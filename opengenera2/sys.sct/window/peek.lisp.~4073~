;;; -*- Syntax: Zetalisp; Mode: Lisp; Package: TV; Base: 8 -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; PEEK -- displays status information about the Lisp Machine

;;; Mode command menus.

(DEFFLAVOR MODE-COMMAND-MENU-MIXIN ((MODE-ITEM NIL) IO-BUFFER (PREVIOUS-MODE-ITEM NIL))
	   (MENU-HIGHLIGHTING-MIXIN)
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES
  (:REQUIRED-FLAVORS BASIC-MENU)
  (:DEFAULT-INIT-PLIST :DEFAULT-STYLE '(:JESS :ITALIC :LARGE))
  (:DOCUMENTATION :MIXIN
   "A mode command menu is a menu, exactly one of whose entries is always
highlighted.  When you click on an item, it becomes the highlighted one,
and a blip is sent to the io-buffer in the style of command menus."))

(DEFMETHOD (:INIT MODE-COMMAND-MENU-MIXIN :AFTER) (&REST IGNORE)
  (IF (NOT (NULL MODE-ITEM))
      (SEND SELF ':SET-MODE-ITEM MODE-ITEM)))

(DEFMETHOD (:SET-MODE-ITEM MODE-COMMAND-MENU-MIXIN) (NEW-MODE-ITEM)
  (IF (NOT (NULL MODE-ITEM))
      (SEND SELF ':REMOVE-HIGHLIGHTED-ITEM MODE-ITEM))
  (SETQ MODE-ITEM NEW-MODE-ITEM)
  (SEND SELF ':ADD-HIGHLIGHTED-ITEM MODE-ITEM))

(DEFMETHOD (:SET-MODE-ITEM MODE-COMMAND-MENU-MIXIN :BEFORE) (IGNORE)
  (SETQ PREVIOUS-MODE-ITEM MODE-ITEM))

(DEFMETHOD (:MOUSE-BUTTONS MODE-COMMAND-MENU-MIXIN :AFTER) (BD IGNORE IGNORE)
  (COND ((NOT (NULL CHOSEN-ITEM))
	 (SEND SELF ':SET-MODE-ITEM CHOSEN-ITEM)
	 (IO-BUFFER-PUT IO-BUFFER `(:MENU ,CHOSEN-ITEM ,BD ,SELF))
	 (SETQ CHOSEN-ITEM NIL))))

(DEFFLAVOR MODE-COMMAND-MENU () (MODE-COMMAND-MENU-MIXIN MENU))

(DEFFLAVOR DYNAMIC-MODE-COMMAND-MENU () (DYNAMIC-ITEM-LIST-MIXIN MODE-COMMAND-MENU))

(DEFFLAVOR BASIC-PEEK ((NEEDS-REDISPLAY NIL) (MODE-ALIST))
   (SCROLL-WINDOW-WITH-DYNAMIC-TYPEOUT)
  :SETTABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES
  (:DEFAULT-INIT-PLIST :MARGIN-COMPONENTS `DW:((MARGIN-RAGGED-BORDERS :THICKNESS 1)
					       (MARGIN-SCROLL-BAR )
					       (MARGIN-WHITE-BORDERS :THICKNESS 2)
					       (MARGIN-LABEL :STRING "Peek"))
		       :TRUNCATION T)
  (:DOCUMENTATION :SPECIAL-PURPOSE "The actual peek window"))

(DEFFLAVOR PEEK-PANE () (PANE-NO-MOUSE-SELECT-MIXIN BASIC-PEEK))

(DEFFLAVOR PEEK-FRAME () (PROCESS-MIXIN INITIALLY-INVISIBLE-MIXIN
			  BORDERED-CONSTRAINT-FRAME-WITH-SHARED-IO-BUFFER)
  (:DEFAULT-INIT-PLIST
   :SAVE-BITS ':DELAYED
   :PANES '((MENU DYNAMIC-MODE-COMMAND-MENU :ITEM-LIST-POINTER PEEK-ITEM-LIST)
	    (PEEK PEEK-PANE))
   :SELECTED-PANE 'PEEK
   :CONSTRAINTS
     '((MAIN . ((MENU PEEK)
		((MENU :ASK :PANE-SIZE))
		((PEEK :EVEN)))))))

(DEFMETHOD (:NAME-FOR-SELECTION PEEK-FRAME) ()
  (STRING-APPEND "Peek"))

(DEFMETHOD (:INIT PEEK-FRAME :BEFORE) (IGNORE)
  (SETQ PROCESS '(PEEK-TOP-LEVEL)))

;;; Add it to the system Create menu
(TV:ADD-TO-SYSTEM-MENU-CREATE-MENU "Peek" 'PEEK-FRAME "Display status information." "Lisp")

(DEFVAR *PEEK-SCROLL-COMMANDS*
	'(#\c-V #\Scroll #\m-V #\m-Scroll #\m-< #\m->))

(DEFMETHOD (:PEEK-KBD-SCROLL PEEK-PANE) (HOW HOW-MUCH)
  (MULTIPLE-VALUE-BIND (TOP-VISIBLE N-VISIBLE MIN-SCROLLABLE MAX-SCROLLABLE)
      (SEND SELF :Y-SCROLL-POSITION)
    (SETQ HOW-MUCH (IF (NUMBERP HOW-MUCH)
		       (* HOW-MUCH (SEND SELF :LINE-HEIGHT))
		     (IF (ZEROP N-VISIBLE)
			 (MULTIPLE-VALUE-BIND (NIL Y-SIZE)
			     (SEND SELF :SIZE)
			   Y-SIZE)
		       N-VISIBLE)))
    (SELECTQ HOW
      ((#\c-V #\Scroll)
       (SEND SELF :Y-SCROLL-TO (+ TOP-VISIBLE HOW-MUCH) :ABSOLUTE))
      ((#\m-V #\m-Scroll)
       (SEND SELF :Y-SCROLL-TO (- TOP-VISIBLE HOW-MUCH) :ABSOLUTE))
      (#\m-<
       (SEND SELF :Y-SCROLL-TO MIN-SCROLLABLE :ABSOLUTE))
      (#\m->
       (SEND SELF :Y-SCROLL-TO (- MAX-SCROLLABLE (* 2 (// N-VISIBLE 3))) :ABSOLUTE)))))

(COMPILE-FLAVOR-METHODS PEEK-FRAME PEEK-PANE DYNAMIC-MODE-COMMAND-MENU)

(DEFVAR PEEK-ITEM-LIST NIL)

(DEFMACRO DEFINE-PEEK-MODE (FUNCTION CHARACTER NAME DOCUMENTATION)
  `(DEFINE-PEEK-MODE-1 ',FUNCTION ',CHARACTER ',NAME ',DOCUMENTATION))

(DEFUN DEFINE-PEEK-MODE-1 (FUNCTION CHARACTER NAME DOCUMENTATION)
  (LET ((ELEM (ASSOC NAME PEEK-ITEM-LIST)))
    (IF ELEM (SETQ PEEK-ITEM-LIST (DELQ ELEM PEEK-ITEM-LIST))))
  (SETQ PEEK-ITEM-LIST
	(APPEND PEEK-ITEM-LIST ;use APPEND, not NCONC, so that it will look different!
	       (NCONS (LIST NAME
			    ':VALUE (LIST FUNCTION CHARACTER NAME DOCUMENTATION)
			    ':DOCUMENTATION DOCUMENTATION)))))
(DEFVAR PEEK-SLEEP-TIME (* 60. 20.))		;20 seconds
(DEFUN PEEK-SET-MODE (WINDOW MODE ARG MENU)
  (WHEN (CHARACTERP MODE)
    (DOLIST (ITEM PEEK-ITEM-LIST)
      (WHEN (CHAR-EQUAL MODE (SECOND (THIRD ITEM)))
	(SETQ MODE (THIRD ITEM))
	(SEND MENU ':SET-MODE-ITEM ITEM)
	(RETURN))))
  (COND ((LISTP MODE)
	 (IF (EQ (CAR MODE) 'PEEK-QUIT)
	     (PROGN (SEND (SEND WINDOW ':SUPERIOR) ':BURY)
		    (SEND MENU ':SET-MODE-ITEM
			  (SEND MENU ':PREVIOUS-MODE-ITEM)))
	     (PEEK-ASSURE-NO-TYPEOUT WINDOW)	 
	     (SEND WINDOW ':SET-LABEL (THIRD MODE))
	     (SEND WINDOW ':SET-DISPLAY-ITEM (FUNCALL (FIRST MODE) ARG)))
	 T)
	(T NIL)))
;;; This is similar to System-P.  The character gets typed at Peek to put it in
;;; some mode; it is P by default.  If you pass NIL, it doesn't change modes.
(DEFUN PEEK (&OPTIONAL (CHARACTER 'P))
  (LET ((FRAME (OR (FIND-WINDOW-OF-FLAVOR 'PEEK-FRAME)
		   (MAKE-WINDOW 'PEEK-FRAME))))
    (COND (CHARACTER
	   (SEND (SEND FRAME ':GET-PANE 'PEEK)
		 ':FORCE-KBD-INPUT
		 (CHAR-UPCASE (CHARACTER CHARACTER)))))
    (SEND FRAME ':MOUSE-SELECT)))
(DEFUN PEEK-TOP-LEVEL (FRAME)
  (SI:WITH-PROCESS-INTERACTIVE-PRIORITY ()
    (SI:WITH-COMMAND-LOOP-VARIABLE-BINDINGS
      (LET* ((PEEK-WINDOW (SEND FRAME ':GET-PANE 'PEEK))
	     (MENU-WINDOW (SEND FRAME ':GET-PANE 'MENU))
	     (TERMINAL-IO (SEND PEEK-WINDOW ':TYPEOUT-WINDOW)))
	(PEEK-SET-MODE PEEK-WINDOW #\HELP NIL MENU-WINDOW)
	(DO ((SLEEP-TIME PEEK-SLEEP-TIME)
	     (WAKEUP-TIME (TIME-INCREMENT (TIME) PEEK-SLEEP-TIME))
	     (ARG))
	    (())
	  (CATCH-ERROR-RESTART ((ERROR ABORT) "Peek Top Level")
	    (AND (TIME-LESSP WAKEUP-TIME (TIME))
		 (SETQ WAKEUP-TIME (TIME-INCREMENT (TIME) SLEEP-TIME)))
	    (IF (PLUSP SLEEP-TIME)
		(PROCESS:PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION
		  "Tyi or Timeout"
		  .5 ;; 1/2 second is fine.
		  #'(LAMBDA (TIME FLAG-LOC STREAM)
		      (NOT (NULL
			     (OR (TIME-LESSP TIME (TIME))
				 (CAR FLAG-LOC)
				 (SEND STREAM ':LISTEN)))))
		  WAKEUP-TIME
		  (LOCATE-IN-INSTANCE PEEK-WINDOW 'NEEDS-REDISPLAY)
		  TERMINAL-IO))
	    (LABELS ((CANT-DEBUG-SIMPLE-PROCESS (PROCESS)
		       (FORMAT T "~&Cannot debug ~S because it is a simple-process.~@
			     It has no saved state, just a function to call when it wakes up."
			       PROCESS))
		     (PEEK-BODY ()
		       ;; If the frame is now deexposed, wait for it to become exposed
		       (COND ((NOT (SEND FRAME :EXPOSED-P))
			      (SI:WITH-PROCESS-INTERACTIVE-PRIORITY ()
				;; So when we get exposed again we start up right away.
				(PROCESS:PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION
				  "Wait for exposure"
				  0.5 ;; 1/2 a second is fine.
				  FRAME ':EXPOSED-P)
				(SETQ WAKEUP-TIME (TIME)))))	;Wakeup now if deexposed.
		       ;; Have new PEEK items been defined?
		       (COND ((NOT (EQUAL PEEK-ITEM-LIST (SEND MENU-WINDOW ':ITEM-LIST)))
			      (SEND FRAME ':SET-CONFIGURATION 'MAIN)))
		       (DO () (())
			 (PEEK-ASSURE-NO-TYPEOUT PEEK-WINDOW)
			 (LET ((CHAR (SEND TERMINAL-IO ':ANY-TYI-NO-HANG)))
			   (COND ((NULL CHAR)
				  (RETURN))
				 ((CHARACTERP CHAR)
				  ;; Keyboard character, either accumulate arg
				  ;; or select new mode
				  (SETQ CHAR (CHAR-UPCASE CHAR))
				  (COND ((DIGIT-CHAR-P (CODE-CHAR (CHAR-CODE CHAR)))
					 (IF (NULL ARG) (SETQ ARG 0))
					 (SETQ ARG
					       (+ (* 10. ARG)
						  (DIGIT-CHAR-P
						    (CODE-CHAR (CHAR-CODE CHAR))))))
					((CHAR-EQUAL CHAR #/Z)
					 ;; Set the sleep-time, in seconds.
					 (AND ARG (SETQ SLEEP-TIME (* 60. ARG)))
					 ;; Wake up that many seconds from now.
					 (SETQ WAKEUP-TIME (+ (TIME) SLEEP-TIME))
					 (SETQ ARG NIL))
					((MEM #'CHAR-EQUAL CHAR *PEEK-SCROLL-COMMANDS*)
					 (SEND PEEK-WINDOW :PEEK-KBD-SCROLL CHAR ARG)
					 (SETQ ARG NIL))
					(T (SETQ ARG NIL)
					   (COND ((PEEK-SET-MODE PEEK-WINDOW CHAR ARG
								 MENU-WINDOW))
						 ((CHAR-EQUAL CHAR #/Q)
						  (SEND FRAME ':BURY))
						 ((CHAR-EQUAL CHAR #\SPACE)
						  (SEND PEEK-WINDOW ':SET-NEEDS-REDISPLAY T))
						 (T (BEEP))))))
				 ((LISTP CHAR)
				  ;; A special command (forced input, no doubt)
				  (SELECTQ (CAR CHAR)
				    (:EXECUTE (SEND PEEK-WINDOW ':EXECUTE (SECOND CHAR)))
				    (:MENU (PEEK-SET-MODE PEEK-WINDOW
							  (SEND PEEK-WINDOW ':EXECUTE
								(SECOND CHAR))
							  ARG
							  MENU-WINDOW))
				    (REMOTE-LOGIN
				     (SEND (TELNET:GET-NVT-WINDOW-TO-HOST (SECOND CHAR))
					   ':SELECT))
				    (QSEND
				     (ZWEI:QSEND-MSG (FORMAT NIL "Anyone@~A" (SECOND CHAR)))
				     (SEND PEEK-WINDOW ':SET-NEEDS-REDISPLAY T)
				     (SEND TERMINAL-IO ':MAKE-COMPLETE))
				    (SHOW-USERS (NET:FINGER NIL STANDARD-OUTPUT ':HOST
							    (SECOND CHAR)))
				    (DBG (LET ((PROCESS (SECOND CHAR)))
					   (IF (and (SI:PROCESS-SIMPLE-P PROCESS)
						    (not (typep (si:process-stack-group process) :stack-group)))
					       (CANT-DEBUG-SIMPLE-PROCESS PROCESS)
					     (DBG PROCESS))))
				    (DESCRIBE (DESCRIBE (SECOND CHAR)))
				    (SEND (LEXPR-SEND PEEK-WINDOW (CADR CHAR) (CDDR CHAR)))
				    (FUNCALL (APPLY (CADR CHAR) (CDDR CHAR)))
				    (OTHERWISE (BEEP)))
				  (SETQ ARG NIL)))))
		       (COND ((OR (SEND PEEK-WINDOW ':NEEDS-REDISPLAY)
				  (TIME-LESSP WAKEUP-TIME (TIME)))
			      ;; We want to redisplay.  If have typeout,
			      ;; hang until user confirms.
			      (SEND PEEK-WINDOW ':SET-NEEDS-REDISPLAY NIL)
			      (SEND PEEK-WINDOW ':REDISPLAY)))))
	      (IF (SEND TERMINAL-IO :LISTEN)
		  (PEEK-BODY)
		(SI:WITH-PROCESS-NON-INTERACTIVE-PRIORITY (:QUANTUM-BOOST NIL)
		  (PEEK-BODY))))))))))

(DEFUN PEEK-ASSURE-NO-TYPEOUT (WINDOW)
  (COND ((SEND (SETQ WINDOW (SEND WINDOW ':TYPEOUT-WINDOW)) ':INCOMPLETE-P)
	 (FORMAT T "~&Type any character to flush:")
	 (LET ((CHAR (SEND TERMINAL-IO ':ANY-TYI)))
	   (SEND WINDOW ':MAKE-COMPLETE)
	   (SEND TERMINAL-IO ':UNTYI CHAR)))))

(ADD-INITIALIZATION "Reconfigure Peek"
		    '(LET ((PEEK (FIND-WINDOW-OF-FLAVOR 'PEEK-FRAME)))
		       (WHEN PEEK (SEND PEEK ':SET-CONFIGURATION 'MAIN)))
		    '(:BEFORE-COLD))

;;; General utility functions.  Maybe someday these should be for all scroll windows?

(DEFUN PEEK-MOUSE-CLICK (ITEM LEADER-TO-COMPLEMENT)
  (SEND *SCROLL-WINDOW* :SET-NEEDS-REDISPLAY T)
  (SETF (ARRAY-LEADER ITEM (+ SCROLL-ITEM-LEADER-OFFSET LEADER-TO-COMPLEMENT))
	(NOT (ARRAY-LEADER ITEM (+ SCROLL-ITEM-LEADER-OFFSET LEADER-TO-COMPLEMENT)))))

(DEFUN PEEK-HIDDEN-DATA (DOCUMENTATION HIDDEN-ITEM &REST UNHIDDEN-ITEM-SPECS)
  "Returns a scroll window item which can be moused to show more detailed information"
  (LET ((INITIALLY-VISIBLE NIL))
    (WHEN (EQ (CAR UNHIDDEN-ITEM-SPECS) :INITIALLY-VISIBLE)
      (SETQ INITIALLY-VISIBLE (CADR UNHIDDEN-ITEM-SPECS))
      (SETQ UNHIDDEN-ITEM-SPECS (CDDR UNHIDDEN-ITEM-SPECS)))
    `((:PRE-PROCESS-FUNCTION PEEK-HIDDEN-DATA-FUNCTION)
      ,(IF INITIALLY-VISIBLE
	   (LEXPR-FUNCALL #'TV:SCROLL-PARSE-ITEM
			  :MOUSE-SELF `(NIL :EVAL (PEEK-MOUSE-CLICK 'SELF 0)
					    :DOCUMENTATION ,DOCUMENTATION)
			  :LEADER `(NIL (,HIDDEN-ITEM))
			  UNHIDDEN-ITEM-SPECS
			  HIDDEN-ITEM)
	   (LEXPR-FUNCALL #'TV:SCROLL-PARSE-ITEM
			  :MOUSE-SELF `(NIL :EVAL (PEEK-MOUSE-CLICK 'SELF 0)
					    :DOCUMENTATION ,DOCUMENTATION)
			  :LEADER `(NIL (,HIDDEN-ITEM))
			  UNHIDDEN-ITEM-SPECS)))))

(DEFUN PEEK-HIDDEN-DATA-FUNCTION (ITEM)
  (COND ((NULL (ARRAY-LEADER (CADR ITEM) TV:SCROLL-ITEM-LEADER-OFFSET)))
	;; Clicked on this item, need to complement state
	((= (LENGTH ITEM) 2)
	 ;; If aren't displaying optional stuff, display it.
	 (SETF (REST2 ITEM) (ARRAY-LEADER (CADR ITEM) (1+ TV:SCROLL-ITEM-LEADER-OFFSET))))
	;;If we are, get rid of it.
	(T (SETF (REST2 ITEM) NIL)))
  (SETF (ARRAY-LEADER (CADR ITEM) TV:SCROLL-ITEM-LEADER-OFFSET) NIL))
(DEFVAR *PEEK-COUNTER-INTERVALS* (LIST (* 60. 5) (* 60. 30.) (* 60. 60. 5)))

;;; Processes, meters
(DEFINE-PEEK-MODE PEEK-PROCESSES #/P "Processes"
   "Show all active processes, their states, priorities, idle times, pct's, etc.")
(DEFVAR *PERCENT-UTILIZATION-INTERVALS*
	(LIST (* 1000000. 3) (* 1000000. 30.))) ; (* 1000000. 60.) (* 1000000. 60. 5)))
(DEFUN PEEK-UPDATE-PROCESS-PERCENTAGES (PROCESS ITEM)
  (LET (DISK-TIME RUN-TIME RUNNABLE-TIME NOW
	(SCHEDULER-INFO (ARRAY-LEADER ITEM SCROLL-ITEM-LEADER-OFFSET)))
    (when (null scheduler-info)
      (setf scheduler-info (make-array (* 8 (length *PERCENT-UTILIZATION-INTERVALS*))))
      (setf (ARRAY-LEADER ITEM SCROLL-ITEM-LEADER-OFFSET) scheduler-info))
    (WITHOUT-INTERRUPTS
      (SETQ DISK-TIME (PROCESS::PROCESS-DISK-WAIT-TIME PROCESS)
	    RUN-TIME (PROCESS::PROCESS-RUN-TIME-LOW PROCESS)
	    RUNNABLE-TIME (PROCESS::PROCESS-RUNNABLE-TIME PROCESS)
	    NOW (sys:%microsecond-clock)))
    (LOOP FOR INTERVALs oN *PERCENT-UTILIZATION-INTERVALS*
	  as interval = (car intervals)
	  as next-interval = (or (cadr intervals) (* 5 interval))
	  FOR LEADER-OFFSET FROM 0 BY 8
	  DO (LET ((TIME-UPDATED (AREF SCHEDULER-INFO LEADER-OFFSET)))
	       (COND ((NULL TIME-UPDATED)
		      (SETF (AREF SCHEDULER-INFO LEADER-OFFSET) NOW)
		      (SETF (AREF SCHEDULER-INFO (1+ LEADER-OFFSET)) DISK-TIME)
		      (SETF (AREF SCHEDULER-INFO (+ LEADER-OFFSET 2)) RUN-TIME)
		      (SETF (AREF SCHEDULER-INFO (+ LEADER-OFFSET 3)) RUNNABLE-TIME))
		     ((LET ((ELAPSED (TIME-DIFFERENCE NOW TIME-UPDATED)))
			;; detect wraparound, too.
			(OR (MINUSP ELAPSED) (> ELAPSED NEXT-INTERVAL)))
		      (SETF (AREF SCHEDULER-INFO (+ LEADER-OFFSET 4)) NIL)
		      (SETF (AREF SCHEDULER-INFO (+ LEADER-OFFSET 5)) NIL)
		      (SETF (AREF SCHEDULER-INFO (+ LEADER-OFFSET 6)) NIL)
		      (SETF (AREF SCHEDULER-INFO (+ LEADER-OFFSET 7)) NIL)
		      (SETF (AREF SCHEDULER-INFO LEADER-OFFSET) NOW)
		      (SETF (AREF SCHEDULER-INFO (1+ LEADER-OFFSET)) DISK-TIME)
		      (SETF (AREF SCHEDULER-INFO (+ LEADER-OFFSET 2)) RUN-TIME)
		      (SETF (AREF SCHEDULER-INFO (+ LEADER-OFFSET 3)) RUNNABLE-TIME))
		     (( (TIME-DIFFERENCE NOW TIME-UPDATED) INTERVAL)
		      (SETF (AREF SCHEDULER-INFO (+ LEADER-OFFSET 4)) TIME-UPDATED)
		      (SETF (AREF SCHEDULER-INFO (+ LEADER-OFFSET 5))
			    (AREF SCHEDULER-INFO (1+ LEADER-OFFSET)))
		      (SETF (AREF SCHEDULER-INFO (+ LEADER-OFFSET 6))
			    (AREF SCHEDULER-INFO (+ LEADER-OFFSET 2)))
		      (SETF (AREF SCHEDULER-INFO (+ LEADER-OFFSET 7))
			    (AREF SCHEDULER-INFO (+ LEADER-OFFSET 3)))
		      (SETF (AREF SCHEDULER-INFO LEADER-OFFSET) NOW)
		      (SETF (AREF SCHEDULER-INFO (1+ LEADER-OFFSET)) DISK-TIME)
		      (SETF (AREF SCHEDULER-INFO (+ LEADER-OFFSET 2)) RUN-TIME)
		      (SETF (AREF SCHEDULER-INFO (+ LEADER-OFFSET 3)) RUNNABLE-TIME)))))))
(DEFUN PEEK-PROGRESS-NOTE (PROCESS)
  (LET ((NOTE (CL:FIND PROCESS *PROGRESS-NOTES* :KEY #'PROGRESS-NOTE-PROCESS)))
    (WHEN NOTE
      (PROGRESS-NOTE-NAME NOTE))))
(DEFUN PEEK-PROCESSES (IGNORE)
  "Shows state of all active processes."
  (LET ((NAME-WIDTH (MIN (1+ (LOOP FOR PROCESS IN PROCESS::*ALL-PROCESSES*
				   MAXIMIZE (STRING-LENGTH (SEND PROCESS :NAME))))
			 ;; Make an initial guess based on processes that exist when we start.
			 (IF process::*show-detailed-process-utilization* 30 72))))
    (LIST ()
	;; 30/72 of process name, 25 of state, 12 of priority, 8 of idle time, followed by N of
	;; percentages (23 (7+7+9) times M intervals, 3 columns per interval)
	(SCROLL-PARSE-ITEM
	  (if process::*show-detailed-process-utilization*
	      (FORMAT NIL "~vA~25A~10A~9A~7A~7A~9A" NAME-WIDTH
		      "Process Name" "State" "Priority" "  Idle" "  real%" "   %cpu" " % page")
	      (format nil "~vA~25A~10A~9A~14A" NAME-WIDTH
		      "Process Name" "State" "Priority" "  Idle" " % utilization")))
	(SCROLL-PARSE-ITEM "")
	(SCROLL-MAINTAIN-LIST #'(LAMBDA () (COPYLIST PROCESS::*ALL-PROCESSES*))
			      #'(LAMBDA (PROCESS)
				  (if process::*show-detailed-process-utilization*
				      (SCROLL-PARSE-ITEM
					`(:MOUSE-ITEM
					   (NIL :KBD (SEND :PROCESS-MENU ,PROCESS)
						:DOCUMENTATION
						"Menu of useful things to do to this process.")
					   :FUNCTION ,PROCESS (:NAME) ,NAME-WIDTH)
					`(:FUNCTION ,#'PEEK-TRUNCATED-STRING
					  (PEEK-process-WHOSTATE 25. ,PROCESS) 25.)
					`(:FUNCTION peek-PROCESS-PRIORITY (,PROCESS) 11.
						    ("~A "))
					`(:FUNCTION process::process-idle-time (,process) 9.
						    ("~\PEEK-PROCESS-IDLE-TIME\ "))

					`(:FUNCTION process::percent-utilization (,process) 7.
						    ("~:[     ~;~:*~1,1,5$%~]"))
					`(:FUNCTION process::percent-cpu (,process) 7.
						    ("~:[     ~;~:*~1,1,5$%~]"))
					`(:FUNCTION process::percent-paging (,process) 9.
						    ("~:[     ~;~:*~1,1,5$%~]")))
				      (SCROLL-PARSE-ITEM
					`(:MOUSE-ITEM
					   (NIL :KBD (SEND :PROCESS-MENU ,PROCESS)
						:DOCUMENTATION
						"Menu of useful things to do to this process.")
					   :FUNCTION ,PROCESS (:NAME) ,NAME-WIDTH)
					`(:FUNCTION ,#'PEEK-TRUNCATED-STRING
					  (PEEK-process-WHOSTATE 25. ,PROCESS) 25.)
					`(:FUNCTION peek-PROCESS-PRIORITY (,PROCESS) 11.
						    ("~A "))
					`(:FUNCTION process::process-idle-time (,process) 9.
						    ("~\PEEK-PROCESS-IDLE-TIME\ "))

					`(:FUNCTION process::percent-utilization (,process) 7.
						    ("~:[     ~;~:*~1,1,5$%~]"))
					`(:FUNCTION PEEK-PROGRESS-NOTE (,PROCESS) nil
						("~@[~A~]")))
				  
				  ))
			      NIL
			      #'(LAMBDA (STATE)
				  (VALUES (CAR STATE) (CDR STATE) (NULL (CDR STATE)))))
	(SCROLL-PARSE-ITEM "")
	(PROCESS::PEEK-AT-TIMERS)
	(SCROLL-PARSE-ITEM "")
	(SI:PEEK-AT-TIMERS)
	(SCROLL-PARSE-ITEM "")
	(SCROLL-PARSE-ITEM "Clock function list")
	(SCROLL-MAINTAIN-LIST #'(LAMBDA () SI:CLOCK-FUNCTION-LIST)
			      #'(LAMBDA (FUNC)
				  (SCROLL-PARSE-ITEM
				    `(:STRING ,(WITH-OUTPUT-TO-STRING (STANDARD-OUTPUT)
						 (PRINC FUNC))))))
	)))
;; RUN-TIME over REAL-TIME
(DEFUN PEEK-PROCESS-PORTION-OF-MACHINE (ITEM INTERVAL)
  (LET* ((scheduler-info (array-leader item scroll-item-leader-offset))
	 (LEADER-OFFSET (* INTERVAL 8))
	 (OLD-TIME (AREF SCHEDULER-INFO (+ LEADER-OFFSET 4))))
    (WHEN OLD-TIME
      (LET ((DENOM (SYS:%32-BIT-DIFFERENCE (AREF SCHEDULER-INFO LEADER-OFFSET) OLD-TIME)))
	(IF (ZEROP DENOM)
	    0.0
	    (* 100.0
	       (FLOAT (scl:// (SYS:%32-BIT-DIFFERENCE (AREF SCHEDULER-INFO (+ LEADER-OFFSET 2))
						      (AREF SCHEDULER-INFO (+ LEADER-OFFSET 6)))
			      DENOM))))))))
;; RUN-TIME over RUNNABLE-TIME
(DEFUN PEEK-PROCESS-EFFECTIVE-CPUS (ITEM INTERVAL)
  (LET* ((scheduler-info (array-leader item scroll-item-leader-offset))
	 (LEADER-OFFSET (* INTERVAL 8))
	 (OLD-RUNNABLE-TIME (AREF SCHEDULER-INFO (+ LEADER-OFFSET 7))))
    (when OLD-RUNNABLE-TIME
      (LET ((DENOM (SYS:%32-BIT-DIFFERENCE (AREF SCHEDULER-INFO (+ LEADER-OFFSET 3))
					   OLD-RUNNABLE-TIME)))
	(IF (ZEROP DENOM)
	    100.0
	    (* 100.0
	       (FLOAT (scl://
			(SYS:%32-BIT-DIFFERENCE (AREF SCHEDULER-INFO (+ LEADER-OFFSET 2))
						(AREF SCHEDULER-INFO (+ LEADER-OFFSET 6)))
			DENOM))))))))
;; DISK-WAIT-TIME over RUN-TIME
(DEFUN PEEK-PROCESS-PERCENT-PAGE-WAITING (ITEM INTERVAL)
  (LET* ((scheduler-info (array-leader item scroll-item-leader-offset))
	 (LEADER-OFFSET (* INTERVAL 8))
	 (OLD-RUN-TIME (AREF SCHEDULER-INFO (+ LEADER-OFFSET 6))))
    (when OLD-RUN-TIME
      (LET ((DENOM (SYS:%32-BIT-DIFFERENCE (AREF SCHEDULER-INFO (+ LEADER-OFFSET 2))
					   OLD-RUN-TIME)))
	(IF (ZEROP DENOM)
	    0.0
	    (* 100.0
	       (FLOAT (scl://
			(- (AREF SCHEDULER-INFO (+ LEADER-OFFSET 1))
			   (AREF SCHEDULER-INFO (+ LEADER-OFFSET 5)))
			DENOM))))))))
(FORMAT:DEFFORMAT FORMAT:PEEK-PROCESS-IDLE-TIME (:ONE-ARG) (ARG IGNORE)
  (LET ((ARG (AND ARG (FLOOR ARG 60.))))
    (COND ((NULL ARG) (SEND FORMAT:*FORMAT-OUTPUT* ':STRING-OUT " forever"))
	  ((ZEROP ARG) (SEND FORMAT:*FORMAT-OUTPUT* ':STRING-OUT "        "))
	  ((< ARG 60.) (FORMAT FORMAT:*FORMAT-OUTPUT* "~3D sec" ARG))
	  ((< ARG 3600.) (FORMAT FORMAT:*FORMAT-OUTPUT* "~3D min" (floor ARG 60.)))
	  (T (FORMAT FORMAT:*FORMAT-OUTPUT* "~4D hr" (floor ARG 3600.))))))

(DEFUN PEEK-TRUNCATED-STRING (FUNCTION WIDTH &REST ARGS)
  (LET ((STRING (APPLY FUNCTION ARGS)))
    (IF (> (STRING-LENGTH STRING) WIDTH)
	(SUBSTRING STRING 0 WIDTH)
	STRING)))
(DEFUN PEEK-MEMORY-HEADER ()
  (SCROLL-PARSE-ITEM
      "Physical memory: "
      `(:FUNCTION ,#'(LAMBDA (&AUX (VAL (* SI:*COUNT-USABLE-PAGES* PAGE-SIZE)))
		       (SETF (VALUE 0) (// VAL 2000))
		       VAL)
		  NIL NIL (NIL 8.))
      `(:VALUE 0 NIL (" (~DK), "))
      "Swapping space remaining: "
      `(:FUNCTION ,#'(LAMBDA (&AUX (VAL (* (SI:SWAP-SPACE-AVAILABLE) PAGE-SIZE)))
		       (SETF (VALUE 0) (// VAL 2000))
		       VAL)
		  NIL NIL (NIL 8.))
      `(:VALUE 0 NIL (" (~DK)"))
      ", Wired pages "
      `(:FUNCTION ,#'(LAMBDA ()
		       (LET ((N-WIRED-PAGES SI:*COUNT-WIRED-PAGES*))
			 (SETF (VALUE 1) (// N-WIRED-PAGES (// 2000 PAGE-SIZE)))
			 (SETF (VALUE 2) (\ N-WIRED-PAGES (// 2000 PAGE-SIZE)))
			 N-WIRED-PAGES))
		  NIL NIL ("~D"))
      `(:VALUE 1 NIL (" (~D"))
      `(:VALUE 2 NIL ("~[~;.25~;.5~;.75~]K)"))))
(DEFUN PEEK-REGION-HEADER ()
  (SCROLL-PARSE-ITEM
      "Regions in use: "
      `(:FUNCTION ,#'(LAMBDA () (- NUMBER-OF-REGIONS (SI:NUMBER-OF-FREE-REGIONS)))
		  NIL NIL (NIL 10.))
      ", Regions remaining: "
      `(:FUNCTION SI:NUMBER-OF-FREE-REGIONS NIL NIL (NIL 10.))))
(DEFINE-PEEK-MODE PEEK-AREAS #/A "Areas"
   "Show all the areas in virtual memory, their types, allocation, etc.")
(DEFUN PEEK-AREAS (IGNORE)
  "Areas"
  (LIST ()
	(PEEK-MEMORY-HEADER)
	(PEEK-REGION-HEADER)
	(SCROLL-PARSE-ITEM "")
	(SCROLL-MAINTAIN-LIST
	  #'(LAMBDA () 0)
	  #'(LAMBDA (AREA)
	      (PEEK-HIDDEN-DATA
		"Insert//remove detail for this area."
		(PEEK-LEVELS-AND-REGIONS AREA) 
		`(:STRING ,(STRING (AREA-NAME AREA)) 40.)
		`(:FUNCTION ,#'(LAMBDA (AREA)
				 (MULTIPLE-VALUE-BIND (LENGTH USED N-REGIONS)
				     (SI:ROOM-GET-AREA-LENGTH-USED AREA)
				   (SETF (VALUE 0) USED)
				   (SETF (VALUE 1) LENGTH)
				   (SETF (VALUE 2)
					 (COND ((ZEROP LENGTH) 0)
					       ((< LENGTH 40000)
						(// (* 100. (- LENGTH USED)) LENGTH))
					       (T
						(// (- LENGTH USED) (// LENGTH 100.)))))
				   N-REGIONS))
		  (,AREA) 15. ("(~D region~:P)"))
		`(:VALUE 2 NIL ("~@3A% free, " 10. T))
		`(:VALUE 0 NIL ("~8O"))
		`(:VALUE 1 NIL ("//~O used"))))
	  NIL
	  #'(LAMBDA (STATE)
	      (PROG (NEXT-ONE THIS-ONE
		     (LEN (SI:N-AREAS)))
		    (DO ((I STATE (1+ I)))
			(( I LEN) NIL)
		      (COND ((AND (NULL THIS-ONE) (AREA-NAME I))
			     (SETQ THIS-ONE I))
			    ((AND THIS-ONE (AREA-NAME I))
			     (SETQ NEXT-ONE I)
			     (RETURN T))))
		    (RETURN (VALUES THIS-ONE NEXT-ONE (NULL NEXT-ONE))))))
	))
(DEFINE-PEEK-MODE PEEK-METERS #/M "Meters"
   "Show storage, disk, and GC meters.")
(DEFVAR *PEEK-METERS* NIL "Global registry of meters that Peek displays.")

(DEFPROP DEFINE-PEEK-METER "Peek Meter" SI:DEFINITION-TYPE-NAME)
(DEFMACRO DEFINE-PEEK-METER (NAME ARGLIST &BODY BODY)
  `(PROGN (RECORD-SOURCE-FILE-NAME ',NAME 'DEFINE-PEEK-METER)
	  (CL:PUSHNEW ',NAME *PEEK-METERS*)
	  (DEFUN (:PROPERTY ,NAME PEEK-METER) ,ARGLIST
	    (DECLARE (SYS:FUNCTION-PARENT ,NAME DEFINE-PEEK-METER))
	    ,@BODY)))
(DEFPROP DEFINE-PEEK-METER UNDEFINE-PEEK-METER ZWEI:KILL-DEFINITION)

(DEFUN UNDEFINE-PEEK-METER (NAME)
  (FUNDEFINE NAME)
  (SI:NREMPROP NAME 'PEEK-METER)
  (SETQ *PEEK-METERS* (CL:DELETE NAME *PEEK-METERS*))
  NAME)
(DEFINE-PEEK-METER STORAGE-METERS ()
  (TV:PEEK-HIDDEN-DATA
    "Show//Hide storage meters"
    (SCROLL-MAINTAIN-LIST #'(LAMBDA () (LIST* #+3600 'SYS:%COUNT-MAP-RELOADS
					      SI:*STORAGE-METERS*))
			  #'PEEK-DISPLAY-COUNTER)
    "Storage meters"))
(DEFINE-PEEK-METER GC-METERS ()
  (TV:PEEK-HIDDEN-DATA
    "Show//Hide GC meters"
    (SCROLL-MAINTAIN-LIST #'(LAMBDA () SI:*GC-METERS*)
			  #'PEEK-DISPLAY-COUNTER)
    "GC meters"))
(DEFINE-PEEK-METER DISK-METERS ()
  (TV:PEEK-HIDDEN-DATA
    "Show//Hide disk meters"
    (SCROLL-MAINTAIN-LIST
      #'(LAMBDA ()
	  (APPEND SI:*DISK-METERS*
		  #+3600 (SELECTQ SYS:*IO-BOARD-TYPE*
			   (:OBS SI:*OBS-DISK-METERS*)
			   (:NBS CLI::*NBS-DISK-METERS*))))
      #'PEEK-DISPLAY-COUNTER)
    "Disk meters"))
(DEFINE-PEEK-METER ZWEI-SECTIONIZATION-METERS ()
  (TV:PEEK-HIDDEN-DATA
    "Show//Hide ZWEI sectionization meters"
    (SCROLL-MAINTAIN-LIST #'(LAMBDA () ZWEI:*SECTIONIZATION-METERS*)
			  #'PEEK-DISPLAY-COUNTER)
    "ZWEI Sectionization meters")) 

#-IMACH
(define-peek-meter netboot-meters ()
  (tv:peek-hidden-data
    "Show/Hide netboot meters"
    (scroll-maintain-list #'(lambda () netboot::*netboot-user-meters*)
			  #'peek-display-counter)
    "Netboot meters"))

(DEFUN PEEK-METERS (IGNORE)
  "Meters"
  (LOOP WITH LIST = NIL
	FOR ITEM IN *PEEK-METERS*
	DOING (PUSH (FUNCALL (GET ITEM 'PEEK-METER)) LIST)
	      (PUSH (SCROLL-PARSE-ITEM "") LIST)
	FINALLY (RETURN (PUSH NIL LIST))))D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB") 

0(DEFVAR PEEK-LEVELS-AND-REGIONS NIL)		;Kludgey cache to make redisplay work!

(DEFUN PEEK-LEVELS-AND-REGIONS (AREA)
  (SCROLL-MAINTAIN-LIST
    ;; State is list of levels in sorted order, where each level is represented by
    ;; a list of area, index, level until we run out of ephemeral levels, then
    ;; it's a region number.  The elements of this list have to be canonicalized
    ;; because scroll redisplay compares them with EQ.  Gad this sucks.
    ;; I know this function conses up the wazoo.  Too damned bad.
    #'(LAMBDA (AREA)
	(LET ((LEVELS NIL))
	  ;; Include all levels that have extant regions
	  (SI:DO-AREA-REGIONS (REGION AREA)
	    (LET ((LEVEL (LDB %%REGION-LEVEL (REGION-BITS REGION))))
	      (WHEN (SI:EPHEMERAL-LEVEL-P LEVEL)
		(CL:PUSHNEW LEVEL LEVELS))))
	  (LET ((START (OR (CADR (ASSQ (AREA-NAME AREA) SI:*EPHEMERAL-AREAS*))
			   (LDB %%REGION-LEVEL (AREA-REGION-BITS AREA)))))
	    (DECLARE (SPECIAL START))
	    ;; Make sure all levels in the object progression are mentioned,
	    ;; even if empty
	    (DO ((LEVEL START (AREF SI:*EPHEMERAL-GC-KEEP-NEXT-LEVEL* LEVEL)))
		((NOT (SI:EPHEMERAL-LEVEL-P LEVEL)))
	      (CL:PUSHNEW LEVEL LEVELS))
	    (APPEND (AND LEVELS
			 ;; Sort levels in order of object progression, with any levels that 
			 ;; are no longer in the progression at the end, and level 0 (dynamic)
			 ;; at the very end.
			 (LOOP FOR LEVEL IN (NCONC (SORT LEVELS
				#'(LAMBDA (X Y)
				    (DO ((LEVEL START (AREF SI:*EPHEMERAL-GC-KEEP-NEXT-LEVEL*
							    LEVEL)))
					((NOT (SI:EPHEMERAL-LEVEL-P LEVEL)) NIL)
				      (WHEN (= LEVEL X) (RETURN T))
				      (WHEN (= LEVEL Y) (RETURN NIL)))))
						   `(,SI:%DYNAMIC-LEVEL))
			       ;; Cons up the result which has to encode all the information
			       ;; that is going to be needed later and canonicalize it so that
			       ;; the scroll-window redisplay EQ tests will work.
			       FOR INDEX FROM 1
			       AS DATA = (LIST AREA INDEX LEVEL)
			       COLLECT (CAR (OR (MEMBER DATA PEEK-LEVELS-AND-REGIONS)
						(PUSH DATA PEEK-LEVELS-AND-REGIONS)))))
		    (LET ((REGIONS NIL))
		      (SI:DO-AREA-REGIONS (REGION AREA)
			(LET ((DATA (LIST AREA NIL REGION)))
			  (PUSH (CAR (OR (MEMBER DATA PEEK-LEVELS-AND-REGIONS)
					 (PUSH DATA PEEK-LEVELS-AND-REGIONS)))
				REGIONS)))
		      REGIONS)))))
    ;; Display for one level or one region
    #'(LAMBDA (STATE)
	(LET ((AREA (FIRST STATE))
	      (INDEX (SECOND STATE))
	      (LEVEL (THIRD STATE)))
	  (IF INDEX
	      ;; Display for one level
	      (SCROLL-PARSE-ITEM
		`(:STRING
		  ,(FORMAT NIL "  ~:[~*Last (dynamic)~;~:(~:R~) ephemeral~] level: "
			   (SI:EPHEMERAL-LEVEL-P LEVEL) LEVEL INDEX))
		`(:FUNCTION ,#'(LAMBDA (AREA LEVEL)
				 (MULTIPLE-VALUE-BIND (LENGTH USED N-REGIONS)
				     (SI:ROOM-GET-AREA-LENGTH-USED AREA LEVEL)
				   (IGNORE LENGTH USED)
				   N-REGIONS))
			    (,AREA ,LEVEL) NIL ("~D region~:P, "))
		(WHEN (SI:EPHEMERAL-LEVEL-P LEVEL)
		  `(:FUNCTION ,#'(LAMBDA (LEVEL)
				   (CEILING (AREF SI:*EPHEMERAL-GC-FLIP-CAPACITY* LEVEL)
					    2000))
			      (,LEVEL) NIL ("capacity ~DK, ")))
		`(:FUNCTION ,#'(LAMBDA (AREA LEVEL)
				 (MULTIPLE-VALUE-BIND (LENGTH)
				     (SI:ROOM-GET-AREA-LENGTH-USED AREA LEVEL)
				   (CEILING LENGTH 2000)))
			    (,AREA ,LEVEL) NIL ("~DK allocated, "))
		`(:FUNCTION ,#'(LAMBDA (AREA LEVEL)
				 (MULTIPLE-VALUE-BIND (LENGTH USED)
				     (SI:ROOM-GET-AREA-LENGTH-USED AREA LEVEL)
				   (IGNORE LENGTH)
				   (CEILING USED 2000)))
			    (,AREA ,LEVEL) NIL ("~DK used.")))
	      ;; Display for one region
	      (LET ((REGION LEVEL))
		(SCROLL-PARSE-ITEM
		  `(:STRING
		    ,(FORMAT NIL "  Region #~O:" REGION))
		  `(:FUNCTION ,(FUNCTION REGION-ORIGIN)		  
		    (,REGION) NIL ("Origin ~\si:address\, "))
		  `(:FUNCTION ,#'REGION-LENGTH (,REGION) NIL ("Length ~O, "))
		  `(:FUNCTION ,#'REGION-FREE-POINTER (,REGION) NIL ("Used ~O, "))
		  `(:FUNCTION ,#'REGION-GC-POINTER (,REGION) NIL ("GC ~O, "))
		  `(:FUNCTION ,#'REGION-BITS (,REGION) NIL ("~\SI:REGION-BITS\"))
		  )))))
    ;; No per-elt-fun
    NIL
    ;; Stepper
    #'(LAMBDA (STATE)
	(VALUES (CAR STATE) (CDR STATE) (NULL (CDR STATE))))
    ;; No compact-p, no pre-proc-fun
    NIL NIL
    AREA))

;;; File system status
(DEFINE-PEEK-MODE PEEK-FILE-SYSTEM #/F "File System"
   "Show all of our connections to various file servers.")
(DEFUN PEEK-FILE-SYSTEM (IGNORE)
  "Display status of file system"
  (SCROLL-MAINTAIN-LIST 
    #'(LAMBDA () (LOOP FOR HOST IN FS:*PATHNAME-HOST-LIST*
		       WHEN (SEND HOST ':PEEK-FILE-SYSTEM-P)
		       COLLECT HOST))
    #'(LAMBDA (HOST)
	(APPEND '(())
		(SEND HOST ':PEEK-FILE-SYSTEM-HEADER)
		(SEND HOST ':PEEK-FILE-SYSTEM)))))
(DEFMETHOD (:PEEK-FILE-SYSTEM SI:FILE-DATA-STREAM-MIXIN) (&OPTIONAL (INDENT 0) &AUX DIRECTION)
  "Returns a scroll item describing a stream"
  (SCROLL-PARSE-ITEM
    ':MOUSE `(NIL :KBD (SEND :FILE-SYSTEM-MENU ,SELF)
		  :DOCUMENTATION "Menu of useful things to do to this open file.")
    (AND ( INDENT 0) (FORMAT NIL "~V@T" INDENT))
    (SELECTQ (SETQ DIRECTION (SEND SELF ':DIRECTION))
      (:INPUT "Input ")
      (:OUTPUT "Output ")
      (:BIDIRECTIONAL "Bidirectional ")
      (OTHERWISE "Direction? "))
    (IF (SEND SELF ':GET ':DIRECT) "direct ")
    (SEND (SEND SELF ':PATHNAME) ':STRING-FOR-PRINTING)
    (IF (SEND SELF ':CHARACTERS)
	", Character, " ", Binary, ")
    `(:FUNCTION ,#'(LAMBDA (STREAM)
		     (SETF (VALUE 0) (SEND STREAM ':READ-POINTER))
		     (VALUE 0))
		(,SELF) NIL ("~D"))
    (AND (EQ DIRECTION ':INPUT)
	 `(:FUNCTION ,#'(LAMBDA (STREAM)
			  (LET ((LENGTH (SEND STREAM ':LENGTH)))
			    (AND LENGTH (NOT (ZEROP LENGTH))
				 (// (* 100. (VALUE 0)) LENGTH))))
		     (,SELF) NIL ("~@[ (~D%)~]")))
    " bytes"))
(DEFMETHOD (:FILE-SYSTEM-MENU BASIC-PEEK) (STREAM)
  (MENU-CHOOSE `(("Close" :EVAL (SEND ',STREAM ':CLOSE)
		  :DOCUMENTATION "Close selected file (normally).")
		 ("Abort" :EVAL (SEND ',STREAM ':CLOSE ':ABORT)
		  :DOCUMENTATION "Close selected file (aborts writing).")
		 ("Delete" :EVAL (SEND ',STREAM ':DELETE)
		  :DOCUMENTATION "Delete selected file, but don't close it.")
		 ("Describe" :EVAL (DESCRIBE ',STREAM)
		  :DOCUMENTATION "Describe the file's stream.")
		 ("Inspect" :EVAL (PROCESS-RUN-FUNCTION "Peek Inspect" #'INSPECT ',STREAM)
		  :DOCUMENTATION "Inspect the file's stream."))
	       (FORMAT NIL "Operation on ~A:" (SEND STREAM ':PATHNAME))))

(DEFVAR *PEEK-PROCESS-CHOICE* NIL)
(DEFMETHOD (:PROCESS-MENU BASIC-PEEK) (PROCESS &AUX CHOICE)
  "Menu for interesting operations on processes in a peek display"
  (MULTIPLE-VALUE (CHOICE *PEEK-PROCESS-CHOICE*)
    (MENU-CHOOSE
      '(("Arrest" :VALUE PROCESS-ARREST
	 :DOCUMENTATION "Arrest the selected process.  Undone by Un-Arrest.")
	("Un-Arrest" :VALUE PROCESS-UN-ARREST
	 :DOCUMENTATION "Un-Arrest the selected process.  Complement of Arrest.")
	("Flush" :VALUE PROCESS-FLUSH
	 :DOCUMENTATION
	 "Unwind the selected process' stack and make it unrunnable.  Ask for confirmation.")
	("Reset" :VALUE PROCESS-RESET
	 :DOCUMENTATION "Reset the selected process.  Ask for confirmation.")
	("Kill" :VALUE PROCESS-KILL
	 :DOCUMENTATION
	 "Kill the selected process.  Ask for confirmation.")
	("Debugger" :VALUE PROCESS-DBG
	 :DOCUMENTATION
	 "Call the debugger to examine the selected process.")
	("Describe" :VALUE PROCESS-DESCRIBE
	 :DOCUMENTATION "Describe this process.")
	("Inspect" :VALUE PROCESS-INSPECT
	 :DOCUMENTATION "Inspect this process."))
      (FORMAT NIL "Operation on ~A:" (PROCESS-NAME PROCESS))
      '(:MOUSE) *PEEK-PROCESS-CHOICE*))
  (SELECTQ CHOICE
    (PROCESS-ARREST (PROCESS-ENABLE-ARREST-REASON PROCESS))
    (PROCESS-UN-ARREST (DOLIST (R (SI:PROCESS-ARREST-REASONS PROCESS))
			 (PROCESS-DISABLE-ARREST-REASON PROCESS R)))
    (PROCESS-FLUSH (IF (MOUSE-Y-OR-N-P (FORMAT NIL "Flush ~A" PROCESS))
		       (PROCESS-FLUSH PROCESS)))
    (PROCESS-RESET (IF (MOUSE-Y-OR-N-P (FORMAT NIL "Reset ~A" PROCESS))
		       (PROCESS-RESET PROCESS)))
    (PROCESS-KILL (IF (MOUSE-Y-OR-N-P (FORMAT NIL "Kill ~A" PROCESS))
		      (PROCESS-KILL PROCESS)))
    (PROCESS-DBG (PEEK-DBG-PROCESS PROCESS))
    (PROCESS-DESCRIBE (DESCRIBE PROCESS))
    (PROCESS-INSPECT (PROCESS-RUN-FUNCTION "Peek Inspect" #'INSPECT PROCESS))
    (NIL)
    (OTHERWISE (BEEP))))
(DEFUN PEEK-DBG-PROCESS (PROCESS)
  (SI:WITH-PROCESS-INTERACTIVE-PRIORITY ()
    (DBG PROCESS)))
(DEFVAR *PEEK-TIMER-QUEUE-CHOICE* NIL)

(DEFMETHOD (:TIMER-QUEUE-MENU BASIC-PEEK) (TQE &AUX CHOICE)
  "Menu for interesting operations on processes in a peek display"
  (MULTIPLE-VALUE (CHOICE *PEEK-TIMER-QUEUE-CHOICE*)
    (MENU-CHOOSE
      '(("Remove" :VALUE TIMER-QUEUE-REMOVE
	 :DOCUMENTATION "Remove the selected timer queue entry.")
	("Run" :VALUE TIMER-QUEUE-RUN
	 :DOCUMENTATION "Reschedule the selected timer queue entry to run now.")
	("Reschedule" :VALUE TIMER-QUEUE-RESCHEDULE
	 :DOCUMENTATION
	 "Reschedule the selected timer queue entry to run at some time in the future.")
	("Describe" :VALUE TIMER-QUEUE-DESCRIBE
	 :DOCUMENTATION "Describe this timer queue entry.")
	("Inspect" :VALUE TIMER-QUEUE-INSPECT
	 :DOCUMENTATION "Inspect this timer queue entry."))
      (FORMAT NIL "Operation on ~A (~D):" (SI:TIMER-QUEUE-NAME TQE) (SI:TIMER-QUEUE-ID TQE))
      '(:MOUSE) *PEEK-TIMER-QUEUE-CHOICE*))
  (SELECTQ CHOICE
    (TIMER-QUEUE-REMOVE
     (WHEN (MOUSE-Y-OR-N-P (FORMAT NIL "Kill ~A(~D)."
			     (SI:TIMER-QUEUE-NAME TQE) (SI:TIMER-QUEUE-ID TQE)))
       (SI:REMOVE-TIMER-QUEUE-ENTRY (SI:TIMER-QUEUE-ID TQE))))
    (TIMER-QUEUE-RUN
     (WHEN (MOUSE-Y-OR-N-P (FORMAT NIL "Run ~A(~D) now."
			     (SI:TIMER-QUEUE-NAME TQE) (SI:TIMER-QUEUE-ID TQE)))
       (LET ((NAME (SI:TIMER-QUEUE-NAME TQE))
	     (FUNCTION (SI:TIMER-QUEUE-FUNCTION TQE))
	     (ARGUMENTS (SI:TIMER-QUEUE-ARGUMENTS TQE))
	     (REPEAT (SI:TIMER-QUEUE-REPEAT TQE)))
	 (SI:REMOVE-TIMER-QUEUE-ENTRY (SI:TIMER-QUEUE-ID TQE))
	 (LEXPR-FUNCALL 'SI:ADD-TIMER-QUEUE-ENTRY
			'(:RELATIVE 0) REPEAT NAME FUNCTION ARGUMENTS))))
    (TIMER-QUEUE-RESCHEDULE
     (LET ((UT (2 0 (NIL 0) (NIL :ROMAN NIL) "CPTFONT")(ACCEPT `((TIME:UNIVERSAL-TIME)
0			 2:BASE-TIME ,(TIME:GET-UNIVERSAL-TIME)
0			 2:DESCRIPTION "0the date and time to run it at2")
0		       2:DEFAULT (TIME:GET-UNIVERSAL-TIME)))
0	   (NAME (SI:TIMER-QUEUE-NAME TQE))
	   (FUNCTION (SI:TIMER-QUEUE-FUNCTION TQE))
	   (ARGUMENTS (SI:TIMER-QUEUE-ARGUMENTS TQE))
	   (REPEAT (SI:TIMER-QUEUE-REPEAT TQE)))
       (SI:REMOVE-TIMER-QUEUE-ENTRY (SI:TIMER-QUEUE-ID TQE))
       (LEXPR-FUNCALL 'SI:ADD-TIMER-QUEUE-ENTRY
		      `(:ABSOLUTE ,UT) REPEAT NAME FUNCTION ARGUMENTS)))
    (TIMER-QUEUE-DESCRIBE (DESCRIBE TQE))
    (TIMER-QUEUE-INSPECT (PROCESS-RUN-FUNCTION "Peek Inspect" #'INSPECT TQE))
    (NIL)
    (OTHERWISE (BEEP))))

(DEFINE-PEEK-MODE PEEK-WINDOW-HIERARCHY #/W "Windows"
   "Show all the active windows and their hierarchical relationships.")
(DEFUN PEEK-WINDOW-HIERARCHY (IGNORE)
  (SCROLL-MAINTAIN-LIST #'(LAMBDA () ALL-THE-SCREENS)
			#'(LAMBDA (SCREEN)
			    (LIST ()
			      (SCROLL-PARSE-ITEM (FORMAT NIL "Screen ~A" SCREEN))
			      (PEEK-WINDOW-INFERIORS SCREEN 2)
			      (SCROLL-PARSE-ITEM "")))))
(DEFUN PEEK-WINDOW-INFERIORS (WINDOW INDENT)
  (SCROLL-MAINTAIN-LIST `(LAMBDA () (SHEET-INFERIORS ',WINDOW))
			`(LAMBDA (SHEET)
			   (LIST ()
			     (SCROLL-PARSE-ITEM 
			       `(:MOUSE (NIL :KBD (SEND :WINDOW-MENU ,SHEET)
					     :DOCUMENTATION
					     "Menu of useful things to do to this window.")
				 :STRING ,(FORMAT NIL "~V@T~A" ,INDENT SHEET)))
			     (PEEK-WINDOW-INFERIORS SHEET (+ ,INDENT 4))))))
(DEFMETHOD (:WINDOW-MENU BASIC-PEEK) (SHEET &AUX CHOICE)
  "Menu for interesting operations on sheets in a peek display"
  (SETQ CHOICE (MENU-CHOOSE
		 '(("Deexpose" :VALUE :DEEXPOSE :DOCUMENTATION "Deexpose the window.")
		   ("Expose" :VALUE :EXPOSE :DOCUMENTATION "Expose the window.")
		   ("Select" :VALUE :SELECT :DOCUMENTATION "Select the window.")
		   ("Deselect" :VALUE :DESELECT :DOCUMENTATION "Deselect the window.")
		   ("Deactivate" :VALUE :DEACTIVATE :DOCUMENTATION "Deactivate the window.")
		   ("Kill" :VALUE :KILL :DOCUMENTATION "Kill the window.")
		   ("Bury" :VALUE :BURY :DOCUMENTATION "Bury the window.")
		   ("Attributes" :VALUE :ATTRIBUTES
		    :DOCUMENTATION "Display or change the window's attributes.")
		   ("Describe" :VALUE :DESCRIBE :DOCUMENTATION "Describe this window.")
		   ("Inspect" :VALUE :INSPECT :DOCUMENTATION "Inspect the window."))
		 (FORMAT NIL "Operation on ~A:"
			 (OR (SEND SHEET ':NAME-FOR-SELECTION) (SEND SHEET ':NAME)))))
  (AND CHOICE
       (SELECTQ CHOICE
	 (:INSPECT (PROCESS-RUN-FUNCTION "Peek Inspect" #'INSPECT SHEET))
	 (:DESCRIBE (SEND SELF ':FORCE-KBD-INPUT `(DESCRIBE ,SHEET)))
	 (:ATTRIBUTES (SCREEN-EDITOR-EDIT-ATTRIBUTES SHEET))
	 ((:KILL :DEACTIVATE)
	  (WHEN (MOUSE-Y-OR-N-P (FORMAT NIL "~A ~A" CHOICE SHEET))
	    (SEND SHEET CHOICE)))
	 (OTHERWISE
	  (SEND SHEET CHOICE)))))

(DEFINE-PEEK-MODE PEEK-SERVERS #/S "Servers"
   "Show all active network servers and what they are doing.")
(DEFUN PEEK-SERVERS (IGNORE)
  (LIST ()
	(SCROLL-PARSE-ITEM "Active Servers")
	(SCROLL-PARSE-ITEM "Protocol Name        Host                Process // State")
	(SCROLL-PARSE-ITEM "                                                  Connection")
	(SCROLL-PARSE-ITEM "")
	(SCROLL-MAINTAIN-LIST
	  #'(LAMBDA () NET:*ACTIVE-SERVERS*)
	  #'(LAMBDA (SERVER)
	      (LIST* () (SEND SERVER :PEEK))))))
;;;
(DEFMETHOD (:PEEK-HOST-MENU TV:BASIC-PEEK) (HOST ITEM
						 &OPTIONAL (OFFSET 0) &REST ADDITIONAL-STUFF)
  "Menu for interesting operations on hosts in a peek display"
  (WHEN (LOCATIVEP HOST)
    (SETQ HOST (LOCATION-CONTENTS HOST)))
  (LET* ((NETWORK-HOST (TYPEP HOST 'NET:HOST))
	 (CHOICE (TV:MENU-CHOOSE
		   `(,@(LOOP FOR NETWORK IN (LOOP FOR (NETWORK)
						    IN (SEND-IF-HANDLES
							 HOST ':NETWORK-ADDRESSES)
						  WHEN (NOT (MEMQ NETWORK NETWORKS))
						    COLLECT NETWORK INTO NETWORKS
						  FINALLY (RETURN NETWORKS))
			     NCONC (SEND NETWORK ':SEND-IF-HANDLES
					 :PEEK-HOST-MENU-CHOICES HOST))
		     ("File Reset" :VALUE HOST-FILE-RESET
		      :DOCUMENTATION "Reset all file access paths to the selected host.")
		     ,(IF NETWORK-HOST
			  '("Remote Login" :VALUE HOST-REMOTE-LOGIN
			    :DOCUMENTATION "Remote login to selected host."))
		     ,(IF NETWORK-HOST
			  '("Show Users" :VALUE HOST-SHOW-USERS
			    :DOCUMENTATION "Show list of users on host in typeout window."))
		     ,(IF NETWORK-HOST
			  '("Qsend" :VALUE HOST-QSEND
			    :DOCUMENTATION "Send a message to user on selected host.")))
		  (FORMAT NIL "Operation on ~A:" (OR (SEND-IF-HANDLES HOST ':PRETTY-NAME)
						     (SEND HOST ':NAME)))))
	(TERMINAL-IO TV:TYPEOUT-WINDOW))
    (IF (LISTP CHOICE)
	(LEXPR-SEND (FIRST CHOICE) ':DO-PEEK-HOST-MENU-CHOICE
		    SELF (SECOND CHOICE)
		    HOST ITEM OFFSET ADDITIONAL-STUFF)	       
      (SELECTQ CHOICE
	(HOST-FILE-RESET (SEND HOST :FILE-RESET T))
	(HOST-REMOTE-LOGIN (FUNCALL-SELF ':FORCE-KBD-INPUT `(TV:REMOTE-LOGIN ,HOST)))
	(HOST-SHOW-USERS (FUNCALL-SELF ':FORCE-KBD-INPUT `(TV:SHOW-USERS ,HOST)))
	(HOST-QSEND (FUNCALL-SELF ':FORCE-KBD-INPUT `(QSEND ,HOST)))
	(NIL)
	(OTHERWISE (BEEP))))))
;;;
(DEFMETHOD (:PEEK-FILE-ACCESS-PATH-MENU TV:BASIC-PEEK) (FILE-ACCESS-PATH)
  "Menu for interesting operations on file access paths in a peek display"
  (LET ((CHOICE (TV:MENU-CHOOSE
		  `(("Reset" :VALUE RESET
		     :DOCUMENTATION "Reset file access path.")
		    ("Describe" :VALUE :DESCRIBE
		     :DOCUMENTATION "Describe this file access path.")
		    ("Inspect" :VALUE :INSPECT
		     :DOCUMENTATION "Inspect this file access path."))
		  (FORMAT NIL "Operation on ~S:" FILE-ACCESS-PATH)))
	(TERMINAL-IO TV:TYPEOUT-WINDOW))
    (SELECTQ CHOICE
      (RESET (WHEN (TV:MOUSE-Y-OR-N-P (FORMAT NIL "Reset file access path to ~A?" 
					      (SEND FILE-ACCESS-PATH :HOST)))
	       (SEND FILE-ACCESS-PATH :RESET)))
      (:INSPECT    (PROCESS-RUN-FUNCTION "Peek Inspect" #'INSPECT FILE-ACCESS-PATH))
      (:DESCRIBE   (DESCRIBE FILE-ACCESS-PATH))
      (NIL)
      (OTHERWISE (BEEP)))))
;;;
(DEFMETHOD (:SERVER-CONNECTION-MENU BASIC-PEEK) (NETWORK CONN ITEM)
  (LET ((CHOICE
	  (MENU-CHOOSE `(,@(SEND NETWORK ':SEND-IF-HANDLES ':SERVER-CONNECTION-MENU-CHOICES)
			 ("Describe" :VALUE :DESCRIBE
			  :DOCUMENTATION
			  "Describe this network connection.")
			 ("Inspect" :VALUE :INSPECT
			  :DOCUMENTATION "Inspect the connection"))
		       (FORMAT NIL "Operation on ~S:" CONN))))
    (SELECTQ CHOICE
      (:INSPECT    (PROCESS-RUN-FUNCTION "Peek Inspect" #'INSPECT CONN))
      (:DESCRIBE   (SEND SELF ':FORCE-KBD-INPUT `(DESCRIBE ,CONN)))
      (NIL)
      (OTHERWISE   (SEND NETWORK ':DO-SERVER-CONNECTION-MENU-CHOICE
			 SELF CHOICE CONN ITEM)))))
;;;
(DEFMETHOD (:SERVER-STREAM-MENU BASIC-PEEK) (STREAM)
  (LET ((CHOICE
	  (MENU-CHOOSE `(("Close" :VALUE :CLOSE
			  :DOCUMENTATION "Close the network connection.")
			 ("Reset" :VALUE :RESET
			  :DOCUMENTATION "Reset the network connection.")
			 ("Describe" :VALUE :DESCRIBE
			  :DOCUMENTATION "Describe this network connection.")
			 ("Inspect" :VALUE :INSPECT
			  :DOCUMENTATION "Inspect the connection"))
		       (FORMAT NIL "Operation on ~S:" STREAM))))
    (SELECTQ CHOICE
      (:CLOSE (SEND STREAM :CLOSE-WITH-REASON "Closed from PEEK."))
      (:RESET (SEND STREAM :CLOSE-WITH-REASON "Closed from PEEK." :ABORT))
      (:INSPECT    (PROCESS-RUN-FUNCTION "Peek Inspect" #'INSPECT STREAM))
      (:DESCRIBE   (DESCRIBE STREAM))
      (NIL))))
;;;
(DEFUN PEEK-SERVER-PREPROCESS (LIST-ITEM &AUX HOST)
  (LET* ((LINE-ITEM (THIRD LIST-ITEM))
	 (HOST-ITEM (SECOND LIST-ITEM))
	 (WANTED (ARRAY-LEADER LINE-ITEM (+ 4 SCROLL-ITEM-LEADER-OFFSET)))
	 (GOT (ARRAY-LEADER LINE-ITEM (+ 5 SCROLL-ITEM-LEADER-OFFSET))))
    #+IGNORE
    (COND ((NULL WANTED)
	   (STORE-ARRAY-LEADER NIL LINE-ITEM (+ 5 SCROLL-ITEM-LEADER-OFFSET))
	   (SETF (FOURTH LIST-ITEM) NIL))
	  ((EQ WANTED GOT))
	  (T
	   (SETF (FOURTH LIST-ITEM) (CHAOS:PEEK-CHAOS-CONN WANTED))
	   (STORE-ARRAY-LEADER WANTED LINE-ITEM (+ 5 SCROLL-ITEM-LEADER-OFFSET))))
    #-IGNORE
    ;; for now, if cached is not what we wanted, nullify whole thing
    (COND ((EQ WANTED GOT))
	  (T
	   (STORE-ARRAY-LEADER NIL LINE-ITEM (+ 5 SCROLL-ITEM-LEADER-OFFSET))
	   (SETF (FOURTH LIST-ITEM) NIL)))    
    ;;Hack hostat
    (COND ((ARRAY-LEADER HOST-ITEM SCROLL-ITEM-LEADER-OFFSET)
	 ;; Want a hostat, make sure it's there and for the right host
	   (IF (AND (EQ (SETQ HOST (ARRAY-LEADER HOST-ITEM (1+ SCROLL-ITEM-LEADER-OFFSET)))
			(ARRAY-LEADER HOST-ITEM  (+ SCROLL-ITEM-LEADER-OFFSET 2)))
		    (FIFTH LIST-ITEM))
	       NIL
	     (SETF (FIFTH LIST-ITEM) (CONS '() (CHAOS:PEEK-CHAOS-HOSTAT HOST 1)))
	     (SETF (ARRAY-LEADER HOST-ITEM (+ SCROLL-ITEM-LEADER-OFFSET 2)) HOST)))
	  (T (SETF (FIFTH LIST-ITEM) NIL)
	     (SETF (ARRAY-LEADER HOST-ITEM (+ SCROLL-ITEM-LEADER-OFFSET 2)) NIL)))))

(DEFINE-PEEK-MODE PEEK-NETWORK #/N "Network"
   "Show all local networks, their state and active connections, and network interfaces.")
(DEFUN PEEK-NETWORK (IGNORE)
  (LIST ()
    (SCROLL-PARSE-ITEM
      "Network status at "
      `(:FUNCTION ,#'TIME () NIL ("~O")))
    (SCROLL-PARSE-ITEM "")
    (SCROLL-PARSE-ITEM "Local networks:")
    (SCROLL-MAINTAIN-LIST #'(LAMBDA () NETI:*LOCAL-NETWORKS*)
			  #'(LAMBDA (NETWORK)
			      (LIST ()
			        (SCROLL-PARSE-ITEM "")
				(SEND NETWORK ':PEEK-HEADER)
				(SEND NETWORK ':PEEK))))
    (SCROLL-PARSE-ITEM "")
    (SCROLL-PARSE-ITEM "Packet allocation meters:")
    (SCROLL-PARSE-ITEM "")
    (SCROLL-MAINTAIN-LIST #'(LAMBDA () NETI:*PACKET-ALLOCATION-METERS*)
			  #'PEEK-DISPLAY-COUNTER)
    (SCROLL-MAINTAIN-LIST #'(LAMBDA () NETI:*UNRESET-PACKET-ALLOCATION-METERS*)
			  #'PEEK-DISPLAY-COUNTER)
    (SCROLL-PARSE-ITEM "")
    (SCROLL-PARSE-ITEM "Network interfaces:")
    (SCROLL-MAINTAIN-LIST #'(LAMBDA () NETI:*INTERFACES*)
			  #'(LAMBDA (INTERFACE)
			      (LIST NIL
			        (SCROLL-PARSE-ITEM "")
				(SEND INTERFACE ':PEEK-HEADER)
				(SEND INTERFACE ':PEEK))))
    ))
(DEFUN PEEK-DISPLAY-COUNTER (COUNTER)
  (PEEK-DISPLAY-COUNTER-INTERNAL COUNTER #'SYMEVAL))

(COMMENT
 (DEFUN PEEK-DISPLAY-COUNTER-INTERNAL (COUNTER ACCESS-FUNCTION)
  (SCROLL-PARSE-ITEM
    `(:STRING ,(STRING COUNTER) 30.)
    `(:FUNCTION ,ACCESS-FUNCTION (,COUNTER) NIL ("~@10A" 10. T))))
)
(DEFUN PEEK-DISPLAY-COUNTER-INTERNAL (COUNTER ACCESS-FUNCTION)
  (SCROLL-PARSE-ITEM
    ':LEADER `(,ACCESS-FUNCTION ,COUNTER
	       . ,(MAKE-LIST (* 3 (LENGTH *PEEK-COUNTER-INTERVALS*))))
    `(:STRING ,(IF (> (STRING-LENGTH COUNTER) 30.)
		   (SUBSTRING COUNTER 0 30.)
		   (STRING COUNTER))
	      30.)
    `(:FUNCTION-ITEM ,#'(LAMBDA (COUNTER ACCESS-FUNCTION ITEM)
			  (LET (NEW-VALUE NOW)
			    (WITHOUT-INTERRUPTS
			      (SETQ NEW-VALUE (FUNCALL ACCESS-FUNCTION COUNTER)
				    NOW (TIME)))
			    (LOOP FOR INTERVAL IN *PEEK-COUNTER-INTERVALS*
				  FOR LEADER-OFFSET FROM (+ SCROLL-ITEM-LEADER-OFFSET 2) BY 3
				  FOR VALUE-INDEX FROM 0
				  DO (LET ((TIME-UPDATED (ARRAY-LEADER ITEM
								       (+ LEADER-OFFSET 2))))
				       (COND ((NULL TIME-UPDATED)
					      (SETF (ARRAY-LEADER ITEM LEADER-OFFSET)
						    NIL)
					      (SETF (ARRAY-LEADER ITEM (1+ LEADER-OFFSET))
						    NEW-VALUE)
					      (SETF (ARRAY-LEADER ITEM (+ LEADER-OFFSET 2))
						    NOW))
					     (( (TIME-DIFFERENCE NOW TIME-UPDATED) INTERVAL)
					      (LET ((OLD-AVERAGE
						      (ARRAY-LEADER ITEM LEADER-OFFSET))
						    (DELTA (- NEW-VALUE
							      (ARRAY-LEADER
								ITEM (1+ LEADER-OFFSET)))))
						(SETF (ARRAY-LEADER ITEM LEADER-OFFSET)
						      (IF (NULL OLD-AVERAGE) DELTA
							  (// (+ DELTA OLD-AVERAGE) 2))))
					      (SETF (ARRAY-LEADER ITEM (1+ LEADER-OFFSET))
						    NEW-VALUE)
					      (SETF (ARRAY-LEADER ITEM (+ LEADER-OFFSET 2))
						    NOW))))
				     (SETF ;;(VALUE VALUE-INDEX)
				       (VALUE-SEQUENCE-REF (VALUE-SEQUENCE) VALUE-INDEX)
					   (ARRAY-LEADER ITEM LEADER-OFFSET)))
			    NEW-VALUE))
		     (,COUNTER ,ACCESS-FUNCTION ITEM)
		     NIL ("~@10A" 10. T))
    `(:VALUE 0 NIL ("~@[~@10A~]" 10. T))
    `(:VALUE 1 NIL ("~@[~@10A~]" 10. T))
    `(:VALUE 2 NIL ("~@[~@10A~]" 10. T))))

(DEFMETHOD (:PEEK-HEADER NETI:NETWORK) ()
  (SCROLL-PARSE-ITEM 
    `(:MOUSE-ITEM
      (NIL :KBD (SEND :NETWORK-MENU ,SELF)
	   :DOCUMENTATION
	   "Menu of useful things to do to this network.")
      :FUNCTION ,(SEND SELF ':NAME) (:POSSIBLY-QUALIFIED-STRING :NETWORK) 30.)))
(DEFVAR *PEEK-NETWORK-CHOICE* NIL)
(DEFMETHOD (:NETWORK-MENU BASIC-PEEK) (NETWORK &AUX CHOICE)
  "Menu for interesting operations on networks in a peek display"
  (MULTIPLE-VALUE (CHOICE *PEEK-NETWORK-CHOICE*)
    (MENU-CHOOSE
      '(("Reset" :VALUE :RESET
	 :DOCUMENTATION "Reset the selected network.  Ask for confirmation.")
	("Enable" :VALUE :ENABLE
	 :DOCUMENTATION "Enable the selected network.")
	("Describe" :VALUE :DESCRIBE
	 :DOCUMENTATION "Describe this network.")
	("Inspect" :VALUE :INSPECT
	 :DOCUMENTATION "Inspect this network."))
      (FORMAT NIL "Operation on ~A:" (SEND NETWORK ':NAME))
      '(:MOUSE) *PEEK-NETWORK-CHOICE*))
  (SELECTQ CHOICE
    (:RESET (AND (MOUSE-Y-OR-N-P (FORMAT NIL "Reset ~A network" NETWORK))
		 (SEND NETWORK ':RESET)))
    (:ENABLE (SEND NETWORK ':ENABLE))
    (:DESCRIBE (DESCRIBE NETWORK))
    (:INSPECT (PROCESS-RUN-FUNCTION "Peek Inspect" #'INSPECT NETWORK))
    (NIL)
    (OTHERWISE (BEEP))))

;;; Defaults

(DEFMETHOD (:PEEK NETI:NETWORK) () ())
(DEFMETHOD (:PEEK-HEADER NETI:NETWORK-INTERFACE) ()
  (SCROLL-PARSE-ITEM
    `(:STRING ,(FORMAT NIL "~S" SELF) 30.)))
(DEFMETHOD (:PEEK NETI:NETWORK-INTERFACE) ()
  (PEEK-NETWORK-INTERFACE SELF))
(DEFUN PEEK-NETWORK-INTERFACE (INTERFACE)
  (LIST ()
    (SCROLL-PARSE-ITEM
      `(:FUNCTION ,#'(LAMBDA (NETWORK)
		       (IF (SEND NETWORK ':ENABLED) " Enabled" " Disabled"))
	(,INTERFACE))
      ", overseer "
      (LET ((OVERSEER (SEND INTERFACE ':OVERSEER)))
	(IF OVERSEER
	    `(:MOUSE
	      (NIL :KBD (SEND :PROCESS-MENU ,OVERSEER)
		   :DOCUMENTATION
		   "Menu of useful things to do to this process.")
	      :STRING
	      ,(FORMAT NIL "~A" (SEND OVERSEER ':NAME)))
	    "<non-existent>")))
    (SCROLL-PARSE-ITEM "")
    (SCROLL-MAINTAIN-LIST #'(LAMBDA () '(:RECEIVE-COUNT :TRANSMIT-COUNT))
			  `(LAMBDA (MESSAGE)
			     (TV:PEEK-DISPLAY-COUNTER-INTERNAL
			       MESSAGE ',INTERFACE)))))

(DEFINE-PEEK-MODE PEEK-HELP #\HELP "Help"
   "Explain how this program works.")
(DEFUN PEEK-HELP (IGNORE)
  (LIST ()
	(SCROLL-PARSE-ITEM
	  "This is the Peek utility program.  It shows a continually updating")
	(SCROLL-PARSE-ITEM
	  "display of status about some aspect of the system, depending on what")
	(SCROLL-PARSE-ITEM
	  "mode it is in.  The available modes are listed below.  Each has a name,")
	(SCROLL-PARSE-ITEM
	  "followed by a single character in parentheses, followed by a description.")
	(SCROLL-PARSE-ITEM
	  "To put Peek into a given mode, click on the name of the mode, in the command")
	(SCROLL-PARSE-ITEM
	  "menu above.  Alternatively, type the single character shown below.")
	(SCROLL-PARSE-ITEM "")
	(SCROLL-MAINTAIN-LIST
	  #'(LAMBDA () PEEK-ITEM-LIST)
	  #'(LAMBDA (ITEM)
	      ;; (function character name documentation)
	      (LIST ()
		    (SCROLL-PARSE-ITEM
		      (FORMAT NIL "~A (~C):" (THIRD (THIRD ITEM)) (SECOND (THIRD ITEM))))
		    (SCROLL-PARSE-ITEM  "  " (FOURTH (THIRD ITEM)))
		    (SCROLL-PARSE-ITEM ""))))
	(SCROLL-PARSE-ITEM "")
	(SCROLL-PARSE-ITEM
	  "There are also the following single-character commands:")
	(SCROLL-PARSE-ITEM
	  "Z (preceded by a number): Set the amount of time between updates, in seconds.")
	(SCROLL-PARSE-ITEM
	  (FORMAT NIL "     By default, the display is updated every ~S seconds."
		  (// PEEK-SLEEP-TIME 60.)))
	(SCROLL-PARSE-ITEM
	  "<SPACE>: Immediately update the display.")))
(DEFINE-PEEK-MODE PEEK-QUIT #\Q "Quit"
   "Bury PEEK window, exiting PEEK")

;; This doesn't get called due to special-case check in PEEK-SET-MODE
(DEFUN PEEK-QUIT (IGNORE)
  NIL)

;;;Pre-create one for the system key
;Why bloat the world with a peek window?
;(ADD-INITIALIZATION "PEEK" '(MAKE-WINDOW 'PEEK-FRAME ':ACTIVATE-P T) '(:ONCE))

(tv:add-select-key #/P 'PEEK-FRAME "Peek" T)
