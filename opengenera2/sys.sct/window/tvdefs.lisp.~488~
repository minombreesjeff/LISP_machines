;;; -*- Mode: LISP; Package: TV; Base: 8 -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(DEFVAR-RESETTABLE DEFAULT-SCREEN NIL)
(DEFVAR ALL-THE-SCREENS NIL)
(DEFVAR MAIN-SCREEN NIL)
(DEFVAR WHO-LINE-SCREEN NIL)
(DEFVAR WHO-LINE-RUN-STATE-SHEET NIL)
(DEFVAR WHO-LINE-FILE-STATE-SHEET NIL)
(DEFVAR NWATCH-WHO-LINE-SHEET NIL)
(DEFVAR WHO-LINE-DOCUMENTATION-WINDOW NIL)
(DEFVAR WHO-LINE-MOUSE-GRABBED-DOCUMENTATION NIL)
(DEFVAR WHO-LINE-MOUSE-GRABBED-MORE-DOCUMENTATION NIL)
(DEFVAR *ACTIVE-WHO-LINE-SCREENS* NIL)
(DEFVAR *DEFAULT-FONT* FONTS:CPTFONT)
(DEFVAR *DEFAULT-STYLE* (SI:INTERN-CHARACTER-STYLE :FIX :ROMAN :NORMAL))
(DEFVAR *DEFAULT-VSP* 2)
(DEFVAR *CHARSET&STYLEFONT-CACHE-TICK* 0)
(DEFVAR *DEFAULT-TYPEIN-STYLE* (SI:INTERN-CHARACTER-STYLE NIL NIL NIL))
(DEFVAR *DEFAULT-ECHO-STYLE*   (SI:INTERN-CHARACTER-STYLE NIL NIL NIL)) ; same as typeout by default
(DEFVAR *MENU-DEFAULT-CHARACTER-STYLE* (SI:INTERN-CHARACTER-STYLE :JESS :ROMAN :LARGE))
(DEFVAR *MENU-SELECTED-CHARACTER-STYLE* NIL)	;NIL => use inverse video to highlight
(DEFVAR *SHEET-ENABLE-EXPLICIT-PAGE-OUT* T)
(DEFVAR *DEFAULT-WINDOW-SIZE-ALIST* NIL)	;Use SET-DEFAULT-WINDOW-SIZE to add to this

;; Keep the names of these two variables for compatibility with the old notification system.
;; Each entry in NOTIFICATION-HISTORY is a notification structure.  New entries are pushed on.

(DEFVAR NOTIFICATION-HISTORY NIL)

;; This is the time of the last notification.  It is used to control updating of the who line.

(DEFVAR *LAST-NOTIFICATION-TIME* 0)

;; This is a pointer into NOTIFICATION-HISTORY, which describes those notifications which have
;; been given to other processes.  This is stored in a special variable rather than in a local
;; inside of NOTIFICATION-DELIVERY-TOP-LEVEL so that if the notification delivery process is
;; reset, all the notifications won't be delivered again.

(DEFVAR *NOTIFICATION-LAST-DELIVERED* NIL)

(DEFVAR BEEP T)
(DEFVAR BEEP-DURATION 400000)
(DEFVAR BEEP-WAVELENGTH 1350)

;;;These are here because they are needed in more than one file
#||	;Compatibility defined in console files
(DEFVAR SELECTED-WINDOW NIL)		;The currently selected window
(DEFVAR SELECTED-IO-BUFFER NIL)		;The IO-BUFFER that input is currently being
					; directed to
||#
(DEFVAR WHO-LINE-PROCESS CURRENT-PROCESS)	;Process that the wholine is stuck on
(DEFVAR LAST-WHO-LINE-PROCESS CURRENT-PROCESS)	;The last one which was displayed
(DEFVAR INHIBIT-WHO-LINE NIL)		;Set this to T with CC if who line is broken
(DEFVAR INHIBIT-SCREEN-MANAGEMENT NIL)	;If set to T causes screen management not to
					; automatically.  This is useful when it is
					; known that many operations are going to be done
					; on the screen.  The function should call
					; SCREEN-MANAGE-SHEET on the superior that is was
					; hacking windows on for correct behaviour.
(DEFVAR-RESETTABLE MOUSE-WINDOW NIL)	;Window controlling the mouse, NIL if none
(DEFVAR MOUSE-RECONSIDER)		;T => mouse process should return to overseer
					;and decide anew which window should get the mouse.
					;For use by :MOUSE-MOVES methods, etc.
(DEFVAR WINDOW-OWNING-MOUSE)		;NIL, or window which has seized the mouse, or
					;T if someone has seized the mouse and can't identify
					;himself as any particular window,
					;or STOP to make the mouse process do nothing.
(DEFVAR MOUSE-BUTTONS-GRABBED NIL)	;non-NIL if mouse process should stay away from
					;the buttons; see WITH-MOUSE-AND-BUTTONS-GRABBED
(DEFVAR MOUSE-SHEET NIL)		;Which sheet MOUSE-BLINKER lives on
(DEFVAR *MOUSE-DOCUMENTATION-NEEDS-UPDATE* NIL)	;Set to T when you'd like quick update

(DEFVAR-RESETTABLE PROCESS-IS-IN-ERROR NIL)	;A sheet if waiting to be noticed

(DEFVAR WHO-LINE-RUN-STATE "")	;Variable containing the current state (RUN, STOP, TYI, etc.)
;(DEFVAR WHO-LINE-RUN-LIGHT-LOC);Contains the address of the run light under the who line
		;in COLD actually

;; Dummy function for load-time use
(OR (FBOUNDP 'MOUSE-WAKEUP)
    (FSET' MOUSE-WAKEUP '(LAMBDA () NIL)))

(DEFVAR SHEET-AREA (MAKE-AREA :NAME 'SHEET-AREA :REGION-SIZE 200000))
(DEFVAR WHO-LINE-AREA (MAKE-AREA :NAME 'WHO-LINE-AREA :REGION-SIZE 100000))

(DEFMACRO SHEET-CONSING (&BODY BODY)
  `(LET ((DEFAULT-CONS-AREA SHEET-AREA))
     . ,BODY))

(DEFVAR BLINKER-AREA (MAKE-AREA :NAME 'BLINKER-AREA :REGION-SIZE 100000))

(DEFVAR BIT-ARRAY-AREA
	(MAKE-AREA :NAME 'TV:BIT-ARRAY-AREA
		   :GC :STATIC
		   :SWAP-RECOMMENDATIONS 31. ;; maximum
		   :REGION-SIZE 1000000.))

(DEFVAR *DEFAULT-BIT-ARRAY-AREA* BIT-ARRAY-AREA)

(DEFFLAVOR SHEET
	   ((SCREEN-ARRAY NIL)	;Array that output goes on.  Either a standard array
				; or a section of the physical screen.  May be null when
				;deexposed if no BIT-ARRAY. (microcode use)
	    LOCATIONS-PER-LINE	;Number of locations per raster line (now unused)
	    OLD-SCREEN-ARRAY	;SCREEN-ARRAY when last exposed if there is no BIT-ARRAY
	    (BIT-ARRAY NIL)	;"In-core" array used when sheet not exposed (may be null)
	    
	    (NAME NIL)		;What this here sheet is called
	    (LOCK NIL)		;Lock cell, contains unique-id of owner of lock, or a list
				;of temporary locking unique-ids.
	    (LOCK-COUNT 0)	;Number of times lock is locked by this id
				;(lock is freed when 0)

	    SUPERIOR		;Null superior is top.
	    (INFERIORS NIL)
	    
	    (EXPOSED-P NIL)	;T when exposed, NIL otherwise.  In this context "exposed"
				;means that it is among the superior's exposed-inferiors
				;and the superior either has a bit-array or is exposed.
				;T here does not necessarily mean it's visible on the screen.
	    (EXPOSED-INFERIORS NIL)
	    
	    (X-OFFSET NIL)	;Position relative to position of superior
	    (Y-OFFSET NIL)
	    (WIDTH NIL)		;Size of sheet
	    (HEIGHT NIL)
	    
	    CURSOR-X		;Position at which to draw next character
	    CURSOR-Y
	    
	    MORE-VPOS		;Y passing here triggers MORE processing
	    
	    (TOP-MARGIN-SIZE 0)	;Reserved region around outside of sheet (for borders, etc.)
	    (BOTTOM-MARGIN-SIZE 0)
	    (LEFT-MARGIN-SIZE 0)
	    (RIGHT-MARGIN-SIZE 0)
	    
	    (FLAGS 0)		;A fixnum containing various flags
	    
	    ;;; Font information
	    (DEFAULT-STYLE *DEFAULT-STYLE*) ;Default character style.  Controls default line-height, etc.
	    BASELINE		;# raster lines from top of char cell to baseline.
	    (CURRENT-STYLE SI:*NULL-STYLE*) ;Currently selected style.
	    CURRENT-FONT	;Currently selected font

	    UNUSED-SLOT-1	;Was BASELINE-ADJ.  Can be recycled if you wish.

	    LINE-HEIGHT		;Total number of raster lines per character line
	    CHAR-WIDTH		;Character width for cursor blinker + (X,Y) positioning
	    CHAR-ALUF		;ALU function for drawing characters
	    ERASE-ALUF		;ALU function for erasing characters/lines/whole thing	    
	    (BLINKER-LIST NIL)	;Possibly null list of blinkers on this sheet

	    (DEEXPOSED-TYPEOUT-ACTION :NORMAL)
	    (TEMPORARY-BIT-ARRAY NIL)
	    (TEMPORARY-WINDOWS-LOCKED NIL)
	    RESTORED-BITS-P
	    (INVISIBLE-TO-MOUSE-P NIL)
	    (SCREEN-MANAGER-SCREEN-IMAGE NIL)
	    (PRIORITY NIL)
	    (TIME-STAMP NIL)
	    (CURRENT-TIME-STAMP NIL)
	    SCREEN		;Screen (Used to do physical I/O on, eventually)
	    DISPLAY-DEVICE-TYPE
	    MERGED-CURRENT-STYLE
	    (VSP *DEFAULT-VSP*)
	    (INFERIOR-LOCK-COUNT 0)
	    (CHARSET&STYLEFONT-CACHE (MAKE-INSTANCE 'SI:VARIABLE-STYLE-FONT-CACHE
						     :GLOBAL-TICK-SYMBOL '*CHARSET&STYLEFONT-CACHE-TICK*))
	    (CLIPPING-REGION NIL)

	    CURRENT-LINE-HEIGHT
	    CURRENT-BASELINE
	    (PENDING-NEW-LINE-HEIGHT NIL)
	    (PENDING-NEW-BASELINE NIL)

	    ;; Use of the spare-1 through spare-4 instance variables is as follows:
	    ;;   Don't change the name of these variables!  If you're adding instance
	    ;;   variables to sheets, add them at the end of the instance variable
	    ;;   list, and then use si:rename-instance-variable to rename one of the
	    ;;   spares until the next world build.  Comment your use as follows:
	    ;;      sheet-spare-n  ; used as sheet-foo until post System 492
	    SHEET-SPARE-1
	    SHEET-SPARE-2
	    SHEET-SPARE-3
	    SHEET-SPARE-4
	    )
	   (SI:OUTPUT-STREAM)
  (:ORDERED-INSTANCE-VARIABLES
   SCREEN-ARRAY
   LOCATIONS-PER-LINE
   OLD-SCREEN-ARRAY
   BIT-ARRAY
   NAME
   LOCK
   LOCK-COUNT
   SUPERIOR
   INFERIORS
   EXPOSED-P
   EXPOSED-INFERIORS
   X-OFFSET
   Y-OFFSET
   WIDTH
   HEIGHT
   CURSOR-X
   CURSOR-Y
   MORE-VPOS
   TOP-MARGIN-SIZE
   BOTTOM-MARGIN-SIZE
   LEFT-MARGIN-SIZE
   RIGHT-MARGIN-SIZE
   FLAGS
   DEFAULT-STYLE
   BASELINE
   CURRENT-STYLE
   CURRENT-FONT
   UNUSED-SLOT-1
   LINE-HEIGHT
   CHAR-WIDTH
   CHAR-ALUF
   ERASE-ALUF
   BLINKER-LIST
   DEEXPOSED-TYPEOUT-ACTION
   TEMPORARY-BIT-ARRAY
   TEMPORARY-WINDOWS-LOCKED
   RESTORED-BITS-P
   INVISIBLE-TO-MOUSE-P
   SCREEN-MANAGER-SCREEN-IMAGE
   PRIORITY
   TIME-STAMP
   SCREEN
   DISPLAY-DEVICE-TYPE
   MERGED-CURRENT-STYLE
   VSP
   INFERIOR-LOCK-COUNT
   CHARSET&STYLEFONT-CACHE
   CLIPPING-REGION
   CURRENT-LINE-HEIGHT
   CURRENT-BASELINE
   PENDING-NEW-LINE-HEIGHT
   PENDING-NEW-BASELINE
   SHEET-SPARE-1
   SHEET-SPARE-2
   SHEET-SPARE-3
   SHEET-SPARE-4
   )
  (:READABLE-INSTANCE-VARIABLES
   SCREEN-ARRAY
   OLD-SCREEN-ARRAY
   BIT-ARRAY
   NAME
   LOCK
   LOCK-COUNT
   SUPERIOR
   INFERIORS
   EXPOSED-P
   EXPOSED-INFERIORS
   X-OFFSET
   Y-OFFSET
   WIDTH
   HEIGHT
   CURSOR-X
   CURSOR-Y
   MORE-VPOS
   TOP-MARGIN-SIZE
   BOTTOM-MARGIN-SIZE
   LEFT-MARGIN-SIZE
   RIGHT-MARGIN-SIZE
   FLAGS
   DEFAULT-STYLE
   BASELINE
   CURRENT-STYLE
   CURRENT-FONT
   UNUSED-SLOT-1
   LINE-HEIGHT
   CHAR-WIDTH
   CHAR-ALUF
   ERASE-ALUF
   BLINKER-LIST
   DEEXPOSED-TYPEOUT-ACTION
   TEMPORARY-BIT-ARRAY
   TEMPORARY-WINDOWS-LOCKED
   RESTORED-BITS-P
   INVISIBLE-TO-MOUSE-P
   SCREEN-MANAGER-SCREEN-IMAGE
   PRIORITY
   TIME-STAMP
   SCREEN
   DISPLAY-DEVICE-TYPE
   MERGED-CURRENT-STYLE
   VSP
   INFERIOR-LOCK-COUNT
   CHARSET&STYLEFONT-CACHE
   CLIPPING-REGION
   CURRENT-LINE-HEIGHT
   CURRENT-BASELINE
   PENDING-NEW-LINE-HEIGHT
   PENDING-NEW-BASELINE
   SHEET-SPARE-1
   SHEET-SPARE-2
   SHEET-SPARE-3
   SHEET-SPARE-4
   )
  (:LOCATABLE-INSTANCE-VARIABLES		;BIND
   SCREEN-ARRAY
   CLIPPING-REGION
   )
  (:WRITABLE-INSTANCE-VARIABLES
   LOCK
   LOCK-COUNT
   INFERIOR-LOCK-COUNT
   TEMPORARY-WINDOWS-LOCKED
   INVISIBLE-TO-MOUSE-P
   SCREEN-MANAGER-SCREEN-IMAGE
   INFERIORS
   EXPOSED-INFERIORS
   BLINKER-LIST
   FLAGS
   DEEXPOSED-TYPEOUT-ACTION
   CHAR-ALUF
   ERASE-ALUF
   )
  (:GETTABLE-INSTANCE-VARIABLES
   SCREEN-ARRAY
   OLD-SCREEN-ARRAY
   BIT-ARRAY
   NAME
   LOCK
   LOCK-COUNT
   SUPERIOR
   INFERIORS
   EXPOSED-P
   EXPOSED-INFERIORS
   X-OFFSET
   Y-OFFSET
   WIDTH
   HEIGHT
   CURSOR-X
   CURSOR-Y
   MORE-VPOS
   TOP-MARGIN-SIZE
   BOTTOM-MARGIN-SIZE
   LEFT-MARGIN-SIZE
   RIGHT-MARGIN-SIZE
   FLAGS
   DEFAULT-STYLE
   BASELINE
   CURRENT-STYLE
   CURRENT-FONT
   UNUSED-SLOT-1
   LINE-HEIGHT
   CHAR-WIDTH
   CHAR-ALUF
   ERASE-ALUF
   BLINKER-LIST
   DEEXPOSED-TYPEOUT-ACTION
   TEMPORARY-BIT-ARRAY
   TEMPORARY-WINDOWS-LOCKED
   RESTORED-BITS-P
   INVISIBLE-TO-MOUSE-P
   SCREEN-MANAGER-SCREEN-IMAGE
   PRIORITY
   TIME-STAMP
   SCREEN
   DISPLAY-DEVICE-TYPE
   MERGED-CURRENT-STYLE
   VSP
   INFERIOR-LOCK-COUNT
   CHARSET&STYLEFONT-CACHE
   CLIPPING-REGION
   CURRENT-LINE-HEIGHT
   CURRENT-BASELINE
   PENDING-NEW-LINE-HEIGHT
   PENDING-NEW-BASELINE
   SHEET-SPARE-1
   SHEET-SPARE-2
   SHEET-SPARE-3
   SHEET-SPARE-4
   )
  (:SETTABLE-INSTANCE-VARIABLES
   DEEXPOSED-TYPEOUT-ACTION
   CHAR-ALUF
   ERASE-ALUF
   )
  (:INITABLE-INSTANCE-VARIABLES
   NAME
   WIDTH
   HEIGHT
   CHAR-ALUF
   ERASE-ALUF
   LEFT-MARGIN-SIZE
   TOP-MARGIN-SIZE
   RIGHT-MARGIN-SIZE
   BOTTOM-MARGIN-SIZE
   SUPERIOR
   SCREEN
   DEFAULT-STYLE
   PRIORITY
   VSP
   DISPLAY-DEVICE-TYPE
   )
  (:INIT-KEYWORDS
   :AUTO-LINE-HEIGHT
   :BACKSPACE-NOT-OVERPRINTING-FLAG
   :BLINKER-ALU
   :BLINKER-DESELECTED-VISIBILITY
   :BLINKER-FLAVOR
   :BLINKER-P
   :BOTTOM
   :CHARACTER-HEIGHT
   :CHARACTER-WIDTH
   :CR-NOT-NEWLINE-FLAG
   :DEEXPOSED-TYPEIN-ACTION
   :DEFAULT-CHARACTER-STYLE
   :EDGES
   :INSIDE-HEIGHT
   :INSIDE-SIZE
   :INSIDE-WIDTH
   :INTEGRAL-P
   :LEFT
   :LOCATIONS-PER-LINE				;ignored for compatibility
   :MORE-P
   :POSITION
   :REVERSE-VIDEO-P
   :RIGHT
   :RIGHT-MARGIN-CHARACTER-FLAG
   :SAVE-BITS
   :SIZE
   :TAB-NCHARS
   :TOP
   :TRUNCATE-LINE-OUT
   :TRUNCATE-LINE-OUT-FLAG
   :TRUNCATE-OUTPUT
   :X
   :Y
   )
  (:FUNCTIONS SHEET-TYO-FUNNY-CHAR-INTERNAL WITH-SHEET-CLIPPING-REGION-INTERNAL)
  (:DEFAULT-INIT-PLIST :TAB-NCHARS 8
		       :AREA SHEET-AREA)
  (:METHOD-COMBINATION :NOTICE :OR
                       :WHO-LINE-DOCUMENTATION-STRING :DAEMON-WITH-OVERRIDE
		       :CHOOSE-ATTRIBUTES (:APPEND :MOST-SPECIFIC-LAST)
		       RESET-DYNAMIC-STATE (:PROGN :MOST-SPECIFIC-LAST))
  (:DOCUMENTATION :LOWLEVEL-MIXIN "A lowest level window type
This is the data structure known about by the microcode."))

;;;*****
(DEFF SHEET-X #'SHEET-X-OFFSET)
(DEFF SHEET-Y #'SHEET-Y-OFFSET)

(COMPILER:MAKE-MESSAGE-OBSOLETE :FONT-MAP "font maps are no longer supported")
(COMPILER:MAKE-MESSAGE-OBSOLETE :SET-FONT-MAP "font maps are no longer supported")
;;;*****

(DEFFLAVOR NO-CHANGE-OF-DEFAULT-FONT-MIXIN () ()
  (:REQUIRED-FLAVORS SHEET)
  (:DOCUMENTATION :MIXIN
    "Prevent SET-DEFAULT-FONT from changing the fonts of this sheet and its inferiors"))



(DEFMACRO DEFINE-SHEET-FLAGS (&REST FLAGS)
  `(PROGN 'COMPILE
	  ,@(MAPCAR #'(LAMBDA (FLAG)
			`(DEFMACRO ,(INTERN (STRING-APPEND "SHEET-" (CAR FLAG)))
				   (&OPTIONAL SHEET)
			   `(%LOGLDB ,',(CADR FLAG)
				     ,(IF SHEET `(SHEET-FLAGS ,SHEET) 'FLAGS))))
		    FLAGS)))
	    
(DEFINE-SHEET-FLAGS
  (EXCEPTIONS (BYTE 4 1))		;Reasons why typeout can't happen:
  (LINE-HEIGHT-CHANGE-FLAG (BYTE 1 1))	;Line height change processing needs to happen
  (END-PAGE-FLAG (BYTE 1 2))		;Cursor is below bottom limit
  (MORE-FLAG (BYTE 1 3))		;More processing needs to happen
  (OUTPUT-HOLD-FLAG (BYTE 1 4))		;Output may not happen on this sheet
  (RIGHT-MARGIN-CHARACTER-FLAG (BYTE 1 5))	;A special character (!) indicates wraparound
  (TRUNCATE-LINE-OUT-FLAG (BYTE 1 6))	;SHEET-LINE-OUT should truncate rather than wrap
  (DONT-BLINK-BLINKERS-FLAG (BYTE 1 7))	;Don't blink blinkers on this sheet or its inferiors
  (BACKSPACE-NOT-OVERPRINTING-FLAG (BYTE 1 10))	;Backspace is another lozenge character
  (CR-NOT-NEWLINE-FLAG (BYTE 1 11))	;CR is also
  (DEEXPOSED-TYPEIN-NOTIFY (BYTE 1 12))	;:DEEXPOSED-TYPEIN-ACTION :NOTIFY
  (FORCE-SAVE-BITS (BYTE 1 13))		;Force bit saving for SHEET-FORCE-ACCESS.
  (TAB-NCHARS (BYTE 7 14))		;Number of character widths in a tab
  (ALL-EXPOSED (BYTE 1 23))		;When 1, all superiors are exposed, so screen
					; array points to real hardware
  (DEAD (BYTE 1 24))			;:KILL has been done
  (IN-RECURSIVE-TYO (BYTE 1 25))	;:TYO has called itself recursively
  (TRUNCATE-OUTPUT-FLAG (BYTE 02 26))
   (TRUNCATE-OUTPUT-HORIZONTAL-FLAG (BYTE 01 26))
   (TRUNCATE-OUTPUT-VERTICAL-FLAG (BYTE 01 27))
  (REVERSE-VIDEO (BYTE 1 30))		;When 1, Sheet is "reverse video", whatever that means
  (AUTO-LINE-HEIGHT-FLAG (BYTE 1 31))	;Adjust line when tall character output.
  (SAVE-BITS (BYTE 1 32))		;Force bit saving on first deexposed
  (OFF-SCREEN-DRAWING-FLAG (BYTE 1 33))	;WITH-OFF-SCREEN-DRAWING on this sheet
  )

;;;Sizes within margins
(DEFMACRO SHEET-INSIDE-LEFT (&OPTIONAL SHEET)
  (IF SHEET `(SHEET-LEFT-MARGIN-SIZE ,SHEET) 'LEFT-MARGIN-SIZE))

(DEFMACRO SHEET-INSIDE-TOP (&OPTIONAL SHEET)
  (IF SHEET `(SHEET-TOP-MARGIN-SIZE ,SHEET) 'TOP-MARGIN-SIZE))

(DEFMACRO SHEET-INSIDE-RIGHT (&OPTIONAL SHEET)
  (IF SHEET
      `(- (SHEET-WIDTH ,SHEET) (SHEET-RIGHT-MARGIN-SIZE ,SHEET))
      `(- WIDTH RIGHT-MARGIN-SIZE)))

(DEFMACRO SHEET-INSIDE-BOTTOM (&OPTIONAL SHEET)
  (IF SHEET
      `(- (SHEET-HEIGHT ,SHEET) (SHEET-BOTTOM-MARGIN-SIZE ,SHEET))
      `(- HEIGHT BOTTOM-MARGIN-SIZE)))

(DEFMACRO SHEET-INSIDE-WIDTH (&OPTIONAL SHEET)
  (IF SHEET
      `(- (SHEET-WIDTH ,SHEET) (SHEET-LEFT-MARGIN-SIZE ,SHEET)
	  (SHEET-RIGHT-MARGIN-SIZE ,SHEET))
      `(- WIDTH LEFT-MARGIN-SIZE RIGHT-MARGIN-SIZE)))

(DEFMACRO SHEET-INSIDE-HEIGHT (&OPTIONAL SHEET)
  (IF SHEET
      `(- (SHEET-HEIGHT ,SHEET) (SHEET-TOP-MARGIN-SIZE ,SHEET)
	  (SHEET-BOTTOM-MARGIN-SIZE ,SHEET))
      `(- HEIGHT TOP-MARGIN-SIZE BOTTOM-MARGIN-SIZE)))

(DEFMACRO SHEET-TEMPORARY-P (&OPTIONAL SHEET)
  `(NOT (NULL ,(IF SHEET `(SHEET-TEMPORARY-BIT-ARRAY ,SHEET) 'TEMPORARY-BIT-ARRAY))))

(DEFMACRO SHEET-SUPERIOR-SCREEN-ARRAY (&OPTIONAL SHEET)
  (LET ((SUPERIOR (IF SHEET `(SHEET-SUPERIOR ,SHEET) 'SUPERIOR)))
    `(OR (SHEET-SCREEN-ARRAY ,SUPERIOR) (SHEET-OLD-SCREEN-ARRAY ,SUPERIOR))))

(DEFMACRO SHEET-OUTPUT-HELD-P (&OPTIONAL SHEET)
  (IF SHEET
      `(OR (NOT (ZEROP (SHEET-OUTPUT-HOLD-FLAG ,SHEET)))
	   (LISTP (SHEET-LOCK ,SHEET)))
      '(OR (NOT (ZEROP (SHEET-OUTPUT-HOLD-FLAG)))
	   (LISTP LOCK))))

(DEFMACRO SHEET-TRUNCATE-OUTPUT-P (&OPTIONAL SHEET (DIRECTION :ANY))
  (LET ((FUN (CL:ECASE DIRECTION
	       (:ANY 'SHEET-TRUNCATE-OUTPUT-FLAG)
	       (:HORIZONTAL 'SHEET-TRUNCATE-OUTPUT-HORIZONTAL-FLAG)
	       (:VERTICAL 'SHEET-TRUNCATE-OUTPUT-VERTICAL-FLAG))))
    `(NOT (ZEROP (,FUN . ,(UNLESS (OR (NULL SHEET) (EQ SHEET 'SELF))
			    `(,SHEET)))))))

(DEFMACRO SHEET-BITS-PER-PIXEL (&OPTIONAL SHEET)
  `(SCREEN-BITS-PER-PIXEL
     ,(IF SHEET `(SHEET-SCREEN ,SHEET) 'SCREEN)))

(DEFMACRO SHEET-LINE-NO (&OPTIONAL SHEET CURSOR-Y)
  `(FLOOR (- ,(COND (CURSOR-Y CURSOR-Y)
		    (SHEET `(SHEET-CURSOR-Y ,SHEET))
		    (T 'CURSOR-Y))
	     (SHEET-INSIDE-TOP ,SHEET))
	  ,(IF SHEET
	       `(SHEET-LINE-HEIGHT ,SHEET)
	       'LINE-HEIGHT)))

(DEFMACRO SHEET-NUMBER-OF-INSIDE-LINES (&OPTIONAL SHEET)
  `(// (SHEET-INSIDE-HEIGHT ,SHEET)
       ,(IF SHEET `(SHEET-LINE-HEIGHT ,SHEET) 'LINE-HEIGHT)))

(DEFMACRO SHEET-TAB-WIDTH (&OPTIONAL SHEET)
  `(* (SHEET-TAB-NCHARS ,SHEET)
      ,(IF SHEET `(SHEET-CHAR-WIDTH ,SHEET) 'CHAR-WIDTH)))

(DEFMACRO SHEET-GET-CHAR-FONT (CHAR &OPTIONAL ERROR-P SHEET)
  (IF SHEET
      `(SHEET-GET-CHAR-FONT-INTERNAL ,SHEET ,CHAR ,ERROR-P)
      `(IF (CHAR-FAT-P ,CHAR)
	   (SI:LOOKUP-FONT-CACHED CHARSET&STYLEFONT-CACHE ,CHAR
				  DISPLAY-DEVICE-TYPE MERGED-CURRENT-STYLE ,ERROR-P)
	   CURRENT-FONT)))

(DEFMETHOD (SHEET-GET-CHAR-FONT-INTERNAL SHEET) (CHAR &OPTIONAL ERROR-P)
  (SHEET-GET-CHAR-FONT CHAR ERROR-P))

(DEFMACRO SHEET-GET-CHAR-INDEX-AND-FONT (CHAR &OPTIONAL ERROR-P SHEET)
  (IF SHEET
      `(SI:LOOKUP-INDEX-AND-FONT 
	 ,CHAR (SHEET-DISPLAY-DEVICE-TYPE ,SHEET) (SHEET-MERGED-CURRENT-STYLE ,SHEET) ,ERROR-P)
      `(IF (CHAR-FAT-P ,CHAR)
	   (SI:LOOKUP-INDEX-AND-FONT ,CHAR DISPLAY-DEVICE-TYPE MERGED-CURRENT-STYLE ,ERROR-P)
	   (MULTIPLE-VALUE-BIND (IGNORE INDEX)
	       (SI:CHAR-CHAR-SET-AND-INDEX ,CHAR)
	     (VALUES INDEX CURRENT-FONT)))))

(DEFMACRO SHEET-GET-TOP-OF-FONT (FONT &OPTIONAL SHEET)
  (LET ((BASELINE-FORM (IF SHEET
			   `(SHEET-CURRENT-BASELINE ,SHEET)
			   'CURRENT-BASELINE)))
    `(IF ,FONT
	 (- ,BASELINE-FORM (FONT-BASELINE ,FONT))
	 (- ,BASELINE-FORM (SHEET-LOZENGE-BASELINE ,SHEET)))))

(DEFFLAVOR SHEET-TIME-STAMP
	(INSIDE-WIDTH INSIDE-HEIGHT
	 TOP-MARGIN-SIZE LEFT-MARGIN-SIZE
	 CHAR-ALUF ERASE-ALUF
	 RESOURCE-TICK
	 DISPLAY-DEVICE-TYPE)
	()
  :INITABLE-INSTANCE-VARIABLES
  :READABLE-INSTANCE-VARIABLES)

;;;A blinker is an actor, described as follows:
(DEFFLAVOR BLINKER
	((X-POS NIL)				;X position of blinker (left) NIL if should follow sheet
	 (Y-POS NIL)				;Y position of blinker (top)
	 SHEET					;Sheet associated with
	 (VISIBILITY ':BLINK)			;NIL invisible, T visible, :BLINK blinking, :ON visible but
						; blinking when selected, :OFF invisibile but ...
	 (DESELECTED-VISIBILITY ':ON)		;Blinker's visibility when the sheet it is on is
						; not selected, reasonable values :ON, :OFF and :BLINK
	 (HALF-PERIOD 15.)			;Time interval (60ths) between phase blinks
	 (PHASE NIL)				;NIL not visible, anything else visible in some form
						; (Complementing blinker has only two phases, uses NIL, T)
	 (TIME-UNTIL-BLINK 0)			;Time interval until next blink.  NIL means not blinking,
						; the clock level should ignore this blinker.
	 (FOLLOW-P NIL)
	 (BLINKER-ALU)
	 )
	()
  :ORDERED-INSTANCE-VARIABLES
  :READABLE-INSTANCE-VARIABLES
  (:WRITABLE-INSTANCE-VARIABLES X-POS Y-POS VISIBILITY DESELECTED-VISIBILITY
				HALF-PERIOD TIME-UNTIL-BLINK BLINKER-ALU)
  (:INITABLE-INSTANCE-VARIABLES X-POS Y-POS SHEET VISIBILITY FOLLOW-P BLINKER-ALU)
  (:GETTABLE-INSTANCE-VARIABLES X-POS Y-POS SHEET VISIBILITY FOLLOW-P)
  (:SETTABLE-INSTANCE-VARIABLES DESELECTED-VISIBILITY HALF-PERIOD)
  (:REQUIRED-METHODS :BLINK :SIZE)
  (:DEFAULT-INIT-PLIST :AREA BLINKER-AREA))

(DEFMACRO BLINKER-SET-CURSORPOS (BLINKER X Y)
  `(SEND ,BLINKER ':SET-CURSORPOS ,X ,Y))

(DEFMACRO BLINKER-READ-CURSORPOS (BLINKER)
  `(SEND ,BLINKER ':READ-CURSORPOS))

(DEFMACRO BLINKER-SET-VISIBILITY (BLINKER VISIBILITY)
  `(SEND ,BLINKER ':SET-VISIBILITY ,VISIBILITY))

(DEFMACRO BLINK (BLINKER)
  `(SEND ,BLINKER ':BLINK))

(DEFMACRO BLINKER-SET-SIZE (BLINKER WIDTH HEIGHT)
  `(SEND ,BLINKER ':SET-SIZE ,WIDTH ,HEIGHT))

(DEFMACRO BLINKER-SET-CHARACTER (BLINKER CHAR)
  `(SEND ,BLINKER ':SET-CHARACTER ,CHAR))

(DEFMACRO BLINKER-SET-SHEET (BLINKER SHEET)
  `(SEND ,BLINKER ':SET-SHEET ,SHEET))

;;; This macro generates the prologue code that most of the
;;; interesting blinker methods need.
(DEFMACRO WITH-BLINKER-PREPARED ((BLINKER &KEY (OPEN T) (WHEN T)) &BODY BODY)
  (FLET ((CAPTURE-FORM (KEYWORD DEFAULT FORM)
	   (COND ((EQ FORM DEFAULT)
		  NIL)
		 ((EQ FORM NIL)
		  `(,KEYWORD #'IGNORE))
		 ((EQ FORM T)
		  `(,KEYWORD #'TRUE))
		 (T
		  `(,KEYWORD #'(LAMBDA () ,FORM))))))	       
    `(WITH-BLINKER-PREPARED-INTERNAL ,BLINKER #'(LAMBDA () ,@BODY)
				     ,@(CAPTURE-FORM :OPEN T OPEN)
				     ,@(CAPTURE-FORM :WHEN T WHEN)
				     )))

;;; For compatibility with Genera 7.
(DEFMACRO WITH-BLINKER-READY (DO-NOT-OPEN-P &BODY BODY)
  `(WITH-BLINKER-PREPARED (SELF :OPEN ,(NOT DO-NOT-OPEN-P))
     ,@BODY))

(DEFGENERIC WITH-BLINKER-PREPARED-INTERNAL (BLINKER CONTINUATION &KEY OPEN WHEN)
  (DECLARE (SYS:DOWNWARD-FUNARG *)))

(DEFMACRO WITH-BLINKER-OFF ((WINDOW) &BODY BODY)
  `(WITH-BLINKER-VISIBILITY (,WINDOW NIL)
     . ,BODY))

(DEFMACRO WITH-BLINKER-VISIBILITY ((WINDOW NEW-VISIBILITY) &BODY BODY)
  `(LET* ((.BLINKER. (SEND ,WINDOW :FOLLOWING-BLINKER))
	  (.OLD-VISIBILITY. (AND .BLINKER. (SEND .BLINKER. :VISIBILITY))))
     (UNWIND-PROTECT
	 (PROGN
	   (WHEN .BLINKER.
	     (SEND .BLINKER. :SET-VISIBILITY ,NEW-VISIBILITY))
	   . ,BODY)
       (WHEN .BLINKER.
	 (SEND .BLINKER. :SET-VISIBILITY .OLD-VISIBILITY.)))))

(DEFFLAVOR RECTANGULAR-BLINKER
	((WIDTH NIL)		;The width
	 (HEIGHT NIL))
	(BLINKER)
  (:INITABLE-INSTANCE-VARIABLES WIDTH HEIGHT))

(DEFFLAVOR MOUSE-BLINKER-MIXIN ((X-OFFSET 0) (Y-OFFSET 0)) ()
  (:REQUIRED-FLAVORS BLINKER)
  :INITABLE-INSTANCE-VARIABLES
  (:DOCUMENTATION :MIXIN "Blinker that is capable of being MOUSE-BLINKER"))

(DEFFLAVOR MOUSE-BLINKER-FAST-TRACKING-MIXIN () (MOUSE-BLINKER-MIXIN)
  (:REQUIRED-FLAVORS BLINKER)
  (:DOCUMENTATION :MIXIN
     "Blinker that is capable of being MOUSE-BLINKER and gets tracked by microcode.")
  (:REQUIRED-METHODS MOUSE-BLINKER-MAKE-CURSOR))

(DEFGENERIC MOUSE-BLINKER-FLUSH-CURSOR-CACHE (BLINKER)
  (:METHOD-COMBINATION :PROGN))



;;; Grab the lock on a sheet.
;;; This is intended as an eventual replacement for LOCK-SHEET.
;;; At present, it does not actually lock the sheet.  It waits for it to be lockable
;;; and disables the scheduler instead.  This makes it compatible with what PREPARE-SHEET,
;;; WITH-BLINKER-READY, and other code did in Genera 7.
(DEFMACRO X-LOCK-SHEET ((SHEET &KEY ALLOW-OUTPUT (WAIT-FOR-LOCK T))
			(&REST GUARDS)
			&BODY BODY)
  (WHEN ALLOW-OUTPUT
    (PUSH '(SHEET-NEEDS-OUTPUT-HOLD-EXCEPTION SHEET-SIGNAL-OUTPUT-HOLD-EXCEPTION)
	  GUARDS))
  (LET ((ARGS `(,@(UNLESS (EQ WAIT-FOR-LOCK T)
		    `(:WAIT-FOR-LOCK ,WAIT-FOR-LOCK)))))
    (IF GUARDS
	`(STACK-LET ((.GUARDS.
		       (LIST
			 ,@(MAPCAR #'(LAMBDA (GUARD)
				       (CL:ECASE (LENGTH GUARD)
					 (2
					   `(CONS #',(FIRST GUARD) #',(SECOND GUARD)))
					 (3
					   (SCL:DESTRUCTURING-BIND (ARGLIST TEST BODY) GUARD
					     `(CONS #'(LAMBDA ,ARGLIST
							(DECLARE (SYS:DOWNWARD-FUNCTION))
							,TEST)
						    #'(LAMBDA ,ARGLIST
							(DECLARE (SYS:DOWNWARD-FUNCTION))
							,BODY))))))
				   GUARDS))))
	   (LOCK-SHEET-1 ,SHEET #'(LAMBDA () ,@BODY) :GUARDS .GUARDS. ,@ARGS))
	`(LOCK-SHEET-1 ,SHEET #'(LAMBDA () ,@BODY) ,@ARGS))))

(DEFGENERIC LOCK-SHEET-1 (SHEET CONTINUATION &KEY GUARDS)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION)))



;;; Grab the lock on a sheet
(DEFMACRO LOCK-SHEET ((SHEET) &BODY BODY)
  `(UNWIND-PROTECT
     (PROGN (SHEET-GET-LOCK ,SHEET)
       . ,BODY)
     (SHEET-RELEASE-LOCK ,SHEET)))

;;; Grab the lock on a sheet if it's available and execute the THEN clause.
;;; If it's not available, execute the ELSE clause instead.
(DEFMACRO MAYBE-LOCK-SHEET (SHEET THEN ELSE)
  `(LET ((OLD-INHIBIT-SCHEDULING-FLAG INHIBIT-SCHEDULING-FLAG)
	 (INHIBIT-SCHEDULING-FLAG T))
     (COND ((SHEET-CAN-GET-LOCK ,SHEET CURRENT-PROCESS)
	    (SHEET-GET-LOCK-INTERNAL ,SHEET CURRENT-PROCESS)
	    (SETQ INHIBIT-SCHEDULING-FLAG OLD-INHIBIT-SCHEDULING-FLAG)
	    (UNWIND-PROTECT ,THEN
			    (SHEET-RELEASE-LOCK ,SHEET)))
	   (T
	    (SETQ INHIBIT-SCHEDULING-FLAG OLD-INHIBIT-SCHEDULING-FLAG)
	    ,ELSE))))

;;; Variables for directed wakeups of processes waiting for sheets

(DEFVAR *NUMBER-OF-SHEET-LOCK-WAITERS* 0)
(DEFCONSTANT MAXIMUM-SHEET-LOCK-WAITERS 10)
(DEFVAR *SHEET-LOCK-WAITERS* (MAKE-ARRAY MAXIMUM-SHEET-LOCK-WAITERS))
(DEFVAR *NUMBER-OF-SHEET-LOCK-WAITERS-OVERFLOWS* 0)
(DEFVAR *NUMBER-OF-MOUSE-WAITERS* 0)
(DEFCONSTANT MAXIMUM-MOUSE-WAITERS 10)
(DEFVAR *MOUSE-WAITERS* (MAKE-ARRAY MAXIMUM-MOUSE-WAITERS))
(DEFVAR *NUMBER-OF-MOUSE-WAITERS-OVERFLOWS* 0)

;;; Wrap this around any drawing on this screen including blinking blinkers
;;; Typically this is called inside a WITHOUT-INTERRUPTS so no preempt with the lock held
;;; The only reason we need a lock is to deal with explicit blocking, e.g. when
;;; communicating with the hardware screen through a network
;;; Do not wait for any sheet-locks while holding the screen-controller-lock
;;; Unlike the sheet-locks, the screen-controller-lock can be awaited by the mouse process
(DEFMACRO WITH-SCREEN-CONTROLLER-LOCK ((SCREEN) &BODY BODY)
  `(PROCESS:WITH-LOCK ((SCREEN-LOCK ,SCREEN))
     ,@BODY))

(DEFMACRO WITHOUT-SCREEN-CONTROLLER-LOCK ((SCREEN) &BODY BODY)
  `(PROCESS:WITHOUT-LOCK ((SCREEN-LOCK ,SCREEN))
     ,@BODY))

(DEFVAR-RESETTABLE CURRENTLY-PREPARED-SHEET NIL)

;;; Allow output to a sheet
;; Caller must ensure that the sheet is locked and that its screen's controller lock is locked.
(DEFMACRO SHEET-IS-PREPARED ((SHEET) &BODY BODY)
  `(LET ((CURRENTLY-PREPARED-SHEET ,SHEET))
     ,@BODY))

;;; Open up a sheet
(DEFVAR-RESETTABLE PREPARED-SHEET NIL)

(DEFMACRO PREPARE-SHEET ((SHEET) &BODY BODY)
  `(PREPARE-SHEET-1 (NAMED-LAMBDA PREPARE-SHEET () . ,BODY) ,SHEET))

(DEFSUBST PREPARE-SHEET-2 (SHEET)
  (WHEN (OR (NOT (EQ PREPARED-SHEET SHEET))
	    (NOT (ZEROP (SHEET-OUTPUT-HOLD-FLAG SHEET))))
    (SHEET-PREPARE-SHEET-INTERNAL SHEET)
    (SETF PREPARED-SHEET SHEET)))

(DEFUN PREPARE-SHEET-1 (CONTINUATION SHEET)
  (DECLARE (DOWNWARD-FUNARG CONTINUATION))
  (COND ((EQ SHEET CURRENTLY-PREPARED-SHEET)
	 (FUNCALL CONTINUATION))
	((AND CURRENTLY-PREPARED-SHEET
	      (LOOP AS S = (SHEET-SUPERIOR SHEET) THEN (SHEET-SUPERIOR S)
		    WHILE S WHEN (EQ S CURRENTLY-PREPARED-SHEET)
			      RETURN (NOT (SHEET-OUTPUT-HELD-P SHEET))))
	 (LET ((CURRENTLY-PREPARED-SHEET SHEET))
	   (FUNCALL CONTINUATION)))
	(T (MULTIPLE-VALUE-PROG1
	     (LOCK-SHEET (SHEET)
	       (WITH-SCREEN-CONTROLLER-LOCK ((SHEET-SCREEN SHEET))
		 (PREPARE-SHEET-2 SHEET)
		 (LET ((CURRENTLY-PREPARED-SHEET SHEET))
		   (FUNCALL CONTINUATION))))
	     (WHEN SI:*PENDING-PROCESS-ABORTS*
	       (PROCESS::CHECK-PENDING-PROCESS-ABORTS-1))))))

(DEFMACRO WITH-SAVED-SCREEN-HARDWARE-STATE ((SCR) &BODY BODY)
  `(WITH-SAVED-SCREEN-HARDWARE-STATE-INTERNAL
     ,SCR
     #'(LAMBDA () (DECLARE (SYS:DOWNWARD-FUNCTION)) ,@BODY)))

;; use this macro to un prepare a sheet for a breather
;; This is used a lot by Color, but perhaps not by anything else
(DEFMACRO UNPREPARE-SHEET (&BODY BODY)
  `(UNPREPARE-SHEET-1 #'(NAMED-LAMBDA UNPREPARE-SHEET () ,@BODY)))


(DEFUN UNPREPARE-SHEET-1 (CONTINUATION)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION))
  (LET ((SHEET CURRENTLY-PREPARED-SHEET))
    (WHEN (NULL SHEET)
      (RETURN-FROM UNPREPARE-SHEET-1
	(FUNCALL CONTINUATION)))
    (LET ((CURRENTLY-PREPARED-SHEET NIL)
	  RELOCK
	  (SCR (SHEET-SCREEN SHEET)))
      (WITH-SAVED-SCREEN-HARDWARE-STATE (SCR)
	(WITHOUT-SCREEN-CONTROLLER-LOCK (scr) 
	  (UNWIND-PROTECT
	      (PROGN
		(SETQ RELOCK (SHEET-RELEASE-LOCK SHEET))
		(FUNCALL CONTINUATION))
	    (WHEN RELOCK (SHEET-GET-LOCK SHEET))
	    (PREPARE-SHEET-2 SHEET)))))))

;;; Redirects a screen array
(DEFVAR %CURRENT-SHEET)

;;
;; This is a hairy macro that deals with the sheet/array dichotomy.  The principal arg,
;; SHEET, is a window, an array, or NIL.   If it is a window, then it is made the
;; prepared sheet.   The rest of the args are keywords, whose values are the names
;; of variables to be bound to the corresponding values. computed from the sheet
;; or its screen array.

;;
;; This is a hairy macro that deals with the sheet/array dichotomy.  The principal arg,
;; SHEET, is a window, an array, or NIL.   If it is a window, then it is made the
;; prepared sheet.   The rest of the args are keywords, whose values are the names
;; of variables to be bound to the corresponding values. computed from the sheet
;; or its screen array.
(DEFMACRO WITH-PREPARED-SHEET-OR-RASTER
	  ((SHEET &KEY
		  WINDOW		;; gets bound to window or NIL if not a window
		  ARRAY			;; gets bound to the screen array, or array, or NIL
		  			;; but allways an array or NIL
		  SCREEN-ARRAY          ;; gets bound to the screen array or array or nil
		  			;; can be any non-nil screen array including pixmaps
		  BITS-PER-PIXEL	;; gets bound to the bits-per-pixel of the array
		  SPAN			;; gets bound to the array-row-span of the array
		  ;; also declares array as array-register-1d
		  INSIDE-LEFT		;; bound to sheet-inside-left or 0
		  INSIDE-TOP		;; bound to sheet-inside-top of 0
		  INSIDE-WIDTH		;; bound to sheet-inside-width or raster-array-width
		  INSIDE-HEIGHT		;; bound to sheet-inside-height or raster-array-height
		  WIDTH 		;; full width 
		  HEIGHT		;; full height
		  SCREEN		;; bound to screen associated with window or NIL
		  FORCE-PREPARE		;; force prepare-sheet, even if no call for array
		  ARRAY-ONLY 		;; if don't look for window ar top level
		  SHEET-ONLY 		;; don't look for an array at top level
		  ;; force preparation of ARRAY as an ARRAY-REGISTER
		  (DECLARE-ARRAY-REGISTER SPAN)
		  )
	   &BODY BODY &AUX )
  (WHEN ARRAY-ONLY (SETQ FORCE-PREPARE NIL))

  (LET* ((LOC-SHEET (UNLESS ARRAY-ONLY (IF (AND (SYMBOLP SHEET) (NEQ SHEET ARRAY))
					   SHEET
					   (MAKE-SYMBOL "SHEET" ))))
	 (LOC-WINDOW (OR WINDOW (IF ARRAY-ONLY NIL (MAKE-SYMBOL "WINDOW"))))
	 (LOC-ARRAY (OR ARRAY (MAKE-SYMBOL "ARRAY")))
	 (LOC-SCREEN-ARRAY (or SCREEN-ARRAY (MAKE-SYMBOL "SCREEN-ARRAY")))
	 (window-needed (or window screen))
	 (array-needed (OR ARRAY SPAN BITS-PER-PIXEL INSIDE-WIDTH INSIDE-HEIGHT WIDTH HEIGHT))
	 (CORE `(LET* (,@(WHEN (AND (OR ARRAY-NEEDED SCREEN-ARRAY)
				    (NOT (and array-only (neq loc-screen-array screen-array))))
			   `((,LOC-SCREEN-ARRAY
			      (COND ,@(WHEN LOC-WINDOW
					(setq window-needed t)
					`((,LOC-WINDOW
					   (TV:SHEET-SCREEN-ARRAY ,LOC-WINDOW))))
				    ,@(WHEN ARRAY-ONLY
					`((,SHEET)))
				    ,@(UNLESS SHEET-ONLY
					`((,LOC-SHEET)))))))
		       ,@(when array-needed
			   `((,LOC-ARRAY (COND ,@(unless sheet-only
						   `(((ARRAYP ,SHEET) ,SHEET)))
					       ,@(unless array-only
						   `(((ARRAYP ,LOC-SCREEN-ARRAY)
						      ,LOC-SCREEN-ARRAY)))))))
		       ,@(WHEN BITS-PER-PIXEL
			   `((,BITS-PER-PIXEL
			      (COND ,@(WHEN SCREEN
					`((,SCREEN (SHEET-BITS-PER-PIXEL ,SCREEN))))
				    ,@(WHEN (AND LOC-ARRAY (NOT SHEET-ONLY))
					`((,LOC-ARRAY
					   (ARRAY-ELEMENT-BYTE-SIZE ,LOC-ARRAY))))
				    ,@(WHEN (AND (NULL ARRAY-ONLY) (NULL SCREEN))
					(setq window-needed t)
					`((,LOC-WINDOW (SHEET-BITS-PER-PIXEL
							(SHEET-SCREEN ,LOC-WINDOW)))))
			      ))))
		       )
		  ,@(WHEN DECLARE-ARRAY-REGISTER `((DECLARE (ARRAY-REGISTER-1D ,LOC-ARRAY))))
		  ,@(IF (OR INSIDE-WIDTH INSIDE-HEIGHT INSIDE-LEFT INSIDE-TOP
			    WIDTH HEIGHT SPAN)
			`((LET* (,@(WHEN INSIDE-WIDTH
				     `(,INSIDE-WIDTH))
				 ,@(WHEN INSIDE-HEIGHT
				     `(,INSIDE-HEIGHT))
				 ,@(WHEN WIDTH
				     `(,WIDTH))
				 ,@(WHEN HEIGHT
				     `(,HEIGHT))
				 ,@(WHEN INSIDE-TOP
				     `((,INSIDE-TOP 0)))
				 ,@(WHEN INSIDE-LEFT
				     `((,INSIDE-LEFT 0)))
				 ,@(WHEN SPAN
				     `(,SPAN))
				 )
			    ,@(IF SPAN
				  `((WHEN ,LOC-ARRAY
				     (MULTIPLE-VALUE (,(OR WIDTH INSIDE-WIDTH)
						      ,(OR HEIGHT INSIDE-HEIGHT)
						      ,SPAN)
						     (DECODE-RASTER-ARRAY ,LOC-ARRAY)))))
			    ,@(IF LOC-WINDOW 
				  `((IF (EQ ,(progn (setq window-needed t) LOC-WINDOW)
					    ,LOC-SHEET)
					D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");only use the sheet inside paramaters if the
0					1;sheet was passed to us, not if we found the
0					1;sheet from the array.
0					  (WHEN ,LOC-SHEET
					    ,@(WHEN INSIDE-TOP
						`((SETQ ,INSIDE-TOP
							(TV:SHEET-INSIDE-TOP ,LOC-WINDOW))))
					    ,@(WHEN INSIDE-LEFT
						`((SETQ ,INSIDE-LEFT
							(TV:SHEET-INSIDE-LEFT ,LOC-WINDOW))))
					    ,@(WHEN INSIDE-WIDTH
						`((SETQ ,INSIDE-WIDTH
							(SHEET-INSIDE-WIDTH ,LOC-WINDOW))))
					    ,@(WHEN INSIDE-HEIGHT
						`((SETQ ,INSIDE-HEIGHT
							(SHEET-INSIDE-HEIGHT ,LOC-WINDOW))))
					    ,@(WHEN WIDTH
						`((SETQ ,WIDTH (SHEET-WIDTH ,LOC-WINDOW))))
					    ,@(WHEN HEIGHT
						`((SETQ ,HEIGHT (SHEET-HEIGHT ,LOC-WINDOW))))
					    )
					  ,@(UNLESS SHEET-ONLY
					      `(,@(WHEN (AND (NOT SPAN)
							     (OR WIDTH INSIDE-WIDTH
								 HEIGHT INSIDE-HEIGHT))
						    `((WHEN ,LOC-ARRAY
							1;loc array is assured to be
							;an array or NIL
0							(MULTIPLE-VALUE
							  (,(OR WIDTH INSIDE-WIDTH)
							   ,(OR HEIGHT INSIDE-HEIGHT))
							  (DECODE-RASTER-ARRAY ,LOC-ARRAY))))
						    )
						,@(WHEN (AND INSIDE-WIDTH WIDTH)
						    `((SETQ ,INSIDE-WIDTH ,WIDTH)))
						,@(WHEN (AND INSIDE-HEIGHT HEIGHT)
						    `((SETQ ,INSIDE-HEIGHT ,HEIGHT))))))))
			    ,@BODY))
			BODY))
	       )
	 (PREP-SHEET (IF (AND (NULL FORCE-PREPARE) (OR ARRAY-ONLY (NULL ARRAY)))
			 CORE
			 `(FLET ((.DO-IT. () ,CORE))
			    (IF ,(progn (setq window-needed t) LOC-WINDOW)
				(PREPARE-SHEET-1 #'.DO-IT. ,LOC-WINDOW)
				(.DO-IT.)))))
	 )
    `(LET* (,@(UNLESS (OR ARRAY-ONLY (EQ LOC-SHEET SHEET))
		1;avoid a superfluous binding if possible
0		`((,LOC-SHEET ,SHEET)))
	    
	    ,@(WHEN window-needed
		`((,LOC-WINDOW
		  1;if the user explicitly asked for a window, use raster-sheet
0		  1;to macimize the chance of finding one.  Otherwise, preserve
0		  1;the old behavior by finding a sheet only if he gave us one.
0		   ,(if (or window force-prepare)
				    `(tv:raster-sheet ,loc-sheet)
				    `(when (typep ,loc-sheet 'sheet) ,loc-sheet))
				    )))
	    ,@(WHEN SCREEN `((,SCREEN (WHEN ,LOC-WINDOW (TV:SHEET-SCREEN ,LOC-WINDOW))))))
       ,PREP-SHEET)
    ))

(DEFMACRO WITH-PREPARED-RASTER ((&REST OPTIONS) &BODY BODY)
  `(WITH-PREPARED-SHEET-OR-RASTER
     (,@OPTIONS
      :ARRAY-ONLY T
      :FORCE-PREPARE NIL)
     ,@BODY))

(DEFMACRO WITH-PREPARED-SHEET ((&REST OPTIONS) &BODY BODY)
  `(WITH-PREPARED-SHEET-OR-RASTER
     (,@OPTIONS
      :SHEET-ONLY T)
     ,@BODY))

;;; Force access to a sheet and execute the code within.  If access cannot be
;;; forced, then the code is not executed.  Forcing access means binding off
;;; the output hold flag if the sheet is deexposed and has a bit-save array.
;;; The code is also executed of the sheet is exposed and not output-held.
(DEFMACRO SHEET-FORCE-ACCESS ((SHEET &OPTIONAL DONT-PREPARE-SHEET) &BODY BODY)
  `(SHEET-FORCE-ACCESS-1 ,SHEET #'(LAMBDA () ,@BODY)
			 ,@(WHEN (NOT DONT-PREPARE-SHEET) `(:PREPARE-SHEET T))))

(DEFGENERIC SHEET-FORCE-ACCESS-1 (SHEET CONTINUATION &KEY PREPARE-SHEET)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION)))

(DEFMACRO SHEET-INCREMENT-BITPOS (DX DY)
  "Increment cursor X and cursor Y, keeping within sheet.  Sets exception flags
according to new positions"
  `(PROGN
     (SETQ CURSOR-X (MAX (+ ,DX CURSOR-X) (SHEET-INSIDE-LEFT)))
     (SETQ CURSOR-Y (MAX (+ ,DY CURSOR-Y) (SHEET-INSIDE-TOP)))
     (SHEET-CHECK-MORE-POSITION CURRENT-LINE-HEIGHT)))

(DEFMACRO SHEET-CHECK-MORE-POSITION (DY &ENVIRONMENT ENV)
  (ONCE-ONLY (DY &ENVIRONMENT ENV)
    `(PROGN
       (AND (> (+ CURSOR-Y ,DY) (SHEET-INSIDE-BOTTOM))
	    (SETF (SHEET-END-PAGE-FLAG) 1))
       (AND MORE-VPOS ( (+ CURSOR-Y (- ,DY LINE-HEIGHT)) MORE-VPOS)
	    (SETF (SHEET-MORE-FLAG) 1)))))



(DEFMACRO WITH-SHEET-DEEXPOSED ((SHEET) &BODY BODY)
  `(LET ((.STATUS. (SEND ,SHEET ':STATUS)))
     (DELAYING-SCREEN-MANAGEMENT
       (UNWIND-PROTECT
	   (PROGN (SEND ,SHEET ':DEEXPOSE ':DEFAULT ':NOOP)
		  . ,BODY)
	 (SET-SHEET-STATUS-AT-LEAST ,SHEET .STATUS.)))))


;
; New macro to ensure the SHEET-ALL-EXPOSED flag is temporarily off, so
; no attempt will be made to use color hardware.
;
(defmacro WITH-SHEET-NOT-ALL-EXPOSED ((sheet) . body)
  `(let ((.all-exposed. (sheet-all-exposed ,sheet)))
     (unwind-protect ()
       (progn (setf (sheet-all-exposed ,sheet) 0)
	      ,@body)
       (setf (sheet-all-exposed ,sheet) .all-exposed.))))


(DEFMACRO WINDOW-BIND ((WINDOW NEW-TYPE . INIT-PAIRS) &BODY BODY)
  "Change the type of a window within the body."
  (CHECK-ARG WINDOW SYMBOLP "a symbol which is set to a window")
    `(LET ((.O.WINDOW. ,WINDOW) (.N.WINDOW.) (,WINDOW ,WINDOW) (TERMINAL-IO TERMINAL-IO))
       (UNWIND-PROTECT
	 (PROGN (SETQ .N.WINDOW. (WINDOW-PUSH ,WINDOW ,NEW-TYPE . ,INIT-PAIRS))
		(SETQ ,WINDOW .N.WINDOW.)
		(AND (EQ .O.WINDOW. TERMINAL-IO) (SETQ TERMINAL-IO ,WINDOW))
	   . ,BODY)
	 (AND .N.WINDOW. (WINDOW-POP .O.WINDOW. .N.WINDOW.)))))

;; Too bad we don't have a real activity system yet.
(DEFMACRO WITH-ALIAS-FOR-SELECTED-WINDOWS (WINDOW ALIAS &BODY BODY)
  `(SEND ,WINDOW :WITH-ALIAS-FOR-SELECTED-WINDOWS-1 ,ALIAS
	 (NAMED-LAMBDA WITH-ALIAS-FOR-SELECTED-WINDOWS ()
	   ,@BODY)))

;;;Temporarily select a window
(DEFMACRO WINDOW-CALL ((WINDOW &OPTIONAL FINAL-ACTION &REST FINAL-ACTION-ARGS) &BODY BODY)
  `(WINDOW-CALL-INTERNAL ,WINDOW
			 #'(NAMED-LAMBDA WINDOW-CALL () ,@BODY)
			 ,FINAL-ACTION ,@FINAL-ACTION-ARGS))

(DEFUN WINDOW-CALL-INTERNAL (WINDOW CONTINUATION FINAL-ACTION &REST FINAL-ACTION-ARGS)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION))
  (LET ((CURRENT-WINDOW (SHEET-SELECTED-WINDOW WINDOW)))
    (WHEN CURRENT-WINDOW
      (LET ((ACTIVITY (SEND CURRENT-WINDOW :ALIAS-FOR-SELECTED-WINDOWS)))
	(UNLESS (EQ ACTIVITY (SEND WINDOW :ALIAS-FOR-SELECTED-WINDOWS))
	  (SETQ CURRENT-WINDOW ACTIVITY))))
    (UNWIND-PROTECT
	(PROGN (SEND WINDOW :SELECT)
	       (FUNCALL CONTINUATION))
      ;; Reselect old window -- be careful not to reselect if we aren't still the currently
      ;; selected window, thus preventing spurious selection
      (LET ((FLAG (SHEET-ME-OR-MY-KID-P (SHEET-SELECTED-WINDOW WINDOW) WINDOW)))
	(IF FINAL-ACTION
	    (DELAYING-SCREEN-MANAGEMENT
	      (LEXPR-SEND WINDOW FINAL-ACTION FINAL-ACTION-ARGS)
	      (WHEN (AND CURRENT-WINDOW FLAG
			 (WINDOW-IS-EXPOSABLE-INFERIOR CURRENT-WINDOW))
		(SEND CURRENT-WINDOW :SELECT NIL)))
	    (WHEN (AND CURRENT-WINDOW FLAG
		       (WINDOW-IS-EXPOSABLE-INFERIOR CURRENT-WINDOW))
	      (SEND CURRENT-WINDOW :SELECT NIL)))))))

;;;Temporarily select a window and reselect old one relative to its (their?) activity
(DEFMACRO WINDOW-CALL-RELATIVE ((WINDOW &OPTIONAL FINAL-ACTION &REST FINAL-ACTION-ARGS)
				&BODY BODY)
  `(WINDOW-CALL-RELATIVE-INTERNAL
     ,WINDOW #'(NAMED-LAMBDA WINDOW-CALL-RELATIVE () (DECLARE (SYS:DOWNWARD-FUNCTION)) ,@BODY)
     ,FINAL-ACTION
     ,@FINAL-ACTION-ARGS))

(DEFUN WINDOW-CALL-RELATIVE-INTERNAL
       (WINDOW CONTINUATION FINAL-ACTION &REST FINAL-ACTION-ARGS)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION))
  ;; CURRENT-WINDOW gets the window that is currently selected within the activity
  ;; that is relevant to this operation.
  (LET ((CURRENT-WINDOW (SEND WINDOW :ALIAS-FOR-SELECTED-WINDOWS)))
    (SETQ CURRENT-WINDOW (OR (SEND-IF-HANDLES CURRENT-WINDOW :SELECTED-PANE)
			     CURRENT-WINDOW))     
    (UNWIND-PROTECT
	(PROGN (SEND WINDOW :SELECT-RELATIVE)
	       (FUNCALL CONTINUATION))
      ;; Reselect old window
      (IF FINAL-ACTION
	  (DELAYING-SCREEN-MANAGEMENT
	    (LEXPR-SEND WINDOW FINAL-ACTION FINAL-ACTION-ARGS)
	    (SEND CURRENT-WINDOW :SELECT-RELATIVE))
	  (SEND CURRENT-WINDOW :SELECT-RELATIVE)))))

(DEFMACRO WINDOW-MOUSE-CALL ((WINDOW &OPTIONAL FINAL-ACTION &REST FINAL-ACTION-ARGS)
			     &BODY BODY)
  `(WINDOW-MOUSE-CALL-INTERNAL
     ,WINDOW #'(NAMED-LAMBDA WINDOW-MOUSE-CALL () (DECLARE (SYS:DOWNWARD-FUNCTION)) ,@BODY)
     ,FINAL-ACTION
     ,@FINAL-ACTION-ARGS))

(DEFUN WINDOW-MOUSE-CALL-INTERNAL (WINDOW CONTINUATION FINAL-ACTION &REST FINAL-ACTION-ARGS)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION))
  (LET ((CURRENT-WINDOW (SHEET-SELECTED-WINDOW WINDOW)))
    (UNWIND-PROTECT
	(PROGN (WHEN CURRENT-WINDOW
		 (LET ((ACTIVITY (SEND CURRENT-WINDOW :ALIAS-FOR-SELECTED-WINDOWS)))
		   (UNLESS (EQ ACTIVITY (SEND WINDOW :ALIAS-FOR-SELECTED-WINDOWS))
		     (SETQ CURRENT-WINDOW ACTIVITY))))
	       (SEND WINDOW :MOUSE-SELECT)
	       (FUNCALL CONTINUATION))
      (IF FINAL-ACTION
	  (DELAYING-SCREEN-MANAGEMENT
	    (LEXPR-SEND WINDOW FINAL-ACTION FINAL-ACTION-ARGS)
	    (WHEN (AND CURRENT-WINDOW (WINDOW-IS-EXPOSABLE-INFERIOR CURRENT-WINDOW))
	      (SEND CURRENT-WINDOW :SELECT NIL)))
	  (WHEN (AND CURRENT-WINDOW (WINDOW-IS-EXPOSABLE-INFERIOR CURRENT-WINDOW))
	    (SEND CURRENT-WINDOW :SELECT NIL))))))

;;; Temporarily select the typeout window overlying a window,
;;; and bind TERMINAL-IO to it.
(DEFMACRO WITH-TERMINAL-IO-ON-TYPEOUT-WINDOW ((WINDOW WAIT-FOR-SPACE-P) &BODY BODY)
  `(WITH-TERMINAL-IO-ON-TYPEOUT-WINDOW-INTERNAL
     ,WINDOW ,WAIT-FOR-SPACE-P
     #'(NAMED-LAMBDA WITH-TERMINAL-IO-ON-TYPEOUT-WINDOW ()
	 (DECLARE (SYS:DOWNWARD-FUNCTION)) ,@BODY)))

(DEFUN WITH-TERMINAL-IO-ON-TYPEOUT-WINDOW-INTERNAL (WINDOW WAIT-FOR-SPACE-P CONTINUATION)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION))
  (LET ((CURRENT-WINDOW (SHEET-SELECTED-WINDOW WINDOW))
	(TERMINAL-IO (SEND WINDOW :TYPEOUT-WINDOW)))
    (UNWIND-PROTECT
	(PROGN (SEND TERMINAL-IO :EXPOSE-FOR-TYPEOUT)
	       (SEND TERMINAL-IO :SELECT)
	       (MULTIPLE-VALUE-PROG1
		 (FUNCALL CONTINUATION)
		 (WHEN WAIT-FOR-SPACE-P
		   (FORMAT TERMINAL-IO "~&Type a space to erase this display:")
		   (LET ((CHAR (SEND TERMINAL-IO :ANY-TYI)))
		     (UNLESS (CL:EQUALP CHAR #\SPACE)	;Foo upon all this
		       (SEND TERMINAL-IO :UNTYI CHAR))))))
      (DELAYING-SCREEN-MANAGEMENT
	(SEND TERMINAL-IO :DEEXPOSE)
	(WHEN (AND CURRENT-WINDOW (SHEET-ME-OR-MY-KID-P (SHEET-SELECTED-WINDOW WINDOW)
							TERMINAL-IO))
	  (SEND CURRENT-WINDOW :SELECT NIL))))))

;;;Maybe this should go somewhere else
(DEFMACRO DOPLIST ((PLIST PROP IND) &BODY BODY)
  `(DO ((PLIST ,PLIST (CDDR PLIST))
	(,PROP)
	(,IND))
       ((NULL PLIST))
     (SETQ ,IND (CAR PLIST)
	   ,PROP (CADR PLIST))
     . ,BODY))

;;; There are certain kinds of windows that are associated with screens.  These include
;;; the system menu, and associated windows.  This a facility for defining those
;;; kinds of windows, and allocating them automatically.

;;; Features flushed from the old thing:
;;;  Having only one of them per screen
;;;  Waiting for that one to become available
;;; As far as I can tell these were not being consciously used.

;;; Options to DEFWINDOW-RESOURCE
;;; :INITIAL-COPIES  (defaults to 1 rather than 0, but only makes one for the default screen)
;;; :CONSTRUCTOR (form that sees TV:SUPERIOR as an argument, or function as with DEFRESOURCE.)
;;; :MAKE-WINDOW (list of flavor name followed by keywords and forms for make-window)
;;; :REUSABLE-WHEN (one of :DEEXPOSED or :DEACTIVATED).  The default is to be
;;;    reusable when nobody is using it and it is not locked.
;;; :SUPERIOR form (defaults to MOUSE-SHEET) specifies the default superior window.
;;;	This can also be specified in the :MAKE-WINDOW options.
;;; If parameters are specified, they are additional parameters that come before
;;; the superior.  The superior is always the last parameter, is optional,
;;; and defaults to the default superior.
;;;
;;; Keywords that defresource is known to handle and defwindow-resource is known
;;; not to want to handle are passed through to defresource.

(DEFCONST *DEFWINDOW-RESOURCE-KEYWORDS* '(:INITIAL-COPIES :CONSTRUCTOR   :MAKE-WINDOW
					  :WINDOW-CREATE  :REUSABLE-WHEN :SUPERIOR)
  "Keywords accepted by defwindow-resource.")

(DEFCONST *DEFRESOURCE-KEYWORDS-HANDLED-INTERNALLY-BY-DEFWINDOW-RESOURCE*
	  '(:CHECKER :INITIAL-COPIES)
  "Defwindow-resource should not pass these through, since it wants to handle them internally.")

(DEFMACRO DEFWINDOW-RESOURCE (NAME PARAMETERS &REST OPTIONS
			      &AUX (CONSTRUCTOR NIL)
				   (INITIAL-COPIES NIL)
				   (CHECKER 'CHECK-UNLOCKED-WINDOW-RESOURCE)
				   (DEFAULT-SUPERIOR `(MOUSE-DEFAULT-SUPERIOR))
				   (EXTRA-OPTIONS-HANDLED-BY-DEFRESOURCE NIL)
				   (INITIAL-COPIES-P NIL))
  (LOOP FOR (KEYWORD VALUE) ON OPTIONS BY 'CDDR
	DO (SELECTQ KEYWORD
	     (:INITIAL-COPIES (SETQ INITIAL-COPIES VALUE
				    INITIAL-COPIES-P T))
	     (:CONSTRUCTOR (SETQ CONSTRUCTOR VALUE))
	     ((:MAKE-WINDOW :WINDOW-CREATE)	;:WINDOW-CREATE obsolete old name
	      (SETQ CONSTRUCTOR
		    `(MAKE-WINDOW ',(CAR VALUE)
				  ':SUPERIOR SUPERIOR
				  ,@(LOOP FOR (KEYWORD VALUE) ON (CDR VALUE) BY 'CDDR
					  WHEN (EQ KEYWORD ':SUPERIOR)
					    DO (SETQ DEFAULT-SUPERIOR VALUE)
					  ELSE COLLECT `',KEYWORD
					       AND COLLECT VALUE))))
	     (:REUSABLE-WHEN
	      (SETQ CHECKER (SELECTQ VALUE
			      (:DEEXPOSED 'CHECK-DEEXPOSED-WINDOW-RESOURCE)
			      (:DEACTIVATED 'CHECK-DEACTIVATED-WINDOW-RESOURCE)
			      (OTHERWISE (FERROR "~S ~S - only :DEEXPOSED and ~
						       :DEACTIVATED are allowed"
						 KEYWORD VALUE)))))
	     (:SUPERIOR (SETQ DEFAULT-SUPERIOR VALUE))	     
	     (OTHERWISE
	      ;; defwindow-resource doesn't know what to do; consult defresource
	      (COND ((AND (MEMQ KEYWORD SI:*DEFRESOURCE-KEYWORDS*)
			  (NOT (MEMQ KEYWORD *DEFRESOURCE-KEYWORDS-HANDLED-INTERNALLY-BY-DEFWINDOW-RESOURCE*)))
		     ;; defresource will handle it (and it's not something
		     ;; to be handled internally)
		     (PUSH VALUE   EXTRA-OPTIONS-HANDLED-BY-DEFRESOURCE)
		     (PUSH KEYWORD EXTRA-OPTIONS-HANDLED-BY-DEFRESOURCE))
		    (T
		     ;; not handled by defresource either.  complain
		     (FERROR "~S invalid DEFWINDOW-RESOURCE or DEFRESOURCE option" KEYWORD))))))
  (OR CONSTRUCTOR (FERROR "DEFWINDOW-RESOURCE requires either the :CONSTRUCTOR or~@
				the :MAKE-WINDOW option."))
  (LT:WITH-LAMBDA-LIST-DESTRUCTURED (PARAMETERS :REQUIRED R
						 :OPTIONAL O
						 :REST REST
						 :KEY KEY
						 :ALLOW-OTHER-KEYS AOK)
    (SETQ PARAMETERS
	  `(,@R &OPTIONAL ,@O (SUPERIOR ,DEFAULT-SUPERIOR)
	    ,@(AND REST `(&REST ,REST))
	    ,@(AND KEY `(&KEY ,@KEY))
	    ,@(AND AOK `(&ALLOW-OTHER-KEYS))))
    `(DEFRESOURCE ,NAME ,PARAMETERS
       :INITIAL-COPIES ,(IF INITIAL-COPIES-P INITIAL-COPIES `(IF MAIN-SCREEN 1 0))
       :CONSTRUCTOR ,CONSTRUCTOR
       :CHECKER ,CHECKER
       ,@EXTRA-OPTIONS-HANDLED-BY-DEFRESOURCE)))

(DEFUN CHECK-UNLOCKED-WINDOW-RESOURCE (IGNORE WINDOW IN-USE-P &REST IGNORE)
  (AND (NOT IN-USE-P)
       (ZEROP (SHEET-DEAD WINDOW))
       (SHEET-CAN-GET-LOCK WINDOW)))

(DEFUN CHECK-DEEXPOSED-WINDOW-RESOURCE (IGNORE WINDOW IGNORE &REST IGNORE)
  (AND (NOT (SHEET-EXPOSED-P WINDOW))
       (ZEROP (SHEET-DEAD WINDOW))
       (SHEET-CAN-GET-LOCK WINDOW)))

(DEFUN CHECK-DEACTIVATED-WINDOW-RESOURCE (IGNORE WINDOW IGNORE &REST IGNORE)
  (AND (NOT (MEMQ WINDOW (SHEET-INFERIORS (SHEET-SUPERIOR WINDOW))))
       (ZEROP (SHEET-DEAD WINDOW))
       (SHEET-CAN-GET-LOCK WINDOW)))


;;; Definitions for screen management
(DEFMACRO RECT-SOURCE (R) `(FIRST ,R))
(DEFMACRO RECT-LEFT (R) `(SECOND ,R))
(DEFMACRO RECT-TOP (R) `(THIRD ,R))
(DEFMACRO RECT-RIGHT (R) `(FOURTH ,R))
(DEFMACRO RECT-BOTTOM (R) `(FIFTH ,R))
(DEFMACRO RECT-WITHIN-RECT-P (R1 R2)
  "R1 within R2"
  `(AND ( (RECT-LEFT ,R1) (RECT-LEFT ,R2))
	( (RECT-RIGHT ,R1) (RECT-RIGHT ,R2))
	( (RECT-TOP ,R1) (RECT-TOP ,R2))
	( (RECT-BOTTOM ,R1) (RECT-BOTTOM ,R2))))

(DEFMACRO RECT-NOT-OVERLAP-RECT-P (R1 R2)
  `(OR ( (RECT-RIGHT ,R2) (RECT-LEFT ,R1))
       ( (RECT-RIGHT ,R1) (RECT-LEFT ,R2))
       ( (RECT-BOTTOM ,R2) (RECT-TOP ,R1))
       ( (RECT-BOTTOM ,R1) (RECT-TOP ,R2))))

(DEFVAR SCREEN-MANAGER-QUEUE NIL)
(DEFVAR SCREEN-MANAGER-TOP-LEVEL T)
(DEFVAR *AUTOMATICALLY-CHANGE-SCREENS* T "On multi-console systems, switch screens.")


(DEFMACRO DELAYING-SCREEN-MANAGEMENT (&BODY BODY)
  "Collect any screen manages that get queued during its body,
and force them to happen at the later.  This code is unwind-
protected so that all pending manages get done, as they are
necessary to have the screen look correct.  The code tries to
remove duplicate screen manages when it finally does them, and
after it finishes all the managing does an autoexpose on all
superiors that it hacked."
  `(LET ((.QUEUE-LEFT. T))
     (UNWIND-PROTECT
       (LET-IF SCREEN-MANAGER-TOP-LEVEL ((SCREEN-MANAGER-QUEUE NIL))
	       (UNWIND-PROTECT
		 (LET ((INHIBIT-SCREEN-MANAGEMENT T)
		       (SCREEN-MANAGER-TOP-LEVEL NIL))
		   (PROGN . ,BODY))
		 (SCREEN-MANAGE-DELAYING-SCREEN-MANAGEMENT-INTERNAL)
		 (SETQ .QUEUE-LEFT. SCREEN-MANAGER-QUEUE)))
       (AND (NEQ .QUEUE-LEFT. T)
	    SCREEN-MANAGER-TOP-LEVEL
	    (DOLIST (E .QUEUE-LEFT.)
	      (LEXPR-FUNCALL #'SCREEN-MANAGE-QUEUE (FIRST (FIRST E)) (CDR E)))))))

(DEFMACRO WITHOUT-SCREEN-MANAGEMENT (&BODY BODY)
  "This causes any screen manages that get queued during its
body to get flushed if the body exits normally.  Abnormal exit
will cause the screen manages to remain on the queue so that they
do get done.  This is useful in circumstances when you know
you'll be doing screen management on the same stuff right away."
  `(LET ((.FLAG. NIL))
     (UNWIND-PROTECT
       (LET ((SCREEN-MANAGER-QUEUE NIL)
	     (SCREEN-MANAGER-TOP-LEVEL NIL))
	 (UNWIND-PROTECT
	   (LET ((INHIBIT-SCREEN-MANAGEMENT T))
	     (PROG1 ,@BODY
		    ;; Body completed successfully, flush any screen manages that got queued
		    (SETQ SCREEN-MANAGER-QUEUE NIL)))
	   (SETQ .FLAG. SCREEN-MANAGER-QUEUE)))
       (DOLIST (E .FLAG.)
	 ;; Requeue entries
	 (LEXPR-FUNCALL #'SCREEN-MANAGE-QUEUE (FIRST (FIRST E)) (CDR E))))))

;;; Macros to help out the squeaking furry things
;;; Stop handling (but continue tracking) the mouse.  Things that use this must set the mouse
;;; blinker right away, by (MOUSE-STANDARD-BLINKER) or otherwise.
(DEFMACRO WITH-MOUSE-GRABBED (&BODY BODY)
  `(WITH-THIS-MOUSE-GRABBED () . ,BODY))

(DEFMACRO WITH-THIS-MOUSE-GRABBED ((&OPTIONAL MOUSE) &BODY BODY)
  `(WITH-THIS-MOUSE-GRABBED-INTERNAL (NAMED-LAMBDA WITH-THIS-MOUSE-GRABBED () . ,BODY)
				     ,MOUSE))

;;; Same as above, and furthermore, restrict the mouse to the argument sheet, and
;;; make MOUSE-X and MOUSE-Y relative to that sheet.  Usually what you want.
(DEFMACRO WITH-MOUSE-GRABBED-ON-SHEET ((&OPTIONAL (SHEET 'SELF)) &BODY BODY)
  `(WITH-THIS-MOUSE-GRABBED-INTERNAL (NAMED-LAMBDA WITH-MOUSE-GRABBED-ON-SHEET () . ,BODY)
				     NIL T :ON-SHEET ,SHEET))

;;; Version of WITH-MOUSE-GRABBED that also grabs the buttons.  You can call
;;; the MOUSE-BUTTONS function to find out the current state of the buttons.
;;; This is better than looking at the MOUSE-LAST-BUTTONS variable because
;;; you won't miss a click.
(DEFMACRO WITH-MOUSE-AND-BUTTONS-GRABBED (&BODY BODY)
  `(WITH-THIS-MOUSE-AND-BUTTONS-GRABBED () . ,BODY))

(DEFMACRO WITH-THIS-MOUSE-AND-BUTTONS-GRABBED ((&OPTIONAL MOUSE) &BODY BODY)
  `(WITH-THIS-MOUSE-GRABBED-INTERNAL (NAMED-LAMBDA WITH-THIS-MOUSE-AND-BUTTONS-GRABBED ()
				       . ,BODY)
				     ,MOUSE T :BUTTONS-TOO T))

(DEFMACRO WITH-MOUSE-AND-BUTTONS-GRABBED-ON-SHEET ((&OPTIONAL (SHEET 'SELF)) &BODY BODY)
  `(WITH-THIS-MOUSE-GRABBED-INTERNAL
     (NAMED-LAMBDA WITH-MOUSE-AND-BUTTONS-GRABBED-ON-SHEET ()
       . ,BODY)
     NIL T :ON-SHEET ,SHEET :BUTTONS-TOO T))

;;; Stop handling and tracking of the mouse completely
(DEFMACRO WITH-MOUSE-USURPED (&BODY BODY)
  `(WITH-THIS-MOUSE-USURPED () . ,BODY))

(DEFMACRO WITH-THIS-MOUSE-USURPED ((&OPTIONAL MOUSE) &BODY BODY)
  `(WITH-THIS-MOUSE-GRABBED-INTERNAL (NAMED-LAMBDA WITH-THIS-MOUSE-USURPED () . ,BODY)
				     ,MOUSE 'STOP))

(DEFMACRO DELAYING-MOUSE-WAKEUPS (&BODY BODY)
  `(LET ((.OLD-MOUSE-WAKEUP. MOUSE-WAKEUP))     
     (MULTIPLE-VALUE-PROG1
       (LET ((MOUSE-WAKEUP MOUSE-WAKEUP))
	 (MULTIPLE-VALUE-PROG1 (PROGN ,@BODY)
			       (SETQ .OLD-MOUSE-WAKEUP. MOUSE-WAKEUP)))
       (WHEN .OLD-MOUSE-WAKEUP. (SETQ MOUSE-WAKEUP T)))))

(DEFMACRO LET-SPECIAL (VARLIST &BODY BODY)  
  `(LET ,VARLIST 
     (DECLARE (SPECIAL ,@(MAPCAR #'(LAMBDA (X) (IF (SYMBOLP X) X (CAR X))) VARLIST)))
     ,@BODY))

(COMPILER:MAKE-OBSOLETE WITH-CURRENT-STYLE "it has been subsumed by with-character-style.")

(DEFMACRO WITH-CURRENT-STYLE ((STREAM STYLE &KEY BIND-LINE-HEIGHT) &BODY BODY)
  `(SEND ,STREAM :WITH-CURRENT-STYLE ,STYLE #'(NAMED-LAMBDA WITH-CURRENT-STYLE (XSTREAM)
					      (DECLARE (SYS:DOWNWARD-FUNCTION))
					      ,@BODY)
	 ,BIND-LINE-HEIGHT))

(DEFMACRO WITH-SHEET-CLIPPING-REGION ((LEFT TOP RIGHT BOTTOM) &BODY BODY)
  `(WITH-SHEET-CLIPPING-REGION-INTERNAL #'(NAMED-LAMBDA WITH-SHEET-CLIPPING-REGION () ,@BODY)
					,LEFT ,TOP ,RIGHT ,BOTTOM))

(DEFMACRO WITH-MARGIN-OUTPUT ((SHEET) &BODY BODY)
  `(WITH-MARGIN-OUTPUT-INTERNAL ,SHEET
     (NAMED-LAMBDA WITH-MARGIN-OUTPUT () ,@BODY)))

(DEFMACRO WITH-CURRENT-BASELINE ((SHEET NEW-CURRENT-BASELINE) &BODY BODY)
  `(WITH-CURRENT-BASELINE-INTERNAL ,SHEET ,NEW-CURRENT-BASELINE
    (NAMED-LAMBDA WITH-CURRENT-BASELINE () ,@BODY)))


#||
(DEFVAR KBD-LAST-ACTIVITY-TIME 0)		;Time user last typed a key or clicked mouse
||#

(DEFCONSTANT ALU-SETZ 0)			;Magic BOOLE numbers
(DEFCONSTANT ALU-AND 1)
(DEFCONSTANT ALU-ANDCA 2)
(DEFCONSTANT ALU-SETA 5)
(DEFCONSTANT ALU-XOR 6)
(DEFCONSTANT ALU-IOR 7)
(DEFCONSTANT ALU-SETO 17)


;;; Drawing

;;; Macros for standard things

;;
;; This macro takes into account the extended alus. It's used by 
;; draw-circle and raw-circular-arg
;;
(DEFMACRO SHEET-DRAW-CACHED (ALU (OPERATION &BODY REST))
  `(,(IF (NUMBERP ALU)
	 OPERATION
	 (INTERN (STRING-APPEND "SHEET-" (SUBSTRING (STRING OPERATION) 1)) "TV"))
    ,@REST))

(DEFMACRO SHEET-POINT (X Y &OPTIONAL (SHEET 'SELF))
  `(SEND ,(IF (EQ SHEET 'SELF) `SCREEN `(SHEET-SCREEN ,SHEET)) :%POINT
	 ,X ,Y ,SHEET))

(DEFMACRO SHEET-READ-1-BIT-RASTER (W H FROM-RASTER FROM-X FROM-Y TO-RASTER TO-X TO-Y
				   &OPTIONAL (SHEET 'SELF) READ-PIXEL-FUNCTION)
  `(SEND ,(IF (EQ SHEET 'SELF) 'SCREEN `(SHEET-SCREEN ,SHEET)) :%READ-1-BIT-RASTER
	 ,W ,H ,FROM-RASTER ,FROM-X ,FROM-Y ,TO-RASTER ,TO-X ,TO-Y ,SHEET
	 ,@(AND READ-PIXEL-FUNCTION `(,READ-PIXEL-FUNCTION))))

(DEFMACRO SHEET-DRAW-POINT (X Y ALU &OPTIONAL (SHEET 'SELF) (VALUE -1))
  `(SEND ,(IF (EQ SHEET 'SELF) `SCREEN `(SHEET-SCREEN ,SHEET)) :%DRAW-POINT
	 ,X ,Y ,ALU ,SHEET ,VALUE))

(DEFMACRO SHEET-DRAW-RECTANGLE (W H X Y ALU &OPTIONAL (SHEET 'SELF) ARRAY)
  `(SEND ,(IF (EQ SHEET 'SELF) `SCREEN `(SHEET-SCREEN ,SHEET)) :%DRAW-RECTANGLE
	 ,W ,H ,X ,Y ,ALU ,SHEET ,@(WHEN ARRAY `(,ARRAY))))

(DEFMACRO SHEET-DRAW-LINE (X1 Y1 X2 Y2 ALU DRAW-END-POINT &OPTIONAL (SHEET 'SELF))
  `(SEND ,(IF (EQ SHEET 'SELF) `SCREEN `(SHEET-SCREEN ,SHEET)) :%DRAW-LINE
	 ,X1 ,Y1 ,X2 ,Y2 ,ALU ,DRAW-END-POINT ,SHEET))

(DEFMACRO SHEET-DRAW-TRIANGLE (X1 Y1 X2 Y2 X3 Y3 ALU &OPTIONAL (SHEET 'SELF)
			       (XMIN 0) (YMIN 0) XMAX YMAX)
  `(SEND ,(IF (EQ SHEET 'SELF) `SCREEN `(SHEET-SCREEN ,SHEET)) :%DRAW-TRIANGLE
	 ,X1 ,Y1 ,X2 ,Y2 ,X3 ,Y3 ,ALU ,SHEET ,XMIN ,YMIN ,XMAX ,YMAX))

(DEFMACRO SHEET-BITBLT (ALU W H FROM-RASTER FROM-X FROM-Y TO-RASTER TO-X TO-Y
			&OPTIONAL (SHEET 'SELF))
  `(SEND ,(IF (EQ SHEET 'SELF) 'SCREEN `(SHEET-SCREEN ,SHEET)) :%BITBLT
	 ,ALU ,W ,H ,FROM-RASTER ,FROM-X ,FROM-Y ,TO-RASTER ,TO-X ,TO-Y ,SHEET))

(DEFMACRO SHEET-DRAW-1-BIT-RASTER (W H FROM-RASTER FROM-X FROM-Y TO-RASTER TO-X TO-Y
				   ONES-ALU ZEROS-ALU &OPTIONAL (SHEET 'SELF))
  `(SEND ,(IF (EQ SHEET 'SELF) 'SCREEN `(SHEET-SCREEN ,SHEET)) :%DRAW-1-BIT-RASTER
	 ,W ,H ,FROM-RASTER ,FROM-X ,FROM-Y ,TO-RASTER ,TO-X ,TO-Y
	 ,ONES-ALU ,ZEROS-ALU ,SHEET))

(DEFMACRO SHEET-DRAW-CHAR (CHAR X Y ALU &OPTIONAL (SHEET 'SELF))
  `(SEND ,(IF (EQ SHEET 'SELF) `SCREEN `(SHEET-SCREEN ,SHEET)) :%DRAW-CHAR
	 ,CHAR ,X ,Y ,ALU ,SHEET))

(DEFMACRO SHEET-DRAW-GLYPH (CHAR FONT X Y ALU &OPTIONAL (SHEET 'SELF) DRAWABLE)
  `(SEND ,(IF (EQ SHEET 'SELF) `SCREEN `(SHEET-SCREEN ,SHEET)) :%DRAW-GLYPH
	 ,CHAR ,FONT ,X ,Y ,ALU ,SHEET
	 ,@(AND DRAWABLE `(,DRAWABLE))))

;;; NOTE: The FONT argument supplied here must be consistent with the
;;;       font for the first character of the string, since this 
;;;       routine hasn't the necessary context to detect an inconsistency.
(DEFMACRO SHEET-DRAW-STRING (SHEET ALU X Y STRING FONT INDEX LIMIT XLIM)
  `(SEND ,(IF (EQ SHEET 'SELF) 'SCREEN `(SHEET-SCREEN ,SHEET)) :%DRAW-STRING
	 ,SHEET ,ALU ,X ,Y ,STRING ,FONT ,INDEX ,LIMIT ,XLIM))

;;; Optimized point plotting goes here!  --HIC



(DEFFLAVOR BASIC-SCREEN
	   ((DEFAULT-STYLE *DEFAULT-STYLE*)
	    (PROPERTY-LIST NIL)
	    (X-OFFSET 0)
	    (Y-OFFSET 0)
	    (MOUSE-X-OFFSET 0)
	    (MOUSE-Y-OFFSET 0)
	    (ADJUST-MOUSE-OFFSETS NIL)
	    (LEVEL-COUNT 0)
	    (MOUSE-BLINKERS NIL)
	    (MENU-DEFAULT-CHARACTER-STYLE *MENU-DEFAULT-CHARACTER-STYLE*)
	    (MENU-SELECTED-CHARACTER-STYLE *MENU-SELECTED-CHARACTER-STYLE*)
	    (WHO-SCREEN NIL)
	    SAVED-PREVIOUSLY-SELECTED-WINDOWS
	    (LAST-BLINKER-TIME 0)
	    (BLINKER-TIMER NIL)
	    (BLINKER-PROCESS NIL)
	    (SCREEN-LOCK (PROCESS:MAKE-LOCK "Screen Controller Lock" :RECURSIVE T))
	    (RESOURCE-TICK 0)
	    )
	   (SHEET)
  :ABSTRACT-FLAVOR
  (:CONC-NAME "SCREEN-")
  (:INITABLE-INSTANCE-VARIABLES PROPERTY-LIST ADJUST-MOUSE-OFFSETS)
  (:READABLE-INSTANCE-VARIABLES MOUSE-BLINKERS (SCREEN-LOCK SCREEN-LOCK) ADJUST-MOUSE-OFFSETS)
  (:WRITABLE-INSTANCE-VARIABLES PROPERTY-LIST DEFAULT-STYLE 
				(MENU-DEFAULT-CHARACTER-STYLE MENU-DEFAULT-CHARACTER-STYLE)
				(MENU-SELECTED-CHARACTER-STYLE MENU-SELECTED-CHARACTER-STYLE)
				(SCREEN-WHO-LINE-SCREEN WHO-SCREEN)
				(SCREEN-DEFAULT-CHARACTER-STYLE DEFAULT-STYLE)
				RESOURCE-TICK MOUSE-X-OFFSET MOUSE-Y-OFFSET)
  (:LOCATABLE-INSTANCE-VARIABLES PROPERTY-LIST)
  (:SETTABLE-INSTANCE-VARIABLES MOUSE-BLINKERS)
  (:DOCUMENTATION :SPECIAL-PURPOSE "The software data structure for the actual screen
The top of a window hierachy should be of this type.")
  (:INIT-KEYWORDS :WHO-SCREEN :DEFAULT-FONT)	;compatibility only
  (:REQUIRED-METHODS 
   :%BITBLT
   :%DRAW-1-BIT-RASTER
   :%DRAW-CHAR
   :%DRAW-GLYPH
   :%DRAW-LINE
   :%DRAW-POINT
   :%DRAW-RECTANGLE
   :%DRAW-STRING
   :%DRAW-TRIANGLE
   :%POINT
   SCREEN-HAS-REMOTE-BITMAPS
   :%READ-1-BIT-RASTER
   :DEFAULT-INFERIOR-ALUFS
   :EXCHANGE-TWO-COLORS-ALUF
   :WITH-ALU-CACHED
   :WITH-ALU-CACHED-SOURCE
   SCREEN-ALU-PRESENTATION-TYPE
   )
  )

(DEFMETHOD (WITH-SAVED-SCREEN-HARDWARE-STATE-INTERNAL TV:BASIC-SCREEN) (FUN)
  (FUNCALL FUN))

;;;

(DEFFLAVOR SLAVE-SCREEN-MIXIN
	((PARENT-SCREEN NIL)
	 (SCREEN-LOCK NIL))
	()
  (:REQUIRED-FLAVORS BASIC-SCREEN)
  (:REQUIRED-INIT-KEYWORDS :PARENT-SCREEN)
  (:GETTABLE-INSTANCE-VARIABLES PARENT-SCREEN)
  (:INITABLE-INSTANCE-VARIABLES PARENT-SCREEN))

;;;

(DEFFLAVOR GENERIC-WHO-LINE-SCREEN-MIXIN
	(WHO-LINE-TEMPLATE
	 (WHO-LINE-FIELDS NIL)
	 (FORCE-PROCESS NIL)
	 (LAST-PROCESS NIL)
	 UPDATE-PROCESS
	 UPDATE-TIMER
	 MOUSE-DOCUMENTATION-UPDATE-TIMER
	 (UPDATE-NEEDED NIL)
	 (RUN-STATE-UPDATE-NEEDED NIL)
	 (MOUSE-DOCUMENTATION-UPDATE-NEEDED NIL)
	 (LAST-MOUSE-DOCUMENTATION-UPDATE-TIME 0)
	 )
	(NO-CHANGE-OF-DEFAULT-FONT-MIXIN SLAVE-SCREEN-MIXIN)
  (:FUNCTIONS WHO-LINE-SCREEN-UPDATE-TOP-LEVEL WHO-LINE-SCREEN-UPDATE-PREDICATE)
  (:CONC-NAME WHO-LINE-SCREEN-)
  (:REQUIRED-FLAVORS BASIC-SCREEN)
  (:INITABLE-INSTANCE-VARIABLES WHO-LINE-TEMPLATE)
  (:READABLE-INSTANCE-VARIABLES UPDATE-PROCESS)
  (:WRITABLE-INSTANCE-VARIABLES WHO-LINE-TEMPLATE WHO-LINE-FIELDS))

(DEFMETHOD (SCREEN-HAS-BLINKER-TIMER-P GENERIC-WHO-LINE-SCREEN-MIXIN) () NIL)


#|
Raster Streams.

The procol requires three methods, TV:WITH-BIT-ARRAY TV:WITH-BIT-ARRAY-STREAM
and TV:WITH-BIT-ARRAY-OR-STREAM.  Most flavors will actually implement only one of these 
three, and implement the other two in terms of that one.  For conventience the functions
WITH-BIT-ARRAY-AS-STREAM and WITH-STREAM-AS-BIT-ARRAY are provided.

All five of these functions accept the same arguments, although not all are meaningful
to all of them.

The mandatory arguments are :DIRECTION and CONTINUATION

 :DIRECTION is :INPUT :OUTPUT or :BOTH
 CONTINUATION is a function which is called with three arguments
    (1) an array,  (2) linearized index, (3) spanning distance
or  (1) an array,  (2) NIL               (3) continuation strobe

   ARRAY will always be raster arrays suitable for BITBLT

   LINEARIZED INDEX is an index appropriate for %1D-AREF into array which 
   points to the start of the current line being processed.

   CONTINUATION STROBE is a function of zero arguments which when called,
   return the next linerarized index in ARRAY to use.  The function must
   be called before the first input or output to get the initial index,
   and must be called after the last output to output the last line.  When
   the line count has expired, the strobe returns :END rather than an index
   that is out of bounds.

 Keywords as follows are accepted and acted upon by all implementations of the
 protocol:
 (x-offset 0)      		;x-offset of the rectangle to be processed
 (y-offset 0)     		;y-offset of the rectangle to be processed
 (width (send self :width)) 	;width of the rectangle to be processed
 (height (send self :height))	;height of the rectangle to be processed
 (minimum-rows 1)		;at least this number of rows (including the current one)
				;remain valid at all times.  This is to facilitate
				;algorithms that process several lines of data at a time
 (stream-width width)
 (stream-height height)
				;for streams which do physical IO, stream-width and 
				;stream-height are the size of the raster actually
				;input or output.  The continuation sees only the
				;rectangle defined by x-offset,y-offset, width, height
				;the additional data (if any) is passed over automatically
 (stream-fill-value 0)		;stream-fill-value is used to pad output not when data
				;not read or generated by the continuation is output
 from-field nil			;used by "field" images.  Valid range is NIL 0 1
 to-field nil			;effectively doubles spanning distance and halves the height
				;if fields are being used, HEIGHT should still be specified
				;as the whole height, y-offset should still be in lines
 temporary-raster		;temporary raster MAY be supplied and if so MUST
				;be suitable!
|#

(DEFGENERIC WITH-BIT-ARRAY-OR-STREAM (SELF DIRECTION CONTINUATION &REST ARGS)

  (:COMPATIBLE-MESSAGE :WITH-BIT-ARRAY-OR-STREAM)
  (:FUNCTION
    (DECLARE (ARGLIST (SELF DIRECTION CONTINUATION
		  &KEY
		  (X-OFFSET 0)
		  (Y-OFFSET 0)
		  (WIDTH (SEND SELF :WIDTH))
		  (HEIGHT (SEND SELF :HEIGHT))
		  (MINIMUM-ROWS 1)
		  (STREAM-WIDTH WIDTH)
		  (STREAM-HEIGHT HEIGHT)
		  (FROM-FIELD)
		  (TO-FIELD)
		  TEMPORARY-RASTER
		  &ALLOW-OTHER-KEYS)))
    (COND ((ARRAYP SELF)
	   (LET ((SCR (RASTER-SCREEN SELF)))
	     (IF SCR
		 (CL:APPLY #'%WITH-BIT-ARRAY SCR SELF DIRECTION CONTINUATION ARGS)
		 (CL:APPLY #'BIT-ARRAY-AS-BIT-ARRAY SELF DIRECTION CONTINUATION ARGS))))
	  (T
	   (LEXPR-SEND SELF :WITH-BIT-ARRAY-OR-STREAM DIRECTION CONTINUATION ARGS))))
  )


;
; :DIRECTION is :INPUT :OUTPUT or :BOTH
; CONTINUATION is a function which is called with three arguments
;    (1) an array,  (2) NIL               (3) continuation strobe
;
(DEFGENERIC WITH-BIT-ARRAY-STREAM (SELF DIRECTION CONTINUATION &REST ARGS)
  (:COMPATIBLE-MESSAGE :WITH-BIT-ARRAY-STREAM)
  (:FUNCTION
    (DECLARE (ARGLIST (SELF DIRECTION CONTINUATION
		  &KEY
		  (X-OFFSET 0)
		  (Y-OFFSET 0)
		  (WIDTH (SEND SELF :WIDTH))
		  (HEIGHT (SEND SELF :HEIGHT))
		  (MINIMUM-ROWS 1)
		  (WRITE-MASK -1)
		  (STREAM-WIDTH WIDTH)
		  (STREAM-HEIGHT HEIGHT)
		  FROM-FIELD
		  TO-FIELD
		  TEMPORARY-RASTER
		  &ALLOW-OTHER-KEYS)))
    (COND ((ARRAYP SELF)
	   (LET ((SCR (RASTER-SCREEN SELF)))
	     (IF SCR
		 (CL:APPLY #'%WITH-BIT-ARRAY-STREAM SCR SELF DIRECTION CONTINUATION ARGS)
		 (CL:APPLY #'BIT-ARRAY-AS-BIT-ARRAY-STREAM SELF DIRECTION CONTINUATION ARGS))))
	  (T
	   (LEXPR-SEND SELF :WITH-BIT-ARRAY-STREAM
		       DIRECTION CONTINUATION ARGS))))
  )
;
; :DIRECTION is :INPUT :OUTPUT or :BOTH
; CONTINUATION is a function which is called with three arguments
;    (1) an array,  (2) linearized index, (3) spanning distance
;
(DEFGENERIC WITH-BIT-ARRAY (SELF DIRECTION CONTINUATION &REST ARGS)
  (:COMPATIBLE-MESSAGE :WITH-BIT-ARRAY)
  (:FUNCTION
    (DECLARE (ARGLIST (SELF DIRECTION CONTINUATION
		  &KEY
		  (X-OFFSET 0)
		  (Y-OFFSET 0)
		  (WIDTH (SEND SELF :WIDTH))
		  (HEIGHT (SEND SELF :HEIGHT))
		  (MINIMUM-ROWS 1)
		  FROM-FIELD
		  TO-FIELD
		  TEMPORARY-RASTER
		  &ALLOW-OTHER-KEYS)))
    (COND ((ARRAYP SELF)
	   (LET ((SCR (RASTER-SCREEN SELF)))
	     (IF SCR
		 (CL:APPLY #'%WITH-BIT-ARRAY SCR SELF DIRECTION CONTINUATION ARGS)
		 (CL:APPLY #'BIT-ARRAY-AS-BIT-ARRAY SELF DIRECTION CONTINUATION ARGS))))
	  (T
	   (LEXPR-SEND SELF :WITH-BIT-ARRAY DIRECTION CONTINUATION ARGS))))
  )
