;;; -*- Mode: LISP; Package: TV; Base: 8 -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; The screen manager, an unseen entity that many have cursed and
;;; many have praised, is herewithin presented for all to see.

;;; Priorities:
;;; Each sheet has a priority (which is basically how hard it tries to be on the screen).
;;; The priorities are used for ordering the list of inferiors of a sheet, and therefore
;;; affect what windows the mouse sees, how the screen manager works, and how the automatic
;;; exposing decides what to expose.  If the priority is null, then it is considered
;;; to have a priority smaller than that of any with explicit priorities (this includes
;;; negative priorities, but that doesn't really matter).  Positive priorities mean an
;;; absolute priority as compared to all other sheets with a numerical priority -- namely,
;;; the larger the number, the more important the sheet is considered to be.  A negative
;;; priority indicates that the sheet is to be considered "inactive" by various routines
;;; when it is not exposed.  -1 means only be considered inactive by the screen manager,
;;; and -2 or less means don't even be a candidate for auto-exposure.  Exposed sheets
;;; are always uncovered, and therefore are guaranteed to have the largest priority
;;; (virtually, and since they don't overlap, all exposed sheets are considered the same).

;;; Notes: A set of rectangles is a list of rectangles.  All functions that
;;; operate on sets expect them in the canonical form (a list of rectangles
;;; that don't mutually overlap).  All user-level functions that return sets
;;; canonicalize them first.

;;; A rectangle is a four-list of (SOURCE LEFT TOP RIGHT BOTTOM)
;;; SOURCE where the rectangle came from.  Rectangles cannot have
;;; their LEFT, TOP, RIGHT, or BOTTOM destructively altered.

(DEFUN CANONICALIZE-RECTANGLE-SET (S)
  "Given a set of rectangles, returns a set in canonical form (that have no overlaps)."
  (DO ((NEW NIL NIL))
      (NIL)
;;; It's not clear whether the sorting helps at all
;    (SETQ S
;	  (SORT S #'(LAMBDA (X Y)
;		      (NOT (< (* (- (RECT-RIGHT X) (RECT-LEFT X))
;				 (- (RECT-BOTTOM X) (RECT-TOP X)))
;			      (* (- (RECT-RIGHT Y) (RECT-LEFT Y))
;				 (- (RECT-BOTTOM Y) (RECT-TOP Y))))))))
    (DO ((R (CAR S) (CAR L))
	 (L (CDR S) (CDR L))
	 (S-TEM))
	((NULL L))
      (DOLIST (RA L)
	(COND ((RECT-NOT-OVERLAP-RECT-P R RA)
	       ;; No overlap, ok
	       )
	      ((RECT-WITHIN-RECT-P R RA)
	       ;; R completely within RA, throw R away
	       (SETQ S (DELQ R S))
	       (RETURN NIL))
	      ((RECT-WITHIN-RECT-P RA R)
	       ;; RA completely within R, throw RA away
	       (SETQ S (DELQ RA S))
	       (RETURN NIL))
	      (T
		(SETQ S-TEM
		      ;; Get all sections of RA not inside of R
		      (RECTANGLE-NOT-INTERSECTION R RA))
		(OR S-TEM
		    ;; No result can't happen if above checks don't succeed
		    (FERROR NIL "Null not-intersection impossible: ~S ~S" R RA))
		(DOLIST (RB S-TEM)
		  (AND (RECT-WITHIN-RECT-P RB R)
		       (SETQ S-TEM (DELQ RB S-TEM))))
		(SETQ NEW (NCONC S-TEM NEW)
		      S (DELQ RA S))))))
    ;; When no new rectangles generated, return the old list
    (OR NEW (RETURN S))
    (SETQ S (NCONC NEW S))))

(DEFUN RECTANGLE-NOT-INTERSECTION (RPRIME RAUX &AUX SET)
  "Return a set of rectangles which consists of all the area in RAUX that
is not also in RPRIME.  The set is garunteed to be canonical."
  (COND ((RECT-NOT-OVERLAP-RECT-P RPRIME RAUX)
	 ;; No intersection at all, just return RAUX
	 (NCONS RAUX))
	((RECT-WITHIN-RECT-P RAUX RPRIME)
	 ;; No area that isn't in RPRIME
	 NIL)
	(T
	 (AND (< (RECT-TOP RAUX) (RECT-TOP RPRIME))
	      (PUSH (LIST (RECT-SOURCE RAUX)
			  (RECT-LEFT RAUX) (RECT-TOP RAUX)
			  (RECT-RIGHT RAUX) (RECT-TOP RPRIME))
		    SET))
	 (AND (> (RECT-BOTTOM RAUX) (RECT-BOTTOM RPRIME))
	      (PUSH (LIST (RECT-SOURCE RAUX)
			  (RECT-LEFT RAUX) (RECT-BOTTOM RPRIME)
			  (RECT-RIGHT RAUX) (RECT-BOTTOM RAUX))
		    SET))
	 (AND (< (RECT-LEFT RAUX) (RECT-LEFT RPRIME))
	      (PUSH (LIST (RECT-SOURCE RAUX)
			  (RECT-LEFT RAUX) (MAX (RECT-TOP RPRIME) (RECT-TOP RAUX))
			  (RECT-LEFT RPRIME) (MIN (RECT-BOTTOM RPRIME) (RECT-BOTTOM RAUX)))
		    SET))
	 (AND (> (RECT-RIGHT RAUX) (RECT-RIGHT RPRIME))
	      (PUSH (LIST (RECT-SOURCE RAUX)
			  (RECT-RIGHT RPRIME) (MAX (RECT-TOP RPRIME) (RECT-TOP RAUX))
			  (RECT-RIGHT RAUX) (MIN (RECT-BOTTOM RPRIME) (RECT-BOTTOM RAUX)))
		    SET))
	 SET)))


;; The rasters created by this resource each consist of two parts, a HEADER and a BODY
;; Headers are always indirect arrays, and bodies are always art-1b arrays.
;; 
;; HEADERS are cached in an EQUAL hash table, one header per unique specification
;; to MAKE-ARRAY.  The keys are the make-array specifications and the values are
;; lists of array headers made to spec.
;;
;; BODIES are arrays to hold the actual bits, which are indexed by (log2 size-in-bits)
;; in *ARRAY-BODY-RESOURCE*.  the theory (and the practice!) is that only a few bodies
;; will ever be allocated.
;;
;; At runtime, when an raster is allocated from the resource, an array header from the
;; header resource is matched with a suitable sized body from the body resource.
;;

;; This hash table is hashed on the arguments to MAKE-ARRAY.  
;; The value of a slot is a list of conses of (FREE-P . ARRAY-HEADER)
(DEFVAR *TEMP-SHEET-RASTER-HEADER-RESOURCE* (CL:MAKE-HASH-TABLE :TEST #'CL:EQUAL))

(DEFUN ALLOCATE-TEMP-SHEET-RASTER-AND-HEADER (&REST ARGS)
  (LET ((ATYPE (GET ARGS ':TYPE))
	(INITIAL-VALUE  (GET ARGS ':INITIAL-VALUE))
	(DISPLACED-TO (ALLOCATE-TEMP-SHEET-RASTER-BODY (CAR ARGS) (CDR ARGS)))
	(NO-INITIAL-VALUE (GET ARGS :NO-INITIAL-VALUE))
	ALLOC-RASTER
	SLOT)
    (UNLESS (MEMQ ATYPE '(ART-1B ART-2B ART-4B ART-8B ART-16B ART-FIXNUM))
      (FERROR "Resource arrays must be a FIXNUM type"))
    (LET ((CONT (GET ARGS :DISPLACED-TO)))
      (WHEN (ARRAYP CONT)
	(RPLACA (LOCF (GET ARGS :DISPLACED-TO)) :ARRAY)))
    (WITHOUT-INTERRUPTS
      (MULTIPLE-VALUE (ALLOC-RASTER SLOT)
	(LOOP WITH OLD = (SEND *TEMP-SHEET-RASTER-HEADER-RESOURCE* ':GET-HASH ARGS)
	      FOR I IN OLD DO			;list of (free-p . array-header)
	  (WHEN (CAR I)
	    (SETF (CAR I) NIL)
	    (LET ((RASTER (CDR I)))
	      D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;if the array is displaced conformally, use CHANGE-INDIRECT-ARRAY
0	      1;;to redirect the array, since it is supposed to do it correctly
0	      1;;if the header is 0NOT1 displaced conformally, just set the indirect
0	      1;;pointer.  Don't call CHANGE-INDIRECT-ARRAY because it will treat
0	      1;;the operation as a conformal displacement if the arrays look like
0	      1;;they want it.
0	      (IF (GET ARGS :DISPLACED-CONFORMALLY)
		  (SI:CHANGE-INDIRECT-ARRAY
		    RASTER
		    (ARRAY-TYPE RASTER)
		    (FIRST ARGS)
		    DISPLACED-TO
		    (SI:ARRAY-INDEX-OFFSET RASTER))
		  (SETF (ARRAY-INDIRECT-POINTER RASTER) DISPLACED-TO))
	      (RETURN (VALUES RASTER I))))
	  )))
    (UNLESS ALLOC-RASTER
      (LABELS ((DUMMY-FUNCTION ()
		 ;;
		 ;; this dummy funciton is to get around a compiler bug
		 ;; with %finish-function-call
		 ;;
		 (SI:WITH-REM-KEYWORDS (KEYARGS (CDR ARGS) '(:AREA :DISPLACED-TO
							     :NO-INITIAL-VALUE
							     :INITIAL-VALUE))
		   (IF NO-INITIAL-VALUE
		       (CL:APPLY #'MAKE-ARRAY (FIRST ARGS)
				 :DISPLACED-TO DISPLACED-TO
				 KEYARGS)
		       (CL:APPLY #'MAKE-ARRAY (FIRST ARGS)
				 :INITIAL-VALUE INITIAL-VALUE
				 :DISPLACED-TO DISPLACED-TO
				 KEYARGS)))))
	(SETQ ALLOC-RASTER (DUMMY-FUNCTION)
	      SLOT `(NIL . ,ALLOC-RASTER)))
	(LET* ((ARGS (COPY-IF-NECESSARY ARGS))
	       (VAL `(,SLOT ,@(SEND *TEMP-SHEET-RASTER-HEADER-RESOURCE* ':GET-HASH ARGS))))
	  (WITHOUT-INTERRUPTS
	    (SEND *TEMP-SHEET-RASTER-HEADER-RESOURCE* ':PUT-HASH ARGS VAL))))
    (UNLESS (OR (GET ARGS ':DISPLACED-TO)
		NO-INITIAL-VALUE)
      (SETQ INITIAL-VALUE (OR INITIAL-VALUE 0))
      (SI:FILL-ARRAY ALLOC-RASTER NIL INITIAL-VALUE))
    (SEND *TEMP-SHEET-RASTER-HEADER-RESOURCE* ':PUT-HASH ALLOC-RASTER SLOT)
    ALLOC-RASTER))

(DEFUN DEALLOCATE-TEMP-SHEET-RASTER-AND-HEADER (RASTER)
  (LET ((SLOT (SEND *TEMP-SHEET-RASTER-HEADER-RESOURCE* ':GET-HASH RASTER)))
    (WITHOUT-INTERRUPTS
      (COND ((NULL SLOT) NIL)
	    ((NULL (CAR SLOT))
	     (DEALLOCATE-TEMP-SHEET-RASTER-BODY (ARRAY-INDIRECT-POINTER (CDR SLOT)))
	     (SEND *TEMP-SHEET-RASTER-HEADER-RESOURCE* ':REM-HASH RASTER)
	     (SETF (CAR SLOT) T)
	     T)
	    (T (FERROR "Raster Resource ~A already released!" SLOT) NIL)))))


(DEFVAR *RASTER-BODY-RESOURCE* (MAKE-ARRAY 32.))   ;;indices are powers of two

(DEFCONST *RASTER-BODY-RESOURCE-SCALE* (- 32. (HAULONG CL:ARRAY-DIMENSION-LIMIT)))

(DEFUN ALLOCATE-TEMP-SHEET-RASTER-BODY (DIMS ARGS )
  (LET* ((ATYPE (OR (GET (LOCF ARGS) ':TYPE) 'ART-FIXNUM))
	 (AAREA (OR (GET ARGS ':AREA) TV:BIT-ARRAY-AREA))
	 (TOTSIZE (CEILING (* (OR (CDR (ASSQ ATYPE ARRAY-BITS-PER-ELEMENT)) 32.)
			      (IF (LISTP DIMS) (LEXPR-FUNCALL #'TIMES DIMS) DIMS))
			   32.))
	 (HSIZE (HAULONG (LSH TOTSIZE *RASTER-BODY-RESOURCE-SCALE* ))))

    (OR (GET (LOCF ARGS) ':DISPLACED-TO)
	(WITHOUT-INTERRUPTS
	  (LOOP WITH OLD = (AREF *RASTER-BODY-RESOURCE* HSIZE)
		FOR I IN OLD DO
		(WHEN (AND (CAR I) (>= (ARRAY-LENGTH (CDR I)) TOTSIZE))
		  (SETF (CAR I) NIL)
		  (RETURN (CDR I)))))
	(LET ((I (MAKE-ARRAY TOTSIZE ':TYPE 'ART-FIXNUM ':AREA AAREA)))
	  (WITHOUT-INTERRUPTS
	    (SETF (AREF *RASTER-BODY-RESOURCE* HSIZE)
		  `((NIL . ,I) ,@ (AREF *RASTER-BODY-RESOURCE* HSIZE))))
	  I))))

(DEFUN DEALLOCATE-TEMP-SHEET-RASTER-BODY (RESOURCE-RASTER)
  (LOOP WITH HSIZE = (HAULONG (LSH (ARRAY-LENGTH RESOURCE-RASTER)
				   *RASTER-BODY-RESOURCE-SCALE*))
	WITH OLD = (AREF *RASTER-BODY-RESOURCE* HSIZE)
	FOR I IN OLD DO
	(WHEN (EQ (CDR I) RESOURCE-RASTER)
	  (IF (NULL (CAR I))
	      (PROGN (SETF (CAR I) T) (RETURN T))
	      (FERROR "Raster Resource ~A already released!" RESOURCE-RASTER )))))


(DEFMACRO WITH-TEMP-SHEET-RASTER ((NAME . ARGS) &BODY FORMS )
  `(LET (,NAME)
     (UNWIND-PROTECT
       (PROGN
	 (SETQ ,NAME (ALLOCATE-TEMP-SHEET-RASTER-AND-HEADER ,@ARGS))
	 ,@FORMS)
       (DEALLOCATE-TEMP-SHEET-RASTER-AND-HEADER ,NAME))))

(DEFMACRO WITH-TEMP-SHEET-RASTERS (SPECS &BODY FORMS)
  `(LET (,@(LOOP FOR I IN SPECS COLLECT (CAR I) ))
     (UNWIND-PROTECT
       (PROGN 
	 ,@(LOOP FOR I IN SPECS
		 COLLECT
		 `(SETQ ,(CAR I) (ALLOCATE-TEMP-SHEET-RASTER-AND-HEADER ,@(CDR I))))
	 ,@FORMS)
       ,@(LOOP FOR I IN SPECS COLLECT `(DEALLOCATE-TEMP-SHEET-RASTER-AND-HEADER ,(CAR I))))))


(DEFUN MAKE-TEMPORARY-SHEET-BIT-RASTER
       (SHEET WIDTH HEIGHT &REST MAKE-ARRAY-OPTIONS)
  (IF (LISTP SHEET)
      ;sheet is a list of arrays, a format used by IMAGES to represent RGB images
      ;allocate a list of temporaries
      (LOOP FOR I IN SHEET
	    COLLECT (CL:APPLY #'MAKE-TEMPORARY-SHEET-BIT-RASTER
			      I WIDTH HEIGHT MAKE-ARRAY-OPTIONS))
      (LET* ((TYPE (IF (ARRAYP SHEET)
		       (ARRAY-TYPE SHEET)   ;use the array type of the array
		       (SHEET-ARRAY-TYPE SHEET)))
	     (ROUND-TO (FLOOR 32. (OR (CDR (ASSQ TYPE ARRAY-BITS-PER-ELEMENT)) 32.)))
	     (ROUNDED-WIDTH (* (CEILING WIDTH ROUND-TO) ROUND-TO))
	     (IVAL (OR (GET (LOCF MAKE-ARRAY-OPTIONS) ':INITIAL-VALUE)
		       0))
	     (RASTER (LEXPR-FUNCALL #'ALLOCATE-TEMP-SHEET-RASTER-AND-HEADER
				    (RASTER-WIDTH-AND-HEIGHT-TO-MAKE-ARRAY-DIMENSIONS 
				      ROUNDED-WIDTH HEIGHT)
				    ':TYPE TYPE
				    ':INITIAL-VALUE IVAL
				    ':NO-INITIAL-VALUE T
				    MAKE-ARRAY-OPTIONS)))
	(SI:PAGE-IN-RASTER-ARRAY RASTER 0 0 WIDTH HEIGHT)
	RASTER)))

(DEFUN DEALLOCATE-TEMPORARY-SHEET-BIT-RASTER (RASTER)
  (COND ((LISTP RASTER)
	 ;raster was a list of rasters, allocated above.
	 (LOOP WITH VAL
	       FOR I IN RASTER
	       AS ALL = (DEALLOCATE-TEMP-SHEET-RASTER-AND-HEADER I)
	       DO (SETQ VAL (OR (WHEN ALL T)))
	       FINALLY
		 ;return T if any of the list were deallocated
		 (RETURN (OR VAL RASTER))))
	((DEALLOCATE-TEMP-SHEET-RASTER-AND-HEADER RASTER) T)
	(T RASTER)))

(DEFUN CLEAR-TEMPORARY-SHEET-BIT-RASTER-RESOURCE ()
  ;; Remove arrays that are not being used, so they can be garbage collected.
  (MAPHASH #'(LAMBDA (KEY L)
	       (WHEN (LISTP KEY)
		 (IF (SETQ L (CL:REMOVE-IF #'CAR L))
		     (PUTHASH KEY L *TEMP-SHEET-RASTER-HEADER-RESOURCE*)
		     (REMHASH KEY *TEMP-SHEET-RASTER-HEADER-RESOURCE*))))
	   *TEMP-SHEET-RASTER-HEADER-RESOURCE*)
  (DOTIMES (I (ARRAY-LENGTH *RASTER-BODY-RESOURCE*))
    (SETF (AREF *RASTER-BODY-RESOURCE* I)
	  (CL:REMOVE-IF #'CAR (AREF *RASTER-BODY-RESOURCE* I)))))

#||
(ADD-INITIALIZATION "Clear temporary raster resource"
		    '(CLEAR-TEMPORARY-SHEET-BIT-RASTER-RESOURCE)
		    nil
		    'SI:BEFORE-DYNAMIC-GC-LIST)
||#

(SI:DEFINE-GC-OPTIMIZATION CLEAR-TEMPORARY-SHEET-BIT-RASTER-RESOURCE
			   :LAYERED-SYSTEM-RELEASE
  (:DOCUMENTATION "Remove unused arrays from the temporary-sheet-bit-raster resource")
  (:BEFORE-FLIP (IGNORE)
    ;; Remove arrays that are not being used, so they can be garbage collected.
   (CLEAR-TEMPORARY-SHEET-BIT-RASTER-RESOURCE)
   ))

(DEFGENERIC WITH-TEMPORARY-SHEET-BIT-RASTER-1 (SHEET CONTINUATION WIDTH HEIGHT)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION)))

(DEFMACRO WITH-TEMPORARY-SHEET-BIT-RASTER ((RASTER-VAR SHEET WIDTH HEIGHT) &BODY BODY)
  `(WITH-TEMPORARY-SHEET-BIT-RASTER-1 ,SHEET #'(LAMBDA (,RASTER-VAR) ,@BODY) ,WIDTH ,HEIGHT))

(DEFMETHOD (WITH-TEMPORARY-SHEET-BIT-RASTER-1 SHEET) (CONTINUATION WIDTH HEIGHT)
  (LET ((RASTER NIL))
    (UNWIND-PROTECT
	(PROGN
	  (SETF RASTER (%SCREEN-ALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF WIDTH HEIGHT))
	  (FUNCALL CONTINUATION RASTER))
      (WHEN (NOT (NULL RASTER))
	(%SCREEN-DEALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF RASTER)))))

(DEFMACRO WITH-OFF-SCREEN-DRAWING ((SHEET &KEY COMPLETE-REDISPLAY) &BODY BODY)
  `(WITH-OFF-SCREEN-DRAWING-1 (LAMBDA () . ,BODY) ,SHEET
			      ,@(WHEN COMPLETE-REDISPLAY
				  `(:COMPLETE-REDISPLAY ,COMPLETE-REDISPLAY))))

(DEFUN WITH-OFF-SCREEN-DRAWING-1 (CONTINUATION SHEET &KEY COMPLETE-REDISPLAY)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION))
  (SHEET-FORCE-ACCESS (SHEET :NO-PREPARE)
    (LET ((WIDTH (SHEET-WIDTH SHEET))
	  (HEIGHT (SHEET-HEIGHT SHEET)))
      (WITH-TEMPORARY-SHEET-BIT-RASTER (RASTER SHEET WIDTH HEIGHT)
	(COND ((NULL RASTER)
	       (FUNCALL CONTINUATION))
	      (T
	       (UNLESS COMPLETE-REDISPLAY
		 (TV:PREPARE-SHEET (SHEET)
		   (SHEET-BITBLT ALU-SETA WIDTH HEIGHT (SHEET-SCREEN-ARRAY SHEET) 0 0
				 RASTER 0 0 SHEET)))
	       (MULTIPLE-VALUE-PROG1
		 (WITH-OFF-SCREEN-DRAWING-2 (SHEET-SCREEN SHEET) SHEET RASTER CONTINUATION)
		 (TV:PREPARE-SHEET (SHEET)
		   (SHEET-BITBLT ALU-SETA WIDTH HEIGHT RASTER 0 0
				 (SHEET-SCREEN-ARRAY SHEET) 0 0 SHEET)))))))))

;; Temporarily install RASTER as SHEET's screen-array, and call CONTINUATION
;; Note that when this is called the sheet is locked, so we don't have to
;; worry about other processes seeing the modified screen array
;; In this method, RASTER is guaranteed to be an array
(DEFMETHOD (WITH-OFF-SCREEN-DRAWING-2 BASIC-SCREEN) (SHEET RASTER CONTINUATION)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION))
  (LET ((OLD-SCREEN-ARRAY (SHEET-SCREEN-ARRAY SHEET))
	(OLD-FLAG (SHEET-OFF-SCREEN-DRAWING-FLAG SHEET))
	(OLD-EXPOSED (SHEET-ALL-EXPOSED SHEET))
	(NEW-SCREEN-ARRAY (OR (SHEET-SCREEN-ARRAY SHEET) (SHEET-OLD-SCREEN-ARRAY SHEET))))
      (UNWIND-PROTECT
	  (PROGN ;; Give SHEET a screen-array since it now has RASTER to draw on
		 (UNLESS (EQ NEW-SCREEN-ARRAY OLD-SCREEN-ARRAY)
		   (SETF (SHEET-SCREEN-ARRAY SHEET) NEW-SCREEN-ARRAY))
		 ;; Make SHEET's screen-array indirect to RASTER
		 (IF (EQ SHEET SELF)	;:ADJUST-SCREEN-ARRAY protocol incompatibility!
		     (SEND SHEET :ADJUST-SCREEN-ARRAY NEW-SCREEN-ARRAY RASTER)
		     (SEND SHEET :ADJUST-SCREEN-ARRAY NEW-SCREEN-ARRAY RASTER 0 0 0 0))
		 #+IGNORE
		 (UNLESS (EQ NEW-SCREEN-ARRAY OLD-SCREEN-ARRAY)
		   ;; This probably ought to expose the SHEET-EXPOSED-INFERIORS, but since
		   ;; the screen manager in 7.2 failed to do that when refreshing a window
		   ;; with :save-bits nil into a temporary array, and since it doesn't seem
		   ;; to work anyway, we'll just let the inferiors remain deexposed.
		   )
		 (SETF (SHEET-OFF-SCREEN-DRAWING-FLAG SHEET) 1)
		 (SETF (SHEET-ALL-EXPOSED SHEET) 0)	;not connected to drawing hardware now
		 (FUNCALL CONTINUATION))
	;; Restore the old indirection of SHEET's screen-array
	(IF (AND (SHEET-BIT-ARRAY SHEET) (NOT (SHEET-EXPOSED-P SHEET)))
	    (SEND SHEET :ADJUST-SCREEN-ARRAY NEW-SCREEN-ARRAY (SHEET-BIT-ARRAY SHEET) 0 0 0 0)
	    (SEND SHEET :ADJUST-SCREEN-ARRAY NEW-SCREEN-ARRAY
					     (IF (SHEET-SUPERIOR SHEET)
						 (SHEET-SUPERIOR-SCREEN-ARRAY SHEET)
						 (SCREEN-BUFFER SELF))))
	;; Restore the old status of the three SHEET fields we modified
	(SETF (SHEET-OFF-SCREEN-DRAWING-FLAG SHEET) OLD-FLAG)
	(SETF (SHEET-ALL-EXPOSED SHEET) OLD-EXPOSED)
	(SETF (SHEET-SCREEN-ARRAY SHEET) OLD-SCREEN-ARRAY))))

;;; The real screen manager:

(DEFMACRO USING-SCREEN-MANAGER-BIT-ARRAY ((VAR SHEET) &BODY BODY)
  `(WITH-TEMPORARY-SHEET-BIT-RASTER (,VAR ,SHEET (SHEET-WIDTH ,SHEET) (SHEET-HEIGHT ,SHEET))
     . ,BODY))

#||
(DEFMETHOD (:CHANGE-OF-SIZE-OR-MARGINS SCREEN :AFTER) (&REST IGNORE)
  ;; Discard screen manager temporary bit arrays that aren't big enough
  (SETF (GET (LOCF PROPERTY-LIST) ':SCREEN-MANAGER-BIT-ARRAY)
	(REM-IF-NOT #'(LAMBDA (A)
			(MULTIPLE-VALUE-BIND (AW AH)
			    (DECODE-RASTER-ARRAY A)
			  (AND ( AW WIDTH) ( AH HEIGHT))))
		    (GET (LOCF PROPERTY-LIST) ':SCREEN-MANAGER-BIT-ARRAY))))
||#

;; Changed ARRAY-TO-DRAW-ON to SHEET-TO-DRAW-ON, 'cause color needs sheets. -DDyer/Weaver
(DEFUN SCREEN-MANAGE-SHEET (SHEET &OPTIONAL BOUND-RECTANGLES SHEET-TO-DRAW-ON (X 0) (Y 0) ALU
			    &AUX RECTANGLE-LIST)
  "Perform screen management on a sheet.  Should be called with the sheet locked, and
inferiors ordered, and inside a method handling a message to that sheet.  The rectangles
passed in here better be destructable."
  (COND (BOUND-RECTANGLES
	 (LET ((LEFT (SHEET-INSIDE-LEFT SHEET))
	       (TOP (SHEET-INSIDE-TOP SHEET))
	       (RIGHT (SHEET-INSIDE-RIGHT SHEET))
	       (BOTTOM (SHEET-INSIDE-BOTTOM SHEET)))
	   (DOLIST (R BOUND-RECTANGLES)
	     (SETF (RECT-LEFT R) (MAX LEFT (RECT-LEFT R)))
	     (SETF (RECT-TOP R) (MAX TOP (RECT-TOP R)))
	     (SETF (RECT-RIGHT R) (MIN RIGHT (RECT-RIGHT R)))
	     (SETF (RECT-BOTTOM R) (MIN BOTTOM (RECT-BOTTOM R)))
	     ;; Is this now an illegal rectangle?  If so, then punt it altogether
	     (OR (AND (< (RECT-LEFT R) (RECT-RIGHT R)) (< (RECT-TOP R) (RECT-BOTTOM R)))
		 (SETQ BOUND-RECTANGLES (DELQ R BOUND-RECTANGLES)))))
	 (SETQ BOUND-RECTANGLES (CANONICALIZE-RECTANGLE-SET BOUND-RECTANGLES)))
	(T
	 (SETQ BOUND-RECTANGLES
	       (LIST (LIST (LIST SHEET 0 0)
			   (SHEET-INSIDE-LEFT SHEET) (SHEET-INSIDE-TOP SHEET)
			   (SHEET-INSIDE-RIGHT SHEET) (SHEET-INSIDE-BOTTOM SHEET))))))

  ;; Figure out what should be visible
  ;; This loop is executed with S each of the inferiors then with S the sheet itself
  (DO ((INFS (SHEET-INFERIORS SHEET) (CDR INFS))
       (S) (R-TEM) (S-TEM))
      ((NULL BOUND-RECTANGLES))
    (AND (NULL INFS)
	 (RETURN (SETQ RECTANGLE-LIST (NCONC BOUND-RECTANGLES RECTANGLE-LIST))))
    (SETQ S (CAR INFS))
    (SETQ S-TEM (SCREEN-MANAGE-SHEET-RECTANGLES S BOUND-RECTANGLES))
    ;; S-TEM is the set of rectangles which are visible portions of S
    (IF (NULL S-TEM)
	NIL
	(DOLIST (R S-TEM)
	  (DOLIST (RA BOUND-RECTANGLES)
	    (SETQ BOUND-RECTANGLES (DELQ RA BOUND-RECTANGLES)
		  R-TEM (RECTANGLE-NOT-INTERSECTION R RA))
	    (AND R-TEM (SETQ BOUND-RECTANGLES (NCONC R-TEM BOUND-RECTANGLES))))
	  (OR BOUND-RECTANGLES (RETURN T)))
	(OR (AND (SHEET-EXPOSED-P S) (SHEET-SCREEN-ARRAY SHEET))
	    ;; Never need to restore exposed sheets if superior
	    ;; has a screen image
	    (SETQ RECTANGLE-LIST (NCONC S-TEM RECTANGLE-LIST)))))

  (SCREEN-MANAGE-FLUSH-KNOWLEDGE SHEET)

  ;; Now do the updates
  (AND RECTANGLE-LIST
       ;; Here we changed ARRAY-TO-DRAW-ON to..
       (IF SHEET-TO-DRAW-ON
	   (SCREEN-MANAGE-SHEET-FINAL SHEET RECTANGLE-LIST SHEET-TO-DRAW-ON X Y ALU)
	   (SHEET-FORCE-ACCESS (SHEET)
	     (SCREEN-MANAGE-SHEET-FINAL SHEET RECTANGLE-LIST SHEET-TO-DRAW-ON X Y ALU)))))

;; Changed ARRAY-TO-DRAW-ON to SHEET-TO-DRAW-ON, 'cause color needs sheets. -DDyer/Weaver
;; The sheet is supposed to be prepared already, so we don't have to worry
;; about the mouse-blinker.
(DEFUN SCREEN-MANAGE-SHEET-FINAL (SHEET RECTANGLE-LIST SHEET-TO-DRAW-ON X Y ALU)
  (OR SHEET-TO-DRAW-ON (SETQ SHEET-TO-DRAW-ON SHEET))
  (DO ((MASTER (CAR RECTANGLE-LIST) (CAR RECTANGLE-LIST))
       (CURRENT-SHEET))
      ((NULL MASTER))
    ;; For all deexposed windows that are of interest, tell them to put their bits up
    ;; (all the sheets are locked by us, so no problem with change of state).  If it's
    ;; an inferior, put up its bits, but if it's the sheet being managed, it means
    ;; there is nothing there.  This is rather misleading; it means there are no
    ;; inferiors there, but not that it is really necessarily blank! See
    ;; comments on SCREEN-MANAGE-MAYBE-BLT-RECTANGLE.
    (SETQ CURRENT-SHEET (CAR (RECT-SOURCE MASTER)))
    (COND ((EQ SHEET CURRENT-SHEET)
	   (SETQ RECTANGLE-LIST
		 (SEND SHEET :SCREEN-MANAGE-UNCOVERED-AREA
		       RECTANGLE-LIST SHEET-TO-DRAW-ON X Y ALU)))
	  (T
	   (SETQ RECTANGLE-LIST
		 (SEND SHEET :SCREEN-MANAGE-INFERIOR-AREA
		       CURRENT-SHEET RECTANGLE-LIST SHEET-TO-DRAW-ON X Y ALU))))))

(DEFUN SCREEN-MANAGE-FLUSH-KNOWLEDGE (SHEET)
  (SETF (SHEET-SCREEN-MANAGER-SCREEN-IMAGE SHEET) NIL))

(DEFUN SCREEN-MANAGE-SHEET-RECTANGLES (SHEET BOUND-RECTANGLES
				        &AUX (X-OFF (SHEET-X-OFFSET SHEET))
					     (Y-OFF (SHEET-Y-OFFSET SHEET))
					     (SUPERIOR (SHEET-SUPERIOR SHEET))
				             (LEFT -1) (TOP -1)
					     (RIGHT (1- 1_23.)) (BOTTOM (1- 1_23.))
					     RECTS)
  (COND ((OR (MEMQ SHEET (SHEET-EXPOSED-INFERIORS SUPERIOR))
	     (SEND SHEET ':SCREEN-MANAGE-DEEXPOSED-VISIBILITY))
	 (COND (SUPERIOR
		(SETQ LEFT (SHEET-INSIDE-LEFT SUPERIOR)
		      TOP (SHEET-INSIDE-TOP SUPERIOR)
		      RIGHT (SHEET-INSIDE-RIGHT SUPERIOR)
		      BOTTOM (SHEET-INSIDE-BOTTOM SUPERIOR))))
	 
	 ;; Intersect the rectangles with the bounds of the specified sheet,
	 ;; and return a list of the resulting rectangles.
	 ;; Include in the source description the bit array so we force an update if that
	 ;; changes.
	 (DOLIST (BOUND BOUND-RECTANGLES)
	   (AND (SHEET-OVERLAPS-P SHEET
				  (RECT-LEFT BOUND) (RECT-TOP BOUND)
				  (- (RECT-RIGHT BOUND) (RECT-LEFT BOUND))
				  (- (RECT-BOTTOM BOUND) (RECT-TOP BOUND)))
		(PUSH (LIST (LIST SHEET X-OFF Y-OFF (SHEET-BIT-ARRAY SHEET))
			    (MAX X-OFF (RECT-LEFT BOUND) LEFT)
			    (MAX Y-OFF (RECT-TOP BOUND) TOP)
			    (MIN (+ X-OFF (SHEET-WIDTH SHEET)) (RECT-RIGHT BOUND) RIGHT)
			    (MIN (+ Y-OFF (SHEET-HEIGHT SHEET)) (RECT-BOTTOM BOUND) BOTTOM))
		      RECTS)))
	 RECTS)))

;;; Subroutines used by bit restorers and blank area managers

(DEFUN-IN-FLAVOR (SCREEN-MANAGE-CLEAR-RECTANGLE SHEET) (R TO-SHEET X Y ALU)
  ;; although these COND clauses seem to be the same, they are in fact both necessary.
  ;; The first clause permits color hardware to do the fastest thing, while the
  ;; second permits the general case to work.
  (COND ((INSTANCEP TO-SHEET)
	 (SEND TO-SHEET ':DRAW-RECTANGLE
	   (- (RECT-RIGHT R) (RECT-LEFT R)) (- (RECT-BOTTOM R) (RECT-TOP R))
	   (- (+ X (RECT-LEFT R)) (SHEET-LEFT-MARGIN-SIZE TO-SHEET))
	   (- (+ Y (RECT-TOP R)) (SHEET-TOP-MARGIN-SIZE TO-SHEET))
	   (OR ALU :ERASE)))
	((EQ TO-SHEET SCREEN-ARRAY)
	 (SHEET-DRAW-RECTANGLE
	   (- (RECT-RIGHT R) (RECT-LEFT R)) (- (RECT-BOTTOM R) (RECT-TOP R))
	   (+ X (RECT-LEFT R)) (+ Y (RECT-TOP R))
	   (OR ALU ERASE-ALUF)
	   SELF))
	(T  ;; ELSE OLD INTERFACE, TO-SHEET IS AN ARRAY
	 (%DRAW-RECTANGLE 
	   (- (RECT-RIGHT R) (RECT-LEFT R)) (- (RECT-BOTTOM R) (RECT-TOP R))
	   (+ X (RECT-LEFT R)) (+ Y (RECT-TOP R))
	   (OR ALU ERASE-ALUF)
	   TO-SHEET))))

(DEFUN-IN-FLAVOR (SCREEN-MANAGE-MAYBE-BLT-RECTANGLE SHEET) (R TO-SHEET X Y ALU)
  "This is a reasonable screen management protocol for blank areas for sheets which
might have bit save arrays and get screen managed, such as LISP-LISTENERS with inferiors."
  (COND ((AND BIT-ARRAY (VERIFY-DRAWABLE SCREEN BIT-ARRAY SELF :READ))
	 (%SCREEN-PAGE-IN-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF BIT-ARRAY :READ)
	 (COND ((INSTANCEP TO-SHEET)
		(SEND TO-SHEET :BITBLT
		      (OR ALU ALU-SETA)
		      (- (RECT-RIGHT R) (RECT-LEFT R)) (- (RECT-BOTTOM R) (RECT-TOP R))
		      ;; The rectangle is defined to be zero based
		      BIT-ARRAY (RECT-LEFT R) (RECT-TOP R)
		      (- (+ X (RECT-LEFT R)) (SHEET-LEFT-MARGIN-SIZE TO-SHEET))
		      (- (+ Y (RECT-TOP R)) (SHEET-TOP-MARGIN-SIZE TO-SHEET))))
	       (T ;; ELSE OLD INTERFACE, WHERE TO-SHEET IS AN ARRAY
		(BITBLT (OR ALU ALU-SETA)
			(- (RECT-RIGHT R) (RECT-LEFT R)) (- (RECT-BOTTOM R) (RECT-TOP R))
			;; The rectangle is defined to be zero based
			BIT-ARRAY (RECT-LEFT R) (RECT-TOP R)
			TO-SHEET (+ X (RECT-LEFT R)) (+ Y (RECT-TOP R))))))
	(T
	 (SCREEN-MANAGE-CLEAR-RECTANGLE R TO-SHEET X Y ALU))))


(DEFUN-IN-FLAVOR (SCREEN-MANAGE-CLEAR-AREA SHEET) (RECTS ARRAY X Y ALU)
  (DOLIST (R RECTS)
    (COND ((EQ SELF (CAR (RECT-SOURCE R)))
           (SCREEN-MANAGE-CLEAR-RECTANGLE R ARRAY X Y ALU)
	   (SETQ RECTS (DELQ R RECTS)))))
  RECTS)

(DEFUN-IN-FLAVOR (SCREEN-MANAGE-RESTORE-AREA SHEET)
		 (RECTANGLE-LIST TO-SHEET X Y ALU
				 &OPTIONAL CLEAR-AREA USE-TO-SHEET)
  (COND ((AND BIT-ARRAY (VERIFY-DRAWABLE SCREEN BIT-ARRAY SELF :READ))
	 (SCREEN-MANAGE-RESTORE-AREA-FROM-BIT-ARRAY SELF
						    RECTANGLE-LIST
						    BIT-ARRAY
						    TO-SHEET X Y
						    (ARRAYP BIT-ARRAY)
						    (OR ALU ALU-SETA)))
	(CLEAR-AREA
	 (SCREEN-MANAGE-CLEAR-AREA RECTANGLE-LIST TO-SHEET X Y ALU))
	(T
	 ;; If no saved bits, Refresh into a temporary array and use that as the bits
	 (LABELS ((FORCED-REFRESH (ARRAY)
		    (%SCREEN-PAGE-IN-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF ARRAY :WRITE)
		    (WITH-OFF-SCREEN-DRAWING-2
		      SCREEN SELF ARRAY
		      #'(LAMBDA ()
			  (SHEET-FORCE-ACCESS (SELF T)
			    (SEND SELF :REFRESH))
			  ;; This fixes a bug, where autoexposed inferiors of the window we just
			  ;; refreshed were left with their screen arrays still indirected to the
			  ;; screen manager temporary.  This happens if :REFRESH calls the screen
			  ;; manager and thus causes autoexposure.
			  (WITHOUT-SCREEN-MANAGEMENT
			    ;; Copy the list before iterating in case deexposing a window causes some
			    ;; side-effect on the list other than just deleting that particular window
			    (DOLIST (I (COPYLIST EXPOSED-INFERIORS))
			      (WHEN (SHEET-EXPOSED-P I)
				(SEND I :DEEXPOSE :DEFAULT :NOOP NIL))))))))
	   (IF (AND USE-TO-SHEET
		    (ARRAYP TO-SHEET)
		    (MULTIPLE-VALUE-BIND (RW RH)(DECODE-RASTER-ARRAY TO-SHEET)
		      (AND ( RW (+ X (SHEET-WIDTH SELF)))
			   ( RH (+ Y (SHEET-HEIGHT SELF))))))
	       (FORCED-REFRESH TO-SHEET)
	       (USING-SCREEN-MANAGER-BIT-ARRAY (ARRAY SELF)
		 (FORCED-REFRESH ARRAY)
		 (SCREEN-MANAGE-RESTORE-AREA-FROM-BIT-ARRAY SELF
							    RECTANGLE-LIST
							    ARRAY
							    TO-SHEET X Y
							    NIL (OR ALU ALU-SETA))))))))

(DEFUN SCREEN-MANAGE-RESTORE-AREA-FROM-BIT-ARRAY
	(FROM-SHEET RECTANGLE-LIST ARRAY TO-SHEET X Y PAGE-FLAG ALU
	 &AUX (FROM-X 0) (FROM-Y 0) (TO-X 0) (TO-Y 0))
  (DOLIST (R RECTANGLE-LIST)
    (COND ((EQ (CAR (RECT-SOURCE R)) FROM-SHEET)
	   (SETF FROM-X (- (RECT-LEFT R) (CADR (RECT-SOURCE R))))
	   (SETF FROM-Y (- (RECT-TOP R) (CADDR (RECT-SOURCE R))))
	   (SETF TO-X (+ FROM-X (- (RECT-RIGHT R) (RECT-LEFT R))))
	   (SETF TO-Y (+ FROM-Y (- (RECT-BOTTOM R) (RECT-TOP R))))
	   (AND PAGE-FLAG (SI:PAGE-IN-RASTER-ARRAY ARRAY FROM-X FROM-Y TO-X TO-Y))
	   (IF (TYPEP TO-SHEET 'SHEET)
	       (SEND TO-SHEET ':BITBLT (OR ALU ALU-SETA)
		     (- (RECT-RIGHT R) (RECT-LEFT R))
		     (- (RECT-BOTTOM R) (RECT-TOP R))
		     ARRAY
		     ;; Take chunk offset to rectangle origin
		     FROM-X FROM-Y
		     (- (+ X (RECT-LEFT R)) (SHEET-LEFT-MARGIN-SIZE TO-SHEET))
		     (- (+ Y (RECT-TOP R)) (SHEET-TOP-MARGIN-SIZE TO-SHEET)))
	       (WITH-SCREEN-CONTROLLER-LOCK ((SHEET-SCREEN FROM-SHEET))
		 (SHEET-IS-PREPARED (FROM-SHEET)
		   (SHEET-BITBLT (OR ALU ALU-SETA)
				 (- (RECT-RIGHT R) (RECT-LEFT R))
				 (- (RECT-BOTTOM R) (RECT-TOP R))
				 ARRAY
				 ;; Take chunk offset to rectangle origin
				 FROM-X FROM-Y
				 TO-SHEET (+ X (RECT-LEFT R)) (+ Y (RECT-TOP R))
				 FROM-SHEET))))

	   (SETQ RECTANGLE-LIST (DELQ R RECTANGLE-LIST)))))
  (WHEN (ARRAYP ARRAY)
    (SI:PAGE-OUT-RASTER-ARRAY ARRAY FROM-X FROM-Y TO-X TO-Y))
  RECTANGLE-LIST)

;;; Screen manager message handlers and flavors

(DEFWRAPPER (:SCREEN-MANAGE SHEET) (IGNORE . BODY)
  `(LOCK-SHEET (SELF)
     . ,BODY))

;;; Deexposed sheets are defaultly "visible" -- they will show through if they can
;;; and if their priority allows them to
;;; If you redefine this to return T even if there is no bit-array, the right thing
;;; will happen (the window will be refreshed into a temporary array and the
;;; results of that will show through).
(DEFWRAPPER (:SCREEN-MANAGE-DEEXPOSED-VISIBILITY SHEET) (IGNORE . BODY)
  `(AND (OR (NULL PRIORITY) ( PRIORITY 0))
	(PROGN . ,BODY)))

(DEFMETHOD (:SCREEN-MANAGE-DEEXPOSED-VISIBILITY SHEET) ()
  (NOT (NULL BIT-ARRAY)))

(DEFMETHOD (:SCREEN-MANAGE SHEET) (&REST ARGS)
  "This performs screen management on a sheet.  This always works, even if screen management
is inhibited.  It will also do autoexposure on the sheet, unless screen management is
inhibited.  This allows you to batch a series of screen manages without running autoexposure
each time.  It is expected that autoexposure gets run explicitly in this case."
;--- I don't think this is needed, they should be ordered already --Moon
;---  (SEND SELF ':ORDER-INFERIORS)
  (SEND SELF ':SCREEN-MANAGE-AUTOEXPOSE-INFERIORS)
  (LEXPR-FUNCALL #'SCREEN-MANAGE-SHEET SELF ARGS))

;;; Note: Rectangles given to :SCREEN-MANAGE-UNCOVERED-AREA are 0 origin and
;;;       point into SELF.  This is guaranteed, and need not be checked for.
(DEFMETHOD (:SCREEN-MANAGE-UNCOVERED-AREA SHEET) (RECTS ARRAY X Y ALU)
  ARRAY X Y ALU					;Unused
  (DOLIST (R RECTS)
    (AND (EQ (CAR (RECT-SOURCE R)) SELF)
	 (SETQ RECTS (DELQ R RECTS))))
  RECTS)

(DEFUN-IN-FLAVOR (SCREEN-MANAGE-CLEAR-UNCOVERED-AREA SHEET) (RECTS ARRAY X Y ALU)
  "Default is to clear area.  This can be redefined if that isn't desireable."
  (DOLIST (R RECTS)
    (COND ((EQ (CAR (RECT-SOURCE R)) SELF)
	   (SCREEN-MANAGE-CLEAR-RECTANGLE R ARRAY X Y ALU)
	   (SETQ RECTS (DELQ R RECTS)))))
  RECTS)

(DEFMETHOD (:SCREEN-MANAGE-UNCOVERED-AREA BASIC-SCREEN) (RECTS ARRAY X Y ALU)
  (SCREEN-MANAGE-CLEAR-UNCOVERED-AREA RECTS ARRAY X Y ALU))

(DEFMETHOD (:SCREEN-MANAGE-RESTORE-AREA SHEET) (RECTS ARRAY X Y ALU &OPTIONAL USE-ARRAY-FREELY)
  "Default way to restore bits.
If there is a bit array, restore from there.  If there is no bit array, simply
clear the area, unless :SCREEN-MANAGE-DEEXPOSED-VISIBILITY returns T in which
case refresh the bits into a temporary array and restore from that"
  (SCREEN-MANAGE-RESTORE-AREA RECTS ARRAY X Y ALU
			      (NOT (SEND SELF ':SCREEN-MANAGE-DEEXPOSED-VISIBILITY))
			      USE-ARRAY-FREELY))



;;; Protocol for negotiating with the inferiors about how they are to be
;;; grayed over when deexposed but partially visible.

(DEFMETHOD (:SCREEN-MANAGE-INFERIOR-AREA SHEET) (INFERIOR RECTS ARRAY X Y ALU)
  (SCREEN-MANAGE-INFERIOR-AREA SELF NIL INFERIOR RECTS ARRAY X Y ALU))

(DEFUN SCREEN-MANAGE-INFERIOR-AREA (SUPERIOR GRAY-ARRAY INFERIOR RECTS ARRAY X Y ALU)
  ;; Let the inferior override our choice of stipple pattern if it wishes
  (MULTIPLE-VALUE-BIND (INFERIOR-GRAY-ARRAY DONT-GRAY)
      (SEND INFERIOR :SCREEN-MANAGE-DEEXPOSED-GRAY-ARRAY)
    (WHEN (OR INFERIOR-GRAY-ARRAY DONT-GRAY)
      (SETQ GRAY-ARRAY INFERIOR-GRAY-ARRAY)))
  (WHEN SCREEN-MANAGE-TRACE-OUTPUT
    (FORMAT SCREEN-MANAGE-TRACE-OUTPUT
	    "~&Inferior-area: sup=~S gray=~S inf=~S~% rects=~S~% array=~S x=~S y=~S alu=~S"
	    SUPERIOR GRAY-ARRAY INFERIOR RECTS ARRAY X Y ALU))
  (COND ((NOT GRAY-ARRAY)
	 ;; Easy case: just restore the unmodified bits of the inferior
	 (SEND INFERIOR :SCREEN-MANAGE-RESTORE-AREA RECTS ARRAY X Y ALU))
	((ZEROP (SHEET-OFF-SCREEN-DRAWING-FLAG SUPERIOR))
	 ;; Get an array to use as a temporary buffer so we don't see obnoxious flashing
	 ;; on the screen as the inferior first comes up proper and then gets grayed over
	 (LET ((SW (SHEET-WIDTH INFERIOR)) (SH (SHEET-HEIGHT INFERIOR)))
	   (USING-SCREEN-MANAGER-BIT-ARRAY (KLUDGE-ARRAY SUPERIOR)
	     (WHEN (ARRAYP KLUDGE-ARRAY)
	       (PAGE-IN-RASTER-ARRAY KLUDGE-ARRAY NIL NIL SW SH))
	     ;; Compute the X and Y offsets to shift the inferior's image to top-left of array
	     (MULTIPLE-VALUE-BIND (KLUDGE-X KLUDGE-Y)
		 (SHEET-CALCULATE-OFFSETS INFERIOR SUPERIOR)
	       ;; Draw the needed parts of the inferior into the top-left corner of KLUDGE-ARRAY
	       (SEND INFERIOR :SCREEN-MANAGE-RESTORE-AREA
		     (COPYLIST RECTS) KLUDGE-ARRAY
		     (- KLUDGE-X)(- KLUDGE-Y) ALU-SETA T)
	       ;; Gray them over 
	       (DOLIST (R RECTS)
		 (WHEN (EQ (CAR (RECT-SOURCE R)) INFERIOR)
		   (LET ((RL (RECT-LEFT R))
			 (RT (RECT-TOP R))
			 (RR (RECT-RIGHT R))
			 (RB (RECT-BOTTOM R)))
		     (TV:SCREEN-MANAGE-GRAY-RECTANGLE-ON-SHEET-INTERNAL
		       INFERIOR
		       (- RR RL)
		       (- RB RT)
		       GRAY-ARRAY
		       (- RL KLUDGE-X)
		       (- RT KLUDGE-Y)
		       RL RT
		       KLUDGE-ARRAY
		       (SHEET-CHAR-ALUF INFERIOR) 
		       COLOR:ALU-NOOP
		       ))))
	       ;; Put the result on the screen and page out the array
	       (SCREEN-MANAGE-RESTORE-AREA-FROM-BIT-ARRAY INFERIOR RECTS KLUDGE-ARRAY
							  ARRAY X Y NIL ALU
							  )))))
	(T
	 ;; Draw directly since the "obnoxious flashing" is off-screen anyway
	 ;; First draw the needed parts of the inferior
	 (LET ((REMAINING-RECTANGLES
		 (SEND INFERIOR :SCREEN-MANAGE-RESTORE-AREA (COPYLIST RECTS) ARRAY X Y ALU)))
	   ;; Then gray them over 
	   (DOLIST (R RECTS)
	     (WHEN (EQ (CAR (RECT-SOURCE R)) INFERIOR)
	       (TV:SCREEN-MANAGE-GRAY-RECTANGLE GRAY-ARRAY R ARRAY X Y
						(SHEET-CHAR-ALUF INFERIOR) 0 0
						COLOR:ALU-NOOP)))
	   ;; Then return the rectangles that haven't been processed yet
	   REMAINING-RECTANGLES))))

;;; Windows that want to override their default appearance when partially exposed
;;; can handle this.  Return (VALUES NIL T) to suppress graying entirely.
;;; Document this near :SCREEN-MANAGE-DEEXPOSED-VISIBILITY
(DEFMETHOD (:SCREEN-MANAGE-DEEXPOSED-GRAY-ARRAY SHEET) ()
  (DECLARE (VALUES GRAY-ARRAY DONT-GRAY))
  NIL)


(DEFFLAVOR NO-SCREEN-MANAGING-MIXIN () ())

(DEFMETHOD (:SCREEN-MANAGE NO-SCREEN-MANAGING-MIXIN) (&REST IGNORE) NIL)
(DEFMETHOD (:SCREEN-MANAGE-UNCOVERED-AREA NO-SCREEN-MANAGING-MIXIN) (&REST IGNORE) NIL)

(DEFFLAVOR SHOW-PARTIALLY-VISIBLE-MIXIN () ())

(DEFMETHOD (:SCREEN-MANAGE-DEEXPOSED-VISIBILITY SHOW-PARTIALLY-VISIBLE-MIXIN) () T)

;;; Graying stuff

;;; Gray-over a rectangular region.
;;; SHEET is who to draw on.  This almost always is a sheet but
;;; according to the rest of the code could sometimes be an array.
;;; It must be prepared already.
;;; The phasing of the gray is constant with respect to the superior, unless
;;; the two optional arguments are supplied.  This makes the gray pattern match
;;; on adjacent windows.  Formerly the phasing was constant with respect to
;;; the inferior, which made adjacent deexposed windows clash in their gray
;;; patterns but kept the interaction of the gray with the window's own image
;;; constant as you moved the window.
(DEFUN SCREEN-MANAGE-GRAY-RECTANGLE (GRAY-ARRAY RECT SHEET X Y ALU
				     &OPTIONAL (X-PHASE 0) (Y-PHASE 0) ZEROS-ALU)
  "Gray the specified rectangle on the specified array.  All graying is phased relative
to (0, 0) on the specified array, unless overridden.  GRAY-ARRAY can be an array, an
instance, a function, a list of a function and extra arguments, NIL, :WHITE, or :BLACK."
  (SCREEN-MANAGE-GRAY-RECTANGLE-INTERNAL GRAY-ARRAY SHEET (OR ALU ALU-SETA)
	(- (RECT-RIGHT RECT) (RECT-LEFT RECT)) (- (RECT-BOTTOM RECT) (RECT-TOP RECT))
	(+ X (RECT-LEFT RECT)) (+ Y (RECT-TOP RECT))
	(+ X (RECT-LEFT RECT) X-PHASE) (+ Y (RECT-TOP RECT) Y-PHASE)
	ZEROS-ALU))

(DEFUN SCREEN-MANAGE-GRAY-RECTANGLE-INTERNAL
       (GRAY-ARRAY SHEET-OR-RASTER ALU X-SIZE Y-SIZE X-POS Y-POS X-PHASE Y-PHASE
	&OPTIONAL ZEROS-ALU)
  (CL:ETYPECASE SHEET-OR-RASTER
    (SCL:INSTANCE
      (SCREEN-MANAGE-GRAY-RECTANGLE-ON-SHEET-INTERNAL
	SHEET-OR-RASTER X-SIZE Y-SIZE GRAY-ARRAY X-POS Y-POS
	X-PHASE Y-PHASE
	(SHEET-SCREEN-ARRAY SHEET-OR-RASTER)
	ALU
	(OR ZEROS-ALU (SHEET-ERASE-ALUF SHEET-OR-RASTER))
	))
    (CL:ARRAY
      (SCREEN-MANAGE-GRAY-RECTANGLE-ON-RASTER-INTERNAL
	GRAY-ARRAY SHEET-OR-RASTER ALU
	X-SIZE Y-SIZE X-POS Y-POS X-PHASE Y-PHASE
	)))
  NIL)

(DEFUN SCREEN-MANAGE-GRAY-RECTANGLE-ON-SHEET-INTERNAL
       (SHEET X-SIZE Y-SIZE
	GRAY-ARRAY  
	X-POS Y-POS
	&OPTIONAL
	(X-PHASE 0) (Y-PHASE 0)
	(DEST-ARRAY (SHEET-SCREEN-ARRAY SHEET))
	(ONES-ALU (SHEET-CHAR-ALUF SHEET))
	(ZEROS-ALU (SHEET-ERASE-ALUF SHEET)))

  ;;this is a lie, but expedient until
  ;;the :%draw-xx functions are next reorganized 
  (WITH-SCREEN-CONTROLLER-LOCK ((SHEET-SCREEN SHEET))
    (SHEET-IS-PREPARED (SHEET)
      (COND ((EQ GRAY-ARRAY :WHITE)
	     (SHEET-DRAW-RECTANGLE X-SIZE Y-SIZE X-POS Y-POS
				   (SHEET-ERASE-ALUF SHEET) SHEET DEST-ARRAY))
	    ((EQ GRAY-ARRAY :BLACK)
	     (SHEET-DRAW-RECTANGLE X-SIZE Y-SIZE X-POS Y-POS
				   (SHEET-CHAR-ALUF SHEET) SHEET DEST-ARRAY))
	    ((NULL GRAY-ARRAY))
	    ((FUNCTIONP GRAY-ARRAY)
	     (FUNCALL GRAY-ARRAY X-SIZE Y-SIZE X-POS Y-POS X-PHASE Y-PHASE
		      SHEET DEST-ARRAY ONES-ALU ZEROS-ALU
		      ))
	    ((LISTP GRAY-ARRAY)
	     (LEXPR-FUNCALL (CAR GRAY-ARRAY) X-SIZE Y-SIZE X-POS Y-POS X-PHASE Y-PHASE
			    SHEET DEST-ARRAY ONES-ALU ZEROS-ALU (CDR GRAY-ARRAY)))
	    ((INSTANCEP GRAY-ARRAY)
	     (SEND GRAY-ARRAY :DRAW-BLANK-RECTANGLE X-SIZE Y-SIZE X-POS Y-POS X-PHASE Y-PHASE
		   SHEET DEST-ARRAY ONES-ALU ZEROS-ALU))
	    (T 
	     (LET* ((SSIZE (ARRAY-ELEMENT-SIZE GRAY-ARRAY)))
	       (MULTIPLE-VALUE-BIND (GRAY-WIDTH GRAY-HEIGHT)
		   (DECODE-RASTER-ARRAY GRAY-ARRAY)
		 (IF ( SSIZE 1)
		     (LET* ((DSIZE (ARRAY-ELEMENT-SIZE DEST-ARRAY))
			    (CORRECTED-X-PHASE (// (* X-PHASE DSIZE) SSIZE)))
		       (SHEET-BITBLT ONES-ALU X-SIZE Y-SIZE
				     GRAY-ARRAY
				     (MOD CORRECTED-X-PHASE GRAY-WIDTH)
				     (MOD Y-PHASE GRAY-HEIGHT)
				     DEST-ARRAY X-POS Y-POS
				     SHEET))
		     ;;Use the copy microcode to do the right thing
		     (SHEET-DRAW-1-BIT-RASTER
		       X-SIZE Y-SIZE
		       GRAY-ARRAY (MOD X-PHASE GRAY-WIDTH) (MOD Y-PHASE GRAY-HEIGHT)
		       DEST-ARRAY X-POS Y-POS
		       ONES-ALU ZEROS-ALU
		       SHEET
		       ))))))))
  NIL)

(DEFUN SCREEN-MANAGE-GRAY-RECTANGLE-ON-RASTER-INTERNAL (GRAY-ARRAY RASTER ALU
					      X-SIZE Y-SIZE X-POS Y-POS X-PHASE Y-PHASE)
  (COND ((EQ GRAY-ARRAY :WHITE)
	 (%DRAW-RECTANGLE-INTERNAL X-SIZE Y-SIZE X-POS Y-POS ALU-SETZ RASTER))
	((EQ GRAY-ARRAY :BLACK)
	 (%DRAW-RECTANGLE-INTERNAL X-SIZE Y-SIZE X-POS Y-POS ALU-SETA RASTER))
	((NULL GRAY-ARRAY))
	((FUNCTIONP GRAY-ARRAY)
	 (FUNCALL GRAY-ARRAY X-SIZE Y-SIZE X-POS Y-POS X-PHASE Y-PHASE 
		  NIL RASTER ALU COLOR:ALU-NOOP)
	 )
	((LISTP GRAY-ARRAY)
	 (LEXPR-FUNCALL (CAR GRAY-ARRAY) X-SIZE Y-SIZE X-POS Y-POS X-PHASE Y-PHASE
			NIL RASTER ALU COLOR:ALU-NOOP (CDR GRAY-ARRAY)))
	((INSTANCEP GRAY-ARRAY)
	 (SEND GRAY-ARRAY :DRAW-BLANK-RECTANGLE X-SIZE Y-SIZE X-POS Y-POS X-PHASE Y-PHASE
	       NIL RASTER ALU COLOR:ALU-NOOP))
	(T 
	 ;; This change to graying arranges to preserve the phase of the gray array
	 ;; when there is a mismatch between the bit-size of the gray array and the
	 ;; destination array.  In general, such "impedence mismatched" graying doesn't
	 ;; look good, but it looks even worse if the swatches don't align.
	 (LET* ((SSIZE (ARRAY-ELEMENT-SIZE GRAY-ARRAY))
		(DSIZE (ARRAY-ELEMENT-SIZE RASTER))
		(CORRECTED-X-PHASE (// (* X-PHASE DSIZE) SSIZE)))
	   (MULTIPLE-VALUE-BIND (GRAY-WIDTH GRAY-HEIGHT)
	       (DECODE-RASTER-ARRAY GRAY-ARRAY)
	     (BITBLT ALU X-SIZE Y-SIZE
		     GRAY-ARRAY (MOD CORRECTED-X-PHASE GRAY-WIDTH) (MOD Y-PHASE GRAY-HEIGHT)
		     RASTER X-POS Y-POS)))))
  NIL)

;;; Mixin to gray areas of a sheet (normally a screen or frame) that have no windows on them.

(DEFFLAVOR GRAY-UNUSED-AREAS-MIXIN ((GRAY-ARRAY-FOR-UNUSED-AREAS 50%-GRAY)) ()
  (:REQUIRED-FLAVORS SHEET)
  :GETTABLE-INSTANCE-VARIABLES
  :SETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  (:DOCUMENTATION :MIXIN
   "Gray over areas of the window that are /"unused/", that is, contain no inferior windows.
This is useful for screens and frames that aren't completely tiled with panes."))


(DEFWHOPPER-SUBST (:SCREEN-MANAGE-UNCOVERED-AREA GRAY-UNUSED-AREAS-MIXIN)
		  (RECTS ARRAY X Y ALU)
  (COND (GRAY-ARRAY-FOR-UNUSED-AREAS
	 (DOLIST (R RECTS)
	   (WHEN (EQ (CAR (RECT-SOURCE R)) SELF)
	     (SCREEN-MANAGE-GRAY-RECTANGLE
	       GRAY-ARRAY-FOR-UNUSED-AREAS R ARRAY X Y CHAR-ALUF)
	     (SETQ RECTS (DELQ R RECTS))))
	 RECTS)
	(T (CONTINUE-WHOPPER RECTS ARRAY X Y ALU))))


;;; Mixin for graying over partially exposed windows
(DEFFLAVOR GRAY-DEEXPOSED-INFERIORS-MIXIN ((GRAY-ARRAY-FOR-INFERIORS 6%-GRAY)) ()
  (:REQUIRED-FLAVORS SHEET)
  :GETTABLE-INSTANCE-VARIABLES
  :SETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  (:DOCUMENTATION :MIXIN "Gray over partially-exposed inferiors of this screen or frame."))

(DEFMETHOD (:SCREEN-MANAGE-INFERIOR-AREA GRAY-DEEXPOSED-INFERIORS-MIXIN)
	   (INFERIOR RECTS ARRAY X Y ALU)
  (SCREEN-MANAGE-INFERIOR-AREA SELF GRAY-ARRAY-FOR-INFERIORS INFERIOR RECTS ARRAY X Y ALU))

;There could be another version of the above mixin that grays inferiors
;more darkly if they are more deeply buried.

;;; Take care of the borders on 3600 black and white screen and make it gray unused-areas

(DEFFLAVOR GRAY-MAIN-SCREEN-BORDERS-MIXIN () ()
  (:REQUIRED-INSTANCE-VARIABLES GRAY-ARRAY-FOR-UNUSED-AREAS)	;forward reference problem
  (:REQUIRED-FLAVORS GRAY-UNUSED-AREAS-MIXIN BASIC-SCREEN))

;;; Extend the unused-areas gray pattern into the screen borders
;;; People who want Zippy in the borders will have to patch this method
;;; or remove this mixin from the MAIN-SCREEN
;;; It seemed better not to complicate things by giving this method its own gray-array
;;; independent of the one for unused-areas in the normal portion of the screen
;;; I guess we can just let this cons, it's not called often at all
(DEFMETHOD (:REFRESH-MARGINS GRAY-MAIN-SCREEN-BORDERS-MIXIN) ()
  (LET ((SIDE-HEIGHT (- HEIGHT BOTTOM-MARGIN-SIZE TOP-MARGIN-SIZE))
	(GRAY-ARRAY (OR GRAY-ARRAY-FOR-UNUSED-AREAS :WHITE)))
    ;; Fill the top margin
    ;; For some gray patterns you get obnoxious striping in the visible area off the
    ;; top of the screen, but that's a bug in the sync program, and not so easy to
    ;; compensate for here.  With the default gray pattern, which is dark, it's no problem.
    (PREPARE-SHEET (SELF)
      (SCREEN-MANAGE-GRAY-RECTANGLE-INTERNAL
	GRAY-ARRAY SELF ALU-SETA
	WIDTH TOP-MARGIN-SIZE 0 0 0 0)
      ;; Fill the bottom margin
      (SCREEN-MANAGE-GRAY-RECTANGLE-INTERNAL
	GRAY-ARRAY SELF ALU-SETA
	WIDTH BOTTOM-MARGIN-SIZE 0 (- HEIGHT BOTTOM-MARGIN-SIZE)
	0 (- HEIGHT BOTTOM-MARGIN-SIZE))
      ;; Fill the left margin
      (SCREEN-MANAGE-GRAY-RECTANGLE-INTERNAL
	GRAY-ARRAY SELF ALU-SETA
	LEFT-MARGIN-SIZE SIDE-HEIGHT 0 TOP-MARGIN-SIZE 0 TOP-MARGIN-SIZE)
      ;; Fill the right margin
      (SCREEN-MANAGE-GRAY-RECTANGLE-INTERNAL
	GRAY-ARRAY SELF ALU-SETA
	RIGHT-MARGIN-SIZE SIDE-HEIGHT (- WIDTH RIGHT-MARGIN-SIZE) TOP-MARGIN-SIZE
	(- WIDTH RIGHT-MARGIN-SIZE) TOP-MARGIN-SIZE)))
  NIL)

;;; Compatibility with the old graying mixins, which were very confused

(DEFFLAVOR GRAY-DEEXPOSED-MIXIN ((GRAY-ARRAY HES-GRAY)) ()
  :GETTABLE-INSTANCE-VARIABLES
  :SETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  (:REQUIRED-FLAVORS SHEET)
  (:DOCUMENTATION :MIXIN "Grayed over when deexposed."))

(DEFMETHOD (:SCREEN-MANAGE-DEEXPOSED-GRAY-ARRAY GRAY-DEEXPOSED-MIXIN) ()
  (VALUES GRAY-ARRAY T))

(DEFFLAVOR GRAY-DEEXPOSED-WRONG-MIXIN () (GRAY-DEEXPOSED-MIXIN))
(DEFFLAVOR GRAY-DEEXPOSED-RIGHT-MIXIN () (GRAY-DEEXPOSED-MIXIN))

(COMPILER:MAKE-OBSOLETE GRAY-DEEXPOSED-WRONG-MIXIN
  "This mixin exists only for compatibility with previous system versions.
Use GRAY-DEEXPOSED-MIXIN if you want special control over how this window
looks when it is deexposed but partially visible, so that you can make this
window look different from other windows.
Use GRAY-UNUSED-AREAS-MIXIN if you want areas of this window not occupied
by inferior windows to be filled with a gray pattern.
Use no mixin at all if you want this window to be grayed the same way as
other windows when it is deexposed."
  DEFFLAVOR)

(COMPILER:MAKE-OBSOLETE GRAY-DEEXPOSED-RIGHT-MIXIN
  "This mixin exists only for compatibility with previous system versions.
Use GRAY-DEEXPOSED-MIXIN if you want special control over how this window
looks when it is deexposed but partially visible, so that you can make this
window look different from other windows.
Use GRAY-UNUSED-AREAS-MIXIN if you want areas of this window not occupied
by inferior windows to be filled with a gray pattern.
Use no mixin at all if you want this window to be grayed the same way as
other windows when it is deexposed."
  DEFFLAVOR)

;;; Simple command interface for graying

;;; These work on frames with the appropriate mixins, too, but to keep
;;; the documentation simple we don't mention that.

(DEFUN SET-SCREEN-BACKGROUND-GRAY (GRAY &OPTIONAL (SCREENS `(,MAIN-SCREEN ,WHO-LINE-SCREEN)))
  "Set the gray pattern used for the background of this screen where there are no windows"
  (CHECK-ARG GRAY (OR (NULL GRAY)
		      (AND (ARRAYP GRAY) (= (ARRAY-#-DIMS GRAY) 2))
		      (INSTANCEP GRAY)
		      (FUNCTIONP GRAY)
		      (AND (LISTP GRAY) (FUNCTIONP (CAR GRAY)))
		      (MEMQ GRAY '(:WHITE :BLACK)))
	     "NIL, a 2-dimensional array, an instance that accepts
the :DRAW-BLANK-RECTANGLE message, a function, a list whose car is
a function and whose cdr is additional arguments to the function,
the symbol :WHITE, or the symbol :BLACK")
  (UNLESS (LISTP SCREENS)
    (SETQ SCREENS (NCONS SCREENS)))
  (DOLIST (SCREEN SCREENS)
    (SEND SCREEN :SET-GRAY-ARRAY-FOR-UNUSED-AREAS GRAY)
    (SEND SCREEN :SCREEN-MANAGE)
    (WHEN (SEND SCREEN :EXPOSED-P)
      (SEND SCREEN :REFRESH-MARGINS))))

(DEFUN SET-SCREEN-DEEXPOSED-GRAY (GRAY &OPTIONAL (SCREEN MAIN-SCREEN))
  "Set the gray pattern smeared over partially-exposed windows on this screen"
  (CHECK-ARG GRAY (OR (NULL GRAY)
		      (AND (ARRAYP GRAY) (= (ARRAY-#-DIMS GRAY) 2))
		      (INSTANCEP GRAY)
		      (FUNCTIONP GRAY)
		      (AND (LISTP GRAY) (FUNCTIONP (CAR GRAY)))
		      (MEMQ GRAY '(:WHITE :BLACK)))
	     "NIL, a 2-dimensional array, an instance that accepts
the :DRAW-BLANK-RECTANGLE message, a function, a list whose car is
a function and whose cdr is additional arguments to the function,
the symbol :WHITE, or the symbol :BLACK")
  (SEND SCREEN :SET-GRAY-ARRAY-FOR-INFERIORS GRAY)
  (SEND SCREEN :SCREEN-MANAGE))

;;; Interfaces to the other software
(DEFVAR SCREEN-MANAGE-TRACE-OUTPUT NIL)

(DEFUN SCREEN-ACTIVITY-HAS-CHANGED (WINDOW ON-P)
  ON-P						;Isn't very interesting
  (AND SCREEN-MANAGE-TRACE-OUTPUT
       (FORMAT SCREEN-MANAGE-TRACE-OUTPUT
	       "~&Activity change: window ~S, ~:[Deactivate~;Activate~]~%"
	       WINDOW ON-P))
  (COND ((SEND WINDOW ':SCREEN-MANAGE-DEEXPOSED-VISIBILITY)
	 ;; If window is visible when deexposed, then screen management is useful
	 (SCREEN-MANAGE-WINDOW-AREA WINDOW))
	(T (SCREEN-MANAGE-FLUSH-KNOWLEDGE WINDOW))))

(DEFUN SCREEN-CONFIGURATION-HAS-CHANGED (WINDOW &OPTIONAL (WHY ':FORCE)
						&AUX (SUP (SHEET-SUPERIOR WINDOW)))
  ;; Only consider active windows
  (WHEN (AND SUP (MEMQ WINDOW (SHEET-INFERIORS SUP)))
    ;; Order superior's list of active inferiors if anything has changed
    (UNLESS (EQ WHY ':SET-EDGES)
      (SEND SUP :ORDER-INFERIORS WINDOW WHY))
    (AND SCREEN-MANAGE-TRACE-OUTPUT
	 (FORMAT SCREEN-MANAGE-TRACE-OUTPUT
		 "~&Configuration change: window ~S, reason ~A~%"
		 WINDOW WHY))		      
    (IF (EQ WHY ':EXPOSE)
	;; Exposing a window does not need to screen-manage area occupied by the window.
	;; If anything was deexposed, this function will be called again.
	;; Screen management may have been requested by SCREEN-ACTIVITY-HAS-CHANGED;
	;; remove that request, or any covered over by this window, from the queue.
	(STACK-LET ((RECT (LIST NIL (SHEET-X-OFFSET WINDOW) (SHEET-Y-OFFSET WINDOW)
				(+ (SHEET-X-OFFSET WINDOW) (SHEET-WIDTH WINDOW))
				(+ (SHEET-Y-OFFSET WINDOW) (SHEET-HEIGHT WINDOW)))))
	  (WITHOUT-INTERRUPTS
	    (DOLIST (QE SCREEN-MANAGER-QUEUE)
	      (AND (EQ (CAR (RECT-SOURCE QE)) SUP)
		   (RECT-WITHIN-RECT-P QE RECT)
		   (SETQ SCREEN-MANAGER-QUEUE (DELQ QE SCREEN-MANAGER-QUEUE)))))
	  (when screen-manager-background-process
	    (process:process-wakeup screen-manager-background-process)))
	;; Normal case
	(SCREEN-MANAGE-WINDOW-AREA WINDOW))))

(DEFUN SCREEN-AREA-HAS-CHANGED (WINDOW &REST RECT
				&AUX (SUP (SHEET-SUPERIOR WINDOW)))
  (WHEN (AND SUP (MEMQ WINDOW (SHEET-INFERIORS SUP))
	     (OR (AND RECT (SHEET-EXPOSED-P WINDOW))	;Explicit rectangle, and exposed
		 (SEND WINDOW ':SCREEN-MANAGE-DEEXPOSED-VISIBILITY)))
    (WHEN SCREEN-MANAGE-TRACE-OUTPUT
      (FORMAT SCREEN-MANAGE-TRACE-OUTPUT "~&Area change: window ~S~%" WINDOW))
    (LEXPR-FUNCALL #'SCREEN-MANAGE-WINDOW-AREA WINDOW RECT)))

(DEFUN SCREEN-MANAGE-WINDOW-AREA (WINDOW
				  &OPTIONAL (LEFT (SHEET-X-OFFSET WINDOW))
				  	    (TOP (SHEET-Y-OFFSET WINDOW))
					    (RIGHT (+ (SHEET-X-OFFSET WINDOW)
						      (SHEET-WIDTH WINDOW)))
					    (BOTTOM (+ (SHEET-Y-OFFSET WINDOW)
						       (SHEET-HEIGHT WINDOW)))
				  &AUX (SUP (SHEET-SUPERIOR WINDOW)))
  (AND SUP (SCREEN-MANAGE-QUEUE SUP LEFT TOP RIGHT BOTTOM)))

(DEFUN SCREEN-MANAGE-QUEUE (SHEET &OPTIONAL LEFT TOP RIGHT BOTTOM
				  &AUX E (INHIBIT-SCHEDULING-FLAG T))
  (SETQ E (IF (LISTP SHEET)
	      SHEET
	      (LIST (LIST SHEET 0 0) LEFT TOP RIGHT BOTTOM)))
  ;; Add to queue, eliminating redundant entries
  (COND ((DOLIST (QE SCREEN-MANAGER-QUEUE)
	   (COND ((EQ (CAR (RECT-SOURCE E)) (CAR (RECT-SOURCE QE)))
		  (AND (RECT-WITHIN-RECT-P E QE)
		       (RETURN T))
		  (AND (RECT-WITHIN-RECT-P QE E)
		       (SETQ SCREEN-MANAGER-QUEUE (DELQ QE SCREEN-MANAGER-QUEUE)))))))
	(T
	 (AND SCREEN-MANAGE-TRACE-OUTPUT
	      (FORMAT SCREEN-MANAGE-TRACE-OUTPUT
		      "~&Queueing rectangle ~S, inhibit ~A~%"
		      E INHIBIT-SCREEN-MANAGEMENT))
	 (PUSH E SCREEN-MANAGER-QUEUE)
	 ;; Do right away if possible, otherwise leave on queue
	 (OR INHIBIT-SCREEN-MANAGEMENT
	     (SCREEN-MANAGE-DEQUEUE-ENTRY E))))
  ;; when all that is finished, do we want to wakeup the background process?
  (WHEN SCREEN-MANAGER-BACKGROUND-PROCESS
    (PROCESS:PROCESS-WAKEUP SCREEN-MANAGER-BACKGROUND-PROCESS)))

(DEFUN SCREEN-MANAGE-DELAYING-SCREEN-MANAGEMENT-INTERNAL (;&OPTIONAL OLD-STYLE
							  &AUX (INHIBIT-SCHEDULING-FLAG T))
  "Called if stuff got queued during a DELAYING-SCREEN-MANAGEMENT.
If now at top level dequeue them all, but never wait for a lock."
  (OR INHIBIT-SCREEN-MANAGEMENT
      ;; Only try to dequeue if not delaying anymore
      (SCREEN-MANAGE-DEQUEUE)))

(DEFUN SCREEN-MANAGE-DEQUEUE (&AUX (INHIBIT-SCHEDULING-FLAG T))
  (DO ((Q SCREEN-MANAGER-QUEUE))
      ((NULL Q))
    (IF (SCREEN-MANAGE-DEQUEUE-ENTRY (CAR Q))
	;; If the entry actually got dequeued, then interrupts were allowed and so the
	;; queue might have gotten hacked.  Restart from the beginning.
	(SETQ Q SCREEN-MANAGER-QUEUE)
	(SETQ Q (CDR Q))))
    ;; when all that is finished, do we want to wakeup the background process?
  (WHEN SCREEN-MANAGER-BACKGROUND-PROCESS
    (PROCESS:PROCESS-WAKEUP SCREEN-MANAGER-BACKGROUND-PROCESS)))

;The difference from the above is that this one will wait for a lock, rather than punting
(DEFUN SCREEN-MANAGE-DEQUEUE-DELAYED-ENTRIES (&AUX (INHIBIT-SCHEDULING-FLAG T))
  (DO ((Q SCREEN-MANAGER-QUEUE SCREEN-MANAGER-QUEUE))
      ((NULL Q))
    (SCREEN-MANAGE-DEQUEUE-ENTRY (CAR Q) T))
  (WHEN SCREEN-MANAGER-BACKGROUND-PROCESS
    (PROCESS:PROCESS-WAKEUP SCREEN-MANAGER-BACKGROUND-PROCESS))
  )	;This reenables scheduling if it does anything

(DEFUN SCREEN-MANAGE-DEQUEUE-ENTRY (ENTRY &OPTIONAL UNCOND &AUX ALL)
  "Handle one entry from the screen manager's queue.  Interrupts must be bound and inhibit.
Though it may turn off INHIBIT-SCHEDULING-FLAG, this routine will always return with
it turned back on.  The code returns T if it actually dequeued the entry, else NIL."
  (COND ((OR UNCOND (SHEET-CAN-GET-LOCK (CAR (RECT-SOURCE ENTRY))))
	 ;; May as well do all rectangles on this sheet together.  ALL gets a list of them.
	 (SETQ SCREEN-MANAGER-QUEUE (DELQ ENTRY SCREEN-MANAGER-QUEUE)
	       ALL (NCONS ENTRY))
	 (DOLIST (E SCREEN-MANAGER-QUEUE)
	   (COND ((EQ (CAR (RECT-SOURCE ENTRY)) (CAR (RECT-SOURCE E)))
		  (SETQ SCREEN-MANAGER-QUEUE (DELQ E SCREEN-MANAGER-QUEUE))
		  (PUSH E ALL))))
	 (AND SCREEN-MANAGE-TRACE-OUTPUT
	      (FORMAT SCREEN-MANAGE-TRACE-OUTPUT
		      "~&Dequeueing ~S~%Queue is ~S~%" ALL SCREEN-MANAGER-QUEUE))

	 (LET ((SHEET (CAR (RECT-SOURCE ENTRY))))
	   (IF (SHEET-SCREEN-ARRAY SHEET)
	       ;; FORCE-ACCESS so that PREPARE-SHEET won't look at the output-hold flag.
	       (SHEET-FORCE-ACCESS (SHEET :NO-PREPARE)
	         (SETQ INHIBIT-SCHEDULING-FLAG NIL)
		 ;; in case something needs to be done....
		 (when screen-manager-background-process
		   (process:process-wakeup
		     screen-manager-background-process))
		 (SEND (CAR (RECT-SOURCE ENTRY)) ':SCREEN-MANAGE ALL))

#|  Remove this code.  Why autoexpose on sheets we can't see?  I think this code 
    is responsible for some screen manager thrashing, and also for some auto-select
    at undesirable times.

             ;; If can't screen manage (no screen!), then just do autoexposure
	       (LOCK-SHEET (SHEET)
	         (SETQ INHIBIT-SCHEDULING-FLAG NIL)
		 (SEND SHEET ':ORDER-INFERIORS)
		 (SEND SHEET ':SCREEN-MANAGE-AUTOEXPOSE-INFERIORS))
 |#
	       )
	   (SETQ INHIBIT-SCHEDULING-FLAG T)
	   T))
	(T NIL)))

;;; Note that this message does not mean automatically expose this sheet.
;;; It means consider the inferiors of this sheet for automatic exposing.
(DEFMETHOD (:SCREEN-MANAGE-AUTOEXPOSE-INFERIORS SHEET) ()
  (SCREEN-MANAGE-AUTOEXPOSE-INFERIORS SELF))

;;
;; This fixes a bug with autoexposing ingeriors when all the screen manager
;; is really doing is refreshing.  It sometimes resulted in a window being
;; exposed as a result of (force-sheet-access --)
;;
(DEFUN SCREEN-MANAGE-AUTOEXPOSE-INFERIORS (SHEET &AUX INTERESTING-INFERIORS)
  "Expose all sheets that are uncovered but not exposed.  No need to do any screen management,
since exposure always does the right thing, and this can never cause a sheet to become
deexposed.  Should be called with the sheet locked."
  ;; First, get an ordered list of all sheets of interest
  ;; SHEET-INFERIORS has been ordered by priority.
  (LOCK-SHEET (SHEET)
    (DOLIST (I (SHEET-INFERIORS SHEET))
      (WHEN (OR (MEMQ I (SHEET-EXPOSED-INFERIORS SHEET))
		(AND ;(SEND I ':SCREEN-MANAGE-DEEXPOSED-VISIBILITY)
		     (SHEET-WITHIN-SHEET-P I SHEET)
		     (> (OR (SHEET-PRIORITY I) 0) -1)
		     (PUSH I INTERESTING-INFERIORS)))
	;; Stop at first full-screen window, to save paging
	(AND (= (SHEET-X I) (SHEET-INSIDE-LEFT SHEET))
	     (= (SHEET-Y I) (SHEET-INSIDE-TOP SHEET))
	     (= (SHEET-WIDTH I) (SHEET-INSIDE-WIDTH SHEET))
	     (= (SHEET-HEIGHT I) (SHEET-INSIDE-HEIGHT SHEET))
	     (RETURN))))
    (SETQ INTERESTING-INFERIORS (NREVERSE INTERESTING-INFERIORS))
    (AND SCREEN-MANAGE-TRACE-OUTPUT
	 (FORMAT SCREEN-MANAGE-TRACE-OUTPUT
		 "~&Autoexpose-inferiors: ~S~%" INTERESTING-INFERIORS))
    ;; Now, we have a list of interesting: deexposed and active
    ;; Expose them one by one if they aren't covered.
    (DOLIST (I INTERESTING-INFERIORS)
      (COND ((DOLIST (EI (SHEET-EXPOSED-INFERIORS SHEET))
	       (AND (SHEET-OVERLAPS-SHEET-P EI I)
		    (RETURN T))))		;This clause if covered: do nothing
	    ;; Don't expose if it would cover anything earlier in the list.  What this
	    ;; does is prevent violations of priority; something earlier in the list
	    ;; might not be exposed because some other part of it was covered.
	    ((DOLIST (HP INTERESTING-INFERIORS)
	       (AND (EQ I HP)
		    (RETURN T))
	       (AND (SEND HP ':SCREEN-MANAGE-DEEXPOSED-VISIBILITY)
		    (SHEET-OVERLAPS-SHEET-P I HP)
		    (RETURN NIL)))
	     (SEND I ':EXPOSE)
	     (SETQ INTERESTING-INFERIORS (DELQ I INTERESTING-INFERIORS)))))
    (AND ;;(EQ SHEET MOUSE-SHEET)			;Removed by DDyer/Weaver
	 (NULL (SHEET-SELECTED-WINDOW SHEET))
	 (SETQ INTERESTING-INFERIORS (SHEET-EXPOSED-INFERIORS SHEET))
	 ;; If there is no window currently selected, select a window.
	 (DOLIST (I INTERESTING-INFERIORS)
	   (AND (SEND I ':NAME-FOR-SELECTION)
		(NOT (ZEROP (SHEET-ALL-EXPOSED I)))  ;; only if it is really exposed! -Ddyer
		(RETURN (SEND I ':SELECT)))))))

;;; Screen manager's background process

;;; The background process is responsible for trying to handle the pending queue of
;;; screen manages, as well as updating windows which are in :PERMIT mode, deexposed,
;;; and have actually done typeout since we were last here

(DEFVAR SCREEN-MANAGE-UPDATE-PERMITTED-WINDOWS NIL)	;NIL not to do it, or time to sleep
(DEFVAR SCREEN-MANAGE-TIME-BETWEEN-DEQUEUES 10.)	;Check queue every 1/6 second
							;while it is non-empty (i.e. try
							;again to get locks this often)

(DEFUN SCREEN-MANAGE-BACKGROUND-TOP-LEVEL ()
  (DO ((HEAD-OF-QUEUE SCREEN-MANAGER-QUEUE SCREEN-MANAGER-QUEUE)
       (SLEEP-TIME))
      (())
    (SETQ SLEEP-TIME (COND (SCREEN-MANAGE-UPDATE-PERMITTED-WINDOWS
			     (COND ((NULL HEAD-OF-QUEUE)
				    SCREEN-MANAGE-UPDATE-PERMITTED-WINDOWS)
				   (T (MIN SCREEN-MANAGE-UPDATE-PERMITTED-WINDOWS
					   SCREEN-MANAGE-TIME-BETWEEN-DEQUEUES))))
			   (INHIBIT-SCREEN-MANAGEMENT NIL)
			   ((NULL HEAD-OF-QUEUE) NIL)
			   (T SCREEN-MANAGE-TIME-BETWEEN-DEQUEUES)))
    ;; Wait until queue has changed, and screen management not inhibited
    ;; Except SLEEP-TIME if non-null is a timeout
    (PROCESS:PROCESS-BLOCK-WITH-TIMEOUT
      (AND SLEEP-TIME (// SLEEP-TIME 60s0))
      "Screen Manage"
      #'(LAMBDA (HEAD-OF-QUEUE UPDATE-P)
	  (NOT (NULL (OR (AND UPDATE-P SCREEN-MANAGE-UPDATE-PERMITTED-WINDOWS)
			 (AND (NOT INHIBIT-SCREEN-MANAGEMENT)
			      (NEQ SCREEN-MANAGER-QUEUE HEAD-OF-QUEUE))))))
      HEAD-OF-QUEUE (NULL SLEEP-TIME))
    (OR INHIBIT-SCREEN-MANAGEMENT (SCREEN-MANAGE-DEQUEUE))
    (AND SCREEN-MANAGE-UPDATE-PERMITTED-WINDOWS
	 (WITHOUT-INTERRUPTS
	   (DOLIST (S ALL-THE-SCREENS)
	     (AND (SHEET-EXPOSED-P S)
		  (SCREEN-MANAGE-UPDATE-PERMITTED-WINDOWS S)))))))

(DEFUN SCREEN-MANAGE-UPDATE-PERMITTED-WINDOWS (SHEET &AUX (EXPSD-INFS
							    (SHEET-EXPOSED-INFERIORS SHEET)))
  (DOLIST (I (SHEET-INFERIORS SHEET))
    (SCREEN-MANAGE-UPDATE-PERMITTED-WINDOWS I)
    (WHEN (OR (MEMQ I EXPSD-INFS)
	      (WHEN ( (OR (SHEET-PRIORITY I) 0) 0)
		(WHEN (AND (EQ (SHEET-DEEXPOSED-TYPEOUT-ACTION I) ':PERMIT)
			   (ZEROP (SHEET-OUTPUT-HOLD-FLAG I)))
		  ;; Sheet is permitted, deexposed, and has been typed on.
		  ;; Update it on screen.
		  (SETF (SHEET-OUTPUT-HOLD-FLAG I) 1)
		  ;; this was (SCREEN-CONFIGURATION-HAS-CHANGED  I).  I think this is 
		  ;; wrong because it frobs the whole window although only output is known
		  ;; to have occurred.  This caused lossage when the screen manager process
		  ;; ran asynchronous to a window being exposed or deexposed. - DDyer/Weaver
		  (SCREEN-MANAGE-WINDOW-AREA I))
		T))
      ;; Window is either exposed or partially visible.
      ;; Stop at first full-screen window, to save paging.
      (AND (= (SHEET-X I) (SHEET-INSIDE-LEFT SHEET))
	   (= (SHEET-Y I) (SHEET-INSIDE-TOP SHEET))
	   (= (SHEET-WIDTH I) (SHEET-INSIDE-WIDTH SHEET))
	   (= (SHEET-HEIGHT I) (SHEET-INSIDE-HEIGHT SHEET))
	   (RETURN NIL)))))

(DEFVAR SCREEN-MANAGER-BACKGROUND-PROCESS
	(PROCESS:MAKE-PROCESS "Screen Manager Background"
			      :INITIAL-FUNCTION 'SCREEN-MANAGE-BACKGROUND-TOP-LEVEL
			      :SYSTEM-PROCESS T
			      :WARM-BOOT-ACTION 'PROCESS::PROCESS-WARM-BOOT-DELAYED-RESTART))

(DEFUN HALT-SCREEN-MANAGER ()
  (SETF TV:INHIBIT-SCREEN-MANAGEMENT T)
  (SETF TV:SCREEN-MANAGER-TOP-LEVEL NIL)
  NIL)

(DEFUN RESTART-SCREEN-MANAGER ()
  (WITHOUT-INTERRUPTS
    (SETF INHIBIT-SCREEN-MANAGEMENT NIL)
    (SETF SCREEN-MANAGER-TOP-LEVEL T)
    (SETF SCREEN-MANAGER-QUEUE NIL)
    (WHEN SCREEN-MANAGER-BACKGROUND-PROCESS
      (PROCESS:PROCESS-WAKEUP SCREEN-MANAGER-BACKGROUND-PROCESS)))
  NIL)

;;; Refresh a subrectangle of an exposed window

(CL:DEFPARAMETER *REFRESH-RECTANGLE-LOCK-TIMEOUT* 300.)	;5 seconds

;;; This whopper takes care of the lock, the inferiors, screen management to
;;; restore deexposed windows and blank area, and the return value.
;;; The primary method takes care of the content and the margins.
(DEFWHOPPER (REFRESH-RECTANGLE SHEET) (LEFT TOP RIGHT BOTTOM)
  (DECLARE (VALUES WINDOWS-AWAITING-REFRESH))
  (LET ((WINDOWS-AWAITING-REFRESH NIL))
    ;; Do the margins and the content
    (IF SUPERIOR
	;; Not a screen, lock it but don't wait forever if a lock is stuck or
	;; if it is temp-locked (it would stay temp-locked until the user took action)
	(LOOP WITH START-TIME = (TIME)
	      DO (MAYBE-LOCK-SHEET SELF
		   (PROGN ;; Erase the rectangle to be refreshed, to get rid of any
			  ;; blinker turds that may have been created there after
			  ;; it was erased by the host operating system without locking
			  ;; the sheet (of course the host doesn't know about sheets)
			  ;; This is also needed for inverse video windows
			  (PREPARE-SHEET (SELF)
			    (SHEET-DRAW-RECTANGLE (- RIGHT LEFT) (- BOTTOM TOP) LEFT TOP
						  ERASE-ALUF))
			  ;; Refresh the window contents and margins
			  (CONTINUE-WHOPPER LEFT TOP RIGHT BOTTOM)
			  (RETURN))
		   NIL)
	      WHILE (NOT (CL:CONSP (SHEET-LOCK SELF)))
	      WHILE (PROCESS-WAIT-WITH-TIMEOUT "Sheet Lock"
					       (- *REFRESH-RECTANGLE-LOCK-TIMEOUT*
						  (TIME-DIFFERENCE (TIME) START-TIME))
					       #'SHEET-CAN-GET-LOCK SELF *CURRENT-PROCESS*)
	      FINALLY
		;; We weren't able to refresh the thing, probably because it is temp-locked
		;; We won't be able to do the inferiors either so just return
		(RETURN-FROM REFRESH-RECTANGLE
		  (LIST (LIST SELF LEFT TOP RIGHT BOTTOM))))
	;; SELF is a screen
	;; It's important not to lock the lock for a screen, or we can get deadlocks
	;; Also screens don't have content, but they might have margins
	;; Refreshing the margins without locking the lock and without erasing them
	;; first seems questionable, but that's what KBD-SCREEN-REDISPLAY does
	(WHEN (OR (< LEFT (SHEET-INSIDE-LEFT)) (< TOP (SHEET-INSIDE-TOP))
		  (< (SHEET-INSIDE-RIGHT) RIGHT) (< (SHEET-INSIDE-BOTTOM) BOTTOM))
	  (SEND SELF :REFRESH-MARGINS)))
    ;; Do the exposed inferiors
    (DOLIST (INFERIOR EXPOSED-INFERIORS)
      (WHEN ;; True if the rectangle overlaps the inferior
	    (AND (< LEFT (+ (SHEET-X-OFFSET INFERIOR) (SHEET-WIDTH INFERIOR)))
		 (< (SHEET-X-OFFSET INFERIOR) RIGHT)
		 (< TOP (+ (SHEET-Y-OFFSET INFERIOR) (SHEET-HEIGHT INFERIOR)))
		 (< (SHEET-Y-OFFSET INFERIOR) BOTTOM))
	(SETQ WINDOWS-AWAITING-REFRESH
	      (NCONC (REFRESH-RECTANGLE INFERIOR
					(MAX (- LEFT (SHEET-X-OFFSET INFERIOR)) 0)
					(MAX (- TOP (SHEET-Y-OFFSET INFERIOR)) 0)
					(MIN (- RIGHT (SHEET-X-OFFSET INFERIOR))
					     (SHEET-WIDTH INFERIOR))
					(MIN (- BOTTOM (SHEET-Y-OFFSET INFERIOR))
					     (SHEET-HEIGHT INFERIOR)))
		     WINDOWS-AWAITING-REFRESH))))
    ;; Do the deexposed inferiors if there are any, and do blank area in frames
    (SCREEN-MANAGE-QUEUE SELF LEFT TOP RIGHT BOTTOM)
    WINDOWS-AWAITING-REFRESH))

;;; The default method does a complete :REFRESH in an off-screen bitmap
;;; and then copies that back onto the screen.  This does the right thing
;;; for menus, for example.
;;; Any method that shadows this needs to call REFRESH-MARGINS-RECTANGLE or in some
;;; other way arrange for the margins to be refreshed (this uses :REFRESH to do it)
(DEFMETHOD (REFRESH-RECTANGLE SHEET) (LEFT TOP RIGHT BOTTOM)
  (DECLARE (VALUES WINDOWS-AWAITING-REFRESH))
  (IGNORE LEFT TOP RIGHT BOTTOM)
  (WITH-OFF-SCREEN-DRAWING (SELF :COMPLETE-REDISPLAY T)
    (SEND SELF :REFRESH)))

(DEFMETHOD (REFRESH-MARGINS-RECTANGLE SHEET) (LEFT TOP RIGHT BOTTOM)
  ;; If the rectangle overlaps the margins, refresh them
  ;; The affected margins have already been erased
  (WHEN (OR (< LEFT (SHEET-INSIDE-LEFT)) (< TOP (SHEET-INSIDE-TOP))
	    (< (SHEET-INSIDE-RIGHT) RIGHT) (< (SHEET-INSIDE-BOTTOM) BOTTOM))
    ;; I don't worry about speeding up the case where only some margins are affected
    (SEND SELF :REFRESH-MARGINS)))
