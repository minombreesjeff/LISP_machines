;;; -*- Mode: LISP; Syntax: Zetalisp; Package: COLOR; Base: 10; Lowercase: Yes -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;; Color translations

;;; magic constants for the ihsrgb conversion algorithm.

(eval-when (compile load eval)
(defconstant *ihs-rgb-c1* (sqrt (// 6.0)))
(defconstant *ihs-rgb-c2* (sqrt (// 2.0)))
(defconstant *ihs-rgb-c3* (sqrt (// 3.0)))

(defconstant *pi-single-float* (float cl:pi))
)


D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;
;;macro to generate rgb->xyz and the like
;;
0(defmacro (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")def-transformation-function 0(name array
				       &key
				       inverse-name
				       (form 'defsubst)
				       (in-names)
				       (inv-in-names))
  (labels ((aval* (b array x y)
	     (let ((val (aref array x y)))
	       (cond (( (abs val) 0.0001) nil)
		     (( (abs (- (abs val) 1.0)) 0.0001)
		      (if (< val 0) `((- ,b)) `(,b)))
		     (t `((* ,b ,val))))))
	   (named-fun (name array &optional names)
	     (destructuring-bind (r g b)
		 (or names
		     (let ((pak (symbol-package name)))
		       (list (intern (substring name 0 1) pak)
			     (intern (substring name 1 2) pak)
			     (intern (substring name 2 3) pak))))
	       `(,form ,name (,r ,g ,b)
		 (values (+ ,@(aval* r array 0 0)
			    ,@(aval* g array 0 1)
			    ,@(aval* b array 0 2))
			 (+ ,@(aval* r array 1 0)
			    ,@(aval* g array 1 1)
			    ,@(aval* b array 1 2))
			 (+ ,@(aval* r array 2 0)
			    ,@(aval* g array 2 1)
			    ,@(aval* b array 2 2))))))
	   (resolve-array (a)
	     (cond ((null a) nil)
		   ((symbolp a) (symeval a))
		   ((listp a)
		    (let ((matrices (loop for i in (cdr a) collect (resolve-array i)))
			  (op (car a)))
		      (cl:ecase op
			(:invert
			  (cl:apply #'math:invert-matrix matrices))
			(:* (let ((val (math:multiply-matrices
					 (second matrices)
					 (first matrices))))
			      (loop for i in (cddr matrices) do
				(setq val (math:multiply-matrices i val)))
			      val))))))))
      (let* ((array (resolve-array array))
	     (named (named-fun name array in-names))
	     (inverse-named (when inverse-name
			      (named-fun inverse-name (math:invert-matrix array)
					 inv-in-names))))
	(if inverse-named
	    `(progn ,named ,inverse-named)
	    named))))

1;
;XYZ are the color primaries for the CIE 1931 color standard.
;these numbers obtained from 0Digital Image Processing1 by Pratt, p0.1 737
;
0(eval-when (compile load eval)
(defvar rgb->xyz-matrix (cl:make-array '(3 3)
				       :initial-contents
				       '((0.606  0.174 0.201)
					 (0.299  0.587 0.114)
					 (0 0.066  1.117 ))))
1;
;YIQ is the ntsc color coordinate system. 
;these numbers obtained from 0Digital Image Processing1 by Pratt, p0.1 737
;
0(defvar rgb->yiq-matrix (cl:make-array '(3 3)
				       :initial-contents
				       `((0.299 0.587 0.114)
					 (0.596 -0.274 -0.322)
					 (0.211 -0.523 0.321))))
1;
;UVW are a trnasform of XYZ so that equal distances in color space
;correspond to perceptually equal differences in color
0(defvar rgb->uvw-matrix (cl:make-array '(3 3)
				       :initial-contents
				      `(( 0.405   0.116   0.133 )
					( 0.299   0.587   0.114 )
					( 0.145   0.827   0.627 )))))

#||
;these already exist as explicit functions below, so leave them
;for strict compatibility
(def-transformation-function rgb->yiq
			     rgb->yiq-matrix
  :inverse-name yiq->rgb) ||#

(def-transformation-function rgb->xyz
			     rgb->xyz-matrix
  :inverse-name xyz->rgb)

(def-transformation-function rgb->uvw
			     rgb->uvw-matrix
  :inverse-name uvw->rgb)

(def-transformation-function xyz->yiq
			     (:* (:invert rgb->xyz-matrix) rgb->yiq-matrix)
  :inverse-name yiq->xyz)

(def-transformation-function xyz->uvw
			     (:* (:Invert rgb->xyz-matrix) rgb->uvw-matrix)
  :inverse-name uvw->xyz)

1;
;xyl is the chromaticity coordinate space defined by CIE 1931
;L is luminance, same as Y in the YUV coordinate space.  It also
;is meaningful for UVW space, which is a linear transform of XYZ
;
0(defun 2xyL->xyz 0(x y l)
  (values (* l (// x y))
	  l
	  (* (// (- 1 x y) y) l)))

(defun 2xyz->xyl0 (x y z)
  (values (// x (+ x y z))
	  (// y (+ x y z))
	  y))

(defun 2rgb->xyl0 (r g b)
  (multiple-value-bind (x y z) (rgb->xyz r g b)
    (xyz->xyl x y z)))

(defun 2xyl->rgb0 (x y l)
  (multiple-value-bind (x y z)
      (xyl->xyz x y l)
    (xyz->rgb x y z)))

(defun 2rgb->uvl0 (r g b)
  (multiple-value-bind (u v l) (rgb->uvw r g b)
    (xyz->xyl u v l)))

(defun 2uvl->rgb0 (u v l)
  (multiple-value-bind (u v w) (xyl->xyz u v l)
    (uvw->rgb u v w)))

(defun 2xyl->yiq0 (x y l)
  (multiple-value-bind (x y z) (xyl->xyz x y l)
    (xyz->yiq x y z)))

(defun 2yiq->xyl0 (y i q)
  (multiple-value-bind (x y z)(yiq->xyz y i q)
    (xyz->xyl x y z)))


(defmacro rgb-values (r g b &environment env)
  (once-only (r g b &environment env)
    `(values (if (< ,r 0.0)
		 0.0
		 (if (> ,r 1.0)
		     1.0
		     ,r))
	     (if (< ,g 0.0)
		 0.0
		 (if (> ,g 1.0)
		     1.0
		     ,g))
	     (if (< ,b 0.0)
		 0.0
		 (if (> ,b 1.0)
		     1.0
		     ,b)))))


;; hue is a number between 0.0 1.0
(defmacro rgb->ihs (r g b &environment env)
  (once-only (r g b &environment env)
    `(let* ((x (* *ihs-rgb-c1* (- (+ ,r ,r) ,b ,g)))
	    (y (* *ihs-rgb-c2* (- ,g ,b)))
	    (z (* *ihs-rgb-c3* (+ ,r ,g ,b)))
	    (q (+ (* x x) (* y y)))
	    (hh) (sat)
	    (int (sqrt (+ q (* z z)))))
       (cond ((zerop q)
	      (setq hh 0.0)
	      (setq sat 0.0))
	     (t
	      (setq hh (// (+ (atan2 y x) *pi-single-float*) (* *pi-single-float* 2.0)))
	      (setq hh (mod (+ hh .5) 1.0))
	      (setq sat
		    (let ((f (// z int)))
		      ;; rg claims this max is needed
		      ;; happen, but might as well leave it in. -- dlw 6/20/81
		      (atan2 (sqrt (max 0.0 (- 1.0 (* f f))))
			     f)))))
       (values int hh sat))))

(defmacro rgb->i (r g b &environment env)
  (once-only (r g b &environment env)
    `(sqrt (+ (* ,r ,r)(* ,g ,g)(* ,b ,b)))))

;;; returns multiple values r g b
(defmacro ihs->rgb (int hh sat &environment env)
  ;; figure out r, g, and b.
  (once-only (int hh sat &environment env)
    `(let* ((hh (mod (- ,hh .5) 1.0))
	    (hh (- (* hh 2.0 *pi-single-float*) *pi-single-float*))
	    (s3 (sin ,sat))
	    (z (* *ihs-rgb-c3* (cos ,sat) ,int))
	    (x (* *ihs-rgb-c1* s3 (cos hh) ,int))
	    (y (* *ihs-rgb-c2* s3 (sin hh) ,int)))
       (rgb-values (+ x x z) (+ y z (- x)) (- z x y)))))

#||
(defun test-rgb-ihs (&optional (step 0.1))
  (loop with max-error = 0
	for r from 0.001 below 1.0 by step
	do
    (loop for g from 0.001 below 1.0 by step do
      (loop for b from 0.001 below 1.0 by step do
	(multiple-value-bind (hr hg hb)
	    (rgb->ihs r g b)
	  (multiple-value-bind (nr ng nb)
	      (ihs->rgb hr hg hb)
	    (let* ((dr (abs (- nr r)))
		   (dg (abs (- ng g)))
		   (db (abs (- nb b))))
	      (setq max-error (max max-error dr dg db))
	      (when (or (> dr 0.0001)
			(> dg 0.0001)
			(> db 0.0001))
		(ferror "decode failed")))))))
    finally (return max-error)))
||#

(defmacro rgb->yiq (r g b &environment env)
  (once-only (r g b &environment env)
    `(values (+ (* .30 ,r) (* .59 ,g) (* .11 ,b))
	     (+ (* .60 ,r) (* -.28 ,g) (* -.32 ,b))
	     (+ (* .21 ,r) (* -.52 ,g) (* .31 ,b)))))

(defmacro yiq->rgb (y i q &environment env)
  (once-only (y i q &environment env)
    `(rgb-values (+ (* .948262244 ,i) (* .62401264 ,q) ,y)
		 (+ (* -.27606635 ,i) (* -.63981043 ,q) ,y)
		 (+ (* -1.10545024 ,i) (* 1.72985782 ,q) ,y))))

#||
(defun test-rgb-yiq (&optional (step 0.1))
  (loop with max-error = 0
	for r from 0.001 below 1.0 by step
	do
    (loop for g from 0.001 below 1.0 by step do
      (loop for b from 0.001 below 1.0 by step do
	(multiple-value-bind (hr hg hb)
	    (rgb->yiq r g b)
	  (multiple-value-bind (nr ng nb)
	      (yiq->rgb hr hg hb)
	    (let* ((dr (abs (- nr r)))
		   (dg (abs (- ng g)))
		   (db (abs (- nb b))))
	      (setq max-error (max max-error dr dg db))
	      (when (or (> dr 0.0001)
			(> dg 0.0001)
			(> db 0.0001))
		(ferror "decode failed")))))))
    finally (return max-error)))
||#

(defmacro rgb->yuv (r g b &environment env)
  (once-only (r g b &environment env)
    `(values (+ (* .299 ,r) (* .587 ,g) (* .114 ,b))
	     (+ (* -0.1686 ,r) (* -0.3311 ,g) (* 0.4997 ,b))
	     (+ (* .4998 ,r) (* -0.4185 ,g) (* -0.0813 ,b)))))

(defmacro yuv->rgb (y u v  &environment env)
  (once-only (y u v &environment env)
    `(values (+ (* 1.40257 ,v) ,y)
	     (+ (* -0.3443692 ,u) (* -0.7144071 ,v) ,y)
	     (+ (* 1.77306 ,u)  ,y)
	     )))


#||
;
;raw numbers from macsyma; two terms are nearly zero which we drop.
;they're 1supposed0 to be zero, but aren't becuase the original RGB->YUV
;matrix contains floating point approximations
(defmacro yuv->rgb (y u v  &environment env)
  (once-only (y u v &environment env)
    `(values (+ (* 5.973491e-5 ,u) (* 1.4025812 ,v) ,y)
	     (+ (* -0.3443692 ,u) (* -0.7144071 ,v) ,y)
	     (+ (* 1.7730427 ,u) (* -1.300364e-4 ,v) ,y)
	     )))

(defun test-rgb-yuv (&optional (step 0.1))
  (loop with max-error = 0 and maxr = 0 and maxg = 0 and maxb = 0
	for r from 0.001 below 1.0 by step
	do
    (loop for g from 0.001 below 1.0 by step do
      (loop for b from 0.001 below 1.0 by step do
	(multiple-value-bind (y u v)
	    (rgb->yuv r g b)
	  (multiple-value-bind (nr ng nb)
	      (yuv->rgb y u v)
	    (let* ((dr (abs (- nr r)))
		   (dg (abs (- ng g)))
		   (db (abs (- nb b))))
	      (setq max-error (max max-error dr dg db))
	      (setq maxr (max maxr dr))
	      (setq maxg (max maxg dg))
	      (setq maxb (max maxb db))
	      (when (or (> dr 0.0001)
			(> dg 0.0001)
			(> db 0.0001))
		(ferror "decode failed")))))))
    finally (return (values max-error maxr maxg maxb))))
||#

;;; from alvy ray smith, siggraph 1978
(defmacro rgb->hexcone-ihs (r g b &environment env)
  (once-only (r g b &environment env)
    `(if (and (zerop ,r) (zerop ,g) (zerop ,b))
	 (values 0.0 0.0 0.0)
	 (let* ((v (max ,r ,g ,b))
		(x (min ,r ,g ,b))
		(sat (// (- v x) v)))
	   (if (not (zerop sat))
	       (let* ((lr (// (- v ,r) (- v x)))
		      (lg (// (- v ,g) (- v x)))
		      (lb (// (- v ,b) (- v x)))
		      (hh (cond ((= ,r v)
				 (if (= ,g x) (+ 5 lb) (- 1 lg)))
				((= ,g v)
				 (if (= ,b x) (+ 1 lr) (- 3 lb)))
				(t
				 (if (= ,r x) (+ 3 lg) (- 5 lr))))))
		 (values v (// hh 6.0) sat))
	       (values v 0.0 0.0))))))

;;; from alvy ray smith, siggraph 1978
;;; reworked by ddyer 11/9/85, now is slightly faster
;;; and used common-lisp arithmetic
(defmacro hexcone-ihs->rgb (v h ss &environment env)
  (once-only (v h ss &environment env)
    `(multiple-value-bind (int f)
	 (floor (* 6 ,h))
       (let* ((m (* ,v (- 1 ,ss)))
	      (n (* ,v (- 1 (* ,ss (if (bit-test 1 int) f (- 1 f)))))))

	 (selector int =
	   (1 (values n ,v m))
	   (2 (values m ,v n))
	   (3 (values m n ,v))
	   (4 (values n m ,v))
	   (5 (values ,v m n))
	   (t (values ,v n m))
	   )))))

#||
;;
;; test routine for ihs-rgb-ihs
;;
(defun test-rgb-hexcone (&optional (step 0.1))
  (loop with max-error = 0
	for r from 0.001 below 1.0 by step
	do
    (loop for g from 0.001 below 1.0 by step do
      (loop for b from 0.001 below 1.0 by step do
	(multiple-value-bind (hr hg hb)
	    (rgb->hexcone-ihs r g b)
	  (multiple-value-bind (nr ng nb)
	      (hexcone-ihs->rgb hr hg hb)
	    (let* ((dr (abs (- nr r)))
		   (dg (abs (- ng g)))
		   (db (abs (- nb b))))
	      (setq max-error (max max-error dr dg db))
	      (when (or (> dr 0.001)
			(> dg 0.001)
			(> db 0.001))
		(ferror "decode failed")))))))
    finally (return max-error)))
||#

(defmacro rgb->hardware-rgb
	  (rr gg bb &optional (range 1023.99) (hmin 0.) &environment  env)
  (when (fixp range) (setq range (float range)))
  (once-only (rr gg bb range hmin &environment env)
    `(values (truncate (+ (* ,range ,rr) ,hmin))
	     (truncate (+ (* ,range ,gg) ,hmin))
	     (truncate (+ (* ,range ,bb) ,hmin)))))

(defmacro hardware-rgb->rgb
	  (hr hg hb &optional (hrange 1023.0) (hmin 0.) &environment env)
  (when (fixp hrange) (setq hrange (float hrange)))
  (once-only (hr hg hb hrange hmin &environment env)
    `(values (// (- ,hr ,hmin) ,hrange)
	     (// (- ,hg ,hmin) ,hrange)
	     (// (- ,hb ,hmin) ,hrange))))

(defmacro fixnum-rgb->i (r g b &environment env)
  ;; the modulus "99" is chosen so the largest intermediate values are still
  ;; fixnums, and so that the error is minimized.   This formulation seems to
  ;; have about 10% errors of +-1 from the floating point formulation
  (once-only (r g b &environment env)
    `(let* ((x (* #.(round (* 99. *ihs-rgb-c1*)) (- (+ ,r ,r) ,b ,g)))
	    (y (* #.(round (* 99. *ihs-rgb-c2*)) (- ,g ,b)))
	    (z (* #.(round (* 99. *ihs-rgb-c3*)) (+ ,r ,g ,b)))
	    (q (+ (* x x) (* y y))))
       (// (isqrt (+ q (* z z))) (round (* 99. (sqrt 3))))
       )))

#||
(defun test-rgb-hardware (&optional (step 0.1)(tolerance (// 1 1024.0)))

  (loop for i from 0 to 1023 do
    (multiple-value-bind (r g b) (hardware-rgb->rgb i i i)
      (multiple-value-bind (nr ng nb) (rgb->hardware-rgb r g b)
	(unless (and (= nr i)(= ng i)(= nb i))
	  (ferror "Encode/Decode failed ~A -> ~A,~A,~A -> ~A,~A,~A"
		  i r g b nr ng nb)))))
  
  (loop with max-error = 0
	for r from 0.001 below 1.0 by step
	do
    (loop for g from 0.001 below 1.0 by step do
      (loop for b from 0.001 below 1.0 by step do
	(multiple-value-bind (hr hg hb)
	    (rgb->hardware-rgb r g b)
	  (multiple-value-bind (nr ng nb)
	      (hardware-rgb->rgb hr hg hb)
	    (let* ((dr (abs (- nr r)))
		   (dg (abs (- ng g)))
		   (db (abs (- nb b))))
	      (setq max-error (max max-error dr dg db))
	      (when (or (> dr tolerance)
			(> dg tolerance)
			(> db tolerance))
		(ferror "decode failed, ~A,~A,~A -> ~A,~A,~A -> ~A,~A,~A  e=~A"
			r g b hr hg hb nr ng nb max-error
			)))))))
	finally (return max-error)))
||#

(eval-when (compile load eval)
(defconst *y-max* 1.0)
(defconst *y-min* 0.0)
(defconst *i-max* .60)
(defconst *i-min* -.60)
(defconst *q-max* .52)
(defconst *q-min* -.52)

(defconst *max-intensity*
	  (multiple-value-bind (i h s)
	      (rgb->ihs 1.0 1.0 1.0)
	    i))

(defconst *default-tolerance* .001)

(defun make-plist (thing)
  (if (not (listp thing))
      thing
      (cons nil
	    (loop for i in thing
		  collect (make-plist i)))))
);End EVAL-WHEN

(defmacro triple-byte (b &environment env)
  (once-only (b &environment env)
    `(dpb ,b (byte 8 16.) (dpb ,b (byte 8 8) ,b))))

(defmacro close-to-equal? (val1 val2 &optional (tolerance .001) &environment env)
  (once-only (val1 val2 tolerance &environment env)
    `(< (- ,val1 ,tolerance) ,val2 (+ ,val1 ,tolerance))))


;;;; Color objects

(defflavor basic-color-mixin ((time-stamp 0)) ()
  (:settable-instance-variables)
  (:method-combination
   :LIST-COLOR-SPACES (:LIST :MOST-SPECIFIC-LAST)
   :COLOR-INFO (:LIST :MOST-SPECIFIC-LAST)
   :EXPAND (:OR :MOST-SPECIFIC-LAST)
   :SPECIFIC-INTERPOLATE (:OR :MOST-SPECIFIC-LAST)
   :MULTIPLY (:CASE :MOST-SPECIFIC-LAST)
   :INTERPOLATE (:CASE :MOST-SPECIFIC-LAST)
   :SCALE (:CASE :MOST-SPECIFIC-LAST)
   :BASE-FLAVOR-LAST (:CASE :MOST-SPECIFIC-LAST)
   :MODEL-AS-LIST (:CASE :MOST-SPECIFIC-LAST)
   :RETURN-MODEL-LIST (:CASE :MOST-SPECIFIC-LAST)
   :SET-MODEL-AS-LIST (:CASE :MOST-SPECIFIC-LAST)
   :SET (:CASE :MOST-SPECIFIC-LAST)
   :SET-COMPONENT (:CASE :MOST-SPECIFIC-LAST)
   :CIRCULAR-INTERPOLATE (:CASE :MOST-SPECIFIC-LAST)
   :MAKE-DUPLICATE (:CASE :MOST-SPECIFIC-LAST)
   :COLORS-EQUAL? (:CASE :MOST-SPECIFIC-LAST)))

(defmethod (:specific-interpolate basic-color-mixin) (&rest ignore))

;;; ***** for debugging******
(defmethod (:print basic-color-mixin) (space)
  (multiple-value-bind (a b c)
    (send self space)
    (print (list a b c))))

(defmethod (:color-components-equal? basic-color-mixin) 
		      (other-color component-message &optional (*tolerance* .001))
  (close-to-equal? (send self component-message)
		   (send other-color component-message)
		   *tolerance*))

(defmethod (:update basic-color-mixin) ()
  nil)

(defmethod (:init basic-color-mixin) (ignore)
  )

(defmacro define-color-object-flavor (short-name definition-plist &aux ans)
  (setq ans nil)
  (setq definition-plist (make-plist (eval definition-plist)))
  (let* ((mixin-name (intern (string-append (string short-name) "-MIXIN")))
	 (valid-var (intern (string-append (string short-name) "-VALID")))
	 (validate-message (intern (string-append "VALIDATE-" (string short-name))
				   'keyword))
	 (to-message (intern (string-append "TO-" (string short-name)) 'keyword))
	 (vars-get-message (intern (string short-name) 'keyword))
	 (vars-set-message (intern (string-append "SET-" (string short-name)) 'keyword))
	 (var-list (plist (get definition-plist :components)))
	 (parameter-list (loop for l in var-list do (ignore l) collect (gensym)))
	 (parameter-list2 (loop for l in var-list do (ignore l) collect (gensym)))
	 (scaling-list (loop for p in parameter-list
			     collect `(* ,p *scale-factor*)))
	 (multiply-list (loop for p1 in parameter-list
			      for p2 in parameter-list2
			      collect (list '* p1 p2)))
	 (equality-list (loop for p1 in parameter-list
			      for p2 in parameter-list2
			      collect `(close-to-equal? ,p1 ,p2 *tolerance*) into a
			      finally (return (cons 'and a))))
	 (interpolate-list (loop for p1 in parameter-list
				 for p2 in parameter-list2
				 collect `(+ ,p1 (* (- ,p2 ,p1) *scale-factor*))))
	 (var-init-list (loop for var in var-list collect (list var 0.0)))
	 (setq-list
	   (loop for parm in parameter-list
		 for var in var-list
		 collect var into answer
		 collect parm into answer
		 finally (return (cons 'setq answer))))
	 (message-list (loop for var in var-list
			     collect (list var (intern (string var) 'keyword)
					   (intern (string-append "SET-"	(string var))
						   'keyword)))))
    
    (putprop definition-plist vars-get-message :color-space)
    (putprop definition-plist vars-set-message :set-method)
    (putprop definition-plist valid-var :validation-variable)
    (putprop definition-plist to-message :to-message)
    (putprop mixin-name definition-plist :color-object-information)
    
    (dolist (var message-list)
      (if (null (get definition-plist (second var)))
	  (putprop definition-plist (ncons nil) (second var)))
      (putprop (get definition-plist (second var)) (second var) ':access-method)
      (putprop (get definition-plist (second var)) (third var) ':set-method)
      )
;      (putprop (get definition-plist (second var)) (first var) ':name))
    
    (putprop definition-plist (loop for i in message-list collect (second i)) :dimensions)
    
    (dolist (var message-list)
      ;; define the :set-red type messages
      (push `(defmethod (,(third var) ,mixin-name ) (value)
	       (if (neq ,valid-var time-stamp)
		   (send self ,validate-message))
	       (setq ,(first var) value)
	       (setq ,valid-var (incf time-stamp))
	       self)
	    ans)
      
      ;; define the :set-component :red type messages
      (push `(defmethod (:set-component ,mixin-name #m:case ,(second var)  ) (value)
	       (cond ((neq ,valid-var time-stamp)
		      (send self ,validate-message)))
	       (setq ,(first var) value)
	       (setq ,valid-var (incf time-stamp))
	       self)
	    ans)
      
      ;; define the :red type messages
      (push `(defmethod (,(second var) ,mixin-name) ()
	       (if (neq ,valid-var time-stamp)
		   (send self ,validate-message))
	       ,(first var))
	    ans))
    
    ;; returns a propertyish-list
    (push `(defmethod (:color-info ,mixin-name) ()
	     (quote ,(list vars-get-message definition-plist)))
	  ans)
    
    ;; returns a list like (:ihs :rgb :yiq)
    (push `(defmethod (:list-color-spaces ,mixin-name) ()
	     ,(list 'quote vars-get-message))
	  ans)
    
    (push `(defmethod ( :colors-equal?  ,mixin-name #m:case ,vars-get-message )
		      (other-color &optional (*tolerance* .001))
	     (multiple-value-bind ,parameter-list
		 (send self ,vars-get-message)
	       (multiple-value-bind ,parameter-list2
		   (send other-color ,vars-get-message)
		 ,equality-list)))
	  ans)
    
    (push `(defmethod (  :multiply ,mixin-name #m:case ,vars-get-message)
		      (other-color &optional output-color)	
	     (if (not output-color)
		 (setq output-color (make-instance (typep self))))
	     (multiple-value-bind ,parameter-list
		 (send self ,vars-get-message)
	       (multiple-value-bind ,parameter-list2
		   (send other-color ,vars-get-message)
		 (send output-color ,vars-set-message ,@multiply-list)))
	     output-color)
	  ans)

    (push `(defmethod ( :make-duplicate  ,mixin-name #m:case ,vars-get-message)
		      (&optional output-color)	
	     (if (not output-color)
		 (setq output-color (make-instance (typep self))))
	     (multiple-value-bind ,parameter-list
		 (send self ,vars-get-message)
	       (send output-color ,vars-set-message ,@parameter-list))
	     output-color)
	  ans)
    
    
    (push `(defmethod ( :interpolate ,mixin-name #m:case ,vars-get-message)
		      (other-color *scale-factor* &optional output-color short-route?)
	     (or (send self :send-if-handles :specific-interpolate ,vars-get-message
		       other-color *scale-factor* output-color short-route?)
		 (progn
		   (if (not output-color)
		       (setq output-color (make-instance (typep self))))
		   (multiple-value-bind ,parameter-list
		       (send self ,vars-get-message)
		     (multiple-value-bind ,parameter-list2
			 (send other-color ,vars-get-message)
		       (send output-color ,vars-set-message ,@interpolate-list)))
		   output-color)))
	     ans)
    
    ;; *scale-factor* used in loop preamble above
    (push `(defmethod ( :scale  ,mixin-name #m:case ,vars-get-message )
		      (*scale-factor* &optional output-color)
	     (if (not output-color)
		 (setq output-color (make-instance (typep self))))
	     (multiple-value-bind ,parameter-list
		 (send self ,vars-get-message)
	       (send output-color ,vars-set-message ,@scaling-list))
	     output-color)
	  ans)
    
    (push `(defmethod (:set  ,mixin-name #m:case ,vars-get-message ) ,parameter-list
	     (cond ((neq ,valid-var time-stamp)
		    (send self ,validate-message)))
	     ,setq-list
	     (setq ,valid-var (incf time-stamp)))
	  ans)
    
    ;; define :set-rgb type messages
    (push `(defmethod (,vars-set-message ,mixin-name) ,parameter-list
	     (cond ((neq ,valid-var time-stamp)
		    (send self ,validate-message)))
	     ,setq-list
	     (setq ,valid-var (incf time-stamp))
	     self)
	  ans)
    
    ;; define :rgb type messages
    (push `(defmethod (,vars-get-message ,mixin-name ) ()
	     (cond ((neq ,valid-var time-stamp)
		    (send self ,validate-message)))
	     (values ,@var-list))
	  ans)
    
    ;; define :validate-rgb type messages
    (push `(defmethod (,validate-message ,mixin-name) ()
	     (let ((message (send self ,to-message)))
	       (cond (message
		      (setq ,valid-var time-stamp)
		      (multiple-value ,var-list
			(send self message)))
		     (t
		      (send self :expand)
		      (send self ,validate-message)))))
	  ans)
    
    ;; to update all mixins
    (push `(defmethod (:update ,mixin-name :after ) ()
	     (send self ,vars-get-message))
	  ans)
    
    (push `(defmethod (:expand ,mixin-name) ()
	     (if (neq ,valid-var time-stamp)
		 (let ((message (send self ,to-message)))
		   (cond (message
			  (setq ,valid-var time-stamp)
			  (multiple-value ,var-list
			    (send self message)))))))
	  ans)
    
    (push `(defmethod (:init ,mixin-name :after) (plist)
	     (loop for messages in ',message-list
		   for message = (second messages)
		   for value = (get plist message)
		   do
		   (if value
		       (send self :set-component message value)))
	     (let* ((color-space ,vars-get-message)
		    (me self)
		    (values (get plist ,vars-get-message)))
	       (if values
		   (eval `(send ',me :set ,color-space ,@values)))))	
	  ans)

    ;;; define the flavor itself
    (push `(defflavor ,mixin-name
		   ((,valid-var 0)
		    ,@var-init-list)
		   ()
	     (:required-flavors basic-color-mixin)
	     (:init-keywords ,@(loop for messages in message-list
				     collect (second messages) into ans
				     finally (return (cons vars-get-message ans))))
	     (:method-combination ,to-message (:or :most-specific-last))
	     )
	  ans))
  
  (append '(progn 'compile) ans))

(defun colors-equal?
       (color-a color-b access-message &optional (tolerance *default-tolerance*))
  (send color-a :colors-equal? access-message color-b tolerance))

(defun interpolate-colors
       (color1 color2 access-method &optional color-out (factor .5) short-route?)
  (send color1 :interpolate access-method color2 factor color-out short-route?))

(defun multiply-colors
       (color1 color2 access-method &optional color-out)
  (send color1 :multiply access-method color2 color-out))

(defun duplicate-color (old-color access-method &optional new-color)
  (send old-color :make-duplicate access-method new-color))

;; sets up the methods for the transformations from one color space to another
(defmacro define-translation
	  (space1 space2  &aux mixin1 mixin2 def1 def2 message1->2 message2->1
	   valid1 valid2 to1 to2 components1 components2 mac1->2 mac2->1)
  (setq mixin1 (intern (string-append (string space1) "-MIXIN"))) 
  (setq mixin2 (intern (string-append (string space2) "-MIXIN"))) 
  (setq def1 (get mixin1 :color-object-information))
  (setq def2 (get mixin2 :color-object-information))
  (setq valid1 (get def1 :validation-variable))
  (setq valid2 (get def2 :validation-variable))
  (setq to1 (get def1 :to-message))
  (setq to2 (get def2 :to-message))
  (setq components1 (cdr (get def1 :components)))
  (setq components2 (cdr (get def2 :components)))

  (setq message1->2
	(intern (string-append (string space1) "->" (string space2)) 'keyword))
  (setq message2->1
	(intern (string-append (string space2) "->" (string space1)) 'keyword))
  (setq mac1->2 (intern (string message1->2)))
  (setq mac2->1 (intern (string message2->1)))
  `(progn 'compile
	  (defmethod (,to2 ,mixin1) () (if (eq ,valid1 time-stamp) ,message1->2))
	  (defmethod (,to1 ,mixin2) () (if (eq ,valid2 time-stamp) ,message2->1))
	  (defmethod (,message1->2 ,mixin1) () (,mac1->2 ,@components1))
	  (defmethod (,message2->1 ,mixin2) () (,mac2->1 ,@components2))))

;;; yiq-mixin
(define-color-object-flavor yiq
			    `(:components (y i q)
			      :y (:min ,*y-min* :max ,*y-max* :name "Y")
			      :i (:min ,*i-min* :max ,*i-max* :name "I")
			      :q (:min ,*q-min* :max ,*q-max* :name "Q")))
	  
;;; ihs-mixin
(define-color-object-flavor ihs
			    `(:components (intensity hue saturation)
			      :intensity (:min 0.0 :max ,*max-intensity* :name "Intensity"
					 :nickname "Int")
			      :hue (:min 0.0 :max 1.0 :name "Hue" :nickname "Hue"
					 :circular t)
			      :saturation (:min 0.0 :max 1.0 :name "Saturation"
					   :nickname "Sat")))

;;; hexcone-ihs mixin
(define-color-object-flavor hexcone-ihs
			    '(:components (hexcone-intensity hexcone-hue hexcone-saturation)
			      :hexcone-hue (:min 0.0 :max 1.0 :name "Hexcone-hue"
					    :nickname "H-Hue")
			      :hexcone-saturation (:min 0.0 :max 1.0
						   :name "Hexcone-saturation"
						   :Nickname "H-Sat")
			      :hexcone-intensity (:min 0.0 :max 1.0 :name "Hexcone-intensity"
						  :nickname "H-Int")
			      ))

(defmacro cmy->rgb (c m y &environment env)
  (once-only (c m y &environment env)
    `(values (- 1.0 ,c) (- 1.0 ,m) (- 1.0 ,y))))

(defmacro rgb->cmy (r g b &environment env)
  (once-only (r g b &environment env)
    `(values (- 1.0 ,r) (- 1.0 ,g) (- 1.0 ,b))))

;;; cmy mixin
(define-color-object-flavor cmy '(:components (cyan magenta yellow)
				  :cyan (:min 0.0 :max 1.0 :name "Cyan")
				  :magenta (:min 0.0 :max 1.0 :name "Magenta")
				  :yellow (:min 0.0 :max 1.0 :name "Yellow")))

;;; rgb mixin
(define-color-object-flavor rgb '(:components (red green blue)
				  :red (:min 0.0 :max 1.0 :name "Red")
				  :green (:min 0.0 :max 1.0 :name "Green")
				  :blue (:min 0.0 :max 1.0 :name "Blue")))

;;; define the translations between the color spaces defined
(define-translation rgb yiq)

(define-translation rgb hexcone-ihs)

(define-translation rgb ihs)

(define-translation rgb cmy)

;(defun show-cos ()
;  (terpri)
;  (format t "co:~a ~a ~a ~%" (send co :intensity) (send co :hue) (send co :saturation))
;  (format t "sc:~a ~a ~a ~%" (send sc :intensity) (send sc :hue) (send sc :saturation))
;  (format t "ans:~a ~a ~a ~%" (send ans :intensity) (send ans :hue) (send ans :saturation)))


(defconst *low-saturation-threshold* .01)

;; ihs has circular interpolation and deals with zero saturation singularities
(defmethod (:specific-interpolate ihs-mixin)
	   (color-space other-color scale-factor &optional output-color short-route?)
  (when (eq color-space :ihs)
    (if (not output-color)
	(setq output-color (make-instance (typep self))))
    ;; when saturation is very low, set hues
    (when (< (send self :saturation) *low-saturation-threshold*)
      (send self :set-hue (send other-color :hue)))
    (when (< (send other-color :saturation) *low-saturation-threshold*)
      (send other-color :set-hue (send self :hue)))
    (multiple-value-bind (i1 h1 s1)
	(send self :ihs)
      (multiple-value-bind (i2 h2 s2)
	  (send other-color :ihs)
	(send output-color :set-ihs
	      (+ i1 (* (- i2 i1) scale-factor))
	      (if short-route?
		  (let* ((dh (abs (- h2 h1)))
			 (other-way? (> dh .5)))
		    (mod (+ (if other-way? (max h1 h2) (min h1 h2))
			    (* (if other-way? (- 1.0 dh) dh)
			       (if (or (and other-way? (eq h1 (min h1 h2)))
				       (and (not other-way?) (eq h2 (min h1 h2))))
				   (- 1.0 scale-factor)
				   scale-factor)))
			 1.0))
		  (+ h1 (* (- h2 h1) scale-factor)))
	      (+ s1 (* (- s2 s1) scale-factor)))))
    output-color))

(defmethod (:specific-interpolate hexcone-ihs-mixin)
	   (color-space other-color scale-factor &optional output-color short-route?)
  (when (eq color-space :hexcone-ihs)
    (if (not output-color)
	(setq output-color (make-instance (typep self))))
    ;; when saturation is very low, set hues
    (when (< (send self :hexcone-saturation) *low-saturation-threshold*)
      (send self :set-hue (send other-color :hue)))
    (when (< (send other-color :hexcone-saturation) *low-saturation-threshold*)
      (send other-color :set-hue (send self :hue)))
    (multiple-value-bind (i1 h1 s1)
	(send self :hexcone-ihs)
      (multiple-value-bind (i2 h2 s2)
	  (send other-color :hexcone-ihs)
	(send output-color :set-hexcone-ihs
	      (+ i1 (* (- i2 i1) scale-factor))
	      (if short-route?
		  (let* ((dh (abs (- h2 h1)))
			 (other-way? (> dh .5)))
		    (mod (+ (if other-way? (max h1 h2) (min h1 h2))
			    (* (if other-way? (- 1.0 dh) dh)
			       (if (or (and other-way? (eq h1 (min h1 h2)))
				       (and (not other-way?) (eq h2 (min h1 h2))))
				   (- 1.0 scale-factor)
				   scale-factor)))
			 1.0))
		  (+ h1 (* (- h2 h1) scale-factor)))
	      (+ s1 (* (- s2 s1) scale-factor)))))
    output-color))

(defmethod  (:print-self rgb-mixin)  (stream &rest ignore)
  (si:printing-random-object  (self stream :no-pointer)
    (format stream
	    "color~@[ ~a~] ~a"
	    (if (send self :send-if-handles :name)
		(send self :name)
		"")
	    (send self :rgb-percentage-string))))

(defmethod  (:rgb-percentage-string rgb-mixin) ()
  (format nil
	  "r=~d% g=~d% b=~d%"
	  (fixr (* (send self :red) 100))
	  (fixr (* (send self :green) 100))
	  (fixr (* (send self :blue) 100))))

(defflavor combined-ihs-mixin () (ihs-mixin hexcone-ihs-mixin))

(defmethod (:set-hue combined-ihs-mixin) (h)
  (cond ((and (neq ihs-valid time-stamp) (neq hexcone-ihs-valid time-stamp))
	 (send self :validate-ihs)		;make model updated selectable
	 (setq ihs-valid (incf time-stamp)))
	;; if both are valid, both should stay valid
	((and (eq ihs-valid time-stamp) (eq hexcone-ihs-valid time-stamp))
	 (setq ihs-valid (setq hexcone-ihs-valid (incf time-stamp))))
	((and (eq ihs-valid time-stamp) (neq hexcone-ihs-valid time-stamp))
	 (setq ihs-valid (incf time-stamp)))
	((and (neq ihs-valid time-stamp) (eq hexcone-ihs-valid time-stamp))
	 (setq hexcone-ihs-valid (incf time-stamp))))
  (setq hexcone-hue (setq hue h)))

(defmethod (:hue combined-ihs-mixin) ()
  (cond ((eq ihs-valid time-stamp)
	 hue)
	((eq hexcone-ihs-valid time-stamp)
	 hexcone-hue)
	(t (send self :validate-ihs)
	   hue)))

(defflavor color-name-mixin (color-name) ()
  (:settable-instance-variables))

(defflavor standard-color ()
	   (basic-color-mixin rgb-mixin combined-ihs-mixin yiq-mixin))

(defmethod (:interpolation-by-numerical-components standard-color)
	   (interpolation-function)
 (make-standard-color :rgb
		      (funcall interpolation-function #'(lambda (c) (send c :red)))
		      (funcall interpolation-function #'(lambda (c) (send c :green)))
		      (funcall interpolation-function #'(lambda (c) (send c :blue)))))

(defun hue-name (h)
  (cond ((< h .08) "Red")
	((< h .13) "Orange")
	((< h .15) "Gold")
	((< h .18) "Yellow")
	((< h .3) "Yellowish-green")
	((< h .46) "Green")
	((< h .54) "Cyan")
	((< h .69) "Blue")
;	((< h .76) "Royal-blue")
	((< h .833) "Purple")
	((< h .915) "Magenta")
	((< h .954) "Rose")
	(t "Red")))

(defun saturation-name (s)
  (cond ((< s .1) "Very De-saturated ")
	((< s .35) "De-saturated ")
	((< s .65) "")
	((< s .8) "")
	(t "")))

(defun grayscale-name (i)
  (cond ((< i .1) "Black")
	((< i .3) "Black-Gray")
	((< i .4) "Very Dark Gray")
	((< i .5) "Dark Gray")
	((< i .6) "Middle Gray")
	((< i .8) "Bright Gray")
	((< i .9) "Very Bright Gray")
	(t "White")))

(defun intensity-name (i)
  (cond ((< i .2) "Very Dark ")
	((< i .35) "Dark ")
	((< i .7) "")
	((< i .85) "")
	(t "")))

(defmethod (:name combined-ihs-mixin) ()
  (let ((i (// (send self :intensity) 1.7))
	(h (send self :hue))
	(s (send self :saturation))
	ii hh ss)
    (setq ii (intensity-name i))
    (setq ss (saturation-name s))
    (setq hh (hue-name h))
    (cond ((< s .02)
	   (grayscale-name i))
	  ((and (< 0.0 h .1) (< i .39))
	   (string-append ii ss "Brown"))
	  (t (string-append ii ss hh)))))

(defmethod (:make-name color-name-mixin) ()
  nil)

;;; compute alu data from object and window
(defun hardware-rgb (window color-object)
  (multiple-value-bind (r g b)
      (send color-object :rgb)
    (send (send window :screen) ':compute-rgb-dat r g b)))

(defmethod (:alu-for-window standard-color) (window)
  (sc-fill-alu (hardware-rgb window self) -1))

(defmethod (:fasd-form rgb-mixin) ()
  (multiple-value-bind (r g b) (send self :rgb)
    `(make-standard-color :rgb ,r ,g ,b)))


(compile-flavor-methods standard-color)

(defun make-standard-color (&optional color-space &rest value-list)
  (if (and color-space value-list)
      (if (listp (car value-list))
	  (make-instance 'standard-color color-space (car value-list))
	  (make-instance 'standard-color color-space value-list))
      (make-instance 'standard-color)))

(defconst sample-color (make-standard-color))


;;;; Color constants

(defconst  *black*  	   (make-standard-color :rgb 0   0   0))
(defconst  *white*         (make-standard-color :rgb  1   1   1))
(defconst  *red*           (make-standard-color :rgb  1   0   0))
(defconst  *red-yellow*    (make-standard-color :rgb  1   .5  0))
(defconst  *yellow*        (make-standard-color :rgb  1   1   0))
(defconst  *yellow-green*  (make-standard-color :rgb  .5  1   0))
(defconst  *green*         (make-standard-color :rgb  0   1   0))
(defconst  *green-cyan*    (make-standard-color :rgb  0   1   .5))
(defconst  *cyan*          (make-standard-color :rgb  0   1   1))
(defconst  *cyan-blue*     (make-standard-color :rgb  0   .5  1))
(defconst  *blue*          (make-standard-color :rgb  0   0   1))
(defconst  *blue-magenta*  (make-standard-color :rgb  .5  0   1))
(defconst  *magenta*       (make-standard-color :rgb  1   0   1))
(defconst  *magenta-red*   (make-standard-color :rgb  1   0   .5))

(defun color-spec->rgb (color-spec)
  (typecase color-spec
    (:symbol
      (selectq color-spec
	(:black (values 0.0 0.0 0.0))
	(:red (values 1.0 0.0 0.0))
	(:green (values 0.0 1.0 0.0))
	(:blue (values 0.0 0.0 1.0))
	(:cyan (values 0.0 1.0 1.0))
	(:yellow (values 1.0 1.0 0.0))
	(:magenta (values 1.0 0.0 1.0))
	(:white (values 1.0 1.0 1.0))
	((nil :transparent) nil)
	(t (ferror "~a isn't a color spec symbol" color-spec))))
    (:list
      (values (pop color-spec) (pop color-spec) (pop color-spec)))
    (:instance
      (send color-spec :rgb))
    (otherwise (ferror "~a isn't a color spec" color-spec))))

;;;; Synonyms 

;;; This is a minimal set.
;;; There could also be ones for all the -> things using -to-, I suppose.

(defun make-color (&rest args)
  (declare (arglist (&key red blue green intensity hue saturation &allow-other-keys)))
  (lexpr-funcall #'make-instance 'standard-color args))

(defun colorp (thing)
  (typep thing 'basic-color-mixin))

(defun color-name (color)
  (send color :name))

(defun name-color (name)
  (multiple-value-bind (r g b)
      (color-rgb name)
    (make-standard-color :rgb r g b)))

(defun color-rgb (color)
  (color-spec->rgb color))

(defun color-red (color)
  (multiple-value-bind (r g b)
      (color-spec->rgb color)
    (ignore g b)
    r))

(defun color-green (color)
  (multiple-value-bind (r g b)
      (color-spec->rgb color)
    (ignore r b)
    g))

(defun color-blue (color)
  (multiple-value-bind (r g b)
      (color-spec->rgb color)
    (ignore r g)
    b))

(defun color-intensity (color)
  (multiple-value-bind (r g b)
      (color-spec->rgb color)
    (rgb->i r g b)))

(defun color-ihs (color)
  (multiple-value-bind (r g b)
      (color-spec->rgb color)
    (rgb->ihs r g b)))

(defun color-hue (color)
  (multiple-value-bind (i h s)
      (color-ihs color)
    (ignore i s)
    h))

(defun color-saturation (color)
  (multiple-value-bind (i h s)
      (color-ihs color)
    (ignore i h)
    s))

;;;; Some other color stuff needed without color loaded

(defgeneric color-stream-p (&optional (stream cl:*standard-output*))
  (:function (funcall (flavor:generic color-stream-p) (si:follow-syn-stream stream)))
  (:method-arglist )
  (:method (si:output-stream)
   (let ((screen (send-if-handles self :screen)))
     (and screen (%screen-inferior-color-p screen self)))))

(defmethod (%screen-inferior-color-p tv:basic-screen :default) (ignore)
  (and (send-if-handles self :color-map) :local))

(cl:deftype color ()
  `(cli::instance basic-color-mixin))

(define-presentation-type color ()
   :no-deftype t
   :parser ((stream)
	    (let ((name (dw:complete-from-sequence '(:black :red :green :blue :cyan :yellow
						     :magenta :white)
						   stream :name-key #'cl:string-capitalize)))
	      (name-color name)))
   :printer ((color stream)
	     (cl:write-string (color-name color) stream)))

(defun color-alu-for-window (color window &optional (alu :draw))
  (multiple-value-bind (r g b)
      (color-spec->rgb color)
    (send (send window :screen) :compute-rgb-alu
	  (graphics::standardize-alu window alu) r g b)))
