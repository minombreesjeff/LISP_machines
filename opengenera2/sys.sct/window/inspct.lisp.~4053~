;;; -*- Mode: LISP; Package: TV; Base: 8; Syntax: Zetalisp -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Inspect structures

(DEFSTRUCT (INSPECTOR-STACK-FRAME :NAMED (:CONC-NAME STACK-FRAME-))
  FRAME
  LABEL
  PC)

(DEFSELECT ((:PROPERTY INSPECTOR-STACK-FRAME NAMED-STRUCTURE-INVOKE))
  (:PRINT-SELF (SF STREAM &REST IGNORE &AUX (FRAME (STACK-FRAME-FRAME SF))
					    (PC (STACK-FRAME-PC SF)))
   (LET ((PRINLENGTH 5) (PRINLEVEL 3))
     (PRINTING-RANDOM-OBJECT (SF STREAM :NO-POINTER)
       (FORMAT STREAM "Stack-Frame ~A ~[PC=~O~;microcoded~;interpreted~]"
	       (FUNCTION-NAME (FRAME-FUNCTION FRAME))
	       (COND (PC 0)
		     #+cadr ((TYPEP (FRAME-FUNCTION FRAME) ':MICROCODE-FUNCTION) 1)
		     (T 2))
	       PC)))))

(DEFSTRUCT (FLAVOR-MESSAGE-HANDLER :NAMED :CONC-NAME)
  FLAVOR
  HANDLER)

(DEFSELECT ((:PROPERTY FLAVOR-MESSAGE-HANDLER NAMED-STRUCTURE-INVOKE))
  (:PRINT-SELF (FMH STREAM &REST IGNORE)
   (PRINTING-RANDOM-OBJECT (FMH STREAM :NO-POINTER)
     (FORMAT STREAM "Message handler for ~S" (FLAVOR-MESSAGE-HANDLER-FLAVOR FMH)))))


(DEFFLAVOR INSPECT-WINDOW ()
	   (BASIC-INSPECT
	    ANY-MOUSE-BUTTONS-TEXT-SCROLL-WINDOW-MIXIN
	    FUNCTION-TEXT-SCROLL-WINDOW MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW
	    MARGIN-SCROLLING-WITH-FLASHY-SCROLLING-MIXIN
	    DONT-SELECT-WITH-MOUSE-MIXIN BORDERS-MIXIN
	    MARGIN-SCROLL-MIXIN MARGIN-REGION-MIXIN
	    FLASHY-SCROLLING-MIXIN		;must be after the two margin mixins
	    TOP-LABEL-MIXIN BASIC-SCROLL-BAR WINDOW)
  (:DEFAULT-INIT-PLIST :MARGIN-SCROLL-REGIONS '((:TOP "Top of object")
						(:BOTTOM "Bottom of object"))
		       :FLASHY-SCROLLING-REGION '((20 0.40s0 0.60s0)
						  (20 0.40s0 0.60s0))
		       :LABEL (LIST NIL NIL NIL NIL (SI:PARSE-CHARACTER-STYLE
						      '(:SANS-SERIF :BOLD :NORMAL))
				    "Empty"))
  (:DOCUMENTATION :COMBINATION "Scroll window for the inspector."))

;;; This flavor should be in SCROLL somewhere
(DEFFLAVOR ANY-MOUSE-BUTTONS-TEXT-SCROLL-WINDOW-MIXIN
	((SINGLE-RIGHT-MENU NIL))		;Menu for single-click-right
	()
  (:REQUIRED-FLAVORS MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW)
  :INITABLE-INSTANCE-VARIABLES
  :SETTABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:MOUSE-CLICK ANY-MOUSE-BUTTONS-TEXT-SCROLL-WINDOW-MIXIN) (BUTTON X Y)
  X Y ;not used
  (COND ((AND (CHAR-MOUSE-EQUAL BUTTON #\MOUSE-3-1) SINGLE-RIGHT-MENU)
	 (PROCESS-RUN-FUNCTION "Menu Choose"
			       #'(LAMBDA (US BUTTON MENU &AUX CHOICE)
				   (SETQ CHOICE (SEND MENU ':CHOOSE))
				   (AND CHOICE
					(SEND US ':FORCE-KBD-INPUT
					      (LIST ':MENU CHOICE BUTTON US))))
			       SELF BUTTON SINGLE-RIGHT-MENU)
	 T)))


(DEFFLAVOR BASIC-INSPECT ((CURRENT-OBJECT (NCONS NIL))
			  (CURRENT-DISPLAY NIL)
			  ;; For list structure hacking
			  (DISPLAYING-LIST NIL)
			  (MODIFY-MODE NIL)
			  LIST-BLINKER DOCUMENTATION-STRINGS)
	   (MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW)
  :SETTABLE-INSTANCE-VARIABLES
  (:GETTABLE-INSTANCE-VARIABLES MODIFY-MODE)
  (:INIT-KEYWORDS :BUTTON-DOCUMENTATION))

(DEFMETHOD (:SENSITIVE-ITEM-P BASIC-INSPECT) (ITEM &AUX (TYPE (DISPLAYED-ITEM-TYPE ITEM)))
  (IF MODIFY-MODE
      (GET TYPE 'SET-FUNCTION)
      (NULL (GET TYPE 'ONLY-WHEN-MODIFY))))

(DEFMETHOD (:INIT BASIC-INSPECT :AFTER) (PLIST)
  (LET ((DOC (OR (GET PLIST ':BUTTON-DOCUMENTATION)
		 '("Right finds function definition."))))
    (SETQ DOCUMENTATION-STRINGS
	  (LIST (STRING-APPEND "Choose a CAR to be modified.  " (OR (SECOND DOC) ""))
		(STRING-APPEND "Choose a CAR.  " (OR (FIRST DOC) ""))
		(STRING-APPEND 	"Choose a slot to be modified, by pointing at the slot.  "
				(OR (SECOND DOC) ""))
		(STRING-APPEND "Choose a value by pointing at the value.  "
			       (OR (FIRST DOC) "")))))
  (SETQ LIST-BLINKER (MAKE-BLINKER SELF 'FOLLOW-LIST-STRUCTURE-BLINKER ':VISIBILITY NIL)
	SENSITIVE-ITEM-TYPES ':SENSITIVE-ITEM-P))

(DEFMETHOD (:WHO-LINE-DOCUMENTATION-STRING BASIC-INSPECT) ()
  (NTH (IF DISPLAYING-LIST (IF MODIFY-MODE 0 1) (IF MODIFY-MODE 2 3)) DOCUMENTATION-STRINGS))


;;--- This function embodies a design insufficiency.  When an object is a malformed
;;--- example of some type, the :OBJECT- message can throw to INSPECT-REAL-OBJECT.
;;--- similiarly, if it believes that the inspect method for some other type would
;;--- do a better job, it can throw to INSPECT-FORCE-TYPE.  In neither of these cases,
;;--- though, will the display give any hint of the fact that there is something
;;--- unusual going on.  If the :OBJECT- handler for a FOO throws to direct the inspector
;;--- to display FOO-INTERNAL instead, the header in the display pane will talk of 
;;--- FOO-INTERNAL, and not mention FOO at all.  There is also no graceful support
;;--- for an object that fails the TYPECASE in here. --BIM

(DEFUN INSPECT-SETUP-OBJECT-DISPLAY-LIST (OBJECT WINDOW &OPTIONAL TOP-ITEM LABEL
					  &AUX DISPLAY-LIST ARG STR ALT-PRINT-FUN
					  FIRST-TOP-ITEM OBJ-LABEL
					  (OOBJECT OBJECT))
  (MACROLET ((INSPECT-DATA-TYPE
		(TYPE)
	       `(MULTIPLE-VALUE (DISPLAY-LIST ARG ALT-PRINT-FUN FIRST-TOP-ITEM OBJ-LABEL)
		  (SEND WINDOW
			,(INTERN (STRING-APPEND "OBJECT-" TYPE) SI:PKG-KEYWORD-PACKAGE)
			OBJECT))))
    (FLET ((INSPECT-TYPECASE ()
	     (CL:TYPECASE OBJECT
	       (INSPECTOR-STACK-FRAME (INSPECT-DATA-TYPE STACK-FRAME))
	       (FLAVOR-MESSAGE-HANDLER
		 (INSPECT-DATA-TYPE FLAVOR-MESSAGE-HANDLER))
	       (SI:BASIC-HASH-TABLE
		 (INSPECT-DATA-TYPE BASIC-HASH-TABLE))
	       (CLI::BASIC-TABLE (INSPECT-DATA-TYPE TABLE))
	       (SCL:STRUCTURE (INSPECT-DATA-TYPE NAMED-STRUCTURE))
	       (SCL:INSTANCE (INSPECT-DATA-TYPE INSTANCE))
	       (SCL:ARRAY (INSPECT-DATA-TYPE ARRAY))
	       (LIST (INSPECT-DATA-TYPE LIST))
	       (SYMBOL (INSPECT-DATA-TYPE SYMBOL))
	       (SYS:DYNAMIC-CLOSURE (INSPECT-DATA-TYPE CLOSURE))
	       (COMPILED-FUNCTION (INSPECT-DATA-TYPE COMPILED-FUNCTION))))
	   (INSPECT-FORCED-TYPE (TYPE)
	     (COND ((SCL:EQUAL-TYPEP TYPE 'INSPECTOR-STACK-FRAME)
		    (INSPECT-DATA-TYPE STACK-FRAME))
		   ((SCL:EQUAL-TYPEP TYPE 'FLAVOR-MESSAGE-HANDLER)
		    (INSPECT-DATA-TYPE FLAVOR-MESSAGE-HANDLER))
		   ((SCL:EQUAL-TYPEP TYPE 'SI:BASIC-HASH-TABLE)
		    (INSPECT-DATA-TYPE BASIC-HASH-TABLE))
		   ((SCL:EQUAL-TYPEP TYPE 'CLI::BASIC-TABLE)
		    (INSPECT-DATA-TYPE TABLE))
		   ((SCL:EQUAL-TYPEP TYPE 'CL:STRUCTURE)
		    (INSPECT-DATA-TYPE NAMED-STRUCTURE))
		   ((SCL:EQUAL-TYPEP TYPE 'SCL:INSTANCE)
		    (INSPECT-DATA-TYPE INSTANCE))
		   ((SCL:EQUAL-TYPEP TYPE 'SCL:ARRAY)
		    (INSPECT-DATA-TYPE ARRAY))
		   ((SCL:EQUAL-TYPEP TYPE 'LIST)
		    (INSPECT-DATA-TYPE LIST))
		   ((SCL:EQUAL-TYPEP TYPE 'SYMBOL)
		    (INSPECT-DATA-TYPE SYMBOL))
		   ((SCL:EQUAL-TYPEP TYPE 'DYNAMIC-CLOSURE)
		    (INSPECT-DATA-TYPE CLOSURE))
		   ((SCL:EQUAL-TYPEP TYPE 'COMPILED-FUNCTION)
		    (INSPECT-DATA-TYPE COMPILED-FUNCTION)))))
      (LOOP NAMED RETRY-TYPE-ANALYSIS
	    DO (SETQ OBJECT
		     (CATCH 'INSPECT-REAL-OBJECT	; if this is thrown to,
						; the value is a better object to look at.
						; too bad the header won't reveal that this
						; happened.
		       (INSPECT-FORCED-TYPE
			 (CATCH 'INSPECT-FORCE-TYPE	; is this is thrown to,
						; the value is a better type to
						; look at. Again, too bad that there
						; is no provision to annotate.
			   (INSPECT-TYPECASE)
			   (RETURN-FROM RETRY-TYPE-ANALYSIS NIL)))
		       (RETURN-FROM RETRY-TYPE-ANALYSIS NIL))))))
  (LIST OBJECT
	(OR ALT-PRINT-FUN 'INSPECT-PRINTER)
	ARG DISPLAY-LIST (OR TOP-ITEM FIRST-TOP-ITEM 0)
	(OR LABEL
	    OBJ-LABEL
	    (LIST NIL NIL NIL NIL (LABEL-STYLE (SEND WINDOW ':LABEL))
		  (IF (LISTP OOBJECT)
		      "a list"
		      (NSUBSTRING (SETQ STR (FORMAT NIL "~S~%" OOBJECT))
				  0 (STRING-SEARCH-CHAR #\CR STR)))))))

(DEFUN INSPECT-SETUP-OBJECT (OBJECT WINDOW &OPTIONAL TOP-ITEM)
  (LET ((DISP (INSPECT-SETUP-OBJECT-DISPLAY-LIST OBJECT WINDOW TOP-ITEM)))
    (SEND WINDOW ':SETUP (CDR DISP))
    (SEND WINDOW ':SET-CURRENT-OBJECT (CAR DISP))
    DISP))

(DEFMETHOD (:SETUP-OBJECT BASIC-INSPECT) (SL)
  (SEND SELF ':SETUP (CDR SL))
  (SEND SELF ':SET-CURRENT-OBJECT (CAR SL))
  SL)

(DEFUN INSPECT-PRINTER (LINE ARG STREAM ITEM-NO)
  (DOLIST (ELT LINE)
    (COND ((NUMBERP ELT)
	   (FORMAT STREAM "~VT" ELT))
	  ((STRINGP ELT)
	   (PRINC ELT STREAM))
	  ((NLISTP ELT)
	   (FERROR NIL "Unknown element type: ~S" ELT))
	  ((STRINGP (CAR ELT))
	   (LEXPR-FUNCALL #'FORMAT STREAM ELT))
	  (T
	   (SELECTQ (FIRST ELT)
	     (:FUNCTION (LEXPR-FUNCALL (SECOND ELT) ARG STREAM ITEM-NO (CDDR ELT)))
	     (:COLON (FORMAT STREAM ":~VT " (SECOND ELT)))
	     (:ITEM (SEND STREAM ':ITEM ELT (SECOND ELT)
			  #'(LAMBDA (ELT &REST ARGS)
			      (LEXPR-FUNCALL (OR (FOURTH ELT)
						 #'PRINT-ITEM-CONCISELY)
					     (THIRD ELT) ARGS))))
	     (OTHERWISE (FERROR NIL "Unknown item type ~A" (FIRST ELT))))))))

;;; Inspection of each type of object is done by a message, so that some of them
;;; may be redefined for some unspecified application
(DEFMETHOD (:OBJECT-NAMED-STRUCTURE BASIC-INSPECT) (OBJ)
  (LET ((NSS (NAMED-STRUCTURE-SYMBOL OBJ))
	(ALIST NIL)
	(RESULT NIL)
	(MAXL -1))
    (PUSH `("Named structure of type "
	    (:ITEM NAMED-STRUCTURE-SYMBOL ,NSS))
	  RESULT)
    (LET ((DEFSTRUCT-DESCRIPTION (GET NSS 'SI:DEFSTRUCT-DESCRIPTION))	; preferable
	  (DEFSTRUCT-ITEMS (GET NSS 'SI:DEFSTRUCT-ITEMS)))	; second string
      (IF (NOT (OR DEFSTRUCT-DESCRIPTION DEFSTRUCT-ITEMS))
;;; ---this is a a second LET in case there is a way someday to have the header say
;;; ---"NAMED-STRUCTURE" and the body be made up by the array printer.
	  (THROW 'INSPECT-FORCE-TYPE 'SCL:ARRAY) 
	  (PUSH '("") RESULT)
	  (COND (DEFSTRUCT-DESCRIPTION
		 (SETQ ALIST (SI:DEFSTRUCT-DESCRIPTION-SLOT-ALIST DEFSTRUCT-DESCRIPTION))
		 (DO L ALIST (CDR L) (NULL L)
		     (SETQ MAXL (MAX (FLATSIZE (CAAR L)) MAXL)))
		  (SETQ MAXL (+ 2 MAXL))
		  ;; For a named structure, each line contains the name and the value
		  (DO L ALIST (CDR L) (NULL L)
		      (PUSH `((:ITEM NAMED-STRUCTURE-SLOT ,(CAAR L))
			      (:COLON ,MAXL)
			      (:ITEM NAMED-STRUCTURE-VALUE
				     ,(EVAL
					`(,(SI:DEFSTRUCT-SLOT-DESCRIPTION-REF-MACRO-NAME
					     (CDAR L))
					  ',OBJ))))
			    RESULT)))
		(DEFSTRUCT-ITEMS
		 (DOLIST (ELT DEFSTRUCT-ITEMS)
		   (SETQ MAXL (MAX (FLATSIZE ELT) MAXL)))
		 (SETQ MAXL (+ 2 MAXL))
		  ;; For a named structure, each line contains the name and the value
		  (DOLIST (ELT DEFSTRUCT-ITEMS)
		    (PUSH `((:ITEM NAMED-STRUCTURE-SLOT ,ELT)
			    (:COLON ,MAXL)
			    (:ITEM NAMED-STRUCTURE-VALUE
				   ,(CATCH-ERROR (FUNCALL ELT OBJ) NIL)))
			  RESULT))))
	  (NREVERSE RESULT)))))

(DEFUN (NAMED-STRUCTURE-SLOT SET-FUNCTION) (ITEM NEW-VALUE OBJECT
					    &AUX (SLOTNAME (THIRD (SECOND ITEM)))
						 (REFMAC SLOTNAME)
						 TEM)
  (AND (SETQ TEM (GET (NAMED-STRUCTURE-SYMBOL OBJECT) 'SI:DEFSTRUCT-DESCRIPTION))
       (SETQ TEM (ASSQ SLOTNAME (SI:DEFSTRUCT-DESCRIPTION-SLOT-ALIST TEM)))
       (SETQ REFMAC (SI:DEFSTRUCT-SLOT-DESCRIPTION-REF-MACRO-NAME (CDR TEM))))
  (EVAL `(SETF (,REFMAC ',OBJECT) ',NEW-VALUE)))

(DEFPROP NAMED-STRUCTURE-SLOT T ONLY-WHEN-MODIFY)


(DEFMETHOD (:OBJECT-INSTANCE BASIC-INSPECT) (OBJ &AUX (MAXL -1) RESULT CLASS)
  (SETQ CLASS (CLOS:CLASS-OF OBJ))
  (SETQ RESULT (LIST '("")
		     `("An instance of "
		       (:ITEM FLAVOR ,(TYPEP OBJ))
		       ".  "
		       (:ITEM FLAVOR-FUNCTION
			      ,(MAKE-FLAVOR-MESSAGE-HANDLER
				 HANDLER (CLOS-INTERNALS::%INSTANCE-INFORMATION-DISPATCH-TABLE
					   (CLOS-INTERNALS::CLASS-INSTANCE-INFORMATION
					     CLASS))
				 FLAVOR (CLOS:CLASS-NAME CLASS))))))
  (DOLIST (SLOT (CLOS:CLASS-SLOTS CLASS))
    (SETQ MAXL (MAX (FLATSIZE (CLOS:SLOT-DEFINITION-NAME SLOT)) MAXL)))
  (SETQ MAXL (+ MAXL 2))
  (LOOP FOR SLOT IN (CLOS:CLASS-SLOTS CLASS)
	FOR SLOT-NAME = (CLOS-INTERNALS:SLOT-DEFINITION-NAME SLOT)
	AS CELL = (LOCF (CLOS:SLOT-VALUE OBJ SLOT-NAME))
	DOING
    (PUSH `((:ITEM INSTANCE-SLOT ,SLOT-NAME)
	    (:COLON ,MAXL)
	    ,(IF (LOCATION-BOUNDP CELL)
		 `(:ITEM INSTANCE-VALUE ,(LOCATION-CONTENTS CELL))
		 "unbound"))
	  RESULT))
  (NREVERSE RESULT))

;---I wonder whether sending a message like this is right or wrong
;---What level of abstraction is this supposed to work at?
(DEFUN (INSTANCE-SLOT SET-FUNCTION) (ITEM NEW-VALUE OBJECT)
  (LET* ((SLOT (THIRD (SECOND ITEM)))
	 (MESSAGE-NAME (INTERN (STRING-APPEND "SET-" SLOT) SI:PKG-KEYWORD-PACKAGE)))
    (IF (OPERATION-HANDLED-P OBJECT MESSAGE-NAME)
	(CATCH-ERROR (SEND OBJECT MESSAGE-NAME NEW-VALUE) T)
	(CL:SETF (CLOS:SLOT-VALUE OBJECT SLOT) NEW-VALUE))))

(DEFPROP INSTANCE-SLOT T ONLY-WHEN-MODIFY)


(DEFMETHOD (:OBJECT-FLAVOR-MESSAGE-HANDLER BASIC-INSPECT) (FMH &AUX (RESULT NIL) (MAXL -1))
  (LET ((MH (FLAVOR-MESSAGE-HANDLER-HANDLER FMH)))
    (COND ((NOT (TYPEP MH ':ARRAY)) (THROW 'INSPECT-REAL-OBJ MH))
	  (T ;;--- Kludgey unmodular code
	     (LOOP FOR SELECTOR BEING THE ARRAY-ELEMENTS OF MH FROM 7 BY 3 USING (INDEX I)
		   AS GEN = (IF (TYPEP SELECTOR ':GENERIC-FUNCTION)
				(GENERIC-FUNCTION-NAME SELECTOR)
				SELECTOR)
		   DO
	       (WHEN SELECTOR
		 (PUSH `((:ITEM FLAVOR-MESSAGE-HANDLER-KEYWORD ,GEN)
			 ,(LIST ':COLON 0)
			 (:ITEM FLAVOR-MESSAGE-HANDLER-FUNCTION 
			  ,#-IMACH (AREF MH (+ I 2))
			   #+IMACH (SYS:%FIND-STRUCTURE-HEADER (AREF MH (+ I 1)))))
		       RESULT)
		 (SETQ MAXL (MAX MAXL (FLATSIZE GEN)))))
	     (SETQ RESULT (SORT RESULT #'(LAMBDA (Y X)
					   (ALPHALESSP (THIRD (FIRST X)) (THIRD (FIRST Y))))))
	     (DOLIST (R RESULT)
	       (SETF (SECOND (SECOND R)) MAXL))
	     (NREVERSE RESULT)))))

(DEFPROP FLAVOR-MESSAGE-HANDLER-KEYWORD T ONLY-WHEN-MODIFY)

;;- --- Allowing this at all is probably a bad idea
(DEFUN (FLAVOR-MESSAGE-HANDLER-KEYWORD SET-FUNCTION) (ITEM NEW-VALUE FMH)
  (LET ((GENERIC (THIRD (SECOND ITEM)))
	(MH (FLAVOR-MESSAGE-HANDLER-HANDLER FMH)))
    (WITHOUT-INTERRUPTS
      (LOOP FOR SELECTOR BEING THE ARRAY-ELEMENTS OF MH FROM 7 BY 3 USING (INDEX I)
	    AS GEN = (IF (TYPEP SELECTOR ':GENERIC-FUNCTION)
			 (GENERIC-FUNCTION-NAME SELECTOR)
			 SELECTOR) DO
	(WHEN (EQ GEN GENERIC)
	  (SETF (AREF MH (+ I 2)) NEW-VALUE))))))


(DEFMETHOD (:OBJECT-CLOSURE BASIC-INSPECT) (OBJ &AUX RESULT (C (%MAKE-POINTER DTP-LIST OBJ)))
  (SETQ RESULT `("Function is "
		 (:ITEM CLOSURE-FUNCTION ,(INSPECT-FUNCTION-FROM (CAR C)))))
  #+CADR
  (COND ((ENTITYP OBJ)
	 (PUSH '(".  ") RESULT)
	 (PUSH `(:ITEM TYPE ,(TYPEP OBJ)) RESULT)
	 (PUSH '("An object of type ") RESULT)))
  (SETQ RESULT (LIST '("") RESULT))
  (LET ((SYM NIL)
	(MAXL -1))
    (DO L (CDR C) (CDDR L) (NULL L)
	(SETQ SYM (%FIND-STRUCTURE-HEADER (CAR L)))
	(SETQ MAXL (MAX (FLATSIZE SYM) MAXL)))
    (SETQ MAXL (+ MAXL 2))
    (DO L (CDR C) (CDDR L) (NULL L)
	(SETQ SYM (%FIND-STRUCTURE-HEADER (CAR L)))
	(PUSH `((:ITEM CLOSURE-SLOT ,SYM)
		(:COLON ,MAXL)
		,(IF (= (%P-DATA-TYPE (CADR L)) DTP-NULL)
		     "unbound"
		     `(:ITEM CLOSURE-VALUE ,(CAADR L))))
	      RESULT))
    (NREVERSE RESULT)))

(DEFUN INSPECT-FUNCTION-FROM (FROM)
  (DO () (())
    (COND ((SYMBOLP FROM)
	   (AND (NOT (FBOUNDP FROM))
		(RETURN FROM))
	   (SETQ FROM (FSYMEVAL FROM)))
	  (T (RETURN FROM)))))

(DEFUN (CLOSURE-SLOT SET-FUNCTION) (ITEM NEW-VALUE OBJECT)
  (LET* ((SLOT (THIRD (SECOND ITEM)))
	 (MESSAGE-NAME (INTERN (STRING-APPEND "SET-" SLOT) SI:PKG-KEYWORD-PACKAGE)))
    (IF (GET-HANDLER-FOR MESSAGE-NAME OBJECT)
	(CATCH-ERROR (SEND OBJECT MESSAGE-NAME NEW-VALUE) T)
	(SET-IN-CLOSURE OBJECT SLOT NEW-VALUE))))

(DEFPROP CLOSURE-SLOT T ONLY-WHEN-MODIFY)

#+cadr (PROGN 'COMPILE
(DEFMETHOD (:OBJECT-SELECT-METHOD BASIC-INSPECT) (SM &AUX (RESULT NIL))
  (SETQ SM (%MAKE-POINTER DTP-LIST SM))
  (DO ((S SM (CDR S))
       (MAXL -1))
      ((SYMBOLP S)
       (SETQ RESULT (SORT RESULT #'(LAMBDA (Y X)
				     (ALPHALESSP (THIRD (FIRST X)) (THIRD (FIRST Y))))))
       (SETQ MAXL (+ (MAX MAXL (STRING-LENGTH "Tail pointer")) 2))
       (DOLIST (R RESULT)
	 (SETF (SECOND (SECOND R)) MAXL))
       (PUSH `((:ITEM SELECT-METHOD-TAIL-POINTER "Tail pointer" PRINC)
	       (:COLON ,MAXL)
	       (:ITEM SELECT-METHOD-TAIL-FUNCTION ,(AND S (INSPECT-FUNCTION-FROM S))))
	     RESULT)
       (NREVERSE RESULT))
    (DO ((KWDS (CAAR S) (CDR KWDS))
	 (K))
	((NULL KWDS))
      (IF (LISTP KWDS)
	  (SETQ K (CAR KWDS))
	  (SETQ K KWDS)
	  (SETQ KWDS NIL))		
      (PUSH `((:ITEM SELECT-METHOD-KEYWORD ,K)
	      ,(LIST ':COLON 0)
	      (:ITEM SELECT-METHOD-FUNCTION ,(CDAR S)))
	      RESULT)
      (SETQ MAXL (MAX MAXL (FLATSIZE K))))))

(DEFUN (SELECT-METHOD-TAIL-POINTER SET-FUNCTION) (IGNORE NEW-VALUE SM)
  (RPLACD (LAST (%MAKE-POINTER DTP-LIST SM)) NEW-VALUE))

(DEFPROP SELECT-METHOD-TAIL-POINTER T ONLY-WHEN-MODIFY)

(DEFUN (SELECT-METHOD-KEYWORD SET-FUNCTION) (ITEM NEW-VALUE SM)
  (SETQ SM (%MAKE-POINTER DTP-LIST SM)
	ITEM (THIRD (SECOND ITEM)))
  (DO ((S SM (CDR S)))
      ((SYMBOLP S))
    (COND ((IF (SYMBOLP (CAAR S))
	       (EQ (CAAR S) ITEM)
	       (MEMQ ITEM (CAAR S)))
	   (SETF (CDAR S) NEW-VALUE)
	   (RETURN)))))

(DEFPROP SELECT-METHOD-KEYWORD T ONLY-WHEN-MODIFY)
) ;#+cadr

(DEFMETHOD (:OBJECT-SYMBOL BASIC-INSPECT) (OBJ)
  `(((:ITEM SYMBOL-VALUE-CELL "Value is " PRINC)
     ,(IF (BOUNDP OBJ)
	  `(:ITEM SYMBOL-VALUE ,(SYMEVAL OBJ))
	  "unbound"))
    ((:ITEM SYMBOL-FUNCTION-CELL "Function is " PRINC)
     ,(IF (FBOUNDP OBJ)
	  `(:ITEM SYMBOL-FUNCTION ,(FSYMEVAL OBJ))
	  "unbound"))
    ((:ITEM SYMBOL-PROPERTY-CELL "Property list: " PRINC)
     (:ITEM SYMBOL-PROPERTY-LIST ,(PLIST OBJ)))
    ("Package: "
     (:ITEM SYMBOL-PACKAGE ,(CAR (PACKAGE-CELL-LOCATION OBJ))))))

(DEFUN (SYMBOL-VALUE-CELL SET-FUNCTION) (IGNORE NEW-VALUE OBJECT)
  (SET OBJECT NEW-VALUE))

(DEFPROP SYMBOL-VALUE-CELL T ONLY-WHEN-MODIFY)

(DEFUN (SYMBOL-FUNCTION-CELL SET-FUNCTION) (IGNORE NEW-VALUE OBJECT)
  (FSET OBJECT NEW-VALUE))

(DEFPROP SYMBOL-FUNCTION-CELL T ONLY-WHEN-MODIFY)

(DEFUN (SYMBOL-PROPERTY-CELL SET-FUNCTION) (IGNORE NEW-VALUE OBJECT)
  (SETPLIST OBJECT NEW-VALUE))

(DEFPROP SYMBOL-PROPERTY-CELL T ONLY-WHEN-MODIFY)

(DEFMETHOD (:OBJECT-COMPILED-FUNCTION BASIC-INSPECT) (COMPILED-FUNCTION)
  (COMPILED-FUNCTION-DISPLAY-LIST COMPILED-FUNCTION SELF))

;;; Use the debugger's function-spec-language-instance facility, which
;;; associates a flavor instance for each language's runtime model.  The
;;; default model is the lisp one.
(DEFMETHOD (:OBJECT-STACK-FRAME BASIC-INSPECT) (SF)
  (LET* ((FRAME (STACK-FRAME-FRAME SF))
	 (FUNCTION (FRAME-FUNCTION FRAME)))
    (TYPECASE FUNCTION
      (:LIST (SEND SELF :OBJECT-LIST FUNCTION))
      (:COMPILED-FUNCTION
       (COMPILED-FUNCTION-DISPLAY-LIST 
	     FUNCTION SELF
	     (FRAME-RELATIVE-EXIT-PC FRAME)
	     (STACK-FRAME-LABEL SF)
	     (AND (VARIABLE-BOUNDP DBG:*ERROR*)
		  (DBG:FRAME-PC-INCREMENTED-P DBG:*ERROR* FRAME)))))))

(DEFVAR *PREFER-DISASSEMBLED-CODE* NIL)
(DEFUN COMPILED-FUNCTION-DISPLAY-LIST (COMPILED-FUNCTION WINDOW &OPTIONAL PC-NOW LABEL
									  PC-INCREMENTED
								&AUX CCA)
  (LET ((SECTION (SI:FUNCTION-CORRESPONDENCE-INFO COMPILED-FUNCTION))
	(LANGUAGE (DBG:FIND-LANGUAGE-FOR-FUNCTION (FUNCTION-NAME COMPILED-FUNCTION))))
    (COND ((OR *PREFER-DISASSEMBLED-CODE*
	       (NULL SECTION)
	       (NEQ LANGUAGE :LISP))
	   (SETQ CCA (COMPILED-FUNCTION-CCA COMPILED-FUNCTION))
	   #+3600
	   (VALUES (LOOP FOR ADDRESS FROM 0 BELOW (CCA-N-INSTRUCTIONS CCA)
			 COLLECT (CCA-INSTRUCTION CCA ADDRESS))
		   (LIST CCA PC-NOW)
		   'PRINT-CCA-INSTRUCTION
		   (AND PC-NOW
			(MAX 0 (- PC-NOW (// (* 3 (// (SHEET-INSIDE-HEIGHT WINDOW)
						      (SHEET-LINE-HEIGHT WINDOW)))
					     4))))
		   LABEL)
	   #+IMACH
	   (LET* ((PC-NOW-INDEX)
		  (DEBUGGING-INFO (DEBUGGING-INFO COMPILED-FUNCTION))
		  (VCA (CDR (CL:ASSOC :VARIABLE-CREATION-ALIST DEBUGGING-INFO)))
		  (PC-LIST
		    (LOOP WITH PC-0 = (%POINTER-PLUS CCA (DEFSTORAGE-SIZE COMPILED-FUNCTION))
			  FOR PC FIRST 0 THEN (+ PC INCREMENT)
			  FOR INDEX FROM 0
			  FOR INCREMENT =
			      (SELECT (%P-CDR-CODE (%POINTER-PLUS PC-0 (LSH PC -1)))
				(SEQUENCING-PC-EVEN+2-ODD+3 (IF (EVENP PC) 2 3))
				(SEQUENCING-PC-1 -1)
				(SEQUENCING-PC+1 +1)
				(SEQUENCING-FENCE NIL))
			  WHILE INCREMENT
			  COLLECT (CONS PC (CDR (CL:ASSOC PC VCA)))
			  DOING
		      (WHEN (EQL PC PC-NOW)
			(SETQ PC-NOW-INDEX INDEX))
			  FINALLY
			    (UNLESS PC-NOW-INDEX
			      (SETQ PC-NOW-INDEX INDEX)))))
	     (VALUES PC-LIST
		     (LIST CCA (WHEN PC-NOW PC-NOW-INDEX)
			   (I-LISP-COMPILER:COMPUTE-STACK-DESCRIPTION COMPILED-FUNCTION)
			   DEBUGGING-INFO)
		     'PRINT-CCA-INSTRUCTION
		     (AND PC-NOW
			  (MAX 0 (- PC-NOW-INDEX (// (* 3 (// (SHEET-INSIDE-HEIGHT WINDOW)
						      (SHEET-LINE-HEIGHT WINDOW)))
						     4))))
		     LABEL)))
	  (T
	   ;; The source code is present in an editor buffer.
	   (MULTIPLE-VALUE-BIND (START-BP NIL END-BP)
	       (AND PC-NOW
		    (SI:CCA-INSTRUCTION-SOURCE-LOCATOR-BP
		      (COMPILED-FUNCTION-CCA COMPILED-FUNCTION)
		      (IF PC-INCREMENTED (1- PC-NOW) PC-NOW)))
	     (VALUES
	       (LET ((BOLD-P NIL))
		 (LOOP FOR LINE FIRST (ZWEI:BP-LINE (ZWEI:INTERVAL-FIRST-BP SECTION))
				THEN (ZWEI:LINE-NEXT LINE)
		       COLLECT (COND ((AND START-BP (EQ LINE (ZWEI:BP-LINE START-BP)))
				      (IF (EQ LINE (ZWEI:BP-LINE END-BP))
					  (LIST LINE (ZWEI:BP-INDEX START-BP)
						(ZWEI:BP-INDEX END-BP))
					  (SETQ BOLD-P T)
					  (LIST LINE (ZWEI:BP-INDEX START-BP))))
				     (BOLD-P
				      (IF (NEQ LINE (ZWEI:BP-LINE END-BP))
					  (LIST LINE 0)
					  (SETQ BOLD-P NIL)
					  (LIST LINE 0 (ZWEI:BP-INDEX END-BP))))
				     (T LINE))
		       UNTIL (EQ LINE (ZWEI:BP-LINE (ZWEI:INTERVAL-LAST-BP SECTION)))))
	       NIL
	       'PRINT-LINE-OF-SOURCE
	       NIL
	       LABEL))))))

(DEFUN PRINT-LINE-OF-SOURCE (LINE INFO STREAM ADDRESS)
  INFO ADDRESS
  (IF (ATOM LINE)
      (SEND STREAM :STRING-OUT LINE)
      (LET ((STRING (FIRST LINE))
	    (BOLD-P NIL)
	    (INDEX 0))
	(FLET ((DO-SUBSTRING (START-INDEX END-INDEX)
		 (IF BOLD-P
		     (WITH-CHARACTER-FACE (:BOLD STREAM)
		       (SEND STREAM :STRING-OUT STRING START-INDEX END-INDEX))
		     (SEND STREAM :STRING-OUT STRING START-INDEX END-INDEX))))
	  (DOLIST (NEXT-INDEX (REST1 LINE))
	    (DO-SUBSTRING INDEX NEXT-INDEX)
	    (SETQ BOLD-P (NOT BOLD-P)
		  INDEX NEXT-INDEX))
	  (DO-SUBSTRING INDEX NIL)))))

#+3600
(DEFUN PRINT-CCA-INSTRUCTION (INST CCA-AND-CURRENT-PC STREAM ADDRESS
			      &AUX (CCA (FIRST CCA-AND-CURRENT-PC))
				   (PC-NOW (SECOND CCA-AND-CURRENT-PC)))
  (FORMAT STREAM "~:[   ~;=> ~]~3O " (EQ ADDRESS PC-NOW) ADDRESS)
  (L-LISP-COMPILER:DISASSEMBLE-CCA-INSTRUCTION CCA INST ADDRESS
					'DISPLAY-CCA-DISASSEMBLE-FUNCTION STREAM))
#+IMACH
(DEFUN PRINT-CCA-INSTRUCTION (PC-AND-NAMES ARGS STREAM ADDRESS)
  (DLET (((CCA PC-NOW-INDEX STACK-ARRAY DEBUGGING-INFO) ARGS)
	 ((PC . NAMES) PC-AND-NAMES ))
    (FORMAT STREAM "~&~:[   ~;=> ~]" (EQ ADDRESS PC-NOW-INDEX))
    (ILC:DISASSEMBLE-INSTRUCTION-FOR-INSPECT
      CCA PC NAMES STACK-ARRAY DEBUGGING-INFO STREAM)))

#+3600
(DEFSELECT (DISPLAY-CCA-DISASSEMBLE-FUNCTION L-LISP-COMPILER:DEFAULT-DISASSEMBLE-FUNCTION)
  ((:PRINT-CONSTANT-OBJECT) (OBJECT PREFIX CCA INDEX STREAM &OPTIONAL FUNCTION-P) 
   FUNCTION-P
   (SEND STREAM ':ITEM (LIST OBJECT CCA INDEX) 'CCA-OBJECT #'PRINT-CCA-OBJECT PREFIX))
  ((:PRINT-INDIRECT-OBJECT) (OBJECT PREFIX CCA INDEX STREAM &OPTIONAL FUNCTION-P)
   FUNCTION-P
   (SEND STREAM ':ITEM (LIST OBJECT CCA INDEX)
	 'CCA-INDIRECT-OBJECT #'PRINT-CCA-OBJECT PREFIX))
  )

(DEFUN PRINT-CCA-OBJECT (ITEM STREAM PREFIX)
  (PRINC PREFIX STREAM)
  (SEND STREAM ':ITEM (FIRST ITEM) ':VALUE #'PRINT-ITEM-CONCISELY))

(DEFUN (:PROPERTY CCA-OBJECT VALUE-FUNCTION) (ITEM)
  (FIRST (SECOND ITEM)))
#+3600
(DEFUN (:PROPERTY CCA-OBJECT SET-FUNCTION) (ITEM NEW-VALUE IGNORE)
  (SETF (CCA-OBJECT (SECOND (SECOND ITEM)) (THIRD (SECOND ITEM))) NEW-VALUE))
#+IMACH
(DEFUN (:PROPERTY CCA-OBJECT SET-FUNCTION) (ITEM NEW-VALUE IGNORE)
  (LET ((CCA (SECOND (SECOND ITEM)))
	(PC (THIRD (SECOND ITEM))))
    (SETF (LOCATION-CONTENTS (%POINTER-PLUS CCA (+ (LSH PC -1) 
						   (DEFSTORAGE-SIZE COMPILED-FUNCTION))))
	  NEW-VALUE)
    (%CLEAR-INSTRUCTION-CACHE)))
#+3600
(DEFUN (:PROPERTY CCA-INDIRECT-OBJECT VALUE-FUNCTION) (ITEM)
  (CDR (CCA-OBJECT (SECOND (SECOND ITEM)) (THIRD (SECOND ITEM)))))
#+IMACH
(DEFUN (:PROPERTY CCA-INDIRECT-OBJECT VALUE-FUNCTION) (ITEM)
  (LET ((CCA (SECOND (SECOND ITEM)))
	(PC (THIRD (SECOND ITEM))))
    (LOCATION-CONTENTS (%P-CONTENTS-AS-LOCATIVE
			 (%POINTER-PLUS CCA (+ (LSH PC -1) 
					       (DEFSTORAGE-SIZE COMPILED-FUNCTION)))))))
#+3600
(DEFUN (:PROPERTY CCA-INDIRECT-OBJECT SET-FUNCTION) (ITEM NEW-VALUE IGNORE)
  (SETF (CDR (CCA-OBJECT (SECOND (SECOND ITEM)) (THIRD (SECOND ITEM)))) NEW-VALUE))
#+IMACH
(DEFUN (:PROPERTY CCA-INDIRECT-OBJECT SET-FUNCTION) (ITEM NEW-VALUE IGNORE)
  (LET* ((CCA (SECOND (SECOND ITEM)))
	 (PC (THIRD (SECOND ITEM)))
	 (PLACE (%POINTER-PLUS CCA (+ (LSH PC -1) (DEFSTORAGE-SIZE COMPILED-FUNCTION)))))
    (%MEMORY-WRITE
      PLACE
      (%SET-TAG
	NEW-VALUE
	(%TAG (%MEMORY-READ PLACE :CYCLE-TYPE %MEMORY-SCAVENGE :SET-CDR-NEXT NIL))))
    (%CLEAR-INSTRUCTION-CACHE)))
;;; Like CCA-OBJECT, only it can't be set
#+IMACH
(DEFUN (:PROPERTY CCA-RANDOM-OBJECT VALUE-FUNCTION) (ITEM)
  (FIRST (SECOND ITEM)))

;;; List structure hacking

(DEFFLAVOR FOLLOW-LIST-STRUCTURE-BLINKER
	((LIST-ITEM NIL))
	(BLINKER)
  (:INITABLE-INSTANCE-VARIABLES LIST-ITEM))

(DEFMETHOD (:SET-LIST-ITEM FOLLOW-LIST-STRUCTURE-BLINKER) (NEW-LIST-ITEM)
  (WHEN (NEQ LIST-ITEM NEW-LIST-ITEM)
    (WITH-BLINKER-PREPARED (SELF)
      (SETQ LIST-ITEM NEW-LIST-ITEM))))

(DEFMETHOD (:BLINK FOLLOW-LIST-STRUCTURE-BLINKER) (&AUX Y LAST-LEFT-X LAST-RIGHT-X
							ITEM END-ITEM
							START-XPOS END-XPOS MAX-X)
  (SETQ MAX-X (SHEET-INSIDE-RIGHT SHEET))
  (MULTIPLE-VALUE-BIND (ITEM-ARRAY TOP-ITEM BOTTOM-ITEM CHARW LINEH IL IT)
      (SEND SHEET ':LIST-BLINKER-INFO)
    (SETQ ITEM (THIRD LIST-ITEM)
	  START-XPOS (1- (SECOND LIST-ITEM))
	  END-ITEM (FIFTH LIST-ITEM)
	  END-XPOS (1+ (FOURTH LIST-ITEM)))
    (SETQ Y (+ (* LINEH (- ITEM TOP-ITEM)) IT -2)
	  LAST-LEFT-X (1- IL))
    (COND ((AND ( ITEM TOP-ITEM)
		(< ITEM BOTTOM-ITEM))
	   ;; Top is on screen, draw the top line
	   (SHEET-DRAW-LINE (SETQ LAST-LEFT-X START-XPOS) Y
			    (SETQ LAST-RIGHT-X
				  (MIN MAX-X
				       (IF ( ITEM END-ITEM)
					   (+ IL 1 (* CHARW
						      (STRING-LENGTH
							(SECOND (AREF ITEM-ARRAY ITEM)))))
					   END-XPOS)))
			    Y
			    BLINKER-ALU T SHEET)))
    (DO () (( ITEM BOTTOM-ITEM))
      (COND (( ITEM TOP-ITEM)
	     ;; Item is on screen, so there are side bars
	     (SHEET-DRAW-LINE LAST-LEFT-X (1+ Y)
			      LAST-LEFT-X (+ Y (1- LINEH))
			      BLINKER-ALU T SHEET)
	     (SHEET-DRAW-LINE LAST-RIGHT-X (1+ Y)
			      LAST-RIGHT-X (+ Y (1- LINEH))
			      BLINKER-ALU T SHEET)))
      (SETQ Y (+ Y LINEH))
      ;; If we just handled the side-bars for the last item, return
      (AND (OR (= ITEM END-ITEM) ( ITEM (1- BOTTOM-ITEM)))
	   (RETURN))
      ;; Onto the next item, and take care of the short horizontal bars on the right and left
      (COND ((> (SETQ ITEM (1+ ITEM)) TOP-ITEM)
	     (SHEET-DRAW-LINE LAST-LEFT-X Y
			      (SETQ LAST-LEFT-X (1- IL)) Y
			      BLINKER-ALU T SHEET)
	     (SHEET-DRAW-LINE LAST-RIGHT-X Y
			      (SETQ LAST-RIGHT-X
				    (MIN MAX-X
					 (IF ( ITEM END-ITEM)
					     (+ IL 1 (* CHARW
							(STRING-LENGTH
							  (SECOND (AREF ITEM-ARRAY ITEM)))))
					     END-XPOS)))
			      Y
			      BLINKER-ALU T SHEET))
	    ((= ITEM TOP-ITEM)
	     (SETQ LAST-RIGHT-X
		   (MIN MAX-X
			(IF ( ITEM END-ITEM)
			    (+ IL 1 (* CHARW (STRING-LENGTH (SECOND (AREF ITEM-ARRAY ITEM)))))
			    END-XPOS))))))
    (AND (= ITEM END-ITEM) (< ITEM BOTTOM-ITEM)
	 ;; If didn't run off bottom of screen, draw in bottom line
	 (SHEET-DRAW-LINE LAST-LEFT-X Y
			  LAST-RIGHT-X Y
			  BLINKER-ALU T SHEET))))

(DEFMETHOD (:SIZE FOLLOW-LIST-STRUCTURE-BLINKER) ()
  (VALUES (SHEET-INSIDE-WIDTH SHEET) (SHEET-INSIDE-HEIGHT SHEET)))


(DEFMETHOD (:LIST-BLINKER-INFO BASIC-INSPECT) ()
  (VALUES ITEMS
	  TOP-ITEM (+ TOP-ITEM (SHEET-NUMBER-OF-INSIDE-LINES))
	  CHAR-WIDTH LINE-HEIGHT
	  (SHEET-INSIDE-LEFT) (SHEET-INSIDE-TOP)))

(DEFMETHOD (:CHANGE-OF-SIZE-OR-MARGINS BASIC-INSPECT :AFTER) (&REST IGNORE)
  (AND DISPLAYING-LIST
       ;; If displaying a list, then must regrind when size changes
       (INSPECT-SETUP-OBJECT CURRENT-OBJECT SELF TOP-ITEM)))

(DEFMETHOD (:MOUSE-MOVES BASIC-INSPECT) (X Y &AUX ITEM TYPE LEFT TOP BWIDTH BHEIGHT)
  (MOUSE-SET-BLINKER-CURSORPOS SELF)
  (MULTIPLE-VALUE (ITEM TYPE LEFT BWIDTH TOP)
    (SEND SELF ':MOUSE-SENSITIVE-ITEM X Y))
  (COND ((MEMQ TYPE '(:LIST-STRUCTURE :LIST-STRUCTURE-TOP-LEVEL))
	 (BLINKER-SET-VISIBILITY ITEM-BLINKER NIL)
	 ;; LEFT, BWIDTH, TOP are invalid
	 (SEND LIST-BLINKER ':SET-LIST-ITEM ITEM)
	 (BLINKER-SET-VISIBILITY LIST-BLINKER T))
	(TYPE
	 (BLINKER-SET-VISIBILITY LIST-BLINKER NIL)
	 (SETQ BWIDTH (- BWIDTH LEFT)
	       BHEIGHT (FONT-BLINKER-HEIGHT CURRENT-FONT))
	 (BLINKER-SET-CURSORPOS ITEM-BLINKER (- LEFT (SHEET-INSIDE-LEFT))
				(- TOP (SHEET-INSIDE-TOP)))
	 (BLINKER-SET-SIZE ITEM-BLINKER BWIDTH BHEIGHT)
	 (BLINKER-SET-VISIBILITY ITEM-BLINKER T))
	(T (BLINKER-SET-VISIBILITY LIST-BLINKER NIL)
	   (BLINKER-SET-VISIBILITY ITEM-BLINKER NIL))))

(DEFMETHOD (:MOUSE-SENSITIVE-ITEM BASIC-INSPECT) (X Y)
  (PROG FOUND-ITEM (LILN)
	(MULTIPLE-VALUE-BIND (ITEM TYPE LEFT BWIDTH TOP)
	    (MOUSE-SENSITIVE-ITEM X Y)
	  (COND (ITEM (RETURN-FROM FOUND-ITEM (VALUES ITEM TYPE LEFT BWIDTH TOP)))
		((NOT DISPLAYING-LIST))
		((AND ( Y (SHEET-INSIDE-TOP))
		      (< Y (SHEET-INSIDE-BOTTOM)))
		 ;; No explicit item on this line -- find list structure if it exists
		 (LET ((LINE-NO (+ TOP-ITEM (SHEET-LINE-NO NIL Y))))
		   ;; Starting from this line, work backwards until an enclosing
		   ;; piece of structure is found
		   (OR ( LINE-NO (ARRAY-ACTIVE-LENGTH ITEMS))
		       (DOLIST (LI (FIRST (AREF ITEMS LINE-NO)))
			 (AND (COND ((= LINE-NO (SETQ LILN (THIRD LI)))
				     ;; Entry starts on this line -- within range on right?
				     ( X (SECOND LI)))
				    ((> LINE-NO LILN)
				     ;; Entry starts on some previous line -- so we are ok
				     T))
			      (COND ((= LINE-NO (SETQ LILN (FIFTH LI)))
				     ;; Entry ends on this line, within range on left?
				     (< X (FOURTH LI)))
				    ((< LINE-NO LILN)
				     ;; Entry starts before -- so this is good
				     T))
			      (IF (AND MODIFY-MODE (EQ (FIRST LI) ':TOP-LEVEL))
				  (RETURN-FROM FOUND-ITEM NIL)
				  (RETURN-FROM FOUND-ITEM
				    (VALUES LI
					    (IF (EQ (FIRST LI) ':TOP-LEVEL)
						':LIST-STRUCTURE-TOP-LEVEL
						':LIST-STRUCTURE)))))))))))))

(DEFMETHOD (:OBJECT-LIST BASIC-INSPECT) (LIST)
  (MULTIPLE-VALUE-BIND (STRING-LIST ATOMIC-ITEMS LIST-ITEMS)
      (GRIND-INTO-LIST LIST (// (SHEET-INSIDE-WIDTH) CHAR-WIDTH) T)
    (DO ((L STRING-LIST (CDR L))
	 (AIS ATOMIC-ITEMS (CDR AIS)))
	((NULL L))
      (DOLIST (I (CAR AIS))
	(SETF (THIRD I) (+ (SHEET-INSIDE-LEFT) (* (THIRD I) CHAR-WIDTH)))
	(SETF (FOURTH I) (+ (SHEET-INSIDE-LEFT) (* (FOURTH I) CHAR-WIDTH))))
      (RPLACA L (LIST NIL (CAR L) (CAR AIS))))
    (DOLIST (I LIST-ITEMS)
      (SETF (SECOND I) (+ (SHEET-INSIDE-LEFT) (* (SECOND I) CHAR-WIDTH)))
      (SETF (FOURTH I) (+ (SHEET-INSIDE-LEFT) (* (FOURTH I) CHAR-WIDTH))))
    (SETQ LIST-ITEMS (SORT LIST-ITEMS
			   #'(LAMBDA (X Y)
			       (COND ((< (THIRD Y) (THIRD X)) T)
				     ((> (THIRD Y) (THIRD X)) NIL)
				     (T (> (SECOND X) (SECOND Y)))))))
    (DO ((LINE (1- (LENGTH STRING-LIST)) (1- LINE))
	 (CURRENT LIST-ITEMS))
	((< LINE 0))
      (DO ()
	  ((OR (NULL CURRENT)
	       ( (THIRD (CAR CURRENT)) LINE)))
	(SETQ CURRENT (CDR CURRENT)))
      (RPLACA (CAR (NTHCDR LINE STRING-LIST)) CURRENT))
    (VALUES STRING-LIST ':LIST-STRUCTURE 'INSPECT-LIST-PRINTER)))

(DEFMETHOD (:SETUP BASIC-INSPECT :BEFORE) (SL)
  (SETQ CURRENT-DISPLAY SL
	DISPLAYING-LIST NIL)
  (BLINKER-SET-VISIBILITY LIST-BLINKER NIL))

(DEFMETHOD (:SETUP BASIC-INSPECT :AFTER) (NEW-SETUP)
  (SETQ DISPLAYING-LIST (EQ (SECOND NEW-SETUP) ':LIST-STRUCTURE)))

(DEFMETHOD (:HANDLE-MOUSE BASIC-INSPECT :AFTER) (&REST IGNORE)
  (BLINKER-SET-VISIBILITY LIST-BLINKER NIL))

(DEFUN INSPECT-LIST-PRINTER (ITEM IGNORE STREAM ITEM-NO)
  (SETF (AREF (SEND STREAM :DISPLAYED-ITEMS) (- ITEM-NO (SEND STREAM :TOP-ITEM)))
	(THIRD ITEM))
  (SEND STREAM :STRING-OUT (SECOND ITEM)))

(DEFUN (:LIST-STRUCTURE SET-FUNCTION) (ITEM NEW-VALUE IGNORE)
  (RPLACA (FIRST (SECOND ITEM)) NEW-VALUE))

(DEFUN (:LOCATIVE SET-FUNCTION) (ITEM NEW-VALUE IGNORE)
  (RPLACD (SECOND ITEM) NEW-VALUE))

;;; Array hacking
(DEFMETHOD (:OBJECT-ARRAY BASIC-INSPECT) (OBJ &AUX (LEADER NIL) (ARRAY NIL))
  (AND (ARRAY-HAS-LEADER-P OBJ)
       (DOTIMES (I (ARRAY-DIMENSION-N 0 OBJ))
	 (PUSH (- -1 I) LEADER)))
  (COND ((STRINGP OBJ)
	 (SETQ ARRAY `((,OBJ))))
	((> (ARRAY-/#-DIMS OBJ) 1)
	 (SETQ ARRAY `((,(FORMAT NIL "~S" OBJ)))))
	(T
	 (DOTIMES (I (ARRAY-DIMENSION-N 1 OBJ))
	   (PUSH I ARRAY))
	 (SETQ ARRAY (NREVERSE ARRAY))))
  (VALUES (NCONC (NREVERSE LEADER) ARRAY) OBJ 'INSPECT-ARRAY-PRINTER))

(DEFUN INSPECT-ARRAY-PRINTER (ITEM OBJ STREAM ARG3)
  (COND ((NOT (NUMBERP ITEM))
	 (INSPECT-PRINTER ITEM OBJ STREAM ARG3))
	((< ITEM 0)
	 (SETQ ITEM (- -1 ITEM))
	 (SEND STREAM ':ITEM ITEM 'LEADER-SLOT
	       #'(LAMBDA (ITEM STREAM)
		   (FORMAT STREAM "Leader ~D" ITEM)))
	 (FORMAT STREAM ":~12T ")
	 (INSPECT-ARRAY-SLOT-PRINTER (LOCF (ARRAY-LEADER OBJ ITEM)) STREAM))
	(T
	 (SEND STREAM ':ITEM ITEM '1D-ARRAY-SLOT
	       #'(LAMBDA (ITEM STREAM)
		   (FORMAT STREAM "Elt ~D" ITEM)))
	 (FORMAT STREAM ":~9T ")
	 (IF (ARRAY-BITS-PER-ELEMENT #-CADR (ARRAY-TYPE-FIELD OBJ)
				     #+CADR (%P-LDB %%ARRAY-TYPE-FIELD OBJ)) 
	     (SEND STREAM ':ITEM (AREF OBJ ITEM) ':VALUE #'PRINT-ITEM-CONCISELY)
	     (INSPECT-ARRAY-SLOT-PRINTER #+CADR (DBG:ALOC-CAREFUL OBJ ITEM)
					 #-CADR (LOCF (AREF OBJ ITEM))
					 STREAM)))))

(DEFUN INSPECT-ARRAY-SLOT-PRINTER (SLOT STREAM)
  (LET ((DTP (SI:DATA-TYPE-NAME (%P-DATA-TYPE SLOT))))
    (IF (MEMQ DTP DBG:*GOOD-DATA-TYPES*)
	(SEND STREAM ':ITEM (CDR SLOT) ':VALUE #'PRINT-ITEM-CONCISELY)
	(FORMAT STREAM "#<~A ~\si:address\>" DTP (%P-POINTER SLOT)))))

(DEFUN (LEADER-SLOT SET-FUNCTION) (ITEM NEW-VALUE OBJECT)
  (STORE-ARRAY-LEADER NEW-VALUE OBJECT (SECOND ITEM)))

(DEFPROP LEADER-SLOT T ONLY-WHEN-MODIFY)

(DEFUN (1D-ARRAY-SLOT SET-FUNCTION) (ITEM NEW-VALUE OBJECT)
  (ASET NEW-VALUE OBJECT (SECOND ITEM)))

(DEFPROP 1D-ARRAY-SLOT T ONLY-WHEN-MODIFY)

(DEFMETHOD (:OBJECT-BASIC-HASH-TABLE BASIC-INSPECT) (OBJECT)
  (VALUES (NCONC (SEND SELF :OBJECT-INSTANCE OBJECT)
		 (LIST '("")
		       '("Contents of the hash table (KEY => VALUE) :")
		       '(""))
		 (LOOP FOR I FROM 0 BELOW (SEND OBJECT ':FILLED-ELEMENTS)
		       COLLECT I))
	  (SEND OBJECT ':GET-DATA-ARRAY)
	  'INSPECT-HASH-TABLE-PRINTER))

(DEFUN INSPECT-HASH-TABLE-PRINTER (ITEM DATA-ARRAY STREAM ARG3)
  (IF (NOT (NUMBERP ITEM))
      (INSPECT-PRINTER ITEM DATA-ARRAY STREAM ARG3)
      (SEND STREAM ':ITEM (AREF DATA-ARRAY (* ITEM 2)) 'HASH-KEY
	    #'PRINT-ITEM-CONCISELY)
      (FORMAT STREAM " => ")
      (SEND STREAM ':ITEM (AREF DATA-ARRAY (1+ (* 2 ITEM)))
	    ':VALUE #'PRINT-ITEM-CONCISELY)))

(DEFUN (HASH-KEY SET-FUNCTION) (ITEM NEW-VALUE OBJECT)
  (SEND OBJECT ':PUT-HASH (SECOND ITEM) NEW-VALUE))
(DEFMETHOD (:OBJECT-TABLE BASIC-INSPECT) (OBJECT)
  (VALUES (NCONC (SEND SELF :OBJECT-INSTANCE OBJECT)
		 (LIST '("")
		       '("Contents of the hash table (KEY => VALUE) :")
		       '(""))
		 ;; Convert to a language that scroll windows can understand.  Bleagh.
		 (LOOP FOR VALUE BEING THE HASH-ELEMENTS OF OBJECT WITH-KEY KEY
		       COLLECT (LIST 'HASH-ELEMENTS KEY VALUE)))
	  OBJECT
	  'INSPECT-TABLE-PRINTER))
(DEFUN INSPECT-TABLE-PRINTER (ITEM TABLE STREAM ARG3)
  (IF (OR (NLISTP ITEM) (NEQ (FIRST ITEM) 'HASH-ELEMENTS))
      (INSPECT-PRINTER ITEM TABLE STREAM ARG3)
    (SEND STREAM :ITEM (SECOND ITEM) 'HASH-KEY #'PRINT-ITEM-CONCISELY)
    (FORMAT STREAM " => ")
    (SEND STREAM ':ITEM (THIRD ITEM) ':VALUE #'PRINT-ITEM-CONCISELY)))


;;; Other windows needed for the inspector
(DEFFLAVOR INSPECT-HISTORY-WINDOW ((CACHE NIL))
	   (LINE-AREA-TEXT-SCROLL-WINDOW
	    ANY-MOUSE-BUTTONS-TEXT-SCROLL-WINDOW-MIXIN
	    FUNCTION-TEXT-SCROLL-WINDOW
	    MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW
	    BASIC-SCROLL-BAR			;outside borders for thermometer effect
	    FLASHY-SCROLLING-MIXIN DONT-SELECT-WITH-MOUSE-MIXIN BORDERS-MIXIN
	    MARGIN-REGION-MIXIN WINDOW)
  :SETTABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES
  (:DEFAULT-INIT-PLIST :LABEL NIL
    		       :FLASHY-SCROLLING-REGION '((20 0.40s0 0.60s0)
						  (20 0.40s0 0.60s0))
		       :SCROLL-BAR-ALWAYS-DISPLAYED T)
  (:DOCUMENTATION :COMBINATION
		  "History window for the inspector, but no margin scroll region"))

(DEFFLAVOR INSPECT-HISTORY-WINDOW-WITH-MARGIN-SCROLLING
	()
	(MARGIN-SCROLL-MIXIN INSPECT-HISTORY-WINDOW)
  (:DEFAULT-INIT-PLIST :MARGIN-SCROLL-REGIONS '((:TOP "Top of History")
						(:BOTTOM "Bottom of History")))
  (:DOCUMENTATION :COMBINATION "History window for the inspector."))

(DEFMETHOD (:LINE-AREA-MOUSE-DOCUMENTATION INSPECT-HISTORY-WINDOW) ()
  "L: Inspect the indicated object.  M: Remove the indicated object.")

(DEFMETHOD (:WHO-LINE-DOCUMENTATION-STRING INSPECT-HISTORY-WINDOW) ()
  "L: Inspect item.")

(DEFMETHOD (:INSPECT-OBJECT INSPECT-HISTORY-WINDOW) (OBJECT INSPECTOR
						     &OPTIONAL TOP-ITEM-NO NEW-LABEL
						               DONT-PROPAGATE)
  ;; First, remember current TOP-ITEM of inspector
  (LET ((DISP (SEND INSPECTOR ':CURRENT-DISPLAY)))
    (AND DISP
	 (SETF (FOURTH DISP) (SEND INSPECTOR ':TOP-ITEM)))
    (OR (DOTIMES (I (ARRAY-ACTIVE-LENGTH ITEMS))
	  (COND ((NEQ OBJECT (AREF ITEMS I)))
		(DONT-PROPAGATE (RETURN T))
		(T (SEND SELF ':DELETE-ITEM I)
		   (RETURN NIL))))
	(SEND SELF ':APPEND-ITEM OBJECT))
    (SEND SELF ':PUT-ITEM-IN-WINDOW OBJECT)
    (LET ((CE (ASSQ OBJECT CACHE)))
      (OR CE
	  (PUSH (SETQ CE
		      (INSPECT-SETUP-OBJECT-DISPLAY-LIST OBJECT INSPECTOR
							 TOP-ITEM-NO NEW-LABEL))
		CACHE))
      (OR (EQ (CDR CE) DISP)
	  (SEND INSPECTOR ':SETUP-OBJECT CE)))))

(DEFMETHOD (:INSPECT-LANGUAGE-OBJECT INSPECT-HISTORY-WINDOW)
	   (OBJECT INSPECTOR LANGUAGE
		   &OPTIONAL TOP-ITEM-NO NEW-LABEL
		   DONT-PROPAGATE)
  ;; First, remember current TOP-ITEM of inspector
  (LET ((DISP (SEND INSPECTOR ':CURRENT-DISPLAY)))
    (AND DISP
	 (SETF (FOURTH DISP) (SEND INSPECTOR ':TOP-ITEM)))
    (OR (DOTIMES (I (ARRAY-ACTIVE-LENGTH ITEMS))
	  (COND ((NEQ OBJECT (AREF ITEMS I)))
		(DONT-PROPAGATE (RETURN T))
		(T (SEND SELF ':DELETE-ITEM I)
		   (RETURN NIL))))
	(SEND SELF ':APPEND-ITEM OBJECT))
    (SEND SELF ':PUT-ITEM-IN-WINDOW OBJECT)
    (LET ((CE (ASSQ OBJECT CACHE)))
      (OR CE
	  (PUSH (SETQ CE
		      (SEND LANGUAGE
			    :INSPECT-SETUP-OBJECT-DISPLAY-LIST OBJECT INSPECTOR
			    TOP-ITEM-NO NEW-LABEL))
		CACHE))
      (OR (EQ (CDR CE) DISP)
	  (SEND INSPECTOR ':SETUP-OBJECT CE)))))



(DEFMETHOD (:FLUSH-OBJECT INSPECT-HISTORY-WINDOW) (OBJ)
  (SEND SELF ':FLUSH-OBJECT-FROM-CACHE OBJ)
  (DOTIMES (I (ARRAY-ACTIVE-LENGTH ITEMS))
    (AND (EQ OBJ (AREF ITEMS I))
	 (RETURN (SEND SELF ':DELETE-ITEM I)))))

(DEFMETHOD (:INIT INSPECT-HISTORY-WINDOW :AFTER) (IGNORE)
  (SETQ PRINT-FUNCTION #'(LAMBDA (LINE IGNORE STREAM IGNORE)
			   (SEND STREAM ':ITEM LINE ':VALUE #'PRINT-ITEM-CONCISELY))
	PRINT-FUNCTION-ARG NIL))

(DEFMETHOD (:FLUSH-OBJECT-FROM-CACHE INSPECT-HISTORY-WINDOW) (OBJECT)
  (SETQ CACHE (DELQ (ASSQ OBJECT CACHE) CACHE)))

(DEFMETHOD (:FLUSH-CONTENTS INSPECT-HISTORY-WINDOW) ()
  (SETQ CACHE NIL
	TOP-ITEM 0)
  (STORE-ARRAY-LEADER 0 ITEMS 0)
  (FILLARRAY DISPLAYED-ITEMS '(NIL))
  (SHEET-FORCE-ACCESS (SELF :NO-PREPARE)
    (SEND SELF ':CLEAR-WINDOW)))

(DEFFLAVOR INSPECT-HISTORY-PANE () (PANE-NO-MOUSE-SELECT-MIXIN INSPECT-HISTORY-WINDOW))

(DEFFLAVOR INSPECT-HISTORY-PANE-WITH-MARGIN-SCROLLING
	()
	(PANE-NO-MOUSE-SELECT-MIXIN INSPECT-HISTORY-WINDOW-WITH-MARGIN-SCROLLING))

(DEFFLAVOR INSPECT-PANE () (PANE-NO-MOUSE-SELECT-MIXIN INSPECT-WINDOW))

(DEFFLAVOR INSPECT-TYPEOUT-WINDOW () (TYPEOUT-WINDOW))

(DEFFLAVOR INSPECT-WINDOW-WITH-TYPEOUT () (TEXT-SCROLL-WINDOW-TYPEOUT-MIXIN INSPECT-WINDOW)
  (:DEFAULT-INIT-PLIST :TYPEOUT-WINDOW '(INSPECT-TYPEOUT-WINDOW
					 :DEEXPOSED-TYPEOUT-ACTION (:EXPOSE-FOR-TYPEOUT))))

(DEFWRAPPER (:MOUSE-SENSITIVE-ITEM INSPECT-WINDOW-WITH-TYPEOUT) (IGNORE . BODY)
  `(COND ((NOT (SHEET-EXPOSED-P TYPEOUT-WINDOW))
	  . ,BODY)))

(DEFFLAVOR INSPECT-PANE-WITH-TYPEOUT () (PANE-NO-MOUSE-SELECT-MIXIN
					 INSPECT-WINDOW-WITH-TYPEOUT))

(DEFFLAVOR INTERACTION-PANE () (PANE-NO-MOUSE-SELECT-MIXIN WINDOW))

(DEFMETHOD (:SELECT INTERACTION-PANE :AFTER) (&REST IGNORE)
  (LET ((TW (SEND SUPERIOR ':TYPEOUT-WINDOW)))
    (AND (SEND TW ':INCOMPLETE-P)
	 (SEND TW ':SELECT))))

(DEFFLAVOR INSPECT-FRAME
	(INSPECTORS
	 TYPEOUT-WINDOW
	 (MENU NIL))
	(BORDERED-CONSTRAINT-FRAME)
  (:DEFAULT-INIT-PLIST :SAVE-BITS ':DELAYED)
  :GETTABLE-INSTANCE-VARIABLES
  (:INITABLE-INSTANCE-VARIABLES MENU)
  (:INIT-KEYWORDS :NUMBER-OF-INSPECTORS))

(DEFFLAVOR INSPECT-FRAME-WITH-OWN-PROCESS () (PROCESS-MIXIN INSPECT-FRAME)
  (:DEFAULT-INIT-PLIST :PROCESS '(INSPECT-FRAME-WITH-OWN-PROCESS-TOP-LEVEL)))

;;; Add it to the system Create menu
(TV:ADD-TO-SYSTEM-MENU-CREATE-MENU
  "Inspect" 'INSPECT-FRAME-WITH-OWN-PROCESS "Inspect data objects" "Lisp")

(DEFWHOPPER (:EXPOSE INSPECT-FRAME-WITH-OWN-PROCESS) (&REST ARGUMENTS)
  (FLET ((FIXUP (ITEM-LIST)
	   `(("Exit" :VALUE :EXIT :DOCUMENTATION "Exit the inspector.")
	     ,@(CL:REMOVE-IF
		 #'(LAMBDA (ITEM) (OR (EQUAL (CAR ITEM) "Exit") (EQUAL (CAR ITEM) "Return")))
		 ITEM-LIST))))
    (LET ((INSPECT-CL-FRAME-ITEM-LIST (FIXUP INSPECT-CL-FRAME-ITEM-LIST))
	  (INSPECT-ZL-FRAME-ITEM-LIST (FIXUP INSPECT-ZL-FRAME-ITEM-LIST)))
      (LEXPR-CONTINUE-WHOPPER ARGUMENTS))))

(DEFCONST INSPECT-ZL-FRAME-ITEM-LIST
	`(("Exit" :VALUE :EXIT
	   :DOCUMENTATION "Exit the inspector, returning NIL.")
	  ("Return" :VALUE :RETURN
	   :DOCUMENTATION "Exit the inspector, returning a value.")
	  ("Modify" :VALUE :MODIFY
	   :DOCUMENTATION "Modify a slot by pointing at it then choosing a new value.")
	  ("DeCache" :VALUE :FLUSH-CACHE
	   :DOCUMENTATION
	   "Delete saved display info.  Useful if you are looking at objects that have changed.")
	  ("Clear" :VALUE :CLEAR
	   :DOCUMENTATION "Remove all objects from the history.")
	  ("Set \" :VALUE :SET-\
	   :DOCUMENTATION
	   "Set the value of the symbol \ by choosing an object.")
	  ("Source" :VALUE :TOGGLE-SOURCE-CODE
	   :DOCUMENTATION
	   "Toggle whether to show source or disassembled code.")))


(DEFCONST INSPECT-CL-FRAME-ITEM-LIST
	`(("Exit" :VALUE :EXIT
	   :DOCUMENTATION "Exit the inspector, returning NIL.")
	  ("Return" :VALUE :RETURN
	   :DOCUMENTATION "Exit the inspector, returning a value.")
	  ("Modify" :VALUE :MODIFY
	   :DOCUMENTATION "Modify a slot by pointing at it then choosing a new value.")
	  ("DeCache" :VALUE :FLUSH-CACHE
	   :DOCUMENTATION
	   "Delete saved display info.  Useful if you are looking at objects that have changed.")
	  ("Clear" :VALUE :CLEAR
	   :DOCUMENTATION "Remove all objects from the history.")
	  ("Set //" :VALUE :SET-\
	   :DOCUMENTATION
	   "Set the value of the symbol // by choosing an object.")
	  ("Source" :VALUE :TOGGLE-SOURCE-CODE
	   :DOCUMENTATION
	   "Toggle whether to show source or disassembled code.")))



(DEFMETHOD (:EXPOSE INSPECT-FRAME :BEFORE) (&REST IGNORE)
  (LET ((CMENU (CDR (ASSQ 'MENU INTERNAL-PANES))))
    (SEND CMENU :SET-ITEM-LIST (IF (CHAR= (SI:PTTBL-SLASH READTABLE) #\\)
				   INSPECT-CL-FRAME-ITEM-LIST
				   INSPECT-ZL-FRAME-ITEM-LIST))))


(DEFMETHOD (:REFRESH INSPECT-FRAME :BEFORE) (&REST IGNORE)
  (LET ((CMENU (CDR (ASSQ 'MENU INTERNAL-PANES))))
    (SEND CMENU :SET-ITEM-LIST (IF (EQ READTABLE SI:*COMMON-LISP-READTABLE*)
				   INSPECT-CL-FRAME-ITEM-LIST
				   INSPECT-ZL-FRAME-ITEM-LIST))))


(DEFMETHOD (:INIT INSPECT-FRAME :BEFORE) (PLIST &AUX IO-BUFFER)
  (LET ((NOI (OR (GET PLIST ':NUMBER-OF-INSPECTORS) 3))
	(NAMES NIL))
    (SETQ IO-BUFFER (MAKE-DEFAULT-IO-BUFFER))
    (SETQ PANES (LIST `(INTERACTOR INTERACTION-PANE :LABEL NIL
				   		    :IO-BUFFER ,IO-BUFFER
						    :MORE-P NIL)
		      `(HISTORY INSPECT-HISTORY-PANE-WITH-MARGIN-SCROLLING
				:IO-BUFFER ,IO-BUFFER
				:SCROLL-BAR 3)
		      `(MENU COMMAND-MENU-PANE
			     :default-style ,*DEFAULT-STYLE* ;not the usual large menu style
			     :ITEM-LIST ,INSPECT-ZL-FRAME-ITEM-LIST
			     :IO-BUFFER ,IO-BUFFER)))
    (DOTIMES (I NOI)
      (LET ((PANE-NAME (INTERN (FORMAT NIL "INSPECTOR-~D" I) "TV")))
	(PUSH `(,PANE-NAME ,(IF (= I (1- NOI))
			   'INSPECT-PANE-WITH-TYPEOUT
			   'INSPECT-PANE)
		:SCROLL-BAR 3
		:IO-BUFFER ,IO-BUFFER) PANES)
	(PUSH PANE-NAME NAMES)))
    (SETQ INSPECTORS NAMES)
    (SETQ CONSTRAINTS `((MAIN . ((INTERACTOR HIST-AND-MENU . ,(REVERSE NAMES))
				 ((HIST-AND-MENU :HORIZONTAL (:LIMIT (3 NIL :LINES HISTORY)
							      0.10s0 :LINES HISTORY)
				    (HISTORY MENU)
				    ((MENU :ASK :PANE-SIZE))
				    ((HISTORY :EVEN)))
				  (INTERACTOR 3 :LINES))
				 ,@(AND (CDR NAMES)
					`((,@(MAPCAR #'(LAMBDA (PANE-NAME)
							 `(,PANE-NAME :LIMIT (1 30. :LINES)
							   ,(// 0.25s0 (1- NOI))
							   :LINES))
						     (CDR NAMES)))))
				  ((,(CAR NAMES) :EVEN))))))))

(DEFMETHOD (:INIT INSPECT-FRAME :AFTER) (IGNORE &AUX INT)
  (SEND SELF ':SELECT-PANE (SETQ INT (SEND SELF ':GET-PANE 'INTERACTOR)))
  (DO ((IS INSPECTORS (CDR IS)))
      ((NULL IS))
    (RPLACA IS (SEND SELF ':GET-PANE (CAR IS))))
  (SETQ TYPEOUT-WINDOW (SEND (CAR INSPECTORS) ':TYPEOUT-WINDOW))
  (SEND TYPEOUT-WINDOW ':SET-IO-BUFFER (SEND INT ':IO-BUFFER)))

(DEFMETHOD (:NAME-FOR-SELECTION INSPECT-FRAME) () NAME)

(COMPILE-FLAVOR-METHODS INSPECT-FRAME INSPECT-FRAME-WITH-OWN-PROCESS INTERACTION-PANE
			INSPECT-HISTORY-PANE INSPECT-HISTORY-PANE-WITH-MARGIN-SCROLLING
			INSPECT-PANE
			INSPECT-PANE-WITH-TYPEOUT INSPECT-TYPEOUT-WINDOW
			FOLLOW-LIST-STRUCTURE-BLINKER)

(DEFWINDOW-RESOURCE INSPECT-FRAME-RESOURCE ()
  :MAKE-WINDOW (INSPECT-FRAME))

;;; User interface

(DEFVAR-RESETTABLE *DEFAULT-INSPECTOR-FRAME* NIL)

(DEFUN INSPECT (&OPTIONAL OBJECT (FRAME *DEFAULT-INSPECTOR-FRAME*))
  (IF (NETI:REMOTE-TERMINAL-P)
      (FORMAT T "~&Currently, The inspector can only be used from the main console.~%")
    (FLET ((INSPECTOR (FRAME &OPTIONAL CLEAR)
	     (RESET-INSPECTOR-FRAME FRAME OBJECT CLEAR)
	     (CATCH-ERROR-RESTART ((ERROR ABORT) "Exit the inspector")
	       (WINDOW-CALL (FRAME :DEACTIVATE)
		 (INSPECT-TOP-LEVEL FRAME)))))
      (IF FRAME
	  (INSPECTOR FRAME)
	(USING-RESOURCE (FRAME INSPECT-FRAME-RESOURCE)
	  (INSPECTOR FRAME (NOT (NULL OBJECT))))))))

;;; Put it in the system menu
(ADD-TO-SYSTEM-MENU-PROGRAMS-COLUMN
  "Inspect" '(INSPECT) "Select an Inspector, to browse through data structure.")

;;; The Split Screen tool is declared to be a development tool, and hence is
;;; not included in the Delivery world.  Since its upper level functions are in
;;; the System (in sys:window;sysmen) its activiation, by being installed in
;;; the system menu, is somewhat arbitrarily placed here, since Inspect is also
;;; a Development tool and in an appropriate subsystem of Utilities.
(ADD-TO-SYSTEM-MENU-WINDOWS-COLUMN
  "Split Screen" (LAMBDA (MENU) (SYSTEM-MENU-SPLIT-SCREEN-VIA-MENUS
				  (MOUSE-SHEET (SHEET-MOUSE MENU))))
  "Create a split screen configuration.  Options from menu." "Select")

(DEFUN RESET-INSPECTOR-FRAME (FRAME &OPTIONAL OBJECT CLEAR)
  (LET ((HISTORY (SEND FRAME ':GET-PANE 'HISTORY)))
    (WITH-SHEET-DEEXPOSED (FRAME)
      (WHEN CLEAR
	(SEND HISTORY ':FLUSH-CONTENTS))
      (WHEN OBJECT
	(SEND HISTORY ':APPEND-ITEM OBJECT)
	(DOLIST (INSPECTOR (SEND FRAME ':INSPECTORS))
	  (SEND INSPECTOR ':SET-CURRENT-DISPLAY
		(SEND INSPECTOR ':SETUP
		      `(INSPECT-PRINTER NIL NIL NIL
					(NIL NIL NIL NIL
					 ,(LABEL-STYLE (SEND INSPECTOR ':LABEL))
					 "Empty"))))
	  (SEND INSPECTOR ':SET-CURRENT-OBJECT (NCONS NIL)))))
    (SEND (SEND FRAME ':TYPEOUT-WINDOW) ':MAKE-COMPLETE)
    (SEND HISTORY ':CLEAR-INPUT)))

(DEFUN INSPECT-FRAME-WITH-OWN-PROCESS-TOP-LEVEL (FRAME)
  (ERROR-RESTART-LOOP ((ERROR ABORT) "Exit the inspector")
    (INSPECT-TOP-LEVEL FRAME)
    (SEND FRAME :BURY)))

;;; The inspector top-level
(DEFUN INSPECT-TOP-LEVEL (FRAME &AUX USER IS HISTORY)
  (SI:WITH-COMMAND-LOOP-VARIABLE-BINDINGS
    (SEND (SETQ USER (SEND FRAME ':GET-PANE 'INTERACTOR)) ':CLEAR-WINDOW)
    (SEND (CAR (SETQ IS (SEND FRAME ':INSPECTORS))) ':FLUSH-TYPEOUT)
    (SETQ HISTORY (SEND FRAME ':GET-PANE 'HISTORY))
    ;; Flush remnants of modify mode
    (SEND HISTORY ':SET-SENSITIVE-ITEM-TYPES T)
    (DOLIST (I IS)
      (SEND I ':SET-MODIFY-MODE NIL))
    (LET ((SYM-TO-SET (IF (CHAR= (SI:PTTBL-SLASH READTABLE) #\\)
			  (INTERN "//")		;common lisp case
			  (INTERN "\")))	;zetalisp case
	  (THING)
	  (TOP-ITEM))
      (PROGV (LIST SYM-TO-SET) (LIST NIL)
	(SET SYM-TO-SET NIL)    
	(ERROR-RESTART ((ERROR ABORT) "Return to Inspector")
	  (LET ((TYPEOUT-WINDOW (SEND FRAME ':TYPEOUT-WINDOW)))
	    (DO-NAMED INSPECT-TOP-LEVEL
		      ((TERMINAL-IO TYPEOUT-WINDOW)
		       (STANDARD-INPUT SYN-TERMINAL-IO)
		       (STANDARD-OUTPUT SYN-TERMINAL-IO))
		      (())
	      (LET ((ITEMS (SEND HISTORY ':ITEMS))
		    (IW)
		    (IDX))
		(SETQ IDX (ARRAY-ACTIVE-LENGTH ITEMS))
		;; Make sure the inspection windows reflect the state of the history buffer
		(DOLIST (I IS)
		  ;; Update datastructure to reflect current TOP-ITEMs
		  (LET ((DISP (SEND I ':CURRENT-DISPLAY)))
		    (AND DISP (SETF (FOURTH DISP) (SEND I ':TOP-ITEM)))))
		(DOTIMES (I (LENGTH IS))
		  (SETQ IDX (1- IDX))
		  (SETQ IW (NTH I IS))
		  (COND ((< IDX 0)
			 (SEND IW ':SET-CURRENT-DISPLAY
			       (SEND IW ':SETUP
				     `(INSPECT-PRINTER NIL NIL NIL
						       (NIL NIL NIL NIL
							    ,(LABEL-STYLE (SEND IW ':LABEL))
							    "Empty"))))
			 (SEND IW ':SET-CURRENT-OBJECT (NCONS NIL)))
			(T (SEND HISTORY ':INSPECT-OBJECT (AREF ITEMS IDX) IW TOP-ITEM NIL T)
			   (SETQ TOP-ITEM NIL)))))
	      
	      ;; Insure last item in history is on the screen
	      (SEND HISTORY ':PUT-LAST-ITEM-IN-WINDOW)
	      
	      ;; Setup the value of * to be something useful
	      ;;--- See SI:SET-VALUE-FOR-* for an explanation...
	      (%P-STORE-CONTENTS (LOCF *) (SEND HISTORY ':LAST-ITEM))
	      
	      ;; Get input
	      (DO (FLAG CHAR) (())
		(SEND (CAR IS) ':FLUSH-TYPEOUT)
		(SEND FRAME ':SELECT-PANE USER)
		(SEND USER :FRESH-LINE)
		(WITH-INPUT-EDITING-OPTIONS ((:PREEMPTABLE :BLIP)
					     (:COMMAND 'CHAR= #\SUSPEND))
		  (MULTIPLE-VALUE (THING FLAG CHAR)
		    (READ-OR-CHARACTER '(#\C-Z #\ESCAPE #+cadr #\QUOTE) USER
				       'READ-AND-EVAL)))
		(SELECTQ FLAG
		  (:BLIP
		   (RETURN))
		  (:COMMAND
		   (SELECTOR (SECOND THING) CHAR=
		     (#\SUSPEND
		      (SEND FRAME ':SELECT-PANE (CAR IS))
		      (SEND TYPEOUT-WINDOW ':EXPOSE-FOR-TYPEOUT)
		      (LET ((TERMINAL-IO TYPEOUT-WINDOW))
			(BREAK INSPECT)))))
		  (:CHARACTER
		   (SELECTOR CHAR CHAR=
		     (#\C-Z
		      (RETURN-FROM INSPECT-TOP-LEVEL NIL))
		     ((#\ESCAPE #+cadr #\QUOTE)
		      (SEND USER :SET-CURSORPOS 0 NIL)
		      (FORMAT USER "Eval: ")
		      (MULTIPLE-VALUE (THING FLAG)
			(WITH-INPUT-EDITING-OPTIONS ((:FULL-RUBOUT :FULL-RUBOUT))
			  (READ-FORM USER)))
		      (COND ((EQ FLAG :FULL-RUBOUT)
			     (SEND USER :SET-CURSORPOS 0 NIL)
			     (SEND USER :CLEAR-REST-OF-LINE))
			    (T (MULTIPLE-VALUE (THING FLAG) (CATCH-ERROR (EVAL THING)))
			       (OR FLAG
				   (LET ((PRINLEVEL 3) (PRINLENGTH 5))
				     (SETQ * (PRINT THING USER)))))))))
		  (OTHERWISE
		   (SETQ * THING)
		   (SETQ THING `(:VALUE , * ,HISTORY))
		   (RETURN THING))))
	      
	      (SELECTQ (FIRST THING)
		(:MENU
		 (SETF (SECOND THING) (FUNCALL (FOURTH THING) ':EXECUTE (SECOND THING)))
		 (SELECTQ (SECOND THING)
		   (:EXIT (RETURN NIL))
		   (:RETURN
		    (MULTIPLE-VALUE-BIND (VALUE PUNT-P)
			(INSPECT-GET-VALUE-FROM-USER USER "Value to return: ")
		      (OR PUNT-P (RETURN VALUE))))
		   (:FLUSH-CACHE
		    (SEND HISTORY ':SET-CACHE NIL))
		   (:MODIFY
		    (SETQ TOP-ITEM (INSPECT-MODIFY-OBJECT USER HISTORY IS)))
		   (:CLEAR
		    (SEND HISTORY ':FLUSH-CONTENTS))
		   (:SET-\
		    (MULTIPLE-VALUE-BIND (VALUE PUNT-P)
			(INSPECT-GET-VALUE-FROM-USER USER
						     (FORMAT NIL "Value to set ~A to: "
							     SYM-TO-SET))
		      (UNLESS PUNT-P (SET SYM-TO-SET VALUE))))
		   (:TOGGLE-SOURCE-CODE
		    (SETQ TV:*PREFER-DISASSEMBLED-CODE* (NOT TV:*PREFER-DISASSEMBLED-CODE*))
		    (SEND HISTORY ':SET-CACHE NIL)
		    (FORMAT (SEND FRAME ':GET-PANE 'INTERACTOR)
			"~&Show compiled function ~:[source~;disassembled~] code"
		      TV:*PREFER-DISASSEMBLED-CODE*))
		   (OTHERWISE (FORMAT USER "~&Unimplemented menu command ~A~%"
				      (SECOND THING)))))
		(:VALUE
		 (SETQ THING (INSPECT-REAL-VALUE THING))
		 (INSPECT-FLUSH-FROM-HISTORY THING HISTORY)
		 (SEND HISTORY ':APPEND-ITEM THING))
		(:MOUSE-BUTTON
		 (BEEP))
		(OTHERWISE
		 (LET ((MOUSE-CLICK (FOURTH THING)))
		   (COND ((NULL (FIRST THING))
			  ;; Type is NIL -- nothing under mouse
			  (BEEP))
			 ((NOT (MOUSE-CHAR-P MOUSE-CLICK)))
			 ((AND (EQ (FIRST THING) ':LINE-AREA)
			       (CHAR-MOUSE-EQUAL MOUSE-CLICK #\MOUSE-2-1))
			  ;; Delete from line area
			  (SEND HISTORY ':FLUSH-OBJECT (INSPECT-REAL-VALUE THING)))
			 ((OR (NULL MOUSE-CLICK)
			      (CHAR-MOUSE-EQUAL MOUSE-CLICK #\MOUSE-1-1)
			      ;; Middle click is only valid from inspector panes, but might come
			      ;; from another window like the history.  In that case, treat it
			      ;; like left click.
			      (AND (CHAR-MOUSE-EQUAL MOUSE-CLICK #\MOUSE-2-1)
				   (NOT (MEMQ (THIRD THING) IS))))
			  (SETQ THING (INSPECT-REAL-VALUE THING))
			  (INSPECT-FLUSH-FROM-HISTORY THING HISTORY)
			  (SEND HISTORY ':APPEND-ITEM THING))
			 ((CHAR-MOUSE-EQUAL MOUSE-CLICK #\MOUSE-2-1)
			  ;; Middle click means leave source in one of the windows
			  (LET ((1ST-THING (INSPECT-REAL-VALUE THING))
				(2ND-THING (SEND (THIRD THING) ':CURRENT-OBJECT)))
			    ;; First flush item we will be inspecting
			    (INSPECT-FLUSH-FROM-HISTORY 1ST-THING HISTORY)
			    (INSPECT-FLUSH-FROM-HISTORY 2ND-THING HISTORY)
			    (SEND HISTORY ':APPEND-ITEM 2ND-THING)
			    (SEND HISTORY ':APPEND-ITEM 1ST-THING)))
			 ((CHAR-MOUSE-EQUAL MOUSE-CLICK #\MOUSE-3-1)
			  ;; Click on right button -- try to find function
			  (SETQ THING (INSPECT-FIND-FUNCTION (INSPECT-REAL-VALUE THING)))
			  (INSPECT-FLUSH-FROM-HISTORY THING HISTORY)
			  (SEND HISTORY ':APPEND-ITEM THING)))))))))))))

(DEFUN INSPECT-FLUSH-FROM-HISTORY (THING HISTORY)
  (LET ((ITEMS (SEND HISTORY ':ITEMS)))
    (DOTIMES (I (ARRAY-ACTIVE-LENGTH ITEMS))
      (AND (EQ THING (AREF ITEMS I))
	   (RETURN (SEND HISTORY ':DELETE-ITEM I))))))

(DEFUN INSPECT-REAL-VALUE (THING &AUX FUN)
  (IF (SETQ FUN (GET (FIRST THING) 'VALUE-FUNCTION))
      (FUNCALL FUN THING)
    (SELECTQ (FIRST THING)
      ((:VALUE :LINE-AREA 1D-ARRAY-SLOT LEADER-SLOT HASH-KEY) (SECOND THING))
      (:LOCATIVE (CDR (SECOND THING)))
      (:LIST-STRUCTURE-TOP-LEVEL (FUNCALL (THIRD THING) ':CURRENT-OBJECT))
      (:LIST-STRUCTURE (CDR (FIRST (SECOND THING))))
      (OTHERWISE (THIRD (SECOND THING))))))

(DEFUN INSPECT-GET-VALUE-FROM-USER (TERMINAL-IO PROMPT)
  (WITH-STACK-LIST (PROMPT "~&~A(type a form to be evaluated or select something with the mouse) "
			   PROMPT)
    (LOOP WITH STANDARD-INPUT = SYN-TERMINAL-IO
	  WITH STANDARD-OUTPUT = SYN-TERMINAL-IO
	  FOR THING = (SI:READ-CHARACTER TERMINAL-IO :ANY-TYI T :PROMPT PROMPT) DO
	  (COND ((LISTP THING)
		 (SELECTQ (FIRST THING)
		   (:MENU
		    (FORMAT T "~:|You cannot set the value from the menu."))
		   (:MOUSE-BUTTON
		    (SEND TERMINAL-IO :CLEAR-WINDOW)
		    (SI:TYI-BLIP-HANDLER THING TERMINAL-IO))
		   (OTHERWISE
		    ;; Choose something with the mouse -- display it truncated and proceed
		    (SETQ THING (INSPECT-REAL-VALUE THING))
		    (LET ((PRINLEVEL 3) (PRINLENGTH 5))
		      (FORMAT T "~S~&" THING))
		    (RETURN THING))))
		((CHARACTERP THING)
		 (SEND TERMINAL-IO :UNTYI THING)
		 (MULTIPLE-VALUE-BIND (THING ERROR)
		     (CATCH-ERROR (EVAL (READ-FORM)))
		   (UNLESS ERROR
		     (SEND TERMINAL-IO :FRESH-LINE)
		     (RETURN THING))))))))

(DEFUN INSPECT-MODIFY-OBJECT (TERMINAL-IO HISTORY &OPTIONAL (INSPECTORS NIL) &AUX THING OSIT)
  (SETQ OSIT (SEND HISTORY ':SENSITIVE-ITEM-TYPES))
  (UNWIND-PROTECT
    (PROGN
      (SEND HISTORY ':SET-SENSITIVE-ITEM-TYPES NIL)
      (DOLIST (I INSPECTORS)
	(SEND I ':SET-MODIFY-MODE T))
      (FORMAT TERMINAL-IO "~&Pick a slot, with the mouse, to modify")
      (SETQ THING (SEND TERMINAL-IO ':LIST-TYI)))
    (SEND HISTORY ':SET-SENSITIVE-ITEM-TYPES OSIT)
    (DOLIST (I INSPECTORS)
      (SEND I ':SET-MODIFY-MODE NIL)))
  (LET ((SET-FUNCTION (GET (FIRST THING) 'SET-FUNCTION)))
    (IF (OR (NULL (FIRST THING))
	    (NULL SET-FUNCTION)
	    (AND (MOUSE-CHAR-P (FOURTH THING))
		 (CHAR-MOUSE-EQUAL (FOURTH THING) #\MOUSE-3-1)))
	(FORMAT TERMINAL-IO "~&Aborted.~%")
	(MULTIPLE-VALUE-BIND (NEW-VALUE PUNT-P)
	    (INSPECT-GET-VALUE-FROM-USER TERMINAL-IO "New value: ")
	  (OR PUNT-P
	      (FUNCALL SET-FUNCTION THING NEW-VALUE
		       (FUNCALL (THIRD THING) ':CURRENT-OBJECT))))
	;; We must recompute object we modified
	(SEND HISTORY ':FLUSH-OBJECT-FROM-CACHE 
	      (FUNCALL (THIRD THING) ':CURRENT-OBJECT))
	(PROG1 (FUNCALL (THIRD THING) ':TOP-ITEM)
	       (FUNCALL (THIRD THING) ':SET-CURRENT-OBJECT (NCONS NIL))))))

(DEFUN INSPECT-FIND-FUNCTION (THING)
  (DO () (())
    (SETQ THING
	  (TYPECASE THING
	    (:SYMBOL
	     (IF (FBOUNDP THING)
		 (FSYMEVAL THING)
		 (RETURN THING)))
	    #+IGNORE	;---I don't know what this would mean in new flavor system
	    (:INSTANCE
	     (%INSTANCE-DESCRIPTOR-FUNCTION (%INSTANCE-FLAVOR THING)))
	    ((:CLOSURE #+CADR :ENTITY)
	     (CAR (%MAKE-POINTER DTP-LIST THING)))
	    (:LEXICAL-CLOSURE
	     (%P-CONTENTS-OFFSET THING 1))
	    (:LIST
	     (OR (SI:VALID-FUNCTION-DEFINITION THING) (RETURN THING)))
	    (OTHERWISE
	      (RETURN THING))))))

;;; Inspect commands

(CP:DEFINE-COMMAND (COM-INSPECT :COMMAND-TABLE "Inspection"
				:PROVIDE-OUTPUT-DESTINATION-KEYWORD NIL)
		   ((OBJECT 'STRING		;should eventually be :object
			    :PROMPT "object"
			    :PROVIDE-DEFAULT NIL
			    :DOCUMENTATION "Lisp object to examine in the Inspector"))
  ;; object needs to be a symbol.
  (LET ((OBJ OBJECT)
	(PKG))
    (IF (STRINGP OBJ)
	(LET ((TEM (STRING-SEARCH-CHAR #/: OBJ)))
	  (WHEN TEM
	    (SETQ PKG (SUBSTRING OBJ 0  TEM))
	    (SETQ OBJ (SUBSTRING OBJ (1+ TEM))))
	  (SETQ OBJ (INTERN-SOFT (STRING-UPCASE OBJ) PKG))
	  (IF OBJ
	      (IF (BOUNDP OBJ)
		  (INSPECT (SYMEVAL OBJ))
		(FORMAT T "~&Error: ~@[~A:~]~A is not bound."
			(IF PKG (STRING-UPCASE PKG)) OBJ))
	      (FORMAT T "~&Error: ~A is not an object in the system." OBJECT)))
      (INSPECT OBJ)))
  (SI:FRESH-TERPRI)
  (VALUES))

(TV:ADD-SELECT-KEY #/I 'INSPECT-FRAME "Inspector" 'INSPECT-FRAME-WITH-OWN-PROCESS)

