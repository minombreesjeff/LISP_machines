;;; -*- Syntax: Zetalisp; Mode: LISP; Package: TV; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

#|
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")HOW THE WHOLINE GETS SET UP AND MODIFIED
0Two scenarios:  initial construction;  user modification.

1Initial construction:
0  An system initialization in sys:window;cometh calls (window-initialize)
  window-initialize (in shwarm) calls initialize-screens
  initialize-screens (in lscreen) calls initialize-screens-internal
  initialize-screens-internal calls initialize-one-screen
  initialize-one-screen calls define-screen and setqs who-line-screen to the result;
	it then calls who-line-setup.
  who-line-setup (in wholin) uses data in who-line-template to find or construct
 	the individual windows (sheets) in the wholine area.  It also setqs some
	variables like nwatch-who-line-sheet, who-line-run-state-sheet etc.

1User modification:
0  The user commands :Set Status Line Options and :Set Mouse Documentation Options 
  set some of *who-line-control-variables*, then call reset-who-line.
  The user-profile (init file) form setq-who-line-control-variables
  is just like SETQ except that it typechecks the values, and calls reset-who-line.
  reset-who-line constructs a new who-line-template from the who-line-
	control-variables, and calls recompute-who-line-geometry.
  recompute-who-line-geometry locks out things like the mouse process, and calls
	initialize-screens, as above.
|#


;;;; Who-line-control-variables, and ways to change them

(defvar *who-line-control-variables* nil)

(cl:defstruct (who-line-control-variable
		(:constructor make-who-line-control-variable
			      (name status default documentation type invisible)))
  name
  status
  default
  documentation
  type
  invisible)

(defun add-who-line-control-variable (name status default documentation type invisible)
  (cl:check-type status (cl:member :status :documentation))
  (scl:pushnew (make-who-line-control-variable name status default documentation type
					       invisible)
	       *who-line-control-variables* :key #'who-line-control-variable-name :replace t))

(defmacro define-who-line-control-variable ((name status) default documentation type
					    &key invisible)
  `(progn
     (defvar ,name ,default ,documentation)
     (add-who-line-control-variable ',name ',status ,default ,documentation ,type
				    ',invisible)))


;;; Note that simply setting the following mouse-documentation-area and status-line
;;; control variables is not necessarily sufficient to effect their appropriate control.
;;;
;;; The variables defined with DEFVAR can be set with SETQ, but RESET-WHO-LINE must
;;; then be executed.
;;;
;;; The variables defined with DEFINE-WHO-LINE-CONTROL-VARIABLE should only be set
;;; with SETQ-WHO-LINE-CONTROL-VARIABLES (which automatically calls RESET-WHO-LINE to
;;; effect the changes in the mouse documentation and status line areas).
;;;
;;; If both classes of variables are to be set, then SETQing the DEFVAR variables be-
;;; fore the SETQ-WHO-LINE-CONTROL-VARIABLES variables will have the correct behavior.
;;;
;;; Example:
;;;
;;;   (SETQ *WHOLINE-DOCUMENTATION-BORDER-P* NIL)        ;No mouse doc area border
;;;   (SETQ-WHO-LINE-CONTROL-VARIABLES
;;;      *WHOLINE-DOCUMENTATION-REVERSE-VIDEO-P* NIL     ;Mouse doc area normal video
;;;      *SHOW-CURRENT-PROCESS-IN-WHOLINE* T)            ;Show active process

;;; The mouse documentation area control variables

(defconst *mouse-documentation-choice-order*	;Define appearance in Set Screen Options
	  '(*number-of-wholine-documentation-lines*
;	     *wholine-documentation-border-p*
	     *wholine-documentation-reverse-video-p*
	     *wholine-documentation-character-style*))


;;  Define the number of screen lines available to the mouse documentation area
(define-who-line-control-variable (*number-of-wholine-documentation-lines* :documentation) 2
  "Mouse documentation area height"
  '((cl:integer 0 2)))


;;  Control the presence of the border encompassing the mouse documentation area.
;;    A value of T turns on the border; NIL turns the border off.
(define-who-line-control-variable (*wholine-documentation-border-p* :documentation) t
  "Mouse documentation area border"
  '((scl:alist-member :alist (("On" :value t
			       :documentation
			       "Turns on box around mouse documentation area")
			      ("Off" :value nil
			       :documentation
			       "Turns off box around mouse documentation area")
			      )))
  :invisible t)


;;  Control the mouse documentation area "video" appearance relative to the main screen.
;;    A value of T sets the mouse documentation area to the "reverse" of the main screen;
;;    a value of NIL sets the mouse documentation area to be the same as the main screen.
(define-who-line-control-variable (*wholine-documentation-reverse-video-p* :documentation) t
  "Mouse documentation area background"
  '((scl:alist-member :alist (("Reverse" :value t	;reverse=black=T
			       :documentation
			       "Mouse documentation area `reverse' of main screen video")
			      ("Normal" :value nil
			       :documentation
			       "Mouse documentation area same as main screen video")
			      ))))


;;  Define the mouse documentation area character style.
(define-who-line-control-variable (*wholine-documentation-character-style* :documentation)
				  (si:parse-character-style '(:swiss :bold-condensed-caps :normal))
  "Mouse documentation area character style"
  `((scl:character-style-for-device :device ,si:*b&w-screen* :allow-relative nil)))



;;; The Status Line control variables

(defconst *status-line-choice-order*		;Define appearance in Set Screen Options
	  '(*wholine-default-character-style*
	    *wholine-clock-format*
	    *wholine-clock-24hour-p*
	    *wholine-clock-delimiters*
	    *wholine-clock-colon-blink-half-period*
	    *show-current-process-in-wholine*
	    *show-machine-name-in-wholine*
	    *wholine-file-state-character-style*
	    *note-progress-in-wholine*
	    ))

;; The default character style for the whole who line.
(define-who-line-control-variable (*wholine-default-character-style* :status)
				  (si:parse-character-style '(:fix :roman :normal))
  "Status area character style"
  `((scl:character-style-for-device :device ,si:*b&w-screen* :allow-relative nil)))

;;  Show the machine name in the who-line progress field, unless there's a file transfer
;;  or other "in progress" notice to display.
(define-who-line-control-variable (*show-machine-name-in-wholine* :status) nil
  "Machine name"
  '((scl:alist-member :alist (("Visible" :value t
			       :documentation
			       "Shows the machine name as the progress area default")
			      ("Invisible" :value nil
			       :documentation "Does not show the machine name anywhere")))))


;;  If a process is currently running, show its name in the who-line instead of the user id
(define-who-line-control-variable (*show-current-process-in-wholine* :status) nil
  "Process display"
  '((scl:alist-member :alist (("User name" :value nil
			       :documentation "Shows the user name as part of status")
			      ("Process name" :value t
			       :documentation
			       "Shows the name of the currently running process")))))


;;  Control display of the "in progress" notice.
;;    A value of T displays the progress notice on a separate line, with a large black
;;    (i.e., "reverse video") progress bar; NIL suppresses the "in progress" display;
;;    and :WITH-FILE displays the progress notice in the status line, with an "underline"
;;    progress bar.
(define-who-line-control-variable (*note-progress-in-wholine* :status) :with-file
  "Progress area"
  '((scl:alist-member :alist (("Wide bar" :value t
			       :documentation
			       "Shows a broad black band to indicate progress on current tasks")
			      ("No display" :value nil
			       :documentation "Does not display progress indicators")
			      ("Text and thin bar" :value :with-file
			       :documentation
			       "Shows textual and graphic description of progress on current tasks")))))


;;  Control the format of the daytime clock display in the status line.
;;    See the following definition for defined formats and values.
(define-who-line-control-variable (*wholine-clock-format* :status) :dow-hh-mm-ss
  "Status line time display"
  '((scl:alist-member :alist (("Mon 31 Jan 11:59:59" . :dow-hh-mm-ss)
			      ("12//31//89 23:59:59" . :month-day-year)
			      ("Mon 31 Jan 11:59pm" . :dow-hh-mm-am)
			      ))))


;;  Control the display of a 12 or 24 hour clock.
;;    A value of T displays the time in 24 hour format; NIL displays 12 hour format.
;;
;;  (Note that the :MONTH-DAY-YEAR clock format is unaffected by *WHOLINE-CLOCK-24HOUR-P*
;;  and always displays in 24 hour format.)
(define-who-line-control-variable (*wholine-clock-24hour-p* :status) nil
  "Status line time in 12//24 hour format"	;Doesn't affect :month-day-year
  '((scl:alist-member :alist (("12-hour" :value nil
			       :documentation
			       "Selects 12 hour time display")
			      ("24-hour" :value t
			       :documentation
			       "Selects 24 hour time display")
			      )))
  :invisible t)


;;  Control whether or not to surround the status line clock with "delimiter" characters.
;;    A value of T says to enclose the clock field with "[" and "]" characters;
;;    a value of 0 says to enclose the clock field with extra space characters; and
;;    a value of NIL says to leave the clock field alone, no extra characters.
(define-who-line-control-variable (*wholine-clock-delimiters* :status) t
  "Status line time delimiter characters"	;Doesn't affect :month-day-year
  '((scl:alist-member :alist (("[]" . t)
			      ("spaces" . 0)
			      ("none" . nil)
			      )))
  :invisible t)


;;  Controls how rapidly (in seconds) the colon character blinks ( :  . ) in the
;;  :DOW-HH-MM-AM clock format.
(define-who-line-control-variable (*wholine-clock-colon-blink-half-period* :status) 1
  "Clock colon blink half period"
  '((scl:token-or-type (nil) time:time-interval)))


;;  Controls the character style used in the "in progress" field display
(define-who-line-control-variable (*wholine-file-state-character-style* :status)
				  (si:parse-character-style '(:fix :extra-condensed :normal))
  "Progress area character style"
  `((scl:character-style-for-device :device ,si:*b&w-screen* :allow-relative nil)))


(defmacro setq-who-line-control-variables (&rest vars-and-vals)
  `(set-who-line-control-variables
     ,@(loop for (var val) on vars-and-vals by #'rest2
	     collect `',var
	     collect val)))

(defun (:property tv:setq-who-line-control-variables :undo-function) (form)
  `(setq-who-line-control-variables
     ,@(do ((pairs (cdr form) (cddr pairs))
	    (result '() (list* `',(symeval (car pairs)) (car pairs) result)))
	   ((null pairs) (nreverse result)))))

#| Example
(setf (who-line-control-variables *wholine-file-state-character-style* *wholine-clock-format*)
      (values z :dow-hh-mm-ss))
|#

(cl:define-setf-method who-line-control-variables (&rest who-variables)
  (loop for who-var in who-variables
	as this-temp = (gensym)
	collect this-temp into store-vars
	collect `(quote ,who-var) into store-list
	collect this-temp into store-list
	collect this-temp into values-list
	finally
	  (return
	    (values ()
		    ()
		    store-vars
		    `(multiple-value-prog1 (values ,@values-list)
					   (set-who-line-control-variables ,@store-list))
		    `(values ,@who-variables)))))

;; Returns T when it changed something.
(defun set-who-line-control-variables-internal (&rest vars-and-vals)
  ;;+++ There is room for replacing the ferrors here with more proceedable versions.
  ;; First verify all variables and value types, then setq the variables, then reset-who-line.
  (let (vars-to-set vals-to-set-to)
    (when
      (catch-error-restart (error "Skip setting any variables")
	(loop for (variable value) on vars-and-vals by #'rest2
	      do (catch-error-restart (error "Skip setting ~s" variable)
		   (let* ((struct (or (cl:find variable *who-line-control-variables*
					       :key #'who-line-control-variable-name)
				      (ferror "The variable ~s is not a declared ~
						who-line-control-variable"
					      variable)))
			  (type (who-line-control-variable-type struct)))
		     (unless (dw::ptypep value type)
		       (ferror "The value provided for the who-line-control variable ~s,~@
					~s, is not of type ~s"
			       variable value type))
		     ;; Don't bother to set it to the same value it already has.
		     (unless (equal (symeval variable) value)
		       (push variable vars-to-set)
		       (push value vals-to-set-to)))))
	T)
      (unless (null vars-to-set)
	(cl:map nil #'set vars-to-set vals-to-set-to)
	T))))

(defun set-who-line-control-variables (&rest vars-and-vals)
  (when (apply #'set-who-line-control-variables-internal vars-and-vals)
    (reset-who-line)
    T))

(defun choose-status-line-options (kind &optional (indentation 2))
  (let ((ordered-choices (cl:ecase kind
			   (:documentation *mouse-documentation-choice-order*)
			   (:status *status-line-choice-order*))))
    (flet ((ask-one (var)
	     (let ((variable (who-line-control-variable-name var)))
	       (unless (who-line-control-variable-invisible var)
		 (list variable
		       (accept (who-line-control-variable-type var)
			       :prompt (format nil "~vX~A" indentation
					       (who-line-control-variable-documentation var))
			       :default (symeval variable)
			       :provide-default t))))))
      (nconc (loop for name in ordered-choices
		   nconc (ask-one (cl:find name *who-line-control-variables*
					   :key #'who-line-control-variable-name)))
	     (loop for var in *who-line-control-variables*
		   when (and (not (memq (who-line-control-variable-name var) ordered-choices))
			     (eq (who-line-control-variable-status var) kind))
		     nconc (ask-one var))))))

;;;; Constructing who-line-template, and using it

(defconst *mouse-documentation-line-margin-decoration*
	  `((dw:margin-pattern :margin :bottom :thickness 1 :pattern :black)
	    (dw:margin-white-borders )
	    (dw:margin-whitespace :margin :left :thickness 4)
	    ))

(defconst *mouse-documentation-line-margin-noborder*
	  `((dw:margin-whitespace :margin :top :thickness 1)
	    ;(dw:margin-borders )
	    (dw:margin-whitespace :margin :left :thickness 4)
	    ))

(defun default-construct-who-line-template (device-type &optional max-width)
  (let ((template nil)
	(pixel-row 0))
    (flet ((style-size (style)
	     (declare (values width height))
	     (let ((font (si:get-font device-type si:*standard-character-set* style)))
	       (values (let ((cwt (font-char-width-table font)))
			 (if cwt
			     ;; Average looks better for variable-width
			     ;; fonts, even if not 100% accurate 
			     (loop for width being the array-elements of cwt
				   when (and width (plusp width))
				     sum width into total-width
				     and count t into nchars
				   finally (return (round total-width nchars)))
			     (font-char-width font)))
		       (font-char-height font))))
	   (add-field (fields)
	     (setf template (nconc template (ncons fields)))))
      ;;
      (multiple-value-bind (default-char-width default-char-height)
	  (style-size *wholine-default-character-style*)
	;;
	(when (eql *note-progress-in-wholine* 't)
	  (add-field
	    `(:progress
	       :top ,pixel-row :left 0 :height ,default-char-height :width :end
	       :function who-line-note-progress))
	  (incf pixel-row (+ 2 default-char-height)))
	;;
	(when (plusp *number-of-wholine-documentation-lines*)
	  (multiple-value-bind (ignore line-height)
	      (style-size *wholine-documentation-character-style*)
	    (let ((height (+ 3 -2 ;;The 3 is for the margin.  See :margin-components.
			     (* (+ 2 line-height) *number-of-wholine-documentation-lines*))))
	      (add-field
		`(:mouse-documentation
		   :top ,pixel-row :left 0
		   :height ,height
		   :width :end
		   :reverse-video-p ,*wholine-documentation-reverse-video-p*
		   :default-character-style ,*wholine-documentation-character-style*
		   :function who-line-documentation-function
		   :margin-components
		   ,(if *wholine-documentation-border-p*
		        *mouse-documentation-line-margin-decoration*
		        *mouse-documentation-line-margin-noborder*)
		   ))
	      (incf pixel-row height))))
	;;
	(let ((column 0)
	      ;; Allow for whichever is larger -- default or file
	      (max-subfield-height (max default-char-height
					(multiple-value-bind (nil line-height)
					    (style-size *wholine-file-state-character-style*)
					  line-height))))
	  (labels ((add-subfield-internal (name width char-width rest)
		     (let ((wid (if (eql width :end) width (* width char-width))))
		       (add-field `(,name :top ,pixel-row :left ,column
				    :height ,max-subfield-height
				    :width ,wid
				    ,@(cl:copy-list rest)))
		       (unless (symbolp wid)
			 (incf column wid))))
		   (add-subfield (name width &rest rest)
		     (add-subfield-internal name width default-char-width rest))
		   (add-subfield-6 (name width &rest args)
		     (when max-width
		       (scl:minf width (// max-width (* default-char-width 6))))
		     (lexpr-funcall #'add-subfield name width args)))
	    ;; Try to keep run-state in same place for all clock formats
	    ;; and align things so the run-state and run-bar line up 
	    (cl:ecase *wholine-clock-format*
	      ((:dow-hh-mm-ss)
	       (add-subfield :time (+ 21 (if *wholine-clock-delimiters* 1 0))
			     :function 'wwatch-who-function)
	       (add-subfield-6 :user (+ 22 (if *wholine-clock-delimiters* -1 0))
			       :function 'who-line-user-or-process))
	      ((:dow-hh-mm-am)
	       (add-subfield :time (+ 20 (if *wholine-clock-delimiters* 1 0))
			     :function 'wwatch-who-function)
	       (add-subfield-6 :user (+ 23 (if *wholine-clock-delimiters* -1 0))
			       :function 'who-line-user-or-process))
	      ((:month-day-year)
	       (add-subfield :time 19
			     :function 'nwatch-who-function)
	       (add-subfield-6 :user 24
			       :function 'who-line-user-or-process)))
	    (add-subfield-6 :package 17 :function 'who-line-package :align :right)
	    (add-subfield-6 :run-state 28 :function 'who-line-run-state :align :left)
	    (add-subfield :file-state :end
			  :default-character-style *wholine-file-state-character-style*
			  :flavor 'who-line-file-sheet)
	    (incf pixel-row max-subfield-height)))
	(add-field
	  `(:run-line
	     :top ,pixel-row :left 0 :height 3 :width :end))
	(incf pixel-row 3)))
    template))

(defun reset-who-line (&optional ignore screen)
  (if screen
      (recompute-who-line-geometry screen)
      (mapc #'recompute-who-line-geometry all-the-screens)))

(defun who-line-total-height (template)
  (loop for field in template
	maximize (+ (who-line-field-value field :top) (who-line-field-value field :height))))

;;;; Flavors and general methods; finding and altering who-line-fields

(defconst *who-line-process-priority*
	  (process:make-process-priority :deadline 500000. :preemptive nil))

(defmethod (make-instance generic-who-line-screen-mixin) (&key &allow-other-keys)
  (setf update-process
	(process:make-process "Update Status Line" :priority *who-line-process-priority*
			      :initial-function #'who-line-screen-update-top-level
			      :verify-function #'who-line-screen-update-predicate
			      :top-level-whostate "Update Status Line"
			      :simple-p t :run-reasons nil :warm-boot-action nil
			      :flags '(:system-process t :no-run-light t :no-kbd-arrest t)))
  ;; No #' in these timer functions, because of process::*optimized-timer-functions*
  (let ((args (list self)))
    (setf update-timer
	  (process:create-timer-call 'who-line-screen-update args
				     :name "Status Line Update"
				     :priority *who-line-process-priority*))
    (setf mouse-documentation-update-timer
	  (process:create-timer-call 'who-line-screen-mouse-documentation-update args 
				     :name "Mouse Documentation Update"
				     :priority *who-line-process-priority*))))

(defmethod (who-line-screen-enable generic-who-line-screen-mixin) ()
  (process:process-reset-and-enable update-process)
  (who-line-screen-update self))

(defmethod (who-line-screen-disable generic-who-line-screen-mixin) ()
  (process:process-kill update-process))

(defmethod (who-line-screen-force-process generic-who-line-screen-mixin) ()
  (if (eq self who-line-screen)
      who-line-process
      force-process))

(defmethod ((cl:setf who-line-screen-force-process) generic-who-line-screen-mixin) (process)
  (if (eq self who-line-screen)
      (setf who-line-process process)
      (setf force-process process)))

(defmethod (who-line-screen-last-process generic-who-line-screen-mixin) ()
  (if (eq self who-line-screen)
      last-who-line-process
      last-process))

(defmethod ((cl:setf who-line-screen-last-process) generic-who-line-screen-mixin) (process)
  (if (eq self who-line-screen)
      (setf last-who-line-process process)
      (setf last-process process)))

(defconst *no-window-alternate-wholine-string* "(no window)"
  "This is the string displayed by processes not associated with a window.
You can bind this with something like the following:
  (let-globally ((tv:*no-window-alternate-wholine-string* /"Selecting Activity/"))
    (cp:execute-command /"select activity/" /"zmail/"))
This is also useful if you have some program that changes its pane configuration:
You can have the wholine say `(Changing Configuration)', for example.")

;;; Decide what process the wholine is looking at and capture its state
(defmethod (screen-get-who-line-process generic-who-line-screen-mixin) ()
  (let* ((console (sheet-console self))
	 (process (or (if (eq self who-line-screen) who-line-process force-process)
		      (when console
			(let ((io-buffer (console-get-selected-io-buffer console t)))
			  (and io-buffer (io-buffer-last-output-process io-buffer))))))
	 (state (cond ((null process)
		       (if (and console (console-selected-window console))
			   "(no process)"
			   (if (and (boundp '*no-window-alternate-wholine-string*)
				    (stringp *no-window-alternate-wholine-string*)
				    (not (= (string-length *no-window-alternate-wholine-string*) 0)))
			       *no-window-alternate-wholine-string*
			       "(no window)")))
		      ((process::process-active-p process)
		       (process::process-whostate process))
		      ((not (null (process:process-arrest-reasons process)))
		       "Arrest")
		      ((null (process:process-run-reasons process))
		       "Stopped")
		      ((memq process process::*all-processes*)
		       (string (process::process-state process)))
		      (t "(dead process)"))))
    (setq last-process process)
    (send (get-who-line-field :run-state self) :set-who-line-extra-state state)
    (when (eq self who-line-screen)
      ;; Separate variable since other can be setq'ed asynchronously by other processes
      (setq last-who-line-process process)
      (setq who-line-run-state state))
    process))

(defmethod (who-line-run-light-loc generic-who-line-screen-mixin :default) () nil)

(defmethod (:user-visible generic-who-line-screen-mixin) () nil)

(defmethod (:console generic-who-line-screen-mixin) () (send parent-screen :console))

;;;

(defflavor who-line-screen
	()
	(generic-who-line-screen-mixin
	 gray-main-screen-borders-mixin gray-unused-areas-mixin
	 single-bit-screen-mixin screen)
  (:default-init-plist
   :gray-array-for-unused-areas :white
   :property-list (list :video :black-and-white
			:controller :remote
			:who-line t)))

(defflavor multi-bit-who-line-screen
	()
	(generic-who-line-screen-mixin
	 gray-main-screen-borders-mixin gray-unused-areas-mixin
	 multi-bit-screen-mixin screen)
  (:default-init-plist
   :gray-array-for-unused-areas :white
   :property-list (list :video :black-and-white
			:controller :remote
			:who-line t)))

#+imach
(defflavor single-bit-vme-direct-who-line-screen
	()
	(vme-direct-graphics-mixin who-line-screen))

#+Imach
(defflavor multi-bit-vme-direct-who-line-screen
	()
	(vme-direct-graphics-mixin multi-bit-who-line-screen))



(defflavor who-line-mixin ((who-line-item-state nil)) ()
				;WHO-LINE-ITEM-STATE is NIL if the contents of the window
				;is unknown and needs to be redrawn.  If non-NIL it
				;represents the current contents, to avoid extra redisplay.
  (:required-flavors minimum-window)
  (:default-init-plist :more-p nil :blinker-p nil :auto-line-height nil)
  (:required-methods :update)
  (:method-order :update)
  (:init-keywords :flavor)
  :initable-instance-variables
  :settable-instance-variables
  :gettable-instance-variables)

(defwrapper (:update who-line-mixin) (ignore . body)
  `(maybe-lock-sheet
     self
     (unless (sheet-output-held-p self)
       ;; This catch is just a last ditch.  The specific output
       ;; method should really catch it.
       (catch 'skip-who-line-update . ,body))
     nil))

(defmethod (:refresh who-line-mixin :after) (&optional type)
  (unless (and restored-bits-p (neq type ':size-changed))
    (send self :clobbered)
    (send self :update)))

;;; Easier to update the whole thing than just the clobbered rectangle
(defmethod (refresh-rectangle who-line-mixin) (left top right bottom)
  (ignore left top right bottom)
  (send self :clobbered)
  (send self :update)
  (refresh-margins-rectangle self left top right bottom))

;;; Should this actually do the updates here??
(defmethod (:clobbered who-line-mixin) ()
  (setq who-line-item-state ':clobbered))

(defwhopper-subst (:string-out who-line-mixin) (&rest args)
  (catch 'skip-who-line-update
    (lexpr-continue-whopper args)))

(defwhopper-subst (:tyo who-line-mixin) (&rest args)
  (catch 'skip-who-line-update
    (lexpr-continue-whopper args)))

(defmethod (:end-of-line-exception who-line-mixin) ()
  (throw 'skip-who-line-update nil))

(defmethod (:end-of-page-exception who-line-mixin) ()
  (throw 'skip-who-line-update nil))

(defflavor who-line-sheet
	((who-line-update-function nil) (who-line-extra-state nil))
	(dw:margin-mixin who-line-mixin minimum-window)
  (:default-init-plist :margin-components nil)
  :initable-instance-variables
  :settable-instance-variables
  :gettable-instance-variables)

(defmethod (:init who-line-sheet :before) (plist)
  (putprop plist (get plist ':who-line-update-function) ':name))

(defmethod (:update who-line-sheet) ()
  (when who-line-update-function
    (multiple-value (who-line-item-state who-line-extra-state)
      (funcall who-line-update-function self who-line-item-state who-line-extra-state))))

(defsubst who-line-field-value (field indicator)
  (get field indicator))

(defun get-who-line-field (name-or-window &optional (who-screen who-line-screen))
  (declare (values window field-descriptor))
  (when who-screen
    (when (instancep name-or-window)
      (setq name-or-window (loop for field in (who-line-screen-who-line-fields who-screen)
				 when (eq (second field) name-or-window)
				   return (first field))))
    (values (second (assq name-or-window (who-line-screen-who-line-fields who-screen)))
	    (assq name-or-window (who-line-screen-who-line-template who-screen)))))

(defun map-over-who-line-fields (function &optional (who-screen who-line-screen))
  (declare (sys:downward-funarg function))
  (loop for field in (who-line-screen-who-line-fields who-screen)
	do
    (funcall function
	     ;; the sheet
	     (second field)
	     ;; the template
	     (assq (first field) (who-line-screen-who-line-template who-screen))
	     )))

(defun set-who-line-field (name who-screen value)
  (let ((old (assq name (who-line-screen-who-line-fields who-screen))))
    (if old
	(setf (second old) value)
	(push (list name value) (who-line-screen-who-line-fields who-screen)))))

(cl:defsetf get-who-line-field set-who-line-field)


#||
;;; When the who-line windows are overlapping or something, this debugging
;;; function helps you see what's going on.
(defun bark (&optional (who-screen who-line-screen))
  (flet ((wlessp (x1 x2)
	   (multiple-value-bind (l1 t1 r1 b1) (send (second x1) :edges)
	     (multiple-value-bind (l2 t2 r2 b2) (send (second x2) :edges)
	       (cond ((< t1 t2) t)
		     ((> t1 t2) ())
		     ((< l1 l2) t)
		     ((> l1 l2) ())
		     ((< b1 b2) t)
		     ((> b1 b2) ())
		     ((< r1 r2) t)
		     (t ()))))))
    (loop for (name window) in (sort (copylist (who-line-screen-who-line-fields who-screen))
				     #'wlessp)
	  do (multiple-value-bind (ll tt rr bb) (send window :edges)
	       (format t "~&~20a ~9<~4d:~d~;~> ~9<~4d:~d~;~> ~a ~(~a~)"
		       name ll rr tt bb window (send window :status))))))
||#




(defun add-active-who-line-screen (screen)
  (send screen :expose)				;This doesn't really need to refresh.
  (when (send screen :exposed-p)
    (send screen :refresh)
    (without-interrupts
      (cl:pushnew screen *active-who-line-screens*))
    (who-line-screen-enable screen)
    (when (eq screen who-line-screen)
      (setq who-line-run-light-loc (who-line-run-light-loc screen))
      #+3600 (when (locativep who-line-run-light-loc)
	       (setf who-line-run-light-loc (%pointer who-line-run-light-loc))))))

(defun remove-active-who-line-screen (screen)
  (who-line-screen-disable screen)
  (without-interrupts
    (setf *active-who-line-screens* (delq screen *active-who-line-screens*)))
  (when (eq screen who-line-screen)
    (setq who-line-run-light-loc nil))
  (send screen :deactivate))

;; This is papering over brain damage in tv:who-line-setup and in the MacIvory
;; who-line-screen flavor inheriting from the main-screen flavor, which is just wrong
(defmethod (:appropriate-hardware-p generic-who-line-screen-mixin) ()
  t)	;wholines don't use the :appropriate-hardware-p mechanism


;;;; Use who-line-template to make the who-line sheets

(defun who-line-setup (&optional (who-screen who-line-screen)
				 (update-global-variables t))
  (send who-screen :set-default-character-style *wholine-default-character-style*)
  (multiple-value-bind (lmarg ignore rmarg ignore)
      (send who-screen :inside-edges)
    (loop with arglist
	  for f in (who-line-screen-who-line-template who-screen)
	  as name = (car f)
	  as window = (get-who-line-field name who-screen)
	  as default-style-field = (who-line-field-value f :default-character-style)
	  as default-style = (if default-style-field
				 (si:parse-character-style default-style-field)
				 (screen-default-style who-screen))
	  as top = (who-line-field-value f :top)
	  as left = (who-line-field-value f :left)
	  as height = (who-line-field-value f :height)
	  as width = (who-line-field-value f :width)
	  as flavor = (who-line-field-value f :flavor)
	  as function = (who-line-field-value f :function)
	  as reverse-video-p = (who-line-field-value f :reverse-video-p)
	  as margin-components = (who-line-field-value f :margin-components)
	  as align = (who-line-field-value f :align)
	  do (incf left lmarg)
	     ;; Using a very large font may cause some windows to go off
	     ;; the screen
	     (scl:minf left rmarg)
	     (if (eq width :end)
		 (setq width (- rmarg left))
		 (scl:minf width (- rmarg left)))
	     (when (member align '(:right :both))
	       (multiple-value-bind (nil error)
		   (round (+ left width)
			  (// 32. (screen-bits-per-pixel who-screen)))
		 (decf width error)))
	     (when (member align '(:left :both))
	       (multiple-value-bind (nil error)
		   (round left
			  (// 32. (screen-bits-per-pixel who-screen)))
		 (decf left error)
		 (incf width error)))
	     (setq arglist `(:top ,top :left ,left :height ,height :width ,width))
	     (cond (window
		    ;;---Check for change of flavor?
		    (send window :set-default-style default-style)
		    (lexpr-send window :change-of-size-or-margins arglist)
		    (when (and function
			       (neq function (send window :who-line-update-function)))
		      (send window :set-who-line-update-function function)
		      (send window :set-who-line-extra-state nil)
		      (send window :clobbered))
		    (when margin-components
		      (send window :set-margin-components margin-components))
		    (send window :set-reverse-video-p reverse-video-p)
		    (send window :expose))
		   (t
		    (macrolet ((extend-arglist (&rest variables)
				 `(progn
				    ,@(loop for (var keyword) in variables
					    collect `(when ,var
						       (setq arglist
							     (list* ,keyword ,var
								    arglist)))))))
		      (extend-arglist (flavor :flavor)
				      (function :who-line-update-function)
				      (reverse-video-p :reverse-video-p)
				      (margin-components :margin-components)
				      (default-style :default-style)))
		    (setf (get-who-line-field name who-screen) 
			  (lexpr-funcall #'who-line-field :superior who-screen arglist)))))
    (when update-global-variables
      ;; Compatibility
      (setq who-line-screen who-screen
	    nwatch-who-line-sheet (get-who-line-field :time)
	    who-line-run-state-sheet (get-who-line-field :run-state)
	    who-line-file-state-sheet (get-who-line-field :file-state)
	    who-line-documentation-window (get-who-line-field :mouse-documentation)))
    (add-active-who-line-screen who-screen)
    who-screen))

(defun who-line-field (&rest args &key (flavor 'who-line-sheet) &allow-other-keys)
  ;; Do sheet type consing in special area to increase locality
  (let ((w (lexpr-funcall #'make-window flavor :area who-line-area :vsp 0 args)))
    (send w :activate)
    (send w :expose)
    w))



(defmacro with-screen-safe ((screen &key deexpose) &body body)
  `(with-screen-safe-internal ,screen #'(lambda () ,@body) ,deexpose))

(defun with-screen-safe-internal (screen continuation deexpose)
  (declare (sys:downward-funarg continuation))
  (delaying-screen-management
    (sys:without-aborts ("Screen data structures may be inconsistent.")
      (let ((mouse (sheet-mouse screen)))
	(flet ((doit ()
		 (when deexpose
		   (send screen :deexpose))
		 (lock-sheet (screen)
		   (let ((who-screen (screen-who-line-screen screen)))
		     (cond (who-screen
			    (remove-active-who-line-screen who-screen)
			    (lock-sheet (who-screen)
			      (funcall continuation)))
			   (t
			    (funcall continuation)))))))
	  (if (and deexpose (sheet-me-or-my-kid-p (mouse-sheet mouse) screen))
	      (with-this-mouse-usurped (mouse)
		(setf (mouse-sheet mouse) nil)
		(doit))
	      (doit)))))))

(defun screen-edges-and-margins-with-who-line (screen)
  (declare (values left top right bottom left-margin top-margin right-margin bottom-margin
		   includes-wholine))
  (let ((includes-wholine nil))
    (multiple-value-bind (left top right bottom)
	(send screen :edges)
      (multiple-value-bind (left-margin top-margin right-margin bottom-margin)
	  (send screen :margins)
	(let ((who-screen (screen-who-line-screen screen)))
	  (when (and who-screen
		     (eql (send who-screen :buffer) (send screen :buffer)))
	    (multiple-value-bind (who-left who-top who-right who-bottom)
		(send who-screen :edges)
	      (when (and (= who-left left)
			 (= who-top bottom)
			 (= who-right right))
		(setf bottom who-bottom)
		(setf bottom-margin (sheet-bottom-margin-size who-screen))
		(setf includes-wholine t)))))
	(values left top right bottom left-margin top-margin right-margin bottom-margin
		includes-wholine)))))

(defun enable-who-line (screen template)
  (multiple-value-bind (left top right bottom
			left-margin-size top-margin-size right-margin-size bottom-margin-size)
      (screen-edges-and-margins-with-who-line screen)
    top-margin-size
    (let* ((who-size (who-line-total-height template))
	   (who-screen (screen-who-line-screen screen)))
      (with-screen-safe (screen)
	;; Resize (or create) the who line.
	(cond (who-screen
	       (change-screen-shape who-screen (send screen :buffer)
				    (- right left) (+ who-size bottom-margin-size)
				    (screen-bits-per-pixel screen))
	       (send who-screen :change-of-size-or-margins
		     :top (- bottom who-size bottom-margin-size) :top-margin-size 0
		     :bottom bottom :bottom-margin-size bottom-margin-size
		     :left left :left-margin-size left-margin-size
		     :right right :right-margin-size right-margin-size))
	      (t
	       (setf who-screen
		     (make-window (who-line-screen-flavor screen) :superior nil
				     :area who-line-area :name "Who Line Screen" :vsp 0
				     :parent-screen screen
				     :who-line-template template
				     :buffer (send screen :buffer)
				     :bits-per-pixel (send screen :bits-per-pixel)
				     :top (- bottom who-size bottom-margin-size)
				     :top-margin-size 0
				     :bottom bottom :bottom-margin-size bottom-margin-size
				     :left left :left-margin-size left-margin-size
				     :right right :right-margin-size right-margin-size))
	       (setf (screen-who-line-screen screen) who-screen)))
	;; Set it up and expose it.
	(who-line-setup who-screen nil)
	;; Resize the main screen.
	(send screen :change-of-size-or-margins :top top
	      :bottom (- bottom who-size bottom-margin-size) :bottom-margin-size 0)))))

(defun disable-who-line (screen)
  (multiple-value-bind (left top right bottom
			left-margin-size top-margin-size right-margin-size bottom-margin-size
			includes-wholine)
      (screen-edges-and-margins-with-who-line screen)
    left right left-margin-size top-margin-size right-margin-size
    (when includes-wholine
      (with-screen-safe (screen)
	(send screen :change-of-size-or-margins
	      :top top :bottom bottom :bottom-margin-size bottom-margin-size)))))

(defun recompute-who-line-geometry (screen)
  (when (not (typep screen 'generic-who-line-screen-mixin))
    (if (memq screen *console-screens*)
	(with-screen-safe (screen)
	  (without-interrupts
	    (initialize-one-screen screen (sheet-console screen) (eq screen main-screen))))
	(if (send screen :get :who-line)
	    (let ((template (default-construct-who-line-template
			      (sheet-display-device-type screen)
			      (sheet-inside-width screen))))
	      (enable-who-line screen template))
	    (disable-who-line screen)))))

(defun recompute-and-replace-screen (screen)
  (let* ((console (sheet-console screen))
	 (mouse (sys:console-mouse console))
	 new-screen
	 new-who-screen)
    (when (not (eq screen (sys:console-screen console)))
      (ferror "This can only be done to a screen associated with a console."))
    (with-screen-safe (screen :deexpose t)
      (without-interrupts
	(setf new-screen
	      (initialize-one-screen nil console (eq console *main-console*)))
	(setf (mouse-sheet mouse) new-screen)
	(setf new-who-screen (screen-who-line-screen new-screen))
	(when (eq main-screen screen) (setf main-screen new-screen))
	(when (eq default-screen screen) (setf default-screen new-screen))
	(setf *console-screens* (nsubst new-screen screen *console-screens*))
	(send screen :deactivate)
	(cl:pushnew screen *old-console-screens*)))
    (dolist (w (copylist (send screen :inferiors)))
      (send w :set-superior new-screen))
    (send new-screen :refresh)
    (when new-who-screen
      (send new-who-screen :refresh))
    new-screen))



;;;; Functions to maintain who-line window contents

;;; Called by Function-Refresh
(defun who-line-clobbered ()
  (dolist (who-screen *active-who-line-screens*)
    (dolist (i (sheet-inferiors who-screen))
      (send i :clobbered))))

;;; Called by scheduler, Function-W, screen hardcopy, etc.
(defun who-line-update (&optional run-state-only-p)
  (cl:dolist (screen *active-who-line-screens* t)
    (if run-state-only-p
	(who-line-screen-run-state-update screen)
	(who-line-screen-update screen))))

(defun who-line-run-state-update ()
  (cl:dolist (screen *active-who-line-screens* t)
    (who-line-screen-run-state-update screen)))

;;; Call this when the state of a process may have changed.
;;; In the cold-load because called by process stuff, loaded before window stuff.
(defun who-line-process-change (proc)
  (dolist (who-screen *active-who-line-screens*)
    (when (eq proc (who-line-screen-last-process who-screen))
      (who-line-screen-run-state-update who-screen)))
  nil)

(defun need-mouse-documentation-update ()
  (cl:dolist (screen *active-who-line-screens*)
    (who-line-screen-mouse-documentation-queue-update screen)))

;;;

(defmethod (who-line-screen-update generic-who-line-screen-mixin) ()
  (setf update-needed t)
  (screen-get-who-line-process self)
  (process:process-wakeup update-process))

(defmethod (who-line-screen-run-state-update generic-who-line-screen-mixin) ()
  (setf run-state-update-needed t)
  (screen-get-who-line-process self)
  (process:process-wakeup update-process))

(defconst *mouse-documentation-update-interval* 250000)		;1/4 second

(defmethod (who-line-screen-mouse-documentation-queue-update generic-who-line-screen-mixin) ()
  ;; Do nothing if an update is already going to happen as soon as the
  ;; process wakes up, or in a little while when the timer goes off
  (unless (or mouse-documentation-update-needed update-needed
	      (process:timer-pending-p mouse-documentation-update-timer))
    (if (< (%32-bit-difference (sys:%microsecond-clock) last-mouse-documentation-update-time)
	   *mouse-documentation-update-interval*)
	;; The mouse documentation has been updated recently, so delay a while before
	;; updating it again, to avoid using up too much of the machine doing
	;; nothing but causing flicker
	(process:reset-timer-relative-timer-units mouse-documentation-update-timer
						  *mouse-documentation-update-interval*)
	;; The mouse documentation has not been updated recently, so update it now
	(who-line-screen-mouse-documentation-update self))))

(defmethod (who-line-screen-mouse-documentation-update generic-who-line-screen-mixin) ()
  (setf mouse-documentation-update-needed t)
  (process:process-wakeup update-process))



(defconst *who-line-update-interval* 1000000)			;1 second

(defun-in-flavor (who-line-screen-update-predicate generic-who-line-screen-mixin) ()
  (and (not inhibit-who-line)
       (or update-needed
	   mouse-documentation-update-needed
	   run-state-update-needed)
       *who-line-process-priority*))

(defun-in-flavor (who-line-screen-update-top-level generic-who-line-screen-mixin) ()
  (cond (update-needed
	 (setf update-needed nil)
	 (setf mouse-documentation-update-needed nil)
	 (setf run-state-update-needed nil)
	 (process:clear-timer update-timer)
	 (setq last-mouse-documentation-update-time (sys:%microsecond-clock))
	 (unwind-protect
	     (progn
	       (who-line-screen-update-internal self)
	       (who-line-screen-run-state-update-internal self)
	       (send self :finish-blinkers))
	   (process:reset-timer-relative-timer-units update-timer *who-line-update-interval*)))
	(t
	 (when run-state-update-needed
	   (setf run-state-update-needed nil)
	   (who-line-screen-run-state-update-internal self))
	 (when mouse-documentation-update-needed
	   (setf mouse-documentation-update-needed nil)
	   (setq last-mouse-documentation-update-time (sys:%microsecond-clock))
	   (who-line-screen-mouse-documentation-update-internal self))
	 (send self :finish-blinkers))))

(defmethod (who-line-screen-update-internal generic-who-line-screen-mixin) ()
  (if (eq self who-line-screen)
      (si:save-who-line-run-light		;Don't clobber run light
	(dolist (i (sheet-exposed-inferiors who-line-screen))
	  (send i :update)))
      (dolist (i exposed-inferiors)
	(send i :update))))

(defmethod (who-line-screen-run-state-update-internal generic-who-line-screen-mixin) ()
  (if (eq self who-line-screen)
      (when (and who-line-run-state-sheet
		 (not inhibit-who-line))
	(si:save-who-line-run-light			;Don't clobber run light
	  (send who-line-run-state-sheet :update)))
      (send (get-who-line-field :run-state self) :update)))

(defmethod (who-line-screen-mouse-documentation-update-internal generic-who-line-screen-mixin)
	   ()
  (send (get-who-line-field :mouse-documentation self) :update))



(defun who-line-string (who-sheet state new-string)
  (unless (eq state new-string)
    (prepare-sheet (who-sheet)
      (send who-sheet :clear-window)
      (send who-sheet :string-out new-string)))
  new-string)

;;; :USER field
(defun who-line-user-or-process (who-sheet state ignore)
  (declare (scl:inline process::process-debug-flag))
  (who-line-string
    who-sheet state
    (block nil
      (let ((force-process
	      (who-line-screen-force-process (sheet-screen who-sheet))))
	(when force-process
	  (return (process-name force-process))))
      (let ((process
	      (and *current-process*
		   *show-current-process-in-wholine*
		   ;; remember that current-process is the timer task that
		   ;; is doing the who-line update.  We want next guy.
		   (let ((temp
			   (process::find-next-highest-priority-process
			     *current-process*)))
		     (loop while
			     (and temp
				  (ldb-test process::%%process-debug-no-run-light
					    (process::process-debug-flag temp))
				  (not (eql temp process::*null-process*)))
			   do (setf temp (process::find-next-highest-priority-process temp)))
		     temp))))
	(when (and process
		   *show-current-process-in-wholine*
		   (not (ldb-test process::%%process-debug-no-run-light
				  (process::process-debug-flag process)))
		   ;; process-run-function-flush-... can cause name to be NIL
		   (process-name process))
	  (return
	    (process-name process))))
      (return user-id))))

;;; utility function to determine relevant process for who-line fields
(defun who-line-relevant-process (who-sheet)
  (declare (values process stack-group))
  (let ((process (who-line-screen-last-process (sheet-screen who-sheet))))
    (when process
      (values process (process-stack-group process)))))

;;;

;;;

(defun who-line-package-1 (who-sheet pkg rdtbl)
  (multiple-value-bind (syntax-string pkg-string)
      (who-line-package-strings pkg rdtbl)
    (let ((size (- (send who-sheet :size-in-characters) 2)))
      (flet ((write-truncated-string (string)
	       (let ((length (string-length string)))
		 (cond ((<= length size)
			(send who-sheet :string-out string)
			(decf size length))
		       (t
			(when (plusp size)
			  (send who-sheet :string-out string 0 size))
			(when (not (minusp size))
			  (send who-sheet :tyo #\center-dot)
			  (setf size -1)))))))
	(prepare-sheet (who-sheet)
	  (send who-sheet :clear-window)
	  (write-truncated-string syntax-string)
	  (write-truncated-string " ")
	  (write-truncated-string pkg-string)
	  (cl:write-char #/: who-sheet))))))

(defun who-line-package-strings (pkg rdtbl)
  (let* ((syntax-keyword (si:readtable-appropriate-file-syntax rdtbl))
	 (syntax (si:lisp-syntax-from-keyword syntax-keyword)))
    (values (cond (syntax (si:lisp-syntax-short-name syntax))
		  (t "?"))
	    (cond ((eq pkg sys:pkg-keyword-package)
		   (sys:pkg-name pkg))
		  (t
		   (let ((last-name nil))
		     (si:pkg-package-prefix
		       #'(lambda (name ignore ignore)
			   (setf last-name name))
		       pkg nil t 0 nil syntax)
		     last-name))))))

;;; :PACKAGE field
(defun who-line-package (who-sheet state extra-state)
  (multiple-value-bind (cur-process sg)
      (who-line-relevant-process who-sheet)
    (multiple-value-bind (pkg rdtbl)
	(who-line-package-for-process cur-process sg)
      (when (and (arrayp pkg) (si:pkg-package-p pkg)
		 (arrayp rdtbl) (cl:readtablep rdtbl)
		 (or (not (eq state pkg))
		     (not (eq extra-state rdtbl))))
	(who-line-package-1 who-sheet pkg rdtbl)
	(return-from who-line-package
	  (values pkg rdtbl)))))
  (values state extra-state))

(defun who-line-package-for-process (cur-process
				     &optional (sg (process-stack-group cur-process)))
  (when sg
    (if (or (eq sg %current-stack-group)
	    (not (typep sg :stack-group)))
	(values cl:*package* cl:*readtable*)
	(values (location-contents
		  (dbg:cell-location-in-stack-group (locf cl:*package*) sg))
		(location-contents
		  (dbg:cell-location-in-stack-group (locf cl:*readtable*) sg))))))

;;;

;;; :RUN-STATE field
(defun who-line-run-state (who-sheet state extra-state)
  (values
    (who-line-string who-sheet state
		     (if (eq who-sheet who-line-run-state-sheet)
			 who-line-run-state
			 (or extra-state "")))
    extra-state))



;;; First cut progress annotation

(defvar-resettable *progress-notes* ())
(defvar *current-progress-note*)
(defconst *show-system-internal-progress-notes* t)	;Set to NIL by world-release script.
(defconst *show-network-progress-notes* nil)
(defvar *forcibly-show-progress-notes* nil)	;true while booting

;Centralized predicate for progress notes that are not shown unconditionally
(defun show-progress-note (type)
  (or *forcibly-show-progress-notes*
      *show-system-internal-progress-notes*
      (cl:case type
	(:network *show-network-progress-notes*)
	(:initializations nil)
	(:package nil)
	(otherwise nil))))

(cl:defstruct (progress-note)
  name
  (fraction-done-numerator 0)
  (fraction-done-denominator 1)
  (process nil))

(defun progress-note-fraction-done (progress-note)
  (cl:// (progress-note-fraction-done-numerator progress-note)
	 (progress-note-fraction-done-denominator progress-note)))

(defun add-progress-note (name &optional (process si:current-process))
  (let ((note (make-progress-note :name name :process process)))
    (without-interrupts
      (push note *progress-notes*))
    note))

(defun alter-progress-note-text (string &optional (note *current-progress-note*))
  (setf (progress-note-name note) string)
  (let ((sheet 
	  (scl:case *note-progress-in-wholine*
	    ((:with-file) (get-who-line-field :file-state))
	    ((T) (get-who-line-field :progress)))))
    (when sheet (send sheet :clobbered)))
  string)

(defun remove-progress-note (note)
  (without-interrupts
    (setq *progress-notes* (delq note *progress-notes*))))

(defmacro noting-progress ((name &optional (variable '*current-progress-note*)
				 (process 'si:current-process)) &body body)
  (declare (zwei:indentation 0 3 1 1))
  (setq variable (or variable '*current-progress-note*))	;allow an explicit NIL
						; to mean `give me the default'
  `(let (,variable)
     (unwind-protect
	 (progn
	   (setq ,variable (add-progress-note ,name ,process))
	   . ,body)
       (remove-progress-note ,variable))))

(defmacro noting-progress-if (condition
			      (name &optional (variable '*current-progress-note*)
				    (process 'si:current-process))
			      &body body
			      &environment env)
  (declare (zwei:indentation 1 3 2 1))
  (setq variable (or variable '*current-progress-note*))
  (once-only (condition &environment env)
    `(let-if ,condition ((,variable nil))
       (unwind-protect
	   (progn
	     (when ,condition
	       (setq ,variable (add-progress-note ,name ,process)))
	     . ,body)
	 (when ,condition
	   (remove-progress-note ,variable))))))

(defun note-progress (numerator &optional (denominator 1) (note *current-progress-note*))
  (when note
    (when (and (= denominator 1) (rationalp numerator))
      (psetq numerator (numerator numerator)
	     denominator (denominator numerator)))
    (setf (progress-note-fraction-done-numerator note) numerator)
    (setf (progress-note-fraction-done-denominator note) denominator))
  nil)

(defun note-progress-in-phases (numerator &optional (denominator 1)
				(phase-number 1) (n-phases 1)
				(note *current-progress-note*))
  (note-progress (+ (* denominator (1- phase-number)) numerator)
		 (* denominator n-phases)
		 note)
  nil)

(defstruct (progress-note-alterable-string
	     :conc-name
	     :named-array-leader
	     (:make-array (:length 100 :element-type 'scl:character)))
  (fill-pointer 0)
  other-string)

(defun make-progress-note-data-stack-arrays (initial-note)
  ;;(make-progress-note-alterable-string)
  (let ((string1
	  (sys:make-stack-array (max 100 (string-length initial-note))
				:leader-length 3
				:named-structure-symbol 'progress-note-alterable-string
				:element-type 'character))
	(string2
	  (sys:make-stack-array 100
				:leader-length 3
				:named-structure-symbol 'progress-note-alterable-string
				:element-type 'character)))
    (setf (fill-pointer string1) 0)
    (setf (fill-pointer string2) 0)
    (setf (progress-note-alterable-string-other-string string1) string2)
    (setf (progress-note-alterable-string-other-string string2) string1)
    (when initial-note (string-nconc string1 initial-note))
    string1))

(defmacro noting-progress-alterable-note ((&optional initial-note
						     (note-var '*current-progress-note*)
						     (process 'current-process))
					  &body body)
  `(with-data-stack
     (noting-progress ((make-progress-note-data-stack-arrays ,initial-note)
		       ,note-var ,process)
       ,@body)))

(defun format-progress-note (nil-or-note format-string &rest format-args)
  (let ((note (or nil-or-note *current-progress-note*)))
    (let ((current-string (progress-note-name note)))
      (cond ((typep current-string 'progress-note-alterable-string)
	     (let ((working-string (progress-note-alterable-string-other-string
				     current-string)))
	       (setf (fill-pointer working-string) 0)
	       (scl:apply #'format working-string format-string format-args)
	       (without-interrupts
		 (setf (progress-note-name note) working-string))))
	    (T
	     ;; ---Well, I have this tradeoff here.  If the note isn't
	     ;; one which supports format-progress-note, do I assist the
	     ;; programmer in finding out why the program doesn't change
	     ;; the note, or do I flame at the poor user who's just running
	     ;; the program?  Well, perhaps even the least testing will
	     ;; show up the problem.
	     (scl:cerror "Don't alter the note"
			 "Attempt to do ~s not within ~s (program error)"
			 'format-progress-note
			 'noting-progress-alterable-note)))))
  (let ((sheet 
	  (scl:case *note-progress-in-wholine*
	    ((:with-file) (get-who-line-field :file-state))
	    ((T) (get-who-line-field :progress)))))
    (when sheet (send sheet :clobbered)))
  ())

#||
(defun test1 ()
  (noting-progress-alterable-note ("Number #")
    (dotimes (i 5)
      (cl:sleep 1)
      (format-progress-note () "Number ~d//~d" (1+ i) 5)
      (note-progress (1+ i) 5))))
||#

(defmacro dolist-noting-progress ((var listform name
				       &optional
				       (progress-note-variable '*current-progress-note*)
				       (process 'si:current-process))
				  &body body
				  &environment env)
  (declare (compiler:do-not-record-macroexpansions))
  (let ((count-var (gensym))
	(total-var (gensym)))
    (once-only (listform &environment env)
      `(noting-progress (,name ,progress-note-variable ,process)
	 (let ((,total-var (length ,listform))
	       (,count-var 0))
	   (cl:dolist (,var ,listform)
	     ,@body
	     (incf ,count-var)
	     (note-progress ,count-var ,total-var)))))))

(defmacro dotimes-noting-progress ((var countform name
					&optional
					(progress-note-variable '*current-progress-note*)
					(process 'si:current-process))
				   &body body
				   &environment env)
  (declare (compiler:do-not-record-macroexpansions))
  (once-only (countform &environment env)
    `(noting-progress (,name ,progress-note-variable ,process)
       (cl:dotimes (,var ,countform)
	 ,@body
	 ;; We want the progress bar to advance after the first iteration
	 ;; even though dotimes is zero-based, so add one to the numerator.
	 (note-progress (1+ ,var) ,countform)))))

(defun maphash-noting-progress (function table progress-note)
  (declare (sys:downward-funarg function))
  (let ((n-elements (scl:hash-table-count table))
	(i 0))
    (noting-progress (progress-note)
      (maphash (sys:named-lambda inner-maphash (key value)
		 (note-progress (incf i) n-elements)
		 (funcall function key value))
	       table))))

(defflavor who-line-file-sheet
	((displayed-stream nil)			;The one being displayed
	 (displayed-percent nil)
	 (displayed-count nil)
	 (highlighted-width 0)
	 (last-update-time nil))
	(who-line-mixin minimum-window))

(defun-in-flavor (highlight-fraction-done who-line-file-sheet) (numerator denominator)
  (let ((new-width (if (eq *note-progress-in-wholine* :with-file)
		       (if (zerop denominator)
			   (sheet-inside-width)
			   (round (* numerator (sheet-inside-width)) denominator))
		       0)))
    (unless (eql new-width highlighted-width)
      (if (> new-width highlighted-width)
	  (send self :draw-rectangle (- new-width highlighted-width) 2
		highlighted-width (- (sheet-inside-height) 2) :flip)
	  (send self :draw-rectangle (- highlighted-width new-width) 2
		new-width (- (sheet-inside-height) 2) :flip))      
      (setq highlighted-width new-width))))

;; Values are NIL       = no GC progress note should be displayed.
;;            T         = there is one available for display.
;;            :OVERRIDE = there is one available and it should be used.
(defun who-line-gc-progress-note-mode (stack-group)
  ;; If GC's not running, no chance of a progress note.
  (unless (and si:%gc-flip-ready si:gc-reclaimed-oldspace)
    ;; GC's running.  Find out what mode is applicable for the current kind of GC.
    (let ((mode (getf si:*gc-progress-note-enable*
		      (if si:*ephemeral-gc-in-progress* :ephemeral :dynamic))))
      (cond ((null mode) nil)
	    ((eq mode :foreground)
	     (or si:gc-immediately-in-progress
		 (and stack-group
		      (car (dbg:cell-location-in-stack-group
			     (locf si:*inside-gc-reclaim-oldspace*) stack-group)))))
	    ((eq mode :background) t)
	    (t mode)))))

(defun who-line-pick-progress-note-or-stream (take-progress-notes-p who-sheet)
  (declare (values stream-or-progress-note which))
  (multiple-value-bind (cur-process stack-group)
      (who-line-relevant-process who-sheet)
    (who-line-pick-progress-note-or-stream-for-process cur-process stack-group
						       take-progress-notes-p who-sheet)))

(defun who-line-pick-progress-note-or-stream-for-process (cur-process &optional
							  (stack-group (process-stack-group
									 cur-process))
							  (take-progress-notes-p t)
							  (who-sheet #'ignore))
  (let ((gc-mode (and take-progress-notes-p
		      (who-line-gc-progress-note-mode stack-group))))
    (when (eq gc-mode :override)
      (return-from who-line-pick-progress-note-or-stream-for-process
	(values (si:get-gc-progress-note who-sheet) 'progress-note)))
    (let* ((candidate-progress-note
	     (and take-progress-notes-p
		  (cl:dolist (progress-note *progress-notes*
					    ;; return the first if none match.
					    (first *progress-notes*))
		    (when (eq (progress-note-process progress-note) cur-process)
		      ;; Progress note for the current process is preferred over all else
		      (return-from who-line-pick-progress-note-or-stream-for-process
			(values progress-note 'progress-note))))))
	   (candidate-stream
	     ;;Take the most recently opened input stream if there is one.  Otherwise
	     ;;take the most recently opened output stream.
	     ;;Try for the right process before settling for some other.
	     (let ((input-winner nil)		;Best input stream for other process
		   (output-winner nil)		;Best output stream for this process
		   (output-other nil))		;Best output stream for other process
	       (dolist (stream fs:all-open-streams)
		 (cond ((eq (send stream :direction) ':output)	;bidirectional = input
			(if (eq (fs:file-data-stream-process stream) cur-process)
			    (unless output-winner (setq output-winner stream))
			    (unless output-other (setq output-other stream))))
		       ((eq (fs:file-data-stream-process stream) cur-process)
			;; Input stream for this process is preferred over all others
			(return-from who-line-pick-progress-note-or-stream-for-process
			  (values stream 'stream)))
		       ((not input-winner) (setq input-winner stream))))
	       (when output-winner
		 (return-from who-line-pick-progress-note-or-stream-for-process
		   (values output-winner 'stream)))
	       (or input-winner output-other))))
      ;; Pick which one to return when neither is for the current process
      (cond (candidate-progress-note (values candidate-progress-note 'progress-note))
	    (candidate-stream (values candidate-stream 'stream))
	    (gc-mode (values (si:get-gc-progress-note who-sheet) 'progress-note))))))

(defvar *who-line-function-hook* nil
  "Place a function here that takes a who-line-file-sheet to display something in the who-line"
  )

(defmethod (:update who-line-file-sheet) (&aux idle old-stream must-update item item-type)
  (setq old-stream displayed-stream)		;what we were doing the last time around.
  (macrolet ((maybe-display-user-message ()
	       `(when (functionp *who-line-function-hook*)
		  (funcall *who-line-function-hook* self))))
    (cond
      ((and notification-history (neq notification-history *notification-last-delivered*))
       (when (or (neq who-line-item-state 'notifications)
		 ( last-update-time *last-notification-time*))
	 (setf who-line-item-state 'notifications)
	 (setf last-update-time *last-notification-time*)
	 (setf displayed-stream nil)
	 (display-who-line-notifications self)
	 (maybe-display-user-message)))
      ;; --- more wonderful style
      ((progn (cl:multiple-value-setq (item item-type)
		(who-line-pick-progress-note-or-stream
		  (eq *note-progress-in-wholine* :with-file)
		  self))
	      item)
       (cond ((eq item-type 'progress-note)
	      (setq displayed-stream item)
	      (unless (and (eq who-line-item-state 'progress)
			   ;;A progress note can't be a stream.
			   (eq old-stream displayed-stream))
		(send self :clear-window)
		(setq highlighted-width 0)
		(when displayed-stream		;In case of timing problem
		  (let ((note-name (progress-note-name displayed-stream)))
		    (send self :string-out note-name))))
	      (setq who-line-item-state 'progress)
	      (setq old-stream displayed-stream)
	      (highlight-fraction-done (progress-note-fraction-done-numerator displayed-stream)
				       (progress-note-fraction-done-denominator
					 displayed-stream)))
	     ((eq item-type 'stream)
	      (setq displayed-stream item
		    must-update (or (neq who-line-item-state 'stream)
				    (neq last-update-time fs:all-open-streams-last-updated))
		    who-line-item-state 'stream
		    last-update-time fs:all-open-streams-last-updated)
	      (multiple-value-bind (pathname direction count percent)
		  (send displayed-stream :who-line-information)
		(ignore pathname)		;not used any more
		(unless (and (not must-update)
			     (eq old-stream displayed-stream)
			     (eq percent displayed-percent)
			     (eq count displayed-count))	;---this will flash even of the count
						;---is truncated off.
		  (send self :home-cursor)
		  (unless (and (eq old-stream displayed-stream)
			       (zerop highlighted-width))
		    (send self :clear-window)
		    (setq highlighted-width 0))
		  (setq displayed-percent percent
			displayed-count count)
		  (display-file-transfer self displayed-stream direction count percent))
		(multiple-value-bind (num den)
		    (let ((length (send displayed-stream :length)))
		      (if (or (null length) (zerop length))
			  (values 0 1)
			  (values count length)))
		  (highlight-fraction-done num den)))
	      (setq old-stream displayed-stream))))
      ((not (null net:*active-servers*))
       (setq displayed-stream nil)
       (when (or (neq who-line-item-state 'servers)
		 (neq last-update-time net:*active-servers-last-update-time*))
	 (send self :home-cursor)
	 (send self :clear-rest-of-line)
	 (setq who-line-item-state 'servers
	       last-update-time net:*active-servers-last-update-time*)
	 (display-server-information self)
	 (maybe-display-user-message)))
      (si:who-line-just-cold-booted-p
       (unless (eq who-line-item-state 'cold)
	 (send self :clear-window)
	 (if (neq si:who-line-just-cold-booted-p :host-name-verified)
	     (send self :string-out "Cold-booting")
	     (catch 'skip-who-line-update
	       (send self :string-out si:local-pretty-host-name)
	       (send self :string-out " is cold-booted")))
	 (setq who-line-item-state 'cold)
	 (maybe-display-user-message)))
      ((> (setq idle (// (time-difference (time)
					  (console-last-activity-time
					    (sheet-console self)))
			 3600.))
	  4)
       ;;Display keyboard idle time
       (let ((old-idle who-line-item-state))
	 (when (or (not (numberp old-idle)) ( old-idle idle))
	   (display-idle-message self idle)
	   (setq who-line-item-state idle)
	   (maybe-display-user-message))))
      ((neq who-line-item-state 'null)
       (send self :clear-window)
       (when *show-machine-name-in-wholine*
	 (send self :string-out si:local-pretty-host-name))
       (setq who-line-item-state 'null)
       (maybe-display-user-message)))))

(defun display-who-line-notifications (sheet)
  (send sheet :clear-window)
  (let* ((count (loop for notes on notification-history
		      until (eq notes *notification-last-delivered*)
		      count t))
	 (string (format nil "~D pending notification~P" count count)))
    (send sheet :string-out string)
    (return-array (prog1 string (setf string nil)))))

;;; Display the who-line-information onto SHEET.  PERCENT may be NIL,
;;; but COUNT is always a fixnum.  DIRECTION is one of the keywords
;;; :INPUT, :OUTPUT, or :BIDIRECTIONAL.
(defun display-file-transfer (sheet file-stream direction count percent)
  ;; MAX-CHARS is just a guess when dealing with variable width fonts.  The complete
  ;; correct logic would be rather expensive even for fixed width here.
  (let ((max-chars (// (sheet-inside-width sheet) (sheet-char-width sheet))))
    (with-stack-array (string max-chars :type 'art-string :fill-pointer 0)
      (display-file-transfer-internal string file-stream direction count percent max-chars)
      (send sheet :clear-rest-of-line)
      (send sheet :string-out string))))

(defun display-file-transfer-internal (string file-stream direction count percent max-chars)
  (string-nconc string (selectq direction
			 (:input " ")
			 (:output " ")
			 (:bidirectional " ")
			 (otherwise "? ")))
  (let* ((file-name (send file-stream :string-for-wholine))
	 (file-name-length (string-length file-name))
	 (file-name-limit nil)
	 (count-string (quick-fixnum-string count))
	 (count-string-length (array-active-length count-string))
	 (percent-string)
	 (percent-string-length)
	 (display-count-p nil)
	 (display-percent-p nil))
    (cond ((null percent)
	   (setq display-percent-p nil display-count-p t)
	   (if (> (+ file-name-length count-string-length 4) max-chars)
	       ;; 4 is two for the direction and two for the spaces after the file name.
	       (setq file-name-limit (max 0 (- max-chars 4 count-string-length)))))
	  (t
	   (setq percent-string (quick-fixnum-string percent))
	   (array-push-extend percent-string #/%)
	   (setq percent-string-length (array-active-length percent-string))
	   (setq display-percent-p t)
	   (cond (( (+ file-name-length count-string-length percent-string-length 5)
		     ;;5 is the above 4 plus 1 space between percent & count
		     max-chars)
		  (setq display-count-p t))
		 ((> (+ file-name-length percent-string-length 4) max-chars)
		  (setq file-name-limit (max 0 (- max-chars percent-string-length 4)))))))
    (string-nconc-portion string file-name 0 file-name-limit)
    (string-nconc string (if file-name-limit "  " "  "))
    (when display-percent-p
      (string-nconc string percent-string)
      (when display-count-p (string-nconc string " ")))
    (when display-count-p
      (string-nconc string count-string))
    (when percent-string
      (return-array (prog1 percent-string (setq percent-string nil))))
    (return-array (prog1 count-string (setq count-string nil)))))

;; 2.8 times as fast as FORMAT ~D.
(defun quick-fixnum-string (n &optional (base 10.))
  (declare (unspecial base))
  (when (zerop n)
    (let ((string (make-array 1 :type 'art-string :fill-pointer 1)))
      (setf (aref string 0) #/0)
      (return-from quick-fixnum-string string)))
  (let ((string (make-array 16. :type 'art-string :fill-pointer 0))
	(minus (if (minusp n)
		   (progn (setf n (- n))
			  t)
		   nil)))
    (loop do (multiple-value-bind (quo rem) (floor n base)
	       (array-push-extend string (code-char (+ (char-code #/0) rem)))
	       (setf n quo))
	  until (zerop n))
    (when minus
      (array-push-extend string #/-))
    (string-nreverse string)))

(defun display-server-information (window)
  (let ((string (if (= (length net:*active-servers*) 1)
		    (format nil "~A serving ~A"
			    (send (car net:*active-servers*) :protocol)
			    (send (car net:*active-servers*) :foreign-host))
		    (format nil "~D active servers" (length net:*active-servers*)))))
    (send window :clear-window)
    (send window :string-out string)
    (return-array (prog1 string (setq string nil)))))

;;;; Displaying progress in its own sheet
(defun who-line-note-progress (window state extra-state)
  (multiple-value-bind (new-item new-item-type)
      (who-line-pick-progress-note-or-stream t window)
    (flet 
      ((note-fraction-done ()
	 (cl:case new-item-type
	   (progress-note
	     (values (progress-note-fraction-done-numerator new-item)
		     (progress-note-fraction-done-denominator new-item)))
	   (stream
	     (multiple-value-bind (nil nil count)
		 (send new-item :who-line-information)
	       (let ((length (send new-item :length)))
		 (cond ((null length)
			;; For directory listing, e.g.
			(values count (+ 2000 count)))
		       ((zerop length)
			(values 1 1))
		       (t
			(values count length))))))
	   (otherwise
	     (values 0 1))))
       (note-name ()
	 (cl:case new-item-type
	   (progress-note
	     (progress-note-name new-item))
	   (stream
	     (format nil "Reading ~A" (send new-item :who-line-information)))
	   (otherwise nil))))
      (when (neq state new-item)
	(send window :clear-window)
	(setq extra-state 0)
	(send window :home-cursor)
	(setq state new-item)
	(when state
	  (send window :string-out (note-name))))
      (let ((width (multiple-value-bind (num den) (note-fraction-done)
		     (if (zerop den)
			 (sheet-inside-width window)
			 (round (* (sheet-inside-width window) num) den)))))
	(unless (eql width extra-state)
	  (if (> width extra-state)
	      (send window :draw-rectangle (- width extra-state) (sheet-inside-height window)
		    extra-state 0 :flip)
	      (send window :draw-rectangle (- extra-state width) (sheet-inside-height window)
		    width 0 :flip))
	  (setq extra-state width)))
      (values state extra-state))))

(defconstant idle-minutes-format-string "'s console idle ~D minute~:P")
(defconstant idle-hours-minutes-format-string "'s console idle ~D hr ~D min~:P")
(defconstant idle-minutes-string-size (string-length "'s console idle xx minutes"))
(defconstant idle-hours-minutes-string-size (string-length "'s console idle xxx hr xx mins"))

(defun display-idle-message (window minutes)
  (send window :clear-window)
  (catch 'skip-who-line-update
    (send window :string-out si:local-pretty-host-name)
    (if (< minutes 60.)
	(format window idle-minutes-format-string minutes)
	(multiple-value-bind (hours fraction)
	    (floor minutes 60.)
	  (format window idle-hours-minutes-format-string hours fraction)))))

;;;; Digital watch

(cl:defstruct wwatch
  old-string
  new-string
  )

;;; :TIME field
(defun wwatch-who-function (window state extra-state)
  (when (null extra-state)
    ;; If not already there, cons one up.
    (setq extra-state (flet ((ss () (make-array 40 :fill-pointer 0
						:type 'art-string
						:area who-line-area)))
			(make-wwatch :old-string (ss) :new-string (ss)))))
  (let ((old-string (wwatch-old-string extra-state))
	(new-string (wwatch-new-string extra-state)))
    (setf (fill-pointer new-string) 0)
    (fill-string-from-decoded-time new-string
				   (and *wholine-clock-colon-blink-half-period*
					(* *wholine-clock-colon-blink-half-period* 2))
				   nil)
    (let ((dif (if (neq state T)
		   0				;clobbered, redisplay all
		   ;; Open-coded (cl:mismatch old-string new-string)
		   (do ((i 0 (1+ i))
			(n (min (fill-pointer old-string) (fill-pointer new-string))))
		       ((= i n)
			(and ( (fill-pointer old-string) (fill-pointer new-string))
			     n))
		     (unless (eql (aref old-string i) (aref new-string i))
		       (return i))))))
      (when dif
	(send window :set-cursorpos (if (zerop dif) 0
					(send window :string-length new-string 0 dif))
				    0)
	(send window :clear-rest-of-line)
	(send window :string-out new-string dif)))
    ;; Swap the strings in the structure
    (setf (wwatch-old-string extra-state) new-string)
    (setf (wwatch-new-string extra-state) old-string)
    (values t extra-state)))

(defun size-of-wwatch-string ()
  (with-stack-array (string 30 :fill-pointer 0 :type 'art-string)
    (cl:length (fill-string-from-decoded-time
		 string nil
		 (cl:encode-universal-time 59 59 23 31 12 1999)))))

(defun fill-string-from-decoded-time (string colon-blink-period universal-time)
  (multiple-value-bind (seconds minutes hours days month nil day-of-week)
      (if universal-time
	  (cl:decode-universal-time universal-time)
	  (and time:*timebase-initialized*
	       (cl:get-decoded-time)))
    (let ((string string)
	  (index 0))
      (declare (sys:array-register string))
      ;; Open code some things to decrease the system working set.  The array and
      ;; string constants get nicely localized on the same page as this function.
      (macrolet ((some-char (char)		;similar to cl:vector-push
		   `(progn (setf (aref string index) ,char) (incf index)))
		 (digit-char (digit)		;no range checking required
		   `(code-char (+ (char-code #/0) ,digit)))
		 (two-digits (number)
		   `(multiple-value-bind (tens units) (floor ,number 10)
		      (some-char (digit-char tens))
		      (some-char (digit-char units))))
		 (some-digits (number)
		   `(multiple-value-bind (tens units) (floor ,number 10)
		      (when (> tens 0)
			(some-char (digit-char tens)))
		      (some-char (digit-char units))))
		 (day-of-the-week-string (day-of-week)
		   `(let ((day (aref #.(cl:vector "Mon" "Tue" "Wed" "Thu" "Fri" "Sat" "Sun")
				     ,day-of-week)))
		      (some-char (aref day 0))
		      (some-char (aref day 1))
		      (some-char (aref day 2))))
		 (month-string (month)
		   `(let ((month (aref #.(cl:vector "Jan" "Feb" "Mar" "Apr" "May" "Jun"
						    "Jul" "Aug" "Sep" "Oct" "Nov" "Dec")
				       (1- ,month))))
		      (some-char (aref month 0))
		      (some-char (aref month 1))
		      (some-char (aref month 2)))))
	(unless (null seconds)			;null if system doesn't know the time yet
	  (if *wholine-clock-delimiters*
	      (cl:case *wholine-clock-delimiters*
		((t) (some-char #\[))
		((0) (some-char #\space))))
	  (day-of-the-week-string day-of-week)
	  (some-char #\space)
	  (some-digits days)
	  (some-char #\space)
	  (month-string month)
	  (some-char #\space)
	  (some-digits (cond (*wholine-clock-24hour-p* hours)
			     ((zerop hours) 12.)
			     ((> hours 12.) (- hours 12.))
			     (t hours)))
	  (cond ((eq *wholine-clock-format* :dow-hh-mm-am)
		 (some-char (if (and colon-blink-period
				     (zerop (mod seconds colon-blink-period)))
				#\. #\:))
		 (two-digits minutes)
		 (if ( hours 12.) (some-char #\p) (some-char #\a))
		 (some-char #\m))
		(t (some-char #\:)
		   (two-digits minutes)
		   (some-char #\:)
		   (two-digits seconds)))
	  (if *wholine-clock-delimiters*
	      (cl:case *wholine-clock-delimiters*
		((t) (some-char #\]))
		((0) (some-char #\space)))))
	;;Must return the string
	(setf (fill-pointer string) index)
	string))))

(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; For external use only (e.g., by Zmail.)
0(defun wholine-watch-string-from-time (&optional universal-time
				       &key include-delimiters (include-day-of-the-week t)
							       (include-date t))
  (multiple-value-bind (seconds minutes hours days month nil day-of-week)
      (if universal-time
	  (cl:decode-universal-time universal-time)
	(cl:get-decoded-time))
    (let ((string (cl:make-array 10. :element-type 'cl:string-char :fill-pointer 0)))
      2;; Open code some things to decrease the system working set.  The array and
      ;; string constants get nicely localized on the same page as this function.
0      (macrolet ((some-char (char)		;similar to cl:vector-push
		   `(array-push-extend string ,char))
		 (digit-char (digit)		;no range checking required
			     `(code-char (+ (char-code #/0) ,digit)))
		 (two-digits (number)
		   `(multiple-value-bind (tens units) (floor ,number 10)
		      (some-char (digit-char tens))
		      (some-char (digit-char units))))
		 (some-digits (number)
		   `(multiple-value-bind (tens units) (floor ,number 10)
		      (when (> tens 0)
			(some-char (digit-char tens)))
		      (some-char (digit-char units))))
		 (day-of-the-week-string (day-of-week)
		   `(let ((day (aref #.(cl:vector "Mon" "Tue" "Wed" "Thu" "Fri" "Sat" "Sun")
				     ,day-of-week)))
		      (some-char (aref day 0))
		      (some-char (aref day 1))
		      (some-char (aref day 2))))
		 (month-string (month)
		   `(let ((month (aref #.(cl:vector "Jan" "Feb" "Mar" "Apr" "May" "Jun"
						    "Jul" "Aug" "Sep" "Oct" "Nov" "Dec")
				       (1- ,month))))
		      (some-char (aref month 0))
		      (some-char (aref month 1))
		      (some-char (aref month 2)))))
	(when include-delimiters
	  (if *wholine-clock-delimiters*
	      (cl:case *wholine-clock-delimiters*
		((t) (some-char #\[))
		((0) (some-char #\space)))))
	(when include-day-of-the-week
	  (day-of-the-week-string day-of-week)
	  (some-char #\space))
	(when include-date
	  (some-digits days)
	  (some-char #\space)
	  (month-string month)
	  (some-char #\space))
	(some-digits (cond (*wholine-clock-24hour-p* hours)
			   ((zerop hours) 12.)
			   ((> hours 12.) (- hours 12.))
			   (t hours)))
	(cond ((eq *wholine-clock-format* :dow-hh-mm-am)
	       (some-char #\:)
	       (two-digits minutes)
	       (if ( hours 12.) (some-char #\p) (some-char #\a))
	       (some-char #\m))
	      (t (some-char #\:)
		 (two-digits minutes)
		 (some-char #\:)
		 (two-digits seconds)))
	(when include-delimiters
	  (if *wholine-clock-delimiters*
	      (cl:case *wholine-clock-delimiters*
		((t) (some-char #\]))
		((0) (some-char #\space))))))
      string)))


;;; Oldstyle :TIME field
;;; Date and time in the who-line, continuously updating.
(defun nwatch-who-function (who-sheet state extra-state)
  (or extra-state
      (let ((default-cons-area who-line-area))
	(setq extra-state (string-append "MM//DD//YY HH:MM:SS"))))
  (let (year month day hours minutes seconds leftx)
    (multiple-value (seconds minutes hours day month year)
      (time:get-time))
    (cond ((null seconds)			       
	   (send who-sheet :set-cursorpos 0 0)
	   (send who-sheet :clear-rest-of-line)
	   (copy-array-contents "MM//DD//YY HH:MM:SS" extra-state)
	   (values nil extra-state))
	  (t
	   (setq leftx (min (nwatch-n month extra-state 0)
			    (nwatch-n day extra-state 3)
			    (nwatch-n (mod year 100.) extra-state 6)
			    (nwatch-n hours extra-state 9)
			    (nwatch-n minutes extra-state 12.)
			    (nwatch-n seconds extra-state 15.)))
	   (when (neq state t) (setq leftx 0))		;was clobbered, redisply all
	   (send who-sheet :set-cursorpos (if (zerop leftx) 0
					      (send who-sheet :string-length extra-state
									     0 leftx))
					  0)
	   (send who-sheet :clear-rest-of-line)
	   (send who-sheet :string-out extra-state leftx)
	   (values t extra-state)))))

;Returns first character position changed
(defun nwatch-n (n str i)
  (multiple-value-bind (dig1 dig2) (floor n 10)
    (setq dig2 (digit-char dig2)
	  dig1 (digit-char dig1))
    (prog1 (cond ((not (char-equal (aref str i) dig1)) i)
		 ((not (char-equal (aref str (1+ i)) dig2)) (1+ i))
		 (t (array-length str)))
	   (aset dig1 str i)
	   (aset dig2 str (1+ i)))))

;;; Support for documentation in the who line

(defmethod (:who-line-documentation-string sheet) () nil)

;;; :MOUSE-DOCUMENTATION field 

(defvar *who-line-no-window-documentation-array*
	'#.(cl:coerce '(nil
			 "Mouse-R: System menu."
			 "Mouse-M: Move mouse to main screen."
			 "Mouse-M: Move mouse to main screen; Mouse-R: System menu."
			 "Mouse-L: Select window."
			 "Mouse-L: Select window; Mouse-R: System menu."
			 "Mouse-L: Select window; Mouse-M: Move mouse to main screen."
			 "Mouse-L: Select window; Mouse-M: Move mouse to main screen; Mouse-R: System menu."
			 )
		      'cl:vector))

(defun who-line-no-window-documentation (mouse)
  (let* ((sheet (mouse-sheet mouse))
	 (console (mouse-console mouse))
	 (main-screen (and (typep sheet 'screen) (not (eq sheet (console-screen console))))))
    (aref *who-line-no-window-documentation-array*
	  (if (window-under-mouse-internal mouse :mouse-select)
	      (+ 4
		 (if main-screen 2 0)
		 (if firewall:*system-menu-enabled* 1 0))
	      (+ (if main-screen 2 0)
		 (if (and (console-system-menu-enabled console)
			  (let ((x (mouse-x mouse))
				(y (mouse-y mouse)))
			    (and ( (sheet-inside-left sheet) x)
				 (< x (sheet-inside-right sheet))
				 ( (sheet-inside-top sheet) y)
				 (< y (sheet-inside-bottom sheet)))))
		     1
		     0))))))

(defun who-line-documentation-function (window old-line-1 old-line-2)
  (when (eq old-line-1 :clobbered) (setq old-line-2 old-line-1))
  (multiple-value-bind (line-1 line-2)
      (let* ((mouse (sheet-mouse window))
	     (mwindow (mouse-window mouse)))
	(cond ((null (mouse-sheet mouse)) nil)	;During booting
	      ((null mwindow)			;Deexposed or no window
	       (who-line-no-window-documentation mouse))
	      ((symbolp mwindow)		;T or STOP
	       (values (who-line-mouse-grabbed-documentation mouse)
		       (who-line-mouse-grabbed-more-documentation mouse)))
	      (t (condition-case (error)
		      (send mwindow :who-line-documentation-string)
		    (error (or (catch-error (format nil "Error: ~A" error) nil)
			       "error getting documentation string"))))))
    (let ((nlines (sheet-number-of-inside-lines window)))
      (flet ((do-line (line-no new-line old-line)
	       (unless (or (eq new-line old-line) ( line-no nlines))
		 (condition-case (error)
		      (when new-line (setq new-line (string new-line)))
		    (error
		      (setq new-line
			    (or (catch-error (format nil "Error: ~A" error ) nil)
				"error getting string from who line documentation"))))
		 (send window :set-cursorpos 0 line-no :character)
		 (send window (if (< line-no (1- nlines)) :clear-rest-of-line
							  :clear-rest-of-window))
		 (when (stringp new-line)
		   ;; If this is not the last line in the window, make sure the string
		   ;; does not continue onto the next line
		   (send window :string-out new-line 0 (and (< line-no (1- nlines))
							    (string-search-exact-char
							      #\newline new-line)))))))
	(do-line 0 line-1 old-line-1)
	(do-line 1 line-2 old-line-2)))
    (values line-1 line-2)))

(defflavor who-line-window () (who-line-mixin window))

(defmethod (:update who-line-window) () )

;;; After warm boot, tell the who line that the host is ok for displaying.
;;; We need a permanent flag so that if the who line gets refreshed again we
;;; don't lose the knowledge that the host name has been verified.
;;; Also, we need a flag that has been reset early on in the booting process.
(add-initialization "UPDATE-WHO-LINE-SCREEN"
		    '(when si:who-line-just-cold-booted-p
		       (setq si:who-line-just-cold-booted-p :host-name-verified)
		       (when who-line-file-state-sheet
			 (send who-line-file-state-sheet :clobbered)))
		    '(:warm))

;;; If the local name initializations are done, refresh the displayed host name.
(add-initialization "UPDATE-WHO-LINE-SCREEN"
		    '(when who-line-file-state-sheet
		       (send who-line-file-state-sheet :clobbered))
		    nil
		    'neti:local-name-initialization-list)

