;;; -*- Syntax: Zetalisp; Mode: LISP; Package: TV; Base: 8 -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(DEFUN %DRAW-RECTANGLE-CLIPPED (WIDTH HEIGHT X-BITPOS Y-BITPOS ALU-FUNCTION SHEET)
  (AND (MINUSP X-BITPOS) (SETQ WIDTH (+ WIDTH X-BITPOS)
			       X-BITPOS 0))
  (AND (MINUSP Y-BITPOS) (SETQ HEIGHT (+ HEIGHT Y-BITPOS)
			       Y-BITPOS 0))
  (SETQ WIDTH (MIN WIDTH (MAX 0 (- (SHEET-WIDTH SHEET) X-BITPOS))))
  (SETQ HEIGHT (MIN HEIGHT (MAX 0 (- (SHEET-HEIGHT SHEET) Y-BITPOS))))
  (AND (> WIDTH 0) (> HEIGHT 0)
       (SHEET-DRAW-RECTANGLE WIDTH HEIGHT X-BITPOS Y-BITPOS ALU-FUNCTION SHEET)))



;;;Primitives
(DEFMETHOD (:PRINT-SELF SHEET) (STREAM IGNORE SLASHIFY-P)
  (IF SLASHIFY-P
      (SI:PRINTING-RANDOM-OBJECT (SELF STREAM :NO-POINTER)	;Do %POINTER explicitly
	(FORMAT STREAM "~A ~A ~\SI:ADDRESS\ ~A"
		(TYPEP SELF) NAME (%POINTER SELF)
		(IF EXPOSED-P "exposed"
		    (IF (OR (NULL SUPERIOR)
			    (MEMQ SELF (SHEET-INFERIORS SUPERIOR)))
			"deexposed"
			"deactivated"))))
      (SEND STREAM ':STRING-OUT (STRING (OR (SEND SELF ':NAME-FOR-SELECTION) NAME))))) 

;;;Compute offsets for one sheet within another (WINDOW within TOP)
(DEFUN SHEET-CALCULATE-OFFSETS (WINDOW TOP &OPTIONAL (ERROR-P T))
  (DECLARE (VALUES X-OFFSET Y-OFFSET TOP-NOT-FOUND-P))
  (DO ((W WINDOW (SHEET-SUPERIOR W))
       (X-OFFSET 0)
       (Y-OFFSET 0))
      ((OR (NULL W)
	   (EQ W TOP))
       (COND ((EQ W TOP)
	      (VALUES X-OFFSET Y-OFFSET))
	     ((NOT ERROR-P)
	      ;; return a third value to indicate the sheet wasn't found
	      (VALUES X-OFFSET Y-OFFSET T))
	     (T (ferror "window ~s isn't a superior of ~s" top window))))
      (SETQ X-OFFSET (+ X-OFFSET (SHEET-X W))
	    Y-OFFSET (+ Y-OFFSET (SHEET-Y W)))))

(DEFUN SHEET-ME-OR-MY-KID-P (SHEET ME)
  (DO ((SHEET SHEET (SHEET-SUPERIOR SHEET)))
      ((NULL SHEET) NIL)
    (AND (EQ SHEET ME) (RETURN T))))

;;; For back-compatibility
(DEFUN SHEET-GET-SCREEN (SHEET)
  (SHEET-SCREEN SHEET))

(DEFUN SHEET-CALCULATE-SCREEN (SHEET &OPTIONAL HIGHEST)
  (DO ((SHEET SHEET SUPERIOR)
       (SUPERIOR SHEET (SHEET-SUPERIOR SUPERIOR)))
      ((OR (NULL SUPERIOR)
	   (EQ SUPERIOR HIGHEST))
       SHEET)))

;;; Call the given function on all the sheets in the universe.
(DEFUN MAP-OVER-EXPOSED-SHEETS (FUNCTION)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (DOLIST (SCREEN ALL-THE-SCREENS)
    (AND (SHEET-EXPOSED-P SCREEN)
	 (MAP-OVER-EXPOSED-SHEET FUNCTION SCREEN))))

(DEFUN MAP-OVER-EXPOSED-SHEET (FUNCTION SHEET)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (DOLIST (SHEET (SHEET-EXPOSED-INFERIORS SHEET))
    (MAP-OVER-EXPOSED-SHEET FUNCTION SHEET))
  (FUNCALL FUNCTION SHEET))

(DEFUN MAP-OVER-SHEETS (FUNCTION)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (DOLIST (SCREEN ALL-THE-SCREENS)
    (MAP-OVER-SHEET FUNCTION SCREEN)))

(DEFUN MAP-OVER-SHEET (FUNCTION SHEET)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (DOLIST (SHEET (SHEET-INFERIORS SHEET))
    (MAP-OVER-SHEET FUNCTION SHEET))
  (FUNCALL FUNCTION SHEET))

;;; This page implements locking for the window system.
;;; There are three instance variables:
;;;  LOCK		 NIL if this sheet is not itself locked.  The sheet is actually
;;;			 locked if the LOCK of any of its superiors is non-NIL.
;;;			 An atom is a lock ID (usually a process).
;;;			 A list is a list of temporary windows overlapping this one.
;;;  LOCK-COUNT		 The number of times LOCK has been locked, if it's a non-null atom.
;;;			 Otherwise zero.  Note that temp-locking doesn't increment this.
;;;  INFERIOR-LOCK-COUNT The number of non-null LOCKs among this sheet's inferiors to
;;;			 all levels.  If non-zero, locking this sheet requires
;;;			 inspecting its inferiors, in addition to the superiors,
;;;			 which must always be inspected.
;;; Locking a sheet changes the INFERIOR-LOCK-COUNT of its superiors to all levels,
;;; but doesn't touch its inferiors.  This minimizes paging since the tree of windows
;;; is short and bushy.
;;;
;;; An inferior of a locked window can be temp-locked by another inferior of the same
;;; locked window, and these locks can be set in either order.  The operation that locks
;;; the temp-locked window by propagation from its superior is also locking all the
;;; temp-locking windows.

(DEFUN SHEET-CAN-GET-LOCK (SHEET &OPTIONAL (UNIQUE-ID CURRENT-PROCESS))
  "Returns T if a sheet's lock can be gotten.  Should be called with interrupts
inhibited if it's to be meaningful."
  (AND ;; There must not be any conflicting locks in this window's inferiors
       (OR (ZEROP (SHEET-INFERIOR-LOCK-COUNT SHEET))
	   (CHECK-INFERIOR-LOCKS SHEET SHEET UNIQUE-ID (SHEET-INFERIOR-LOCK-COUNT SHEET)))
       ;; The locks of this window and all its superiors must either be free or
       ;; already owned by this unique-ID.
       (LOOP AS LOCK = (SHEET-LOCK SHEET)
	     AS INF = SHEET
	     DO (UNLESS (OR (NULL LOCK) (EQ LOCK UNIQUE-ID))
		  (RETURN NIL))
		(UNLESS (SETQ SHEET (SHEET-SUPERIOR SHEET))
		  (RETURN T))
		(UNLESS (MEMQ INF (SHEET-INFERIORS SHEET))
		  ;; Stop if inactive (like SHEET-LOCK-UPWARDS)
		  (RETURN T)))))

;; Check inferiors of this sheet for conflicting locks.
;; Returns decremented count if no conflicts, NIL as soon as a conflict is found.
;; The count is a performance bum to minimize paging on deactivated windows.
(DEFUN CHECK-INFERIOR-LOCKS (TOP-SHEET SHEET UNIQUE-ID COUNT)
  (LOOP FOR I IN (SHEET-INFERIORS SHEET)
	AS LOCK = (SHEET-LOCK I)
	DO (WHEN LOCK
	     (IF (OR (EQ LOCK UNIQUE-ID)
		     (AND (LISTP LOCK)
			  ;; If window is temp locked, and all of the temp lockers
			  ;; are inferiors of the top-level sheet, then it's ok.
			  (LOOP FOR L IN LOCK
				ALWAYS (SHEET-ME-OR-MY-KID-P L TOP-SHEET))))
		 ;; Locked in a non-conflicting way
		 (DECF COUNT)
		 ;; Conflicting lock
		 (RETURN-FROM CHECK-INFERIOR-LOCKS NIL)))
	   (WHEN (PLUSP (SHEET-INFERIOR-LOCK-COUNT I))
	     (UNLESS (SETQ COUNT (CHECK-INFERIOR-LOCKS TOP-SHEET I UNIQUE-ID COUNT))
	       (RETURN)))			;conflicting lock at lower level
	UNTIL (ZEROP COUNT))			;speed bum, stop if all locks have been found
  COUNT)

;;; Propagate upwards through INFERIOR-LOCK-COUNT of superiors
(DEFMACRO SHEET-LOCK-UPWARDS (SHEET DELTA &OPTIONAL ACTIVE-SUPERIOR)
  (IF ACTIVE-SUPERIOR
      `(UNLESS (EQ ,SHEET ,ACTIVE-SUPERIOR)
	 (LOOP FOR SUP = (SHEET-SUPERIOR ,SHEET) THEN (SHEET-SUPERIOR SUP)
	       DO (INCF (SHEET-INFERIOR-LOCK-COUNT SUP) ,DELTA)
	       UNTIL (EQ SUP ,ACTIVE-SUPERIOR)))
      `(LOOP FOR S = ,SHEET THEN SUP WITH SUP
	     WHILE (SETQ SUP (SHEET-SUPERIOR S))
	     WHILE (MEMQ S (SHEET-INFERIORS SUP))	;only propagate if active
	     DO (INCF (SHEET-INFERIOR-LOCK-COUNT SUP) ,DELTA))))

(DEFUN SHEET-GET-LOCK (SHEET &OPTIONAL (UNIQUE-ID CURRENT-PROCESS))
  (DO ((INHIBIT-SCHEDULING-FLAG T T)
       (ACTIVE-SUPERIOR SHEET SHEET))
      (())
    (COND #+IGNORE		;slower
	  ((SHEET-CAN-GET-LOCK SHEET UNIQUE-ID)
	   (RETURN (SHEET-GET-LOCK-INTERNAL SHEET UNIQUE-ID)))
	  #-IGNORE		;faster
	  ;; inline SHEET-CAN-GET-LOCK and SHEET-GET-LOCK-INTERNAL to cut
	  ;; in half the number of calls to MEMQ and generally speed things up
	  ((AND ;; There must not be any conflicting locks in this window's inferiors
	        (OR (ZEROP (SHEET-INFERIOR-LOCK-COUNT SHEET))
		    (CHECK-INFERIOR-LOCKS SHEET SHEET UNIQUE-ID
					  (SHEET-INFERIOR-LOCK-COUNT SHEET)))
		;; The locks of this window and all its superiors must either be free or
		;; already owned by this unique-ID.  ACTIVE-SUPERIOR is the highest sheet
		;; whose INFERIOR-LOCK-COUNT needs to be incremented, which is either
		;; the screen or the lowest sheet that is deactivated.
		(LOOP WITH SHEET = SHEET
		      AS LOCK = (SHEET-LOCK SHEET)
		      DO (UNLESS (OR (NULL LOCK) (EQ LOCK UNIQUE-ID))
			   (RETURN NIL))
			 (UNLESS (SETQ SHEET (SHEET-SUPERIOR (SETQ ACTIVE-SUPERIOR SHEET)))
			   (RETURN T))
			 (UNLESS (MEMQ ACTIVE-SUPERIOR (SHEET-INFERIORS SHEET))
			   ;; Stop if inactive (like SHEET-LOCK-UPWARDS)
			   (RETURN T))))
	   (SETF (SHEET-LOCK SHEET) UNIQUE-ID)
	   ;; Always bump the lock count here, then propagate
	   ;; upwards if lock was not formerly locked
	   (WHEN (= (INCF (SHEET-LOCK-COUNT SHEET)) 1)
	     (SHEET-LOCK-UPWARDS SHEET +1 ACTIVE-SUPERIOR))
	   (RETURN NIL))
	  (T
	   (SETQ INHIBIT-SCHEDULING-FLAG NIL)
	   (WAIT-FOR-SHEET-LOCK SHEET UNIQUE-ID)))))

(DEFUN SHEET-GET-LOCK-INTERNAL (SHEET UNIQUE-ID)
  "Really get the lock on a sheet and its inferiors.  Must be INHIBIT-SCHEDULING-FLAG
bound and set to T.  The caller must guarantee the lock isn't locked by someone else."
  (SETF (SHEET-LOCK SHEET) UNIQUE-ID)
  ;; Always bump the lock count here, then propagate upwards if lock was not formerly locked
  (WHEN (= (INCF (SHEET-LOCK-COUNT SHEET)) 1)
    (SHEET-LOCK-UPWARDS SHEET +1)))

(DEFUN WAIT-FOR-SHEET-LOCK (SHEET &OPTIONAL (UNIQUE-ID *CURRENT-PROCESS*) TIMEOUT)
  (LET ((WAITERS *SHEET-LOCK-WAITERS*))
    (DECLARE (SYS:ARRAY-REGISTER WAITERS))
    (WITHOUT-INTERRUPTS
      (LET ((I *NUMBER-OF-SHEET-LOCK-WAITERS*))
	(UNLESS (< I MAXIMUM-SHEET-LOCK-WAITERS)
	  ;; Full, discard the oldest
	  (CL:REPLACE WAITERS WAITERS :START2 1)
	  (INCF *NUMBER-OF-SHEET-LOCK-WAITERS-OVERFLOWS*)
	  (DECF I))
	(SETQ *NUMBER-OF-SHEET-LOCK-WAITERS* (1+ I))
	(SETF (AREF WAITERS I) *CURRENT-PROCESS*)))
    (UNWIND-PROTECT
	(LET ((PRIORITY (PROCESS:PROCESS-PROCESS-PRIORITY *CURRENT-PROCESS*)))
	  (IF (LDB-TEST PROCESS::%%SCHEDULER-PRIORITY-PREEMPTION-FIELD PRIORITY)
	      (PROCESS-WAIT-WITH-TIMEOUT "Sheet Lock" TIMEOUT
					 #'SHEET-CAN-GET-LOCK SHEET UNIQUE-ID)
	      ;; Change to preemptive priority so that when sheet-release-lock wakes us up
	      ;; so we can have the lock, we will really wake up right away
	      (PROCESS:WITH-PROCESS-PRIORITY
		  (DPB 1 PROCESS::%%SCHEDULER-PRIORITY-PREEMPTION-FIELD PRIORITY)
		(PROCESS-WAIT-WITH-TIMEOUT "Sheet Lock" TIMEOUT
					   #'SHEET-CAN-GET-LOCK SHEET UNIQUE-ID))))
      (WITHOUT-INTERRUPTS
	(LOOP FOR I FROM 0 BELOW *NUMBER-OF-SHEET-LOCK-WAITERS*
	      WITH J = 0 DO
	  (COND ((EQ (AREF WAITERS I) *CURRENT-PROCESS*)
		 (DECF *NUMBER-OF-SHEET-LOCK-WAITERS*))
		(T
		 (UNLESS (= J I)
		   (SETF (AREF WAITERS J) (AREF WAITERS I)))
		 (INCF J))))))))

(DEFUN SHEET-RELEASE-LOCK (SHEET &OPTIONAL (UNIQUE-ID CURRENT-PROCESS))
  "Release a lock on a sheet and its inferiors"
  ;; No-op if not locked, for ease of cleanup handlers
  (WITHOUT-INTERRUPTS
    (WHEN (EQ (SHEET-LOCK SHEET) UNIQUE-ID)
      (WHEN (ZEROP (DECF (SHEET-LOCK-COUNT SHEET)))
	;; Last locker of this sheet is letting go
	(SETF (SHEET-LOCK SHEET) NIL)
	;; Propagate upwards
	(SHEET-LOCK-UPWARDS SHEET -1)
	;; Wakeup processes that might be waiting for this lock
	;; We might have freed a lock that doesn't conflict with the one a process
	;; is waiting for, but checking for that is just as expensive as calling
	;; SHEET-CAN-GET-LOCK, so we'll just wakeup every waiting process and
	;; let the process's verify-function do the checking.
	(LET ((N *NUMBER-OF-SHEET-LOCK-WAITERS*))
	  (COMPILER:%ERROR-WHEN (PLUSP N)
	    (LET ((WAITERS *SHEET-LOCK-WAITERS*))
	      (DECLARE (SYS:ARRAY-REGISTER WAITERS))
	      (LOOP FOR I FROM 0 BELOW N DO
		(PROCESS:PROCESS-WAKEUP (AREF WAITERS I)))))))
      T D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");return a definite value of T if we unlocked something
0      )))

(DEFUN SHEET-CAN-GET-TEMPORARY-LOCK (SHEET REQUESTOR)
  "Returns T if the temp-lock can be grabbed.  Should be called with interrupts inhibited.
REQUESTOR is the temporary sheet that is going to cover SHEET."
  ;; SHEET must either be unlocked or temp-locked.
  ;; If any superior is locked, REQUESTOR must be a direct or indirect inferior of it.
  ;; REQUESTOR is never a direct or indirect inferior of the original SHEET.
  (LOOP ALWAYS (OR (CL:LISTP (SHEET-LOCK SHEET))
		   (SHEET-ME-OR-MY-KID-P REQUESTOR SHEET))
	WHILE (SETQ SHEET (SHEET-SUPERIOR SHEET))))

(DEFUN SHEET-GET-TEMPORARY-LOCK (SHEET REQUESTOR)
  "Get a temporary lock on a sheet.  Requestor is used as the unique-id."
  (DO ((INHIBIT-SCHEDULING-FLAG T T))
      ((SHEET-CAN-GET-TEMPORARY-LOCK SHEET REQUESTOR)
       (UNLESS (SHEET-LOCK SHEET)
	 ;; Propagate upwards
	 (SHEET-LOCK-UPWARDS SHEET +1))
       (PUSH REQUESTOR (SHEET-LOCK SHEET))
       NIL)
    (SETQ INHIBIT-SCHEDULING-FLAG NIL)
    (PROCESS-WAIT "Sheet Lock" #'SHEET-CAN-GET-TEMPORARY-LOCK SHEET REQUESTOR)))

(DEFUN SHEET-RELEASE-TEMPORARY-LOCK (SHEET REQUESTOR)
  "Release a temporary lock on a sheet."
  (WITHOUT-INTERRUPTS
    (WHEN (LISTP (SHEET-LOCK SHEET))		;In case not really locked
      (UNLESS (SETF (SHEET-LOCK SHEET) (DELQ REQUESTOR (SHEET-LOCK SHEET)))
	;; Propagate upwards
	(SHEET-LOCK-UPWARDS SHEET -1)))))

(DEFUN SHEET-FREE-TEMPORARY-LOCKS (SHEET)
  "Free all temporary locks on a sheet by deexposing the sheets that own the lock."
  (DO ((LOCK (SHEET-LOCK SHEET) (SHEET-LOCK SHEET)))
      ((NULL LOCK) T)
    (OR (LISTP LOCK)
	(RETURN NIL))				;Not temporary locked, can't do anything
    (OR (= DTP-INSTANCE (%DATA-TYPE (SETQ LOCK (CAR LOCK))))
	(RETURN NIL))				;The lock isn't an instance, can't do anything
    (OR (GET-HANDLER-FOR LOCK ':DEEXPOSE)
	(RETURN NIL))				;An instance, but maybe not a window -- punt
    (COND ((LISTP (SHEET-LOCK LOCK))		;Is the locker also temp locked?
	   (OR (SHEET-FREE-TEMPORARY-LOCKS LOCK);Yes, free it up first.  If ok, keep going
	       (RETURN NIL))))
    (SEND LOCK ':DEEXPOSE)))

(DEFUN SCREEN-CLEAR-LOCKS (SCREEN)
  (SHEET-CLEAR-LOCKS-INTERNAL SCREEN)
  (PROCESS:RESET-LOCK (SCREEN-LOCK SCREEN)))

(DEFUN SHEET-CLEAR-LOCKS ()
  "Called in an emergency to reset all locks"
  (MAPC #'SCREEN-CLEAR-LOCKS ALL-THE-SCREENS)
  (SETF PREPARED-SHEET NIL))

(DEFUN SHEET-CLEAR-LOCKS-INTERNAL (SHEET)
  (SETF (SHEET-LOCK SHEET) NIL)
  (SETF (SHEET-LOCK-COUNT SHEET) 0)
  (SETF (SHEET-INFERIOR-LOCK-COUNT SHEET) 0)
  (SETF (SHEET-TEMPORARY-WINDOWS-LOCKED SHEET) NIL)
  (SETF (SHEET-INVISIBLE-TO-MOUSE-P SHEET) NIL)
  (SETF (SHEET-OFF-SCREEN-DRAWING-FLAG SHEET) 0)
  (DOLIST (SHEET (SHEET-INFERIORS SHEET))
    (SHEET-CLEAR-LOCKS-INTERNAL SHEET)))

(DEFUN SHEET-ASSURE-LOCK-AVAILABLE (SHEET)
  "Must be called with INHIBIT-SCHEDULING-FLAG bound to T.  Waits until the lock can be
gotten on SHEET, and returns in that state with scheduling inhibited."
  (DO () ((SHEET-CAN-GET-LOCK SHEET))
    (SETQ INHIBIT-SCHEDULING-FLAG NIL)
    (WAIT-FOR-SHEET-LOCK SHEET)
    (SETQ INHIBIT-SCHEDULING-FLAG T)))

(DEFMETHOD (LOCK-SHEET-1 SHEET) (CONTINUATION &KEY GUARDS (WAIT-FOR-LOCK T))
  WAIT-FOR-LOCK
  (LOCK-SHEET (SELF)
    (CL:LOOP
       (BLOCK TRY-LOCKS
	 (DOLIST (GUARD GUARDS)
	   (WHEN (FUNCALL (CAR GUARD) SELF)
	     (SHEET-RELEASE-LOCK SELF)
	     (UNWIND-PROTECT
		 (FUNCALL (CDR GUARD) SELF)
	       (SHEET-GET-LOCK SELF))
	     (RETURN-FROM TRY-LOCKS)))
	 (RETURN)))
    (FUNCALL CONTINUATION)))

(DEFUN WAIT-FOR-MOUSE (SHEET MOUSE FOR-EXPOSE)
  (LET ((WAITERS *MOUSE-WAITERS*))
    (DECLARE (SYS:ARRAY-REGISTER WAITERS))
    (WITHOUT-INTERRUPTS
      (LET ((I *NUMBER-OF-MOUSE-WAITERS*))
	(UNLESS (< I MAXIMUM-MOUSE-WAITERS)
	  ;; Full, discard the oldest
	  (CL:REPLACE WAITERS WAITERS :START2 1)
	  (INCF *NUMBER-OF-MOUSE-WAITERS-OVERFLOWS*)
	  (DECF I))
	(SETQ *NUMBER-OF-MOUSE-WAITERS* (1+ I))
	(SETF (AREF WAITERS I) *CURRENT-PROCESS*)))
    (UNWIND-PROTECT
	(LET ((FUNCTION 
		;;--- I don't know whether the difference between these two wait functions
		;;--- actually makes any difference, I'm just copying the code that was
		;;--- there before I got here.
		(IF FOR-EXPOSE
		    #'(LAMBDA (MOUSE SHEET)
			(DECLARE (IGNORE MOUSE))
			(NOT (SHEET-IS-MOUSE-WINDOW-P SHEET)))	    
		    #'(LAMBDA (MOUSE SHEET)
			(LET ((MW (MOUSE-WINDOW MOUSE)))
			  (OR (NOT (TYPEP MW 'SHEET))
			      (NOT (SHEET-ME-OR-MY-KID-P MW SHEET)))))))
	      (PRIORITY (PROCESS:PROCESS-PROCESS-PRIORITY *CURRENT-PROCESS*)))
	  (IF (LDB-TEST PROCESS::%%SCHEDULER-PRIORITY-PREEMPTION-FIELD PRIORITY)
	      (PROCESS-WAIT "Mouse Out" FUNCTION MOUSE SHEET)
	      ;; Change to preemptive priority so that when mouse-overseer wakes us up
	      ;; so we can have the lock, we will really wake up right away
	      (PROCESS:WITH-PROCESS-PRIORITY
		  (DPB 1 PROCESS::%%SCHEDULER-PRIORITY-PREEMPTION-FIELD PRIORITY)
		(PROCESS-WAIT "Mouse Out" FUNCTION MOUSE SHEET))))
      (WITHOUT-INTERRUPTS
	(LOOP FOR I FROM 0 BELOW *NUMBER-OF-MOUSE-WAITERS*
	      WITH J = 0 DO
	  (COND ((EQ (AREF WAITERS I) *CURRENT-PROCESS*)
		 (DECF *NUMBER-OF-MOUSE-WAITERS*))
		(T
		 (UNLESS (= J I)
		   (SETF (AREF WAITERS J) (AREF WAITERS I)))
		 (INCF J))))))))

(DEFUN SHEET-NEEDS-OUTPUT-HOLD-EXCEPTION (SHEET)
  (NOT (ZEROP (SHEET-OUTPUT-HOLD-FLAG SHEET))))

(DEFUN SHEET-SIGNAL-OUTPUT-HOLD-EXCEPTION (SHEET)
  (SEND SHEET :OUTPUT-HOLD-EXCEPTION))

;;; **********************************************************************
;;; ** The following is a total kludge and should not even be looked at **
;;; **********************************************************************
(DEFUN-IN-FLAVOR (SHEET-MORE-LOCK-KLUDGE SHEET) (FUN &REST ARGS)
  (UNPREPARE-SHEET
    (PROGN
      (WHEN (AND LOCK (NOT (EQ LOCK CURRENT-PROCESS)))
	(FERROR NIL "Attempt to **MORE** when sheet was not locked by current process."))
      (LEXPR-FUNCALL FUN ARGS))))
;;; ******************* End of total, complete, and utter kludge *******************

(DEFMETHOD (SHEET-BLINK-BLINKERS SHEET) (DELTA)
  (WHEN (AND EXPOSED-P
	     (ZEROP (SHEET-OUTPUT-HOLD-FLAG))
	     (NULL LOCK)			;Superiors guaranteed to be unlocked
	     (ZEROP (SHEET-DONT-BLINK-BLINKERS-FLAG)))
    (LET ((NEXT-INTERVAL NIL))
      (FLET ((ADD-INTERVAL (INTERVAL)
	       (COND ((NULL INTERVAL))
		     ((NULL NEXT-INTERVAL)
		      (SETF NEXT-INTERVAL INTERVAL))
		     (T
		      (SETF NEXT-INTERVAL (MIN NEXT-INTERVAL INTERVAL))))))
	(DOLIST (B BLINKER-LIST)
	  (ADD-INTERVAL (BLINKER-TIME-HAS-PASSED B DELTA)))
	(DOLIST (S EXPOSED-INFERIORS)
	  (ADD-INTERVAL (SHEET-BLINK-BLINKERS S DELTA)))
	NEXT-INTERVAL))))


;;; SHEET-CAN-GET-LOCK, ignoring locks on inferiors and ignoring temp-locks
(DEFUN SHEET-CAN-ACTIVATE-INFERIOR (SUPERIOR)
  ;; The locks of this window and all its superiors must either be free or
  ;; already owned by this unique-ID.
  (LOOP AS LOCK = (SHEET-LOCK SUPERIOR)
	ALWAYS (OR (CL:LISTP LOCK) (EQ LOCK CURRENT-PROCESS))
	WHILE (SETQ SUPERIOR (SHEET-SUPERIOR SUPERIOR))))

(DEFMETHOD (:INFERIOR-ACTIVATE SHEET) (INFERIOR) INFERIOR)
(DEFMETHOD (:INFERIOR-DEACTIVATE SHEET) (INFERIOR) INFERIOR)

(DEFMETHOD (:INFERIOR-TIME-STAMP SHEET) (INFERIOR)
  INFERIOR
  (OR CURRENT-TIME-STAMP
      (SETF CURRENT-TIME-STAMP 
	    (MAKE-INSTANCE 'SHEET-TIME-STAMP
			   :INSIDE-WIDTH (SHEET-INSIDE-WIDTH)
			   :INSIDE-HEIGHT (SHEET-INSIDE-HEIGHT)
			   :TOP-MARGIN-SIZE TOP-MARGIN-SIZE
			   :LEFT-MARGIN-SIZE LEFT-MARGIN-SIZE
			   :CHAR-ALUF CHAR-ALUF
			   :ERASE-ALUF ERASE-ALUF
			   :RESOURCE-TICK (SCREEN-RESOURCE-TICK SCREEN)
			   :DISPLAY-DEVICE-TYPE DISPLAY-DEVICE-TYPE
			   ))))

(DEFMETHOD (:UPDATE-CURRENT-TIMESTAMP SHEET) ()
  (SETF CURRENT-TIME-STAMP NIL))

(DEFMETHOD (SCALE-INFERIORS-MIXIN-SCALE-INFERIOR SHEET :DEFAULT) (INFERIOR OLD-TIME-STAMP)
  INFERIOR OLD-TIME-STAMP
  NIL)

(DEFMETHOD (SHEET-RESOLVE-TIME-STAMP SHEET) ()
  (WHEN SUPERIOR
    (LET ((SUP-TIME-STAMP (SEND SUPERIOR :INFERIOR-TIME-STAMP SELF))
	  (OLD-TIME-STAMP TIME-STAMP))
      (WHEN (NOT (EQ OLD-TIME-STAMP SUP-TIME-STAMP))
	;; Update timestamp
	(SETF TIME-STAMP SUP-TIME-STAMP)
	;; Now update things
	(WHEN (NOT (NULL OLD-TIME-STAMP))
	  ;; Flush resources
	  (WHEN (NOT (EQL (SCREEN-RESOURCE-TICK SCREEN)
			  (SHEET-TIME-STAMP-RESOURCE-TICK OLD-TIME-STAMP)))
	    (WITHOUT-SCREEN-MANAGEMENT		;if deexpose inferiors, don't try to draw on
						;the screen that isn't there
	      (SHEET-FLUSH-SCREEN-RESOURCES SELF)
	      (SEND SELF :UPDATE-CURRENT-TIMESTAMP)))
	  ;; Update ALUFs
	  (LET ((TS-CHAR-ALUF (SHEET-TIME-STAMP-CHAR-ALUF OLD-TIME-STAMP))
		(TS-ERASE-ALUF (SHEET-TIME-STAMP-ERASE-ALUF OLD-TIME-STAMP)))
	    (MULTIPLE-VALUE-BIND (SUP-CHAR-ALUF SUP-ERASE-ALUF BLINK)
		(SEND SUPERIOR :DEFAULT-INFERIOR-ALUFS)
	      (WHEN (OR (NOT (EQL SUP-CHAR-ALUF TS-CHAR-ALUF))
			(NOT (EQL SUP-ERASE-ALUF TS-ERASE-ALUF)))
		(WHEN (NOT (ZEROP (SHEET-REVERSE-VIDEO)))
		  (SWAPF SUP-CHAR-ALUF SUP-ERASE-ALUF))
		(SETF CHAR-ALUF SUP-CHAR-ALUF)
		(SETF ERASE-ALUF SUP-ERASE-ALUF)
		(DOLIST (BLINKER BLINKER-LIST)
		  (SETF (BLINKER-BLINKER-ALU BLINKER) BLINK))
		(SEND SELF :UPDATE-CURRENT-TIMESTAMP))))
	  ;; Update display device type
	  (LET ((SUP-DISPLAY-DEVICE-TYPE (SHEET-DISPLAY-DEVICE-TYPE SUPERIOR)))
	    (WHEN (NOT (EQ SUP-DISPLAY-DEVICE-TYPE
			   (SHEET-TIME-STAMP-DISPLAY-DEVICE-TYPE OLD-TIME-STAMP)))
	      (SETQ DISPLAY-DEVICE-TYPE SUP-DISPLAY-DEVICE-TYPE)
	      (SEND CHARSET&STYLEFONT-CACHE :TABLE-CLEAR)
	      (RECACHE-DEFAULT-FONT)
	      (SEND SELF :SET-LINE-HEIGHT-FROM-STYLES MERGED-CURRENT-STYLE)
	      (SEND SELF :UPDATE-CURRENT-TIMESTAMP)))
	  ;; Update sheet size
	  (SCALE-INFERIORS-MIXIN-SCALE-INFERIOR SUPERIOR SELF OLD-TIME-STAMP))))))

(DEFUN SHEET-RESOLVE-INFERIOR-TIME-STAMPS (SHEET)
  (MAPC #'(LAMBDA (SHEET)
	    (SHEET-RESOLVE-TIME-STAMP SHEET)
	    (SHEET-RESOLVE-INFERIOR-TIME-STAMPS SHEET))
	;; Copy the list we are iterating over, because during its processing
	;; of SHEET-RESOLVE-TIME-STAMP a window might bury itself, changing
	;; the order of elements in the list.
	(COPYLIST (SHEET-INFERIORS SHEET))))

;;; Activation and deactivation (these go with locking)

(DEFMETHOD (:ACTIVATE SHEET) (&AUX (INHIBIT-SCHEDULING-FLAG T))
  "Activates a sheet."
  (WHEN (AND SUPERIOR
	     (NEQ SCREEN (SHEET-SCREEN SUPERIOR)))
    (SEND SELF :SET-SUPERIOR SUPERIOR))
  (COND ((NOT (SEND SUPERIOR ':INFERIOR-ACTIVATE SELF)))
	((DO () ((MEMQ SELF (SHEET-INFERIORS SUPERIOR)) NIL)
	   (COND ((NOT (SHEET-CAN-GET-LOCK SELF))
		  (SETQ INHIBIT-SCHEDULING-FLAG NIL)
		  (WAIT-FOR-SHEET-LOCK SELF)
		  (SETQ INHIBIT-SCHEDULING-FLAG T))
		 ((SHEET-CAN-ACTIVATE-INFERIOR SUPERIOR)
		  (RETURN T))
		 (T
		  (SETQ INHIBIT-SCHEDULING-FLAG NIL)
		  ;; Wait for sheet to become activatable or to become activated
		  (PROCESS-WAIT "Activate" #'(LAMBDA (SHEET SUP)
					       (OR (SHEET-CAN-ACTIVATE-INFERIOR SUP)
						   (MEMQ SHEET (SHEET-INFERIORS SUP))))
				SELF SUPERIOR)
		  ;; Loop back to prevent timing screws
		  (SETQ INHIBIT-SCHEDULING-FLAG T))))
	 ;; Executed if we are not active already
	 (SHEET-CONSING
	   (SETF (SHEET-INFERIORS SUPERIOR)
		 ;; Put the new window at the end of the list 'cuz otherwise it
		 ;; immediately gets displayed in the background and looks spastic.
		 (APPEND (SHEET-INFERIORS SUPERIOR) (NCONS SELF))))
	 ;; If we are locked, propagate up to superior
	 (LET ((DELTA (+ (IF LOCK 1 0) INFERIOR-LOCK-COUNT)))
	   (UNLESS (ZEROP DELTA)
	     (SHEET-LOCK-UPWARDS SELF DELTA)))
	 (SETF INHIBIT-SCHEDULING-FLAG NIL)
	 (SHEET-RESOLVE-TIME-STAMP SELF)
	 (SHEET-RESOLVE-INFERIOR-TIME-STAMPS SELF))))

;;; Do some of what :ACTIVATE does without actually activating
;;; Call this before trying to draw on a deactivated window
(DEFMETHOD (SHEET-VALIDATE-DEACTIVATED-SCREEN-ARRAY SHEET) ()
  (UNLESS (MEMQ SELF (SHEET-INFERIORS SUPERIOR))	;do only if deactivated
    (UNLESS (EQ SCREEN (SHEET-SCREEN SUPERIOR))
      (SEND SELF :SET-SUPERIOR SUPERIOR))
    (SHEET-RESOLVE-TIME-STAMP SELF)
    (SHEET-RESOLVE-INFERIOR-TIME-STAMPS SELF)))

(DEFWHOPPER (:DEACTIVATE SHEET) ()
  (WITH-MOUSE-SAFELY-OUT-OF-THE-WAY
    (CONTINUE-WHOPPER)))

;A separate method from (SHEET :ACTIVATE) so that screens get it, too.
(DEFMETHOD (:ACTIVATE SHEET :BEFORE) ()
  (UNLESS (ZEROP (SHEET-DEAD))
    (FSIGNAL "Attempt to activate ~S, which has been sent a :KILL message" SELF)
    (SETF (SHEET-DEAD) 0)))			;In case it can be resuscitated

(DEFMETHOD (:DEACTIVATE SHEET) (&AUX (INHIBIT-SCHEDULING-FLAG T))
  "Deactivates a sheet.  Should be called by all deactivate methods to do the actual work."
  (WHEN (SEND SUPERIOR :INFERIOR-DEACTIVATE SELF)
    (DO () ((NOT (MEMQ SELF (SHEET-EXPOSED-INFERIORS SUPERIOR))))
      (SETQ INHIBIT-SCHEDULING-FLAG NIL)
      (SEND SELF :DEEXPOSE (IF (NOT (ZEROP (SHEET-FORCE-SAVE-BITS))) :DEFAULT NIL))
      (SETQ INHIBIT-SCHEDULING-FLAG T))
    (WHEN (MEMQ SELF (SHEET-INFERIORS SUPERIOR))
      ;; We are locked, de-propagate from superior
      (LET ((DELTA (+ (IF LOCK 1 0) INFERIOR-LOCK-COUNT)))
	(SHEET-LOCK-UPWARDS SELF (- DELTA)))
      ;; Keep INFERIORS list cdr-coded, at the cost of copying it
      (SHEET-CONSING
	(SETF (SHEET-INFERIORS SUPERIOR) (REMQ SELF (SHEET-INFERIORS SUPERIOR)))))))

(DEFMETHOD (:KILL SHEET) ()
  "Killing deactivate self, then kills all inferiors."
  (DELAYING-SCREEN-MANAGEMENT
    (SEND SELF :DEEXPOSE NIL)
    (SEND SELF :DEACTIVATE)
    ;; Do it this way to prevent CDR'ing down list structure being modified
    (LOOP UNTIL (NULL INFERIORS)
	  DO (SEND (CAR INFERIORS) :KILL))
    (SETF (SHEET-DEAD) 1)))

(DEFUN SHEET-OVERLAPS-P (SHEET LEFT TOP WIDTH HEIGHT
			       &AUX (W-X (SHEET-X SHEET))
			            (W-Y (SHEET-Y SHEET))
				    (W-X1 (+ W-X (SHEET-WIDTH SHEET)))
				    (W-Y1 (+ W-Y (SHEET-HEIGHT SHEET))))
  "True if a sheet overlaps the given area"
  (NOT (OR ( LEFT W-X1)
	   ( W-X (+ LEFT WIDTH))
	   ( TOP W-Y1)
	   ( W-Y (+ TOP HEIGHT)))))

(DEFUN SHEET-OVERLAPS-EDGES-P (SHEET LEFT TOP RIGHT BOTTOM
			       &AUX (W-X (SHEET-X SHEET))
			            (W-Y (SHEET-Y SHEET))
				    (W-X1 (+ W-X (SHEET-WIDTH SHEET)))
				    (W-Y1 (+ W-Y (SHEET-HEIGHT SHEET))))
  "True if a sheet overlaps the given four coordinates"
  (NOT (OR ( LEFT W-X1)
	   ( W-X RIGHT)
	   ( TOP W-Y1)
	   ( W-Y BOTTOM))))

(DEFUN SHEET-OVERLAPS-SHEET-P (SHEET-A SHEET-B &AUX X-OFF-A X-OFF-B
				                    Y-OFF-A Y-OFF-B)
  "True if two sheets overlap"
  (COND ((EQ (SHEET-SUPERIOR SHEET-A) (SHEET-SUPERIOR SHEET-B))
	 ;; If superiors are the same, simple comparison
	 (SHEET-OVERLAPS-P SHEET-A (SHEET-X SHEET-B) (SHEET-Y SHEET-B)
			   (SHEET-WIDTH SHEET-B) (SHEET-HEIGHT SHEET-B)))
	(T
	 (MULTIPLE-VALUE (X-OFF-A Y-OFF-A)
	   (SHEET-CALCULATE-OFFSETS SHEET-A NIL))
	 (MULTIPLE-VALUE (X-OFF-B Y-OFF-B)
	   (SHEET-CALCULATE-OFFSETS SHEET-B NIL))
	 (NOT (OR ( X-OFF-A (+ X-OFF-B (SHEET-WIDTH SHEET-B)))
		  ( X-OFF-B (+ X-OFF-A (SHEET-WIDTH SHEET-A)))
		  ( Y-OFF-A (+ Y-OFF-B (SHEET-HEIGHT SHEET-B)))
		  ( Y-OFF-B (+ Y-OFF-A (SHEET-HEIGHT SHEET-A))))))))

(DEFUN SHEET-WITHIN-P (SHEET OUTER-LEFT OUTER-TOP OUTER-WIDTH OUTER-HEIGHT
			     &AUX (W-X (SHEET-X SHEET))
			          (W-Y (SHEET-Y SHEET))
				  (W-X1 (+ W-X (SHEET-WIDTH SHEET)))
				  (W-Y1 (+ W-Y (SHEET-HEIGHT SHEET))))
  "True if the sheet is fully within the specified rectangle"
  (AND ( OUTER-LEFT W-X)
       ( W-X1 (+ OUTER-LEFT OUTER-WIDTH))
       ( OUTER-TOP W-Y)
       ( W-Y1 (+ OUTER-TOP OUTER-HEIGHT))))

(DEFUN SHEET-BOUNDS-WITHIN-SHEET-P (W-X W-Y WIDTH HEIGHT OUTER-SHEET
					&AUX (OUTER-LEFT (SHEET-INSIDE-LEFT OUTER-SHEET))
					     (OUTER-TOP (SHEET-INSIDE-TOP OUTER-SHEET))
					     (OUTER-WIDTH (SHEET-INSIDE-WIDTH OUTER-SHEET))
					     (OUTER-HEIGHT (SHEET-INSIDE-HEIGHT OUTER-SHEET)))
  "True if the specified rectangle is fully within the non-margin part of the sheet"
  (AND ( OUTER-LEFT W-X)
       ( (+ W-X WIDTH) (+ OUTER-LEFT OUTER-WIDTH))
       ( OUTER-TOP W-Y)
       ( (+ W-Y HEIGHT) (+ OUTER-TOP OUTER-HEIGHT))))

(DEFUN SHEET-WITHIN-SHEET-P (SHEET OUTER-SHEET)
  "True if sheet is fully within the non-margin area of the outer sheet"
  (SHEET-WITHIN-P SHEET (SHEET-INSIDE-LEFT OUTER-SHEET) (SHEET-INSIDE-TOP OUTER-SHEET)
		        (SHEET-INSIDE-WIDTH OUTER-SHEET)
			(SHEET-INSIDE-HEIGHT OUTER-SHEET)))

(DEFUN SHEET-CONTAINS-SHEET-POINT-P (SHEET TOP-SHEET X Y)
  "T if (X,Y) lies in SHEET.  X and Y are co-ordinates in TOP-SHEET."
  (DO ((S SHEET (SHEET-SUPERIOR S))
       (X X (- X (SHEET-X S)))
       (Y Y (- Y (SHEET-Y S))))
      ((NULL S))			;Not in the same hierarchy, return nil
    (AND (EQ S TOP-SHEET)
	 (RETURN (AND ( X 0) ( Y 0)
		      (< X (SHEET-WIDTH SHEET)) (< Y (SHEET-HEIGHT SHEET)))))))

;;; A sheet is no longer "selected", blinkers are left on or turned off as wanted
(DEFUN DESELECT-SHEET-BLINKERS (SHEET)
  (DOLIST (BLINKER (SHEET-BLINKER-LIST SHEET))
    (AND (EQ (BLINKER-VISIBILITY BLINKER) ':BLINK)
	 (SETF (BLINKER-VISIBILITY BLINKER)
	       (BLINKER-DESELECTED-VISIBILITY BLINKER)))))

;;; Turn off blinkers, regardless of deselected-visibility
(DEFUN TURN-OFF-SHEET-BLINKERS (SHEET)
  (DOLIST (BLINKER (SHEET-BLINKER-LIST SHEET))
    (AND (MEMQ (BLINKER-VISIBILITY BLINKER) '(:BLINK :ON))
	 (SETF (BLINKER-VISIBILITY BLINKER) ':OFF))))

;;; A sheet is to be selected, make sure its blinkers are blinking if they should be
(DEFUN SELECT-SHEET-BLINKERS (SHEET)
  (DOLIST (BLINKER (SHEET-BLINKER-LIST SHEET))
    (AND (MEMQ (BLINKER-VISIBILITY BLINKER) '(:ON :OFF))
	 (SETF (BLINKER-VISIBILITY BLINKER) ':BLINK))))

(DEFUN SHEET-OPEN-ALL-BLINKERS (FROM-SHEET)
  (DO SHEET FROM-SHEET (SHEET-SUPERIOR SHEET) (NULL SHEET)
      (DOLIST (BLINKER (SHEET-BLINKER-LIST SHEET))
	(OPEN-BLINKER BLINKER))
      ;; If this sheet is not exposed, don't have to open blinkers on superior
      (OR (SHEET-EXPOSED-P SHEET) (RETURN NIL))))

(DEFUN SHEET-OPEN-BLINKERS (SHEET)
  (DOLIST (BLINKER (SHEET-BLINKER-LIST SHEET))
    (OPEN-BLINKER BLINKER)))

(DEFUN SHEET-FOLLOWING-BLINKER (SHEET)
  "Return NIL or the blinker which follows the sheet's cursorpos
  If there is more than one, which would be strange, only one is returned."
  (DOLIST (B (SHEET-BLINKER-LIST SHEET))
    (AND (BLINKER-FOLLOW-P B) (RETURN B))))

(DEFUN SHEET-OPEN-ALL-CONFLICTING-BLINKERS (FROM-SHEET)
  (LOOP WITH FROM-WIDTH = (SHEET-WIDTH FROM-SHEET)
	WITH FROM-HEIGHT = (SHEET-HEIGHT FROM-SHEET)
	WITH THE-MOUSE-BLINKER = (LET ((MOUSE (SHEET-MOUSE FROM-SHEET)))
				   (AND MOUSE (MOUSE-POTENTIALLY-CONFLICTING-BLINKER MOUSE)))
	FOR PREVIOUS-SHEET = FROM-SHEET THEN SHEET
	WHEN (NOT (SHEET-EXPOSED-P PREVIOUS-SHEET))
	  RETURN NIL
	AS SHEET = (SHEET-SUPERIOR PREVIOUS-SHEET)
	WHEN (NULL SHEET)
	  ;; Record the screen area occupied by this prepared sheet for the
	  ;; benefit of fast-tracking
	  RETURN (SCREEN-OPEN-ALL-CONFLICTING-BLINKERS
		   PREVIOUS-SHEET
		   X-OFFSET-TO-ORIGINAL Y-OFFSET-TO-ORIGINAL
		   (+ X-OFFSET-TO-ORIGINAL FROM-WIDTH) (+ Y-OFFSET-TO-ORIGINAL FROM-HEIGHT))
	SUM (SHEET-X-OFFSET PREVIOUS-SHEET) INTO X-OFFSET-TO-ORIGINAL
	SUM (SHEET-Y-OFFSET PREVIOUS-SHEET) INTO Y-OFFSET-TO-ORIGINAL
	DO (LOOP WITH INSIDE-LEFT-TO-ORIGINAL = (- X-OFFSET-TO-ORIGINAL
						   (SHEET-INSIDE-LEFT SHEET))
		 WITH INSIDE-TOP-TO-ORIGINAL = (- Y-OFFSET-TO-ORIGINAL
						  (SHEET-INSIDE-TOP SHEET))
		 FOR BLINKER IN (SHEET-BLINKER-LIST SHEET)
		 WHEN (OR (BLINKER-PHASE BLINKER)	;Image of this visible on screen, or
			  (EQ BLINKER THE-MOUSE-BLINKER)) ;fast-tracking visible for this one
		   DO (MULTIPLE-VALUE-BIND (BLEFT BTOP) (SEND BLINKER ':READ-CURSORPOS)
			(MULTIPLE-VALUE-BIND (BW BH) (SEND BLINKER ':SIZE)
			  ;; adjust bleft and btop to be relative to original
			  (DECF BLEFT INSIDE-LEFT-TO-ORIGINAL)
			  (DECF BTOP INSIDE-TOP-TO-ORIGINAL)
			  (UNLESS (OR ( BLEFT FROM-WIDTH)
				      ( 0 (+ BLEFT BW))
				      ( BTOP FROM-HEIGHT)
				      ( 0 (+ BTOP BH)))
			    (OPEN-BLINKER BLINKER)))))))

(DEFUN OPEN-INFERIOR-BLINKERS (SHEET)
  (DOLIST (INFERIOR (SHEET-EXPOSED-INFERIORS SHEET))
    (WHEN (SHEET-EXPOSED-P INFERIOR)
      (OPEN-INFERIOR-BLINKERS INFERIOR)))
  (DOLIST (BLINKER (SHEET-BLINKER-LIST SHEET))
    (OPEN-BLINKER BLINKER))
  NIL)

(DEFUN SHEET-PREPARE-SHEET-INTERNAL (SHEET)
  "This is an internal function for PREPARE-SHEET, and must be called with the sheet locked."
  (DO () ((NOT (SHEET-OUTPUT-HELD-P SHEET)))
    (WITHOUT-SCREEN-CONTROLLER-LOCK ((SHEET-SCREEN SHEET))
      (SHEET-RELEASE-LOCK SHEET)
      (UNWIND-PROTECT
	  (SEND SHEET :OUTPUT-HOLD-EXCEPTION)
	(SHEET-GET-LOCK SHEET))))
  (IF (SHEET-INFERIORS SHEET)
      (OPEN-INFERIOR-BLINKERS SHEET)
      ;; No need to do full hair if no inferiors
      (DOLIST (BLINKER (SHEET-BLINKER-LIST SHEET))
	(OPEN-BLINKER BLINKER)))
  (WHEN (SHEET-EXPOSED-P SHEET)
    ;; Only open blinkers on superior if we are exposed
    (SHEET-OPEN-ALL-CONFLICTING-BLINKERS SHEET)))



(DEFUN-IN-FLAVOR (DECODE-CHARACTER-WIDTH-SPEC SHEET) (SPEC)
  (COND ((NUMBERP SPEC)
	 (+ (* SPEC CHAR-WIDTH) LEFT-MARGIN-SIZE RIGHT-MARGIN-SIZE))
	((STRINGP SPEC)
	 (MULTIPLE-VALUE-BIND (NIL NIL MAX-X)
	     (SEND SELF ':STRING-LENGTH SPEC)
	   (+ MAX-X LEFT-MARGIN-SIZE RIGHT-MARGIN-SIZE)))
	(T (FERROR "~S illegal as :CHARACTER-WIDTH; use a number or string" SPEC))))

(DEFUN-IN-FLAVOR (DECODE-CHARACTER-HEIGHT-SPEC SHEET) (SPEC &OPTIONAL WIDTH-ALSO &AUX WID)
  (AND WIDTH-ALSO (STRINGP SPEC)
       (SETQ WID (- (DECODE-CHARACTER-WIDTH-SPEC SPEC) LEFT-MARGIN-SIZE RIGHT-MARGIN-SIZE)))
  (COND ((NUMBERP SPEC)
	 (+ (* SPEC LINE-HEIGHT)
	    TOP-MARGIN-SIZE BOTTOM-MARGIN-SIZE))
	((STRINGP SPEC)
	 (MULTIPLE-VALUE-BIND (IGNORE HT)
	     (SEND SELF ':COMPUTE-MOTION SPEC 0 NIL 0 0 T 0 1000000 1000000 WID)
	   (+ HT TOP-MARGIN-SIZE BOTTOM-MARGIN-SIZE)))
	(T (FERROR "~S illegal as :CHARACTER-HEIGHT; use a number or string" SPEC))))

(DEFUN-IN-FLAVOR (SHEET-DEDUCE-MORE-VPOS SHEET) ()
  (+ TOP-MARGIN-SIZE
     (1+ (* (- (// (SHEET-INSIDE-HEIGHT) LINE-HEIGHT) 2)
	    LINE-HEIGHT))))

(DEFMETHOD (:EDGES SHEET) ()
  (VALUES X-OFFSET Y-OFFSET (+ X-OFFSET WIDTH) (+ Y-OFFSET HEIGHT)))

(DEFMETHOD (:INSIDE-WIDTH SHEET) ()
  (SHEET-INSIDE-WIDTH))

(DEFMETHOD (:INSIDE-HEIGHT SHEET) ()
  (SHEET-INSIDE-HEIGHT))

(DEFMETHOD (:SIZE SHEET) ()
  (VALUES WIDTH HEIGHT))

(DEFMETHOD (:INSIDE-SIZE SHEET) ()
  (VALUES (SHEET-INSIDE-WIDTH) (SHEET-INSIDE-HEIGHT)))

;Note that the :SIZE-IN-CHARACTERS message is part of the stream protocol,
;but is defined on SHEET rather than STREAM-MIXIN because windows that
;don't talk the stream protocol may still be used to display characters.
;STREAM-MIXIN should really be called INPUT-STREAM-MIXIN!
(DEFMETHOD (:SIZE-IN-CHARACTERS SHEET) ()
  (VALUES (// (SHEET-INSIDE-WIDTH) CHAR-WIDTH) (SHEET-NUMBER-OF-INSIDE-LINES)))

(DEFMETHOD (:SET-SIZE-IN-CHARACTERS SHEET) (WIDTH-IN-CHARS HEIGHT-IN-CHARS
							   &OPTIONAL OPTION)
   (SEND SELF ':SET-SIZE
	 (DECODE-CHARACTER-WIDTH-SPEC WIDTH-IN-CHARS)
	 (DECODE-CHARACTER-HEIGHT-SPEC HEIGHT-IN-CHARS)
	 OPTION))

(DEFMETHOD (:VISIBLE-CURSORPOS-LIMITS SHEET) (&OPTIONAL (UNIT :PIXEL))
  (CL:ECASE UNIT
    (:PIXEL
      (VALUES 0 0 (SHEET-INSIDE-WIDTH) (SHEET-INSIDE-HEIGHT)))
    (:CHARACTER
      (VALUES 0 0 (// (SHEET-INSIDE-WIDTH) CHAR-WIDTH) (SHEET-NUMBER-OF-INSIDE-LINES)))))

(DEFMETHOD (:INSIDE-EDGES SHEET) ()
  (VALUES (SHEET-INSIDE-LEFT) (SHEET-INSIDE-TOP) (SHEET-INSIDE-RIGHT)
	  (SHEET-INSIDE-BOTTOM)))

(DEFMETHOD (:POSITION SHEET) ()
  (VALUES X-OFFSET Y-OFFSET))

(DEFMETHOD (:MARGINS SHEET) ()
  (VALUES LEFT-MARGIN-SIZE TOP-MARGIN-SIZE RIGHT-MARGIN-SIZE BOTTOM-MARGIN-SIZE))
 ;;; Screen management issues 
(DEFMETHOD (:NAME-FOR-SELECTION SHEET) () NIL)

(DEFMETHOD (:ORDER-INFERIORS SHEET) (&OPTIONAL WINDOW WHY)
  (WITHOUT-INTERRUPTS
    (SELECTQ WHY
      (:EXPOSE
       ;; Exposing a temporary window doesn't deexpose anything, so just pull it to
       ;; the front without sorting the list (which would take a lot of page faults).
       ;; Even for non-temporary windows, just pull to front.  If anything got deexposed,
       ;; this function will be called again.
       (LET ((X (MEMQ WINDOW INFERIORS)))
	 (WHEN X
	   (LOOP FOR L = INFERIORS THEN (CDR L)
		 DO (SWAPF (CAR L) WINDOW)
		 UNTIL (EQ L X)))))
      (:DEEXPOSE
       ;; Deexposing a window just moves it to where it belongs without paging in
       ;; all the lower-priority deexposed windows.
       (LOOP FOR L = (MEMQ WINDOW INFERIORS) THEN (CDR L) WHILE (CDR L)
	     WHILE (SHEET-PRIORITY-LESSP (CADR L) WINDOW)
	     DO (SETF (CAR L) (CADR L))
	     FINALLY (WHEN L (SETF (CAR L) WINDOW))))
      (:BURY
       ;; :BURY is like :DEEXPOSE but puts it at the end of its priority class
       (LOOP FOR L = (MEMQ WINDOW INFERIORS) THEN (CDR L)
	     WITH AFTER = (LOOP FOR I DOWNFROM (1- (LENGTH INFERIORS))
				WHILE (SHEET-PRIORITY-LESSP WINDOW (NTH I INFERIORS))
				FINALLY (RETURN (NTHCDR I INFERIORS)))
	     DO (IF (EQ L AFTER)
		    (RETURN (SETF (CAR L) WINDOW))
		    (SETF (CAR L) (CADR L)))))
      (OTHERWISE
       ;; Default case requires full sorting, which will page in every active window.
       (SETQ INFERIORS (STABLE-SORT INFERIORS #'SHEET-PRIORITY-LESSP))))))

;Return an alist of all "activities" (selectable windows) at or below this one.
;To find all selectable activities, do (MAPCAN #'SELECTABLE-WINDOWS ALL-THE-SCREENS)
(DEFMETHOD (:SELECTABLE-WINDOWS SHEET) ()
  (SI:ELIMINATE-DUPLICATES
    (NCONC (AND (SEND SELF :NAME-FOR-SELECTION)
		(NCONS (LIST (SEND SELF :NAME-FOR-SELECTION)
			     (SEND SELF :ALIAS-FOR-SELECTED-WINDOWS))))
	   (MAPCAN #'(LAMBDA (I) (SEND I :SELECTABLE-WINDOWS)) INFERIORS))
    #'(LAMBDA (X Y) (EQ (SECOND X) (SECOND Y)))))

(DEFMETHOD (:SET-PRIORITY SHEET) (NEW-PRIORITY)
  (CHECK-ARG NEW-PRIORITY (OR (NUMBERP NEW-PRIORITY) (NULL NEW-PRIORITY)) "a number or NIL")
  (SETQ PRIORITY NEW-PRIORITY)
  (SCREEN-CONFIGURATION-HAS-CHANGED SELF))

(DEFMETHOD (:REFRESH SHEET :BEFORE) (&OPTIONAL IGNORE)
  (SCREEN-MANAGE-FLUSH-KNOWLEDGE SELF))

(DEFUN SHEET-PRIORITY-LESSP (S1 S2 &AUX (EI (SHEET-EXPOSED-INFERIORS (SHEET-SUPERIOR S1)))
					(PRI-S1 (SHEET-PRIORITY S1))
				        (PRI-S2 (SHEET-PRIORITY S2))
					(EX1 (MEMQ S1 EI))
					(EX2 (MEMQ S2 EI)))
  (COND ((AND EX1 (NOT EX2))
	 ;; First exposed, second not -- S1 on top
	 T)
	((AND (NOT EX1) EX2)
	 ;; Second exposed, first not -- S1 underneath
	 NIL)
	((OR (EQ PRI-S1 PRI-S2)
	     (AND EX1 EX2))
	 ;; Both exposed, or equal priority -- S2 remains on bottom
	 NIL)
	((AND (NULL PRI-S1) PRI-S2)
	 ;; S2 has explicit priority, and S1 doesn't -- S1 on bottom
	 NIL)
	((AND PRI-S1 (NULL PRI-S2))
	 ;; S1 has explicit priority, and S2 doesn't -- S1 on top
	 T)
	(T
	 ;; Both have explicit priority -- S2 on bottom if it's priority is less,
	 ;; stable if equal
	 ( PRI-S2 PRI-S1))))

;;; If a screen is going to use this message for something, it must shadow this method
;;; in its flavor combination.  There must be a better way to do this. - Weaver
(DEFMETHOD (:KEEP-MOUSE-VISIBLE SHEET) ()
  (UNLESS (EQ SELF SCREEN)
    (SEND SCREEN ':KEEP-MOUSE-VISIBLE)))

;;;This does it all (somehow)
(DEFUN MAKE-WINDOW (FLAVOR-NAME &REST OPTIONS
		    &KEY (SUPERIOR (CONSOLE-DEFAULT-SUPERIOR))
		    &ALLOW-OTHER-KEYS)
  (SETQ OPTIONS (COPYLIST OPTIONS))		;Allow RPLACD'ing/PUTPROP'ing
  ;; If specified in init plist, use it; else if superior, use its; else, b&w-screen.
  ;; This can't be done in (:init sheet) because :before :init methods need it.
  (UNLESS (MULTIPLE-VALUE-BIND (IGNORE THERE)
	      (SI:MULTIPLE-VALUE-GET (LOCF OPTIONS) :DISPLAY-DEVICE-TYPE)
	    THERE)
    (PUTPROP (LOCF OPTIONS)
	     (IF SUPERIOR (SHEET-DISPLAY-DEVICE-TYPE SUPERIOR) SI:*B&W-SCREEN*)
	     :DISPLAY-DEVICE-TYPE))
  ;; Don't screen manage between :ACTIVATE & :EXPOSE, and don't screen-manage
  ;; while in the initialization methods of the window, which might create
  ;; and expose other windows.
  (DELAYING-SCREEN-MANAGEMENT
    (LET ((WINDOW (LEXPR-FUNCALL #'MAKE-INSTANCE FLAVOR-NAME
						 :SCREEN (SHEET-CALCULATE-SCREEN SUPERIOR)
						 :SUPERIOR SUPERIOR
						 OPTIONS)))
      (WHEN (SHEET-BIT-ARRAY WINDOW)
	(SHEET-FORCE-ACCESS (WINDOW :NO-PREPARE)
	  (SEND WINDOW :REFRESH ':COMPLETE-REDISPLAY)))
      ;; Don't change :ACTIVATE-P into an &KEY argument, OPTIONS might be modified by method
      (WHEN (CL:GETF OPTIONS ':ACTIVATE-P)
	(SEND WINDOW :ACTIVATE))
      ;; Don't change :EXPOSE-P into an &KEY argument, OPTIONS might be modified by method
      (LET ((EXPOSE-P (CL:GETF OPTIONS ':EXPOSE-P)))
	(WHEN EXPOSE-P
	  (LEXPR-SEND WINDOW :EXPOSE (IF (EQ EXPOSE-P T) NIL EXPOSE-P))))
      WINDOW)))

(DEFF WINDOW-CREATE 'MAKE-WINDOW)
(COMPILER:MAKE-OBSOLETE WINDOW-CREATE "it has been renamed to TV:MAKE-WINDOW")

(DEFWHOPPER (:INIT SHEET) (PLIST)
  (LOCK-SHEET (SELF)
    (CONTINUE-WHOPPER PLIST)))

(DEFUN SHEET-ARRAY-TYPE (SHEET)
  (SELECTQ (SCREEN-BITS-PER-PIXEL (SHEET-SCREEN SHEET))
    (1 'ART-1B)
    (2 'ART-2B)
    (4 'ART-4B)
    (8 'ART-8B)
    (16. 'ART-16B)
    ((32. 24.) 'ART-FIXNUM)
    (T 'ART-1B)))

;;; *** The VSP argument can probably go away soon.  Look this over someday and decide.
(DEFUN-IN-FLAVOR (SHEET-DEDUCE-AND-SET-SIZES SHEET) (RIGHT BOTTOM NEW-VSP INTEGRAL-P
						&OPTIONAL CHARACTER-WIDTH CHARACTER-HEIGHT
						&AUX DEFAULTS)
   (SEND SELF :SET-VSP NEW-VSP)
   (SEND SELF :SET-LINE-HEIGHT-FROM-STYLES DEFAULT-STYLE)

   ;; If height and/or width given in terms of characters in font 0, convert to pixels
   (IF (NOT (NULL CHARACTER-WIDTH))
       (SETQ WIDTH (DECODE-CHARACTER-WIDTH-SPEC CHARACTER-WIDTH)))
   (IF (NOT (NULL CHARACTER-HEIGHT))
       (SETQ HEIGHT (DECODE-CHARACTER-HEIGHT-SPEC CHARACTER-HEIGHT)))

   ;; If position and size completely unspecified, look for a default specification
   (AND (NULL WIDTH) (NULL X-OFFSET) (NULL RIGHT)
	(NULL HEIGHT) (NULL Y-OFFSET) (NULL BOTTOM)
	(SETQ DEFAULTS (CDR (ASSQ SUPERIOR *DEFAULT-WINDOW-SIZE-ALIST*)))
	(SETQ DEFAULTS (OR (ASSQ (SI:FLAVOR-NAME (%INSTANCE-FLAVOR SELF)) DEFAULTS)
			   (ASSQ NIL DEFAULTS)))
	(SETQ WIDTH (GET DEFAULTS ':WIDTH)
	      X-OFFSET (GET DEFAULTS ':LEFT)
	      RIGHT (GET DEFAULTS ':RIGHT)
	      HEIGHT (GET DEFAULTS ':HEIGHT)
	      Y-OFFSET (GET DEFAULTS ':TOP)
	      BOTTOM (GET DEFAULTS ':BOTTOM)))

   ;; Need to have X-OFFSET, Y-OFFSET, WIDTH, HEIGHT
   (UNLESS X-OFFSET
     (SETQ X-OFFSET (COND ((AND RIGHT WIDTH) (- RIGHT WIDTH))
			  (SUPERIOR (SHEET-INSIDE-LEFT SUPERIOR))
			  (T 0))))
   (UNLESS Y-OFFSET
     (SETQ Y-OFFSET (COND ((AND BOTTOM HEIGHT) (- BOTTOM HEIGHT))
			  (SUPERIOR (SHEET-INSIDE-TOP SUPERIOR))
			  (T 0))))
   (UNLESS WIDTH
     (SETQ WIDTH (- (COND (RIGHT)
			  (SUPERIOR (SHEET-INSIDE-RIGHT SUPERIOR))
			  (T (FERROR 
 "You must specify the width of a window without a superior.")))
		    X-OFFSET)))
   (UNLESS HEIGHT
     (SETQ HEIGHT (- (COND (BOTTOM)
			   (SUPERIOR (SHEET-INSIDE-BOTTOM SUPERIOR))
			   (T (FERROR 
 "You must specify the height of a window without a superior.")))
		     Y-OFFSET)))

   ;; If negative size was asked for explicitly, give a meaningful message.
   (IF (MINUSP WIDTH)
       (FERROR "A negative width, ~S, was specified for window ~S" WIDTH SELF))
   (IF (MINUSP HEIGHT)
       (FERROR "A negative height, ~S, was specified for window ~S" HEIGHT SELF))

   (AND INTEGRAL-P
	(SETQ BOTTOM-MARGIN-SIZE (- HEIGHT TOP-MARGIN-SIZE
				    (* LINE-HEIGHT (SHEET-NUMBER-OF-INSIDE-LINES)))))

   (SETQ CURSOR-X (SHEET-INSIDE-LEFT))
   (SETQ CURSOR-Y (SHEET-INSIDE-TOP))
   (LET ((REGION (SI:GLOBAL-VALUE CLIPPING-REGION)))
     (UNLESS REGION
       ;; Create the CLIPPING-REGION right next to the SHEET for paging efficiency
       (SETF (SI:GLOBAL-VALUE CLIPPING-REGION)
	     (SETQ REGION (G-L-P (MAKE-ARRAY 4 :TYPE ART-Q-LIST :AREA (%AREA-NUMBER SELF))))))
     (SETF (FIRST REGION) (SHEET-INSIDE-LEFT))
     (SETF (SECOND REGION) (SHEET-INSIDE-TOP))
     (SETF (THIRD REGION) (SHEET-INSIDE-RIGHT))
     (SETF (FOURTH REGION) (SHEET-INSIDE-BOTTOM)))
   SELF)

(DEFMETHOD (:INIT SHEET) (INIT-PLIST &AUX BOTTOM RIGHT SAVE-BITS (MORE-P T)
				          (CHARACTER-WIDTH NIL) (CHARACTER-HEIGHT NIL)
					  (REVERSE-VIDEO-P NIL) (INTEGRAL-P NIL)
					  (BLINKER-P T) (BLINK-FL 'RECTANGULAR-BLINKER)
					  (DESELECTED-VISIBILITY :ON)
					  (BLINKER-ALU) (AUTO-LINE-HEIGHT NIL))
  ;; Process options
  (LOOP FOR (VAL OP) ON (REVERSE (LOCATION-CONTENTS INIT-PLIST)) BY #'CDDR DO
    (SELECTQ OP
	((:LEFT :X) (SETQ X-OFFSET VAL))
	((:TOP :Y) (SETQ Y-OFFSET VAL))
	(:POSITION (SETQ X-OFFSET (FIRST VAL) Y-OFFSET (SECOND VAL)))
	(:RIGHT (SETQ RIGHT VAL))
	(:BOTTOM (SETQ BOTTOM VAL))
	(:SIZE (AND VAL (SETQ WIDTH (FIRST VAL)
			      HEIGHT (SECOND VAL))))
	(:EDGES (AND VAL (SETQ X-OFFSET (FIRST VAL)
			       Y-OFFSET (SECOND VAL)
			       RIGHT (THIRD VAL)
			       BOTTOM (FOURTH VAL))))
	(:CHARACTER-WIDTH (SETQ CHARACTER-WIDTH VAL))
	(:CHARACTER-HEIGHT (SETQ CHARACTER-HEIGHT VAL))
	(:BLINKER-P (SETQ BLINKER-P VAL))
	(:BLINKER-ALU (SETQ BLINKER-ALU VAL))
	(:REVERSE-VIDEO-P (SETQ REVERSE-VIDEO-P VAL))
	(:MORE-P (SETQ MORE-P VAL))
	(:BLINKER-FLAVOR (SETQ BLINK-FL VAL))
	(:BLINKER-DESELECTED-VISIBILITY (SETQ DESELECTED-VISIBILITY VAL))
	(:INTEGRAL-P (SETQ INTEGRAL-P VAL))
	(:SAVE-BITS (SETQ SAVE-BITS VAL))
	(:RIGHT-MARGIN-CHARACTER-FLAG (SETF (SHEET-RIGHT-MARGIN-CHARACTER-FLAG) VAL))
	(:BACKSPACE-NOT-OVERPRINTING-FLAG (SETF (SHEET-BACKSPACE-NOT-OVERPRINTING-FLAG) VAL))
	(:CR-NOT-NEWLINE-FLAG (SETF (SHEET-CR-NOT-NEWLINE-FLAG) VAL))
	(:TRUNCATE-LINE-OUT (SETF (SHEET-TRUNCATE-LINE-OUT-FLAG) (IF VAL 1 0)))
	;; The following is an old moldy version that uses 0 and 1 instead of NIL and T,
	;; for compatibility only.
	(:TRUNCATE-LINE-OUT-FLAG (SETF (SHEET-TRUNCATE-LINE-OUT-FLAG) VAL))
	(:DEEXPOSED-TYPEIN-ACTION (SEND SELF :SET-DEEXPOSED-TYPEIN-ACTION VAL))
	(:TAB-NCHARS (SETF (SHEET-TAB-NCHARS) VAL))
	(:DEFAULT-CHARACTER-STYLE (SETF DEFAULT-STYLE VAL))
	(:TRUNCATE-OUTPUT
	 (SI:COERCE-TO-LIST VAL
	   (DOLIST (X VAL)
	     (CL:ECASE X
	       (:HORIZONTAL (SETF (SHEET-TRUNCATE-OUTPUT-HORIZONTAL-FLAG) 1))
	       (:VERTICAL (SETF (SHEET-TRUNCATE-OUTPUT-VERTICAL-FLAG) 1))))))
	(:AUTO-LINE-HEIGHT
	 (SETQ AUTO-LINE-HEIGHT VAL))
	))
  ;; Probably this was already taken care of by make-window
  (UNLESS (VARIABLE-BOUNDP DISPLAY-DEVICE-TYPE)
    (SETQ DISPLAY-DEVICE-TYPE
	  (IF SUPERIOR
	      (SHEET-DISPLAY-DEVICE-TYPE SUPERIOR)
	      SI:*B&W-SCREEN*)))
  (SHEET-DEDUCE-AND-SET-SIZES RIGHT BOTTOM VSP INTEGRAL-P CHARACTER-WIDTH CHARACTER-HEIGHT)
  (CL:ECASE SAVE-BITS
    ((NIL))
    ((T)
     (SETF (SHEET-SAVE-BITS) 1)
     (SETF (SHEET-FORCE-SAVE-BITS) 1))
    ((:DELAYED)
     (SETF (SHEET-SAVE-BITS) 1)))
  (SETQ MORE-VPOS (AND MORE-P (SHEET-DEDUCE-MORE-VPOS)))
  (WHEN SUPERIOR
    (SETQ OLD-SCREEN-ARRAY
	  (SEND SCREEN :CREATE-SCREEN-ARRAY WIDTH HEIGHT (SHEET-SUPERIOR-SCREEN-ARRAY)))
    (WHEN BLINKER-P
      (LEXPR-FUNCALL #'MAKE-BLINKER SELF BLINK-FL
		     :FOLLOW-P T :DESELECTED-VISIBILITY DESELECTED-VISIBILITY
		     :BLINKER-ALU BLINKER-ALU
		     (AND (LISTP BLINKER-P) BLINKER-P)))
    (SETF TIME-STAMP (SEND SUPERIOR :INFERIOR-TIME-STAMP SELF)))
  (SETF (SHEET-OUTPUT-HOLD-FLAG) 1)
  (LET ((DEF-CHAR ALU-IOR) (DEF-ERASE ALU-ANDCA))
    (WHEN SUPERIOR
      (MULTIPLE-VALUE (DEF-CHAR DEF-ERASE)
	(SEND SUPERIOR :DEFAULT-INFERIOR-ALUFS)))
    (UNLESS (VARIABLE-BOUNDP CHAR-ALUF)
      (SETQ CHAR-ALUF (IF REVERSE-VIDEO-P DEF-ERASE DEF-CHAR)))
    (UNLESS (VARIABLE-BOUNDP ERASE-ALUF)
      (SETQ ERASE-ALUF (IF REVERSE-VIDEO-P DEF-CHAR DEF-ERASE))))
  (SETF (SHEET-REVERSE-VIDEO) (IF REVERSE-VIDEO-P 1 0))
  (WHEN AUTO-LINE-HEIGHT
    ;; This isn't set directly inside the dispatch above so that the deduce-and-set-sizes
    ;; will initialize the line-height variables without attempting an adjustment.
    (SETF (SHEET-AUTO-LINE-HEIGHT-FLAG) 1))
  SELF)

(DEFMETHOD (:ALIAS-FOR-SELECTED-WINDOWS SHEET) ()
  SELF)

(DEFMETHOD (:DEFAULT-INFERIOR-ALUFS SHEET) ()
  (SEND SUPERIOR ':DEFAULT-INFERIOR-ALUFS))

;;;This is the default method, which those who don't want their fonts changed may replace
;;;perhaps by including the NO-CHANGE-OF-DEFAULT-FONT-MIXIN
;;; *** This message should probably be flushed (7/26/85 --DEG)
(DEFMETHOD (:CHANGE-OF-DEFAULT-FONT SHEET) (OLD-FONT NEW-FONT)
  OLD-FONT
  (SEND SELF :SET-DEFAULT-CHARACTER-STYLE
	(SI:BACKTRANSLATE-FONT NEW-FONT DISPLAY-DEVICE-TYPE)))

;;;

(DEFMETHOD (:CHANGE-OF-DEFAULT-FONT NO-CHANGE-OF-DEFAULT-FONT-MIXIN) (OLD-FONT NEW-FONT)
  OLD-FONT NEW-FONT
  NIL)

;;;

(DEFMETHOD (:MORE-P SHEET) ()
  (NOT (NULL MORE-VPOS)))

(DEFMETHOD (:SET-MORE-P SHEET) (MORE-P)
  (SETQ MORE-VPOS (AND MORE-P (SHEET-DEDUCE-MORE-VPOS))))


(COMPILER:MAKE-OBSOLETE SHEET-DEDUCE-VSP "there is now a VSP instance variable.")
(DEFUN-IN-FLAVOR (SHEET-DEDUCE-VSP SHEET) ()
  VSP)


;; The optional arguments do this for a particular character or style.
(DEFUN-IN-FLAVOR (SHEET-ADJUST-BLINKER SHEET) (&OPTIONAL CHARACTER STYLE)
  (LET ((BLINKER (SHEET-FOLLOWING-BLINKER SELF))
	(FONT (COND ((AND CHARACTER
			  (SHEET-GET-CHAR-FONT CHARACTER)))
		    ((AND STYLE
			  (SI:LOOKUP-FONT-CACHED
			    CHARSET&STYLEFONT-CACHE
			    #\M DISPLAY-DEVICE-TYPE STYLE)))
		    (T (SHEET-CURRENT-FONT SELF)))))
    (WHEN BLINKER
      (LET ((BWIDTH
	      (AND CHARACTER
		   (SEND SELF :CHARACTER-WIDTH CHARACTER FONT))))
	(UNLESS (AND BWIDTH
		     (PLUSP BWIDTH))
	  (SETQ BWIDTH (FONT-BLINKER-WIDTH FONT)))
	(BLINKER-SET-SIZE BLINKER
			  BWIDTH
			  (+ (SHEET-BASELINE SELF)
			     (- (FONT-CHAR-HEIGHT FONT) (FONT-BASELINE FONT))))))))

(DEFMETHOD (:ADJUST-BLINKER SHEET) (&OPTIONAL CHARACTER STYLE)
  (SHEET-ADJUST-BLINKER CHARACTER STYLE))

(DEFMETHOD (:FOLLOWING-BLINKER SHEET) ()
  (SHEET-FOLLOWING-BLINKER SELF))

(DEFMETHOD (:SET-VSP SHEET) (NEW-VSP)
  (CHECK-ARG NEW-VSP (AND (FIXNUMP NEW-VSP) ( NEW-VSP 0)) "a non-negative fixnum")
  (SETQ VSP NEW-VSP)
  (WHEN (AND (VARIABLE-BOUNDP MERGED-CURRENT-STYLE) MERGED-CURRENT-STYLE)
    (SEND SELF :SET-LINE-HEIGHT-FROM-STYLES MERGED-CURRENT-STYLE)))

(COMPILER:MAKE-MESSAGE-OBSOLETE :SET-FONT-MAP "Font maps are no longer used.")
(DEFMETHOD (:SET-FONT-MAP SHEET) (IGNORE))

(COMPILER:MAKE-MESSAGE-OBSOLETE :SET-FONT-MAP-AND-VSP "Use character-style functions")
(DEFMETHOD (:SET-FONT-MAP-AND-VSP SHEET) (NEW-MAP NEW-VSP)
  (IGNORE NEW-MAP NEW-VSP))

(COMPILER:MAKE-MESSAGE-OBSOLETE :SET-CURRENT-FONT "Use character-style functions")
(DEFMETHOD (:SET-CURRENT-FONT SHEET) (IGNORE))

(DEFUN-IN-FLAVOR (RECACHE-DEFAULT-FONT SHEET) ()
  (WHEN (VARIABLE-BOUNDP DISPLAY-DEVICE-TYPE) 
    (LET* ((MERGED-STYLE (SI:MERGE-CHARACTER-STYLES CURRENT-STYLE DEFAULT-STYLE))
	   (NEW-CURRENT-FONT
	     (OR (SI:CACHE-LOOKUP CHARSET&STYLEFONT-CACHE
				  #'SI:GET-FONT
				  DISPLAY-DEVICE-TYPE
				  SI:*STANDARD-CHARACTER-SET*
				  MERGED-STYLE NIL)
		 (SI:CACHE-LOOKUP CHARSET&STYLEFONT-CACHE
				  #'SI:GET-FONT
				  DISPLAY-DEVICE-TYPE
				  SI:*STANDARD-CHARACTER-SET*
				  SI:*UNDEFINED-CHARACTER-STYLE*))))
      (SETQ MERGED-CURRENT-STYLE MERGED-STYLE
	    CURRENT-FONT NEW-CURRENT-FONT
	    CHAR-WIDTH (FONT-CHAR-WIDTH CURRENT-FONT))
      (SHEET-ADJUST-BLINKER))))

(DEFMETHOD (:SET-LINE-HEIGHT-FROM-STYLES SHEET) (&REST STYLES)
  (WHEN STYLES
    (WITHOUT-INTERRUPTS
      (LOOP WITH MAX-HEIGHT = -1 AND BIGGEST-FONT
	    FOR UNMERGED-STYLE IN STYLES
	    FOR STYLE = (SI:MERGE-CHARACTER-STYLES UNMERGED-STYLE DEFAULT-STYLE)
	    AS FONT = (SI:CACHE-LOOKUP CHARSET&STYLEFONT-CACHE
				       #'SI:GET-FONT
				       DISPLAY-DEVICE-TYPE
				       SI:*STANDARD-CHARACTER-SET*
				       STYLE)
	    AS FONT-HEIGHT = (FONT-CHAR-HEIGHT FONT)
	    WHEN (> FONT-HEIGHT MAX-HEIGHT)
	      DO (SETQ BIGGEST-FONT FONT
		       MAX-HEIGHT FONT-HEIGHT)
	    FINALLY (SETQ PENDING-NEW-LINE-HEIGHT (+ MAX-HEIGHT VSP)
			  PENDING-NEW-BASELINE (FONT-BASELINE BIGGEST-FONT))
		    (COND ((ZEROP (SHEET-AUTO-LINE-HEIGHT-FLAG))
			   ;; Not allowed to adjust, just change instance variables right here.
			   (SETQ LINE-HEIGHT PENDING-NEW-LINE-HEIGHT
				 BASELINE PENDING-NEW-BASELINE)
			   (SETQ CURRENT-LINE-HEIGHT LINE-HEIGHT
				 CURRENT-BASELINE BASELINE))
			  ((AND (= LINE-HEIGHT PENDING-NEW-LINE-HEIGHT)
				(= BASELINE PENDING-NEW-BASELINE))
			   ;; Already alright, no need to exception, which might mess up
			   ;; some window by happening at an inopportune time.
			   )
			  (T
			   ;; Need to adjust.  Set default and except to adjust current.
			   (SETQ LINE-HEIGHT PENDING-NEW-LINE-HEIGHT
				 BASELINE PENDING-NEW-BASELINE)
			   (SETF (SHEET-LINE-HEIGHT-CHANGE-FLAG) 1))))
      (RECACHE-DEFAULT-FONT))))

;I'd like to, but things are too messed up.
#||
(COMPILER:MAKE-MESSAGE-OBSOLETE :DEFAULT-STYLE "Use :DEFAULT-CHARACTER-STYLE.")
(COMPILER:MAKE-MESSAGE-OBSOLETE :SET-DEFAULT-STYLE "Use :SET-DEFAULT-CHARACTER-STYLE.")
||#

(DEFMETHOD (:DEFAULT-CHARACTER-STYLE SHEET) () (SEND SELF :DEFAULT-STYLE))
(DEFMETHOD (:SET-DEFAULT-CHARACTER-STYLE SHEET) (STYLE) (SEND SELF :SET-DEFAULT-STYLE STYLE))

;;; Attempt to translate to a font.  If it is going to blow out, it is better
;;; done here before we change the instance variable.
(DEFUN VALIDATE-CHARACTER-STYLE-TRANSLATION
       (DISPLAY-DEVICE-TYPE CHARACTER-SET CHARACTER-STYLE)
  (SI:GET-FONT DISPLAY-DEVICE-TYPE CHARACTER-SET CHARACTER-STYLE))

(DEFMETHOD (:SET-DEFAULT-STYLE SHEET) (NEW-DEFAULT-STYLE)
  (SHEET-RESOLVE-TIME-STAMP SELF)
  (SETQ NEW-DEFAULT-STYLE (SI:PARSE-CHARACTER-STYLE NEW-DEFAULT-STYLE))
  (VALIDATE-CHARACTER-STYLE-TRANSLATION
    DISPLAY-DEVICE-TYPE SI:*STANDARD-CHARACTER-SET* NEW-DEFAULT-STYLE)
  (SETQ DEFAULT-STYLE NEW-DEFAULT-STYLE)
  (SEND SELF :SET-LINE-HEIGHT-FROM-STYLES DEFAULT-STYLE)
  (SEND SELF :UPDATE-CURRENT-TIMESTAMP)
  (SHEET-RESOLVE-INFERIOR-TIME-STAMPS SELF))

(DEFMETHOD (:WITH-CHARACTER-STYLE SHEET)
 	   (NEW-STYLE CONTINUATION XSTREAM &OPTIONAL BIND-LINE-HEIGHT)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION))
  ;; Validate that the new current-style will be translatable to a font.
  ;; We must do this OUTSIDE the binding of current-style to the new style.
  ;; Otherwise, when an error finally gets signalled, someone will try to type
  ;; out in NIL.NIL.NIL which will get recursive errors.
  ;; It is unfortunate that we will do this merging and translation several times.
  ;; It seems too hard to do that work here and save it around for
  ;; recache-default-font to pick up later.  Perhaps if someone measures that
  ;; all this takes too long it can be reconsidered.
  (LET ((NEW-CURRENT-STYLE (SI:MERGE-CHARACTER-STYLES NEW-STYLE MERGED-CURRENT-STYLE)))
    (VALIDATE-CHARACTER-STYLE-TRANSLATION
      DISPLAY-DEVICE-TYPE SI:*STANDARD-CHARACTER-SET*
      (SI:MERGE-CHARACTER-STYLES NEW-CURRENT-STYLE DEFAULT-STYLE))
    (UNWIND-PROTECT
	(LETF* ((CURRENT-STYLE NEW-CURRENT-STYLE)
		;; Simply establish a new binding contour, let RECACHE-DEFAULT-FONT
		;; do the work.
		(MERGED-CURRENT-STYLE MERGED-CURRENT-STYLE)
		(CURRENT-FONT CURRENT-FONT)
		(CHAR-WIDTH CHAR-WIDTH))
	  (COND (BIND-LINE-HEIGHT
		 ;; When the user said :BIND-LINE-HEIGHT T, we shouldn't
		 ;; move lines around on him.
		 (SEND SELF :WITH-AUTO-LINE-HEIGHT
		       #'(LAMBDA (IGNORE)
			   (LETF ((LINE-HEIGHT LINE-HEIGHT)
				  (BASELINE BASELINE))
			     (SEND SELF :SET-LINE-HEIGHT-FROM-STYLES
				   ;; We can't use merged-current-style because it isn't set until
				   ;; we call recache-default-font, which is done at the end of
				   ;; :SET-LINE-HEIGHT-FROM-STYLES
				   (SI:MERGE-CHARACTER-STYLES CURRENT-STYLE DEFAULT-STYLE))
			     (FUNCALL CONTINUATION XSTREAM)))
		       SELF NIL))
		(T
		 (RECACHE-DEFAULT-FONT)
		 (FUNCALL CONTINUATION XSTREAM))))
      ;; This has to recompute the font since the default-style may have been changed
      ;; inside the body.
      (RECACHE-DEFAULT-FONT))))

(DEFMETHOD (WITH-MARGIN-OUTPUT-INTERNAL SHEET) (CONTINUATION)
  (DECLARE (DOWNWARD-FUNARG CONTINUATION))
  (LETF ((CURRENT-LINE-HEIGHT LINE-HEIGHT)
	 (LINE-HEIGHT LINE-HEIGHT)
	 (CURRENT-BASELINE BASELINE)
	 (BASELINE BASELINE)
	 (FLAGS FLAGS)
	 (PENDING-NEW-LINE-HEIGHT PENDING-NEW-LINE-HEIGHT)
	 (PENDING-NEW-BASELINE PENDING-NEW-BASELINE))
    (SETF (SHEET-LINE-HEIGHT-CHANGE-FLAG) 0)
    (FUNCALL CONTINUATION)))

(DEFMETHOD (WITH-CURRENT-BASELINE-INTERNAL SHEET) (NEW-CURRENT-BASELINE CONTINUATION)
  (DECLARE (DOWNWARD-FUNARG CONTINUATION))
  (LETF ((CURRENT-BASELINE NEW-CURRENT-BASELINE))
    (FUNCALL CONTINUATION)))

(DEFMETHOD (:WITH-OUTPUT-TRUNCATION SHEET) (CONTINUATION XSTREAM &REST OPTIONS)
  (LET ((OLD-FLAGS (SHEET-TRUNCATE-OUTPUT-FLAG))
	(SET-MORE-P NIL))
    (UNWIND-PROTECT
	(PROGN
	  (LOOP FOR (KEY VAL) ON OPTIONS BY 'CDDR
		DO (CL:ECASE KEY
		     (:HORIZONTAL
		       (SETF (SHEET-TRUNCATE-OUTPUT-HORIZONTAL-FLAG) (IF VAL 1 0)))
		     (:VERTICAL
		       (SETF (SHEET-TRUNCATE-OUTPUT-VERTICAL-FLAG) (IF VAL 1 0))
		       (WHEN VAL
			 (SETQ SET-MORE-P (SEND SELF :MORE-P))
			 (SETF MORE-VPOS NIL)))))
	  (FUNCALL CONTINUATION XSTREAM))
      (WHEN SET-MORE-P
	(SEND SELF :SET-MORE-P T))
      (SETF (SHEET-TRUNCATE-OUTPUT-FLAG) OLD-FLAGS))))

(DEFMETHOD (:WITH-AUTO-LINE-HEIGHT SHEET) (CONTINUATION XSTREAM ENABLED)
  (LET ((OLD-FLAGS (SHEET-AUTO-LINE-HEIGHT-FLAG)))
    (UNWIND-PROTECT
	(PROGN
	  (SETF (SHEET-AUTO-LINE-HEIGHT-FLAG) (IF ENABLED 1 0))
	  (UNLESS ENABLED
	    (SETF (SHEET-LINE-HEIGHT-CHANGE-FLAG) 0))
	  (FUNCALL CONTINUATION XSTREAM))
      (SETF (SHEET-AUTO-LINE-HEIGHT-FLAG) OLD-FLAGS))))

(DEFMETHOD (:AUTO-LINE-HEIGHT SHEET) ()
  (NOT (ZEROP (SHEET-AUTO-LINE-HEIGHT-FLAG))))

(DEFMETHOD (:SET-AUTO-LINE-HEIGHT SHEET) (VALUE)
  (SETF (SHEET-AUTO-LINE-HEIGHT-FLAG) (IF VALUE 1 0)))

(DEFMETHOD (:REVERSE-VIDEO-P SHEET) ()
  (NOT (ZEROP (SHEET-REVERSE-VIDEO))))

(DEFMETHOD (:SET-REVERSE-VIDEO-P SHEET) (REVERSE-VIDEO-P)
  (LET ((OLD (NOT (ZEROP (SHEET-REVERSE-VIDEO)))))
    (UNLESS (EQ REVERSE-VIDEO-P OLD)
      (LOCK-SHEET (SELF)
	(SETF (SHEET-REVERSE-VIDEO) (IF REVERSE-VIDEO-P 1 0))
	(SWAPF CHAR-ALUF ERASE-ALUF)
       (SHEET-FORCE-ACCESS (SELF)
         (SHEET-DRAW-RECTANGLE WIDTH HEIGHT 0 0
			       (SEND SCREEN :EXCHANGE-TWO-COLORS-ALUF CHAR-ALUF ERASE-ALUF)
			       SELF))))))

(DEFMETHOD (:DEEXPOSED-TYPEIN-ACTION SHEET) ()
  (IF (ZEROP (SHEET-DEEXPOSED-TYPEIN-NOTIFY)) ':NORMAL ':NOTIFY))

(DEFMETHOD (:SET-DEEXPOSED-TYPEIN-ACTION SHEET) (VALUE)
  (SETF (SHEET-DEEXPOSED-TYPEIN-NOTIFY)
	(SELECTQ VALUE
	  (:NORMAL 0)
	  (:NOTIFY 1)
	  (OTHERWISE
	   (FERROR NIL "~S illegal deexposed-typein-action; use :NORMAL or :NOTIFY" VALUE)))))

(DEFMETHOD (:SAVE-BITS SHEET) ()
  (COND ((NOT (ZEROP (SHEET-FORCE-SAVE-BITS)))
	 T)
	((NOT (ZEROP (SHEET-SAVE-BITS)))
	 :DELAYED)))

(DEFUN-IN-FLAVOR (FLUSH-BIT-ARRAY SHEET) ()
  (WHEN (NOT (NULL BIT-ARRAY))
    ;; The mouse can't possibly be in any of these windows, so it's alright
    ;; to just go ahead and deexpose them with us locked
    ;; Copy the list before iterating in case deexposing a window causes some side-effect
    ;; on the list other than just deleting that particular window from the list
    (WITHOUT-SCREEN-MANAGEMENT
      (DOLIST (I (COPYLIST EXPOSED-INFERIORS))
	(SEND I :DEEXPOSE NIL :NOOP NIL)))
    (%SCREEN-DEALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF BIT-ARRAY)
    (SETQ BIT-ARRAY NIL)
    (SETQ OLD-SCREEN-ARRAY SCREEN-ARRAY
	  SCREEN-ARRAY NIL)
    (WHEN (EQ SCREEN (SHEET-SCREEN SUPERIOR))
      (SEND SELF :ADJUST-SCREEN-ARRAY OLD-SCREEN-ARRAY (SHEET-SUPERIOR-SCREEN-ARRAY)))
    (SETF (SHEET-OUTPUT-HOLD-FLAG) 1))
  NIL)


(DEFUN-IN-FLAVOR (FORCE-CREATE-BIT-SAVE-ARRAY SHEET) ()
  (WHEN (AND (NULL SCREEN-ARRAY)
	     (MEMQ SCREEN TV:ALL-THE-SCREENS))
    (LOOP FOR THIS-SHEET FIRST SELF THEN NEXT-SHEET
	  FOR NEXT-SHEET = (TV:SHEET-SUPERIOR THIS-SHEET)
	  DO
      (WHEN (NULL NEXT-SHEET)
	(RETURN NIL))
      (WHEN (NOT (ZEROP (SHEET-FORCE-SAVE-BITS THIS-SHEET)))
	(SEND THIS-SHEET :SET-SAVE-BITS T)
	(WHEN (NOT (NULL (SHEET-SCREEN-ARRAY THIS-SHEET)))
	  (RETURN T)))
      (WHEN (NOT (MEMQ THIS-SHEET (SHEET-EXPOSED-INFERIORS NEXT-SHEET)))
	(RETURN NIL)))))

(DEFMETHOD (SHEET-FLUSH-SCREEN-RESOURCES SHEET) ()
  (LOCK-SHEET (SELF)
    (FLUSH-BIT-ARRAY)))

(DEFMETHOD (SHEET-CLEAR-LOCKS-AND-RESOURCES SHEET) ()
  (SETF LOCK NIL)
  (SETF LOCK-COUNT 0)
  (SETF INFERIOR-LOCK-COUNT 0)
  (SETF TEMPORARY-WINDOWS-LOCKED NIL)
  (SETF INVISIBLE-TO-MOUSE-P NIL)
  (SETF (SHEET-OFF-SCREEN-DRAWING-FLAG) 0)
  (FLUSH-BIT-ARRAY)
  (RESET-DYNAMIC-STATE SELF)
  (SEND-IF-HANDLES SELF :SHUTDOWN-ACTIVITY)
  NIL)

(DEFMETHOD (:SET-SAVE-BITS SHEET) (SAVE-BITS)
  (UNLESS SUPERIOR
    (FERROR "Cannot :SET-SAVE-BITS on a top-level sheet."))
  (LOCK-SHEET (SELF)
    (CL:ECASE SAVE-BITS
      ((T)
       (SETF (SHEET-SAVE-BITS) 1)
       (SETF (SHEET-FORCE-SAVE-BITS) 1)
       (WHEN (AND (NULL BIT-ARRAY)
		  (NULL SCREEN-ARRAY)
		  (NOT EXPOSED-P)
		  (MEMQ SCREEN TV:ALL-THE-SCREENS))
	 (SETF BIT-ARRAY
	       (%SCREEN-ALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF WIDTH HEIGHT))
	 (WHEN (NOT (NULL BIT-ARRAY))
	   (CL:SHIFTF SCREEN-ARRAY OLD-SCREEN-ARRAY NIL)
	   (SEND SELF :ADJUST-SCREEN-ARRAY SCREEN-ARRAY BIT-ARRAY 0 0 0 0)
	   ;; We are not exposed, first refresh ourself
	   (WITHOUT-SCREEN-MANAGEMENT		;-DDyer
	     (SHEET-FORCE-ACCESS (SELF :NO-PREPARE) (SEND SELF :REFRESH  :COMPLETE-REDISPLAY))
	     ;; Expose in reverse order for the sake of temporary windows
	     (DOLIST (I (REVERSE EXPOSED-INFERIORS))
	       ;; Then actually expose all of our virtually exposed inferiors.
	       ;; Note that we already own the lock on all of them, and the mouse
	       ;; can't be in them since we are deexposed.
	       (SEND I :EXPOSE))))))
      ((:DELAYED)
       (SETF (SHEET-SAVE-BITS) 1)
       (SETF (SHEET-FORCE-SAVE-BITS) 0)
       (FLUSH-BIT-ARRAY))
      ((NIL)
       (SETF (SHEET-SAVE-BITS) 0)
       (SETF (SHEET-FORCE-SAVE-BITS) 0)
       (FLUSH-BIT-ARRAY))))
  SAVE-BITS)

(DEFMETHOD (:SET-SAVE-BITS SHEET :AFTER) (IGNORE)
  (SCREEN-MANAGE-WINDOW-AREA SELF))

(DEFMETHOD (SHEET-FORCE-ACCESS-1 SHEET) (CONTINUATION &KEY PREPARE-SHEET)
  ;; If the user asked for a bit-save array here, give it to him or else.
  (FORCE-CREATE-BIT-SAVE-ARRAY)
  (LOCK-SHEET (SELF)
    (WHEN (NOT (NULL SCREEN-ARRAY))
      ;; Sheet can't have temporary lock here as we own lock, so SHEET-OUTPUT-HELD-P not
      ;; required for proper operation
      (LET ((OLD-OUTPUT-HOLD-FLAG (SHEET-OUTPUT-HOLD-FLAG)))
	(UNWIND-PROTECT
	    (PROGN
	      (SETF (SHEET-OUTPUT-HOLD-FLAG) 0)
	      (IF PREPARE-SHEET
		  (PREPARE-SHEET (SELF)
		    (FUNCALL CONTINUATION))
		  (FUNCALL CONTINUATION)))
	  (SETF (SHEET-OUTPUT-HOLD-FLAG) OLD-OUTPUT-HOLD-FLAG))))))

(DEFUN-IN-FLAVOR (ERASE-MARGINS SHEET) ()
  (COND (SCREEN-ARRAY
	 (PREPARE-SHEET (SELF)
	   (SHEET-DRAW-RECTANGLE LEFT-MARGIN-SIZE HEIGHT
				 0 0 ERASE-ALUF SELF)
	   (SHEET-DRAW-RECTANGLE RIGHT-MARGIN-SIZE HEIGHT
				 (SHEET-INSIDE-RIGHT) 0 ERASE-ALUF SELF)
	   (SHEET-DRAW-RECTANGLE WIDTH TOP-MARGIN-SIZE
				 0 0 ERASE-ALUF SELF)
	   (SHEET-DRAW-RECTANGLE WIDTH BOTTOM-MARGIN-SIZE
				 0 (SHEET-INSIDE-BOTTOM) ERASE-ALUF SELF)))))

(DEFMETHOD (:CHANGE-OF-SIZE-OR-MARGINS SHEET)
	   (&REST OPTIONS
		  &AUX TOP BOTTOM LEFT RIGHT NEW-HEIGHT NEW-WIDTH OLD-X OLD-Y (INTEGRAL-P NIL))
  "Change some sheet parameters"
  (WHEN (AND SUPERIOR
	     (NEQ SCREEN (SHEET-SCREEN SUPERIOR)))
    (SEND SELF :SET-SUPERIOR SUPERIOR))
  (TV:SHEET-RESOLVE-TIME-STAMP SELF)		;This is safe, believe it or not.
  (LET ((OLD-INSIDE-WIDTH (SHEET-INSIDE-WIDTH))
	(OLD-INSIDE-HEIGHT (SHEET-INSIDE-HEIGHT))
	(OLD-TOP-MARGIN-SIZE TOP-MARGIN-SIZE)
	(OLD-LEFT-MARGIN-SIZE LEFT-MARGIN-SIZE)
	;;Don't try to save bits while things are inconsistent.
	(OLD-FORCE-SAVE-BITS (SHEET-FORCE-SAVE-BITS)))
    (UNWIND-PROTECT
	(PROGN
	  (SETF (SHEET-FORCE-SAVE-BITS) 0)
	  (SHEET-FORCE-ACCESS (SELF)
	    (ERASE-MARGINS))
	  (SETQ OLD-X CURSOR-X
		OLD-Y CURSOR-Y)
	  ;; Process options
	  (DOPLIST (OPTIONS VAL OP)
	    (SELECTQ OP
	      ((:TOP :Y) (SETQ TOP VAL))
	      (:BOTTOM (SETQ BOTTOM VAL))
	      ((:LEFT :X) (SETQ LEFT VAL))
	      (:RIGHT (SETQ RIGHT VAL))
	      (:WIDTH (SETQ NEW-WIDTH VAL))
	      (:HEIGHT (SETQ NEW-HEIGHT VAL))
	      (:TOP-MARGIN-SIZE (SETQ TOP-MARGIN-SIZE VAL))
	      (:BOTTOM-MARGIN-SIZE (SETQ BOTTOM-MARGIN-SIZE VAL))
	      (:LEFT-MARGIN-SIZE (SETQ LEFT-MARGIN-SIZE VAL))
	      (:RIGHT-MARGIN-SIZE (SETQ RIGHT-MARGIN-SIZE VAL))
	      (:INTEGRAL-P (SETQ INTEGRAL-P VAL))
	      (OTHERWISE (FERROR NIL "~S is not a recognized option" OP))))
	  (SETQ X-OFFSET (OR LEFT (IF RIGHT (- RIGHT (OR NEW-WIDTH WIDTH)) X-OFFSET)))
	  (SETQ Y-OFFSET (OR TOP (IF BOTTOM (- BOTTOM (OR NEW-HEIGHT HEIGHT)) Y-OFFSET)))
	  (SETQ NEW-WIDTH (OR NEW-WIDTH (IF RIGHT (- RIGHT LEFT) WIDTH)))
	  (SETQ NEW-HEIGHT (OR NEW-HEIGHT (IF BOTTOM (- BOTTOM TOP) HEIGHT)))
	  (SETQ WIDTH NEW-WIDTH HEIGHT NEW-HEIGHT)
  
	  ;; We need to deexpose all of our inferiors that won't fit anymore
	  ;; Copy the list before iterating in case deexposing a window causes some side-effect
	  ;; on the list other than just deleting that particular window from the list
	  (DOLIST (I (COPYLIST EXPOSED-INFERIORS))
	    (UNLESS (SHEET-WITHIN-P I (SHEET-INSIDE-LEFT) (SHEET-INSIDE-TOP)
				    (SHEET-INSIDE-RIGHT) (SHEET-INSIDE-BOTTOM))
	      (SEND I :DEEXPOSE)))
  
	  (LOCK-SHEET (SELF)
	    (SHEET-FORCE-ACCESS (SELF T)
	      (WITH-SCREEN-CONTROLLER-LOCK (SCREEN)
		(MAPC #'OPEN-BLINKER BLINKER-LIST)))
	    (SHEET-DEDUCE-AND-SET-SIZES RIGHT BOTTOM VSP INTEGRAL-P)
	    ;; Slide the cursorpos by the change in margin size and then clip.
	    (SETQ CURSOR-X
		  (MAX LEFT-MARGIN-SIZE (MIN (+ OLD-X (- LEFT-MARGIN-SIZE OLD-LEFT-MARGIN-SIZE))
					     (- WIDTH RIGHT-MARGIN-SIZE CHAR-WIDTH))))
	    (SETQ CURSOR-Y
		  (MAX TOP-MARGIN-SIZE (MIN (+ OLD-Y (- TOP-MARGIN-SIZE OLD-TOP-MARGIN-SIZE))
					    (- HEIGHT BOTTOM-MARGIN-SIZE LINE-HEIGHT))))
	    (DOLIST (BL BLINKER-LIST)
	      (COND ((NULL (BLINKER-X-POS BL)))
		    (( (BLINKER-X-POS BL) (SHEET-INSIDE-RIGHT))
		     (SETF (BLINKER-X-POS BL) (SHEET-INSIDE-LEFT))))
	      (COND ((NULL (BLINKER-Y-POS BL)))
		    (( (BLINKER-Y-POS BL) (SHEET-INSIDE-BOTTOM))
		     (SETF (BLINKER-Y-POS BL) (SHEET-INSIDE-TOP)))))
	    (WHEN SUPERIOR
	      ;;If we have a bit-array, SCREEN-ARRAY indirects to it, else OLD-SCREEN-ARRAY 
	      ;; indirects into our superior.
	      (COND (BIT-ARRAY
		     (LET ((NEW-BIT-ARRAY (%SCREEN-ALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF WIDTH HEIGHT)))
		       (COND (NEW-BIT-ARRAY
			      (SHEET-FORCE-ACCESS (SELF)
				(SHEET-DRAW-RECTANGLE WIDTH HEIGHT 0 0 ERASE-ALUF SELF NEW-BIT-ARRAY)				(SHEET-BITBLT
				  ALU-SETA (MIN (SHEET-INSIDE-WIDTH) OLD-INSIDE-WIDTH)
					   (MIN (SHEET-INSIDE-HEIGHT) OLD-INSIDE-HEIGHT)
				  BIT-ARRAY OLD-LEFT-MARGIN-SIZE OLD-TOP-MARGIN-SIZE
				  NEW-BIT-ARRAY LEFT-MARGIN-SIZE TOP-MARGIN-SIZE
				  SELF))
			      (%SCREEN-DEALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF BIT-ARRAY)
			      (SETF BIT-ARRAY NEW-BIT-ARRAY)
			      (SEND SELF :ADJUST-SCREEN-ARRAY SCREEN-ARRAY BIT-ARRAY 0 0 0 0))
			     (T
			      (FLUSH-BIT-ARRAY)))))
		    (SCREEN-ARRAY
		     (SEND SELF :ADJUST-SCREEN-ARRAY SCREEN-ARRAY (SHEET-SUPERIOR-SCREEN-ARRAY))
		     ;; If the size of the top and/or left margin changed, move the inside bits around
		     (LET ((DELTA-TOP-MARGIN (- TOP-MARGIN-SIZE OLD-TOP-MARGIN-SIZE))
			   (DELTA-LEFT-MARGIN (- LEFT-MARGIN-SIZE OLD-LEFT-MARGIN-SIZE)))
		       (UNLESS (AND (ZEROP DELTA-TOP-MARGIN) (ZEROP DELTA-LEFT-MARGIN))
			 ;; This should be BITBLT-WITH-FAST-PAGING, sometimes it is not paged in
			 (SHEET-FORCE-ACCESS (SELF)
			   (SHEET-BITBLT
			     ALU-SETA
			     (IF (PLUSP DELTA-LEFT-MARGIN)
				 (- (SHEET-INSIDE-WIDTH))
				 (SHEET-INSIDE-WIDTH))
			     (IF (PLUSP DELTA-TOP-MARGIN)
				 (- (SHEET-INSIDE-HEIGHT))
				 (SHEET-INSIDE-HEIGHT))
			     NIL OLD-LEFT-MARGIN-SIZE OLD-TOP-MARGIN-SIZE
			     NIL LEFT-MARGIN-SIZE TOP-MARGIN-SIZE
			     SELF)
			   ;; If margins got smaller, may be space to clear out on bottom and right
			   (WHEN (MINUSP DELTA-LEFT-MARGIN)
			     (SHEET-DRAW-RECTANGLE
			       (- DELTA-LEFT-MARGIN) (SHEET-INSIDE-HEIGHT)
			       (+ (SHEET-INSIDE-RIGHT) DELTA-LEFT-MARGIN) (SHEET-INSIDE-TOP)
			       ERASE-ALUF SELF))
			   (WHEN (MINUSP DELTA-TOP-MARGIN)
			     (SHEET-DRAW-RECTANGLE
			       (SHEET-INSIDE-WIDTH) (- DELTA-TOP-MARGIN)
			       (SHEET-INSIDE-LEFT) (+ (SHEET-INSIDE-BOTTOM) DELTA-TOP-MARGIN)
			       ERASE-ALUF SELF))))))
		    (T
		     (SEND SELF :ADJUST-SCREEN-ARRAY OLD-SCREEN-ARRAY (SHEET-SUPERIOR-SCREEN-ARRAY))))
	      (WHEN (AND TEMPORARY-BIT-ARRAY (NEQ TEMPORARY-BIT-ARRAY T))
		(%SCREEN-DEALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF TEMPORARY-BIT-ARRAY)
		(SETQ TEMPORARY-BIT-ARRAY T))
	      (SHEET-FORCE-ACCESS (SELF)
		(ERASE-MARGINS)))))
      (SETF (SHEET-FORCE-SAVE-BITS) OLD-FORCE-SAVE-BITS))
    (OR ( OLD-INSIDE-WIDTH (SHEET-INSIDE-WIDTH))
	( OLD-INSIDE-HEIGHT (SHEET-INSIDE-HEIGHT)))))


;;
;; called when the superior has changed and that entails a change of screens too
;;
;; this is a method so it can be whop'ed by mixins which add bit arrays or otherwise
;; depend on the screen
(DEFMETHOD (:CHANGE-OF-SCREEN SHEET) (CHANGE-OF-DISPLAY-ATTRIBUTES)
  (LET ((NEW-SCREEN (SHEET-SCREEN SUPERIOR)))
    (WHEN (NOT (EQ SCREEN NEW-SCREEN))
      (SHEET-FLUSH-SCREEN-RESOURCES SELF)
      (SETF SCREEN NEW-SCREEN)))
  (SETQ OLD-SCREEN-ARRAY
	(SEND SCREEN :CREATE-SCREEN-ARRAY WIDTH HEIGHT (SHEET-SUPERIOR-SCREEN-ARRAY)))
  (SETF SCREEN-ARRAY NIL)
  (DOLIST (INFERIOR INFERIORS)
    ;;pass the news to the kids
    (SEND INFERIOR :CHANGE-OF-SCREEN CHANGE-OF-DISPLAY-ATTRIBUTES)))

(defun RASTER-WIDTH-FOR-BITBLT (width array-type)
1  ;type is a fixnum, the number of bits per pixel
  ;  or an array to be imitated
  ;  or a symbol, which is a zetalisp raster array type or a common-lisp raster array type
0  (let* ((bits-per-pixel 
	   (cond ((fixp array-type) array-type)
		 ((arrayp array-type) (array-element-byte-size array-type))
		 ((and (symbolp array-type)
		       (cdr (assq array-type array-bits-per-element))))
		 ((let ((lispm-type
			  (car (or (if (symbolp array-type)
				       (cl:rassoc array-type cli::*array-element-types*
						  :test #'eql)
				       (cl:rassoc array-type cli::*array-element-types*
						  :test #'equal))
				   (cl:rassoc array-type cli::*array-element-types*
					      :test #'cl:subtypep)))))
		    (when lispm-type
		      (cdr (assq lispm-type array-bits-per-element)))))
		 (t (ferror "~A doesn't specify a raster array type" array-type))))
	 (round-to (// 32. bits-per-pixel)))
    (* (ceiling width round-to) round-to)))

(defun RASTER-ARRAY-TYPE-FOR-BITS (BITS-PER-PIXEL)
  (cond ((eql bits-per-pixel 1) 'art-1b)
	((eql bits-per-pixel 2) 'art-2b)
	(( bits-per-pixel 0) nil)
	(( bits-per-pixel 4) 'art-4b)
	(( bits-per-pixel 8) 'art-8b)
	(( bits-per-pixel 16.) 'art-16b)
	(( bits-per-pixel 32.) 'art-fixnum)))

(DEFUN MAKE-SHEET-BIT-ARRAY (SHEET WIDTH HEIGHT &REST MAKE-ARRAY-OPTIONS)
  (LET ((ARRAY-TYPE (SHEET-ARRAY-TYPE SHEET)))
    (LEXPR-FUNCALL #'MAKE-RASTER-ARRAY
		   (RASTER-WIDTH-FOR-BITBLT WIDTH ARRAY-TYPE)
		   HEIGHT
		   ':TYPE ARRAY-TYPE
		   ':INITIAL-VALUE (OR (GET (LOCF MAKE-ARRAY-OPTIONS) ':INITIAL-VALUE)
				       0)
		   ':AREA (OR (GET (LOCF MAKE-ARRAY-OPTIONS) ':AREA)
			      *DEFAULT-BIT-ARRAY-AREA*)
		   MAKE-ARRAY-OPTIONS)))


(DEFUN GROW-BIT-ARRAY (RASTER WIDTH HEIGHT REAL-WIDTH OREAL-WIDTH OHEIGHT
		       &OPTIONAL (OLD-BITS-GOOD T) (ERASE-ALUF ALU-ANDCA))
  (OR REAL-WIDTH (SETQ REAL-WIDTH WIDTH))
  (MULTIPLE-VALUE-BIND (AWIDTH AHEIGHT)
      (DECODE-RASTER-ARRAY RASTER)
    (LET* ((TYPE (ARRAY-TYPE RASTER))
	   (WWIDTH (RASTER-WIDTH-FOR-BITBLT WIDTH RASTER)))
      (COND ((AND (= OREAL-WIDTH REAL-WIDTH) (= OHEIGHT HEIGHT))
	     ;; Not changing anything, so don't need to do any work.
	     RASTER)
	    ((OR (> WWIDTH AWIDTH) (> HEIGHT AHEIGHT))
	     ;; Asking for more than is in the array, so must make a larger array
	     (LET ((NRASTER (MAKE-RASTER-ARRAY
			      WWIDTH HEIGHT :TYPE TYPE
			      :AREA (%AREA-NUMBER RASTER)
			      :INITIAL-VALUE (IF (EQL ERASE-ALUF ALU-IOR) -1 0))))
	       (AND OLD-BITS-GOOD
		    (BITBLT ALU-SETA (MIN REAL-WIDTH AWIDTH) (MIN HEIGHT AHEIGHT)
			    RASTER 0 0 NRASTER 0 0))
	       (STRUCTURE-FORWARD RASTER NRASTER)
	       ;; Done with this one for good!
	       (SI:PAGE-OUT-RASTER-ARRAY RASTER)
	       NRASTER))
	    (OLD-BITS-GOOD
	     ;; New size fits in old array.  If making the array bigger, clear out unused area
	     (WHEN (> REAL-WIDTH OREAL-WIDTH)
	       (%DRAW-RECTANGLE-INTERNAL (- WIDTH OREAL-WIDTH) HEIGHT OREAL-WIDTH 0 ERASE-ALUF RASTER))
	     (WHEN (> HEIGHT OHEIGHT)
	       (%DRAW-RECTANGLE-INTERNAL REAL-WIDTH (- HEIGHT OHEIGHT) 0 OHEIGHT ERASE-ALUF RASTER))
	     RASTER)
	    (T RASTER)))))

(DEFUN SET-DEFAULT-WINDOW-SIZE (FLAVOR-NAME SUPERIOR EXISTING-WINDOWS &REST OPTIONS
				&AUX ELEM DEFAULTS)
  "Set the default size and//or position for windows of unspecified size and position
of a particular flavor, created under a particular superior.
NIL for the flavor sets a default for all windows.
EXISTING-WINDOWS, if T, means to force the options on already-existing windows."
  ;; Make sure that only options understood by SHEET-DEDUCE-AND-SET-SIZES are used
  (LOOP FOR OPTION IN OPTIONS BY 'CDDR DO
	(OR (MEMQ OPTION '(:WIDTH :LEFT :RIGHT :HEIGHT :TOP :BOTTOM))
	    (FSIGNAL "~S is not a recognized option keyword" OPTION)))
  (OR (SETQ ELEM (ASSQ SUPERIOR *DEFAULT-WINDOW-SIZE-ALIST*))
      (PUSH (SETQ ELEM (NCONS SUPERIOR)) *DEFAULT-WINDOW-SIZE-ALIST*))
  (OR (SETQ DEFAULTS (ASSQ FLAVOR-NAME (CDR ELEM)))
      (PUSH (SETQ DEFAULTS (NCONS FLAVOR-NAME)) (CDR ELEM)))
  (RPLACD DEFAULTS (COPYLIST OPTIONS))
  ;; Mung existing active windows if so desired
  (WHEN EXISTING-WINDOWS
    (LET* ((LEFT-SPEC (GET (LOCF OPTIONS) ':LEFT))
	   (RIGHT-SPEC (GET (LOCF OPTIONS) ':RIGHT))
	   (TOP-SPEC (GET (LOCF OPTIONS) ':TOP))
	   (BOTTOM-SPEC (GET (LOCF OPTIONS) ':BOTTOM))
	   (WIDTH-SPEC (OR (GET (LOCF OPTIONS) ':WIDTH)
			  (AND LEFT-SPEC RIGHT-SPEC (- RIGHT-SPEC LEFT-SPEC))))
	   (HEIGHT-SPEC (OR (GET (LOCF OPTIONS) ':HEIGHT)
			    (AND TOP-SPEC BOTTOM-SPEC (- BOTTOM-SPEC TOP-SPEC)))))
      (DOLIST (W (SHEET-INFERIORS SUPERIOR))
	(WHEN (OR (NULL FLAVOR-NAME) (EQ (TYPEP W) FLAVOR-NAME))
	  (MULTIPLE-VALUE-BIND (WIDTH HEIGHT) (SEND W ':SIZE)
	    (MULTIPLE-VALUE-BIND (LEFT TOP) (SEND W ':POSITION)
	      (AND WIDTH-SPEC (SETQ WIDTH WIDTH-SPEC))
	      (AND HEIGHT-SPEC (SETQ HEIGHT HEIGHT-SPEC))
	      (AND RIGHT-SPEC (SETQ LEFT (- RIGHT-SPEC WIDTH)))
	      (AND LEFT-SPEC (SETQ LEFT LEFT-SPEC))
	      (AND BOTTOM-SPEC (SETQ TOP (- BOTTOM-SPEC HEIGHT)))
	      (AND TOP-SPEC (SETQ TOP TOP-SPEC))
	      (AND (SEND W ':SET-EDGES LEFT TOP (+ LEFT WIDTH) (+ TOP HEIGHT) ':VERIFY)
		   (SEND W ':SET-EDGES LEFT TOP (+ LEFT WIDTH) (+ TOP HEIGHT))))))))))

(DEFUN-IN-FLAVOR (SHEET-SET-DEEXPOSED-POSITION SHEET) (NEW-X NEW-Y)
  "Called to set the position of a deexposed sheet.  Sheet must be locked.  Can be called
on deexposed screens."
  (WHEN EXPOSED-P
    (FERROR NIL "Wrong function called to set position of exposed sheet ~A" SELF))
  ;;SCREEN-ARRAY will be adjusted when we next get exposed
  (SETQ X-OFFSET NEW-X
	Y-OFFSET NEW-Y))

(DEFUN-IN-FLAVOR (SHEET-SET-EXPOSED-POSITION SHEET) (NEW-X NEW-Y &AUX OX OY)
  "Called to set the position of an exposed sheet.  Sheet must be locked.  The bits"
  (PREPARE-SHEET (SELF)
    (SETQ OX X-OFFSET
	  OY Y-OFFSET
	  X-OFFSET NEW-X
	  Y-OFFSET NEW-Y)

    ;; open blinkers appropriate for our new position
    (SHEET-OPEN-ALL-CONFLICTING-BLINKERS SELF)

    (LET ((SUP-ARRAY (SHEET-SUPERIOR-SCREEN-ARRAY)))
      (SEND SELF ':ADJUST-SCREEN-ARRAY SCREEN-ARRAY SUP-ARRAY 0 0 NEW-X NEW-Y)
      (SHEET-IS-PREPARED (SUPERIOR)
	(SHEET-BITBLT ALU-SETA
		      (IF (> OX NEW-X) WIDTH (- WIDTH)) (IF (> OY NEW-Y) HEIGHT (- HEIGHT))
		      SUP-ARRAY OX OY SUP-ARRAY NEW-X NEW-Y
		      SUPERIOR)))
    (SETF (MOUSE-RECONSIDER (SHEET-MOUSE SELF)) T)))

(DEFMETHOD (:SET-SUPERIOR SHEET) (NEW-SUPERIOR)
  (UNLESS (AND (EQ NEW-SUPERIOR SUPERIOR)
	       (EQ (SHEET-SCREEN NEW-SUPERIOR) SCREEN))
    (DELAYING-SCREEN-MANAGEMENT
      (LET ((STATUS (SEND SELF :STATUS))
	    (NEW-SCREEN (SHEET-SCREEN NEW-SUPERIOR))
	    (OLD-SCREEN SCREEN))
	(SEND SELF :DEACTIVATE)
	(SETQ SUPERIOR NEW-SUPERIOR)
	(WHEN (NOT (EQ NEW-SCREEN OLD-SCREEN))
	  (SEND SELF :CHANGE-OF-SCREEN
		(OR ( (SEND OLD-SCREEN :BITS-PER-PIXEL) (SEND NEW-SCREEN :BITS-PER-PIXEL))
		    (NEQ (SEND OLD-SCREEN :DISPLAY-DEVICE-TYPE)
			 (SEND NEW-SCREEN :DISPLAY-DEVICE-TYPE)))))
	(WHEN (AND (VARIABLE-BOUNDP OLD-SCREEN-ARRAY) OLD-SCREEN-ARRAY)
	  ;;note, we don't have to fool with BIT-ARRAY because it isn't
	  ;;changing size, and we won't have a SCREEN-ARRAY because we
	  ;;are deactivated.
	  (SEND SELF :ADJUST-SCREEN-ARRAY OLD-SCREEN-ARRAY
		(SHEET-SUPERIOR-SCREEN-ARRAY)))
	(LOOP FOR INFERIOR IN INFERIORS
	      DO (SEND INFERIOR :SET-SUPERIOR SELF))
	(SEND SELF :SET-STATUS STATUS)))))


(DEFUN SET-WINDOW-ON-USABLE-SCREEN (WIN &OPTIONAL (TO-SCREEN DEFAULT-SCREEN) NOTIFY
				    &key (FORCE-MOVE NIL))
  (LET ((TO-SCREEN (OR TO-SCREEN DEFAULT-SCREEN)))
    (WHEN TO-SCREEN
      (LET* ((SET-WIN (LOOP AS WIN = WIN THEN SUP
			    AS SUP = (SHEET-SUPERIOR WIN)
			    WHILE (AND SUP (SHEET-SUPERIOR SUP))
			    DO ()
			    FINALLY (RETURN WIN)))
	     (OLD-SCR (SHEET-SCREEN SET-WIN)))
	(COND ((SHEET-EXPOSED-P TO-SCREEN))
	      ((SHEET-EXPOSED-P DEFAULT-SCREEN)
	       (SETQ TO-SCREEN DEFAULT-SCREEN))
	      (T (SETQ TO-SCREEN MAIN-SCREEN)))
	(WHEN (OR FORCE-MOVE (NOT (SEND OLD-SCR :APPROPRIATE-HARDWARE-P)))
	  (SELECTQ *AUTOMATICALLY-CHANGE-SCREENS*
	    (:NOTIFY
	     (WHEN NOTIFY
	       (NOTIFY () "Changing the screen of ~S from ~A to ~A" WIN OLD-SCR TO-SCREEN)))
	    (:DEBUG
	     (LET ((DEBUG-IO COLD-LOAD-STREAM))
	       (CL:BREAK "Changing the screen of ~S from ~A to ~A" WIN OLD-SCR TO-SCREEN)))
	    (NIL
	     (WHEN NOTIFY
	       (RETURN-FROM SET-WINDOW-ON-USABLE-SCREEN NIL))))
	  (MULTIPLE-VALUE-BIND (ML MT MR MB)
	      (SEND SET-WIN :EDGES)
	    (SEND SET-WIN :SET-SUPERIOR TO-SCREEN)
	    (MULTIPLE-VALUE-BIND (OL OT OR OB)
		(SEND OLD-SCR :INSIDE-EDGES)
	      (MULTIPLE-VALUE-BIND (NL NT NR NB)
		  (SEND TO-SCREEN :INSIDE-EDGES)
		(LET ((NEW-LEFT (MAX NL (+ NL (ROUND (* (- NR NL) (- ML OL)) (- OR OL)))))
		      (NEW-TOP (MAX NT (+ NT (ROUND (* (- NB NT) (- MT OT)) (- OB OT)))))
		      (NEW-RIGHT (MIN NR (+ NL (ROUND (* (- NR NL) (- MR OL)) (- OR OL)))))
		      (NEW-BOTTOM (MIN NB (+ NT (ROUND (* (- NB NT) (- MB OT)) (- OB OT))))))
1						;for short windows, try to preserve the height.  This is reasonable
						;because small windows are a small number of lines rather than bits
						;high.  Also reasonable because sometimes fixed-height-mixin insists.

0		  (WHEN (OR ( (* 3 (- NEW-BOTTOM NEW-TOP)) (- NB NT))	1;less than 1/3 screen
0			    (SEND SET-WIN :VERIFY-NEW-EDGES1            
						;or just rejected for somereason
0				  NEW-LEFT NEW-TOP NEW-RIGHT NEW-BOTTOM))
		    (SETQ NEW-TOP (MAX NT (- NEW-BOTTOM (- MB MT)))
			  NEW-BOTTOM (MIN NB (+ NEW-TOP (- MB MT)))))
		
		  ;; SET-DEFAULT-WINDOW-SIZE can override those proportional edges
		  ;; but only if SET-WIN currently conforms to it
		  (LET ((OPTIONS (ASSQ TO-SCREEN *DEFAULT-WINDOW-SIZE-ALIST*))
			(OLD-OPTIONS (ASSQ OLD-SCR *DEFAULT-WINDOW-SIZE-ALIST*)))
		    (AND OPTIONS
			 (SETQ OPTIONS (ASSQ (TYPEP SET-WIN) (CDR OPTIONS)))
			 (SETQ OLD-OPTIONS (ASSQ (TYPEP SET-WIN) (CDR OLD-OPTIONS)))
			 (LET* ((LEFT-SPEC (GET OPTIONS :LEFT))
				(RIGHT-SPEC (GET OPTIONS :RIGHT))
				(TOP-SPEC (GET OPTIONS :TOP))
				(BOTTOM-SPEC (GET OPTIONS :BOTTOM))
				(WIDTH-SPEC (OR (GET OPTIONS :WIDTH)
						(AND LEFT-SPEC RIGHT-SPEC
						     (- RIGHT-SPEC LEFT-SPEC))))
				(HEIGHT-SPEC (OR (GET OPTIONS :HEIGHT)
						 (AND TOP-SPEC BOTTOM-SPEC
						      (- BOTTOM-SPEC TOP-SPEC))))
				(OLD-LEFT-SPEC (GET OLD-OPTIONS :LEFT))
				(OLD-RIGHT-SPEC (GET OLD-OPTIONS :RIGHT))
				(OLD-TOP-SPEC (GET OLD-OPTIONS :TOP))
				(OLD-BOTTOM-SPEC (GET OLD-OPTIONS :BOTTOM))
				(OLD-WIDTH-SPEC (OR (GET OLD-OPTIONS :WIDTH)
						    (AND OLD-LEFT-SPEC OLD-RIGHT-SPEC
							 (- OLD-RIGHT-SPEC OLD-LEFT-SPEC))))
				(OLD-HEIGHT-SPEC (OR (GET OLD-OPTIONS :HEIGHT)
						     (AND OLD-TOP-SPEC OLD-BOTTOM-SPEC
							  (- OLD-BOTTOM-SPEC OLD-TOP-SPEC)))))
			   (WHEN (EQL MR OLD-RIGHT-SPEC)
			     (SETQ NEW-LEFT (- (IF (= MR (SHEET-INSIDE-RIGHT OLD-SCR))
						   (SHEET-INSIDE-RIGHT TO-SCREEN) RIGHT-SPEC)
					       (IF (EQL (- MR ML) OLD-WIDTH-SPEC)
						   WIDTH-SPEC (- MR ML)))))
			   (WHEN (EQL ML OLD-LEFT-SPEC)
			     (SETQ NEW-LEFT LEFT-SPEC))
			   (WHEN (EQL MB OLD-BOTTOM-SPEC)
			     (SETQ NEW-TOP (- (IF (= MB (SHEET-INSIDE-BOTTOM OLD-SCR))
						  (SHEET-INSIDE-BOTTOM TO-SCREEN) BOTTOM-SPEC)
					      (IF (EQL (- MB MT) OLD-HEIGHT-SPEC)
						  HEIGHT-SPEC (- MB MT )))))
			   (WHEN (EQL MT OLD-TOP-SPEC)
			     (SETQ NEW-TOP TOP-SPEC))
			   (WHEN (EQL (- MR ML) OLD-WIDTH-SPEC)
			     (SETQ NEW-RIGHT (+ NEW-LEFT WIDTH-SPEC)))
			   (WHEN (EQL (- MB MT) OLD-HEIGHT-SPEC)
			     (SETQ NEW-BOTTOM (+ NEW-TOP HEIGHT-SPEC))))))

		  (SEND SET-WIN :SET-EDGES NEW-LEFT NEW-TOP NEW-RIGHT NEW-BOTTOM)
		  )))))))))

(DEFMETHOD (RESET-DYNAMIC-STATE SHEET) ()
  ;; May have been inside a with-character-style.
  (UNLESS (AND (VARIABLE-BOUNDP CURRENT-STYLE) (EQ CURRENT-STYLE SI:*NULL-STYLE*))
    (SETQ CURRENT-STYLE SI:*NULL-STYLE*)
    (RECACHE-DEFAULT-FONT))
  ;; May have been inside a with-clipping-region.
  (WHEN CLIPPING-REGION
    (WHEN (SI:IN-STACK-OR-TEMPORARY-AREA CLIPPING-REGION)
      (SETQ CLIPPING-REGION (G-L-P (MAKE-ARRAY 4 :TYPE ART-Q-LIST :AREA (%AREA-NUMBER SELF)))))
    (SETF (FIRST CLIPPING-REGION) (SHEET-INSIDE-LEFT))
    (SETF (SECOND CLIPPING-REGION) (SHEET-INSIDE-TOP))
    (SETF (THIRD CLIPPING-REGION) (SHEET-INSIDE-RIGHT))
    (SETF (FOURTH CLIPPING-REGION) (SHEET-INSIDE-BOTTOM))))

;;; Sheet exposure/deexposure

;;; Normal sheets ignore notification about exposure/deexposure/change-of-edges
;;; (Sheets themselves never send these messages, but it is possible that
;;; sheets be superiors of things which do (the case of screens is an example))
(DEFMETHOD (:INFERIOR-EXPOSE SHEET) (SHEET) SHEET)
(DEFMETHOD (:INFERIOR-DEEXPOSE SHEET) (SHEET) SHEET)
(DEFMETHOD (:INFERIOR-SET-EDGES SHEET) (SHEET &REST IGNORE) SHEET)
(DEFMETHOD (:INFERIOR-BURY SHEET) (SHEET) SHEET)

;;; Always send :INFERIOR-SELECT upwards through all levels of window hierarchy,
;;; since nested windows always must be in the same "activity" currently.
;;; Programs that don't work that way can shadow this method.
(DEFMETHOD (:INFERIOR-SELECT SHEET) (SHEET)
  (WHEN SUPERIOR
    (SEND SUPERIOR :INFERIOR-SELECT SHEET))
  SHEET)

(DEFVAR *SHEETS-MADE-INVISIBLE-TO-MOUSE*)

(DEFMACRO-IN-FLAVOR (WITH-MOUSE-SAFELY-OUT-OF-THE-WAY SHEET) (&BODY BODY)
  `(UNWIND-PROTECT
       (PROGN
	 ;; Always make ourselves invisible to the mouse
	 (SETF (SHEET-INVISIBLE-TO-MOUSE-P SELF) T)
	 (WITH-MOUSE-SAFELY-OUT-OF-THE-WAY-1)
	 (DELAYING-SCREEN-MANAGEMENT
	   (LOCK-SHEET (SELF)
	     ;; This lets sheets with OUTPUT-HOLD on be deexposed.
	     (WHEN EXPOSED-P
	       (SETF (SHEET-OUTPUT-HOLD-FLAG SELF) 0))
	     ,@BODY)))
     (SETF (SHEET-INVISIBLE-TO-MOUSE-P SELF) NIL)))

(DEFUN-IN-FLAVOR (WITH-MOUSE-SAFELY-OUT-OF-THE-WAY-1 SHEET) ()
  (LET ((MOUSE (SHEET-MOUSE SELF)))
    (WHEN MOUSE
      (LET ((MS (MOUSE-SHEET MOUSE)))
	(WHEN (SHEET-ME-OR-MY-KID-P MS SELF)
	  ;; The mouse is currently on me or one of my inferiors, get it out of there
	  (COND (SUPERIOR
		 (MOUSE-SET-SHEET SUPERIOR))
		((AND DEFAULT-SCREEN
		      (NOT (EQ SELF DEFAULT-SCREEN))
		      (EQ MOUSE (SHEET-MOUSE DEFAULT-SCREEN)))
		 (MOUSE-SET-SHEET DEFAULT-SCREEN))
		(T
		 (FERROR NIL
  "Attempt to deexpose sheet ~S, which is top level sheet that owns mouse"
			 SELF))))
	(WHEN (LET ((MW (MOUSE-WINDOW MOUSE)))
		(AND (TYPEP MW 'SHEET) (SHEET-ME-OR-MY-KID-P MW SELF)))
	  ;; Me or my inferior is the current mouse sheet, so force it out
	  (SETF (MOUSE-RECONSIDER MOUSE) T)
	  (WAIT-FOR-MOUSE SELF MOUSE NIL))))))

(DEFUN-IN-FLAVOR (SHEET-PREPARE-FOR-EXPOSE SHEET) (SHEET INSIDE-EXPOSE-METHOD
						    TURN-ON-BLINKERS BITS-ACTION X Y)
  TURN-ON-BLINKERS
  (PROG ABORT ((OLD-INHIBIT-SCHEDULING-FLAG INHIBIT-SCHEDULING-FLAG)
	       (INHIBIT-SCHEDULING-FLAG T) RESULT)
     MAIN-LOOP
	(SETQ INHIBIT-SCHEDULING-FLAG T)
	(COND ((NOT (SHEET-CAN-GET-LOCK SHEET))
	       (SETQ INHIBIT-SCHEDULING-FLAG NIL)
	       (WAIT-FOR-SHEET-LOCK SHEET)
	       (GO MAIN-LOOP)))
	(WHEN (IF SUPERIOR
		  (MEMQ SELF (SHEET-EXPOSED-INFERIORS SUPERIOR))
		  EXPOSED-P)
	  (RETURN-FROM ABORT (VALUES T BITS-ACTION NIL)))
	(OR (NOT INSIDE-EXPOSE-METHOD)
	    (NULL SUPERIOR)
	    (MEMQ SELF (SHEET-INFERIORS SUPERIOR))
	    ;; We can only be exposed if we are activated
	    (RETURN-FROM ABORT
	      (VALUES NIL BITS-ACTION (LIST NIL "Attempt to expose deactivated sheet ~S" SELF))))
	(COND ((OR ( X-OFFSET X) ( Y-OFFSET Y))
	       (AND INSIDE-EXPOSE-METHOD (RETURN-FROM ABORT (VALUES NIL BITS-ACTION NIL)))
	       (SETQ INHIBIT-SCHEDULING-FLAG NIL)
	       (SHEET-SET-DEEXPOSED-POSITION X Y)
	       (GO MAIN-LOOP)))
	(OR (NULL SUPERIOR)
	    (NOT INSIDE-EXPOSE-METHOD)
	    (SHEET-WITHIN-SHEET-P SELF SUPERIOR)
	    (RETURN-FROM ABORT
	      (VALUES NIL BITS-ACTION
		      (LIST NIL "Attempt to expose ~S outside of its superior.~&  Inferior's outside edges ~s;  Superior's inside edges ~s"
			    SELF
			    (LIST X-OFFSET Y-OFFSET
				  (+ X-OFFSET WIDTH) (+ Y-OFFSET HEIGHT))
			    (LET ((LEFT (SHEET-INSIDE-LEFT SUPERIOR))
				  (TOP (SHEET-INSIDE-TOP SUPERIOR)))
			      (LIST LEFT TOP
				    (+ LEFT (SHEET-INSIDE-WIDTH SUPERIOR))
				    (+ TOP (SHEET-INSIDE-HEIGHT SUPERIOR))))))))
	;; If our superior is temp locked, see if we will overlap any
	;; of the temp windows.  If we will, then wait until the temp window is
	;; deexposed then try again
	(COND ((AND SUPERIOR
		    (LISTP (SHEET-LOCK SUPERIOR))
		    (SETQ RESULT
			  (DOLIST (TEMP-SHEET (SHEET-LOCK SUPERIOR))
			    (AND (SHEET-OVERLAPS-SHEET-P TEMP-SHEET SELF)
				 (RETURN TEMP-SHEET)))))
	       (AND INSIDE-EXPOSE-METHOD (RETURN-FROM ABORT (VALUES NIL BITS-ACTION NIL)))
	       (SETQ INHIBIT-SCHEDULING-FLAG NIL)
	       (PROCESS-WAIT "Sheet Deexpose"
			     #'(LAMBDA (TEMP-SHEET SUP)				 
				 (OR (NLISTP (SHEET-LOCK SUP))
				     (NOT (MEMQ TEMP-SHEET (SHEET-LOCK SUP)))))
			     RESULT SUPERIOR)
	       (GO MAIN-LOOP)))
	(COND ((SHEET-TEMPORARY-P)
	       (SETQ RESULT
		     (CATCH 'SHEET-EXPOSE-CANT-GET-LOCK
		       (LET ((*REQUESTOR* SELF))
			 (DECLARE (SPECIAL *REQUESTOR*))
			 ;; Check to make sure we can get all the locks at once
			 (MAP-OVER-EXPOSED-SHEET
			   #'(LAMBDA (TARGET)
			       (AND ;; Can't be us, we aren't exposed yet
				 (NEQ TARGET (SHEET-SUPERIOR *REQUESTOR*))
				 ;; Sheet may be on EXPOSED-INFERIORS, but not
				 ;; in actuality exposed
				 (SHEET-EXPOSED-P TARGET)
				 (SHEET-OVERLAPS-SHEET-P *REQUESTOR* TARGET)
				 (OR (SHEET-CAN-GET-TEMPORARY-LOCK TARGET *REQUESTOR*)
				     (THROW 'SHEET-EXPOSE-CANT-GET-LOCK TARGET))
				 ;; If this window owns the mouse, must force
				 ;; mouse out of it
				 (SHEET-IS-MOUSE-WINDOW-P TARGET)
				 (THROW 'SHEET-EXPOSE-CANT-GET-LOCK TARGET)))
			   SUPERIOR)
			 ;; We can, get them all and win totally, but only do this if
			 ;; we are inside the expose method proper
			 (AND INSIDE-EXPOSE-METHOD
			      (LET ((*REQUESTOR* SELF))
				(DECLARE (SPECIAL *REQUESTOR*))
				(MAP-OVER-EXPOSED-SHEET
				  #'(LAMBDA (TARGET)
				      (COND ((AND ;; Can't be us, we aren't exposed yet
					       (NEQ TARGET (SHEET-SUPERIOR *REQUESTOR*))
					       ;; Sheet may be on EXPOSED-INFERIORS, but not
					       ;; in actuality exposed
					       (SHEET-EXPOSED-P TARGET)
					       (SHEET-OVERLAPS-SHEET-P *REQUESTOR* TARGET))
					     ;; All blinkers must get turned off on this sheet
					     (WITH-SCREEN-CONTROLLER-LOCK (SCREEN)
					       (SHEET-OPEN-BLINKERS TARGET))
					     (SHEET-GET-TEMPORARY-LOCK TARGET *REQUESTOR*)
					     (PUSH TARGET TEMPORARY-WINDOWS-LOCKED))))
				  SUPERIOR)))
			 ;; Return NIL indicating that we are winning
			 NIL)))
	       (COND ((NULL RESULT))		;done
		     (INSIDE-EXPOSE-METHOD (RETURN-FROM ABORT (VALUES NIL BITS-ACTION NIL)))
		     ((SHEET-IS-MOUSE-WINDOW-P RESULT)
		      (SETF (MOUSE-RECONSIDER (SHEET-MOUSE RESULT)) T)
		      (PUSH RESULT *SHEETS-MADE-INVISIBLE-TO-MOUSE*)
		      (SETF (SHEET-INVISIBLE-TO-MOUSE-P RESULT) T)
		      (SETQ INHIBIT-SCHEDULING-FLAG NIL)
		      (WAIT-FOR-MOUSE RESULT NIL T)
		      (GO MAIN-LOOP))
		     (T
		      ;; One we couldn't get: wait for it
		      (SETQ INHIBIT-SCHEDULING-FLAG NIL)
		      (PROCESS-WAIT "Temp Lock"
				    #'(LAMBDA (TARGET SHEET)
					(OR (NOT (SHEET-EXPOSED-P TARGET))
					    (NOT (SHEET-OVERLAPS-SHEET-P SHEET TARGET))
					    (SHEET-CAN-GET-TEMPORARY-LOCK TARGET SHEET)))
				    RESULT SELF)
		      (GO MAIN-LOOP))))
	      (SUPERIOR
	       ;; Deexpose one window we will overlap, then loop again as the world may have
	       ;; changed out from under us.  Can't even deexpose all the windows we will
	       ;; overlap before trying again, as the SHEET-EXPOSED-INFERIORS list can be
	       ;; destructively modified.
	       (DOLIST (SIBLING (SHEET-EXPOSED-INFERIORS SUPERIOR))
		 (COND ((SHEET-OVERLAPS-SHEET-P SELF SIBLING)
			(WHEN INSIDE-EXPOSE-METHOD
			  (RETURN-FROM ABORT (VALUES NIL BITS-ACTION NIL)))
			(SETQ INHIBIT-SCHEDULING-FLAG OLD-INHIBIT-SCHEDULING-FLAG)
			(SEND SIBLING :DEEXPOSE)
			(GO MAIN-LOOP)
			)))))
	;; We have successfully met all of the requirements, be successful
 	(RETURN (VALUES T BITS-ACTION))))

(DEFWHOPPER (:EXPOSE SHEET) (&REST ARGS
			     &AUX (*SHEETS-MADE-INVISIBLE-TO-MOUSE* NIL))
  (WHEN (AND (NOT EXPOSED-P)
	     (EQ SUPERIOR SCREEN))
    (SET-WINDOW-ON-USABLE-SCREEN SELF DEFAULT-SCREEN T))
  (DELAYING-SCREEN-MANAGEMENT
    (UNWIND-PROTECT
	(LOOP DOING
	  (DESTRUCTURING-BIND (&OPTIONAL TURN-ON-BLINKERS BITS-ACTION
					 (X X-OFFSET) (Y Y-OFFSET)) ARGS
	    (SHEET-PREPARE-FOR-EXPOSE SELF NIL TURN-ON-BLINKERS BITS-ACTION X Y))
	  (LET ((ERROR (CATCH 'SHEET-ABORT-EXPOSE
			 (LOCK-SHEET (SELF)
			   (RETURN (LEXPR-CONTINUE-WHOPPER ARGS))))))
	    (WHEN ERROR (APPLY #'FERROR ERROR))))
	;; Cleanup handler
	(DOLIST (SHEET *SHEETS-MADE-INVISIBLE-TO-MOUSE*)
	  (SETF (SHEET-INVISIBLE-TO-MOUSE-P SHEET) NIL))
	(MOUSE-WAKEUP (SHEET-MOUSE SELF)))))

(DEFMETHOD (:DEFAULT-EXPOSE-BITS-ACTION SHEET) () (IF BIT-ARRAY ':RESTORE ':CLEAN))

;;; TURN-ON-BLINKERS means that this window will soon become the SELECTED-WINDOW,
;;; so it is not necessary to change blinkers from :BLINK to their
;;; DESELECTED-BLINKER-VISIBILITY.

(DEFMETHOD (:EXPOSE SHEET) (&OPTIONAL TURN-ON-BLINKERS BITS-ACTION (X X-OFFSET) (Y Y-OFFSET)
			    &AUX (OLD-INHIBIT-SCHEDULING-FLAG INHIBIT-SCHEDULING-FLAG)
				 (INHIBIT-SCHEDULING-FLAG T) SUPERIOR-HAS-SCREEN-ARRAY
			         OK ERROR)
  "Expose a sheet (place it on the physical screen)"
  (PROG ()
	(SETQ RESTORED-BITS-P T)
	(OR BITS-ACTION (SETQ BITS-ACTION (SEND SELF :DEFAULT-EXPOSE-BITS-ACTION)))
	(AND EXPOSED-P (RETURN NIL))
	(SETQ RESTORED-BITS-P NIL)
	(MULTIPLE-VALUE (OK BITS-ACTION ERROR)
	  (SHEET-PREPARE-FOR-EXPOSE SELF T TURN-ON-BLINKERS BITS-ACTION X Y))
	(SETQ SUPERIOR-HAS-SCREEN-ARRAY (OR (NULL SUPERIOR) (SHEET-SCREEN-ARRAY SUPERIOR)))
	(OR OK (THROW 'SHEET-ABORT-EXPOSE ERROR))
	;; Have made our area of the screen safe for us.  We'll now call ourselves
	;; "exposed", even though we haven't put our bits on the screen at all.  This
	;; will win, because we have ourself locked, and if someone wants to cover us
	;; he'll have to go blocked until we are done -- it's a cretinous thing to have
	;; happen, but the system shouldn't come crashing to the ground because of it.
	;; *** INHIBIT-SCHEDULING-FLAG had better still be T ***
	(OR INHIBIT-SCHEDULING-FLAG
	    (FERROR NIL "Hairy part of expose finished with INHIBIT-SCHEDULING-FLAG off"))
	;; Lie by saying that we are exposed, because we aren't really, but we are
	;; locked so it doesn't matter
	(AND SUPERIOR-HAS-SCREEN-ARRAY (SETQ EXPOSED-P T))
	(AND SUPERIOR
	     (OR (NOT (MEMQ SELF (SHEET-EXPOSED-INFERIORS SUPERIOR)))
		 ;; Must always reorder in the case of temporary windows since they
		 ;; are the only type of window that can be exposed and overlapping some
		 ;; other exposed window
		 (SHEET-TEMPORARY-P))
	     (SHEET-CONSING
	       (SETF (SHEET-EXPOSED-INFERIORS SUPERIOR)
		     (CONS SELF (COPYLIST (DELQ SELF (SHEET-EXPOSED-INFERIORS SUPERIOR)))))))
	(WHEN SUPERIOR-HAS-SCREEN-ARRAY
	  ;; If really exposed now, then we must clear the cache of which sheet was
	  ;; prepared last, since changing our exposure status can affect preparedness
	  ;; in non-trivially-computable ways.
	  (SETF PREPARED-SHEET NIL)
	  (COND (BIT-ARRAY
		 (SETF (SHEET-OUTPUT-HOLD-FLAG) 0)
		 ;; We're gonna change where our bits go, so we must turn off blinkers,
		 ;; because they won't be on in the new place.  This holds for all of
		 ;; our exposed inferiors too.  Don't mark us as prepared, because
		 ;; our superior might not be.  These blinkers cannot get turned back
		 ;; on again, because this sheet is locked.
		 (WITH-SCREEN-CONTROLLER-LOCK (SCREEN)
		   (OPEN-INFERIOR-BLINKERS SELF))
		 ;; Fix the screen-array and locations-per-line of me and all my exp infs
		 (SEND SELF :ADJUST-SCREEN-ARRAY SCREEN-ARRAY
						  (IF SUPERIOR (SHEET-SUPERIOR-SCREEN-ARRAY)
							       (SCREEN-BUFFER SELF))))
		(T
		 ;; Fix my screen-array and locations-per-line, which might have become
		 ;; obsolete if my superior was moved while I was deexposed.  Don't
		 ;; update my exposed-inferiors; they will get done by a :EXPOSE below.
		 (SEND SELF :ADJUST-SCREEN-ARRAY OLD-SCREEN-ARRAY
						  (IF SUPERIOR (SHEET-SUPERIOR-SCREEN-ARRAY)
							       (SCREEN-BUFFER SELF)))
		 (SETQ SCREEN-ARRAY OLD-SCREEN-ARRAY)
		 (SETF (SHEET-OUTPUT-HOLD-FLAG) 0)))
	;; Now, update setting of SHEET-ALL-EXPOSED flag.  Copy value from our
	;; superior into our exposed inferiors (to all levels).  If we are top-level, then
	;; always set the flag.  However, if we don't have a bit array, then this will be
	;; done by the exposes later on, so no need to worry about it.
	(LET ((NEW-FLAG-VAL (IF SUPERIOR (SHEET-ALL-EXPOSED SUPERIOR) 1)))
	  (SETF (SHEET-ALL-EXPOSED SELF) NEW-FLAG-VAL)
	  (WHEN BIT-ARRAY
	    (SHEET-SET-ALL-EXPOSED-FLAGS EXPOSED-INFERIORS NEW-FLAG-VAL)))

	  (WHEN (SHEET-TEMPORARY-P)
	    (WHEN (AND (NOT (EQ TEMPORARY-BIT-ARRAY T))
		       (NULL (VERIFY-DRAWABLE SCREEN TEMPORARY-BIT-ARRAY SELF :WRITE)))
	      (%SCREEN-DEALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF TEMPORARY-BIT-ARRAY)
	      (SETF TEMPORARY-BIT-ARRAY T))
	    (WHEN (EQ TEMPORARY-BIT-ARRAY T)
	      (SETQ TEMPORARY-BIT-ARRAY
		    (OR (%SCREEN-ALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF WIDTH HEIGHT) T)))
	    (UNLESS (EQ TEMPORARY-BIT-ARRAY T)
	      (%SCREEN-PAGE-IN-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF TEMPORARY-BIT-ARRAY :WRITE)
	      (WITH-SCREEN-CONTROLLER-LOCK (SCREEN)
		(SHEET-IS-PREPARED (SELF)
		  ;; For temporary windows, we must open the blinkers of our
		  ;; superiors to all levels
		  (SHEET-OPEN-ALL-BLINKERS SUPERIOR)
		  (SHEET-BITBLT ALU-SETA WIDTH HEIGHT NIL 0 0 TEMPORARY-BIT-ARRAY 0 0)))
	      (%SCREEN-PAGE-OUT-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF TEMPORARY-BIT-ARRAY))))
	(DOLIST (SHEET *SHEETS-MADE-INVISIBLE-TO-MOUSE*)
	  (SETF (SHEET-INVISIBLE-TO-MOUSE-P SHEET) NIL))
	(SETQ *SHEETS-MADE-INVISIBLE-TO-MOUSE* NIL)
	(LET ((MOUSE (SHEET-MOUSE SELF)))
	  (MOUSE-DISCARD-CLICKAHEAD MOUSE)
	  (MOUSE-WAKEUP MOUSE))

	;; This goes after preceeding code so that blinkers won't accidentally
	;; turn on before the bits get BITBLT'ed into the temporary array
	(SETQ INHIBIT-SCHEDULING-FLAG OLD-INHIBIT-SCHEDULING-FLAG)
	(WHEN SUPERIOR-HAS-SCREEN-ARRAY
	  (WHEN (NOT TURN-ON-BLINKERS)
	    (DESELECT-SHEET-BLINKERS SELF))
	  (CL:ECASE BITS-ACTION
	    ((:NOOP) NIL)
	    ((:RESTORE)
	     (SEND SELF :REFRESH :USE-OLD-BITS))
	    ((:CLEAN)
	     (SEND SELF :HOME-CURSOR)
	     (SEND SELF :REFRESH :COMPLETE-REDISPLAY)))
	  (COND ((NULL BIT-ARRAY)
		 ;; Expose in opposite order for the sake of temporary windows
		 (DOLIST (INFERIOR (REVERSE EXPOSED-INFERIORS))
		   (SEND INFERIOR :EXPOSE NIL)))
		(T
		 (%SCREEN-DEALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF BIT-ARRAY)
		 (SETQ BIT-ARRAY NIL)))
	  (RETURN T))))

(DEFUN SHEET-SET-ALL-EXPOSED-FLAGS (SHEET-LIST VAL)
  (DOLIST (S SHEET-LIST)
    (SETF (SHEET-ALL-EXPOSED S) VAL)
    (SHEET-SET-ALL-EXPOSED-FLAGS (SHEET-EXPOSED-INFERIORS S) VAL)))

(DEFWHOPPER (:DEEXPOSE SHEET) (&REST ARGS)
  (WITH-MOUSE-SAFELY-OUT-OF-THE-WAY
    (LEXPR-CONTINUE-WHOPPER ARGS)))

(DEFMETHOD (:DEEXPOSE SHEET)  (&OPTIONAL (SAVE-BITS-P :DEFAULT) SCREEN-BITS-ACTION
					 (REMOVE-FROM-SUPERIOR T))
  "Deexpose a sheet (removing it virtually from the physical screen, some bits may remain)"
  (LET ((SW (SHEET-SELECTED-WINDOW SELF)))
    (WHEN (AND SW (SHEET-ME-OR-MY-KID-P SW SELF))
      (SEND SW :DESELECT NIL)))
  (WHEN EXPOSED-P
    (SHEET-OPEN-BLINKERS SELF)
    (WHEN (SELECTQ SAVE-BITS-P
	    ((:FORCE) T)
	    ((NIL) NIL)
	    (OTHERWISE (AND (NOT (ZEROP (SHEET-SAVE-BITS)))
			    (OR (NOT (ZEROP (SHEET-FORCE-SAVE-BITS)))
				(SCREEN-PERMITS-BIT-SAVE-ARRAYS SCREEN)))))
      (SETF BIT-ARRAY (%SCREEN-ALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF WIDTH HEIGHT)))
    (COND (BIT-ARRAY
	   (SETF OLD-SCREEN-ARRAY NIL)
	   (%SCREEN-PAGE-IN-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF BIT-ARRAY :WRITE)
	   (PREPARE-SHEET (SELF)
	     (SHEET-BITBLT ALU-SETA WIDTH HEIGHT NIL 0 0 BIT-ARRAY 0 0))
	   (WHEN *SHEET-ENABLE-EXPLICIT-PAGE-OUT*
	     (%SCREEN-PAGE-OUT-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF BIT-ARRAY)))
	  (T
	   ;; Copy the list before iterating in case deexposing a window causes some
	   ;; side-effect on the list other than just deleting that particular window
	   (DOLIST (INFERIOR (COPYLIST EXPOSED-INFERIORS))
	     (SEND INFERIOR :DEEXPOSE SAVE-BITS-P :NOOP NIL))))
    (LET ((CLEAN-ALUF (IF SUPERIOR (SHEET-ERASE-ALUF SUPERIOR) ERASE-ALUF)))
      (COND ((SHEET-TEMPORARY-P)
	     (COND ((AND (NOT (EQ TEMPORARY-BIT-ARRAY T))
			 (VERIFY-DRAWABLE SCREEN TEMPORARY-BIT-ARRAY SELF :READ))
		    (%SCREEN-PAGE-IN-SHEET-TEMPORARY-BIT-ARRAY
		      SCREEN SELF TEMPORARY-BIT-ARRAY :READ)
		    (PREPARE-SHEET (SELF)
		      (SHEET-BITBLT ALU-SETA WIDTH HEIGHT TEMPORARY-BIT-ARRAY 0 0 NIL 0 0))
		    (%SCREEN-PAGE-OUT-SHEET-TEMPORARY-BIT-ARRAY
		      SCREEN SELF TEMPORARY-BIT-ARRAY))
		   (T
		    ;; TEMPORARY-BIT-ARRAY lost by host, just erase the bits
		    (PREPARE-SHEET (SELF)
		      (SHEET-DRAW-RECTANGLE WIDTH HEIGHT 0 0 CLEAN-ALUF))))
	     ;; deallocate the temporary array, back into the pool
	     (UNLESS (EQ TEMPORARY-BIT-ARRAY T)
	       (%SCREEN-DEALLOCATE-SHEET-TEMPORARY-BIT-ARRAY
		 SCREEN SELF TEMPORARY-BIT-ARRAY)
	       (SETF TEMPORARY-BIT-ARRAY T))
	     (DOLIST (SHEET TEMPORARY-WINDOWS-LOCKED)
	       (SHEET-RELEASE-TEMPORARY-LOCK SHEET SELF))
	     (SETQ TEMPORARY-WINDOWS-LOCKED NIL)
	     ;; Locked sheets had their output-held-p cleared without sending
	     ;; :EXPOSE message, mouse sees them now.
	     (MOUSE-WAKEUP (SHEET-MOUSE SELF)))
	    (T
	     (CL:ECASE SCREEN-BITS-ACTION
	       ((:NOOP NIL))
	       ((:CLEAN)
		(PREPARE-SHEET (SELF)
		  (SHEET-DRAW-RECTANGLE WIDTH HEIGHT 0 0 CLEAN-ALUF)))))))
    (SETQ EXPOSED-P NIL)
    (SETF (SHEET-ALL-EXPOSED) 0)
    (COND (BIT-ARRAY
	   ;; If didn't deexpose inferiors, then let them know their screen-array
	   ;; isn't on the screen any more.
	   (SHEET-SET-ALL-EXPOSED-FLAGS EXPOSED-INFERIORS 0)
	   (SEND SELF :ADJUST-SCREEN-ARRAY SCREEN-ARRAY BIT-ARRAY 0 0 0 0))
	  (T
	   (SETQ OLD-SCREEN-ARRAY SCREEN-ARRAY SCREEN-ARRAY NIL)))
    (SETF (SHEET-OUTPUT-HOLD-FLAG) 1))
  (WHEN (EQ SAVE-BITS-P NIL)
    (FLUSH-BIT-ARRAY))
  (WHEN (AND REMOVE-FROM-SUPERIOR SUPERIOR)
    (SETF (SHEET-EXPOSED-INFERIORS SUPERIOR)
	  (DELQ SELF (SHEET-EXPOSED-INFERIORS SUPERIOR)))))

;Adjust the specified indirect array (could be screen-array or old-screen-array)
;to have the appropriate size and position within the ultimate superior bit array
;(a non-indirect array or the screen).
;Also make sure the locations-per-line agrees with the array's spanning width.
;Propagate the change to all exposed inferiors.
(DEFMETHOD (:ADJUST-SCREEN-ARRAY SHEET) (ARRAY NEW-POINTER
					       &OPTIONAL (SUP-XOFF 0) (SUP-YOFF 0)
					       (XOFF X-OFFSET) (YOFF Y-OFFSET))

  ;; Follow array indirection since it doesn't make significantly more work
  ;; here and will speed up drawing of things onto the screen-array.  There
  ;; will still be a single level of indirection, into either a bit-array
  ;; or a screen's screen-array (which is displaced, not indirect).
  (MULTIPLE-VALUE (NEW-POINTER SUP-XOFF SUP-YOFF)
    (SCREEN-FOLLOW-DRAWABLE-INDIRECTION SCREEN NEW-POINTER SUP-XOFF SUP-YOFF))
  (INCF SUP-XOFF XOFF)
  (INCF SUP-YOFF YOFF)
  (SEND SCREEN :INFERIOR-SCREEN-ARRAY-ADJUSTED SELF ARRAY WIDTH HEIGHT
	NEW-POINTER SUP-XOFF SUP-YOFF)
  (WHEN (EQ ARRAY SCREEN-ARRAY)
    (ADJUST-INFERIOR-SCREEN-ARRAYS SELF NEW-POINTER SUP-XOFF SUP-YOFF)))

(DEFUN ADJUST-INFERIOR-SCREEN-ARRAYS (SHEET NEW-POINTER X-OFFSET Y-OFFSET)
  (DOLIST (I (SHEET-INFERIORS SHEET))
    (LET ((ARRAY (SHEET-SCREEN-ARRAY I)))
      (WHEN (OR (SHEET-EXPOSED-P I)
		(AND (NULL ARRAY) (SETQ ARRAY (SHEET-OLD-SCREEN-ARRAY I))))
	;; ARRAY is indirected to same place as our screen array, so update it
	(SEND I :ADJUST-SCREEN-ARRAY ARRAY NEW-POINTER X-OFFSET Y-OFFSET)))))

(DEFMETHOD (:REFRESH SHEET) (&OPTIONAL (TYPE :COMPLETE-REDISPLAY) &AUX (PAGED-IN NIL))
  (lock-sheet (self)
    (WHEN (AND (EQ TYPE :USE-OLD-BITS)
	       (NOT (NULL BIT-ARRAY))
	       (NOT (VERIFY-DRAWABLE SCREEN BIT-ARRAY SELF :READ)))
      ;; If the host has lost the bit-array, refresh the window instead
      (SETQ TYPE :COMPLETE-REDISPLAY))
    (SETQ RESTORED-BITS-P (AND BIT-ARRAY (NEQ TYPE :COMPLETE-REDISPLAY)))
    (COND (RESTORED-BITS-P
	   (WHEN EXPOSED-P			;If we are deexposed, this is a big no-op!
	     (%SCREEN-PAGE-IN-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF BIT-ARRAY :READ)
	     (SETQ PAGED-IN T)
	     (PREPARE-SHEET (SELF)
	       (SHEET-BITBLT ALU-SETA WIDTH HEIGHT BIT-ARRAY 0 0 NIL 0 0)))
	   (COND ((NEQ TYPE :USE-OLD-BITS)
		  (UNLESS EXPOSED-P
		    (%SCREEN-PAGE-IN-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF BIT-ARRAY :WRITE)
		    (SETQ PAGED-IN T))
		  (ERASE-MARGINS)
		  (SEND SELF :REFRESH-MARGINS))))
	  (T
	   (UNLESS EXPOSED-P
	     (WHEN BIT-ARRAY
	       (%SCREEN-PAGE-IN-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF BIT-ARRAY :WRITE)
	       (SETQ PAGED-IN T)))
	   (PREPARE-SHEET (SELF)
	     (SHEET-DRAW-RECTANGLE WIDTH HEIGHT 0 0 ERASE-ALUF SELF))
	   (SEND SELF :REFRESH-MARGINS)
	   (DOLIST (INFERIOR INFERIORS)
	     (WHEN (SHEET-EXPOSED-P INFERIOR)	;EXPOSED-INFERIORS may not all be on screen
	       (SEND INFERIOR :REFRESH :COMPLETE-REDISPLAY)))
;	 (SEND SELF :SCREEN-MANAGE)
	   (SCREEN-MANAGE-QUEUE SELF 0 0 WIDTH HEIGHT)
	   ))
    (WHEN (AND PAGED-IN *SHEET-ENABLE-EXPLICIT-PAGE-OUT* BIT-ARRAY)
      (%SCREEN-PAGE-OUT-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF BIT-ARRAY))
  RESTORED-BITS-P))

(DEFMETHOD (:REFRESH-MARGINS SHEET) () )

(DEFUN-IN-FLAVOR (WITH-SHEET-CLIPPING-REGION-INTERNAL SHEET) (CONTINUATION &REST BOUNDS)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION))
  (LETF ((CLIPPING-REGION BOUNDS))
    (FUNCALL CONTINUATION)))

;;; Called from inside a PREPARE-SHEET.
(DEFUN-IN-FLAVOR (SHEET-LET-THE-GUY-ABORT SHEET) ()
  (WHEN (AND (EQ LOCK CURRENT-PROCESS)
	     (EQ SELF CURRENTLY-PREPARED-SHEET)
	     (NOT MORE-VPOS)
	     PROCESS::*PREEMPTION-ENABLED*	;not in scheduler or something
	     (LET ((CONSOLE (SHEET-CONSOLE SELF)))
	       (OR (NOT (IO-BUFFER-EMPTY-P (CONSOLE-SYSTEM-IO-BUFFER CONSOLE)))
		   (CONSOLE-HARDWARE-CHAR-AVAILABLE CONSOLE))))
    ;; See comment on function below for tastefulness evaluation.
    (SHEET-MORE-LOCK-KLUDGE #'PROCESS-ALLOW-SCHEDULE)))


;;;Exceptions
(DEFMETHOD (:HANDLE-EXCEPTIONS SHEET) ()
  "Called when an exception occurs on a sheet.  The appropriate exception handling 
routines are called"
  (LOOP DOING
    (LET ((EXCEPTIONS (SHEET-EXCEPTIONS)))
      (WHEN (ZEROP EXCEPTIONS)
	(RETURN))
      (UNLESS (ZEROP (SHEET-OUTPUT-HOLD-FLAG))
	(SEND SELF :OUTPUT-HOLD-EXCEPTION))
      (UNLESS (ZEROP (SHEET-END-PAGE-FLAG))
	(SHEET-LET-THE-GUY-ABORT)
	(SEND SELF :END-OF-PAGE-EXCEPTION))
      (UNLESS (ZEROP (SHEET-MORE-FLAG))
	(WHEN (AND MORE-PROCESSING-TRULY-GLOBAL-ENABLE
		   MORE-PROCESSING-GLOBAL-ENABLE)
	  (SEND SELF :MORE-EXCEPTION)
	  (UNLESS (ZEROP (SHEET-END-PAGE-FLAG))
	    (SEND SELF :END-OF-PAGE-EXCEPTION)))
	(SETF (SHEET-MORE-FLAG) 0))
      (UNLESS (ZEROP (SHEET-LINE-HEIGHT-CHANGE-FLAG))
	(PREPARE-SHEET (SELF)
	  (SETF (SHEET-LINE-HEIGHT-CHANGE-FLAG) 0)
	  (NOTE-LINE-HEIGHT-CHANGE SELF PENDING-NEW-LINE-HEIGHT PENDING-NEW-BASELINE)))
      (WHEN (= (SHEET-EXCEPTIONS) EXCEPTIONS)
	(FERROR NIL "Exceptions (~O) on sheet ~S won't go away" EXCEPTIONS SELF))))
  NIL)

;This used to put continuation-line marks in the margin
;Note that when using variable-width fonts, the mark is placed relative to the
;right margin rather than relative to the text that is already there.  Hope this is right.
(DEFUN-IN-FLAVOR (SHEET-TYO-RIGHT-MARGIN-CHARACTER SHEET) (XPOS YPOS CH &AUX WID)
  XPOS	;Ignored now, but supplied in case I decide to change where the character goes
  (SETQ WID (SEND SELF ':CHARACTER-WIDTH CH CURRENT-FONT))
  (PREPARE-SHEET (SELF)
    (SHEET-DRAW-CHAR CH (- (SHEET-INSIDE-RIGHT) WID) YPOS CHAR-ALUF)))

;Called by typeout routines when they discover there is not enough space to output another
;character.  Sheet has already been prepared when this is called.
(DEFMETHOD (:END-OF-LINE-EXCEPTION SHEET) ()
  ;; Put an "!" in the right margin if called for.
  (OR (ZEROP (SHEET-RIGHT-MARGIN-CHARACTER-FLAG))
      (SHEET-TYO-RIGHT-MARGIN-CHARACTER CURSOR-X CURSOR-Y #/!))
  ;; Move to left margin, next line, and clear it
  (SHEET-INCREMENT-BITPOS (- CURSOR-X) CURRENT-LINE-HEIGHT)
  (SEND SELF ':CLEAR-REST-OF-LINE)		;If at end of page, this will home up first
  (OR (ZEROP (SHEET-EXCEPTIONS))		;Take care of any residual **more**
      (SEND SELF ':HANDLE-EXCEPTIONS)))	;since caller is about to type out

(DEFMETHOD (:END-OF-PAGE-EXCEPTION SHEET) ()
  (COND ((NOT (ZEROP (SHEET-END-PAGE-FLAG)))
	 ;; Erase any fractional line at the bottom of the sheet
	 (WHEN (< CURSOR-Y (SHEET-INSIDE-BOTTOM))
	   (PREPARE-SHEET (SELF)
	     (SHEET-DRAW-RECTANGLE (- (SHEET-INSIDE-RIGHT) (SHEET-INSIDE-LEFT))
				   (- (SHEET-INSIDE-BOTTOM) CURSOR-Y)
				   (SHEET-INSIDE-LEFT) CURSOR-Y ERASE-ALUF SELF)))
	 (LET ((M-VP MORE-VPOS))		;HOME smashes this, since it moves the cursor
	   ;; Wrap around to top of sheet
	   (SEND SELF ':HOME-CURSOR)
	   (SEND SELF ':CLEAR-REST-OF-LINE)
	   ;; Arrange for more processing next time around
	   (COND ((NULL M-VP))			;No more processing at all
		 (( M-VP 100000)		;More processing delayed?
		  (SETQ MORE-VPOS (- M-VP 100000)))	;Cause to happen next time around
		 (T (SETQ MORE-VPOS (SHEET-DEDUCE-MORE-VPOS))))))))

;;; This is the default more handler, it takes an operation, which can be something like
;;; :MORE-TYI, and returns the character that unMOREd, in case you want to UNTYI it sometimes.
;;; Note that this always returns with the cursor at the beginning of a blank line,
;;; on which you may type "flushed" if you like.  Sheet-end-page-flag will be set if
;;; this is the last line in the window, so that normal typeout will not come out on
;;; that line but will wrap-around instead.
(DEFUN-IN-FLAVOR (SHEET-MORE-HANDLER SHEET) (&OPTIONAL (OPERATION ':TYI) (MORE-STRING "**MORE**")
						  &AUX (CURRENT-X CURSOR-X)
						  (RUBOUT-HANDLER :TYI)
						  CHAR)
  (WITH-CHARACTER-STYLE (DEFAULT-STYLE SELF :bind-line-height t)
    
    (SETF (SHEET-MORE-FLAG) 0)	;"Won't need MORE processing no more"
    (SETQ MORE-VPOS (AND MORE-VPOS (+ 100000 MORE-VPOS))) ;Defer more's while typing **MORE**
    (SEND SELF ':CLEAR-REST-OF-LINE)
    (AND MORE-STRING
	 (SEND SELF ':STRING-OUT MORE-STRING))
    
    (AND (GET-HANDLER-FOR SELF OPERATION)
	 (SETQ CHAR (SHEET-MORE-LOCK-KLUDGE SELF OPERATION)))
    
    (COND (MORE-STRING
	   (SETQ CURSOR-X CURRENT-X)	;Wipe out the **MORE**
	   (SEND SELF ':CLEAR-REST-OF-LINE)))
    (COND (( (+ CURSOR-Y LINE-HEIGHT)
	      (+ TOP-MARGIN-SIZE (1- (* (1- (SHEET-NUMBER-OF-INSIDE-LINES)) LINE-HEIGHT))))
	   (IF (NOT (NULL MORE-VPOS))	;Might have been disabled while waiting!!
	       (SETQ MORE-VPOS 0))
	   (SETF (SHEET-END-PAGE-FLAG) 1))	;Wrap around unless flushed
				;At bottom, wrap around (or scroll)
				;Next MORE will happen at same place
	  (T (SEND SELF ':NOTICE ':INPUT-WAIT))) ;Otherwise, MORE one line up next time
    CHAR))

(DEFMETHOD (:MORE-EXCEPTION SHEET) ()
  (OR (ZEROP (SHEET-MORE-FLAG))
      (SHEET-MORE-HANDLER)))

;;; Returns T if the truncation flag is on.  See TRUNCATABLE-LINES-MIXIN.
(DEFMETHOD (:TRUNCATE-LINE-OUT SHEET) ()
  (NOT (ZEROP (SHEET-TRUNCATE-LINE-OUT-FLAG))))

(DEFMETHOD (:SET-TRUNCATE-LINE-OUT SHEET) (NEW-VALUE)
  (SETF (SHEET-TRUNCATE-LINE-OUT-FLAG)
	(IF NEW-VALUE 1 0)))

(DEFMETHOD (:OUTPUT-HOLD-EXCEPTION SHEET) ()
  (WHEN (AND (NOT (ZEROP (SHEET-OUTPUT-HOLD-FLAG)))
	     (NOT EXPOSED-P))			;Output held due to deexposure
    (SELECTQ DEEXPOSED-TYPEOUT-ACTION
      (:NORMAL)
      (:ERROR					;Give error if attempting typeout?
       ;;--- This should probably allow you to decide how to proceed.
       (ERROR 'OUTPUT-ON-DEEXPOSED-SHEET :SHEET SELF))
      (:PERMIT
       ;; OUTPUT-HOLD gets cleared at this level, rather than never getting set when 
       ;; deexposing, so that software knows if a sheet actually did typeout, as opposed to
       ;; it being permitted.  This allows software to know if it needs to update a
       ;; partially exposed window's bits, for example.  It is similar to a page-fault
       ;; handler's setting the write-protect bit on write enabled pages to detect when a
       ;; page is actually modified (READ-WRITE-FIRST)
       ;; If the user asked for a bit-save array here, give it to him or else.
       (FORCE-CREATE-BIT-SAVE-ARRAY)
       (WHEN SCREEN-ARRAY
	 (SETF (SHEET-OUTPUT-HOLD-FLAG) 0)))
      (:EXPOSE
       (SEND SELF :EXPOSE))
      (:NOTIFY
       (SEND SELF :NOTICE :OUTPUT))		;Consider notifying the user
      (OTHERWISE
       (IF (LISTP DEEXPOSED-TYPEOUT-ACTION)
	   (LEXPR-SEND SELF (CAR DEEXPOSED-TYPEOUT-ACTION) (CDR DEEXPOSED-TYPEOUT-ACTION))
	   (FERROR "~S is not a recognized DEEXPOSED-TYPEOUT-ACTION"
		   DEEXPOSED-TYPEOUT-ACTION)))))
  (WHEN (SHEET-OUTPUT-HELD-P)
    (SIGNAL-PROCEED-CASE (() 'OUTPUT-ON-DEEXPOSED-SHEET :SHEET SELF)
      ((:RETRY)
       (SEND SELF :OUTPUT-HOLD-EXCEPTION))
      ((NIL)
       (PROCESS:PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION
	 "Output Hold"
	 .5  ;; only poll once every 1/2 second, more frequently seems like overkill.  
	 ;; How quickly do windows get re-exposed?
	 ;; In any case, this should *really* be done by having the window system be event
	 ;; driven, and sending a wakeup when a window is exposed, or output is no longer
	 ;; held.
	 #'(LAMBDA (SHEET)
	     (NOT (SHEET-OUTPUT-HELD-P SHEET)))	;Wait until no output hold
	 SELF))
      )))

(DEFFLAVOR OUTPUT-ON-DEEXPOSED-SHEET (SHEET) (DBG:CONDITION)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:REPORT OUTPUT-ON-DEEXPOSED-SHEET) (STREAM)
  (FORMAT STREAM "Attempt to typeout on ~S, which is deexposed" SHEET))

(COMPILE-FLAVOR-METHODS OUTPUT-ON-DEEXPOSED-SHEET)

;;; This is the default method for :NOTICE, which is always called last
;;; if all other methods have returned NIL.  It provides the default handling
;;; for deexposed input and output in notify mode, handles :INPUT-WAIT,
;;; and provides the special handling for errors vis a vis the window system.
;;; Other events are completely ignored; presumably they shouldn't be noticed by windows
;;; which don't have flavors to handle them.
;;; No currently-defined events use the ARGS argument, but it is there for
;;; future extensibility.
(DEFMETHOD (:NOTICE SHEET) (EVENT &REST ARGS)
  ARGS						;ignored
  (SELECTQ EVENT
    ((:INPUT :OUTPUT)				;Deexposed window needs some attention
     ;; Now, if this window is visible we don't need to bother notifying
     (UNLESS (LOOP FOR W = SELF THEN (SHEET-SUPERIOR W) UNTIL (NULL W)
		   ALWAYS (SHEET-EXPOSED-P W))
       (NOTIFY SELF "Process ~A wants ~A"
	       (IF CURRENT-PROCESS (PROCESS-NAME CURRENT-PROCESS) "Scheduler")
	       (IF (EQ EVENT :OUTPUT) "to type out" "typein")))
     T)
    (:INPUT-WAIT				;Hanging up waiting for input.
     (SETF (SHEET-MORE-FLAG) 0)			;Decide when we need to **more** next
     (COND ((NULL MORE-VPOS))			;Unless MORE inhibited entirely
	   ((< (* (- (SHEET-INSIDE-BOTTOM) CURSOR-Y) 4)	;More than 3/4 way down window?
	       (SHEET-INSIDE-HEIGHT))
	    ;; Wrap around and more just before the current line
	    (SETQ MORE-VPOS (+ 100000 (- CURSOR-Y LINE-HEIGHT))))
	   (T ;; More at bottom 
	    (SETQ MORE-VPOS (SHEET-DEDUCE-MORE-VPOS))))
     (WHEN (AND (NOT EXPOSED-P)			;Send a notification if desired
		(NOT (ZEROP (SHEET-DEEXPOSED-TYPEIN-NOTIFY))))
       (SEND SELF :NOTICE :INPUT))
     T)
    (:ERROR
     ;;Error in process using this window as its TERMINAL-IO.
     ;;Notify if possible, and decide whether to use this
     ;;window or the cold-load stream.
     ;;For complete validity, should be called with
     ;;INHIBIT-SCHEDULING-FLAG set
     ;; If the window is too small, use a background window instead
     (LET ((SHEET SELF))
       (WHEN (OR (< (SHEET-INSIDE-WIDTH) (* CHAR-WIDTH 35.))
		 (< (SHEET-INSIDE-HEIGHT) (* LINE-HEIGHT 5)))
	 (SETQ TERMINAL-IO (SETQ SHEET (ALLOCATE-BACKGROUND-LISP-INTERACTOR))))
       ;; Do notification and lock checking
       (LET ((REASON (REASON-NOT-TO-USE-TERMINAL-IO-FOR-ERROR SHEET)))
	 (IF REASON
	     (VALUES REASON COLD-LOAD-STREAM)))))
    (OTHERWISE NIL)))				;Ignore unknown events (could signal error instead?)


;; If the window is too small, it's never OK.  (Actually, should we pop up a window
;; here?)  Otherwise we allow one of two main cases:  terminal-io is exposed and
;; good, or terminal-io is deexposed.
;; If terminal-io is exposed, it is good if we can lock it within 10. seconds, or
;; after unlocking its temporary locks.  If SELECTED-WINDOW is good and we can do
;; a CAREFUL-NOTIFY.
;; If terminal-io is deexposed we assume the world isn't screwed up if we can
;; do a CAREFUL-NOTIFY.
(DEFUN REASON-NOT-TO-USE-TERMINAL-IO-FOR-ERROR (SHEET
						&OPTIONAL (RIGHT-SHEET SHEET) RECURSION
							  (TIMEOUT (+ (TIME) 300.))
						&AUX EXPOSED-P
						(INHIBIT-SCHEDULING-FLAG T))
  (COND ;; Let's see if we're exposed and unlocked, or if we become unlocked
	((NOT (PROCESS:LOCK-IDLE-P (SCREEN-LOCK (SHEET-SCREEN SHEET))))
	 "The window-system is locked")
	((PROCESS::SCHEDULER-IS-UNSAFE-FOR-THIS-PROCESS *CURRENT-PROCESS*)
	 "The scheduler and system data-bases are in an inconsistent state")
	((CLI::CONSOLE-INPUT-LOCK (SHEET-CONSOLE SHEET))
	 "Keyboard input on this console is locked")
	((AND (SETQ EXPOSED-P
		    (LOOP FOR W = SHEET THEN (SHEET-SUPERIOR W) UNTIL (NULL W)
			  ALWAYS (SHEET-EXPOSED-P W)))
	      (OR (SHEET-CAN-BE-ACTIVATED-FOR-DEBUGGER SHEET)
		  (PROGN (SETQ INHIBIT-SCHEDULING-FLAG NIL)
			 (PROCESS-WAIT "Lock or Timeout"
				       #'(LAMBDA (SHEET TIMEOUT)
					   (OR (SHEET-CAN-BE-ACTIVATED-FOR-DEBUGGER SHEET)
					       (TIME-LESSP TIMEOUT (TIME))))
				       SHEET TIMEOUT)
			 (SETQ INHIBIT-SCHEDULING-FLAG T)
			 (AND (LOOP FOR W = SHEET THEN (SHEET-SUPERIOR W) UNTIL (NULL W)
				    ALWAYS (SHEET-EXPOSED-P W))
			      (SHEET-CAN-BE-ACTIVATED-FOR-DEBUGGER SHEET)))
		  ;; Still locked, try to unlock it.
		  (PROGN (ERROR-ATTEMPT-TEMP-UNLOCK
			   SHEET (ERROR-TIMEOUT-ADDITIONAL-DELAY TIMEOUT 90.))
			 (SETQ INHIBIT-SCHEDULING-FLAG T)
			 (SHEET-CAN-BE-ACTIVATED-FOR-DEBUGGER SHEET))))
	 ;; This window is not locked, we can use it
	 NIL)
	;; If we have already frobbed with a window, don't do notification stuff
	(RECURSION "The window-system is locked")
	(T
	 ;; The window is locked, see whether the selected window is visible and unlocked
	 ;; in which case we will be able to notify.  If there isn't a selected window,
	 ;; wait another five seconds for the window system to stabilize.
	 (LOOP WITH SELECT-TIMEOUT = (ERROR-TIMEOUT-ADDITIONAL-DELAY TIMEOUT 300.)
	       AS NEW-SHEET = (SHEET-SELECTED-WINDOW SHEET) DO	;Might change from under us
	   (COND ((AND NEW-SHEET		;A selected window exists
		       (NEQ NEW-SHEET SHEET)	;Don't recurse on same window
		       (NULL (REASON-NOT-TO-USE-TERMINAL-IO-FOR-ERROR
			       NEW-SHEET RIGHT-SHEET T
			       (ERROR-TIMEOUT-ADDITIONAL-DELAY TIMEOUT 180.))))
		  ;; Not selected, but can notify.  If we're not exposed, wait.
		  (RETURN (ERROR-CAREFUL-NOTIFY-AND-WAIT RIGHT-SHEET (NOT EXPOSED-P))))
		 ((NULL (REASON-NOT-TO-USE-TERMINAL-IO-FOR-ERROR SHEET RIGHT-SHEET T
			  (ERROR-TIMEOUT-ADDITIONAL-DELAY TIMEOUT 180.)))
		  ;; This window is okay now, stop being anxious
		  (RETURN NIL))
		 ((AND (NULL NEW-SHEET)
		       (TIME-LESSP (TIME) SELECT-TIMEOUT))
		  (PROCESS-WAIT "Selected window"
				#'(LAMBDA (SHEET SELECT-TIMEOUT)
				    (OR (SHEET-SELECTED-WINDOW SHEET)
					(TIME-LESSP SELECT-TIMEOUT (TIME))))
				SHEET SELECT-TIMEOUT))
		 (T
		  ;; Not exposed and can't notify, have to use cold-load stream
		  (RETURN "The window-system is locked")))))))

;; Ensure that our timeout time is at least INCREMENT away ...
(DEFUN ERROR-TIMEOUT-ADDITIONAL-DELAY (TIMEOUT INCREMENT)
  (IF (TIME-LESSP TIMEOUT (+ INCREMENT (TIME)))
      (+ (TIME) INCREMENT)
    TIMEOUT))

;; Try to unlock the lockers of our sheet.
(DEFUN ERROR-ATTEMPT-TEMP-UNLOCK (SHEET TIMEOUT)
  (WHEN (NOT (ATOM (SHEET-LOCK SHEET)))		;Temp locked
    (PROCESS-RUN-FUNCTION "Unlock for debugger" #'SHEET-FREE-TEMPORARY-LOCKS SHEET)
    (PROCESS-WAIT "Debugger unlock"
      #'(LAMBDA ()
	  (OR (AND SELECTED-WINDOW (NEQ SHEET SELECTED-WINDOW))
	      (SHEET-CAN-BE-ACTIVATED-FOR-DEBUGGER SHEET)
	      (TIME-LESSP TIMEOUT (TIME)))))))

(DEFUN ERROR-CAREFUL-NOTIFY-AND-WAIT (SHEET &OPTIONAL (WAIT-P T))
  (NOTIFY SHEET "Process ~A got an error" (PROCESS-NAME CURRENT-PROCESS))
  (WHEN WAIT-P
    (LET ((PROCESS-IS-IN-ERROR SHEET))		;Notify FIND-PROCESS-IN-ERROR
      (PROCESS-WAIT "Selected"
	(LAMBDA (MY-ACTIVITY MY-CONSOLE)
	  (LET* ((SEL-W (CONSOLE-SELECTED-WINDOW MY-CONSOLE))
		 (SELECTED-ACTIVITY (AND SEL-W (SEND SEL-W :ALIAS-FOR-SELECTED-WINDOWS))))
	    (EQ SELECTED-ACTIVITY MY-ACTIVITY)))
	(SEND SHEET :ALIAS-FOR-SELECTED-WINDOWS) (SHEET-CONSOLE SHEET))))
  T)

(DEFUN SHEET-CAN-BE-ACTIVATED-FOR-DEBUGGER (SHEET)
  ;; It isn't ok for the lock to be held by the current process even.
  ;; The window might only half work.
  (AND (SHEET-CAN-GET-LOCK SHEET 'SHEET-CAN-BE-ACTIVATED-FOR-DEBUGGER)
       (OR (NULL (SHEET-SUPERIOR SHEET))
	   (MEMQ SHEET (SHEET-INFERIORS (SHEET-SUPERIOR SHEET)))
	   (SHEET-CAN-BE-ACTIVATED-FOR-DEBUGGER (SHEET-SUPERIOR SHEET)))))

;; Generic interface to blinkers which also works for other types of interactive streams.
;; "Cursor" is used in the names of these messages rather than "blinker" since they refer
;; to the specific blinker which follows the typeout cursor.

;; Return the blinker visibility as the first value.
;; Return the blinker itself as second value, so that the caller can distinguish between the
;;   case in which the visibility is NIL and the case in which no blinker exists, since
;;   SHEET-FOLLOWING-BLINKER can return NIL.

(DEFMETHOD (:CURSOR-VISIBILITY SHEET) ()
  (LET ((BLINKER (SHEET-FOLLOWING-BLINKER SELF)))
    (VALUES 
      (WHEN BLINKER (SEND BLINKER :VISIBILITY))
      BLINKER)))

;; Return the blinker as the value, so that the caller can tell whether or not the message had
;; any effect.

(DEFMETHOD (:SET-CURSOR-VISIBILITY SHEET) (VISIBILITY)
  (LET ((BLINKER (SHEET-FOLLOWING-BLINKER SELF)))
    (WHEN BLINKER
      (SEND BLINKER :SET-VISIBILITY VISIBILITY))
    BLINKER))


;;; Blinker code has been moved to sys:window;blinkers.lisp

(DEFMETHOD (:CHOOSE-ATTRIBUTES SHEET) ()
  (LET* ((OLD-REVERSE-VIDEO-P (SEND SELF :REVERSE-VIDEO-P))
	 (REVERSE-VIDEO-P OLD-REVERSE-VIDEO-P))
    (LIST
      :SET-MORE-P
      (SCL:ACCEPT 'SCL:BOOLEAN
		  :PROMPT "More processing enabled"
		  ;;:DOCUMENTATION "Enable typing **MORE** and waiting for typein when there is too much typeout."
		  :DEFAULT (SEND SELF :MORE-P))
      :SET-REVERSE-VIDEO-P
      (SETQ REVERSE-VIDEO-P
	    (SCL:ACCEPT 'SCL:BOOLEAN
			:PROMPT "Reverse video"
			;;:DOCUMENTATION "Use white characters on a black background in this window."
			:DEFAULT OLD-REVERSE-VIDEO-P))
      :SET-VSP
      (SCL:ACCEPT '((CL:INTEGER 0)) :PROMPT "Vertical spacing"
		  ;;:DOCUMENTATION "The number of pixels between successive lines of printed text"
		  :DEFAULT (SEND SELF :VSP))
      :SET-DEEXPOSED-TYPEIN-ACTION
      (SCL:ACCEPT
	'((SCL:ALIST-MEMBER :ALIST (("Wait until exposed" . :NORMAL)
				    ("Notify user" . :NOTIFY))))
	:PROMPT "Deexposed typein action"
	;;:DOCUMENTATION "What to do if input is attempted while this window is deexposed."
	:DEFAULT (SEND SELF :DEEXPOSED-TYPEIN-ACTION))
      :SET-DEEXPOSED-TYPEOUT-ACTION
      (LET* ((OTHER-DEEXPOSED-TYPEOUT-ACTION (NULL (MEMQ DEEXPOSED-TYPEOUT-ACTION
							 '(:NORMAL :NOTIFY :PERMIT :ERROR))))
	     (NEW-TYPEOUT-ACTION
	       (SCL:ACCEPT '((SCL:ALIST-MEMBER :ALIST (("Wait until exposed" . :NORMAL)
						       ("Notify user" . :NOTIFY)
						       ("Let it happen" . :PERMIT)
						       ("Signal error" . :ERROR)
						       ("Other" . :OTHER))))
			   :PROMPT "Deexposed typeout action"
			   ;;:DOCUMENTATION "What to do if output is attempted while this window is deexposed."
			   :DEFAULT (IF (NOT OTHER-DEEXPOSED-TYPEOUT-ACTION)
					DEEXPOSED-TYPEOUT-ACTION
					:OTHER))))
	(IF (NOT (EQ NEW-TYPEOUT-ACTION :OTHER))
	    NEW-TYPEOUT-ACTION
	    (SCL:ACCEPT 'EXPRESSION :PROMPT "(/"Other/" value of above)"
			:DEFAULT DEEXPOSED-TYPEOUT-ACTION
			:PROVIDE-DEFAULT OTHER-DEEXPOSED-TYPEOUT-ACTION)))
      :SET-CHAR-ALUF
      (SCL:ACCEPT `((ALU-FOR-SHEET ,SELF))
		  :PROMPT "ALU function for drawing"
		  ;;:DOCUMENTATION "The ALU function for drawing characters and graphics."
		  :DEFAULT (IF (EQ REVERSE-VIDEO-P OLD-REVERSE-VIDEO-P)
			       CHAR-ALUF
			       ERASE-ALUF))
      :SET-ERASE-ALUF
      (SCL:ACCEPT `((ALU-FOR-SHEET ,SELF))
		  :PROMPT "ALU function for erasing"
		  ;;:DOCUMENTATION "The ALU function for erasing pieces of the window."
		  :DEFAULT (IF (EQ REVERSE-VIDEO-P OLD-REVERSE-VIDEO-P)
			       ERASE-ALUF
			       CHAR-ALUF))
      :SET-PRIORITY
      (SCL:ACCEPT '((SCL:NULL-OR-TYPE CL:INTEGER))
		  :PROMPT "Screen manager priority"
		  ;;:DOCUMENTATION "Set screen manager priority.  NIL is the usual thing."
		  :PROVIDE-DEFAULT T
		  :DEFAULT PRIORITY)
      :SET-SAVE-BITS
      (SCL:ACCEPT '((SCL:ALIST-MEMBER :ALIST (("Never" . NIL)
					      ("When Deexposed" . :DELAYED)
					      ("Whenever Used" . T))))
		  :PROMPT "Save bits"
		  ;;:DOCUMENTATION "Should the contents of the window be saved away when the window is deexposed?"
		  :DEFAULT (SEND SELF :SAVE-BITS))
      )))

