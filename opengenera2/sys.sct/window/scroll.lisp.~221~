;;; -*- Mode: LISP; Package: TV; Base: 8 -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; A scroll window displays a section of a database.  The user can dynamically
;;; change what is displayed on the window.

;;; The datastructure consists of items.  Each item represents an integral number
;;; of lines.  Each item is:
;;;  A) An array consisting of scroll entries (described later)
;;;  B) A list of items

;;; The scroll window knows only about one item:  in general for this to be useful
;;; this item is of form B

(DEFVAR SCROLL-NEW-X)
(DEFVAR SCROLL-NEW-Y)

(DEFVAR SCROLL-DEFAULT-VALUE-ARRAY-SIZE 100.)

(DEFVAR *SCROLL-WINDOW*)	;Bound to the scroll window around the :EXECUTE message
				;and while calling :FUNCTION items

(DEFSUBST VALUE-SEQUENCE ()
  (SEND *SCROLL-WINDOW* ':VALUE-ARRAY))

(DEFSUBST VALUE-SEQUENCE-REF (VALUE-SEQUENCE N)
  (AREF VALUE-SEQUENCE N))

(DEFSUBST VALUE (N)
  (VALUE-SEQUENCE-REF (VALUE-SEQUENCE) N))

(DEFMACRO SCROLL-LINE () `(SHEET-LINE-NO))

(DEFMACRO SCROLL-ITEM-SIZE (ITEM) `(ARRAY-LENGTH ,ITEM))

;;; Things in item's leader
(DEFSTRUCT (SCROLL-ITEM-LEADER :ARRAY-LEADER (:CONSTRUCTOR NIL)
					     (:SIZE-SYMBOL SCROLL-ITEM-LEADER-OFFSET))
  SCROLL-ITEM-MOUSE-ITEMS
  SCROLL-ITEM-LINE-SENSITIVITY)

(DEFMACRO SCROLL-FLAGS (ITEM) `(CAR ,ITEM))
(DEFMACRO SCROLL-ITEMS (ITEM) `(CDR ,ITEM))

(DEFSTRUCT (SCROLL-ENTRY :ARRAY)
  SCROLL-ENTRY-FUNCTION			;Function to call to hack entry
  SCROLL-ENTRY-RECOMPUTE-FUNCTION	;Function called to recompute item (sometimes unused)
  SCROLL-ENTRY-ARGS			;Args to above, also included is data
  SCROLL-ENTRY-LINES			;Number of lines entry spanned last time
  SCROLL-ENTRY-FINAL-X			;Final X position of cursor after this item
  SCROLL-ENTRY-FINAL-PRINTING-X		;Final X position after item was printed (may be
					; different from final-x if fixed width item)
  SCROLL-ENTRY-WIDTH			;Width of entry, or last width if variable width
  SCROLL-ENTRY-VARIABLE-WIDTH-P		;T if entry is variable width, else NIL
  SCROLL-ENTRY-DATA			;Data to be printed
  SCROLL-ENTRY-PRINTED-FORM		;The data stored in its printed form in case
					; the data isn't a string, and if the data is
					; variable width -- this makes outputting
					; a bit more efficient (Note: this is only used
					; when the item is variable width)
  SCROLL-ENTRY-PRINT-FORMAT		;Specification of how to print data
					; List of (prin1-or-princ base)
  SCROLL-ENTRY-MOUSE-INFO		;Mouse data if item is mouse sensitive
  )


(DEFFLAVOR BASIC-SCROLL-WINDOW ((DISPLAY-ITEM NIL) TOP-ITEM TARGET-TOP-ITEM BOTTOM-ITEM
				SCREEN-IMAGE SCREEN-LINES (TRUNCATION NIL)
				(VALUE-ARRAY NIL) (OUTPUT-LOCK NIL))
  ()
  (:REQUIRED-FLAVORS ESSENTIAL-WINDOW)
  (:GETTABLE-INSTANCE-VARIABLES DISPLAY-ITEM TRUNCATION VALUE-ARRAY)
  (:INITABLE-INSTANCE-VARIABLES DISPLAY-ITEM TRUNCATION VALUE-ARRAY))

(DEFUN-IN-FLAVOR (SCROLL-FLUSH-ITEM-FROM-SCREEN-IMAGE BASIC-SCROLL-WINDOW) (ITEM)
  (DOTIMES (I SCREEN-LINES)
    (COND ((EQ (AREF SCREEN-IMAGE I 0) ITEM)
	   (ASET NIL SCREEN-IMAGE I 0)
	   (ASET -1 SCREEN-IMAGE I 1)
	   (ASET -1 SCREEN-IMAGE I 2)))))

(DEFUN-IN-FLAVOR (SCROLL-MAKE-SCREEN-IMAGE BASIC-SCROLL-WINDOW) ()
  (SETQ SCREEN-LINES (SHEET-NUMBER-OF-INSIDE-LINES))
  (SETQ SCREEN-IMAGE (MAKE-ARRAY (LIST SCREEN-LINES 3)))
  (DOTIMES (I SCREEN-LINES)
    (ASET NIL SCREEN-IMAGE I 0)
    (ASET -1 SCREEN-IMAGE I 1)
    (ASET -1 SCREEN-IMAGE I 2)))

(DEFFLAVOR SCROLL-WINDOW ()
  (FLASHY-SCROLLING-MIXIN BASIC-SCROLL-WINDOW BORDERS-MIXIN BASIC-SCROLL-BAR WINDOW)
  (:DOCUMENTATION :COMBINATION))

(DEFMETHOD (:SCROLL-BAR-P SCROLL-WINDOW) () T)

(DEFMETHOD (:SCREEN-MANAGE SCROLL-WINDOW) (&REST IGNORE) () )

(DEFMETHOD (:INIT BASIC-SCROLL-WINDOW :BEFORE) (PLIST)
  (SETQ TOP-ITEM NIL
	TARGET-TOP-ITEM 0)
  (OR VALUE-ARRAY (SETQ VALUE-ARRAY (MAKE-ARRAY SCROLL-DEFAULT-VALUE-ARRAY-SIZE)))
  (PUTPROP PLIST NIL ':BLINKER-P)
  (PUTPROP PLIST NIL ':MORE-P))

(DEFMETHOD (:INIT BASIC-SCROLL-WINDOW :AFTER) (IGNORE)
  (SCROLL-MAKE-SCREEN-IMAGE))

(DEFMETHOD (:SET-DISPLAY-ITEM BASIC-SCROLL-WINDOW) (NEW-DISPLAY-ITEM)
  (SETQ DISPLAY-ITEM NEW-DISPLAY-ITEM
	TOP-ITEM NIL
	TARGET-TOP-ITEM 0)
  (SEND SELF ':REDISPLAY T ':FORCE))

(DEFMETHOD (:SET-TRUNCATION BASIC-SCROLL-WINDOW) (NEW-VALUE)
  (SETQ TRUNCATION NEW-VALUE)
  (SEND SELF ':REDISPLAY T ':FORCE))

;;; All the work is done by the redisplayer
(DEFVAR SCROLL-SPACES (FORMAT NIL "~2000X"))
(DEFVAR *SCROLL-CURRENT-ITEM*)
(DEFVAR *SCROLL-CURRENT-ITEM-LINE*)

(DEFUN-IN-FLAVOR (SCROLL-REDISPLAY-DISPLAY-ITEM BASIC-SCROLL-WINDOW)
	      (ITEM CURRENT-COUNT
	       &AUX CURRENT-LINE CURRENT-ITEM-LINE
		    FIRST-LINE FORCE-UPDATE OLD-LINE ENTRY-NEEDS-UPDATING END-OF-ITEM
		    (*SCROLL-WINDOW* SELF))
  "Called with an item that might want to be on the screen.  CURSOR-Y set up correctly."
  (COND (( CURRENT-COUNT TARGET-TOP-ITEM)
	 ;; We wanna be on the screen
	 (SETQ FIRST-LINE (IF SCROLL-NEW-X
			      (// SCROLL-NEW-Y LINE-HEIGHT)
			      (SCROLL-LINE))
	       BOTTOM-ITEM CURRENT-COUNT)
	 (COND ((AND (SETQ OLD-LINE
			   (DO ((I FIRST-LINE (1+ I)))
			       (( I SCREEN-LINES) NIL)
			     (AND (EQ ITEM (AREF SCREEN-IMAGE I 0))
				  (ZEROP (AREF SCREEN-IMAGE I 1))
				  ;; If first line of this item on screen anywhere, then
				  ;; can move it to current line
				  (RETURN I))))
		     ( OLD-LINE FIRST-LINE))
		(AND SCROLL-NEW-X
		     (SEND SELF ':SET-CURSORPOS SCROLL-NEW-X SCROLL-NEW-Y))
		(SETQ SCROLL-NEW-X NIL
		      SCROLL-NEW-Y NIL)
		;; On screen but not in same position, move it up
		(SEND SELF ':DELETE-LINE (- OLD-LINE FIRST-LINE))))

	 ;; Now redisplay the item.
	 (SETQ CURRENT-LINE FIRST-LINE
	       CURRENT-ITEM-LINE 0)
	 (UNWIND-PROTECT
	   (PROGN
	     (DOTIMES (I (SCROLL-ITEM-SIZE ITEM))
	       (LET ((ENTRY (AREF ITEM I))
		     (WID) (CHANGED-P))
		 ;; Loop over all elements of the item
		 (SETQ ENTRY-NEEDS-UPDATING
		       (OR FORCE-UPDATE
			   (NEQ ITEM (AREF SCREEN-IMAGE CURRENT-LINE 0))
			   ( (AREF SCREEN-IMAGE CURRENT-LINE 1) CURRENT-ITEM-LINE)))
		 (COND ((NOT (OR (SETQ CHANGED-P (FUNCALL (SCROLL-ENTRY-FUNCTION ENTRY)
							  ':CHANGED-P ENTRY
							  (SCROLL-ENTRY-FUNCTION ENTRY)))
				 ENTRY-NEEDS-UPDATING))
			;; Entry didn't change, but take into account how many
			;; lines it takes up
			(LET ((SEL (SCROLL-ENTRY-LINES ENTRY)))
			  (IF (AND TRUNCATION (> SEL 0))
			      ;; Spans more than one line, and truncating -- punt
			      (SETQ END-OF-ITEM T)
			      (SETQ CURRENT-ITEM-LINE (+ SEL CURRENT-ITEM-LINE)
				    CURRENT-LINE (+ SEL CURRENT-LINE))
			      (SETQ SCROLL-NEW-X (- (SCROLL-ENTRY-FINAL-X ENTRY)
						    (SHEET-INSIDE-LEFT))
				    SCROLL-NEW-Y (+ (OR SCROLL-NEW-Y
							(- CURSOR-Y (SHEET-INSIDE-TOP)))
						    (* LINE-HEIGHT SEL)))
			      (AND ( (// SCROLL-NEW-Y LINE-HEIGHT) SCREEN-LINES)
				   (THROW 'END-OF-PAGE T)))))
		       ;; Set cursor to correct place, and continue with COND
		       ((PROG1 NIL
			       (AND SCROLL-NEW-X
				    (SEND SELF ':SET-CURSORPOS SCROLL-NEW-X SCROLL-NEW-Y))
			       (SETQ SCROLL-NEW-X NIL
				     SCROLL-NEW-Y NIL)))
		       ;; Entry needs updating, decide whether variable width or not
		       ((AND CHANGED-P
			     (SCROLL-ENTRY-VARIABLE-WIDTH-P ENTRY)
			     ( (SCROLL-ENTRY-WIDTH ENTRY)
				(SETQ WID (FUNCALL (SCROLL-ENTRY-FUNCTION ENTRY) ':WIDTH
						   ENTRY (SCROLL-ENTRY-FUNCTION ENTRY)))))
			;; Going to kill line, move it down if it belongs below here anyway
			(AND (AREF SCREEN-IMAGE CURRENT-LINE 0)
			     (NEQ (AREF SCREEN-IMAGE CURRENT-LINE 0) ITEM)
			     (SEND SELF ':INSERT-LINE 1))
			;; Variable width entry, and the width changed, force
			;; complete update of rest of item
			(SETQ FORCE-UPDATE T)
			(SETF (SCROLL-ENTRY-WIDTH ENTRY) WID)
			(SEND SELF ':CLEAR-REST-OF-LINE)
			(SCROLL-FLUSH-ITEM-FROM-SCREEN-IMAGE ITEM)
			(LET ((*SCROLL-CURRENT-ITEM* ITEM)
			      (*SCROLL-CURRENT-ITEM-LINE* CURRENT-ITEM-LINE))
			  (SETQ END-OF-ITEM
				(CATCH 'END-OF-LINE
				  (PROGN
				    (UNWIND-PROTECT
				      (FUNCALL (SCROLL-ENTRY-FUNCTION ENTRY) ':PRINT ENTRY)
				      (SETF (SCROLL-ENTRY-FINAL-X ENTRY) CURSOR-X)
				      (SETF (SCROLL-ENTRY-FINAL-PRINTING-X ENTRY) CURSOR-X)
				      (SETF (SCROLL-ENTRY-LINES ENTRY)
					    (- (MIN (SCROLL-LINE) (1- SCREEN-LINES))
					       CURRENT-LINE)))
				    NIL))))
			(SETQ CURRENT-LINE (SCROLL-LINE)
			      CURRENT-ITEM-LINE (+ (SCROLL-ENTRY-LINES ENTRY)
						   CURRENT-ITEM-LINE)))
		       (T
			;; Fixed width entry, or variable width entry and width hasn't changed
			;; Using the width, figure out the cursor motion and erase area
			(MULTIPLE-VALUE-BIND (FINAL-X FINAL-Y FINAL-COUNT)
			    (SEND SELF ':COMPUTE-MOTION SCROLL-SPACES 
				  0 (MIN (SCROLL-ENTRY-WIDTH ENTRY)
					 (STRING-LENGTH SCROLL-SPACES))
				  NIL NIL NIL
				  (IF TRUNCATION
				      (- (SHEET-INSIDE-RIGHT) CHAR-WIDTH)
				    0)
				  (IF TRUNCATION
				      (- CURSOR-Y (SHEET-INSIDE-TOP))
				    NIL)
				  ;; Large number, making believe we
				  ;; have infinitly long screen
				  1_20.)
			  (SETQ FINAL-X (+ FINAL-X (SHEET-INSIDE-LEFT))
				END-OF-ITEM (AND (NUMBERP FINAL-COUNT)
						 ( FINAL-COUNT (SCROLL-ENTRY-WIDTH ENTRY))))
			  (LET ((Y-LIMIT (* (1- SCREEN-LINES) LINE-HEIGHT)))
			    (AND (> FINAL-Y Y-LIMIT)
				(SETQ FINAL-X (SHEET-INSIDE-RIGHT)
				      FINAL-Y Y-LIMIT)))
			  (INCF FINAL-Y (SHEET-INSIDE-TOP))
			  (SETF (SCROLL-ENTRY-FINAL-X ENTRY) FINAL-X)
			  (SETF (SCROLL-ENTRY-LINES ENTRY)
				(- (SHEET-LINE-NO NIL FINAL-Y) CURRENT-LINE))
			  ;; Zero the area
			  (PREPARE-SHEET (SELF)
			    (DO ((Y CURSOR-Y (+ Y LINE-HEIGHT))
				 (LINE 0 (1+ LINE))
				 (X CURSOR-X (SHEET-INSIDE-LEFT))
				 (LE) (DELTA-ITEMS))
				((> Y FINAL-Y))
			      (SETQ LE (AREF SCREEN-IMAGE (+ CURRENT-LINE LINE) 0))
			      (COND ((OR (AND (EQ LE ITEM)
					      (= (AREF SCREEN-IMAGE (+ CURRENT-LINE LINE) 1)
						 (+ CURRENT-ITEM-LINE LINE)))
					 (NULL LE))
				     ;; We know about this line so just clear the area
				     (SHEET-DRAW-RECTANGLE
				       (- (IF (= Y FINAL-Y)
					      (MIN FINAL-X
						   (SHEET-INSIDE-RIGHT))
					      (SHEET-INSIDE-RIGHT))
					  X)
				       LINE-HEIGHT X Y ERASE-ALUF))
				    ((EQ LE ITEM)
				     ;; We own line, but it is wrong number.  Clear the line
				     ;; and flush all knowledge
				     (SHEET-DRAW-RECTANGLE (- (SHEET-INSIDE-RIGHT) X)
							   LINE-HEIGHT X Y ERASE-ALUF)
				     (SCROLL-FLUSH-ITEM-FROM-SCREEN-IMAGE ITEM))
				    (T
				     ;; Make room for remaining number of lines and return
				     (SETQ DELTA-ITEMS
					   (- (AREF SCREEN-IMAGE (+ CURRENT-LINE LINE) 2)
					      CURRENT-COUNT))
				     ;; DELTA-ITEMS is a guess as to the number of items
				     ;; in between this and the line it collided with.  
				     ;; Assuming one line per item, this is a good guess as
				     ;; to the number of additional lines to insert
				     (LET-GLOBALLY ((CURSOR-Y Y))
				       (SEND SELF ':INSERT-LINE
					 ;; If we are past the item that's on this line, it
					 ;; can't possibly appear on the screen -- insert 
					 ;; enough lines to make it go off the screen
					 (MAX 1 (MIN (+ (// (- FINAL-Y Y) LINE-HEIGHT)
							(ABS DELTA-ITEMS))
						     (- SCREEN-LINES (SCROLL-LINE))))))
				     (RETURN T)))))
			  (LET ((*SCROLL-CURRENT-ITEM* ITEM)
				(*SCROLL-CURRENT-ITEM-LINE* CURRENT-ITEM-LINE))
			    (COND ((CATCH 'END-OF-LINE
				     (PROGN
				       (FUNCALL (SCROLL-ENTRY-FUNCTION ENTRY) ':PRINT ENTRY)
				       (SETQ CURRENT-ITEM-LINE (+ (SCROLL-ENTRY-LINES ENTRY)
								  CURRENT-ITEM-LINE)
					     CURRENT-LINE (+ (SCROLL-ENTRY-LINES ENTRY)
							     CURRENT-LINE))
				       (SETF (SCROLL-ENTRY-FINAL-PRINTING-X ENTRY) CURSOR-X)
				       (SETQ SCROLL-NEW-X (- FINAL-X (SHEET-INSIDE-LEFT))
					     SCROLL-NEW-Y (- FINAL-Y (SHEET-INSIDE-TOP)))
				       (SEND SELF ':HANDLE-EXCEPTIONS)
				       NIL))
				   (SETF (SCROLL-ENTRY-FINAL-PRINTING-X ENTRY) CURSOR-X)
				   (SETQ END-OF-ITEM T))))))))
	       (AND END-OF-ITEM (RETURN T)))
	     (SETQ SCROLL-NEW-X 0
		   SCROLL-NEW-Y (+ (OR SCROLL-NEW-Y (- CURSOR-Y (SHEET-INSIDE-TOP)))
				   LINE-HEIGHT))
	     (AND ( (1+ CURRENT-LINE) SCREEN-LINES)
		  (THROW 'END-OF-PAGE T)))
	   (SETQ CURRENT-LINE (MIN CURRENT-LINE (1- SCREEN-LINES)))
	   (DO ((L FIRST-LINE (1+ L)))
	       ((> L CURRENT-LINE))
	     (ASET ITEM SCREEN-IMAGE L 0)
	     (ASET (- L FIRST-LINE) SCREEN-IMAGE L 1)
	     (ASET CURRENT-COUNT SCREEN-IMAGE L 2))))))

(DEFUN-IN-FLAVOR (SCROLL-REDISPLAY-ITEM-LOOP BASIC-SCROLL-WINDOW)
	      (ITEM CURRENT-COUNT FUNCTION NO-RECOMP &REST POSITION)
  "Loop over an item and it's inferiors until TARGET-TOP-ITEM has been reached,
then start doing the appropriate things to fix up the screen.  This may require
inserting and deleting lines, etc...  Returns what the number of the next item is."
  (LET ((*SCROLL-WINDOW* SELF))
    (LABELS ((RECURSE (ITEM &REST POSITION &AUX FUN)
	       (COND ((NULL ITEM))
		     ((LISTP ITEM)
		      ;; A list of other items, recurse
		      (UNLESS NO-RECOMP
			(DO ((F (SCROLL-FLAGS ITEM) (CDDR F)))
			    ((NULL F))
			  (SELECTQ (CAR F)
			    (:FUNCTION (SETQ FUN (CADR F)))
			    (:PRE-PROCESS-FUNCTION (FUNCALL (CADR F) ITEM)))))
		      (DO ((ITEMS (SCROLL-ITEMS ITEM) (CDR ITEMS)))
			  ((NULL ITEMS))
			(WHEN FUN
			  (RPLACA ITEMS (FUNCALL FUN (CAR ITEMS) POSITION
						 (LOCF (SCROLL-FLAGS ITEM)))))
			(SETQ CURRENT-COUNT (LEXPR-FUNCALL #'RECURSE (CAR ITEMS) 0 POSITION))
			(SEND SELF ':HANDLE-EXCEPTIONS)
			(SETF (FIRST POSITION) (1+ (FIRST POSITION)))))
		     ;; An item that really takes up space
		     ((> (SETQ CURRENT-COUNT (1+ CURRENT-COUNT)) TARGET-TOP-ITEM)
		      ;; This item is of interest
		      (FUNCALL FUNCTION ITEM (1- CURRENT-COUNT))))
	       CURRENT-COUNT))
      (COND ((NULL TOP-ITEM)
	     ;; Nothing on the screen now, will have to do whole thing
	     (AND (OR (NULL TARGET-TOP-ITEM)
		      (< TARGET-TOP-ITEM 0))
		  (SETQ TARGET-TOP-ITEM 0)))
	    ((OR (NULL TARGET-TOP-ITEM) (< TARGET-TOP-ITEM 0))
	     ;; No change in top line, just target for where we are
	     (SETQ TARGET-TOP-ITEM TOP-ITEM)))
      (LEXPR-FUNCALL #'RECURSE ITEM POSITION))))

(DEFUN-IN-FLAVOR (SCROLL-REDISPLAY BASIC-SCROLL-WINDOW)
	      (&OPTIONAL FULL-REDISPLAY &AUX (SCROLL-NEW-X 0) (SCROLL-NEW-Y 0))
  (SHEET-FORCE-ACCESS (SELF :NO-PREPARE)
   (LOCK-SHEET (SELF)
    (AND (OR FULL-REDISPLAY (NULL TOP-ITEM))
	 ;; If doing full redisplay then must clear whole screen
	 ;; :CLEAR-WINDOW will take care of forcing redisplay
	 (SEND SELF ':CLEAR-WINDOW))
    (WITHOUT-INTERRUPTS
      (COND ((NULL TOP-ITEM)
	     ;; Nothing on the screen now, will have to do whole thing
	     (AND (OR (NULL TARGET-TOP-ITEM)
		      (< TARGET-TOP-ITEM 0))
		  (SETQ TARGET-TOP-ITEM 0)))
	    ((OR (NULL TARGET-TOP-ITEM) (< TARGET-TOP-ITEM 0))
	     ;; No change in top line, just target for where we are
	     (SETQ TARGET-TOP-ITEM TOP-ITEM))))
    (CATCH 'END-OF-PAGE
      (PROGN
	(SETQ BOTTOM-ITEM -1)
	(SCROLL-REDISPLAY-ITEM-LOOP DISPLAY-ITEM 0
				    #'(LAMBDA (ITEM CURRENT-COUNT)
					(DECLARE (SYS:DOWNWARD-FUNCTION))
					(SCROLL-REDISPLAY-DISPLAY-ITEM ITEM CURRENT-COUNT))
				    NIL 0)
	(SETQ BOTTOM-ITEM (1+ BOTTOM-ITEM))
	(AND SCROLL-NEW-X
	     (SEND SELF ':SET-CURSORPOS SCROLL-NEW-X SCROLL-NEW-Y))
	(SEND SELF ':CLEAR-REST-OF-LINE)
	(DO ((I (SCROLL-LINE) (1+ I)))
	    (( I SCREEN-LINES))
	  ;; Bind off SHEET-CR-NOT-NEWLINE-FLAG to that we really CRLF
	  (CATCH 'END-OF-PAGE
	    (LETF ((FLAGS (DPB 0 (BYTE 1 9) FLAGS)))
	      (SEND SELF ':TYO #\CR)))
	  (SEND SELF ':CLEAR-REST-OF-LINE)
	  (ASET NIL SCREEN-IMAGE I 0)
	  (ASET -1 SCREEN-IMAGE I 1)
	  (ASET -1 SCREEN-IMAGE I 2))))
    (SETQ TOP-ITEM TARGET-TOP-ITEM)
    (SEND SELF ':NEW-SCROLL-POSITION TOP-ITEM))))

(DEFSELECT SCROLL-ENTRY-CONSTANT-STRING-FUNCTION
  (:PRINT (ENTRY)
    (SEND *SCROLL-WINDOW* :STRING-OUT (SCROLL-ENTRY-DATA ENTRY)))
  (:RECOMPUTE (IGNORE) NIL)
  (:CHANGED-P (IGNORE IGNORE) NIL))

(DEFSELECT SCROLL-ENTRY-SYMBOL-VALUE-FUNCTION
  (:PRINT (ENTRY &AUX (DATA (SCROLL-ENTRY-PRINTED-FORM ENTRY))
		      (FORMAT (SCROLL-ENTRY-PRINT-FORMAT ENTRY)))
    (COND (DATA (SEND *SCROLL-WINDOW* :STRING-OUT DATA))
	  (T
	   (LET* ((BASE (OR (CADR FORMAT) BASE))
		  (CL:*PRINT-RADIX* (NOT (OR (CADDR FORMAT) (NOT CL:*PRINT-RADIX*)))))
	     (SETQ DATA (SCROLL-ENTRY-DATA ENTRY))
	     (IF (CAR FORMAT)
		 (FORMAT *SCROLL-WINDOW* (CAR FORMAT) DATA)
		 (FORMAT *SCROLL-WINDOW* "~A" DATA))))))
  (:CHANGED-P (ENTRY US)
    (COND ((NOT (EQUAL (SCROLL-ENTRY-DATA ENTRY)
		       (FUNCALL US :RECOMPUTE ENTRY)))
	   (SETF (SCROLL-ENTRY-PRINTED-FORM ENTRY) NIL)
	   T)
	  (T NIL)))    
  (:RECOMPUTE (ENTRY &AUX DATA)
    (SETQ DATA (SYMEVAL (SCROLL-ENTRY-RECOMPUTE-FUNCTION ENTRY)))
    (SETF (SCROLL-ENTRY-DATA ENTRY) DATA)
    DATA)
  (:WIDTH (ENTRY US &AUX DATA (FORMAT (SCROLL-ENTRY-PRINT-FORMAT ENTRY)))
    (SETQ DATA (FUNCALL US :RECOMPUTE ENTRY))
    ;; Stream to return length
    (LET* ((BASE (OR (CADR FORMAT) BASE))
	   (CL:*PRINT-RADIX* (NOT (OR (CADDR FORMAT) (NOT CL:*PRINT-RADIX*)))))
;	 (SETF (SCROLL-ENTRY-PRINTED-FORM ENTRY)
;	       (SETQ DATA
;		     (IF (AND (STRINGP DATA) (NULL (CAR FORMAT)))
;			 DATA
;			 (IF (CAR FORMAT)
;			     (FORMAT NIL (CAR FORMAT) DATA)
;			     (FORMAT NIL "~A" DATA)))))
;	 (MULTIPLE-VALUE-BIND (IGNORE WIDTH)
;	     (SHEET-STRING-LENGTH *SCROLL-WINDOW* DATA)
;	   WIDTH))))
      (IF (AND (STRINGP DATA) (NULL (CAR FORMAT)))
	  (MULTIPLE-VALUE-BIND (IGNORE STRING-WIDTH)
	      (SEND *SCROLL-WINDOW* :STRING-LENGTH DATA)
	    STRING-WIDTH)
	  (IF (CAR FORMAT)
	      (STRING-LENGTH (FORMAT NIL (CAR FORMAT) DATA))
	      (FLATC DATA))))))

(DEFSELECT (SCROLL-ENTRY-CALL-FUNCTION-FUNCTION SCROLL-ENTRY-SYMBOL-VALUE-FUNCTION)
  (:RECOMPUTE (ENTRY &AUX DATA)
    (SETQ DATA (LEXPR-FUNCALL (SCROLL-ENTRY-RECOMPUTE-FUNCTION ENTRY)
			      (SCROLL-ENTRY-ARGS ENTRY)))
    (SETF (SCROLL-ENTRY-DATA ENTRY) DATA)
    DATA))

(DEFMETHOD (:SCROLL-MORE-ABOVE BASIC-SCROLL-WINDOW) ()
  (AND TOP-ITEM (> TOP-ITEM 0)))

(DEFUN-IN-FLAVOR (SCROLL-TOTAL-ITEMS BASIC-SCROLL-WINDOW) ()
  (MAX 0 (1- (SCROLL-REDISPLAY-ITEM-LOOP DISPLAY-ITEM 0 #'(LAMBDA (&REST IGNORE)) T 0))))

(DEFMETHOD (:SCROLL-POSITION BASIC-SCROLL-WINDOW) ()
  (VALUES (OR TOP-ITEM 0)	;Item number at top
	  (SCROLL-TOTAL-ITEMS)			;Total number of items
	  LINE-HEIGHT				;Pixels per item
	  (IF TOP-ITEM				;Number currently displayed
	      (MAX 0 (- BOTTOM-ITEM TOP-ITEM))
	      1)))

;;Copied from (:Y-SCROLL-POSITION BASIC-SCROLL-BAR :DEFAULT)
(DEFMETHOD (:Y-SCROLL-POSITION BASIC-SCROLL-WINDOW) ()
  (MULTIPLE-VALUE-BIND (TOP-LINE-NUM TOTAL-LINES LIN-HEIGHT N-ITEMS)
      (SEND SELF :SCROLL-POSITION)
    ;; Apparently there are some losers who fail to provide this value.
    (UNLESS N-ITEMS (SETQ N-ITEMS (// (SHEET-INSIDE-HEIGHT) LIN-HEIGHT)))
    (VALUES (* TOP-LINE-NUM LIN-HEIGHT)
	    (* N-ITEMS LIN-HEIGHT)
	    0
	    (* TOTAL-LINES LIN-HEIGHT))))

;;Copied from (:Y-SCROLL-TO BASIC-SCROLL-BAR :DEFAULT)
(DEFMETHOD (:Y-SCROLL-TO BASIC-SCROLL-WINDOW) (POS &OPTIONAL (TYPE ':ABSOLUTE))
  ;; Truncate POS, because the reference point for a line is its top.
  ;; Don't use ROUND or CEILING.
  ;; The units for :RELATIVE-JUMP are whole lines.
  (IF (EQ TYPE :RELATIVE-JUMP)
      (SEND SELF :SCROLL-TO POS :RELATIVE)
      (MULTIPLE-VALUE-BIND (IGNORE IGNORE USER-LINE-HEIGHT IGNORE)
	  ;; this is a bit of a crock, to use the "obsolete" method, but
	  ;; the information isn't available from the "real" method, y-scroll-to
	  (SEND SELF :SCROLL-POSITION)
	(SEND SELF :SCROLL-TO (// POS USER-LINE-HEIGHT) TYPE))))

(DEFMETHOD (:REFRESH BASIC-SCROLL-WINDOW :AFTER) (&OPTIONAL TYPE)
  (AND (OR (NOT RESTORED-BITS-P) (EQ TYPE ':SIZE-CHANGED))
       (SCROLL-REDISPLAY T)))

(DEFMETHOD (:REDISPLAY BASIC-SCROLL-WINDOW) (&OPTIONAL (FULL-P NIL) (FORCE-P NIL))
  (IF FORCE-P
      (SCROLL-REDISPLAY FULL-P)
      (DO () (())
	(LOCK-SHEET (SELF)
	  (OR (SHEET-OUTPUT-HELD-P SELF)
	      (RETURN (SCROLL-REDISPLAY FULL-P))))
	(SEND SELF ':OUTPUT-HOLD-EXCEPTION))))

(DEFMETHOD (:REDISPLAY-SELECTED-ITEMS BASIC-SCROLL-WINDOW) (ITEMS)
  (SHEET-FORCE-ACCESS (SELF :NO-PREPARE)
    (LET ((SCROLL-NEW-X) (SCROLL-NEW-Y)
	  (ITEM NIL))
      (LETF ((BOTTOM-ITEM BOTTOM-ITEM))
	(SETQ TARGET-TOP-ITEM TOP-ITEM)
	(CATCH 'END-OF-PAGE
	  (DOTIMES (I SCREEN-LINES)
	    (COND ((AND (SETQ ITEM (CAR (MEMQ (AREF SCREEN-IMAGE I 0) ITEMS)))
			(ZEROP (AREF SCREEN-IMAGE I 1)))
		   (SETQ SCROLL-NEW-Y (* I LINE-HEIGHT)
			 SCROLL-NEW-X 0)
		   (SCROLL-REDISPLAY-DISPLAY-ITEM ITEM (AREF SCREEN-IMAGE I 2))))))))))

(DEFMETHOD (:REDISPLAY BASIC-SCROLL-WINDOW :AFTER) (&REST IGNORE)
  (MOUSE-WAKEUP))

(DEFMETHOD (:CHANGE-OF-SIZE-OR-MARGINS BASIC-SCROLL-WINDOW :AFTER) (&REST IGNORE)
  (SCROLL-MAKE-SCREEN-IMAGE))

(DEFMETHOD (:CLEAR-WINDOW BASIC-SCROLL-WINDOW :BEFORE) ()
  (OR TARGET-TOP-ITEM (SETQ TARGET-TOP-ITEM TOP-ITEM))
  (SETQ TOP-ITEM NIL)
  (DOTIMES (I SCREEN-LINES)
    (ASET NIL SCREEN-IMAGE I 0)
    (ASET -1 SCREEN-IMAGE I 1)
    (ASET -1 SCREEN-IMAGE I 2)))

;;; At end of page simply throw
(DEFMETHOD (:END-OF-PAGE-EXCEPTION BASIC-SCROLL-WINDOW) (&REST IGNORE)
  (SETF (SHEET-END-PAGE-FLAG SELF) 0)
  (THROW 'END-OF-PAGE T))

;;; If run over end of line, make sure room on next line
(DEFMETHOD (:END-OF-LINE-EXCEPTION BASIC-SCROLL-WINDOW :BEFORE) ()
  (COND (TRUNCATION
	 (THROW 'END-OF-LINE T)))
  (COND (( (1+ (SCROLL-LINE)) SCREEN-LINES)
	 ;; We're really at the end of the page, nothing to do
	 )
	((NEQ *SCROLL-CURRENT-ITEM* (AREF SCREEN-IMAGE (1+ (SCROLL-LINE)) 0))
	 (SCROLL-FLUSH-ITEM-FROM-SCREEN-IMAGE *SCROLL-CURRENT-ITEM*)
	 (LET-GLOBALLY ((CURSOR-Y (+ CURSOR-Y LINE-HEIGHT)))
	   (SEND SELF ':INSERT-LINE)))
	(( (1+ *SCROLL-CURRENT-ITEM-LINE*) (AREF SCREEN-IMAGE (1+ (SCROLL-LINE)) 1))
	 (SCROLL-FLUSH-ITEM-FROM-SCREEN-IMAGE *SCROLL-CURRENT-ITEM*))))

(DEFMETHOD (:DELETE-LINE BASIC-SCROLL-WINDOW :BEFORE) (&OPTIONAL (N 1)
						       &AUX (CUR-LINE (SCROLL-LINE)))
  (DO ((L CUR-LINE (1+ L)))
      (( (+ L N) SCREEN-LINES))
    (ASET (AREF SCREEN-IMAGE (+ L N) 0) SCREEN-IMAGE L 0)
    (ASET (AREF SCREEN-IMAGE (+ L N) 1) SCREEN-IMAGE L 1)
    (ASET (AREF SCREEN-IMAGE (+ L N) 2) SCREEN-IMAGE L 2))
  (DOTIMES (I N)
    (ASET NIL SCREEN-IMAGE (- SCREEN-LINES (1+ I)) 0)
    (ASET -1 SCREEN-IMAGE (- SCREEN-LINES (1+ I)) 1)
    (ASET -1 SCREEN-IMAGE (- SCREEN-LINES (1+ I)) 2)))

(DEFMETHOD (:INSERT-LINE BASIC-SCROLL-WINDOW :BEFORE) (&OPTIONAL (N 1)
						       &AUX (CUR-LINE (SCROLL-LINE)))
  (DO ((L (- SCREEN-LINES N 1) (1- L))
       (I (1- SCREEN-LINES) (1- I)))
      ((< L CUR-LINE))
    (ASET (AREF SCREEN-IMAGE L 0) SCREEN-IMAGE I 0)
    (ASET (AREF SCREEN-IMAGE L 1) SCREEN-IMAGE I 1)
    (ASET (AREF SCREEN-IMAGE L 2) SCREEN-IMAGE I 2))
  (DO ((L CUR-LINE (1+ L)))
      (( L (+ CUR-LINE N)))
    (ASET NIL SCREEN-IMAGE L 0)
    (ASET -1 SCREEN-IMAGE L 1)
    (ASET -1 SCREEN-IMAGE L 2)))

;;; Scrolling from the mouse
(DEFUN-IN-FLAVOR (SCROLL-ITEM-NUMBER-AT-Y BASIC-SCROLL-WINDOW) (Y &AUX IN)
  (SETQ Y (MAX 0 (MIN (SHEET-LINE-NO NIL Y) (1- (SHEET-NUMBER-OF-INSIDE-LINES)))))
  (SETQ IN (AREF SCREEN-IMAGE Y 2))
  (IF (< IN 0)
      NIL
      IN))

(DEFUN-IN-FLAVOR (SCROLL-FIND-A-TOP-ITEM BASIC-SCROLL-WINDOW)
		 (SCROLL-ITEM-TARGET-ITEM SCROLL-ITEM-TARGET-DISTANCE)
  (DECLARE (SPECIAL SCROLL-ITEM-TARGET-ITEM SCROLL-ITEM-TARGET-DISTANCE))
  (LET ((SCROLL-ITEM-LIST NIL)
	(SCROLL-ITEM-LONGEST-DISTANCE 0))
    (DECLARE (SPECIAL SCROLL-ITEM-LIST SCROLL-ITEM-LONGEST-DISTANCE))
    (LETF ((TARGET-TOP-ITEM 0))
      (CATCH 'SCROLL-FIND-A-TOP-ITEM
	(SCROLL-REDISPLAY-ITEM-LOOP DISPLAY-ITEM 0
				    #'SCROLL-FIND-A-TOP-ITEM-INTERNAL NIL 0)))))

(DEFUN SCROLL-FIND-A-TOP-ITEM-INTERNAL (ITEM ITEM-NUMBER)
  (DECLARE (SPECIAL SCROLL-ITEM-LIST SCROLL-ITEM-LONGEST-DISTANCE
		    SCROLL-ITEM-TARGET-DISTANCE SCROLL-ITEM-TARGET-ITEM))
  (COND ((= ITEM-NUMBER SCROLL-ITEM-TARGET-ITEM)
	 ;; Found the item of interest, put the last item on top.
	 (THROW 'SCROLL-FIND-A-TOP-ITEM (CDAR (LAST SCROLL-ITEM-LIST))))
	(( SCROLL-ITEM-LONGEST-DISTANCE SCROLL-ITEM-TARGET-DISTANCE)
	 ;; We have enough items to make up the distance, throw away the last one and
	 ;; add in the new one
	 (LET ((LAST-ITEM (CAR (LAST SCROLL-ITEM-LIST))))
	   (SETQ SCROLL-ITEM-LONGEST-DISTANCE
		 (+ (- SCROLL-ITEM-LONGEST-DISTANCE
		       (IF LAST-ITEM (SCROLL-ITEM-LINES (CAR LAST-ITEM)) 0))
		    (SCROLL-ITEM-LINES ITEM)))
	   (SETQ SCROLL-ITEM-LIST (DELQ LAST-ITEM SCROLL-ITEM-LIST))
	   (PUSH (CONS ITEM ITEM-NUMBER) SCROLL-ITEM-LIST)))
	(T
	 ;; An item, we can use it
	 (PUSH (CONS ITEM ITEM-NUMBER) SCROLL-ITEM-LIST)
	 (SETQ SCROLL-ITEM-LONGEST-DISTANCE
	       (+ SCROLL-ITEM-LONGEST-DISTANCE (SCROLL-ITEM-LINES ITEM))))))

(DEFUN SCROLL-ITEM-LINES (ITEM &AUX (SUM 1))
  (DOTIMES (I (ARRAY-LENGTH ITEM))
    (SETQ SUM (+ SUM (OR (SCROLL-ENTRY-LINES (AREF ITEM I)) 1))))
  SUM)

(DEFMETHOD (:SCROLL-RELATIVE BASIC-SCROLL-WINDOW) (FROM TO)
  (OR TOP-ITEM
      ;; Redisplay if a redisplay hasn't been done recently
      (SEND SELF ':REDISPLAY))
  ;; Convert FROM into an item number, and TO into a target top item
  (SETQ FROM (COND ((EQ FROM ':TOP) TOP-ITEM)
		   ((EQ FROM ':BOTTOM) BOTTOM-ITEM)
		   ((NUMBERP FROM)
		    ;; Number of pixels down, convert into item number
		    (SCROLL-ITEM-NUMBER-AT-Y FROM))))
  (AND (EQ TO ':BOTTOM)
       (SETQ TO (1- (* SCREEN-LINES LINE-HEIGHT))))
  (SETQ TO (IF (EQ TO ':TOP)
	       ;; Scroll to the indicated position only if there's something there
	       ;; to scroll to.
	       (IF (AND FROM (< FROM (SCROLL-TOTAL-ITEMS))) FROM)
	       ;; Find an item such that if we put it on the top, then the FROM item will be
	       ;; in the desired position.  This is an estimate only and not guaranteed to
	       ;; do exactly the right thing
	       (AND FROM (SCROLL-FIND-A-TOP-ITEM FROM (// TO LINE-HEIGHT)))))
  (IF TO
      (SEND SELF ':SCROLL-TO TO)
      (BEEP)))

(DEFMETHOD (:SCROLL-TO BASIC-SCROLL-WINDOW) (TO &OPTIONAL (TYPE ':ABSOLUTE))
  (IF (EQ CURRENT-PROCESS (MOUSE-PROCESS (SHEET-MOUSE SELF)))
      (PROCESS-RUN-FUNCTION "Scroll" SELF ':SCROLL-TO TO TYPE)
      (OR TOP-ITEM
	  ;; Redisplay if a redisplay hasn't been done recently
	  (SEND SELF ':REDISPLAY))
      (SETQ TARGET-TOP-ITEM (SELECTQ TYPE
			      (:ABSOLUTE TO)
			      ((:RELATIVE :RELATIVE-JUMP) (+ TO TOP-ITEM))
			      (OTHERWISE (FERROR "~A is an unknown type of scrolling" TYPE))))
      (AND (< TARGET-TOP-ITEM 0) (SETQ TARGET-TOP-ITEM 0))
      (SEND SELF ':REDISPLAY)))

(DEFMETHOD (:NEW-SCROLL-POSITION BASIC-SCROLL-WINDOW :AFTER) (&REST IGNORE)
  (MOUSE-WAKEUP))

(DEFFLAVOR SCROLL-WINDOW-WITH-TYPEOUT-MIXIN () ()
  (:REQUIRED-FLAVORS WINDOW-WITH-TYPEOUT-MIXIN BASIC-SCROLL-WINDOW))

(DEFMETHOD (:REDISPLAY SCROLL-WINDOW-WITH-TYPEOUT-MIXIN :BEFORE) (&REST IGNORE)
  "If the typeout window is active, deexposed it, and make sure the redisplayer knows how many
lines were clobbered."
  (COND ((SEND TYPEOUT-WINDOW ':ACTIVE-P)
	 (LET ((BR (MIN SCREEN-LINES
			(1+ (// (SEND TYPEOUT-WINDOW ':BOTTOM-REACHED) LINE-HEIGHT)))))
	   (DOTIMES (L BR)
	     ;; Mark lines as clobbered
	     (ASET NIL SCREEN-IMAGE L 0)
	     (ASET -1 SCREEN-IMAGE L 1)
	     (ASET -1 SCREEN-IMAGE L 2))
	   (SEND TYPEOUT-WINDOW ':DEACTIVATE)
	   (SEND SELF ':DRAW-RECTANGLE (SHEET-INSIDE-WIDTH) (* BR LINE-HEIGHT) 0 0 :ERASE)))))

;Allow for the typeout window to cover over the mouse-sensitive items
(DEFWRAPPER (:MOUSE-SENSITIVE-ITEM SCROLL-WINDOW-WITH-TYPEOUT-MIXIN) (IGNORE BODY)
  `(MULTIPLE-VALUE-BIND (ITEM TYPE LEFT TOP WID HEI)
       ,BODY
     (IF (AND ITEM
	      (SEND TYPEOUT-WINDOW ':ACTIVE-P)
	      (< TOP (SEND TYPEOUT-WINDOW ':BOTTOM-REACHED)))
	 NIL
	 (VALUES ITEM TYPE LEFT TOP WID HEI))))

(DEFFLAVOR SCROLL-WINDOW-WITH-TYPEOUT ()
  (SCROLL-WINDOW-WITH-TYPEOUT-MIXIN WINDOW-WITH-TYPEOUT-MIXIN SCROLL-WINDOW)
  (:DEFAULT-INIT-PLIST :TYPEOUT-WINDOW '(TYPEOUT-WINDOW 
					 :DEEXPOSED-TYPEOUT-ACTION (:EXPOSE-FOR-TYPEOUT)
					 :IO-BUFFER NIL))
  (:DOCUMENTATION :COMBINATION "A scroll window with a typeout window"))

(DEFMETHOD (:INIT SCROLL-WINDOW-WITH-TYPEOUT :AFTER) (IGNORE)
  (SEND TYPEOUT-WINDOW ':SET-IO-BUFFER IO-BUFFER))

;;; More sophisticated user interface functions
(DEFUN-IN-FLAVOR (SCROLL-GET-ITEM-LOCATIVE BASIC-SCROLL-WINDOW)
	      (POSITION &AUX (ITEM (LOCF DISPLAY-ITEM)))
  (AND (NUMBERP POSITION) (SETQ POSITION (NCONS POSITION)))
  (DOLIST (C POSITION)
    (SETQ ITEM (LOCF (NTH (1+ C) (SCROLL-ITEMS (CAR ITEM))))))
  ITEM)

(DEFMETHOD (:GET-ITEM BASIC-SCROLL-WINDOW) (POSITION)
  "Given a position in the tree, returns the specified item."
  (CAR (SCROLL-GET-ITEM-LOCATIVE POSITION)))

(DEFMETHOD (:SET-ITEM BASIC-SCROLL-WINDOW) (POSITION NEW-ITEM)
  (RPLACA (SCROLL-GET-ITEM-LOCATIVE POSITION) NEW-ITEM)
  (SEND SELF ':REDISPLAY))

(DEFMETHOD (:INSERT-ITEM BASIC-SCROLL-WINDOW) (POSITION ITEM &AUX WHERE)
  "Inserts an item before the specified position."
  (AND (NUMBERP POSITION) (SETQ POSITION (NCONS POSITION)))
  (SETQ WHERE (LOCF DISPLAY-ITEM))
  (DOLIST (P POSITION)
    (DOTIMES (IGNORE P)
      (SETQ WHERE (LOCF (CDAR WHERE)))))
  (RPLACA WHERE (CONS ITEM (CAR WHERE)))
  (SEND SELF ':REDISPLAY))

(DEFMETHOD (:DELETE-ITEM BASIC-SCROLL-WINDOW) (POSITION &AUX WHERE)
  "Deletes the item at the specified position."
  (AND (NUMBERP POSITION) (SETQ POSITION (NCONS POSITION)))
  (SETQ WHERE (LOCF DISPLAY-ITEM))
  (DOLIST (P POSITION)
    (DOTIMES (IGNORE P)
      (SETQ WHERE (LOCF (CDAR WHERE)))))
  (RPLACA WHERE (CDAR WHERE))
  (SEND SELF ':REDISPLAY))

(DEFUN SCROLL-MAKE-ENTRY (&REST ELTS)
  ;; this is fillarray, but twice as fast
  (LOOP WITH ENTRY = (MAKE-SCROLL-ENTRY)
	FOR INDEX BELOW (ARRAY-ACTIVE-LENGTH ENTRY)
	DO (SETF (AREF ENTRY INDEX) (POP ELTS))
	FINALLY (RETURN ENTRY)))

(DEFUN SCROLL-INTERPRET-ENTRY (ENTRY ITEM &AUX MOUSE)
  "Given a descriptor (see documentation) returns an entry suitable for inclusion
in an array-type item."
  ;; Canonicalize into a list
  (COND ((STRINGP ENTRY) (SETQ ENTRY (LIST ':STRING ENTRY)))
	((SYMBOLP ENTRY) (SETQ ENTRY (LIST ':SYMEVAL ENTRY)))
	((FUNCTIONP ENTRY) (SETQ ENTRY (LIST ':FUNCTION ENTRY)))
	((LISTP ENTRY)
	 ;; Use supplied list -- look for some special initial items
	 (WHEN (EQ (FIRST ENTRY) ':MOUSE)
	   (SETQ MOUSE (SECOND ENTRY)
		 ENTRY (CDDR ENTRY)))
	 (WHEN (EQ (FIRST ENTRY) ':MOUSE-ITEM)
	   (SETQ MOUSE (SUBLIS `((ITEM . ,ITEM)) (CADR ENTRY))
		 ENTRY (CDDR ENTRY)))
	 ;; convert :value and :function-item into :function
	 (SELECTQ (FIRST ENTRY)
	   (:VALUE
	    (SETQ ENTRY `(:FUNCTION ,#'VALUE (,(SECOND ENTRY)) . ,(CDDR ENTRY))))
	   (:FUNCTION-ITEM
	    (SETQ ENTRY `(:FUNCTION . ,(SUBLIS `((ITEM . ,ITEM)) (CDR ENTRY)))))))
	(T (FERROR NIL "Unknown kind of entry: ~S" ENTRY)))
  ;; Convert the list entry into a scroll entry
  (SETQ ENTRY
	(SELECTQ (FIRST ENTRY)
	  (:STRING (SCROLL-MAKE-ENTRY 'SCROLL-ENTRY-CONSTANT-STRING-FUNCTION NIL NIL 0 0 0
				      (OR (THIRD ENTRY) (STRING-LENGTH (SECOND ENTRY)))
				      NIL (SECOND ENTRY) NIL NIL NIL))
	  (:SYMEVAL (SCROLL-MAKE-ENTRY 'SCROLL-ENTRY-SYMBOL-VALUE-FUNCTION
				       (SECOND ENTRY) NIL
				       0 0 0 (OR (THIRD ENTRY) 0) (NULL (THIRD ENTRY))
				       (NCONS NIL) NIL (FOURTH ENTRY) NIL))
	  (:FUNCTION (SCROLL-MAKE-ENTRY 'SCROLL-ENTRY-CALL-FUNCTION-FUNCTION
					(SECOND ENTRY) (THIRD ENTRY)
					0 0 0 (OR (FOURTH ENTRY) 0) (NULL (FOURTH ENTRY))
					(NCONS NIL) NIL (FIFTH ENTRY) NIL))))
  (WHEN MOUSE
     (SETF (SCROLL-ENTRY-MOUSE-INFO ENTRY) MOUSE))
  ENTRY)

(DEFUN SCROLL-PARSE-ITEM (&REST ITEM-SPEC &AUX ITEM (EXTRA-LEADER 0) LEADER-FILL
				               MOUSE MOUSE-SELF)
  "Given a list of entry descriptors, produce an array-type item."
  ;; first get rid of leading NILs
  (WHEN ITEM-SPEC
    (LOOP UNTIL (CAR ITEM-SPEC) DO (SETQ ITEM-SPEC (CDR ITEM-SPEC))))
  (DO ((L ITEM-SPEC (CDDR L)))
      ((OR (NOT (SYMBOLP (CAR L)))
	   (NULL (CAR L)))
       (SETQ ITEM-SPEC L))
    (SELECTQ (CAR L)
      (:MOUSE (SETQ MOUSE (CADR L)))
      (:MOUSE-SELF (SETQ MOUSE-SELF T MOUSE (CADR L)))
      (:LEADER (SETQ EXTRA-LEADER
		     (IF (NUMBERP (CADR L))
			 (CADR L)
		         (LENGTH (SETQ LEADER-FILL (CADR L))))))
      (OTHERWISE (FERROR NIL "~A is unknown keyword to SCROLL-PARSE-ITEM" (CAR L)))))
  ;; collect only non-NIL items
  (SETQ ITEM (MAKE-ARRAY (LOOP FOR SPEC IN ITEM-SPEC COUNT SPEC)
			 ':LEADER-LENGTH (+ SCROLL-ITEM-LEADER-OFFSET EXTRA-LEADER)))
  (AND MOUSE-SELF (SETQ MOUSE (SUBLIS `((SELF . ,ITEM)) MOUSE)))
  (AND LEADER-FILL
       (DOTIMES (I EXTRA-LEADER)
	 (SETF (ARRAY-LEADER ITEM (+ SCROLL-ITEM-LEADER-OFFSET I)) (NTH I LEADER-FILL))))
  (SETF (SCROLL-ITEM-LINE-SENSITIVITY ITEM) MOUSE)
  (LOOP WITH ITEM-INDEX = 0
	FOR SPEC IN ITEM-SPEC
	WHEN SPEC
	  DO (SETF (AREF ITEM ITEM-INDEX)
		   (SCROLL-INTERPRET-ENTRY SPEC ITEM))
	     (INCF ITEM-INDEX))
  ITEM)

(DEFUN SCROLL-STRING-ITEM-WITH-EMBEDDED-NEWLINES (STRING &AUX STRINGS ITEM)
  (DO ((NEXT (STRING-SEARCH-CHAR #\CR STRING)
	     (STRING-SEARCH-CHAR #\CR STRING (1+ NEXT)))
       (ONEXT 0 (1+ NEXT)))
      ((NULL NEXT)
       (AND (< ONEXT (STRING-LENGTH STRING))
	    (PUSH (NSUBSTRING STRING ONEXT) STRINGS)))
    (PUSH (NSUBSTRING STRING ONEXT NEXT) STRINGS))
  (DOLIST (STRING STRINGS)
    (PUSH (SCROLL-PARSE-ITEM STRING) ITEM))
  (LIST* () ITEM))

(DEFUN SCROLL-MAINTAIN-LIST-UNORDERED (INIT-FUN ITEM-FUN &OPTIONAL PER-ELT-FUN STEPPER)
  "Given a function that returns a list, and a function that returns an item spec
when given an element of that list, maintains one item for each element in the list.
This is not useful when recursion is necessary.  Returns an item that should be
inserted somewhere.  The LIST-FUN should return a private copy of the list."
  (LIST (LIST ':PRE-PROCESS-FUNCTION 'SCROLL-MAINTAIN-LIST-UNORDERED-UPDATE-FUNCTION
	      ':FUNCTION PER-ELT-FUN
	      ':INIT-FUNCTION INIT-FUN
	      ':ITEM-FUNCTION ITEM-FUN
	      ':OLD-STATE NIL
	      ':STEPPER-FUNCTION (OR STEPPER #'SCROLL-MAINTAIN-LIST-STEPPER))))


(DEFUNP SCROLL-MAINTAIN-LIST-STEPPER (STATE)
  (RETURN (VALUES (CAR STATE) (CDR STATE) (NULL (CDR STATE)))))

(DEFSTRUCT (STATE :LIST (:CONSTRUCTOR NIL))
  STATE-VALUE
  STATE-FLAG
  STATE-ITEM)

(DEFUN SCROLL-MAINTAIN-LIST-UNORDERED-UPDATE-FUNCTION (ITEM
						       &AUX (FLAGS-PLIST (LOCF (CAR ITEM))))
  (LET ((STEP-STATE (FUNCALL (GET FLAGS-PLIST ':INIT-FUNCTION)))
	(OLD-STATE (GET FLAGS-PLIST ':OLD-STATE))
	(ITEM-FUN (GET FLAGS-PLIST ':ITEM-FUNCTION))
	(STEPPER (GET FLAGS-PLIST ':STEPPER-FUNCTION)))
    ;; Clear out remembered state
    (DOLIST (E OLD-STATE)
      (SETF (STATE-FLAG E) NIL))
    ;; Loop over all items.  If one is found that doesn't exist, add it and
    ;; remember that.  Any that no longer exist need to be flushed.
    (DO ((CURRENT)
	 (LAST)
	 (STATE))
	((OR (NULL STEP-STATE) LAST))
      (MULTIPLE-VALUE (CURRENT STEP-STATE LAST) (FUNCALL STEPPER STEP-STATE))
      (IF (SETQ STATE (ASSQ CURRENT OLD-STATE))
	  (SETF (STATE-FLAG STATE) T)
	  ;; Doesn't exist.  Add it to the front of the list and add in the item
	  (LET ((NEW-ITEM (FUNCALL ITEM-FUN CURRENT)))
	    (PUSH (LIST CURRENT T NEW-ITEM) OLD-STATE)
	    (PUSH NEW-ITEM (SCROLL-ITEMS ITEM)))))
    (DOLIST (STATE OLD-STATE)
      ;; Delete all items that are no longer valid
      (COND ((NOT (STATE-FLAG STATE))
	     (SETF (SCROLL-ITEMS ITEM) (DELQ (STATE-ITEM STATE) (SCROLL-ITEMS ITEM)))
	     (SETQ OLD-STATE (DELQ STATE OLD-STATE)))))
    ;; ITEM and OLD-STATE have been updated.  Store back appropriate info.
    (PUTPROP FLAGS-PLIST OLD-STATE ':OLD-STATE)
    ITEM))

(DEFUN SCROLL-MAINTAIN-LIST (INIT-FUN ITEM-FUN
			     &OPTIONAL PER-ELT-FUN STEPPER COMPACT-P PRE-PROC-FUN
			     &REST INIT-ARGS)
									     
  "Given a function that returns a list, and a function that returns an item spec
when given an element of that list, maintains one item for each element in the list.
This is not useful when recursion is necessary.  Returns an item that should be
inserted somewhere.  The LIST-FUN should return a private copy of the list."
  (LIST (LIST ':PRE-PROCESS-FUNCTION (OR PRE-PROC-FUN 'SCROLL-MAINTAIN-LIST-UPDATE-FUNCTION)
	      ':FUNCTION PER-ELT-FUN
	      ':INIT-FUNCTION INIT-FUN
	      ':INIT-ARGS (COPYLIST INIT-ARGS)
	      ':ITEM-FUNCTION ITEM-FUN
	      ':OLD-STATE NIL
	      ':COMPACT-P COMPACT-P
	      ':STEPPER-FUNCTION (OR STEPPER #'SCROLL-MAINTAIN-LIST-STEPPER))))

(DEFVAR SCROLL-LIST-AREA (MAKE-AREA ':NAME 'SCROLL-LIST-AREA))

(DEFUN SCROLL-MAINTAIN-LIST-UPDATE-FUNCTION (ITEM &AUX (FLAGS-PLIST (LOCF (CAR ITEM))))
  (LET* ((STEP-STATE (LEXPR-FUNCALL (GET FLAGS-PLIST ':INIT-FUNCTION)
				    (GET FLAGS-PLIST ':INIT-ARGS)))
	 (OLD-STATE (LOCF (GET FLAGS-PLIST ':OLD-STATE)))
	 (ITEM-FUN (GET FLAGS-PLIST ':ITEM-FUNCTION))
	 (STEPPER (GET FLAGS-PLIST ':STEPPER-FUNCTION))
	 (COMPACT-P (GET FLAGS-PLIST ':COMPACT-P))
	 (ITEMS (LOCF (SCROLL-ITEMS ITEM))))
    ;; Loop over all items.  If one is found that doesn't exist, add it and
    ;; remember that.  Any that no longer exist need to be flushed.
    (DO ((CURRENT)
	 (NEEDS-COMPACTION NIL)
	 (LAST (NULL STEP-STATE))
	 (PREV-ITEM ITEMS)
	 (PREV-STATE OLD-STATE))
	(LAST
	  (RPLACD PREV-STATE NIL)
	  (RPLACD PREV-ITEM NIL)
	  (COND ((AND COMPACT-P NEEDS-COMPACTION)
		 (SETF (SCROLL-ITEMS ITEM) (COPYLIST (SCROLL-ITEMS ITEM) SCROLL-LIST-AREA))
		 (SETF (GET FLAGS-PLIST ':OLD-STATE)
		       (COPYLIST (GET FLAGS-PLIST ':OLD-STATE) SCROLL-LIST-AREA)))))
      (SETQ ITEMS (CDR ITEMS)
	    OLD-STATE (CDR OLD-STATE))
      (MULTIPLE-VALUE (CURRENT STEP-STATE LAST) (FUNCALL STEPPER STEP-STATE))
      (COND ((EQ (CAR OLD-STATE) CURRENT)
	     ;; No change, ok then
	     )
	    ((MEMQ CURRENT OLD-STATE)
	     ;; Is later on list, therefore must have deleted some things
	     (SETQ NEEDS-COMPACTION T)
	     (DO ()
		 ((EQ (CAR OLD-STATE) CURRENT))
	       (RPLACD PREV-STATE (SETQ OLD-STATE (CDR OLD-STATE)))
	       (RPLACD PREV-ITEM (SETQ ITEMS (CDR ITEMS)))))
	    (T
	     (SETQ NEEDS-COMPACTION T)
	     (RPLACD PREV-STATE (SETQ OLD-STATE (CONS-IN-AREA CURRENT (CDR PREV-STATE)
							      SCROLL-LIST-AREA)))
	     (RPLACD PREV-ITEM (SETQ ITEMS
				     (CONS-IN-AREA (FUNCALL ITEM-FUN CURRENT)
						   (CDR PREV-ITEM) SCROLL-LIST-AREA)))))
      
      (AND OLD-STATE (SETQ PREV-STATE OLD-STATE))
      (AND ITEMS (SETQ PREV-ITEM ITEMS)))
    ITEM))

(DEFUN SCROLL-MAINTAIN-LIST-UPDATE-STATES (STATES WINDOW
					   &OPTIONAL (DITEM (SEND WINDOW ':DISPLAY-ITEM)))
  (LET* ((FLAGS-PLIST (LOCF (FIRST DITEM)))
	 (OLD-STATE (GET FLAGS-PLIST ':OLD-STATE))
	 (ITEMS (SCROLL-ITEMS DITEM))
	 (ITEMS-TO-BE-REDISPLAYED NIL))
    (WHEN (MEMQ OLD-STATE STATES)
      (PUSH ITEMS ITEMS-TO-BE-REDISPLAYED))
    (DOLIST (STATE OLD-STATE)
      (WHEN (MEMQ STATE STATES)
	(PUSH (FIRST ITEMS) ITEMS-TO-BE-REDISPLAYED))
      (POP ITEMS))
    (SEND WINDOW ':REDISPLAY-SELECTED-ITEMS ITEMS-TO-BE-REDISPLAYED)))

;;; Mouse-menu stuff
(DEFFLAVOR ESSENTIAL-SCROLL-MOUSE-MIXIN
	((ITEM-LIST NIL) (TYPE-ALIST) (ITEM-BLINKER NIL) (CURRENT-ITEM NIL))
	()
  (:INITABLE-INSTANCE-VARIABLES TYPE-ALIST ITEM-BLINKER)
  :GETTABLE-INSTANCE-VARIABLES
  (:SETTABLE-INSTANCE-VARIABLES ITEM-LIST TYPE-ALIST ITEM-BLINKER)
  (:REQUIRED-FLAVORS BASIC-SCROLL-WINDOW SHEET))

(DEFFLAVOR SCROLL-MOUSE-MIXIN () (ESSENTIAL-SCROLL-MOUSE-MIXIN MENU-EXECUTE-MIXIN)
  (:DOCUMENTATION :MIXIN "Menu like scroll windows"))

(DEFMETHOD (:INIT ESSENTIAL-SCROLL-MOUSE-MIXIN :AFTER) (IGNORE)
  (SETQ ITEM-BLINKER (LEXPR-FUNCALL #'MAKE-BLINKER SELF
				    (OR (CAR ITEM-BLINKER) 'HOLLOW-RECTANGULAR-BLINKER)
				    ':VISIBILITY NIL
				    (CDR ITEM-BLINKER))))

(DEFMETHOD (:HANDLE-MOUSE ESSENTIAL-SCROLL-MOUSE-MIXIN :AFTER) ()
  (BLINKER-SET-VISIBILITY ITEM-BLINKER NIL)
  (SETQ CURRENT-ITEM NIL))

(DEFSTRUCT (SCROLL-MOUSE-ITEM :LIST (:CONSTRUCTOR NIL))
  SCROLL-MOUSE-ITEM-ITEM
  SCROLL-MOUSE-ITEM-TYPE
  SCROLL-MOUSE-ITEM-LEFT
  SCROLL-MOUSE-ITEM-REL-TOP
  SCROLL-MOUSE-ITEM-WIDTH
  SCROLL-MOUSE-ITEM-HEIGHT)

(DEFUN-IN-FLAVOR (SCROLL-FIND-SENSITIVE-ITEM ESSENTIAL-SCROLL-MOUSE-MIXIN) (X Y)
  ;; First check for the mouse pointing at something in the item list (things here
  ;; may override items as specified in the data structure itself)
  (PROG HAVE-ITEM ()
    (COND ((AND ( Y (SHEET-INSIDE-TOP))
		(< Y (+ (SHEET-INSIDE-TOP) (* SCREEN-LINES LINE-HEIGHT)))
		( X (SHEET-INSIDE-LEFT))
		(< X (SHEET-INSIDE-RIGHT)))
	   (LET ((LINE-OF-INTEREST (SHEET-LINE-NO NIL Y))
		 (MOUSE-INFO) (LINE-ITEM) (LINE) (ENTRY) (START-X (SHEET-INSIDE-LEFT))
		 (REL-Y) (FIRST-LINE))
	     (SETQ LINE-ITEM (AREF SCREEN-IMAGE LINE-OF-INTEREST 0))
	     (OR LINE-ITEM (RETURN-FROM HAVE-ITEM NIL))
	     (SETQ FIRST-LINE
		   (SETQ LINE (- LINE-OF-INTEREST (AREF SCREEN-IMAGE LINE-OF-INTEREST 1))))

	     ;; First check explicitly set up mouse items
	     (SETQ REL-Y (- Y (* LINE LINE-HEIGHT)))
	     (DOLIST (I (SCROLL-ITEM-MOUSE-ITEMS LINE-ITEM))
	       (AND ( REL-Y (SCROLL-MOUSE-ITEM-REL-TOP I))
		    (< REL-Y (+ (SCROLL-MOUSE-ITEM-REL-TOP I) (SCROLL-MOUSE-ITEM-HEIGHT I)))
		    ( X (SETQ START-X (SCROLL-MOUSE-ITEM-LEFT I)))
		    (< X (+ (SCROLL-MOUSE-ITEM-LEFT I) (SCROLL-MOUSE-ITEM-WIDTH I)))
		    (RETURN-FROM HAVE-ITEM
		      (VALUES
			(SCROLL-MOUSE-ITEM-ITEM I) (SCROLL-MOUSE-ITEM-TYPE I)
			START-X (+ (* LINE LINE-HEIGHT) (SCROLL-MOUSE-ITEM-REL-TOP I))
			(SCROLL-MOUSE-ITEM-WIDTH I) (SCROLL-MOUSE-ITEM-HEIGHT I)))))

	     ;; Didn't find an explicit item, check for one in the regular data structure
	     (DOTIMES (I (ARRAY-LENGTH LINE-ITEM))
	       (SETQ ENTRY (AREF LINE-ITEM I))
	       (COND ((> LINE LINE-OF-INTEREST)
		      (RETURN NIL))
		     ((< LINE LINE-OF-INTEREST)
		      (SETQ LINE (+ LINE (SCROLL-ENTRY-LINES ENTRY))))
		     ((OR (NULL (SCROLL-ENTRY-MOUSE-INFO ENTRY))
			  ( (IF (> (SCROLL-ENTRY-LINES ENTRY) 0)
				 (SHEET-INSIDE-RIGHT)
				 (SCROLL-ENTRY-FINAL-PRINTING-X ENTRY))
			     X))
		      (SETQ LINE (+ LINE (SCROLL-ENTRY-LINES ENTRY))
			    START-X (SCROLL-ENTRY-FINAL-X ENTRY)))
		     ((> START-X X)
		      (RETURN NIL))
		     (T
		      (RETURN-FROM HAVE-ITEM
			(VALUES
			  (SETQ MOUSE-INFO (SCROLL-ENTRY-MOUSE-INFO ENTRY)) (FIRST MOUSE-INFO)
			  START-X (+ (SHEET-INSIDE-TOP) (* LINE-OF-INTEREST LINE-HEIGHT))
			  (IF (> (SCROLL-ENTRY-LINES ENTRY) 0)
			      (- (SHEET-INSIDE-RIGHT) START-X)
			      (- (SCROLL-ENTRY-FINAL-PRINTING-X ENTRY) START-X))
			  LINE-HEIGHT)))))

	     ;; No item is sensitive, perhaps the whole item (line) is sensitive
	     (COND ((SETQ MOUSE-INFO (SCROLL-ITEM-LINE-SENSITIVITY LINE-ITEM))
		    (RETURN-FROM HAVE-ITEM
		      (VALUES
			MOUSE-INFO (FIRST MOUSE-INFO)
			(SHEET-INSIDE-LEFT) (+ (* FIRST-LINE LINE-HEIGHT) (SHEET-INSIDE-TOP))
			(SHEET-INSIDE-WIDTH)
			(DO ((I (1+ FIRST-LINE) (1+ I)))
			    ((OR ( I SCREEN-LINES) (NEQ LINE-ITEM (AREF SCREEN-IMAGE I 0)))
			     (* LINE-HEIGHT (- I FIRST-LINE)))))))))))))

(DEFMETHOD (:MOUSE-SENSITIVE-ITEM ESSENTIAL-SCROLL-MOUSE-MIXIN) (X Y)
  (SCROLL-FIND-SENSITIVE-ITEM X Y))

(DEFMETHOD (:MOUSE-MOVES ESSENTIAL-SCROLL-MOUSE-MIXIN) (X Y)
  (MOUSE-SET-BLINKER-CURSORPOS SELF)
  (MULTIPLE-VALUE-BIND (ITEM NIL LEFT TOP WID HEI)
      (SEND SELF ':MOUSE-SENSITIVE-ITEM X Y)
    (AND TOP (SETQ TOP (1- TOP)))
    (COND (ITEM
	   (BLINKER-SET-CURSORPOS ITEM-BLINKER (- LEFT (SHEET-INSIDE-LEFT))
				  (- TOP (SHEET-INSIDE-TOP)))
	   (BLINKER-SET-SIZE ITEM-BLINKER WID HEI)
	   (BLINKER-SET-VISIBILITY ITEM-BLINKER T)
	   (SETQ CURRENT-ITEM ITEM))
	  (T
	   (BLINKER-SET-VISIBILITY ITEM-BLINKER NIL)
	   (SETQ CURRENT-ITEM NIL)))))

(DEFMETHOD (:MOUSE-CLICK ESSENTIAL-SCROLL-MOUSE-MIXIN) (BUTTON X Y &AUX ITEM TYPE OP)
  (COND ((ZEROP (CHAR-MOUSE-BITS BUTTON))
	 (MULTIPLE-VALUE (ITEM TYPE)
	   (SEND SELF ':MOUSE-SENSITIVE-ITEM X Y))
	 (COND ((NULL ITEM)
		(PROCESS-RUN-FUNCTION "Mouse select" #'MOUSE-SELECT SELF))
	       ((OR (NULL TYPE)
		    (SETQ OP (FIRST (CDR (ASSQ TYPE TYPE-ALIST)))))

		;;psych out :BUTTONS --- Copy of code in (BASIC-MENU :MOUSE-BUTTONS)
		(COND ((AND (LISTP ITEM)
			    ( (LENGTH ITEM) 3)
			    (EQ (SECOND ITEM) ':BUTTONS))
		       (SETQ ITEM (NTH (CHAR-MOUSE-BUTTON BUTTON) (THIRD ITEM)))))

		(BLINKER-SET-VISIBILITY ITEM-BLINKER NIL)
		(LET ((*SCROLL-WINDOW* SELF))
		  (SEND SELF :EXECUTE (IF OP
					  (LIST* NIL OP ITEM)
					  ITEM))))
	       (T
		(SEND SELF ':FORCE-KBD-INPUT (LIST TYPE ITEM SELF BUTTON))))
	 T)))

(DEFMETHOD (:WHO-LINE-DOCUMENTATION-STRING ESSENTIAL-SCROLL-MOUSE-MIXIN) ()
  (AND (LISTP CURRENT-ITEM) (LISTP (CDR CURRENT-ITEM))
       (GET (CDDR CURRENT-ITEM) ':DOCUMENTATION)))

(DEFFLAVOR SCROLL-WINDOW-WITH-DYNAMIC-TYPEOUT ()
	   (DW:MARGIN-MIXIN			;Needs to check mouse first.
	    SCROLL-MOUSE-MIXIN SCROLL-WINDOW-WITH-TYPEOUT-MIXIN WINDOW-WITH-TYPEOUT-MIXIN
	    BASIC-SCROLL-WINDOW
	    STREAM-MIXIN SELECT-MIXIN GRAPHICS-MIXIN MINIMUM-WINDOW)
  (:DEFAULT-INIT-PLIST :TYPEOUT-WINDOW '(DW::DYNAMIC-TYPEOUT-WINDOW
					 :DEEXPOSED-TYPEOUT-ACTION (:EXPOSE-FOR-TYPEOUT)
					 :IO-BUFFER NIL)
		       :MARGIN-COMPONENTS `DW:((MARGIN-BORDERS :THICKNESS 1)
					       (MARGIN-SCROLL-BAR )
					       (MARGIN-WHITE-BORDERS :THICKNESS 2)
					       )))

;;; Comes from SCROLL-WINDOW-WITH-TYPEOUT
(DEFMETHOD (:INIT SCROLL-WINDOW-WITH-DYNAMIC-TYPEOUT :AFTER) (IGNORE)
  (SEND TYPEOUT-WINDOW ':SET-IO-BUFFER IO-BUFFER))

(DEFMETHOD (:RAGGED-BORDERS-P SCROLL-WINDOW-WITH-DYNAMIC-TYPEOUT) ()
  (VALUES NIL (AND TOP-ITEM (PLUSP TOP-ITEM))
	  NIL (AND TOP-ITEM (< BOTTOM-ITEM (SCROLL-TOTAL-ITEMS)))))
