;;; -*- Mode:LISP; Package:TV; Base:8 -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;; Lisp Machine Mouse Handler

;;; These variables are low-level and more or less private to this file
;;; The higher-level variables that have to do with the mouse are declared
;;; in TVDEFS.

					;If one or more of these keys is pressed, turn a
					;single mouse-click into a double mouse-click.
(DEFVAR *MOUSE-INCREMENTING-KEYSTATES* '(:SHIFT))
					;If one or more of these keys is pressed, set
					;the corresponding modifier bit in the mouse
					;character.  If a key appears in both this and
					;the preceding list, it has both effects.
(DEFVAR *MOUSE-MODIFYING-KEYSTATES* '(:CONTROL :META :SUPER :HYPER))
(DEFCONST MOUSE-BOUNCE-TIME 2000.)	;Delay for bounce elimination

					;Delay for user to push button again, in microseconds
					;Set this to NIL to disable the feature entirely
(DEFCONST MOUSE-DOUBLE-CLICK-TIME 200000.)

(DEFVAR *MOUSE-LOW-PRIORITY-TIME* 100000.)		;1/10 second

(DEFCONST FIREWALL:*SYSTEM-MENU-ENABLED* T);Global control of system menu.

(CL:PROCLAIM '(SPECIAL FONTS:MOUSE))	;New 1980's mouse characters

(DEFVAR MOUSE-LAST-X 0)			;Last value of MOUSE-X to compute deltas
(DEFVAR MOUSE-LAST-Y 0)			;Last value of MOUSE-Y to compute deltas
(DEFVAR MOUSE-LAST-BUTTONS 0)		;To compute change in buttons
(DEFVAR MOUSE-LAST-BUTTONS-TIME)	;Associated fixnum-microsecond-time
(DEFVAR MOUSE-LAST-BUTTONS-X)		;Associated mouse position
(DEFVAR MOUSE-LAST-BUTTONS-Y)
(DEFVAR MOUSE-BUTTONS-IN-PROGRESS NIL)	;If non-NIL, is next state for buttons to enter



;(DEFVAR MOUSE-RECONSIDER)		;T => mouse process should return to overseer
					;and decide anew which window should get the mouse.
					;For use by :MOUSE-MOVES methods, etc.
					;Declared in TVDEFS
(DEFVAR MOUSE-CURSOR-CLOSED-STATE 1)	;1 if cursor not being drawn by microcode,
					;2 if it is

(DEFVAR MOUSE-MAYBE-WAKEUP-TIME NIL)    ;if non-nil, what time in 60'ths to wake up.

;+++
(DEFVAR MAIN-MOUSE NIL)

(DEFUN SHEET-MOUSE (SHEET)
  (LET ((CONSOLE (SHEET-CONSOLE SHEET)))
    (AND CONSOLE (CONSOLE-MOUSE CONSOLE))))

(DEFFLAVOR BASIC-MOUSE (CONSOLE) ()
  :ABSTRACT-FLAVOR
  (:CONC-NAME "MOUSE-")
  (:INITABLE-INSTANCE-VARIABLES CONSOLE)
  (:WRITABLE-INSTANCE-VARIABLES CONSOLE))

(DEFFLAVOR LOCAL-MOUSE-MIXIN (WIRED-MOUSE (FAST-TRACK-P T)(SCREEN)) ()
  :ABSTRACT-FLAVOR
  (:CONC-NAME "MOUSE-")
  (:READABLE-INSTANCE-VARIABLES WIRED-MOUSE)
  (:REQUIRED-FLAVORS BASIC-MOUSE))

(DEFFLAVOR PRIMARY-MOUSE-MIXIN () ()
  :ABSTRACT-FLAVOR
  (:REQUIRED-FLAVORS BASIC-MOUSE))

(DEFFLAVOR SECONDARY-MOUSE-MIXIN () ()
  :ABSTRACT-FLAVOR
  (:REQUIRED-FLAVORS BASIC-MOUSE))

(DEFMACRO DEFINE-MOUSE-STATE-VARIABLES (&BODY VARS)
  `(PROGN
     (DEFFLAVOR NONLOCAL-MOUSE-MIXIN
	     (,@(LOOP FOR (NIL IVAR DEFAULT . KEYS) IN VARS
		      WHEN (AND (CL:GETF KEYS :WIRED)
				(NOT (CL:GETF KEYS :LOCAL)))
			COLLECT `(,IVAR ,DEFAULT)))
	     ()
       :ABSTRACT-FLAVOR
       (:WRITABLE-INSTANCE-VARIABLES
	,@(LOOP FOR (FUNCTION IVAR NIL . KEYS) IN VARS
		WHEN (AND (CL:GETF KEYS :WIRED)
			  (NOT (CL:GETF KEYS :LOCAL)))
		  COLLECT `(,FUNCTION ,IVAR)))
       (:REQUIRED-FLAVORS BASIC-MOUSE))
     (DEFFLAVOR SECONDARY-LOCAL-MOUSE-MIXIN
	     (,@(LOOP FOR (NIL IVAR DEFAULT . KEYS) IN VARS
			  WHEN (NOT (CL:GETF KEYS :WIRED))
			COLLECT `(,IVAR ,DEFAULT)))
	     (SECONDARY-MOUSE-MIXIN LOCAL-MOUSE-MIXIN)
       :ABSTRACT-FLAVOR
       (:WRITABLE-INSTANCE-VARIABLES
	,@(LOOP FOR (FUNCTION IVAR NIL . KEYS) IN VARS
		    WHEN (NOT (CL:GETF KEYS :WIRED))
		  COLLECT `(,FUNCTION ,IVAR))))
     (DEFFLAVOR SECONDARY-NONLOCAL-MOUSE-MIXIN
	     (,@(LOOP FOR (NIL IVAR DEFAULT . KEYS) IN VARS
			  WHEN (NOT (CL:GETF KEYS :LOCAL))
			COLLECT `(,IVAR ,DEFAULT)))
	     (SECONDARY-MOUSE-MIXIN NONLOCAL-MOUSE-MIXIN)
       :ABSTRACT-FLAVOR
       (:WRITABLE-INSTANCE-VARIABLES
	,@(LOOP FOR (FUNCTION IVAR NIL . KEYS) IN VARS
		    WHEN (NOT (CL:GETF KEYS :LOCAL))
		  COLLECT `(,FUNCTION ,IVAR))))
     ;; Forward wired parts into wired handler.
     ,@(LOOP FOR (FUNCTION IVAR NIL . KEYS) IN VARS
	     WHEN (CL:GETF KEYS :WIRED)
	       COLLECT (LET ((WIRED-NAME (INTERN (STRING-APPEND "WIRED-MOUSE-" IVAR) "SI")))
			 `(PROGN
			    (DEFMETHOD (,FUNCTION LOCAL-MOUSE-MIXIN) ()
			      (,WIRED-NAME WIRED-MOUSE))
			    (DEFMETHOD ((CL:SETF ,FUNCTION) LOCAL-MOUSE-MIXIN) (NEW-VALUE)
			      (SETF (,WIRED-NAME WIRED-MOUSE) NEW-VALUE)))))
     ;; Forward unwired parts of primary mouse to special variables.
     ,@(LOOP FOR (FUNCTION NIL NIL . KEYS) IN VARS
	     FOR VAR = (CL:GETF KEYS :SPECVAR)
	     WHEN (NOT (NULL VAR))
	       COLLECT `(PROGN
			  (DEFMETHOD (,FUNCTION PRIMARY-MOUSE-MIXIN) ()
			    (COMPILER:INHIBIT-STYLE-WARNINGS
			      ,VAR))
			  (DEFMETHOD ((CL:SETF ,FUNCTION) PRIMARY-MOUSE-MIXIN) (NEW-VALUE)
			    (COMPILER:INHIBIT-STYLE-WARNINGS
			      (SETF ,VAR NEW-VALUE)))))
     (DEFCONST *MAIN-MOUSE-COMPATIBILITY-VARIABLES*
	       ',(LOOP FOR (FUNCTION VAR) IN VARS
		       WHEN (NOT (NULL VAR))
			 COLLECT (LIST VAR FUNCTION)))
     ))

(DEFINE-MOUSE-STATE-VARIABLES
  (MOUSE-FEP-X FEP-X 0 :SPECVAR FEP-MOUSE-X :LOCAL T :WIRED T)
  (MOUSE-FEP-Y FEP-Y 0 :SPECVAR FEP-MOUSE-Y :LOCAL T :WIRED T)
  (MOUSE-BLINKER BLINKER NIL :SPECVAR MOUSE-BLINKER)
  (MOUSE-BLINKER-NAME BLINKER-NAME NIL :SPECVAR MOUSE-BLINKER-NAME)
  (MOUSE-BUTTONS-INTERNAL BUTTONS 0 :SPECVAR MOUSE-BUTTONS :WIRED T)
  (MOUSE-BUTTONS-BUFFER BUTTONS-BUFFER (MAKE-ARRAY 40)
			:SPECVAR MOUSE-BUTTONS-BUFFER :WIRED T)
  (MOUSE-BUTTONS-BUFFER-IN-INDEX BUTTONS-BUFFER-IN-INDEX 0
				 :SPECVAR MOUSE-BUTTONS-BUFFER-IN-INDEX :WIRED T)
  (MOUSE-BUTTONS-BUFFER-OUT-INDEX BUTTONS-BUFFER-OUT-INDEX 0
				  :SPECVAR MOUSE-BUTTONS-BUFFER-OUT-INDEX :WIRED T)
  (MOUSE-BUTTONS-GRABBED BUTTONS-GRABBED NIL :SPECVAR MOUSE-BUTTONS-GRABBED)
  (MOUSE-BUTTONS-IN-PROGRESS BUTTONS-IN-PROGRESS NIL :SPECVAR MOUSE-BUTTONS-IN-PROGRESS)
  (MOUSE-CURSOR-CLOSED-STATE CURSOR-CLOSED-STATE 1 :SPECVAR MOUSE-CURSOR-CLOSED-STATE :LOCAL T)
  (MOUSE-CURSOR-WIDTH CURSOR-WIDTH 0 :SPECVAR MOUSE-CURSOR-WIDTH :WIRED T :LOCAL T)
  (MOUSE-CURSOR-HEIGHT CURSOR-HEIGHT 0 :SPECVAR MOUSE-CURSOR-HEIGHT :WIRED T :LOCAL T)
  (MOUSE-CURSOR-PATTERN CURSOR-PATTERN NIL :SPECVAR MOUSE-CURSOR-PATTERN :WIRED T :LOCAL T)
  (MOUSE-CURSOR-STATE CURSOR-STATE 0 :SPECVAR MOUSE-CURSOR-STATE :WIRED T :LOCAL T)
  (MOUSE-CURSOR-X-OFFSET CURSOR-X-OFFSET 0 :SPECVAR MOUSE-CURSOR-X-OFFSET :WIRED T :LOCAL T)
  (MOUSE-CURSOR-Y-OFFSET CURSOR-Y-OFFSET 0 :SPECVAR MOUSE-CURSOR-Y-OFFSET :WIRED T :LOCAL T)
  (MOUSE-LAST-BUTTONS LAST-BUTTONS 0 :SPECVAR MOUSE-LAST-BUTTONS)
  (MOUSE-LAST-BUTTONS-TIME LAST-BUTTONS-TIME 0 :SPECVAR MOUSE-LAST-BUTTONS-TIME)
  (MOUSE-LAST-BUTTONS-X LAST-BUTTONS-X 0 :SPECVAR MOUSE-LAST-BUTTONS-X)
  (MOUSE-LAST-BUTTONS-Y LAST-BUTTONS-Y 0 :SPECVAR MOUSE-LAST-BUTTONS-Y)
  (MOUSE-LAST-X LAST-X 0 :SPECVAR MOUSE-LAST-X)
  (MOUSE-LAST-Y LAST-Y 0 :SPECVAR MOUSE-LAST-Y)
  (MOUSE-MAYBE-WAKEUP-TIME MAYBE-WAKEUP-TIME NIL :SPECVAR MOUSE-MAYBE-WAKEUP-TIME)
  (MOUSE-PROCESS PROCESS NIL :SPECVAR MOUSE-PROCESS :WIRED T)
  (MOUSE-USURPED-PROCESS USURPED-PROCESS NIL :SPECVAR MOUSE-USURPED-PROCESS :WIRED T)
  (MOUSE-RECONSIDER RECONSIDER NIL :SPECVAR MOUSE-RECONSIDER)
  (MOUSE-SHEET SHEET NIL :SPECVAR MOUSE-SHEET)
  (MOUSE-WAKEUP-INTERNAL WAKEUP NIL :SPECVAR MOUSE-WAKEUP :WIRED T)
  (MOUSE-WARP-INTERNAL WARP NIL :SPECVAR MOUSE-WARP)
  (MOUSE-WINDOW WINDOW NIL :SPECVAR MOUSE-WINDOW)
  (WINDOW-OWNING-MOUSE-INTERNAL OWNING-WINDOW NIL :SPECVAR WINDOW-OWNING-MOUSE)
  (MOUSE-X X-POSITION 0 :SPECVAR MOUSE-X :WIRED T)
  (MOUSE-Y Y-POSITION 0 :SPECVAR MOUSE-Y :WIRED T)
  (MOUSE-X-SCALE-ARRAY X-SCALE-ARRAY () :SPECVAR MOUSE-X-SCALE-ARRAY :LOCAL T :WIRED T)
  (MOUSE-Y-SCALE-ARRAY Y-SCALE-ARRAY () :SPECVAR MOUSE-Y-SCALE-ARRAY :LOCAL T :WIRED T)
  (MOUSE-X-SPEED X-SPEED 0 :SPECVAR MOUSE-X-SPEED :WIRED T)
  (MOUSE-Y-SPEED Y-SPEED 0 :SPECVAR MOUSE-Y-SPEED :WIRED T)

  (MOUSE-BLINKER-OFF-TIME BLINKER-OFF-TIME 0 :SPECVAR *MOUSE-BLINKER-OFF-TIME*)
  (WHO-LINE-MOUSE-GRABBED-DOCUMENTATION GRABBED-WHO-LINE-DOCUMENTATION NIL
					:SPECVAR WHO-LINE-MOUSE-GRABBED-DOCUMENTATION)
  (WHO-LINE-MOUSE-GRABBED-MORE-DOCUMENTATION GRABBED-WHO-LINE-MORE-DOCUMENTATION NIL
					     :SPECVAR WHO-LINE-MOUSE-GRABBED-MORE-DOCUMENTATION)

  (MOUSE-LAST-REAL-MOTION-TIME LAST-REAL-MOTION-TIME 0
			       :SPECVAR DW::*LAST-REAL-MOUSE-MOTION-TIME*)
  (MOUSE-LAST-SHIFT-TIME LAST-SHIFT-TIME 0 :SPECVAR DW::*LAST-SHIFT-TIME*)
  (MOUSE-TRACKING-STATE TRACKING-STATE :SLUGGISH :SPECVAR DW::*MOUSE-TRACKING-STATE*)
  (MOUSE-TRACKING-STATE-LAST-SHIFTS TRACKING-STATE-LAST-SHIFTS 0
				    :SPECVAR DW::*MOUSE-TRACKING-STATE-LAST-SHIFTS*)
  )

(DEFMETHOD (REMOTE-MOUSE-P BASIC-MOUSE :DEFAULT) () NIL)

(DEFMETHOD (MOUSE-POTENTIALLY-CONFLICTING-BLINKER BASIC-MOUSE) ()
  (MOUSE-BLINKER SELF))

(DEFRESOURCE MOUSE-PROCESS ()
  :CONSTRUCTOR (PROCESS:MAKE-PROCESS
		 "Mouse"
		 :PRIORITY (PROCESS:MAKE-PROCESS-PRIORITY :FG 31. :PREEMPTIVE T)
		 :WARM-BOOT-ACTION NIL :FLAGS '(:SYSTEM-PROCESS T :NO-KBD-ARREST T)
		 :INTERRUPT-HANDLER T))

(DEFMETHOD (MOUSE-PROCESS-INITIALIZE BASIC-MOUSE) ()
  (WHEN (NULL (MOUSE-PROCESS SELF))
    (SETF (MOUSE-PROCESS SELF) (ALLOCATE-RESOURCE 'MOUSE-PROCESS)))
  (WHEN (MOUSE-USURPED-PROCESS SELF)
    (SETF (MOUSE-USURPED-PROCESS SELF) NIL))
  (PROCESS:PRESET (MOUSE-PROCESS SELF) #'MOUSE-OVERSEER SELF)
  (PROCESS:ENABLE (MOUSE-PROCESS SELF))
  NIL)

(DEFMETHOD (MOUSE-PROCESS-SHUTDOWN BASIC-MOUSE) ()
  (WHEN (MOUSE-PROCESS SELF)
    (PROCESS:RESET-AND-RELEASE-RESOURCES (MOUSE-PROCESS SELF))
    (DEALLOCATE-RESOURCE 'MOUSE-PROCESS (MOUSE-PROCESS SELF))
    (SETF (MOUSE-PROCESS SELF) NIL))
  NIL)

;; Approximate speed of the mouse in inches per second
(DEFMETHOD (MOUSE-SPEED BASIC-MOUSE) ()
  (LET ((X (MOUSE-X-SPEED SELF)) (Y (MOUSE-Y-SPEED SELF)))
    (// (ISQRT (+ (* X X) (* Y Y)))
	1.0s2)))

(DEFMETHOD (MOUSE-WARP-1 BASIC-MOUSE) (NEW-X NEW-Y)
  (WHEN NEW-X
    (SETF (MOUSE-LAST-X SELF) (SETF (MOUSE-X SELF) NEW-X)))
  (WHEN NEW-Y 
    (SETF (MOUSE-LAST-Y SELF) (SETF (MOUSE-Y SELF) NEW-Y)))
  NIL)



(DEFCONSTANT %LOCAL-CURSOR-CLOSED-STATE-SLOW-TRACKING 1)
(DEFCONSTANT %LOCAL-CURSOR-CLOSED-STATE-FAST-TRACKING 2)

(DEFMETHOD (MAKE-INSTANCE LOCAL-MOUSE-MIXIN) (&REST IGNORE)
  (SETF (SI:WIRED-MOUSE-MOUSE WIRED-MOUSE) SELF))

(DEFMETHOD (OPEN-MOUSE-CURSOR LOCAL-MOUSE-MIXIN) ()
  (%FUNCALL-IN-AUXILIARY-STACK-BUFFER NIL #'SI:%AUX-OPEN-MOUSE-CURSOR WIRED-MOUSE))

(DEFMETHOD (CLOSE-MOUSE-CURSOR LOCAL-MOUSE-MIXIN) ()
  (%FUNCALL-IN-AUXILIARY-STACK-BUFFER NIL #'SI:%AUX-CLOSE-MOUSE-CURSOR WIRED-MOUSE))

(DEFMETHOD (SUSPEND-MOUSE-CURSOR LOCAL-MOUSE-MIXIN) ()
  (%FUNCALL-IN-AUXILIARY-STACK-BUFFER NIL #'SI:%AUX-SUSPEND-MOUSE-CURSOR WIRED-MOUSE))

(DEFMETHOD ((CL:SETF MOUSE-SHEET) LOCAL-MOUSE-MIXIN :AFTER) (NEW-SHEET)
  (WHEN NEW-SHEET
    (SETF SCREEN (SHEET-SCREEN NEW-SHEET))
    (LET ((SCREEN SCREEN))
      (MULTIPLE-VALUE-BIND (IGNORE X-OFFSET Y-OFFSET)
	  (TV:SCREEN-FOLLOW-DRAWABLE-INDIRECTION SCREEN (SHEET-SCREEN-ARRAY NEW-SHEET) 0 0)
	(CL:SETF (SI:WIRED-MOUSE-SCREEN-BUFFER-ADDRESS WIRED-MOUSE) (SCREEN-BUFFER SCREEN)
		 (SI:WIRED-MOUSE-SCREEN-LOCATIONS-PER-LINE WIRED-MOUSE)
	         (// (* (SHEET-WIDTH SCREEN) (SCREEN-BITS-PER-PIXEL SCREEN)) 32.)
		 (SI:WIRED-MOUSE-SCREEN-BITS-PER-PIXEL WIRED-MOUSE)
	         (SCREEN-BITS-PER-PIXEL SCREEN)
		 (SI:WIRED-MOUSE-SCREEN-BUFFER-BIT-OFFSET WIRED-MOUSE)
	         (* (SI:WIRED-MOUSE-SCREEN-BITS-PER-PIXEL WIRED-MOUSE)
		    (+ X-OFFSET (* Y-OFFSET (SHEET-WIDTH SCREEN))))
		 (SI:WIRED-MOUSE-SCREEN-WIDTH WIRED-MOUSE) (SHEET-WIDTH NEW-SHEET)
		 (SI:WIRED-MOUSE-SCREEN-HEIGHT WIRED-MOUSE) (SHEET-HEIGHT NEW-SHEET)
		 (SI:WIRED-MOUSE-PREPARED-SHEET-VALID WIRED-MOUSE) NIL
		 PREPARED-SHEET NIL
	         FAST-TRACK-P (SCREEN-PERMIT-FAST-TRACKING-P SCREEN)
		 )))))

(DEFMETHOD (MOUSE-RESUME-TRACKING LOCAL-MOUSE-MIXIN) ()
  (SELECT (MOUSE-CURSOR-CLOSED-STATE SELF)
    (%LOCAL-CURSOR-CLOSED-STATE-SLOW-TRACKING
     (CL:SETF (MOUSE-CURSOR-STATE SELF) SI:%MOUSE-CURSOR-OPEN))
    (%LOCAL-CURSOR-CLOSED-STATE-FAST-TRACKING
     (CL:SETF (MOUSE-CURSOR-STATE SELF) SI:%MOUSE-CURSOR-INVISIBLE)
     (SETF PREPARED-SHEET NIL))))

(DEFMETHOD (MOUSE-HALT-FAST-TRACKING LOCAL-MOUSE-MIXIN) ()
  (OPEN-MOUSE-CURSOR SELF)
  (SETF (MOUSE-CURSOR-CLOSED-STATE SELF) %LOCAL-CURSOR-CLOSED-STATE-SLOW-TRACKING))

(DEFMETHOD (MOUSE-CHECK-FAST-TRACKING LOCAL-MOUSE-MIXIN) (DELTA-TIME)
  (WHEN (= (MOUSE-CURSOR-CLOSED-STATE SELF) %LOCAL-CURSOR-CLOSED-STATE-FAST-TRACKING)
    ;; Fast tracking is in effect on this sheet
    (WHEN (AND (EQL (MOUSE-CURSOR-STATE SELF) SI:%MOUSE-CURSOR-OPEN)
	       ;; Mouse blinker is open; turn fast tracking back on if it's time
	       (NOT (EQ (WINDOW-OWNING-MOUSE-INTERNAL SELF) 'STOP))
	       (> (INCF (MOUSE-BLINKER-OFF-TIME SELF) DELTA-TIME)
		  *MOUSE-BLINKER-WAIT-TIME*))
      (CL:SETF (MOUSE-CURSOR-STATE SELF) SI:%MOUSE-CURSOR-INVISIBLE)
      (SETF PREPARED-SHEET NIL))
    (WHEN (AND (EQL (MOUSE-CURSOR-STATE SELF) SI:%MOUSE-CURSOR-INVISIBLE)
	       ;; If mouse is trying to track into the prepared sheet, permit it
	       (SI:WIRED-MOUSE-PREPARED-SHEET-VALID WIRED-MOUSE))
      (LET ((NX (- (MOUSE-X SELF) (MOUSE-CURSOR-X-OFFSET SELF)))
	    (NY (- (MOUSE-Y SELF) (MOUSE-CURSOR-Y-OFFSET SELF))))
	(WHEN (AND (< NX (SI:WIRED-MOUSE-PREPARED-SHEET-RIGHT WIRED-MOUSE))
		   (< NY (SI:WIRED-MOUSE-PREPARED-SHEET-BOTTOM WIRED-MOUSE))
		   ( (+ NX 32.) (SI:WIRED-MOUSE-PREPARED-SHEET-LEFT WIRED-MOUSE))
		   ( (+ NY 32.) (SI:WIRED-MOUSE-PREPARED-SHEET-TOP WIRED-MOUSE)))
	  (SETF (SI:WIRED-MOUSE-PREPARED-SHEET-VALID WIRED-MOUSE) NIL)
	  (SETF PREPARED-SHEET NIL))))
    (WHEN (EQL (MOUSE-CURSOR-STATE SELF) SI:%MOUSE-CURSOR-SUSPENDED)
      ;; Let the cursor go again.
      (CL:SETF (MOUSE-CURSOR-STATE SELF) SI:%MOUSE-CURSOR-VISIBLE)
      (SETF PREPARED-SHEET NIL))
    ;; In a direct system, this just duplicates what the wired handler does.
    ;; In a remote system, nothing else will ever close it.
    (CLOSE-MOUSE-CURSOR SELF)))

(DEFMETHOD (MOUSE-UNLOCKED-CHECK-FAST-TRACKING LOCAL-MOUSE-MIXIN) (SCREEN DELTA-TIME)
  (WHEN (= (MOUSE-CURSOR-CLOSED-STATE SELF) %LOCAL-CURSOR-CLOSED-STATE-FAST-TRACKING)
    ;; Fast tracking is in effect on this sheet
    (WHEN (SELECT (MOUSE-CURSOR-STATE SELF)
	    (SI:%MOUSE-CURSOR-OPEN
	     (AND (NOT (EQ (WINDOW-OWNING-MOUSE-INTERNAL SELF) 'STOP))
		  (> (+ (MOUSE-BLINKER-OFF-TIME SELF) DELTA-TIME)
		     *MOUSE-BLINKER-WAIT-TIME*)))
	    (SI:%MOUSE-CURSOR-INVISIBLE T)
	    (SI:%MOUSE-CURSOR-SUSPENDED T))
      (MAYBE-LOCK-SHEET SCREEN
        (WITH-SCREEN-CONTROLLER-LOCK (SCREEN)	;Blinkers require screen-controller-lock
	  (MOUSE-CHECK-FAST-TRACKING SELF DELTA-TIME))
	;; If we can't get the lock, don't worry, will come back later
	;; If this is the mouse process, we mustn't wait for a sheet lock
	NIL))))

(DEFMETHOD (MOUSE-SET-PREPARED-SHEET LOCAL-MOUSE-MIXIN) (LEFT TOP RIGHT BOTTOM)
  (SETF (SI:WIRED-MOUSE-PREPARED-SHEET-LEFT WIRED-MOUSE) LEFT)
  (SETF (SI:WIRED-MOUSE-PREPARED-SHEET-TOP WIRED-MOUSE) TOP)
  (SETF (SI:WIRED-MOUSE-PREPARED-SHEET-RIGHT WIRED-MOUSE) RIGHT)
  (SETF (SI:WIRED-MOUSE-PREPARED-SHEET-BOTTOM WIRED-MOUSE) BOTTOM)
  (SETF (SI:WIRED-MOUSE-PREPARED-SHEET-VALID WIRED-MOUSE) T)
  ;; If the mouse already has tracked into the prepared sheet, turn it off
  (WHEN (AND (= (SI:WIRED-MOUSE-CURSOR-STATE WIRED-MOUSE) SI:%MOUSE-CURSOR-VISIBLE)
	     (< (SI:WIRED-MOUSE-CURSOR-X WIRED-MOUSE) RIGHT)
	     (> (+ (SI:WIRED-MOUSE-CURSOR-X WIRED-MOUSE)
		   (SI:WIRED-MOUSE-CURSOR-WIDTH WIRED-MOUSE))
		LEFT)
	     (< (SI:WIRED-MOUSE-CURSOR-Y WIRED-MOUSE) BOTTOM)
	     (> (+ (SI:WIRED-MOUSE-CURSOR-Y WIRED-MOUSE)
		   (SI:WIRED-MOUSE-CURSOR-HEIGHT WIRED-MOUSE))
		TOP))
    (OPEN-BLINKER (MOUSE-BLINKER SELF))))

(CL:DEFSTRUCT (LOCAL-MOUSE-CURSOR :NAMED-ARRAY-LEADER (:COPIER NIL) (:PREDICATE NIL)
				  (:CONSTRUCTOR-MAKE-ARRAY-KEYWORDS DIMENSIONS TYPE))
  WIDTH
  HEIGHT
  X-OFFSET
  Y-OFFSET)

(DEFWHOPPER (MAKE-MOUSE-CURSOR LOCAL-MOUSE-MIXIN) (&REST ARGS)
  (WHEN (SCREEN-PERMIT-FAST-TRACKING-P SCREEN)
    (LEXPR-CONTINUE-WHOPPER ARGS)))

(DEFMETHOD (MOUSE-MAKE-CURSOR LOCAL-MOUSE-MIXIN) (RASTER WIDTH HEIGHT X-OFF Y-OFF)
  (WHEN FAST-TRACK-P
    (LET ((BITS-PER-PIXEL (SI:WIRED-MOUSE-SCREEN-BITS-PER-PIXEL WIRED-MOUSE)))
      (IF (= 1 BITS-PER-PIXEL)
	  (AND (< WIDTH 32.) (< HEIGHT 32.)
	       (LET ((CURSOR (MAKE-LOCAL-MOUSE-CURSOR
			       :DIMENSIONS '(32. 32.) :TYPE 'SYS:ART-1B
			       :WIDTH WIDTH :HEIGHT HEIGHT :X-OFFSET X-OFF :Y-OFFSET Y-OFF)))
		 (BITBLT CL:BOOLE-1 WIDTH HEIGHT RASTER 0 0 CURSOR 0 0)
		 CURSOR))
	  (LET ((MAX-WIDTH (CL:// 32. BITS-PER-PIXEL)))
	    (AND (< WIDTH MAX-WIDTH) (< HEIGHT 32.)
		 (LET* ((CURSOR (MAKE-LOCAL-MOUSE-CURSOR 
				  :DIMENSIONS '(32 32)
				  :TYPE 'ART-1B
				  :WIDTH (* BITS-PER-PIXEL WIDTH)
				  :HEIGHT HEIGHT
				  :X-OFFSET (* BITS-PER-PIXEL X-OFF)
				  :Y-OFFSET Y-OFF)))
		   (WITH-STACK-LIST (DIMS 32. MAX-WIDTH)
		     (WITH-STACK-ARRAY
		       (REAL-CURSOR DIMS
				    :TYPE (SHEET-ARRAY-TYPE (MOUSE-SHEET SELF))
				    :DISPLACED-TO CURSOR)
		       (BITBLT-UNPACKED (LOGIOR COLOR:%EXTENDED-ALU
						COLOR:%TEMPLATE-ALU
						CL:BOOLE-1)
					WIDTH HEIGHT RASTER 0 0 REAL-CURSOR 0 0)))
		   CURSOR)))))))

(DEFMETHOD (MOUSE-FREE-CURSOR LOCAL-MOUSE-MIXIN) (CURSOR)
  CURSOR
  NIL)

(DEFMETHOD (MOUSE-FAST-TRACK LOCAL-MOUSE-MIXIN) (CURSOR REFRESH)
  (CL:SETF (MOUSE-CURSOR-WIDTH SELF) (LOCAL-MOUSE-CURSOR-WIDTH CURSOR))
  (CL:SETF (MOUSE-CURSOR-HEIGHT SELF) (LOCAL-MOUSE-CURSOR-HEIGHT CURSOR))
  (CL:SETF (MOUSE-CURSOR-X-OFFSET SELF) (LOCAL-MOUSE-CURSOR-X-OFFSET CURSOR))
  (CL:SETF (MOUSE-CURSOR-Y-OFFSET SELF) (LOCAL-MOUSE-CURSOR-Y-OFFSET CURSOR))
  (CL:SETF (MOUSE-CURSOR-CLOSED-STATE SELF) %LOCAL-CURSOR-CLOSED-STATE-FAST-TRACKING)
  (COPY-ARRAY-CONTENTS CURSOR (MOUSE-CURSOR-PATTERN SELF))
  ;; Allow the mouse tracker to proceed
  (CL:SETF (MOUSE-CURSOR-STATE SELF) SI:%MOUSE-CURSOR-INVISIBLE)
  (WHEN REFRESH
    (CLOSE-MOUSE-CURSOR SELF)))



(DEFFLAVOR PRIMARY-LOCAL-MOUSE
	((WIRED-MOUSE SI:*MAIN-MOUSE-WIRED-MOUSE*))
	(PRIMARY-MOUSE-MIXIN LOCAL-MOUSE-MIXIN BASIC-MOUSE)
  (:CONSTRUCTOR MAKE-PRIMARY-LOCAL-MOUSE (CONSOLE)))

(DEFFLAVOR SECONDARY-LOCAL-MOUSE
	()
	(SECONDARY-LOCAL-MOUSE-MIXIN BASIC-MOUSE)
  (:CONSTRUCTOR MAKE-SECONDARY-LOCAL-MOUSE (CONSOLE WIRED-MOUSE)))

(COMPILE-FLAVOR-METHODS PRIMARY-LOCAL-MOUSE SECONDARY-LOCAL-MOUSE)


;;; Low-level routines

;;; MOUSE-INPUT blocks until the mouse status changes (it moves or a button
;;; is depressed or raised).  It then returns 6 values: delta-X, delta-Y,
;;; buttons-newly-pushed, buttons-newly-raised, and the relevant mouse X and Y
;;; (the current position normally, but if any buttons changed, the position then).
;;; There are 3 coordinate systems involved:
;;;  Table coordinates - physical motion of the mouse
;;;			 Speeds are expressed in terms of these.
;;;  Mouse coordinates - These are the scaled table coordinates.  Only deltas
;;;			 are valid here.
;;;  Screen coordinates - these are where the mouse-blinker appears on
;;;			 the TV screen; the same as mouse coordinates except
;;;			 for non-simple geometry caused by e.g. scroll bars.
;;;			 These appear in the variables MOUSE-X and MOUSE-Y
;;; Note that because of non-simple geometry, the deltas returned by MOUSE-INPUT
;;; are not necessarily equal to the change in MOUSE-X and MOUSE-Y.
;;; If MOUSE-BUTTONS-GRABBED is T, stay away from the mouse buttons.
;;; This allows a process that has grabbed the mouse to call MOUSE-BUTTONS itself.
(DEFUN MOUSE-INPUT (&OPTIONAL (WAIT-FLAG T) (MOUSE MAIN-MOUSE))
  ;; Await a change in hardware status from what it was last time
  (WHEN WAIT-FLAG
    (IF (EQL *CURRENT-PROCESS* (MOUSE-PROCESS MOUSE))
	;; This ensures that moving the mouse does not lock out lower priority
	;; processes for a long time.  Wake up right away if a mouse button is
	;; pressed or if we need to reconsider which window the mouse is in.
	;; Wake up right away if the mouse moved and no processes are running,
	;; but if processes are running and the mouse is moved, don't wake up
	;; until the processes block or a delay expires.
	(PROCESS:WITH-DELAYED-PROCESS-PRIORITIES-IN-TIMER-UNITS
	  (NIL					;don't change priority now, but
	   *MOUSE-LOW-PRIORITY-TIME*		; after this long, if still hung,
	   (PROCESS:MAKE-PROCESS-PRIORITY :FOREGROUND 31.))	; boost priority to this
	  (PROCESS:BLOCK-AND-POLL-WAIT-FUNCTION
	    "Mouse"
	    (// 1.0 3.0)
	    #'(LAMBDA (MOUSE PROCESS:START-DELAYED-PRIORITIES START-TIME)
		(COND ((MOUSE-RECONSIDER MOUSE) T)	;high priority wakeup for Mouse Out
		      ((NOT (OR (MOUSE-WAKEUP-INTERNAL MOUSE)
				(AND (MOUSE-MAYBE-WAKEUP-TIME MOUSE)
				     (TIME-ELAPSED-P 0 (MOUSE-MAYBE-WAKEUP-TIME MOUSE)))))
		       NIL)				;stay blocked
		      (( (MOUSE-BUTTONS-BUFFER-IN-INDEX MOUSE)
			  (MOUSE-BUTTONS-BUFFER-OUT-INDEX MOUSE))
		       T)				;high priority wakeup for buttons
		      ((TIME-ELAPSED-P *MOUSE-LOW-PRIORITY-TIME* START-TIME
				       (TIME:FIXNUM-MICROSECOND-TIME))
		       T)				;high priority wakeup for motion
		      (T
		       (PROCESS:START-DELAYED-PRIORITIES)	;low priority wakeup
		       (PROCESS:MAKE-PROCESS-PRIORITY :FOREGROUND -1))))
	    MOUSE PROCESS:START-DELAYED-PRIORITIES (TIME:FIXNUM-MICROSECOND-TIME)))
	(PROCESS-WAIT "Mouse"
	  #'(LAMBDA (MOUSE)
	      (OR (MOUSE-WAKEUP-INTERNAL MOUSE)
		  (MOUSE-RECONSIDER MOUSE)
		  (AND (MOUSE-MAYBE-WAKEUP-TIME MOUSE)
		       (TIME-ELAPSED-P 0 (MOUSE-MAYBE-WAKEUP-TIME MOUSE)))))
	  MOUSE)))
  ;; Clear wakeup flag unless there are buffered mouse button transitions, since we
  ;; might not read all of them before calling MOUSE-INPUT again.
  (CL:SETF (MOUSE-WAKEUP-INTERNAL MOUSE)
	   (AND (NOT (MOUSE-BUTTONS-GRABBED MOUSE))
		( (MOUSE-BUTTONS-BUFFER-IN-INDEX MOUSE)
		   (MOUSE-BUTTONS-BUFFER-OUT-INDEX MOUSE))))
  (CL:SETF (MOUSE-MAYBE-WAKEUP-TIME MOUSE) NIL)
  ;; Compute delta-X and delta-Y in screen coordinates
  (LET ((DELTA-X (- (MOUSE-X MOUSE) (MOUSE-LAST-X MOUSE)))
	(DELTA-Y (- (MOUSE-Y MOUSE) (MOUSE-LAST-Y MOUSE)))
	(GLITCH-X NIL) (GLITCH-Y NIL)
	(NEW-BUTTONS 0) (CHANGED-BUTTONS 0))
    (INCF (MOUSE-LAST-X MOUSE) DELTA-X)
    (INCF (MOUSE-LAST-Y MOUSE) DELTA-Y)
    ;; Compute change in button status
    (UNLESS (MOUSE-BUTTONS-GRABBED MOUSE)
      (MULTIPLE-VALUE-BIND (BUTTONS LAST-TIME LAST-X LAST-Y)
	  (MOUSE-BUTTONS NIL MOUSE)
	(CL:SETF NEW-BUTTONS BUTTONS
		 (MOUSE-LAST-BUTTONS-TIME MOUSE) LAST-TIME
		 (MOUSE-LAST-BUTTONS-X MOUSE) LAST-X
		 (MOUSE-LAST-BUTTONS-Y MOUSE) LAST-Y))
      (CL:SETF CHANGED-BUTTONS (LOGXOR NEW-BUTTONS (MOUSE-LAST-BUTTONS MOUSE))
	       (MOUSE-LAST-BUTTONS MOUSE) NEW-BUTTONS))
    (UNLESS (AND (REMOTE-MOUSE-P MOUSE) (NULL (WINDOW-OWNING-MOUSE-INTERNAL MOUSE)))
      ;; Force blinker to stay within mouse-sheet.  If the mouse moves during this
      ;; computation, it will glitch back.  So we only SETQ the variables 
      ;; if the mouse position actually needs to be changed, rather than using
      ;; MAX and MIN which would be more readable.
      (IF (> 0 (MOUSE-X MOUSE))
	  (SETQ GLITCH-X 0))
      (IF ( (SHEET-WIDTH (MOUSE-SHEET MOUSE)) (MOUSE-X MOUSE))
	  (SETQ GLITCH-X (1- (SHEET-WIDTH (MOUSE-SHEET MOUSE)))))
      (IF (> 0 (MOUSE-Y MOUSE))
	  (SETQ GLITCH-Y 0))
      (IF ( (SHEET-HEIGHT (MOUSE-SHEET MOUSE)) (MOUSE-Y MOUSE))
	  (SETQ GLITCH-Y (1- (SHEET-HEIGHT (MOUSE-SHEET MOUSE)))))
      ;; If mouse blinker needs to be glitched, do so
      (IF (OR GLITCH-X GLITCH-Y)
	  (WITHOUT-INTERRUPTS
	     (OPEN-MOUSE-CURSOR MOUSE)
	     (MOUSE-WARP-1 MOUSE GLITCH-X GLITCH-Y)
	     (MOUSE-RESUME-TRACKING MOUSE))))
    (VALUES DELTA-X
	    DELTA-Y
	    (LOGAND NEW-BUTTONS CHANGED-BUTTONS)
	    (BOOLE 2 NEW-BUTTONS CHANGED-BUTTONS) ;BOOLE 2 is ANDCA
	    (IF (ZEROP CHANGED-BUTTONS) (MOUSE-LAST-X MOUSE) (MOUSE-LAST-BUTTONS-X MOUSE))
	    (IF (ZEROP CHANGED-BUTTONS) (MOUSE-LAST-Y MOUSE) (MOUSE-LAST-BUTTONS-Y MOUSE)))))

;;; MOUSE-BUTTONS returns a word with a 1 for each button currently held down,
;;; the time when that was the true state of the buttons, and the X and Y
;;; coordinates of the mouse then.
;;; PEEK means to look at the state without pulling anything out of the buffer
;;; (processes other than the mouse process use this)
(DEFUN MOUSE-BUTTONS (&OPTIONAL PEEK (MOUSE MAIN-MOUSE))
  (DECLARE (VALUES MOUSE-LAST-BUTTONS MOUSE-LAST-BUTTONS-TIME MOUSE-X MOUSE-Y))
  (LET ((TEM (MOUSE-BUTTONS-BUFFER-OUT-INDEX MOUSE)))
    (COND ((MOUSE-BUTTONS-IN-PROGRESS MOUSE)
	   (VALUES (PROG1 (MOUSE-BUTTONS-IN-PROGRESS MOUSE)
			  (CL:SETF (MOUSE-BUTTONS-IN-PROGRESS MOUSE) NIL))
		   (MOUSE-LAST-BUTTONS-TIME MOUSE)
		   (MOUSE-LAST-BUTTONS-X MOUSE)
		   (MOUSE-LAST-BUTTONS-Y MOUSE)))
	  ((= TEM (MOUSE-BUTTONS-BUFFER-IN-INDEX MOUSE))
	   ;; Return current button/keyboard status and current mouse position
	   (LET* ((CONSOLE (MOUSE-CONSOLE MOUSE))
		  (KEYBOARD (CONSOLE-KEYBOARD CONSOLE)))
	     (WHEN (CONSOLE-HARDWARE-CHAR-AVAILABLE CONSOLE)
	       (CONSOLE-PROCESS-INPUT CONSOLE))
	     (LET ((BD (MOUSE-BUTTONS-INTERNAL MOUSE)))
	       (WHEN (= BD 1) ;If the button is down, maybe shift it from keys.
		 (SETQ BD (CLI::KEYBOARD-INCLUDE-MOUSE-BUTTON-SHIFT-KEYS KEYBOARD BD)))
	       (VALUES BD (TIME:FIXNUM-MICROSECOND-TIME) (MOUSE-X MOUSE) (MOUSE-Y MOUSE)))))
	  (T
	   (UNLESS PEEK
	     (CL:SETF (MOUSE-BUTTONS-BUFFER-OUT-INDEX MOUSE) (%FIXNUM-MOD (+ TEM 4) 32.)))
	   ;; Make sure the button state in the buffer has been updated from the keyboard
	   (CONSOLE-PROCESS-INPUT (MOUSE-CONSOLE MOUSE))
	   (VALUES (LDB (BYTE 16. 0)	;mask off shift keys
			(AREF (MOUSE-BUTTONS-BUFFER MOUSE) (+ TEM 3)))	;BD
		   (AREF (MOUSE-BUTTONS-BUFFER MOUSE) TEM)		;TIME
		   (AREF (MOUSE-BUTTONS-BUFFER MOUSE) (+ TEM 1))	;X
		   (AREF (MOUSE-BUTTONS-BUFFER MOUSE) (+ TEM 2)))))))	;Y

;;; Call this to forget about any complete clicks which have already happened
(DEFUN MOUSE-DISCARD-CLICKAHEAD (&OPTIONAL (MOUSE MAIN-MOUSE))
  (WHEN MOUSE
    (CL:SETF (MOUSE-BUTTONS-BUFFER-OUT-INDEX MOUSE) (MOUSE-BUTTONS-BUFFER-IN-INDEX MOUSE)
	     (MOUSE-BUTTONS-IN-PROGRESS MOUSE) NIL)))

;;; Remember this change in the buttons and handle it again later
(DEFUN MOUSE-DEFER-BUTTONS (BU BD &OPTIONAL (MOUSE MAIN-MOUSE))
  (IF (OR (NOT (ZEROP BU)) (NOT (ZEROP BD)))
      (CL:SETF (MOUSE-BUTTONS-IN-PROGRESS MOUSE) (MOUSE-LAST-BUTTONS MOUSE)
	       (MOUSE-LAST-BUTTONS MOUSE) (LOGIOR BU
						  (BOOLE 2 BD	;BOOLE 2 is ANDCA
							 (MOUSE-LAST-BUTTONS MOUSE))))))

;;; MOUSE-BUTTON-ENCODE
;;; When a mouse button has been pushed, and you want to support
;;; double-clicking, call this function.  It returns NIL if no
;;; button is pushed, or 100000 + 8 N + B, where B is the bit number
;;; in the button word, and N is one less than the number of clicks.
;;; Timing is computed from the microsecond clock.
;;; The argument, BD, is which buttons were just pushed, supplied by the caller
;;; who presumably got it from MOUSE-INPUT for the sake of good rollover.
(DEFUN MOUSE-BUTTON-ENCODE (BD &OPTIONAL (MOUSE MAIN-MOUSE))
  (MACROLET ((TIME-DIFFERENCE (T1 T2)	;time can go backwards, can't use the normal function
	      `(LET ((TD (- ,T1 ,T2)))
		 (COND ((PLUSP TD) TD)
		       ((> TD (FLOOR CL:MOST-NEGATIVE-FIXNUM 2)) TD)	;slightly negative
		       (T (LDB (BYTE 31. 0) TD))))))	;wrapped around 31 bits
    (LET ((BUTTON (1- (HAULONG BD))))	;Pick a button that was just pushed
      (UNLESS (MINUSP BUTTON)		;Check whether a button was in fact pushed
	(LET* ((TIME (MOUSE-LAST-BUTTONS-TIME MOUSE))
	       (CONSOLE (MOUSE-CONSOLE MOUSE))
	       (CH ;; Let keyboard do mapping to apply various kinds of shifts.
		   (CLI::KEYBOARD-CONVERT-TO-MOUSE-CHAR
		     (CONSOLE-KEYBOARD CONSOLE) BUTTON
		     ;; Shifts at the moment of the last mouse button transition
		     (LDB (BYTE 16. 16.)
			  (AREF (MOUSE-BUTTONS-BUFFER MOUSE)
				(%FIXNUM-MOD (+ (MOUSE-BUTTONS-BUFFER-OUT-INDEX MOUSE) 3 -4)
					     32.)))))
	       (MASK (LSH 1 BUTTON))
	       (DEBOUNCE (NOT (REMOTE-MOUSE-P MOUSE)))
	       NEW-BUTTONS NEW-TIME)
	  ;; De-bounce mouse and look for double clicks
	  (LOOP NAMED DEBOUNCE DOING  ;Do forever (until guy's finger wears out)
	    ;; Ignore any clicking during the bounce delay
	    (IF DEBOUNCE
		(LOOP DOING (MULTIPLE-VALUE (NEW-BUTTONS NEW-TIME) (MOUSE-BUTTONS NIL MOUSE))
		      UNTIL (> (TIME-DIFFERENCE NEW-TIME TIME) MOUSE-BOUNCE-TIME)
		      FINALLY (SETQ TIME NEW-TIME))
		(SETQ NEW-BUTTONS BD))
	    (WHEN (NULL MOUSE-DOUBLE-CLICK-TIME)
	      (RETURN))			;Double-click feature disabled
	    ;; Look for button to be lifted, or for double-click timeout
	    (LOOP WHILE (BIT-TEST MASK NEW-BUTTONS)
		  DO (MULTIPLE-VALUE (NEW-BUTTONS NEW-TIME) (MOUSE-BUTTONS NIL MOUSE))
		  WHEN (OR (> (TIME-DIFFERENCE NEW-TIME TIME) MOUSE-DOUBLE-CLICK-TIME)
			   (CONSOLE-HARDWARE-CHAR-AVAILABLE CONSOLE))
		    ;; Timed-out with button still down
		    DO (RETURN-FROM DEBOUNCE)
		  FINALLY (SETQ TIME NEW-TIME))
	    ;; Button was lifted, do another bounce delay
	    (WHEN DEBOUNCE
	      (LOOP DOING (MULTIPLE-VALUE (NEW-BUTTONS NEW-TIME) (MOUSE-BUTTONS NIL MOUSE))
		    UNTIL (> (TIME-DIFFERENCE NEW-TIME TIME) MOUSE-BOUNCE-TIME)
		    FINALLY (SETQ TIME NEW-TIME)))
	    ;; Now watch for button to be pushed again
	    (LOOP UNTIL (BIT-TEST MASK NEW-BUTTONS)
		  DO (MULTIPLE-VALUE (NEW-BUTTONS NEW-TIME) (MOUSE-BUTTONS NIL MOUSE))
		  WHEN (OR (> (TIME-DIFFERENCE NEW-TIME TIME) MOUSE-DOUBLE-CLICK-TIME)
			   (CONSOLE-HARDWARE-CHAR-AVAILABLE CONSOLE))
		    ;; Timed-out with button still up
		    DO (RETURN-FROM DEBOUNCE)
		  FINALLY (SETQ CH (MAKE-MOUSE-CHAR (CHAR-MOUSE-BUTTON CH)
						    (LOGIOR #o20 (CHAR-MOUSE-BITS CH))))
			  (SETF TIME NEW-TIME))
	    ;; Used to continue scanning (for triple click), but that's
	    ;; a useless waste of time now that we don't encode triple clicks in CH anymore
	    (RETURN-FROM DEBOUNCE))
	  ;; Save state for next time
	  (CL:SETF (MOUSE-LAST-BUTTONS MOUSE) NEW-BUTTONS
		   (MOUSE-LAST-BUTTONS-TIME MOUSE) NEW-TIME)
	  ;; CH now encodes the button and the number of times it was clicked
	  CH)))))

(DEFUN WITH-THIS-MOUSE-GRABBED-INTERNAL (CONTINUATION &OPTIONAL MOUSE
								(NEW-MOUSE-WINDOW T)
						      &KEY (BUTTONS-TOO NIL)
							   (ON-SHEET NIL))
  (DECLARE (DOWNWARD-FUNARG CONTINUATION))
  (WHEN (NULL MOUSE)
    (SETQ MOUSE (COND (ON-SHEET (SHEET-MOUSE ON-SHEET))
		      ((TYPEP TERMINAL-IO 'SHEET)
		       (SHEET-MOUSE TERMINAL-IO))
		      (T MAIN-MOUSE))))
  (LET ((OLD-MOUSE-WINDOW (WINDOW-OWNING-MOUSE-INTERNAL MOUSE))
	(OLD-MOUSE-DOC (WHO-LINE-MOUSE-GRABBED-DOCUMENTATION MOUSE))
	(OLD-MOUSE-MORE-DOC (WHO-LINE-MOUSE-GRABBED-MORE-DOCUMENTATION MOUSE))
	(OLD-MOUSE-SHEET (MOUSE-SHEET MOUSE))
	(OLD-BUTTONS-GRABBED (MOUSE-BUTTONS-GRABBED MOUSE)))
    (UNWIND-PROTECT
	(PROGN
	  (CL:SETF (WHO-LINE-MOUSE-GRABBED-DOCUMENTATION MOUSE) NIL)
	  (CL:SETF (WHO-LINE-MOUSE-GRABBED-MORE-DOCUMENTATION MOUSE) NIL)
	  ;; Tell the mouse process to switch "modes" and wait for it to do so
	  (WITHOUT-INTERRUPTS
	    (CL:SETF (WINDOW-OWNING-MOUSE-INTERNAL MOUSE) NEW-MOUSE-WINDOW)
	    (WHEN (NEQ NEW-MOUSE-WINDOW (MOUSE-WINDOW MOUSE))
	      (CL:SETF (MOUSE-RECONSIDER MOUSE) T
		       INHIBIT-SCHEDULING-FLAG NIL)
	      (PROCESS:WAKEUP (MOUSE-PROCESS MOUSE))
	      (PROCESS-WAIT "Grab Mouse" #'(LAMBDA (WOM MOUSE)
					     (AND (NULL (MOUSE-RECONSIDER MOUSE))
						  (EQ (MOUSE-WINDOW MOUSE) WOM)))
			    NEW-MOUSE-WINDOW MOUSE)))
	  (WHEN BUTTONS-TOO
	    (CL:SETF (MOUSE-BUTTONS-GRABBED MOUSE) T))
	  (WHEN ON-SHEET
	    (MOUSE-SET-SHEET ON-SHEET))
	  (WHEN (EQL NEW-MOUSE-WINDOW 'STOP)
	    (SETF (MOUSE-USURPED-PROCESS MOUSE) *CURRENT-PROCESS*))
	  (FUNCALL CONTINUATION))
	 (WHEN (EQL *CURRENT-PROCESS* (MOUSE-USURPED-PROCESS MOUSE))
	   (CL:SETF (MOUSE-USURPED-PROCESS MOUSE) NIL))
	 (WHEN ON-SHEET
	   (MOUSE-SET-SHEET OLD-MOUSE-SHEET))
	 (CL:SETF (WINDOW-OWNING-MOUSE-INTERNAL MOUSE) OLD-MOUSE-WINDOW
		  (MOUSE-RECONSIDER MOUSE) T
		  (WHO-LINE-MOUSE-GRABBED-DOCUMENTATION MOUSE) OLD-MOUSE-DOC
		  (WHO-LINE-MOUSE-GRABBED-MORE-DOCUMENTATION MOUSE) OLD-MOUSE-MORE-DOC
		  (MOUSE-BUTTONS-GRABBED MOUSE) OLD-BUTTONS-GRABBED)

	 (PROCESS:WAKEUP (MOUSE-PROCESS MOUSE)))))

(DEFUN MOUSE-CHORD-SHIFTS (&OPTIONAL (MOUSE MAIN-MOUSE))
  (LET ((BITS (CONSOLE-SHIFTS (MOUSE-CONSOLE MOUSE))))
    (DPB BITS (BYTE 1 4) (LDB (BYTE 4 1) BITS))))

;;; Read the mouse buttons by reading a variable stored into by the FEP
(COMPILER:MAKE-OBSOLETE %MOUSE-BUTTONS "Use TV:MOUSE-BUTTONS-INTERNAL instead.")
(DEFUN %MOUSE-BUTTONS ()
  (MOUSE-BUTTONS-INTERNAL MAIN-MOUSE))

;;; Middle-level routines

;(DEFVAR MOUSE-PROCESS)			;This global-process is in charge of the mouse
(DEFVAR MOUSE-BLINKER NIL)		;This blinker shows where the mouse "is"
(DEFVAR MOUSE-BLINKER-NAME NIL)		;The type of MOUSE-BLINKER
;(DEFVAR MOUSE-WINDOW)			;Window controlling the mouse, NIL if none
;(DEFVAR WINDOW-OWNING-MOUSE)		;NIL, or window which has seized the mouse, or
;					;T if someone has seized the mouse and can't identify
;					;himself as any particular window,
;					;or STOP to make the mouse process do nothing.
;(DEFVAR MOUSE-X)			;X coordinate of MOUSE-BLINKER
;(DEFVAR MOUSE-Y)			;Y coordinate of MOUSE-BLINKER
;(DEFVAR MOUSE-SHEET NIL)		;Which sheet MOUSE-BLINKER lives on
(DEFVAR MOUSE-WARP NIL)			;Set to T whenever mouse is warped

(DEFUN MOUSE-STANDARD-BLINKER (&OPTIONAL WINDOW MOUSE)
  (WHEN (NULL MOUSE)
    (SETQ MOUSE (IF (INSTANCEP WINDOW)
		    (SHEET-MOUSE WINDOW)
		    MAIN-MOUSE)))
  (WHEN (NULL WINDOW)
    (SETQ WINDOW (WINDOW-OWNING-MOUSE NIL NIL MOUSE)))
  (WHEN (SYMBOLP WINDOW)
    (SETQ WINDOW (MOUSE-SHEET MOUSE)))
  (SEND WINDOW ':MOUSE-STANDARD-BLINKER))

(DEFMETHOD (:MOUSE-STANDARD-BLINKER SHEET) ()
  (SEND SUPERIOR ':MOUSE-STANDARD-BLINKER))

(DEFMETHOD (:MOUSE-STANDARD-BLINKER SCREEN) ()
  (MOUSE-SET-BLINKER-DEFINITION-INTERNAL (SHEET-MOUSE SELF)
					 ':CHARACTER 0 0 ':ON
					 ':SET-CHARACTER #\MOUSE:NW-ARROW))


;;; This message is worthless, since it wouldn't work to have anything other
;;; than FONTS:MOUSE.
(DEFMETHOD (:MOUSE-FONT SCREEN) () (SEND SELF ':PARSE-FONT-DESCRIPTOR 'FONTS:MOUSE))

(DEFMETHOD (:MAGNIFYING-BLINKER-FLAVOR SCREEN) ()
  'MAGNIFYING-BLINKER)

(DEFMETHOD (:OFFSETS MOUSE-BLINKER-MIXIN) ()
  (VALUES X-OFFSET Y-OFFSET))

(DEFMETHOD (:SET-OFFSETS MOUSE-BLINKER-MIXIN) (X Y)
  (WITH-BLINKER-PREPARED (SELF)
    (SETQ X-OFFSET (ROUND X)
	  Y-OFFSET (ROUND Y))))

(DEFMETHOD (:SET-CURSORPOS MOUSE-BLINKER-MIXIN :AFTER) (&rest ignore)
  (WHEN (EQ SELF (TV:MOUSE-BLINKER (TV:SHEET-MOUSE (SEND SELF :SHEET))))
    (SEND (SEND SELF :SHEET) :KEEP-MOUSE-VISIBLE)))

(DEFMETHOD (:SET-SIZE MOUSE-BLINKER-MIXIN :AFTER) (&REST IGNORE)
  (WHEN (EQ SELF (TV:MOUSE-BLINKER (TV:SHEET-MOUSE (SEND SELF :SHEET))))
    (SEND (SEND SELF :SHEET) :KEEP-MOUSE-VISIBLE)))

(DEFMETHOD (:SET-OFFSETS MOUSE-BLINKER-MIXIN :AFTER) (&REST IGNORE)
  (WHEN (EQ SELF (TV:MOUSE-BLINKER (TV:SHEET-MOUSE (SEND SELF :SHEET))))
    (SEND (SEND SELF :SHEET) :KEEP-MOUSE-VISIBLE)))

(DEFMETHOD (:SET-SIZE-AND-CURSORPOS MOUSE-BLINKER-MIXIN :AFTER) (&REST IGNORE)
  (WHEN (EQ SELF (TV:MOUSE-BLINKER (TV:SHEET-MOUSE (SEND SELF :SHEET))))
    (SEND (SEND SELF :SHEET) :KEEP-MOUSE-VISIBLE)))

(DEFMETHOD (:SET-CORNER-AND-SIZE MOUSE-BLINKER-MIXIN :AFTER) (&REST IGNORE)
  (WHEN (EQ SELF (TV:MOUSE-BLINKER (TV:SHEET-MOUSE (SEND SELF :SHEET))))
    (SEND (SEND SELF :SHEET) :KEEP-MOUSE-VISIBLE)))

(DEFWHOPPER (:SET-OFFSETS MOUSE-BLINKER-FAST-TRACKING-MIXIN) (X Y)
  (WITH-BLINKER-PREPARED (SELF)
    (MOUSE-BLINKER-FLUSH-CURSOR-CACHE SELF)
    (CONTINUE-WHOPPER X Y)))

(DEFWHOPPER (:SET-SHEET MOUSE-BLINKER-FAST-TRACKING-MIXIN) (S)
  (WITH-BLINKER-PREPARED (SELF)
    (MOUSE-BLINKER-FLUSH-CURSOR-CACHE SELF)
    (CONTINUE-WHOPPER S)))

(DEFMETHOD (:TRACK-MOUSE MOUSE-BLINKER-MIXIN) (&OPTIONAL REFRESH)
  (IGNORE REFRESH)				;Always refreshes immediately
  (WITH-SCREEN-CONTROLLER-LOCK ((SHEET-SCREEN SHEET))
    (LET ((MOUSE (SHEET-MOUSE SHEET)))
      (OPEN-MOUSE-CURSOR MOUSE)
      (CL:SETF (MOUSE-BLINKER MOUSE) SELF)
      (MOUSE-HALT-FAST-TRACKING MOUSE)
      ;; No fast tracking, so draw the blinker right away to decrease flicker
      (WHEN (AND (EQ (BLINKER-VISIBILITY SELF) T)
		 (NULL (BLINKER-PHASE SELF)))
	(BLINK SELF)))))

(DEFMETHOD (:TRACK-MOUSE MOUSE-BLINKER-FAST-TRACKING-MIXIN) (&OPTIONAL REFRESH)
  (WITH-SCREEN-CONTROLLER-LOCK ((SHEET-SCREEN SHEET))
    (LET ((MOUSE (SHEET-MOUSE SHEET)))
      (OPEN-MOUSE-CURSOR MOUSE)			;Get rid of old microcode cursor
      (CL:SETF (MOUSE-BLINKER MOUSE) SELF)
      (LET ((CURRENT-CURSOR (MOUSE-BLINKER-MAKE-CURSOR SELF MOUSE)))
	(COND ((NULL CURRENT-CURSOR)
	       (MOUSE-HALT-FAST-TRACKING MOUSE)	;Too big to use fast tracking
	       (WHEN (NULL (BLINKER-PHASE SELF))
		 (BLINK SELF)))
	      (T
	       (SEND SELF :SET-VISIBILITY NIL)	;We are not in charge of drawing anything
	       (MOUSE-FAST-TRACK MOUSE CURRENT-CURSOR REFRESH)))))))

(DEFMETHOD (:SET-MOTION-PENDING MOUSE-BLINKER-MIXIN :DEFAULT) (IGNORE) )

;All the standard mouse blinkers are character blinkers, so enable fast tracking for them.
(DEFFLAVOR MOUSE-CHARACTER-BLINKER
	((CACHED-CURSOR NIL)
	 (CACHED-CURSOR-MOUSE NIL))
	(MOUSE-BLINKER-FAST-TRACKING-MIXIN CHARACTER-BLINKER))

(DEFMETHOD (MOUSE-BLINKER-FLUSH-CURSOR-CACHE MOUSE-CHARACTER-BLINKER) ()
  (WHEN (NOT (NULL CACHED-CURSOR))
    (MOUSE-FREE-CURSOR CACHED-CURSOR-MOUSE CACHED-CURSOR)
    (SETF CACHED-CURSOR NIL)))

(DEFWHOPPER (:SET-CHARACTER MOUSE-CHARACTER-BLINKER) (C)
  (WITH-BLINKER-PREPARED (SELF)
    (MOUSE-BLINKER-FLUSH-CURSOR-CACHE SELF)
    (CONTINUE-WHOPPER C)))


(DEFMETHOD (MOUSE-BLINKER-MAKE-CURSOR MOUSE-CHARACTER-BLINKER) (MOUSE)
  (WHEN (NOT (EQ MOUSE CACHED-CURSOR-MOUSE))
    (MOUSE-BLINKER-FLUSH-CURSOR-CACHE SELF)
    (SETF CACHED-CURSOR-MOUSE MOUSE))
  (WHEN (NULL CACHED-CURSOR)
    (MULTIPLE-VALUE-BIND (WID HEI)
	(SEND SELF :SIZE)
      (STACK-LET* ((DIMS `(,HEI ,(* 32. (CEILING (MAX 1 WID) 32.))))
		   (RASTER (MAKE-ARRAY DIMS :TYPE 'SYS:ART-1B))
		   (BOUNDS `(0 0 ,WID ,HEI)))
	;; Draw the blinker into PATTERN
	(%DRAW-CHAR-CLIPPED-INTERNAL INDEX FONT 0 0 CL:BOOLE-IOR RASTER BOUNDS)
	(SETF CACHED-CURSOR (MOUSE-MAKE-CURSOR MOUSE RASTER WID HEI X-OFFSET Y-OFFSET)))))
  CACHED-CURSOR)

;;;

(DEFFLAVOR MOUSE-ALTERNATE-CHARACTER-BLINKER
	((HOLLOW-P NIL)
	 ACTIVE-CHARACTER BACKUP-CHARACTER
	 ACTIVE-FONT BACKUP-FONT
	 ACTIVE-INDEX BACKUP-INDEX
	 (CACHED-ACTIVE-CURSOR NIL) (CACHED-BACKUP-CURSOR NIL)
	 (CACHED-CURSOR-MOUSE NIL))
	(MOUSE-BLINKER-FAST-TRACKING-MIXIN BLINKER))

(DEFMETHOD (MOUSE-BLINKER-FLUSH-CURSOR-CACHE MOUSE-ALTERNATE-CHARACTER-BLINKER) ()
  (WHEN (NOT (NULL CACHED-ACTIVE-CURSOR))
    (MOUSE-FREE-CURSOR CACHED-CURSOR-MOUSE CACHED-ACTIVE-CURSOR)
    (SETF CACHED-ACTIVE-CURSOR NIL))
  (WHEN (NOT (NULL CACHED-BACKUP-CURSOR))
    (MOUSE-FREE-CURSOR CACHED-CURSOR-MOUSE CACHED-BACKUP-CURSOR)
    (SETF CACHED-BACKUP-CURSOR NIL)))

(DEFMETHOD (MOUSE-BLINKER-MAKE-CURSOR MOUSE-ALTERNATE-CHARACTER-BLINKER) (MOUSE)
  (WHEN (NOT (EQ MOUSE CACHED-CURSOR-MOUSE))
    (MOUSE-BLINKER-FLUSH-CURSOR-CACHE SELF)
    (SETF CACHED-CURSOR-MOUSE MOUSE))
  (WHEN (NULL CACHED-ACTIVE-CURSOR)
    (MULTIPLE-VALUE-BIND (WID HEI) (SEND SELF :SIZE)
      (STACK-LET* ((DIMS `(,HEI ,(* 32. (CEILING (MAX 1 WID) 32.))))
		   (RASTER (MAKE-ARRAY DIMS :TYPE 'SYS:ART-1B))
		   (BOUNDS `(0 0 ,WID ,HEI)))
	;; Draw the blinker into PATTERN
	(%DRAW-CHAR-CLIPPED-INTERNAL ACTIVE-INDEX ACTIVE-FONT 0 0 CL:BOOLE-IOR RASTER BOUNDS)
	(SETF CACHED-ACTIVE-CURSOR
	      (MOUSE-MAKE-CURSOR MOUSE RASTER WID HEI X-OFFSET Y-OFFSET)))))
  CACHED-ACTIVE-CURSOR)


(DEFMETHOD (:SIZE MOUSE-ALTERNATE-CHARACTER-BLINKER) ()
  ;; The width and height of a glyph (the size of the bitblt that draws it)
  ;; Assume (< INDEX (FONT-FILL-POINTER FONT))
  (VALUES (LET ((FIT (FONT-INDEXING-TABLE ACTIVE-FONT)))
	    (IF FIT
		(- (AREF FIT (1+ ACTIVE-INDEX)) (AREF FIT ACTIVE-INDEX))
		(FONT-RASTER-WIDTH ACTIVE-FONT)))
	  (FONT-RASTER-HEIGHT ACTIVE-FONT)))

(DEFMETHOD (:BLINK MOUSE-ALTERNATE-CHARACTER-BLINKER) ()
  "Use a character as a blinker.  Any font, any character"
  (SHEET-DRAW-GLYPH ACTIVE-INDEX ACTIVE-FONT X-POS Y-POS BLINKER-ALU SHEET))

(DEFMETHOD (:SET-SOLID-AND-HOLLOW-CHARACTERS MOUSE-ALTERNATE-CHARACTER-BLINKER)
	   (NEW-SOLID NEW-HOLLOW)
  (WITH-BLINKER-PREPARED (SELF)
    (MOUSE-BLINKER-FLUSH-CURSOR-CACHE SELF)
    (MULTIPLE-VALUE-BIND (NEW-ACTIVE NEW-BACKUP)
	(IF HOLLOW-P
	    (VALUES NEW-HOLLOW NEW-SOLID)
	    (VALUES NEW-SOLID NEW-HOLLOW))
      (SETQ ACTIVE-CHARACTER NEW-ACTIVE)
      (MULTIPLE-VALUE (ACTIVE-INDEX ACTIVE-FONT)
	(SHEET-GET-CHAR-INDEX-AND-FONT ACTIVE-CHARACTER T SHEET))
      (SETF BACKUP-CHARACTER NEW-BACKUP)
      (MULTIPLE-VALUE (BACKUP-INDEX BACKUP-FONT)
	(SHEET-GET-CHAR-INDEX-AND-FONT BACKUP-CHARACTER T SHEET)))))

(DEFMETHOD (:SET-MOTION-PENDING MOUSE-ALTERNATE-CHARACTER-BLINKER) (PENDING-P)
  (WITH-SCREEN-CONTROLLER-LOCK ((SHEET-SCREEN SHEET))
    (WHEN (EQ (NULL PENDING-P) HOLLOW-P)
      (OPEN-BLINKER SELF)
      (SETF HOLLOW-P (NOT HOLLOW-P))
      (SWAPF ACTIVE-CHARACTER BACKUP-CHARACTER)
      (SWAPF ACTIVE-FONT BACKUP-FONT)
      (SWAPF ACTIVE-INDEX BACKUP-INDEX)
      (SWAPF CACHED-ACTIVE-CURSOR CACHED-BACKUP-CURSOR)
      (WHEN (EQ SELF (MOUSE-BLINKER (SHEET-MOUSE SHEET)))
	;; Send new character raster to mouse tracker, and refresh immediately
	(SEND SELF :TRACK-MOUSE T)))))

(COMPILE-FLAVOR-METHODS MOUSE-ALTERNATE-CHARACTER-BLINKER)

;;;

(DEFFLAVOR MOUSE-RECTANGULAR-BLINKER () (MOUSE-BLINKER-MIXIN RECTANGULAR-BLINKER))

(DEFFLAVOR MOUSE-HOLLOW-RECTANGULAR-BLINKER
	()
	(MOUSE-BLINKER-MIXIN HOLLOW-RECTANGULAR-BLINKER))

(DEFFLAVOR MOUSE-CHARACTER-BLINKER-WITH-INSIDE-LINE ()
	   (MOUSE-BLINKER-MIXIN CHARACTER-BLINKER-WITH-INSIDE-LINE))

(DEFFLAVOR CHARACTER-AND-STRING-MOUSE-BLINKER ()
	   (MOUSE-BLINKER-MIXIN CHARACTER-AND-STRING-BLINKER))

;;; If the mouse hasn't caught up, don't show string.  This doesn't work
;;; by opening the blinker here, because it won't get closed soon enough
;;; and you'll lose the arrow, too.
(DEFMETHOD (:SET-MOTION-PENDING CHARACTER-AND-STRING-MOUSE-BLINKER) (PENDING-P)
  (SETQ SUPPRESS-STRING PENDING-P))

(DEFFLAVOR CHARACTER-AND-OTHER-CHARACTER-MOUSE-BLINKER ()
	   (MOUSE-BLINKER-MIXIN CHARACTER-AND-OTHER-CHARACTER-BLINKER))

;;; If the mouse hasn't caught up, don't show string.  This doesn't work
;;; by opening the blinker here, because it won't get closed soon enough
;;; and you'll lose the arrow, too.
(DEFMETHOD (:SET-MOTION-PENDING CHARACTER-AND-OTHER-CHARACTER-MOUSE-BLINKER) (PENDING-P)
  (SETQ SUPPRESS-OTHER-CHARACTER PENDING-P))

(DEFFLAVOR CHARACTER-AND-STRING-AND-OTHER-CHARACTER-MOUSE-BLINKER ()
	   (MOUSE-BLINKER-MIXIN CHARACTER-AND-STRING-AND-OTHER-CHARACTER-BLINKER))

(COMPILE-FLAVOR-METHODS MOUSE-CHARACTER-BLINKER MOUSE-RECTANGULAR-BLINKER
			MOUSE-HOLLOW-RECTANGULAR-BLINKER
			MOUSE-CHARACTER-BLINKER-WITH-INSIDE-LINE
			CHARACTER-AND-STRING-MOUSE-BLINKER
			CHARACTER-AND-OTHER-CHARACTER-MOUSE-BLINKER
			CHARACTER-AND-STRING-AND-OTHER-CHARACTER-MOUSE-BLINKER)

(DEFVAR MOUSE-BLINKER-TYPES NIL)
(DEFUN MOUSE-DEFINE-BLINKER-TYPE (TYPE CREATION-FUN)
  (FLET ((DELASSTYPE (SEQ) (CL:DELETE-IF (LAMBDA (PAIR) (EQL (FIRST PAIR) TYPE)) SEQ)))
    (SETQ MOUSE-BLINKER-TYPES (DELASSTYPE MOUSE-BLINKER-TYPES))
    (PUSH (CONS TYPE CREATION-FUN) MOUSE-BLINKER-TYPES)
    ;; The screens have their own alist, mapping from blinker-type  blinker.
    ;; The old blinker (if any) of this type is hereby wrong, so remove it.  It
    ;; will be recomputed on demand.
    (DOLIST (SCREEN ALL-THE-SCREENS)
      (SEND SCREEN :SET-MOUSE-BLINKERS (DELASSTYPE (SEND SCREEN :MOUSE-BLINKERS))))
    (WHEN (AND MAIN-MOUSE (MOUSE-SHEET MAIN-MOUSE)) (MOUSE-GET-BLINKER TYPE))))

(DEFUN MOUSE-GET-BLINKER (TYPE &OPTIONAL SHEET MOUSE &AUX SCREEN BLINKERS)
  (WHEN (NULL MOUSE)
    (SETQ MOUSE (IF SHEET (SHEET-MOUSE SHEET) MAIN-MOUSE)))
  (WHEN (NULL SHEET)
    (SETQ SHEET (MOUSE-SHEET MOUSE)))
  (SETQ SCREEN (SHEET-GET-SCREEN SHEET))
  (LET ((BE (ASSQ TYPE MOUSE-BLINKER-TYPES)))
    (OR BE (FERROR NIL "~A is unknown mouse blinker type" TYPE))
    (LET ((BL (CDR (ASSQ TYPE (SETQ BLINKERS (SEND SCREEN ':MOUSE-BLINKERS))))))
      (COND ((NULL BL)
	     (SETQ BL (FUNCALL (CDR BE) SCREEN))
	     (PUSH (CONS TYPE BL) BLINKERS)
	     (SEND SCREEN ':SET-MOUSE-BLINKERS BLINKERS)))
      (BLINKER-SET-SHEET BL SHEET)
      BL)))

(DEFUN MOUSE-SET-BLINKER-DEFINITION (TYPE X-OFF Y-OFF VISIBILITY
				     MESSAGE &REST MESSAGE-ARGS)
  (LEXPR-FUNCALL #'MOUSE-SET-BLINKER-DEFINITION-INTERNAL
		 MAIN-MOUSE TYPE X-OFF Y-OFF VISIBILITY
		 MESSAGE MESSAGE-ARGS))

(DEFUN MOUSE-SET-BLINKER-DEFINITION-INTERNAL (MOUSE TYPE X-OFF Y-OFF VISIBILITY
					      MESSAGE &REST MESSAGE-ARGS)
  (LET ((BL (MOUSE-GET-BLINKER TYPE NIL MOUSE)))
    (AND (MOUSE-BLINKER MOUSE) (NEQ BL (MOUSE-BLINKER MOUSE))
	 (SEND (MOUSE-BLINKER MOUSE) ':SET-VISIBILITY NIL))
    (LEXPR-SEND BL MESSAGE MESSAGE-ARGS)
    (SEND BL ':SET-OFFSETS X-OFF Y-OFF)
    (SEND BL ':SET-CURSORPOS (- (MOUSE-X MOUSE) X-OFF (SHEET-INSIDE-LEFT (MOUSE-SHEET MOUSE)))
			     (- (MOUSE-Y MOUSE) Y-OFF (SHEET-INSIDE-TOP (MOUSE-SHEET MOUSE))))
    (SEND BL ':SET-VISIBILITY (IF (EQ VISIBILITY ':ON) T VISIBILITY))
    (SEND BL ':TRACK-MOUSE)
    (CL:SETF (MOUSE-BLINKER-NAME MOUSE) TYPE)
    BL))

(DEFUN MOUSE-SET-BLINKER (TYPE &OPTIONAL X-OFF Y-OFF (MOUSE MAIN-MOUSE))
  (LET ((BL (MOUSE-GET-BLINKER TYPE NIL MOUSE)))
    (AND (NEQ BL (MOUSE-BLINKER MOUSE)) (SEND (MOUSE-BLINKER MOUSE) ':SET-VISIBILITY NIL))
    (AND X-OFF (SEND BL ':SET-OFFSETS X-OFF Y-OFF))
    (SEND BL ':SET-CURSORPOS (- (MOUSE-X MOUSE) (OR X-OFF 0)
				(SHEET-INSIDE-LEFT (MOUSE-SHEET MOUSE)))
			     (- (MOUSE-Y MOUSE) (OR Y-OFF 0)
				(SHEET-INSIDE-TOP (MOUSE-SHEET MOUSE))))
    (SEND BL ':SET-VISIBILITY T)
    (SEND BL ':TRACK-MOUSE)
    (CL:SETF (MOUSE-BLINKER-NAME MOUSE) TYPE)
    BL))

(MOUSE-DEFINE-BLINKER-TYPE ':CHARACTER
			   #'(LAMBDA (SCREEN)
			       (MAKE-BLINKER SCREEN 'MOUSE-CHARACTER-BLINKER
				 :VISIBILITY T
				 :CHAR #\MOUSE:NW-ARROW)))
				 
(MOUSE-DEFINE-BLINKER-TYPE ':RECTANGLE-BLINKER
			   #'(LAMBDA (SCREEN)
			       (MAKE-BLINKER SCREEN 'MOUSE-CHARACTER-BLINKER
				 :VISIBILITY NIL
				 :CHAR #\MOUSE:NW-CORNER)))

(MOUSE-DEFINE-BLINKER-TYPE ':CHARACTER-WITH-INSIDE-LINE
			   #'(LAMBDA (SCREEN)
			       (MAKE-BLINKER SCREEN
					     'MOUSE-CHARACTER-BLINKER-WITH-INSIDE-LINE
					     :VISIBILITY NIL
					     :CHAR #\MOUSE:NW-ARROW)))

(MOUSE-DEFINE-BLINKER-TYPE :SOMETIMES-HOLLOW-CHARACTER
			   #'(LAMBDA (SCREEN)
			       (MAKE-BLINKER SCREEN 'MOUSE-ALTERNATE-CHARACTER-BLINKER
				 :VISIBILITY NIL)))

(MOUSE-DEFINE-BLINKER-TYPE :CHARACTER-AND-STRING
			   #'(LAMBDA (SCREEN)
			       (MAKE-BLINKER SCREEN 'CHARACTER-AND-STRING-MOUSE-BLINKER
				 :VISIBILITY NIL
				 :CHAR #\MOUSE:NW-ARROW
				 :STRING "" :STRING-X-OFFSET 10
				 :STYLE '(NIL NIL :VERY-SMALL))))

(MOUSE-DEFINE-BLINKER-TYPE :CHARACTER-AND-OTHER-CHARACTER
			   #'(LAMBDA (SCREEN)
			       (MAKE-BLINKER SCREEN
					     'CHARACTER-AND-OTHER-CHARACTER-MOUSE-BLINKER
				 :VISIBILITY NIL :X-OFFSET 6 :Y-OFFSET 6
				 :CHAR #\MOUSE:FAT-CIRCLE :OTHER-CHAR #\MOUSE:PLUS)))

;;; The entire Lord's Prayer on the head of a pin.
(MOUSE-DEFINE-BLINKER-TYPE :CHARACTER-AND-STRING-AND-OTHER-CHARACTER
			   #'(LAMBDA (SCREEN)
			       (MAKE-BLINKER SCREEN
				  'CHARACTER-AND-STRING-AND-OTHER-CHARACTER-MOUSE-BLINKER
				 :VISIBILITY NIL :X-OFFSET 6 :Y-OFFSET 6
				 :CHAR #\MOUSE:FAT-CIRCLE 
				 :STRING "" :STRING-X-OFFSET 15
				 :STYLE '(NIL NIL :VERY-SMALL)
				 :OTHER-CHAR #\MOUSE:PLUS)))

(DEFUN MOUSE-SET-BLINKER-CURSORPOS (&OPTIONAL WINDOW)
  (MOUSE-SET-BLINKER-CURSORPOS-INTERNAL (IF WINDOW (SHEET-MOUSE WINDOW) MAIN-MOUSE)))

(DEFUN MOUSE-SET-BLINKER-CURSORPOS-INTERNAL (MOUSE)
  (MULTIPLE-VALUE-BIND (X-OFF Y-OFF)
      (SEND (MOUSE-BLINKER MOUSE) ':OFFSETS)
    (BLINKER-SET-CURSORPOS
      (MOUSE-BLINKER MOUSE)
      (- (IF (MOUSE-WARP-INTERNAL MOUSE) (MOUSE-LAST-X MOUSE) (MOUSE-X MOUSE))
	 X-OFF (SHEET-INSIDE-LEFT (MOUSE-SHEET MOUSE)))
      (- (IF (MOUSE-WARP-INTERNAL MOUSE) (MOUSE-LAST-Y MOUSE) (MOUSE-Y MOUSE))
	 Y-OFF (SHEET-INSIDE-TOP  (MOUSE-SHEET MOUSE))))))

;;; MOUSE-SHEET of some mouse
(DEFUN MOUSE-DEFAULT-SUPERIOR (&OPTIONAL (SOME-WINDOW TERMINAL-IO))
  (OR (LET ((SCREEN (SEND-IF-HANDLES SOME-WINDOW :SCREEN)))
	(AND SCREEN (MOUSE-SHEET (SHEET-MOUSE SCREEN))))
      (MOUSE-SHEET MAIN-MOUSE)))

;;; Some screen
(DEFUN CONSOLE-DEFAULT-SUPERIOR (&OPTIONAL (SOME-WINDOW TERMINAL-IO))
  (OR (LET ((SCREEN (SEND-IF-HANDLES SOME-WINDOW :SCREEN)))
	(AND SCREEN (CONSOLE-SCREEN (SHEET-CONSOLE SCREEN))))
      DEFAULT-SCREEN))

(DEFUN MOUSE-CALL-SYSTEM-MENU (&OPTIONAL (SUPERIOR (MOUSE-DEFAULT-SUPERIOR)))
  (PROCESS-RUN-FUNCTION '(:NAME "System Menu" :PRIORITY 10.) #'CALL-SYSTEM-MENU SUPERIOR))

(DEFUN CALL-SYSTEM-MENU (SUPERIOR)
  (LET ((DEFAULT-SCREEN SUPERIOR)
	(*CONSOLE* (TV:SHEET-CONSOLE SUPERIOR)))
    (IF (CONSOLE-SYSTEM-MENU-ENABLED *CONSOLE*)
	(CATCH-ERROR-RESTART ((ABORT ERROR) "Exit system menu")
	  (USING-RESOURCE (MENU SYSTEM-MENU SUPERIOR)
	    (SEND MENU ':CHOOSE)))
      (BEEP))))

;;; This function as a warm initialization
;;; to initialize the mouse process and associated variable.
(DEFUN MOUSE-INITIALIZE (&OPTIONAL ONE-SCREEN)
  (SETQ MAIN-MOUSE NIL)
  (FLET ((MOUSE-INITIALIZE-SCREEN (SCREEN)
	   (MOUSE-INITIALIZE-INTERNAL (SHEET-MOUSE SCREEN) SCREEN)))
    (IF ONE-SCREEN
	(MOUSE-INITIALIZE-SCREEN ONE-SCREEN)
	(MAPC #'MOUSE-INITIALIZE-SCREEN *CONSOLE-SCREENS*)))
  NIL)

(DEFUN MOUSE-INITIALIZE-INTERNAL (MOUSE
				  &OPTIONAL (SHEET (CONSOLE-SCREEN (MOUSE-CONSOLE MOUSE))))
  (CL:SETF (MOUSE-WINDOW MOUSE) NIL
	   (WINDOW-OWNING-MOUSE-INTERNAL MOUSE) NIL
	   (MOUSE-BUTTONS-GRABBED MOUSE) NIL
	   (MOUSE-SHEET MOUSE) SHEET)
  (MOUSE-WARP-1 MOUSE 0 0)
  ;; Make sure at least one blinker of each type exists
  (MOUSE-GET-BLINKER :CHARACTER SHEET)
  (MOUSE-GET-BLINKER :RECTANGLE-BLINKER SHEET)
  (MOUSE-GET-BLINKER 'FLASHY-CHARACTER SHEET)
  (LET ((BL (MOUSE-BLINKER MOUSE)))
    (WHEN BL
      (IF (SHEET-OUTPUT-HELD-P (BLINKER-SHEET BL))
	  D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");this is an extreme measure, but better than getting stuck in output hold
0	  1;this can occur when the mouse sheet is no longer exposed (or exposable?)
0	  1;and we have to get the mouse off it somehow.  This situation arises during
0	  1;warm booting.
0	  (CL:SETF (SCL:SYMBOL-VALUE-IN-INSTANCE BL 'TV:VISIBILITY) NIL
		(SCL:SYMBOL-VALUE-IN-INSTANCE BL 'TV:PHASE) NIL)
	  (BLINKER-SET-VISIBILITY BL NIL)
	  )))
  (MOUSE-STANDARD-BLINKER NIL MOUSE)
  ;; Screens have margins just like regular windows; mouse-warp includes margins
  (MOUSE-WARP (- (SHEET-WIDTH (MOUSE-SHEET MOUSE))
		 (SHEET-RIGHT-MARGIN-SIZE (MOUSE-SHEET MOUSE))
		 8.)
	      (- (SHEET-HEIGHT (MOUSE-SHEET MOUSE))
		 (SHEET-BOTTOM-MARGIN-SIZE (MOUSE-SHEET MOUSE))
		 16.)
	      MOUSE)
  ;; Call MOUSE-INPUT once to flush any pending motion and update variables, but don't wait.
  (CL:SETF (MOUSE-BUTTONS-BUFFER-OUT-INDEX MOUSE) (MOUSE-BUTTONS-BUFFER-IN-INDEX MOUSE))
  (MOUSE-INPUT NIL MOUSE)
  (CL:SETF (MOUSE-X-SPEED MOUSE) 0
	   (MOUSE-Y-SPEED MOUSE) 0)
  (LET ((CONSOLE (MOUSE-CONSOLE MOUSE)))
    (WHEN (EQ CONSOLE *MAIN-CONSOLE*)
      (SETQ MAIN-MOUSE MOUSE)))
  (MOUSE-PROCESS-INITIALIZE MOUSE)
  NIL)

;;; This function changes the MOUSE-SHEET
;;; The MOUSE-SHEET has to be visible (we don't want the mouse to get an output-hold!)
;;; If the new mouse-sheet and the old one are on the same screen, the position
;;; of the mouse on the screen does not change unless it would lie outside the
;;; new sheet; in that case MOUSE-INPUT will warp it into the new sheet.
;;; Also set video on (used by color console).
(DEFUN MOUSE-SET-SHEET (NEW-SHEET &optional new-x new-y)
  (WHEN (ZEROP (SHEET-ALL-EXPOSED NEW-SHEET))
    (FERROR "Attempt to set MOUSE-SHEET to a non-visible sheet"))
  (LET ((SCR (SHEET-SCREEN NEW-SHEET)))
    (UNLESS (SEND SCR :VIDEO-ON)
      (SEND SCR :SET-VIDEO-ON T)))
  (LET ((MOUSE (SHEET-MOUSE NEW-SHEET)))
    (WITH-THIS-MOUSE-USURPED (MOUSE)
      (OPEN-MOUSE-CURSOR MOUSE)
      (LET* ((OLD-SHEET (MOUSE-SHEET MOUSE))
	     (OLD-SCREEN (AND OLD-SHEET (SHEET-SCREEN OLD-SHEET)))
	     (NEW-SCREEN (SHEET-SCREEN NEW-SHEET)))
	(CL:SETF (MOUSE-SHEET MOUSE) NEW-SHEET)
	(IF (EQ OLD-SCREEN NEW-SCREEN)
	    (MULTIPLE-VALUE-BIND (X1 Y1)
		(SHEET-CALCULATE-OFFSETS OLD-SHEET NIL)
	      (MULTIPLE-VALUE-BIND (X2 Y2)
		  (SHEET-CALCULATE-OFFSETS NEW-SHEET NIL)
		(MOUSE-WARP-1 MOUSE
			      (or new-x (+ (MOUSE-X MOUSE) (- X1 X2)))
			      (or new-y (+ (MOUSE-Y MOUSE) (- Y1 Y2))))))
	    (WHEN OLD-SCREEN
	      (MOUSE-WARP-1 MOUSE
			    (or new-x
				(FLOOR (* (MOUSE-X MOUSE) (SHEET-INSIDE-WIDTH NEW-SCREEN))
				       (SHEET-INSIDE-WIDTH OLD-SCREEN )))
			    (or new-y
				(FLOOR (* (MOUSE-Y MOUSE) (SHEET-INSIDE-HEIGHT NEW-SCREEN))
				       (SHEET-INSIDE-HEIGHT OLD-SCREEN)))))
	      ))
      (MOUSE-DISCARD-CLICKAHEAD MOUSE)		;Since the coordinate system has changed
      (MOUSE-STANDARD-BLINKER NIL MOUSE))))

;;; This function "warps" the mouse to a specified place
(DEFUN MOUSE-WARP (X Y &OPTIONAL (MOUSE MAIN-MOUSE))
  (WHEN (WITHOUT-INTERRUPTS
	  (WHEN (OR ( (MOUSE-X MOUSE) X) ( (MOUSE-Y MOUSE) Y))
	    (OPEN-MOUSE-CURSOR MOUSE)
	    (CL:SETF (MOUSE-WARP-INTERNAL MOUSE) T)
	    ;; "fix" the new X and Y coordinates for the mouse.  You shouldn't
	    ;; pass flonums anyway, but if you do you don't deserve to die...
	    (MOUSE-WARP-1 MOUSE
			  (MAX 0 (MIN (1- (SHEET-WIDTH (MOUSE-SHEET MOUSE)))
				      (ROUND X)))
			  (MAX 0 (MIN (1- (SHEET-HEIGHT (MOUSE-SHEET MOUSE)))
				      (ROUND Y))))
	    (MOUSE-RESUME-TRACKING MOUSE)
	    T))
    ;; do these outside the without-interrupts.
    (MOUSE-SET-BLINKER-CURSORPOS-INTERNAL MOUSE)
    (MOUSE-WAKEUP MOUSE)))			;Make sure the mouse tracker process notices

(DEFUN SHEET-MOUSE-OFFSETS (SHEET &OPTIONAL (ERROR-P T))
  (DECLARE (VALUES X-OFFSET Y-OFFSET MOUSE ERROR-P))
  (LET ((MOUSE (SHEET-MOUSE SHEET)))
    (MULTIPLE-VALUE-BIND (X Y ERROR)
	(SHEET-CALCULATE-OFFSETS SHEET (MOUSE-SHEET MOUSE) ERROR-P)
      (VALUES X Y MOUSE ERROR))))

(DEFUN SHEET-MOUSE-POSITION (WINDOW)
  (DECLARE (VALUES X-POSITION Y-POSITION))
  (MULTIPLE-VALUE-BIND (DX DY MOUSE)
      (SHEET-MOUSE-OFFSETS WINDOW)
    (VALUES (- (MOUSE-X MOUSE) DX) (- (MOUSE-Y MOUSE) DY))))

(DEFUN SHEET-IS-MOUSE-WINDOW-P (WINDOW)
  (LET ((SM (SHEET-MOUSE WINDOW)))
    (WHEN SM (EQ WINDOW (MOUSE-WINDOW SM)))))

(DEFUN SHUTDOWN-MICE ()
  (MAPC #'(LAMBDA (SCREEN)
	    (LET ((MOUSE (SHEET-MOUSE SCREEN)))
	      (WHEN MOUSE
		(SHUTDOWN-THIS-MOUSE MOUSE))))
	*CONSOLE-SCREENS*)
  NIL)

(DEFUN SHUTDOWN-THIS-MOUSE (MOUSE)
  ;; Tell the mouse process to switch "modes" and wait for it to do so
  (SETF (WINDOW-OWNING-MOUSE-INTERNAL MOUSE) 'STOP)
  (UNLESS (EQ (MOUSE-WINDOW MOUSE) 'STOP)
    (SETF (MOUSE-RECONSIDER MOUSE) T)
    (PROCESS:WAKEUP (MOUSE-PROCESS MOUSE))
    (WHEN (MOUSE-USURPED-PROCESS MOUSE)
      (PROCESS:WAKEUP (MOUSE-USURPED-PROCESS MOUSE)))
    (CATCH-ERROR-RESTART (ERROR "Proceed anyway.")
      (ERROR-RESTART (ERROR "Wait a while longer.")
	(UNLESS (PROCESS-WAIT-WITH-TIMEOUT "Shutdown Mouse" (* 10. 60.)
		  #'(LAMBDA ()
		      (AND (NULL (MOUSE-RECONSIDER MOUSE))
			   (EQ (MOUSE-WINDOW MOUSE) 'STOP))))
	  (ERROR "Mouse failed to shutdown after 10 seconds~%For ~A" MOUSE))))
    (SETF (MOUSE-WINDOW MOUSE) 'STOP))
  (SETF (MOUSE-SHEET MOUSE) NIL)
  (SETF (MOUSE-USURPED-PROCESS MOUSE) NIL)
  (MOUSE-PROCESS-SHUTDOWN MOUSE)
  (MOUSE-HALT-FAST-TRACKING MOUSE)
  NIL)



;;; This returns the lowest window under the mouse prepared to handle the given operation.
(DEFUN WINDOW-UNDER-MOUSE (&OPTIONAL METHOD (ACTIVE-CONDITION ':ACTIVE) X Y)
  (WINDOW-UNDER-MOUSE-INTERNAL MAIN-MOUSE METHOD ACTIVE-CONDITION X Y))

(DEFUN WINDOW-UNDER-MOUSE-INTERNAL (MOUSE &OPTIONAL METHOD (ACTIVE-CONDITION ':ACTIVE) X Y)
  (LOWEST-SHEET-UNDER-POINT (MOUSE-SHEET MOUSE) (OR X (MOUSE-X MOUSE)) (OR Y (MOUSE-Y MOUSE))
			    METHOD ACTIVE-CONDITION))

;;; This is the window or special thing that owns the mouse
(DEFUN WINDOW-OWNING-MOUSE (&OPTIONAL X Y (MOUSE MAIN-MOUSE))
  (OR (WINDOW-OWNING-MOUSE-INTERNAL MOUSE)
      (WINDOW-UNDER-MOUSE-INTERNAL MOUSE ':HANDLE-MOUSE ':EXPOSED X Y)))

;;; Use this to tell whether a certain window owns the mouse, or one of its inferiors does.
(DEFUN WINDOW-OWNS-MOUSE-P (WINDOW &OPTIONAL X Y MOUSE)
  (WHEN (NULL MOUSE)
    (SETQ MOUSE (IF (SYMBOLP WINDOW) MAIN-MOUSE (SHEET-MOUSE WINDOW))))
  (COND ((EQ WINDOW T)
	 (EQ (WINDOW-OWNING-MOUSE-INTERNAL MOUSE) T))
	((WINDOW-OWNING-MOUSE-INTERNAL MOUSE)
	 (DO W WINDOW (SHEET-SUPERIOR W) (NULL W)
	     (AND (EQ W (WINDOW-OWNING-MOUSE-INTERNAL MOUSE)) (RETURN T))))
	(T
	 (AND (SHEET-EXPOSED-P WINDOW)
	      (SHEET-CONTAINS-SHEET-POINT-P WINDOW (MOUSE-SHEET MOUSE)
					    (OR X (MOUSE-X MOUSE))
					    (OR Y (MOUSE-Y MOUSE)))))))

;;; A window's process should call this function when it wishes to seize
;;; the mouse to use it to get input that can range over the whole screen.
;;; To free the mouse again, setq WINDOW-OWNING-MOUSE to NIL again.
(DEFUN MOUSE-SEIZE (&OPTIONAL (MOUSE MAIN-MOUSE))
  (CL:SETF (WINDOW-OWNING-MOUSE-INTERNAL MOUSE)
	   (CONSOLE-SELECTED-WINDOW (MOUSE-CONSOLE MOUSE))))

;;; Call this function to awaken the mouse process
;;; whenever the layout of the screen changes, so that it can call WINDOW-OWNING-MOUSE
;;; and find out that the mouse should be under control of a different window.
(DEFVAR *DELAY-MOUSE-WAKEUP* NIL)

;;; If BACKGROUND is true, don't wakeup the process now, wait until it's polled
(DEFUN MOUSE-WAKEUP (&OPTIONAL (MOUSE MAIN-MOUSE) (BACKGROUND NIL))
  (WHEN MOUSE
    (UNLESS *DELAY-MOUSE-WAKEUP*
      (CL:SETF (MOUSE-WAKEUP-INTERNAL MOUSE) T)
      (UNLESS BACKGROUND
	(LET ((PROC (OR (MOUSE-USURPED-PROCESS MOUSE) (MOUSE-PROCESS MOUSE))))
	  (WHEN PROC
	    (PROCESS:WAKEUP PROC)))))))

(DEFUN MOUSE-MAYBE-WAKEUP (INTERVAL-IN-60THS &OPTIONAL (MOUSE MAIN-MOUSE))
  (WHEN MOUSE
    (UNLESS *DELAY-MOUSE-WAKEUP*
      (WITHOUT-INTERRUPTS
	(LET* ((NOW (TIME))
	       (THEN (TIME-INCREMENT NOW INTERVAL-IN-60THS)))
	  (IF (OR (NULL (MOUSE-MAYBE-WAKEUP-TIME MOUSE))
		  (TIME-LESSP THEN (MOUSE-MAYBE-WAKEUP-TIME MOUSE)))
	      (CL:SETF (MOUSE-MAYBE-WAKEUP-TIME MOUSE) THEN)))))))

(DEFMACRO DELAYING-MOUSE-WAKEUP (&BODY BODY)
  `(MULTIPLE-VALUE-PROG1
     (LET ((*DELAY-MOUSE-WAKEUP* T))
       . ,BODY)
     (MOUSE-WAKEUP)))


;;; MOUSE-OVERSEER
;;; This is the top-level function of the mouse process.  It tracks the
;;; mouse and does default things with the buttons.  If the mouse enters
;;; the region of the screen occupied by a window that has its own mouse handler,
;;; that mouse handler is called.  It then has control of the mouse until
;;; it returns.  Both this function and specialized mouse handlers are
;;; to call the above low-level routines.  MOUSE-WINDOW is the window which
;;; has control of the mouse, or NIL if there is none.  Note that window
;;; need not be selected, nor exposed.  It does have to be active.
;;; Mouse handlers are free to mung the mouse blinker however they like.
;;; The mouse overseer is guaranteed to put it back.

;;; Most mouse handlers will return whenever WINDOW-OWNING-MOUSE says that the
;;; mouse has moved outside of the visible part of that window.  Some however,
;;; will not return until they feel like it.
;;; The convention to be used is up to the individual handler.

;;; Frobbing with MOUSE-RECONSIDER is for race-free interface with WITH-MOUSE-GRABBED
(DEFUN MOUSE-OVERSEER (MOUSE)
  (CONDITION-BIND-DEFAULT ((ERROR #'(LAMBDA (ERROR)
				      (ERROR-IN-MOUSE-PROCESS ERROR MOUSE))))
    (ERROR-RESTART-LOOP ((ERROR ABORT) "MOUSE-OVERSEER")
      (CL:SLEEP (// 1. 60s0))
      (CL:SETF (MOUSE-RECONSIDER MOUSE) NIL)	      
      (LET* ((DEBUG-IO TERMINAL-IO)		;Can get setq'ed by an error
	     (MW (WITHOUT-INTERRUPTS (CL:SETF (MOUSE-WINDOW MOUSE)
					      (WINDOW-OWNING-MOUSE NIL NIL MOUSE))))
	     (MS (MOUSE-SHEET MOUSE)))
	;; Wakeup processes that might be waiting for this mouse process to get to here
	(LET ((N *NUMBER-OF-MOUSE-WAITERS*))
	  (WHEN (PLUSP N)
	    (LET ((WAITERS *MOUSE-WAITERS*))
	      (DECLARE (SYS:ARRAY-REGISTER WAITERS))
	      (LOOP FOR I FROM 0 BELOW N DO
		(PROCESS:PROCESS-WAKEUP (AREF WAITERS I))))))
	;; Don't do (MOUSE-SET-BLINKER-CURSORPOS-INTERNAL MOUSE),
	;; not necessary when running handler; dangerous when mouse usurped.
	(COND ((EQ MW 'STOP)
	       ;; Stop tracking the mouse; do what (MOUSE-BLINKER-MIXIN :TRACK-MOUSE) does.
	       (SEND (MOUSE-BLINKER MOUSE) :SET-VISIBILITY NIL)
	       (MOUSE-HALT-FAST-TRACKING MOUSE)
	       (PROCESS-WAIT "Usurped"
		 #'(LAMBDA (MOUSE)
		     (OR (MOUSE-RECONSIDER MOUSE)	;This can happen randomly 
			 (NEQ (WINDOW-OWNING-MOUSE-INTERNAL MOUSE) 'STOP)))
		 MOUSE))
	      (T
	       (NEED-MOUSE-DOCUMENTATION-UPDATE)
	       (UNLESS (AND (REMOTE-MOUSE-P MOUSE)
			    (NULL (WINDOW-OWNING-MOUSE-INTERNAL MOUSE)))
		 ;; Make sure the mouse is really on the sheet.
		 (MOUSE-WARP (MAX 0 (MIN (SHEET-WIDTH MS) (MOUSE-X MOUSE)))
			     (MAX 0 (MIN (SHEET-HEIGHT MS) (MOUSE-Y MOUSE)))
			     MOUSE))
	       (CL:TYPECASE MW
		 (CL:NULL
		   (MOUSE-STANDARD-BLINKER MS MOUSE)
		   (MOUSE-DEFAULT-HANDLER MW NIL MOUSE))
		 (CL:SYMBOL
		   (MOUSE-DEFAULT-HANDLER MW NIL MOUSE))
		 (OTHERWISE
		   (SEND MW :HANDLE-MOUSE)))))))))

(DEFUN ERROR-IN-MOUSE-PROCESS (IGNORE MOUSE)
  (COND ((AND (TYPEP (MOUSE-WINDOW MOUSE) 'SHEET)
	      (NOT (SHEET-CAN-GET-LOCK (MOUSE-WINDOW MOUSE) T)))
	 ;; The mouse process holds a window system lock, so use cold load stream
	 (SETQ DEBUG-IO "Error in the mouse process"))
	(T
	 ;; Normally, we can take the error in a background window.
	 (CL:SETF (MOUSE-WINDOW MOUSE) 'STOP)	;This should allow the background window to come up
	 (MOUSE-HALT-FAST-TRACKING MOUSE)))	;Kill mouse cursor so user realizes problem
  NIL)

;; Magic adjustments

;; Magic top-level values for scroll bar parameters
;; These can be bound by :HANDLE-MOUSE methods.
(DEFCONST SCROLL-BAR-MAX-SPEED 4)		;Speed at which scroll bar gets ignored
						;Smaller on 3600 because at 7 ips console or
						; FEP loses characters, so can't move so fast
(DEFCONST SCROLL-BAR-MAX-EXIT-SPEED NIL)	;Speed at which you leave scroll bar
(DEFCONST SCROLL-BAR-RELUCTANCE 10.)		;Pixels before entering scroll bar
(DEFCONST SCROLL-BAR-WIDTH 40.)			;Width of scroll bar region

#|
(DEFCONST MOUSE-FAST-MOTION-SPEED 30.)		;Moving faster than this
(DEFCONST MOUSE-FAST-MOTION-CROSS-SIZE 40.)	; triggers a cross 1 cm in diameter
(DEFCONST MOUSE-FAST-MOTION-CROSS-TIME 2000.)	; which lasts this long (DO-loop units)
|#

;; MOUSE-DEFAULT-HANDLER serves for windows which want to do things the simple way.
;; 
;; The first argument should be the window the mouse is in. This function is also used to
;; track the mouse when it isn't inside any window by calling it with a first argument of
;; NIL. A first argument of T is used when the mouse has been seized by a process not for
;; any specific window.
;;
;; The scroll-bar argument controls wether or not the window should have a scroll bar.
;; This argument is interpreted as follows:
;;
;;  Not supplied (or NIL)                    - The window should not have a scroll bar.
;;
;;  A list of any of the margin symbols.     - The window should have a scroll bar in
;;  (:LEFT :TOP :RIGHT :BOTTOM)                each of those margins.
;;
;;  One of the in-margin symbols             - The mouse is already in that particular
;;  (:IN-LEFT :IN-TOP :IN-RIGHT :IN-BOTTOM)    scroll bar.
;;
;; For backwards compatibility, a single T is treated as (:LEFT), and a single :IN is
;; treated as :IN-LEFT.

(DEFVAR *IN-SCROLL-MARGIN* NIL)

(DEFUN MOUSE-DEFAULT-HANDLER (WINDOW &OPTIONAL SCROLL-BAR
					       (MOUSE (IF (INSTANCEP WINDOW)
							  (SHEET-MOUSE WINDOW)
							  MAIN-MOUSE))
				     &AUX MOVE-HANDLER MOVE-METHOD BUTTONS-METHOD
					  (WINDOW-X-OFFSET 0) (WINDOW-Y-OFFSET 0)
					  WINDOW-X WINDOW-Y
					  WINDOW-WIDTH WINDOW-HEIGHT)
  ;; Backwards compatibility for the scroll-bar argument. It used to be a
  ;; single symbol, T meant what (:LEFT) means, :IN meant what :IN-LEFT means.
  (COND ((EQ SCROLL-BAR T) (SETQ SCROLL-BAR '(:LEFT)))
	((EQ SCROLL-BAR ':IN) (SETQ SCROLL-BAR ':IN-LEFT)))
  (MULTIPLE-VALUE (MOVE-METHOD BUTTONS-METHOD)
    (IF (AND SCROLL-BAR (SYMBOLP SCROLL-BAR))
	(VALUES ':MOUSE-MOVES-SCROLL ':MOUSE-BUTTONS-SCROLL)
	(VALUES ':MOUSE-MOVES ':MOUSE-BUTTONS)))
  (SETQ MOVE-HANDLER (IF (AND (NOT (SYMBOLP WINDOW)) (GET-HANDLER-FOR WINDOW MOVE-METHOD))
			 WINDOW
			 #'(LAMBDA (&REST IGNORE)
			     (DECLARE (DOWNWARD-FUNCTION))
			     (MOUSE-SET-BLINKER-CURSORPOS-INTERNAL MOUSE))))
  (UNLESS (SYMBOLP WINDOW)
    (MULTIPLE-VALUE (WINDOW-X-OFFSET WINDOW-Y-OFFSET)
      (SHEET-CALCULATE-OFFSETS WINDOW (MOUSE-SHEET MOUSE) NIL))
    (UNLESS (AND WINDOW-X-OFFSET WINDOW-Y-OFFSET)
      (RETURN-FROM MOUSE-DEFAULT-HANDLER NIL ))
    (SETQ WINDOW-WIDTH (SHEET-WIDTH WINDOW)
	  WINDOW-HEIGHT (SHEET-HEIGHT WINDOW)))
  (DO ((DX) (DY) (BU) (BD) (HAND) (X) (Y)
       (OLD-OWNER (WINDOW-OWNING-MOUSE-INTERNAL MOUSE) (WINDOW-OWNING-MOUSE-INTERNAL MOUSE))
       (X-OFFSET 0) (Y-OFFSET 0)
       (WAIT-FLAG NIL T))
      ((MOUSE-RECONSIDER MOUSE))
    (MULTIPLE-VALUE (DX DY BD BU X Y) (MOUSE-INPUT WAIT-FLAG MOUSE))
    ;; If asked to reconsider, do so immediately.
    ;; Don't bother updating blinker since it is likely to change soon, and
    ;; in any case we are going to be called back shortly.
    (IF (MOUSE-RECONSIDER MOUSE) (RETURN NIL))
    ;; Update console-idle time when buttons pushed
    (IF (NOT (ZEROP BD)) (SETF (CONSOLE-LAST-ACTIVITY-TIME (MOUSE-CONSOLE MOUSE)) (TIME)))
    (SETQ WINDOW-X (- X WINDOW-X-OFFSET)
	  WINDOW-Y (- Y WINDOW-Y-OFFSET))
    ;; X-OFFSET is how far out the sides of the window the mouse has moved, or 0 if the
    ;; mouse is inside the window. If x-offset is negative the mouse has moved outside
    ;; the left of the window, if it is positive the mouse has moved outside the right
    ;; of the window. Y-OFFSET is similar, with negative => top, positive => bottom.
    ;;
    ;; If the side of the window the mouse is moving out of is at an edge of the screen,
    ;; MOUSE-X/MOUSE-Y will not move out the edge of the window, but DX/DY will. This
    ;; extra movement is accumulated into X-OFFSET/Y-OFFSET.
    (UNLESS (SYMBOLP WINDOW)
      (COND (( WINDOW-X 0)	; not < if you want scroll bars at screen edge to work
	     (SETQ X-OFFSET (IF (MINUSP X-OFFSET)
				(MIN (+ X-OFFSET DX) -1)
				-1)))		;First time, don't use all of DX
	    (( WINDOW-X (1- WINDOW-WIDTH))
	     (SETQ X-OFFSET (IF (PLUSP X-OFFSET)
				(MAX (+ X-OFFSET DX) 1)
				1)))		;First time, don't use all of DX
	    ((AND (> WINDOW-X SCROLL-BAR-RELUCTANCE)
		  ( WINDOW-X (- WINDOW-WIDTH SCROLL-BAR-RELUCTANCE)))
	     (SETQ X-OFFSET 0)))
      (COND (( WINDOW-Y 0)	; not < if you want scroll bars at screen edge to work
	     (SETQ Y-OFFSET (IF (MINUSP Y-OFFSET)
				(MIN (+ Y-OFFSET DY) -1)
				-1)))		;First time, don't use all of DY
	    (( WINDOW-Y (1- WINDOW-HEIGHT))
	     (SETQ Y-OFFSET (IF (PLUSP Y-OFFSET)
				(MAX (+ Y-OFFSET DY) 1)
				1)))		;First time, don't use all of DY
	    ((AND (> WINDOW-Y SCROLL-BAR-RELUCTANCE)
		  ( WINDOW-Y (- WINDOW-HEIGHT SCROLL-BAR-RELUCTANCE)))
	     (SETQ Y-OFFSET 0)))
      (UNLESS (or (mouse-warp-internal mouse)
		  (AND (ZEROP X-OFFSET) (ZEROP Y-OFFSET)))
	(SEND-IF-HANDLES WINDOW :MOUSE-EXIT X-OFFSET Y-OFFSET WINDOW-X WINDOW-Y)))
    ;; Consider entering the scroll bar. [Perhaps this should be changed so that it is
    ;; in the move-handler rather than here. The problem would be communicating the
    ;; values of X-OFFSET/Y-OFFSET to the move handler.]
    ;; 
    ;; If there is a scroll bar and we are entering it, activate it. However, the mouse
    ;; must move at least a certain distance past the edge of the window in order to
    ;; qualify for scrolling (this is set by the SCROLL-BAR-RELUCTANCE variable in the
    ;; window).  Before entering scroll bar, send a :MOUSE-MOVES message in order to let
    ;; the window know what's happening.
    (UNLESS (OR OLD-OWNER
		(WINDOW-OWNING-MOUSE-INTERNAL MOUSE)
		(NULL SCROLL-BAR)
		(MOUSE-WARP-INTERNAL MOUSE)
		)				;These disable scroll bar
      (COND ((LISTP SCROLL-BAR)
	     (LET ((*IN-SCROLL-MARGIN*
		     (CAR (OR (AND (MINUSP X-OFFSET) (MEMQ ':LEFT   SCROLL-BAR))
			      (AND (PLUSP X-OFFSET)  (MEMQ ':RIGHT  SCROLL-BAR))
			      (AND (MINUSP Y-OFFSET) (MEMQ ':TOP    SCROLL-BAR))
			      (AND (PLUSP Y-OFFSET)  (MEMQ ':BOTTOM SCROLL-BAR))))))
	       (WHEN *IN-SCROLL-MARGIN*
		 (COND ((AND SCROLL-BAR-MAX-SPEED (> (MOUSE-SPEED MOUSE)
						     SCROLL-BAR-MAX-SPEED))
			(RETURN NIL))		;Too fast, pass right through
		       ((OR (> (ABS X-OFFSET) SCROLL-BAR-RELUCTANCE)
			    (> (ABS Y-OFFSET) SCROLL-BAR-RELUCTANCE))
			(FUNCALL MOVE-HANDLER MOVE-METHOD WINDOW-X WINDOW-Y)
			(RETURN (FUNCALL WINDOW ':HANDLE-MOUSE-SCROLL)))
		       (T
			(COND ((MINUSP X-OFFSET) (SETQ WINDOW-X 0))
			      ((PLUSP X-OFFSET) (SETQ WINDOW-X (SHEET-INSIDE-WIDTH WINDOW)))
			      ((PLUSP Y-OFFSET) (SETQ WINDOW-Y (SHEET-INSIDE-HEIGHT WINDOW)))
			      ((MINUSP Y-OFFSET) (SETQ WINDOW-Y 0))))))))
	    ((SYMBOLP SCROLL-BAR)
	     ;; We are in a scroll bar.  Moving the mouse faster than the exit speed,
	     ;; or moving it towards the center of the window by more than the scroll
	     ;; bar width will escape. Cannot escape by moving outside the window.
	     ;; [This is different from the previous algorithm, which involved a
	     ;; "hidden variable" which let you out when you moved the mouse (but
	     ;; not the cursor) more than a certain amount to the "left or right".]
	     (COND ((AND SCROLL-BAR-MAX-EXIT-SPEED
			 (> (MOUSE-SPEED MOUSE) SCROLL-BAR-MAX-EXIT-SPEED))
		    ;; Moving like a bat, let the guy out of the scroll bar
		    (RETURN NIL))
		   ((NOT (AND ( 0 WINDOW-X) (< WINDOW-X WINDOW-WIDTH)
			      ( 0 WINDOW-Y) (< WINDOW-Y WINDOW-HEIGHT)))
		    (WITHOUT-INTERRUPTS
		      (OPEN-MOUSE-CURSOR MOUSE)
		      (CL:SETF WINDOW-X (MIN (MAX WINDOW-X 0) (- WINDOW-WIDTH 1))
			       WINDOW-Y (MIN (MAX WINDOW-Y 0) (- WINDOW-HEIGHT 1)))
		      (MOUSE-WARP-1 MOUSE
				    (+ WINDOW-X-OFFSET WINDOW-X)
				    (+ WINDOW-Y-OFFSET WINDOW-Y))
		      (MOUSE-RESUME-TRACKING MOUSE)))
		   ((OR (AND (EQ SCROLL-BAR ':IN-LEFT)  (> WINDOW-X SCROLL-BAR-WIDTH))
			(AND (EQ SCROLL-BAR ':IN-TOP)   (> WINDOW-Y SCROLL-BAR-WIDTH))
			(AND (EQ SCROLL-BAR ':IN-RIGHT)
			     (< WINDOW-X (- WINDOW-WIDTH SCROLL-BAR-WIDTH)))
			(AND (EQ SCROLL-BAR ':IN-BOTTOM)
			     (< WINDOW-Y (- WINDOW-HEIGHT SCROLL-BAR-WIDTH))))
		    (RETURN NIL))))))
    ;; Update the position of the mouse before checking for button clicks, so
    ;; that button clicks get processed with knowledge of where the mouse
    ;; was when the button was first clicked.  The arguments to the move handler
    ;; may be where the mouse was when the button was clicked, whereas the
    ;; mouse cursor follows MOUSE-X and MOUSE-Y, which may be different.    
    (CL:SETF (MOUSE-WARP-INTERNAL MOUSE) NIL)
    (FUNCALL MOVE-HANDLER MOVE-METHOD WINDOW-X WINDOW-Y)
    ;; Check for all the ways of losing control of the mouse.
    (IF (COND ;; The move handler may have decided to warp the mouse so that it will not
	  ;; move out of the window.  This test is a crock but should work.
	  ((MOUSE-WARP-INTERNAL MOUSE) NIL)
	  ;; Check for mouse seized, becoming seized, or ceasing to be seized
	  ((OR (WINDOW-OWNING-MOUSE-INTERNAL MOUSE) (EQ WINDOW T))
	   (NOT (WINDOW-OWNS-MOUSE-P WINDOW X Y MOUSE)))
	  ;; Check for moving into a window when not in any
	  ((NULL WINDOW)
	   (WINDOW-OWNING-MOUSE X Y MOUSE))
	  ;; Check for leaving the boundaries of the current window
	  ;; HYSTERETIC-WINDOW-MIXIN requires that we wait at least once before returning
	  ((NOT (AND (SHEET-EXPOSED-P WINDOW)
		     ( WINDOW-X 0)
		     (< WINDOW-X (SHEET-WIDTH WINDOW))
		     ( WINDOW-Y 0)
		     (< WINDOW-Y (SHEET-HEIGHT WINDOW))))
	   WAIT-FLAG)
	  ;; Check for moving into an inferior of the current window
	  ((NEQ (LOWEST-SHEET-UNDER-POINT WINDOW WINDOW-X WINDOW-Y ':HANDLE-MOUSE ':EXPOSED)
		WINDOW)
	   T))
	;; Return to overseer, saving any pending button click.
	(RETURN (MOUSE-DEFER-BUTTONS BU BD MOUSE)))
    ;; Now process button pushes if mouse is not seized
    (COND ((OR (ZEROP BD) (EQ WINDOW T) OLD-OWNER))
	  ;; If over an exposed window, send it the button-push
	  (WINDOW (FUNCALL WINDOW BUTTONS-METHOD BD WINDOW-X WINDOW-Y))
	  ;; Default action for left button is to select what mouse is pointing at
	  ((BIT-TEST 1 BD)
	   (AND (SETQ HAND (WINDOW-UNDER-MOUSE-INTERNAL MOUSE ':MOUSE-SELECT ':ACTIVE X Y))
		;; Next line temporarily papers over a bug with :MOUSE-SELECT
		(GET-HANDLER-FOR HAND ':SELECT)
		(MOUSE-SELECT HAND)))
	  ;; Default action for middle button is to switch to the main screen
	  ((BIT-TEST 2 BD)
	   (WHEN (AND (EQ MOUSE (SHEET-MOUSE DEFAULT-SCREEN))
		      (TYPEP (MOUSE-SHEET MOUSE) 'SCREEN))
	     (PROCESS-RUN-FUNCTION "Set mouse sheet" #'MOUSE-SET-SHEET DEFAULT-SCREEN)))
	  ;; Default action for right button is to call the system menu
	  ((BIT-TEST 4 BD)
	   (CONSIDER-MOUSE-CALL-SYSTEM-MENU (MOUSE-BUTTON-ENCODE BD MOUSE) NIL X Y MOUSE)))))

(DEFUN CONSIDER-MOUSE-CALL-SYSTEM-MENU (BUTTON WINDOW X Y &OPTIONAL MOUSE)
  (WHEN (NULL MOUSE)
    (SETQ MOUSE (IF (INSTANCEP WINDOW) (SHEET-MOUSE WINDOW) MAIN-MOUSE)))
  (SELECTOR BUTTON CHAR-MOUSE-EQUAL
    ((#\sh-Mouse-R #\Mouse-R)
     (MOUSE-CALL-SYSTEM-MENU (MOUSE-SHEET MOUSE)))
    ((#\m-sh-Mouse-R)
     (IF WINDOW
	 (MOUSE-CALL-WINDOW-EDIT WINDOW X Y)
	 (LET ((WIN (WINDOW-UNDER-MOUSE-INTERNAL MOUSE :MOUSE-SELECT :ACTIVE X Y)))
	   (IF WIN
	       (MULTIPLE-VALUE-BIND (DX DY)
		   (SHEET-CALCULATE-OFFSETS WIN (MOUSE-SHEET MOUSE))
		 (MOUSE-CALL-WINDOW-EDIT WIN (- X DX) (- Y DY)))
	       (BEEP)))))
    (OTHERWISE (BEEP))))

;It is often useful for mouse commands to keep doing things in the window's process
;as MOUSE-DEFAULT-HANDLER keeps tracking the mouse and updating MOUSE-X and MOUSE-Y
;in the mouse process.  The mouse command can use this function to wait for
;something to happen.  For best results, to avoid timing errors,
;the command should examine the values of MOUSE-X and MOUSE-Y,
;use them, and supply the same values as arguments to this function.
;This function works whether or not you call it inside of WITH-MOUSE-AND-BUTTONS-GRABBED.
;Callers that only care about the buttons, and don't want to wake up if the mouse
;moves, should call WAIT-FOR-MOUSE-BUTTON-DOWN or WAIT-FOR-MOUSE-BUTTON-UP.
;and one for the following three functions.
(DEFUN MOUSE-WAIT (&REST ARGS)
  (DECLARE (ARGLIST &OPTIONAL (OLD-X MOUSE-X)
			      (OLD-Y MOUSE-Y)
			      (OLD-BUTTONS MOUSE-LAST-BUTTONS)
			      (WHOSTATE "Mouse")
			      (TIMEOUT NIL))
	   (VALUES BUTTONS X Y))
  (LEXPR-FUNCALL #'MOUSE-WAIT-INTERNAL MAIN-MOUSE ARGS))

(DEFUN MOUSE-WAIT-INTERNAL (MOUSE &OPTIONAL (OLD-X (MOUSE-X MOUSE))
					    (OLD-Y (MOUSE-Y MOUSE))
					    (OLD-BUTTONS (MOUSE-LAST-BUTTONS MOUSE))
					    (WHOSTATE "Mouse")
					    (TIMEOUT NIL))
  (PROCESS-WAIT-WITH-TIMEOUT WHOSTATE TIMEOUT
    (IF (MOUSE-BUTTONS-GRABBED MOUSE)
	#'(LAMBDA (OLD-X OLD-Y OLD-BUTTONS)
	    (OR ( (MOUSE-X MOUSE) OLD-X)
		( (MOUSE-Y MOUSE) OLD-Y)
		( (MOUSE-BUTTONS-BUFFER-IN-INDEX MOUSE)
		   (MOUSE-BUTTONS-BUFFER-OUT-INDEX MOUSE))
		( (MOUSE-BUTTONS-INTERNAL MOUSE) OLD-BUTTONS)))
	#'(LAMBDA (OLD-X OLD-Y OLD-BUTTONS)
	    (OR ( (MOUSE-X MOUSE) OLD-X)
		( (MOUSE-Y MOUSE) OLD-Y)
		( (MOUSE-LAST-BUTTONS MOUSE) OLD-BUTTONS))))
    OLD-X OLD-Y OLD-BUTTONS)
  (COND ((MOUSE-BUTTONS-GRABBED MOUSE)
	 (MULTIPLE-VALUE-BIND (BUTTONS TIME X Y)
	     (MOUSE-BUTTONS NIL MOUSE)
	   (CL:SETF (MOUSE-LAST-BUTTONS MOUSE) BUTTONS
		    (MOUSE-LAST-BUTTONS-TIME MOUSE) TIME
		    (MOUSE-LAST-BUTTONS-X MOUSE) X
		    (MOUSE-LAST-BUTTONS-Y MOUSE) Y)
	   (VALUES BUTTONS X Y)))
	(T (VALUES (MOUSE-LAST-BUTTONS MOUSE) (MOUSE-X MOUSE) (MOUSE-Y MOUSE)))))

;;; This expects to be called inside a WITH-MOUSE-AND-BUTTONS-GRABBED,
;;; but will also work in an ordinary environment (only for compatibility
;;; with any old code that may have been calling this).  In the latter case
;;; it may miss mouse clicks that go by too quickly.
(DEFUN WAIT-FOR-MOUSE-BUTTON-DOWN (&OPTIONAL (PROMPT "Button") (TIMEOUT NIL) WAIT-FUNCTION
					     (MOUSE MAIN-MOUSE))
  (DECLARE (VALUES BUTTONS X Y))
  (COND ((MOUSE-BUTTONS-GRABBED MOUSE)
	  ;; In case this was called in response to a mouse click, wait for
	  ;; the buttons to be released.  Then wait for a button to be depressed.
	  (LOOP WITH START-TIME = (TIME) WITH WAIT-FOR-UP = T DOING
	    (MULTIPLE-VALUE-BIND (BUTTONS TIME X Y)
		(MOUSE-BUTTONS NIL MOUSE)
	      (CL:SETF (MOUSE-LAST-BUTTONS MOUSE) BUTTONS
		       (MOUSE-LAST-BUTTONS-TIME MOUSE) TIME
		       (MOUSE-LAST-BUTTONS-X MOUSE) X
		       (MOUSE-LAST-BUTTONS-Y MOUSE) Y))
	    (COND ((AND WAIT-FUNCTION (FUNCALL WAIT-FUNCTION))
		   (RETURN))
		  ((AND TIMEOUT (TIME-ELAPSED-P TIMEOUT START-TIME))
		   ;; Time is up.
		   (RETURN))
		  ((ZEROP (MOUSE-LAST-BUTTONS MOUSE))
		   ;; No depressed buttons, now just wait for the next button depression.
		   (SETQ WAIT-FOR-UP NIL)) 
		  ((NOT WAIT-FOR-UP)
		   ;; Button is depressed after we've seen it undepressed.
		   (RETURN)))
	    (PROCESS-WAIT (IF WAIT-FOR-UP "Release Button" PROMPT)
	      #'MOUSE-BUTTON-WAIT-FUNCTION MOUSE TIMEOUT START-TIME WAIT-FUNCTION)))
	(T
	  ;; This clause is only for compatibility with old programs.
	  ;; In case this was called in response to a mouse click, wait for
	  ;; the buttons to be released.
	  (PROCESS-WAIT "Release Button" #'(LAMBDA () (ZEROP (MOUSE-LAST-BUTTONS MOUSE))))
	  (PROCESS-WAIT PROMPT #'(LAMBDA () (NOT (ZEROP (MOUSE-LAST-BUTTONS MOUSE)))))))
  (VALUES (MOUSE-LAST-BUTTONS MOUSE)
	  (MOUSE-LAST-BUTTONS-X MOUSE) (MOUSE-LAST-BUTTONS-Y MOUSE)))

;;; Must be called inside of WITH-MOUSE-AND-BUTTONS-GRABBED
;;; Returns new state of buttons (zero unless timed out)
(DEFUN WAIT-FOR-MOUSE-BUTTON-UP (&OPTIONAL (PROMPT "Release Button") (TIMEOUT NIL)
					   (MOUSE MAIN-MOUSE))
  (DECLARE (VALUES BUTTONS X Y))
  (LOOP WITH START-TIME = (TIME) DOING
    (MULTIPLE-VALUE-BIND (BUTTONS TIME X Y)
	(MOUSE-BUTTONS NIL MOUSE)
      (CL:SETF (MOUSE-LAST-BUTTONS MOUSE) BUTTONS
	       (MOUSE-LAST-BUTTONS-TIME MOUSE) TIME
	       (MOUSE-LAST-BUTTONS-X MOUSE) X
	       (MOUSE-LAST-BUTTONS-Y MOUSE) Y))
    (COND ((ZEROP (MOUSE-LAST-BUTTONS MOUSE)) (RETURN))
	  ((AND TIMEOUT (TIME-ELAPSED-P TIMEOUT START-TIME)) (RETURN)))
    (PROCESS-WAIT PROMPT #'MOUSE-BUTTON-WAIT-FUNCTION MOUSE TIMEOUT START-TIME))
  (VALUES (MOUSE-LAST-BUTTONS MOUSE)
	  (MOUSE-LAST-BUTTONS-X MOUSE) (MOUSE-LAST-BUTTONS-Y MOUSE)))

;;; PROCESS-WAIT function that waits until mouse buttons change,
;;; or an entry gets created in the mouse-buttons buffer that happens to be
;;; equal to the current state of the buttons, or the timeout expires.
(DEFUN MOUSE-BUTTON-WAIT-FUNCTION (MOUSE TIMEOUT START-TIME &OPTIONAL WAIT-FUNCTION)
  (OR (AND WAIT-FUNCTION (FUNCALL WAIT-FUNCTION))
      ( (MOUSE-BUTTONS-BUFFER-IN-INDEX MOUSE) (MOUSE-BUTTONS-BUFFER-OUT-INDEX  MOUSE))
      ( (MOUSE-BUTTONS-INTERNAL MOUSE) (MOUSE-LAST-BUTTONS MOUSE))
      (AND TIMEOUT (TIME-ELAPSED-P TIMEOUT START-TIME))))

;  (:DOCUMENTATION :MIXIN "Sticks clicks in input buffer as characters
;Clicking on the window when it is not selected will select it; mouse-right-twice
;calls the system menu; any other number of mouse clicks is sent as a fixnum
;via :force-kdb-input, %%kbd-mouse-button is button clicked on, %%kbd-mouse-n-clicks
;the number of click."))

(DEFFLAVOR ESSENTIAL-MOUSE () ()
  (:REQUIRED-FLAVORS ESSENTIAL-WINDOW)
  (:METHOD-COMBINATION :MOUSE-CLICK :OR))

(DEFMETHOD (:HANDLE-MOUSE ESSENTIAL-MOUSE) ()
  (MOUSE-STANDARD-BLINKER SELF)
  (MOUSE-DEFAULT-HANDLER SELF (SEND SELF ':SCROLL-BAR-P)))

(DEFMETHOD (:SET-MOUSE-CURSORPOS ESSENTIAL-MOUSE) (X Y)
  (SEND SELF ':SET-MOUSE-POSITION (+ (SHEET-INSIDE-LEFT) X) (+ (SHEET-INSIDE-TOP) Y)))

(DEFMETHOD (:SET-MOUSE-POSITION ESSENTIAL-MOUSE) (X Y &OPTIONAL (ERROR-P T)
						      &AUX X-OFF Y-OFF)
  (LET ((MOUSE (SHEET-MOUSE SELF)))
    (COND ((SHEET-ME-OR-MY-KID-P SELF (MOUSE-SHEET MOUSE))
	   (MULTIPLE-VALUE (X-OFF Y-OFF)
	     (SHEET-CALCULATE-OFFSETS SELF (MOUSE-SHEET MOUSE)))
	   (SETQ X (IF X
		       (+ X X-OFF)
		       (MOUSE-X MOUSE))
		 Y (IF Y
		       (+ Y Y-OFF)
		       (MOUSE-Y MOUSE)))
	   (MOUSE-WARP X Y MOUSE)
	   T)
	  ((NOT ERROR-P) NIL)
	  (T (FERROR NIL
  "Attempt to :SET-MOUSE-POSITION on a ~S, which is not related to MOUSE-SHEET."
		     SELF)))))

(DEFMETHOD (:MOUSE-MOVES ESSENTIAL-MOUSE) (&REST IGNORE)
  (MOUSE-SET-BLINKER-CURSORPOS SELF))

(DEFMETHOD (:MOUSE-BUTTONS ESSENTIAL-MOUSE) (BD X Y)
  (LET* ((MOUSE (SHEET-MOUSE SELF))
	 (BUTTONS (MOUSE-BUTTON-ENCODE BD MOUSE)))
    (IF (CHAR-MOUSE-EQUAL BUTTONS #\MOUSE-R-2)
	(MOUSE-CALL-SYSTEM-MENU (MOUSE-SHEET MOUSE))
	(SEND SELF ':MOUSE-CLICK BUTTONS X Y))))

;;; This is combined with :OR method combination.  This code gets its chance to run
;;; after other methods from other flavors.
(DEFMETHOD (:MOUSE-CLICK ESSENTIAL-MOUSE) (BUTTONS X Y)
  (COND ((AND (CHAR-MOUSE-EQUAL BUTTONS #\MOUSE-L-1)
	      (NOT (SHEET-SELECTED-P SELF))
	      (GET-HANDLER-FOR SELF ':SELECT))	;paper over a bug
	 (MOUSE-SELECT SELF)
	 (SEND-IF-HANDLES SELF :FORCE-KBD-INPUT `(:MOUSE-BUTTON ,BUTTONS ,SELF ,X ,Y) T))
	((OPERATION-HANDLED-P SELF :FORCE-KBD-INPUT)
	 (SEND SELF :FORCE-KBD-INPUT `(:MOUSE-BUTTON ,BUTTONS ,SELF ,X ,Y) T))
	(T (CONSIDER-MOUSE-CALL-SYSTEM-MENU BUTTONS SELF X Y)))
  T)

(DEFUN MOUSE-SELECT (WINDOW)
  (IF (EQ CURRENT-PROCESS (MOUSE-PROCESS (SHEET-MOUSE WINDOW)))
      (PROCESS-RUN-FUNCTION '(:NAME "Mouse Select" :PRIORITY 20.) WINDOW ':MOUSE-SELECT NIL)
      (SEND WINDOW ':MOUSE-SELECT NIL)))

(DEFMETHOD (:SCROLL-BAR-P ESSENTIAL-MOUSE) () NIL)

(DEFFLAVOR HYSTERETIC-WINDOW-MIXIN ((HYSTERESIS 25.)) ()
  (:REQUIRED-FLAVORS ESSENTIAL-WINDOW)
  (:SETTABLE-INSTANCE-VARIABLES HYSTERESIS)
  (:DOCUMENTATION :MIXIN "Controls mouse for small area outside of itself too.
The hysteresis instance variable is the number of pixels outside of its own
area within the :handle-mouse method still retain control."))

;; Allow HYSTERESIS to be a list of left,top,right,bottom, if requested.
(DEFMETHOD (:HANDLE-MOUSE HYSTERETIC-WINDOW-MIXIN) ()
  (LET (MOUSE LEFT-LIM TOP-LIM RIGHT-LIM BOTTOM-LIM)
    (MULTIPLE-VALUE (LEFT-LIM TOP-LIM MOUSE)
      (SHEET-MOUSE-OFFSETS SELF))
    (IF (LISTP HYSTERESIS)
	(SCL:DESTRUCTURING-BIND (LEFT-HYS &OPTIONAL (TOP-HYS LEFT-HYS)
						    (RIGHT-HYS LEFT-HYS) (BOTTOM-HYS TOP-HYS))
				HYSTERESIS
	  (SETQ RIGHT-LIM (+ LEFT-LIM WIDTH RIGHT-HYS)
		BOTTOM-LIM (+ TOP-LIM HEIGHT BOTTOM-HYS)
		LEFT-LIM (- LEFT-LIM LEFT-HYS)
		TOP-LIM (- TOP-LIM TOP-HYS)))
	(SETQ RIGHT-LIM (+ LEFT-LIM WIDTH HYSTERESIS)
	      BOTTOM-LIM (+ TOP-LIM HEIGHT HYSTERESIS)
	      LEFT-LIM (- LEFT-LIM HYSTERESIS)
	      TOP-LIM (- TOP-LIM HYSTERESIS)))
    (DO (W) (())
      ;; Let the mouse out of the window only if it moves more than <hysteresis> away
      (AND (OR (MOUSE-RECONSIDER MOUSE)
	       ;; Also leave if mouse fell into inferior
	       (AND (NEQ SELF (SETQ W (LOWEST-SHEET-UNDER-POINT (MOUSE-SHEET MOUSE) (MOUSE-X MOUSE) (MOUSE-Y MOUSE)
								NIL ':EXPOSED)))
		    (SHEET-ME-OR-MY-KID-P W SELF))
	       (< (MOUSE-X MOUSE) LEFT-LIM)
	       (> (MOUSE-X MOUSE) RIGHT-LIM)
	       (< (MOUSE-Y MOUSE) TOP-LIM)
	       (> (MOUSE-Y MOUSE) BOTTOM-LIM))
	   (RETURN T))
      (MOUSE-STANDARD-BLINKER SELF MOUSE)
      (MOUSE-DEFAULT-HANDLER SELF (SEND SELF ':SCROLL-BAR-P)))))

;;; The Scroll-Bar

;;; BASIC-SCROLL-BAR provides scroll bars in any or all of the window's margins. It
;;; does none of the actual scrolling itself, it just provides the scroll-bars.
;;;
;;; The scroll-bar structure contains information about the margin in which the mouse
;;; can be used to scroll, and information about the size of the bar which is drawn.
(defstruct (basic-scroll-bar :named-list (:conc-name scroll-bar-)
					 (:constructor make-scroll-bar))
  margin			        ;The margin this scroll bar lives in; one of the
					;margin symbols: :LEFT :TOP :RIGHT :BOTTOM.
  (width 1)				;The width of the scroll bar. When the scroll bar
					;is in the :top or :bottom margin this might be
					;called the height of the scroll bar, but it is
					;called the width anyways.
  left top right bottom			;The distance from the relevant outside edge of the
					;window to the edge of the scroll bar. Please note:
					;These values do not control the size of the region
					;in which the mouse is said to be in the scroll bar.
					;That region is controlled by MOUSE-DEFAULT-HANDLER
					;and the global variables SCROLL-BAR-RELUCTANCE and
					;SCROLL-BAR-WIDTH. Also please note that these are
					;internal values, they should only be accessed with
					;SCROLL-BAR-EDGE-COORDINATES.
  (always-displayed-p nil)		;T   ==> This scroll bar is always displayed.
					;NIL ==> This scroll bar is only displayed when
					;        the mouse is in its scroll-region.
  )

(defflavor basic-scroll-bar
       ((scroll-bars '(:left))		;SCROLL-BAR structures for this window's scroll bars.
        (scroll-bar-margins ())		;Cache for:
					;   (mapcar 'scroll-bar-margin scroll-bars)
        (in-scroll-bar nil))    	;The scroll bar the mouse-is in, or nil if the mouse
					;is not in any of this window's scroll-bars.
	()
  (:required-flavors essential-window)
  (:initable-instance-variables scroll-bars)
  (:init-keywords :scroll-bars
		  :scroll-bar
		  :scroll-bar-always-displayed)			;*** Compatibility
  (:default-init-plist :scroll-bars '(:left))
  (:functions draw-scroll-bar erase-scroll-bar draw-x-scroll-bar draw-y-scroll-bar))

;; The window should handle the :X/Y-SCROLL-POSITION messages by
;; returning four values:
;;    MIN-VISIBLE-X/Y    - The x/y coordinate of the first line
;;                         visible in the window.
;;    TOTAL-VISIBLE-X/Y  - The total number of 'coordinate units'
;;                         displayed in the window.
;;    MIN-X/Y            - The minimum x/y coordinate that can
;;                         be scrolled to.
;;    MAX-X/Y            - The maximum x/y coordinate that can
;;                         be scrolled to.
;;
;; Another way of looking at the four :*-SCROLL-POSITION values is to count items, not 
;; coordinate units.  Then, the four values are:
;;    TOP-ITEM-NO        - index of first item in window
;;    N-ITEMS-IN-WINDOW  - number of items in window [is this the number that could fit, or 
;;                         the number currently there?  They differ when the last item isn't
;;                         on or below the last line of the window]
;;    MIN-ITEM-NO        - min index there is (usually 0)
;;    MAX-ITEM-NO        - max index there is (total number of items)
;; However, BASIC-SCROLL-BAR itself cares nothing of the units used to count "items".
;;
;; The window should handle the :X/Y-SCROLL-TO messages by scrolling
;; to that x/y position or trying to.		     
;;
;; [I made :x-scroll-position and :x-scroll-to not be required-methods. I put an
;;  operation-handled-p check in parse-scroll-bars, which now complains only when told
;;  to make an x-scroll bar.
;;     -- RLB 17 Sept 1984]

;;; ***********************************************************************************
;;; 
;;;    COMPATIBILITY       TAKE THIS OUT IN SOME FUTURE RELEASE       COMPATIBILITY
;;;
;;; Here is a list of the methods defined on the old BASIC-SCROLL-BAR that could be
;;; considered as part of the interface to that flavor.  These are all provided for
;;; compatibility, but some of them are now considered to be obsolete.
;;;   :SCROLL-ABSOLUTE                   A compatibility method, the old method
;;;                                      didn't do all that much anyways,
;;;   :SCROLL-RELATIVE                   This is the same method as before,
;;;                                      but now the from and to arguments
;;;                                      can include:  :LEFT and :RIGHT
;;;   :SET-SCROLL-BAR                    Compatibility method.
;;;   :SET-SCROLL-BAR-ALWAYS-DISPLAYED   Compatibility method.
;;;   :SCROLL-BAR-ALWAYS-DISPLAYED       Compatibility method.
;;;   :SCROLL-BAR                        Compatibility method.
(eval-when (load)
  (loop for (msg reason) in '((:set-scroll-bar
			       "Use :ADD-SCROLL-BAR, :REMOVE-SCROLL-BAR or :SET-SCROLL-BARS.")
			      (:set-scroll-bar-always-displayed
			       "Use :SET-SCROLL-BAR-ALWAYS-DISPLAYED-P.")
			      (:scroll-bar-always-displayed
			       "Use :SCROLL-BAR-ALWAYS-DISPLAYED-P.")
			      (:scroll-bar
			       "Use :SCROLL-BARS or :SCROLL-BAR-IN-MARGIN."))
	    do (compiler:make-message-obsolete msg reason)))

(defmethod (:set-scroll-bar basic-scroll-bar) (new-left-margin-scroll-bar)
  (if (null new-left-margin-scroll-bar)
      (when (send self :scroll-bar-in-margin ':left)
	(send self :remove-scroll-bar ':left))
      (send self :add-scroll-bar new-left-margin-scroll-bar)))

(defmethod (:set-scroll-bar-always-displayed basic-scroll-bar) (new)
  (send self :set-scroll-bar-always-displayed-p ':left new))

(defmethod (:scroll-bar-always-displayed basic-scroll-bar) ()
  (memq ':left (send self :scroll-bar-always-displayed-p)))

(defmethod (:scroll-bar basic-scroll-bar) ()
  (send self :scroll-bar-in-margin ':left))

(defmethod (:scroll-absolute basic-scroll-bar) (to)
  (send self :y-scroll-to to ':absolute))

;;; The following two methods are for scrolling windows that haven't been converted yet.

(defmethod (:y-scroll-position basic-scroll-bar :default) ()
  (multiple-value-bind (top-line-num total-lines lin-height n-items)
      (send self :scroll-position)
    ;; Apparently there are some losers who fail to provide this value.
    (unless n-items (setq n-items (// (sheet-inside-height) lin-height)))
    (values (* top-line-num lin-height)
	    (* n-items lin-height)
	    0
	    (* total-lines lin-height))))

(defmethod (:y-scroll-to basic-scroll-bar :default) (pos type)
  ;; Truncate POS, because the reference point for a line is its top.
  ;; Don't use ROUND or CEILING.
  ;; The units for :RELATIVE-JUMP are whole lines.
  (if (eq type :relative-jump)
      (send self :scroll-to pos :relative)
      (multiple-value-bind (ignore ignore user-line-height ignore)
	  ;; this is a bit of a crock, to use the "obsolete" method, but
	  ;; the information isn't available from the "real" method, y-scroll-to
	  (send self :scroll-position)
	(send self :scroll-to (// pos user-line-height) type))))

;;; The following two methods are for windows that have been converted.

(defmethod (:scroll-position basic-scroll-bar :default) ()
  (multiple-value-bind (top-item displayed-items min-item max-item)
      (send self :y-scroll-position)
    (unless (zerop min-item) (ferror "Incompatible use of scroll windows."))
    (values top-item
	    (- max-item min-item)
	    ;;This assumes the displayed items fill all the pixels inside the window.
	    ;;That's not necessarily true, actually, but to use line-height here is also
	    ;;the wrong thing since only basic-scroll-bar's client knows the item heights.
	    ;;Such client should probably be using :y-scroll-position anyway.
	    (// (sheet-inside-height) displayed-items)
	    displayed-items)))

(defmethod (:scroll-to basic-scroll-bar :default) (pos type)
  (send self :y-scroll-to pos type))

;;;    COMPATIBILITY       TAKE THIS OUT IN SOME FUTURE RELEASE       COMPATIBILITY
;;;
;;; **********************************************************************************

(defmethod (:init basic-scroll-bar :before) (init-plist)
  (setq scroll-bars (if (get init-plist ':scroll-bar)
			(list (parse-single-scroll-bar-spec (get init-plist ':scroll-bar)))
			(loop for spec in scroll-bars
			  collect (parse-single-scroll-bar-spec spec))))
  (adjust-margins 'scroll-bars :parse-scroll-bars init-plist nil)
  (setq scroll-bar-margins (mapcar #'scroll-bar-margin scroll-bars))  
  (when (get init-plist ':scroll-bar-always-displayed)
    (setf (scroll-bar-always-displayed-p (send self :scroll-bar-in-margin ':left)) t)))

(defmethod (:redefine-margins basic-scroll-bar :before) (plist)
  (adjust-margins 'scroll-bars ':parse-scroll-bars plist ':scroll-bars)
  (setq scroll-bar-margins (mapcar #'scroll-bar-margin scroll-bars)))

(defmethod (:scroll-bar-p basic-scroll-bar) ()
  scroll-bar-margins)

(defmethod (:scroll-bar-displayed-p basic-scroll-bar) ()
  (loop for scroll-bar in scroll-bars
       when (or (scroll-bar-always-displayed-p scroll-bar)
 		(eq scroll-bar in-scroll-bar))
    collect (scroll-bar-margin scroll-bar)))

(defmethod (:scroll-bar-always-displayed-p basic-scroll-bar) ()
  (loop for scroll-bar in scroll-bars
       when (scroll-bar-always-displayed-p scroll-bar)
    collect (scroll-bar-margin scroll-bar)))

(defmethod (:set-scroll-bar-always-displayed-p basic-scroll-bar) (margin new)
  (let ((existing (send self :scroll-bar-in-margin margin)))
    (sheet-force-access (self)
      (if (or (eq existing in-scroll-bar)
	      (scroll-bar-always-displayed-p existing))
	  (when (null new) (erase-scroll-bar existing))
	  (when new (draw-scroll-bar existing)))
      (setf (scroll-bar-always-displayed-p existing) new))))

(defmethod (:scroll-bar-in-margin basic-scroll-bar) (margin-symbol)
  (loop for scroll-bar in scroll-bars
	when (eq (scroll-bar-margin scroll-bar) margin-symbol)
	return scroll-bar))
 
(defmethod (:add-scroll-bar basic-scroll-bar) (new-scroll-bar-spec)
  (let* ((new (parse-single-scroll-bar-spec new-scroll-bar-spec))
	 (existing (send self :scroll-bar-in-margin (scroll-bar-margin new)))
	 (plist `(:scroll-bars ,(cons new (remove existing scroll-bars)))))
    (send self :redefine-margins (locf plist))))

(defmethod (:remove-scroll-bar basic-scroll-bar) (remove-scroll-bar-spec)
  (let* ((remove (parse-single-scroll-bar-spec remove-scroll-bar-spec))
	 (existing (send self :scroll-bar-in-margin (scroll-bar-margin remove)))
	 (plist (if existing
		    `(:scroll-bars ,(remove existing scroll-bars))
		    (ferror "The window ~S received a :REMOVE-SCROLL-BAR message with a~@
                             remove-scroll-bar-spec argument of ~S, but the window does not~@
                             have a scroll bar which matches that spec."
			    self remove-scroll-bar-spec))))
    (send self :redefine-margins (locf plist))))

(defmethod (:set-scroll-bars basic-scroll-bar) (new-scroll-bars-spec)
  (let* ((new-scroll-bars (loop for spec in new-scroll-bars-spec
				collect (parse-single-scroll-bar-spec spec)))
	 (plist `(:scroll-bars ,new-scroll-bars)))
    (send self :redefine-margins (locf plist))))

(defmethod (:parse-scroll-bars basic-scroll-bar) (spec lm tm rm bm)
  (parse-scroll-bars self spec lm tm rm bm))

(defun parse-scroll-bars (window bars lm tm rm bm)
  (if (null bars)
      (values nil lm tm rm bm)
      (loop for scroll-bar in bars
	     do (let ((width (scroll-bar-width scroll-bar))
		      (margin (scroll-bar-margin scroll-bar)))
		  (let ((message (selectq margin
				   ((:left :right) :y-scroll-position)
				   ((:top :bottom) :x-scroll-position))))
		     (unless (operation-handled-p window message)
		       (fsignal "The window ~s doesn't handle the message ~s, ~
				  yet it is told to offer a scroll bar at the ~s"
				window message margin)))
		  (multiple-value-bind (sl st sr sb)
		      (selectq margin
			(:left   (multiple-value-prog1 (values lm tm (+ lm width) bm)
						       (incf lm width)))
			(:top    (multiple-value-prog1 (values lm tm rm (+ tm width))
						       (incf tm width)))
			(:right  (multiple-value-prog1 (values (+ rm width) tm rm bm)
						       (incf rm width)))
			(:bottom (multiple-value-prog1 (values lm (+ bm width) rm bm)
						       (incf bm width))))
		    (setf (scroll-bar-left   scroll-bar) sl)
		    (setf (scroll-bar-top    scroll-bar) st)
		    (setf (scroll-bar-right  scroll-bar) sr)
		    (setf (scroll-bar-bottom scroll-bar) sb))))
      (values bars lm tm rm bm)))

(defun parse-single-scroll-bar-spec (spec &aux (margins '(:left :top :right :bottom)))
  (cond ((eq spec 't) (setq spec ':left))	        ;** Compatibility
	((numberp spec) (setq spec `(:left ,spec))))	;** Compatibility
  (cond ((and (symbolp spec) (memq spec margins))
	 (make-scroll-bar margin spec))
	((and (listp spec) (memq (car spec) margins))
	 (make-scroll-bar margin (car spec)
			  width (or (cadr spec) 1)
			  always-displayed-p (caddr spec)))
	((and (listp spec) (eq (car spec) 'scroll-bar))
	 spec)
	(t
	 (ferror "Could not parse ~S as an scroll-bar-spec." spec))))

;;; SCROLL-BAR-EDGE-COORDINATES takes an scroll-bar and returns the coordinates
;;; of the scroll-bar's four edges. This function and parse-scroll-bars are the only
;;; people who should figure out what the "relevant" edge is for converting a scroll bars
;;; edge values into edge coordinates and vice versa.
(defun-in-flavor (scroll-bar-edge-coordinates basic-scroll-bar) (scroll-bar)
  (let ((lef (scroll-bar-left scroll-bar))
	(top (scroll-bar-top scroll-bar))
	(rig (scroll-bar-right scroll-bar))
	(bot (scroll-bar-bottom scroll-bar)))
    (selectq (scroll-bar-margin scroll-bar)
      (:left   (values lef            top            rig           (- height bot)))
      (:top    (values lef            top            (- width rig) bot))
      (:right  (values (- width lef)  top            (- width rig) (- height bot)))
      (:bottom (values lef            (- height top) (- width rig) (- height bot))))))


(defun-in-flavor (refresh-scroll-bars basic-scroll-bar) ()
  (loop for bar in scroll-bars
	when (or (scroll-bar-always-displayed-p bar)
		 (eq in-scroll-bar bar))
	  do (draw-scroll-bar bar)))

(defmethod (:refresh-margins basic-scroll-bar :after) ()
  (refresh-scroll-bars))

(defmethod (:new-scroll-position basic-scroll-bar :after) (&optional (ignore))
  (sheet-force-access (self)
    (refresh-scroll-bars)))


(defun-in-flavor (draw-scroll-bar basic-scroll-bar) (scroll-bar)
  (selectq (scroll-bar-margin scroll-bar)
    ((:left :right) (draw-y-scroll-bar scroll-bar))
    ((:top :bottom) (draw-x-scroll-bar scroll-bar))))

(defun-in-flavor (draw-y-scroll-bar basic-scroll-bar) (y-scroll-bar)
  (when y-scroll-bar
    (multiple-value-bind (lef top rig bot)
	(scroll-bar-edge-coordinates y-scroll-bar)
      (multiple-value-bind (min-visible-y total-visible-y min-y max-y)
	  (send self :y-scroll-position)
	(multiple-value-bind (bar-top bar-bot)
	    (compute-scroll-bar-ends min-y max-y
				     min-visible-y (+ min-visible-y total-visible-y)
				     top bot)
	  (prepare-sheet (self)
	    (sheet-draw-rectangle
	      (abs (- rig lef)) (- bot top) lef top erase-aluf)
	    (sheet-draw-rectangle
	      (abs (- rig lef)) (- bar-bot bar-top) lef bar-top char-aluf)))))))

(defun-in-flavor (draw-x-scroll-bar basic-scroll-bar) (x-scroll-bar)
  (when x-scroll-bar
    (multiple-value-bind (lef top rig bot)
	(scroll-bar-edge-coordinates x-scroll-bar)
      (multiple-value-bind (min-visible-x total-visible-x min-x max-x)
	  (send self :x-scroll-position)
	(multiple-value-bind (bar-lef bar-rig)
	    (compute-scroll-bar-ends min-x max-x
				     min-visible-x (+ min-visible-x total-visible-x)
				     lef rig)
	  (prepare-sheet (self)
	    (sheet-draw-rectangle
	      (- rig lef) (abs (- bot top)) lef top erase-aluf)
	    (sheet-draw-rectangle
	      (- bar-rig bar-lef) (abs (- bot top)) bar-lef top char-aluf)))))))

(defun-in-flavor (erase-scroll-bar basic-scroll-bar) (scroll-bar)
  (when scroll-bar
    (multiple-value-bind (lef top rig bot)
	(scroll-bar-edge-coordinates scroll-bar)
      (prepare-sheet (self)
	(sheet-draw-rectangle (- rig lef) (- bot top) lef top erase-aluf)))))

;;; This is used to determine the ends of the scroll-bar to draw.
(defvar scroll-bar-min-size  8.)

(defun compute-scroll-bar-ends (min max visible-min visible-max window-min window-max)  
  (let* ((bar-length (- window-max window-min))
	 (bar-min (fixr (+ window-min
			   (* bar-length (if (zerop (- max min))	
					     0
					     (// (- visible-min min)
						 (float (- max min))))))))
	 (bar-max (fixr (+ window-min
			   (* bar-length (if (zerop (- max min))
					     1
					     (// (- visible-max min)
						 (float (- max min)))))))))
    (setq bar-max (min (max bar-max window-min) window-max)
	  bar-min (min (max bar-min window-min) window-max))
    ;; Make sure the bar is is big enough.
    (cond (( (- bar-max bar-min) scroll-bar-min-size))
	  ((> bar-min (- visible-max scroll-bar-min-size ))
	   (setq bar-min (max (- window-max scroll-bar-min-size ) window-min)
		 bar-max window-max))
	  (t
	   (setq bar-max (min (+ bar-min scroll-bar-min-size ) window-max))))
    (values bar-min bar-max)))

(defmethod (:draw-scroll-bar-delayed basic-scroll-bar) (scroll-bar)
  (sheet-force-access (self)
    ;; It is possible that the mouse moved out while we were
    ;; waiting.  If this is the case, punt drawing.
    (when (eq in-scroll-bar scroll-bar)
      (draw-scroll-bar scroll-bar))))

(defmethod (:erase-scroll-bar-delayed basic-scroll-bar) (scroll-bar)
  (sheet-force-access (self)
    ;; It is possible that the user reentered the scroll bar
    ;; while we were waiting, In this is the case punt erasing.
    (unless (eq in-scroll-bar scroll-bar)
      (erase-scroll-bar scroll-bar))))

;;; These four :SCROLL-MORE-mumble methods are defaults.
;;; Flavors which can implement these more efficiently should certainly do so.
(defmethod (:scroll-more-above basic-scroll-bar :default) ()
  (multiple-value-bind (min-visible-y nil min-y)
      (send self :y-scroll-position)
    (< min-y min-visible-y)))

(defmethod (:scroll-more-below basic-scroll-bar :default) ()
  (multiple-value-bind (min-visible-y total-visible-y nil max-y)
      (send self :y-scroll-position)
    (< (+ min-visible-y total-visible-y) max-y)))

(defmethod (:scroll-more-to-left basic-scroll-bar :default) ()
  (multiple-value-bind (min-visible-x nil min-x)
      (send self :x-scroll-position)
    (< min-x min-visible-x)))

(defmethod (:scroll-more-to-right basic-scroll-bar :default) ()
  (multiple-value-bind (min-visible-x total-visible-x nil max-x)
      (send self :x-scroll-position)
    (< (+ min-visible-x total-visible-x) max-x)))


(defvar *default-x-scroll-bar-who-line-documentation-string*	
"Left: this column to left (L2: right); Middle: percentage-wise; Right: left column to here.")

(defvar *default-y-scroll-bar-who-line-documentation-string*
  "Left: this line to top (L2: bottom); Middle: percentage-wise; Right: top line to here.")

(defmethod (:who-line-documentation-string basic-scroll-bar :override) ()
  (when in-scroll-bar
    (if (memq (scroll-bar-margin in-scroll-bar) '(:left :right))
	*default-y-scroll-bar-who-line-documentation-string*
	*default-x-scroll-bar-who-line-documentation-string*)))

(defmethod (:handle-mouse-scroll basic-scroll-bar) ()
  (when (setq in-scroll-bar (send self :scroll-bar-in-margin *in-scroll-margin*))
    (multiple-value-bind (in-symbol jump-to-x jump-to-y x-off y-off char)
	(let* ((half-wid (// scroll-bar-width 2))
	       (rig-jump (- width half-wid))
	       (bot-jump (- height half-wid))
	       (lef (scroll-bar-left in-scroll-bar))
	       (top (scroll-bar-top in-scroll-bar))
	       (rig (scroll-bar-right in-scroll-bar))
	       (bot (scroll-bar-bottom in-scroll-bar)))
	  (selectq *in-scroll-margin*
	    ;; These magic numbers are based on the appearance of the doubly-shafted
	    ;; arrow characters in the MOUSE font and are designed to use the center
	    ;; of the character as the pointing position.
	    (:left   (values :in-left half-wid nil (- rig) 7
			     #\mouse:fat-double-vertical-arrow))
	    (:top    (values :in-top nil half-wid 8 (- 2 bot)
			     #\mouse:fat-double-horizontal-arrow))
	    (:right  (values :in-right rig-jump nil (+ lef 11.) 7
			     #\mouse:fat-double-vertical-arrow))
	    (:bottom (values :in-bottom nil bot-jump 8 (+ top 13.)
			     #\mouse:fat-double-horizontal-arrow))))
      (send self ':set-mouse-position jump-to-x jump-to-y)
      (mouse-set-blinker-definition ':character x-off y-off ':on ':set-character char)
      (without-interrupts
	(maybe-lock-sheet self
	  (draw-scroll-bar in-scroll-bar)	  
	  (process-run-function
	    "Draw Scroll Bar" self ':draw-scroll-bar-delayed in-scroll-bar)))
      (do () (())
	(mouse-default-handler self in-symbol)
	(multiple-value-bind (x-off y-off mouse)
	    (sheet-mouse-offsets self)
	  (let ((warped-x (min (max (mouse-x mouse) x-off) (+ x-off width)))
		(warped-y (min (max (mouse-y mouse) y-off) (+ y-off height))))
	    (if (or ( warped-x (mouse-x mouse)) ( warped-y (mouse-y mouse)))
		(mouse-warp warped-x warped-y mouse)
		(return t)))))
      (without-interrupts
	(or (scroll-bar-always-displayed-p in-scroll-bar)
	    ;; There is this funny case where the sheet could be locked by the person waiting
	    ;; for us to back out.  For us to block here would be a disaster, so undraw the
	    ;; scroll bar in another process
	    (maybe-lock-sheet self
	      (sheet-force-access (self) (erase-scroll-bar in-scroll-bar))
	      (process-run-function
		"Erase Scroll Bar" self ':erase-scroll-bar-delayed in-scroll-bar)))
	(setq in-scroll-bar nil)))))

(defmethod (:mouse-moves-scroll basic-scroll-bar) (&rest ignore)
  (mouse-set-blinker-cursorpos self))

(defmethod (:mouse-buttons-scroll basic-scroll-bar) (bd x y)
  (let* ((char (mouse-button-encode bd))
	 (margin-symbol (scroll-bar-margin in-scroll-bar)))
    (multiple-value-bind (lef top rig bot)
	(scroll-bar-edge-coordinates in-scroll-bar)
      (multiple-value-bind (here min max min-symbol max-symbol position-msg scroll-msg)
	  (if (memq margin-symbol '(:left :right))
	      (values y top bot :top  :bottom :y-scroll-position :y-scroll-to)
	      (values x lef rig :left :right  :x-scroll-position :x-scroll-to))
	(selector char char-mouse-equal
	  (#\mouse-l-1 (send self ':scroll-relative here min-symbol))
	  (#\mouse-r-1 (send self ':scroll-relative min-symbol here))
	  (#\mouse-l-2 (send self ':scroll-relative here max-symbol))
	  (#\mouse-r-2 (send self ':scroll-relative max-symbol here))
	  (#\mouse-m-1
	   ;; Middle: Jump to a proportional place in the "buffer"
	   ;; If we are n% of the window down, we want the point
	   ;; n% through the buffer to appear at the top of the window.
	   (multiple-value-bind (nil nil min-scrollable max-scrollable)
	       (send self position-msg)
	     (send self scroll-msg
		   (+ min-scrollable
		      (round (* (- max-scrollable min-scrollable) here)
			     (- max min)))
		   ':absolute)))
	  (otherwise (beep)))))))

(defun-in-flavor (scroll-relative-1 basic-scroll-bar) (edge-spec)
  (if (numberp edge-spec)
      (values edge-spec nil nil nil)
      (selectq edge-spec
	(:left   (values (sheet-inside-left)   (sheet-inside-width)
			 :x-scroll-to :x-scroll-position))
	(:top    (values (sheet-inside-top)    (sheet-inside-height)
			 :y-scroll-to :y-scroll-position))
	(:right  (values (sheet-inside-right)  (sheet-inside-width)
			 :x-scroll-to :x-scroll-position))
	(:bottom (values (sheet-inside-bottom) (sheet-inside-height)
			 :y-scroll-to :y-scroll-position)))))

(defmethod (:scroll-relative basic-scroll-bar) (from to)
  (multiple-value-bind (from-number from-range from-msg from-pos)
      (scroll-relative-1 from)
    (multiple-value-bind (to-number to-range to-msg to-pos)
	(scroll-relative-1 to)
      (when (or (and (null from-msg) (null to-msg))
		(and (not (null from-msg))
		     (not (null to-msg))
		     (neq from-msg to-msg)))
	(ferror "Incompatible arguments to :scroll-relative."))
      (multiple-value-bind (nil display-size nil nil)
	  (send self (or from-pos to-pos))
	(send self (or from-msg to-msg)
	      (round (* display-size (- from-number to-number))
		     (or from-range to-range))
	      ':relative)))))


;Flashy Scrolling

;If you move the mouse slowly out the top or bottom of a window that
;has this flavor, it gets scrolled up or down by a line, and the mouse
;jumps back in so that if you keep moving it, it keeps getting scrolled.
(defflavor flashy-scrolling-mixin
	((flashy-scrolling-region '((32. 0.80 :right) (32. 0.80 :right)))
	 ;*** I'm not sure there's any point to making this an instance variable --Moon ***
	 (flashy-scrolling-max-speed 6)	;Default to 6 inches per second
	 (flashy-scrolling-blinker nil))
	()
  (:initable-instance-variables flashy-scrolling-region flashy-scrolling-max-speed)
  (:required-flavors minimum-window)
  (:required-methods :y-scroll-to)
  (:documentation :mixin "Automatic scrolling when moving over the margins
Moving slowly out of the top or bottom of a window that includes this and keep moving,
and it will scroll up or down by a single line and the mouse will be moved back."))

(mouse-define-blinker-type 'flashy-character
			   #'(lambda (screen)
			       (make-blinker screen 'mouse-character-blinker
				 ':visibility nil
				 ':char #\mouse:fat-up-arrow)))

(defmethod (:who-line-documentation-string flashy-scrolling-mixin :override) ()
  (and flashy-scrolling-blinker
       (if (char-equal (send (mouse-blinker (sheet-mouse self)) :character)
		       #\mouse:fat-up-arrow)
	   "Bump blinker against top of window to scroll down by one line."
	   "Bump blinker against bottom of window to scroll up by one line.")))

(defun-in-flavor (flashy-scrolling-parse-x-spec flashy-scrolling-mixin) (spec)
  (cond ((floatp spec) (fix (* spec width)))
	((fixp spec) spec)
	((eq spec ':right) width)
	((eq spec ':left) 0)
	(t (ferror nil "~A is illegal X position specification for flashy scrolling" spec))))

(defvar *flashy-scrolling-global-enable* t)

;;; Returns T to suppress running the normal :MOUSE-MOVES method
(defun-in-flavor (flashy-scrolling-mouse-moves flashy-scrolling-mixin)
		 (w x y &aux region top-p (mouse (sheet-mouse self)))
  ;; Make sure mouse is within the appropriate window
  (cond ((and *flashy-scrolling-global-enable*
	      ( x 0) (< x width) (sheet-is-mouse-window-p self))
	 (setq region (if (setq top-p (< y (// height 2)))
			  (first flashy-scrolling-region)
			  (second flashy-scrolling-region)))
	 ;; Make sure mouse is within the appropriate region
	 (cond ((and (send self ':scroll-bar-p)
		     (if top-p
			 (< y (first region))
			 (> y (- height (first region))))
		     (> x (flashy-scrolling-parse-x-spec (second region)))
		     ( x (flashy-scrolling-parse-x-spec (third region)))
		     (send self (if top-p ':scroll-more-above ':scroll-more-below)))
		(when (null flashy-scrolling-blinker)
		  (setq flashy-scrolling-blinker (mouse-blinker-name mouse)))
		(if top-p
		    (mouse-set-blinker-definition-internal mouse
		      'flashy-character 6 0 ':on ':set-character #\mouse:fat-up-arrow)
		    (mouse-set-blinker-definition-internal mouse
		      'flashy-character 6 13. ':on ':set-character #\mouse:fat-down-arrow))
		(multiple-value-bind (nil window-y-offset)
		    (sheet-mouse-offsets w)
		  (when (and ;; If mouse is moving slowly enough
			     (or (null flashy-scrolling-max-speed)
				 (< (mouse-speed mouse) flashy-scrolling-max-speed))
			     ;; and out the top or bottom
			     (or (setq top-p ( y 0)) ( y (1- height))))
		    ;; then warp the mouse and send the appropriate message and return T
		    (mouse-warp (mouse-x mouse)
				(+ (if top-p 10. (- height 10.)) window-y-offset)
				mouse)
		    ;; Scroll 1 line (or other unit) up or down
		    (send self ':y-scroll-to (if top-p -1 +1) ':relative-jump)))
		t)
	       (flashy-scrolling-blinker
		;; Outside of the region, set the blinker back to the normal blinker
		(mouse-set-blinker flashy-scrolling-blinker nil nil mouse)
		(setq flashy-scrolling-blinker nil)
		nil)))))

;Arguments are window-relative position of the mouse
;This only does the rest of the processing if the flashy scrolling didn't happen
(defwrapper (:mouse-moves flashy-scrolling-mixin) ((x y) . body)
  `(cond ((not (flashy-scrolling-mouse-moves self x y))
	  . ,body)))

(defvar *mouse-exit-gate-width* 40.)		;Width of displayed target window and also
						;the width of the sensitive area of border
(defvar *mouse-exit-target-hysteresis* 4)	;How far mouse can get outside the target

(defvar *mouse-exit-target-global-enable* nil)	;Set this to t if you like the feature

(defflavor mouse-exit-target-mixin ((target-windows))
	   ()
  :settable-instance-variables)

(defmethod (:mouse-exit mouse-exit-target-mixin) (dx dy x y)
  (when *mouse-exit-target-global-enable*
    (mouse-exit-window self dx dy x y)))

;;; Having this separate lets us parameterize this behavior
(defun mouse-exit-window (window-being-exited dx dy x y)
  (let* ((gate-width *mouse-exit-gate-width*)
	 ;; Sensitive portion of the border is within gate-width of the 1inside0 corners,
	 ;; plus everything between the 1inside0 corners and the 1outside0 corners.  We use
	 ;; the inside corners because that's where the target window pops up.
	 (left (+ (sheet-inside-left window-being-exited) gate-width))
	 (top (+ (sheet-inside-top window-being-exited) gate-width))
	 (right (- (sheet-inside-right window-being-exited) gate-width))
	 (bottom (- (sheet-inside-bottom window-being-exited) gate-width)))
    (multiple-value-bind (corner direction delta)
	(cond ((plusp dx)
	       (let ((corner (cond ((< y top) :upper-right)
				   ((> y bottom) :lower-right))))
		 (when corner
		   (values corner :horizontal +1))))
	      ((plusp dy)
	       (let ((corner (cond ((< x left) :lower-left)
				   ((> x right) :lower-right))))
		 (when corner
		   (values corner :vertical +1))))
	      ((minusp dx)
	       (let ((corner (cond ((< y top) :upper-left)
				   ((> y bottom) :lower-left))))
		 (when corner
		   (values corner :horizontal -1))))
	      ((minusp dy)
	       (let ((corner (cond ((< x left) :upper-left)
				   ((> x right) :upper-right))))
		 (when corner
		   (values corner :vertical -1)))))
      (when (and corner (mouse-exit-target-direction-sensitive window-being-exited direction))
	(set-mouse-blinker-for-exit-target-window window-being-exited)
	(let ((target-windows (cl:nintersection (send window-being-exited :target-windows)
						(send window-being-exited :inferiors))))
	  (send window-being-exited :set-target-windows target-windows)
	  (unless (cl:some (lambda (window) (eq (send window :corner) corner)) target-windows)
	    (let ((window (find-exit-target-window
			    :corner corner :window window-being-exited
			    :direction direction :delta delta
			    :hysteresis *mouse-exit-target-hysteresis*)))
	      (push window target-windows)
	      (send window-being-exited :set-target-windows target-windows)
	      (send window :move-into-corner)
	      (multiple-value-bind (x-offset y-offset mouse)
		  (sheet-mouse-offsets window-being-exited)
		(let ((mx (- (mouse-x mouse) x-offset))
		      (my (- (mouse-y mouse) y-offset))
		      (slop *mouse-exit-target-hysteresis*))
		  ;; If he already moved the mouse out of the way before we even
		  ;; got the window set up, don't bother.  Allow more slop in the
		  ;; direction the mouse was initially moving.
		  (cond ((and (if (memq corner '(:upper-left :lower-left))
				  ( (- (if (minusp dx) (* slop 3) slop)) mx (+ left slop))
				  ( (- right slop) mx
				     (+ (sheet-width window-being-exited)
					(if (plusp dx) (* slop 3) slop))))
			      (if (memq corner '(:upper-left :upper-right))
				  ( (- (if (minusp dy) (* slop 3) slop)) my (+ top slop))
				  ( (- bottom slop) my
				     (+ (sheet-height window-being-exited)
					(if (plusp dy) (* slop 3) slop)))))
			 ;; Put the mouse in the center of the exit target
			 (multiple-value-bind (left top right bottom) (send window :edges)
			   (mouse-warp (+ (// (+ left right) 2) x-offset)
				       (+ (// (+ top bottom) 2) y-offset)
				       mouse))
			 ;; The ignore-errors is for things like superior being too small.
			 (cond ((ignore-errors (send window :expose) t)
				;; Kludge.  Setting mouse-reconsider keeps the following
				;; :handle-mouse from returning immediately.  The method
				;; (:handle-mouse :after) deactivates the very window we just
				;; labored to set up.
				(setf (mouse-reconsider mouse) nil)
				(send window :handle-mouse))
			       (T (send window :deactivate))))
			(T (send window :deactivate))))))))
	(mouse-standard-blinker)))))
