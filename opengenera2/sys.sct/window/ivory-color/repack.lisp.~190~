;;; -*- Mode: LISP; Base: 10.; Package: COLOR -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
						;
#+3600
(eval-when (compile load eval)
(progn
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");
;
; Some compatability kludges to permit Lmach and Imach to use the same source code
;
;
0(globalize "%BLOCK-REGISTER-INTERNAL" 'sys)
(globalize "WITH-BLOCK-REGISTERS" 'SYS)
(globalize "%BLOCK-REGISTER" 'SYS)
(globalize "%BLOCK-READ" 'SYS)
(globalize "%BLOCK-READ-SHIFT" 'SYS)
(globalize "%BLOCK-WRITE" 'SYS)
(globalize "LOAD-BAR" 'CLI)))

#+3600
(eval-when (compile load eval)
(globalize "%BLOCK-READ-SHIFT" 'SYS))
#+3600
(eval-when (compile load eval)
(defmacro sys:%block-read-shift (bar &key no-increment alu)
  (let ((base-form (selectq no-increment
		     (:keep `(si:%p-contents-offset ,(%block-register-internal bar) 1))
		     ((t) `(si:%p-contents-offset ,(%block-register-internal bar) 0))
		     (nil `(si:%p-contents-increment-pointer ,(%block-register-internal bar))))))
    (setq base-form `(sys:rot ,base-form shift-count))
    (if alu (setq base-form `(boole ,alu -1 ,base-form)))
    base-form))

(defmacro cli::source-dependent-alu-p (alu &optional (color? t))
  (let ((AA (IF COLOR?
		`(IF (< ,ALU 0)
		     (select (ldb color:%%extended-alu-opcode ,alu)
		       ((0 1) (if (ldb-test (byte 1 4) ,alu) cl:boole-1 cl:boole-set))
		       (2  cl:boole-1)
		       (otherwise (error "Don't know about color alu space ~D."
					 (ldb color:%%extended-alu-opcode ,alu))))
		     ,ALU)
		ALU)))
    `( color:alu-source-ignored (ldb color:%%alu-source-use (aref color:*alu-info* ,aa)))))
)

#+3600
(progn

(defun sys:%block-register-internal (n)
  (intern (format nil "BLOCK-REGISTER-~S" n)))

(defmacro sys:%block-register (n)
  (%block-register-internal n))

(defmacro CLI:LOAD-BAR (n val)
  `(setf ,(%block-register-internal n) ,val))

(defmacro sys:%block-read (bar &key no-increment alu)
  (let ((base-form (selectq no-increment
		     (:keep `(si:%p-contents-offset ,(%block-register-internal bar) 1))
		     ((t) `(si:%p-contents-offset ,(%block-register-internal bar) 0))
		     (nil `(si:%p-contents-increment-pointer ,(%block-register-internal bar))))))
    (if alu (setq base-form `(boole ,alu -1 ,base-form)))
    base-form))

(defmacro sys:%block-write (bar value &key no-increment)
  (selectq no-increment
    (:keep `(progn (%p-store-contents-offset ,value ,(%block-register-internal bar) 1) nil))
    ((t) `(progn (%p-store-contents ,(%block-register-internal bar) ,value) nil))
    (nil `(progn (si:%p-store-contents-increment-pointer ,value ,(%block-register-internal bar)) nil))))

(defmacro sys:with-block-registers ((&rest registers) &body body)
  `(let (,@(loop for i in registers collect (%block-register-internal i)))
    ,@body))

)
#||
(defconst *mask-alus-that-will-occur* (list  color:alu-X*~Y color:alu-X color:alu-~x+~Y
				       color:alu-add)
  1;these are the alus that will occur with a mask in the 0draw-rectangle 1like inner loops.  
0  1;others are either trivial, or will be transformed into these by complementing
0  1;the fill-data.  See COMBINE-ALU-AND-DATA for justification
0  )

(defconst *no-mask-alus-that-will-occur* (list color:alu-X*Y color:alu-X*~Y color:alu-X
				       color:alu-xor color:alu-ior color:alu-~x+~Y
				       color:alu-add)
  1;these are the alus that will occur without a mask in the bitblt-like inner loops.  
0  1;others are either trivial, or will be transformed into these by complementing
0  1;the fill-data or will have the mask operations incorporated into the operands
0  1;see COMBINE-ALU-AND-DATA for justification
0  )

||#

(defconst *skip-zero-strategy* (cl:make-array 16 :initial-contents
					      '(:mask     ;0 but alu-setz won't occur
						-1        ;X*Y
						0         ;~X*Y but won't occur
						0         ;noop, but won't occur
						:mask     ;X*~Y, will occur, use mask
						:original ;alu-seta, use original for zeros
						0	  ;xor, use 0 for zeros
						0	  ;ior, use 0 for zeros
						:MASK     ;8,~X+~Y, becomes X+~Y
						-1	  ;9, x=y, becomes XOR
						:~ORIGINAL	  ;10, ~x becomes X
						          ;changed from :original sep 90 for
						          ;unpacking-bitblt-81
						-1        ;11, ~x+y becomes x+y
						:mask	  ;12, ~y becomes XOR
						          ;changed from 0 sep 90 for
						          ;unpacking-bitblt-81
						:mask     ;13, x+~y becomes ~x*~Y
						:mask     ;14, ~x+~y 
						:MASK	  ;15, ones, becomes seta
						)))

(defvar *show-sample-pixel* nil)
						
(defmacro store-fill-data (val)
  `(progn ,val fill-data))

(defmacro store-fill-data-or-zero (val)
  `(logand fill-data (- ,val)))

(defmacro store-fill-data-or-ones (val)
  `(let ((val (- ,val)))
     (logior (lognot val)
	     (logand fill-data val))))

(defmacro store-not-minus-data (val)
  `(lognot (- ,val)))

(defmacro store-minus-data (val) 
  `(- ,val))

(defmacro store-minus-data-or-value (val old)
  `(let ((val (- ,val)))
     (logior val
	     (boole ,tv:alu-andca val ,old))))

(defmacro store-minus-data-or-mask (val size pos)
  `(let ((v (- ,val)))
     (setq traveling-mask
	   (logior traveling-mask
		   (logand (lognot v) ,(%logdpb -1 (byte size pos) 0))))
     v)) 

(defmacro store-fill-data-or-value (val old)
  `(let ((val (- ,val)))
     (logior (logand fill-data val)
	     (boole ,tv:alu-andca val ,old))))


(defmacro store-fill-data-or-mask (val size pos)
  `(let ((v (- ,val)))
     (setq traveling-mask
	   (logior traveling-mask
		   (boole ,tv:alu-andca v ,(%logdpb -1 (byte size pos) 0))))
     (logand fill-data v)))
#||

1This is a very hairy macro to generate the inner loop which processes
a row using some function to combine source and destination, also optionally
using an ALU and PLANE-MASK to store the result.  The hairiest part is that
it asjusts for mismatches in pixel size; so for example the source can
be 1 bit/pixel while the destinatin is 8 bits/pixel. The basic strategy is
to generate an inner loop which processes an integral number of 32 bit words,
which is executed repeatedly in the "middle" of the row.   Special set up for
the first few and last few pixels adjusts the operands and enters the loop
at the appropriate point.  

(2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")Machine Type considerations:
1This macro generates code that works for both L and I machines.  On L machines,
%P-CONTENTS-INCREMENT is the most effecient.  On I machines, BLOCK-READ is the
most effecient.  On either machine array registers and AREF can be used if you
want to run slower.   Partly as a consequence of this generality, partly as a
not-done-yet, fancy ivory features such as %block-read-alu are not used.  They
could be used to significantly reduce the size of the code generated, but the 
overall effeciency wouldn't change much, and it would require a major redesign.

2Size of the code:
1The basic numbers which determine the shape of  the code generated are SOURCE-BYTES-PER-WORD
and DEST-BYTES-PER-WORD.  Since both are small powers of 2 (1 2 4 8 16 32), the loop which
we generate will have (MAX S-bytes D-bytes) clauses.   

The main confounding factors are the "phase" of the source and destination.  The first
pixel we use of the source can be any of the S-bytes, and the first destination pixel 
we store can be any of the D-bytes.   In order to avoid having to shift
the source by a non-constant amount (which is relatively slow) we have D-bytes copies
of the loop, one for each possible phase of the destination.


2Considerations when fetching Destination words.

1Destination words might be fetched never, just before the before the completed result
is stored, or before source words are processed, depending on the type of operation,
the pixel function, and the boolean.    We call these strategies NEVER, LATE, and EARLY,
in order of preference.   Depending on the peripheral considerations, we downgrade the
destination fetch strategy as far as necessary.

The three basic peripheral considerations are MASK, BOOLEAN, and "HOLES".  

Mask:  If there is a plane mask, we'll have to fetch the destination sometime in
       order to preserve the masked bits.  Depending on the other requirements,
       this fetch can be either :EARLY or :LATE

Holes: All functions have potential "holes" in the first and last pixel of every row,
       (unless dest-bytes-per-word = 1).  We call these FL (first+last) holes.  Some
       pixel functions have holes in every word, for example if the destination is
       a byte smaller thant the nominal pixel size, or if the operation is some variation
       of draw-1-bit-raster.  One strategy for covering holes is to fetch the original
       data and use it, for the holes can be covered this way if the alu is ALU-SETA.
       This forces the fetch to :EARLY.

Boolean:  For some booleans, the holes can be covered by using an innocuous value
       such as 0 or -1 for the unspecified bits.  For others, the holes cannot be
       covered, so we have to resort to using a mask.0  1We designate booleans type 
0       1I if an annocuous value is avaiable, type N otherwise

Consolidating all these considerations, we get the following 
0	MASK	Boolean  Holes

(1)	NO	I	 FL
(2)	NO	I	 A
(3) 	NO 7	N	 FL
(4)	NO 8	N	 A
(5)	YES	I	 FL
(6)	YES	I	 A
(7)	YES	N	 FL
(8)	YES	N	 FL

1Given our loop strategy, holes in type N booleans can't be handled conveniently,
so we downgrade handling of those by using a mask, so type 3 and 4 become 7 and 8.
With sufficiently complex bookkeeping, type 3 could be handled, but there is
not much motivation to do so, because there aren't any important booleans in
type 3.

0||#
(defmacro repack-row
	  (source-bytes-per-word  dest-bytes-per-word 
	   bytes-to-repack-variable source-phase-variable dest-phase-variable
	   source-variable  source-index-variable 
	   dest-variable dest-index-variable
	   pixels-to-go-in-chunk pixels-in-a-chunk wrap-x-to
	   &key

	   1;description of the per-pixel function
0	   pixel-function
	   pixel-function-args
	   (pixel-function-gets-source t)
	   pixel-function-gets-dest

	   skip-outside-bits  1;strategy for skipping outside bits

0	   1;strategy, use AREFs or use %P-CONTENTS-INCREMENT
0	   (use-bar-registers t)

	   1;optional output parameters
0	   (write-byte-pointer)
	   (write-mask)
	   (write-alu)
	   (skip-zeros)
	   (first-word-mask)
	   (last-word-mask)
	   (exit-d-phase)
	   1;optional input parameters
0	   (complement-source nil)
	   (rotate-source)
	   (source-bar 2)
	   (dest-bar 3)
	   declarations
	   vars
	   (show-sample-pixel *show-sample-pixel*))


  (let* ((n-steps (max source-bytes-per-word dest-bytes-per-word))
	 (sample)
	 (source-byte-size (// 32 source-bytes-per-word))
	 (dest-byte-size (// 32 dest-bytes-per-word))
	 (read-the-dest (cond ((or pixel-function-gets-dest
				   (and write-alu write-mask)
				   (memq pixel-function '(store-fill-data-or-value
							   store-minus-data-or-value)))
			       :early)
			      ((or write-mask
				   write-alu
				   ) :late)))
	 (fetch-dest-word (if (and (eq read-the-dest :early)
				   (or write-alu write-mask))
			      'saved-dest-word
			      'dest-word))
	 (no-traveling-mask (and (null write-mask) (eq fetch-dest-word 'dest-word)))
	 (write-byte-size (or (second write-byte-pointer) dest-byte-size ))
	 (write-byte-pos (or (third write-byte-pointer) 0))
	 )

    (labels ((with-debugging (&rest body)
	       (ignore body)
	       ()
	       #||
		 `((LET* ((SAVED-BLOCK1 (%READ-INTERNAL-REGISTER %REGISTER-BAR-1))
			 (saved-alu (%READ-INTERNAL-REGISTER
				      %REGISTER-ALU-AND-ROTATE-CONTROL))
			 )
		    (dbg:when-mode-lock ,@(copylist body))
		    (%WRITE-INTERNAL-REGISTER SAVED-BLOCK1 %REGISTER-BAR-1)
		    (%WRITE-INTERNAL-REGISTER saved-alu %REGISTER-ALU-AND-ROTATE-CONTROL)))
		 ||#
		 )
	     (held-increment-value (value)
	       1;handling of autoincrementing pointers on 3600 vs Ivory.
	       ; On 3600, autoincrement is pre-increment
0	       1; On Ivory, autoincrement is pos-increment.
0	       1;For the most part, we can paper over the difference when loading the registers,
0	       1;but if we need to read and then store back to the same location, we have to know
0	       1;which operation to suppress the increment for.
0	       1;
	       ; :HOLD means do the operation and hold the pointer value for later
0	       1; :HELD means do the operation with a pointer value previously held
0	       1; :KEEP means always no-increment
0	       1; NIL means just do it, and always increment
0	       (cond ((null value) nil)
		     ((eq value :hold) #+3600 NIL #+IMACH T)
		     ((eq value :held) #+3600 T #+IMACH NIL)
		     ((eq value :keep) #+3600 :KEEP #+IMACH T)
		     (t (ferror "unknown hold value ~S" value))))

	     (bar-aref (bar &optional NO-INCREMENT)
	       (setq no-increment (held-increment-value no-increment))
	       (let ((base-form
		       (if use-bar-registers
			   `(,(if (and rotate-source (eql bar source-bar))
					      '%block-read-shift
					      '%block-read)
					 ,bar :no-increment ,no-increment)
			   (let ((form `(aref ,(selector bar eql
						 (source-bar source-variable)
						 (dest-bar dest-variable)
						 (t (ferror "undefined read bar ~s" bar)))
					      ,(let ((var (selector bar eql
							    (source-bar 'sidx)
							    (dest-bar 'didx))))
						 (if no-increment
						     var
						     `(prog1 ,var (incf ,var)))))))
			     (if (and rotate-source (eql bar source-bar))
				 `(rot ,form alu-register)
				 form)))))
		 (when (and complement-source (eql bar source-bar))
		   (setq base-form `(lognot ,base-form)))
		 base-form))

	     (bar-aset (bar value &optional no-increment)
	       (setq no-increment (held-increment-value no-increment))
	       (if use-bar-registers
		   (progn
		     #+imach (when no-increment (ferror "no-increment-write not available"))
		     `(%block-write ,bar ,value
				    ,@(when no-increment `(:no-increment ,no-increment))))
		   `(setf (aref ,(cl:ecase bar (dest-bar dest-variable))
				,(if no-increment
				     'didx
				     `(prog1 didx (incf didx))))
			  ,value)))

	     (set-bar (bar base-form inc)
	       (if use-bar-registers
		   `(cli::load-bar
		      ,bar
		      #+imach (%pointer-plus ,base-form (+ ,inc #+3600 -1))
		      #+3600 (si:%p-structure-offset ,base-form (+ ,inc #+3600 -1)))
		   `(setq ,(selector bar eql (source-bar 'sidx)(dest-bar 'didx)
				     (t (ferror "unknown-bar ~A" bar)))
			  ,inc)))

	     (restore-alu-and-rotate ()
	       #+imach
	       `(%WRITE-INTERNAL-REGISTER alu-register %REGISTER-ALU-AND-ROTATE-CONTROL)
	       #+3600
	       ())

	     (prepared-dest-word (mask)
	       (let* ((base-form 'dest-word)
		      (dest-form (if (eq read-the-dest :early)
				     fetch-dest-word
				     (bar-aref dest-bar :hold)))
		      (second-dest-form dest-form))

		 (when (and (null write-mask)
			    mask)
1		   ;if we are doing store-fill-data and not masking, and this is the
		   ;exit word, supply the missing "source" bits that we didn't read
0		   (cond ((null last-word-mask))
			 ((eq pixel-function 'store-fill-data-or-zero)
			  (setq base-form `(boole ,tv:alu-andca ,last-word-mask ,base-form)))
			 ((eq pixel-function 'store-fill-data-or-ones)
			  (setq base-form `(logior ,last-word-mask ,base-form)))))

		 (when write-alu
		   (when mask
		     (setq dest-form (if (eql dest-form fetch-dest-word)
					 dest-form
					 `(setq ,fetch-dest-word ,dest-form))
			   second-dest-form fetch-dest-word))
		   (setq base-form
			 (if (fixp write-alu)
			     `(boole ,write-alu ,base-form
					   ,dest-form)
			     `(,write-alu ,base-form ,dest-form)
			     )))
		 (let ((mask (and mask
				  (cond (no-traveling-mask last-word-mask)
					(t 'traveling-mask)))))
		   (when mask
		     (if write-alu
			 (setq base-form
			       `(let ((temp ,base-form))
				  (logxor temp
					  (logand ,mask
						  (logxor temp ,second-dest-form)))))
			 (setq base-form
			       `(logxor ,base-form
					(logand ,mask
						(logxor ,base-form ,second-dest-form)))))))
		 base-form))

	     (dest-phase-loop (dest-phase &key pixel-function)
	       (let ((main-labels (loop for i from 0 below n-steps
					collect (make-symbol (format nil "Dest-~D-Source-~D" dest-phase i))))
		     (next-loop (make-symbol (format nil "Dest-~D-Next-Loop" dest-phase)))
		     (exit-loop-store (make-symbol (format nil "Dest-~D-Exit-Loop-Store" dest-phase)))
		     (exit-loop-store-skip (make-symbol (format nil "Dest-~D-Exit-Loop-Store-skip" dest-phase)))
		     )
		 (labels ((source-phase-loop (dest-phase &key step-labels pixel-function)
						
	       1;generate an unrolled loop that processes at least one source word and one destination word.
0	       1;we depend on the fact that and all are powers of two, and so one will always divide the other0s
	       1;
0	       (loop1 0with dest-pos = (* dest-phase dest-byte-size) 
		     and source-pos = 0
		     for label in step-labels
		     as index from 1
		     do (setq sample (last value))
		     as skip-label = nil
		     nconc
		       `(,@(when (eql dest-pos 0)
			     (nconc
			       (when (eq read-the-dest :early)
				 `((setq ,fetch-dest-word ,(bar-aref dest-bar :hold))))
			       (cond ((and (neq fetch-dest-word 'dest-word)
					   (eq skip-zeros :skip))
				      `((setq dest-word ,fetch-dest-word)))
				     (write-byte-pointer
				      `((setq dest-word
					      ,(cond ((eql skip-outside-bits :~original)
						      `(lognot ,(bar-aref dest-bar :hold)))
						     ((eql skip-outside-bits :original)
						      (bar-aref dest-bar :hold))
						     ((eql skip-outside-bits -1) -1)
						     (t 0))))))
			       (unless no-traveling-mask
				 `((setq traveling-mask
					 ,(if write-mask 'write-protect-mask 0))))))
			 ,@(when (eql source-pos 32)
			     (setq source-pos 0)
			     `((setq source-word 1,0(bar-aref source-bar))

			     ,@(with-debugging `(cl:format t " m~x ~x,~x,~x,~x "
						   (cli::%READ-INTERNAL-REGISTER
						     cli::%REGISTER-ALU-AND-ROTATE-CONTROL)
							  (ldb (byte 8 0) source-word)
							  (ldb (byte 8 8) source-word)
							  (ldb (byte 8 16) source-word)
							  (ldb (byte 8 24) source-word)))
			       ))

			 ,@(when label (list label))    1;dispatch entry point0 1for startup and shutdown
0			 ,(let ((sb (if (= source-byte-size 32)	
					'source-word
					`(%logldb (byte ,source-byte-size ,source-pos) source-word))))

			    (when (eq skip-zeros :skip)
			      (setq skip-label (make-symbol (string-append "skip-" label)))
			      (setq sb `(if (= ,sb 0)	
					    (progn ,@(when (eql 32 dest-byte-size)
						       (cond ((eq read-the-dest :early)
							      `(,(bar-aref dest-bar :held)))
							     (t `(,(bar-aref dest-bar nil)))))
						   ,@(when (eql 32 (+ source-pos
								      source-byte-size))
1							;end of a source word
0							`((when ( pixels-to-go-in-chunk 0)
							    (when ( pixels-to-go 0)
							      (go ,exit-loop-store-skip))
							    (setq pixels-to-go-in-chunk (min pixels-to-go pixels-in-a-chunk))
							    (decf pixels-to-go pixels-to-go-in-chunk)
							    ,(set-bar source-bar SOURCE-VARIABLE wrap-x-to)

							    )))
						   (go ,skip-label))
					    1
					    )))

			    (when pixel-function
			    
			      (setq sb `(,pixel-function
					 ,@(when pixel-function-gets-source (list sb))
					 ,@(when pixel-function-gets-dest
					     (if (= 32 write-byte-size)
						 (list fetch-dest-word)
						 `((ldb (byte ,write-byte-size
							      ,(+ write-byte-pos dest-pos))
							,fetch-dest-word))))
					 ,@(when (eq skip-zeros :mask)
					     `(,dest-byte-size ,dest-pos))
					 ,@pixel-function-args)
				    ))

			    (setq sb (if (= 32 write-byte-size)
					 SB
					 `(%logdpb ,SB
						   (byte ,write-byte-size ,(+ write-byte-pos
									      dest-pos))
						   dest-word)))
			 `(setq dest-word ,sb))
			 ,@(when (and (eq skip-zeros :skip)
				      ( dest-byte-size 32))
			     (prog1 (list skip-label) (setq skip-label nil)))
			 )
		       into value
		     do (incf source-pos source-byte-size )
			(incf dest-pos dest-byte-size)
		     when (eql dest-pos 32.)
		       nconc (progn (setq dest-pos 0)
						1;store a completed destination word
0				    (unless (and (eql index n-steps)
						 (eql dest-phase 0))
				      `(,(bar-aset dest-bar (prepared-dest-word write-mask)
						   (when (eq read-the-dest :early) :HELD)))))
			 into value
		     when (and skip-label
			       ( 32 source-pos))
		       nconc (prog1 `(,skip-label) (setq skip-label nil))
			 into value
		     finally 
		       (setq sample (cdr sample))
		       (return (nconc
				 value
				 `((when ( pixels-to-go-in-chunk 0)
						1;if we have finished, go store the last word
0				     (when ( pixels-to-go 0) (go ,exit-loop-store))
				     (setq pixels-to-go-in-chunk (min pixels-to-go pixels-in-a-chunk))
				     (decf pixels-to-go pixels-to-go-in-chunk)
				     ,(set-bar source-bar SOURCE-VARIABLE wrap-x-to)
				     )
				   ,@(when (eql dest-phase 0)
1						;put out the dest word we owe
0				       `(,(bar-aset dest-bar (prepared-dest-word write-mask)
						    (when (eq read-the-dest :early) :HELD))))

				   ,@(when (and skip-label (= 32 source-pos))
				       (prog1 `(,skip-label) (setq skip-label nil)))
				   (when ( pixels-to-go-in-chunk ,n-steps)
						1;iterate if there is at least another full cycle remaining
0				     (go ,next-loop))

						1;otherwise, fall into the exit loop

0						1;get the next source word ready
0				   (setq s-phase 0)
				   (setq source-word ,(bar-aref source-bar))
				   ,@(with-debugging `(cl:format t " e ~x,~x,~x,~x "
								(ldb (byte 8 0) source-word)
								(ldb (byte 8 8) source-word)
								(ldb (byte 8 16) source-word)
								(ldb (byte 8 24) source-word)))
				   ,@(with-debugging
				      `(cl:format t " rr-e ~X "
					       (cli::%READ-INTERNAL-REGISTER
						 cli::%REGISTER-ALU-AND-ROTATE-CONTROL)))
				     
				   ,@(when (eql dest-phase 0)
				       `(,@(when (eq read-the-dest :early)
					     `((setq ,fetch-dest-word ,(bar-aref dest-bar :hold))))
					 ,@(when (and (neq fetch-dest-word 'dest-word)
						      (or ( 0 write-byte-pos)
							  (eq skip-zeros :skip)))
					     `((setq dest-word ,fetch-dest-word)))
					 ,@(unless no-traveling-mask
					     `((setq traveling-mask
						     ,(if write-mask 'write-protect-mask 0))))
					 )))))
		       )))



	       `(tagbody

		  1;dispatch initially to do the last few pixels of the first source word
0		  (selector s-phase eql
		    ,@(loop for i from 0 below n-steps
			    as tag in main-labels
			    collect `(,i (go ,tag))))

	       ,next-loop

		      1;main loop which processes one source word and n destination words,
0		      1;or n source words and one destination word
0		      (decf pixels-to-go-in-chunk ,n-steps)

		      1;get the next source word ready
0		      (setq source-word ,(bar-aref source-bar))
		      ,@(with-debugging `(cl:format t " n~X ~x,~x,~x,~x "
						   (cli::%READ-INTERNAL-REGISTER
						     cli::%REGISTER-ALU-AND-ROTATE-CONTROL)
								(ldb (byte 8 0) source-word)
								(ldb (byte 8 8) source-word)
								(ldb (byte 8 16) source-word)
								(ldb (byte 8 24) source-word)))

		      ,@(source-phase-loop dest-phase :step-labels main-labels
							:pixel-function pixel-function)

		      (go exit-phase)

		   ,exit-loop-store

1		   ;protect the last bits of the destination 
0		   ,@(unless (or no-traveling-mask (null last-word-mask))
		       `((setq traveling-mask
			       (logior traveling-mask ,last-word-mask))))
		   ,(bar-aset dest-bar (prepared-dest-word t) :held)
		   ,exit-loop-store-skip
		   )))
	       )
	     )
	     
      (let ((base-form
	      `(let* ((pixels-to-go ,bytes-to-repack-variable)
		      (pixels-to-go-in-chunk ,pixels-to-go-in-chunk)
		      (pixels-in-a-chunk ,pixels-in-a-chunk)
		      ,@(unless use-bar-registers
			  `((sidx)
			    (didx)))
		      (s-phase ,source-phase-variable)
		      (d-phase ,dest-phase-variable)
		      ,@vars
		      )
		 ,@(when declarations `((declare ,@declarations)))
		 ,@(when (and rotate-source use-bar-registers)
1		     ;this is needed because the LSH uses the rotate latch
0		     `(,(restore-alu-and-rotate)))
		 ,(set-bar source-bar SOURCE-VARIABLE SOURCE-INDEX-VARIABLE)
		 ,(set-bar dest-bar DEST-VARIABLE DEST-INDEX-VARIABLE)

		 (when (> pixels-to-go 0)
		   (prog* ((source-word ,(bar-aref source-bar))
			   (dest-word ,(cond ((eq pixel-function 'store-fill-data-or-zero)
					      0)
					     ((eq pixel-function 'store-fill-data-or-ones)
					      -1)
					     ((or (null read-the-dest)
						  (eql skip-outside-bits :original))
					      (bar-aref dest-bar :hold))
					     ((eql skip-outside-bits :~original)
					      `(lognot ,(bar-aref dest-bar :hold)))
					     ((eql skip-outside-bits -1) -1)
					     (t 0)))
			   (n-entry-pixels (- ,n-steps s-phase))
			   ,@(when (eq fetch-dest-word 'saved-dest-word)
			       `(saved-dest-word))
			   ,@(unless no-traveling-mask
			       `((traveling-mask
				   ,(or first-word-mask
					(if write-mask 'write-protect-mask 0)))))
			   )
			  ,@(with-debugging `(cl:format t " l~x ~x,~x,~x,~x "
						   (cli::%READ-INTERNAL-REGISTER
						     cli::%REGISTER-ALU-AND-ROTATE-CONTROL)
								(ldb (byte 8 0) source-word)
								(ldb (byte 8 8) source-word)
								(ldb (byte 8 16) source-word)
								(ldb (byte 8 24) source-word)))
1			 ;prefetch the destination word if we need to read it
0			 ,@(cond ((eq read-the-dest :early)
				  `((setq ,fetch-dest-word ,(bar-aref dest-bar :hold))))
				 )

			 ,@(when (and (neq fetch-dest-word 'dest-word)
				      (or ( 0 write-byte-pos)
					  (eq skip-zeros :skip)))
			     `((setq dest-word ,fetch-dest-word)))

		       chunk-phase

			 (decf pixels-to-go pixels-to-go-in-chunk)

			 (when ( pixels-to-go-in-chunk n-entry-pixels)

			   ,@(with-debugging
			     `(format t "~&to disp"))

			   (go main-dispatch))

		      exit-phase
			 1;if we are doing less than one full cycle, right align the source
0			 1;end enter the exit phase of the loop.
0			 ,@(with-debugging
			    `(cl:format t " rr-exit ~X "
				     (cli::%READ-INTERNAL-REGISTER
				       cli::%REGISTER-ALU-AND-ROTATE-CONTROL)))
			 (let* ((n-exit-pixels (- ,n-steps pixels-to-go-in-chunk s-phase))
			       ,@(when (< source-bytes-per-word dest-bytes-per-word)
1				   ;subpixels is the number of source pixels we will
				   ;eventually discard from the last word
0				   `((subpixels (logand ,(1- source-bytes-per-word)
							n-exit-pixels))))
			       )
			   ,@(when (< source-bytes-per-word dest-bytes-per-word)
			       #||1 this is the really tricky bit.  The strategy for dealing
0			       1with the last few pixels is to shift them into a suitable
0			       1position, then dispatch to a d-phase that will store them
0			       1corectly.  If there are fewer source bytes than dest bytes
0			       1per chunk, we can't do that directly because there may0	
			       1be multiple source words to process.  So, we dispatch once
0			       1for the full word source and once for the final fraction.
0			       ||#


			       `(
	 ,@(with-debugging
	   `(format t "~&adj: s-phase ~D  d-phase ~D n-ex ~D pix-to-go ~D in-chunk ~D sub ~D"
	   s-phase d-phase n-exit-pixels pixels-to-go pixels-to-go-in-chunk subpixels))

				 (when ( (+ pixels-to-go-in-chunk s-phase)
					  ,source-bytes-per-word)
				   (unless (and (zerop subpixels) 1;exact match at the end
0						(zerop s-phase)   1;exact match now
0						)
1				     ;discount for the pixels we won't process this loop
0				     (incf n-exit-pixels (+ (%fixnum-mod
							      (- ,source-bytes-per-word
								 subpixels)
							      ,source-bytes-per-word)
							    s-phase))
				     (setq d-phase (sys:%fixnum-mod
						     (+ d-phase s-phase
							(- ,n-steps n-exit-pixels))
						     ,n-steps)
					   s-phase n-exit-pixels
					   n-entry-pixels (- ,n-steps s-phase))
				     ,@(with-debugging 
				       `(format t " disp"))

				     (go main-dispatch)
				     ))))
			   ,@(with-debugging
			     `(format t " shift ~D" 
				     (* ,source-byte-size
					,(if (< source-bytes-per-word dest-bytes-per-word)
					     'subpixels
					     'n-exit-pixels))))

			   (setq ,@(cond ((eql source-bytes-per-word 1) nil)
					 (t
					  `(source-word
					     (lsh source-word
						  (* ,source-byte-size
						     ,(if (< source-bytes-per-word dest-bytes-per-word)
							  'subpixels
							  'n-exit-pixels))))))
				 s-phase (+ s-phase n-exit-pixels)
				 n-entry-pixels pixels-to-go-in-chunk)
			   ,@(unless (= 1 dest-bytes-per-word)
			       `((setq d-phase ,exit-d-phase))))
			 ,@(when (and rotate-source use-bar-registers)
1			     ;this is needed because the LSH uses the rotate latch
0			     `(,(restore-alu-and-rotate)))
		      main-dispatch
			 ,@(with-debugging
      `(format t "~&disp: s-phase ~D  d-phase ~D pix-to-go ~D in-chunk ~D x ~D  ent ~D"
	     s-phase d-phase pixels-to-go pixels-to-go-in-chunk ,exit-d-phase
	     n-entry-pixels))
			 ,@(with-debugging
			    `(cl:format t " rr-disp ~X "
				     (cli::%READ-INTERNAL-REGISTER
				       cli::%REGISTER-ALU-AND-ROTATE-CONTROL)))

			 (decf pixels-to-go-in-chunk n-entry-pixels)

			 ,(if (eql dest-bytes-per-word 1)
			      `(progn (ignore d-phase)
				      ,(dest-phase-loop 0 :pixel-function pixel-function))
			      `(selector d-phase eql
				 ,@(loop for i from 0 below dest-bytes-per-word
					 collect `(,i ,(dest-phase-loop i :pixel-function pixel-function))
					   )))
			      ))
			    )))
		   (when show-sample-pixel
		     (format t "~{~&    ~S~}" sample))
		   base-form
		   ))))


(defun skip-zeros-strategy (skip-zeros dest-byte-size alu masked)
  (cond ((neq t skip-zeros) skip-zeros)
	((= 32 dest-byte-size)
	 1;if the output pixels are 32 bits, we can conveniently skip them
0	 1;on macivory rev1, this is about twice as fast as reading them.
0	 :skip)
	(masked :mask)
	(( 0 alu 16) (aref *skip-zero-strategy* alu))
	((= alu color:alu-add) 0)
	(t :mask)))


(defmacro repack-rectangle (width height
			    indirect-source source-span sx s-phase s-elements-per-q
			    indirect-dest dest-span dx d-phase d-elements-per-q
			    pixels-in-first-chunk pixels-in-a-chunk wrap-y-from
			    &rest repack-row-keywords
			    &key (use-bar-registers t)
			    (source-bar 2)
			    (write-byte-pointer)
			    (dest-bar 3)
			    (write-mask)
			    (write-alu)
			    (skip-zeros)
			    (pixel-function)
			    (pixel-function-gets-dest)
			    (pixel-function-args)
			    (rotate-source)
			    &allow-other-keys)
  (si:with-rem-keywords (repack-row-keywords
			  repack-row-keywords
			  '(:use-bar-registers
			    :write-mask
			    :source-bar
			    :dest-bar
			    :write-alu
			    :skip-zeros
			    :rotate-source
			    :pixel-function
			    :pixel-function-gets-dest
			    :pixel-function-args))
  (let* ((folded-photon (when write-alu (when (fixp write-alu)
					  (bit-test %folded-fill-alu write-alu))))
	 (write-alu (if folded-photon
			(cl:logandc1 %folded-fill-alu write-alu )
			write-alu
			  ))
	 (write-alu (if (eql write-alu tv:alu-seta) nil write-alu))
	 (d-element-size (// 32 d-elements-per-q))
	 (d-size-shift (1- (haulong d-element-size)))
	 (skip-zeros (skip-zeros-strategy skip-zeros d-element-size
					  (or write-alu tv:alu-seta)
			      write-mask))
	 (skip-outside-bits (skip-zeros-strategy t d-element-size
						 (or write-alu tv:alu-seta)
						 write-mask))
	 (write-mask (or write-mask (eq skip-zeros :mask)(eq skip-outside-bits :mask)))

	 (pixel-function-gets-dest (or pixel-function-gets-dest
				       (member skip-zeros '(:original :~original))
				       ))
	 (pixel-function (cond ((eq pixel-function '-)
				(cond ((or (eql skip-zeros 0)
					   (eq skip-zeros :skip))
				       pixel-function)
				      ((eql skip-zeros -1)
				       'store-not-minus-data)
				      ((eq skip-zeros :mask)
				       'store-minus-data-or-mask)
				      (t (unless (member skip-zeros '(:original :~original))
					   (setq pixel-function-args
						 (list skip-zeros)))
					 'store-minus-data-or-value
					 )))
			       ((eq pixel-function 'store-fill-data-or-zero)
				(cond ((or (eql skip-zeros 0)
					   (eq skip-zeros :skip))
				       pixel-function)
				      ((eq skip-zeros :mask)
				       'store-fill-data-or-mask)
				      ((eql skip-zeros -1)
				       'store-fill-data-or-ones)
				      (t (unless (member skip-zeros '(:original :~original))
					   (setq pixel-function-args
						 (list skip-zeros)))
					 'store-fill-data-or-value)))
			       (t pixel-function)))
	 (pixel-function (if (or (neq skip-zeros :skip)
				 (not (memq pixel-function '(store-fill-data-or-zero
							      store-fill-data-or-ones
							      store-fill-data-or-value
							      store-fill-data-or-mask))))
			     pixel-function
			     'store-fill-data))
	 (main-loop `(loop repeat ,height
			   ,@(when rotate-source
				 `(with alu-register =
				       #+imach
				       ,(if use-bar-registers
					    '(%READ-INTERNAL-REGISTER
					       %REGISTER-ALU-AND-ROTATE-CONTROL)
					    rotate-source)
				       #+3600 rotate-source))
			   with pixels-in-first-chunk
			     = (min (- ,pixels-in-a-chunk ,pixels-in-first-chunk) ,width)
			   ,@(when ( d-elements-per-q 1)
			       `(and exit-d-phase = (%fixnum-mod  (+ ,width ,d-phase)
							    ,d-elements-per-q)))
			   and entry-d-phase = (%fixnum-mod (- ,d-phase ,s-phase)
							    ,d-elements-per-q)
			     ,@(if write-mask
				 `(and write-protect-mask
				       = (lognot (effective-write-mask
						   ,(if (and write-mask write-byte-pointer)
							`(logand write-mask
								 (%logdpb -1
									  ,write-byte-pointer
									  0))
							'write-mask)
						   ,d-elements-per-q))
				       ,@(unless (= d-elements-per-q 1)
					   `(with first-word-mask =
				         (logior write-protect-mask
						 (lsh -1 (- (lsh ,d-phase ,d-size-shift) 32)))
				       and last-word-mask =
				       (if (zerop exit-d-phase) write-protect-mask
				        (logior write-protect-mask
						(lsh -1 (lsh exit-d-phase ,d-size-shift))
				       )))))
				 (unless (eql d-elements-per-q 1)
				 `(with first-word-mask = 
				        (lsh -1 (- (lsh ,d-phase ,d-size-shift) 32))
				       and last-word-mask = (if (zerop exit-d-phase) 0
								(lsh -1 (lsh exit-d-phase
									 ,d-size-shift))))))
			   and y-wrap-to = (%fixnum-floor ,pixels-in-first-chunk ,s-elements-per-q)
			   for saddr first ,sx
				     then
			       (let ((next (+ saddr ,source-span)))
				 (if (= next ,wrap-y-from)
				     y-wrap-to
				     next))
			   as daddr from ,dx by ,dest-span
			   as wrap-x-to = (- saddr y-wrap-to)
			   do ,@(unless (eql d-elements-per-q 1)
				  `((ignore last-word-mask first-word-mask)))

		       (repack-row ,s-elements-per-q ,d-elements-per-q ,width 
				   ,s-phase entry-d-phase source saddr dest daddr
				   pixels-in-first-chunk ,pixels-in-a-chunk wrap-x-to
				   :use-bar-registers ,use-bar-registers
				   :skip-outside-bits ,skip-outside-bits
				   :write-mask ,write-mask
				   :source-bar ,source-bar
				   :dest-bar ,dest-bar
				   :first-word-mask ,(if (eql d-elements-per-q 1)
							 nil
							 'first-word-mask)
				   :last-word-mask ,(if (eql d-elements-per-q 1)
							nil
							'last-word-mask)
				   :exit-d-phase exit-d-phase
				   :write-alu ,write-alu
				   :skip-zeros ,skip-zeros
				   :rotate-source ,rotate-source
				   :pixel-function ,pixel-function
				   :pixel-function-gets-dest ,pixel-function-gets-dest
				   :pixel-function-args ,pixel-function-args
				   ,@(copylist repack-row-keywords)))
		       ))
    (if use-bar-registers
	`(multiple-value-bind (nil nil source)
	     (if (arrayp ,indirect-source)
		 (si:setup-force-1d-array ,indirect-source)
		 (values nil nil ,indirect-source))
	   (multiple-value-bind (nil nil dest)
	       (if (arrayp ,indirect-dest)
		   (si:setup-force-1d-array ,indirect-dest)
		   (values nil nil ,indirect-dest))
						;(dbg:when-mode-lock (dbg))
	     (with-block-registers (,source-bar ,dest-bar)
	       ,@(when rotate-source
		   #+imach
		   `((let ((off (%fixnum-mod (- ,rotate-source) 32.)))
		       (cli::SET-ALU-AND-ROTATE-REGISTER
			 2(0cli::2BITBLT-ALU-MAP 0,(cond ((or (null write-alu) (< write-alu 0))
						      tv:alu-seta)
						     (t tv:alu-seta)))
			 off 32.)))
		   #+3600
		   ())
	       ,main-loop)))
	`(let* ((source ,indirect-source)
		(dest ,indirect-dest))
	   (declare (sys:array-register-1d source dest))
	   ,main-loop)
	))))

(defvar *repack-rectangle-functions* (scl:make-hash-table :test #'equal))
(defvar *latest-function-spec* nil)
(defvar *latest-function-definition* nil)
(defvar *latest-function* nil)
(defun make-repack-rectangle-function
       (source-bits dest-bits other-args other-keys
	&key (compile :defer) other-keywords other-key-args name
	(function-parent 'def-repack-rectangle-function)
	)

  (let* ((new-function-name (or name
				(funcall (if (eq compile t) #'make-symbol #'intern)
					 (format nil "Repack-~D->~D~{!~A ~A~}~{!~A ~A~}"
						 source-bits
						 dest-bits
						 other-keys
						 other-key-args))))
	 (new-function-body `(lambda (width height
				      source source-span sx s-phase 
				      dest dest-span dx d-phase
				      initial-index pixels-in-a-chunk wrap-y-from
				      ,@(copylist other-args))
			       ,@(cond ((listp function-parent)
					`((declare (sys:function-parent ,@function-parent))))
				       (function-parent
					`((declare (sys:function-parent ,new-function-name
									,function-parent)))))
			       (ignore ,@(copylist other-args))
			       (repack-rectangle width height
						 source source-span sx s-phase ,(// 32 source-bits)
						 dest dest-span dx d-phase ,(// 32 dest-bits)
						 initial-index pixels-in-a-chunk wrap-y-from
						 ,@(copylist other-keys)
						 ,@(copylist other-keywords))))
	 (function-spec `(,source-bits ,dest-bits
			  ,@(copy-if-necessary other-keys)
			  ,@(copy-if-necessary other-key-args)
			  ))
	 )
    ;;for debugging
    ;;(setq newf `(defun ,new-function-name ,@(cdr new-function-body)))
    (selectq compile
      ((t) (tv:unprepare-sheet
	     (let ((new-function (compile new-function-name new-function-body)))
	       (setq *latest-function-spec* function-spec)
	       (setq *latest-function-definition* new-function-body)
	       (setq *latest-function* new-function-name)
	       (puthash function-spec
			new-function-name
			*repack-rectangle-functions*)
	       (values new-function function-spec))))
      (:defer `(progn (defun ,new-function-name ,@(cdr new-function-body))
		      (puthash ',function-spec
			       ',new-function-name
			       *repack-rectangle-functions*))))))

(defmacro def-repack-rectangle-function (&rest args)
  (cl:apply #'make-repack-rectangle-function args))

(defmacro load-source-byte (src byte)
  (if (and (listp src)
	   (eq (car src) '%logldb)
	   (listp byte)
	   (eq (first byte) 'byte)
	   (let ((spec (second src)))
	     (and (listp spec)
		  (eql (car spec) 'byte)
		  ( (second byte) (second spec)))))
      `(%logldb (byte ,(second byte)
		      (+ ,(third byte) ,(third (second src))))
		,(third src))
      `(%logldb ,byte ,src)))


#||

More things to think about

(1) Restructure :draw-1-bit-raster to generate a 1 pass request when
both ones and zeros are being stored under compatible conditions.
(2) augment shift alus to include booleans
(3) recast PIXEL-COPY-xx to use these
(4) restructure to permit hacjhing of copy functions at a higher level


2Still to do:

0optimize with use of block-read-shift and block-read-alu

alu-add

integrate this with Lmach, so as much commonality as possible can be maintained 
when we begin to extend the opcodes


2New capabilities we have already, that should arrange to become available
on the lmachine:

0bitblt-shift with mask and alu
correct font drawing for arbitrary pixel depth and alu

||#

(defmacro precompile-repackers ()
  (let ((specs ))
    (maphash #'(lambda (key dat)
		 (let ((other-a (nthcdr 13 (arglist dat))))
		   (push `(,other-a ,@key) specs)))
	     *repack-rectangle-functions*)
    `(progn
      ,@(loop for (other-args s d . other-keys) in specs
	      collect `(def-repack-rectangle-function ,s ,d ,other-args ,other-keys
						       :compile :defer)))))

