;;; -*- Mode: LISP;  Package: TV;  Base: 8 -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Superior that supports its inferiors as panes -- windows which are managed
;;; by the superior in some way

;;; Each window that is a pane (an inferior of a frame), should include
;;; the PANE-MIXIN flavor so as to interact correctly
(DEFFLAVOR PANE-MIXIN () ()
  (:REQUIRED-FLAVORS ESSENTIAL-WINDOW)
  (:DOCUMENTATION :MIXIN "Included in windows that are to be inferiors of a frame"))

(DEFFLAVOR PANE-NO-MOUSE-SELECT-MIXIN () (PANE-MIXIN DONT-SELECT-WITH-MOUSE-MIXIN))

(DEFMETHOD (:PRINT-SELF PANE-MIXIN) (STREAM IGNORE SLASHIFY-P)
  (IF SLASHIFY-P
      (LET ((PANE-NAME (SEND-IF-HANDLES SUPERIOR :PANE-NAME SELF)))
	(SI:PRINTING-RANDOM-OBJECT (SELF STREAM :NO-POINTER)	;Do %POINTER explicitly
	  (FORMAT STREAM "~A ~A ~:[~*~*~;(pane ~A of ~A) ~]~\si:address\ ~A"
		  (TYPEP SELF) NAME
		  PANE-NAME PANE-NAME SUPERIOR
		  (%POINTER SELF)
		  (IF EXPOSED-P "exposed"
		      (IF (OR (NULL SUPERIOR)
			      (MEMQ SELF (SHEET-INFERIORS SUPERIOR)))
			  "deexposed"
			  "deactivated")))))
      (SEND STREAM ':STRING-OUT (STRING (OR (SEND SELF ':NAME-FOR-SELECTION) NAME)))))

(DEFWHOPPER (:EXPOSE PANE-MIXIN) (&REST ARGS)
  "Notify the superior before the :EXPOSE is done.  A value of NIL returned
means to punt the expose."
  (WHEN (SEND SUPERIOR :INFERIOR-EXPOSE SELF)
    (LEXPR-CONTINUE-WHOPPER ARGS)))

(DEFWHOPPER (:DEEXPOSE PANE-MIXIN) (&REST ARGS)
  "Notify the superior about :DEEXPOSE."
  (WHEN (SEND SUPERIOR :INFERIOR-DEEXPOSE SELF)
    (LEXPR-CONTINUE-WHOPPER ARGS)))

(DEFWHOPPER (:BURY PANE-MIXIN) (&REST ARGS)
  "Notify the superior about :BURY."
  (WHEN (SEND SUPERIOR :INFERIOR-BURY SELF)
    (LEXPR-CONTINUE-WHOPPER ARGS)))

(DEFWHOPPER (:SET-EDGES PANE-MIXIN) (&REST ARGS)
  (LET ((VALUES (MULTIPLE-VALUE-LIST
		  (LEXPR-SEND SUPERIOR :INFERIOR-SET-EDGES SELF ARGS))))
    (IF (NOT (FIRST VALUES))
	(VALUES (REST1 VALUES))
	(LEXPR-CONTINUE-WHOPPER ARGS))))

(DEFWHOPPER (:SELECT PANE-MIXIN) (&REST ARGS)
  (WHEN (SEND SUPERIOR :INFERIOR-SELECT SELF)
    (LEXPR-CONTINUE-WHOPPER ARGS)))

(DEFMETHOD (:MOUSE-SELECT PANE-MIXIN) (&REST ARGS)
  "When selecting a pane with the mouse, pass the selection request to the frame."
  (LEXPR-SEND SUPERIOR ':MOUSE-SELECT ARGS))

(DEFMETHOD (:ALIAS-FOR-SELECTED-WINDOWS PANE-MIXIN) ()
  (SEND SUPERIOR ':ALIAS-FOR-SELECTED-WINDOWS))

(DEFMETHOD (:SQUARE-PANE-SIZE PANE-MIXIN) (MAX-WIDTH MAX-HEIGHT IGNORE IGNORE STACKING)
  (SELECTQ STACKING
    (:VERTICAL MAX-WIDTH)
    (:HORIZONTAL MAX-HEIGHT)))

(DEFMETHOD (:SQUARE-PANE-INSIDE-SIZE PANE-MIXIN) (MAX-WIDTH MAX-HEIGHT IGNORE IGNORE STACKING)
  (SELECTQ STACKING
    (:VERTICAL
     (+ TOP-MARGIN-SIZE (- MAX-WIDTH LEFT-MARGIN-SIZE RIGHT-MARGIN-SIZE) BOTTOM-MARGIN-SIZE))
    (:HORIZONTAL
     (+ LEFT-MARGIN-SIZE (- MAX-HEIGHT TOP-MARGIN-SIZE BOTTOM-MARGIN-SIZE) RIGHT-MARGIN-SIZE))
    ))

(DEFFLAVOR MARGINLESS-WINDOW-PANE () (PANE-MIXIN MARGINLESS-WINDOW)
  (:DOCUMENTATION :COMBINATION "Marginless window within a frame.  
Mixins must supply borders, labels, etc."))

(DEFFLAVOR WINDOW-PANE () (PANE-MIXIN WINDOW)
  (:DOCUMENTATION :COMBINATION "Plain window within a frame"))

(DEFFLAVOR LISP-LISTENER-PANE () (PANE-MIXIN LISP-LISTENER)
  (:DOCUMENTATION :COMBINATION "Lisp listener within a frame"))

(DEFFLAVOR COMMAND-MENU-PANE () (PANE-MIXIN COMMAND-MENU)
  (:DOCUMENTATION :COMBINATION "Command menu within a frame"))

;;; Basic frame contains methods that are used by most frames
(DEFFLAVOR BASIC-FRAME ((SELECTED-PANE NIL))
  (ESSENTIAL-EXPOSE ESSENTIAL-ACTIVATE ESSENTIAL-SET-EDGES ESSENTIAL-WINDOW)
  (:REQUIRED-METHODS :INFERIOR-SET-EDGES)
  (:DEFAULT-INIT-PLIST :BLINKER-P NIL :MORE-P NIL)
  (:DOCUMENTATION :LOWLEVEL-MIXIN "Pane handling messages used by most frames"))

;; If the selected pane is itself a frame, ask it instead.  This is
;; consistent with the theoretical basis for :alias-for-selected-windows
(DEFMETHOD (:SELECTED-PANE BASIC-FRAME) ()
  (OR (AND (INSTANCEP SELECTED-PANE) (SEND-IF-HANDLES SELECTED-PANE :SELECTED-PANE))
      SELECTED-PANE))

;This sets what pane should be selected if this window is selected.
(DEFMETHOD (:SELECT-PANE BASIC-FRAME) (PANE)
  (OR (MEMQ PANE EXPOSED-INFERIORS)
      (NULL PANE)
      (FERROR "Cannot select ~S, which is not a pane of ~S" PANE SELF))
  ;; Deselect the previous selected pane, since it will no longer receive
  ;; a deselect message from this frame
  (DELAYING-SCREEN-MANAGEMENT
    (AND SELECTED-PANE (NEQ PANE SELECTED-PANE)
	 (SEND SELECTED-PANE ':DESELECT NIL))
    ;; Select the new selected pane relative to its activity (a.k.a. window hierarchy)
    (AND PANE (SEND PANE ':SELECT-RELATIVE)))
  ;; Remember what pane is selected so select and deselect messages can be forwarded to it
  (SETQ SELECTED-PANE PANE))

(DEFMETHOD (:SELECT-RELATIVE BASIC-FRAME) (&REST ARGS)	; probably needs more checking
  (AND SELECTED-PANE (LEXPR-SEND SELECTED-PANE ':SELECT-RELATIVE ARGS)))

(DEFMETHOD (:SELECT BASIC-FRAME) (&REST ARGS)
  (AND SELECTED-PANE (LEXPR-SEND SELECTED-PANE ':SELECT ARGS)))

(DEFMETHOD (:DESELECT BASIC-FRAME) (&REST ARGS)
  (AND SELECTED-PANE (LEXPR-SEND SELECTED-PANE ':DESELECT ARGS)))

(DEFMETHOD (:NAME-FOR-SELECTION BASIC-FRAME) ()
  (OR (AND SELECTED-PANE (SEND SELECTED-PANE ':NAME-FOR-SELECTION))
      NAME))

(DEFWHOPPER (:STATUS BASIC-FRAME) ()
  (IF (AND SELECTED-PANE (EQ (SEND SELECTED-PANE ':STATUS) ':SELECTED))
      ':SELECTED
      (CONTINUE-WHOPPER)))

(DEFMETHOD (:DEACTIVATE BASIC-FRAME :AFTER) (&REST IGNORE)
  ;; May not have select mixin, but may still be remembered due to aliasing
  ;; by an inferior.
  (REMOVE-FROM-PREVIOUSLY-SELECTED-WINDOWS SELF T)
  ;; Make sure that none of our inferiors are remembered as selectable
  (DOLIST (I INFERIORS)
    (REMOVE-FROM-PREVIOUSLY-SELECTED-WINDOWS I T)))

(DEFMETHOD (:ACTIVATE BASIC-FRAME :AFTER) (&REST IGNORE)
  ;; Make sure that the selected pane is activated.  This may have side-effects, like
  ;; adding the window to the list of previously selected windows.
  (AND SELECTED-PANE (SEND SELECTED-PANE ':ACTIVATE)))

(DEFMETHOD (:INFERIOR-SELECT BASIC-FRAME) (PANE)
  (SETQ SELECTED-PANE PANE)
  (SEND SUPERIOR :INFERIOR-SELECT SELF))

;;; Screen management et. al.

(DEFMETHOD (:SCREEN-MANAGE-DEEXPOSED-VISIBILITY BASIC-FRAME) () T)

(DEFMETHOD (:SCREEN-MANAGE-UNCOVERED-AREA BASIC-FRAME) (RECTS ARRAY X Y ALU)
  (SCREEN-MANAGE-CLEAR-UNCOVERED-AREA RECTS ARRAY X Y ALU))

(DEFMETHOD (:PANE-TYPES-ALIST BASIC-FRAME) ()
  NIL)

;;; Simple superior for split-screen
(DEFFLAVOR SPLIT-SCREEN-FRAME () (BASIC-FRAME))

(DEFMETHOD (:PANE-TYPES-ALIST SPLIT-SCREEN-FRAME) ()
  DEFAULT-WINDOW-TYPES-ITEM-LIST)

;;; Constraint frames -- these frames maintain their panes based on a set
;;;  of constraints.  These frames are the right thing for most frame applications.
(DEFFLAVOR BASIC-CONSTRAINT-FRAME (PANES INTERNAL-PANES SELECTED-PANE
				   (EXPOSED-PANES NIL)
				   CONSTRAINTS PARSED-CONSTRAINTS INTERNAL-CONSTRAINTS
				   (SUBSTITUTIONS NIL)
				   (BLANK-RECTANGLES NIL)
				   (CONFIGURATION NIL))
	   (BASIC-FRAME)
  (:INITABLE-INSTANCE-VARIABLES CONSTRAINTS PANES SUBSTITUTIONS SELECTED-PANE CONFIGURATION)
  (:GETTABLE-INSTANCE-VARIABLES CONSTRAINTS PANES CONFIGURATION)
  (:SETTABLE-INSTANCE-VARIABLES EXPOSED-PANES)
  (:INIT-KEYWORDS :CONFIGURATIONS)
  (:FUNCTIONS CONSTRAINT-FRAME-PROCESS-CONSTRAINTS CONSTRAINT-FRAME-DRAW-BLANK-SPACE
	      CONSTRAINT-FRAME-RECOMPUTE-CONFIGURATION
	      CONSTRAINT-FRAME-SCREEN-MANAGE-UNCOVERED-AREA
	      CONSTRAINT-FRAME-MAKE-BLANK-RECTANGLES
	      CONSTRAINT-FRAME-WINDOWS CONSTRAINT-FRAME-SUBSTITUTION
	      PARSE-CONSTRAINT PARSE-CONSTRAINT-GET-PANE CONSTRAINT-FRAME-DRAW-A-BLANK)
  (:DOCUMENTATION :LOWLEVEL-MIXIN "Maintains panes according to specified constraints"))


(DEFFLAVOR CONSTRAINT-FRAME ()
	   (BASIC-CONSTRAINT-FRAME BASIC-FRAME)
  (:DOCUMENTATION :MIXIN "Normal constraint frame"))

(DEFFLAVOR BORDERED-CONSTRAINT-FRAME ()
	   (BASIC-CONSTRAINT-FRAME BORDERS-MIXIN BASIC-FRAME)
  (:DEFAULT-INIT-PLIST :BORDER-MARGIN-WIDTH 0)
  (:DOCUMENTATION :COMBINATION "Maintains uniform borders around panes"))


(DEFSTRUCT (CONSTRAINT-NODE :ARRAY)
  CONSTRAINT-NAME			;Name of this node
  (CONSTRAINT-MIN -1)			;Minimum limit
  (CONSTRAINT-MAX 1_20.)		;Maximum limit
  CONSTRAINT-CONSTRAINT			;The constraint as specified by the user
  CONSTRAINT-TYPE			;One of: :WINDOW, :STACKING, :IF, :BLANK
  CONSTRAINT-DATA			;If WINDOW: the window
					;If SPECIAL: (ordering . inferiors)
					;If IF: (conditional . inferiors)
					;If BLANK: function to draw "whitespace"
  (CONSTRAINT-CW 0)			;Current position of this window (if a window)
  (CONSTRAINT-CH 0)
  (CONSTRAINT-CX 0)
  (CONSTRAINT-CY 0)
  (CONSTRAINT-PW 0)			;Proposed position
  (CONSTRAINT-PH 0)
  (CONSTRAINT-PX 0)
  (CONSTRAINT-PY 0))

(DEFUN-IN-FLAVOR (CONSTRAINT-FRAME-PROCESS-CONSTRAINTS BASIC-CONSTRAINT-FRAME) (&REST IGNORE)
  "CONSTRAINTS contains a list of unprocessed constraints.  Process them.  Entries
look like:

   constraint := ({:LIMIT (min max {[:LINES | :CHARACTERS]})}
		  [:ASK-WINDOW pane-name message . args |
                   :ASK message . args |
		   :FUNCALL function . args |
		   :EVAL form |
		   [:EVEN | fixnum | flonum] {[:LINES | :CHARACTERS]} |
		   :FIXED
		   ])

   desc := (ordering desc-part)
   desc-part := (desc-group) {desc-part}
   desc-group := [ ('window name' . constraint) |
   		   ('special name' [:HORIZONTAL | :VERTICAL] constraint . desc) |
		   ('special name' :IF [conditional | :ELSE] desc)
		   ('special name' :BLANK [:WHITE | :BLACK] constraint)
		   ] {desc-group}


    Fixnum - absolute number of pixels
    Flonum - percentage of available space
    :EVEN - divide remaining space evenly among all :EVEN constraints
            :EVEN's can only be in the last descriptor group, and must be by themselves
            (No other types of constraints allowed)
    :ASK, :ASK-WINDOW, :FUNCALL - sends the message to the pane with the args as shown below,
      and the specified args, and expects back the height or
      the width that the window wants to be.  :ASK-WINDOW takes the
      name of a window as its first arg.

    :EVAL - evals the specified form

    :FIXED - Only for a window: never change the window's size

    For :FUNCALL the first arg is the node.  
    For :EVAL, **CONSTRAINT-NODE** is bound to the node.

      The first five arguments given to the method are as follows:
	**CONSTRAINT-REMAINING-WIDTH** - The maximum width of the window (amount
					 of space remaining for this window)
	**CONSTRAINT-REMAINING-HEIGHT** - The maximum height
	**CONSTRAINT-TOTAL-WIDTH** - The total width of the current section
	**CONSTRAINT-TOTAL-HEIGHT** - The total height of the current section
	**CONSTRAINT-CURRENT-STACKING** - :HORIZONTAL or :VERTICAL, depending upon
					    which dimension is currently being hacked

      (In the case of :EVAL, these special variables are bound)

 A typical frame setup might be (dimension starts out as :HEIGHT):
 ((WA LISP-LISTENER) (WB MENU :ITEM-LIST (foo bar baz quux))
  (WC MY-OWN-LISP-LISTENER) (WD SOME-OTHER-FUNNY-WINDOW :MY-INIT MY-ARG))

 ((WA
   WB
   G0)
  ((WB :ASK :PANE-SIZE))
  ((WA :LIMIT (3 NIL :LINES) :EVEN)
   (G0 :HORIZONTAL (:ASK-WINDOW WD :PANE-SIZE)
       (WD WC)
       ((WC :LIMIT (10. NIL :LINES) :EVEN)
        (WD :LIMIT (10. NIL :LINES) :EVEN)))))
"

  ;; First turn constraint list into nodes
  (SETQ INTERNAL-PANES (CONSTRAINT-FRAME-WINDOWS PANES))
  (SETQ PARSED-CONSTRAINTS NIL)
  (DOLIST (CONSTR CONSTRAINTS)
    (PUSH (CONS (CAR CONSTR)
		(CONSTRAINT-FRAME-PARSE-CONSTRAINTS SELF (CDR CONSTR)))
	  PARSED-CONSTRAINTS))
  (SETQ PARSED-CONSTRAINTS (NREVERSE PARSED-CONSTRAINTS)))

(DEFMETHOD (:INIT BASIC-CONSTRAINT-FRAME :AFTER) (INIT-PLIST)
  (LET ((CONFIGURATIONS (GET INIT-PLIST ':CONFIGURATIONS)))
    (WHEN CONFIGURATIONS
      (SETQ CONSTRAINTS (CONVERT-CONFIGURATIONS CONFIGURATIONS PANES))))
  (CONSTRAINT-FRAME-PROCESS-CONSTRAINTS)
  (SETF `(,CONFIGURATION . ,INTERNAL-CONSTRAINTS)
	(IF CONFIGURATION
	    (OR (ASSQ CONFIGURATION PARSED-CONSTRAINTS)
		(FERROR "Configuration ~S not found" CONFIGURATION))
	    (FIRST PARSED-CONSTRAINTS)))	;Default initial configuration
  (AND SELECTED-PANE
       (SYMBOLP SELECTED-PANE)
       (SETQ SELECTED-PANE (SEND SELF ':GET-PANE SELECTED-PANE)))
  (CONSTRAINT-FRAME-RECOMPUTE-CONFIGURATION))

(DEFUN-IN-FLAVOR (CONSTRAINT-FRAME-DRAW-BLANK-SPACE BASIC-CONSTRAINT-FRAME)
	      (&OPTIONAL (CONSTRS INTERNAL-CONSTRAINTS))
  "Map over the constraint data structure, and draw all blank area."
  (DOLIST (AENTRY (FIRST CONSTRS))
    (LET ((NODE (CDR AENTRY)))
      (SELECTQ (CONSTRAINT-TYPE NODE)
	(:BLANK (PREPARE-SHEET (SELF)
		  (CONSTRAINT-FRAME-DRAW-A-BLANK (CONSTRAINT-DATA NODE) NODE
						 (CONSTRAINT-CX NODE) (CONSTRAINT-CY NODE)
						 (CONSTRAINT-CW NODE) (CONSTRAINT-CH NODE)
						 SELF)))
	(:STACKING (CONSTRAINT-FRAME-DRAW-BLANK-SPACE (CONSTRAINT-DATA NODE)))))))

(DEFMETHOD (:REFRESH BASIC-CONSTRAINT-FRAME :AFTER) (&OPTIONAL TYPE)
  (OR (AND RESTORED-BITS-P (NEQ TYPE ':SIZE-CHANGED))
      (EQ TYPE ':MARGINS-ONLY)
      (CONSTRAINT-FRAME-DRAW-BLANK-SPACE)))

;;; A frame has no content, just its inferiors.  Screen manager takes care of the blank area.
;;; We just have to do the margins
(DEFMETHOD (REFRESH-RECTANGLE BASIC-FRAME) (LEFT TOP RIGHT BOTTOM)
  (IGNORE LEFT TOP RIGHT BOTTOM)
  (REFRESH-MARGINS-RECTANGLE SELF LEFT TOP RIGHT BOTTOM))

;;; Inform the screen editor that it can move our inferiors about.
(DEFMETHOD (:INFERIORS-EDITABLE-P BASIC-FRAME) () T)

;;; Stuff for dealing with panes by name

(DEFMETHOD (:GET-PANE BASIC-CONSTRAINT-FRAME) (PANE-NAME)
  "Returns the pane with specified name or NIL if not found"
  (CDR (ASSQ PANE-NAME INTERNAL-PANES)))

(DEFMETHOD (:SEND-PANE BASIC-CONSTRAINT-FRAME) (PANE-NAME MESSAGE &REST ARGS &AUX W)
  "Send a message to the pane with specified name (error if not found)"
  (IF (SETQ W (CDR (ASSQ PANE-NAME INTERNAL-PANES)))
      (LEXPR-SEND W MESSAGE ARGS)
      (FERROR "No pane named ~S in this frame" PANE-NAME)))

(DEFMETHOD (:SEND-ALL-PANES BASIC-CONSTRAINT-FRAME) (MESSAGE &REST ARGS)
  "Send a message to all panes, including non-exposed ones"
  (DOLIST (X INTERNAL-PANES)
    (LEXPR-SEND (CDR X) MESSAGE ARGS)))

(DEFMETHOD (:SEND-ALL-EXPOSED-PANES BASIC-CONSTRAINT-FRAME) (MESSAGE &REST ARGS)
  "Send a message to all exposed panes"
  (DOLIST (X INTERNAL-PANES)
    (AND (MEMQ (CDR X) EXPOSED-INFERIORS)
	 (LEXPR-SEND (CDR X) MESSAGE ARGS))))

(DEFMETHOD (:PANE-NAME BASIC-CONSTRAINT-FRAME) (PANE)
  "Given a pane, this returns the name for that pane the user gave in his alist.
   NIL if for some reason it is not found."
  (DOLIST (X INTERNAL-PANES)
    (AND (EQ (CDR X) PANE) (RETURN (CAR X)))))


(DEFMETHOD (:GET-CONFIGURATION BASIC-CONSTRAINT-FRAME) (CONFIG-NAME)
  (CDR (ASSQ CONFIG-NAME PARSED-CONSTRAINTS)))

(DEFMETHOD (:REDEFINE-CONFIGURATION BASIC-CONSTRAINT-FRAME) (CONFIG-NAME NEW-CONFIG
							     &OPTIONAL (PARSED-P T))
  (UNLESS PARSED-P
    (SETQ NEW-CONFIG (CONSTRAINT-FRAME-PARSE-CONSTRAINTS SELF NEW-CONFIG)))
  (LET ((CONFIG (ASSQ CONFIG-NAME PARSED-CONSTRAINTS)))
    (UNLESS CONFIG
      (SETQ CONFIG (CONS CONFIG-NAME NIL))
      (WITHOUT-INTERRUPTS
	(SETQ PARSED-CONSTRAINTS (NCONC PARSED-CONSTRAINTS (NCONS CONFIG)))))
    (RPLACD CONFIG NEW-CONFIG)
    NEW-CONFIG))

(DEFMETHOD (:CONFIGURATION-NAMES BASIC-CONSTRAINT-FRAME) ()
  (LOOP FOR (NAME . NIL) IN PARSED-CONSTRAINTS COLLECT NAME))

(DEFMETHOD (:SET-CONFIGURATION BASIC-CONSTRAINT-FRAME) (NEW-CONFIG-NAME)
  (LET ((CONFIG (ASSQ NEW-CONFIG-NAME PARSED-CONSTRAINTS)))
    (OR CONFIG (FERROR "Unknown configuration ~S" NEW-CONFIG-NAME))
    (SETQ CONFIGURATION (CAR CONFIG)
	  INTERNAL-CONSTRAINTS (CDR CONFIG)
	  BLANK-RECTANGLES NIL))
  (CONSTRAINT-FRAME-CLEAR-CURRENT-POSITION INTERNAL-CONSTRAINTS)
  (CONSTRAINT-FRAME-RECOMPUTE-CONFIGURATION))

(DEFUN CONSTRAINT-FRAME-CLEAR-CURRENT-POSITION (CONSTRS &AUX NODE)
  (DOLIST (AENTRY (FIRST CONSTRS))
    (SETQ NODE (CDR AENTRY))
    (SELECTQ (CONSTRAINT-TYPE NODE)
      (:WINDOW
       (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
	   (SEND (CONSTRAINT-DATA NODE) ':EDGES)
	 (SETF (CONSTRAINT-CX NODE) LEFT)
	 (SETF (CONSTRAINT-CY NODE) TOP)
	 (SETF (CONSTRAINT-CW NODE) (- RIGHT LEFT))
	 (SETF (CONSTRAINT-CH NODE) (- BOTTOM TOP))))
      (:STACKING
       (CONSTRAINT-FRAME-CLEAR-CURRENT-POSITION (CONSTRAINT-DATA NODE)))
      (:IF (FERROR ":IF node type not yet implemented"))
      (OTHERWISE
       (SETF (CONSTRAINT-CX NODE) 0)
       (SETF (CONSTRAINT-CY NODE) 0)
       (SETF (CONSTRAINT-CW NODE) 0)
       (SETF (CONSTRAINT-CH NODE) 0)))))

(DEFMETHOD (:VERIFY-NEW-EDGES BASIC-CONSTRAINT-FRAME) (IGNORE IGNORE NEW-WIDTH NEW-HEIGHT)
  (COND ((VARIABLE-BOUNDP INTERNAL-CONSTRAINTS)
	 (IF (NOT (CONSTRAINT-FRAME-DO-CONSTRAINTS SELF INTERNAL-CONSTRAINTS
					  (- NEW-WIDTH LEFT-MARGIN-SIZE RIGHT-MARGIN-SIZE)
					  (- NEW-HEIGHT TOP-MARGIN-SIZE BOTTOM-MARGIN-SIZE)))
	     "Some constraint cannot be satisfied"
	     ;; Change our size temporarily
	     ;; so that panes will check their edges against the new size
	     (WITHOUT-INTERRUPTS
	       (LET-GLOBALLY ((WIDTH NEW-WIDTH) (HEIGHT NEW-HEIGHT))
		 (COND ((CONSTRAINT-FRAME-SET-EDGES INTERNAL-CONSTRAINTS ':VERIFY) NIL)
		       (T "Some pane refused to have its size set"))))))))

(DEFUN-IN-FLAVOR (CONSTRAINT-FRAME-RECOMPUTE-CONFIGURATION BASIC-CONSTRAINT-FRAME) ()
  (WITH-SHEET-DEEXPOSED (SELF)
    (DOLIST (P EXPOSED-PANES)
      (SEND P ':DEEXPOSE ':DEFAULT ':NOOP)
      ;; This assures that old panes won't gratuitously reappear if there is
      ;; blank space in the new configuration where a pane used to be.  Note that
      ;; this is careful not to touch inferiors that aren't "panes" of this
      ;; constraint frame.
      (SEND P ':DEACTIVATE))
    (OR (CONSTRAINT-FRAME-DO-CONSTRAINTS SELF INTERNAL-CONSTRAINTS
					 (SHEET-INSIDE-WIDTH) (SHEET-INSIDE-HEIGHT))
	(FERROR "Some constraint could not be satisfied"))
    (CONSTRAINT-FRAME-SET-EDGES INTERNAL-CONSTRAINTS NIL)
    (DOLIST (P EXPOSED-PANES) (SEND P ':EXPOSE))
    (SETQ BLANK-RECTANGLES NIL)
    (SHEET-FORCE-ACCESS (SELF :NO-PREPARE)
      (CONSTRAINT-FRAME-DRAW-BLANK-SPACE))
    (OR (MEMQ SELECTED-PANE EXPOSED-INFERIORS)
	(SETQ SELECTED-PANE NIL))))

;;; When the inside-size changes, rethink the constraints and panes' edges
(DEFMETHOD (:CHANGE-OF-SIZE-OR-MARGINS BASIC-CONSTRAINT-FRAME :AFTER) (&REST IGNORE)
  (CONSTRAINT-FRAME-RECOMPUTE-CONFIGURATION))

(DEFUN-IN-FLAVOR (CONSTRAINT-FRAME-SCREEN-MANAGE-UNCOVERED-AREA BASIC-CONSTRAINT-FRAME)
	      (RECTS ARRAY X Y IGNORE)
  "If there is any blank area, it might be covered by some :BLANK type constraints.
Check through the constraint list, and draw onto the array the appropriate swatches
of 'blankness'"
  (OR BLANK-RECTANGLES
      ;; If haven't figured out the blank rectangles, compute them now
      (SETQ BLANK-RECTANGLES
	    (OR (CONSTRAINT-FRAME-MAKE-BLANK-RECTANGLES INTERNAL-CONSTRAINTS)
		T)))
  (AND (NEQ BLANK-RECTANGLES T)
       (DOLIST (R RECTS)
	 (COND ((EQ (CAR (RECT-SOURCE R)) SELF)
		;; This is a blank area, hack appropriate portions of it
		(PROG DONE ((REMAINING-BLANK-RECTS (LIST R)))
		  (DOLIST (BLANK-RECT BLANK-RECTANGLES)
		    (DOLIST (REM-BLANK-RECT REMAINING-BLANK-RECTS)
		      (COND ((RECT-NOT-OVERLAP-RECT-P BLANK-RECT REM-BLANK-RECT))
			    (T
			     (LET ((NODE (FOURTH (RECT-SOURCE BLANK-RECT)))
				   (LEFT) (TOP) (RIGHT) (BOTTOM))
			       ;; Draw the overlapping area
			       (SETQ LEFT (MAX (RECT-LEFT BLANK-RECT)
					       (RECT-LEFT REM-BLANK-RECT))
				     TOP (MAX (RECT-TOP BLANK-RECT) (RECT-TOP REM-BLANK-RECT))
				     RIGHT (MIN (RECT-RIGHT BLANK-RECT)
						(RECT-RIGHT REM-BLANK-RECT))
				     BOTTOM (MIN (RECT-BOTTOM BLANK-RECT)
						 (RECT-BOTTOM REM-BLANK-RECT)))
			       (CONSTRAINT-FRAME-DRAW-A-BLANK
				 (CONSTRAINT-DATA NODE) NODE
				 (+ X LEFT) (+ Y TOP) (- RIGHT LEFT) (- BOTTOM TOP)
				 ARRAY))
			     (SETQ REMAINING-BLANK-RECTS
				   (NCONC (RECTANGLE-NOT-INTERSECTION BLANK-RECT
								      REM-BLANK-RECT)
					  (DELQ REM-BLANK-RECT REMAINING-BLANK-RECTS)))
			     (AND (NULL REMAINING-BLANK-RECTS) (RETURN-FROM DONE))))))
		  (SETQ RECTS (NCONC REMAINING-BLANK-RECTS RECTS)))
		(SETQ RECTS (DELQ R RECTS 1))))))
  RECTS)

(DEFWHOPPER-SUBST (:SCREEN-MANAGE-UNCOVERED-AREA BASIC-CONSTRAINT-FRAME)
		  (RECTS ARRAY X Y ALU)
  (CONTINUE-WHOPPER
    (CONSTRAINT-FRAME-SCREEN-MANAGE-UNCOVERED-AREA RECTS ARRAY X Y ALU)
    ARRAY X Y ALU))

(DEFUN-IN-FLAVOR (CONSTRAINT-FRAME-MAKE-BLANK-RECTANGLES BASIC-CONSTRAINT-FRAME) (CONSTR
									     &AUX RECTS)
  (DOLIST (AENTRY (FIRST CONSTR))
    (LET ((NODE (CDR AENTRY))
	  (X) (Y))
      (SELECTQ (CONSTRAINT-TYPE NODE)
	(:BLANK (PUSH (LIST (LIST SELF 0 0 NODE)
			    (SETQ X (CONSTRAINT-CX NODE)) (SETQ Y (CONSTRAINT-CY NODE))
			    (+ X (CONSTRAINT-CW NODE)) (+ Y (CONSTRAINT-CH NODE)))
		      RECTS))
	(:STACKING
	 (SETQ RECTS
	       (NCONC RECTS
		      (CONSTRAINT-FRAME-MAKE-BLANK-RECTANGLES (CONSTRAINT-DATA NODE))))))))
  RECTS)

(DEFVAR CONSTRAINT-FRAME-DEFAULT-STACKING ':VERTICAL)

(DEFUN CONSTRAINT-FRAME-SET-EDGES (CONSTRS OPTION &AUX X Y R)
  "Loop over all panes and hack the edges as specified by the option."
  (NOT
    (DOLIST (AENTRY (FIRST CONSTRS))
      (LET ((NODE (CDR AENTRY)))
	(SELECTQ (CONSTRAINT-TYPE NODE)
	  (:WINDOW
	   (SETQ R (OR (AND (NEQ OPTION ':VERIFY)
			    (= (CONSTRAINT-PX NODE) (CONSTRAINT-CX NODE))
			    (= (CONSTRAINT-PY NODE) (CONSTRAINT-CY NODE))
			    (= (CONSTRAINT-PW NODE) (CONSTRAINT-CW NODE))
			    (= (CONSTRAINT-PH NODE) (CONSTRAINT-CH NODE)))
		       (SEND (CONSTRAINT-DATA NODE) ':SET-EDGES
			     (SETQ X (CONSTRAINT-PX NODE)) (SETQ Y (CONSTRAINT-PY NODE))
			     (+ X (CONSTRAINT-PW NODE)) (+ Y (CONSTRAINT-PH NODE))
			     OPTION))))
	  (:STACKING (SETQ R (CONSTRAINT-FRAME-SET-EDGES (CONSTRAINT-DATA NODE) OPTION)))
	  (:IF (FERROR ":IF is unimplemented option"))
	  (OTHERWISE (SETQ R T)))
	(IF (EQ OPTION ':VERIFY)
	    
	    ;; If verifying, return right away if didn't verify
	    (OR R (RETURN T))
	    
	    ;; If not verifying, proposed data is now current data
	    (SETF (CONSTRAINT-CX NODE) (CONSTRAINT-PX NODE))
	    (SETF (CONSTRAINT-CY NODE) (CONSTRAINT-PY NODE))
	    (SETF (CONSTRAINT-CW NODE) (CONSTRAINT-PW NODE))
	    (SETF (CONSTRAINT-CH NODE) (CONSTRAINT-PH NODE)))))))

(DEFUN-IN-FLAVOR (CONSTRAINT-FRAME-WINDOWS BASIC-CONSTRAINT-FRAME) (DESCS &AUX PARSED)
  (DOLIST (DESC DESCS)
    (PUSH (CONS (FIRST DESC)
		(IF (TYPEP (CDR DESC) 'SHEET)
		    (CDR DESC)
		    (LEXPR-SEND SELF ':CREATE-PANE DESC)))
	  PARSED))
  PARSED)

(DEFMETHOD (:CREATE-PANE BASIC-CONSTRAINT-FRAME) (IGNORE FLAVOR &REST OPTIONS)
  (LEXPR-FUNCALL #'MAKE-WINDOW FLAVOR ':SUPERIOR SELF OPTIONS))

(DEFFLAVOR CONSTRAINT-FRAME-WITH-SHARED-IO-BUFFER ((IO-BUFFER NIL)) (BASIC-CONSTRAINT-FRAME)
  (:GETTABLE-INSTANCE-VARIABLES IO-BUFFER)
  (:INITABLE-INSTANCE-VARIABLES IO-BUFFER))

(DEFMETHOD (:INIT CONSTRAINT-FRAME-WITH-SHARED-IO-BUFFER :BEFORE) (IGNORE)
  (OR IO-BUFFER (SETQ IO-BUFFER (MAKE-DEFAULT-IO-BUFFER))))

(DEFMETHOD (:CREATE-PANE CONSTRAINT-FRAME-WITH-SHARED-IO-BUFFER) (IGNORE FLAVOR &REST OPTIONS)
  ;; If OPTIONS contains :IO-BUFFER, use it instead of our io-buffer.  This lets
  ;; people easily construct constraint-frames with shared io-buffers where one
  ;; of the inferiors has a different io-buffer from all the rest.
  ;; Writer Tools, where the zmacs inferior wants zmacs' io-buffer rather than
  ;; the program-framework's io-buffer is an example of this.
  (STACK-LET ((NEW-OPTIONS (LIST* :IO-BUFFER IO-BUFFER :SUPERIOR SELF OPTIONS)))
    (WHEN (CL:GETF OPTIONS :IO-BUFFER)
      (SETQ NEW-OPTIONS (CDDR NEW-OPTIONS)))
    (LEXPR-FUNCALL #'MAKE-WINDOW FLAVOR new-options)))

(DEFFLAVOR BORDERED-CONSTRAINT-FRAME-WITH-SHARED-IO-BUFFER ()
  (CONSTRAINT-FRAME-WITH-SHARED-IO-BUFFER BORDERS-MIXIN BASIC-FRAME)
  (:DEFAULT-INIT-PLIST :BORDER-MARGIN-WIDTH 0))

(DEFUN-IN-FLAVOR (CONSTRAINT-FRAME-SUBSTITUTION BASIC-CONSTRAINT-FRAME) (DESC)
  (COND ((LISTP DESC) DESC)
	((SYMBOLP DESC)
	 (OR (CDR (ASSQ DESC SUBSTITUTIONS))
	     (FERROR
	       "~S is a symbol where a list was expected (and it has no substitution)"
	       DESC)))
	(T (FERROR
	     "~S was found where a list (or a symbol with a substitution) was expected"
	     DESC))))

(DEFMETHOD (CONSTRAINT-FRAME-PARSE-CONSTRAINTS BASIC-CONSTRAINT-FRAME)
	   (CONSTRS &OPTIONAL (STACKING CONSTRAINT-FRAME-DEFAULT-STACKING))
  "Given a list of constraints, returns the internal format."
  (LET ((INTERNAL-ORDERING NIL)
	(ORDERING (CAR CONSTRS))
	(INTERNAL-DESCS NIL))
    (OR (LISTP ORDERING)
	(FERROR "Constraint ~S does not start with an ordering" CONSTRS))
    (DO ((WNS ORDERING (CDR WNS))
	 (WS NIL)
	 (WINDOW))
	((NULL WNS)
	 (SETQ INTERNAL-ORDERING (NREVERSE WS)))
      (PUSH (CONS (CAR WNS)
		  (IF (SETQ WINDOW (ASSQ (CAR WNS) INTERNAL-PANES))
		      (CDR WINDOW)		;A window, include the window itself
		      (CAR WNS)))		;Must be a special name, will fill it in later
	    WS))
    (DO ((DESC-GROUPS (CDR CONSTRS) (CDR DESC-GROUPS))
	 (INTERNAL-DESC-GROUP NIL NIL)
	 (EVEN-P NIL NIL)
	 (LAST-GROUP-P))
	((NULL DESC-GROUPS))	 
      ;; Process each descriptor group
      (SETQ LAST-GROUP-P (NULL (CDR DESC-GROUPS)))
      (DOLIST (DESC (CONSTRAINT-FRAME-SUBSTITUTION (CAR DESC-GROUPS)))

	REPARSE					;Yes, this is a GO tag!

	;; For each descriptor, parse it
	(SETQ DESC (CONSTRAINT-FRAME-SUBSTITUTION DESC))
	(LET ((NAM (CAR DESC))
	      (WOS) (AENTRY) (MACRO-P))
	  (OR (SETQ WOS (CDR (SETQ AENTRY (ASSQ NAM INTERNAL-ORDERING))))
	      (FERROR "~S is unspecified in the ordering" NAM))
	  (COND ((TYPEP WOS 'SHEET)
		 ;; A window -- parse the constraint and make the node
		 (MULTIPLE-VALUE-BIND (CONSTR MIN MAX TEM)
		     (PARSE-CONSTRAINT (CDR DESC) WOS LAST-GROUP-P EVEN-P)
		   (SETQ EVEN-P TEM)
		   (PUSH (MAKE-CONSTRAINT-NODE CONSTRAINT-NAME (GET-PNAME NAM)
					       CONSTRAINT-TYPE ':WINDOW
					       CONSTRAINT-CONSTRAINT CONSTR
					       CONSTRAINT-DATA WOS
					       CONSTRAINT-MIN MIN
					       CONSTRAINT-MAX MAX)
			 INTERNAL-DESC-GROUP)))
		((NOT (SYMBOLP WOS))
		 (FERROR "~S is not a valid special name at this point" NAM))
		((MEMQ (SECOND DESC) '(:HORIZONTAL :VERTICAL))
		 (AND (EQ (SECOND DESC) STACKING)
		      (FERROR "Current stacking (~S) same as new stacking" STACKING))
		 (MULTIPLE-VALUE-BIND (CONSTR MIN MAX TEM)
		     (PARSE-CONSTRAINT (THIRD DESC) NIL LAST-GROUP-P EVEN-P)
		   (SETQ EVEN-P TEM)
		   (PUSH (MAKE-CONSTRAINT-NODE
			   CONSTRAINT-NAME (GET-PNAME NAM)
			   CONSTRAINT-TYPE ':STACKING
			   CONSTRAINT-CONSTRAINT CONSTR
			   CONSTRAINT-DATA
			    (CONSTRAINT-FRAME-PARSE-CONSTRAINTS
			      SELF (CDDDR DESC) (SECOND DESC))
			   CONSTRAINT-MIN MIN
			   CONSTRAINT-MAX MAX)
			 INTERNAL-DESC-GROUP)))
		((EQ (SECOND DESC) ':IF)
		 (FERROR "Conditionals not currently supported"))
		((EQ (SECOND DESC) ':BLANK)
		 (MULTIPLE-VALUE-BIND (CONSTR MIN MAX TEM)
		     (PARSE-CONSTRAINT (CDDDR DESC) NIL LAST-GROUP-P EVEN-P)
		   (SETQ EVEN-P TEM)
		   (PUSH (MAKE-CONSTRAINT-NODE
			   CONSTRAINT-NAME (GET-PNAME NAM)
			   CONSTRAINT-TYPE ':BLANK
			   CONSTRAINT-CONSTRAINT CONSTR
			   CONSTRAINT-DATA (SELECTQ (THIRD DESC)
					     (:WHITE #'CONSTRAINT-FRAME-WHITE-BLANKING)
					     (:BLACK #'CONSTRAINT-FRAME-BLACK-BLANKING)
					     (OTHERWISE (THIRD DESC)))
			   CONSTRAINT-MIN MIN
			   CONSTRAINT-MAX MAX)
			 INTERNAL-DESC-GROUP)))
		((SETQ MACRO-P (GET (SECOND DESC) 'CONSTRAINT-MACRO))
		 ;; A macro: expand it and use its expansion in place of the current
		 ;; description
		 (SETQ DESC (CONS (CAR DESC) (FUNCALL MACRO-P DESC STACKING)))
		 (GO REPARSE))
		(T (FERROR "~S is unknown special keyword, perhaps ~S is missing from TV:PANES" (SECOND DESC) (FIRST DESC))))
	  (RPLACD AENTRY (CAR INTERNAL-DESC-GROUP))))
      (PUSH (NREVERSE INTERNAL-DESC-GROUP) INTERNAL-DESCS))
    (DOLIST (ORD INTERNAL-ORDERING)
      (AND (OR (TYPEP (CDR ORD) 'SHEET) (EQ (CAR ORD) (CDR ORD)))
	   (FERROR "~S was specified in ordering, but not specified in any descriptor"
		   (CAR ORD))))
    (CONS INTERNAL-ORDERING (NREVERSE INTERNAL-DESCS))))

(DEFUN-IN-FLAVOR (PARSE-CONSTRAINT BASIC-CONSTRAINT-FRAME) (CONSTR WINDOW LG-P EVEN-P
						       &AUX (MIN -1) (MAX 1_15.))
  "Verify correctness of the specified constraint.  Returns the constraint part
of the constraint, as well as the limits if specified."
  (COND ((EQ (FIRST CONSTR) ':LIMIT)
	 (LET ((LIMITS (SECOND CONSTR))
	       (ROUND) (OFFSET))
	   (COND ((> (LENGTH LIMITS) 2)
		  (OR (SETQ WINDOW (OR (PARSE-CONSTRAINT-GET-PANE (FOURTH LIMITS))
				       WINDOW))
		      (FERROR "Illegal format :LIMIT (no window specified)"))
		  (SELECTQ (THIRD LIMITS)
		    (:CHARACTERS (SETQ ROUND (SHEET-CHAR-WIDTH WINDOW)
				       OFFSET (+ (SHEET-LEFT-MARGIN-SIZE WINDOW)
						 (SHEET-RIGHT-MARGIN-SIZE WINDOW))))
		    (:LINES (SETQ ROUND (SHEET-LINE-HEIGHT WINDOW)
				  OFFSET (+ (SHEET-TOP-MARGIN-SIZE WINDOW)
					    (SHEET-BOTTOM-MARGIN-SIZE WINDOW))))
		    (OTHERWISE (FERROR "~S is illegal rounding specification"
				       (THIRD LIMITS))))))
	   (SETQ MIN (OR (FIRST LIMITS) MIN)
		 MAX (OR (SECOND LIMITS) MAX))
	   (SETQ MIN (IF ROUND (+ (* MIN ROUND) OFFSET) MIN)
		 MAX (IF ROUND (+ (* MAX ROUND) OFFSET) MAX)))
	 (SETQ CONSTR (CDDR CONSTR))))
  (COND ((OR (IF (NUMBERP (FIRST CONSTR))
		 (OR (NULL EVEN-P) (EQ EVEN-P ':NO)
		     (FERROR "Cannot mix :EVEN constraints and other constraints"))
		 NIL)
	     (COND ((EQ (FIRST CONSTR) ':EVEN)
		    (OR LG-P (FERROR ":EVEN not in last descriptor group"))
		    (OR (NULL EVEN-P) (EQ EVEN-P ':YES)
			(FERROR "Cannot mix :EVEN constraints and other constraints"))
		    (SETQ EVEN-P ':YES)
		    T)))
	 (COND ((> (LENGTH CONSTR) 1)
		(LET ((W (PARSE-CONSTRAINT-GET-PANE (THIRD CONSTR))))
		  (IF W
		      (SETQ WINDOW W
			    CONSTR (LIST (FIRST CONSTR) (SECOND CONSTR) W))
		      (OR WINDOW
			  (FERROR 
			    "Illegal format constraint -- no window specified for ~S in ~S"
			    (SECOND CONSTR) CONSTR))))
		(OR (MEMQ (SECOND CONSTR) '(:LINES :CHARACTERS))
		    (FERROR "Illegal rounding specifier ~S" (SECOND CONSTR)))
		(AND (FIXP (FIRST CONSTR))
		     (SETQ CONSTR (LIST (* (FIRST CONSTR)
					   (SELECTQ (SECOND CONSTR)
					     (:LINES (SHEET-LINE-HEIGHT WINDOW))
					     (:CHARACTERS (SHEET-CHAR-WIDTH WINDOW))))
					(SECOND CONSTR)
					WINDOW))))))
	((NOT (OR (NULL EVEN-P) (EQ EVEN-P ':NO)))
	 (FERROR "Cannot mix :EVEN constraints and other constraints"))
	((MEMQ (FIRST CONSTR) '(:ASK :FUNCALL :EVAL :FIXED)))
	((EQ (FIRST CONSTR) ':ASK-WINDOW)
	 (LET ((W (SECOND CONSTR)))
	   (SETQ W (IF (EQ W 'SELF) SELF (PARSE-CONSTRAINT-GET-PANE W)))
	   (SETF (SECOND (SETQ CONSTR (COPYLIST CONSTR))) W))))
  (VALUES CONSTR MIN MAX (OR EVEN-P ':NO)))

(DEFUN-IN-FLAVOR (PARSE-CONSTRAINT-GET-PANE BASIC-CONSTRAINT-FRAME) (PANE-NAME)
  (AND PANE-NAME
       (OR (CDR (ASSQ PANE-NAME INTERNAL-PANES))
	   (FERROR "Unknown pane name ~S" PANE-NAME))))

(DEFUN CONSTRAINT-FRAME-DO-CONSTRAINTS (FRAME CONSTRS
					&OPTIONAL (W (SHEET-INSIDE-WIDTH FRAME))
					          (H (SHEET-INSIDE-HEIGHT FRAME)))
  (CATCH ':VERTICAL
    (CATCH ':HORIZONTAL
      (PROGN
	(CONSTRAINT-FRAME-DO-SIZES W H CONSTRS)
	(SEND FRAME ':SET-EXPOSED-PANES
	      (CONSTRAINT-FRAME-DO-POSITIONS CONSTRS CONSTRAINT-FRAME-DEFAULT-STACKING
					     (SHEET-LEFT-MARGIN-SIZE FRAME)
					     (SHEET-TOP-MARGIN-SIZE FRAME)))
	T))))

(DEFUN CONSTRAINT-FRAME-DO-SIZES (WIDTH HEIGHT CONSTRS
				   &OPTIONAL (STACKING CONSTRAINT-FRAME-DEFAULT-STACKING))
  "Given that the current width and height of the frame, calculate new values of position
and size for each node.  Constraints are assumed parsed and valid."
;;; **** Does not know about min's or max's yet!
  (LET ((DESC-GROUPS (CDR CONSTRS)))
    (DOLIST (DESC-GROUP DESC-GROUPS)
      ;; For each group, assign widths and heights
      (LET (WIDTH-USED HEIGHT-USED)
	(COND ((NOT (CATCH STACKING
		      (PROGN
			(MULTIPLE-VALUE (WIDTH-USED HEIGHT-USED)
			  (CONSTRAINT-FRAME-DO-SIZES-INTERNAL DESC-GROUP
							      WIDTH HEIGHT WIDTH HEIGHT
							      STACKING))
			T)))
	       ;; Some constraint couldn't be satisfied.  Try only allowing each constraint
	       ;; to take 1/Nth of the area, where N is the total number of constraints
	       (MULTIPLE-VALUE (WIDTH-USED HEIGHT-USED)
		 (CONSTRAINT-FRAME-DO-SIZES-INTERNAL DESC-GROUP WIDTH HEIGHT
	           (IF (EQ STACKING ':HORIZONTAL) (// WIDTH (LENGTH DESC-GROUP)) WIDTH)
		   (IF (EQ STACKING ':VERTICAL) (// HEIGHT (LENGTH DESC-GROUP)) HEIGHT)
		   STACKING))))
	(SETQ WIDTH (- WIDTH WIDTH-USED)
	      HEIGHT (- HEIGHT HEIGHT-USED))
	(AND (OR (< WIDTH 0) (< HEIGHT 0))
	     (THROW STACKING NIL))))))

(DEFUN CONSTRAINT-FRAME-DO-SIZES-INTERNAL (DESC-GROUP WIDTH HEIGHT AV-WIDTH AV-HEIGHT STACKING
					   &AUX (WIDTH-USED 0) (HEIGHT-USED 0) W H)
  (DOLIST (NODE DESC-GROUP)
    ;; Amount of room available is the smaller of the total amount of room, or the maximum
    ;; allowed by the caller
    (SETQ AV-WIDTH (MIN (- WIDTH WIDTH-USED) AV-WIDTH)
	  AV-HEIGHT (MIN (- HEIGHT HEIGHT-USED) AV-HEIGHT))
    (SELECTQ (CONSTRAINT-TYPE NODE)
      ;; Dispatch on node type
      ((:WINDOW :BLANK)
       ;; A real window, easy -- compute the new values, stick 'em in, and loop
       ;; Blanks get handled in same way
       (MULTIPLE-VALUE (W H)
	 (CONSTRAINT-FRAME-DO-A-CONSTRAINT NODE AV-WIDTH AV-HEIGHT WIDTH HEIGHT
					   STACKING DESC-GROUP)))
      (:STACKING
       ;; A special thing, some sort of descent needed.  First fill in size
       (MULTIPLE-VALUE (W H)
	 (CONSTRAINT-FRAME-DO-A-CONSTRAINT NODE AV-WIDTH AV-HEIGHT WIDTH HEIGHT
					   STACKING DESC-GROUP))
       ;; Then recurse with new values
       (CONSTRAINT-FRAME-DO-SIZES W H (CONSTRAINT-DATA NODE)
				  (SELECTQ STACKING
				    (:VERTICAL ':HORIZONTAL)
				    (:HORIZONTAL ':VERTICAL))))
      (:IF (FERROR ":IF not yet supported"))
      (OTHERWISE (FERROR "Unknown node type ~S" (CONSTRAINT-TYPE NODE))))
    (SELECTQ STACKING
      (:VERTICAL
       (SETQ HEIGHT-USED (+ HEIGHT-USED H))
       (AND (> HEIGHT-USED HEIGHT)
	    ;; Ran out of room, try alternate algorithm
	    (THROW ':VERTICAL NIL)))
      (:HORIZONTAL
       (SETQ WIDTH-USED (+ WIDTH-USED W))
       (AND (> WIDTH-USED WIDTH)
	    (THROW ':HORIZONTAL NIL)))))
  (VALUES WIDTH-USED HEIGHT-USED))


(DEFVAR **CONSTRAINT-NODE**)
(DEFVAR **CONSTRAINT-REMAINING-WIDTH**)
(DEFVAR **CONSTRAINT-REMAINING-HEIGHT**)
(DEFVAR **CONSTRAINT-TOTAL-WIDTH**)
(DEFVAR **CONSTRAINT-TOTAL-HEIGHT**)
(DEFVAR **CONSTRAINT-CURRENT-STACKING**)

(DEFUN CONSTRAINT-FRAME-DO-A-CONSTRAINT (NODE AV-W AV-H W H STACKING DG &AUX AMOUNT CON)
  "Processes one constraint, setting the proposed width and height in the node to the
ones specified by the constraint."
  (SETQ CON (CONSTRAINT-CONSTRAINT NODE))
  (COND
    ;; Dispatch on type of constraint
    ((EQ (FIRST CON) ':ASK-WINDOW)
     (SETQ AMOUNT (CONSTRAINT-ROUND
		    (LEXPR-FUNCALL (SECOND CON) (THIRD CON) AV-W AV-H W H STACKING
				   (CDDDR CON))
		    CON NODE)))
    ((EQ (FIRST CON) ':ASK)
     (SETQ AMOUNT (CONSTRAINT-ROUND
		    (LEXPR-FUNCALL (CONSTRAINT-DATA NODE)
				   (SECOND CON) AV-W AV-H W H STACKING
				   (CDDR CON))
		    CON NODE)))
    ((EQ (FIRST CON) ':FUNCALL)
     (SETQ AMOUNT (CONSTRAINT-ROUND
		    (LEXPR-FUNCALL (SECOND CON) NODE AV-W AV-H W H STACKING
				   (CDDR CON))
		    CON NODE)))
    ((EQ (FIRST CON) ':EVAL)
     (LET ((**CONSTRAINT-NODE** NODE)
	   (**CONSTRAINT-REMAINING-WIDTH** AV-W)
	   (**CONSTRAINT-REMAINING-HEIGHT** AV-H)
	   (**CONSTRAINT-TOTAL-WIDTH** W)
	   (**CONSTRAINT-TOTAL-HEIGHT** H)
	   (**CONSTRAINT-CURRENT-STACKING** STACKING))
       (SETQ AMOUNT (EVAL (SECOND CON)))))
    ((FIXP (FIRST CON))
     (SETQ AMOUNT (CONSTRAINT-ROUND (FIRST CON) CON NODE)))
    ((NUMBERP (FIRST CON))			;Float or ratio
     (SETQ AMOUNT (CONSTRAINT-ROUND (* (FIRST CON) (SELECTQ STACKING
 						     (:VERTICAL H)
						     (:HORIZONTAL W)))
				    CON NODE)))
    ((EQ (FIRST CON) ':EVEN)
     (SETQ AMOUNT (CONSTRAINT-ROUND (// (SELECTQ STACKING
					  (:HORIZONTAL AV-W)
					  (:VERTICAL AV-H))
					(- (LENGTH DG)
					   (DO ((I 0 (1+ I))
						(L DG (CDR L)))
					       ((NULL L) (FERROR "Node not a node"))
					     (AND (EQ (CAR L) NODE) (RETURN I)))))
				    CON NODE)))
    ((EQ (FIRST CON) ':FIXED)
     (SELECTQ STACKING
       (:VERTICAL (SETQ AMOUNT (SHEET-HEIGHT (CONSTRAINT-DATA NODE))
			W (SHEET-WIDTH (CONSTRAINT-DATA NODE))))
       (:HORIZONTAL (SETQ H (SHEET-HEIGHT (CONSTRAINT-DATA NODE))
			  AMOUNT (SHEET-WIDTH (CONSTRAINT-DATA NODE))))))
    (T (FERROR "Unknown constraint type ~S" CON)))
  (SELECTQ STACKING
    (:VERTICAL (SETF (CONSTRAINT-PW NODE) W)
	       (SETF (CONSTRAINT-PH NODE) (SETQ H AMOUNT)))
    (:HORIZONTAL (SETF (CONSTRAINT-PW NODE) (SETQ W AMOUNT))
		 (SETF (CONSTRAINT-PH NODE) H))
    (OTHERWISE (FERROR "Illegal value for stacking ~S" STACKING)))
  (VALUES W H))

(DEFUN CONSTRAINT-ROUND (SIZE CON NODE &AUX TEM (WINDOW (CONSTRAINT-DATA NODE)))
  "Given a proposed size, a constraint, and the node, don't round, or round to lines
or characters.  Also enforces limits."
  (SETQ SIZE (FIX SIZE))
  (MIN (CONSTRAINT-MAX NODE)
       (MAX (CONSTRAINT-MIN NODE)
	    (COND ((OR (NUMBERP (FIRST CON)) (EQ (FIRST CON) ':EVEN))
		   (SETQ WINDOW (OR (THIRD CON) WINDOW))
		   (SELECTQ (SECOND CON)
		     (:LINES
		      (+ (SHEET-TOP-MARGIN-SIZE WINDOW) (SHEET-BOTTOM-MARGIN-SIZE WINDOW)
			 (* (SETQ TEM (SHEET-LINE-HEIGHT WINDOW))
			    (// SIZE TEM))))
		     (:CHARACTERS
		      (+ (SHEET-LEFT-MARGIN-SIZE WINDOW) (SHEET-RIGHT-MARGIN-SIZE WINDOW)
			 (* (SETQ TEM (SHEET-CHAR-WIDTH WINDOW))
			    (// SIZE TEM))))
		     (T SIZE)))
		  (T SIZE)))))

(DEFUN CONSTRAINT-FRAME-DO-POSITIONS (CONSTRS
				       &OPTIONAL (STACKING CONSTRAINT-FRAME-DEFAULT-STACKING)
				                 (X 0) (Y 0)
				       &AUX NODE PANES)
  "Given that proposed size has been set up, set up the proposed positions.  Returns a list 
of all involved panes."
  (DOLIST (AENTRY (FIRST CONSTRS))
    ;; Loop over windows in order, and assign positions
    (SETQ NODE (CDR AENTRY))
    (SETF (CONSTRAINT-PX NODE) X)
    (SETF (CONSTRAINT-PY NODE) Y)
    (SELECTQ (CONSTRAINT-TYPE NODE)
      (:WINDOW (PUSH (CONSTRAINT-DATA NODE) PANES))
      (:STACKING (SETQ PANES
		       (NCONC (CONSTRAINT-FRAME-DO-POSITIONS (CONSTRAINT-DATA NODE)
							     (SELECTQ STACKING
							       (:VERTICAL ':HORIZONTAL)
							       (:HORIZONTAL ':VERTICAL))
							     X Y)
			      PANES)))
      (:IF (FERROR ":IF not yet supported"))
      (:BLANK)
      (OTHERWISE (FERROR "Unknown node type ~S" (CONSTRAINT-TYPE NODE))))
    (SELECTQ STACKING
      (:VERTICAL (SETQ Y (+ Y (CONSTRAINT-PH NODE))))
      (:HORIZONTAL (SETQ X (+ X (CONSTRAINT-PW NODE))))))
  PANES)

(DEFVAR BLANKING-ARRAY (MAKE-ARRAY '(32. 1) ':TYPE 'ART-1B ':INITIAL-VALUE 1))

;;
;; fix blanking on constraint frames - DDyer/Weaver
;;
(DEFUN CONSTRAINT-FRAME-WHITE-BLANKING (IGNORE X Y W H TO-SHEET)

  ;; Note, this is a little strange.  Originally this was a BITBLT, which is completely
  ;; correct, but doesn't permit color screens to take advantage of FILL mode.
  ;; SHEET-DRAW-RECTANGLE does use fill mode, but the sheet to use is whatever
  ;; was prepared at top level rather than self.  - DDyer
  ;; 
  ;; Dyer had some Inside/Outside coord brain damage here, that's what all this
  ;; "(- X (sheet-inside.." stuff is about.  It seems to me that there's some
  ;; factoring being done wrong.  - Weaver

  (COND ((INSTANCEP TO-SHEET)
	 (SEND TO-SHEET ':DRAW-RECTANGLE W H
	       (- X (SHEET-INSIDE-LEFT TO-SHEET))
	       (- Y (SHEET-INSIDE-TOP TO-SHEET))
	       :ERASE))
	((AND CURRENTLY-PREPARED-SHEET
	      (EQ TO-SHEET (SHEET-SCREEN-ARRAY CURRENTLY-PREPARED-SHEET)))
	 (SHEET-DRAW-RECTANGLE W H X Y (SHEET-ERASE-ALUF CURRENTLY-PREPARED-SHEET)
			       CURRENTLY-PREPARED-SHEET))
	(T (ERROR "Sheet not prepared"))))

(DEFUN CONSTRAINT-FRAME-BLACK-BLANKING (IGNORE X Y W H TO-SHEET)
  (COND ((INSTANCEP TO-SHEET)
	 (SEND TO-SHEET ':DRAW-RECTANGLE W H 
	       (- X (SHEET-INSIDE-LEFT TO-SHEET))
	       (- Y (SHEET-INSIDE-TOP TO-SHEET))))
	((AND CURRENTLY-PREPARED-SHEET
	      (EQ TO-SHEET (SHEET-SCREEN-ARRAY CURRENTLY-PREPARED-SHEET)))
	 (SHEET-DRAW-RECTANGLE W H X Y (SHEET-CHAR-ALUF CURRENTLY-PREPARED-SHEET)
			       CURRENTLY-PREPARED-SHEET))
	(T (ERROR "Sheet not prepared"))))

(DEFUN CONSTRAINT-FRAME-STIPPLE-BLANKING (IGNORE X Y W H TO-SHEET GRAY-ARRAY)
  (MULTIPLE-VALUE-BIND (GA-WIDTH GA-HEIGHT)
      (DECODE-RASTER-ARRAY GRAY-ARRAY)
    (COND ((INSTANCEP TO-SHEET)
	   (SEND TO-SHEET :DRAW-1-BIT-RASTER W H
		 GRAY-ARRAY (\ X GA-WIDTH) (\ Y GA-HEIGHT)
		 (- X (SHEET-INSIDE-LEFT TO-SHEET)) (- Y (SHEET-INSIDE-TOP TO-SHEET))))
	  ;; Assume if it's not an instance it's an array of the currently prepared sheet.
	  (T
	   (SHEET-DRAW-1-BIT-RASTER W H
				    GRAY-ARRAY (\ X GA-WIDTH) (\ Y GA-HEIGHT)
				    TO-SHEET X Y
				    (SHEET-CHAR-ALUF CURRENTLY-PREPARED-SHEET)
				    (SHEET-ERASE-ALUF CURRENTLY-PREPARED-SHEET)
				    CURRENTLY-PREPARED-SHEET)))))

(comment ; The old versions, for comparison...  -Weaver

(DEFUN-IN-FLAVOR (CONSTRAINT-FRAME-WHITE-BLANKING SHEET) (IGNORE X Y W H ARRAY)
  (BITBLT ERASE-ALUF W H BLANKING-ARRAY 0 0 ARRAY X Y))

(DEFUN-IN-FLAVOR (CONSTRAINT-FRAME-BLACK-BLANKING SHEET) (IGNORE X Y W H ARRAY)
  (BITBLT CHAR-ALUF W H BLANKING-ARRAY 0 0 ARRAY X Y))

(DEFUN-IN-FLAVOR (CONSTRAINT-FRAME-STIPPLE-BLANKING SHEET) (IGNORE X Y W H ARRAY GRAY-ARRAY)
  (MULTIPLE-VALUE-BIND (GA-WIDTH GA-HEIGHT)
      (DECODE-RASTER-ARRAY GRAY-ARRAY)
    (BITBLT (DPB (LDB (BYTE 2 2) CHAR-ALUF) (BYTE 2 0) CHAR-ALUF)	;depend on source only
	    W H
	    GRAY-ARRAY (\ X GA-WIDTH)
		       (\ Y GA-HEIGHT)
	    ARRAY X Y)))
);comment

;;
;; This implements an extension to the protocol that allows instances
;; to be the stipple pattern, in which case it is sent an :draw-blank-rectangle
;; message.  This lets a color alu object be the blanker.
;;
(DEFUN-IN-FLAVOR (CONSTRAINT-FRAME-DRAW-A-BLANK BASIC-CONSTRAINT-FRAME)
		 (BLANK-TYPE NODE X Y W H SCR)
  (COND ((FUNCTIONP BLANK-TYPE)
	 ;; An explicit drawing function
	 (FUNCALL BLANK-TYPE NODE X Y W H SCR))
	((TYPEP BLANK-TYPE ':INSTANCE)
	 (SEND BLANK-TYPE ':DRAW-BLANK-RECTANGLE W H X Y X Y SELF))
	((LISTP BLANK-TYPE)
	 (LEXPR-FUNCALL (CAR BLANK-TYPE) NODE X Y W H SCR (CDR BLANK-TYPE)))
	((ARRAYP BLANK-TYPE)
	 ;; Stipple array -- draw in standard way
	 (CONSTRAINT-FRAME-STIPPLE-BLANKING NODE X Y W H SCR BLANK-TYPE))
	(T (FERROR "~S is an unknown type of blanking" BLANK-TYPE))))


;;; This converts from :CONFIGURATIONS format to :CONSTRAINTS format.

(DEFFLAVOR CC-THING (NAME CONSTRAINT) ()
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES
  (:SETTABLE-INSTANCE-VARIABLES CONSTRAINT))

(DEFFLAVOR CC-PANE () (CC-THING))

(DEFFLAVOR CC-STACK (ORDER CONSTRAINEES) (CC-THING)
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES
  (:SETTABLE-INSTANCE-VARIABLES CONSTRAINEES))

(DEFFLAVOR CC-ROW () (CC-STACK))

(DEFFLAVOR CC-COLUMN () (CC-STACK))

(DEFFLAVOR CC-BLANK (PATTERN) (CC-THING)
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES)

(DEFUN FIND-THING-NAMED (NAME THINGS)
  (DOLIST (THING THINGS)
    (WHEN (EQ NAME (SEND THING ':NAME))
      (RETURN THING))))

;;; Take a list of configurations, e.g. the value of the :CONFIGURATIONS
;;; init option, and return the corresponding value for the :CONSTRAINTS
;;; init option.
(DEFUN CONVERT-CONFIGURATIONS (CONFIGURATIONS PANES)
  (LOOP FOR CONFIG IN CONFIGURATIONS
	DO (WHEN (OR (ATOM CONFIG) (NOT (= (LENGTH CONFIG) 3)))
	     (FERROR "The configuration ~S is not well-formed." CONFIG))
	COLLECT
	(LET ((NAME (FIRST CONFIG))
	      (ARG1 (SECOND CONFIG))
	      (ARG2 (THIRD CONFIG)))
	  (UNLESS (SYMBOLP NAME) (FERROR "The configuration name ~S is not a symbol."))
	  (COND ((AND (EQ (CAR ARG1) ':LAYOUT)
		      (EQ (CAR ARG2) ':SIZES))
		 (CONVERT-CONFIGURATION NAME (CDR ARG1) (CDR ARG2) PANES))
		((AND (EQ (CAR ARG2) ':LAYOUT)
		      (EQ (CAR ARG1) ':SIZES))
		 (CONVERT-CONFIGURATION NAME (CDR ARG2) (CDR ARG1) PANES))
		(T
		 (FERROR "LAYOUT and SIZES are not where they should be in ~S" CONFIG))))))

(DEFUN CONVERT-CONFIGURATION (NAME LAYOUT SIZES PANES)
  ;; Convert the LAYOUT items into a list of things.
  (LET ((THINGS (LOOP FOR ITEM IN LAYOUT COLLECT
		      (SELECTQ (SECOND ITEM)
			(:COLUMN
			 (MAKE-INSTANCE 'CC-COLUMN :NAME (FIRST ITEM) :ORDER (REST2 ITEM)))
			(:ROW
			 (MAKE-INSTANCE 'CC-ROW :NAME (FIRST ITEM) :ORDER (REST2 ITEM)))
			(:FILL
			 (MAKE-INSTANCE 'CC-BLANK :NAME (FIRST ITEM) :PATTERN (THIRD ITEM)))
			(OTHERWISE (FERROR "~S is not a meaningful layout item" ITEM))))))
    (DOLIST (PANE PANES)
      (PUSH (MAKE-INSTANCE 'CC-PANE :NAME (CAR PANE)) THINGS))
    ;; Do some error checking.
    (CC-ERROR-CHECK THINGS)
    ;; Use data in :SIZES to set the CONSTRAINTS and the CONSTRAINEES in the things.
    (DOLIST (SIZE-SPEC SIZES)
      (LET ((SERIAL NIL)
	    (PARALLEL NIL))
	(DOLIST (ITEM (REST1 SIZE-SPEC))
	  (COND ((LISTP ITEM)
		 ;; This item sets the constraint on some thing.
		 (LET ((THING (FIND-THING-NAMED (FIRST ITEM) THINGS)))
		   (UNLESS THING
		     (FERROR "The name ~S appears in size-spec ~S but not~@
                              in the LAYOUTS description." (FIRST ITEM) ITEM))
		   (SEND THING :SET-CONSTRAINT (REST1 ITEM))
		   (PUSH (FIRST ITEM) PARALLEL)))
		((EQ ITEM ':THEN)
		 (PUSH (NREVERSE PARALLEL) SERIAL)
		 (SETQ PARALLEL NIL))
		(T (FERROR "Unknown item in size-spec: ~S" ITEM))))
	(LET ((STACK (FIND-THING-NAMED (FIRST SIZE-SPEC) THINGS)))
	  (UNLESS (AND STACK (TYPEP STACK 'CC-STACK))
	    (FERROR "~S is not a valid stack spec" SIZE-SPEC))
	  (SEND STACK :SET-CONSTRAINEES
		(NRECONC SERIAL (AND PARALLEL (LIST (NREVERSE PARALLEL))))))))
    ;; Convert the things to :CONSTRAINTS notation.
    (LET ((CONFIG-THING (FIND-THING-NAMED NAME THINGS)))
      (UNLESS CONFIG-THING (ERROR "The configuration ~S wasn't listed in the layout." NAME))
      (SEND CONFIG-THING :SET-CONSTRAINT NIL))
    (LET ((CONFIG (CONVERT-CONFIGURATION-1 NAME THINGS)))
      (LET ((DIR (SECOND CONFIG)) (CON (THIRD CONFIG)) (STUFF (REST3 CONFIG)))
	(WHEN CON
	  (FERROR "The top level item, ~S, must not be a stack" NAME))
	(SELECTQ DIR
	  (:VERTICAL `(,NAME . ,STUFF))
	  (:HORIZONTAL
	   (SETF (FIRST CONFIG) '.TOP.LEVEL.HORIZONTAL.)
	   (SETF (THIRD CONFIG) '(:EVEN))
	   `(,NAME . ((.TOP.LEVEL.HORIZONTAL.)
		      . ((,CONFIG)))))
	  (OTHERWISE (FERROR "~S is not a valid stacking direction, in ~S" DIR CONFIG)))))))

(DEFUN CC-ERROR-CHECK (THINGS)
  ;; Check for duplicate thing names.
  (LOOP FOR (THING . REST-OF-THINGS) ON THINGS
	FOR NAME = (SEND THING :NAME)
	WHEN (FIND-THING-NAMED NAME REST-OF-THINGS)
	DO (FERROR "The name ~S appears twice in the :LAYOUT" NAME))
  ;; Make sure that each stack is defined in terms of other things; no dependency
  ;; on unknown things, or circular dependencies.
  (LET ((UNRESOLVED-STACKS (LOOP FOR THING IN THINGS
				 WHEN (TYPEP THING 'CC-STACK) COLLECT THING))
	(RESOLVED-STACKS NIL))
    ;; All stacks start out being unresolved; the goal is to get them all
    ;; resolved (they get moved from the one list to the other, one at a time).
    (LOOP UNTIL (NULL UNRESOLVED-STACKS) DO
	  (LET ((THIS-STACK
		  ;; Loop over all unresolved stacks, looking for one to resolve; return
		  ;; it, or return NIL if no stacks are resolvable.
		  (DOLIST (STACK UNRESOLVED-STACKS)
		    ;; A stack can be resolved if every one of its constrainees is
		    ;; a resolved stack or a pane or a blank.
		    (WHEN (LOOP FOR NAME IN (SEND STACK :ORDER)
				ALWAYS (OR (FIND-THING-NAMED NAME RESOLVED-STACKS)
					   (NOT (TYPEP (FIND-THING-NAMED NAME THINGS)
						       'CC-STACK))))
		      (RETURN STACK)))))
	    (WHEN (NULL THIS-STACK)
	      (FERROR "One of these stacks has an unresolvable dependency: ~S"
		     (LOOP FOR STACK IN UNRESOLVED-STACKS COLLECT (SEND STACK :NAME))))
	    (PUSH THIS-STACK RESOLVED-STACKS)
	    (SETQ UNRESOLVED-STACKS (DELQ THIS-STACK UNRESOLVED-STACKS))))))

(DEFUN CONVERT-CONFIGURATION-1 (NAME THINGS)
  (LET ((THING (FIND-THING-NAMED NAME THINGS)))
    (IF THING
	(SEND THING :CONVERT-CONFIGURATION THINGS)
	(FERROR "Could not find pane, stack, or fill named ~S" NAME))))

(DEFMETHOD (:CONVERT-CONFIGURATION CC-PANE) (IGNORE)
  (CONS NAME CONSTRAINT))

(DEFMETHOD (:CONVERT-CONFIGURATION CC-BLANK) (IGNORE)
  `(,NAME :BLANK ,PATTERN . ,CONSTRAINT))

(DEFMETHOD (:CONVERT-CONFIGURATION CC-STACK) (THINGS)
  `(,NAME
    ,(SEND SELF :STACK-TYPE)
    ,CONSTRAINT
    ,ORDER
    . ,(LOOP FOR PARALLEL IN CONSTRAINEES
	     COLLECT (LOOP FOR CONSTRAINEE IN PARALLEL
			   COLLECT (CONVERT-CONFIGURATION-1 CONSTRAINEE THINGS)))))

(DEFMETHOD (:STACK-TYPE CC-ROW) ()
  ':HORIZONTAL)

(DEFMETHOD (:STACK-TYPE CC-COLUMN) ()
  ':VERTICAL)

(COMPILE-FLAVOR-METHODS CC-PANE CC-BLANK CC-ROW CC-COLUMN)

;;; back-convert-constraints, for uncompiling existing code
(DEFVAR *BC-LAYOUTS*)
(DEFVAR *BC-SIZES*)
(DEFVAR *BC-SIZE-LIST*)
(DEFVAR *BC-PANES*)

(DEFUN BACK-CONVERT-CONSTRAINTS (CONSTRAINTS)
  (DECLARE (VALUES CONFIGURATIONS PANES))
  (LET ((*BC-PANES* ()))
    (VALUES
      (LOOP FOR (NAME . CONF-DESC) IN CONSTRAINTS
	    COLLECT (LET ((*BC-LAYOUTS* ())
			  (*BC-SIZE-LIST* ()))
		      (BC-CONFIGURATION-DESCR NAME
					      CONSTRAINT-FRAME-DEFAULT-STACKING
					      CONF-DESC)
		      `(,NAME
			(:LAYOUT ,@(NREVERSE *BC-LAYOUTS*))
			(:SIZES ,@(NREVERSE *BC-SIZE-LIST*)))))
      *BC-PANES*)))

(DEFUN BC-CONFIGURATION-DESCR (NAME DIRECTION DESC)
  (DESTRUCTURING-BIND (ORDERING . SERIAL-DESC-GROUP-LIST) DESC
    (PUSH `(,NAME ,(SELECTQ DIRECTION
		     (:VERTICAL ':COLUMN)
		     (:HORIZONTAL ':ROW)
		     (OTHERWISE (FERROR "Unrecognized direction ~S" DIRECTION)))
	    ,@ORDERING)
	  *BC-LAYOUTS*)
    (PUSH (CONS NAME (LET ((*BC-SIZES* ()))
		       (BC-PARALLEL-DESC-GROUP-LIST (FIRST SERIAL-DESC-GROUP-LIST))
		       (LOOP FOR X IN (REST1 SERIAL-DESC-GROUP-LIST)
			     DO (PUSH ':THEN *BC-SIZES*)
			     DO (BC-PARALLEL-DESC-GROUP-LIST X))
		       (NREVERSE *BC-SIZES*)))
	  *BC-SIZE-LIST*)))

(DEFUN BC-PARALLEL-DESC-GROUP-LIST (LIST)
  (LOOP FOR (NAME KEY . STUFF) IN LIST
	DO (SELECTQ KEY
	     (:BLANK
	      (BC-BLANK-DESC NAME KEY STUFF))
	     ((:VERTICAL :HORIZONTAL)
	      (BC-STACK-DESC NAME KEY STUFF))
	     (OTHERWISE
	      (BC-PANE-DESC NAME (CONS KEY STUFF))))))

(DEFUN BC-BLANK-DESC (NAME KEY STUFF)
  (IGNORE KEY)
  (DESTRUCTURING-BIND (PATTERN . CONSTRAINT) STUFF
    (PUSH `(,NAME :FILL ,PATTERN) *BC-LAYOUTS*)
    (PUSH `(,NAME ,@CONSTRAINT) *BC-SIZES*)))

(DEFUN BC-STACK-DESC (NAME KEY STUFF)
  (DESTRUCTURING-BIND (CONSTRAINT . DESCR) STUFF
    (PUSH `(,NAME ,@CONSTRAINT) *BC-SIZES*)
    (BC-CONFIGURATION-DESCR NAME KEY DESCR)))

(DEFUN BC-PANE-DESC (NAME STUFF)
  (PUSH `(,NAME ,@STUFF) *BC-SIZES*)
  (UNLESS (MEMQ NAME *BC-PANES*)
    (PUSH NAME *BC-PANES*)))

;;; Constraint macros

(DEFUN (FIXED-WITH-WHITESPACE CONSTRAINT-MACRO) (OLD-DESC STACKING)
  "A constraint-frame macro to take a window, and giving it the :FIXED attribute
leave whitespace around it on all four sides.  Format is:
    (name FIXED-WITH-WHITESPACE name-of-window color-of-border . constraint)
"
  (LET ((S1 (GENSYM)) (S2 (GENSYM)) (S3 (GENSYM)) (S4 (GENSYM))
	(SN (GENSYM)) (COB (FOURTH OLD-DESC)))
    `(,(SELECTQ STACKING
	 (:VERTICAL ':HORIZONTAL)
	 (:HORIZONTAL ':VERTICAL))
      ,(CDDDDR OLD-DESC)
      (,S1 ,SN ,S2)
      ((,SN ,STACKING (:ASK-WINDOW ,(THIRD OLD-DESC) :PANE-SIZE)
	(,S3 ,(THIRD OLD-DESC) ,S4)
	((,(THIRD OLD-DESC) :FIXED))
	((,S3 :BLANK ,COB :EVEN) (,S4 :BLANK ,COB :EVEN))))
      ((,S1 :BLANK ,COB :EVEN) (,S2 :BLANK ,COB :EVEN)))))

(DEFUN (INTERDIGITATED-WHITESPACE CONSTRAINT-MACRO) (OLD-DESC STACKING)
  "Leave whitespace betweem all specified constraints (alternates stacking):
    (name INTERDIGITATED-WHITESPACE color :INCLUDE-or-:EXCLUDE
          our-constraint
          whitespace-constraint
          . <same as args to a stacking constraint>)

   :EXCLUDE means no whitespace before first and after last, :INCLUDE means include this
whitespace."
  (LET ((COLOR (THIRD OLD-DESC))
	(IOE (FOURTH OLD-DESC))
	(WSPACECON (SIXTH OLD-DESC))
	(INFS (SEVENTH OLD-DESC))
	(WSPACE) (NINFS))
    (OR (MEMQ IOE '(:INCLUDE :EXCLUDE))
	(FERROR "~S must be either :INCLUDE or :EXCLUDE" IOE))
    (DO ((I INFS (CDR I))
	 (GS))
	(NIL)
      (COND ((AND (EQ IOE ':EXCLUDE)
		  (OR (EQ I INFS) (NULL I))))
	    (T
	     (SETQ GS (GENSYM))
	     (PUSH GS NINFS)
	     (PUSH `(,GS :BLANK ,COLOR . ,WSPACECON) WSPACE)))
      (AND I (PUSH (CAR I) NINFS))
      (AND (NULL I) (RETURN)))
    `(,(SELECTQ STACKING
	 (:VERTICAL ':HORIZONTAL)
	 (:HORIZONTAL ':VERTICAL))
      ,(FIFTH OLD-DESC)
      ,(NREVERSE NINFS)
      . ,(LET ((CONSTRS (COPYLIST (NTHCDR 7 OLD-DESC))))
	   (DO ((CS CONSTRS (CDR CS))
		(SEEN-* NIL))
	       ((NULL CS)
		(OR SEEN-* (RPLACD (LAST CONSTRS) (NCONS WSPACE))))
	     (COND ((MEMQ '* (CAR CS))
		    (SETQ SEEN-* T)
		    (RPLACA CS (APPEND (REMQ '* (CAR CS)) WSPACE)))))
	   CONSTRS))))

;;; Support from other flavors

(DEFMETHOD (:PANE-SIZE BASIC-MENU) (REM-WIDTH REM-HEIGHT IGNORE IGNORE STACKING
					      &OPTIONAL N-ROWS N-COLUMNS)
  (MULTIPLE-VALUE-BIND (IGNORE IGNORE NEW-WIDTH NEW-HEIGHT)
      (MENU-DEDUCE-PARAMETERS N-COLUMNS N-ROWS
			      (IF (EQ STACKING ':VERTICAL)
				  (- REM-WIDTH LEFT-MARGIN-SIZE RIGHT-MARGIN-SIZE)
				  ':UNCONSTRAINED)
			      (IF (EQ STACKING ':HORIZONTAL)
				  (- REM-HEIGHT TOP-MARGIN-SIZE BOTTOM-MARGIN-SIZE)
				  ':UNCONSTRAINED)
			      (- REM-WIDTH LEFT-MARGIN-SIZE RIGHT-MARGIN-SIZE)
			      (- REM-HEIGHT TOP-MARGIN-SIZE BOTTOM-MARGIN-SIZE))
    (SELECTQ STACKING
      (:VERTICAL (+ NEW-HEIGHT TOP-MARGIN-SIZE BOTTOM-MARGIN-SIZE))
      (:HORIZONTAL (+ NEW-WIDTH LEFT-MARGIN-SIZE RIGHT-MARGIN-SIZE)))))

(DEFMETHOD (:PANE-SIZE ESSENTIAL-WINDOW) (REM-WIDTH REM-HEIGHT IGNORE IGNORE STACKING)
  (SELECTQ STACKING
    (:VERTICAL (MIN REM-HEIGHT HEIGHT))
    (:HORIZONTAL (MIN REM-WIDTH WIDTH))))

;These are obsolete, I guess
(DEFMETHOD (:PANE-WIDTH PANE-MIXIN) (&REST ARGS)
  (LEXPR-SEND SELF ':PANE-SIZE ARGS))
       
(DEFMETHOD (:PANE-HEIGHT PANE-MIXIN) (&REST ARGS)
  (LEXPR-SEND SELF ':PANE-SIZE ARGS))

(COMPILE-FLAVOR-METHODS WINDOW-PANE LISP-LISTENER-PANE COMMAND-MENU-PANE
			BASIC-FRAME
			CONSTRAINT-FRAME BORDERED-CONSTRAINT-FRAME
			CONSTRAINT-FRAME-WITH-SHARED-IO-BUFFER
			BORDERED-CONSTRAINT-FRAME-WITH-SHARED-IO-BUFFER)
