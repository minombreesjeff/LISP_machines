;;; -*- Syntax: Zetalisp; Mode: LISP; Package: TV; Base: 8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB");---This file has a series of unfinished ADSI changes.

0;This file contains stuff that goes along with TSCROL for letting the
;user choose things in various ways other than menus.

(DEFSTRUCT (MARGIN-REGION :LIST (:CONSTRUCTOR NIL))
  MARGIN-REGION-FUNCTION				;A DTP-SELECT-METHOD for this one
  MARGIN-REGION-MARGIN					;Name of the margin occupied
  MARGIN-REGION-SIZE					;Amount of that to occupy
  MARGIN-REGION-LEFT					;Its area of the screen
  MARGIN-REGION-TOP
  MARGIN-REGION-RIGHT
  MARGIN-REGION-BOTTOM)

(DEFUN KLUDGE-CALCULATE-HEIGHT (REGION SHEET)
  (FONT-CHAR-HEIGHT (SI:CACHE-LOOKUP (SHEET-CHARSET&STYLEFONT-CACHE SHEET)
				  #'SI:GET-FONT
				  (SHEET-DISPLAY-DEVICE-TYPE SHEET)
				  SI:*STANDARD-CHARACTER-SET*
				  (MARGIN-SCROLL-REGION-MSG-STYLE REGION) NIL)))

;;; Margin region windows, various special areas can be defined within the window's
;;; margins that are allowed to handle the mouse
(DEFFLAVOR MARGIN-REGION-MIXIN
       ((REGION-LIST NIL)				;A list of active regions
	(CURRENT-REGION NIL)				;The one currently owning the mouse
	)
       (MARGIN-HACKER-MIXIN)
  (:REQUIRED-FLAVORS ESSENTIAL-MOUSE)
  (:INITABLE-INSTANCE-VARIABLES REGION-LIST)
  (:DOCUMENTATION :MIXIN "Allows separate mouse handling in parts of the margins"))

(DEFMETHOD (:INIT MARGIN-REGION-MIXIN :BEFORE) (INIT-PLIST)
  (SEND SELF ':INIT-REGION-LIST INIT-PLIST))

(DEFMETHOD (:INIT-REGION-LIST MARGIN-REGION-MIXIN) (INIT-PLIST)
  (ADJUST-MARGINS 'REGION-LIST ':PARSE-REGION-LIST INIT-PLIST NIL))

(DEFMETHOD (:WHO-LINE-DOCUMENTATION-STRING MARGIN-REGION-MIXIN :OVERRIDE) ()
  (AND CURRENT-REGION
       (FUNCALL (MARGIN-REGION-FUNCTION CURRENT-REGION) ':WHO-LINE-DOCUMENTATION-STRING
		SELF CURRENT-REGION)))

(DEFMETHOD (:SET-REGION-LIST MARGIN-REGION-MIXIN) (NEW-REGION-LIST
					 &AUX (PLIST (LIST ':REGION-LIST NEW-REGION-LIST)))
  (SEND SELF ':REDEFINE-MARGINS (LOCF PLIST)))

(DEFMETHOD (:REDEFINE-MARGINS MARGIN-REGION-MIXIN :BEFORE) (PLIST)
  (ADJUST-MARGINS 'REGION-LIST ':PARSE-REGION-LIST PLIST ':REGION-LIST))

(DEFMETHOD (:PARSE-REGION-LIST MARGIN-REGION-MIXIN) (SPEC LM TM RM BM)
  (DO ((SPEC SPEC (CDR SPEC))
       (REGION) (SIZE))
      ((NULL SPEC))
    (SETQ REGION (CAR SPEC)
	  SIZE (MARGIN-REGION-SIZE REGION))
    (AND ( SIZE 0)
	 ;; Negative size means the region took care of setting this stuff
	 (MULTIPLE-VALUE (NIL LM TM RM BM)
	   (MARGIN-REGION-SET-SIZE REGION SIZE LM TM RM BM))))
  (VALUES SPEC LM TM RM BM))

(DEFUN MARGIN-REGION-SET-SIZE (REGION SIZE LM TM RM BM)
  (LET ((LEFT LM) (TOP TM)
	(RIGHT (- RM)) (BOTTOM (- BM)))
    (SELECTQ (MARGIN-REGION-MARGIN REGION)
      (:LEFT
       (SETQ RIGHT (SETQ LM (+ LM SIZE))))
      (:TOP
       (SETQ BOTTOM (SETQ TM (+ TM SIZE))))
      (:RIGHT
       (SETQ LEFT (- (SETQ RM (+ RM SIZE)))))
      (:BOTTOM
       (SETQ TOP (- (SETQ BM (+ BM SIZE))))))
    (SETF (MARGIN-REGION-LEFT REGION) LEFT)
    (SETF (MARGIN-REGION-TOP REGION) TOP)
    (SETF (MARGIN-REGION-RIGHT REGION) RIGHT)
    (SETF (MARGIN-REGION-BOTTOM REGION) BOTTOM))
  (VALUES REGION LM TM RM BM))

(DEFMETHOD (:REFRESH-MARGINS MARGIN-REGION-MIXIN :AFTER) ()
  (DOLIST (REGION REGION-LIST)
    (FUNCALL (MARGIN-REGION-FUNCTION REGION) ':REFRESH SELF REGION)))

;(DEFWRAPPER (MARGIN-REGION-MIXIN :MOUSE-MOVES) (IGNORE . BODY)
;  `(*CATCH 'REGION-HANDLED-MOUSE
;     (PROGN . ,BODY)))

(DEFWRAPPER (:HANDLE-MOUSE MARGIN-REGION-MIXIN) (IGNORE . BODY)
  `(UNWIND-PROTECT
       (PROGN . ,BODY)
     (IF CURRENT-REGION
	 (FUNCALL (MARGIN-REGION-FUNCTION CURRENT-REGION)
		  ':MOUSE-LEAVES-REGION SELF CURRENT-REGION)
	 (SEND SELF ':MOUSE-LEAVES-REGION))
     (SETQ CURRENT-REGION NIL)))

(DEFUN-IN-FLAVOR (MARGIN-REGION-AREA MARGIN-REGION-MIXIN) (REGION &AUX LEFT TOP RIGHT BOTTOM)
  (SETQ LEFT (MARGIN-REGION-LEFT REGION)
	TOP (MARGIN-REGION-TOP REGION)
	RIGHT (MARGIN-REGION-RIGHT REGION)
	BOTTOM (MARGIN-REGION-BOTTOM REGION))
  (AND (< LEFT 0) (SETQ LEFT (+ WIDTH LEFT)))
  (AND (< TOP 0) (SETQ TOP (+ HEIGHT TOP)))
  (AND ( RIGHT 0) (SETQ RIGHT (+ WIDTH RIGHT)))
  (AND ( BOTTOM 0) (SETQ BOTTOM (+ HEIGHT BOTTOM)))
  (VALUES LEFT TOP RIGHT BOTTOM))

(DEFUN-IN-FLAVOR (UPDATE-CURRENT-MARGIN-REGION MARGIN-REGION-MIXIN) (X Y &AUX REGION)
  (DOLIST (REG REGION-LIST)
    (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
	(MARGIN-REGION-AREA REG)
      (AND ( X LEFT) (< X RIGHT) ( Y TOP) (< Y BOTTOM)
	   (RETURN (SETQ REGION REG)))))
  (COND ((NEQ REGION CURRENT-REGION)
	 (IF CURRENT-REGION
	     (FUNCALL (MARGIN-REGION-FUNCTION CURRENT-REGION) ':MOUSE-LEAVES-REGION
		      SELF CURRENT-REGION)
	     (SEND SELF ':MOUSE-LEAVES-REGION))
	 (IF REGION
	     (FUNCALL (MARGIN-REGION-FUNCTION REGION) ':MOUSE-ENTERS-REGION
		      SELF REGION)
	     (SEND SELF ':MOUSE-ENTERS-REGION))))
  (COND ((SETQ CURRENT-REGION REGION)
;	 (MOUSE-SET-BLINKER-CURSORPOS)
	 (FUNCALL (MARGIN-REGION-FUNCTION CURRENT-REGION) ':MOUSE-MOVES
		  SELF CURRENT-REGION X Y)
;	 (*THROW 'REGION-HANDLED-MOUSE T)
	 )))

(DEFMETHOD (:MOUSE-MOVES MARGIN-REGION-MIXIN :AFTER) (X Y)
  (UPDATE-CURRENT-MARGIN-REGION X Y))

(DEFMETHOD (:MOUSE-CLICK MARGIN-REGION-MIXIN) (BUTTON X Y)
  (UNLESS (CHAR-MOUSE-EQUAL BUTTON #\MOUSE-3-2)
    (UPDATE-CURRENT-MARGIN-REGION X Y)
    (WHEN CURRENT-REGION
      (FUNCALL (MARGIN-REGION-FUNCTION CURRENT-REGION) ':MOUSE-CLICK
	       SELF CURRENT-REGION X Y BUTTON)
      T)))

(DEFMETHOD (:MOUSE-ENTERS-REGION MARGIN-REGION-MIXIN) ())

(DEFMETHOD (:MOUSE-LEAVES-REGION MARGIN-REGION-MIXIN) ())

;;; Special scrolling windows that tell when there is more above or below and scroll if
;;; you click there
(DEFFLAVOR MARGIN-SCROLL-MIXIN () (MARGIN-REGION-MIXIN)
  (:REQUIRED-FLAVORS BASIC-SCROLL-BAR)
  (:INIT-KEYWORDS :MARGIN-SCROLL-REGIONS)
  (:DOCUMENTATION :MIXIN "Shows if there is more above or below"))

(DEFSTRUCT (MARGIN-SCROLL-REGION :LIST (:INCLUDE MARGIN-REGION) (:CONSTRUCTOR NIL))
  MARGIN-SCROLL-REGION-EMPTY-MSG			;Message when nothing more to scroll
  MARGIN-SCROLL-REGION-MORE-MSG				;Other message
  MARGIN-SCROLL-REGION-MSG-style			;
  MARGIN-SCROLL-REGION-MORE-P				;Is there more to scroll to?
)


(DEFMETHOD (:INIT-REGION-LIST MARGIN-SCROLL-MIXIN :BEFORE) (INIT-PLIST &AUX TOP-P)
  (DOLIST (REGION (GET INIT-PLIST ':MARGIN-SCROLL-REGIONS))
    (COND ((MEMQ REGION '(:TOP :BOTTOM))
	   (SETQ TOP-P (EQ REGION ':TOP)
		 REGION (LIST 'MARGIN-SCROLL-REGION REGION 0 0 0 0 0 NIL NIL NIL NIL)))
	  ((MEMQ (CAR REGION) '(:TOP :BOTTOM))
	   (SETQ TOP-P (EQ (CAR REGION) ':TOP)
		 REGION (LIST 'MARGIN-SCROLL-REGION (CAR REGION) 0 0 0 0 0 (CADR REGION)
			      (CADDR REGION) (CADDDR REGION) NIL)))
	  (T
	   (SETQ TOP-P (EQ (MARGIN-REGION-MARGIN REGION) ':TOP))))
    (OR (MARGIN-SCROLL-REGION-EMPTY-MSG REGION)
	(SETF (MARGIN-SCROLL-REGION-EMPTY-MSG REGION)
	      (IF TOP-P "Top" "Bottom")))
    (OR (MARGIN-SCROLL-REGION-MORE-MSG REGION)
	(SETF (MARGIN-SCROLL-REGION-MORE-MSG REGION)
	      (IF TOP-P "More above" "More below")))
    (OR (MARGIN-SCROLL-REGION-MSG-STYLE REGION)
	(SETF (MARGIN-SCROLL-REGION-MSG-STYLE REGION)
	      (SI:PARSE-CHARACTER-STYLE '(:DUTCH :ITALIC :SMALL))))    
    (SETF (MARGIN-REGION-SIZE REGION)
	  (+ 2 (KLUDGE-CALCULATE-HEIGHT REGION SELF)))
    (PUSH REGION REGION-LIST)))

(DEFMETHOD (:NEW-SCROLL-POSITION MARGIN-SCROLL-MIXIN :AFTER) (&REST IGNORE)
  (DOLIST (REGION REGION-LIST)
    (WHEN (EQ (MARGIN-REGION-FUNCTION REGION) 'MARGIN-SCROLL-REGION)
      (MARGIN-SCROLL-REGION ':REFRESH SELF REGION T))))

(DEFSELECT MARGIN-SCROLL-REGION
  (:REFRESH (WINDOW REGION &OPTIONAL OLD-VALID)
   (UNLESS (ZEROP (MARGIN-REGION-SIZE REGION))	;Turned off
     (REFRESH-MARGIN-SCROLL-REGION WINDOW REGION OLD-VALID)))
  ((:MOUSE-ENTERS-REGION :MOUSE-LEAVES-REGION :MOUSE-MOVES) (&REST IGNORE))
  (:MOUSE-CLICK (WINDOW REGION IGNORE IGNORE IGNORE)
   (IF (MARGIN-SCROLL-REGION-MORE-P REGION)
       (LET ((FROM (MARGIN-REGION-MARGIN REGION)))
	 (SEND WINDOW :SCROLL-RELATIVE FROM (IF (EQ FROM ':TOP) ':BOTTOM ':TOP)))
       (BEEP)))
  (:WHO-LINE-DOCUMENTATION-STRING (IGNORE IGNORE) "Any button to scroll one page."))

(DEFMETHOD (REFRESH-MARGIN-SCROLL-REGION MARGIN-SCROLL-MIXIN) (REGION OLD-VALID)
  (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
      (MARGIN-REGION-AREA REGION)
   (LET ((MORE-P (SEND SELF (IF (EQ (MARGIN-REGION-MARGIN REGION) ':TOP)
				':SCROLL-MORE-ABOVE ':SCROLL-MORE-BELOW))))
     (WHEN (OR (NOT OLD-VALID) (NEQ MORE-P (MARGIN-SCROLL-REGION-MORE-P REGION)))
       (SETF (MARGIN-SCROLL-REGION-MORE-P REGION) MORE-P)
       (SHEET-FORCE-ACCESS (SELF)
	 (WHEN OLD-VALID
	   (SHEET-DRAW-RECTANGLE (- RIGHT LEFT) (- BOTTOM TOP) LEFT TOP ERASE-ALUF))
	 (LET* ((MSG (IF MORE-P (MARGIN-SCROLL-REGION-MORE-MSG REGION)
			 (MARGIN-SCROLL-REGION-EMPTY-MSG REGION)))
		(MSGL (SEND SELF :STRING-LENGTH MSG 0 NIL NIL
			    (MARGIN-SCROLL-REGION-MSG-STYLE REGION))))
	   (WITH-CHARACTER-STYLE ((MARGIN-SCROLL-REGION-MSG-STYLE REGION) SELF)
	     (SEND SELF :STRING-OUT-EXPLICIT MSG (MAX (// (- (+ RIGHT LEFT) MSGL) 2) LEFT)
					     TOP RIGHT CHAR-ALUF))))))))

(DEFFLAVOR MARGIN-SCROLL-REGION-ON-AND-OFF-WITH-SCROLL-BAR-MIXIN ()
	   (MARGIN-SCROLL-MIXIN BASIC-SCROLL-BAR)
  (:DOCUMENTATION :MIXIN
     "Makes the margin-scroll-regions disappear if the scroll-bar is set to NIL"))

(DEFMETHOD (:REDEFINE-MARGINS MARGIN-SCROLL-REGION-ON-AND-OFF-WITH-SCROLL-BAR-MIXIN :BEFORE)
						(PLIST &AUX TEM)
  (COND ((SETQ TEM (GETL PLIST '(:SCROLL-BARS)))	;If changing the scroll-bar
	 (SETQ TEM (CADR TEM))
	 (DOLIST (R REGION-LIST)
	   (AND (EQ (MARGIN-REGION-FUNCTION R) 'MARGIN-SCROLL-REGION)
		(SETF (MARGIN-REGION-SIZE R)
		      (IF (NULL TEM) 0
			  (+ 2 (KLUDGE-CALCULATE-HEIGHT R SELF))))))
	 (PUTPROP PLIST REGION-LIST ':REGION-LIST))))  ;Cause those changes to get parsed

(DEFFLAVOR MARGIN-SCROLLING-WITH-FLASHY-SCROLLING-MIXIN ()
	   (MARGIN-SCROLL-MIXIN MARGIN-REGION-MIXIN FLASHY-SCROLLING-MIXIN)
  (:DEFAULT-INIT-PLIST :FLASHY-SCROLLING-REGION '((32. 0.40s0 0.60s0) (32. 0.40s0 0.60s0))))

(DEFMETHOD (:WHO-LINE-DOCUMENTATION-STRING MARGIN-SCROLLING-WITH-FLASHY-SCROLLING-MIXIN :OVERRIDE) ()
  (AND FLASHY-SCROLLING-BLINKER
       (IF (= (CHAR-CODE (SEND (MOUSE-BLINKER (SHEET-MOUSE SELF)) :CHARACTER)) 10)
	   ;; Character 10 is upward pointing arrow for top of window
  "Bump blinker against top to scroll down by one line.  Any button to scroll one page." 
  "Bump blinker against bottom to scroll up by one line.  Any button to scroll one page.")))

(DEFFLAVOR SCROLL-STUFF-ON-OFF-MIXIN
	((MAKING-SCROLL-DECISION NIL))	;Internal, prevents infinite recursion
	(MARGIN-SCROLLING-WITH-FLASHY-SCROLLING-MIXIN
	 MARGIN-SCROLL-MIXIN MARGIN-REGION-MIXIN FLASHY-SCROLLING-MIXIN
	 BASIC-SCROLL-BAR)
	(:REQUIRED-METHODS :SCROLL-BAR-P	;T if scrolling needed
			   :ADJUSTABLE-SIZE-P)	;T if outside size can change
						; to preserve inside size,
						; NIL if something like a pane
	(:DOCUMENTATION :MIXIN "Scroll bar, flashy scrolling, and margin scrolling, which turn on and off with :SCROLL-BAR-P")
	(:DEFAULT-INIT-PLIST :SCROLL-BAR 2  ;This 2 is unmodular, sigh.
			     :MARGIN-SCROLL-REGIONS '(:TOP :BOTTOM)))

(DEFMETHOD (:REDEFINE-MARGINS SCROLL-STUFF-ON-OFF-MIXIN :BEFORE)
						(PLIST &AUX TEM)
  (COND ((SETQ TEM (GETL PLIST '(:SCROLL-BARS)))	;If changing the scroll-bar
	 (SETQ TEM (CADR TEM))
	 (DOLIST (R REGION-LIST)
	   (AND (EQ (MARGIN-REGION-FUNCTION R) 'MARGIN-SCROLL-REGION)
		(SETF (MARGIN-REGION-SIZE R)
		      (IF (NULL TEM) 0
			  ;--- 1This cannot be right. What about  japanese?
0			  (+ 2 (KLUDGE-CALCULATE-HEIGHT R SELF))))))
	 (PUTPROP PLIST REGION-LIST ':REGION-LIST))))  ;Cause those changes to get parsed

(DEFMETHOD (:CHANGE-OF-SIZE-OR-MARGINS SCROLL-STUFF-ON-OFF-MIXIN :AFTER) (&REST IGNORE)
  (OR MAKING-SCROLL-DECISION
      (SEND SELF ':DECIDE-IF-SCROLLING-NECESSARY)))

;;; Window should send this message to itself after changing the
;;; number of displayable items, but before doing the associated
;;; redisplay.  This method will decide whether to turn the scroll
;;; bar, flashy scrolling, and margin-scroll regions on and off.
;;; If :ADJUSTABLE-SIZE-P, then if changing the number of displayable
;;; items changes the height of the window, that should be done
;;; before sending this message.
;;; This can change the inside-height of the window, unless the
;;; :ADJUSTABLE-SIZE-P message returns NIL.
;;; Note that redisplay can happen inside this method, you may want
;;; to do a WITH-SHEET-DEEXPOSED to avoid letting the user see
;;; gratuitous double redisplays, or to suppress the redisplay
;;; entirely if there is no bit-save-array.
(DEFMETHOD (:DECIDE-IF-SCROLLING-NECESSARY SCROLL-STUFF-ON-OFF-MIXIN) ()
  (LETF ((MAKING-SCROLL-DECISION T))
    (LET ((IW (SHEET-INSIDE-WIDTH)) (IH (SHEET-INSIDE-HEIGHT)) (CHANGEP NIL))
      (MULTIPLE-VALUE-BIND (IGNORE IGNORE MIN-ITEM-INDEX MAX-ITEM-INDEX)
	  (SEND SELF :Y-SCROLL-POSITION)
	(UNLESS (= MIN-ITEM-INDEX MAX-ITEM-INDEX)
	  (IF (SEND SELF :SCROLL-BAR-P)		;Need scrolling?
	      ;; Needs scrolling.  If scroll stuff not on, turn on
	      (UNLESS (SEND SELF :SCROLL-BAR-IN-MARGIN :LEFT)
		(SETQ CHANGEP T)
		(SEND SELF :SET-SCROLL-BARS `(:LEFT 2)))
	      ;; Doesn't need scrolling, turn off if on
	      (WHEN (SEND SELF :SCROLL-BAR-IN-MARGIN :LEFT)
		(SETQ CHANGEP T)		;Turn scroll stuff off
		(SEND SELF :REMOVE-SCROLL-BAR :LEFT)))
	  (AND CHANGEP (SEND SELF :ADJUSTABLE-SIZE-P)
	       ;; Keep same inside size, even though margins have changed size,
	       ;; but don't make it cease to fit in its superior.
	       (SEND SELF :SET-INSIDE-SIZE (MIN (- (SHEET-INSIDE-WIDTH SUPERIOR)
						   LEFT-MARGIN-SIZE RIGHT-MARGIN-SIZE)
						IW)
		     (MIN (- (SHEET-INSIDE-HEIGHT SUPERIOR)
			     TOP-MARGIN-SIZE BOTTOM-MARGIN-SIZE)
			  IH))))))))

(DEFFLAVOR LINE-AREA-TEXT-SCROLL-WINDOW () (TEXT-SCROLL-WINDOW)
  (:REQUIRED-FLAVORS MARGIN-REGION-MIXIN)
  (:INIT-KEYWORDS :LINE-AREA-WIDTH)
  (:METHOD-COMBINATION :LINE-AREA-MOUSE-DOCUMENTATION :DAEMON-WITH-OVERRIDE)
  (:DOCUMENTATION :MIXIN "Allows selection of a line from the left margin"))

(DEFMETHOD (:INIT-REGION-LIST LINE-AREA-TEXT-SCROLL-WINDOW :BEFORE) (INIT-PLIST)
  (PUSH (LIST 'LINE-AREA-REGION ':LEFT (OR (GET INIT-PLIST ':LINE-AREA-WIDTH) 30)
	      0 0 0 0)
	REGION-LIST))

(DEFMETHOD (:LINE-AREA-MOUSE-DOCUMENTATION LINE-AREA-TEXT-SCROLL-WINDOW) ()
  "Select a line.")

(DEFSELECT LINE-AREA-REGION
  ((:REFRESH :MOUSE-MOVES) (&REST IGNORE))
  (:MOUSE-ENTERS-REGION (IGNORE IGNORE)
   (MOUSE-SET-BLINKER-DEFINITION ':CHARACTER 15 6 ':ON
				 ':SET-CHARACTER #\MOUSE:RIGHT-ARROW))
  (:MOUSE-LEAVES-REGION (IGNORE IGNORE)
    (MOUSE-STANDARD-BLINKER))
  (:MOUSE-CLICK (WINDOW IGNORE X Y BD &AUX ITEM)
    (IGNORE X)
    (LET ((TOP-ITEM (SEND WINDOW :TOP-ITEM))
	  (ITEMS (SEND WINDOW :ITEMS)))
      (IF (AND ( Y (SHEET-INSIDE-TOP WINDOW))
	       (LET ((LINE (+ TOP-ITEM (SHEET-LINE-NO WINDOW Y))))
		 (AND (< LINE (ARRAY-ACTIVE-LENGTH ITEMS))
		      (SETQ ITEM (AREF ITEMS LINE)))))
	  (SEND WINDOW :FORCE-KBD-INPUT `(:LINE-AREA ,ITEM ,WINDOW ,BD))
	  (BEEP))))
  (:WHO-LINE-DOCUMENTATION-STRING (WINDOW IGNORE)
   (SEND WINDOW :LINE-AREA-MOUSE-DOCUMENTATION)))


(DEFFLAVOR LINE-AREA-MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW ()
	   (BORDERS-MIXIN MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW LINE-AREA-TEXT-SCROLL-WINDOW)
  (:DOCUMENTATION :COMBINATION))

(DEFMETHOD (:MOUSE-LEAVES-REGION LINE-AREA-MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW) ()
  (BLINKER-SET-VISIBILITY ITEM-BLINKER NIL))


(DEFFLAVOR CURRENT-ITEM-MIXIN ((CURRENT-ITEM NIL)) (LINE-AREA-TEXT-SCROLL-WINDOW)
  (:GETTABLE-INSTANCE-VARIABLES CURRENT-ITEM)
  (:DOCUMENTATION :MIXIN "Provides an arrow in the line-area pointing to current-item"))

(DEFUN-IN-FLAVOR (UPDATE-CURRENT-ITEM CURRENT-ITEM-MIXIN) (&REST IGNORE)
  (LET ((REGION (ASSQ 'LINE-AREA-REGION REGION-LIST))
	(ITEM-NO (DOTIMES (I (ARRAY-ACTIVE-LENGTH ITEMS))
		   (AND (EQ (AREF ITEMS I) CURRENT-ITEM) (RETURN I)))))
    (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
	(MARGIN-REGION-AREA REGION)
      (MULTIPLE-VALUE-BIND (TOP-ITEM-NO IGNORE IGNORE MAX-ITEM-NO)
	  (SEND SELF :Y-SCROLL-POSITION)
	(LET ((CURRENT-ITEM-Y (AND ITEM-NO ( TOP-ITEM-NO MAX-ITEM-NO)	;Can be 1 off end
				   (+ (SHEET-INSIDE-TOP)
				      (* LINE-HEIGHT (- ITEM-NO TOP-ITEM-NO))))))
	  (SHEET-FORCE-ACCESS (SELF)
	    (SHEET-DRAW-RECTANGLE (- RIGHT LEFT) (- BOTTOM TOP) LEFT TOP ERASE-ALUF)
	    (AND CURRENT-ITEM-Y
		 ( CURRENT-ITEM-Y TOP)
		 ( (+ CURRENT-ITEM-Y (FONT-CHAR-HEIGHT CURRENT-FONT)) BOTTOM)
		 ;; We need to use this because we are trying to draw in the margin.
		 (TV:WITH-SHEET-CLIPPING-REGION (LEFT TOP RIGHT BOTTOM)
		   (SHEET-DRAW-CHAR #/
				  (- RIGHT (FONT-CHAR-WIDTH CURRENT-FONT) 6)
				  CURRENT-ITEM-Y
				  CHAR-ALUF)))))))))


(DEFMETHOD (:SET-CURRENT-ITEM CURRENT-ITEM-MIXIN) (NEW-CURRENT-ITEM)
  (COND ((NEQ NEW-CURRENT-ITEM CURRENT-ITEM)
	 (SETQ CURRENT-ITEM NEW-CURRENT-ITEM)
	 (UPDATE-CURRENT-ITEM))))

(DEFMETHOD (:REFRESH-MARGINS CURRENT-ITEM-MIXIN :AFTER) ()
  (UPDATE-CURRENT-ITEM))

(DEFMETHOD (:NEW-SCROLL-POSITION CURRENT-ITEM-MIXIN :AFTER) (&REST IGNORE)
  (UPDATE-CURRENT-ITEM))

;;;TV:MARK-CURRENT-ITEM-MIXIN
;;;Provides an arrow in the margin marking the "current" item.
;;;Set the item by :SET-CURRENT-ITEM.  
;;;Customize the arrow by setting the mark-data (either init keyword :mark-data, or 
;;;  message :set-mark-data)  to a list of (font, char-code, x-offset, y-offset) where
;;;  the offsets are optional.
;;;The arrow will be on the left unless you include as init option:
;;;  :MARK-CURRENT-ITEM-REGION-SIDE :RIGHT (of course, you'd better have a left-pointing arrow
;;;  to display there).
;;;Mix in with TV:TEXT-SCROLL-WINDOW (or any other flavor that supports :ITEMS the same way).
;;;This is like tv:current-item-mixin except that it doesn't share the line-area margin.
;;; In Genera right now (7.0) the only thing that uses this is the Document Examiner's 
;;; Candidates and Bookmarks panes.  Probably even that will go away as of 7.2.

(defflavor mark-current-item-mixin
	((current-item)
	 (mark-data (list 'fonts:narrow #\? 0 -1)))
	(margin-region-mixin)
  (:settable-instance-variables mark-data)
  (:gettable-instance-variables current-item)
  (:init-keywords :mark-current-item-region-side :mark-current-item-region-width)
  )

(defstruct (mark-current-item-data :list (:constructor ()) :conc-name)
  font char x-off y-off)

(defmethod (:init-region-list mark-current-item-mixin :before) (init-plist)
  (push (list 'mark-current-item-region
	      (or (get init-plist :mark-current-item-region-side) :left)
	      (or (get init-plist :mark-current-item-region-width)
		  (destructuring-bind (font char) mark-data
		    (let ((font (send (send self :screen) :parse-font-descriptor font)))
		      (let ((cwt (font-char-width-table font)))
			(+ 2 (if cwt (aref cwt (char-code char)) (font-char-width font)))))))
	      0 0 0 0)
	region-list))

(defselect mark-current-item-region
  (:refresh (window region)
    (refresh-mark-current-item-region window region))
  ((:mouse-enters-region :mouse-leaves-region :mouse-moves :mouse-click) (&rest ignore))
  (:who-line-documentation-string (ignore ignore) nil))

(defmethod (refresh-mark-current-item-region mark-current-item-mixin) (region)
  (multiple-value-bind (left top right bottom)
      (margin-region-area region)
    (let ((item-no (and current-item
			(loop for elt being array-elements of (send self :items)
				      using (index i)
			      when (eq elt current-item) return i
			      finally (setq current-item ())))))
      (multiple-value-bind (top-item-no ignore ignore total-items)
	  (send self :y-scroll-position)
	(sheet-force-access (self)
	  (sheet-draw-rectangle (- right left) (- bottom top) left top erase-aluf self)
	  (unless (null item-no)
	    (let ((current-item-y (and ( top-item-no total-items)	;Can be 1 off end
				       (+ (sheet-inside-top)
					  (* line-height (- item-no top-item-no))))))
	      (destructuring-bind (font char x-off y-off) mark-data
		(setq font (send (send self :screen) :parse-font-descriptor font))
		(when (null x-off) (setq x-off 0))
		(when (null y-off) (setq y-off 0))
		(and current-item-y
		     ( current-item-y top)
		     ( (+ current-item-y (font-char-height font)) bottom)
		     (with-sheet-clipping-region (left top right bottom)
		       (sheet-draw-glyph
			 (char-code char) font (+ left 1 x-off) (+ current-item-y y-off)
			 char-aluf)))))))))))

(defun-in-flavor (update-mark-current-item mark-current-item-mixin) (&rest ignore)
  (refresh-mark-current-item-region self (assq 'mark-current-item-region region-list)))

(defmethod (:set-current-item mark-current-item-mixin) (new-current-item)
  (unless (eq new-current-item current-item)
    (setq current-item new-current-item))
  (update-mark-current-item))

(defmethod (:refresh-margins mark-current-item-mixin :after) ()
  (update-mark-current-item))

(defmethod (:new-scroll-position mark-current-item-mixin :after) ()
  (update-mark-current-item))

(defmethod (:new-mark-data mark-current-item-mixin :after) ()
  (update-mark-current-item))

;;; TV:MAINTAIN-CURRENT-ITEM-MIXIN
;;; Makes new items become marked as current-item.

(defflavor maintain-current-item-mixin () ()
  (:required-methods :set-current-item))

(defmethod (:set-items maintain-current-item-mixin :after) (&rest ignore)
  (send self :set-current-item ()))

;;; TV:MAC-SCROLL-MIXIN  -- looks like Macintosh scroll bars.
;;;   Right now there are only y-scroll bars.
;;;   You probably want to turn off the basic-scroll-bars with init keyword :SCROLL-BARS NIL.
;;;   The scroll bar is on the right.  Put it on the left with
;;;   init keyword :MAC-SCROLL-SIDE :LEFT.
;;;   The bar is of width 18.  Change it with init keyword :MAC-SCROLL-REGION-WIDTH n.
;;;   The height of the scroll region defaults to the height of the window.  If you
;;;   would rather have the mac-scroll-bars on all your windows be fixed height,
;;;   set tv:*mac-scroll-region-bar-height* to that height.  (If the window is shorter
;;;   than that, of course the bar will be shorter, too.)
;;; In Genera right now (7.0) nothing uses this; everything uses the "new" dw scroll bars.

(defflavor mac-scroll-mixin
	()
	(margin-region-mixin)
  (:init-keywords :mac-scroll-region-width :mac-scroll-side)
  )

(defstruct (mac-scroll-region :list (:include margin-region) (:constructor nil))
  mac-scroll-region-box-top
  mac-scroll-region-box-bottom
  mac-scroll-region-bar-top
  mac-scroll-region-bar-bottom
  )

;;;This is a default method that is appropriate when the window that needs
;;;scrolling has fixed height lines.  If it doesn't then you have to provide
;;;your own method that knows how to return the correct values.  (Beware the
;;;problem of a partially filled screen when trying to compute the number of
;;;variable height lines in a window.)
(defmethod (:sheet-line-count mac-scroll-mixin) (&optional sheet)
  (if sheet
      (sheet-number-of-inside-lines sheet)
      (sheet-number-of-inside-lines)))		;macro dies if called with explicit NIL

(defmacro with-mac-scroll-region-ends (vars region &body body &environment env)
  (let ((access '((box-top mac-scroll-region-box-top)
		  (box-bottom mac-scroll-region-box-bottom)
		  (bar-top mac-scroll-region-bar-top)
		  (bar-bottom mac-scroll-region-bar-bottom))))
    (once-only (region &environment env)
      (let ((bindings (loop for v in vars
			    for accessor = (or (second (assq v access))
					       (ferror "The variable ~s must be literally ~
							 among ~s" v access))
			    collect `(,v (,accessor ,region)))))
	`(let ,bindings ,@body)))))

(defconst *mac-scroll-region-box-height* 18.)
(defconst *mac-scroll-region-bar-height* ())	;250. works well

(defconst *mac-scroll-region-mouse-doc*
  (let ((rest "M: This line to top;  R: This line to bottom; (M2: Top to this line)"))
    ;;--- "R2: Bottom to this line"
    (si:copytree-and-leaves
       (loop for (key stuff) in '((:top-box "Scroll to prev line")
				  (:bottom-box "Scroll to next line")
				  (:upper-gray "Scroll to prev screen")
				  (:lower-gray "Scroll to next screen")
				  (:in-box "Move (drag) the box")
				  (()))
	     collect (list key (format () "~@:[~;L: ~a;  ~]~a"
				       stuff rest)))
       permanent-storage-area)))


(defmethod (:init-region-list mac-scroll-mixin :before) (init-plist)
  (push (list 'mac-scroll-region
	      (or (get init-plist :mac-scroll-side) :right)
	      (or (get init-plist :mac-scroll-region-width) 16.)
	      0 0 0 0 () () () ())
	region-list))

(defmethod (mac-scroll-region-refresh mac-scroll-mixin) (region)
  (multiple-value-bind (left top right bottom)
      (margin-region-area region)
    (multiple-value-bind  (first-y-in-window total-y-in-window
			   first-y-overall last-y-overall)
	(send self :y-scroll-position)
      ;;    FIRST-Y-IN-WINDOW  - The y coordinate of the first line
      ;;                         visible in the window.
      ;;    TOTAL-Y-IN-WINDOW  - The total number of 'coordinate units'
      ;;                         displayed in the window.
      ;;    FIRST-Y-OVERALL    - The minimum y coordinate that can
      ;;                         be scrolled to.
      ;;    LAST-Y-OVERALL     - The maximum y coordinate that can
      ;;                         be scrolled to.
      (let* ((bar-top (+ top *mac-scroll-region-box-height*))
	     (bar-bottom (let ((tem (- bottom *mac-scroll-region-box-height*)))
			   (if (null *mac-scroll-region-bar-height*)
			       tem
			       (min tem (+ bar-top *mac-scroll-region-bar-height*)))))
	     (wid (- right left)))
	(multiple-value-bind (box-top box-bottom)
	    (mac-compute-scroll-bar-ends
	      first-y-overall last-y-overall
	      first-y-in-window (+ first-y-in-window total-y-in-window)
	      bar-top bar-bottom)
	  (setf (mac-scroll-region-box-top region) box-top)
	  (setf (mac-scroll-region-box-bottom region) box-bottom)
	  (setf (mac-scroll-region-bar-top region) bar-top)
	  (setf (mac-scroll-region-bar-bottom region) bar-bottom)
	  (sheet-force-access (self)
	    ;;Draw the upper and lower arrows, erasing first.
	    (let ((wid//2 (floor wid 2)))
	      (sheet-draw-rectangle wid 1 left top char-aluf)
	      (sheet-draw-char #\mouse:fat-up-arrow (+ left wid//2 -7) (+ top 2) char-aluf)
	      (sheet-draw-rectangle wid 1 left (+ bar-bottom 16.) char-aluf)
	      (sheet-draw-char #\mouse:fat-down-arrow (+ left wid//2 -7) bar-bottom char-aluf))
	    ;;Draw the upper and lower gray areas
	    (let ((hei (- box-top bar-top)))
	      (tv:sheet-draw-1-bit-raster wid hei 33%-gray 0 0 nil left bar-top char-aluf erase-aluf))
	    (let ((hei (- bar-bottom box-bottom)))
	      (tv:sheet-draw-1-bit-raster wid hei 33%-gray 0 0 nil left box-bottom char-aluf erase-aluf))
	    ;;Draw the box
	    (let ((hei (- box-bottom box-top)))
	      (sheet-draw-rectangle wid hei left box-top erase-aluf)
	      (draw-hollow-rectangle self wid hei left box-top))))))))

;;to fix the scroll bar rectangle being shrunk to neglible size for moby TOC
;;and get bumped down to bottom by computations of function compute-scroll-bar-ends in 
;;mouse.lisp.
(defvar mac-scroll-bar-min-size  12.)
(defun mac-compute-scroll-bar-ends (min max visible-min visible-max window-min window-max)  
  (let* ((bar-length (- window-max window-min))
	 (bar-min (fixr (+ window-min
			   (* bar-length (if (zerop (- max min))	
					     0
					     (// (- visible-min min)
						 (float (- max min))))))))
	 (bar-max (fixr (+ window-min
			   (* bar-length (if (zerop (- max min))
					     1
					     (// (- visible-max min)
						 (float (- max min)))))))))
    (setq bar-max (min (max bar-max window-min) window-max)
	  bar-min (min (max bar-min window-min) window-max))
    ;; Make sure the bar is is big enough.
    (cond (( (- bar-max bar-min) mac-scroll-bar-min-size))
	  ((> bar-min (- visible-max mac-scroll-bar-min-size ))
	   (setq bar-min window-min
		 bar-max (+ window-min mac-scroll-bar-min-size)))
	  (t
	   (setq bar-max (min (+ bar-min mac-scroll-bar-min-size ) window-max))))
    (values bar-min bar-max)))


(defun draw-hollow-rectangle (sheet width height x-pos y-pos)
  (sheet-force-access (sheet)
    (let ((draw-x-pos (max 0 x-pos)) (draw-y-pos (max 0 y-pos))
	  (draw-height height) (draw-width width))
      (%draw-rectangle-clipped 1 draw-height draw-x-pos draw-y-pos alu-xor sheet)
      (%draw-rectangle-clipped (- draw-width 1) 1 (+ draw-x-pos 1) draw-y-pos alu-xor sheet)
      (%draw-rectangle-clipped 1 (- draw-height 1)
			       (+ draw-x-pos draw-width -1) (+ draw-y-pos 1)
			       alu-xor sheet)
      (%draw-rectangle-clipped (- draw-width 2) 1
			       (+ draw-x-pos 1) (+ draw-y-pos draw-height -1)
			       alu-xor sheet))))

(defmethod (mac-scroll-region-mouse-leaves-region mac-scroll-mixin) (region)
  ;;If the mouse button is still held down, and it's not dragging the box,
  ;;do flashy scrolling.
  (if (or (zerop (mouse-buttons :peek))
	  (eq mouse-blinker-name :box-blinker))
      (mouse-standard-blinker)
      (with-mac-scroll-region-ends (bar-top bar-bottom) region
	(let ((top (- bar-top 16.))
	      (bottom (+ bar-bottom 16.)))
	  (multiple-value-bind (x-off y-off) (sheet-calculate-offsets self mouse-sheet)
	    (ignore x-off)
	    (let ((y (- mouse-y y-off)))
	      (cond ((and (< y top) (> y (- top 32.)))	;leaving out the top
		     (mouse-warp mouse-x (+ top 10. y-off))
		     ;; Express scrolling 1 line up or down by relations of lines 0 and 1
		     (send self ':scroll-to -1 ':relative))
		    ((and ( y bottom) (< y (+ bottom 32.)))
		     (mouse-warp mouse-x (+ (- bottom 10.) y-off))
		     ;; Express scrolling 1 line up or down by relations of lines 0 and 1
		     (send self ':scroll-to 1 ':relative))
		    (T (mouse-standard-blinker)))))))))

(defmethod (mac-scroll-region-mouse-moves mac-scroll-mixin) (x y region)
  (selectq mouse-blinker-name
    (:box-blinker ;;It gets this way by a click on the box.
     (multiple-value-bind (left ignore right ignore) (margin-region-area region)
       (multiple-value-bind (cursor-width cursor-height)
	   (send mouse-blinker :size)
	 (with-mac-scroll-region-ends (bar-top bar-bottom box-top box-bottom) region
	   (let* ((box-height (- box-bottom box-top))
		  (x-off-by (- x (round (+ right left) 2)))
		  (cursor-y-offset (symeval-in-instance mouse-blinker 'y-offset))
		  (cursor-top (- y cursor-y-offset))
		  (cursor-bottom (+ cursor-top cursor-height))
		  (y-off-by (if (< cursor-top bar-top) (- cursor-top bar-top) 0)))
	     (cond ((zerop (mouse-buttons :peek))
		    (when (and ( left x) (< x right))
		      (multiple-value-bind (nil nil min-scrollable max-scrollable)
			  (send self :y-scroll-position)
			(send self :y-scroll-to
			      (round (* (- max-scrollable min-scrollable)
					(- cursor-top bar-top))
				     (- bar-bottom bar-top))
			      ':absolute)))
		    (mouse-standard-blinker))
		   ((not (and (zerop x-off-by) (zerop y-off-by)))	;recenter
		    (mouse-warp (- mouse-x x-off-by) (- mouse-y y-off-by)))
		   (( cursor-bottom bar-bottom)	;getting squashed at the bottom
		    (send mouse-blinker :set-size cursor-width (- bar-bottom cursor-top)))
		   ;;---The box blinker starts out being the size of the box.  If the last
		   ;;item is above the bottom of the window, the box is smaller than its
		   ;;max size.  It would be nice to grow the blinker in that case, when it
		   ;;is moved above its start position.  Here's where to put a cond clause
		   ;;to do it.  I ran out of steam, myself.
		   ((< cursor-bottom (min (+ cursor-top box-height) bar-bottom))
		    ;;Undo the above squash
		    (send mouse-blinker :set-size cursor-width
			  (- (min (+ cursor-top box-height) bar-bottom)
			     cursor-top)))))))))
    (otherwise
     (let ((portion (mac-scroll-region-portion region y)))
       (if portion
	   (multiple-value-bind (char x-off y-off)
	       (selectq portion
		 (:top-box (values #\mouse:up-arrow 5 0))	;skinny up arrow
		 (:upper-gray (values #\mouse:fat-up-arrow 7 0))	;fat up arrow
		 (:in-box (values #\mouse:filled-lozenge 8 9))	;flying saucer
		 (:lower-gray (values #\mouse:fat-down-arrow 7 15.))	;fat down arrow
		 (:bottom-box (values #\mouse:down-arrow 5 15.))	;skinny down arrow
		 (otherwise (values #\mouse:nw-arrow 0 0)))	;normal northwest arrow
	     (mouse-set-blinker-definition :character x-off y-off :on
					   :set-character char))
	   (mac-scroll-region-mouse-leaves-region self region))))))

(defun-in-flavor (mac-scroll-region-click-on-portion mac-scroll-mixin) (x y region mouse-char)
  (selectq (mac-scroll-region-portion region y)
    (:top-box
     (selectq (ldb (byte 2 0) (char-mouse-bits mouse-char))
       (0 (send self :scroll-to -1 :relative))
       (1 (send self :scroll-to (- (- (send self :sheet-line-count) 2)) :relative))
       (otherwise (send self :scroll-to 0 :absolute))))
    (:bottom-box
     (selectq (ldb (byte 2 0) (char-mouse-bits mouse-char))
       (0 (send self :scroll-to 1 :relative))
       (1 (send self :scroll-to (- (send self :sheet-line-count) 2) :relative))
       (otherwise (send self :scroll-to 1_30. :absolute))))
    (:upper-gray (send self :scroll-to (- (- (send self :sheet-line-count) 2))	;---
		       :relative))
    (:lower-gray (send self :scroll-to (- (send self :sheet-line-count) 2)	;---
		       :relative))
    (:in-box
     (multiple-value-bind (left ignore right ignore) (margin-region-area region)
       (let ((x-off-by (- x (round (+ right left) 2))))
	 ;;Warp the mouse to the center (in x) of the rectangle.
	 (unless (zerop x-off-by)
	   (mouse-warp (- mouse-x x-off-by) mouse-y))
	 (let ((box-top (mac-scroll-region-box-top region))
	       (box-bottom (mac-scroll-region-box-bottom region)))
	   (let ((dx (- x left x-off-by))
		 (dy (- y box-top)))
	     (mouse-set-blinker-definition :box-blinker dx dy :on
					   :set-size (- right left)
					   (- box-bottom box-top)))))))
    (otherwise ())))

(defun-in-flavor (mac-scroll-region-click-for-line-scroll mac-scroll-mixin) (y region mouse-char)
  (multiple-value-bind (ignore top ignore ignore)
      (margin-region-area region)
    (let ((here (- y top)))
      (selector mouse-char char-mouse-equal
	(#\mouse-m-1
	 ;;This line to top
	 (send self :scroll-relative here :top))
	(#\mouse-r-1
	 ;;This line to bottom
	 (send self :scroll-relative here :bottom))
	(#\mouse-m-2
	 ;;Top to this line
	 (send self :scroll-relative :top here))
	(#\mouse-r-2
	 ;;Bottom to this line
	 (send self :scroll-relative :bottom here))
	(otherwise
	  (beep))))))

(defmethod (mac-scroll-region-mouse-click mac-scroll-mixin) (x y region mouse-char)
  (ignore x)
  (if (char-mouse-equal mouse-char #\mouse-l-1)
      (mac-scroll-region-click-on-portion x y region mouse-char)
      (mac-scroll-region-click-for-line-scroll y region mouse-char)))

(defselect mac-scroll-region
  (:refresh (window region)
   (mac-scroll-region-refresh window region))
  (:mouse-moves (window region x y)
   (mac-scroll-region-mouse-moves window x y region))
  (:mouse-enters-region (window region)
   (ignore window region)
   (mouse-set-blinker-definition :character 0 0 :on :set-character #\mouse:nw-arrow))
  (:mouse-leaves-region (window region)
   (mac-scroll-region-mouse-leaves-region window region))
  (:mouse-click (window region x y button)
   (mac-scroll-region-mouse-click window x y region button))
  (:who-line-documentation-string (window region)
   (selectq mouse-blinker-name
     (:box-blinker
      "Let go of the button to put the box down here.  To abort, move quickly off the scroll bar.")
     (otherwise
      (multiple-value-bind (x y) (sheet-calculate-offsets window mouse-sheet)
	(setq x (- mouse-x x) y (- mouse-y y))
	(second (assq (mac-scroll-region-portion region y)
		      *mac-scroll-region-mouse-doc*)))))))

;this line to top
(defmethod (:new-scroll-position mac-scroll-mixin :after) (&rest ignore)
  (dolist (region region-list)
    (when (eq (margin-region-function region) 'mac-scroll-region)
      (mac-scroll-region-refresh self region))))

(defun mac-scroll-region-portion (region y &rest ignore)
  (with-mac-scroll-region-ends (bar-top bar-bottom box-top box-bottom) region
    (cond ((not (and bar-top bar-bottom box-top box-bottom))
	   ;;Perhaps not yet drawn.
	   ())
	  ((< y bar-top) :top-box)
	  ((< y box-top) :upper-gray)
	  ((< y box-bottom) :in-box)
	  ((< y bar-bottom) :lower-gray)
	  ((< y (+ bar-bottom 16.)) :bottom-box)
	  (T ()))))

(DEFFLAVOR MARGIN-CHOICE-MIXIN
	((MARGIN-CHOICES NIL))
	(MARGIN-REGION-MIXIN)
  (:INITABLE-INSTANCE-VARIABLES MARGIN-CHOICES)
  (:GETTABLE-INSTANCE-VARIABLES MARGIN-CHOICES)
  (:DOCUMENTATION :MIXIN "Provides a few boxes in the bottom margin"))

(DEFSTRUCT (CHOICE-BOX :LIST (:CONSTRUCTOR NIL))
  CHOICE-BOX-NAME
  CHOICE-BOX-STATE
  CHOICE-BOX-FUNCTION
  CHOICE-BOX-X1
  CHOICE-BOX-X2)

(DEFUN DRAW-CHOICE-BOX (SHEET X Y ON-P
			&OPTIONAL (SIZE (FONT-BLINKER-HEIGHT (SHEET-CURRENT-FONT SHEET)))
			&AUX (WIDTH (// SIZE 5)))
  (PREPARE-SHEET (SHEET)
    (LET ((CHAR-ALUF (SHEET-CHAR-ALUF SHEET))
	  (ERASE-ALUF (SHEET-ERASE-ALUF SHEET)))
      (SHEET-DRAW-RECTANGLE SIZE SIZE X Y CHAR-ALUF SHEET)
      (LET ((TEM (- SIZE (* WIDTH 2)))
	    (X1 (+ X WIDTH)) (Y1 (+ Y WIDTH)))
	(SHEET-DRAW-RECTANGLE TEM TEM X1 Y1 ERASE-ALUF SHEET)
	(AND ON-P
	     (LET ((X2 (+ X1 TEM)) (Y2 (+ Y1 TEM)))
	       ;; This is a diagonal hexagon
	       (SHEET-DRAW-TRIANGLE (1- X2) Y1 (1+ X1) Y2 X1 (1- Y2) CHAR-ALUF SHEET)
	       (SHEET-DRAW-TRIANGLE (1- X2) Y1 X2 Y1 X2 (1+ Y1) CHAR-ALUF SHEET)
	       (SHEET-DRAW-TRIANGLE (1- X2) Y1 X2 (1+ Y1) (1+ X1) Y2 CHAR-ALUF SHEET)
	       (SHEET-DRAW-TRIANGLE (1+ X1) Y2 X1 Y2 X1 (1- Y2) CHAR-ALUF SHEET)
	       ;; So is this
	       (SHEET-DRAW-TRIANGLE (1+ X1) Y1 X2 (1- Y2) (1- X2) Y2 CHAR-ALUF SHEET)
	       (SHEET-DRAW-TRIANGLE X2 (1- Y2) X2 Y2 (1- X2) Y2 CHAR-ALUF SHEET)
	       (SHEET-DRAW-TRIANGLE (1- X2) Y2 X1 (1+ Y1) (1+ X1) Y1 CHAR-ALUF SHEET)
	       (SHEET-DRAW-TRIANGLE X1 (1+ Y1) X1 Y1 (1+ X1) Y1 CHAR-ALUF SHEET)
	       )))))
  (VALUES (+ X SIZE) Y))

(DEFMETHOD (:INIT-REGION-LIST MARGIN-CHOICE-MIXIN :BEFORE) (IGNORE)
  (PUSH (LIST 'MARGIN-CHOICE-REGION ':BOTTOM
	      (IF (NULL MARGIN-CHOICES) 0 (1+ (SHEET-LINE-HEIGHT SUPERIOR)))
	      0 0 0 0)
	REGION-LIST))

(DEFMETHOD (:SET-MARGIN-CHOICES MARGIN-CHOICE-MIXIN) (NEW-MARGIN-CHOICES)
  (SETQ MARGIN-CHOICES NEW-MARGIN-CHOICES)
  (LET ((REGION (ASSQ 'MARGIN-CHOICE-REGION REGION-LIST))
	(SIZE (IF (NULL MARGIN-CHOICES) 0 (1+ (SHEET-LINE-HEIGHT SUPERIOR)))))
    (COND ((= (MARGIN-REGION-SIZE REGION) SIZE)
	   (SHEET-FORCE-ACCESS (SELF T)
	     (MARGIN-CHOICE-REGION ':REFRESH SELF REGION T)))
	  (T
	   (SETF (MARGIN-REGION-SIZE REGION) SIZE)
	   (SEND SELF ':REDEFINE-MARGINS (LIST NIL ':REGION-LIST REGION-LIST))))))

(DEFUN HANDLE-CHOICE-BUTTON (WINDOW BOXES X Y THING &AUX CHOSEN)
  (IF (SETQ CHOSEN (DOLIST (BOX BOXES)
		     (AND ( X (CHOICE-BOX-X1 BOX))
			  (< X (CHOICE-BOX-X2 BOX))
			  (RETURN BOX))))
      (PROCESS-RUN-FUNCTION "Choice" (CHOICE-BOX-FUNCTION CHOSEN) WINDOW CHOSEN THING Y)
      (BEEP)))

(DEFSELECT MARGIN-CHOICE-REGION
  (:REFRESH (WINDOW REGION &OPTIONAL ERASE-P)
     (UNLESS (ZEROP (MARGIN-REGION-SIZE REGION))
       (REFRESH-MARGIN-CHOICE-REGION WINDOW REGION ERASE-P)))
  (:MOUSE-MOVES (&REST IGNORE))
  (:MOUSE-ENTERS-REGION (WINDOW &REST IGNORE)
     ;; use a vertical arrow when the mouse enters a margin-choice region
     (MOUSE-SET-BLINKER-DEFINITION-INTERNAL
       (SHEET-MOUSE WINDOW) :CHARACTER 4. 0.
       :ON :SET-CHARACTER #\MOUSE:UP-ARROW))
  (:MOUSE-LEAVES-REGION (WINDOW &REST IGNORE) 
     ;; when it leaves the region, let the window it goes to decide 
     (MOUSE-STANDARD-BLINKER WINDOW))
  (:MOUSE-CLICK (WINDOW REGION X Y IGNORE)
     (HANDLE-CHOICE-BUTTON WINDOW (SEND WINDOW :MARGIN-CHOICES) X Y REGION))
  (:WHO-LINE-DOCUMENTATION-STRING (WINDOW IGNORE)
     (LET ((X (SHEET-MOUSE-POSITION WINDOW)))
       (DOLIST (BOX (SEND WINDOW :MARGIN-CHOICES))
	 (AND ( X (CHOICE-BOX-X1 BOX))
	      (< X (CHOICE-BOX-X2 BOX))
 	      (RETURN "Any button to select choice."))))))

(DEFMETHOD (REFRESH-MARGIN-CHOICE-REGION MARGIN-CHOICE-MIXIN) (REGION ERASE-P)
  (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
      (MARGIN-REGION-AREA REGION)
  (PREPARE-SHEET (SELF)
    (AND ERASE-P
	 (SHEET-DRAW-RECTANGLE (- RIGHT LEFT) (- BOTTOM TOP) LEFT TOP ERASE-ALUF))
    (SHEET-DRAW-RECTANGLE (- RIGHT LEFT) 1 LEFT TOP CHAR-ALUF))
  (SETQ TOP (+ TOP 2))
  ;; Note: As far as I can tell, this code is unguarded against the possiblity that a
  ;; string furnished as a margin choice is too long for the space allotted to it.  In
  ;; changing this code to center each margin choice string/box, I haven't done anything
  ;; about this; it needs deeper investigation.  -- Dodds, 1/19/87 14:16:52
  ;; Note: Doug was right.  The :setup method now makes sure that there is
  ;; enough space, per SGD's request via joseph. -- Cassels, 10/8/87
  (LOOP WITH SHARE = (AND MARGIN-CHOICES (// (- RIGHT LEFT) (LENGTH MARGIN-CHOICES)))
	FOR CHOICE IN MARGIN-CHOICES
	AS X FIRST LEFT THEN (+ X SHARE)
	;; subtract CHAR-WIDTH for the space between the name and the choice box;
	;; subtract (FONT-BLINKER-HEIGHT CURRENT-FONT) because it's the width (as
	;; well as height) of the choice box.
	AS X0 = (+ X (MAX 0 (// (- SHARE (SEND SELF :STRING-LENGTH (CHOICE-BOX-NAME CHOICE))
				   CHAR-WIDTH
				   (FONT-BLINKER-HEIGHT CURRENT-FONT))
				2)))
	DO (SETQ X0 (+ (SEND SELF ':STRING-OUT-EXPLICIT (CHOICE-BOX-NAME CHOICE)
			     X0 TOP RIGHT CHAR-ALUF)
		       CHAR-WIDTH))
	   (SETF (CHOICE-BOX-X1 CHOICE) X0)
	   (SETF (CHOICE-BOX-X2 CHOICE) (DRAW-CHOICE-BOX SELF X0 TOP
				   (CHOICE-BOX-STATE CHOICE)
				   (FONT-BLINKER-HEIGHT CURRENT-FONT))))))

;;;
;;; Menus in the margin.  An alternative to margin-choices.  (Note that, just as 
;;; menu-margin-choice-mixin is a special case of margin-choices for menus, you'd better
;;; use menu-margin-menu-mixin instead if the window you're mixing this into is a menu.
;;; Menu-margin-menu-mixin makes sure the :execute of the chosen item happens in the
;;; right process; margin-menu-mixin just spins off a choice process.)
;;;

(DEFFLAVOR MARGIN-MENU-MIXIN
	;; margin-menu-items is a list of structures, each of which contains
	;; a menu item.  The structure gives us extra slots in which to keep notes
	;; about its position and so on.
	;; current-margin-menu-item is what's currently got a box around it.
	((MARGIN-MENU-ITEMS NIL) (CURRENT-MARGIN-MENU-ITEM NIL))
	;; this wants to :execute menu items, and
	;; messes with a region in the bottom margin
	;; (have to be in this order, otherwise can't mix in with basic-menu)
	(MARGIN-REGION-MIXIN MENU-EXECUTE-MIXIN)
  (:INIT-KEYWORDS :MARGIN-MENU-ITEM-LIST)
  (:DOCUMENTATION :MIXIN "Provides a few menu choices in the bottom margin."))

(DEFMETHOD (:INIT-REGION-LIST MARGIN-MENU-MIXIN :BEFORE) (IGNORE)
  "Push something on region-list that represents the entire margin-menu."
  ;; this is really instantiating a margin-region defstruct.  Sigh.
  ;; It looks like (function margin size left top right bottom)
  (PUSH (LIST 'MARGIN-MENU-REGION :BOTTOM
	      (IF (NULL MARGIN-MENU-ITEMS)
		  0
		  (+ (SHEET-LINE-HEIGHT SUPERIOR) 2.)) ;for blinker
	      0 0 0 0)
	REGION-LIST))

(DEFUN-IN-FLAVOR (FIND-MARGIN-MENU-REGION MARGIN-MENU-MIXIN) ()
  "Find the margin-region associated with the margin-menu (there's only one such)."
  (ASSOC 'MARGIN-MENU-REGION REGION-LIST))

(DEFUN MENU-ITEM-SELECTABLE-P (ITEM)
  "Whether or not this menu-item is selectable."
  ;; cribbed from  :mouse-moves of basic-menu
  (OR (ATOM ITEM) (ATOM (CDR ITEM)) (ATOM (CDDR ITEM))
      (NEQ (CADR ITEM) :NO-SELECT)))

(DEFUN-IN-FLAVOR (MARGIN-MENU-ITEM-INITIAL-STATE MARGIN-MENU-MIXIN) (ITEM)
  "Find out whether or not this item should be initially reverse-video'd."
  (AND (LISTP ITEM) (LISTP (CDR ITEM))
       (GET (CDDR ITEM) :INITIAL-STATE)))

(CL:DEFSTRUCT MARGIN-MENU-ITEM
  ;; remember horizontal position assigned to this item, and its width.
  ;; state is for a future extension like menu-highlighting mixin
  ITEM LEFT-EDGE RIGHT-EDGE WIDTH STATE)

(DEFUN-IN-FLAVOR (CONSTRUCT-MARGIN-MENU-ITEMS MARGIN-MENU-MIXIN) (MARGIN-MENU-ITEM-LIST)
  "Construct the defstructs out of the menu-items."
  (SETQ MARGIN-MENU-ITEMS
	(LOOP FOR ITEM IN MARGIN-MENU-ITEM-LIST
	      COLLECTING (MAKE-MARGIN-MENU-ITEM
			   :ITEM ITEM
			   :STATE (MARGIN-MENU-ITEM-INITIAL-STATE ITEM)))))

;;; The following 2 items are cribbed from basic-menu.  If they were defuns
;;; instead of defun-in-flavors on basic-menu, we could have shared code.  However,
;;; the versions on basic-menu now refer to instance variables (hightlighting style).
;;; So, since this doesn't always co-exist with basic-menu, we need to duplicate them.
						
;;; These understand the mapping between an item and its printed representation
;;; This attempts to win with fat strings by looking at the first character of the string.
;;; It should really return the largest font of the string.
(DEFUN-IN-FLAVOR (MARGIN-MENU-ITEM-STRING MARGIN-MENU-MIXIN)
		 (ITEM &AUX STRING FONT STYLE UNDERSCORE)
  (DECLARE (VALUES STRING FONT UNDERSCORE))
  (COND ((ATOM ITEM) (SETQ STRING ITEM))
	(T (SETQ STRING (CAR ITEM))
	   (WHEN (LISTP (CDR ITEM))
	     (SETQ FONT (GET (CDDR ITEM) ':FONT))  ;; Support :FONT for compatibility.
	     (SETQ STYLE (GET (CDDR ITEM) ':STYLE))
	     (SETQ UNDERSCORE (GET (CDDR ITEM) ':UNDERSCORE)))))
  (SETQ STRING (STRING STRING))
  (COND ((AND FONT STYLE)
	 (FERROR "Illegal to specify both :FONT and :STYLE (in ~S)" ITEM))
	((AND (NULL STYLE) (NULL FONT))
	 (SETQ STYLE SI:*NULL-STYLE*))
	((NUMBERP FONT)
	 (FERROR "In item ~S: it is no longer supported for :FONT to be a number.  Specify ~
		  a style instead."))
	((NULL STYLE)
	 (SETQ STYLE (SI:BACKTRANSLATE-FONT FONT DISPLAY-DEVICE-TYPE))))
  (VALUES STRING STYLE UNDERSCORE))

(DEFUN-IN-FLAVOR (MARGIN-MENU-ITEM-STRING-WIDTH MARGIN-MENU-MIXIN) (ITEM &OPTIONAL STOP-X)
  (MULTIPLE-VALUE-BIND (STRING STYLE)
      (MARGIN-MENU-ITEM-STRING ITEM)
    ;; defend against menus that want Jess.Roman.Large
    (WITH-CHARACTER-STYLE ((SI:MERGE-CHARACTER-STYLES STYLE *DEFAULT-STYLE*) SELF)
      (SEND SELF ':STRING-LENGTH STRING 0 NIL STOP-X))))

(DEFUN-IN-FLAVOR (COMPUTE-MARGIN-MENU-ITEM-POSITIONS MARGIN-MENU-MIXIN)
		 (&AUX MARGIN-WIDTH MARGIN-HEIGHT CHOICES-WIDTH)
  (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
      (MARGIN-REGION-AREA (FIND-MARGIN-MENU-REGION))
    ;; figure out how big the margin is
    (SETQ MARGIN-WIDTH (- RIGHT LEFT) MARGIN-HEIGHT (- BOTTOM TOP))
    (IGNORE MARGIN-HEIGHT)
    ;; compute the width of each item, as well as total width
    (SETQ CHOICES-WIDTH
	  (LOOP FOR DESCRIPTOR IN MARGIN-MENU-ITEMS
		FOR DESCRIPTOR-WIDTH = (MARGIN-MENU-ITEM-STRING-WIDTH
					 (MARGIN-MENU-ITEM-ITEM DESCRIPTOR))
		DOING (SETF (MARGIN-MENU-ITEM-WIDTH DESCRIPTOR) DESCRIPTOR-WIDTH)
		SUMMING DESCRIPTOR-WIDTH))
    (WHEN (> CHOICES-WIDTH MARGIN-WIDTH)
      ;; a more drastic option would be to start trunctating the longer items here
      (FSIGNAL "The window ~S is too narrow to contain its margin-menu." SELF))
    ;; allocate whitespace evenly between choices, half a share on each edge
    (LOOP WITH WHITESPACE-WIDTH = (// (- MARGIN-WIDTH CHOICES-WIDTH)
				      (LENGTH MARGIN-MENU-ITEMS))
	  FOR HORIZONTAL-POSITION FROM (+ LEFT (// WHITESPACE-WIDTH 2.))
				  BY WHITESPACE-WIDTH
	  FOR DESCRIPTOR IN MARGIN-MENU-ITEMS
	  DOING
      ;; big ones get a lot of space, little ones not much
      (SETF (MARGIN-MENU-ITEM-LEFT-EDGE  DESCRIPTOR) HORIZONTAL-POSITION)
      (INCF HORIZONTAL-POSITION (MARGIN-MENU-ITEM-WIDTH DESCRIPTOR))
      (SETF (MARGIN-MENU-ITEM-RIGHT-EDGE DESCRIPTOR) HORIZONTAL-POSITION))))

(DEFMETHOD (MAKE-INSTANCE MARGIN-MENU-MIXIN :AFTER)
	   (&KEY MARGIN-MENU-ITEM-LIST &ALLOW-OTHER-KEYS)
  (CONSTRUCT-MARGIN-MENU-ITEMS MARGIN-MENU-ITEM-LIST))

(DEFMETHOD (:SET-MARGIN-MENU-ITEM-LIST MARGIN-MENU-MIXIN) (NEW-ITEM-LIST)
  (CONSTRUCT-MARGIN-MENU-ITEMS NEW-ITEM-LIST)
  (COMPUTE-MARGIN-MENU-ITEM-POSITIONS)
  ;; Inform the mouse.  If we're the current mouse window, it'll call us back.
  (WHEN EXPOSED-P (MOUSE-WAKEUP (SHEET-MOUSE SELF))))

(DEFUN-IN-FLAVOR (INSIDE-MARGIN-MENU-REGION-P MARGIN-MENU-MIXIN) (X Y)
  "T if (x, y) is inside the margin-menu-region."
  (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
      (MARGIN-REGION-AREA (FIND-MARGIN-MENU-REGION))
    (AND ( LEFT X RIGHT) ( TOP Y BOTTOM))))

(DEFUN-IN-FLAVOR (MARGIN-MENU-ITEM-AT-X MARGIN-MENU-MIXIN) (X Y)
  "Return the descriptor of the margin-menu item at x, or nil."
  ;; x is in outside coordinates relative to the window, e.g.,
  ;; (- tv:mouse-x (tv:sheet-calculate-offsets self mouse-sheet))
  (WHEN (AND (INSIDE-MARGIN-MENU-REGION-P X Y)
	     (SOME MARGIN-MENU-ITEMS
		   #'(LAMBDA (X) (MENU-ITEM-SELECTABLE-P (MARGIN-MENU-ITEM-ITEM X)))))
    ;; ok, we're inside the region and there are some selectable margin-menu-items
    (LOOP WITH NEAREST-ITEM = (FIRST MARGIN-MENU-ITEMS)
	  WITH DISTANCE-TO-NEAREST-ITEM =
	    (MIN (ABS (- X (MARGIN-MENU-ITEM-LEFT-EDGE NEAREST-ITEM)))
		 (ABS (- X (MARGIN-MENU-ITEM-RIGHT-EDGE NEAREST-ITEM))))
	  FOR NEXT-ITEM IN (CDR MARGIN-MENU-ITEMS)
	  FOR DISTANCE-TO-NEXT-ITEM =
	      (MIN (ABS (- X (MARGIN-MENU-ITEM-LEFT-EDGE NEXT-ITEM)))
		   (ABS (- X (MARGIN-MENU-ITEM-RIGHT-EDGE NEXT-ITEM))))
	  IF (AND ( X (MARGIN-MENU-ITEM-LEFT-EDGE  NEXT-ITEM))
		  (< X (MARGIN-MENU-ITEM-RIGHT-EDGE NEXT-ITEM)))
	    RETURN 
	      ;; the mouse is inside this item; return it or NIL
	      (WHEN (MENU-ITEM-SELECTABLE-P (MARGIN-MENU-ITEM-ITEM NEXT-ITEM))
		;; this item is selectable
		NEXT-ITEM)
	  ELSE IF (< DISTANCE-TO-NEXT-ITEM DISTANCE-TO-NEAREST-ITEM)
		 ;; this item is nearer than the previous candidate
		 DO (SETQ NEAREST-ITEM NEXT-ITEM
			  DISTANCE-TO-NEAREST-ITEM DISTANCE-TO-NEXT-ITEM)
	  FINALLY (IF (MENU-ITEM-SELECTABLE-P (MARGIN-MENU-ITEM-ITEM NEAREST-ITEM))
		      ;; if what we caught was selectable, take it
		      (RETURN NEAREST-ITEM)))))

(DEFMETHOD (MARGIN-MENU-DESCRIPTOR-UNDER-MOUSE MARGIN-MENU-MIXIN) ()
  "Return the descriptor of the margin-menu item under the mouse, or nil."
  (MULTIPLE-VALUE-BIND (X Y)
      (SHEET-MOUSE-POSITION SELF)
    (MARGIN-MENU-ITEM-AT-X X Y)))

(DEFUN-IN-FLAVOR (DRAW-MARGIN-MENU-ITEM-BOX MARGIN-MENU-MIXIN) (DESCRIPTOR REGION)
  "Draws a box around descriptor."
  (MULTIPLE-VALUE-BIND (IGNORE TOP IGNORE BOTTOM)
      ;; figure out how big the margin area is
      (MARGIN-REGION-AREA REGION)
    (LET ((LEFT  (MARGIN-MENU-ITEM-LEFT-EDGE  DESCRIPTOR))
	  (RIGHT (MARGIN-MENU-ITEM-RIGHT-EDGE DESCRIPTOR))
	  (FLIP-ALU (GRAPHICS::STANDARDIZE-ALU SELF :FLIP)))
      ;; back off a pixel ("I don' wanna pixel; just wanna to ride my motorcycle.")
      (INCF TOP 2.) (DECF BOTTOM) ;top gets 1 line whitespace + the border-line
      (DECF LEFT) (INCF RIGHT)
      (PREPARE-SHEET (SELF)
	;; Draw rectangle (top edge, right edge, bottom edge, left edge)
	(SHEET-DRAW-LINE LEFT  TOP    RIGHT TOP    FLIP-ALU NIL)
	(SHEET-DRAW-LINE RIGHT TOP    RIGHT BOTTOM FLIP-ALU NIL)
	(SHEET-DRAW-LINE RIGHT BOTTOM LEFT  BOTTOM FLIP-ALU NIL)
	(SHEET-DRAW-LINE LEFT  BOTTOM LEFT  TOP    FLIP-ALU NIL)))))

(DEFMETHOD (CLEAR-CURRENT-MARGIN-MENU-ITEM MARGIN-MENU-MIXIN) (REGION)
  "As though the mouse just left the region."
  (WHEN CURRENT-MARGIN-MENU-ITEM
    ;; if there's one already highlighted, unbox it.
    (DRAW-MARGIN-MENU-ITEM-BOX CURRENT-MARGIN-MENU-ITEM REGION)
    (SETQ CURRENT-MARGIN-MENU-ITEM NIL)))

(DEFMETHOD (UPDATE-CURRENT-MARGIN-MENU-ITEM MARGIN-MENU-MIXIN) (REGION)
  "Takes care of the `blinker' and updates item under mouse."
  (CLEAR-CURRENT-MARGIN-MENU-ITEM SELF REGION)
  (LET ((TARGET (MARGIN-MENU-DESCRIPTOR-UNDER-MOUSE SELF)))
    (WHEN TARGET
      ;; found one under the mouse, box it and remember it
      (SETQ CURRENT-MARGIN-MENU-ITEM TARGET)
      (DRAW-MARGIN-MENU-ITEM-BOX CURRENT-MARGIN-MENU-ITEM REGION))))

(DEFMETHOD (:REFRESH MARGIN-MENU-MIXIN :AFTER) (&REST IGNORE)
  "Re-draw the `blinker' if a :refresh just trashed it."
  (WHEN CURRENT-MARGIN-MENU-ITEM
    ;; there was a `blinker'
    (DRAW-MARGIN-MENU-ITEM-BOX CURRENT-MARGIN-MENU-ITEM
			       (FIND-MARGIN-MENU-REGION))))

(DEFMETHOD (REFRESH-MARGIN-MENU-REGION MARGIN-MENU-MIXIN)
	   (REGION ERASE-P &AUX MARGIN-WIDTH MARGIN-HEIGHT)
  "Re-draw the margin-menu."
  (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
      (MARGIN-REGION-AREA REGION)
    (SETQ MARGIN-WIDTH (- RIGHT LEFT) MARGIN-HEIGHT (- BOTTOM TOP))
    ;; first, clear out the margin-region
    (PREPARE-SHEET (SELF)
      (AND ERASE-P
	   ;; clear the entire margin-menu if that's what was asked for
	   (SHEET-DRAW-RECTANGLE MARGIN-WIDTH MARGIN-HEIGHT LEFT TOP ERASE-ALUF))
      ;; draw a horizontal line at the top of the region
      (SHEET-DRAW-LINE LEFT TOP RIGHT TOP CHAR-ALUF T))
    (SETQ TOP (+ TOP 3)) ;top border, whitespace line, and blinker
    (COMPUTE-MARGIN-MENU-ITEM-POSITIONS)
    (LOOP FOR DESCRIPTOR IN MARGIN-MENU-ITEMS
	  DO
      (MULTIPLE-VALUE-BIND (STRING STYLE)
	  (MARGIN-MENU-ITEM-STRING (MARGIN-MENU-ITEM-ITEM DESCRIPTOR))
	;; menus would override this to Jess.Roman.Large, so we
	;; restore it to Fix.Roman.Normal here
	(SETQ STYLE (SI:MERGE-CHARACTER-STYLES STYLE *DEFAULT-STYLE*))
	(WITH-CHARACTER-STYLE (STYLE SELF)
	  (SEND SELF :STRING-OUT-EXPLICIT STRING 
		(MARGIN-MENU-ITEM-LEFT-EDGE DESCRIPTOR)
		TOP
		(MARGIN-MENU-ITEM-RIGHT-EDGE DESCRIPTOR)
		CHAR-ALUF)))))
  (UPDATE-CURRENT-MARGIN-MENU-ITEM SELF REGION))

(DEFMETHOD (HANDLE-MARGIN-MENU-CLICK MARGIN-MENU-MIXIN) (REGION X Y)
  "Spin off a process in which to do the :execute."
  ;; Keep the application out of the Mouse Process!
  (IGNORE REGION Y)
  (LET ((VICTIM (MARGIN-MENU-ITEM-AT-X X Y)))
    (COND (VICTIM
	    ;; found a menu item where he clicked; run the item,
	    ;; but not in the mouse process!  (see menu-margin-menu-mixin
	    ;; below to see how we get the :choose-ing process to do this!)
	    (PROCESS-RUN-FUNCTION "Margin Menu Choice"
	      #'(LAMBDA ()
		  (SEND SELF :EXECUTE (MARGIN-MENU-ITEM-ITEM VICTIM)))))
	  (T
	    ;; no such item
	    (BEEP)))))

(DEFSELECT MARGIN-MENU-REGION
  (:REFRESH (WINDOW REGION &OPTIONAL ERASE-P)
     (UNLESS (ZEROP (MARGIN-REGION-SIZE REGION))
       (REFRESH-MARGIN-MENU-REGION WINDOW REGION ERASE-P)))
  (:MOUSE-MOVES (WINDOW REGION X Y)
     (IGNORE X Y)
     (UPDATE-CURRENT-MARGIN-MENU-ITEM WINDOW REGION))
  (:MOUSE-ENTERS-REGION (WINDOW REGION)
     ;; draw rectangle and use menu cross-hairs
     (MOUSE-SET-BLINKER-DEFINITION ':CHARACTER 4 5 ':ON ':SET-CHARACTER #\MOUSE:TIMES)
     (UPDATE-CURRENT-MARGIN-MENU-ITEM WINDOW REGION))
  (:MOUSE-LEAVES-REGION (WINDOW REGION)
     ;; undraw rectangle and let somebody decide the mouse-blinker
     (MOUSE-STANDARD-BLINKER)
     (CLEAR-CURRENT-MARGIN-MENU-ITEM WINDOW REGION))
  (:MOUSE-CLICK (WINDOW REGION X Y IGNORE)
     (HANDLE-MARGIN-MENU-CLICK WINDOW REGION X Y))
  (:WHO-LINE-DOCUMENTATION-STRING (WINDOW IGNORE)
     (LET ((TARGET (MARGIN-MENU-DESCRIPTOR-UNDER-MOUSE WINDOW)))
       (AND TARGET
	    (MENU-ITEM-WHO-LINE-DOCUMENTATION (MARGIN-MENU-ITEM-ITEM TARGET))))))

(DEFFLAVOR MENU-MARGIN-MENU-MIXIN () (MARGIN-MENU-MIXIN)
  (:REQUIRED-FLAVORS BASIC-MENU))

(DEFMETHOD (HANDLE-MARGIN-MENU-CLICK MENU-MARGIN-MENU-MIXIN) (REGION X Y)
  "Notify the parent menu of the choice; let it do the :execute in its own process."
  (IGNORE REGION Y)
  (LET ((VICTIM (MARGIN-MENU-ITEM-AT-X X Y)))
    (COND (VICTIM
	    ;; found a menu item where he clicked; suffices
	    ;; to notify the parent menu of this fact.  The :choose-ing
	    ;; process is looking for this to become non-NIL
	    (SETQ TV:CHOSEN-ITEM (MARGIN-MENU-ITEM-ITEM VICTIM)))
	  (T
	    ;; no such item
	    (BEEP)))))

(DEFFLAVOR BASIC-MULTIPLE-CHOICE ()
	   (MULTIPLE-CHOICE-MIXIN
	    DISPLAYED-ITEMS-TEXT-SCROLL-WINDOW
	    SCROLL-STUFF-ON-OFF-MIXIN MARGIN-CHOICE-MIXIN))

(DEFFLAVOR MULTIPLE-CHOICE () (BORDERS-MIXIN TOP-BOX-LABEL-MIXIN BASIC-MULTIPLE-CHOICE
			       WINDOW))

(DEFVAR *HIGHLIGHT-MULTIPLE-CHOICE-ITEM* T)
(DEFVAR *MULTIPLE-CHOICE-HIGHLIGHTING-CHARACTER* #/.)

(DEFFLAVOR MULTIPLE-CHOICE-MIXIN
	((ITEM-NAME NIL)
	 (CHOICE-TYPES NIL)
	 (MARGIN-CHOICES DEFAULT-FINISHING-CHOICES)
	 (CHOICE-VALUE)
	 (BOX-TEMPLATES NIL)
	 (NORMAL-BLINKER NIL)
	 (NORMAL-BLINKER-STYLE '(NIL NIL NIL))
	 (SELECTED-BLINKER NIL)
	 (SELECTED-BLINKER-STYLE '(NIL :BOLD NIL))
	 (HIGHLIGHTING-CHARACTER *MULTIPLE-CHOICE-HIGHLIGHTING-CHARACTER*)
	 (BLINKER-STRING NIL)
	 (LAST-ITEM NIL))
	()
  (:REQUIRED-FLAVORS
   SCROLL-STUFF-ON-OFF-MIXIN MARGIN-CHOICE-MIXIN DISPLAYED-ITEMS-TEXT-SCROLL-WINDOW)
  (:SETTABLE-INSTANCE-VARIABLES ITEM-NAME HIGHLIGHTING-CHARACTER)
  (:INITABLE-INSTANCE-VARIABLES
   HIGHLIGHTING-CHARACTER NORMAL-BLINKER-STYLE SELECTED-BLINKER-STYLE)
  (:INIT-KEYWORDS :CHOICES)
  (:DEFAULT-INIT-PLIST :BLINKER-P NIL :MORE-P NIL :SCROLL-BAR 2))

(DEFWHOPPER (:INIT MULTIPLE-CHOICE-MIXIN) (&REST ARGS)
  (PROG1
    (LEXPR-CONTINUE-WHOPPER ARGS)
    (SETQ NORMAL-BLINKER-STYLE
	    (SI:MERGE-CHARACTER-STYLES NORMAL-BLINKER-STYLE DEFAULT-STYLE)
	  SELECTED-BLINKER-STYLE
	    (SI:MERGE-CHARACTER-STYLES SELECTED-BLINKER-STYLE DEFAULT-STYLE))
    (SETQ BLINKER-STRING (MAKE-ARRAY 100. :TYPE 'ART-FAT-STRING
				     :FILL-POINTER 0 :INITIAL-VALUE HIGHLIGHTING-CHARACTER)
	  NORMAL-BLINKER (MAKE-BLINKER SELF 'STRING-BLINKER
				       :STYLE NORMAL-BLINKER-STYLE :STRING "")
	  SELECTED-BLINKER (MAKE-BLINKER SELF 'STRING-BLINKER
					 :STYLE SELECTED-BLINKER-STYLE :STRING ""))))

(DEFMETHOD (:SET-NORMAL-BLINKER-STYLE MULTIPLE-CHOICE-MIXIN :AFTER) (CHAR-STYLE)
  (SETQ NORMAL-BLINKER-STYLE (SI:MERGE-CHARACTER-STYLES CHAR-STYLE DEFAULT-STYLE)))

(DEFMETHOD (:SET-SELECTED-BLINKER-STYLE MULTIPLE-CHOICE-MIXIN :AFTER) (CHAR-STYLE)
  (SETQ SELECTED-BLINKER-STYLE (SI:MERGE-CHARACTER-STYLES CHAR-STYLE DEFAULT-STYLE)))

(DEFMETHOD (:MOUSE-MOVES MULTIPLE-CHOICE :AFTER) (IGNORE Y)
  (WHEN *HIGHLIGHT-MULTIPLE-CHOICE-ITEM*
    (LET* ((LINE-NO (SHEET-LINE-NO NIL Y))
	   (INDEX (+ TOP-ITEM LINE-NO))
	   (THIS-ITEM (AND ( INDEX 0)
			   (< INDEX (FILL-POINTER ITEMS))
			   (AREF ITEMS INDEX)))
	   ;; This can work even if THIS-ITEM is NIL.
	   (THIS-ITEM-NAME (CHOICE-ITEM-NAME THIS-ITEM)))
      (IF (AND ( Y (SHEET-INSIDE-TOP))
	       (< Y (+ (SHEET-INSIDE-TOP) (* (SHEET-NUMBER-OF-INSIDE-LINES)
					     LINE-HEIGHT)))
	       (NOT (NULL THIS-ITEM)))
       	  ;; Only do this if we've changed what line we're on.  This
	  ;; prevents excessive flashing.
	  (WHEN (NEQ LAST-ITEM THIS-ITEM)
	    (SETQ LAST-ITEM THIS-ITEM)
	    ;; Make the constant string be the right size.  Presumably
	    ;; this could be optimized so it didn't have to do this all the time.
	    (LET* (;;--- Really, this should be sending the menu a :STRING-LENGTH message
		   ;;--- for both the selected and normal styles, and maximizing that,
		   ;;--- and converting the pixel result to characters.  Note that if
		   ;;--- the font is fixed-width, we can just use STRING-LENGTH (which
		   ;;--- is much faster), and we can also get away with only sending
		   ;;--- :STRING-LENGTH to the selected-style if the normal-style and
		   ;;--- the selected-style have (roughly) the same character width.
		   (MAX (LOOP FOR ITEM BEING THE ARRAY-ELEMENTS OF ITEMS
			      MAXIMIZE (STRING-LENGTH (CHOICE-ITEM-NAME ITEM))))
		   ;; Multiple choice windows automatically add two spaces
		   ;; to the end of the string.
		   (MAX (+ 2 MAX))
		   (STOP-X (LET ((BOX (FIRST (LAST (CHOICE-ITEM-BOXES THIS-ITEM)))))
			     (IF BOX (- (CHOICE-BOX-X1 BOX) CHAR-WIDTH)
				 (SHEET-INSIDE-WIDTH))))
		   (NORMAL-CUTOFF
		     (MULTIPLE-VALUE-BIND (NIL END)
			 (SEND SELF :STRING-LENGTH THIS-ITEM-NAME 0 NIL STOP-X NORMAL-BLINKER-STYLE)
		       END)))
	      (WHEN (> MAX (ARRAY-LENGTH BLINKER-STRING))
		(SETQ BLINKER-STRING
		      (MAKE-ARRAY MAX :TYPE 'ART-FAT-STRING
				  :FILL-POINTER 0
				  :INITIAL-VALUE HIGHLIGHTING-CHARACTER)))
	      (SETF (FILL-POINTER BLINKER-STRING) MAX)
	      ;; Must turn the blinkers off, else they XOR wrong.
	      ;;--- THIS-ITEM-NAME really needs to have NORMAL-BLINKER-STYLE
	      ;;--- merged into it, sort of like the code below...
	      (SEND NORMAL-BLINKER :SET-VISIBILITY NIL)
	      (SEND SELECTED-BLINKER :SET-VISIBILITY NIL)
	      (SEND NORMAL-BLINKER :SET-STRING
				   THIS-ITEM-NAME 0 NORMAL-CUTOFF NORMAL-BLINKER-STYLE)
	      ;; Copy the newly selected item into the blinker-string, including
	      ;; the trailing "dots".  Make sure the char-styles are right, too.
	      (FLET ((COERCE-STYLE (CHAR NEW-STYLE)
		       (LET* ((OLD (SI:INDEX-CHARACTER-STYLE (SI:CHAR-STYLE-INDEX CHAR)))
			      (NEW (SI:MERGE-CHARACTER-STYLES NEW-STYLE OLD)))
			 (SETF (SI:CHAR-STYLE-INDEX CHAR) (SI:STYLE-INDEX NEW T))
			 CHAR)))
		(LET ((FROM THIS-ITEM-NAME)
		      (TO BLINKER-STRING))
		  (DECLARE (SYS:ARRAY-REGISTER FROM) (SYS:ARRAY-REGISTER TO))
		  (LOOP FOR I BELOW (STRING-LENGTH THIS-ITEM-NAME)
			DO (SETF (AREF TO I)
				 (COERCE-STYLE (AREF FROM I) SELECTED-BLINKER-STYLE))
			FINALLY (LOOP WITH FILL = (COERCE-STYLE HIGHLIGHTING-CHARACTER
								SELECTED-BLINKER-STYLE)
				      FOR J FROM I BELOW (ARRAY-ACTIVE-LENGTH BLINKER-STRING)
				      DO (SETF (AREF TO J) FILL)))))
	      (LET ((HIGHLIGHT-CUTOFF
		      (MULTIPLE-VALUE-BIND (NIL END)
			 (SEND SELF :STRING-LENGTH BLINKER-STRING 0 NIL STOP-X SELECTED-BLINKER-STYLE)
		       END)))
		(SEND SELECTED-BLINKER :SET-STRING BLINKER-STRING
						   0 HIGHLIGHT-CUTOFF NIL)) ;SELECTED-BLINKER-STYLE
	      (BLINKER-SET-CURSORPOS NORMAL-BLINKER 0 (* LINE-NO LINE-HEIGHT))
	      (BLINKER-SET-CURSORPOS SELECTED-BLINKER 0 (* LINE-NO LINE-HEIGHT))
	      (SEND NORMAL-BLINKER :SET-VISIBILITY T)
	      (SEND SELECTED-BLINKER :SET-VISIBILITY T)))
	(SETQ LAST-ITEM NIL)
	(SEND NORMAL-BLINKER :SET-VISIBILITY NIL)
	(SEND SELECTED-BLINKER :SET-VISIBILITY NIL)))))

;; Don't go bold when the mouse is in the scroll bar.
(DEFMETHOD (:HANDLE-MOUSE-SCROLL MULTIPLE-CHOICE :BEFORE) (&REST IGNORE)
  (WHEN *HIGHLIGHT-MULTIPLE-CHOICE-ITEM*
    (SEND NORMAL-BLINKER :SET-VISIBILITY NIL)
    (SEND SELECTED-BLINKER :SET-VISIBILITY NIL)))

(DEFWHOPPER (:HANDLE-MOUSE MULTIPLE-CHOICE) ()
  (UNWIND-PROTECT
      (PROGN
	(WHEN *HIGHLIGHT-MULTIPLE-CHOICE-ITEM*
	  ;; This makes the blinker work right when the window is first
	  ;; exposed, by telling it that it wasn't on any item.
	  (SETQ LAST-ITEM NIL))
	(CONTINUE-WHOPPER))
    (WHEN *HIGHLIGHT-MULTIPLE-CHOICE-ITEM*
      (SEND NORMAL-BLINKER :SET-VISIBILITY NIL)
      (SEND SELECTED-BLINKER :SET-VISIBILITY NIL))))

(DEFUN SET-MULTIPLE-CHOICE-HIGHLIGHTING (&OPTIONAL (ENABLE T) (CHAR #/.))
  (SETQ *HIGHLIGHT-MULTIPLE-CHOICE-ITEM* ENABLE)
  (SETQ *MULTIPLE-CHOICE-HIGHLIGHTING-CHARACTER* CHAR)
  (CLEAR-RESOURCE 'TEMPORARY-MULTIPLE-CHOICE-WINDOW))


(DEFSTRUCT (CHOICE-TYPE :LIST (:CONSTRUCTOR NIL))
  CHOICE-TYPE-KEYWORD
  CHOICE-TYPE-NAME
  CHOICE-TYPE-ON-POSITIVE-IMPLICATIONS
  CHOICE-TYPE-ON-NEGATIVE-IMPLICATIONS
  CHOICE-TYPE-OFF-POSITIVE-IMPLICATIONS
  CHOICE-TYPE-OFF-NEGATIVE-IMPLICATIONS)

(DEFSTRUCT (CHOICE-ITEM :LIST (:CONSTRUCTOR NIL))
  CHOICE-ITEM-ITEM
  CHOICE-ITEM-NAME
  CHOICE-ITEM-BOXES
  CHOICE-ITEM-MOUSE-SENSITIVITIES)

(DEFVAR DEFAULT-FINISHING-CHOICES
  '(("Do It" NIL MULTIPLE-CHOICE-DONE NIL NIL)
    ("Abort" NIL MULTIPLE-CHOICE-ABORT NIL NIL)))

(DEFMETHOD (:INIT MULTIPLE-CHOICE-MIXIN :AFTER) (INIT-PLIST &AUX CHOICES)
  (WHEN (SETQ CHOICES (GET INIT-PLIST ':CHOICES))
    (SEND SELF ':SET-CHOICES CHOICES)))
    

(DEFMETHOD (:ADJUSTABLE-SIZE-P MULTIPLE-CHOICE-MIXIN) ()
  T)

(DEFMETHOD (:ITEM-NAME-WIDTH MULTIPLE-CHOICE-MIXIN) (&OPTIONAL CHOICES)
  (AND CHOICES
       (LOOP FOR CHOICE IN CHOICES
	     FOR CHOICE-ITEM-NAME = (CHOICE-ITEM-NAME CHOICE)
	     WHEN CHOICE-ITEM-NAME MAXIMIZE (+ (SEND SELF ':STRING-LENGTH CHOICE-ITEM-NAME)
					       CHAR-WIDTH))))

(DEFMETHOD (:SET-CHOICE-TYPES MULTIPLE-CHOICE-MIXIN) (NEW-TYPES &OPTIONAL NAME-WIDTH
								&AUX NEW-LABEL
								MAX-X)
  (DECLARE (VALUES INSIDE-WIDTH NEW-LABEL))
  (LET ((ALLTYPES (MAPCAR 'CAR NEW-TYPES)))
    (SETQ CHOICE-TYPES
	  (LOOP FOR CHOICE-TYPE IN NEW-TYPES
		;; don't smash the caller's list structure, make a copy if necessary
		WHEN (OR (EQ (CHOICE-TYPE-ON-POSITIVE-IMPLICATIONS CHOICE-TYPE) T)
			 (EQ (CHOICE-TYPE-ON-NEGATIVE-IMPLICATIONS CHOICE-TYPE) T)
			 (EQ (CHOICE-TYPE-OFF-POSITIVE-IMPLICATIONS CHOICE-TYPE) T)
			 (EQ (CHOICE-TYPE-OFF-NEGATIVE-IMPLICATIONS CHOICE-TYPE) T))
		  DO (SETQ CHOICE-TYPE (COPYTREE CHOICE-TYPE))
		     (WHEN (EQ (CHOICE-TYPE-ON-POSITIVE-IMPLICATIONS CHOICE-TYPE) T)
		       (SETF (CHOICE-TYPE-ON-POSITIVE-IMPLICATIONS CHOICE-TYPE) ALLTYPES))
		     (WHEN (EQ (CHOICE-TYPE-ON-NEGATIVE-IMPLICATIONS CHOICE-TYPE) T)
		       (SETF (CHOICE-TYPE-ON-NEGATIVE-IMPLICATIONS CHOICE-TYPE) ALLTYPES))
		     (WHEN (EQ (CHOICE-TYPE-OFF-POSITIVE-IMPLICATIONS CHOICE-TYPE) T)
		       (SETF (CHOICE-TYPE-OFF-POSITIVE-IMPLICATIONS CHOICE-TYPE) ALLTYPES))
		     (WHEN (EQ (CHOICE-TYPE-OFF-NEGATIVE-IMPLICATIONS CHOICE-TYPE) T)
		       (SETF (CHOICE-TYPE-OFF-NEGATIVE-IMPLICATIONS CHOICE-TYPE) ALLTYPES))
		COLLECT CHOICE-TYPE)))
  ;; Now compute the length of the name needed
  (OR ITEM-NAME
      NAME-WIDTH
      (FERROR "Neither item name nor width supplied; I don't know how much room to leave."))
  (UNLESS NAME-WIDTH (SETQ NAME-WIDTH 0))
  (IF ITEM-NAME
      (SETQ NAME-WIDTH
	    (MAX NAME-WIDTH (+ CHAR-WIDTH (SEND SELF ':STRING-LENGTH ITEM-NAME)))))
  ;; Make prototype boxes
  (DO ((X NAME-WIDTH (+ X TYPE-WIDTH))
       (TYPES CHOICE-TYPES (CDR TYPES))
       (TYPE) (TYPE-WIDTH))
      ((NULL TYPES)
       (SETQ MAX-X (+ X CHAR-WIDTH)))
    (SETQ TYPE (CAR TYPES)
	  TYPE-WIDTH (+ (SEND SELF ':STRING-LENGTH (CHOICE-TYPE-NAME TYPE)) CHAR-WIDTH))
    (PUSH (LIST (CHOICE-TYPE-KEYWORD TYPE) NIL 
		#'(LAMBDA (WINDOW BOX ITEM Y)
		    (SEND WINDOW ':MULTIPLE-CHOICE-CHOOSE BOX ITEM Y))
		(+ X (// TYPE-WIDTH 2)) 177777)
	  BOX-TEMPLATES))
  ;; If this is too wide to fit inside the superior, truncate text to make it fit
  (LET* ((AVAIL (- (SHEET-INSIDE-WIDTH SUPERIOR) LEFT-MARGIN-SIZE RIGHT-MARGIN-SIZE))
	 (OVER (- MAX-X AVAIL)))
    (WHEN (PLUSP OVER)
      (WHEN (> (- MAX-X NAME-WIDTH) (FLOOR (* 3 AVAIL) 4))
	(ERROR "Too many choice boxes, window cannot be made narrow enough to fit."))
      (DECF MAX-X OVER)
      (DECF NAME-WIDTH OVER)
      (DOLIST (BOX BOX-TEMPLATES)
	(DECF (CHOICE-BOX-X1 BOX) OVER))))
  ;; Compute the new label
  (SETQ NEW-LABEL (MAKE-ARRAY (// MAX-X CHAR-WIDTH) :TYPE 'ART-FAT-STRING ':FILL-POINTER 0))
  (AND ITEM-NAME (SETQ NEW-LABEL (STRING-NCONC NEW-LABEL ITEM-NAME)))
  (DO ((I (STRING-LENGTH NEW-LABEL) (1+ I))
       (LIM (// NAME-WIDTH CHAR-WIDTH)))
      (( I LIM)
       (STORE-ARRAY-LEADER I NEW-LABEL 0))
    (ASET #\SP NEW-LABEL I))
  (DOLIST (CHOICE-TYPE CHOICE-TYPES)
    (SETQ NEW-LABEL (STRING-NCONC NEW-LABEL #\SP (CHOICE-TYPE-NAME CHOICE-TYPE))))
  (VALUES MAX-X NEW-LABEL))

;I don't think the user is supposed to call this directly; use :SETUP
(DEFMETHOD (:SET-CHOICES MULTIPLE-CHOICE-MIXIN) (NEW-CHOICES)
  (LET ((NITEMS (LENGTH NEW-CHOICES)))
    (AND (> NITEMS (ARRAY-LENGTH ITEMS))
	 (ADJUST-ARRAY-SIZE ITEMS NITEMS))
    (LET ((ONITEMS (FILL-POINTER ITEMS)))
      (WHEN (> ONITEMS NITEMS)
	;; Erase part of array past fill pointer for sake of GC.
	(CL:FILL ITEMS NIL :START NITEMS :END ONITEMS)))
    (SETF (FILL-POINTER ITEMS) 0)
    (LOOP FOR CHOICE IN NEW-CHOICES
	  DO (ARRAY-PUSH ITEMS (SEND SELF ':PREPARE-MULTIPLE-CHOICE-LINE CHOICE)))
    (* NITEMS LINE-HEIGHT)))
		       
(DEFMETHOD (:PREPARE-MULTIPLE-CHOICE-LINE MULTIPLE-CHOICE-MIXIN) (CHOICE)
  (LET ((CHOICE-ITEM (LIST (CHOICE-ITEM-ITEM CHOICE) (CHOICE-ITEM-NAME CHOICE) NIL NIL)))
    (DO ((BOXES (CHOICE-ITEM-BOXES CHOICE) (CDR BOXES))
	 (BOX) (TYPE) (INITIAL-STATE))
	((NULL BOXES))
      (SETQ BOX (CAR BOXES))
      (IF (SYMBOLP BOX)
	  (SETQ TYPE BOX
		INITIAL-STATE NIL)
	  (SETQ TYPE (CHOICE-BOX-NAME BOX)
		INITIAL-STATE (CHOICE-BOX-STATE BOX)))
      (SETQ BOX (COPYLIST (ASSQ TYPE BOX-TEMPLATES)))
      (SETF (CHOICE-BOX-STATE BOX) INITIAL-STATE)
      (PUSH BOX (CHOICE-ITEM-BOXES CHOICE-ITEM)))
    CHOICE-ITEM))

(DEFMETHOD (:SETUP MULTIPLE-CHOICE-MIXIN) (NEW-ITEM-NAME NEW-CHOICE-TYPES
					   NEW-FINISHING-CHOICES NEW-CHOICES
					   &OPTIONAL (MAXLINES 20.) &AUX WID HGT LBL)
  (SETQ ITEM-NAME NEW-ITEM-NAME)
  ;; Set the choices to NIL so SCROLL-STUFF-ON-OFF-MIXIN won't do anything yet,
  ;; since first we have to set the size of the margins.
  (SEND SELF :SET-CHOICES NIL)
  (MULTIPLE-VALUE (WID LBL)
    (SEND SELF :SET-CHOICE-TYPES NEW-CHOICE-TYPES
				 (SEND SELF :ITEM-NAME-WIDTH NEW-CHOICES)))
  (SEND SELF :SET-LABEL LBL)
  (SEND SELF :SET-MARGIN-CHOICES NEW-FINISHING-CHOICES)
  (SETQ WID (MAX WID (* (LENGTH NEW-FINISHING-CHOICES)
			(+ (LOOP FOR CHOICE IN NEW-FINISHING-CHOICES
				 MAXIMIZE (SEND SELF ':STRING-LENGTH (FIRST CHOICE)))
			   ;; leave room for a space and a box
			   ;; see the refresh-margin-choice-region method for how it's drawn
			   CHAR-WIDTH
			   (FONT-BLINKER-HEIGHT CURRENT-FONT)))))
  (SETQ HGT (SEND SELF :SET-CHOICES NEW-CHOICES))
  (IF (SEND SELF :ADJUSTABLE-SIZE-P)
      (SEND SELF :SET-INSIDE-SIZE WID (MIN (* LINE-HEIGHT MAXLINES)
					   (- (SHEET-INSIDE-HEIGHT SUPERIOR)
					      TOP-MARGIN-SIZE BOTTOM-MARGIN-SIZE)
					   HGT)))
  (SETQ TOP-ITEM 0)		;Un-scroll
  (SEND SELF :DECIDE-IF-SCROLLING-NECESSARY)
  (SHEET-FORCE-ACCESS (SELF T)
    (SEND SELF :REFRESH)))

(DEFMETHOD (:PRINT-ITEM MULTIPLE-CHOICE-MIXIN) (ITEM LINE-NO ITEM-NO)
  ITEM-NO					;Not used
  (MULTIPLE-VALUE-BIND (NIL END)
      (LET ((BOX (FIRST (LAST (CHOICE-ITEM-BOXES ITEM)))))
	(SEND SELF :STRING-LENGTH (CHOICE-ITEM-NAME ITEM) 0 NIL (IF BOX
								    (- (CHOICE-BOX-X1 BOX) CHAR-WIDTH)
								    (SHEET-INSIDE-WIDTH))))
    (SEND SELF ':STRING-OUT (CHOICE-ITEM-NAME ITEM) 0 END))
  (DOLIST (BOX (CHOICE-ITEM-BOXES ITEM))
    (SETF (CHOICE-BOX-X2 BOX)
	  (DRAW-CHOICE-BOX SELF (CHOICE-BOX-X1 BOX) CURSOR-Y (CHOICE-BOX-STATE BOX))))
  (ASET ITEM DISPLAYED-ITEMS LINE-NO))

(DEFMETHOD (:APPEND-CHOICE-ITEM MULTIPLE-CHOICE-MIXIN) (CHOICE-ITEM)
  (SEND SELF ':APPEND-ITEM (SEND SELF ':PREPARE-MULTIPLE-CHOICE-LINE CHOICE-ITEM))
  (SEND SELF ':DECIDE-IF-SCROLLING-NECESSARY))

(DEFUN-IN-FLAVOR (FIND-CHOICE-ITEM-INDEX MULTIPLE-CHOICE-MIXIN) (CHOICE-ITEM-ITEM)
  (LOOP FOR ITEM BEING THE ARRAY-ELEMENTS OF ITEMS
	FOR I UPFROM 0
	WHEN (EQ CHOICE-ITEM-ITEM (CHOICE-ITEM-ITEM ITEM))
	RETURN I
	FINALLY (FERROR "Item ~S not found." CHOICE-ITEM-ITEM)))

(DEFMETHOD (:DELETE-CHOICE-ITEM MULTIPLE-CHOICE-MIXIN) (ITEM)
  (SEND SELF ':DELETE-ITEM (FIND-CHOICE-ITEM-INDEX ITEM))
  (SEND SELF ':DECIDE-IF-SCROLLING-NECESSARY))

(DEFMETHOD (:INSERT-CHOICE-ITEM MULTIPLE-CHOICE-MIXIN) (OLD-ITEM NEW-ITEM)
  (SEND SELF ':INSERT-ITEM
	(FIND-CHOICE-ITEM-INDEX OLD-ITEM)
	(SEND SELF ':PREPARE-MULTIPLE-CHOICE-LINE NEW-ITEM))
  (SEND SELF ':DECIDE-IF-SCROLLING-NECESSARY))

(DEFMETHOD (:MOUSE-CLICK MULTIPLE-CHOICE-MIXIN) (BUTTON X Y &AUX LINE-NO ITEM)
  (UNLESS (CHAR-MOUSE-EQUAL BUTTON #\MOUSE-3-2)
    (SETQ LINE-NO (SHEET-LINE-NO NIL Y))
    (WHEN (AND ( Y (SHEET-INSIDE-TOP))
	       (< Y (+ (SHEET-INSIDE-TOP) (* (SHEET-NUMBER-OF-INSIDE-LINES)
					     LINE-HEIGHT)))
	       (SETQ ITEM (AREF DISPLAYED-ITEMS LINE-NO)))
      (HANDLE-CHOICE-BUTTON SELF (CHOICE-ITEM-BOXES ITEM) X Y ITEM)
      T)))

(DEFMETHOD (:WHO-LINE-DOCUMENTATION-STRING MULTIPLE-CHOICE-MIXIN) ()
  "Any button on a box to complement its state")

;;;A method so we can put daemons on it.
(DEFMETHOD (:MULTIPLE-CHOICE-CHOOSE MULTIPLE-CHOICE-MIXIN) (BOX ITEM Y)
  (SETQ Y (+ (SHEET-INSIDE-TOP) (* (SHEET-LINE-NO NIL Y) LINE-HEIGHT)))
  (SEND SELF ':SET-ITEM-BOX-STATE ITEM Y (CHOICE-BOX-NAME BOX)
	     (NOT (CHOICE-BOX-STATE BOX))))


(DEFMETHOD (:SET-ITEM-BOX-STATE MULTIPLE-CHOICE-MIXIN) (ITEM Y KEYWORD NEW-STATE &AUX BOX TYP)
  (WHEN (AND (SETQ BOX (ASSQ KEYWORD (CHOICE-ITEM-BOXES ITEM)))
	     (NEQ NEW-STATE (CHOICE-BOX-STATE BOX)))
    (SEND SELF ':SET-ITEM-BOX-STATE-INTERNAL ITEM Y KEYWORD NEW-STATE)
    (SETQ TYP (ASSQ KEYWORD CHOICE-TYPES))
    (DOLIST (POS (IF NEW-STATE (CHOICE-TYPE-ON-POSITIVE-IMPLICATIONS TYP)
		     (CHOICE-TYPE-OFF-POSITIVE-IMPLICATIONS TYP)))
      (OR (EQ POS KEYWORD)
	  (SEND SELF ':SET-ITEM-BOX-STATE-INTERNAL ITEM Y POS T)))
    (DOLIST (NEG (IF NEW-STATE (CHOICE-TYPE-ON-NEGATIVE-IMPLICATIONS TYP)
		     (CHOICE-TYPE-OFF-NEGATIVE-IMPLICATIONS TYP)))
      (OR (EQ NEG KEYWORD)
	  (SEND SELF ':SET-ITEM-BOX-STATE-INTERNAL ITEM Y NEG NIL)))))

(DEFMETHOD (:SET-ITEM-BOX-STATE-INTERNAL MULTIPLE-CHOICE-MIXIN)
	   (ITEM Y KEYWORD NEW-STATE &AUX BOX)
  (WHEN (AND (SETQ BOX (ASSQ KEYWORD (CHOICE-ITEM-BOXES ITEM)))
	     (NEQ NEW-STATE (CHOICE-BOX-STATE BOX)))
    (SETF (CHOICE-BOX-STATE BOX) NEW-STATE)
    (AND Y (DRAW-CHOICE-BOX SELF (CHOICE-BOX-X1 BOX) Y NEW-STATE))))

(DEFMETHOD (:SET-CHOICE-ITEM-STATE MULTIPLE-CHOICE-MIXIN) (CHOICE-ITEM-ITEM TURN-ON TURN-OFF)
  (LET* ((ITEM-NUMBER (FIND-CHOICE-ITEM-INDEX CHOICE-ITEM-ITEM))
	 (RELATIVE-ITEM-NUMBER (- ITEM-NUMBER TOP-ITEM))
	 (Y (AND ( RELATIVE-ITEM-NUMBER 0)
		 (< RELATIVE-ITEM-NUMBER (SHEET-NUMBER-OF-INSIDE-LINES))
		 (+ (SHEET-INSIDE-TOP) (* RELATIVE-ITEM-NUMBER LINE-HEIGHT))))
	 (ITEM (AREF ITEMS ITEM-NUMBER)))
    (LOOP FOR KEYWORD IN TURN-ON
	  DO (SEND SELF ':SET-ITEM-BOX-STATE ITEM Y KEYWORD T))
    (LOOP FOR KEYWORD IN TURN-OFF
	  DO (SEND SELF ':SET-ITEM-BOX-STATE ITEM Y KEYWORD NIL))))

(DEFMETHOD (:REDISPLAY-CHOICE-ITEM MULTIPLE-CHOICE-MIXIN) (CHOICE-ITEM-ITEM)
  (LET* ((ITEM-NUMBER (FIND-CHOICE-ITEM-INDEX CHOICE-ITEM-ITEM))
	 (RELATIVE-ITEM-NUMBER (- ITEM-NUMBER TOP-ITEM)))
    (WHEN (AND (NOT (MINUSP RELATIVE-ITEM-NUMBER))
	       (< RELATIVE-ITEM-NUMBER (SHEET-NUMBER-OF-INSIDE-LINES)))
      (SEND SELF ':DRAW-RECTANGLE (SHEET-INSIDE-WIDTH)
	    LINE-HEIGHT 0 (* RELATIVE-ITEM-NUMBER LINE-HEIGHT) :ERASE)
      (SEND SELF ':REDISPLAY RELATIVE-ITEM-NUMBER (1+ RELATIVE-ITEM-NUMBER)))))

(DEFMETHOD (:CHOOSE MULTIPLE-CHOICE-MIXIN) (&OPTIONAL (NEAR-MODE '(:MOUSE)) &AUX OLD-STATUS)
  (SETQ CHOICE-VALUE NIL)
  (SETQ OLD-STATUS (SEND SELF ':STATUS))
  (UNWIND-PROTECT
    (PROGN
      (EXPOSE-WINDOW-NEAR SELF NEAR-MODE)
      (PROCESS-WAIT "Choose" #'CAR (LOCF CHOICE-VALUE)))
    (SEND SELF ':SET-STATUS OLD-STATUS))
  (IF (EQ CHOICE-VALUE 'ABORT) (VALUES NIL T) CHOICE-VALUE))

(DEFMETHOD (MULTIPLE-CHOICE-DONE MULTIPLE-CHOICE-MIXIN) (CHOSEN THING Y)
  (DECLARE (FLAVOR:SOLITARY-METHOD))
  (IGNORE CHOSEN THING Y)
  (SETQ CHOICE-VALUE
	(DO ((I 0 (1+ I))
	     (LIM (ARRAY-ACTIVE-LENGTH ITEMS))
	     (ITEM) (RET NIL))
	    (( I LIM) (NREVERSE RET))
	  (SETQ ITEM (AREF ITEMS I))
	  (PUSH (CONS (CHOICE-ITEM-ITEM ITEM)
		      (DO ((BOXES (CHOICE-ITEM-BOXES ITEM) (CDR BOXES))
			   (BOX) (RET NIL))
			  ((NULL BOXES) (NREVERSE RET))
			(AND (CHOICE-BOX-STATE (SETQ BOX (CAR BOXES)))
			     (PUSH (CHOICE-BOX-NAME BOX) RET))))
		RET))))

(DEFMETHOD (MULTIPLE-CHOICE-ABORT MULTIPLE-CHOICE-MIXIN) (CHOSEN THING Y)
  (DECLARE (FLAVOR:SOLITARY-METHOD))
  (IGNORE CHOSEN THING Y)
  (SETQ CHOICE-VALUE 'ABORT))

(DEFFLAVOR TEMPORARY-MULTIPLE-CHOICE-WINDOW () (TEMPORARY-WINDOW-MIXIN MULTIPLE-CHOICE)
	   (:DEFAULT-INIT-PLIST :BORDERS *DROP-SHADOW-BORDERS-SPEC*))

(DEFMETHOD (:DEEXPOSE TEMPORARY-MULTIPLE-CHOICE-WINDOW :AFTER) (&REST IGNORE)
  (OR CHOICE-VALUE (SETQ CHOICE-VALUE 'ABORT)))

(COMPILE-FLAVOR-METHODS TEMPORARY-MULTIPLE-CHOICE-WINDOW)

;; Since Multiple Choice windows can keep nasty pointers around, help out GC.
(DEFUN UNATTACH-MULTIPLE-CHOICE-WINDOW (W &REST IGNORE)
  (SI:SET-IN-INSTANCE W 'CHOICE-VALUE NIL)
  (LET ((ITEMS (SI:SYMEVAL-IN-INSTANCE W 'ITEMS)))
    (LOOP FOR I BELOW (ARRAY-LENGTH ITEMS)
	  DO (SETF (AREF ITEMS I) NIL)))
  (LET ((ITEMS (SI:SYMEVAL-IN-INSTANCE W 'DISPLAYED-ITEMS)))
    (LOOP FOR I BELOW (ARRAY-LENGTH ITEMS)
	  DO (SETF (AREF ITEMS I) NIL))))

(SI:DEFINE-GC-OPTIMIZATION UNATTACH-MULTIPLE-CHOICE-WINDOWS :CLEANUP
  (:DOCUMENTATION "Clear items in multiple choice windows")
  (:BEFORE-FLIP (IGNORE)
    (MAP-RESOURCE 'TV:TEMPORARY-MULTIPLE-CHOICE-WINDOW #'TV:UNATTACH-MULTIPLE-CHOICE-WINDOW)))

(DEFFLAVOR STATIC-MULTIPLE-CHOICE-MIXIN
	((CHOICE-FUNCTION NIL))
	(TOP-BOX-LABEL-MIXIN MULTIPLE-CHOICE-MIXIN)
  (:DEFAULT-INIT-PLIST :MARGIN-CHOICES NIL)
  (:SETTABLE-INSTANCE-VARIABLES CHOICE-FUNCTION))

(DEFFLAVOR MULTIPLE-CHOICE-PANE ()
	   (PANE-MIXIN STATIC-MULTIPLE-CHOICE-MIXIN BASIC-MULTIPLE-CHOICE))

(DEFMETHOD (:ADJUSTABLE-SIZE-P STATIC-MULTIPLE-CHOICE-MIXIN) ()
  NIL)

(DEFUN-IN-FLAVOR (CALL-CHOICE-FUNCTION STATIC-MULTIPLE-CHOICE-MIXIN) (ITEM)
  (FUNCALL CHOICE-FUNCTION
	   SELF
	   (CHOICE-ITEM-ITEM ITEM)
	   (LOOP FOR BOX IN (CHOICE-ITEM-BOXES ITEM)
		 WHEN (CHOICE-BOX-STATE BOX)
		 COLLECT (CHOICE-BOX-NAME BOX))))

(DEFMETHOD (:MULTIPLE-CHOICE-CHOOSE STATIC-MULTIPLE-CHOICE-MIXIN :AFTER) (IGNORE ITEM IGNORE)
  (WHEN CHOICE-FUNCTION (CALL-CHOICE-FUNCTION ITEM)))

(DEFMETHOD (:SET-CHOICE-ITEM-STATE STATIC-MULTIPLE-CHOICE-MIXIN :AFTER)
	   (CHOICE-ITEM-ITEM &REST IGNORE)
  (WHEN CHOICE-FUNCTION
    (LET* ((INDEX (FIND-CHOICE-ITEM-INDEX CHOICE-ITEM-ITEM))
	   (ITEM (AREF ITEMS INDEX)))
      (CALL-CHOICE-FUNCTION ITEM))))

(DEFFLAVOR BORDERED-MULTIPLE-CHOICE-PANE ()
	   (BORDERS-MIXIN MULTIPLE-CHOICE-PANE))

(DEFFLAVOR MULTIPLE-CHOICE-MOUSE-SENSITIVITY-MIXIN
	((WHO-LINE-DOCUMENTATION-ALIST NIL))
	   ()
  (:SETTABLE-INSTANCE-VARIABLES WHO-LINE-DOCUMENTATION-ALIST)
  (:REQUIRED-FLAVORS MULTIPLE-CHOICE-MIXIN
   MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW-WITHOUT-CLICK))

(DEFMETHOD (:WHO-LINE-DOCUMENTATION-STRING MULTIPLE-CHOICE-MOUSE-SENSITIVITY-MIXIN :OVERRIDE)
	   ()
  (MULTIPLE-VALUE-BIND (X Y) (SHEET-MOUSE-POSITION SELF)
    (MULTIPLE-VALUE-BIND (NIL TYPE) (SEND SELF ':MOUSE-SENSITIVE-ITEM X Y)
      (AND TYPE (SECOND (ASSQ TYPE WHO-LINE-DOCUMENTATION-ALIST))))))

(DEFMETHOD (:MOUSE-MOVES MULTIPLE-CHOICE-MOUSE-SENSITIVITY-MIXIN :AFTER) (X Y)
  (TEST-FOR-MOUSE-SENSITIVE-ITEMS X Y))

(DEFMETHOD (:ADD-MOUSE-SENSITIVE-ITEM-FOR-LINE MULTIPLE-CHOICE-MOUSE-SENSITIVITY-MIXIN)
	   (DISITEM LINE-NO)
  (PUSH DISITEM (CHOICE-ITEM-MOUSE-SENSITIVITIES (AREF DISPLAYED-ITEMS LINE-NO))))

(DEFMETHOD (:MOUSE-SENSITIVE-ITEMS-FOR-LINE MULTIPLE-CHOICE-MOUSE-SENSITIVITY-MIXIN)
	   (LINE-NO)
  (CHOICE-ITEM-MOUSE-SENSITIVITIES (AREF DISPLAYED-ITEMS LINE-NO)))

;;;This is here because MARGIN-CHOICE-MIXIN assumes that if a click is not exactly
;;;his click, it's worth beeping about.  So put our click checker in front of his.
;;;What's more, we want to return our user's concept of "item".
(DEFMETHOD (:MOUSE-CLICK MULTIPLE-CHOICE-MOUSE-SENSITIVITY-MIXIN) (BUTTON X Y &AUX ITEM TYPE)
  (MULTIPLE-VALUE (ITEM TYPE) (SEND SELF ':MOUSE-SENSITIVE-ITEM X Y))
  (COND (TYPE
	 (SEND SELF ':FORCE-KBD-INPUT (LIST TYPE (CHOICE-ITEM-ITEM ITEM) SELF BUTTON))
	 T)))

(DEFFLAVOR BORDERED-MOUSE-SENSITIVE-MULTIPLE-CHOICE-PANE ()
	   (PANE-MIXIN BORDERS-MIXIN MULTIPLE-CHOICE-MOUSE-SENSITIVITY-MIXIN
	    STATIC-MULTIPLE-CHOICE-MIXIN
	    SCROLL-STUFF-ON-OFF-MIXIN MARGIN-CHOICE-MIXIN
	    MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW-WITHOUT-CLICK))

(DEFMETHOD (:DEINITIALIZE TEMPORARY-MULTIPLE-CHOICE-WINDOW) ()
  (SEND SELF :SET-CHOICES NIL)
  (CL:FILL DISPLAYED-ITEMS NIL)
  (SEND SELF :SET-NORMAL-BLINKER-STYLE (SI:PARSE-CHARACTER-STYLE '(NIL NIL NIL)))
  (SEND SELF :SET-SELECTED-BLINKER-STYLE (SI:PARSE-CHARACTER-STYLE '(NIL :BOLD NIL)))
  (SEND SELF :SET-HIGHLIGHTING-CHARACTER *MULTIPLE-CHOICE-HIGHLIGHTING-CHARACTER*))

(DEFWINDOW-RESOURCE TEMPORARY-MULTIPLE-CHOICE-WINDOW ()
	:MAKE-WINDOW (TEMPORARY-MULTIPLE-CHOICE-WINDOW)
	:REUSABLE-WHEN :DEACTIVATED
	:DEINITIALIZER (SEND OBJECT :DEINITIALIZE)
	:INITIAL-COPIES 0)

(DEFVAR *DEFAULT-CHARACTER-STYLE-FOR-MULTIPLE-CHOOSE* TV:*DEFAULT-STYLE*)

(DEFUN MULTIPLE-CHOOSE (ITEM-NAME ITEM-LIST KEYWORD-ALIST
			&OPTIONAL (NEAR-MODE '(:MOUSE)) (MAXLINES 20.) SUP
				  (BLINKER-STYLE '(NIL :BOLD NIL)))
  "ITEM-NAME is a string of the name of the type of item, e.g. /"Buffer/".
   ITEM-LIST is an alist, (ITEM NAME CHOICES).  ITEM is the item itself, NAME a string
	of its name, and CHOICES a list of possible keywords, either KEYWORD or
	(KEYWORD DEFAULT), where if DEFAULT is non-NIL the KEYWORD is initially on.
   KEYWORD-ALIST is a list of the possible keywords, (KEYWORD NAME . IMPLICATIONS).
   KEYWORD is a symbol, the same as in ITEM-LIST's CHOICES.  NAME is a string of its name.
   IMPLICATIONS is a list of on-positive, on-negative, off-positive, and off-negative
   implications for when the keyword is selected, each one either a list of (other) keywords
   or T for all other keywords.  The default for IMPLICATIONS is (NIL T NIL NIL)."
  ;; Decide what superior to use
  (OR SUP
      (SETQ SUP (IF (EQ (CAR NEAR-MODE) ':WINDOW)
		    (MOUSE-DEFAULT-SUPERIOR (CADR NEAR-MODE))
		    (MOUSE-DEFAULT-SUPERIOR))))
  ;; This used to destructively alter the callers list.  That behaviour had the obvious
  ;; problems.  Changed 9/6/85 not to cons, but clearly the right answer is to rewrite this
  ;; whole mess someday.  As it stands now, the amount this conses is only a small fraction
  ;; of the total consing done in a call to MULTIPLE-CHOOSE, so I'm not too concerned. --DEG
  (SETQ KEYWORD-ALIST
	(LOOP FOR ELEMENT IN KEYWORD-ALIST
	      COLLECT (IF (= (LENGTH ELEMENT) 2)
			  (APPEND ELEMENT '(NIL T NIL NIL))
			  ELEMENT)))
  (USING-RESOURCE (WINDOW TEMPORARY-MULTIPLE-CHOICE-WINDOW SUP)
    (WITH-CHARACTER-STYLE (*DEFAULT-CHARACTER-STYLE-FOR-MULTIPLE-CHOOSE*
			    WINDOW :BIND-LINE-HEIGHT T)
      (SEND WINDOW ':SET-SELECTED-BLINKER-STYLE
		   (SI:PARSE-CHARACTER-STYLE BLINKER-STYLE))
      (SEND WINDOW ':SETUP ITEM-NAME KEYWORD-ALIST
	    DEFAULT-FINISHING-CHOICES ITEM-LIST MAXLINES)
      (UNWIND-PROTECT
	  (SEND WINDOW ':CHOOSE NEAR-MODE)
	(SEND WINDOW ':DEACTIVATE)))))


;;;
;;; A menu for selecting a subset of things.
;;;

(DEFCONST *SUBSET-CHOOSE-DEFAULT-MARGIN-ITEMS*
	  '(("Do It"      
	     :FUNCALL-WITH-SELF TV:MULTIPLE-MENU-GET-HIGHLIGHTED
	     :DOCUMENTATION     "Select the highlighted items.")
	    ("Mark All"
	     :FUNCALL-WITH-SELF SUBSET-CHOOSE-MENU-MARK-ALL
	     :DOCUMENTATION     "Mark all the items.")
	    ("Unmark All"
	     :FUNCALL-WITH-SELF SUBSET-CHOOSE-MENU-MARK-NONE
	     :DOCUMENTATION     "Un-mark all the items.")
	    ("Abort"
	     :VALUE             NIL
	     :DOCUMENTATION     "Choose none of these, returning NIL."))
  "Default for margin-items of a subset-choose menu.")

(DEFFLAVOR SUBSET-CHOOSE-MENU
	((MINIMUM-WIDTH 400.))		    ;hack this if you hack the margin-choices
	(BORDERS-MIXIN CENTERED-LABEL-MIXIN MENU-MARGIN-MENU-MIXIN
	 KEYBOARD-SENSITIVE-MENU-MIXIN MULTIPLE-MENU)
  :INITABLE-INSTANCE-VARIABLES
  :READABLE-INSTANCE-VARIABLES
  :SETTABLE-INSTANCE-VARIABLES
  (:DEFAULT-INIT-PLIST
    :SPECIAL-CHOICES NIL
    :MARGIN-MENU-ITEM-LIST *SUBSET-CHOOSE-DEFAULT-MARGIN-ITEMS*))

(DEFCONST *SUBSET-CHOOSE-MENU-ADDITIONAL-CHARS*
	  '((#\END      . (#\END         :FUNCALL-WITH-SELF TV:MULTIPLE-MENU-GET-HIGHLIGHTED))
	    (#\COMPLETE . (#\COMPLETE    :FUNCALL-WITH-SELF SUBSET-CHOOSE-MENU-MARK-ALL))
	    (#\CLEAR-INPUT . (#\CLEAR-INPUT :FUNCALL-WITH-SELF SUBSET-CHOOSE-MENU-MARK-NONE))
	    (#\RETURN   . (#\RETURN  :FUNCALL-WITH-SELF SUBSET-CHOOSE-MENU-MARK-ALL-&-DO-IT)))
  "Additional characters handled by subset-choose menus.")

(DEFMETHOD (SET-ITEM-LIST SUBSET-CHOOSE-MENU :AFTER) (IGNORE)
  ;; Call menu-compute-geometry with a minimum width argument
  (TV:MENU-COMPUTE-GEOMETRY T (MAX MINIMUM-WIDTH TV:WIDTH)))

(DEFMETHOD (SET-LABEL SUBSET-CHOOSE-MENU :AFTER) (IGNORE)
  ;; Call menu-compute-geometry with a minimum width argument
  (TV:MENU-COMPUTE-GEOMETRY T (MAX MINIMUM-WIDTH TV:WIDTH)))

;;; These throw's are kind of ugly.  Think about how to remove them.

(DEFMETHOD (WARP-TO-ITEM SUBSET-CHOOSE-MENU :AFTER) (IGNORE)
  ;; keyboard warping of the mouse should not cause the menu to return
  (THROW 'KEYBOARD-MENU-CHOOSE-RETRY NIL))

(DEFMETHOD (CLICK-LEFT SUBSET-CHOOSE-MENU :AFTER) ()
  ;; clicking left on a multiple menu should not cause the menu to return
  (THROW 'KEYBOARD-MENU-CHOOSE-RETRY NIL))

(DEFUN SUBSET-CHOOSE-MENU-MARK-ALL (MENU)
  "Turn on all selectable items."
  (LOOP FOR ITEM IN (SEND MENU :ITEM-LIST)
	UNLESS (AND (LISTP ITEM) (EQ (SECOND ITEM) :NO-SELECT))
	  ;; don't highlight un-selectable items
	  DO (SEND MENU :ADD-HIGHLIGHTED-ITEM ITEM))
  ;; try again
  (THROW 'KEYBOARD-MENU-CHOOSE-RETRY NIL))

(DEFUN SUBSET-CHOOSE-MENU-MARK-NONE (MENU)
  "Turn off all items."
  (SEND MENU :SET-HIGHLIGHTED-ITEMS NIL)
  ;; try again
  (THROW 'KEYBOARD-MENU-CHOOSE-RETRY NIL))

(DEFUN SUBSET-CHOOSE-MENU-MARK-ALL-&-DO-IT (MENU)
  "Mark all the items and do it."
  (LOOP FOR ITEM IN (SEND MENU :ITEM-LIST)
	UNLESS (AND (LISTP ITEM) (EQ (SECOND ITEM) :NO-SELECT))
	  ;; don't highlight un-selectable items
	  DO (SEND MENU :ADD-HIGHLIGHTED-ITEM ITEM))
  (TV:MULTIPLE-MENU-GET-HIGHLIGHTED MENU))

;;;
;;; Easily-callable interface to all this.
;;;

(DEFFLAVOR POP-UP-SUBSET-CHOOSE-MENU () ;NB -- this is not momentary
	   (TV:TEMPORARY-WINDOW-MIXIN SUBSET-CHOOSE-MENU))

(DEFWINDOW-RESOURCE POP-UP-SUBSET-CHOOSE-MENU ()
  :MAKE-WINDOW (POP-UP-SUBSET-CHOOSE-MENU)
  :REUSABLE-WHEN :DEEXPOSED
  :INITIAL-COPIES 0)

(DEFUN SUBSET-CHOOSE (ITEM-LIST &OPTIONAL
				(LABEL NIL)
				(CHAR-TO-ITEM-ALIST
				  (APPEND *KEYBOARD-SENSITIVE-MENU-DEFAULT-CHAR-ALIST*
					  *SUBSET-CHOOSE-MENU-ADDITIONAL-CHARS*)
				  CHAR-TO-ITEM-ALIST-SUPPLIED-P)
				(MENU-MARGIN-CHOICES *SUBSET-CHOOSE-DEFAULT-MARGIN-ITEMS*)
				(NEAR-MODE '(:MOUSE))
				DEFAULT-ITEM
				(SUPERIOR (MOUSE-DEFAULT-SUPERIOR)))
  "Select a subset of a bunch of items."
  (WHEN (EQ (CAR NEAR-MODE) :WINDOW)
    ;; wants to expose near some window
    (SETQ SUPERIOR (TV:SHEET-SUPERIOR (CADR NEAR-MODE))))
  (USING-RESOURCE (MENU POP-UP-SUBSET-CHOOSE-MENU SUPERIOR)
    ;; allocate a subset-choose-menu
    (SEND MENU :SET-ITEM-LIST
	  (IF CHAR-TO-ITEM-ALIST-SUPPLIED-P
	      ;; if they supplied a char-to-item-alist, they'll have
	      ;; to supply their own documentation
	      ITEM-LIST
	      (APPEND '(("1c-N0 moves to next choice, 1c-P0 moves to previous, 1m-<0 moves to top, 1m->0 moves to bottom, 1Space0 clicks left"
			 :NO-SELECT T :STYLE (:SWISS :ROMAN :SMALL))
			("" :NO-SELECT T))
		      ITEM-LIST
		      '(("" :NO-SELECT T)
			("1End0 means Do It, 1Complete0 means Mark All, 1Clear-Input0 means Unmark All, 1Abort0 means Abort, 1Return0 means Do Them All"
			 :NO-SELECT T :STYLE (:SWISS :ROMAN :SMALL))))))
    (SEND MENU :SET-LABEL LABEL)
    (SEND MENU :SET-LAST-ITEM DEFAULT-ITEM)
    (SETF (KEYBOARD-SENSITIVE-MENU-MIXIN-CHAR-TO-ITEM-ALIST MENU) CHAR-TO-ITEM-ALIST)
    (SEND MENU :SET-MARGIN-MENU-ITEM-LIST MENU-MARGIN-CHOICES)
    (TV:EXPOSE-WINDOW-NEAR MENU NEAR-MODE)
    (WHEN (AND DEFAULT-ITEM
	       (NOT (MEMQ (CAR NEAR-MODE) '(:MOUSE :POINT))))
      ;; if there's a default item, and we're not exposing near a point
      (MULTIPLE-VALUE-BIND (X Y)
	  ;; ask menu where default item is
	  (SEND MENU :ITEM-CURSORPOS DEFAULT-ITEM)
	(WHEN (AND X Y)
	  ;; if answer makes sense, tell menu to move mouse there
	  (SEND MENU :SET-MOUSE-POSITION
		(+ X (TV:SHEET-INSIDE-LEFT MENU))
		(+ Y (TV:SHEET-INSIDE-TOP  MENU))))))
    ;; things are set up, now choose
    (SEND MENU :CHOOSE)))

(COMPILE-FLAVOR-METHODS POP-UP-SUBSET-CHOOSE-MENU SUBSET-CHOOSE-MENU)

;Choose-variable-values stuff.
;Basic idea is that the program has a list of special variables, and
;the user is asked to confirm and possibly modify their values.  Values
;can be either general expressions, or a choice from a list (menu like).
;
;The printing of the display is not actually done in the user's stack group,
;but it acts as if it were.  The reading of new values is done in the user's stack group.
;Thus you can bind BASE, PRINLEVEL, READTABLE, etc.

;The user can point at a displayed value and click the mouse, to modify it.
;The new value is input from the keyboard; over-rubbing-out restores the
;old value.  For values chosen from a list, clicking the mouse selects
;the value pointed-to.

;VARIABLES is a list of elements, each describing one line of the display
; These become text-scroll items.  Kinds of elements allowed are:
;  string - just displayed
;  special-variable - value is printed, and if the user clicks on it
;		with the mouse a new value is read.
;  locative - like special-variable but value is accessed by car and written by rplaca
; Otherwise a list whose car is the variable, optionally
; followed by a string to use as label instead of the var, or nil for
; no label, followed by a keyword for the type of variable, followed by
; args to the keyword.  The default keyword is :SEXP
; Keywords are:
;    :EXPRESSION - value of variable is a Lisp S-expression, printed with PRIN1,
;		   read in with READ  (:SEXP is a synonym for compatibility)
;    :EVAL-FORM - same as :EXPRESSION, but read it with READ-AND-EVAL.
;    :PRINC - same as :EXPRESSION but print it with PRINC instead of PRIN1
;    :STRING - print with PRINC, read with READLINE
;    :NUMBER - print with PRIN1, read with READ but must be a number
;    :INTEGER - print with PRIN1, read with READ but must be an integer
;    :CHOOSE values-list print-function - value of variable is one of the
;		elements of values-list (EQUAL testing is used).  Printed
;		by printing all the value choices, with the current one in
;		boldface, read in by the user pointing and clicking.
;		print-function is optional and defaults to PRINC
;    :ASSOC values-list print-function - like :CHOOSE, but car of
;		values-list element is displayed, cdr is variable-value
;    :CHOOSE-MULTIPLE values-list print-function - like :ASSOC, but
;		multiple items can be selected concurrently.  The variable
;		is set to a list of the values selected.
;    :BOOLEAN - value is T or NIL, but displays as Yes or No
;    :INVERTED-BOOLEAN - value is T or NIL, but display has sense inverted (No or Yes)
;    :CHARACTER - value is a character, prints with ~:@C, reads as one keystroke
;    :CHARACTER-OR-NIL - same but can also be NIL, displays as "none", inputs as CLEAR-INPUT
;
; The other keywords are listed below, and are more or less self-explanatory:
;    :DATE, :PAST-DATE, :DATE-OR-NEVER, :PAST-DATE-OR-NEVER
;    :TIME-INTERVAL-OR-NEVER
;    :NUMBER, :NUMBER-OR-NIL, :DECIMAL-NUMBER, :DECIMAL-NUMBER-OR-NIL,
;    :OCTAL-NUMBER, :OCTAL-NUMBER-OR-NIL,
;    :DECIMAL-NUMBER-OR-NONE, :TIME-INTERVAL-60THS,
;    :STRING-LIST, :PATHNAME-OR-NIL, :PATHNAME, :PATHNAME-LIST, :STRING-OR-NIL
;    :HOST, :PATHNAME-HOST, :HOST-OR-LOCAL, :HOST-LIST, :FONT-LIST, :KEYWORD-LIST
;
; If :DOCUMENTATION appears where the keyword is expected, it is followed by
; a string to display when the mouse is pointing here, and then by the keyword.
; This is implemented by :DECODE-VARIABLE-TYPE (see below) so that you can
; change it.
;
; Should there also be ones which are constrained to be lists of chars?
; Keywords automatically forced into the keyword package?
; Should there be a provision for documentation of a variable, and a way
; to make that print somewhere?  (As in ZMACS Alter Options)
;
; The :DECODE-VARIABLE-TYPE message to the window is used to look at the
; keyword and options and return information about how to print and change
; the variable's value.  The argument to this message is
; the tail of a VARIABLES element starting with the keyword, and it
; returns 6 values:
;  The print function (args are object and stream).
;  The read function, or NIL if it works by pointing (args are stream and
;    input editor options).
;    Crockishness: usually this is called inside the input editor, with the
;    feature supplied that over-rubout causes the variable to be left at its old
;    value.  But with a list here the car of the list is the function which
;    just gets called directly.
;  The choices to be printed (NIL if just print current value).
;  The function which translates a value to its printed form (NIL for identity).
;  The function which translates a value to the form
;    which goes in the variable (NIL for identity).
;  The who-line mouse documentation string.  If this is a symbol, then NIL means
;    use the default documentation, and any other symbol is the name of a function
;    which translates a value to its documentation.
; The two functions only apply when there are choices.
; The default handler looks for a TV:CHOOSE-VARIABLE-VALUES-KEYWORD-FUNCTION property which
; is a function to call or a TV:CHOOSE-VARIABLE-VALUES-KEYWORD property which is
; (print-func read-func choices ptransfn vtransfn mouse-documentation)

;FUNCTION can be NIL or a function called on window, special-variable, old-value, new-value
;  when a variable is changed.  It may make other changes.  Returns T if it did
;  its own redisplay (typically by sending a :SET-VARIABLES),
;  NIL if that variable's new value needs to be displayed.
;  Typically this function implements constraints among the variable
;  values and sends a refresh message and returns T.
;
;STACK-GROUP is the stack-group in which the variables may be evaluated.

;Height of window is chosen automatically upon creation if not specified
; in the init-plist.  Also is automatically adjustable if you send
; a :SET-VARIABLES.

;The following messages can come back through the io-buffer:
;  (:CHOICE-BOX window box)
;  (:VARIABLE-CHOICE window VARIABLES-element value line-no)


(DEFFLAVOR BASIC-CHOOSE-VARIABLE-VALUES
	((FUNCTION NIL) STACK-GROUP (RECURSION NIL) VARIABLES
	 STRING-STYLE
	 NAME-STYLE
	 VALUE-STYLE
	 UNSELECTED-CHOICE-STYLE
	 SELECTED-CHOICE-STYLE
	 )
	(MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW-WITHOUT-CLICK)
  (:REQUIRED-FLAVORS STREAM-MIXIN)
  :GETTABLE-INSTANCE-VARIABLES
  (:SETTABLE-INSTANCE-VARIABLES FUNCTION STACK-GROUP)
  (:INIT-KEYWORDS :VARIABLES
		  ;; -FONT init keywords are only for compatibility.
		  :STRING-STYLE :STRING-FONT
		  :NAME-STYLE :NAME-FONT
		  :VALUE-STYLE :VALUE-FONT
		  :UNSELECTED-CHOICE-STYLE :UNSELECTED-CHOICE-FONT
		  :SELECTED-CHOICE-STYLE :SELECTED-CHOICE-FONT)
  (:DEFAULT-INIT-PLIST :SAVE-BITS NIL :CHARACTER-WIDTH 50.
		       :BLINKER-P '(:VISIBILITY NIL) :BLINKER-DESELECTED-VISIBILITY NIL
		       :TRUNCATE-LINE-OUT-FLAG 0 ;So lines can wrap around when reading
		       ))

(DEFFLAVOR CHOOSE-VARIABLE-VALUES-WINDOW
	()
	(BASIC-CHOOSE-VARIABLE-VALUES BORDERS-MIXIN TOP-BOX-LABEL-MIXIN
	 SCROLL-STUFF-ON-OFF-MIXIN MARGIN-CHOICE-MIXIN WINDOW)
  (:DEFAULT-INIT-PLIST :MARGIN-CHOICES
		         '(("Exit" NIL CHOOSE-VARIABLE-VALUES-CHOICE-BOX-HANDLER NIL NIL))))

(DEFMETHOD (CHOOSE-VARIABLE-VALUES-CHOICE-BOX-HANDLER BASIC-CHOOSE-VARIABLE-VALUES)
	   (BOX REGION YPOS)
  (DECLARE (FLAVOR:SOLITARY-METHOD))
  REGION YPOS ;ignored
  (SEND SELF ':FORCE-KBD-INPUT `(:CHOICE-BOX ,SELF ,BOX)))

(DEFCONST CHOOSE-VARIABLE-VALUES-MAX-LINES 25.)

;;; I don't know if this function's list of options is up to date...
(DEFUN HEIGHT-SPECIFIED-IN-INIT-PLIST (PLIST)
  "Returns T if the PLIST contains anything that specifies the window height"
  (OR (GETL PLIST '(:EDGES-FROM :EDGES :HEIGHT :CHARACTER-HEIGHT))
      (AND (GETL PLIST '(:TOP :Y)) (GET PLIST ':BOTTOM))))

(SI:DEFINE-CHARACTER-STYLE-FAMILIES SI:*B&W-SCREEN* SI:*STANDARD-CHARACTER-SET*
  '(:SIZE *
	  (:FAMILY CHOOSE-VARIABLE-VALUES-MENU
		   (:FACE :ROMAN (:STYLE :FIX :ROMAN ())
			  :ITALIC (:STYLE :FIX :ITALIC ())
			  :BOLD (:STYLE :FIX :BOLD ())
			  :BOLD-ITALIC (:STYLE :FIX :BOLD-ITALIC ())
			  :FIX (:STYLE :FIX :ROMAN ())
			  STRING (:STYLE CHOOSE-VARIABLE-VALUES-MENU :ROMAN ())
			  NAME (:STYLE CHOOSE-VARIABLE-VALUES-MENU :ROMAN ())
			  VALUE (:STYLE CHOOSE-VARIABLE-VALUES-MENU :ROMAN ())
			  UNSELECTED-CHOICE (:STYLE :SWISS :ROMAN :SMALLER)
			  SELECTED-CHOICE (:STYLE :SWISS :BOLD :SMALLER)))))

(DEFMETHOD (:INIT BASIC-CHOOSE-VARIABLE-VALUES :BEFORE) (PLIST)
  ;; Default the height according to the number of variables, unless
  ;; it was specified explicitly.
  (OR (HEIGHT-SPECIFIED-IN-INIT-PLIST PLIST)
      (PUTPROP PLIST (MAX (MIN (LENGTH (GET PLIST ':VARIABLES)) 25.) 1) ':CHARACTER-HEIGHT))
  (MACROLET ((SET-STYLE (SLOT DEFAULT)
	       (LET* ((IV (INTERN (STRING-APPEND SLOT "-STYLE")))
		      (STYLE-KEY (INTERN (STRING-APPEND SLOT "-STYLE") PKG-KEYWORD-PACKAGE))
		      (FONT-KEY (INTERN (STRING-APPEND SLOT "-FONT") PKG-KEYWORD-PACKAGE))
		      (ERRMSG (FORMAT NIL "Can't supply both ~S ~~S and ~S ~~S"
				      STYLE-KEY FONT-KEY)))
					    
		 `(LET ((STYLE (GET PLIST ,STYLE-KEY))
			(FONT (GET PLIST ,FONT-KEY)))
		    (WHEN (AND STYLE FONT)
		      (FERROR ,ERRMSG STYLE FONT))
		    (SETQ ,IV (COND (STYLE
				     (SI:PARSE-CHARACTER-STYLE STYLE))
				    (FONT
				     (SI:BACKTRANSLATE-FONT FONT DISPLAY-DEVICE-TYPE))
				    (T
				     (SI:PARSE-CHARACTER-STYLE ,DEFAULT))))))))
    (SET-STYLE STRING '(CHOOSE-VARIABLE-VALUES-MENU STRING NIL))
    (SET-STYLE NAME '(CHOOSE-VARIABLE-VALUES-MENU NAME NIL))
    (SET-STYLE VALUE '(CHOOSE-VARIABLE-VALUES-MENU VALUE NIL))
    (SET-STYLE UNSELECTED-CHOICE '(CHOOSE-VARIABLE-VALUES-MENU UNSELECTED-CHOICE NIL))
    (SET-STYLE SELECTED-CHOICE '(CHOOSE-VARIABLE-VALUES-MENU SELECTED-CHOICE NIL))))

;;; This sets the variables and adjusts the scrolling but never changes the height
;;; which was set either by the before-init method or by the creator.
;;; Except that the outside height may be changed to preserve what the creator
;;; is thought to have specified as the inside height.
(DEFMETHOD (:INIT BASIC-CHOOSE-VARIABLE-VALUES :AFTER) (PLIST)
  (WHEN (NOT (VARIABLE-BOUNDP STACK-GROUP))
    (SETQ STACK-GROUP %CURRENT-STACK-GROUP))
  (LET ((ELEMS (GET PLIST ':VARIABLES)))
    (WHEN ELEMS
      (SEND SELF ':SET-VARIABLES ELEMS T))))

;;; Default is that size adjusts according to the number of items present,
;;; provided that the window is de-exposed.  This is because if it was
;;; exposed the user would see it spastically redisplay several times.
;;; Also it probably looks very bad for it to change size while it's exposed.
;;; You are welcome to redefine this method.
(DEFMETHOD (:ADJUSTABLE-SIZE-P BASIC-CHOOSE-VARIABLE-VALUES) ()
  (NOT EXPOSED-P))

(DEFMETHOD (:SET-VARIABLES BASIC-CHOOSE-VARIABLE-VALUES) (ELEMS &OPTIONAL NO-SET-HEIGHT)
  (SEND SELF ':SET-VARIABLES-INTERNAL ELEMS)
  (SEND SELF ':ADJUST-GEOMETRY-FOR-NEW-VARIABLES
		(AND (NOT NO-SET-HEIGHT) (SHEET-INSIDE-WIDTH))))

(DEFMETHOD (:SET-VARIABLES-INTERNAL BASIC-CHOOSE-VARIABLE-VALUES) (ELEMS)
  (LET ((NELEM (LENGTH ELEMS)))
    (SETQ TOP-ITEM 0)			;Unscroll
    (AND (< (ARRAY-LENGTH ITEMS) NELEM)
	 (SETQ ITEMS (ADJUST-ARRAY-SIZE ITEMS NELEM)))
    (SETF (FILL-POINTER ITEMS) 0)
    (DOLIST (ELEM ELEMS)
      (ARRAY-PUSH ITEMS ELEM))
    (SETQ VARIABLES ELEMS)))

;WID is NIL if size is not to be adjusted, otherwise the inside-width desired
;and the height will be adjusted also
(DEFMETHOD (:ADJUST-GEOMETRY-FOR-NEW-VARIABLES BASIC-CHOOSE-VARIABLE-VALUES)
	   (WID &OPTIONAL (MAX-LINES CHOOSE-VARIABLE-VALUES-MAX-LINES))
  ;; Look for choice items which take multiple lines
  (SETF (FILL-POINTER ITEMS) 0)
  (DOLIST (ELEM VARIABLES)
    (ARRAY-PUSH-EXTEND ITEMS ELEM)
    (IF (LISTP ELEM)			;Choice-type item extend onto multiple lines?
	(MULTIPLE-VALUE-BIND (IW PW) (SEND SELF ':ITEM-WIDTH ELEM)
	  (IF (> IW (OR WID (SHEET-INSIDE-WIDTH)))
	      (MULTIPLE-VALUE-BIND (STR IGNORE VAR IGNORE IGNORE CHOICES IGNORE IGNORE K&A)
		  (SEND SELF ':DECODE-ITEM-FOR-PRINTING ELEM)
		(AND CHOICES
		     (MEMQ CHOICES K&A)
		     (LOOP DOING
		       (MULTIPLE-VALUE-BIND (IGNORE IGNORE TAIL)
			   (SEND SELF ':ITEM-WIDTH ELEM 0 (OR WID (SHEET-INSIDE-WIDTH)))
			 ;; If single choice too long to fit, let it get truncated
			 (IF (EQ TAIL CHOICES) (SETQ TAIL (CDR CHOICES)))
			 ;; If it all fits, good
			 (OR TAIL (RETURN))
			 ;; Store truncated item
			 (ASET (LIST* VAR STR (SUBSTQ (LDIFF CHOICES TAIL) CHOICES K&A))
			       ITEMS (1- (FILL-POINTER ITEMS)))
			 ;; Make additional item containing the rest of the choices
			 ;; and loop to operate on that item in place of the original one.
			 (SETQ K&A (SUBSTQ TAIL CHOICES K&A)
			       ELEM (LIST* VAR PW K&A)
			       CHOICES TAIL
			       STR PW)
			 (ARRAY-PUSH-EXTEND ITEMS ELEM)))))))))
   (LET* ((NELEM (FILL-POINTER ITEMS))
	 (DESIRED-HEIGHT (* (MIN MAX-LINES NELEM) LINE-HEIGHT))
	 (HEIGHT-TO-USE (SHEET-INSIDE-HEIGHT)))
    (AND WID
	 ( (SHEET-INSIDE-HEIGHT) DESIRED-HEIGHT)
	 (SEND SELF ':ADJUSTABLE-SIZE-P)
	 (SETQ HEIGHT-TO-USE (MIN (- (SHEET-INSIDE-HEIGHT SUPERIOR)
				     TOP-MARGIN-SIZE BOTTOM-MARGIN-SIZE)
				  DESIRED-HEIGHT)))
    (AND WID (SEND SELF ':SET-INSIDE-SIZE WID HEIGHT-TO-USE)))
  (SEND SELF ':DECIDE-IF-SCROLLING-NECESSARY)
  (SEND SELF ':SET-ITEMS ITEMS))	;Redisplay

(DEFMETHOD (:CHANGE-OF-SIZE-OR-MARGINS BASIC-CHOOSE-VARIABLE-VALUES :AFTER) (&REST IGNORE)
  (WHEN (VARIABLE-BOUNDP VARIABLES)
	(SEND SELF ':ADJUST-GEOMETRY-FOR-NEW-VARIABLES NIL)))

(DEFMETHOD (:SETUP BASIC-CHOOSE-VARIABLE-VALUES) (ELEMS NEW-LABEL NEW-FUNCTION
						  NEW-MARGIN-CHOICES)
  (SETQ FUNCTION NEW-FUNCTION)
  (SETQ STACK-GROUP %CURRENT-STACK-GROUP)
  (AND IO-BUFFER
       (SETF (IO-BUFFER-LAST-OUTPUT-PROCESS IO-BUFFER) CURRENT-PROCESS))  ;Kludge
  ;; Set the variables to NIL so SCROLL-STUFF-ON-OFF-MIXIN won't do anything yet,
  ;; since first we have to set the size of the margins.
  (SEND SELF ':SET-VARIABLES-INTERNAL NIL)
  (SEND SELF ':SET-LABEL NEW-LABEL)
  (SEND SELF ':SET-MARGIN-CHOICES NEW-MARGIN-CHOICES)
  ;; Now set the variables.  The :ADJUST-GEOMETRY-FOR-NEW-VARIABLES message will
  ;; be sent a little later by the caller, after everything is ready, to make
  ;; SCROLL-STUFF-ON-OFF-MIXIN do its thing.
  (SEND SELF ':SET-VARIABLES-INTERNAL ELEMS))

;; :SEXP is the obsolete way of saying :EXPRESSION.

(DEFPROP :EXPRESSION (PRIN1 READ) CHOOSE-VARIABLE-VALUES-KEYWORD)
(DEFPROP :SEXP (PRIN1 READ) CHOOSE-VARIABLE-VALUES-KEYWORD)
(DEFPROP :PRINC (PRINC READ) CHOOSE-VARIABLE-VALUES-KEYWORD)
(DEFPROP :EVAL-FORM (PRIN1 READ-AND-EVAL) CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFPROP :STRING (PRINC READLINE) CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFPROP :CHOOSE CHOOSE-VARIABLE-VALUES-DECODE-CHOOSE CHOOSE-VARIABLE-VALUES-KEYWORD-FUNCTION)
(DEFPROP :ASSOC CHOOSE-VARIABLE-VALUES-DECODE-CHOOSE CHOOSE-VARIABLE-VALUES-KEYWORD-FUNCTION)
(DEFPROP :CHOOSE-MULTIPLE
	 CHOOSE-VARIABLE-VALUES-DECODE-CHOOSE
	 CHOOSE-VARIABLE-VALUES-KEYWORD-FUNCTION)
(DEFUN CHOOSE-VARIABLE-VALUES-DECODE-CHOOSE (KWD-AND-ARGS)
  (VALUES (OR (THIRD KWD-AND-ARGS) 'PRINC)
	  NIL
	  (SECOND KWD-AND-ARGS)
	  (AND (NEQ (FIRST KWD-AND-ARGS) ':CHOOSE) 'CAR)
	  (AND (NEQ (FIRST KWD-AND-ARGS) ':CHOOSE) 'CDR)))

(DEFPROP :BOOLEAN (CHOOSE-VARIABLE-VALUES-BOOLEAN-PRINT NIL (T NIL))
	 CHOOSE-VARIABLE-VALUES-KEYWORD)
(DEFUN CHOOSE-VARIABLE-VALUES-BOOLEAN-PRINT (VALUE STREAM)
  (SEND STREAM ':STRING-OUT (IF VALUE "Yes" "No")))

(DEFPROP :INVERTED-BOOLEAN (CHOOSE-VARIABLE-VALUES-INVERTED-BOOLEAN-PRINT NIL (T NIL))
	 CHOOSE-VARIABLE-VALUES-KEYWORD)
(DEFUN CHOOSE-VARIABLE-VALUES-INVERTED-BOOLEAN-PRINT (VALUE STREAM)
  (SEND STREAM ':STRING-OUT (IF (NOT VALUE) "Yes" "No")))

(DEFPROP :CHARACTER
	 (CHOOSE-VARIABLE-VALUES-CHARACTER-PRINT (TYI) NIL
	  NIL NIL "Click left to input a new character from the keyboard.")
	 CHOOSE-VARIABLE-VALUES-KEYWORD)
(DEFUN CHOOSE-VARIABLE-VALUES-CHARACTER-PRINT (VALUE STREAM)
  (FORMAT STREAM "~:@C" VALUE))

(DEFPROP :CHARACTER-OR-NIL
	 (CHOOSE-VARIABLE-VALUES-CHARACTER-OR-NIL-PRINT
	  CHOOSE-VARIABLE-VALUES-CHARACTER-OR-NIL-READ
	  NIL NIL NIL "Click left to input a new character from the keyboard.")
	 CHOOSE-VARIABLE-VALUES-KEYWORD)
(DEFUN CHOOSE-VARIABLE-VALUES-CHARACTER-OR-NIL-PRINT (VALUE STREAM)
  (FORMAT STREAM (IF VALUE "~:@C" "none") VALUE))

(DEFUN CHOOSE-VARIABLE-VALUES-CHARACTER-OR-NIL-READ (STREAM &AUX CH)
  (IF (CHAR= (SETQ CH (SEND STREAM ':TYI)) #\CLEAR)
      NIL
      (SEND STREAM ':UNTYI CH)
      (TYI STREAM)))

(DEFPROP :DATE
	 (TIME:PRINT-UNIVERSAL-TIME READ-DATE NIL
	  NIL NIL "Click left to input a new date from the keyboard, middle to edit the current value.") 
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFPROP :PAST-DATE
	 (TIME:PRINT-UNIVERSAL-TIME READ-PAST-DATE NIL
	  NIL NIL "Click left to input a new date in the past from the keyboard, middle to edit the current value.") 
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFUN READ-PAST-DATE (&OPTIONAL STREAM)
  (READ-DATE STREAM T))

(DEFPROP :DATE-OR-NEVER
	 (PRINT-UNIVERSAL-TIME-OR-NEVER READ-DATE-OR-NEVER NIL
	  NIL NIL "Click left to input a new date from the keyboard, middle to edit the current value.") 
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFUN PRINT-UNIVERSAL-TIME-OR-NEVER (TIME STREAM)
  (IF (NULL TIME) (PRINC "never" STREAM)
      (TIME:PRINT-UNIVERSAL-TIME TIME STREAM)))

(DEFUN READ-DATE-OR-NEVER (&OPTIONAL STREAM)
  (READ-DATE STREAM NIL T))

(DEFPROP :PAST-DATE-OR-NEVER
	 (PRINT-UNIVERSAL-TIME-OR-NEVER READ-PAST-DATE-OR-NEVER NIL
	  NIL NIL "Click left to input a new date in the past from the keyboard, middle to edit the current value.") 
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFUN READ-PAST-DATE-OR-NEVER (&OPTIONAL STREAM)
  (READ-DATE STREAM T T))

(DEFPROP :TIME-INTERVAL-OR-NEVER (TIME:PRINT-INTERVAL-OR-NEVER READ-INTERVAL-OR-NEVER
				  NIL NIL NIL
				  "Click left to input a time interval or /"never/".")
	 CHOOSE-VARIABLE-VALUES-KEYWORD)


(DEFPROP :NUMBER NUMBER-CVV-TYPE-GENERATOR
	 CHOOSE-VARIABLE-VALUES-KEYWORD-FUNCTION)
(DEFPROP :NUMBER-OR-NIL NUMBER-OR-NIL-CVV-TYPE-GENERATOR
	 CHOOSE-VARIABLE-VALUES-KEYWORD-FUNCTION)
(DEFPROP :INTEGER INTEGER-CVV-TYPE-GENERATOR
	 CHOOSE-VARIABLE-VALUES-KEYWORD-FUNCTION)
(DEFPROP :INTEGER-OR-NIL INTEGER-OR-NIL-CVV-TYPE-GENERATOR
	 CHOOSE-VARIABLE-VALUES-KEYWORD-FUNCTION)

(DEFUN NUMBER-OR-NIL-CVV-TYPE-GENERATOR (KWD-AND-ARGS)
  (NUMBER-CVV-TYPE-GENERATOR KWD-AND-ARGS T))
(DEFUN INTEGER-CVV-TYPE-GENERATOR (KWD-AND-ARGS)
  (NUMBER-CVV-TYPE-GENERATOR KWD-AND-ARGS NIL T))
(DEFUN INTEGER-OR-NIL-CVV-TYPE-GENERATOR (KWD-AND-ARGS)
  (NUMBER-CVV-TYPE-GENERATOR KWD-AND-ARGS T T))


(DEFUN NUMBER-CVV-TYPE-GENERATOR (KWD-AND-ARGS &OPTIONAL OR-NIL FORCE-INTEGER)
  (LET* ((OR-NIL (OR OR-NIL (GET KWD-AND-ARGS ':OR-NIL)))
	 (BSE (OR (GET KWD-AND-ARGS ':BASE)
		  (GET KWD-AND-ARGS ':INPUT-RADIX)
		  10.))
	 (DOC (OR (GET KWD-AND-ARGS ':DOCUMENTATION)
		  (FORMAT NIL "Click left to enter a number in base ~D~:[~;, or ~:C for none~], middle to edit the current value."
		    BSE OR-NIL #\RETURN))))
    (VALUES #'(LAMBDA (OBJ STREAM)
		(IF OBJ
		    (LET ((BASE BSE))
		      (PRIN1 OBJ STREAM))
		  (PRINC "none" STREAM)))
	    #'(LAMBDA (STREAM)
		(IF FORCE-INTEGER
		    (SI:READ-INTEGER STREAM BSE OR-NIL)
		    (SI:READ-NUMBER  STREAM BSE OR-NIL)))
	    NIL NIL NIL DOC)))


;; :DECIMAL-NUMBER and :DECIMAL-NUMBER-OR-NIL exist for compatibility with Rel 5.

(PUTPROP :DECIMAL-NUMBER (GET :NUMBER 'CHOOSE-VARIABLE-VALUES-KEYWORD-FUNCTION)
	 'CHOOSE-VARIABLE-VALUES-KEYWORD-FUNCTION)
(PUTPROP :DECIMAL-NUMBER-OR-NIL (GET :NUMBER-OR-NIL 'CHOOSE-VARIABLE-VALUES-KEYWORD-FUNCTION)
	 'CHOOSE-VARIABLE-VALUES-KEYWORD-FUNCTION)

(DEFPROP :OCTAL-NUMBER
	 (PRINT-OCTAL-NUMBER READ-OCTAL-NUMBER NIL
	  NIL NIL "Click left to enter a new number, base eight, from the keyboard, middle to edit the current value.")
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFPROP :OCTAL-NUMBER-OR-NIL
	 (PRINT-OCTAL-NUMBER-OR-NIL READ-OCTAL-NUMBER-OR-NIL NIL
	  NIL NIL "Click left to enter a new number, base eight, or Return, from the keyboard, middle to edit the current value.")
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFUN PRINT-DECIMAL-NUMBER (X STREAM)
  (LET ((BASE 10.)) (PRIN1 X STREAM)))

(DEFUN READ-DECIMAL-NUMBER (&OPTIONAL STREAM)
  (READ-NUMBER STREAM 10. NIL))

(DEFUN PRINT-DECIMAL-NUMBER-OR-NIL (X STREAM)
  (AND X (PRINT-DECIMAL-NUMBER X STREAM)))

(DEFUN READ-DECIMAL-NUMBER-OR-NIL (&OPTIONAL STREAM)
  (READ-NUMBER STREAM 10. T))

(DEFUN PRINT-OCTAL-NUMBER (X STREAM)
  (LET ((BASE 8)) (PRIN1 X STREAM)))

(DEFUN READ-OCTAL-NUMBER (&OPTIONAL STREAM)
  (READ-NUMBER STREAM 8 NIL))

(DEFUN PRINT-OCTAL-NUMBER-OR-NIL (X STREAM)
  (AND X (PRINT-OCTAL-NUMBER X STREAM)))

(DEFUN READ-OCTAL-NUMBER-OR-NIL (&OPTIONAL STREAM)
  (READ-NUMBER STREAM 8 T))

(DEFPROP :OCTAL-INTEGER
	 (PRINT-OCTAL-NUMBER READ-OCTAL-INTEGER NIL
	  NIL NIL "Click left to enter a new integer, base eight, from the keyboard, middle to edit the current value.")
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFPROP :OCTAL-INTEGER-OR-NIL
	 (PRINT-OCTAL-NUMBER-OR-NIL READ-OCTAL-INTEGER-OR-NIL NIL
	  NIL NIL "Click left to enter a new integer, base eight, or Return, from the keyboard, middle to edit the current value.")
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFUN READ-DECIMAL-INTEGER (&OPTIONAL STREAM)
  (READ-INTEGER STREAM 10. NIL))

(DEFUN READ-DECIMAL-INTEGER-OR-NIL (&OPTIONAL STREAM)
  (READ-INTEGER STREAM 10. T))

(DEFUN READ-OCTAL-INTEGER (&OPTIONAL STREAM)
  (READ-INTEGER STREAM 8 NIL))

(DEFUN READ-OCTAL-INTEGER-OR-NIL (&OPTIONAL STREAM)
  (READ-INTEGER STREAM 8 T))

(DEFPROP :TIME-INTERVAL-60THS (PRINT-INTERVAL-60THS READ-INTERVAL-60THS NIL NIL NIL
			       "Click left to input a time interval.")
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFUN PRINT-INTERVAL-60THS (INTERVAL STREAM)
  (TIME:PRINT-INTERVAL-OR-NEVER (ROUND INTERVAL 60.) STREAM))

(DEFUN READ-INTERVAL-60THS (STREAM &OPTIONAL OR-NIL)
  (READ-TOKEN STREAM OR-NIL #'PARSE-INTERVAL-60THS))

(DEFUN PARSE-INTERVAL-60THS (STRING)
  (SI:WITH-PARSE-FERROR (TIME:PARSE-ERROR)
    (* (TIME:TIME-INTERVAL-TO-SECONDS STRING) 60.)))

;If :DECIMAL-NUMBER could take arguments....this wouldn't be needed
(DEFPROP :DECIMAL-NUMBER-OR-NONE
	 (PRINT-DECIMAL-NUMBER-OR-NONE READ-DECIMAL-NUMBER-OR-NONE NIL
	  NIL NIL "Click left to enter a new number, base ten, or /"None/", from the keyboard, middle to edit the current value.")
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFUN PRINT-DECIMAL-NUMBER-OR-NONE (VALUE STREAM)
  (IF VALUE (PRINT-DECIMAL-NUMBER VALUE STREAM)
      (PRINC "None" STREAM)))

(DEFUN READ-DECIMAL-NUMBER-OR-NONE (STREAM)
  (READ-TOKEN STREAM NIL
	      #'(LAMBDA (STRING)
		  (IF (STRING-EQUAL STRING "None") NIL
		      (LET ((NUMBER (IGNORE-ERRORS (LET ((IBASE 10.))
						     (READ-FROM-STRING STRING)))))
			(IF (NUMBERP NUMBER)
			    NUMBER
			    (PARSE-FERROR "A decimal number or /"None/" is required.")))))))

(DEFUN (:MENU-ALIST CHOOSE-VARIABLE-VALUES-KEYWORD-FUNCTION) (KWD-AND-ARGS)
  (VALUES 'PRINC
	  NIL
	  (SECOND KWD-AND-ARGS)
	  #'(LAMBDA (ITEM) (IF (ATOM ITEM) ITEM (CAR ITEM)))	;like MENU-ITEM-STRING
	  #'(LAMBDA (ITEM) (MENU-EXECUTE-NO-SIDE-EFFECTS ITEM T))	;complain if bad item
	  'MENU-ITEM-WHO-LINE-DOCUMENTATION))

(DEFPROP :STRING-LIST (PRINT-STRING-LIST READ-STRING-LIST) CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFUN PRINT-STRING-LIST (STRING-LIST STREAM)
  (FORMAT STREAM "~{~A~^, ~}" STRING-LIST))

(DEFPROP :PATHNAME-OR-NIL
	 (PRINC-OR-NIL READ-PATHNAME-STRING-OR-NIL NIL
	  NIL NIL "Click left to enter a new pathname from the keyboard, middle to edit the current value.")
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFUN PRINC-OR-NIL (OBJECT STREAM)
  (WHEN (NOT (NULL OBJECT))
    (PRINC OBJECT STREAM)))

(DEFUN READ-PATHNAME-STRING-OR-NIL (&OPTIONAL STREAM)
  (MULTIPLE-VALUE-BIND (PATHNAME STRING)
      (READ-PATHNAME STREAM NIL NIL T)
    (IF STRING (STRING PATHNAME))))

(DEFPROP :PATHNAME
	 (PRINC READ-PATHNAME-STRING NIL
	  NIL NIL "Click left to enter a new pathname from the keyboard, middle to edit the current value.")
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFUN READ-PATHNAME-STRING (&OPTIONAL STREAM)
  (STRING (READ-PATHNAME STREAM)))

;;;This will accept strings and return them if given, in order to support
;;;WRITE-USER-OPTIONS, which is in need of redesign.
(DEFPROP :PATHNAME-LIST
	 (PRINT-STRING-LIST READ-PATHNAME-LIST NIL
	  NIL NIL "Click left to enter new pathnames from the keyboard, middle to edit the current list.")
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFPROP :STRING-OR-NIL (PRINT-STRING-OR-NIL READLINE-OR-NIL)
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

;; These two called by fs:*known-file-properties*
(DEFUN PARSE-STRING-OR-NIL (STRING &OPTIONAL (START 0) (END (STRING-LENGTH STRING)))
  (LET ((TRIMMED (SUBSTRING STRING START END)))
    (IF (ZEROP (STRING-LENGTH TRIMMED))
	NIL
	TRIMMED)))

;; This is the other one of "these two..."
(DEFUN PRINT-STRING-OR-NIL (STRING STREAM)
  (AND STRING
       (SEND STREAM ':STRING-OUT (STRING STRING))))

(DEFPROP :HOST
	 (PRINT-HOST READ-HOST NIL NIL NIL "Enter the name of a host.")
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFPROP :HOST-OR-LOCAL
	 (PRINT-HOST-OR-LOCAL READ-HOST-OR-LOCAL NIL NIL NIL "Enter the name of a host, or /"Local/".")
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFUN PRINT-HOST (HOST STREAM)
  (IF HOST
      (SEND STREAM :STRING-OUT
	    (OR (SEND-IF-HANDLES HOST :PRETTY-NAME)
		(SEND HOST :NAME)))))

(DEFUN PRINT-HOST-OR-LOCAL (HOST STREAM)
  (IF (EQ HOST NET:LOCAL-HOST)
      (SEND STREAM ':STRING-OUT "Local")
      (PRINT-HOST HOST STREAM)))

(DEFPROP :PATHNAME-HOST
	 (PRINT-HOST READ-PATHNAME-HOST NIL NIL NIL "Enter the name of a pathname host.")
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFUN READ-PATHNAME-HOST (&OPTIONAL STREAM)
  (READ-HOST STREAM NIL NIL :PATHNAME))

(DEFUN READ-HOST-OR-LOCAL (&OPTIONAL STREAM)
  (READ-HOST STREAM NIL NIL :OR-LOCAL))

(DEFPROP :HOST-LIST
	 (PRINT-STRING-LIST READ-HOST-LIST NIL NIL NIL "Enter a list of host names.")
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFPROP :FONT-LIST
	 (PRINT-STRING-LIST READ-FONT-LIST NIL NIL NIL "Enter a list of font names.")
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFPROP :KEYWORD-LIST
	 (FS:PRINT-KEYWORD-LIST READ-KEYWORD-LIST NIL NIL NIL "Enter a list of keywords.")
	 CHOOSE-VARIABLE-VALUES-KEYWORD)

(DEFMETHOD (:DECODE-VARIABLE-TYPE BASIC-CHOOSE-VARIABLE-VALUES) (KWD-AND-ARGS &AUX KEY TEM)
  (SETQ KEY (CAR KWD-AND-ARGS))
  (COND ((EQ KEY ':DOCUMENTATION)
	 (MULTIPLE-VALUE-BIND (PF RF CHOICES GPVF GVVF)
	     (SEND SELF ':DECODE-VARIABLE-TYPE (OR (CDDR KWD-AND-ARGS) '(:EXPRESSION)))
	   (VALUES PF RF CHOICES GPVF GVVF (CADR KWD-AND-ARGS))))
	((SETQ TEM (GET KEY 'CHOOSE-VARIABLE-VALUES-KEYWORD-FUNCTION))
	 (FUNCALL TEM KWD-AND-ARGS))
	((SETQ TEM (GET KEY 'CHOOSE-VARIABLE-VALUES-KEYWORD))
	 (VALUES-LIST TEM))
	(T
	 (FERROR "~S bad keyword in a CHOOSE-VARIABLE-VALUES-WINDOW" KEY))))

;;; Make printing work in environment of owning stack group
(DEFWRAPPER (:REDISPLAY BASIC-CHOOSE-VARIABLE-VALUES) (IGNORE . BODY)
  `(LET ((PACKAGE (SYMEVAL-IN-STACK-GROUP 'PACKAGE STACK-GROUP))
	 (BASE (SYMEVAL-IN-STACK-GROUP 'BASE STACK-GROUP))
	 (CL:*PRINT-RADIX* (SYMEVAL-IN-STACK-GROUP 'CL:*PRINT-RADIX* STACK-GROUP))
	 (PRINLEVEL (SYMEVAL-IN-STACK-GROUP 'PRINLEVEL STACK-GROUP))
	 (PRINLENGTH (SYMEVAL-IN-STACK-GROUP 'PRINLENGTH STACK-GROUP))
	 (READTABLE (SYMEVAL-IN-STACK-GROUP 'READTABLE STACK-GROUP)))
     (UNWIND-PROTECT
       (PROGN (SETF (SHEET-TRUNCATE-LINE-OUT-FLAG) 1)
	      . ,BODY)
       (SETF (SHEET-TRUNCATE-LINE-OUT-FLAG) 0))))

(DEFMETHOD (:DECODE-ITEM-FOR-PRINTING BASIC-CHOOSE-VARIABLE-VALUES)
			(ITEM &AUX STR STYLE (VAR NIL) (K&A NIL) PF RF CHOICES GPVF GVVF)
  (DECLARE (VALUES STR STYLE VAR PF RF CHOICES GPVF GVVF K&A))
  ;; Parse ITEM into label string, font to print that in, variable, and keyword-&-arguments
  (COND ((SI:SOME-STRING ITEM)
	 (SETQ STR ITEM STYLE STRING-STYLE))
	((SYMBOLP ITEM)
	 (SETQ VAR ITEM STR (GET-PNAME VAR) STYLE NAME-STYLE))
	(T (LET* ((IT (CADR ITEM))
		  (SS (SI:SOME-STRING IT))
		  )
	     (SETQ VAR (CAR ITEM)
		 STR (COND (SS (SETQ ITEM (CDR ITEM))
			       SS)
			   ((OR  (NUMBERP IT) (NULL IT))
			    (CAR (SETQ ITEM (CDR ITEM))))
			   (t (GET-PNAME VAR)))
		 STYLE NAME-STYLE
		 K&A (CDR ITEM)))))
  (IF VAR (MULTIPLE-VALUE (PF RF CHOICES GPVF GVVF)
	    (SEND SELF ':DECODE-VARIABLE-TYPE (OR K&A '(:EXPRESSION)))))
  (VALUES str STYLE VAR PF RF CHOICES GPVF GVVF K&A))

(DEFMETHOD (:PRINT-ITEM BASIC-CHOOSE-VARIABLE-VALUES) (ITEM LINE-NO ITEM-NO)
  LINE-NO ITEM-NO ;ignored
  (MULTIPLE-VALUE-BIND (STR STYLE VAR PF IGNORE CHOICES GPVF GVVF K&A)
      (SEND SELF ':DECODE-ITEM-FOR-PRINTING ITEM)
    ;; If there is a prefix label string, print it
    (COND ((NULL STR))
	  ((NUMBERP STR)
	   (SEND SELF ':SET-CURSORPOS STR NIL))
	  (T
	   (WITH-CHARACTER-STYLE (STYLE SELF)
	     (SEND SELF ':STRING-OUT STR)
	     ;; If there are both a label and a value, separate them with a colon
	     (IF VAR (SEND SELF ':STRING-OUT ": ")))))
    ;; If there is a value, print it (under the control of K&A)
    (IF VAR
	(LET ((VAL (IF (SYMBOLP VAR) (SYMEVAL-IN-STACK-GROUP VAR STACK-GROUP) (CAR VAR)))
	      PVAL CVAL)
	  (COND ((NOT CHOICES)
		 (WITH-CHARACTER-STYLE (VALUE-STYLE SELF)
		   (SEND SELF ':ITEM VAL ':VARIABLE-CHOICE PF)))
		(T
		 (LET ((MULTIPLE (OR (EQ :CHOOSE-MULTIPLE (CAR K&A))
				     (AND (EQ :DOCUMENTATION (CAR K&A))
					  (EQ :CHOOSE-MULTIPLE (CADDR K&A))))))
		   (DOLIST (CHOICE CHOICES)
		     (SETQ PVAL (IF GPVF (FUNCALL GPVF CHOICE) CHOICE)
			   CVAL (IF GVVF (FUNCALL GVVF CHOICE) CHOICE))
		     (WITH-CHARACTER-STYLE ((IF (IF MULTIPLE
						       (MEMBER CVAL VAL)
						       (EQUAL CVAL VAL))
						   SELECTED-CHOICE-STYLE
						   UNSELECTED-CHOICE-STYLE)
					       SELF)
		       (SEND SELF ':ITEM CHOICE ':VARIABLE-CHOICE
			     'CHOOSE-VARIABLE-VALUES-PRINT-FUNCTION PF PVAL)
		       (SEND SELF ':FORWARD-CHAR))))))))))

(DEFUN CHOOSE-VARIABLE-VALUES-PRINT-FUNCTION (ITEM WINDOW PF PVAL)
  ITEM ;ignored
  (FUNCALL PF PVAL WINDOW))

;Extra-width is amount of space to allow for non-menu items to grow
;Stop-X if supplied is a cursor position not be exceeded.  If there are choices then
;the tail of the choice list containing the first choice to pass through that X is returned
(DEFMETHOD (:ITEM-WIDTH BASIC-CHOOSE-VARIABLE-VALUES) (ITEM &OPTIONAL (EXTRA-WIDTH 0)
								      (STOP-X NIL)
						       &AUX (X 0) PREFIX-WIDTH CHOICE-TAIL)
  (DECLARE (VALUES ITEM-WIDTH PREFIX-WIDTH CHOICE-TAIL))
  (MULTIPLE-VALUE-BIND (STR STYLE VAR PF IGNORE CHOICES GPVF GVVF)
      (SEND SELF ':DECODE-ITEM-FOR-PRINTING ITEM)
    (CATCH 'REACHED-STOP-X
      ;; Determine width of label prefix if present
      (COND ((NULL STR))
	    ((NUMBERP STR) (SETQ X STR))
	    (T
	     (SETQ X 
		   (WITH-CHARACTER-STYLE (STYLE SELF)
		     (LET ((X2 (SEND SELF ':STRING-LENGTH STR 0 NIL NIL NIL X)))
		       (IF VAR
			   (SEND SELF ':STRING-LENGTH ": " 0 NIL NIL NIL X2)
			   X2))))))
      (SETQ PREFIX-WIDTH X)
      ;; Determine width of value/choices if present
      (IF VAR
	  (LET ((VAL (IF (SYMBOLP VAR) (SYMEVAL-IN-STACK-GROUP VAR STACK-GROUP) (CAR VAR))))
	    (COND ((NOT CHOICES)
		   (setq x (+ (WITH-CHARACTER-STYLE (VALUE-STYLE SELF)
				(SEND SELF ':STRING-LENGTH
				      (WITH-OUTPUT-TO-STRING (S) (FUNCALL PF VAL S))
				      0 NIL NIL NIL X))
			      EXTRA-WIDTH)))
		  (T (LOOP FOR L ON CHOICES AS CHOICE = (CAR L)
			   AS PVAL = (IF GPVF (FUNCALL GPVF CHOICE) CHOICE)
			   AS CVAL = (IF GVVF (FUNCALL GVVF CHOICE) CHOICE)
			   DO (SETQ X (WITH-CHARACTER-STYLE ((IF (EQUAL CVAL VAL)
								    SELECTED-CHOICE-STYLE
								    UNSELECTED-CHOICE-STYLE)
								SELF)
					(SEND SELF ':STRING-LENGTH
					      (WITH-OUTPUT-TO-STRING (S) (FUNCALL PF PVAL S))
					      0 NIL NIL NIL X)))
			      (AND STOP-X (> X STOP-X)
				   (THROW 'REACHED-STOP-X (SETQ CHOICE-TAIL L)))
			      (INCF X CHAR-WIDTH)))))))
      (VALUES X PREFIX-WIDTH CHOICE-TAIL)))

(DEFMETHOD (:APPROPRIATE-WIDTH BASIC-CHOOSE-VARIABLE-VALUES) (&OPTIONAL EXTRA-WIDTH)
  "Returns the inside-width appropriate to accommodate the current set of variables
   with their current values.  If EXTRA-WIDTH is specified that much room for expansion,
   which can be a number of characters or a string, is left after non-menu items."
  (SETQ EXTRA-WIDTH
	(COND ((STRINGP EXTRA-WIDTH) (SEND SELF ':STRING-LENGTH EXTRA-WIDTH))
	      ((NUMBERP EXTRA-WIDTH) (* CHAR-WIDTH EXTRA-WIDTH))
	      (T 0)))
  (MIN (MAX (SEND SELF ':LABEL-SIZE)
	    (LOOP FOR ITEM BEING THE ARRAY-ELEMENTS OF ITEMS
		  MAXIMIZE (SEND SELF ':ITEM-WIDTH ITEM EXTRA-WIDTH)))
       (- (SHEET-INSIDE-WIDTH SUPERIOR) LEFT-MARGIN-SIZE RIGHT-MARGIN-SIZE
	  2	;Damn, we don't know yet whether we will get wider because of a scroll bar
	  )))

;This is quite a bit slower than it needs to be.  However these windows aren't used much.
 (DEFMETHOD (:WHO-LINE-DOCUMENTATION-STRING BASIC-CHOOSE-VARIABLE-VALUES) ()
  (MULTIPLE-VALUE-BIND (X Y)
      (SHEET-MOUSE-POSITION SELF)
    (MULTIPLE-VALUE-BIND (VALUE TYPE) (SEND SELF ':MOUSE-SENSITIVE-ITEM X Y)
      (AND TYPE
	   (LET ((ITEM (AREF ITEMS (+ TOP-ITEM (// (- Y (SHEET-INSIDE-TOP)) LINE-HEIGHT)))))
	     (IF (ATOM ITEM) "Click left to input a new value from the keyboard, middle to edit the current value."
		 (SETQ ITEM (CDR ITEM))
		 (AND (OR (SI:SOME-STRING (CAR ITEM)) (NUMBERP (CAR ITEM)) (NULL (CAR ITEM)))
		      (SETQ ITEM (CDR ITEM)))
		 (MULTIPLE-VALUE-BIND (IGNORE RF IGNORE IGNORE IGNORE DOC)
		     (SEND SELF ':DECODE-VARIABLE-TYPE (OR ITEM '(:EXPRESSION)))
		   (COND ((SI:SOME-STRING DOC) DOC)
			 ((AND DOC (FUNCALL DOC VALUE)))
			 ((NULL RF) "Click left to change to this value.")
			 (T "Click left to input a new value from the keyboard, middle to edit the current value.")))))))))

(DEFMETHOD (:MOUSE-CLICK BASIC-CHOOSE-VARIABLE-VALUES) (BUTTON X Y &AUX VALUE TYPE LINE-NO)
  (COND ((OR (CHAR-MOUSE-EQUAL BUTTON #\MOUSE-L-1) (CHAR-MOUSE-EQUAL BUTTON #\MOUSE-M-1))
	 (MULTIPLE-VALUE (VALUE TYPE) (SEND SELF ':MOUSE-SENSITIVE-ITEM X Y))
	 (COND (TYPE
		(SETQ LINE-NO (// (- Y (SHEET-INSIDE-TOP)) LINE-HEIGHT))
		(SEND SELF ':FORCE-KBD-INPUT
			   (LIST TYPE SELF (AREF ITEMS (+ TOP-ITEM LINE-NO))
				 VALUE LINE-NO BUTTON))
		T)))))

;Called when a :VARIABLE-CHOICE message comes back through the io-buffer
;This is not a message, so that instance-variables won't be bound in it
;This is assumed to be called in the relevant stack group and binding environment
(DEFUN CHOOSE-VARIABLE-VALUES-CHOICE (WINDOW ITEM CHOICE LINE-NO
				      &OPTIONAL (BUTTON #\MOUSE-L)
				      &AUX FCN OLDVAL NEWVAL NO-CHANGE REDIS)
  (MULTIPLE-VALUE-BIND (STR FONTNO VAR PF RF CHOICES GPVF GVVF K&A)
      (SEND WINDOW ':DECODE-ITEM-FOR-PRINTING ITEM)
    FONTNO CHOICES GPVF				;not used
    (COND ((NOT (NULL RF))			;Not "menu" case
	   (MULTIPLE-VALUE (NEWVAL REDIS NO-CHANGE)
	     (WITH-CHARACTER-STYLE ((SEND WINDOW :NAME-STYLE) WINDOW)
	       (LET ((BL (SHEET-FOLLOWING-BLINKER WINDOW))
		     (WS (SEND WINDOW ':STATUS)))
		 (UNWIND-PROTECT
		     (PROGN (SEND WINDOW ':SELECT)
			    ;; Next line makes the mouse highlight go away
			    (SEND WINDOW ':SET-SENSITIVE-ITEM-TYPES NIL)
			    (BLINKER-SET-VISIBILITY BL ':BLINK)
			    (SEND WINDOW ':SET-CURSORPOS
				  (COND ((NULL STR) 0)
					((NUMBERP STR) STR)
					(T (+ (SEND WINDOW ':STRING-LENGTH (STRING STR))
					      (SEND WINDOW ':STRING-LENGTH ": "))))
				  (* LINE-NO (SHEET-LINE-HEIGHT WINDOW)))
			    (SEND WINDOW ':CLEAR-REST-OF-LINE)
			    (IF (LISTP RF) (SETQ NEWVAL (FUNCALL (CAR RF) WINDOW))
				;; Hair for over-rubout => save old value
				(DO ((CH) (FULL-RUBOUT T) (REDISPLAY-FLAG NIL)
				     (TERMINAL-IO WINDOW))	;Should be ERROR-OUTPUT
				    ((NOT FULL-RUBOUT))
				  (DECLARE (SPECIAL REDISPLAY-FLAG))
				  ;; Check for over-rubout except in Mouse-middle case
				  (AND (NOT (CHAR-MOUSE-EQUAL BUTTON #\MOUSE-M-1))
				       (CHAR= (SETQ CH (SEND WINDOW ':TYI)) #\RUBOUT)
				       (RETURN (SETQ NO-CHANGE T)))
				  (AND CH (SEND WINDOW ':UNTYI CH))
				  (MULTIPLE-VALUE (NEWVAL FULL-RUBOUT)
				    ;; Call the rubout handler.  If mouse-middle, 
				    ;; we need to prime the IE with the old value
				    ;; of the object, printed with the normal
				    ;; printing function.
				    (SEND WINDOW ':RUBOUT-HANDLER
					  (IF (CHAR-MOUSE-EQUAL BUTTON #\MOUSE-M)
					      `((:FULL-RUBOUT T)
						(:SUPPRESS-NOTIFICATION T)
						(:ACTIVATION MEMQ (#\END #\RETURN #\LINE))
						(:INITIAL-INPUT
						  ,(WITH-OUTPUT-TO-STRING
						     (OUTPUT-STREAM)
						     (FUNCALL PF
							      (IF (SYMBOLP VAR) (SYMEVAL VAR)
								  (CDR VAR))
							      OUTPUT-STREAM))))
						; Not mouse-m.  Normal IE call.
					      '((:FULL-RUBOUT T)
						(:SUPPRESS-NOTIFICATION T)
						(:ACTIVATION MEMQ (#\END #\RETURN #\LINE))))
					  #'(LAMBDA (RF STREAM)
					      (CONDITION-BIND ((ERROR 'CVV-INTERNAL-HANDLER))
						(VALUES (FUNCALL RF STREAM))))
					  RF WINDOW))
				  ;; If we got a read error, try to avoid garbage in the display
				  ;; This is really a kludge, is there a better way?
				  (SETQ REDIS REDISPLAY-FLAG))))
		   (BLINKER-SET-VISIBILITY BL NIL)
		   (SEND WINDOW ':SET-SENSITIVE-ITEM-TYPES T)
		   (OR (EQ WS ':SELECTED) (SEND WINDOW ':SET-STATUS WS))))
	       (VALUES NEWVAL REDIS NO-CHANGE))))
	  (T (SETQ NEWVAL CHOICE)))
    (AND GVVF (SETQ NEWVAL (FUNCALL GVVF NEWVAL)))
    (SETQ OLDVAL (IF (SYMBOLP VAR)
		     (SYMEVAL VAR)
		     (CAR VAR)))
    (IF NO-CHANGE
	(SETQ NEWVAL OLDVAL)
	(WHEN (OR (EQ :CHOOSE-MULTIPLE (CAR K&A))
		  (AND (EQ :DOCUMENTATION (CAR K&A))
		       (EQ :CHOOSE-MULTIPLE (CADDR K&A))))
	  (IF (MEMBER NEWVAL OLDVAL)
	      (SETQ NEWVAL (REMQ NEWVAL OLDVAL))
	      (SETQ NEWVAL (CONS NEWVAL OLDVAL)))))
    (IF (SYMBOLP VAR)
	(SET VAR NEWVAL)
	(RPLACA VAR NEWVAL))
    (OR (AND (SETQ FCN (SEND WINDOW ':FUNCTION))
	     (FUNCALL FCN WINDOW VAR OLDVAL NEWVAL))
	;; Redisplay
	(LET ((LAST-LINE-CLOBBERED
		(1+ (IF (NULL RF) LINE-NO	;If menu always one line, otherwise could have cr'ed
			(// (- (SHEET-CURSOR-Y WINDOW) (SHEET-INSIDE-TOP WINDOW))
			    (SHEET-LINE-HEIGHT WINDOW)))))
	      (N-LINES (// (SHEET-INSIDE-HEIGHT WINDOW) (SHEET-LINE-HEIGHT WINDOW))))
	  (AND (OR (AND RF ( LAST-LINE-CLOBBERED LINE-NO))	;wrap-around => full redisplay
		   REDIS)
	       (SETQ LAST-LINE-CLOBBERED N-LINES
		     LINE-NO 0))
	  ;; Need to redisplay all lines that pertain to the same variable
	  (LOOP FOR LN FROM 0 BELOW N-LINES
		WITH ITEMS = (SEND WINDOW ':ITEMS)
		AS ITEM-NO FROM (SEND WINDOW ':Y-SCROLL-POSITION)
			   BELOW (ARRAY-ACTIVE-LENGTH ITEMS)
		AS ITEM = (AREF ITEMS ITEM-NO)
		DO (MULTIPLE-VALUE-BIND (IGNORE IGNORE VAR1)
		       (SEND WINDOW ':DECODE-ITEM-FOR-PRINTING ITEM)
		     (IF (EQ VAR1 VAR)
			 (SETQ LINE-NO (MIN LINE-NO LN)
			       LAST-LINE-CLOBBERED (MAX LAST-LINE-CLOBBERED (1+ LN))))))
	  (SHEET-FORCE-ACCESS (WINDOW T)
	    ;; :REDISPLAY doesn't erase first, so erase those lines
	    (SEND WINDOW ':DRAW-RECTANGLE
		  (SHEET-INSIDE-WIDTH WINDOW)
		  (* (- LAST-LINE-CLOBBERED LINE-NO) (SHEET-LINE-HEIGHT WINDOW))
		  0 (* LINE-NO (SHEET-LINE-HEIGHT WINDOW)) :ERASE)
	    (SEND WINDOW ':REDISPLAY LINE-NO LAST-LINE-CLOBBERED))))))

(DEFUN CVV-INTERNAL-HANDLER (IGNORE)
  (DECLARE (SPECIAL REDISPLAY-FLAG))
  (SETQ REDISPLAY-FLAG T)
  NIL)

;;; Redisplay a single choice item, when you know its value has been changed elsewhere
(DEFMETHOD (:REDISPLAY-VARIABLE BASIC-CHOOSE-VARIABLE-VALUES) (VARIABLE)
  (DO ((I 0 (1+ I))
       (NITEMS (ARRAY-ACTIVE-LENGTH ITEMS))
       (ITEM))
      (( I NITEMS)
       (FERROR "~S is not a variable in ~S" VARIABLE SELF))
    (AND (EQ VARIABLE (IF (ATOM (SETQ ITEM (AREF ITEMS I))) ITEM (CAR ITEM)))
	 (LET ((LINE-NO (- I TOP-ITEM)))
	   (COND ((AND ( I 0) (< I (SHEET-NUMBER-OF-INSIDE-LINES)))
		  (SEND SELF ':DRAW-RECTANGLE (SHEET-INSIDE-WIDTH) LINE-HEIGHT
			     0 (* LINE-NO LINE-HEIGHT) :ERASE)
		  (SEND SELF ':REDISPLAY LINE-NO (1+ LINE-NO))))
	   (RETURN NIL)))))

(DEFFLAVOR CHOOSE-VARIABLE-VALUES-PANE-MIXIN () (PANE-MIXIN))
(DEFFLAVOR CHOOSE-VARIABLE-VALUES-PANE
	()
	(CHOOSE-VARIABLE-VALUES-PANE-MIXIN CHOOSE-VARIABLE-VALUES-WINDOW))

;;; Let it be determined by the superior
(DEFMETHOD (:ADJUSTABLE-SIZE-P CHOOSE-VARIABLE-VALUES-PANE-MIXIN) ()
  NIL)

;;; Even though we the vertical and horizontal dimensions are independent, this gives
;;; what we prefer.
(DEFMETHOD (:PANE-SIZE BASIC-CHOOSE-VARIABLE-VALUES) (REM-WIDTH REM-HEIGHT
						      IGNORE IGNORE STACKING)
  (SELECTQ STACKING
    (:VERTICAL (MIN REM-HEIGHT
		    (+ TOP-MARGIN-SIZE BOTTOM-MARGIN-SIZE
		       (* (ARRAY-ACTIVE-LENGTH ITEMS) LINE-HEIGHT))))
    (:HORIZONTAL (MIN REM-WIDTH
		      (+ LEFT-MARGIN-SIZE RIGHT-MARGIN-SIZE
			 (SEND SELF ':APPROPRIATE-WIDTH))))))

(DEFFLAVOR TEMPORARY-CHOOSE-VARIABLE-VALUES-WINDOW ()
	   (TEMPORARY-WINDOW-MIXIN CHOOSE-VARIABLE-VALUES-WINDOW)
	   (:DEFAULT-INIT-PLIST :BORDERS *DROP-SHADOW-BORDERS-SPEC*))

(DEFMETHOD (:NAME-FOR-SELECTION TEMPORARY-CHOOSE-VARIABLE-VALUES-WINDOW) ()
  NIL)

(COMPILE-FLAVOR-METHODS CHOOSE-VARIABLE-VALUES-WINDOW
			TEMPORARY-CHOOSE-VARIABLE-VALUES-WINDOW
			CHOOSE-VARIABLE-VALUES-PANE)

(DEFWINDOW-RESOURCE TEMPORARY-CHOOSE-VARIABLE-VALUES-WINDOW ()
	:MAKE-WINDOW (TEMPORARY-CHOOSE-VARIABLE-VALUES-WINDOW)
	:INITIAL-COPIES 0)

;; This is the handy-dandy user interface to the above
;; Options are:
;; :LABEL  Window label (default is "Choose Variable Values")
;; :FUNCTION  Function called if user changes anything (default is NIL)
;; :NEAR-MODE  Where to appear the window (default is (:MOUSE))
;; :WIDTH  Desired width of window.  Default is to set wide enough for items.
;; :EXTRA-WIDTH  Amount of extra width to allow for growing items.  Default 10 characters.
;;   Both of the above widths may be a number of characters or a string.
;; :MAX-LINES  Maximum number of lines of window before we have to use scrolling.
;; :MARGIN-CHOICES  List of elements.  A string is the label for the
;;		box which means "exit" (Default is "Exit"), list of
;;		a string and a form means eval that form if box clicked upon.
;; :SUPERIOR  Window to put under, default is MOUSE-SHEET or the superior
;;	      of the window it is supposed to be near, like MENU-CHOOSE

(DEFUN CHOOSE-VARIABLE-VALUES (VARIABLES &KEY (LABEL "Choose Variable Values")
					      FUNCTION
					      (NEAR-MODE '(:MOUSE))
					      WIDTH
					      (EXTRA-WIDTH 10.)
					      (MAX-LINES CHOOSE-VARIABLE-VALUES-MAX-LINES)
					      MARGIN-CHOICES
					      SUPERIOR
			       &AUX OSW)
  ;; Decide what superior to use
  (UNLESS SUPERIOR
    (SETQ SUPERIOR (IF (EQ (CAR NEAR-MODE) ':WINDOW) (SHEET-SUPERIOR (CADR NEAR-MODE))
		       (MOUSE-DEFAULT-SUPERIOR))))
  ;; MARGIN-CHOICES must always contain a "exit" box so user can stop choosing
  (DO ((L MARGIN-CHOICES (CDR L)))
      ((NULL L) (PUSH "Exit" MARGIN-CHOICES))
    (COND ((SI:SOME-STRING (CAR L)) (RETURN))
	  ((OR (ATOM (CAR L)) (NOT (SI:SOME-STRING (CAAR L))))
	   (FERROR "~S garbage in MARGIN-CHOICES" (CAR L)))))
  (DOLIST (ELEM VARIABLES)  ;Make sure all variables are bound, while in caller's environment
    (IF (LISTP ELEM)
	(SETQ ELEM (CAR ELEM)))
    (COND ((SYMBOLP ELEM) (SYMEVAL ELEM))
	  ((TYPEP ELEM ':LOCATIVE) (SETQ ELEM (CAR ELEM)))	;Force compiler
	  ((SI:SOME-STRING ELEM))
	  (T (FERROR "~S is a ~S; a symbol, a locative, or a string is required"
		     ELEM (DATA-TYPE ELEM)))))
  (USING-RESOURCE (WINDOW TEMPORARY-CHOOSE-VARIABLE-VALUES-WINDOW SUPERIOR)
    (SETQ MARGIN-CHOICES
	  (MAPCAR #'(LAMBDA (X)
		      (LIST (IF (ATOM X) X (CAR X))
			    NIL
			    #'(LAMBDA (WINDOW BOX REGION YPOS)
				REGION YPOS	;ignored
				(SEND WINDOW :FORCE-KBD-INPUT `(:CHOICE-BOX ,WINDOW ,BOX)))
			    NIL NIL
			    (IF (ATOM X) NIL (CADR X))))
		  MARGIN-CHOICES))
    (SEND WINDOW ':SETUP VARIABLES LABEL FUNCTION MARGIN-CHOICES)
    (COND ((SI:SOME-STRING WIDTH)
	   (SETQ WIDTH (SEND WINDOW ':STRING-LENGTH WIDTH)))
	  ((NUMBERP WIDTH)
	   (SETQ WIDTH (* (SHEET-CHAR-WIDTH WINDOW) WIDTH)))
	  ((NULL WIDTH)
	   (SETQ WIDTH (SEND WINDOW ':APPROPRIATE-WIDTH EXTRA-WIDTH))))
    (SEND WINDOW ':ADJUST-GEOMETRY-FOR-NEW-VARIABLES WIDTH MAX-LINES)
    (SETQ OSW (CONSOLE-SELECTED-WINDOW (SHEET-CONSOLE WINDOW)))
    (UNWIND-PROTECT
      (PROGN
	(SEND WINDOW ':CLEAR-INPUT)
	(DELAYING-SCREEN-MANAGEMENT
	  (EXPOSE-WINDOW-NEAR WINDOW NEAR-MODE)
	  (SEND WINDOW ':SELECT))
	(DO () (NIL)
	  (SEND WINDOW :INPUT-WAIT "Choose"
		#'(LAMBDA (WINDOW) (NOT (SEND WINDOW :EXPOSED-P)))
		WINDOW)
	  (COND ((NOT (SEND WINDOW :EXPOSED-P))
		 (RETURN))
		((SEND WINDOW :LISTEN)
		 (WHEN (CHOOSE-VARIABLE-VALUES-PROCESS-MESSAGE WINDOW (SEND WINDOW :ANY-TYI))
		   (RETURN)))))
	NIL)
      (DELAYING-SCREEN-MANAGEMENT
	;; Only deselect the old window if the CVV window is still selected.  If the user
	;; used the mouse or Select key to select some other window, then don't select
	;; the old one.
	(LET ((STILL-SELECTED (EQ WINDOW (CONSOLE-SELECTED-WINDOW (SHEET-CONSOLE WINDOW)))))
	  (SEND WINDOW ':DEACTIVATE)
	  (WHEN (AND OSW STILL-SELECTED)
	    (SEND OSW ':SELECT NIL)))))))

(DEFUN CHOOSE-VARIABLE-VALUES-PROCESS-MESSAGE (WINDOW MSG)
  ;; Returns T if message is "exit", else does variable-changing or special action
  ;; and returns NIL.  msg is either a list that came in whose cadr is
  ;; this window, or it is a regular character; only #\REFRESH is used.
  (PROG ()
    (COND ((LISTP MSG)
	   (SELECTQ (CAR MSG)
	     (:CHOICE-BOX
	      (SETQ MSG (SIXTH (THIRD MSG)))	;NIL if done or form to eval
	      (IF (NULL MSG) (RETURN T) (EVAL MSG)))
	     (:VARIABLE-CHOICE
	      (APPLY #'CHOOSE-VARIABLE-VALUES-CHOICE (CDR MSG)))
	     (:MOUSE-BUTTON
	      (BEEP))
	     (OTHERWISE (FERROR "~S unknown message from ~S" MSG WINDOW))))
	  ((CHARACTERP MSG)
	   (IF (CHAR= MSG #\REFRESH)
	       (SEND WINDOW ':REFRESH)
	       (BEEP))))))

;;; User program macro interface

(DEFMACRO DEFINE-USER-OPTION-ALIST (ALIST &OPTIONAL CONSTRUCTOR)
  `(PROGN 'COMPILE
     ,@(AND CONSTRUCTOR
	    `((DEFPROP ,CONSTRUCTOR DEFVAR ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)
	      (DEFMACRO ,CONSTRUCTOR (OPTION DEFAULT &OPTIONAL TYPE NAME &REST ARGS)
		`(DEFINE-USER-OPTION (,OPTION ,',ALIST) ,DEFAULT ,TYPE ,NAME . ,ARGS))))
     (DEFVAR ,ALIST NIL :LOCALIZE T)))

(DEFMACRO DEFINE-USER-OPTION ((OPTION ALIST) DEFAULT &OPTIONAL TYPE NAME &REST ARGS)
  `(PROGN 'COMPILE
     (DEFVAR ,OPTION ,DEFAULT ,NAME)
     (DEFINE-USER-OPTION-1 ',OPTION ',ALIST ,OPTION ',(OR TYPE ':EXPRESSION)
			   ',(OR NAME (SI:MAKE-COMMAND-NAME OPTION)) . ,ARGS)))

(DEFUN DEFINE-USER-OPTION-1 (OPTION ALIST DEFAULT TYPE NAME &REST ARGS)
  (PUTPROP OPTION DEFAULT 'DEFAULT-VALUE)
  (LET ((ELEM (ASSQ OPTION (SYMEVAL ALIST))))
    (AND ELEM (SET ALIST (DELQ ELEM (SYMEVAL ALIST)))))
  (PUSH (LIST* OPTION NAME TYPE (COPYLIST ARGS))
	(SYMEVAL ALIST)))

(DEFUN RESET-USER-OPTIONS (ALIST)
  (DO ((X ALIST (CDR X))
       (SYM))
      ((NULL X))
    (SETQ SYM (CAAR X))
    (SET SYM (GET SYM 'DEFAULT-VALUE))))

(DEFUN CHOOSE-USER-OPTIONS (ALIST &REST ARGS)
  (LEXPR-FUNCALL #'CHOOSE-VARIABLE-VALUES ALIST ARGS))

;;; Output all values that aren't the default
(DEFUN WRITE-USER-OPTIONS (ALIST STREAM &AUX (SI:PRINT-READABLY T))
  (DO ((ALIST ALIST (CDR ALIST))
       (OPTION) (DEFAULT) (VALUE))
      ((NULL ALIST))
    (SETQ OPTION (CAAR ALIST)
	  DEFAULT (PRINTABLE-USER-OPTION (GET OPTION 'DEFAULT-VALUE))
	  VALUE (PRINTABLE-USER-OPTION (SYMEVAL OPTION)))
    (OR (SI:CASE-SENSITIVE-EQUAL VALUE DEFAULT)
	(CL:PPRINT `(LOGIN-SETQ ,OPTION ,(IF (OR (NUMBERP VALUE) (MEMQ VALUE '(T NIL)))
					     VALUE `',VALUE))
		   STREAM))))

(DEFUN PRINTABLE-USER-OPTION (OBJECT)
  (TYPECASE OBJECT
    ((:STRING :NUMBER :SYMBOL) OBJECT)
    (:LIST (CONS (PRINTABLE-USER-OPTION (CAR OBJECT))
		 (PRINTABLE-USER-OPTION (CDR OBJECT))))
    (:INSTANCE (STRING OBJECT))			;pathnames, hosts, etc.
    (T (FERROR "Object not representable in readable character form: ~S" OBJECT))))

;;; Site dependent versions
(DEFMACRO DEFINE-SITE-USER-OPTION ((OPTION ALIST) KEYWORD &OPTIONAL TYPE NAME &REST ARGS)
  `(PROGN 'COMPILE
     (DEFINE-USER-OPTION-1 ',OPTION ',ALIST NIL ',(OR TYPE ':EXPRESSION)
			   ',(OR NAME (SI:MAKE-COMMAND-NAME OPTION)) . ,ARGS)
     (DEFVAR ,OPTION)
     (ADD-INITIALIZATION ,(FORMAT NIL "SITE:~A" OPTION)
			 `(RESET-USER-OPTION ',',OPTION (SI:GET-SITE-OPTION ',',KEYWORD))
			 '(SITE))))

;;; Change the default value of an option
(DEFUN RESET-USER-OPTION (OPTION VALUE)
  (SET OPTION VALUE)
  (PUTPROP OPTION VALUE 'DEFAULT-VALUE))

;;; A :MENU-ALIST type variable whose alist changes
(DEFMACRO DEFINE-SITE-ALIST-USER-OPTION ((OPTION ALIST) NAME MENU-ALIST &OPTIONAL DEFAULT)
  `(PROGN 'COMPILE
     (DEFINE-USER-OPTION-1 ',OPTION ',ALIST NIL ':MENU-ALIST
			   ',(OR NAME (SI:MAKE-COMMAND-NAME OPTION))
			   ,MENU-ALIST)
     (DEFVAR ,OPTION)
     (ADD-INITIALIZATION ,(FORMAT NIL "SITE:~A" OPTION)
			 `(RESET-ALIST-USER-OPTION ',',OPTION ,',ALIST ,',MENU-ALIST
						   ',',DEFAULT)
			 '(SITE))))

;; Sets the entry for OPTION in ALIST to a subset of the items in MENU-ALIST.  Items in
;; MENU-ALIST are selected as being applicable by having a :SITE-KEYWORD which appears in
;; the site file.  One of the items in MENU-ALIST is selected as the default by having a
;; :DEFAULT-SITE-KEYWORD which matches the entry in the site file named DEFAULT.  If no
;; default is specified in the site file, then the first of the selected items is chosen
;; as the default.

(DEFUN RESET-ALIST-USER-OPTION (OPTION ALIST MENU-ALIST DEFAULT)
  (AND DEFAULT
       (SETQ DEFAULT (SI:GET-SITE-OPTION DEFAULT)))
  (LOOP FOR ELEM IN MENU-ALIST
	AS SITE-KEYWORD = (OR (AND (LISTP (CDR ELEM)) (GET ELEM ':SITE-KEYWORD))
			      (MENU-EXECUTE-NO-SIDE-EFFECTS ELEM))
	AS DEFAULT-SITE-KEYWORD = (OR (AND (LISTP (CDR ELEM))
					   (GET ELEM ':DEFAULT-SITE-KEYWORD))
				      SITE-KEYWORD)
	WHEN (NOT (NULL (SI:GET-SITE-OPTION SITE-KEYWORD)))
	COLLECT ELEM INTO NEW-ALIST
	WITH DEFAULT-ELEM
	WHEN (EQ DEFAULT-SITE-KEYWORD DEFAULT)
	DO (SETQ DEFAULT-ELEM ELEM)
	FINALLY (AND DEFAULT-ELEM (SETQ NEW-ALIST (CONS DEFAULT-ELEM
							(DELQ DEFAULT-ELEM NEW-ALIST))))
		(SETQ MENU-ALIST NEW-ALIST))
  (LET ((ELEM (ASSQ OPTION ALIST)))
    (SETF (FOURTH ELEM) MENU-ALIST))
  (RESET-USER-OPTION OPTION (AND MENU-ALIST
				 (MENU-EXECUTE-NO-SIDE-EFFECTS (CAR MENU-ALIST)))))

(DEFMACRO RESTRICT-USER-OPTION (OPTION RESTRICTION-TYPE &REST SITE-KEYWORDS &AUX IF IF-NOT)
  (SETQ SITE-KEYWORDS (COPYLIST SITE-KEYWORDS))
  (SELECTQ RESTRICTION-TYPE
    (:IF (SETQ IF SITE-KEYWORDS))
    (:UNLESS (SETQ IF-NOT SITE-KEYWORDS))
    (:NEVER (SETQ IF-NOT T)))
  `(DEFPROP ,OPTION ,(OR IF IF-NOT)
	    ,(IF IF 'SITE-KEYWORDS-RESTRICTION 'NOT-SITE-KEYWORDS-RESTRICTION)))

;;; This removes all user options that are restricted or choices with less than two
;;; possibilities.
(DEFUN PRUNE-USER-OPTION-ALIST (ALIST)
  (LOOP FOR ELEM IN ALIST
	AS OPTION = (CAR ELEM)
	WITH TEM
	UNLESS (OR (AND (NOT (NULL (SETQ TEM (GET OPTION 'NOT-SITE-KEYWORDS-RESTRICTION))))
			(OR (EQ TEM T)
			    (LOOP FOR KEY IN TEM
				  THEREIS (SI:GET-SITE-OPTION KEY))))
		   (AND (NOT (NULL (SETQ TEM (GET OPTION 'SITE-KEYWORDS-RESTRICTION))))
			(NOT (LOOP FOR KEY IN TEM
				   ALWAYS (SI:GET-SITE-OPTION KEY))))
		   (AND (MEMQ (THIRD ELEM) '(:ASSOC :MENU-ALIST))
			(NULL (CDR (FOURTH ELEM)))))
	COLLECT ELEM))
