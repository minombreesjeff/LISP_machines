;;; -*- Mode: LISP; Package: TV; Base: 8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(DEFMACRO DEFINE-OLD-SHEET-FUNCTION (FUNCTION OLD-ARGLIST MESSAGE &REST MESSAGE-ARGS)
  `(PROGN 
     (COMPILER:MAKE-OBSOLETE ,FUNCTION ,(FORMAT NIL "use the :~A message" MESSAGE))
     (DEFUN ,FUNCTION (.SHEET. . ,OLD-ARGLIST)
       (SEND .SHEET. ',MESSAGE . ,MESSAGE-ARGS))))

(DEFINE-OLD-SHEET-FUNCTION SHEET-BACKSPACE () :TYO #\BS)
(DEFINE-OLD-SHEET-FUNCTION SHEET-CHARACTER-WIDTH (CHAR FONT) :CHARACTER-WIDTH CHAR FONT)
(DEFINE-OLD-SHEET-FUNCTION SHEET-CLEAR () :CLEAR-WINDOW)
(DEFINE-OLD-SHEET-FUNCTION SHEET-CLEAR-BETWEEN-CURSORPOSES (START-X START-Y END-X END-Y)
  :CLEAR-BETWEEN-CURSORPOSES START-X START-Y END-X END-Y)
(DEFINE-OLD-SHEET-FUNCTION SHEET-CLEAR-CHAR (&OPTIONAL CHAR) :CLEAR-CHAR CHAR)
(DEFINE-OLD-SHEET-FUNCTION SHEET-CLEAR-EOF () :CLEAR-REST-OF-WINDOW)
(DEFINE-OLD-SHEET-FUNCTION SHEET-CLEAR-EOL () :CLEAR-REST-OF-LINE)
;;; Note order of arguments change
(DEFINE-OLD-SHEET-FUNCTION SHEET-COMPUTE-MOTION (X Y STRING &OPTIONAL (START 0)
						 END CR-AT-END-P (STOP-X 0) (STOP-Y NIL)
						 BOTTOM-LIMIT RIGHT-LIMIT)
  :COMPUTE-MOTION STRING START END X Y CR-AT-END-P STOP-X STOP-Y BOTTOM-LIMIT RIGHT-LIMIT)
(DEFINE-OLD-SHEET-FUNCTION SHEET-CRLF () :TYO #\CR)
(DEFINE-OLD-SHEET-FUNCTION SHEET-DELETE-CHAR (&OPTIONAL (CHAR-COUNT 1) (TYPE ':CHARACTER))
  :DELETE-CHAR CHAR-COUNT TYPE)
(DEFINE-OLD-SHEET-FUNCTION SHEET-DELETE-LINE (&OPTIONAL (LINE-COUNT 1))
  :DELETE-LINE LINE-COUNT)
(DEFINE-OLD-SHEET-FUNCTION SHEET-DELETE-STRING (STRING &OPTIONAL (START 0) END)
  :DELETE-STRING STRING START END)
(DEFINE-OLD-SHEET-FUNCTION SHEET-DISPLAY-CENTERED-STRING
			   (STRING &OPTIONAL (LEFT 0)
				   (RIGHT (SHEET-INSIDE-WIDTH .SHEET.))
				   (Y-POS (- (SHEET-CURSOR-Y .SHEET.)
					     (SHEET-INSIDE-TOP .SHEET.))))
  :DISPLAY-CENTERED-STRING STRING LEFT RIGHT Y-POS)
(DEFINE-OLD-SHEET-FUNCTION SHEET-DISPLAY-X-Y-CENTERED-STRING
			   (STRING &OPTIONAL (LEFT 0) (TOP 0)
				   (RIGHT (SHEET-INSIDE-WIDTH .SHEET.))
				   (BOTTOM (SHEET-INSIDE-HEIGHT .SHEET.))
				   (FNT (SHEET-CURRENT-FONT .SHEET.)))
  :DISPLAY-X-Y-CENTERED-STRING STRING LEFT TOP RIGHT BOTTOM FNT)
(DEFINE-OLD-SHEET-FUNCTION SHEET-HANDLE-EXCEPTIONS () :HANDLE-EXCEPTIONS)
(DEFINE-OLD-SHEET-FUNCTION SHEET-HOME () :HOME-CURSOR)
(DEFINE-OLD-SHEET-FUNCTION SHEET-HOME-DOWN () :HOME-DOWN)
(DEFINE-OLD-SHEET-FUNCTION SHEET-INSERT-CHAR (&OPTIONAL (CHAR-COUNT 1)
							(TYPE ':CHARACTER))
  :INSERT-CHAR CHAR-COUNT TYPE)
(DEFINE-OLD-SHEET-FUNCTION SHEET-INSERT-LINE (&OPTIONAL (LINE-COUNT 1))
  :INSERT-LINE LINE-COUNT)
(DEFINE-OLD-SHEET-FUNCTION SHEET-INSERT-STRING (STRING &OPTIONAL (START 0) END (TYPE-TOO T))
  :INSERT-STRING STRING START END TYPE-TOO)
(DEFINE-OLD-SHEET-FUNCTION SHEET-LINE-OUT (STRING &OPTIONAL (START 0) END SET-XPOS SET-YPOS
						  DWID)
  :EDITOR-LINE-OUT STRING START END SET-XPOS SET-YPOS DWID)
(DEFINE-OLD-SHEET-FUNCTION SHEET-READ-CURSORPOS () :READ-CURSORPOS)
(DEFINE-OLD-SHEET-FUNCTION SHEET-SET-CURSORPOS (X Y) :SET-CURSORPOS X Y)
(COMPILER:MAKE-OBSOLETE SHEET-SET-FONT "use character styles instead")
(DEFINE-OLD-SHEET-FUNCTION SHEET-SPACE (&OPTIONAL CHAR) :FORWARD-CHAR CHAR)
(DEFINE-OLD-SHEET-FUNCTION SHEET-STRING-LENGTH (STRING &OPTIONAL (START 0) END STOP-X FONT
						       (START-X 0) (MAX-X 0))
  :STRING-LENGTH STRING START END STOP-X FONT START-X MAX-X)
(DEFINE-OLD-SHEET-FUNCTION SHEET-STRING-OUT (STRING &OPTIONAL (START 0) END)
  :STRING-OUT STRING START END)
(DEFINE-OLD-SHEET-FUNCTION SHEET-STRING-OUT-EXPLICIT (STRING X Y XLIM FONT ALU
						      &OPTIONAL (START 0) END)
  :STRING-OUT-EXPLICIT STRING X Y XLIM FONT ALU START END)
(DEFINE-OLD-SHEET-FUNCTION SHEET-TAB () :TYO #\TAB)
(DEFINE-OLD-SHEET-FUNCTION SHEET-TYO (CHAR) :TYO CHAR)



(DEFMETHOD (:BEEP SHEET) (&OPTIONAL BEEP-TYPE)
  (AND SUPERIOR (SEND SUPERIOR ':BEEP BEEP-TYPE)))


(DEFMETHOD (:READ-CURSORPOS SHEET) (&OPTIONAL (UNIT ':PIXEL))
  (LET ((X (- CURSOR-X (SHEET-INSIDE-LEFT)))
	(Y (- CURSOR-Y (SHEET-INSIDE-TOP))))
    (SELECTQ UNIT
      (:PIXEL)
      (:CHARACTER
	(SETQ X (// X CHAR-WIDTH)
	      Y  (// Y LINE-HEIGHT)))
      (OTHERWISE
	(FERROR NIL "~S is not a known unit." UNIT)))
    (VALUES X Y)))

(DEFMETHOD (:SET-CURSORPOS SHEET) (X Y &OPTIONAL (UNIT ':PIXEL))
  "Set 'cursor' position of a sheet in terms of raster units.  Cursorposes are relative
to the left and top margins.  Cursorpos is `clipped' to stay inside the sheet-inside."
  (CL:ECASE UNIT
    (:PIXEL)
    (:CHARACTER
     (WHEN X (SETQ X (* X CHAR-WIDTH)))
     (WHEN Y (SETQ Y (* Y LINE-HEIGHT)))))
  (X-LOCK-SHEET (SELF :ALLOW-OUTPUT T) ()
    (SETQ X (IF X (MIN (+ (MAX (FIX X) 0) (SHEET-INSIDE-LEFT))
		       (SHEET-INSIDE-RIGHT))
		CURSOR-X))
    (SETQ Y (IF Y (MIN (+ (MAX (FIX Y) 0) (SHEET-INSIDE-TOP))
		       (SHEET-INSIDE-BOTTOM))
		CURSOR-Y))
    (UNLESS (AND (= CURSOR-X X) (= CURSOR-Y Y))	;Not moving, don't open the blinker
      (WITH-SCREEN-CONTROLLER-LOCK (SCREEN)
	(LET ((BL (SHEET-FOLLOWING-BLINKER SELF)))
	  (WHEN BL (OPEN-BLINKER BL))
	  (WHEN MORE-VPOS				;If more processing enabled, delay until
	    (SETQ MORE-VPOS (SHEET-DEDUCE-MORE-VPOS)))	; bottom of sheet
	  (UNLESS (= Y CURSOR-Y)
	    (SETQ CURRENT-LINE-HEIGHT LINE-HEIGHT
		  CURRENT-BASELINE BASELINE))
	  (SETQ CURSOR-X X)
	  (SETQ CURSOR-Y Y)
	  (SETF (SHEET-EXCEPTIONS) 0)
	  (WHEN (> (+ Y LINE-HEIGHT) (SHEET-INSIDE-BOTTOM))
	    (SETF (SHEET-END-PAGE-FLAG) 1))
	  T)))))

(DEFMETHOD (:INCREMENT-CURSORPOS SHEET) (DX DY &OPTIONAL (UNIT ':PIXEL))
  (IF (NOT DX) (SETQ DX 0))
  (IF (NOT DY) (SETQ DY 0))
  (SELECTQ UNIT
    (:PIXEL)
    (:CHARACTER
     (IF (NOT (ZEROP DX))
	 (SETQ DX (- (* DX CHAR-WIDTH)
		     (\ (- CURSOR-X (SHEET-INSIDE-LEFT)) CHAR-WIDTH))))
     (IF (NOT (ZEROP DY))
	 (SETQ DY (- (* DY LINE-HEIGHT)
		     (\ (- CURSOR-Y (SHEET-INSIDE-TOP)) LINE-HEIGHT)))))
    (OTHERWISE
     (FERROR "~S is not a known unit." UNIT)))
  (LOCK-SHEET (SELF)
    (UNLESS (ZEROP (SHEET-EXCEPTIONS)) (SEND SELF ':HANDLE-EXCEPTIONS))
    (UNLESS (ZEROP DY)
      (SETQ CURRENT-LINE-HEIGHT LINE-HEIGHT
	    CURRENT-BASELINE BASELINE))
    (SHEET-INCREMENT-BITPOS DX DY)))

(DEFMETHOD (:HOME-CURSOR SHEET) ()
  "Go to upper left edge of sheet (Home up)"
  (LOCK-SHEET (SELF)
    (AND MORE-VPOS				;If MORE processing, put it off 'til last line
	 (SETQ MORE-VPOS (SHEET-DEDUCE-MORE-VPOS)))
    (SETQ CURSOR-X (SHEET-INSIDE-LEFT))
    (SETQ CURSOR-Y (SHEET-INSIDE-TOP))
    (SETQ CURRENT-LINE-HEIGHT LINE-HEIGHT
	  CURRENT-BASELINE BASELINE)
    (SETF (SHEET-END-PAGE-FLAG) 0)
    (SETF (SHEET-MORE-FLAG) 0)
    (SETF (SHEET-LINE-HEIGHT-CHANGE-FLAG) 0)))

(DEFMETHOD (:FORWARD-CHAR SHEET) (&OPTIONAL CHAR)
  "Space forward"
  (LOCK-SHEET (SELF)
    (UNLESS (ZEROP (SHEET-EXCEPTIONS)) (SEND SELF ':HANDLE-EXCEPTIONS))
    (SHEET-INCREMENT-BITPOS (IF CHAR (SEND SELF ':CHARACTER-WIDTH-IN-FONT CHAR) CHAR-WIDTH)
			    0)))

(DEFMETHOD (:CLEAR-CHAR SHEET) (&OPTIONAL CHAR)
  "Clear current character position"
  (PREPARE-SHEET (SELF)
    (OR (ZEROP (SHEET-EXCEPTIONS)) (SEND SELF ':HANDLE-EXCEPTIONS))
    (SHEET-DRAW-RECTANGLE (MIN (- (SHEET-INSIDE-RIGHT) CURSOR-X)
			       (IF CHAR
				   (SEND SELF ':CHARACTER-WIDTH-IN-FONT CHAR)
				   CHAR-WIDTH))
			  (MIN (- (SHEET-INSIDE-BOTTOM) CURSOR-Y) CURRENT-LINE-HEIGHT)
			  CURSOR-X CURSOR-Y ERASE-ALUF)))

(DEFMETHOD (:CLEAR-REST-OF-LINE SHEET) ()
  "Clear to the end of the current line"
  (PREPARE-SHEET (SELF)
    ;; Note that this need not handle **MORE** exception, because the **more**
    ;; would bash the line this is clearing anyway.  We don't want to **more**
    ;; if the next operation is going to be tyi.
    (OR (ZEROP (SHEET-END-PAGE-FLAG)) (SEND SELF ':HANDLE-EXCEPTIONS))
    (SHEET-DRAW-RECTANGLE (MAX (- (SHEET-INSIDE-RIGHT) CURSOR-X)
			       0)
			  (MIN (- (SHEET-INSIDE-BOTTOM) CURSOR-Y) CURRENT-LINE-HEIGHT)
			  CURSOR-X CURSOR-Y ERASE-ALUF)))

(DEFMETHOD (:CLEAR-BETWEEN-CURSORPOSES SHEET) (START-X START-Y END-X END-Y
						       &OPTIONAL (UNIT ':PIXEL)
						       &AUX MID-Y)
  "Erase from starting pos to ending pos
   Does nothing if start is after end on the same line, but if on different
   lines, assumes screen wrap-around"

  ;; This has no right to work on variable-height lines.
  ;; The references to current-line-height merely improve its chances
  ;; of doing what the user intended in such a case; they don't guarantee it.

  (SELECTQ UNIT
    (:PIXEL)
    (:CHARACTER
     (SETQ START-X (* START-X CHAR-WIDTH))
     (SETQ START-Y (* START-Y LINE-HEIGHT))
     (SETQ END-X (* END-X CHAR-WIDTH))
     (SETQ END-Y (* END-Y LINE-HEIGHT)))
    (OTHERWISE
     (FERROR NIL "~S is not a known unit." UNIT)))
  ;; Do clipping
  (SETQ START-X (MIN (+ (MAX START-X 0) (SHEET-INSIDE-LEFT)) (SHEET-INSIDE-RIGHT))
	START-Y (MIN (+ (MAX START-Y 0) (SHEET-INSIDE-TOP)) (SHEET-INSIDE-BOTTOM))
	END-X (MIN (+ (MAX END-X 0) (SHEET-INSIDE-LEFT)) (SHEET-INSIDE-RIGHT))
	END-Y (MIN (+ (MAX END-Y 0) (SHEET-INSIDE-TOP)) (SHEET-INSIDE-BOTTOM)))
  (PREPARE-SHEET (SELF)
    (COND ((= START-Y END-Y)
	   (COND ((< START-X END-X)
		  (SHEET-DRAW-RECTANGLE (- END-X START-X)
					(MIN (- (SHEET-INSIDE-BOTTOM) START-Y)
					     (IF (= START-Y CURSOR-Y)
						 CURRENT-LINE-HEIGHT
						 LINE-HEIGHT))
					START-X START-Y ERASE-ALUF))))
	  (T
	   ;; First delete the rest of the current line.
	   (SHEET-DRAW-RECTANGLE (- (SHEET-INSIDE-RIGHT) START-X) 
				 (MIN (- (SHEET-INSIDE-BOTTOM) START-Y) LINE-HEIGHT)
				 START-X START-Y ERASE-ALUF)
	   ;; Next delete the start of the last line.
	   (SETQ MID-Y (+ START-Y LINE-HEIGHT))
	   (SHEET-DRAW-RECTANGLE (- END-X (SHEET-INSIDE-LEFT))
				 (MIN (- (SHEET-INSIDE-BOTTOM) END-Y)
				      (IF (= END-Y CURSOR-Y)
					  CURRENT-LINE-HEIGHT
					  LINE-HEIGHT))
				 (SHEET-INSIDE-LEFT) END-Y ERASE-ALUF)
	   ;; Finally, delete everything in between.
	   (IF (< START-Y END-Y)
	       (AND (< MID-Y END-Y)
		    (SHEET-DRAW-RECTANGLE (SHEET-INSIDE-WIDTH) (- END-Y MID-Y)
					  (SHEET-INSIDE-LEFT) MID-Y ERASE-ALUF))
	       (SHEET-DRAW-RECTANGLE (SHEET-INSIDE-WIDTH)
				     (- (SHEET-INSIDE-BOTTOM) MID-Y)
				     (SHEET-INSIDE-LEFT) MID-Y ERASE-ALUF)
	       (SHEET-DRAW-RECTANGLE (SHEET-INSIDE-WIDTH)
				     (- END-Y (SHEET-INSIDE-TOP))
				     (SHEET-INSIDE-LEFT) (SHEET-INSIDE-TOP)
				     ERASE-ALUF))))))

(DEFMETHOD (:CLEAR-WINDOW SHEET) (&OPTIONAL (MARGINS-P NIL))
  (PREPARE-SHEET (SELF)
    (SEND SELF ':HOME-CURSOR)			;Handles any exceptions
    (IF MARGINS-P
	(SHEET-DRAW-RECTANGLE WIDTH HEIGHT 0 0 ERASE-ALUF)
	(SHEET-DRAW-RECTANGLE (SHEET-INSIDE-WIDTH) (SHEET-INSIDE-HEIGHT)
			      (SHEET-INSIDE-LEFT) (SHEET-INSIDE-TOP)
			      ERASE-ALUF))
    (SCREEN-MANAGE-FLUSH-KNOWLEDGE SELF)))

(DEFMETHOD (:CLEAR-REST-OF-WINDOW SHEET) (&AUX HT TEM)
  "Clear from the cursor to the end of the window"
  (PREPARE-SHEET (SELF)
    (UNLESS (ZEROP (SHEET-EXCEPTIONS)) (SEND SELF ':HANDLE-EXCEPTIONS))
    (SEND SELF ':CLEAR-REST-OF-LINE)
    (WHEN (PLUSP (SETQ HT (- (SHEET-INSIDE-BOTTOM)
			     (SETQ TEM (+ CURSOR-Y CURRENT-LINE-HEIGHT)))))
      (SHEET-DRAW-RECTANGLE (SHEET-INSIDE-WIDTH) HT
			    (SHEET-INSIDE-LEFT) TEM
			    ERASE-ALUF))))

(DEFMETHOD (:HOME-DOWN SHEET) ()
  "Place cursor at beginning of last line on sheet"
  (SEND SELF ':SET-CURSORPOS
	0 (* LINE-HEIGHT (1- (// (SHEET-INSIDE-HEIGHT) LINE-HEIGHT)))))

(DEFMETHOD (:INSERT-LINE SHEET) (&OPTIONAL (LINE-COUNT 1) (UNIT ':CHARACTER))
  "Make room for a line before the line the cursor is currently on"
  (PREPARE-SHEET (SELF)
    (LET* ((WID (SHEET-INSIDE-WIDTH))
	   (HGT (SELECTQ UNIT
		  (:CHARACTER (IF ( LINE-COUNT 0)
				  0
				  (+ (* (1- LINE-COUNT) LINE-HEIGHT) CURRENT-LINE-HEIGHT)))
		  (:PIXEL LINE-COUNT)
		  (OTHERWISE (FERROR NIL "~S is not a known unit." UNIT))))
	   ;; Compute minus height of block to BLT
	   (DELTA-HEIGHT
	     (- HGT (- (SELECTQ UNIT
			 (:CHARACTER (* LINE-HEIGHT (SHEET-NUMBER-OF-INSIDE-LINES)))
			 (:PIXEL (SHEET-INSIDE-HEIGHT)))
		       (- CURSOR-Y (SHEET-INSIDE-TOP))))))
      (UNLESS ( DELTA-HEIGHT 0)		;If some bits to move, move them
	(SHEET-BITBLT ALU-SETA
		      WID DELTA-HEIGHT
		      NIL (SHEET-INSIDE-LEFT) CURSOR-Y
		      NIL (SHEET-INSIDE-LEFT) (+ CURSOR-Y HGT)))
      (SHEET-DRAW-RECTANGLE WID HGT
			    (SHEET-INSIDE-LEFT) CURSOR-Y
			    ERASE-ALUF))))

(DEFMETHOD (:DELETE-LINE SHEET) (&OPTIONAL (LINE-COUNT 1) (UNIT ':CHARACTER))
  (PREPARE-SHEET (SELF)
    (LET* ((WID (SHEET-INSIDE-WIDTH))
	   (HGT (SELECTQ UNIT
		  (:CHARACTER (IF ( LINE-COUNT 0)
				  0
				(+ (* (1- LINE-COUNT) LINE-HEIGHT) CURRENT-LINE-HEIGHT)))
		  (:PIXEL LINE-COUNT)
		  (OTHERWISE (FERROR NIL "~S is not a known unit." UNIT))))
	   (DELTA-HEIGHT (- (+ (- CURSOR-Y (SHEET-INSIDE-TOP)) HGT)
			    (SELECTQ UNIT
			      (:CHARACTER (* LINE-HEIGHT (SHEET-NUMBER-OF-INSIDE-LINES)))
			      (:PIXEL (SHEET-INSIDE-HEIGHT))))))
      (WHEN (PLUSP DELTA-HEIGHT)
	(FERROR NIL "Illegal line-count ~S for ~S" LINE-COUNT SELF))
      (SHEET-BITBLT ALU-SETA WID (- DELTA-HEIGHT)
		    NIL (SHEET-INSIDE-LEFT) (+ CURSOR-Y HGT)
		    NIL (SHEET-INSIDE-LEFT) CURSOR-Y)
      (SHEET-DRAW-RECTANGLE WID HGT
			    (SHEET-INSIDE-LEFT) (- CURSOR-Y DELTA-HEIGHT)
			    ERASE-ALUF))))

(DEFMETHOD (:INSERT-CHAR SHEET) (&OPTIONAL (CHAR-COUNT 1) (UNIT ':CHARACTER))
  "Make room for characters after cursor.  Is only correct for fixed width fonts"
  (PREPARE-SHEET (SELF)
    (LET ((WID (SELECTQ UNIT
		 (:PIXEL CHAR-COUNT)
		 (:CHARACTER (* CHAR-COUNT CHAR-WIDTH))
		 (OTHERWISE (FERROR NIL "~S is not a known unit." UNIT)))))
      (WHEN (< (+ CURSOR-X WID) (SHEET-INSIDE-RIGHT))
	(SHEET-BITBLT ALU-SETA
		      (- WID (- (SHEET-INSIDE-RIGHT) CURSOR-X))
		      CURRENT-LINE-HEIGHT
		      NIL CURSOR-X CURSOR-Y
		      NIL (+ CURSOR-X WID) CURSOR-Y))
      (SHEET-DRAW-RECTANGLE (MIN WID (- (SHEET-INSIDE-WIDTH) CURSOR-X)) CURRENT-LINE-HEIGHT
			    CURSOR-X CURSOR-Y
			    ERASE-ALUF))))

(DEFMETHOD (:DELETE-CHAR SHEET) (&OPTIONAL (CHAR-COUNT 1) (UNIT :CHARACTER))
  "Delete characters after cursor.  Is only correct for fixed width fonts"
  (LET* ((PIXELS (CL:ECASE UNIT
		   (:PIXEL CHAR-COUNT)
		   (:CHARACTER (* CHAR-COUNT CHAR-WIDTH))))
	 (REMAIN (- (SHEET-INSIDE-RIGHT) CURSOR-X PIXELS)))
    (WHEN (MINUSP REMAIN)
      (SETF PIXELS (+ PIXELS REMAIN))
      (SETF REMAIN 0))
    (PREPARE-SHEET (SELF)
      (WHEN (PLUSP REMAIN)
	(SHEET-BITBLT ALU-SETA REMAIN CURRENT-LINE-HEIGHT
		      NIL (+ CURSOR-X PIXELS) CURSOR-Y
		      NIL CURSOR-X CURSOR-Y))
      (SHEET-DRAW-RECTANGLE PIXELS CURRENT-LINE-HEIGHT
			    (+ CURSOR-X REMAIN) CURSOR-Y ERASE-ALUF))))

;;; :INSERT-STRING and :DELETE-STRING only work if STRING does not contain
;;; any newline characters.  They are essentially an interface to
;;; :INSERT-CHAR and :DELETE-CHAR which deal correctly with fonts.

(DEFMETHOD (:INSERT-STRING SHEET) (STRING &OPTIONAL (START 0) END (TYPE-ALSO T))
  (LET* ((INSIDE-X (- CURSOR-X (SHEET-INSIDE-LEFT)))
	 LENGTH)
    (COND ((CHARACTERP STRING)
	   (SETQ LENGTH (SEND SELF :CHARACTER-WIDTH-IN-FONT STRING))
	   (SETQ STRING (STRING STRING)))
	  (T
	   (SETQ LENGTH (- (SEND SELF :STRING-LENGTH STRING START END NIL NIL INSIDE-X)
			   INSIDE-X))))
    (SEND SELF :INSERT-CHAR LENGTH :PIXEL)
    (IF TYPE-ALSO (SEND SELF :STRING-OUT STRING START END))))

(DEFMETHOD (:DELETE-STRING SHEET) (STRING &OPTIONAL (START 0) END)
  (LET* ((INSIDE-X (- CURSOR-X (SHEET-INSIDE-LEFT)))
	 (LENGTH (IF (CHARACTERP STRING)
		     (SEND SELF :CHARACTER-WIDTH-IN-FONT STRING)
		     (- (SEND SELF :STRING-LENGTH STRING START END NIL NIL INSIDE-X)
			INSIDE-X))))
    (SEND SELF :DELETE-CHAR LENGTH :PIXEL)))

;; Returns the number of pixels to the next tab stop.
;; X must be in outside window coordinates

(DEFUN-IN-FLAVOR (NEXT-TAB-DISTANCE SHEET) (X)
  (LET ((TAB-WIDTH (SHEET-TAB-WIDTH)))
    (- TAB-WIDTH (\ (- X (SHEET-INSIDE-LEFT)) TAB-WIDTH))))

;; Eventually *lozenge-style* will just be (:fix :roman (:smaller than current-style))
(DEFVAR *LOZENGE-STYLE* (SI:PARSE-CHARACTER-STYLE '(:FIX :UPPERCASE :VERY-SMALL)))

;; Get baseline of lozenged characters.
(DEFMACRO SHEET-LOZENGE-BASELINE (SHEET)
  (IGNORE SHEET)
  10.)

;; Must be called with the sheet prepared
(DEFUN-IN-FLAVOR (SHEET-LOZENGED-STRING-WIDTH SHEET) (STRING-OR-STRING-LENGTH
						       &OPTIONAL SUPPRESS-LOZENGE)
  (+ (* (COND ((STRINGP STRING-OR-STRING-LENGTH) (STRING-LENGTH STRING-OR-STRING-LENGTH))
	      ((NUMBERP STRING-OR-STRING-LENGTH) STRING-OR-STRING-LENGTH)
	      (T 0))
	6)
     (IF SUPPRESS-LOZENGE 0 10.)))

(DEFMETHOD (:LOZENGED-STRING-WIDTH SHEET) (STRING)
  (PREPARE-SHEET (SELF)
    (SHEET-LOZENGED-STRING-WIDTH STRING)))

(DEFUN-IN-FLAVOR (SHEET-DISPLAY-LOZENGED-STRING-INTERNAL SHEET)
		 (STRING X0 Y0 XLIM ALUF &OPTIONAL SUPPRESS-LOZENGE)
  (LET ((WID (SHEET-LOZENGED-STRING-WIDTH STRING SUPPRESS-LOZENGE))
	(ADJ (- (SHEET-GET-TOP-OF-FONT
		  (SI:GET-FONT (SHEET-DISPLAY-DEVICE-TYPE SELF) SI:*STANDARD-CHARACTER-SET*
			       *LOZENGE-STYLE* NIL)))))
    (WHEN (> BASELINE 10.)
      ;;Put the lozenge on the baseline.  Don't hang it from the line above.
      (INCF Y0 (- BASELINE 10.)))
    (IF SUPPRESS-LOZENGE
	(LET ((X1 (MIN (+ X0 WID) XLIM)))
	  (SEND SELF :STRING-OUT-EXPLICIT-INTERNAL STRING X0 (+ Y0 4 ADJ) X1 ALUF
		0 NIL *LOZENGE-STYLE*)
	  X1)
      ;; Put the string then the box around it
      (LET ((X1 (1- (MIN (+ X0 WID) XLIM)))
	    (Y1 (+ Y0 8)))
	;; Check for the case where not even the diamond will fit and draw nothing
	(WHEN ( (- X1 X0) 8)
	  (SEND SELF :STRING-OUT-EXPLICIT-INTERNAL STRING (+ X0 5)
		(+ Y0 2 ADJ) (- X1 3) ALUF 0 NIL *LOZENGE-STYLE*)
	  (SHEET-DRAW-RECTANGLE (- X1 X0 7) 1 (+ X0 4) Y0 ALUF)
	  (SHEET-DRAW-RECTANGLE (- X1 X0 7) 1 (+ X0 4) Y1 ALUF)
	  (SHEET-DRAW-LINE X0 (+ Y0 4) (+ X0 3) (1+ Y0) ALUF T)
	  (SHEET-DRAW-LINE (1+ X0) (+ Y0 5) (+ X0 3) (1- Y1) ALUF T)
	  (SHEET-DRAW-LINE X1 (+ Y0 4) (- X1 3) (1+ Y0) ALUF T)
	  (SHEET-DRAW-LINE (1- X1) (+ Y0 5) (- X1 3) (1- Y1) ALUF T))
	(1+ X1)))))

(DEFUN-IN-FLAVOR (SHEET-DISPLAY-LOZENGED-STRING SHEET) (STRING &OPTIONAL SUPPRESS-LOZENGE)
  "Must be called with sheet prepared"
  (LET ((WID (SHEET-LOZENGED-STRING-WIDTH STRING SUPPRESS-LOZENGE)))
    ;; Make sure there is enough room on the line, if not CRLF and
    ;; hope the sheet isn't too narrow.  Relies on the fact that handling
    ;; of all exceptions leaves you no further to the right than you were
    ;; (usually at the left margin).
    (COND ((> (+ CURSOR-X WID)
	      (IF (ZEROP (SHEET-RIGHT-MARGIN-CHARACTER-FLAG))
		  (SHEET-INSIDE-RIGHT)
		  (- (SHEET-INSIDE-RIGHT) CHAR-WIDTH)))
	   (SEND SELF ':END-OF-LINE-EXCEPTION)))
    (SETQ CURSOR-X
	  (SHEET-DISPLAY-LOZENGED-STRING-INTERNAL STRING CURSOR-X (1+ CURSOR-Y)
						  (SHEET-INSIDE-RIGHT) CHAR-ALUF
						  SUPPRESS-LOZENGE))))

;This is a kludge for ZWEI:WITH-EXTENDED-SEARCH-DISPLAY
;The second value is an even worse kludge to suppress drawing the lozenge.
;This is to make up for lack of obese characters in the editor.
;Maybe instead of this, these defun-methods should have been methods
;No, these characters should have been a character-set.  --RWK
(DEFVAR-RESETTABLE *FUNNY-CHAR-HOOK* NIL)

(DEFUN-IN-FLAVOR (SHEET-TYO-FUNNY-CHAR SHEET) (CHAR)
  (UNLESS (AND (ZEROP (CHAR-BITS CHAR))
	       (COND ((AND (CHAR-EQUAL CHAR #\CR) (ZEROP (SHEET-CR-NOT-NEWLINE-FLAG)))
		      (SETQ CURSOR-X (SHEET-INSIDE-LEFT))
		      (SHEET-INCREMENT-BITPOS 0 CURRENT-LINE-HEIGHT)
		      (SETQ CURRENT-LINE-HEIGHT LINE-HEIGHT
			    CURRENT-BASELINE BASELINE)
		      (SEND SELF ':CLEAR-REST-OF-LINE)
		      'T)
		     ((CHAR-EQUAL CHAR #\TAB)
		      (SHEET-INCREMENT-BITPOS (NEXT-TAB-DISTANCE CURSOR-X) 0)
		      'T)
		     ((AND (CHAR-EQUAL CHAR #\BS)
			   (ZEROP (SHEET-BACKSPACE-NOT-OVERPRINTING-FLAG)))
		      (SHEET-INCREMENT-BITPOS (- CHAR-WIDTH) 0)
		      'T)
		     (T
		      (LET ((CODE (CHAR-CODE CHAR)))
			;; Handle non spacing graphic characters here.  These are specially
			;; treated in a way that keeps fixed width fonts fixed.
			;; Would also handle any other graphic characters above #o200, of
			;; which there aren't any now.
			(WHEN (AND ( #o300 CODE #o317)
				   (NOT (OR (= CODE #o300) (= CODE #o311))))
			  (LET ((FONT (SHEET-GET-CHAR-FONT CHAR)))
			    (WHEN FONT
			      (LET ((LEN (FONT-FILL-POINTER FONT))
				    (CET (FONT-CHARS-EXIST-TABLE FONT))
				    (FIT (FONT-INDEXING-TABLE FONT))
				    (CWT (FONT-CHAR-WIDTH-TABLE FONT)))
				(WHEN (OR ;; Fixed width.
					  (AND (NULL CET) (NULL FIT) (NULL CWT) (= LEN #o200)
					       ( (DECODE-RASTER-ARRAY FONT)
						  (* (1+ CODE) (FONT-RASTER-WIDTH FONT))))
					  ;; Variable width with this position defined.
					  (AND CET (< CODE LEN) (AREF CET CODE)))
				  (LETF (((FONT-FILL-POINTER FONT) #o320))
				    (SHEET-DRAW-GLYPH
				      CODE FONT
				      CURSOR-X (+ CURSOR-Y (SHEET-GET-TOP-OF-FONT FONT))
				      CHAR-ALUF))
				  ;; Fixed width gives width of 0 for this one.
				  (WHEN CWT
				    (INCF CURSOR-X (AREF CWT CODE)))
				  T)))))))))
    (WITH-STACK-ARRAY (TEMP-STRING 50 :TYPE 'ART-FAT-STRING :FILL-POINTER 0)
      (MULTIPLE-VALUE-BIND (STRING SUPPRESS-LOZENGE)
	  (SHEET-TYO-FUNNY-CHAR-INTERNAL CHAR TEMP-STRING)
	(SHEET-DISPLAY-LOZENGED-STRING STRING SUPPRESS-LOZENGE)))))

(DEFUN-IN-FLAVOR (SHEET-TYO-FUNNY-CHAR-INTERNAL SHEET) (CHAR TEMP-STRING)
  (WHEN *FUNNY-CHAR-HOOK*
    (MULTIPLE-VALUE-BIND (STRING FLAG)
	(FUNCALL *FUNNY-CHAR-HOOK* CHAR)
      (WHEN STRING
	(RETURN-FROM SHEET-TYO-FUNNY-CHAR-INTERNAL
	  (VALUES STRING FLAG)))))
  (WITH-OUTPUT-TO-STRING (S TEMP-STRING)
    (WHEN (GRAPHIC-CHAR-P CHAR)			; must be a problem with the style....
      (FORMAT:FORMAT-CHARACTER-STYLE S (SI:CHAR-STYLE CHAR) NIL 'T))
    (FORMAT:FORMAT-CHARACTER-BITS S (CHAR-BITS CHAR) NIL NIL)
    (LET* ((CH (MAKE-CHAR CHAR))
	   (CHNAME (CL:CHAR-NAME CH)))
      (IF CHNAME
	  (SEND S :STRING-OUT CHNAME)
	  (IF (ZEROP (SI:CHAR-CHAR-SET-INDEX CH))
	      (IF (OR (NOT (GRAPHIC-CHAR-P CH))
		      ;; This kludge is for characters that don't have a glyph in the
		      ;; font for the standard TV for style (:fix :uppercase :very-small),
		      ;; or that are illegible in that font
		      (STRING-SEARCH-CHAR CH " ˆ‰ŒŠ/!@[]{}~‡"))
		  (FORMAT S "~3,'0O" (CHAR-CODE CH))
		  (WHEN (LOWER-CASE-P CH)
		    (SEND S :STRING-OUT (IF (ZEROP (CHAR-BITS CHAR))
					    "LOWER-"
					    "SH-")))
		  (SEND S :TYO CH))
	      (MULTIPLE-VALUE-BIND (CHAR-SET INDEX)
		  (SI:CHAR-CHAR-SET-AND-INDEX CH)
		(SEND S :STRING-OUT (SEND CHAR-SET :NAME))
		(SEND S :TYO #/:)
		(FORMAT S "~O" INDEX))))))
  TEMP-STRING)

;;; This code must use the same computation that SHEET-TYO-FUNNY-CHAR uses.
;;; Don't change one without changing the other.

(DEFUN-IN-FLAVOR (SHEET-CHAR-WIDTH-FUNNY-CHAR SHEET) (CHAR &OPTIONAL (X CURSOR-X))
  (BLOCK SPECIAL
    (WHEN (ZEROP (CHAR-BITS CHAR))
      (SELECTOR CHAR CHAR-EQUAL
	(#\RETURN
	 (WHEN (ZEROP (SHEET-CR-NOT-NEWLINE-FLAG))
	   (RETURN-FROM SPECIAL
	     (- (SHEET-INSIDE-LEFT) X))))
	(#\TAB
	 (RETURN-FROM SPECIAL
	   (NEXT-TAB-DISTANCE X)))
	(#\BS
	 (WHEN (ZEROP (SHEET-BACKSPACE-NOT-OVERPRINTING-FLAG))
	   (RETURN-FROM SPECIAL
	     (MINUS CHAR-WIDTH)))))
      (LET ((CODE (CHAR-CODE CHAR)))
	;; Handle non spacing graphic characters here.  These are specially
	;; treated in a way that keeps fixed width fonts fixed.
	;; Would also handle any other graphic characters above #o200, of
	;; which there aren't any now.
	(WHEN (AND ( #o300 CODE #o317)
		   (NOT (OR (= CODE #o300) (= CODE #o311))))
	  (LET ((FONT (SHEET-GET-CHAR-FONT CHAR)))
	    (WHEN FONT
	      (LET ((LEN (FONT-FILL-POINTER FONT))
		    (CET (FONT-CHARS-EXIST-TABLE FONT))
		    (FIT (FONT-INDEXING-TABLE FONT))
		    (CWT (FONT-CHAR-WIDTH-TABLE FONT)))
		(WHEN (AND (NULL CET) (NULL FIT) (NULL CWT) (= LEN #o200)
			   ( (DECODE-RASTER-ARRAY FONT)
			      (* (1+ CODE) (FONT-RASTER-WIDTH FONT))))
		  (RETURN-FROM SPECIAL 0))
		(WHEN (AND CET (< CODE LEN) (AREF CET CODE))
		  (RETURN-FROM SPECIAL (AREF CWT CODE)))))))))
    (WHEN *FUNNY-CHAR-HOOK*
      (MULTIPLE-VALUE-BIND (STRING SUPPRESS-LOZENGE)
	  (FUNCALL *FUNNY-CHAR-HOOK* CHAR)
	(WHEN STRING
	  (RETURN-FROM SPECIAL
	    (SHEET-LOZENGED-STRING-WIDTH STRING SUPPRESS-LOZENGE)))))
    ;; Lozenged string so lets count up characters in lozenge.
    (SHEET-LOZENGED-STRING-WIDTH
      (+ (IF (GRAPHIC-CHAR-P CHAR)		; must be a problem with the style....
	     (FORMAT:FORMAT-CHARACTER-STYLE-WIDTH (SI:CHAR-STYLE CHAR) NIL 'T)
	     0)
	 (FORMAT:FORMAT-CHARACTER-BITS-WIDTH (CHAR-BITS CHAR) NIL NIL)
	 (LET* ((CH (MAKE-CHAR CHAR))
		(CHNAME (CL:CHAR-NAME CH)))
	   (IF CHNAME
	       (STRING-LENGTH CHNAME)
	       (IF (ZEROP (SI:CHAR-CHAR-SET-INDEX CH))
		   (IF (OR (NOT (GRAPHIC-CHAR-P CH))
			   ;; This kludge is for characters that don't have a glyph in the
			   ;; font for the standard TV for style (:fix :uppercase :very-small),
			   ;; or that are illegible in that font
			   (STRING-SEARCH-CHAR CH " ˆ‰ŒŠ/!@[]{}~‡"))
		       3			;3 octal digits
		       (+ (IF (LOWER-CASE-P CH)
			      (IF (ZEROP (CHAR-BITS CHAR))
				  (STRING-LENGTH "LOWER-") (STRING-LENGTH "SH-"))
			      0)
			  1))
		   (MULTIPLE-VALUE-BIND (CHAR-SET INDEX)
		       (SI:CHAR-CHAR-SET-AND-INDEX CH)
		     (+ (STRING-LENGTH (SEND CHAR-SET :NAME))
			1			; #/:
						; someday special case so index of 0 will work.
			(CEILING (HAULONG INDEX) 3))))))))))


(DEFMETHOD (:DISPLAY-LOZENGED-STRING SHEET) (STRING)
  (PREPARE-SHEET (SELF)
    (SHEET-DISPLAY-LOZENGED-STRING STRING)))

(COMPILER:MAKE-OBSOLETE FONT-MAP-FONT-N "Font maps are no longer supported.")
(DEFUN FONT-MAP-FONT-N (&REST IGNORE)
  FONTS:CPTFONT)

(DEFMETHOD (:TYO SHEET) (CHAR &AUX (SECOND-TRY NIL))
  "Draw a printing character in a sheet, or execute a special function"
  (CHECK-ARG CHAR CHARACTERP "a character")
  (PREPARE-SHEET (SELF)
    (PROG ()
       TRY-AGAIN
	  (COND ((PLUSP (SHEET-EXCEPTIONS))
		 ;; Handle the exception.  This can recursively call :TYO if we get a
		 ;; more break (since it has to print "*MORE*").  If the window is small enough,
		 ;; we can get a recursive more break.  Complain in that case.
		 (WHEN SECOND-TRY
		   (FERROR "Could not clear an exception.~@
		       	~S is probably too small to print /"~C/"." SELF CHAR))
		 (SEND SELF :HANDLE-EXCEPTIONS)
		 (SETQ SECOND-TRY T)
		 (GO TRY-AGAIN))
		(T
		 (MULTIPLE-VALUE-BIND (INDEX FONT)
		     (SHEET-GET-CHAR-INDEX-AND-FONT CHAR)
		   (IF (NOT (AND FONT (GRAPHIC-CHAR-P CHAR)))
		       (SHEET-TYO-FUNNY-CHAR CHAR)
		     (LET* ((RIGHT-LIM (SHEET-INSIDE-RIGHT))
			    (CHAR-WIDTHS (FONT-CHAR-WIDTH-TABLE FONT))
			    (WID (IF CHAR-WIDTHS
				     (AREF CHAR-WIDTHS INDEX)
				   (FONT-CHAR-WIDTH FONT))))
		       (OR (ZEROP (SHEET-RIGHT-MARGIN-CHARACTER-FLAG))
			   (SETQ RIGHT-LIM (- RIGHT-LIM CHAR-WIDTH)))
		       (WHEN (> (+ CURSOR-X WID) RIGHT-LIM)
			 ;; END-OF-LINE exception.  Clear it, unless we have
			 ;; already tried and failed (e.g. because the window
			 ;; is too small to print the character).
			 (WHEN SECOND-TRY
			   (FERROR "Could not clear an END-OF-LINE exception.~@
			   	 	  ~S is probably too small to print /"~C/"."
				   SELF CHAR))
			 (SEND SELF :END-OF-LINE-EXCEPTION)
			 (SETQ SECOND-TRY T)
			 (GO TRY-AGAIN))
		       (WHEN (NOT (ZEROP (SHEET-AUTO-LINE-HEIGHT-FLAG)))
			 (LET ((HT (+ (FONT-CHAR-HEIGHT FONT) VSP))
			       (NB (FONT-BASELINE FONT)))
			   (WHEN (> NB CURRENT-BASELINE)
			     (NOTE-LINE-HEIGHT-CHANGE SELF (MAX HT CURRENT-LINE-HEIGHT) NB))))
		       (SHEET-DRAW-GLYPH
			 INDEX FONT CURSOR-X (+ CURSOR-Y (SHEET-GET-TOP-OF-FONT FONT))
			 CHAR-ALUF)
		       (INCF CURSOR-X WID))))))))
  CHAR) 

(DEFMETHOD (:STRING-OUT SHEET) (STRING &OPTIONAL (START 0) END)
  "Routine to print a string on a sheet. Understands format effectors (special
keys 200-237).  Optional starting and ending indices may be supplied.  Default is
to output the whole string."
  (SETQ STRING (STRING STRING))
  (PREPARE-SHEET (SELF)
    (PROG ((I START)
	   (FAT-P (STRING-FAT-P STRING))
	   (N (OR END (ARRAY-ACTIVE-LENGTH STRING)))
	   FONT char-in-font fast-subindex
	   BASE-ADJ XLIM CH DONE-P)
	  
       TOP
	  (WHEN ( I N) (RETURN NIL))		;No exception if done anyway
	  (SETQ XLIM (SHEET-INSIDE-RIGHT))
	  (UNLESS (ZEROP (SHEET-RIGHT-MARGIN-CHARACTER-FLAG))
	    (DECF XLIM CHAR-WIDTH))
	  (SETQ CH (AREF STRING I))
       NEW-FONT
	  (setq char-in-font ch)
	  (SETQ FONT (sheet-get-char-font ch))
	  (unless (and font (graphic-char-p ch)
		       (ZEROP (SHEET-EXCEPTIONS)))	;End of page, MORE
	    (GO TYO))				;Let TYO handle it so no infinite loop here
	  
	  (SETQ FAST-SUBINDEX (IF FAT-P
				  (SI:%CHAR-SUBINDEX-IS-INDEX-P CH)
				'T)
		BASE-ADJ (SHEET-GET-TOP-OF-FONT FONT))

	  (WHEN (< BASE-ADJ 0)
	    (WHEN (NOT (ZEROP (SHEET-AUTO-LINE-HEIGHT-FLAG)))
	      (NOTE-LINE-HEIGHT-CHANGE SELF
				       (MAX CURRENT-LINE-HEIGHT
					    (+ (FONT-CHAR-HEIGHT FONT) VSP))
				       (MAX CURRENT-BASELINE (FONT-BASELINE FONT)))
	      (SETQ BASE-ADJ 0)))
	  (MULTIPLE-VALUE (CURSOR-X I DONE-P)
	    (SHEET-DRAW-STRING SELF CHAR-ALUF CURSOR-X (+ CURSOR-Y BASE-ADJ)
				   STRING FONT I N XLIM))
	  (WHEN DONE-P (RETURN NIL))		;Run do not walk to the nearest exit..
	  
	  ;; Some exception, see what it was
	  (SETQ CH (AREF STRING I))
	  (unless (SI:%CHARs-share-device-font-p CH char-in-font fast-subindex)	;Font change...
	    (GO NEW-FONT))			;Pop back to top to cache info.
	  
	  ;; Funny character (format effector) or reached end of line.
	  ;; Let TYO handle all such weirdnesses.
       TYO (SEND SELF ':TYO CH)
	  (INCF I)
	  ;; Go back to the top to handle the next character
	  ;; Recompute XLIM in case the window size changed during a **more**
	  (GO TOP))))

(defsubst compute-char-width (index char-width-table char-width)
  (if char-width-table
      (aref char-width-table index)
      char-width))

;; Compute the motion that would be caused by outputing a string.
;;  This is used by the editor.
;; In computing the motion, it will chose the font in one of two ways:
;;  If given an ART-FAT-STRING array (16 bit string) like the editor uses,
;;  it will take the font from the %%CH-FONT field (high 8 bits) of the
;;  character.
;;  If given an ART-STRING array (8 bit string), it will take the font from
;;  SHEET-CURRENT-FONT of the sheet.
;; Args are: sheet, X and Y position to start at (NILs here use the current
;;  position of the sheet), string, and optionally the starting and ending indices
;;  and a flag saying to fake a CRLF at end of the string.
;;  Optionally you can give two additional arguments which are the X and Y to stop at,
;;  if not given these default to the end of the sheet.
;;  ACCOUNT-FOR-CONTINUATION-AFTER recognizes the case where characters after the desired
;;  ending index may cause continuation to be output (causing more motion) before that
;;  index.
;; Returns 3 values: FINAL-X, FINAL-Y, and an indication of how far down the
;;  string it got.  this is NIL if the whole string (including the fake
;;  carriage return, if any) was processed without
;;  reaching the stopping point, or the index of the next character to be
;;  processed when the stopping point was reached, or T if the stopping point
;;  was reached after the fake carriage return.
;; *** The interface to this crock should be redesigned.  Also note that the
;; *** exact treatment of STOP-X and STOP-Y does not agree with SHEET-STRING-LENGTH.

(DEFMETHOD (:COMPUTE-MOTION SHEET) (STRING &OPTIONAL (START 0) (END NIL)
 					   X Y CR-AT-END-P (STOP-X 0) STOP-Y
					   BOTTOM-LIMIT RIGHT-LIMIT
					   ACCOUNT-FOR-CONTINUATION-AFTER)
  (DECLARE (VALUES FINAL-X FINAL-Y END-INDEX))
  (SETQ STRING (STRING STRING))
  (PROG (CWA CW CH FONT TEM I N NN II MARGIN-FLAG char-in-font fast-subindex index)
	(OR (ZEROP (SHEET-RIGHT-MARGIN-CHARACTER-FLAG)) (SETQ MARGIN-FLAG T))
	(AND (NULL X) (SETQ X (- CURSOR-X (SHEET-INSIDE-LEFT))))
	(AND (NULL Y) (SETQ Y (- CURSOR-Y (SHEET-INSIDE-TOP))))
	(AND (NULL STOP-Y)
	     (SETQ STOP-Y (1+ (SHEET-INSIDE-HEIGHT))))
	;;   ^-- This 1+ is so can use  rather than >
	(OR RIGHT-LIMIT (SETQ RIGHT-LIMIT (SHEET-INSIDE-WIDTH)))
	(AND MARGIN-FLAG (SETQ RIGHT-LIMIT (- RIGHT-LIMIT CHAR-WIDTH)))
	(AND (NULL BOTTOM-LIMIT)
	     (SETQ BOTTOM-LIMIT (- (SHEET-INSIDE-HEIGHT) CURRENT-LINE-HEIGHT)))
	(SETQ I START
	      N (OR END (ARRAY-ACTIVE-LENGTH STRING))
	      FONT (if (< i n)
		       (SHEET-GET-CHAR-FONT (aref string i))
		       ; This will go to the end test in SCX, and we know that it will
		       ; execute the ( I N) clause.  This clause doesn't depend on font
		       ; being valid, and rechecks that I is a valid index into the array.
		       (go scx)))
     NEW-FONT
	(setq char-in-font (aref string i)
	      fast-subindex (si:%char-subindex-is-index-p char-in-font))
	(when font
	  (setq CW (FONT-CHAR-WIDTH FONT)
		CWA (FONT-CHAR-WIDTH-TABLE FONT)))
	  
	;; At this point, decide whether we can use the fast version.
	(unless (or cwa (string-fat-p string) (not font))
	  ;; Only if it is thin, and a fixed width font.
	  (GO FAST))
	;;This is the slow version.
     SLOW
	(COND ((AND ( Y STOP-Y) ( X STOP-X))	;Reached sticking-point
	       (RETURN (VALUES X Y I)))
	      (( I N)				;If string exhausted
	       (COND (CR-AT-END-P
		      (SETQ X 0 Y (+ Y CURRENT-LINE-HEIGHT))	;CRLF if told to
		      (AND (> Y BOTTOM-LIMIT) (SETQ Y 0)))
		     ;; If there is more of the line to be displayed after where we were
		     ;; told to stop, it may cause continuation to be printed, advancing
		     ;; the cursor before the desired end char is output.
		     ((AND ACCOUNT-FOR-CONTINUATION-AFTER
			   (< N (ARRAY-ACTIVE-LENGTH STRING))	;More of string
			   (> (+ X
				 (SEND SELF
				       ':CHARACTER-WIDTH-IN-FONT
				       (AREF STRING N) NIL (+ X (SHEET-INSIDE-LEFT))))
			      RIGHT-LIMIT))
		      (SETQ X 0 Y (+ Y CURRENT-LINE-HEIGHT))
		      (AND (> Y BOTTOM-LIMIT) (SETQ Y 0))))
	       (RETURN (VALUES X Y (AND ( X STOP-X) ( Y STOP-Y))))))
	(SETQ CH (AREF STRING I))
	(unless (setq index (si:%chars-share-device-font-p ch char-in-font fast-subindex))
	  (multiple-value (index font)
	    (sheet-get-char-index-and-font ch))
	  (go new-font))
	(if (and font (graphic-char-p ch))
	    (incf X (compute-char-width index cwa cw))
	    (setq x (max 0 (+ x (sheet-char-width-funny-char ch (+ (sheet-inside-left) x)))))
	    (when (and (zerop (char-bits ch)) (char-equal ch #\cr))
	       (SETQ Y (+ Y CURRENT-LINE-HEIGHT))
	       (AND (> Y BOTTOM-LIMIT) (SETQ Y 0))))
	(COND ((> X RIGHT-LIMIT)		;If this character doesn't fit, crlf
	       (SETQ X 0 Y (+ Y CURRENT-LINE-HEIGHT))	; and do it again
	       (AND (> Y BOTTOM-LIMIT) (SETQ Y 0)))
	      (T (SETQ I (1+ I))))
	(GO SLOW)
	
	;;Here is the fast loop.  The basic idea is to scan as fast as possible
	;;over printing characters, with all checking outside the loop.
     FAST 
	;;First, decide the most characters we want to scan over in a whack
	(SETQ NN (MIN (+ (// (- (COND (( Y STOP-Y)	;Stop-point is in this line
				       STOP-X)
				      (T RIGHT-LIMIT))	;Stop for this line is margin
				X)
			     CW)
			 I)
		      N))			;NN is limiting value of I
						;Now, scan over printing characters.
	(AND ( (SETQ II I) NN)			;Save initial I, and check for null loop
	     (GO SCX))
	(SETQ TEM #o200)			;This is really a ridiculous bum
     SCN (AND (< (CHAR-CODE (AREF STRING I)) TEM)	;If this is a printing character
	      (< (SETQ I (1+ I)) NN)		; and we haven't reached stop point
	      (GO SCN))				; then continue to loop (9 instructions)
	(SETQ X (+ (* (- I II) CW) X))		;Account for the motion of those chars
     SCX (SETQ NN X)
	(COND ((AND ( Y STOP-Y) ( X STOP-X))	;If reached sticking-point, done.
	       (RETURN (VALUES X Y I)))
	      (( I N)				;If string exhausted
	       (COND (CR-AT-END-P		;Do return X off end of line
		      (SETQ X 0 Y (+ Y CURRENT-LINE-HEIGHT))	;crlf if told to
		      (AND (> Y BOTTOM-LIMIT) (SETQ Y 0)))
		     ((AND ACCOUNT-FOR-CONTINUATION-AFTER
			   (< N (ARRAY-ACTIVE-LENGTH STRING))	;More of string
			   (> (+ X (SEND SELF ':CHARACTER-WIDTH-IN-FONT
					 (AREF STRING N)
					 NIL
					 (+ X (SHEET-INSIDE-LEFT))))
			      RIGHT-LIMIT))
		      (SETQ X 0 Y (+ Y CURRENT-LINE-HEIGHT))
		      (AND (> Y BOTTOM-LIMIT) (SETQ Y 0))))	;
	       (RETURN (VALUES X Y (AND ( X STOP-X) ( Y STOP-Y))))))
	(setq ch (aref string i))
	(if (graphic-char-p ch)
	    (incf x cw)
	    (setq x (max 0 (+ x (sheet-char-width-funny-char ch (+ (sheet-inside-left) x)))))
	    (when (and (zerop (char-bits ch)) (char-equal ch #\CR))
	       (SETQ Y (+ Y CURRENT-LINE-HEIGHT))
	       (AND (> Y BOTTOM-LIMIT) (SETQ Y 0))))
	(COND ((> X RIGHT-LIMIT)		;If this char didn't fit, crlf and do again
	       (SETQ X 0 Y (+ Y CURRENT-LINE-HEIGHT))
	       (AND (> Y BOTTOM-LIMIT) (SETQ Y 0)))
	      (T (SETQ I (1+ I))))
	(GO FAST)))

(DEFMETHOD (:CHARACTER-WIDTH SHEET) (CH &OPTIONAL FONT (X CURSOR-X) STYLE)
  "Returns the width of a character, in raster units.
For backspace, it can return a negative number.
For tab, the number returned depends on the current cursor position.
For return, the result is zero."
  (if FONT
      (SETQ FONT (SEND SCREEN ':PARSE-FONT-DESCRIPTOR FONT))
      (setq font (IF STYLE
		     (SI:LOOKUP-FONT-CACHED
		       CHARSET&STYLEFONT-CACHE
		       (MAKE-CHAR CH 0 0) DISPLAY-DEVICE-TYPE STYLE)
		     (sheet-get-char-font ch))))
  (if (AND FONT (GRAPHIC-CHAR-P CH))		;Ordinary printing character
      (LET ((TEM (FONT-CHAR-WIDTH-TABLE FONT)))
	(IF TEM
	    (AREF TEM (MULTIPLE-VALUE-BIND (NIL INDEX) (SI:CHAR-CHAR-SET-AND-INDEX CH) INDEX))
	    (FONT-CHAR-WIDTH FONT)))
      (SHEET-CHAR-WIDTH-FUNNY-CHAR CH X)))

(DEFMETHOD (:CHARACTER-WIDTH-IN-FONT SHEET) (CH &OPTIONAL FONT (X CURSOR-X))
  "Returns the width of a character, in raster units.
For backspace, it can return a negative number.
For tab, the number returned depends on the current cursor position.
For return, the result is zero."
  (SETQ FONT (or font (sheet-get-char-font ch)))
  (if (AND FONT
	   (GRAPHIC-CHAR-P CH))	;Ordinary printing character
      (LET ((TEM (FONT-CHAR-WIDTH-TABLE FONT)))
	(IF TEM 
	    (AREF TEM (MULTIPLE-VALUE-BIND (NIL INDEX) (SI:CHAR-CHAR-SET-AND-INDEX CH) INDEX))
	    (FONT-CHAR-WIDTH FONT)))
      (SHEET-CHAR-WIDTH-FUNNY-CHAR CH X)))

(DEFMETHOD (:CHARACTER-HEIGHT SHEET) (CH &KEY FONT STYLE)
  "Returns the height of a character, in raster units.
For return, the result is the current line height."
  (if FONT
      (SETQ FONT (SEND SCREEN ':PARSE-FONT-DESCRIPTOR FONT))
      (SETQ FONT (IF STYLE (SI:LOOKUP-FONT (MAKE-CHAR CH 0 0) DISPLAY-DEVICE-TYPE STYLE)
		     (SHEET-GET-CHAR-FONT CH))))
  (if (AND FONT (GRAPHIC-CHAR-P CH))		;Ordinary printing character
      (FONT-CHAR-HEIGHT FONT)
    CURRENT-LINE-HEIGHT))


;;; This is like (SHEET :COMPUTE-MOTION), but in one dimension only.  Returned values are
;;; X, I, and MAX-X.  X is the cursor position when all characters are processed.  I is
;;; the index of the next character to be processed; I is the length of the string (or
;;; END) unless STOP-X is specified in which case it may be the index of the character
;;; which would have made the cursor > STOP-X.  MAX-X is the greatest value that X ever
;;; attained; it can be different from X if there are backspaces or newlines in the
;;; string.  If there are newlines in the string, then it is the length of the last line.
(DEFMETHOD (:STRING-LENGTH SHEET) (STRING &OPTIONAL (START 0) (END NIL) (STOP-X NIL)
					  STYLE (START-X 0) (MAX-X 0))
  (DECLARE (VALUES FINAL-X INDEX MAX-X FINAL-Y TOTAL-HEIGHT BASELINE))
  (SETQ STRING (STRING STRING))
  (PROG (CWA CW CH TEM I N NN II (X START-X)
	 FONT fast-index char-in-font index
	 (Y 0) (CLH LINE-HEIGHT) (CLB BASELINE)
	 (style-of-string (IF style
			      (si:merge-character-styles style merged-current-style)
			      merged-current-style)))
	(SETQ I START
	      N (OR END (ARRAY-ACTIVE-LENGTH STRING)))
	(when ( i n) (go done))
	(setq font (si:lookup-font-cached
		     charset&stylefont-cache
		     (aref string i)
		     display-device-type
		     style-of-string
		     nil))
     NEW-FONT
	(setq char-in-font (aref string i)
	      fast-index (si:%char-subindex-is-index-p char-in-font))
	(when font
	  (setq CW (FONT-CHAR-WIDTH FONT)
		cwa (font-char-width-table font))
	  (SETQ CLH (MAX CLH (+ (FONT-CHAR-HEIGHT FONT) VSP))
		CLB (MAX CLB (FONT-BASELINE FONT))))

	;;At this point, decide whether we can use the fast version
	(unless (or cwa			       ;i.e.  fixed width
		    (STRING-FAT-P STRING)      ;and no font changes
		    (not font))
	  (GO FAST))
     SLOW
	(OR (< I N) (go done))			;If string exhausted
	(SETQ CH (AREF STRING I))
	
	(unless (setq index 
		      (si:%chars-share-device-font-p ch char-in-font fast-index))
	  (multiple-value (index FONT)
	    (si:lookup-index-and-font (aref string i)
				       display-device-type
				       style-of-string
				       nil))
	  (go new-font))
	(if (and font (graphic-char-p ch)) ;printing character
	    (setq nn (compute-char-width index cwa cw))
	    (setq nn (sheet-char-width-funny-char ch (+ x (sheet-inside-left))))
	    (when (zerop (char-bits ch))
	      (cond ((char-equal ch #\CR)
		     (setq nn 0 x 0)
		     (SETQ Y (+ Y CLH)
			   CLH LINE-HEIGHT
			   CLB BASELINE))
		    ((char-equal CH #\BS)
		     (SETQ NN (max nn (MINUS X)))))))
	(SETQ X (+ X NN))
	(IF (> X MAX-X) (SETQ MAX-X X))
	(WHEN (AND STOP-X (> X STOP-X))		;If char doesn't fit, stop before it
	  (SETQ X (- X NN))
	  (GO DONE))
	(SETQ I (1+ I))
	(GO SLOW)
	
	;;Here is the fast loop.  The basic idea is to scan as fast as possible
	;;over printing characters, with all checking outside the loop.
     FAST 
	;;First, decide the most characters we want to scan over in a whack
	(SETQ NN (COND ((NULL STOP-X) N)	;NN is limiting value of I
		       ((MIN (+ (// (- STOP-X X)
				    CW)
				I)
			     N))))
	;;Now, scan over printing characters.
	(AND ( (SETQ II I) NN)			;Save initial I, and check for null loop
	     (GO SLOW))
	(SETQ TEM #o200)				;This is really a ridiculous bum
     SCN (AND (< (CHAR-CODE (AREF STRING I)) TEM)	;If this is a printing character
	      (< (SETQ I (1+ I)) NN)		; and we haven't reached stop point
	      (GO SCN))				; then continue to loop (9 instructions)
	(SETQ X (+ (* (- I II) CW) X))		;Account for the motion of those chars
	(IF (> X MAX-X) (SETQ MAX-X X))
	(GO SLOW)				;Either string exhausted, non-printing,
						; or reached stop-x
     DONE
	(RETURN (VALUES X I MAX-X Y (+ Y CLH) CLB))
	))

;;; Editor's line redisplay primitive, output STRING from START to END,
;;; first setting position to (SET-XPOS,SET-YPOS) and doing a clear-rest-of-line
;;; DWIDTH is a special hack for DIS-LINE redisplay of italic fonts, it means
;;; draw an extra character starting one character back, since the clear-rest-of-line
;;; will have erased part of the last character where it sticks out past its width.
;;; (If this can really happen, it's going to mean trouble with the margins, too!)
;;; This function never does more than one line; it stops rather than wrapping around.
;;; If you put a carriage return in the string, above may not be true.
;;; Where this leaves the sheet's actual cursorpos is undefined (somewhere on the line)
(DEFMETHOD (:EDITOR-LINE-OUT SHEET) (STRING &OPTIONAL (START 0) (END NIL)
					    SET-XPOS SET-YPOS DWIDTH)
  ;;Returns index of next character to do and where cursor got to
  (DECLARE (VALUES I XPOS))
  ;;Except the first value can be incremented, to show that
  ;;the line was completed (as if it counted the carriage return)
  (PREPARE-SHEET (SELF)
    (PROG ((I START)
	   (N (OR END (ARRAY-ACTIVE-LENGTH STRING)))
	   (RIGHT-LIMIT (SHEET-INSIDE-RIGHT))
	   (MARGIN-FLAG (NOT (ZEROP (SHEET-RIGHT-MARGIN-CHARACTER-FLAG))))
	   (fast-subindex 't)
	   DONE-P OYPOS CH FONT BASE-ADJ char-in-font)
	  (AND MARGIN-FLAG (SETQ RIGHT-LIMIT (- RIGHT-LIMIT CHAR-WIDTH)))
	  (COND (SET-XPOS
		 (SETF CURSOR-X
		       (SETQ SET-XPOS (MIN (+ SET-XPOS (SHEET-INSIDE-LEFT))
					   (SHEET-INSIDE-RIGHT))))))
	  (COND (SET-YPOS
		 (AND MORE-VPOS
		      (SETQ MORE-VPOS (SHEET-DEDUCE-MORE-VPOS)))
		 (SETQ CURSOR-Y
		       (SETQ SET-YPOS (MIN (+ SET-YPOS (SHEET-INSIDE-TOP))
					   (SHEET-INSIDE-BOTTOM))))
		 (SETF (SHEET-EXCEPTIONS) 0)
		 (AND (> (+ SET-YPOS LINE-HEIGHT) (SHEET-INSIDE-BOTTOM))
		      (SETF (SHEET-END-PAGE-FLAG) 1))
		 (SETQ OYPOS SET-YPOS))
		(T (SETQ OYPOS CURSOR-Y)))
	  
	  ;; I don't think the editor is supposed to let an exception ever go off
	  ;; here.  If one should go off, some of what was encached in local variables
	  ;; above might become out of date.
	  (OR (ZEROP (SHEET-EXCEPTIONS)) (SEND SELF ':HANDLE-EXCEPTIONS))
	  
	  ;; If we set the cursor then do a clear to end of line
	  (AND (OR SET-XPOS SET-YPOS)
	       (SHEET-DRAW-RECTANGLE (- (SHEET-INSIDE-RIGHT)
					(SETQ SET-XPOS (OR SET-XPOS CURSOR-X)))
				     LINE-HEIGHT SET-XPOS OYPOS ERASE-ALUF))
	  ;; If special case of italic line, move back and decrement starting index
	  (COND (DWIDTH
		 (SETF CURSOR-X (- SET-XPOS DWIDTH))
		 (SETQ I (1- I))))
	  
       TOP
	  (WHEN ( I N)
	    (RETURN (VALUES (1+ I) (- CURSOR-X (SHEET-INSIDE-LEFT)))))
	  (SETQ CH (AREF STRING I))
       NEW-FONT
	  (setq char-in-font ch)
	  (SETQ FONT (sheet-get-char-font ch))
	  (unless (and font (graphic-char-p ch))
	    (GO TYO))				;Let TYO handle it so no infinite loop here
	  
	  (SETQ FAST-SUBINDEX (IF (CHAR-FAT-P CH)
				  (SI:%CHAR-SUBINDEX-IS-INDEX-P CH)
				'T)
		BASE-ADJ (SHEET-GET-TOP-OF-FONT FONT))
	  
	  ;; Ready to do a segment of this.  Let the string primitive blast it out...
	  (MULTIPLE-VALUE (CURSOR-X I DONE-P)
	    (SHEET-DRAW-STRING SELF CHAR-ALUF CURSOR-X (+ CURSOR-Y BASE-ADJ)
			       STRING FONT I N RIGHT-LIMIT))
	  (WHEN DONE-P
	    (RETURN (VALUES (1+ I) (- CURSOR-X (SHEET-INSIDE-LEFT)))))
	  
	  ;; Some exception, see what it was
	  (SETQ CH (AREF STRING I))
	  (unless (SI:%CHARs-share-device-font-p CH char-in-font fast-subindex)	;Font change...
	    (GO NEW-FONT))			;Pop back to top to cache info.
	  
       TYO
	  ;; Funny character (format effector) or reached end of line.
	  (WHEN (> (+ CURSOR-X (SEND SELF ':CHARACTER-WIDTH CH FONT)) RIGHT-LIMIT)
	    ;; This character won't fit on the line
	    (AND MARGIN-FLAG (SHEET-TYO-RIGHT-MARGIN-CHARACTER CURSOR-X OYPOS #/!))
	    (RETURN (VALUES (IF (ZEROP (SHEET-TRUNCATE-LINE-OUT-FLAG)) I (1+ N))
			    (- CURSOR-X (SHEET-INSIDE-LEFT)))))
	  (SEND SELF ':TYO CH)
	  (INCF I)
	  (GO TOP))))


;; Replacement for the above, that gets all the size information as arguments
;; since redisplay is two pass.  Thus it ignores sheet state like current-baseline.
(DEFMETHOD (:DISPLAY-LINE-INTERNAL SHEET)
	   (STRING START-INDEX END-INDEX X Y
	    STRING-WIDTH STRING-HEIGHT STRING-BASELINE STRING-VSP
	    FONT-CACHE RIGHT-LIMIT TAB-FUNCTION)
  (INCF X (SHEET-INSIDE-LEFT))
  (INCF Y (SHEET-INSIDE-TOP))
  (PREPARE-SHEET (SELF)
    (TV:SHEET-DRAW-RECTANGLE (- (IF RIGHT-LIMIT
				    (+ (SHEET-INSIDE-LEFT) RIGHT-LIMIT)
				    (SHEET-INSIDE-RIGHT))
				X)
			     (+ STRING-HEIGHT STRING-VSP)
			     X Y ERASE-ALUF SELF)
    (LET ((RIGHT-LIMIT (+ STRING-WIDTH (SHEET-INSIDE-LEFT)))
	  (INDEX START-INDEX))
      (LOOP NAMED TOP
	    WHILE (< INDEX END-INDEX)
	    DOING
	(LET ((CH (AREF STRING INDEX)))
	  (IF T #||(CHARACTERP CH)||#
	      ;; SHEET-DRAW-STRING cannot check the font of the first
	      ;; character in the string.  Thus, if you have a format
	      ;; effector in nil.nil.nil followed by a styled character,
	      ;; it will draw the styled character in nil.nil.nil still
	      ;; without noticing the change. So we have to recompute
	      ;; the font after each break. (so for roman - format-effector - roman)
	      ;; roman will be computed twice, but there is no helping.
	      (LET* ((FONT (AND (GRAPHIC-CHAR-P CH)
				(IF (CHAR-FAT-P CH)
				    (MULTIPLE-VALUE-BIND (NIL FONT)
					(SI:LOOKUP-INDEX-AND-FONT-CACHED
					  CH DISPLAY-DEVICE-TYPE MERGED-CURRENT-STYLE
					  FONT-CACHE CHARSET&STYLEFONT-CACHE)
				      FONT)
				    CURRENT-FONT)))
		     (FAST-SUBINDEX (SI:%CHAR-SUBINDEX-IS-INDEX-P CH))
		     (BASELINE-ADJUST (AND FONT (- STRING-BASELINE (FONT-BASELINE FONT)))))
		(LOOP DOING
		  (WHEN FONT
		    (LET ((DONE-P NIL))
		      (MULTIPLE-VALUE (X INDEX DONE-P)
			(SHEET-DRAW-STRING SELF CHAR-ALUF X (+ Y BASELINE-ADJUST)
					   STRING FONT INDEX END-INDEX RIGHT-LIMIT))
		      (WHEN DONE-P
			(RETURN-FROM TOP NIL)))
		    ;; Check for font change or diagram char
		    (UNLESS (LET ((NCH (AREF STRING INDEX)))
			      (PROG1 (AND (CHARACTERP NCH)
					  (SI:%CHARS-SHARE-DEVICE-FONT-P NCH CH
									 FAST-SUBINDEX))
				     (SETQ CH NCH)))
		      ;; Loop back
		      (RETURN))
		    ;; Here the next character is the same as the last one we
		    ;; displayed, yet we aren't done displaying the string,
		    ;; meaning SHEET-DRAW-STRING quit because it went past
		    ;; RIGHT-LIMIT.  So if this character is still in the
		    ;; current font, we must have screwed up on the width
		    ;; calculation earlier.
		    (WHEN (< (CHAR-SUBINDEX CH) (FONT-FILL-POINTER FONT))
		      (CL:CERROR "Skip displaying this line"
				 "Line was wider when displayed.")
		      (RETURN-FROM TOP NIL)))
		  ;; Handle some sort of non-printing character
		  (COND ((CHAR-EQUAL CH #\TAB)
			 (MULTIPLE-VALUE-BIND (TAB-X TAB-Y)
			     (FUNCALL TAB-FUNCTION SELF STRING INDEX
				      (- X (SHEET-INSIDE-LEFT))
				      (- Y (SHEET-INSIDE-TOP)))
			   (SETQ X (+ (SHEET-INSIDE-LEFT) TAB-X))
			   (WHEN TAB-Y
			     (SETQ Y (+ (SHEET-INSIDE-TOP) TAB-Y)))))
			((AND (CHAR-EQUAL CH #\BS)
			      (ZEROP (SHEET-BACKSPACE-NOT-OVERPRINTING-FLAG)))
			 (SETQ X (MAX (SHEET-INSIDE-LEFT)
				      (- X (FONT-CHAR-WIDTH FONT)))))
			(T
			 (SETQ CURSOR-X X)
			 (SETQ CURSOR-Y Y)
			 (SEND SELF :TYO CH)
			 (SETQ X CURSOR-X)
			 (SETQ Y CURSOR-Y)))
		  (INCF INDEX)
		  (RETURN)))
	      (MULTIPLE-VALUE-BIND (WIDTH HEIGHT BASELINE)
		  (OBESE-CHARACTER-SIZE CH SELF (- X (SHEET-INSIDE-LEFT)))
		(OBESE-CHARACTER-DRAW CH SELF
				      (- X (SHEET-INSIDE-LEFT))
				      (+ (- Y (SHEET-INSIDE-TOP))
					 (- STRING-BASELINE (OR BASELINE HEIGHT))))
		(INCF X WIDTH))
	      (INCF INDEX))))))
  NIL)

;;; Friend of the above.
(DEFMETHOD (:LINE-DISPLAYED-SIZE-INTERNAL SHEET) (LINE START-INDEX END-INDEX START-X
						       FONT-CACHE RIGHT-LIMIT TAB-FUNCTION)
  (IF (= END-INDEX START-INDEX)
      ;; By convention, an empty line is a high as a line of characters all in the primary
      ;; font.
      (LET ((FONT CURRENT-FONT))
	(VALUES START-X
		(FONT-CHAR-HEIGHT FONT)
		(FONT-BASELINE FONT)
		START-INDEX))
      (LET ((LINE LINE)
	    (MAX-WIDTH (OR RIGHT-LIMIT (- (SHEET-INSIDE-WIDTH) 4)))
	    (INDEX START-INDEX) (X START-X)
	    (Y-OFFSET 0)
	    (MAX-ABOVE-BASE 0) (MAX-BELOW-BASE 0)
	    (SEEN-LOZENGE NIL)
	    LAST-FONT LAST-FONT-CH
	    FONT-FAST-INDEX FONT-FILL-POINTER FONT-CHARS-EXIST-TABLE
	    FONT-CHAR-WIDTH-TABLE FONT-CHAR-WIDTH)
	(DECLARE (SYS:ARRAY-REGISTER LINE))
	;; Make a common case about twice as fast, by open-coding the %chars-... mechanism.
	;; Wholly in a non-standard style takes a no longer.  Something that starts out
	;; fixed and switches in the middle takes about 5% longer worst case.
	(LET ((FONT CURRENT-FONT))
	  (WHEN (NULL (FONT-CHAR-WIDTH-TABLE FONT))
	    (BLOCK FIXED
	      (LET* ((CHAR-WIDTH (FONT-CHAR-WIDTH FONT))
		     (INDEX START-INDEX) (X START-X))
		(LOOP DOING
		  (WHEN ( INDEX END-INDEX)
		    (RETURN))
		  (LET ((CODE (SYS:CHAR-LDB-INTERNAL SYS:%%CHAR-ALL (AREF LINE INDEX))))
		    (COND ((< CODE #o200)
			   (LET ((NEW-X (+ X CHAR-WIDTH)))
			     (WHEN (> NEW-X MAX-WIDTH)
			       (RETURN))
			     (SETQ X NEW-X)))
			  ((= CODE (CHAR-SUBINDEX #\TAB))
			   (MULTIPLE-VALUE-BIND (NEW-X NEW-Y)
			       (FUNCALL TAB-FUNCTION SELF LINE INDEX X 0)
			     (WHEN (> NEW-X MAX-WIDTH)
			       (RETURN))
			     (WHEN (AND NEW-Y (NOT (EQL NEW-Y 0)))
			       ;; Will retry below
			       (RETURN-FROM FIXED NIL))
			     (SETQ X NEW-X)))
			  ((AND (= CODE (CHAR-SUBINDEX #\BS))
				(ZEROP (SHEET-BACKSPACE-NOT-OVERPRINTING-FLAG)))
			   (SETQ X (MAX 0 (- X CHAR-WIDTH))))
			  (T
			   (RETURN-FROM FIXED NIL))))
		  (INCF INDEX))
		(RETURN-FROM :LINE-DISPLAYED-SIZE-INTERNAL
		  (VALUES X (FONT-CHAR-HEIGHT FONT) (FONT-BASELINE FONT) INDEX))))
	    (WHEN (> INDEX START-INDEX)
	      (LET ((FONT-BASELINE (FONT-BASELINE FONT)))
		(SETQ MAX-ABOVE-BASE FONT-BASELINE
		      MAX-BELOW-BASE (- (FONT-CHAR-HEIGHT FONT) FONT-BASELINE))))))
	(FLET ((RETHINK-FONT-MAX (FNT)
		 (LET ((FONT-BASELINE (FONT-BASELINE FNT))
		       (FONT-CHAR-HEIGHT (FONT-CHAR-HEIGHT FNT)))
		   (SCL:MAXF MAX-ABOVE-BASE (- FONT-BASELINE Y-OFFSET))
		   (SCL:MAXF MAX-BELOW-BASE (+ (- FONT-CHAR-HEIGHT FONT-BASELINE) Y-OFFSET)))))
	  (LOOP WITH TABS-ONLY = T
		DOING
	    (WHEN ( INDEX END-INDEX)
	      (WHEN TABS-ONLY
		(RETHINK-FONT-MAX CURRENT-FONT))
	      (RETURN))
	    (LET ((CH (AREF LINE INDEX))
		  (NEW-FONT NIL))
	      (UNLESS (CHAR-EQUAL CH #\TAB)
		(SETQ TABS-ONLY NIL))
	      (IF T #||(CHARACTERP CH)||#
		  (LET ((CH-FONT LAST-FONT)
			(CH-INDEX (AND LAST-FONT-CH
				       (SI:%CHARS-SHARE-DEVICE-FONT-P CH LAST-FONT-CH
								      FONT-FAST-INDEX))))
		    (WHEN (NULL CH-INDEX)
		      (MULTIPLE-VALUE (CH-INDEX CH-FONT)
			(LET ((INDEX (CHAR-SUBINDEX CH)))
			  (WHEN (OR (< INDEX #o200)
				    ;; If it's not in char set 0, it can't be a be
				    ;; a format effector.
				    (PLUSP (SYS:CHAR-LDB-INTERNAL %%CHAR-CHAR-SET CH)))
			    ;; Format effectors are high numbered thin characters
			    ;; A font can have a larger glyph set than this, but you
			    ;; do not access the high characters through the default
			    ;; character set.  Also, the editor allows format effectors
			    ;; in non-standard styles.
			    (IF (CHAR-FAT-P CH)
				(SI:LOOKUP-INDEX-AND-FONT-CACHED CH DISPLAY-DEVICE-TYPE
								 MERGED-CURRENT-STYLE
								 FONT-CACHE
								 CHARSET&STYLEFONT-CACHE)
				(VALUES INDEX CURRENT-FONT))))))
		    (UNLESS
		      (COND ((NULL CH-FONT)
			     NIL)
			    ((EQ CH-FONT LAST-FONT)
			     (WHEN (AND (< CH-INDEX FONT-FILL-POINTER)
					(OR (NULL FONT-CHARS-EXIST-TABLE)
					    (AREF FONT-CHARS-EXIST-TABLE CH-INDEX)))
			       ;; Still in same font, no need to worry about height parameters.
			       (LET ((NEW-X (+ X (COMPUTE-CHAR-WIDTH CH-INDEX
								     FONT-CHAR-WIDTH-TABLE
								     FONT-CHAR-WIDTH))))
				 (WHEN (> NEW-X MAX-WIDTH)
				   (RETURN))
				 (SETQ X NEW-X)
				 T)))
			    (T
			     ;; Set new font parameters
			     (SETQ NEW-FONT T
				   LAST-FONT CH-FONT
				   LAST-FONT-CH CH
				   FONT-FAST-INDEX (SI:%CHAR-SUBINDEX-IS-INDEX-P CH)
				   FONT-FILL-POINTER (FONT-FILL-POINTER CH-FONT)
				   FONT-CHARS-EXIST-TABLE (FONT-CHARS-EXIST-TABLE CH-FONT)
				   FONT-CHAR-WIDTH-TABLE (FONT-CHAR-WIDTH-TABLE CH-FONT)
				   FONT-CHAR-WIDTH (FONT-CHAR-WIDTH CH-FONT))
			     (WHEN (AND (< CH-INDEX FONT-FILL-POINTER)
					(OR (NULL FONT-CHARS-EXIST-TABLE)
					    (AREF FONT-CHARS-EXIST-TABLE CH-INDEX)))
			       ;; Still in same font, no need to worry about height parameters.
			       (LET ((NEW-X (+ X (COMPUTE-CHAR-WIDTH CH-INDEX
								     FONT-CHAR-WIDTH-TABLE
								     FONT-CHAR-WIDTH))))
				 (WHEN (> NEW-X MAX-WIDTH)
				   (RETURN))
				 (SETQ X NEW-X)
				 (RETHINK-FONT-MAX CH-FONT)
				 T))))
		      ;; Format effector or character outside font limit, display in lozenge.
		      (COND ((CHAR-EQUAL CH #\TAB)	;Editor allows Tabs in funny styles.
			     (MULTIPLE-VALUE-BIND (NEW-X NEW-Y)
				 (FUNCALL TAB-FUNCTION SELF LINE INDEX X Y-OFFSET)
			       (WHEN (> NEW-X MAX-WIDTH)
				 (RETURN))
			       (SETQ X NEW-X)
			       (WHEN (AND NEW-Y (NOT (EQL NEW-Y Y-OFFSET)))
				 (SETQ Y-OFFSET NEW-Y
				       NEW-FONT T))
			       (WHEN NEW-FONT
				 (RETHINK-FONT-MAX (OR CH-FONT CURRENT-FONT)))))
			    ((AND (CHAR-EQUAL CH #\BS)
				  (ZEROP (SHEET-BACKSPACE-NOT-OVERPRINTING-FLAG)))
			     (SETQ X (MAX 0 (- X (IF FONT-CHAR-WIDTH-TABLE
						     (AREF FONT-CHAR-WIDTH-TABLE
							   (CHAR-SUBINDEX #\SPACE))
						   FONT-CHAR-WIDTH))))
			     (WHEN NEW-FONT
			       (RETHINK-FONT-MAX CH-FONT)))
			    (T
			     (LET ((NEW-X (+ X (SHEET-CHAR-WIDTH-FUNNY-CHAR CH X))))
			       (WHEN (> NEW-X MAX-WIDTH)
				 (RETURN))
			       (SETQ X NEW-X)
			       (UNLESS SEEN-LOZENGE
				 ;; First lozenged character, need to account
				 ;; for height info of that.
				 (SCL:MAXF MAX-ABOVE-BASE
					   (- (SHEET-LOZENGE-BASELINE SELF) Y-OFFSET))
				 (SCL:MAXF MAX-BELOW-BASE (+ 2 Y-OFFSET))
				 (SETQ SEEN-LOZENGE T)))))))
		  (MULTIPLE-VALUE-BIND (WIDTH HEIGHT BASELINE)
		      (OBESE-CHARACTER-SIZE CH SELF X)
		    (LET ((NEW-X (+ X WIDTH)))
		      (WHEN (> NEW-X MAX-WIDTH)
			(RETURN))
		      (SETQ X NEW-X))
		    (SCL:MAXF MAX-ABOVE-BASE (- (OR BASELINE HEIGHT) Y-OFFSET))
		    (WHEN BASELINE
		      (SCL:MAXF MAX-BELOW-BASE (+ (- HEIGHT BASELINE) Y-OFFSET))))))
	  (INCF INDEX)))
	(VALUES X (+ MAX-ABOVE-BASE MAX-BELOW-BASE) MAX-ABOVE-BASE INDEX))))


(DEFMETHOD (:STRING-OUT-EXPLICIT SHEET)
	   (STRING X Y XLIM ALU &OPTIONAL (START 0) (END NIL) CLIPPING-REGION)
  "Output a special string (like a label) without exceptions or anything like that."
  (PREPARE-SHEET (SELF)
    (SEND SELF :STRING-OUT-EXPLICIT-INTERNAL (STRING STRING) X Y XLIM ALU START END
	  NIL CLIPPING-REGION)))

(DEFMETHOD (:STRING-OUT-EXPLICIT-INTERNAL SHEET)
	   (STRING X Y XLIM ALU &OPTIONAL (START 0) (END NIL) STYLE CLIPPING-REGION)
  (MULTIPLE-VALUE-BIND (CLIP-LEFT CLIP-TOP CLIP-RIGHT CLIP-BOTTOM)
      (IF CLIPPING-REGION
	  (VALUES (POP CLIPPING-REGION) (POP CLIPPING-REGION) (POP CLIPPING-REGION) (POP CLIPPING-REGION))
	  (VALUES 0 0 WIDTH HEIGHT))
    (WITH-SHEET-CLIPPING-REGION (CLIP-LEFT CLIP-TOP CLIP-RIGHT CLIP-BOTTOM)
      (PROG ((I START)
	     (N (OR END (ARRAY-ACTIVE-LENGTH STRING)))
	     (FAT-P (STRING-FAT-P STRING))
	     FONT
	     CHAR-IN-FONT
	     (FAST-SUBINDEX 'T)
	     (BASE-ADJ 0)			;thin strings use no baseline adjustment
	     CH DONE-P)
	 TOP (WHEN ( I N)
	       (RETURN (VALUES X I)))
	    (SETQ CH (AREF STRING I))
	 NEW-FONT
	    (SETQ CHAR-IN-FONT CH)
	    (WHEN (SETQ FONT (IF STYLE
				 (SI:LOOKUP-FONT-CACHED
				   CHARSET&STYLEFONT-CACHE
				   CH (SHEET-DISPLAY-DEVICE-TYPE SELF)
				   (SI:MERGE-CHARACTER-STYLES STYLE TV:*DEFAULT-STYLE*)
				   NIL)
				 (SHEET-GET-CHAR-FONT CH)))
	      (SETQ FAST-SUBINDEX (IF (AND FAT-P (CHAR-FAT-P CH))
				      (SI:%CHAR-SUBINDEX-IS-INDEX-P CH)
				      'T)
		    BASE-ADJ (SHEET-GET-TOP-OF-FONT FONT))
	      (MULTIPLE-VALUE (X I DONE-P)
		(SHEET-DRAW-STRING SELF ALU X (+ Y BASE-ADJ) STRING FONT I N XLIM))
	      (WHEN DONE-P
		(RETURN (VALUES X I)))
	      (SETQ CH (AREF STRING I))		;Find out why it stopped
	      (UNLESS (SI:%CHARS-SHARE-DEVICE-FONT-P CH CHAR-IN-FONT FAST-SUBINDEX)	;Font change
		(GO NEW-FONT)))			;Pop back to top to cache info.
	    
	    (LET ((CODE (CHAR-CODE CH)))
	      ;; Handle non spacing graphic characters here.  These are specially
	      ;; treated in a way that keeps fixed width fonts fixed.
	      ;; Would also handle any other graphic characters above #o200, of
	      ;; which there aren't any now.
	      (WHEN (AND FONT ( #o300 CODE #o317) (NOT (OR (= CODE #o300) (= CODE #o311))))
		(LET ((LEN (FONT-FILL-POINTER FONT))
		      (CET (FONT-CHARS-EXIST-TABLE FONT))
		      (FIT (FONT-INDEXING-TABLE FONT))
		      (CWT (FONT-CHAR-WIDTH-TABLE FONT)))
		  (WHEN (OR ;; Fixed width.
			  (AND (NULL CET) (NULL FIT) (NULL CWT) (= LEN #o200)
			       ( (DECODE-RASTER-ARRAY FONT)
				  (* (1+ CODE) (FONT-RASTER-WIDTH FONT))))
			  ;; Variable width with this position defined.
			  (AND CET (< CODE LEN) (AREF CET CODE)))
		    (LETF (((FONT-FILL-POINTER FONT) #o320))
		      (SHEET-DRAW-GLYPH CODE FONT X (+ Y (SHEET-GET-TOP-OF-FONT FONT)) ALU))
		    ;; Fixed width gives width of 0 for this one.
		    (WHEN CWT
		      (INCF X (AREF CWT CODE)))
		    (INCF I)
		    (GO TOP)))))

	    (UNLESS (AND FONT (GRAPHIC-CHAR-P CH))
	      ;; Funny character
	      (WITH-STACK-ARRAY (TEMP-STRING 50 :TYPE 'ART-FAT-STRING :FILL-POINTER 0)
		(SETQ X (SHEET-DISPLAY-LOZENGED-STRING-INTERNAL
			  (SHEET-TYO-FUNNY-CHAR-INTERNAL CH TEMP-STRING)
			  X (1+ Y) XLIM ALU)))
	      (INCF I)
	      (GO TOP))

	    (RETURN (VALUES X I))))))		;Must have reached right edge of sheet

;;; This function displays a string centered between two X coordinates, truncated if necessary
;;; The arguments are relative to the margins, as usual.
(DEFMETHOD (:DISPLAY-CENTERED-STRING SHEET) (STRING
					     &OPTIONAL (LEFT 0)
						       (RIGHT (SHEET-INSIDE-WIDTH))
						       (Y-POS (- CURSOR-Y (SHEET-INSIDE-TOP)))
					     &AUX WID SWID SLEN)
  (SETQ WID (- RIGHT LEFT)
	STRING (STRING STRING))
  (MULTIPLE-VALUE (NIL SLEN SWID)
    ;;Compute how wide the string is, and whether to truncate
    (SEND SELF ':STRING-LENGTH STRING 0 NIL WID))
  ;; :SET-CURSORPOS takes arguments in a different coordinate system
  (SEND SELF ':SET-CURSORPOS (+ LEFT (MAX (// (- WID SWID) 2) 0)) Y-POS)
  (SEND SELF ':STRING-OUT STRING 0 SLEN))

(DEFMETHOD (:DISPLAY-X-Y-CENTERED-STRING SHEET) (STRING
						  &OPTIONAL (LEFT 0) (TOP 0)
						  (RIGHT (SHEET-INSIDE-WIDTH))
						  (BOTTOM (SHEET-INSIDE-HEIGHT)))
  "Display a string centered in both X and Y.
  Note that the coordinates of the box in which it is centered are relative to the margins"
  (LET* ((string (string string))
	 (HT (LOOP WITH MAX-BASE = 0
		   FOR CH BEING THE ARRAY-ELEMENTS OF STRING
		   AS LAST-STYLE FIRST NIL THEN STYLE
		   AS STYLE = (SI:CHAR-STYLE CH)
		   UNLESS (EQ STYLE LAST-STYLE)	; Optimization
		     DO (LET ((FONT (SHEET-GET-CHAR-FONT CH)))
			  (WHEN FONT
			    (SETQ MAX-BASE (MAX MAX-BASE (FONT-BASELINE FONT)))))
			FINALLY (RETURN MAX-BASE)))
	 (WID (- RIGHT LEFT)))
    (WITH-STACK-LIST (INSIDE-EDGES (SHEET-INSIDE-LEFT) (SHEET-INSIDE-TOP)
				   (SHEET-INSIDE-RIGHT) (SHEET-INSIDE-BOTTOM))
      (MULTIPLE-VALUE-BIND (NIL SLEN SWID)
	  (SEND SELF ':STRING-LENGTH STRING 0 NIL WID)
	(SEND SELF ':STRING-OUT-EXPLICIT STRING
	      (+ (SHEET-INSIDE-LEFT) LEFT
		 (MAX (// (- WID SWID) 2) 0))
	      (+ (SHEET-INSIDE-TOP)
		 (MAX (- (// (+ TOP BOTTOM) 2) (// HT 2)) TOP))
	      (+ (SHEET-INSIDE-LEFT) RIGHT)
	      CHAR-ALUF 0 SLEN
	      INSIDE-EDGES
	      )))))

(DEFMETHOD (:FRESH-LINE SHEET) ()
  (COND ((= CURSOR-X (SHEET-INSIDE-LEFT))
	 (SEND SELF ':CLEAR-REST-OF-LINE)
	 NIL)
	(T
	 (SEND SELF ':TYO #\NEWLINE)
	 T)))

(DEFMETHOD (:LINE-OUT SHEET) (STRING &OPTIONAL (START 0) END)
  (SEND SELF ':STRING-OUT STRING START END)
  (SEND SELF ':TYO #\NEWLINE))



;;; :BITBLT, :BITBLT-FROM-SHEET, and :BITBLT-WITHIN-SHEET
;;;
;;; All of these use "overlapping piece of paper clipping" which works as follows:
;;;
;;;   1.) Take a piece of paper the size of specified bitblt (wid hei).  Put
;;;       that piece of paper over the source array with its upper left corner
;;;       (0 0) at the specified (from-x from-y).  Copy the part of the source
;;;       array that the piece of paper covers onto the piece of paper.  If
;;;       part of the paper hangs off the right or bottom edge of the source
;;;       array then do standard bitblt tiling to fill in that part of the
;;;       paper.  Leave any part of the paper that hangs off the left or top
;;;       of the source array blank.
;;;
;;;   2.) Now put that piece of paper with its upper left corner at the
;;;       specified (to-x to-y) of the destination.  Trim off any part of
;;;       the paper that hang off the edges of the destination, also trim
;;;       off any parts of that paper that were left blank in step 1.
;;;
;;;   3.) Glue the piece of paper to the destination in its current place
;;;       and you have the result.
;;; 
;;; (Of course) they take their arguments in inside window coordinates. They do
;;; the clipping on these coordinates too, they convert to outside coordinates
;;; just before the actual call to bitblt.
;;;
;;; BITBLT-CLIP implements the overlapping piece of paper clipping.  It clips a
;;; bitblt from an unlimited source array to a limited destination array.  :BITBLT
;;; and :BITBLT-FROM-SHEET use one call to bitblt-clip, :BITBLT-WITHIN-SHEET uses
;;; two calls since both its source and destination are bounded.
;;;
;;; *** NOTE:                                                               ***     
;;; ***   The :BITBLT and :BITBLT-FROM-SHEET messages do no checking on     ***
;;; ***   the bounds of the array they receive to bitblt from/to.  Their    ***
;;; ***   caller must do this itself (it might want to use bitblt-clip).    ***

(DEFMACRO BITBLT-CLIP (WID HEI TO-X TO-Y FROM-X FROM-Y TO-LIMIT-WID TO-LIMIT-HEI)
  `(LET* ((CLIPPED-TO-X (MIN (MAX 0 ,TO-X) ,TO-LIMIT-WID))     
	  (CLIPPED-TO-Y (MIN (MAX 0 ,TO-Y) ,TO-LIMIT-HEI))
	  (LEF-OVERRUN (MAX 0 (- ,TO-X)))
	  (TOP-OVERRUN (MAX 0 (- ,TO-Y)))
	  (RIG-OVERRUN (MAX 0 (- (+ ,TO-X (ABS ,WID)) ,TO-LIMIT-WID)))
	  (BOT-OVERRUN (MAX 0 (- (+ ,TO-Y (ABS ,HEI)) ,TO-LIMIT-HEI))))
     (SETQ ,WID (* (IF (MINUSP ,WID) -1 1) (MAX 0 (- (ABS ,WID) LEF-OVERRUN RIG-OVERRUN)))
	   ,HEI (* (IF (MINUSP ,HEI) -1 1) (MAX 0 (- (ABS ,HEI) TOP-OVERRUN BOT-OVERRUN)))
	   ,FROM-X (+ ,FROM-X LEF-OVERRUN)
	   ,FROM-Y (+ ,FROM-Y TOP-OVERRUN)
	   ,TO-X CLIPPED-TO-X
	   ,TO-Y CLIPPED-TO-Y)))

;;; Like bitblt-clip, but takes four clipping limits.
(DEFMACRO CLIP-FOR-BITBLT (WID HEI FROM-X FROM-Y TO-X TO-Y TO-LEFT TO-TOP TO-RIGHT TO-BOTTOM)
  `(LET* ((CLIPPED-TO-X (MIN (MAX ,TO-LEFT ,TO-X) ,TO-RIGHT))
	  (CLIPPED-TO-Y (MIN (MAX ,TO-TOP ,TO-Y) ,TO-BOTTOM))
	  (LEF-OVERRUN (MAX 0 (- ,TO-LEFT ,TO-X)))
	  (TOP-OVERRUN (MAX 0 (- ,TO-TOP ,TO-Y)))
	  (RIG-OVERRUN (MAX 0 (- (+ ,TO-X ,WID) ,TO-RIGHT)))
	  (BOT-OVERRUN (MAX 0 (- (+ ,TO-Y ,HEI) ,TO-BOTTOM))))
     (SETQ ,WID (MAX 0 (- ,WID LEF-OVERRUN RIG-OVERRUN))
	   ,HEI (MAX 0 (- ,HEI TOP-OVERRUN BOT-OVERRUN))
	   ,FROM-X (+ ,FROM-X LEF-OVERRUN)
	   ,FROM-Y (+ ,FROM-Y TOP-OVERRUN)
	   ,TO-X CLIPPED-TO-X
	   ,TO-Y CLIPPED-TO-Y)))

(DEFMETHOD (:BITBLT SHEET) (ALU WID HEI FROM-RASTER FROM-X FROM-Y TO-X TO-Y)
  (BITBLT-CLIP WID HEI TO-X TO-Y FROM-X FROM-Y (SHEET-INSIDE-WIDTH) (SHEET-INSIDE-HEIGHT))
  (UNLESS (OR (ZEROP WID) (ZEROP HEI))
    (PREPARE-SHEET (SELF)
      (SHEET-BITBLT ALU WID HEI
		    FROM-RASTER FROM-X FROM-Y
		    NIL (+ TO-X (SHEET-INSIDE-LEFT)) (+ TO-Y (SHEET-INSIDE-TOP))))))


(DEFMETHOD (:BITBLT-FROM-SHEET SHEET) (ALU WID HEI FROM-X FROM-Y TO-RASTER TO-X TO-Y)
  (BITBLT-CLIP WID HEI FROM-X FROM-Y TO-X TO-Y (SHEET-INSIDE-WIDTH) (SHEET-INSIDE-HEIGHT))
  (UNLESS (OR (ZEROP WID) (ZEROP HEI))
    (PREPARE-SHEET (SELF)
      (SHEET-BITBLT ALU WID HEI
		    NIL (+ FROM-X (SHEET-INSIDE-LEFT)) (+ FROM-Y (SHEET-INSIDE-TOP))
		    TO-RASTER TO-X TO-Y))))

(DEFMETHOD (:BITBLT-WITHIN-SHEET SHEET) (ALU WID HEI FROM-X FROM-Y TO-X TO-Y)
  (LET ((INSIDE-WID (SHEET-INSIDE-WIDTH)) (INSIDE-HEI (SHEET-INSIDE-HEIGHT))
	(INSIDE-LEF (SHEET-INSIDE-LEFT))  (INSIDE-TOP (SHEET-INSIDE-TOP)))
    (BITBLT-CLIP WID HEI FROM-X FROM-Y TO-X TO-Y INSIDE-WID INSIDE-HEI)
    (BITBLT-CLIP WID HEI TO-X TO-Y FROM-X FROM-Y INSIDE-WID INSIDE-HEI)
    (UNLESS (OR (ZEROP WID) (ZEROP HEI))
      (PREPARE-SHEET (SELF)
	(SHEET-BITBLT ALU WID HEI
		      NIL (+ FROM-X INSIDE-LEF) (+ FROM-Y INSIDE-TOP)
		      NIL (+ TO-X INSIDE-LEF)   (+ TO-Y INSIDE-TOP))))))

(DEFMETHOD (:BITBLT-FROM-SHEET-TO-SHEET SHEET)
	   (ALU WID HEI FROM-SHEET FROM-X FROM-Y TO-X TO-Y)
  (BITBLT-CLIP WID HEI FROM-X FROM-Y TO-X TO-Y
	       (SHEET-INSIDE-WIDTH FROM-SHEET) (SHEET-INSIDE-HEIGHT FROM-SHEET))
  (BITBLT-CLIP WID HEI TO-X TO-Y FROM-X FROM-Y
	       (SHEET-INSIDE-WIDTH) (SHEET-INSIDE-HEIGHT))
  (UNLESS (OR (ZEROP WID) (ZEROP HEI))
    (SHEET-FORCE-ACCESS (FROM-SHEET NIL)
      (PREPARE-SHEET (SELF)
	(SHEET-BITBLT ALU WID HEI
		      (SHEET-SCREEN-ARRAY FROM-SHEET)
		      (+ FROM-X (SHEET-INSIDE-LEFT FROM-SHEET))
		      (+ FROM-Y (SHEET-INSIDE-TOP FROM-SHEET))
		      (SHEET-SCREEN-ARRAY SELF)
		      (+ TO-X (SHEET-INSIDE-LEFT))
		      (+ TO-Y (SHEET-INSIDE-TOP)))))))

;;; Syntactic sugar
(DEFSUBST BITBLT-FROM-SHEET-TO-SHEET
	  (ALU WIDTH HEIGHT FROM-SHEET FROM-X FROM-Y TO-SHEET TO-X TO-Y)
  (SEND TO-SHEET :BITBLT-FROM-SHEET-TO-SHEET ALU WIDTH HEIGHT
		 FROM-SHEET FROM-X FROM-Y TO-X TO-Y))



(DEFMETHOD (GRAPHICS::STANDARDIZE-ALU SHEET) (ALU)
  (CL:TYPECASE ALU
    (CL:SYMBOL
      (CL:ECASE ALU
	(:DRAW CHAR-ALUF)
	(:ERASE ERASE-ALUF)
	(:FLIP (SEND SCREEN :EXCHANGE-TWO-COLORS-ALUF CHAR-ALUF ERASE-ALUF))
	(:NOOP COLOR:ALU-NOOP)))
    (OTHERWISE
      ALU)))

(DEFMETHOD (:POINT SHEET) (X Y)
  ;this doesn't replace the :POINT method of graphics-mixin,
  ;but it supplies one for screens, and permits negative X,Y to compensate
  ;for left,top and oversize to compensate for right,bottom
  (incf x (sheet-inside-left))
  (incf y (sheet-inside-top))
  (IF (OR (< X 0) ( X WIDTH)
	  (< Y 0) ( Y HEIGHT))
      0
      (PREPARE-SHEET (SELF)
	(SHEET-POINT X Y))))

(DEFMETHOD (:DRAW-RECTANGLE SHEET) (RECTANGLE-WIDTH RECTANGLE-HEIGHT X Y &OPTIONAL (ALU :DRAW))
  (SETF ALU (GRAPHICS::STANDARDIZE-ALU SELF ALU))
  (INCF X (SHEET-INSIDE-LEFT))
  (INCF Y (SHEET-INSIDE-TOP))
  (DESTRUCTURING-BIND (INSIDE-LEFT INSIDE-TOP INSIDE-RIGHT INSIDE-BOTTOM) CLIPPING-REGION
    (WHEN (< X INSIDE-LEFT)
      (DECF RECTANGLE-WIDTH (- INSIDE-LEFT X))
      (SETF X INSIDE-LEFT))
    (WHEN (< Y INSIDE-TOP)
      (DECF RECTANGLE-HEIGHT (- INSIDE-TOP Y))
      (SETF Y INSIDE-TOP))
    (SETQ RECTANGLE-WIDTH (MIN RECTANGLE-WIDTH (- INSIDE-RIGHT X)))
    (SETQ RECTANGLE-HEIGHT (MIN RECTANGLE-HEIGHT (- INSIDE-BOTTOM Y))))
  (WHEN (AND (> RECTANGLE-WIDTH 0) (> RECTANGLE-HEIGHT 0))
    (PREPARE-SHEET (SELF)
      (SHEET-DRAW-RECTANGLE RECTANGLE-WIDTH RECTANGLE-HEIGHT X Y ALU))))

(DEFMETHOD (:DRAW-1-BIT-RASTER SHEET)
	   (WID HEI FROM-RASTER FROM-X FROM-Y TO-X TO-Y
		&OPTIONAL (ONES-ALU :DRAW) (ZEROS-ALU :ERASE))
  (SETF ONES-ALU (GRAPHICS::STANDARDIZE-ALU SELF ONES-ALU))
  (SETF ZEROS-ALU (GRAPHICS::STANDARDIZE-ALU SELF ZEROS-ALU))
  (INCF TO-X (SHEET-INSIDE-LEFT))
  (INCF TO-Y (SHEET-INSIDE-TOP))
  (DESTRUCTURING-BIND (CLIP-LEFT CLIP-TOP CLIP-RIGHT CLIP-BOTTOM) CLIPPING-REGION
    (CLIP-FOR-BITBLT WID HEI FROM-X FROM-Y TO-X TO-Y
		     CLIP-LEFT CLIP-TOP CLIP-RIGHT CLIP-BOTTOM))
  (WHEN (AND (> WID 0) (> HEI 0))
    (PREPARE-SHEET (SELF)
      (SHEET-DRAW-1-BIT-RASTER WID HEI
			       FROM-RASTER FROM-X FROM-Y
			       NIL TO-X TO-Y
			       ONES-ALU ZEROS-ALU))))

(DEFMETHOD (:DRAW-CHAR SHEET) (CHAR X-BITPOS Y-BITPOS &OPTIONAL (ALU :DRAW) STYLE)
  (SETF ALU (GRAPHICS::STANDARDIZE-ALU SELF ALU))
  (WITH-CHARACTER-STYLE (STYLE SELF)
    (PREPARE-SHEET (SELF)
      (SHEET-DRAW-CHAR CHAR
		       (+ X-BITPOS (SHEET-INSIDE-LEFT))
		       (+ Y-BITPOS (SHEET-INSIDE-TOP))
		       ALU))))

(DEFMETHOD (:DRAW-GLYPH SHEET) (INDEX FONT X-BITPOS Y-BITPOS &OPTIONAL (ALU :DRAW))
  (SETF ALU (GRAPHICS::STANDARDIZE-ALU SELF ALU))
  (PREPARE-SHEET (SELF)
    (SHEET-DRAW-GLYPH INDEX FONT
		      (+ X-BITPOS (SHEET-INSIDE-LEFT))
		      (+ Y-BITPOS (SHEET-INSIDE-TOP))
		      ALU))) 


;;; Reserve OUTPUT-HEIGHT distance from CURSOR-Y for output.
;;; The caller is responsible for keeping track of how much is already
;;; reserved, and how much space has to be cleared out.
(DEFMETHOD (RESERVE-VERTICAL-SPACE-FOR-OUTPUT SHEET) (OUTPUT-HEIGHT)
  (PREPARE-SHEET (SELF)
    (SHEET-CHECK-MORE-POSITION OUTPUT-HEIGHT)
    (WHEN (NOT (ZEROP (SHEET-EXCEPTIONS)))
      (UNLESS (ZEROP (SHEET-MORE-FLAG))
	(WHEN (> MORE-VPOS CURSOR-Y)
	  (SHEET-DRAW-RECTANGLE (SHEET-INSIDE-WIDTH)
				(MIN (- (SHEET-INSIDE-BOTTOM) CURSOR-Y)
				     (+ (- MORE-VPOS CURSOR-Y) (* LINE-HEIGHT 2)))
				(SHEET-INSIDE-LEFT) CURSOR-Y ERASE-ALUF)))
      (IF (OR (ZEROP (SHEET-MORE-FLAG))
	      (ZEROP (SHEET-END-PAGE-FLAG)))
	  (SEND SELF :HANDLE-EXCEPTIONS)
	;; This is the complicated case.  Both exceptions have
	;; come on, because we moved too far.  Go back and more
	;; first.
	(SETQ CURSOR-Y MORE-VPOS)
	(SETF (SHEET-END-PAGE-FLAG) 0)
	(SEND SELF :HANDLE-EXCEPTIONS)))))

;;; Make sure there is enough room for both OUTPUT-HEIGHT and EXTRA-SPACE-ABOVE.
;;; Then move the cursor down such that the baseline is correct for the total.
(DEFMETHOD (:ALLOCATE-VERTICAL-SPACE-FOR-OUTPUT SHEET) (OUTPUT-HEIGHT EXTRA-SPACE-ABOVE)
  (PREPARE-SHEET (SELF)
    (RESERVE-VERTICAL-SPACE-FOR-OUTPUT SELF (+ OUTPUT-HEIGHT EXTRA-SPACE-ABOVE))
    (SHEET-DRAW-RECTANGLE (SHEET-INSIDE-WIDTH)
			  (MIN (- (SHEET-INSIDE-BOTTOM) CURSOR-Y)
			       (+ OUTPUT-HEIGHT EXTRA-SPACE-ABOVE))
			  (SHEET-INSIDE-LEFT) CURSOR-Y ERASE-ALUF)
    (SHEET-INCREMENT-BITPOS 0 (+ EXTRA-SPACE-ABOVE (MAX 0 (- OUTPUT-HEIGHT
							     CURRENT-LINE-HEIGHT))))))

(DEFMETHOD (NOTE-LINE-HEIGHT-CHANGE SHEET) (NEW-LINE-HEIGHT NEW-BASELINE)
  (LET* ((MOVEMENT (- NEW-BASELINE CURRENT-BASELINE))
	 (OLD-CURRENT-HEIGHT CURRENT-LINE-HEIGHT)
	 (HEIGHT-INCREASE (- NEW-LINE-HEIGHT OLD-CURRENT-HEIGHT)))
    (SETQ CURRENT-LINE-HEIGHT NEW-LINE-HEIGHT)
    (SHEET-CHECK-MORE-POSITION CURRENT-LINE-HEIGHT)		;Get **MORE** processing
    (WHEN (NOT (ZEROP (SHEET-EXCEPTIONS)))
      (SEND SELF :HANDLE-EXCEPTIONS))
    (SETQ CURRENT-BASELINE NEW-BASELINE)
    (WHEN (PLUSP MOVEMENT)
      (MOVE-FOR-LINE-HEIGHT-CHANGE SELF OLD-CURRENT-HEIGHT MOVEMENT HEIGHT-INCREASE))))

(DEFMETHOD (MOVE-FOR-LINE-HEIGHT-CHANGE SHEET) (MOVEMENT-HEIGHT MOVEMENT HEIGHT-INCREASE)
  (RESERVE-VERTICAL-SPACE-FOR-OUTPUT SELF (+ MOVEMENT-HEIGHT HEIGHT-INCREASE))
  (MULTIPLE-VALUE-BIND (INSIDE-WIDTH INSIDE-HEIGHT)
      (SEND SELF :INSIDE-SIZE)
    (IGNORE INSIDE-HEIGHT)
    ;; MOVEMENT is always positive, so this is always moving to increased Y coordinates,
    ;; possibly with some overlap between source and destination
    (LET ((OFFSET-CURSOR-Y (+ CURSOR-Y MOVEMENT)))
      (SHEET-BITBLT ALU-SETA INSIDE-WIDTH (- MOVEMENT-HEIGHT)
		    SCREEN-ARRAY (SHEET-INSIDE-LEFT) CURSOR-Y
		    SCREEN-ARRAY (SHEET-INSIDE-LEFT) OFFSET-CURSOR-Y)
      (SHEET-DRAW-RECTANGLE INSIDE-WIDTH MOVEMENT
			    (SHEET-INSIDE-LEFT SELF) CURSOR-Y
			    ERASE-ALUF)
      (WHEN (> HEIGHT-INCREASE MOVEMENT)
	(SHEET-DRAW-RECTANGLE INSIDE-WIDTH (- HEIGHT-INCREASE MOVEMENT)
			      (SHEET-INSIDE-LEFT SELF) (+ OFFSET-CURSOR-Y MOVEMENT-HEIGHT)
			      ERASE-ALUF)))))

(DEFMETHOD (:FORCE-OUTPUT SHEET) () (SEND SCREEN :FORCE-OUTPUT))
(DEFMETHOD (:FINISH SHEET) () (SEND SCREEN :FINISH))

(DEFMETHOD (:READ-1-BIT-RASTER SHEET) 
	   (WID HEI FROM-X FROM-Y TO-RASTER TO-X TO-Y)

  (INCF FROM-X (SHEET-INSIDE-LEFT))
  (INCF FROM-Y (SHEET-INSIDE-TOP))

  (LET ((CLIP-LEFT 0)
	(CLIP-TOP 0)
	(CLIP-RIGHT WIDTH)
	(CLIP-BOTTOM HEIGHT))
    (CLIP-FOR-BITBLT WID HEI  TO-X TO-Y FROM-X FROM-Y
		     CLIP-LEFT CLIP-TOP CLIP-RIGHT CLIP-BOTTOM))

  (MULTIPLE-VALUE-BIND (CLIP-RIGHT CLIP-BOTTOM) (DECODE-RASTER-ARRAY TO-RASTER)
    (LET ((CLIP-LEFT 0)
	  (CLIP-TOP 0))
    (CLIP-FOR-BITBLT WID HEI FROM-X FROM-Y TO-X TO-Y 
		     CLIP-LEFT CLIP-TOP CLIP-RIGHT CLIP-BOTTOM)))

  (WHEN (AND (> WID 0) (> HEI 0))
    (PREPARE-SHEET (SELF)
      (SHEET-READ-1-BIT-RASTER WID HEI
			       NIL FROM-X FROM-Y
			       TO-RASTER TO-X TO-Y
			       SELF)))
  )

;
; Principle implmentation for windows
;
(DEFMETHOD (:WITH-BIT-ARRAY-OR-STREAM SHEET) (&REST ARGS)
  (PREPARE-SHEET (SELF)
    (CL:APPLY #'%WITH-BIT-ARRAY-OR-STREAM SCREEN SELF ARGS)))

(DEFMETHOD (:WITH-BIT-ARRAY-STREAM SHEET) (&REST ARGS)
  (PREPARE-SHEET (SELF)
    (CL:APPLY #'%WITH-BIT-ARRAY-STREAM SCREEN SELF ARGS)))

(DEFMETHOD (:WITH-BIT-ARRAY SHEET) (&REST ARGS)
  (PREPARE-SHEET (SELF)
    (CL:APPLY #'%WITH-BIT-ARRAY SCREEN SELF ARGS)))

;
; Implementation for rasters to make like streams
;
(DEFUN BIT-ARRAY-AS-BIT-ARRAY-STREAM
       (RASTER DIRECTION CONTINUATION
	&KEY (X-OFFSET 0) (Y-OFFSET 0) HEIGHT FROM-FIELD TO-FIELD &ALLOW-OTHER-KEYS)
  (IGNORE DIRECTION)
  ;utility to provide a stream when a raster is the natural implementation
  (MULTIPLE-VALUE-BIND (NIL R-HEIGHT SPAN)
      (DECODE-RASTER-ARRAY (IF (LISTP RASTER) (FIRST RASTER) RASTER))
    (LET ((E-SPAN SPAN)
	  (H (OR HEIGHT R-HEIGHT))
	  (INDEX (+ X-OFFSET (* SPAN Y-OFFSET))))
      (COND ((EQ DIRECTION :INPUT)
	     (WHEN (EQL FROM-FIELD 2) (INCF INDEX SPAN))
	     (WHEN FROM-FIELD (SETQ E-SPAN (+ SPAN SPAN))))
	    (T
	     (UNLESS (EQL DIRECTION :OUTPUT)
	       (UNLESS (EQL FROM-FIELD TO-FIELD)
		 (FERROR "from field must eql to-field if direction is :BOTH")))
	     (WHEN (EQL TO-FIELD 2) (INCF INDEX SPAN))
	     (WHEN TO-FIELD (SETQ E-SPAN (+ SPAN SPAN)))))
      (LABELS ((NEXT-STEP ()
		 (COND (( H 0) :END)
		       (T (DECF H)
			  (PROG1 INDEX (INCF INDEX E-SPAN))))))
	(FUNCALL CONTINUATION RASTER NIL #'NEXT-STEP)
	)))
  )

;
; Implementation for rasters to make like rasters
;
(DEFUN BIT-ARRAY-AS-BIT-ARRAY
       (RASTER DIRECTION CONTINUATION
	&KEY (X-OFFSET 0)(Y-OFFSET 0) FROM-FIELD TO-FIELD &ALLOW-OTHER-KEYS)
  (MULTIPLE-VALUE-BIND (NIL NIL SPAN) (DECODE-RASTER-ARRAY RASTER)
    (LET ((E-SPAN SPAN))
      (COND ((EQ DIRECTION :INPUT)
	     (WHEN (EQL FROM-FIELD 2) (INCF Y-OFFSET))
	     (WHEN FROM-FIELD (SETQ E-SPAN (+ SPAN SPAN))))
	    (T
	     (UNLESS (EQL DIRECTION :OUTPUT)
	       (UNLESS (EQL FROM-FIELD TO-FIELD)
		 (FERROR "from field must eql to-field if direction is :BOTH")))
	     (WHEN (EQL TO-FIELD 2) (INCF Y-OFFSET))
	     (WHEN TO-FIELD (SETQ E-SPAN (+ SPAN SPAN)))))
      (FUNCALL CONTINUATION RASTER (+ X-OFFSET (* Y-OFFSET SPAN)) E-SPAN))))

;
; Implementation for streams to make like rasters
;
(DEFUN BIT-ARRAY-STREAM-AS-BIT-ARRAY
       (AGENT DIRECTION CONTINUATION &REST ARGS
	&KEY HEIGHT WIDTH TEMPORARY-RASTER FROM-FIELD TO-FIELD &ALLOW-OTHER-KEYS)
  ;utility to provide a raster when a stream is the natural implementation
  (LABELS
    ((READ-IN-RASTER-ARRAY (RAS IGNORE STEPPER)

       (LET* ((E-HEIGHT (COND ((EQL FROM-FIELD 1) (CEILING HEIGHT 2))
			      ((EQL FROM-FIELD 2) (FLOOR HEIGHT 2))
			      (T HEIGHT)))
	      (RASTER (OR TEMPORARY-RASTER
			  (MAKE-TEMPORARY-SHEET-BIT-RASTER AGENT WIDTH E-HEIGHT))))
	 (UNWIND-PROTECT
	     (LOOP REPEAT E-HEIGHT
		   AS Y FROM 0
		   AS IDX = (FUNCALL STEPPER)
		   DO
	       (BITBLT TV:ALU-SETA WIDTH 1 RAS IDX 0 RASTER 0 Y))
	   (UNLESS (EQ RASTER TEMPORARY-RASTER)
	     (DEALLOCATE-TEMP-SHEET-RASTER-AND-HEADER RASTER))
	   ))
       )
     (WRITE-OUT-RASTER-ARRAY (RAS IGNORE STEPPER)
       (LET* ((E-HEIGHT (COND ((EQL TO-FIELD 1) (CEILING HEIGHT 2))
			      ((EQL TO-FIELD 2) (FLOOR HEIGHT 2))
			      (T HEIGHT)))
	      (RASTER (OR TEMPORARY-RASTER
			  (MAKE-TEMPORARY-SHEET-BIT-RASTER AGENT WIDTH E-HEIGHT))))
	 (UNWIND-PROTECT
	     (LOOP INITIALLY (FUNCALL CONTINUATION RASTER NIL STEPPER)
		   REPEAT E-HEIGHT
		   AS Y FROM 0
		   AS IDX = (FUNCALL STEPPER)
		   DO
	       (BITBLT TV:ALU-SETA WIDTH 1 RAS IDX 0 RASTER 0 Y))
	   (UNLESS (EQ RASTER TEMPORARY-RASTER)
	     (DEALLOCATE-TEMP-SHEET-RASTER-AND-HEADER RASTER))
	   ))))
    (CL:APPLY #'WITH-BIT-ARRAY-STREAM
	      AGENT DIRECTION
	      (SELECTQ DIRECTION
		(:INPUT #'READ-IN-RASTER-ARRAY)
		(:OUTPUT #'WRITE-OUT-RASTER-ARRAY)
		(T (FERROR "Direction ~S isn't supported" DIRECTION)))
	      ARGS)))

;
; Implementation for streams to make like bit array streams
;
(DEFUN STREAM-AS-BIT-ARRAY-STREAM (AGENT DIRECTION CONTINUATION
				   &KEY
				   (X-OFFSET 0)
				   (Y-OFFSET 0)
				   (WIDTH)
				   (HEIGHT)
				   (STREAM-WIDTH WIDTH)
				   (STREAM-HEIGHT HEIGHT)
				   (STREAM-FILL-VALUE 0)
				   (MINIMUM-ROWS 1)
				   (BYTE-SIZE (SEND AGENT :BYTE-SIZE))
				   FROM-FIELD
				   TO-FIELD
				   TEMPORARY-RASTER
				   &ALLOW-OTHER-KEYS)

  (CHECK-ARG DIRECTION (LET ((DIR (SEND AGENT :DIRECTION)))
			 (OR (EQ DIR :BIDIRECTIONAL)
			     (EQ DIR DIRECTION)))
	     "invalid direction" )
  
  (LET* ((RASTER TEMPORARY-RASTER)
	 (ALLOCATED-TEMPORARY-RASTER)
	 (ALLOCATED-TEMPORARY-RASTER-2)
	 (ROUND-TO (FLOOR 32. BYTE-SIZE))
	 (ROUNDED-WIDTH (* ROUND-TO (CEILING STREAM-WIDTH ROUND-TO)))
	 (E-HEIGHT (MIN HEIGHT MINIMUM-ROWS))
	 (NATIVE-BYTE-SIZE (SEND AGENT :BYTE-SIZE))	
	 (STRING-WIDTH (CEILING (* ROUNDED-WIDTH BYTE-SIZE) NATIVE-BYTE-SIZE))
	 )

    (UNWIND-PROTECT
	(PROGN

	  (UNLESS RASTER
	    (WITH-STACK-LIST (DIMS E-HEIGHT ROUNDED-WIDTH)
	      (SETQ ALLOCATED-TEMPORARY-RASTER (TV:ALLOCATE-TEMP-SHEET-RASTER-AND-HEADER
						 DIMS
						 :TYPE (COLOR:DATA-ARRAY-TYPE BYTE-SIZE))
		    RASTER ALLOCATED-TEMPORARY-RASTER)))

	  (MULTIPLE-VALUE-BIND (NIL NIL SPAN)(DECODE-RASTER-ARRAY RASTER)
	    (SETQ ALLOCATED-TEMPORARY-RASTER-2 (TV:ALLOCATE-TEMP-SHEET-RASTER-AND-HEADER
						 (* E-HEIGHT
						    STRING-WIDTH)
						 :DISPLACED-TO RASTER
						 :TYPE
						 (COLOR:DATA-ARRAY-TYPE NATIVE-BYTE-SIZE)))
	    (LABELS
	      ((READ-LINES ()
		 (LET ((LINE-INDEX 0)
		       (SKIP-LINE (EQL FROM-FIELD 2))
		       (LIM-INDEX (* SPAN E-HEIGHT)))
		   (LABELS ((FILL-INPUT (NLINES)
			      (LOOP REPEAT NLINES DO
				(MULTIPLE-VALUE-BIND (NIL E)
				    (SEND AGENT :STRING-IN
					  :EOF
					  ALLOCATED-TEMPORARY-RASTER-2
					  LINE-INDEX (+ LINE-INDEX STRING-WIDTH))
				  (WHEN E
				    (RETURN (SETQ STREAM-HEIGHT 0
						  HEIGHT 0))
				    ))))
			    (GET-NEXT-LINE ()
			      (WHEN (AND SKIP-LINE (> HEIGHT 0))
				(DECF HEIGHT)
				(FILL-INPUT 1))
			      (SETQ SKIP-LINE FROM-FIELD)
			      (IF (ZEROP HEIGHT)
				  :END
				  (DECF HEIGHT)
				  (MULTIPLE-VALUE-BIND (NIL EOF)
				      (SEND AGENT :STRING-IN :END
					    ALLOCATED-TEMPORARY-RASTER-2
					    LINE-INDEX (+ LINE-INDEX STRING-WIDTH))
				    (IF EOF
					(PROGN (SETQ HEIGHT 0)
					       :END)
					(PROG1 (+ LINE-INDEX X-OFFSET)
					       (INCF LINE-INDEX SPAN)
					       (WHEN ( LINE-INDEX LIM-INDEX)
						 (SETQ LINE-INDEX 0))))))))
		     (WHEN (AND (> STREAM-HEIGHT 0)
				(> Y-OFFSET 0))
		       (FILL-INPUT Y-OFFSET)
		       (DECF STREAM-HEIGHT Y-OFFSET)
		       )
		     (WHEN (> HEIGHT 0)
		       (DECF STREAM-HEIGHT HEIGHT)
		       (FUNCALL CONTINUATION RASTER NIL #'GET-NEXT-LINE))
		     (WHEN (> STREAM-HEIGHT 0)
		       (FILL-INPUT (+ HEIGHT STREAM-HEIGHT)))
		     )))
	       (WRITE-LINES ()
		 (LET ((LINE-INDEX NIL)
		       (SKIP-LINE (EQL TO-FIELD 2))
		       (LIM-INDEX (* SPAN E-HEIGHT)))
		   (LABELS ((FILL-OUTPUT (NLINES)
			      (LET ((RAS RASTER)
				    (INDEX (OR LINE-INDEX 0)))
				(DECLARE (SYS:ARRAY-REGISTER-1D RAS))
						;do even if nlines=0
				(LOOP FOR I FROM INDEX BELOW (+ INDEX STREAM-WIDTH) DO
				  (SETF (AREF RAS I) STREAM-FILL-VALUE))
				(LOOP REPEAT NLINES DO
				  (SEND AGENT :STRING-OUT RAS INDEX STRING-WIDTH))))
			    (PASS-OUTPUT (NLINES)
			      (SEND AGENT :SET-POINTER
				    (+ (SEND AGENT :READ-POINTER)
				       (* NLINES STREAM-WIDTH))))
			    (PUT-NEXT-LINE ()
			      (WHEN (AND (> HEIGHT 0)
					 SKIP-LINE)
				(IF (EQ DIRECTION :OUTPUT)
				    (FILL-OUTPUT 1)
				    (PASS-OUTPUT 1)))
			      (SETQ SKIP-LINE TO-FIELD)
			      (WHEN (> HEIGHT 0)
				(LET ((NEXT 
					(IF (NULL LINE-INDEX)

					    (SETQ LINE-INDEX 0)

					    (SEND AGENT :STRING-OUT ALLOCATED-TEMPORARY-RASTER-2
						  LINE-INDEX (+ LINE-INDEX STRING-WIDTH))
					    (DECF HEIGHT)
					    (INCF LINE-INDEX SPAN)
					    (WHEN ( LINE-INDEX LIM-INDEX)
					      (SETQ LINE-INDEX 0))
					    (+ X-OFFSET LINE-INDEX))))
				  (IF (EQ DIRECTION :OUTPUT)
				      NEXT
				      (LET ((WHERE (SEND AGENT :READ-POINTER)))
					(MULTIPLE-VALUE-BIND (NIL EOF)
					    (SEND AGENT :STRING-IN :EOF
						  NEXT (+ NEXT STRING-WIDTH))
					  (IF EOF
					      (PROGN (SETQ HEIGHT 0) :END)
					      (SEND AGENT :SET-POINTER WHERE)
					      NEXT))))
				  ))))

		     (WHEN (AND (> STREAM-HEIGHT 0)
				(OR (> Y-OFFSET 0)
				    (> STREAM-WIDTH WIDTH)))
		       ;output leading padding, and set up the buffer
		       ;with padding
			       (IF (EQ DIRECTION :OUTPUT)
			   (FILL-OUTPUT Y-OFFSET)
			   (PASS-OUTPUT Y-OFFSET))
		       (DECF STREAM-HEIGHT Y-OFFSET))

		     (FUNCALL CONTINUATION RASTER NIL #'PUT-NEXT-LINE)
			   
		     (WHEN (> STREAM-HEIGHT 0)
						;output trailing padding
		       (IF (EQ DIRECTION :OUTPUT)
			   (FILL-OUTPUT (+ HEIGHT STREAM-HEIGHT))
			   (PASS-OUTPUT (+ HEIGHT STREAM-HEIGHT)))
		     )))))
	    (IF (EQ DIRECTION :INPUT)
		(READ-LINES)
		(WRITE-LINES))
	    ))
	  ;end of unwind protect
	  )
      (WHEN ALLOCATED-TEMPORARY-RASTER-2
	(TV:DEALLOCATE-TEMP-SHEET-RASTER-AND-HEADER ALLOCATED-TEMPORARY-RASTER-2))
      (WHEN ALLOCATED-TEMPORARY-RASTER
	(TV::DEALLOCATE-TEMP-SHEET-RASTER-AND-HEADER ALLOCATED-TEMPORARY-RASTER))
      )
  ))

;
; Principle implementation for binary streams
;
(DEFMETHOD (:WITH-BIT-ARRAY SI:BINARY-STREAM) (&REST ARGS)
  (CL:APPLY #'BIT-ARRAY-STREAM-AS-BIT-ARRAY SELF ARGS))

(DEFMETHOD (:WITH-BIT-ARRAY-OR-STREAM SI:BINARY-STREAM) (&REST ARGS)
  (CL:APPLY #'WITH-BIT-ARRAY-STREAM SELF ARGS))

(DEFMETHOD (:WITH-BIT-ARRAY-STREAM SI:BINARY-STREAM) (&REST ARGS)
  (CL:APPLY #'STREAM-AS-BIT-ARRAY-STREAM SELF ARGS))
