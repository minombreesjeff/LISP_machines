;;;-*- Mode:LISP; Package:TV; Base:8 -*- 
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>


(defstruct (sheet-raster (:type :named-array-leader) 
			 (:print "~\sheet-raster\" sheet-raster)
			 (:constructor nil)
			 (:size-symbol sheet-raster-leader-length))
  (unused-0 nil)			;Fill pointer, unused
  (sheet-raster-sheet)		        ;the parent sheet
  )


(format:defformat format:sheet-raster (:one-arg) (arg options)
  (ignore options)
  (printing-random-object (arg format:*format-output*)
    (multiple-value-bind (x y)(decode-raster-array arg)
      (format format:*format-output* "~A ~Dx~Dx~Db"
	      (typep arg)
	      x y (si:array-element-byte-size arg))
      (let ((sheet (sheet-raster-sheet arg)))
	(when sheet (format format:*format-output* " for ~A"
			    (send sheet :name)))
    ))))

(defgeneric raster-sheet (raster)
  (:FUNCTION
    (cond ((let ((name (named-structure-p raster)))
	     (and name
		  (or (member name '(sheet-raster color:color-raster-array))
		      (typep raster 'sheet-raster))))
	   (sheet-raster-sheet raster))
	  ((instancep raster)
	   (funcall (flavor::generic raster-sheet) raster))))
  )

(defmethod (raster-sheet sheet) () self)

(defgeneric raster-screen (raster)
  (:function
    (let ((sheet (tv:raster-sheet raster)))
      (cond ((instancep sheet)
	     (values (tv:sheet-screen sheet) sheet))
	    (t (values nil sheet))))))


(DEFMETHOD (CHANGE-SCREEN-SHAPE SCREEN-MICROCODED-GRAPHICS-MIXIN)
	   (NEW-BUFFER-ADDRESS NEW-WIDTH NEW-HEIGHT NEW-BITS-PER-PIXEL)
  (COND ((AND (EQ BUFFER NEW-BUFFER-ADDRESS)
	      (= BITS-PER-PIXEL NEW-BITS-PER-PIXEL)
	      (= WIDTH NEW-WIDTH) (= HEIGHT NEW-HEIGHT))
	 NIL)
	(T
	 (LET ((CHANGE-OF-BITS-PER-PIXEL (NOT (= BITS-PER-PIXEL NEW-BITS-PER-PIXEL))))
	   (SETF BUFFER NEW-BUFFER-ADDRESS)
	   (SETF BITS-PER-PIXEL NEW-BITS-PER-PIXEL)
	   (SETF WIDTH NEW-WIDTH) (SETF HEIGHT NEW-HEIGHT)
	   (SEND SELF :ADJUST-SCREEN-ARRAY OLD-SCREEN-ARRAY BUFFER)
	   (WHEN CHANGE-OF-BITS-PER-PIXEL
	     (DOLIST (I INFERIORS)
	       (SEND I :CHANGE-OF-SCREEN CHANGE-OF-BITS-PER-PIXEL))))
	 T)))

;For screens, the position and size can't change and NEW-POINTER is always the address
;of the hardware screen buffer.
(DEFMETHOD (:ADJUST-SCREEN-ARRAY SCREEN-MICROCODED-GRAPHICS-MIXIN) (ARRAY NEW-POINTER)
  (LET ((XOFF X-OFFSET) (YOFF Y-OFFSET))
    ;; The who-line screen has an offset from its buffer
    (WHEN (CL:TYPEP NEW-POINTER #+3600 'SCL:LOCATIVE #+IMACH 'SYS:PHYSICAL-ADDRESS)
      (SETF NEW-POINTER
	    (%POINTER-PLUS NEW-POINTER (CL:// (* BITS-PER-PIXEL (+ XOFF (* WIDTH YOFF))) 32.)))
      (SETF XOFF 0)
      (SETF YOFF 0))
    (SEND SCREEN :INFERIOR-SCREEN-ARRAY-ADJUSTED SELF ARRAY WIDTH HEIGHT NEW-POINTER XOFF YOFF)
    (WHEN (EQ ARRAY SCREEN-ARRAY)
      (ADJUST-INFERIOR-SCREEN-ARRAYS SELF ARRAY 0 0)))
  NIL)

(DEFMETHOD (SCREEN-FOLLOW-DRAWABLE-INDIRECTION SCREEN-MICROCODED-GRAPHICS-MIXIN)
	   (DRAWABLE X-OFFSET Y-OFFSET)
  (MULTIPLE-VALUE-BIND (IGNORE IGNORE SPAN)
      (DECODE-RASTER-ARRAY DRAWABLE)
    (IF (ZEROP SPAN)
	(VALUES DRAWABLE X-OFFSET Y-OFFSET)
	(LET ((INDEX-OFFSET 0))
	  (LOOP WHILE (ARRAY-INDIRECT-P DRAWABLE)
		AS NEXT-POINTER = (SI:ARRAY-INDIRECT-TO DRAWABLE)
		WHILE (AND (ARRAYP NEXT-POINTER)
			   (= 2 (ARRAY-#-DIMS NEXT-POINTER)))
		DO (INCF INDEX-OFFSET (SI:ARRAY-INDEX-OFFSET DRAWABLE))
		   (SETQ DRAWABLE NEXT-POINTER))
	  (MULTIPLE-VALUE-BIND (YOFF XOFF)
	      (FLOOR INDEX-OFFSET SPAN)
	    (VALUES DRAWABLE (+ X-OFFSET XOFF) (+ Y-OFFSET YOFF)))))))

(DEFUN REDIRECT-TV-RASTER (RASTER TYPE WIDTH HEIGHT DISPLACED-TO X-OFFSET Y-OFFSET)
  (WITH-STACK-LIST (.DIMLIST. HEIGHT WIDTH)
    (WITHOUT-INTERRUPTS
      (SETQ %CURRENT-SHEET NIL)
      (COND ((AND (ZEROP X-OFFSET) (ZEROP Y-OFFSET))
	     (SI:CHANGE-INDIRECT-ARRAY RASTER TYPE .DIMLIST. DISPLACED-TO NIL))
	    ((zerop y-offset)
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")	     ;avoid decode-raster-array when the y-offset is zero, which it
	     ;will be if displaced-to isn't a 2d array
0	     (when #+3600 (or (fixp displaced-to)
			      (locativep displaced-to))
		   #+imach (typep displaced-to :physical-address)
		   1;incorporate the index-offset into physical addresses, since
0		   1;horible things happen if we dont.  Better to do it here than
0		   1;require all callers to do it.
0		   (setq displaced-to
			 (%pointer-plus displaced-to
					(floor x-offset
					       (cdr (assoc type si:array-elements-per-q))))
			 x-offset 0))
	     (SI:CHANGE-INDIRECT-ARRAY RASTER TYPE .DIMLIST. DISPLACED-TO X-OFFSET)
	     )
	    (T
	     (MULTIPLE-VALUE-BIND (IGNORE IGNORE SPAN)
		 (DECODE-RASTER-ARRAY DISPLACED-TO)
	       (SI:CHANGE-INDIRECT-ARRAY
		 RASTER TYPE .DIMLIST. DISPLACED-TO
		 (+ X-OFFSET (* Y-OFFSET
				(// (* (SI:ARRAY-ELEMENT-BYTE-SIZE DISPLACED-TO)
				       SPAN)
				    (CDR (ASSOC TYPE si:array-bits-per-element))
				    ))))))))))

;;Some screens define a method for this message, to adjust augmentations of the screen array.
;; This method does the actual alteration of the screen array
(DEFMETHOD (:INFERIOR-SCREEN-ARRAY-ADJUSTED SCREEN-MICROCODED-GRAPHICS-MIXIN)
	   (SHEET RASTER W H NEW-POINTER X-OFFSET Y-OFFSET)
  SHEET ;Ignored
  (REDIRECT-TV-RASTER RASTER (SHEET-ARRAY-TYPE SELF) W H NEW-POINTER X-OFFSET Y-OFFSET)
  (WHEN (TYPEP RASTER 'SHEET-RASTER)
1    ;set the associated sheet
0    (SETF (SHEET-RASTER-SHEET RASTER) SHEET))
  NIL)


;Some screens have augmented screen arrays and hence redefine this method.
;The index offset of the screen array will be corrected, if necessary, by exposing.
(DEFMETHOD (:CREATE-SCREEN-ARRAY SCREEN-MICROCODED-GRAPHICS-MIXIN) (W H DISPLACED-TO)
1  ;make the raster array, but don't set the associated sheet yet
0  (MAKE-RASTER-ARRAY W H :TYPE (SHEET-ARRAY-TYPE SELF)
		     :NAMED-STRUCTURE-SYMBOL 'SHEET-RASTER
		     :LEADER-LENGTH SHEET-RASTER-LEADER-LENGTH
		     :DISPLACED-TO DISPLACED-TO
		     :DISPLACED-INDEX-OFFSET (AND (ARRAYP DISPLACED-TO) 0)
		     :DISPLACED-CONFORMALLY (ARRAYP DISPLACED-TO)))

(DEFMETHOD (:INIT SCREEN-MICROCODED-GRAPHICS-MIXIN :AFTER) (IGNORE)
  (SETQ OLD-SCREEN-ARRAY (SEND SELF :CREATE-SCREEN-ARRAY WIDTH (OR HEIGHT 1) BUFFER))
  NIL)

(DEFMETHOD (SCREEN-ALU-PRESENTATION-TYPE SCREEN-MICROCODED-GRAPHICS-MIXIN) ()
  'TV:MICROCODED-GRAPHICS-ALU)

;;; Put the run light in the second line of the :RUN-LINE directly
;;; under the :RUN-STATE window.
(DEFMETHOD (WHO-LINE-RUN-LIGHT-LOC SCREEN-MICROCODED-GRAPHICS-MIXIN) ()
  (AND (CL:TYPEP BUFFER #+3600 'SCL:LOCATIVE #+IMACH 'SYS:PHYSICAL-ADDRESS)
       (LET ((RUN-Y (SEND (GET-WHO-LINE-FIELD :RUN-LINE SELF) :Y-OFFSET)))
	 (AND RUN-Y
	      (LET ((RUN-X (SEND (GET-WHO-LINE-FIELD :RUN-STATE SELF) :X-OFFSET)))
		(%POINTER-PLUS BUFFER
			       (ROUND (* BITS-PER-PIXEL
					 (+ RUN-X (* WIDTH (+ Y-OFFSET RUN-Y 1))))
				      32.)))))))

(DEFMETHOD (SCREEN-PERMITS-BIT-SAVE-ARRAYS SCREEN-MICROCODED-GRAPHICS-MIXIN) () T)

(DEFMETHOD (%SCREEN-ALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN-MICROCODED-GRAPHICS-MIXIN)
	   (SHEET WIDTH HEIGHT)
  ;;; call a special function to make a temporary bit array
  ;;; this is a hook for later using a temporary-array resource
  (MAKE-TEMPORARY-SHEET-BIT-RASTER SHEET WIDTH HEIGHT))

(DEFMETHOD (%SCREEN-DEALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN-MICROCODED-GRAPHICS-MIXIN)
	   (SHEET PIXMAP)
  SHEET
  (DEALLOCATE-TEMPORARY-SHEET-BIT-RASTER PIXMAP))

(DEFMETHOD (VERIFY-DRAWABLE SCREEN-MICROCODED-GRAPHICS-MIXIN) (PIXMAP SHEET DIRECTION)
  PIXMAP SHEET DIRECTION
  :LOCAL)

(DEFMETHOD (%SCREEN-PAGE-IN-SHEET-TEMPORARY-BIT-ARRAY SCREEN-MICROCODED-GRAPHICS-MIXIN)
	   (SHEET PIXMAP DIRECTION)
  SHEET DIRECTION
  (PAGE-IN-RASTER-ARRAY PIXMAP))

(DEFMETHOD (%SCREEN-PAGE-OUT-SHEET-TEMPORARY-BIT-ARRAY SCREEN-MICROCODED-GRAPHICS-MIXIN)
	   (SHEET PIXMAP)
  SHEET
  (PAGE-OUT-RASTER-ARRAY PIXMAP))


(DEFMETHOD (%WITH-BIT-ARRAY-STREAM SCREEN-MICROCODED-GRAPHICS-MIXIN)
	   (SHEET-OR-RASTER &REST ARGS)
  (CL:APPLY #'BIT-ARRAY-AS-BIT-ARRAY-STREAM
	    (IF (ARRAYP SHEET-OR-RASTER)
		SHEET-OR-RASTER
		(SHEET-SCREEN-ARRAY SHEET-OR-RASTER))
	    ARGS))

(DEFMETHOD (%WITH-BIT-ARRAY SCREEN-MICROCODED-GRAPHICS-MIXIN)
	   (SHEET-OR-RASTER DIRECTION CONTINUATION &REST ARGS)
  (IGNORE DIRECTION)
  (CL:APPLY #'BIT-ARRAY-AS-BIT-ARRAY
	    (IF (ARRAYP SHEET-OR-RASTER)
		SHEET-OR-RASTER
		(SHEET-SCREEN-ARRAY SHEET-OR-RASTER))
	    DIRECTION CONTINUATION ARGS))



;;; Output primitives
;;; These messages are only sent by the SHEET-DRAW-xxx macros defined in LTVDEF

;;; Notes on this excessively hairy macrology:
;;;
;;; This bunch of macros exist for the sole purpose of encapsulating the
;;; interactions between screens and alus.  They are used in four places;
;;; in SCREEN-MICROCODED-GRAPHICS-MIXIN, SINGLE-BIT-SCREEN-MIXIN, MULTI-BIT-SCREEN-MIXIN,
;;; and in COMMON-COLOR-HARDWARE-MIXIN.
;;; These correspond to the "Vanilla screen", "Vanilla 1 bit/pixel screen",
;;; "Vanilla multi-bit/pixel screen" and "any color screen".
;;; If, in the future, there come to be new types of hardware
;;; that don't fit any of these, then these macros will get even hairier.   The
;;; point is that the screen's :%DRAW-xx methods stay simple - all the duplicate
;;; code is encapsulated in these hairy macros.
;;;
;;; Since these macros are not intended to be used except by these special mixins,
;;; their argument lists and the set of names used freely are fairly arbitrary.
;;; It isn't worth the effort and the probability of breaking them to fix all
;;; these macros so they are completely parameterized.

(DEFMACRO B&W-FONT-ALU (ALU &OPTIONAL ARRAY)
  `(COND ((<= 0 ,ALU #O17)
	  (LET ((ALU (%LOGLDB COLOR:%%B&W-FONT-ALU (AREF COLOR:*ALU-INFO* ,ALU))))
	    (IF (EQ ,ARRAY :NOT-MASKED-BITS)
		;; if not-masked-bits is requested, substitute complementary alus
		;; this is basicly useless, but compatability...
		(SELECTOR ALU =
		  (TV:ALU-ANDCA TV:ALU-AND)
		  (TV:ALU-XOR COLOR:ALU-X=Y)
		  (TV:ALU-IOR COLOR:ALU-~X+Y)
		  (T ALU))
		ALU)))
	 (T ,ALU)))



;
; convert font alus to one of the canonical four,
; respect the %literal-alu bit to prevent that conversion
;
(defmacro (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")simplify-b&w-alu0 (ALU ARRAY ARRAY-TYPE
			    &key
			    (mask 'tv:bitblt-unpacking-mask)
			    (type nil)
			    (sheet 'sheet)
			    (const 'tv:bitblt-unpacking-constant))
  (ignore mask const sheet)
  (let ((font-type (member type '(:BITBLT :FONT))))
    `(let ,(when font-type
	     `((LIT (OR ( %LITERAL-ALU ,ALU (+ %LITERAL-ALU #o17))
			,@(when (eq type :BITBLT)
			    `((NOT (MEMBER ,ARRAY-TYPE
					   '(:FILL :MASKED-BITS :NOT-MASKED-BITS)))))
			))))
       (WHEN ( ,ALU 0) (SETQ ,ALU (LDB (BYTE 4 0) ,ALU)))
       (WHEN (OR ,@(when (NULL TYPE) `(,T))
		 ,@(when FONT-TYPE `((NOT LIT))))
1	 ;drawing microcode requires that it be drawing with ones.
0	 (multiple-value (,alu ,const ,mask)
	   (color:combine-alu-and-data ,alu (- (logand ,const 1))(- (logand ,mask 1))))
	 (SETQ ,ALU (B&W-FONT-ALU ,ALU ,(IF (EQ TYPE :FONT) ARRAY-TYPE ARRAY)))
	 ))))


;
; default way to try to simplify a color alu, preferring
; to eliminate plane mask and fill data
;
(defmacro 2simplify-color-alu0 (ALU ARRAY ARRAY-TYPE
			      &key (mask 'tv:bitblt-unpacking-mask)
			      (type nil)
			      (const 'tv:bitblt-unpacking-constant))

  `(MULTIPLE-VALUE (NIL NIL ,ALU ,ARRAY ,CONST ,MASK)
     (COLOR:DEFAULT-FIGURE-USABLE-COLOR-PARAMETERS
       ,MASK
       ,CONST
       ,ALU
       ,(IF (EQ TYPE :FONT)
	    `(IF (EQ (ARRAY-TYPE FONT) 'ART-1B) :FONT :BITBLT)
	    TYPE)
       ,ARRAY-TYPE ,ARRAY)))

;
; prepare to draw using lispm software (using ucode on 36xx)
;
(DEFMACRO 2WITH-LISPM-DRAWING-ENVIRONMENT 
0	  ((ALU TYPE ARRAY-TYPE ARRAY &KEY (COLOR T))
	   &BODY BODY)
  `(PROGN
     ,@(IF COLOR
	   `((SIMPLIFY-COLOR-ALU ,ALU ,ARRAY ,ARRAY-TYPE
				 :TYPE ,TYPE)
	     ,@BODY)
	   `((SIMPLIFY-B&W-ALU ,ALU ,ARRAY ,ARRAY-TYPE
			       :TYPE ,TYPE)
	     ,@BODY
	     ))))

;
; extract alu, mask, and fill data from the environment and the alu
;
(defmacro 2EXTRACT-ALU0 (alu type &key
		       (color T)
		       (mask 'tv:bitblt-unpacking-mask)
		       (value 'tv:bitblt-unpacking-constant)
		       (sheet 'tv:sheet)
		       (array-type)
		       (array)
		       )
  `(CL:ETYPECASE ,ALU
     (CL:FIXNUM
       (COND ((= (LDB (BYTE 8. 24.) ,ALU) #O377) ;; < ALU 0, negative alus on
	      ;;
	      ;; kludgey, obsolete, undocumented "negative alus"
	      ;;
	      (LET ((ALU-SPEC (- ,ALU)))
		(SETQ ,MASK (LDB (BYTE 8. 8.) ALU-SPEC))
		(WHEN (ZEROP ,MASK)
		  (SETQ ,MASK #O377))
		(SETQ ,VALUE (LDB (BYTE 8. 0) ALU-SPEC))
		,@(COND ((EQ TYPE :FONT) `((SETQ ,ALU ALU-IOR)))
			(T `((SETQ ,ALU ALU-SETA))))
		))))
     (SCL:INSTANCE
       ,(IF COLOR
	    `(MULTIPLE-VALUE (,ARRAY-TYPE
			      ,MASK
			      NIL
			      ,VALUE
			      ,ALU)
	       (SEND ,ALU :SC-PARAMETERS ,SHEET ,ARRAY))
	    `(MULTIPLE-VALUE (,ALU ,VALUE ,MASK)
	       (SEND ,ALU :1-BIT-PARAMETERS ,SHEET))
	    ))))

(defmacro parse-local-drawing-body ((&key color drawing-function array-type) &body forms)
  (ignore array-type)
  (SELECTQ (FIRST FORMS)
    (:%DRAW-POINT
     (if drawing-function
	 `(,drawing-function array x y alu)
	 `(SETF (RASTER-AREF ARRAY X Y)
		(IF (ZEROP (LOGAND COLOR:%EXTENDED-ALU ALU))
		    ,(IF (NOT COLOR)
			 '(BOOLE ALU BITBLT-UNPACKING-CONSTANT
				 (RASTER-AREF ARRAY X Y))
			 '(LET ((OLDVAL (RASTER-AREF ARRAY X Y)))
			    (LOGIOR (LOGAND BITBLT-UNPACKING-MASK
					    (BOOLE ALU
						   BITBLT-UNPACKING-CONSTANT
						   OLDVAL)
					    )
				    (BOOLE ALU-ANDCA
					   BITBLT-UNPACKING-MASK
					   OLDVAL))))
		    (LET ((TEMP  (ASSQ ALU COLOR:*ALL-THE-ALU-FNS*)))
		      (IF TEMP
			  (FUNCALL (CADR TEMP) BITBLT-UNPACKING-CONSTANT
				   (RASTER-AREF ARRAY X Y) BITBLT-UNPACKING-MASK)
			  (FERROR "~a is an undefined alu" ALU))))
		)))
    (:%READ-POINT
     `(,(or drawing-function 'RASTER-AREF)
       ARRAY X Y))
    (:%BITBLT					
     `(,(OR DRAWING-FUNCTION (IF COLOR 'BITBLT-UNPACKED 'BITBLT))
       ALU W H
       (OR FROM-ARRAY ARRAY) FROM-X FROM-Y
       (OR TO-ARRAY ARRAY) TO-X TO-Y))
    (:%DRAW-1-BIT-RASTER
     `(,(OR DRAWING-FUNCTION (IF COLOR 'BITBLT-UNPACKED 'BITBLT))
       ALU W H
       PATTERN FROM-X FROM-Y
       ARRAY TO-X TO-Y))
    ((:%DRAW-CHAR :%DRAW-GLYPH)
     `(,(OR DRAWING-FUNCTION '%DRAW-CHAR-CLIPPED-INTERNAL)
       CHAR FONT X Y ALU ARRAY
       (SHEET-CLIPPING-REGION SHEET)))
    (:%DRAW-RECTANGLE
     `(,(or drawing-function '%DRAW-RECTANGLE-INTERNAL)
       W H X Y ALU ARRAY))
    (:%DRAW-MULTIPLE-RECTANGLES
     `(,(or drawing-function '%DRAW-MULTIPLE-RECTANGLES-INTERNAL)
       ALU RECTS ARRAY))
    (:%DRAW-LINE
     `(,(or drawing-function '%DRAW-LINE-INTERNAL)
       X1 Y1 X2 Y2 ALU DRAW-END-POINT ARRAY))
    (:%DRAW-MULTIPLE-LINES
     `(,(or drawing-function '%DRAW-MULTIPLE-LINES-INTERNAL)
       ALU LINES DRAW-END-POINT ARRAY))
    (:%DRAW-STRING
     `(LET ((BOUNDS (SHEET-CLIPPING-REGION SHEET)))
	(WITH-STACK-LIST (BOUNDS (POP BOUNDS)
				 (POP BOUNDS)
				 (MIN XLIM (POP BOUNDS))
				 (POP BOUNDS))
	  (,(or drawing-function '%DRAW-STRING-CLIPPED-INTERNAL)
	   ARRAY ALU X Y STRING FONT INDEX LIMIT BOUNDS))))
    (:%DRAW-TRIANGLE
     `(,(or drawing-function '%DRAW-TRIANGLE-INTERNAL)
       X1 Y1 X2 Y2 X3 Y3 ALU ARRAY LIMITS))
    (:%WITH-ALU-CACHED
     `(LEXPR-SEND SHEET MESSAGE ALU ARRAY ARGS))
    (T (unless (listp (first forms))
	 (ferror "No forms for ~S" forms))
       `(progn ,@FORMS))))


(DEFMACRO WITH-SCREEN-DRAWING-ENVIRONMENT
	  ((TYPE &KEY
		 (DRAWING-ENVIRONMENT 'WITH-LISPM-DRAWING-ENVIRONMENT)
		 (WITH-PREPARED-SHEET T)	;; option to don't require the prepare-sheet
		 (COLOR NIL)			;; multi bit/pixel flag
		 (DRAWING-FUNCTION)
		 (MASK '(BITBLT-UNPACKING-MASK BITBLT-UNPACKING-MASK))
		 (VALUE '(BITBLT-UNPACKING-CONSTANT BITBLT-UNPACKING-CONSTANT))
		 (ARRAY '(ARRAY (SHEET-SCREEN-ARRAY SHEET)))
		 (ARRAY-TYPE '(ARRAY-TYPE :DEFAULT))
		 (ALU '(ALU ALU))
		 (DRAW-CHAR)
		 )
	   &BODY FORMS)
  (LET* ((DRAWING-ENVIRONMENT (IF (LISTP DRAWING-ENVIRONMENT)
				  DRAWING-ENVIRONMENT
				  (LIST DRAWING-ENVIRONMENT)))
	 (NARRAY (FIRST ARRAY))
	 (NALU (FIRST ALU))
	 (USE-ARRAY-TYPE (AND ARRAY-TYPE
			      (OR COLOR
				  (MEMQ TYPE '(:BITBLT :FONT)))))
	 (NARRAY-TYPE (WHEN USE-ARRAY-TYPE (FIRST ARRAY-TYPE)))
	 (BODY `((parse-local-drawing-body
		   (:color ,color :drawing-function ,drawing-function
			   :array-type ,narray-type)
		   ,@forms)))
	 (MAIN-ROUTINE
	  `(LET* (;; put in bindings as specified, or defaulted from the keywords
		  ,@(AND MASK (LIST MASK))
		  ,@(AND VALUE (LIST VALUE))
		  ,@(AND ARRAY (LIST ARRAY))
		  ,@(AND USE-ARRAY-TYPE
			 (LIST ARRAY-TYPE))
		  ,@(AND ALU (LIST ALU))
		  ,@(AND DRAW-CHAR `((FONT)))
		  )

	     (EXTRACT-ALU ,NALU ,TYPE :ARRAY ,NARRAY :ARRAY-TYPE ,NARRAY-TYPE :COLOR ,COLOR)

	     ;;
	     ,@(AND DRAW-CHAR
		    `((MULTIPLE-VALUE (CHAR FONT)
			(SHEET-GET-CHAR-INDEX-AND-FONT CHAR NIL SHEET))))
	     
	     ;; bless and transform the alu to the actual form we use
	     ;;
	     (,(CAR DRAWING-ENVIRONMENT)
	      (,NALU ,type ,NARRAY-TYPE ,NARRAY :COLOR ,COLOR
	       ,@(CDR DRAWING-ENVIRONMENT))
	      ,@body)
	     )))

    (WHEN WITH-PREPARED-SHEET
      (SETQ MAIN-ROUTINE `(IF (NEQ SHEET CURRENTLY-PREPARED-SHEET)
			      (ERROR 'DRAW-ON-UNPREPARED-SHEET :SHEET SHEET)
			      ,MAIN-ROUTINE)))

    MAIN-ROUTINE))


;; This moby macro is the whole body of draw-1-bit-raster for color screens.
;; It is separated because it is used by system COLOR as well as in MULTI-BIT-SCREEN-MIXIN
(DEFMACRO DRAW-COLOR-1-BIT-RASTER (DRAWING-ENVIRONMENT &key OPTIMIZE-ZEROS)
  `(MULTIPLE-VALUE-BIND (COMBINED-ALU
			 O-ALU O-CONST O-MASK
			 Z-ALU Z-CONST Z-MASK
			 )
       (COMBINE-COLOR-ALUS ONES-ALU ZEROS-ALU)
     (WHEN (NULL ARRAY) (SETF ARRAY (SHEET-SCREEN-ARRAY SHEET)))
     (IF (AND COMBINED-ALU
	      (EQL Z-MASK O-MASK)
	      (EQL O-CONST Z-CONST))

	 ;;if both mask and data match, we really can combine the alus
	 (IF (EQL O-ALU Z-ALU)

1	     ;pretty useless, but becomes draw-rectangle
0	     (LET ((ALU COMBINED-ALU)
		   (ARRAY-TYPE :DEFAULT)
		   (X TO-X)
		   (Y TO-Y))
	       (WITH-SCREEN-DRAWING-ENVIRONMENT
		 (NIL :COLOR T
		      :DRAWING-ENVIRONMENT ,DRAWING-ENVIRONMENT
		      :MASK (BITBLT-UNPACKING-MASK O-MASK)
		      :VALUE (BITBLT-UNPACKING-CONSTANT O-CONST)
		      :ARRAY (ARRAY ARRAY)
		      :ARRAY-TYPE (ARRAY-TYPE ARRAY-TYPE))
		 :%DRAW-RECTANGLE))

1	     ;successfully combined the alus
0	     (LET ((ALU COMBINED-ALU)
		   (ARRAY-TYPE :MASKED-BITS))
	       ;;we combined the alu.  The only way this can
	       ;;happen is if either the ones or zeros were a noop
	       ;;use :MASKED-BITS or :NOT-MASKED-BITS as appropriate
	       ;;the #B1010 is boolean magic based on mapping between
	       ;;form and function of boolean opcodes
	       (UNLESS (= #B0010 (LOGAND #B1010 ALU))
		 (SETF ALU (ASH (LOGAND #B1010 ALU) -1))
		 (SETF ARRAY-TYPE :NOT-MASKED-BITS))
	       (WITH-SCREEN-DRAWING-ENVIRONMENT
		 (:BITBLT :COLOR T
			  :DRAWING-ENVIRONMENT ,DRAWING-ENVIRONMENT
			  :MASK (BITBLT-UNPACKING-MASK O-MASK)
			  :VALUE (BITBLT-UNPACKING-CONSTANT O-CONST)
			  :ARRAY (ARRAY ARRAY)
			  :ARRAY-TYPE (ARRAY-TYPE ARRAY-TYPE)
			  )
		 :%DRAW-1-BIT-RASTER)))

	 ;;two passes.  It is conceivable to optimize out the second pass
	 ;;in cases where the masks match, by using a temporary array and
	 ;;constructing the combined picture in two passes, then using the
	 ;;temp to paint the screen in one pass. For now, it doesn't seem
	 ;;worth it. 
	 (LET ((OPT (AND ,OPTIMIZE-ZEROS
			 (EQL O-MASK Z-MASK)
			 (MEMBER O-ALU '(0 5 15.))
			 (MEMBER Z-ALU '(0 5 15.)))))
	   (WHEN OPT
	     (LET ((ALU Z-ALU)
		   (ARRAY-TYPE :DEFAULT)
		   (X TO-X)
		   (Y TO-Y))
	       (WITH-SCREEN-DRAWING-ENVIRONMENT
		 (NIL :COLOR T
		      :DRAWING-ENVIRONMENT ,DRAWING-ENVIRONMENT
		      :MASK (BITBLT-UNPACKING-MASK Z-MASK)
		      :VALUE (BITBLT-UNPACKING-CONSTANT Z-CONST)
		      :ARRAY (ARRAY ARRAY)
		      :ARRAY-TYPE (ARRAY-TYPE ARRAY-TYPE))
		 :%DRAW-RECTANGLE)))
	     
	   (WITH-SCREEN-DRAWING-ENVIRONMENT
	     (:BITBLT :ALU (ALU O-ALU)
		      :COLOR T
		      :MASK (BITBLT-UNPACKING-MASK O-MASK)
		      :VALUE (BITBLT-UNPACKING-CONSTANT O-CONST)
		      :ARRAY (ARRAY ARRAY)
		      :DRAWING-ENVIRONMENT ,DRAWING-ENVIRONMENT
		      :ARRAY-TYPE (ARRAY-TYPE :MASKED-BITS)
		      )
	     :%DRAW-1-BIT-RASTER)

	   (UNLESS OPT
	     (WITH-SCREEN-DRAWING-ENVIRONMENT
	       (:BITBLT :ALU (ALU Z-ALU)
			:COLOR T			
			:MASK (BITBLT-UNPACKING-MASK Z-MASK)
			:VALUE (BITBLT-UNPACKING-CONSTANT Z-CONST)
			:ARRAY (ARRAY ARRAY)
			:DRAWING-ENVIRONMENT ,DRAWING-ENVIRONMENT
			:ARRAY-TYPE (ARRAY-TYPE :NOT-MASKED-BITS)
			)
	       :%DRAW-1-BIT-RASTER)))
	 )
     ))

;; Combine CHAR-ALUF and ERASE-ALUF for use by DRAW-1-BIT-RASTER on a 1-bit screen
(DEFUN 2COMBINE-1-BIT-ALUS0 (ONES-ALU ZEROS-ALU)
  (LET* ((O-MASK 1)
	 (O-CONST 1)
	 (O-ALU ONES-ALU)
	 (Z-MASK 1)
	 (Z-CONST 1)
	 (Z-ALU ZEROS-ALU))
    (EXTRACT-ALU O-ALU :PLAIN :COLOR T :MASK O-MASK :VALUE O-CONST
		 :COLOR NIL
		 :SHEET NIL)
    (EXTRACT-ALU Z-ALU :PLAIN :COLOR T :MASK Z-MASK :VALUE Z-CONST
		 :COLOR NIL
		 :SHEET NIL)
    (SIMPLIFY-B&W-ALU Z-ALU NIL NIL
		      :TYPE :FONT
		      :MASK Z-MASK
		      :CONST Z-CONST)
    (SIMPLIFY-B&W-ALU O-ALU NIL NIL
		      :TYPE :FONT
		      :MASK O-MASK
		      :CONST O-CONST)
    ;; this is Boolean magic to construct a new alu code which combines
    ;; the effects of doing a DRAW-xx with ONES-ALU everywhere there is a 1 in the source
    ;; and that of doing a DRAW-xx with ZEROS-ALU everywhere there is a 0 in the source.
    (LOGIOR (LOGAND O-ALU #B0101)
	    (ASH (LOGAND Z-ALU #B0101) 1))
    ))

;; Combine CHAR-ALUF and ERASE-ALUF for use by DRAW-1-BIT-RASTER in a multi bit screen.
(DEFUN COMBINE-COLOR-ALUS (ONES-ALU ZEROS-ALU &OPTIONAL (MASK BITBLT-UNPACKING-MASK))
  (LET* ((O-MASK MASK)
	 (O-CONST -1)
	 (O-ALU ONES-ALU)
	 (Z-MASK MASK)
	 (Z-CONST -1)
	 (Z-ALU ZEROS-ALU))
    (EXTRACT-ALU O-ALU :PLAIN :COLOR T :MASK O-MASK :VALUE O-CONST 
		 :SHEET NIL)
    (EXTRACT-ALU Z-ALU :PLAIN :COLOR T :MASK Z-MASK :VALUE Z-CONST
		 :SHEET NIL)
    (COND ((AND ( 0 O-ALU 15.)( 0 Z-ALU 15.))
	   (SIMPLIFY-COLOR-ALU Z-ALU NIL NIL
			       :TYPE :PLAIN
			       :MASK Z-MASK
			       :CONST Z-CONST)
	   (SIMPLIFY-COLOR-ALU O-ALU NIL NIL
			       :TYPE :PLAIN
			       :MASK O-MASK
			       :CONST O-CONST)
	   ;; this is Boolean magic to construct a new alu code which combines
	   ;; the effects of doing a DRAW-xx with ONES-ALU everywhere there is a 1 in the source
	   ;; and that of doing a DRAW-xx with ZEROS-ALU everywhere there is a 0 in the source.

	   (VALUES (LOGIOR (LOGAND O-ALU #B0101)
			   (ASH (LOGAND Z-ALU #B0101) 1))
						;we return all this other stuff because usually 
						;the combined alu can't do the job
		   (LDB (BYTE 4 0) O-ALU) O-CONST O-MASK
		   (LDB (BYTE 4 0) Z-ALU) Z-CONST Z-MASK))
	  (t (VALUES NIL
		     O-ALU O-CONST O-MASK
		     Z-ALU Z-CONST Z-MASK
		     )))))


(DEFCONST *COLOR-XOR-BLINKER* (MAKE-INSTANCE 'COLOR:GENERAL-SC-COLOR-ALU
					     :FILL-DATA #o5252525257
					     :PLANE-MASK -1
					     :ARRAY :DEFAULT
					     :ALU ALU-XOR))



(DEFMETHOD (:DEFAULT-INFERIOR-ALUFS SCREEN-MICROCODED-GRAPHICS-MIXIN) ()
  (VALUES ALU-IOR
	  ALU-ANDCA
	  (IF (= BITS-PER-PIXEL 1)
	      ALU-XOR
	      *COLOR-XOR-BLINKER*)))

;;
;; This method is used to implement :SET-REVERSE-VIDEO-P on multi bit screens.
;; We figure out what colors (ie: fill data and plane mask) correspond to 
;; CHAR-ALUF and ERASE-ALUF, and construct an ALU that will turn each into
;; the other.
;;
(DEFMETHOD (:EXCHANGE-TWO-COLORS-ALUF SCREEN-MICROCODED-GRAPHICS-MIXIN :DEFAULT) (OLD-1 OLD-2)
  (IF (= BITS-PER-PIXEL 1)
      ALU-XOR
      (LET ((COLOR:ALU-PARAMETER-MESSAGE :SC-PARAMETERS))
	(MULTIPLE-VALUE-BIND (NIL OLD-1-MASK NIL OLD-1-DATA OLD-1-ALU)
	    (IF (INSTANCEP OLD-1)
		(SEND OLD-1 COLOR:ALU-PARAMETER-MESSAGE SELF (SEND SELF :SCREEN-ARRAY))
		(VALUES 'IGNORE -1 'IGNORE -1 OLD-1))
	  (MULTIPLE-VALUE-BIND (IGNORE OLD-1-DATA OLD-1-MASK)
	      (COLOR:COMBINE-ALU-AND-DATA  OLD-1-ALU OLD-1-DATA OLD-1-MASK)
	    
	    (MULTIPLE-VALUE-BIND (NIL OLD-2-DATA NIL OLD-2-MASK OLD-2-ALU)
		(IF (INSTANCEP OLD-2)
		    (SEND OLD-2 COLOR:ALU-PARAMETER-MESSAGE SELF (SEND SELF :SCREEN-ARRAY))
		    (VALUES 'IGNORE -1 NIL -1 OLD-2))
	      (MULTIPLE-VALUE-BIND (IGNORE OLD-2-DATA OLD-2-MASK)
		  (COLOR:COMBINE-ALU-AND-DATA  OLD-2-ALU OLD-2-DATA OLD-2-MASK)
		
		(LET* ((FILL (LOGXOR OLD-1-DATA OLD-2-DATA))
		       (MASK (LOGIOR OLD-1-MASK OLD-2-MASK)))
		  (IF (AND (= FILL -1) (= MASK -1))
		      TV:ALU-XOR
		      (MAKE-INSTANCE 'COLOR:GENERAL-SC-COLOR-ALU
				     :ALU TV:ALU-XOR
				     :FILL-DATA FILL
				     :PLANE-MASK MASK
				     :ARRAY :DEFAULT))))))))))

;;; These methods are independent of the number of bits per pixel.

(DEFMETHOD (:%BITBLT SCREEN-MICROCODED-GRAPHICS-MIXIN :DEFAULT)
	   (ALU W H FROM-ARRAY FROM-X FROM-Y TO-ARRAY TO-X TO-Y SHEET)
  (LET ((BITBLT-TYPE (IF (NULL FROM-ARRAY) :BITBLT-FROM :BITBLT)))
    (WITH-SCREEN-DRAWING-ENVIRONMENT (BITBLT-TYPE :COLOR T)
      :%BITBLT)))

(DEFMETHOD (:%POINT SCREEN-MICROCODED-GRAPHICS-MIXIN :DEFAULT) (X Y SHEET)
  (RASTER-AREF (SHEET-SCREEN-ARRAY SHEET) X Y))

(DEFMETHOD (SCREEN-OPEN-ALL-CONFLICTING-BLINKERS SCREEN-MICROCODED-GRAPHICS-MIXIN :DEFAULT)
	   (LEFT TOP RIGHT BOTTOM)
  (LET ((MOUSE (SHEET-MOUSE SELF)))
    ;; Make sure the mouse doesn't track into the prepared sheet.
    (WHEN (AND MOUSE (EQ SELF (MOUSE-SHEET MOUSE)))
      (MOUSE-SET-PREPARED-SHEET MOUSE LEFT TOP RIGHT BOTTOM))))



;;; SINGLE-BIT-SCREEN-MIXIN to LTVDEF

(DEFMETHOD (:WITH-ALU-CACHED SINGLE-BIT-SCREEN-MIXIN) (SHEET ALU MESSAGE &REST ARGS)
  (WITH-SCREEN-DRAWING-ENVIRONMENT (NIL)
    :%WITH-ALU-CACHED))

(DEFMETHOD (:WITH-ALU-CACHED-SOURCE SINGLE-BIT-SCREEN-MIXIN) (SHEET ALU MESSAGE &REST ARGS)
  ;; This one is for when we have a "source" of bits, like DRAW-POINT or BITBLT.
  ;; Basically, don't turn ALU-IOR or -ANDCA into a fill-mode operation.
  ;; don't use :BITBLT as the type of operation, because that interacts with the
  ;; :ARRAY field, so we use :PLAIN
  (WITH-SCREEN-DRAWING-ENVIRONMENT (:PLAIN)
    :%WITH-ALU-CACHED))

(DEFMETHOD (:%DRAW-POINT SINGLE-BIT-SCREEN-MIXIN) (X Y ALU SHEET &OPTIONAL (VALUE BITBLT-UNPACKING-CONSTANT))
  (WITH-SCREEN-DRAWING-ENVIRONMENT (:POINT :VALUE (BITBLT-UNPACKING-CONSTANT VALUE))
    :%DRAW-POINT))

(DEFMETHOD (:%DRAW-RECTANGLE SINGLE-BIT-SCREEN-MIXIN) (W H X Y ALU SHEET &OPTIONAL ARRAY)
  (WITH-SCREEN-DRAWING-ENVIRONMENT
    (NIL
      :ARRAY (ARRAY (OR ARRAY (SHEET-SCREEN-ARRAY SHEET))))
    :%DRAW-RECTANGLE))

(DEFMETHOD (:%DRAW-MULTIPLE-RECTANGLES SINGLE-BIT-SCREEN-MIXIN) (SHEET ALU RECTS &OPTIONAL ARRAY)
  (WITH-SCREEN-DRAWING-ENVIRONMENT
    (NIL
      :ARRAY (ARRAY (OR ARRAY (SHEET-SCREEN-ARRAY SHEET))))
    :%DRAW-MULTIPLE-RECTANGLES))

(DEFMETHOD (:%DRAW-LINE SINGLE-BIT-SCREEN-MIXIN) (X1 Y1 X2 Y2 ALU DRAW-END-POINT SHEET)
  (WITH-SCREEN-DRAWING-ENVIRONMENT (NIL)
    :%DRAW-LINE))

(DEFMETHOD (:%DRAW-MULTIPLE-LINES SINGLE-BIT-SCREEN-MIXIN) (SHEET ALU LINES DRAW-END-POINT)
  (WITH-SCREEN-DRAWING-ENVIRONMENT (NIL)
    :%DRAW-MULTIPLE-LINES))

(DEFMETHOD (:%DRAW-TRIANGLE SINGLE-BIT-SCREEN-MIXIN) (X1 Y1 X2 Y2 X3 Y3 ALU SHEET &REST LIMITS)
  (WITH-SCREEN-DRAWING-ENVIRONMENT (NIL)
    :%DRAW-TRIANGLE))

(DEFMETHOD (:%DRAW-CHAR SINGLE-BIT-SCREEN-MIXIN) (CHAR X Y ALU SHEET)
  (WITH-SCREEN-DRAWING-ENVIRONMENT (:FONT :DRAW-CHAR T)
    :%DRAW-CHAR))

(DEFMETHOD (:%DRAW-GLYPH SINGLE-BIT-SCREEN-MIXIN) (CHAR FONT X Y ALU SHEET &OPTIONAL ARRAY)
  (WITH-SCREEN-DRAWING-ENVIRONMENT (:FONT :ARRAY (ARRAY (OR ARRAY (SHEET-SCREEN-ARRAY SHEET))))
    :%DRAW-CHAR))

;;; NOTE: The FONT argument supplied here must be consistent with the
;;;       font for the first character of the string, since this 
;;;       routine hasn't the necessary context to detect an inconsistency.
(DEFMETHOD (:%DRAW-STRING SINGLE-BIT-SCREEN-MIXIN) (SHEET ALU X Y STRING FONT INDEX LIMIT XLIM)
  (WITH-SCREEN-DRAWING-ENVIRONMENT (:FONT)
    :%DRAW-STRING))

(DEFMETHOD (:%DRAW-1-BIT-RASTER SINGLE-BIT-SCREEN-MIXIN)
	   (W H PATTERN FROM-X FROM-Y ARRAY TO-X TO-Y ONES-ALU ZEROS-ALU SHEET)
  ;;note that for 1 bit screens, it is always possible to transform
  ;;the two alus into one.
  (WITH-SCREEN-DRAWING-ENVIRONMENT
    (:1B-BITBLT :ALU (ALU (COMBINE-1-BIT-ALUS ONES-ALU ZEROS-ALU)) 
		:ARRAY (ARRAY (OR ARRAY (SHEET-SCREEN-ARRAY SHEET))))
    :%DRAW-1-BIT-RASTER))


(DEFMETHOD (:DEFAULT-INFERIOR-ALUFS SINGLE-BIT-SCREEN-MIXIN) ()
  (VALUES ALU-IOR ALU-ANDCA ALU-XOR))

;;
;; This method is used to implement :SET-REVERSE-VIDEO-P on multi bit screens.
;; We figure out what colors (ie: fill data and plane mask) correspond to 
;; CHAR-ALUF and ERASE-ALUF, and construct an ALU that will turn each into
;; the other.
;;
(DEFMETHOD (:EXCHANGE-TWO-COLORS-ALUF SINGLE-BIT-SCREEN-MIXIN) (IGNORE IGNORE)
  ALU-XOR)



;;; MULTI-BIT-SCREEN-MIXIN -> LTVDEF

(DEFMETHOD (:WITH-ALU-CACHED MULTI-BIT-SCREEN-MIXIN)
	   (SHEET ALU MESSAGE &REST ARGS)
  (WITH-SCREEN-DRAWING-ENVIRONMENT (NIL :COLOR T)
    :%WITH-ALU-CACHED)
  )

(DEFMETHOD (:WITH-ALU-CACHED-SOURCE MULTI-BIT-SCREEN-MIXIN)
	   (SHEET ALU MESSAGE &REST ARGS)
  ;; This one is for when we have a "source" of bits, like DRAW-POINT or BITBLT.
  ;; Basically, don't turn ALU-IOR or -ANDCA into a fill-mode operation.
  ;; don't use :BITBLT as the type of operation, because that interacts with the
  ;; :ARRAY field, so we use :PLAIN
  (WITH-SCREEN-DRAWING-ENVIRONMENT (:PLAIN :COLOR T)
    :%WITH-ALU-CACHED))

(DEFMETHOD (:%DRAW-POINT MULTI-BIT-SCREEN-MIXIN)
	   (X Y ALU SHEET &OPTIONAL (VALUE BITBLT-UNPACKING-CONSTANT))
  (WITH-SCREEN-DRAWING-ENVIRONMENT
    (:POINT :COLOR T :VALUE (BITBLT-UNPACKING-CONSTANT VALUE))
    :%DRAW-POINT))

(DEFMETHOD (:%DRAW-LINE MULTI-BIT-SCREEN-MIXIN)
	   (X1 Y1 X2 Y2 ALU DRAW-END-POINT SHEET)
  (WITH-SCREEN-DRAWING-ENVIRONMENT (NIL :COLOR T)
    :%DRAW-LINE))

(DEFMETHOD (:%DRAW-MULTIPLE-LINES MULTI-BIT-SCREEN-MIXIN) (SHEET ALU LINES DRAW-END-POINT)
  (WITH-SCREEN-DRAWING-ENVIRONMENT (NIL :COLOR T)
    :%DRAW-MULTIPLE-LINES))

(DEFMETHOD (:%DRAW-RECTANGLE MULTI-BIT-SCREEN-MIXIN) (W H X Y ALU SHEET &OPTIONAL ARRAY)
  (WITH-SCREEN-DRAWING-ENVIRONMENT
    (NIL :COLOR T
	 :ARRAY (ARRAY (OR ARRAY (SHEET-SCREEN-ARRAY SHEET))))
    :%DRAW-RECTANGLE))

(DEFMETHOD (:%DRAW-MULTIPLE-RECTANGLES MULTI-BIT-SCREEN-MIXIN) (SHEET ALU RECTS &OPTIONAL ARRAY)
  (WITH-SCREEN-DRAWING-ENVIRONMENT
    (NIL :COLOR T
         :ARRAY (ARRAY (OR ARRAY (SHEET-SCREEN-ARRAY SHEET))))
    :%DRAW-MULTIPLE-RECTANGLES))

(DEFMETHOD (:%DRAW-TRIANGLE MULTI-BIT-SCREEN-MIXIN)
	   (X1 Y1 X2 Y2 X3 Y3 ALU SHEET &REST LIMITS)
  (WITH-SCREEN-DRAWING-ENVIRONMENT (NIL :COLOR T )
    :%DRAW-TRIANGLE))

(DEFMETHOD (:%DRAW-CHAR MULTI-BIT-SCREEN-MIXIN) (CHAR X Y ALU SHEET)
  (WITH-SCREEN-DRAWING-ENVIRONMENT (:FONT :COLOR T :DRAW-CHAR T)
    :%DRAW-CHAR))

(DEFMETHOD (:%DRAW-GLYPH MULTI-BIT-SCREEN-MIXIN) (CHAR FONT X Y ALU SHEET &OPTIONAL ARRAY)
  (WITH-SCREEN-DRAWING-ENVIRONMENT (:FONT :COLOR T
					  :ARRAY (ARRAY (OR ARRAY (SHEET-SCREEN-ARRAY SHEET))))
    :%DRAW-CHAR))

(DEFMETHOD (:%DRAW-STRING MULTI-BIT-SCREEN-MIXIN)
	   (SHEET ALU X Y STRING FONT INDEX LIMIT XLIM)
  (WITH-SCREEN-DRAWING-ENVIRONMENT (:FONT :COLOR T)
    :%DRAW-STRING))

(DEFMETHOD (:%DRAW-1-BIT-RASTER MULTI-BIT-SCREEN-MIXIN)
	   (W H PATTERN FROM-X FROM-Y ARRAY TO-X TO-Y ONES-ALU ZEROS-ALU SHEET)
  (DRAW-COLOR-1-BIT-RASTER WITH-LISPM-DRAWING-ENVIRONMENT))

(DEFMETHOD (:DEFAULT-INFERIOR-ALUFS MULTI-BIT-SCREEN-MIXIN) ()
  (VALUES ALU-IOR ALU-ANDCA *COLOR-XOR-BLINKER*))

;;
;; This method is used to implement :SET-REVERSE-VIDEO-P on multi bit screens.
;; We figure out what colors (ie: fill data and plane mask) correspond to 
;; CHAR-ALUF and ERASE-ALUF, and construct an ALU that will turn each into
;; the other.
;;
(DEFMETHOD (:EXCHANGE-TWO-COLORS-ALUF MULTI-BIT-SCREEN-MIXIN) (OLD-1 OLD-2)
  (MULTIPLE-VALUE-BIND (NIL OLD-1-MASK NIL OLD-1-DATA OLD-1-ALU)
      (IF (INSTANCEP OLD-1)
	  (SEND OLD-1 COLOR:ALU-PARAMETER-MESSAGE SELF (SEND SELF :SCREEN-ARRAY))
	  (VALUES 'IGNORE -1 'IGNORE -1 OLD-1))
    (MULTIPLE-VALUE-BIND (IGNORE OLD-1-DATA OLD-1-MASK)
	(COLOR:COMBINE-ALU-AND-DATA  OLD-1-ALU OLD-1-DATA OLD-1-MASK)

      (MULTIPLE-VALUE-BIND (NIL OLD-2-DATA NIL OLD-2-MASK OLD-2-ALU)
	  (IF (INSTANCEP OLD-2)
	      (SEND OLD-2 COLOR:ALU-PARAMETER-MESSAGE SELF (SEND SELF :SCREEN-ARRAY))
	      (VALUES 'IGNORE -1 NIL -1 OLD-2))
	(MULTIPLE-VALUE-BIND (IGNORE OLD-2-DATA OLD-2-MASK)
	    (COLOR:COMBINE-ALU-AND-DATA  OLD-2-ALU OLD-2-DATA OLD-2-MASK)

	  (LET* ((FILL (LOGXOR OLD-1-DATA OLD-2-DATA))
		 (MASK (LOGIOR OLD-1-MASK OLD-2-MASK)))
	    (IF (AND (= FILL -1) (= MASK -1))
		TV:ALU-XOR
		(MAKE-INSTANCE 'COLOR:GENERAL-SC-COLOR-ALU
			       :ALU TV:ALU-XOR
			       :FILL-DATA FILL
			       :PLANE-MASK MASK
			       :ARRAY :DEFAULT))))))))

1#||

(3 0 (NIL 0) (NIL :BOLD :LARGE) "MEDFNTB")READ-1-BIT-RASTER

1this code implements the method :READ-1-BIT-RASTER for sheets,  the underlying
screen method :%READ-1-BIT-RASTER, and the primitive function %READ-1-BIT-RASTER

READ-1-BIT-RASTER is the inverse of %DRAW-1-BIT-RASTER; it copies from a multi bit
source to a single bit destination.  The method used to convert the multi-bit source
is determined by the READ-PIXEL-FUNCTION argument.   READ-PIXEL-FUNCTION specifies
a function of one variable, a pixel value, and returns one or zero.   For speed,
READ-PIXEL-FUNCTION is compiled into a tight loop.

||#

0(DEFVAR *READ-PIXEL-FUNCTIONS* (CL:MAKE-HASH-TABLE :TEST #'EQUAL))
(DEFVAR *BITBLT-READ-PIXEL-FUNCTIONS* (CL:MAKE-HASH-TABLE :TEST #'EQUAL))

(DEFUN READ-PIXEL-FUNCTION (KEY &OPTIONAL (LAMBDA-EXP KEY))
  1;find the function for KEY, or create one.  If we create one,
0  1;LAMBDA-EXP is compiled in a the conversion function.  LAMBDA-EXP
0  1;can be a lambda expression or the name of a function or a subst.
0  1;
0  (OR (GETHASH KEY *READ-PIXEL-FUNCTIONS*)
      (LET* ((FUN `(LAMBDA (W H FROM FX FY TO TX TY)
		     (WITH-PREPARED-SHEET-OR-RASTER (FROM :ARRAY FROM-ARRAY :SPAN FROM-SPAN
							  :ARRAY-ONLY T)
		       (WITH-PREPARED-SHEET-OR-RASTER (TO :ARRAY TO-ARRAY :SPAN TO-SPAN
							  :ARRAY-ONLY T)
			 (LOOP WITH LAST-Y = (+ FY H)
			       FOR FIRST-Y FROM FY BELOW LAST-Y
			       AS FROM-X FIRST (+ (* FY FROM-SPAN) FX)
					 THEN (+ FROM-X FROM-SPAN)
			       AS TO-X FIRST (+ (* TY TO-SPAN) TX)
				       THEN (+ TO-X TO-SPAN)
			       AS LAST-X = (+ FROM-X W)
			       DO
			   (LOOP FOR FIRST-X FROM FROM-X BELOW LAST-X
				 AS DEST-X FROM TO-X
				 DO
			     (SETF (AREF TO-ARRAY DEST-X)
				   (,LAMBDA-EXP  (AREF FROM-ARRAY FIRST-X)))
			     ))))))
	     (COMPILED (COMPILE (MAKE-SYMBOL (STRING KEY)) FUN)))
	(PUTHASH KEY COMPILED *READ-PIXEL-FUNCTIONS*)
	COMPILED
	)))

(PUTHASH :NONZERO COLOR:ALU-X *BITBLT-READ-PIXEL-FUNCTIONS*)
(PUTHASH :ZERO COLOR:ALU-~X *BITBLT-READ-PIXEL-FUNCTIONS*)
(READ-PIXEL-FUNCTION :NONZERO '(LAMBDA (A) (IF (= A 0) 0 1)))
(READ-PIXEL-FUNCTION :ZERO '(LAMBDA (A) (IF (= A 0) 0 1)))


(DEFUN %READ-1-BIT-RASTER (W H FROM-RASTER FX FY TO-RASTER TX TY
			   &OPTIONAL (READ-PIXEL-FUNCTION :NONZERO))
  1;call either BITBLT or the appropriate copy function
0  (LET ((BITBLT-ALU (WHEN (= (SI:ARRAY-ELEMENT-BYTE-SIZE FROM-RASTER) 1)
		      (GETHASH READ-PIXEL-FUNCTION *BITBLT-READ-PIXEL-FUNCTIONS*))))

    (IF BITBLT-ALU
	(BITBLT BITBLT-ALU W H FROM-RASTER FX FY TO-RASTER TX TY)

	(LET ((FUN (READ-PIXEL-FUNCTION READ-PIXEL-FUNCTION)))
	  (FUNCALL FUN W H FROM-RASTER FX FY TO-RASTER TX TY)))))

(DEFMETHOD (:%READ-1-BIT-RASTER SCREEN-MICROCODED-GRAPHICS-MIXIN)
	   (W H FROM-RASTER FROM-X FROM-Y ARRAY TO-X TO-Y SHEET &REST ARGS)

  ;;note that for 1 bit screens, it is always possible to transform
  ;;the two alus into one.
  (if from-raster
      (LEXPR-FUNCALL #'%READ-1-BIT-RASTER W H
		     FROM-RASTER FROM-X FROM-Y
		     ARRAY TO-X TO-Y ARGS)      
      (with-bit-array
	sheet :input
	#'(lambda (raster index span)
	    (multiple-value-bind (dy dx) (floor index span)
	      (LEXPR-FUNCALL #'%READ-1-BIT-RASTER W H
			     RASTER DX DY
			     ARRAY TO-X TO-Y ARGS))
	    )
	:width w
	:height h
	:x-offset from-x
	:y-offset from-y
	)))



#+imach (PROGN

(DEFFLAVOR VME-DIRECT-GRAPHICS-MIXIN
	(BUS-WINDOW-ADDRESS SHUFFLE)
	(SCREEN-MICROCODED-GRAPHICS-MIXIN))

(DEFMETHOD (WHO-LINE-RUN-LIGHT-LOC VME-DIRECT-GRAPHICS-MIXIN) ()
  (AND (CL:TYPEP BUFFER 'CL:FIXNUM)
       (LET ((RUN-Y (SEND (GET-WHO-LINE-FIELD :RUN-LINE SELF) :Y-OFFSET)))
	 (AND RUN-Y
	      (%32-BIT-PLUS BUFFER
			    (SYS:%FIXNUM-MULTIPLY
			      (ROUND (* BITS-PER-PIXEL
					(+ (SEND (GET-WHO-LINE-FIELD :RUN-STATE SELF)
						 :X-OFFSET)
					   (* WIDTH (+ Y-OFFSET RUN-Y 1))))
				     32.)
			      4))))))

(DEFMETHOD (SCREEN-PERMIT-FAST-TRACKING-P VME-DIRECT-GRAPHICS-MIXIN) () NIL)

;;;

(DEFMACRO-IN-FLAVOR (WITH-BUS-ADDRESS VME-DIRECT-GRAPHICS-MIXIN) ((DISPLACED-TO) &BODY BODY)
  `(SYS:WITH-BUS-MODE ()
     (CL:TYPECASE ,DISPLACED-TO
       (CL:FIXNUM
	 (SETF BUS-WINDOW-ADDRESS (DPB 0 (BYTE 2 0) ,DISPLACED-TO))
	 (SETF SHUFFLE (AREF '#.(LISP:VECTOR :NONE :BYTE :NIBBLE :BIT)
			     (LDB (BYTE 2 0) ,DISPLACED-TO)))
	 (SETF ,DISPLACED-TO (SYS:MAKE-BUS-ADDRESS BUS-WINDOW-ADDRESS 1_21 :SHUFFLE SHUFFLE))))
     ,@BODY))

(DEFWHOPPER (:CREATE-SCREEN-ARRAY VME-DIRECT-GRAPHICS-MIXIN) (W H DISPLACED-TO)
  (WITH-BUS-ADDRESS (DISPLACED-TO)
    (CONTINUE-WHOPPER W H DISPLACED-TO)))

(DEFWHOPPER (:ADJUST-SCREEN-ARRAY VME-DIRECT-GRAPHICS-MIXIN)
	    (ARRAY NEW-POINTER &REST OPTIONALS)
  (WITH-BUS-ADDRESS (NEW-POINTER)
    (LEXPR-CONTINUE-WHOPPER ARRAY NEW-POINTER OPTIONALS)))

;;;

(DEFMACRO-IN-FLAVOR (WITH-VME-DIRECT-GRAPHICS VME-DIRECT-GRAPHICS-MIXIN) (&BODY BODY)
  `(SYS:WITH-BUS-MODE ()
     (SYS:MAKE-BUS-ADDRESS BUS-WINDOW-ADDRESS 1_21 :SHUFFLE SHUFFLE)
     ,@BODY))

(DEFWHOPPER (:%BITBLT VME-DIRECT-GRAPHICS-MIXIN)
	    (ALU W H FROM-ARRAY FROM-X FROM-Y TO-ARRAY TO-X TO-Y SHEET)
  (WITH-VME-DIRECT-GRAPHICS
    (CONTINUE-WHOPPER ALU W H FROM-ARRAY FROM-X FROM-Y TO-ARRAY TO-X TO-Y SHEET)))

(DEFWHOPPER (:%POINT VME-DIRECT-GRAPHICS-MIXIN) (X Y SHEET)
  (WITH-VME-DIRECT-GRAPHICS
    (CONTINUE-WHOPPER X Y SHEET)))

(DEFWHOPPER (:%READ-1-BIT-RASTER VME-DIRECT-GRAPHICS-MIXIN)
	   (W H FROM-RASTER FROM-X FROM-Y ARRAY TO-X TO-Y SHEET &REST ARGS)
  (WITH-VME-DIRECT-GRAPHICS
    (LEXPR-CONTINUE-WHOPPER W H FROM-RASTER FROM-X FROM-Y ARRAY TO-X TO-Y SHEET ARGS)))

(DEFWHOPPER (%WITH-BIT-ARRAY-STREAM VME-DIRECT-GRAPHICS-MIXIN)
	    (SHEET &REST ARGS)
  (WITH-VME-DIRECT-GRAPHICS
    (LEXPR-CONTINUE-WHOPPER SHEET ARGS)))

(DEFWHOPPER (%WITH-BIT-ARRAY VME-DIRECT-GRAPHICS-MIXIN)
	    (SHEET DIRECTION CONTINUATION &REST ARGS)
  (WITH-VME-DIRECT-GRAPHICS
    (LEXPR-CONTINUE-WHOPPER SHEET DIRECTION CONTINUATION ARGS)))

(DEFWHOPPER (:WITH-ALU-CACHED VME-DIRECT-GRAPHICS-MIXIN)
	    (SHEET ALU MESSAGE &REST ARGS)
  (WITH-VME-DIRECT-GRAPHICS
    (LEXPR-CONTINUE-WHOPPER SHEET ALU MESSAGE ARGS)))

(DEFWHOPPER (:WITH-ALU-CACHED-SOURCE VME-DIRECT-GRAPHICS-MIXIN)
	    (SHEET ALU MESSAGE &REST ARGS)
  (WITH-VME-DIRECT-GRAPHICS
    (LEXPR-CONTINUE-WHOPPER SHEET ALU MESSAGE ARGS)))

(DEFWHOPPER (:%DRAW-POINT VME-DIRECT-GRAPHICS-MIXIN)
	    (X Y ALU SHEET &OPTIONAL (VALUE BITBLT-UNPACKING-CONSTANT))
  (WITH-VME-DIRECT-GRAPHICS
    (CONTINUE-WHOPPER X Y ALU SHEET VALUE)))

(DEFWHOPPER (:%DRAW-LINE VME-DIRECT-GRAPHICS-MIXIN)
	    (X1 Y1 X2 Y2 ALU DRAW-END-POINT SHEET)
  (WITH-VME-DIRECT-GRAPHICS
    (CONTINUE-WHOPPER X1 Y1 X2 Y2 ALU DRAW-END-POINT SHEET)))

(DEFWHOPPER (:%DRAW-RECTANGLE VME-DIRECT-GRAPHICS-MIXIN) (W H X Y ALU SHEET &OPTIONAL ARRAY)
  (WITH-VME-DIRECT-GRAPHICS
    (CONTINUE-WHOPPER W H X Y ALU SHEET ARRAY)))

(DEFWHOPPER (:%DRAW-TRIANGLE VME-DIRECT-GRAPHICS-MIXIN)
	    (X1 Y1 X2 Y2 X3 Y3 ALU SHEET &REST LIMITS)
  (WITH-VME-DIRECT-GRAPHICS
    (LEXPR-CONTINUE-WHOPPER X1 Y1 X2 Y2 X3 Y3 ALU SHEET LIMITS)))

(DEFWHOPPER (:%DRAW-CHAR VME-DIRECT-GRAPHICS-MIXIN) (CHAR X Y ALU SHEET)
  (WITH-VME-DIRECT-GRAPHICS
    (CONTINUE-WHOPPER CHAR X Y ALU SHEET)))

(DEFWHOPPER (:%DRAW-GLYPH VME-DIRECT-GRAPHICS-MIXIN) (CHAR FONT X Y ALU SHEET &OPTIONAL ARRAY)
  (WITH-VME-DIRECT-GRAPHICS
    (CONTINUE-WHOPPER CHAR FONT X Y ALU SHEET ARRAY)))

(DEFWHOPPER (:%DRAW-STRING VME-DIRECT-GRAPHICS-MIXIN)
	    (SHEET ALU X Y STRING FONT INDEX LIMIT XLIM)
  (WITH-VME-DIRECT-GRAPHICS
    (CONTINUE-WHOPPER SHEET ALU X Y STRING FONT INDEX LIMIT XLIM)))

(DEFWHOPPER (:%DRAW-1-BIT-RASTER VME-DIRECT-GRAPHICS-MIXIN)
	    (W H PATTERN FROM-X FROM-Y ARRAY TO-X TO-Y ONES-ALU ZEROS-ALU SHEET)
  (WITH-VME-DIRECT-GRAPHICS
    (CONTINUE-WHOPPER W H PATTERN FROM-X FROM-Y ARRAY TO-X TO-Y ONES-ALU ZEROS-ALU SHEET)))

)
