;;; -*- Mode: LISP; Base: 8; Package: TV; Lowercase: Yes -*-
;;;
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

#|

The idea here is that mouse-sensitive-items are objects.  They get to decide:
 if the mouse is over them                      (:minimum-distance-to-boundary)
 if they are sensitive                          (:sensitivep)
 what is the item being pointed to              (:mouse-sensitive-item
                                                 :mouse-sensitive-inferior)
 what to do when they are moved over            (:mouse-moves)
 what to do when they are clicked on            (:mouse-click)
 because of above, what who-line-string to show (:who-line-documentatation-string)
 how to highlight themselves                    (complicated...)

A mouse sensitive-item is an object.  It must have basic-sensitive-item,
in addition it must provide the geometry method :minimum-distance-to-boundary.
In addition most interesting sensitive items will want to be able to
highlight themselves so they will want basic-highlighting-mixin and methods
to actually do their highlighting.

The window that your objects go on will want essential-window-with-sensitive-items.

It is possible for objects that are not windows to have inferior-sensitive-items.
to do so they should have superior-sensitive-item-mixin.  If they want to have
hierarchical highlighting they should have superior-highlighting-mixin.

There are some predefined geometries.. they are not yet finished.

:sensitivep -> (reason distance)
:mouse-sensitive-item - > (item reason distance)

The notion of a hierarchy of sensitive items is abstracted out.

The structure the items are stored in is abstracted out.
:map-over-sensitive-items

There is a hairy highlighting scheme that lets different levels of the
hierarchy decide to highlight themselves independently but still makes
the highlighting look good.  (Does not allow different levels to have
different visibilities).

|#

(defflavor basic-sensitive-item
	((superior-sensitive-item 'ignore)	    ;Our superior sensitive item. If we have
						    ;one. When we have no superior sensitive
						    ;item this is the symbol IGNORE (instead
						    ;of NIL).
	 (sensitivity ':inside))		    ;:INSIDE  sensitive for points inside of
						    ;         our boundary.
						    ;:NEAR    sensitive for points both near
						    ;         and inside our boundary. This
						    ;         really says sensitive for any
						    ;         point our superior gives us a
						    ;         chance to be sensitive at.
						    ;NIL      not sensitive for any points.
	()
  :gettable-instance-variables
  (:init-keywords :superior-sensitive-item :sensitivity)
  (:default-init-plist :sensitivity ':inside)
  (:required-methods ;; :MINIMUM-DISTANCE-TO-BOUNDARY is the interface between the 
                     ;; specific geometry of the item and the basic-sensitive-item
                     ;; flavor. The arguments (test-x test-y) are a test point in
                     ;; the coordinate system of the item's superior. The returned
                     ;; value should be the minimum distance from the test point to
                     ;; the boundary of the item. If the test point is inside the
                     ;; boundary, the returned value should be negative.
                     ;; NOTE:    Keep in mind that this message is sent a lot
		     ;;          (as often as once to each item in a window per
                     ;;          mouse move).  So, it is worth trying to use
                     ;;           fixnums and it is worth trying to be fast.
                     :minimum-distance-to-boundary))

;;; Whenever a sensitive-item modifies one of its attributes which is relevant to its
;;; being a sensitive item it is supposed to send itself a :MODIFIED message with that
;;; attribute's keyword and its previous value as arguments. Abiding by this contract
;;; is facilitated by the SENSITIVE-ITEM-MODIFY-ATTRIBUTES macro. As an example of the
;;; use of this macro, a particular flavor of sensitive item might implement it's :set-x
;;; method as follows:
;;;   (DEFMETHOD (MY-SENSITIVE-ITEM :SET-X) (NEW-X-POSITION)
;;;     (SENSITIVE-ITEM-MODIFY-ATTRIBUTES (:X X-POSITION NEW-X-POSITION))
;;;
;;; These are the established attribute keywords:
;;;   :X                      - The x-coordinate of the items position in its superior.
;;;   :Y                      - The y-coordinate of the items position in its superior.
;;;   :WIDTH                  - The width of the space over which the item is sensitive.
;;;   :HEIGHT                 - The height of the space over which the item is sensitive.
;;;   :INFERIORS              - The items inferior sensitive items.
;;;   :SENSITIVITY            - The sensitivity of the item.
;;;   :INFERIORS-SENSITIVITY  - The sensitivity of an item with inferior sensitive
;;;                             items inferior sensitive items.
;;;   (specific applications may wish to add their own, that is permissible)
;;;
;;; NOTE: This hair may well be gratuitous, but it is possible to imagine wanting to
;;;       put daemons on the :modified or :inferior-sensitive-item-modified messages
;;;       and those daemons wanting information about what attributes of the item had
;;;       changed and what the previous values of those attributes were.

(defmacro sensitive-item-modify-attributes attributes
  (declare (arglist (keyword accessor new-value) . others))
  `(send self :modified
     . ,(loop for (key access . new-value) in attributes
	      append `(,key (prog1 ,access
				   ,(when new-value `(setf ,access ,(car new-value))))))))


(defmethod (:init basic-sensitive-item :before) (init-plist)
  (send self :set-superior-sensitive-item (get init-plist ':superior-sensitive-item))
  (send self :set-sensitivity (get init-plist ':sensitivity)))


(defmethod (:set-superior-sensitive-item basic-sensitive-item) (new-value)
  (sensitive-item-modify-attributes
    (:superior-sensitive-item superior-sensitive-item (or new-value 'ignore))))

(defmethod (:set-sensitivity basic-sensitive-item) (new-value)
  (check-arg new-value (memq new-value '(:inside :near nil)) "One of :INSIDE :NEAR or NIL.")
  (sensitive-item-modify-attributes
    (:sensitivity sensitivity new-value)))


(defmethod (:sensitivep basic-sensitive-item) (test-x test-y)
  (declare (values reason distance))
  (let ((distance (send self :minimum-distance-to-boundary test-x test-y)))
    (cond ((null sensitivity)     (values nil      distance))
	  ((minusp distance)      (values ':inside distance))
	  ((eq sensitivity :near) (values ':near   distance))
	  (t                      (values nil      distance)))))

(defmethod (:mouse-sensitive-item basic-sensitive-item) (test-x test-y)
  (declare (values item reason distance))
  (multiple-value-bind (reason distance)
      (send self :sensitivep test-x test-y)
    (if reason (values self reason distance))))

(defmethod (:more-sensitive-than basic-sensitive-item)
	   (other-item other-reason other-distance test-x test-y)
  (declare (values item reason distance))
  (multiple-value-bind (reason distance)
      (send self :sensitivep test-x test-y)
    (if (or (not other-reason)
	    (and (eq reason ':inside) (neq other-reason ':inside))
	    ;; There might be several items which have the same distance from
	    ;; the mouse -- take the first one of these.  Note that the distance
	    ;; can be negative (meaning "inside"), so we need to use the absolute
	    ;; value.  The effect of this is that the innermost sensitive item
	    ;; is preferred to an outer one, should the items be nested.
	    ( (abs distance) (abs other-distance)))
	(values self reason distance)
	(values other-item other-reason other-distance))))

(defmethod (:modified basic-sensitive-item) (&rest modified-plist)
  (delaying-mouse-wakeups 
    (send superior-sensitive-item :inferior-mouse-sensitive-item-modified modified-plist self)
    (mouse-wakeup)))

;args are (window buttons click-x click-y)
;but we don't declare them because that screws up the :mouse-click generic function's
;heuristicated arguments, which we would rather were for the window protocol
;rather than the sensitive-item protocol.
(defmethod (:mouse-click basic-sensitive-item :default) (&rest ignore)
  nil)

;args are (window moves-x moves-y)
;but we don't declare them because that screws up the :mouse-moves generic function's
;heuristicated arguments, which we would rather were for the window protocol
;rather than the sensitive-item protocol.
(defmethod (:mouse-moves basic-sensitive-item :default) (&rest ignore)
  nil)

;arg is window
(defmethod (:who-line-documentation-string basic-sensitive-item :default) (ignore)
  nil)

(defflavor superior-sensitive-item-mixin
	((inferiors-sensitivity ':inside))	    ;:INSIDE inferiors get a chance to be
						    ;        sensitive when the mouse is
						    ;        inside of us.
						    ;:NEAR   inferiors get a chance to be
						    ;        sensitive when the mouse is
						    ;        near us.
						    ;NIL     inferiors never get a chance
						    ;        to be sensitive.
	(basic-sensitive-item)
  (:required-methods ;; :MAP-OVER-SENSITIVE-ITEMS interfaces superior-sensitive-item-mixin
		     ;; to the structure the inferior items are stored in.  The arguments
		     ;; are (function test-x test-y).  This method should call function on
		     ;; each of the inferiors sensitive-items.  When the second and third
		     ;; arguments are non-null the caller is only trying to find the item
		     ;; closest to the test point (test-x, test-y).  In this case, the
		     ;; method is allowed to skip as many of the inferiors as it wants as
		     ;; long as it gets the one closest to the test point.
		     :map-over-sensitive-items))

(defmethod (:set-inferiors-sensitivity superior-sensitive-item-mixin) (new-value)
  (sensitive-item-modify-attributes
    (:inferiors-sensitivity inferiors-sensitivity new-value)))

(defwrapper (:mouse-sensitive-item superior-sensitive-item-mixin) ((test-x test-y) . body)
  `(multiple-value-bind (item reason distance)
       (progn . ,body)
     (multiple-value-bind (other-item other-reason other-distance)
	 (send self :mouse-sensitive-inferior test-x test-y)       
       (cond ((null item) (values other-item other-reason other-distance))
	     ((null other-item) (values item reason distance))
	     (t
	      (send item :more-sensitive-than other-item other-reason other-distance
					      test-x test-y))))))

(defmethod (:mouse-sensitive-inferior superior-sensitive-item-mixin) (test-x test-y)
  (declare (values item reason distance))
  (let ((our-reason (send self :sensitivep test-x test-y)))
    (when (and (not (null inferiors-sensitivity))
	       (not (null our-reason))
	       (or (eq our-reason ':inside) (eq inferiors-sensitivity ':near)))
      (let-special ((.test-x. test-x) (.test-y. test-y) .inf. .reas. .dist.)
	(send self :map-over-sensitive-items
	  #'(lambda (inferior)
	      (multiple-value-bind (item reason distance)
		  (send inferior :mouse-sensitive-item .test-x. .test-y.)
		(when reason
		  (if (null .inf.)
		      (setq .inf. item .reas. reason .dist. distance)
		      (multiple-value (.inf. .reas. .dist.)
			(send .inf. :more-sensitive-than item reason distance
							 .test-x. .test-y.))))))
	  test-x
	  test-y)
	(values .inf. .reas. .dist.)))))

(defmethod (:inferior-mouse-sensitive-item-modified superior-sensitive-item-mixin)
	   (plist &rest path-to-modified-item)
  (lexpr-send superior-sensitive-item :inferior-mouse-sensitive-item-modified
				      plist
				      self path-to-modified-item))


;;; HIGHLIGHTERS are blinkers that can blink lots of virtual blinkers (or highlights).
;;; Each virtual blinker (or highlight) is a 5-tuple:
;;; 
;;;     (<object>, <blink-message>, <size-message>, <x-offset>, <y-offset>)
;;;
;;; To blink a highlight the highlighter sends <object> <blink-message> with arguments
;;; <x-offset> and <y-offset>.
;;;
;;; The highlights a highlighter is currently highlighting are divided into two categories,
;;; and the highlighter is asked to highlight them in a different way for each category.
;;;
;;;   Dynamic highlights
;;;     A collecting-highlights pass (collecting highlights are allowed to be nested,
;;;     outermost one demarks the pass).
;;;     :collect-highlight 
;;;
;;;   Static Highlights
;;;     :ADD-HIGHLIGHT
;;;     :REMOVE-HIGHLIGHT

(defflavor basic-highlighter
	(object-array			;There is a set of five arrays corresponding
	 blink-message-array		;to the five elements of a highlight.  See
	 size-message-array		;highlighter-munge-arrays.
	 x-offset-array
	 y-offset-array
	 (dynamic-entries 0)
	 (static-entries 0))
	(blinker))

;;; A little macrology to make it easier to do the same (or even nearly the same) thing to
;;; all of the highlighter's arrays. The easiest way to show how this works is to show an
;;; example of how it expands:
;;;
;;; (HIGHLIGHTER-MUNGE-ARRAYS (SETF (AREF .ARRAY. I) .ARG.)
;;;   (OBJECT) (BLINK) (SIZE) (X-OFF) (Y-OFF))
;;;
;;; (PROGN 'COMPILE
;;;        (SETF (AREF OBJECT-ARRAY I) OBJECT)
;;;        (SETF (AREF BLINK-MESSAGE-ARRAY I) BLINK)
;;;        (SETF (AREF SIZE-MESSAGE-ARRAY I) SIZE)
;;;        (SETF (AREF X-OFFSET-ARRAY I) X-OFF)
;;;        (SETF (AREF Y-OFFSET-ARRAY I) Y-OFF))
;;;
(defmacro highlighter-munge-arrays (template &rest args-to-template)
  `(progn 'compile
     . ,(loop for array-symbol in '(object-array blink-message-array size-message-array
						 x-offset-array y-offset-array)
	      for args = (pop args-to-template)
	      for copy = (copytree template)
	      do (nsubst array-symbol '.array. copy)
	         (highlighter-munge-arrays-1 copy args)
	      collect copy)))

(eval-when (compile load eval)
(defun highlighter-munge-arrays-1 (template args)
  (unless (null args)
    (loop for sublist on template
	   do (cond ((listp (car sublist))
		     (setq args (highlighter-munge-arrays-1 (car sublist) args)))
		    ((eq (car sublist) '.arg.)
		     (rplaca sublist (pop args))))
	  finally (return args)))))

(defmacro highlighter-blink-entry (entry)
  `(send (aref object-array ,entry) (aref blink-message-array ,entry) sheet
	 (aref x-offset-array ,entry) (aref y-offset-array ,entry)))

(defmacro highlighter-entry-equals ((entry) obj blinkm sizem xoff yoff &environment env)
  (declare (zwei:indentation 1 1))
  (once-only (entry &environment env)
    `(and (eq (aref object-array ,entry)        ,obj)
	  (eq (aref blink-message-array ,entry) ,blinkm)
	  (eq (aref size-message-array ,entry)  ,sizem)
	  (= (aref x-offset-array ,entry)       ,xoff)
	  (= (aref y-offset-array ,entry)       ,yoff))))

(defmethod (:init basic-highlighter :before) (ignore)
  (highlighter-munge-arrays (setq .array. (make-array 20. :leader-list '(0)))))

(defmethod (:blink basic-highlighter) ()
  ;; BLINKing blinks all the entries, static and dynamic.
  (dotimes (entry (+ static-entries dynamic-entries))
    (highlighter-blink-entry entry)))

(defmethod (:size basic-highlighter) ()
  (let ((width 0) (height 0))
    (dotimes (entry (+ static-entries dynamic-entries))
      (multiple-value-bind (object-width object-height)
	  (send (aref object-array entry) (aref size-message-array entry))
	(setq width (max width (+ (aref x-offset-array entry) object-width)))
	(setq height (max height (+ (aref y-offset-array entry) object-height)))))
    (values width height)))

(defmacro collecting-highlights (highlighter &body body &environment env)
  (once-only (highlighter &environment env)
    `(prog1 (let ((.collecting-highlights. ,highlighter))
	      (declare (special .collecting-highlights.))
	      ,@body)
	    ;; If we are the outermost collecting-highlights then do a
	    ;; :finish-collecting-highlights. This lets code have nested
	    ;; collecting highlights when it doesn't mean to which makes
	    ;; life better.
	    (cl:locally
	      (declare (special .collecting-highlights.))
	      (unless (and (variable-boundp .collecting-highlights.)
			   (eq .collecting-highlights. ,highlighter))
		(send ,highlighter :finish-collecting-highlights))))))

(defmethod (:collect-highlight basic-highlighter) (object blink-message size-message
						   &optional (x-off 0)
							     (y-off 0))
  (without-interrupts
    (highlighter-munge-arrays (array-push-extend .array. .arg.)
      (object) (blink-message) (size-message) (x-off) (y-off))))

;;; Messages to add and remove static entries.  These are what you use from outside
;;; of the mouse-moves highlighting code.  (When not inside a collecting-highlights).
(defmethod (:add-highlight basic-highlighter)
	   (object &optional (blink-message (send object :highlight-blink-message))
			     (size-message (send object :highlight-size-message))
			     (x-off 0)
			     (y-off 0))
  (with-blinker-prepared (self :open nil)
    (sheet-is-prepared (sheet)
      (let* ((active-length (fill-pointer object-array))
	     (size-needed (+ active-length 1)))
	(highlighter-munge-arrays (si:assure-array-size .array. size-needed))
	;; Check for duplication.  If there is a static entry that duplicates
	;; the new entry, quit.  If there is a dynamic entry that duplicates
	;; the new entry flush the dynamic entry.
	(when (loop for entry from 0 below (+ static-entries dynamic-entries)
		     do (when (highlighter-entry-equals (entry)
				object blink-message size-message x-off y-off)
			  (if (< entry dynamic-entries)
			      nil
			      (when phase (highlighter-blink-entry entry))
			      (setf (aref object-array entry) nil)
			      t)))
	  ;; Now slide the dynamic entries (plus any entries that could be
	  ;; being collected) up to make room for the new static entry.
	  (loop for entry from active-length above static-entries
		 do (highlighter-munge-arrays (setf (aref .array. entry)
						    (aref .array. (- entry 1)))))
	  (highlighter-munge-arrays (progn (setf (aref .array. static-entries) .arg.)
					   (incf (fill-pointer .array.)))
	    (object) (blink-message) (size-message) (x-off) (y-off))
	  (incf static-entries)
	  (when phase (send object blink-message sheet x-off y-off)))))))

(defmethod (:finish-collecting-highlights basic-highlighter) ()
  (with-blinker-prepared (self :open nil)
    (highlighter-munge-arrays (setq .array. (follow-structure-forwarding .array.)))
    (let* ((active-length (array-active-length object-array))
	   (all-old-entries (+ static-entries dynamic-entries))	   
	   (new-dynamic-entries (- active-length all-old-entries)))
      ;; Loop through all the entries checking for duplication between static entries
      ;; and new dynamic entries.  Don't have to check for duplication between static
      ;; entries and old dynamic entries since the code that adds new static entries
      ;; has to do that.  Between the new and old dynamic entries we turn off those
      ;; that don't exist any more and turn on new ones.   Done this way rather than
      ;; blinking all the entries to make things look "smoother".
      (loop for entry from static-entries below active-length
	    for oobj = (aref object-array entry)
	    for omsg = (aref blink-message-array entry)
	    for osiz = (aref size-message-array entry)
	    for xoff = (aref x-offset-array entry)
	    for yoff = (aref y-offset-array entry)
	    for second-half-p = ( entry all-old-entries)
	    when oobj
	      do (unless (loop repeat (if second-half-p all-old-entries new-dynamic-entries)
			          for i from (if second-half-p 0 all-old-entries)
			      thereis (when
					(highlighter-entry-equals (i)oobj omsg osiz xoff yoff)
					(when (< i static-entries)
					  (setf (aref object-array entry) nil))
					t))
		   (when phase
		     (sheet-is-prepared (sheet) (send oobj omsg sheet xoff yoff)))))
      ;; Copy the new dynamic entries into old dynamic entry space, skipping the ones
      ;; that were set to NIL by the above loop, then update the fill pointers etc.
      (loop repeat new-dynamic-entries
	      with i = static-entries
	       for j from all-old-entries
	        do (when (aref object-array j)
		     (highlighter-munge-arrays (setf (aref .array. i) (aref .array. j)))
		     (incf i))
	   finally (setq dynamic-entries (- i static-entries)))
      (highlighter-munge-arrays (setf (fill-pointer .array.)
				      (+ static-entries dynamic-entries))))))

(defmethod (:remove-highlight basic-highlighter)
	   (object &optional (blink-message (send object :highlight-blink-message))
			     (size-message (send object :highlight-size-message))
			     (x-off 0)
			     (y-off 0))
  (with-blinker-prepared (self :open nil)
    (loop repeat static-entries
	     for entry from 0
	   until (highlighter-entry-equals (entry)
		   object blink-message size-message x-off y-off)
	 finally (when phase (sheet-is-prepared (sheet) (highlighter-blink-entry entry)))
	         (loop for i from entry below static-entries
		        do (highlighter-munge-arrays (setf (aref .array. i)
							   (aref .array. (+ i 1)))))
		 (setf (aref object-array (- static-entries 1)) nil)
		 (decf static-entries)
		 (highlighter-munge-arrays (decf (fill-pointer .array.))))))

(defmethod (:reset basic-highlighter) ()
  (declare (special .collecting-highlights.))
  (if (and (variable-boundp .collecting-highlights.) (eq .collecting-highlights. self))
      (ferror "Attempt to :RESET a highlighter inside a COLLECTING-HIGHLIGHTS.")
      (with-blinker-prepared (self :open nil)
	(when phase
	  (sheet-is-prepared (sheet)
	    (loop for entry from static-entries below (+ static-entries dynamic-entries)
		  do (highlighter-blink-entry entry))))
	(setq dynamic-entries 0)
	(highlighter-munge-arrays (setf (fill-pointer .array.) static-entries)))))

(compile-flavor-methods basic-highlighter)



(defflavor basic-highlighting-mixin
	()	 
	()
  (:required-flavors basic-sensitive-item)
  (:required-methods :highlight-blink-message	;These are messages instead of instance
		     :highlight-size-message))	;variables since they don't change during
						;the life of common objects, and we would
						;like to keep those objects small.
						;(Like Menu Items)

(defmethod (:mouse-moves basic-highlighting-mixin :before) (window ignore ignore)
  (let ((highlighter (send window :highlighter)))
    (when highlighter (send self :highlight highlighter))))

(defmethod (:highlight-superior-sensitive-item-p basic-highlighting-mixin) () nil)

(defmethod (:highlight basic-highlighting-mixin) (blinker)
  (collecting-highlights blinker		;We are usually called from inside of a
						;collecting-highlights, but this is here
						;so that when debugging, you can get the
						;desired effect just by sending the item
						;a :highlight message.
    (send self :highlight-internal blinker t t)))

(defmethod (:highlight-internal basic-highlighting-mixin) (blinker go-up-p go-down-p)
  go-down-p ;ignore
  (when (and go-up-p (send self :highlight-superior-sensitive-item-p))
    (send superior-sensitive-item :highlight-internal blinker t nil))
  (send self :collect-highlight blinker 
				(send self :highlight-blink-message)
				(send self :highlight-size-message)))

(defmethod (:collect-highlight basic-highlighting-mixin) (blinker blink-message size-message
								  &optional (x-offset 0)
									    (y-offset 0))
  (send blinker :collect-highlight self blink-message size-message x-offset y-offset))

(defflavor superior-highlighting-mixin
	()
	()
  (:required-flavors basic-highlighting-mixin)
  (:required-methods :highlight-inferiors-p))

(defmethod (:highlight-inferiors-p superior-highlighting-mixin) () nil)

(defwrapper (:highlight-internal superior-highlighting-mixin) ((blinker go-up-p go-down-p)
							       . body)
  `(progn ,@body
	  (when (and go-down-p (send self :highlight-inferiors-p))
	    ;; We are the original recipient of the :highlight message.
	    ;; Recurse down the tree if :highlight-inferiors-p is true.
	    (let-special ((.blinker. blinker))
	      (send self :map-over-sensitive-items
		    #'(lambda (item)
			(send item :highlight-internal .blinker. nil nil)))))))



(defflavor essential-window-with-sensitive-items
	  ((highlighter nil))
	  (superior-sensitive-item-mixin)
  ;; Be sure to precede any methods provided by ESSENTIAL-MOUSE, such as :MOUSE-CLICK
  (:component-order (essential-window-with-sensitive-items
		     superior-sensitive-item-mixin
		     essential-mouse))
  (:required-flavors sheet)
  :gettable-instance-variables
  (:init-keywords :highlighter-p) 
  (:default-init-plist :highlighter-p t :sensitivity ':inside))

(defmethod (:init essential-window-with-sensitive-items :after) (init-plist)
  (setq highlighter
	(if (get init-plist ':highlighter-p)
	    (tv:make-blinker self 'basic-highlighter :visibility t)
	    'ignore)))

(defwrapper (:handle-mouse essential-window-with-sensitive-items) (() . body)
  `(unwind-protect (progn . ,body) (send highlighter :reset)))

(defmethod (:mouse-moves essential-window-with-sensitive-items :after) (moves-x moves-y
									   &aux item)
  (decf moves-x (sheet-inside-left)) ;Convert to inside coordinates
  (decf moves-y (sheet-inside-top))
  (collecting-highlights highlighter
    (unless (or (minusp moves-x) (minusp moves-y)
		( moves-x (sheet-inside-width)) ( moves-y (sheet-inside-height))
		(null (setq item (send self ':mouse-sensitive-item moves-x moves-y))))
      (send item :mouse-moves self moves-x moves-y))))

(defmethod (:mouse-click essential-window-with-sensitive-items) (buttons click-x click-y
								    &aux item)  
  (decf click-x (sheet-inside-left))
  (decf click-y (sheet-inside-top))
  (unless (or (minusp click-x) (minusp click-y)
	      ( click-x (sheet-inside-width)) ( click-y (sheet-inside-height))
	      (null (setq item (send self ':mouse-sensitive-item click-x click-y))))
      (send item :mouse-click self buttons click-x click-y)))

(defmethod (:who-line-documentation-string essential-window-with-sensitive-items :override) ()
  (multiple-value-bind (x y)
      (sheet-mouse-position self)
    (let ((item (send self ':mouse-sensitive-item
		      (- x (sheet-inside-left))
		      (- y (sheet-inside-top)))))
      (and item (send item :who-line-documentation-string self)))))

(defmethod (:inferior-mouse-sensitive-item-modified essential-window-with-sensitive-items)
	   (&rest ignore)
  (mouse-wakeup))

(defmethod (:modified essential-window-with-sensitive-items) (&rest ignore)
  (mouse-wakeup))

;;; ESSENTIAL-WINDOW-WITH-SENSITIVE-ITEMS can have inferior sensitive items, but the window
;;; itself is not a sensitive item. The following two methods arrange for this.

(defmethod (:minimum-distance-to-boundary essential-window-with-sensitive-items) (test-x
										  test-y)
  (minimum-distance-to-rectangle 0 0 width height test-x test-y))

(defmethod (:mouse-sensitive-item essential-window-with-sensitive-items) (&rest ignore)
  nil)

;;; BASIC-WINDOW-WITH-SENSITIVE-ITEMS takes care of storing the items too.
(defflavor basic-window-with-sensitive-items
	((sensitive-items nil))
	(essential-window-with-sensitive-items)
  :initable-instance-variables
  :gettable-instance-variables)

(defmethod (:add-sensitive-item basic-window-with-sensitive-items) (item)
  (sensitive-item-modify-attributes
    (:inferior-sensitive-items sensitive-items (cons item (delq item sensitive-items)))))

(defmethod (:remove-sensitive-item basic-window-with-sensitive-items) (item)
  (sensitive-item-modify-attributes
    (:inferior-sensitive-items sensitive-items (delq item sensitive-items))))


;;; Things having to do with particular geometries.
;;;
;;; This code is modularized so as to try to help out people with flavors that already know
;;; a great deal about their geometry get as much us out of it as possible. Basically this
;;; code is split into three layers. The highest layer defines flavors which can completely
;;; keep track of an item's geometry. The next layer defines flavors that provide all the
;;; required geometry methods, but require one method to get the items geometry. The lowest
;;; layer provides functions to do common computations with on an item's geometry.

;;; MINIMUM-<some-geometry>-SENSITIVE-ITEM flavors are for including in flavors which
;;; already have a way storing information about their geometry but need to provide the
;;; geometry dependent methods required by basic-sensitive-item.  Each of these flavors
;;; requires one method to get the geometry information from wherever it is stored.

(defflavor minimum-rectangular-sensitive-item
	((highlighter-line-width 2))
	(basic-highlighting-mixin basic-sensitive-item)
  (:required-methods :rectangle-position-and-size)
  (:initable-instance-variables highlighter-line-width))

(defmethod (:minimum-distance-to-boundary minimum-rectangular-sensitive-item) (test-x test-y)
  (multiple-value-bind (rec-lef rec-top rec-wid rec-hei)
      (send self :rectangle-position-and-size)
    (minimum-distance-to-rectangle rec-lef rec-top rec-wid rec-hei test-x test-y)))

(defmethod (:highlight-blink-message minimum-rectangular-sensitive-item) ()
  ':blink-boundary)

(defmethod (:highlight-size-message minimum-rectangular-sensitive-item) ()
  ':boundary-size)

(defmethod (:blink-boundary minimum-rectangular-sensitive-item) (window &optional (x-off 0)
									(y-off 0))
  (multiple-value-bind (rec-lef rec-top rec-wid rec-hei)
      (send self :rectangle-position-and-size)
    (incf rec-lef (+ x-off (sheet-inside-left window)))
    (incf rec-top (+ y-off (sheet-inside-top window)))
    (let ((flip-alu (graphics::standardize-alu window :flip)))
      (%draw-rectangle-clipped highlighter-line-width rec-hei		       
			       (- rec-lef highlighter-line-width) rec-top
			       flip-alu window)
      (%draw-rectangle-clipped highlighter-line-width rec-hei
			       (+ rec-lef rec-wid) rec-top
			       flip-alu window)
      (%draw-rectangle-clipped (+ rec-wid (* highlighter-line-width 2)) highlighter-line-width
			       (- rec-lef highlighter-line-width)
			       (- rec-top highlighter-line-width)
			       flip-alu window)
      (%draw-rectangle-clipped (+ rec-wid (* highlighter-line-width 2)) highlighter-line-width
			       (- rec-lef highlighter-line-width)
			       (+ rec-top rec-hei)
			       flip-alu window))))

(defmethod (:boundary-size minimum-rectangular-sensitive-item) ()
  (multiple-value-bind (nil nil width height)
      (send self :rectangle-position-and-size)
    (values width height)))


(defflavor minimum-circular-sensitive-item
	((blinker-width 2))
	(basic-highlighting-mixin basic-sensitive-item)
  (:required-methods :circle-position-and-radius)
  (:initable-instance-variables blinker-width))

(defmethod (:minimum-distance-to-boundary minimum-circular-sensitive-item) (test-x test-y)
  (multiple-value-bind (center-x center-y radius)
      (send self :circle-position-and-radius)
    (minimum-distance-to-circle center-x center-y radius test-x test-y)))

(defmethod (:highlight-blink-message minimum-circular-sensitive-item) ()
  ':blink-boundary)

(defmethod (:blink-boundary minimum-circular-sensitive-item) (window &optional (x-off 0)
									       (y-off 0))
  (multiple-value-bind (center-x center-y radius)
      (send self :circle-position-and-radius)
    (incf center-x (+ x-off (sheet-inside-left window)))
    (incf center-y (+ y-off (sheet-inside-top window)))
    (send window :draw-filled-in-circle center-x center-y radius :flip)
    (send window :draw-filled-in-circle center-x center-y (+ radius blinker-width) :flip)))

;;;
;;;
(defflavor basic-rectangular-sensitive-item
	((x 0) (y 0) (width 0) (height 0))
	(minimum-rectangular-sensitive-item basic-sensitive-item)
  :initable-instance-variables
  :gettable-instance-variables)

(defmethod (:set-x basic-rectangular-sensitive-item) (new-x)
  (sensitive-item-modify-attributes
    (:x x new-x)))

(defmethod (:set-y basic-rectangular-sensitive-item) (new-y)
  (sensitive-item-modify-attributes
    (:y y new-y)))

(defmethod (:set-width basic-rectangular-sensitive-item) (new-width)
  (sensitive-item-modify-attributes
    (:width width new-width)))

(defmethod (:set-height basic-rectangular-sensitive-item) (new-height)
  (sensitive-item-modify-attributes
    (:height height new-height)))

(defmethod (:rectangle-position-and-size basic-rectangular-sensitive-item) ()
  (values x y width height))


(defflavor basic-circular-sensitive-item
	((x 0) (y 0) (radius 0))
	(minimum-circular-sensitive-item basic-sensitive-item)
  :initable-instance-variables
  :gettable-instance-variables)

(defmethod (:set-x basic-circular-sensitive-item) (new-x)
  (sensitive-item-modify-attributes
    (:x x new-x)))
(defmethod (:set-y basic-circular-sensitive-item) (new-y)
  (sensitive-item-modify-attributes
    (:y y new-y)))

(defmethod (:set-radius basic-circular-sensitive-item) (new-radius)
  (sensitive-item-modify-attributes
    (:width radius)
    (:height radius new-radius)))

(defmethod (:circle-position-and-radius basic-circular-sensitive-item) ()
  (values x y radius))

;;; Functions to compute the minimum distance from the boundary of a geomtric shape to
;;; a test point. These are abstracted out so that people who are not using the supplied
;;; geometry mixins (people who have their own way of representing an objects shape) can
;;; still use this code to do their minimum distance calculations.

(defun minimum-distance-to-rectangle (rec-left rec-top rec-width rec-height x y)
  "Returns the minimum distance from a rectangle to a test point. If the test
   point is inside the rectangle, then a negative number will be returned."
  (let* ((rec-right (+ rec-left rec-width -1))
	 (rec-bottom (+ rec-top rec-height -1))
	 (nearest-x (max rec-left (min rec-right x)))
	 (nearest-y (max rec-top (min rec-bottom y))))
    (cond ((and (= nearest-x x) (= nearest-y y))
	   ;; Point is inside rectangle
	   (- (min (- x rec-left)
		   (- rec-right x)
		   (- y rec-top)
		   (- rec-bottom y))))
	  (t
	   (let ((xdiff (- nearest-x x))
		 (ydiff (- nearest-y y)))
	     (sqrt (+ (* xdiff xdiff) (* ydiff ydiff))))))))

(defun minimum-distance-to-circle (center-x center-y radius x y)
  "Returns the minimum distance from a circle to a test point. If the test
   point is inside the circle, a negative number will be returned."
  (let ((xdiff (- x center-x))
	(ydiff (- y center-y)))
    (- (sqrt (+ (expt xdiff 2) (expt ydiff 2))) radius)))

;;; Square of the distance from the point x0y0 to the line between x1y1 and x2y2
;;; Also returns x and y of the nearest point
(defun minimum-distance-to-line-segment (x0 y0 x1 y1 x2 y2)
  (cond ((= x1 x2)			;line is vertical
	 (when (< y2 y1) (psetq y1 y2 y2 y1))
	 (cond ((> y0 y2) (values (sqrt (+ (expt (- x0 x2) 2) (expt (- y0 y2) 2))) x2 y2))
	       ((< y0 y1) (values (sqrt (+ (expt (- x0 x1) 2) (expt (- y0 y1) 2))) x1 y1))
	       (T (values (sqrt (expt (- x0 x1) 2)) x1 y0))))
	((= y1 y2)			;line is horizontal
	 (when (< x2 x1) (psetq x1 x2 x2 x1))
	 (cond ((> x0 x2) (values (sqrt (+ (expt (- x0 x2) 2) (expt (- y0 y2) 2))) x2 y2))
	       ((< x0 x1) (values (sqrt (+ (expt (- x0 x1) 2) (expt (- y0 y1) 2))) x1 y1))
	       (T (values (* (- y0 y1) (- y0 y1)) x0 y1))))
	(T (let* ((m1 (// (- y2 y1) (float (- x2 x1))))	;slope of the line
		  (b1 (- y1 (* m1 x1)))		        ;intercept of the line
		  (m2 (// -1.0 m1))		        ;slope of the perpendicular
		  (b2 (- y0 (* m2 x0)))		        ;intercept of the perpendicular
		  (xi (// (- b2 b1) (- m1 m2)))	        ;x of the intersection
		  (yi (+ (* m1 xi) b1)))	        ;y of the intersection
	     ;;make sure the intersection is between the endpoints
	     (if (not (and ( (min x1 x2) xi (max x1 x2)) ( (min y1 y2) yi (max y1 y2))))
		 (let ((dist1 (+ (* (- x1 x0) (- x1 x0)) (* (- y1 y0) (- y1 y0))))
		       (dist2 (+ (* (- x2 x0) (- x2 x0)) (* (- y2 y0) (- y2 y0)))))
		   (if (> dist1 dist2)
		       (values (sqrt dist2) x2 y2)
		       (values (sqrt dist1) x1 y1)))
		 (values (sqrt (+ (expt (- xi x0) 2) (expt (- yi y0) 2))) xi yi))))))

(defun minimum-distance-to-point (point-x point-y x y)
  "Returns the distance from one point to another point. If the points are on
   top of one another returns 0."
  (sqrt (+ (expt (- x point-x) 2) (expt (- y point-y) 2))))



(defflavor typed-sensitive-items-mixin
	((item-type-alist nil))			    ;Associates item types with operations
						    ;possible on that item type. See comment
						    ;above add-sensitive-item-type.
	(essential-window-with-sensitive-items)
  :settable-instance-variables
  (:required-methods :execute)
  (:documentation :mixin
   "Sensitive items may have a type. When they do have a type, the type is looked up in
    ITEM-TYPE-ALIST to find the operations that are possible on that type. Operations
    are defined using the ADD-SENSITIVE-ITEM-TYPE macro. Operations can be assigned to
    a particular button and any unused buttons get a menu of all the operations possible
    on that item."))

;;; The ADD-SENSITIVE-ITEM-TYPE macro is used to add sensitive item types to an item-type
;;; alist at the point in the program where the operations for that type are implemented.
;;; This adds one operation for one item type on a particular alist. The meaning of the
;;; arguments is as follows:
;;;    ALIST          the variable containing the item-type alist.
;;;    TYPE           the type keyword (the one used when creating the item).
;;;    OPERATION      the operation, this will be the first argument to the :EXECUTE
;;;                   message (the actual item will be the second argument)
;;;    NAME           the pretty-name of this operation.
;;;    DOCUMENTATION  who-line documentation string for this operation.
;;;    BUTTON         the button this operation should go on, specifically:
;;;                     NIL         means this operation only goes in the MENU
;;;                     #\MOUSE-x-y means button to put operation on
;;;                     T           means #\MOUSE-L-1
;;;                   Remember: the standard convention (hah) is to put a default
;;;                             operation on the left button and leave the right
;;;                             button as a menu of operations.
;;;    MENUP          whether or not this item should go in the menu
;;;                     T (default) means it should go in the menu  (def
;;;                     NIL         means it shouldn't go in the menu
;;;                   This is useful for putting a default operation on a button
;;;                   that really shouldn't go in the menu.
;;;
;;; An ITEM-TYPE-ALIST is an alist whose elements look like:
;;;   (type wholine-doc ((button operation name doc)...) (menu-item..) menu-last-item)
;;;
;;; Note that there are no accessors for these since this is the only code that should
;;; poke around inside the alists themselves.

(defmacro add-sensitive-item-type (alist type operation name &optional documentation
								       button
								       (menup t))
  (when (eq button t) (setq button #\mouse-l-1))
  `(setq ,alist (add-sensitive-item-type-1
		  ,alist ',type ',operation ,name ,documentation ,button ,menup)))

(defun add-sensitive-item-type-1 (alist type operation name documentation button menup
				   &aux alist-elem)
  (when (eq button t) (setq button #\mouse-l-1))
  ;; If this type is new, add it to the end of the list (so old copies tend to share)
  (or (setq alist-elem (assq type alist))
      (setq alist (nconc alist (ncons (setq alist-elem (list type nil nil nil nil))))))
  ;; If this operation goes on a button, remember it.  Keep the list sorted left-to-right.
  (setf (third alist-elem)
	(delq (ass #'(lambda (x y)
		       (or (and (null x) (null y))
			   (and x y (char-mouse-equal x y))))
		   button (third alist-elem)) (third alist-elem)))
  (when button
    (push (list button operation name documentation) (third alist-elem))
    (setf (third alist-elem)
	  (sortcar (third alist-elem) #'si:char-mouse-<)))
  ;; Add/Remove this operation to the menu that unused buttons call up
  (setf (fourth alist-elem) (delq (assoc name (fourth alist-elem)) (fourth alist-elem)))
  (when menup
    (push (list name ':value operation ':documentation documentation) (fourth alist-elem)))
  ;; Update the who-line documentation
  (setf (second alist-elem) (make-sensitive-item-type-prompt (second alist-elem)
							     (third alist-elem)
							     (fourth alist-elem)))
  alist)

(defmacro set-sensitive-item-type-who-line-documentation-string (alist type who-line-string)
  `(setq alist (set-sensitive-item-type-who-line-documentation-string-1
		 ,alist ',type ',who-line-string)))

(defun set-sensitive-item-type-who-line-documentation-string-1 (alist type who-line-string)
  (let ((alist-elem (assq type alist)))
    (when alist-elem (setf (second alist-elem) who-line-string))))

(defun make-sensitive-item-type-prompt (string buttons menu)
  (if string
      (setf (fill-pointer string) 0)
      (setq string (make-array 96. ':type 'art-string ':leader-list '(0))))
  (let ((multiple-clicks
	  (loop for (button) in buttons
		thereis (not (zerop (char-mouse-bits button)))))
	(menu-button
	  (cond ((not (ass #'char-mouse-equal #\mouse-r-1 buttons)) #\mouse-r-1)
		((not (ass #'char-mouse-equal #\mouse-m-1 buttons)) #\mouse-m-1)
		((not (ass #'char-mouse-equal #\mouse-l-1 buttons)) #\mouse-l-1))))
    (loop for (button operation nil doc) in buttons
	  do
      ;; this UNLESS clause was commented out in the original source
      ;; it is needed for reasonable formatting, so I added it back -York 5/29/85
      (unless (zerop (fill-pointer string))
	(string-nconc string ", "))
      (string-nconc string
		    (sensitive-item-type-prompt-button-name button multiple-clicks)
		    ": "
		    (or doc (string operation))))
    (cond ((and (> (length menu) 1) menu-button)
	   (if (plusp (fill-pointer string))
	       (string-nconc string
		 ", "
		 (sensitive-item-type-prompt-button-name menu-button multiple-clicks)
		 ": "))
	   (string-nconc string "menu of ")
	   (loop for (name) in menu with first-p = t
		 do (if first-p (setq first-p nil) (string-nconc string ", "))
		    (string-nconc string name)
		 finally (string-nconc string #/.)))))
  string)

(defun sensitive-item-type-prompt-button-name (button multiple-clicks)
  (or (cdr (ass #'char-mouse-equal button
		(if (not multiple-clicks)
		    '((#\mouse-l-1 . "Left")
		      (#\mouse-m-1 . "Middle")
		      (#\mouse-r-1 . "Right"))
		    '((#\mouse-l-1 . "L") (#\mouse-l-2 . "sh-L")
		      (#\mouse-m-1 . "M") (#\mouse-m-2 . "sh-M")
		      (#\mouse-r-1 . "R") (#\mouse-r-2 . "sh-R")))))
      (with-output-to-string (stream)
	(format:format-mouse-character stream button nil nil nil nil))))

(defflavor typed-sensitive-item-mixin
	((sensitive-item-type nil))
	(basic-sensitive-item)
  :initable-instance-variables
  :gettable-instance-variables)

(defmethod (:set-sensitive-item-type typed-sensitive-item-mixin) (new-value)
  (sensitive-item-modify-attributes
    (:sensitive-item-type sensitive-item-type new-value)))

;;; Clicking the mouse on a sensitive item sends the :EXECUTE message to the window with the
;;; with the selected operation and the item.  If the button wasn't assigned to a particular
;;; operation we will have to pop up a menu to get the operation (in another process).
(defmethod (:mouse-click typed-sensitive-item-mixin) (window button ignore ignore)
  (let ((item-type-alist (send window :send-if-handles :item-type-alist)) elem op)
    (when (and sensitive-item-type (setq elem (assq sensitive-item-type item-type-alist)))
      (cond ((setq op (cadr (ass #'char-mouse-equal button (third elem))))
	     ;; this is a click with a specific operation bound to it
	     (send window ':execute op self)
	     t)
	    ((and (zerop (char-mouse-bits button)) (fourth elem))
	     ;; only single clicks get menu, to avoid usurping system menu
	     (process-run-function "menu choose"
				   #'sensitive-item-type-choose elem self window)
	     t)))))

(defwindow-resource typed-sensitive-items-menu ()
  :make-window (momentary-menu)
  :reusable-when :deactivated
  ;; can't actually make any since window system isn't set up enough when
  ;; this file is loaded (during system building).
  :initial-copies 0)

;;; Operation has to be chosen from menu
(defun sensitive-item-type-choose (item-type-alist-element item window)
  (destructuring-bind (nil nil nil choices last-item)
		      item-type-alist-element
    (using-resource (menu typed-sensitive-items-menu)
      (unwind-protect
	(progn		
	  (send menu :set-item-list choices)
	  (send menu :set-last-item last-item)
	  (let ((operation (send menu ':choose)))
	    (when operation (send window ':execute operation item))))
	(setf (fifth item-type-alist-element) (send menu :last-item))))))

;;; document the item the mouse is pointing at
(defmethod (:who-line-documentation-string typed-sensitive-item-mixin) (window)
  (second (assq sensitive-item-type (send window :send-if-handles :item-type-alist))))
