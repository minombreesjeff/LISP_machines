;;; -*- Mode: LISP; Package: TV; Base: 8 -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(DEFFLAVOR TEXT-SCROLL-WINDOW
       ((ITEMS NIL)				;An array of all items
	(TOP-ITEM 0)				;The index of the topmost displayed item
	)
       (BASIC-SCROLL-BAR)
  :GETTABLE-INSTANCE-VARIABLES
  (:DEFAULT-INIT-PLIST :BLINKER-P NIL :TRUNCATE-LINE-OUT-FLAG 1)
  (:DOCUMENTATION :MIXIN "Scrolling of lines all of one type"))

(DEFMETHOD (:INIT TEXT-SCROLL-WINDOW :BEFORE) (PLIST)
  (COND ((NOT (ARRAYP ITEMS))
	 (SETQ ITEMS (MAKE-ARRAY (OR ITEMS 100.) ':LEADER-LENGTH 1))
	 (SETF (FILL-POINTER ITEMS) 0)))
  (PUTPROP PLIST NIL ':MORE-P))

(DEFMETHOD (:SET-ITEMS TEXT-SCROLL-WINDOW) (NEW-ITEMS &OPTIONAL (NEW-TOP-ITEM 0))
  (SETQ ITEMS
	(COND ((ARRAYP NEW-ITEMS) NEW-ITEMS)
	      (T (COND ((NUMBERP NEW-ITEMS)
			(MAKE-ARRAY NEW-ITEMS ':FILL-POINTER 0))
		       ((OR (NULL NEW-ITEMS) (LISTP NEW-ITEMS))
			(LET* ((NITEMS (LENGTH NEW-ITEMS))
			       (ARRAY (MAKE-ARRAY (MAX 100. NITEMS) ':FILL-POINTER
						  NITEMS)))
			  (FILLARRAY ARRAY NEW-ITEMS)
			  (SETF (FILL-POINTER ARRAY) NITEMS)
			  ARRAY))
		       (T (FERROR "How do you :SET-ITEMS from ~S?" NEW-ITEMS))))))
  (SHEET-FORCE-ACCESS (SELF T)
    (SETQ TOP-ITEM NEW-TOP-ITEM)
    (SEND SELF ':CLEAR-WINDOW)
    (SEND SELF ':REDISPLAY 0 (SHEET-NUMBER-OF-INSIDE-LINES))))

(DEFMETHOD (:LAST-ITEM TEXT-SCROLL-WINDOW) ()
  (AND ITEMS (> (ARRAY-ACTIVE-LENGTH ITEMS) 0)
       (AREF ITEMS (1- (ARRAY-ACTIVE-LENGTH ITEMS)))))

(DEFMETHOD (:ITEM-VALUE TEXT-SCROLL-WINDOW) (ITEM-NO)
  (AND ITEMS (AREF ITEMS ITEM-NO)))

(DEFMETHOD (:NUMBER-OF-ITEMS TV:TEXT-SCROLL-WINDOW) ()
  (ARRAY-ACTIVE-LENGTH TV:ITEMS))

(DEFMETHOD (:PUT-LAST-ITEM-IN-WINDOW TEXT-SCROLL-WINDOW) ()
  (OR ( (ARRAY-ACTIVE-LENGTH ITEMS)
	 (+ TOP-ITEM (SHEET-NUMBER-OF-INSIDE-LINES) -1))
      ;; Last item not on screen -- put it on bottom line
      (SEND SELF ':Y-SCROLL-TO (- (ARRAY-ACTIVE-LENGTH ITEMS)
				(SHEET-NUMBER-OF-INSIDE-LINES))
			     ':ABSOLUTE)))

(DEFMETHOD (:PUT-ITEM-IN-WINDOW TEXT-SCROLL-WINDOW) (ITEM)
  ;; If item not visible, put it in the window; if off the top, bring it to the
  ;; top.  If off the bottom, bring it to the bottom.
  (LET ((ITEM-NO (DOTIMES (I (ARRAY-ACTIVE-LENGTH ITEMS))
		   (AND (EQ (AREF ITEMS I) ITEM) (RETURN I))))
	(BOTTOM-ITEM (+ TOP-ITEM (SHEET-NUMBER-OF-INSIDE-LINES) -1)))
    (COND ((NULL ITEM-NO))
	  ((< ITEM-NO TOP-ITEM)
	   (SEND SELF ':Y-SCROLL-TO ITEM-NO ':ABSOLUTE))
	  ((> ITEM-NO BOTTOM-ITEM)
	   (SEND SELF ':Y-SCROLL-TO (- ITEM-NO (- BOTTOM-ITEM TOP-ITEM)) ':ABSOLUTE)))))

(DEFMETHOD (:APPEND-ITEM TEXT-SCROLL-WINDOW) (NEW-ITEM)
  (SEND SELF ':INSERT-ITEM (ARRAY-ACTIVE-LENGTH ITEMS) NEW-ITEM))

(DEFMETHOD (:DELETE-ITEM TEXT-SCROLL-WINDOW) (ITEM-NO &AUX I)
  (STORE-ARRAY-LEADER (1- (ARRAY-LEADER ITEMS 0)) ITEMS 0)
  (DO ((I ITEM-NO (1+ I)))
      (( I (ARRAY-ACTIVE-LENGTH ITEMS)))
    (ASET (AREF ITEMS (1+ I)) ITEMS I))
  (COND ((< ITEM-NO TOP-ITEM)
	 (SETQ TOP-ITEM (1- TOP-ITEM))
	 (SEND SELF ':NEW-SCROLL-POSITION))
	((< ITEM-NO (+ TOP-ITEM (SHEET-NUMBER-OF-INSIDE-LINES)))
	 ;; Old item was on the screen -- flush it
	 (SHEET-FORCE-ACCESS (SELF :NO-PREPARE)
	   (SEND SELF ':SET-CURSORPOS 0 (* LINE-HEIGHT (- ITEM-NO TOP-ITEM)))
	   (SEND SELF ':DELETE-LINE 1)
	   (SEND SELF ':REDISPLAY
			 (SETQ I (1- (SHEET-NUMBER-OF-INSIDE-LINES)))
			 (1+ I))))
	(T (SEND SELF ':NEW-SCROLL-POSITION)))
  ITEM-NO)

(DEFMETHOD (:INSERT-ITEM TEXT-SCROLL-WINDOW) (ITEM-NO NEW-ITEM)
  "Inserts an item before ITEM-NO"
  (LET ((NO-ITEMS (ARRAY-LEADER ITEMS 0)))
    (SETQ ITEM-NO (MIN (MAX ITEM-NO 0) NO-ITEMS))
    (ARRAY-PUSH-EXTEND ITEMS NIL)
    (DOTIMES (I (- NO-ITEMS ITEM-NO))
      ;; Bubble items up
      (ASET (AREF ITEMS (- NO-ITEMS I 1)) ITEMS (- NO-ITEMS I)))
    (ASET NEW-ITEM ITEMS ITEM-NO)
    (COND ((< ITEM-NO TOP-ITEM)
	   (SETQ TOP-ITEM (1+ TOP-ITEM))
	   (SEND SELF ':NEW-SCROLL-POSITION))
	  ((< ITEM-NO (+ TOP-ITEM (SHEET-NUMBER-OF-INSIDE-LINES)))
	   ;; New item is on screen, insert a line then redisplay it
	   (SHEET-FORCE-ACCESS (SELF :NO-PREPARE)
	     (SEND SELF ':SET-CURSORPOS 0 (* LINE-HEIGHT
						(SETQ ITEM-NO (- ITEM-NO TOP-ITEM))))
	     (SEND SELF ':INSERT-LINE 1)
	     (SEND SELF ':REDISPLAY ITEM-NO (1+ ITEM-NO))))
	  (T (SEND SELF ':NEW-SCROLL-POSITION))))
  ITEM-NO)

(DEFMETHOD (:REPLACE-ITEM TEXT-SCROLL-WINDOW) (ITEM-NO NEW-ITEM)
  (SETQ ITEM-NO (MIN (MAX ITEM-NO 0) (ARRAY-ACTIVE-LENGTH ITEMS)))
  (ASET NEW-ITEM ITEMS ITEM-NO)
  (WHEN (AND ( ITEM-NO TOP-ITEM)
	     (< ITEM-NO (+ TOP-ITEM (SHEET-NUMBER-OF-INSIDE-LINES))))
    (SHEET-FORCE-ACCESS (SELF :NO-PREPARE)
      (LET ((REL-ITEM-NO (- ITEM-NO TOP-ITEM)))
	(SEND SELF ':SET-CURSORPOS 0 (* LINE-HEIGHT REL-ITEM-NO))
	(SEND SELF ':CLEAR-REST-OF-LINE)
	(SEND SELF ':REDISPLAY REL-ITEM-NO (1+ REL-ITEM-NO))))))

(DEFUN-IN-FLAVOR (FIND-ITEM-INDEX TEXT-SCROLL-WINDOW) (THE-ITEM)
  (LOOP FOR ITEM BEING THE ARRAY-ELEMENTS OF ITEMS
	FOR I UPFROM 0
	WHEN (EQ THE-ITEM ITEM)
	RETURN I
	FINALLY (FERROR "Item ~S not found." THE-ITEM)))

(DEFMETHOD (:REDISPLAY-ITEM TEXT-SCROLL-WINDOW) (ITEM)
  (LET* ((ITEM-NUMBER (FIND-ITEM-INDEX ITEM))
	 (RELATIVE-ITEM-NUMBER (- ITEM-NUMBER TOP-ITEM)))
    (WHEN (AND (NOT (MINUSP RELATIVE-ITEM-NUMBER))
	       (< RELATIVE-ITEM-NUMBER (SHEET-NUMBER-OF-INSIDE-LINES)))
      (SEND SELF ':DRAW-RECTANGLE (SHEET-INSIDE-WIDTH)
	    LINE-HEIGHT 0 (* RELATIVE-ITEM-NUMBER LINE-HEIGHT) :ERASE)
      (SEND SELF ':REDISPLAY RELATIVE-ITEM-NUMBER (1+ RELATIVE-ITEM-NUMBER)))))

;;; When exposed, draw in the items
(DEFMETHOD (:REFRESH TEXT-SCROLL-WINDOW :AFTER) (&OPTIONAL TYPE)
  (AND (OR (NOT RESTORED-BITS-P) (EQ TYPE ':SIZE-CHANGED))
       (SEND SELF ':REDISPLAY 0 (SHEET-NUMBER-OF-INSIDE-LINES))))

;;; Arguments are screen line indices -- assumes screen area already erased
(DEFMETHOD (:REDISPLAY TEXT-SCROLL-WINDOW) (START END)
  (DO ((I START (1+ I))
       (J (+ START TOP-ITEM) (1+ J))
       (LIM (ARRAY-ACTIVE-LENGTH ITEMS)))
      ((OR ( I END) ( J LIM)))
    (SEND SELF ':SET-CURSORPOS 0 (* LINE-HEIGHT I))
    (SEND SELF ':PRINT-ITEM (AREF ITEMS J) I J))
  (SEND SELF ':NEW-SCROLL-POSITION))

;;; Each item is allowed only one line
(DEFWRAPPER (:PRINT-ITEM TEXT-SCROLL-WINDOW) (IGNORE . BODY)
  `(CATCH 'LINE-OVERFLOW
       (LET ((CL:*PRINT-PRETTY* NIL))
	 ,@BODY)))

(DEFMETHOD (:END-OF-LINE-EXCEPTION TEXT-SCROLL-WINDOW :BEFORE) ()
  (OR (ZEROP (SHEET-TRUNCATE-LINE-OUT-FLAG))
      (THROW 'LINE-OVERFLOW T)))

;;; Simplest printer, you want to redefine this probably
(DEFMETHOD (:PRINT-ITEM TEXT-SCROLL-WINDOW) (ITEM LINE-NO ITEM-NO)
  LINE-NO ITEM-NO				;Ignore these
  (PRIN1 ITEM SELF))

;;; Scrolling
(DEFMETHOD (:SCROLL-BAR-P TEXT-SCROLL-WINDOW) ()
  (OR (PLUSP TOP-ITEM)
      (> (ARRAY-ACTIVE-LENGTH ITEMS) (SHEET-NUMBER-OF-INSIDE-LINES))))

(DEFMETHOD (:Y-SCROLL-POSITION TEXT-SCROLL-WINDOW) ()
  (VALUES TOP-ITEM (SHEET-NUMBER-OF-INSIDE-LINES) 0 (ARRAY-ACTIVE-LENGTH ITEMS)))

(DEFMETHOD (:Y-SCROLL-TO TEXT-SCROLL-WINDOW) (NEW-TOP TYPE &AUX DELTA)
  (UNLESS (EQ TYPE ':ABSOLUTE) (SETQ NEW-TOP (+ TOP-ITEM NEW-TOP)))
  (SETQ NEW-TOP (MAX (MIN NEW-TOP (1- (ARRAY-ACTIVE-LENGTH ITEMS))) 0))
  (SETQ DELTA (- NEW-TOP TOP-ITEM))
  (OR (= DELTA 0)				;Nothing to change
      (SEND SELF ':SCROLL-REDISPLAY NEW-TOP DELTA))
  (SEND SELF ':NEW-SCROLL-POSITION))

(DEFMETHOD (:NEW-SCROLL-POSITION TEXT-SCROLL-WINDOW :AFTER) (&REST IGNORE)
  (MOUSE-WAKEUP))

;;;This is a message so it can have daemons
(DEFMETHOD (:SCROLL-REDISPLAY TEXT-SCROLL-WINDOW) (NEW-TOP DELTA &AUX NLINES)
  (SEND SELF ':HOME-CURSOR)
  (SETQ NLINES (SHEET-NUMBER-OF-INSIDE-LINES))
  (COND	((> DELTA 0)				;Scrolling forward
	 (SETQ DELTA (MIN DELTA NLINES))
	 (WITHOUT-INTERRUPTS
	   (SEND SELF ':DELETE-LINE DELTA)
	   (SETQ TOP-ITEM NEW-TOP))
	 (SEND SELF ':REDISPLAY (- NLINES DELTA) NLINES))
	((< DELTA 0)				;Scrolling backward
	 (SETQ DELTA (MIN (- DELTA) NLINES))
	 (WITHOUT-INTERRUPTS
	   (SEND SELF ':INSERT-LINE DELTA)
	   (SETQ TOP-ITEM NEW-TOP))
	 (SEND SELF ':REDISPLAY 0 DELTA)))
  (SEND SELF ':NEW-SCROLL-POSITION))

(DEFFLAVOR FUNCTION-TEXT-SCROLL-WINDOW
       (PRINT-FUNCTION				;Function called to print the item
	(PRINT-FUNCTION-ARG NIL)		;Fixed argument for above
	)
       (TEXT-SCROLL-WINDOW)
  (:SETTABLE-INSTANCE-VARIABLES PRINT-FUNCTION PRINT-FUNCTION-ARG)
  (:DOCUMENTATION :MIXIN "Text scroll windows that print lines by calling a set function"))

(DEFMETHOD (:SETUP FUNCTION-TEXT-SCROLL-WINDOW) (LIST)
  ;; Label changing should be first -- this may cause redisplay so flush current items too
  (AND ITEMS (STORE-ARRAY-LEADER 0 ITEMS 0))
  (AND ( (LENGTH LIST) 5) (SEND SELF ':SET-LABEL (FIFTH LIST)))
  (SEND SELF ':SET-PRINT-FUNCTION (FIRST LIST))
  (SEND SELF ':SET-PRINT-FUNCTION-ARG (SECOND LIST))
  (LET ((ARRAY (OR ITEMS (MAKE-ARRAY (LENGTH (THIRD LIST)) ':LEADER-LENGTH 1))))
    (STORE-ARRAY-LEADER 0 ARRAY 0)
    (DO L (THIRD LIST) (CDR L) (NULL L) (ARRAY-PUSH-EXTEND ARRAY (CAR L)))
    (SEND SELF ':SET-ITEMS ARRAY (OR (FOURTH LIST) 0)))
  LIST)

(DEFMETHOD (:PRINT-ITEM FUNCTION-TEXT-SCROLL-WINDOW) (ITEM IGNORE ITEM-NO)
  (FUNCALL PRINT-FUNCTION ITEM PRINT-FUNCTION-ARG SELF ITEM-NO))


(DEFFLAVOR TEXT-SCROLL-WINDOW-TYPEOUT-MIXIN () (WINDOW-WITH-TYPEOUT-MIXIN)
  (:REQUIRED-FLAVORS TEXT-SCROLL-WINDOW)
  (:DOCUMENTATION :MIXIN "Makes a TEXT-SCROLL-WINDOW have a typeout window"))

(DEFUN-IN-FLAVOR (TEXT-SCROLL-WINDOW-FLUSH-TYPEOUT TEXT-SCROLL-WINDOW-TYPEOUT-MIXIN) ()
  "If the typeout window is active, deexpose it, and make sure the redisplayer knows how many lines were clobbered."
  (COND ((SEND TYPEOUT-WINDOW ':ACTIVE-P)
	 (LET ((BR (MIN (SHEET-NUMBER-OF-INSIDE-LINES)	; BR stands for "Bottom Reached"
			(1+ (// (SEND TYPEOUT-WINDOW ':BOTTOM-REACHED) LINE-HEIGHT)))))
	   (SEND TYPEOUT-WINDOW ':DEACTIVATE)
	   (SEND SELF ':DRAW-RECTANGLE (SHEET-INSIDE-WIDTH) (* BR LINE-HEIGHT) 0 0 :ERASE)
	   BR))))				; This is the number of lines to redisplay

(DEFWRAPPER (:REDISPLAY TEXT-SCROLL-WINDOW-TYPEOUT-MIXIN) (ARGS . BODY)
  `(LET ((TO (TEXT-SCROLL-WINDOW-FLUSH-TYPEOUT)))	; flushes typeout and calculates how many
     (COND (TO					; lines should be redisplayed
	    (SETF (FIRST ARGS) 0)
	    (SETF (SECOND ARGS) (MAX TO (SECOND ARGS)))))
     . ,BODY))

(DEFMETHOD (:FLUSH-TYPEOUT TEXT-SCROLL-WINDOW-TYPEOUT-MIXIN) ()
  (LET ((TO (TEXT-SCROLL-WINDOW-FLUSH-TYPEOUT)))
    (AND TO (SEND SELF ':REDISPLAY 0 TO))))

(DEFFLAVOR DISPLAYED-ITEMS-TEXT-SCROLL-WINDOW
	(DISPLAYED-ITEMS				;An array of mouse sensitive items
	  )
	(TEXT-SCROLL-WINDOW)
  (:GETTABLE-INSTANCE-VARIABLES DISPLAYED-ITEMS)
  (:DOCUMENTATION :MIXIN "Keep track of displayed items on the screen"))

(DEFMETHOD (:INIT DISPLAYED-ITEMS-TEXT-SCROLL-WINDOW :AFTER) (IGNORE)
  (SETQ DISPLAYED-ITEMS (MAKE-ARRAY (SHEET-NUMBER-OF-INSIDE-LINES))))

(DEFMETHOD (:CHANGE-OF-SIZE-OR-MARGINS DISPLAYED-ITEMS-TEXT-SCROLL-WINDOW :AFTER)
	   (&REST IGNORE)
  (LET ((NLINES (SHEET-NUMBER-OF-INSIDE-LINES)))
    (AND (< (ARRAY-LENGTH DISPLAYED-ITEMS) NLINES)
	 (ADJUST-ARRAY-SIZE DISPLAYED-ITEMS NLINES))))

(DEFMETHOD (:DELETE-ITEM DISPLAYED-ITEMS-TEXT-SCROLL-WINDOW :BEFORE) (ITEM-NO &AUX AL)
  "Deleting an item -- if on the screen, update the displayed items appropriately"
  (SETQ ITEM-NO (- ITEM-NO TOP-ITEM)
	AL (SHEET-NUMBER-OF-INSIDE-LINES))
  (COND ((AND ( ITEM-NO 0)
	      (< ITEM-NO AL))
	 (DOTIMES (I (- AL ITEM-NO 1))
	   (ASET (AREF DISPLAYED-ITEMS (+ I ITEM-NO 1)) DISPLAYED-ITEMS (+ I ITEM-NO)))
	 (ASET NIL DISPLAYED-ITEMS (1- AL)))))

(DEFMETHOD (:INSERT-ITEM DISPLAYED-ITEMS-TEXT-SCROLL-WINDOW :BEFORE) (ITEM-NO IGNORE &AUX AL)
  "Inserting an item -- adjust the data structure appropriatly"
  (SETQ ITEM-NO (- ITEM-NO TOP-ITEM)
	AL (SHEET-NUMBER-OF-INSIDE-LINES))
  (COND ((AND ( ITEM-NO 0)
	      (< ITEM-NO AL))
	 ;; The item will be on the screen, adjust the data structure
	 (DOTIMES (I (- AL ITEM-NO 1))
	   (ASET (AREF DISPLAYED-ITEMS (- AL I 2)) DISPLAYED-ITEMS (- AL I 1)))
	 (ASET NIL DISPLAYED-ITEMS ITEM-NO))))

;;;Forget anything that was on screen before
(DEFMETHOD (:REDISPLAY DISPLAYED-ITEMS-TEXT-SCROLL-WINDOW :BEFORE) (START END)
  (DO I START (1+ I) ( I END)
    (ASET NIL DISPLAYED-ITEMS I)))

(DEFMETHOD (:SET-ITEMS DISPLAYED-ITEMS-TEXT-SCROLL-WINDOW :BEFORE) (&REST IGNORE)
  ;; Make sure mouse isn't left pointing to gubbish
  (DOTIMES (I (ARRAY-LENGTH DISPLAYED-ITEMS))
    (ASET NIL DISPLAYED-ITEMS I)))

(DEFMETHOD (:SCROLL-REDISPLAY DISPLAYED-ITEMS-TEXT-SCROLL-WINDOW :BEFORE) (IGNORE DELTA
									   &AUX NLINES)
  (SETQ NLINES (SHEET-NUMBER-OF-INSIDE-LINES))
  (COND ((> DELTA 0)				;Scrolling forward
	 (DO ((I DELTA (1+ I))
	      (J 0 (1+ J)))
	     (( I NLINES)
	      (DO J J (1+ J) ( J NLINES)
		(ASET NIL DISPLAYED-ITEMS J)))
	   (ASET (AREF DISPLAYED-ITEMS I) DISPLAYED-ITEMS J)))
	((< DELTA 0)				;Scrolling backward
	 (DO ((I (1- (+ NLINES DELTA)) (1- I))
	      (J (1- NLINES) (1- J)))
	     ((< I 0)
	      (DO J J (1- J) (< J 0)
		(ASET NIL DISPLAYED-ITEMS J)))
	   (ASET (AREF DISPLAYED-ITEMS I) DISPLAYED-ITEMS J)))))

(DEFFLAVOR MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW-WITHOUT-CLICK
       ((SENSITIVE-ITEM-TYPES T)		;Types of items that can be selected
	ITEM-BLINKER				;Blinker for displaying things
	)
       (DISPLAYED-ITEMS-TEXT-SCROLL-WINDOW)
  (:SETTABLE-INSTANCE-VARIABLES SENSITIVE-ITEM-TYPES)
  (:DOCUMENTATION :MIXIN "Text scroll window that allows selection of parts of text"))

(DEFSTRUCT (MOUSE-SENSITIVE-ITEM :LIST (:CONSTRUCTOR NIL))
  DISPLAYED-ITEM-ITEM
  DISPLAYED-ITEM-TYPE
  DISPLAYED-ITEM-LEFT
  DISPLAYED-ITEM-RIGHT)

(DEFMETHOD (:ADD-MOUSE-SENSITIVE-ITEM-FOR-LINE MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW-WITHOUT-CLICK) (DISITEM LINE-NO)
  (PUSH DISITEM (AREF DISPLAYED-ITEMS LINE-NO)))

(DEFMETHOD (:MOUSE-SENSITIVE-ITEMS-FOR-LINE MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW-WITHOUT-CLICK) (LINE-NO)
  (AREF DISPLAYED-ITEMS LINE-NO))

(DEFMETHOD (:INIT MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW-WITHOUT-CLICK :AFTER) (IGNORE)
  (SETQ ITEM-BLINKER (MAKE-BLINKER SELF 'HOLLOW-RECTANGULAR-BLINKER ':VISIBILITY NIL)))

;;;Print something that is sensitive to the mouse -- generally called inside a :PRINT-ITEM
(DEFMETHOD (:ITEM MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW-WITHOUT-CLICK)
	   (ITEM TYPE &OPTIONAL (FUNCTION #'PRIN1) &REST PRINT-ARGS &AUX DISITEM)
  (SETQ DISITEM (LIST ITEM TYPE CURSOR-X (SHEET-INSIDE-RIGHT)))
  (SEND SELF ':ADD-MOUSE-SENSITIVE-ITEM-FOR-LINE DISITEM (SHEET-LINE-NO))
  (LEXPR-FUNCALL FUNCTION ITEM SELF PRINT-ARGS)
  ;; Try to avoid making zero-length items that cannot be selected with the mouse
  (SETF (DISPLAYED-ITEM-RIGHT DISITEM)
	(MIN (MAX (+ (DISPLAYED-ITEM-LEFT DISITEM) (SHEET-CHAR-WIDTH SELF)) CURSOR-X)
	     (SHEET-INSIDE-RIGHT)))
  (MOUSE-WAKEUP))

(DEFMETHOD (:HANDLE-MOUSE MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW-WITHOUT-CLICK :AFTER) ()
  (BLINKER-SET-VISIBILITY ITEM-BLINKER NIL))

;;; Turn off blinker before setting up new items
(DEFMETHOD (:SET-ITEMS MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW-WITHOUT-CLICK :BEFORE)
	   (&REST IGNORE)
  (BLINKER-SET-VISIBILITY ITEM-BLINKER NIL))

;;;Blink any item the mouse points to
(DEFUN-IN-FLAVOR (TEST-FOR-MOUSE-SENSITIVE-ITEMS MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW-WITHOUT-CLICK)
	   (X Y &AUX ITEM TYPE LEFT TOP BWIDTH BHEIGHT)
  (MOUSE-SET-BLINKER-CURSORPOS SELF)
  (MULTIPLE-VALUE (ITEM TYPE LEFT BWIDTH TOP)
    (SEND SELF ':MOUSE-SENSITIVE-ITEM X Y))
  (IGNORE ITEM)
  (COND (TYPE
	 (SETQ BWIDTH (- BWIDTH LEFT)
	       BHEIGHT (FONT-BLINKER-HEIGHT CURRENT-FONT))
	 (BLINKER-SET-CURSORPOS ITEM-BLINKER (- LEFT (SHEET-INSIDE-LEFT))
					     (- TOP (SHEET-INSIDE-TOP)))
	 (BLINKER-SET-SIZE ITEM-BLINKER BWIDTH BHEIGHT)
	 (BLINKER-SET-VISIBILITY ITEM-BLINKER T))
	(T (BLINKER-SET-VISIBILITY ITEM-BLINKER NIL))))

(DEFMETHOD (:MOUSE-MOVES MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW-WITHOUT-CLICK) (X Y)
  (TEST-FOR-MOUSE-SENSITIVE-ITEMS X Y))

(DEFUN-IN-FLAVOR (ITEM-MOUSE-SENSITIVE-P MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW-WITHOUT-CLICK) (ITEM)
  (OR (EQ SENSITIVE-ITEM-TYPES T)	;If everything visible,
      (COND ((FUNCTIONP SENSITIVE-ITEM-TYPES)
	     (FUNCALL SENSITIVE-ITEM-TYPES ITEM))	;or filter funtion,
	    ((AND SENSITIVE-ITEM-TYPES
		  (SYMBOLP SENSITIVE-ITEM-TYPES))	;or method says it's ok
	     (SEND SELF SENSITIVE-ITEM-TYPES ITEM))
	    (T (MEMQ (DISPLAYED-ITEM-TYPE ITEM)	;or this is ok
		     SENSITIVE-ITEM-TYPES)))))

(DEFUN-IN-FLAVOR (MOUSE-SENSITIVE-ITEM MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW-WITHOUT-CLICK)
		 (X Y &AUX LINE-NO)
  (SETQ LINE-NO (SHEET-LINE-NO NIL Y))
  (AND ( Y (SHEET-INSIDE-TOP))
       (< Y (+ (SHEET-INSIDE-TOP) (* (SHEET-NUMBER-OF-INSIDE-LINES) LINE-HEIGHT)))
       (DOLIST (ITEM (SEND SELF ':MOUSE-SENSITIVE-ITEMS-FOR-LINE LINE-NO))
	 (AND (ITEM-MOUSE-SENSITIVE-P ITEM)
	      ( (DISPLAYED-ITEM-LEFT ITEM) X)	;And within this place on the line
	      (> (DISPLAYED-ITEM-RIGHT ITEM) X)
	      (RETURN (VALUES (DISPLAYED-ITEM-ITEM ITEM) (DISPLAYED-ITEM-TYPE ITEM)
			      (DISPLAYED-ITEM-LEFT ITEM) (DISPLAYED-ITEM-RIGHT ITEM)
			      (+ (SHEET-INSIDE-TOP) (* LINE-NO LINE-HEIGHT))))))))


(DEFMETHOD (:MOUSE-SENSITIVE-ITEM MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW-WITHOUT-CLICK) (X Y)
  (MOUSE-SENSITIVE-ITEM X Y))


(DEFFLAVOR MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW ()
	   (MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW-WITHOUT-CLICK))

(DEFMETHOD (:MOUSE-CLICK MOUSE-SENSITIVE-TEXT-SCROLL-WINDOW) (BUTTON X Y &AUX ITEM TYPE)
  (MULTIPLE-VALUE (ITEM TYPE) (SEND SELF ':MOUSE-SENSITIVE-ITEM X Y))
  (COND (TYPE
	 (SEND SELF ':FORCE-KBD-INPUT (LIST TYPE ITEM SELF BUTTON))
	 T)))

(DEFFLAVOR TEXT-SCROLL-WINDOW-EMPTY-GRAY-HACK () ()
  (:REQUIRED-FLAVORS TEXT-SCROLL-WINDOW)
  (:DOCUMENTATION :MIXIN "Text scroll window that is grayed when it has no items"))

(DEFUN-IN-FLAVOR (EMPTY-GRAY-HACK-DRAW-GRAY TEXT-SCROLL-WINDOW-EMPTY-GRAY-HACK) ()
  (UNLESS (PLUSP (ARRAY-ACTIVE-LENGTH ITEMS))
    (SEND SELF :DRAW-1-BIT-RASTER (SHEET-INSIDE-WIDTH) (SHEET-INSIDE-HEIGHT) 25%-GRAY 0 0 0 0
	  :DRAW COLOR:ALU-NOOP)))

(DEFMETHOD (:REDISPLAY TEXT-SCROLL-WINDOW-EMPTY-GRAY-HACK :AFTER) (START END)
  (IGNORE START END)
  (EMPTY-GRAY-HACK-DRAW-GRAY))

(DEFMETHOD (:INSERT-ITEM TEXT-SCROLL-WINDOW-EMPTY-GRAY-HACK :BEFORE) (&REST IGNORE)
  (OR (PLUSP (ARRAY-ACTIVE-LENGTH ITEMS))
      ;; We must have been gray -- erase ourselves
      (SEND SELF ':CLEAR-WINDOW)))

(DEFMETHOD (:DELETE-ITEM TEXT-SCROLL-WINDOW-EMPTY-GRAY-HACK :AFTER) (ITEM-NO)
  (IGNORE ITEM-NO)
  (EMPTY-GRAY-HACK-DRAW-GRAY))

;;;Fancy printing of an item
(DEFUN PRINT-ITEM-CONCISELY (ITEM STREAM &OPTIONAL (LEVEL 0))
  (TYPECASE ITEM
    (:LIST
     (COND ((EQ (CAR ITEM) 'QUOTE)
	    (SEND STREAM ':TYO #/')
	    (SEND STREAM ':ITEM (CADR ITEM) ':VALUE #'PRINT-ITEM-CONCISELY (1+ LEVEL)))
	   ((AND PRINLEVEL ( LEVEL PRINLEVEL))
	    (SEND STREAM ':STRING-OUT (SI:PTTBL-PRINLEVEL READTABLE)))
	   (T
	    (DO () ((OR (NLISTP ITEM) (NEQ (CAR ITEM) 'QUOTE)))
	      (SETQ ITEM (CADR ITEM)))
	    (SEND STREAM ':TYO (SI:PTTBL-OPEN-PAREN READTABLE))
	    (DO ((L ITEM (CDR L))
		 (FLAG NIL T)
		 (I 1 (1+ I)))
		((ATOM L)
		 (COND (L
			(SEND STREAM ':STRING-OUT (SI:PTTBL-CONS-DOT READTABLE))
			(SEND STREAM ':ITEM L ':VALUE #'PRINT-ITEM-CONCISELY (1+ LEVEL))))
		 (SEND STREAM ':TYO (SI:PTTBL-CLOSE-PAREN READTABLE)))
	      (AND FLAG (SEND STREAM ':TYO (SI:PTTBL-SPACE READTABLE)))
	      (SEND STREAM ':ITEM (CAR L) ':VALUE #'PRINT-ITEM-CONCISELY (1+ LEVEL))
	      (COND ((AND PRINLENGTH ( I PRINLENGTH))
		     (SEND STREAM ':STRING-OUT (SI:PTTBL-PRINLENGTH READTABLE))
		     (RETURN NIL)))))))
    (:COMPILED-FUNCTION
     (SEND STREAM ':STRING-OUT "#'")
     (PRIN1 (FUNCTION-NAME ITEM) STREAM))
    (:STRING
     ;; Some strings (i.e., LMFS data addressors) are really named structures.
     (IF (NAMED-STRUCTURE-P ITEM)
	 (PRIN1 ITEM STREAM)
	 (PRIN1 (IF (OR (AND ( LEVEL 0) (> (ARRAY-ACTIVE-LENGTH ITEM) 20.))
			(STRING-SEARCH-CHAR #\CR ITEM))
		    "..." ITEM)
		STREAM)))
    (OTHERWISE
     (PRIN1 ITEM STREAM))))

(DEFVAR GRIND-INTO-LIST-LIST)
(DEFVAR GRIND-INTO-LIST-STRING)
(DEFVAR GRIND-INTO-LIST-ITEMS-P)
(DEFVAR GRIND-INTO-LIST-ITEMS)
(DEFVAR GRIND-INTO-LIST-LIST-ITEMS)
(DEFVAR GRIND-INTO-LIST-LIST-ITEM-STACK)
(DEFVAR GRIND-INTO-LIST-LINE)

(EVAL-WHEN (COMPILE LOAD)
  (COMPILER:FUNCTION-DEFINED 'SI:GRIND-TOP-LEVEL))	; forward reference to Utilities
(DEFUN GRIND-INTO-LIST (EXP WIDTH &OPTIONAL ITEMS-P
			&AUX GRIND-INTO-LIST-LIST GRIND-INTO-LIST-STRING
			(GRIND-INTO-LIST-ITEMS-P ITEMS-P)
			(GRIND-INTO-LIST-ITEMS (NCONS NIL))
			GRIND-INTO-LIST-LIST-ITEMS
			GRIND-INTO-LIST-LIST-ITEM-STACK
			(GRIND-INTO-LIST-LINE 0))
  (SI:GRIND-TOP-LEVEL EXP WIDTH 'GRIND-INTO-LIST-IO NIL 'SI:DISPLACED T
		      (AND ITEMS-P 'GRIND-INTO-LIST-MAKE-ITEM) ':TOP-LEVEL)
  (GRIND-INTO-LIST-IO ':TYO #\CR)
  (PROG () (RETURN (VALUES (NREVERSE GRIND-INTO-LIST-LIST)
			   (NREVERSE GRIND-INTO-LIST-ITEMS)
			   GRIND-INTO-LIST-LIST-ITEMS))))

(DEFUN GRIND-INTO-LIST-IO (OP &OPTIONAL ARG1 &REST REST)
  (COND ((EQ OP ':WHICH-OPERATIONS) '(:TYO))
	((EQ OP ':TYO)
	 (COND ((CHAR-EQUAL ARG1 #\CR)
		(COND (GRIND-INTO-LIST-STRING
		       (PUSH GRIND-INTO-LIST-STRING GRIND-INTO-LIST-LIST)
		       (SETQ GRIND-INTO-LIST-LINE (1+ GRIND-INTO-LIST-LINE))
		       (AND GRIND-INTO-LIST-ITEMS-P
			    (PUSH NIL GRIND-INTO-LIST-ITEMS))))
		(SETQ GRIND-INTO-LIST-STRING (MAKE-ARRAY 50.
							 ':TYPE 'ART-FAT-STRING
							 ':LEADER-LENGTH 1))
		(SETF (FILL-POINTER GRIND-INTO-LIST-STRING) 0))
	       (T
		(ARRAY-PUSH-EXTEND GRIND-INTO-LIST-STRING ARG1))))
	(T
	 (STREAM-DEFAULT-HANDLER 'GRIND-INTO-LIST-IO OP ARG1 REST))))

(DEFUN GRIND-INTO-LIST-MAKE-ITEM (THING LOC ATOM-P)
  (LET ((IDX (IF GRIND-INTO-LIST-STRING
		 (ARRAY-ACTIVE-LENGTH GRIND-INTO-LIST-STRING)
		 0)))
    (COND (ATOM-P
	   ;; An atom -- make an item for it
	   (PUSH (LIST LOC ':LOCATIVE IDX (+ IDX (FLATSIZE THING)))
		 (CAR GRIND-INTO-LIST-ITEMS)))
	  (T
	   ;; Printing an interesting character
	   (SELECTOR THING CHAR-EQUAL
	     (#/(
	      ;; Start of a list
	      (PUSH (LIST LOC IDX GRIND-INTO-LIST-LINE NIL NIL)
		    GRIND-INTO-LIST-LIST-ITEM-STACK))
	     (#/)
	      ;; Closing a list
	      (LET ((ITEM (POP GRIND-INTO-LIST-LIST-ITEM-STACK)))
		;; 1+ is to account for close-paren which hasn't been typed yet
		(SETF (FOURTH ITEM) (1+ IDX))
		(SETF (FIFTH ITEM) GRIND-INTO-LIST-LINE)
		(PUSH ITEM GRIND-INTO-LIST-LIST-ITEMS))))))))

;;; Apparently not used any more.
#||
(DEFUN CONCISE-FLATSIZE (THING)
  (LET ((SI:*IOCH 0))
    (PRINT-ITEM-CONCISELY THING 'CONCISE-FLATSIZE-STREAM)
    SI:*IOCH))

(DEFPROP CONCISE-FLATSIZE-STREAM T SI:IO-STREAM-P)
(DEFUN CONCISE-FLATSIZE-STREAM (OP &OPTIONAL ARG1 &REST REST)
  (IF (EQ OP ':ITEM)
      (PRINT-ITEM-CONCISELY ARG1 'CONCISE-FLATSIZE-STREAM (THIRD REST))
      (LEXPR-FUNCALL #'SI:FLATSIZE-STREAM OP ARG1 REST)))

(DEFUN CONCISE-STRING (THING &OPTIONAL TRUNCATE-AT)
  "Prints thing concisely into a string.  Returns two values: the string, and
an item-list in the form: (object starting-position-in-string last-position-in-string)."
  (LET ((CONCISE-STRING (MAKE-ARRAY (OR TRUNCATE-AT 100.)
				    ':TYPE 'ART-STRING ':FILL-POINTER 0))
	(CONCISE-ITEMS NIL)
	(CONCISE-TRUNCATE TRUNCATE-AT))
    (DECLARE (SPECIAL CONCISE-STRING CONCISE-ITEMS CONCISE-TRUNCATE))
    (CATCH 'CONCISE-TRUNCATE
      (PRINT-ITEM-CONCISELY THING 'CONCISE-STRING-STREAM))
    (PROG () (RETURN CONCISE-STRING CONCISE-ITEMS))))

(DEFPROP CONCISE-STRING-STREAM T SI:IO-STREAM-P)
(DEFUN CONCISE-STRING-STREAM (OP &OPTIONAL ARG1 &REST REST)
  (DECLARE (SPECIAL CONCISE-STRING CONCISE-ITEMS CONCISE-TRUNCATE))
  (SELECTQ OP
    (:TYO
     (ARRAY-PUSH-EXTEND CONCISE-STRING ARG1)
     (AND CONCISE-TRUNCATE
	  ( (ARRAY-LEADER CONCISE-STRING 0) CONCISE-TRUNCATE)
	  (THROW 'CONCISE-TRUNCATE NIL)))
    (:WHICH-OPERATIONS '(:TYO))
    (:ITEM
     (LET ((ITEM (LIST ARG1 (ARRAY-LEADER CONCISE-STRING 0) CONCISE-TRUNCATE)))
       (PUSH ITEM CONCISE-ITEMS)
       (PRINT-ITEM-CONCISELY ARG1 'CONCISE-STRING-STREAM (THIRD REST))
       (SETF (THIRD ITEM) (ARRAY-LEADER CONCISE-STRING 0))))
    (T (STREAM-DEFAULT-HANDLER 'CONCISE-STRING-STREAM OP ARG1 REST))))
||#
