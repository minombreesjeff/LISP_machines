;;; -*- Mode: Lisp; Syntax: Zetalisp; Package: TV; Base: 10; Lowercase: T -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;--- The defflavor for GRAPHICS-MIXIN moved to DYNAMIC-WINDOW-FLAVORS

(defmethod (reset-dynamic-state graphics-mixin) ()
  ;; This rather than graphics::drawing-state-initialize, because it might be arbitrarily
  ;; munged.
  (setq graphics::drawing-state nil))

(defmethod (:physical-unit-scale-factor graphics-mixin) (unit)
  (cl:ecase unit
    (:meter (// 100 .0254))			;Nominal size; could get from sync program.
    (:line (send self :line-height))
    (:page (send self :inside-width))))

(defwhopper (graphics::with-scan-conversion-mode-internal graphics-mixin)
	    (continuation xstream &rest args &key sketch host-allowed &allow-other-keys)
  (let ((on (not (or host-allowed sketch)))
	(on-now (screen-genera-graphics-compatibility screen)))
    (if (eq on on-now)
	(lexpr-continue-whopper continuation xstream args)
	(unwind-protect
	    (progn
	      (setf (screen-genera-graphics-compatibility screen) on)
	      (lexpr-continue-whopper continuation xstream args))
	  (setf (screen-genera-graphics-compatibility screen) on-now)))))

(defmethod (:choose-attributes graphics-mixin) ()
  (list :set-graphics-scan-conversion-mode-internal
	(graphics::scan-conversion-mode-option
	  t graphics::(and drawing-state (drawing-state-scan-conversion-flags drawing-state))
	  :prompt "Graphics scan conversion")))

(defmethod (:set-graphics-scan-conversion-mode-internal graphics-mixin) (flag)
  (if (fixp flag)
      (setf (graphics::drawing-state-scan-conversion-flags (graphics::get-drawing-state self))
	    flag)
      (cl:apply #'graphics:set-scan-conversion-mode self flag)))

;;;; Points

(defmethod (:point graphics-mixin) (x y)
  (incf x (sheet-inside-left))
  (incf y (sheet-inside-top))
  (if (or (< x (sheet-inside-left)) ( x (sheet-inside-right))
	  (< y (sheet-inside-top)) ( y (sheet-inside-bottom)))
      0
      (prepare-sheet (self)
	(sheet-point x y))))

(defmethod (:draw-point graphics-mixin) (x y &optional (alu :draw) (value -1))
  (setf alu (graphics::standardize-alu self alu))
  (incf x (sheet-inside-left))
  (incf y (sheet-inside-top))
  (unless (or (< x (sheet-inside-left)) ( x (sheet-inside-right))
	      (< y (sheet-inside-top)) ( y (sheet-inside-bottom)))
    (prepare-sheet (self)
      (sheet-draw-point x y alu self value))))

;;;; Lines

(defun-in-flavor (draw-line-clip-visibility graphics-mixin) (point-x point-y &aux visibility)
  (destructuring-bind (clip-left clip-top clip-right clip-bottom) clipping-region
    (setq visibility (cond ((< point-x clip-left) 1)
			   (( point-x clip-right) 2)
			   (t 0)))
    (cond ((< point-y clip-top) (logior 4 visibility))
	  (( point-y clip-bottom) (logior 8 visibility))
	  (t visibility))))

;;; The following clipping function takes the inside window
;;; coordinates of a line and returns the multiple values FROM-X FROM-Y
;;; TO-X TO-Y which are the outside, clipped coordinates of the line.
(defmethod (clip-and-offset-line-internal graphics-mixin) (from-x from-y to-x to-y)
  (setq from-x (+ from-x (sheet-inside-left))	; add offsets
	from-y (+ from-y (sheet-inside-top))
	to-x (+ to-x (sheet-inside-left))
	to-y (+ to-y (sheet-inside-top)))
  (destructuring-bind (clip-left clip-top clip-right clip-bottom) clipping-region
    (do ((from-visibility (draw-line-clip-visibility from-x from-y)
			  (draw-line-clip-visibility from-x from-y))
	 (to-visibility (draw-line-clip-visibility to-x to-y))
	 (exchanged nil))
	;;When completely visible, return clipped points
	((and (zerop from-visibility) (zerop to-visibility))
	 (and exchanged (psetq from-x to-x to-x from-x from-y to-y to-y from-y))
	 (values from-x from-y to-x to-y))	; actually returns the points
      ;;If all off the screen, return NIL as a flag
      (or (zerop (logand from-visibility to-visibility)) (return nil))
      ;;Exchange points to try to make to point visible
      (and (zerop from-visibility)
	   (psetq from-x to-x to-x from-x from-y to-y to-y from-y
		  from-visibility to-visibility to-visibility from-visibility
		  exchanged (not exchanged)))
      ;;If TO-X = FROM-X then FROM-VISIBILITY = 0, 4 or 8 so there is no danger
      ;; of divide by zero in the next "Push"
      (cond ((ldb-test (byte 1 0) from-visibility)	;Push toward left edge
	     (setq from-y (+ from-y (// (* (- to-y from-y) (- clip-left from-x))
					(- to-x from-x)))
		   from-x clip-left))
	    ((ldb-test (byte 1 1) from-visibility)	;Push toward right edge
	     (setq from-y (+ from-y (// (* (- to-y from-y) (- clip-right from-x 1))
					(- to-x from-x)))
		   from-x (1- clip-right))))
      (cond ((ldb-test (byte 1 2) from-visibility)	;Push toward top
	     ;;It is possible that TO-Y = FROM-Y at this point because of the effects of
	     ;; the last "Push", but in that case TO-X is probably equal to FROM-X as well
	     ;; (or at least close to it) so we needn't draw anything:
	     (and (= to-y from-y) (return nil))
	     (setq from-x (+ from-x (// (* (- to-x from-x) (- clip-top from-y))
					(- to-y from-y)))
		   from-y clip-top))
	    ((ldb-test (byte 1 3) from-visibility)	;Push toward bottom
	     ;; Same:
	     (and (= to-y from-y) (return nil))
	     (setq from-x (+ from-x (// (* (- to-x from-x) (- clip-bottom from-y 1))
					(- to-y from-y)))
		   from-y (1- clip-bottom)))))))

(defsubst-in-flavor (clip-and-offset-line graphics-mixin) (from-x from-y to-x to-y)
  (clip-and-offset-line-internal self from-x from-y to-x to-y))

(DEFMETHOD (:DRAW-LINE GRAPHICS-MIXIN) (FROM-X FROM-Y TO-X TO-Y
					&OPTIONAL (ALU :DRAW) (DRAW-END-POINT T))
  (SETF ALU (GRAPHICS::STANDARDIZE-ALU SELF ALU))
  (MULTIPLE-VALUE (FROM-X FROM-Y TO-X TO-Y)	; clip and offset the line to
    (CLIP-AND-OFFSET-LINE FROM-X FROM-Y TO-X TO-Y))	; screen coordinates
  (COND
    (FROM-X					; is the line visible at all?
     (PREPARE-SHEET (SELF)			; yes
	 (SHEET-DRAW-LINE FROM-X FROM-Y TO-X TO-Y ALU DRAW-END-POINT SELF)))))


(DEFUN-IN-FLAVOR (DRAW-DASHED-LINE-INTERNAL GRAPHICS-MIXIN)
		 (START-X START-Y END-X END-Y
			  X-SPACING Y-SPACING X-LENGTH Y-LENGTH N-SEGS ALU)
  (WHEN (> N-SEGS 0)
    (PREPARE-SHEET (SELF)
      (WITH-STACK-ARRAY (COORDS (* (1- N-SEGS) 4) :TYPE 'ART-16B)
	(DECLARE (SYS:ARRAY-REGISTER COORDS))
	(LOOP WITH IDX = 0
	      FOR X FROM (FLOAT START-X) BY X-SPACING
	      FOR Y FROM (FLOAT START-Y) BY Y-SPACING
	      FOR I FROM 1 TO N-SEGS
	      DO
	  (COND ((EQL I N-SEGS)
		 D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");before the last line, draw all the previous in one whack 
0		 (SEND SCREEN :%DRAW-MULTIPLE-LINES SELF ALU COORDS NIL)
		 (SHEET-DRAW-LINE (ROUND X) (ROUND Y)
				  (IF (< START-X END-X)
				      (MIN END-X (ROUND (+ X X-LENGTH)))
				      (MAX END-X (ROUND (+ X X-LENGTH))))
				  (IF (< START-Y END-Y)
				      (MIN END-Y (ROUND (+ Y Y-LENGTH)))
				      (MAX END-Y (ROUND (+ Y Y-LENGTH))))
				  ALU T SELF)
		 )
		(T
		 (SETF (AREF COORDS IDX)(ROUND X))
		 (INCF IDX)
		 (SETF (AREF COORDS IDX) (ROUND Y))
		 (INCF IDX)
		 (SETF (AREF COORDS IDX) (ROUND (+ X X-LENGTH)))
		 (INCF IDX)
		 (SETF (AREF COORDS IDX) (ROUND (+ Y Y-LENGTH)))
		 (INCF IDX))))))))


;;; Modified 1985-07-16, BIM: take null of optionals as "take-default"
;;; pass all the arguments to DRAW-DASHED-LINE-INTERNAL
;;;
(DEFMETHOD (:DRAW-DASHED-LINE GRAPHICS-MIXIN)
	   (FROM-X FROM-Y TO-X TO-Y
		   &OPTIONAL ALU DASH-SPACING
		   SPACE-LITERALLY-P OFFSET DASH-LENGTH)
  (SETF ALU (GRAPHICS::STANDARDIZE-ALU SELF (OR ALU :DRAW)))
  (WHEN (NULL DASH-SPACING) (SETQ DASH-SPACING 20.))
  (WHEN (NULL OFFSET) (SETQ OFFSET 0))
  (WHEN (NULL DASH-LENGTH) (SETQ DASH-LENGTH (// DASH-SPACING 2)))
  (SETQ OFFSET (MOD OFFSET DASH-SPACING))
  (MULTIPLE-VALUE (FROM-X FROM-Y TO-X TO-Y)	; clip the line and offset 
    (CLIP-AND-OFFSET-LINE FROM-X FROM-Y TO-X TO-Y))	; to screen coords
  (COND
    (FROM-X					; if this isn't NIL 
     (LET* ((LWIDTH (- TO-X FROM-X))		; (meaning line is completely invisible)
	    (LHEIGHT (- TO-Y FROM-Y))
	    (LENGTH (ISQRT (+ (^ LWIDTH 2) (^ LHEIGHT 2)))))
       (COND ((NOT SPACE-LITERALLY-P)
	      ;; We want to draw line segments such that the last one ends up
	      ;; finishing at the end-point.  Therefore, separate the entire
	      ;; line length into an odd number of regions, each half of the
	      ;; dash-spacing, and fill in every other one with a line segment.
	      ;; Just use dash-spacing to decide how many segments, so the
	      ;; spacing may not be quite right.
	      (LET* ((N-HALF-SEGS (LOGIOR 1 (ROUND (// LENGTH (// DASH-SPACING 2)))))
		     (X-LEN (// (FLOAT LWIDTH) N-HALF-SEGS))
		     (Y-LEN (// (FLOAT LHEIGHT) N-HALF-SEGS)))
		(DRAW-DASHED-LINE-INTERNAL 
		  FROM-X FROM-Y
		  TO-X TO-Y
		  (* 2 X-LEN) (* 2 Y-LEN)
		  X-LEN Y-LEN
		  (1+ (// N-HALF-SEGS 2)) ALU)))	; N-HALF-SEGS is odd, so add 1
	     (T
	      ;; Don't worry about where it ends.  Compute the x and y components and
	      ;; just draw dashes of the exact specified size.
	      (LET* ((FLOAT-LENGTH (SQRT (+ (^ LWIDTH 2) (^ LHEIGHT 2))))
		     (X-COMPONENT (IF (= 0 FLOAT-LENGTH) 0 (// LWIDTH FLOAT-LENGTH)))
		     (Y-COMPONENT (IF (= 0 FLOAT-LENGTH) 0 (// LHEIGHT FLOAT-LENGTH))))
		(DRAW-DASHED-LINE-INTERNAL
		  (+ FROM-X (* OFFSET X-COMPONENT))
		  (+ FROM-Y (* OFFSET Y-COMPONENT))
		  TO-X
		  TO-Y
		  (* DASH-SPACING X-COMPONENT)
		  (* DASH-SPACING Y-COMPONENT)
		  (* DASH-LENGTH X-COMPONENT)
		  (* DASH-LENGTH Y-COMPONENT)
		  (CEILING (// (- FLOAT-LENGTH OFFSET) DASH-SPACING))
		  ALU))))))))

;;; This is like the above, but it returns the longest line that can be drawn correctly by
;;; the microcode, which does not clip, and which has the correct slope.  It also returns
;;; the two little lines that overlap the edge which cannot be drawn with the microcode
;;; and which complete the shape.
(defun-in-flavor (clip-and-offset-line-correct-slope graphics-mixin)
		 (from-x from-y to-x to-y draw-end-point)
  (declare (values clipped-outside-from-x clipped-outside-from-y
		   clipped-outside-to-x clipped-outside-to-y
		   draw-end-point
		   from-additional-point-x from-additional-point-y
		   to-additional-point-x to-additional-point-y))
  (setq from-x (+ from-x (sheet-inside-left))	; add offsets
	from-y (+ from-y (sheet-inside-top))
	to-x (+ to-x (sheet-inside-left))
	to-y (+ to-y (sheet-inside-top)))
  (let ((from-visibility (draw-line-clip-visibility from-x from-y))
	(to-visibility (draw-line-clip-visibility to-x to-y)))
    (when (and (zerop from-visibility) (zerop to-visibility))
      ;; First check quickly for being all inside the window and return.
      (return-from clip-and-offset-line-correct-slope
	(values from-x from-y to-x to-y draw-end-point)))
    ;; If all off the screen, return NIL as a flag.
    (unless (zerop (logand from-visibility to-visibility))
      (return-from clip-and-offset-line-correct-slope nil))
    (let ((slope-x (- to-x from-x))
	  (slope-y (- to-y from-y))
	  (original-from-x from-x) (original-from-y from-y)
	  (original-to-x to-x) (original-to-y to-y)
	  (draw-from t) (draw-to draw-end-point)
	  (from-correction nil)
	  (to-correction nil))
      ;; Compute the smallest congruent unit of the line.  We can only use the microcode
      ;; to draw as many of these as intersect the window.
      (if (and (zerop slope-x) (zerop slope-y))
	  (setq slope-x 1 slope-y 1)
	  (let ((m (abs (\\ slope-x slope-y))))
	    (setq slope-x (// slope-x m)
		  slope-y (// slope-y m))))
      (destructuring-bind (clip-left clip-top clip-right clip-bottom) clipping-region
	(let ((exchanged nil)
	      ;; If the line is x-major, when clipping at the top or bottom we may still
	      ;; have some more on the same scan line from the next fundamental unit and
	      ;; therefore need macrocode to draw that.
	      (x-major (> (abs slope-x) (abs slope-y)))
	      (y-major (> (abs slope-y) (abs slope-x))))
	  (loop doing
	    (setq from-visibility (draw-line-clip-visibility from-x from-y))
	    (when (and (zerop from-visibility) (zerop to-visibility))
	      (return))
	    (unless (zerop (logand from-visibility to-visibility))
	      (return))
	    ;;Exchange points to try to make to point visible
	    (when (zerop from-visibility)
	      (psetq from-x to-x to-x from-x from-y to-y to-y from-y
		     from-visibility to-visibility to-visibility from-visibility
		     slope-x (- slope-x) slope-y (- slope-y)
		     draw-from draw-to draw-to draw-from
		     from-correction to-correction to-correction from-correction
		     exchanged (not exchanged)))
	    (setq draw-from t)
	    (cond ((ldb-test (byte 1 0) from-visibility)	;Push toward left edge
		   (multiple-value-bind (n r) (ceiling (- clip-left from-x) slope-x)
		     (incf from-x (* n slope-x))
		     (incf from-y (* n slope-y))
		     (unless (and (zerop r) (not y-major))
		       (setq from-correction t))))
		  ((ldb-test (byte 1 1) from-visibility)	;Push toward right edge
		   (multiple-value-bind (n r) (ceiling (- clip-right from-x 1) slope-x)
		     (incf from-x (* n slope-x))
		     (incf from-y (* n slope-y))
		     (unless (and (zerop r) (not y-major))
		       (setq from-correction t)))))
	    (cond ((ldb-test (byte 1 2) from-visibility)	;Push toward top
		   (multiple-value-bind (n r) (ceiling (- clip-top from-y) slope-y)
		     (incf from-x (* n slope-x))
		     (incf from-y (* n slope-y))
		     (unless (and (zerop r) (not x-major))
		       (setq from-correction t))))
		  ((ldb-test (byte 1 3) from-visibility)	;Push toward bottom
		   (multiple-value-bind (n r) (ceiling (- clip-bottom from-y 1) slope-y)
		     (incf from-x (* n slope-x))
		     (incf from-y (* n slope-y))
		     (unless (and (zerop r) (not x-major))
		       (setq from-correction t))))))
	  (when exchanged
	    (psetq from-x to-x to-x from-x from-y to-y to-y from-y
		   slope-x (- slope-x) slope-y (- slope-y)
		   draw-from draw-to draw-to draw-from
		   from-correction to-correction to-correction from-correction))))
      (if (and (not from-correction) (not to-correction))
	  ;; No extras necessary.  Return visible part, if any.
	  (when (and (zerop from-visibility) (zerop to-visibility))
	    (values from-x from-y to-x to-y draw-to))
	  (let ((corrected-from-x (- from-x slope-x))
		(corrected-from-y (- from-y slope-y))
		(corrected-to-x (+ to-x slope-x))
		(corrected-to-y (+ to-y slope-y)))
	    (unless from-correction
	      (setq corrected-from-x nil corrected-from-y nil))
	    (unless to-correction
	      (setq corrected-to-x nil corrected-to-y nil))
	    (if (and (zerop from-visibility) (zerop to-visibility))
		(values from-x from-y to-x to-y draw-to
			corrected-from-x corrected-from-y corrected-to-x corrected-to-y)
		;; Hardest case, microcode cannot help.  Must use macrocode for whole thing.
		;; This can do useless work in the case (unusual in practice, majority by
		;; number theory) of far above to far to the right, e.g.  We could check
		;; for the line intersection the clipping region at all.  This would be
		;; done by inspecting the original visibilities.  1,2 or 4,8 must intersect.
		;; Otherwise, check which side of the line the corresponding corner(s) of the
		;; clipping region is(are) on.
		(values nil nil nil nil draw-end-point
			original-from-x original-from-y original-to-x original-to-y)))))))

(defmethod (graphics::draw-scaled-line graphics-mixin)
	   (from-x from-y to-x to-y &optional (alu :draw) (draw-end-point t))
  (setf alu (graphics::standardize-alu self alu))
  (cond ((= from-y to-y)
	 (destructuring-bind (clip-left clip-top clip-right clip-bottom) clipping-region
	   (let ((y (+ from-y (tv:sheet-inside-top))))
	     (when (and ( y clip-top) (< y clip-bottom))
	       (multiple-value-bind (left right)
		   (if (> to-x from-x)
		       (values from-x (if draw-end-point (1+ to-x) to-x))
		       (values (if draw-end-point to-x (1+ to-x)) (1+ from-x)))
		 (setq left (max (+ left (tv:sheet-inside-left)) clip-left))
		 (setq right (min (+ right (tv:sheet-inside-left)) clip-right))
		 (when (> right left)
		   (prepare-sheet (self)
		     (sheet-draw-rectangle (- right left) 1 left y alu self)))))))
	 (return-from graphics::draw-scaled-line))
	#+no-good	;Slower this way.
	((= from-x to-x)
	 (destructuring-bind (clip-left clip-top clip-right clip-bottom) clipping-region
	   (let ((x (+ from-x (tv:sheet-inside-left))))
	     (when (and ( x clip-left) (< x clip-right))
	       (multiple-value-bind (top bottom)
		   (if (> to-y from-y)
		       (values from-y (if draw-end-point (1+ to-y) to-y))
		       (values (if draw-end-point to-y (1+ to-y)) (1+ from-y)))
		 (setq top (max (+ top (tv:sheet-inside-top)) clip-top))
		 (setq bottom (min (+ bottom (tv:sheet-inside-top)) clip-bottom))
		 (when (> bottom top)
		   (prepare-sheet (self)
		     (sheet-draw-rectangle 1 (- bottom top) x top alu self)))))))
	 (return-from graphics::draw-scaled-line)))
  (let (from-extra-x from-extra-y to-extra-x to-extra-y)
    (multiple-value (from-x from-y to-x to-y draw-end-point
		     from-extra-x from-extra-y to-extra-x to-extra-y)
      ;; Compute the portion that can be drawn by microcode, and leftovers.
      (clip-and-offset-line-correct-slope from-x from-y to-x to-y draw-end-point))
    (when (or from-x from-extra-x to-extra-x)	;Anything visible at all?
      (prepare-sheet (self)
	(when from-x
	  ;; Draw the part that the microcode can correctly.
	  (sheet-draw-line from-x from-y to-x to-y alu draw-end-point self))
	(when (or from-extra-x to-extra-x)
	  (destructuring-bind (clip-left clip-top clip-right clip-bottom) clipping-region
	    (flet ((slice (width height x y)
		     (when (< x clip-left)
		       (decf width (- clip-left x))
		       (setq x clip-left))
		     (when (< y clip-top)
		       (decf height (- clip-top y))
		       (setq y clip-top))
		     (setq width (min width (max 0 (- clip-right x)))
			   height (min height (max 0 (- clip-bottom y))))
		     (when (and (plusp width) (plusp height))
		       (sheet-draw-rectangle width height x y alu))))
	      (if (not from-x)
		  ;; Worst case: coprime dx and dy outside of the window.  There is no
		  ;; microcoded line at all which overlaps even part of this line correctly.
		  ;; Have to do the whole thing by hand.
		  (graphics:draw-line-driver from-extra-x from-extra-y to-extra-x to-extra-y
					     draw-end-point #'slice)
		;; More normal case, just a couple of little leftovers at the ends if going
		;; outside the window.
		(when from-extra-x
		  (graphics:draw-line-driver from-extra-x from-extra-y from-x from-y
					     nil #'slice))
		(when to-extra-x
		  (graphics:draw-line-driver to-extra-x to-extra-y to-x to-y
					     nil #'slice))))))))))

(defwhopper-subst (graphics::draw-thick-lines-scaled graphics-mixin) (&rest args)
  (prepare-sheet (self)
    (lexpr-continue-whopper args)))

;;;; Triangles.

;;; Clipping is done in the actual triangle loop (in microcode), because
;;; you cannot clip the three coordiates and still get a triangle.
(defmethod (:draw-triangle graphics-mixin) (x1 y1 x2 y2 x3 y3 &optional (alu :draw))
  (setf alu (graphics::standardize-alu self alu))
  (prepare-sheet (self)
    (lexpr-send screen :%draw-triangle
		(+ x1 (sheet-inside-left)) (+ y1 (sheet-inside-top))
		(+ x2 (sheet-inside-left)) (+ y2 (sheet-inside-top))
		(+ x3 (sheet-inside-left)) (+ y3 (sheet-inside-top))
		alu self clipping-region)))

;;; Handles cases the microcode does not.
(defmethod (:draw-fractional-triangle graphics-mixin) 
	   (x1 y1 x2 y2 x3 y3 &optional (alu :draw) xmin ymin xmax ymax)
  (setf alu (graphics::standardize-alu self alu))
  (destructuring-bind (clip-left clip-top clip-right clip-bottom) clipping-region
    (setq xmin (if xmin (+ xmin (sheet-inside-left)) clip-left)
	  ymin (if ymin (+ ymin (sheet-inside-top)) clip-top)
	  xmax (if xmax (+ xmax (sheet-inside-left)) clip-right)
	  ymax (if ymax (+ ymax (sheet-inside-top)) clip-bottom)))
  (prepare-sheet (self)
    (graphics:draw-triangle-driver
      x1 y1 x2 y2 x3 y3
      (if (macrolet ((ok (x y)
		       `(and (let ((adj-x (+ ,x (sheet-inside-left))))
			       (and ( xmin adj-x) (< adj-x xmax)))
			     (let ((adj-y (+ ,y (sheet-inside-top))))
			       (and ( ymin adj-y) (< adj-y ymax))))))
	    (and (ok x1 y1) (ok x2 y2) (ok x3 y3)))
	  #'(lambda (width height x y)
	      (declare (downward-function))
	      (cond ((or (zerop width) (zerop height)) )
		    ((and (= width 1) (= height 1))
		     (sheet-draw-point (+ x (sheet-inside-left)) (+ y (sheet-inside-top)) alu))
		    (t
		     (sheet-draw-rectangle width height
					   (+ x (sheet-inside-left)) (+ y (sheet-inside-top))
					   alu))))
	  #'(lambda (width height x y)
	      (declare (downward-function))
	      (let ((from-x 0)
		    (from-y 0))
		(incf x (sheet-inside-left)) (incf y (sheet-inside-top))
		(clip-for-bitblt width height from-x from-y x y xmin ymin xmax ymax)
		(sheet-draw-rectangle width height x y alu)))))))

;;; Pattern-left,-top is the offset that would be applied to 0,0.
(defmethod (:draw-patterned-triangle graphics-mixin)
	   (x1 y1 x2 y2 x3 y3 pattern
	    &optional (ones-alu :draw) (zeros-alu :erase)
		      (pattern-left x1) (pattern-top y1)
		      xmin ymin xmax ymax)
  (setf ones-alu (graphics::standardize-alu self ones-alu))
  (setf zeros-alu (graphics::standardize-alu self zeros-alu))
  (destructuring-bind (clip-left clip-top clip-right clip-bottom) clipping-region
    (setq xmin (if xmin (+ xmin (sheet-inside-left)) clip-left)
	  ymin (if ymin (+ ymin (sheet-inside-top)) clip-top)
	  xmax (if xmax (+ xmax (sheet-inside-left)) clip-right)
	  ymax (if ymax (+ ymax (sheet-inside-top)) clip-bottom)))
  (prepare-sheet (self)
    (graphics:draw-triangle-driver
      x1 y1 x2 y2 x3 y3
      #'(lambda (width height x y)
	  (let ((from-x (round (+ (- x x1) pattern-left)))
		(from-y (round (+ (- y y1) pattern-top))))
	    (incf x (sheet-inside-left)) (incf y (sheet-inside-top))
	    (clip-for-bitblt width height from-x from-y x y xmin ymin xmax ymax)
	    (sheet-draw-1-bit-raster width height pattern
				     from-x from-y nil x y
				     ones-alu zeros-alu))))))

(defmethod (:draw-raster graphics-mixin) (width height pattern left top
						&optional (pattern-left 0) (pattern-top 0)
									   (alu tv:alu-seta))
  (cl:setf alu (graphics::standardize-alu self alu))
  (incf left (sheet-inside-left)) (incf top (sheet-inside-top))
  (destructuring-bind (clip-left clip-top clip-right clip-bottom) clipping-region
    (clip-for-bitblt width height pattern-left pattern-top left top 
		     clip-left clip-top clip-right clip-bottom))
  (when (and (> width 0) (> height 0))
    (prepare-sheet (self)
      (sheet-bitblt alu width height pattern pattern-left pattern-top nil left top))))

(defmethod (:draw-patterned-rectangle graphics-mixin)
	   (width height left top pattern
		  &optional (ones-alu :draw) (zeros-alu :erase)
			    (pattern-left left) (pattern-top top))
  (cl:setf ones-alu (graphics::standardize-alu self ones-alu)
	   zeros-alu (graphics::standardize-alu self zeros-alu))
  (incf left (sheet-inside-left)) (incf top (sheet-inside-top))
  (destructuring-bind (clip-left clip-top clip-right clip-bottom) clipping-region
    (clip-for-bitblt width height pattern-left pattern-top left top 
		     clip-left clip-top clip-right clip-bottom))
  (when (and (> width 0) (> height 0))
    (prepare-sheet (self)
      (sheet-draw-1-bit-raster width height pattern pattern-left pattern-top nil
			       left top ones-alu zeros-alu))))

(defmethod (:draw-tiled-triangle graphics-mixin)
	   (x1 y1 x2 y2 x3 y3 pattern &optional (alu :draw)
						(pattern-left x1) (pattern-top y1)
						xmin ymin xmax ymax)
  (setf alu (graphics::standardize-alu self alu))
  (destructuring-bind (clip-left clip-top clip-right clip-bottom) clipping-region
    (setq xmin (if xmin (+ xmin (sheet-inside-left)) clip-left)
	  ymin (if ymin (+ ymin (sheet-inside-top)) clip-top)
	  xmax (if xmax (+ xmax (sheet-inside-left)) clip-right)
	  ymax (if ymax (+ ymax (sheet-inside-top)) clip-bottom)))
  (prepare-sheet (self)
    (graphics:draw-triangle-driver
      x1 y1 x2 y2 x3 y3
      #'(lambda (width height x y)
	  (let ((from-x (round (+ (- x x1) pattern-left)))
		(from-y (round (+ (- y y1) pattern-top))))
	    (incf x (sheet-inside-left)) (incf y (sheet-inside-top))
	    (clip-for-bitblt width height from-x from-y x y xmin ymin xmax ymax)
	    (sheet-bitblt alu width height pattern from-x from-y nil x y))))))

(defmethod (:draw-tiled-rectangle graphics-mixin)
	   (width height left top pattern
		  &optional (alu :draw) (pattern-left left) (pattern-top top))
  (setf alu (graphics::standardize-alu self alu))
  (incf left (sheet-inside-left)) (incf top (sheet-inside-top))
  (destructuring-bind (clip-left clip-top clip-right clip-bottom) clipping-region
    (clip-for-bitblt width height pattern-left pattern-top left top 
		     clip-left clip-top clip-right clip-bottom))
  (when (and (> width 0) (> height 0))
    (prepare-sheet (self)
      (sheet-bitblt alu width height pattern pattern-left pattern-top nil left top))))

(defwhopper (graphics::draw-simply-scaled-image graphics-mixin)
	    (image x y scale-x scale-y
	     pattern ones-alu zeros-alu opaque
	     image-left image-top image-right image-bottom)
  (destructuring-bind (clip-left clip-top clip-right clip-bottom) clipping-region
    ;; Convert to outside coordinates.
    (decf clip-left (tv:sheet-inside-left)) (decf clip-right (tv:sheet-inside-left))
    (decf clip-top (tv:sheet-inside-top)) (decf clip-bottom (tv:sheet-inside-top))
    ;; Clip within visible range, since individual draws will do that also.
    (let ((width (- image-right image-left)))
      (cond ((plusp scale-x)
	     (when (< x clip-left)
	       (let ((diff (floor (- clip-left x) scale-x)))
		 (incf image-left diff)
		 (decf width diff)
		 (incf x (* diff scale-x))))
	     (when ( (+ x (* width scale-x)) clip-right)
	       (setq image-right (+ image-left (ceiling (- clip-right x) scale-x)))))
	    (t
	     (when ( x clip-right)
	       (let ((diff (floor (- x clip-right) (- scale-x))))
		 (incf image-left diff)
		 (decf width diff)
		 (incf x (* diff scale-x))))
	     (when (< (+ x (* width scale-x)) clip-left)
	       (setq image-right (+ image-left (ceiling (- x clip-left) (- scale-x))))))))
    (let ((height (- image-bottom image-top)))
      (cond ((plusp scale-y)
	     (when (< y clip-top)
	       (let ((diff (floor (- clip-top y) scale-y)))
		 (incf image-top diff)
		 (decf height diff)
		 (incf y (* diff scale-y))))
	     (when ( (+ y (* height scale-y)) clip-bottom)
	       (setq image-bottom (+ image-top (ceiling (- clip-bottom y) scale-y)))))
	    (t
	     (when ( y clip-bottom)
	       (let ((diff (floor (- y clip-bottom) (- scale-y))))
		 (incf image-top diff)
		 (decf height diff)
		 (incf y (* diff scale-y))))
	     (when (< (+ y (* height scale-y)) clip-top)
	       (setq image-bottom (+ image-top (ceiling (- y clip-top) (- scale-y))))))))
    (prepare-sheet (self)
      (continue-whopper image x y scale-x scale-y
			pattern ones-alu zeros-alu opaque
			image-left image-top image-right image-bottom))))

;;;; Circles and ellipses

;;; Very special kludgey macro for :DRAW-CIRCLE.
(defmacro draw-clipped-point-cached (x-form y-form)
  `(progn
     (setq x-val ,x-form
	   y-val ,y-form)
     (or (< x-val il) ( x-val ir)
	 (< y-val it) ( y-val ib)
	 (if (arrayp array)
	     (%draw-point x-val y-val alu array)
	     (sheet-draw-cached alu (%draw-point x-val y-val alu self))))))

(defun cached-draw-rectangle-clipped
       (width height x-bitpos y-bitpos alu-function array
	inside-left inside-top inside-right inside-bottom)

  (when (< x-bitpos inside-left)
       (setq width (- width (- inside-left x-bitpos))
	     x-bitpos inside-left))
  (when (< y-bitpos inside-top)
    (setq height (- height (- inside-top y-bitpos))
	  y-bitpos inside-top))
  (setq width (min width (max 0 (- inside-right x-bitpos))))
  (setq height (min height (max 0 (- inside-bottom y-bitpos))))
  (when (and (plusp width) (plusp height))
    (%draw-rectangle width height x-bitpos y-bitpos alu-function array)))

;;; The general method of drawing all these circles and pieces of circles is the algorithm
;;; in Hakmem item #177.  It is generally applied over just the first octant and reflected
;;; around for the seven other points.

;;; f is x^2 + y^2 - r^2 and is therefore a measurement of the error of the current
;;; point the test for f > x works for the following reason :  we are trying to tell
;;; whether decrementing x would give a point with smaller error than the current
;;; error.  The error for the point at the same y and with x one smaller is different
;;; from the current error by -2x + 1.  So at the point where f exceeds x we can
;;; guarantee that the other point will have an error which is just smaller than our
;;; current error.

;;; The below methods use the cached alu feature to speed things up on the color
;;; screen.  The -internal methods therefore do not prepare the sheet, and must be
;;; called from within the other method.

(DEFMETHOD (:DRAW-CIRCLE GRAPHICS-MIXIN)
	   (CENTER-X CENTER-Y RADIUS &OPTIONAL (ALU :draw))
  (setf alu (graphics::standardize-alu self alu))
  (PREPARE-SHEET (SELF)
    (LET ((IL (SHEET-INSIDE-LEFT))
	  (IT (SHEET-INSIDE-TOP)))
      (SEND SCREEN ':WITH-ALU-CACHED-SOURCE SELF ALU
	    ':DRAW-CIRCLE-INTERNAL (+ CENTER-X IL) (+ CENTER-Y IT) RADIUS
	    IL IT
	    (SHEET-INSIDE-RIGHT)
	    (SHEET-INSIDE-BOTTOM)))))

;;; Warning:  This does not do a prepare sheet!  It should only be called on a prepared sheet
(DEFMETHOD (:DRAW-CIRCLE-INTERNAL GRAPHICS-MIXIN)
	   (ALU ARRAY CENTER-X CENTER-Y RADIUS IL IT IR IB)  
  (IF (= RADIUS 0)      
      (LET (X-VAL Y-VAL)
	(DRAW-CLIPPED-POINT-CACHED CENTER-X  CENTER-Y))      
      (DO ((Y 0)
	   (F 0)				; F is just Y squared without any multiplies
	   (X-VAL) (Y-VAL)
	   (X RADIUS))
	  (NIL)
	(DRAW-CLIPPED-POINT-CACHED (+ CENTER-X X) (- CENTER-Y Y))
	(DRAW-CLIPPED-POINT-CACHED (- CENTER-X X) (+ CENTER-Y Y))
	(DRAW-CLIPPED-POINT-CACHED (+ CENTER-X Y) (+ CENTER-Y X))
	(DRAW-CLIPPED-POINT-CACHED (- CENTER-X Y) (- CENTER-Y X))
	(SETQ F (+ F Y Y 1) Y (1+ Y))
	(COND (( F X) (SETQ F (- F X X -1) X (- X 1))))
	(COND ((> Y X) (RETURN T)))
	(DRAW-CLIPPED-POINT-CACHED (+ CENTER-X X) (+ CENTER-Y Y))
	(DRAW-CLIPPED-POINT-CACHED (- CENTER-X X) (- CENTER-Y Y))
	(DRAW-CLIPPED-POINT-CACHED (+ CENTER-X Y) (- CENTER-Y X))
	(DRAW-CLIPPED-POINT-CACHED (- CENTER-X Y) (+ CENTER-Y X))
	(COND ((= Y X) (RETURN T))))))

;;;+++ Too bad the :WITH-ALU-CACHED[-SOURCE] mechanism doesn't take a funarg instead of
;;;a message.
(defmethod (graphics::draw-scaled-circle graphics-mixin)
	   (center-x center-y radius &optional (alu :draw) ignore)
  (setf alu (graphics::standardize-alu self alu))
  (prepare-sheet (self)
    (lexpr-send screen :with-alu-cached-source self alu
		:draw-scaled-circle-internal
		(+ center-x (sheet-inside-left)) (+ center-y (sheet-inside-top)) radius
		clipping-region)))

(defmethod (:draw-scaled-circle-internal graphics-mixin)
	   (alu array center-x center-y radius il it ir ib)
  (graphics:draw-unfilled-circle-driver center-x center-y radius
    #'(lambda (x y &aux x-val y-val) (draw-clipped-point-cached x y))))


;;
;; Draw an annular ring, with CENTER-X, CENTER-Y as its center and radii MINOR-RADIUS
;; and MAJOR-RADIUS.  Either of the radus may be smaller.
;;
;; DRAW-RING has the same footprint as DRAW-FILLED-IN-CIRCLE
;; Drawing rings with stepped radii exactly fill a circle, so 
;;  :DRAW-RING x y 10 20  followed by :DRAW-RING x y 20 30
;; is the same as :DRAW-RING x y 10 30
;;

(defresource circular-arc-array ()
  :constructor (make-array '(2 8)))

;;; An even more very special kludge for DRAW-CIRCULAR-ARC
(defmacro draw-clipped-octant-point-cached (i x-form y-form)
  `(when (not (eq reverse-sense			;lisp predicate XOR
		  (and ( k (aref limit-arr 0 ,i))
		       ( k (aref limit-arr 1 ,i)))))
     (draw-clipped-point-cached ,x-form ,y-form)))

;;; A circular arc drawing primitive -- draw part of a circle boundary between the
;;; two arguments.
;;; Reduce the radian angles start-theta and end-theta mod 2, then
;;; draw counter-clockwise from start-theta to end-theta.
;;; Note that the measure of the angles agrees with ATAN.  Since Y goes down the screen,
;;; this means that theta=pi/2 points that way too.

(DEFMETHOD (:DRAW-CIRCULAR-ARC GRAPHICS-MIXIN) (CENTER-X CENTER-Y RADIUS START-THETA END-THETA
							 &OPTIONAL (ALU :draw))
  (setf alu (graphics::standardize-alu self alu))
  (PREPARE-SHEET (SELF)
   (LET ((IL (SHEET-INSIDE-LEFT))
	 (IT (SHEET-INSIDE-TOP)))
    (SEND SCREEN ':WITH-ALU-CACHED-SOURCE SELF ALU
	  ':DRAW-CIRCULAR-ARC-CACHED-INTERNAL (+ IL CENTER-X) (+ IT CENTER-Y) RADIUS
	  START-THETA END-THETA
	  IL IT
	  (SHEET-INSIDE-RIGHT)
	  (SHEET-INSIDE-BOTTOM)))))

(DEFMETHOD (:DRAW-CIRCULAR-ARC-CACHED-INTERNAL GRAPHICS-MIXIN)
	   (ALU ARRAY CENTER-X CENTER-Y RADIUS START-THETA END-THETA 
		IL IT IR IB)
  (WITH-STACK-ARRAY (LIMIT-ARR '(2 8))
    (MULTIPLE-VALUE-BIND (IGNORE REVERSE-SENSE)
	(COMPUTE-OCTANT-ENDPOINTS LIMIT-ARR RADIUS START-THETA END-THETA)
	(DO ((K 0)
	     (F 0)
	     (X-VAL) (Y-VAL)
	     (J RADIUS))
	    (NIL)
	  (DRAW-CLIPPED-OCTANT-POINT-CACHED 0 (+ CENTER-X J) (- CENTER-Y K))
	  (DRAW-CLIPPED-OCTANT-POINT-CACHED 4 (- CENTER-X J) (+ CENTER-Y K))
	  (DRAW-CLIPPED-OCTANT-POINT-CACHED 6 (+ CENTER-X K) (+ CENTER-Y J))
	  (DRAW-CLIPPED-OCTANT-POINT-CACHED 2 (- CENTER-X K) (- CENTER-Y J))
	  (SETQ F (+ F  K K 1) K (1+ K))
	  (COND (( F J) (SETQ F (- F J J -1) J (- J 1))))
	  (COND ((> K J) (RETURN T)))
	  (DRAW-CLIPPED-OCTANT-POINT-CACHED 7 (+ CENTER-X J) (+ CENTER-Y K))
	  (DRAW-CLIPPED-OCTANT-POINT-CACHED 3 (- CENTER-X J) (- CENTER-Y K))
	  (DRAW-CLIPPED-OCTANT-POINT-CACHED 1 (+ CENTER-X K) (- CENTER-Y J))
	  (DRAW-CLIPPED-OCTANT-POINT-CACHED 5 (- CENTER-X K) (+ CENTER-Y J))
	  (COND ((= K J) (RETURN T)))))))

(defmethod (graphics::draw-scaled-circular-arc graphics-mixin)
	   (center-x center-y radius start-theta end-theta
		     &optional (alu :draw)
		     &rest ignore)
  (setf alu (graphics::standardize-alu self alu))
  (prepare-sheet (self)
    (lexpr-send screen :with-alu-cached-source self alu
		:draw-scaled-circular-arc-cached-internal
		(+ center-x (sheet-inside-left)) (+ center-y (sheet-inside-top)) radius
		start-theta end-theta clipping-region))
  nil)

(defmethod (:draw-scaled-circular-arc-cached-internal graphics-mixin)
	   (alu array center-x center-y radius start-theta end-theta 
		il it ir ib)
  (with-stack-array (limit-arr '(2 8))
    (multiple-value-bind (ignore reverse-sense)
	;; Note that this subroutine is coded for upsidedown y, so we reverse the angles
	;; here and the difference below.
	(compute-octant-endpoints limit-arr radius (- end-theta) (- start-theta))
      (let (x-val y-val)
	(graphics:draw-unfilled-circle-driver center-x center-y radius
	  #'(lambda (x y)
	      (let* ((rx (- x center-x))
		     (ry (- center-y y))
		     (oct (if (minusp ry)
			      (if (minusp rx)
				  (if (> (- rx) (- ry)) 4 5)
				  (if (> rx (- ry)) 7 6))
			      (if (minusp rx)
				  (if (> (- rx) ry) 3 2)
				  (if (> rx ry) 0 1))))
		     (k (selectq oct
			  ((0 3) ry)
			  ((4 7) (- ry))
			  ((1 6) rx)
			  (otherwise (- rx)))))
		(draw-clipped-octant-point-cached oct x y))))))))

(defun compute-octant-endpoints (arr radius start-theta end-theta)
  ;;Convert angles to octant measure, 0angle<8
  (let ((2 (* 2 (float si:pi))))		; single precision 2
    (let ((start-oct (mod (* 8 (// start-theta 2)) 8))
	  (end-oct (mod (* 8 (// end-theta 2)) 8))
	  (reverse-sense ()))
      ;; since thetas are floating-point, MOD may have rounded
      (when ( start-oct 8.0) (setq start-oct 0.0))
      (when ( end-oct 8.0) (setq end-oct 0.0))
      (when (< end-oct start-oct)
	(psetq end-oct start-oct start-oct end-oct reverse-sense t))
      (let ((start (fix start-oct))
	    (end (fix end-oct)))
	(dotimes (i 8)
	  (when (or (< i start) (> i end))
	    (setf (aref arr 0 i) (1+ radius))
	    (setf (aref arr 1 i) -1))
	  (when (and (> i start) (< i end))
	    (setf (aref arr 0 i) 0)
	    (setf (aref arr 1 i) radius)))
	(cond ((= start end)
	       (cond ((evenp start)
		      (let ((th (* 2 (// (mod start-oct 2.0) 8))))
			(setf (aref arr 0 start) (round (* radius (sin th)))))
		      (let ((th (* 2 (// (mod end-oct 2.0) 8))))
			(setf (aref arr 1 end) (round (* radius (sin th))))))
		     (t
		      (let ((th (* 2 (// (- 2 (mod start-oct 2.0))
					  8))))
			(setf (aref arr 1 start) (round (* radius (sin th)))))
		      (let ((th (* 2 (// (- 2 (mod end-oct 2.0)) 8))))
			(setf (aref arr 0 end) (round (* radius (sin th))))))))
	      (t
	       (cond ((evenp start)
		      (let ((th (* 2 (// (mod start-oct 2.0) 8))))
			(setf (aref arr 0 start) (round (* radius (sin th))))
			(setf (aref arr 1 start) radius)))
		     (t
		      (let ((th (* 2 (// (- 2 (mod start-oct 2.0))
					  8))))
			(setf (aref arr 0 start) 0)
			(setf (aref arr 1 start) (round (* radius (sin th)))))))
	       (cond ((evenp end)
		      (let ((th (* 2 (// (mod end-oct 2.0) 8))))
			(setf (aref arr 0 end) 0)
			(setf (aref arr 1 end) (round (* radius (sin th))))))
		     (t
		      (let ((th (* 2 (// (- 2 (mod end-oct 2.0)) 8))))
			(setf (aref arr 0 end) (round (* radius (sin th))))
			(setf (aref arr 1 end) radius)))))))
      (values arr reverse-sense))))

(DEFMETHOD (:DRAW-FILLED-IN-CIRCLE GRAPHICS-MIXIN)
	   (CENTER-X CENTER-Y RADIUS &OPTIONAL (ALU :draw))
  (setf alu (graphics::standardize-alu self alu))
  (PREPARE-SHEET (SELF)
    (LET ((IL (SHEET-INSIDE-LEFT))
	  (IT (SHEET-INSIDE-TOP)))
      (SEND SCREEN ':WITH-ALU-CACHED SELF ALU
	    ':DRAW-FILLED-IN-CIRCLE-CACHED-INTERNAL
	    (ROUND (+ CENTER-X IL))
	    (ROUND (+ CENTER-Y IT))
	    (ROUND RADIUS)
	    IL IT (SHEET-INSIDE-RIGHT) (SHEET-INSIDE-BOTTOM)))))

(DEFMETHOD (:DRAW-FILLED-IN-CIRCLE-CACHED-INTERNAL GRAPHICS-MIXIN)
	   (ALU ARRAY CENTER-X CENTER-Y RADIUS INSIDE-L INSIDE-T INSIDE-R INSIDE-B)

  (LOOP WITH X = RADIUS AND Y = 0 AND ERROR = 0 AND OLD-Y
	DO
    (SETQ ERROR (+ ERROR Y Y 1))
    (COND
      ;; Will the next chord be shorter?
      ((>= ERROR X)
       ;; Draw the middle region.
       (COND
	 ;; If this is the first time through, then draw one big rectangle.
	 ((NULL OLD-Y)
	  (CACHED-DRAW-RECTANGLE-CLIPPED
	    (+ X X 1) (+ Y Y 1)
	    (- CENTER-X X) (- CENTER-Y Y) ALU ARRAY
	    INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
	  (SETQ OLD-Y Y))
	 ;; Otherwise draw upper & lower rectangles.
	 (T
	  (CACHED-DRAW-RECTANGLE-CLIPPED
	    (+ X X 1) (- Y OLD-Y)
	    (- CENTER-X X) (- CENTER-Y Y) ALU ARRAY
	    INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
	  (CACHED-DRAW-RECTANGLE-CLIPPED
	    (+ X X 1) (- Y OLD-Y)
	    (- CENTER-X X) (+ CENTER-Y OLD-Y 1) ALU ARRAY
	    INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
	  (SETQ OLD-Y Y)))
       (AND (= X Y) (RETURN T))			;Finished?
       ;; Draw the top line.
       (CACHED-DRAW-RECTANGLE-CLIPPED
	 (+ Y Y 1) 1
	 (- CENTER-X Y) (+ CENTER-Y X) ALU ARRAY
	 INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
       ;; draw the bottom line.
       (CACHED-DRAW-RECTANGLE-CLIPPED
	 (+ Y Y 1) 1
	 (- CENTER-X Y) (- CENTER-Y X) ALU ARRAY
	 INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
       (SETQ ERROR (- ERROR X X -1)
	     X   (1- X))))
    (SETQ Y (1+ Y))
    (AND (> Y X) (RETURN T))))

;;; This has the same outline as :DRAW-CIRCLE above.
(defmethod (graphics::draw-scaled-filled-in-circle graphics-mixin)
	   (center-x center-y radius &optional (alu :draw))
  (setf alu (graphics::standardize-alu self alu))
  (prepare-sheet (self)
    (lexpr-send screen :with-alu-cached self alu
		:draw-scaled-filled-in-circle-cached-internal
		(+ center-x (sheet-inside-left)) (+ center-y (sheet-inside-top)) radius
		clipping-region)))

(defmethod (:draw-scaled-filled-in-circle-cached-internal graphics-mixin)
	   (alu array center-x center-y radius inside-l inside-t inside-r inside-b)
  (graphics:draw-circle-driver center-x center-y radius
    #'(lambda (width height x y)
	(cached-draw-rectangle-clipped width height x y alu array
				       inside-l inside-t inside-r inside-b))))

;;; Draw an annular ring, with CENTER-X, CENTER-Y as its center and radii MINOR-RADIUS
;;; and MAJOR-RADIUS.  Either of the radii may be the smaller.

;;; :DRAW-RING has the same footprint as :DRAW-FILLED-IN-CIRCLE
;;; Drawing rings with stepped radii exactly fill a circle, so 
;;;  :DRAW-RING x y 10 20  followed by :DRAW-RING x y 20 30
;;; is the same as :DRAW-RING x y 10 30

(DEFMETHOD (:DRAW-RING GRAPHICS-MIXIN)
	   (CENTER-X CENTER-Y MINOR-RADIUS MAJOR-RADIUS &OPTIONAL (ALU :draw) )
  (setf alu (graphics::standardize-alu self alu))
  (PREPARE-SHEET (SELF)
    (LET ((IL (SHEET-INSIDE-LEFT))
	  (IT (SHEET-INSIDE-TOP)))
    (SEND SCREEN ':WITH-ALU-CACHED SELF ALU
	  ':DRAW-RING-CACHED-INTERNAL (+ CENTER-X IL) (+ CENTER-Y IT) MINOR-RADIUS MAJOR-RADIUS
	  IL IT (SHEET-INSIDE-RIGHT) (SHEET-INSIDE-BOTTOM)))))
;;
;; Notes about the algorithm (it took 2 days to get it right, so listen!)
;;
;; Draw-ring uses the same circle-generator as :draw-filled-in-circle, but with additional
;; complications because it is stepping two circles in parallel.  The primary algorithm
;; actually computes the endpoints for 1/8 of a circle, and relects these points to the 
;; rest of the circle.  Draw-ring does the same for its outer circle, but for the
;; inner circle, it has to work harder, becuase the inner circle doesn't complete
;; its 1/8 circle at the same time as the outer.  As a result, several non-intuitive
;; computations have to be done to make sure the inner circle contains exactly the
;; same points it would if :draw-filled-in-curcle had been used to specify it.
;; These places are commented in the code.
;;

(DEFMETHOD (:DRAW-RING-CACHED-INTERNAL GRAPHICS-MIXIN)
	   (ALU ARRAY CENTER-X CENTER-Y MINOR-RADIUS MAJOR-RADIUS
		INSIDE-L INSIDE-T INSIDE-R INSIDE-B)

  (SETQ MAJOR-RADIUS (ROUND MAJOR-RADIUS)
	MINOR-RADIUS (ROUND MINOR-RADIUS)
	CENTER-X (ROUND CENTER-X)
	CENTER-Y (ROUND CENTER-Y))

  (WHEN (> MINOR-RADIUS MAJOR-RADIUS)
    (PSETQ MINOR-RADIUS MAJOR-RADIUS
	   MAJOR-RADIUS MINOR-RADIUS))

  (LOOP WITH X-MAJ = MAJOR-RADIUS
	AND  E-MAJ = 0
	AND  X-MIN = MINOR-RADIUS  ;; when it becomes negative, the small circle is finished.
	AND  E-MIN = 0
	AND  Y-ERR = 0 AND Y-MIN = MINOR-RADIUS AND Y-LEN = -1
	AND Y = 0 AND OLD-Y
	DO
	(SETQ E-MAJ (+ E-MAJ Y Y 1))  ;; incrementally x^2, but without multiplies
	(SETQ E-MIN (+ E-MIN Y Y 1))
	(COND
	  ;; will either next chord be shorter?
	  ((OR (>= E-MAJ X-MAJ)
	       (AND (>= X-MIN 0) (>= E-MIN X-MIN)))
	   ;; draw the middle region.
	   (COND
	     ;; if this is the first time through, then draw one big rectangle.
	     ((NULL OLD-Y)
	      (COND ((AND (<= X-MIN 0) (> X-MAJ 0))
		     (CACHED-DRAW-RECTANGLE-CLIPPED
		       (+ X-MAJ X-MAJ 1) (+ Y Y 1)
		       (- CENTER-X X-MAJ) (- CENTER-Y Y) ALU ARRAY
		       INSIDE-L INSIDE-T INSIDE-R INSIDE-B))
		    (T  ;; draw left and right segments, to avoid the center circle
		     (CACHED-DRAW-RECTANGLE-CLIPPED
		       (- X-MAJ X-MIN) (+ Y Y 1)
		       (- CENTER-X X-MAJ) (- CENTER-Y Y) ALU ARRAY
		       INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
		     (CACHED-DRAW-RECTANGLE-CLIPPED
		       (- X-MAJ X-MIN) (+ Y Y 1)
		       (+ CENTER-X X-MIN 1) (- CENTER-Y Y) ALU ARRAY
		       INSIDE-L INSIDE-T INSIDE-R INSIDE-B)))
	      (SETQ OLD-Y Y))
	     ((< X-MIN 0)
	      ;; otherwise draw upper & lower rectangles.
	      (CACHED-DRAW-RECTANGLE-CLIPPED
		(+ X-MAJ X-MAJ 1) (- Y OLD-Y)
		(- CENTER-X X-MAJ) (- CENTER-Y Y) ALU ARRAY
		INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
	      (CACHED-DRAW-RECTANGLE-CLIPPED
		(+ X-MAJ X-MAJ 1) (- Y OLD-Y)
		(- CENTER-X X-MAJ) (+ CENTER-Y OLD-Y 1) ALU ARRAY
		INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
	      (SETQ OLD-Y Y))
	     (T
	      ;; draw upper&lower, left&right rectangles, to avoid the small circle
	      (CACHED-DRAW-RECTANGLE-CLIPPED
		(- X-MAJ X-MIN) (- Y OLD-Y)
		(- CENTER-X X-MAJ) (- CENTER-Y Y) ALU ARRAY
		INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
	      (CACHED-DRAW-RECTANGLE-CLIPPED
		(- X-MAJ X-MIN) (- Y OLD-Y)
		(+ CENTER-X X-MIN 1) (- CENTER-Y Y) ALU ARRAY
		INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
	      (CACHED-DRAW-RECTANGLE-CLIPPED
		(- X-MAJ X-MIN) (- Y OLD-Y)
		(- CENTER-X X-MAJ) (+ CENTER-Y OLD-Y 1) ALU ARRAY
		INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
	      (CACHED-DRAW-RECTANGLE-CLIPPED
		(- X-MAJ X-MIN) (- Y OLD-Y)
		(+ CENTER-X X-MIN 1) (+ CENTER-Y OLD-Y 1) ALU ARRAY
		INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
	      (SETQ OLD-Y Y)))
	   (AND (= X-MAJ Y) (RETURN T))		;finished?
	   ;; draw the top line by reflection.
	   (COND ((< E-MAJ X-MAJ))  ;; only the small circle changed
		 (T
		  (COND ((> X-MAJ MINOR-RADIUS)
			 ;; we don't intersect the small circle yet
			 (CACHED-DRAW-RECTANGLE-CLIPPED
			   (+ Y Y 1) 1
			   (- CENTER-X Y) (+ CENTER-Y X-MAJ) ALU ARRAY
			   INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
			 ;; draw the bottom line.
			 (CACHED-DRAW-RECTANGLE-CLIPPED
			   (+ Y Y 1) 1
			   (- CENTER-X Y) (- CENTER-Y X-MAJ) ALU ARRAY
			   INSIDE-L INSIDE-T INSIDE-R INSIDE-B))
			(T
			 (INCF Y-LEN)
			 ;; we intersect the small circle, and must calculate the
			 ;; width of the chord the same as :draw-filled-in-circle would.
			 ;; this loop calculates the next step point
			 (LOOP DO
			       (SETQ Y-ERR (+ Y-ERR Y-LEN Y-LEN 1))
			       (SETQ Y-LEN (1+ Y-LEN))
			       UNTIL
			       (WHEN (>= Y-ERR Y-MIN)
				 (LOOP WHILE (AND (>= Y-ERR Y-MIN)
						  (> Y-MIN 0))
				       DO
				       (SETQ Y-ERR (- Y-ERR Y-MIN Y-MIN -1)
					     Y-MIN (1- Y-MIN))
				       FINALLY (RETURN T))))
			 (DECF Y-LEN)
			 (CACHED-DRAW-RECTANGLE-CLIPPED
			   (- Y Y-LEN ) 1
			   (- CENTER-X Y) (- CENTER-Y X-MAJ) ALU ARRAY
			   INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
			 (CACHED-DRAW-RECTANGLE-CLIPPED
			   (- Y Y-LEN ) 1
			   (+ CENTER-X Y-LEN 1) (- CENTER-Y X-MAJ) ALU ARRAY
			   INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
			 (CACHED-DRAW-RECTANGLE-CLIPPED
			   (- Y Y-LEN ) 1
			   (- CENTER-X Y) (+ CENTER-Y X-MAJ) ALU ARRAY
			   INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
			 (CACHED-DRAW-RECTANGLE-CLIPPED
			   (- Y Y-LEN ) 1
			   (+ CENTER-X Y-LEN 1) (+ CENTER-Y X-MAJ) ALU ARRAY
			   INSIDE-L INSIDE-T INSIDE-R INSIDE-B)))
		  (SETQ E-MAJ (- E-MAJ X-MAJ X-MAJ -1)
			X-MAJ (1- X-MAJ))))
	   (LOOP WHILE (AND (>= E-MIN X-MIN)
			    ;; this extra clause is needed to keep the footprint right.
			    ;; we are stepping the minor axis toward the center, but
			    ;; if we are beyond the 1/8 circle point,
			    ;; :draw-filled-in-circle would be stepping it away from the
			    ;; center.  to keep it right, we avoid taking the step if
			    ;; :draw-filled-in-circle would have stepped it back.
			    (OR (> X-MIN Y)
				(> E-MIN Y))
			    (>= X-MIN 0))
		 DO
		 (SETQ E-MIN (- E-MIN X-MIN X-MIN -1)
		       X-MIN (1- X-MIN)))))
	(SETQ Y (1+ Y))
	(AND (> Y X-MAJ) (RETURN T))))

(defmethod (graphics::draw-scaled-ring graphics-mixin)
	   (center-x center-y minor-radius major-radius &optional (alu :draw) )
  (setf alu (graphics::standardize-alu self alu))
  (prepare-sheet (self)
    (lexpr-send screen :with-alu-cached self alu
		:draw-scaled-ring-cached-internal
		(+ center-x (sheet-inside-left)) (+ center-y (sheet-inside-top))
		minor-radius major-radius clipping-region))) 

(defmethod (:draw-scaled-ring-cached-internal graphics-mixin)
	   (alu array center-x center-y minor-radius major-radius
		inside-l inside-t inside-r inside-b)
  (graphics:draw-circular-ring-driver center-x center-y minor-radius major-radius
    #'(lambda (width height x y)
	(cached-draw-rectangle-clipped width height x y alu array
				       inside-l inside-t inside-r inside-b))))

(DEFMETHOD (:DRAW-FILLED-IN-SECTOR GRAPHICS-MIXIN) (CENTER-X CENTER-Y RADIUS THETA-1 THETA-2
						    &OPTIONAL (ALU :draw))
  (setf alu (graphics::standardize-alu self alu))
  (PREPARE-SHEET (SELF)
    (DO ((Y (- RADIUS) (1+ Y))
	 (X 0)
	 (U0 0) (U1 0)				;Clipped plane 1
	 (V0 0) (V1 0)				;Clipped plane 2
	 (CO-X0 (FIX (* -1000.0 (SIN THETA-1))))
	 (CO-Y0 (FIX (*  1000.0 (COS THETA-1))))
	 (CO-X1 (FIX (* -1000.0 (SIN THETA-2))))
	 (CO-Y1 (FIX (*  1000.0 (COS THETA-2))))
	 (FLAG (> (ABS (- THETA-1 THETA-2)) 3.14159))
	 (R2 (* RADIUS RADIUS)))
	((> Y RADIUS))
      (SETQ X (ISQRT (- R2 (* Y Y))))		;Unclipped line
      (SETQ U0 (- X) U1 X
	    V0 (- X) V1 X)			;Init clipped lines
      
      (AND (PLUSP (- (* CO-Y0 Y) (* CO-X0 U1)))	;Clip with first plane
	   (SETQ U1 (IF (= 0 CO-X0) 0 (// (* CO-Y0 Y) CO-X0))))
      (AND (PLUSP (- (* CO-Y0 Y) (* CO-X0 U0)))
	   (SETQ U0 (IF (= 0 CO-X0) 0 (// (* CO-Y0 Y) CO-X0))))
      
      (AND (MINUSP (- (* CO-Y1 Y) (* CO-X1 V1)))	;Clip with second plane
	   (SETQ V1 (IF (= 0 CO-X1) 0 (// (* CO-Y1 Y) CO-X1))))
      (AND (MINUSP (- (* CO-Y1 Y) (* CO-X1 V0)))
	   (SETQ V0 (IF (= 0 CO-X1) 0 (// (* CO-Y1 Y) CO-X1))))
      
      ;; Ok, we have two lines, [U0 U1] and [V0 V1].
      ;; If the angle was greater than pi, then draw both of them,
      ;; otherwise draw their intersection
      (COND (FLAG
	     (AND (> U1 U0)
		  (SEND SELF ':DRAW-LINE
			(+ CENTER-X U0) (+ CENTER-Y Y)
			(+ CENTER-X U1) (+ CENTER-Y Y)
			ALU T))
	     (AND (> V1 V0)
		  (SEND SELF ':DRAW-LINE 
			(+ CENTER-X V0) (+ CENTER-Y Y)
			(+ CENTER-X V1) (+ CENTER-Y Y)
			ALU T)))
	    (T					;Compute intersection
	     (LET ((LEFT  (MAX U0 V0))
		   (RIGHT (MIN U1 V1)))
	       (AND (> RIGHT LEFT)
		    (SEND SELF ':DRAW-LINE 
			  (+ CENTER-X LEFT)  (+ CENTER-Y Y)
			  (+ CENTER-X RIGHT) (+ CENTER-Y Y)
			  ALU T))))))))

;;; This might make it a little faster.
(defwhopper-subst (graphics::draw-scaled-filled-in-sector graphics-mixin) (&rest args)
  (prepare-sheet (self)
    (lexpr-continue-whopper args)))

;;
;; A "simple" ellipse is one which is aligned on the grid axis.
;;
(DEFMETHOD (:DRAW-SIMPLE-ELLIPSE GRAPHICS-MIXIN)
	   (CENTER-X CENTER-Y X-RADIUS Y-RADIUS &OPTIONAL (ALU :draw))
  (setf alu (graphics::standardize-alu self alu))
  (PREPARE-SHEET (SELF)
    (LET ((IL (SHEET-INSIDE-LEFT))
	  (IT (SHEET-INSIDE-TOP)))
      (SEND SCREEN ':WITH-ALU-CACHED-SOURCE  SELF ALU
	    :DRAW-SIMPLE-ELLIPSE-CACHED-INTERNAL
	    (+ CENTER-X IL) (+ CENTER-Y IT) X-RADIUS Y-RADIUS
	    IL IT (SHEET-INSIDE-RIGHT) (SHEET-INSIDE-BOTTOM)))))


(DEFMETHOD (:DRAW-SIMPLE-ELLIPSE-CACHED-INTERNAL GRAPHICS-MIXIN)
	   (ALU ARRAY CX CY A B IL IT IR IB)
  (LET* ((X A)
	 (Y 0)
	 X-VAL Y-VAL				;ditto.
	 (ASQ (* A A))
	 (BSQ (* B B))
	 (T8 (* 4 A BSQ))
	 (D1 (+ (- (* ASQ 2) (* A BSQ 2)) (// BSQ 2)))
	 (D2 (+ (- (// ASQ 2) T8) (* 2 BSQ)))
	 (4ASQ (* 4 ASQ))
	 (2ASQ (* 2 ASQ))
	 (4BSQ (* 4 BSQ))
	 (2BSQ (* 2 BSQ))
	 (TEMP 0))
    (LOOP WHILE (MINUSP D2)			;"Y major" half of the ellipse.
	  DO
	  (DRAW-CLIPPED-POINT-CACHED (+ CX X) (+ CY Y))
	  (DRAW-CLIPPED-POINT-CACHED (- CX X) (+ CY Y))
	  (WHEN (> Y 0)
	    (DRAW-CLIPPED-POINT-CACHED (+ CX X) (- CY Y))
	    (DRAW-CLIPPED-POINT-CACHED (- CX X) (- CY Y)))
	  (INCF Y)
	  (INCF TEMP 4ASQ)
	  (COND
	    ((< D1 0)
	     (SETQ D1 (+ D1 TEMP 2ASQ))
	     (INCF D2 TEMP))
	    (T
	     (DECF X)
	     (DECF T8 4BSQ)
	     (SETQ D1 (- (+ D1 TEMP 2ASQ) T8))
	     (SETQ D2 (- (+ D2 TEMP 2BSQ) T8)))))
    (LOOP DO				        ;"X major" half of the ellipse.
	  (DRAW-CLIPPED-POINT-CACHED (+ CX X) (+ CY Y))
	  (DRAW-CLIPPED-POINT-CACHED (+ CX X) (- CY Y))
	  (WHEN (> X 0)
	    (DRAW-CLIPPED-POINT-CACHED (- CX X) (+ CY Y))
	    (DRAW-CLIPPED-POINT-CACHED (- CX X) (- CY Y)))
	  (DECF X)
	  (DECF T8 4BSQ)
	  (COND
	    ((< D2 0)
	     (INCF Y)
	     (INCF TEMP 4ASQ)
	     (SETQ D2 (- (+ D2 2BSQ TEMP) T8)))
	    (T
	     (SETQ D2 (- (+ D2 2BSQ) T8))))
	  UNTIL (MINUSP X))))

;;; A "simple" ellipse is one which is aligned on the grid axis.
(defmethod (graphics::draw-scaled-simple-ellipse graphics-mixin)
	   (center-x center-y x-radius y-radius &optional (alu :draw) ignore)
  (setf alu (graphics::standardize-alu self alu))
  (prepare-sheet (self)
    (lexpr-send screen :with-alu-cached-source self alu
		:draw-scaled-simple-ellipse-cached-internal
		(+ center-x (sheet-inside-left)) (+ center-y (sheet-inside-top))
		x-radius y-radius clipping-region)))

(defmethod (:draw-scaled-simple-ellipse-cached-internal graphics-mixin)
	   (alu array cx cy a b il it ir ib)
  (graphics:draw-unfilled-ellipse-driver cx cy a b
    #'(lambda (x y &aux x-val y-val) (draw-clipped-point-cached x y))))

(DEFMETHOD (:DRAW-FILLED-IN-SIMPLE-ELLIPSE GRAPHICS-MIXIN)
	   (CX CY A B &OPTIONAL (ALU :draw))
  (DECLARE (ARGLIST CENTER-X CENTER-Y X-RADIUS Y-RADIUS &OPTIONAL (ALU :draw)))
  (setf alu (graphics::standardize-alu self alu))
  (PREPARE-SHEET (SELF)
    (LET ((IL (SHEET-INSIDE-LEFT))
	  (IT (SHEET-INSIDE-TOP)))
      (SEND SCREEN ':WITH-ALU-CACHED SELF ALU ':DRAW-FILLED-IN-SIMPLE-ELLIPSE-CACHED-INTERNAL
	    (+ IL CX) (+ IT CY) A B
	    IL IT (SHEET-INSIDE-RIGHT) (SHEET-INSIDE-BOTTOM)))))

(DEFMETHOD (:DRAW-FILLED-IN-SIMPLE-ELLIPSE-CACHED-INTERNAL GRAPHICS-MIXIN)
	   (ALU ARRAY CX CY A B INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
  (LET* ((X A)
	 (Y 0)
	 (ASQ (* A A))
	 (BSQ (* B B))
	 (T8 (* 4 A BSQ))
	 (D1 (+ (- (* ASQ 2) (* A BSQ 2)) (// BSQ 2)))
	 (D2 (+ (- (// ASQ 2) T8) (* 2 BSQ)))
	 (4ASQ (* 4 ASQ))
	 (2ASQ (* 2 ASQ))
	 (4BSQ (* 4 BSQ))
	 (2BSQ (* 2 BSQ))
	 (TEMP 0))
    (PREPARE-SHEET (SELF)
      (LOOP WITH Y0 = 0
	    WHILE (MINUSP D2)			;"Y major" half of the ellipse.
	    DO
	    (INCF Y0)
	    (WHEN (>= D1 0)
	      (CACHED-DRAW-RECTANGLE-CLIPPED
		(+ X X) Y0 (- CX X) (+ CY (- Y Y0 -1)) ALU ARRAY
		INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
	      (WHEN (> Y 0)
		(WHEN (> Y0 Y)
		  (DECF Y0))
		(CACHED-DRAW-RECTANGLE-CLIPPED
		  (+ X X) Y0 (- CX X) (- CY Y) ALU ARRAY
		  INSIDE-L INSIDE-T INSIDE-R INSIDE-B))
	      (SETQ Y0 0))
	    (INCF Y)
	    (INCF TEMP 4ASQ)
	    (COND
	      ((< D1 0)
	       (SETQ D1 (+ D1 TEMP 2ASQ))
	       (INCF D2 TEMP))
	      (T
	       (DECF X)
	       (DECF T8 4BSQ)
	       (SETQ D1 (- (+ D1 TEMP 2ASQ) T8))
	       (SETQ D2 (- (+ D2 TEMP 2BSQ) T8)))))
      (LOOP INITIALLY
	    (CACHED-DRAW-RECTANGLE-CLIPPED
	      (+ X X) 1 (- CX X) (+ CY Y) ALU ARRAY
	      INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
	    (CACHED-DRAW-RECTANGLE-CLIPPED
	      (+ X X) 1 (- CX X) (- CY Y) ALU ARRAY
	      INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
	    DO					;"X major" half of the ellipse.
	    (DECF X)
	    (DECF T8 4BSQ)
	    (COND
	      ((< D2 0)
	       (INCF Y)
	       (INCF TEMP 4ASQ)
	       (WHEN (> X 0)
		 (CACHED-DRAW-RECTANGLE-CLIPPED
		   (+ X X) 1 (- CX X) (+ CY Y) ALU ARRAY
		   INSIDE-L INSIDE-T INSIDE-R INSIDE-B)
		 (CACHED-DRAW-RECTANGLE-CLIPPED
		   (+ X X) 1 (- CX X) (- CY Y) ALU ARRAY
		   INSIDE-L INSIDE-T INSIDE-R INSIDE-B))
	       (SETQ D2 (- (+ D2 2BSQ TEMP) T8)))
	      (T
	       (SETQ D2 (- (+ D2 2BSQ) T8))))
	    UNTIL (MINUSP X)))))

(defmethod (graphics::draw-scaled-filled-in-simple-ellipse graphics-mixin)
	   (cx cy a b &optional (alu :draw))
  (declare (arglist center-x center-y x-radius y-radius &optional (alu :draw)))
  (setf alu (graphics::standardize-alu self alu))
  (prepare-sheet (self)
    (lexpr-send screen :with-alu-cached self alu
		:draw-scaled-filled-in-simple-ellipse-cached-internal
		(+ cx (sheet-inside-left)) (+ cy (sheet-inside-top))
		a b clipping-region)))

(defmethod (:draw-scaled-filled-in-simple-ellipse-cached-internal graphics-mixin)
	   (alu array cx cy a b inside-l inside-t inside-r inside-b)
  (graphics:draw-ellipse-driver cx cy a b
    #'(lambda (width height x y)
	(cached-draw-rectangle-clipped width height x y alu array
				       inside-l inside-t inside-r inside-b))))

;;; This gives some performance speedup by only preparing once.
(defwhopper-subst (graphics::draw-general-ellipse graphics-mixin) (&rest args)
  (prepare-sheet (self)
    (lexpr-continue-whopper args)))

;;;; Strings (as graphics, not TTY output style).

;;; DEFUN-METHODs used by :DRAW-STRING.  These definitions must appear
;;; before they are used so that the compiler optimiziations will happen.

;;; Draw a (perhaps multi-font) string horizontally, expanding or compressing
(defun-in-flavor (draw-string-horizontal graphics-mixin)
		 (string last-index from-x y extra extra-per-gap period
		  shortfall back-p style alu)
  (multiple-value-bind (x-edge y-edge) (send self :inside-size)
    (let (font index font-char-width-table font-baseline font-height char-in-font fast-index
	  font-width)
      (loop with x = from-x
	    with first-time = 't
	    with adjust = (cond ((minusp extra) -1)
				((zerop extra) 0)
				(t 1))
	    for i from 0 to last-index
	    for char = (aref string (if back-p (- last-index i) i))
	    for condition = (and period (not (zerop shortfall)) (zerop (remainder i period)))
	    do
	(when (or first-time
		  (null (setq index (si:%chars-share-device-font-p char char-in-font
								   fast-index))))
	  ;; we've just changed font.  Get all the necessary information, once.
	  (multiple-value (index font)
	    (si:lookup-index-and-font char display-device-type style nil))
	  (setq char-in-font char)
	  (setq fast-index (si:%char-subindex-is-index-p char-in-font))
	  (when font
	    (setq font-width (font-char-width font)
		  font-char-width-table (font-char-width-table font)
		  font-baseline (font-baseline font)
		  font-height (font-char-height font)))
	  ;; new font values are initialized.
	  (setq first-time nil))
	;; still in same font; just add up values.
	(when (and font (graphic-char-p char))	;only printing characters
	  (let* ((ch-width (compute-char-width index font-char-width-table font-width))
		 (total-width (+ ch-width extra-per-gap
				 (cond (condition (setq shortfall (- shortfall adjust))
						  adjust)
				       (t 0)))))
	    (cond (back-p
		   (draw-glyph-to-left index font x y font-height ch-width
				       font-baseline self x-edge y-edge alu)
		   (setq x (- x total-width)))
		  (t
		   (draw-glyph-to-right index font x y font-height ch-width
					font-baseline self x-edge y-edge alu)
		   (setq x (+ x total-width))))))
	    finally (return (values x y))))))

;;; Draw a (perhaps multi-font) string vertically, expanding or compressing
(defun-in-flavor (draw-string-vertical graphics-mixin)
		 (string last-index from-y x extra extra-per-gap period shortfall back-p
		  style alu)
  (multiple-value-bind (x-edge y-edge) (send self :inside-size)
    (let (font index font-char-width-table font-baseline font-height char-in-font fast-index
	  font-width)
      (loop with y = from-y
	    with first-time = 't
	    with adjust = (cond ((minusp extra) -1)
				((zerop extra) 0)
				(t 1))
	    for i from 0 to last-index
	    for char = (aref string (if back-p (- last-index i) i))
	    for condition = (and period (not (zerop shortfall)) (zerop (remainder i period)))
	    do (when
		 (or first-time
		     (null (setq index (si:%chars-share-device-font-p char char-in-font
								      fast-index))))
		 ;; we've just changed font.  Get all the necessary information, once.
		 (multiple-value (index font)
		   (si:lookup-index-and-font char display-device-type style nil))
		 (setq char-in-font char)
		 (setq fast-index (si:%char-subindex-is-index-p char-in-font))
		 (when font
		   (setq font-width (font-char-width font)
			 font-char-width-table (font-char-width-table font)
			 font-baseline (font-baseline font)
			 font-height (font-char-height font)))
		 ;; new font values are initialized.
		 (setq first-time nil))
	       ;; still in same font; just add up values.
	       (when (and font (graphic-char-p char))	;only printing characters
		 (let* ((ch-width (compute-char-width index font-char-width-table font-width))
			(total-height (+ font-height extra-per-gap
					 (cond (condition
						(setq shortfall (- shortfall adjust))
						adjust)
					       (t 0)))))
		   (funcall (if back-p #'draw-glyph-to-left #'draw-glyph-to-right)
			    index font x y
			    font-height ch-width font-baseline
			    self x-edge y-edge alu)
		   (setq y (if back-p
			       (- y total-height)
			       (+ y total-height)))))
	    finally (return (values x y))))))

;;; Draw a (perhaps multi-font) string diagonally, expanding or compressing
(defun-in-flavor (draw-string graphics-mixin)
		 (string last-index from-x from-y to-x to-y x-extra y-extra
		  x-extra-per-gap y-extra-per-gap x-period y-period shortfall-x
		  shortfall-y back-p style alu delta-x delta-y stretch-p)
  (ignore to-x)
  (multiple-value-bind (x-edge y-edge) (send self :inside-size)
    (let (font index font-char-width-table font-baseline font-height char-in-font fast-index
	  font-width)
      (loop with first-time = 't
	    with x-adjust = (cond ((minusp x-extra) -1)
				  ((zerop x-extra) 0)
				  (t 1))
	    and y-adjust = (cond ((minusp y-extra) -1)
				 ((zerop y-extra) 0)
				 (t 1))
	    with up-p = (lessp to-y from-y)
	    with x-longer-p = (greaterp (abs delta-x) (abs delta-y))
	    with test = (// (if x-longer-p (abs delta-x) (abs delta-y)) 2)
	    with x = from-x and lx = from-x and y = from-y and ly = from-y 
	    for i from 0 to last-index
	    for char = (aref string (if back-p (- last-index i) i))
	    for condition-x = (and x-period (not (zerop shortfall-x))
				   (zerop (remainder i x-period)))
	    and condition-y = (and y-period (not (zerop shortfall-y))
				   (zerop (remainder i y-period)))
	    do (when
		 (or first-time
		     (null (setq index (si:%chars-share-device-font-p char char-in-font
								      fast-index))))
		 ;; we've just changed font.  Get all the necessary information, once.
		 (multiple-value (index font)
		   (si:lookup-index-and-font char display-device-type style nil))
		 (setq char-in-font char)
		 (setq fast-index (si:%char-subindex-is-index-p char-in-font))
		 (when font
		   (setq font-width (font-char-width font)
			 font-char-width-table (font-char-width-table font)
			 font-baseline (font-baseline font)
			 font-height (font-char-height font)))
		 ;; new font values are initialized.
		 (setq first-time nil))
	       ;; still in same font; just add up values.
	       (when (and font (graphic-char-p char))	;only printing characters
		 (let ((ch-width (compute-char-width index font-char-width-table font-width)))
		   (setq lx (if back-p
				(- lx ch-width x-extra-per-gap	;(break back)
				   (cond (condition-x (setq shortfall-x
							    (- shortfall-x x-adjust))
						      x-adjust)
					 (t 0)))
				(+ lx ch-width x-extra-per-gap	;(break forward)
				   (cond (condition-x (setq shortfall-x
							    (- shortfall-x x-adjust))
						      x-adjust)
					 (t 0)))))
		   (setq ly (if up-p
				(- ly font-height y-extra-per-gap	;(break up)
				   (cond (condition-y (setq shortfall-y
							    (- shortfall-y y-adjust))
						      y-adjust)
					 (t 0)))
				(+ ly font-height y-extra-per-gap	;(break down)
				   (cond (condition-y (setq shortfall-y
							    (- shortfall-y y-adjust))
						      y-adjust)
					 (t 0)))))
		   (if back-p
		       (draw-glyph-to-left index font x y font-height ch-width
					   font-baseline self x-edge y-edge alu)
		       (draw-glyph-to-right index font x y font-height
					    ch-width font-baseline self x-edge y-edge alu))
		   (multiple-value (x y test)
		     (next-free-pixel x y test delta-x delta-y
				      x-longer-p lx ly up-p (not back-p) stretch-p))))
	    finally (return (values x y))))))

;;; Go through a string (perhaps multi-font) accumulating character height and width
;;; STYLE is the default-style for this string, and must be fully qualified.
(defun-in-flavor (string-normal-size graphics-mixin) (string last-index style)
  (declare (values total-x total-y))
  (if (< last-index 0)				;Inclusive index.
      (values 0 0)
      (let* (cw cwa font-height index font char-in-font fast-index
	     (first-time 't)
	     (total-x 0)
	     (total-y 0))
	(loop for i from 0 to last-index
	      for ch = (aref string i)
	      do (when
		   (or first-time
		       (null (setq index (si:%chars-share-device-font-p ch char-in-font
									fast-index))))
		   ;; we've just changed font.  Get all the necessary information, once.
		   (multiple-value (index font)
		     (si:lookup-index-and-font ch display-device-type style nil))
		   (setq char-in-font ch)
		   (setq fast-index (si:%char-subindex-is-index-p char-in-font))
		   (if font
		       (setq cw (font-char-width font)
			     cwa (font-char-width-table font)
			     font-height (font-char-height font))
		       (setq cw 0 cwa nil font-height 0))
		   ;; new font values are initialized.
		   (setq first-time nil))
		 ;; still in same font; just add up values.
		 (when (and font (graphic-char-p ch))	;only count printing characters
		   (incf total-y font-height)
		   (incf total-x (compute-char-width index cwa cw))))
	(values total-x total-y))))

#||
;;; DDyer's test case
(dw:with-own-coordinates ()
  (send cl:*standard-output* :draw-line 0 100 200 100)
  (send cl:*standard-output* :draw-line 100 0 100 200)
  (loop for dy from -1 to +1 do
    (loop for dx from -1 to +1 do
      (unless (and (zerop dx) (zerop dy))
	(send cl:*standard-output* :draw-string "FOO" 100 100 (+ 100 dx) (+ 100 dy))))))
||#

;;; Draw a character string at an arbitrary place in a window.  Only
;;; printing characters (including space) are allowed in the string.  The
;;; left baseline points of the characters lie on the line defined by FROM-X, FROM-Y
;;; TOWARD-X and TOWARD-Y.  If TOWARD-X is less than FROM-X, the string is written backwards
;;; (i.e. the right-most character is at FROM-X, FROM-Y and the right baseline points
;;; are used); otherwise the leftmost character starts at FROM-X, FROM-Y.
;;; If TOWARD-X is equal to FROM-X, the string is drawn vertically, to be read from top
;;; to bottom.  Also, if drawing up, right baseline points are used.
;;; If STRETCH-P is true, the string will end near END-X by END-Y (though maybe no
;;; exactly, because of roundoff error.)
;;; The given ALUF is used.  Fat strings are merged against the given style, which is merged
;;; against the window's current style (not its default style).
;;; The stopping location is returned (as two values).

;;; Problems:
;;; extreme slopes cause character overstrikes
;;; doesn't use vsp in vertical space calculation
;;; doesn't skip everything if string lies completely outside screen
;;; doesn't apportion compress/squeeze space with regard to character size
;;; should really return place to start continuation of string, rather than coordinates
;;;    of last char

(defmethod (:draw-string graphics-mixin)
	   (string from-x from-y &optional (toward-x (1+ from-x)) (toward-y from-y)
		   (stretch-p nil) style (alu :draw))
  "Draws a character string between given points.  If stretch-p is non-nil,
the characters will be spaced to closely fit between the points;
otherwise, they merely use the line defined by the points.  If toward-x
is less than from-x, the string ends at from-x from-y; otherwise it
starts there and in both cases it will read from left to right.  If
drawn vertically, it will read from top to bottom.  If STYLE is non-nil,
it is merged with with the window's current-style for the default style
for this string."
  
  (setf alu (graphics::standardize-alu self alu))
  (let* ((string (string string))		;convert possible randomness to string
	 (length (array-active-length string))
	 (end-displacement (1- length))		;highest aref index and also number of gaps
						;between characters
	 (stretch-p (and stretch-p (plusp end-displacement)))
	 (delta-x (- toward-x from-x))
	 (delta-y (- toward-y from-y))
	 (style-of-string (or (and style (si:merge-character-styles style
								    merged-current-style))
			      merged-current-style))
	 (backwards-p (minusp delta-x))		;predicate for backwards strings
	 (vertical-p (zerop delta-x))
	 (horizontal-p (zerop delta-y)))
    (cond (horizontal-p
	   (cond (stretch-p
		  (multiple-value-bind (x-desired ignore)
		      (string-normal-size string end-displacement style-of-string)
		    (let* ((excess-x-space (- (abs delta-x) (abs x-desired)))	;+ = expand
			   (excess-x-per-gap (// excess-x-space end-displacement))
			   (shortfall-x (- excess-x-space
					   (* end-displacement excess-x-per-gap)))
			   (x-period (if (zerop shortfall-x) nil
					 (// end-displacement shortfall-x))))
		      (draw-string-horizontal string end-displacement from-x from-y
					      excess-x-space excess-x-per-gap x-period
					      shortfall-x backwards-p style-of-string alu))))
		 (t (draw-string-horizontal string end-displacement from-x from-y 0 0 nil 0
					    backwards-p style-of-string alu))))
	  (vertical-p
	   (cond (stretch-p
		  (multiple-value-bind (ignore y-desired)
		      (string-normal-size string end-displacement style-of-string)
		    (let* ((excess-y-space (- (abs delta-y) (abs y-desired)))
			   (excess-y-per-gap (// excess-y-space end-displacement))
			   (shortfall-y (- excess-y-space (* end-displacement
							     excess-y-per-gap)))
			   (y-period (if (zerop shortfall-y) nil (// end-displacement
								     shortfall-y))))
		      (draw-string-vertical
			string end-displacement from-y from-x excess-y-space excess-y-per-gap
			y-period shortfall-y (minusp delta-y) style-of-string alu))))
		 (t (draw-string-vertical string end-displacement from-y from-x
					  0 0 nil 0 (minusp delta-y) style-of-string alu))))
	  (t (cond (stretch-p
		    (multiple-value-bind (x-desired y-desired)
			(string-normal-size string end-displacement style-of-string)
		      (let* ((excess-x-space (- (abs delta-x) (abs x-desired)))
			     (excess-x-per-gap (// excess-x-space end-displacement))
			     (shortfall-x (- excess-x-space (* end-displacement
							       excess-x-per-gap)))
			     (x-period (if (zerop shortfall-x) nil (// end-displacement
								       shortfall-x)))
			     (excess-y-space (- (abs delta-y) (abs y-desired)))
			     (excess-y-per-gap (// excess-y-space end-displacement))
			     (shortfall-y (- excess-y-space (* end-displacement
							       excess-y-per-gap)))
			     (y-period (if (zerop shortfall-y) nil (// end-displacement
								       shortfall-y))))
			(draw-string string end-displacement from-x from-y toward-x toward-y
				     excess-x-space excess-y-space excess-x-per-gap
				     excess-y-per-gap x-period y-period shortfall-x
				     shortfall-y backwards-p style-of-string alu
				     delta-x delta-y stretch-p))))
		   (t (draw-string string end-displacement from-x from-y toward-x toward-y
				   0 0 0 0
				   nil nil 0 0 backwards-p style-of-string alu delta-x delta-y
				   stretch-p)))))))

(defun next-free-pixel (current-x current-y test delta-x delta-y x-long-p x-lim y-lim
			up-p right-p stretch-p)
  (flet ((and-or-or-based-on-stretch-p (flag c1 c2)
	   (cond (flag (and c1 c2))
		 (t (or c1 c2)))))
    (loop until (and-or-or-based-on-stretch-p stretch-p
					      (cond (right-p ( current-x x-lim))
						    (t ( current-x x-lim)))
					      (cond (up-p ( current-y y-lim))
						    (t ( current-y y-lim))))
	  with last-x = current-x and last-y = current-y
	  and last-test = test
	  do (setq last-x current-x last-y current-y last-test test)
	     (multiple-value (current-x current-y test)
	       (cond ((minusp delta-x)
		      (next-pixel-to-left current-x current-y test delta-x delta-y x-long-p))
		     (t (next-pixel-to-right current-x current-y test
					     delta-x delta-y x-long-p))))
	  finally (return (values last-x last-y last-test)))))

;;; given current point, total displacements and test (initially long/2)
;;; return new x, y and test
(defun next-pixel-to-right (current-x current-y test delta-x delta-y x-long-p)
  (let ((y-incr (cond ((lessp delta-y 0)
		       -1)
		      ((greaterp delta-y 0)
		       1)
		      (t 0))))
    (cond (x-long-p
	   (setq test (- test (abs delta-y)))
	   (if (minusp test) (setq test (+ test delta-x)
				  current-y (+ current-y y-incr)))
	   (setq current-x (1+ current-x)))
	  (t
	   (setq test (- test delta-x))
	   (if (minusp test) (setq test (+ test (abs delta-y))
				  current-x (1+ current-x)))
	   (setq current-y (+ current-y y-incr))))
    (values current-x current-y test)))

(defun next-pixel-to-left (current-x current-y test delta-x delta-y x-long-p)
  (let ((y-incr (cond ((lessp delta-y 0)
		       -1)
		      ((greaterp delta-y 0)
		       1)
		      (t 0))))
    (cond (x-long-p
	   (setq test (- test (abs delta-y)))
	   (if (minusp test) (setq test (+ test (minus delta-x))
				  current-y (+ current-y y-incr)))
	   (setq current-x (1- current-x)))
	  (t
	   (setq test (- test (minus delta-x)))
	   (if (minusp test) (setq test (+ test (abs delta-y))
				  current-x (1- current-x)))
	   (setq current-y (+ current-y y-incr))))
    (values current-x current-y test)))

(defun //-no-ratios (x y)
  (if (and (floatp x) (floatp y))
      (// x y)
      (multiple-value-bind (q r)
	  (floor x y)
	(if (zerop r) q (+ q (// (float r) y))))))

#||
(defvar *font-of-approximately-this-size-cache* 
	(dw::make-good-table :name "Font of approximately this size"
			     :test #'dw::fringe-eql :hash-function #'dw::fringe-eql-hash
			     :store-hash-code t))
||#
(defvar *font-of-approximately-this-size-cache* (cl:make-hash-table :test #'cl:equal))
(defvar *font-of-approximately-this-size-cache-tick* 0)
(cl:pushnew '*font-of-approximately-this-size-cache-tick*
	    si:*character-style-global-tick-symbols*)
(defvar *font-of-approximately-this-size-last-tick* -1)

(defun font-of-approximately-this-size (sheet char-set style scale-x scale-y)
  (declare (values font scale-x scale-y))
  (destructuring-bind (font font-scale)
      (let ((family (si:cs-family style))
	    (face (si:cs-face style))
	    (display-device (sheet-display-device-type sheet))
	    (scale (min (abs scale-x) (abs scale-y))))
	(unless (eql *font-of-approximately-this-size-last-tick*
		     *font-of-approximately-this-size-cache-tick*)
	  (clrhash *font-of-approximately-this-size-cache*)
	  (setq *font-of-approximately-this-size-last-tick*
		*font-of-approximately-this-size-cache-tick*))
	(with-stack-list (key char-set family face display-device scale)
	  (multiple-value-bind (value found-p)
	      (gethash key *font-of-approximately-this-size-cache*)
	    (when (not found-p)
	      (setq value (font-of-approximately-this-size-1 sheet char-set family face
							     display-device scale))
	      (setf (gethash (copylist key) *font-of-approximately-this-size-cache*) value))
	    value)))
    (setq scale-x (//-no-ratios scale-x font-scale)
	  scale-y (//-no-ratios scale-y font-scale))
    (values font scale-x scale-y)))

(defun font-of-approximately-this-size-1 (sheet char-set family face display-device scale)
  (let ((best-bigger nil) (best-bigger-scale nil)
	(best-smaller nil) (best-smaller-scale nil))
    (block found
      (dw::map-over-valid-character-style-sizes-for-family-face	;used by ch-style p-t
	(named-lambda valid-faces (size)
	  (declare (sys:downward-function))
	  (let ((font (si:get-font display-device char-set
				   (si:intern-character-style family face size)
				   nil)))
	    (when font
	      (let ((this-scale (font-char-height font)))	;Should be -width?
		(cond ((= scale this-scale)
		       (return-from found (list font scale)))
		      ((> scale this-scale)
		       (when (or (null best-smaller)
				 (> this-scale best-smaller-scale))
			 (setq best-smaller font
			       best-smaller-scale this-scale)))
		      ((< scale this-scale)
		       (when (or (null best-bigger)
				 (< this-scale best-bigger-scale))
			 (setq best-bigger font
			       best-bigger-scale this-scale))))))))
	family face (sheet-merged-current-style sheet)
	:device display-device :allow-relative nil)
      (if best-smaller				;Always prefer something a little small.
	  (list best-smaller best-smaller-scale)
	  (list best-bigger best-bigger-scale)))))

(defmethod (:draw-string-size graphics-mixin) (string &optional style size)
  (declare (values string-width char-width string-height line-height baseline))
  (setq style (if style
		  (si:merge-character-styles style merged-current-style)
		  merged-current-style))
  (let* (cw cwa font-height font-baseline index font char-in-font fast-index
	 (first-time 't)
	 (string-width 0)
	 (char-width 0)
	 (string-height 0)
	 (baseline 0)
	 (below-baseline 0)
	 (scale-x nil) (scale-y nil)
	 (char-scale-x nil) (char-scale-y nil)
	 (font-scale-x 1) (font-scale-y 1))
    ;; If a size override is given, we must choose the font that will really get used
    ;; according to the current scale, then scale back down the returned values so that
    ;; they'll be in user space units, as required.
    (when size
      (multiple-value (nil scale-x scale-y)
	(graphics:decompose-transform (graphics:stream-transform self)))
      (setq scale-x (abs scale-x)	; Just magnitudes, directions determined elsewhere.
	    scale-y (abs scale-y))
      (setq char-scale-x (* size scale-x)
	    char-scale-y (* size scale-y)))
    (loop for ch being the array-elements of string do
      (when (or first-time
		(null (setq index (si:%chars-share-device-font-p ch char-in-font
								 fast-index))))
	;; We've just changed font.  Get all the necessary information, once.
	(if size
	    (multiple-value-bind (char-set char-index)
		(si:char-char-set-and-index ch)
	      (setq index char-index)
	      (multiple-value (font font-scale-x font-scale-y)
		(font-of-approximately-this-size self char-set
						 (si:merge-character-styles (si:char-style ch)
									    style)
						 char-scale-x char-scale-y)))
	    (multiple-value (index font)
	      (si:lookup-index-and-font ch display-device-type style)))
	(setq char-in-font ch)
	(setq fast-index (si:%char-subindex-is-index-p char-in-font))
	(when font
	  (setq cw (font-char-width font)
		cwa (font-char-width-table font)
		font-height (* font-scale-y (font-char-height font))
		font-baseline (* font-scale-y (font-baseline font))
		below-baseline (max below-baseline (- font-height font-baseline))
		baseline (max baseline font-baseline)))
	;; new font values are initialized.
	(setq first-time nil))
      ;; still in same font; just add up values.
      (when (and font (graphic-char-p ch))	;only count printing characters
	(incf string-height font-height)
	(let ((ch-cw (* font-scale-x (compute-char-width index cwa cw))))
	  (incf string-width ch-cw)
	  (setq char-width (max char-width ch-cw)))))
    (if size
	(values (//-no-ratios string-width scale-x)
		(//-no-ratios char-width scale-x)
		(//-no-ratios string-height scale-y)
		(//-no-ratios (+ baseline below-baseline) scale-y)
		(//-no-ratios baseline scale-y))
	(values string-width char-width
		string-height (+ baseline below-baseline) baseline))))

(defmethod (graphics::default-draw-string-image graphics-mixin)
	   (string x y
		   &rest args
		   &key (attachment-x :left) (attachment-y :baseline)
			(character-style nil) (character-size nil) (string-width nil)
			(scale-down-allowed t))
  (graphics:with-drawing-state (self
				 :opaque (and (or (graphics::with-standardized-source-and-alu
						    (pattern alu nil)
						    (or (not (null pattern))
							(eql alu erase-aluf)))
						  (graphics::drawing-state-color
						    graphics::drawing-state))
					      (graphics::drawing-state-opaque
						graphics::drawing-state)))
    (let* (cw cwa rw fit lkt font-height font-baseline index font char-in-font fast-index
	   char-scale-x char-scale-y
	   font-scale-x font-scale-y
	   space-scale font-space-scale
	   (style (if character-style
		      (si:merge-character-styles character-style merged-current-style)
		      merged-current-style))
	   (first-time 't))
      (multiple-value-bind (rotation scale-x scale-y)
	  (graphics:decompose-transform (graphics:stream-transform self))
	(setq space-scale scale-x)
	(unless (and (eq attachment-x :left) (eq attachment-y :baseline)
		     (null string-width))
	  (multiple-value-bind (adjusted-x nil nil nil adjusted-y nil nil computed-width)
	      (lexpr-funcall #'graphics::draw-string-bounding-box string x y args)
	    (setq x adjusted-x
		  y (- y (- adjusted-y y)))	;draw-string-bounding-box thinks upside down.
	    (when string-width
	      (setq space-scale (//-no-ratios (* scale-x computed-width) string-width)))))
	(if character-size
	    (setq char-scale-x (* scale-x character-size)
		  char-scale-y (* scale-y character-size))
	    (setq font-scale-x scale-x
		  font-scale-y scale-y))
	(loop for ch being the array-elements of string do
	  (when (or first-time
		    (null (setq index (si:%chars-share-device-font-p ch char-in-font
								     fast-index))))
	    ;; We've just changed font.  Get all the necessary information, once.
	    (if character-size
		(multiple-value-bind (char-set char-index)
		    (si:char-char-set-and-index ch)
		  (setq index char-index)
		  (multiple-value (font font-scale-x font-scale-y)
		    (font-of-approximately-this-size self char-set
						     (si:merge-character-styles
						       (si:char-style ch)
						       style)
						     char-scale-x char-scale-y)))
		(multiple-value (index font)
		  (si:lookup-index-and-font ch display-device-type style)))
	    (setq char-in-font ch)
	    (setq fast-index (si:%char-subindex-is-index-p char-in-font))
	    (when font
	      (setq cw (font-char-width font)
		    cwa (font-char-width-table font)
		    rw (font-raster-width font)
		    fit (font-indexing-table font)
		    lkt (font-left-kern-table font)
		    font-baseline (font-baseline font)
		    font-height (font-raster-height font)))
	    ;; new font values are initialized.
	    (setq first-time nil)
	    (setq font-space-scale (//-no-ratios font-scale-x space-scale))
	    (flet ((round-scale (x)
		     (if scale-down-allowed
			 ;; Always a smaller font or piece of font, with a 1% tolerance
			 ;; for floating roundoff error.
			 (if (< (abs x) 1) x (truncate (+ x (* (signum x) .01))))
			 ;; Never part of a font, and generally allow slightly larger if
			 ;; better.
			 (* (signum x) (max 1 (round (abs x)))))))
	      (setq font-scale-x (round-scale font-scale-x)
		    font-scale-y (round-scale font-scale-y))))
	  ;; still in same font; draw the glyph
	  (when (and font (graphic-char-p ch))	;Only count printing characters
	    (multiple-value-bind (dx dy)
		(values (if lkt (aref lkt index) 0) font-baseline)
	      (if (and (zerop rotation) (= font-scale-x 1) (= font-scale-y -1))
		  (funcall (flavor:generic graphics:draw-glyph) self
			   index font
			   (- x (//-no-ratios dx scale-x)) (- y (//-no-ratios dy scale-y)))
		  (multiple-value-bind (sx sy)
		      (graphics::stream-transform-point x y self)
		    (graphics:with-graphics-identity-transform (self)
		      (graphics:graphics-translate sx sy :stream self)
		      (graphics:graphics-rotate rotation :stream self)
		      (graphics:graphics-translate (* dx font-scale-x)
						   (* dy font-scale-y)
						   :stream self)
		      (graphics:graphics-scale font-scale-x (- font-scale-y) :stream self)
		      (multiple-value-bind (image-left image-right)
			  (if fit
			      (values (aref fit index) (aref fit (1+ index)))
			      (values (* rw index) (* rw (1+ index))))
			(draw-image-cached-internal self font 0 0
						    :image-left image-left
						    :image-right image-right
						    :image-bottom font-height)))))
	      (incf x (* font-space-scale (compute-char-width index cwa cw)))))))))
  (values x y))

(defvar *draw-image-cache* (cl:make-hash-table :test #'cl:equal))

(defmethod (draw-image-cached-internal graphics-mixin) (image x y
							&key (image-left 0) (image-top 0)
							      image-right image-bottom)
  (when (null *draw-image-cache*)		;Disabled.
    (return-from draw-image-cached-internal
      (funcall (flavor:generic graphics:draw-image) self image x y
	       :image-left image-left :image-top image-top
	       :image-right image-right :image-bottom image-bottom)))
  (multiple-value-bind (rwidth rheight)
      (decode-raster-array image)
    (when (null image-right)
      (setq image-right rwidth))
    (when (null image-bottom)
      (setq image-bottom rheight)))
  (let ((entry
	  (destructuring-bind (a b c d tx ty)
	      (graphics:stream-transform self)
	    (stack-let ((transform (list a b c d 0 0)))
	      (multiple-value (x y)		;Take care of rotation of position.
		(graphics:transform-point x y transform)))
	    ;; Filter out integral translation.  The fraction must still be part of the key,
	    ;; as it affects the edges of the figure.
	    (let ((exact (not
			   graphics::(ldb-test %%scan-conversion-round-coordinates
					       (get-drawing-state-scan-conversion-flags
						 drawing-state)))))
	      (multiple-value-bind (q r)
		  (round tx)
		(incf x q)
		(setq tx (if (and exact (> (abs r) 1e-6)) r 0)))
	      (multiple-value-bind (q r)
		  (round ty)
		(incf y q)
		(setq ty (if (and exact (> (abs r) 1e-6)) r 0))))
	    (stack-let* ((transform (list a b c d tx ty))
			 (key (list* image image-left image-top image-right image-bottom
				     transform)))
	      (let ((entry (gethash key *draw-image-cache*)))
		(when (null entry)
		  (multiple-value-bind (raster left top right bottom)
		      (with-output-to-bitmap (stream :graphics-transform transform)
			(graphics:draw-image image 0 0
					     :image-left image-left :image-top image-top
					     :image-right image-right
					     :image-bottom image-bottom
					     :stream stream))
		    (setq entry (list (list raster left top (- right left) (- bottom top))
				      nil)))
		  (unless (zerop (graphics:decompose-transform transform))	;No rotation
		    (multiple-value-bind (raster left top right bottom)
			(with-output-to-bitmap (stream :graphics-transform transform)
			  (graphics:draw-rectangle 0 0
						   (- image-right image-left)
						   (- image-bottom image-top)
						   :stream stream))
		      (setf (second entry)
			    (list raster left top (- right left) (- bottom top)))))
		  (setf (gethash (copylist key) *draw-image-cache*) entry))
		entry)))))
    (destructuring-bind ((image-raster dx dy width height) background-entry) entry
      (when (and (plusp width) (plusp height))
	(graphics::with-standardized-source-and-alu (drawing-pattern ones-alu zeros-alu)
	  (unless (or (null background-entry) (eql zeros-alu color:alu-noop))
	    ;; Drawing opaque and rotated; cannot just draw image straight, as that would
	    ;; erase too large a field.  First draw a background erasing pattern, then
	    ;; the correct field.
	    (destructuring-bind (background-raster dx dy width height) background-entry
	      (graphics::draw-raster-internal width height background-raster 0 0
					      (round (+ x dx)) (round (+ y dy)) zeros-alu)))
	  (if (null drawing-pattern)
	      (graphics::draw-raster-internal width height image-raster 0 0
					      (round (+ x dx)) (round (+ y dy)) ones-alu)
	      (graphics:with-graphics-identity-transform (self)
		(graphics:draw-image image-raster (+ x dx) (+ y dy)
				     :image-right width :image-bottom height
				     :stream self :opaque nil))))))))

;;;; Stuff that doesn't have any business being a method.

;;; Anything for which there is a method on graphics-mixin must have a corresponding
;;; method on all encapsulating streams that do translation and the like.
;;; Something defined only in terms of send self of other methods can be on
;;; graphics-compatibility-mixin, which is combined into the encapsulating streams themselves.

;;; These are all obsolete.  They all have equivalent graphics:draw- interfaces.
;;; However, they are not defined in terms of those interfaces to insure strict
;;; compatibility of scan conversion.

;;;This never draws any end points, thus it is good for making closed polygons.
;;;Calls the :DRAW-LINE method to do the clipping.
(DEFMETHOD (:DRAW-LINES GRAPHICS-COMPATIBILITY-MIXIN) (ALU X1 Y1 &REST END-XS-AND-YS)
  (DO ((X2) (Y2))
      ((NULL END-XS-AND-YS))
    (SETQ X2 (CAR END-XS-AND-YS)
	  Y2 (CADR END-XS-AND-YS)
	  END-XS-AND-YS (CDDR END-XS-AND-YS))
    (SEND SELF ':DRAW-LINE X1 Y1 X2 Y2 ALU NIL)
    (SETQ X1 X2
	  Y1 Y2)))

(DEFMETHOD (:DRAW-ARROW GRAPHICS-COMPATIBILITY-MIXIN)
	   (FROM-X FROM-Y TO-X TO-Y &OPTIONAL (ALU :DRAW)
		   (ARROW-HEAD-LENGTH *DEFAULT-ARROW-LENGTH*)
		   (ARROW-BASE-WIDTH  *DEFAULT-ARROW-WIDTH*))
  "Draws a line with an arrow-head at the endpoint."
  (LET* ((X             (- TO-X FROM-X))
	 (Y             (- TO-Y FROM-Y))
	 (LENGTH-OF-LINE (SQRT (+ (ZL:EXPT X 2.) (ZL:EXPT Y 2.)))))
    (UNLESS (ZEROP LENGTH-OF-LINE)
      ;; if length-of-line = 0, we don't do anything! (and return nil)
      (LET* (;; angle of inclination of the line
	     (COS-THETA (// X LENGTH-OF-LINE))
	     (SIN-THETA (// Y LENGTH-OF-LINE))
	     ;; coords of center of base of arrowhead, where the line enters it
	     (X-BASE    (- TO-X (* ARROW-HEAD-LENGTH COS-THETA)))
	     (Y-BASE    (- TO-Y (* ARROW-HEAD-LENGTH SIN-THETA)))
	     ;; changes in x and y from arrow base to corners
	     (X-CORNER (// (* ARROW-BASE-WIDTH SIN-THETA) 2.0))
	     (Y-CORNER (// (* ARROW-BASE-WIDTH COS-THETA) -2.0)))
	;; draw the line -- don't overlap with arrowhead in case
	;; alu is alu-xor or something
	(SEND SELF :DRAW-LINE FROM-X FROM-Y (ROUND X-BASE) (ROUND Y-BASE) ALU)
	;; draw the arrowhead
	(SEND SELF :DRAW-TRIANGLE
	      TO-X                             TO-Y
	      (ROUND (+ X-BASE X-CORNER))     (ROUND (+ Y-BASE Y-CORNER))
	      (ROUND (+ X-BASE (- X-CORNER))) (ROUND (+ Y-BASE (- Y-CORNER)))
	      ALU))
      ;; return t if actually drew something
      T)))

(DEFMETHOD (:DRAW-DASHED-ARROW GRAPHICS-COMPATIBILITY-MIXIN)
	   (FROM-X FROM-Y TO-X TO-Y &OPTIONAL (ALU :DRAW)
		   (ARROW-HEAD-LENGTH *DEFAULT-ARROW-LENGTH*)
		   (ARROW-BASE-WIDTH  *DEFAULT-ARROW-WIDTH*)
		   ;; defaults from :draw-dashed-line
		   (DASH-SPACING 20.) 
		   (SPACE-LITERALLY-P NIL)
		   (OFFSET 0.)
		   (DASH-LENGTH (// DASH-SPACING 2.)))
  
  "Draws a line with an arrow-head at the endpoint."
  (LET* ((X             (- TO-X FROM-X))
	 (Y             (- TO-Y FROM-Y))
	 (LENGTH-OF-LINE (SQRT (+ (ZL:EXPT X 2.) (ZL:EXPT Y 2.)))))
    (UNLESS (ZEROP LENGTH-OF-LINE)
      ;; if length-of-line = 0, we do nothing and return nil
      (LET* (;; angle of inclination of the line
	     (COS-THETA (// X LENGTH-OF-LINE))
	     (SIN-THETA (// Y LENGTH-OF-LINE))
	     ;; coords of center of base of arrowhead, where the line enters
	     (X-BASE    (- TO-X (* ARROW-HEAD-LENGTH COS-THETA)))
	     (Y-BASE    (- TO-Y (* ARROW-HEAD-LENGTH SIN-THETA)))
	     ;; changes in x and y from arrow base to corners
	     (X-CORNER (// (* ARROW-BASE-WIDTH SIN-THETA) 2.0))
	     (Y-CORNER (// (* ARROW-BASE-WIDTH COS-THETA) -2.0)))
	;; draw the line -- don't overlap with arrowhead in case 
	;; alu is alu-xor or something
	(SEND SELF :DRAW-DASHED-LINE FROM-X FROM-Y (ROUND X-BASE) (ROUND Y-BASE) ALU
	      DASH-SPACING SPACE-LITERALLY-P OFFSET DASH-LENGTH)
	;; draw the arrowhead
	(SEND SELF :DRAW-TRIANGLE
	      TO-X                             TO-Y
	      (ROUND (+ X-BASE X-CORNER))     (ROUND (+ Y-BASE Y-CORNER))
	      (ROUND (+ X-BASE (- X-CORNER))) (ROUND (+ Y-BASE (- Y-CORNER)))
	      ALU))
      ;; return t if actually drew something
      T)))

(DEFMETHOD (:DRAW-ARROWS GRAPHICS-COMPATIBILITY-MIXIN) (ALU &REST X-Y-PAIRS)
  "Like :draw-lines, but with arrows instead."
  ;; dunno 'bout how many times the endpoints are drawn
  ;; bug: no way to set width & height of arrow head
  ;; (other than -binding *default-arrow-length*, etc.)
  (LOOP FOR (X-START Y-START) ON X-Y-PAIRS        BY #'CDDR
	FOR (X-END   Y-END)   ON (CDDR X-Y-PAIRS) BY #'CDDR
	DOING
    (SEND SELF :DRAW-ARROW X-START Y-START X-END Y-END ALU)))

(DEFMETHOD (:DRAW-DASHED-ARROWS GRAPHICS-COMPATIBILITY-MIXIN) (ALU &REST X-Y-PAIRS)
  "Like :draw-lines, but with dashed arrows."
  ;; dunno 'bout how many times the endpoints are drawn
  ;; bug: no way to set width & height of arrow head (or dash stuff, either)
  (LOOP FOR (X-START Y-START) ON X-Y-PAIRS        BY #'CDDR
	FOR (X-END   Y-END)   ON (CDDR X-Y-PAIRS) BY #'CDDR
	DOING
    (SEND SELF :DRAW-DASHED-ARROW X-START Y-START X-END Y-END ALU)))

;;; These DRAW-FAT-LINE methods are useful on interlaced screens, where strong
;;; features such as lines look bad if they are only one pixel thick.
(defmethod (:draw-fat-circle graphics-compatibility-mixin)  (x y  radius  alu)
  (send self :draw-circle  x      y  radius  alu)
  (send self :draw-circle  (1- x) y  radius  alu)
  (send self :draw-circle  x (1- y)  radius  alu))

(defmethod (:draw-fat-line graphics-compatibility-mixin)
	   (from-x from-y to-x to-y &optional (alu :draw) (draw-end-point t))
  (send self :draw-line from-x from-y to-x to-y alu draw-end-point)
  (send self :draw-line (1+ from-x) from-y (1+ to-x) to-y alu draw-end-point)
  (send self :draw-line from-x (1+ from-y) to-x (1+ to-y) alu draw-end-point))

(defmethod (:draw-fat-lines graphics-compatibility-mixin) (alu &rest args)
  (lexpr-send self :draw-lines alu args)
  (loop for i on args by #'cddr do (setf (car i) (1+ (car i))))
  (lexpr-send self :draw-lines alu args)
  (loop for i on args by #'cddr do (setf (car i) (1- (car i))) (setf (cadr i) (1+ (cadr i))))
  (lexpr-send self :draw-lines alu args))

;;; Given an edge and a number of sides, draw something
;;; The sign of N determines which side of the line the figure is drawn on.
;;; If the line is horizontal, the rest of the polygon is in the positive direction
;;; when N is positive.
(DEFMETHOD (:DRAW-REGULAR-POLYGON GRAPHICS-MIXIN) (X1 Y1 X2 Y2 N &OPTIONAL (ALU :DRAW)
								 &AUX THETA)
  (SETF ALU (GRAPHICS::STANDARDIZE-ALU SELF ALU))
  (SETQ THETA (* 3.14159 (1- (// 2.0 N)))
	N (ABS N))  
  (PREPARE-SHEET (SELF)
    (DO ((I 2 (1+ I))
	 (SIN-THETA (SIN THETA))
	 (COS-THETA (COS THETA))
	 (X0 X1) (Y0 Y1)
	 (X3) (Y3))
	(( I N))
      (SETQ X3 (+ (- (- (* X1 COS-THETA)
			(* Y1 SIN-THETA))
		     (* X2 (1- COS-THETA)))
		  (* Y2 SIN-THETA))
	    Y3 (- (- (+ (* X1 SIN-THETA)
			(* Y1 COS-THETA))
		     (* X2 SIN-THETA))
		  (* Y2 (1- COS-THETA))))
      (LEXPR-SEND SCREEN :%DRAW-TRIANGLE
		  (+ (SHEET-INSIDE-LEFT) (ROUND X0))
		  (+ (SHEET-INSIDE-TOP) (ROUND Y0))
		  (+ (SHEET-INSIDE-LEFT) (ROUND X2))
		  (+ (SHEET-INSIDE-TOP) (ROUND Y2))
		  (+ (SHEET-INSIDE-LEFT) (ROUND X3))
		  (+ (SHEET-INSIDE-TOP) (ROUND Y3))
		  ALU SELF CLIPPING-REGION)
      (SETQ X1 X2 Y1 Y2
	    X2 X3 Y2 Y3))))

;;
;; A convex polygon is one which is convex from the perspective of its first
;; vertex.  Given this, we can just draw triangles without checking for intersections
;; and so on.
;;
(DEFMETHOD (:DRAW-CONVEX-POLYGON GRAPHICS-COMPATIBILITY-MIXIN)
	   (ALU &REST POINTS)
  (LEXPR-SEND SELF :TRIANGULATE-CONVEX-POLYGON :DRAW-TRIANGLE ALU POINTS))

(DEFMETHOD (:TRIANGULATE-CONVEX-POLYGON GRAPHICS-COMPATIBILITY-MIXIN)
	   (MESSAGE ALU &REST POINTS)
  (LOOP WITH P = POINTS
	AND X1 AND Y1 AND X2 AND Y2 AND X3 AND Y3
	INITIALLY
	(POP P X1)
	(POP P Y1)
	(POP P X3)
	(POP P Y3)
	WHILE P
	DO
	(SETQ X2 X3
	      Y2 Y3)
	(POP P X3)
	(POP P Y3)
	(SEND SELF MESSAGE X1 Y1 X2 Y2 X3 Y3 ALU)))

(DEFMETHOD (:DRAW-POLYGON GRAPHICS-COMPATIBILITY-MIXIN) (ALU &REST POINTS)
  (OR ALU (SETQ ALU :DRAW))
  (LEXPR-SEND SELF :TRIANGULATE-POLYGON :DRAW-TRIANGLE ALU POINTS))


(DEFMETHOD (:DRAW-TRIANGULAR-OUTLINE GRAPHICS-COMPATIBILITY-MIXIN)
	   (X1 Y1 X2 Y2 X3 Y3 &OPTIONAL (ALU :DRAW))
  (SEND SELF :DRAW-LINES ALU X1 Y1 X2 Y2 X3 Y3 X1 Y1))

(defmethod (:triangulate-polygon graphics-compatibility-mixin) (message alu &rest points)
  (graphics::triangulate-polygon #'(lambda (x1 y1 x2 y2 x3 y3)
				     (send self message x1 y1 x2 y2 x3 y3 alu))
				 points))

(deff line-intersection #'graphics::line-intersection)

;;; Display vectors of points
(DEFMETHOD (:DRAW-CURVE GRAPHICS-COMPATIBILITY-MIXIN) (PX PY &OPTIONAL END (ALU :DRAW))
  (OR END (SETQ END (ARRAY-ACTIVE-LENGTH PX)))
  (DO ((I 1 (1+ I))
       (X0)
       (X1 (FIX (AREF PX 0)))
       (Y0)
       (Y1 (FIX (AREF PY 0))))
      (( I END))
    (SETQ X0 X1)
    (OR (SETQ X1 (AREF PX I)) (RETURN NIL))
    (SETQ X1 (FIX X1))
    (SETQ Y0 Y1)
    (OR (SETQ Y1 (AREF PY I)) (RETURN NIL))
    (SETQ Y1 (FIX Y1))
    (SEND SELF :DRAW-LINE X0 Y0 X1 Y1 ALU NIL)))

(DEFMETHOD (:DRAW-CLOSED-CURVE GRAPHICS-COMPATIBILITY-MIXIN)
	   (PX PY &OPTIONAL END (ALU :DRAW))
  (OR END (SETQ END (ARRAY-ACTIVE-LENGTH PX)))
  (DO ((I 1 (1+ I))
       (X0)
       (X1 (FIX (AREF PX 0)))
       (Y0)
       (Y1 (FIX (AREF PY 0))))
      (( I END)
       (SEND SELF ':DRAW-LINE X1 Y1 (FIX (AREF PX 0)) (FIX (AREF PY 0)) ALU NIL))
    (SETQ X0 X1)
    (OR (SETQ X1 (AREF PX I)) (RETURN NIL))
    (SETQ X1 (FIX X1))
    (SETQ Y0 Y1)
    (OR (SETQ Y1 (AREF PY I)) (RETURN NIL))
    (SETQ Y1 (FIX Y1))
    (SEND SELF ':DRAW-LINE X0 Y0 X1 Y1 ALU NIL)))

;;; Version from Mabry Tyson.  This draws the same points, but not necessarily the same
;;; number of times.  I think this is safe within the guidelines of compatibility, as a bug
;;; fix, whereas doing it as graphics:draw-lines :thickness curve-width might not be.
(defmethod (:draw-wide-curve graphics-mixin) (px py curve-width &optional end (alu :draw))
  (setf alu (graphics::standardize-alu self alu))
  (let (x0 y0					;Previous point
	x1 y1					;Current point
	dx dy ex0 ey0 ex1 ey1 s			;change in x,y from previous to current point
						; a point (ex0,ey0) on one edge of wide curve between these two points
						; and a point (ex1,ey1) on the other edge
						; and the slant of the current line
	firstex0 firstey0 firstex1 firstey1 	;Saved values of the above for the first line
	secondpx0 secondpy0 secondpx1 secondpy1
	odx ody oex0 oey0 oex1 oey1 os		;the values of the above for the previous line
	px0 py0 px1 py1				;the two points that properly terminate the previous edge lines
						; and start the current ones
	opx0 opy0 opx1 opy1			;the previous points of those points
	len ddy ddx)
    (macrolet (
      ;;
      ;; returns dx, dy, x and y of a point on lines parallel on either side of the line
      ;; specified by points (x0,y0) and (x1,y1) and separated from it by current-width
      ;; Points are on the perpendicular through the (x0,y0) point
      ;;		   
      (COMPUTE-SLOPE-POINTS-OFF ()
	'(progn
	   (setq dx (- x1 x0)
		 dy (- y1 y0)
		 len (sqrt (+ (* dx dx) (* dy dy))))
	   (setq ddy (// (* curve-width dx) len)
		 ddx (// (* curve-width dy) len))
	   (setq ex0 (- x0 ddx)			;point on right of directed line
		 ey0 (+ y0 ddy)
		 ex1 (+ x0 ddx)			;point on left of directed line
		 ey1 (- y0 ddy))
	   (if ( dx 0) (setq s (// dy (float dx)))))
	   )
      ;;
      ;; this function computes the points that we need.  These are the points that
      ;; define the ends of the triangles near the previous point (x0,y0).
      ;;
      (COMPUTE-POINTS ()
       '(progn
	  (cond ((= dx 0)
	       (if (= odx 0)
		   (setq px0 ex0		;x's don't change.  Note that ex0 = oex0.
			 py0 y0
			 px1 ex1
			 py1 y0)
		   (setq px0 ex0		;x's don't change
			 py0 (+ (* os (- ex0 oex0)) oey0)
			 px1 ex1
			 py1 (+ (* os (- ex1 oex1)) oey1))
		   ))
	      ((= odx 0)
	       ;; dx = 0 already caught
	       (setq px0 oex0			;x's don't change
		     py0 (+ (* s (- opx0 ex0)) ey0)
		     px1 oex1
		     py1 (+ (* s (- opx1 ex1)) ey1)
		     px1 px1)
	       )
	      (t (if (< (abs (- s os)) 0.0001)	;The pair of segments are nearly in line with each other
		     ;; Straight line, pick the point on the perp to joining point
		     ;; This happens to be the edge points returned above
		     (setq px0 ex0
			   py0 ey0
			   px1 ex1
			   py1 ey1)
		     ;; Normal case.
		     (setq px0 (// (- (+ ey0 (* os oex0)) (* s ex0) oey0)
				   (- os s))
			   py0 (+ (* s px0) (- ey0 (* s ex0)))
			   px1 (// (- (+ ey1 (* os oex1)) (* s ex1) oey1)
				   (- os s))
			   py1 (+ (* s px1) (- ey1 (* s ex1)))))))
	  ))
      )
      (flet (
       ;;
       ;; Draw the triangles
       ;;
       (DRAW-TRIANGLES ()
	 (declare (sys:downward-function))
	 (sheet-draw-triangle (+ (sheet-inside-left) (fix opx0))
			      (+ (sheet-inside-top) (fix opy0))
			      (+ (sheet-inside-left) (fix opx1))
			      (+ (sheet-inside-top) (fix opy1))
			      (+ (sheet-inside-left) (fix px1))
			      (+ (sheet-inside-top) (fix py1))
			      alu self
			      (sheet-inside-left) (sheet-inside-top)
			      (sheet-inside-right) (sheet-inside-bottom))
	 (sheet-draw-triangle (+ (sheet-inside-left) (fix opx0))
			      (+ (sheet-inside-top) (fix opy0))
			      (+ (sheet-inside-left) (fix px0))
			      (+ (sheet-inside-top) (fix py0))
			      (+ (sheet-inside-left) (fix px1))
			      (+ (sheet-inside-top) (fix py1))
			      alu self
			      (sheet-inside-left) (sheet-inside-top)
			      (sheet-inside-right) (sheet-inside-bottom)))
       )
	(flet (
	 ;;
	 ;; presume x1, y1 were just set.  Do all the necessary stuff
	 ;; Normally i is the index into the x,y arrays but i is only used
	 ;; in here for determining what to do.
	 ;;
	 (INNER-LOOP (i)
	  (declare (sys:downward-function))
	  (cond ((= i 0)
		 ;; Do nothing now...
		 )
		(t 
		 ;; Compute the slope, and find points on either edge of filled region
		 (compute-slope-points-off)	;Sets Exi, DX, DY, S
		   (cond ((= i 1)
			  ;; First line segment, wait for later to draw it but save the variables
			  (setq firstex0 ex0
				firstey0 ey0
				firstex1 ex1
				firstey1 ey1
				)
			  (setq opx0 ex0
				opy0 y0
				opx1 ex1
				opy1 y0)
			  )
			 (t
			  ;; We now know the current edges of the filled region and we know the
			  ;; edges of the previous one, so figure out where to join them up
			  ;; These points are near the previous point (ie, at point 3, we are computing
			  ;; the correct location of the points near point 2 so we can draw the line
			  ;; from point 1 to point 2)
			  (compute-points)
			  (cond ((= i 2)
				 (setq secondpx0 px0
				       secondpy0 py0
				       secondpx1 px1
				       secondpy1 py1))
				(t		;Only now can we start drawing things in...
				 ;; now we have 4 points so draw the triangles
				 (draw-triangles)
				 ))
			  (setq opx0 px0	;Save the values for next time around
				opy0 py0
				opx1 px1
				opy1 py1)))
		     (setq odx dx
			 ody dy
			 oex0 ex0
			 oey0 ey0
			 oex1 ex1
			 oey1 ey1
			 os s)))
	  (setq x0 x1
		y0 y1)
	  ))
	;;
	;; here beginneth the real code...
	;;
	(or end (setq end (array-active-length px)))
	(setq curve-width (// curve-width 2.0s0))
	(prepare-sheet (self)
	  (loop with nth = 0 and nx=1 and ny=1 and nx=2 and ny=2
		for i from 0 to (1- end)
		while (setq x1 (aref px i))
		while (setq y1 (aref py i))
		do (unless (and (eql x1 x0)(eql y0 y1))
		     (inner-loop nth)
		     (cond ((= nth 1) (setq nx=1 x0 ny=1 y0))
			   ((= nth 2) (setq nx=2 x0 ny=2 y0)))
		     (incf nth)
		     )
		finally
		  (setq end nth)			;The true end
		  ;; Now comes the tricky part.  First see if this is a closed curve.
		  (cond ((< nth 2)		;If not at least 2, then nothing drawn
			 nil)
			((and (= x0 (aref px 0))	;x0,y0 was last thing we did...
			      (= y0 (aref py 0))	;See if closed curve...
			      (> nth 2))
			 (setq x1 nx=1
			       y1 ny=1)
			 (inner-loop 3)		;This draws the last line
			 (setq x1 nx=2
			       y1 ny=2)
			 (inner-loop 3)		;This draws the first line
			 )
			(t			;Not a closed curve.  Just punt...
			 (when (> nth 2)
			   (setq x1 (+ x0 odx)	;Make like there is a next segment which is an extension of current line
				 y1 (+ y0 ody))
			   (inner-loop 3))	;Draws the last segment.
			 (setq opx0 firstex0
			       opy0 firstey0
			       opx1 firstex1
			       opy1 firstey1)
			 (if (= nth 2)
			     (setq px0 (+ x1 (- opx0 (aref px 0))) ;use the same offsets as before but based off current point
				   py0 (+ y1 (- opy0 (aref py 0)))
				   px1 (+ x1 (- opx1 (aref px 0)))
				   py1 (+ y1 (- opy1 (aref py 0))))
			     (setq px0 secondpx0	;If we had at least 2 segments, we got these already
				   py0 secondpy0
				   px1 secondpx1
				   py1 secondpy1))
			 (draw-triangles)	;So go draw the first segment
			  )))))))))

(defun spline (&rest args)
  (declare (arglist px py z &optional cx cy (c1 :relaxed) (c2 c1)
		    p1-prime-x p1-prime-y pn-prime-x pn-prime-y))
  (apply #'graphics:compute-cubic-spline args))

(DEFMETHOD (:DRAW-CUBIC-SPLINE GRAPHICS-COMPATIBILITY-MIXIN)
	   (PX PY Z &OPTIONAL CURVE-WIDTH ALU (C1 ':RELAXED) (C2 C1)
	               P1-PRIME-X P1-PRIME-Y PN-PRIME-X PN-PRIME-Y)
  (WHEN (NULL CURVE-WIDTH)
    (SETQ CURVE-WIDTH 1))
  (WHEN (NULL ALU)
    (SETQ ALU :DRAW))
  (MULTIPLE-VALUE-BIND (CX CY I)
      (SPLINE PX PY Z NIL NIL C1 C2 P1-PRIME-X P1-PRIME-Y PN-PRIME-X PN-PRIME-Y)
    (IF (= CURVE-WIDTH 1)
	(SEND SELF :DRAW-CURVE CX CY I ALU)
	(SEND SELF :DRAW-WIDE-CURVE CX CY CURVE-WIDTH I ALU))))


(defun draw-glyph-centered (index font x y height width baseline window x-lim y-lim alu)
  (let ((new-x (- x (// width 2)))
	(new-y (- y baseline)))
    (unless (or ( new-x x-lim)
		( new-y y-lim)
		( (+ new-x width) 0)
		( (+ new-y height) 0))
      (send window :draw-glyph index font new-x new-y alu))))

(defun draw-glyph-to-right (index font x y height width baseline window x-lim y-lim alu)
  (let ((new-x x)
	(new-y (- y baseline)))
    (unless (or ( new-x x-lim)
		( new-y y-lim)
		( (+ new-x width) 0)
		( (+ new-y height) 0))
      (send window :draw-glyph index font new-x new-y alu))))

(defun draw-glyph-to-left (index font x y height width baseline window x-lim y-lim alu)
  (let ((new-x (- x width))
	(new-y (- y baseline)))
    (unless (or ( new-x x-lim)
		( new-y y-lim)
		( (+ new-x width) 0)
		( (+ new-y height) 0))
      (send window :draw-glyph index font new-x new-y alu))))

(defmethod (:draw-multiple-lines graphics-mixin) (lines
						  &optional (alu :draw) (draw-end-point t))
  (setf alu (graphics::standardize-alu self alu))
  (let ((length (cl:length lines))
	(output 0))
    (stack-let ((clipped (make-array length :type 'sys:art-16b)))
      (declare (sys:array-register clipped))
      (cl:etypecase lines
	(cl:list
	  (loop for index below length by 4 do
	    (let* ((x1 (pop lines))
		   (y1 (pop lines))
		   (x2 (pop lines))
		   (y2 (pop lines)))
	      (multiple-value (x1 y1 x2 y2)
		(clip-and-offset-line x1 y1 x2 y2))
	      (when x1
		(setf (aref clipped output) x1)
		(incf output)
		(setf (aref clipped output) y1)
		(incf output)
		(setf (aref clipped output) x2)
		(incf output)
		(setf (aref clipped output) y2)
		(incf output)))))
	(cl:vector
	  (let ((lines lines))
	    (declare (sys:array-register lines))
	    (loop for index below length by 4 do
	      (let ((x1 (aref lines (+ index 0)))
		    (y1 (aref lines (+ index 1)))
		    (x2 (aref lines (+ index 2)))
		    (y2 (aref lines (+ index 3))))
		(multiple-value (x1 y1 x2 y2)
		  (clip-and-offset-line x1 y1 x2 y2))
		(when x1
		  (setf (aref clipped output) x1)
		  (incf output)
		  (setf (aref clipped output) y1)
		  (incf output)
		  (setf (aref clipped output) x2)
		  (incf output)
		  (setf (aref clipped output) y2)
		  (incf output)))))))
      (when (plusp output)
	(unless (= output length)
	  (adjust-array-size clipped output))
	(prepare-sheet (self)
	  (send screen :%draw-multiple-lines self alu clipped draw-end-point))))))

(defmethod (:draw-multiple-rectangles graphics-mixin) (rectangles &optional (alu :draw))
  (setf alu (graphics::standardize-alu self alu))
  (let ((length (cl:length rectangles))
	(output 0))
    (stack-let ((clipped (make-array length :type 'sys:art-16b)))
      (declare (sys:array-register clipped))
      (let ((inside-dx (sheet-inside-left))
	    (inside-dy (sheet-inside-top)))
	(destructuring-bind (inside-left inside-top inside-right inside-bottom) clipping-region
	  (cl:etypecase rectangles
	    (cl:list
	      (loop for index below length by 4 do
		(let* ((left (pop rectangles))
		       (top  (pop rectangles))
		       (right  (pop rectangles))
		       (bottom (pop rectangles)))
		  (setq left (max inside-left (+ left inside-dx))
			top (max inside-top (+ top inside-dy))
			right (min inside-right (+ right inside-dx))
			bottom (min inside-bottom (+ bottom inside-dy)))
		  (when (and (> right left) (> bottom top))
		    (setf (aref clipped output) left)
		    (incf output)
		    (setf (aref clipped output) top)
		    (incf output)
		    (setf (aref clipped output) right)
		    (incf output)
		    (setf (aref clipped output) bottom)
		    (incf output)))))
	    (cl:vector
	      (let ((rectangles rectangles))
		(declare (sys:array-register rectangles))
		(loop for index below length by 4 do
		  (let ((left (aref rectangles (+ index 0)))
			(top  (aref rectangles (+ index 1)))
			(right  (aref rectangles (+ index 2)))
			(bottom (aref rectangles (+ index 3))))
		    (setq left (max inside-left (+ left inside-dx))
			  top (max inside-top (+ top inside-dy))
			  right (min inside-right (+ right inside-dx))
			  bottom (min inside-bottom (+ bottom inside-dy)))
		    (when (and (> right left) (> bottom top))
		      (setf (aref clipped output) left)
		      (incf output)
		      (setf (aref clipped output) top)
		      (incf output)
		      (setf (aref clipped output) right)
		      (incf output)
		      (setf (aref clipped output) bottom)
		      (incf output)))))))))
      (when (plusp output)
	(unless (= output length)
	  (adjust-array-size clipped output))
	(prepare-sheet (self)
	  (send screen :%draw-multiple-rectangles self alu clipped))))))
