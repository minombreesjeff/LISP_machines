;;; -*- Syntax: Zetalisp; Mode: LISP; Package: TV; Base: 10 -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Define a blinker on a piece of paper
(DEFUN MAKE-BLINKER (SHEET &OPTIONAL (TYPE 'RECTANGULAR-BLINKER) &REST OPTIONS)
  (LEXPR-FUNCALL #'MAKE-INSTANCE TYPE :SHEET SHEET OPTIONS))

(DEFF DEFINE-BLINKER 'MAKE-BLINKER) ;Keep old name for compatibility.
(COMPILER:MAKE-OBSOLETE DEFINE-BLINKER "it has been renamed to TV:MAKE-BLINKER")

(DEFMETHOD (:INIT BLINKER) (IGNORE)
  (UNLESS (OR FOLLOW-P X-POS)
    (SETQ X-POS (SHEET-CURSOR-X SHEET)
	  Y-POS (SHEET-CURSOR-Y SHEET)))
  (WHEN (NULL BLINKER-ALU)
    (MULTIPLE-VALUE-BIND (NIL NIL XR)
	(SEND SHEET :DEFAULT-INFERIOR-ALUFS)
      (SETQ BLINKER-ALU (OR XR TV:ALU-XOR))))
  (WITHOUT-INTERRUPTS
    (WITH-STACK-LIST* (NEW SELF (SHEET-BLINKER-LIST SHEET))
      ;; These lists never get that long, so always copy to localize.  
      (SETF (SHEET-BLINKER-LIST SHEET) (COPYLIST NEW)))))

(DEFMETHOD (:INIT RECTANGULAR-BLINKER :BEFORE) (IGNORE &AUX FONT)
  (SETQ FONT (SI:CACHE-LOOKUP (SHEET-CHARSET&STYLEFONT-CACHE SHEET)
			      #'SI:GET-FONT
			      (SHEET-DISPLAY-DEVICE-TYPE SHEET)
			      SI:*STANDARD-CHARACTER-SET*
			      (SHEET-MERGED-CURRENT-STYLE SHEET)))
  (OR WIDTH (SETQ WIDTH (FONT-BLINKER-WIDTH FONT)))
  (OR HEIGHT (SETQ HEIGHT (FONT-BLINKER-HEIGHT FONT))))

(DEFMETHOD (:SIZE RECTANGULAR-BLINKER) ()
  (VALUES WIDTH HEIGHT))


;;; Make mouse blinker stay off for a short time after it really could come back on
;;; so that it flashed less obnoxiously.  I don't know if it will really help, but
;;; it's certainly true that at 1/2 second it doesn't flash anywhere near as much in
;;; the editor.
(DEFVAR *MOUSE-BLINKER-OFF-TIME* 0)
(DEFVAR *MOUSE-BLINKER-WAIT-TIME* -1)

;;; Make a blinker temporarily disappear from the screen.
;;; Anything that moves it or changes its parameters should call this.
;;; When the next clock interrupt happens with the sheet lock clear,
;;; the blinker will come back on.  This is independent of the time until next
;;; blink, in order to provide the appearance of fast response.
;;; Anyone who calls this should have locked the sheet.
;;; This is a noop if the sheet the blinker is on is output held.
(DEFVAR *BLINKER-CLOSE-DELAY-TIME* 4)

(DEFMETHOD (OPEN-BLINKER BLINKER) ()
  (COND (PHASE
	 (WHEN (SHEET-OUTPUT-HELD-P SHEET)
	   (FSIGNAL "OPEN-BLINKER with sheet output-held."))
	 (BLINK SELF)
	 (SETF TIME-UNTIL-BLINK *BLINKER-CLOSE-DELAY-TIME*))
	(T
	 (SCL:MAXF TIME-UNTIL-BLINK *BLINKER-CLOSE-DELAY-TIME*)))
  (LET ((MOUSE (SHEET-MOUSE SHEET)))
    (WHEN (AND MOUSE (EQ SELF (MOUSE-BLINKER MOUSE)))
      (SETF (MOUSE-BLINKER-OFF-TIME MOUSE) 0)
      (OPEN-MOUSE-CURSOR MOUSE))))

(DEFMETHOD (WITH-BLINKER-PREPARED-INTERNAL BLINKER)
	   (CONTINUATION &KEY (OPEN NIL OPEN-P) (WHEN NIL WHEN-P))
  (WHEN (OR (NOT WHEN-P) (AND WHEN (FUNCALL WHEN)))
    (WITH-SCREEN-CONTROLLER-LOCK ((SHEET-SCREEN SHEET))
      (DO () ((OR (NULL PHASE)
		  (NOT (SHEET-OUTPUT-HELD-P SHEET))))
	(WITHOUT-SCREEN-CONTROLLER-LOCK ((SHEET-SCREEN SHEET))
	  (SEND SHEET :OUTPUT-HOLD-EXCEPTION)))
      (COND ((AND PHASE
		  (OR (NOT OPEN-P) (AND OPEN (FUNCALL OPEN))))
	     (OPEN-BLINKER SELF)
	     (FUNCALL CONTINUATION)
	     (WHEN (AND (NOT PHASE)
			(OR (EQ VISIBILITY T) (EQ VISIBILITY :ON))
			(NOT (SHEET-OUTPUT-HELD-P SHEET)))
	       (BLINK SELF)))
	    (T
	     (FUNCALL CONTINUATION))))))

;;; This function should get called by the clock about every 60th of a second.
;;; Any blinkers which are supposed to be on but are off are turned on.
;;; Any blinkers which are supposed to be flashed are flashed if it is time.
(DEFMETHOD (BLINKER-TIME-HAS-PASSED BLINKER) (BLINKER-DELTA-TIME)
  (SELECTQ VISIBILITY
    ((NIL :OFF)
     (WHEN PHASE
       (BLINK SELF)))
    ((:BLINK)
     (COND ((SCREEN-HAS-FOCUS-P (SHEET-SCREEN SHEET))
	    (WHEN (<= (DECF TIME-UNTIL-BLINK BLINKER-DELTA-TIME) 0)
	      (BLINK SELF))
	    (RETURN-FROM BLINKER-TIME-HAS-PASSED
	      TIME-UNTIL-BLINK))
	   ((NOT PHASE)
	    (BLINK SELF))))	    
    ((T :ON)
     (WHEN (NOT PHASE)
       ;; blinkers turned off by prepare-sheet; time these too
       (IF (<= (DECF TIME-UNTIL-BLINK BLINKER-DELTA-TIME) 0)
	   (BLINK SELF)
	   (RETURN-FROM BLINKER-TIME-HAS-PASSED
	     TIME-UNTIL-BLINK)))))
  NIL)

(DEFVAR *BLINK-BLINKER-NOW-DELAY* 100000.)		;1/10 second in microseconds

(DEFUN-IN-FLAVOR (BLINK-BLINKER-NOW BLINKER) ()
  (WHEN VISIBILITY
    (SETQ TIME-UNTIL-BLINK 0)
    (WHEN (AND SHEET (SHEET-SCREEN SHEET))
      ;; Make the blinker process wake up and turn this blinker on, pretty soon
      (HASTEN-BLINKER-TIME (SHEET-SCREEN SHEET) *BLINK-BLINKER-NOW-DELAY*))))

(DEFMETHOD (:SET-CURSORPOS BLINKER :AFTER) (&REST IGNORE)
  (BLINK-BLINKER-NOW))

(DEFMETHOD (:SET-SIZE BLINKER :AFTER) (&REST IGNORE)
  (BLINK-BLINKER-NOW))

(DEFMETHOD (:SET-SIZE-AND-CURSORPOS BLINKER :AFTER) (&REST IGNORE)
  (BLINK-BLINKER-NOW))

(DEFWHOPPER (:BLINK BLINKER) ()
  (SHEET-IS-PREPARED (SHEET)
    (SETQ PREPARED-SHEET NIL)			;Blinking any blinker makes us forget
    (SETQ TIME-UNTIL-BLINK HALF-PERIOD)		;Schedule the next blink (wink??)
    (WHEN (AND FOLLOW-P (NULL PHASE))		;Position to cursor if not drawn.
      (SETQ X-POS (SHEET-CURSOR-X SHEET)
	    Y-POS (+ (SHEET-CURSOR-Y SHEET)
		     (- (SHEET-CURRENT-BASELINE SHEET)
			(SHEET-BASELINE SHEET)))))
    (CONTINUE-WHOPPER)
    (SETQ PHASE (NOT PHASE))))

(DEFMETHOD (:SET-CURSORPOS BLINKER) (X Y)
  "Set the position of a blinker relative to the sheet it is on.  Args in terms of
raster units.  If blinker was following cursor, it will no longer be doing so."
  (WITH-BLINKER-PREPARED (SELF :WHEN (NOT (AND (EQL (+ X (SHEET-INSIDE-LEFT SHEET)) X-POS)
					       (EQL (+ Y (SHEET-INSIDE-TOP SHEET)) Y-POS)
					       (NOT FOLLOW-P))))
    (SETQ X-POS (MIN (+ (MAX (ROUND X) 0)
			(SHEET-INSIDE-LEFT SHEET))
		     (SHEET-INSIDE-RIGHT SHEET))
	  Y-POS (MIN (+ (MAX (ROUND Y) 0)
			(SHEET-INSIDE-TOP SHEET))
		     (SHEET-INSIDE-BOTTOM SHEET))
	  FOLLOW-P NIL)))

(DEFMETHOD (:SET-FOLLOW-P BLINKER) (NEW-FOLLOW-P)
  "Turn on or off whether the blinker follows the sheet's typeout cursor."
  (WITH-BLINKER-PREPARED (SELF :WHEN (NOT (EQ FOLLOW-P NEW-FOLLOW-P)))
    (SETQ FOLLOW-P NEW-FOLLOW-P)))

(DEFMETHOD (:READ-CURSORPOS BLINKER) ()
  "Returns the position of a blinker in raster units relative to the margins of the
sheet it is on"
  (VALUES (- (OR X-POS (SHEET-CURSOR-X SHEET))
	     (SHEET-INSIDE-LEFT SHEET))
	  (- (OR Y-POS (SHEET-CURSOR-Y SHEET))
	     (SHEET-INSIDE-TOP SHEET))))

(DEFMETHOD (:SET-VISIBILITY BLINKER) (NEW-VISIBILITY)
  "Carefully alter the visibility of a blinker"
  (CL:CHECK-TYPE NEW-VISIBILITY (CL:MEMBER T NIL :BLINK :ON :OFF))
  (WITH-BLINKER-PREPARED (SELF :WHEN (NOT (EQ VISIBILITY NEW-VISIBILITY))
			       :OPEN NIL)
    (COND ((EQ PHASE NEW-VISIBILITY)
	   (SETQ VISIBILITY NEW-VISIBILITY))
	  (T
	   (WHEN (NULL NEW-VISIBILITY) (OPEN-BLINKER SELF))
	   (SETQ VISIBILITY NEW-VISIBILITY)))
    ;; Blinker clock will fix the screen
    (BLINK-BLINKER-NOW)))

(DEFMETHOD (:SET-SHEET BLINKER) (NEW-SHEET)
  (UNLESS (EQ NEW-SHEET SHEET)
    ;; Only need to turn off blinker if it is turned on
    (LET ((OLD-VISIBILITY VISIBILITY)
	  (OLD-SHEET SHEET))
      (WITH-BLINKER-PREPARED (SELF)
	(SETF VISIBILITY NIL)
	(SETF (SHEET-BLINKER-LIST SHEET) (DELQ SELF (SHEET-BLINKER-LIST SHEET))))
      (SETF SHEET NEW-SHEET)
      (WITH-BLINKER-PREPARED (SELF)
	(PUSH SELF (SHEET-BLINKER-LIST SHEET))
	(SETF VISIBILITY OLD-VISIBILITY)
	(MULTIPLE-VALUE-BIND (S-SUP S-INF EXCH-FLAG)
	    (IF (SHEET-ME-OR-MY-KID-P OLD-SHEET SHEET)
		(VALUES SHEET OLD-SHEET 1)
		(VALUES OLD-SHEET SHEET -1))
	  (COND ((OR (= EXCH-FLAG 1)
		     (SHEET-ME-OR-MY-KID-P S-INF S-SUP))
		 (MULTIPLE-VALUE-BIND (X-OFF Y-OFF)
		     (SHEET-CALCULATE-OFFSETS S-INF S-SUP)
		   (SETQ X-POS
			 (MIN (MAX 0 (+ X-POS (* EXCH-FLAG X-OFF)))
			      (1- (SHEET-WIDTH SHEET))))
		   (SETQ Y-POS
			 (MIN (MAX 0 (+ Y-POS (* EXCH-FLAG Y-OFF)))
			      (1- (SHEET-HEIGHT SHEET))))))
		(T
		 ;; The sheets aren't related so directly, just put the blinker in the middle
		 (SETQ X-POS (ROUND (SHEET-WIDTH SHEET) 2)
		       Y-POS (ROUND (SHEET-HEIGHT SHEET) 2)))))))))

;;;

(DEFMETHOD (:SET-SIZE RECTANGULAR-BLINKER) (NWIDTH NHEIGHT)
  (WITH-BLINKER-PREPARED (SELF :WHEN (OR ( WIDTH NWIDTH)
					 ( HEIGHT NHEIGHT)))
    (SETQ WIDTH NWIDTH HEIGHT NHEIGHT)))

(DEFMETHOD (:SET-SIZE-AND-CURSORPOS RECTANGULAR-BLINKER) (NWIDTH NHEIGHT X Y)
  "This is like :SET-SIZE and :SET-CURSORPOS together, in order to prevent
the user from seeing the intermediate state.  This prevents occasional
spasticity in menu blinkers, which looks terrible."
  (WITH-BLINKER-PREPARED (SELF :WHEN (NOT (AND (EQL (+ X (SHEET-INSIDE-LEFT SHEET)) X-POS)
					       (EQL (+ Y (SHEET-INSIDE-TOP SHEET)) Y-POS)
					       (EQL WIDTH NWIDTH) (EQL HEIGHT NHEIGHT)
					       (NOT FOLLOW-P))))
    (SETQ X-POS (MIN (+ (MAX (ROUND X) 0)
			(SHEET-INSIDE-LEFT SHEET))
		     (SHEET-INSIDE-RIGHT SHEET))
	  Y-POS (MIN (+ (MAX (ROUND Y) 0)
			(SHEET-INSIDE-TOP SHEET))
		     (SHEET-INSIDE-BOTTOM SHEET))
	  FOLLOW-P NIL
	  WIDTH NWIDTH
	  HEIGHT NHEIGHT)))

(DEFMETHOD (:BLINK RECTANGULAR-BLINKER) ()
  ;; Standard style, rectangular blinker
  ;; If outside of window, see it half in and half out, rather than disappearing
  (%DRAW-RECTANGLE-CLIPPED WIDTH HEIGHT
			   (COND ((< X-POS 0)
				  (// WIDTH -2))
				 (( X-POS (SHEET-WIDTH SHEET))
				  (- (SHEET-WIDTH SHEET) (// WIDTH 2) 1))
				 (T X-POS))
			   (COND ((< Y-POS 0)
				  (// HEIGHT -2))
				 (( Y-POS (SHEET-HEIGHT SHEET))
				  (- (SHEET-HEIGHT SHEET) (// HEIGHT 2) 1))
				 (T Y-POS))
			   BLINKER-ALU SHEET))

(DEFFLAVOR HOLLOW-RECTANGULAR-BLINKER () (RECTANGULAR-BLINKER))

;This sticks out by 1 pixel on the top and left but not on the bottom and
;right since that seems to be the right thing for boxing text -- this may be a crock
;draw one pixel off rather than getting clipped, though.
(DEFMETHOD (:BLINK HOLLOW-RECTANGULAR-BLINKER) ()
  (LET ((DRAW-X-POS (MAX 0 (1- X-POS))) (DRAW-Y-POS (MAX 0 (1- Y-POS)))
	(DRAW-HEIGHT (1+ HEIGHT)) (DRAW-WIDTH (1+ WIDTH)))
    (%DRAW-RECTANGLE-CLIPPED 1 DRAW-HEIGHT DRAW-X-POS DRAW-Y-POS BLINKER-ALU SHEET)
    (%DRAW-RECTANGLE-CLIPPED (- DRAW-WIDTH 1) 1 (+ DRAW-X-POS 1) DRAW-Y-POS BLINKER-ALU SHEET)
    (%DRAW-RECTANGLE-CLIPPED 1 (- DRAW-HEIGHT 1) (+ DRAW-X-POS DRAW-WIDTH -1) (+ DRAW-Y-POS 1)
			     BLINKER-ALU SHEET)
    (%DRAW-RECTANGLE-CLIPPED (- DRAW-WIDTH 2) 1 (+ DRAW-X-POS 1) (+ DRAW-Y-POS DRAW-HEIGHT -1)
			     BLINKER-ALU SHEET)))

(DEFFLAVOR BOX-BLINKER ((GRAY-ARRAY T))
	   (RECTANGULAR-BLINKER)
  :SETTABLE-INSTANCE-VARIABLES)

;; The argument D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")gray-array0 is T, meaning draw-rectangle; an array, meaning bitblt
;; from that array; or a list of two arrays -- bitblt from the first for horizontal
;; rectangles, and from the second for vertical ones.
(DEFUN BLINKER-BITBLT-CLIPPED (WIDTH HEIGHT X Y GRAY-ARRAY SHEET BLINKER-ALU)
  (WHEN (MINUSP X) (SETQ WIDTH (+ WIDTH X) X 0))
  (WHEN (MINUSP Y) (SETQ HEIGHT (+ HEIGHT Y) Y 0))
  (SETQ WIDTH (MIN WIDTH (MAX 0 (- (SHEET-WIDTH SHEET) X))))
  (SETQ HEIGHT (MIN HEIGHT (MAX 0 (- (SHEET-HEIGHT SHEET) Y))))
  (WHEN (AND (> WIDTH 0) (> HEIGHT 0))
    (FLET ((DR () (SHEET-DRAW-RECTANGLE WIDTH HEIGHT X Y BLINKER-ALU SHEET))
	   (BB (ARRAY) (SHEET-DRAW-1-BIT-RASTER WIDTH HEIGHT ARRAY X Y NIL X Y
						BLINKER-ALU COLOR:ALU-NOOP SHEET)))
      (TYPECASE GRAY-ARRAY
	(:SYMBOL (DR))
	(:ARRAY (BB GRAY-ARRAY))
	(:LIST (BB (IF ( WIDTH HEIGHT)
		       (FIRST GRAY-ARRAY)
		       (SECOND GRAY-ARRAY))))
	(OTHERWISE (DR))))))

(DEFUN DRAW-BLINKER-BOX (LEFT TOP RIGHT BOTTOM GRAY-ARRAY SHEET BLINKER-ALU)
  (IF (OR (< RIGHT LEFT) (< BOTTOM TOP))
      (PROGN
	(SHEET-DRAW-CHAR #\MOUSE:NW-CORNER RIGHT BOTTOM BLINKER-ALU SHEET)
	(SHEET-DRAW-CHAR #\MOUSE:SE-CORNER LEFT TOP BLINKER-ALU SHEET))
      (LET ((BORDER-WIDTH 2))
	(FLET ((BB (LL TT RR BB)
		 (BLINKER-BITBLT-CLIPPED (- RR LL) (- BB TT) LL TT GRAY-ARRAY SHEET BLINKER-ALU)))
	  (BB LEFT TOP RIGHT (+ TOP BORDER-WIDTH))
	  (BB LEFT (- BOTTOM BORDER-WIDTH) RIGHT BOTTOM)
	  (BB LEFT (+ TOP BORDER-WIDTH) (+ LEFT BORDER-WIDTH) (- BOTTOM BORDER-WIDTH))
	  (BB (- RIGHT BORDER-WIDTH) (+ TOP BORDER-WIDTH) RIGHT (- BOTTOM BORDER-WIDTH))))))

(DEFMETHOD (:BLINK BOX-BLINKER) ()
  (DRAW-BLINKER-BOX X-POS Y-POS (+ X-POS WIDTH) (+ Y-POS HEIGHT) GRAY-ARRAY SHEET BLINKER-ALU))

;; Perhaps this should be replaced by BOX-TRACKING-CORNER-BLINKER-MIXIN
(DEFFLAVOR BOX-LOWER-RIGHT-BLINKER-MIXIN () ()
  (:DOCUMENTATION :MIXIN "BOX-BLINKER whose lower-right corner moves and upper-left is fixed")
  (:REQUIRED-FLAVORS BOX-BLINKER))

(DEFMETHOD (:BLINK BOX-LOWER-RIGHT-BLINKER-MIXIN) ()
  (DRAW-BLINKER-BOX (- X-POS WIDTH) (- Y-POS HEIGHT) X-POS Y-POS GRAY-ARRAY SHEET BLINKER-ALU))

(DEFWRAPPER (:SET-CURSORPOS BOX-LOWER-RIGHT-BLINKER-MIXIN) ((X Y) . BODY)
  `(LET ((OLD-X-POS X-POS)
	 (OLD-Y-POS Y-POS))
     (WITH-BLINKER-PREPARED (SELF :WHEN (NOT (AND (EQL (+ X (SHEET-INSIDE-LEFT SHEET))
						       OLD-X-POS)
						  (EQL (+ Y (SHEET-INSIDE-RIGHT SHEET))
						       OLD-Y-POS))))
       (PROGN . ,BODY)
       (INCF WIDTH (- X-POS OLD-X-POS))
       (INCF HEIGHT (- Y-POS OLD-Y-POS)))))

;X and Y are -outside- coordinates and guaranteed to be in the window
(DEFMETHOD (:SET-CORNER-AND-SIZE BOX-LOWER-RIGHT-BLINKER-MIXIN) (X Y NWIDTH NHEIGHT)
  ;; Get coordinates of lower-right corner, the one that moves
  (WITH-BLINKER-PREPARED (SELF)
    (INCF X NWIDTH)
    (LET ((DIFF (- (SHEET-INSIDE-RIGHT SHEET) X)))
      (WHEN (PLUSP DIFF)
	(DECF X DIFF)
	(DECF NWIDTH DIFF)))
    (INCF Y NHEIGHT)
    (LET ((DIFF (- (SHEET-INSIDE-BOTTOM SHEET) Y)))
      (WHEN (PLUSP DIFF)
	(DECF Y DIFF)
	(DECF NHEIGHT DIFF)))
    (SETQ X-POS X Y-POS Y FOLLOW-P NIL WIDTH NWIDTH HEIGHT NHEIGHT)))

;;
;; This blinker type lies about its size etc. without these two methods. -DDyer/Weaver
;;
(DEFMETHOD (:SIZE BOX-LOWER-RIGHT-BLINKER-MIXIN) ()
  (VALUES (ABS WIDTH) (ABS HEIGHT)))

(DEFMETHOD (:READ-CURSORPOS BOX-LOWER-RIGHT-BLINKER-MIXIN) ()
  (VALUES (IF (> WIDTH 0) (- X-POS WIDTH) X-POS)
	  (IF (> HEIGHT 0) (- Y-POS HEIGHT) Y-POS)))

(DEFFLAVOR BOX-TRACKING-CORNER-BLINKER-MIXIN
	(MOVING-CORNER
	 (OPPOSITE-CORNER-FIXED T)
	 (BOUNDING-LEFT NIL) (BOUNDING-TOP NIL) (BOUNDING-RIGHT NIL) (BOUNDING-BOTTOM NIL))
	()
  (:DOCUMENTATION :MIXIN "BOX-BLINKER whose corner moves and opposite corner is fixed")
  (:REQUIRED-FLAVORS BOX-BLINKER)
  (:SETTABLE-INSTANCE-VARIABLES MOVING-CORNER OPPOSITE-CORNER-FIXED)
  (:REQUIRED-INIT-KEYWORDS :MOVING-CORNER))

(DEFMETHOD (:BLINK BOX-TRACKING-CORNER-BLINKER-MIXIN) ()
  (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM CHAR-X CHAR-Y CHAR)
      (CL:ECASE MOVING-CORNER
	(:UPPER-LEFT (VALUES X-POS Y-POS (+ X-POS WIDTH) (+ Y-POS HEIGHT)
			     (- X-POS 7) Y-POS #\MOUSE:NE-ARROW))
	(:UPPER-RIGHT (VALUES (- X-POS WIDTH) Y-POS X-POS (+ Y-POS HEIGHT)
			      X-POS Y-POS #\MOUSE:NW-ARROW))
	(:LOWER-LEFT (VALUES X-POS (- Y-POS HEIGHT) (+ X-POS WIDTH) Y-POS
			     (- X-POS 7) Y-POS #\MOUSE:NE-ARROW))
	(:LOWER-RIGHT (VALUES (- X-POS WIDTH) (- Y-POS HEIGHT) X-POS Y-POS
			      X-POS Y-POS #\MOUSE:NW-ARROW)))
    (DRAW-BLINKER-BOX LEFT TOP RIGHT BOTTOM GRAY-ARRAY SHEET BLINKER-ALU)
    (SHEET-DRAW-GLYPH (CHAR-SUBINDEX CHAR) FONTS:MOUSE CHAR-X CHAR-Y BLINKER-ALU SHEET)
    ))

(DEFWHOPPER (:SET-CURSORPOS BOX-TRACKING-CORNER-BLINKER-MIXIN) (X-ARG Y-ARG)
  (WITH-BLINKER-PREPARED (SELF)
    (LET* ((OLD-X-POS X-POS)
	   (OLD-Y-POS Y-POS)
	   (SHEET-DX (SHEET-INSIDE-LEFT SHEET))
	   (SHEET-DY (SHEET-INSIDE-TOP SHEET))
	   (X (+ X-ARG SHEET-DX))
	   (Y (+ Y-ARG SHEET-DY)))
      (UNLESS (AND (= X OLD-X-POS) (= Y OLD-Y-POS))
	(LET ((B-RIGHT BOUNDING-RIGHT)
	      (B-LEFT BOUNDING-LEFT)
	      (B-TOP BOUNDING-TOP)
	      (B-BOTTOM BOUNDING-BOTTOM))
	  (UNLESS OPPOSITE-CORNER-FIXED
	    (CL:ECASE MOVING-CORNER
	      ((:UPPER-LEFT :LOWER-LEFT)
	       (WHEN B-RIGHT
		 (LET* ((RIGHT-X (+ X WIDTH))
			(TOO-FAR (- RIGHT-X B-RIGHT)))
		   (WHEN (> TOO-FAR 0) (DECF X TOO-FAR)))))
	      ((:UPPER-RIGHT :LOWER-RIGHT)
	       (WHEN B-LEFT
		 (LET* ((LEFT-X (- X WIDTH))
			(TOO-FAR (- LEFT-X B-LEFT)))
		   (WHEN (< TOO-FAR 0) (DECF X TOO-FAR))))))
	    (CL:ECASE MOVING-CORNER
	      ((:UPPER-LEFT :UPPER-RIGHT)
	       (WHEN B-BOTTOM
		 (LET* ((BOTTOM-Y (+ Y HEIGHT))
			(TOO-FAR (- BOTTOM-Y B-BOTTOM)))
		   (WHEN (> TOO-FAR 0) (DECF Y TOO-FAR)))))
	      ((:LOWER-LEFT :LOWER-RIGHT)
	       (WHEN B-TOP
		 (LET* ((TOP-Y (- Y HEIGHT))
			(TOO-FAR (- TOP-Y B-TOP)))
		   (WHEN (< TOO-FAR 0) (DECF Y TOO-FAR)))))))
	  (WHEN B-LEFT (SETQ X (MAX X B-LEFT)))
	  (WHEN B-RIGHT (SETQ X (MIN X B-RIGHT)))
	  (WHEN B-TOP (SETQ Y (MAX Y B-TOP)))
	  (WHEN B-BOTTOM (SETQ Y (MIN Y B-BOTTOM))))
	(CONTINUE-WHOPPER (- X SHEET-DX) (- Y SHEET-DY))
	(WHEN OPPOSITE-CORNER-FIXED
	  (LET ((DX (- X-POS OLD-X-POS))
		(DY (- Y-POS OLD-Y-POS)))
	    (CL:ECASE MOVING-CORNER
	      (:UPPER-LEFT (DECF WIDTH DX) (DECF HEIGHT DY))
	      (:UPPER-RIGHT (INCF WIDTH DX) (DECF HEIGHT DY))
	      (:LOWER-RIGHT (INCF WIDTH DX) (INCF HEIGHT DY))
	      (:LOWER-LEFT (DECF WIDTH DX) (INCF HEIGHT DY)))))))))

;X and Y are -outside- coordinates and guaranteed to be in the window
(DEFMETHOD (:SET-EDGES-AND-MOVING-CORNER BOX-TRACKING-CORNER-BLINKER-MIXIN)
	   (LEFT TOP RIGHT BOTTOM CORNER-TO-MOVE &OPTIONAL (FIX-OPPOSITE-CORNER T))
  (MULTIPLE-VALUE-BIND (NEW-X-POS NEW-Y-POS)
      (CL:ECASE CORNER-TO-MOVE
	(:UPPER-LEFT (VALUES LEFT TOP))
	(:UPPER-RIGHT (VALUES RIGHT TOP))
	(:LOWER-LEFT (VALUES LEFT BOTTOM))
	(:LOWER-RIGHT (VALUES RIGHT BOTTOM)))
    (LET ((NEW-WIDTH (- RIGHT LEFT))
	  (NEW-HEIGHT (- BOTTOM TOP)))
      (WITH-BLINKER-PREPARED (SELF)
	(SETQ MOVING-CORNER CORNER-TO-MOVE
	      OPPOSITE-CORNER-FIXED FIX-OPPOSITE-CORNER
	      BOUNDING-LEFT NIL BOUNDING-TOP NIL BOUNDING-RIGHT NIL BOUNDING-BOTTOM NIL)
	(SETQ X-POS NEW-X-POS
	      Y-POS NEW-Y-POS
	      FOLLOW-P NIL
	      WIDTH NEW-WIDTH
	      HEIGHT NEW-HEIGHT)))))

(DEFMETHOD (:SET-BOUNDING-BOX BOX-TRACKING-CORNER-BLINKER-MIXIN) (LEFT TOP RIGHT BOTTOM)
  (SETQ BOUNDING-LEFT LEFT
	BOUNDING-TOP TOP
	BOUNDING-RIGHT RIGHT
	BOUNDING-BOTTOM BOTTOM))

(DEFMETHOD (:SIZE BOX-TRACKING-CORNER-BLINKER-MIXIN) ()
  (MULTIPLE-VALUE-BIND (EXTRA-WIDTH EXTRA-HEIGHT)
      (CL:ECASE MOVING-CORNER
	(:UPPER-LEFT (VALUES 8 0))
	(:UPPER-RIGHT (VALUES 16. 0))
	(:LOWER-LEFT (VALUES 8 16.))
	(:LOWER-RIGHT (VALUES 16. 16.)))
    (VALUES (+ (ABS WIDTH) EXTRA-WIDTH) (+ (ABS HEIGHT) EXTRA-HEIGHT))))

(DEFMETHOD (:SIZE-WITHOUT-ARROW BOX-TRACKING-CORNER-BLINKER-MIXIN) ()
  (VALUES WIDTH HEIGHT))

(DEFMETHOD (:READ-CURSORPOS BOX-TRACKING-CORNER-BLINKER-MIXIN) ()
  (VALUES (IF (> WIDTH 0) (- X-POS WIDTH) X-POS)
	  (IF (> HEIGHT 0) (- Y-POS HEIGHT) Y-POS)))

;;; Blinker that blinks multiple boxes.
(DEFFLAVOR BOXES-BLINKER
	((HOLLOW-BOXES NIL)
	 (SOLID-BOXES NIL)
	 (SLANTED-LINES NIL)

	 (RECTANGLE-LIST NIL)
	 (WIDTH 0)
	 (HEIGHT 0))
	(BLINKER)
  :GETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:SIZE BOXES-BLINKER) ()
  (VALUES WIDTH HEIGHT))

(DEFMETHOD (:SHAPES BOXES-BLINKER) ()
  (VALUES HOLLOW-BOXES SOLID-BOXES SLANTED-LINES))

(DEFMETHOD (:BLINK BOXES-BLINKER) ()
  (LOOP FOR (X Y W H) IN RECTANGLE-LIST
	DO (%DRAW-RECTANGLE-CLIPPED W H X Y BLINKER-ALU SHEET))
  (LOOP FOR (X1 Y1 X2 Y2) IN SLANTED-LINES
	DO (SHEET-DRAW-LINE X1 Y1 X2 Y2 BLINKER-ALU NIL SHEET)))

;;;   Take a bunch of boxes and compute the minimal set of rectangular
;;;   slices that are equivalent to drawing a lot of outlines of the
;;;   boxes in XOR mode.
;;;   
;;;   For example,
;;;    Given
;;;        ************
;;;        ************
;;;   and
;;;   *****************
;;;   *****************
;;;   *****************
;;;   
;;;   you draw
;;;        +----------+
;;;        |          |
;;;   +----+          |
;;;   |               |
;;;   +---------------+
;;;   (six line segments)
;;;   
;;;   The segment
;;;        +----------+
;;;        |          |
;;;   +----+==========+
;;;   |               |
;;;   +---------------+
;;;   being in effect drawn twice.

(DEFMETHOD (:SET-SHAPES BOXES-BLINKER) (NEW-HOLLOW-BOXES NEW-SOLID-BOXES NEW-SLANTED-LINES)
  (MACROLET ((LEFT (BOX) `(FIRST ,BOX))
	     (TOP (BOX) `(SECOND ,BOX))
	     (RIGHT (BOX) `(THIRD ,BOX))
	     (BOTTOM (BOX) `(FOURTH ,BOX)))
    (FLET ((X-Y-LESSP (B-1 B-2)
	     (COND ((< (TOP B-1) (TOP B-2)) T)
		   ((> (TOP B-1) (TOP B-2)) NIL)
		   ((< (LEFT B-1) (LEFT B-2)) T)
		   (T NIL))))
      ;; This first sort is solely for the purpose of canonical equal comparison below.
      (SETQ NEW-HOLLOW-BOXES (SORT NEW-HOLLOW-BOXES #'X-Y-LESSP))
      (UNLESS (AND (EQUAL HOLLOW-BOXES NEW-HOLLOW-BOXES)
		   (EQUAL SOLID-BOXES NEW-SOLID-BOXES)
		   (EQUAL SLANTED-LINES NEW-SLANTED-LINES))
	(LET ((RECTANGLES (LOOP FOR BOX IN NEW-SOLID-BOXES
				COLLECT (LIST (LEFT BOX) (TOP BOX)
					      (- (RIGHT BOX) (LEFT BOX))
					      (- (BOTTOM BOX) (TOP BOX))))))
	  (LET* ((NBOXES (LENGTH NEW-HOLLOW-BOXES))
		 (NBOXES*8 (* NBOXES 8)))
	    (WITH-STACK-ARRAY (SLICES NBOXES*8)
	      (MACROLET ((SLICE-CROSS-POS (INDEX &OPTIONAL (SLICES 'SLICES))
			   `(AREF ,SLICES ,INDEX))
			 ;; This says that the slice came from the top/left edge of a box,
			 ;; and should be drawn one pixel above if it indeed does get
			 ;; drawn.
			 (SLICE-START-EDGE-P (INDEX &OPTIONAL (SLICES 'SLICES))
			   `(AREF ,SLICES (1+ ,INDEX)))
			 (SLICE-START (INDEX &OPTIONAL (SLICES 'SLICES))
			   `(AREF ,SLICES (+ ,INDEX 2)))
			 (SLICE-END (INDEX &OPTIONAL (SLICES 'SLICES))
			   `(AREF ,SLICES (+ ,INDEX 3))))
		(FLET ((SLICE-LESSP (ARRAY-1 INDEX-1 ARRAY-2 INDEX-2)
			 (LET ((POS1 (SLICE-CROSS-POS INDEX-1 ARRAY-1))
			       (POS2 (SLICE-CROSS-POS INDEX-2 ARRAY-2)))
			   (COND ((< POS1 POS2) T)
				 ((> POS1 POS2) NIL)
				 (T (LET ((X11 (SLICE-START INDEX-1 ARRAY-1))
					  (X12 (SLICE-START INDEX-2 ARRAY-2)))
				      (COND ((< X11 X12) T)
					    ((> X11 X12) NIL)
					    (T (< (SLICE-END INDEX-1 ARRAY-1)
						  (SLICE-END INDEX-2 ARRAY-2))))))))))
		  (MACROLET
		    ((DO-SLICES (HORIZONTAL-P)
		       (MULTIPLE-VALUE-BIND (START END CROSS-START CROSS-END)
			   (IF HORIZONTAL-P
			       (VALUES 'LEFT 'RIGHT 'TOP 'BOTTOM)
			       (VALUES 'TOP 'BOTTOM 'LEFT 'RIGHT))
			 `(MACROLET ((MAKE-LINE (START EXTEND-START END EXTEND-END DRAW-POS)
				       (IGNORE EXTEND-START EXTEND-END)
				       ,(IF HORIZONTAL-P
					   '`(LET ((ST (+ ,START ,EXTEND-START))
						   (EN (+ ,END ,EXTEND-END)))
					       (LIST ST ,DRAW-POS (- EN ST) 1))
					   '`(LIST ,DRAW-POS ,START 1 (- ,END ,START)))))
			    ;; Add slices for the tops and bottoms of the boxes.
			    (LOOP FOR BOX IN NEW-HOLLOW-BOXES
				  FOR I FROM 0 BY 8
				  AS I+4 = (+ I 4)
				  DO
			      (SETF (SLICE-CROSS-POS I) (,CROSS-START BOX))
			      (SETF (SLICE-START-EDGE-P I) T)
			      (SETF (SLICE-CROSS-POS I+4) (,CROSS-END BOX))
			      (SETF (SLICE-START-EDGE-P I+4) NIL)
			      (LET ((START (,START BOX))
				    (END (,END BOX)))
				(SETF (SLICE-START I) START)
				(SETF (SLICE-START I+4) START)
				(SETF (SLICE-END I) END)
				(SETF (SLICE-END I+4) END)))
			    (SORT-GROUPED-ARRAY-GROUP-KEY SLICES 4 #'SLICE-LESSP)
			    (LET ((INDEX 0))
			      (LOOP WHILE (< INDEX NBOXES*8) DO
				(LET* ((START (SLICE-START INDEX))
				       (EXTEND-START -1)
				       (END (SLICE-END INDEX))
				       (EXTEND-END +1)
				       (POS (SLICE-CROSS-POS INDEX))
				       (DRAW-POS (IF (SLICE-START-EDGE-P INDEX)
						     (MAX 0 (1- POS))
						     POS)))
				  ;; the compiler misses the references in a call to a
				  ;; macrolet within another macrolet...
				  (IGNORE EXTEND-START EXTEND-END)
				  ;; So long as the next slice overlaps, draw the portion
				  ;; to the left of the overlap and continue after the end
				  ;; of the overlap.
				  (LOOP AS NEXT-INDEX = (+ INDEX 4)
					WHILE (AND (< NEXT-INDEX NBOXES*8)
						   (= POS (SLICE-CROSS-POS NEXT-INDEX)))
					DO (LET ((NEXT-START (SLICE-START NEXT-INDEX)))
					     (COND ((> NEXT-START END) (RETURN))
						   ((= NEXT-START END)
						    (SETQ END (SLICE-END NEXT-INDEX)))
						   (T
						    (UNLESS (= NEXT-START START)
						      (PUSH (MAKE-LINE START EXTEND-START
								       NEXT-START -1
								       DRAW-POS)
							    RECTANGLES))
						    (SETQ START END
							  EXTEND-START +1
							  END (SLICE-END NEXT-INDEX)
							  EXTEND-END +1)
						    ;; Sort didn't say which one went
						    ;; further to right.  Have correct
						    ;; boundaries, maybe just incorrect
						    ;; order.
						    (WHEN (< END START)
						      (SWAPF START END)))))
					   (INCF INDEX 4))
				  (UNLESS (= END START)
				    (PUSH (MAKE-LINE START EXTEND-START END EXTEND-END
						     DRAW-POS)
					  RECTANGLES))
				  (INCF INDEX 4))))))))
		    (DO-SLICES T)
		    (DO-SLICES NIL))))))
	  (SETQ RECTANGLES (SORT RECTANGLES #'X-Y-LESSP))	;Don't draw all over randomly
	  (WITH-BLINKER-PREPARED (SELF)
	    (SETQ X-POS (MIN (IF NEW-HOLLOW-BOXES (LEFT (FIRST NEW-HOLLOW-BOXES)) 0)
			     (IF NEW-SOLID-BOXES (LEFT (FIRST NEW-SOLID-BOXES)) 0)
			     (LOOP FOR LINE IN NEW-SLANTED-LINES
				   MINIMIZE (LEFT LINE)
				     MINIMIZE (RIGHT LINE)))
		  Y-POS (MIN (IF NEW-HOLLOW-BOXES (TOP (FIRST NEW-HOLLOW-BOXES)) 0)
			     (IF NEW-SOLID-BOXES (TOP (FIRST NEW-SOLID-BOXES)) 0)
			     (LOOP FOR LINE IN NEW-SLANTED-LINES
				   MINIMIZE (TOP LINE)
				     MINIMIZE (BOTTOM LINE)))
		  WIDTH (- (MAX (LOOP FOR BOX IN NEW-HOLLOW-BOXES MAXIMIZE (RIGHT BOX))
				(LOOP FOR BOX IN NEW-SOLID-BOXES MAXIMIZE (RIGHT BOX))
				(LOOP FOR LINE IN NEW-SLANTED-LINES
				      MAXIMIZE (LEFT LINE)
				      MAXIMIZE (RIGHT LINE)))
			   X-POS)
		  HEIGHT (- (MAX (LOOP FOR BOX IN NEW-HOLLOW-BOXES MAXIMIZE (BOTTOM BOX))
				 (LOOP FOR BOX IN NEW-SOLID-BOXES MAXIMIZE (BOTTOM BOX))
				 (LOOP FOR LINE IN NEW-SLANTED-LINES
				       MAXIMIZE (TOP LINE)
				       MAXIMIZE (BOTTOM LINE)))
			    Y-POS))
	    (SETQ RECTANGLE-LIST RECTANGLES
		  HOLLOW-BOXES NEW-HOLLOW-BOXES
		  SOLID-BOXES NEW-SOLID-BOXES
		  SLANTED-LINES NEW-SLANTED-LINES)
	    ;; If the blinker is supposed to be visible, turn it back on immediately,
	    ;; don't wait for *BLINKER-CLOSE-DELAY-TIME*
	    (WHEN (EQ VISIBILITY T)
	      (BLINK SELF))))))))

;;; Compatibility
(DEFMETHOD (:BOXES BOXES-BLINKER) () HOLLOW-BOXES)

(DEFMETHOD (:SET-BOXES BOXES-BLINKER) (NEW-BOXES &OPTIONAL NEW-SLANTED-LINES)
  (SEND SELF :SET-SHAPES NEW-BOXES NIL NEW-SLANTED-LINES))

;Mixin that causes a blinker to stay inside its sheet
(DEFFLAVOR STAY-INSIDE-BLINKER-MIXIN () ()
  (:REQUIRED-FLAVORS BLINKER))

(DEFWRAPPER (:SET-CURSORPOS STAY-INSIDE-BLINKER-MIXIN) (XY . BODY)
  `(PROGN (SETF (FIRST XY) (MIN (FIRST XY) (- (SHEET-INSIDE-WIDTH SHEET) WIDTH)))
	  (SETF (SECOND XY) (MIN (SECOND XY) (- (SHEET-INSIDE-HEIGHT SHEET) HEIGHT)))
	  . ,BODY))

(DEFFLAVOR IBEAM-BLINKER
	((HEIGHT NIL))
	(BLINKER)
  (:INITABLE-INSTANCE-VARIABLES HEIGHT))

(DEFMETHOD (:INIT IBEAM-BLINKER :BEFORE) (IGNORE)
  (OR HEIGHT (SETQ HEIGHT (SHEET-LINE-HEIGHT SHEET))))

(DEFMETHOD (:SIZE IBEAM-BLINKER) ()
  (VALUES 9. HEIGHT))

(DEFMETHOD (:BLINK IBEAM-BLINKER) (&AUX X0)
  (%DRAW-RECTANGLE-CLIPPED 2 HEIGHT (MAX 0 (1- X-POS)) Y-POS BLINKER-ALU SHEET)
  (SETQ X0 (MAX 0 (- X-POS 4)))
  (%DRAW-RECTANGLE-CLIPPED (- (+ X-POS 5) X0) 2 X0 (MAX 0 (- Y-POS 2)) BLINKER-ALU SHEET)
  (%DRAW-RECTANGLE-CLIPPED (- (+ X-POS 5) X0) 2 X0 (+ Y-POS HEIGHT) BLINKER-ALU SHEET))

(DEFFLAVOR CHARACTER-BLINKER
	(FONT
	 CHAR
	 INDEX)
	(BLINKER)
  ;; FONT is only initable for compatibility.
  (:INITABLE-INSTANCE-VARIABLES FONT CHAR))

(DEFMETHOD (:INIT CHARACTER-BLINKER :BEFORE) (IGNORE)
  (COND ((VARIABLE-BOUNDP FONT)
	 ;; Compatibility
	 (SETQ FONT (SEND (SHEET-SCREEN SHEET) ':PARSE-FONT-DESCRIPTOR FONT)
	       INDEX (CHAR-CODE CHAR)))
	(T
	 (MULTIPLE-VALUE (INDEX FONT)
	   (SHEET-GET-CHAR-INDEX-AND-FONT CHAR T SHEET)))))

(DEFMETHOD (:SIZE CHARACTER-BLINKER) ()
  ;; The width and height of a glyph (the size of the bitblt that draws it)
  ;; Assume (< INDEX (FONT-FILL-POINTER FONT))
  (VALUES (LET ((FIT (FONT-INDEXING-TABLE FONT)))
	    (IF FIT (- (AREF FIT (1+ INDEX)) (AREF FIT INDEX)) (FONT-RASTER-WIDTH FONT)))
	  (FONT-RASTER-HEIGHT FONT)))

(DEFMETHOD (:BLINK CHARACTER-BLINKER) ()
  "Use a character as a blinker.  Any font, any character"
  (SHEET-DRAW-GLYPH INDEX FONT X-POS Y-POS BLINKER-ALU SHEET))

(DEFMETHOD (:SET-CHARACTER CHARACTER-BLINKER) (NCHAR)
  (MULTIPLE-VALUE-BIND (NINDEX NFONT)
      (SHEET-GET-CHAR-INDEX-AND-FONT NCHAR T SHEET)
    (WITH-BLINKER-PREPARED (SELF)
      (SETQ FONT NFONT
	    INDEX NINDEX
	    CHAR NCHAR))))

(DEFMETHOD (:CHARACTER CHARACTER-BLINKER) () CHAR)

(DEFFLAVOR CHARACTER-BLINKER-WITH-INSIDE-LINE
	(DIRECTION				;:horizontal or :vertical
	 WITHIN-LEFT WITHIN-TOP WITHIN-RIGHT WITHIN-BOTTOM	;bounding-box
	 (TEMPS-ALLOCATED NIL)
	 (XOR-BITS NIL)				;..
	 (CURSOR-BITS NIL)			;..
	 (DOT-BITS NIL)				;..
	 (MATTE-BITS NIL)			;..
	 CHAR-RW CHAR-RH)
	(CHARACTER-BLINKER))

(DEFUN-IN-FLAVOR (DEALLOCATE-TEMPORARY-BIT-ARRAYS CHARACTER-BLINKER-WITH-INSIDE-LINE) ()
  (WHEN TEMPS-ALLOCATED
    (SETF TEMPS-ALLOCATED NIL)
    (LET ((SCREEN (SHEET-SCREEN SHEET)))
      (WHEN XOR-BITS
	(%SCREEN-DEALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN SHEET XOR-BITS)
	(SETQ XOR-BITS NIL))
      (WHEN CURSOR-BITS
	(%SCREEN-DEALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN SHEET CURSOR-BITS)
	(SETQ CURSOR-BITS NIL))
      (WHEN MATTE-BITS
	(%SCREEN-DEALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN SHEET MATTE-BITS)
	(SETQ MATTE-BITS NIL))
      (WHEN DOT-BITS
	(%SCREEN-DEALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN SHEET DOT-BITS)
	(SETQ DOT-BITS NIL))
      ;;(XLIB:UNTRACE-DISPLAY (X-SCREEN::X-CONSOLE-DISPLAY (SHEET-CONSOLE SHEET)))
      )))

(DEFMETHOD (:SET-VISIBILITY CHARACTER-BLINKER-WITH-INSIDE-LINE :AFTER) (NEW-VISIBILITY)
  (UNLESS NEW-VISIBILITY
    (DEALLOCATE-TEMPORARY-BIT-ARRAYS)))

(DEFWHOPPER-SUBST (:SIZE CHARACTER-BLINKER-WITH-INSIDE-LINE) ()
  (MULTIPLE-VALUE-BIND (XS YS) (CONTINUE-WHOPPER)
    (VALUES (IF (EQ DIRECTION :HORIZONTAL) (- WITHIN-RIGHT WITHIN-LEFT) XS)
	    (IF (EQ DIRECTION :VERTICAL) (- WITHIN-BOTTOM WITHIN-TOP) YS))))

(DEFWHOPPER-SUBST (:READ-CURSORPOS CHARACTER-BLINKER-WITH-INSIDE-LINE) ()
  (MULTIPLE-VALUE-BIND (X Y) (CONTINUE-WHOPPER)
    (IF (EQ DIRECTION :HORIZONTAL)
	(WHEN (> (+ X X) (+ WITHIN-LEFT WITHIN-RIGHT))
	  (SETQ X WITHIN-LEFT))
	(WHEN (> (+ Y Y) (+ WITHIN-LEFT WITHIN-TOP))
	  (SETQ Y WITHIN-TOP)))
    (VALUES X Y)))

(DEFMETHOD (:SET-CHAR-DIRECTION-AND-BOUNDS CHARACTER-BLINKER-WITH-INSIDE-LINE)
	   (NCHAR NEW-DIRECTION &REST BOX)
  (CL:CHECK-TYPE NEW-DIRECTION (CL:MEMBER :HORIZONTAL :VERTICAL))
  (CHECK-ARG BOX (EVERY BOX #'CL:INTEGERP) "a list of integers")
  (MULTIPLE-VALUE-BIND (NINDEX NFONT)
      (SHEET-GET-CHAR-INDEX-AND-FONT NCHAR T SHEET)
    (DESTRUCTURING-BIND (&OPTIONAL NL NT NR NB) BOX
      (WITH-BLINKER-PREPARED (SELF)
	(SETQ CHAR NCHAR
	      FONT NFONT
	      INDEX NINDEX
	      CHAR-RW (MIN (- (IF (FONT-INDEXING-TABLE FONT)
				  (- (AREF (FONT-INDEXING-TABLE FONT) (1+ INDEX))
				     (AREF (FONT-INDEXING-TABLE FONT) INDEX))
				  (FONT-RASTER-WIDTH FONT))
			      (IF (AND (FONT-LEFT-KERN-TABLE FONT)
				       (MINUSP (AREF (FONT-LEFT-KERN-TABLE FONT) INDEX)))
				  (AREF (FONT-LEFT-KERN-TABLE FONT) INDEX)
				  0))
			   30)
	      CHAR-RH (MIN (FONT-RASTER-HEIGHT FONT) 30))
	(WHEN NL (SETQ WITHIN-LEFT NL))
	(WHEN NT (SETQ WITHIN-TOP NT))
	(WHEN NR (SETQ WITHIN-RIGHT NR))
	(WHEN NB (SETQ WITHIN-BOTTOM NB))
	(SETQ DIRECTION NEW-DIRECTION)
	(DEALLOCATE-TEMPORARY-BIT-ARRAYS)))))

(DEFMETHOD (:BLINK CHARACTER-BLINKER-WITH-INSIDE-LINE) ()
  ;; Order of operations here is designed to minimize off time when moving blinker
  ;; :SET-CURSORPOS method ensures (X-POS, Y-POS) point lies inside screen margins
  ;; May need to clip on bottom or right, however
  (LET* ((W (+ 2 CHAR-RW))
	 (H (+ 2 CHAR-RH))
	 (WIDTH (MIN W (- (SHEET-INSIDE-RIGHT SHEET) X-POS)))
	 (HEIGHT (MIN H (- (SHEET-INSIDE-BOTTOM SHEET) Y-POS)))
	 (SCREEN (SHEET-SCREEN SHEET)))
    (WHEN (AND (PLUSP WIDTH) (PLUSP HEIGHT))	;unless clipped to nothingness
      ;; If the temporary bit arrays have not been allocated yet, allocate them
      ;; Let the screen decide what type of temporary bit array is most efficient
      (UNLESS TEMPS-ALLOCATED
	;;(XLIB:TRACE-DISPLAY (X-SCREEN::X-CONSOLE-DISPLAY (SHEET-CONSOLE SHEET)))
	(SETQ XOR-BITS (%SCREEN-ALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN SHEET W H))
	(SETQ CURSOR-BITS (%SCREEN-ALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN SHEET W H))
	(SETQ MATTE-BITS (%SCREEN-ALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN SHEET W H))
	;; Put the character into the cursor
	(SHEET-DRAW-RECTANGLE W H 0 0 ALU-ANDCA SHEET MATTE-BITS)
	(SHEET-DRAW-RECTANGLE W H 0 0 (SHEET-ERASE-ALUF SHEET) SHEET CURSOR-BITS)
	(WITH-STACK-LIST (CLIPPING-REGION 0 0 W H)
	  (LETF (((TV:SHEET-CLIPPING-REGION SHEET) CLIPPING-REGION))
	    (DOTIMES (DX 2)
	      (DOTIMES (DY 2)
		(SHEET-DRAW-GLYPH INDEX FONT DX DY ALU-IOR SHEET MATTE-BITS)))
	    (SHEET-DRAW-GLYPH INDEX FONT 1 1 (SHEET-CHAR-ALUF SHEET) SHEET CURSOR-BITS)))
	(SHEET-BITBLT ALU-AND W H MATTE-BITS 0 0 CURSOR-BITS 0 0 SHEET)
	(MULTIPLE-VALUE-BIND (DW DH)
	    (CL:ECASE DIRECTION
	      (:HORIZONTAL (VALUES WITHIN-RIGHT 1))
	      (:VERTICAL (VALUES 1 WITHIN-BOTTOM)))
	  (SETQ DOT-BITS (%SCREEN-ALLOCATE-SHEET-TEMPORARY-BIT-ARRAY SCREEN SHEET DW DH))
	  (SHEET-DRAW-RECTANGLE DW DH 0 0 ALU-ANDCA SHEET DOT-BITS)
	  (SHEET-DRAW-1-BIT-RASTER DW DH TV:25%-GRAY 0 0 DOT-BITS 0 0
				   BLINKER-ALU ALU-ANDCA SHEET))
	(SETF TEMPS-ALLOCATED T))
      ;; If blinker is now off, turn it on
      (WHEN (NULL PHASE)
	;; Copy the bits under the blinker
	(SHEET-BITBLT ALU-SETA WIDTH HEIGHT NIL X-POS Y-POS XOR-BITS 0 0 SHEET)
	;; Draw the character into those bits, with an outline around it
	(WITH-SHEET-NOT-ALL-EXPOSED (SHEET)
	  (SHEET-BITBLT ALU-ANDCA WIDTH HEIGHT MATTE-BITS 0 0 XOR-BITS 0 0 SHEET)
	  (SHEET-BITBLT ALU-IOR WIDTH HEIGHT CURSOR-BITS 0 0 XOR-BITS 0 0 SHEET))
	;; Compute the XOR that will put the blinker onto the sheet
	;; Have to use XOR rather than save and restore because if this blinker
	;; overlaps another blinker, they may not get drawn and undrawn in
	;; a consistent order
	(SHEET-BITBLT ALU-XOR WIDTH HEIGHT NIL X-POS Y-POS XOR-BITS 0 0 SHEET)
	;; Finally, draw onto the screen
	(SHEET-BITBLT ALU-XOR WIDTH HEIGHT XOR-BITS 0 0 NIL X-POS Y-POS SHEET))
      ;; XOR the dotted line
      (MULTIPLE-VALUE-BIND (XP YP)
	  (IF (OPERATION-HANDLED-P SELF :OFFSETS)
	      (MULTIPLE-VALUE-BIND (DX DY) (SEND SELF :OFFSETS)
		(VALUES (+ X-POS DX) (+ Y-POS DY)))
	      (VALUES X-POS Y-POS))
	(CL:ECASE DIRECTION
	  (:HORIZONTAL
	    (WHEN (AND ( WITHIN-TOP YP) (< YP WITHIN-BOTTOM))
	      (SHEET-BITBLT ALU-XOR (- WITHIN-RIGHT WITHIN-LEFT) 1
			    DOT-BITS WITHIN-LEFT 0 NIL WITHIN-LEFT YP SHEET)))
	  (:VERTICAL
	    (WHEN (AND ( WITHIN-LEFT XP) (< XP WITHIN-RIGHT))
	      (SHEET-BITBLT ALU-XOR 1 (- WITHIN-BOTTOM WITHIN-TOP)
			    DOT-BITS 0 WITHIN-TOP NIL XP WITHIN-TOP SHEET)))))
      ;; If blinker is now on, turn it off--do this last to minimize off time
      (WHEN PHASE
	(SHEET-BITBLT ALU-XOR WIDTH HEIGHT XOR-BITS 0 0 NIL X-POS Y-POS SHEET)))))

(DEFFLAVOR STRING-BLINKER
	(STRING
	 (STYLE NIL)
	 (FROM 0)
	 (TO NIL)
	 (BASELINE NIL))
	(BLINKER)
  (:INITABLE-INSTANCE-VARIABLES STRING STYLE BASELINE)
  (:SETTABLE-INSTANCE-VARIABLES BASELINE))

(DEFMETHOD (:INIT STRING-BLINKER :BEFORE) (IGNORE)
  (WHEN STYLE
    (SETQ STYLE (SI:PARSE-CHARACTER-STYLE STYLE))))

(DEFMETHOD (:INIT STRING-BLINKER :AFTER) (IGNORE)
  (UNLESS BASELINE
    (SETQ BASELINE (SEND SHEET :BASELINE))))

(DEFMETHOD (:SIZE STRING-BLINKER) ()
  (IF STRING
      (VALUES (SEND SHEET :STRING-LENGTH STRING FROM TO NIL STYLE)
	      (+ BASELINE (SEND SHEET :VSP)))
    (VALUES 0 0)))

(DEFMETHOD (:BLINK STRING-BLINKER) ()
  "Use a character string as a blinker."
  (LETF (((SHEET-BASELINE SHEET) BASELINE)
	 ((SHEET-CURRENT-BASELINE SHEET) BASELINE))
    (SEND SHEET :STRING-OUT-EXPLICIT-INTERNAL STRING X-POS Y-POS (SHEET-INSIDE-RIGHT SHEET)
					      BLINKER-ALU FROM TO STYLE)))
  
(DEFMETHOD (:SET-STRING STRING-BLINKER) (NSTRING &OPTIONAL NFROM NTO NSTYLE)
  (WHEN NSTYLE
    (SETQ STYLE (SI:PARSE-CHARACTER-STYLE NSTYLE)))
  (SETQ NFROM (OR NFROM 0))
  (SETQ NTO (OR NTO (STRING-LENGTH NSTRING)))
  (UNLESS (AND STRING
	       (STRING= NSTRING STRING)
	       (EQL NFROM FROM)
	       (EQL NTO TO))
    (WITH-BLINKER-PREPARED (SELF)
      (SETQ HALF-PERIOD (IF (> (- NTO NFROM) 1) 20. 8.))
      (WHEN (OR (NULL STRING)
		(> (STRING-LENGTH NSTRING) (ARRAY-LENGTH STRING))
		(AND (STRING-FAT-P NSTRING)
		     (NOT (STRING-FAT-P STRING))))
	;; Make a new blinker string if we don't have one already, or the
	;; new string is either longer or fatter.
	(SETQ STRING (MAKE-ARRAY (STRING-LENGTH NSTRING) :TYPE 'ART-FAT-STRING
							 :FILL-POINTER 0)))
      (COPY-ARRAY-CONTENTS NSTRING STRING)
      (WHEN (CL:ARRAY-HAS-FILL-POINTER-P STRING)
	(SETF (FILL-POINTER STRING) (STRING-LENGTH NSTRING)))
      (SETQ FROM NFROM
	    TO NTO)))) 

(DEFFLAVOR CHARACTER-AND-STRING-BLINKER
	((CHARACTER-X-OFFSET 0)
	 (CHARACTER-Y-OFFSET 0)
	 (STRING-X-OFFSET 0)
	 (STRING-Y-OFFSET 0)
	 (SUPPRESS-STRING NIL)
	 (STRING-WAS-SUPPRESSED NIL))
	(CHARACTER-BLINKER STRING-BLINKER)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:SIZE CHARACTER-AND-STRING-BLINKER) ()
  (LET ((RIGHT 0)
	(BOTTOM 0))
    (WHEN (AND FONT INDEX)
      (SETQ RIGHT (+ CHARACTER-X-OFFSET 
		     (LET ((FIT (FONT-INDEXING-TABLE FONT)))
		       (IF FIT (- (AREF FIT (1+ INDEX)) (AREF FIT INDEX))
			   (FONT-RASTER-WIDTH FONT)))))
	    BOTTOM (+ CHARACTER-Y-OFFSET (FONT-RASTER-HEIGHT FONT)))
    (WHEN STRING
      (SETQ RIGHT (MAX RIGHT (+ STRING-X-OFFSET
				(SEND SHEET :STRING-LENGTH STRING FROM TO NIL STYLE)))
	    BOTTOM (MAX BOTTOM (+ STRING-Y-OFFSET
				  (SEND SHEET :LINE-HEIGHT)))))
    (VALUES RIGHT BOTTOM)))

(DEFMETHOD (:BLINK CHARACTER-AND-STRING-BLINKER) ()
  (SHEET-DRAW-GLYPH INDEX FONT (+ X-POS CHARACTER-X-OFFSET) (+ Y-POS CHARACTER-Y-OFFSET)
		    BLINKER-ALU SHEET)
  (UNLESS (IF PHASE STRING-WAS-SUPPRESSED SUPPRESS-STRING)
    ;; Draw if position known or if drawn on the screen.
    (SEND SHEET :STRING-OUT-EXPLICIT-INTERNAL STRING
	  (+ X-POS STRING-X-OFFSET) (+ Y-POS STRING-Y-OFFSET)
	  (SHEET-INSIDE-RIGHT SHEET) BLINKER-ALU FROM TO STYLE))
  ;; If drawing, remember whether it was on the screen.
  (WHEN (NOT PHASE)
    (SETQ STRING-WAS-SUPPRESSED SUPPRESS-STRING)))

(DEFMETHOD (:SET-CHARACTER-AND-STRING CHARACTER-AND-STRING-BLINKER)
	   (&KEY ((:CHARACTER NEW-CHARACTER))
		 ((:STRING NEW-STRING))
		 ((:STYLE NEW-STYLE))
		 ((:CHARACTER-X-OFFSET NEW-CHARACTER-X-OFFSET))
		 ((:CHARACTER-Y-OFFSET NEW-CHARACTER-Y-OFFSET))
		 ((:STRING-X-OFFSET NEW-STRING-X-OFFSET))
		 ((:STRING-Y-OFFSET NEW-STRING-Y-OFFSET)))
  (WITH-BLINKER-PREPARED (SELF)
    (WHEN NEW-CHARACTER
      (SEND SELF :SET-CHARACTER NEW-CHARACTER))
    (WHEN (OR NEW-STRING NEW-STYLE)
      (SEND SELF :SET-STRING NEW-STRING NIL NIL NEW-STYLE))
    (WHEN NEW-CHARACTER-X-OFFSET
      (SETQ CHARACTER-X-OFFSET NEW-CHARACTER-X-OFFSET))
    (WHEN NEW-CHARACTER-Y-OFFSET
      (SETQ CHARACTER-Y-OFFSET NEW-CHARACTER-Y-OFFSET))
    (WHEN NEW-STRING-X-OFFSET
      (SETQ STRING-X-OFFSET NEW-STRING-X-OFFSET))
    (WHEN NEW-STRING-Y-OFFSET
      (SETQ STRING-Y-OFFSET NEW-STRING-Y-OFFSET))
    ))

(DEFFLAVOR CHARACTER-AND-OTHER-CHARACTER-BLINKER
	((CHARACTER-X-OFFSET 0)
	 (CHARACTER-Y-OFFSET 0)
	 (OTHER-FONT NIL)
	 (OTHER-CHAR NIL)
	 (OTHER-INDEX NIL)
	 (OTHER-CHARACTER-X-OFFSET 0)
	 (OTHER-CHARACTER-Y-OFFSET 0)
	 (SUPPRESS-OTHER-CHARACTER NIL)
	 (OTHER-CHARACTER-WAS-SUPPRESSED NIL))
	(CHARACTER-BLINKER)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:INIT CHARACTER-AND-OTHER-CHARACTER-BLINKER :BEFORE) (IGNORE)
  (MULTIPLE-VALUE (OTHER-INDEX OTHER-FONT)
    (SHEET-GET-CHAR-INDEX-AND-FONT OTHER-CHAR T SHEET)))

(DEFMETHOD (:SIZE CHARACTER-AND-OTHER-CHARACTER-BLINKER) ()
  (LET ((RIGHT 0)
	(BOTTOM 0))
    (WHEN (AND FONT INDEX)
      (SETQ RIGHT (+ CHARACTER-X-OFFSET
		     (LET ((FIT (FONT-INDEXING-TABLE FONT)))
		       (IF FIT (- (AREF FIT (1+ INDEX)) (AREF FIT INDEX))
			   (FONT-RASTER-WIDTH FONT)))))
	    BOTTOM (+ CHARACTER-Y-OFFSET (FONT-RASTER-HEIGHT FONT)))
    (WHEN (AND OTHER-FONT OTHER-INDEX)
      (SETQ RIGHT (+ OTHER-CHARACTER-X-OFFSET
		     (LET ((FIT (FONT-INDEXING-TABLE OTHER-FONT)))
		       (IF FIT (- (AREF FIT (1+ OTHER-INDEX)) (AREF FIT OTHER-INDEX))
			   (FONT-RASTER-WIDTH OTHER-FONT)))))
	    BOTTOM (+ OTHER-CHARACTER-Y-OFFSET (FONT-RASTER-HEIGHT OTHER-FONT)))
    (VALUES RIGHT BOTTOM)))

(DEFMETHOD (:BLINK CHARACTER-AND-OTHER-CHARACTER-BLINKER) ()
  (SHEET-DRAW-GLYPH INDEX FONT (+ X-POS CHARACTER-X-OFFSET) (+ Y-POS CHARACTER-Y-OFFSET)
		    BLINKER-ALU SHEET)
  (UNLESS (IF PHASE OTHER-CHARACTER-WAS-SUPPRESSED SUPPRESS-OTHER-CHARACTER)
    ;; Draw if position known or if drawn on the screen.
    (SHEET-DRAW-GLYPH OTHER-INDEX OTHER-FONT
		      (+ X-POS OTHER-CHARACTER-X-OFFSET) (+ Y-POS OTHER-CHARACTER-Y-OFFSET)
		      BLINKER-ALU SHEET))
  ;; If drawing, remember whether it was on the screen.
  (WHEN (NOT PHASE)
    (SETQ OTHER-CHARACTER-WAS-SUPPRESSED SUPPRESS-OTHER-CHARACTER)))

(DEFMETHOD (:SET-CHARACTER-AND-OTHER-CHARACTER CHARACTER-AND-OTHER-CHARACTER-BLINKER)
	   (&KEY ((:CHARACTER NEW-CHARACTER))
		 ((:CHARACTER-X-OFFSET NEW-CHARACTER-X-OFFSET))
		 ((:CHARACTER-Y-OFFSET NEW-CHARACTER-Y-OFFSET))
		 ((:OTHER-CHARACTER NEW-OTHER-CHARACTER))
		 ((:OTHER-CHARACTER-X-OFFSET NEW-OTHER-CHARACTER-X-OFFSET))
		 ((:OTHER-CHARACTER-Y-OFFSET NEW-OTHER-CHARACTER-Y-OFFSET)))
  (WITH-BLINKER-PREPARED (SELF)
    (WHEN NEW-CHARACTER
      (SEND SELF :SET-CHARACTER NEW-CHARACTER))
    (WHEN NEW-CHARACTER-X-OFFSET
      (SETQ CHARACTER-X-OFFSET NEW-CHARACTER-X-OFFSET))
    (WHEN NEW-CHARACTER-Y-OFFSET
      (SETQ CHARACTER-Y-OFFSET NEW-CHARACTER-Y-OFFSET))
    (WHEN NEW-OTHER-CHARACTER
      (SETQ OTHER-CHAR NEW-OTHER-CHARACTER)
      (MULTIPLE-VALUE (OTHER-INDEX OTHER-FONT)
	(SHEET-GET-CHAR-INDEX-AND-FONT OTHER-CHAR T SHEET)))
    (WHEN NEW-OTHER-CHARACTER-X-OFFSET
      (SETQ OTHER-CHARACTER-X-OFFSET NEW-OTHER-CHARACTER-X-OFFSET))
    (WHEN NEW-OTHER-CHARACTER-Y-OFFSET
      (SETQ OTHER-CHARACTER-Y-OFFSET NEW-OTHER-CHARACTER-Y-OFFSET))
    ))

(DEFMETHOD (:SET-OTHER-CHARACTER-OFFSETS CHARACTER-AND-OTHER-CHARACTER-BLINKER)
	   (NEW-OTHER-CHARACTER-X-OFFSET NEW-OTHER-CHARACTER-Y-OFFSET)
  (WITH-BLINKER-PREPARED (SELF)
    (SETQ OTHER-CHARACTER-X-OFFSET NEW-OTHER-CHARACTER-X-OFFSET
	  OTHER-CHARACTER-Y-OFFSET NEW-OTHER-CHARACTER-Y-OFFSET)))

(DEFFLAVOR CHARACTER-AND-STRING-AND-OTHER-CHARACTER-BLINKER
	()
	(CHARACTER-AND-STRING-BLINKER CHARACTER-AND-OTHER-CHARACTER-BLINKER)
  )

(DEFMETHOD (:SIZE CHARACTER-AND-STRING-AND-OTHER-CHARACTER-BLINKER) ()
  (LET ((RIGHT 0)
	(BOTTOM 0))
    (WHEN (AND FONT INDEX)
      (SETQ RIGHT (+ CHARACTER-X-OFFSET
		     (LET ((FIT (FONT-INDEXING-TABLE FONT)))
		       (IF FIT (- (AREF FIT (1+ INDEX)) (AREF FIT INDEX))
			   (FONT-RASTER-WIDTH FONT)))))
	    BOTTOM (+ CHARACTER-Y-OFFSET (FONT-RASTER-HEIGHT FONT)))
    (WHEN STRING
      (SETQ RIGHT (MAX RIGHT (+ STRING-X-OFFSET
				(SEND SHEET :STRING-LENGTH STRING FROM TO NIL STYLE)))
	    BOTTOM (MAX BOTTOM (+ STRING-Y-OFFSET
				  (SEND SHEET :LINE-HEIGHT)))))
    (WHEN (AND OTHER-FONT OTHER-INDEX)
      (SETQ RIGHT (+ OTHER-CHARACTER-X-OFFSET
		     (LET ((FIT (FONT-INDEXING-TABLE OTHER-FONT)))
		       (IF FIT (- (AREF FIT (1+ OTHER-INDEX)) (AREF FIT OTHER-INDEX))
			   (FONT-RASTER-WIDTH OTHER-FONT)))))
	    BOTTOM (+ OTHER-CHARACTER-Y-OFFSET (FONT-RASTER-HEIGHT OTHER-FONT)))
    (VALUES RIGHT BOTTOM)))

(DEFMETHOD (:BLINK CHARACTER-AND-STRING-AND-OTHER-CHARACTER-BLINKER) ()
  (SHEET-DRAW-GLYPH INDEX FONT (+ X-POS CHARACTER-X-OFFSET) (+ Y-POS CHARACTER-Y-OFFSET)
		    BLINKER-ALU SHEET)
  ;; Use STRING-WAS-SUPPRESSED for both.
  ;; Requires correct method combination to get :SET-MOTION-PENDING that hacks that.
  (UNLESS (IF PHASE STRING-WAS-SUPPRESSED SUPPRESS-STRING)
    ;; Draw if position known or if drawn on the screen.
    (SEND SHEET :STRING-OUT-EXPLICIT-INTERNAL STRING
	  (+ X-POS STRING-X-OFFSET) (+ Y-POS STRING-Y-OFFSET)
	  (SHEET-INSIDE-RIGHT SHEET) BLINKER-ALU FROM TO STYLE)
    ;; Draw if position known or if drawn on the screen.
    (SHEET-DRAW-GLYPH OTHER-INDEX OTHER-FONT
		      (+ X-POS OTHER-CHARACTER-X-OFFSET) (+ Y-POS OTHER-CHARACTER-Y-OFFSET)
		      BLINKER-ALU SHEET))
  ;; If drawing, remember whether it was on the screen.
  (WHEN (NOT PHASE)
    (SETQ STRING-WAS-SUPPRESSED SUPPRESS-STRING)))

;;;

(DEFFLAVOR BITBLT-BLINKER
	((WIDTH NIL)
	 (HEIGHT NIL)
	 (ARRAY NIL)
	 (DELTA-X 0)
	 (DELTA-Y 0))
	(BLINKER)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:INIT BITBLT-BLINKER :BEFORE) (IGNORE)
  (WHEN (NULL ARRAY)
    (FERROR NIL "Attempt to create a BITBLT-BLINKER without specifying any array"))
  (WHEN (OR (NULL WIDTH) (NULL HEIGHT))
    ;; at least one dimension defaulted from the array
    (MULTIPLE-VALUE-BIND (AWIDTH AHEIGHT)
	(DECODE-RASTER-ARRAY ARRAY)
      (WHEN (NULL WIDTH)
	(SETQ WIDTH AWIDTH))
      (WHEN (NULL HEIGHT)
	(SETQ HEIGHT AHEIGHT)))))

(DEFMETHOD (:SIZE BITBLT-BLINKER) ()
  (VALUES WIDTH HEIGHT))

(DEFMETHOD (:BLINK BITBLT-BLINKER) ()
  (LET* ((X (+ DELTA-X X-POS))
	 (Y (+ DELTA-Y Y-POS))
	 (W (MIN (- (SHEET-WIDTH SHEET) X) WIDTH))
	 (H (MIN (- (SHEET-HEIGHT SHEET) Y) HEIGHT)))
    (WHEN (AND (PLUSP W) (PLUSP H))
      (SHEET-BITBLT BLINKER-ALU W H ARRAY 0 0 NIL X Y SHEET))))

;;;

(DEFFLAVOR REVERSE-CHARACTER-BLINKER
	(CHARACTER
	 ARRAY WIDTH HEIGHT
	 DELTA-X DELTA-Y
	 INDEX
	 (FONT NIL))
	(BLINKER)
  (:GETTABLE-INSTANCE-VARIABLES CHARACTER)
  (:INITABLE-INSTANCE-VARIABLES CHARACTER FONT)
  (:REQUIRED-INIT-KEYWORDS :CHARACTER))

(DEFMETHOD (:INIT REVERSE-CHARACTER-BLINKER :BEFORE) (IGNORE)
  (SEND SELF :SET-CHARACTER CHARACTER FONT))

(DEFMETHOD (:SET-CHARACTER REVERSE-CHARACTER-BLINKER) (NEW-CHARACTER &OPTIONAL USER-FONT)
  (WHEN NEW-CHARACTER
    (MULTIPLE-VALUE (INDEX FONT)
      (SHEET-GET-CHAR-INDEX-AND-FONT NEW-CHARACTER T SHEET))
    (SETF CHARACTER NEW-CHARACTER))
  (WHEN USER-FONT
    (SETF FONT (IF (EQ USER-FONT T)
		   (SHEET-CURRENT-FONT SHEET)
		   (SEND (SHEET-SCREEN SHEET) :PARSE-FONT-DESCRIPTOR USER-FONT))))
  (LET* ((NEW-WIDTH (LET ((CWT (FONT-CHAR-WIDTH-TABLE FONT)))
		      (IF CWT (AREF CWT INDEX) (FONT-CHAR-WIDTH FONT))))
	 (NEW-HEIGHT (FONT-RASTER-HEIGHT FONT))
	 (NEW-ARRAY (MAKE-RASTER-ARRAY (* 32 (CEILING NEW-WIDTH 32)) NEW-HEIGHT
				       :TYPE 'ART-1B))
	 (NEW-DELTA-X (- (LET ((LKT (FONT-LEFT-KERN-TABLE FONT)))
			   (IF LKT (AREF LKT INDEX) 0))))
	 (NEW-DELTA-Y (FONT-BASELINE FONT)))
    ;; This is an operation on an array, not on a screen!
    (WITH-STACK-LIST (BOUNDS 0 0 NEW-WIDTH NEW-HEIGHT)
      (%DRAW-CHAR-CLIPPED-INTERNAL INDEX FONT NEW-DELTA-X NEW-DELTA-Y ALU-SETO NEW-ARRAY
				   BOUNDS))
    (WITH-BLINKER-PREPARED (SELF)
      (SETQ HEIGHT NEW-HEIGHT
	    WIDTH NEW-WIDTH
	    ARRAY NEW-ARRAY
	    DELTA-X NEW-DELTA-X
	    DELTA-Y NEW-DELTA-Y
	    )
      (WHEN (AND VISIBILITY (NEQ VISIBILITY :BLINK))
	(BLINK SELF))
      )
    ))

(DEFMETHOD (:BLINK REVERSE-CHARACTER-BLINKER) ()
  (LET* ((X (+ DELTA-X X-POS))
	 (Y (+ DELTA-Y Y-POS))
	 (W (MIN (- (SHEET-WIDTH SHEET) X) WIDTH))
	 (H (MIN (- (SHEET-HEIGHT SHEET) Y) HEIGHT)))
    (WHEN (AND (PLUSP W) (PLUSP H))
      (SHEET-DRAW-1-BIT-RASTER W H ARRAY 0 0 NIL X Y COLOR:ALU-NOOP BLINKER-ALU SHEET))))

(DEFMETHOD (:SIZE REVERSE-CHARACTER-BLINKER) ()
  (VALUES WIDTH HEIGHT))

(DEFMETHOD (:SET-SIZE REVERSE-CHARACTER-BLINKER) (NEW-WIDTH NEW-HEIGHT)
  NEW-WIDTH NEW-HEIGHT
  ;no can do
  NIL)

(COMPILE-FLAVOR-METHODS RECTANGULAR-BLINKER CHARACTER-BLINKER IBEAM-BLINKER
			STRING-BLINKER BOX-BLINKER HOLLOW-RECTANGULAR-BLINKER
			BITBLT-BLINKER REVERSE-CHARACTER-BLINKER BOXES-BLINKER)
