;;; -*- Mode: LISP; Package: COMMON-LISP-INTERNALS; Syntax: Common-lisp; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This file builds up the inner loop functions for BITBLT and its derivatives.
;;; 
;;; DEBUGGING:
;;;   Because the bitblt inner loops are generated by a large macro, a number of 
;;; aids to debugging have been implemented to avoid repeated compilations of large 
;;; amounts of code to focus in on a particular inner loop. 
;;;
;;; 1) Basic support macros have been provided for both the I-Machine and L-Machine to 
;;;    allow at least preliminary expansion of the inner loop code that is the same on 
;;;    both machines. C-1 C-SHIFT-M will expand a call to DEFINE-BITBLT-INNER-LOOP
;;;    to the first level of macro expansion. M-SHIFT-M will expand it further into 
;;;    machine-dependent code. Working with the L-Machine expansion directly should permit
;;;    some debugging efforts to track down pointer modifications and basic loop iteration. 
;;;
;;; 2) A given call to DEFINE-BITBLT-INNER-LOOP may produce from 1 to 5 inner-loop functions
;;;    covering the basic :FORWARDS and :SIMPLE cases, through to :FORWARDS-WRAP, :BACKWARDS,
;;;    and :BACKWARDS-WRAP. An optional argument to DEFINE-BITBLT-INNER-LOOP will allow you
;;;    to select one or more functions to be generated without the others. A suggested way 
;;;    of working to debug inner loops is to move the relevant call to DEFINE-BITBLT...
;;;    to a temporary file, specify which function you want to inspect and then use 
;;;    C-1 C-SHIFT-M to expand the code; comment out the copy of the DEFINE-BITBLT... call
;;;    and then make local modifications to the function to isolate the bug. When you are 
;;;    done, make the related changes to DEFINE-BITBLT... to install them.
;;;
;;;    Note: The function definitions for the inner loop functions are stored into an array
;;;    so that merely recompiling a new definition will not complete the change. 
;;;    Reevaluate (SETUP-BITBLT-CASES T) at the bottom of this file to reinstall the new 
;;;    definition or setup the real function as an indirect function and have the BB-xxx
;;;    function definition be a dummy which calls the indirect function. 
;;;
;;; 3) Since BITBLT is such an integral component of the environment, debugging the inner
;;;    loops can get into the way of the editor and debugger. While producing a debuggable
;;;    inner loop, leave the original expansion unchanged except for a line which captures
;;;    the arguments on entry and saves them into a global variable. Then edit a copy of
;;;    the inner loop that takes its arguments from the global and make changes to the copy
;;;    to inspect intermediate results. This way the debugging version is not necessarily 
;;;    invoked when the debugger or lisp listener attempts to print out characters. 
;;;    This level of indirection may not be necessary for the less used wrapping cases. 

;;;*********************************************************************
;;; Basic Support macros and functions to manipulate BAR's etc.
;;;
;;; Note that the truncation to 5 bits is essential for correct operation (max 32 bits)
;;; Note: (= 31 (Sum BYTE-R BYTE-S))
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; BAR-1 access and restoration ?

0#+IMACH
(EVAL-WHEN (compile load eval)
(defsubst set-alu-and-rotate-register (alu-op r s)
  (si:set-alu-and-rotate-control :byte-r r
				 :byte-s (1- s)
				 :function-bits alu-op
				 :function-class %alu-function-class-boolean))

;;; This is a fix for end-of-line problems from reading too far past end of source
;;; and is used in place of some cases of (BLOCK-READ-SHIFT 1 :No-Increment t)

(defsubst rotate-latch-contents ()
  (si:saving-registers-for-value (%register-alu-and-rotate-control)
    (si:%rotate-latch)))

(defmacro load-bar (bar value)
  (selector bar =
    (1 `(SETF (SYS:%BLOCK-REGISTER 1) ,value))
    (2 `(SETF (SYS:%BLOCK-REGISTER 2) ,value))
    (3 `(SETF (SYS:%BLOCK-REGISTER 3) ,value))))

;;; These macros provide default parameters in addition to the varying parameters

(defmacro block-read (bar &rest args)
  `(%BLOCK-READ ,bar :SET-CDR-NEXT T :FIXNUM-ONLY T ,@args))

(defmacro block-read-shift (bar &rest args)
  `(%BLOCK-READ-SHIFT ,bar :SET-CDR-NEXT T :FIXNUM-ONLY T ,@args))

(defmacro block-read-alu (bar arg)
  `(%BLOCK-READ-ALU ,bar ,arg))

(defmacro block-write (bar value &optional &key (no-increment))
  (if no-increment
      `(%MEMORY-WRITE (SYS:%BLOCK-REGISTER ,bar) ,value)
      `(%BLOCK-WRITE ,bar ,value)))

(2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB");;; Calls to this should be replaced with %POINTER-PLUS when the debug code is removed
(defsubst ptr+ (base-address offset)
  (%pointer-plus base-address offset))

0) ;END EVAL-WHEN
;;;**********************************************************************
;;; To facilitate debugging the following definitions are provided to allow the same
;;; code to be compiled into L-Machine functions that can be more closely examined
;;; They allow easier macro expansion on the L-Machine and build up emulator functions
;;; that can be used in more closely examining the BITBLT loop behavior.

2;;; To remove this code completely do the following:
;;;   a) remove the #+3600 EVAL-WHEN and its contents
;;;   b) remove the #+IMACH EVAL-WHEN BUT NOT ITS CONTENTS
;;;   c) Replace PTR+ calls with %POINTER-PLUS

0#+3600
(eval-when (compile eval load)

;;; Block register vars 
(defvar bar-1 0)
(defvar bar-2 0)
(defvar bar-3 0)
(defvar byte-r 0)
(defvar byte-s 0)
(defvar alu 0)

(defmacro lbar (n)
  (selector n =
    (1 'bar-1)
    (2 'bar-2)
    (3 'bar-3)))

;;; Debugging print out switches

(defvar *debug-bar-ops* nil)

;;; Substitute functions
(defun set-alu-and-rotate-register (alu-op r s)
  (setq byte-r r
	byte-s (1- s)
	alu alu-op))

;;; This is a fix for end-of-line problems from reading too far past end of source
;;; and is used in place of some cases of (BLOCK-READ-SHIFT 1 :No-Increment t)

(defun rotate-latch-contents ()
  0)

(defun load-bar (bar value)
  (selector bar =
    (1 (setf (lbar 1) value))
    (2 (setf (lbar 2) value))
    (3 (setf (lbar 3) value))))

;;; These macros provide default parameters in addition to the varying parameters

(defun dummy-block-read (bar args)
  (unless (member :no-increment args)
    (selector bar =
      (1 (setf (lbar 1) (+ (lbar 1) 1)))
      (2 (setf (lbar 2) (+ (lbar 2) 2)))
      (3 (setf (lbar 3) (+ (lbar 3) 3)))))
  0)

(defun block-read (bar &rest args)
  (dummy-block-read bar args))

(defun block-read-shift (bar &rest args)
  (dummy-block-read bar args))

(defun block-read-alu (bar arg)
  (ignore arg)
  (dummy-block-read bar '(:no-increment)))

(defun block-write (bar value &optional &key (no-increment))
  (ignore value)
  (unless no-increment
    (selector bar =
      (1 (setf (lbar 1) (+ (lbar 1) 1)))
      (2 (setf (lbar 2) (+ (lbar 2) 2)))
      (3 (setf (lbar 3) (+ (lbar 3) 3))))))

(defun ptr+ (base-address offset)
  (+ base-address offset))

  ) ; End EVAL-WHEN
;;;*********************************************************************
;;; UNROLL-BLOCK-WRITE
;;; 
;;; This macro is custom written for BITBLT to produce the unrolled loop for processing 
;;; the expression in the most efficient form. It expects to receive one of the 
;;; following types of expressions:
;;; 
;;;    CONSTANT                       a symbol representing a constant variable
;;;    (BLOCK-xxx n)                  a simple block operation and bar number
;;;    (logop (BLOCK-xxx n))          a simple block operation and operation on it
;;;    (BLOCK-READ-ALU n (BLOCK-READ-SHIFT m))  an alu op on a block operation result
;;; 
;;; These are compiled into code which unrolls the operation (does UNROLLMENT reads
;;; and then operates on the temporaries and then BLOCK-WRITES out the results) and
;;; provides a loop at the end for fewer than unrollment operations for which 
;;; efficiency is more difficult.
;;;
;;; Augmentations to support color:
;;; if MASK, generate a write-under-mask
;;; also, accept (block-read-shift n constant) (%32-bit-plus s1 s2)
;;; test case:

(defmacro unroll-block-write ((count-var unrollment
					 &key mask backwards setup-function last-row?
					 folded-photon) expr)
  (let* ((expr-type (if (atom expr)
			:CONSTANT
			(case (car expr)
			  (BLOCK-READ-ALU :ALU)
			  ((BLOCK-READ BLOCK-READ-SHIFT) :BLOCK)
			  (%32-bit-plus :FUNC)
			  (t :LOGOP))))
	 (local-var-expr (case expr-type
			   (:CONSTANT nil)
			   ((:FUNC :BLOCK) expr)
			   (:LOGOP (second expr))
			   (:ALU   (third expr))))
	 (modify-expr (case expr-type
			((:CONSTANT :BLOCK :FUNC) nil)
			(:LOGOP (list (first expr)))
			(:ALU   (list (first expr) (second expr)))))
	 (local-var-list (unless (equal expr-type :CONSTANT)
			   (loop for b from 0 below unrollment
				 collect (intern (string-append "UB" (format nil "~D" b))))))
	 (log-unrollment (1- (integer-length unrollment)))
	 (block-read-shift?  (and (listp local-var-expr)
				  (equal (car local-var-expr) 'block-read-shift)))
	 (last-row? (when (and last-row? block-read-shift? (not backwards))
		      last-row?)))

    (flet ((multi-operation-let (n-words no-incr?)
	     (let ((prefetch-cutoff (- unrollment 2))	;Change this to control prefetching
		   (local-vars (butlast local-var-list (- unrollment n-words))))
	       `(LET (,@(if local-vars
			    (loop for var in local-vars
				  for n from 1 
				  collect (list var
						(if no-incr?
						    (if (and (listp local-var-expr)
							     (neq expr-type :func))
							(append local-var-expr
								'(:PREFETCH NIL :NO-INCREMENT T))
							local-var-expr)
						    (if (<= n prefetch-cutoff)
							local-var-expr
							(if (and (listp local-var-expr)
								 (neq expr-type :func))
							    (append local-var-expr
								    '(:PREFETCH NIL))
							    local-var-expr)))))))
		  ,@(if (equal expr-type :logop)
			(loop for var in local-vars
			      collect (list 'SETQ var (append modify-expr (list var))))
			(if (equal expr-type :alu)
			    (loop for var in local-vars
				  collect (append modify-expr (list var)))))
		  
		  ,@(if (equal expr-type :constant)
			(loop repeat n-words
			      as exp =
				 (if mask
				     (if folded-photon
					 (error "shouldn't mask in folded photon")
					 `(let ((temp ,expr))
					    (LOGXOR TEMP
						    (LOGAND ,MASK
							    (LOGXOR TEMP
								    (BLOCK-READ 3 :NO-INCREMENT T))))))
				     EXPR)
			      collect
				`(BLOCK-WRITE 3 ,exp))
			(loop for var in local-vars
			      as exp = (if mask
					   (if folded-photon
					       (error "shouldn't mask in folded photon")
					       `(logxor ,var
							(logand ,mask
								(logxor ,var
									(block-read 3 :no-increment t)))))
					   var)
			      collect
				`(BLOCK-WRITE 3 ,exp)
				))))))
      (let ((clauses
	   ;;*********************************************************************
	   ;;  Build up the main cycle
	   ;;    (LET ((temp1 (block-read-xxx 1 ...))
	   ;;          ...
	   ;;          (tempn (block-read-xxx 1 ... :prefetch nil)))
	   ;;      (operation on temp - such as block-read-alu or inversion)
	   ;;      (block-write temp1)...)

	      (loop for n from log-unrollment downto 0
		    as count = (lsh 1 n)
		    as clause = (multi-operation-let count nil)
		    as setup-clause = (if setup-function
					  (funcall setup-function count clause)
					  clause)
		    collect
		      (if (= n log-unrollment)
			  `(LOOP REPEAT (%LOGLDB (BYTE ,(- 32 n) ,n)
						 ,(if last-row? 'N-WORD-COUNT count-var))
				 DO
			     ,setup-clause)
			  `(IF (LDB-TEST (BYTE 1 ,n)
					 ,(if last-row? 'N-WORD-COUNT count-var))
			       ,setup-clause))
		      )))

	(when backwards (setq clauses (reverse clauses)))

	(if last-row?
	    `(LET ((N-WORD-COUNT ,count-var))

	       ,(if (equal last-row? t)
		    `((DECF N-WORD-COUNT))
		    `((IF ,last-row? (DECF N-WORD-COUNT))))
	       (SI:PREPARE-FOR-BLOCK-WRITE)
	       (when (plusp  n-word-count)
		 ,@clauses)
	       (,@(if (equal last-row? t)
		    `(UNLESS (MINUSP N-WORD-COUNT))
		    `(WHEN (AND ,last-row? (>= N-WORD-COUNT 0))))
		,(multi-operation-let 1 t)))
	    `(progn (si:prepare-for-block-write)
		   ,@clauses)
	   )))))

#||

;   Test cases for unroll-block-write
(defun q1 (n-words a)
  (unroll-block-write (n-words 8) (block-read-alu 2 (block-read-shift 1))))

(defun backwards-setup (n body)
  `(progn (decf count ,n)
	  ,body))
(unroll-block-write (n-words 8 :backwards t :setup-function backwards-setup)
		    (block-read-alu 2 (block-read-shift 1)))

(unroll-block-write (n-words 4 :last-row? t) (lognot (block-read-shift 1)))	;BOOLE-C1

(unroll-block-write (n-words 4)   (block-read 2))	                ;BOOLE-2

(unroll-block-write (n-words 4)   constant-source)	                ;BOOLE-SET, BOOLE-CLR

;test cases for color options
(unroll-block-write (word-width 4)
		    (block-read-alu 2 constant-source))

(unroll-block-write (word-width 1)
		    (%32-bit-plus (block-read 2) constant-source))

||#


(defmacro with-bitblt-inner-loop-environment ((alu-op source-dependent? dest-dependent?
						      &optional (multiple-row? t)
						      folded-photon)
					      &body body
					      &aux
					      (constant-source
						(eq source-dependent? :constant))
					      (masked (member dest-dependent?
							      '(:t-masked :nil-masked)))
					      (dest-dependent?
						(member dest-dependent? '(t :t-masked))))
  `(LET* (,@(if (not (or source-dependent? dest-dependent?))
		`((CONSTANT-SOURCE (IF (= ,alu-op BOOLE-SET) -1 0))))
	  ,@(when (eq source-dependent? :constant)
	      `((constant-source ,(if folded-photon -1
				      `(if (eql ,alu-op boole-c1)
					   (lognot tv:bitblt-unpacking-constant)
					   tv:bitblt-unpacking-constant)))))
	  ,@(when masked
	      `((write-protect-mask (lognot tv:bitblt-unpacking-mask))
		(first-column-mask (logand first-column-mask
					   tv:bitblt-unpacking-mask))
		(last-column-mask (logand last-column-mask
					  tv:bitblt-unpacking-mask)))
	      )
	  ,@(if (and source-dependent? (not folded-photon))
		(let ((first-mask '(LOGNOT FIRST-COLUMN-MASK))
		      (last-mask '(LOGNOT LAST-COLUMN-MASK)))
		  `((NEG-FIRST-MASK ,(if masked
					 `(logior ,first-mask write-protect-mask)
					 first-mask))
		    (NEG-LAST-MASK ,(if masked
					`(logior ,last-mask write-protect-mask)
					last-mask)))))
	  )
     ,@(unless (and source-dependent? (not constant-source))
	`((IGNORE S-ROW-ADDRESS BIT-OFFSET SOURCE-OVERHANG?
		  ,@(if multiple-row? `(S-ROW-SPAN)))))	;Simple case doesn't have this arg
     (#+IMACH SYS:WITH-BLOCK-REGISTERS #+IMACH (1 2 3)
      #+3600 PROGN
       ,@body
       ;; Clear BAR-1 when done since WITH-BLOCK-REGISTERS will not save its value
       ;; and it may be pointing beyond the end of the source array
       ,@(if (and source-dependent? (not constant-source))
	     `((LOAD-BAR 1 NIL)))
       )))

;;;*********************************************************************
;;; This macro defines the BITBLT inner loops which can only be called within IBITBLT
;;; functions.
;;; 
;;;    INPUT:
;;;       NAME                    Base name of the functions to be produced
;;;       DEPENDS-ON-SOURCE?      Operation uses the source array as input for the operation.
;;;       DEPENDS-ON-DESTINATION? Operation uses the destination as input for the operation.
;;;       UNROLLMENT              Number of words to be processed in a complete group.
;;;       ALUS-HANDLED            List of actual alu ops which use this function family
;;;                               (Currently ignored-bitblt case array setup by 
;;;                                  SETUP-BITBLT-CASES)

(defmacro define-bitblt-inner-loop
	  (name depends-on-source? depends-on-destination? unrollment
				    alus-handled 
				    &optional
				    (generation-selection 
				      '(:FORWARDS :FORWARDS-WRAP
					:BACKWARDS :BACKWARDS-WRAP :SIMPLE
					))
				    (folded-photon nil)
				    &aux
				    (original-depends-on-destination?
				      depends-on-destination?)
				    (mask-destination
				      (member depends-on-destination?
					  '(:T-MASKED :NIL-masked)))
				    (depends-on-destination?
				      (member depends-on-destination? '(t :t-masked)))
				    (constant-source
				      (eq depends-on-source? :constant))
				    (log-unrollment (1- (integer-length unrollment)))
				    (forwards-fun
				      (intern (string-append name "-FORWARDS")))
				    (forwards-wrap-fun
				      (intern (string-append name "-FORWARDS-WRAP")))
				    (backwards-fun
				      (intern (string-append name "-BACKWARDS")))
				    (backwards-wrap-fun
				      (intern (string-append name "-BACKWARDS-WRAP")))
				    (simple-fun
				      (intern (string-append name "-SIMPLE")))
				    (boolean-alus)
				    )

  (assert (cond ((listp alus-handled)
		 (when (loop with bitblt-alus =
			       '(boole-clr boole-set boole-1   boole-c1
					   boole-2   boole-c2 boole-and  boole-ior
					   boole-xor   boole-eqv  boole-nand
					   boole-nor  boole-andc1 boole-andc2
					   boole-orc1 boole-orc2)
			     for i in alus-handled always (member i bitblt-alus))
		   (setq boolean-alus t)))
		((eq alus-handled 'sys:%32-bit-plus)))
	  (alus-handled)
	  "not all alus handled")


;;;********************************************************************** MOON'S COMMENTS
;;; Issue: Does per-row loop fit in the I Cache, to avoid memory interference?
;;;        Should additional code duplication be used to decrease the number of
;;;        dispatches per row from 3 to 1?
;;;        Should partial words at the edges be handled by separate iterations sometimes?
;;;
;;; This always prefetches one extra word while prefetching blocks.  In the aligned-at-right
;;; case that is a waste, but doesn't cause memory interference if I have correctly
;;; guess the bus timing for write.  In the unaligned-at-right case it's a word that you
;;; really need (of course it's only useful to prefetch it if it will be held in a cache
;;; across other memory operations).  In the very wide (multiple blocks) case the extra
;;; word saves time starting up the next block.
;;; For all this to work the cache size must be twice the unrollment.
;;; It works better if the cache size  2(unrollment+1).
;;;**********************************************************************

  (assert (= unrollment (expt 2 log-unrollment)) (unrollment) "a power of 2")

  (labels ((setup-registers (alu bit-offset)

	     ;;************************************************************
	     ;; Initialize internal control registers
	     ;; BYTE-R and BYTE-S control block shifts to align source with dest
	     ;; ALU controls Block-alu operations

	   `(,@(unless boolean-alus
		 `((ignore ,alu)))

	     ,@(when folded-photon
		 `(,(folded-photon-remask 'last-column-mask
					  '(%pointer-plus
					     d-row-address
					     (+ word-width
						(if (zerop first-column-mask) 0 1)))
					  )
		   ,(folded-photon-remask 'first-column-mask 'd-row-address)))
	     ,@(if depends-on-source?
		   (if constant-source
		       `((SET-ALU-AND-ROTATE-REGISTER
			   2(BITBLT-ALU-MAP ,0(if boolean-alus 2alu0 boole-2))	;MOVE OUTSIDE
			   0 0))
		       `((SET-ALU-AND-ROTATE-REGISTER
			   2(BITBLT-ALU-MAP ,0(if boolean-alus 2alu0 boole-22)0)	;MOVE OUTSIDE
			   ,bit-offset (- ,bit-offset)))))
		   ))
	   (folded-photon-remask (word pointer)
	     `(setq ,word
		    (lsh (sys:%logdpbs
			   (sys:%logldb (byte 1 28) ,word) (byte 25 7)
			   (sys:%logldb (byte 1 24) ,word) (byte 1 6)
			   (sys:%logldb (byte 1 20) ,word) (byte 1 5)
			   (sys:%logldb (byte 1 16) ,word) (byte 1 4)
			   (sys:%logldb (byte 1 12) ,word) (byte 1 3)
			   (sys:%logldb (byte 1 8) ,word) (byte 1 2)
			   (sys:%logldb (byte 1 4) ,word) (byte 1 1)
			   ,word)
			 (lsh (sys:%logldb (byte 2 0) (sys:%pointer ,pointer)) 3)
			 ))
	     )


	   (setup-bars (&optional &key (offset nil)
				  (dest-offset nil)
				  (load-rotate-latch nil)
				  (last-word nil)
				  (backup-offset)
				  (backwards-load? nil))

            ;; Expects the following locals: BIT-OFFSET, S-ROW-ADDR, D-ROW-ADDR		      

	    ;;This macro sets up the code to load the three BAR registers according to 
	    ;;the operations needs. It permits the address to include an offset to allow
            ;;the backwards function to backup by groups of block-operations, resetting the
	    ;;BAR address to the beginning of each group. 

            ;; OFFSET - Fixnum form or NIL		       
            ;;   An offset to be added to the start of the row to get to the words that
            ;;   you want to start processing, added to source and dest row addresses.

            ;; DEST-OFFSET - Fixnum for or NIL
            ;;   An independent destination offset that is only used when it is non-NIL

	    ;; LOAD-ROTATE-LATCH  - Condition form to evaluate or NIL
	    ;;   This argument is a condition which when true indicates the need
	    ;;   to perform a BLOCK-1-READ-SHIFT to load data into the rotate latch
            ;;   before the first combination operation, i.e. priming the pipeline. 
            ;;
            ;; BACKWARDS-LOAD? - Special case which determines from context need to preload
            ;;   If this is non-nil then load-rotate-latch is ignored. The value may be
	    ;;   :WRAP or :NO-WRAP to distinguish the two backwards cases. 
            ;;   The backwards case is complicated because the rotate-latch will not have
            ;;   the remainder of the last word from the previous unrollment group as it
            ;;   does in the forwards case, so it must be preloaded at the outset of each
            ;;   each group. Note that when bits are shifted left on the screen (visually)
            ;;   they are actually shifted right within the fixnum that contains them 
            ;;   because the bit order seen on the screen is 0 to 31 while the fixnum is 
            ;;   store as 31 to 0. The following rules govern the impact of :BACKWARDS
            ;;   
            ;;   (MINUSP BIT-OFFSET)  Source must be (visually) shifted LEFT 
            ;;      Preload CURRENT word (no need to worry about preceding word)
            ;;   (ZEROP BIT-OFFSET)   No shift is needed, just prime latch with first word
            ;;      No preload as the result does not involve the rotate latch
            ;;   (PLUSP BIT-OFFSET)   Source must be (visually) shifted RIGHT
            ;;      Preload PREVIOUS word when OFFSET is greater than 0. 
            ;;      That is load previous word for unrollment groups and last column mask
            ;;      BUT do not preload when OFFSET is 0 (i.e. first column mask)
	    ;;      because implicitly the bits from the rotate latch are masked out
	    ;;   The :WRAP case handles loading the last word of the row as 
	    ;;   the latch value and then setting the BAR to the first word of the row.

            ;; LAST-WORD - NIL or Form
            ;;   Since we may preload a word that is the very last word in a row
            ;;   we need to make sure that if the last word is loaded, that NO-INCREMENT is 
            ;;   applied. 

	     (cond ((or offset dest-offset backwards-load?)
		    (if (null offset) (setq offset 0))
		    `(LET* ((DEST-ADDR-VAR (PTR+ D-ROW-ADDRESS
						       ,(if dest-offset dest-offset offset)))
			    ,@(when (and depends-on-source? (not constant-source))
				(select backwards-load?
				  (:wrap 
				    `((BACKUP-OFFSET? (AND (PLUSP BIT-OFFSET)
							   (PLUSP ,OFFSET)
							   ,@(when backup-offset
							       `(,backup-offset))
							   ))
				      (BACKUP-WRAP? (AND (NOT BACKUP-OFFSET?)
							 ( bit-offset 0)
							 (= ,offset ,last-word)))
				      (SOURCE-ADDR-VAR
					(PTR+ S-ROW-ADDRESS
					      (IF BACKUP-OFFSET?
						  (1- ,offset)
						  ,offset)))))
				  (:no-wrap
				    `((BACKUP-OFFSET? (and (PLUSP BIT-OFFSET)
							   (plusp ,offset)))
				      (SOURCE-ADDR-VAR
					(PTR+ S-ROW-ADDRESS
						    (IF BACKUP-OFFSET?
							(1- ,offset) ,offset)))))
				  (T `((SOURCE-ADDR-VAR (PTR+ S-ROW-ADDRESS
								       ,offset)))))
				))
		       ,@(when depends-on-source?
			   `(,@(unless constant-source
				 `((LOAD-BAR 1 SOURCE-ADDR-VAR)))
			     ,(select backwards-load?
				(:wrap
				  `(WHEN (OR BACKUP-WRAP? ( BIT-OFFSET 0))
				     ,(cond (constant-source nil)
					    #||
					    (last-word
					     `(IF (= ,last-word ,offset)
						  2(BLOCK-READ-SHIFT 1 :NO-INCREMENT T
0								    2:PREFETCH NIL)
0						2;0(ROTATE-LATCH-CONTENTS)
						  (BLOCK-READ-SHIFT 1)))
					    ||#
					    (t `(BLOCK-READ-SHIFT 1)))
				     ,@(unless constant-source
					 `((IF BACKUP-WRAP?	
					       (LOAD-BAR 1 S-ROW-ADDRESS))))))
				(:no-wrap
				  `(WHEN ( BIT-OFFSET 0)
				     ,(cond (constant-source nil)
					    #||
					    (last-word
					     `(IF (AND (= ,last-word ,offset)
						       (NOT BACKUP-OFFSET?))
						  2(BLOCK-READ-SHIFT 1 :NO-INCREMENT T
0								    2:PREFETCH NIL)
0						2;0(ROTATE-LATCH-CONTENTS)
						  (BLOCK-READ-SHIFT 1))) ||#
					    (t `(unless (and (plusp bit-offset)
							    (zerop ,offset))
						  (BLOCK-READ-SHIFT 1))))))
				(t
				  (if load-rotate-latch
				  `(WHEN LOAD-ROTATE-LATCH
				     ,(cond (constant-source nil)
					    #||
					    (last-word
					     `(IF (= ,last-word ,offset)
						  2(BLOCK-READ-SHIFT 1 :NO-INCREMENT T
0								    2:PREFETCH NIL)
0						2;0(ROTATE-LATCH-CONTENTS)
						  (BLOCK-READ-SHIFT 1)))
					    ||#
					    (t `(BLOCK-READ-SHIFT 1)))))))
			     ))
		       ,(when depends-on-destination? `(LOAD-BAR 2 DEST-ADDR-VAR));Dest read
		       (LOAD-BAR 3 DEST-ADDR-VAR)))	                           ;Dest write
		   (t
		    `(PROGN
		       ,@(when (and depends-on-source? (not constant-source))
			   `((LOAD-BAR 1 S-ROW-ADDRESS)
			     ,(if load-rotate-latch
				  `(WHEN ,load-rotate-latch
				     (BLOCK-READ-SHIFT 1)))))
		       ,(when depends-on-destination?
			  `(LOAD-BAR 2 D-ROW-ADDRESS))  ;Dest read
		       (LOAD-BAR 3 D-ROW-ADDRESS)))))	;Dest write

;;;*********************************************************************
;;; 
;;;
	   (unroll-n-words (n-words &rest keywords &key folded-photon &allow-other-keys)

            ;; Expects the following locals: ALU, UNROLLMENT			   
	     (let ((keywords (zl:copylist keywords)))
	    (cond ((and depends-on-source? depends-on-destination?)	
		   ;; Read and shift source, combine with destination and write
		   `(UNROLL-BLOCK-WRITE
		      (,n-words ,unrollment ,@keywords)
		      ,(IF BOOLEAN-ALUS
			   `(BLOCK-READ-ALU 2 ,(if constant-source
						   'constant-source
						   '(BLOCK-READ-SHIFT 1)))
			   (if folded-photon
			       (error "shouldn't ADD in folded photon")
			       `(SYS:%32-BIT-PLUS (BLOCK-READ 2)
						  ,(if constant-source
						       'constant-source
						       '(BLOCK-READ-SHIFT 1))))
			   )))

		  (depends-on-source?
		   ;; Copy a block of source into buffer, aligned with the destination
		   ;; Store into the destination, complementing if desired
		   ;; Complementing takes 1 or 2 extra cycles
		   `(IF (= ALU BOOLE-C1)
			(UNROLL-BLOCK-WRITE (,n-words ,unrollment ,@keywords)	;BOOLE-C1
			  (LOGNOT ,(if constant-source
				       'constant-source
				       '(BLOCK-READ-SHIFT 1))))
			
			(UNROLL-BLOCK-WRITE (,n-words ,unrollment ,@keywords)	;BOOLE-1
					    ,(if constant-source
						 'constant-source
						 '(BLOCK-READ-SHIFT 1))
					    )))
		      
		  (depends-on-destination?
		   ;; Identity operation still modifies
		   ;; the destination, to get the right values in BAR-2 and BAR-3 and
		   ;; because no one would ever use it unless they were testing memory

		   ;; Read destination, Store it back, complementing if desired
		   ;; Complementing takes 1 or 2 extra cycles
		   (if folded-photon
		       (error "can't do depends-on-destination in folded photon")
		       `(IF (= ALU BOOLE-C2)
			    (UNROLL-BLOCK-WRITE (,n-words ,unrollment ,@keywords)	;BOOLE-C2
						(LOGNOT (BLOCK-READ 2))
						)

			    (UNROLL-BLOCK-WRITE (,n-words ,unrollment ,@keywords)	;BOOLE-2
						(BLOCK-READ 2)
						))))
		      
		  (t
		   ;; Fill the destination with a constant value
		   `(UNROLL-BLOCK-WRITE (,n-words ,unrollment ,@keywords)
					;BOOLE-SET, BOOLE-CLR
		      CONSTANT-SOURCE
		      )))))

;;;*********************************************************************
;;;
;;;
	     (do-masked-word (mask neg-mask &optional overhang no-incr)
               ;; Expects the following locals: ALU
	       ;; Only doing part of the destination.  Maybe some cases of this would
	       ;; do better with DPB, but it's a pain to keep changing the BYTE-R/S registers
	       (if no-incr (setq no-incr '(:NO-INCREMENT T)))
	       (if depends-on-source?
		   (let* ((source (cond (constant-source 'constant-source)
					(overhang
					 `(IF ,overhang
					      (BLOCK-READ-SHIFT 1 :PREFETCH NIL ,@no-incr)
					      (ROTATE-LATCH-CONTENTS)))
					(t `(BLOCK-READ-SHIFT 1 :PREFETCH NIL ,@no-incr)))))
		     (if depends-on-destination?
			 ;; Depends on both source and destination
			 (if folded-photon
			     (error "can't do depends-on-destination in folded photon")
			     `(LET ((NEW ,source)	;aligned source
				    (OLD (BLOCK-READ 2 :NO-INCREMENT
						     ,(IF BOOLEAN-ALUS T NIL))))	;raw destination
				,(if boolean-alus
				     `(BLOCK-READ-ALU 2 NEW)	;combine source and dest
				     `(setq new (,alus-handled new old)))
				,(UNLESS NO-INCR
				   `(SI:PREPARE-FOR-BLOCK-WRITE))
				(BLOCK-WRITE 3 (LOGIOR (LOGAND NEW ,mask)
						       (LOGAND OLD ,neg-mask)) ,@no-incr)))

			 ;; Doesn't depend on destination, so mask off dest bits storing into
			 `(BLOCK-WRITE 3
				       (PROG1 (LOGIOR (IF (= ALU BOOLE-C1)
							  (LOGANDC1 ,source ,mask)	;BOOLE-C1
							  (LOGAND ,source ,mask))	;BOOLE-1
						      ,@(unless folded-photon
							  `((LOGAND (BLOCK-READ 3 :NO-INCREMENT T
									  :PREFETCH NIL)
							      ,neg-mask))))
					      ,(UNLESS NO-INCR
						 `(SI:PREPARE-FOR-BLOCK-WRITE)))
				       ,@no-incr)))
		   ;; CONSTANT-SOURCE case
		   (if depends-on-destination?
		       ;; Depends only on the destination
		       (if folded-photon
			   (error "can't do depends-on-destination in folded photon")
			   `(BLOCK-WRITE 3
					 (PROG1 (IF (= ALU BOOLE-C2)
						    (LOGXOR (BLOCK-READ 2 :PREFETCH NIL ,@no-incr) 
							    ,mask)
						    (BLOCK-READ 2 :PREFETCH NIL ,@no-incr))
						,(UNLESS NO-INCR
						   `(SI:PREPARE-FOR-BLOCK-WRITE)))
					 ,@no-incr))	;BOOLE-1

		       ;; Depends on neither the source nor the destination
		       `(BLOCK-WRITE 3
			  (PROG1 
			    ,(if folded-photon
				 `(if (= alu boole-set)
				      (block-write 3 ,mask)
				      (block-write 3 (lognot ,mask)))
				 `(IF (= ALU BOOLE-SET)
				      (LOGIOR (BLOCK-READ 3 :NO-INCREMENT T
							  :PREFETCH NIL)
					      ,mask)
				      (LOGANDC2 (BLOCK-READ 3 :NO-INCREMENT T
							    :PREFETCH NIL)
						,mask)))
			    ,(UNLESS NO-INCR
			       `(SI:PREPARE-FOR-BLOCK-WRITE)))
			  ,@no-incr))))
	     ) ; End of labels functions
;;;*********************************************************************
;;;
;;;
    `(progn
       ,@(when (member :FORWARDS generation-selection)
	     `((DEFUN ,forwards-fun (ALU S-ROW-ADDRESS S-ROW-SPAN D-ROW-ADDRESS D-ROW-SPAN
				     HEIGHT BIT-OFFSET WORD-WIDTH
				     FIRST-COLUMN-MASK LAST-COLUMN-MASK
				     SOURCE-OVERHANG?)
	 
		 (WITH-BITBLT-INNER-LOOP-ENVIRONMENT (ALU ,depends-on-source?
							  ,original-depends-on-destination?
							  t
							  ,folded-photon)
		   ;;************************************************************
		   ;; Initialize Shift and ALU operation register

		   ,@(setup-registers 'alu 'bit-offset)

		   ;;************************************************************
		   ;; Process successive rows
	   
		   (LOOP FOR ROW FROM 1 TO HEIGHT
			 DO
		     ,(setup-bars :load-rotate-latch '(MINUSP BIT-OFFSET))

		     ;;****************************************
		     ;; Process first partial destination word	     
		     ;;   SETUP-BARS will prime rotate-latch as needed
		     ;; If shifting source right, fetch second source word.
		     ;; If shifting source left, or not at all, fetch the first word.
	     
		     (UNLESS (ZEROP FIRST-COLUMN-MASK)
		       ,(do-masked-word `FIRST-COLUMN-MASK 'NEG-FIRST-MASK))
	     
		     ;;****************************************
		     ;; Do full words in unrollment groups and 
		     ;;   then in a loop of < unrollment words
	     
		     ,(unroll-n-words 'WORD-WIDTH
				      :mask (when mask-destination 'write-protect-mask)
				      :folded-photon folded-photon)
	     
		     ;;****************************************
		     ;; Process last partial destination word
		     ;; We may or may not need to fetch one additional source word
	     
		     (UNLESS (ZEROP LAST-COLUMN-MASK)
		       ,(do-masked-word `LAST-COLUMN-MASK 'NEG-LAST-MASK `SOURCE-OVERHANG? T))
	     
		     ;;****************************************
		     ;; Setup for next row
		     (UNLESS (= ROW HEIGHT)
		       ,@(when (and depends-on-source? (not constant-source))
			   `((SETQ S-ROW-ADDRESS (PTR+ S-ROW-ADDRESS S-ROW-SPAN))))
		       (SETQ D-ROW-ADDRESS (PTR+ D-ROW-ADDRESS D-ROW-SPAN))))))))

;;;*********************************************************************
;;; Source Wraparound case 
;;;
       ,@(when (and depends-on-source? (member :FORWARDS-WRAP generation-selection))
	   (FLET ((DO-IT ()
            `((DEFUN ,forwards-wrap-fun (ALU S-ROW-ADDRESS S-ROW-SPAN 
					 D-ROW-ADDRESS D-ROW-SPAN
					 HEIGHT BIT-OFFSET WORD-WIDTH
					 FIRST-COLUMN-MASK LAST-COLUMN-MASK
					 SOURCE-OVERHANG?
					 S-COL-WORD S-WIDTH-WORDS
					 S-ROW S-HEIGHT)
		
		(DECLARE (FUNCTION-PARENT ,forwards-fun DEFUN))
		(IGNORE SOURCE-OVERHANG?)
		 
		(WITH-BITBLT-INNER-LOOP-ENVIRONMENT (ALU ,depends-on-source?
							 ,original-depends-on-destination?
							 t
							 ,folded-photon)
		   
		  ;;************************************************************
		  ;; Initialize Shift and ALU operation register

		  ,@(setup-registers 'ALU 'BIT-OFFSET)
		   
		  (macrolet ((source-wrap (n-words)
			       ;; N-WORDS swallowed from source, may be time to wrap
			       `(UNLESS (PLUSP (DECF S-WIDTH-REMAINING ,n-words))
				  (LOAD-BAR 1 S-ROW-START)
				  (SETQ S-WIDTH-REMAINING S-WIDTH-WORDS))))
		     
		    ;;************************************************************
		    ;; Process successive rows
		     
		    (LET* ((VERTICAL-REVERSE (MINUSP S-ROW-SPAN))
			   (MORE-SOURCE? NIL)
			   (VERTICAL-START (IF VERTICAL-REVERSE (1- S-HEIGHT) 0))
			   (S-ROW-START (PTR+ S-ROW-ADDRESS (- S-COL-WORD)))
			   (S-VERTICAL-WRAP (* S-ROW-SPAN (- 1 S-HEIGHT)))
			   )
		      (LOOP FOR ROW FROM 1 TO HEIGHT
			    AS S-WIDTH-REMAINING = (- S-WIDTH-WORDS S-COL-WORD) DO
			(SETQ MORE-SOURCE? (IF VERTICAL-REVERSE
					       (>= (DECF S-ROW) 0)
					       (< (INCF S-ROW) S-HEIGHT)))
			,(setup-bars)
			 
			;;****************************************
			;; Iterate over columns
			;; The Rotate Latch contains source bits left over from previous 
			;; dest word, rotated to align them with the destination.  
			;; When BIT-OFFSET=0, Rotate-latch is empty,so DPB 32-bit bytes.
			 
			(WHEN (MINUSP BIT-OFFSET)
			  ;; If source is being shifted right, fetch the initial word, 
			  ;; part of which is going to be thrown away, and leave the 
			  ;; remainder of it in Rotate-latch, aligned.
			  ;; Do maximal prefetching (why not?)

			  (BLOCK-READ-SHIFT 1)
			  (SOURCE-WRAP 1))
			 
			;;****************************************
			;; Process first partial destination word	     
			;;   (SETUP-BARS could preload, but not source-wrap)
			;; If shifting source right, fetch second source word.
			;; If shifting source left, or not at all, fetch the first word.
			 
			(UNLESS (ZEROP FIRST-COLUMN-MASK)
			  ,(do-masked-word `FIRST-COLUMN-MASK 'NEG-FIRST-MASK)
			  (SOURCE-WRAP 1))
			 
			;;****************************************
			;; Do full words in unrollment groups and 
			;;   then in a loop of < unrollment words
			;; Wrap within the source width 
			 
			(LOOP WITH REMAINING-WIDTH = WORD-WIDTH
			      WHILE (PLUSP REMAINING-WIDTH)
			      AS THIS-WIDTH = (MIN REMAINING-WIDTH S-WIDTH-REMAINING) DO
			  ,(unroll-n-words 'THIS-WIDTH
					   :mask (when mask-destination 'write-protect-mask)
					   :folded-photon folded-photon
					   )
			  (SOURCE-WRAP THIS-WIDTH)
			  (DECF REMAINING-WIDTH THIS-WIDTH))
			 
			;;****************************************
			;; Process last partial destination word
			;; We may or may not need to fetch one additional source word
			 
			(UNLESS (ZEROP LAST-COLUMN-MASK)
			  ,(do-masked-word `LAST-COLUMN-MASK 'NEG-LAST-MASK
					   `SOURCE-OVERHANG? T))
			 
			;;****************************************
			;; Setup for next row
			;; wrapping vertically if necessary
			 
			(UNLESS (= ROW HEIGHT)
			  (IF MORE-SOURCE? 
			      (SETQ S-ROW-ADDRESS (PTR+ S-ROW-ADDRESS S-ROW-SPAN)
				    S-ROW-START (PTR+ S-ROW-START S-ROW-SPAN))
			     
			      ;; Source wraparound in the Y direction
			      (SETQ S-ROW VERTICAL-START
				    S-ROW-ADDRESS (PTR+ S-ROW-ADDRESS
							S-VERTICAL-WRAP)
				    S-ROW-START (PTR+ S-ROW-START S-VERTICAL-WRAP)))
			 
			  (SETQ D-ROW-ADDRESS (PTR+ D-ROW-ADDRESS D-ROW-SPAN)))))))))))
	     (DO-IT)))

;;;*********************************************************************
;;;
;;;
       ,@(when (and depends-on-source? (member :BACKWARDS generation-selection))
	   (when folded-photon
	     (error "backwards photon folded is not supported or necessary"))
	   (FLET ((DO-IT ()
            `((DEFUN ,backwards-fun (ALU S-ROW-ADDRESS S-ROW-SPAN
				     D-ROW-ADDRESS D-ROW-SPAN
				     HEIGHT BIT-OFFSET WORD-WIDTH
				     FIRST-COLUMN-MASK LAST-COLUMN-MASK
				     SOURCE-OVERHANG?1)
0		(DECLARE (FUNCTION-PARENT ,FORWARDS-FUN DEFUN))
		 
		(WITH-BITBLT-INNER-LOOP-ENVIRONMENT (ALU ,depends-on-source?
							 ,original-depends-on-destination?
							 t
							 ,folded-photon)

		  ;;************************************************************
		  ;; Initialize Shift and ALU operation register
		   
		  ,@(setup-registers 'ALU 'BIT-OFFSET)
		   
		  ;;************************************************************
		  ;; Process successive rows
		   
		  (LOOP FOR ROW FROM 1 TO HEIGHT
			WITH LAST-WORD-OFFSET = (IF (ZEROP FIRST-COLUMN-MASK)
						    WORD-WIDTH (1+ WORD-WIDTH)) DO

		    ;;****************************************
		    ;; Process last partial destination word
		    ;; We may or may not need to fetch one additional source word
		     
		    (UNLESS (ZEROP LAST-COLUMN-MASK)
		      ,(setup-bars :offset `LAST-WORD-OFFSET :backwards-load? :no-wrap)
		      ,(do-masked-word `LAST-COLUMN-MASK 'NEG-LAST-MASK `SOURCE-OVERHANG? T))
		     
		    ;;****************************************
		    ;; Do full words in unrollment groups and 
		    ;;   then in a loop of < unrollment words
		    ;;   resetting the BARs each time to the 
		    ;;   beginning of the group
		     
		    (let ((front (IF (ZEROP FIRST-COLUMN-MASK) 0 1))
			  (tail word-width))
		      ,(labels ((backward-bar-setup (n body)
				  `(progn (decf tail ,n)
					  ,(setup-bars :offset `(+ front tail)
						       :backwards-load? :no-wrap)
					  ,body)))
			 (unroll-n-words 'tail
					 :mask (when mask-destination 'write-protect-mask)
					 :backwards t
					 :folded-photon folded-photon
					 :setup-function #'backward-bar-setup)))
			  
		    ;;****************************************
		    ;; Process first partial destination word	     
		    ;;   SETUP-BARS will prime rotate-latch as needed
		    ;; If shifting source right, fetch second source word.
		    ;; If shifting source left, or not at all, fetch the first word.
		     
		    (UNLESS (ZEROP FIRST-COLUMN-MASK)
		      ,(setup-bars :backwards-load? :no-wrap :last-word 'LAST-WORD-OFFSET)
		      ,(do-masked-word `FIRST-COLUMN-MASK 'NEG-FIRST-MASK NIL T))
		     
		    ;;****************************************
		    ;; Setup for next row
		     
		    (UNLESS (= ROW HEIGHT)
		      ,@(when (and depends-on-source? (not constant-source))
			  `((SETQ S-ROW-ADDRESS (PTR+ S-ROW-ADDRESS S-ROW-SPAN))))
		      (SETQ D-ROW-ADDRESS (PTR+ D-ROW-ADDRESS D-ROW-SPAN)))))))))
	     (DO-IT)))
;;;*********************************************************************
;;;
;;;
       ,@(when (and depends-on-source? (member :BACKWARDS-WRAP generation-selection))
	   (when folded-photon
	     (error "backwards photon folded is not supported or necessary"))
	   (FLET ((DO-IT ()
	    `((DEFUN ,backwards-wrap-fun (ALU S-ROW-ADDRESS S-ROW-SPAN
					  D-ROW-ADDRESS D-ROW-SPAN
					  HEIGHT BIT-OFFSET WORD-WIDTH
					  FIRST-COLUMN-MASK LAST-COLUMN-MASK
					  SOURCE-OVERHANG?
					  S-COL-WORD S-WIDTH-WORDS
					  S-ROW S-HEIGHT)
		(DECLARE (FUNCTION-PARENT ,forwards-fun DEFUN))
		 
		(WITH-BITBLT-INNER-LOOP-ENVIRONMENT (ALU ,depends-on-source?
							 ,original-depends-on-destination?
							 t
							 ,folded-photon)

		  ;;************************************************************
		  ;; Initialize Shift and ALU operation register
		   
		  ,@(setup-registers 'ALU 'BIT-OFFSET)
		   
		  ;;************************************************************
		  ;; Process successive rows
		   
		  (SETQ S-ROW-ADDRESS (PTR+ S-ROW-ADDRESS (- S-COL-WORD)))

		  (LET* ((VERTICAL-REVERSE (MINUSP S-ROW-SPAN))
			 (MORE-SOURCE? NIL)
			 (VERTICAL-START (IF VERTICAL-REVERSE (1- S-HEIGHT) 0))
			 (S-VERTICAL-WRAP (* S-ROW-SPAN (- 1 S-HEIGHT)))
			 (DEST-LAST-COLUMN (+ WORD-WIDTH
					      (IF (ZEROP FIRST-COLUMN-MASK) 0 1)))
			 (LAST-COLUMN-POS (MOD (+ S-COL-WORD DEST-LAST-COLUMN)
					       S-WIDTH-WORDS))
			 (LAST-WORD-OFFSET (1- S-WIDTH-WORDS))
			 (DEST-OFFSET NIL))
2			  
0		    ;; Tricky placement - if original value is incremented above,
		    ;;    then last-column-pos is affected
		    (UNLESS (ZEROP LAST-COLUMN-MASK)
		      (INCF DEST-LAST-COLUMN))

		    (LOOP FOR ROW FROM 1 TO HEIGHT DO
		      (SETQ MORE-SOURCE? (IF VERTICAL-REVERSE
					     (>= (DECF S-ROW) 0)
					     (< (INCF S-ROW) S-HEIGHT)))
		      (SETQ DEST-OFFSET DEST-LAST-COLUMN)
		       
		      ;;****************************************
		      ;; Process last partial destination word
		      ;; We may or may not need to fetch one additional source word
		       
		      (UNLESS (ZEROP LAST-COLUMN-MASK)
			(DECF DEST-OFFSET)
			(let ((local-offset (if (and (zerop last-column-pos)
						     (plusp bit-offset))
						last-word-offset
						last-column-pos)))
			  ,(setup-bars :offset `local-offset
				       :dest-offset 'DEST-OFFSET
				       :backup-offset '(plusp last-column-pos)
				       :backwards-load? :wrap
				       :last-word 'LAST-WORD-OFFSET))
			,(do-masked-word `LAST-COLUMN-MASK 'NEG-LAST-MASK
					 `SOURCE-OVERHANG? T))
		       
		      ;;****************************************
		      ;; Do full words in unrollment groups and 
		      ;;   then in a loop of < unrollment words
		      ;;   resetting the BARs each time to the 
		      ;;   beginning of the group
		      (LOOP WITH WORD-COUNT = WORD-WIDTH
			    FOR BAR-OFFSET = LAST-COLUMN-POS
					   THEN (IF (ZEROP BAR-OFFSET)
						    S-WIDTH-WORDS BAR-OFFSET)
			    FOR COUNT = (MIN WORD-COUNT
					     (IF (AND (MINUSP BIT-OFFSET)
						      (= S-WIDTH-WORDS BAR-OFFSET))
						 1
						 BAR-OFFSET))
			    UNTIL (ZEROP WORD-COUNT) DO
			,(labels ((set-backward-wrap-bars (n body)
				    `(progn (decf word-count ,n)
					    (decf BAR-OFFSET ,n)
					    (DECF DEST-OFFSET ,n)
					    (let ((local-offset (if (and (zerop bar-offset)
									 (plusp bit-offset))
								    last-word-offset
								    bar-offset)))
					      ,(setup-bars :offset 'local-offset
							   :dest-offset 'DEST-OFFSET
							   :backwards-load? :WRAP
							   :backup-offset '(plusp bar-offset)
							   :last-word 'LAST-WORD-OFFSET)
					      )
					  ,body)))
			   (unroll-n-words 'count
					    :mask (when mask-destination 'write-protect-mask)
					    :backwards t
					    :folded-photon folded-photon
					    :setup-function #'set-backward-wrap-bars))
			)
		       
		      ;;****************************************
		      ;; Process first partial destination word	     
		      ;;   SETUP-BARS will prime rotate-latch as needed
		      ;; If shifting source right, fetch second source word.
		      ;; If shifting source left, or not at all, fetch the first word.
		       
		      (UNLESS (ZEROP FIRST-COLUMN-MASK)
			(DECF DEST-OFFSET)
			(let ((local-offset (if (and (zerop s-col-word)
						     (plusp bit-offset))
						last-word-offset
						s-col-word)))
			  ,(setup-bars :offset 'local-offset
				       :backup-offset '(plusp s-col-word)
				       :dest-offset 'DEST-OFFSET
				       :backwards-load? :WRAP :last-word 'LAST-WORD-OFFSET))
			,(do-masked-word `FIRST-COLUMN-MASK 'NEG-FIRST-MASK NIL T))
		       
		      ;;****************************************
		      ;; Setup for next row
		       
		      (UNLESS (= ROW HEIGHT)
			(IF MORE-SOURCE?
			    (SETQ S-ROW-ADDRESS (PTR+ S-ROW-ADDRESS S-ROW-SPAN))
			   
			    ;; Source wraparound in the Y direction
			    (SETQ S-ROW VERTICAL-START
				  S-ROW-ADDRESS (PTR+ S-ROW-ADDRESS
						      S-VERTICAL-WRAP)))
			(SETQ D-ROW-ADDRESS (PTR+ D-ROW-ADDRESS D-ROW-SPAN))))))))))
	     (DO-IT)))
;;;*********************************************************************
;;; This version is  for single row cases only and is (currently) used by 
;;;   TV:%draw-line-internal and TV:%draw-triangle-internal and the BIT-ops

       ,@(when (member :SIMPLE generation-selection)
	   (FLET ((DO-IT ()
   	    `((DEFUN ,simple-fun (ALU S-ROW-ADDRESS D-ROW-ADDRESS BIT-OFFSET
				  WORD-WIDTH FIRST-COLUMN-MASK
				  LAST-COLUMN-MASK SOURCE-OVERHANG?)
	 
		(WITH-BITBLT-INNER-LOOP-ENVIRONMENT (ALU ,depends-on-source?
							 ,original-depends-on-destination?
							 nil
							 ,folded-photon)
	   
		  ;;************************************************************
		  ;; Initialize Shift and ALU operation register

		  ,@(setup-registers 'ALU 'BIT-OFFSET)
	   
		  ,(setup-bars :load-rotate-latch '(MINUSP BIT-OFFSET))
	   
		  ;;****************************************
		  ;; Process first partial destination word	     
		  ;;   SETUP-BARS will prime rotate-latch as needed
		  ;; If shifting source right, fetch second source word.
		  ;; If shifting source left, or not at all, fetch the first word.
	   
		  (UNLESS (ZEROP FIRST-COLUMN-MASK)
		    ,(do-masked-word `FIRST-COLUMN-MASK 'NEG-FIRST-MASK))
	   
		  ;;****************************************
		  ;; Do full words in unrollment groups and 
		  ;;   then in a loop of < unrollment words
	   
		  ,(unroll-n-words 'WORD-WIDTH 
				   :folded-photon folded-photon
2				   0:mask (when mask-destination 'write-protect-mask)2)
0	   
		  ;;****************************************
		  ;; Process last partial destination word
		  ;; We may or may not need to fetch one additional source word
	   
		  (UNLESS (ZEROP LAST-COLUMN-MASK)
		    ,(do-masked-word `LAST-COLUMN-MASK 'NEG-LAST-MASK `SOURCE-OVERHANG? T))
		  )))))
	     (DO-IT)))
      )))



(defprop define-bitblt-inner-loop defun zwei:definition-function-spec-type)
;;;*********************************************************************
;;; Mapping bitfields and extraction operations
;;;    Source-dependent-alus - which alu ops do require the source as input
;;;    Bitblt-Alu-Map - correction mapping from raw alus to hardware implementation alus
;;;    Bitblt-Destination-Only-Alu - mapping of two-operand alus to single operand alus

;;; Boolean Bitfield indicating that the ALU operation does not require the source array

(defvar *bitblt-source-dependent-alus*
	(loop for non-source-alu in (list boole-clr boole-set boole-2 boole-c2)
	      with result = (lognot 0) do
	  (setq result (dpb 0 (byte 1 non-source-alu) result))
	      finally (return result)))

(defconstant %%extended-alu-opcode (byte 7. 24.))	;Borrowed From Color

(defmacro source-dependent-alu-p (alu &optional (color? t))
  (let ((AA (IF COLOR?
		`(IF (< ,ALU 0)
		     (select (ldb color:%%extended-alu-opcode ,alu)
		       (0 (if (ldb-test (byte 1 4) ,alu) boole-1 boole-set))
		       ((1 2)  boole-1)
		       (otherwise (error "Don't know about color alu space ~D."
					 (ldb color:%%extended-alu-opcode ,alu))))
		     ,ALU)
		ALU)))
    `( 0 (LOGAND (LSH 1 ,AA) *BITBLT-SOURCE-DEPENDENT-ALUS*))))

(defmacro bitblt-inner-loop-p (alu source-bits dest-bits write-mask)
  `(and ( 0 ,alu 15)
	(or (not (cli::source-dependent-alu-p ,alu nil))
	    (and (eql ,source-bits ,dest-bits)
		 (or (eql ,dest-bits 0)
		     (and (member ,alu '(#.tv:alu-ior #.tv:alu-xor #.tv:alu-andca))
			  (eql ,write-mask -1)
			  ))))))

;;; Mapping is required because the hardware implementation views some operations 
;;; differently than the software does. In particular for
;;;   Boole-C2, Dest is the only input so it is seen as the "source" operand
;;;   and similarly source and dest in ANDC1/C2 and ORC1/ORC2 are reversed
;;; This works because the particular pairs of values (boole-c2 being a one-way pair)
;;; are different by 2 or -2 depending on the direction

(defconstant *bitblt-alu-map*
	     '#.(make-array 16 :element-type '(unsigned-byte 4) :initial-contents
			    (loop for alu from 0 below 16 collect 
			      (select alu
				(boole-c2 boole-c1)
				(boole-andc1 boole-andc2)
				(boole-andc2 boole-andc1)
				(boole-orc1 boole-orc2)
				(boole-orc2 boole-orc1)
				(otherwise alu)))))

(defmacro bitblt-alu-map (alu)
  `(aref *bitblt-alu-map* ,alu))

;;;*********************************************************************
;;; Bitblt Inner Loop function accessing through an array of function symbols
;;;

;;; Symbol array for BITBLT inner loop functions in 16-element segments for each variant

(defvar *bitblt-inner-loops* (make-array (* 5 16)))	;5 variants on 16 operations
(defvar *bitblt-inner-loops-location* (locf (aref *bitblt-inner-loops* 0)))

;;; Symbolic mapping of variant name to segment id within *BITBLT-INNER-LOOPS* array

1;allow for runtime expansion
0(defmacro bitblt-inner-loop-variant (variant)
  (if (keywordp variant)
      (ecase variant
	(:forwards 0)
	(:forwards-wrap 1)
	(:backwards 2)
	(:backwards-wrap 3)
	(:single 4)
	)
      `(ecase ,variant
	 (:forwards 0)
	 (:forwards-wrap 1)
	 (:backwards 2)
	 (:backwards-wrap 3)
	 (:single 4)
	 )))

;;;**********************************************************************
;;; Temporary debugging code to identify bitblt usage distribution

(defvar *bitblt-inner-loops-usage*
	(make-array (* 5 16) :element-type 'fixnum :initial-element 0))
(defvar *bitblt-inner-loops-usage-enable* nil)

(defun bitblt-inner-loop-usage (ptr)
  (setf (aref *bitblt-inner-loops-usage* ptr)
	(si:%32-bit-plus (aref *bitblt-inner-loops-usage* ptr) 1)))

(defun clear-bitblt-usage ()
  (fill *bitblt-inner-loops-usage* 0))

(defun report-bitblt-usage ()
  (format t "~%ALU   Function        Forwards  Forwards-Wrap   Backwards Backwards-Wrap  ~
                    Single~%")
  (loop for i from 0 below 16 do
    (format t "~%~{~5A  ~11A~}  ~10D  ~10D  ~10D  ~10D  ~10D"
	      (selector i =
		(boole-clr   '("CLR" "CONSTANT"))
		(boole-and   '("AND" "BOTH"))
		(boole-andc1 '("ANDC1" "BOTH"))
		(boole-2     '("2" "DESTINATION"))
		(boole-andc2 '("ANDC2" "BOTH"))
		(boole-1     '("1" "SOURCE"))
		(boole-xor   '("XOR" "BOTH"))
		(boole-ior   '("IOR" "BOTH"))
		(boole-nor   '("NOR" "BOTH"))
		(boole-eqv   '("EQV" "BOTH"))
		(boole-c1    '("C1" "SOURCE"))
		(boole-orc1  '("ORC1" "BOTH"))
		(boole-c2    '("C2" "DESTINATION"))
		(boole-orc2  '("ORC2" "BOTH"))
		(boole-nand  '("NAND" "BOTH"))
		(boole-set   '("SET" "CONSTANT")))
	    (aref *bitblt-inner-loops-usage* (dpb 0 (byte 3 4) i))
	    (aref *bitblt-inner-loops-usage* (dpb 1 (byte 3 4) i))
	    (aref *bitblt-inner-loops-usage* (dpb 2 (byte 3 4) i))
	    (aref *bitblt-inner-loops-usage* (dpb 3 (byte 3 4) i))
	    (aref *bitblt-inner-loops-usage* (dpb 4 (byte 3 4) i)))))
;;;**********************************************************************

(defmacro bitblt-inner-loop-fun (variant alu
				 &optional (mask-p '( tv:bitblt-unpacking-mask -1)))
  `(if (minusp ,alu)
       (color:color-bitblt-inner-loop-fun ,variant ,alu ,mask-p)
       (if *bitblt-inner-loops-usage-enable*
	   (bitblt-inner-loop-usage
	     (%LOGDPB (BITBLT-INNER-LOOP-VARIANT ,variant) (BYTE 28 4) ,alu))
	   (aref  *bitblt-inner-loops*
		  (%LOGDPB (BITBLT-INNER-LOOP-VARIANT ,variant) (BYTE 28 4) ,alu)))
       ))


;;; NOTE: ArrayFNS BITBLT-SINGLE-ROW has hardcoded in :SINGLE case and BITBLT-INNER-LOOP-FUN
;;;   and I-Wired-Console XOR-MOUSE-CURSOR is hardcoded call to BB-BOTH-FORWARDS function
;;;   so watch out for naming changes.

;;;*********************************************************************
;;; These calls will cause the definition of all required functions
;;; If an additional argument is called, you can control which functions 
;;; are actually generated; for example
;;;
;;; (define-bitblt-inner-loop bb-source t nil 8 '(boole-1 boole-c1) (:forwards))
;;; 
;;; will generate the forwards case only, i.e. BB-SOURCE-FORWARDS.
;;; Using C-SHIFT-M (macroexpand) you can use a similar call to produce the actual 
;;; function code for a specific function or functions in a seperate file and then 
;;; modify it in isolation for debugging. Note that M-SHIFT-M will more fully expand the 
;;; the definition and produce machine-dependent code, whereas C-SHIFT-M will produce
;;; the same code whether it is performed on an I-Machine or an L-Machine. 

(define-bitblt-inner-loop bb-constant     nil nil 8 (boole-clr boole-set))
(define-bitblt-inner-loop bb-source       t   nil 8 (boole-1   boole-c1))
(define-bitblt-inner-loop bb-destination  nil t   8 (boole-2   boole-c2))
(define-bitblt-inner-loop bb-both         t   t   8
			  (boole-and  boole-ior   boole-xor   boole-eqv  boole-nand
	                    boole-nor  boole-andc1 boole-andc2 boole-orc1 boole-orc2))

;;; This function needs to be run before IBITBLT is able to access the functions
;;; which performs its inner loops. It will allocate the arrays and fill them with the 
;;; inner loop function symbols for each different purpose - forwards, wrap, etc.

(defun setup-bitblt-cases (&optional (force-it? nil))
  force-it?
  ;; This macro builds a list of (row column symbol) triplets where the row is the
  ;; type of inner-loop-function desired, the column is the boole-op alu and the symbol
  ;; is the interned name of the function that performs the given variant of the alu op.
  (macrolet ((inner-loop-funs ()
	       (loop for suffix in `("-FORWARDS" "-FORWARDS-WRAP" "-BACKWARDS"
				     "-BACKWARDS-WRAP" "-SIMPLE")
		     for row from 0 below 5
		     with result = nil do
		 (setq result
		       (append result
			       (loop for (alu base) in '((boole-clr   "CONSTANT")
							 (boole-and   "BOTH")
							 (boole-andc1 "BOTH")
							 (boole-2     "DESTINATION")
							 (boole-andc2 "BOTH")
							 (boole-1     "SOURCE")
							 (boole-xor   "BOTH")
							 (boole-ior   "BOTH")
							 (boole-nor   "BOTH")
							 (boole-eqv   "BOTH")
							 (boole-c1    "SOURCE")
							 (boole-orc1  "BOTH")
							 (boole-c2    "DESTINATION")
							 (boole-orc2  "BOTH")
							 (boole-nand  "BOTH")
							 (boole-set   "CONSTANT"))
				     for column from 0 below 16 
				     collect (list row column
						   (intern (string-append "BB-" base suffix))
						   alu))))
		     finally (return `',result))))

    (loop for (variant alu-fun symbol alu) in (inner-loop-funs) do
      (setf (aref *bitblt-inner-loops* (dpb variant (byte 3 4) alu-fun))
						;Forwards used everytime
	    (if (or (= variant (bitblt-inner-loop-variant :forwards)) 
		    (= variant (bitblt-inner-loop-variant :single))
		    (source-dependent-alu-p (eval alu)))
		2(symbol-function 0symbol)))2)0	2;Store function not function symbol 
0						2;to avoid lookup at run-time
0    ))

(setup-bitblt-cases t)
