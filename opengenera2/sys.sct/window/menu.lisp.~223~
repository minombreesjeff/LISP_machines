;;; -*- Mode:Lisp; Package:TV; Base:8 -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; New menu system

;Documentation on menu item-lists:
;
;Each item in the item-list may be one of the following:
; 1. A string (or a symbol).  
; 2. Cons of a string (or a symbol) and an atom.
; 3. List of a string (or a symbol) and any object.  The list may
;    not be more than 2 long.
; 4. List of a string (or a symbol), a flavor keyword, and an argument.
;    After the first 3 elements of the list, the rest of the list is
;    a property list of modifier keywords and values.
;The string (or symbol) is displayed in the menu to represent this item.
;The value returned by the :CHOOSE method is the item in case 1, the cdr
;in case 2, the cadr in case 3, and varies in case 4 depending on the flavor.
;Case 4 menu items can also have side-effects.
;The following are the permissible flavor keywords:
;		:VALUE - argument is returned by the :CHOOSE method
;		:EVAL - argument is evaluated then returned
;		:FUNCALL - argument is a function of no args to be called
;		:FUNCALL-WITH-SELF - argument is a function which is called with the
;			   menu as the argument
;		:NO-SELECT - this item cannot be selected
;		:WINDOW-OP - argument is a function of one argument.  This
;			argument is a list of window, mouse-x, mouse-y as they
;			were before the menu popped up.
;		:KBD - argument is forced into keyboard input of appropriate process.
;		:MENU - argument is a new menu to choose from.
;		:BUTTONS - argument is 3 items, which one is used depends on
;			which mouse button was clicked
;The following are the known modifier keywords:
;		:FONT - the font in which to display the item  (-- Compatibility only)
;		:STYLE - the style in which to display the item
;		:DOCUMENTATION - a string documenting this item
;This stuff is largely although not entirely controlled by the :EXECUTE method,
;which you may redefine.
;
; The string slot can be filled by an instance with the following methods:
;
;		:MENU-BOUNDING-BOX-SIZE window stop-x-> xsize,ysize
;		:MENU-PRINT window x y
;    and optionally
;		:MENU-BLINKER-EDGES window -> left,top,right,bottom for
;		blinker relative to the bounding box.
;

;;; These special variables exist so that there are less random numbers
;;; in the code, giving somewhat more chance of understanding it.
;;; You might even want to change them.
(DEFVAR MENU-INTERWORD-SPACING 27.)	;For fill mode.  3 characters in MEDFNT, which was
					; once the default menu font...
(DEFVAR MENU-INTERCOLUMN-SPACING 10.)	;For column mode.
(DEFVAR MENU-INTERROW-SPACING 2)
(DEFVAR MENU-FILL-BREAKAGE 60.)
(DEFVAR MENU-GOLDEN-RATIO 1.6s0)
(DEFVAR MENU-MINIMUM-WIDTH 16.)		;Avoid invisibly narrow menus in pathological cases

;;; MENU-EXECUTE-MIXIN flavor processes a menu-like item

(DEFFLAVOR MENU-EXECUTE-MIXIN () ()
  (:DOCUMENTATION :MIXIN "Processes a menu-like item
This is a part of every menu, it is a separate flavor so that it can be included in other
things which want to act like menus with regard to the format of an item passed to a
:execute message.  This message is what handles most of the interpretation of the
item-list instance variable."))

;;; Decide what to return based on the item selected.  Also have side-effects
;;; such as calling a function if the item says to.
(DEFMETHOD (:EXECUTE MENU-EXECUTE-MIXIN) (ITEM)
  (MENU-EXECUTE ITEM SELF))

(DEFUN MENU-EXECUTE (ITEM &OPTIONAL WINDOW &AUX OP ARG)
  (COND ((ATOM ITEM) ITEM)
	((ATOM (CDR ITEM)) (CDR ITEM))
	((ATOM (CDDR ITEM)) (CADR ITEM))
	((EQ (SETQ ARG (CADDR ITEM)
		   OP (CADR ITEM))
	     ':VALUE)
	 ARG)
	((EQ OP ':EVAL) (EVAL ARG))
	((EQ OP ':FUNCALL) (FUNCALL ARG))
	((EQ OP ':MENU) (SEND (IF (OR (SYMBOLP ARG) (LISTP ARG)) (EVAL ARG) ARG)
			      ':CHOOSE))
 	((NULL WINDOW) (FERROR "~S cannot be executed without a window" ITEM))
	((EQ OP ':FUNCALL-WITH-SELF) (FUNCALL ARG WINDOW))
	((EQ OP ':WINDOW-OP) (SEND WINDOW ':EXECUTE-WINDOW-OP ARG))
								 
	((EQ OP ':KBD) (LET ((SWIN (SHEET-SELECTED-WINDOW WINDOW)))
			 (AND SWIN (SEND SWIN ':FORCE-KBD-INPUT ARG))))
	(T (FERROR "~S is unknown operation for :EXECUTE" OP))))

;Same as above but returns NIL if getting the value would require side-effects.
;This is used by MENU-HIGHLIGHTING-MIXIN
(DEFMETHOD (:EXECUTE-NO-SIDE-EFFECTS MENU-EXECUTE-MIXIN) (ITEM &OPTIONAL ERROR-P)
  (MENU-EXECUTE-NO-SIDE-EFFECTS ITEM ERROR-P))

(DEFUN MENU-EXECUTE-NO-SIDE-EFFECTS (ITEM &OPTIONAL ERROR-P)
  (COND ((ATOM ITEM) ITEM)
	((ATOM (CDR ITEM)) (CDR ITEM))
	((ATOM (CDDR ITEM)) (CADR ITEM))
	((EQ (SECOND ITEM) ':VALUE)		;OP
	 (THIRD ITEM))				;ARG
	((AND (EQ (SECOND ITEM) ':EVAL)
	      (OR (ATOM (THIRD ITEM))		;Evaluable with no side effects
		  (EQ (CAR (THIRD ITEM)) 'QUOTE)))
	 (EVAL (THIRD ITEM)))
	((EQ (SECOND ITEM) ':BUTTONS)
	 (TV:MENU-EXECUTE-NO-SIDE-EFFECTS (CAADDR ITEM)))
	(ERROR-P
	 (FERROR "The menu item ~S cannot be evaluated without side-effects" ITEM))
	(T NIL)))

(DEFMETHOD (:EXECUTE-WINDOW-OP MENU-EXECUTE-MIXIN) (FUNCTION) (FUNCALL FUNCTION))

;; GEOMETRY is the user specified geometry.  It is a list of:
;; Number of columns or 0 if FILL-P, number of rows, inside width, inside height,
;; maximum width, maximum height.  NIL means it's free to change, as was not
;; explicitly specified by the user.  Default is to leave everything free.
(DEFSTRUCT (GEOMETRY :LIST (:CONSTRUCTOR NIL) (:SIZE-SYMBOL GEOMETRY-LIST-SIZE))
  GEOMETRY-N-COLUMNS
  GEOMETRY-N-ROWS
  GEOMETRY-INSIDE-WIDTH
  GEOMETRY-INSIDE-HEIGHT
  GEOMETRY-MAX-WIDTH
  GEOMETRY-MAX-HEIGHT
  GEOMETRY-FLAGS)

(DEFMACRO GEOMETRY-FILL-P (GEO) `(AND (GEOMETRY-N-COLUMNS ,GEO)
				      (ZEROP (GEOMETRY-N-COLUMNS ,GEO))))

(DEFMACRO GEOMETRY-CENTERED-COLUMNS (GEO)
  `(AND (GEOMETRY-FLAGS ,GEO)
	(NOT (BIT-TEST 1 (GEOMETRY-FLAGS ,GEO)))))

(DEFUN SET-GEOMETRY-CENTERED-COLUMNS (GEO VAL)
  (LET ((LEN (LENGTH GEO)))
    (WHEN (< LEN GEOMETRY-LIST-SIZE)
      (SETQ GEO (NCONC GEO (MAKE-LIST (- GEOMETRY-LIST-SIZE LEN))))))
  (SETF (GEOMETRY-FLAGS GEO)
	(DPB (IF VAL 0 1) (BYTE 1 0) (OR (GEOMETRY-FLAGS GEO) 0))))

(EVAL-WHEN (COMPILE LOAD EVAL)
(DEFPROP GEOMETRY-FILL-P
	 ((GEOMETRY-FILL-P GEO) . (SETF (GEOMETRY-N-COLUMNS GEO) (IF SI:VAL 0 NIL)))
	 SETF)

(DEFPROP GEOMETRY-CENTERED-COLUMNS
	 ((GEOMETRY-CENTERED-COLUMNS GEO) . (SET-GEOMETRY-CENTERED-COLUMNS GEO SI:VAL))
	 SETF)
)


(DEFFLAVOR BASIC-MENU
	   (ITEM-LIST			;List of items being displayed.
	    CURRENT-ITEM		;Item being pointed at now.
	    LAST-ITEM			;The last item to have been selected.
	    (CHOSEN-ITEM NIL)		;The same, but it's ok to set this to NIL
					;and wait for it to become non-NIL.
	    SCREEN-ROWS			;Number of rows in menu on screen
	    TOTAL-ROWS			;Total number of rows in menu.
					;If this is greater than SCREEN-ROWS, then the latter
					;represent a window on all the rows.
	    TOP-ROW			;This is first row visible now.
	    ROW-HEIGHT			;Height in dots of a row (including vsp).
	    ROW-MAP			;Array of tails of ITEM-LIST.  For each row
					;in the menu, points to first item on that row.
					;An extra element at the end is NIL.
					;The length is thus (1+ TOTAL-ROWS).
	    (COLUMNS NIL)		;Number of columns (NIL in fill mode).
	    COLUMN-WIDTH		;Width in dots of a column (NIL in fill mode).
	    (GEOMETRY (MAKE-LIST GEOMETRY-LIST-SIZE))
	    (SET-EDGES-MODE NIL)	;Looked at by :CHANGE-OF-SIZE-OR-MARGINS method
					;NIL means not via SET-EDGES (margin changing, for
					; example)
					;T means via an internal call from the menu system
					;USER means from a user's :SET-EDGES
					;Any other means to recompute parameters, but don't
					; be sticky with respect to new sizes
	   (INTERWORD-SPACING MENU-INTERWORD-SPACING)
	   (INTERCOLUMN-SPACING MENU-INTERCOLUMN-SPACING)
	   (INTERROW-SPACING MENU-INTERROW-SPACING)
	   )
	   (MENU-EXECUTE-MIXIN)
  (:REQUIRED-FLAVORS BASIC-SCROLL-BAR)	;Position in component list decided at higher level
  (:GETTABLE-INSTANCE-VARIABLES ITEM-LIST CURRENT-ITEM LAST-ITEM CHOSEN-ITEM GEOMETRY)
  (:SETTABLE-INSTANCE-VARIABLES LAST-ITEM CHOSEN-ITEM
				INTERWORD-SPACING INTERCOLUMN-SPACING INTERROW-SPACING)
  (:INITABLE-INSTANCE-VARIABLES ITEM-LIST)
  (:INIT-KEYWORDS :ROWS :COLUMNS :FILL-P :CENTERED-COLUMNS :GEOMETRY	;Set parts of geometry
   :DEFAULT-FONT :JAPANESE-FONT-SIZE)
  (:DEFAULT-INIT-PLIST :BLINKER-FLAVOR 'HOLLOW-RECTANGULAR-BLINKER)
  (:DOCUMENTATION :MIXIN "Regular menu messages
Provides methods and instance variables common to all menus, such as the item-list,
the geometry hacking, a default :choose message, and a scroll bar if necessary."))

(DEFFLAVOR MENU ((LABEL NIL))
		;; Mixins go before basic flavors
		;; BASIC-MENU shadows a method of BASIC-SCROLL-BAR
		(BORDERS-MIXIN TOP-BOX-LABEL-MIXIN BASIC-MENU BASIC-SCROLL-BAR MINIMUM-WINDOW)
  ;; relax the constraints on ordering a bit so that we can
  ;; hack the margins of menus, just like other windows.
  ;; see the similar thing done to tv:window
  (:COMPONENT-ORDER (BORDERS-MIXIN TOP-BOX-LABEL-MIXIN) ;label inside borders
		    (BASIC-MENU BASIC-SCROLL-BAR)       ;basic-menu shadows a scroll method
		    ;; "Aesthetics" dictates that menu precede
		    ;; basic-menu and minimum-window.  Seet similar
		    ;; comment in tv:window.
		    (MENU BASIC-MENU)       
		    (MENU MINIMUM-WINDOW))	
  (:DOCUMENTATION :COMBINATION "The simplest instantiatable menu.
Defaults to not having a label, a label whose position is not initially specified will
be at the top, in a small auxiliary box, unlike most windows."))

(DEFFLAVOR POP-UP-MENU () (TEMPORARY-WINDOW-MIXIN MENU)
  (:DEFAULT-INIT-PLIST :BORDERS *DROP-SHADOW-BORDERS-SPEC*)
  (:DOCUMENTATION :COMBINATION "A menu that is temporary
This is not a momentary menu, it must be exposed and deexposed normally, it does save
the state beneath itself when exposed."))



;separate this function from the MENU-ITEM-STRING method, which really had no
;reason to be a method in the first place
(DEFUN GET-STRING-FROM-MENU-ITEM (ITEM &optional DISPLAY-DEVICE-TYPE &AUX STRING FONT STYLE UNDERSCORE)
  (DECLARE (VALUES STRING STYLE UNDERSCORE))

  (COND ((AND (INSTANCEP ITEM)
	      (OPERATION-HANDLED-P ITEM :MENU-BOUNDING-BOX-SIZE))
	 (RETURN-FROM GET-STRING-FROM-MENU-ITEM		;All together in one
	   (VALUES ITEM SI:*NULL-STYLE* NIL)))
	((ATOM ITEM) (SETQ STRING ITEM))
	(T (SETQ STRING (CAR ITEM))
	   (WHEN (LISTP (CDR ITEM))
	     (SETQ FONT (GET (CDDR ITEM) :FONT))  ;; Support :FONT for compatibility.
	     (SETQ STYLE (GET (CDDR ITEM) :STYLE))
	     (SETQ UNDERSCORE (GET (CDDR ITEM) :UNDERSCORE)))))
  (UNLESS (AND (INSTANCEP STRING)
	       (OPERATION-HANDLED-P STRING :MENU-BOUNDING-BOX-SIZE))
    (SETQ STRING (STRING STRING)))
  (COND ((AND FONT STYLE)
	 (FERROR "Illegal to specify both :FONT and :STYLE (in ~S)" ITEM))
	((AND (NULL STYLE) (NULL FONT))
	 (SETQ STYLE SI:*NULL-STYLE*))
	((NUMBERP FONT)
	 (FERROR "In item ~S: it is no longer supported for :FONT to be a number.  Specify ~
		  a style instead."))
	((NULL STYLE)
	 (SETQ STYLE (SI:BACKTRANSLATE-FONT FONT DISPLAY-DEVICE-TYPE))))
  (VALUES STRING STYLE UNDERSCORE))

;;; These understand the mapping between an item and its printed representation
;;; This attempts to win with fat strings by looking at the first character of the string.
;;; It should really return the largest font of the string.
(DEFMETHOD (MENU-ITEM-STRING BASIC-MENU) (ITEM &optional ignore)
  (DECLARE (VALUES STRING STYLE UNDERSCORE))
  (GET-STRING-FROM-MENU-ITEM ITEM DISPLAY-DEVICE-TYPE))


(DEFUN-IN-FLAVOR (MENU-ITEM-STRING-SIZE-INTERNAL BASIC-MENU) (STRING STYLE STOP-X)
  (DECLARE (VALUES WIDTH HEIGHT BASELINE))
  (IF (INSTANCEP STRING)
      (MULTIPLE-VALUE-BIND (WIDTH HEIGHT)
	  (SEND STRING :MENU-BOUNDING-BOX-SIZE SELF STOP-X)
	(VALUES WIDTH HEIGHT BASELINE))
      (WITH-CHARACTER-STYLE (STYLE SELF :BIND-LINE-HEIGHT T)
	(MULTIPLE-VALUE-BIND (NIL NIL WIDTH NIL TOTAL-HEIGHT MAX-BASELINE)
	    (SEND SELF :STRING-LENGTH STRING 0 NIL STOP-X)
	  (VALUES WIDTH (- TOTAL-HEIGHT VSP) MAX-BASELINE)))))

(DEFMETHOD (MENU-ITEM-STRING-SIZE BASIC-MENU) (ITEM &OPTIONAL STOP-X IGNORE)
  (MULTIPLE-VALUE-BIND (STRING STYLE IGNORE)
      (MENU-ITEM-STRING SELF ITEM)
    (MENU-ITEM-STRING-SIZE-INTERNAL STRING STYLE STOP-X)))

;; FONT-MAP-FILTER is used by Japanese.
;;; *** Figure out what this did someday
#+IGNORE
(DEFUN-IN-FLAVOR (MENU-COMPUTE-FONT-MAP BASIC-MENU) (ITEMS &OPTIONAL DEFAULT FONT-MAP-FILTER)
  (DECLARE (SYS:DOWNWARD-FUNARG FONT-MAP-FILTER))
  (OR DEFAULT (SETQ DEFAULT CURRENT-FONT))
  (SEND SELF :SET-DEFAULT-STYLE (SI:BACKTRANSLATE-FONT DEFAULT DEVICE-TYPE))
  (LET ((MAP (NCONS DEFAULT))
	FONT)
    (DOLIST (ITEM ITEMS)
      (SETQ FONT (AND (LISTP ITEM)
		      (LISTP (CDR ITEM))
		      (GET (CDDR ITEM) ':FONT)))
      (AND FONT (NOT (MEMQ FONT MAP))
	   (PUSH FONT MAP)))
    (SETQ MAP (NREVERSE MAP))
    (IF FONT-MAP-FILTER
	(FUNCALL FONT-MAP-FILTER MAP)
	MAP)))

;;; This function, given a menu item-list, returns the maximum size
;;; of any string in it.  Normally you want to add an allowance for interword spacing.
(DEFUN-IN-FLAVOR (MENU-MAX-SIZE BASIC-MENU) (IL)
  (LET ((MAX-WIDTH 0)
	(MAX-HEIGHT 0))
    (DOLIST (ITEM IL)
      (MULTIPLE-VALUE-BIND (ITEM-WIDTH ITEM-HEIGHT)
	  (MENU-ITEM-STRING-SIZE SELF ITEM NIL T)
	(SETQ MAX-WIDTH (MAX MAX-WIDTH ITEM-WIDTH)
	      MAX-HEIGHT (MAX MAX-HEIGHT ITEM-HEIGHT))))
    (VALUES MAX-WIDTH (+ MAX-HEIGHT VSP))))

;;; This function, given a menu item-list, returns the estimated total width
;;; (product of WIDTH and N-ROWS, not counting borders) when the menu items
;;; are put in "fill mode" rather than in columns.  It is only an estimate
;;; because at this point we can't be sure about word breakage.
(DEFUN-IN-FLAVOR (MENU-FILL-WIDTH BASIC-MENU) (IL)
  (DO ((L IL (CDR L))
       (WID 0))
      ((NULL L) WID)
    (SETQ WID (+ WID (MENU-ITEM-STRING-SIZE SELF (CAR L) NIL T) MENU-FILL-BREAKAGE))))

;;; This function, given a bunch of parameters some of which are NIL meaning
;;; unspecified, deduces the rest of the parameters from constraints.
;;; For parameters passed in as NIL, the corresponding element of GEOMETRY
;;; is used.

;;; First, compute the geometry
;;;  (1) The user has supplied the width and the number of columns or fill-p, nothing special.
;;;  (2) The user has supplied the width, we compute the number of columns
;;;             by finding the widest string in the item-list.
;;;  (3) The user has not supplied the width, but has supplied n-columns, we compute width
;;;             again by finding the widest string in the item-list.
;;;  (4) The user has supplied neither width nor n-columns.
;;;    (4a) The user has, however, supplied height or n-rows, so we pick a suitable width
;;;         to make the entire menu come out to n-rows, depending on fill mode.  Then if
;;;         it doesn't fit, this width will be wider than the screen, and will be limited.
;;;    (4b) The user has supplied no geometry, it's up to us.
;;;         Compute the total width depending on fill-mode, then pick n-rows and
;;;         n-columns to make this a square array.  Then limit each to the available
;;;         area of the screen, in case the menu is too big to fit.
;;;	    Not actually square but the prettiest looking shape.

;;; Once the horizontal business has been straightened out, if we don't have the
;;; height already, we pick a height to make it all fit on the screen, and limit that
;;; if it is too big.  Note that fill-mode has a line-breakage problem, which will
;;; need to be solved here (may change shape "slightly" from square.)

;;; Arguments:
;;; SELF, ITEM-LIST and GEOMETRY are used freely.
;;; SELF should have the right font, screen, vsp but not
;;;	  yet the right dimensions and location.
;;; NEW-LEFT, etc. are the boundaries of the area actually available for use.
;;;  Any margins have already been excluded.

(DEFUN-IN-FLAVOR (MENU-DEDUCE-PARAMETERS BASIC-MENU) (N-COLUMNS N-ROWS INSIDE-WIDTH INSIDE-HEIGHT
							   MAX-WIDTH MAX-HEIGHT
							   &AUX TEM COL-WIDTH
							   (N-ITEMS (LENGTH ITEM-LIST))
							   FILL-P MAX-ITEM-WIDTH MAX-ITEM-HEIGHT)
  ;; Pick up default constraints from GEOMETRY
  (SETQ N-COLUMNS (OR N-COLUMNS (GEOMETRY-N-COLUMNS GEOMETRY))
	N-ROWS (OR N-ROWS (GEOMETRY-N-ROWS GEOMETRY))
	INSIDE-WIDTH (OR INSIDE-WIDTH (GEOMETRY-INSIDE-WIDTH GEOMETRY))
	INSIDE-HEIGHT (OR INSIDE-HEIGHT (GEOMETRY-INSIDE-HEIGHT GEOMETRY))
	MAX-WIDTH (OR MAX-WIDTH (GEOMETRY-MAX-WIDTH GEOMETRY))
	MAX-HEIGHT (OR MAX-HEIGHT (GEOMETRY-MAX-HEIGHT GEOMETRY)))
  ;; If any of the arguments was :UNCONSTRAINED, that means use NIL
  ;; even if the geometry is non-NIL, whereas if an argument was NIL
  ;; that means use any constraint that is in the geometry.
  (AND (EQ N-COLUMNS ':UNCONSTRAINED) (SETQ N-COLUMNS NIL))
  (AND (EQ N-ROWS ':UNCONSTRAINED) (SETQ N-ROWS NIL))
  (AND (EQ INSIDE-WIDTH ':UNCONSTRAINED) (SETQ INSIDE-WIDTH NIL))
  (AND (EQ INSIDE-HEIGHT ':UNCONSTRAINED) (SETQ INSIDE-HEIGHT NIL))
  (AND (EQ MAX-WIDTH ':UNCONSTRAINED) (SETQ MAX-WIDTH NIL))
  (AND (EQ MAX-HEIGHT ':UNCONSTRAINED) (SETQ MAX-HEIGHT NIL))
  ;; Decide whether it is fill mode or array mode
  (AND (SETQ FILL-P (AND N-COLUMNS (ZEROP N-COLUMNS)))
       (SETQ N-COLUMNS NIL))
  (MULTIPLE-VALUE (MAX-ITEM-WIDTH MAX-ITEM-HEIGHT) (MENU-MAX-SIZE ITEM-LIST))
  (INCF MAX-ITEM-WIDTH INTERCOLUMN-SPACING)

  ;; Realize any immediately clear implications
  (AND N-ROWS (NULL INSIDE-HEIGHT) (SETQ INSIDE-HEIGHT (* N-ROWS MAX-ITEM-HEIGHT)))
  (AND INSIDE-HEIGHT (NULL N-ROWS) (SETQ N-ROWS (MAX 1 (// INSIDE-HEIGHT MAX-ITEM-HEIGHT))))
  (MULTIPLE-VALUE-BIND (WINDOW-MAX-WIDTH WINDOW-MAX-HEIGHT)
      (SEND SELF :MAXIMUM-SIZE)
    (SETQ MAX-HEIGHT (MIN (OR INSIDE-HEIGHT MAX-HEIGHT 10000)
			  WINDOW-MAX-HEIGHT)
	  MAX-WIDTH (MIN (OR INSIDE-WIDTH MAX-WIDTH 10000)
			 WINDOW-MAX-WIDTH)))

  ;; Compute the horizontal parameters.
  (COND ((AND INSIDE-WIDTH (OR N-COLUMNS FILL-P)) )		;It's fully-determined
	(INSIDE-WIDTH		;We have the width, and it's not in fill mode, compute
	 (SETQ N-COLUMNS	; N-COLUMNS based on widest item, but always fill the space
	       (MAX (MIN (// (+ INSIDE-WIDTH INTERCOLUMN-SPACING) MAX-ITEM-WIDTH)
			 (IF N-ROWS (// (+ N-ITEMS (1- N-ROWS)) N-ROWS) N-ITEMS))
		    1)))
	(N-COLUMNS  ;We don't have the width, but do know how many columns, compute width
	 (SETQ INSIDE-WIDTH (MIN (- (* MAX-ITEM-WIDTH N-COLUMNS)
				    INTERCOLUMN-SPACING)
				 MAX-WIDTH)))
	(N-ROWS  ;We know how high, make it wide enough to come out this high
	 (IF FILL-P
	     (SETQ INSIDE-WIDTH (MIN (// (+ (MENU-FILL-WIDTH ITEM-LIST)
					    (1- N-ROWS))
					 N-ROWS)
				     MAX-WIDTH))
	     (SETQ N-COLUMNS (MAX (// (+ N-ITEMS (1- N-ROWS)) N-ROWS) 1)
		   INSIDE-WIDTH (- (* (SETQ COL-WIDTH MAX-ITEM-WIDTH)
				      N-COLUMNS)
				   INTERCOLUMN-SPACING))))
	((NOT FILL-P) ;No geometry supplied, pick N-ROWS and N-COLUMNS to make it look nice
		      ;Use the largest number of columns which does not make the ratio
		      ;of height to width less than the Golden ratio
	 (SETQ TEM (* (SETQ COL-WIDTH MAX-ITEM-WIDTH)
                      N-ITEMS
                      MAX-ITEM-HEIGHT)
	       COL-WIDTH (+ COL-WIDTH INTERCOLUMN-SPACING)
	       N-COLUMNS (MAX (// (ISQRT (FIX (// TEM MENU-GOLDEN-RATIO))) COL-WIDTH) 1)
	       INSIDE-WIDTH (MAX (- (* COL-WIDTH N-COLUMNS) INTERCOLUMN-SPACING)
				 MENU-MINIMUM-WIDTH)))
	(T	;No geometry supplied, and in fill mode, make it like above
	 (SETQ INSIDE-WIDTH (MAX (ISQRT (FIX (// (* (MENU-FILL-WIDTH ITEM-LIST)
						    MAX-ITEM-HEIGHT)
						 MENU-GOLDEN-RATIO)))
				 MAX-ITEM-WIDTH
				 MENU-MINIMUM-WIDTH))))  ;Avoid zero, absurdly small

  ;; Now figure out the vertical characteristics
  (COND (FILL-P
	 (MULTIPLE-VALUE (ROW-MAP N-ROWS INSIDE-HEIGHT)
	   (MENU-COMPUTE-ROW-MAP INSIDE-WIDTH))
	 (SETQ INSIDE-HEIGHT (+ INSIDE-HEIGHT (* 2 N-ROWS))))
	(T
	 (OR N-ROWS
	     (SETQ N-ROWS (MAX (IF FILL-P 
				   (// (+ (MENU-FILL-WIDTH ITEM-LIST) INSIDE-WIDTH -1)
				       INSIDE-WIDTH)
				   (// (+ N-ITEMS N-COLUMNS -1) N-COLUMNS))
			       1)))
	 (OR INSIDE-HEIGHT (SETQ INSIDE-HEIGHT (* N-ROWS MAX-ITEM-HEIGHT)))))

  ;; If there is a label, the menu must be at least wide enough to accomodate it
  (LET ((L (SEND SELF ':SEND-IF-HANDLES ':LABEL-SIZE)))
    (AND L (SETQ INSIDE-WIDTH (MAX INSIDE-WIDTH L)))
    )

  ;; If this came out too high or too wide, retrench
  (WHEN (> INSIDE-HEIGHT MAX-HEIGHT)
    (SETQ N-ROWS (MAX 1 (// MAX-HEIGHT MAX-ITEM-HEIGHT))
	  INSIDE-HEIGHT (MIN MAX-HEIGHT (* N-ROWS MAX-ITEM-HEIGHT))))
  (WHEN (> INSIDE-WIDTH MAX-WIDTH)
    (WHEN COL-WIDTH		;If N-COLUMNS was not user-supplied, recompute it
      (SETQ N-COLUMNS (MAX (// (+ MAX-WIDTH INTERCOLUMN-SPACING) COL-WIDTH) 1))
      (SETQ INSIDE-WIDTH (- (* N-COLUMNS COL-WIDTH) INTERCOLUMN-SPACING)))
    (WHEN (> INSIDE-WIDTH MAX-WIDTH)
      (SETQ INSIDE-WIDTH MAX-WIDTH)))

  ;; At this point, INSIDE-WIDTH, INSIDE-HEIGHT, N-COLUMNS (if not FILL-P), and N-ROWS
  ;; are all valid and consistent, and not bigger than the available area,
  ;; provided that the user's original parameters were not illegally huge.

  ;; Return all the dependent parameters as multiple values
  (VALUES (IF FILL-P 0 N-COLUMNS) N-ROWS INSIDE-WIDTH INSIDE-HEIGHT MAX-ITEM-HEIGHT))

(DEFMETHOD (:MAXIMUM-SIZE BASIC-MENU) ()
  (VALUES (- (SHEET-INSIDE-WIDTH SUPERIOR) LEFT-MARGIN-SIZE RIGHT-MARGIN-SIZE)
	  (- (SHEET-INSIDE-HEIGHT SUPERIOR) TOP-MARGIN-SIZE BOTTOM-MARGIN-SIZE)))

(DEFVAR *ORDER-MENU-COLUMNWISE* NIL
  "Whether to invert the menu's list to read down columns.")

;;; This function computes the ROW-MAP, which determines how many strings per line, & c.
;;; The first value is the row-map and the second is the n-total-rows
(DEFUN-IN-FLAVOR (MENU-COMPUTE-ROW-MAP BASIC-MENU) (&OPTIONAL (INSIDE-WIDTH (SHEET-INSIDE-WIDTH))
						    &AUX (MAP (MAKE-ARRAY (1+ (LENGTH ITEM-LIST))))
							 (TOTAL-HEIGHT 0)
							 (FILL-P (GEOMETRY-FILL-P GEOMETRY)))
  (DO ((ITEMS (IF *ORDER-MENU-COLUMNWISE* (SI:COLUMN-INVERT-LIST ITEM-LIST COLUMNS)
		  ITEM-LIST))
       (ROW 0 (1+ ROW)))
      ((NULL ITEMS)
       (VALUES (ADJUST-ARRAY-SIZE MAP (1+ ROW))  ;Last element always contains NIL
	       ROW TOTAL-HEIGHT))
    (ASET ITEMS MAP ROW)	;This is where this row starts
    (IF FILL-P		;Fill mode, we have some hairy calculation to do
	(LET ((MAX-HEIGHT 0))
	  (DO ((SPACE INSIDE-WIDTH))
	      ((NULL ITEMS))
	    (MULTIPLE-VALUE-BIND (WID HEI)
		(MENU-ITEM-STRING-SIZE SELF (CAR ITEMS))
	      (COND ((> WID SPACE)		;This one won't fit, break the line
		     (AND (> WID INSIDE-WIDTH)
			  (FERROR "The item /"~A/" is too wide for this fill-mode menu"
				  (CAR ITEMS)))
		     (RETURN NIL)))
	      (SETQ MAX-HEIGHT (MAX MAX-HEIGHT HEI)
		    SPACE (- SPACE (+ WID INTERWORD-SPACING))
		    ITEMS (CDR ITEMS))))
	  (INCF TOTAL-HEIGHT MAX-HEIGHT))
	(SETQ ITEMS (NTHCDR COLUMNS ITEMS)
	      TOTAL-HEIGHT (+ TOTAL-HEIGHT LINE-HEIGHT)))))

(DEFUN-IN-FLAVOR (MENU-COMPUTE-GEOMETRY BASIC-MENU) (DRAW-P &OPTIONAL INSIDE-WIDTH INSIDE-HEIGHT)
  "This function is called whenever something related to the geometry changes.  The menu
is redrawn if DRAW-P is T."
  (WHEN (VARIABLE-BOUNDP ITEM-LIST)  ;Do nothing if item-list not specified yet
    ;; NIL doesn't work as an item, so remove them.  Leaves item-list EQ in normal case.
    ;; I suppose some programs might want to insert NIL as a poor way of
    ;; conditionally including items in the list.
    (SETQ ITEM-LIST (REMQ NIL ITEM-LIST))
    ;; Get the new N-ROWS and so forth.
    (MULTIPLE-VALUE (COLUMNS SCREEN-ROWS INSIDE-WIDTH INSIDE-HEIGHT ROW-HEIGHT)
      (MENU-DEDUCE-PARAMETERS NIL NIL INSIDE-WIDTH INSIDE-HEIGHT NIL NIL))
    ;; Recompute the row map
    (MULTIPLE-VALUE (ROW-MAP TOTAL-ROWS)
      (MENU-COMPUTE-ROW-MAP INSIDE-WIDTH))
    (SETQ TOP-ROW 0)
    (SEND SELF :NEW-SCROLL-POSITION TOP-ROW)
    (SEND SELF :SET-SCROLL-BAR-ALWAYS-DISPLAYED-P :LEFT (> TOTAL-ROWS SCREEN-ROWS))
    (SETQ COLUMN-WIDTH
	  (AND (NOT (GEOMETRY-FILL-P GEOMETRY))
	       (// (+ INSIDE-WIDTH INTERCOLUMN-SPACING) COLUMNS)))
    (COND ((AND (= INSIDE-HEIGHT (SHEET-INSIDE-HEIGHT))
		(= INSIDE-WIDTH (SHEET-INSIDE-WIDTH)))
	   (WHEN DRAW-P
	     (SHEET-FORCE-ACCESS (SELF :NO-PREPARE)
	       (%SCREEN-PAGE-IN-SHEET-TEMPORARY-BIT-ARRAY SCREEN SELF SCREEN-ARRAY :WRITE)
	       (SEND SELF :MENU-DRAW))))
	  ((SEND SELF :SET-INSIDE-SIZE INSIDE-WIDTH INSIDE-HEIGHT :VERIFY)
	   ;; Room to do this in current place.
	   (LET-GLOBALLY ((SET-EDGES-MODE T))
	     (SEND SELF :SET-INSIDE-SIZE INSIDE-WIDTH INSIDE-HEIGHT)))
	  (T
	   ;; Else try to be approximately in the same place
	   (LET ((CX (+ X-OFFSET (// WIDTH 2)))
		 (CY (+ Y-OFFSET (// HEIGHT 2))))
	     (WITH-SHEET-DEEXPOSED (SELF)
	       (LET-GLOBALLY ((SET-EDGES-MODE T))
		 (SEND SELF :SET-INSIDE-SIZE INSIDE-WIDTH INSIDE-HEIGHT))
	       (CENTER-WINDOW-AROUND SELF CX CY))))))
  NIL)

;; Used by Japanese
(DEFVAR *BASIC-MENU-FONT-MAP-FILTER* NIL)

(DEFMETHOD (:INIT BASIC-MENU :BEFORE) (INIT-PLIST &AUX (SUP SUPERIOR) TEM)
  (SETQ SUP (OR SUP (GET INIT-PLIST :SUPERIOR) DEFAULT-SCREEN))
  (SEND SELF :SET-DEFAULT-CHARACTER-STYLE
	(OR (GET INIT-PLIST :DEFAULT-CHARACTER-STYLE)
	    (GET INIT-PLIST :DEFAULT-STYLE)
	    (MENU-DEFAULT-CHARACTER-STYLE (SHEET-GET-SCREEN SUP))))
  ;; *** What was this trying to do ?
  #+Ignore
  (OR (VARIABLE-BOUNDP FONT-MAP)
      (SETQ FONT-MAP
	    (MENU-COMPUTE-FONT-MAP (AND (VARIABLE-BOUNDP ITEM-LIST)
					ITEM-LIST)
				   (OR (GET INIT-PLIST :DEFAULT-FONT)
				       (SEND (SHEET-GET-SCREEN SUP) :MENU-FONT))
				   (LAMBDA (MAP)
				     (DECLARE (SYS:DOWNWARD-FUNCTION))
				     (IF *BASIC-MENU-FONT-MAP-FILTER*
					 (FUNCALL *BASIC-MENU-FONT-MAP-FILTER* MAP INIT-PLIST)
					 MAP)))))
  (PUTPROP INIT-PLIST NIL :MORE-P)
  (SETQ TEM (GET INIT-PLIST :GEOMETRY))
  (IF (> (LENGTH TEM) (LENGTH GEOMETRY))
      ;; Longer than we need, take a copy of the list
      (SETQ GEOMETRY (COPYLIST TEM))
      ;; Else copy the appropriate piece of user specified list into our list
      (DO ((TEM TEM (CDR TEM))
	   (GEO GEOMETRY (CDR GEO)))
	  ((NULL TEM))
	(SETF (CAR GEO) (CAR TEM))))
  (AND (GET INIT-PLIST :FILL-P)
       ;(SETF (GEOMETRY-FILL-P GEOMETRY) T)  ;Compiler gives a gratuitous warning for this
       (SETF (GEOMETRY-N-COLUMNS GEOMETRY) 0))
  (MULTIPLE-VALUE-BIND (VAL PRESENCE) (SI:MULTIPLE-VALUE-GET INIT-PLIST :CENTERED-COLUMNS)
    (IF PRESENCE
	(SETF (GEOMETRY-CENTERED-COLUMNS GEOMETRY) VAL)
	(SETF (GEOMETRY-CENTERED-COLUMNS GEOMETRY) T)))
  (AND (SETQ TEM (GET INIT-PLIST :ROWS))
       (SETF (GEOMETRY-N-ROWS GEOMETRY) TEM))
  (AND (SETQ TEM (GET INIT-PLIST :COLUMNS))
       (SETF (GEOMETRY-N-COLUMNS GEOMETRY) TEM)))

(DEFMETHOD (:INIT BASIC-MENU :AFTER) (IGNORE)
  (SETF (BLINKER-VISIBILITY (CAR BLINKER-LIST)) NIL)
  (MENU-COMPUTE-GEOMETRY NIL))

(DEFUN MENU-VSP (SCREEN)
  (SETQ SCREEN (SHEET-SCREEN SCREEN))
  (LET ((TEXT (MAKE-CHARACTER #/X :STYLE (MENU-DEFAULT-CHARACTER-STYLE SCREEN))))
    (ROUND (FONT-CHAR-HEIGHT (SHEET-GET-CHAR-FONT TEXT T SCREEN)) 5)))

(DEFMETHOD ((CL:SETF MENU-DEFAULT-CHARACTER-STYLE) BASIC-SCREEN :AFTER) (IGNORE)
  (SETQ MENU-DEFAULT-CHARACTER-STYLE (SI:PARSE-CHARACTER-STYLE MENU-DEFAULT-CHARACTER-STYLE))
  (SI:MAP-OVER-OBJECTS-IN-AREA
    SHEET-AREA
    #'SI:REGION-PREDICATE-STRUCTURE
    #'(LAMBDA (IGNORE IGNORE WINDOW &REST IGNORE)
	(WHEN (TYPEP WINDOW 'BASIC-MENU)
	  (WHEN (AND (ZEROP (SHEET-DEAD WINDOW)) (EQ SELF (SEND WINDOW :SCREEN)))
	    (CHANGE-DEFAULT-CHARACTER-STYLE WINDOW MENU-DEFAULT-CHARACTER-STYLE))))))

(DEFMETHOD (CHANGE-DEFAULT-CHARACTER-STYLE BASIC-MENU) (NEW-STYLE)
  (SEND SELF :SET-DEFAULT-CHARACTER-STYLE NEW-STYLE)
  (WHEN EXPOSED-P
    (SEND SELF :REFRESH)))

(COMPILER:MAKE-MESSAGE-OBSOLETE
  :MENU-STYLE "use (TV:MENU-DEFAULT-CHARACTER-STYLE SCREEN instead")

(DEFMETHOD (:REFRESH BASIC-MENU :AFTER) (&OPTIONAL TYPE)
  (OR (AND RESTORED-BITS-P (NEQ TYPE ':SIZE-CHANGED))
      (SEND SELF ':MENU-DRAW)))

(DEFMETHOD (:CHANGE-OF-SIZE-OR-MARGINS BASIC-MENU :AFTER) (&REST IGNORE)
  (COND ((EQ SET-EDGES-MODE T))  ;Recursive call, caller will take care of it
	((EQ SET-EDGES-MODE ':USER)
	 ;; Some sort of explicit setting of edges -- make the new size sticky
	 (SETF (GEOMETRY-INSIDE-WIDTH GEOMETRY) (SHEET-INSIDE-WIDTH))
	 (SETF (GEOMETRY-INSIDE-HEIGHT GEOMETRY) (SHEET-INSIDE-HEIGHT))
	 (MENU-COMPUTE-GEOMETRY NIL))
	((EQ SET-EDGES-MODE NIL)
	 (MENU-COMPUTE-GEOMETRY NIL))
	(T
	 ;; Some change other than by user or margins or compute geometry -- recompute
	 ;; geometry, use current size, but don't make it sticky.
	 ;; E.g. :MOVE-NEAR-WINDOW
	 (MENU-COMPUTE-GEOMETRY NIL (SHEET-INSIDE-WIDTH) (SHEET-INSIDE-HEIGHT)))))

(DEFWRAPPER (:SET-EDGES BASIC-MENU) (IGNORE . BODY)
  `(LET-GLOBALLY ((SET-EDGES-MODE (OR SET-EDGES-MODE ':USER)))
     . ,BODY))

(DEFMETHOD (:SET-ITEM-LIST BASIC-MENU) (NEW-ITEM-LIST &OPTIONAL FONT-MAP-FILTER)
  (SETQ ITEM-LIST NEW-ITEM-LIST
	LAST-ITEM NIL
	CURRENT-ITEM NIL)
  ;;; *** What is this really doing?
  (IGNORE FONT-MAP-FILTER) ; this here till the line below is cleared up...
  #+ignore
  (SEND SELF ':SET-FONT-MAP (MENU-COMPUTE-FONT-MAP NEW-ITEM-LIST NIL FONT-MAP-FILTER))
  (MENU-COMPUTE-GEOMETRY T)		;Recompute parameters, and redraw menu
  NEW-ITEM-LIST)

(DEFMETHOD (:SET-LABEL BASIC-MENU :AFTER) (IGNORE)
  (MENU-COMPUTE-GEOMETRY T))

(DEFWHOPPER (:SET-VSP BASIC-MENU) (NEW-VSP)
  (LET ((CHANGING ( NEW-VSP VSP)))
    (CONTINUE-WHOPPER NEW-VSP)
    ;; This is not just an efficiency optimization.  The :init methods also send the :set-vsp
    ;; internally (no distinction between user message and system internal message) to the
    ;; same thing as already in force.
    (WHEN CHANGING
      (MENU-COMPUTE-GEOMETRY T))))

(COMPILER:MAKE-MESSAGE-OBSOLETE :SET-DEFAULT-FONT "use :SET-DEFAULT-STYLE")
(DEFMETHOD (:SET-DEFAULT-FONT BASIC-MENU) (IGNORE))

(DEFMETHOD (:SET-GEOMETRY BASIC-MENU) (&REST NEW-GEOMETRY)
  (DECLARE (ARGLIST (&OPTIONAL N-COLUMNS N-ROWS INSIDE-WIDTH INSIDE-HEIGHT
			       MAX-WIDTH MAX-HEIGHT)))
  "NIL for an argument means make it unconstrained.  T or unsupplied means leave it alone"
  (OR ( (LENGTH NEW-GEOMETRY) (LENGTH GEOMETRY))
      (FERROR "Too many args to :SET-GEOMETRY"))
  (DO ((G NEW-GEOMETRY (CDR G))
       (CG GEOMETRY (CDR CG)))
      ((NULL G))
    (IF (NEQ (CAR G) T)
	(RPLACA CG (CAR G))))
  (MENU-COMPUTE-GEOMETRY T))

(DEFMETHOD (:CURRENT-GEOMETRY BASIC-MENU) ()
  "Like :GEOMETRY but returns the current state rather than the default"
  (LIST (IF (GEOMETRY-FILL-P GEOMETRY) 0 COLUMNS) TOTAL-ROWS
	(SHEET-INSIDE-WIDTH) (SHEET-INSIDE-HEIGHT)
	(GEOMETRY-MAX-WIDTH GEOMETRY) (GEOMETRY-MAX-HEIGHT GEOMETRY)
	(GEOMETRY-FLAGS GEOMETRY)))

(DEFMETHOD (:FILL-P BASIC-MENU) () (GEOMETRY-FILL-P GEOMETRY))
(DEFMETHOD (:SET-FILL-P BASIC-MENU) (FILL-P)
  (SEND SELF ':SET-GEOMETRY (IF FILL-P 0 NIL)))

(DEFMETHOD (:CENTERED-COLUMNS BASIC-MENU) ()
  (GEOMETRY-CENTERED-COLUMNS GEOMETRY))
(DEFMETHOD (:SET-CENTERED-COLUMNS BASIC-MENU) (CENTERED)
  (SET-GEOMETRY-CENTERED-COLUMNS GEOMETRY CENTERED))

(DEFMETHOD (:MOUSE-STANDARD-BLINKER BASIC-MENU) ()
  ;; Change the mouse cursor to a small X so it doesn't get in the way
  (MOUSE-SET-BLINKER-DEFINITION-INTERNAL (SHEET-MOUSE SELF)
					 ':CHARACTER 4 5 ':ON
					 ':SET-CHARACTER #\MOUSE:TIMES))

;;; Mouse handler for menus
(DEFMETHOD (:HANDLE-MOUSE BASIC-MENU :BEFORE) ()
  ;; Forget anything we knew before about the highlight, so it will really be positioned
  (SETQ CURRENT-ITEM NIL))

(DEFMETHOD (:HANDLE-MOUSE BASIC-MENU :AFTER) ()
  ;; When mouse leaves this window, stop flashing any item
  (BLINKER-SET-VISIBILITY (CAR BLINKER-LIST) NIL))

;;; Mouse-click handler for menus.
;;; All buttons are treated the same, select the item you are on.
;;; There are no double-clicks and you can't get to the system command menu.
;;; Clicking when the menu is not exposed just exposes it.

(DEFMETHOD (:MOUSE-BUTTONS BASIC-MENU) (BD X Y)
  BD X Y ;ignored, we don't care where the mouse is, the :MOUSE-MOVES method took care of that
  (COND (CURRENT-ITEM				;Any button, select item.
	 (SETQ LAST-ITEM CURRENT-ITEM
	       CHOSEN-ITEM CURRENT-ITEM)
	 (COND ((AND (LISTP CHOSEN-ITEM)
		     ( (LENGTH CHOSEN-ITEM) 3)
		     (EQ (SECOND CHOSEN-ITEM) ':BUTTONS))
		(SETQ CHOSEN-ITEM (NTH (1- (HAULONG BD)) (THIRD CHOSEN-ITEM))))))
	((AND ( X (SHEET-INSIDE-LEFT)) (< X (SHEET-INSIDE-RIGHT))
	      ( Y (SHEET-INSIDE-TOP)) (< Y (SHEET-INSIDE-BOTTOM))))
	(T
	 ;; Here, clicked on the window, but outside of the window proper.
	 ;; Send a :MOUSE-CLICK message so things like margin regions can work.
	 (SEND SELF ':MOUSE-CLICK (MOUSE-BUTTON-ENCODE BD (SHEET-MOUSE SELF)) X Y))))

(DEFMETHOD (:MOUSE-CLICK BASIC-MENU) (BD X Y)
  ;; If we get to here, punt: default action is to do nothing
  BD X Y
  T)

(DEFVAR *RESTORE-MOUSE-POSITION-AFTER-MENU-SELECTION* T)

(DEFVAR *RESTORE-MOUSE-POSITION-CUTOFF-SPEED* 1)

;;; Maybe this should put the mouse sheet back?
(defmacro saving-mouse-position (sheet &body body)
  `(saving-mouse-position-internal
     ,sheet
     (lambda (test-continuation warper-continuation)
       (flet ((restore-mouse-position-if-necessary (&optional (condition 't))
		(when (and condition
			   (funcall test-continuation))
		  (funcall warper-continuation))))
	 ,@body))))

(defun saving-mouse-position-internal (sheet continuation)
  (let* ((mouse (sheet-mouse sheet))
	 (x-position (mouse-x mouse))
	 (y-position (mouse-y mouse))
	 (the-mouse-sheet (mouse-sheet mouse)))
    (funcall continuation
	     #'(lambda ()			;tester
		 (and *restore-mouse-position-after-menu-selection*
		      (eq the-mouse-sheet (mouse-sheet mouse))
		      (< (mouse-speed mouse) *restore-mouse-position-cutoff-speed*)))
	     #'(lambda ()			;warper
		 (mouse-warp x-position y-position mouse)))))

(DEFMETHOD (:CHOOSE BASIC-MENU) ()
  (SAVING-MOUSE-POSITION SELF
    (SETQ CHOSEN-ITEM NIL)
    (OR EXPOSED-P (SEND SELF ':EXPOSE))
    (PROCESS-WAIT "Menu Choose" #'(LAMBDA (ITEM-LOC STATUS-LOC)
				    (OR (CAR ITEM-LOC) (NULL (CAR STATUS-LOC))))
		  (LOCF CHOSEN-ITEM)
		  (LOCF EXPOSED-P))
    (LET ((ITEM CHOSEN-ITEM))
      (SETQ CHOSEN-ITEM NIL)
      (AND ITEM
	   (PROGN (RESTORE-MOUSE-POSITION-IF-NECESSARY)
		  (VALUES (SEND SELF :EXECUTE ITEM) ITEM))))))

;;; This is called from the scheduler
(DEFMETHOD (:WHO-LINE-DOCUMENTATION-STRING BASIC-MENU) ()
  (AND (VARIABLE-BOUNDP CURRENT-ITEM)
       (MENU-ITEM-WHO-LINE-DOCUMENTATION CURRENT-ITEM)))

(DEFUN MENU-ITEM-WHO-LINE-DOCUMENTATION (ITEM)
  (AND (LISTP ITEM) (LISTP (CDR ITEM))
       (GET (CDDR ITEM) ':DOCUMENTATION)))

;;; Split this out from :mouse-moves so we can share code in other places.
(DEFMETHOD (COMPUTE-CURRENT-ITEM BASIC-MENU) (X Y)
  "Compute the item under the mouse, even if it's not selectable."
  
  (DECLARE (VALUES ITEM BLINKER BLWIDTH BLX BLY BLHEIGHT))
  
  (MOUSE-SET-BLINKER-CURSORPOS SELF)
  
  (LET* ((FILL-P (GEOMETRY-FILL-P GEOMETRY))
	 (FULL-WIDTH (SHEET-INSIDE-WIDTH))
	 (YREL (- Y (SHEET-INSIDE-TOP)))
	 (XREL (- X (SHEET-INSIDE-LEFT)))
	 (BLINKER (CAR BLINKER-LIST))
	 (BLWIDTH 0) (BLHEIGHT 0)
	 ROW BLX BLY ITEM)
    
    (COND ((AND ( XREL 0)			;If inside the menu
		(< X (SHEET-INSIDE-RIGHT))
		( Y (SHEET-INSIDE-TOP))
		(< Y (SHEET-INSIDE-BOTTOM)))
	   
	   (COND (FILL-P 
		  (SETQ ITEM NIL
			BLY 0
			ROW TOP-ROW)
		  (LOOP FOR ITEMS IN (AREF ROW-MAP ROW)
			WITH X = 0
			DO
		    (MULTIPLE-VALUE-BIND (W H)
			(MENU-ITEM-STRING-SIZE SELF ITEMS)

		      (WHEN (>  (+ X W) FULL-WIDTH)
			(IF (>= (+ BLY BLHEIGHT) YREL)
			    (RETURN NIL)
			    (SETQ BLY (+ BLY BLHEIGHT INTERROW-SPACING)
				  BLHEIGHT 0
				  X 0
				  ITEM NIL
				  ROW (1+ ROW)))
			)

		      (WHEN (AND (> (+ X W INTERWORD-SPACING) XREL)
				 (NULL ITEM))
			(SETQ ITEM ITEMS
			      BLX X
			      BLWIDTH W)
			)
		      (SETQ BLHEIGHT (MAX BLHEIGHT H)
			    X (+ X W INTERWORD-SPACING))))
		  )
		 (T
		  (SETQ ROW (// YREL ROW-HEIGHT)
			BLY (* ROW ROW-HEIGHT)
			BLHEIGHT ROW-HEIGHT)
		  
		  ;;If mouse is past the last displayed row, don't blink item.
		  (WHEN (OR (>= (+ TOP-ROW ROW) TOTAL-ROWS) (>= ROW SCREEN-ROWS))
		    (SETQ ROW -1))
		  
		  (UNLESS (MINUSP ROW)
		    (LET ((COLN (// XREL COLUMN-WIDTH)))	;Column selected
		      (WHEN (SETQ ITEM (CAR (NTHCDR COLN (AREF ROW-MAP (+ TOP-ROW ROW)))))
			(MULTIPLE-VALUE (BLWIDTH BLHEIGHT)
			  (MENU-ITEM-STRING-SIZE SELF ITEM COLUMN-WIDTH))
			
			(COND (BLHEIGHT (SETQ BLHEIGHT (+ BLHEIGHT INTERROW-SPACING)))
			      (T (SETQ BLHEIGHT ROW-HEIGHT)))
			(SETQ BLWIDTH (1+ BLWIDTH))
			(SETQ BLX (+ (* COLN COLUMN-WIDTH)	;Start of column
				     -1
				     (IF (GEOMETRY-CENTERED-COLUMNS GEOMETRY)
					 (MAX 0 (// (- COLUMN-WIDTH	;Centering
						       MENU-INTERCOLUMN-SPACING
						       BLWIDTH
						       -1)	;round to nearest
						    2))
					 0)))
			(SETQ BLY (+ -1 BLY (// (- ROW-HEIGHT BLHEIGHT) 2)))
			(SETQ BLWIDTH (MIN BLWIDTH FULL-WIDTH
					   (- COLUMN-WIDTH INTERCOLUMN-SPACING -1)))
			
			BLX (+ (* COLN COLUMN-WIDTH)	;Start of column
			       -1
			       (IF (GEOMETRY-CENTERED-COLUMNS GEOMETRY)
				   (MAX 0 (// (- COLUMN-WIDTH	;Centering
						 MENU-INTERCOLUMN-SPACING
						 BLWIDTH
						 -1)	;round to nearest
					      2))
				   0)))))
		  ))
	   
	   
	   (WHEN ITEM
	     (LET ((ITEM (MENU-ITEM-STRING SELF ITEM)))
	       (WHEN (AND (INSTANCEP ITEM)
			  (OPERATION-HANDLED-P ITEM :MENU-BLINKER-EDGES))
		 ;; interface to the instance protocol, which allows instances
		 ;; to specift the size of the box independantly
		 (MULTIPLE-VALUE-BIND (BLX-OFF BLY-OFF BLX-BOT BLY-BOT)
		     (SEND ITEM ':MENU-BLINKER-EDGES SELF)
		   (WHEN (AND (FIXP BLX-OFF) (FIXP BLY-OFF) (FIXP BLX-BOT) (FIXP BLY-BOT))
		     (SETQ BLWIDTH (- BLX-BOT BLX-OFF -1)
			   BLHEIGHT (- BLY-BOT BLY-OFF -1)
			   BLX (+ BLX BLX-OFF)
			   BLY (+ BLY BLY-OFF)))))))))
	   
    (VALUES ITEM BLINKER BLWIDTH BLX BLY BLHEIGHT)))

;;; This is the guts.  Given a menu and a set of coordinates, it finds
;;; the corresponding item, if any, sets CURRENT-ITEM to it, and sets up
;;; the blinker to mark that item.  If no item, the blinker is shut off.
(DEFMETHOD (:MOUSE-MOVES BASIC-MENU) (X Y)
  (MULTIPLE-VALUE-BIND (ITEM BLINKER BLWIDTH BLX BLY BLHEIGHT)
      (COMPUTE-CURRENT-ITEM SELF X Y)
    ;; If this item is non-selectable, don't select it.
    (AND (NOT (ATOM ITEM)) (NOT (ATOM (CDR ITEM))) (NOT (ATOM (CDDR ITEM)))
	 (EQ (CADR ITEM) ':NO-SELECT)
	 (SETQ ITEM NIL))
    ;; Now make the blinker be where and what we have just found it should be.
    (BLINKER-SET-VISIBILITY BLINKER (NOT (NULL ITEM)))
    (SETQ CURRENT-ITEM ITEM)
    (NEED-MOUSE-DOCUMENTATION-UPDATE)
    (WHEN ITEM
      (SEND BLINKER ':SET-SIZE-AND-CURSORPOS 
	    BLWIDTH BLHEIGHT
	    BLX BLY)
      (NEED-MOUSE-DOCUMENTATION-UPDATE)
      )))

(DEFMETHOD (:SCROLL-POSITION BASIC-MENU) ()
  (VALUES TOP-ROW TOTAL-ROWS ROW-HEIGHT))

(DEFMETHOD (:SCROLL-TO BASIC-MENU) (LINE MODE)
  (SELECTQ MODE
    (:ABSOLUTE)
    ((:RELATIVE :RELATIVE-JUMP) (SETQ LINE (+ TOP-ROW LINE)))
    (OTHERWISE (FERROR "Illegal scroll mode ~A" MODE)))
  (WHEN ( (SETQ LINE (MAX 0 (MIN LINE (1- TOTAL-ROWS)))) TOP-ROW)
    ;; Actually changing something, update
    (SETQ TOP-ROW LINE)
    (SEND SELF ':MENU-DRAW)
    (SEND SELF ':NEW-SCROLL-POSITION TOP-ROW)))

;;; Put a menu near another window.  This will normally try to put it just below
;;; it and give it the same width.
(DEFMETHOD (:MOVE-NEAR-WINDOW BASIC-MENU) (W)
  (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
      (SEND W ':EDGES)
    (MULTIPLE-VALUE-BIND (IGNORE IGNORE IGNORE NEW-HEIGHT)
	(MENU-DEDUCE-PARAMETERS NIL NIL (- RIGHT LEFT) NIL NIL NIL)
      (SETQ NEW-HEIGHT (+ NEW-HEIGHT TOP-MARGIN-SIZE BOTTOM-MARGIN-SIZE))
      ;If it won't fit below try putting it above
      (AND (> (+ BOTTOM NEW-HEIGHT)
	      (SHEET-INSIDE-BOTTOM SUPERIOR))
	   (SETQ BOTTOM (MAX (- TOP NEW-HEIGHT) 0)))
      ;Put it there
      (LET-GLOBALLY ((SET-EDGES-MODE ':MOVE-NEAR))
	(SEND SELF ':SET-EDGES LEFT BOTTOM RIGHT (+ BOTTOM NEW-HEIGHT)))
      (SEND SELF ':EXPOSE))))

;;; This is used by orthogonal things like hysteretic window
(DEFMETHOD (:SCROLL-BAR-P BASIC-MENU) () (< SCREEN-ROWS TOTAL-ROWS))

(DEFMETHOD (:MENU-DRAW BASIC-MENU) (&AUX (FILL-P (GEOMETRY-FILL-P GEOMETRY)))
 (PROG1
  (PREPARE-SHEET (SELF)
    (SEND SELF ':CLEAR-WINDOW)
    (DO ((ROW TOP-ROW (1+ ROW))
	 (Y-POS 0 (+ Y-POS (IF FILL-P
			       (+ MAX-HEIGHT-THIS-ROW INTERROW-SPACING)
			       ROW-HEIGHT)))
	 (MAX-HEIGHT-THIS-ROW 0 0)
	 (LIM (IF FILL-P
		  TOTAL-ROWS
		  (MIN TOTAL-ROWS (+ TOP-ROW SCREEN-ROWS)))))
	((OR ( ROW LIM) ( Y-POS (SHEET-INSIDE-HEIGHT))))
      ;; Compute the maximum height of any item on this row
      (DO ((ITEMS (AREF ROW-MAP ROW) (CDR ITEMS))
	   (END-ITEM-LIST (AREF ROW-MAP (1+ ROW)))
	   )
	  ((EQ ITEMS END-ITEM-LIST))
	(MULTIPLE-VALUE-BIND (NIL ITEM-HEIGHT)
	    (MENU-ITEM-STRING-SIZE SELF (CAR ITEMS))
	  (SETQ MAX-HEIGHT-THIS-ROW (MAX MAX-HEIGHT-THIS-ROW ITEM-HEIGHT))))
      (DO ((ITEMS (AREF ROW-MAP ROW) (CDR ITEMS))
	   (END-ITEM-LIST (AREF ROW-MAP (1+ ROW)))
	   (STR) (STYLE) (UNDERSCORE)
	   (X-POS 0))
	  ((EQ ITEMS END-ITEM-LIST))
	(MULTIPLE-VALUE (STR STYLE UNDERSCORE)
	  (MENU-ITEM-STRING SELF (CAR ITEMS)))
	(SETQ X-POS
	  (WITH-CHARACTER-STYLE (STYLE SELF :BIND-LINE-HEIGHT T)
	    (MULTIPLE-VALUE-BIND (ITEM-WIDTH ITEM-HEIGHT ITEM-BASELINE)
		;; Only pass in the string, since we have
		;; bound the style, we don't need that
		;; additional information.
		(MENU-ITEM-STRING-SIZE SELF STR)
	      (WITH-CURRENT-BASELINE (SELF ITEM-BASELINE)
		(LET* (LEFT-XPOS RIGHT-XPOS
		       (NEW-X-POS X-POS))
		  (COND (FILL-P			;Filled, put string followed by spacing
			 (SETQ LEFT-XPOS NEW-X-POS)
			 (SEND SELF ':SET-CURSORPOS NEW-X-POS
			       (+ Y-POS (MAX 0 (// (- MAX-HEIGHT-THIS-ROW ITEM-HEIGHT)
						   2))))
			 (SEND SELF :ITEM-STRING-OUT STR)
			 (SETQ NEW-X-POS (+ (SETQ RIGHT-XPOS (+ NEW-X-POS ITEM-WIDTH))
					    INTERWORD-SPACING)))
			((GEOMETRY-CENTERED-COLUMNS GEOMETRY)
			 ;;Columnated, center text within column
			 (SETQ LEFT-XPOS NEW-X-POS RIGHT-XPOS (+ NEW-X-POS COLUMN-WIDTH))
			 (LET ((ITEM-LEFT NEW-X-POS)
			       (ITEM-RIGHT (- (SETQ NEW-X-POS (+ NEW-X-POS COLUMN-WIDTH))
					      INTERCOLUMN-SPACING))
			       (ITEM-TOP (+ Y-POS (MAX 0 (// (- ROW-HEIGHT ITEM-HEIGHT
								INTERROW-SPACING)
							     2)))))
			   (COND ((INSTANCEP STR)
				  (SETQ ITEM-LEFT (+ ITEM-LEFT
						     (MAX 0 (// (- ITEM-RIGHT ITEM-LEFT
								   ITEM-WIDTH)
								2))))
				  (SEND SELF :SET-CURSORPOS ITEM-LEFT ITEM-TOP)
				  (SEND STR :MENU-PRINT SELF ITEM-LEFT ITEM-TOP))
				 (T
				  (SEND SELF ':DISPLAY-CENTERED-STRING STR
					ITEM-LEFT ITEM-RIGHT ITEM-TOP)))))
			(T ;;Ordinary, put out string
			 (SEND SELF ':SET-CURSORPOS NEW-X-POS Y-POS)
			 (MULTIPLE-VALUE-BIND (nil TRUNCATED-INDEX TRUNCATED-LENGTH)
			     (IF (INSTANCEP STR)
				 (VALUES nil 0 0)
				 (SEND SELF :STRING-LENGTH
				       STR 0 NIL (- COLUMN-WIDTH INTERCOLUMN-SPACING)))
			   (SEND SELF :ITEM-STRING-OUT STR 0 TRUNCATED-INDEX)
			   (WHEN UNDERSCORE
			     (SETQ LEFT-XPOS NEW-X-POS
				   RIGHT-XPOS (+ LEFT-XPOS TRUNCATED-LENGTH))))
			 (INCF NEW-X-POS COLUMN-WIDTH)))
		  (WHEN UNDERSCORE
		    (SEND SELF :DRAW-RECTANGLE (- RIGHT-XPOS LEFT-XPOS) 1
			  LEFT-XPOS (+ Y-POS CURRENT-BASELINE 2)))
		  NEW-X-POS))))))))
  ;; Make sure the mouse knows we changed
  (AND EXPOSED-P (MOUSE-WAKEUP (SHEET-MOUSE SELF)))))

(DEFMETHOD (:SET-CURSORPOS BASIC-MENU :AFTER) (&REST IGNORE)
  ;; Shut off the end of page exception after positioning.
  (SETF (SHEET-END-PAGE-FLAG) 0))

(DEFMETHOD (:ITEM-STRING-OUT BASIC-MENU) (STRING &OPTIONAL (START 0) END)
  (IF (INSTANCEP STRING)
      (MULTIPLE-VALUE-BIND (X Y)
	  (SEND SELF :READ-CURSORPOS)
	(SEND STRING :MENU-PRINT SELF X Y))
      (SEND SELF :STRING-OUT STRING START END)))

;;; Clear a single item's place in the menu
(DEFMETHOD (MENU-CLEAR-ITEM BASIC-MENU) (ITEM)
  (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
      (SEND SELF :ITEM-RECTANGLE ITEM)
    (WHEN LEFT
      (PREPARE-SHEET (SELF)
  	(LET ((LEFT (MAX (+ LEFT (SHEET-INSIDE-LEFT)) (SHEET-INSIDE-LEFT)))
	      (RIGHT (+ (MIN RIGHT (SHEET-INSIDE-WIDTH)) (SHEET-INSIDE-LEFT)))
	      (TOP (MAX (+ TOP (SHEET-INSIDE-TOP)) (SHEET-INSIDE-TOP)))
	      (BOTTOM (+ (MIN BOTTOM (SHEET-INSIDE-HEIGHT)) (SHEET-INSIDE-TOP))))
	  (SHEET-DRAW-RECTANGLE (- RIGHT LEFT) (- BOTTOM TOP) LEFT TOP ERASE-ALUF))))))

;;; Draw a single item of the menu
(DEFMETHOD (MENU-DRAW-ITEM BASIC-MENU) (ITEM)
  (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT IGNORE)
      (SEND SELF :ITEM-RECTANGLE ITEM)
    (WHEN LEFT
      (PREPARE-SHEET (SELF)
	(MULTIPLE-VALUE-BIND (STRING STYLE UNDERSCORE)
	    (MENU-ITEM-STRING SELF ITEM)
	  (WITH-CHARACTER-STYLE (STYLE SELF :BIND-LINE-HEIGHT T)
	    (LET ((LEFT (MAX (1+ LEFT) 0))
		  (RIGHT (MIN (1- RIGHT) (SHEET-INSIDE-WIDTH)))
		  (TOP (MAX (1+ TOP) 0)))
	      (SEND SELF :SET-CURSORPOS LEFT TOP)
	      (LET ((LIMITING-WIDTH (- RIGHT LEFT)))
		(MULTIPLE-VALUE-BIND (IGNORE TRUNCATED-LENGTH)
		    (SEND SELF :STRING-LENGTH STRING 0 NIL LIMITING-WIDTH)
		  (SEND SELF :ITEM-STRING-OUT STRING 0 TRUNCATED-LENGTH)))
	      (SETQ RIGHT (+ (SEND SELF :READ-CURSORPOS)
			     (IF (GEOMETRY-FILL-P GEOMETRY) INTERWORD-SPACING 0)))
	      (WHEN UNDERSCORE
		(LET ((FONT-BASELINE (FONT-BASELINE CURRENT-FONT)))
		  (SEND SELF :DRAW-RECTANGLE (- RIGHT LEFT) 1
					     LEFT (+ TOP FONT-BASELINE 2)))))))))))


;;; Here is how we make a menu appear with the last item chosen under the mouse.

;;; Return the x and y co-ordinates (inside the margins)
;;; of the center of the specified item, NIL if scrolled off display
(DEFMETHOD (:ITEM-CURSORPOS BASIC-MENU) (ITEM)
  (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
      (SEND SELF :ITEM-RECTANGLE ITEM)
    (WHEN LEFT
      (VALUES (// (+ LEFT RIGHT) 2)
	      (// (+ TOP BOTTOM) 2)))))

;;; Return the left, top, right, bottom coordinates (inside the margins)
;;; of the rectangle enclosing the specified item, including one bit of
;;; margin all around, or NIL if scrolled off the display.
;;; Note that because of the one bit of margin, returned values can be outside
;;; the window.
(DEFMETHOD (:ITEM-RECTANGLE BASIC-MENU) (ITEM &AUX (X 0) SWIDTH (ALEN (ARRAY-LENGTH ROW-MAP)))

  (IF (GEOMETRY-FILL-P GEOMETRY)

      (LOOP FOR I IN (AREF ROW-MAP TOP-ROW)
	    WITH ITEM-X = 0 AND ITEM-Y = 0
	    AND W AND H AND MAXH = 0 AND FOUND AND FOUND-W AND FOUND-H
	    INITIALLY
	      (UNLESS (MEMQ ITEM (AREF ROW-MAP TOP-ROW))
		(RETURN NIL))
	    DO
	(MULTIPLE-VALUE (W H)
	  (MENU-ITEM-STRING-SIZE SELF I))
	(COND ((> (+ ITEM-X W) (SHEET-INSIDE-WIDTH))
	       (WHEN FOUND
		 (SETQ ITEM-Y (+ ITEM-Y (MAX 0 (// (- MAXH FOUND-H) 2))))
		 (RETURN (VALUES (1- FOUND)
				 (1- ITEM-Y)
				 (+ 2 FOUND FOUND-W)
				 (+ 2 ITEM-Y FOUND-H))))
	       
	       (WHEN (> ITEM-Y (SHEET-INSIDE-HEIGHT))
		 (RETURN NIL))
	       
	       (SETQ ITEM-Y (+ ITEM-Y MAXH INTERROW-SPACING)
		     ITEM-X 0
		     MAXH 0)
	       ))
	(WHEN (EQ ITEM I)
	  (SETQ FOUND ITEM-X
		FOUND-W W
		FOUND-H H))
	
	(SETQ ITEM-X (+ ITEM-X INTERWORD-SPACING W)
	      MAXH (MAX MAXH H))
	    FINALLY
	      (WHEN FOUND
		(SETQ ITEM-Y (+ ITEM-Y (MAX 0 (// (- MAXH FOUND-H) 2))))
		(RETURN (VALUES (1- FOUND)
				(1- ITEM-Y)
				(+ 2 FOUND FOUND-W)
				(+ 2 ITEM-Y FOUND-H)))))

      (DO ((ROW (1- (MIN (+ TOP-ROW SCREEN-ROWS)	;last row on screen
		     ALEN))				;last row that exists
		(1- ROW)))
	  ((< ROW TOP-ROW) NIL)
	(COND ((AND (MEMQ ITEM (AREF ROW-MAP ROW))
		    (OR (= ROW (1- ALEN)) (NOT (MEMQ ITEM (AREF ROW-MAP (1+ ROW))))))
	       
	       (SETQ SWIDTH (MENU-ITEM-STRING-SIZE SELF ITEM COLUMN-WIDTH)
		     X (+ (* (FIND-POSITION-IN-LIST ITEM (AREF ROW-MAP ROW)) COLUMN-WIDTH)
			  (IF (GEOMETRY-CENTERED-COLUMNS GEOMETRY)
			      (// (- COLUMN-WIDTH
				     INTERCOLUMN-SPACING
				     SWIDTH) 2)
			      0)))
	       
	       (RETURN (VALUES (1- X) (1- (* (- ROW TOP-ROW) ROW-HEIGHT))
			       (+ X SWIDTH 1) (1- (* (1+ (- ROW TOP-ROW)) ROW-HEIGHT))))
	       ))
	)))

;; When we move a menu to a spot, make it go so that the last item chosen
;; appears at that spot.
(DEFMETHOD (:CENTER-AROUND BASIC-MENU) (X Y &AUX (XI 0) (YI 0))
  (AND (VARIABLE-BOUNDP LAST-ITEM)
       (MEMQ LAST-ITEM ITEM-LIST)
       ;; If we remember a previous choice,
       ;; let XI and YI get the offsets from that item to the center.
       (MULTIPLE-VALUE-BIND (X1 Y1)
	   (SEND SELF ':ITEM-CURSORPOS LAST-ITEM)
	 (AND X1 Y1
	      (SETQ XI (- (// WIDTH 2) X1 (SHEET-INSIDE-LEFT))
		    YI (- (// HEIGHT 2) Y1 (SHEET-INSIDE-TOP))))))
  (MULTIPLE-VALUE-BIND (X1 Y1)
      (CENTER-WINDOW-AROUND SELF (+ X XI) (+ Y YI))
    (VALUES (- X1 XI) (- Y1 YI))))

(DEFMETHOD (:COLUMN-ROW-SIZE BASIC-MENU) ()
  (VALUES COLUMN-WIDTH ROW-HEIGHT))

;; Permanent menus for giving "keyboard" commands from a menu alist
(DEFFLAVOR COMMAND-MENU-MIXIN (IO-BUFFER) ()
  (:REQUIRED-FLAVORS BASIC-MENU)
  (:SETTABLE-INSTANCE-VARIABLES IO-BUFFER))

(DEFMETHOD (:MOUSE-BUTTONS COMMAND-MENU-MIXIN :AFTER) (BD IGNORE IGNORE)
  (COND (CHOSEN-ITEM
	 (IO-BUFFER-PUT IO-BUFFER `(:MENU ,CHOSEN-ITEM ,BD ,SELF))
	 (SETQ CHOSEN-ITEM NIL))))

(DEFFLAVOR COMMAND-MENU () (COMMAND-MENU-MIXIN MENU))

(DEFFLAVOR COMMAND-MENU-ABORT-ON-DEEXPOSE-MIXIN () (COMMAND-MENU)
  (:DOCUMENTATION :MIXIN "Automatically clicks on the ABORT item if the menu is deexposed"))

(DEFMETHOD (:DEEXPOSE COMMAND-MENU-ABORT-ON-DEEXPOSE-MIXIN :BEFORE) (&REST IGNORE)
  (IF EXPOSED-P
      (DOLIST (ITEM ITEM-LIST)
	(IF (STRING-EQUAL (MENU-ITEM-STRING SELF ITEM) "ABORT")
	    (RETURN (IO-BUFFER-PUT IO-BUFFER `(:MENU ,ITEM 1 ,SELF)))))))

(DEFFLAVOR MENU-HIGHLIGHTING-MIXIN ((HIGHLIGHTED-ITEMS NIL)
				    (SELECTED-CHARACTER-STYLE NIL))
	   ()
  (:REQUIRED-FLAVORS BASIC-MENU)
  (:READABLE-INSTANCE-VARIABLES (MENU-HIGHLIGHTED-ITEMS HIGHLIGHTED-ITEMS))
  (:WRITABLE-INSTANCE-VARIABLES (MENU-SELECTED-CHARACTER-STYLE SELECTED-CHARACTER-STYLE))
  (:INITABLE-INSTANCE-VARIABLES HIGHLIGHTED-ITEMS SELECTED-CHARACTER-STYLE)
  (:DOCUMENTATION
    :MIXIN "Provides for highlighting of items with inverse video or merging character styles"
    ))

(DEFMETHOD (:INIT MENU-HIGHLIGHTING-MIXIN :BEFORE) (INIT-PLIST)
  (LET ((REAL-SUPERIOR (OR SUPERIOR (GET INIT-PLIST :SUPERIOR) DEFAULT-SCREEN)))
    (SETF SELECTED-CHARACTER-STYLE
	  (OR (WHEN (GET INIT-PLIST :SELECTED-CHARACTER-STYLE)
		(SI:PARSE-CHARACTER-STYLE (GET INIT-PLIST :SELECTED-CHARACTER-STYLE)))
	      (MENU-SELECTED-CHARACTER-STYLE (SHEET-GET-SCREEN REAL-SUPERIOR))))))

(DEFMETHOD ((CL:SETF MENU-SELECTED-CHARACTER-STYLE) BASIC-SCREEN :AFTER) (IGNORE)
  (WHEN MENU-SELECTED-CHARACTER-STYLE
    (SETQ MENU-SELECTED-CHARACTER-STYLE (SI:PARSE-CHARACTER-STYLE MENU-SELECTED-CHARACTER-STYLE)))
  (SI:MAP-OVER-OBJECTS-IN-AREA
    SHEET-AREA
    #'SI:REGION-PREDICATE-STRUCTURE
    #'(LAMBDA (IGNORE IGNORE WINDOW &REST IGNORE)
	(WHEN (TYPEP WINDOW 'MENU-HIGHLIGHTING-MIXIN)
	  (WHEN (AND (ZEROP (SHEET-DEAD WINDOW)) (EQ SELF (SEND WINDOW :SCREEN)))
	    (CHANGE-SELECTED-CHARACTER-STYLE WINDOW MENU-SELECTED-CHARACTER-STYLE))))))

(DEFMETHOD (CHANGE-SELECTED-CHARACTER-STYLE MENU-HIGHLIGHTING-MIXIN) (NEW-SELECTED-STYLE)
  (SETQ SELECTED-CHARACTER-STYLE NEW-SELECTED-STYLE)
  (WHEN EXPOSED-P
    (SEND SELF :REFRESH)))

;;; These understand the mapping between an item and its printed representation
;;; This attempts to win with fat strings by looking at the first character of the string.
;;; It should really return the largest font of the string.
(DEFWHOPPER (MENU-ITEM-STRING MENU-HIGHLIGHTING-MIXIN) (ITEM &OPTIONAL IGNORE-HIGHLIGHTING-P)
  (MULTIPLE-VALUE-BIND (STRING STYLE UNDERSCORE)
      (CONTINUE-WHOPPER ITEM IGNORE-HIGHLIGHTING-P)
    (UNLESS IGNORE-HIGHLIGHTING-P
      (WHEN (AND SELECTED-CHARACTER-STYLE (MEMQ ITEM HIGHLIGHTED-ITEMS))
	(SETQ STYLE (SI:MERGE-CHARACTER-STYLES SELECTED-CHARACTER-STYLE STYLE))))
    (VALUES STRING STYLE UNDERSCORE)))

(DEFMETHOD (MENU-ITEM-STRING-SIZE MENU-HIGHLIGHTING-MIXIN) (ITEM &OPTIONAL STOP-X
									   MAX-WIDTH-P)
  (MULTIPLE-VALUE-BIND (STRING STYLE IGNORE)
      (MENU-ITEM-STRING SELF ITEM MAX-WIDTH-P)
    (IF (AND MAX-WIDTH-P SELECTED-CHARACTER-STYLE)
	(MULTIPLE-VALUE-BIND (UNHIGHLIGHTED-WIDTH UNHIGHLIGHTED-HEIGHT UNHIGHLIGHTED-BASELINE)
	    (MENU-ITEM-STRING-SIZE-INTERNAL STRING STYLE STOP-X)
	  (MULTIPLE-VALUE-BIND (HIGHLIGHTED-WIDTH HIGHLIGHTED-HEIGHT HIGHLIGHTED-BASELINE)
	      (MENU-ITEM-STRING-SIZE-INTERNAL STRING
					      (SI:MERGE-CHARACTER-STYLES
						SELECTED-CHARACTER-STYLE STYLE)
					      STOP-X)
	    (VALUES (MAX UNHIGHLIGHTED-WIDTH HIGHLIGHTED-WIDTH)
		    (MAX UNHIGHLIGHTED-HEIGHT HIGHLIGHTED-HEIGHT)
		    (MAX UNHIGHLIGHTED-BASELINE HIGHLIGHTED-BASELINE))))
	(MENU-ITEM-STRING-SIZE-INTERNAL STRING STYLE STOP-X))))

; This does not remember it on the list, you probably don't want to use it yourself
(DEFMETHOD (INVERT-ITEM MENU-HIGHLIGHTING-MIXIN) (ITEM)
  (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM) (SEND SELF :ITEM-RECTANGLE ITEM)
    (AND (NOT (NULL LEFT))
	 (PREPARE-SHEET (SELF)			;Clip but allow extension into margins
	   (SETQ LEFT (MAX (+ LEFT (SHEET-INSIDE-LEFT)) 0)
		 RIGHT (MIN (+ RIGHT (SHEET-INSIDE-LEFT)) WIDTH)
		 TOP (MAX (+ TOP (SHEET-INSIDE-TOP)) 0)
		 BOTTOM (MIN (+ BOTTOM (SHEET-INSIDE-TOP)) HEIGHT))
	   (SHEET-DRAW-RECTANGLE (- RIGHT LEFT) (- BOTTOM TOP) LEFT TOP
				 (GRAPHICS::STANDARDIZE-ALU SELF :FLIP))))))

(DEFMETHOD (:ADD-HIGHLIGHTED-ITEM MENU-HIGHLIGHTING-MIXIN) (ITEM)
  (WHEN (NOT (MEMQ ITEM HIGHLIGHTED-ITEMS))
    (SHEET-FORCE-ACCESS (SELF T)
      (WHEN SELECTED-CHARACTER-STYLE (MENU-CLEAR-ITEM SELF ITEM))
      (PUSH ITEM HIGHLIGHTED-ITEMS)
      (IF SELECTED-CHARACTER-STYLE
	  (MENU-DRAW-ITEM SELF ITEM)
	  (INVERT-ITEM SELF ITEM)))
    ;; This is just for the case of the SHEET-FORCE-ACCESS not happening.
    ;; The push must occur within the extent of it to get the region cleared with the old
    ;; boundaries and drawn with the new.
    (CL:PUSHNEW ITEM HIGHLIGHTED-ITEMS)))

(DEFMETHOD (:REMOVE-HIGHLIGHTED-ITEM MENU-HIGHLIGHTING-MIXIN) (ITEM)
  (WHEN (MEMQ ITEM HIGHLIGHTED-ITEMS)
    (SHEET-FORCE-ACCESS (SELF T)
      (WHEN SELECTED-CHARACTER-STYLE (MENU-CLEAR-ITEM SELF ITEM))
      (SETQ HIGHLIGHTED-ITEMS (REMQ ITEM HIGHLIGHTED-ITEMS))
      (IF SELECTED-CHARACTER-STYLE
	  (MENU-DRAW-ITEM SELF ITEM)
	(INVERT-ITEM SELF ITEM)))
    ;; See comment on :ADD-HIGHLIGHTED-ITEM.
    (SETQ HIGHLIGHTED-ITEMS (REMQ ITEM HIGHLIGHTED-ITEMS))))

(DEFMETHOD (:SET-HIGHLIGHTED-ITEMS MENU-HIGHLIGHTING-MIXIN) (NEW-HIGHLIGHTED-ITEMS)
  (LET ((OLD-HIGHLIGHTED-ITEMS HIGHLIGHTED-ITEMS))
    (SHEET-FORCE-ACCESS (SELF T)
      (LOOP FOR ITEM IN OLD-HIGHLIGHTED-ITEMS
	    UNLESS (MEMQ ITEM NEW-HIGHLIGHTED-ITEMS)
	      DO (SEND SELF :REMOVE-HIGHLIGHTED-ITEM ITEM))
      (LOOP FOR ITEM IN NEW-HIGHLIGHTED-ITEMS
	    UNLESS (MEMQ ITEM OLD-HIGHLIGHTED-ITEMS)
	      DO (SEND SELF :ADD-HIGHLIGHTED-ITEM ITEM))))
  (SETQ HIGHLIGHTED-ITEMS (COPYLIST NEW-HIGHLIGHTED-ITEMS)))

(DEFMETHOD (:MENU-DRAW MENU-HIGHLIGHTING-MIXIN :AFTER) ()
  (UNLESS SELECTED-CHARACTER-STYLE
    (DOLIST (X HIGHLIGHTED-ITEMS)
      (INVERT-ITEM SELF X))))

(DEFMETHOD (:HIGHLIGHTED-VALUES MENU-HIGHLIGHTING-MIXIN) ()
  (MAPCAR #'(LAMBDA (X) (SEND SELF ':EXECUTE-NO-SIDE-EFFECTS X)) HIGHLIGHTED-ITEMS))

(DEFMETHOD (:SET-HIGHLIGHTED-VALUES MENU-HIGHLIGHTING-MIXIN) (VALUES &AUX ITEMS)
  (DOLIST (ITEM ITEM-LIST)
    (AND (MEMBER (SEND SELF ':EXECUTE-NO-SIDE-EFFECTS ITEM) VALUES)
	 (PUSH ITEM ITEMS)))
  (UNLESS (= (LENGTH ITEMS) (LENGTH VALUES))
    (LET (ITEM-VALUES DUPLICATES)
      (LOOP FOR ITEM IN ITEM-LIST
	    DO (LET ((ITEM-VALUE (SEND SELF ':EXECUTE-NO-SIDE-EFFECTS ITEM)))
		 (WHEN (MEMBER ITEM-VALUE VALUES)
		   (IF (MEMBER ITEM-VALUE ITEM-VALUES)
		       (PUSH ITEM-VALUE DUPLICATES)
		       (PUSH ITEM-VALUE ITEM-VALUES)))))
      (LET ((MISSING (LOOP FOR VALUE IN VALUES
			   UNLESS (MEMBER VALUE ITEM-VALUES)
			   COLLECT VALUE)))
	(WHEN (OR MISSING DUPLICATES)
	  (FERROR
   "~@[Values missing from item-list: ~S~]~@[, ~]~@[duplicate values in item-list: ~S~]."
                  MISSING (AND MISSING DUPLICATES) DUPLICATES)))))
  (SEND SELF ':SET-HIGHLIGHTED-ITEMS ITEMS))

(DEFMETHOD (:ADD-HIGHLIGHTED-VALUE MENU-HIGHLIGHTING-MIXIN) (VALUE)
  (DO ((L ITEM-LIST (CDR L)))
      ((NULL L) (FERROR NIL "Value not found"))
    (AND (EQUAL (SEND SELF ':EXECUTE-NO-SIDE-EFFECTS (CAR L)) VALUE)
	 (RETURN (SEND SELF ':ADD-HIGHLIGHTED-ITEM (CAR L))))))

(DEFMETHOD (:REMOVE-HIGHLIGHTED-VALUE MENU-HIGHLIGHTING-MIXIN) (VALUE)
  (DO ((L ITEM-LIST (CDR L)))
      ((NULL L) (FERROR NIL "Value not found"))
    (AND (EQUAL (SEND SELF ':EXECUTE-NO-SIDE-EFFECTS (CAR L)) VALUE)
	 (RETURN (SEND SELF ':REMOVE-HIGHLIGHTED-ITEM (CAR L))))))


;******** This doesn't work because it has to tell the geometry guy to leave enough
;******** width for the margin choices to fit in.  As it stands it actually manages
;******** to draw outside of its assigned area of the screen.
(DEFFLAVOR MENU-MARGIN-CHOICE-MIXIN () (MARGIN-CHOICE-MIXIN BASIC-MENU)
  (:DOCUMENTATION :MIXIN "Puts choice boxes in the bottom margin of a menu.
Clicking on a choice box simulates clicking on a menu item")
  (:INIT-KEYWORDS :MENU-MARGIN-CHOICES))

;An element of :MENU-MARGIN-CHOICES is just like an element of :ITEM-LIST

(DEFUN-IN-FLAVOR (MENU-MARGIN-CHOICE-FROM-ITEM MENU-MARGIN-CHOICE-MIXIN) (X)
  (MULTIPLE-VALUE-BIND (STRING STYLE UNDERSCORE)
      (MENU-ITEM-STRING SELF X)
    (IGNORE UNDERSCORE)
    ;; basic-menu sets default-style to Jess.Roman.Large, so we have
    ;; to set it back here to get normal-looking margin-choices.
    (LET ((MARGIN-STYLE (SI:MERGE-CHARACTER-STYLES STYLE (SHEET-DEFAULT-STYLE (SHEET-SCREEN SELF)))))
      (SETQ STRING
	    (WITH-OUTPUT-TO-STRING (STR)
	      (WITH-CHARACTER-STYLE (MARGIN-STYLE STR)
		(FORMAT STR "~A" STRING)))))
    ;; constructs a margin-choice item of the form
    ;; (item-string on-p function x-pos y-pos menu-item)
    (LIST STRING NIL
	  #'(LAMBDA (WINDOW CHOICE-BOX REGION Y-POS)
	      (IGNORE WINDOW REGION Y-POS)
	      (SETQ CHOSEN-ITEM (SIXTH CHOICE-BOX)))
	  NIL NIL X)))

(DEFMETHOD (:INIT MENU-MARGIN-CHOICE-MIXIN :BEFORE) (INIT-PLIST)
  (LET-GLOBALLY ((CURRENT-FONT NIL))	;MENU-ITEM-STRING looks at this
    (SETQ MARGIN-CHOICES
	  (LOOP FOR ITEM IN (GET INIT-PLIST ':MENU-MARGIN-CHOICES)
		COLLECT (MENU-MARGIN-CHOICE-FROM-ITEM ITEM)))))

(DEFMETHOD (:SET-MENU-MARGIN-CHOICES MENU-MARGIN-CHOICE-MIXIN) (LIST)
  (SEND SELF ':SET-MARGIN-CHOICES (LOOP FOR ITEM IN LIST
					COLLECT (MENU-MARGIN-CHOICE-FROM-ITEM ITEM))))

(DEFFLAVOR MULTIPLE-MENU-MIXIN (SPECIAL-CHOICE-ITEMS) (MENU-HIGHLIGHTING-MIXIN)
  (:INIT-KEYWORDS :SPECIAL-CHOICES)
  (:DEFAULT-INIT-PLIST :SPECIAL-CHOICES '(("Do It"
					   :FUNCALL-WITH-SELF
					   MULTIPLE-MENU-GET-HIGHLIGHTED)))
  (:DOCUMENTATION :MIXIN "A menu in which you can select more than one choice.
 HIGHLIGHTED-ITEMS is a list of those items in the ITEM-LIST that are currently
 selected.  SPECIAL-CHOICES are those items that don't highlight when
 you click on them, but instead are executed in the usual way.  The default
 special choice is just Done, which returns a list of the values of the highlighted
 items.  SPECIAL-CHOICES are displayed in italics at the top of the menu."))

(DEFUN MULTIPLE-MENU-GET-HIGHLIGHTED (MENU)
  (SEND MENU ':HIGHLIGHTED-VALUES))

;Insert the special-choices into the item-list
;Buglet - if n-columns is not specified explicitly, and turns out to be more than 1,
;there will not be automatic blank space inserted to keep the special-choices on
;a separate row.  There is probably nothing wrong with this.
(DEFUN-IN-FLAVOR (MULTIPLE-MENU-HACK-ITEM-LIST MULTIPLE-MENU-MIXIN) (ITM-LST &OPTIONAL N-COLUMNS)
  (SETQ N-COLUMNS (OR N-COLUMNS (CAR GEOMETRY) 1))
  (APPEND SPECIAL-CHOICE-ITEMS
	  (AND N-COLUMNS (> N-COLUMNS 1)
	       (DO ((N (\ (LENGTH SPECIAL-CHOICE-ITEMS) N-COLUMNS) (1+ N))
		    (L NIL (CONS '("" :NO-SELECT NIL) L)))
		   ((OR (ZEROP N) (= N N-COLUMNS)) L)))
	  ITM-LST))

(DEFMETHOD (:INIT MULTIPLE-MENU-MIXIN :BEFORE) (INIT-PLIST)
  (SETQ SPECIAL-CHOICE-ITEMS
	(MAPCAR #'(LAMBDA (X)
		    (APPEND (COND ((ATOM X) (LIST X ':VALUE X))
				  ((ATOM (CDR X)) (LIST (CAR X) ':VALUE (CDR X)))
				  ((NULL (CDDR X)) (LIST (CAR X) ':VALUE (CADR X)))
				  (T X))
			    '(:STYLE (:SWISS :ITALIC :NORMAL) :SPECIAL-CHOICE T)))
		(GET INIT-PLIST ':SPECIAL-CHOICES)))
  (AND (VARIABLE-BOUNDP ITEM-LIST)	;Only if items specified in init-plist
       (SETQ ITEM-LIST (MULTIPLE-MENU-HACK-ITEM-LIST ITEM-LIST (GET INIT-PLIST ':COLUMNS)))))

(DEFMETHOD (:SET-ITEM-LIST MULTIPLE-MENU-MIXIN) (NEW-ITEM-LIST)
  (SEND SELF ':SET-HIGHLIGHTED-ITEMS NIL)
  (SETQ ITEM-LIST (MULTIPLE-MENU-HACK-ITEM-LIST NEW-ITEM-LIST)
	LAST-ITEM NIL
	CURRENT-ITEM NIL)
  (MENU-COMPUTE-GEOMETRY T)		;Recompute parameters, and redraw menu
  ITEM-LIST)

;Modified mouse-button handler.  Does normal thing for special-choices, otherwise
;just complements highlight state.
(DEFWRAPPER (:MOUSE-BUTTONS MULTIPLE-MENU-MIXIN) (IGNORE . BODY)
  `(LET ((ITEM CURRENT-ITEM))
     (COND ((OR (NULL ITEM) ;so margin-choices can work
		(AND (NOT (ATOM ITEM))		;Special-choice selected?
		     (NOT (ATOM (CDR ITEM)))
		     (GET (CDDR ITEM) ':SPECIAL-CHOICE)))
	    . ,BODY)				;Yes, do normal action
	   (T					;Ordinary item, highlight or un-highlight it
	    (SEND SELF (IF (MEMQ ITEM HIGHLIGHTED-ITEMS) ':REMOVE-HIGHLIGHTED-ITEM
			   ':ADD-HIGHLIGHTED-ITEM)
		  ITEM)))))

(DEFFLAVOR MULTIPLE-MENU () (MULTIPLE-MENU-MIXIN MENU))

(DEFFLAVOR MOMENTARY-MULTIPLE-MENU () (MULTIPLE-MENU-MIXIN MOMENTARY-MENU))

(DEFFLAVOR BASIC-MOMENTARY-MENU () (HYSTERETIC-WINDOW-MIXIN BASIC-MENU)
  (:DOCUMENTATION :MIXIN "A menu that holds control of the mouse.
Menus of this type handle the mouse for a small area outside of their
actual edges.  They also are automatically deactivated whenever an item
is chosen or the mouse moves even further, out of its control."))


;;
;; Add a control to momentary menu's deexposure, so mixins
;; can control the behavior.
;;
(DEFMETHOD (AUTO-DEACTIVATE-P BASIC-MOMENTARY-MENU) (&OPTIONAL REASON)
  (IGNORE REASON)
  T)


(DEFWRAPPER (:CHOOSE BASIC-MOMENTARY-MENU) (IGNORE . BODY)
  `(UNWIND-PROTECT-CASE ()
     (CATCH 'ABORT . ,BODY)
     (:ABORT (SEND SELF :DEACTIVATE))))

(DEFMETHOD (:CHOOSE BASIC-MOMENTARY-MENU :BEFORE) ()
  (UNLESS EXPOSED-P
    (LET ((MOUSE (SHEET-MOUSE SELF)))
      (EXPOSE-WINDOW-NEAR SELF '(:MOUSE) T NIL)
      ;; Expose self, and seize the mouse.
      (WITH-THIS-MOUSE-GRABBED (MOUSE)
	(SEND SELF ':EXPOSE)
	(COND ((NEQ SELF (LOWEST-SHEET-UNDER-POINT (MOUSE-SHEET MOUSE)
						   (MOUSE-X MOUSE) (MOUSE-Y MOUSE)
						   NIL ':EXPOSED))
	       (SEND SELF ':DEACTIVATE)
	       (THROW 'ABORT NIL)))))))


(DEFMETHOD (:MAXIMUM-WIDTH BASIC-MOMENTARY-MENU) ()
  (- (SHEET-INSIDE-WIDTH SUPERIOR) LEFT-MARGIN-SIZE RIGHT-MARGIN-SIZE
     (* HYSTERESIS 3)))

;;; When no selection, but mouse moved out of range, deexpose menu
(DEFMETHOD (:HANDLE-MOUSE BASIC-MOMENTARY-MENU :AFTER) ()
  (WHEN (AUTO-DEACTIVATE-P SELF :HANDLE-MOUSE)
    (LET ((MOUSE (SHEET-MOUSE SELF)))
      (OR CHOSEN-ITEM
	  ;; Don't flush if mouse being usurped
	  (WINDOW-OWNING-MOUSE-INTERNAL MOUSE)
	  ;; Only flush us if either not explicitly flushing or we don't own mouse
	  (AND (MOUSE-RECONSIDER MOUSE) (EQ SELF (WINDOW-OWNING-MOUSE NIL NIL MOUSE)))
	  ;; Don't flush if mouse is still geographically within this window
	  ;; It might be in another window that overlaps this one
	  (SHEET-CONTAINS-SHEET-POINT-P SELF (MOUSE-SHEET MOUSE)
					(MOUSE-X MOUSE) (MOUSE-Y MOUSE))
	  ;; This is called in the mouse process.  We don't want to take the chance that
	  ;; we might go blocked, so run in another process.
	  (PROCESS-RUN-FUNCTION '(:NAME "Menu Deactivate" :PRIORITY 20.) SELF ':DEACTIVATE)))))

;;; Make MOUSE-DEFAULT-HANDLER return so menu gets deactivated.
(DEFMETHOD (:MOUSE-BUTTONS BASIC-MOMENTARY-MENU :AFTER) (IGNORE IGNORE IGNORE)
  (AND CHOSEN-ITEM (SETF (MOUSE-RECONSIDER (SHEET-MOUSE SELF)) T)))

(DEFMETHOD (:EXECUTE BASIC-MOMENTARY-MENU :BEFORE) (&REST IGNORE)
  (WHEN (AUTO-DEACTIVATE-P SELF :EXECUTE)
    (SEND SELF ':DEACTIVATE)))

(DEFFLAVOR WINDOW-HACKING-MENU-MIXIN (WINDOW-UNDER-MENU OLD-X OLD-Y) ()
  (:DOCUMENTATION :MIXIN "Menu which handles :WINDOW-OP when called over another window
The window that the menu is exposed over is remembered when the :choose message is sent,
and then used if a :window-op type item is selected."))

(DEFMETHOD (:CHOOSE WINDOW-HACKING-MENU-MIXIN :BEFORE) ()
  (LET ((MOUSE (SHEET-MOUSE SELF)))
    (SETQ OLD-X (MOUSE-X MOUSE)
	  OLD-Y (MOUSE-Y MOUSE)
	  WINDOW-UNDER-MENU (LOWEST-SHEET-UNDER-POINT (MOUSE-SHEET MOUSE) OLD-X OLD-Y))))

(DEFMETHOD (:EXECUTE-WINDOW-OP WINDOW-HACKING-MENU-MIXIN) (FUNCTION)
  (FUNCALL FUNCTION WINDOW-UNDER-MENU OLD-X OLD-Y))

(DEFFLAVOR ABSTRACT-DYNAMIC-ITEM-LIST-MIXIN () ()
  (:REQUIRED-FLAVORS BASIC-MENU)
  (:REQUIRED-METHODS :UPDATE-ITEM-LIST)
  (:DEFAULT-INIT-PLIST :ITEM-LIST NIL)
  (:DOCUMENTATION :MIXIN "Allows the menu to have an item list that's being dynamically
modified.  Causes the menu's item list to be updated at appropriate times.
The actual item list is computed via the :UPDATE-ITEM-LIST message."))

(DEFMETHOD (:CHOOSE ABSTRACT-DYNAMIC-ITEM-LIST-MIXIN :BEFORE) (&REST IGNORE)
  (SEND SELF ':UPDATE-ITEM-LIST))

(DEFMETHOD (:MOVE-NEAR-WINDOW ABSTRACT-DYNAMIC-ITEM-LIST-MIXIN :BEFORE) (&REST IGNORE)
  (SEND SELF ':UPDATE-ITEM-LIST))

(DEFMETHOD (:CENTER-AROUND ABSTRACT-DYNAMIC-ITEM-LIST-MIXIN :BEFORE) (&REST IGNORE)
  (SEND SELF ':UPDATE-ITEM-LIST))

(DEFMETHOD (:SIZE ABSTRACT-DYNAMIC-ITEM-LIST-MIXIN :BEFORE) (&REST IGNORE)
  (SEND SELF ':UPDATE-ITEM-LIST))

(DEFMETHOD (:PANE-SIZE ABSTRACT-DYNAMIC-ITEM-LIST-MIXIN :BEFORE) (&REST IGNORE)
  (SEND SELF ':UPDATE-ITEM-LIST))


(DEFFLAVOR DYNAMIC-ITEM-LIST-MIXIN ((ITEM-LIST-POINTER NIL))
	   (ABSTRACT-DYNAMIC-ITEM-LIST-MIXIN)
  :INITABLE-INSTANCE-VARIABLES
  :SETTABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES
  (:DOCUMENTATION :MIXIN "Allows the menu to have an item list that's being dynamically
modified.  Causes the menu's item list to be updated at appropriate times.
The ITEM-LIST-POINTER instance variable is a form to be evaluated to get the item list."))

(DEFUN-IN-FLAVOR (DYNAMIC-ITEM-LIST DYNAMIC-ITEM-LIST-MIXIN) ()
  (IF (SYMBOLP ITEM-LIST-POINTER)
      (SYMEVAL ITEM-LIST-POINTER)
      (STACK-LET ((ENV `(((SELF ,SELF)))))
	(EVAL ITEM-LIST-POINTER ENV))))

(DEFMETHOD (:INIT DYNAMIC-ITEM-LIST-MIXIN :BEFORE) (IGNORE)
  (AND ITEM-LIST-POINTER
       (SETQ ITEM-LIST (DYNAMIC-ITEM-LIST))))

(DEFMETHOD (:UPDATE-ITEM-LIST DYNAMIC-ITEM-LIST-MIXIN) (&AUX NEW-ITEM-LIST)
  (AND ITEM-LIST-POINTER
       (OR (EQUAL ITEM-LIST (SETQ NEW-ITEM-LIST (DYNAMIC-ITEM-LIST)))
	   (SEND SELF ':SET-ITEM-LIST NEW-ITEM-LIST))))


(DEFFLAVOR DYNAMIC-MULTICOLUMN-MIXIN (COLUMN-SPEC-LIST PREVIOUS-STATE)
	   (ABSTRACT-DYNAMIC-ITEM-LIST-MIXIN)
  (:INITABLE-INSTANCE-VARIABLES COLUMN-SPEC-LIST)
  (:DOCUMENTATION :MIXIN "Makes a menu have multiple 'dynamic' columns.
Each column comes from a separate item-list which is recomputed at appropriate times.
The instance variable COLUMN-SPEC-LIST is a list of columns, each column consists
of (heading item-list-form . options).  Heading is a string to go at the top of the
column, and options are menu-item options for it (typically font).  item-list-form is
a form to be evaluated (without side-effects) to get the item list for that column."))

(DEFMETHOD (:INIT DYNAMIC-MULTICOLUMN-MIXIN :BEFORE) (IGNORE)
  (SETQ PREVIOUS-STATE (MAKE-LIST (LENGTH COLUMN-SPEC-LIST))))

(DEFMETHOD (:UPDATE-ITEM-LIST DYNAMIC-MULTICOLUMN-MIXIN) (&OPTIONAL FORCE)
  (IF (OR FORCE
	  (LOOP FOR (HEADING FORM) IN COLUMN-SPEC-LIST
		AND OLD-ITEM-LIST IN PREVIOUS-STATE
		DO (IGNORE HEADING)
		THEREIS (NEQ (IF (SYMBOLP FORM) (SYMEVAL FORM) (EVAL FORM)) OLD-ITEM-LIST)))
      ;; Something has changed, set up new item list.
      ;; Start by extracting the column lists and setting up the headings.
      (LOOP FOR (HEADING FORM . OPTIONS) IN COLUMN-SPEC-LIST 
	    AND STATEL ON PREVIOUS-STATE	;"for flow"
	    DO (IGNORE STATEL)
	    COLLECT `(,HEADING :NO-SELECT T . ,OPTIONS) INTO NEW-ITEM-LIST
	    COLLECT (IF (SYMBOLP FORM) (SYMEVAL FORM) (EVAL FORM)) INTO COLUMN-LIST
	    FINALLY
	;; Now interleave the columns, and save the old state.
	(SETQ NEW-ITEM-LIST (NREVERSE NEW-ITEM-LIST))
	(LOOP FOR C IN COLUMN-LIST AND L ON PREVIOUS-STATE DO (RPLACA L C))
	(LOOP REPEAT (LOOP FOR C IN COLUMN-LIST MAXIMIZE (LENGTH C))
	      DO (LOOP FOR L ON COLUMN-LIST
		       DO (PUSH (OR (CAAR L) `("" :NO-SELECT T)) NEW-ITEM-LIST)
			  (RPLACA L (CDAR L))))
	(OR (EQ (CAR GEOMETRY) (LENGTH COLUMN-SPEC-LIST))
	    (SEND SELF ':SET-GEOMETRY (LENGTH COLUMN-SPEC-LIST)))
	(SEND SELF ':SET-ITEM-LIST (NREVERSE NEW-ITEM-LIST)))))

(DEFMETHOD (:SET-COLUMN-SPEC-LIST DYNAMIC-MULTICOLUMN-MIXIN) (NEW-COLUMN-SPEC-LIST)
  (SETQ PREVIOUS-STATE (MAKE-LIST (LENGTH NEW-COLUMN-SPEC-LIST)))
  (SETQ COLUMN-SPEC-LIST NEW-COLUMN-SPEC-LIST)
  (SEND SELF ':UPDATE-ITEM-LIST T))

(DEFFLAVOR PROCESS-RENAMING-MENU-MIXIN ((STARTING-PROCESS-NAME NIL)) ()
  (:REQUIRED-FLAVORS BASIC-MENU MENU-EXECUTE-MIXIN)
  :INITABLE-INSTANCE-VARIABLES
  (:DOCUMENTATION :MIXIN
	"Renames the process to the item name before executing the item.
	 STARTING-PROCESS-NAME must be set to the expected name to avoid renaming
	 a /"random/" process."))

(DEFMETHOD (:EXECUTE PROCESS-RENAMING-MENU-MIXIN :BEFORE) (ITEM)
  (AND (LISTP ITEM) (STRINGP (CAR ITEM))
       (EQUAL (PROCESS-NAME CURRENT-PROCESS) STARTING-PROCESS-NAME)
       (SETF (PROCESS-NAME CURRENT-PROCESS) (CAR ITEM))))

;;;
;;; A mixin to make menus respond to the keyboard.
;;;

(DEFFLAVOR REMEMBER-NON-SELECTABLE-ITEMS-MIXIN ((REAL-CURRENT-ITEM NIL))
	   ()
  ;; remembers the item under the mouse, even if it's non-selectable
  :ABSTRACT-FLAVOR
  (:REQUIRED-FLAVORS BASIC-MENU)
  :READABLE-INSTANCE-VARIABLES)

(DEFWHOPPER (COMPUTE-CURRENT-ITEM REMEMBER-NON-SELECTABLE-ITEMS-MIXIN) (&REST ARGS)
  "Cache the value of :compute-current-item in an instance var."
  ;; this conses a bit
  (LET ((VALUES (MULTIPLE-VALUE-LIST (LEXPR-CONTINUE-WHOPPER ARGS))))
    (SETQ REAL-CURRENT-ITEM (CAR VALUES))
    (VALUES-LIST VALUES)))

(DEFCONST *KEYBOARD-SENSITIVE-MENU-DEFAULT-CHAR-ALIST*
	  '((#\ABORT . (#\ABORT :VALUE             NIL))
	    (#\C-N   . (#\C-N   :FUNCALL-WITH-SELF KEYBOARD-SENSITIVE-MENU-WARP-NEXT))
	    (#\C-P   . (#\C-P   :FUNCALL-WITH-SELF KEYBOARD-SENSITIVE-MENU-WARP-PREVIOUS))
	    (#\M-<   . (#\M-<   :FUNCALL-WITH-SELF KEYBOARD-SENSITIVE-MENU-WARP-FIRST))
	    (#\M->   . (#\M->   :FUNCALL-WITH-SELF KEYBOARD-SENSITIVE-MENU-WARP-LAST))
	    (#\SPACE . (#\SPACE :FUNCALL-WITH-SELF KEYBOARD-SENSITIVE-MENU-CLICK-LEFT)))
  ;; multiple-menus, such as subset-choose-menus,
  ;; might want to add #\End, #\Complete, and #\Clear-Input
  "Default characters handled by a subset-choose menu.")

(DEFFLAVOR KEYBOARD-SENSITIVE-MENU-MIXIN
	((CHAR-TO-ITEM-ALIST *KEYBOARD-SENSITIVE-MENU-DEFAULT-CHAR-ALIST*))
	(REMEMBER-NON-SELECTABLE-ITEMS-MIXIN)
  ;; associated with certain characters there are menu-items that get :executed.
  ;; the default is cursor motion and so on.
  :ABSTRACT-FLAVOR
  (:REQUIRED-FLAVORS BASIC-MENU)
  (:WRITABLE-INSTANCE-VARIABLES CHAR-TO-ITEM-ALIST)
  (:READABLE-INSTANCE-VARIABLES CHAR-TO-ITEM-ALIST) 
  (:INITABLE-INSTANCE-VARIABLES CHAR-TO-ITEM-ALIST))

(DEFMETHOD (ADD-CHAR-ITEM KEYBOARD-SENSITIVE-MENU-MIXIN) (CHAR ITEM)
  (LET ((CELL (ASS #'CHAR= CHAR CHAR-TO-ITEM-ALIST)))
    (COND (CELL
	    ;; this char already in use, so bash its cell
	    (RPLACD CELL ITEM))
	  (T
	    ;; not already in use, so push cell onto front
	    (PUSH (CONS CHAR ITEM) CHAR-TO-ITEM-ALIST))))
  ;; return something harmless
  T)

(DEFMETHOD (DELETE-CHAR-ITEM KEYBOARD-SENSITIVE-MENU-MIXIN) (CHAR)
  ;; remove this char-item from the list
  (SETQ CHAR-TO-ITEM-ALIST
	(CL:DELETE-IF #'(LAMBDA (X) (CHAR= (CAR X) CHAR)) CHAR-TO-ITEM-ALIST))
  T)

(DEFMETHOD (:CHOOSE KEYBOARD-SENSITIVE-MENU-MIXIN) (&OPTIONAL (STREAM TERMINAL-IO))
  "Like (:choose basic-menu), but listen to keyboard, too."
  (SETQ TV:CHOSEN-ITEM NIL)
  (UNLESS TV:EXPOSED-P (SEND SELF :EXPOSE))
  (FLET ((REAL-CHAR-AVAILABLE-P (STREAM)
	   ;; Sigh.  We shouldn't have had to write this.  -- sgr & York
	   ;; Returns t if there's a real char available, otherwise nil.  Flushes blips.
	   (LET ((SYS:KBD-INTERCEPTED-CHARACTERS '(#\M-ABORT)))
	     (AND (SEND STREAM :LISTEN)
		  (LET ((INPUT (SEND STREAM :ANY-TYI)))
		    ;; :listen says there's somebody at the door
		    (WHEN (CHARACTERP INPUT)
		      ;; it's a character, so put it back & tell caller
		      (SEND STREAM :UNTYI INPUT)
		      T))))))
    ;; wait for either an item-click or some keyboard action
    (LOOP DOING 
      (CATCH 'KEYBOARD-MENU-CHOOSE-RETRY	;character items throw here to retry
	(PROCESS-WAIT "Keyboard or Menu Choose"
	  #'(LAMBDA ()
	      ;; chose something, or deexposed, or keyboard action
	      (OR TV:CHOSEN-ITEM
		  (NOT TV:EXPOSED-P)
		  (REAL-CHAR-AVAILABLE-P STREAM))))
	;; see what we caught
	(LET ((ITEM TV:CHOSEN-ITEM))
	  (SETQ TV:CHOSEN-ITEM NIL)
	  (COND ((AND (NULL ITEM) (REAL-CHAR-AVAILABLE-P STREAM))
		 ;; keyboard action
		 (LET* ((SYS:KBD-INTERCEPTED-CHARACTERS NIL)
			(CHAR (SEND STREAM :TYI))
			(CHAR-ITEM (CDR (ASS #'CHAR= CHAR CHAR-TO-ITEM-ALIST))))
		   (COND (CHAR-ITEM
			   ;; now have a menu-item corresponding to this char;
			   ;; otherwise try again
			   (LET ((VALUE (SEND SELF :EXECUTE CHAR-ITEM)))
			     ;; if we get this far, the :execute didn't throw
			     (SEND SELF :BURY)
			     (RETURN (VALUES VALUE CHAR-ITEM))))
			 (T
			   ;; no item, so beep
			   (BEEP)))))
		(ITEM
		  ;; mouse-click action
		  (LET ((VALUE (SEND SELF :EXECUTE ITEM)))
		    ;; if we get this far, the :execute didn't throw
		    (SEND SELF :BURY)
		    (RETURN (VALUES VALUE ITEM))))
		(T
		  ;; deexposed or moved off menu or some such
		  (SEND SELF :BURY)
		  (RETURN NIL))))))))

(DEFMETHOD (CLICK-LEFT KEYBOARD-SENSITIVE-MENU-MIXIN) ()
  "Click left on current item."
  ;; this is a separate method so it can be whopped.
  (LET ((MOUSE (TV:SHEET-MOUSE SELF)))
    (SEND SELF :MOUSE-BUTTONS 1. (TV:MOUSE-X MOUSE) (TV:MOUSE-Y MOUSE))))

(DEFUN KEYBOARD-SENSITIVE-MENU-CLICK-LEFT (MENU)
  "Toggle state of this item."
  ;; behave as though a left click occured on the menu item the mouse 
  ;; is currently over.  If it's not over one (or even not over the menu),
  ;; this is a no-op.
  (CLICK-LEFT MENU))

;;; These keyboard-motion things probably don't work properly if there
;;; are items not visible that need scrolling. (Maybe should call
;;; :scroll-to?)  Also, c-P and c-N mean previous and next in item-list,
;;; not up and down -- affected by geometry.

(DEFMETHOD (WARP-TO-ITEM KEYBOARD-SENSITIVE-MENU-MIXIN) (ITEM-SPEC)
  "Warp mouse to be over some item. Item-spec is :first, :last, :previous, :next, or an item."
  ;; item-spec is compared with the tv:item-list using EQ,
  ;; so be sure you get it from the right place!
  ;; DWIMify the item-spec -- turn into an actual item or NIL
  (SELECTQ ITEM-SPEC
    (:FIRST (SETQ ITEM-SPEC (CAR TV:ITEM-LIST)))
    (:LAST  (SETQ ITEM-SPEC (CAR (LAST TV:ITEM-LIST))))
    (:NEXT  (SETQ ITEM-SPEC (SECOND (MEMQ TV:REAL-CURRENT-ITEM TV:ITEM-LIST))))
    (:PREVIOUS
      (LET ((CURRENT-POSITION (FIND-POSITION-IN-LIST TV:REAL-CURRENT-ITEM TV:ITEM-LIST)))
	(SETQ ITEM-SPEC (IF (AND CURRENT-POSITION (> CURRENT-POSITION 0.))
			    (NTH (1- CURRENT-POSITION) TV:ITEM-LIST)
			    NIL))))
    (OTHERWISE NIL)) ;presumably a real item
  (WHEN ITEM-SPEC
    ;; find out where this item is
    (MULTIPLE-VALUE-BIND (ITEM-CENTER-X ITEM-CENTER-Y)
	(SEND SELF :ITEM-CURSORPOS ITEM-SPEC)
      (WHEN (AND ITEM-CENTER-X ITEM-CENTER-Y)
	;; move the mouse to the center of this item
	(SEND SELF :SET-MOUSE-POSITION (+ (TV:SHEET-LEFT-MARGIN-SIZE SELF)
					  ITEM-CENTER-X)
				       (+ (TV:SHEET-TOP-MARGIN-SIZE  SELF)
					  ITEM-CENTER-Y))))))

(DEFUN KEYBOARD-SENSITIVE-MENU-WARP-NEXT (MENU) ;c-N
  "Move mouse down to the next item."
  (WARP-TO-ITEM MENU :NEXT))

(DEFUN KEYBOARD-SENSITIVE-MENU-WARP-PREVIOUS (MENU) ;c-P
  "Move mouse up to previous item."
  (WARP-TO-ITEM MENU :PREVIOUS))

(DEFUN KEYBOARD-SENSITIVE-MENU-WARP-FIRST (MENU) ;m->
  "Move mouse to last item."
  (WARP-TO-ITEM MENU :FIRST))

(DEFUN KEYBOARD-SENSITIVE-MENU-WARP-LAST (MENU) ;m-<
  "Move mouse to first item."
  (WARP-TO-ITEM MENU :LAST))

;;; This is a bit of a kludge.  It is necessary because this method is not
;;; loaded before the COMPILE-FLAVOR-METHODS is done, and therefore the
;;; flavor system assumes that the method has been deleted and recompiles
;;; the combined method.  So we tell it that there is going to be a method,
;;; but the actual code for the method is in FRAME.
(FLAVOR:NOTICE-RUN-TIME-METHOD '(FLAVOR:METHOD :PANE-SIZE BASIC-MENU))

;;; Menus to be used for a momentary choice.
;;; Send a menu of this type a :CHOOSE message to use the menu.
;;; When the user selects an item, or moves the mouse off the menu,
;;; the menu will disappear, and whatever was underneath it will reappear.
;;; It will return the chosen item, or NIL.  If the item is not atomic
;;; and its cadr is non-NIL, the cadr will be called with no arguments.
;;; In this case, if the caddr of the item is also non-nil,
;;; no windows will be re-exposed before the cadr is called.
(DEFFLAVOR MOMENTARY-MENU ((LABEL NIL)) (BASIC-MOMENTARY-MENU TEMPORARY-WINDOW-MIXIN
					 DROP-SHADOW-BORDERS-MIXIN TOP-BOX-LABEL-MIXIN
					 BASIC-SCROLL-BAR MINIMUM-WINDOW)
  (:DOCUMENTATION :COMBINATION "Temporary menu that goes away after item is chosen"))


(DEFFLAVOR MOMENTARY-WINDOW-HACKING-MENU () (WINDOW-HACKING-MENU-MIXIN MOMENTARY-MENU)
  (:DOCUMENTATION :COMBINATION))

(DEFFLAVOR DYNAMIC-MOMENTARY-MENU () (DYNAMIC-ITEM-LIST-MIXIN MOMENTARY-MENU))
(DEFFLAVOR DYNAMIC-MOMENTARY-WINDOW-HACKING-MENU
	()
	(DYNAMIC-ITEM-LIST-MIXIN MOMENTARY-WINDOW-HACKING-MENU))
(DEFFLAVOR DYNAMIC-POP-UP-MENU () (DYNAMIC-ITEM-LIST-MIXIN POP-UP-MENU))
(DEFFLAVOR DYNAMIC-POP-UP-COMMAND-MENU ()
	   (DYNAMIC-ITEM-LIST-MIXIN TEMPORARY-WINDOW-MIXIN COMMAND-MENU))
(DEFFLAVOR DYNAMIC-POP-UP-ABORT-ON-DEEXPOSE-COMMAND-MENU ()
	   (COMMAND-MENU-ABORT-ON-DEEXPOSE-MIXIN DYNAMIC-POP-UP-COMMAND-MENU))
(DEFFLAVOR DYNAMIC-MULTICOLUMN-MOMENTARY-MENU ()
	   (DYNAMIC-MULTICOLUMN-MIXIN MOMENTARY-MENU))
(DEFFLAVOR DYNAMIC-MULTICOLUMN-MOMENTARY-WINDOW-HACKING-MENU ()
	   (WINDOW-HACKING-MENU-MIXIN DYNAMIC-MULTICOLUMN-MOMENTARY-MENU))

(DEFFLAVOR DYNAMIC-MULTICOLUMN-MOMENTARY-WINDOW-HACKING-PROCESS-RENAMING-MENU ()
	   (PROCESS-RENAMING-MENU-MIXIN
	    DYNAMIC-MULTICOLUMN-MOMENTARY-WINDOW-HACKING-MENU))

(DEFUN MENU-CHOOSE (ITEM-LIST &OPTIONAL (LABEL NIL) (NEAR-MODE '(:MOUSE)) DEFAULT-ITEM
					(SUPERIOR (MOUSE-DEFAULT-SUPERIOR)))
  (DECLARE (VALUES CHOICE ITEM))	;Result of executing choice, and the item chosen
  (WHEN (EQ (CAR NEAR-MODE) ':WINDOW)
    (SETQ SUPERIOR (SHEET-SUPERIOR (CADR NEAR-MODE))))
  (USING-RESOURCE (MENU MOMENTARY-MENU SUPERIOR)
    (SEND MENU ':SET-ITEM-LIST ITEM-LIST)
    (SEND MENU ':SET-LABEL LABEL)
    (SEND MENU ':SET-LAST-ITEM DEFAULT-ITEM)
    (EXPOSE-WINDOW-NEAR MENU NEAR-MODE)
    (SAVING-MOUSE-POSITION MENU
      (AND DEFAULT-ITEM (NOT (MEMQ (CAR NEAR-MODE) '(:MOUSE :POINT)))
	   (MULTIPLE-VALUE-BIND (X Y)
	       (SEND MENU ':ITEM-CURSORPOS DEFAULT-ITEM)
	     (AND X Y
		  (SEND MENU ':SET-MOUSE-POSITION (+ X (SHEET-INSIDE-LEFT MENU))
			(+ Y (SHEET-INSIDE-TOP MENU))))))
      (LET ((VALUES (MULTIPLE-VALUE-LIST
		      (SEND MENU ':CHOOSE))))
	(RESTORE-MOUSE-POSITION-IF-NECESSARY (FIRST VALUES))
	(CL:APPLY #'VALUES VALUES)))))
