;;; -*- Mode: LISP;  Package: TV; Base: 8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; WINDOW type flavor
(DEFFLAVOR ESSENTIAL-WINDOW () (SHEET)
  (:INIT-KEYWORDS :EDGES-FROM :MINIMUM-WIDTH :MINIMUM-HEIGHT :ACTIVATE-P :EXPOSE-P
		  :DEFAULT-NAME)
  (:DOCUMENTATION :LOWLEVEL-MIXIN "The flavor that is part of every window
This had better be at the end of your any hierarchy, it should also always
be an :included-flavor of any window mixin just so that instance variables
are declared properly."))

(DEFMETHOD (:MOUSE-SELECT ESSENTIAL-WINDOW :BEFORE) (&REST IGNORE)
  (WITHOUT-INTERRUPTS
    (LET* ((CONSOLE (SHEET-CONSOLE SELF))
	   (SW (WHEN CONSOLE (CONSOLE-SELECTED-WINDOW CONSOLE)))
	   (BUF (AND SW (SEND SW :IO-BUFFER))))
      (WHEN BUF
	(CONSOLE-MOVE-TYPEAHEAD CONSOLE BUF)))))

(DEFMETHOD (:MOUSE-SELECT ESSENTIAL-WINDOW) (&REST ARGS)
  "Form of select used when 'mouseing' windows.  Clears all temp locks that are on the
window, as well as failing if the window is not fully within its superior."
  (SEND SELF ':ACTIVATE)		;Maybe our size has to get adjusted first
  (COND ((SHEET-WITHIN-SHEET-P SELF SUPERIOR)
	 (SHEET-FREE-TEMPORARY-LOCKS SELF)	;Flush all temp windows that cover us
	 (LEXPR-SEND SELF ':SELECT ARGS))))

(DEFVAR *WINDOWS-SHADOWED-FOR-SELECTION* NIL)

;; Consider the case where you are in the Display Debugger debugging some activity <X>
;;  (1) When you're in the Display Debugger, Select <X> should select the original
;;	window.  When in the original window, it should select the Display Debugger.
;;	Ditto for the :Select Activity command.
;;  (2) Function S swaps you back and forth between <X> and the Display Debugger.
;;	[Select] from the system menu is like Function S.
;;  (3) Clicking [Select] on a window in PEEK selects that precise window.
;;  (4) If there is another window of the same type as <X>, the <X> window is exposed,
;;      and you type Select <X>, then you should get the second <X> window, not the
;;	Display Debugger.  (Select <X> Select <X> Select <X> cycles you through X1,
;;	X2, Display Debugger, ...)
(DEFMACRO WITH-WINDOW-SHADOWED-FOR-SELECTION ((SHADOWED-WINDOW SHADOWER &KEY (RESELECT T))
					      &BODY BODY)
  `(LET* ((SHADOWED-ACTIVITY (SEND ,SHADOWED-WINDOW :ALIAS-FOR-SELECTED-WINDOWS))
	  (SHADOW (LIST SHADOWED-ACTIVITY ,SHADOWER)))
     (UNWIND-PROTECT
	 (PROGN
	   (WITHOUT-INTERRUPTS (PUSH SHADOW *WINDOWS-SHADOWED-FOR-SELECTION*))
	   ,@BODY)
       (WITHOUT-INTERRUPTS
	 (SETQ *WINDOWS-SHADOWED-FOR-SELECTION*
	       (DELQ SHADOW *WINDOWS-SHADOWED-FOR-SELECTION*)))
       ;; When we're done, bury the shadowing window so that the original
       ;; one ends up exposed again
       (DELAYING-SCREEN-MANAGEMENT
	 (WHEN ,RESELECT (SEND SHADOWED-ACTIVITY :SELECT))
	 (SEND ,SHADOWER :BURY)))))

;; Like :MOUSE-SELECT, except that it obeys *WINDOWS-SHADOWED-FOR-SELECTION*
(DEFMETHOD (:SELECT-SHADOWED-ACTIVITY ESSENTIAL-WINDOW) (PREVIOUS-ACTIVITY &REST ARGS)
  (LET ((SHADOW (ASSQ (SEND SELF :ALIAS-FOR-SELECTED-WINDOWS)
		      *WINDOWS-SHADOWED-FOR-SELECTION*)))
    (IF (AND PREVIOUS-ACTIVITY
	     (EQ (SECOND SHADOW) PREVIOUS-ACTIVITY))
	;; If we are trying to select the shadower, but are already in it, go
	;; back to the shadowee.  That is, Select <X> while in the Display Debugger
	;; debugging <X> will select <X>, not the Display Debugger.
	(LEXPR-SEND SELF :MOUSE-SELECT ARGS)
      ;; Here we are in another activity trying to select <X>.  Either select
      ;; <X>'s shadow, or <X> itself.
      (LEXPR-SEND (OR (SECOND SHADOW) SELF) :MOUSE-SELECT ARGS))))

(DEFMETHOD (:LISP-LISTENER-P ESSENTIAL-WINDOW) () NIL)

(DEFMETHOD (:INTERACTOR-P ESSENTIAL-WINDOW) () NIL)

(DEFMETHOD (:INIT ESSENTIAL-WINDOW :BEFORE) (INIT-PLIST &AUX EDGES-FROM)

  ;; If no name is explicitly given, then look for a :DEFAULT-NAME property
  ;; in the INIT-PLIST.  If that doesn't exist, then construct a default name from
  ;; the name of the flavor and cache it.
  (OR NAME
      (LET* ((WINDOW-FLAVOR (TYPEP SELF))
	     (WINDOW-NAME (OR (GET INIT-PLIST ':DEFAULT-NAME)
			      (GET WINDOW-FLAVOR 'UNNAMED-WINDOW-DEFAULT-NAME)))
	     (N (1+ (OR (GET WINDOW-FLAVOR 'UNNAMED-WINDOW-INSTANCE-COUNT) 0))))
	(COND ((NOT WINDOW-NAME)
	       (SETQ WINDOW-NAME (STRING-CAPITALIZE-WORDS WINDOW-FLAVOR))
	       (PUTPROP WINDOW-FLAVOR WINDOW-NAME 'UNNAMED-WINDOW-DEFAULT-NAME)))
	(PUTPROP WINDOW-FLAVOR N 'UNNAMED-WINDOW-INSTANCE-COUNT)
	(SETQ NAME (FORMAT NIL "~A ~D" WINDOW-NAME N))))

  (SETQ EDGES-FROM (GET INIT-PLIST ':EDGES-FROM))
  (COND ((NULL EDGES-FROM))
	((STRINGP EDGES-FROM)
	 (PUTPROP INIT-PLIST EDGES-FROM ':CHARACTER-WIDTH)
	 (PUTPROP INIT-PLIST EDGES-FROM ':CHARACTER-HEIGHT))
	(T
	 (PUTPROP INIT-PLIST
		  (COND ((LISTP EDGES-FROM)
			 ;; If a list, means explicit edges specified
			 EDGES-FROM)
			((EQ EDGES-FROM ':MOUSE)
			 ;; Get edges from mouse
			 (LET ((MINIMUM-WIDTH (OR (GET INIT-PLIST ':MINIMUM-WIDTH) 0))
			       (MINIMUM-HEIGHT (OR (GET INIT-PLIST ':MINIMUM-HEIGHT) 0)))
			   (MULTIPLE-VALUE-LIST
			     (MOUSE-SPECIFY-RECTANGLE-SET-SHEET NIL NIL NIL NIL SUPERIOR
								MINIMUM-WIDTH
								MINIMUM-HEIGHT))))
			((TYPEP EDGES-FROM 'ESSENTIAL-WINDOW)
			 ;; A window, use it's edges
			 (OR (EQ SUPERIOR (SHEET-SUPERIOR EDGES-FROM))
			     (FERROR "Attempt to get edges from sheet (~S) with different superior"
				     EDGES-FROM))
			 (LIST (SHEET-X EDGES-FROM)
			       (SHEET-Y EDGES-FROM)
			       (+ (SHEET-X EDGES-FROM) (SHEET-WIDTH EDGES-FROM))
			       (+ (SHEET-Y EDGES-FROM) (SHEET-HEIGHT EDGES-FROM))))
			(T (FERROR "~S is illegal :EDGES-FROM specification" EDGES-FROM)))
		  ':EDGES)))
  (LET ((INSIDE-WIDTH (OR (GET INIT-PLIST ':INSIDE-WIDTH)
			  (FIRST (GET INIT-PLIST ':INSIDE-SIZE))))
	(INSIDE-HEIGHT (OR (GET INIT-PLIST ':INSIDE-HEIGHT)
			   (SECOND (GET INIT-PLIST ':INSIDE-SIZE)))))
    (AND INSIDE-WIDTH (SETQ WIDTH (+ INSIDE-WIDTH LEFT-MARGIN-SIZE RIGHT-MARGIN-SIZE)))
    (AND INSIDE-HEIGHT (SETQ HEIGHT (+ INSIDE-HEIGHT TOP-MARGIN-SIZE BOTTOM-MARGIN-SIZE)))))

(DEFFLAVOR MINIMUM-WINDOW () (ESSENTIAL-EXPOSE ESSENTIAL-ACTIVATE ESSENTIAL-SET-EDGES
			      ESSENTIAL-MOUSE ESSENTIAL-WINDOW)
  (:DOCUMENTATION :COMBINATION "Essential flavors for most normal windows
Most windows should include this at the end of their hierachy or all of its components."))

(DEFFLAVOR WINDOW-WITHOUT-LABEL () (STREAM-MIXIN BORDERS-MIXIN SELECT-MIXIN
				    GRAPHICS-MIXIN MINIMUM-WINDOW))

;; I just copied WINDOW leaving out its margin mixins. --RLB
(DEFFLAVOR MARGINLESS-WINDOW () (STREAM-MIXIN SELECT-MIXIN GRAPHICS-MIXIN MINIMUM-WINDOW)
  ;; Relax the constraints that would normally be implied by the above list of
  ;; components, so that flavors built on top of WINDOW can rearrange things.
  (:COMPONENT-ORDER ;; For esthetics, I guess, force WINDOW to precede MINIMUM-WINDOW
		    (WINDOW MINIMUM-WINDOW))
  (:DOCUMENTATION :COMBINATION "This window has no borders, margins, label, etc.
It needs mixins to supply those."))

(DEFFLAVOR WINDOW () (STREAM-MIXIN BORDERS-MIXIN LABEL-MIXIN SELECT-MIXIN
		      GRAPHICS-MIXIN MINIMUM-WINDOW)
  ;; The component flavors already come with almost all necessary constraints.
  ;; Relax the constraints that would normally be implied by the above list of
  ;; components, so that flavors built on top of WINDOW can rearrange things.
  (:COMPONENT-ORDER ;; Put the label inside the border.
		    (BORDERS-MIXIN LABEL-MIXIN)
		    ;; For esthetics, I guess, force WINDOW to precede MINIMUM-WINDOW
		    (WINDOW MINIMUM-WINDOW))
  (:DOCUMENTATION :COMBINATION "This is the simplest practical window
It probably isn't what you want, except for testing purposes; although it is useful for
mixing with one or two simple mixins to get something useful."))

;;; Like WINDOW, but with new borders and label
(DEFFLAVOR WINDOW-WITH-MARGIN-MIXIN () (STREAM-MIXIN DW:MARGIN-MIXIN SELECT-MIXIN
					GRAPHICS-MIXIN MINIMUM-WINDOW))

;;; Basic exposure/deexposure
(DEFFLAVOR ESSENTIAL-EXPOSE () (ESSENTIAL-WINDOW)
  (:DOCUMENTATION :ESSENTIAL-MIXIN "Handles default exposure behaviour.
Makes sure the screen manager is aware of a window leaving or entering the screen."))

(DEFMETHOD (:EXPOSE ESSENTIAL-EXPOSE :AFTER) (&REST IGNORE)
  (SCREEN-CONFIGURATION-HAS-CHANGED SELF ':EXPOSE))

(DEFMETHOD (:DEEXPOSE ESSENTIAL-EXPOSE :AFTER) (&REST IGNORE)
  ;;--- An optimization is trying to happen here, but can't ---
  ;; It seems like you could say (UNLESS (SHEET-TEMPORARY-P) here
  ;; since the temporary window should have already fixed the screen without any
  ;; need to go through the full overhead of the screen manager.
  ;; There are two reasons why it isn't so:
  ;; (1) It is possible for the screen under a temporary window to change; not everything
  ;;     is locked.  A partially visible deexposed window can move, a window can be
  ;;     be activated and start to show through, or a window could change its priority.
  ;;     The part of the screen around the temporary window will be updated by the
  ;;     screen manager, but the temporary window's saved copy of the screen under it is not
  ;;     updated, so when those bits come back wrong a screen manage is needed to fix them.
  ;; (2) Some windows, such as the pop-up notification window, rely on the screen
  ;;     manager's autoselection to reselect the right window when they pop down.
  (SCREEN-CONFIGURATION-HAS-CHANGED SELF ':DEEXPOSE))

(DEFWHOPPER (:BURY ESSENTIAL-EXPOSE) ()
  (DELAYING-SCREEN-MANAGEMENT
    (CONTINUE-WHOPPER)))

;;; Basic activation/deactivation
(DEFFLAVOR ESSENTIAL-ACTIVATE () (ESSENTIAL-WINDOW)
  (:DOCUMENTATION :ESSENTIAL-MIXIN "Handles default activation behaviour
Makes sure a window is activated before it can get exposed (see discussion of activation).
Also provides for the :STATUS and :SET-STATUS messages (q.v.)."))


;; [ddyer 10/7/89]
;; Remove a WITHOUT-SCREEN-MANAGEMENT.  Shouldn't be necessary because
;; we are already in a DELAYING-SCREEN-MANAGEMENT from SHEET :WHOPPER :EXPOSE
;; Is undesirable because any screen management activity that happens
;; as an explicit result of the activation will be forgotten.
;;
;; An obscure case where without-screen-management code did the right thing,
;; involved killing one of several overlapping windows in a frame.
;; The WITHOUT-SCREEN-MANAGEMENT inhibited the screen manager from issuing
;; an EXPOSE to the killed window.   The screen manager's behavior in this
;; case is clearly bogus, but we now avoid it a different way, by inhibiting
;; screen managemet around the entire kill operation
;;
(DEFMETHOD (:EXPOSE ESSENTIAL-ACTIVATE :BEFORE) (&REST IGNORE)
  (SEND SELF ':ACTIVATE))


(DEFMETHOD (:ACTIVATE ESSENTIAL-ACTIVATE :AFTER) ()
  (SCREEN-ACTIVITY-HAS-CHANGED SELF T))

(DEFMETHOD (:DEACTIVATE ESSENTIAL-ACTIVATE :AFTER) ()
  (SCREEN-ACTIVITY-HAS-CHANGED SELF NIL))

(DEFMETHOD (:BURY ESSENTIAL-ACTIVATE) ()
  ;; Buries a window -- gives it the lowest priority in its priority class by
  ;; putting it on the end of active windows.
  (WHEN (MEMQ SELF (SHEET-EXPOSED-INFERIORS SUPERIOR))
    (SEND SELF :DEEXPOSE))
  (WHEN (MEMQ SELF (SHEET-INFERIORS SUPERIOR))
    (SCREEN-CONFIGURATION-HAS-CHANGED SELF ':BURY)))

(DEFMETHOD (:STATUS ESSENTIAL-ACTIVATE) ()
  (COND ((SHEET-SELECTED-P SELF)
	 :SELECTED)
	((DO ((WINDOW SELF (SHEET-SUPERIOR WINDOW)))
	     ((NULL WINDOW) T)
	   (OR (SHEET-EXPOSED-P WINDOW) (RETURN NIL)))
	 :EXPOSED)				;Only if really on screen
	((AND SUPERIOR (MEMQ SELF (SHEET-EXPOSED-INFERIORS SUPERIOR)))
	 :EXPOSED-IN-SUPERIOR)			;Would be exposed if superior was
	((OR (NULL SUPERIOR) (MEMQ SELF (SHEET-INFERIORS SUPERIOR)))
	 :DEEXPOSED)
	(T
	 :DEACTIVATED)))

(DEFMETHOD (:SET-STATUS ESSENTIAL-ACTIVATE) (NEW-STATUS)
  (SELECTQ NEW-STATUS
    (:SELECTED (SEND SELF ':SELECT))
    (:EXPOSED
     (WHEN SUPERIOR
       (IF (OPERATION-HANDLED-P SUPERIOR :SET-STATUS)
	   (WHEN (ZEROP (SHEET-ALL-EXPOSED SUPERIOR))
	     (SEND SUPERIOR :SET-STATUS :EXPOSED))
	   (SEND SUPERIOR :EXPOSE)))		;Could be a screen
     (SEND SELF ':EXPOSE)
     (WHEN (SHEET-SELECTED-P SELF)
       (SEND SELF ':DESELECT NIL)))		;Don't restore-selected!
    (:EXPOSED-IN-SUPERIOR
     (UNLESS (MEMQ SELF (SHEET-EXPOSED-INFERIORS SUPERIOR))
       (SEND SELF ':EXPOSE))
     (WHEN (SHEET-SELECTED-P SELF)
       (SEND SELF ':DESELECT NIL)))		;Don't restore-selected!
    (:DEEXPOSED
     (UNLESS (MEMQ SELF (SHEET-INFERIORS SUPERIOR))
       (SEND SELF ':ACTIVATE))
     (WHEN (MEMQ SELF (SHEET-EXPOSED-INFERIORS SUPERIOR))
       (SEND SELF ':DEEXPOSE)))
    (:DEACTIVATED
     (WHEN (MEMQ SELF (SHEET-INFERIORS SUPERIOR))
       (SEND SELF ':DEACTIVATE)))
    (OTHERWISE
     (FERROR "~S not one of :DEACTIVATED, :DEEXPOSED, :EXPOSED, :SELECTED"
	     NEW-STATUS))))

(DEFUN SET-SHEET-STATUS-AT-LEAST (SHEET NEW-STATUS)
  (SELECTQ NEW-STATUS
    (:SELECTED (SEND SHEET :SELECT))
    ((:EXPOSED :EXPOSED-IN-SUPERIOR) (SEND SHEET :EXPOSE))
    (:DEEXPOSED (SEND SHEET :ACTIVATE))))
;;;

(DEFVAR *SELECTED-PROCESS* ())

(DEFVAR *SELECTED-PROCESS-QUANTUM-BOOST-FACTOR* 3
  "A number between 1 and 20, to be multiplied by the base quantum when a
process's window is selected.")

(DEFUN PROCESS-IS-NOT-SELECTED (PROCESS)
  (WITHOUT-INTERRUPTS
    (WHEN *SELECTED-PROCESS*
      (WHEN (EQ *SELECTED-PROCESS* PROCESS)
	(SI:SET-QUANTUM-INTERNAL PROCESS (SI:PROCESS-BASE-QUANTUM PROCESS))
	(SETQ *SELECTED-PROCESS* NIL))))
  NIL)

(DEFUN PROCESS-IS-SELECTED (PROCESS)
  (WITHOUT-INTERRUPTS
    (WHEN *SELECTED-PROCESS*
      (UNLESS (EQ PROCESS *SELECTED-PROCESS*)	;If we're about to up it again, don't lower it
	(SI:SET-QUANTUM-INTERNAL *SELECTED-PROCESS*
				 (SI:PROCESS-BASE-QUANTUM *SELECTED-PROCESS*))
	(SETQ *SELECTED-PROCESS* NIL)))
    (WHEN PROCESS
      (SETQ *SELECTED-PROCESS* PROCESS)
      (UNLESS (CL:TYPEP *SELECTED-PROCESS-QUANTUM-BOOST-FACTOR* '(CL:INTEGER 1 20))
	(SETQ *SELECTED-PROCESS-QUANTUM-BOOST-FACTOR* 3))
      (SI:SET-QUANTUM-INTERNAL PROCESS
			       (MIN 60.		;Don't get too extreme!
				    (MAX (SI:PROCESS-QUANTUM PROCESS)
					 (* *SELECTED-PROCESS-QUANTUM-BOOST-FACTOR*
					    (SI:PROCESS-BASE-QUANTUM PROCESS)))))
      ;; Selection counts as an explicit command.
      (SETF (SI:PROCESS-QUANTUM-REMAINING PROCESS)
	    (MAX (SI:PROCESS-QUANTUM-REMAINING PROCESS)
		 (SI:PROCESS-QUANTUM PROCESS)
		 SI:*PROCESS-COMMAND-INITIAL-QUANTUM*))))
  NIL)

;;;

;;; Basic selection/deselection
(DEFFLAVOR SELECT-MIXIN () (ESSENTIAL-WINDOW)
  :GETTABLE-INSTANCE-VARIABLES
  :SETTABLE-INSTANCE-VARIABLES
  (:REQUIRED-INSTANCE-VARIABLES IO-BUFFER)
  (:REQUIRED-METHODS :IO-BUFFER)
  (:DOCUMENTATION :MIXIN "Default SELECTion behaviour
Provides a :NAME-FOR-SELECTION message that gives the window's label or name.
Note that any window that can be selected is expected to handle this message,
and should probably include this flavor somewhere."))

(DEFMETHOD (:NAME-FOR-SELECTION SELECT-MIXIN) (&AUX LABEL)
  (OR (COND ((GET-HANDLER-FOR SELF ':LABEL)
	     (SETQ LABEL (SEND SELF ':LABEL))
	     (WHEN (LISTP LABEL) (SETQ LABEL (LABEL-STRING LABEL)))
	     (AND (STRING-SEARCH-NOT-CHAR #\SP LABEL) LABEL)))
      NAME))

(DEFMETHOD (:DEACTIVATE SELECT-MIXIN :AFTER) (&REST IGNORE)
  (WITHOUT-INTERRUPTS
    (SETQ BACKGROUND-INTERESTING-WINDOWS (DELQ SELF BACKGROUND-INTERESTING-WINDOWS)))
  (REMOVE-FROM-PREVIOUSLY-SELECTED-WINDOWS SELF T))

;;; This could simply do (ADD-TO-PREVIOUSLY-SELECTED-WINDOWS SELF T) except
;;; this method gets run whether or not the window was already active when
;;; the :ACTIVATE message was sent.  What a drag.
;;; If process not otherwise known, default to process which is activating
;;; the window which will usually be good enough for the who-line.
(DEFMETHOD (:ACTIVATE SELECT-MIXIN :AFTER) (&REST IGNORE)
  (UNLESS (IO-BUFFER-LAST-OUTPUT-PROCESS IO-BUFFER)
    (SETF (IO-BUFFER-LAST-OUTPUT-PROCESS IO-BUFFER) CURRENT-PROCESS))
  (LET ((W (SEND SELF :ALIAS-FOR-SELECTED-WINDOWS)))
    ;; Can be activating a pane relative to a frame which is not itself activated
    (WHEN (NOT (DO ((SUP (SHEET-SUPERIOR W) (SHEET-SUPERIOR SUP))
		    (INF W SUP))
		   ((NULL SUP) NIL)
		 (UNLESS (MEMQ INF (SHEET-INFERIORS SUP))
		   (RETURN T))))
      (ADD-TO-PREVIOUSLY-SELECTED-WINDOWS W T T))))

(DEFMETHOD (:PROCESS SELECT-MIXIN) ()
  (IO-BUFFER-LAST-OUTPUT-PROCESS IO-BUFFER))

(DEFMETHOD (:SET-PROCESS SELECT-MIXIN) (PROC)
  (SETF (IO-BUFFER-LAST-OUTPUT-PROCESS IO-BUFFER) PROC))

(DEFMETHOD (:ARREST SELECT-MIXIN) (&AUX LAST-PROCESS)
  (AND (SETQ LAST-PROCESS (SEND SELF ':PROCESS))
       (SEND LAST-PROCESS ':ARREST-REASON)))

(DEFMETHOD (:UN-ARREST SELECT-MIXIN) (&AUX LAST-PROCESS)
  (AND (SETQ LAST-PROCESS (SEND SELF ':PROCESS))
       (SEND LAST-PROCESS ':REVOKE-ARREST-REASON)))

(DEFMETHOD (:RESET-PROCESS SELECT-MIXIN) (&AUX LAST-PROCESS)
  (AND (SETQ LAST-PROCESS (SEND SELF ':PROCESS))
       (SEND LAST-PROCESS ':RESET)))

;;;

;;; These are defined on sheet, rather than select-mixin, because frames
;;; can be selected (passing on to their selected pane).

(DEFUN SHEET-CONSOLE (SHEET)
  (OR (SEND (SHEET-SCREEN SHEET) :CONSOLE)
      SYS:*CONSOLE*))

(DEFUN SHEET-SELECTED-WINDOW (SHEET)
  (LET ((CONSOLE (SHEET-CONSOLE SHEET)))
    (AND CONSOLE (CONSOLE-SELECTED-WINDOW CONSOLE))))

(DEFUN (CL:SETF SHEET-SELECTED-WINDOW) (SHEET NEW-SELECTED-WINDOW)
  (LET ((CONSOLE (SHEET-CONSOLE SHEET)))
    (WHEN CONSOLE
      (SETF (CONSOLE-SELECTED-WINDOW CONSOLE) NEW-SELECTED-WINDOW))))

(DEFUN SHEET-SELECTED-P (SHEET)
  (EQ (SHEET-SELECTED-WINDOW SHEET) SHEET))

(DEFUN ACTIVITY-SELECTED-P (SHEET)
  (LET* ((WINDOW (SEND SHEET :ALIAS-FOR-SELECTED-WINDOWS))
	 (SW (SHEET-SELECTED-WINDOW WINDOW)))
    (AND SW (EQ WINDOW (SEND SW :ALIAS-FOR-SELECTED-WINDOWS)))))

;;; 

(DEFMETHOD (:SELECT SELECT-MIXIN) (&OPTIONAL IGNORE)
  ;; Select a window.  Make its blinkers blink.
  (WITHOUT-INTERRUPTS
    (DO () ((MEMQ SELF (SHEET-EXPOSED-INFERIORS SUPERIOR)))
      (SETQ INHIBIT-SCHEDULING-FLAG NIL)
      (SEND SELF :EXPOSE T)
      (SETQ INHIBIT-SCHEDULING-FLAG T))
    (LET ((OSW (SHEET-SELECTED-WINDOW SELF)))
      (UNLESS (EQ OSW SELF)
	(WHEN OSW (SEND OSW :DESELECT NIL))
	(SELECT-SHEET-BLINKERS SELF)
	(SETF (SHEET-SELECTED-WINDOW SELF) SELF)))
    (SETQ BACKGROUND-INTERESTING-WINDOWS (DELQ SELF BACKGROUND-INTERESTING-WINDOWS)))
  (REMOVE-FROM-PREVIOUSLY-SELECTED-WINDOWS SELF)
  T)						;For frames and :MOUSE-SELECT


(DEFMETHOD (:DESELECT SELECT-MIXIN) (&OPTIONAL (RESTORE-SELECTED T))
  ;; Deselect a window.  Make its blinkers stay on or off as specified.
  (WHEN (EQ SELF (SHEET-SELECTED-WINDOW SELF))
    (DESELECT-SHEET-BLINKERS SELF)
    (SETF (SHEET-SELECTED-WINDOW SELF) NIL)
    (COND ((EQ RESTORE-SELECTED T)
	   (ADD-TO-PREVIOUSLY-SELECTED-WINDOWS SELF T)
	   (LET* ((CONSOLE (SHEET-CONSOLE SELF)))
	     (WHEN CONSOLE
	       (LET ((PSW (CONSOLE-PREVIOUSLY-SELECTED-WINDOWS CONSOLE)))
		 (WHEN (> (FILL-POINTER PSW) 0)
		   (LET ((W (AREF PSW 0)))
		     (SHEET-FREE-TEMPORARY-LOCKS W)
		     (SEND W :SELECT)))))))
	  (T
	   (ADD-TO-PREVIOUSLY-SELECTED-WINDOWS SELF (EQ RESTORE-SELECTED :BURY))))))

(DEFWHOPPER (:SELECT SELECT-MIXIN) (&REST ARGS)
  (DELAYING-SCREEN-MANAGEMENT
    (LEXPR-CONTINUE-WHOPPER ARGS)))

(DEFWHOPPER (:DESELECT SELECT-MIXIN) (&REST ARGS)
  (DELAYING-SCREEN-MANAGEMENT
    (LEXPR-CONTINUE-WHOPPER ARGS)))

(DEFMETHOD (:SELECT SELECT-MIXIN :BEFORE) (&OPTIONAL (SAVE-SELECTED T))
  (LET ((OSW (SHEET-SELECTED-WINDOW SELF)))
    (UNLESS EXPOSED-P (SEND SELF :EXPOSE T))
    (DO ((SHEET SUPERIOR (SHEET-SUPERIOR SHEET)))
	((NULL SHEET))				;Really onto the screen
      (UNLESS (SHEET-EXPOSED-P SHEET) (SEND SHEET :EXPOSE)))
    (SEND SCREEN :SEND-IF-HANDLES :SCREEN-SELECT SAVE-SELECTED)
    (WITHOUT-INTERRUPTS
      (WHEN (AND OSW SAVE-SELECTED (NOT (EQ SELF OSW))
		 (NOT (EQ (SEND OSW :STATUS) :DEACTIVATED)))	;Deexposing can deactivate
	(ADD-TO-PREVIOUSLY-SELECTED-WINDOWS OSW)))))

(DEFMETHOD (:SELECT SELECT-MIXIN :AFTER) (&OPTIONAL IGNORE)
  (LET ((P (SEND SELF :PROCESS)))
    (WHEN P
      (PROCESS-IS-SELECTED P)))
  NIL)

(DEFMETHOD (:DESELECT SELECT-MIXIN :AFTER) (&OPTIONAL IGNORE)
  (LET ((P (SEND SELF :PROCESS)))
    (WHEN P
      (PROCESS-IS-NOT-SELECTED P)))
  NIL)

(DEFMETHOD (:DEEXPOSE SELECT-MIXIN :BEFORE) (&REST IGNORE)
  (SEND SELF ':DESELECT NIL))

(DEFMETHOD (:BURY SELECT-MIXIN :BEFORE) ()
  (SEND SELF ':DESELECT ':BURY))

;;; Select a window relative to its activity, but don't select a different activity.
;;; Since we don't actually have activities now, we have to fake it:
;;;   Two windows are in the same activity if their :alias-for-selected-windows is the same.
;;;   If there is no selected window, a transitory state that often occurs, we
;;;	assume that any window whose top-level superior is exposed must belong
;;;	to the selected activity--this is necessary to make Zmacs work.
;;;   Use the :INFERIOR-SELECT message to change the selected window within an
;;;	unselected activity--this works for enough cases to be worthwhile.
;;;   Hope that nobody changes anything while we're in the middle of this method,
;;;	since there is no activity lock.
(DEFMETHOD (:SELECT-RELATIVE SELECT-MIXIN) ()
  (LET ((SW (SHEET-SELECTED-WINDOW SELF)))
    (IF (IF SW
	    ;; Same activity as the selected window?
	    (EQ (SEND SW :ALIAS-FOR-SELECTED-WINDOWS)
		(SEND SELF :ALIAS-FOR-SELECTED-WINDOWS))
	    ;; No selected window, is our top-level superior exposed?	
	    (SHEET-EXPOSED-P (LOOP FOR INF = SELF THEN SUP
				   AS SUP = (SHEET-SUPERIOR INF)
				   UNTIL (NULL (SHEET-SUPERIOR SUP))
				   FINALLY (RETURN INF))))
	;; We are in the selected activity, it's okay to select
	(SEND SELF :SELECT)
	;; We are not in the selected activity, just remember to become selected
	;; when our superior becomes selected
	(SEND SUPERIOR :INFERIOR-SELECT SELF))))

(DEFFLAVOR SELECT-RELATIVE-MIXIN () (SHEET)
  (:DOCUMENTATION :MIXIN
   "Make a window part of the same /"activity/" as its superior, unless the superior is
a screen, in which case this window is its own /"activity/"."))

(DEFMETHOD (:ALIAS-FOR-SELECTED-WINDOWS SELECT-RELATIVE-MIXIN) ()
  (IF (TYPEP SUPERIOR 'SCREEN)
      SELF
      (SEND SUPERIOR :ALIAS-FOR-SELECTED-WINDOWS)))

(DEFMETHOD (:SELECT SELECT-RELATIVE-MIXIN :BEFORE) (&OPTIONAL IGNORE)
  (SEND SUPERIOR :INFERIOR-SELECT SELF))


(DEFFLAVOR DONT-SELECT-WITH-MOUSE-MIXIN () (ESSENTIAL-WINDOW)
  ;; If TV:SELECT-MIXIN is present, we must override its :NAME-FOR-SELECTION method
  (:COMPONENT-ORDER (TV:DONT-SELECT-WITH-MOUSE-MIXIN TV:SELECT-MIXIN TV:ESSENTIAL-WINDOW))
  (:DOCUMENTATION :MIXIN "Don't allow selection via the mouse and similar ways
Include this for windows that may be selected internally by a program, but which
will not work if just randomly selected, e.g. they do not have their own process.
They will then not show up in the Select system menu, or be gettable to in other
similar ways."))

(DEFMETHOD (:NAME-FOR-SELECTION DONT-SELECT-WITH-MOUSE-MIXIN) () NIL)


;;; Stuff for remembering a "ring buffer" of recently-selected windows
;;; This is an array with fill-pointer whose 0'th element is the most
;;; recently selected window.  Successive elements are windows that were
;;; selected before that.  A window may only appear once in this array.
;;; The selected-window does not appear at all, nor do deactivated
;;; windows.

#||	;Defined in the console
(DEFVAR PREVIOUSLY-SELECTED-WINDOWS
	(MAKE-ARRAY 20. :FILL-POINTER 0 :AREA PERMANENT-STORAGE-AREA))
||#


(DEFUN ADD-TO-PREVIOUSLY-SELECTED-WINDOWS (WINDOW &OPTIONAL AT-END ONLY-IF-NECESSARY)
  (WITHOUT-INTERRUPTS
    (SETQ WINDOW (SEND WINDOW :ALIAS-FOR-SELECTED-WINDOWS))
    (WHEN (AND (NOT (NULL WINDOW))
	       (NOT (NULL (SEND WINDOW :NAME-FOR-SELECTION)))
	       (NOT (EQ WINDOW (SHEET-SELECTED-WINDOW WINDOW))))
      (LET* ((CONSOLE (SHEET-CONSOLE WINDOW)))
	(WHEN CONSOLE
	  (LET* ((PSW (CONSOLE-PREVIOUSLY-SELECTED-WINDOWS CONSOLE))
		 (FP (FILL-POINTER PSW))
		 (OLD (CL:POSITION WINDOW PSW)))
	    ;; Make sure that the screen's windows have been added here.
	    (WHEN (AND (NULL OLD)
		       (SEND (SHEET-SCREEN WINDOW) :RESTORE-PREVIOUSLY-SELECTED-WINDOWS))
	      (SETF FP (FILL-POINTER PSW))
	      (SETF OLD (CL:POSITION WINDOW PSW)))
	    (WHEN (NULL OLD)
	      (WHEN (= FP (CL:ARRAY-TOTAL-SIZE PSW))
		(SETF PSW (CL:ADJUST-ARRAY PSW (+ FP 10))))
	      (SETF OLD FP)
	      (CL:VECTOR-PUSH WINDOW PSW)
	      (INCF FP)
	      (SETF ONLY-IF-NECESSARY NIL))
	    (UNLESS ONLY-IF-NECESSARY
	      (COND (AT-END
		     (UNLESS (= OLD (1- FP))
		       (CL:REPLACE PSW PSW :START1 OLD :START2 (1+ OLD))
		       (SETF (AREF PSW (1- FP)) WINDOW)))
		    (T
		     (UNLESS (ZEROP OLD)
		       (CL:REPLACE PSW PSW :START1 1 :END2 OLD)
		       (SETF (AREF PSW 0) WINDOW))))))))))
  NIL)

(DEFUN REMOVE-FROM-PREVIOUSLY-SELECTED-WINDOWS (WINDOW &OPTIONAL NO-ALIAS)
  (WITHOUT-INTERRUPTS
    (UNLESS NO-ALIAS
      (SETQ WINDOW (SEND WINDOW :ALIAS-FOR-SELECTED-WINDOWS)))
    (WHEN WINDOW
      (REMOVE-FROM-PREVIOUSLY-SELECTED-WINDOWS-OF-SCREEN (SHEET-SCREEN WINDOW) WINDOW)))
  NIL)

(DEFUN REMOVE-FROM-PREVIOUSLY-SELECTED-WINDOWS-IF (PREDICATE &OPTIONAL (CONSOLE *CONSOLE*))
  (WHEN CONSOLE
    (WITHOUT-INTERRUPTS
      (LET* ((PSW (CONSOLE-PREVIOUSLY-SELECTED-WINDOWS CONSOLE))
	     (INDEX 0)
	     (LENGTH (FILL-POINTER PSW))
	     (REMOVED NIL))
	(LOOP WHILE (< INDEX LENGTH) DO
	  (LET ((WINDOW (AREF PSW INDEX)))
	    (COND ((FUNCALL PREDICATE WINDOW)
		   (PUSH WINDOW REMOVED)
		   (CL:REPLACE PSW PSW :START1 INDEX :START2 (1+ INDEX))
		   (DECF LENGTH)
		   (SETF (AREF PSW LENGTH) NIL))
		  (T
		   (INCF INDEX)))))
	(SETF (FILL-POINTER PSW) LENGTH)
	REMOVED))))

(DEFMETHOD (REMOVE-FROM-PREVIOUSLY-SELECTED-WINDOWS-OF-SCREEN BASIC-SCREEN) (WINDOW)
  (LET ((CONSOLE (TV:SHEET-CONSOLE SELF)))
    (COND ((VARIABLE-BOUNDP SAVED-PREVIOUSLY-SELECTED-WINDOWS)
	   (UNLESS (MEMQ WINDOW SAVED-PREVIOUSLY-SELECTED-WINDOWS)
	     (SETQ SAVED-PREVIOUSLY-SELECTED-WINDOWS
		   (APPEND SAVED-PREVIOUSLY-SELECTED-WINDOWS (LIST WINDOW)))))
	  (CONSOLE
	   (LET* ((PSW (CONSOLE-PREVIOUSLY-SELECTED-WINDOWS CONSOLE))
		  (OLD (CL:POSITION WINDOW PSW)))
	     (WHEN OLD
	       (LET ((FP (1- (FILL-POINTER PSW))))
		 (UNLESS (= OLD FP)
		   (CL:REPLACE PSW PSW :START1 OLD :START2 (1+ OLD)))
		 (SETF (AREF PSW FP) NIL)	;for GC's benefit
		 (SETF (FILL-POINTER PSW) FP))))))))


(DEFUN CLEAR-PREVIOUSLY-SELECTED-WINDOWS (CONSOLE)
  (WHEN CONSOLE
    (LET ((SW (CONSOLE-SELECTED-WINDOW CONSOLE)))
      (WHEN SW (SEND SW :DESELECT NIL)))
    (LET ((PSW (CONSOLE-PREVIOUSLY-SELECTED-WINDOWS CONSOLE)))
      (LOOP WHILE (PLUSP (FILL-POINTER PSW))
	    FOR WINDOW = (AREF PSW 0)
	    WHEN (EQ (SHEET-CONSOLE WINDOW) CONSOLE)
	      DO (SEND (SHEET-SCREEN WINDOW) :REMOVE-FROM-PREVIOUSLY-SELECTED-WINDOWS)
	    WHEN (EQ WINDOW (AREF PSW 0))
	      DO (CL:REPLACE PSW PSW :START2 1)
		 (SETF (AREF PSW (DECF (FILL-POINTER PSW))) NIL)))))

(DEFUN CHANGE-IN-PREVIOUSLY-SELECTED-WINDOWS (FROM-WINDOW TO-WINDOW)
  (WITHOUT-INTERRUPTS
    (SETQ FROM-WINDOW (SEND FROM-WINDOW :ALIAS-FOR-SELECTED-WINDOWS))
    (SETQ TO-WINDOW (SEND TO-WINDOW :ALIAS-FOR-SELECTED-WINDOWS))
    (LET ((CONSOLE (SHEET-CONSOLE FROM-WINDOW)))
      (COND ((AND (NULL FROM-WINDOW) (NULL TO-WINDOW)))
	    ((AND FROM-WINDOW (NULL TO-WINDOW))
	     (REMOVE-FROM-PREVIOUSLY-SELECTED-WINDOWS FROM-WINDOW))
	    ((NULL FROM-WINDOW)
	     ;; This shouldn't happen, but...
	     (ADD-TO-PREVIOUSLY-SELECTED-WINDOWS TO-WINDOW))
	    ((NOT (EQ CONSOLE (SHEET-CONSOLE TO-WINDOW))))
	    (CONSOLE
	     (CL:NSUBSTITUTE TO-WINDOW FROM-WINDOW
			     (CONSOLE-PREVIOUSLY-SELECTED-WINDOWS CONSOLE)))))
    NIL))

(DEFUN SELECT-PREVIOUS-WINDOW (&OPTIONAL WINDOW (MOUSE-P T) (DEFAULT-TO-LISP-LISTENER T)
					 MOUSE-SELECT)
  "Select the window that was selected before the current one.
  If WINDOW is non-NIL it tries to select that one, if it is active.
  MOUSE-P T (the default) means consider only windows selectable from the mouse.
  If no previously-selected window can be found, gets a Lisp listener,
  unless DEFAULT-TO-LISP-LISTENER is specified as NIL.
  Moves the current window to the end of the ring buffer rather than the beginning.
  Returns the window that was selected.  If MOUSE-SELECT a :MOUSE-SELECT message is
  sent rather than a :SELECT message."
  (WHEN (AND WINDOW
	     (SETQ WINDOW (SEND WINDOW :ALIAS-FOR-SELECTED-WINDOWS))
	     (EQ (SEND WINDOW :STATUS) :DEACTIVATED))
    (SETQ WINDOW NIL))
  (OR WINDOW
      (DOTIMES (I (ARRAY-ACTIVE-LENGTH PREVIOUSLY-SELECTED-WINDOWS))
	(AND (SETQ WINDOW (AREF PREVIOUSLY-SELECTED-WINDOWS I))
	     (OR (NOT MOUSE-P) (SEND WINDOW ':NAME-FOR-SELECTION))
	     (RETURN WINDOW)))
      (SETQ WINDOW (AND DEFAULT-TO-LISP-LISTENER
			(FIND-WINDOW-OF-FLAVOR 'LISP-LISTENER))))
  (DELAYING-SCREEN-MANAGEMENT	;Avoid auto-select
    (LET ((SW SELECTED-WINDOW))
      (COND (SW (SEND SW ':DESELECT NIL)
		(ADD-TO-PREVIOUSLY-SELECTED-WINDOWS SW T))))
    (COND ((AND WINDOW MOUSE-SELECT)
	   (SEND WINDOW ':MOUSE-SELECT))
	  (WINDOW
	   (SHEET-FREE-TEMPORARY-LOCKS WINDOW)
	   (SEND WINDOW ':SELECT))))
  WINDOW)

(DEFUN DESELECT-AND-MAYBE-BURY-WINDOW (WINDOW)
  "Deselect WINDOW and bury it if that leaves it deexposed."
  (DELAYING-SCREEN-MANAGEMENT
    (SEND WINDOW ':DESELECT)
    (OR (SHEET-EXPOSED-P WINDOW) (SEND WINDOW ':BURY))))

;;; Basic set-edges stuff
(DEFFLAVOR ESSENTIAL-SET-EDGES () (ESSENTIAL-WINDOW)
  (:METHOD-COMBINATION :VERIFY-NEW-EDGES (:OR :MOST-SPECIFIC-LAST))
  (:DOCUMENTATION :ESSENTIAL-MIXIN "Normal EDGES getting//setting messages
Provides :SET-EDGES and related messages such as :SET-SIZE, :SET-POSITION, :FULL-SCREEN,
and :CENTER-AROUND."))

(DEFMETHOD (:INIT ESSENTIAL-SET-EDGES :AFTER) (IGNORE)
  (LET ((ERROR-MESSAGE (SEND SELF ':VERIFY-NEW-EDGES X-OFFSET Y-OFFSET WIDTH HEIGHT)))
    (IF (NOT (NULL ERROR-MESSAGE))
	(FERROR ERROR-MESSAGE))))
 
(DEFMETHOD (:SET-EDGES ESSENTIAL-SET-EDGES)
	   (NEW-LEFT NEW-TOP NEW-RIGHT NEW-BOTTOM &OPTIONAL OPTION
	    &AUX (NEW-WIDTH (- NEW-RIGHT NEW-LEFT)) (NEW-HEIGHT (- NEW-BOTTOM NEW-TOP))
		 ERROR WINDOW-TO-BE-DEEXPOSED)
  (DELAYING-SCREEN-MANAGEMENT
    (DO (DONE RESULT) (())
      (SETQ WINDOW-TO-BE-DEEXPOSED
	  (CATCH 'SET-EDGES
	    (LOCK-SHEET (SELF)
	      (SETQ RESULT
		(COND ((SETQ ERROR (SEND SELF ':VERIFY-NEW-EDGES NEW-LEFT NEW-TOP
						 NEW-WIDTH NEW-HEIGHT))
		       ;; Can't put window there
		       (SELECTQ OPTION
			 (:VERIFY NIL)
			 (OTHERWISE
			  (FERROR ERROR))))
		      ((EQ OPTION ':VERIFY)
		       ;; "Only want to know"
		       T)
		      ((AND (= NEW-WIDTH WIDTH)
			    (= NEW-HEIGHT HEIGHT)
			    (= NEW-LEFT X-OFFSET)
			    (= NEW-TOP Y-OFFSET))
		       ;;Not changing size or position, just return T (we do the verify 
		       ;; anyway in case something in the environment has made the current
		       ;; size no longer "ok", such as having the size of the
		       ;; superior change.)
		       T)
		      ((AND (= NEW-WIDTH WIDTH)
			    (= NEW-HEIGHT HEIGHT))
		       ;; Only moving the window, move it's bits behind its back
		       (LET ((CURRENT-RECTANGLE (LIST X-OFFSET Y-OFFSET
						      (+ X-OFFSET WIDTH)
						      (+ Y-OFFSET HEIGHT))))
			 (COND ((NOT EXPOSED-P)
				(SHEET-SET-DEEXPOSED-POSITION NEW-LEFT NEW-TOP)
				(WHEN (MEMQ SELF (SHEET-INFERIORS SUPERIOR))
				  ;; If active, tell the screen manager
				  (LEXPR-FUNCALL #'SCREEN-AREA-HAS-CHANGED SELF
						 CURRENT-RECTANGLE)
				  (SCREEN-CONFIGURATION-HAS-CHANGED SELF ':SET-EDGES)))
			       ((SHEET-TEMPORARY-P)
				;; For temporary windows, just deexpose and reexpose
				(LET ((SELECT-P (SHEET-SELECTED-P SELF)))
				  (SEND SELF ':DEEXPOSE)
				  (SEND SELF ':EXPOSE NIL NIL NEW-LEFT NEW-TOP)
				  (WHEN SELECT-P (SEND SELF ':SELECT))))
			       (T
				(OR (SHEET-BOUNDS-WITHIN-SHEET-P NEW-LEFT NEW-TOP
								 WIDTH HEIGHT
								 SUPERIOR)
				    (FERROR "Attempt to move sheet ~S outside of superior"
					    SELF))
				;; Make sure everyone under us is deexposed
				(WITHOUT-INTERRUPTS
				  (DOLIST (SISTER (SHEET-EXPOSED-INFERIORS SUPERIOR))
				    (COND ((AND (NEQ SELF SISTER)
						(SHEET-OVERLAPS-P SISTER NEW-LEFT NEW-TOP
								  WIDTH HEIGHT))
					   (THROW 'SET-EDGES SISTER)))))
				(SHEET-SET-EXPOSED-POSITION NEW-LEFT NEW-TOP)
				(LEXPR-FUNCALL #'SCREEN-AREA-HAS-CHANGED SELF
					       CURRENT-RECTANGLE)
				(SCREEN-CONFIGURATION-HAS-CHANGED SELF ':SET-EDGES)))))
		      (T
		       (LET ((CURRENT-RECTANGLE (LIST X-OFFSET Y-OFFSET
						      (+ X-OFFSET WIDTH)
						      (+ Y-OFFSET HEIGHT))))
			 (WITH-SHEET-DEEXPOSED (SELF)
			   (SEND SELF ':CHANGE-OF-SIZE-OR-MARGINS
				      ':LEFT NEW-LEFT ':TOP NEW-TOP
				      ':WIDTH NEW-WIDTH ':HEIGHT NEW-HEIGHT)
			   (SHEET-FORCE-ACCESS (SELF :NO-PREPARE)
			     (SEND SELF ':REFRESH ':SIZE-CHANGED)))
			 (LET ((MOUSE (SHEET-MOUSE SELF)))
			   (WHEN MOUSE
			     (SETF (MOUSE-RECONSIDER MOUSE) T)))
			 (LEXPR-FUNCALL #'SCREEN-AREA-HAS-CHANGED SELF CURRENT-RECTANGLE)
			 (SCREEN-CONFIGURATION-HAS-CHANGED SELF ':SET-EDGES)))))
	      (SETQ DONE T))))
      (IF DONE
	  (RETURN (VALUES RESULT ERROR))
	  (SEND WINDOW-TO-BE-DEEXPOSED ':DEEXPOSE)))))


(DEFMETHOD (:VERIFY-NEW-EDGES ESSENTIAL-SET-EDGES) (NL NT NW NH)
  "Verifies that the edges are ok.  This method returns NIL unless the edges do not allow
enough room for the margins, or the window is exposed and will not fit within its superior."
  (COND ((OR (< NW (+ LEFT-MARGIN-SIZE RIGHT-MARGIN-SIZE))
	     (< NH (+ TOP-MARGIN-SIZE BOTTOM-MARGIN-SIZE)))
	 "Not enough room for margins")
	((AND EXPOSED-P
	      SUPERIOR
	      (NOT (SHEET-BOUNDS-WITHIN-SHEET-P NL NT NW NH SUPERIOR)))
	 "Attempt to expose outside of superior")))

(DEFMETHOD (:SET-SIZE ESSENTIAL-SET-EDGES) (NEW-WIDTH NEW-HEIGHT &OPTIONAL OPTION)
  (UNLESS NEW-WIDTH (SETQ NEW-WIDTH WIDTH))
  (UNLESS NEW-HEIGHT (SETQ NEW-HEIGHT HEIGHT))
  (SEND SELF ':SET-EDGES X-OFFSET Y-OFFSET
	     (+ NEW-WIDTH X-OFFSET) (+ NEW-HEIGHT Y-OFFSET)
	     OPTION))

(DEFMETHOD (:SET-INSIDE-SIZE ESSENTIAL-SET-EDGES) (NEW-WIDTH NEW-HEIGHT &OPTIONAL OPTION)
  (SEND SELF ':SET-EDGES X-OFFSET Y-OFFSET
	     (+ X-OFFSET NEW-WIDTH LEFT-MARGIN-SIZE RIGHT-MARGIN-SIZE)
	     (+ Y-OFFSET NEW-HEIGHT TOP-MARGIN-SIZE BOTTOM-MARGIN-SIZE)
	     OPTION))

(DEFMETHOD (:SET-POSITION ESSENTIAL-SET-EDGES) (NEW-X NEW-Y &OPTIONAL OPTION)
  (SEND SELF ':SET-EDGES NEW-X NEW-Y
	     (+ WIDTH NEW-X) (+ HEIGHT NEW-Y)
	     OPTION))

(DEFMETHOD (:FULL-SCREEN ESSENTIAL-SET-EDGES) (&OPTIONAL OPTION)
  (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
      (SEND SUPERIOR ':INSIDE-EDGES)
    (SEND SELF ':SET-EDGES LEFT TOP RIGHT BOTTOM OPTION)))

(DEFMETHOD (:CENTER-AROUND ESSENTIAL-SET-EDGES) (X Y)
  (CENTER-WINDOW-AROUND SELF X Y))

(DEFMETHOD (:EXPOSE-NEAR ESSENTIAL-SET-EDGES) (MODE &OPTIONAL (WARP-MOUSE-P T))
  (EXPOSE-WINDOW-NEAR SELF MODE WARP-MOUSE-P))

(DEFUN CENTER-WINDOW-AROUND (WINDOW X Y &AUX (W (SHEET-WIDTH WINDOW))
					     (H (SHEET-HEIGHT WINDOW))
					     (SUPERIOR (SHEET-SUPERIOR WINDOW))
					     SH SW)
  (SETQ X (MAX (SHEET-INSIDE-LEFT SUPERIOR) (- X (// W 2)))
	Y (MAX (SHEET-INSIDE-TOP SUPERIOR) (- Y (// H 2))))
  (AND (> (+ X W) (SETQ SW (SHEET-INSIDE-RIGHT SUPERIOR)))
       (SETQ X (MAX (SHEET-INSIDE-LEFT SUPERIOR) (- SW W))))
  (AND (> (+ Y H) (SETQ SH (SHEET-INSIDE-BOTTOM SUPERIOR)))
       (SETQ Y (MAX (SHEET-INSIDE-TOP SUPERIOR) (- SH H))))
  (SEND WINDOW ':SET-POSITION X Y)
  (VALUES (+ X (// W 2)) (+ Y (// H 2))))

(DEFUN CENTER-WINDOW-AROUND-POINT (WINDOW WARP-MOUSE-P X Y)
  (MULTIPLE-VALUE-BIND (X Y)
      (SEND WINDOW ':CENTER-AROUND X Y)
	      
    (WHEN WARP-MOUSE-P
      (MULTIPLE-VALUE-BIND (X-OFF Y-OFF MOUSE NOT-SUPERIOR)
	  (SHEET-MOUSE-OFFSETS (SHEET-SUPERIOR WINDOW) NIL)
	(UNLESS NOT-SUPERIOR
	  (MOUSE-WARP (+ X X-OFF)
		      (+ Y Y-OFF)
		      MOUSE))))))

(DEFUN MOVE-WINDOW-NEAR-MOUSE (WINDOW WARP-MOUSE-P)
  (MULTIPLE-VALUE-BIND (X-OFF Y-OFF MOUSE NOT-SUPERIOR)
      (SHEET-MOUSE-OFFSETS (SHEET-SUPERIOR WINDOW) NIL)
    (MULTIPLE-VALUE-BIND (X Y)
	(SEND WINDOW ':CENTER-AROUND
	      (- (MOUSE-X MOUSE) X-OFF) (- (MOUSE-Y MOUSE) Y-OFF))
      (WHEN WARP-MOUSE-P
	(WHEN NOT-SUPERIOR
	  ;; force the mouse to be in an acceptable screen
	  (MOUSE-SET-SHEET (SHEET-SCREEN WINDOW)))
	(MOUSE-WARP (+ X X-OFF) (+ Y Y-OFF) MOUSE)))))

(DEFUN %MOVE-WINDOW-NEAR-RECTANGLE (WINDOW WARP-MOUSE-P &REST MODE)
  (MOVE-WINDOW-NEAR-RECTANGLE
    WINDOW
    (FIRST MODE) (SECOND MODE) (THIRD MODE) (FOURTH MODE)
    NIL WARP-MOUSE-P))

(DEFUN MOVE-WINDOW-NEAR-RECTANGLE (WINDOW LEFT TOP RIGHT BOTTOM
				   &OPTIONAL (EXPOSE-P T) (WARP-MOUSE-P T)
				   &AUX WIDTH HEIGHT SUPERIOR
					NLEFT NTOP NRIGHT NBOTTOM TEM)
  (MULTIPLE-VALUE (WIDTH HEIGHT) (SEND WINDOW ':SIZE))
  (SETQ SUPERIOR (SHEET-SUPERIOR WINDOW))
  ;; Assuming window will go beside rectangle, try to center it vertically
  ;; but if that doesn't work butt it against the bottom of the superior.
  (SETQ NTOP (MIN (- (SHEET-INSIDE-BOTTOM SUPERIOR) HEIGHT)
		  (MAX (SHEET-INSIDE-TOP SUPERIOR)
		       (- (// (+ TOP BOTTOM) 2) (// HEIGHT 2))))
	NBOTTOM (+ NTOP HEIGHT))
  (COND ((AND ( RIGHT (SHEET-INSIDE-LEFT SUPERIOR))
	      ( (SHEET-INSIDE-RIGHT SUPERIOR) (SETQ TEM (+ RIGHT WIDTH))))
	 (SETQ NLEFT RIGHT NRIGHT TEM))
	((AND (< LEFT (SHEET-INSIDE-RIGHT SUPERIOR))
	      ( (SHEET-INSIDE-LEFT SUPERIOR) (SETQ TEM (- LEFT WIDTH))))
	 (SETQ NRIGHT LEFT NLEFT TEM))
	(T  ;Not enough room on either side, center it horizontally above or below the rect
	 (SETQ NLEFT (MAX (SHEET-INSIDE-LEFT SUPERIOR)
			  (MIN (- (SHEET-INSIDE-RIGHT SUPERIOR) WIDTH)
			       (- (// (+ LEFT RIGHT) 2) (// WIDTH 2))))
	       NRIGHT (+ NLEFT WIDTH))
	 (COND ((AND ( BOTTOM (SHEET-INSIDE-TOP SUPERIOR))
		     ( (SHEET-INSIDE-BOTTOM SUPERIOR) (SETQ TEM (+ BOTTOM HEIGHT))))
		(SETQ NTOP BOTTOM NBOTTOM TEM))
	       ((AND (< TOP (SHEET-INSIDE-BOTTOM SUPERIOR))
		     ( (SHEET-INSIDE-TOP SUPERIOR) (SETQ TEM (- TOP HEIGHT))))
		(SETQ NBOTTOM TOP NTOP TEM))
	       ;; Won't fit anywhere next to the rectangle, so center it on it instead
	       (T (SETQ NTOP (MAX (SHEET-INSIDE-TOP SUPERIOR)
				  (MIN (- (SHEET-INSIDE-BOTTOM SUPERIOR) HEIGHT)
				       (- (// (+ TOP BOTTOM) 2) (// HEIGHT 2))))
			NBOTTOM (+ NTOP HEIGHT))))))
  (SEND WINDOW ':SET-EDGES NLEFT NTOP NRIGHT NBOTTOM)
  (WHEN EXPOSE-P (SEND WINDOW ':EXPOSE))
  (WHEN WARP-MOUSE-P
    (MULTIPLE-VALUE-BIND (NIL NIL NIL NOT-SUPERIOR)
	(SHEET-MOUSE-OFFSETS (SHEET-SUPERIOR WINDOW) NIL)
      (UNLESS NOT-SUPERIOR
	(SEND WINDOW ':SET-MOUSE-POSITION (// WIDTH 2) (// HEIGHT 2))))))

(DEFUN MOVE-WINDOW-AWAY-FROM-WINDOWS (WINDOW WARP-MOUSE-P &REST OTHER-WINDOWS)
  (LOOP FOR NEAR-WINDOW IN OTHER-WINDOWS
	WITH (LEFT1 RIGHT1 TOP1 BOTTOM1 X-OFF Y-OFF)
	AND SUP = (SHEET-SUPERIOR WINDOW)
	AS SUP-NEAR = (SHEET-SUPERIOR NEAR-WINDOW)
	DO
    (MULTIPLE-VALUE (LEFT1 TOP1 RIGHT1 BOTTOM1)
      (SEND NEAR-WINDOW ':EDGES))
    (MULTIPLE-VALUE-BIND (X-OFF-1 Y-OFF-1)
	(SHEET-CALCULATE-OFFSETS SUP (SHEET-SCREEN SUP))
      (MULTIPLE-VALUE-BIND (X-OFF-2 Y-OFF-2)
	  (SHEET-CALCULATE-OFFSETS SUP-NEAR (SHEET-SCREEN SUP-NEAR))
	(SETQ X-OFF (- X-OFF-1 X-OFF-2)
	      Y-OFF (- Y-OFF-1 Y-OFF-2))))
	MINIMIZE (- LEFT1 X-OFF) INTO LEFT
	MINIMIZE (- TOP1 Y-OFF) INTO TOP
	MAXIMIZE (- RIGHT1 X-OFF) INTO RIGHT
	MAXIMIZE (- BOTTOM1 Y-OFF) INTO BOTTOM
	FINALLY
	  ;; See if it will fit
	  (MULTIPLE-VALUE-BIND (WIDTH HEIGHT) (SEND WINDOW :SIZE)
	    (UNLESS (OR (AND ( RIGHT (SHEET-INSIDE-LEFT SUP))
			     ( (SHEET-INSIDE-RIGHT SUP) (+ RIGHT WIDTH)))
			(AND (< LEFT (SHEET-INSIDE-RIGHT SUP))
			     ( (SHEET-INSIDE-LEFT SUP) (- LEFT WIDTH)))
			(AND ( BOTTOM (SHEET-INSIDE-TOP SUP))
			     ( (SHEET-INSIDE-BOTTOM SUP) (+ BOTTOM HEIGHT)))
			(AND (< TOP (SHEET-INSIDE-BOTTOM SUP))
			     ( (SHEET-INSIDE-TOP SUP) (- TOP HEIGHT))))
	      ;; It won't fit, maybe we can move the other window out of the way
	      (WHEN (AND (= (LENGTH OTHER-WINDOWS) 1)
			 (EQ SUP SUP-NEAR)
			 (SHEET-TEMPORARY-P NEAR-WINDOW))
		(MULTIPLE-VALUE-BIND (NEAR-WIDTH NEAR-HEIGHT) (SEND NEAR-WINDOW :SIZE)
		  (COND (( (+ NEAR-WIDTH WIDTH) (SHEET-INSIDE-WIDTH SUP))
			 (SEND NEAR-WINDOW :SET-POSITION (+ (SHEET-INSIDE-LEFT SUP)
							    (FLOOR (- (SHEET-INSIDE-WIDTH SUP)
								      NEAR-WIDTH WIDTH)
								   2))
							 (SEND NEAR-WINDOW :Y-OFFSET)))
			(( (+ NEAR-HEIGHT HEIGHT) (SHEET-INSIDE-HEIGHT SUP))
			 (SEND NEAR-WINDOW :SET-POSITION (SEND NEAR-WINDOW :X-OFFSET)
							 (+ (SHEET-INSIDE-TOP SUP)
							    (FLOOR (- (SHEET-INSIDE-HEIGHT
									SUP)
								      NEAR-HEIGHT HEIGHT)
								   2))))))
		(MULTIPLE-VALUE (LEFT TOP RIGHT BOTTOM) (SEND NEAR-WINDOW :EDGES)))))
	  (MOVE-WINDOW-NEAR-RECTANGLE WINDOW LEFT TOP RIGHT BOTTOM
				      NIL WARP-MOUSE-P)))

(DEFUN MOVE-WINDOW-TO-AVOID-WINDOWS (WINDOW WARP-MOUSE-P &REST OTHER-WINDOWS)
  (LET* ((HEIGHT (SEND WINDOW :HEIGHT))
	 (WIDTH (SEND WINDOW :WIDTH))
	 (SUPER (SHEET-SUPERIOR WINDOW)))
    (MULTIPLE-VALUE-BIND (SUPER-LEFT SUPER-TOP SUPER-RIGHT SUPER-BOTTOM) (SEND SUPER :INSIDE-EDGES)
      (LET* ((RAW-RECTS
	       (LOOP FOR I IN OTHER-WINDOWS
		     COLLECT
		       (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM) (SEND I :EDGES)
			 ;if there is no room between the window edge and the margin,
			 ;expand it to the margin.  This attempts to influence the boxes
			 ;to reflect squarish areas the window could fit into.
			 (WHEN (< (- TOP SUPER-TOP) HEIGHT) (SETQ TOP SUPER-TOP))
			 (WHEN (< (- SUPER-BOTTOM BOTTOM) HEIGHT) (SETQ BOTTOM SUPER-BOTTOM))
			 (WHEN (< (- LEFT SUPER-LEFT) WIDTH)(SETQ LEFT SUPER-LEFT))
			 (WHEN (< (- SUPER-RIGHT RIGHT) WIDTH) (SETQ RIGHT SUPER-RIGHT))
			 (LIST I LEFT TOP RIGHT BOTTOM))))
	     (RECTS (CANONICALIZE-RECTANGLE-SET (COPYLIST RAW-RECTS)))
	     (SUPER-RECTANGLE (LIST SUPER SUPER-LEFT SUPER-TOP SUPER-RIGHT SUPER-BOTTOM))
	     (CANONICAL-RECTANGLES
	       (CANONICALIZE-RECTANGLE-SET
		 (LOOP FOR RECT IN RECTS
		       WITH OK-RECTANGLES
		       DO
		   (LOOP WITH RECTANGLES = (RECTANGLE-NOT-INTERSECTION RECT SUPER-RECTANGLE)
			 AS (R) = RECTANGLES
			 WHILE R
			 DO (SETQ RECTANGLES (CDR RECTANGLES))
			    (LOOP FOR W IN RAW-RECTS
				  AS NEW = (RECTANGLE-NOT-INTERSECTION W R)
				  WHEN (NEQ (CAR NEW) R)
				    DO
				      (SETQ RECTANGLES (NCONC NEW RECTANGLES))
				      (RETURN T)
				  FINALLY
				    (PUSH R OK-RECTANGLES)))
		       FINALLY (RETURN OK-RECTANGLES)))))
	(LOOP WITH MAXR and MAXS AND MAXR-SPARE AND MAXS-SPARE
	      FOR R in CANONICAL-RECTANGLES
	      AS (NIL LEFT TOP RIGHT BOTTOM) = R
	      AS W = (- RIGHT LEFT)
	      AS H = (- BOTTOM TOP)
	      AS S = (* W H)
	      WHEN (AND ( W WIDTH)( H HEIGHT)
			(OR (NULL MAXR)
			    (> S MAXS)))
		DO (SETQ MAXR R MAXS S)
	      WHEN (AND (NULL MAXR)
			(OR (NULL MAXR-SPARE)
			    (> S MAXS-SPARE)))
		DO				;as a backup to a rectangle that can contain the window, find
						;the largest rectangle
		  (SETQ MAXR-SPARE R MAXS-SPARE S)
	      FINALLY
		(DESTRUCTURING-BIND (NIL LEFT TOP RIGHT BOTTOM) (OR MAXR MAXR-SPARE SUPER-RECTANGLE)
		  (LET ((X (// (+ LEFT RIGHT) 2))
			(Y (// (+ TOP BOTTOM) 2)))

		    (CENTER-WINDOW-AROUND WINDOW X Y)
		    (WHEN WARP-MOUSE-P
		      (MULTIPLE-VALUE-BIND (X-OFF Y-OFF MOUSE NOT-SUPERIOR)
			  (SHEET-MOUSE-OFFSETS (SHEET-SUPERIOR WINDOW) NIL)
			(UNLESS NOT-SUPERIOR
			  (MOUSE-WARP (+ X X-OFF)
				      (+ Y Y-OFF)
				      MOUSE)))))
		  ))))))


(DEFVAR *EXPOSE-WINDOW-FUNCTIONS* '((:POINT . CENTER-WINDOW-AROUND-POINT)
				   (:MOUSE . MOVE-WINDOW-NEAR-MOUSE)
				   (:RECTANGLE . %MOVE-WINDOW-NEAR-RECTANGLE)
				   (:WINDOW . MOVE-WINDOW-AWAY-FROM-WINDOWS)
				   (:AVOID-WINDOWS . MOVE-WINDOW-TO-AVOID-WINDOWS)
				   ))
(DEFUN EXPOSE-WINDOW-NEAR (WINDOW MODE &OPTIONAL (WARP-MOUSE-P T) (EXPOSE-P T))
  (COND ((NOT (SHEET-EXPOSED-P WINDOW))
	 (LET* ((SUP (SHEET-SUPERIOR WINDOW))
		(SCR (SHEET-SCREEN SUP)))
	   (UNLESS (OR (SHEET-EXPOSED-P SCR)
		       (SEND SCR :APPROPRIATE-HARDWARE-P))
	     ;;
	     ;; if the window to be exposed is on an unusable screen,
	     ;; move it to a good one.
	     ;;
	     (SET-WINDOW-ON-USABLE-SCREEN
	       WINDOW
	       (SELECTQ (FIRST MODE)
		 (:MOUSE (MOUSE-SHEET (SHEET-MOUSE WINDOW)))
		 ((:WINDOW :AVOID-WINDOWS)
		  (SHEET-SUPERIOR (SECOND MODE)))
		 (T TV:DEFAULT-SCREEN)))))
	 (LET ((FUN (OR (CDR (ASSOC (FIRST MODE) *EXPOSE-WINDOW-FUNCTIONS*))
			(FIRST MODE))))
	   (IF (KEYWORDP FUN)
	       (IF (OPERATION-HANDLED-P WINDOW FUN)
		   (LEXPR-SEND WINDOW FUN WARP-MOUSE-P (CDR MODE))
		   (FERROR "~S invalid mode" (FIRST MODE)))
	       (IF (FUNCTIONP FUN)
		   (LEXPR-FUNCALL FUN WINDOW WARP-MOUSE-P (CDR MODE))
		   (FERROR "~S invalid mode" (FIRST MODE)))
	       ))))
  (WHEN EXPOSE-P (SEND WINDOW :EXPOSE)))


;;;Things that hack margins (borders and labels)

;;;In order to interact correctly with adjusting the size of the margins, flavors
;;;that handle an area of the window further outside should come higher in the hierarchy,
;;;that is their pre-daemons should be called first.
;;;When redefining the window, pre-daemons for margin hackers should add in the amount
;;;they will need to the appropriate margins (this will happen in the right order).
;;;Thus to change the value of a border or label, send a :REDEFINE-MARGINS message with a
;;;:FOO property in it, and have a pre-daemon on :REDEFINE-MARGINS that calls ADJUST-MARGINS.

(DEFFLAVOR MARGIN-HACKER-MIXIN () (ESSENTIAL-WINDOW)
  (:DOCUMENTATION :LOWLEVEL-MIXIN "For mixins that occupy space in the margins
See the section on margins for what to do when you mix this in."))

(DEFMETHOD (:REDEFINE-MARGINS MARGIN-HACKER-MIXIN) (PLIST)
  (SETQ RESTORED-BITS-P T)
  (COND ((NOT (AND (= LEFT-MARGIN-SIZE (GET PLIST ':LEFT-MARGIN-SIZE))
		   (= TOP-MARGIN-SIZE (GET PLIST ':TOP-MARGIN-SIZE))
		   (= RIGHT-MARGIN-SIZE (GET PLIST ':RIGHT-MARGIN-SIZE))
		   (= BOTTOM-MARGIN-SIZE (GET PLIST ':BOTTOM-MARGIN-SIZE))))
	 (WITH-SHEET-DEEXPOSED (SELF)
	   (LET ((INSIDE-SIZE-CHANGED
		   (LEXPR-SEND SELF ':CHANGE-OF-SIZE-OR-MARGINS (CDR PLIST))))
	     (SHEET-FORCE-ACCESS (SELF :NO-PREPARE)
	       (SEND SELF ':REFRESH (IF INSIDE-SIZE-CHANGED
					':SIZE-CHANGED
				      ':MARGINS-ONLY))))))))

;;;Adjust the margins, PARSING-MESSAGE is called on either the value of PLIST-KEYWORD
;;;in PLIST or INSTANCE-VARIABLE, it should return the new value, and the size required
;;;in the four margins.  INSTANCE-VARIABLE is then set to the new value, and the margins,
;;;either in PLIST, or the appropriate instance variables.
(DEFUN-IN-FLAVOR (ADJUST-MARGINS ESSENTIAL-WINDOW) (INSTANCE-VARIABLE PARSING-MESSAGE PLIST
								 PLIST-KEYWORD
								 &AUX LM TM RM BM NVAL)
  (IF (NULL PLIST-KEYWORD)
      (SETQ LM LEFT-MARGIN-SIZE TM TOP-MARGIN-SIZE
	    RM RIGHT-MARGIN-SIZE BM BOTTOM-MARGIN-SIZE)
      (SETQ LM (OR (GET PLIST ':LEFT-MARGIN-SIZE) 0)
	    TM (OR (GET PLIST ':TOP-MARGIN-SIZE) 0)
	    RM (OR (GET PLIST ':RIGHT-MARGIN-SIZE) 0)
	    BM (OR (GET PLIST ':BOTTOM-MARGIN-SIZE) 0)))
  (SETQ NVAL (SYMEVAL-IN-INSTANCE SELF INSTANCE-VARIABLE))
  (AND PLIST-KEYWORD (LET ((TEM (GET PLIST PLIST-KEYWORD)))
		       (WHEN (SI:NREMPROP PLIST PLIST-KEYWORD)
			 (SETQ NVAL TEM))))
  (MULTIPLE-VALUE (NVAL LM TM RM BM)
    (SEND SELF PARSING-MESSAGE NVAL LM TM RM BM))
  (IF (NULL PLIST-KEYWORD)
      (SETQ LEFT-MARGIN-SIZE LM TOP-MARGIN-SIZE TM
	    RIGHT-MARGIN-SIZE RM BOTTOM-MARGIN-SIZE BM)
      (PUTPROP PLIST LM ':LEFT-MARGIN-SIZE)
      (PUTPROP PLIST TM ':TOP-MARGIN-SIZE)
      (PUTPROP PLIST RM ':RIGHT-MARGIN-SIZE)
      (PUTPROP PLIST BM ':BOTTOM-MARGIN-SIZE))
  (SET-IN-INSTANCE SELF INSTANCE-VARIABLE NVAL))

;;;Borders
(DEFFLAVOR BORDERS-MIXIN ((BORDERS T) (BORDER-MARGIN-WIDTH 1)) (MARGIN-HACKER-MIXIN)
  (:GETTABLE-INSTANCE-VARIABLES BORDERS BORDER-MARGIN-WIDTH)
  (:INITABLE-INSTANCE-VARIABLES BORDERS BORDER-MARGIN-WIDTH)
  (:DOCUMENTATION :MIXIN "Normal BORDERS.
This flavor should provide general enough handling of the borders for most uses, see
the description of the :BORDERS init option for the format of the BORDERS instance
variable."))

(DEFMETHOD (:INIT BORDERS-MIXIN :BEFORE) (INIT-PLIST)
  (ADJUST-MARGINS 'BORDERS ':PARSE-BORDERS-SPEC INIT-PLIST NIL))

(DEFMETHOD (:SET-BORDER-MARGIN-WIDTH BORDERS-MIXIN) (NEW-WIDTH
						      &AUX (PLIST (LIST ':BORDERS BORDERS)))
  (SETQ BORDER-MARGIN-WIDTH NEW-WIDTH)
  (SEND SELF ':REDEFINE-MARGINS (LOCF PLIST)))

(DEFMETHOD (:SET-BORDERS BORDERS-MIXIN) (NEW-BORDERS
					     &AUX (PLIST (LIST ':BORDERS NEW-BORDERS)))
  (SEND SELF ':REDEFINE-MARGINS (LOCF PLIST)))

(DEFMETHOD (:CHOOSE-ATTRIBUTES BORDERS-MIXIN) ()
  (LIST
    :SET-BORDERS (SCL:ACCEPT '((SCL:NULL-OR-TYPE ((CL:INTEGER (0)))))
			     :PROMPT "Width of borders"
			     ;;:DOCUMENTATION "Set the widths of the borders or CR for no borders"
			     :PROVIDE-DEFAULT T
			     :DEFAULT
			     (AND (LISTP BORDERS)
				  (FIRST BORDERS)
				  (COND ((ATOM (FIRST BORDERS)) 0)
					((LOOP FOR SPEC IN BORDERS
					       ALWAYS (OR (NLISTP SPEC)
							  (EQ (BORDER-ITEM-FUNCTION SPEC)
							      'DRAW-RECTANGULAR-BORDER)))
					 (- (BORDER-ITEM-RIGHT (FIRST BORDERS))
					    (BORDER-ITEM-LEFT (FIRST BORDERS)))))))
    :SET-BORDER-MARGIN-WIDTH (SCL:ACCEPT '((CL:INTEGER 0))
					 :PROMPT "Width of border margins"
					 ;;:DOCUMENTATION "Set the width of the margin in between the borders and the window contents"
					 :DEFAULT BORDER-MARGIN-WIDTH)))

;;;This handles the actual drawing of the borders
(DEFUN-IN-FLAVOR (DRAW-BORDERS BORDERS-MIXIN) (ALU)
  (SHEET-FORCE-ACCESS (SELF)
    (DOLIST (BORDER BORDERS)
      (AND BORDER
	   (NEQ BORDER ':ZERO)
	   (LET ((LEFT (SECOND BORDER))
		 (TOP (THIRD BORDER))
		 (RIGHT (FOURTH BORDER))
		 (BOTTOM (FIFTH BORDER)))
	     (FUNCALL (FIRST BORDER) SELF ALU
		      (IF (MINUSP LEFT) (+ LEFT WIDTH) LEFT)
		      (IF (MINUSP TOP) (+ TOP HEIGHT) TOP)
		      (IF (PLUSP RIGHT) RIGHT (+ RIGHT WIDTH))
		      (IF (PLUSP BOTTOM) BOTTOM (+ BOTTOM HEIGHT))))))))

(DEFSTRUCT (BORDER-ITEM :LIST (:CONSTRUCTOR ()) :CONC-NAME)
  FUNCTION LEFT TOP RIGHT BOTTOM)

;;;This is called with the new border specification and the current (relative to this
;;;redefining) margins, and should return the canonical form of the border, and the four new
;;;margins.
;;The borders meet like this:
;;   |---------|
;;   |         |
;;   |         |
;;   ----------|
(DEFUN-IN-FLAVOR (PARSE-BORDERS-SPEC BORDERS-MIXIN) (SPEC LM TM RM BM FUNCTION
						&OPTIONAL DEFAULT-SIZE)
  (COND ;;NIL means no borders at all
	(SPEC
	 ;;A symbol or an number means that type for each of the four, else make a copy
	 ;;a plist of (:LEFT FOO :RIGHT BAR) works too
	 ;;Canonicalize into list of four specs
	 (SETQ SPEC (COND ((ATOM SPEC)
			   (SETQ SPEC (LIST SPEC SPEC SPEC SPEC)))
			  ((MEMQ (CAR SPEC) '(:LEFT :TOP :RIGHT :BOTTOM))
			   (DO ((NSPEC (IF (EQ BORDERS SPEC)		;The first time
					   (LIST NIL NIL NIL NIL)
					   (COPYLIST BORDERS)))
				(SPEC SPEC (CDDR SPEC)))
			       ((NULL SPEC) NSPEC)
			     (SETF (NTH (FIND-POSITION-IN-LIST (CAR SPEC)
							       '(:LEFT :TOP :RIGHT :BOTTOM))
					NSPEC)
				   (CADR SPEC))))
			  (T
			   (COPYLIST SPEC))))
	 ;;Canonicalize atomic items into (function . size)
	 (DO ((SPEC SPEC (CDR SPEC))
	      (ITEM))
	     ((NULL SPEC))
	   (COND ((OR (NULL (SETQ ITEM (CAR SPEC)))
		      (EQ ITEM ':ZERO)))
		 ;;A number means that width of the default function
		 ((NUMBERP ITEM)
		  (SETF (CAR SPEC) (CONS FUNCTION ITEM)))
		 ;;A symbol means that function and its default width
		 ((SYMBOLP ITEM)
		  (AND (EQ ITEM T) (SETQ ITEM FUNCTION))
		  (SETF (CAR SPEC) (CONS ITEM (OR DEFAULT-SIZE
						  (GET ITEM 'DEFAULT-BORDER-SIZE)))))))
	 ;;Canonicalize into 4-list of (function left top right bottom)
	 (LOOP FOR ITEM IN SPEC
	       FOR TYPE IN '(:LEFT :TOP :RIGHT :BOTTOM)
	       WHEN (AND ITEM (LISTP ITEM))
	       DO (LET ((WID (CDR ITEM)))
		    (IF (ATOM WID)
			;;A cons of a symbol and a number is the CAR function
			;; with the CDR width
			(SETF (CDR ITEM)
			      (LIST (IF (EQ TYPE ':RIGHT) WID 0)	;left side of right
				    (IF (EQ TYPE ':BOTTOM) WID 0)	;top side of bottom
				    (IF (EQ TYPE ':LEFT) WID 0)		;right side of left
				    (IF (EQ TYPE ':TOP) WID 0)))	;bottom side of top
			;;Else make entries relative
			(LET ((WID (- (BORDER-ITEM-RIGHT ITEM) (BORDER-ITEM-LEFT ITEM)))
			      (HGT (- (BORDER-ITEM-BOTTOM ITEM) (BORDER-ITEM-TOP ITEM))))
			  (SETF (BORDER-ITEM-LEFT ITEM) (IF (EQ TYPE ':RIGHT) WID 0))
			  (SETF (BORDER-ITEM-TOP ITEM) (IF (EQ TYPE ':BOTTOM) HGT 0))
			  (SETF (BORDER-ITEM-RIGHT ITEM) (IF (EQ TYPE ':LEFT) WID 0))
			  (SETF (BORDER-ITEM-BOTTOM ITEM) (IF (EQ TYPE ':TOP) HGT 0))))))
	 ;;Now adjust all non-NIL items for the current margins
	 (LOOP FOR SPEC ON SPEC
	       FOR (ITEM) = SPEC
	       FOR TYPE IN '(:LEFT :TOP :RIGHT :BOTTOM)
	       WHEN (AND ITEM (LISTP ITEM))
	       DO (LET ((WID (ABS (- (BORDER-ITEM-RIGHT ITEM) (BORDER-ITEM-LEFT ITEM))))
			(HGT (ABS (- (BORDER-ITEM-BOTTOM ITEM) (BORDER-ITEM-TOP ITEM)))))
		    (COND ((SELECTQ TYPE
			     ((:LEFT :RIGHT) (ZEROP WID))
			     ((:TOP :BOTTOM) (ZEROP HGT)))
			   (SETF (CAR SPEC) ':ZERO))
			  (T ;; Order here is L R T B to give symmetry
			   (IF (EQ TYPE ':RIGHT)
			       (SETF (BORDER-ITEM-LEFT ITEM)	;left side of right
				     (- (+ (BORDER-ITEM-LEFT ITEM) RM)))
			       (INCF (BORDER-ITEM-LEFT ITEM) LM))
			   (IF (EQ TYPE ':LEFT)
			       (INCF (BORDER-ITEM-RIGHT ITEM) LM)	;right side of left
			       (SETF (BORDER-ITEM-RIGHT ITEM)
				     (- (+ (BORDER-ITEM-RIGHT ITEM) RM))))
			   (IF (EQ TYPE ':BOTTOM)
			       (SETF (BORDER-ITEM-TOP ITEM)	;top side of bottom
				     (- (+ (BORDER-ITEM-TOP ITEM) BM)))
			       (INCF (BORDER-ITEM-TOP ITEM) TM))
			   (IF (EQ TYPE ':TOP)
			       (INCF (BORDER-ITEM-BOTTOM ITEM) TM)	;bottom side of top
			       (SETF (BORDER-ITEM-BOTTOM ITEM)
				     (- (+ (BORDER-ITEM-BOTTOM ITEM) BM))))
			   (SELECTQ TYPE
			     (:LEFT (INCF LM WID))
			     (:TOP (INCF TM HGT))
			     (:RIGHT (INCF RM WID))
			     (:BOTTOM (INCF BM HGT)))))))
	 (DESTRUCTURING-BIND (LEFT-SPEC TOP-SPEC RIGHT-SPEC BOTTOM-SPEC) SPEC
	   (WHEN (AND LEFT-SPEC BOTTOM-SPEC
		      (NEQ LEFT-SPEC :ZERO) (NEQ BOTTOM-SPEC :ZERO))
	     (SETF (BORDER-ITEM-BOTTOM LEFT-SPEC) (BORDER-ITEM-TOP BOTTOM-SPEC))
	     (SETF (BORDER-ITEM-LEFT BOTTOM-SPEC) (BORDER-ITEM-LEFT LEFT-SPEC)))
	   (WHEN (AND TOP-SPEC RIGHT-SPEC
		      (NEQ TOP-SPEC :ZERO) (NEQ RIGHT-SPEC :ZERO))
	     (SETF (BORDER-ITEM-RIGHT TOP-SPEC) (BORDER-ITEM-LEFT RIGHT-SPEC))
	     (SETF (BORDER-ITEM-TOP RIGHT-SPEC) (BORDER-ITEM-TOP TOP-SPEC)))
	   ;;Now account for the extra margin
	   (WHEN LEFT-SPEC (INCF LM BORDER-MARGIN-WIDTH))
	   (WHEN TOP-SPEC (INCF TM  BORDER-MARGIN-WIDTH))
	   (WHEN RIGHT-SPEC (INCF RM BORDER-MARGIN-WIDTH))
	   (WHEN BOTTOM-SPEC (INCF BM BORDER-MARGIN-WIDTH)))))
  (VALUES SPEC LM TM RM BM))

(DEFMETHOD (:REFRESH-MARGINS BORDERS-MIXIN :AFTER) ()
  (DRAW-BORDERS CHAR-ALUF))

(DEFMETHOD (:REDEFINE-MARGINS BORDERS-MIXIN :BEFORE) (PLIST)
  (ADJUST-MARGINS 'BORDERS ':PARSE-BORDERS-SPEC PLIST ':BORDERS))

(DEFMETHOD (:PARSE-BORDERS-SPEC BORDERS-MIXIN) (SPEC LM TM RM BM)
  (PARSE-BORDERS-SPEC SPEC LM TM RM BM 'DRAW-RECTANGULAR-BORDER))

(DEFPROP DRAW-RECTANGULAR-BORDER 1 DEFAULT-BORDER-SIZE)

(DEFUN DRAW-RECTANGULAR-BORDER (WINDOW ALU LEFT TOP RIGHT BOTTOM)
  (SHEET-DRAW-RECTANGLE (- RIGHT LEFT) (- BOTTOM TOP) LEFT TOP ALU WINDOW))

;; Functions and such for drawing drop shadow borders.  
;; The deepest shadow is at bottom right, sort of like:
;; ---------
;; |      ||
;; |      ||
;; |      ||
;; =========
;;

(DEFCONST *DROP-SHADOW-OUTSIDE-MARGIN* 2)

(LOOP FOR (FUNCTION WIDTH) IN '((DRAW-LEFT-DROP-SHADOW-BORDER 2)
				(DRAW-TOP-DROP-SHADOW-BORDER 2)
				(DRAW-RIGHT-DROP-SHADOW-BORDER 6)
				(DRAW-BOTTOM-DROP-SHADOW-BORDER 6))
      DO (SETF (GET FUNCTION 'DEFAULT-BORDER-SIZE)
	       (+ WIDTH *DROP-SHADOW-OUTSIDE-MARGIN*)))

(DEFUN DRAW-LEFT-DROP-SHADOW-BORDER (WINDOW ALU LEFT TOP RIGHT BOTTOM)
  (LET ((WIDTH (- RIGHT LEFT))
	(HEIGHT (- BOTTOM TOP)))
    (WHEN (> WIDTH *DROP-SHADOW-OUTSIDE-MARGIN*)
      (INCF LEFT *DROP-SHADOW-OUTSIDE-MARGIN*)
      (DECF WIDTH *DROP-SHADOW-OUTSIDE-MARGIN*))
    (WHEN (> HEIGHT *DROP-SHADOW-OUTSIDE-MARGIN*)
      (DECF HEIGHT  *DROP-SHADOW-OUTSIDE-MARGIN*)
      (INCF TOP *DROP-SHADOW-OUTSIDE-MARGIN*))
    (SHEET-DRAW-RECTANGLE WIDTH HEIGHT LEFT TOP ALU WINDOW)
    ;;(SHEET-BITBLT ALU WIDTH HEIGHT 50%-GRAY 0 0 () LEFT TOP WINDOW)
    ))

(DEFUN DRAW-TOP-DROP-SHADOW-BORDER (WINDOW ALU LEFT TOP RIGHT BOTTOM)
  (LET ((WIDTH (- RIGHT LEFT))
	(HEIGHT (- BOTTOM TOP)))
    (WHEN (> HEIGHT *DROP-SHADOW-OUTSIDE-MARGIN*)
      (INCF TOP *DROP-SHADOW-OUTSIDE-MARGIN*) (DECF HEIGHT *DROP-SHADOW-OUTSIDE-MARGIN*))
    (SHEET-DRAW-RECTANGLE WIDTH HEIGHT LEFT TOP ALU WINDOW)
    ;;(SHEET-BITBLT ALU WIDTH HEIGHT 50%-GRAY 0 0 () LEFT TOP WINDOW)
    ))

(DEFUN DRAW-RIGHT-DROP-SHADOW-BORDER (WINDOW ALU LEFT TOP RIGHT BOTTOM)
  (LET ((WIDTH (- RIGHT LEFT))
	(HEIGHT (- BOTTOM TOP)))
    (WHEN (> WIDTH *DROP-SHADOW-OUTSIDE-MARGIN*) (DECF WIDTH *DROP-SHADOW-OUTSIDE-MARGIN*))
    (WHEN (> HEIGHT *DROP-SHADOW-OUTSIDE-MARGIN*)
      (DECF HEIGHT (* 2 *DROP-SHADOW-OUTSIDE-MARGIN*))
      (INCF TOP *DROP-SHADOW-OUTSIDE-MARGIN*))
    (IF (> HEIGHT WIDTH)
	(LET ((RTOP (+ TOP WIDTH)))
	  (SHEET-DRAW-RECTANGLE WIDTH (- HEIGHT WIDTH) LEFT RTOP ALU WINDOW)
	  ;;(SHEET-BITBLT ALU WIDTH (- HEIGHT WIDTH) 50%-GRAY 0 0 () LEFT RTOP WINDOW)
	  (SHEET-DRAW-TRIANGLE LEFT TOP LEFT RTOP (+ LEFT WIDTH) RTOP ALU WINDOW)
	  )
	(SHEET-DRAW-RECTANGLE WIDTH HEIGHT LEFT TOP ALU WINDOW))))

(DEFUN DRAW-BOTTOM-DROP-SHADOW-BORDER (WINDOW ALU LEFT TOP RIGHT BOTTOM)
  (LET ((WIDTH (- RIGHT LEFT))
	(HEIGHT (- BOTTOM TOP)))
    (WHEN (> HEIGHT *DROP-SHADOW-OUTSIDE-MARGIN*)
      (DECF HEIGHT *DROP-SHADOW-OUTSIDE-MARGIN*))
    (WHEN (> WIDTH *DROP-SHADOW-OUTSIDE-MARGIN*)
      (DECF WIDTH *DROP-SHADOW-OUTSIDE-MARGIN*)
      (INCF LEFT *DROP-SHADOW-OUTSIDE-MARGIN*))
    (IF (> WIDTH HEIGHT)
	(LET ((RLEFT (+ LEFT HEIGHT)))
	  (SHEET-DRAW-RECTANGLE (- WIDTH HEIGHT) HEIGHT RLEFT TOP ALU WINDOW)
	  ;;(SHEET-BITBLT ALU (- WIDTH HEIGHT) HEIGHT 50%-GRAY 0 0 () RLEFT TOP WINDOW)
	  (SHEET-DRAW-TRIANGLE LEFT TOP RLEFT TOP RLEFT (+ TOP HEIGHT) ALU WINDOW)
	  ;;draw-triangle chooses not to draw the points "on" the left diagonal
	  (SHEET-DRAW-LINE LEFT TOP RLEFT (+ TOP HEIGHT) ALU () WINDOW))
	(SHEET-DRAW-RECTANGLE WIDTH HEIGHT LEFT TOP ALU WINDOW))))

(DEFCONST *DROP-SHADOW-BORDERS-SPEC*
	  '(DRAW-LEFT-DROP-SHADOW-BORDER DRAW-TOP-DROP-SHADOW-BORDER
	    DRAW-RIGHT-DROP-SHADOW-BORDER DRAW-BOTTOM-DROP-SHADOW-BORDER))

(DEFFLAVOR DROP-SHADOW-BORDERS-MIXIN () (BORDERS-MIXIN)
  (:DOCUMENTATION :MIXIN "Drop shadow borders.
This flavor can be used in place of BORDERS-MIXIN to give the window pseudo-3d borders.
It provides the correct :BORDERS init option.")
  (:DEFAULT-INIT-PLIST :BORDERS *DROP-SHADOW-BORDERS-SPEC*))

;;Things for drawing fancy borders like you'd see in "tombstone" advertisements
;;in the financial pages.

(DEFCONST *TOMBSTONE-BORDERS-SPEC*
	  '(DRAW-LEFT-TOMBSTONE-BORDER DRAW-TOP-TOMBSTONE-BORDER
	    DRAW-RIGHT-TOMBSTONE-BORDER DRAW-BOTTOM-TOMBSTONE-BORDER))

(DEFCONST *TOMBSTONE-BORDER-THICKNESS* 1)
(DEFCONST *TOMBSTONE-BORDER-MARGIN* 3)
(DEFCONST *TOMBSTONE-OUTER-THICKNESS* 10.)
(DEFCONST *TOMBSTONE-OUTER-MARGIN* 8.)
(DEFCONST *TOMBSTONE-INNER-THICKNESS* 4)

(DEFCONST *TOMBSTONE-INNER-MARGINS* '(50. 10. 50. 4.))

;;; We have to keep all these numbers somewhere.  The right place is in the borders
;;; spec, but then I'd have to wade through all the hair of PARSE-BORDERS-SPEC to support
;;; it.  So, I'll just keep on using the plist like DRAW-RECTANGULAR-BORDER before me.
;;; That means that if you have more than one window with tombstone borders, they'll
;;; all look the same.   Fixed in margin-decoration-mixin, when that's designed.
;;; This is for people who don't think my graphic design is right.  It probably
;;; doesn't need to get advertised/documented.
(DEFUN ALTER-TOMBSTONE-BORDER-SIZES (WINDOW &KEY
				     LEFT-MARGIN TOP-MARGIN RIGHT-MARGIN BOTTOM-MARGIN	;inner
				     BORDER-THICKNESS BORDER-MARGIN	;outside
				     OUTER-THICKNESS
				     OUTER-MARGIN	;between
				     INNER-THICKNESS)
  ;;If I had MACROLET, I'd do this:
  ;;    (MACROLET ((SET-IF (ACC VAL) `(WHEN ,VAL  (SETF ,ACC ,VAL)))) 
  ;;       (SET-IF (FIRST *TOMBSTONE-INNER-MARGINS*) LEFT-MARGIN)
  ;;       ...)
  ;;It sounds just marginally less useful than deserving to be made available elsewhere.
  #.`(PROGN
       ,@(LOOP WITH STUFF = '(((FIRST *TOMBSTONE-INNER-MARGINS*) LEFT-MARGIN)
			      ((SECOND *TOMBSTONE-INNER-MARGINS*) TOP-MARGIN)
			      ((THIRD *TOMBSTONE-INNER-MARGINS*) RIGHT-MARGIN)
			      ((FOURTH *TOMBSTONE-INNER-MARGINS*) BOTTOM-MARGIN)
			      (*TOMBSTONE-BORDER-THICKNESS* BORDER-THICKNESS)
			      (*TOMBSTONE-BORDER-MARGIN* BORDER-MARGIN)
			      (*TOMBSTONE-OUTER-THICKNESS* OUTER-THICKNESS)
			      (*TOMBSTONE-OUTER-MARGIN* OUTER-MARGIN)
			      (*TOMBSTONE-INNER-THICKNESS* INNER-THICKNESS))
	       FOR (ACC VAL) IN STUFF
	       COLLECT `(WHEN ,VAL (SETF ,ACC ,VAL))))
  (LOOP WITH THICKNESS = (+ *TOMBSTONE-BORDER-THICKNESS* 
			    *TOMBSTONE-BORDER-MARGIN* 
			    *TOMBSTONE-OUTER-THICKNESS*
			    *TOMBSTONE-OUTER-MARGIN*
			    *TOMBSTONE-INNER-THICKNESS*)
	FOR FN IN '(DRAW-LEFT-TOMBSTONE-BORDER DRAW-TOP-TOMBSTONE-BORDER
		    DRAW-RIGHT-TOMBSTONE-BORDER DRAW-BOTTOM-TOMBSTONE-BORDER)
	FOR VAL IN *TOMBSTONE-INNER-MARGINS*
	DO (SETF (GET FN 'TV:DEFAULT-BORDER-SIZE) (+ THICKNESS VAL)))
  (WHEN WINDOW
    (SEND WINDOW :SET-BORDERS (CONS (FIRST *TOMBSTONE-BORDERS-SPEC*)	;Intentionally NEQ
				    (REST1 *TOMBSTONE-BORDERS-SPEC*)))))

;;Put numbers on the plists for parse-borders-spec.
(ALTER-TOMBSTONE-BORDER-SIZES ())

;;The rectangle whacking is the best we can do before inventing margin-decoration-mixin.
;;    Imagine whacking slabs off the sides of the rectangle with a machete.
;;    I am not attatached to the name.
(DEFMACRO WHACK-RECTANGLES ((WINDOW ALU LEFT TOP RIGHT BOTTOM)
			    &BODY CLAUSES)
  (DECLARE (ARGLIST (WINDOW ALU LEFT TOP RIGHT BOTTOM)
		    &LIST-OF (CLAUSES &LIST-OF (SIDE THICKNESS COLOR))))
  `(LET ((,WINDOW ,WINDOW))
     ,@(LOOP FOR (SIDES . SPECS) IN CLAUSES
	     NCONC (LOOP FOR (THICKNESS COLOR) IN SPECS
			 COLLECT `(MULTIPLE-VALUE (,LEFT ,TOP ,RIGHT ,BOTTOM)
				    (WHACK-RECTANGLE ',SIDES ,THICKNESS ,ALU ,COLOR ,WINDOW
						     ,LEFT ,TOP ,RIGHT ,BOTTOM))))))

;;The -side- is one of :left, :top, :right or :bottom.
;;Draw a rectangle with -thickness- on the named side, with -alu- (which if NIL means
;;  don't draw)
;;Return the left,top,right,bottom of what's left.
(DEFUN WHACK-RECTANGLE (SIDE THICKNESS DRAW-ALU COLOR WINDOW LEFT TOP RIGHT BOTTOM)
  (DECLARE (VALUES LEFT TOP RIGHT BOTTOM))
  (IF (LISTP SIDE)
      (DOLIST (SIDE SIDE)
	(MULTIPLE-VALUE (LEFT TOP RIGHT BOTTOM)
	  (WHACK-RECTANGLE SIDE THICKNESS DRAW-ALU COLOR WINDOW LEFT TOP RIGHT BOTTOM)))
      (LET ((ALU (IF COLOR
		     DRAW-ALU
		     (DW::INVERSE-ALU DRAW-ALU WINDOW))))
	(SELECTQ SIDE
	  (:LEFT
	   (WHEN ALU
	     (SHEET-DRAW-RECTANGLE THICKNESS (- BOTTOM TOP) LEFT TOP ALU WINDOW))
	   (INCF LEFT THICKNESS))
	  (:RIGHT
	   (WHEN ALU
	     (SHEET-DRAW-RECTANGLE THICKNESS (- BOTTOM TOP) (- RIGHT THICKNESS) TOP ALU WINDOW))
	   (DECF RIGHT THICKNESS))
	  (:TOP
	   (WHEN ALU
	     (SHEET-DRAW-RECTANGLE (- RIGHT LEFT) THICKNESS LEFT TOP ALU WINDOW))
	   (INCF TOP THICKNESS))
	  (:BOTTOM
	   (WHEN ALU
	     (SHEET-DRAW-RECTANGLE (- RIGHT LEFT) THICKNESS LEFT (- BOTTOM THICKNESS) ALU WINDOW))
	   (DECF BOTTOM THICKNESS))
	  (OTHERWISE (FERROR "Bad side ~s" SIDE)))))
  (VALUES LEFT TOP RIGHT BOTTOM))

(DEFUN DRAW-TOP-TOMBSTONE-BORDER (WINDOW ALU LEFT TOP RIGHT BOTTOM)
  (WHACK-RECTANGLES (WINDOW ALU LEFT TOP RIGHT BOTTOM)
    (:TOP
     (*TOMBSTONE-BORDER-THICKNESS* T)
     (*TOMBSTONE-BORDER-MARGIN*)
     (*TOMBSTONE-OUTER-THICKNESS* T)
     (*TOMBSTONE-OUTER-MARGIN*)
     (*TOMBSTONE-INNER-THICKNESS* T)
     ((SECOND *TOMBSTONE-INNER-MARGINS*)))))

(DEFUN DRAW-BOTTOM-TOMBSTONE-BORDER (WINDOW ALU LEFT TOP RIGHT BOTTOM)
;;This needs to draw something like
;;   || |
;;   || |
;;   || ------
;;   =========
  (WHACK-RECTANGLES (WINDOW ALU LEFT TOP RIGHT BOTTOM)
    ((:BOTTOM :LEFT)
     (*TOMBSTONE-BORDER-THICKNESS* T)
     (*TOMBSTONE-BORDER-MARGIN*)
     (*TOMBSTONE-OUTER-THICKNESS* T)
     (*TOMBSTONE-OUTER-MARGIN*)
     (*TOMBSTONE-INNER-THICKNESS* T))
    (:LEFT
     ((FIRST *TOMBSTONE-INNER-MARGINS*)))
    (:BOTTOM
     ((FOURTH *TOMBSTONE-INNER-MARGINS*)))))

(DEFUN DRAW-LEFT-TOMBSTONE-BORDER (WINDOW ALU LEFT TOP RIGHT BOTTOM)
;;
;; =========
;; || |-----
;; || |
  (WHACK-RECTANGLES (WINDOW ALU LEFT TOP RIGHT BOTTOM)
    ((:TOP :LEFT)
     (*TOMBSTONE-BORDER-THICKNESS* T)
     (*TOMBSTONE-BORDER-MARGIN*)
     (*TOMBSTONE-OUTER-THICKNESS* T)
     (*TOMBSTONE-OUTER-MARGIN*)
     (*TOMBSTONE-INNER-THICKNESS* T))
    (:LEFT
     ((FIRST *TOMBSTONE-INNER-MARGINS*)))
    (:TOP
     ((SECOND *TOMBSTONE-INNER-MARGINS*)))))

(DEFUN DRAW-RIGHT-TOMBSTONE-BORDER (WINDOW ALU LEFT TOP RIGHT BOTTOM)
;; This needs to draw something like
;;   ======||
;;   ----| ||
;;       | ||
;;       ....
;;       ....
;;   ----| ||
;;   ======||
  (WHACK-RECTANGLES (WINDOW ALU LEFT TOP RIGHT BOTTOM)
    ((:RIGHT :TOP :BOTTOM)
     (*TOMBSTONE-BORDER-THICKNESS* T)
     (*TOMBSTONE-BORDER-MARGIN*)
     (*TOMBSTONE-OUTER-THICKNESS* T)
     (*TOMBSTONE-OUTER-MARGIN*)
     (*TOMBSTONE-INNER-THICKNESS* T))
    (:TOP
     ((SECOND *TOMBSTONE-INNER-MARGINS*)))
    (:RIGHT
     ((THIRD *TOMBSTONE-INNER-MARGINS*)))
    (:BOTTOM
     ((FOURTH *TOMBSTONE-INNER-MARGINS*)))))

#||
;;; This should be called from scrolling functions or whatever.
(DEFUN FIXUP-RAGGED-BORDERS (WINDOW)
  (MULTIPLE-VALUE-BIND (LEFT-P TOP-P RIGHT-P BOTTOM-P)
      (SEND WINDOW :RAGGED-BORDERS-P)
    (WITH-STACK-LIST (RAGGED-BORDERS LEFT-P TOP-P RIGHT-P BOTTOM-P)
      (LOOP FOR BORDER IN (SEND WINDOW :BORDERS)
	    FOR RAGGED-P IN RAGGED-BORDERS
	    DO
	(BLOCK SKIP-IT
	  (UNLESS (LISTP BORDER)		;Skip it if not well formed
	    (RETURN-FROM SKIP-IT))
	  (UNLESS (EQ RAGGED-P
		      (SELECTQ (FIRST BORDER)
			(DRAW-RAGGED-BORDER T)
			(DRAW-RECTANGULAR-BORDER NIL)
			(OTHERWISE (RETURN-FROM SKIP-IT))))
	    (SEND WINDOW :DRAW-SINGLE-BORDER BORDER :ERASE)
	    (SETF (FIRST BORDER) (IF RAGGED-P 'DRAW-RAGGED-BORDER 'DRAW-RECTANGULAR-BORDER))
	    (SEND WINDOW :DRAW-SINGLE-BORDER BORDER :DRAW)))))))

(DEFMETHOD (:DRAW-SINGLE-BORDER BORDERS-MIXIN) (BORDER ALU)
  (SETQ ALU (SELECTQ ALU
	      (:ERASE ERASE-ALUF)
	      (:DRAW CHAR-ALUF)
	      (OTHERWISE ALU)))
  (SHEET-FORCE-ACCESS (SELF)
    (AND BORDER
	 (NEQ BORDER ':ZERO)
	 (LET ((LEFT (SECOND BORDER))
	       (TOP (THIRD BORDER))
	       (RIGHT (FOURTH BORDER))
	       (BOTTOM (FIFTH BORDER)))
	   (FUNCALL (FIRST BORDER) SELF ALU
		    (IF (MINUSP LEFT) (+ LEFT WIDTH) LEFT)
		    (IF (MINUSP TOP) (+ TOP HEIGHT) TOP)
		    (IF (PLUSP RIGHT) RIGHT (+ RIGHT WIDTH))
		    (IF (PLUSP BOTTOM) BOTTOM (+ BOTTOM HEIGHT)))))))

(DEFUN DRAW-RAGGED-BORDER (WINDOW ALU LEFT TOP RIGHT BOTTOM)
  (SEND WINDOW :%DRAW-RAGGED-BORDER ALU LEFT TOP RIGHT BOTTOM)
  )

(DEFMETHOD (:%DRAW-RAGGED-BORDER BORDERS-MIXIN) (ALU LEFT TOP RIGHT BOTTOM)

  (LET ((W (- RIGHT LEFT))
	(H (- BOTTOM TOP)))
    (SETQ RIGHT (1- RIGHT)
	  BOTTOM (1- BOTTOM))
    (COND ((> W H)
	   ;; Drawing horizontal border
	   (IF ( TOP 1)
	       (SETQ BOTTOM (1+ BOTTOM))
	       (SETQ TOP (1- TOP)))
	   (DO ((SOUTH T (NOT SOUTH))
		(CUR-LEFT RIGHT)
		(CUR-L (1- RIGHT)))
	       (( CUR-LEFT LEFT)) 
	     (%DRAW-LINE CUR-LEFT (IF SOUTH TOP BOTTOM)
			 (MAX LEFT (SETQ CUR-LEFT (- CUR-LEFT 5))) (IF SOUTH BOTTOM TOP)
			 ALU NIL SELF)
	     (WHEN (> (- BOTTOM TOP) 1)
	       (%DRAW-LINE CUR-L (IF SOUTH TOP BOTTOM)
			   (MAX LEFT (SETQ CUR-L (- CUR-L 5))) (IF SOUTH BOTTOM TOP)
			   ALU NIL SELF))
	     ))
	  (T
	   ;; Drawing vertical border
	   (DO ((EAST T (NOT EAST))
		(CUR-TOP BOTTOM)
		(CUR-T (1- BOTTOM)))
	       (( CUR-TOP TOP))
	     (%DRAW-LINE (IF EAST LEFT RIGHT) CUR-TOP
			 (IF EAST RIGHT LEFT) (MAX TOP (SETQ CUR-TOP (- CUR-TOP 5)))
			 ALU NIL SELF)
	     (WHEN (> (- RIGHT LEFT) 1)
	       (%DRAW-LINE (IF EAST LEFT RIGHT) CUR-T
			   (IF EAST RIGHT LEFT) (MAX TOP (SETQ CUR-T (- CUR-T 5)))
			   ALU NIL SELF))))
	  )))
||#

(DEFFLAVOR STREAM-MIXIN ((IO-BUFFER NIL)) (SI:DISPLAY-INPUT-EDITOR ESSENTIAL-WINDOW)
  (:GETTABLE-INSTANCE-VARIABLES IO-BUFFER)
  (:INITABLE-INSTANCE-VARIABLES IO-BUFFER)
  (:DOCUMENTATION :MIXIN
   "This is the flavor of window which is designed for interacting with a human user.
    It adds input messages and input editing messages.  Any window to which TERMINAL-IO
    may be bound should be built on this flavor."))

(DEFMETHOD (:INIT STREAM-MIXIN :BEFORE) (IGNORE)
  (OR (TYPEP IO-BUFFER 'IO-BUFFER)
      (LET (SIZE INPUT-FUNCTION OUTPUT-FUNCTION)
	(IF (NUMBERP IO-BUFFER)
	    (SETQ SIZE IO-BUFFER
		  INPUT-FUNCTION NIL
		  OUTPUT-FUNCTION 'KBD-DEFAULT-OUTPUT-FUNCTION)
	    (SETQ SIZE (OR (FIRST IO-BUFFER) 100)
		  INPUT-FUNCTION (SECOND IO-BUFFER)
		  OUTPUT-FUNCTION (OR (THIRD IO-BUFFER) 'KBD-DEFAULT-OUTPUT-FUNCTION)))
 	(SETQ IO-BUFFER (MAKE-IO-BUFFER SIZE INPUT-FUNCTION OUTPUT-FUNCTION)))))

(DEFMETHOD (:SELECT STREAM-MIXIN :BEFORE) (&REST IGNORE)
  (LET ((CONSOLE (SHEET-CONSOLE SELF)))
    (WHEN CONSOLE
      (CONSOLE-CLEAR-SELECTED-IO-BUFFER CONSOLE))))

(DEFMETHOD (:DESELECT STREAM-MIXIN :BEFORE) (&REST IGNORE)
  (LET ((CONSOLE (SHEET-CONSOLE SELF)))
    (WHEN CONSOLE
      (CONSOLE-CLEAR-SELECTED-IO-BUFFER CONSOLE))))

(DEFMETHOD (:SET-IO-BUFFER STREAM-MIXIN) (NEW-BUFFER)
  (WITHOUT-INTERRUPTS
    (LET ((CONSOLE (SHEET-CONSOLE SELF)))
      (WHEN CONSOLE
	(CONSOLE-CLEAR-SELECTED-IO-BUFFER CONSOLE)))
    (SETQ IO-BUFFER NEW-BUFFER)))

(DEFMETHOD (:FORCE-KBD-INPUT STREAM-MIXIN) (CH &OPTIONAL NO-HANG-P WHOSTATE)
  (IO-BUFFER-PUT IO-BUFFER CH NO-HANG-P WHOSTATE))

(DEFMETHOD (:CLEAR-INPUT STREAM-MIXIN) ()
  (IO-BUFFER-CLEAR IO-BUFFER)
  (LET ((CONSOLE (SHEET-CONSOLE SELF)))
    (WHEN (AND CONSOLE (EQ IO-BUFFER (CONSOLE-GET-SELECTED-IO-BUFFER CONSOLE)))
      (CONSOLE-CLEAR-IO-BUFFER CONSOLE))))

(DEFMETHOD (:LISTEN STREAM-MIXIN) ()
  (LET ((CONSOLE (SHEET-CONSOLE SELF)))
    (AND CONSOLE (CONSOLE-IO-BUFFER-LISTEN CONSOLE IO-BUFFER))))

(DEFMETHOD (:UNTYI STREAM-MIXIN) (CH)
  (IO-BUFFER-UNGET IO-BUFFER CH))

;; The INTERACTIVE-STREAM :ANY-TYI and :ANY-TYI-NO-HANG whoppers filter out the EOF argument.

(DEFUN WAIT-FOR-SHEET-CONSOLE (WINDOW)
  (PROCESS-WAIT "console" #'sheet-console window)
  (sheet-console window))

(DEFMETHOD (:ANY-TYI STREAM-MIXIN) ()
  (LET ((CONSOLE (SHEET-CONSOLE SELF)))
    (UNLESS CONSOLE (SETQ CONSOLE (WAIT-FOR-SHEET-CONSOLE SELF)))
    (WHEN CONSOLE
      (MULTIPLE-VALUE-BIND (CHAR CHAR-P)
	  (CONSOLE-IO-BUFFER-GET CONSOLE IO-BUFFER T)
	(COND (CHAR-P CHAR)
	      (T (SEND SELF :NOTICE :INPUT-WAIT)
		 (CONSOLE-IO-BUFFER-GET CONSOLE IO-BUFFER)))))))

(DEFMETHOD (:ANY-TYI-NO-HANG STREAM-MIXIN) ()
  (LET ((CONSOLE (SHEET-CONSOLE SELF)))
    (WHEN CONSOLE
      (CONSOLE-IO-BUFFER-GET CONSOLE IO-BUFFER T))))

;;; This method is at the end of a chain of synonym streams and encapsulating streams
;;; It allows :INPUT-WAIT functions to minimize their working set
(DEFMETHOD (:WINDOW-FOR-INPUT-WAIT STREAM-MIXIN) () SELF)

;; Check for input available before sending the :NOTICE message so that typeahead
;; doesn't cause infinite notifications for a window on which Function 4 T has been done.

(DEFMETHOD (:INPUT-WAIT STREAM-MIXIN) (&OPTIONAL WHOSTATE FUNCTION &REST ARGUMENTS)
  (LET ((CONSOLE (SHEET-CONSOLE SELF)))
    (UNLESS CONSOLE (SETQ CONSOLE (WAIT-FOR-SHEET-CONSOLE SELF)))
    (UNLESS (CONSOLE-IO-BUFFER-LISTEN CONSOLE IO-BUFFER)
      (SEND SCREEN :FORCE-OUTPUT)
      (SEND SELF :NOTICE :INPUT-WAIT)
      (LEXPR-FUNCALL #'CONSOLE-IO-BUFFER-INPUT-WAIT CONSOLE IO-BUFFER WHOSTATE
		     FUNCTION ARGUMENTS))))

;; This portion of the input editor help message is specific to the window system.
;; The term "program" corresponds with the label which appears in the system menu.

(DEFCONST *INPUT-EDITOR-HELP-FRAME-HELP-MESSAGE*
  (FORMAT NIL
    "Press Symbol- for a list of special function keys and special character keys.~@
     Press   for a list of programs.~@
     Press   for a list of asynchronous and window operations.~%"))

(DEFCONST *INPUT-EDITOR-HELP-MESSAGE*
  (FORMAT NIL
    "Hold down Shift and click the rightmost mouse button to select the System Menu of~@
     programs and window operations."))

(DEFCONST *INPUT-EDITOR-CP-HELP-MESSAGE*
	  "Use c-? or c-// to get a list of command possibilities while entering a command.")

(DEFMETHOD (:INPUT-EDITOR-HELP STREAM-MIXIN) ()
  (WHEN (FBOUNDP 'TV:SHOW-HELP)			; Extended Help is loaded
    (SEND SELF :STRING-OUT *INPUT-EDITOR-HELP-FRAME-HELP-MESSAGE*))
  (SEND SELF :STRING-OUT *INPUT-EDITOR-HELP-MESSAGE*)
  (UNLESS (EQ CP:*DISPATCH-MODE* ':FORM-ONLY)
    (SEND SELF :FRESH-LINE)
    (SEND SELF :STRING-OUT *INPUT-EDITOR-CP-HELP-MESSAGE*)))

;;; We are in the middle of a two-phase name change for the following flavors.
;;; TRUNCATABLE-LINES-MIXIN is the new name for the mixin that makes truncation
;;;  possible but doesn't cause it unless you turn on the truncation flag.
;;; TRUNCATING-LINES-MIXIN is the new name for a new mixin that makes all lines
;;;  truncate.  It just turns the flag on and leaves it on.  This is the simpler
;;;  of the two, because you don't think about the flag: it just truncates all
;;;  your lines.
;;; LINE-TRUNCATING-MIXIN is an old name being phased out, because it does
;;;  the first thing but sounds as if it ought to do the last thing.  The
;;;  new flavors are still built on it, for two-arg TYPEP compatibility.

(DEFFLAVOR LINE-TRUNCATING-MIXIN () ()
  (:REQUIRED-FLAVORS STREAM-MIXIN)
  (:DOCUMENTATION :MIXIN "Causes stream output functions to truncate if the
SHEET-TRUNCATE-LINE-OUT-FLAG in the window is set."))

(DEFWRAPPER (:TYO LINE-TRUNCATING-MIXIN) (IGNORE . BODY)
  `(CATCH 'LINE-OVERFLOW
     . ,BODY))

(DEFMETHOD (:END-OF-LINE-EXCEPTION LINE-TRUNCATING-MIXIN :BEFORE) ()
  (OR (ZEROP (SHEET-TRUNCATE-LINE-OUT-FLAG))
      (THROW 'LINE-OVERFLOW T)))

(DEFWHOPPER (:STRING-OUT LINE-TRUNCATING-MIXIN) (STRING &OPTIONAL (START 0) END)
  (OR END (SETQ END (STRING-LENGTH STRING)))
  (DO ((I START (1+ CR-IDX))
       (CR-IDX))
      (( I END))
    (SETQ CR-IDX (STRING-SEARCH-CHAR #\CR STRING I END))
    (CATCH 'LINE-OVERFLOW
      (CONTINUE-WHOPPER STRING I (OR CR-IDX END)))
    (OR CR-IDX (RETURN NIL))
    (SEND SELF ':TYO #\CR)))

(DEFFLAVOR TRUNCATABLE-LINES-MIXIN () (LINE-TRUNCATING-MIXIN))

(DEFFLAVOR TRUNCATING-LINES-MIXIN () (TRUNCATABLE-LINES-MIXIN)
  (:DEFAULT-INIT-PLIST :TRUNCATE-LINE-OUT-FLAG 1))

(DEFFLAVOR TRUNCATING-WINDOW () (TRUNCATING-LINES-MIXIN WINDOW))

(DEFFLAVOR AUTOEXPOSING-MORE-MIXIN () ()
  (:REQUIRED-FLAVORS SHEET))

(DEFMETHOD (:MORE-EXCEPTION AUTOEXPOSING-MORE-MIXIN :BEFORE) ()
  (SEND SELF ':EXPOSE))

;;;Labels
(DEFSTRUCT (ESSENTIAL-LABEL-MIXIN :LIST (:CONSTRUCTOR NIL))
  LABEL-LEFT					;Coordinates of the label, all relative to the
  LABEL-TOP					;edges of the window
  LABEL-RIGHT
  LABEL-BOTTOM)

(DEFFLAVOR ESSENTIAL-LABEL-MIXIN ((LABEL T)) (MARGIN-HACKER-MIXIN)
  (:GETTABLE-INSTANCE-VARIABLES LABEL)
  (:INITABLE-INSTANCE-VARIABLES LABEL)
  (:REQUIRED-METHODS :PARSE-LABEL-SPEC :DRAW-LABEL)
  (:DOCUMENTATION :LOWLEVEL-MIXIN "Lowlevel LABEL handling
This flavor probably isn't any good without some other label mixin.  See LABEL-MIXIN
for the normal label handler."))

(DEFFLAVOR WINDOW-WITH-ESSENTIAL-LABEL () (STREAM-MIXIN BORDERS-MIXIN ESSENTIAL-LABEL-MIXIN
						 SELECT-MIXIN MINIMUM-WINDOW)
  (:DOCUMENTATION :COMBINATION "Simple window for special label handling
Mix this with a special type of label mixin to get the simplest usable case of that mixin."))

(DEFUN-IN-FLAVOR (COMPUTE-LABEL-POSITION ESSENTIAL-LABEL-MIXIN) (&AUX LEFT TOP RIGHT BOTTOM)
  (SETQ LEFT (LABEL-LEFT LABEL) TOP (LABEL-TOP LABEL)
	RIGHT (LABEL-RIGHT LABEL) BOTTOM (LABEL-BOTTOM LABEL))
  (SETQ BOTTOM (- BOTTOM TOP))			;Really height
  (AND (MINUSP TOP) (SETQ TOP (+ HEIGHT TOP)))
  (VALUES (IF (MINUSP LEFT) (+ WIDTH LEFT) LEFT) TOP
	  (IF (PLUSP RIGHT) RIGHT (+ WIDTH RIGHT)) (+ TOP BOTTOM)))

(DEFUN-IN-FLAVOR (ERASE-LABEL ESSENTIAL-LABEL-MIXIN) (&REST IGNORE)
  (AND LABEL
       (SHEET-FORCE-ACCESS (SELF)
	 (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
	     (COMPUTE-LABEL-POSITION)
	   (SHEET-DRAW-RECTANGLE (- RIGHT LEFT) (- BOTTOM TOP) LEFT TOP ERASE-ALUF)))))

(DEFUN-IN-FLAVOR (DRAW-LABEL ESSENTIAL-LABEL-MIXIN) (&REST IGNORE)
  (AND LABEL
       (SHEET-FORCE-ACCESS (SELF)
	 (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
	     (COMPUTE-LABEL-POSITION)
	   (SEND SELF ':DRAW-LABEL LABEL LEFT TOP RIGHT BOTTOM)))))

;;;This designed to be a subroutine of :PARSE-LABEL-SPEC messages, it makes the label
;;;into a list, onto which other things can then be added.
(DEFUN-IN-FLAVOR (PARSE-LABEL-SPEC-INTERNAL ESSENTIAL-LABEL-MIXIN)
	      (SPEC LM TM RM BM &OPTIONAL (HGT NIL HEIGHT-P) TOP-P)
  (OR HGT (SETQ HGT (SEND SCREEN :LINE-HEIGHT)))
  (COND (SPEC
	 (SETQ TOP-P (COND ((MEMQ SPEC '(:TOP :BOTTOM))
			    (EQ SPEC ':TOP))
			   ((AND (LISTP SPEC) (LABEL-TOP SPEC))
			    (NOT (MINUSP (LABEL-TOP SPEC))))
			   (T
			    TOP-P)))
	 (SETQ SPEC (IF (LISTP SPEC) (COPYLIST SPEC) (MAKE-LIST 4)))
	 (LET ((BOTTOM (LABEL-BOTTOM SPEC)) (TOP (LABEL-TOP SPEC)))
	   (AND BOTTOM TOP (NOT HEIGHT-P) (SETQ HGT (- BOTTOM TOP))))
	 (SETF (LABEL-LEFT SPEC) LM)
	 (SETF (LABEL-RIGHT SPEC) (- RM))
	 (LET ((TOP (IF TOP-P TM (- (+ BM HGT)))))
	   (SETF (LABEL-TOP SPEC) TOP)
	   (SETF (LABEL-BOTTOM SPEC) (+ TOP HGT)))
	 (IF TOP-P (SETQ TM (LABEL-BOTTOM SPEC)) (SETQ BM (- (LABEL-TOP SPEC))))))
  (VALUES SPEC LM TM RM BM))

(DEFMETHOD (:LABEL-SIZE ESSENTIAL-LABEL-MIXIN) ()
  (IF LABEL (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
		(COMPUTE-LABEL-POSITION)
	      (VALUES (- RIGHT LEFT) (- BOTTOM TOP)))
      (VALUES 0 0)))

(DEFMETHOD (:SET-LABEL ESSENTIAL-LABEL-MIXIN) (NEW-LABEL
					       &AUX (PLIST (LIST ':LABEL NEW-LABEL)))
  (SEND SELF ':REDEFINE-MARGINS (LOCF PLIST))
  (COND (RESTORED-BITS-P
	 (ERASE-LABEL)		;This has the right dimensions, even though it is the new label, because it occupies the same margin space.
	 (DRAW-LABEL))))

(DEFMETHOD (:INIT ESSENTIAL-LABEL-MIXIN :BEFORE) (INIT-PLIST)
  (ADJUST-MARGINS 'LABEL ':PARSE-LABEL-SPEC INIT-PLIST NIL))

(DEFMETHOD (:REFRESH-MARGINS ESSENTIAL-LABEL-MIXIN :AFTER) ()
  (DRAW-LABEL))

(DEFMETHOD (:REDEFINE-MARGINS ESSENTIAL-LABEL-MIXIN :BEFORE) (PLIST)
  (ADJUST-MARGINS 'LABEL ':PARSE-LABEL-SPEC PLIST ':LABEL))

(DEFSTRUCT (LABEL-MIXIN :LIST (:INCLUDE ESSENTIAL-LABEL-MIXIN) (:CONSTRUCTOR NIL)
			(:SIZE-SYMBOL LABEL-DEFSTRUCT-SIZE))
  LABEL-STYLE
  LABEL-STRING
  LABEL-VSP
  LABEL-CENTERED-P)

(DEFFLAVOR LABEL-MIXIN () (ESSENTIAL-LABEL-MIXIN)
  (:DOCUMENTATION :MIXIN "Normal LABEL handling.
This is the usual type of label a window will want, it provides for an arbitrary string
in an arbitrary font."))

(DEFMETHOD (:INIT LABEL-MIXIN :AFTER) (IGNORE)
  (AND LABEL (OR (LABEL-STRING LABEL) (SETF (LABEL-STRING LABEL) NAME))))

(DEFMETHOD (:CHOOSE-ATTRIBUTES LABEL-MIXIN) ()
  (LIST :SET-LABEL (SCL:ACCEPT '((SCL:NULL-OR-TYPE STRING)) :PROMPT "Label"
			       :PROVIDE-DEFAULT T
			       :DEFAULT (SEND SELF :LABEL))))

(DEFUN-IN-FLAVOR (PARSE-LABEL-SPEC LABEL-MIXIN) (SPEC LM TM RM BM &OPTIONAL TOP-P
						 &AUX STYLE NSPEC (CENTERED-P :DEFAULT))
  (COND (SPEC
	 (AND (LISTP SPEC) (MEMQ (CAR SPEC) '(:STRING :TOP :BOTTOM :CENTERED-P
					      :STYLE :CHARACTER-STYLE :FONT))
	      (DO ((LIST SPEC (CDR LIST))
		   (STRING NIL))
		  ((NULL LIST)
		   (SETQ SPEC (LIST NIL NIL NIL NIL STYLE STRING)))
		  (SELECTQ (CAR LIST)
		    (:STRING (SETQ STRING (CADR LIST)
				   LIST (CDR LIST)))
		    (:CENTERED-P (SETQ CENTERED-P (CADR LIST)
				       LIST (CDR LIST)))
		    ((:STYLE :CHARACTER-STYLE)
		     (SETQ STYLE (CADR LIST)
			   LIST (CDR LIST)))
		    (:FONT
		     ;; Compatibility, only.
		     (SETQ STYLE (SI:BACKTRANSLATE-FONT (CADR LIST)
							DISPLAY-DEVICE-TYPE)
			   LIST (CDR LIST)))
		    (:TOP (SETQ TOP-P T))
		    (:BOTTOM (SETQ TOP-P NIL))
		    (OTHERWISE (FERROR "~S is not a recognized keyword" (CAR LIST))))))
	 (SETQ STYLE (SI:MERGE-CHARACTER-STYLES (OR (AND (EQ (TYPEP SPEC) 'FONT)
							 (PROG1 (SI:BACKTRANSLATE-FONT
								  SPEC DISPLAY-DEVICE-TYPE)
								(SETQ SPEC T)))
						    (AND (LISTP SPEC) (LABEL-STYLE SPEC)))
						(SCREEN-DEFAULT-STYLE SCREEN)))
	 (AND (LISTP SPEC) (LABEL-TOP SPEC) (SETQ TOP-P (NOT (MINUSP (LABEL-TOP SPEC)))))
	 (LET* ((STRING (COND ((STRINGP SPEC) SPEC)
			      ((AND (LISTP SPEC) (LABEL-STRING SPEC))
			       (LABEL-STRING SPEC))
			      ((AND (ATOM SPEC) (NEQ SPEC T)) (STRING SPEC))
			      (T NAME)))
		;; Default VSP to 2
		(LABEL-VSP (OR (AND (LISTP SPEC) (LABEL-VSP SPEC)) 2))
		HGT)
	       (MULTIPLE-VALUE-BIND (NIL NIL NIL NIL TOTAL-HEIGHT)
		   (LET ((STREAM (IF (VARIABLE-BOUNDP MERGED-CURRENT-STYLE) SELF SCREEN)))
		     (LETF ((VSP LABEL-VSP))
		       (WITH-CHARACTER-STYLE (STYLE STREAM :BIND-LINE-HEIGHT T)
			 (SEND STREAM :STRING-LENGTH (OR STRING "")))))
		 (SETQ HGT (- TOTAL-HEIGHT LABEL-VSP)))
	       (MULTIPLE-VALUE (NSPEC LM TM RM BM)
		 (PARSE-LABEL-SPEC-INTERNAL SPEC LM TM RM BM HGT TOP-P))
	       (LET ((TEM (- LABEL-DEFSTRUCT-SIZE (LENGTH NSPEC))))
		 (AND (> TEM 0) (RPLACD (LAST NSPEC) (MAKE-LIST TEM))))
	       (UNLESS (EQ CENTERED-P :DEFAULT)
		 (SETF (LABEL-CENTERED-P NSPEC) CENTERED-P))	       
	       (SETF (LABEL-STYLE NSPEC) STYLE)
	       (SETF (LABEL-VSP NSPEC) LABEL-VSP)
	       (OR (LABEL-STRING NSPEC)
		   (SETF (LABEL-STRING NSPEC) STRING)))
	 (SETQ SPEC NSPEC)))
  (VALUES SPEC LM TM RM BM))

(DEFMETHOD (:PARSE-LABEL-SPEC LABEL-MIXIN) (SPEC LM TM RM BM &OPTIONAL TOP-P)
  (PARSE-LABEL-SPEC SPEC LM TM RM BM TOP-P))

(DEFMETHOD (:DRAW-LABEL LABEL-MIXIN) (SPEC LEFT TOP RIGHT BOTTOM)
  BOTTOM
  (WHEN SPEC
    (TV:WITH-MARGIN-OUTPUT (SELF)
      (DO ((CHAR-POS 0) (NEXT-NEWLINE)
	   (STRING (LABEL-STRING SPEC))
	   (STYLE (LABEL-STYLE SPEC))
	   (SLEN (STRING-LENGTH (LABEL-STRING SPEC))))
	  (( CHAR-POS SLEN))
	(SETQ NEXT-NEWLINE (STRING-SEARCH-CHAR #\NEWLINE STRING CHAR-POS))
	(WITH-CHARACTER-STYLE (STYLE SELF :BIND-LINE-HEIGHT T)
	  (MULTIPLE-VALUE-BIND (NIL INDEX WID NIL LINE-HEIGHT BASELINE)
	      (SEND SELF :STRING-LENGTH STRING CHAR-POS NEXT-NEWLINE RIGHT STYLE
		    0 (- RIGHT LEFT))
	    (UNLESS INDEX (SETQ INDEX NEXT-NEWLINE))
	    (LET ((LEFT (MAX LEFT
			     (IF (LABEL-CENTERED-P SPEC)
				 (+ LEFT (// (- RIGHT LEFT WID) 2))
				 -1))))
	      (TV:WITH-CURRENT-BASELINE (SELF BASELINE)
		(SEND SELF :STRING-OUT-EXPLICIT STRING LEFT TOP RIGHT CHAR-ALUF
		      CHAR-POS INDEX)))
	    (SETQ CHAR-POS (IF NEXT-NEWLINE (1+ NEXT-NEWLINE) SLEN)
		  TOP (+ TOP LINE-HEIGHT))))))))

(DEFMETHOD (:LABEL-SIZE LABEL-MIXIN) ()
  (IF LABEL
      (DO ((MAX 0) (CHAR-POS 0) (NEXT-NEWLINE)
	   (STRING (LABEL-STRING LABEL))
	   (SLEN (STRING-LENGTH (LABEL-STRING LABEL))))
	  (( CHAR-POS SLEN)
	   (VALUES MAX (- (LABEL-BOTTOM LABEL) (LABEL-TOP LABEL))))
	(SETQ NEXT-NEWLINE (STRING-SEARCH-CHAR #\NEWLINE STRING CHAR-POS))
	(LET ((NEXT-LINE (SUBSTRING STRING CHAR-POS NEXT-NEWLINE)))
	  (SETQ MAX (MAX MAX (SEND SELF ':STRING-LENGTH NEXT-LINE 0 NIL NIL
					(LABEL-STYLE LABEL))))
	  (RETURN-ARRAY NEXT-LINE))
	(SETQ CHAR-POS (IF NEXT-NEWLINE (1+ NEXT-NEWLINE) SLEN)))
      (VALUES 0 0)))

(DEFFLAVOR DELAYED-REDISPLAY-LABEL-MIXIN ((LABEL-NEEDS-UPDATING NIL)) (LABEL-MIXIN)
  (:READABLE-INSTANCE-VARIABLES LABEL-NEEDS-UPDATING)
  (:DOCUMENTATION :MIXIN "Delays the setting of the label until a normal redisplay loop.
Send a :DELAYED-SET-LABEL to cause the label to be changed when a :UPDATE-LABEL message
is sent.  This is especially useful for things with suppressed redisplay for typeahead,
where the user's typein may change the label several times, and where the label wants to
change along with the rest of the window."))

(DEFMETHOD (:DELAYED-SET-LABEL DELAYED-REDISPLAY-LABEL-MIXIN) (NEW-LABEL)
  (SETQ LABEL-NEEDS-UPDATING (OR NEW-LABEL 'NULL)))	;No label versus no updating

(DEFMETHOD (:UPDATE-LABEL DELAYED-REDISPLAY-LABEL-MIXIN) ()
  (WHEN LABEL-NEEDS-UPDATING
    (SEND SELF ':SET-LABEL (IF (EQ LABEL-NEEDS-UPDATING 'NULL) NIL LABEL-NEEDS-UPDATING))
    (SETQ LABEL-NEEDS-UPDATING NIL)))

(DEFFLAVOR TOP-LABEL-MIXIN () (LABEL-MIXIN)
  (:DOCUMENTATION :MIXIN "Label positioned at the top
If the label is specified only as a string or defaults to the name of the window, it
will be at the top of the window."))

(DEFMETHOD (:PARSE-LABEL-SPEC TOP-LABEL-MIXIN) (SPEC LM TM RM BM)
  (PARSE-LABEL-SPEC SPEC LM TM RM BM T))

(DEFFLAVOR TOP-BOX-LABEL-MIXIN () (LABEL-MIXIN)
  (:DOCUMENTATION :MIXIN "Label at the top, with a line underneath
If the label is a string or defaults to the name, it is at the top.
When combined with BORDERS-MIXIN, the label will be surrounded by a box."))

(DEFMETHOD (:PARSE-LABEL-SPEC TOP-BOX-LABEL-MIXIN) (SPEC LM TM RM BM)
  (MULTIPLE-VALUE (SPEC LM TM RM BM)
    (PARSE-LABEL-SPEC SPEC LM TM RM BM T))
  (AND SPEC (SETQ TM (1+ TM)))
  (VALUES SPEC LM TM RM BM))

(DEFMETHOD (:DRAW-LABEL TOP-BOX-LABEL-MIXIN :AFTER) (SPEC LEFT TOP RIGHT BOTTOM)
  SPEC TOP
  (SHEET-FORCE-ACCESS (SELF)
    (SHEET-DRAW-RECTANGLE (- RIGHT LEFT) 1 LEFT (1- BOTTOM) CHAR-ALUF)))

(DEFFLAVOR BOTTOM-BOX-LABEL-MIXIN () (LABEL-MIXIN)
  (:DOCUMENTATION :MIXIN "Label at the bottom, with a line above.
If the label is a string or defaults to the name, it is at the bottom.
When combined with BORDERS-MIXIN, the label will be surrounded by a box."))

(DEFMETHOD (:PARSE-LABEL-SPEC BOTTOM-BOX-LABEL-MIXIN) (SPEC LM TM RM BM)
  (MULTIPLE-VALUE (SPEC LM TM RM BM)
    (PARSE-LABEL-SPEC SPEC LM TM RM BM))
  (AND SPEC (SETQ BM (+ 2 BM)))
  (VALUES SPEC LM TM RM BM))

(DEFMETHOD (:DRAW-LABEL BOTTOM-BOX-LABEL-MIXIN :AFTER) (SPEC LEFT TOP RIGHT BOTTOM)
  SPEC BOTTOM
  (SHEET-FORCE-ACCESS (SELF)
    (SHEET-DRAW-RECTANGLE (- RIGHT LEFT) 1 LEFT (1- TOP) CHAR-ALUF)))


(DEFFLAVOR CENTERED-LABEL-MIXIN () (LABEL-MIXIN)
  (:DOCUMENTATION :MIXIN "Mixing this into anything built on LABEL-MIXIN centers the label"))

(DEFWHOPPER (:PARSE-LABEL-SPEC CENTERED-LABEL-MIXIN) (&REST ARGS)
  (MULTIPLE-VALUE-BIND (SPEC LM TM RM BM)
      (LEXPR-CONTINUE-WHOPPER ARGS)
    (AND SPEC (SETF (LABEL-CENTERED-P SPEC) T))
    (VALUES SPEC LM TM RM BM)))


;;; Flavor that allows you to change the name of the window, and 
;;; if the label is the same as the name, changes the label, too.
(DEFFLAVOR CHANGEABLE-NAME-MIXIN () (LABEL-MIXIN)
  (:DOCUMENTATION :MIXIN "Allows setting of name via :SET-NAME
Also changes the label if it happens to be the same."))

(DEFMETHOD (:NAME CHANGEABLE-NAME-MIXIN) () NAME)

(DEFMETHOD (:SET-NAME CHANGEABLE-NAME-MIXIN) (NEW-NAME)
  (LET ((LABEL-EQUALS-NAME (AND LABEL (EQ (LABEL-STRING LABEL) NAME))))
    (SETQ NAME NEW-NAME)
    (COND (LABEL-EQUALS-NAME
	   (SETF (LABEL-STRING LABEL) NEW-NAME)
	   (SHEET-FORCE-ACCESS (SELF T)
	     (ERASE-LABEL)
	     (DRAW-LABEL))))))

(DEFMETHOD (:CHOOSE-ATTRIBUTES CHANGEABLE-NAME-MIXIN) ()
  (LIST :SET-NAME (SCL:ACCEPT 'STRING :PROMPT "Name of window" :DEFAULT NAME)))


;;; Margin space mixin.

;;; This flavor provides a margin item that just leaves some blank space.
;;; It's useful if you're using scroll bars, and you want to leave a little
;;; white space between the scroll bar and the inside of the window, for instance.

;;; The value of the :MARGIN-SPACE init option can be:
;;;   NIL - no space
;;;   T - one pixel of space on each edge
;;;   <n> (a fixnum) - n pixels of space on each edge
;;;   (<l> <t> <r> <b>) (a list of four fixna) - that much space on each edge.
;;;    Example: (2 0 0 0) means to leave two pixels of space on the left
;;;    edge and none on the other edges.
;;;    :MARGIN-SPACE and :SET-MARGIN-SPACE also exist.

(DEFFLAVOR MARGIN-SPACE-MIXIN ((MARGIN-SPACE 1)) (TV:MARGIN-HACKER-MIXIN)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:INIT MARGIN-SPACE-MIXIN :BEFORE) (INIT-PLIST)
  (TV:ADJUST-MARGINS 'MARGIN-SPACE ':PARSE-MARGIN-SPACE-SPEC INIT-PLIST NIL))

(DEFMETHOD (:REDEFINE-MARGINS MARGIN-SPACE-MIXIN :BEFORE) (PLIST)
  (TV:ADJUST-MARGINS 'MARGIN-SPACE ':PARSE-MARGIN-SPACE-SPEC PLIST ':MARGIN-SPACE))

(DEFMETHOD (:SET-MARGIN-SPACE MARGIN-SPACE-MIXIN) (NEW-MARGIN-SPACE)
  (LET ((PLIST (LIST ':MARGIN-SPACE NEW-MARGIN-SPACE)))
    (SEND SELF ':REDEFINE-MARGINS (LOCF PLIST))))

(DEFMETHOD (:PARSE-MARGIN-SPACE-SPEC MARGIN-SPACE-MIXIN) (SPEC LM TM RM BM)
  (SETQ SPEC (COND ((NULL SPEC) (COPYLIST '(0 0 0 0)))
		   ((EQ SPEC T) (COPYLIST '(1 1 1 1)))
		   ((FIXP SPEC) (LIST SPEC SPEC SPEC SPEC))
		   ((NOT (AND (LISTP SPEC) (= (LENGTH SPEC) 4)))
		    (FERROR "~S is not a valid margin space spec" SPEC))
		   (T (COPYLIST SPEC))))
  (VALUES SPEC
	  (+ LM (FIRST SPEC)) (+ TM (SECOND SPEC))
	  (+ RM (THIRD SPEC)) (+ BM (FOURTH SPEC))))

(DEFUN LOWEST-SHEET-UNDER-POINT (SHEET X Y &OPTIONAL OPERATION (ACTIVE-CONDITION ':ACTIVE))
  "Return the sheet lowest in the sheet hierarchy which contains the given point."
  ;; Trace down to find the lowest sheet under the point
  (DO-NAMED FOO
      ((X X (- X (SHEET-X SHEET)))
       (Y Y (- Y (SHEET-Y SHEET))))
      (NIL)
    (DO ((INFERIORS (IF (EQ ACTIVE-CONDITION ':EXPOSED) (SHEET-EXPOSED-INFERIORS SHEET)
							(SHEET-INFERIORS SHEET))
		    (CDR INFERIORS))
	 (INFERIOR))
	((NULL INFERIORS)
	 (RETURN-FROM FOO))
      (SETQ INFERIOR (CAR INFERIORS))
      (COND ((AND (NOT (SHEET-INVISIBLE-TO-MOUSE-P INFERIOR))
		  ( X (SHEET-X INFERIOR)) ( Y (SHEET-Y INFERIOR))
		  (< X (+ (SHEET-X INFERIOR) (SHEET-WIDTH INFERIOR)))
		  (< Y (+ (SHEET-Y INFERIOR) (SHEET-HEIGHT INFERIOR)))
		  (SELECTQ ACTIVE-CONDITION
		    (:ACTIVE (OR (SHEET-EXPOSED-P INFERIOR)
				 (SEND INFERIOR ':SCREEN-MANAGE-DEEXPOSED-VISIBILITY)))
		    (:EXPOSED (NOT (SHEET-OUTPUT-HELD-P INFERIOR)))
		    (OTHERWISE T)))
	     (SETQ SHEET INFERIOR)
	     (RETURN T)))))
  (IF (NULL OPERATION) SHEET
      ;; Now trace back up until we find someone to handle the message
      (DO SHEET SHEET (SHEET-SUPERIOR SHEET) (NULL SHEET)
	(AND (GET-HANDLER-FOR SHEET OPERATION)
	     (RETURN SHEET)))))

(DEFFLAVOR TEMPORARY-WINDOW-MIXIN () (ESSENTIAL-WINDOW)
  (:DOCUMENTATION :LOWLEVEL-MIXIN "Windows that save bits underneath and lock when exposed
Causes the temporary-bit-array instance variable to get set, which makes sheet exposure
behave appropriately."))

(DEFMETHOD (:INIT TEMPORARY-WINDOW-MIXIN :AFTER) (IGNORE)
  (OR (AND (VARIABLE-BOUNDP TEMPORARY-BIT-ARRAY) TEMPORARY-BIT-ARRAY)
      ;; T means will get created when needed
      (SETQ TEMPORARY-BIT-ARRAY T)))

(DEFUN WINDOW-PUSH (WINDOW NEW-TYPE &REST INIT-PAIRS
			            &AUX NEW-WINDOW INIT-PLIST STATUS)
  (SETQ INIT-PAIRS (COPYLIST INIT-PAIRS))	;There should be a comment here saying why
  (SETQ INIT-PLIST (LOCF INIT-PAIRS))
  (LOCK-SHEET (WINDOW)
    (SETQ STATUS (SEND WINDOW ':STATUS))
    ;; Window we are "pushing" gets deactivated
    (DELAYING-SCREEN-MANAGEMENT
      (PUTPROP INIT-PLIST (SHEET-SUPERIOR WINDOW) ':SUPERIOR)
      (PUTPROP INIT-PLIST (SHEET-X-OFFSET WINDOW) ':LEFT)
      (PUTPROP INIT-PLIST (SHEET-Y-OFFSET WINDOW) ':TOP)
      (PUTPROP INIT-PLIST (SHEET-HEIGHT WINDOW) ':HEIGHT)
      (PUTPROP INIT-PLIST (SHEET-WIDTH WINDOW) ':WIDTH)
      (AND (SI:FLAVOR-ALLOWS-INIT-KEYWORD-P NEW-TYPE ':PROCESS)
	   (GET-HANDLER-FOR WINDOW ':PROCESS)
	   (PUTPROP INIT-PLIST (SEND WINDOW ':PROCESS) ':PROCESS))
      (SETQ NEW-WINDOW (LEXPR-FUNCALL #'MAKE-WINDOW NEW-TYPE (CAR INIT-PLIST)))
      (CHANGE-IN-PREVIOUSLY-SELECTED-WINDOWS WINDOW NEW-WINDOW)
      (SEND WINDOW ':DEACTIVATE)
      (SCREEN-CONFIGURATION-HAS-CHANGED WINDOW)
      (SEND NEW-WINDOW ':SET-STATUS STATUS)	;Activate, expose, or select
      (SCREEN-CONFIGURATION-HAS-CHANGED NEW-WINDOW))
    NEW-WINDOW))

(DEFUN WINDOW-POP (OLD-WINDOW WINDOW)
  (LOCK-SHEET (WINDOW)
    (DELAYING-SCREEN-MANAGEMENT
      ;; Put back most of the sheet
      (LET ((STATUS (SEND WINDOW ':STATUS))
	    (SUPERIOR (SHEET-SUPERIOR WINDOW))
	    (X (SHEET-X-OFFSET WINDOW))
	    (Y (SHEET-Y-OFFSET WINDOW))
	    (W (SHEET-WIDTH WINDOW))
	    (H (SHEET-HEIGHT WINDOW)))
	(CHANGE-IN-PREVIOUSLY-SELECTED-WINDOWS WINDOW OLD-WINDOW)
	(SEND WINDOW ':DEACTIVATE)
	(SEND OLD-WINDOW ':SET-SUPERIOR SUPERIOR)
	(COND ((AND (SEND OLD-WINDOW ':SET-SIZE W H ':VERIFY)
		    (SHEET-BOUNDS-WITHIN-SHEET-P X Y W H SUPERIOR))
	       ;; Legal to set new edges, do it
	       (SEND OLD-WINDOW ':SET-POSITION X Y)
	       (SEND OLD-WINDOW ':SET-SIZE W H)))
	(SEND OLD-WINDOW ':SET-STATUS STATUS)))))

(DEFFLAVOR FULL-SCREEN-HACK-MIXIN ((OLD-BORDERS NIL) (OLD-LABEL NIL)) (SHEET)
  (:REQUIRED-METHODS :LABEL :SET-LABEL :BORDERS :SET-BORDERS)
  (:DOCUMENTATION :MIXIN "Has borders and labels only when not the full size of the screen
For windows like the initial lisp listener which frequently occupy the whole screen and
are immediately recognizable."))

(DEFUN-IN-FLAVOR (FULL-SCREEN-HACK FULL-SCREEN-HACK-MIXIN) (LEFT TOP WID HEI)
  (LET ((LABEL (SEND SELF :LABEL))
	(BORDERS (SEND SELF :BORDERS)))
    (COND ((AND (= LEFT (SHEET-INSIDE-LEFT SUPERIOR))
		(= TOP (SHEET-INSIDE-TOP SUPERIOR))
		(= WID (SHEET-INSIDE-WIDTH SUPERIOR))
		(= HEI (SHEET-INSIDE-HEIGHT SUPERIOR)))
	   (COND ((AND LABEL (NULL OLD-LABEL))
		  (SETQ OLD-LABEL LABEL)
		  (SEND SELF ':SET-LABEL NIL)))
	   (COND ((AND BORDERS (NULL OLD-BORDERS))
		  (SETQ OLD-BORDERS BORDERS)
		  (SEND SELF ':SET-BORDERS NIL))))
	  (T
	   (COND ((AND OLD-BORDERS (NULL BORDERS))
		  (SEND SELF ':SET-BORDERS OLD-BORDERS)
		  (SETQ OLD-BORDERS NIL)))
	   (COND ((AND OLD-LABEL (NULL LABEL))
		  (SEND SELF ':SET-LABEL OLD-LABEL)
		  (SETQ OLD-LABEL NIL)))))))

;;;This unfortunately has to redefine the sheet, since the width and height are not known
;;;at (:BEFORE :INIT) time.
(DEFMETHOD (:INIT FULL-SCREEN-HACK-MIXIN :AFTER) (IGNORE)
  (FULL-SCREEN-HACK X-OFFSET Y-OFFSET WIDTH HEIGHT))

(DEFMETHOD (:CHANGE-OF-SIZE-OR-MARGINS FULL-SCREEN-HACK-MIXIN :BEFORE) (&REST OPTIONS)
  (SHEET-FORCE-ACCESS (SELF)
    (ERASE-MARGINS))				;Insure that old margins get erased
  (AND (CL:GETF OPTIONS ':LEFT)
       (FULL-SCREEN-HACK (CL:GETF OPTIONS ':LEFT) (CL:GETF OPTIONS ':TOP)
			 (CL:GETF OPTIONS ':WIDTH) (CL:GETF OPTIONS ':HEIGHT))))

;;;

(DEFFLAVOR PROCESS-MIXIN ((PROCESS NIL)) (ESSENTIAL-WINDOW)
  ;;(:GETTABLE-INSTANCE-VARIABLES PROCESS)
  (:INITABLE-INSTANCE-VARIABLES PROCESS)
  (:DOCUMENTATION :MIXIN "For windows with a particular process associated with them
The process can be specified as a list of the function and arguments to make-stack-group.
When the window is selected, the who line is updated for the state of the process.
When the window is exposed or selected, if the process is flushed, it gets reset and
can run again.  The process gets a RUN-REASON of the window itself, but doesn't get
it until the window is first exposed or selected.  It is mostly
ok for the PROCESS to be NIL even when this flavor is included."))

;;; This is explicit to ensure shadowing
(DEFMETHOD (:PROCESS PROCESS-MIXIN) () PROCESS)

(DEFMETHOD (:INIT PROCESS-MIXIN :AFTER) (IGNORE)
  (AND (LISTP PROCESS)
       (LET ((PRESET PROCESS))
	 (SETQ PROCESS (LEXPR-FUNCALL #'MAKE-PROCESS NAME (CDR PRESET)))
	 (PROCESS-PRESET PROCESS (CAR PRESET) SELF)))
  ;; Assume that a window with both and io-buffer and a process is going
  ;; to commission the process to read from the io-buffer.  This gets
  ;; things set as soon as possible.
  (LET ((IB (SEND-IF-HANDLES SELF :IO-BUFFER)))
    (WHEN IB
      (SETF (IO-BUFFER-LAST-OUTPUT-PROCESS IB) PROCESS))))

(DEFUN MAYBE-RESET-WINDOW-PROCESS (SHEET PROCESS &KEY SELECT (REASON SHEET))
  ;; Only touch the process if the window is going to become visible.  This
  ;; makes many of the processes in the initial cold-load not have run reasons
  ;; until you first select their window.  This makes booting faster (pages less).
  ;; Also this is necessary to make the editor work:
  ;; What was happening was that when the editor created its first
  ;; pane and exposed it within its deactivated frame, the editor's process was
  ;; being prematurely started up when it didn't even have all its instance
  ;; variables yet, never mind enough editor environment set up.  The editor
  ;; process would thus immediately get an error, which would later be reset
  ;; asynchronously, leaving a second-level error handler around forever.
  (WHEN (AND (OR SELECT
		 (LOOP FOR SUP = (SHEET-SUPERIOR SHEET)
			       THEN (SHEET-SUPERIOR SUP)
		       UNTIL (NULL SUP)
		       ALWAYS (SHEET-EXPOSED-P SUP)))
	     (PROCESS:PROCESS-P PROCESS))
    ;; If we really have a process (not just NIL or something),
    ;; Reset the process if it is flushed, then make sure it has a run reason.
    (COND ((NOT *WINDOW-INITIALIZATIONS-RUN*)
	   (PUSH (LIST PROCESS REASON) *WINDOW-DELAYED-PROCESSES*))
	  (SI:*DELAYING-PROCESSES*
	   (PUSH (LIST PROCESS REASON) SI:DELAYED-RESTART-PROCESSES))
	  (T
	   (WHEN (PROCESS:FLUSHED-P PROCESS)
	     (PROCESS:RESET PROCESS :IF-WITHOUT-ABORTS T))
	   (PROCESS:ENABLE-RUN-REASON PROCESS REASON)))))

(DEFUN START-WINDOW-DELAYED-PROCESSES ()
  (DOLIST (ENTRY *WINDOW-DELAYED-PROCESSES*)
    (IF SI:*DELAYING-PROCESSES*
	(PUSH ENTRY SI:DELAYED-RESTART-PROCESSES)
	(CL:APPLY #'PROCESS:ENABLE-RUN-REASON ENTRY)))
  (SETF *WINDOW-DELAYED-PROCESSES* NIL))

;;; *** This is a horrible crock.  If the "program system" is ever implemented,
;;; *** this should be flushed and replaced by the concept that selecting a program
;;; *** does something appropriate to its processes.
;;; I dont know if this is really the right thing
(DEFMETHOD (:EXPOSE PROCESS-MIXIN :BEFORE) (&REST IGNORE)
  (MAYBE-RESET-WINDOW-PROCESS SELF PROCESS))

(DEFMETHOD (:SELECT PROCESS-MIXIN :BEFORE) (&OPTIONAL IGNORE)
  (MAYBE-RESET-WINDOW-PROCESS SELF PROCESS :SELECT T))

(DEFMETHOD (:PRESTART-PROCESS PROCESS-MIXIN) ()
  ;; This is to make it have a bit save array if requested, so that it can output.
  (WHEN (EQ (SEND SELF :SAVE-BITS) :DELAYED)
    (SEND SELF :SET-SAVE-BITS T))
  (MAYBE-RESET-WINDOW-PROCESS SELF PROCESS :SELECT T))

;Don't kill the process until all methods
;and wrappers have run first.  This is because we might be
;executing inside the process that belongs to the window,
;and we don't want to go away before finishing.
(DEFWRAPPER (:KILL PROCESS-MIXIN) (() . BODY)
  `(PROGN ,@BODY
	  (WHEN PROCESS
	    (WHEN (EQ PROCESS *SELECTED-PROCESS*)
	      (SETQ *SELECTED-PROCESS* NIL))
	    (PROCESS-KILL PROCESS))))

(DEFMETHOD (:RESET-PROCESS PROCESS-MIXIN) ()
  (WHEN PROCESS
    (PROCESS-RESET PROCESS)))

(DEFUN SHUTDOWN-WINDOW-PROCESS (PROCESS)
  (COND (*WINDOW-INITIALIZATIONS-RUN*
	 (PROCESS:RESET-AND-RELEASE-RESOURCES PROCESS :IF-WITHOUT-ABORTS T))
	(T
	 (SETF SI:DELAYED-RESTART-PROCESSES
	       (CL:DELETE PROCESS SI:DELAYED-RESTART-PROCESSES :KEY #'FIRST))
	 (SETF *WINDOW-DELAYED-PROCESSES*
	       (CL:DELETE PROCESS *WINDOW-DELAYED-PROCESSES* :KEY #'FIRST))))
  NIL)

(DEFMETHOD (:SHUTDOWN-ACTIVITY PROCESS-MIXIN) ()
  (WHEN PROCESS
    (SHUTDOWN-WINDOW-PROCESS PROCESS)))

;;;

(DEFFLAVOR INTERACTOR-MIXIN () ()
  (:DOCUMENTATION :SPECIAL-PURPOSE "A window or pane in which user interaction is performed."))

(DEFMETHOD (:INTERACTOR-P INTERACTOR-MIXIN) () T)

;; All Interactors are subject to getting their histories cleared by GC Cleanup.
(DEFMETHOD (:CLEAR-HISTORY INTERACTOR-MIXIN :DEFAULT) () ())

(DEFFLAVOR LISTENER-MIXIN-INTERNAL
	()
	(PROCESS-MIXIN SI:STANDARD-VALUE-ENVIRONMENT-MIXIN)
  (:DOCUMENTATION :SPECIAL-PURPOSE "An actual LISP window
Includes a process that will run the lisp top level read-eval-print loop.
Use this rather than LISTENER-MIXIN when you want to be invisible to the SYSTEM L key."))

(DEFMETHOD (:INIT LISTENER-MIXIN-INTERNAL :BEFORE) (IGNORE)
  (OR PROCESS (SETQ PROCESS '(SI:LISP-TOP-LEVEL1))))

(DEFFLAVOR LISTENER-MIXIN () (INTERACTOR-MIXIN LISTENER-MIXIN-INTERNAL)
  (:DOCUMENTATION :SPECIAL-PURPOSE "An actual LISP window
Includes a process that will run the lisp top level read-eval-print loop.
Use this when you want to be visible to the SYSTEM L key."))

(DEFMETHOD (:LISP-LISTENER-P LISTENER-MIXIN) () T)

(DEFFLAVOR LISP-INTERACTOR () (LISTENER-MIXIN-INTERNAL WINDOW)
  (:DEFAULT-INIT-PLIST :SAVE-BITS T :AUTO-LINE-HEIGHT T)
  (:DOCUMENTATION :COMBINATION "LISP window, but not LISP-LISTENER-P"))


(DEFFLAVOR LISP-LISTENER () (LISTENER-MIXIN WINDOW)
  (:DEFAULT-INIT-PLIST :SAVE-BITS T :AUTO-LINE-HEIGHT T :BORDER-MARGIN-WIDTH 2)
  (:DOCUMENTATION :COMBINATION "Normal LISP window"))

;;; There are occasions when a window gets automatically created.  Unfortunately,
;;; in this case it is not known what size the user wants the window to be.
;;; It is fairly inconvenient to change the size of the window by hand.
(DEFFLAVOR AUTOMATICALLY-CREATED-WINDOW-MIXIN ((HAVE-EDGES NIL)) (ESSENTIAL-WINDOW)
  (:DOCUMENTATION :MIXIN
"arranges for a window to ask what size it should be when it gets selected for the first time
The new edges will be specified with the mouse the same way as Create in the system menu"))

(DEFMETHOD (:SELECT AUTOMATICALLY-CREATED-WINDOW-MIXIN :BEFORE) (&REST IGNORE)
  (OR HAVE-EDGES
      (LEXPR-SEND SELF ':SET-EDGES
		  (MULTIPLE-VALUE-LIST
		    (MOUSE-SPECIFY-RECTANGLE X-OFFSET Y-OFFSET
					     (+ X-OFFSET WIDTH) (+ Y-OFFSET HEIGHT)
					     SUPERIOR))))
  (SETQ HAVE-EDGES T))

(DEFFLAVOR AUTOMATICALLY-CREATED-LISP-LISTENER ()
  (AUTOMATICALLY-CREATED-WINDOW-MIXIN LISP-LISTENER)
  (:DOCUMENTATION :COMBINATION))

(DEFFLAVOR POP-UP-TEXT-WINDOW () (TEMPORARY-WINDOW-MIXIN WINDOW)
  (:DOCUMENTATION :COMBINATION "A simple temporary window for stream type output
Useful for things like [ESC] F or qsend, which just want a tv type stream that will not
disturb things underneath."))

(DEFFLAVOR TRUNCATING-POP-UP-TEXT-WINDOW () (TEMPORARY-WINDOW-MIXIN TRUNCATING-WINDOW)
  (:DOCUMENTATION :COMBINATION "A pop up window what truncates lines"))

(DEFFLAVOR RESET-ON-OUTPUT-HOLD-FLAG-MIXIN () ()
  (:DEFAULT-INIT-PLIST :DEEXPOSED-TYPEOUT-ACTION '(:RESET-ON-OUTPUT-HOLD-FLAG)))

(DEFMETHOD (:RESET-ON-OUTPUT-HOLD-FLAG RESET-ON-OUTPUT-HOLD-FLAG-MIXIN) ()
  (PROCESS-RESET CURRENT-PROCESS :ALWAYS NIL :FORCE))

(DEFFLAVOR TRUNCATING-POP-UP-TEXT-WINDOW-WITH-RESET ()
	   (RESET-ON-OUTPUT-HOLD-FLAG-MIXIN TRUNCATING-POP-UP-TEXT-WINDOW))

;;; This mixin is useful for those windows that are created during the world-load.
;;; It is disconcerting when you suddenly see them appearing after you reshape
;;; some window.  This mixin causes them to be invisible and immune to autoexposure.
;;; They don't appear on the screen until you explicitly ask for them.  However, they
;;; are still active and appear on the Select menu.
(DEFFLAVOR INITIALLY-INVISIBLE-MIXIN () ()
  (:DEFAULT-INIT-PLIST :PRIORITY -2))

(DEFMETHOD (:EXPOSE INITIALLY-INVISIBLE-MIXIN :BEFORE) (&REST IGNORE)
  ;; If the priority has been altered since creation, don't clear it.
  (LET ((PRIORITY (SEND SELF :PRIORITY)))
    (WHEN (AND PRIORITY (< PRIORITY 0))
      (SEND SELF ':SET-PRIORITY NIL))))

;;For compatibility
(DEFFLAVOR POP-UP-NOTIFICATION-MIXIN () ())
(DEFFLAVOR NOTIFICATION-MIXIN () ())

;;; Resource to supply reasonably sized bit arrays.  This is especially useful
;;; for window-bind type windows that don't want to go through the overhead of
;;; creating a new bit array every time they get invoked
(DEFRESOURCE BIT-ARRAYS (&OPTIONAL (WIDTH (SHEET-WIDTH DEFAULT-SCREEN))
				   (HEIGHT (SHEET-HEIGHT DEFAULT-SCREEN)))
  :CONSTRUCTOR (MAKE-ARRAY (LIST WIDTH HEIGHT) ':TYPE 'ART-1B)
  :INITIAL-COPIES 0)

;;; To be called by functions like ED.
;;; If you want to await the re-exposure of the Lisp listener after activating
;;; some other window, call this.  Usually it does nothing, but if the TERMINAL-IO
;;; window is an auto-exposing window, if you didn't call this you would get into
;;; a loop where two windows were fighting for exposure, each de-exposing the other.
;;; If that would happen this function causes a wait until TERMINAL-IO is exposed.
;;;
;;; Actually, what's more important is that some people use input notification,
;;; usually in Terminal-4-T mode, and this prevents the notification when it isn't
;;; wanted.
(DEFUN AWAIT-WINDOW-EXPOSURE ()
  (WHEN (TYPEP TERMINAL-IO 'SHEET)		;No-op if terminal-io isn't a window.
    (LET ((WINDOW TERMINAL-IO))
      ;; This kludge is because there is no activity system.  Programs that use
      ;; frames generally use a typeout window as TERMINAL-IO, and it normally
      ;; doesn't ever get exposed.  So use its superior instead.
      (UNLESS (SEND WINDOW :SEND-IF-HANDLES :AWAIT-EXPOSURE)	;for live windows
	(WHEN (TYPEP WINDOW 'TV:BASIC-TYPEOUT-WINDOW)
	  (SETQ WINDOW (SEND WINDOW ':SUPERIOR)))
	(UNLESS (EQ (SHEET-DEEXPOSED-TYPEOUT-ACTION WINDOW) ':NORMAL)
	  (PROCESS-WAIT "Await Exposure" #'SHEET-EXPOSED-P WINDOW)))))
  T)
