;;; -*- Syntax: Zetalisp; Mode: LISP; Package: TV; Base: 10; Lowercase: Yes -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; The screen editor

(defun mouse-set-sheet-then-call (sheet function &rest args
				  &aux (old-mouse-sheet (mouse-sheet (sheet-mouse sheet))))
  (unwind-protect
    (progn
      (and (neq old-mouse-sheet sheet)
	   (mouse-set-sheet sheet))
      (apply function args))
    (and (neq (mouse-sheet (sheet-mouse sheet)) old-mouse-sheet)
	 (mouse-set-sheet old-mouse-sheet))))

(defun mouse-specify-rectangle-set-sheet (&optional left top right bottom (sheet mouse-sheet)
					            (minimum-width 0) (minimum-height 0)
						    abortable)
  (mouse-set-sheet-then-call sheet #'mouse-specify-rectangle left top right bottom sheet
			     minimum-width minimum-height abortable))

(defun mouse-specify-rectangle (&optional left top right bottom (sheet mouse-sheet)
					  (minimum-width 0) (minimum-height 0) abortable
				&aux (mouse (sheet-mouse sheet))
				     left1 top1 width height button abort mx my)
"Call this and get back a rectangle as four values: left, top, right, bottom.
The user uses the mouse to specify the rectangle.  The left button puts
a corner down, the right button puts it down at the nearest 'good' place,
the middle button aborts if that is possible.
Specifying a rectangle of zero or negative size instead gives the full screen.
Our arguments are where to start the corners out:
The upper left corner goes at LEFT and TOP, or where the mouse is if they are NIL;
the lower right corner goes near the other one by default, unless all
four args are present, in which case it starts off so as to make a rectangle
congruent to the one specified by the arguments.
If ABORTABLE is T, this can return NIL.
SHEET specifies the area within which we are allowed to act."
  (when (eq current-process (mouse-process mouse))
    (ferror "MOUSE-SPECIFY-RECTANGLE cannot be called in the mouse process"))
  (unless (sheet-me-or-my-kid-p sheet (mouse-sheet mouse))
    (ferror "MOUSE-SPECIFY-RECTANGLE attempted on ~S which is not inferior of MOUSE-SHEET"
	    sheet))
  (with-this-mouse-and-buttons-grabbed (mouse)
    (do () (nil)
      (setq width (if (and left right) (- right left) (max minimum-width 128.)))
      (setq height (if (and top bottom) (- bottom top) (max minimum-height 40.)))
      (mouse-warp (or left (mouse-x mouse)) (or top (mouse-y mouse)) mouse)
      ;Displaying a fixed-size rectangle is not as good as displaying a top-left corner
      ;(MOUSE-SET-BLINKER-DEFINITION ':BOX-BLINKER 0 0 ':ON
      ;	 			     ':SET-SIZE WIDTH HEIGHT)
      (mouse-set-blinker-definition-internal mouse
					     ':character 0 0
					     ':on ':set-character #\mouse:nw-corner)
      (setf (who-line-mouse-grabbed-documentation mouse)
	    (if abortable
		"Position upper left corner of rectangle.  Middle aborts.  Right is smart."
		"Position upper left corner of rectangle.  Right is smart."))
      (multiple-value (button mx my)
	(wait-for-mouse-button-down "Button" nil nil mouse))
      ;; The first click determines the upper left corner.
      (and abortable (bit-test 2 button) (return (setq abort t)))
      (multiple-value (left1 top1)
	(mouse-specified-point sheet mx my (bit-test 4 button) nil))
      ;; Set up the mouse for finding the lower right corner.
      ;; Next two lines would like to be inside a without-interrupts to guarantee
      ;; that spurious blinkers will not be displayed momentarily.  However, it
      ;; works okay as it stands.
      (mouse-warp (+ left1 width) (+ top1 height) mouse)
      (mouse-set-blinker-definition-internal mouse
					     :box-tracking-corner-blinker 0 0 :on
					     :set-edges-and-moving-corner
					     left1 top1 (+ left1 width) (+ top1 height)
					     :lower-right)
      (setf (who-line-mouse-grabbed-documentation mouse)
	    (if abortable
		"Position lower right corner of rectangle.  Middle aborts.  Right is smart."
		"Position lower right corner of rectangle.  Right is smart."))
      ;; The next click fixes the lower right corner.
      (multiple-value (button mx my)
	(wait-for-mouse-button-down "Button" nil nil mouse))
      (mouse-standard-blinker nil mouse)
      (setf (who-line-mouse-grabbed-documentation mouse) nil)
      (and abortable (bit-test 2 button) (return (setq abort t)))
      (multiple-value-bind (x y)
	  (mouse-specified-point sheet (1+ mx) (1+ my) (bit-test 4 button) t)
	(setq width (- x left1)
	      height (- y top1)))
      (cond ((and (plusp width) (plusp height))
	     (multiple-value-bind (xoff yoff)
		 (sheet-mouse-offsets sheet)
	       (setq left1 (- left1 xoff)
		     top1 (- top1 yoff)))
	     (if (or (< width minimum-width) (< height minimum-height)
		     (minusp left1) (minusp top1)
		     (> (+ left1 width) (sheet-width sheet))
		     (> (+ top1 height) (sheet-height sheet)))
		 (beep)
		 (return nil)))
	    (t (setq left1 (sheet-inside-left sheet)
		     top1 (sheet-inside-top sheet)
		     width (sheet-inside-width sheet)
		     height (sheet-inside-height sheet))
	       (return nil)))))
  (unless abort
    (values left1 top1 (+ left1 width) (+ top1 height))))

(defun mouse-specified-point (sheet x y magicp at-right &optional (at-bottom at-right))
  (when magicp
    (let ((x2 x) (x2-delta 999999.)
	  (y2 y) (y2-delta 999999.)
	  (x-mult (if at-right 1 -1))
	  (y-mult (if at-bottom 1 -1)))
      (map-over-sheet				;Map over all visible edges
	#'(lambda (sh)
	    (multiple-value-bind (sh-left sh-top) (sheet-calculate-offsets sh sheet)
	      (let ((sh-right (+ sh-left (sheet-width sh)))
		    (sh-bottom (+ sh-top (sheet-height sh))))
		(flet ((suitably-close (delta lim)
			 ;; 32 is 4 character-widths
			 (and ( delta 0) (< delta 32.) (< delta lim))))
		  (let ((delta (* (- sh-left x) x-mult)))
		    (when (and (suitably-close delta x2-delta)
			       (eq (lowest-sheet-under-point sheet sh-left y) sh))
		      (setq x2 sh-left
			    x2-delta delta)))
		  (let ((delta (* (- sh-right x) x-mult)))
		    (when (and (suitably-close delta x2-delta)
			       (eq (lowest-sheet-under-point sheet (1- sh-right) y) sh))
		      (setq x2 sh-right x2-delta delta)))
		  (let ((delta (* (- sh-top y) y-mult)))
		    (when (and (suitably-close delta y2-delta)
			       (eq (lowest-sheet-under-point sheet x sh-top) sh))
		      (setq y2 sh-top y2-delta delta)))
		  (let ((delta (* (- sh-bottom y) y-mult)))
		    (when (and (suitably-close delta y2-delta)
			       (eq (lowest-sheet-under-point sheet x (1- sh-bottom)) sh))
		      (setq y2 sh-bottom y2-delta delta)))))))
	sheet)
      (setq x x2
	    y y2)))
  (values (min (max x (sheet-inside-left sheet)) (sheet-inside-right sheet))
	  (min (max y (sheet-inside-top sheet)) (sheet-inside-bottom sheet))))

#|| 
;;; Wave the mouse around.  The "x" (like the menu mouse blinker) shows where "R is smart"
;;; would put the edge.
(defun test-mouse-specified-point ()
  (with-mouse-and-buttons-grabbed
    (setq who-line-mouse-grabbed-documentation "L: Next corner;  R: Exit")
    (let (screen-x screen-y
	  (window mouse-sheet))
      (flet ((mark-at (x y)
	       (flet ((glyph (nx ny)
			(send window :%draw-glyph (char-code #\) fonts:mouse
			      (- nx 4) (- ny 5)
			      alu-xor)))
		 (when screen-x (glyph screen-x screen-y))
		 (when x
		   (glyph x y)
		   (setq screen-x x screen-y y)))))
	(wait-for-mouse-button-up)
	(loop with old-mouse-x = mouse-x
	      with old-mouse-y = mouse-y
	      with old-buttons = mouse-last-buttons
	      with (at-right at-bottom)
	      do
	  (multiple-value-bind (button mx my)
	      (mouse-wait old-mouse-x old-mouse-y old-buttons
			  (if at-right
			      (if at-bottom "lower-right" "upper-right")
			      (if at-bottom "lower-left" "upper-left")))
	    (cond ((bit-test 1 button)
		   (multiple-value (at-right at-bottom)
		     (if at-right
			 (if at-bottom (values nil t) (values t t))
			 (if at-bottom (values nil nil) (values t nil))))
		   (wait-for-mouse-button-up))
		  ((bit-test 2 button)
		   (beep)
		   (wait-for-mouse-button-up))
		  ((bit-test 4 button)
		   (loop-finish))
		  (t (multiple-value-bind (nx ny)
			 (mouse-specified-point window mx my t at-right at-bottom)
		       (mark-at nx ny))
		     (setq old-mouse-x mx
			   old-mouse-y my))))
	      finally
		(mark-at nil nil))))))
||#

;;; Put a window someplace using the mouse
(defun mouse-set-window-size (window &optional (move-p t) &aux left top right bottom error)
  (declare (values left top right bottom))
  (multiple-value (left top)
    (sheet-mouse-offsets window))
  (setq right (+ left (sheet-width window))
	bottom (+ top (sheet-height window)))
  (do () (())
    (multiple-value (left top right bottom)
      (mouse-specify-rectangle left top right bottom (sheet-superior window) 0 0 t))
    (cond ((null left)				;Aborted
	   (beep)				;Leave it where it is
	   (setq move-p nil)
	   (multiple-value (left top right bottom) (send window ':edges))
	   (return))
	  ((null (multiple-value (nil error)
		   (send window ':set-edges left top right bottom ':verify)))
	   (beep)
	   (pop-up-format (mouse-default-superior window)
			  "Illegal edges for ~S:~%~A"
			  window error)) ;Edges no good, try again
	  (t (return))))			;Good
  (and move-p (send window ':set-edges left top right bottom))
  (values left top right bottom))


(defflavor mouse-box-blinker () (mouse-blinker-mixin box-blinker))
(defflavor mouse-box-stay-inside-blinker ()
	   (mouse-blinker-mixin stay-inside-blinker-mixin box-blinker))
(defflavor mouse-box-lower-right-blinker ()
	   (mouse-blinker-mixin box-lower-right-blinker-mixin box-blinker))
(defflavor mouse-box-tracking-corner-blinker ()
	   (mouse-blinker-mixin box-tracking-corner-blinker-mixin box-blinker))

(compile-flavor-methods mouse-box-blinker mouse-box-stay-inside-blinker
			mouse-box-lower-right-blinker mouse-box-tracking-corner-blinker)

(mouse-define-blinker-type ':box-blinker
			   #'(lambda (screen)
			       (make-blinker screen 'mouse-box-blinker
				 :visibility nil)))

(defconst box-horizontal-edge-gray #o(make-gray 4 16.
						1111111100000000 1111111100000000
						0000000011111111 0000000011111111))
(defconst box-vertical-edge-gray #o(make-gray 16. 4
					      1100 1100 1100 1100
					      1100 1100 1100 1100
					      0011 0011 0011 0011
					      0011 0011 0011 0011))

(mouse-define-blinker-type ':box-stay-inside-blinker
			   #'(lambda (screen)
			       (make-blinker screen 'mouse-box-stay-inside-blinker
					     :gray-array (list box-horizontal-edge-gray
							       box-vertical-edge-gray)
					     :visibility nil)))
(mouse-define-blinker-type ':box-lower-right-blinker
			   #'(lambda (screen)
			       (make-blinker screen 'mouse-box-lower-right-blinker
					     :gray-array 50%-gray
					     :visibility nil)))

(mouse-define-blinker-type :box-tracking-corner-blinker
			   (lambda (screen)
			     (make-blinker screen 'mouse-box-tracking-corner-blinker
					   :gray-array (list box-horizontal-edge-gray
							     box-vertical-edge-gray)
					   :visibility nil
					   :moving-corner :bottom-right)))

;;; Move a window around using the mouse
;;; If MOVE-P is NIL move just an outline of it and return where it would have moved to
;;; Return values are the position X, Y, or NIL if the middle button is clicked to abort.
(defun mouse-set-window-position (window &optional (move-p t))
  (declare (values x y))
  (let* ((mouse (sheet-mouse window))
	 (msheet (mouse-sheet mouse)))
    (unless (sheet-me-or-my-kid-p window msheet)
      (ferror "Attempt to set position of ~S, which is not inferior to MOUSE-SHEET" window))
    (multiple-value-bind (xoff yoff)
	(sheet-calculate-offsets (sheet-superior window) (mouse-sheet mouse))
      (with-this-mouse-and-buttons-grabbed (mouse)
	(without-interrupts
	  (mouse-set-blinker-definition-internal mouse
						 ':box-stay-inside-blinker 0 0 nil
						 ':set-size
						 (sheet-width window) (sheet-height window))
	  (mouse-warp (+ (sheet-x window) xoff) (+ (sheet-y window) yoff) mouse))
	(blinker-set-visibility (mouse-blinker mouse) t)
	(setf (who-line-mouse-grabbed-documentation mouse)
	      "Left selects position of window.  Middle or right aborts.")
	
	(loop for bd = (wait-for-mouse-button-down "Button" nil nil mouse)
	      do
	  ;; Get the location of the upper left-hand corner, constrained to a legal position
	  (multiple-value-bind (x y) (send (mouse-blinker mouse) ':read-cursorpos)
	    ;;Blinker cursorposes are w.r.t. INSIDE coord system, but
	    ;;edges are specified w.r.t. the OUTSIDE coord system.
	    (setq x (- (+ x (sheet-inside-left msheet)) xoff)
		  y (- (+ y (sheet-inside-top msheet)) yoff))
	    (cond ((zerop bd))
		  ((bit-test 6 bd) (return-from mouse-set-window-position nil))
		  ((send window ':set-position x y ':verify)
		   (blinker-set-visibility (mouse-blinker mouse) nil)
		   (if move-p (send window ':set-position x y))
		   (return-from mouse-set-window-position (values x y)))
		  (t (beep)))))))))		;Illegal position


(defun expand-window (window &optional (move-p t))
  (declare (values left top right bottom))
  (when (not (null (send window :superior)))
    (let ((x-offset (sheet-x-offset window))
	  (y-offset (sheet-y-offset window)))
      (multiple-value-bind (left top right bottom)
	  (expand-rectangular-area 
	    (sheet-superior window)	
	    x-offset
	    y-offset
	    (+ x-offset (sheet-width window))
	    (+ y-offset (sheet-height window)))
	(and move-p (send window ':set-edges left top right bottom))
	(values left top right bottom)))))

;;; Given a superior window, and a rectangle within that window, return
;;; the boundaries of a new rectangle that includes the old rectangle
;;; and is expanded as much as possible without overlapping any exposed
;;; inferiors of the superior window.  If the IGNORED-WINDOW argument
;;; is present, it means that we should ignore the presence of this window.
(defun expand-rectangular-area (superior left top right bottom &optional ignored-window)
  (declare (values max-left max-top max-right max-bottom))
  (let ((siblings (sheet-exposed-inferiors superior))
	(max-left (sheet-inside-left superior))
	(max-right (sheet-inside-right superior))
	(max-top (sheet-inside-top superior))
	(max-bottom (sheet-inside-bottom superior)))
    ;;Expand to the left and right
    (dolist (w siblings)
      (cond ((or (null ignored-window) (neq w ignored-window))
	     (and (sheet-overlaps-edges-p w max-left top left bottom)
		  (setq max-left (+ (sheet-x-offset w) (sheet-width w))))
	     (and (sheet-overlaps-edges-p w right top max-right bottom)
		  (setq max-right (sheet-x-offset w))))))
    ;;Expand to the top and bottom
    (dolist (w siblings)
      (cond ((or (null ignored-window) (neq w ignored-window))
	     (and (sheet-overlaps-edges-p w max-left max-top max-right top)
		  (setq max-top (+ (sheet-y-offset w) (sheet-height w))))
	     (and (sheet-overlaps-edges-p w max-left bottom max-right max-bottom)
		  (setq max-bottom (sheet-y-offset w))))))
    (values max-left max-top max-right max-bottom)))


;;;The hairy window whitespace reclaimer
(defstruct (expand-windows-item :list (:constructor nil))
  expand-windows-window
  expand-windows-left
  expand-windows-top
  expand-windows-right
  expand-windows-bottom
  expand-windows-left-top-winners
  expand-windows-right-bottom-winners
  expand-windows-max-left-top
  expand-windows-max-right-bottom)

(defun expand-windows (top-window &aux window-list)
  (setq window-list (mapcar #'(lambda (w &aux left top)
				(list w
				      (setq left (sheet-x-offset w))
				      (setq top (sheet-y-offset w))
				      (+ left (sheet-width w))
				      (+ top (sheet-height w))
				      nil nil nil nil))
			    (sheet-exposed-inferiors top-window)))
  (expand-windows-left-and-right top-window window-list)
  (expand-windows-top-and-bottom top-window window-list)
  ;;Now we are ready to set all the edges
  (delaying-screen-management
    (dolist (item window-list)
      (send (expand-windows-window item) ':set-edges
	       (expand-windows-left item) (expand-windows-top item)
	       (expand-windows-right item) (expand-windows-bottom item)))))

;;;Expand the lefts and rights
(defun expand-windows-left-and-right (top-window window-list)
  (do ((l window-list (cdr l))
       (item)
       (superior-inside-left (sheet-inside-left top-window))
       (superior-inside-right (sheet-inside-right top-window)))
      ((null l))
    (setq item (car l))
    (do ((l window-list (cdr l))
	 (nitem)
	 (left (expand-windows-left item))
	 (top (expand-windows-top item))
	 (right (expand-windows-right item))
	 (bottom (expand-windows-bottom item))
	 (max-left superior-inside-left)
	 (max-right superior-inside-right)
	 (left-winners)
	 (right-winners)
	 (nitem-left)
	 (nitem-right))
	((null l)
	 (setf (expand-windows-left-top-winners item) left-winners)
	 (setf (expand-windows-right-bottom-winners item) right-winners)
	 (setf (expand-windows-max-left-top item) max-left)
	 (setf (expand-windows-max-right-bottom item) max-right))
      (or (eq item (setq nitem (car l)))		;For all other windows
	  (> top (expand-windows-bottom nitem))		;Which share some space on y
	  (< bottom (expand-windows-top nitem))
	  (cond (( left (setq nitem-right (expand-windows-right nitem)))
		 (and ( nitem-right max-left)
		      (if (= nitem-right max-left)	;More than one window along the edge
			  (push nitem left-winners)
			  (setq max-left nitem-right
				left-winners (list nitem)))))
		(( right (setq nitem-left (expand-windows-left nitem)))
		 (and ( nitem-left max-right)
		      (if (= nitem-left max-right)
			  (push nitem right-winners)
			  (setq max-right nitem-left
				right-winners (list nitem)))))))))
  (dolist (item window-list)
    (let ((window (expand-windows-window item))
	  (left (expand-windows-left item))
	  (top (expand-windows-top item))
	  (right (expand-windows-right item))
	  (bottom (expand-windows-bottom item))
	  (max-left (expand-windows-max-left-top item))
	  (max-right (expand-windows-max-right-bottom item))
	  (left-winners (expand-windows-left-top-winners item))
	  (right-winners (expand-windows-right-bottom-winners item)))
      (and ( max-left left)				;If not already adjacent
	   (let ((winners-max-right (and left-winners
					 (expand-windows-max-right-bottom
					   (car left-winners))))
		 (left-middle (+ max-left (// (- left max-left) 2))))
	     (and winners-max-right (setq left-middle (min left-middle winners-max-right)))
	     (if (not (send window ':set-edges left-middle top right bottom ':verify))
		 ;;This window will not move, get as many of the others as will allow
		 (dolist (left-winner left-winners)
		   (and (send (expand-windows-window left-winner) ':set-edges
			      (expand-windows-left left-winner)
			      (expand-windows-top left-winner)
			      winners-max-right
			      (expand-windows-bottom left-winner)
			      ':verify)
			(set-expand-windows-right left-winner winners-max-right)))
		 ;;Otherwise expand this window left
		 (if (and (or (null left-winners)	;If no windows to the left,
			      (dolist (left-winner left-winners)	;or some won't budge
				(or (send (expand-windows-window left-winner) ':set-edges
					  (expand-windows-left left-winner)
					  (expand-windows-top left-winner)
					  left-middle
					  (expand-windows-bottom left-winner)
					  ':verify)
				    (return t))))
			  (send window ':set-edges max-left top right bottom ':verify))
		     ;;Go all the way left
		     (set-expand-windows-left item (setq left max-left))
		     ;;Share with winners
		     (set-expand-windows-left item (setq left left-middle))
		     (dolist (left-winner left-winners)
		       (set-expand-windows-right left-winner left-middle))))))
      (and ( max-right right)
	   (let ((winners-max-left (and right-winners
					(expand-windows-max-left-top (car right-winners))))
		 (right-middle (- max-right (// (- max-right right) 2))))
	     (and winners-max-left (setq right-middle (max right-middle winners-max-left)))
	     (if (not (send window ':set-edges left top right-middle bottom ':verify))
		 (dolist (right-winner right-winners)
		   (and (send (expand-windows-window right-winner) ':set-edges
			      winners-max-left
			      (expand-windows-top right-winner)
			      (expand-windows-right right-winner)
			      (expand-windows-bottom right-winner)
			      ':verify)
			(set-expand-windows-left right-winner winners-max-left)))
		 (if (and (or (null right-winners)
			      (dolist (right-winner right-winners)
				(or (send (expand-windows-window right-winner)
					  ':set-edges
					  right-middle
					  (expand-windows-top right-winner)
					  (expand-windows-right right-winner)
					  (expand-windows-bottom right-winner)
					  ':verify)
				    (return t))))
			  (send window ':set-edges left top max-right bottom ':verify))
		     (set-expand-windows-right item (setq right max-right))
		     (set-expand-windows-right item (setq right right-middle))
		     (dolist (right-winner right-winners)
		       (set-expand-windows-left right-winner right-middle)))))))))

(defun set-expand-windows-left (item val)
  (setf (expand-windows-left item) val)
  (setf (expand-windows-max-left-top item) val)
  (dolist (winner (expand-windows-left-top-winners item))
    (setf (expand-windows-max-right-bottom winner)
	  (min val (expand-windows-max-right-bottom winner)))))

(defun set-expand-windows-right (item val)
  (setf (expand-windows-right item) val)
  (setf (expand-windows-max-right-bottom item) val)
  (dolist (winner (expand-windows-right-bottom-winners item))
    (setf (expand-windows-max-left-top winner)
	  (max val (expand-windows-max-left-top winner)))))

(defun expand-windows-top-and-bottom (top-window window-list)
  (do ((l window-list (cdr l))
       (item)
       (superior-inside-top (sheet-inside-top top-window))
       (superior-inside-bottom (sheet-inside-bottom top-window)))
      ((null l))
    (setq item (car l))
    (do ((l window-list (cdr l))
	 (nitem)
	 (left (expand-windows-left item))
	 (top (expand-windows-top item))
	 (right (expand-windows-right item))
	 (bottom (expand-windows-bottom item))
	 (max-top superior-inside-top)
	 (max-bottom superior-inside-bottom)
	 (top-winners)
	 (bottom-winners)
	 (nitem-top)
	 (nitem-bottom))
	((null l)
	 (setf (expand-windows-left-top-winners item) top-winners)
	 (setf (expand-windows-right-bottom-winners item) bottom-winners)
	 (setf (expand-windows-max-left-top item) max-top)
	 (setf (expand-windows-max-right-bottom item) max-bottom))
      (or (eq item (setq nitem (car l)))		;For all other windows
	  (> left (expand-windows-right nitem))		;Which share some space on y
	  (< right (expand-windows-left nitem))
	  (cond (( top (setq nitem-bottom (expand-windows-bottom nitem)))
		 (and ( nitem-bottom max-top)
		      (if (= nitem-bottom max-top)	;More than one window along the edge
			  (push nitem top-winners)
			  (setq max-top nitem-bottom
				top-winners (list nitem)))))
		(( bottom (setq nitem-top (expand-windows-top nitem)))
		 (and ( nitem-top max-bottom)
		      (if (= nitem-top max-bottom)
			  (push nitem bottom-winners)
			  (setq max-bottom nitem-top
				bottom-winners (list nitem)))))))))
  (dolist (item window-list)
    (let ((window (expand-windows-window item))
	  (left (expand-windows-left item))
	  (top (expand-windows-top item))
	  (right (expand-windows-right item))
	  (bottom (expand-windows-bottom item))
	  (max-top (expand-windows-max-left-top item))
	  (max-bottom (expand-windows-max-right-bottom item))
	  (top-winners (expand-windows-left-top-winners item))
	  (bottom-winners (expand-windows-right-bottom-winners item)))
      (and ( max-top top)				;If not already adjacent
	   (let ((winners-max-bottom (and top-winners
					  (expand-windows-max-right-bottom
					    (car top-winners))))
		 (top-middle (+ max-top (// (- top max-top) 2))))
	     (and winners-max-bottom (setq top-middle (min top-middle winners-max-bottom)))
	     (if (not (send window ':set-edges left top-middle right bottom ':verify))
		 ;;This window will not move, get as many of the others as will allow
		 (dolist (top-winner top-winners)
		   (and (send (expand-windows-window top-winner) ':set-edges
			      (expand-windows-left top-winner)
			      (expand-windows-top top-winner)
			      (expand-windows-right top-winner)
			      winners-max-bottom
			      ':verify)
			(set-expand-windows-bottom top-winner winners-max-bottom)))
		 ;;Otherwise expand this window top
		 (if (and (or (null top-winners)	;If no windows to the top,
			      (dolist (top-winner top-winners)	;or some won't budge
				(or (send (expand-windows-window top-winner) ':set-edges
					  (expand-windows-left top-winner)
					  (expand-windows-top top-winner)
					  (expand-windows-right top-winner)
					  top-middle
					  ':verify)
				    (return t))))
			  (send window ':set-edges left max-top right bottom ':verify))
		     ;;Go all the way top
		     (set-expand-windows-top item (setq top max-top))
		     ;;Share with winners
		     (set-expand-windows-top item (setq top top-middle))
		     (dolist (top-winner top-winners)
		       (set-expand-windows-bottom top-winner top-middle))))))
      (and ( max-bottom bottom)
	   (let ((winners-max-top (and bottom-winners
					(expand-windows-max-left-top (car bottom-winners))))
		 (bottom-middle (- max-bottom (// (- max-bottom bottom) 2))))
	     (and winners-max-top (setq bottom-middle (max bottom-middle winners-max-top)))
	     (if (not (send window ':set-edges left top right bottom-middle ':verify))
		 (dolist (bottom-winner bottom-winners)
		   (and (send (expand-windows-window bottom-winner) ':set-edges
			      (expand-windows-left bottom-winner)
			      winners-max-top
			      (expand-windows-right bottom-winner)
			      (expand-windows-bottom bottom-winner)
			      ':verify)
			(set-expand-windows-top bottom-winner winners-max-top)))
		 (if (and (or (null bottom-winners)
			      (dolist (bottom-winner bottom-winners)
				(or (send (expand-windows-window bottom-winner)
					  ':set-edges
					  (expand-windows-left bottom-winner)
					  bottom-middle
					  (expand-windows-right bottom-winner)
					  (expand-windows-bottom bottom-winner)
					  ':verify)
				    (return t))))
			  (send window ':set-edges left top right max-bottom ':verify))
		     (set-expand-windows-bottom item (setq bottom max-bottom))
		     (set-expand-windows-bottom item (setq bottom bottom-middle))
		     (dolist (bottom-winner bottom-winners)
		       (set-expand-windows-top bottom-winner bottom-middle)))))))))

(defun set-expand-windows-top (item val)
  (setf (expand-windows-top item) val)
  (setf (expand-windows-max-left-top item) val)
  (dolist (winner (expand-windows-left-top-winners item))
    (setf (expand-windows-max-right-bottom winner)
	  (min val (expand-windows-max-right-bottom winner)))))

(defun set-expand-windows-bottom (item val)
  (setf (expand-windows-bottom item) val)
  (setf (expand-windows-max-right-bottom item) val)
  (dolist (winner (expand-windows-right-bottom-winners item))
    (setf (expand-windows-max-left-top winner)
	  (max val (expand-windows-max-left-top winner)))))

(defvar screen-editor-item-list
	'(("Bury" :value sec-bury
	   :documentation "Point at a window and put it underneath all other windows.")
	  ("Expose" :value sec-expose
	   :documentation "Point at a window and expose it.")
	  ("Expose (menu)" :value sec-expose-menu
	   :documentation 
   "Choose a window (from a menu) and expose it.  This can get at more windows than Expose.")
	  ("Create" :value sec-create
	   :documentation
  "Choose a flavor of window (from a menu) and corners, and create a window of that flavor.")
	  ("Create (expand)" :value sec-create-expand
	   :documentation "Create followed by Expand Window.")
	  ("Kill" :value sec-kill :underscore t
	   :documentation "Point at a window and kill it.  Asks for confirmation.")
	  ("Exit" :value sec-quit :style (:swiss :bold-italic :normal)
	   :documentation "Leave the screen editor.")
	  ("Undo" :value sec-undo :style (:swiss :bold-italic :normal) :underscore t
	   :documentation "Undo the last screen editor command.  Can't undo Create or Kill.")
	  ("Move window" :value sec-move-window
	   :documentation "Point at a window and move it.")
	  ("Reshape" :value sec-reshape
	   :documentation "Point at a window, and specify new corners for it.")
	  ("Move multiple" :value sec-multiple-move
	   :documentation "Choose a group of edges and corners and move them as a unit.")
	  ("Move single" :value sec-single-move
	   :documentation "Point at an edge or corner and move it.")
	  ("Expand window" :value sec-expand-window
	   :documentation 
"Point at a window and change its size so it fills as much empty space around it as possible."
	   )
	  ("Expand all" :value sec-expand-all
	   :documentation
	   "Change the size of all windows to fill as much empty space as possible.")
	  ("Attributes" :value sec-attributes
	   :documentation
	   "Edit the attributes of a specified window.")))

(defwindow-resource screen-editor-menu ()
	:make-window (dynamic-pop-up-menu :item-list-pointer 'screen-editor-item-list
					  :save-bits ':delayed
					  :label '(:string "Screen Edit Operation"
						   :style (:swiss :italic :normal)))
	:reusable-when :deexposed)

(defvar screen-editor-menu)
(defvar screen-editor-previous-alist)

;;; The actual screen editor
;;; The WINDOW-EDGE-ALIST is in sheet visibility order and has elements
;;;	(window exposed-p left top right bottom)
;;; :BURY in exposed-p is a special kludge to make burying to deexposed windows work
;;; Only problem with this is that undoing a bury of a de-exposed window does not work;
;;; we do not have window operations to do things like bring a window to the top
;;; of the de-exposed ones.

;;; Commands work by modifying this alist and the command loop here does the
;;; actual side-effects, allowing for undoing.
(defun edit-screen (top-sheet &aux window-edge-alist screen-editor-previous-alist
				   (console (sheet-console top-sheet))
				   (old-mouse-sheet (mouse-sheet (console-mouse console)))
				   (old-selected-window (console-selected-window console))
				   (who-line (tv:console-who-line-screen console))
				   (old-who-line-process
				     (who-line-screen-force-process who-line)))
  (using-resource (screen-editor-menu screen-editor-menu top-sheet)
   (unwind-protect
    (catch 'exit-screen-editor
      (mouse-set-sheet top-sheet)
      (setf (who-line-screen-force-process who-line) current-process)
      (do ((command)
	   (new-alist 'first))
	 (nil)
       (expose-window-near screen-editor-menu '(:mouse))
       (if (setq command (send screen-editor-menu ':choose))
	   (delaying-screen-management
	     (send screen-editor-menu ':deactivate)
	     ;; Now, just before executing the command, pick up the state of the screen
	     ;; We defer it until now so that we see the results of screen management
	     ;; and of things done to the screen by other processes.
	     ;; Also save the state before the previous command for Undo
	     (or (eq new-alist 'abort)
		 (setq screen-editor-previous-alist window-edge-alist))
	     (setq window-edge-alist (get-window-edge-alist top-sheet))
	     (and (eq new-alist 'first)
		  (setq screen-editor-previous-alist window-edge-alist))
	     (setq new-alist (funcall command top-sheet window-edge-alist))
	     (cond ((neq new-alist 'abort)	;Don't change history if command aborted
		    (dolist (new new-alist)
		      (let ((old (assq (car new) window-edge-alist)))
			(or (equal (cddr old) (cddr new))	;Edges not the same?
			    (multiple-value-bind (win lose)
				(send (first new) ':set-edges (third new) (fourth new)
				      (fifth new) (sixth new) ':verify)
			      (if win (lexpr-send (car new) ':set-edges (cddr new))
				  (beep)
				  (pop-up-format (mouse-default-superior top-sheet)
						 "Illegal edges for ~S:~%~A"
						 (car new) lose))))
			;; Try to fix exposure and ordering of de-exposed sheets.
			;; This may not be quite right, e.g. if undoing an expose
			;; because the window will go in the wrong place in the
			;; de-exposed sheets, and Undo twice will not be a no-op.
			;; It will just have to do for now though.
			(cond ((eq (cadr new) t)
			       (or (cadr old) (send (car new) ':expose)))
			      ((eq (cadr new) ':bury)
			       (send (car new) ':bury)))))
		    ;; Doing the buries in a second pass makes the
		    ;; above-mentioned inaccuracy less
		    (dolist (new new-alist)
		      (and (not (cadr new)) (sheet-exposed-p (car new))
			   (send (car new) ':bury))))))
	      )))
    (setf (who-line-screen-force-process who-line) old-who-line-process)
    (mouse-set-sheet old-mouse-sheet)))
  (if (screen-editor-should-reselect old-selected-window)
      (send old-selected-window ':select)
      (send top-sheet ':screen-manage-autoexpose-inferiors)))

(defun get-window-edge-alist (top-sheet &aux window-edge-alist tem)
  (dolist (sheet (sheet-inferiors top-sheet))
    (and (or (setq tem (sheet-exposed-p sheet))
	     (send sheet ':screen-manage-deexposed-visibility))
	 (push (list* sheet tem (multiple-value-list (send sheet ':edges)))
	       window-edge-alist)))
  (nreverse window-edge-alist))

(defun screen-editor-should-reselect (w)
  (and w
       (do ((w w (sheet-superior w)))
	   ((null w) t)
	 (or (sheet-exposed-p w)
	     (return nil)))))

(defun screen-editor-find-screen-to-edit (bottom-window &aux list)
  (do sheet bottom-window (sheet-superior sheet) (null sheet)
      (if (sheet-exposed-p sheet)
	  ;; By default, a screen's inferiors are not editable.
	  (if (send-if-handles sheet :inferiors-editable-p) (push sheet list))
	  (setq list nil)))
  ;; LIST is now all the frames under the mouse that are VISIBLE!
  (let ((ms (mouse-sheet (sheet-mouse bottom-window))))
    (if (null list)
	ms
	(unless (memq ms list) (push ms list))
	(menu-choose
	  (mapcar #'(lambda (w) (cons (or (and (get-handler-for w ':name-for-selection)
					       (send w ':name-for-selection))
					  (sheet-name w))
				      w))
		  list)
	  "Edit the subwindows of:"))))

;;; This is like SUBST but uses EQ rather than EQUAL and only copies what it has to.
(defun substq (new old sexp)
  (cond ((eq old sexp) new)
	((atom sexp) sexp)
	(t (let ((ncar (substq new old (car sexp)))
		 (ncdr (substq new old (cdr sexp))))
	     (if (and (eq (car sexp) ncar) (eq (cdr sexp) ncdr)) sexp (cons ncar ncdr))))))

;;; The screen editor commands and their friends; called with the top-sheet and edge-alist
;;; as arguments, they return the new edge alist.
(defun sec-quit (ignore ignore)
  (throw 'exit-screen-editor t))

(defun sec-undo (ignore ignore)
  screen-editor-previous-alist)

(defun sec-bury (sheet window-edge-alist &aux window)
  (cond ((setq window (screen-editor-find-window window-edge-alist (sheet-mouse sheet) nil
			"Bury Window"
			"Left choose a window to bury.  Middle or right aborts."))
	 (setq window-edge-alist (nreverse (xcons (delq window (reverse window-edge-alist))
						  (setq window (copylist window)))))
	 (setf (second window) ':bury)
	 window-edge-alist)
	(t 'abort)))

;This is not really undoable, in that the window cannot be "unkilled"
(defun sec-kill (sheet window-edge-alist &aux window)
  (cond ((and (setq window (screen-editor-find-window window-edge-alist (sheet-mouse sheet)
						      nil "Kill Window"
			     "Left chooses a window to be killed.  Middle or right aborts."))
	      (mouse-y-or-n-p (format nil "Kill ~A" (sheet-name (car window)))
			      (mouse-sheet (sheet-mouse sheet))))
	 (send (car window) ':kill)
	 (setq window-edge-alist (remq window window-edge-alist))
	 window-edge-alist)
	(t 'abort)))

;;; Undoing this won't kill this window, just bury it
(defun sec-create (sup window-edge-alist)
  (if (system-menu-create-window sup)
      window-edge-alist
      'abort))

;;; Undoing this won't kill this window, just bury it
(defun sec-create-expand (sup window-edge-alist)
  (if (system-menu-create-window sup 'expand)
      window-edge-alist
      'abort))

(defun sec-expose (sheet window-edge-alist &aux window)
  (cond ((setq window (screen-editor-find-window window-edge-alist (sheet-mouse sheet) nil
			"Expose Window"
			"Left chooses a window to be exposed.  Middle or right aborts."))
	 (setq window-edge-alist (remq window window-edge-alist))
	 (push (setq window (copylist window)) window-edge-alist)
	 (setf (second window) t)
	 window-edge-alist)
	(t 'abort)))

(defun sec-expose-menu (top-sheet window-edge-alist &aux window elem)
  (let ((list (mapcan #'(lambda (w)
			  (and (not (memq w (sheet-exposed-inferiors top-sheet)))
			       (ncons (cons (or (and (get-handler-for
						       w ':name-for-selection)
						     (send w
							   ':name-for-selection))
						(sheet-name w))
					    w))))
		      (sheet-inferiors top-sheet))))
    (cond ((null list)
	   (beep)
	   (pop-up-message "Error: there are no windows to be exposed."
			   (mouse-sheet (sheet-mouse top-sheet)))
	   'abort)
	  ((setq window (menu-choose list "Expose:" '(:mouse) nil
				     (mouse-sheet (sheet-mouse top-sheet))))
	   (cond ((setq elem (assq window window-edge-alist))
		  (setq window-edge-alist (remq elem window-edge-alist))
		  (setq elem (copylist elem))
		  (setf (second elem) t))
		 (t
		  (setq elem (list* window t (multiple-value-list
					       (send window ':edges))))))
	   (push elem window-edge-alist)
	   window-edge-alist)
	  (t 'abort))))

(defun sec-move-window (sheet window-edge-alist &aux window)
  (cond ((setq window (screen-editor-find-window window-edge-alist (sheet-mouse sheet) nil
			"Move Window"
			"Left chooses a window to be moved.  Middle or right aborts."))
	 (multiple-value-bind (x y)
	     (mouse-set-window-position (car window) nil)
	   (if x
	       (setq window-edge-alist (substq (list (car window) (cadr window) x y
						     (+ x (sheet-width (car window)))
						     (+ y (sheet-height (car window))))
					       window window-edge-alist))
	       'abort)))
	(t 'abort)))

(defun sec-reshape (sheet window-edge-alist &aux window)
  (cond ((setq window (screen-editor-find-window window-edge-alist (sheet-mouse sheet) nil
			"Reshape Window"
			"Left chooses a window to be reshaped.  Middle or right aborts."))
	 (setq window-edge-alist
	       (substq (list* (car window) (cadr window)
			      (multiple-value-list (window-editor-reshape (car window)
									  :move-window nil
									  :corner-mode :use-default-corner)))
		       window window-edge-alist))
	 window-edge-alist)
	(t 'abort)))

(defun sec-expand-window (sheet window-edge-alist &aux window)
  (cond ((setq window (screen-editor-find-window window-edge-alist (sheet-mouse sheet) nil
			"Expand Window"
			"Left chooses a window to expand.  Middle or right aborts."))
	 (setq window-edge-alist
	       (substq (list* (car window) (cadr window)
			      (multiple-value-list (expand-window (car window) nil)))
		       window window-edge-alist))
	 window-edge-alist)
	(t 'abort)))

(defun sec-expand-all (top-window window-edge-alist &aux window-list)
  (setq window-list (do ((l window-edge-alist (cdr l))
			 (list nil))
			((null l) (nreverse list))
		      (and (cadar l)	;Exposed
			   (push (cons (caar l) (append (cddar l) (make-list 4))) list))))
  (expand-windows-left-and-right top-window window-list)
  (expand-windows-top-and-bottom top-window window-list)
  (nconc (mapcar #'(lambda (item)
		     (list (expand-windows-window item) t
			   (expand-windows-left item) (expand-windows-top item)
			   (expand-windows-right item) (expand-windows-bottom item)))
		 window-list)
	 (do l window-edge-alist (cdr l) (null l)	;All the de-exposed guys
	     (and (null (cadar l)) (return l)))))

;Clicking a button other than the left-hand one is the way to punt
;NIL for CHAR means use the default, which you should use unless there
;is a good reason to have a different blinker.
(defun screen-editor-find-window (window-edge-alist mouse char prompt doc &aux window)
  (or char (setq char #\mouse:circle-plus))  ;Default is the bombsight
  (with-this-mouse-and-buttons-grabbed (mouse)
    (mouse-set-blinker-definition-internal mouse ':character 5 7 ':on ':set-character char)
    (setf (who-line-mouse-grabbed-documentation mouse) doc)
    (multiple-value-bind (buttons x y)
	(wait-for-mouse-button-down prompt nil nil mouse)
      (when (bit-test 1 buttons)
	(dolist (w window-edge-alist)
	  (and ( x (third w)) ( y (fourth w))
	       (< x (fifth w)) (< y (sixth w))
	       (return (setq window w)))))))
  window)

;;; Get a point within the mouse-sheet from the user.  CHAR is the
;;; character to use; NIL means use the default, which you should use
;;; unless there is a good reason to have a different blinker.
(defun screen-editor-find-point (mouse char prompt doc)
  (or char (setq char #\mouse:circle-plus))			;Is bombsight a good default?
  (with-this-mouse-and-buttons-grabbed (mouse)
    (mouse-set-blinker-definition-internal mouse ':character 5 7 ':on ':set-character char)
    (setf (who-line-mouse-grabbed-documentation mouse) doc)
    (multiple-value-bind (buttons x y)
	(wait-for-mouse-button-down prompt nil nil mouse)
      (when (bit-test 1 buttons)
	(values x y)))))

;;; This should return edges if happy or NIL if unhappy.
(defun mouse-specify-expand (superior)
  (multiple-value-bind (x y)
      (screen-editor-find-point
	(sheet-mouse superior) nil
	"Button" "Left chooses a point to expand around.  Middle or right aborts.")
    (cond ((null x) nil)
	  (t (multiple-value-bind (left top right bottom)
		 (expand-rectangular-area superior x y x y
					  (exposed-inferior-containing-point superior x y))
	       (if (or ( right left)
		       ( bottom top))
		   ;; No expansion, return NIL.
		   nil
		   ;; Worked OK, return the new edges.
		   (values left top right bottom)))))))
  
;;; X, Y are coordinates in SUPERIOR.  If any of SUPERIOR's exposed inferiors
;;; contains X, Y, return it.  Else return NIL.
(defun exposed-inferior-containing-point (superior x y)
  (dolist (w (sheet-exposed-inferiors superior))
    (if (sheet-contains-sheet-point-p w superior x y)
	(return w))))

;;; Attribute command.

(defun sec-attributes (sheet window-edge-alist)
  (let ((window
	  (screen-editor-find-window window-edge-alist (sheet-mouse sheet) nil
				     "Attributes"
				     "Left chooses a window to edit the attributes of.  Middle or right aborts.")))
    (cond ((null window)
	   'abort)
	  (t
	   (screen-editor-edit-attributes (car window))
	   window-edge-alist))))

(defun screen-editor-edit-attributes (window &key (own-window t))
  (loop for (message value) on (dw:accepting-values (query-io
						      :own-window own-window
						      :superior (tv:mouse-sheet
								  (tv:sheet-mouse window))
						      :label (format nil "Edit ~A attributes"
								     window))
				 (send window :choose-attributes))
		     by 'cddr
	do (send window message value)))

;;; Hairy movement commands
(defflavor following-arrow-blinker
	(x-origin y-origin
	 tri-width tri-height
	 rect-width rect-height
	 state)
	(blinker)
  (:initable-instance-variables x-origin y-origin tri-width tri-height
				rect-width rect-height))

(defmethod (:init following-arrow-blinker :before) (ignore)
  (setq state (make-list 12.)))

(defun make-following-arrow-blinker (sheet x-origin y-origin tri-width tri-height
					   rect-width rect-height
				     &rest options)
  (lexpr-funcall #'make-blinker sheet 'following-arrow-blinker
		 ':x-origin x-origin ':y-origin y-origin
		 ':tri-width tri-width ':tri-height tri-height
		 ':rect-width rect-width ':rect-height rect-height
		 options))

(defmethod (:size following-arrow-blinker) ()
  (values (max tri-width rect-width)
	  (+ tri-height rect-height)))

(defun set-following-arrow-blinker-origin (blinker x-origin y-origin)
  (send blinker ':set-origin x-origin y-origin))					   

(defmethod (:set-origin following-arrow-blinker) (nx-origin ny-origin)
  (with-blinker-prepared (self)
    (setq x-origin nx-origin y-origin ny-origin)))

(defmethod (:blink following-arrow-blinker) (&aux x0 y0 x2 y2 x3 y3 x4 y4 x5 y5 x6 y6 x7 y7)
  (cond ((not phase)
	 ;;Making it visible, recompute the parameters
	 (let (dx dy len)
	   (setq x0 (or x-origin x-pos))
	   (setq y0 (or y-origin y-pos))
	   (setq dx (- x-pos x0)
		 dy (- y-pos y0)
		 len (isqrt (+ (* dx dx) (* dy dy))))
	   (and (zerop len)			;Right on top of where it's pointing
		(cond ((null x-origin)		;Straight up
		       (setq dy 1 len 1))
		      ((null y-origin)		;Straight left
		       (setq dx 1 len 1))
		      (t (setq dx 1 dy 1 len 1))))	;Top-left corner
	   (setq x4 (+ x-pos (// (* dx tri-height) len))
		 y4 (+ y-pos (// (* dy tri-height) len))
		 x6 (+ x-pos (// (* dx (+ tri-height rect-height)) len))
		 y6 (+ y-pos (// (* dy (+ tri-height rect-height)) len)))
	   (let ((dx1 (// (* tri-width dy) len))
		 (dy1 (// (* tri-width dx) len)))
	     (setq x2 (- x4 dx1)
		   y2 (+ y4 dy1)
		   x3 (+ x4 dx1)
		   y3 (- y4 dy1)))
	   (let ((dx1 (// (* rect-width dy) len))
		 (dy1 (// (* rect-width dx) len)))
	     (setq x5 (+ x4 dx1)
		   y5 (- y4 dy1)
		   x4 (- x4 dx1)
		   y4 (+ y4 dy1))
	     (setq x7 (+ x6 dx1)
		   y7 (- y6 dy1)
		   x6 (- x6 dx1)
		   y6 (+ y6 dy1))))
	 (macrolet ((setf-state-to-values (state &rest values)
		      `(let ((.list. ,state))
			 ,@(loop for val in values
				 collect `(setf (first .list.) ,val)
				 collect `(setf .list. (rest1 .list.))))))
	   ;; cl:replace could be of help here, if it were bummed some more.
	   (setf-state-to-values state x2 y2 x3 y3 x4 y4 x5 y5 x6 y6 x7 y7)))
	(t
	 ;;Erasing it, use old parameters
	 (multiple-value (x2 y2 x3 y3 x4 y4 x5 y5 x6 y6 x7 y7)
	   (values-list state))))
  (sheet-draw-triangle x-pos y-pos x2 y2 x4 y4 blinker-alu sheet)
  (sheet-draw-triangle x-pos y-pos x4 y4 x6 y6 blinker-alu sheet)
  (sheet-draw-triangle x-pos y-pos x6 y6 x7 y7 blinker-alu sheet)
  (sheet-draw-triangle x-pos y-pos x7 y7 x5 y5 blinker-alu sheet)
  (sheet-draw-triangle x-pos y-pos x5 y5 x3 y3 blinker-alu sheet))

(defflavor mouse-following-arrow-blinker () (mouse-blinker-mixin following-arrow-blinker))
(compile-flavor-methods mouse-following-arrow-blinker)
(mouse-define-blinker-type :following-arrow
			   #'(lambda (screen)
			       (make-blinker screen 'mouse-following-arrow-blinker
					     :x-origin 0 :y-origin 0
					     :tri-width 10. :tri-height 20. :rect-width 4
					     :rect-height 32. :visibility nil)))

;;; First value is window that we were pointing at and its edges
;;; Second value is in what direction we were pointing at it
;;; This value is mouse buttons that got us out
(defun find-edge-or-corner (window-edge-alist mouse doc-inside doc-outside
			    &aux buttons old-x old-y)
  (declare (values window-and-edges mode buttons))
  (block find-edge-or-corner
    (with-this-mouse-and-buttons-grabbed (mouse)
      ;; In case this was called in response to a mouse click, wait for
      ;; the buttons to be released.
      (multiple-value (buttons old-x old-y)
	(wait-for-mouse-button-up "Release Button" nil mouse))
      ;; Initialize mouse blinker to small X
     (mouse-set-blinker-definition-internal mouse ':character 3 3 ':on
					    ':set-character #\mouse:times)
     (setf (who-line-mouse-grabbed-documentation mouse) doc-outside)
     (do ((mode ':out)
	  (x0) (y0)
	  (window-and-edges)
	  (new-window-and-edges)
	  (new-mode))
	 (nil)
       (cond ((setq new-window-and-edges (dolist (window-and-edges window-edge-alist)
					   (and ( old-x (third window-and-edges))
						( old-y (fourth window-and-edges))
						(< old-x (fifth window-and-edges))
						(< old-y (sixth window-and-edges))
						(return window-and-edges))))
	      (and (eq mode ':out)
		   (without-interrupts
		     (mouse-set-blinker ':following-arrow nil nil mouse)
		     (mouse-wakeup mouse)
		     (setf (who-line-mouse-grabbed-documentation mouse) doc-inside)))
	      (let ((left (third new-window-and-edges))
		    (top (fourth new-window-and-edges))
		    (right (fifth new-window-and-edges))
		    (bottom (sixth new-window-and-edges)))
		(let (left-p top-p left-right-corner-p top-bottom-corner-p)
		  (let ((one-third (// (- right left) 3)))
		    (setq left-right-corner-p
			  (if (setq left-p (< old-x (// (+ left right) 2)))
			      (< old-x (+ left one-third))
			      (> old-x (- right one-third)))))
		  (let ((one-third (// (- bottom top) 3)))
		    (setq top-bottom-corner-p
			  (if (setq top-p (< old-y (// (+ top bottom) 2)))
			      (< old-y (+ top one-third))
			      (> old-y (- bottom one-third)))))
		  (if (and left-right-corner-p top-bottom-corner-p)
		      (setq new-mode (if left-p (if top-p ':top-left ':bottom-left)
					 (if top-p ':top-right ':bottom-right)))
		      (let ((dx (// (* 100. (if left-p (- old-x left) (- right old-x)))
				    (- right left)))
			    (dy (// (* 100. (if top-p (- old-y top) (- bottom old-y)))
				    (- bottom top))))
			(setq new-mode (if (< dx dy) (if left-p ':left ':right)
					   (if top-p ':top ':bottom))))))
		(cond ((or (neq new-window-and-edges window-and-edges)
			   (neq new-mode mode))
		       (setq x0 (cond ((memq new-mode '(:left :top-left :bottom-left))
				       left)
				      ((memq new-mode '(:right :top-right :bottom-right))
				       right)
				      (t
				       nil)))
		       (setq y0 (cond ((memq new-mode '(:top :top-left :top-right))
				       top)
				      ((memq new-mode '(:bottom :bottom-left :bottom-right))
				       bottom)
				      (t
				       nil)))
		       (send (mouse-blinker mouse) ':set-origin x0 y0)
		       (blinker-set-visibility (mouse-blinker mouse) t)
		       (setq mode new-mode
			     window-and-edges new-window-and-edges)))))
	     ((neq mode ':out)			;Not already out
	      (setq mode ':out)
	      (without-interrupts
		(mouse-set-blinker-definition-internal mouse
						       ':character 3 3 ':on
						       ':set-character #\mouse:times)
		(mouse-wakeup mouse)
		(setf (who-line-mouse-grabbed-documentation mouse) doc-outside))))
       (multiple-value (buttons old-x old-y)
	 (mouse-wait-internal mouse old-x old-y 0 "Pick Something"))
       (unless (zerop buttons)
	 (if (eq mode :out)
	     (multiple-value (buttons old-x old-y)
	       (wait-for-mouse-button-up "Release Button" nil mouse))
	     (return-from find-edge-or-corner
	       (values window-and-edges mode buttons))))))))

;;; Display a set of filled in rectangles
(defflavor multiple-rectangle-blinker
	((rectangle-list))
	(blinker)
  (:initable-instance-variables rectangle-list))

(defmethod (:set-rectangle-list multiple-rectangle-blinker) (new-rectangle-list)
  (with-blinker-prepared (self)
    ;; We have to copy the rectangles because do-multiple-move bashes them afterwards,
    ;; and if that's done while the blinker is visible, a turd would be left behind
    (setq rectangle-list (mapcar #'copylist new-rectangle-list))))

(defmethod (:size multiple-rectangle-blinker) ()
  (do ((rects rectangle-list (cdr rects))
       (rect)
       (min-x0 0) (min-y0 0)
       (max-x1 0) (max-y1 0))
      ((null rects)
       (values (- max-x1 min-x0) (- max-y1 min-y0)))
    (setq rect (car rects))
    (setq min-x0 (min min-x0 (first rect))
	  min-y0 (min min-y0 (second rect)))
    (setq max-x1 (max max-x1 (+ (first rect) (third rect)))
	  max-y1 (max max-y1 (+ (second rect) (fourth rect))))))

(defmethod (:blink multiple-rectangle-blinker) ()
  (dolist (rect rectangle-list)
    (%draw-rectangle-clipped (third rect) (fourth rect)
			     (+ x-pos (first rect)) (+ y-pos (second rect))
			     blinker-alu sheet)))

;;; Rectangle merger, makes an XORable set
(defun add-rect (list x y width height &aux (right (+ x width)) (bottom (+ y height)))
  (do ((rlist list (cdr rlist))
       (rect)
       (rbottom)
       (rright))
      (nil)
    (cond ((or (null rlist)			;If above all others, just add this one
	       (< bottom (second (setq rect (car rlist)))))
	   (push (list x y width height) list)
	   (return)))
    (cond ((< y (second rect))			;Handle part above all others
	   (cond ((and (= x (first rect)) (= width (third rect)))
		  (setf (fourth rect) (- (+ (second rect) (fourth rect)) y))
		  (setf (second rect) y)
		  (setq y (+ y (fourth rect))))
		 (t
		  (push (list x y width (- (second rect) y)) list)
		  (setq y (second rect))))
	   (or (plusp (setq height (- bottom y))) (return))))
    (cond ((> y (setq rbottom (+ (second rect) (fourth rect)))))
	  ((= y rbottom)			;Can extend to the bottom
	   (cond ((and (= x (first rect)) (= width (third rect)))
		  (setf (fourth rect) (- bottom (second rect)))
		  (return))))
	  (t					;Consider part that overlaps this rectangle
	   (cond ((not (or (< right (first rect))
			   (> x (setq rright (+ (first rect) (third rect))))))
		  (cond ((or (< x (first rect)) (> right rright))
			 (cond ((> y (second rect))	;Fragment the top
				(push (list (first rect) (second rect) (third rect)
					    (- y (second rect)))
				      list)
				(setf (second rect) y)
				(setf (fourth rect) (- rbottom y))))
			 (cond ((< bottom rbottom)	;Fragment the bottom
				(push (list (first rect) bottom (third rect)
					    (- rbottom bottom))
				      list)
				(setf (fourth rect) (- y (second rect)))))))
		  (setf (first rect) (min x (first rect)))
		  (setf (third rect) (- (max right rright) (first rect)))
		  (setq y rbottom)
		  (or (plusp (setq height (- bottom y))) (return)))))))
  list)

(defvar corner-length 64.)			;The length of displayed corners
(defvar edge-width 8)				;The width of displayed edges
		;This width has to be more than twice the width of any borders
		;the user might be trying to move, or it looks really confusing
		;due to the XOR.

;;; Add just the corner of a window
(defun add-corner (list left-p top-p left top right bottom)
  (setq list (add-rect list (if left-p left (- right corner-length))
		       (if top-p top (- bottom edge-width))
		       corner-length edge-width))
  (add-rect list (if left-p left (- right edge-width))
	    (if top-p top (- bottom corner-length))
	    edge-width corner-length))

;;; Add a window's corners or edge to the movement list
;;; ON-P means only turn things on, not off
(defun add-moving-window (window-and-edges edge-or-corner window-movement-alist
			  &optional on-p &aux edges)
  (or (setq edges (assq window-and-edges window-movement-alist))
      (push (setq edges (list window-and-edges nil nil nil nil))
	    window-movement-alist))
  (selectq edge-or-corner
    (:left
     (setf (second edges) (setq on-p (or (not (second edges)) on-p))))
    (:top
     (setf (third edges) (setq on-p (or (not (third edges)) on-p))))
    (:right
     (setf (fourth edges) (setq on-p (or (not (fourth edges)) on-p))))
    (:bottom
     (setf (fifth edges) (setq on-p (or (not (fifth edges)) on-p))))
    (:top-left
     (setf (third edges) (setq on-p (or (not (and (second edges) (third edges))) on-p)))
     (setf (second edges) on-p))
    (:top-right
     (setf (fourth edges) (setq on-p (or (not (and (third edges) (fourth edges))) on-p)))
     (setf (third edges) on-p))
    (:bottom-left
     (setf (fifth edges) (setq on-p (or (not (and (second edges) (fifth edges))) on-p)))
     (setf (second edges) on-p))
    (:bottom-right
     (setf (fifth edges) (setq on-p (or (not (and (fourth edges) (fifth edges))) on-p)))
     (setf (fourth edges) on-p))
    (otherwise
     (ferror nil "~S invalid edge//corner descriptor." edge-or-corner)))
  (values window-movement-alist on-p))

;;; Return the corner or edge of a window associated with another
;;; This could somehow take frames into account, i have no idea how though
(defun associated-corner-or-edge (window-and-edges corner-or-edge other-window-and-edges
				  &aux left top right bottom
				       oleft otop oright obottom)
  (setq left (third window-and-edges)
	top (fourth window-and-edges)
	right (fifth window-and-edges)
	bottom (sixth window-and-edges)
	oleft (third other-window-and-edges)
	otop (fourth other-window-and-edges)
	oright (fifth other-window-and-edges)
	obottom (sixth other-window-and-edges))
  (and (neq window-and-edges other-window-and-edges)
       (selectq corner-or-edge
	 (:left (and (= left oright) ( top otop) ( bottom obottom) ':right))
	 (:top (and (= top obottom) ( left oleft) ( right oright) ':bottom))
	 (:right (and (= right oleft) ( top otop) ( bottom obottom) ':left))
	 (:bottom (and (= bottom otop) ( left oleft) ( right oright) ':top))
	 (:top-left
	  (cond ((= left oleft) (and (= top obottom) ':bottom-left))
		(( left oright) nil)
		((= top otop) ':top-right)
		((= top obottom) ':bottom-right)))
	 (:top-right
	  (cond ((= right oright) (and (= top obottom) ':bottom-right))
		(( right oleft) nil)
		((= top otop) ':top-left)
		((= top obottom) ':bottom-left)))
	 (:bottom-left
	  (cond ((= left oleft) (and (= bottom otop) ':top-left))
		(( left oright) nil)
		((= bottom obottom) ':bottom-right)
		((= bottom otop) ':top-right)))
	 (:bottom-right
	  (cond ((= right oright) (and (= bottom otop) ':top-right))
		(( right oleft) nil)
		((= bottom obottom) ':bottom-left)
		((= bottom otop) ':top-left))))))

;;; Make the rectangle list for a given list of window movements
(defun construct-movement-rectangle-list (top-sheet window-movement-alist)
  (do ((alist window-movement-alist (cdr alist))
       (left-margin (sheet-left-margin-size top-sheet))
       (top-margin (sheet-top-margin-size top-sheet))
       (window-and-moving-edges)
       (list nil)
       (left) (top)
       (right) (bottom))
      ((null alist)
       list)
    (setq window-and-moving-edges (car alist))
    (setq left (- (third (first window-and-moving-edges)) left-margin)
	  top (- (fourth (first window-and-moving-edges)) top-margin)
	  right (- (fifth (first window-and-moving-edges)) left-margin)
	  bottom (- (sixth (first window-and-moving-edges)) top-margin))
    ;; If there is just one corner, light it up as a corner
    (if (member (cdr window-and-moving-edges)
		'((t t nil nil) (nil t t nil) (nil nil t t) (t nil nil t)))
	(setq list (add-corner list
			       (second window-and-moving-edges)
			       (third window-and-moving-edges)
			       left top right bottom))
	(and (second window-and-moving-edges)	;Left
	     (setq list (add-rect list left top edge-width (- bottom top))))
	(and (third window-and-moving-edges)	;Top
	     (setq list (add-rect list left top (- right left) edge-width)))
	(and (fourth window-and-moving-edges)	;Right
	     (setq list (add-rect list (- right edge-width) top edge-width (- bottom top))))
	(and (fifth window-and-moving-edges)	;Bottom
	     (setq list (add-rect list left (- bottom edge-width) (- right left)
				  edge-width))))))

(defvar multiple-move-blinker)
(defvar multiple-move-release-time 60.)		;1 second hold-down to start moving things
(defflavor mouse-multiple-rectangle-blinker
	()
	(mouse-blinker-mixin multiple-rectangle-blinker))

(compile-flavor-methods mouse-multiple-rectangle-blinker)
(mouse-define-blinker-type :multiple-rectangle
			   #'(lambda (screen)
			       (make-blinker screen 'mouse-multiple-rectangle-blinker
					     :rectangle-list nil :visibility nil
					     :follow-p nil :x-pos 0 :y-pos 0)))

;;; Screen editor multiple moving command
(defun sec-multiple-move (top-sheet window-edge-alist)
  (initialize-multiple-move-blinker top-sheet)
  (let ((mouse (sheet-mouse top-sheet)))
    (with-this-mouse-and-buttons-grabbed (mouse)
      (unwind-protect
       (do-named abort
	   ((movement-list nil)
	    window-and-edges corner-or-edge buttons
	    (on-p) (rectangle-list))
	   (nil)
	 (multiple-value (window-and-edges corner-or-edge buttons)
	   (find-edge-or-corner window-edge-alist mouse
	     "Left chooses edge or corner.  Middle aborts.  Right starts moving."
   "Move inside a window to choose an edge or corner.  Middle aborts.  Right starts moving."
	    ))
	 (when (bit-test 2 buttons)		;Middle button aborts
	   (return-from abort nil))
	 (cond ((eq corner-or-edge ':out))		;Click while not pointing at anything
	       ((bit-test 1 buttons)		;Left button changes things
		(multiple-value (movement-list on-p)
		  (add-moving-window window-and-edges corner-or-edge movement-list))
		;; If we turned things on, also turn on the associated things
		(and on-p
		     (dolist (other-window-and-edges window-edge-alist)
		       (let ((associated-corner-or-edge (associated-corner-or-edge
							  window-and-edges corner-or-edge
							  other-window-and-edges)))
			 (and associated-corner-or-edge
			      (setq movement-list (add-moving-window other-window-and-edges
								     associated-corner-or-edge
								     movement-list t))))))
		(setq rectangle-list (construct-movement-rectangle-list top-sheet
									movement-list))
		(send multiple-move-blinker ':set-rectangle-list rectangle-list)
		;; Decide whether this is a short click or a long click
		(setq buttons (wait-for-mouse-button-up "Long Click?"
							multiple-move-release-time mouse))))
	 (cond ((not (zerop buttons))		;Still held down (Left or Right)?
		(and movement-list			;Could be nothing to move
		     (setq window-edge-alist (do-multiple-move top-sheet window-edge-alist
							       rectangle-list movement-list)))
		(return t))))
       (blinker-set-visibility multiple-move-blinker nil))))
  window-edge-alist)

(defun get-movement-delta (mouse &aux (starting-x (mouse-x mouse))
				      (starting-y (mouse-y mouse)))
  (multiple-value-bind (buttons x y)
      (wait-for-mouse-button-down "Moving" nil nil mouse)
    (values (- x starting-x) (- y starting-y) buttons)))

;;; Make an absolute rectangle list relative to its upper-left corner for moving with mouse
(defun relative-rectangle-list (top-sheet list &aux (min-x 99999.) (min-y 99999.))
  (dolist (rect list)
    (setq min-x (min min-x (first rect))
	  min-y (min min-y (second rect))))
  (dolist (rect list)
    (setf (first rect) (- (first rect) min-x))
    (setf (second rect) (- (second rect) min-y)))
  (values (+ min-x (sheet-left-margin-size top-sheet))
	  (+ min-y (sheet-top-margin-size top-sheet))
	  list))

(defun initialize-multiple-move-blinker (top-sheet)
  (let ((bl (mouse-get-blinker ':multiple-rectangle top-sheet)))
    (send bl ':set-rectangle-list nil)
    (send bl ':set-cursorpos 0 0)
    (send bl ':set-visibility t)
    (setq multiple-move-blinker bl)))

(defun do-multiple-move (top-sheet window-edge-alist rectangle-list movement-list)
  (let ((mouse (sheet-mouse top-sheet)))
    (with-this-mouse-and-buttons-grabbed (mouse)
      (multiple-value-bind (x y l)
	  (relative-rectangle-list top-sheet rectangle-list)
	(mouse-warp x y mouse)
	(mouse-set-blinker-definition-internal
	  mouse :multiple-rectangle 0 0 t :set-rectangle-list l))
      (setf (who-line-mouse-grabbed-documentation mouse)
	    "Left to move edges and corners.  Middle aborts.")
      (do ((min-x (sheet-inside-left top-sheet))
	   (max-x (sheet-inside-right top-sheet))
	   (min-y (sheet-inside-top top-sheet))
	   (max-y (sheet-inside-bottom top-sheet))
	   (new-edge-alist)
	   delta-x delta-y buttons)
	  (nil)
	(setq new-edge-alist window-edge-alist)
	(multiple-value (delta-x delta-y buttons)
	  (get-movement-delta mouse))
	(if (bit-test 2 buttons)			;Middle aborts
	    (return nil)
	    (if (dolist (move movement-list)
		  (let ((new-edges (copylist (car move))))
		    (and (second move)
			 (let ((new-left (+ (third new-edges) delta-x)))
			   (and (or (< new-left min-x) ( new-left max-x))
				(return t))
			   (setf (third new-edges) new-left)))
		    (and (third move)
			 (let ((new-top (+ (fourth new-edges) delta-y)))
			   (and (or (< new-top min-y) ( new-top max-y))
				(return t))
			   (setf (fourth new-edges) new-top)))
		    (and (fourth move)
			 (let ((new-right (+ (fifth new-edges) delta-x)))
			   (and (or (< new-right min-x) ( new-right max-x))
				(return t))
			   (setf (fifth new-edges) new-right)))
		    (and (fifth move)
			 (let ((new-bottom (+ (sixth new-edges) delta-y)))
			   (and (or (< new-bottom min-y) ( new-bottom max-y))
				(return t))
			   (setf (sixth new-edges) new-bottom)))
		    (setq new-edge-alist (substq new-edges (car move) new-edge-alist))))
		(beep)				;Something off the screen
		(setq window-edge-alist new-edge-alist)		     
		(return t))))))
  window-edge-alist)

(defun sec-single-move (top-sheet window-edge-alist)
  (initialize-multiple-move-blinker top-sheet)
  (unwind-protect
    (multiple-value-bind (window-and-edges corner-or-edge buttons)
	(find-edge-or-corner window-edge-alist (sheet-mouse top-sheet)
	  "Left to choose an edge or corner.  Middle or right aborts."
	  "Move inside a window to choose an edge or corner.  Middle or right aborts.")
      (cond ((not (bit-test 6 buttons))		;Middle or right aborts
	     (let* ((movement-list (add-moving-window window-and-edges corner-or-edge nil))
		    (rectangle-list (construct-movement-rectangle-list top-sheet
								       movement-list)))
	       (setq window-edge-alist (do-multiple-move top-sheet window-edge-alist
							 rectangle-list movement-list))))))
    (blinker-set-visibility multiple-move-blinker nil))
  window-edge-alist)

;;;; The window used by mouse-exit-target-mixin.
;;; Since it has something to do with screen editing, I put it into this file.
;;; If you don't like its position, I suppose it's fixed in Statice.

(defvar *exit-target-windows* ())

(defun find-exit-target-window (&key corner window direction delta hysteresis)
  (let ((win (cl:find-if (lambda (win) (check-deactivated-window-resource nil win nil))
			 *exit-target-windows*)))
    (cond (win
	   (send win :set-superior window)
	   (exit-target-window-set-corner-window-direction-delta-hysteresis
	     win corner window direction delta hysteresis))
	  (t (setq win (make-window 'exit-target-window
				    :corner corner
				    :window window
				    :direction direction
				    :delta delta
				    :hysteresis hysteresis
				    :superior window))
	     (push-onto-list-without-interrupts
	       win
	       (lambda (which &optional new)
		 (cl:ecase which
		   (:read *exit-target-windows*)
		   (:write (setq *exit-target-windows* new)))))))
    win))

;; This replaces (without-interrupts (push x list)) except that list gets reconsed
;; each time, leaving it all on the same virtual memory page.
(defun push-onto-list-without-interrupts (item read-write-continuation)
  (let ((old-n (length (funcall read-write-continuation :read))))
    ;; I'd rather cons the new list outside the without-interrupts, thank you.
    (let ((new-list (make-list (1+ old-n))))
      (loop repeat 5
	    when
	      (without-interrupts
		(let* ((current-list (funcall read-write-continuation :read))
		       (current-n (length current-list)))
		  (when (= current-n old-n)
		    (setf (first new-list) item)
		    (cl:replace (rest1 new-list) current-list)
		    (funcall read-write-continuation :write new-list)
		    T)))
	      return T
	    finally (ferror "Failed to adjoin item after 5 tries")))))

(defflavor exit-target-window
	(corner
	 window
	 direction
	 delta)
	(dont-select-with-mouse-mixin  ;;Keeps clicking Left on it from deselecting superior
	 temporary-window-mixin hysteretic-window-mixin window)
  :initable-instance-variables
  :gettable-instance-variables
  (:default-init-plist :label nil :blinker-p nil))

(defmethod (exit-target-window-set-corner-window-direction-delta-hysteresis
	     exit-target-window)
	   (new-corner new-window new-direction new-delta new-hysteresis)
  (setq corner new-corner
	window new-window
	direction new-direction
	delta new-delta
	hysteresis new-hysteresis))

(defmethod (:move-into-corner exit-target-window) ()
  (unless (listp hysteresis)
    (setq hysteresis (make-list 4 :initial-value hysteresis)))
  (multiple-value-bind (window-left window-top window-right window-bottom)
      (send window :inside-edges)
    (multiple-value-bind (lm tm rm bm) (send window :margins)
      (macrolet ((hyset (lm tm rm bm)
		   `(progn ,(and lm `(incf (first hysteresis) ,lm))
			   ,(and tm `(incf (second hysteresis) ,tm))
			   ,(and rm `(incf (third hysteresis) ,rm))
			   ,(and bm `(incf (fourth hysteresis) ,bm)))))
	(let ((gate-width *mouse-exit-gate-width*))
	  (cl:ecase corner
	    (:upper-left
	      (hyset (1+ lm) (1+ tm) nil nil)
	      (send self :set-edges window-left window-top
		    (+ window-left gate-width) (+ window-top gate-width)))
	    (:upper-right
	      (hyset nil (1+ tm) (1+ rm) nil)
	      (send self :set-edges (- window-right gate-width) window-top
		    window-right (+ window-top gate-width)))
	    (:lower-right
	      (hyset nil nil (1+ rm) (1+ bm))
	      (send self :set-edges (- window-right gate-width)
		    (- window-bottom gate-width)
		    window-right window-bottom))
	    (:lower-left
	      (hyset (1+ lm) nil nil (1+ bm))
	      (send self :set-edges window-left (- window-bottom gate-width)
		    (+ window-left gate-width) window-bottom))))))))

(defvar *exit-target-window-bitmaps*
	(subst nil 'x '(0 (:up x) (:down x) (:left x) (:right x))))

(defun find-exit-target-window-bitmap (arrow-direction)
  (declare (values array needs-drawing))
  (let ((width *mouse-exit-gate-width*))
    (unless (eql (first *exit-target-window-bitmaps*) width)
      (setf (first *exit-target-window-bitmaps*) width)
      (dolist (pair (rest1 *exit-target-window-bitmaps*))
	(setf (second pair) nil)))
    (let ((pair (assq arrow-direction (rest1 *exit-target-window-bitmaps*))))
      (if (null pair)
	  (ferror "Ill-conceived direction ~s" arrow-direction)
	  (if (second pair)
	      (values (second pair) ())
	      (let ((array (make-raster-array (* 32. (ceiling width 32.)) width
					      :type 'art-1b)))	;---color?
		(setf (second pair) array)
		(values array T)))))))

(defmethod (:refresh exit-target-window :after) (&optional ignore)
  (unless restored-bits-p
    (let ((arrow-direction
	    (cl:ecase direction
	      (:vertical
	       (if (minusp delta) :up :down))
	      (:horizontal
	       (if (minusp delta) :left :right)))))
      (flet ((draw ()
	       (send self :draw-rectangle (sheet-inside-width) (sheet-inside-height) 0 0)
	       (let* ((char (second (assq arrow-direction
					  '((:up #\mouse:fat-up-arrow)
					    (:down #\mouse:fat-down-arrow)
					    (:left #\mouse:fat-left-arrow)
					    (:right #\mouse:fat-right-arrow)))))
		      (w (aref (font-char-width-table fonts:mouse) (char-subindex char)))
		      (h (font-raster-height fonts:mouse)))
		 (let ((ww (floor (sheet-inside-width) 2))
		       (wh (floor (sheet-inside-height) 2)))
		   (send self :draw-filled-in-circle ww wh (- (min ww wh) 2) :erase)
		   (send self :draw-glyph (char-subindex char) fonts:mouse
			 (- ww (floor w 2))
			 (- wh (floor h 2)))))))
	(prepare-sheet (self)
	  (cond ((= 1 (send screen :bits-per-pixel))
		 (multiple-value-bind (array needs-drawing)
		     (find-exit-target-window-bitmap arrow-direction)
		   (cond (needs-drawing
			  (draw)
			  (sheet-bitblt alu-seta width height nil 0 0 array 0 0 self))
			 (T (sheet-bitblt alu-seta width height array 0 0 nil 0 0 self)))))
		(T (draw))))))))

(defmethod (:mouse-standard-blinker exit-target-window) ()
  (set-mouse-blinker-for-exit-target-window self))

(defun set-mouse-blinker-for-exit-target-window (sheet)
  (mouse-set-blinker-definition-internal (sheet-mouse sheet)
					 :character 7 7 :on
					 :set-character #\mouse:fat-times))

(defmethod (:who-line-documentation-string exit-target-window) ()
  (macrolet ((doc (which)
	       (format nil "Mouse-Left: scroll window contents;  Middle: ~a window;  ~
			    Right: menu."
		       which)))
    (values
      (selectq corner
	(:upper-left (doc "move"))
	(otherwise   (doc "reshape")))
      "Hold Left to keep scrolling.  Press Shift or Meta to scroll in the opposite direction."
      )))

(defmethod (:handle-mouse exit-target-window :before) ()
  (setf (mouse-window (sheet-mouse self)) self)
  (tv:need-mouse-documentation-update))

(defmethod (:handle-mouse exit-target-window :after) ()
  (setf (mouse-window (sheet-mouse self)) nil)			;---
  (setf (mouse-reconsider (sheet-mouse self)) t)  ;Keeps above line from screwing things up
  (process-run-function `(:name "Remove window" :priority 5) #'send self :deactivate)
  (mouse-standard-blinker self))

(defmacro retaining-relative-mouse-pos ((window) &body body)
  `(retaining-relative-mouse-pos-1 ,window
				   (lambda (,window)
				     (declare (sys:downward-function))
				     ,@body)))
(defun retaining-relative-mouse-pos-1 (window continuation)
  (declare (sys:downward-funarg continuation))
  (let* ((mouse (sheet-mouse window))
	 (old-mouse-x (mouse-x mouse)) (old-mouse-y (mouse-y mouse)))
    (multiple-value-bind (old-dx old-dy error)
	(sheet-calculate-offsets window (mouse-sheet mouse) nil)
      (if error
	  (funcall continuation window)
	  (multiple-value-bind (old-left old-top old-right old-bottom) (send window :edges)
	    (multiple-value-prog1
	      (funcall continuation window)
	      (multiple-value-bind (new-left new-top new-right new-bottom)
		  (send window :edges)
		(multiple-value-bind (new-dx new-dy error)
		    (sheet-calculate-offsets window (mouse-sheet mouse) nil)
		  (unless error
		    (mouse-warp (+ new-dx (let ((old-x-rel (- old-mouse-x old-dx))
						(old-width (- old-right old-left)))
					    (if (< (* 2 old-x-rel) old-width)
						old-x-rel
						(let ((new-width (- new-right new-left)))
						  (- new-width
						     (- old-width old-x-rel))))))
				(+ new-dy (let ((old-y-rel (- old-mouse-y old-dy))
						(old-height (- old-bottom old-top)))
					    (if (< (* 2 old-y-rel) old-height)
						old-y-rel
						(let ((new-height (- new-bottom new-top)))
						  (- new-height
						     (- old-height old-y-rel))))))
				mouse))))))))))

(defmethod (:mouse-click exit-target-window) (mouse-char &rest ignore)
  (macrolet ((in-spawned-process ((var name priority) &body body)
	       ;;This introduces D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")var0 to be bound to 1window0 because the process might
	       ;;run for a while, even after 1self0 has been returned to the "resource"
	       ;;and perhaps reallocated to hack a different window.
	       `(process-run-function '(:name ,(string name) :priority ,priority)
		  (dw:named-value-snapshot-continuation ,(intern (string name))
							(,var)
		    (send self :deactivate)
		    ,@body)
		  window)))
    (selectq mouse-char
      ((#\Mouse-L #\Shift-Mouse-L #\Meta-Mouse-L)
       (in-spawned-process
	 (win "Scroll" 5)
	 (let ((delta (if (eql mouse-char #\Mouse-L) delta (- delta)))
	       (key (if (eql mouse-char #\Meta-Mouse-L) :meta :shift))
	       (state (if (eql mouse-char #\Mouse-L) nil t))
	       (mouse (sheet-mouse self)))
	   (flet ((scroll-once ()
;---This exposes a DW bug where the line with input echoing on it is not counted
;---when computing the possible scroll range.  Also it isn't what we want, because
;---it doesn't allow bringing in a few blank lines at the end of the window.
;---Don't change this to use :y-scroll-position, it's very slow for zwei.
;		    ;; Return nil if we have gone as far as it is useful to go.
;		    ;; This doesn't let you scroll the window until it's blank.
;		    (when (operation-handled-p win :ragged-borders-p)
;		      (multiple-value-bind (left top right bottom)
;			  (send win :ragged-borders-p)
;			(unless (if (minusp delta)
;				    (if (eq direction :horizontal) left top)
;				    (if (eq direction :horizontal) right bottom))
;			  (return-from scroll-once nil))))
		    ;; Scroll, or return nil if we can't ever scroll this way
		    (let ((mes (cl:ecase direction
				 (:horizontal :x-scroll-to)
				 (:vertical :y-scroll-to)))
			  (*asynchronous-window-operation* t))
		      (unless (operation-handled-p win mes)
			(return-from scroll-once nil))
		      ;; Unfortunately, to get right looking behavior we have to use
		      ;; two different algorithms, depending on whether or not this is
		      ;; zwei, which does its scrolling in another process
		      (cond ((not (typep win 'zwei:zwei))
			     ;; Don't wait forever for the sheet lock, since we could get into
			     ;; a deadlock if a menu is covering the sheet and waiting for us
			     ;; to ungrab the mouse.  The scroll method might wait for the
			     ;; sheet lock, so lock before calling it.
			     (tv:maybe-lock-sheet win (send win mes delta :relative-jump) nil))
			    (t
			     ;; For zwei, don't worry about sheet lock, but do worry about
			     ;; getting ahead of the redisplay process.
			     (send win mes delta :relative-jump)
			     (process-wait-with-timeout "i//o buffer" 3
				  #'send win :io-buffer-empty-p)
			     (process-wait-with-timeout "redisplay" 120
			       (lambda (window)
				 (= (zwei:window-redisplay-degree window) zwei:dis-none))
			       (send win :zwei-window))))
		      ;; Return t to indicate that it will be fruitful to keep scrolling
		      t))
		  (set-mouse-char ()
		    (multiple-value-bind (char dx dy)
			(cl:ecase direction
			  (:vertical
			    (if (< delta 0)
				(values #\mouse:boxed-up-triangle 8 0)
				(values #\mouse:boxed-down-triangle 8 16)))
			  (:horizontal
			    (if (< delta 0)
				(values #\mouse:fat-left-arrow 0 8)
				(values #\mouse:fat-right-arrow 15 8))))
		      (mouse-set-blinker-definition-internal mouse ':character dx dy
							     ':on ':set-character char))))
	     (with-this-mouse-and-buttons-grabbed (mouse)
	       (set-mouse-char)
	       (loop for timeout = 10 then (max (* timeout 0.9) 0.9)
		     while (scroll-once)
		     until (let ((last-buttons
				   (wait-for-mouse-button-up "Scrolling while button down"
							     (floor timeout) mouse)))
			     (zerop last-buttons))
		     do ;; See if key reversed
		 (unless (eq state (console-key-state (mouse-console mouse) key))
		   (setq state (not state))
		   (setq delta (- delta))
		   (setq timeout 10)
		   (set-mouse-char))))))))

      (#\Mouse-M
       (in-spawned-process (win "Screen edit" 1)
			   ;;Remember mouse position relative to window
			   (retaining-relative-mouse-pos (win)
			     (selectq corner
			       (:upper-left (window-editor-move win))
			       (otherwise (window-editor-reshape win :corner corner :corner-mode :use-supplied-corner))))))
      (#\Mouse-R
       (in-spawned-process (win "Screen edit menu" 0)
			   (call-window-editor win :corner corner))))))

(compile-flavor-methods exit-target-window)

;;;; "Window Editing".  Similar to the screen editing above, and might replace some of 
;;; the above if only I had another few weeks to spend on it.

(defun mouse-call-window-edit (window window-x window-y)
  (process-run-function "Edit Window" #'call-window-editor window
			:alias T :window-x window-x :window-y window-y))

(defconst *window-editor-choices*
	  '(("Move" :value window-editor-move
	     :documentation "Move the window")
	    ("Bury" :value window-editor-bury
	     :documentation "Bury the window -- put it underneath all other windows")
	    ("Shape" :value window-editor-reshape
	     :documentation "Reshape the window")
	    ("Kill" :value window-editor-kill
	     :documentation "Kill the window.  Asks for confirmation")
	    ("Expand" :value window-editor-expand
	     :documentation
	       "Expand the window so it fills as much empty space around it as possible")
	    ("Hardcopy" :value window-editor-hardcopy
	    : documentation "Hardcopy the window image")
	    ))
(defconst *window-editor-choices-by-columns*
	  '(("Move" "Shape" "Expand")
	    ("Bury" "Kill" "Hardcopy")))
(defvar *window-editor-choice-alist* ()
  "Indexed by row,column,victim")

(defun find-window-editor-choice-alist ()
  (declare (values array[row-column-victim]))
  (or *window-editor-choice-alist*
      (setq *window-editor-choice-alist*
	    (let ((array (make-array '(3 2 2))))
	      (loop for victim in '(:window :alias)
		    for ivictim from 0
		    do (loop for column in *window-editor-choices-by-columns*
			     for icolumn from 0
			     do (loop for row in column
				      for irow from 0
				      do (let ((item (or (cl:assoc row *window-editor-choices*
								   :test #'string-equal)
							 (ferror "Lost it ~s" row))))
					   (setq item (copylist item))
					   (setf (get item :value)
						 (list (get item :value) victim))
					   (setf (aref array irow icolumn ivictim) item)))))
	      array))))

(defvar *last-window-editor-item* ())

(defun call-window-editor (window &key alias
			   (corner () corner-supplied-p)
			   window-x window-y)
  (ignore window-x window-y)
  (multiple-value-bind (victim1 victim2)
      (if alias
	  (values (send window :alias-for-selected-windows) nil)
	  (values (send window :alias-for-selected-windows) window))
    (multiple-value-bind (choice item)
	(let* ((foobar 'foobar)
	       (presentation-type `((dw::menu-alist-element :alist ,foobar))))
	  (multiple-value-bind (item mouse-char)
	      (dw::menu-choose-from-drawer
		(dw::named-continuation drawer (stream &key max-width max-height)
		  (ignore max-width max-height)
		  (present-operations-on-victims stream presentation-type victim1 victim2))
		presentation-type :default *last-window-editor-item*
		:superior (mouse-default-superior window)
		:alias-for-selected-windows victim1)
	    (when item (values (tv:menu-execute-no-side-effects item t)
			       item
			       mouse-char))))
      (when choice
	(setq *last-window-editor-item* item)
	(catch-error-restart ((abort error) "Exit window editor")
	  (destructuring-bind (choice victim) choice
	    (let ((victim (cl:ecase victim
			    (:window victim1)
			    (:alias victim2))))
	      (let ((corner-to-use
		      (if corner-supplied-p
			  corner
			  (and window-x window-y
			       (multiple-value-bind (w-width w-height)
				   (send window :size)
				 (macrolet ((nearer ((var lower higher)
						     lower-case higher-case)
					      `(if (< (abs (- ,var ,lower))
						      (abs (- ,var ,higher)))
						   ,lower-case ,higher-case)))
				   (nearer (window-x 0 w-width)
					   (nearer (window-y 0 w-height)
						   :upper-left :lower-left)
					   (nearer (window-y 0 w-height)
						   :upper-right :lower-right))))))))
		(retaining-relative-mouse-pos (victim)
		  (funcall choice victim :corner corner-to-use))))))))))

(defun present-operations-on-victims (stream presentation-type victim1 victim2)
  (let ((choices (find-window-editor-choice-alist)))
    (with-stack-array (presentations (array-dimensions choices))
      (labels ((one-of-them (stream victim ivictim indent)
		 (let* ((char-width (send stream :char-width))
			(incr-x (* indent char-width)))
		   (send stream :increment-cursorpos incr-x 0)
		   (with-character-style ('(:swiss :italic :normal) stream
					  :bind-line-height t)
		     (with-underlining (stream)
		       (format stream "Operation on ~a" victim))
		     (terpri stream))
		   (send stream :increment-cursorpos incr-x 0)
		   (send stream :increment-cursorpos (* 2 char-width) 0)
		   (multiple-value-bind (start-x ignore) (send stream :read-cursorpos)
		     (with-character-style ('(:jess :roman :large) stream
					    :bind-line-height t)
		       (dotimes (irow (cl:array-dimension choices 0))
			 (dotimes (icolumn (cl:array-dimension choices 1))
			   (send stream :set-cursorpos
				 ;; You see, I have an idea how wide the items are
				 (+ start-x (* icolumn (* 12 char-width)))
				 nil)
			   (setf (aref presentations irow icolumn ivictim)
				 (present (aref choices irow icolumn ivictim)
					  presentation-type :stream stream
					  :single-box t
					  :allow-sensitive-inferiors nil
					  :allow-sensitive-raw-text nil)))
			 (terpri stream)))))))
	(cond ((and victim2 (neq victim2 victim1))
	       (one-of-them stream victim1 0 0)
	       (terpri stream)
	       (one-of-them stream victim2 1 4))
	      (T (one-of-them stream victim1 0 0))))
      (loop for ivictim below 2
	    nconc (loop for icolumn below (cl:array-dimension presentations 1)
			nconc (loop for irow below (cl:array-dimension presentations 0)
				    when (aref presentations irow icolumn ivictim)
				      collect it))))))

(defun window-editor-move (window &key corner)
  (ignore corner)
  (mouse-set-window-position window))

(defun window-editor-bury (window &key corner)
  (ignore corner)
  (send window :bury))

(defun window-editor-kill (window &key corner)
  (ignore corner)
  (when (mouse-y-or-n-p (format nil "Kill ~A" (sheet-name window))
			(mouse-sheet (sheet-mouse window)))
    (send window :kill)))

(defun window-editor-hardcopy (window &key corner)
  (ignore corner)
  (hardcopy:hardcopy-window (send window :alias-for-selected-windows)))

(defun window-editor-expand (window &key corner)
  (ignore corner)
  (expand-window window))

;;; I think that it is too hard to remember what corner you were near when
;;; clicked to get the system menu, so by default always use the lower-right.
;;; -York 8/10/87
(defvar *default-window-reshape-corner* :lower-right
  "One of :lower-right, :lower-left, :upper-right and :upper-left,
or NIL to use the corner nearest the original mouse click.")

(defun window-editor-reshape (window
			      &key
			      (corner *default-window-reshape-corner*)
			      ;; can be :use-supplied-corner or :use-default-corner
			      (corner-mode :use-default-corner)
			      (move-window t))
  (let ((superior (send window :superior)))
    (multiple-value-bind (sup-mouse-dx sup-mouse-dy)
	(if superior
	    (sheet-mouse-offsets superior)
	    (values 0 0))
      (macrolet ((make-box-from-4-values (form)
		   `(sys:multiple-value-funcall-n #'dw::make-box ,form 4))
		 (set-window-edges-from-box (window box &rest more-args)
		   `(when move-window
		      (sys:multiple-value-funcall-n ,window
			:set-edges 1
			(dw::box-edges ,box) 4
			,@(loop for x in more-args
				collect x collect 1)))))
	(let* ((initial-box-sup (make-box-from-4-values (send window :edges)))
	       (initial-box-mouse (dw::box-copy-with-offsets
				    initial-box-sup sup-mouse-dx sup-mouse-dy))
	       (bounding-box-mouse
		 (and superior
		      (let ((bb (if (operation-handled-p superior :bounding-box-for-inferior)
				    (send superior :bounding-box-for-inferior window)
				    (make-box-from-4-values (send superior :inside-edges)))))
			;;bb is in superior's coords; translate to mouse's coords
			(dw::box-copy-with-offsets bb sup-mouse-dx sup-mouse-dy))))
	       (new-box-mouse (mouse-reshape-rectangle
				:sheet (mouse-sheet (sheet-mouse window))
				:initial-box initial-box-mouse
				:bounding-box bounding-box-mouse
				:corner (cl:ecase corner-mode
					  (:use-supplied-corner corner)
					  (:use-default-corner (or *default-window-reshape-corner* corner)))
				:abortable T))
	       (new-box-sup (and new-box-mouse
				 (dw::box-copy-with-offsets
				   new-box-mouse (- sup-mouse-dx) (- sup-mouse-dy)))))
	    (if new-box-sup
		(multiple-value-bind (ignore error)
		    (set-window-edges-from-box window new-box-sup :verify)
		  (cond (error
			 (beep)
			 (if superior
			     (pop-up-format (mouse-default-superior window)
					    "~a~@
					       Inferior's new edges    ~a~@
					       Superior's inside edges ~a"
					    error new-box-sup
					    (make-box-from-4-values
					      (send superior :inside-edges)))
			     (pop-up-format (mouse-default-superior window) "~a" error)))
			(T (set-window-edges-from-box window new-box-sup)))
		  (dw:box-edges new-box-sup))
		(dw:box-edges initial-box-sup)))))))

(defun mouse-reshape-rectangle (&key initial-box bounding-box (corner *default-window-reshape-corner*)
				abortable (sheet mouse-sheet)
				key-test
				)
  (let* ((mouse (sheet-mouse sheet))
	 (console (mouse-console mouse))
	 (key-test (or key-test 
		       #'(lambda () 
			   (console-key-state console :shift))))
	 )
    (multiple-value-bind (left top right bottom) (dw::box-edges initial-box)
      (with-this-mouse-and-buttons-grabbed (mouse)
	(setf (who-line-mouse-grabbed-documentation mouse)
	      (nth (if abortable 0 1)
		   '#.(loop for middle in '("Mouse-M: abort.  " "")
			    collect (string-append
				      "Mouse-L: Position corner of rectangle.  "
				      middle
				      "Mouse-R is smart.  "
				      "Hold down Shift to move opposite corner too."))))
	(cl:ecase corner
	  (:upper-left (mouse-warp left top mouse))
	  (:upper-right (mouse-warp right top mouse))
	  (:lower-left (mouse-warp left bottom mouse))
	  (:lower-right (mouse-warp right bottom mouse)))
	(mouse-set-blinker-definition-internal mouse
					       :box-tracking-corner-blinker 0 0 :on
					       :set-edges-and-moving-corner
					        left top right bottom corner)
	(when bounding-box
	  (sys:multiple-value-funcall-n (mouse-blinker mouse)
					:set-bounding-box 1
					(dw::box-edges bounding-box) 4))
	(let (button mx my width height)
	  (multiple-value-bind (new-button new-mx new-my new-width new-height)
	      (loop with old-shift-state = (funcall key-test)
		    with (button mx my)
		    for wait-function-decided-to-return = nil
		    do (send (mouse-blinker mouse) :set-opposite-corner-fixed
			     (not old-shift-state))
		       (multiple-value-bind (new-button new-mx new-my)
			   (wait-for-mouse-button-down
			     "Button" nil
			     (lambda () (setq wait-function-decided-to-return
					      (neq (funcall key-test)
						   old-shift-state)))
			     mouse)
			 (setq button new-button mx new-mx my new-my))
		       (cond (wait-function-decided-to-return
			      (setq old-shift-state (funcall key-test)))
			     (T (multiple-value-bind (width height)
				    (send (mouse-blinker mouse) :size-without-arrow)
				  (if (or (minusp width) (minusp height))
				      (beep)
				      (return (values button mx my width height)))))))
	    ;;--- This gets around a compiler bug...
	    (setq button new-button
		  mx new-mx my new-my
		  width new-width height new-height))
	  (mouse-standard-blinker nil mouse)
	  (setf (who-line-mouse-grabbed-documentation mouse) nil)
	  (unless (and abortable (bit-test 2 button))
	    (when (and (numberp mx) (numberp my))
	      (flet ((get-new-corner (at-right at-bottom)
		       (multiple-value-bind (x y)
			   (mouse-specified-point sheet mx my (bit-test 4 button)
						  at-right at-bottom)
			 (if bounding-box
			     (values (if at-right
					 (min (dw::box-right bounding-box) x)
				       (max (dw::box-left bounding-box) x))
				     (if at-bottom
					 (min (dw::box-bottom bounding-box) y)
				       (max (dw::box-top bounding-box) y)))
			   (values x y)))))
		(cl:ecase corner
		  (:upper-left
		    (multiple-value (left top) (get-new-corner nil nil))
		    (setq right (+ left width) bottom (+ top height)))
		  (:upper-right
		    (multiple-value (right top) (get-new-corner T nil))
		    (setq left (- right width) bottom (+ top height)))
		  (:lower-left
		    (multiple-value (left bottom) (get-new-corner nil T))
		    (setq right (+ left width) top (- bottom height)))
		  (:lower-right
		    (multiple-value (right bottom) (get-new-corner T T))
		    (setq left (- right width) top (- bottom height)))))
	      (when bounding-box
		(multiple-value-bind (bl bt br bb) (dw::box-edges bounding-box)
		  (setq left (max bl (min br left))
			top (max bt (min bb top))
			right (max bl (min br right))
			bottom (max bt (min bb bottom)))))
	      (dw::make-box left top right bottom))))))))
