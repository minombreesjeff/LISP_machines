;;; -*- Mode: LISP; Package: TV; Base: 8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;; Operations for moving, reshaping and creating windows,
;; and menus to get them from.

;; Item lists for the System Menu

(DEFVAR *SYSTEM-MENU-WINDOWS-COLUMN*		;General window operations
      '(("Create" :FUNCALL-WITH-SELF (LAMBDA (MENU)
				       (SYSTEM-MENU-CREATE-WINDOW
					 (MOUSE-DEFAULT-SUPERIOR MENU)))
	 :DOCUMENTATION "Create a new window.  Flavor of window selected from a menu.")
	("Select" :FUNCALL-WITH-SELF (LAMBDA (MENU)
				       (SYSTEM-MENU-SELECT-WINDOW
					 (MOUSE-DEFAULT-SUPERIOR MENU)))
	 :DOCUMENTATION "Select a window from a menu.")
	;; "Split Screen" is declared a development tool in TV-Applications, and is somewhat
	;; arbitrarily added to this column when "Inspect" is added to the Programs column.
	("Layouts" :FUNCALL-WITH-SELF (LAMBDA (MENU)
					(SYSTEM-MENU-LAYOUTS 
					  (MOUSE-DEFAULT-SUPERIOR MENU)))
	 :DOCUMENTATION "Save//restore current screen configuration.  Options from menu.")
	("Edit Screen" :BUTTONS
		(("Edit Screen" :FUNCALL-WITH-SELF (LAMBDA (MENU)
						     (EDIT-SCREEN
						       (MOUSE-DEFAULT-SUPERIOR MENU))))
		 ("Edit Screen" :FUNCALL-WITH-SELF (LAMBDA (MENU)
						     (EDIT-SCREEN
						       (MOUSE-DEFAULT-SUPERIOR MENU))))
		 ("Edit Screen" :WINDOW-OP
			(LAMBDA (WINDOW IGNORE IGNORE)
			  (SETQ WINDOW (SCREEN-EDITOR-FIND-SCREEN-TO-EDIT WINDOW))
			  (AND WINDOW (EDIT-SCREEN WINDOW)))))
		:DOCUMENTATION "Edit a screen.  Left edits screen the mouse is on, right button gives menu of frames."
		)
	("Set Mouse Screen" :BUTTONS ((NIL :EVAL (SYSTEM-MENU-SET-MOUSE-SCREEN NIL))
				      (NIL :EVAL (SYSTEM-MENU-SET-MOUSE-SCREEN NIL))
				      (NIL :EVAL (SYSTEM-MENU-SET-MOUSE-SCREEN T)))
	 :DOCUMENTATION "Set the screen the mouse is on.  Left defaults if possible, right always uses menu.")))

;;Programs outside of the basic system which add tools for the current
;;window to the system menu call this function, specifying string, function
;;to call (with the System Menu as its arg), mouse documentation string,
;;and optionally the name of another menu item they should be listed after.
;;The default (AFTER=NIL) is to add new programs at the bottom.  If AFTER=T
;;the new program is added at the top.
(DEFUN ADD-TO-SYSTEM-MENU-WINDOWS-COLUMN (NAME FORM DOCUMENTATION &OPTIONAL AFTER)
  (LET ((ITEM `(,NAME :FUNCALL-WITH-SELF ,FORM :DOCUMENTATION ,DOCUMENTATION))
	(OLD))
  (IF (SETQ OLD (ASSOC NAME *SYSTEM-MENU-WINDOWS-COLUMN*))
      (SETF (CDR OLD) (CDR ITEM))
    (SETQ *SYSTEM-MENU-WINDOWS-COLUMN*
	  (IF (EQ AFTER T) (CONS ITEM *SYSTEM-MENU-WINDOWS-COLUMN*)
	    (LOOP WITH AFTER = (OR (ASSOC AFTER *SYSTEM-MENU-WINDOWS-COLUMN*)
				   (CAR (LAST *SYSTEM-MENU-WINDOWS-COLUMN*)))
		  FOR X IN *SYSTEM-MENU-WINDOWS-COLUMN*
		  COLLECT X
		  WHEN (EQ X AFTER)
		  COLLECT ITEM))))))

(DEFVAR *SYSTEM-MENU-THIS-WINDOW-COLUMN*	;Operations on window mouse is over
      '(("Move" :BUTTONS ((() :WINDOW-OP SYSTEM-MENU-MOVE-WINDOW)
			  (() :WINDOW-OP SYSTEM-MENU-MOVE-WINDOW)
			  (() :WINDOW-OP SYSTEM-MENU-MOVE-WINDOW-MENU))
	 :DOCUMENTATION "Move the window that the mouse is over.  Mouse-Left: the window;  Mouse-Right: menu.")
	("Shape" :BUTTONS ((() :WINDOW-OP SYSTEM-MENU-SHAPE-WINDOW)
			   (() :WINDOW-OP SYSTEM-MENU-SHAPE-WINDOW)
			   (() :WINDOW-OP SYSTEM-MENU-SHAPE-WINDOW-MENU))
	 :DOCUMENTATION "Change the shape of the window that the mouse is over.  Mouse-Left: the window;  Mouse-Right: menu.")
	("Expand" :BUTTONS ((() :WINDOW-OP SYSTEM-MENU-EXPAND-WINDOW)
			    (() :WINDOW-OP SYSTEM-MENU-EXPAND-WINDOW)
			    (() :WINDOW-OP SYSTEM-MENU-EXPAND-WINDOW-MENU))
	 :DOCUMENTATION "Expand the window that the mouse is over, to fill empty space around it.  Mouse-Left: the window;  Mouse-Right: menu.")
	("Refresh" :WINDOW-OP (LAMBDA (WINDOW IGNORE IGNORE)
				(AND WINDOW (SEND WINDOW ':REFRESH)))
	 :DOCUMENTATION "Refresh the window that the mouse is over.")
	("Bury" :WINDOW-OP SYSTEM-MENU-BURY-WINDOW
	 :DOCUMENTATION
	    "Bury the window that the mouse is over, beneath all other active windows.")
	("Kill" :WINDOW-OP SYSTEM-MENU-KILL-WINDOW
	 :DOCUMENTATION "Kill the window that the mouse is over.")
	("Reset" :WINDOW-OP SYSTEM-MENU-RESET-WINDOW
	 :DOCUMENTATION
	    "Reset the process that can be found via the window the mouse is over.")
	("Arrest" :WINDOW-OP SYSTEM-MENU-ARREST-PROCESS
	 :DOCUMENTATION
	    "Arrest the process that can be found via the window the mouse is over.")
	("Un-Arrest" :WINDOW-OP SYSTEM-MENU-UNARREST-PROCESS
	 :DOCUMENTATION
	    "Un-arrest the process that can be found via the window the mouse is over (inverse of Arrest).")
	("Attributes" :WINDOW-OP SYSTEM-MENU-EDIT-WINDOW-ATTRIBUTES
	 :DOCUMENTATION
	    "View or change the attributes of the window that the mouse is over.")))

;Programs outside of the basic system which furnish added functionality for
;the system menu call this function, specifying string, form to evaluate,
;mouse documentation string, and optionally the name of another program
;they should be listed after, and a different form for the right mouse
;button and for the middle button.  The default (AFTER=NIL) is to add new
;programs at the bottom.  If AFTER=T the new program is added at the top.
(DEFUN ADD-TO-SYSTEM-MENU-THIS-WINDOW-COLUMN (NAME FORM DOCUMENTATION
					       &OPTIONAL AFTER RIGHT-FORM MIDDLE-FORM)
  (LET ((ITEM (IF (OR RIGHT-FORM MIDDLE-FORM)
		  `(,NAME :BUTTONS ((() :WINDOW-OP ,FORM)
				    (() :WINDOW-OP ,(OR MIDDLE-FORM FORM))
				    (() :WINDOW-OP ,(OR RIGHT-FORM FORM)))
		    :DOCUMENTATION ,DOCUMENTATION)
		`(,NAME :WINDOW-OP ,FORM :DOCUMENTATION ,DOCUMENTATION)))
	(OLD (ASSOC NAME *SYSTEM-MENU-THIS-WINDOW-COLUMN*)))
    (IF OLD
	(SETF (CDR OLD) (CDR ITEM))
      (SETQ *SYSTEM-MENU-THIS-WINDOW-COLUMN*
	    (IF (EQ AFTER T) (CONS ITEM *SYSTEM-MENU-THIS-WINDOW-COLUMN*)
	    (LOOP WITH AFTER = (OR (ASSOC AFTER *SYSTEM-MENU-THIS-WINDOW-COLUMN*)
				   (CAR (LAST *SYSTEM-MENU-THIS-WINDOW-COLUMN*)))
		  FOR X IN *SYSTEM-MENU-THIS-WINDOW-COLUMN*
		  COLLECT X
		  WHEN (EQ X AFTER)
		  COLLECT ITEM))))))

;;; These two should go away in sometime after 8.0.  --- Foner 12-Oct-89.
(deff add-to-systems-menu-this-window-column 'add-to-system-menu-this-window-column)
(compiler:make-obsolete add-to-systems-menu-this-window-column
			"it has been replaced by TV:ADD-TO-SYSTEM-MENU-THIS-WINDOW-COLUMN")

(DEFVAR *SYSTEM-MENU-PROGRAMS-COLUMN*		;Invoke the most commonly-needed programs
	'(("Emergency Break"
	   :EVAL (PROCESS-RUN-FUNCTION
		   "Emergency Break"
		   #'(LAMBDA () (KBD-USE-COLD-LOAD-STREAM "Emergency Break")))
	   :DOCUMENTATION 
	   "Evaluate Lisp forms without using the window system.  ** Use with caution **")))

;Programs outside of the basic system which want to appear in the system menu
;call this function, specifying string, form to evaluate, mouse documentation
;string, and optionally the name of another program they should be listed after.
;The default (AFTER=NIL) is to add new programs at the bottom.
;If AFTER=T the new program is added at the top.
;The SELECT-OR-CREATE-WINDOW-OF-FLAVOR function is often useful.
(DEFUN ADD-TO-SYSTEM-MENU-PROGRAMS-COLUMN (NAME FORM DOCUMENTATION &OPTIONAL AFTER)
  (LET ((ITEM `(,NAME :EVAL ,FORM :DOCUMENTATION ,DOCUMENTATION))
	(OLD))
  (IF (SETQ OLD (ASSOC NAME *SYSTEM-MENU-PROGRAMS-COLUMN*))
      (SETF (CDR OLD) (CDR ITEM))
    (SETQ *SYSTEM-MENU-PROGRAMS-COLUMN*
	  (IF (EQ AFTER T) (CONS ITEM *SYSTEM-MENU-PROGRAMS-COLUMN*)
	    (LOOP WITH AFTER = (OR (ASSOC AFTER *SYSTEM-MENU-PROGRAMS-COLUMN*)
				   (CAR (LAST *SYSTEM-MENU-PROGRAMS-COLUMN*)))
		  FOR X IN *SYSTEM-MENU-PROGRAMS-COLUMN*
		  COLLECT X
		  WHEN (EQ X AFTER)
		  COLLECT ITEM))))))

;Resource of system menus
(DEFWINDOW-RESOURCE SYSTEM-MENU ()
	:MAKE-WINDOW (DYNAMIC-MULTICOLUMN-MOMENTARY-WINDOW-HACKING-PROCESS-RENAMING-MENU
			 :COLUMN-SPEC-LIST '(("Windows" *SYSTEM-MENU-WINDOWS-COLUMN*
					      :STYLE (:SWISS :ITALIC :NORMAL)
					      :UNDERSCORE T)
					     ("This window" *SYSTEM-MENU-THIS-WINDOW-COLUMN*
					      :STYLE (:SWISS :ITALIC :NORMAL)
					      :UNDERSCORE T)
					     ("Programs" *SYSTEM-MENU-PROGRAMS-COLUMN*
					      :STYLE (:SWISS :ITALIC :NORMAL)
					      :UNDERSCORE T))
			 :SAVE-BITS ':DELAYED  ;since it would be the wrong size anyway
			 :STARTING-PROCESS-NAME "System Menu"
			 :BORDERS *DROP-SHADOW-BORDERS-SPEC*
			 :LABEL '(:STRING "The System Menu"
					  :STYLE (:SWISS :BOLD-ITALIC :NORMAL))
			 :VSP (MENU-VSP SUPERIOR))
	:REUSABLE-WHEN :DEEXPOSED)

;This is the menu of programs popped-up when you Click on create.  To keep the
;system menu from being absurdly big, some programs are in this menu but not
;in the programs column of the system menu.  Also this menu gives you a
;chance to set the edges.
(DEFVAR DEFAULT-WINDOW-TYPES-ITEM-LIST
      '(("Lisp" :VALUE DW::DYNAMIC-LISP-LISTENER
	 :DOCUMENTATION "A READ-EVAL-PRINT loop in separate process.")
	("Any" :VALUE T :STYLE (NIL :BOLD NIL)
	 :DOCUMENTATION "Prompts for any flavor name.")))

;Window flavors outside of the basic system which want to appear in the
;Create menu used by both the system menu and the screen editor
;call this function, specifying string, flavor of window, mouse documentation
;string, and optionally the name of another window-type they should be listed after.
;The default (AFTER=NIL) is to add new ones at the bottom.
;If AFTER=T the new one is added at the top.
(DEFUN ADD-TO-SYSTEM-MENU-CREATE-MENU (NAME FLAVOR DOCUMENTATION &OPTIONAL AFTER)
  (LET ((ITEM `(,NAME :VALUE ,FLAVOR :DOCUMENTATION ,DOCUMENTATION))
	(OLD))
  (IF (SETQ OLD (ASSOC NAME DEFAULT-WINDOW-TYPES-ITEM-LIST))
      (SETF (CDR OLD) (CDR ITEM))
    (SETQ DEFAULT-WINDOW-TYPES-ITEM-LIST
	  (IF (EQ AFTER T) (CONS ITEM DEFAULT-WINDOW-TYPES-ITEM-LIST)
	    (LOOP WITH AFTER = (IF AFTER
				   (ASSOC AFTER DEFAULT-WINDOW-TYPES-ITEM-LIST)
				   (NTH (- (LENGTH DEFAULT-WINDOW-TYPES-ITEM-LIST) 2)
					DEFAULT-WINDOW-TYPES-ITEM-LIST))
		  FOR X IN DEFAULT-WINDOW-TYPES-ITEM-LIST
		  COLLECT X
		  WHEN (EQ X AFTER)
		  COLLECT ITEM))))))

;This variable is usually bound to something appropriate when using the menus that
;depend on it.
;But it needs a global value so that the initial copy of the menu can get created.
(DEFVAR WINDOW-TYPES-ITEM-LIST DEFAULT-WINDOW-TYPES-ITEM-LIST)

;Resource of menus of flavors of windows user can create with mouse
(DEFWINDOW-RESOURCE WINDOW-TYPE-MENU ()
	:MAKE-WINDOW (DYNAMIC-MOMENTARY-MENU :ITEM-LIST-POINTER 'WINDOW-TYPES-ITEM-LIST
					     :SAVE-BITS ':DELAYED
					     :LABEL "Window type"
					     )
	:REUSABLE-WHEN :DEEXPOSED)

(DEFMETHOD (:PANE-TYPES-ALIST SHEET) ()
  (SEND SUPERIOR ':PANE-TYPES-ALIST))

(DEFMETHOD (:PANE-TYPES-ALIST BASIC-SCREEN) ()
  DEFAULT-WINDOW-TYPES-ITEM-LIST)

;;; All screens whose windows could be selected on a screen on this console
(DEFMETHOD (CONSOLE-SCREENS-FOR-SELECTION CLI::CONSOLE) ()
  (LET ((RESULT NIL))
    (DOLIST (SCREEN ALL-THE-SCREENS)
      (WHEN (EQ (SEND SCREEN :CONSOLE) SELF)
	(UNLESS (TYPEP SCREEN 'GENERIC-WHO-LINE-SCREEN-MIXIN)
	  (CL:PUSHNEW SCREEN RESULT))))
    (DOLIST (SCREEN *OLD-CONSOLE-SCREENS*)
      (CL:PUSHNEW SCREEN RESULT))
    (NREVERSE RESULT)))

(DEFUN SELECTABLE-WINDOWS (SUP)
  (SEND SUP ':SELECTABLE-WINDOWS))

;Resource of menus of windows that user can select
(DEFWINDOW-RESOURCE SELECTABLE-WINDOWS-MENU ()
  :MAKE-WINDOW (DYNAMIC-MOMENTARY-MENU
		 :ITEM-LIST-POINTER '(MAPCAN #'SELECTABLE-WINDOWS
					     (CONSOLE-SCREENS-FOR-SELECTION
					       (SHEET-CONSOLE SELF)))
		 :SAVE-BITS NIL			;changes every time anyway
		 :label "Select window")
  :REUSABLE-WHEN :DEEXPOSED)

(DEFUN SYSTEM-MENU-SELECT-WINDOW (&OPTIONAL (SUP MOUSE-SHEET))
  (LET ((MENU (ALLOCATE-RESOURCE 'SELECTABLE-WINDOWS-MENU SUP)))
    (SEND MENU :UPDATE-ITEM-LIST)
    (COND ((NULL (SEND MENU ':ITEM-LIST))
	   (BEEP)
	   (POP-UP-MESSAGE "Error: There are no windows that can be selected." SUP))
	  (T
	   (LET ((WINDOW (SEND MENU ':CHOOSE)))
	     (AND WINDOW (MOUSE-SELECT WINDOW)))))))

;Must return the window or NIL
(DEFUN SYSTEM-MENU-CREATE-WINDOW (&OPTIONAL (SUP MOUSE-SHEET) (EDGES-FROM 'MOUSE))
  (LET* ((WINDOW-TYPES-ITEM-LIST (SEND SUP ':PANE-TYPES-ALIST))
	 (MS (MOUSE-SHEET (SHEET-MOUSE SUP)))
	 (WINDOW-TYPE (COND ((NULL WINDOW-TYPES-ITEM-LIST)
			     (BEEP)
			     NIL)
			    ((NULL (CDR WINDOW-TYPES-ITEM-LIST))
			     (CDAR WINDOW-TYPES-ITEM-LIST))
			    (T
			     (SEND (ALLOCATE-RESOURCE 'WINDOW-TYPE-MENU MS) ':CHOOSE)))))
    (AND WINDOW-TYPE (LISTP WINDOW-TYPE)
	 (SETQ WINDOW-TYPE (EVAL WINDOW-TYPE)))
    (UNWIND-PROTECT
	(PROGN (AND (EQ WINDOW-TYPE T)	;"Any"
		    (SETQ WINDOW-TYPE
			  (GET-WINDOW-TYPE-FROM-KEYBOARD SUP ':EDGES-FROM)))
	       (COND (WINDOW-TYPE
		      (MOUSE-SET-SHEET SUP)
		      (CREATE-WINDOW-WITH-MOUSE WINDOW-TYPE EDGES-FROM MS))))
      (MOUSE-SET-SHEET MS))))

;Must return the window or NIL
(DEFUN CREATE-WINDOW-WITH-MOUSE (FLAVOR-NAME &OPTIONAL (EDGES-FROM 'MOUSE) (TOP MOUSE-SHEET)
					     &AUX TEM ARGS)
  (WHEN (LISTP FLAVOR-NAME)
    (CL:SETF `(,FLAVOR-NAME . ,ARGS) FLAVOR-NAME))
  (AND FLAVOR-NAME
       ;; Get the edges before creating the window so can abort.
       (CAR (SETQ TEM
		  (SELECTQ EDGES-FROM
		    (MOUSE
		     (MULTIPLE-VALUE-LIST
		       (MOUSE-SPECIFY-RECTANGLE NIL NIL NIL NIL TOP
			    (FLAVOR:FLAVOR-DEFAULT-INIT-GET FLAVOR-NAME ':MINIMUM-WIDTH 0)
			    (FLAVOR:FLAVOR-DEFAULT-INIT-GET FLAVOR-NAME ':MINIMUM-HEIGHT 0)
			    T)))
		    (EXPAND
		     (MULTIPLE-VALUE-LIST
		       (MOUSE-SPECIFY-EXPAND TOP))))))
       (LET ((WINDOW (LEXPR-FUNCALL #'MAKE-WINDOW FLAVOR-NAME
				    ':SUPERIOR TOP ':EDGES TEM
				    ARGS)))
	 (SEND WINDOW ':MOUSE-SELECT)
	 WINDOW)))

(DEFUN SYSTEM-MENU-SET-MOUSE-SCREEN (HAIRY &AUX SCREENS)
  (DOLIST (S ALL-THE-SCREENS)
    (AND (SHEET-EXPOSED-P S)
	 (SEND S ':USER-VISIBLE)
	 (EQ (SHEET-MOUSE S) MAIN-MOUSE)
	 (PUSH (CONS (SHEET-NAME S) S) SCREENS)))
  (COND ((= (LENGTH SCREENS) 1)
	 (MOUSE-SET-SHEET (CDAR SCREENS)))
	((NOT HAIRY)
	 (MOUSE-SET-SHEET (DO ((L SCREENS (CDR L)))
			      ((NULL L) (CDAR SCREENS))
			    (AND (EQ (CDAR L) (MOUSE-SHEET MAIN-MOUSE))
				 (CDR L)
				 (RETURN (CDADR L))))))
	(T (LET ((S (MENU-CHOOSE SCREENS "Mouse onto:")))
	     (AND S (MOUSE-SET-SHEET S))))))

(DEFVAR *USE-NEW-MOUSE-Y-OR-N-P* T)

;Use this for functions that need confirmation.  Returns non-NIL if user confirms.
(DEFUN MOUSE-Y-OR-N-P (MESSAGE &OPTIONAL (SUPERIOR (MOUSE-DEFAULT-SUPERIOR)))
  (IF *USE-NEW-MOUSE-Y-OR-N-P*
 ;; Dodds has some concerns about this interface and wonders if 
 ;;  (LET ((OPTIONS `(,MESSAGE ("Cancel"  :VALUE NIL :FONT FONTS:JESS11I))))
 ;;    (IF (MENU-CHOOSE OPTIONS "Confirm:" '(:MOUSE) (CAR OPTIONS) SUPERIOR) ...))
 ;; wouldn't be another possible way to do this.  For now, though, he and I have
 ;; agreed to try the version SWM and I worked out, and see what comments come back.
 ;; -kmp 2-Oct-92
      (LET ((OPTIONS '(("Yes" :VALUE T :FONT FONTS:JESS14)
		       ("No"  :VALUE NIL :FONT FONTS:JESS14))))
	(IF (MENU-CHOOSE OPTIONS
			 `(:STRING ,(FORMAT NIL "~VConfirm: ~~%~V ~~A~ ~"
					  '(:JESS :ROMAN :NORMAL)
					  '(:JESS :BOLD :LARGE)
					  MESSAGE)
			   ;; The style of the string is fully specified above.
			   ;; This hack is just to get the line-height to be a little better.
			   ;; Sigh. -kmp 2-Oct-92
			   :STYLE (:FIX NIL :VERY-LARGE)
			  )
			 '(:MOUSE)
			 (CAR OPTIONS)
			 SUPERIOR)
	    ;; For historical reasons, this returns the MESSAGE as its true value.
	    MESSAGE
	    NIL))
      (MENU-CHOOSE (LIST MESSAGE) "Confirm:" '(:MOUSE) MESSAGE SUPERIOR)))

(DEFUN SYSTEM-MENU-KILL-WINDOW (WINDOW IGNORE IGNORE)
  (COND ((NULL WINDOW))
	((TYPEP WINDOW 'SCREEN) (BEEP))
	((MOUSE-Y-OR-N-P
	   (FORMAT NIL "Kill ~A"
		   (SHEET-NAME (SETQ WINDOW (OR (SEND WINDOW ':ALIAS-FOR-SELECTED-WINDOWS)
						WINDOW))))
	   (MOUSE-SHEET (SHEET-MOUSE WINDOW)))
	 (SEND WINDOW ':KILL))))

(DEFUN SYSTEM-MENU-RESET-WINDOW (WINDOW IGNORE IGNORE)
  (COND ((NULL WINDOW))
	((NOT (OPERATION-HANDLED-P WINDOW :RESET-PROCESS))
	 (BEEP))
	((MOUSE-Y-OR-N-P (FORMAT NIL "Reset process in ~A" (SHEET-NAME WINDOW))
			 (MOUSE-SHEET (SHEET-MOUSE WINDOW)))
	 (SEND WINDOW :RESET-PROCESS))))

(DEFUN SYSTEM-MENU-BURY-WINDOW (WINDOW IGNORE IGNORE)
  (COND ((NULL WINDOW))
	((TYPEP WINDOW 'SCREEN) (BEEP))
	(T (SEND (OR (SEND WINDOW ':ALIAS-FOR-SELECTED-WINDOWS) WINDOW) ':BURY))))

(DEFUN SYSTEM-MENU-ARREST-PROCESS (WINDOW IGNORE IGNORE)
  (COND ((NULL WINDOW))
	((NOT (OPERATION-HANDLED-P WINDOW :ARREST)) (BEEP))
	(T (SEND WINDOW ':ARREST))))

(DEFUN SYSTEM-MENU-UNARREST-PROCESS (WINDOW IGNORE IGNORE)
  (COND ((NULL WINDOW))
	((NOT (OPERATION-HANDLED-P WINDOW :UN-ARREST)) (BEEP))
	(T (SEND WINDOW :UN-ARREST))))

(DEFUN SELECT-OR-CREATE-WINDOW-OF-FLAVOR (FIND-FLAVOR &OPTIONAL (CREATE-FLAVOR FIND-FLAVOR))
  (SEND (OR (FIND-WINDOW-OF-FLAVOR FIND-FLAVOR) (MAKE-WINDOW CREATE-FLAVOR))
	':MOUSE-SELECT))

(DEFUN SYSTEM-MENU-EDIT-WINDOW-ATTRIBUTES (WINDOW IGNORE IGNORE)
  (AND WINDOW
       (SCREEN-EDITOR-EDIT-ATTRIBUTES WINDOW)))

(DEFUN SYSTEM-MENU-MOVE-WINDOW (WINDOW OLD-MOUSE-X OLD-MOUSE-Y)
  (SYSTEM-MENU-WINDOW-EDIT #'WINDOW-EDITOR-MOVE () WINDOW OLD-MOUSE-X OLD-MOUSE-Y))
(DEFUN SYSTEM-MENU-MOVE-WINDOW-MENU (WINDOW OLD-MOUSE-X OLD-MOUSE-Y)
  (SYSTEM-MENU-WINDOW-EDIT #'WINDOW-EDITOR-MOVE T WINDOW OLD-MOUSE-X OLD-MOUSE-Y))

(DEFUN SYSTEM-MENU-SHAPE-WINDOW (WINDOW OLD-MOUSE-X OLD-MOUSE-Y)
  (SYSTEM-MENU-WINDOW-EDIT #'WINDOW-EDITOR-RESHAPE () WINDOW OLD-MOUSE-X OLD-MOUSE-Y))
(DEFUN SYSTEM-MENU-SHAPE-WINDOW-MENU (WINDOW OLD-MOUSE-X OLD-MOUSE-Y)
  (SYSTEM-MENU-WINDOW-EDIT #'WINDOW-EDITOR-RESHAPE T WINDOW OLD-MOUSE-X OLD-MOUSE-Y))

(DEFUN SYSTEM-MENU-EXPAND-WINDOW (WINDOW OLD-MOUSE-X OLD-MOUSE-Y)
  (SYSTEM-MENU-WINDOW-EDIT #'WINDOW-EDITOR-EXPAND () WINDOW OLD-MOUSE-X OLD-MOUSE-Y))
(DEFUN SYSTEM-MENU-EXPAND-WINDOW-MENU (WINDOW OLD-MOUSE-X OLD-MOUSE-Y)
  (SYSTEM-MENU-WINDOW-EDIT #'WINDOW-EDITOR-EXPAND T WINDOW OLD-MOUSE-X OLD-MOUSE-Y))

(DEFUN SYSTEM-MENU-HARDCOPY-WINDOW (WINDOW OLD-MOUSE-X OLD-MOUSE-Y)
  (SYSTEM-MENU-WINDOW-EDIT #'WINDOW-EDITOR-HARDCOPY () WINDOW OLD-MOUSE-X OLD-MOUSE-Y))
(DEFUN SYSTEM-MENU-HARDCOPY-WINDOW-MENU (WINDOW OLD-MOUSE-X OLD-MOUSE-Y)
  (SYSTEM-MENU-WINDOW-EDIT #'WINDOW-EDITOR-HARDCOPY T WINDOW OLD-MOUSE-X OLD-MOUSE-Y))

(DEFUN SYSTEM-MENU-WINDOW-EDIT (FUNCTION OFFER-MENU WINDOW OLD-MOUSE-X OLD-MOUSE-Y)
  (LET ((ALIAS (SEND WINDOW :ALIAS-FOR-SELECTED-WINDOWS)))
    (LET ((VICTIM
	    (IF OFFER-MENU
		(WITH-DATA-STACK
		  (FLET ((NAME-OF (WINDOW)
			   (LET ((N (FLATC WINDOW)))
			     (LET ((ARR (MAKE-STACK-ARRAY N :TYPE 'ART-STRING
							  :FILL-POINTER 0)))
			       (FORMAT ARR "~a" WINDOW)
			       ARR))))
		    (STACK-LET ((CHOICES `((,(NAME-OF ALIAS) ,ALIAS)
					   (,(NAME-OF WINDOW) ,WINDOW))))
		      (UNLESS (AND ALIAS (NEQ ALIAS WINDOW))
			(POP CHOICES))
		      (MENU-CHOOSE CHOICES "Which window?" '(:MOUSE) ()
				   (MOUSE-SHEET (SHEET-MOUSE WINDOW))))))
		(IF (AND ALIAS (NEQ ALIAS WINDOW)) ALIAS WINDOW))))
      (WHEN VICTIM
	(MULTIPLE-VALUE-BIND (X-OFFSET Y-OFFSET MOUSE)
	    (SHEET-MOUSE-OFFSETS WINDOW)
	  (IGNORE MOUSE)
	  (LET ((WINDOW-X (- OLD-MOUSE-X X-OFFSET))
		(WINDOW-Y (- OLD-MOUSE-Y Y-OFFSET)))
	    (LET ((CORNER
		    (MULTIPLE-VALUE-BIND (W-WIDTH W-HEIGHT)
			(SEND VICTIM :SIZE)
		      (MACROLET ((NEARER ((VAR LOWER HIGHER)
					  LOWER-CASE HIGHER-CASE)
				   `(IF (< (ABS (- ,VAR ,LOWER))
					   (ABS (- ,VAR ,HIGHER)))
					,LOWER-CASE ,HIGHER-CASE)))
			(NEARER (WINDOW-X 0 W-WIDTH)
				(NEARER (WINDOW-Y 0 W-HEIGHT)
					:UPPER-LEFT :LOWER-LEFT)
				(NEARER (WINDOW-Y 0 W-HEIGHT)
					:UPPER-RIGHT :LOWER-RIGHT))))))
	      (FUNCALL FUNCTION VICTIM :CORNER CORNER))))))))

;;; Stuff for setting up a screen layout.
;;; Suggested improvements:
;;;  Find out why it thrashes the disk for several seconds before coming up,
;;;   after displaying all the windows.
;;;  Provide the ability to edit saved screen layouts.
;;;  Provide the ability to edit the SPLIT-SCREEN-LAYOUT-WINDOW with the mouse
;;;  Figure out why the choose-variable-values window sometimes fails to
;;;   appear and also why it sometimes fails to use a frame when I clearly told it to.

(DEFVAR SPLIT-SCREEN-ITEM-LIST
	'(("Existing Lisp" :VALUE "Existing Lisp"
	   :DOCUMENTATION "An already existing LISP Listener.")
	  ("Existing Window" :VALUE "Existing Window"
	   :DOCUMENTATION "An already existing window chosen from a menu.")
	  ("Plain Window" :VALUE "Plain Window"
	   :DOCUMENTATION "A window with no special attributes, suitable for simple output.")
	  ("Trace & Debug" :VALUE "Trace & Debug"
	   :DOCUMENTATION "Where trace output and Debugger interaction are directed.")
	  ("Trace" :VALUE "Trace" :DOCUMENTATION "Where trace output is directed.")
	  ("Debug" :VALUE "Debug" :DOCUMENTATION "Where the Debugger will run.")
	  ("" :NO-SELECT T) ("" :NO-SELECT T)
	  ("Frame" :VALUE "Frame" :DOCUMENTATION "Put chosen windows together in a frame.")
	  ("Mouse Corners" :VALUE "Mouse Corners"
	   :DOCUMENTATION "Specify the area to fill from the mouse.")
	  ("" :NO-SELECT T)
	  ("Undo" :VALUE "Undo" :DOCUMENTATION "Undo last selection.")
	  ("Do It" :VALUE "Do It" :STYLE (NIL :BOLD NIL)
	   :DOCUMENTATION "Complete selection.")
	  ("Abort" :VALUE "Abort" :STYLE (NIL :BOLD NIL)
	   :DOCUMENTATION "Abort Split Screen.")
	  ))

(DEFUN SPLIT-SCREEN-ITEM-LIST ()
  (APPEND WINDOW-TYPES-ITEM-LIST
	  (IF (ODDP (LENGTH WINDOW-TYPES-ITEM-LIST))
	      '(("" :NO-SELECT T)))
	  SPLIT-SCREEN-ITEM-LIST))

(DEFWINDOW-RESOURCE SPLIT-SCREEN-MENU ()
	:MAKE-WINDOW (DYNAMIC-POP-UP-ABORT-ON-DEEXPOSE-COMMAND-MENU
			 :NAME "Split Screen Menu"
			 :LABEL "Split screen element:" :COLUMNS 2 :SAVE-BITS ':DELAYED
			 :IO-BUFFER (MAKE-IO-BUFFER 10)
			 :ITEM-LIST-POINTER '(SPLIT-SCREEN-ITEM-LIST))
	:REUSABLE-WHEN :DEEXPOSED)

(DEFWINDOW-RESOURCE SPLIT-SCREEN-CHOOSE-VALUES ()
	:CONSTRUCTOR
	  (LET ((CVVW (MAKE-WINDOW 'TEMPORARY-CHOOSE-VARIABLE-VALUES-WINDOW
				   ':SUPERIOR SUPERIOR
				   ':NAME "Split Screen Choose Values"
				   ':CHARACTER-WIDTH 40.
				   ':IO-BUFFER NIL)))
	    (SEND CVVW ':SETUP '((*USE-FRAME* "Enclose windows in a frame" :BOOLEAN)
				 (*FRAME-NAME* "Name of frame" :STRING)
				 (*SELECT-KEY* "[SELECT] <char> selects it"
					       :CHARACTER-OR-NIL))
			       "Frame characteristics:"
			       'SPLIT-SCREEN-CHOOSE-VALUES-FUNCTION
			       NIL)	;No margin choices
	    (SEND CVVW ':ADJUST-GEOMETRY-FOR-NEW-VARIABLES
		  (SHEET-INSIDE-WIDTH CVVW))
	    CVVW)
	:REUSABLE-WHEN :DEEXPOSED
	:INITIAL-COPIES NIL)  ;due to order of loading of files

(DEFUN SPLIT-SCREEN-CHOOSE-VALUES-FUNCTION (WINDOW VARIABLE OLD-VALUE NEW-VALUE)
  (IGNORE OLD-VALUE)
  (AND (EQ VARIABLE '*USE-FRAME*)
       (EQ NEW-VALUE NIL)
       (SEND WINDOW :FORCE-KBD-INPUT '(PUNT-FRAME)))
  NIL)						;Normal redisplay

(DEFUN SYSTEM-MENU-SPLIT-SCREEN-VIA-MENUS (&OPTIONAL (SUP MOUSE-SHEET))
  (USING-RESOURCE (SCVM-MENU SPLIT-SCREEN-MENU SUP)
    (USING-RESOURCE (LAYWIN SPLIT-SCREEN-LAYOUT-WINDOW SUP)
      (LET* ((WINDOW-TYPES-ITEM-LIST (SEND SUP ':PANE-TYPES-ALIST))
	     (EDGES (LIST (SHEET-INSIDE-LEFT SUP) (SHEET-INSIDE-TOP SUP)
			  (SHEET-INSIDE-RIGHT SUP) (SHEET-INSIDE-BOTTOM SUP)))
	     (INTERACTION-WINDOWS NIL) (CVVW NIL)
	     (*USE-FRAME* NIL) (*FRAME-NAME* "Split-screen frame") (*SELECT-KEY* NIL)
	     (IO-BUFFER) (ITEM))
	(DECLARE (SPECIAL *FRAME-NAME* *SELECT-KEY* *USE-FRAME*))
	(SEND LAYWIN ':CLEAR-FROBS)
	(SETQ IO-BUFFER (SEND SCVM-MENU ':IO-BUFFER))
	(IO-BUFFER-CLEAR IO-BUFFER)
	(EXPOSE-WINDOW-NEAR SCVM-MENU '(:MOUSE))
	(PUSH SCVM-MENU INTERACTION-WINDOWS)
	(UNWIND-PROTECT
	  (DO ((WINDOW-TYPE-LIST NIL)
	       (N-WINDOWS 0)
	       (RES))
	      (NIL)
	    (COND ((AND (PLUSP N-WINDOWS) (NOT (MEMQ LAYWIN INTERACTION-WINDOWS)))
		   (AND CVVW (SEND CVVW ':DEEXPOSE))		;May need to be moved
		   (SEND LAYWIN ':MOVE-NEAR-WINDOW SCVM-MENU
			 (CONS (- (THIRD EDGES) (FIRST EDGES))
			       (- (FOURTH EDGES) (SECOND EDGES))))
		   (PUSH LAYWIN INTERACTION-WINDOWS)
		   (AND CVVW (EXPOSE-WINDOW-NEAR CVVW
			       (CONS ':WINDOW (REMQ CVVW INTERACTION-WINDOWS))
			       NIL))))
	    (PROCESS-WAIT "Choose" #'(LAMBDA (B) (NOT (IO-BUFFER-EMPTY-P B))) IO-BUFFER)
	    (SETQ RES (IO-BUFFER-GET IO-BUFFER))
	    (COND ((AND (EQ (FIRST RES) ':MENU) (EQ (FOURTH RES) SCVM-MENU))
		   (SETQ RES (SEND SCVM-MENU ':EXECUTE (SETQ ITEM (SECOND RES))))
		   (AND (EQ RES T)		;"Any"
			(SETQ RES (GET-WINDOW-TYPE-FROM-KEYBOARD SUP ':EDGES-FROM
				    (CONS ':WINDOW INTERACTION-WINDOWS))))
		   (COND ((NULL RES))	;Maybe failed getting type from keyboard
			 ((EQUAL RES "Abort") (RETURN NIL))
			 ((EQUAL RES "Mouse Corners")
			  (COND ((CAR (SETQ RES (MULTIPLE-VALUE-LIST
						  (MOUSE-SPECIFY-RECTANGLE NIL NIL NIL NIL
									   SUP 0 0 T))))
				 (SETQ EDGES RES)
				 ;; Next line causes shape of LAYWIN to be recomputed
				 (SETQ INTERACTION-WINDOWS
				       (DELQ LAYWIN INTERACTION-WINDOWS)))))
			 ((EQUAL RES "Undo")
			  (COND ((PLUSP N-WINDOWS)
				 (SETQ N-WINDOWS (1- N-WINDOWS)
				       WINDOW-TYPE-LIST (CDR WINDOW-TYPE-LIST))
				 (SEND LAYWIN ':REMOVE-LAST-FROB))))			     
			 ((EQUAL RES "Frame")
			  (SETQ *USE-FRAME* T)
			  (COND ((NULL CVVW)
				 (SETQ CVVW (ALLOCATE-RESOURCE
					      'SPLIT-SCREEN-CHOOSE-VALUES SUP))
				 (SEND CVVW ':SET-IO-BUFFER IO-BUFFER)
				 (SEND CVVW ':SET-STACK-GROUP %CURRENT-STACK-GROUP)
				 (EXPOSE-WINDOW-NEAR CVVW (CONS ':WINDOW INTERACTION-WINDOWS))
				 (PUSH CVVW INTERACTION-WINDOWS))))
			 ((EQUAL RES "Existing Window")
			  ;; This used to use SELECTABLE-WINDOWS-MENU, but that lists only
			  ;; activities (selectable windows), not all windows, and includes
			  ;; useless ones that are on the wrong screen.
			  (USING-RESOURCE (AW-MENU MOMENTARY-MENU SUP)
			    (SEND AW-MENU :SET-LABEL "Choose window")
			    (SEND AW-MENU :SET-ITEM-LIST
					  (LOOP FOR W IN (SHEET-INFERIORS SUP)
						UNLESS (MEMQ W INTERACTION-WINDOWS)
						COLLECT (LIST (OR (SEND W :NAME-FOR-SELECTION)
								  (SHEET-NAME W))
							      W)))
			    (EXPOSE-WINDOW-NEAR AW-MENU (CONS ':WINDOW INTERACTION-WINDOWS))
			    (LET ((W (SEND AW-MENU :CHOOSE)))
			      (WHEN W
				(SEND LAYWIN ':ADD-FROB (OR (SEND W :NAME-FOR-SELECTION)
							    (SHEET-NAME W)))
				(PUSH W WINDOW-TYPE-LIST)
				(SETQ N-WINDOWS (1+ N-WINDOWS)))))
			  (LEXPR-SEND SCVM-MENU ':SET-MOUSE-CURSORPOS
				      (MULTIPLE-VALUE-LIST
					(SEND SCVM-MENU ':ITEM-CURSORPOS ITEM))))
			 ((NOT (EQUAL RES "Do It"))
			  (PUSH RES WINDOW-TYPE-LIST)
			  (SEND LAYWIN ':ADD-FROB
				(OR (GET-STRING-FROM-WINDOW-TYPE RES)
				    (STRING RES)))
			  (SETQ N-WINDOWS (1+ N-WINDOWS)))
			 ((ZEROP N-WINDOWS) (BEEP))	;Do It with nothing to do
			 (T (DELAYING-SCREEN-MANAGEMENT
			      (DOLIST (W INTERACTION-WINDOWS)	;Done with these now
				(SEND W ':DEACTIVATE))
			      (IF (NOT *USE-FRAME*)
				  (SPLIT-SCREEN-VIA-MENUS-SETUP-WINDOW SUP EDGES
				    WINDOW-TYPE-LIST N-WINDOWS LAYWIN)
				  ;; SPLIT-SCREEN-FRAME isn't necessarily the right
				  ;; flavor.  Maybe ask user whether it should be a
				  ;; constraint-frame.  Maybe put borders around it, but
				  ;; need a way for them to appear when partially
				  ;; exposed even though it doesn't have a
				  ;; bit-save array.
				  (LET ((FRAME (MAKE-WINDOW 'SPLIT-SCREEN-FRAME
							    ':SUPERIOR SUP
							    ':EDGES-FROM EDGES
							    ':NAME *FRAME-NAME*
							    ':EXPOSE-P T)))
				    (WHEN *SELECT-KEY*
				      (TV:ADD-SELECT-KEY *SELECT-KEY* FRAME *FRAME-NAME*
							 NIL T))
				    (LET ((SEL (SPLIT-SCREEN-VIA-MENUS-SETUP-WINDOW FRAME
						 (LIST (SHEET-INSIDE-LEFT FRAME)
						       (SHEET-INSIDE-TOP FRAME)
						       (SHEET-INSIDE-RIGHT FRAME)
						       (SHEET-INSIDE-BOTTOM FRAME))
						 WINDOW-TYPE-LIST N-WINDOWS LAYWIN)))
				      ;; This wouldn't be needed if frames weren't broken
				      (AND (MEMQ SEL (SHEET-EXPOSED-INFERIORS FRAME))
					   (SEND FRAME ':SELECT-PANE SEL))))))
			    (RETURN NIL))))
		  ((EQ (FIRST RES) ':VARIABLE-CHOICE)
		   (APPLY #'CHOOSE-VARIABLE-VALUES-CHOICE (CDR RES)))
		  ((EQ (FIRST RES) 'PUNT-FRAME)
		   (SEND CVVW ':DEACTIVATE)
		   (SETQ INTERACTION-WINDOWS (DELQ CVVW INTERACTION-WINDOWS))
		   (SETQ *USE-FRAME* NIL CVVW NIL))
		  (T (FERROR "Garbage from i//o buffer: ~S" RES))))
	  (DELAYING-SCREEN-MANAGEMENT
	    (DOLIST (W INTERACTION-WINDOWS)	;Done with these now
	      (SEND W ':DEACTIVATE))))))))

;; Return the string that was displayed for the window type chosen by the user, or NIL if
;; we can't figure it out.  This will cause "Edit" to be displayed in the tiny label
;; instead of "ZMACS-FRAME", for instance.  If we can't figure out which item our window
;; type came from, then display the name of the flavor.

(DEFUN GET-STRING-FROM-WINDOW-TYPE (TYPE)
  (DOLIST (ITEM WINDOW-TYPES-ITEM-LIST)
    (IF (EQ (MENU-EXECUTE-NO-SIDE-EFFECTS ITEM) TYPE)
	(RETURN (FIRST ITEM)))))

;; We now have the list of windows, lay out the screen and set them up.
;; The general rule for screen layout is that 2 or 3 windows stack vertically,
;; 4 are in a square, 5 are a square with 1 below it, etc.
;; To generalize, you have floor(n/2) rows in 2 columns and 1 below if n is odd
;; This returns the window it selects, or NIL
(DEFUN SPLIT-SCREEN-VIA-MENUS-SETUP-WINDOW (SUP EDGES WINDOW-TYPE-LIST N-WINDOWS LAYWIN
					    &AUX N-COLUMNS N-ROWS WIDTH HEIGHT TEM WINDOW SEL
					    LL)
  LAYWIN  ;ignored for now
  (IF (< N-WINDOWS 4)
      (SETQ N-COLUMNS 1 N-ROWS N-WINDOWS)
      (SETQ N-COLUMNS 2 N-ROWS (// (1+ N-WINDOWS) 2)))
  (SETQ WIDTH (// (- (THIRD EDGES) (FIRST EDGES)) N-COLUMNS)
	HEIGHT (// (- (FOURTH EDGES) (SECOND EDGES)) N-ROWS))
  (LOCK-SHEET (SUP)
    (DOLIST (WINDOW (SHEET-EXPOSED-INFERIORS SUP))
      (SEND WINDOW ':DEEXPOSE))
    (DO ((L (NREVERSE WINDOW-TYPE-LIST) (CDR L))
	 (I 0 (1+ I)) (LEFT) (RIGHT) (TOP) (BOTTOM))
	((NULL L))
      (SETQ LEFT (+ (FIRST EDGES) (* (\ I N-COLUMNS) WIDTH))
	    RIGHT (+ LEFT WIDTH)
	    TOP (+ (SECOND EDGES) (* (// I N-COLUMNS) HEIGHT))
	    BOTTOM (+ TOP HEIGHT))
      ;; The bottom-most window is wider if there are an odd number of them
      (AND (NULL (CDR L))
	   (SETQ RIGHT (THIRD EDGES)))
      (COND ((EQUAL (CAR L) "Existing Lisp")
	     (SETQ WINDOW (FIND-INFERIOR-OF-FLAVOR SUP 'DW::DYNAMIC-LISP-LISTENER T LL))
	     (PUSH WINDOW LL)
	     (SEND WINDOW ':SET-EDGES LEFT TOP RIGHT BOTTOM)
	     (OR SEL (SETQ SEL WINDOW)))
	    ((SETQ TEM (ASSOC (CAR L) '(("Plain Window")
					("Trace" TRACE-OUTPUT)
					("Debug" DBG:*DEBUG-IO-OVERRIDE*)
					("Trace & Debug" TRACE-OUTPUT DBG:*DEBUG-IO-OVERRIDE*)
					)))
	     (SETQ WINDOW (MAKE-WINDOW 'WINDOW
				       ':SUPERIOR SUP
				       ':NAME (AND (CDR TEM) (CAR TEM))
				       ':LEFT LEFT ':TOP TOP
				       ':RIGHT RIGHT ':BOTTOM BOTTOM))		     
	     (DOLIST (V (CDR TEM))
	       (SET V WINDOW)))
	    ((INSTANCEP (CAR L))		;Window itself
	     (SETQ WINDOW (CAR L))
	     (SEND WINDOW ':SET-SUPERIOR SUP)
	     (SEND WINDOW ':SET-EDGES LEFT TOP RIGHT BOTTOM)
	     (OR SEL (SETQ SEL WINDOW)))
	    (T
	     (LET ((FLAVOR (CAR L))
		   (OPTIONS NIL))
	       (WHEN (LISTP FLAVOR)
		 (SETQ FLAVOR (EVAL FLAVOR)))
	       (WHEN (LISTP FLAVOR)
		 (CL:SETF `(,FLAVOR . ,OPTIONS) FLAVOR))
	       (SETQ WINDOW (LEXPR-FUNCALL #'MAKE-WINDOW FLAVOR
					   ':SUPERIOR SUP
					   ':LEFT LEFT ':TOP TOP
					   ':RIGHT RIGHT ':BOTTOM BOTTOM
					   OPTIONS)))
	     (OR SEL (SETQ SEL WINDOW))))
      (SEND WINDOW ':EXPOSE))
    (AND SEL (SEND SEL ':SELECT)))
  SEL)

(DEFVAR SCREEN-LAYOUT-MENU-ALIST NIL)
(DEFWINDOW-RESOURCE SCREEN-LAYOUT-MENU ()
    :MAKE-WINDOW (MOMENTARY-MENU :NAME "Screen Layout Menu" :LABEL "Screen Layouts"
		    :ITEM-LIST `(("Just Lisp" :EVAL `((,(FIND-INFERIOR-OF-FLAVOR ',SUPERIOR
							  'LISP-LISTENER T)
						       ,(SHEET-INSIDE-LEFT ',SUPERIOR)
						       ,(SHEET-INSIDE-TOP ',SUPERIOR)
						       ,(SHEET-INSIDE-RIGHT ',SUPERIOR)
						       ,(SHEET-INSIDE-BOTTOM ',SUPERIOR))))
				 ("Save This" :EVAL (PROGN (SAVE-THIS-SCREEN-LAYOUT) NIL))))
    :REUSABLE-WHEN :DEEXPOSED)

;;; This needs grossly more error checking!!
(DEFUN SYSTEM-MENU-LAYOUTS (&OPTIONAL (SCREEN MOUSE-SHEET))
  (USING-RESOURCE (MENU SCREEN-LAYOUT-MENU SCREEN)
    (LET ((X (SEND MENU ':CHOOSE)))
      (COND (X 
	     (DELAYING-SCREEN-MANAGEMENT
	       (DOLIST (Y X)
		 (LET ((WINDOW (CAR Y))
		       (EDGES (CDR Y)))
		   (SEND WINDOW ':SET-EDGES
			 (FIRST EDGES) (SECOND EDGES)
			 (THIRD EDGES) (FOURTH EDGES))
		   (SEND WINDOW ':EXPOSE))))
	     (SEND (CAAR X) ':SELECT NIL))))))

(DEFUN SAVE-THIS-SCREEN-LAYOUT (&OPTIONAL (SCREEN MOUSE-SHEET) &AUX SW)
  (USING-RESOURCE (MENU SCREEN-LAYOUT-MENU SCREEN)
    (SEND MENU ':SET-ITEM-LIST
	  (CONS (LIST (GET-LINE-FROM-KEYBOARD "Name for this screen layout")
		      ':VALUE
		      (LET (LIST)
			(MAP-OVER-EXPOSED-SHEET
			  #'(LAMBDA (W)
			      (AND (NOT (SHEET-TEMPORARY-P W))
				   (NEQ W MOUSE-SHEET)
				   (PUSH (CONS W (MULTIPLE-VALUE-LIST (SEND W ':EDGES)))
					 LIST)))
			  MOUSE-SHEET)
			(SETQ LIST (NREVERSE LIST))
			;; Move selected window to the front
			(WHEN (SETQ SW (ASSQ (SHEET-SELECTED-WINDOW SCREEN) LIST))
			  (SETQ LIST (LIST* SW (DELQ SW LIST))))
			LIST))
		(SEND MENU ':ITEM-LIST)))))

(DEFWINDOW-RESOURCE POP-UP-TEXT-WINDOW ()
	:MAKE-WINDOW (POP-UP-TEXT-WINDOW))

(DEFWINDOW-RESOURCE POP-UP-TEXT-WINDOW-WITHOUT-MORE ()
	:MAKE-WINDOW (POP-UP-TEXT-WINDOW :MORE-P NIL))

;;; Pop up a window with a message in it, require user to type a character to flush.
(DEFUN POP-UP-MESSAGE (PROMPT &OPTIONAL (SUP MOUSE-SHEET) (POP-UP-NEAR '(:MOUSE)))
  (LET ((MESSAGE (STRING-APPEND PROMPT "
Click here or type any character to flush:  ")))
    (USING-RESOURCE (POP-UP-MESSAGE-WINDOW POP-UP-TEXT-WINDOW-WITHOUT-MORE SUP)
      (SEND POP-UP-MESSAGE-WINDOW :SET-LABEL NIL)
      (SEND POP-UP-MESSAGE-WINDOW :SET-SIZE-IN-CHARACTERS MESSAGE MESSAGE)
      (SEND POP-UP-MESSAGE-WINDOW :CLEAR-INPUT)
      (EXPOSE-WINDOW-NEAR POP-UP-MESSAGE-WINDOW POP-UP-NEAR NIL)
      (WINDOW-CALL (POP-UP-MESSAGE-WINDOW :DEACTIVATE)
	(SEND POP-UP-MESSAGE-WINDOW :STRING-OUT MESSAGE)
	;; Back up the cursor by one.  This is easier than trying to make the window
	;; come out wider, because of the interface to :set-size-in-characters.
	(MULTIPLE-VALUE-BIND (X-POS Y-POS)
	    (SEND POP-UP-MESSAGE-WINDOW :READ-CURSORPOS ':CHARACTER)
	(SEND POP-UP-MESSAGE-WINDOW :SET-CURSORPOS (1- X-POS) Y-POS ':CHARACTER))
	(SEND POP-UP-MESSAGE-WINDOW :ANY-TYI)))))

;Pop up a formatted message near the mouse
(DEFUN POP-UP-FORMAT (SUP CONTROL &REST ARGS)
  (POP-UP-MESSAGE (LEXPR-FUNCALL #'FORMAT NIL CONTROL ARGS) SUP))

;;; Pop up a window near where the mouse is, then read a line from it.

(DEFUN GET-LINE-FROM-KEYBOARD (PROMPT &OPTIONAL (SUP MOUSE-SHEET) (FUNCTION #'READLINE)
						(POP-UP-NEAR '(:MOUSE)) (xsize 0) (ysize 0))
  (USING-RESOURCE (GET-LINE-FROM-KEYBOARD-WINDOW POP-UP-TEXT-WINDOW SUP)

    (COND (PROMPT
	   (SEND GET-LINE-FROM-KEYBOARD-WINDOW ':SET-SIZE-IN-CHARACTERS PROMPT PROMPT)
	   (MULTIPLE-VALUE-BIND (W H)
	       (SEND GET-LINE-FROM-KEYBOARD-WINDOW ':SIZE-IN-CHARACTERS)
	     (SEND GET-LINE-FROM-KEYBOARD-WINDOW ':SET-SIZE-IN-CHARACTERS
		   (MAX (+ W 2) XSIZE)
		   (MAX (+ H 3) YSIZE))))
	  (T (SEND GET-LINE-FROM-KEYBOARD-WINDOW :SET-SIZE-IN-CHARACTERS
		   (MAX 2 XSIZE)
		   (MAX 3 YSIZE))))
    (FUNCALL GET-LINE-FROM-KEYBOARD-WINDOW ':SET-LABEL NIL)

    ;guard against tiny superiors
    (MULTIPLE-VALUE-BIND (W H) (SEND GET-LINE-FROM-KEYBOARD-WINDOW :SIZE)
      (MULTIPLE-VALUE-BIND (SW SH) (SEND SUP :INSIDE-SIZE)
	(WHEN (OR (> W SW)(> H SH))
	  (SEND GET-LINE-FROM-KEYBOARD-WINDOW :SET-SIZE (MIN W SW)(MIN H SH)))))

    (FUNCALL GET-LINE-FROM-KEYBOARD-WINDOW ':CLEAR-INPUT)
    (EXPOSE-WINDOW-NEAR GET-LINE-FROM-KEYBOARD-WINDOW POP-UP-NEAR NIL)
    (WINDOW-CALL (GET-LINE-FROM-KEYBOARD-WINDOW :DEACTIVATE)
      (when prompt (FORMAT GET-LINE-FROM-KEYBOARD-WINDOW "~A:~%" PROMPT))
      (FUNCALL FUNCTION GET-LINE-FROM-KEYBOARD-WINDOW))))

(DEFUN GET-WINDOW-TYPE-FROM-KEYBOARD (&OPTIONAL (SUP MOUSE-SHEET) REQUIRED-INIT-OPTION
						(POP-UP-NEAR '(:MOUSE)) (XSIZE 0) (YSIZE 0))
  (CATCH-ERROR-RESTART ((ERROR ABORT) "Abort entering window type")
    (GET-LINE-FROM-KEYBOARD
      NIL
      SUP
      #'(LAMBDA (A)
	  (ACCEPT `(WINDOW-FLAVOR :REQUIRED-INIT-OPTION ,REQUIRED-INIT-OPTION)
		  :STREAM A)
	  )
      POP-UP-NEAR (MAX XSIZE 100) YSIZE))
  )


;;;Hack window for split screen
(DEFFLAVOR DISPLAY-LAYOUT-WINDOW ((FROBS NIL))
				 (TEMPORARY-WINDOW-MIXIN BORDERS-MIXIN MINIMUM-WINDOW)
  (:INITABLE-INSTANCE-VARIABLES FROBS))

(DEFMETHOD (:INIT DISPLAY-LAYOUT-WINDOW :BEFORE) (INIT-PAIRS)
  (PUTPROP INIT-PAIRS NIL ':BLINKER-P))

(DEFMETHOD (:INIT DISPLAY-LAYOUT-WINDOW :AFTER) (IGNORE)
  (SETQ LEFT-MARGIN-SIZE 1 TOP-MARGIN-SIZE 1
	RIGHT-MARGIN-SIZE 1 BOTTOM-MARGIN-SIZE 1))

(DEFMETHOD (:CLEAR-FROBS DISPLAY-LAYOUT-WINDOW) ()
  (SETQ FROBS NIL)
  (SHEET-FORCE-ACCESS (SELF T)
    (SEND SELF ':CLEAR-WINDOW)))

(DEFMETHOD (:ADD-FROB DISPLAY-LAYOUT-WINDOW) (FROB &AUX N)
  (SETQ N (LENGTH FROBS)
	FROBS (NCONC FROBS (NCONS FROB)))
  (SHEET-FORCE-ACCESS (SELF)
    (DRAW-FROBS SELF FROBS N ERASE-ALUF)
    (DRAW-FROBS SELF FROBS (1+ N) CHAR-ALUF)))

(DEFMETHOD (:REMOVE-LAST-FROB DISPLAY-LAYOUT-WINDOW) ()
  (SETQ FROBS (NREVERSE (CDR (NREVERSE FROBS))))
  (SHEET-FORCE-ACCESS (SELF :NO-PREPARE)
    (SEND SELF ':CLEAR-WINDOW)
    (DRAW-FROBS SELF FROBS (LENGTH FROBS) CHAR-ALUF)))

(DEFMETHOD (:REFRESH DISPLAY-LAYOUT-WINDOW :AFTER) (&OPTIONAL IGNORE)
  (OR RESTORED-BITS-P
      (DRAW-FROBS SELF FROBS (LENGTH FROBS) CHAR-ALUF)))

(DEFUN DRAW-FROBS (SHEET FROBS N ALU)
  (OR (ZEROP N)
      (LET ((INSIDE-LEFT (SHEET-INSIDE-LEFT SHEET))
	    (INSIDE-TOP (SHEET-INSIDE-TOP SHEET))
	    (INSIDE-RIGHT (SHEET-INSIDE-RIGHT SHEET))
	    (INSIDE-BOTTOM (SHEET-INSIDE-BOTTOM SHEET))
	    (INSIDE-HEIGHT (SHEET-INSIDE-HEIGHT SHEET))
	    (INSIDE-WIDTH (SHEET-INSIDE-WIDTH SHEET))
	    MIDDLE NROW)
	(IF (< N 4)
	    (SETQ NROW N)
	    (SETQ NROW (// (1+ N) 2)
		  MIDDLE (+ INSIDE-LEFT (// INSIDE-WIDTH 2))))
	(PREPARE-SHEET (SHEET)
	  (DO ((I NROW (1- I))
	       (J 0 (1+ J))
	       (FROBS FROBS (CDR FROBS))
	       (Y) (Y1)
	       (LHEIGHT (// INSIDE-HEIGHT NROW))
	       (ODDP (ODDP N)))
	      (( I 0))
	    (SETQ Y (+ INSIDE-TOP (// (* INSIDE-HEIGHT J) NROW))
		  Y1 (IF (= I 1) (1- INSIDE-BOTTOM) (+ Y LHEIGHT)))
	    (OR (= I 1)
		(SHEET-DRAW-LINE INSIDE-LEFT Y1 INSIDE-WIDTH Y1 ALU T SHEET))
	    (DRAW-LAYOUT-LABEL SHEET (CAR FROBS) INSIDE-LEFT Y1
			       (IF (OR (NULL MIDDLE) (AND (= I 1) ODDP)) INSIDE-RIGHT MIDDLE)
			       LHEIGHT ALU)
	    (COND ((NOT (OR (NULL MIDDLE) (AND (= I 1) ODDP)))
		   (SHEET-DRAW-LINE MIDDLE Y MIDDLE Y1 ALU T SHEET)
		   (SETQ FROBS (CDR FROBS))
		   (DRAW-LAYOUT-LABEL SHEET (CAR FROBS) MIDDLE Y1 INSIDE-RIGHT
				      LHEIGHT ALU))))))))

(DEFUN DRAW-LAYOUT-LABEL (SHEET STRING X Y XLIM LHEIGHT ALU)
  (COND ((< LHEIGHT 3))				;Too small for anything
	((< LHEIGHT 7)				;Too small for Einy7
	 (DRAW-LAYOUT-TURDS SHEET STRING (1+ X) (- Y 2) XLIM ALU))
	(T
	 (WITH-CHARACTER-STYLE ('(:FIX NIL :VERY-SMALL) SHEET)
	   (SEND SHEET ':STRING-OUT-EXPLICIT (STRING STRING)
		 (1+ X) (- Y 11.) XLIM ALU)))))

(DEFUN DRAW-LAYOUT-TURDS (SHEET STRING X Y XLIM ALU)
  (DO ((I 0 (1+ I))
       (X X (+ X 2))
       (LEN (STRING-LENGTH STRING)))
      ((OR ( I LEN) ( X XLIM)))
    (UNLESS (CHAR= (AREF STRING I) #\SP)
      (SHEET-DRAW-POINT X Y ALU SHEET))))

;;;Move along side a window
;;;Try to make the same height as that window, but if that won't fit because it
;;;comes out too wide then become shorter, and center.
;;;DIMENSIONS argument controls the width to height ratio.
;;;MINIMUM-SIZE is the smallest allowed size for the smaller of the two dimensions.
(DEFMETHOD (:MOVE-NEAR-WINDOW DISPLAY-LAYOUT-WINDOW)
	   (WINDOW &OPTIONAL (DIMENSIONS '(1 . 1)) (MINIMUM-SIZE 100.)
		   &AUX (MINIMUM-WIDTH (* (MAX (// (CAR DIMENSIONS) (CDR DIMENSIONS)) 1)
					  MINIMUM-SIZE))
			(MINIMUM-HEIGHT (* (MAX (// (CDR DIMENSIONS) (CAR DIMENSIONS)) 1)
					   MINIMUM-SIZE)))
  (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
      (SEND WINDOW ':EDGES)
    (LET ((NEW-WIDTH (// (* (CAR DIMENSIONS) (- BOTTOM TOP)) (CDR DIMENSIONS)))
	  (NEW-HEIGHT (- BOTTOM TOP))
	  (NTOP TOP)
	  (NBOTTOM BOTTOM)
	  NLEFT NRIGHT)
      (COND (( (SETQ NLEFT (- LEFT NEW-WIDTH)) (SHEET-INSIDE-LEFT SUPERIOR))
	     (SETQ NRIGHT LEFT))	;Fits on the left
	    (( (SETQ NRIGHT (+ RIGHT NEW-WIDTH)) (SHEET-INSIDE-RIGHT SUPERIOR))
	     (SETQ NLEFT RIGHT))	;Fits on the right
	    ((OR ( (- (SHEET-INSIDE-WIDTH SUPERIOR) (- RIGHT LEFT)) MINIMUM-WIDTH)
		 (NOT (OR ( (- TOP (SHEET-INSIDE-TOP SUPERIOR)) MINIMUM-HEIGHT)
			  ( (- (SHEET-INSIDE-BOTTOM SUPERIOR) BOTTOM) MINIMUM-HEIGHT))))
					;Put on whichever side has more room
	     (IF ( (- LEFT (SHEET-INSIDE-LEFT SUPERIOR))
		    (- (SHEET-INSIDE-RIGHT SUPERIOR) RIGHT))
		 (SETQ NLEFT (SHEET-INSIDE-LEFT SUPERIOR) NRIGHT LEFT)
		 (SETQ NLEFT RIGHT NRIGHT (SHEET-INSIDE-RIGHT SUPERIOR)))
	     (SETQ NEW-WIDTH (- NRIGHT NLEFT)
		   NEW-HEIGHT (// (* (CDR DIMENSIONS) NEW-WIDTH) (CAR DIMENSIONS)))
	     (SETQ NTOP (MAX (// (- (+ TOP BOTTOM) NEW-HEIGHT) 2)
			     (SHEET-INSIDE-TOP SUPERIOR))
		   NBOTTOM (MIN (+ NTOP NEW-HEIGHT) (SHEET-INSIDE-BOTTOM SUPERIOR))))
	    (T				;No room beside window, put above or below
	     (SETQ NLEFT (MAX (// (- (+ LEFT RIGHT) NEW-WIDTH) 2)
			      (SHEET-INSIDE-LEFT SUPERIOR))
		   NRIGHT (MIN (+ NLEFT NEW-WIDTH) (SHEET-INSIDE-RIGHT SUPERIOR)))
	     (COND (( (SETQ NTOP (- TOP NEW-HEIGHT)) (SHEET-INSIDE-TOP SUPERIOR))
		    (SETQ NBOTTOM TOP))	;Put above
		   (( (SETQ NBOTTOM (+ BOTTOM NEW-HEIGHT)) (SHEET-INSIDE-BOTTOM SUPERIOR))
		    (SETQ NTOP BOTTOM))	;Put below
		   (( (- TOP (SHEET-INSIDE-TOP SUPERIOR)) ;Put wherever there is any space!
		       (- (SHEET-INSIDE-BOTTOM SUPERIOR) BOTTOM))
		    (SETQ NTOP (SHEET-INSIDE-TOP SUPERIOR)
			  NBOTTOM TOP))
		   (T (SETQ NBOTTOM (SHEET-INSIDE-BOTTOM SUPERIOR)
			    NTOP BOTTOM)))))
      (SEND SELF ':SET-EDGES NLEFT NTOP NRIGHT NBOTTOM)))
  (SEND SELF ':EXPOSE))

(COMPILE-FLAVOR-METHODS DISPLAY-LAYOUT-WINDOW)


(DEFWINDOW-RESOURCE SPLIT-SCREEN-LAYOUT-WINDOW ()
	:MAKE-WINDOW (DISPLAY-LAYOUT-WINDOW :HEIGHT (// (SHEET-HEIGHT MOUSE-SHEET) 4.))
	:REUSABLE-WHEN :DEEXPOSED)

;;; This goes in QTRACE

;;; Display Features

;; Items in this menu are lists of the form:
;;  ("name" :VALUE (S-expr-arg-p . what-to-append-into-trace-options))
;;			^-- if this is UNTRACE, QUIT, or DO-IT, that special function
;;			if NIL, nothing special
;;			otherwise a string, which is treated as a prompt for
;;		         reading what goes into trace options.
;;                      or PER-PROCESS, which has to be handled specially
;; Try to keep this so it comes out in 3 columns
(DEFVAR TRACE-ITEM-LIST
	`(("Break before" :VALUE (NIL :BREAK T)
	   :DOCUMENTATION "Call BREAK before entering the function, binding ARGLIST.")
	  ("Break after" :VALUE (NIL :EXITBREAK T)
	   :DOCUMENTATION "Call BREAK after leaving the function, binding VALUES.")
	  ("Step" :VALUE (NIL :STEP)
	   :DOCUMENTATION "Single-step through the body of the (interpreted) function.")
	  ("Error" :VALUE (NIL :ERROR)
	   :DOCUMENTATION "Enter the error-handler when the function is called.")
	  ("Print" :VALUE ("Form to evaluate and print in trace messages" :PRINT)
	   :DOCUMENTATION "Asks for a form to be evaluated and printed in trace messages.")
	  ("Print before" :VALUE ("Form to evaluate and print before calling" :ENTRYPRINT)
	   :DOCUMENTATION "Asks for a form to be evaluated and printed upon function entry.")
	  ("Print after" :VALUE ("Form to evaluate and print after returning" :EXITPRINT)
	   :DOCUMENTATION "Asks for a form to be evaluated and printed upon function exit.")
	  ("Conditional" :VALUE ("Predicate for tracing" :COND)
	   :DOCUMENTATION "Asks for a predicate which controls whether tracing happens.")
	  ("Cond before" :VALUE ("Predicate for tracing calls" :ENTRYCOND)
	   :DOCUMENTATION "Asks for a predicate which controls tracing of function entry.")
	  ("Cond after" :VALUE ("Predicate for tracing returns" :EXITCOND)
	   :DOCUMENTATION "Asks for a predicate which controls tracing of function exit.")
	  ("Cond break before" :VALUE ("Predicate for breaking before" :BREAK)
	   :DOCUMENTATION "Asks for a predicate which controls BREAKing on function entry.")
	  ("Cond break after" :VALUE ("Predicate for breaking after" :EXITBREAK)
	   :DOCUMENTATION "Asks for a predicate which controls BREAKing on function exit.")
	  ("ARGPDL" :VALUE ("Arg pdl variable" :ARGPDL)
	   :DOCUMENTATION "Asks for a variable which gets list of recursive argument lists.")
	  ("Wherein" :VALUE ("Function within which to trace" :WHEREIN)
	   :DOCUMENTATION "Asks for a function, within which tracing will be active.")
	  ("Untrace" :VALUE (UNTRACE)
	   :DOCUMENTATION "Instead of tracing this function, stop tracing it.")
	  ("Per Process" :VALUE (PER-PROCESS)
	   :DOCUMENTATION
	   "Asks for a process, with a pop-up menu.  Trace only in that process.")
	  ("Abort" :VALUE (QUIT) :STYLE (:FIX :BOLD :LARGE)
	   :DOCUMENTATION "Click here to get out of this without doing anything.")
	  ("Do It" :VALUE (DO-IT) :STYLE (:FIX :BOLD :LARGE)
	   :DOCUMENTATION "Click here to do the tracing with the selected options.")))

(DEFWINDOW-RESOURCE TRACE-POP-UP-MENU ()
  :MAKE-WINDOW (DYNAMIC-POP-UP-COMMAND-MENU :NAME "Trace Options"
					    :ITEM-LIST-POINTER 'TRACE-ITEM-LIST)
  :REUSABLE-WHEN :DEEXPOSED)

;;; This function is invoked in the momentary menu process when the user clicks "trace"
;;; and in the editor process by the editor's Trace command.
;;; If the function isn't supplied as an argument the user is asked for it.
(DEFUN TRACE-VIA-MENUS (&OPTIONAL FCN)
  (USING-RESOURCE (TRACE-POP-UP-WINDOW POP-UP-TEXT-WINDOW)
    (USING-RESOURCE (TRACE-POP-UP-MENU TRACE-POP-UP-MENU)
      (SEND TRACE-POP-UP-WINDOW ':SET-LABEL "Trace")
      (SEND TRACE-POP-UP-WINDOW ':SET-SIZE 1000 300)
      (SEND TRACE-POP-UP-WINDOW ':CENTER-AROUND
	    (MOUSE-X (SHEET-MOUSE TRACE-POP-UP-WINDOW))
	    (MOUSE-Y (SHEET-MOUSE TRACE-POP-UP-WINDOW)))
      (SEND TRACE-POP-UP-MENU :SET-IO-BUFFER (SEND TRACE-POP-UP-WINDOW :IO-BUFFER))
      (WINDOW-CALL (TRACE-POP-UP-WINDOW :DEACTIVATE)
	(UNWIND-PROTECT
	  (CONDITION-CASE ()
	      (LET ((TERMINAL-IO TRACE-POP-UP-WINDOW)
		    (STANDARD-INPUT SI:SYN-TERMINAL-IO)
		    (STANDARD-OUTPUT SI:SYN-TERMINAL-IO)
		    (QUERY-IO SI:SYN-TERMINAL-IO)
		    (BLINKER (SHEET-FOLLOWING-BLINKER TRACE-POP-UP-WINDOW)))
		(UNLESS FCN
		  ;; Make sure blinker is blinking
		  (BLINKER-SET-VISIBILITY BLINKER ':BLINK)
		  (SETQ FCN
			(PROMPT-AND-READ '(:FUNCTION-SPEC :DEFINED-P T)
					 "Type in the name of a function to be traced or untraced.~@
					  ~XPress ‘ to quit.~%")))
		(SEND TRACE-POP-UP-MENU ':MOVE-NEAR-WINDOW TRACE-POP-UP-WINDOW)
		(DO ((FORM (IF (ATOM FCN) `(TRACE (,FCN)) `(TRACE (:FUNCTION ,FCN))))
		     (UNTRACE-MODE NIL)
		     (CHOICE) (OPTION) (ARG))
		    (NIL)
		  ;; Put the current status on the text window
		  (SEND TRACE-POP-UP-WINDOW ':CLEAR-WINDOW)
		  (CL:PPRINT FORM TRACE-POP-UP-WINDOW)
		  (FORMAT TRACE-POP-UP-WINDOW "~2&Press ‘ to quit or ” to finish.~%")
		  ;; Not listening to the keyboard any more, shut off blinker.
		  ;; If we type Suspend, then we are in a break loop without any blinker.
		  (BLINKER-SET-VISIBILITY BLINKER NIL)
		  ;; Get input from the menu or from the keyboard, or notice that the window
		  ;; has been deexposed.  If the window is deexposed while we are inside READ,
		  ;; however, the process will not go away.  Need the New Interaction System here.
		  (PROCESS-WAIT "Mouse or Keyboard"
				#'(LAMBDA (WINDOW MENU)
				    (OR (SEND WINDOW :LISTEN)
					(NOT (SEND WINDOW :EXPOSED-P))
					(NOT (SEND MENU :EXPOSED-P))))
				TRACE-POP-UP-WINDOW
				TRACE-POP-UP-MENU)
		  (COND
		    ;; Either the window or the menu is no longer exposed.
		    ((NOT (AND (SEND TRACE-POP-UP-WINDOW :EXPOSED-P)
			       (SEND TRACE-POP-UP-MENU :EXPOSED-P)))
		     (RETURN NIL))
		    ;; Returned from the wait function for some random reason.
		    ((NOT (SEND TRACE-POP-UP-WINDOW :LISTEN)))
		    ;; Input is available.
		    (T
		     (SETQ CHOICE (SEND TRACE-POP-UP-WINDOW :ANY-TYI))
		     (COND
		       ;; Keyboard input
		       ((CHARACTERP CHOICE)
			(SELECTOR CHOICE CHAR-EQUAL
			  (#\REFRESH)
			  (#\END
			   (EVAL FORM)
			   (RETURN NIL))
			  (#\ABORT
			   (RETURN NIL))
			  (OTHERWISE
			   (BEEP))))
		       ;; Menu input
		       ((AND (LISTP CHOICE) (EQ (CAR CHOICE) :MENU))
			(SETQ CHOICE (SEND TRACE-POP-UP-MENU :EXECUTE (CADR CHOICE)))
			(SETQ OPTION (FIRST CHOICE))
			(COND ((NULL CHOICE))	;Try again if outside menu
			      ((EQ OPTION 'UNTRACE)
			       (SETQ UNTRACE-MODE T
				     FORM `(UNTRACE ,FCN)))
			      ((EQ OPTION 'QUIT)
			       (RETURN NIL))
			      ((EQ OPTION 'DO-IT)
			       (EVAL FORM)
			       (RETURN NIL))
			      (UNTRACE-MODE
			       (BEEP))
			      ((EQ OPTION 'PER-PROCESS)
			       (LET ((PROCESS (GET-PROCESS-VIA-MENU)))
				 (WHEN PROCESS
				   (SETF (SECOND FORM)
					 (APPEND (SECOND FORM)
						 `(:PER-PROCESS ',PROCESS))))))
			      (T (SETF (SECOND FORM)
				       (APPEND (SECOND FORM) (CDR CHOICE)))
				 (COND (OPTION	;Needs an arg, get it
						;Turn on blinker
					(BLINKER-SET-VISIBILITY BLINKER ':BLINK)
					(FORMAT T "~2%")
					(SETQ ARG (PROMPT-AND-READ :EXPRESSION "~A:~%" OPTION))
					(SETF (SECOND FORM)
					      (APPEND (SECOND FORM) (LIST ARG))))))))
		       ;; Some other random input
		       (T (BEEP)))))))
	    (ABORT))
	  (SEND TRACE-POP-UP-MENU ':DEACTIVATE))))))

;;; Pop up a momentary menu showing the names of all processes.
;;; Return NIL if the user moves off the menu, otherwise return the process chosen.
(DEFUN GET-PROCESS-VIA-MENU ()
   (TV:MENU-CHOOSE (LOOP FOR P IN PROCESS:*ALL-PROCESSES*
		      WHEN (PROCESS:PROCESS-ACTIVE-P P)
		      COLLECT (LIST (SEND P :NAME) ':VALUE P))))
