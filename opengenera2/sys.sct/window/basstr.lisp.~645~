;;; -*- Mode: LISP; Package: TV; Base: 8 -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>


;;; This file contains keyboard process
(DEFVAR *KEYBOARD-PROCESS-ESC-CHARACTERS*
  `((#\FUNCTION . KBD-ESC)
    (#\SELECT . KBD-SYS)
    (#\HYPER-CONTROL-FUNCTION)
    (#\KEYBOARD:PRINT . KBD-PRINT)))

(DEFUN ADD-KEYBOARD-ESC-CHARACTER (CHARACTER FUNCTION)
  (SCL:PUSHNEW (CONS CHARACTER FUNCTION) *KEYBOARD-PROCESS-ESC-CHARACTERS*
	       :REPLACE T :KEY #'FIRST :LOCALIZE T))

(DEFMETHOD (CONSOLE-HARDWARE-OR-REPEAT-CHAR-AVAILABLE CLI::CONSOLE) (&OPTIONAL IN-PTR)
  (OR (CONSOLE-HARDWARE-CHAR-AVAILABLE SELF IN-PTR)
      (CLI::KEYBOARD-TIME-TO-REPEAT (CONSOLE-KEYBOARD SELF))))

(DEFMETHOD (CONSOLE-PROCESS-INPUT CLI::CONSOLE) ()
  ;; If the cold-load stream is using the keyboard, don't read from it here,
  ;; unless this is the the scheduler or the process that is using the cold-load-stream.
  (WHEN (OR (NULL COLD-LOAD-STREAM-SELECTED)
	    (NULL CURRENT-PROCESS)
	    (EQ DBG:SAVED-SCREEN-PROCESS CURRENT-PROCESS))
    (AND DBG:SAVED-SCREEN-PROCESS (EQ DBG:SAVED-SCREEN-PROCESS CURRENT-PROCESS)
	 (FERROR "Attempt to read from keyboard while in cold load stream."))
    (WITHOUT-INTERRUPTS
      (LET ((KEYBOARD (CONSOLE-KEYBOARD SELF))
	    (MOUSE (CONSOLE-MOUSE SELF))
	    (SYSTEM-BUFFER (CONSOLE-SYSTEM-IO-BUFFER SELF))
	    (SELECTED-BUFFER (CONSOLE-GET-SELECTED-IO-BUFFER SELF))
	    (RAW-P NIL)
	    (BUFFER-TABLE NIL) (BUFFER-MODE-LOCK-TABLE NIL))
	(WHEN SELECTED-BUFFER
	  (LET ((PLIST (IO-BUFFER-PLIST SELECTED-BUFFER)))
	    (IF (GETF PLIST :RAW)
		(SETQ RAW-P T)
		(SETQ BUFFER-TABLE (GETF PLIST :KEYBOARD-TABLE)
		      BUFFER-MODE-LOCK-TABLE (GETF PLIST :MODE-LOCK-KEYBOARD-TABLE)))))
	(UNLESS BUFFER-TABLE
	  (SETQ BUFFER-TABLE (CLI::KEYBOARD-KEYBOARD-TABLE KEYBOARD)))
	(UNLESS BUFFER-MODE-LOCK-TABLE
	  (SETQ BUFFER-MODE-LOCK-TABLE (CLI::KEYBOARD-MODE-LOCK-KEYBOARD-TABLE KEYBOARD)))
	(FLET ((PROCESS-INPUT-UNTIL (IN-PTR)
		 (LOOP UNTIL (OR (AND (NULL IN-PTR) (CLI::CONSOLE-ESC-FUNCTION SELF))
				 (NOT (CONSOLE-HARDWARE-OR-REPEAT-CHAR-AVAILABLE SELF IN-PTR)))
		       DO
		   (LET ((HARD-CHAR (CONSOLE-GET-HARDWARE-CHAR SELF)))
		     (IF HARD-CHAR
			 (SETF (CLI::KEYBOARD-LAST-CHAR-WAS-REPEATED-P KEYBOARD) NIL)
			 (SETQ HARD-CHAR (CLI::KEYBOARD-REPEAT-HARDWARE-CHAR KEYBOARD)))
		     (IF RAW-P
			 (UNLESS (IO-BUFFER-FULL-P SELECTED-BUFFER)
			   (IO-BUFFER-PUT SELECTED-BUFFER HARD-CHAR))
			 (LET ((SOFT-CHAR (CONSOLE-CONVERT-TO-SOFTWARE-CHAR
					    SELF HARD-CHAR
					    (IF (CLI::KEYBOARD-USE-MODE-LOCK-TABLE-P KEYBOARD)
						BUFFER-MODE-LOCK-TABLE BUFFER-TABLE))))
			   (BLOCK PROCESSED
			     (WHEN (NULL SOFT-CHAR)
			       (RETURN-FROM PROCESSED))
			     (LET ((SPECIAL (ASSOC SOFT-CHAR
						   *KEYBOARD-PROCESS-ESC-CHARACTERS*)))
			       (WHEN SPECIAL
				 (SETF (CLI::CONSOLE-ESC-FUNCTION SELF) (CDR SPECIAL))
				 (RETURN-FROM PROCESSED)))
			     (LET ((WINDOW (CONSOLE-SELECTED-WINDOW SELF)))
			       (WHEN (AND WINDOW
					  (SEND-IF-HANDLES WINDOW :ASYNCHRONOUS-CHARACTER-P
								  SOFT-CHAR))
				 ;; This character is asynchronous for the currently
				 ;; selected window. Let it do what it want with it now.
				 (SEND WINDOW :HANDLE-ASYNCHRONOUS-CHARACTER SOFT-CHAR)
				 (RETURN-FROM PROCESSED)))
			     (UNLESS (IO-BUFFER-FULL-P SYSTEM-BUFFER)
			       (CL:ETYPECASE SOFT-CHAR
				 (CL:CHARACTER (IO-BUFFER-PUT SYSTEM-BUFFER SOFT-CHAR))
				 (CL:LIST
				   (DOLIST (CHAR SOFT-CHAR)
				     (IO-BUFFER-PUT SYSTEM-BUFFER CHAR)
				     (WHEN (IO-BUFFER-FULL-P SYSTEM-BUFFER)
				       (RETURN))))
				 (CL:VECTOR
				   (LOOP FOR CHAR BEING THE ARRAY-ELEMENTS OF SOFT-CHAR
					 DO (IO-BUFFER-PUT SYSTEM-BUFFER CHAR)
					 UNTIL (IO-BUFFER-FULL-P SYSTEM-BUFFER))))
			       (CL:SETF (CONSOLE-LAST-ACTIVITY-TIME SELF) (TIME)
					SI:WHO-LINE-JUST-COLD-BOOTED-P NIL))))))
		   ;; If we're in the cold load stream, give it control again after reading
		   ;; one char.
		   (WHEN COLD-LOAD-STREAM-SELECTED
		     (RETURN)))
		 NIL))
	  ;; Keep the mouse buttons buffer up to date on the state of the keyboard
	  (UNLESS COLD-LOAD-STREAM-SELECTED
	    (LOOP WITH INDEX = CLI::MOUSE-BUTTONS-BUFFER-KEYBOARD-INDEX
		  UNTIL (= (MOUSE-BUTTONS-BUFFER-IN-INDEX MOUSE) INDEX) DO
	      ;; Bring keyboard state up to date with the moment the mouse button was clicked
	      (PROCESS-INPUT-UNTIL (SI:MOUSE-TIME-KBD-IN-POINTER
				     (AREF (MOUSE-BUTTONS-BUFFER MOUSE) INDEX)))
	      ;; Save the keyboard buttons and shifts into the mouse buttons buffer
	      (LET ((BUTTONS (AREF (MOUSE-BUTTONS-BUFFER MOUSE) (+ INDEX 3))))
		(WHEN (= BUTTONS 1) ;If the button is down, maybe shift it from keys.
		  (SETQ BUTTONS (CLI::KEYBOARD-INCLUDE-MOUSE-BUTTON-SHIFT-KEYS KEYBOARD
									       BUTTONS)))
		(SETF (AREF (MOUSE-BUTTONS-BUFFER MOUSE) (+ INDEX 3))
		      (%LOGDPB (KEYBOARD-SHIFTS KEYBOARD) (BYTE 16. 16.) BUTTONS)))
	      (SETQ CLI::MOUSE-BUTTONS-BUFFER-KEYBOARD-INDEX
		    (SETQ INDEX (%FIXNUM-MOD (+ INDEX 4) 32.)))))
	  ;; Handle the keyboard input
	  (UNLESS CLI::INPUT-LOCK
	    (PROCESS-INPUT-UNTIL NIL)))))))

;; This function is suitable for calling from a user process since it uses WITHOUT-INTERRUPTS
;; between calling KBD-GET-IO-BUFFER and examining KBD-IO-BUFFER.  It can also be called
;; within a loop which is within a WITHOUT-INTERRUPTS since it checks
;; KBD-HARDWARE-CHAR-AVAILABLE itself, instead of relying on the keyboard process to do it.
(DEFMETHOD (CONSOLE-IO-BUFFER-LISTEN CLI::CONSOLE) (BUFFER)
  (OR (NOT (IO-BUFFER-EMPTY-P BUFFER))
      (WITHOUT-INTERRUPTS
	(WHEN (AND (EQ BUFFER (CONSOLE-GET-SELECTED-IO-BUFFER SELF))
		   (NOT COLD-LOAD-STREAM-SELECTED))
	  (WHEN (CONSOLE-HARDWARE-OR-REPEAT-CHAR-AVAILABLE SELF)
	    (CONSOLE-PROCESS-INPUT SELF))
	  (NOT (IO-BUFFER-EMPTY-P (CONSOLE-SYSTEM-IO-BUFFER SELF)))))))

;; This is the function to call when waiting for input from the keyboard.  It is different
;; from KBD-IO-BUFFER-LISTEN in that it doesn't use WITHOUT-INTERRUPTS, since wait functions
;; are run uninterruptibly, and it doesn't check KBD-HARDWARE-CHAR-AVAILABLE, since the
;; keyboard process takes care of that.  Should this be checking COLD-LOAD-STREAM-SELECTED
;; earlier in the wait predicate?
(DEFMETHOD (CONSOLE-IO-BUFFER-INPUT-WAIT CLI::CONSOLE)
	   (BUFFER &OPTIONAL WHOSTATE FUNCTION &REST ARGUMENTS)
  ;; Update variables the who-line uses, presuming that anybody who :INPUT-WAITSs
  ;; a stream is planning on reading from it.
  (UNLESS (EQ (IO-BUFFER-LAST-OUTPUT-PROCESS BUFFER) CURRENT-PROCESS)
    (SETF (IO-BUFFER-LAST-OUTPUT-PROCESS BUFFER) CURRENT-PROCESS)
    (WHEN (EQ BUFFER (CONSOLE-SELECTED-IO-BUFFER SELF))
      (WHO-LINE-RUN-STATE-UPDATE)))
  (flet ((wait-predicate (console buffer function &rest arguments)
	   (OR (NOT (IO-BUFFER-EMPTY-P BUFFER))
	       (AND FUNCTION (NOT (NULL (APPLY FUNCTION ARGUMENTS))))
	       (AND (EQ BUFFER (CONSOLE-GET-SELECTED-IO-BUFFER CONSOLE))
		    (NOT COLD-LOAD-STREAM-SELECTED)
		    (NOT (IO-BUFFER-EMPTY-P
			   (CONSOLE-SYSTEM-IO-BUFFER CONSOLE)))))))
    ;; The crock here with process:verify-function is because there's no way to communicate
    ;; down through all the levels that you're willing to block rather than wait.  After
    ;; things work, I'll clean up the protocol for passing such information through.
    (if (and (or (null function) (eql function 'process::verify-function))
	     (neq buffer (CONSOLE-SYSTEM-IO-BUFFER SELF)))
	(CL:APPLY #'PROCESS:PROCESS-BLOCK
		  (OR WHOSTATE SI:*WHOSTATE-AWAITING-USER-INPUT*)
		  #'wait-predicate
		  SELF BUFFER (FIRST ARGUMENTS) (CDR ARGUMENTS))
	(CL:APPLY #'PROCESS:PROCESS-BLOCK-AND-POLL-WAIT-FUNCTION
		  (OR WHOSTATE SI:*WHOSTATE-AWAITING-USER-INPUT*)
		  ;; assume that all the more common events will generate wakeups, so poll
		  ;; infrequently, less than twice a second.
		  0.75
		  #'wait-predicate
		  SELF BUFFER FUNCTION ARGUMENTS))))

;; If you know that the function passed in will get wakeups on change of state, then 
;; we don't have to poll at all.
(DEFMETHOD (CONSOLE-IO-BUFFER-INPUT-BLOCK CLI::CONSOLE)
	   (BUFFER &OPTIONAL WHOSTATE FUNCTION &REST ARGUMENTS)
  ;; Update variables the who-line uses, presuming that anybody who :INPUT-WAITSs
  ;; a stream is planning on reading from it.
  (UNLESS (EQ (IO-BUFFER-LAST-OUTPUT-PROCESS BUFFER) CURRENT-PROCESS)
    (SETF (IO-BUFFER-LAST-OUTPUT-PROCESS BUFFER) CURRENT-PROCESS)
    (WHEN (EQ BUFFER (CONSOLE-SELECTED-IO-BUFFER SELF))
      (WHO-LINE-RUN-STATE-UPDATE)))
  ;;(PROCESS::WITH-EVENTS (*WAKEUP-ON-SELECT*)
  (LEXPR-FUNCALL #'PROCESS:PROCESS-BLOCK
		 (OR WHOSTATE SI:*WHOSTATE-AWAITING-USER-INPUT*)
		 #'(LAMBDA (CONSOLE BUFFER FUNCTION &REST ARGUMENTS)
		     (OR (AND FUNCTION (NOT (NULL (APPLY FUNCTION ARGUMENTS))))
			 (NOT (IO-BUFFER-EMPTY-P BUFFER))
			 (AND (EQ BUFFER (CONSOLE-GET-SELECTED-IO-BUFFER CONSOLE))
			      (NOT COLD-LOAD-STREAM-SELECTED)
			      (NOT (IO-BUFFER-EMPTY-P
				     (CONSOLE-SYSTEM-IO-BUFFER CONSOLE))))))
		 SELF BUFFER FUNCTION ARGUMENTS);)
  )

(DEFMETHOD (CONSOLE-IO-BUFFER-GET CLI::CONSOLE) (BUFFER &OPTIONAL (NO-HANG-P NIL) WHOSTATE)
  (DO ((INHIBIT-SCHEDULING-FLAG T T)
       (UPDATE-STATE-P (NEQ CURRENT-PROCESS (IO-BUFFER-LAST-OUTPUT-PROCESS BUFFER)))
       (OK)
       (ELT))
      (())
    (MULTIPLE-VALUE (ELT OK)
      (IO-BUFFER-GET BUFFER T))
    ;; If new process reading, better update wholine run state
    (AND UPDATE-STATE-P (EQ BUFFER (CONSOLE-SELECTED-IO-BUFFER SELF))
	 (WHO-LINE-RUN-STATE-UPDATE))
    ;; Got something from the normal buffer, just return it
    (AND OK (RETURN (VALUES ELT T)))
    ;; OK is NIL here.  If we aren't selected, don't look at system's io buffer
    (AND (EQ BUFFER (CONSOLE-SELECTED-IO-BUFFER SELF))
	 (MULTIPLE-VALUE (ELT OK)
	   (IO-BUFFER-GET (CONSOLE-SYSTEM-IO-BUFFER SELF) T)))
    (COND (OK
	   ;; Got something from the kbd buffer, put it into the normal buffer and loop
	   (IO-BUFFER-PUT BUFFER ELT T))	;Can't hang, but...
	  ;; Nothing for baby!!!  What should we do?
	  (T
	   (WHEN (AND COLD-LOAD-STREAM-SELECTED
		      (EQ DBG:SAVED-SCREEN-PROCESS CURRENT-PROCESS))
	     (FERROR "Attempt to read from keyboard while in cold load stream."))
	   (AND (NOT (IO-BUFFER-FULL-P (CONSOLE-SYSTEM-IO-BUFFER SELF)))
		(CONSOLE-HARDWARE-OR-REPEAT-CHAR-AVAILABLE SELF)
		;; If there is a possibility that a character of interest exists in
		;; the hardware, get it
		(CONSOLE-PROCESS-INPUT SELF))
	   (IF (OR (NOT (IO-BUFFER-EMPTY-P BUFFER))
		   (AND (EQ BUFFER (CONSOLE-GET-SELECTED-IO-BUFFER SELF))
			(NOT (IO-BUFFER-EMPTY-P (CONSOLE-SYSTEM-IO-BUFFER SELF)))))
	       NIL				;Have a character, so loop and get it
	       (AND NO-HANG-P (RETURN (VALUES NIL NIL)))
	       (SETQ INHIBIT-SCHEDULING-FLAG NIL)
	       (CONSOLE-IO-BUFFER-INPUT-WAIT SELF BUFFER WHOSTATE))))))

(DEFMETHOD (CONSOLE-MOVE-TYPEAHEAD CLI::CONSOLE) (BUFFER &OPTIONAL (HARDWARE-CHARS-P T))
  (WITHOUT-INTERRUPTS
    (COND ((NULL BUFFER))			;This can happen due to timing error
	  ((EQ BUFFER (CONSOLE-GET-SELECTED-IO-BUFFER SELF))
	   ;; There is potentially input for us
	   (WHEN HARDWARE-CHARS-P
	     (CONSOLE-PROCESS-INPUT SELF))
	   (LET ((SYSBUF (CONSOLE-SYSTEM-IO-BUFFER SELF)))
	     (LOOP UNTIL (IO-BUFFER-EMPTY-P SYSBUF)
		   DO (MULTIPLE-VALUE-BIND (ELT OK)
			  (IO-BUFFER-GET SYSBUF T)
			(UNLESS OK (RETURN NIL))	;Some ignored characters, we are done
			(WHEN ELT (IO-BUFFER-PUT BUFFER ELT T)))))))))

(DEFVAR-RESETTABLE KBD-TYI-HOOK NIL)  ;This is a crock, but I suppose someone might want to...

(DEFUN KBD-DEFAULT-OUTPUT-FUNCTION (IGNORE CHAR)
  "System standard IO-BUFFER output function.
Intercepts those characters in KBD-INTERCEPTED-CHARACTERS.
Must be called with INHIBIT-SCHEDULING-FLAG bound to T, and this may SETQ it to NIL."
  (DECLARE (VALUES ELEMENT IGNORE-P))
  (IF (AND KBD-TYI-HOOK (FUNCALL KBD-TYI-HOOK CHAR))
      (VALUES CHAR T)
      ;; Note, this must not use =, since the character may not be a number
      (COND ((CL:MEMBER CHAR KBD-INTERCEPTED-CHARACTERS)
	     (KBD-INTERCEPT-CHARACTER CHAR)
	     (VALUES CHAR T))		;If returns, ignore the char and retry
	    (T CHAR))))

;;; This function knows what to do in response to each of the standard intercepted
;;; characters.  It is called by other functions besides KBD-DEFAULT-OUTPUT-FUNCTION
;;; The STREAM argument is for ZWEI, where to output the message.
(DEFUN KBD-INTERCEPT-CHARACTER (CHAR &OPTIONAL (STREAM TERMINAL-IO))
  (DECLARE (DBG:ERROR-REPORTER))
  (SETQ INHIBIT-SCHEDULING-FLAG NIL)		;It was T in the IO-BUFFER-OUTPUT-FUNCTION
  (SELECTQ CHAR
    ((#\ABORT)
     (SI:PROCESS-ABORT CURRENT-PROCESS :MESSAGE "[Abort]" :STREAM STREAM))
    ((#\m-ABORT)
     (SI:PROCESS-ABORT CURRENT-PROCESS :ALL T :MESSAGE "[Abort all]" :STREAM STREAM))
    (#\BREAK (BREAK BREAK))
    (#\m-BREAK (DBG:ENTER-DEBUGGER (MAKE-CONDITION 'DBG:ASYNCHRONOUS-BREAK))
     NIL)	;This NIL is here for a reason!
    (OTHERWISE (FERROR "~:@C is not a standard intercepted character" CHAR))))

;Print the message if it's convenient.  But don't hang up in an output hold
;that would make it impossible to abort.  This is a kludge, of course.
(DEFUN KBD-UNIMPORTANT-MESSAGE (STRING STREAM)
  (COND ((EQ STREAM DEFAULT-BACKGROUND-STREAM))
	((AND (TYPEP STREAM 'SHEET)
	      (OR (SHEET-OUTPUT-HELD-P STREAM)
		  ;; Must be able to get lock as if another entity.  Current process might
		  ;; be in the middle of some output operation that doesn't care for more.
		  (NOT (SHEET-CAN-GET-LOCK STREAM (LOCF STREAM))))))
	(T (FLET ((PRINT-IT (STREAM)
		    (DECLARE (DOWNWARD-FUNCTION))
		    (SEND-IF-HANDLES STREAM :PREPARE-FOR-MORE-TYPEOUT)
		    (SEND STREAM :CLEAR-REST-OF-LINE)
		    (SEND STREAM :STRING-OUT STRING)
		    T))
	     (OR (SEND-IF-HANDLES STREAM :WITH-OUTPUT-RECORDING-ENABLED #'PRINT-IT STREAM T)
		 (PRINT-IT STREAM))))))

;;; This function is called, possibly in the keyboard process, when one of the
;;; standard asynchronous intercepted characters, of the sort that mungs over the
;;; process, is typed.  Scheduling is inhibited.
;;; This does the actual munging of the process in a separate process, in case
;;; it has to wait for the process' stack-group to get out of some weird state.
(DEFUN KBD-ASYNCHRONOUS-INTERCEPT-CHARACTER (CHAR &OPTIONAL (STREAM SELECTED-WINDOW))
  (WHEN STREAM
    ;; Forget chars typed before "CTRL-abort", even those inside window's iob
    (SEND STREAM :CLEAR-INPUT)
    (LET* ((PROCESS (SEND-IF-HANDLES STREAM :PROCESS))
	   (DEFAULT-SCREEN (CONSOLE-DEFAULT-SUPERIOR STREAM))
	   (*CONSOLE* (AND DEFAULT-SCREEN (SHEET-CONSOLE DEFAULT-SCREEN))))
      (WHEN PROCESS
	(SELECTOR CHAR CHAR=
	  ((#\c-ABORT #\c-m-ABORT)
	   (LET ((ALL-P (CHAR-BIT CHAR :META)))
	     (PROCESS-RUN-FUNCTION '(:NAME "Abort" :PRIORITY 50.)
	       #'(LAMBDA (PROCESS ALL-P *CONSOLE* DEFAULT-SCREEN)
		   (WITHOUT-INTERRUPTS
		     (WAIT-UNTIL-PROCESS-DISTURBABLE PROCESS *PROCESS-DISTURBABLE-TIMEOUT*)
		     (PROCESS-ABORT PROCESS
				    :MESSAGE (IF ALL-P "[Abort all]" "[Abort]")
				    :ALL ALL-P
				    :QUERY :POP-UP)))
	       PROCESS ALL-P *CONSOLE* DEFAULT-SCREEN)))
	  (#\c-BREAK
	   (PROCESS-RUN-FUNCTION '(:NAME "Break" :PRIORITY 40.)
	     #'(LAMBDA (PROCESS)
		 (WITHOUT-INTERRUPTS
		   (WAIT-UNTIL-PROCESS-DISTURBABLE PROCESS *PROCESS-DISTURBABLE-TIMEOUT*)
		   (PROCESS-INTERRUPT PROCESS #'SI:BREAK-INTERNAL 'BREAK)))
	     PROCESS))
	  (#\c-m-BREAK
	   (PROCESS-RUN-FUNCTION '(:NAME "Break" :PRIORITY 40.)
	     #'(LAMBDA (PROCESS)
		 (WITHOUT-INTERRUPTS
		   (WAIT-UNTIL-PROCESS-DISTURBABLE PROCESS *PROCESS-DISTURBABLE-TIMEOUT*)
		   (PROCESS::PROCESS-ASYNCHRONOUS-BREAK PROCESS)))
	     PROCESS))))))
  NIL)

;;; False if process does not own any window-system locks
;;; Otherwise returns a sheet or a lock
;;; This function is not fast (one or two milliseconds typical)
;;; Looks for sheet locks first since these are locked outside of screen controller locks
;;;--- Should this worry about non-window-related locks as well?
(DEFUN PROCESS-UNDISTURBABLE-P (PROCESS)
  (DOLIST (SCREEN ALL-THE-SCREENS)
    (LABELS ((TRAVERSE (SHEET)
	       (WHEN (EQ (SHEET-LOCK SHEET) PROCESS)
		 (RETURN-FROM PROCESS-UNDISTURBABLE-P SHEET))
	       (UNLESS (ZEROP (SHEET-INFERIOR-LOCK-COUNT SHEET))
		 (MAPC #'TRAVERSE (SHEET-INFERIORS SHEET)))))
      (TRAVERSE SCREEN))
    (LET* ((SCREEN-LOCK (SCREEN-LOCK SCREEN))
	   (SCREEN-LOCKER
	     (UNLESS (PROCESS:LOCK-IDLE-P SCREEN-LOCK)
	       (IGNORE-ERRORS (FOURTH (PROCESS::DECODE-LOCK-FOR-DEBUGGER SCREEN-LOCK))))))
      (WHEN (EQ SCREEN-LOCKER PROCESS)
	(RETURN-FROM PROCESS-UNDISTURBABLE-P SCREEN-LOCK))))
  NIL)

(DEFVAR *PROCESS-DISTURBABLE-TIMEOUT* (* 5 60.))	;5 seconds

;;; Should be called inside without-interrupts
;;; Returns true if process was disturbable when last checked, NIL if timed out
;;; TIMEOUT is in 60ths
(DEFUN WAIT-UNTIL-PROCESS-DISTURBABLE (PROCESS TIMEOUT)
  (LOOP WITH START-TIME = (TIME)
	AS LOCK = (PROCESS-UNDISTURBABLE-P PROCESS)
	DO (UNLESS LOCK (RETURN T))
	   ;; Wait for the lock to unlock, with directed wakeup so we have a chance
	   ;; of catching the process when it's disturbable
	   (CL:ETYPECASE LOCK
	     (SHEET
	       (WAIT-FOR-SHEET-LOCK LOCK T TIMEOUT))
	     (PROCESS::BASIC-LOCK
	       (PROCESS:WITH-TIMEOUT ((// TIMEOUT 60s0))
		 (PROCESS:WITH-LOCK (LOCK)))))
	   (DECF TIMEOUT (TIME-DIFFERENCE (TIME) START-TIME))
	   (UNLESS (PLUSP TIMEOUT) (RETURN NIL))))

(DEFMETHOD (CONSOLE-GET-SOFTWARE-CHAR CLI::CONSOLE) (&OPTIONAL (WHOSTATE "Keyboard"))
  "Returns the next char from the hardware converted to software codes.  This
is meant to be used only by things that run in the keyboard process, and not by
any user code."
  (DO ((CH)) (NIL)
    (PROCESS-WAIT WHOSTATE #'CONSOLE-HARDWARE-CHAR-AVAILABLE SELF)
    (AND (SETQ CH (CONSOLE-CONVERT-TO-SOFTWARE-CHAR SELF
						    (CONSOLE-GET-HARDWARE-CHAR SELF)))
	 (NOT (EQL CH #\HYPER-CONTROL-FUNCTION))
	 (RETURN CH))))

;; Kludge to return T when a character has been typed.  First checks the selected window's
;; IO buffer, and if it is empty then checks the microcode's buffer.  This is useful for
;; programs which want to stop when a character is typed, but don't want to allow
;; interrupts and scheduling.
(DEFMETHOD (CONSOLE-CHAR-TYPED-P CLI::CONSOLE) ()
  (LET ((BUFFER (CONSOLE-GET-SELECTED-IO-BUFFER SELF)))
    (OR (AND BUFFER (NOT (IO-BUFFER-EMPTY-P BUFFER)))
	(CONSOLE-HARDWARE-CHAR-AVAILABLE SELF))))

(DEFMETHOD (CONSOLE-CLEAR-IO-BUFFER CLI::CONSOLE) ()
  "Clear the keyboard buffer and the hardware buffer"
  (WITHOUT-INTERRUPTS
    (IO-BUFFER-CLEAR (CONSOLE-SYSTEM-IO-BUFFER SELF))
    (LOOP WHILE (CONSOLE-HARDWARE-CHAR-AVAILABLE SELF)
	  AS CHAR = (CONSOLE-GET-HARDWARE-CHAR SELF)
	  WHILE CHAR
	  ;; Call this to process shifts
	  DO (CONSOLE-CONVERT-TO-SOFTWARE-CHAR SELF CHAR))))

(DEFMETHOD (CONSOLE-CLEAR-SELECTED-IO-BUFFER CLI::CONSOLE) ()
  (SETF (CONSOLE-SELECTED-IO-BUFFER SELF) NIL))

(DEFMETHOD (CONSOLE-GET-SELECTED-IO-BUFFER CLI::CONSOLE) (&OPTIONAL WHOLINE)
  "Returns the current IO buffer.  If there is no current buffer, the selected window
is interrogated.  If there is no selected window, or the window has no buffer, returns NIL."
  (LET ((SW (CONSOLE-SELECTED-WINDOW SELF)))
    (COND ((NULL SW)
	   ;; This shouldn't be necessary, but try not to lose too big
	   (CONSOLE-CLEAR-SELECTED-IO-BUFFER SELF)
	   NIL)
	  ((CONSOLE-SELECTED-IO-BUFFER SELF))
	  (T
	   (LET ((BUFFER (SEND SW :IO-BUFFER)))
	     (SETF (CONSOLE-SELECTED-IO-BUFFER SELF) BUFFER)
	     (UNLESS WHOLINE
	       (WHO-LINE-RUN-STATE-UPDATE))	;May have just switched processes
	     BUFFER)))))

;;;; Mode-lock multiplexing

(DEFVAR *MODE-LOCK-STATES* ())

(DEFPROP DEFINE-MODE-LOCK-STATE "Mode lock state" SI:DEFINITION-TYPE-NAME)

(DEFMACRO DEFINE-MODE-LOCK-STATE (STATE &OPTIONAL DESCRIPTION)
  `(DEFINE-MODE-LOCK-STATE-INTERNAL ',STATE ',DESCRIPTION))

(DEFUN DEFINE-MODE-LOCK-STATE-INTERNAL (STATE DESCRIPTION)
  (WHEN (RECORD-SOURCE-FILE-NAME STATE 'DEFINE-MODE-LOCK-STATE)
    (SCL:PUSHNEW (LIST STATE DESCRIPTION) *MODE-LOCK-STATES* :KEY #'FIRST :REPLACE T)))

(DEFINE-MODE-LOCK-STATE :KEYBOARD "Enables alternative keyboard mapping table")

(DEFUN MODE-LOCK-STATE (STATE &OPTIONAL (CONSOLE *CONSOLE*))
  (AND (EQ STATE (CLI::KEYBOARD-MODE-LOCK-CONTROLLER (CONSOLE-KEYBOARD CONSOLE)))
       (CONSOLE-KEY-STATE CONSOLE :MODE-LOCK)))

(DEFUN SET-MODE-LOCK-STATE-CONTROLLER (STATE &OPTIONAL (CONSOLE *CONSOLE*))
  (SETF (CLI::KEYBOARD-MODE-LOCK-CONTROLLER (CONSOLE-KEYBOARD CONSOLE)) STATE))

;; The key labelled "Escape", "Terminal", or "Function", depending upon which
;; keyboard you have.

; A list of elements (char function documentation . options).
; Typing [Function] char activates this element.  If function is a list it is
; evaluated, otherwise it is a function to be applied to one argument, which
; is NIL or the numeric-arg typed by the user.  In either case it happens
; in a separate process.  documentation is a form to evaluate to get the
; documentation, a string or NIL to leave this key undocumented.
; Documentation can be a list of strings to go on separate lines.
; The following options in the CDDDR of the list are:
;    :TYPEAHEAD - copy the contents of the
;	software buffer into the currently selected IO-BUFFER.  This has the
;	effect of treating everything typed before the ESC as typeahead to
;	the currently selected window.  Useful for ESC commands that
;	change the selected window.  These commands should set KBD-ESC-TIME to NIL
;       as soon as they change the selected window, unless they complete quickly
;       (input should never be done with KBD-ESC-TIME non-NIL).
;    :KEYBOARD-PROCESS - run the function in the keyboard process instead of starting
;	a new process for it.
;    :PROCESS-NAME string - name the process that instead of "Function Key"
;    :PROCESS list - options for PROCESS-RUN-FUNCTION, such as :NAME and :PRIORITY

; Unknown or misspelled keywords are ignored.
; If you want to patch this, see ALTER-FUNCTION-KEYS.
(DEFVAR *FUNCTION-KEYS*
     '( (#\CLEAR-INPUT  KBD-ESC-CLEAR "Discard type-ahead." :KEYBOARD-PROCESS)
	(#\REFRESH (KBD-SCREEN-REDISPLAY) "Clear and redisplay all windows.")
	(#\END KBD-INSERT-EOF
	       "Insert an EOF indicator into the currently selected I//O buffer.")
	(#/A KBD-ESC-ARREST
	     "Arrest process in the status line (minus means unarrest)." :KEYBOARD-PROCESS)
	(#/B KBD-BURY
	     '("Bury or deactivate a window."
	       "  0 or no arg buries the selected window"
	       "  1 deactivates the selected window (confirm)"
	       "  2 buries the mouse window"
	       "  3 deactivates the mouse window (confirm)"
	       "  4 buries the top level window on the screen"
	       "  5 deactivates the top level window on the screen (confirm)")
	     :TYPEAHEAD
	     :PROCESS (:NAME "Function B" :PRIORITY 1))
	(#/C KBD-COMPLEMENT
	     (KBD-COMPLEMENT-PROMPT)
	     :KEYBOARD-PROCESS)
	(#/c-C KBD-LOCAL-COMPLEMENT
	       "Toggle black-on-white state of the selected window.  Args like C."
	       :KEYBOARD-PROCESS)
	(#/m-C KBD-DOC-LINE-COMPLEMENT
	       "Toggle black-on-white state of the mouse documentation line.  Args like C."
	       :KEYBOARD-PROCESS)
	(#/E KBD-ESC-END-OF-PAGE
	 '("Set global default end-of-page mode. With no arg, prompt with a menu."
	   "With an argument: 1=Scroll, 2=Truncate, 3=Wrap")
	 :PROCESS (:NAME "Function E" :PRIORITY 10.))
	(#/c-E KBD-ESC-END-OF-PAGE-LOCAL
	 '("Set end-of-page mode for the selected window. With no arg, prompt with a menu."
	   "With an argument: 0=Default, 1=Scroll, 2=Truncate, 3=Wrap")
	 :PROCESS (:NAME "Function c-E" :PRIORITY 10.))
	(#/M KBD-ESC-MORE
	 "Toggle global **MORE** processing.  An argument of 1 turns it on; 0 turns it off."
	 :KEYBOARD-PROCESS)
        (#/c-M KBD-ESC-LOCAL-MORE 
   "Toggle **MORE** for the selected window.  An argument of 1 turns it on; 0 turns it off."
	 :KEYBOARD-PROCESS)
	(#/O KBD-OTHER-EXPOSED-WINDOW "Select another exposed window." :TYPEAHEAD
	     :PROCESS (:NAME #,(FORMAT NIL "~:C-O" #\FUNCTION) :PRIORITY 1))
	(#/S KBD-SWITCH-WINDOWS
	 '("Select the most recently selected window.  With an argument, select the nth"
	   "  previously selected window and rotate the top n windows.  (Default arg is 2)."
	   "  With an arg of 1, rotate through all the windows.  With a negative arg, rotate"
	   "  in the other direction.  With an argument of 0, select a window that requires"
	   "  attention, e.g. to report an error.")
	   :TYPEAHEAD :PROCESS (:NAME #,(FORMAT NIL "~:C-S" #\FUNCTION) :PRIORITY 1))
	(#/T KBD-ESC-T
	 '("Control the selected window's notification properties."
	   "  Toggle output notification, making input notification the same as output."
	   "  0 Input and output notification off    3 Input on, output off"
	   "  1 Input and output notification on     4 Input on, output proceeds deexposed"
	   "  2 Input off, output on                 5 Input off, output proceeds deexposed"
	   "  (You can also use the Attribute command in the Screen Editor.)")
	 :KEYBOARD-PROCESS)
	(#/W KBD-ESC-W
	 '("Switch which process the status line reports.  Default is just to refresh it."
	   "  0 gives a menu of all processes,"
	   "  1 means selected-window's process,     3 means rotate among all processes,"
	   "  2 means freeze on this process,        4 means rotate other direction.")
	 :PROCESS (:NAME #,(FORMAT NIL "~:C-W" #\FUNCTION) :PRIORITY 10.))
	(NIL) ;Ones after here are "for wizards"
	(#\ESCAPE KBD-ESC-OUTPUT-HOLD
	 "Assist with window problems such as /"Output Hold/" or /"Sheet Lock/"")
	(#\c-A KBD-ESC-ARREST-ALL
	       "Arrest all processes except the status line one (minus unarrests them)"
	       :KEYBOARD-PROCESS)
	(#\SUSPEND (KBD-USE-COLD-LOAD-STREAM) "Get to cold-load stream    (use with caution)"
	        :TYPEAHEAD :PROCESS (:NAME "Function Suspend" :PRIORITY 100.))
	(#\c-T KBD-CLEAR-TEMPORARY-WINDOWS "Flush temporary windows    (use with caution)")
	(#\c-CLEAR KBD-CLEAR-LOCKS "Clear window-system locks  (use with caution)")))

(DEFCONST FIREWALL:*FUNCTION-KEYS-ENABLED* T)

(DEFUN FUNCTION-KEY-ENABLED-P (CH)
  (CONSOLE-FUNCTION-KEY-ENABLED-P *CONSOLE* CH))

(COMPILER:MAKE-OBSOLETE
  FUNCTION-KEY-ENABLED-P "use SYS:CONSOLE-FUNCTION-KEY-ENABLED-P instead")

;; Use this instead of patching the DEFVAR for *FUNCTION-KEYS*.
;; It doesn't wipe out any user additions.
(DEFUN ALTER-FUNCTION-KEYS (LIST)
  (LET ((NEW-LIST (COPYLIST *FUNCTION-KEYS*)))
    (DOLIST (NEW-ITEM LIST)
      (SETQ NEW-LIST (CL:NSUBSTITUTE-IF NEW-ITEM
					#'(LAMBDA (OLD-ITEM)
					    (AND (CAR OLD-ITEM)
						 (CAR NEW-ITEM)
						 (CHAR-EQUAL (CAR OLD-ITEM) (CAR NEW-ITEM))))
					NEW-LIST)))
    (SETQ *FUNCTION-KEYS* NEW-LIST)))

;;; This is the official function for adding new Function-X commands.
(DEFUN ADD-FUNCTION-KEY (CHAR FUNCTION DOCUMENTATION &REST OPTIONS)
  (CHECK-ARG-TYPE CHAR :CHARACTER)
  (CHECK-ARG DOCUMENTATION
	     (OR (SI:SOME-STRING DOCUMENTATION) (LISTP DOCUMENTATION) (NULL DOCUMENTATION))
	     "a string, a form to be evaluated, or NIL")
  ;; KBD-ESC ignores case and style, but not bits
  (SETQ CHAR (CHAR-UPCASE (MAKE-CHARACTER CHAR :BITS (CHAR-BITS CHAR))))
  (SETQ *FUNCTION-KEYS* (CL:DELETE CHAR *FUNCTION-KEYS* :KEY #'CAR
				   :TEST (LAMBDA (X Y) (AND X Y (CHAR-EQUAL X Y)))))
  (PUSH (LIST* CHAR FUNCTION DOCUMENTATION (COPYLIST OPTIONS)) *FUNCTION-KEYS*)
  (SORT-FUNCTION-KEY-LIST)
  T)

;;; Sort predicate for function key sorter.  This reverts to CHAR-LESSP,
;;; unless CHAR1 and CHAR2 are same character aside from modifier bits
;;; (i.e. we want "a" to be less than "meta-a")
(DEFUN FUNCTION-KEY-SORT-PREDICATE (CHAR1 CHAR2)
  (IF (OR (NULL CHAR1) (NULL CHAR2))		;NIL isn't a character
      CHAR1					;return something useful (NIL or non-NIL)
    (LET* ((BITS1 (CHAR-BITS CHAR1))
	   (BITS2 (CHAR-BITS CHAR2))
	   (CHAR1 (MAKE-CHAR CHAR1))		;we will compare characters without bits
	   (CHAR2 (MAKE-CHAR CHAR2)))
      (IF (CHAR-EQUAL CHAR1 CHAR2)
	  (LESSP BITS1 BITS2)			;same code, maybe different modifiers
	(CHAR-LESSP CHAR1 CHAR2)))))

;;; Sort those elements in *FUNCTION-KEYS* that are just letters, to make the
;;; Function Help message easier to use.  It assumes that the list is in the
;;; order: new alphas, pre-alphas, real-alphas, post-alphas.  This strategy
;;; is designed to be robust and backward-compatible; if somebody does add
;;; a command by manually pushing, the next real add-function-key will fix it up.
;;; We need to do MAKE-CHAR on the characters to throw away their CHAR-BITS before
;;; doing any further comparisons.
(DEFUN SORT-FUNCTION-KEY-LIST ()
  (LET* ((INIT-ALPHA (COPYLIST *FUNCTION-KEYS*))
	 START BODY END)
    (SETQ START INIT-ALPHA)
    (LET ((PRE-START NIL))
      (LOOP WHILE (AND START (ALPHANUMERICP (MAKE-CHAR (CAAR START)))) DO
	    (SETQ PRE-START START)
	    (POP START))
      (IF PRE-START
	  (RPLACD PRE-START NIL)
	  (SETQ INIT-ALPHA NIL)))
    (SETQ BODY START)
    (LET ((LAST NIL))
      (LOOP UNTIL (OR (NULL BODY) (ALPHANUMERICP (MAKE-CHAR (CAAR BODY)))) DO
	    (SETQ LAST BODY)
	    (POP BODY))
      (IF LAST
	  (RPLACD LAST NIL)
	  (SETQ START NIL)))
    (SETQ END BODY)
    (LET ((PRE-END NIL))
      (LOOP WHILE (AND END (CAAR END) (ALPHANUMERICP (MAKE-CHAR (CAAR END)))) DO
	    (SETQ PRE-END END)
	    (POP END))
      (IF PRE-END
	  (RPLACD PRE-END NIL)
	  (SETQ BODY NIL)))
    (SETQ *FUNCTION-KEYS*
	  (NCONC START				; pre-alphas, then sorted alphas next
		 (SORTCAR (NCONC INIT-ALPHA BODY) #'FUNCTION-KEY-SORT-PREDICATE)
		 END))))			; lastly, post-alphas

;;; Suitable for use with CONSOLE-GET-SOFTWARE-CHAR.
(DEFMACRO WITH-WHO-LINE-FORCE-PROCESS (ARGS &BODY BODY)
  (DECLARE (ARGLIST (&OPTIONAL (CONSOLE *CONSOLE*) (PROCESS CURRENT-PROCESS)) &BODY BODY))
  `(WITH-WHO-LINE-FORCE-PROCESS-1 (LAMBDA () . ,BODY) . ,ARGS))

(DEFUN WITH-WHO-LINE-FORCE-PROCESS-1 (CONTINUATION
				      &OPTIONAL (CONSOLE *CONSOLE*)
						(PROCESS CURRENT-PROCESS))
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION))
  (LET ((WHO-LINE (CONSOLE-WHO-LINE-SCREEN CONSOLE))
	(OLD-FORCE-PROCESS NIL))
    (WHEN WHO-LINE
      (SETQ OLD-FORCE-PROCESS (WHO-LINE-SCREEN-FORCE-PROCESS WHO-LINE))
      (SETF (WHO-LINE-SCREEN-FORCE-PROCESS WHO-LINE) PROCESS)
      (WHO-LINE-RUN-STATE-UPDATE))		;Necessary to make above take effect
    (UNWIND-PROTECT
	(FUNCALL CONTINUATION)
      (WHEN WHO-LINE
	(WITHOUT-INTERRUPTS
	  (WHEN (EQ (WHO-LINE-SCREEN-FORCE-PROCESS WHO-LINE) PROCESS)
	    (SETF (WHO-LINE-SCREEN-FORCE-PROCESS WHO-LINE) OLD-FORCE-PROCESS)))
	(WHO-LINE-RUN-STATE-UPDATE)))))		;Switch LAST-WHO-LINE-PROCESS back
	
(DEFMETHOD (KBD-ESC CLI::CONSOLE) ()
  (WHEN (NULL (CONSOLE-FUNCTION-KEYS-ENABLED SELF))
    (BEEP)
    (RETURN-FROM KBD-ESC NIL))
  (LET ((ARG NIL) CH)
    (WITH-WHO-LINE-FORCE-PROCESS (SELF)
      (LET ((MINUS NIL))
	(LOOP DOING
	  (SETQ CH (LET ((CHAR (CONSOLE-GET-SOFTWARE-CHAR
				 SELF (format nil "Function~:[~; ~:[~;-~]~@[~D~]~]:"
					      (or minus arg) minus arg))))
		     (CHAR-UPCASE (MAKE-CHARACTER CHAR :BITS (CHAR-BITS CHAR)))))

	  (LET ((DIGIT (DIGIT-CHAR-P CH)))
	    (COND (DIGIT
		   (SETQ ARG (+ (* (OR ARG 0) 10.) DIGIT)))
		  ((EQL CH #/-)
		   (SETQ MINUS T))
		  ((EQL CH #\Function)		;Typed again, reset
		   (SETQ ARG NIL MINUS NIL))
		  (T (RETURN)))))
	(WHEN MINUS
	  (SETQ ARG (MINUS (OR ARG 1))))))
    (LET ((ENTRY (AND (CONSOLE-FUNCTION-KEY-ENABLED-P SELF CH)
		      (CL:ASSOC CH *FUNCTION-KEYS* :TEST #'EQL))))
      (COND (ENTRY
	     (WHEN (MEMQ ':TYPEAHEAD (CDDDR ENTRY))
	       (CONSOLE-START-SELECTION-INPUT-HOLD SELF))
	     (LET ((FUNCTION (SECOND ENTRY)))
	       (UNLESS (FUNCTIONP FUNCTION)
		 (SETQ ARG FUNCTION FUNCTION #'EVAL))
	       (IF (MEMQ ':KEYBOARD-PROCESS (CDDDR ENTRY))
		   (CONSOLE-DO-FUNCTION-KEY SELF FUNCTION ARG)
		   (PROCESS-RUN-FUNCTION
		     (OR (CADR (MEMQ ':PROCESS (CDDDR ENTRY)))
			 (CADR (MEMQ ':PROCESS-NAME (CDDDR ENTRY)))
			 "Function Key")
		     #'CONSOLE-DO-FUNCTION-KEY SELF FUNCTION ARG))))
	    ((CL:MEMBER (MAKE-CHAR CH) '(#\ABORT #\SUSPEND) :TEST #'CHAR-EQUAL)
	     (KBD-ASYNCHRONOUS-INTERCEPT-CHARACTER (SET-CHAR-BIT CH :CONTROL T)
						   (CONSOLE-SELECTED-WINDOW SELF)))
	    ((CHAR CH #\RUBOUT)
	     (BEEP))))))

(DEFVAR-RESETTABLE *ASYNCHRONOUS-WINDOW-OPERATION* NIL)

(DEFMETHOD (CONSOLE-DO-FUNCTION-KEY CLI::CONSOLE) (FUNCTION &REST ARGS)
  (LET ((*CONSOLE* SELF)
	(DEFAULT-SCREEN (CONSOLE-SCREEN SELF))
	(*ASYNCHRONOUS-WINDOW-OPERATION* T))
    (APPLY FUNCTION ARGS))
  (CONSOLE-END-SELECTION-INPUT-HOLD SELF))

;;Function C -- An argument of 1 means white-on-black; 0 means black-on-white.
(DEFUN KBD-COMPLEMENT (ARG)
  (LET ((SCREEN-COMPLEMENT-DISABLED
	  #+3600 NIL
	  #+IMACH (SYS:SYSTEM-CASE (EMBEDDED T)
				   (DOMINO T)
				   (OTHERWISE NIL))))
    (IF SCREEN-COMPLEMENT-DISABLED
	(BEEP)
      (LET ((SCREEN (OR (LET ((SW (CONSOLE-SELECTED-WINDOW *CONSOLE*)))
			  (AND SW (SEND SW :SCREEN)))
			(CONSOLE-SCREEN *CONSOLE*))))
	(SEND SCREEN :SET-BOW-MODE (COND ((NULL ARG) (NOT (SEND SCREEN :BOW-MODE)))
					 ((< ARG 1) T)
					 (T NIL)))))))

(DEFUN KBD-COMPLEMENT-PROMPT ()
  (LET ((SCREEN-COMPLEMENT-DISABLED
	  #+3600 NIL
	  #+IMACH (SYS:SYSTEM-CASE (EMBEDDED T)
				   (DOMINO T)
				   (OTHERWISE NIL))))
    (LIST
      (IF SCREEN-COMPLEMENT-DISABLED
	  (FORMAT NIL "Reserved for toggling the black-on-white state of the whole screen ~
on suitably equipped machines.")
	(FORMAT NIL "Toggle the black-on-white state of the whole screen."))
      (FORMAT NIL "  An argument of 1 means white-on-black; 0 means black-on-white."))))

(DEFUN KBD-LOCAL-COMPLEMENT (ARG)
  (LET ((FRAME (LET ((SW (CONSOLE-SELECTED-WINDOW *CONSOLE*)))
		 (AND SW (SEND SW :ALIAS-FOR-SELECTED-WINDOWS)))))
    (WHEN FRAME
      (SEND FRAME :SET-REVERSE-VIDEO-P (COND ((NULL ARG) (NOT (SEND FRAME :REVERSE-VIDEO-P)))
					     ((< ARG 1) NIL)
					     (T T))))))

(DEFUN KBD-DOC-LINE-COMPLEMENT (ARG)
  (LET ((WINDOW (LET ((WHO-LINE (CONSOLE-WHO-LINE-SCREEN *CONSOLE*)))
		  (AND WHO-LINE (GET-WHO-LINE-FIELD :MOUSE-DOCUMENTATION WHO-LINE)))))
    (WHEN WINDOW
      (LET ((NEW-STATE (COND ((NULL ARG) (NOT (SEND WINDOW :REVERSE-VIDEO-P)))
			     ((< ARG 1) NIL)
			     (T T))))
	(SEND WINDOW :SET-REVERSE-VIDEO-P NEW-STATE)
	(WHEN (EQ WINDOW WHO-LINE-DOCUMENTATION-WINDOW)
	  (SETQ *WHOLINE-DOCUMENTATION-REVERSE-VIDEO-P* NEW-STATE))))))

(DEFUN KBD-ESC-MORE (ARG)		   ;Function M
  (SETQ MORE-PROCESSING-TRULY-GLOBAL-ENABLE
	(COND ((NULL ARG) (NOT MORE-PROCESSING-TRULY-GLOBAL-ENABLE))
	      ((< ARG 1) NIL)		   ;Function 0 M, Function - M = More processing off
	      (T T))))			   ;Function 1 M = More processing on

(DEFUN KBD-ESC-LOCAL-MORE (ARG)		   ;Function c-M
  (LET ((WINDOW (CONSOLE-SELECTED-WINDOW *CONSOLE*)))
    (WHEN WINDOW
      (SEND WINDOW :SET-MORE-P
	    (COND ((NULL ARG) (NOT (SEND WINDOW ':MORE-P)))
		  ((< ARG 1) NIL)	;Function 0 c-M, Function - c-M = More proc. off
		  (T T))))))

(DEFUN KBD-ESC-END-OF-PAGE (ARG)		;Function E
  (LET* ((WINDOW (CONSOLE-SELECTED-WINDOW *CONSOLE*))
	 (MODE (SELECTQ ARG
		   ((NIL)
		    (OR (DW:MENU-CHOOSE-FROM-SET
			  '(:SCROLL :TRUNCATE :WRAP)
			  '(CL:MEMBER :SCROLL :TRUNCATE :WRAP)
			  :DEFAULT DW::*DEFAULT-END-OF-PAGE-MODE*
			  :PROMPT "Select a global end of page mode: "
			  :SUPERIOR (MOUSE-DEFAULT-SUPERIOR WINDOW))
			:IGNORE))
		   ((1) :SCROLL)
		   ((2) :TRUNCATE)
		   ((3) :WRAP))))
    (UNLESS (EQ MODE :IGNORE)
      (IF MODE
	  (SETQ DW::*DEFAULT-END-OF-PAGE-MODE* MODE)
	  (BEEP)))))

(DEFUN KBD-ESC-END-OF-PAGE-LOCAL (ARG)		;Function Control-E
  (LET* ((WINDOW (CONSOLE-SELECTED-WINDOW *CONSOLE*))
	 (MODE (WHEN (AND WINDOW
			  (SEND WINDOW :OPERATION-HANDLED-P :END-OF-PAGE-MODE)
			  (SEND WINDOW :OPERATION-HANDLED-P :SET-END-OF-PAGE-MODE))
		 (SELECTQ ARG
		   ((NIL)
		    (OR
		      (DW:MENU-CHOOSE-FROM-SET
			'(:DEFAULT :SCROLL :TRUNCATE :WRAP)
			`((SCL:ALIST-MEMBER
			    :ALIST
			    ((,(FORMAT NIL "Default (currently ~:(~A~))"
				       DW::*DEFAULT-END-OF-PAGE-MODE*)
			      :DEFAULT)
			     ("Scroll" :SCROLL)
			     ("Truncate" :TRUNCATE)
			     ("Wrap" :WRAP))))
			:DEFAULT (SEND WINDOW :END-OF-PAGE-MODE)
			:PROMPT (FORMAT NIL "Select end of page mode for ~A: " WINDOW)
			:SUPERIOR (MOUSE-DEFAULT-SUPERIOR WINDOW))
		      :IGNORE))
		   ((0) :DEFAULT)
		   ((1) :SCROLL)
		   ((2) :TRUNCATE)
		   ((3) :WRAP)))))
    (UNLESS (EQ MODE :IGNORE)
      (IF MODE
	  (SEND WINDOW :SET-END-OF-PAGE-MODE MODE)
	  (BEEP)))))

(DEFUN KBD-ESC-CLEAR (IGNORE)		   ;Function Clear-Input
  (LET ((BUFFER (CONSOLE-GET-SELECTED-IO-BUFFER *CONSOLE*)))
    (WHEN BUFFER
      (IO-BUFFER-CLEAR BUFFER)))
  (IO-BUFFER-CLEAR (CONSOLE-SYSTEM-IO-BUFFER *CONSOLE*)))

(DEFUN KBD-INSERT-EOF (IGNORE)		   ;Function End
  (LET ((BUFFER (CONSOLE-GET-SELECTED-IO-BUFFER *CONSOLE*)))
    (WHEN BUFFER
      (IO-BUFFER-PUT BUFFER NIL))))

(DEFUN KBD-ESC-ARREST (ARG)
  (LET ((PROCESS (CONSOLE-VISIBLE-SELECTED-PROCESS *CONSOLE*)))
    (COND ((NULL PROCESS) (BEEP))
	  ((AND ARG (MINUSP ARG))
	   (DOLIST (R (SEND PROCESS :ARREST-REASONS))
	     (SEND PROCESS :REVOKE-ARREST-REASON R)))
	  (T
	   (WITHOUT-INTERRUPTS
	     (WAIT-UNTIL-PROCESS-DISTURBABLE PROCESS *PROCESS-DISTURBABLE-TIMEOUT*)
	     (SEND PROCESS :ARREST-REASON))))))

(DEFMETHOD (CONSOLE-VISIBLE-SELECTED-PROCESS CLI::CONSOLE) ()
  (OR (LET ((WHO-LINE (CONSOLE-WHO-LINE-SCREEN SELF)))
	(AND WHO-LINE (WHO-LINE-SCREEN-LAST-PROCESS WHO-LINE)))
      (LET ((SW (CONSOLE-SELECTED-WINDOW SELF)))
	(AND SW (SEND-IF-HANDLES SW :PROCESS)))))

(DEFMETHOD (CONSOLE-WHO-LINE-SCREEN CLI::CONSOLE) ()
  (LET ((SCREEN (CONSOLE-SCREEN SELF)))
    (AND SCREEN (SCREEN-WHO-LINE-SCREEN SCREEN))))

;; Arrest all processes except those that have the :NO-KBD-ARREST flag on in the process
;; (typically the keyboard, mouse, and notification processes, various scheduler processes, and
;; on embedded systems the processes handling RPC and remote output) and the one in
;; the who-line.  With a negative arg, unarrest all processes arrested by this command.  Use
;; this when the machine is too slow to figure out why it's slow.
(DEFUN KBD-ESC-ARREST-ALL (ARG)
  (DECLARE (SCL:INLINE PROCESS::PROCESS-DEBUG-FLAG))
  (PROCESS:MAP-OVER-ALL-PROCESSES
    #'(LAMBDA (P)
	(COND ((AND ARG (MINUSP ARG))
	       (PROCESS:PROCESS-DISABLE-ARREST-REASON P 'KBD-ESC-ARREST-ALL))
	      ((LDB-TEST PROCESS::%%PROCESS-DEBUG-NO-KBD-ARREST
			 (PROCESS::PROCESS-DEBUG-FLAG P)))
	      ((LOOP FOR WHO-LINE IN *ACTIVE-WHO-LINE-SCREENS*
		     THEREIS (EQL P (WHO-LINE-SCREEN-LAST-PROCESS WHO-LINE))))
	      ((PROCESS:PROCESS-ACTIVE-P P)
	       (WITHOUT-INTERRUPTS
		 (WAIT-UNTIL-PROCESS-DISTURBABLE P *PROCESS-DISTURBABLE-TIMEOUT*)
		 (PROCESS:PROCESS-ENABLE-ARREST-REASON P 'KBD-ESC-ARREST-ALL))))))
  (UNLESS (AND ARG (MINUSP ARG))
    (TV:NOTIFY NIL "All other processes arrested.  Type <~:C> <Minus> <Control-A> to unarrest them."
	       #\FUNCTION)))

(DEFVAR *DEFAULT-KBD-BURY-ARG* 0)

(DEFUN KBD-BURY (ARG) ;Function B
  (MULTIPLE-VALUE-BIND (WINDOW MODE)
      (CL:FLOOR (OR ARG *DEFAULT-KBD-BURY-ARG*) 2)
    (SETQ WINDOW (SELECTOR WINDOW =
		   (0 (CONSOLE-SELECTED-WINDOW *CONSOLE*))
		   (1 (WINDOW-UNDER-MOUSE-INTERNAL (CONSOLE-MOUSE *CONSOLE*)))
		   (2 (SETQ WINDOW (WINDOW-UNDER-MOUSE-INTERNAL (CONSOLE-MOUSE *CONSOLE*)))
		      (LOOP AS SUPERIOR = (SEND WINDOW :SUPERIOR)
			    UNTIL (EQ SUPERIOR (SHEET-SCREEN WINDOW))
			    DO (SETQ WINDOW SUPERIOR)))))
    (WHEN WINDOW
      (SETQ WINDOW (SEND WINDOW :ALIAS-FOR-SELECTED-WINDOWS)))
    (COND ((NULL WINDOW) (BEEP))
	  ((PLUSP MODE)
	   (WHEN (MOUSE-Y-OR-N-P (FORMAT NIL "Deactivate  ~S" WINDOW))
	     (SEND WINDOW :DEACTIVATE)))
	  (T (SEND WINDOW :BURY)))))

(DEFUN KBD-OTHER-EXPOSED-WINDOW (IGNORE)
  ;; ESC O selects the least recently-selected window that is exposed.
  ;; Thus repeated esc O cycles among all the selectable exposed windows 
  ;; on all the screens.  Real useful with split-screen!
  (LET ((WINDOW NIL))
    (LOOP FOR LATER-WINDOW BEING THE ARRAY-ELEMENTS
	      OF (CONSOLE-PREVIOUSLY-SELECTED-WINDOWS *CONSOLE*)
	  DO
      (WHEN (AND LATER-WINDOW 
		 (EQ (SEND LATER-WINDOW :STATUS) :EXPOSED)
		 (NOT (NULL (SEND LATER-WINDOW :NAME-FOR-SELECTION))))
	(SETQ WINDOW LATER-WINDOW)))
    (IF WINDOW (SEND WINDOW :MOUSE-SELECT) (BEEP))))

(DEFUN KBD-SWITCH-WINDOWS (ARG) ;Function S
  ;; ESC n S rotates the n most recently selected windows, selecting the nth
  ;; ESC S = ESC 2 S
  ;; ESC 1 S selects the next most recent window but rotates all the windows
  ;; ESC -n S rotates the same set of windows in the other direction
  ;; ESC 0 S selects a window which has an error pending (or otherwise wants attention)
  (UNLESS ARG (SETQ ARG 2))
  (IF (= ARG 0)
      (LET ((WINDOW (FIND-INTERESTING-WINDOW)))
	(WHEN WINDOW (SEND WINDOW :MOUSE-SELECT)))
      (DELAYING-SCREEN-MANAGEMENT		;Inhibit auto-selection
	(LET ((WINDOW (CONSOLE-SELECTED-WINDOW *CONSOLE*)))
	  (WHEN WINDOW
	    (SEND WINDOW :DESELECT NIL)
	    (CONSOLE-MOVE-TYPEAHEAD *CONSOLE* (SEND WINDOW :IO-BUFFER) NIL)))
	(WITHOUT-INTERRUPTS		;Get rid of any non-mouse-selectable ones
	  (REMOVE-FROM-PREVIOUSLY-SELECTED-WINDOWS-IF
	    #'(LAMBDA (WINDOW) (NOT (SEND WINDOW :NAME-FOR-SELECTION)))
	    *CONSOLE*)
	  (ROTATE-TOP-OF-ARRAY (CONSOLE-PREVIOUSLY-SELECTED-WINDOWS *CONSOLE*) ARG))
	(LET ((WINDOW (AREF (CONSOLE-PREVIOUSLY-SELECTED-WINDOWS *CONSOLE*) 0)))
	  (WHEN WINDOW (SEND WINDOW :MOUSE-SELECT))))))

;This is like ZWEI:ROTATE-TOP-OF-LIST but for an array with a fill-pointer.
;Rotate nth (1-origin!) element to the front of the array, rotating the
;part of the array before it.  With a negative arg rotate the same amount
;backwards.  With an arg of 1 rotate the whole array BACKWARDS, i.e. bring
;up the same element as with an arg of 2 but store the old front at the back.
;Zero arg is undefined, do nothing I guess.  Note that 2 and -2 do the same thing.
;Doesn't barf if N is too big.
(DEFUN ROTATE-TOP-OF-ARRAY (ARRAY N &AUX (LENGTH (ARRAY-ACTIVE-LENGTH ARRAY)))
  (AND (= (ABS N) 1) (SETQ N (* N -1 LENGTH)))
  (COND ((PLUSP N)
	 (SETQ N (MIN LENGTH N))
	 (DO ((I 0 (1+ I))
	      (NTH (AREF ARRAY (1- N)) OLD)
	      (OLD))
	     (( I N))
	   (SETQ OLD (AREF ARRAY I))
	   (ASET NTH ARRAY I)))
	((MINUSP N)
	 (SETQ N (MIN LENGTH (MINUS N)))
	 (DO ((I 1 (1+ I))
	      (FRONT (AREF ARRAY 0)))
	     (( I N) (ASET FRONT ARRAY (1- I)))
	   (ASET (AREF ARRAY I) ARRAY (1- I)))))
  ARRAY)

(DEFUN KBD-SCREEN-REDISPLAY ()
  (DOLIST (SCREEN ALL-THE-SCREENS)
    (WHEN (AND (EQ (SHEET-CONSOLE SCREEN) *CONSOLE*)
	       (SHEET-EXPOSED-P SCREEN))
      (DOLIST (I (SHEET-EXPOSED-INFERIORS SCREEN))
	(WHEN (SHEET-CAN-GET-LOCK I)
	  (SEND I :REFRESH)))
      (SEND SCREEN :SCREEN-MANAGE)
      (SEND SCREEN :REFRESH-MARGINS)))
  (WHO-LINE-CLOBBERED))

(DEFUN KBD-CLEAR-LOCKS (IGNORE)			;Function c-Clear-Input
  (DOLIST (CONSOLE *CONSOLES*)
    (SETF (MOUSE-WINDOW (CONSOLE-MOUSE CONSOLE)) NIL))	;This is a lock, too
  (KBD-CLEAR-TEMPORARY-WINDOWS NIL)		;First flush any temporary windows
  (SHEET-CLEAR-LOCKS)				;Then clear all locks
  (DOLIST (CONSOLE *CONSOLES*)
    (SETF (MOUSE-RECONSIDER (CONSOLE-MOUSE CONSOLE)) T)))	;Force mouse out of former MOUSE-WINDOW

(DEFUN KBD-CLEAR-TEMPORARY-WINDOWS (IGNORE)	;Function c-T
  (MAP-OVER-SHEETS #'(LAMBDA (SHEET)
		       (AND (SHEET-TEMPORARY-P SHEET)
			    (SHEET-EXPOSED-P SHEET)
			    (SHEET-CAN-GET-LOCK SHEET)
			    (CATCH-ERROR (SEND SHEET ':DEEXPOSE) NIL)))))

(DEFVAR-RESETTABLE COLD-LOAD-STREAM-SELECTED NIL)
(DEFVAR-RESETTABLE COLD-LOAD-STREAM-OLD-SELECTED-WINDOW NIL)

(DEFMACRO WITH-COLD-LOAD-STREAM ((STRING) &BODY BODY)
  (LET ((CLEANUP (GENSYM)))
    `(LET ((,CLEANUP)
	   (TERMINAL-IO TERMINAL-IO)
	   (COLD-LOAD-STREAM-OLD-SELECTED-WINDOW SELECTED-WINDOW))
       (UNWIND-PROTECT
	 (LET ((QUERY-IO SI:SYN-TERMINAL-IO)
	       (DEBUG-IO SI:SYN-TERMINAL-IO)
	       (ERROR-OUTPUT SI:SYN-TERMINAL-IO)
	       (STANDARD-OUTPUT SI:SYN-TERMINAL-IO)
	       (STANDARD-INPUT SI:SYN-TERMINAL-IO)
	       ;; DBG:USE-COLD-LOAD-STREAM can setq SYS:INHIBIT-SCHEDULING-FLAG
	       (SYS:INHIBIT-SCHEDULING-FLAG SYS:INHIBIT-SCHEDULING-FLAG))
	   (WHEN (NEQ TERMINAL-IO COLD-LOAD-STREAM)
	     (SETQ ,CLEANUP T)
	     (SETQ COLD-LOAD-STREAM-SELECTED T)
	     (DBG:USE-COLD-LOAD-STREAM ,STRING))
	   (CATCH-ERROR-RESTART-IF ,CLEANUP ((ERROR ABORT) "Exit from COLD-LOAD-STREAM")
	     ,. BODY))
	 (WHEN ,CLEANUP
	   (DBG:RECOVER-FROM-COLD-LOAD-STREAM))))))

(DEFUN KBD-USE-COLD-LOAD-STREAM (&OPTIONAL (REASON "Function Suspend") ERROR-IF-UNAVAILABLE-P)
  (MACROLET ((DOIT ()
	       `(WITHOUT-INTERRUPTS
		  (WITH-COLD-LOAD-STREAM (REASON)
		    (LET ((SELECTED-WINDOW NIL))
		      (FORMAT COLD-LOAD-STREAM "~&The current package is ~A~%~%" PACKAGE)
		      (BREAK COLD-LOAD-STREAM))))))
    #+3600 (DOIT)
    #+IMACH (COND ((SYSTEM-CASE
		     (DOMINO (CLI::DOMINO-DEBUG-SWITCH-P))
		     (OTHERWISE T))
		   (DOIT))
		  (ERROR-IF-UNAVAILABLE-P
		    ;; If the caller must get into the debugger when there's no cold load
		    ;; stream, signal an error to generate a stack trace and warm boot.
		    (ERROR REASON))
		  (T
		   (TV:NOTIFY NIL "There is no cold load stream available at this time.")))))


(DEFUN KBD-ESC-OUTPUT-HOLD (IGNORE)
  (LET (P W LOCKED ANS SCR)
    (COND ((AND (SETQ P (CONSOLE-VISIBLE-SELECTED-PROCESS *CONSOLE*))
		(MEMBER (PROCESS-WHOSTATE P) '("Output Hold" "Lock" "Sheet Lock"))
		(TYPEP (SETQ W (CAR (PROCESS-WAIT-ARGUMENT-LIST P))) 'SHEET))
	   ;; Bludgeon our way past any deadlocks, e.g. due to the process P holding
	   ;; the lock on the window we are trying to expose, or on something we need
	   ;; to de-expose in order to expose it.  This code probably doesn't do a good
	   ;; enough job explaining what is going on to the user.
	   (COND ((AND (LISTP (SHEET-LOCK W))	;Only temp-locked?
		       (ZEROP (SHEET-LOCK-COUNT W))
		       (LOOP FOR TW IN (SHEET-LOCK W)
			     ALWAYS (SHEET-CAN-GET-LOCK TW)))
		  (SHEET-FREE-TEMPORARY-LOCKS W))
		 ((AND (NOT (SHEET-EXPOSED-P (SETQ SCR (SHEET-SCREEN W))))
		       (NOT (SEND SCR :APPROPRIATE-HARDWARE-P)))
		  ;;
		  ;; the screen isn't exposable.
		  (WITH-COLD-LOAD-STREAM ("Screen is unusable")
		    (format t
			    "~&Screen ~A is not usable, and window ~A is trying to expose on it~%"
			    scr w)
		    (when (FQUERY '(:CHOICES (((T "Yes.") #/Y #\SP #/T)
					      ((NIL "No.") #/N #\RUBOUT)
					      ((DBG "Debugger.") #/D)))
				  "Use screen ~A instead?" default-screen)
		      (set-window-on-usable-screen w))))
		 ((OR (NOT (SHEET-CAN-GET-LOCK (SETQ LOCKED W)))
		      (AND (SHEET-SUPERIOR W)
			   (LOOP FOR I IN (SHEET-EXPOSED-INFERIORS (SHEET-SUPERIOR W))
				 THEREIS (AND (SHEET-OVERLAPS-SHEET-P W I)
					      (NOT (SHEET-CAN-GET-LOCK (SETQ LOCKED I) P))))))
		  (BEEP)
		  (WITH-COLD-LOAD-STREAM ('#,(FORMAT NIL "~:C ~:C while window system frozen"
						     #\FUNCTION #\ESCAPE))
		    (FORMAT T
			    "&Process ~S is waiting on the window~@
			     ~S because ~:[~S~;~*it~]~@
			     is locked by ~S."
			    P W (EQ W LOCKED) LOCKED (SHEET-LOCK LOCKED))
		    (UNLESS
		      ;; If the problem is our window is deexposed because there is a
		      ;; process locking it or a superior
		      (AND (TYPEP (SHEET-LOCK LOCKED) 'SI:PROCESS)
			   (NOT (SHEET-EXPOSED-P W))
			   (CL:LOCALLY (DECLARE (SPECIAL INSIDE-FORCED-EXPOSE))
			     (LET ((DONE NIL))
			       (SETQ INSIDE-FORCED-EXPOSE NIL)	;Top-level value
			       (FORMAT T "~&We can try to send a :EXPOSE message in ~S.~@
					  If that hangs, we time out in 10 seconds."
				       (SHEET-LOCK W))
			       (WHEN (Y-OR-N-P
				       "Attempt to do a :EXPOSE in the other process? ")
				 (DBG:RECOVER-FROM-COLD-LOAD-STREAM NIL)
				 (SEND (SHEET-LOCK LOCKED) ':INTERRUPT
				       #'(LAMBDA (W LOC)
					   (*CATCH LOC
					     (CONDITION-CASE (.ERROR.)
						 (LET ((INSIDE-FORCED-EXPOSE LOC))
						   (DECLARE (SPECIAL INSIDE-FORCED-EXPOSE))
						   (SEND W ':EXPOSE))
					       (ERROR (RPLACA LOC .ERROR.))
					       (:NO-ERROR (RPLACA LOC W)))))
				       W (LOCF DONE))
				 (PROCESS-WAIT-WITH-TIMEOUT "Other Expose" 600.
							    #'CAR (LOCF DONE))
				 (UNLESS DONE
				   (SEND (SHEET-LOCK LOCKED) ':INTERRUPT
					 #'(LAMBDA (LOC)
					     (WHEN (EQ INSIDE-FORCED-EXPOSE LOC)
					       (*THROW INSIDE-FORCED-EXPOSE NIL)))
					 (LOCF DONE)))
				 (SETQ DBG:SAVED-SCREEN-PROCESS CURRENT-PROCESS)
				 (TYPECASE DONE
				   (ERROR (SEND COLD-LOAD-STREAM ':HOME-CURSOR)
					  (FORMAT T "~&~%:EXPOSE Got an error:  ~A~%" DONE))
				   (SHEET (SETQ DBG:SAVED-SCREEN-PROCESS NIL))
				   (OTHERWISE (SEND COLD-LOAD-STREAM ':HOME-CURSOR)
					      (FORMAT T "~&Attempt to expose timed out."))))
			       (EQ DONE W))))				   
		      (SETQ ANS
			    (FQUERY '(:CHOICES (((T "Yes.") #/Y #\SP #/T)
						((NIL "No.") #/N #\RUBOUT)
						((DBG "Debugger.") #/D)))
				    "Process ~S is waiting on the window~@
		                 Forcibly unlock all window-system locks, or enter debugger? "
				    P W (EQ W LOCKED) LOCKED (SHEET-LOCK LOCKED)))
		      (COND ((EQ ANS 'DBG)
			     (PROCESS::PROCESS-ASYNCHRONOUS-BREAK P)
			     (RETURN-FROM KBD-ESC-OUTPUT-HOLD NIL))	;Don't try to expose
			    (ANS (SHEET-CLEAR-LOCKS))))))
		 ((AND (SHEET-EXPOSED-P W)	;This can happen, I don't know how
		       (NOT (SHEET-LOCK W))
		       (SHEET-OUTPUT-HELD-P W))
		  (WITH-COLD-LOAD-STREAM ("Window system bug")
		    (IF (FQUERY '(:BEEP T)
				"~S is output-held for no apparent reason.~@
				 If you know the circumstances that led to this, please~@
				 mail in a bug report describing them.  ~
				 Do you want to forcibly clear output-hold? "
				W)
			(SETF (SHEET-OUTPUT-HOLD-FLAG W) 0)))))
	   (SEND W :SET-STATUS ':EXPOSED))
	  (T (BEEP)))))

(DEFUN KBD-ESC-T (ARG)
  "Control the selected window's notification properties.
Toggle output notification and set input notification to the same thing.
 0 Turn off output and input notification.
 1 Turn on output and input notification.
 2 Turn output notification on and input notification off.
 3 Turn output notification off and input notification on.
 4 Let output proceed with window deexposed and turn input notification on.
 5 Let output proceed with window deexposed and turn input notification off."
  (LET ((SW (CONSOLE-SELECTED-WINDOW *CONSOLE*)))
    (COND ((NOT (OR (NULL ARG) ( ARG 5)))
	   (BEEP))
	  ((NOT (NULL SW))				     
	   (LET ((CURRENT-OUT-ACTION (SEND SW :DEEXPOSED-TYPEOUT-ACTION)))
	     (SEND SW :SET-DEEXPOSED-TYPEOUT-ACTION
		   (COND ((OR (MEMQ ARG '(0 3))
			      (AND (NULL ARG)
				   (NOT (EQ CURRENT-OUT-ACTION ':NORMAL))))
			  ':NORMAL)
			 ((OR (MEMQ ARG '(1 2))
			      (AND (NULL ARG)
				   (NOT (EQ CURRENT-OUT-ACTION ':NOTIFY))))
			  ':NOTIFY)
			 ((MEMQ ARG '(4 5))
			  ':PERMIT)))
	     (SEND SW :SET-DEEXPOSED-TYPEIN-ACTION
		   (COND ((NULL ARG) (IF (EQ CURRENT-OUT-ACTION ':NORMAL) ':NOTIFY ':NORMAL))
			 ((MEMQ ARG '(0 2 5)) ':NORMAL)
			 (T ':NOTIFY)))))
	  (T (BEEP)))))

(DEFUN KBD-ESC-W (ARG)
  (LET ((WHO-LINE (CONSOLE-WHO-LINE-SCREEN *CONSOLE*)))
    (WHEN (NULL WHO-LINE)
      (RETURN-FROM KBD-ESC-W))
    (WHEN (NULL ARG)
      (SEND WHO-LINE :REFRESH)
      (RETURN-FROM KBD-ESC-W))
    (LET* ((PROC (CONSOLE-VISIBLE-SELECTED-PROCESS *CONSOLE*))
	   (NEW-PROC (SELECTOR ARG =
		       (0 (DW:MENU-CHOOSE-FROM-SET PROCESS:*ALL-PROCESSES* 'PROCESS:PROCESS
						   :PROMPT "Who-line process:"
						   :DEFAULT PROC))
		       (1 NIL)
		       (2 PROC)
		       (3 (OR (DO ((L PROCESS:*ALL-PROCESSES* (CDR L)))
				  ((NULL L))
				(AND (EQ (CAR L) PROC)
				     (RETURN (CADR L))))
			      (CAR (LAST PROCESS:*ALL-PROCESSES*))))
		       (4 (OR (DO ((L PROCESS:*ALL-PROCESSES* (CDR L))
				   (OL NIL L))
				  ((NULL L))
				(AND (EQ (CAR L) PROC)
				     (RETURN (CAR OL))))
			      (CAR (LAST PROCESS:*ALL-PROCESSES*)))))))
      (SETF (WHO-LINE-SCREEN-FORCE-PROCESS WHO-LINE) NEW-PROC)
      (WHO-LINE-UPDATE))))

(DEFMETHOD (KBD-SYS CLI::CONSOLE) ()
  (WHEN (NOT (CONSOLE-SELECT-KEY-ENABLED-P SELF))
    (BEEP)
    (RETURN-FROM KBD-SYS NIL))
  (LET (CH)
    (WITH-WHO-LINE-FORCE-PROCESS (SELF)
      (LET ((CHAR (CONSOLE-GET-SOFTWARE-CHAR SELF "Select:")))
	(SETQ CH (CHAR-UPCASE (MAKE-CHARACTER CHAR :BITS (CHAR-BITS CHAR))))))
    (LET ((FORCE-CREATE (PROG1 (CHAR-BIT CH :CONTROL) (SETQ CH (MAKE-CHAR CH))))
	  (ACTIVITY (AND (CONSOLE-SELECT-KEY-ENABLED-P SELF CH) (SYS:SELECT-KEY-ACTIVITY CH))))
      (COND (ACTIVITY
	     (CONSOLE-START-SELECTION-INPUT-HOLD SELF)
	     (PROCESS-RUN-FUNCTION '(:NAME "Select Key" :PRIORITY 1)
	       #'CONSOLE-DO-FUNCTION-KEY SELF
	       #'SELECT-ACTIVITY ACTIVITY :FORCE-CREATE FORCE-CREATE
					  :BEEP-IF-ONLY-ONE-SELECTED T))
	    ((AND (MEMQ CH '(#/? #\HELP))
		  (VARIABLE-BOUNDP #'KBD-SYS-HELP))
	     (CONSOLE-START-SELECTION-INPUT-HOLD SELF)
	     (PROCESS-RUN-FUNCTION "Select Key" 
	       #'CONSOLE-DO-FUNCTION-KEY SELF #'KBD-SYS-HELP))
	    ((CHAR CH #\RUBOUT) (BEEP))))))

(DEFMETHOD (KBD-PRINT CLI::CONSOLE) ()
  ;; Equivalent to Function Q
  (LET ((FUNCTION (SECOND (CL:ASSOC #\Q *FUNCTION-KEYS*))))
    (IF (AND FUNCTION (CONSOLE-FUNCTION-KEY-ENABLED-P SELF #\Q))
	(PROCESS-RUN-FUNCTION "Hardcopy Screen" #'CONSOLE-DO-FUNCTION-KEY SELF FUNCTION 0)
      (BEEP))))

;;; Anything typed before the System belongs to the currently selected window
;;; Anything typed after this belongs to the new window we are going to get to.
(DEFMETHOD (CONSOLE-START-SELECTION-INPUT-HOLD CLI::CONSOLE) ()
  (WITHOUT-INTERRUPTS
    (LET ((BUFFER (CONSOLE-GET-SELECTED-IO-BUFFER SELF)))
      (WHEN BUFFER
	(CONSOLE-MOVE-TYPEAHEAD SELF BUFFER NIL)))
    (SETF (CLI::CONSOLE-SELECTION-START-TIME SELF) (TIME))))

(DEFMETHOD (CONSOLE-END-SELECTION-INPUT-HOLD-1 CLI::CONSOLE) ()
  (SETF (CLI::CONSOLE-SELECTION-START-TIME SELF) NIL))

;;; Call this if you want typein to start right away while still in the special process.
(DEFUN CONSOLE-END-SELECTION-INPUT-HOLD (&OPTIONAL (CONSOLE *CONSOLE*))
  (CONSOLE-END-SELECTION-INPUT-HOLD-1 CONSOLE))

;; this helps with SYSTEM-keys tendancy to bomb when it selects
;; an unselectable window.
;;
(DEFUN WINDOW-IS-SELECTABLE (WINDOW)
  (LOOP FOR SHEET = WINDOW THEN (SEND SHEET :SUPERIOR)
	WHILE SHEET
	ALWAYS (WINDOW-IS-EXPOSABLE-INFERIOR SHEET T)))

;; Check for permanent conditions that would make this window not exposable.
;; Don't check for transient conditions, because that made the behavior of
;; the Select key too unpredictable.  Locking is considered a transient
;; condition; of course we can't really know whether or not the holder of
;; the lock is planning on releasing it any time soon.  The screen being
;; unselectable is considered a permanent one.
;; Covering of the superior by a temporary window is considered a transient
;; condition; if the :MOUSE-SELECT message fails to pop these down, that
;; is a bug in the :MOUSE-SELECT message.
;; Thus the only condition we really care about is whether the window's
;; edges are legal.
(DEFUN WINDOW-IS-EXPOSABLE-INFERIOR (SHEET &OPTIONAL OK-TO-ACTIVATE)
  ;; this stuff stolen from sheet:prepare-to-expose
  (OR (SEND SHEET ':EXPOSED-P)
      (AND (ZEROP (SHEET-DEAD SHEET))
	   (LET ((SUPER (SHEET-SUPERIOR SHEET)))
	     (IF (NULL SUPER)
		 (SEND SHEET :SEND-IF-HANDLES :APPROPRIATE-HARDWARE-P)
		 (WHEN (OR OK-TO-ACTIVATE (MEMQ SHEET (SHEET-INFERIORS SUPER)))
		   (SHEET-WITHIN-SHEET-P SHEET SUPER)))))))

;; the improvements here allow a user-supplied predicate, to help select windows.
;; also, FIND-WINDOW-OF-FLAVOR returns the resumption index so if you don't
;; like the window it selects you can resume.  - DDyer
;; [The value returned is meaningless if the caller doesn't WITHOUT-INTERRUPTS
;;  around the whole operation.]
(DEFUN FIND-WINDOW-OF-FLAVOR (FLAVOR &OPTIONAL (INDEX 0) (PREDICATE #'WINDOW-IS-SELECTABLE)
			      (CONSOLE *CONSOLE*))
  ;; Only looks at PREVIOUSLY-SELECTED-WINDOWS, but that should have all the ones
  ;; of any interest.
  (WITHOUT-INTERRUPTS
    (UNLESS (NULL CONSOLE)
      (LOOP WITH PSW = (CONSOLE-PREVIOUSLY-SELECTED-WINDOWS CONSOLE)
	    FOR I FROM INDEX BELOW (ARRAY-ACTIVE-LENGTH PSW)
	    AS W = (AREF PSW I)
	    WHEN (AND W
		      (COND ((LISTP FLAVOR)
			     (LOOP FOR FLAV IN FLAVOR
				   THEREIS (AND (FLAVOR:FIND-FLAVOR FLAV NIL)
						(TYPEP W FLAV))))
			    (FLAVOR
			     (AND (FLAVOR:FIND-FLAVOR FLAVOR NIL)
				  (TYPEP W FLAVOR)))
			    (T T))
		      (SEND W :NAME-FOR-SELECTION)
		      (OR (NULL PREDICATE)
			  (FUNCALL PREDICATE W)))
	      DO (RETURN (VALUES W (ADD1 I)))
		 ))))

(DEFUN FIND-INFERIOR-OF-FLAVOR (SUPERIOR FLAVOR &OPTIONAL CREATE-P NOT-THESE)
  (LOOP FOR INFERIOR IN (SHEET-INFERIORS SUPERIOR)
	WHEN (AND (SI:TYPEP-FLAVOR INFERIOR FLAVOR)
		  (NOT (MEMQ INFERIOR NOT-THESE)))
	  RETURN INFERIOR
	FINALLY (AND CREATE-P (RETURN (MAKE-WINDOW FLAVOR ':SUPERIOR SUPERIOR)))))

(DEFUN FIND-PROCESS-IN-ERROR (&OPTIONAL (CONSOLE *CONSOLE*))
  (PROCESS:MAP-OVER-ACTIVE-PROCESSES
    #'(LAMBDA (P)
	(LET ((SG (PROCESS::PROCESS-STACK-GROUP P)))
	  (WHEN (TYPEP SG :STACK-GROUP)
	    (LET ((WINDOW (SYMEVAL-IN-STACK-GROUP 'PROCESS-IS-IN-ERROR SG)))
	      (WHEN (AND WINDOW (EQ (SHEET-CONSOLE WINDOW) CONSOLE))
		(RETURN-FROM FIND-PROCESS-IN-ERROR (VALUES P WINDOW)))))))))

;;; Some people still calling this.  This isn't what it used to do, but what its callers
;;; thought it did.
(DEFUN TYPE-A-SPACE-TO-FLUSH (WINDOW)
  (READ-CHARACTER WINDOW :PROMPT "Type a space to refresh the screen: "))

;;; More or less innocuous functions from the old window system that are called all over the
;;; place.
(DEFUN KBD-TYI (&REST IGNORE) (SEND TERMINAL-IO :TYI))

(DEFUN KBD-TYI-NO-HANG (&REST IGNORE) (SEND TERMINAL-IO :TYI-NO-HANG))

(DEFUN KBD-CHAR-AVAILABLE (&REST IGNORE) (SEND TERMINAL-IO :LISTEN))

;;; Other compatibility stuff

;;; This is its old name (should be removed for Release 7)
(DEFF ADD-ESCAPE-KEY 'ADD-FUNCTION-KEY)
(COMPILER:MAKE-OBSOLETE ADD-ESCAPE-KEY
			"The name for this function has been changed to TV:ADD-FUNCTION-KEY")

;;; This is the alias for the LM-2 (mainly useful for lusers finding this with APROPOS)
(DEFF ADD-TERMINAL-KEY 'ADD-FUNCTION-KEY)
(COMPILER:MAKE-OBSOLETE ADD-TERMINAL-KEY "This function is now TV:ADD-FUNCTION-KEY")

(DEFVAR *OBSOLETE-CONSOLE-FUNCTIONS* ())

(DEFPROP DEFUN-OBSOLETE-CONSOLE-COMPATIBILITY DEFUN ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)

;;; Some of these should just be flushed, and others made no longer to warn after
;;; initial conversion of the system itself.
(DEFMACRO DEFUN-OBSOLETE-CONSOLE-COMPATIBILITY (OLD-NAME CONSOLE-FUNCTION ARGLIST
						&OPTIONAL FORM)
  (UNLESS FORM
    (LET* ((INFO (LT:PARSE-LAMBDA-LIST ARGLIST))
	       (POSITIONAL (APPEND (CL:SUBSEQ (LT:LLI-REQUIRED INFO)
					      0 (LT:LLI-N-REQUIRED INFO))
				   (LOOP FOR OPT IN (LT:LLI-OPTIONAL INFO)
					 REPEAT (LT:LLI-N-OPTIONAL INFO)
					 COLLECT (IF (SYMBOLP OPT) OPT (FIRST OPT)))))
	       (REST (LT:LLI-REST INFO)))
	  (SETQ FORM (IF REST
			 `(LEXPR-FUNCALL #',CONSOLE-FUNCTION *CONSOLE* ,@POSITIONAL ,REST)
			 `(,CONSOLE-FUNCTION *CONSOLE* . ,POSITIONAL)))))
  `(PROGN
     (DEFUN ,OLD-NAME ,ARGLIST ,FORM)
     (SCL:PUSHNEW '(,OLD-NAME ,CONSOLE-FUNCTION) *OBSOLETE-CONSOLE-FUNCTIONS*
		  :REPLACE T :KEY #'FIRST)))

(DEFUN-OBSOLETE-CONSOLE-COMPATIBILITY KBD-PROCESS-MAIN-LOOP-INTERNAL
				      CONSOLE-PROCESS-INPUT
  (&OPTIONAL FORCE-P)
  (PROGN (IGNORE FORCE-P) (CONSOLE-PROCESS-INPUT *CONSOLE*)))

(DEFUN-OBSOLETE-CONSOLE-COMPATIBILITY KBD-IO-BUFFER-LISTEN CONSOLE-IO-BUFFER-LISTEN
  (BUFFER))

(DEFUN-OBSOLETE-CONSOLE-COMPATIBILITY KBD-IO-BUFFER-INPUT-WAIT CONSOLE-IO-BUFFER-INPUT-WAIT
  (BUFFER &OPTIONAL WHOSTATE FUNCTION &REST ARGUMENTS))

(DEFUN-OBSOLETE-CONSOLE-COMPATIBILITY KBD-IO-BUFFER-INPUT-BLOCK CONSOLE-IO-BUFFER-INPUT-BLOCK
  (BUFFER &OPTIONAL WHOSTATE FUNCTION &REST ARGUMENTS))

(DEFUN-OBSOLETE-CONSOLE-COMPATIBILITY KBD-IO-BUFFER-GET CONSOLE-IO-BUFFER-GET
  (BUFFER &OPTIONAL (NO-HANG-P NIL) WHOSTATE))

(DEFUN-OBSOLETE-CONSOLE-COMPATIBILITY KBD-SNARF-INPUT CONSOLE-MOVE-TYPEAHEAD
  (BUFFER &OPTIONAL NO-HARDWARE-CHARS-P))

(DEFUN-OBSOLETE-CONSOLE-COMPATIBILITY KBD-GET-SOFTWARE-CHAR CONSOLE-GET-SOFTWARE-CHAR
  (&OPTIONAL (WHOSTATE "Keyboard")))

(DEFUN-OBSOLETE-CONSOLE-COMPATIBILITY KBD-CHAR-TYPED-P CONSOLE-CHAR-TYPED-P ())

(DEFUN-OBSOLETE-CONSOLE-COMPATIBILITY KBD-CLEAR-IO-BUFFER CONSOLE-CLEAR-IO-BUFFER ())

(DEFUN-OBSOLETE-CONSOLE-COMPATIBILITY KBD-CLEAR-SELECTED-IO-BUFFER
				      CONSOLE-CLEAR-SELECTED-IO-BUFFER ())

(DEFUN-OBSOLETE-CONSOLE-COMPATIBILITY KBD-GET-IO-BUFFER CONSOLE-GET-SELECTED-IO-BUFFER ())

(DEFUN-OBSOLETE-CONSOLE-COMPATIBILITY KEY-STATE CONSOLE-KEY-STATE (KEY))

;;; Read hardware characters from main console for cold load stream.
;;; Don't use *CONSOLE*, since cold load stream always reads from main keyboard.
;;; Also, these check *MAIN-CONSOLE* for being null so that they work for the cold load
;;; stream during console initialization.  Of course that doesn't apply to NBS machines,
;;; where the -cold versions don't get characters from the right place.
(DEFUN-OBSOLETE-CONSOLE-COMPATIBILITY KBD-HARDWARE-CHAR-AVAILABLE
				      CONSOLE-HARDWARE-CHAR-AVAILABLE
  (&OPTIONAL KBD-IN-PTR)
  (IF (NULL *MAIN-CONSOLE*)
      (SI:KBD-HARDWARE-CHAR-AVAILABLE-COLD KBD-IN-PTR)
      (CONSOLE-HARDWARE-CHAR-AVAILABLE *MAIN-CONSOLE* KBD-IN-PTR)))

(DEFUN-OBSOLETE-CONSOLE-COMPATIBILITY KBD-GET-HARDWARE-CHAR CONSOLE-GET-HARDWARE-CHAR ()
  (IF (NULL *MAIN-CONSOLE*)
      (SI:KBD-GET-HARDWARE-CHAR-COLD)
      (CONSOLE-GET-HARDWARE-CHAR *MAIN-CONSOLE*)))

(DEFUN-OBSOLETE-CONSOLE-COMPATIBILITY KBD-CONVERT-TO-SOFTWARE-CHAR
				      CONSOLE-CONVERT-TO-SOFTWARE-CHAR
  (CH &OPTIONAL (KBD-TABLE SI:KBD-NEW-TABLE))
  (IF (NULL *MAIN-CONSOLE*)
      (SI:KBD-CONVERT-TO-SOFTWARE-CHAR-COLD CH)	;Use whatever keyboard table it wants
      (CONSOLE-CONVERT-TO-SOFTWARE-CHAR *MAIN-CONSOLE* CH KBD-TABLE)))

;;; Use this when compiling an application that is supposed to run in multiple console
;;; configurations.
(DEFUN ENABLE-OBSOLETE-CONSOLE-COMPILER-WARNINGS ()
  (SCL:WITH-STANDARD-IO-ENVIRONMENT		;For printing
    (LOOP FOR (OLD NEW) IN *OBSOLETE-CONSOLE-FUNCTIONS*
	  DO (COMPILER:MAKE-OBSOLETE-1 OLD
				       (FORMAT () "Use ~S of the right console" NEW)
				       'DEFUN))
    (LOOP FOR (OLD NEW) IN CLI::*MAIN-CONSOLE-COMPATIBILITY-VARIABLES*
	  DO (COMPILER:MAKE-OBSOLETE-1 OLD
				       (FORMAT () "Use ~S of the right console"
					       (PKG-BIND "CLI"
						 (FINTERN "CONSOLE-~A" NEW)))
				       'DEFVAR))
    (LOOP FOR (OLD NEW) IN CLI::*MAIN-KEYBOARD-COMPATIBILITY-VARIABLES*
	  DO (COMPILER:MAKE-OBSOLETE-1 OLD 
				       (FORMAT () "Use ~S of the right keyboard"
					       (PKG-BIND "CLI"
						 (FINTERN "KEYBOARD-~A" NEW)))
				       'DEFVAR))
    (LOOP FOR (OLD NEW) IN *MAIN-MOUSE-COMPATIBILITY-VARIABLES*
	  DO (COMPILER:MAKE-OBSOLETE-1 OLD
				       (FORMAT () "Use ~S of the right mouse" NEW)
				       'DEFVAR))
    ))
