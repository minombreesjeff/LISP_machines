;;; -*- Mode: LISP; Base: 10.; Package: TV -*-


;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
(eval-when (compile load eval)

(defconst %allocator-methods% '(allocate-raster deallocate-raster make-local make-remote
   describe-allocator-state find-info make-raster-permanent
   verify-rasters remove-lock-reason %SCREEN-PAGE-IN-SHEET-TEMPORARY-BIT-ARRAY
   %SCREEN-PAGE-OUT-SHEET-TEMPORARY-BIT-ARRAY %screen-deallocate-sheet-temporary-bit-array
   %screen-allocate-sheet-temporary-bit-array monitor-allocator
   find-active-allocators find-all-allocators 
   screen-follow-drawable-indirection
   state my-allocator-raster-p)))

(defflavor D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")allocator-protocol0 () ()
  (:required-methods . #.%allocator-methods%)
  :abstract-flavor )

(defflavor 1slave-allocator-mixin0 () (allocator-protocol)
  (:required-instance-variables parent-screen))

(defwhopper (1:adjust-screen-array0 slave-allocator-mixin)
	    (array new-pointer &optional (dx 0)(dy 0)(xo 0)(yo 0))
(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")  ;deliberately dump the optional arguments, which aren't part of the screen protocol
  ;but which sometimes get sent anyway
0  (if (and (zerop dx)(zerop dy)(zerop xo)(zerop yo))
      (continue-whopper array new-pointer)
      (error "Passing illegal arguments offsets to a screen")
      ))

(def-pass-to-parent slave-allocator-mixin . #.%allocator-methods%)

2;;error flavors
0(defflavor 1allocator-error0 ((screen)) (ferror)
  :initable-instance-variables
  (:required-init-keywords :screen))

(defmacro 1signal-allocator-error0 ((&rest format-args)
				  &body proceed-clauses)
  `(signal-proceed-case (() 'allocator-error
			 :screen screen
			 :format-string (or ,(first format-args) "Allocator error")
			 :format-args (list ,@(cdr format-args)))
     ,@proceed-clauses
     ))

(defwhopper (:1bug-report-description0 allocator-error) (stream &rest args)
  (describe-allocator-state screen stream)
  (lexpr-continue-whopper stream args))

(defmethod (1sys:proceed0 allocator-error 1:proceed0) ()
  "Continue and return NIL (for failure)"
  (values :proceed))

(defmethod (1sys:proceed 0allocator-error 1:use-nil0) ()
  "Use a value of NIL"
  (values :use-nil))

(defmethod (1sys:proceed0 allocator-error 1:enable0) ()
  "Enable the allocator and continue"
  (values :enable))

(defmethod (1sys:proceed0 allocator-error 1:unlock) 0()
  "Unlock it and proceed"
  (values :unlock))

(defmethod (1sys:proceed0 allocator-error 1:local) 0()
  "Make local and return :LOCAL"
  (values :local))

(defmethod (1sys:proceed0 allocator-error 1:ignore) 0()
  "Try to proceed, trying to ignore the error"
  (values :ignore)
  )


(defmethod (1sys:proceed0 allocator-error 1:ignore-array0) ()
  "Continue, ignoring the offending raster"
  (values :ignore-array)
  )

(defmethod (1sys:proceed0 allocator-error 1:allocate-anyway0) ()
  "Allocate the raster as a local raster"
  (values :allocate-anyway))

(compile-flavor-methods allocator-error)


(defvar 1*dummy-raster*0 (make-array 0 :type 'art-fixnum))
(defvar 1*deallocated-raster*0 1"*deallocated*"0)
(defvar 1*dummy-sequence*0 0)
(defvar 1*default-screen-allocator-enable* t)
0(defvar 1*default-page-out-max-cost*0 1.0)

(defflavor 1allocated-raster0 ((page-status)
			     (name)
			     (raster)
			     (local-raster)
			     (allocated-local-raster)	;a raster we allocated
			     (initial-value :no-initial-value)
			     (lock-status)
			     (for-sheet)
			     (swap-cost-multiplier 1.0)
			     )
	   (si:property-list-mixin)
  (:conc-name "ALLOCATOR-")
  (:required-methods set-size-and-location )
  :readable-instance-variables 
  :writable-instance-variables 
  :initable-instance-variables )

(defmethod (1inform-sheet 0allocated-raster) ()
  (when for-sheet
    2;this is a bit of a hack, necessary to keep windows informed of changes
0    2;from local to remote and back.  When we change the raster from local to
    ;remote, their screen arrays can retain stale information
    ;about the raster we gave them.
0    (cond ((functionp for-sheet)
	   (funcall for-sheet self))
	  (t (let* ((sa (sheet-screen-array for-sheet))
		    (ba (when sa (si:array-indirect-pointer sa)))
		    )
	       (when (and sa (eq ba raster))
		 (send for-sheet :adjust-screen-array sa ba 0 0 0 0)
		 ))
	     ))))

(defmethod (1make-local-raster 0allocated-raster) ()
  2;find or create local storage 
0  (or allocated-local-raster
      (multiple-value-bind (w h)
	  (decode-raster-array raster)
	(progn (with-stack-list (dims h (tv:raster-width-for-bitblt w (array-type raster)))
		 (setf allocated-local-raster 
		       (allocate-temp-sheet-raster-and-header
			 dims
			 :initial-value (if (eq initial-value :no-initial-value)
					    0
					    initial-value)
			 :no-initial-value (eq initial-value :no-initial-value)
			 :displaced-to local-raster
			 :displaced-conformally (and (arrayp local-raster)
						     (= 2 (array-#-dims local-raster)))
			 :type (tv:array-type raster)))
	       allocated-local-raster)))))

(defmethod (1make-raster-permanent0 allocated-raster) ()
  (unless local-raster
    (make-local-raster self)
    (let ((perm allocated-local-raster))
      (without-interrupts
	(setq local-raster perm
	      allocated-local-raster nil))
      perm)))

(defmethod (1deallocate-local-raster0 allocated-raster) (&key preserve-bits)
  (when (and allocated-local-raster
	     (or (null preserve-bits)
		 local-raster))
    (deallocate-temp-sheet-raster-and-header allocated-local-raster)
    (setq allocated-local-raster nil))
  (or local-raster allocated-local-raster)
  )

(defmethod (1remote-p 0allocated-raster) ()
  (and raster
       (let ((ind (si:array-indirect-pointer raster)))
	 (and (neq allocated-local-raster ind)
	      (not (stringp ind))
	      (neq *dummy-raster* ind))
       )))

(defmethod (1allocated-raster-status0 allocated-raster) ()
  (let* ((r raster)
	 (ind (when r (si:array-indirect-pointer r))))
    (cond ((eq ind *deallocated-raster*) :deallocated)
	  ((eq ind *dummy-raster*) :never-allocated)
	  (lock-status :locked)
	  ((remote-p self) :remote)
	  (t :local))))

(defmethod (1allocator-state-string0 allocated-raster) ()
  (cl:ecase (allocated-raster-status self)
    (:deallocated 1"*deallocated*"0)
    (:never-allocated 1"*never allocated*"0)
    (:local "local")
    (:remote
      (let ((scr (raster-screen raster)))
	(if (and scr
		 (multiple-value-bind (info state allocator)
		     (find-info scr raster)
		   (when (and allocator
			      (eq state :remote)
			      (eq info self))
		     (remote-allocator-p allocator))))
	    "remote"
	    "wired")))
    (:wired "wired")
    (:locked "locked")))

(defflavor 1square-allocated-raster 
0	((left)
	 (top)
	 (right)
	 (bottom))
	(allocated-raster)
  (:conc-name "ALLOCATOR-")
  :readable-instance-variables 
  :writable-instance-variables 
  :initable-instance-variables )

2;functions for sorting
0(defun 1active-right-<0 (a b) (< (allocator-right a)(allocator-right b)))
(defun 1active-bottom-<0 (a b) (< (allocator-bottom a)(allocator-bottom b)))
(defsubst 1rectangles-overlap-p0 (left top right bottom r-l r-t r-r r-b)
  (NOT (OR ( LEFT R-R)
	   ( R-L RIGHT)
	   ( TOP R-B)
	   ( R-T BOTTOM))))

(defmethod (1:edges0 square-allocated-raster) ()
  (values left top right bottom))

(defmethod (1:length0 square-allocated-raster) () (* (- right left)(- bottom top)))
(defmethod (1allocator-length0 square-allocated-raster) () (* (- right left)(- bottom top)))

(defmethod (1:print-self0 square-allocated-raster) (stream slash prin)
  (ignore slash prin)
  (sys:printing-random-object (self stream :no-pointer)
    (multiple-value-bind (width height) (when raster (decode-raster-array raster))
      (format stream "~A ~A ~Dx~Dx~D @~D,~D ~A" name page-status
	      width height
	      (when raster (si:array-element-byte-size raster))
	      left top
	      (allocator-state-string self)
	      ))))

(defmethod (1set-size-and-location 0square-allocated-raster) (x y w h)
  (setf left x)
  (setf top y)
  (setf right (+ x w))
  (setf bottom (+ y h)))

(defflavor 1linear-allocated-raster
0	((index-offset)
	 (dummy-raster)
	 (length))
	(allocated-raster)
  (:conc-name "ALLOCATOR-")
  :readable-instance-variables 
  :writable-instance-variables 
  :initable-instance-variables )

(defmethod (1:length0 linear-allocated-raster) () length)

(defun 1allocator-origin-lessp0 (a b)
  (< (allocator-index-offset a)(allocator-index-offset b)))

(defmethod (1:print-self0 linear-allocated-raster) (stream slash prin)
  (ignore slash prin)
  (sys:printing-random-object (self stream :no-pointer)
    (multiple-value-bind (width height) (when raster (decode-raster-array raster))
      (format stream "~A ~A ~Dx~Dx~D @~D ~A" name page-status
	      width height
	      (when raster (si:array-element-byte-size raster))
	      index-offset
	      (allocator-state-string self)))))

(defmethod (1set-size-and-location 0linear-allocated-raster) (x y w h)
  (ignore y)
  (setf index-offset x)	
  (setf length (* w h))
  )

2;
; this flavor of window is the container for all the actual allocations.  It's
; a real window, but normally it will be placed in the margins of a screen somewhere.
; it's immediate inferiors are the allocated windows.  They're real windows too,
; but we frequently give out their bitmaps rather than the window itself.
;

0(defflavor1 allocator-mixin 
0	((inactive-rasters)2 0	2;spares
0	 (local-rasters)	2;rasters in local store (ie; regular memory)
0	 (remote-rasters)	2;rasters in remote store (ie; screen memory)
0	 (transaction-log)
	 (current-transaction)
	 (transaction-log-enabled)
	 (temp-remote-raster)   2;temporary raster used in shuffling
0	 2;transaction lock
0	 (allocator-lock)
	 (used-size)
	 (unused-size)
	 (locked-size)
	 (frozen-size)
	 (swap-cost-decay 0.95)
	 (work-units 0)
	 (allocator-tick 0)
	 )
	()
  (:required-instance-variables screen screen-array name)
  (:required-methods allocation-possible-p make-raster-info allocator-priority
		     adjust-width-for-type adjust-raster
		     )
  :settable-instance-variables
  :initable-instance-variables)

(defmethod (1square-allocator-p0 allocator-mixin) () nil)

(defmethod (1%fixed-cost0 allocator-mixin) (size) (ignore size) 0)

(defmethod (1tick-allocator-state0 allocator-mixin) (&optional (n 1))
  (incf allocator-tick n))

(defmethod (1allocator-space-available0 allocator-mixin)
	   (&key (units :pixel)
		 include-locked-space
		 (in-one-chunk t)
		 linear)
  (ignore in-one-chunk linear)
  (let* ((siz (- (+ used-size unused-size)
		 (if include-locked-space 0 locked-size)))
	 (default-type (array-type screen-array))
	 (default-size (cdr (assoc default-type array-bits-per-element)))
	 (unit-size (if (eq units :pixel)
			default-size
			(cdr (assoc units array-bits-per-element))))
	 )
    (floor (* siz default-size) unit-size)
    ))

(defmethod (1allocator-work-units0 allocator-mixin) ()
  work-units)

(defmethod (1allocator-tick0 allocator-mixin) ()
  allocator-tick)

(defmethod (1%adjust-swap-costs0 allocator-mixin) (&optional (multiplier swap-cost-decay))
  (incf allocator-tick)
  (loop for r in remote-rasters do
    (setf (allocator-swap-cost-multiplier r)
	  (* (max 0.0000001 ;avoid floating underflow
		  (allocator-swap-cost-multiplier r))
	     multiplier))))

(defmethod (1describe-allocator-state0 allocator-mixin) (stream)
  (let ((ma (tv:state self)))
    (format stream "~&used-size ~D  unused-size ~D  locked-size ~D  frozen-size ~D"
	    used-size unused-size locked-size frozen-size)
    (format stream "~&   remote rasters: ~{~A, ~}" ma))
  )

(defmethod (1signal-too-large-message0 allocator-mixin)
	   (stream w h type to-be-visible &optional (include-advice t))
  (multiple-value-bind (possible possible-if-unlocked max-w max-h adjusted-w )
      (allocation-possible-p self w h type to-be-visible)
    (if (eq possible t)
	(format stream
		"The allocator is confused about what is possible to allocate.~
 ~&Allocation of ~Dx~D should be possible, but caller thinks it isn't.~
 ~&Please report this error." w h)

	(format stream
		"~& Width ~D by Height ~D is too large for ~S to allocate." w h self)
	(when (or (eq possible :probably)
		  possible-if-unlocked)
	  (format stream "~& It is possible to allocate it if some rasters are unlocked"))
	(unless (eql adjusted-w w)
	  (format stream
		  "~& Adjusted for type and visibility requirements, the effective width of~
 ~&the request would be ~D pixels." adjusted-w))
	(if max-h
	    (format stream
		    "~& The largest request that can be satisfied is ~Dx~D pixels."
		    max-w max-h)
	    (format stream
		    "~& The largest request that can be satisfied is ~D pixels in any shape,~
 ~&which corresponds to a rectangle ~Dx~D pixels."
		    max-w adjusted-w (floor max-w adjusted-w)))

	(when include-advice
	  (format stream
		"~& If you wanted this allocaton to succeed by allocating a lisp array,~
~&use the option :ALLOW-EXCESS-SIZE T.  If you wanted this allocation to return NIL~
~&instead of causing an error, use :ERROR-P NIL"
			 ))
    )))

(defmethod (1signal-too-large-error0 allocator-mixin)
	   (w h
	      &rest args
	      &key
	      (error-p t)
	      (type (array-type screen-array))
	      (to-be-visible nil)
	      &allow-other-keys)
  (when error-p
    (let ((msg (with-output-to-string (error-string)
		 (signal-too-large-message self error-string w h type to-be-visible))))
      (signal-allocator-error (msg)
	(:proceed)
	(:allocate-anyway
	  (return-from signal-too-large-error
	    (cl:apply #'allocate-raster self w h
		      :allow-excess-size t
		      :error-p nil
		      args)))
	)))
  (values nil :too-large))

(defmacro-in-flavor (1record-transaction0 allocator-mixin) (&rest args)
  `(when transaction-log-enabled
     (push (list (time:fixnum-microsecond-time) ,@args) current-transaction)))


(defmethod (1verify-raster0 allocator-mixin) (raster &key error-fun repair)
  (process:with-lock (allocator-lock)
    (let ((info (find-info self raster))
	  (errs 0))
      (when (member info remote-rasters)
	(let ((local-copy (allocator-allocated-local-raster info)))
	  (when local-copy
	    (multiple-value-bind (w h)
		(decode-raster-array raster)
	      (with-bit-array
		raster :input
		#'(lambda (remote-raster remote-index remote-span)
		    (with-bit-array
		      local-copy :input
		      #'(lambda (local-raster local-index local-span)
			  (let ((local-raster local-raster)
				(remote-raster remote-raster)
				(adjust-bp (- (haulong (si:array-element-byte-size remote-raster))
					      (haulong (send screen :bits-per-pixel))))
				)
			    (declare (sys:array-register-1d local-raster remote-raster))
			    (loop named compare-loop
				  repeat h
				  as row from 0
				  as lidx from local-index by local-span
				  as ridx from remote-index by remote-span
				  do
			      (loop repeat w
				    as ri from ridx
				    as li from lidx
				    as rv = (aref remote-raster ri)
				    as lv = (aref local-raster li)
				    unless (eql rv lv)
				      do (incf errs)
					 (when error-fun
					   (cl:ecase (funcall error-fun
							      (lsh (- ri ridx) adjust-bp) row
							      lv rv)
					     (:exit (return-from compare-loop))
					     ((nil t))))))))
		      :width w
		      :height h)
		    )
		:width w
		:height h)
	      (when (and repair ( errs 0))
		(tv:sheet-is-prepared (screen)
		  2;this is moving bits from lisp to screen, which will wait
0		  2;until it is safe
0		  (record-transaction :bitblt-to w h)
		  (let ((tv:bitblt-unpacking-mask -1))
		    (send screen :%bitblt alu-seta w h
			  local-copy 0 0
			  raster 0 0
			  screen)))
		)))))
      errs
      )))

(defmethod (1verify-rasters0 allocator-mixin) (&key repair all (print-message t))
  (loop with aval = 0
	for i in remote-rasters
	when (or all (eq :read (allocator-page-status i)))
	  do
	    (let ((val (verify-raster self (allocator-raster i) :repair repair)))
	      (when ( val 0)
		(incf aval val)
		(when print-message
		  (format t "~&~D errors on ~S" val i))))
	    finally (return (if (zerop aval) nil aval))
  ))

(defmethod (1:print-self0 allocator-mixin) (stream slash prinl)
  (ignore prinl slash)
  (si:printing-random-object (self stream :typep :no-pointer)
    (format stream "~A for ~A"
	    (or name "")
	    (or (when screen (send screen :name)) ""))))

(defmethod (1:init0 allocator-mixin :after) (ignore)
  (initialize-state self))

(defmacro-in-flavor (1with-transaction0 allocator-mixin) ((&rest args) &body body)
  `(unwind-protect
       (progn
	 (when current-transaction
	   (let ((a current-transaction))
	     (setq current-transaction nil)
	     (push a transaction-log)))
	 (record-transaction ,@args)
	 ,@body)
     (record-transaction :end)
     (when current-transaction
       (let ((a current-transaction))
	 (setq current-transaction nil)
	 (push a transaction-log)))
     ))

(defmethod (1unconditionally-make-empty0 allocator-mixin) ()
  (loop for i in (copylist remote-rasters)
	do (make-local self i :unlock-all t :error-p nil)))
(defmethod (1:deexpose0 allocator-mixin) (&rest ignore)
  (unconditionally-make-empty self))


(defmethod (1reverse-transaction-log0 allocator-mixin) ()
  (when current-transaction
    (let ((a current-transaction))
      (setq current-transaction nil)
      (push a transaction-log)))
  (let ((log transaction-log))
    (setq transaction-log nil)
	
    (loop for i on log do
      (setf (car i) (nreverse (car i))))
    (nreverse log)
  ))

(defmethod (1:set-transaction-log-enabled0 allocator-mixin :after) (ignore)
  (setq transaction-log nil
	current-transaction nil))

(defmethod (1my-allocator-raster-p0 allocator-mixin) (a)
  (or (cl:find a remote-rasters :key #'allocator-raster)
      (cl:find a local-rasters :key #'allocator-raster)))

(defmethod (1reset 0allocator-mixin) ()
  (loop for i in (copylist local-rasters) do (deallocate-raster self (allocator-raster i)))
  (loop for i in (copylist remote-rasters) do (deallocate-raster self (allocator-raster i)))
  (setq local-rasters nil
	remote-rasters nil)
  (initialize-state self)
  )

(defmethod (1initialize-state0 allocator-mixin) ()
  2;we keep auxiliary data structures, which should be parallel the
0  2;information inherent in the remote-rasters list.  The lists are
  ;kept sorted
0  (setq allocator-lock (process:make-lock
			 (format nil "for ~A" self)
			 :recursive t))
  (setq transaction-log nil
	current-transaction nil
	inactive-rasters nil
	locked-size 0
	frozen-size 0
	used-size 0
	allocator-tick 0
	)
  (loop for i in remote-rasters
	as lock = (allocator-lock-status i)
	as sz = (send i :length)
	do (decf unused-size sz)
	   (incf used-size sz)
	   (when lock
	     (incf locked-size sz)
	     (when (member :freeze lock)
	       (incf frozen-size sz))))
  )

(defmethod (1state0 allocator-mixin) ()
  (values remote-rasters local-rasters ))

(defmethod (1change-lock-status0 allocator-mixin )(info new)
  (without-interrupts
    (incf allocator-tick)
    (let ((old (allocator-lock-status info)))
      (when (or new old)
	(let ((sz (send info :length)))
	  (cond ((and new old)
		 (if (member :freeze new)
		     (unless (member :freeze old)
		       (incf frozen-size sz))
		     (when (member :freeze old)
		       (decf frozen-size sz))))
		(new
		 (incf locked-size sz)
		 (when (member :freeze new)
		   (incf frozen-size sz)))
		(old
		 (decf locked-size sz)
		 (when (member :freeze old)
		   (decf frozen-size sz)))))
	(setf (allocator-lock-status info) new))
      )))

(defmethod (1adjust-sizes0 allocator-mixin) (info make-remote)
  (let ((sz (send info :length)))
    (when (allocator-lock-status info)
2      ;the rule is you adjust sizes when making local or remote, before locking.
0	(signal-allocator-error ("~A is Locked" info)
	  (:ignore)))
    (unless make-remote (setq sz (- sz)))
    (decf unused-size sz)
    (incf used-size sz)))

(defmethod (1add-to-local-info-database0 allocator-mixin) (info)
2  ;this method will probably be superceeded by clients of the mixin
0  (without-interrupts
    (setq remote-rasters (cl:delete info remote-rasters :count 1)
	  local-rasters (cons info local-rasters))
    (setf (allocator-page-status info) :local)
    (incf allocator-tick)
    (adjust-sizes self info nil)
    ))

(defmethod (1add-to-remote-info-database0 allocator-mixin) (info)
  2;this method will probably be superceeded by clients of the mixin
0  (%adjust-swap-costs self)
  (without-interrupts
    (setq local-rasters (cl:delete info local-rasters :count 1)
	  remote-rasters (cons info remote-rasters))
    (incf allocator-tick)
    (adjust-sizes self info t)
    ))

(defmethod (1find-info 0allocator-mixin) (raster-or-info &optional (error-p t))
  (cond ((arrayp raster-or-info)
	 (let ((r-val (cl:find raster-or-info remote-rasters :key #'allocator-raster)))
	   (when r-val (return-from find-info (values r-val :remote))))
	 (let ((l-val (cl:find raster-or-info local-rasters :key #'allocator-raster)))
	   (when l-val (return-from find-info (values l-val :local)))))
	(t (let ((r-val (cl:member raster-or-info remote-rasters)))
	     (when r-val (return-from find-info (values (first r-val) :remote))))
	   (let ((l-val (cl:member raster-or-info local-rasters)))
	     (when l-val (return-from find-info (values (first l-val) :local))))))
  (when error-p
    (signal-allocator-error ("Info object not found for ~S" raster-or-info)
      (:ignore))))

(defmethod (1remove-lock-reason0 allocator-mixin)
	   (raster-or-info reason
			   &key error-p unlock-all swap-cost)			    
  (let ((info (find-info self raster-or-info error-p)))
    (when swap-cost (setf (allocator-swap-cost-multiplier info) swap-cost))
    (change-lock-status self info
			(if unlock-all
			    nil
			    (remove reason (allocator-lock-status info))))))


(defmethod (1make-local 0allocator-mixin)
	   (raster-or-info &key
			   (discard nil discard-supplied-p)
			   unlock-reason (error-p t) unlock-all initial-value)
  2;coerce a remote raster into being local, and either copy its bits to
0  2;a local array or discard them, whatever is appropriate

0  (process:with-lock (allocator-lock)
    (multiple-value-bind (info status) (find-info self raster-or-info)

      (record-transaction 'make-local info discard)
      (incf allocator-tick)

      (when info
	(let ((discard (if discard-supplied-p
			   discard
			   (eq :never (send info :get :keep-bit-save-array)))))
	  (cond ((or unlock-all (eq discard :deallocate))
		 (change-lock-status self info nil))
		(unlock-reason
		 (let ((lock (allocator-lock-status info)))
		   (when (member unlock-reason lock)
		     (change-lock-status self info (remove unlock-reason lock))))))

	  (when (and error-p (allocator-lock-status info))
	    (signal-allocator-error
	      ("~A is still locked, with reason ~A"
	       raster-or-info
	       (allocator-lock-status info))
	      (:unlock (change-lock-status self info nil))
	      (:proceed)))


	  (cond ((null (allocator-lock-status info))

		 (let ((raster (allocator-raster info)))
		   (when (eq status :remote)
		     (cl:ecase (allocator-page-status info)
		       ((:read :initial)
						2;since we are are about to reclaim this space,
0						2;wait for remote activity to subside
0			(wait-remote-screen-idle screen)
			(when (fixp initial-value)
			  (setf (allocator-initial-value info)
				initial-value))
			(setq discard t)
			nil)
		       (:write			2;we need to save it
0			 (setf (allocator-page-status info) :read)
			(unless discard
			  (let ((local-bitm (make-local-raster info)))
			    (cond ((fixp initial-value)
				   (%set-raster-initial-value self local-bitm initial-value))
				  (t (record-transaction 'copy-to-lisp raster local-bitm)
				     (multiple-value-bind (w h)
					 (decode-raster-array local-bitm)
						2;bitblt in units of the local bitmap, not the source bitmap
0				       (tv:sheet-is-prepared (screen)
						2;this is movin0g2 bits from the screen to lisp, 
0						;2which will wait0 2until it is safe
0					 (incf work-units (1+ (lsh (* w h) -10)))
					 (send screen :%bitblt alu-seta w h
					       raster 0 0
					       local-bitm 0 0
					       screen))))))
	   
			  )))

		     (add-to-local-info-database self info))

		   (multiple-value-bind (rw rh)
		       (decode-raster-array raster)

		     (unless discard
		       (make-local-raster info))

		     (let ((local (allocator-allocated-local-raster info)))

		       (if local

			   (send screen :inferior-screen-array-adjusted
				 screen raster rw rh
				 local 0 0)

			   (send screen :inferior-screen-array-adjusted
				 screen raster
				 (raster-width-for-bitblt rw raster) rh
2						;use *dummy-raster* rather than *deallocated-raster*
						;so capture-raster will do the right thing when we
						;later make-remote again
0				 *dummy-raster* 0 0)))

		     (inform-sheet info))

		   (unless (eq status :remote)
		     (let ((local (allocator-allocated-local-raster info)))
		       (if local
			   (%set-raster-initial-value self local initial-value)
			   (when (fixp initial-value)
			     (setf (allocator-initial-value info) initial-value))
			   )))
		   )
		 t				2;for success
0		 )
		(t (values nil :locked))
		)))
      )))


(defmethod (1page-in-raster0 allocator-mixin) (raster &key (page-status :write) max-cost)
  (with-transaction ('page-in raster)
    (let ((rem (make-remote self raster
			    :page-status page-status
			    :max-cost max-cost
			    :error-p :local)))
      (when (and (member color:*explicit-page* '(:in t))
		 (eq rem :local))
	(page-in-raster-array raster))
      rem)))

(defmethod (1page-out-raster0 allocator-mixin) (raster)

  (with-transaction ('page-out raster)
     (let ((info (find-info self raster)))
       (when info (setf (allocator-swap-cost-multiplier info) 0)))
    ;(make-local raster)
    ))

(defmethod (1make-new-raster0 allocator-mixin) (raster)
  (let ((info (find-info self raster)))
    (multiple-value-bind (w h) (decode-raster-array raster)
      (let ((new (make-remote-raster self w h
				     nil
				     (array-type raster))))
	(send screen :inferior-screen-array-adjusted
	      screen
	      new w h
	      (si:array-indirect-pointer raster)
	      (si:array-index-offset raster)
	      0)
	(setf (allocator-raster info) new)
	new))))


(defmethod (1check-page-status0 allocator-mixin) (page-status)
  (cl:case page-status
    ((:read :write) page-status)
    (otherwise (signal-allocator-error
		 ("Page status must be :READ or:WRITE, is ~S" page-status)
		 (:ignore :write)))))

(defmethod (1capture-raster0 allocator-mixin)
	   (raster &key x y victims
		   make-local
		   (make-remote t)
		   relocate-victims
		   ok-to-displace
		   max-cost
		   error-p
		   lock-reason
		   (page-status :write page-status-supplied)
		   (initial-value)
		   (from-allocator (my-allocator-raster-p screen raster))
		   to-be-visible)
  (record-transaction 'capture raster x y)
  (process::with-lock (allocator-lock)
    (let ((old-allocator from-allocator))
      (unless (eq old-allocator self)
	(process::with-lock ((send old-allocator :allocator-lock))
	  (let ((info (find-info old-allocator raster))
		(atype (array-type raster))
		)

	    (when (member :freeze (allocator-lock-status info))
	      (signal-allocator-error ( "~A is frozen" raster)
		(:ignore)))

	    (multiple-value-bind (w h) (decode-raster-array raster)
	      (unless (and x y)
		(multiple-value (x y nil victims)
		  (find-placement self w h
				  :ok-to-displace ok-to-displace
				  :displace nil
				  :relocate-victims nil
				  :to-be-visible to-be-visible
				  :error-p nil
				  :max-cost max-cost
				  :for-lock (or lock-reason (allocator-lock-status info))
				  :type atype)))
	      (when error-p
		(unless (and x y)			   
		  (signal-allocator-error ("can't find new placement for ~A" raster)
		    (:ignore)
		    )))

	      (when (and x y)
						2;allocate a new raster, forcing the use of RASTER as the destination
0						2;and COPY-OF-RASTER as the source.
0		(without-aborts ("moving raster")
		  (let* ((copy-of-raster (make-new-raster old-allocator raster))
			 (ar (unless (or (fixp initial-value)
					 (eq (si:array-indirect-pointer copy-of-raster)
					     *dummy-raster*))
			       2;capture-raster serves two masters, copying a remote raster
0			       2;from one allocator to the other and copying a local raster
0			       2;to a remote raster on another allocator.  In this latter case,
0			       2;the "local" bit array may not exist.
0			       copy-of-raster)))
		    (allocate-raster
		      self w h
		      :type atype
		      :make-local make-local
		      :make-remote make-remote
		      :relocate-victims relocate-victims
		      :to-be-visible to-be-visible
		      :raster raster
		      :array ar
		      :allocated-array ar
		      :page-status (if page-status-supplied
				       page-status
				       (let ((old-status (allocator-page-status info)))
					 (if (eql old-status :local) :write old-status)))
		      :x x :y y :victims victims
		      :initial-value initial-value
		      :lock-reason lock-reason)

		    (let ((new-info (find-info self raster)))

2						;swap the backing store for the new and old

0		      (cl:setf (allocator-swap-cost-multiplier new-info)
			       (allocator-swap-cost-multiplier info))

		      (cl:shiftf (allocator-local-raster new-info)
			      (allocator-local-raster info)
			      nil)

		      (cl:shiftf (allocator-allocated-local-raster new-info)
				 (allocator-allocated-local-raster info)
				 nil)

		      (cl:shiftf (allocator-for-sheet new-info)
				 (allocator-for-sheet info)
				 nil)

		      (cl:shiftf (allocator-initial-value new-info)
				 (allocator-initial-value info)
				 nil)

		      (cl:shiftf (allocator-name new-info)
				 (allocator-name info)
				 nil)
		      (cl:shiftf (send new-info :property-list)
				 (send info :property-list)
				 nil)

		      (let ((lock (allocator-lock-status info)))
			(when lock
			  (change-lock-status
			    self new-info 
			    (append (allocator-lock-status new-info) lock))
			  )
			)
2		      ;finally, deallocate the old

0		      (deallocate-raster old-allocator copy-of-raster :preserve-bits nil)

						2;and inform any windows that need to know
0		      (inform-sheet new-info)
		      t
		      ))))

	      ))))))
  )

(defmethod (1bitblt-shuffle 0allocator-mixin) (from-index to info)
  (let ((to-index (si:array-index-offset to)))
    (unless (= from-index to-index)
      (unless temp-remote-raster
	(setq temp-remote-raster (make-remote-raster self 1 1)))
      (multiple-value-bind (w h)(decode-raster-array to)
	2;make a copy of the remote raster
0	(send screen :inferior-screen-array-adjusted
	      screen temp-remote-raster w h
	      screen-array from-index 0)
	(let ((backwards (if ( from-index to-index) 1 -1)))
	  (record-transaction 'shuffle to from-index to-index)
	  (sheet-is-prepared (screen)
	    (let ((tv:bitblt-unpacking-mask -1))
	      (incf work-units (1+ (lsh (* w h) -16)))
	      (send screen :%bitblt alu-seta
		    (* w backwards)(* h backwards)
		    temp-remote-raster 0 0
		    to 0 0
		    screen)))
	  2;since we are about to reclaim the "FROM" space, wait for the copy
0	  2;to finish.
0	  (wait-remote-screen-idle screen)
	  (inform-sheet info)
	  )))))

(defvar 1*allow-movement*0 t)

(defmethod (1make-local-or-relocate0 allocator-mixin)
	   (victims relocate-to allow-movement-among-allocators &optional max-cost)

  (when victims
    (setq allow-movement-among-allocators
	  (and allow-movement-among-allocators
	       relocate-to))
    (loop with total-cost = (when max-cost
			      (// max-cost
				  (loop for i in victims
					sum (allocator-length i))))
	  for i in victims
	  as raster = (allocator-raster i)
	  do
      (cond ((and allow-movement-among-allocators
		  (multiple-value-bind (w h) (decode-raster-array raster)
		    (let* ((type (array-type raster))
			   (max-cost (when max-cost (* total-cost (allocator-length i))))
			   (destination (if (cdr relocate-to)	;multiple-choices
					    (loop with best-v and best = self
						  for alloc in relocate-to
						  when (neq alloc self)
						    do (multiple-value-bind (x y cost)
							   (find-placement
							     alloc w h
							     :type type
							     :allow-movement-among-allocators nil
							     :displace nil
							     :max-cost max-cost
							     :ok-to-displace t)
							 (when (and x y
								    (or (null best-v)
									(< cost best-v)))
							   (setq best-v cost
								 best alloc)))
						  finally (return best))
					    (first relocate-to))))
		      (when (neq destination self)
			(capture-raster
			  destination
			  raster
			  :from-allocator self
			  :max-cost max-cost
			  :ok-to-displace (when max-cost t)
			  :error-p nil)
			)))))
	    (t (make-local self i))))))

(defmethod (1%set-raster-initial-value0 allocator-mixin)
	   (raster initial-value &optional w h)
  (when initial-value
    (unless (eq initial-value :no-initial-value)
      (unless (and w h) (multiple-value (w h) (decode-raster-array raster)))
      (record-transaction 'initialize initial-value)
      (tv:sheet-is-prepared (screen)
	(i-p:%draw-rectangle
	  screen screen raster 0 0 w h
	  tv:alu-seta
	  (color:effective-write-mask initial-value nil (si:array-element-byte-size raster))
	  -1
	  )))))

(defmethod (1do-remote-bookkeeping0 allocator-mixin)
	   (info page-status lock-reason swap-cost initial-value)
  (setf (allocator-swap-cost-multiplier info) swap-cost)
  (when page-status
    (setf (allocator-page-status info)
	  (check-page-status self page-status)))
  (when lock-reason
    (change-lock-status self info
			(cons lock-reason (allocator-lock-status info))))
  (when (and (eq page-status :write)
	     (null (allocator-local-raster info)))
    2;when we expect to write it out again, and the user didn't
0    2;supply an array, deallocate the temporary
0    (deallocate-local-raster info))
  (%set-raster-initial-value self (allocator-raster info) initial-value)
  )

(defmethod (1make-remote0 allocator-mixin)
	   (raster-or-info &key x y victims
			   (page-status :write)
			   (lock-reason)
			   (to-be-visible)
			   (allow-movement-among-allocators *allow-movement*)
			   (max-cost)
			   (error-p (null max-cost))
			   (ok-to-displace t)
			   (relocate-victims)
			   (swap-cost 1.0)
			   initial-value
			   )
  (ignore allow-movement-among-allocators)
  (incf allocator-tick)

  (when (eql page-status :read)
    (setq swap-cost (* swap-cost 0.5)))

  (process:with-lock (allocator-lock)

    (multiple-value-bind (info status) (find-info self raster-or-info t)
      (when info
	(let* ((freezing-already-remote
		 (when (eq status :remote)
		   (let ((lock (allocator-lock-status info)))
		     (cond ((or (null lock-reason)
				(member lock-reason lock))
2						;nothing to do
0			    nil)
			   ((neq lock-reason :freeze)
						;2just relocking in place
0			    (change-lock-status self info
						(cons lock-reason lock))
			    nil)
			   (t t))))))

	  (cond ((neq status :remote)
		 (block 1info-block
0		   (record-transaction 'make-remote info page-status)
		   (let* ((remote (allocator-raster info))
			  (remote-type (array-type remote)))
		     (multiple-value-bind (rw rh) (decode-raster-array remote)
		       (let ((adjusted-width
			       (adjust-width-for-type
				 self rw
				 remote-type
				 to-be-visible)))
						2;find a place for it if it needs one
0			 (if (and x y)
			     (make-local-or-relocate
			       self
			       victims
			       relocate-victims
			       allow-movement-among-allocators
			       (or max-cost *default-page-out-max-cost*))
			     (multiple-value (x y)
			       (find-placement self rw rh
					       :allow-movement-among-allocators
					        allow-movement-among-allocators
					       :displace t
					       :ok-to-displace ok-to-displace
					       :type remote-type
					       :relocate-victims relocate-victims
					       :shuffle t
					       :freezing-already-remote freezing-already-remote
					       :max-cost max-cost
					       :for-lock lock-reason))
			     )

			 (unless (and x y)

			   (when freezing-already-remote
2						;leave it where it is
0			     (change-lock-status
			       self info
			       (cons lock-reason (allocator-lock-status info)))
			     (return-from info-block t)
			     )

			   (when (and error-p (neq error-p :local))
			     (signal-allocator-error
			       ("Placement failed, making ~A remote" remote)
			       (:proceed)
			       (:Local (setq error-p :local))
			       ))

			   (cond ((eq error-p :local)
				  (make-local self info)
				  (return-from info-block :local))
				 (t (return-from info-block (values nil :no-placement)))))

			 (when freezing-already-remote
			   (setq freezing-already-remote
				 (si:array-index-offset (allocator-raster info))))

			 (set-size-and-location
			   info x y
			   adjusted-width
			   rh)

2						;adjust the remote array to point to out screen array
0			 (multiple-value-bind (adjusted-offset rem)
			     (floor (* x (si:array-element-byte-size screen-array))
				    (si:array-element-byte-size remote))
			   (unless (zerop rem)
2						;if this error ever occurs, we have allocated a raster which is not
						;aligned properly with memory, for example an art-fixnum that isn't
						;aligned 0 mod 4 in an art-8b window.  This shouldn't happen, because
						;all the allocations are multiples of 32 bits.  If it ever occurs, we
						;need to add smarts to the allocator to coerce 0 mod n
0			     (signal-allocator-error
			       ("offset remainder should be zero, is ~A" rem)))

			   (adjust-raster self info x y rw rh adjusted-width adjusted-offset)))

		       (let ((local (allocator-allocated-local-raster info)))
			 (tv:sheet-is-prepared (screen)
			   (cond (freezing-already-remote
				  (bitblt-shuffle self freezing-already-remote remote info)
				  )
				 (local
				  (unless (fixp initial-value)
				    (record-transaction 'copy-from-lisp local remote)
						2;this will wait until the screen is idle
0				    (let ((tv:bitblt-unpacking-mask -1))
				      (incf work-units (1+ (lsh (* rw rh) -10)))
				      (send screen :%bitblt
					    alu-seta rw rh local 0 0 remote 0 0 screen)))
				  )
				 (t (when (eq page-status :read)
				      (setq swap-cost 0))
				    (unless initial-value
				      (setq initial-value
					    (allocator-initial-value info)))
				    ))
			   ))
						2;insert the info into our database of edges
0		       (when freezing-already-remote
			 (add-to-local-info-database self info)
			 )
		       (add-to-remote-info-database self info)
						;now remote.  Do bookeeeping
		       (do-remote-bookkeeping self
					      info
					      page-status
					      lock-reason
					      swap-cost
					      initial-value)
		       (inform-sheet info)
		       )
		     )
		   t				2;for success
0		   ))
		(info				;was already remote
		 (do-remote-bookkeeping self
					info
					(if (eq page-status :read) nil page-status)
					lock-reason swap-cost
					initial-value)

		 t))
	  )))))

(defmethod (1deallocate-raster 0allocator-mixin)
	   (raster-or-info &key
			   (preserve-bits nil preserve-bits-supplied-p)
			   (error-p t))
  2;deallocate a raster, and return the lisp backup store to the caller
  ;if we don't own it
0  (with-transaction ('deallocate-raster raster-or-info)
    (make-local self raster-or-info :discard (if preserve-bits nil :deallocate)
		:error-p error-p)
    (let* ((info (if (arrayp raster-or-info)
		     (cl:find raster-or-info local-rasters  :key #'allocator-raster)
		     (first (cl:member raster-or-info local-rasters)))))
      (cond (info
	     (unless preserve-bits-supplied-p
	       (setq preserve-bits (eq t (send info :get :keep-bit-save-array))))
	     (let ((his-raster (deallocate-local-raster info :preserve-bits preserve-bits))
		   (raster (allocator-raster info)))
2						;make-local made it local if it was remote
0	       (without-interrupts
		 (setq local-rasters (cl:delete info local-rasters :count 1))
		 (when raster
		   (if his-raster
		       (multiple-value-bind (rw rh)
			   (decode-raster-array his-raster)
			 (send screen :inferior-screen-array-adjusted
			       screen raster rw rh
			       his-raster
			       0 0))
		       (setf (si:array-indirect-pointer raster)
			     *deallocated-raster*))
		   (push info inactive-rasters)))
	       his-raster
	       ))
	    (t (when error-p
		 (signal-allocator-error ("~A is not my raster" raster-or-info)
		   (:proceed)))
	       (values nil :not-my-raster))
	    )))
  )

(defmethod (1make-remote-raster0 allocator-mixin)
	   (w h &optional
	      (displaced-to *dummy-raster*)
	      (type (array-type screen-array))
	      (raster)
	      )
  (let ((new (or raster
		 (send screen :create-screen-array
		       w h (or displaced-to *dummy-raster*) type))))
    (setf (sheet-raster-sheet new) screen)
    new
    ))

(defmethod (1allocate-raster0 allocator-mixin)
	   (w h &rest args
	      &key
	      (initial-value :no-initial-value)
	      (no-initial-value (eq initial-value :no-initial-value))
	      (name
		(format nil "Raster ~D"
			(incf *dummy-sequence*)))
	      (type (array-type screen-array))
	      (array)
	      (page-status :write)
	      (make-remote t)
	      (make-local (not make-remote))
	      (raster)
	      x y victims
	      (to-be-visible nil)
	      (lock-reason)
	      (keep-bit-save-array)
	      (allow-excess-size)
	      (max-cost )
	      (error-p (null max-cost))
	      (relocate-victims)
	      (ok-to-displace t)
	      (allow-movement-among-allocators *allow-movement*)
	      (swap-cost 1.0)
	      (for-sheet)
	      allocated-array ;for internal use only
	      )
  (cl:case keep-bit-save-array
    ((t nil :never))
    (otherwise (signal-allocator-error 
		 (":KEEP-BIT-SAVE-ARRAY ~S is undefined.  Use T NIL or :NEVER"
		  keep-bit-save-array)
		 (:use-nil (setq keep-bit-save-array nil)))))
    
  (when (and array
	   (typep array 'color:color-raster-array)
	   (let ((ind (si:array-indirect-pointer array)))
	     (and ind
		  (or (stringp ind)
		      (zerop (array-length ind))))))
    (signal-allocator-error ("passing garbage as :array: ~s" array)
      (:proceed (return-from allocate-raster (values nil :array-is-junk)))
      (:ignore-array (setq array nil))
      ))
      
  (if (and array (my-allocator-raster-p self array))

      (progn (when error-p
	       (signal-allocator-error ("Array ~A is already an allocated array" array)))
	     (values nil :array-already-allocated))

      (with-transaction ('allocate-raster w h)
	(cond ((or allow-excess-size
		   (allocation-possible-p self w h type to-be-visible))
	       (let ((info (or (pop inactive-rasters)
			       (make-raster-info self))))
		 (setf (allocator-name info) name)
		 (setf (allocator-for-sheet info) for-sheet)
		 (setf (allocator-page-status info) (check-page-status self page-status))
		 (setf (allocator-initial-value info)
		       (if no-initial-value :no-initial-value initial-value))

		 (setf (allocator-raster info)
		       (make-remote-raster self w h 
					   *dummy-raster*
					   type
					   raster))


		 (setf (allocator-local-raster info) array)
		 (setf (allocator-allocated-local-raster info) allocated-array)
		 (setf (send info :property-list) nil)
		 2;new strategy; defer creating the array until strictly necessary
0		 (setf (send info :get :keep-bit-save-array)
		       (and (null array)
			     keep-bit-save-array))
		 #||
		 ;old strategy, make it immediately
		 (when  (and keep-bit-save-array (null array))
		   2;when the user wants to keep the bit array permanantly
0		   2;(even if the raster is killed or deallocated)
0		   2;create it now.
0		   (setq array (make-raster-permanent info)))||#

		 (when array
2		   ;when the user supplied an array, make our indirect to it
0		   (make-local-raster info))

		 (push info local-rasters)

		 (cond (make-remote (make-remote self info :x x :y y
						 :victims victims
						 :swap-cost swap-cost
						 :allow-movement-among-allocators
						   allow-movement-among-allocators
						 :relocate-victims relocate-victims
						 :lock-reason lock-reason
						 :page-status page-status
						 :error-p (if allow-excess-size error-p nil)
						 :ok-to-displace ok-to-displace
						 :to-be-visible to-be-visible))
		       (make-local (make-local self info :error-p error-p)))
      
		 (values (allocator-raster info) info)
		 ))
	      (t (cl:apply #'signal-too-large-error self w h args))
	       ))))


(defmethod (1locked-rasters 0allocator-mixin) ()
  (loop for i in remote-rasters
	when (allocator-lock-status i)
	  collect i))

(defmethod (1capture-locked-rasters 0allocator-mixin) (other-allocator)
  (loop with progress
	for i in (sort (locked-rasters other-allocator)
		       #'(lambda (a b) (> (send a :length)(send b :length))))
	unless (member :freeze (allocator-lock-status i))
	  when (capture-raster self
			       (allocator-raster i)
			       :ok-to-displace t
			       :error-p nil)
	    do (setq progress t)
	finally (return progress)
		))

(defmethod (1remote-allocator-p0 allocator-mixin) () t)

2;;
;; This version uses a real window, which lives in the margins of the screen
;;
0(defflavor 1rectangle-allocator
0	((right-borders)  2;active rasters sorted by right border
0	 (bottom-borders) 2;active rasters sorted by bottom border
0	 (must-refresh t)
	 (screen)
	 (screen-array)
	 (name)
	 (width)
	 (height)
	 )
      (allocator-mixin)
  :settable-instance-variables
  :initable-instance-variables)

(defmethod (1allocator-priority0 rectangle-allocator) () 0.5)

(defwhopper (1allocator-space-available0 rectangle-allocator)
	    (&rest args &key linear &allow-other-keys)
  (let ((val (lexpr-continue-whopper args)))
    (if linear (min width val) val)))

(defmethod (1square-allocator-p0 rectangle-allocator) () (// width (float height)))

(defmethod (1picture0 rectangle-allocator)
	   (window &key item (clear t) (alu tv:alu-seta) verify
		   (w 1.0)
		   (h 1.0)
		   (left 0.0)
		   (top 0.0))
  (multiple-value-bind (ww hh)
      (send window :inside-size)
    (setq w (round (* w ww))
	  h (round (* h hh))
	  left (round (* left ww))
	  top (round (* top hh))))

  (let ((x-scale (// w (float tv:width)))
	(y-scale (// h (float tv:height))))
      (when clear
	(send window :draw-rectangle w h left top :erase)
	(send window :draw-1-bit-raster w h tv:hes-gray 0 0 left top))
      (send window :draw-lines tv:alu-seta
	    left top
	    (+ left w -1) top
	    (+ left w -1) (+ top h -1)
	    left (+ top h -1)
	    left top)
	

      (loop for i in remote-rasters
	    as name = (allocator-name i)
	    as swap = (allocator-swap-cost-multiplier i)
	    when (or (null item)
		     (eq item i)
		     (and (listp item)(member i item)))
	      do
		(multiple-value-bind (r-left r-top r-right r-bottom)
		    (send i :edges)
		  (let ((al (+ left (floor (* r-left x-scale))))
			(ar (+ left (floor (* r-right x-scale))))
			(at (+ top (floor (* r-top y-scale))))
			(ab (+ top (floor (* r-bottom y-scale)))))
		    (when clear
		      (if (allocator-lock-status i)
			  (send window :draw-1-bit-raster (- ar al)(- ab at)
				tv:5.5%-gray 0 0
				al at)
			  (send window :draw-rectangle (- ar al)(- ab at) al at tv:alu-setz))

		      (let ((id (with-output-to-string (id)
				  (when name (format id "~A" name))
				  (when swap (format id " ~2f" swap)))))
			(when id (send window :display-x-y-centered-string
				       id al at ar ab)))
		     

		      (send window :send-if-handles
			    :primitive-item
			    :active i al at ar ab))
		    (send window :draw-lines alu
			  al at
			  ar at
			  ar ab
			  al ab
			  al at)
		    (when verify
		      (verify-raster
			self
			(allocator-raster i)
			:error-fun
			#'(lambda (x y sb is)
			    (ignore sb is)
			    (send window :draw-point
				  (floor (* (+ r-left x) x-scale))
				  (floor (* (+ r-top y) y-scale)))
			    nil)))

		    ))
		finally
		  (setf (sheet-restored-bits-p window) t)
		)))

2;required methods
0(defmethod (1adjust-width-for-type 0rectangle-allocator) (awidth type to-be-visible)
  2;just convert the width to our byte size
0  (ignore to-be-visible)
  (ceiling (* awidth (cdr (assoc type array-bits-per-element)))
	   (send screen :bits-per-pixel)))

(defmethod (1allocation-possible-p0 rectangle-allocator)
	   (w h type to-be-visible)
  (declare (values possible possible-if-unlocked max-width max-height adjusted-width ))
  (ignore to-be-visible)
  (let ((w (adjust-width-for-type self w type to-be-visible))
	(possible-unlocked (and ( w width) ( h height)))
	)
    (or (and possible-unlocked
	     (if (> locked-size 0)
		 (when ( (* w h) (- (* width height) locked-size)) :probably)
		 t)
	     )
	(values nil possible-unlocked width height w ))))

(defmethod (1make-raster-info0 rectangle-allocator) (&rest args)
  (cl:apply #'make-instance 'square-allocated-raster args))

(defmethod (1adjust-raster0 rectangle-allocator)
	   (info x y rw rh adjusted-width adjusted-offset)
  (ignore x adjusted-width)
  (send screen :inferior-screen-array-adjusted
	screen (allocator-raster info)
	rw rh
	screen-array adjusted-offset y))


(defwhopper (1initialize-state0 rectangle-allocator) ()
  (multiple-value (width height)(decode-raster-array screen-array))
  (setq unused-size (* width height))
  (continue-whopper)
  (let ((initial-raster (make-raster-info self
					  :left 0 :top 0 :right 0 :bottom 0
					  :lock-status '(:first :freeze)
					  :name "initial-raster")))
    (setq inactive-rasters nil)
    (setq right-borders (sort `(,initial-raster ,@(copylist remote-rasters))
			      #'active-right-<))
    (setq bottom-borders (sort `(,initial-raster ,@(copylist remote-rasters))
			       #'active-bottom-<))
    )
  )

(defmethod (1add-to-local-info-database0 rectangle-allocator) (info)
  (without-interrupts
    (setq right-borders (cl:delete info right-borders :count 1)
	  bottom-borders (cl:delete info bottom-borders :count 1)
	  remote-rasters (cl:delete info remote-rasters :count 1)
	  local-rasters (cons info local-rasters))
    (adjust-sizes self info nil)
    (setf (allocator-page-status info) :local)
    (incf allocator-tick)
    ))

(defmethod (1add-to-remote-info-database0 rectangle-allocator) (info)

  (loop with left = (allocator-left info)
	and top = (allocator-top info)
	and right = (allocator-right info)
	and bottom = (allocator-bottom info)
	for i in remote-rasters
	do
    (cond ((eq i info)
	   (signal-allocator-error ("~A is already remote" info)
	     (:ignore (return-from add-to-remote-info-database nil))))
	  ((rectangles-overlap-p left top right bottom
				 (allocator-left i)
				 (allocator-top i)
				 (allocator-right i)
				 (allocator-bottom i))
	   (signal-allocator-error ("~A overlaps ~A" info i)
	     ))))

  (%adjust-swap-costs self)

  (without-interrupts
    (setq local-rasters (cl:delete info local-rasters :count 1)
	  remote-rasters (cons info remote-rasters))
    (incf allocator-tick)
    (adjust-sizes self info t)

    (loop with bottom = (allocator-bottom info)
	  as pl = nil then l
	  as l on bottom-borders
	  as lp = (first l)
	  as lbottom = (allocator-bottom lp)
	  when ( bottom lbottom)
	    do (setf (first l) info)
	       (setf (cdr l) (cons lp (cdr l)))
	       (return nil)
	  finally (setf (cdr pl) (cons info nil)))

    (loop with right = (allocator-right info)
	  as pb = nil then border
	  for border on right-borders
	  as b = (first border)
	  when ( right (allocator-right b))
	    do (setf (first border) info)
	       (setf (cdr border) (cons b (cdr border)))
	       (return nil)
	  finally (setf (cdr pb) (cons info nil)))))

(defmethod (1find-placement0 rectangle-allocator)
	   (w h &key
	      (ok-to-displace t)
	      (displace)
	      (for-lock)
	      (shuffle t)
	      (type (array-type screen-array))
	      (initial-best-score)
	      (error-p nil)
	      (relocate-victims)
	      (allow-movement-among-allocators *allow-movement*)
	      (freezing-already-remote)
	      (to-be-visible)
	      (max-cost))

  (ignore for-lock shuffle)
  (record-transaction :find-placement w h)

  2;
  ;this is the meat of the difference between an allocator window and a simple
  ;linear allocator.  This hair allocates rectangles from a pre-existing square.
0  2;

0  (unless (cdr (assoc type array-bits-per-element))
    (signal-allocator-error ("~S isn't a valid array type" type)))

  (let* ((w (adjust-width-for-type self w type to-be-visible))
	 (len (* w h))
	 (max-allocator-cost (when max-cost (* len max-cost)))
	 )
  (when (and (20 w width)(20 h height)
	     (if ok-to-displace
		 ( len (- (+ unused-size used-size) locked-size))
		 ( len unused-size))
	     (not freezing-already-remote))

    (let* ((max-x-placement (- width w))
	   (max-y-placement (- height h))
	   (n-places (length remote-rasters))
	   (base-score
	     2;this is based on some gross empiricism along the following lines;
0	     2;net page in/out cost is about 32 usec/pixel.  Allocation time for
0	     2;a bad case with 60 or so allocations is 0.5 second, and the algorithm
0	     2;is 0o2N^3, so the "cost" of doing an allocation is very roughly (n^3)/16
0	     2;the net effect of this penalty is to prefer to put as few, large things
	     ;as possible in the margin allocator
0	     (lsh (* n-places n-places n-places) -4))
	   possible-x possible-y
	   best-victims
	   (best-score (when initial-best-score
			 (+ base-score initial-best-score 0)))
	   (score base-score)
	   victims
	   (word-alignment-mask (max 0 (- (raster-width-for-bitblt
					    1
					    (array-type screen-array))
					  (raster-width-for-bitblt 1 type))))
	   )
      (macrolet ((word-align (a)
		   `(cl:logandc1 word-alignment-mask (+ word-alignment-mask ,a))))
      (block find
	(labels ((1overlap-p0 (r left top)
		   (unless (cl:member r best-victims)
		     (multiple-value-bind (r-l r-t r-r r-b) (send r :edges)
		       (rectangles-overlap-p left top (+ left w)(+ top h)
					     r-l r-t r-r r-b))))

		 (1sum-obstacles0 (r left top)
		     (multiple-value-bind (r-l r-t r-r r-b) (send r :edges)
		       (when (rectangles-overlap-p left top (+ left w)(+ top h)
						   r-l r-t r-r r-b)
			 (incf score (* (allocator-swap-cost-multiplier r)
					(- r-r r-l)(- r-b r-t)))

2			 ;return non-nil if we hit a locked guy or a too costly guy
0			 (cond ((or (allocator-lock-status r)2 ;Include all, not
0				 2;just frozen, until there is a reasonable shuffler
0				 (and best-score ( score best-score))
				 (and max-allocator-cost
				      (> score max-allocator-cost))
				 )
				(setq score base-score victims nil)
				t)
			       (t (push r victims)
				  nil))
			 )))

		 (1least-obstacles0 (left top)
		   (when (and (or (null victims)
				  2;either no victims, or no locked victim.  Include all, not
0				  2;just frozen, until there is a reasonable shuffler
0				  (null (allocator-lock-status (first victims))))
			      (or (null best-score)(< score best-score))
			      (or (null max-allocator-cost)
				  (< score max-allocator-cost))
			      )
		     (setq possible-x left
			   possible-y top
			   best-score score
			   best-victims victims))
		   (setq score base-score
			 victims nil))

		 (1find-simple-placement0 (test-fn possible-fn)
2						;look for a simple placement
0		   (loop for rectangles on  bottom-borders
			 as rectangle = (first rectangles)
			 as old-top = -1 then new-top
			 as new-top = (allocator-bottom rectangle)
			 while ( new-top max-y-placement)
			 unless (eql old-top new-top)
			 do
		     (loop for new-left-o in right-borders
			   as old-left = -1 then new-left
			   as new-left = (word-align (allocator-right new-left-o))
			   while ( new-left max-x-placement)
			   unless (eql old-left new-left)
			   when (and (loop for r in (cdr rectangles)
					   when (funcall test-fn r new-left new-top)
					     return nil
					   finally (return t))
				     (funcall possible-fn new-left new-top))
			     do
			       (when displace
				 (make-local-or-relocate
				   self
				   best-victims
				   relocate-victims
				   allow-movement-among-allocators
				   (or max-cost *default-page-out-max-cost*))
				 (setq best-victims nil))
			       (record-transaction
				 :found 
				 new-left new-top best-score
				 best-victims allocator-tick)
			       (return-from find
				 (values new-left new-top best-score
					 best-victims allocator-tick))
			       )
		     )))

2	  ;first look for a simple placement, which won't disturb anything
0	  (find-simple-placement #'overlap-p #'true)

2	  ;then look for the best placement, measured by the number of bits
	  ;to be removed

0	  (when ok-to-displace
	    (find-simple-placement #'sum-obstacles #'least-obstacles)
	    (when (and (null possible-x)(null initial-best-score))
	      (when error-p
		(signal-allocator-error ("no simple placement found")
		  (:proceed)))
	      )
	    (when displace
	      (loop for i in best-victims do
		(make-local self i)))
	    (record-transaction :found possible-x possible-y
				best-score best-victims allocator-tick)
	    (values possible-x possible-y best-score best-victims allocator-tick))
	  )))
	))))

2;
;this version uses an arbitrary chunk of memory
;
0(defflavor 1screen-memory-allocator
0	((screen)
	 (screen-array)
	 (sorted-remote-rasters)
	 (name))
      (allocator-mixin)
  :settable-instance-variables
  :initable-instance-variables)

(defmethod (1allocator-priority0 screen-memory-allocator) () 1.0)

(defmethod (1picture0 screen-memory-allocator)
	   (window &key item (clear t) (alu tv:alu-seta) verify
		   (w 1.0)
		   (h 1.0)
		   (left 0.0)
		   (top 0.0))
  (multiple-value-bind (ww hh)
      (send window :inside-size)
    (setq w (round (* w ww))
	  h (round (* h hh))
	  left (round (* left ww))
	  top (round (* top hh))))

  (let ((scale (// (* w h) (float (array-length screen-array) ))))
      (when clear
	(send window :draw-rectangle w h left top :erase)
	(send window :draw-1-bit-raster w h tv:hes-gray 0 0 left top ))
      (send window :draw-lines tv:alu-seta
	    left top
	    (+ left w -1) top
	    (+ left w -1) (+ top h -1)
	    left (+ top h -1)
	    left top)
      (loop for i in remote-rasters
	    as idx = (allocator-index-offset i)
	    as len = (allocator-length i)
	    as name = (allocator-name i)
	    as swap = (allocator-swap-cost-multiplier i)
	    when (or (null item)
		     (eq item i)
		     (and (listp item)(member i item)))
	    do
	(multiple-value-bind (at al) (floor (floor (* idx scale)) w)
	  (incf al left)
	  (incf at top)
	  (multiple-value-bind (ab ar) (floor (floor (* (+ idx len) scale)) w)
	    (incf ab top)
	    (incf ar left)
	    (cond ((> (- ab at) 1)
						;multiple lines
		   (when clear
		     (if (allocator-lock-status i)
			 (send window :draw-1-bit-raster w (- ab at) 
			       tv:5.5%-gray 0 0
			       left at)
			 (send window :draw-rectangle w (- ab at) left at tv:alu-setz))
		     (send window :send-if-handles
			   :primitive-item :active i left (1+ at) w (1- ab)))

		   (let ((id (with-output-to-string (id)
			       (let ((style (selector (- ab at) >
					      (11 '(:fix :extra-condensed :normal))
					      (8  '(:fix :roman :small))
					      (5  '(:fix :roman :very-small))))
				     )
				 ;;(3 0 (NIL 0) (NIL NIL :SMALLER) "EINY7")one might wish to attempt smaller sizes based on avail space, but
0				 ;;3:display-x-y-centered-string doesn't seem to center well vertically:
0				 (when name (format id "~V~A~" style name))
				 (when swap (format id "~V ~2f~" style swap))))))
		     (when id (send window :display-x-y-centered-string
				    id left at (+ left w) ab)))
		     
		   (send window :draw-lines alu
			 left ab
			 (+ left -1 w) ab
			 (+ left -1 w) at
			 left at
			 left ab))
		  ((> ab at)			2;two lines
0		   (send window :draw-line al at w at alu)
		   (send window :draw-line left ab ar ab alu)
		   (when clear
		     (send window :send-if-handles
			   :primitive-item :active i
			   al at (+ left w) (1+ at))
		     (send window :send-if-handles
			   :primitive-item :active i
			   left ab ar (1+ ab))))
		  (t				;contained on one line
		   (send window :draw-line al at ar at alu)
		   (when clear
		     (send window :send-if-handles :primitive-item :active i
			   al at ar (1+ at)))))

	      ))
	(when verify
	  (let ((raster (allocator-raster i)))
	    (multiple-value-bind (nil nil span)
		(decode-raster-array raster)
	      (setq span (// (* span (array-element-byte-size raster))
			     (send screen :bits-per-pixel)))
	      (verify-raster
		self
		(allocator-raster i)
		:error-fun
		#'(lambda (x y sb is)
		    (ignore sb is)
		    (multiple-value-bind (ry rx)
			(floor (floor (* (+ idx x (* y span)) scale)) w)
		      (send window :draw-point rx ry))
		    nil)))))
	finally
	(setf (sheet-restored-bits-p window) t) 2;note that we did it
0	)))

2;required methods
0(defmethod (1adjust-width-for-type 0screen-memory-allocator) (awidth type to-be-visible)
  2;since the bitmap we make will be independant, allow the screen to adjust
0  2;it's width first; for example, standard color screens need all spanning
0  2;distances to be multiples of 32 pixels, so the fill mode array will be
  ;a multiple of a word in width.
0  (let* ((bpp (cdr (assoc type array-bits-per-element)))
	 (awidth (send screen :adjusted-width-for-screen awidth bpp to-be-visible)))
    (ceiling (* awidth bpp)
	     (si:array-element-byte-size screen-array))))


(defmethod (1adjust-raster0 screen-memory-allocator) (info x y rw rh adjusted-width adjusted-offset)
  (ignore adjusted-offset)
  (unless (allocator-dummy-raster info)
    (setf (allocator-dummy-raster info)
	  (make-remote-raster self adjusted-width rh )))
  (send screen :inferior-screen-array-adjusted
	screen (allocator-dummy-raster info) adjusted-width rh screen-array x y)
  (send screen :inferior-screen-array-adjusted
	screen (allocator-raster info)
	rw rh
	(allocator-dummy-raster info) 0 0))

(defmethod (1allocation-possible-p0 screen-memory-allocator)
	   (w h type to-be-visible)
  (declare (values possible possible-if-unlocked max-len nil adjusted-width ))
  (let* ((w (adjust-width-for-type self w type to-be-visible))
	 (alen (array-length screen-array))
	 (siz (* w h))
	 (len (- alen locked-size)))
    (or ( siz len)
	(values nil ( siz alen) len nil w ))))

(defmethod (1make-raster-info0 screen-memory-allocator) (&rest args)
  (cl:apply #'make-instance 'linear-allocated-raster args))

(defwhopper (1initialize-state0 screen-memory-allocator) ()
  (setq unused-size (array-length screen-array))
  (continue-whopper)
  (setq sorted-remote-rasters
	(sort `(,(make-raster-info self
				   :index-offset (array-length screen-array)
				   :length 1
				   :lock-status `(:end :freeze)
				   :name "end-marker")
		,@(copylist remote-rasters))
	      #'allocator-origin-lessp)
	))

(defmethod (1add-to-local-info-database0 screen-memory-allocator) (info)
  (without-interrupts
    (setq remote-rasters (cl:delete info remote-rasters :count 1)
	  sorted-remote-rasters (cl:delete info sorted-remote-rasters :count 1)
	  local-rasters (cons info local-rasters))
    (setf (allocator-page-status info) :local)
    (incf allocator-tick)
    (adjust-sizes self info nil)
    ))

(defmethod (1add-to-remote-info-database0 screen-memory-allocator) (info)

  (loop with orig = (allocator-index-offset info)
	and len = (allocator-length info)
	for i in sorted-remote-rasters
	as iorig = (allocator-index-offset i)
	as ilen = (allocator-length i)
	do
    (cond ((eq i info)
	   (signal-allocator-error ("~A is already remote" info)
	     (:ignore (return-from add-to-remote-info-database nil))))
	  ((rectangles-overlap-p orig 0 (+ orig len) 1
				  iorig 0 (+ iorig ilen) 1)
	   (signal-allocator-error ("~A overlaps ~A" info i)
	     ))))

  (%adjust-swap-costs self)

  (without-interrupts
    (setq local-rasters (cl:delete info local-rasters :count 1)
	  remote-rasters (cons info remote-rasters))

    (incf allocator-tick)
    (adjust-sizes self info t)

    (loop with orig = (allocator-index-offset info)
	  for prev first nil then this
	  for this on sorted-remote-rasters
	  when ( orig (allocator-index-offset (first this)))
	    do (loop-finish)
	       finally
		 (if prev
		     (setf (cdr prev) (cons info (cdr prev)))
		     (setq sorted-remote-rasters (cons info sorted-remote-rasters))))))

(defmethod (1displace-best-rasters-for-size0 screen-memory-allocator)
	   (size &key allow-movement-among-allocators relocate-victims allocator-max-cost)
  2;call here when we know we'll need to displace something to make room.
0  2;pick the lowest cost set of victims to make the free space large enough
0  2;for SIZE, and displace them0, 2but don't exceed allocator-max-cost0.
  (let ((potential-victims (sort (loop for info in sorted-remote-rasters
				       unless (allocator-lock-status info)
					 collect info)
				 #'(lambda (a b)
				     (< (* (allocator-swap-cost-multiplier a)
					   (allocator-length a))
					(* (allocator-swap-cost-multiplier b)
					   (allocator-length b))))
				 )))
2    ;if there were a lot of rasters, it might be better to be smarter than collecting
    ;and sorting the entire list

0    (when allocator-max-cost
      2;pre-pass over the list, and count the costs.  Punt if we exceed the cost limit
0      (loop with victim-size = unused-size
	    and victim-cost = 0
	    for victim in potential-victims
	    as len = (allocator-length victim)
	    as cost = (* (allocator-swap-cost-multiplier victim)
			 len)
	    do (incf victim-cost cost)
	    when (> victim-cost allocator-max-cost)
	      do (return-from displace-best-rasters-for-size nil)
	    do (incf victim-size len)
	    when ( victim-size size) do (loop-finish)))

    2;actually do the punching out.
0    (loop for victim in potential-victims
	  until ( unused-size size)
	  do
      (with-stack-list (v victim)
	(make-local-or-relocate self v relocate-victims
				allow-movement-among-allocators
				(or allocator-max-cost
				    *default-page-out-max-cost*))))
    ))

(defmethod (1find-placement0 screen-memory-allocator)
	   (w h &key
	      (type (array-type screen-array))
	      (to-be-visible)
	      (ok-to-displace t)
	      (best-fit t)
	      (displace)
	      (relocate-victims)
	      (allow-movement-among-allocators *allow-movement*)
	      (for-lock)
	      (initial-best-score)
	      (error-p nil)
	      (freezing-already-remote)
	      (shuffle t)
	      (max-cost))
  (ignore initial-best-score)
  (record-transaction :find-placement w h)
  (unless (cdr (assoc type array-bits-per-element))
    (signal-allocator-error ("~S isn't a valid array type" type)))


  2;
0  2;Allocate from a linear hunk a memory.  Simpler, but therefore we try harder
0  2;
0  2; In order of preference, we
0  2; (1) find an exact fit
0  2; (2) find a fit with minimal waste, and no victims to displace
0  2; (3) find a fit made by shuffling
0  2; (4) victmize some existing bitmaps by swapping them out
0  2;
  ; Locking throws a monkey-wrench into this, because we don't care who
0  2; we victimize in the quest for optimum placement of the lockee
0  2;
0  (let* ((w (adjust-width-for-type self w type to-be-visible))
	 (size (* w h))
	 (best-location)
	 (waste)
	 (cost)
	 (victims)
	 (best-gap-origin nil)
	 (best-gap-shufflers nil)
	 (allocator-max-cost (when max-cost
			       2;when the caller specified the max cost he is willing to pay,
0			       2;it is a multiplier for the size of the allocation.  It is
0			       2;compared to the size of the victims, times the swap multiplier
0			       (* size max-cost)))
	 )

  (when (and (eq for-lock :freeze) (> locked-size 0))
2    ;
    ;do some preliminary bashing to help the freeze land in the best place.  The
    ;:FREEZE clause of the allocator loop will be stopped dead by any locked rasters,
    ;so we first "place" a big chunk, which forces unlocked rasters to swap and locked
    ;rasters to shuffle.
    ;
0    (let ((place-size (min (* size 2) (+ unused-size (- used-size locked-size)))) )
2      ;do this for side effect, to force swapping and shuffling
0      (find-placement self place-size 1 :type type
		      :displace t :ok-to-displace t :error-p nil)
    ))

  (when ( size (if ok-to-displace
		    (- (+ used-size unused-size) locked-size)
		    unused-size))


    (when (and (< unused-size size) ok-to-displace shuffle displace)
      2;some swapping will be required, so do a two phase operation to
0      2;pick the least costly victims to swap, then shuffle the rest
0      (unless (displace-best-rasters-for-size
		self size
		:allow-movement-among-allocators allow-movement-among-allocators
		:allocator-max-cost allocator-max-cost
		:relocate-victims relocate-victims
		)
	(when error-p
	  (signal-allocator-error
	    ("Placement would exceed specified cost of ~A" max-cost)
	    (:proceed (return-from find-placement nil))
	    (:ignore
	      2;displace them without a cost constraint
0	      (displace-best-rasters-for-size
		self size
		:allow-movement-among-allocators allow-movement-among-allocators
		:allocator-max-cost NIL
		:relocate-victims relocate-victims
		)
	      )
	    )))
      )

    (macrolet ((word-align (a)
		 `(cl:logandc1 word-alignment-mask (+ word-alignment-mask ,a))))

    (loop with potential-victims
	  and victim-origin = 0
	  and total-gaps = 0
	  and gap-origin = nil
	  and gap-shufflers = nil
	  and word-alignment-mask = (max 0 (- (raster-width-for-bitblt
						1
						(array-type screen-array))
					      (raster-width-for-bitblt 1 type)))
	  as prev-end = 0 then (word-align (+ orig len))
	  for info-list on sorted-remote-rasters
	  as info = (first info-list)
	  as orig = (allocator-index-offset info)
	  as len = (allocator-length info)
	  as gap = (- orig prev-end)
	  do
      (cond ((eq for-lock :freeze)
	     2;if placement is for locking, we want to shuffle down to the
0	     2;end of memory - out of the way and unfragmented
0	     2;place the locker in the absolute last place possible, to
0	     2;avoid fragmentation by other lockers as things lock and unlock
0	     (if (allocator-lock-status info)

		 (progn
		   (if ( size gap)
		       2;it fits for free, aren't we lucky!
0		     (let ((new-waste (- gap size)))
		       (setq waste new-waste
			     best-location (- orig size)
			     victims nil
			     cost nil
			     potential-victims nil)
		       )

		     (if ( size (- orig victim-origin))
			 2;determine the correct list of victims if we stop here
0			 2;we still will proceed in case there is a later fit
0			 (loop with begin-addr = (- orig size)
			       and total-victims = 0
			       as prev = nil then victim-list
			       for victim-list on potential-victims
			       as (victim) = victim-list
			       as vsize = (allocator-length victim)
			       as end = (+ (allocator-index-offset victim)
					   vsize)
			       when ( end begin-addr)	2;this guy is safe
0				 do (if prev
					(setf (cdr prev) nil)
					(setq victims nil
					      cost nil))
				    (loop-finish)
			       do (incf total-victims
					(* (allocator-swap-cost-multiplier victim)
					   vsize))
				  (when allocator-max-cost
				    (when (> total-victims allocator-max-cost)
				      2;this placement would exceed the budget
0				      (return nil)))
			       finally 
				 (setq best-location (- orig size)
				       waste 0
				       cost total-victims
				       victims potential-victims
				       potential-victims nil)
				 )))
		   (setq victim-origin (+ orig len)))

		 (when (neq info freezing-already-remote)
		   (push info potential-victims)) 2;another potential victim
0		 ))
	    (( size gap)
2	     ;there is room
0	     (setq best-gap-origin nil) 2;forget about shuffling
0	     (let ((new-waste (- gap size)))
	       (when (or (null waste) (< new-waste waste))
		 (setq waste new-waste
		       best-location prev-end
		       cost nil
		       victims nil)))
	     (when (or (= size gap) (null best-fit))
	       2;if a perfect fit, or we're not being picky
0	       (loop-finish))
	     )
	    ((or waste (not ok-to-displace))
	     2;if we have some fit, or we don't want to bump anyone
	     ;don't investigate victims
0	     )
	    ((when shuffle
	       2;and interlude to count the gap info, this cond clause will
0	       2;never return T
0	       (incf total-gaps gap)
	       (when (and (null gap-origin)(> gap 0))
		 (setq gap-origin prev-end
		       gap-shufflers info-list))
	       (when (member :freeze (allocator-lock-status info))
		 2;get here at the end and also when we encounter a locked element
0		 (when ( size total-gaps)
		   2;we found enough free space to make the allocation
0		   (setq best-gap-origin gap-origin
			 best-gap-shufflers gap-shufflers))
		 (setq gap-origin nil
		       gap-shufflers nil
		       total-gaps 0))
	       nil))
	    (t 2;look for victims to displace, and keep track of the actual
0	     2  ;identities and cost of displacing them.
0	     (loop with new-victims and new-cost = 0
		     for i in info-list
		     as orig = (allocator-index-offset i)
		     as gap = (- orig prev-end)
		     when ( size gap)
		       do (when (or (null cost)
				    (< new-cost cost)
				    )
			    (setq best-location prev-end
				  cost new-cost
				  victims new-victims))
			  (return nil)
		     when (allocator-lock-status i) return nil
		     do (push i new-victims)
			(incf new-cost (* (allocator-swap-cost-multiplier i)
					  (allocator-length i)))
			(when (and allocator-max-cost
				   (> new-cost allocator-max-cost))
			  (return nil)
			  )
			)))
	  finally

	    (when best-gap-origin
	      2;we have the opportunity to shuffle the deck and make room
0	      (loop with orig = best-gap-origin
		    for info in best-gap-shufflers
		    as from-index = (allocator-index-offset info)
		    as gap = (- from-index orig)
		    when ( size gap)
		      do (setq best-location orig
			       victims nil
			       cost nil
			       waste (- gap size))
			 2;made a place
0			 (loop-finish)
		    as dummy = (allocator-dummy-raster info)
		    when (member :freeze (allocator-lock-status info))
		      do (signal-allocator-error
			   ("tried to shuffle ~A, a frozen raster" info)
			   (:ignore))
		    do
		(setf (allocator-index-offset info) orig)
		(multiple-value-bind (w h) (decode-raster-array dummy)
		  (send screen :inferior-screen-array-adjusted
			screen dummy
			w h screen-array orig 0))
2		  ;adjust both rasters, so everyone gets the word
0		(let ((raster (allocator-raster info)))
		  (multiple-value-bind (w h) (decode-raster-array raster)
		    (send screen :inferior-screen-array-adjusted
			  screen raster
			  w h dummy 0 0)))
		(bitblt-shuffle self from-index dummy info)
		(incf orig (allocator-length info))
	      ))

	    (when displace
	      (make-local-or-relocate
		self
		victims
		relocate-victims
		allow-movement-among-allocators
		(or max-cost *default-page-out-max-cost*))
	      (setq victims nil))

	    (when (null best-location)
	      (when error-p
		(signal-allocator-error ("no simple placement was found for ~A,~A" w h)
		  (:proceed)
		  )))
	    (record-transaction :found 
				best-location 0 (or cost 0) victims allocator-tick)
	    (return (values best-location 0
			    (+ (or cost 0)
			       (%fixed-cost self size))
			    victims allocator-tick))))
    )))

(4 0 (NIL 0) (NIL :BOLD :VERY-LARGE) "BIGFNTB");;
;; An auxiliary allocator using wired physical memory
;;
0(defvar 1*default-wired-memory-enabled* 0 nil) ;not enabled
(defvar 1*default-wired-memory-size* 00.5) ;50%
(defvar 1*reserved-physical-memory-size*0 (* 1024 1024)) 2;keep a megaword
0(defvar 1*wired-arrays*0 nil)

(defun 1wired-space-available0 ()
  (- (* sys:page-size (- si:*count-usable-pages* si:*count-wired-pages*))
     *reserved-physical-memory-size*
     ))

(defflavor 1wired-memory-allocator0 ()(screen-memory-allocator))

(defmethod (1remote-allocator-p0 wired-memory-allocator) () nil)

(defmethod (1allocator-priority0 wired-memory-allocator) () 0.25)

(defmethod (1%fixed-cost0 wired-memory-allocator) (size) size)

(defmethod (1move-to-virtual-memory0 wired-memory-allocator) (raster &rest args)
  (multiple-value-bind (info state) (find-info self raster)
    (ignore info)
    (cond ((eq state :remote) (cl:apply #'make-remote self raster args))
	  (t (cl:apply #'make-local self raster args)))))


(defmethod (1:deexpose0 wired-memory-allocator) ()
  (when screen-array
    (storage::unwire-structure screen-array)
    (setq *wired-arrays* (remove screen-array *wired-arrays*))
    )
  )
(defmethod (1wire-screen-array0 wired-memory-allocator) ()
  (when screen-array
    (let ((available (wired-space-available))
	  (sz (// (* (array-length screen-array)
		     (array-element-byte-size screen-array)) 32)))
      (cond ((> sz available)			
	     (signal-allocator-error
	       ("Array ~A is too big to wire.  Asking for ~D, max is ~D"
		sz available)))
	    (t (push screen-array *wired-arrays*)
	       (storage:wire-structure screen-array))))))
(defmethod (1:expose0 wired-memory-allocator) ()
  (when screen-array
    (wire-screen-array self))
  )


4;;;
;;; Now, screen mixins
;;;

0(defflavor 1common-allocator-mixin0 ((active-allocators)
				   (all-allocators)
				   (registered-applications))
	   (allocator-protocol)
  (:method-combination my-allocator-raster-p :or
		       find-active-allocators :nconc
		       find-all-allocators :nconc
		       )
  (:required-instance-variables screen)
  :readable-instance-variables
  (:conc-name nil)
  )

(defvar1 *allocated-local-rasters*0 (cl:make-hash-table :test #'eql))

(defwhopper (1:adjust-screen-array0 common-allocator-mixin)
	    (array new-pointer &optional (dx 0)(dy 0)(xo 0)(yo 0))
2  ;deliberately dump the optional arguments, which aren't part of the screen protocol
  ;but which sometimes get sent anyway
0  (if (and (zerop dx)(zerop dy)(zerop xo)(zerop yo))
      (continue-whopper array new-pointer)
      (error "Passing illegal arguments offsets to a screen")
      ))

(defmethod (1register-allocator-application0 common-allocator-mixin) (ap)
  (cl:pushnew ap registered-applications))

(defmethod (1unregister-allocator-application0 common-allocator-mixin) (ap)
  (setq registered-applications (remove ap registered-applications)))

(defmethod (1make-room-in-allocator0 common-allocator-mixin) (&optional requestor)
  (loop for a in registered-applications do
    (block make-room
      (catch-error-restart (sys:error "Unregister application ~S and continue" a)
	(return-from make-room (make-room-in-allocator a requestor)))
      (unregister-allocator-application self a)))
  )

(defmethod (1set-allocator-enabled0 common-allocator-mixin ) (allocator to)
  (ignore allocator to)
  )

(defmethod (1find-info0 common-allocator-mixin) (raster)
  (loop for a in all-allocators
	do (multiple-value-bind (info state)
	       (find-info a raster nil)
	     (when info (return-from find-info (values info state a))))
	finally (when (gethash raster *allocated-local-rasters*)
		  (return (values nil :local nil)))))


(defmethod (1reset-active-allocators0 common-allocator-mixin) ()
  (setq active-allocators
	(sort (find-active-allocators self)
	      #'(lambda (a b)(> (allocator-priority a)
				(allocator-priority b))))
	all-allocators
	(sort (find-all-allocators self)
	      #'(lambda (a b)(> (allocator-priority a)
				(allocator-priority b))))))


(defmethod (1describe-allocator-state0 common-allocator-mixin) (&optional (stream t))
  (ignore stream)
  (loop for a in all-allocators do
    (format stream "~&~%1allocator0 ~S is ~A"
	    a
	    (if (member a active-allocators) "enabled" "disabled"))
    (describe-allocator-state a stream))
  active-allocators)

(defmethod (1verify-rasters0 common-allocator-mixin ) (&rest args)
  (declare (arglist (&key all repair (print-message t))))
  (loop for a in all-allocators
	as v = (cl:apply #'verify-rasters a args)
	when (fixp v) sum v)
  )

(defmethod (1state0 common-allocator-mixin ) ()
  (loop for a in all-allocators
	nconc (multiple-value-list (state a)) into states
	finally (return (apply #'values states))))

(defmethod (1screen-follow-drawable-indirection 0common-allocator-mixin)
	   (DRAWABLE X-OFFSET Y-OFFSET)
  2;don't follow indirection, since that makes it impossible for the allocator
0  2;to keep track of windows that are using allocatated bitmaps
0  (VALUES DRAWABLE X-OFFSET Y-OFFSET))

(defmethod (1raster-status-for-screen0 common-allocator-mixin) (raster)
  (multiple-value-bind (info state allocator)
      (find-info self raster)
    (when info
      (cl:ecase state
	(:remote
	  (cond ((not (remote-allocator-p allocator)) :wired)
		((allocator-lock-status info) :locked)
		(t :remote)))
	(:local
	  (allocated-raster-status info)))
    )))

(defmethod (1unknown-raster-error0 common-allocator-mixin) (raster &key (error-p t))
  (if (gethash raster *allocated-local-rasters*)
      nil
      (if (and (arrayp raster)
	       (si:array-indirect-p raster)
	       (eq *deallocated-raster*
		   (si:array-indirect-pointer raster)))
	  (progn (when error-p
		   (signal-allocator-error ("~A has been deallocated" raster)
		     (:proceed)))
		 (values nil :deallocated))
	  (progn (when error-p
		   (signal-allocator-error ("~A isn't an allocated raster of ~A" raster self)
		     (:proceed)))
		 (values nil :not-my-raster)))))

(defmethod (1make-raster-permanent0 common-allocator-mixin) (raster-or-info &key (error-p t))
  (let ((info (find-info self raster-or-info)))
    (cond (info (make-raster-permanent info))
	  ((gethash raster-or-info *allocated-local-rasters*)
	   (let ((also (si:array-indirect-pointer raster-or-info)))
	     (when (gethash also *allocated-local-rasters*)
	       (remhash also *allocated-local-rasters*))
	     (remhash raster-or-info *allocated-local-rasters*)))
	  (t (unknown-raster-error self raster-or-info :error-p error-p))
	   )))


(defmethod (1remove-lock-reason 0common-allocator-mixin)
	   (raster reason &key error-p unlock-all swap-cost)
  (multiple-value-bind (info status allocator) (find-info self raster)
    (ignore status)
    (if (and allocator info)
	(remove-lock-reason allocator
			    info reason
			    :error-p error-p :unlock-all unlock-all :swap-cost swap-cost)
	(unknown-raster-error self raster :error-p error-p))))

(defmethod (1relocate-to-wired-allocator0 common-allocator-mixin) (info current-allocator)
  (ignore info current-allocator)
  nil)
  
(defmethod (1make-local0 common-allocator-mixin)
	   (raster &key
		   unlock-all
		   (discard nil discard-supplied-p)
		   unlock-reason (error-p t) initial-value
		   (allow-movement-among-allocators *allow-movement*)
		   (max-cost *default-page-out-max-cost*))
  (multiple-value-bind (info state allocator) (find-info self raster)
    (ignore state)
    (if allocator
	(let ((discard (if discard-supplied-p 
			   discard
			   (eq :never (send info :get :keep-bit-save-array)))))
	  (or (when (and allow-movement-among-allocators (not discard))
		(relocate-to-wired-allocator self raster allocator max-cost))
	      (make-local allocator raster
			  :discard discard
			  :unlock-all unlock-all
			  :unlock-reason unlock-reason
			  :initial-value initial-value
			  :error-p error-p)))
	(unknown-raster-error self raster :error-p error-p)
	)))

(defmethod (1move-to-virtual-memory0 allocator-mixin) (raster &rest args)
  (cl:apply #'make-local self raster args)
  )

(defmethod (1make-raster-remote-with-movement0 common-allocator-mixin) 
	   (raster old-allocator freezing-already-remote
		   &key
		   (page-status :write)
		   (lock-reason)
		   (to-be-visible)
		   (max-cost)
		   (error-p (null max-cost))
		   (ok-to-displace t)
		   (allow-movement-among-allocators t)
		   (swap-cost 1.0)
		   initial-value
		   )
  2;if movement is allowed, find an optimum placement on any allocator
0  (multiple-value-bind (awidth aheight)
      (decode-raster-array raster)
    (let ((atype (array-type raster)))
      (multiple-value-bind (x y victims new-allocator score)
	  (find-placement-and-allocator
	    self
	    awidth aheight
	    :type atype
	    :lock-reason lock-reason
	    :to-be-visible to-be-visible
	    :error-p nil
	    :max-cost max-cost
	    :freezing-already-remote freezing-already-remote
	    :reshuffle t
	    )
	(ignore score)

	(cond ((eq old-allocator new-allocator)
	       (make-remote old-allocator raster
			    :x x :y y
			    :initial-value initial-value
			    :victims victims
			    :allow-movement-among-allocators
			    allow-movement-among-allocators
			    :swap-cost swap-cost
			    :relocate-victims active-allocators
			    :page-status page-status
			    :ok-to-displace ok-to-displace
			    :to-be-visible to-be-visible
			    :error-p error-p
			    :lock-reason lock-reason))
	      (new-allocator
	       (%adjust-swap-costs old-allocator)
	       (capture-raster
		 new-allocator raster
		 :x x :y y
		 :victims victims
		 :to-be-visible to-be-visible
		 :lock-reason lock-reason
		 :ok-to-displace t
		 :page-status page-status
		 :error-p error-p
		 :initial-value initial-value
		 )
	       )
	      ((eq error-p :local)
	       (move-to-virtual-memory old-allocator raster :initial-value initial-value)
	       :local)
	      (error-p
	       (when error-p
		 (signal-allocator-error
		   ("Placement failed, making ~A remote" raster)
		   (:proceed (make-local old-allocator raster) :local))))
	      (t nil
		 ))
	))))

(defmethod (1make-remote0 common-allocator-mixin)
	   (raster &rest args
		   &key
		   (page-status :write)
		   (lock-reason)
		   (to-be-visible)
		   (max-cost)
		   (error-p (null max-cost))
		   (ok-to-displace t)
		   (allow-movement-among-allocators t)
		   (swap-cost 1.0)
		   initial-value
		   )
  (multiple-value-bind (info state allocator) (find-info self raster)
    (cond (allocator
	   (let ((freezing-already-remote
		   (and (eq lock-reason :freeze)
			(not (member :freeze (allocator-lock-status info)))))
		 (remote-allocator-p (remote-allocator-p allocator)))
	     (cond ((and (eq state :remote)
			 remote-allocator-p
			 (not freezing-already-remote))
		    2;already satisfactorally remote.  Just do some bookkeeping
0		    (do-remote-bookkeeping
		      allocator info
		      (if (eq page-status :read) nil page-status)
		      lock-reason
		      swap-cost
		      initial-value)

		    t)

		   (allow-movement-among-allocators
		    (cl:apply #'make-raster-remote-with-movement
			      self raster allocator freezing-already-remote
			      args
			      ))
		   (remote-allocator-p
		    2;this allocator is a remote one.  See if it's enabled
0		    (unless (member allocator active-allocators)
		      (signal-allocator-error ("allocator ~S isn't enabled" allocator)
			(:proceed (setq error-p nil))
			(:enable (set-allocator-enabled self allocator t))))
		    (when (member allocator active-allocators)
		      (make-remote allocator raster
				   :initial-value initial-value
				   :allow-movement-among-allocators
				   allow-movement-among-allocators
				   :swap-cost swap-cost
				   :relocate-victims active-allocators
				   :page-status page-status
				   :ok-to-displace ok-to-displace
				   :to-be-visible to-be-visible
				   :error-p error-p
				   :lock-reason lock-reason)))
		   ((eql error-p :local) nil)
		   (error-p
		    (when error-p
		      (signal-allocator-error
			("Placement failed, making ~A remote" raster)
			(:proceed (make-local allocator raster) :local))))
		   )))
	  (t (unknown-raster-error self raster :error-p error-p)))
    ))
  
(defmethod (1deallocate-raster0 common-allocator-mixin)
	   (raster &key (error-p t)(preserve-bits))
  (let ((allocator (my-allocator-raster-p self raster)))
    (cond (allocator
	   (deallocate-raster allocator raster :preserve-bits preserve-bits :error-p error-p))
	  ((deallocate-local-raster-internal raster))
	  (error-p
	   (unknown-raster-error self raster)))))

(defwhopper (1allocate-raster0 common-allocator-mixin)
	   (w h &rest args &key array &allow-other-keys)
  (if (and array (my-allocator-raster-p self array))
      (signal-allocator-error ("Array ~A is already an allocated array" array)
	(:proceed (values nil :already-allocated))
	(:ignore-array (si:with-rem-keywords (args args '(:array))
			 (lexpr-continue-whopper w h :array nil args))))
      (lexpr-continue-whopper w h args)))

(defvar 1*max-allocator-cost*0 3.0)

(defwhopper (1%SCREEN-PAGE-IN-SHEET-TEMPORARY-BIT-ARRAY0 common-allocator-mixin)
	    (SHEET PIXMAP DIRECTION &rest args)
  (ignore SHEET )
  (let ((allocator (my-allocator-raster-p self pixmap)))
    (if (not allocator)
	(when (member color:*explicit-page* '(:in t))
	  (lexpr-continue-whopper sheet pixmap direction args))

	(page-in-raster allocator pixmap :page-status direction
			:max-cost *max-allocator-cost*))
    ))

(defwhopper (1%SCREEN-PAGE-OUT-SHEET-TEMPORARY-BIT-ARRAY0 common-allocator-mixin)
	    (SHEET PIXMAP &rest args)
  (ignore SHEET)
  (let ((allocator (my-allocator-raster-p self pixmap)))
    (if (not allocator)
	(when (member color:*explicit-page* '(:out t))
	  (lexpr-continue-whopper sheet pixmap args))
	(page-out-raster allocator pixmap))))


(defwhopper (1%screen-deallocate-sheet-temporary-bit-array0 common-allocator-mixin)
	    (sheet pixmap)
  (let ((allocator (my-allocator-raster-p self pixmap)))
    (if allocator
	(deallocate-raster allocator pixmap)
	(continue-whopper sheet pixmap))))

(defwhopper (1%screen-allocate-sheet-temporary-bit-array0 common-allocator-mixin)
	    (sheet awidth aheight)
  (or (when (send self :exposed-p)
	(allocate-raster self awidth aheight
			 :type (sheet-array-type sheet)
			 :for-sheet sheet
			 :max-cost *max-allocator-cost*
			 :allow-excess-size t
			 :error-p :local))
      (continue-whopper sheet awidth aheight)))

(defun 1monitor-allocators0 (&key windows verify once allocators)
  2;this is a debugging hack, and also possible entertainment.
0  (let ((forced-refresh t))
    (labels ((picture-state (allocator allocator-window old-state)
	       (when (and allocator allocator-window)
		 (let ((win (if (listp allocator-window)
				(first allocator-window)
				allocator-window)))
		   (when (null (sheet-restored-bits-p win))
		     (setq forced-refresh win))
		   (when (or (not (eql (allocator-tick allocator) old-state))
			     (eq win forced-refresh))
		     (if (listp allocator-window)
			 (cl:apply #'picture allocator win
				   :verify verify (cdr allocator-window))
			 (picture allocator allocator-window :verify verify))
		     (setq old-state (allocator-tick allocator))
		     ))
		 )
	       old-state))
      (loop with aa = (copylist allocators)
	    with old-states = (make-list (length aa))
	    doing
	(loop for alloc in aa
	      as state on old-states
	      as window in windows
	      do (setf (first state) (picture-state alloc window (first state))))
	    until once
	    do
	(setq forced-refresh nil)
	(process-sleep 60 "allocator change")))))


(defmethod (1monitor-allocator0 common-allocator-mixin)
	   (&key windows verify once)

  (when (and windows (nlistp windows))
    (multiple-value-bind (w h) (send windows :inside-size)
      (setq windows
	    (loop with all = (all-allocators self)
		  with tot = (float (loop for a in all
					  sum (allocator-space-available
						a :include-locked-space t)))
		  and left = 0.0 and top = 0.0
		  and right = 1.0 and bottom = 1.0
		  for (alloc . next) on all
		  as siz = (allocator-space-available alloc :include-locked-space t)
		  as share = (// siz tot)
		  as square = (square-allocator-p alloc)
		  as spec =
		     (cond ((null next)
			    (list windows :left left :top top
				  :w (- right left)
				  :h (- bottom top)))
			   ((or (null square)
				(> (abs (- square (// (* w (- right left) )
						      (* h (- bottom top) share))))
				   (abs (- square (// (* w (- right left) share)
						      (* h (- bottom top)))))))
2			    ;if not a square allocator, or the best fit is vertical
0			    (let ((new-left (+ left (* (- right left) share)))
				  (old-left left))
			      (setq left new-left)
			      (list windows :left old-left :top top
				    :w (- new-left old-left)
				    :h (- bottom top))))
			   (t (let ((new-top (+ top (* share (- bottom top))))
				    (old-top top))
				(setq top new-top)
				(list windows
				      :left left :top old-top
				      :w (- right left)
				      :h (- new-top old-top)))))
		  collect spec
		  do (decf tot siz)
		    ))))

  (monitor-allocators :windows windows :verify verify :once once
		      :allocators (all-allocators self))
  )

(defwhopper-subst (1allocate-raster 0common-allocator-mixin) (&rest args)
  (cond (exposed-p (lexpr-continue-whopper args))
	(t (catch-error-restart ((error) "Try to expose it ~A" self)
	     (ferror "Screen ~A is deexposed, (and probably obsolete)" self))
	   (send self :expose)
	   (lexpr-continue-whopper args)
	   )))
(defwhopper-subst (1make-remote0 common-allocator-mixin) (&rest args)
  (cond (exposed-p (lexpr-continue-whopper args))
	(t (catch-error-restart ((error) "Try to expose it ~A" self)
	     (ferror "Screen ~A is deexposed, (and probably obsolete)" self))
	   (send self :expose)
	   (lexpr-continue-whopper args)
	   )))


(defflavor 1wired-memory-allocator-mixin
0	((wired-memory-allocator-enabled *default-wired-memory-enabled*)
	 (wired-memory-allocator)
	 )
	(common-allocator-mixin)
  :initable-instance-variables
  :settable-instance-variables
  (:required-flavors sheet))

(defmethod (1relocate-to-wired-allocator0 wired-memory-allocator-mixin) 
	   (raster current-allocator max-cost)
  (cond ((eq current-allocator wired-memory-allocator) t)
	((and wired-memory-allocator wired-memory-allocator-enabled)
	 (capture-raster wired-memory-allocator raster
			 :ok-to-displace (when max-cost t)
			 :max-cost max-cost
			 :error-p nil)
	 )))

(defmethod (1set-allocator-enabled0 wired-memory-allocator-mixin) (allocator to)
  (when (and allocator (eq allocator wired-memory-allocator))
    (send self :set-wired-memory-allocator-enabled to)))

(defmethod (1find-active-allocators0 wired-memory-allocator-mixin :nconc) ()
  (when (and wired-memory-allocator-enabled wired-memory-allocator)
    (list wired-memory-allocator)))
(defmethod (1find-all-allocators0 wired-memory-allocator-mixin :nconc) ()
  (when  wired-memory-allocator
    (list wired-memory-allocator)))


(defmethod (1allocate-wired-array0 wired-memory-allocator-mixin) (&key size array) 
  2;
0  2;size is a number of words of percentage of space available
0  2;an array can be supplied in place of the size
0  2;the actual maximum is protected by 1*reserved-physical-memory-size*
0  2;
0  (let ((available (wired-space-available)))
    (when (floatp size) (setq size (round (* size available))))
    (when (and size (null array))
      (when (> size available)
	(signal-allocator-error
	  ("asking for too much wired space.  Asking for ~D, max is ~D"
	   size available)))
      (setq array (make-array (* size (// 32. (send self :bits-per-pixel)))
			      :area sys:permanent-storage-area
			      :type (sheet-array-type self)
			      :initial-value 0))
      )
    array))

(defmethod (1:create-wired-memory-allocator0 wired-memory-allocator-mixin)
	   (&optional (memory-size *default-wired-memory-size*))
  (when wired-memory-allocator-enabled
    (unless wired-memory-allocator
      (let* ((wired-mem (allocate-wired-array self :size memory-size)))
	(when wired-mem
	  (setq wired-memory-allocator
		(make-instance 'wired-memory-allocator
				     :screen-array wired-mem
				     :screen self
				     :name (format nil "Wired Allocator for ~A" self)))
	  )))
    (when wired-memory-allocator
      (wire-screen-array wired-memory-allocator)
      (reset-active-allocators self)
      )
    wired-memory-allocator)
    )


(defmethod (1:expose 0wired-memory-allocator-mixin :after) (&rest ignore)
  (when exposed-p
    (send self :create-wired-memory-allocator)
    ))

(defmethod (1my-allocator-raster-p0 wired-memory-allocator-mixin) (raster)
2  ;uses OR method combination
0  (when (and wired-memory-allocator (arrayp raster))
    (let ((sheet (raster-sheet raster)))
      (and sheet
	   (eq sheet screen)
	   (my-allocator-raster-p wired-memory-allocator raster)
	   wired-memory-allocator))))

(defmethod (1:deexpose0 wired-memory-allocator-mixin :before) (&rest ignore)
  (when (and wired-memory-allocator wired-memory-allocator-enabled)
    (send wired-memory-allocator :deexpose)))

(defmethod (1:set-wired-memory-allocator-enabled 0wired-memory-allocator-mixin :after) (to)
  (if wired-memory-allocator-enabled
      (send self :create-wired-memory-allocator
	    (cond ((eql to t) *default-wired-memory-size*)
		  (t to)))
      (when wired-memory-allocator
	(send wired-memory-allocator :deexpose))
      )
  (reset-active-allocators self)
  )

(defflavor 1margin-allocator-mixin
0	((margin-allocator-enabled *default-screen-allocator-enable*)
	 (margin-allocator)
	 (right-margin-guard-size 0)
	 )
      (wired-memory-allocator-mixin common-allocator-mixin)
  :initable-instance-variables
  :settable-instance-variables
  (:required-flavors sheet))

(defwhopper (1make-raster-remote-with-movement0 margin-allocator-mixin) (&rest args)
  (cond ((and margin-allocator margin-allocator-enabled)
	 (process::with-lock ((send margin-allocator :allocator-lock))
	   (lexpr-continue-whopper args)))
	(t (lexpr-continue-whopper args))
	))

(defmethod (1set-allocator-enabled0 margin-allocator-mixin ) (allocator to)
  (when (and allocator (eq allocator margin-allocator))
    (send self :set-margin-allocator-enabled to)))

(defmethod (1find-active-allocators 0margin-allocator-mixin :nconc) ()
  (when (and margin-allocator-enabled margin-allocator) (list margin-allocator)))
(defmethod (1find-all-allocators 0margin-allocator-mixin :nconc) ()
  (when margin-allocator (list margin-allocator)))

(defmethod (1screen-has-remote-bitmaps0 margin-allocator-mixin) ()
  (and margin-allocator margin-allocator-enabled)
  )

(defwhopper (1:change-of-size-or-margins0 margin-allocator-mixin)(&rest args)
  (let ((old (and margin-allocator margin-allocator-enabled exposed-p)))
    (unwind-protect
	(progn (when old (send self :set-margin-allocator-enabled nil))
	       (lexpr-continue-whopper args))
      (when old (send self :set-margin-allocator-enabled t)))))

(defwhopper (1:refresh0 margin-allocator-mixin) (&optional (type :complete-redisplay))
  (cond ((or (eq type :override)
	     (null margin-allocator))
	 (continue-whopper type))
	(t (letf ((tv:width (- tv:width
			       (- (sheet-right-margin-size self)
				  right-margin-guard-size))))
	     (continue-whopper type)))))



(defmethod (1my-allocator-raster-p0 margin-allocator-mixin) (raster)
2  ;uses OR method combination
0  (when (and margin-allocator (arrayp raster))
    (let ((sheet (raster-sheet raster)))
      (and (eq sheet self)
	   (my-allocator-raster-p margin-allocator raster)
	   margin-allocator))))

(defmethod (1:set-right-margin-guard-size0 margin-allocator-mixin :after) (new)
  (ignore new)
  (send self :expose-margin-allocator))

(defmethod (1:create-margin-allocator0 margin-allocator-mixin) ()
  (if margin-allocator
      (send self :expose-margin-allocator)
      (let ((w (- right-margin-size right-margin-guard-size)))
	(when (and margin-allocator-enabled
		   (> w 32))
	  (let* ((sa (send screen :create-screen-array
			   w height screen-array))
		 (alloc (make-instance 'rectangle-allocator
				       :screen self
				       :screen-array sa)))
	  (setq margin-allocator alloc)
	  (reset-active-allocators self)
	  (when (and alloc exposed-p)
	    (send self :expose-margin-allocator))
	  t)))))

(defmethod (1:expose-margin-allocator0 margin-allocator-mixin) ()
  (when (and margin-allocator-enabled margin-allocator)
    (let ((w (max 0 (- right-margin-size right-margin-guard-size))))
      (send screen :inferior-screen-array-adjusted
	    self (send margin-allocator :screen-array)
	    w height
	    screen-array (- width w) 0))))

(defmethod (1:expose0 margin-allocator-mixin :after) (&rest ignore)
  (when exposed-p
    (send self :create-margin-allocator)))

(defmethod (1:set-margin-allocator-enabled 0margin-allocator-mixin :after) (ignore)
  (if margin-allocator-enabled
      (send self :create-margin-allocator)
      (when margin-allocator
	(send margin-allocator :deexpose))
      )
  (reset-active-allocators self)
  )

(defmethod (1:deexpose0 margin-allocator-mixin :before) (&rest ignore)
  (when (and margin-allocator margin-allocator-enabled)
    (send margin-allocator :deexpose)))

(defmethod (1find-placement-and-allocator0 margin-allocator-mixin)
	   (awidth aheight &key
		   (type (sheet-array-type self))
		   (lock-reason)
		   (max-cost)
		   (error-p (null max-cost))
		   (reshuffle)         2;try reshuffling the allocators
0		   (freezing-already-remote)
		   &allow-other-keys)
  (ignore reshuffle)
  (when (and margin-allocator margin-allocator-enabled)
    (multiple-value-bind (x2 y2 score2 victims2 tick2)
	(find-placement margin-allocator awidth aheight
			:freezing-already-remote freezing-already-remote
			:max-cost max-cost
			:ok-to-displace t
			:for-lock lock-reason
			:error-p error-p
			:type type)
      (values x2 y2 victims2 margin-allocator score2 tick2)
      )))

(defun 1deallocate-local-raster-internal0 (raster)
  (let ((mine (gethash raster *allocated-local-rasters*)))
    (when mine
      (let ((also-mine (si:array-indirect-pointer mine)))
	(tv:deallocate-temp-sheet-raster-and-header mine)
	(remhash also-mine *allocated-local-rasters*)
	(when also-mine
	  (tv:deallocate-temp-sheet-raster-and-header also-mine)))
      (remhash mine *allocated-local-rasters*)
      t)))

(defun 1allocate-local-raster0 (awidth aheight type &key (no-initial-value t) initial-value)
  (let ((ww (raster-width-for-bitblt awidth type)))
    (with-stack-list (dims aheight ww)
      (when (eq initial-value :no-initial-value)
	(setq initial-value nil
	      no-initial-value t))
      (let ((new-raster (tv:allocate-temp-sheet-raster-and-header
			  dims
			  :type type
			  :initial-value initial-value
			  :no-initial-value no-initial-value)))
	(setf (gethash new-raster *allocated-local-rasters*) new-raster)
	(unless (eql ww awidth)
	  (with-stack-list (dims aheight awidth)
	    (setq new-raster
		  (tv:allocate-temp-sheet-raster-and-header
		    dims
		    :type type
		    :displaced-conformally t
		    :displaced-to new-raster))
	    (setf (gethash new-raster *allocated-local-rasters*) new-raster)
	    ))
	new-raster))))

(defmethod (1allocate-raster 0margin-allocator-mixin)
	   (awidth aheight &rest keywords &key
		   allow-excess-size
		   (type (sheet-array-type self))
		   (initial-value :no-initial-value)
		   (no-initial-value (eq initial-value :no-initial-value))
		   &allow-other-keys)
		   
  (cond ((and margin-allocator-enabled
	      margin-allocator)
	 (cl:apply #'allocate-raster margin-allocator awidth aheight keywords))
	(allow-excess-size
	 (allocate-local-raster
	   awidth aheight type
	   :initial-value initial-value
	   :no-initial-value no-initial-value))
	(t
	 (cl:apply #'signal-too-large-error margin-allocator awidth aheight keywords))
	))

(defmethod (1allocator-space-available0 margin-allocator-mixin)
	   (&key (units :pixel)
		 include-locked-space
		 linear
		 (in-one-chunk t))
  (when (and margin-allocator margin-allocator-enabled)
    (allocator-space-available margin-allocator
			       :units units
			       :in-one-chunk in-one-chunk
			       :linear linear
			       :include-locked-space include-locked-space)))

(defflavor 1unused-memory-allocator-mixin
0	((unused-memory-allocator-enabled *default-screen-allocator-enable*)
	 (unused-memory-allocator)
	 )
      (margin-allocator-mixin)
  :initable-instance-variables
  :settable-instance-variables
  (:required-flavors sheet))

(defwhopper (1make-raster-remote-with-movement0 unused-memory-allocator-mixin) (&rest args)
  (cond ((and unused-memory-allocator unused-memory-allocator-enabled)
	 (process::with-lock ((send unused-memory-allocator :allocator-lock))
	   (lexpr-continue-whopper args)))
	(t (lexpr-continue-whopper args))
	))

(defmethod (1set-allocator-enabled0 unused-memory-allocator-mixin ) (allocator to)
  (when (and allocator (eq allocator unused-memory-allocator))
    (send self :set-unused-memory-allocator-enabled to)))

(defmethod (1find-active-allocators0 unused-memory-allocator-mixin :nconc) ()
  (when (and unused-memory-allocator-enabled unused-memory-allocator)
    (list unused-memory-allocator)))

(defmethod (1find-all-allocators0 unused-memory-allocator-mixin :nconc) ()
  (when unused-memory-allocator
    (list unused-memory-allocator)))

(defwhopper (1allocator-space-available0 unused-memory-allocator-mixin)
	    (&key (units :pixel)
		  include-locked-space
		  linear
		  (in-one-chunk t))
  (ignore in-one-chunk)
  (let ((size (or (when (and unused-memory-allocator unused-memory-allocator-enabled)
		    (allocator-space-available unused-memory-allocator
					       :units units
					       :linear linear
					       :include-locked-space include-locked-space))
		  0))
	(margin-size (or (continue-whopper :units units
					   :include-locked-space include-locked-space
					   :linear linear
					   :in-one-chunk in-one-chunk)
			 0)))
    (if in-one-chunk
	(max size margin-size)
	(+ size margin-size))))


(defwhopper (1screen-has-remote-bitmaps0 unused-memory-allocator-mixin) ()
  (or (and unused-memory-allocator unused-memory-allocator-enabled)
      (continue-whopper))
  )

(defwhopper (1:change-of-size-or-margins0 unused-memory-allocator-mixin)(&rest args)
  (let ((old (and unused-memory-allocator unused-memory-allocator-enabled exposed-p)))
    (unwind-protect
	(progn (when old (send self :set-unused-memory-allocator-enabled nil))
	       (lexpr-continue-whopper args))	
      (when old (send self :set-unused-memory-allocator-enabled t)))))

(defmethod (1:expose 0unused-memory-allocator-mixin :after) (&rest ignore)
  (when exposed-p
    (send self :create-unused-memory-allocator)))

(defmethod (1my-allocator-raster-p0 unused-memory-allocator-mixin) (raster)
2  ;uses OR method combination
0  (when (and unused-memory-allocator (arrayp raster))
    (let ((sheet (raster-sheet raster)))
      (and sheet
	   (eq sheet screen)
	   (my-allocator-raster-p unused-memory-allocator raster)
	   unused-memory-allocator))))

(defwhopper (1:unused-screen-memory0 unused-memory-allocator-mixin) (&optional special-array)
  2;if there is an active margin-allocator, say NIL
0  (if (and unused-memory-allocator unused-memory-allocator-enabled)
      (progn
	(catch-error-restart (error "Disable the screen allocator and continue")
	       (ferror "the unused screen memory has been usurped by the unused memory allocator.~%~
                 You should modify your application to use it, but in the meantime, you can disable it and continue"))
	(send self :set-unused-memory-allocator-enabled nil)
	(continue-whopper special-array))
      (continue-whopper special-array)))

(defmethod (1:create-unused-memory-allocator0 unused-memory-allocator-mixin) ()
  (when unused-memory-allocator-enabled
    (unless unused-memory-allocator
      (let* ((unused-mem (send self :unused-screen-memory)))
	(when unused-mem
	  (let ((unused-len (* (array-length unused-mem)
			       (// 32 (si:array-element-byte-size screen-array)))))
	    (when (> unused-len (* width 20))	;20 rows worth?
	      (let* ((allocator
		       (make-instance 'screen-memory-allocator
					    :screen-array unused-mem
					    :screen self
					    :name (format nil "Allocator for ~A" self))))
		(when allocator
		  (setq unused-memory-allocator allocator)
		  (reset-active-allocators self)
		  )
		allocator))
	))))))

(defmethod (1:deexpose0 unused-memory-allocator-mixin :before) (&rest ignore)
  (when (and unused-memory-allocator unused-memory-allocator-enabled)
    (send unused-memory-allocator :deexpose)))

(defmethod (1:set-unused-memory-allocator-enabled 0unused-memory-allocator-mixin :after) (ignore)
  (if unused-memory-allocator-enabled
      (send self :create-unused-memory-allocator)
      (when unused-memory-allocator
	(send unused-memory-allocator :deexpose))
      )
  (reset-active-allocators self)
  )

(defmethod (1find-placement-and-allocator0 unused-memory-allocator-mixin)
	   (awidth aheight &key
		   (type (sheet-array-type self))
		   (lock-reason)
		   (max-cost)
		   (error-p (null max-cost))
		   (displace nil)
		   (reshuffle) ;try reshuffling the allocators
		   (freezing-already-remote)
		   &allow-other-keys)
  (let (x y score (victims t) tick
	(unused-available (and unused-memory-allocator-enabled unused-memory-allocator))
	(margin-available (and margin-allocator-enabled margin-allocator)))
    (block find-someone

2      ;first choice, use the unused memory allocator
      ;(because it's faster and easier to manage)
0      (when unused-available
	(multiple-value (x y score victims tick)
	  (find-placement unused-available awidth aheight
			  :for-lock lock-reason
			  :freezing-already-remote freezing-already-remote
			  :type type
			  2;maybe do the displacement too, which enables trying harder
0			  :displace (and (not margin-available) displace)
			  :relocate-victims active-allocators
			  :max-cost max-cost
			  :ok-to-displace t))
	(when (and x y (zerop score)(null victims))
	  2;(ferror "first choice ")
0	  (return-from find-someone
	    (values x y victims unused-available score tick ))))

      2;second choice, use the margin-allocator, limiting options as much as possible
0      2;to speed it up.
0      (when margin-available
	(multiple-value-bind (x2 y2 score2 victims2 tick2)
	    (find-placement margin-available awidth aheight
			    :freezing-already-remote freezing-already-remote
			    :max-cost max-cost
			    :relocate-victims active-allocators
			    :ok-to-displace (when (or victims (and (null (and x y))))
2					      ;allow displace if the unused-allocator found nothing
					      ;or if it found something with victims
0					      t)
			    :displace (and (not unused-available) displace)
			    :initial-best-score (when victims score)
			    :for-lock lock-reason
			    :type type)

	  (when (and x2 y2 
		     (or (not (and x y)) 2;no choice
0			 (null victims2)
			 ( score2 score)))
	   2;0 2(ferror "second choice ")
0	    (return-from find-someone (values x2 y2 victims2 margin-available score2 tick2))
	    )))

      (when (and x y)
	  2;(ferror "third choice ")0	
	(return-from find-someone (values x y victims unused-available score tick)))

      (when (and (or (and error-p (neq error-p t)) reshuffle)
		 margin-available unused-available)
	2;we're desperate, and being impeded by locked rasters.  First try shuffling
0	2;to the unused-allocator, making room in the margin-allocator.  Do this even
0	2;if the raster won't fit in the margin, since the reshuffle may make things
0	2;fit better
0	(when (capture-locked-rasters unused-available margin-available)
	  (multiple-value-bind (x2 y2 score2 victims2 tick2)
	      (find-placement margin-available awidth aheight
			      :ok-to-displace t
			      :displace t
			      :max-cost max-cost
			      :freezing-already-remote freezing-already-remote
			      :initial-best-score nil
			      :for-lock lock-reason
			      :relocate-victims active-allocators
			      :type type)
	    (when (and x2 y2 )
	      (return-from find-someone (values x2 y2 victims2 margin-available score2 tick2))
	    )))

	(when (capture-locked-rasters margin-available unused-available)
	  (multiple-value-bind (x y score victims tick)
	      (find-placement unused-available awidth aheight
			      :ok-to-displace t
2			      ;do the displacement too, which enables "trying harder"
0			      :displace t
			      :relocate-victims active-allocators
			      :freezing-already-remote freezing-already-remote
			      :max-cost max-cost
			      :initial-best-score nil
			      :for-lock lock-reason
			      :type type)
	    (when (and x y )
	      (return-from find-someone
		(values x y victims unused-available score tick))
	      )))
	)

      (unless freezing-already-remote
	(when error-p
	  (signal-allocator-error ("No placement found for ~A,~A" awidth aheight)
	    (:proceed)
	    )))

      (values nil :no-placement)
      )))

(defmethod (1signal-too-large-error0 unused-memory-allocator-mixin) 
	   (w h
	      &rest args
	      &key
	      (error-p t)
	      (type (sheet-array-type self))
	      (to-be-visible nil)
	      &allow-other-keys)
  (when error-p
    (let ((msg (with-output-to-string (error-string)
		 (let ((margin (and margin-allocator-enabled margin-allocator))
		       (unused (and unused-memory-allocator-enabled unused-memory-allocator)))
		   (when margin
		     (signal-too-large-message
		       margin error-string w h type to-be-visible (not unused)))
		   (when unused
		     (signal-too-large-message
		       unused error-string w h type to-be-visible t))))))
      (signal-allocator-error (msg)
	(:proceed)
	(:allocate-anyway
	  (return-from signal-too-large-error
	    (cl:apply #'allocate-raster self w h
		      :allow-excess-size t
		      :error-p nil
		      args)))
	)))
  (values nil :too-large))

(defmethod (1allocate-raster0 unused-memory-allocator-mixin)
	   (awidth aheight &rest keywords
		   &key allow-excess-size
		   (make-remote t)
		   (make-local (not make-remote))
		   (initial-value :no-initial-value)
		   (no-initial-value (eq initial-value :no-initial-value))
		   (type (sheet-array-type self))
		   max-cost
		   (error-p (null max-cost))
		   (to-be-visible)
		   &allow-other-keys)

  (prog ()
    restart 2;we might go here if the allocation we initially find gets stolen
0    (return    
    (multiple-value-bind (x y victims allocator score tick)
	(when make-remote			
	  (cl:apply #'find-placement-and-allocator self awidth aheight
		    :error-p nil
		    :max-cost max-cost
2						;if we'll ultimately cause an error if we
						;fail, try reshuffling.
0		    :reshuffle (and error-p (neq error-p :local) (not allow-excess-size))
		    :make-remote make-remote
		    keywords))

      (when (and make-remote (eq error-p :local) (not (and x y allocator)))
	(setq make-remote nil
	      make-local t))

      (let (possible-for-unused possible-for-margin)
	(cond (make-remote)
	      ((and make-local
		    wired-memory-allocator
		    wired-memory-allocator-enabled
		    2;prefer to make-local by using the wired allocator
0		    (progn (multiple-value (x y score victims tick)
			     (find-placement wired-memory-allocator awidth aheight
					     :error-p nil
					     :max-cost max-cost
					     :type type
					     :ok-to-displace t))
			   (and x y)))
	       (setq make-remote t
		     allocator wired-memory-allocator 
		     make-local nil))
	      ((and unused-memory-allocator
		    unused-memory-allocator-enabled
		    (multiple-value-bind (possible possible-unlock)
			(allocation-possible-p unused-memory-allocator awidth aheight
					       type to-be-visible)
		      (setq possible-for-unused possible-unlock)
		      possible
		      ))
	       (setq x -1 y -1 allocator unused-memory-allocator tick nil))
	      ((and margin-allocator
		    margin-allocator-enabled
		    (multiple-value-bind (possible possible-unlock)
			(allocation-possible-p margin-allocator awidth aheight
					       type to-be-visible)
		      (setq possible-for-margin possible-unlock)
		      possible
		      ))
	       (setq x -1 y -1 allocator margin-allocator tick nil))
	      (possible-for-unused
2	       ;possible if unlocked
0	       (setq x -1 y -1 allocator unused-memory-allocator tick nil)
	       )
	      (possible-for-margin
	       2;possible if unlocked
0	       (setq x -1 y -1 allocator margin-allocator tick nil))
	      ))

      (ignore score)
      (cond ((and x y allocator)
	     (process:with-lock ((send allocator :allocator-lock))
	       (unless (or (null tick)
			   (eql (send allocator :allocator-tick) tick))
		 (go restart)
		 )

	       (let ((other-allocator (if (eql allocator unused-memory-allocator)
					  margin-allocator
					  unused-memory-allocator)))
		 (when other-allocator (%adjust-swap-costs other-allocator)))

	       (cl:apply #'allocate-raster allocator awidth aheight
			 :x x
			 :y y
			 :victims victims
			 :relocate-victims active-allocators
			 :make-remote make-remote
			 :make-local make-local
			 keywords)))
	    (allow-excess-size
	     (let ((all (or (and unused-memory-allocator-enabled unused-memory-allocator)
			    (and margin-allocator-enabled margin-allocator))))
	       (if all
		   (cl:apply #'allocate-raster all awidth aheight
			     :make-remote nil
			     :make-local (or make-local make-remote)
			     keywords)
		   (allocate-local-raster
		     awidth aheight type
		     :initial-value initial-value
		     :no-initial-value no-initial-value))))
	    (t (cl:apply #'signal-too-large-error self awidth aheight keywords))
	    )))))


#||

(defun 1test-alloc0 (win &key do-it max-w max-h type)
  (let ((w (max 1 (random max-w)))
	(h (max 1 (random max-h))))
    (if do-it
	(values (allocate-raster win w h
				 :type (or type (sheet-array-type win))
				 :initial-value (random (lsh 1 30)))
		w h)
	(find-placement win w h))
    ))

(defun 1test-alloc-loop 0(win n size &key (max-w 200)(max-h 200) (types))
  (loop repeat1 0n
	for i from 1
	when (> i size)
	  do (deallocate-raster
	       win
	       (allocator-raster
		 (multiple-value-bind (rem loc) (state win)
		   (let* ((nr (length rem))
			  (n (random (+ nr (length loc)))))
		     (if ( n nr)
			 (nth (- n nr) loc)
			 (nth n rem))))))
	do (test-alloc win :do-it t :max-w max-w :max-h max-h
		       :type (if types (nth (random (length types)) types)))))


||#

(compile-flavor-methods
  screen-memory-allocator rectangle-allocator
  linear-allocated-raster square-allocated-raster)

#||

(DEFFLAVOR MAIN-SCREEN ()
      (margin-allocator-mixin MAIN-SCREEN-MIXIN SINGLE-BIT-SCREEN-MIXIN SCREEN)
  (:default-init-plist :right-margin-guard-size 30))

;this is compatible with or without margin-allocator-mixin
(DEFMETHOD (:REFRESH-MARGINS GRAY-MAIN-SCREEN-BORDERS-MIXIN) ()
  (LET ((SIDE-HEIGHT (- HEIGHT BOTTOM-MARGIN-SIZE TOP-MARGIN-SIZE))
	(GUARD-SIZE (SEND SELF :SEND-IF-HANDLES :right-margin-guard-size))
	(GRAY-ARRAY (OR GRAY-ARRAY-FOR-UNUSED-AREAS :WHITE)))
    ;; Fill the top margin
    ;; For some gray patterns you get obnoxious striping in the visible area off the
    ;; top of the screen, but that's a bug in the sync program, and not so easy to
    ;; compensate for here.  With the default gray pattern, which is dark, it's no problem.
    (PREPARE-SHEET (SELF)
      (SCREEN-MANAGE-GRAY-RECTANGLE-INTERNAL
	GRAY-ARRAY SELF ALU-SETA
	(- WIDTH RIGHT-MARGIN-SIZE) TOP-MARGIN-SIZE 0 0 0 0)
      ;; Fill the bottom margin
      (SCREEN-MANAGE-GRAY-RECTANGLE-INTERNAL
	GRAY-ARRAY SELF ALU-SETA
	WIDTH BOTTOM-MARGIN-SIZE 0 (- HEIGHT BOTTOM-MARGIN-SIZE)
	0 (- HEIGHT BOTTOM-MARGIN-SIZE))
      ;; Fill the left margin
      (SCREEN-MANAGE-GRAY-RECTANGLE-INTERNAL
	GRAY-ARRAY SELF ALU-SETA
	LEFT-MARGIN-SIZE SIDE-HEIGHT 0 TOP-MARGIN-SIZE 0 TOP-MARGIN-SIZE)
      ;; Fill the right margin
      (SCREEN-MANAGE-GRAY-RECTANGLE-INTERNAL
	GRAY-ARRAY SELF ALU-SETA
	(OR GUARD-SIZE RIGHT-MARGIN-SIZE) (+ SIDE-HEIGHT TOP-MARGIN-SIZE)
	(- WIDTH RIGHT-MARGIN-SIZE) 0
	(- WIDTH RIGHT-MARGIN-SIZE) 0)
      ))
  NIL)


||#


(defmethod (1:set-transaction-log-enabled0 margin-allocator-mixin) (to)
  (when margin-allocator
    (send margin-allocator :set-transaction-log-enabled to)))

(defmethod (1:set-transaction-log-enabled0 unused-memory-allocator-mixin) (to)
  (when unused-memory-allocator
    (send unused-memory-allocator :set-transaction-log-enabled to)))

(defmethod (1:transaction-log 0margin-allocator-mixin) ()
  (if margin-allocator
      (send margin-allocator :transaction-log)
      (values)))

(defwhopper (1:transaction-log0 unused-memory-allocator-mixin ) ()
  (let ((my-transaction-log
	  (when unused-memory-allocator
	    (list (send unused-memory-allocator :transaction-log))
	    )))
    (cl:apply #'values
	      (nconc (multiple-value-list (continue-whopper))
		     my-transaction-log))))

#||
;more debugging hacks
(defvar 1*start-state*0 nil)
(defvar 1*end-state*0 nil)
(defvar 1*log*0 nil)
(defmethod (1set-logging0 common-allocator-mixin) (to)
  (setq *log* (multiple-value-list (send self :transaction-log)))
  (multiple-value-bind (a-remote a-local m-local m-remote)
      (state self)
    (let ((state `(,(copylist a-remote)
			  ,(copylist a-local)
			  ,(copylist m-remote)
			  ,(copylist m-local))))
      (if to
	  (setq *start-state* state)
	  (setq *end-state* state))
      (send self :set-transaction-log-enabled to)
      (length *log*)
      )))

(defvar 1*used-rasters*0 (cl:make-hash-table))

(defun 1used-rasters0 (&optional (log *log*))
  (clrhash *used-rasters*)
  (labels ((note-used-rasters (a)
	     (cond ((typep a 'allocated-raster)
		    (scl:modify-hash
		      *used-rasters*
		      a
		      #'(lambda (k d found)
			  (ignore k)
			  (cond ((null found) 1)
				(t (1+ d))))))
		   ((nlistp a))
		   (t (loop for i in a do (note-used-rasters i))))))
    (note-used-rasters log)))

(defun 1remove-unused-rasters0 ()
  (used-rasters)
  (labels ((remove-rasters (a)
	     (cond ((listp a)
		    (loop for i on a do  (setf (first i) (remove-rasters (first i))))
		    (cl:remove-if #'(lambda (a)
				      (and (typep a 'allocated-raster)
					   (not (gethash a *used-rasters*))))
				  a))
		   (t a))))
    (setq *start-state* (remove-rasters *start-state*)
	  *end-state* (remove-rasters *end-state*))
    ))

(defun print-transaction-log ()
  (remove-unused-rasters)
  (loop for log in *log* do
    (loop for transaction in (reverse log)
	  do
      (format t "~&")
      (loop with first = t
	    for (event  next-event) on (reverse transaction)
	    as (time id . args) = event
	    as (next-time ) = next-event		
	    when next-event
	      do
		(format t "~&~A~7d ~a"
			(if first "." " ")
			(time:time-difference next-time time) id)
		(setq first nil)
		(loop for arg in args do
		  (cond ((and (arrayp arg)(= 2 (array-#-dims arg)))
			 (multiple-value-bind (w h) (decode-raster-array arg)
			   (format t " ar ~Dx~D x ~D" w h (array-element-byte-size arg))))
			(t (format t " ~A" arg))))))))
	  
||#

#||
(defmethod (screen-has-remote-bitmaps allocator-mixin) () t)
||#


(defflavor 1photometry-allocator0 ((base-raster)
				 (lock-reason :photometry)
				 (other-allocators)
				 (exposed-p)
				 )
	   (screen-memory-allocator)
  :initable-instance-variables
  (:gettable-instance-variables base-raster lock-reason other-allocators))


(defun 1make-photometry-allocator0 (screen size &key
				  (lock-reason :photometry)
				  (make-remote t)
				  (name "Photometry Allocator")
				  (error-p t)
				  )
  (labels ((1d-array (a)
	     (when a
	       (let ((len (array-length a)))
		 (send screen :create-screen-array len nil a (array-type a))))))
    (let* ((size-available (allocator-space-available
			     screen
			     :units 'art-fixnum :include-locked-space nil :linear t))
	   (raster (tv:allocate-raster screen (floor (* size-available size)) 1
				       :error-p error-p
				       :lock-reason :freeze
				       :keep-bit-save-array :never
				       :name name
				       :make-remote make-remote)))
      (when raster
	(let* ((red (1d-array (or (color:get-special-array screen :red raster)
				  raster)))
	       (g (1d-array (color:get-special-array screen :green raster)))
	       (b (1d-array (color:get-special-array screen :blue raster)))
	       (a (1d-array (color:get-special-array screen :alpha raster)))
	       (other-allocators
		 `(,@(when g (list (make-instance 'screen-memory-allocator
						  :screen screen
						  :name "Photometry Green"
						  :screen-array g)))
		   ,@(when b (list (make-instance 'screen-memory-allocator
						  :screen screen
						  :name "Photometry Blue"
						  :screen-array b)))
		   ,@(when a (list (make-instance 'screen-memory-allocator
						  :screen screen
						  :name "Photometry Alpha"
						  :screen-array a)))))
	       (allocator (make-instance 'photometry-allocator
					 :screen screen
					 :base-raster raster
					 :lock-reason lock-reason
					 :name "Photometry Red"
					 :other-allocators other-allocators
					 :screen-array red)))
	  (send allocator :expose)
	  allocator))
      )))

(defmethod (1:expose0 photometry-allocator :before) ()
  (tv:make-remote screen base-raster :lock-reason :freeze)
  (tv:make-remote screen base-raster :lock-reason lock-reason)
  (let ((red (or (color:get-special-array screen :red base-raster)
			   base-raster))
	(g (color:get-special-array screen :green base-raster))
	(b (color:get-special-array screen :blue base-raster))
	(a (color:get-special-array screen :alpha base-raster)))

    (let ((ext (color:color-external-overlay-arrays base-raster))
	  (packed (color:color-packed-mode-arrays base-raster)))
      (when (and ext packed)
	(loop for pack in packed do
	  (setf (color:color-external-overlay-arrays pack)
		(loop repeat 8 collect (Pop ext))))))

    (send screen :inferior-screen-array-adjusted
	  screen 
	  screen-array (array-length screen-array) nil
	  red 0 0)
    (si:with-stack-list (other g b a)
      (loop for a in other-allocators
	    for ba in other
	    as sa = (send a :screen-array)
	    do (send screen :inferior-screen-array-adjusted
		     screen
		     sa (array-length sa) nil
		     ba 0 0))
      )
    (setq exposed-p t)
    ))

(defmethod (1:deexpose0 photometry-allocator :after) ()
  (setq exposed-p nil)
  (remove-lock-reason screen base-raster :freeze)
  (remove-lock-reason screen base-raster lock-reason)
  (make-local screen base-raster :discard t)
  )

(defmethod (1:exposed-p0 photometry-allocator) ()
  (and exposed-p screen (send screen :exposed-p)))

(defmethod (1:kill0 photometry-allocator :after) ()
  (deallocate-raster screen base-raster :preserve-bits nil))

(defvar *use-photometry-aux-allocators* t)

(defmethod (1get-photometry-board0 photometry-allocator) (board)
  (if (eq board :red) self
      (destructuring-bind (g b a) other-allocators
	(or (cl:ecase board
	      (:green g)
	      (:blue b)
	      (:alpha a))
	    (error "There is no ~S board in this configuration" board)))))
  
(defwhopper (1make-remote0 photometry-allocator)
	    (raster-or-info &rest keys &key
			    (relocate-victims other-allocators)
			    (ok-to-displace t)
			    (error-p t)
			    (board :red)
			    &allow-other-keys)
  (si:with-rem-keywords (keys keys '(:relocate-victims :ok-to-displace :error-p :board))
    (let ((board-of-interest (get-photometry-board self board)))
      (multiple-value-bind (info state allocator) (find-info self raster-or-info)
	(ignore state)
	(cond ((eq allocator board-of-interest)
	       (if (eq allocator self)
		   (lexpr-continue-whopper info
					   :relocate-victims relocate-victims
					   :allow-movement-among-allocators
					   *use-photometry-aux-allocators*
					   :ok-to-displace ok-to-displace
					   :error-p error-p
					   keys)
		   (cl:apply #'make-remote board-of-interest info
			     :relocate-victims relocate-victims
			     :allow-movement-among-allocators
			     *use-photometry-aux-allocators*
			     :ok-to-displace ok-to-displace
			     :error-p error-p
			     keys)))			     
	      (t (cl:apply #'capture-raster board-of-interest (allocator-raster info)
			   :relocate-victims relocate-victims
			   :ok-to-displace ok-to-displace
			   :from-allocator allocator
			   :error-p error-p
			   keys)))))))

(defwhopper (1allocate-raster0 photometry-allocator)
	    (w h &rest keys &key
	       (relocate-victims other-allocators)
	       (board :red)
	       &allow-other-keys)
  (si:with-rem-keywords (keys keys '(:relocate-victims :board))
    (let ((board-of-interest (get-photometry-board self board)))    
      (if (eq board-of-interest self)
	  (lexpr-continue-whopper w h
				  :relocate-victims relocate-victims
				  :allow-movement-among-allocators
				  *use-photometry-aux-allocators*
				  keys)
	  (cl:apply #'allocate-raster board-of-interest
		    w h
		    :relocate-victims relocate-victims
		    :allow-movement-among-allocators
		    *use-photometry-aux-allocators*
		    keys)
	  ))))

(defwhopper (1make-local0 photometry-allocator)
	    (raster-or-info &rest keys &key
			    &allow-other-keys)
  (multiple-value-bind (info state allocator) (find-info self raster-or-info)
    (ignore state)
    (cond ((eq allocator self)
	   (lexpr-continue-whopper info keys))
	  (t (cl:apply #'move-to-virtual-memory allocator info keys)))))

(defwhopper (1deallocate-raster0 photometry-allocator) (raster-or-info &rest args)
  (multiple-value-bind (info state allocator) (find-info self raster-or-info nil)
    (ignore state)
    (cond ((null allocator))
	  ((eq allocator self) (lexpr-continue-whopper info args))
	  (t (cl:apply #'deallocate-raster allocator info args)))))

(defmethod (1active-allocators0 photometry-allocator) ()
  (cons self other-allocators))

(defmethod (1monitor-allocator0 photometry-allocator)
	   (&key windows verify once)
  (when (nlistp windows)
    (cond ((null other-allocators) (setq windows (list windows)))
	  (t (setq windows `((,windows :left 0 :top 0 :w 0.5 :h 1.0)
			     ,@(loop with n = (length other-allocators)
				     with step = (// 0.5 n)
				     repeat n for idx from 0.5 by step
				     collect `(,windows :left ,idx :top 0 :w ,step :h 1.0
					       )))))))
  (monitor-allocators :windows windows :verify verify :once once
		      :allocators (active-allocators self)))


(defwhopper (1find-info0 photometry-allocator) (raster &optional (error-p t))
  (multiple-value-bind (info status) (continue-whopper raster nil)
    (if info
	(values info status self)
	(loop for i in other-allocators
	      as info = (find-info i raster nil)
	      when info return (values info :local i)
	      finally
		(when error-p
		  (signal-allocator-error ("Info object not found for ~S" raster)
		    (:ignore)))))))

