;;; -*- Mode: LISP; Base: 10.; Package: COLOR -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

(defmethod (:init rle-mixin :after) (plist)
  (send self ':set-rle-internal
	(cl:getf (location-contents plist) ':rle *default-image-rle*)))

(defmethod (:rle rle-mixin) ()
  (let ((out (send self :rle-on-output)))
    (if (eq out :unk)
	(cl:getf flavor:property-list :rle-on-output *default-image-rle*)
	out)))

(defwhopper (D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")can-i-make-the-right-input-stream0 rle-mixin)
	    (&rest keywords &key components frame(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI") 0&allow-other-keys)
  (if (and (send self :rle)
	   (not (send self :bit-arrays-valid-for-frame frame))
	   (not (member components '(:red :green :blue :alpha :y))))
      nil 2;if we are run length encoded and not asking for a component, no
0      (lexpr-continue-whopper keywords)))


(defmethod (:set-rle-internal rle-mixin) (to)
  (send self :putprop
	(if (eq to t)
	    '(rle-array-2 rld-array-2)
	    to)
	':rle-on-output)
  (send self :remprop :next-rle-on-output)
  )

(defmethod (:set-rld rle-mixin) (to)
  (send self ':set-rle-on-output to))

(defmethod (:set-rle rle-mixin) (to)
  (send self ':set-rle-on-output to))

(defmethod (:set-rle-on-output rle-mixin) (to)
  (if to
      (send self :putprop '(rle-array-2 rld-array-2) ':next-rle-on-output)
      (send self :putprop :nil ;yes, I mean :NIL
	    ':next-rle-on-output)))

(defmethod (:image-dump-form rle-mixin) ()
  `(:rle ',(send self :rle)))

(defmethod (:create-init-plist rle-mixin) (&key exclude-properties include-properties)
  (ignore include-properties)
  (unless (memq :rle exclude-properties)
    `(:rle ',(send self ':rle))))

(comment 
  1          load
  000xx      +xx
  001xx      -xx
  010        copy
  01100      push (unused at present)
  01101      loop (unused at present)
  01110      repeat
  01111      unassigned
 )

(defconst op-repeat #o16)
(defconst op-loop #o15 )
(defconst op-pixel 1)
(defconst op-copy #o2)
(defconst op-plusc 0)
(defconst op-minusc 1)

(defconst stats t)
(defconst const-range 4)




(defflavor 1compressing-stream
0	(buffer width height elt-size
	 (rect-ac 0)
	 (rect-acc 0)
	 (rect-outi -1)
	 (rect-p-dif 0)
	 (rect-p-difc 0)
	 (rect-p-point 0)
	 (stream)
	 (from-field)
	 (to-field))
	()
  :writable-instance-variables
  :initable-instance-variables)



(defmacro-in-flavor (1emit0 compressing-stream) (val bits)
  `(progn
     #m(format t "~a ~a   " ,val ,bits)
     (setq ac (logior (lsh ac ,bits) ,val))
     (incf acc ,bits)
     (when (>= acc 16)
       (aset (lsh ac (- 16 acc)) out (incf outi))
       (decf acc 16)
       )))

(defmacro-in-flavor (1finish-run0 compressing-stream) ()
  `(progn
     (let ((loop (>= p-difc 8)))
       (cond (loop
	      (loop with n = (* 8 (// (1- (haulong p-difc)) 8))
		    do
		    (emit op-repeat 5)
		    (emit op-pixel 1)
		    (emit (load-byte p-difc n 8) 8)
		    (decf n 8)
		    while (>= n 0))
	      ))
       (cond ((zerop p-dif)
	      (when  (> p-difc 0)
		(emit op-copy 3)))
	     ((<= (- const-range) p-dif const-range)
	      (if (> p-dif 0)
		  (progn (emit op-plusc 3)
			 (emit (1- p-dif) 2))
		  (progn (emit op-minusc 3)
			 (emit (1- (- p-dif)) 2))))
	     (t (emit op-pixel 1)
		(emit p-point 8)))
       (cond (loop
	      )
	     (t (loop repeat (- p-difc 1) do
		      (emit op-copy 3)))))))

(defmacro1 compress-rectangle0 (width height source dx dy
			      &key
			      (src-inc 1)
			      indirect-source
			      line-continuation
			      (from-field 'from-field)
			      (to-field 'to-field)
			      )

  `(tv:with-prepared-sheet-or-raster (,source :array ar
				      ,@(unless line-continuation
					  `(:span span))
				      :width w
				      ,@(when indirect-source `(:height h)))
     (,@(if indirect-source
	    `(with-stack-array (indirect-in (list h (* w ,src-inc))	
					    :type 'art-8b
					    :displaced-conformally t
					    :displaced-to ar))
	    `(progn))
      (let (,@(cond (indirect-source `((ar indirect-in)
				      (span (* span ,src-inc))))
		    (line-continuation `((ar ar))))
	    
	    (emit-blanks (eql ,to-field 2))
	    (out buffer))
	(declare (sys:array-register-1d out ,@(when (or line-continuation indirect-source) `(ar))))
	,@(when line-continuation `((ignore ,dy)))
	(loop with ac = rect-ac
	      and last-time = (time:fixnum-microsecond-time)
	      and acc = rect-acc
	      and outi = rect-outi
	      and p-dif = rect-p-dif
	      and p-difc = rect-p-difc
	      and p-point = rect-p-point
	      and ewidth = (* ,width ,src-inc)
		,@(if line-continuation
		      `(repeat ,height
			       as spani = (+ ,dx (funcall ,line-continuation)))
		      `(for spani
			    from (+ (* (+ ,dy (if ,from-field (1- ,from-field) 0))
				       span) ,dx)
			    below (+ (* (+ ,dy ,height) span) ,dx)
			    by (+ (if ,from-field span 0)
				  span)))
	      as spanx = (+ spani ewidth)
	      do
	  (when (> (time:time-difference (time:fixnum-microsecond-time) last-time)
		   500000)
	    (allow-sheet-activity)
	    (setq last-time (time:fixnum-microsecond-time)))
	  (when ,to-field
	    (if emit-blanks
		(progn
		  (unless (eql p-point 0)
		    (finish-run)
		    (setq p-difc 0
			  p-point 0))
		  (incf p-difc w))
		(setq emit-blanks t)))
	  (loop for idx from spani below spanx by ,src-inc
		as point = (aref ar idx)
		as dif = (- point p-point)
		do
	    (cond ((= dif 0)
		   (incf p-difc))
		  (t (finish-run)
		     (setq p-dif dif
			   p-point point
			   p-difc 1)))
	    )
	      finally
		(setq rect-ac ac
		      rect-acc acc
		      rect-outi outi
		      rect-p-dif p-dif
		      rect-p-point p-point
		      rect-p-difc p-difc)
		)))))

(defmethod (1setup-buffer0 compressing-stream) (version)
  (macrolet ((emit-word (n)
	       `(progn (setf (aref buffer (incf rect-outi)) ,n)
		       )))
    (when (> version 1)
      (emit-word 0)
      (emit-word elt-size))
    (emit-word (lsh width -16))
    (emit-word width)
    (emit-word (lsh height -16))
    (emit-word height)))

(defmethod (1finish-buffer0 compressing-stream) ()
  (let ((ac rect-ac)
	(acc rect-acc)
	(outi rect-outi)
	(out buffer)
	(p-dif rect-p-dif)
	(p-difc rect-p-difc)
	(p-point rect-p-point))
    (finish-run)
    (emit 0 (- 16 acc)) 2;push out the last bit, if necessary
0    (setq rect-ac ac
	  rect-acc acc
	  rect-outi outi
	  rect-p-dif p-dif
	  rect-p-difc p-difc
	  rect-p-point p-point)
    ))

#||

(defmethod (1tv:with-bit-array-or-stream0 compressing-stream)
	   (direction continuation &rest args)
  (lexpr-send self :with-bit-array-stream direction continuation args)
  )

(defmethod (1tv:with-bit-array0 compressing-stream)
	   (direction continuation &rest args)
  (lexpr-funcall #'tv:bit-array-stream-as-bit-array
		 self direction continuation args)
  )

(defmethod (1tv:with-bit-array-stream0 compressing-stream )
	   (direction continuation
		      &key
		      (x-offset 0)
		      (y-offset 0)
		      (width in-width)
		      (height in-height)
		      from-field
		      (stream-height in-height)
		      (minimum-rows 1)
		      temporary-raster
		      &allow-other-keys)

  (check-arg direction (eq direction :input) "Direction must be :OUTPUT")
  )

||#

(defmethod (1compress-8b-rectangle0 compressing-stream)
	   (width height source dx dy)
  2;compress a regular art-8b rectangle
0  (compress-rectangle width height source dx dy)
  )

(defmethod (1compress-8b-rectangle-continuation0 compressing-stream)
	   (width height source dx dy continuation)
  2;compress a regular art-8b rectangle
0  (compress-rectangle width height source dx dy :line-continuation continuation)
  )

(defmethod (1compress-32b-rectangle0 compressing-stream)
	   (width height source dx dy phase)
  2;compress one channel of an art-32
0  (let ((dx (+ (* dx 4)
	       (selectq phase (:red 0)(:green 1)(:blue 2)(:alpha 3)(t phase)))))
    (compress-rectangle width height source dx dy
			:src-inc 4
			:indirect-source t)
    ))

(defmethod (1compress-rgb-rectangle0 compressing-stream)
	   (width height source dx dy phase)
  2;compress one channel of a packed-rgb data array
0  (let ((dx (+ (* dx 3)
	       (selectq phase (:red 0)(:green 1)(:blue 2)(t phase)))))
    (compress-rectangle width height source dx dy
			:src-inc 3)))

(defmethod (1compress-yuv-rectangle0 compressing-stream)
	   (width height source dx dy phase)
  2;compress some channel of a packjed-yuv data array
0  (let ((dx (+ (* dx 2) (selectq phase (:y 1)(:u 0)(:v 2)))))
    (selectq phase
      (:Y (compress-rectangle width height source dx dy
			      :src-inc 2))
      (T (let ((width (// width 2)))
	   (compress-rectangle width height source dx dy
			       :src-inc 4)
	   )))))


      

(defmethod (:rle-1 rle-mixin) (input &key output )
  (rle-array-1-internal input output width height))

(defmethod (:rle-2 rle-mixin) (input &key output)
  (rle-array-1-internal input output width height 0 0 :version 2))

(defun 1rle-array-2
0       (input &optional output
	(width (decode-raster-array input))
	(height (multiple-value-bind (nil h) (decode-raster-array input) h))
	(dx 0) (dy 0))
  (rle-array-1 input output width height dx dy :version 2))

(defun 1rle-array-10 (input &optional output 
		  (width (decode-raster-array input))
		  (height (multiple-value-bind (nil h) (decode-raster-array input) h))
		  (dx 0) (dy 0) &key (version 1))
  (when si:*sheet-to-prepare*
    (setq input (list si:*sheet-to-prepare* input)))

  (rle-array-1-internal
    input output width height dx dy :version version))

(defun 1rle-array-1-internal
0       (input &optional output
	(width (decode-raster-array input))
	(height (multiple-value-bind (nil h) (decode-raster-array input) h))
	(dx 0) (dy 0) &key (version 1) (component si:*shift*) (image-type si:*image-type*))

  (let* ((sheet (if (listp input) (first input)))
	 (in (if (listp input) (second input) input))
	 (elt-size (si:array-element-byte-size in))
	 (width (// width (image-width-multiplier image-type)))
	 temp-input-line
	 (temp-input-idx dy)
	 line-continuation
	 )
    (unwind-protect
	(tv:with-prepared-sheet-or-raster ((or sheet input) :force-prepare t )
	  (cond ((< elt-size 8)
		 (setq width (// width (// 8 elt-size)))
		 (let ((rounded-width (* (ceiling width 4) 4)))
		   (cond ((si:array-indirect-p in)
			  ;;
			  ;; with an indirect art-1b, we have to copy it, since
			  ;; making a displaced array into a random indirect
			  ;; array may not work
			  ;;
			  (setq temp-input-line (tv:allocate-temp-sheet-raster-and-header
						  (list 1 rounded-width)
						  ':type 'art-8b
						  )
				line-continuation
				#'(lambda ()
				    (declare (sys:downward-function))
				    (bitblt tv:alu-seta width 1
					    in dx temp-input-idx temp-input-line 0 0)
				    (incf temp-input-idx)
				    0)))
			 (t
			  (setq temp-input-line (tv:allocate-temp-sheet-raster-and-header
						  (list height rounded-width)
						  :type 'art-8b
						  :displaced-to in
						  :displaced-conformally t))
			  ))))
		((> elt-size 8) (setq elt-size 8)))

	  (let* ((default-image-type (default-image-type in))
		 (image-type (or image-type default-image-type))
		 (component (if (fixp component) (// component 8) component))
		 (buffer-size (+ 6 (ceiling (// (* width height) 1.75)))))
	    (tv:with-temp-sheet-raster (out buffer-size :type 'art-16b )
	      (let ((compressing-stream (make-instance 'compressing-stream
						       :buffer out
						       :width (if (memq component '(:U :V))
								  (// width 2) width)
						       :height height
						       :elt-size elt-size)))
	      

		(setup-buffer compressing-stream version)

		(cond ((eq default-image-type '32b-image)
		       (compress-32b-rectangle
			 compressing-stream
			 width height in dx dy component))
		      ((eq image-type 'packed-rgb-image)
		       (compress-rgb-rectangle
			 compressing-stream
			 width height in dx dy component))
		      ((eq image-type 'packed-yuv-image)
		       (compress-yuv-rectangle
			 compressing-stream
			 width height in dx dy component))
		      (line-continuation
		       (compress-8b-rectangle-continuation
			 compressing-stream
			 width height temp-input-line 0 0 line-continuation))
		      (t (compress-8b-rectangle
			   compressing-stream
			   width height (or temp-input-line in) dx dy ))
		     )

		(finish-buffer compressing-stream)

		(let ((end (1+ (compressing-stream-rect-outi compressing-stream))))
		  (values
		    (if output
			(funcall output out end) 
			(let ((val (make-array end ':type 'art-16b))
			      (out out))
			  (declare (array-register-1d val buffer))
			  (loop for i from 0 below end do
			    (setf (aref val i) (aref out i)))
			  val))
		    (// (* end 16.0) (* width height 8))
		    ))
		))))
2      ;unwind protected
0      (when temp-input-line
	(tv:deallocate-temp-sheet-raster-and-header temp-input-line))
      )
    ))

(defmethod (:rld-1 rle-mixin) (input output  )
  (rld-array-1-internal input output width height))

(defmethod (:rld-2 rle-mixin) (input output  )
  (rld-array-1-internal input output width height 0 0 0 0 :version 2))


(defun rld-array-2 (stream array n-bytes dims ddx ddy sdx sdy wid hei element-size)
  (rld-array-1 stream array n-bytes dims ddx ddy sdx sdy wid hei element-size
	       :version 2 ))

(defun rld-array-1
       (stream array n-bytes dims ddx ddy sdx sdy wid hei element-size
	&key (version 1)
	)
  (with-stack-list (sp stream
		       n-bytes
		       (first dims)
		       (second dims)
		       element-size)
    (with-stack-list (win si:*sheet-to-prepare* array)
      (rld-array-1-internal
	sp
	(if (typep si:*sheet-to-prepare* 'tv:sheet)
	    win
	    array)
	wid hei
	ddx ddy
	sdx sdy
	:version version))
    )
  )

#|

  This function suffers from that common killer of young programs: excess of hair

  Input can be either an art-16b containing an encoded image, or a list consisting
        of stream pointer to a binary stream, the number of bytes expected from the 
	stream, and the two dimensions of the array to be decoded.

  Output can be an array or a window or a list consisting of an array and a window.
        If a window is specified, its screen array will be used if there is no array
	specified, and it will be prepared while writing into the array.  No I/O 
	is done while the sheet is prepared.

  Width and Height are the limiting values for width and height

  WDX and WDY are the initial X,Y of the destination
  DX and DY are the initial X,Y of the source
 	The code fast-skips the initial DX,DY, and ultra-fast skips the trailing
	bytes from the stream if one is used.

|#

(defconst *min-buffer-size* 25000.)
(defconst *min-string-in-size* 1024.)
(defvar *async-fill-input-buffer* :non-local)
(defvar *async-fill-priority* 1)
2;;
;; This is a sort-of stream which presents a compressed data stream
;; as a rectangle.  The data stream can be either an array in memory
;; or a real input stream.  If it's a real stream, it can be read 
;; asynchronously by a separate process, and in any case the reading
;; occurs in line-sized chunks outside the prepare-sheet.
;;
0(defflavor1 compressed-rectangle
0	(in-width		2;basic description of the compressed stream and
0	 in-height		2;uncompressed rectangle
0	 in-file
	 input-length
	 in-length 
	 original-in-length
	 ibits-per-elt
	 8b-in-width 

	 (rect-in)		2;these RECT-xx variables are loaded into locals
0	 (rect-in-buffer)	2;in the gust of the decoding loop.  They have to be
0	 (rect-ini 0)		2;uncached when communicating with the asynchronous reader
0	 (rect-ac 0)		2;and at the exit from the process-rectangle loop.
0	 (rect-acc 0)
	 (rect-loop 0)
	 (rect-point 0)

	 fill-input-buffer	2;controls for the asynchronous reader
0	 wait-function
	 min-in-buffer
	 (async-filler-error)
	 (first-pointer)
	 (async-filler)
	 (from-field)
	 (to-field)
	 (allocated-in)
	 )
	()
  :writable-instance-variables
  :initable-instance-variables)

2;;
;; Controls for the reader.  The basic protocol requires that there
;; be a full line of data available before any part of the line is 
;; decoded - this is so the physical I/O can be done while interrupts
;; are momentarily enables between lines.
;;
0(defmethod (1reset-filler-process0 compressed-rectangle) ()
  (when async-filler
    (setq async-filler-error :reset)
    (send async-filler :reset)
    (setq async-filler nil))
  (when allocated-in
    (tv:deallocate-temp-sheet-raster-and-header allocated-in)))

(defmethod (1finish-input0 compressed-rectangle) ()
  (when (and in-file (> in-length 0))
    (if async-filler

	(if first-pointer
	    (progn (setq async-filler-error :reset)
		   (send async-filler :reset)
		   (setq async-filler nil)
		   (send in-file :set-pointer (+ first-pointer original-in-length)))
	    (loop while (> in-length 0)
		  do (setq rect-ini rect-in-buffer)
		     (process-wait "Await filler"
		       #'(lambda ()
			   (or (= in-length 0)
			       ( rect-ini rect-in-buffer))))))
	(if first-pointer
	    (let ((new (+ first-pointer original-in-length)))
	      (si:set-stream-pointer in-file new (- new in-length)) )
	    (loop while (> in-length 0)
		  do 
	      ;; force the rest of the i/o to finish
	      (send in-file :string-in nil rect-in 0 (min in-length input-length))
	      (decf in-length input-length))))))

(defmethod (1setup-filler0 compressed-rectangle)
	   (&optional (async-io *async-fill-input-buffer*))

  (if (and in-file
	   async-io
	   (or (eq *async-fill-input-buffer* t)
	       (let* ((path (send in-file :truename))
		      (host (send path :host)))
		 (not (or (eq host net:*local-host*)
			  (and (typep path 'fs:fep-pathname)
			       (eq (send host :host) net:*local-host*)))
		      ))))

      (setq fill-input-buffer #'await-input-buffer-filled
	    async-filler (process-run-function
			   `(:name "Fill Buffer"
			     :priority
			     ,(+ *async-fill-priority*
				 (send tv:current-process :priority))
			     )
			   #'async-fill-input-buffer
			   self
			   #'room-to-fill-p)
	    wait-function #'room-to-empty-p)

      (setq fill-input-buffer #'assure-input-buffer-filled
	    wait-function #'not-room-to-empty-p)

      ))

(defmethod (1assure-input-buffer-filled0 compressed-rectangle) (wait)
  (loop while (funcall wait self)
	as max-xfer = (min in-length *min-string-in-size*)
	as last = (if ( rect-ini rect-in-buffer)
		      (min (- input-length (if (zerop rect-ini) 1 0))
			   (+ rect-in-buffer max-xfer))
		      (min (1- rect-ini)
			   (+ rect-in-buffer max-xfer)))
	   #||
	as start-time = (time:microsecond-time)
	   ||#
	do
    (send in-file :string-in nil rect-in rect-in-buffer last)
    #||
    (when *monitor*
      (funcall *monitor* self start-time (time:microsecond-time)))
    ||#
    (let ((new-len (- last rect-in-buffer))
	  (new-in-b (if (= last input-length) 0 last)))
      (setq rect-in-buffer new-in-b)
      (decf in-length new-len))
    ))

(defmethod (1room-to-fill-p0 compressed-rectangle) ()
  (and (> in-length 0)
       (> (- input-length (mod (- rect-in-buffer rect-ini) input-length))
	  (min in-length *min-string-in-size*))))

(defmethod (1room-to-empty-p0 compressed-rectangle) ()
  (when (or (zerop in-length)
	    ( (mod (- rect-in-buffer rect-ini) input-length)
	       min-in-buffer)
	    async-filler-error)
    rect-in-buffer))

(defmethod (1not-room-to-empty-p0 compressed-rectangle) ()
  (not (room-to-empty-p self)))

(defmethod (1async-fill-input-buffer0 compressed-rectangle) (wait)
  (unwind-protect
      (condition-case (err)
	   (loop until (zerop in-length) do
	     (process-wait "Await emptier" wait self)
	     (assure-input-buffer-filled self wait))
	 (sys:error
	   (setq async-filler-error err)))
    (unless (or async-filler-error (zerop in-length))
      (ferror "buffer not emptied!"))
    ))

(defmethod (1await-input-buffer-filled0 compressed-rectangle) (wait)
  (process-wait "Await filler" wait self)
  (when async-filler-error
    (sys:eval-in-instance async-filler-error
			  '(setq dbg:status :just-created))
    (signal async-filler-error)
    ))


2;;
;; Macros to assist in the decoding of the compressed stream.
;; these guys know the names of locals and instance variables
;; used in the decoding process, so they are very closely coupled
;; to their current callers.
;;
0(defmacro-in-flavor (1putb0 compressed-rectangle) (nb)
  2;put back a few bits you have just taken
0  `(decf acc ,nb))

(defmacro-in-flavor (1getb0 compressed-rectangle) (nb)
  2;get a few bits
0  `(progn
     (if (> acc ,(- nb))      ;;not enough bits in fetched word
	 (cond ((and (eql ini in-buffer)
		     (eql ini (setq in-buffer rect-in-buffer)))
		(cond (( acc 0)
		       (ferror "Not enough bits in the encoded array!"))
		      (t
		       ;;allow an overdraft of a few bits.  This is needed because
		       ;;the primary dispatch grabs 5 bits
		       (incf acc ,nb))))
	       (t 
		(setq ac (si:%logdpb ac (byte 16. 16.) (aref in ini)))
		(let ((new (1+ ini)))
		  (if (eql new input-length)
		      (setq ini 0)
		      (setq ini new)))
		(decf acc ,(- 16. nb))))
	 ;; get the bits
	 (incf acc ,nb))
     ,@(if (fixp nb)
	   `((si:%logldb (byte ,nb 0) (lsh ac acc)))
	   `((load-byte ac acc ,nb)))))

(defmacro-in-flavor (1unrolled-body0 compressed-rectangle)
		    ((reps-variable &optional (unroll-factor 8)) &body  body)
  2;; unroll a loop to eliminate loop overhead from repetitive operations
0  (let ((tags (loop for i from 1 to unroll-factor
		    collect (intern (format nil "L-~D" i)))))
  `(tagbody 
     (selector ,reps-variable eql
       ,@(loop for i from 1 to unroll-factor
	       as tag in tags
	       collect `(,i (go ,tag))))
     ,@(loop for tag in (reverse tags)
	     nconc `(,tag (progn ,@body)))
     (decf ,reps-variable ,unroll-factor)
     )))


(defmacro-in-flavor (1process-compressed-rectangle0 compressed-rectangle) 
		    ((height &key
			     (width '8b-in-width)
			     (array-registers)
			     dest (sdx 0) (wdx 0)(wdy 0)
			     (dest-inc 1)
			     loop-option
			     indirect-dest
			     line-continuation
			     (to-field 'to-field)
			     (from-field 'from-field))
		     &body body)
  2;;
0  2;; this is the hairy mother.  It processes some number of complete lines
0  2;; of compressed data, actually using some subinterval of each line and
0  2;; discarding the rest.
0  2;; The body is a form, which has to know the internal state of the decoder,
  ;; which is to be executed on each decoded pixel.
0  2;;
0  (labels ((put-point-loop (do-it)
	     `(progn
		,@(when (memq do-it '(:pre-noop :post-noop))
		    `((let ((dif (- ,(if (eq do-it :post-noop) 'last-idx 'spani) idx)))
			(when (> dif 0)
			  ,(if (= dest-inc 1)
			       `(if (> dif loop)
				    (setq idx (+ idx loop)
					  loop 0)
				    (incf idx dif)
				    (decf loop dif))
			       `(let ((dif2 (// dif ,dest-inc)))
				  (if (> dif2 loop)
				      (setq idx (+ idx (* loop ,dest-inc))
					    loop 0)
				      (incf idx dif)
				      (decf loop dif2))))
			  ))))
		,@(when (neq do-it :post-noop)
		    `((loop with maxc = ,(if (= dest-inc 1)
					     `(- spanx idx)
					     `(// (- spanx idx) ,dest-inc))
			    with ct = (if (> maxc loop) loop maxc)
			    while (> ct 0)
			    do (unrolled-body (ct 10)
				 ,@body (incf idx ,dest-inc))
			    finally
			      (if (> maxc loop)
				  (setq loop 0)
				  (decf loop maxc))
			      )))
		)
	     )
	   (put-point (do-it)
	     `(progn
		,@(unless (memq do-it '(:pre-noop :post-noop))
		    body)
		(incf idx ,dest-inc)
		))
	   (decode-byte (looping do-it)
	     `(let ((v (getb 5)))
		(selector v eql
		  ((#o20 #o21 #o22 #o23 #o24 #o25 #o26 #o27
		    #o30 #o31 #o32 #o33 #o34 #o35 #o36 #o37)
2		   ;constants
0		   (setq point (%logdpb v (byte 4 4) (getb 4)))
		   ,@(when (eq loop-option :debug)
		       `((incf op-constant)
			 (setf (aref results debug-idx)
			       (dpb #o20 (byte 5 26) point))
			 (setq debug-idx (if (= debug-idx 7) 0 (1+ debug-idx)))))
		    ,@(when (eq loop-option :explain)
			'((format t "~%const ~A" point)))
		    ,(if looping '(loop-finish) (put-point do-it)))
		  (#o0 (incf point)
		   ,@(when (eq loop-option :debug)
		       `((incf op-increment)
			 (setf (aref results debug-idx)
			       (dpb #o00 (byte 5 26) point))
			 (setq debug-idx (if (= debug-idx 7) 0 (1+ debug-idx)))))
		   ,@(when (eq loop-option :explain)
		       '((format t " += ~d" point)))
		   ,(if looping '(loop-finish) (put-point do-it)))
		  (#o1 (incf point 2)
		   ,@(when (eq loop-option :debug)
		       `((incf op-increment)
			 (setf (aref results debug-idx)
			       (dpb #o01 (byte 5 26) point))
			 (setq debug-idx (if (= debug-idx 7) 0 (1+ debug-idx)))))
		   ,@(when (eq loop-option :explain)
		       '((format t " += ~d" point)))
		   ,(if looping '(loop-finish) (put-point do-it)))
		  (#o2 (incf point 3)
		   ,@(when (eq loop-option :debug)
		       `((incf op-increment)
			 (setf (aref results debug-idx)
			       (dpb #o02 (byte 5 26) point))
			 (setq debug-idx (if (= debug-idx 7) 0 (1+ debug-idx)))))
		   ,@(when (eq loop-option :explain)
		       '((format t " += ~d" point)))
		   ,(if looping '(loop-finish) (put-point do-it))
		   )
		  (#o3 (incf point 4)
		   ,@(when (eq loop-option :debug)
		       `((incf op-increment)
			 (setf (aref results debug-idx)
			       (dpb #o03 (byte 5 26) point))
			 (setq debug-idx (if (= debug-idx 7) 0 (1+ debug-idx)))))
		   ,@(when (eq loop-option :explain)
		       '((format t " += ~d" point)))
		   ,(if looping '(loop-finish) (put-point do-it))
		   )
		  (#o4 (decf point)
		   ,@(when (eq loop-option :debug)
		       `((incf op-decrement)
			 (setf (aref results debug-idx)
			       (dpb #o04 (byte 5 26) point))
			 (setq debug-idx (if (= debug-idx 7) 0 (1+ debug-idx)))))
		   ,@(when (eq loop-option :explain)
		       '((format t " -= ~d" point)))
		   ,(if looping '(loop-finish) (put-point do-it))
		   )
		  (#o5 (decf point 2)
		   ,@(when (eq loop-option :debug)
		       `((incf op-decrement)
			 (setf (aref results debug-idx)
			       (dpb #o5 (byte 5 26) point))
			 (setq debug-idx (if (= debug-idx 7) 0 (1+ debug-idx)))))
		   ,@(when (eq loop-option :explain)
		       '((format t " -= ~d" point)))
		   ,(if looping '(loop-finish) (put-point do-it))
		   )
		  (#o6 (decf point 3)
		   ,@(when (eq loop-option :explain)
		       '((format t " -= ~d" point)))
		   ,@(when (eq loop-option :debug)
		       `((incf op-decrement)
			 (setf (aref results debug-idx)
			       (dpb #o6 (byte 5 26) point))
			 (setq debug-idx (if (= debug-idx 7) 0 (1+ debug-idx)))))
		   ,(if  looping '(loop-finish) (put-point do-it))
		   )
		  (#o7 (decf point 4)
		   ,@(when (eq loop-option :debug)
		       `((incf op-decrement)
			 (setf (aref results debug-idx)
			       (dpb #o7 (byte 5 26) point))
			 (setq debug-idx (if (= debug-idx 7) 0 (1+ debug-idx)))))
		   ,@(when (eq loop-option :explain)
		       '((format t " -= ~d" point)))
		   ,(if looping '(loop-finish) (put-point do-it))
		   )
		  ((#o10 #o11 #o12 #o13)
		   ;copy followed by something else
		   ,@(when (eq loop-option :debug)
		       `((incf op-copy)
			 (setf (aref results debug-idx)
			       (dpb #o10 (byte 5 26) point))
			 (setq debug-idx (if (= debug-idx 7) 0 (1+ debug-idx)))))
		   ,@(when (eq loop-option :explain)
		       '((format t " copy ~d" point)))
		   (putb 2) ;put back two bits
		   ,(if looping '(loop-finish) (put-point do-it))
		   )
		  (#o16 ;repeat
		   ,@(unless looping
		       `((loop doing
			   (setq loop
				 (logior (lsh loop 8)
					 (ldb (byte 8 0) (getb 9))))
			   ,@(when (eq loop-option :debug)
			       `((incf op-repeat)
				 (setf (aref results debug-idx)
				       (dpb #o26 (byte 5 26) loop))
				 (setq debug-idx (if (= debug-idx 7) 0 (1+ debug-idx)))))
			   ,@(when (eq loop-option :explain)
			       '((format t "< loop = ~a" loop)))
			   ,(decode-byte t do-it)
			       finally ,(put-point-loop do-it)
				       ,@(when (eq loop-option :debug)
					   `((incf op-constant)
					     (setf (aref results debug-idx)
						   (dpb #o20 (byte 5 26) point))
					     (setq debug-idx (if (= debug-idx 7)
								 0 (1+ debug-idx)))))
				       ,@(when (eq loop-option :explain)
					   '((format t "> ")))
				       ))))
		  ((#o14 #o15 #o17)
		   (putb 5)
		   (ferror "~A is an invalid op" (getb 5))
		   )))))
    `(,@(if (and dest body)
	    `(tv:with-prepared-sheet-or-raster
	       (,dest :force-prepare t :span span :array out))
	    '(progn))
       (,@(if indirect-dest
	      `(with-stack-array (indirect-out (* (array-length out) ,dest-inc)
					       :type 'art-8b
					       :displaced-to out))
	      `(progn))
       (let ((in rect-in)
	     ,@(when indirect-dest
		 `(,@(unless line-continuation `((span (* span ,dest-inc))))
		   (out indirect-out)))
	     ,@array-registers
	     )

	 (declare (sys:array-register
		    in
		    ,@(when indirect-dest `(out))
		    ,@(loop for (a) in array-registers collect a)
		    ))
       
       (loop with ini = rect-ini and last-time =  (time:fixnum-microsecond-time)
	     and in-buffer = rect-in-buffer
	     and ac = rect-ac
	     and acc = rect-acc 
	     and loop = rect-loop 
	     and point = rect-point
	     and dwidth = ,width
	     ,@(when from-field `(as line first 1 then (if (= line 1) 2 1)))
	     repeat ,height
	       ,@(cond ((or (null body)(null dest))
			`(as spani = 0))
		       (line-continuation
			`(as spani = (+ ,wdx (funcall ,line-continuation))))
		       (t `(as spani from (+ (* (+ ,wdy
						   ,@(when to-field
						       `((if (and ,to-field (null ,from-field))
							     (1- ,to-field)
							     0))))
						span)
					     ,wdx)
			       by (if (and ,to-field (null ,from-field))
				      (+ span span)
				      span))))
	     as spanx = (+ spani ,(if (= dest-inc 1) 'dwidth `(* dwidth ,dest-inc )))
	   do
	 (ignore spanx)
	 (setq rect-ini ini)

	 (when (> (time:time-difference (time:fixnum-microsecond-time) last-time)
		  500000)
	   (allow-sheet-activity)
	   (setq in-buffer rect-in-buffer)
	   (setq last-time (time:fixnum-microsecond-time)))

	 (when (and in-file
		    (< (mod (- in-buffer ini) input-length) min-in-buffer)
		    (> in-length 0))
	   (tv:unprepare-sheet
	     ;; do I/O without prepared sheet
	     (funcall fill-input-buffer self wait-function))
	   (setq in-buffer rect-in-buffer)
	   (setq last-time (time:fixnum-microsecond-time))
	   )

	 (let* ((idx (- spani ,(if (= dest-inc 1) sdx `(* ,sdx ,dest-inc))))
		(last-idx (+ idx ,(if (= dest-inc 1)
				      '8b-in-width
				      `(* 8b-in-width ,dest-inc ))))
		)

	   (if (and ,from-field (not (eql line ,from-field)))
	       (unless ,to-field
		 ,@(when body
		     `((decf spani span))))
	       ,@(when body
		   `(				;skip leading bytes
		     (when (> loop 0) ,(put-point-loop :pre-noop))
2						;(format t "~&skip leading #~A  ~A ~A ~A" loop spani idx spanx)
0		     (loop while (< idx spani) do ,(decode-byte nil :pre-noop))
2						;these are the real ones
						;(format t "~&do it #~A  ~A ~A ~A = ~A" loop spani idx spanx)
0		     (loop while (< idx spanx) do ,(decode-byte nil t))
		     )))
2	   ;skip trailing bytes
0	   (when (> loop 0) ,(put-point-loop :post-noop))
	   (loop while (< idx last-idx) do ,(decode-byte nil :post-noop))
	   )
       ,@(when (eq loop-option :explain)
	   '((format t "~&exit row, loop = ~d point = ~d~%" loop point)))
       finally 
	 ,@(when line-continuation `((funcall ,line-continuation)))
	 ;repack the state variables
	 (decf in-height ,height)
	   (setq rect-ini ini
		 rect-ac ac
		 rect-acc acc 
		 rect-loop loop 
		 rect-point point)
       ))))))

(defmethod (1skip-compressed-lines0 compressed-rectangle) (n)
  2;; skip leading lines of the compressed image
0  (when (> n 0) (process-compressed-rectangle (n)))
  )

(defmethod (1tv:with-bit-array-or-stream0 compressed-rectangle)
	   (direction continuation &rest args)
  (lexpr-send self :with-bit-array-stream direction continuation args)
  )

(defmethod (1tv:with-bit-array0 compressed-rectangle)
	   (direction continuation &rest args)
  (lexpr-funcall #'tv:bit-array-stream-as-bit-array
		 self direction continuation args)
  )

(defmethod (1tv:with-bit-array-stream0 compressed-rectangle)
	   (direction continuation
		      &key
		      (x-offset 0)
		      (y-offset 0)
		      (width in-width)
		      (height in-height)
		      from-field
		      (stream-height in-height)
		      (minimum-rows 1)
		      temporary-raster
		      &allow-other-keys)

  (check-arg direction (eq direction :input) "Direction must be :INPUT")
  (when (> y-offset 0)
    (skip-compressed-lines  self y-offset)
    (decf stream-height y-offset))

  (multiple-value-bind (e-dx dx)
      (floor x-offset (// 8 ibits-per-elt))
    (let* ((e-width (ceiling (+ dx width) (// 8 ibits-per-elt)))
	   (e-height (min height minimum-rows))
	   allocated-temp-raster
	   allocated-temp-raster-2
	   (round-to (// 32 ibits-per-elt))
	   (rounded-width (* round-to (ceiling (+ width dx) round-to )))
	   (temp-raster temporary-raster))

      (unwind-protect

	  (progn
	    (unless temp-raster 
	      (with-stack-list (dims e-height rounded-width)
		(setq allocated-temp-raster
		      (TV:ALLOCATE-TEMP-SHEET-RASTER-AND-HEADER
			dims
			:TYPE (DATA-ARRAY-TYPE
				IBITS-PER-ELT)
			:DISPLACED-TO)
		      temp-raster allocated-temp-raster))
	      )
	    (let ((temp-raster-2
		    (if (eq (si:array-type temp-raster) 'art-8b)
			temp-raster
			(with-stack-list (dims e-height e-width)
			  (setq allocated-temp-raster-2
				(tv:allocate-temp-sheet-raster-and-header
				  dims
				  :type 'art-8b 
				  :displaced-to temp-raster)
				)))))

	      (multiple-value-bind (nil nil e-span) (decode-raster-array temp-raster)
		(let ((next-index  dx)
		      (skip-line (eql from-field 2))
		      (lim-span (* e-span e-height)))
		  (labels ((process-1-row ()
			     (when (and skip-line
					(> height 0))
			       (skip-compressed-lines self 1)
			       (decf height))
			     (setq skip-line from-field)
			     (if (zerop height)
				 :end
				 (process-compressed-rectangle
				   (1 :width e-width
				      :sdx e-dx
				      :dest temp-raster-2
				      :to-field nil
				      :from-field nil)
				   (setf (aref out idx) point))
				 (decf height)
				 (prog1 next-index
					(incf next-index e-span)
					(when ( next-index lim-span)
					  (setq next-index dx))))))
		    (decf stream-height height)
		    (funcall continuation temp-raster nil #'process-1-row)
		    (skip-compressed-lines self (+ height stream-height ))
		    ))))
						2;end of unwind protect
0	    )
	(when allocated-temp-raster-2
	  (tv:deallocate-temp-sheet-raster-and-header allocated-temp-raster-2))
	(when allocated-temp-raster
	  (tv:deallocate-temp-sheet-raster-and-header allocated-temp-raster))))))


(defmethod (1expand-compressed-rectangle-debug0 compressed-rectangle) (n)
  2;expand the compressed image and print info about the decoding process.
0  (let ((op-constant 0)
	(op-increment 0)
	(op-decrement 0)
	(op-repeat 0)
	(op-copy 0)
	(debug-idx 0)
	(results (make-array 8)))

    (declare (sys:array-register results))

    (process-compressed-rectangle (n :loop-option :debug))

    `(:constant ,op-constant
      :increment ,op-increment
      :decrement ,op-decrement
      :copy ,op-copy
      :repeat ,op-repeat)))

(defmethod (1expand-compressed-rectangle-explain0 compressed-rectangle) (n)
  2;expand the compressed image and print info about the decoding process.
0    (process-compressed-rectangle (n :loop-option :explain))
    )

(defmethod (1expand-compressed-rectangle-8b0 compressed-rectangle)
	   (width nlines dx dest wdx wdy)
  2;normal expansion of some lines into an art-8b
0  (process-compressed-rectangle
    (nlines :width width :sdx dx :wdx wdx :wdy wdy :dest dest)
    (setf (aref out idx) point)))

(defmethod (1expand-compressed-rectangle-8b-mapped0  compressed-rectangle)
	   (width nlines dx dest wdx wdy map)
  2;expansion of lines into an art-32b, expanding from 8.
0  (process-compressed-rectangle
    (nlines :width width :sdx dx :wdx wdx :wdy wdy :dest dest
	    :array-registers ((map map)))
    (setf (aref out idx) (aref map point))))


(defmethod (1expand-compressed-rectangle-32b 0compressed-rectangle)
	   (width nlines dx dest wdx wdy phase)
  2;expand into one channel of an art-32b
0  (let ((wdx (+ (* wdx 4)
		(selectq phase (:red 0)(:green 1)(:blue 2)(:alpha 3)(t phase)))))
    (declare (sys:array-register map))
    (process-compressed-rectangle
      (nlines :width width :sdx dx :wdx wdx :wdy wdy :dest dest :dest-inc 4 :indirect-dest t)
      (setf (aref out idx) point))))

(defmethod (1expand-compressed-rectangle-packed-rgb 0compressed-rectangle)
	   (width nlines dx dest wdx wdy phase)
  2;expand into one channel of a packed-rgb image
0  (let ((wdx (+ (* wdx 3)
		(selectq phase (:red 0)(:green 1)(:blue 2)(t phase)))))
    (process-compressed-rectangle
      (nlines :width width :sdx dx :wdx wdx :wdy wdy :dest dest :dest-inc 3)
      (setf (aref out idx) point))))

(defmethod (1expand-compressed-rectangle-packed-yuv 0compressed-rectangle)
	   (width nlines dx dest wdx wdy phase)
						2;expand into one channel of a packed-yuv image
0  (let ((wdx (+ (* wdx 2)
		(selectq phase (:y 1)(:u 0)(:v 2)))))
    (selectq phase
      (:Y
       (process-compressed-rectangle
	 (nlines :width width :sdx dx :wdx wdx :wdy wdy :dest dest :dest-inc 2)
	 (setf (aref out idx) point))
       )
      ((:U :V)
       (process-compressed-rectangle
	 (nlines :width width :sdx dx :wdx wdx :wdy wdy :dest dest :dest-inc 4)
	 (setf (aref out idx) point))
       ))))

(defmethod (1expand-compressed-stream-general0 compressed-rectangle)
	   (width nlines dx dest wdx wdy image-type to-image-type write-mask map
		  window component window-map)

  (when (null map)
    (when (memq image-type '(8b-random-image 8b-palette-image))
      (setq image-type 'false-color-image))
    (when (memq to-image-type '(8b-random-image 8b-palette-image))
      (setq to-image-type 'false-color-image)))

  (let ((store (cond ((null component) :default)
		     ((fixp component)
		      (selector component eql
			(0 :red)
			(8 :green)
			(16 :blue)
			(24 :alpha)
			(t (ferror "invalid component ~A" component))))
		     (t component))))
    (tv:with-bit-array-stream
      self :input
      #'(lambda (raster ignore stream)
	  (color:zoom-rectangle
	    :from-image-type image-type
	    :from-array raster
	    :from-left 0
	    :from-top 0
	    :from-right width
	    :from-bottom (cond ((eql from-field 1)(ceiling nlines 2))
			       ((eql from-field 2)(floor nlines 2))
			       (t nlines))
	    :from-array-stream stream
	    :to-array dest
	    :to-left wdx
	    :to-top wdy
	    :to-right (+ wdx (ROUND (* SI:*DEST-X-SCALE* width)))
	    :to-bottom (+ wdy (ROUND (* SI:*DEST-Y-SCALE* nlines)))
	    :to-image-type  to-image-type
	    :write-mask write-mask
	    :to-window window
	    :store store
2	      ;;; From-field is handled by the stream :from-field from-field
0	    :to-field to-field
	    :rescale si:*dest-rescale*
	    :combination-array window-map
	    :default-alpha si:*default-alpha*
	    :translation-array map))
      :x-offset dx
      :y-offset 0
      :from-field from-field
      :width width
      :height nlines
      )))


(defun1 make-compressed-input-stream
0       (&key (input) (version 1) (async-io *async-fill-input-buffer*)(from-field)(to-field))

  (let (in in-length in-buffer in-file input-length ibits-per-elt iwidth iheight
	(acc 0)(ini 0)(ac 0) first-pointer
	allocated-in
	min-in-buffer)
  
    (if (arrayp input)
	  
	(macrolet ((getw ()
		     `(prog1 (logior (lsh (aref in ini) 16)
				     (progn (incf ini)
					    (aref in ini)))
			     (incf ini))))
	  (setq in input
		in-length (array-length input)
		in-buffer in-length
		input-length (array-length input)
		ibits-per-elt (if (= version 1)
				  8
				  (getw))
		iwidth (getw)
		iheight (getw)
		))

	(setq in-file (first input)
	      first-pointer (when in-file
			      (send in-file :send-if-handles :read-pointer))
	      in-length (second input)
	      iwidth (third input)
	      iheight (fourth input)
	      ibits-per-elt (if (= version 1) 8 (or (fifth input) 8))
	      min-in-buffer (round (* 1.2 (// iwidth (max 1 (// 16 ibits-per-elt )))))
	      input-length (min (1+ in-length)
				(max *min-buffer-size*  (* 3 min-in-buffer)))
	      in (tv:allocate-temp-sheet-raster-and-header input-length ':type 'art-16b)
	      allocated-in in
	      in-buffer 0)
  	)
    
    (let* ((ibits (min 8 ibits-per-elt))
	   (comp-stream (make-instance 'compressed-rectangle
				       :rect-in in
				       :rect-in-buffer in-buffer
				       :rect-acc acc
				       :rect-ini ini
				       :rect-ac ac
				       :first-pointer first-pointer
				       :in-file in-file
				       :in-length in-length
				       :original-in-length in-length
				       :in-width iwidth
				       :in-height iheight
				       :input-length input-length
				       :ibits-per-elt ibits
				       :8b-in-width (ceiling iwidth (// 8 ibits))
				       :min-in-buffer min-in-buffer
				       :from-field from-field
				       :to-field to-field
				       :allocated-in allocated-in
				       )))
      (setup-filler comp-stream async-io)
      comp-stream
      )
    ))

(defvar *monitor* nil)

#|| ;some metering hacks
  
  (defvar *monitor* '*monitor*)
  
  (defvar *monitored-data* nil)
  (defstruct (monitor-block :named-array (:conc-name nil))
    data-remaining buffer-size take fill fill-to read-start read-finish)
  
  (defun *monitor* (buffer remaining ini from to start finish)
    (let ((new-block (make-monitor-block
		       buffer-size (array-length buffer)
		       data-remaining remaining
		       take ini
		       fill from
		       fill-to to
		       read-start start
		       read-finish finish)))
      (push new-block *monitored-data*))
      )
  
  (defun plot-segmented-data (data window)
    (multiple-value-bind (w h) (send window :inside-size)
      (let* ((first-item (first data))
	     (start-time (read-start first-item))
	     (last-item (car (last data)))
	     (time-interval (time:time-difference
			      (read-finish last-item)
			      start-time))
	     (buffer-interval (buffer-size first-item))
	     (x-scale (// w (float time-interval)))
	     (y-scale (// h (float buffer-interval))))
	(send window :clear-window)
	(loop for item in data
	      as pre-il = 0 then il
	      as pre-ir = 0 then (+ il iw)
	      as pre-it = 0 then it
	      as iw = (max 1 (round (* x-scale (time:time-difference
						 (read-finish item)
						 (read-start item)))))
	      as ih = (max 1 (round (* y-scale (- (fill-to item)
						  (fill item)))))
	      as il = (round (* x-scale (time:time-difference
					  (read-start item)
					  start-time)))
	      as it = (- (round (* y-scale (mod (- (take item) (fill item))
						buffer-interval)))
			 ih)
	      do
	  (send window :draw-rectangle iw ih il it)
	  (when (< pre-ir il) 
	    (send window :draw-1-bit-raster (- il pre-ir) (abs (- it pre-it))
		  tv:50%-gray 0 0	pre-ir pre-it
		  ))
	  (send window :send-if-handles :primitive-item :active item
		il it (+ il iw) (+ it ih ))
	)
	(loop with second = (* x-scale 1e6)
	      for i from second below (* x-scale time-interval) by second
	      do
	  (send window :draw-line (round i) 0 (round i) 10 tv:alu-xor))
	)))
  
  (defun segment-monitored-data (&optional (data *monitored-data*))
    (loop with fd = data
	  for d first data then nd
	  as nd on (cdr data)
	  when (< (data-remaining (car nd))
		  (data-remaining (car d)))
	    collect
	    (progn (setf (cdr d) nil)
		   (prog1 (nreverse fd)
			  (setq fd nd))) into val
	      finally
		(nconc val (list (nreverse fd)))
		))
  

  
  
  (defvar image (make-image 'b&w-image :name "test"))
  (defvar *frame* 1)
  
  (defun rld-array-1
	 (stream array n-bytes dims ddx ddy sdx sdy wid hei element-size
	  &key (version 1)
	  )
  
    (setq *monitored-data* nil)
    (with-stack-list (sp stream
			 n-bytes
			 (first dims)
			 (second dims)
			 element-size)
      (with-stack-list (win si:*sheet-to-prepare* array)
	(rld-array-1-internal
	  sp
	  (if (typep si:*sheet-to-prepare* 'tv:sheet)
	      win
	      array)
	  wid hei
	  ddx ddy
	  sdx sdy
	  :version version))
      )
    (setq *segmented* (nreverse *monitored-data*))
    (plot-segmented-data *segmented* w)
    (send image :take-image-from-window w :frame *frame* :edges :everything)
    (incf *frame*)
    )

||#						

(defun 1rld-array-1-internal
0       (input &optional output width height  (wdx 0) (wdy 0) (dx 0) (dy 0)
	&key
	(version 1)
	(component si:*shift*)
	(component-write-mask (selector component eql
				(:red #o377)
				(:green (lsh  #o377 8))
				(:blue (lsh #o377 16))
				(:alpha (lsh #o377 24))
				((:debug :Y :U :V nil) -1)
				(t (lsh #o377 component))))
	(image-type si:*image-type*)
	(write-mask (or si:*write-mask* -1))
	(dest-image-type si:*dest-image-type*)
	(map si:*color-map-translation*)
	(window-map si:*window-color-map-translation*)
	(from-field si:*from-field*)
	(to-field si:*to-field*)
	(continuation si:*continuation*)
	)

  (let* ((compressed-stream (make-compressed-input-stream :input input :version version
							  :from-field from-field
							  :to-field to-field))
	 (in input)
	 made-out
	 temp-dest-row
	 out
	 (width (min (or width (compressed-rectangle-in-width compressed-stream))
		     (- (compressed-rectangle-in-width compressed-stream)
			dx)))
	 (height (min (or height (compressed-rectangle-in-height compressed-stream))
		      (or (compressed-rectangle-in-height compressed-stream) dy)))
	 (window (cond ((listp output) (first output))
		       ((typep output 'tv:sheet)
			output)))
	 (ib (compressed-rectangle-ibits-per-elt compressed-stream))
	 )

    (if continuation

	(tv:with-bit-array-stream
	  compressed-stream :input continuation
	  :width width
	  :height height
	  :x-offset dx 
	  :y-offset dy)

	(unwind-protect

	    (let* ((out (cond ((if (listp output) (second output) output))
			      (window  nil)
			      (t (let* ((round-to (// 32 ib))
					(rounded-width (* round-to (ceiling width round-to))))
				   (with-stack-list (dims  height rounded-width)
				     (setq made-out (tv:allocate-temp-sheet-raster-and-header
						      dims
						      ':type (data-array-type ib))))
				   ))))
		   (dest-image-type
		     (or dest-image-type
			 (default-image-type (or window out))))
		   )
	      (tv:with-prepared-sheet-or-raster (window :array ar :screen scr)
		(let* ((out (cond ((arrayp out) out)
				  ((null out) ar)
				  ((symbolp out) (get-special-array scr ar out))))
		       (out-bpp (si:array-element-byte-size out))
		       )
      
						2;finally, the real work

0		  (multiple-value-bind (ow oh) (decode-raster-array out)
	  
		    (setq width (min (or width ow) (- ow wdx))
			  height (min (or height oh) (- oh wdy)))

		    (skip-compressed-lines compressed-stream dy)

		    (cond ((zerop (logand write-mask component-write-mask)))
			  ((eq component :debug)
			   (setq made-out (expand-compressed-rectangle-debug
					    compressed-stream height )))
			  ((or (< ib 8)
			       (< out-bpp 8)
			       (let ((bpp (1- (lsh 1 out-bpp))))
				 (not (eql (logand component-write-mask
						   bpp)
					   (logand bpp (logand write-mask
							       component-write-mask)))))
			       ( SI:*DEST-X-SCALE* 1)
			       ( SI:*DEST-Y-SCALE* 1)
			       (and (memq image-type  '(false-color-image
							 8b-random-image
							 8b-palette-image))
				    (memq dest-image-type '(false-color-image
							     8b-random-image
							     8b-palette-image))
				    window-map
				    map
				    (neq window-map map))
			       )
2			   ;if the destination is less than 8 bits, or if there
			   ;is a write mask to contend with
0			   (expand-compressed-stream-general
			     compressed-stream width height
			     dx out wdx wdy
			     (if (or (< ib 8)
				     (memq image-type '(false-color-image
							 8b-random-image
							 8b-palette-image)))
				 image-type
				 'false-color-image)
			     (if component
				 'false-color-image
				 dest-image-type)
			     write-mask
			     map
			     window
			     component
			     window-map
			     ))
			  ((and (eq image-type 'packed-rgb-image)
				(eq dest-image-type 'packed-rgb-image))
			   (expand-compressed-rectangle-packed-rgb
			     compressed-stream width height
			     dx out wdx wdy
			     (if (fixp component) (// component 8) component)))
			  ((and (eq image-type 'packed-yuv-image)
				(eq dest-image-type 'packed-yuv-image))
			   (expand-compressed-rectangle-packed-yuv
			     compressed-stream width height
			     dx out wdx wdy
			     component))
			  ((and component
				(eql 32. out-bpp)
				(eq dest-image-type '32b-image))
			   (expand-compressed-rectangle-32b
			     compressed-stream width height
			     dx out wdx wdy (// component 8)))
			  ((> out-bpp 8)
			   (expand-compressed-rectangle-8b-mapped
			     compressed-stream width height
			     dx out wdx wdy
			     (cond ((null map)
				    (send *standard-grayscale-map*
					  :full-color-translation-array))
				   ((arrayp map) map)
				   (t (send map :full-color-translation-array)))))
			  (t (expand-compressed-rectangle-8b
			       compressed-stream width height
			       dx out wdx wdy)
			     )
			  )
		    (finish-input compressed-stream)
		    ))))

      ;unwind protected

      (when compressed-stream
	(reset-filler-process compressed-stream))

      (when temp-dest-row
	(tv:deallocate-temp-sheet-raster-and-header temp-dest-row))

      (when (and in (neq in input))
	(tv:deallocate-temp-sheet-raster-and-header in))

      (when made-out
	(tv:deallocate-temp-sheet-raster-and-header made-out)
	(setq made-out nil))
      )

    (or made-out out))))

