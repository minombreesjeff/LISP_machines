;;; -*- Package: COLOR; Base: 10.; Mode: LISP; Lowercase: Yes; -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Functions for the user interface
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defvar *images-directory-cache*
	(make-instance 'directory-cache	
	       :file-types images:*images-canonical-types*))

(defvar *wild-directory-cache*
	(make-instance 'directory-cache	
		       :file-types t))
 

(defun cache-image-directory (path &rest keywords )
  D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");
0  1;if we are looking for an exact type match, which is one of the canonical
0  1;types, then use the images-only cache.  Otherwise, use the "anything" cache
  ;
0  (let* ((type (send path :canonical-type)))
    (values (lexpr-funcall #'pathnames-matching
			   (if (and (symbolp type)
				    (member type images:*images-canonical-types*))
			       *images-directory-cache*
			       *wild-directory-cache*)
			   path keywords)
	    path)))


(defun cache-image-file (file)
  (map-over-matching-pathnames *images-directory-cache* file :uncache t)
  (map-over-matching-pathnames *wild-directory-cache* file :uncache t))

(defun sort-pathname-names (a b)
  (declare (sys:downward-function))
  (string-lessp (string a)(string b)))

(defun image-pathname-match (path &key
			     uncache
			     predicate
			     format
			     exclude-loaded-images
			     (sort-function #'sort-pathname-names))
  (let* ((format-obj (images::find-image-file-format format :if-does-not-exist nil))
	 (canonical-types (when format-obj
			    (images::image-file-format-file-canonical-types
			      format-obj)))
	 (path (fs:parse-pathname path))
	 (path (if (null (send path :name)) (send path :new-name :wild) path))
	 (path (send (fs:merge-pathname-defaults
		       path *image-pathname-defaults*
		       (or (first canonical-types) :wild))
		     :translated-pathname))
	 (path-type (send path :type))
	 (path-canonical-type (send path :canonical-type))
	 (use-canonical-types
1	   ;if the specified pathname is compatible with the format's declared canonical type
0	   1;we will use canonical types to match.  Otherwise, we wildcard match on the
0	   1;raw types.
0	   (or (eq path-canonical-type (first canonical-types))
	       (and canonical-types (eq path-canonical-type :wild))))
	 )
    (setq *last-image-file* (fs:set-default-pathname path *image-pathname-defaults*))
    (loop for paths in (cache-image-directory path :uncache uncache)
	  with (format-type . aux-types) = canonical-types
	  as image-exists = nil
	  and dump-exists = (null aux-types)
	  when (loop for path in paths
		     as typ = (send path :canonical-type)
		     when (memq typ aux-types) do (setq dump-exists t)
		     when (if use-canonical-types
			      (eq typ format-type)
			      (fs:wildcard-match path-type (send path :type)))
		       do (setq image-exists path)
		     when (and dump-exists image-exists)
		       return (and (if predicate (funcall predicate image-exists) t)
				   (if exclude-loaded-images
				       (not (find-image image-exists
							:exact-only t :menu nil))
				       t)))
	    collect image-exists into exists
	  finally
	    (when sort-function
	      (setq exists (sort exists sort-function)))
	    (return exists))
    ))


(defun choose-from-images (choices
			   &key
			   (menu-icons *default-use-image-icons*)
			   (rescale-icon :select)
			   (choose-multiple nil)
			   (label (if choose-multiple "multiple images" "an image"))
			   (verb "Choose") 
			   (noun "image")
			   (menu-keywords)
			   (no-other-choices nil)
			   (explicit-image-choices)
			   (highlighted-values)
			   (additional-choices)
			   )
  (loop with max-picture-height = 0
	and max-picture-width = 0
	and use-menu-icons = menu-icons
	as superior = (or tv:mouse-sheet tv:main-screen)
	as use-menu-icons-on-sheet =
	   (cond ((null use-menu-icons) nil)
		 ((and (eq use-menu-icons :color)
		       ( (useful-bits-per-pixel superior) 8))
		  t)
		 ((eq use-menu-icons t)))
	as image-choices =
	   (or explicit-image-choices
	       (loop for i in choices
		     with item-w and item-h
		     as im = (find-image i)
		     when im
		     as icon-available =
			(cond ((null use-menu-icons-on-sheet) nil)
			      ((send im :menu-icon :create-p :defer
				     :rescale rescale-icon)))
		     as item =
			`(,(if icon-available
			       im
			       (send im :print-name-to-stream nil :print-type nil))
			  :value ,im :documentation ,(format nil "Image ~S" im))
		     if icon-available collect item into pics
		       and maximize
			     (progn (multiple-value (item-w item-h)
				      (send (first item) :menu-bounding-box-size nil))
				    item-h)
			     into max-item-height
		       and maximize item-w into max-item-width
		     else collect item into names
		     finally
		       (setq names (cl:sort names #'alphalessp :key #'CAR))
		       (setq pics (cl:sort pics #'alphalessp
					   :key #'(lambda (a) (send (car a) :name))))
		       (setq max-picture-height max-item-height
			     max-picture-width max-item-width)
		       (return (nconc names pics))
		       ))
	as fixed-choice-list =
	   (if no-other-choices
	       additional-choices
	       (nconc (list (unless explicit-image-choices
			      (if use-menu-icons-on-sheet
				  `("menu without icons" :value (:switch)
				    :style (nil :italic nil)
				    :documentation "Switch to a menu without pictures")
				  `("menu using icons" :value (:switch)
				    :style (nil :italic nil)
				    :documentation "Switch to a menu with pictures of the images"))))

		      (when choose-multiple (list `(,(format nil "~A selected ~A~P"
							     verb noun noun)
						    :value (:do-it)
						    :style (nil :bold nil)
						    :documentation "Select the marked images")
						  `(,(format nil "~A all except selected ~A~P"
							     verb noun noun)
						    :value (:inverted-do-it)
						    :style (nil :bold nil)
						    :documentation "Select some images to ignore, select all the rest")
						  ))
		      (list '("Abort" :value (:abort)
			      :style (nil :italic nil)
			      :documentation "Forget it, abort this process"))
		      additional-choices
		      ))
	as choice-list = (unless choose-multiple image-choices)
	do
    (multiple-value-bind (choice choice-made nil multiple)
	(lexpr-funcall #'tv:choose-with-menu
		       :choices `(((:choices ,fixed-choice-list)
				   :submenu)
				  ((:choices ,choice-list
				    :multiple-choice-items
				    ,(when choose-multiple image-choices)
				    :highlighted-values ,highlighted-values
				    :geometry ,(if use-menu-icons-on-sheet
						   *default-image-icon-geometry*
						   nil)
				    :maximum-height ,(if (> max-picture-height 0)
							 (* 5 max-picture-height)
							 400)
				    :maximum-width ,(if (> max-picture-width 0)
							(* 6 max-picture-width)
							400))
				   :submenu))
		       :momentary-mode '(:execute)
		       :label (format nil "~A ~A" verb label)
		       :geometry 0 
		       menu-keywords)
      (setq highlighted-values multiple)
      (when choice-made
	(when (listp choice)
	  (selectq (car choice)
	    (:do-it (setq choice multiple))
	    (:inverted-do-it
	     (setq choice (loop for i in image-choices
				as iv = (third i)
				unless (memq iv multiple)
				  collect iv)))
	    (:abort (return (values nil nil)))
	    ((eq choice :switch)
	     (setq use-menu-icons (not use-menu-icons-on-sheet)
		   choice-made nil)
	     )))
	(when choice-made (return (values choice t)))))
    ))

(defun find-images-matching
       (image &key (names nil) (table *named-images*) filter exact-only)

  (loop with match-pathname = (when (typep image 'fs:pathname)
				(send image :translated-pathname))
	with match-dir = (when match-pathname (send match-pathname :directory))
	with match-host = (when match-pathname (send match-pathname :host))
	with image-name = (if match-pathname
			      (send match-pathname :name)
			      (string image))
	for images being the hash-elements of table
	nconc (loop while images
		 as im = (if (listp images) (first images) images)
		 when (cond ((null im) nil)
			    ((eq image im)
			     (return (list (if names (send im :name) im))))
			    ((and filter (not (funcall filter im))) nil)
			    (match-pathname
			     (let ((sf (send im :source-file)))
			       (if sf
				   (if exact-only
				       (eq sf match-pathname)
				       (and (fs:wildcard-match image-name
							       (string (send sf :name)))
					    (let* ((pa (send sf :translated-pathname))
						   (ho (send pa :host))
						   (d-dir (send pa :directory))
						   )
					      (and (eql ho match-host)
						   (loop for s in (if (listp match-dir) match-dir (list match-dir))
							 as d in (if (listp d-dir) d-dir (list d-dir))
							 always (fs:wildcard-match (string s)(string d))))
					      )))
				   (if exact-only
				       nil
				       (fs:wildcard-match
					 image-name
					 (string (send im :name))))
				   )))
			    (image-name
			     (if exact-only
				 (string-equal image-name (string (send im :name)))
				 (fs:wildcard-match image-name (string (send im :name))))))
		   collect (if names (send im :name) im)
		 do (setq images (if (listp images) (cdr images) nil))
		    )
	  ))


(defun find-images (&optional image &key
		    (names nil)
		    filter
		    menu
		    (menu-icons *default-use-image-icons*)
		    (rescale-icon :select)
		    menu-keywords
		    all-images
		    label (verb "Choose")
		    exact-only
		    )
  (if (image-p image)
      image
      (if menu
	  (find-image image :name names :choose-multiple t :menu-icons menu-icons
		      :menu-keywords menu-keywords
		      :label label :verb verb
		      :menu menu
		      :exact-only exact-only
		      :rescale-icon rescale-icon
		      :all-images all-images)
	  (let ((table (if all-images *non-garbage-images* *named-images*)))
	    (find-images-matching (or image "*")
				  :names names :table table :filter filter
				  :exact-only exact-only)
	    ))
      ))


(defun find-image (&optional (image "*") &key
		   (menu-icons *default-use-image-icons*)
		   (rescale-icon :select)
		   (choose-multiple nil)
		   (name nil)
		   menu-keywords
		   filter
		   all-images
		   label (verb "Choose")
		   exact-only
		   menu
		   )
  (if (image-p image)
      image
      (when (null image) (setq image "*"))
      (let ((choices (find-images-matching
		       image
		       :exact-only exact-only
		       :filter filter :names name
		       :table (if all-images *non-garbage-images* *named-images*))))
	(cond ((null choices) nil)
	      ((and (null menu)(null (cdr choices))) (car choices))
	      (t (choose-from-images choices
				     :menu-icons menu-icons
				     :rescale-icon rescale-icon
				     :menu-keywords menu-keywords
				     :choose-multiple choose-multiple
				     :label (or label
						(format nil "images matching ~A" image))
				     :verb verb
				     )
		 #||(pop-up-image-browser
		      :configuration 'find-images) ||#
		 )))
      ))

(defmethod (:set-write-file-keywords essential-image-methods) (&rest keywords)
  (send self :putprop (copy-if-necessary keywords) :write-file-keywords))

(defmethod (:write-file-keywords essential-image-methods) ()
  (send self :get :write-file-keywords))

(defun write-image (file &optional image
		    &rest keywords
		    &key (menu-icons *default-use-image-icons*)
		    (menu-keywords)
		    (write-files-keywords)
		    (write-icon-file *default-use-image-icons*)
		    format
		    &allow-other-keys)
  (ignore write-icon-file)
  (let ((im (find-image image
			:menu-icons menu-icons
			:menu-keywords menu-keywords)))
    (if (null im)
	(ferror "No image named ~A" image)

	(when (eq format :fasd) (setq format :binary))
	(let ((file-format (images::find-image-file-format
			     (or format (send im :file-format) :image))))
	  (when file-format
	    (send im :set-file-format (images::image-file-format-name file-format))
	    (si:with-rem-keywords (keywords keywords `(:menu-icons :menu-keywords
						       :write-files-keywords :format))
	      (lexpr-send im :set-write-file-keywords 
			  (append write-files-keywords keywords))
	      (images::write-image-to-file-in-format file-format im file)))))))

(defun write-image-internal (file image)
  (lexpr-send image :write-files-internal file (send image :write-file-keywords)))

(defmethod (:write-files-internal essential-image-methods)
	   (&optional (file source-file) &rest options)
  (let ((file (fs:parse-pathname file))
	(old-map (send self :get :binary-map))
	(image-file-name))

    (if (send file :name)
	(unless (send self :name) (send self :set-name (send file :name)))
	(setq file (send file :new-pathname :name (string name))))

    (multiple-value-bind (binary-name binary-map)
	(lexpr-send self ':write-binary-file file options)
      (when binary-name
	(unwind-protect
	    (progn (send self :putprop binary-map :binary-map)
		   (setq image-file-name (lexpr-send self ':write-image-file file options))
		   )
	  (if image-file-name
	      (setq source-file image-file-name)

	      (send self :putprop old-map :binary-map)
	      (deletef binary-name)))))

    image-file-name))

(defmethod (choose-frame essential-image-methods)
	   (&rest keywords &key choose-multiple &allow-other-keys)
  (lexpr-funcall #'choose-from-images
		 nil
		 :explicit-image-choices (loop for i in (send self :defined-frames)
					       collect  `(,(format nil "~S" i) :value ,i))
		 :noun "frame" 
		 :label (if choose-multiple "multiple frames" "a frame")
		 keywords))

(defmethod (choose-frames essential-image-methods) (&rest keywords)
  (lexpr-funcall #'choose-frame self :choose-multiple t keywords))

(defmethod (kill-frames essential-image-methods) ()
  (multiple-value-bind (frames chosen)
      (choose-frames self :verb "kill")
    (when chosen (loop for i in frames do (send self :delete-frame i)))))

(defun view-image
       (window &optional image
	&rest keywords
	&key
	function
	width height
	(edges :inside)
	(menu-icons *default-use-image-icons*)
	(clear-before-load)
	(frame nil frame-specified-p)
	(frame-menu nil)
	&allow-other-keys
	&aux im)

  (when (setq im (find-image image :menu-icons menu-icons))


    (when frame-menu
      (multiple-value (frame frame-specified-p)
	(choose-frame image))
      (unless frame-specified-p (return-from view-image nil))
      )

    (when frame-specified-p
      (send im :set-current-frame frame t))

    (when (send im :image-valid-p t)
      
      (tv:with-prepared-sheet-or-raster
	(window :window window :array array
		:inside-width inside-width :inside-height inside-height)
	(unless height (setq height inside-height))
	(unless width (setq width inside-width))
	(when clear-before-load
	  (unless (and (neq edges :inside) (eq clear-before-load :unless-edges))
	    (if window
		(send window :clear-window)
		(%draw-rectangle width height 0 0 tv:alu-setz array)))))

      (si:with-rem-keywords (keywords keywords '(:function :menu-icons :clear-before-load
							   :frame-menu
							   :edges :width :height))
	(lexpr-send im (or function :send-image-to-window) window
		    :width width :height height
		    :edges edges
		    keywords)))
    im))

(defun read-form-from-file (file)
  (with-reliable-connections ()
    (with-open-file (f file :direction :input)
      (multiple-value-bind (ignore ignore ignore generic-plist)
	  (send f ':generic-pathname-and-plist)
	(scl:with-standard-io-environment
	  (fs:read-attribute-list generic-plist f)
	  (let ((rt readtable))
	    (multiple-value-bind (vars vals)
		(fs:file-attribute-bindings generic-plist)
	      (progv vars vals
		;this is a terrible kludge to force the
		;common-lisp readtable to be used
		(let ((readtable rt))  
		  (values (read f) (send f :pathname)))
		)))
	  )))))

(defvar *window* nil)

(defun load-image-file (file &optional (binary-too t)  window
			&rest options
			&key load-image-icons make-image-icons discard-image
			(format (or (images::pathname-default-image-file-format-name
				      (fs:parse-pathname file))
				    :image))
			(mac-file-header nil)
			(write-mask -1)
			(edges :inside)
			;(allow-multiple (null window))
			&allow-other-keys)

  (let* ((*dont-load-image-binary* (not binary-too))
	 (*make-image-load-image-icons*
	   (cond ((and load-image-icons make-image-icons) :always)
		 (load-image-icons t)
		 (make-image-icons :only)))
	 (fdefine-file-pathname )
	 (format (or format :image))
	 (format-obj (images::find-image-file-format format))
	 (canonical-type (first (images::image-file-format-file-canonical-types format-obj)))
	 (*window* window))

    (setq file (fs:merge-pathname-defaults
		 file *image-pathname-defaults*
		 canonical-type :newest))
    (si:with-rem-keywords (options options
				   (if (eq format :image)
				       '(:format :discard-image :mac-file-header 
						 :edges :write-mask)
				       '(:format :discard-image :mac-file-header 
						 :edges :write-mask
						 :load-image-icons)
				       ))
      (let ((options
	      (if (and (member format '(:pict :macpaint))
		       file
		       (neq (send (send file :host) :system-type) :macintosh))
		  `(:header-p ,mac-file-header ,@options)
		  options)))

	(let ((image (lexpr-funcall #'images::read-images-from-file-in-format
				    format-obj file options)))

	  (when image
	    (with-stack-list (images image)
	      (dolist (image (if (Listp image) image images))
		(cl:setf (images::image-file image)
			 file
			 (images::image-file-format image)
			 format)
		(when (null (images::image-name image))
		  (setf (images::image-name image)
			(unique-image-name (send file :raw-name)))))))

	  (when (listp image)(setq image (first image)))

	  (when *window*
	    (lexpr-send image :send-image-to-window *window*
			:write-mask write-mask
			:edges edges
			options))
	  (when discard-image (kill-image image)(setq image nil))
	  image
	  )))))

(defun load-image-file-internal (file &rest options)
  (multiple-value-bind (form fdefine-file-pathname)
      (read-form-from-file file)
    
    (when (listp form)
      (if (eq (car form) 'make-image)
	  (let ((im (eval (append form '(:file-format :image)))))  ;;images format
	    (when im
	      (when *window*
		(si:with-rem-keywords (options options '(:discard-image))
		  (lexpr-send im :send-image-to-window *window* options))
		(setq *window* nil)
		)
	      im))
	  (ferror "Not an Iman format image"))
      )
    ))

(defun load-image-file-into-window (file window &rest options)
  (lexpr-funcall #'load-image-file  file nil window options)
  )

(defun choose-image-pathname (pathname &rest keywords)
  (when pathname
    (setq pathname (fs:merge-pathname-defaults pathname *image-pathname-defaults*
					       :image))
    (if (or (send pathname :directory-wild-p)
	    (send pathname :name-wild-p))
	(let* ((possibilities (lexpr-funcall #'image-pathname-match pathname keywords))
	       (val (first possibilities)))
	  (when (cdr possibilities)
	    (setq val (tv:choose-with-menu
			:label "Choose one image pathname"
			:choices possibilities))
	    )
	  val)
	pathname
	)))

(defun combine-pathname-and-image-format (pathname format)
  (let* ((pathname (fs:parse-pathname pathname))
	 (path-format (images::pathname-default-image-file-format-name pathname)))
    (values pathname (or format path-format))
    ))

(defun load-images (file-spec &optional (binary-too nil) &key
		    (load t)
		    (exclude-loaded-images t)
		    (menu t)
		    (format :image format-supplied-p)
		    (load-image-icons *default-use-image-icons*)
		    (window)
		    (stream cl:*query-io*)
		    (label "Choose multiple images to be loaded")
		    (sort-function #'sort-pathname-names)
		    (predicate)
		    (uncache t))
  (multiple-value (file-spec format)
		  (combine-pathname-and-image-format
		    file-spec
		    (when format-supplied-p format)))
    (let* ((files (image-pathname-match file-spec :uncache uncache
					:format format
					:predicate predicate
					:exclude-loaded-images exclude-loaded-images
					:sort-function sort-function))
	   (cl:*query-io* stream)
	   (new-uncache uncache)
	   (new-exclude exclude-loaded-images)
	   (to-load '(dw::alist-subset
		       :alist (("icon"
				:value :icon
				:documentation "load the small image (.icon) files when available")
			       ("binary"
				:value :dump
				:documentation "load the main binary (.dump) files")
			       )))
	   (how-to-load  :all)
	   (new-how-to-load 0)
	   (new-new-files 99999)
	   (new-format 9199)
	   (new-file-spec file-spec)
	   (default-file-spec file-spec)
	   (default-to-load 
	     `(:image
		,@(when binary-too (list :dump))
		,@(when (and load-image-icons
			     (neq load-image-icons :only))
		    (list :icon))))
	   new-files 
	   item-list
	   n-images)

      (cond ((null menu) (setq how-to-load :all))
	    ((and (eq menu :optional) (null (cdr files)))
	     (setq how-to-load :all))
	    ((and menu (null files))
	     (tv:mouse-y-or-n-p (format nil "No files match ~A" file-spec))
	     (setq how-to-load :abort)
	     )
	    (t

	     (condition-case ()
		  (dw:accepting-values (cl:*query-io* :label label
						      :resynchronize-every-pass t)

		    (when (and new-files (eq how-to-load :all))
		      (incf new-how-to-load)
		      (setq how-to-load :selected))

		    (setq how-to-load
			  (accept '(dw::alist-member
				     :alist
				     (("all"
				       :value :all
				       :documentation "load all the images listed")
				      ("selected"
				       :value :selected
				       :documentation
				       "load just the selected images")
				      ("all except"
				       :value :except
				       :documentation "load all the images except the selected images"))
				     )
				  :query-identifier new-how-to-load
				  :default how-to-load
				  :prompt "load which images"))

		    (when (and (eq how-to-load :all) new-files)
		      (incf new-new-files)
		      (setq new-files nil))
		      
		    (setq new-uncache
			  (accept 'inverted-boolean :default (when uncache t)
				  :prompt "Use remembered directory"))

		    (setq new-exclude
			  (accept 'boolean :default (when exclude-loaded-images t)
				  :prompt "Exclude images already loaded"))

		    (let ((old-format format))
		      (setq format (accept 'images::image-file-format-name-internal
					   :default old-format
					   :query-identifier new-format
					   :prompt "File format"))
		      (when (neq format old-format)
			(setq format-supplied-p t)
			(let* ((ff (images::find-image-file-format format :if-does-not-exist nil))
			       (can (and ff
					 (first (IMAGES::IMAGE-FILE-FORMAT-FILE-CANONICAL-TYPES
						  ff)))))
			  (when (and can (neq can (send file-spec :canonical-type)))
			    (setq default-file-spec (send file-spec :new-canonical-type can))
			    ))
			))

		    (when (member format '(:image :bin nil))
		      (setq default-to-load (accept to-load
						    :prompt "file types to load"
						    :default default-to-load)))

		    (multiple-value (new-file-spec format)
				    (accept-image-pathname default-file-spec
					   :format format
					   :format-is-defaulted (not format-supplied-p)))

		    (when (or (neq file-spec new-file-spec)
			      (and new-uncache (neq new-uncache uncache))
			      (neq new-exclude exclude-loaded-images))
		      (setq file-spec new-file-spec)
		      (setq uncache new-uncache)
		      (setq exclude-loaded-images new-exclude)
		      (setq new-files nil)
		      (incf new-new-files)
		      (setq files
			    (image-pathname-match
			      file-spec :uncache uncache
			      :format format
			      :predicate predicate
			      :exclude-loaded-images exclude-loaded-images
			      :sort-function sort-function)))

		    (setq item-list (loop for i in files
					  collect
					    `(,(send i ':raw-name)
					      :value ,i
					      :documentation
					      ,(send i :string-for-printing))))

		    (setq n-images (length files))
		    (setq new-files
			  (accept `((dw::alist-subset
				      :alist ,item-list)
				    :row-wise nil	;  (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")pending patch 
0				    )
				  :prompt nil :prompt-mode :raw
				  :query-identifier new-new-files
				  :default (if (= 1 n-images) files new-files)))
		    )
		(sys:abort (setq files nil how-to-load :all)))

		(setq binary-too (member :dump default-to-load)
		      load-image-icons (memq :icon default-to-load)
		      )))

      (selectq how-to-load
	(:all (setq new-files files))
	(:select)
	(:except (setq new-files (loop for i in files
				       unless (memq i new-files)
					 collect i))))

      (setq files (loop for i in new-files
			collect
			  (if load
			      (load-image-file
				i binary-too window
				:format format
				:load-image-icons load-image-icons)
			      i)))
      files))

(defun accept-image-pathname (default-pathname
			      &key
			      (format-is-defaulted)
			       (format :image))
  (let* ((format (or (when format-is-defaulted
		       (images::pathname-default-image-file-format-name default-pathname))
		     format))
	 (ff (images::find-image-file-format
	       format
	       :if-does-not-exist nil))
	 (can (when ff (first (IMAGES::IMAGE-FILE-FORMAT-FILE-CANONICAL-TYPES ff))))
	 (fs:*default-pathname-defaults*
	   `((nil . ,(fs:merge-pathname-defaults
		       ""
		       *last-image-file*
		       can))))
	 (new-pathname (accept 'cl:pathname
			       :default default-pathname
			       :prompt "image pathname"))
	 )
    (when (and (neq new-pathname default-pathname)
	       format-is-defaulted)
      (let* ((new-typ (send new-pathname :type))
	     (old-typ (when default-pathname (send default-pathname :type)))
	     (this-format
	       (and (not (equal new-typ old-typ))
		    (images::pathname-default-image-file-format-name
		      new-pathname))))
	(when this-format
	  (setq format this-format)
	  )
	))
    (values new-pathname format)	
    ))

(defun save-window
       (&optional window &key
	(edges :INSIDE)
	(file *last-image-file*)
	(rle *default-image-rle*)
	(ask t)
	(print nil)
	(menu-icons *default-use-image-icons*)
	(specify-rectangle *msr-function*)
	(clear-before-load)
	(color-map nil color-map-supplied)
	(properties)
	(image-type (when window (default-image-type window t)))
	(disposition :unchanged)
	(file-types `(,@(when *default-use-image-icons* (list :icon))
		      :dump))
	(own-window (neq tv:mouse-sheet (and cl:*query-io* (send cl:*query-io* :screen))))
	(compression-method :combine)
	(discard-image)
	from-field to-field
	(where (when window :FILE))
	(load-or-save :save)
	(format :image format-supplied-p)
	&aux (*msr-function* specify-rectangle)
	(window window)
	)

  (ignore menu-icons)
  (let ((where where)
	(load-or-save load-or-save)
	(format format)
	(*msr-function* *msr-function*)
	(window window))
    (declare (special where load-or-save format *msr-function* window))

  (loop with source = (if window :window :memory)
	and name = (or (catch-error (send (setq file (fs:parse-pathname file)) :name)
				    nil)
		       "new-image")
	and disposition-type = '(alist-member :alist
					      (("Preserve" :value :LOADED
						:documentation "Keep them (uses virtual memory)")
					       ("Discard" :value :UNLOADED
						:documentation "Discard them, freeing virtual memory")
					       ("No change"  :value :UNCHANGED
						:documentation "Leave it as it is now"
						)))
	and op-id = nil
	and image = (catch-error
		      (first (or (color:find-images *last-image-file*)
				 (color:find-images Nil)))
		      nil)
	do

    (when ask
      (dw:accepting-values (cl:*query-io*
			     :own-window own-window
			     :minimum-width 600
			     :minimum-height 250
			     :label "Load or Save an Image")

	(setq load-or-save
	      (accept `(alist-member
			 :alist
			 (("load an image" :value :load
			   :Documentation "load an image into a window or virtual memory")
			  ("save an image" :value :save
			   :Documentation "save an image from a window or virtual memory")))
		      :default load-or-save
		      :prompt "Operation"
		      ))

	(setq op-id (if (eq load-or-save :load) "Load from" "Save to"))

	(setq source (accept `(alist-member
				:alist
				(("a window" :value :window
				  :documentation
				  ,(selectq load-or-save
				     (:load "Load an image into a window")
				     (:save "Save an image from a window")
				     (t "Load or save a window")))
				 ("virtual memory" :value :memory
				  :documentation
				  ,(selectq load-or-save
				     (:load "Load an imageinto virtual memory")
				     (:save "Save an image from virtual memory")
				     (t "Load or save an image in virtual memory")
				     ))))
			     :default source
			     :prompt
			     (selectq load-or-save
			       (:load "Load into")
			       (:save "Save from")
			       (t "to or from"))
			     ))

	(when (eq source :window)
	  (setq window (accept (if (tv:arrayp window)
				   'expression
				   'tv:window)
			       :default window
			       :prompt "Window")))

	(when (memq load-or-save '(:load :save))

	  (when (neq source :window)
	    (selectq load-or-save
	      (:load (setq where :file))
	      (:save (setq where :image))))


	  (cond ((eq source :window)
		 (setq where
		       (accept `(dw::alist-member
				  :alist
				  (("memory"
				    :value :image
				    :documentation
				    ,(format nil "~A an image in virtual memory"
					     op-id))
				   ("a file" :value :file
				    :documentation
				    ,(format nil "~A an image saved in a file" op-id))))
			       :default where
			       :prompt (if (eq load-or-save :load) "Load from" "Save to")
			       )))
		((eq load-or-save :save)
		 (setq image (accept 'images:named-image :prompt "Save image" :default image)
		       where :file))
		)

	  (cond ((eq where :file)
		 (multiple-value (file format)
				 (accept-image-pathname
				   (or (and image (eq source :image)
					    (send image :source-file))
				       file)
				   :format format
				   :format-is-defaulted (not format-supplied-p)))
		 (let ((old-format format))
		   (setq format (accept 'images::image-file-format-name-internal
					:default format
					:prompt "File format "))
		   (unless (eq format old-format)(setq format-supplied-p t))
		   ))
		((eq load-or-save :load)
		 (setq image (accept 'images:named-image :prompt "Image" :default image))
		 )
		(t (setq name
			 (accept 'symbol :prompt "Image Name"
				 :default (intern  name)))
		   (when name (setq file (fs:merge-pathname-defaults
					   (string name)
					   file
					   :image)))
		   ))

	  (when (eq source :window)
	    (setq edges
		  (accept `(alist-member
			     :alist
			     (,@(when (eq load-or-save :save)
				  `(("everything" :value :everything
				     :documentation "Save the entire window, including borders")))
			      ("inside" :value :inside
			       :documentation ,(if (eq load-or-save :load)
						   "Load into the whole window"
						   "Save the whole window without borders"))
			      ("mouse corners" :value :mouse
			       :documentation
			       ,(if (eq load-or-save :load)
				    "Use the mouse to specify a rectangle to load into"
				    "Use the mouse to specify a rectangle to save"))))
			  :default edges
			  :prompt (if (eq load-or-save :load)
				      "Where in the window to load"
				      "What part to save"))))


	  (when (eq load-or-save :save)
	    (setq rle (accept 'boolean :prompt "run length encode the image?" :default rle))

	    (when (eq where :file)
	      (let ((include-dump (accept 'boolean :prompt "Write an Icon file too"
					  :default (when (memq :icon file-types) t))))
		(if include-dump
		    (cl:pushnew :icon file-types)
		    (setq file-types (cl:remove :icon file-types)))))

	    (when (eq source :window)
	      (setq image-type
		    (accept `image-type
			    :prompt "type of image to save "
			    :default image-type))
	      (let ((available-bits (useful-bits-per-pixel window)))
		(when (and (eq image-type 'false-color-image)
			   (> available-bits 8))
		  (setq compression-method
			(accept `(alist-member
				   :alist ,(choose-rgb-combination-alist
					     :color-map color-map
					     :abort nil
					     :alpha (> available-bits 24)))
				:prompt "Coversion to 8 bits: "
				:default compression-method)))))
	    (when (eq where :file)
	      (setq disposition (accept disposition-type
					:default disposition
					:prompt "Disposition of the bit arrays")))
	    )

	  (when (eq load-or-save :load)
	    (if (eq source :window)
		(setq disposition (accept disposition-type
					  :default disposition
					  :prompt "Disposition of the bit arrays"))
		(setq file-types (accept '(dw::alist-subset :alist
							    (("Icon" :value :icon)
							     ("Dump" :value :dump)))
					 :default file-types
					 :prompt "file types to load"))))
		      
	    )
	))

    (when (null load-or-save)
      (setq load-or-save
	    (tv:menu-choose '(("LOAD" :LOAD) ("SAVE" :SAVE) ("retry the main menu" NIL))))
      )
	until (eq load-or-save :exit)
	do
    ;;
    ;; do the operaion
    ;;
    (when (and file (eq load-or-save :load) (eq where :file))
      (setq file (choose-image-pathname       file))
      (when file (setq name (send file :name))))

    (cond ((eq where :file) (when  file (setq *last-image-file* file)))
	  ((eq where :memory) (when image (setq *last-image-name* name))))
    (when window (setq *last-image-window* window))
    (return
      (if (eq source :window)
	  (cond ((null file))
		((eq load-or-save :SAVE)
		 (save-window-to-file
		   :to-file (eq where :file)
		   :write-icon-file (when (memq :icon file-types) t)
		   :window  window
		   :image-type image-type
		   :disposition disposition
		   :displaced (and (eq where :file)
				   (neq disposition :loaded))
		   :file file
		   :format format
		   :name nil
		   :edges edges
		   :print print
		   :properties properties
		   :method compression-method
		   :color-map color-map
		   :discard-image discard-image
		   :from-field from-field
		   :to-field to-field
		   :rle rle))
		((eq where :file)
		 (load-image-file-into-window
		   file window
		   :disposition disposition
		   :compression-method compression-method
		   :edges edges
		   :format format
		   :from-field from-field
		   :to-field to-field
		   :discard-image discard-image
		   :clear-before-load clear-before-load))
		(t (lexpr-funcall #'view-image
				  window image
				  :disposition disposition
				  :edges edges
				  :clear-before-load clear-before-load
				  :from-field from-field
				  :to-field to-field
				  :compression-method compression-method
				  (when color-map-supplied
				    `(:color-map ,color-map))
				  )
		   (when discard-image (kill-image image))
		   ))
	  (cond ((null file))
		((eq load-or-save :SAVE)
		 (when image
		   (loop for (prop val) on properties by #'cddr
			 do (send image :putprop val prop))
		   (when color-map
		     (send image :set-setup-color-map color-map))
		   (send image :write-files file
			 :rle rle
			 :print print
			 :write-icon-file (when (memq :icon file-types) t)
			 :format format
			 )
		   (when (eq disposition :unloaded)
		     (send image :discard-bit-arrays)
		     (kill-derived-images image))
		   (when discard-image (kill-image image))
		   ))
		((eq load-or-save :LOAD)
		 (cond ((eq where :FILE)
			(load-image-file file (when (memq :dump file-types) t)
					 nil
					 :discard-image discard-image
					 :format format
					 :load-image-icons (when (memq :icon file-types) t)))
		       (t nil))))
	  )
      ))))

(defun load-image (&rest args &key file window name load-binary discard-image &allow-other-keys)

  (when file (setq file (choose-image-pathname file)))

  (when (or name file)
    (setq name (find-image (if file nil name) :filter
			   (when file
			     #'(lambda (im) (eq file (send im :source-file))))))
    (unless name
      (when file (setq name (load-image-file file nil)))))

  (when name
    (if load-binary
	(send name :load-binary-file :frame load-binary)
	(send name :putprop t :binary-not-loaded)
	)
    (when window
      (si:with-rem-keywords (new-keywords args '(:file :window :name
						       :load-binary :discard-image))
	(lexpr-funcall #'view-image window name new-keywords)))
    (when discard-image
      (kill-image name))
    name
    ))

(defun save-image (&rest args &key window file name discard-image &allow-other-keys)
  (ignore discard-image)
  (si:with-rem-keywords (new-keywords args '(:window :name :file))
    (when file (setq file (fs:parse-pathname file)))
    (lexpr-funcall #'save-window
		   (or window *last-image-window*)
		   :load-or-save :save
		   :file (or file name *last-image-file*)
		   :where (if file :file :image)
		   new-keywords)))


(defun save-window-to-file (&rest keywords
			    &key to-file file window name
			    (rle *default-image-rle*)
			    print image-type displaced
			    properties
			    discard-image
			    (disposition :unchanged)
			    (write-icon-file *default-use-image-icons*)
			    (rescale-icon :select)
			    (format :image)
			    &allow-other-keys)

  (si:with-rem-keywords (keywords keywords '(:to-file :file :window :name :disposition
						      :rle :properties :discard-image
						      :write-icon-file
						      :continuation :format
						      :image-type :print))
    (let ((image (make-instance (or image-type (default-image-type window t))
				:name (or name
					  (and file (send file ':name))
					  window)
				:properties properties
				:file-format format
				:rle rle)))
      (labels ((write-image-internal ()
		 (declare (sys:downward-function))
1		 ;write-the files from inside the window bit array environment
0		 (when to-file
		   (when write-icon-file
1		     ;pre-create the icon file while we are in the right environment
0		     (send image :menu-icon
			   :create-p t
			   :load-file nil
			   :rescale rescale-icon))
		   (send image ':write-files file :print (and print rle)
			 :write-icon-file write-icon-file))))
	(lexpr-send image ':take-image-from-window window
		    :continuation #'write-image-internal
		    :kill-derived-images nil
		    keywords)
	)

      (if (eq disposition :loaded)
	  ()
	  (when displaced
	    (send image :discard-bit-arrays)
	    )
	  )
      (when discard-image (kill-image image)(setq image (send image :source-file)))
      image)))

(defprop :CHOOSE-IMAGE-NAME
	 (tv:print-string-or-nil
	   readline-or-nil
	   nil nil choose-image-file-for-cvv "an image name")
	 tv:choose-variable-values-keyword)

(defun choose-image-file-for-cvv (name)
  (declare (special window where load-or-save))
  (when (null window)
    (selectq load-or-save
      (:load (setq where :file))
      (:save (setq where :image))))
  (multiple-value-bind (file name)
    (choose-image-file-and-name name (eq where :file) load-or-save)
    (if (eq where :file) file name)))

(defun choose-image-file-and-name
       (original-file
	&optional
	(file-only t)
	(load-or-save :load)
	return-nil-on-error
	&key
	(menu-icons *default-use-image-icons*)
	(rescale-icon :select))

  (cond (file-only
	 (let* ((file (catch-error
			(fs:merge-pathname-defaults
			  original-file
			  *image-pathname-defaults*
			  :image
			  :newest)
			nil))
		)

	   (if (null file)

	       (tv:mouse-y-or-n-p (format nil "Error parsing ~A as a pathname" original-file))

	       (if (and file (send file :wild-p))
			 
		   (let ((possibilities
			   (or (cdr (catch-error (fs:directory-list file :fast) nil))
			       )))

		     (setq file
			   (selectq (length possibilities)
			     (0 (if (eq load-or-save :load)
				  (progn
				    (tv:mouse-y-or-n-p (format nil "No files match ~A" file))
				    nil)
				  file))
			     (1 (caar possibilities))
			     (t 
			      (tv:menu-choose
				(append `(("" :no-select :no-select)
					  (2"ABORT - go back to main menu"
0					   :value nil
					   :documentation "Don't overwrite any of these")
					  ("" :no-select :no-select))
					(mapcar 'car possibilities))
				(selectq load-or-save
				  (:LOAD 2"load which image from disk?")
0				  (:SAVE 2"write a new version of which image?"0)
				  (T 2"load or save which image?")
0				  )
				))))2)

0		   ;;non-wild single file
		   (when (eq load-or-save :load)
		     (or (null file)
			 (catch-error (probef file) nil)
			 (progn (tv:mouse-y-or-n-p
				  (format nil "File ~A was not found" file))
				(setq file nil))
			 ))
		   ))

	   (when (and file (eq load-or-save :save))
	     (setq file (send file ':new-pathname :canonical-type :image :version :newest)))

	   (if file
	       (values file (send file :name))
	       (values (if return-nil-on-error nil original-file) nil))
	   ))
	(t
	 (let* ((possibilities (or (find-images original-file)
				   (let ((fn (catch-error (fs:parse-pathname original-file)
							  nil)))
				     (when fn
				       (let ((name (send fn :name)))
					 (find-images (if (eq name :wild) "*" name)))))))
				   
		(choice (cond ((null possibilities)
			       (if (eq load-or-save :save)
				   original-file
				   (tv:mouse-y-or-n-p
				     (format nil "No images match ~A" original-file))
				   nil))
			      ((null (cdr possibilities))
			       (car possibilities))
			      (t (let ((im (choose-from-images 
					     possibilities
					     :label
					     (format nil "Images matching ~A" original-file)
					     :menu-icons menu-icons
					     :rescale-icon rescale-icon
					     )))
				   im)))))
	   (if choice
	       (values original-file (if (instancep choice) (send choice :name) choice))
	       (values (if return-nil-on-error nil original-file) nil))
	   ))
	))


(defun save-window-usual-choices (window &rest ignore)
  (loop while window
	until (tv:sheet-exposed-p window)
	do (setq window (tv:sheet-superior window)))
  (when window
    (save-window window
		 :load-or-save :save
		 :rle *default-image-rle*
		 :own-window t
		 :print nil)))

(defun system-menu-save-window (window old-mouse-x old-mouse-y)
  (tv:system-menu-window-edit #'save-window-usual-choices
			      nil window old-mouse-x old-mouse-y))
(defun system-menu-menu-save-window (window old-mouse-x old-mouse-y)
  (tv:system-menu-window-edit #'save-window-usual-choices t
			      window old-mouse-x old-mouse-y))

(setq tv:*system-menu-this-window-column*
      (append (remove (assoc "Load or Save Image" tv:*system-menu-this-window-column*)
		      tv:*system-menu-this-window-column*)
	      (list '("Load or Save Image" :buttons	
		      ((() :window-op system-menu-save-window)
		       (() :window-op system-menu-save-window)
		       (() :window-op system-menu-menu-save-window))
		      :documentation
      "L: M: Load or Save an image using this window   R: menu of likely subwindows")
		      ))
	      )


#||
;;
;; this is experimental, intended for s-record.  Before this can be enabled,
;; TV:BOX-NCHARS has to be incorporated into graphics-support.
;;
(defun make-slate-image (string &key (width 640)(height 484) style (name "slate frame"))
  (let ((im (color:make-image 'color:b&w-image ))
	(w (make-instance 'tv:bitmap :width 10 :height 10)))
    (with-character-style (style w)
      (send w :clear-window)
      (multiple-value-bind (wid hei)(tv:box-nchars string)
	(send w :set-size-in-characters (+ 1 wid)(+ hei 1)))
      (send w :set-cursorpos 0 0)
      (send w :string-out string 0)
      (send im :take-image-from-window w :displaced t))
    (multiple-value-bind (w h) (send im :size)
      (let* ((scale (min (// width w)(// height h)))
	     (to-left (// (- width (* scale w)) 2))
	     (to-top (// (- height (* scale h)) 2))
	     (to-right (+ to-left (* w scale)))
	     (to-bottom (+ to-top (* h scale))))	
	(let ((new-image (send im :create-scaled-image
			       :rescale :select
			       :scaled-image-name name
			       :scaled-width width
			       :scaled-height height
			       :to-left to-left
			       :to-top to-top
			       :to-right to-right
			       :to-bottom to-bottom)))
	  (color:kill-image im)
	  new-image)))))
||#

(images:define-image-file-format :image
  :pretty-name "Image"
  :description "Reads and writes in Images' native format"
  :read-function load-image-file-internal
  :write-function write-image-internal
  :file-canonical-type :image
  :auxiliary-file-canonical-types (:dump)
  :calling-sequence :image)

(cp:define-command (com-load-images :command-table "Global")
    ((pathname 'fs:pathname :prompt "from file"
	       :default *last-image-file*)
     &key
     (format 'images::image-file-format-name
	     :default (or  (images::pathname-default-image-file-format-name pathname)
			  :image))
     (menu 'boolean
	   :default t
	   :documentation
	   "If Yes, accept a subset of matching images to load, otherwise load all matching images")
     (load-image-icons 'boolean
		       :default *default-use-image-icons*
		       :documentation "If Yes, load image icons immediately")
     (load-binary-too 'boolean
		      :default nil
		      :documentation
		      "If Yes, load the binary immediately, otherwise try to defer until needed")
     (use-remembered-directory 'boolean
			       :default nil
			       :documentation "If Yes, use the last remembered directory contents"
			       )
     (exclude-loaded-images
       'boolean :default t
       :documentation "If yes, exclude the images you've already loaded")
     )
   (let ((loaded (load-images pathname load-binary-too
			      :menu menu
			      :format format
			      :uncache (not use-remembered-directory)
			      :exclude-loaded-images exclude-loaded-images
			      :load-image-icons load-image-icons)))
     (present loaded '((dw::sequence images:named-image)))))


(tv:def-display-window-operation "View Image" :value view-image

				 :documentation "View an image on this window")

(tv:def-display-window-operation
  "Load or Save Image" :value save-window
  :documentation "Load an image from a file, or Save this window as an image")

