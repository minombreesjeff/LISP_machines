;;; -*- Package: COLOR; Base: 10.; Mode: LISP; -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD-EXTENDED NIL) "CPTFONTB")Global variables0 1used by images
0;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defvar *image-pathname-defaults* (fs:make-pathname-defaults))
(defvar *last-image-file* (fs:parse-pathname "images:junk;junk.image"))
(defvar *last-image-window* nil)
(defvar *last-image-name* "junk")

(defvar *msr-function* 'tv:mouse-specify-rectangle)
(defvar *default-use-image-icons* :color)
(defvar *box-image-icons* t)
(defvar *default-image-icon-geometry* 0)
(defvar *default-image-menu-size* 100.)
(defvar *default-image-rle* t)

(defvar *default-compression-method* :compose)

(defmethod (:view-image essential-image-methods) (raster &rest args)
  (cl:apply #'view-image raster self
	    :compression-method *default-compression-method*
	    args))

(defmethod (compatible-pixel-depth-and-color-map essential-image-methods)
	   (pixel-depth color-map)
  (ignore color-map)
  (send self :compatible-pixel-depth pixel-depth))


(defwhopper (compatible-pixel-depth-and-color-map false-color-mixin)
	    (pixel-depth color-map)
  (and (or (eq color-map setup-color-map)
	   (and (null color-map) (eq setup-color-map *standard-false-color-map*))
	   (and (null setup-color-map) (eq color-map *standard-false-color-map*)))
       (continue-whopper pixel-depth color-map)))

(defmethod (images::write-image-to-file-in-format images::image-file-format :after)
	   (image &rest ignore)
  (send image :set-modified nil)
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")Elaboration of the bit array stream protocol
0;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 1Utility functions
0;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; resolve edge specs into a legal set, get some edges from
;; the mouse if needed.
;;
(defun resolve-edges (window wdx wdy iwidth iheight edges from-field to-field
		      &key (scale 1) (x-scale scale)(y-scale scale))
  
  (let* ((iswin (typep window 'tv:sheet))
	 (isimage (typep window 'essential-image-methods))
	 (wwidth (cond ((or iswin isimage)
			(send window :width))
		       (t (when (listp window) (setq window (first window)))
			  (decode-raster-array window))))
	 (wheight (if (or iswin isimage)
		      (send window :height)
		      (multiple-value-bind (nil w)
			  (decode-raster-array window)
			w)))
	 (iwidth (or iwidth wwidth))
	 (iheight (or iheight wheight))
	 (width (ceiling (* iwidth x-scale)))
	 (height (ceiling (* iheight y-scale)))
	 (wleft (if iswin (tv:sheet-inside-left window) 0))
	 (wtop (if iswin (tv:sheet-inside-top window) 0))
	 (wright (if iswin (- wwidth (tv:sheet-right-margin-size window)) wwidth))
	 (wbot (if iswin (- wheight (tv:sheet-bottom-margin-size window)) wheight))
	 (wdx (or wdx 0))
	 (wdy (or wdy 0)))

    (when to-field
      (setq height (* height 2)))
    (when from-field
      (cond ((eql from-field 1) (setq height (ceiling height 2)))
	    ((eql from-field 2) (setq height (floor height 2)))))

    (multiple-value-bind (left top right bottom)
	(cond ((eq edges :everything)
	       (values wdx wdy width height))
	      ((eq edges :inside)
	       (let ((left (+ wleft wdx))
		     (top (+ wtop wdy)))
		 (values left top
			 (min wright (+ left width))
			 (min wbot (+ top height)))))
	      ((eq edges :mouse)
	       (tv:with-mouse-grabbed-on-sheet (window)
		 (tv:mouse-set-blinker-definition :character 0 0 :on
						  :set-character #\mouse:nw-corner)
		 (loop with left and top and right and bottom do
		   (multiple-value (left top right bottom)
		     (funcall *msr-function*
			      wdx wdy (+ wdx width) (+ wdy height)
			      window
			      0 0 t))
		       until (and left right bottom top)
		       finally (return (values left top right bottom)))
	       ))
	      ((listp edges)
	       (let* ((left (+ wleft (or (first edges) wdx 0)))
		      (top (+ wtop (or (second edges) wdy 0))))
		 (values left
			 top
			 (min wright
			      (cond ((third edges)
				     (+ (third edges) wleft))
				    (t (+ left width))))
			 (min wbot
			      (cond ((fourth edges)
				     (+ (fourth edges) wtop))
				    (t (+ top height)))))))
	      (t ;; unspecified, default to inside coordinates
	       (let ((left (+ wdx wleft))
		     (top (+ wdy wtop))
		     )
		 ;; clip to inside coordinates
		 (values (max wleft left)
			 (max wtop top)
			 (min wright
			      (+ left width))
			 (min wbot
			      (+ top height))))
	       ))
      (let ((left (min (max 0 left) wwidth))
	    (top (min (max 0 top) wheight))
	    (height (min iheight
			 (floor (max (- (min wheight bottom) top) 0) y-scale)))
	    )

	(when from-field (setq height (* height 2)))

	(cond ((eql to-field 1) (setq height (ceiling height 2)))
	      ((eql to-field 2) (setq height (floor height 2))))
	(values left top
		(min iwidth (floor (max (- (min wwidth right) left) 0) x-scale))
		height))
      )
    ))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 1BITBLT FUNCTIONS
0;;
;;(3 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI") these are all called with pure arrays (no sheets!) to do 
0;;3 some kind of image process between the two arrays.  They 
0;;3 pause after each line to allow interrupts, so are OK to call
0;;3 with screen arrays of prepared sheets.
0;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun images-copy-32b-8b (wid hei src sdx sdy dest dx dy how
			   &rest keywords
			   &key (scale 1)(x-scale scale)(y-scale scale)(rescale :select)
			   &allow-other-keys)

  ;; simulate a bitblt from an 32bit array to an 8bit array, with a shift
  (let ((fetch (selector how eql
		 ((0) :red)
		 (8. :green)
		 (16. :blue)
		 (24. :alpha)
		 ((nil :combine-grayscale)
		  (setq how :combine-grayscale)
		  :rgba)
		 ((:red :green :blue :alpha) how)
		 ((:combine :combine-map) :rgba)
		 (t (ferror "Can't process how=~A" how))))
	(to-wid (round (* x-scale wid)))
	(to-hei (round (* y-scale hei)))
	)
    (lexpr-funcall #'zoom-rectangle :from-left sdx :from-right (+ sdx wid)
		   :from-top sdy :from-bottom (+ sdy hei)
		   :from-array src
		   :to-array dest
		   :to-left dx :to-top dy
		   :from-image-type '32b-image
		   :fetch fetch
		   :rescale rescale
		   :separate (if (memq fetch '(:red :green :blue :alpha))
				 nil :default)
		   :to-right (+ dx to-wid) :to-bottom (+ dy to-hei)
		   keywords)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;1 Common mixin,
0;;
;; containing methods shared among all types of image
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod (:set-modified essential-image-methods :after) (new)
  (when new
    (send self :putprop :no :icon-file-exists)))

(defmethod (:fake-draw-lines essential-image-methods) (&rest args)
  (loop for (fx fy tx ty) on args by #'cddr
	when (and fx fy tx ty)
	do (send self :fake-draw-line fx fy tx ty)))

(defwhopper (:create-bit-arrays essential-image-methods )()
  (let ((val (continue-whopper)))
    (send self :update-field-description :void)
    (unless (garbage-image-p self)
      (puthash self self *non-garbage-images*)
      (send self :remprop :killed)
      )
    val))

(defwhopper (:create-displaced-bit-arrays essential-image-methods )(&rest args)
  (let ((val (lexpr-continue-whopper args)))
    (send self :update-field-description nil)
    (unless (garbage-image-p self)
      (puthash self self *non-garbage-images*)
      (send self :remprop :killed))
    val))


(defmethod (:set-rle-internal essential-image-methods :default) (ignore) nil)

(defmethod (:clear-window essential-image-methods) ()
  (when (send self :bit-arrays-valid-p)
    (send self :with-single-bit-array
	  #'(lambda (a)
	      (if (nlistp a)
		  (multiple-value-bind (w h)(decode-raster-array a)
		    (tv:%draw-rectangle-internal w h 0 0 tv:alu-setz a))
		  (loop for i in a do
		    (multiple-value-bind (w h)(decode-raster-array i)
		      (tv:%draw-rectangle-internal w h 0 0 tv:alu-setz i))))))))

(defmethod (:rle-component-names essential-image-methods) ()
  nil)



(defvar unique-id-sequence 0)

(defun make-unique-id (&optional prefix)
  (if prefix
      (format nil "~A-~D" prefix (incf unique-id-sequence))
      (format nil "~A:~\time\ #~D"
	      chaos:local-host
	      (time:get-universal-time)
	      (incf unique-id-sequence))))

(defun unique-image-name (prefix)
  (make-unique-id prefix))

(defmethod (:complete-binary-dump-form essential-image-methods) ()
  (let ((curr current-frame)
	(frames (send self :frame-plists)))

    `(:binary-unique-id ,(make-unique-id)
      :rld ,(cadr (send self :rle))
      ,@(if (loop for (fr) in frames thereis (neq fr nil))
	    
	    `(,@(loop for (cf) in frames
		      when (not (eql cf curr))
			nconc
			  `(:current-frame ,@(send self :rle-binary-dump-form
						   (copylist (send self :frame-plist cf)))))
	      ,@`(:current-frame ,@(send self :rle-binary-dump-form
					 (copylist (send self :frame-plist curr)))))

	    (append (send self :current-frame-properties)
		    (cdr (send self :rle-binary-dump-form
			       (cons nil (send self :binary-dump-form)))))))))



(defmethod (:rle-binary-dump-form essential-image-methods) (form)
  (when (send self :rle)
    (let ((dat (get form :data-array))
	  (comp (send self :rle-component-names)))
      (when (and dat comp)
	(remprop form :data-array)
	(nconc form (loop for i in comp nconc (list i dat))))
      ))
  form)

(defmethod (:complete-image-dump-form essential-image-methods) ()
  (let ((frames (send self :frame-plists)))

    (if (loop for (fr) in frames thereis (neq fr nil))

	(let ((idf (send self :image-dump-form)))
	  (remprop (locf idf) :width)
	  (remprop (locf idf) :height)
	  idf)

	(send self :image-dump-form))))

(defmethod (make-new-name-and-source-file essential-image-methods)
	   (suffix new-name new-source-file)
  (unless new-name
    (setq new-name (when name (intern (string-append name suffix) :keyword))))
  (unless new-source-file
    (when source-file
      (let ((old-file (catch-error (fs:parse-pathname source-file))))
	(when old-file
	  (setq new-source-file (send old-file :new-name
				      (string-append (send old-file :name) suffix)))))))
  (values new-name new-source-file)
  )

(defmethod (:deallocate-bit-array essential-image-methods) (&rest arrays)
  (loop for i in arrays do (tv:deallocate-temp-sheet-raster-and-header i))
  )

(defvar *always-discard-bit-arrays* nil)
(defwhopper (:discard-bit-arrays essential-image-methods)
	    (&key (frame current-frame) (always-discard *always-discard-bit-arrays*))
  (when (and source-file
	     (not (or always-discard
		      (send self :get :killed)
		      (member (send self :file-format) '(:image nil)))))
    (catch-error-restart
      ((sys:error) "Discard the bits anyway" nil)
      (ferror "Image ~S cannot reload the discarded bits" self)))

  (let ((cf current-frame))
    (unwind-protect
	(cond ((listp frame)
	       (loop for fr in frame do
		 (send self :set-current-frame fr)
		 (continue-whopper)))
	      ((eql frame t)
	       (loop for (fr) in (send self :frame-plists)
		     do (send self :set-current-frame fr)
			(continue-whopper)))
	      (t (send self :set-current-frame frame)
		 (continue-whopper)))
      (send self :putprop nil :window)
      (send self :set-current-frame cf)
      (garbage-image-p self)
      )))


(defmethod (:load-direct-to-window essential-image-methods) (w)
  (let ((my-size (send self :useful-bits-per-pixel)))
    (tv:with-prepared-sheet-or-raster (w :bits-per-pixel bpp)
      (if (send self :rle)
	  (if (and (> my-size 8) ( bpp 16))
	      nil
	      t)
	  (if (and (> my-size 8) (eql bpp 8))
	      nil
	      t)))))

(defmethod (default-suffix essential-image-methods) (&optional new-image-type)
  (let ((typ (string (typep self))))
    (format nil "-~A~A~A"
	    (substring (string typ) 0 (string-search "-IMAGE" typ))
	    (if new-image-type "-to-" "")
	    (if new-image-type (substring (string new-image-type)
					  0
					  (string-search "-IMAGE" new-image-type))
		"")
	    )))

(defmacro-in-flavor (whop-image-copy essential-image-methods) ()
  `(if (eq frame t)
       (let* ((cf current-frame)
	      (copy-of-image (lexpr-continue-whopper :frame cf args)))
	 (unwind-protect
	     (loop for (i) in (send self :get :frames)
		   unless (eql i cf)
		     do (send self :set-current-frame i)
			(lexpr-continue-whopper :frame i :image copy-of-image args))
	   (send self :set-current-frame cf)
	   (send copy-of-image :set-current-frame cf))
	 copy-of-image)
       (lexpr-continue-whopper args)))

(defwhopper (:copy-image essential-image-methods)
	    (&rest args &key frame &allow-other-keys)
  (whop-image-copy))


(defun-in-flavor (prep-image-for-copy essential-image-methods)
		 (user:name file image-type 
			    &optional
			    image 
			    suffix
			    invisible-to-database)
  (unless suffix (setq suffix (default-suffix self image-type)))
  (cond ((null image)
	 (multiple-value (user:name file)
	   (make-new-name-and-source-file self suffix user:name file))
	 (let* ((props (send self ':*apply-interesting-properties*))
		(props2 (get (locf props) :properties)))
	   (remprop (locf props) :binary-map)
	   (remprop (locf props2) :binary-map)
	   (putprop (locf props) props2 :properties)
	   (lexpr-funcall 'make-image image-type
			  :source-file file
			  :name user:name
			  :height (send self :height)
			  :width (send self :width)
			  :pixel-aspect-ratio (send self :pixel-aspect-ratio)
			  :dont-load-binary t
			  :load-image-icons nil
			  :invisible-to-database invisible-to-database
			  props
			  )))
	((typep image image-type)
	 (when user:name (send image :set-name user:name))
	 (when file (send image :set-source-file file))
	 (send image :set-size (send self :width) (send self :height))
	 (send image :set-pixel-aspect-ratio (send self :pixel-aspect-ratio))
	 image)
	(t (ferror "The /"IMAGE/" argument must be type ~S" image-type))))

(defmethod (:copy-image essential-image-methods)
	   (&rest args )
  (lexpr-send self :create-scaled-image args))

(defmethod (:1b-image essential-image-methods) (&rest keywords)
  (or (send self :get :1b-image)
      (let ((im  (lexpr-send self ':create-1b-image keywords)))
	(send im :set-name nil)
	(send self :putprop im :1b-image)
	im)))

(defmethod (:2b-image essential-image-methods) (&rest keywords)
  (or (send self :get :2b-image)
      (let ((im  (lexpr-send self ':create-2b-image keywords)))
	(send im :set-name nil)
	(send self :putprop im :2b-image)
	im)))

(defmethod (:4b-image essential-image-methods) (&rest keywords)
  (or (send self :get :4b-image)
      (let ((im  (lexpr-send self ':create-4b-image keywords)))
	(send im :set-name nil)
	(send self :putprop im :4b-image)
	im)))

(defmethod (:8b-image essential-image-methods) (&optional (palette t))
  (let ((prop (if palette :8b-palette-image :8b-peano-image)))
    (or (send self :get prop)
	(let ((im  (send self ':create-8b-image :method (if palette :palette :peano))))
	  (send im :set-name nil)
	  (send self :putprop im prop)
	  im))))

(defmethod (:rgb-image essential-image-methods) ()
  (or (send self :get :rgb-image)
      (let ((im  (send self ':create-rgb-image)))
	(send im :set-name nil)
	(send self :putprop im :rgb-image)
	im)))


(defmethod (:packed-rgb-image essential-image-methods) ()
  (or (send self :get :packed-rgb-image)
      (let ((im  (send self ':create-packed-rgb-image)))
	(send im :set-name nil)
	(send self :putprop im :packed-rgb-image)
	im)))

(defmethod (:packed-yuv-image essential-image-methods) ()
  (or (send self :get :packed-yuv-image)
      (let ((im  (send self ':create-packed-yuv-image)))
	(send im :set-name nil)
	(send self :putprop im :packed-yuv-image)
	im)))

(defmethod (:32b-image essential-image-methods) ()
  (or (send self :get :32b-image)
      (let ((im  (send self ':create-32b-image)))
	(send im :set-name nil)
	(send self :putprop im :32b-image)
	im)))

(defmethod (:image-dump-form essential-image-methods :nconc) ()
  `(:name ',name 
    ,@(send self ':*interesting-properties*)))

(defmethod (:pixel-aspect-ratio essential-image-methods) ()
  (send self :get :pixel-aspect-ratio))
(defmethod (:set-pixel-aspect-ratio essential-image-methods) (new)
  (send self :putprop new :pixel-aspect-ratio))

(defmethod (:*apply-interesting-properties* essential-image-methods) ()
  (destructuring-bind (nil (nil pvs)) (send self :*interesting-properties*)
    (when pvs
      `(:properties ,pvs))))


(defmethod (:write-files essential-image-methods) (&optional (file source-file) &rest options)
  (cl:apply #'write-image (or file source-file) self options))


(defmethod (:write-image-file essential-image-methods)
	   (&optional (file source-file) &rest ignore)
  (or file (setq file source-file))
  (setq file (fs:parse-pathname file))
  (setq file (send file :new-pathname :version :newest :canonical-type :image))
  (scl:with-standard-io-environment 
    (let ((base 10.)
	  (ibase 10.)
	  (package (pkg-find-package 'zl-user))
	  (forms (send self ':complete-image-dump-form))
	  (bins (send self ':binary-dump-form)))
      (with-reliable-connections ()
	(with-open-file (stream file :direction :output :characters t)
	  (format stream ";;; -*- Package: ~A; Base: ~A; Syntax: Common-Lisp; Mode: LISP -*-~%~%" package base)
	  (grind-top-level
	    `(make-image ',(typep self)
			 ,@forms
			 :binary-info ',(loop for i in bins by #'cddr collect i))
	    nil stream)
	  (cache-image-file (send stream :truename))
	  )
	)
      (setq source-file file))))

(defmethod (:write-binary-file essential-image-methods)
	   (&optional (file source-file)
		      &key
		      (rle (send self :rle-on-output))
		      print
		      (write-icon-file *default-use-image-icons*)
		      (file-type :dump)
		      (write-dump-file t)
		      (rescale-icon :select)
		      (disposition :unchanged)
		      )

  (let ((frames-to-load
	  (when source-file
	    (cond ((send self :get :binary-not-loaded) t)
		  (t (loop for i in (send self :defined-frames)
			   unless (send self :bit-arrays-valid-for-frame i)
			     collect i))))))
    (unwind-protect
	(progn
	  (when frames-to-load (send self :load-binary-file :frame frames-to-load))

	  (or file (setq file source-file))

	  (and (neq rle :unk) (send self ':set-rle-internal rle))

	  (send self :putprop :no :icon-file-exists)

	  (when write-icon-file
	    (let ((ic (send self :menu-icon :create-p t :load-file nil :rescale rescale-icon)))
	      (when (and ic (neq ic self))
		(when (send ic :get :building-icon)
		  (process-wait "Icon Built"
		    #'(lambda (i)(null (send i :get :building-icon)))
		    ic))
		(send ic :write-binary-file file
		      :write-icon-file nil
		      :write-dump-file t
		      :file-type :image-icon
		      :rle nil )
		(send self :putprop t :icon-file-exists))
	      )
	    )

	  (and print (format t "~&~a~%" file))

	  (when write-dump-file
	    (multiple-value-prog1 
	      (si:write-to-dump-file file
				     (send self ':complete-binary-dump-form)
				     :image-type (send self :transfer-image-type-spec)
				     :rle (car (send self ':rle))
				     :PREPARE-SHEET (SEND SELF ':GET :WINDOW)
				     :file-type file-type
				     :print print)
	      (setq source-file file))))

      (when (and frames-to-load (neq disposition :loaded))
	(send self :discard-bit-arrays :frame frames-to-load))
      )))

(defmethod (:icon-file-exists essential-image-methods) ()
  (and source-file
       (eq file-format :image)
       (let ((ic (send self :get :icon-file-exists)))	
	 (cond ((eq ic :no) nil)
	       (ic ic)
	       (t (send self :putprop
			(or (setq ic
				  (loop for i in (first (cache-image-directory
							  (fs:parse-pathname source-file)))
					thereis (eq (send i :canonical-type) :image-icon)))
			    :no)
			:icon-file-exists)
		  ic)))))

(defmethod (:write-icon-file essential-image-methods) (&rest write-file-args)
  (with-bit-arrays () 
    (lexpr-funcall self :write-binary-file (or (first write-file-args)
					       source-file)
		   :write-icon-file t :write-dump-file nil (cdr write-file-args))))

(defun create-missing-icon-files (&key pathnames forced )
  (loop for path in (if (and pathnames (nlistp pathnames))
			(list pathnames)
			pathnames)
	as images = (load-images path nil :menu nil :load-image-icons nil)
	do
    (loop for i in images
	  unless (and (null forced) (send i :icon-file-exists))
	    do (format t "~&~A" i)
	       (send i :write-icon-file))))

(cp:define-command (create-image-icons :name "Create Image Icons" :command-table :global)
    ((pathnames 'fs:wildcard-pathname)
     &key
     (forced 'boolean))
   (create-missing-icon-files :pathnames pathnames :forced forced))

(defmethod (:rle essential-image-methods) ()
  (getf flavor:property-list
	:rle-on-output
	nil ;this really should be NIL, not *default-image-rle*
	))

(defmethod (:rle-on-output essential-image-methods) ()
  (let ((val (or (send self ':get ':next-rle-on-output)
		 :unk)))
    (when (eq val :nil) (setq val nil))
    val))

(defmethod (:load-icon-file essential-image-methods) ()
  (let ((path (send (fs:parse-pathname source-file)
		    :new-pathname :canonical-type :image-icon
		    :version :newest)))
    (when (catch-error (setq path (probef path)) nil)
      (let ((icon-image (make-image (typep self)
				    :binary-file-type :image-icon
				    :dont-load-binary nil
				    :source-file path
				    :invisible-to-database t)))
	(send self :putprop icon-image :image-icon)))))

(defmethod (build-load-map-for-frame essential-image-methods)
	   (&key frame inhibit-channels force-reload (use-load-map t))

   (let ((map (when use-load-map (send self :get :binary-map))))

     (if (null map)

	 t

	 (loop with matching-frame = (or (eql frame t)
					 (if (listp frame)
					     (member nil frame)
					     (eql frame nil)))
	       and some and load-vals
	       and cf = (send self :frame-plist nil)
	       for (map-var map-val) on map by #'cddr
	       do
	   (when (cond ((eq map-var :current-frame)
			(setq cf (send self :frame-plist map-val))
			(setq matching-frame (cond ((eql frame t))
						   ((listp frame)
						    (member map-val frame))
						   ((eql map-val frame)))))
		       ((eq map-var :rld))
		       ((eq map-var :binary-unique-id))
		       ((not matching-frame) nil)
		       ((memq map-var inhibit-channels) nil)
		       ((or force-reload
			    (not (send self
				       :component-valid-for-frame
				       cf
				       map-var)))
			(setq some t)))
	     (push map-var load-vals)
	     (push map-val load-vals)
	     ) 
	       finally
		 (return (or (when some (nreverse load-vals))
			     ""))
		 )
     )
     ))

(defmethod (:load-binary-file essential-image-methods)
	   (&key (file source-file) 
		 force-reload
		 wdx wdy dx dy width height edges
		 clear-before-load
		 (make-array 'tv:allocate-temp-sheet-raster-and-header)
		 prepare-sheet
		 (frame t)
		 (inhibit-channels)
		 (describe-file)
		 (color-map (send self :setup-color-map))
		 (window-color-map)
		 (file-type (or (send self :get :binary-file-type)
				:dump))
		 write-mask
		 (use-load-map t) from-field to-field
		 continuation
		 (scale 1)
		 (x-scale scale)
		 (y-scale scale)
		 (rescale :select)
		 (default-alpha #xff)
		 &special window)

  (unless file (setq file source-file))

  (send self ':putprop window ':window)

  (when (send self :get :killed)
    (catch-error-restart
      ((sys:error)
       "Try to load it anyway"
       nil)
      (ferror "image ~S has been killed" self)
      ))

  (let* ((array-type (send self :data-array-type))
	 (color-map (when (and window
			       (neq (transfer-map-type color-map) :grayscale))
		      color-map))
	 (image-type (send self :transfer-image-type-spec color-map))
	 (to-image-type (when window (transfer-image-type window window-color-map)))
	 (data)
	 (real-make-array make-array)
	 (rle-component-names (send self :rle-component-names))
	 )

    (unless (or (eql frame t)(listp frame))
      (send self :set-current-frame frame))

    (when (or force-reload window)
      (send self :discard-bit-arrays :frame frame))

    (when (and clear-before-load window)
      (if (typep window 'tv:sheet)
	  (send window :clear-window)
	  (multiple-value-bind (w h) (decode-raster-array window)
	    (tv:%draw-rectangle-internal w h 0 0 tv:alu-setz window))))

    (labels ((load-image-internal (ddx ddy)
	       (loop as load-map = (build-load-map-for-frame
				     self
				     :frame frame
				     :inhibit-channels inhibit-channels
				     :use-load-map use-load-map
				     :force-reload force-reload)
		     when (stringp load-map)
		       do
			 (when continuation
			   (ferror "Shouln't call LOAD-BINARY-FILE for this"))
			 (return t)
		     as loaded = (si:read-from-dump-file
				   (send (fs:parse-pathname file)
					 :new-pathname :canonical-type
					 file-type
					 :version :newest)
				   :ddx ddx :ddy ddy
				   :x-scale x-scale
				   :y-scale y-scale
				   :rescale rescale
				   :color-map color-map
				   :window-color-map window-color-map
				   :sdx dx :sdy dy
				   :width width
				   :height height
				   :write-mask write-mask
				   :prepare-sheet prepare-sheet
				   :rle-component-names rle-component-names
				   :array-type array-type
				   :make-array make-array
				   :image-type image-type
				   :to-image-type to-image-type
				   :load-map load-map
				   :frame-list (when (listp frame) frame)
				   :inhibit-channels inhibit-channels
				   :describe-file describe-file
				   :file-type file-type
				   :from-field from-field
				   :to-field to-field
				   :default-alpha default-alpha
				   :continuation continuation
				   )
		     if (eq loaded :discard-load-map)
		       do (send self :remprop :binary-map)
		     else do
			    (loop for (var val) on loaded by #'cddr
				  do
			      (send self :set-variable var val))

			    (when (or (send self :get :binary-map)
				      (eq frame t))
			      (send self :remprop :binary-not-loaded))
			      
			    (when (or window continuation)
			      (send self :discard-bit-arrays :frame frame))
			    (when loaded (return t))
			    )))

      (cond (continuation
	     (let ((null-array (make-array 0)))
	       (setq make-array #'(lambda (dims &rest options)
				    (if (listp dims)
					(cl:apply real-make-array dims
						  :displaced-to null-array options)
					(cl:apply real-make-array dims)))))
	     (load-image-internal dx dy))
	    (window
	     (multiple-value (wdx wdy width height)
	       (resolve-edges window wdx wdy width height edges from-field to-field
			      :x-scale x-scale :y-scale y-scale ))
	     (setq prepare-sheet window)
	     (let* ((bpp (useful-bits-per-pixel window))
		    (dest-image-type (when (eql bpp 1) 'b&w-image))
		    )
	       (setq write-mask (logand (1- (lsh 1 bpp)) (or write-mask -1)))
	       (tv:with-bit-array
		 window :output
		 #'(lambda (raster offset span)
		     (setq make-array #'(lambda (ignore &rest ignore)
					  (setq si:*dest-image-type* dest-image-type)
					  raster))
		     (multiple-value-bind (dy dx)(floor offset span)
		       (load-image-internal dx dy)))
		 :width (round (* width x-scale))
		 :height (round (* height y-scale))
		 :x-offset wdx
		 :y-offset wdy)))
	    (t
	     (when rle-component-names
	       (setq make-array
		     #'(lambda (dims &rest args)
			 (declare (sys:downward-function))
			 (if (and (memq si:*last-key* rle-component-names)
				  (listp dims) (= 2 (length dims)))
			     (if (eq si:*last-key* (first rle-component-names))
				 (setq data
				       (lexpr-funcall
					 real-make-array
					 (list (first dims)
					       (* (second dims)
						  (image-width-multiplier image-type)))
					 :type array-type
					 (remprop :type (copylist args))))
				 data)
			     (lexpr-funcall real-make-array dims args)))))
	     (load-image-internal wdx wdy)))
      )
    (unless (or (eql frame t)(listp frame))
      (send self :set-current-frame frame))
    )
  (unless (garbage-image-p self)
    (puthash self self *non-garbage-images*)
    (send self :remprop :killed))
  )


(defwhopper (:take-image-from-window essential-image-methods)
	    (window &rest props
		    &key
		    displaced
		    (from-image-type (default-image-type window))
		    &allow-other-keys)

  (when displaced
    (let ((my-size (send self :useful-bits-per-pixel))
	  (window-size (useful-bits-per-pixel window)))
      (cond ((and ( my-size 24) ( window-size 24)))
	    ((eql my-size window-size))
	    ((typep self from-image-type))
	    (t (setq displaced nil)))
      )
    )
  (send self :putprop (if displaced window nil) ':window)
  (send self :set-modified t)
  (let ((aspect (raster-pixel-aspect-ratio window)))
    (when aspect (send self :putprop aspect :pixel-aspect-ratio)))
  
  (lexpr-continue-whopper window
			  :displaced displaced
			  props))


(defmethod (kill-derived-images essential-image-methods) (&rest args)
  (loop for derived-image in *derived-image-properties*
	as im = (send self :get derived-image)
	when (and im (not (named-image-p im)))
	  do
	    (send self :remprop derived-image)
	    (lexpr-funcall #'kill-image im args))
  
  (lexpr-send self :discard-scaled-images args))

(defmethod (kill-image essential-image-methods)
	   (&key (remove-from-database t)
		 (discard-bit-arrays t)
		 (frame t)
		 (kill-derived-images t))
  (when remove-from-database
    (send self :set-name nil)
    )
  (when discard-bit-arrays
    (send self :putprop t :killed)
    (send self :discard-bit-arrays :frame frame)
    )
  (when kill-derived-images
    (kill-derived-images self
			 :remove-from-database remove-from-database
			 :discard-bit-arrays discard-bit-arrays
			 :kill-derived-images t))
  nil)

(defun kill-images (&optional images &rest args &key
		    (kill-derived-images t)
		    (discard-bit-arrays t)
		    (frame t)
		    (remove-from-database t)
		    (all-images)
		    &allow-other-keys)
  (si:with-rem-keywords (args args '(:kill-derived-images
				      :remove-from-database
				      :frame 
				      :discard-bit-arrays))
    (let ((val (lexpr-funcall #'find-images images
			      :names nil
			      :menu t
			      :all-images all-images
			      :verb "Kill"
			      args)))
      (loop for i in val do
	(kill-image i :kill-derived-images kill-derived-images
		    :frame frame
		    :discard-bit-arrays discard-bit-arrays
		    :remove-from-database remove-from-database
		    )))))


(defmethod (:adjust-image-size essential-image-methods)
	   (a type x y)
  (when a (send self :deallocate-bit-array a))
  (unless (send self :get :invisible-to-database)
    (puthash self self *non-garbage-images*))
  (tv:allocate-temp-sheet-raster-and-header
    (raster-width-and-height-to-make-array-dimensions
      (tv:raster-width-for-bitblt x type) y)
    ':area (image-bit-array-area)
    ':type type)
  )

(defmethod (:create-displaced-array essential-image-methods) (to dx dy w h)
  (tv:with-prepared-sheet-or-raster 
    (to :array array)
    (let* ((TYPE (ARRAY-TYPE ARRAY)))
      (tv:allocate-temp-sheet-raster-and-header
	(RASTER-WIDTH-AND-HEIGHT-TO-MAKE-ARRAY-DIMENSIONS W H)
	':displaced-to array
	':displaced-conformally t
	':type type
	':displaced-index-offset (+ dx (* dy (multiple-value-bind (nil nil span)
						 (decode-raster-array to)
					       span))))))
  )

(defmethod (:setup-color-map essential-image-methods :default) ()
  (send self :get :setup-color-map))

(defmethod (:set-setup-color-map essential-image-methods :default) (new)
  (send self :putprop new :setup-color-map)
  (let ((ip (send self :get :interesting-properties)))
    (if new
	(unless (member :setup-color-map ip)
	  (send self :putprop `(,:setup-color-map ,@ip) :interesting-properties))
	(send self :putprop
	      (delete :setup-color-map ip)
	      :interesting-properties))))

(defmethod (:copy-image-from-window  essential-image-methods)
	   (window &optional
		   (dx 0) (dy 0) (wdx 0) (wdy 0)
		   (wid (send self :width))
		   (hei (send self :height))
		   how
		   &rest keywords
		   &key color-map kill-derived-images from-field to-field
		   from-image-type to-image-type
		   &allow-other-keys)

  (ignore how)
  (when kill-derived-images
    (kill-derived-images self)
    )

  (si:with-rem-keywords
    (keywords keywords '(:color-map :kill-derived-images :from-image-type :to-image-type))
    (send self :with-single-bit-array
	  #'(lambda (data-array)
	      (tv:with-bit-array-or-stream
		window :input
		#'(lambda (src index span)
		    (let ((wdx 0)(wdy 0))
		      (when (fixp span)
			(multiple-value (wdy wdx) (floor index span))
			(setq span nil))
		      (lexpr-funcall #'zoom-rectangle 
				     :to-array data-array
				     :to-image-type
				     (or to-image-type
					 (send self :transfer-image-type-spec (send self :setup-color-map)))
				     :from-array src
				     :from-array-stream span
				     :from-image-type (or from-image-type (transfer-image-type src color-map))
				     :from-left wdx
				     :from-top wdy
				     :from-right (+ wdx wid)
				     :from-bottom (+ wdy (if (and from-field (null to-field)) (* 2 hei) hei))
				     :to-left dx
				     :to-top dy
				     :to-right (+ dx wid)
				     :to-bottom (+ dy (if (and to-field (null from-field))
							  (cond ((eql to-field 1)(ceiling hei 2))
								((eql to-field 2)(floor hei 2)))
							  hei))
				     :translation-array color-map
				     :rescale nil
				     keywords))
		    (send self :update-field-description to-field from-field)
		    )
		:x-offset wdx
		:y-offset wdy
		:width wid 
		:height hei
		)))))

(defmethod (:copy-image-to-window essential-image-methods)
	   (window dx dy wdx wdy wid hei &optional how
		   &rest keywords
		   &key (color-map (send self :setup-color-map))
		   (window-color-map )
		   (to-window window)
		   to-field
		   from-field
		   (scale 1)
		   (x-scale scale)
		   (y-scale scale)
		   (rescale :select)
		   (from-image-type)
		   &allow-other-keys)
  (ignore how)
  (si:with-rem-keywords (keywords keywords '(:color-map :window-color-map :to-window
							:from-image-type
							:rescale :scale :x-scale :y-scale))
    (tv:with-bit-array-or-stream
      self :input
      #'(lambda (from-raster from-index from-span)
	  (let ((dx 0)
		(dy 0)
		(to-hei (round (* y-scale hei)))
		(to-wid (round (* x-scale wid)))
		)
	    (when (fixp from-span)
	      (multiple-value (dy dx) (floor from-index from-span))
	      (setq from-span nil))
	    (tv:with-bit-array-or-stream
	      window :output
	      #'(lambda (to-raster to-index to-span)
		  (let* ((wdx 0)(wdy 0)
			 (from-image-type (or from-image-type
					      (send self :transfer-image-type-spec
						    color-map)))
			 (to-image-type (transfer-image-type window window-color-map))
			 )
		    (when (fixp to-span)
		      (multiple-value (wdy wdx) (floor to-index to-span))
		      (setq to-span nil))

		    (when (and (eq from-image-type to-image-type)
			       (eq color-map window-color-map)
			       (eq rescale :select))
		      (setq window-color-map nil
			    color-map nil
			    from-image-type (send self :transfer-image-type-spec nil)
			    to-image-type (transfer-image-type to-raster nil)))

		    (lexpr-funcall #'zoom-rectangle 
				   :from-array from-raster
				   :from-image-type from-image-type
				   :from-array-stream from-span
				   :to-array-stream to-span
				   :to-array to-raster
				   :to-image-type to-image-type
				   :translation-array color-map
				   :combination-array window-color-map
				   :from-left dx
				   :from-top dy
				   :from-right (+ dx wid)
				   :from-bottom (+ dy hei)
				   :to-left wdx
				   :to-top wdy
				   :to-right (+ wdx to-wid)
				   :rescale rescale
				   :to-bottom (+ wdy
						 (cond ((and to-field (null from-field))
							(* to-hei 2))
						       ((and from-field (null to-field))
							(cond ((eql from-field 1)
							       (ceiling to-hei 2))
							      (t (floor to-hei 2))
							      ))
						       (t to-hei)))
				   :to-window (when (typep to-window 'tv:sheet)
						to-window)
				   keywords
				   )))
	      :x-offset wdx
	      :y-offset wdy
	      :width to-wid
	      :height to-hei)))
      :permit-rgb t
      :x-offset dx
      :y-offset dy
      :width wid
      :height hei)))


(defmethod (:full-color-translation-array essential-image-methods) (map)
  (when map (send map :full-color-translation-array)))

(defvar *displace-from-fields* nil)

(defmethod (:update-field-description essential-image-methods) (to-field &optional from-field)
  (cond ((or (null to-field)
	     (and (neq to-field :void)
		  (let ((old (or (send self :get :field-description) 0)))
		    (eql 0 (ldb (byte 2 0) (logand old (lognot to-field)))))))
	 (send self :remprop :field-description))
	((eq to-field :void) (send self :putprop 3 :field-description))
3	;encode from-field and to-field such that a 1 indicates a missing field
0	(t (send self :putprop (dpb (ldb (byte 2 0) (lognot (or from-field 3)))
				    (byte 2 2)
				    (ldb (byte 2 0) (lognot (or to-field 3))))
		 :field-description)))
  (send self :field-description)
  )

(defmethod (:field-description essential-image-methods) ()
  (let ((old (or (send self :get :field-description) 0)))
    (values (selector (ldb (byte 2 0) old) =
	      (0 nil)(2 1)(1 2)(3 :void))
	    (selector (ldb (byte 2 2) old) =
	      (0 nil)(2 1)(1 2)(3 :void)))))


(defun 2raster-pixel-aspect-ratio0 (sheet-or-raster)
  (cond ((arrayp sheet-or-raster) 1)
	((typep sheet-or-raster 'tv:sheet)
	 (send (tv:sheet-screen sheet-or-raster) :pixel-aspect-ratio))
	((image-p sheet-or-raster)
	 (send sheet-or-raster :pixel-aspect-ratio))))


(defmethod (:2take-image-from-window0 essential-image-methods)
	    (window &rest keywords
		    &key edges displaced
		    (wdx 0) (wdy 0)
		    (dx 0) (dy 0)
		    (new-bit-arrays t)
		    tv:width 
		    tv:height
		    (pixel-aspect-ratio :unspecified)
		    method
		    (frame current-frame)
		    from-field to-field from-image-type
		    (kill-derived-images t)
		    (continuation)
		    &allow-other-keys
		    )
  (send self :set-current-frame frame nil)

  (let ((mul (image-width-multiplier from-image-type)))

    (multiple-value (wdx wdy tv:width tv:height)
      (resolve-edges window
		     (if wdx (* wdx mul) wdx) wdy
		     (if tv:width (* tv:width mul) tv:width) tv:height
		     edges nil nil))
    (setq tv:width (// tv:width mul)
	  wdx (// wdx mul)))

  (when to-field 
    (unless *displace-from-fields* (setq displaced nil))
    (setq tv:height (* tv:height 2)))

  (when from-field
    (unless *displace-from-fields* (setq displaced nil))
    (cond ((eql from-field 1) (setq tv:height (ceiling tv:height 2)))
	  ((eql from-field 2) (setq tv:height (floor tv:height 2)))))

  (when (< dx 0)				
    (setq tv:width (+ tv:width dx)
	  wdx (- wdx dx)
	  dx 0))

  (when (< dy 0)
    (setq tv:height (+ tv:height dy)
	  wdy (- wdy dy)
	  dy 0))

  (when new-bit-arrays
    (send self :set-width tv:width)
    (send self :set-height tv:height)

    (when (> dx 0)
      (send self :set-width (+ tv:width dx)))

    (when (> dy 0)
      (send self :set-height (+ tv:height dy))))

  (when (neq pixel-aspect-ratio :unspecified)
    (send self :set-pixel-aspect-ratio pixel-aspect-ratio))

  (when (and (> tv:width 0) (> tv:height 0))
    (tv:with-bit-array
      window :input
      #'(lambda (raster index span)
	  (multiple-value-bind (nwdy nwdx)(floor index span)
	    (unless (or (arrayp window)
			(and (typep window 'tv:sheet)
			     (let ((scr-ar (tv:sheet-screen-array window)))
			       (or (eq raster scr-ar)
				   (and (array-indirect-p raster)
					(eq (si:array-indirect-pointer raster)
					    scr-ar))
				 ))))
	      (setq displaced nil))
	    (cond (displaced
		   (when kill-derived-images (kill-derived-images self))
		   (when new-bit-arrays
		     (send self ':create-displaced-bit-arrays window wdx wdy)
		     (send self :update-field-description to-field from-field)
		     ))
		  (t (when new-bit-arrays (send self ':create-bit-arrays))
		     (si:with-rem-keywords
		       (keywords keywords '(:dx :dy :wdx :wdy :width :height
						:frame :pixel-aspect-ratio
						:new-bit-arrays
						:kill-derived-images
						:displaced :edges :method
						:continuation))
		       (lexpr-send self ':copy-image-from-window raster
				   dx dy nwdx nwdy tv:width tv:height
				   method
				   :kill-derived-images kill-derived-images
				   keywords
				   )))))
	  (when continuation (funcall continuation)))
      :x-offset wdx
      :y-offset wdy
      :width tv:width
      :height tv:height)
    ))

(defmethod (:create-new-image essential-image-methods)
	   (&rest args
		  &key
		  (user:name)
		  (method :dither)
		  (file)
		  (frame current-frame)
		  image
		  (image-type 'b&w-image)
		  (color-map)
		  (continuation)
		  (from-image-type (send self :transfer-image-type-spec))
		  (rescale :select)
		  (scale-factor 1)
		  (scale scale-factor)
		  (x-scale scale)
		  (y-scale scale)
		  (dither t)
		  (jitter nil)
		  (threshold)
		  (brightness)
		  invisible-to-database
		  &allow-other-keys
		  )

  (setq image (prep-image-for-copy user:name file image-type image nil invisible-to-database))
  (send image :set-setup-color-map color-map)

  (send image :putprop
	`(,(send image :create-me-message) ,name
	  :dither ,dither
	  :jitter ,jitter
	  :threshold ,threshold
	  :brightness ,brightness
	  :frame ,frame
	  :method ,method
	  ,@(unless (eql x-scale 1) `(:x-scale ,x-scale))
	  ,@(unless (eql y-scale 1) `(:y-scale ,y-scale))
	  ,@(when color-map `(:color-map ,(if (instancep color-map)
					      (send color-map :name)
					      color-map)))
	  )
	:creation-parameters)

  (cond (continuation
	 (funcall continuation image))
	((eq method :peano)
	 (si:with-rem-keywords (args args '(:method))
	   (lexpr-send self :combine-peano :image image args )))
	(t 
	 (si:with-rem-keywords (args args '(:name :method :file :frame :image :image-type
				       :color-map :continuation :from-image-type
				       :rescale :scale-factor :dither :jitter
				       :scale :x-scale :y-scale
				       :invisible-to-database
				       :threshold :brightness))
	   (send self :with-single-bit-array
	    #'(lambda (da)
		(declare (sys:downward-function))
		(multiple-value-bind (xs ys) (send self :size)
		  (let ((dest-xs (round (* xs x-scale)))
			(dest-ys (round (* ys y-scale))))
		    (send image :set-current-frame current-frame) 
		    (send image :set-size dest-xs dest-ys)
		    (send image :create-bit-arrays)
		    (send image :with-single-bit-array
			  #'(lambda (ar)
			      (declare (sys:downward-function))
			      (lexpr-funcall #'zoom-rectangle
					     :from-array da
					     :to-array ar
					     :from-left 0
					     :from-top 0
					     :from-right xs
					     :from-bottom ys
					     :to-left 0
					     :to-top 0
					     :to-right dest-xs
					     :to-bottom dest-ys
					     :jitter jitter
					     :dither dither
					     :threshold threshold
					     :brightness brightness
					     :rescale rescale
					     :from-image-type from-image-type
					     :translation-array (send self :setup-color-map)
					     :combination-array color-map
					     :to-image-type (send image :transfer-image-type-spec)
					     args))
			  ))))
	:frame frame
	))))
  image
  )

(defmethod (:create-1b-image essential-image-methods)
	   (&rest args &key (image-type 'b&w-image) (method :dither) &allow-other-keys)
  (declare (sys:arglist (&key
			  (user:name)
			  (method :dither)
			  (file)
			  (jitter nil)
			  (dither (eq method :dither))
			  (threshold)
			  (brightness)
			  (frame current-frame)
			  image
			  (image-type 'b&w-image)
			  )))
  (lexpr-send self :create-new-image
	      :image-type image-type
	      :method method
	      args)
  )

(defmethod (:create-2b-image essential-image-methods)
	   (&rest args &key (image-type '2b-image)(method :dither) &allow-other-keys)
  (declare (sys:arglist (&key
			  (user:name)
			  (method :dither)
			  (file)
			  (jitter nil)
			  (dither (eq method :dither))
			  (threshold)
			  (brightness)
			  (frame current-frame)
			  image
			  (image-type '2b-image)
			  )))
  (lexpr-send self :create-new-image
	      :image-type image-type
	      :method method
	      args)
  )



(defmethod (:create-4b-image essential-image-methods)
	   (&rest args &key
		  (image-type '4b-image)
		  (method :expand)
		  (color-map (selectq method
			       ((:grayscale :combine-grayscale
				 :red :green :blue) 
				*standard-4b-grayscale-map*)
			       ((:palette :primary-palette)
				*standard-4b-color-map*)
			       (t (send self :4b-color-map))))
		  &allow-other-keys)
  (declare (sys:arglist (&key (user:name)
			      (file)
			      (color-map (selectq method
					   ((:grayscale :combine-grayscale
					     :red :green :blue) 
					    *standard-4b-grayscale-map*)
					   ((:palette :primary-palette)
					    *standard-4b-color-map*)
					   (t (send self :4b-color-map))))
			      (method :expand)
			      (image-type '4b-image)
			      frame image
			      &allow-other-keys)))
  (lexpr-send self :create-new-image
	      :image-type image-type
	      :method method
	      :color-map color-map
	      args))

(defmethod (:create-8b-image essential-image-methods)
	   (&rest args &key
		  (image-type 'false-color-image)
		  (method :expand)
		  (color-map (send self :8b-color-map))
		  &allow-other-keys)
  (declare (sys:arglist (&key (user:name)
			      (file)
			      (color-map (send self :8b-color-map))
			      (method :expand)
			      (image-type 'false-color-image)
			      frame image
			      &allow-other-keys)))
  (lexpr-send self :create-new-image
	      :image-type image-type
	      :method method
	      :color-map color-map
	      args))

(defmethod (:create-rgb-image essential-image-methods)
	   (&rest args
		  &key
		  (image-type 'rgb-image)
		  (method :expand)
		  &allow-other-keys)
  (declare (sys:arglist (&key (user:name)
			      (file)
			      (method :expand)
			      (image-type 'rgb-image)
			      image frame
			      &allow-other-keys)))
  (lexpr-funcall self :create-new-image
		 :image-type image-type
		 :method method
		 args))

(defmethod (:create-packed-rgb-image essential-image-methods)
	   (&rest args
		  &key
		  (image-type 'packed-rgb-image)
		  (method :expand)
		  &allow-other-keys)
  (declare (sys:arglist (&key (user:name)
			      (file)
			      (method :expand)
			      (image-type 'packed-rgb-image)
			      image frame
			      &allow-other-keys)))
  (lexpr-funcall self :create-new-image
		 :image-type image-type
		 :method method
		 args))

(defmethod (:create-packed-yuv-image essential-image-methods)
	   (&rest args
		  &key
		  (image-type 'packed-yuv-image)
		  (method :expand)
		  &allow-other-keys)
  (declare (sys:arglist (&key (user:name)
			      (file)
			      (method :expand)
			      (image-type 'packed-yuv-image)
			      image frame
			      &allow-other-keys)))
  (lexpr-funcall self :create-new-image
		 :image-type image-type
		 :method method
		 args))

(defmethod (:create-32b-image essential-image-methods)
	   (&rest args
		  &key
		  (image-type '32b-image)
		  (method :expand)
		  &allow-other-keys)
  (declare (sys:arglist (&key (user:name)
			      (file)
			      (method :expand)
			      (image-type '32b-image)
			      image frame
			      &allow-other-keys)))
  (lexpr-funcall self :create-new-image
		 :image-type image-type
		 :method method
		 args))

(defmethod (:combine-peano essential-image-methods) 
	   (&key image
		  (bins-per-color 64.)
		  (buckets (- (expt 2 (useful-bits-per-pixel image)) 2))
		  (replay-offset 1)
		  (dither t)
		  jitter
		  (frame current-frame)
	     &allow-other-keys)

  (let* ((final-map-size (expt 2 (useful-bits-per-pixel image)))
	 (final-map (make-instance 'standard-color-map :size final-map-size)))

    (with-stack-list (bpc  bins-per-color bins-per-color bins-per-color)
      (tv:with-temp-sheet-raster
	(hist bpc ':initial-value 0 :type 'art-fixnum)

	(let ((peano-map (color-map-optimize
			   buckets bins-per-color
			   (send self :histogram-image
				 :to-array hist
				 :result-type :color
				 :bins-per-color bins-per-color
				 :frame frame)
			   (* (send self :width) (send self :height))))
	      )
	  (remap-optimize bins-per-color hist peano-map replay-offset)

	  (loop for i from replay-offset
		repeat buckets
		do
	    (multiple-value-bind (r g b)
		(send peano-map :read-color-map (- i replay-offset))
	      (send final-map :write-color-map i r g b)
	      ))

	  (send image :set-setup-color-map final-map)

	  (send self :with-single-bit-array
		#'(lambda (da)
		    (ignore da)
		    (multiple-value-bind (xs ys) (send self :size)
		      (send image :set-current-frame current-frame)
		      (send image :set-size xs ys)
		      (send image :create-bit-arrays)
		      (send self :remap-image
			    (send image :data-array)
			    hist
			    :color-map final-map
			    :width xs
			    :height ys
			    :jitter jitter
			    :dither dither
			    )))
		:frame frame)
	  )))
    final-map))


(defmethod (:send-image-to-window essential-image)
	   (window
	     &rest keywords
	     &key
	     (dx 0) (dy 0) (wdx 0) (wdy 0)
	     (tv:width width)
	     (tv:height height)
	     (edges :inside)
	     (disposition :unchanged)
	     force-reload
	     clear-before-load
	     (frame current-frame)
	     (inhibit-channels)
	     compression-method
	     write-mask from-field to-field
	     (scale 1)
	     (x-scale scale)
	     (y-scale scale)
	     &allow-other-keys)

  (check-arg disposition (memq disposition '(:unchanged :loaded :unloaded))
	     "One of :UNCHANGED :LOADED or :UNLOADED")

  (when write-mask
3    ;combine the effects of :inhibit-channels and :write-mask
0    (loop for bit from 0 by 8
	  as mv = (ldb (byte 8 bit) write-mask)
	  for chan in '(:red :green :blue :alpha)
	  when (and (zerop mv) (not (memq chan inhibit-channels)))
	    do (push chan inhibit-channels)
	  when (memq chan inhibit-channels)
	    do (setq write-mask (%logdpb 0 (byte 8 bit) write-mask))))
	  
  (when (< wdx 0)
    (setq dx (- dx wdx)
	  wdx 0))

  (when (< wdy 0)
    (setq dy (- dy wdy)
	  wdy 0))

  (when (< dx 0)
    (setq wdx (- wdx dx)
	  dx 0))

  (when (< dy 0)
    (setq wdy (- wdy dy)
	  dy 0))

  (setq tv:height (min (- height dy) tv:height)
	tv:width (min (- width dx) tv:width))

  (let* ((bnl (when (not (send self :bit-arrays-valid-p))
		(if (neq disposition :loaded)
		    t
		    (send self :load-binary-file :frame frame)
		    nil)))
	 (no-window (and window
			 bnl
			 (not (send self :load-direct-to-window window))
			 )))
    (unwind-protect
	(si:with-rem-keywords (keywords keywords '(:wdx :wdy :dx :dy :width :height
							:disposition :force-reload
							:inhibit-channels 
							:write-mask
							:compression-method
							:frame :edges :clear-before-load))

	  (cond (no-window
		 ;bitmaps will be loaded downstream from here
		 )
		(bnl
3		 ;load-binary-file can load directly to the window,
0		 (lexpr-send self ':load-binary-file
		       :window window
		       :FORCE-RELOAD force-reload
		       :wdx wdx
		       :wdy wdy
		       :width tv:width
		       :height tv:height
		       :dx dx
		       :dy dy
		       :edges edges
		       :clear-before-load clear-before-load
		       :frame frame
		       :inhibit-channels inhibit-channels
		       :write-mask write-mask
		       :from-field from-field
		       :to-field to-field
		       keywords
		       )))

	  (send self :set-current-frame frame t)

	  (when (or (null bnl) no-window)


	    (multiple-value (wdx wdy tv:width tv:height)
	      (resolve-edges window wdx wdy tv:width tv:height edges from-field to-field
			     :x-scale x-scale
			     :y-scale y-scale))

	    (when (and (> tv:height 0)
		       (> tv:width 0))

	      (when clear-before-load
		(tv:with-prepared-sheet-or-raster
		  (window :array array :window win :inside-width w :inside-height h)
		  (if win
		      (send win :clear-window)
		      (%draw-rectangle w h 0 0 tv:alu-setz array))))

	      (lexpr-send self ':copy-image-to-window window
			  dx dy
			  wdx wdy
			  tv:width tv:height compression-method
			  :write-mask write-mask
			  keywords))
	    ))
      (when (or (eq disposition :unloaded)
		(or no-window (and bnl window)))
	(send self :discard-bit-arrays :frame frame)))
    ))


(defmethod (:image-dump-form essential-image :nconc) ()
  `(:width ,width :height ,height))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 2FULL-COLOR1-IMAGE-MIXIN
0;;
;; methods common to all full color images
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defwhopper (:copy-image-to-window full-color-image-mixin)
	    (window dx dy wdx wdy wid hei &optional how &rest keywords)

  (selector (useful-bits-per-pixel window)
	    eql
    (8
      (lexpr-send self :32b-8b-copy  window wid hei wdx wdy dx dy how keywords)
      )
    (t (lexpr-continue-whopper window dx dy wdx wdy wid hei how keywords))))

(defmethod (:compose full-color-image-mixin)
	   (window dx dy wdx wdy wid hei &rest keywords)
  (let ((im (send self ':8b-image nil)))
    (coerce-screen-color-map window (send im :setup-color-map))
    (lexpr-send im :copy-image-to-window window dx dy wdx wdy wid hei nil
		:window-color-map (send im :setup-color-map)
		keywords)))

(defmethod (:combine-primary full-color-image-mixin)
	   (w dx dy wdx wdy wid hei &rest keywords)
  (lexpr-send self :combine w dx dy wdx wdy wid hei
	      :window-color-map *primary-only-color-map*
	      keywords))

(defmethod (:combine-grayscale full-color-image-mixin)
	   (w dx dy wdx wdy wid hei &rest keywords)
  (lexpr-send self :combine w dx dy wdx wdy wid hei
	      :window-color-map *standard-grayscale-map*
	      keywords))
	   

(defmethod (:combine full-color-image-mixin)
	   (w dx dy wdx wdy wid hei
	      &rest keywords
	      &key (color-map *standard-false-color-map*)
	      (window-color-map color-map)
	      (scale 1)
	      (x-scale scale)
	      (y-scale scale)
	      (rescale :select)
	      &allow-other-keys)
  (let ((to-wid (round (* wid x-scale)))
	(to-hei (round (* hei y-scale))))
  (tv:with-bit-array-or-stream
    self :input
    #'(lambda (data-array index strobe-or-span)
	(tv:with-bit-array-or-stream
	  w :output
	  #'(lambda (ar to-index to-strobe-or-span)
	      (when (and window-color-map
			 (typep w 'tv:sheet))
		  (coerce-screen-color-map (tv:sheet-screen w) window-color-map))
	      (let ((from-left 0)
		    (from-top 0)
		    (to-left 0)
		    (to-top 0))
		(when (fixp strobe-or-span)
		  (multiple-value (from-top from-left) (floor index strobe-or-span))
		  (setq strobe-or-span nil))
		(when (fixp to-strobe-or-span)
		  (multiple-value (to-top to-left) (floor to-index to-strobe-or-span))
		  (setq to-strobe-or-span nil))
		(si:with-rem-keywords
		  (keywords keywords '(:color-map :scale :x-scale :y-scale
						  :window-color-map))
		  (lexpr-funcall #'zoom-rectangle
				 :from-array data-array
				 :from-array-stream strobe-or-span
				 :from-image-type (send self :transfer-image-type-spec)
				 :to-array ar
				 :to-array-stream to-strobe-or-span
				 :from-left from-left
				 :from-top from-top
				 :from-right (+ from-left wid)
				 :from-bottom (+ from-top hei)
				 :to-left to-left
				 :to-top to-top
				 :to-right (+ to-left to-wid)
				 :to-bottom (+ to-top to-hei)
				 :rescale rescale
				 :to-image-type (transfer-image-type ar window-color-map)
				 :combination-array window-color-map
				 keywords)))
	      )
	  :x-offset wdx
	  :y-offset wdy
	  :width to-wid
	  :height to-hei)
	)
    :permit-rgb t
    :x-offset dx
    :y-offset dy
    :width wid
    :height hei))
  )


(defmethod (:remap-image full-color-image-mixin)
	   (dest-array assignment-array &key dither jitter color-map threshold
		       (dx 0)
		       (dy 0)
		       (wdx 0)
		       (wdy 0)
		       (fetch :rgba)
		       (separate (if dither :rgb :bins))
		       (user:width (send self :width))
		       (user:height (send self :height)))
  (let ((bins (array-dimensions assignment-array)))

    (when jitter
      (setq dither t)
      (unless threshold (when (numberp jitter) (setq threshold jitter)))
      (when (floatp threshold)
	(setq threshold (round (* threshold 255))))
      (unless threshold
	(setq threshold (// 256 (lexpr-funcall #'max bins)))))

    (tv:with-bit-array
      self :input
      #'(lambda (source sidx s-span)
	  (let ((dx 0)(dy 0))
	    (multiple-value (dy dx) (floor sidx s-span))
	    (tv:with-bit-array
	      dest-array :output
	      #'(lambda (da to-index to-span)
		  (let ((wdx 0)(wdy 0))
		    (multiple-value (wdy wdy)(floor to-index to-span))
		    (create-and-call-image-process
		      histogram-remap
		      `(:fetch ,fetch
			:store :rgba
			:combine ,(if dither :dithered-remap :remap )
			:separate ,separate
			:jitter ,(when jitter t)
			:dither ,(when dither t)
			:color-map t
			:threshold ,threshold
			:bins ,bins
			)
		      user:width user:height
		      source dx dy
		      da wdx wdy
		      :histogram assignment-array
		      :threshold threshold
		      :color-map color-map)))
	      :x-offset wdx
	      :y-offset wdy
	      :width user:width
	      :height user:height
	      )))
      :x-offset dx
      :y-offset dy
      :width user:width
      :height user:height
      :permit-rgb t
      ))
  dest-array)

(defmethod (:32b-8b-copy full-color-image-mixin)
	   ( window-or-array  wid hei wdx wdy dx dy  &optional how
	    &rest keywords
	    &key to-window color-map from-array separate
	    (window-color-map *standard-grayscale-map*)
	    (from-image-type 'false-color-image)
	    (scale 1)
	    (x-scale scale)
	    (y-scale scale)
	    (rescale :select)
	    &allow-other-keys)

  (ignore color-map)
  (setq how (choose-rgb-combination :how how :color-map window-color-map))

  (selectq how
    (:abort)
    ((:red :green :blue)
     (si:with-rem-keywords (keywords keywords '(:to-window :color-map :window-color-map
						:scale :x-scale :y-scale))
       (let ((to-wid (round (* wid x-scale)))
	     (to-hei (round (* hei y-scale))))
	 (tv:with-bit-array-or-stream
	   window-or-array :output
	   #'(lambda (to-raster to-index to-span)
	       (let ((wdx 0)(wdy 0))
		 (when (fixp to-span)
		   (multiple-value (wdy wdx) (floor to-index to-span))
		   (setq to-span nil))
		 (tv:with-prepared-sheet-or-raster
		   (window-or-array :screen scr :window win)
		   (when scr (send window-color-map :write-screen-map scr))

		   (lexpr-funcall #'zoom-rectangle :from-left dx :from-right (+ dx wid)
				  :from-top dy :from-bottom (+ dy hei)
				  :from-array from-array
				  :to-array to-raster
				  :to-array-stream to-span
				  :to-window (or to-window win)

				  :to-left wdx :to-top wdy
				  :to-right (+ wdx to-wid)
				  :to-bottom (+ wdy to-hei)

				  :from-image-type from-image-type
				  :separate separate
				  :to-image-type 'false-color-image
				  :rescale rescale
				  keywords
				  ))))
	   :x-offset wdx
	   :y-offset wdy
	   :width to-wid
	   :height to-hei)))
     )
    (t 
      (si:with-rem-keywords (keywords keywords '(:from-array))
	(lexpr-send self how window-or-array dx dy wdx wdy wid hei keywords)))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 1RGB-IMAGE-MIXIN
0;;
;; Common components for images stored in three parts,
;; nominally RGB,
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod (2can-i-make-the-right-input-stream0 rgb-image-mixin) (&rest ignore)
  3;if we are RGB, we can never make stream naturally
0  nil)

(defmethod (:fake-draw-line rgb-image-mixin) (fx fy tx ty)
  (when red (tv:%draw-line fx fy tx ty tv:alu-seta t red))
  (when green (tv:%draw-line fx fy tx ty tv:alu-seta t green))
  (when blue (tv:%draw-line fx fy tx ty tv:alu-seta t blue)))


(defmethod (:load-direct-to-window rgb-image-mixin) (w)
  (tv:with-prepared-sheet-or-raster (w :bits-per-pixel bits-per-pixel)
    ( bits-per-pixel 24)))

(defmethod (:create-me-message rgb-image-mixin) ()
  (values :create-rgb-image :rgb-image))

(defmethod (:rgb-image rgb-image-mixin) ()
  self)

(defmethod (:create-rgb-image rgb-image-mixin) (&rest args)
  (lexpr-send self :copy-image args))

(defmethod (:discard-bit-arrays rgb-image-mixin) ()
  (let ((r red) (g green) (b blue))
    (setq red nil)
    (setq green nil)
    (setq blue nil)
    (send self :deallocate-bit-array r g b)
    ))

(defmethod (:create-bit-arrays rgb-image-mixin) ()
  (let ((da (send self :data-array-type)))
    (setq red (send self :adjust-image-size red da width height))
    (setq green (send self :adjust-image-size green da width height))
    (setq blue (send self :adjust-image-size blue da width height))
    ))

(defmethod (:create-displaced-bit-arrays rgb-image-mixin) (window dx dy)

  (tv:with-prepared-sheet-or-raster
    (window :array array :screen scr)
    (let ((packed (when scr (send scr :packed-pixel-mode-arrays array))))
      (setq red (send self ':create-displaced-array
		      (or (first packed) array)
		      dx dy width height))
      (setq green (send self ':create-displaced-array
			(or (second packed)
			    array)
			dx dy width height))
      (setq blue (send self ':create-displaced-array
		       (or (third packed)
			   array)
		       dx dy width height))
	)))

(defwhopper (:32b-8b-copy rgb-image-mixin)
	    (window-or-array wid hei wdx wdy dx dy &optional how
			     &rest keywords
			     &key
			     (color-map)
			     &allow-other-keys)
  (setq how (choose-rgb-combination :how how :color-map color-map))
  (lexpr-continue-whopper window-or-array wid hei wdx wdy dx dy how
			  :from-array (selectq how (:red red)(:green green)(:blue blue))
			  keywords))


(defwhopper (:remap-image rgb-image-mixin)
	    (dest-array assignment-array
			&rest keywords
			&key dither
			(fetch :r+g+b)
			(separate (if dither nil :bins))
			&allow-other-keys)

  (lexpr-continue-whopper dest-array assignment-array
			  :fetch fetch
			  :separate separate
			  keywords)
  dest-array)


(defmethod (:create-8b-image rgb-image-mixin)
	   (&rest args
		  &key
		  (method :peano)
		  (color-map (selectq method
			       ((:grayscale :combine-grayscale
				 :red :green :blue) 
				*standard-grayscale-map*)
			       (:palette *standard-false-color-map*)
			       (:primary-palette *primary-only-color-map*)
			       (t nil)))
		  &allow-other-keys)
  
  (selectq method
    ((:red :green :blue)
     (lexpr-send self :create-new-image
	   :continuation
	   #'(lambda (im)
	       (send self :with-single-bit-array
		     #'(lambda (da)
			 (multiple-value-bind (xs ys) (send self :size)
			   (send im :set-size xs ys)
			   (send im :create-bit-arrays)
			   (bitblt tv:alu-seta xs ys
				   (selectq method
				     (:red (first da))
				     (:green (second da))
				     (:Blue (third da)))
				   0 0
				   (send im :data-array)
				   0 0))
			 )
		     ))
	   :image-type 'false-color-image
	   :color-map color-map
	   args)
     )
    ((:grayscale :combine-grayscale :peano
      :palette :primary-palette)
     (send self :create-new-image
	   :image-type 'false-color-image
	   :color-map color-map
	   :method method
	   ))
    (t (lexpr-send self method args)
       )))


(defun choose-rgb-combination-alist (&key alpha color-map (abort t))
  `(("Red " :value :red
     :documentation "Save only the red channel")
    ("Green " :value :green
     :documentation "Save only the green channel")
    ("Blue " :value :blue
     :documentation "Save only the blue channel")
    ,@(when alpha
	`(("Alpha " :value :alpha
	   :documentation "Save only the alpha channel")))
    ("Grayscale" :value :combine-grayscale
     :documentation "Convert the image to Grayscale")
    ("quick color composite" :value :combine
     :documentation "Use the standard 8 bit palette")
    ("best color composite" :value :compose
     :documentation "Create a unique color map for this image")
    ,@(when color-map
	`((,(format nil "use color map ~A" color-map)
	   :value :combine-map)
	  ))
    ,@(when abort
	`(("Forget it -abort" :value :abort :style (nil :italic nil))))))

(defun 2query-choice0 (choices label &key (query-by :guess) default)
  (when (eq query-by :guess)
    (setq query-by
	  (cond ((or (let ((selwin tv:selected-window))
		       (and (typep selwin 'dw::dynamic-lisp-listener)
			    (send (tv:sheet-screen selwin) :video-on)))
		     (not (typep zl:terminal-io 'tv:sheet)))
		 :accept)
		(t :menu)))
    )
  (cl:ecase query-by
    (:menu  (tv:menu-choose
	      choices
	      (or label " How shall I reduce full color to 8 bits? ")
	      '(:mouse)
	      default))
    (:accept (accept
	       `(dw::alist-member :alist ,choices)
	       :prompt (or label " How shall I reduce full color to 8 bits? ")
	       :default (third default))
	       )))

(defvar 2*last-rgb-choice*0 :combine)
(defun 2choose-rgb-combination
0       (&key
	(how)
	(msg)
        (alpha nil)
	(color-map)
	(query-by :guess)
	)

  (unless how
    (tv:unprepare-sheet
      (loop with choices = (choose-rgb-combination-alist :alpha alpha :color-map color-map)
	    until how
	    do (setq how (query-choice choices msg
				       :query-by query-by
				       :default (loop for i in choices
						      when (eq (third i) *last-rgb-choice*)
							return i)
				       )))))
  (setq *last-rgb-choice* how)
  how)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 1FALSE-COLOR-MIXIN
0;;
;; used for 8 bit/pixel images, provides color map services
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod (take-image-from-image false-color-mixin :after) (image &rest ignore)
  (setq setup-color-map (send image :setup-color-map))
  )

(defmethod (:image-dump-form false-color-mixin :nconc) ()
  (and setup-color-map (send setup-color-map ':image-dump-form)))

(defmethod (:b&w-translation-array false-color-mixin)
	   (&optional (intensity-operator :intensity))
  (cond ((null setup-color-map) nil)
	((eq setup-color-map *standard-grayscale-map*) nil)
	(t (send setup-color-map ':b&w-translation-array intensity-operator))))


(defmethod (:full-color-translation-array false-color-mixin)
	   (&optional (color-map setup-color-map))
  (cond ((null color-map)
	 (send *standard-grayscale-map* ':full-color-translation-array))
	(t
	 (send color-map ':full-color-translation-array))
	)
  )

(defmethod (:take-image-from-window false-color-mixin :before)
	   (window &key color-map &allow-other-keys )
  (if color-map
      (setq setup-color-map color-map)
      (tv:with-prepared-sheet-or-raster (window :screen scr :bits-per-pixel bpp)
	(if (and scr ( bpp 24.) (send scr :color-map))
	    (progn
	      (setq setup-color-map (make-instance 'standard-color-map))
	      (send setup-color-map :read-screen-map scr))
	    (setq setup-color-map
		  (standard-grayscale-map
		    (cdr (assoc (data-array-type (typep self)) array-bits-per-element))))
	    ))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 1SINGLE-PLANE-IMAGE-MIXIN 
0;; 
;; Common to 8 bit and 1 bit images.  If there ever is a 32bit-image-mixin,
;; where the image is stored in a single array, it will be common to those 
;; too
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod (:fake-draw-line single-plane-image-mixin) (fx fy tx ty)
  (let ((m (image-width-multiplier self)))
    (when data-array (tv:%draw-line (* m fx) fy (* m tx) ty tv:alu-seta t data-array))))

(defmethod (:create-displaced-bit-arrays single-plane-image-mixin :nconc) 
	   (window dx dy)
  
  (tv:with-prepared-sheet-or-raster (window :array screen-array)
    (setq data-array (send self ':create-displaced-array screen-array
			   dx dy width height))
    ))

(defmethod (:discard-bit-arrays single-plane-image-mixin) ()
  (let ((d data-array))
    (when d
      (setq data-array nil)
      (send self :deallocate-bit-array d))))

(defmethod (:create-bit-arrays single-plane-image-mixin :nconc) ()
  (setq data-array (send self ':adjust-image-size
			 data-array (send self ':data-array-type) width height)))
	    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 11BIT-IMAGE-MIXIN
0;;
;; the mixin flavor for 1bit/pixel images
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod (:create-me-message 1bit-image-mixin) ()
  (values :create-1b-image :1b-image))

(defmethod (:create-1b-image 1bit-image-mixin) (&rest args)
  (lexpr-send self :copy-image args))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 221BIT-IMAGE-MIXIN
0;;
;; the mixin flavor for 2bit/pixel images, with a color map
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod (:create-me-message 2bit-image-mixin) ()
  (values :create-2b-image :2b-image))

(defmethod (:create-2b-image 2bit-image-mixin) (&rest args)
  (lexpr-send self :copy-image args))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 241BIT-IMAGE-MIXIN
0;;
;; the mixin flavor for 4bit/pixel images, with a color map
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod (:create-me-message 4bit-image-mixin) ()
  (values :create-4b-image :4b-image))

(defmethod (:create-4b-image 4bit-image-mixin) (&rest args)
  (lexpr-send self :copy-image args))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 18BIT-IMAGE-MIXIN
0;;
;; the mixin flavor for 8bit/pixel images, with a color map
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod (:create-me-message 8bit-image-mixin) ()
  (values :create-8b-image :8b-image))


(defwhopper (:copy-image-from-window 8bit-image-mixin)
	   (window &optional  (dx 0) (dy 0) (wdx 0) (wdy 0) (wid width) (hei height)
		   how
		   &rest keywords
		   )
  (selector (tv:with-prepared-sheet-or-raster (window :bits-per-pixel bits-per-pixel)
	      bits-per-pixel)
	    eql
    ((32. 24.)
     (lexpr-send self :32b-8b-copy window wid hei wdx wdy dx dy how keywords))
    (t (lexpr-continue-whopper window dx dy wdx wdy wid hei how 
			       :to-image-type 'false-color-image
			       keywords)))
    )

;;
;; we can still call :create-8b-image to get an 8 bit image with different composition
;;
(defmethod (:create-8b-image 8bit-image-mixin)
	   (&rest keys
		  &key
		  (image-type 'false-color-image)
		  (method :peano)
		  (color-map (selectq method
			       ((:combine-grayscale :grayscale
				 :red :green :blue :alpha)
				*standard-grayscale-map*)
			       (:primary-palette *primary-only-color-map*)
			       (:palette *standard-false-color-map*)))
		  &allow-other-keys)

  (if (and (null color-map) (or (null method) (eq method :peano)))

      (si:with-rem-keywords (keys keys '(:method :color-map :buckets :bins-per-color))
	(lexpr-send self :copy-image keys))

      (lexpr-send self :create-new-image
		  :image-type image-type
		  :color-map color-map
		  keys)
      ))

(defwhopper (:create-new-image 8bit-image-mixin)
	    (&rest args &key translation-name method &allow-other-keys)
  (let ((args args))
    (when (memq method '(:red :green :Blue :alpha
			      :combine-grayscale
			      :grayscale))
      (setq args `(:translation-name
		    ,(or translation-name
			 (selectq method
			   (:red :red-translation-array)
			   (:green :green-translation-array)
			   (:blue :blue-translation-array)
			   (:alpha :alpha-translation-array)
			   ((:combine-grayscale :grayscale) :b&w-translation-array)))
		    ,@args)))
    (lexpr-continue-whopper args)
    ))

(defmethod (standard-color-map essential-image-methods) () nil)
(defmethod (standard-color-map 2bit-image-mixin) () *standard-2b-grayscale-map*)
(defmethod (standard-color-map 4bit-image-mixin) () *standard-4b-color-map*)
(defmethod (standard-color-map 8bit-image-mixin) () *standard-false-color-map*)

(defun coerce-screen-color-map (window color-map)
  (tv:with-prepared-sheet-or-raster (window :bits-per-pixel bits-per-pixel :screen screen)
    (when (and screen color-map)
      (when (and screen (= bits-per-pixel 8) (send screen :color-map))
	(when (symbolp color-map)
	  (setq color-map (or (standard-map-with-name color-map)
			      (and (boundp color-map) (symeval color-map))
			      (ferror "~A doesn't specify a color map" color-map))))
	(if (instancep color-map)
	    (send color-map ':write-screen-map screen)
	    (send screen ':new-color-map color-map))
	t))))

(defwhopper (:send-image-to-window false-color-mixin)
	    (window &rest args
		    &key window-color-map
		    (color-map setup-color-map)
		    &allow-other-keys)
  (let ((cmap (or window-color-map color-map)))
    (if (coerce-screen-color-map window cmap)
	(lexpr-continue-whopper window
				:window-color-map cmap
				args
				)
	(lexpr-continue-whopper window args))
    )
  )

(defmethod (:32b-8b-copy 8bit-image-mixin)
	   (window wid hei wdx wdy dx dy how
		   &rest keywords
		   &key
		   to-window
		   color-map
		   (window-color-map color-map)
		   (kill-derived-images t)
		   (to-image-type (send self :transfer-image-type-spec color-map))
		   &allow-other-keys)

  (setq how (choose-rgb-combination :how how :color-map window-color-map))
  (si:with-rem-keywords (keywords keywords '(:to-window :color-map :kill-derived-images))
    (selectq how
      (:abort)
      ((:red :green :blue :alpha :combine-grayscale :combine)
       (when kill-derived-images (kill-derived-images self))
       (cond ((memq how '(:combine :combine-map))
	      (unless window-color-map (setq window-color-map *standard-false-color-map*))
	      (setq to-image-type (send self :transfer-image-type-spec window-color-map))
	      )
	     ((eq how :combine-grayscale)
	      (setq to-image-type 'false-color-image)
	      (setq window-color-map nil)))
       (setq setup-color-map color-map)
       (with-bit-arrays ()
	 (tv:with-bit-array
	   window :input
	   #'(lambda (array idx span)
	       (multiple-value-bind (wdy wdx) (floor idx span)
		 (lexpr-funcall #'images-copy-32b-8b wid hei
				array wdx wdy data-array dx dy how
				:to-window (or to-window
					       (when (typep window 'tv:sheet) window))
				:to-image-type to-image-type
				:combination-array window-color-map
				keywords)))
	   :x-offset wdx
	   :y-offset wdy
	   :width wid
	   :height hei
	   )))
      (:compose
       (let ((temp-image (make-instance '32b-image :name nil)))
	 (send temp-image :take-image-from-window window :displaced t
	       :wdx wdx :wdy wdy :width wid :height hei)
	 (lexpr-send temp-image :create-8b-image :method :peano :image self
	       keywords)
	 (kill-image temp-image))
       )
      (t (ferror "32b-8b copy by method ~A is unimplemented" how)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 2321BIT-IMAGE-MIXIN
0;;
;; the mixin flavor for 32bit/pixel images, with a color map
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod (:rle-component-names 32bit-image-mixin) ()
  '(:red :green :blue :alpha))

(defmethod (:create-me-message 32bit-image-mixin) ()
  (values :create-32b-image :32b-image))

(defmethod (:create-32b-image 32bit-image-mixin) (&rest args)
  (lexpr-send self :copy-image args))



(defwhopper (:set-variable 32bit-image-mixin) (name to)
  (when (memq name '(:red :green :blue :alpha))
    (setq name :data-array))
  (continue-whopper name to))


(defmethod (:create-8b-image 32bit-image-mixin)
	   (&rest args
		  &key
		  (method :peano)
		  (color-map (selectq method
			       ((:grayscale :combine-grayscale
				 :red :green :blue :alpha)
				*standard-grayscale-map*)
			       (:palette *standard-false-color-map*)
			       (:primary-palette *primary-only-color-map*)
			       (t nil)))
		  &allow-other-keys)
  
  (selectq method
    ((:red :green :blue :alpha
	   :grayscale :combine-grayscale :peano
	   :palette :primary-palette)
     (lexpr-send self :create-new-image
		 :image-type 'false-color-image
		 :color-map color-map
		 :method method
		 args)
     )
    (t (lexpr-send self method args)
       )))

(defmethod (:32b-8b-copy 32bit-image-mixin)
	   (window wid hei wdx wdy dx dy how
		   &rest keywords
		   &key to-window color-map
		   (scale 1)
		   (x-scale scale)
		   (y-scale scale)
		   (rescale :select)
		   &allow-other-keys)
  (ignore color-map)
  (setq how (choose-rgb-combination :how how
				    :msg "How shall I reduce 32 bits to 8 bits?"
				    :color-map color-map
				    :alpha t))
  (when (eq how :grayscale) (setq how :combine-grayscale))
  (selectq how
    ((:red :green :blue :alpha)
     (si:with-rem-keywords (keywords keywords '(:to-window :color-map :scale :x-scale :y-scale))
       (let ((to-wid (round (* x-scale wid)))
	     (to-hei (round (* y-scale hei))))
	 (tv:with-bit-array-or-stream
	   self :input
	   #'(lambda (data-array index from-span)
	       (let ((from-x 0)
		     (from-y 0))
		 (when (fixp from-span)
		   (multiple-value (from-y from-x) (floor index from-span))
		   (setq from-span nil))
		 (tv:with-bit-array-or-stream
		   window :output
		   #'(lambda (array index span)
		       (let ((to-x 0)
			     (to-y 0))
			 (when (fixp span)
			   (multiple-value (to-y to-x) (floor index span))
			   (setq span nil))
			 (tv:with-prepared-sheet-or-raster (window
							     :screen scr
							     :window win)
			   (when scr (send *standard-grayscale-map* :write-screen-map scr))
			   (if (and (eql to-wid wid)
				    (eql to-hei hei))
			       (lexpr-funcall #'images-copy-32b-8b wid hei
					      data-array from-x from-y array to-x to-y how
					      :to-window (or to-window win)
					      :to-array-stream span
					      :from-array-stream from-span
					      keywords)
			       (lexpr-funcall #'zoom-rectangle
					      :fetch how
					      :rescale rescale
					      :from-array data-array
					      :to-array array
					      :from-left from-x
					      :from-top from-y
					      :to-left to-x
					      :to-top to-y
					      :from-right (+ from-x wid)
					      :from-bottom (+ from-y hei)
					      :to-right (+ to-x to-wid)
					      :to-bottom (+ to-y to-hei)
					      :to-window (or to-window win)
					      :to-array-stream span
					      :from-array-stream from-span
					      keywords))
					    
			   )))
		   :x-offset wdx
		   :y-offset wdy
		   :width to-wid
		   :height to-hei)))
	   :x-offset dx
	   :y-offset dy
	   :width wid
	   :height hei
	   ))))
    (:abort)
    (t (lexpr-send self how window dx dy wdx wdy wid hei keywords))))

(defwhopper (:create-new-image 32bit-image-mixin)
	    (&rest args &key from-image-type fetch separate method &allow-other-keys)
  (let ((args args))
    (when (memq method '(:red :green :blue :alpha))
      (setq args `(:fetch ,(or fetch method)
		   :separate ,(or separate nil)
		   :from-image-type ,(or from-image-type 'false-color-image)
		   ,@args)))
    (lexpr-continue-whopper args)))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 2PACKED-RGB1-IMAGE-MIXIN
0;;
;; the mixin flavor for packed-rgb/pixel images, with a color map
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defmethod (:rle-component-names packed-rgb-image-mixin) ()
  '(:red :green :blue))

(defmethod (:useful-bits-per-pixel packed-rgb-image-mixin) ()
  24.)

(defmethod (:compatible-pixel-depth packed-rgb-image-mixin) (with)
 (ignore with)
  nil)

(defwhopper (:create-displaced-array packed-rgb-image-mixin) (to dx dy w h)
  (continue-whopper to dx dy (* w 3) h))

(defwhopper (:adjust-image-size packed-rgb-image-mixin) (a type x y)
  (continue-whopper a type (* x 3) y))

(defmethod (:create-me-message packed-rgb-image-mixin) ()
  (values :create-packed-rgb-image :packed-rgb-image))

(defmethod (:create-packed-rgb-image packed-rgb-image-mixin) (&rest args)
  (lexpr-send self :copy-image args))

(defwhopper (:set-variable packed-rgb-image-mixin) (name to)
  (when (memq name '(:red :green :blue))
    (setq name :data-array))
  (continue-whopper name to))

(defwhopper (:32b-8b-copy packed-rgb-image-mixin)
	    (window-or-array wid hei wdx wdy dx dy &optional how
			     &rest keywords
			     &key
			     (color-map)
			     (separate)
			     &allow-other-keys)
  (setq how (choose-rgb-combination :how how :color-map color-map))
  (let ((keywords (if (member how '(:red :green :blue))
		      `(:separate 
			 ,(or separate
			      (selectq how
				(:red :packed-red)(:green :packed-green)
				(:blue :packed-blue)
				))
			 ,@keywords)
		      keywords)))
    (lexpr-continue-whopper window-or-array wid hei wdx wdy dx dy how
			    :from-array data-array
			    keywords)))

(defwhopper (:remap-image packed-rgb-image-mixin)
	    (dest-array assignment-array
			&rest keywords
			&key dither
			(fetch :packed-rgb)
			(separate (if dither nil :bins))
			&allow-other-keys)
  (lexpr-continue-whopper dest-array assignment-array
			  :fetch fetch
			  :separate separate
			  keywords)
  dest-array)


(defmethod (:create-8b-image packed-rgb-image-mixin)
	   (&rest args
		  &key
		  (method :peano)
		  (color-map (selectq method
			       ((:grayscale :combine-grayscale
				 :red :green :blue) 
				*standard-grayscale-map*)
			       (:palette *standard-false-color-map*)
			       (:primary-palette *primary-only-color-map*)
			       (t nil)))
		  &allow-other-keys)
  (selectq method
    ((:red :green :blue :peano
	   :grayscale :combine-grayscale 
	   :palette :primary-palette)
     (lexpr-send self :create-new-image
		 :image-type 'false-color-image
		 :color-map color-map
		 :method method
		 args
		 ))
    (t (lexpr-send self method args)
       )))

(defwhopper (:create-new-image packed-rgb-image-mixin)
	    (&rest args &key from-image-type separate method &allow-other-keys)
  (let ((args args))
    (when (memq method '(:red :green :blue))
      (setq args `(:separate ,(or separate
				  (selectq method
				    (:red :packed-red)
				    (:green :packed-green)
				    (:blue :packed-blue)))
		   :from-image-type ,(or from-image-type 'false-color-image)
		   ,@args)))
    (lexpr-continue-whopper args)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; 2PACKED-YUV1-IMAGE-MIXIN
0;;
;; the mixin flavor for packed-yuv/pixel images, with a color map
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod (:compatible-pixel-depth packed-yuv-image-mixin) (with)
  (ignore with)
  nil)

(defmethod (:useful-bits-per-pixel packed-yuv-image-mixin)()
  24.)

(defmethod (:rle-component-names packed-yuv-image-mixin) ()
  '(:Y :U :V))

(defmethod (:load-direct-to-window packed-yuv-image-mixin) (w)
  (if (send self :rle)
      (tv:with-prepared-sheet-or-raster (w :bits-per-pixel bpp)
	( bpp 8))
      t))

(defwhopper (:create-displaced-array packed-yuv-image-mixin) (to dx dy w h)
  (continue-whopper to dx dy (* w 2) h))

(defwhopper (:adjust-image-size packed-yuv-image-mixin) (a type x y)
  (continue-whopper a type (* x 2) y))

(defmethod (:create-me-message packed-yuv-image-mixin) ()
  (values :create-packed-yuv-image :packed-yuv-image))

(defmethod (:create-packed-yuv-image packed-yuv-image-mixin) (&rest args)
  (lexpr-send self :copy-image args))

(defwhopper (:set-variable packed-yuv-image-mixin) (name to)
  (when (memq name '(:Y :U :V))
    (setq name :data-array))
  (continue-whopper name to))

(defwhopper (:remap-image packed-yuv-image-mixin)
	    (dest-array assignment-array
			&rest keywords
			&key dither
			(fetch :packed-yuv)
			(separate (if dither :rgb :bins))
			&allow-other-keys)
  (lexpr-continue-whopper dest-array assignment-array
			  :fetch fetch
			  :separate separate
			  keywords)
  dest-array)

(defmethod (:create-8b-image packed-yuv-image-mixin)
	   (&rest args 
	    &key
	    (method :peano)
	    (color-map (selectq method
			 ((:grayscale :combine-grayscale
			   :red :green :blue) 
			  *standard-grayscale-map*)
			 (:palette *standard-false-color-map*)
			 (:primary-palette *primary-only-color-map*)
			 (t nil)))
	    &allow-other-keys)
  
  (selectq method
    ((:red :green :blue) (ferror "not yet")
     )
    ((:grayscale :combine-grayscale :peano)
     (lexpr-send self :create-new-image
		 :image-type 'false-color-image
		 :color-map color-map
		 :method method
		 args
		 ))
    ((:palette :primary-palette)
     (ferror "not yet"))
    (t (lexpr-send self method args)
       )))
