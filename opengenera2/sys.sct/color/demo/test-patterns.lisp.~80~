; -*- Base: 10; Lowercase: Yes; Mode: Lisp; Package: color; -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

;;
;; Maintain this file as an independently loadable file, not dependent on the rest of 
;; color-demo, so Craig can load it and do simple things.  
;;

(defvar demo-list nil)
(defvar test-patterns nil)
(defvar simple-patterns nil)

(defvar color-demo-lists '(("major demos" :value demo-list :style (nil :bold nil))
			   ("test patterns" :value test-patterns :style (nil :bold nil))
			   ("bar patterns" :value simple-patterns :style (nil :bold nil))))


(defvar color-demo-list 'demo-list)

(defun def-color-demo-internal (text method &optional (list 'demo-list))
  (when (nlistp method)
    (setq method `(:value ,method)))

  (loop for i in (symeval list)
	when (or (equal (car i) text)
		 (equal (cdr i) method))
	do (rplaca i text)
	   (rplacd i method)
	   (return text)
	finally
	   (set list (cons `(,text ,@method)
			   (symeval list)))))

(defmacro def-color-demo (text method &optional (list 'demo-list))
  `(def-color-demo-internal ',text ',method ',list))

(defun clear-window (w) (send w :clear-window))
(def-color-demo "Clear Window"
		(:value clear-window
		 :color-map :none
		 :documentation "Erase the demo window")
  test-patterns)
(def-color-demo "Clear Window"
		(:value clear-window
		 :color-map :none
		 :documentation "Erase the demo window")
  simple-patterns)

(defun test-grid (&optional (self terminal-io)
		  &key
		  (black-alu (tv:sheet-erase-aluf self))
		  (white-alu (tv:sheet-char-aluf self))
		  (fat (send (send self :screen) :send-if-handles :interlace))
		  (pixel-aspect-ratio (send (send self :screen) :pixel-aspect-ratio)))

  (let* ((scale-x (// 1.0  pixel-aspect-ratio))
	 (w  (* (send self :inside-width) pixel-aspect-ratio))
	 (h  (send self :inside-height))
	 (xm (// w 2))
	 (ym (// h 2))
	 (w  (* xm 2))
	 (h  (* ym 2))
	 (m  (// (min w h) 2))
	 (i  (fixr (* 0.1 (- m 5))))
	 (thickness (if fat 3 1)))

    (graphics:draw-rectangle 0 0 w h :stream self :alu black-alu
			     :scale-x scale-x)
    (graphics:draw-line 0 0 w h :stream self :alu white-alu :thickness thickness
			:scale-thickness t
			:scale-x scale-x)
    (graphics:draw-line w 0 0 h :stream self :alu white-alu :thickness thickness
			:scale-thickness t
			:scale-x scale-x)
    
    (loop for d from 0 to (max xm ym) by i
	  do
      (loop for sign in '(-1 1)
	    for xx = (+ 0 xm (* sign d))
	    for yy = (+ 1 ym (* sign d))
	    unless (and (= d 0) (= sign -1))
	      do
		(graphics:draw-line 0 yy w yy :stream self :alu white-alu
				    :thickness thickness
				    :scale-thickness t
				    :scale-x scale-x)
		(graphics:draw-line xx 0 xx  h :stream self :alu white-alu
				    :scale-thickness t
				    :scale-x scale-x)))
    
    (loop repeat 11
	  for r from 0 by i do
      (graphics:draw-circle xm ym r :stream self
			    :alu  white-alu :filled nil :thickness thickness
			    :scale-thickness t
			    :scale-x scale-x))
    
    (loop with max-dia = (min (- (// (sqrt (+ (* w w) (* h h))) 2)
				 (* 10 i))
			      (// (min w h) 2))
	  with x =     (fix (* i (1+ (fix (// xm i)))))
	  with y = (1- (fix (* i (1+ (fix (// ym i))))))
	  for r from 0 below max-dia by i
	  do
      (graphics:draw-circle (- xm x) (- ym y)  r  :stream self :alu white-alu
			    :filled nil :thickness thickness
			    :scale-thickness t
			    :scale-x scale-x)
      (graphics:draw-circle (- xm x) (+ ym y)  r  :stream self :alu white-alu
			    :filled nil :thickness thickness
			    :scale-thickness t
			    :scale-x scale-x)
      (graphics:draw-circle (+ xm x) (- ym y)  r  :stream self :alu white-alu
			    :filled nil :thickness thickness
			    :scale-thickness t
			    :scale-x scale-x)
      (graphics:draw-circle (+ xm x) (+ ym y)  r  :stream self :alu white-alu
			    :filled nil :thickness thickness
			    :scale-thickness t
			    :scale-x scale-x))))

(def-color-demo  "test grid"
		 (:value TEST-GRID
		  :documentation "Draw a test grid with circles and lines"
		  :color-map :none)
  test-patterns)

(defun test-reso (&optional (self terminal-io)
		  &key
		  (background-alu
		     (or (send (send self :screen) :send-if-handles
			       :compute-color-alu tv:alu-seta 0.4 0.4 0.4)
			 (make-instance 'general-sc-color-alu
					':fill-data (logior #o125
							    (lsh #o125 8)
							    (lsh #o125 16)))))
		  (white-alu tv:alu-ior)
		  (black-alu tv:alu-andca))

  (let* ((ih       (send self :inside-height))
	 (iw       (send self :inside-width))
	 (w-bits   (- (haulong iw) 1))
	 (width    (expt 2 w-bits))
	 (x-margin (// (- iw width) 2))
	 (y-step   (// ih (+ (* 2 w-bits) 2)))
	 (y-margin (// (- ih (* y-step (+ 1 (* 2 w-bits)))) 2)))

    (send  self  :draw-rectangle  iw ih  0 0 background-alu)

    (loop for x-step first width then (// x-step 2)
	  for y from 0 to w-bits
	  do
      (loop with h = (- y-step  (max 2 (fixr (// ih 250.0))))
	    with y1 = (+ y-margin (* y y-step))
	    with y2 = (- ih y1 y-step)
	    for x from x-margin to (+ x-margin width -1) by x-step
	    for phase first t then (not phase)
	    unless (= 1 x-step)
	      do
		(send self :draw-rectangle  x-step h  x y1
		      (if phase white-alu black-alu))
	    do
	(send self :draw-rectangle  x-step h  x y2
	      (if phase black-alu white-alu))))))

(def-color-demo "resolution chart"
		(:value TEST-RESO
		 :documentation
		 "Draw a resolution chart with progressively smaller features"
		 :color-map :none)
  test-patterns)


;;;----------------------------------------------------------------------------
;;; This stuff from >Paint>PLib


;;; Predicate for a number between 0 and 1.
(defun  number-between-0-and-1-p  (n)
  (and  (numberp  n)  (>=  n 0)  (<=  n 1)))

;;; Cause restartable error if specified arg is not a number between 0 and 1.
(defmacro  check-arg-0-1  (arg)
  `(check-arg  ,arg
	       number-between-0-and-1-p
	       "a number between 0 and 1"))


; Calculates a value by linearly extra(or inter)polating between two "extreme"
; values by a specified weighting factor which is expressed as a flonum.  
; Values of the weight between 0 and 1 correspond to the interval between the
; extreme values.
(defsubst  linear-extrapolation  (weight
				  value-for-weight-of-0  value-for-weight-of-1)
  (let* ((wt  (float weight))
	 (v0  value-for-weight-of-0)
	 (v1  value-for-weight-of-1)
	 (li  (+ (* wt (- v1 v0)) v0)))
    
    (if  (fixp v0)  (fixr li)  li)))

; Calculates a value by linearly interpolating between two "extreme" values by
; a specified weighting factor which is expressed as a flonum between 0 and 1
(defmacro linear-interpolation  (weight
				  value-for-weight-of-0  value-for-weight-of-1)
  `(progn
     (check-arg-0-1  ,weight)
     (linear-extrapolation  ,weight  ,value-for-weight-of-0  ,value-for-weight-of-1)))


; Ensures that a value lies between two bounds, by "clipping" to the bounding
; values if necessary.
(defsubst  force-into-range  (number  lower-bound  upper-bound)
  "Ensures that a number lies between a lower and upper bound."
  (min  (max  number  lower-bound)  upper-bound))

 

(defun chip-row-ramp 
	   (self r1 g1 b1  r2 g2 b2  number-of-steps  top-y  bot-y
	    &aux (screen (send self :screen)))

  (loop with          w = (send self :inside-width)
	with       bits = (send screen :bits-per-pixel)
	with        alu = (if (= bits 1)
			      tv:alu-xor
			      (send screen ':compute-color-alu tv:alu-seta 0))
	with      top-y = (fixr top-y)
	with      bot-y = (fixr bot-y)
	with chip-width = (// (* w .9) number-of-steps)
	with   chip-gap = (if (> chip-width 5)
			      (fixr (// chip-width 10))
			      0)
	with   half-gap = (if (zerop chip-gap) 0 (max 1 (// chip-gap 2)))
	for interpolant from 0.0 by (// 1.0 (- number-of-steps 1))
	for           i = (force-into-range  interpolant 0 1)
	for r = (linear-interpolation i (float r1) (float r2))
	for g = (linear-interpolation i (float g1) (float g2))
	for b = (linear-interpolation i (float b1) (float b2))
	for j from 0 below number-of-steps
	for x0 = (fixr (+ (// w 20) (* chip-width j)))
	for x1 = (fixr (+ (// w 20) (* chip-width (+ 1 j))))
	do
	(setq alu (send screen ':compute-color-alu alu r g b))
	(send self
	      :draw-rectangle
	      (- (- x1 x0) chip-gap -1)  (- bot-y top-y) 
	      (+ x0 half-gap)  top-y
	      alu)))



(defmacro outline-string-single (xoff yoff)
  `(send window
	 :display-x-y-centered-string
	 string
	 (+ ,xoff left) (+ ,yoff top)
	 (+ ,xoff right) (+ ,yoff bot)
	 ))

(defun outline-string  (window offset string left top right bot )
  (loop for x from 0 to offset do
	(loop for y from 0 to offset do
	      (outline-string-single (+ x) (+ y))
	      (outline-string-single (- x) (+ y))
	      (outline-string-single (+ x) (- y))
	      (outline-string-single (- x) (- y)))))


(defun display-outlined-string (window string left top right bot)
  (unless (null string)
    (letf (((tv:sheet-char-aluf window) tv:alu-setz))
      (outline-string window 3 string left top right bot)
      (outline-string window 2 string left top right bot)
      (outline-string window 1 string left top right bot))
    (letf (((tv:sheet-char-aluf window) tv:alu-seta))
      (outline-string-single 0 0))
    ))


(defun chip-row-list
	   (self rgb-list top-y  bot-y)

  (loop with          w = (send self :inside-width)
	with     screen = (send self :screen)
	with       bits = (send screen :bits-per-pixel)
	with        alu = (if (= bits 1)
			      tv:alu-xor
			      (send screen ':compute-color-alu tv:alu-seta 0))
	with      top-y = (fixr top-y)
	with      bot-y = (fixr bot-y)
	with   chip-gap = (// w 50)
	with chip-width = (fixr (// (* w .9) (length rgb-list)))
	for rgb in rgb-list
	for r = (first rgb)
	for g = (second rgb)
	for b = (third rgb)
	for name = (fourth rgb)
	for x from (// w 20) by chip-width
	for width = (- chip-width chip-gap)
	for height = (- bot-y top-y)
	for left = (+ x (// chip-gap 2))
	for top = top-y
	for right = (+ left width)
	for bot = (+ top height)
	do
	(setq alu (send screen ':compute-color-alu alu r g b))
	(send self :draw-rectangle width height left top alu)
	(display-outlined-string self  name left top right bot)))


(defun test-colors (&optional (self terminal-io))
  (send self :clear-window)

  (let* ((h (send self :inside-height))
	 (rygcbm-list-f '((1.0 0 0 "RED")
			  (1.0 1.0 0 "YELLOW")
			  (0 1.0 0 "GREEN")
			  (0 1.0 1.0 "CYAN")
			  (0 0 1.0 "BLUE")
			  (1.0 0 1.0 "MAGENTA")))
	 (rygcbm-list-b (reverse rygcbm-list-f))
	 (screen (send self :screen))
	 (segs (send screen ':number-of-segments ':gray)))

       (chip-row-list self rygcbm-list-f   (* h .02) (* h .19) )

       (chip-row-ramp self 0 0 0  1 1 1  (min segs 10)  (* h .33) (* h .47) )
       (chip-row-ramp self 1 1 1  0 0 0  (min segs 10)  (* h .53) (* h .67) )
       (chip-row-list self rygcbm-list-b   (* h .81) (* h .98) )
       
       (chip-row-ramp self 1 0 0  1 1 0  segs (* h .20) (* h .22) )
       (chip-row-ramp self 1 1 0  0 1 0  segs (* h .22) (* h .24) )
       (chip-row-ramp self 0 1 0  0 1 1  segs (* h .24) (* h .26) )
       (chip-row-ramp self 0 1 1  0 0 1  segs (* h .26) (* h .28) )
       (chip-row-ramp self 0 0 1  1 0 1  segs (* h .28) (* h .30) )
       (chip-row-ramp self 1 0 1  1 0 0  segs (* h .30) (* h .32) )

       (chip-row-ramp self 0 0 0  1 1 1  segs (* h .48) (* h .5) )
       (chip-row-ramp self 1 1 1  0 0 0  segs (* h .5) (* h .52) )
       
       (chip-row-ramp self 1 0 1  1 0 0  segs (* h .68) (* h .70) )
       (chip-row-ramp self 0 0 1  1 0 1  segs (* h .70) (* h .72) )
       (chip-row-ramp self 0 1 1  0 0 1  segs (* h .72) (* h .74) )
       (chip-row-ramp self 0 1 0  0 1 1  segs (* h .74) (* h .76) )
       (chip-row-ramp self 1 1 0  0 1 0  segs (* h .76) (* h .78) )
       (chip-row-ramp self 1 0 0  1 1 0  segs (* h .78) (* h .80) )
    )
  )

(def-color-demo "test colors and gray scales"
		(:value TEST-COLORS
		 :documentation "Draw a pattern of color chips and ramps"
		 :color-map :standard)
  test-patterns)
(defvar *default-screen-gamma* 1.0)
(defvar *default-ramp-width* 2)
(defun ntsc-color-bars (&optional (self terminal-io)
			&rest keywords
			&key (intensity 0.75)
			(make-color-map nil)
			(first-color 1)
			(height 1.0) (offset 0)
			(reverse nil)
			(luminance nil)
			(clear t)
			(multipliers '((1 1 1)))
			(colors '((1 1 1) (1 1 0) (0 1 1) (0 1 0)
				  (1 0 1) (1 0 0) (0 0 1) (0 0 0)))
			(span)
			(gamma *default-screen-gamma*)
			(ramp-width *default-ramp-width*)
			(ramp-mode nil)
			&aux w h)

  (unless self (setq self (color:demo-window)))
  (when clear (send self :clear-window))
  (multiple-value (w h) (send self ':inside-size))
  (setq offset (round (* offset h)))
  (let ((screen (send self :screen))
	(n-v-steps (length multipliers)))

    (when make-color-map
      (multiple-value-bind (nil nil type) (send screen :color-map-description)
	(when (neq type :dependent) (setq make-color-map nil))))
    (setq h (// (round (* h height)) n-v-steps))
    (multiple-value-bind (mode segn pixel-position) (send screen :map-mode)
      (ignore mode)
      (loop with allocated-colors = (cond ((eq make-color-map t)
					   (scl:make-hash-table :test #'equal))
					  (t make-color-map))
	    with next-color = first-color
	    for y from 0 by h
	    as (xb xg xr rev) in multipliers
	    do
	(loop with nc = (length colors) and brightness
	      for (red green blue) in colors
	      with  panel = (1+ (fix (if span (* span w) (* (// 1.0 nc) w))))
	      as place from 0 by panel do
	  (setq red (* red xr)
		green (* green xg)
		blue (* blue xb))
	  (when rev
	    (setq red (if (zerop xr) red (- 1 red))
		  green (if (zerop xg) green (- 1 green))
		  blue (if (zerop xb) blue (- 1 blue))))
	  (when reverse
	    (setq red (- 1 red)
		  green (- 1 green)
		  blue (- 1 blue)))

	  (setq brightness (rgb->y red green blue))
	  (when luminance (setq red brightness green brightness blue brightness))
	  (let* ((rr (expt (* red intensity) gamma))
		 (gg (expt (* green intensity) gamma))
		 (bb (expt (* blue intensity) gamma))
		 (brightness (expt brightness gamma))
		 (alu (if make-color-map
			 (with-stack-list (color (round (* rr 256))
						 (round (* gg 256))
						 (round (* bb 256)))
			   (or (gethash color allocated-colors)
			       (let ((alu (sc-fill-alu next-color -1)))
				 (when (> next-color 254)
				   (ferror "too many colors"))
				 (send screen :write-managed-map next-color rr gg bb segn nil)
				 (incf next-color)
				 (puthash (copylist color) alu allocated-colors)
				 alu)
			       ))
			 (send screen ':compute-color-alu tv:alu-seta rr gg bb))))

	    (unless (D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")0 pixel-position 24.)
	      1;put the luminance in alpha, unless that's where the data is
0	      (send alu :set-fill-data
		    (%logdpb (max 0 (min 255 (round (* brightness 255.99))))
			     (byte 8 24)
			     (send alu :fill-data))
		    ))

	    (cond ((null ramp-mode)
		   (send self ':draw-rectangle
			 panel h place (+ y offset) alu
			 ))
		  (t (labels ((ramp-internal (place)
				(let* ((p1 (send self :point
						 (- place ramp-width 1)
						 (+ y offset)))
				       (p2 (send self :point
						 (+ place ramp-width)
						 (+ y offset)))
				       (2w (* ramp-width 2))
				       (f2w (float (1+ 2w)))
				       (r1 (ldb (byte 8 0) p1))
				       (g1 (ldb (byte 8 8) p1))
				       (b1 (ldb (byte 8 16) p1))
				       (r2 (ldb (byte 8 0) p2))
				       (g2 (ldb (byte 8 8) p2))
				       (b2 (ldb (byte 8 16) p2)))
				  (loop as i from 1 to 2w
					as dx from (- place ramp-width)
					as r = (// (+ r1 (// (* i (- r2 r1)) f2w)) 255.0)
					as g = (// (+ g1 (// (* i (- g2 g1)) f2w)) 255.0)
					as b = (// (+ b1 (// (* i (- b2 b1)) f2w)) 255.0)
					do (send screen :compute-color-alu alu r g b)
					   (unless (10 pixel-position 24.)
						1;put the luminance in alpha, unless that's where the data is
0					     (setq brightness (rgb->y r g b))
					     (send alu :set-fill-data
						   (%logdpb (max 0 (min 255 (round (* brightness 255.99))))
							    (byte 8 24)
							    (send alu :fill-data))
						   ))
					   (send self :draw-rectangle 1 h dx
						 (+ y offset) alu)
					   ))))
		       (ramp-internal place)
		       (ramp-internal (+ place panel)))))

	    ))
	finally (when make-color-map
		  (send screen :new-color-map nil segn)
		  (return (values make-color-map next-color))
		  )

	)))
  (when (and ramp-width (> ramp-width 0) (null ramp-mode))
    (cl:apply #'ntsc-color-bars self :ramp-mode t :clear nil keywords))	
  )

(defun full-field-100%-bars (&optional window )
  (ntsc-color-bars window :intensity 1.0 :height 1.0))

(defun full-field-color-bars (&optional window)
  (ntsc-color-bars window))

(defun full-field-reverse-bars (&optional window)

  (ntsc-color-bars window :height 0.5)
  (ntsc-color-bars window :reverse t :height 0.5 :offset 0.5 :clear nil)
  )

(defun full-field-red-bars (&optional window)

  (ntsc-color-bars window :height 0.5)
  (ntsc-color-bars window :height 0.5 :offset 0.5 :colors '((1 0 0)) :clear nil)
  )

(defun full-field-luminance-bars (&optional window)
  (multiple-value-bind (map first)
      (ntsc-color-bars window :height 0.5 :make-color-map t)
    (ntsc-color-bars window :height 0.5 :offset 0.5 :clear nil :luminance t
		     :make-color-map map
		     :first-color first)))

(defun smpte-color-bars (&optional window)

  (ntsc-color-bars window :height 0.665
		   :colors '((1 1 1) (1 1 0) (0 1 1.0) (0 1 0) (1 0 1) (1 0 0) (0 0 1)))
  (ntsc-color-bars window :height 0.085 :offset 0.665 :clear nil
		   :colors '((0 0 1) (0 0 0) (1 0 1) (0 0 0) (0 1 1) (0 0 0) (1 1 1)))
  (ntsc-color-bars window :intensity 1.0 :offset (+ 0.665 0.085) :clear nil
		   :colors '((0.0 0.0 0.0) (1.0 1.0 1.0))
		   :span (// 5.0 28)
  ))

(defun fcc-color-bars (&optional w)
  (ntsc-color-bars w :intensity 1.0 :height 0.75 
		   :colors '((.77 .77 .77) (1.0 1.0 0) (0 1.0 1.0) (0 1.0 0)
			     (1.0 0 1.0) (1.0 0 0) (0 0 1.0)))
  (ntsc-color-bars w :intensity 1.0 :height 0.25 :offset 0.75 :clear nil
		   :colors '((0 .1696 .3013) (1.0 1.0 1.0) (.2085 0 .3652))
		   :span (// 5.0 28.)))


(defun ten-step-gray-wedge (&optional w)
  (ntsc-color-bars w :intensity 1.0 :height 1.0
		   :make-color-map t
		   :colors '((0 0 0) (0.1 0.1 0.1) (0.2 0.2 0.2) (0.3 0.3 0.3)
				    (0.4 0.4 0.4) (0.5 0.5 0.5) (0.6 0.6 0.6) (0.7 0.7 0.7)
				    (0.8 0.8 0.8) (0.9 0.9 0.9) (1.0 1.0 1.0))))


(defun ten-step-color-wedge (&optional w)
  (ntsc-color-bars w :intensity 1.0 :height 1.0
		   :make-color-map t
		   :multipliers '((0 0 1)(0 0 1 t)
				  (0 1 1)(0 1 1 t)
				  (0 1 0 )(0 1 0 t)
				  (1 1 0)(1 1 0 t)
				  (1 0 0)(1 0 0 t)
				  (1 0 1)(1 0 1 t)
				  (1 1 1) (1 1 1 t))
		   :colors '((0 0 0) (0.1 0.1 0.1) (0.2 0.2 0.2) (0.3 0.3 0.3)
				    (0.4 0.4 0.4) (0.5 0.5 0.5) (0.6 0.6 0.6) (0.7 0.7 0.7)
				    (0.8 0.8 0.8) (0.9 0.9 0.9) (1.0 1.0 1.0))))

(defun twenty-step-gray-wedge (&optional w)
  (ntsc-color-bars w :intensity 1.0 :height 1.0
		   :make-color-map t
		   :colors '((0 0 0) (0.05 0.05 0.05) (0.1 0.1 0.1) (0.15 0.15 0.15)
			     (0.2 0.2 0.2) (0.25 0.25 0.25)
		    (0.3 0.3 0.3) (0.35000002 0.35000002 0.35000002)
		    (0.40000004 0.40000004 0.40000004)
		    (0.45000005 0.45000005 0.45000005) (0.50000006 0.50000006 0.50000006)
		    (0.5500001 0.5500001 0.5500001) (0.6000001 0.6000001 0.6000001)
		    (0.6500001 0.6500001 0.6500001) (0.7000001 0.7000001 0.7000001)
		    (0.7500001 0.7500001 0.7500001) (0.80000013 0.80000013 0.80000013)
		    (0.85000014 0.85000014 0.85000014) (0.90000015 0.90000015 0.90000015)
		    (0.95000017 0.95000017 0.95000017))))

(defun twenty-step-color-wedge (&optional w)
  (ntsc-color-bars w :intensity 1.0 :height 1.0
		   :make-color-map t
		   :multipliers '((0 0 1)(0 0 1 t)
				  (0 1 1)(0 1 1 t)
				  (0 1 0 )(0 1 0 t)
				  (1 1 0)(1 1 0 t)
				  (1 0 0)(1 0 0 t)
				  (1 0 1)(1 0 1 t)
				  (1 1 1) (1 1 1 t))
		   :colors '((0 0 0) (0.05 0.05 0.05) (0.1 0.1 0.1) (0.15 0.15 0.15)
			     (0.2 0.2 0.2) (0.25 0.25 0.25)
		    (0.3 0.3 0.3) (0.35000002 0.35000002 0.35000002)
		    (0.40000004 0.40000004 0.40000004)
		    (0.45000005 0.45000005 0.45000005) (0.50000006 0.50000006 0.50000006)
		    (0.5500001 0.5500001 0.5500001) (0.6000001 0.6000001 0.6000001)
		    (0.6500001 0.6500001 0.6500001) (0.7000001 0.7000001 0.7000001)
		    (0.7500001 0.7500001 0.7500001) (0.80000013 0.80000013 0.80000013)
		    (0.85000014 0.85000014 0.85000014) (0.90000015 0.90000015 0.90000015)
		    (0.95000017 0.95000017 0.95000017))))

(def-color-demo "full field 100% bars"
		(:value full-field-100%-bars 
		 :documentation
		 "100% intensity color bars the full height of the window"
		 :color-map :standard)
  simple-patterns)
(def-color-demo "full field 75% bars"
		(:value full-field-color-bars
		 :documentation "75% intensity color bars the full height of the window"
		 :color-map :standard)
  simple-patterns)
(def-color-demo "bars + reverse bars"
		(:value full-field-reverse-bars
		 :documentation "top half: color bars  Bottom half: bars in rever order"
		 :color-map :standard)
  simple-patterns)
(def-color-demo "bars + red field"
		(:value full-field-red-bars
		 :documentation  "top half: color bars  bottom-half: red"
		 :color-map :standard)
 simple-patterns)
(def-color-demo "bars + luminance"
		(:value full-field-luminance-bars
		 :documentation "top half: color bars   bottom half: luminance of top half"
		 :color-map :change-8b)
  simple-patterns)
(def-color-demo "smpte color bars"
		(:value smpte-color-bars
		 :documentation "smpte standard color bars"
		 :color-map :standard
		 )
  simple-patterns)

(def-color-demo "fcc color bars"
		(:value fcc-color-bars
		 :color-map :standard
		 :documentation "fcc standard color bars"
		 )
  simple-patterns)

(def-color-demo "10 step gray bars"
		(:value ten-step-gray-wedge
		 :color-map :change-8b
		 :documentation "10 steps of gray bars")
  simple-patterns)

(def-color-demo "10 step color bars"
		(:value ten-step-color-wedge
		 :color-map :change-8b
		 :documentation "10 steps of color bars")
  simple-patterns)

(def-color-demo "20 step gray bars"
		(:value twenty-step-gray-wedge
		 :color-map :change-8b
		 :documentation "20 steps of gray bars")
  simple-patterns)

(def-color-demo "20 step color bars"
		(:value twenty-step-color-wedge
		 :color-map :change-8b
		 :documentation "20 steps of color bars")
  simple-patterns)

(def-color-demo "standardize color maps"
		(:value (lambda (w) (send (send w :screen)
					  :send-if-handles :standardize-color-map))
		 :documentation "Standardize the color maps for this screen"
		 :color-map :set-new)
  test-patterns)


(def-color-demo "grab frame"
		(:value grab-frame
		 :documentation
		 "use the frame grabber (if there is one) to grab and display a frame"
		 :color-map :none))

(def-color-demo "load or save image" 
		(:value (lambda (window)
			  (load-images-system)
			  (funcall 'save-window window :clear-before-load :unless-edges)
			  )
		 :color-map :none
		 :documentation "invoke IMAN to load or save an image"
		 ))

(def-color-demo "color editor"
		(:value (lambda (window)
			  (load-color-editor-system)
			  (funcall 'edit-color ))
		 :documentation "Invoke the color editor"
		 :color-map :any
		 ))


(defvar demo-window nil)

;;
;; Find a suitable color-demo-window on a color screen
;;

(tv:def-display-window-operation "Color Demo"
				 :value demo
				 :documentation "Run color:demo on this window")

(defun demo-window (&optional screen)
  (let ((screen (find-color-screen
		  :error-p nil
		  :message (when (eq screen t) #'ignore)
		  :frame-grabbers nil
		  :which :default
		  :default screen
		  :create-p t
		  )))
    (when screen
      (or (tv:find-window-of-flavor
	    'tv:window
	    0
	    #'(lambda (w)
		(tv:display-window-p
		  w 
		  :predicate
		  #'(lambda (w) (and (eq (tv:sheet-screen w) screen)
				     (tv:window-is-selectable w)
				     (= (tv:sheet-width w) (tv:sheet-inside-width screen))
				     (= (tv:sheet-height w) (tv:sheet-inside-height screen))
				     )))))
	  (tv:make-window 'tv:display-window :superior screen :borders nil :label nil
			  :name "Color Demo Window"
			  :blinker-p nil)))))
#||

 We use a :COLOR-MAP property of the item list to indicate what color
map actions and expectations the demo has.  The currently known values
are:

    :NONE         ;no expectation.  Any color map, or no color map, is OK
    :ANY          ;a color map is expected, but any is ok.  No changes are made
    :CHANGE       ;the color map is changed, and needs to be reverted after
    :CHANGE-8B    ;the color map is changed on 8 bit systems.
    :NEW	  ;deliberate changes are made.  Keep them
    :STANDARD     ;the standard color map is expected   

||#
 
(defun demo (&optional window screen)
  
  (cond ((eq window t)
	 ;; hack the args so (demo t) makes a new screen
	 (setq screen t)
	 (setq window nil)))

  (unless window
    (setq window (setq demo-window (demo-window screen))))

  (if (null window)
      (format t "no color screen designated~%")

      (setq screen (send window :screen))
      (let ((m tv:mouse-sheet)
	    (demo-color-map (when (send screen :color-map)
			      (send screen :make-color-map-image)))
	    (overlay-is-dependent (multiple-value-bind (nil nil mode)
				      (send screen :color-map-description)
				    (eq mode :dependent)))
	    (color-map :standard))

	(when demo-color-map
	  (copy-array-contents (send screen :color-map-image) demo-color-map))

	;; for cad buffer overlay -- select main screen and put the mouse there
	(unless (send screen :video-on)
	  (send screen :set-video-on t)
	  (when (and (instancep m)
		     (send m :invisible-to-mouse-p))
	    (tv:mouse-set-sheet screen)))
	
	(unless (send window :exposed-p)
	  (send window ':expose))
	
	(unwind-protect
	    (loop with next and this-item and label
		  as demos = (append (symeval color-demo-list)
				     (loop for i in color-demo-lists
					   as list-id = (third i)
					   if (eq list-id color-demo-list)
					     do (setq label (first i))
					   else collect i))
		  and next-item = (loop for i in demos when (eq (third i) next) return i)
		  while (not (send terminal-io ':any-tyi-no-hang))
		  do
	      (multiple-value (next this-item)
		(tv:choose-with-menu
		  :choices demos
		  :label `(:string ,(or label "Color Hacks")
			   :style (nil nil :very-large))
		  :mouse (tv:sheet-mouse window)
		  :default-item next-item
		  ))
	      (unless next (loop-finish))
	      (let ((new-color-map (get this-item :color-map)))
		(if (and (null demo-color-map)
			 (not (memq new-color-map '(:none nil))))
		    (tv:mouse-y-or-n-p "This demo won't run on this screen")
		    
		    (when (and (neq color-map :standard)
			       (memq new-color-map '(:standard :change-8b)))
		      (setq color-map :standard)
		      (send screen :new-color-map demo-color-map))
		    (catch-error-restart ((error sys:abort) "Color Demo Menu")
		      (send window ':clear-input)
		      (cond ((keywordp next)
			     (funcall window next))
			    ((functionp next)
			     (funcall next window))
			    ((and (boundp next)
				  (listp (symeval next)))
			     (setq color-demo-list next)))))
		(cond ((eq new-color-map :new)
		       (copy-array-contents (send screen :color-map-image) demo-color-map)
		       (setq color-map :standard))
		      ((eq new-color-map :change)
		       (setq color-map :nonstandard))
		      ((and (eq new-color-map :change-8b)
			    overlay-is-dependent)
		       (setq color-map :nonstandard)))
		))
	  (let ((scr (send terminal-io :send-if-handles :screen)))
	    ;; for cad buffer overlay, put overlay screen back
	    (unless (send scr :video-on)
	      (send scr :set-video-on t))
	    (tv:mouse-set-sheet m))
	  (unless (or (null demo-color-map)
		      (eq color-map :standard))
	    (send screen :new-color-map demo-color-map)
	    )
	  )))
  window
  )

(defun system-menu-demo ()
  (let ((window (demo-window)))
    (when window
      (tv:window-call (window :deselect)
	(send window :select)
	(demo window)))))

(defun (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")square-color-map0 (window &optional trans)
  (let* ((scr (tv:sheet-screen window))
	 (alu (send scr ':compute-color-alu tv:alu-seta 0)))
    (multiple-value-bind (w h)
	(send window :inside-size)
      
      (send window :clear-window)
      (loop with size = (COND (trans (array-length trans))
			      ((send scr :color-map-description))
			      (T 256))
	    with cols = (if (= size 256.) 32. (round (sqrt size)))
	    with rows = (ceiling size cols)
	    for i from 0 below cols do
	(loop for j from 0 below rows
	      as dat = (+ (* j cols) i)
	      do
	  (send alu ':set-fill-data (cond (trans (aref trans dat))
					  ((= size 256)
					   (dpb dat (byte 8 24.)
						(dpb dat (byte 8 16.)
						     (dpb dat (byte 8 8 ) dat))))
					  (t dat)))
	  (send window ':draw-rectangle (// w cols) (// h rows)
		(* i (// w cols)) (* j (// h rows))
		alu)
	  )
	))))

(def-color-demo "Color Map Squares"
		(:value square-color-map
		 :documentation "Paint a grid of all the colors in the color map"
		 :color-map :any
		 )
  test-patterns)

#||
(def-color-demo "Keep this color map"
		(:value ignore
		 :documentation "Keep this color map as the standard one"
		 :color-map :new)
  test-patterns)
||#

1;;
;; 2How to interpret the DAC test
1;;
;; The dac test is intended as a visual test of the dac's output stage.
;;
;; The screen is divided into 5 rows.  The top four rows test RED, GREEN, BLUE, 
;; and GRAY respectively.  The bottom row labels the columns.   The screen is
;; divided into 8 columns, each tests a different bit of the DAC's output.  The
;; colomns are graduated in intensity from 3/4 brightness at the left to 1/2
;; brightness at the right.
;;
;; The main area of the screen is therefore an array of 8x4 squares, each of which
;; should be approximately uniform in color.  Any significant divergence from a uniform
;; color indicates a problem with the DAC.
;;
;; Each of the test squares is actually divided into six sub squares which should
;; not be noticably different in color.
;;
;; The top half of each square is driven from small color map input values,
;; while the bottom half of each square is driven from large color map inputs.
;; The 0visible 1color of the top and bottom halves should be identical.  
0;; 1If you can see any horizontal0 1division at all, there is some problem with
0;; 1the input bits to the DACS, which0 1could mean a problem with the DACS themselves 
0;; 1or with the color maps, or with0 1color memory.  
;; If the top and bottom halves of each square are identical, then
;; everything up to the DACS is probably working, and therefore any problems are 
;; probably in the DACS themselves or in the monitor you are using.
;;
;; Each square is subdivided from right to left into three regions, with the middle
;; region very slightly brighter than the left and right regions.  If there is any 
;; gross difference in color in a whole section of a square, the dac may have failed
;; completely. You may be able to see the dividing line between the regions as a 
;; faint vertical mach band.  If you can see the division at all, it should appear 
;; purely as a boundary between two regions, with no noticable difference in color 
;; at the boundary itself.  If you see any noticable extraneous color at any 
;; boundary inside any square,  The problem may be fixed by tweaking the 
;; "glitch adjustment" on the dac.  See you customer service rep.  
;;
;; Summary:  Any differneces between the top and bottom halves of each square
;;           indicate a problem before the data gets to the DAC.
;;
;;           Any gross deviations from left-right gradient indicates a total DAC
;;0	     1failure.
;;
;; 0	     1Any subtle vertical lines at the 1/3 and 2/3 point indicate a DAC in
;;0	     1need of glitch adjustment.
;;
0(defun dac-test (window)
  (let* ((scr (send window :screen))
	 (wid (send window :inside-width))
	 (seg-width (// wid 8))
	 (seg-one (// seg-width 3))
	 (seg-three (- seg-width seg-one seg-one))
	 (full-height (send window :inside-height))
	 (hei (- full-height (// full-height 8)))
	 (seg-height (// hei 4))
	 (seg-height-1 (// seg-height 2))
	 (seg-height-2 (- seg-height seg-height-1))
	 )

    (multiple-value-bind (n-slots nil map-type)
	(send scr :color-map-description)

      (unwind-protect
	  (let* ((slot-mask (1- n-slots))
		 (slot-high-bit (lsh 1 (1- (haulong  slot-mask)))))

	    (send scr :initialize-color-map
		  (send scr :map-segment-number)
		  (send scr :color-map-image)
		  1;;
0		  1;; this generates a color map with the following characteristics
0		  1;; black and white at 0 and end
0		  1;; From 1-16  and end-1 to end-16   shades of red 
0		  1;;      17-.. and end-17 .. shades of green
0		  1;;      ... shades of blue
0		  1;;      ... shades of gray
0		  1;; the shades are intensity graded from 1/2 to 3/4, the odd elements
0		  1;; include a power of two and the next higher even elements one less
0		  1;;
0		  #'(lambda (slot)
		      (cond (( slot 0) (values 0 0 0))
			    (( slot slot-mask) (values 1023. 1023. 1023.))
			    (t
			     (when (bit-test slot slot-high-bit)
			       (setq slot (logxor slot slot-mask)))
			     (let* ((slot (1- slot))
				    (color (// slot 16))
				    (intensity-spec (\ slot 16))
				    (color-bit (lsh 1 (// intensity-spec 2)))
				    (color-spec (logior (lsh 1 9) (lsh color-bit 2)))
				    (intensity (if (oddp intensity-spec)
						   (1- color-spec)
						   color-spec))
				    )
			       (values (if (or (= color 0) ( color 3)) intensity 0)
				       (if (or (= color 1) ( color 3)) intensity 0)
				       (if ( color 2) intensity 0)))
			     ))))
			    
	    (send scr :new-color-map (send scr :color-map-image)
		  (send scr :map-segment-number))
	    (send window :clear-window)
	    (multiple-value-bind (nil nil p) (send scr :map-mode)
	    (loop with alu = (send scr :compute-color-alu tv:alu-seta :white)
		  and 8-bit = (eq map-type :dependent)
		  for bit in '(6 5 4 3 2 1 0 7)
		  as x from 0 by seg-width
		  as val = (* 2 bit)
		  do

	      (loop for color from 0 to 3
		    as y from 0 by seg-height
		    as color-base = (1+ (* color 16))
		    as fill-data-1 = (+ val color-base)
		    as fill-data-2 = (1+ fill-data-1)
		    as x2 = (+ x seg-one seg-one)
		    do
		(send alu :set-fill-data
		      (if 8-bit
			  (lsh fill-data-2 p)
			  (dpb fill-data-2 (byte 8 16)
			       (dpb fill-data-2 (byte 8 8) fill-data-2))))
		(send window :draw-rectangle seg-one seg-height-1
		      x y alu)
		(send window :draw-rectangle seg-three seg-height-1
		      x2 y alu)
		(send alu :set-fill-data (lognot (send alu :fill-data)))
		(send window :draw-rectangle seg-one seg-height-2
		      x (+ y seg-height-1) alu)
		(send window :draw-rectangle seg-three seg-height-2
		      x2 (+ y seg-height-1) alu)
		
		(send alu :set-fill-data
		      (if 8-bit
			  (lsh fill-data-1 p)
			  (dpb fill-data-1 (byte 8 16)
			       (dpb fill-data-1 (byte 8 8) fill-data-1))))
		(send window :draw-rectangle seg-one seg-height-1
		      (+ x seg-one) y alu)
		(send alu :set-fill-data (lognot (send alu :fill-data)))
		(send window :draw-rectangle seg-one seg-height-2
		      (+ x seg-one) (+ y seg-height-1) alu)

		finally 
		  (send window :draw-rectangle seg-width (- full-height hei) x hei alu)
		)

	      (send window :draw-lines tv:alu-seta
		    x hei
		    (+ -1 x seg-width) hei
		    (+ -1 x seg-width) full-height)

	      (with-character-style ('(:dutch :bold :very-large) window)
		(display-outlined-string window (format nil "bit ~A" bit)
					 x hei (+ x seg-width) full-height))
	      )))
	))))

(def-color-demo  "Dac output test"
		 (:value dac-test
		  :color-map :change
		  :documentation "A pattern specifically designed to visually test DACs"
		  )
  test-patterns )


;;
;; add color demo to the system menu
;;
(tv:add-to-system-menu-programs-column
  "Color Demo"
  '(process-run-function "color demo" 'color:system-menu-demo)
  "run the color demo loop")

;patch
(define-cp-command  (demonstrate-color :command-table :global)
    (&key (make-new-screen 'boolean
			   :default nil
			   :documentation "Force Creation of a new screen")
	  (window 'tv:display-window
		  :documentation "A color window to use")
	  (screen 'color-screen
		  :documentation "A color screen to use")
	  )
   (demo (or make-new-screen window)
	 screen))


(defun 2reverse-ramps0 (window)
  (let* ((scr (send window :screen))
	 (segn (send scr :map-segment-number)))

    (multiple-value-bind (n-slots nil map-type) (send scr :color-map-description)
      (multiple-value-bind (width height)
	  (send window :inside-size)

	(when (eql map-type :dependent)
	  (send scr :initialize-color-map segn (send scr :color-map-image))
	  (send scr :new-color-map nil segn))

	(tv:with-bit-array 
	  window :output
	  #'(lambda (ar idx span)
	      (ignore span)
	      (let ((ar ar))
		(declare (sys:array-register-1d ar))
		(loop with fw = (float width)
		      for x from idx below width
		      for value = (fix (* n-slots (// x fw)))
		      for packed-value = (%logdpbs value (byte 8 24)
						   value (byte 8 16)
						   value (byte 8 8)
						   value)
		      do
		  (setf (raster-aref ar x 0) packed-value))))
	  :width width
	  :height 1
	  :x-offset 0
	  :y-offset 0)
	(let ((half (lsh height -1)))
      (send window :bitblt-within-sheet
	    tv:alu-seta width (1- half) 0 0 0 1)
      (send window :bitblt-within-sheet
	    color:alu-~x width 1 0 0 0 half)
      (send window :bitblt-within-sheet
	    color:alu-seta width (- height half 1) 0 half 0 (1+ half))
      )))))
	
(def-color-demo  "Continuous Gray Ramps"
		 (:value reverse-ramps
		  :color-map :change-8b
		  :documentation "Continous gray ramp and reverse ramp"
		  )
  test-patterns )
		 
		 
