;;-*- Mode: LISP; Package: COLOR; Base: 8 -*- 
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

;;
;; Expanded fonts are not needed for simple fonts anymore, but they may still
;; be used as grayscale fonts.
;;
(defun color-font-info (bits-per-pixel)
  (selectq bits-per-pixel
    (2 (values 2 'fonts:2bit-font))
    (4 (values 4 'fonts:4bit-font))
    (8. (values 8 'fonts:8bit-font))
    ((16. 24. 32.) (values 32. 'fonts:32bit-font))))

(defstruct (expanded-font (:include font) :conc-name (:size-symbol expanded-font-leader-size))
  original-font					;Font that this was expanded from
  expansion-factor				;How wide this font is
  )

(defselect ((expanded-font named-structure-invoke))
  (:print-self (font stream &rest ignore)
   (si:printing-random-object (font stream :typep)
     (princ (font-name font) stream))))

(defun make-wide-font (old-fd expansion mask prop-name)
  (check-arg expansion (memq expansion '(2. 8. 16. 32.)) "2., 8., 16., or 32.")
  (multiple-value-bind (width height)
      (decode-raster-array old-fd)
    (let* ((array-type (selectq expansion
			 (2. 'art-2b)
			 (4. 'art-4b)
			 (8. 'art-8b)
			 (16. 'art-16b)
			 (32. 'art-fixnum)))
	   (new-fd (make-raster-array width height ':type array-type
				      ':leader-length expanded-font-leader-size
				      ':named-structure-symbol t))
	   (font-name (intern (format nil "EXP~D-~A" expansion (font-name old-fd))
			      'fonts)))
      (dotimes (i (array-leader-length old-fd))
	(setf (array-leader new-fd i) (array-leader old-fd i)))
      (setf (array-leader new-fd 1) 'expanded-font)
      (setf (font-name new-fd) font-name)
      (setf (expanded-font-original-font new-fd) old-fd)
      (setf (expanded-font-expansion-factor new-fd) expansion)
      (dotimes (x width)
	(dotimes (y height)
	  (setf (raster-aref new-fd x y)
		(if (zerop (raster-aref old-fd x y))
		    0				;In case an ART-Q
		    mask))))
      (putprop font-name new-fd prop-name)
      (putprop (font-name old-fd) font-name prop-name)
      ;; Backlink.  Is this used?
      (putprop font-name (font-name old-fd) 'fonts:cpt-font)
      (set font-name new-fd)
      new-fd)))





(defun setup-hardware-slots (cont-type &optional slot)
  ;; N specifies the controler in slot N
  (loop for cont in (color-controllers)
	when (eq (first cont) cont-type)
	do
	(if (or (null slot) (= slot (second cont)))
	    (return (values (second cont) (third cont)))
	    )))

;;; A place to keep track of exposed screens
(defvar *sc-exposed-screens* (cl:make-hash-table))

;;
;; Common pieces of the control protocol
;;
(defvar *dummy-array* (make-array 0))
(defflavor common-control-mixin
	(control
	 control-image
	 control-address
	 sync-program 
	 number-of-planes
	 tv:bits-per-pixel
	 (tv:buffer *dummy-array*);; randomness for the standard system screen stuff
	 (packed-mode-bases)
	 (fill-mode-base)
	 (pixel-mode-base)
	 (unused-screen-memory)
	 )
	(simulate-bow-mode-mixin
	 control-protocol)
  (:gettable-instance-variables
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")   ;all but uused-screen-memory
0   control control-image control-address
   sync-program number-of-planes tv:bits-per-pixel
   tv:buffer packed-mode-bases fill-mode-base pixel-mode-base)
  (:settable-instance-variables sync-program control-image control)
  (:required-methods :total-screen-array-elements)
  (:initable-instance-variables number-of-planes sync-program control-address)
  (:init-keywords :backplane-slot :base-addresses :pixel-width :put-sync-on-video
   :interlace :x-pan :y-pan :x-zoom :y-zoom)
  )

(defmethod (:adjusted-width-for-screen common-control-mixin :default)
	   (width bpp to-be-visible)
  (ignore to-be-visible)
  (let ((round-to (// 32. bpp)))
1    ;no problem with BPP becuase we use only a margin allocator
0    (* round-to (ceiling width round-to))))

(defun validate-map-mode (screen &optional new-mode new-segment
			  new-map-source new-overlay-source
			  cont)
  (let ((map-modes (send screen :map-modes)))
    (multiple-value-bind (old-mode old-segn old-source old-overlay-source)
	(send screen :color-map-description cont)
      (multiple-value-bind (nil n-segs)
	  (send screen :color-map-description new-mode)
	(multiple-value-bind (old-pixel-positions old-overlay-positions)
	    (send screen :pixel-positions new-mode)

	  (if (null new-mode)
	      (setq new-mode old-mode)
	      (unless (memq new-mode map-modes)
		(ferror "~A isn't a valid map mode, ~A are the valid modes"
			new-mode map-modes)))

	  (if (null new-segment)
	      (setq new-segment old-segn)
	      (unless ( 0 new-segment (1- n-segs))
		(ferror "~A isn't a valid map segment number,~&~
		the valid values for map mode ~A are 0 to ~D"
			new-segment
			new-mode
			(1- n-segs))))
	  (if (null new-map-source)
	      (setq new-map-source old-source)
	      (unless (memq new-map-source old-pixel-positions)
		(ferror "~A isn't a valid map source,~&~
		the valid values for map mode ~A are ~{~D, ~}"
			new-map-source
			new-mode
			old-pixel-positions)))
	  (if (null new-overlay-source)
	      (setq new-overlay-source old-overlay-source)
	      (unless (memq new-overlay-source old-overlay-positions)
		(ferror "~A isn't a valid overlay source,~&~
		the valid values for map mode ~A are ~{~D, ~}"
			new-overlay-source
			new-mode
			old-overlay-positions)))))))
  t)


(defmethod (tv:screen-open-all-conflicting-blinkers common-control-mixin)
	   (left top right bottom)
  left right top bottom
  (let ((mouse (tv:sheet-mouse self)))
    ;; Disable fast tracking for the whole screen.
    (when (and mouse (eq self (tv:mouse-sheet mouse)))
      (tv:suspend-mouse-cursor mouse))))

;;
;; Given X,Y  or A pixel value, or an alu-instance containing fill-data,
;; compute the RGB actually driving the current video.
;;
(defmethod (:rgb-for-color common-control-mixin) (color &optional y)
  (let* ((rgb (cond (y (send self :point color y))
		    ((fixp color) color)
		    ((instancep color)
		     (multiple-value-bind (ignore ignore ignore fill)
			 (send color :sc-parameters self (send self :screen-array))
		       fill))
		    (t (ferror "~A Not valid as a color spec" color)))))
    (multiple-value-bind (mode segment-number data-p data-s overlay-p overlay-s)
	(send self :map-mode)
      (send self :visible-pixel
	    mode
	    (load-byte rgb data-p data-s)  ;; data bits
	    (load-byte rgb overlay-p overlay-s) ;; overlay bits
	    segment-number))))

;;
;; As above, except returns them as flonums
;;
(defmethod (:flonum-rgb-for-color common-control-mixin) (color &optional y)
  (multiple-value-bind (r g b segment-number)
      (send self :rgb-for-color color y)
    (values (// r 1023.0)
	    (// g 1023.0)
	    (// b 1023.0)
	    segment-number)))
;;
;; Given a map mode, pixel, overlay and map number, figure the rgb and segment-number
;; that actuall y drive the video.  This routine is spart enough for
;; all the existing screen types; standard, lores, cad buffer.
;;
(defmethod (:visible-pixel common-control-mixin)
	   (ov-type main-bits ov-bits segment-number)
  (multiple-value-bind (r g b seg)
      (send self :visible-pixel-slots ov-type main-bits ov-bits segment-number)
    (let ((map (send self :alternate-color-map-for-mode ov-type)))
      (cond ((and (= r g) (= g b))
	   (multiple-value-bind (r g b)
	       (send self :read-color-map-image r seg map)
	     (values r g b seg)))
	  (t (multiple-value-bind (r)
		 (send self :read-color-map-image r seg map)
	       (multiple-value-bind (nil g)
		   (send self :read-color-map-image g seg map)
		 (multiple-value-bind (nil nil b)
		     (send self :read-color-map-image b seg map)
		   (values r g b seg)))))))))

(defmethod (:alternate-color-map-for-mode common-control-mixin) (ignore)
  (send self :color-map-image))

;;
;; Return the R,G,B and segment numbers used for the color
;;
(defmethod (:visible-pixel-slots common-control-mixin)
	   (ov-type main-bits ov-bits segment-number)	   

  (selectq ov-type
    ((:8-bit :12-BIT)
     (values main-bits main-bits main-bits segment-number))
    (:24-bit
     (values (ldb (byte 8 0) main-bits)
	     (ldb (byte 8 8) main-bits)
	     (ldb (byte 8 16.) main-bits)
	     segment-number))
    (t (let* ((ov-segment-number (cond ((memq ov-type
					      '(:24-bit-transparent-overlay
						:8-bit-transparent-overlay))
					ov-bits)
				       ((= ov-bits 0) segment-number)
				       (t (logior 1 segment-number))
				       )))
	 (selectq ov-type
	   (:8-BIT-TRANSPARENT-OVERLAY
	    (values main-bits main-bits main-bits ov-segment-number))
	   (:24-BIT-TRANSPARENT-OVERLAY
	    (values (ldb (byte 8 0) main-bits)
		    (ldb (byte 8 8) main-bits)
		    (ldb (byte 8 16.) main-bits)
		    ov-segment-number))
	   (:8-BIT-REPLACEMENT-OVERLAY
	    (if (= 0 ov-bits)
		(values main-bits main-bits main-bits ov-segment-number)
		(values ov-bits ov-bits ov-bits ov-segment-number)))
	   (:24-BIT-REPLACEMENT-OVERLAY
	    (if (= 0 ov-bits)
		(values (ldb (byte 8 0) main-bits)
			(ldb (byte 8 8) main-bits)
			(ldb (byte 8 16.) main-bits)
			ov-segment-number)
		(values ov-bits ov-bits ov-bits ov-segment-number)))
	   (t (ferror "~A is an unknown overlay type" ov-type))
	   ))))
  )

;;
;; make sure the contorol args are right, and synchronize if needed, before
;; continuing on to the device dependent part.
;;
(defwhopper-subst (:copy-control-image common-control-mixin)
	   (&optional image-to-copy-from image-to-copy-into)

  (fixup-control image-to-copy-from)
  (fixup-control image-to-copy-into)

  (if (or (eq image-to-copy-from control)
	  (eq image-to-copy-into control))
      (wait-for-vertical-sync
	(continue-whopper image-to-copy-from image-to-copy-into))
      (continue-whopper image-to-copy-from image-to-copy-into))
    image-to-copy-into)


(defmethod (:figure-usable-color-parameters common-control-mixin)
       (write-mask data alu &optional type array screen-array)
  (default-figure-usable-color-parameters write-mask data alu type array screen-array))


(defmethod (:clear-vertical-flag common-control-mixin :default) ()
  (send self :vertical-sync-p))

(defmethod (:get-vertical-sync-with-timeout common-control-mixin) ()
  (loop initially (send self ':clear-vertical-flag) ;; read to clear it
	repeat 2000
	thereis (send self ':vertical-sync-p)
	  ))

(defmethod (:pixel-aspect-ratio common-control-mixin) ()
  (or (catch-error ;in case of obsolete sync programs
	(pixel-aspect-ratio sync-program))
      1.0))

(defmethod (:visible-size common-control-mixin) (&optional without-line-index-pan-zoom)
  (ignore without-line-index-pan-zoom)
  (values (pixels-per-line sync-program)
	  (number-of-lines sync-program)))


(defmethod (:chroma-key-modes common-control-mixin) () nil)

(defmethod (:put-sync-on-video common-control-mixin) () :jumper)

(defwhopper (:expose common-control-mixin) (&rest args)
  "Don't actually expose the color screen if there is no color monitor.  This
function is a TOTAL KLUDGE."
  (if (send self ':appropriate-hardware-p)
      (lexpr-continue-whopper args)
      (send self :deactivate)
      (values nil "Can't expose because the necessary hardware isn't present")
  ))

(defmethod (:deactivate common-control-mixin :after) ()
  (send self :un-set-base-addresses))

(defun (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")set-who-line-buffer0 (scr buffer)
  (let ((who (tv:screen-who-line-screen scr)))
    (when who (send who :set-buffer buffer))))

(defmethod (:un-set-base-addresses common-control-mixin :after) ()
  (set-who-line-buffer self *dummy-array*)
  (when unused-screen-memory
    (setf (array-indirect-pointer unused-screen-memory) *dummy-array*)))

(defmethod (2:set-base-addresses0 common-control-mixin :after) (&rest ignore)
  (set-who-line-buffer self tv:buffer)
  (when unused-screen-memory
    (let ((len (array-length unused-screen-memory)))
      (send self :inferior-screen-array-adjusted
	    self unused-screen-memory len nil
	    (or tv:buffer (ferror "Buffer not set up yet"))
	    (- (send self :total-screen-array-elements)
	       len)
	    0))))

(defmethod (:hardware-slot-id common-control-mixin) ()
  control-address)

(defmethod (:expose common-control-mixin :before) (&rest ignore)
  (send self :hardware-set-base-addresses)
  (unless (and (send self :exposed-p)
	       ;; this is a kludge; if the screen has been reset by a warm boot
	       ;; we need to do setup hardware. Otherwise we really shouldn't
	       (without-interrupts
		 (loop repeat 5
		       thereis (send self :get-vertical-sync-with-timeout)
			 )))
    (let* ((board-no (send self :hardware-slot-id))
	   (current-screen (gethash board-no *sc-exposed-screens*)))
      (and current-screen (neq current-screen self) (send current-screen :exposed-p)
	   (send current-screen ':deactivate))
      (setf (gethash board-no *sc-exposed-screens*) self))
    (send self ':setup-hardware)
    )
  (when (send self  :exposed-p)
    ;; this helps 3670's, which don't lose sync but do lose control
    ;; when warm booted
    (send self :new-control)))


(defmethod (:new-control common-control-mixin) (&optional (new control-image))
  "Update the control register from a control image, default to the screen's control image"
  (fixup-control new)
  (page-in-array new)
  (wait-for-vertical-sync
    (copy-array-contents new control)))

(defmethod (:pixel-mode-array common-control-mixin) (array)
  (and (typep array 'color-raster-array)
       (color-pixel-mode-arrays array)))

(defmethod (:fill-mode-array common-control-mixin) (array)
  (and (typep array 'color-raster-array)
       (color-fill-mode-arrays array)))

(defmethod (:packed-pixel-mode-arrays common-control-mixin) (array)
  (and (typep array 'color-raster-array)
       (color-packed-mode-arrays array)))

(defmethod (:external-overlay-array common-control-mixin) (array)
  (and (typep array 'color-raster-array)
       (color-external-overlay-arrays array)))

(defmethod (get-special-array common-control-mixin)
	   (which &optional (base-array (send self :screen-array)))
   (selectq which
     ((nil :pixel) base-array)
     (:fill (send self :fill-mode-array base-array))
     (:external-overlay (send self :external-overlay-array base-array))
     ((0 1 2 3 :red :green :blue :overlay :alpha)
      (setq which (selectq which (:red 0) (:green 1) (:blue 2) (:alpha :overlay 3)
			   (t which)))
      (nth which (send self :packed-pixel-mode-arrays base-array)))
     (t (ferror "Can't recognise ~a as a special array designator" which)))
   )

(defmethod (:create-screen-array common-control-mixin)
	   (width height array &optional (type (tv:sheet-array-type self)))
  (let* ((not-for-screen? (and height (arrayp array) (= (array-#-dims array) 2)))
	 (sarray (make-array
		   (if height (list height width) width)
		   :named-structure-symbol
		      (if height 'color-raster-array '1d-color-raster-array)
		   :leader-length color-raster-array-leader-length
		   :type type
		   :displaced-to array
		   :displaced-index-offset (and not-for-screen? 0)
		   :displaced-conformally not-for-screen?)))
    sarray))

(defun redirect-color-raster (array type width height displaced-to x-offset y-offset)
  (when (and (fixp displaced-to) (or (= displaced-to 0)(= displaced-to -1)))
    (ferror "bad displaced-to"))
  (if displaced-to
      (progn 
	(unless array
	  (setq array (make-array
			(if height (list height width) width)
			:type type
			:named-structure-symbol
			(if height 'color-raster-array '1d-color-raster-array)
			:leader-length
			  color-raster-array-leader-length
1			  ;not tv:sheet-raster-leader-length, so properties slot is there too
0			:displaced-to displaced-to
			:displaced-conformally (and (arrayp displaced-to)
						    height
						    (= (array-#-dims displaced-to) 2)))))

	(when #+3600 (or (fixp displaced-to)
			 (locativep displaced-to))
	      #+imach (typep displaced-to :physical-address)
	      (setq displaced-to
		    (%pointer-plus displaced-to
				   (floor x-offset
					  (cdr (assoc type si:array-elements-per-q))))
		    x-offset 0))
	(if (and height y-offset)
	    (tv:redirect-tv-raster array type width height displaced-to x-offset y-offset)
	    (si:change-indirect-array array type width displaced-to x-offset)
	    ))

      (when array
	(setf (si:array-indirect-pointer array) *dummy-array*))
      (setq array nil))
  array)

(defmethod (redirect-color-raster-array common-control-mixin) 
	   (array type width height displaced-to x-offset y-offset
		  &optional sheet private-type number)
  (ignore private-type)
  (let ((ar (redirect-color-raster array type width height displaced-to x-offset y-offset)))
    (when ar
      (setf (tv:sheet-raster-sheet ar) sheet)
      (register-bitmap-internal self ar sheet private-type number))
    ar))

(defun adjust-type-for-bit-size (super inferior target)
  (let* ((sup-bpp (array-element-byte-size super))
	 (inf-bpp (array-element-byte-size inferior))
	 (target-bpp (array-element-byte-size target))
	 (net-bpp (// (* target-bpp inf-bpp) sup-bpp)))
    (tv:raster-array-type-for-bits net-bpp)))
    
(defmethod (redirect-related-color-raster-arrays common-control-mixin)
	   (sheet array width height
		  pixel pixel-type
		  packed packed-type
		  fill fill-type
		  overlay overlay-type
		  x-offset y-offset &optional (new-pointer (send self :screen-array)))
  (setf (tv:sheet-raster-sheet array) sheet)
  (labels ((redirect-list-of-rasters
	     (dests sources type private-type &optional (number 0))
	     (cond ((listp sources)
		    (when (null dests)
		      (setq dests (make-list (length sources))))
		    (loop for s in sources
			  as number from 0
			  as d on dests do
		      (setf (first d)
			    (redirect-list-of-rasters (first d) s type private-type number))))
		   ((listp dests)
		    (loop for d on dests
			  as number from 0
			  do
		      (setf (first d)
			    (redirect-list-of-rasters (first d) sources type private-type number)
			    )))
		   (t (cond (type)
			    ((arrayp sources)
			     (setq type (adjust-type-for-bit-size
					  (or new-pointer array)
					  array
					  sources)))
			    ((arrayp dests)
			     (setq type (adjust-type-for-bit-size
					  (or new-pointer array)
					  array
					  dests))))
		      (when (typep dests 'tv:sheet-raster)
			(setf (tv:sheet-raster-sheet dests) sheet))
		      (when (and type (or sources dests))
			(unless sources
			  (setq x-offset 0 y-offset 0 sources *dummy-array*))
			(setq dests
			      (redirect-color-raster-array self
				    dests type
				    width height
				    sources
				    x-offset y-offset
				    sheet
				    private-type
				    number
				    )
				  )
			)
		      ))
	     dests))

    (setf (color-pixel-mode-arrays array)
	  (redirect-list-of-rasters
	    (color-pixel-mode-arrays array)
	    pixel
	    pixel-type
	    :pixel))

    (setf (color-fill-mode-arrays array)
	  (redirect-list-of-rasters
	    (color-fill-mode-arrays array)
	    fill
	    fill-type
	    :fill))

    (setf (color-external-overlay-arrays array)
	  (redirect-list-of-rasters
	    (color-external-overlay-arrays array)
	    overlay
	    overlay-type
	    :overlay))

    (setf (color-packed-mode-arrays array)
	  (redirect-list-of-rasters
	    (color-packed-mode-arrays array)
	    packed
	    packed-type
	    :packed))
    ))

(defmethod (redirect-root-rasters common-control-mixin)
	   (sheet array width height x-offset y-offset)
  (redirect-related-color-raster-arrays self
    sheet array width height
    pixel-mode-base 'art-fixnum
    packed-mode-bases 'art-8b
    fill-mode-base 'art-1b
    nil nil
    x-offset y-offset))

(defmethod (2register-bitmap-internal0 common-control-mixin)
	   (new sheet &optional private-type number)
  (ignore private-type number sheet)
  (if (and (eq private-type :pixel)
	   (multiple-value-bind (origin bit-origin bpp w h span) (decode-array-parameters new)
	     (ignore bit-origin bpp w h span)
	     #+3600 (or (fixp origin)
			(and (locativep origin)
			     (eql (ldb sys:%%vma-equals-pma (%pointer origin))
				  sys:%vma-equals-pma)))
	     #+imach (typep origin :physical-address)))

      (setf (cl:getf  (color-raster-array-properties new) self)
	    new)

      (setf (cl:getf (color-raster-array-properties new) self)
	    nil)))

(defmethod (2tv:get-remote-bitmap0 common-control-mixin) (raster)
  (let ((sym (si:named-structure-p raster)))
    (when (or (eq sym 'color-raster-array)
	      (eq sym '1d-color-raster-array))
      (getf (color-raster-array-properties raster) self))))


(defun 2screen-height-with-who-line0 (self)
  (let ((height (tv:sheet-height self))
	(who (tv:screen-who-line-screen self)))
    (when who
      (incf height (tv:sheet-height who)))
    (values height who)
    ))

(defmethod (private-array-type common-control-mixin) (a)
  (ignore a)
  :pixel)

(defmethod (:inferior-screen-array-adjusted common-control-mixin)
	   (sheet array width height new-pointer x-offset y-offset)

  (when (typep array 'tv:sheet-raster)
    (setf (tv:sheet-raster-sheet array) self))

  (let ((xoff x-offset))

    (when #+3600 (or (fixp new-pointer)
		     (locativep new-pointer))
	  #+imach (typep new-pointer :physical-address)
	  (let ((size-multiplier (// 32. (si:array-element-byte-size array))))
	    (setq new-pointer
		  (%pointer-plus new-pointer
				 (floor xoff size-multiplier))
		  xoff 0
		  x-offset (* (%pointer-difference new-pointer tv:buffer)
			      size-multiplier)))

	  1;;when there is a who screen, use the full height
0	  (when height (setq height (max height (screen-height-with-who-line self))))
	  )
    ; this isn't quite correct, since it doesn't consider the byte size of
    ; the array.  It's also unnecessary except as a debugging aid.
    ;    (unless ( 0 x-offset (send self :total-screen-array-elements))
    ;      (ferror "invalid x offset of ~A" x-offset))
    
    (if height
	(tv:redirect-tv-raster array (array-type array)
			       width height new-pointer xoff y-offset)
	(si:change-indirect-array array (array-type array) width new-pointer xoff))
    (register-bitmap-internal self array sheet (private-array-type self new-pointer))
    )

  (cond ((or #+3600 (or (fixp new-pointer)
			(locativep new-pointer))
	     #+imach (typep new-pointer :physical-address))
	 (redirect-root-rasters self sheet array width height x-offset y-offset))
	((typep new-pointer 'color-raster-array)
	 (redirect-related-color-raster-arrays self
	   sheet array width height
	   (color-pixel-mode-arrays new-pointer) nil
	   (color-packed-mode-arrays new-pointer) nil
	   (color-fill-mode-arrays new-pointer) nil
	   (color-external-overlay-arrays new-pointer) nil
	   x-offset y-offset new-pointer ))
	(t (redirect-related-color-raster-arrays self
	     sheet array width height
	     nil nil nil nil nil nil nil nil x-offset y-offset)))
  array)

(defmethod (2:unused-screen-memory-size0 common-control-mixin) ()
  (max 0 (- (send self ':total-screen-array-elements)
	    (array-length (send self :screen-array)))))

(defmethod (2:unused-screen-memory0 common-control-mixin) (&optional special-array)
  (unless unused-screen-memory
    (let ((len (send self :unused-screen-memory-size)))
      (when (> len 0)
	(setq unused-screen-memory
	      (send self :create-screen-array len nil tv:buffer))
	(send self :inferior-screen-array-adjusted
	      self unused-screen-memory
	      len nil
	      tv:buffer (tv:array-length (send self :screen-array)) 0)
	)))
  (when unused-screen-memory
    (get-special-array self special-array unused-screen-memory)))


;;
;; Called from setup-hardware.  Do not call from elsewhere due to syncronization issues.
;;

(defmethod (:load-sync-program common-control-mixin) (to-address &optional ignore)
  (let* ((size (min 2048. ;; safety, old programs are erroneously longer
		    (array-length sync-program)))
	 (sync-memory (make-array (array-length sync-program)
				  :type 'art-q
				  :displaced-to to-address)))
    (loop for i from 0 below size do
      (setf (aref sync-memory i)
	    (si:integer-low-bits-as-fixnum (aref sync-program i)))
      )))

(defwhopper (:setup-hardware common-control-mixin) ()
  (send self :hardware-set-base-addresses)
  (continue-whopper))

(defmethod (:parse-font-descriptor common-color-hardware-mixin) (fd)
  (tv:screen-parse-font-descriptor fd nil)
  )

#|| rest in peace, expanded fonts
  (multiple-value-bind (bits prop-name)
     (color-font-info tv:bits-per-pixel)
    (setq fd (tv:screen-parse-font-descriptor fd prop-name))
    (or (get (font-name fd) prop-name)
	(setq fd (make-wide-font fd bits -1 prop-name))))
||#





;; For compatibility
(defvar color-screen nil)

(defun make-default-color-screen (&rest args)
  (cond ((color:color-exists-p)
	 (cl:apply #'make-color-screen :expose-p t args))
	(t (setq color-screen nil))))


(defvar sync-programs)

(defun find-sync-program (prog &optional recur &aux val)
  (when (symbolp prog) 
    (cond ((setq val (get 'sync-programs prog)))
	  ((and (boundp prog)
		(setq val (symeval prog))))
	  ((not recur)
	   (load (fs:make-pathname :host "SYS"
				   :directory '("COLOR" "SYNC")
				   :name (string prog))
		 nil nil t t
		 )
	   (setq val (find-sync-program prog t)))))

  (cond ((or recur (ARRAYP VAL) (LISTP VAL))
	 val)
	((arrayp prog) ;accept it if the sync program itself was used as a spec
	 prog)
	(t (ferror "Can't find sync program called ~A" prog)))
  )

(defun load-sync-programs ()
  (loop for i in (cdr (fs:directory-list "sys:color;sync;*.bin.newest" :fast))
	do (load (car i))))

#||
(COLOR:MAKE-COLOR-SCREEN &optional base-flavor &REST keywords)

COLOR:MAKE-COLOR-SCREEN is an extended TV:MAKE-WINDOW which understands some additional
keywords appropriate to setting up various kinds of color screens.  

See color:doc;make-color-screen.documentation

||#

(defun define-color-controller (type slot &optional memories &rest paddle)
  (cl:apply #'define-color-controller-internal type slot memories paddle))


(defun parse-color-keys (keys &aux tmp menu-item)
  (declare (special  name width height sync-program
		     bits-per-pixel number-of-planes controller base-flavor paddle-card
		     property-list interlace pixel-width
		     no-setq return-spec setup other-keys dont-set-screen expose-p
		     hardware-options memories-available no-hardware
		     genlock controller-types not-controller-types
		     paddle-card-types not-paddle-card-types
		     raster-width raster-height
		     top-margin-size left-margin-size right-margin-size bottom-martgin-size
		     ))
  (ignore menu-item)
  (keyword-extract keys thiskey
		   ( name width height 
		    bits-per-pixel
		    property-list number-of-planes
		    interlace base-flavor genlock
		    no-setq return-spec dont-set-screen expose-p
		    hardware-options memories-available 
		    menu-item
		    raster-width raster-height
		    top-margin-size left-margin-size right-margin-size bottom-martgin-size
		    )
		   nil
    (:controller
     (setq thiskey (cdr thiskey))
     (setq controller (car thiskey))
     (when (and (null setup)
		(null (get (locf keys) ':setup)))
       (parse-color-keys `(:setup ,controller)))
     )
    (:properties
      (setq thiskey (cdr thiskey))
      (loop for (id prop) on (car thiskey) by #'cddr
	    do
	(putprop (locf property-list) prop id)))
    (:controller-types
      (setq thiskey (cdr thiskey)
	    controller-types (car thiskey))
      (when (symbolp controller-types)
	(setq controller-types (symeval controller-types))))
    (:not-controller-types
      (setq thiskey (cdr thiskey)
	    not-controller-types (car thiskey))
      (when (symbolp not-controller-types)
	(setq not-controller-types (symeval not-controller-types))))
    (:paddle-card
     (setq thiskey (cdr thiskey)
	   paddle-card (car thiskey))
     (let ((gl (cond ((memq paddle-card *genlock-paddle-cards*)
		      paddle-card)
		     ((and (listp paddle-card)
			   (loop for pa in *genlock-paddle-cards*
				 when (memq pa paddle-card)
				   do (setq paddle-card (remove pa paddle-card))
				      (return pa))))
		     )))
       (when gl (setq genlock gl)))
     (when (listp paddle-card) (setq paddle-card (car paddle-card))))
    (:paddle-card-types
      (setq thiskey (cdr thiskey)
	    paddle-card-types (car thiskey))
      (when (symbolp paddle-card-types)
	(setq paddle-card-types (symeval paddle-card-types))))
    (:not-paddle-card-types
      (setq thiskey (cdr thiskey)
	    not-paddle-card-types (car thiskey))
      (when (symbolp not-paddle-card-types)
	(setq not-paddle-card-types (symeval not-paddle-card-types))))
    ((:dont-check-hardware :no-hardware)
     (setq thiskey (cdr thiskey))
     (setq no-hardware (car thiskey)))
    (:sync-program
      (setq thiskey (cdr thiskey))
      (setq sync-program (car thiskey))
      (when sync-program
	(let ((syncp (get-sync-program-for-paddle-card sync-program
						       paddle-card genlock controller)))
	  (cond ((arrayp syncp)
		 ;; try to complete resolution info from spec
		 (setq sync-program syncp)
		 (setq width (pixels-per-line sync-program))
		 (setq height (number-of-lines sync-program))
		 (setq interlace (interlace? sync-program))
		 )
		((listp syncp) (parse-color-keys syncp))
		))))
    (:sync-on-green
      (setq thiskey (cdr thiskey))
      (putprop (locf other-keys) (car thiskey) :put-sync-on-video)
      )
    (:video-calibration
      (setq thiskey (cdr thiskey))
      (putprop (locf property-list)
	       (get-video-calibration (car thiskey))
	       :video-calibration))
    (:setup
      (setq thiskey (cdr thiskey))
      (setq tmp (setq setup (car thiskey)))
      (when setup
	(loop do (setq tmp (get-color-setup tmp))
	      while (and tmp (symbolp tmp)))
	(if tmp 
	    (parse-color-keys tmp)
	    (ferror "Color setup ~A is not known (on property list of color:color-setups)"
		    setup))))
    (otherwise
      (let ((key (car thiskey)))
	(setq thiskey (cdr thiskey))
	(putprop (locf other-keys) (car thiskey) key)
	)))
  )

(defun get-sync-program-for-paddle-card
       (sync-program &optional paddle-card genlock controller (read-file t))

  (when sync-program
    (if (and (or paddle-card controller)
	     (symbolp sync-program))

	(let* ((cont (cl:getf color-parts (or paddle-card controller)))
	       (sync (or (when genlock 
			   (cl:getf cont (if (eq genlock t) :genlock genlock)))
			 (cl:getf cont :sync-programs)))
	       (sync-names (if (listp sync) sync (symeval sync)))
	       (sync-name-1 (cl:getf sync-names sync-program))
	       (sync-name-2 (if (listp sync-name-1)
				(or (get (locf sync-name-1) paddle-card)
				    sync-name-1)
				sync-name-1))
	       (sync-name (if (listp sync-name-2)
			      (or (get (locf sync-name-2) controller)
				  sync-name-2)
			      sync-name-2)))
	  (or (when sync-name (find-sync-program sync-name (not read-file )))
	      (if genlock
		(get-sync-program-for-paddle-card
		  sync-program paddle-card nil controller read-file)
		(find-sync-program sync-program (not read-file))
		)
	      ))

	(find-sync-program sync-program (not read-file ))))
  )

#||
(defun test-sync-get ()
  (loop for cont in '(:standard :second-standard :2k-line :second-2k-line) do 
    (loop for paddle in '(:chroma-hires-paddle :hires-paddle :broadcast-paddle) do
      (loop for genlock in '(nil :genlock :hdtv-genlock) do
	(loop for sync in '(:ntsc :pal :narrow-pal :hdtv) 
	      as res = (catch-error
			 (color:get-sync-program-for-paddle-card sync paddle genlock cont))
	      do (format t "~&~A ~A ~A ~A ~A~%" cont paddle genlock sync res))))
    ))
||#

(defun make-color-screen-error (message &rest args)
  (ferror (format NIL
		  "The hardware required to make this color screen wasn't found~%~A~%~%~A"
		  (lexpr-funcall 'format nil message args)
		  "Do (COLOR:COLOR-SYSTEM-DESCRIPTION) to see what is really there.
See the manual under DEFINE-COLOR-CONTROLLER if you really want to lie."
		  )))

#||
(defun old-create-color-screen (&key controller-types not-controller-types
			    paddle-card-types not-paddle-card-types
			    controller-predicate
			    (minimum-bits-per-pixel 2.)
			    (maximum-bits-per-pixel 32.)
			    (error-p t)
			    (frame-grabbers t))

  (selectq frame-grabbers
    (nil (push :frame-grabber not-controller-types))
    (:only (push :frame-grabber controller-types)))

  (loop with controllers =
	  (color-controllers :controller-types controller-types
			     :paddle-card-types paddle-card-types
			     :not-paddle-card-types not-paddle-card-types
			     :not-controller-types not-controller-types
			     :controller-predicate
			     #'(lambda (controller-spec)
				 (and (if controller-predicate
					  (funcall controller-predicate controller-spec)
					  t)
				      (destructuring-bind (controller nil mems paddle)
							  controller-spec
					(let* ((cont-dest (cl:getf color-parts controller))
					       (pixdepth (cl:getf cont-dest :pixel-depths))
					       (useful-bits
						 (cond ((memq :broadcast-paddle paddle)
							32.)
						       ((memq :frame-grabber-paddle paddle)
							24.)
						       ((memq controller
							      *standard-color-controllers*)
							(min maximum-bits-per-pixel
							     (* (or (length mems) 0) 8)))
						       ((loop for i in pixdepth
							      when
								( minimum-bits-per-pixel
								   i
								   maximum-bits-per-pixel)
								return i))
							(t 8))))
					       ( minimum-bits-per-pixel
						  useful-bits
						  maximum-bits-per-pixel))))))
	and choices				
	for spec in controllers
	as cont = (pop spec)
	as desc = (get (locf color-parts) cont)
	as find-paddle = (get (locf desc) :find-paddle-cards)
	as slot = (pop spec)
	as mem-slots = (pop spec)
	as paddle = (pop spec)
	as genlock = (loop for pa in paddle
			   as gp = (memq pa *genlock-paddle-cards*)
			   when gp return (first gp))
	as principle-paddle-card = (loop for i in paddle
					 unless (memq i *genlock-paddle-cards*)
					   return i)
	do
	  (when choices
	    (push '("" :no-select :no-select) choices))
	  (push `(,(format nil "~A~A ~A"
			   (if genlock "Genlocked " "")
			   (or (let ()
				 (get (locf desc) :description))
			       cont)		
			   (if (and (fixp slot)
				    (zerop (ldb (byte 16. 0) slot))
				    (not (zerop (ldb (byte 16. 16.) slot))))
			       (cl:format nil "at #X~4,48X" (ldb (byte 16. 16.) slot))
			       (cl:format nil "in slot ~D" slot)))
		  :no-select :no-select
		  :font fonts:bigfnt)
		choices)

	  (when (and find-paddle (null principle-paddle-card))
	    (push `("Paddle card is missing??" :no-select :no-select
			    :documentation "This controller requires a paddle card, which doesn't seem to be present") choices))
	  (let ((setups (setups-matching-constraints
			   :controller cont
			   :paddle principle-paddle-card)))
	    (labels ((push-setups (bpp)
		       (loop for i in setups
			     do (push `(,(if bpp
					     (format nil "~d bit ~A" bpp (first i))
					     (first i))
					,(second i)
					(,@(third i)
					 :controller ,cont 
					 :paddle-card ,principle-paddle-card
					 :backplane-slot ,slot
					 ,@(when bpp `(:bits-per-pixel ,bpp))
					 )
					 ,@(cdddr i))
				      choices))))
	      (push-setups (cond ((eq principle-paddle-card :broadcast-paddle)
				  32.)
				 (mem-slots (min maximum-bits-per-pixel
						 (* 8 (length mem-slots))))
				 (t nil)))
	      (when (and (listp mem-slots)
			 (cdr mem-slots)
			 (neq principle-paddle-card :broadcast-paddle)
			 ( minimum-bits-per-pixel 8 maximum-bits-per-pixel))
		(push-setups 8))))
	finally
	  (if (null choices)
	      (when error-p
		(if (eq error-p :notify)
		    (tv:mouse-y-or-n-p "no suitable hardware is available")
		    (ferror "No color hardware appears to be available")))
	      (setq choices (nreverse choices))
	      (let ((fn (tv:menu-choose choices "Choose the type of screen")))
		(when fn (return (lexpr-funcall 'make-color-screen fn)))))
  ))
||#


(defun controller-alist (&optional (controllers (color:color-controllers)))
  (loop for spec in controllers
	as (cont slot mem paddle) =  spec
	as desc = (cl:getf color-parts cont)
	as short-name = (or (cl:getf desc :short-description)
			    (cl:getf desc :description)
			    (string cont))
	as long-name = (or (cl:getf desc :description)
			   (cl:getf desc :short-description)
			   (string cont))
	as genlock = (loop for pa in paddle
			   as gp = (memq pa *genlock-paddle-cards*)
			   when gp return (first gp))
	as principle-paddle = (loop for pa in paddle
				    as gp = (memq pa *genlock-paddle-cards*)
				    unless gp return pa)
	as paddle-desc = (when principle-paddle (cl:getf color-parts principle-paddle))
	as paddle-short-name = (when paddle-desc
				 (or (cl:getf paddle-desc :short-description)
				     (cl:getf paddle-desc :description)
				     (string principle-paddle)))
	as paddle-string = (when (and paddle-short-name
				      (not (string-equal paddle-short-name "")))
			     (format nil " w//~A" paddle-short-name))
	as slot-name = (if (and (fixp slot)
				(zerop (ldb (byte 16. 0) slot))
				(not (zerop (ldb (byte 16. 16.) slot))))
			   (cl:format nil "at #X~4,48X" (ldb (byte 16. 16.) slot))
			   (cl:format nil "in slot ~D" slot))
	collect
	  `(,(format nil "~A~A~A ~A"
		     (if genlock "Genlocked " "")
		     short-name
		     (or paddle-string "")
		     slot-name)
	    :value ,spec
	    :documentation
	    ,(format nil "~A~A, with ~{~A~} paddle cards and ~A external memory boards"
				   long-name slot-name
				   (or paddle '("no"))
				   (or mem "no"))
	    ))
	  )

(defun sync-program-alist (sync-programs &optional sync-info)
  (loop for s in sync-programs
	as info0 = (or (getf sync-info s) (get 'sync-programs s))
	as info = (if (listp info0) info0 nil)
	as name = (or (cl:getf info :short-description)
		      (cl:getf info :description)
		      (string s))
	as long-name = (or (or (cl:getf info :description)
			       (cl:getf info :short-description)
			       (string s)))
	as width = (cl:getf info :width "unknown ")
	as height = (cl:getf info :height " unknown")
	as interlace = (cl:getf info :interlace :unknown)
	collect `(,name :value ,s
		  :documentation ,(format nil "~A, ~dx~d~A"
					  long-name width height
					  (cond ((eq interlace :unknown) "")
						((eq interlace t)
						 ", interlaced: Yes")
						(t ", interlace: No"))))))


(defun video-calibrations-alist (var)
  (loop for s in var
	as info = (get-video-calibration s)
	as name = (or (and (listp info)
			   (or (cl:getf info :short-description)
			       (cl:getf info :description)))
		      (string s))
	as long-name = (or (and (listp info)
				(or (cl:getf info :description)
				    (cl:getf info :short-description)))
			   (string s))
	collect `(,name :value ,s :documentation ,long-name)))



(defun get-default (type possibilities &optional controller setup)
  (cl:ecase type
    (:controller
      (or controller
	  (loop with best and bestv
		for i in possibilities
		as info = (cl:getf color:color-parts (first i))
		as priority = (cl:getf info :priority 0)
		when (or (null best)
			 (> priority bestv))
		  do
		    (setq bestv priority
			  best i)
		finally (return best))))
    (t (let* ((defaults (read-color-defaults :always-read nil))
	      (default-setups (cl:getf defaults :default-setups))
	      (setups (cl:getf defaults :setups))
	      (controller-defaults (cl:getf default-setups controller))
	      (default-setup-name  (or setup
				       (if (listp controller-defaults)
					   (first controller-defaults)
					   controller-defaults)))
	      (default-setup (cl:getf setups default-setup-name)))
	 (let ((val (cl:ecase type
		      (:bits-per-pixel
			(or (cl:getf default-setup :bits-per-pixel)
			    (cl:apply #'max (or possibilities '(8)))))
		      (:setup
			(let ((preferred-setups
				(when setup	;actually, sync program
				  (loop for s in setups
					as v = (get-color-setup s)
					when (eq (cl:getf v :sync-program) setup)
					  collect v))))
			  (or (when (member default-setup-name preferred-setups)
				default-setup-name)
			      (when (member controller preferred-setups)
				controller)
			      (first preferred-setups)
			      (when (member default-setup-name possibilities)
				default-setup-name)
			      (when (member controller possibilities) controller))))
		      ((:sync-program :sync-on-green :video-calibration :genlock
				      :width :height)
		       (cl:getf default-setup type))
		      )))
	   (or (when (member val possibilities) val)
	       (if (and (eq type :sync-program) (cdr possibilities))
		   nil ;no default for sync programs
		   (first possibilities))))))))

(defun create-color-screen (&key controller-types not-controller-types
			    paddle-card-types not-paddle-card-types
			    controller-predicate
			    (minimum-bits-per-pixel 2.)
			    (maximum-bits-per-pixel 32.)
			    (error-p t)
			    (own-window t)
			    (return-spec)
			    (default-setup)
			    (frame-grabbers t))

  (selectq frame-grabbers
    (nil (loop for (part desc) on color-parts by #'cddr
	       when (or (eq part :frame-grabber)
			(and (listp desc)
			     (cl:getf desc :controller)
			     (eq (cl:getf desc :frame-grabber) :only)))
		 do (cl:pushnew part not-controller-types)))
    (:only (loop for (part desc) on color-parts by #'cddr
	       when (or (eq part :frame-grabber)
			(and (listp desc)
			     (cl:getf desc :controller)
			     (cl:getf desc :frame-grabber)))
		 do (cl:pushnew part controller-types))))

  (let* ((tv:*ASYNCHRONOUS-WINDOW-OPERATION* nil)
	 (controllers
	  (color-controllers :controller-types controller-types
			     :paddle-card-types paddle-card-types
			     :not-paddle-card-types not-paddle-card-types
			     :not-controller-types not-controller-types
			     :controller-predicate
			     #'(lambda (controller-spec)
				 (and (if controller-predicate
					  (funcall controller-predicate controller-spec)
					  t)
				      (loop for useful-bits in
						(possible-pixel-depths controller-spec)
					    thereis
					  ( minimum-bits-per-pixel
					     useful-bits
					     maximum-bits-per-pixel))))))
	 (controller-alist (controller-alist controllers))
	 (controller (get-default :controller controllers ))
	 (controller-name)
	 controller-info

	 bits-per-pixel-list
	 bits-per-pixel-alist
	 bits-per-pixel

	 sync-programs
	 sync-program-alist
	 sync-program

	 video-calibrations
	 video-calibrations-alist
	 video-calibration


	 (principle-paddle-card )
	 (principle-paddle-info)
	 genlock
	 can-genlock

	 sync-on-green
	 can-sync-on-green

	 (other-setups)
	 (setup default-setup)

	 (width)
	 (height)
	 save-it
	 )

    (if (null controllers)
	(when error-p
	  (if (eq error-p :notify)
	      (tv:mouse-y-or-n-p "no suitable hardware is available")
	      (ferror "No color hardware appears to be available")))

	(labels ((adjust-other-parameters (&rest changed)
		   (when (eq (first changed) :controller)
		     (setq controller-name (first controller)
			   controller-info (cl:getf color-parts controller-name)
			   principle-paddle-card
			   (loop for i in (fourth controller)
				 unless (memq i *genlock-paddle-cards*)
				   return i)
			   principle-paddle-info (cl:getf color-parts principle-paddle-card)
			   can-genlock
			   (or (loop for i in (fourth controller)
				     when (memq i *genlock-paddle-cards*)
				       return t)
			       (cl:getf controller-info :can-genlock))
			   can-sync-on-green
			   (or (cl:getf controller-info :can-sync-on-green)
			       (cl:getf principle-paddle-info :can-sync-on-green))
			   ))

		   (unless (member :setup changed)
		     (setq other-setups (setups-matching-constraints
					  :menu-p nil
					  :controller controller-name
					  :sync-program
					   (unless (eq (first changed) :controller)
					     sync-program)
					  :paddle principle-paddle-card))
		     (unless (member setup other-setups)
		       (setq setup (get-default :setup other-setups controller-name
						(when (member :sync-program changed)
						  sync-program)))
		       (cl:apply #'adjust-other-parameters :setup changed)
		       ))

		   (when (or (member :setup changed)
			     (member :controller changed))
		     (setq genlock (get-default :genlock
						(if can-genlock '(t nil) '(nil))
						controller-name setup)
			   sync-on-green
			      (get-default :sync-on-green
					   (if can-sync-on-green '(t nil) '(nil))
					   controller-name setup)))

		   (unless (member :bits-per-pixel changed)
		     
		     (setq bits-per-pixel-list (possible-pixel-depths controller)
			   bits-per-pixel-alist
			    (loop for i in bits-per-pixel-list
				  collect (list (format nil "~D " i) :value i)))
		     (unless (member bits-per-pixel bits-per-pixel-list)
		       (let ((new-bpp (get-default :bits-per-pixel bits-per-pixel-list
						   controller-name setup)))
			 (unless (eql new-bpp bits-per-pixel)
			   (setq bits-per-pixel new-bpp)
			   (cl:apply #'adjust-other-parameters :bits-per-pixel changed)))))

		   (unless (member :sync-program changed)
1		     ;set up sync program stuff 
0		     (setq sync-programs (possible-sync-programs controller-name principle-paddle-card))
		     (setq sync-program-alist
			   (sync-program-alist sync-programs
					       (or (get principle-paddle-card :menu-sync-info)
						   (get controller-name :menu-sync-info))))
		     (unless (member sync-program sync-programs)
		       (setq sync-program (get-default :sync-program sync-programs
						       controller-name setup))
		       (cl:apply #'adjust-other-parameters :sync-program changed)))

		   (unless (member :video-calibration changed)
		     (setq video-calibrations (possible-video-calibrations controller-name)
			   video-calibrations-alist (video-calibrations-alist video-calibrations)
			   video-calibration (get-default :video-calibration video-calibrations
							  controller-name setup)))

		   (let ((sync-changed (member :sync-program changed)))
		     (when (or (member :controller changed)
			       (member :setup changed)
			       sync-changed)
		       (let* ((syncp (get-sync-program-for-paddle-card
				       sync-program
				       principle-paddle-card
				       genlock
				       controller-name
				       nil))
			      (setupv (get-color-setup setup))
			      (default-width (cl:getf setupv :width))
			      (default-height (cl:getf setupv :height)))
			 (cond ((listp syncp)
				(setq width (or default-width (cl:getf syncp :width))
				      height (or default-height (cl:getf syncp :height))))
			       ((arrayp syncp)
				(setq width (if sync-changed
						(pixels-per-line syncp)
						(or default-width (pixels-per-line syncp))))
				(setq height (if sync-changed
						 (number-of-lines syncp)
						 (or default-height (number-of-lines syncp))))))
			 )))
		 ))

	  (adjust-other-parameters :controller)

	  (loop doing
	    (dw:accepting-values (nil :Own-window own-window
				      :resynchronize-every-pass t
				      :label "Specify the type of color screen to create")

	      (let ((new-c (accept `(dw:alist-member
				      :alist ,controller-alist)
				   :prompt "Controller"
				   :default controller)))
		(when (neq new-c controller)
		  (setq controller new-c)
		  (adjust-other-parameters :controller)))


	      (let ((new-bpp (accept `(dw:alist-member :alist ,bits-per-pixel-alist)
				     :prompt "bits per pixel"
				     :query-identifier bits-per-pixel-alist
				     :default bits-per-pixel)))
		(unless (eql new-bpp bits-per-pixel)
		  (setq bits-per-pixel new-bpp)
		  (adjust-other-parameters :bits-per-pixel)))

	      (let ((new-s (accept `(dw:alist-member :alist ,sync-program-alist)
				   :prompt "Sync Program"
				   :query-identifier sync-program-alist
				   :default sync-program)))
		(when (neq new-s sync-program)
		  (setq sync-program new-s)
		  (adjust-other-parameters :sync-program)
		  ))

	      (when can-genlock
		(setq genlock (accept 'boolean
				      :default genlock
				      :prompt "Genlock")))

	      (when can-sync-on-green
		(setq sync-on-green (accept 'boolean
					    :default sync-on-green
					    :prompt "Sync On Green")))

	      (when video-calibrations
		(setq video-calibration
		      (accept `(dw:alist-member :alist ,video-calibrations-alist)
			      :default video-calibration
			      :prompt "Video Calibration")))

	      (setq width (accept '((cl:integer 1 4096.))
				  :default width
				  :prompt "width" )
		    height (accept '((cl:integer 1 4096.))
				   :default height
				   :prompt "height" ))
      
	      (let ((new-s (accept `(dw::alist-member :alist ,other-setups)
				   :default setup
				   :query-identifier other-setups
				   :prompt "Setup name")))
		(unless (eql new-s setup)
		  (setq setup new-s)
		  (adjust-other-parameters :setup)))

	      (setq save-it (accept 'string
				    :default ""
				    :prompt "Name to save this as default")
		    ))
	    until sync-program
	      do (unless (tv:confirmation-menu (3 0 (NIL 0) (NIL :BOLD :LARGE) "MEDFNTB")"You must specify a sync program"
0					       :yes-item '("retry specification" :value t
							   :documentation "Go back and retry specifying the screen to create")
					       :no-item '("abort" :value nil
							  :documentation "Forget it")
					       )
		   (signal 'sys:abort)
		   )))

    (when (not (string-equal save-it ""))
      (let ((name (intern save-it 'keyword))
	    (default-setups ))
	(save-modified-color-defaults
	  `(:controllers ,(loop for (cont slot mem paddle) in (color-controllers)
				collect `(,cont ,slot ,mem ,@paddle))
	    :setups (,name
		    (:controller ,controller-name
		     :paddle-card ,principle-paddle-card
		     :bits-per-pixel ,bits-per-pixel
		     :sync-program ,sync-program
		     :put-sync-on-video ,sync-on-green
		     :video-calibration ,video-calibration
		     :genlock ,genlock
		     :width ,width
		     :height ,height))
	    :default-setups (,controller-name
			     (,name ,@(cl:remove name default-setups)))))
      ))
    (make-color-screen
      :setup setup
      :controller controller-name
      :paddle-card principle-paddle-card
      :backplane-slot (second controller)
      :return-spec return-spec
      :expose-p t
      :bits-per-pixel bits-per-pixel
      :sync-program sync-program
      :put-sync-on-video sync-on-green
      :video-calibration video-calibration
      :genlock genlock
      :width width
      :height height)
	)))


(defun get-descriptor-list (desc keyword)
  (let ((spec (get (locf desc) keyword)))
    (when (and spec (nlistp spec))
      (setq spec (symeval spec)))
    spec))

(defun get-default-screen-flavor (controller paddle-card)
  (let ((base-info (or (get paddle-card ':default-screen-flavor)
		       (get controller ':default-screen-flavor))))
    (if (listp base-info)
	(cl:getf base-info controller)
	base-info)))


(defun setups-matching-constraints
       (&key
	controller
	paddle
	sync-program
	(menu-p t)
	bits-per-pixel)

  (let* ((defaults (color:read-color-defaults :always-read nil))
	 (default-setups (cl:getf defaults :setups)))

    (loop for (name desc) on (append default-setups (plist 'color-setups)) by #'cddr
	  as item = (when (listp desc) (if menu-p (cl:getf desc :menu-item) name))
	  when (and item
		    (not (member item names))
		    (if menu-p (cl:getf desc :menu-item) t)
		    (if bits-per-pixel
			(let ((bpp (cl:getf desc :bits-per-pixel)))
			  (cond ((null bpp) t)
				((fixp bpp) (eql bpp bits-per-pixel))
				((listp bpp) (member bits-per-pixel bpp))))
			t)
		    (if sync-program
			(let ((sp (cl:getf desc :sync-program)))
			  (if sp (eq sync-program sp) t))
			t)
		    (if controller
			(and (or (eq controller (getf desc :controller))
				 (memq controller
				       (get-descriptor-list desc :controller-types)))
			     (not (memq controller
					(get-descriptor-list desc :not-controller-types))))
			t)
		    (if paddle
			(let ((paddle-spec (get-descriptor-list desc :paddle-card-types))
			      (not-paddle-spec (get-descriptor-list desc :not-paddle-card-types)))
			  (and (or (null paddle-spec)
				   (memq paddle paddle-spec))
			       (or (null not-paddle-spec)
				   (not (memq paddle not-paddle-spec)))))
			t))
	    collect item into names
	      finally (return names))
    ))

(defun make-color-screen
       (&rest keys
	&aux  val
	&special other-keys number-of-planes
	name width height sync-program pixel-width
	bits-per-pixel controller property-list paddle-card
	no-setq return-spec interlace
	setup base-flavor dont-set-screen
	expose-p hardware-options memories-available
	no-hardware genlock 
	controller-types not-controller-types
	paddle-card-types not-paddle-card-types
	;; screens with inside edges
	raster-width raster-height
	(top-margin-size 0)(left-margin-size 0)(right-margin-size 0)(bottom-margin-size 0)
	(error-p t)
	)
  
  (parse-color-keys keys)
  
  (when (and controller
	     (not (memq controller controller-types)))
    (push controller controller-types))
  
  (when (and paddle-card
	     (not (memq paddle-card paddle-card-types)))
    (push paddle-card paddle-card-types))
  

  (when (and bits-per-pixel
	     (null number-of-planes))
    (setq number-of-planes (// bits-per-pixel 8)))
  
  (block make-screen
    (unless no-hardware
      
      (let* ((available-controllers
	       (color-controllers
		 :controller-types controller-types
		 :not-controller-types not-controller-types
		 :paddle-card-types paddle-card-types
		 :not-paddle-card-types not-paddle-card-types
		 :controller-predicate
		 #'(lambda (cont-spec)
		     (destructuring-bind (cont-type
					   cont-slot
					   cont-number-of-memories
					   cont-options)
					 cont-spec
		       (and (let ((backplane-slot (get (locf other-keys) :backplane-slot)))
			      (if backplane-slot
				  (eq cont-slot backplane-slot)
				  t))
			    (if number-of-planes
				(let* ((cont-desc (get (locf color-parts) cont-type))
				       (mem-req (get (locf cont-desc) :memory-required))
				       (pixel-depths (get (locf cont-desc) :pixel-depths)))
				  (if mem-req
				      ( number-of-planes
					 (if (memq :broadcast-paddle cont-options)
					     (* 4 (length cont-number-of-memories))
					     (length cont-number-of-memories)))
				      (or (member (* number-of-planes 8)
						  pixel-depths)
					  (when (= number-of-planes 3)
1					    ;avoid confustion over 24 verses 32 bit depth
0					    (member 32. pixel-depths))
					  )))
				t)
			    (if (loop for i in hardware-options
				      thereis (memq i *genlock-paddle-cards*))
				(loop for i in cont-options
				      when (memq i *genlock-paddle-cards*)
					return t)
				t)
			    )))
		 )))

	(selector (length available-controllers) =
	  (0 (if error-p
		 (make-color-screen-error "No suitable ~A controller found"
					  (or controller "color"))
		 (return-from make-screen nil)))
	  
	  (1 (let ((cont (first available-controllers)))
	       (destructuring-bind (hardware-controller
				   nil
				   hardware-number-of-memories
				   hardware-hardware-options)
		   cont

	       (unless (or bits-per-pixel number-of-planes)
		 (setq bits-per-pixel (first (possible-pixel-depths cont))
		       number-of-planes (// bits-per-pixel 8)))

	       (unless number-of-planes
		 (setq number-of-planes
		       (if hardware-number-of-memories
			   (length hardware-number-of-memories)
			   1)))
	       
	       (unless bits-per-pixel
		 (setq bits-per-pixel (* number-of-planes 8)))
	       
	       (loop for i in hardware-options
		     when (memq i *genlock-paddle-cards*)
		       do (setq genlock i))
	       
	       (setq hardware-options hardware-hardware-options)
	       
	       (setq controller hardware-controller
		     paddle-card (loop with pc
				       for i in hardware-options
				       do
				       (if (memq i *genlock-paddle-cards*)
					   (setq genlock i)
					   (setq pc i))
				       finally (return pc)))
	       
	       (let* ((cont-desc (get (locf color-parts) hardware-controller))
		      (find-paddle (get (locf cont-desc) :find-paddle-cards)))
		 
		 (if (and (null paddle-card) find-paddle)
		     (if error-p
			 (make-color-screen-error
			   "no paddle boards in ~A controller" controller)
			 (return-from make-screen nil))
		     (if (stringp paddle-card)
			 (if error-p
			     (make-color-screen-error
			       (format nil "~a in ~a controller" paddle-card controller))
			     (return-from make-screen nil))
			 )))
	       (setq other-keys nil)
	       (parse-color-keys `(:controller ,hardware-controller
				   :paddle-card ,paddle-card
				   ,@keys))
	       )))
	  (t (if error-p
		 (make-color-screen-error
		   "Several matching color controllers!~
              ~{~%  ~S~}~%..You will have to be more specific"
		   available-controllers)
		 (return-from make-screen nil)))
	  )
	
	(when bits-per-pixel
	  ;make sure bits per pixel is a power of 2
	  (setq bits-per-pixel (lsh 1 (haulong (1- bits-per-pixel)))))
	
	;; figure how many planes to use.
	(cond ((eq paddle-card ':broadcast-paddle)
	       (setq number-of-planes 1
		     bits-per-pixel 32.))
	      ((eq controller :frame-grabber)
	       (setq number-of-planes 1
		     bits-per-pixel 24.))
	      (number-of-planes
	       (setq bits-per-pixel
		     (selectq number-of-planes
		       (1 8.)
		       (t 32.))))
	      (bits-per-pixel
	       (unless number-of-planes
		 (setq number-of-planes (// bits-per-pixel 8.))))
	      )

	(when (member controller *standard-color-controllers*)
	  (when (> bits-per-pixel 8) (setq bits-per-pixel 32.)))

	(unless number-of-planes
	  (setq number-of-planes 1))
	(unless bits-per-pixel
	  (setq bits-per-pixel 8))
	
	;; name this sucker
	(cond ((null name)
	       (let ((cl:*print-radix* t))
		 (setq name (format nil "~D-bit ~A ~A color screen"
				    (cond ((eq paddle-card ':broadcast-paddle)
					   bits-per-pixel)
					  ((eq controller :frame-grabber)
					   24.)
					  (t (* 8 number-of-planes)))
				    (string-downcase setup)
				    (cond ((eq paddle-card ':broadcast-paddle) "direct")
					  ((>= number-of-planes 3) "direct")
					  (t "mapped"))
				    )))))
	
	
	(setq property-list
	      `(,@(copylist property-list)
		,@`(:interlace ,interlace)
		,@(and no-hardware `(:no-hardware ,no-hardware))
		:controller ,controller
		:paddle-card ,paddle-card
		:genlock ,genlock
		:setup ,setup
		:video ,(if (eq controller :frame-grabber) :frame-grabber :color)
		))
	
	(or base-flavor
	    (setq base-flavor
		  (or (get-default-screen-flavor controller paddle-card)
		      (if error-p
			  (ferror "I don't know what flavor to use for a ~S color controller"
				  controller
				  (if paddle-card
				      (format nil " with a ~S paddle card" paddle-card)
				      #+imach ""
				      #+3600 " (with no paddle card)"))
			  (return-from make-screen nil)))))
	    
	(when raster-width
	  (setq right-margin-size (max 0 (- raster-width width left-margin-size))
		width raster-width))

	(when raster-height
	  (setq bottom-margin-size (max 0 (- raster-height height top-margin-size))
		height raster-height))


	(setq val (lexpr-funcall
		    (cond (return-spec 'list)
			  (t 'tv:make-window))
		    base-flavor
		    :superior nil
		    :name name
		    :bits-per-pixel bits-per-pixel
		    :width width
		    :height height
		    :left-margin-size left-margin-size
		    :right-margin-size right-margin-size
		    :top-margin-size top-margin-size
		    :bottom-margin-size bottom-margin-size
		    :number-of-planes number-of-planes
		    :sync-program sync-program
		    :pixel-width pixel-width
		    :interlace interlace
		    :property-list property-list
		    other-keys))
	    
	(cond (return-spec val)
	      (t (when expose-p
		   (multiple-value-bind (success whynot)
		       (send val :expose)
		     (when (and (null success) whynot)
		       (if error-p
			   (make-color-screen-error whynot)
			   (return-from make-screen nil)))))
		 (cond ((or no-setq dont-set-screen) val)
		       (t (setq color-screen val))))
	      ))
      )))

(defun find-color-screen (&key
			  (which :choose)
			  (create-p NIL)
			  (frame-grabbers nil)
			  (error-p t)
			  default message create-options
			  (minimum-bits-per-pixel 2.)
			  (maximum-bits-per-pixel 32.)
			  )
  ;; first, check the mouse screen
  ;; then, other screens in turn
  (loop named find-color-screen-loop do
    (catch-error-restart (error "Try creating a color screen")
      (return-from find-color-screen-loop
	(let ((m tv:mouse-sheet)
	      (d tv:default-screen))
	  
	  (labels ((find-color-screen-internal
		      (screen)
		     (when (and screen
				(instancep screen)
				(send screen :send-if-handles :user-visible)
				(send screen :exposed-p)
				(let ((bpp (send screen :useful-bits-per-pixel)))
				  ( minimum-bits-per-pixel
				     bpp
				     maximum-bits-per-pixel))
				(let* ((cont (send screen :hardware-description))
				       (cont-info (cl:getf color-parts cont))
				       (cont-fg (cl:getf cont-info :frame-grabber)))
				  (selectq frame-grabbers
				    (nil (and (neq cont :frame-grabber)
					      (neq cont-fg :only)))
				    (:only (or (eq cont :frame-grabber)
					       cont-fg))
				    (t t))
				  ))
		       (cond ((functionp message) (funcall message screen))
			     ((listp message)
			      (lexpr-send screen :send-if-handles message))
			     (message (send screen :send-if-handles message))
			     ((memq (send screen :get :video) '(:frame-grabber :color)))))))
	    
	    (or (cond ((and default (find-color-screen-internal default)) default)
		      ((and (eq which :default) (find-color-screen-internal m)) m)
		      ((and (eq which :default) (find-color-screen-internal d)) d)
		      (t (loop for i in tv:all-the-screens
			       when (find-color-screen-internal i)
				 if which collect i into color-screens
			       else return i
			       finally
				 (return
				   (cond ((memq which '(:all t)) color-screens)
					 ((and (null color-screens) create-p)
					  (lexpr-funcall 'create-color-screen
							 `(,@create-options
							   :frame-grabbers
							   ,frame-grabbers
							   :minimum-bits-per-pixel
							   ,minimum-bits-per-pixel
							   :maximum-bits-per-pixel
							   ,maximum-bits-per-pixel
							   :error-p ,error-p
							   )
							 ))
					 ((memq which '(:choose :default))
					  (if (null (cdr color-screens))
					      (car color-screens)
					      (tv:menu-choose (loop for i in color-screens
								    collect (list (send i :name)
										  i))
							      "Which Screen?")))
					 ((fixp which)
					  (nth (1- which) color-screens))
					 (t (ferror "~A isn't an understood value for :WHICH" which)))
				   ))))
		(when (and error-p (not create-p))
		  (if (eq error-p :notify)
		      (tv:mouse-y-or-n-p  "No color screen found")
		      (ferror "No color screen found"))))
	    ))))
    (setq create-p t)
    ))



;;; More compatibility
;; Remove these three functions after genera 7.4
;;
(defun write-color-map (slot r g b)
  (send color-screen ':write-color-map slot r g b))

(defun read-color-map (slot)
  (send color-screen ':read-color-map slot))

(defmacro with-plane-mask ((window color-alu) &body body)
  (ignore window color-alu)
  `(progn ,@body))

(compiler:make-obsolete read-color-map "Use :READ-COLOR-MAP message to a particular screen")
(compiler:make-obsolete write-color-map  "Use :WRITE-COLOR-MAP message to a particular screen")
(compiler:make-obsolete with-plane-mask "Use color alus with a plane mask")

(defflavor color-slave-screen-mixin () (tv:slave-screen-mixin))

(tv:def-pass-to-parent
  color-slave-screen-mixin
  :read-screen-map
  :write-screen-map
  tv:screen-permit-fast-tracking-p
  :put-sync-on-video
  :hardware-control-locs
  :figure-usable-color-parameters
  :map-mode
  :color-map-description
  :overlay-description
  :pixel-positions
  :compute-color-alu
  :color-map
  :color-map-image
  :number-of-segments
  :make-color-map-image
  :pixel-mode-array
  :fill-mode-array
  :packed-pixel-mode-arrays
  :external-overlay-array
  :inferior-screen-array-adjusted
  get-special-array)

(DEFMETHOD (:CREATE-SCREEN-ARRAY COLOR-SLAVE-SCREEN-MIXIN)
	   (width height array &optional (type (tv:sheet-array-type self)))
  (send TV:PARENT-SCREEN :CREATE-SCREEN-ARRAY width height array type))

(defprop sync-programs (:width 640. :height 484.) :ntsc)
(defprop sync-programs (:width 1280. :height 1024.) :hires)
(defprop sync-programs (:width 864. :height 574.) :pal)
(defprop sync-programs (:width 640. :height 574.) :narrow-pal)
(defprop sync-programs (:width 1248. :height 1024.) :hdtv)
(defprop sync-programs (:width 512 :height 2048) :3d)
(defprop sync-programs (:width 2048 :height 1024) :3d-tek)
(defprop sync-programs (:width 2048 :height 1024) :3d-hires)

(defprop sync-programs (:width 720. :height 484.) :ntsc-601)
(defprop sync-programs (:width 720. :height 484.) :ntsc-601-10pt7)
(defprop sync-programs (:width 640. :height 484.) :ntsc-10pt8)
(defprop sync-programs (:width 720. :height 574.) :pal-601)
(defprop sync-programs (:width 720. :height 574.) :pal-601-12us)

(defflavor screen-stuff-mixin ((screen-raster-height)(tv:invisible-to-mouse-p))
	   (tv:gray-deexposed-inferiors-mixin
	    tv:gray-unused-areas-mixin
	    tv:scale-inferiors-mixin
	    tv:screen)
  (:conc-name nil)
  (:initable-instance-variables screen-raster-height tv:invisible-to-mouse-p)
  (:default-init-plist
   :who-screen nil				;obsolete
   :gray-array-for-unused-areas nil))

(defmethod (2:visible-height0 screen-stuff-mixin) ()
  (multiple-value-bind (ignore h) (send self :visible-size) h))

(defmethod (2:visible-width0 screen-stuff-mixin) ()
  (multiple-value-bind (w ignore) (send self :visible-size) w))

(defmethod (color-bitmap-on-real-screen-flavor screen-stuff-mixin) ()
  nil)

(defmethod (make-color-bitmap-on-real-screen screen-stuff-mixin) (&rest args)
  (let ((flav (color-bitmap-on-real-screen-flavor self)))
    (if flav
	(lexpr-funcall #'make-instance flav :parent-screen self :dest-screen self args)
	(ferror "this screen cannot make visible off-screen bitmaps"))))

(defmethod (tv:screen-raster-height screen-stuff-mixin) ()
  screen-raster-height)

(defmethod (:init screen-stuff-mixin :after) (ignore)
  (unless screen-raster-height
    (setq screen-raster-height tv:height)))

(defmethod (tv:2eval-with-bus-setup0 tv:basic-screen) (form)
  (eval form))

(defmethod (tv:2funcall-with-bus-setup0 tv:basic-screen) (form &rest args)
  (cl:apply form args))



(defflavor color-who-line-screen-mixin ()
	(tv:generic-who-line-screen-mixin
	 color-slave-screen-mixin
	 tv:gray-deexposed-inferiors-mixin tv:gray-unused-areas-mixin
	 tv:screen)
  (:default-init-plist
   :gray-array-for-unused-areas nil
   :who-screen nil				;obsolete
   :property-list '(:video :overlay
		    :who-line t))
  )

(defmethod (tv:screen-open-all-conflicting-blinkers color-who-line-screen-mixin)
	   (left top right bottom)
  left right top bottom
  (tv:screen-open-all-conflicting-blinkers tv:parent-screen 0 0 0 0))

(defflavor color-who-line-screen ()
      (slave-graphics-mixin
       color-who-line-screen-mixin))

(defmethod (tv:who-line-screen-flavor common-control-mixin) ()
  'color-who-line-screen)

(defun REPAIR-WINDOW-STATE ()
  
  (condition-case (err)
       (progn
	 (loop for screen in (copylist tv:all-the-screens)
	       unless (memq screen tv:*console-screens*)
		 do (tv:reset-who-line nil screen)
		    (send screen :expose))

  
	 (when (and tv:main-screen (send tv:main-screen :get :color-console-p))
	   (send tv:main-screen :expose)
	   (let ((parent (send tv:main-screen :send-if-handles :parent-screen)))
	     (when parent
	       (when si:*cold-load-stream-selected*
		 (send si:cold-load-stream :deselect))	;wait for the fep to do it
	       (send parent :new-control)
	       (send parent :new-color-map)))))
     (sys:error
       (tv:notify nil
		  (with-output-to-string (str)
		    (format str "Error in COLOR:REPAIR-WINDOW-STATE~%")
		    (send err :report str)))
       )))

#||
(defun test-repair-screen-state ()
  (send color:color-screen :deexpose)
  (let ((sys:*console* nil))
    (print (tv:sheet-console color:color-screen))
    (repair-window-state)))
||#

(add-initialization "Repair screen state" '(repair-window-state)
		    '(:window))






;;
;; This implements a flavor, LINE-INDEX-PAN-ZOOM, which is intended
;; to be used in conjunction with standard color screen's.  It permits
;; groups of adjacent lines to be panned and zoomed using the same protocols
;; as the global pan and zoom.
;;
;;
;;  Example:
;;
;; (setq pz (make-instance 'line-index-pan-zoom 
;;   :dest-screen color:color-screen
;;   :source-screen fake-screen
;;   :first-line nn
;;   :last-line kk))
;; (send pz :set-video-on t)
;; (send pz :set-pan-and-zoom --)
;;

;;
;; Line index pan and zoom
;;
(defflavor line-index-pan-zoom
	((first-line) 		;; first screen line affected
	 (last-line)   		;; last screen line affected
	 (active-lit)	  	;; line index table we work from
	 (active-pan-zoom) 	;; line pan/zoom we work from

	 (x-pan 0)		;; current pan and zoom values
	 (x-zoom 0)
	 (y-pan 0)
	 (y-zoom 0)

	 (dest-screen)		;; screen we are appearing on
	 (source-screen)	;; screen we are coming from
			;; ** note these must be the same hardware, but needn't
			;; ** be the same screen.  See COLOR-BITMAP-ON-REAL-SCREEN

	 (border-lines 2)   ;; two border lines is advisable, because of hardware
			    ;; trouble the lines where the pan/zoom are changing
			    ;; don't quite make it.

	 (border-address 0) ;; where in screen memory to get the border from
	 )
	(pan-zoom-methods-mixin)
  :settable-instance-variables
  :initable-instance-variables
  (:init-keywords :screen)
  )

(defmethod (:screen-for-size line-index-pan-zoom) () dest-screen)

(defmethod (:screen line-index-pan-zoom) ()
  ;; for :mouse-pan-zoom and friends
  source-screen)

(defmethod (:restore-dest-lines line-index-pan-zoom) (from to &optional (update t))
  (send dest-screen :restore-dest-lines from to update))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; INITIALIZATION
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(defmethod (:init line-index-pan-zoom :before) (plist)

  ;; the screen can be specified either separately as :source-screen and
  ;; :dest-screen, or just :screen for both.  If no screen is specified,
  ;; look for an existing color screen that can :line-pan-zoom
  (send self :set-dest-screen
	(or dest-screen
	    (get plist :screen)
	    source-screen
	    (setq dest-screen (find-color-screen :message :line-pan-zoom))))

  (setq source-screen (or source-screen
			  (get plist :screen)
			  dest-screen)
	first-line (or first-line 0)
	last-line  (or last-line (min (+ first-line
					 (min (send source-screen :height)
					      (send dest-screen :height)))
				      (send dest-screen :height)))
	
	))

(defmethod (:init line-index-pan-zoom :after) (ignore)
  (send self :set-screen dest-screen :initialize-line-index-table nil)
  )

(defmethod (:set-screen line-index-pan-zoom)
	   (new-screen &key
		       (user:first-line first-line)
		       (user:last-line last-line)
		       (initialize-line-index-table new-screen)
		       )
  (setq first-line user:first-line
	last-line user:last-line
	dest-screen new-screen
	)
  (when (eq dest-screen initialize-line-index-table)
    (setq y-pan first-line))

  (when initialize-line-index-table
    (send self :initialize-line-index-table)))

(defwhopper (:initialize-line-index-table line-index-pan-zoom) (&rest args)
  (unless active-lit
    (setq active-lit (send source-screen :make-line-index-table-image)))
  (unless active-pan-zoom
    (setq active-pan-zoom (send source-screen :make-line-pan-zoom-image)))
  (lexpr-continue-whopper args))

(defmethod (:initialize-line-index-table line-index-pan-zoom)
	   (&key (table active-lit)
		 (base-array (send source-screen :screen-array))
1		 ;note that since line-pan-zoom objects have no real bits
		 ;of their own, these should be :visible-width and :visible-height
		 ;even though most others use :inside-width and :height
0		 (width (send source-screen :visible-width))
		 (height (send source-screen :visible-height)))
  (send dest-screen :initialize-line-index-table
	:table (or table active-lit)
	:base-array base-array
	:height height
	:width width
	))


;;
;; :set-line-index-pan-zoom T-OR-NIL, activate or deactivate
;; this segment.  Likewise, :set-video-on
;;

(defmethod (:set-line-index-pan-zoom line-index-pan-zoom) (to)
  (send dest-screen :set-line-index-pan-zoom to self)
  )

(defmethod (:line-index-pan-zoom line-index-pan-zoom) ()
  (let ((lst (send dest-screen :line-index-pan-zoom)))
    (and (listp lst)
	 (memq self lst))))

(defmethod (:set-video-on line-index-pan-zoom) (to &optional ignore)
  (unless active-lit (send self :initialize-line-index-table))
  (send dest-screen :set-line-index-pan-zoom to self ))

(defmethod (:video-on line-index-pan-zoom) (&optional ignore)
  (when (send dest-screen :video-on)
    (let ((lst (send dest-screen :line-index-pan-zoom)))
      (and (listp lst)
	   (memq self lst)))))


;;
;; When changing size, keep the screen updated correctly
;;
(defwhopper (:set-first-line line-index-pan-zoom) (to &optional (update t))

  (let ((visible (send self :video-on))
	(dif-lines (- to first-line)))
    (continue-whopper to)
    (unless (or (not update) (not visible) (zerop dif-lines))
      (send dest-screen :update-line-index-pan-zoom))
    ))

(defwhopper (:set-last-line line-index-pan-zoom) (to &optional (update t))

  (let ((visible (send self :video-on))
	(dif-lines (- last-line to)))
    (continue-whopper to)
    (unless (or (not update) (not visible) (zerop dif-lines))
      (send dest-screen :update-line-index-pan-zoom))
    ))

(defwhopper (:set-border-lines line-index-pan-zoom) (new &optional (update t))
  (let ((visible (send self :video-on))
	(dif-lines (- new border-lines)))
    (continue-whopper new)
    (unless (or (not update) (not visible) (zerop dif-lines))
      (send dest-screen :update-line-index-pan-zoom))))

(defmethod (:new-control line-index-pan-zoom) (&optional ignore)
  (send dest-screen :update-line-index-pan-zoom))



;;
;; Information Out
;;
(defmethod (:pan-and-zoom line-index-pan-zoom) (&optional ignore)
  (values x-pan y-pan x-zoom y-zoom))

(defmethod (:pan-and-zoom-p line-index-pan-zoom) () t)

(defmethod (:pan line-index-pan-zoom) (&optional ignore)
  (values x-pan y-pan))
(defmethod (:zoom line-index-pan-zoom) (&optional ignore)
  (values x-zoom y-zoom))


;;
;; Changing pan and zoom
;;
(defmethod (:set-x-pan-zoom line-index-pan-zoom)
	   (new-x-pan new-x-zoom &optional (update t))
  (when (or ( new-x-pan x-pan)
	    ( new-x-zoom x-zoom)
	    (eq update :forced))
    (setq x-pan new-x-pan
	  x-zoom new-x-zoom)
    (when (send self :video-on)
      (send self :update-x-pan-zoom update)
      t)))

(defmethod (:update-x-pan-zoom line-index-pan-zoom) (update)
  (send dest-screen :update-x-pan-zoom self update))

(defmethod (:set-y-pan-zoom line-index-pan-zoom)
	   (new-y-pan new-y-zoom &optional (update t))
  (when (or ( new-y-pan y-pan)
	    ( new-y-zoom y-zoom)
	    (eq update :forced)
	    )
    (setq y-pan new-y-pan
	  y-zoom new-y-zoom)
    (when (send self :video-on)
      (send self :update-y-pan-zoom update))
    ))

(defmethod (:update-y-pan-zoom line-index-pan-zoom) (update)
  (send dest-screen :update-y-pan-zoom self update))

(defmethod (:set-pan line-index-pan-zoom) (new-x new-y &optional (update t))
  (let ((old-x x-pan)
	(old-y y-pan))
    (multiple-value-bind (screen-x screen-y) (send (send self :screen-for-size) :size)	
      (let ((x-up (send self :set-x-pan-zoom (mod new-x screen-x) x-zoom
			(when update :first))))
	(send self :set-y-pan-zoom (mod new-y screen-y) y-zoom
	      (when update (if x-up :forced t)))))
    (values old-x old-y)))

(defmethod (:set-zoom line-index-pan-zoom) (new-x new-y &optional (update t))
  (let ((old-x x-zoom)
	(old-y y-zoom))
    (let ((x-up (send self :set-x-pan-zoom x-pan (max 0 (min 255. new-x))
		      (when update :first))))
      (send self :set-y-pan-zoom y-pan (max 0 (min 255. new-y))
	    (when update (if x-up :forced t))))
    (values old-x old-y)))

(defmethod (:set-pan-and-zoom line-index-pan-zoom)	
	   (new-x-pan new-y-pan new-x-zoom new-y-zoom &optional (update t))
  (let* ((old-xp x-pan)
	 (old-yp y-pan)
	 (old-xz x-zoom)
	 (old-yz y-zoom)
	 (new-x (or ( new-x-pan old-xp) ( new-x-zoom old-xz)))
	 (new-y (or ( new-y-pan old-yp) ( new-y-zoom old-yz))))
    (multiple-value-bind (screen-x screen-y )
	(send (send self :screen-for-size) :size)
      (send self :set-x-pan-zoom (mod new-x-pan screen-x) (max 0 (min 255. new-x-zoom)) nil)
      (send self :set-y-pan-zoom (mod new-y-pan screen-y) (max 0 (min 255. new-y-zoom)) nil)
      )
    (when update
      (without-interrupts
	(when new-y (send dest-screen :new-line-index-table))
	(when new-x (send dest-screen :new-line-pan-zoom))
	))
  (values old-xp old-yp old-xz old-yz)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Methods to simply pass to the screen
;;

(defmethod (:wrap line-index-pan-zoom) (&optional cont)
  (send dest-screen :wrap cont))

(defmethod (:set-wrap line-index-pan-zoom) (x y &optional cont)
  (send dest-screen :set-wrap x y cont))

(defmethod (:size line-index-pan-zoom) ()
  (multiple-value-bind (xs ys)
      (send source-screen :size)
    (values xs (min (- last-line first-line) ys))))

(defmethod (:visible-size line-index-pan-zoom) (&optional without-line-index-pan-zoom)
  (ignore without-line-index-pan-zoom)
  (multiple-value-bind (xs ys)
      (send source-screen :visible-size t)
    (values xs (min (- last-line first-line) ys))))

(defmethod (:inside-size line-index-pan-zoom) ()
  (multiple-value-bind (xs ys)
      (send source-screen :inside-size)
    (values xs (min (- last-line first-line) ys))))


2;;
;; Support for making bitmaps out of the remains of the frame buffer;
;;
0(defflavor color-bitmap-on-real-screen-mixin
	((border-array)
	 (allocated-border-array)
	 (border-alu alu-0s)
	 (inhibit-refresh)
	 (invisible-p)
	 (tv:buffer)
	 (unused-screen-memory)
	 )
	(color-slave-screen-mixin
	 tv:color-bitmap-mixin
	 tv:bitmap-screen-mixin
	 line-index-pan-zoom
	 tv:screen
	 )
  (:settable-instance-variables
	border-array allocated-border-array border-alu
	inhibit-refresh invisible-p tv:buffer)
  :initable-instance-variables
  (:init-keywords
   :border-array-length 
   :border-array-pixel
   :set-mouse-sheet-when-selected
   :special-array	;SPECIAL-ARRAY no longer supported!
(4 0 (NIL 0) (NIL NIL :SMALLER) "EINY7")			; which of the dest screen's arrays to use. Can be
   			; NIL or :PIXEL (default)
    0  			4; 0 1 2 3 :RED :GREEN :BLUE :OVERLAY (packed arrays)
0			4; :EXTERNAL-OVERLAY (cad buffers only)
0			4; :FILL
0   :to-be-visible	;if T (default) enforce the 32 pixel wide restriction
   )
  (:default-init-plist :set-mouse-sheet-when-selected :from-parent
		       :border-array-length nil
		       :border-array-pixel 0
		       :to-be-visible t
		       :parent-screen nil
		       :special-array nil)
  )

(defmethod (:visible-height color-bitmap-on-real-screen-mixin ) () (send self :height))
(defmethod (:visible-width color-bitmap-on-real-screen-mixin) () (send self :width))

(defmethod (tv:screen-has-blinker-timer-p color-bitmap-on-real-screen-mixin) () t)

(defmethod (:screen-for-size color-bitmap-on-real-screen-mixin) () self)

(defwhopper (:activate color-bitmap-on-real-screen-mixin) ()
  (unless invisible-p (continue-whopper)))

(defwhopper (:refresh color-bitmap-on-real-screen-mixin) (&optional type)
  (unless (and inhibit-refresh (neq type :override))
    (continue-whopper type)))

(defmethod (:set-dest-screen color-bitmap-on-real-screen-mixin :after) (new)
  (setq tv:parent-screen new))

(defmethod (:init color-bitmap-on-real-screen-mixin :before) (plist)

  (setq source-screen self)

  (send self :set-dest-screen
	(or dest-screen
	    (get plist :screen)
	    (find-color-screen :message :line-pan-zoom)))

  (let ((preferred-flavor (color-bitmap-on-real-screen-flavor dest-screen )))
    (unless (typep self preferred-flavor)
      (flavor::change-instance-flavor self preferred-flavor)))

  (unless tv:bits-per-pixel
    (setq tv:bits-per-pixel (send dest-screen :bits-per-pixel)))

  (let ((m (send dest-screen :adjusted-width-for-screen tv:width tv:bits-per-pixel t)))
    (when m (setq tv:right-margin-size
		  (max tv:right-margin-size
		       (- m tv:width))
		  tv:width m)))

  (let ((sm (get plist :set-mouse-sheet-when-selected))
	(special-array (get plist :special-array))
	(to-be-visible (get plist :to-be-visible))
	(border-len  (send dest-screen :adjusted-width-for-screen 
			   (or (get plist :border-array-length) 32.)
			   tv:bits-per-pixel
			   t))
	(pix (get plist :border-array-pixel))
	(dummy-border)
	)
    
    (when (and special-array (neq special-array :pixel))
      (ferror "Special array is no longer supported.~&~
		Instead, pass in the special bitmap as :BUFFER"))
    
    (unless to-be-visible 
1      ; border lines are useless if not to be visible
0      (setq border-lines 0))

    (send self :putprop sm :set-mouse-sheet-then-selected)
    
    (unless tv:name
      (setq tv:name (format nil "on ~a" (send dest-screen :name))))
    
    (unless (or border-array (zerop border-lines))
      (setq allocated-border-array
	    (setq border-array
		  (or (tv:allocate-raster dest-screen
				      border-len 1
				      :type (tv:sheet-array-type self)
				      :make-remote nil
				      :make-local nil
				      :to-be-visible t
				      :error-p nil
				      :initial-value (or pix 0))
		      (progn
			(setq dummy-border t)
			(send self :create-screen-array 
			      border-len 1
			      *dummy-array*))
		      ))))

    (unless tv:buffer
      (unless tv:height
	(setq tv:height
1	      ;calculate the maximum height we can get
0	      (floor (- (floor (* (send dest-screen :unused-screen-memory-size)
				  (send dest-screen :bits-per-pixel))
			       tv:bits-per-pixel)
			(if border-array
			    (ceiling (* (array-length border-array)
					(si:array-element-byte-size border-array))
				     tv:bits-per-pixel)
			    0))
		     tv:width)))
      (setq tv:buffer
	    (or (tv:allocate-raster dest-screen tv:width tv:height
				    :make-remote nil
				    :make-local nil
				    :error-p nil
				    :for-sheet self
				    :type (tv:sheet-array-type self)
				    :to-be-visible to-be-visible)
		(send dest-screen :unused-screen-memory)
		(ferror "allocation of offscreen memory failed"))))

    (when dummy-border
      (send dest-screen :inferior-screen-array-adjusted
	    dest-screen border-array
	    border-len 1
	    tv:buffer 0 0)
      (si:fill-array border-array nil (or pix 0))
      (let* ((border-len (array-length border-array))
	     (len (- (array-length tv:buffer)
		     border-len))
	     (new (send dest-screen :create-screen-array len nil tv:buffer)))
	(send dest-screen :inferior-screen-array-adjusted
	      dest-screen new
	      len nil
	      tv:buffer border-len 0
	      )
	(setq tv:buffer new)))

    (unless tv:height
      (setq tv:height (floor (// (* (array-length tv:buffer)
				    (array-element-byte-size tv:buffer))
				 tv:bits-per-pixel)
			     tv:width)))
    ))

;;
;; these methods are needed to override a LINE-INDEX-PAN-ZOOM method
;;
(defmethod (:size color-bitmap-on-real-screen-mixin) ()
  (values tv:width tv:height))

(defmethod (:inside-size color-bitmap-on-real-screen-mixin) ()
  (values  (tv:sheet-inside-width) (tv:sheet-inside-height)))

(defmethod (:beep color-bitmap-on-real-screen-mixin) (&optional beep-type)
  beep-type
  (when (send self :video-on)
    (send dest-screen :beep)))


;;
;; Messages to pass through to the real screen
;;
(Defmethod (:visible-size color-bitmap-on-real-screen-mixin) (&optional without-line-index-pan-zoom)
  (values (send dest-screen :visible-size without-line-index-pan-zoom)
	  (- last-line first-line border-lines border-lines)))

(defwhopper (:pan-zoom-visible-edges color-bitmap-on-real-screen-mixin) (&optional ignore)
  (multiple-value-bind (x0 y0 xs ys) (continue-whopper)
    (values x0 y0
	    (+ x0 (min tv:width (- xs x0)))
	    (+ y0 (min tv:height (- ys y0))))))

;;
;; Messages which provide stuff for line index pan/zoom
;;
(defmethod (:make-line-index-table-image color-bitmap-on-real-screen-mixin)
	   (&optional displaced-to height)
  (send dest-screen :make-line-index-table-image displaced-to height))

(defmethod (:initialize-line-index-table color-bitmap-on-real-screen-mixin)
	   (&key (table active-lit) (base-array tv:buffer)
		 (height (send self :height))
		 (width (send self :visible-width)))

  (send dest-screen :initialize-line-index-table
	:table (or table active-lit)
	:base-array base-array
	:height height
	:width width
	))


(defmethod (:make-line-pan-zoom-image color-bitmap-on-real-screen-mixin) (&rest ignore)
  ;; this is a near copy of
  ;; (:method std-color-line-pan-zoom-mixin :make-line-pan-zoom-image)
  ;;
  (send dest-screen :make-line-pan-zoom-image nil tv:height))

;;
;; Compute the remaining unused screen array size
;;
(defmethod (:total-screen-array-elements color-bitmap-on-real-screen-mixin) ()
  1;;
0  1;; [ddyer 18 dec 91] Under some curcumstances I can't quite imagine, BUFFER may be
0  1;; a locative or a direct memory pointer.  But if buffer is an array,
0  1;; then it's probably the right thing to use.
0  1;; This change was made to make paint menu screen know how much it can allocate
0  1;; to unpaint arrays.
0  (array-length (cond ((arrayp tv:buffer) tv:buffer)
		      (t tv:screen-array)))
  )

(defmethod (2:unused-screen-memory-size0 color-bitmap-on-real-screen-mixin) ()
  (max 0 (- (send self ':total-screen-array-elements)
	    (array-length (send self :screen-array)))))

(defmethod (2:unused-screen-memory0 color-bitmap-on-real-screen-mixin) (&optional special-array)
  (unless unused-screen-memory
    (let ((len (send self :unused-screen-memory-size)))
      (when (> len 0)
	(setq unused-screen-memory
	      (send self :create-screen-array len nil tv:buffer))
	(send self :inferior-screen-array-adjusted
	      self unused-screen-memory
	      len nil
	      tv:buffer (tv:array-length (send self :screen-array)) 0)
	)))
  (when unused-screen-memory
    (get-special-array self special-array unused-screen-memory)))

(defmethod (2:border-address0 color-bitmap-on-real-screen-mixin) ()

  (if border-array
      (let ((baa (send dest-screen :buffer-address border-array))
	    (bae (send dest-screen :buffer-address
		       (// (array-length border-array) (// 32. tv:bits-per-pixel)))))
	(logior (lsh (+ baa bae -1) 16.)
		baa 
		))
      0
      ))

(defmethod (:screen-select color-bitmap-on-real-screen-mixin :after) (&optional (set-video-on t))
  (unless (or (null set-video-on)
	      (send self :get :dont-make-visible-when-selected))
    (unless (send self :video-on)
      (send self :set-video-on t))
    (when (and (instancep tv:mouse-sheet)
	       (eq dest-screen (tv:sheet-screen tv:mouse-sheet))
	       (eq :from-parent (send self :get :set-mouse-sheet-when-selected)))
      (tv:mouse-set-sheet self))))

(defmethod (:invisible-to-mouse-p color-bitmap-on-real-screen-mixin) ()
  (or tv:invisible-to-mouse-p
      (not (send self :video-on))))

(defmethod (:border-array color-bitmap-on-real-screen-mixin :after) ()
  (when allocated-border-array
    (tv:make-local dest-screen allocated-border-array :error-p nil)))

(defmethod (:accept-pop-up-notifications color-bitmap-on-real-screen-mixin) ()
  nil)

(defmethod (:deexpose color-bitmap-on-real-screen-mixin :before) (&rest ignore)
  (send self :set-video-on nil))

(defmethod (:deexpose color-bitmap-on-real-screen-mixin :after) (&rest ignore)
  (when border-array
    (tv:make-local dest-screen border-array :discard t :unlock-reason :freeze :error-p nil))
  (tv:make-local dest-screen tv:buffer :discard t :unlock-reason :freeze :error-p nil))

(defmethod (:expose color-bitmap-on-real-screen-mixin :before) (&rest ignore)
  (tv:make-remote dest-screen tv:buffer :lock-reason :freeze
		  :error-p nil)
  (when border-array
    (tv:make-remote dest-screen border-array :lock-reason :freeze :error-p nil))
  (send self :initialize-line-index-table)
  )

(defmethod (:kill color-bitmap-on-real-screen-mixin :after) ()
  (when allocated-border-array
    (tv:deallocate-raster dest-screen allocated-border-array :error-p nil))
  (tv:deallocate-raster dest-screen tv:buffer :error-p nil))

(defwhopper (:set-video-on color-bitmap-on-real-screen-mixin) (to &optional ignore)
  (cond (to
	 (unless (send self :exposed-p) (send self :expose))
	     (when (send self :exposed-p) (continue-whopper to)))
	(t (continue-whopper to)))) 

(defflavor color-bitmap-on-real-screen ()
      (tv:slave-allocator-mixin slave-graphics-mixin color-bitmap-on-real-screen-mixin))

(compile-flavor-methods line-index-pan-zoom color-bitmap-on-real-screen)


(defmethod (:expose color-who-line-screen :before) (&rest ignore)
  (multiple-value-bind (w h span)
      (decode-raster-array (send tv:parent-screen :screen-array))
    (ignore w h)
    (incf tv:right-margin-size (- span tv:width))
    (setq tv:width span)))
	
(compile-flavor-methods color-who-line-screen)

;utility for defining sync programs
(defmacro def-sync-program (hardware-type name &rest keywords)
  (let* ((constructor (get hardware-type :sync-program-constructor))
	 (hardware-info (getf color-parts hardware-type))
	 (var (getf hardware-info :sync-programs))
	 (constructor-keys)
	 (width (or (getf keywords 'published-pixels-per-line)
		    (getf keywords 'pixels-per-line)))
	 (height (getf keywords 'number-of-lines))
	 (menu-keys `(:width ,width :height ,height))
	 (prop-name (intern (string-append hardware-type "-" name) 'tv)))

    (loop for (k v) on keywords by #'cddr
	  do (cond ((keywordp k) (setf (getf menu-keys k) v))
		   (t (setf (getf constructor-keys k) v)))
	     )

    `(progn
       (setf (getf ,var ',name) ',prop-name)
       (setf (getf (get ,hardware-type :menu-sync-info) ',name)
	     ',menu-keys)
       (setf (get 'sync-programs ',prop-name)
	     (,constructor
	      ,@(unless (getf keywords 'hardware-type)
		  `(hardware-type ,hardware-type))
	      ,@(unless (getf keywords 'name)
		  `(name ,name))
	      ,@constructor-keys)))))
