;;; -*- Base: 10; Lowercase: Yes; Mode: Lisp; Package: Gt; Fonts: CPTFONT,CPTFONTB,CPTFONTI; -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

(defvar *window* nil)



(deff d #'describe)
(defun D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")sm0 () (send current-item :select-method))
(defun dm () (send current-item :drawing-method))
(defun1 ghf0 (message &optional (object current-item)) (get-handler-for object message))


; All items draw themselves when receiving a :draw
; All items undraw themselves when receiving a :undraw
; When you click on an item, it is sent :select with the mouse button and mouse device as args.
; An item can do anything it likes on :select
; Some items respond to :compute-size.  Will compute from string, font, what their size is.


(defconst xor-data (+ 128.))
(defconst1 new-xor0 (color:scf (+ xor-data (ash xor-data 8.) (ash xor-data 16.)) -1))
(send1 new-xor0 :set-alu tv:alu-xor)
(defconst1 24bit-xor0 (color:scf (+ 255 (ash 255 8.) (ash 254 16.)) -1))
(send1 24bit-xor0 :set-alu tv:alu-xor)

(defvar1 *dark-blue*0 (color:make-standard-color :rgb '(0 0 .5)))
(defvar1 *dark-red*0 (color:make-standard-color :rgb '(.5 0 0)))
(defvar1 *pale-green*0 (color:make-standard-color :rgb '(.6 .8 .7)))

(defvar1 *menu-item-pink*0 (color:make-standard-color :rgb '(.44 .38 .39))) ;'(.88 .75 .78)))  ;87 .52 .59)))
(defvar 1*name-menu-item-color*0 (color:make-standard-color :rgb '(.71 .88 .86)))	;'(.8 1.0 .8)))
(defvar 1*file-name-color*0 (color:make-standard-color :rgb '(.55 .68 .66)))      ;'(.6 .8 .6)))
;(defvar 1*file-name-color*0 (color:make-standard-color :rgb '(.72 .91 .78)))
(defvar1 *black0* (color:make-color :red 0 :green 0 :blue 0))
(defvar 1*red*0 (color:make-standard-color :rgb '(1 0 0)))
(defvar1 *white*0 (color:make-color :red 1 :green 1 :blue 1))
(defvar1 *80%-gray*0 (color:make-color :red .8 :green .8 :blue .8))
(defvar1 *70%-gray*0 (color:make-color :red .7 :green .7 :blue .7))
(defvar1 *menu-80%-gray*0 (color:make-color :red .8 :green .8 :blue .8))
(defvar1 *cyan*0  (color:make-color :red 0 :green 1.0 :blue 1.0))
(defvar1 *menu0-1cyan*0  (color:make-color :red 0 :green 1.0 :blue 1.0))
(defvar1 *40%-gray*0 (color:make-color :red .4 :green .4 :blue .4))
(defvar1 *30%-gray*0 (color:make-color :red .3 :green .3 :blue .3))
(defvar1 *menu0-140%-gray*0 (color:make-color :red .4 :green .4 :blue .4))
(defvar1 *magenta*0 (color:make-color :red 1.0 :green 0.0 :blue 1.0))
(defvar1 *menu0-1magenta*0 (color:make-color :red 1.0 :green 0.0 :blue 1.0))
(defvar 1*illegal-color-warning*0 :ntsc)
(defvar 1*grid-plane-mask*0 (lognot (ash #b00000001 16.)))	(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");grid lives in low order bit of blue channel.
0(defvar *1default-erase-color0* (copy-spec *black*))   

(defconst 1selected-color0 (color:make-standard-color :rgb '(.7 .7 0)))
(defconst 1command-color0 (color:make-standard-color :rgb '(.0 .4 .0)))	;.5
(defconst 1execute-color0 (color:make-standard-color :rgb '(1.0 .88 .0)))
(defconst1 lib-name-color0 (color:make-standard-color :rgb '(.8 .8 .8)))
(defconst1 toggle-on-color0 (color:make-standard-color :rgb '(0 .7 1.0)))
(defconst1 toggle-off-color0 (color:make-standard-color :rgb '(.65 .65 .65)))

(defmacro 1with-group-realigned0 (item &body body)
  `(let ((realigned-group (send ,item :realign-group))
	 (realigned-self (send ,item :self-to-realign)))

     (tv:prepare-sheet (menu-window)
       (when (send ,item :realign-on-select?)
	 (send realigned-group :recursively-undraw-from realigned-self)))
     ,@body
     (tv:prepare-sheet (menu-window)
       (when (send ,item :realign-on-select?)
	 (send realigned-self :draw-item)
	 (send realigned-group :realign)
	 (send realigned-group :recursively-draw-from realigned-self) 
	 ))))

(defmacro1 declare-brothers10 (parent list &optional (cget :children) (cset :set-children))
  `(progn
     (when ,parent
       (if (send ,parent ,cget)
	   (send ,parent ,cset (append (send ,parent ,cget) ,list))
	   (send ,parent ,cset ,list)))
     (loop for bro in ,list
	   do
       (send bro :set-brothers (append (send bro :brothers) ,list)))))

(defmacro 1with-item-xored-in-style0 (item style &body body)
  `(unwind-protect
       (progn (cond ((eq ,style :wait)
		     (xored-item-start ,item))
		    ((eq ,style :xor)
		     (send self :xor))
		    (t
		     (send self ,style))
		    )
	      ,@body)
     (xored-item-end ,item)))

(defmacro 1with-item-xored0 (item &body body)
  `(unwind-protect
       (progn (xored-item-start ,item)
	      ,@body)
     (xored-item-end ,item)))

(defmacro 1with-item-maybe-xored0 (item xor? &body body)
  `(unwind-protect
       (progn (if ,xor? (xored-item-start ,item))
	      ,@body)
     (if ,xor? (xored-item-end ,item))))

(defmacro 1with-item-xored-saying0 (item string &body body)
  `(unwind-protect
       (progn (xored-item-start ,item ,string)
	      ,@body)
     (xored-item-end ,item)))

(defconst 1*keypad-width*0 135.)
(defconst 1*keypad-height*0 120.)

(defconst 1string-y-off0 0)
(defconst 1string-x-off0 1)

(defvar1 *permit-draw-item*0 t)

(defvar1 *font-menu*0 nil)

(defvar 1*known-non-text-tv-fonts*0 '(2;; These are in the distribution world.
0				    fonts:edsymbol12
				    fonts:hippo10 fonts:hippo12
				    fonts:math10 fonts:math12
				    fonts:mouse
				    fonts:symbol10 fonts:symbol12
2				    ;; This is loaded by Concordia
0				    fonts:concordia-glyphs
2				    ;; This may not be distributed, but just in case...
0				    fonts:quantum
2				    ;; These are loaded by Paint, Dynamics, and Geometry respectively
0				    fonts:paint fonts:dyna-symbol fonts:3dfont
2				    ;; These are loaded by Hacks
0				    fonts:worm fonts:abacus fonts:tog fonts:tally))

(defun 1loaded-tv-font0 (font-symbol)
  (and (boundp font-symbol)
       (typep (symeval font-symbol) 'font)
       (symeval font-symbol)))

(defun 1loaded-tv-fonts-item-list0 ()
  (labels ((smaller-font-raster-heights (a b)
	     (< (font-raster-height a) (font-raster-height b)))
	   (font-name-string-lessp (a b)
	     (string-lessp (font-name a) (font-name b))))
    (loop for font-symbol being the interned-symbols in "FONTS"
	  for font = (loaded-tv-font font-symbol)
	  if (and font (not (memq font-symbol *known-non-text-tv-fonts*)))
	    collect `(,(format nil "  ~A  " font-symbol) :value ,font :font ,font)
	      into text-tv-fonts 
	  else
	    when font
	      collect `(,(format nil "  ~A  " font-symbol) :value ,font)
		into non-text-tv-fonts
	  finally (let ((sorted-text-tv-fonts
			  (cl:sort text-tv-fonts #'smaller-font-raster-heights :key #'third))
			(sorted-non-text-tv-fonts
			  (cl:sort non-text-tv-fonts #'font-name-string-lessp :key #'third)))
		    (return
		      (nconc
			sorted-text-tv-fonts
			`(("Non-textual Fonts"
			   :eval (more-menu-choose ',sorted-non-text-tv-fonts
						   "Non-textual Fonts")
			   :font fonts:bigfnt))))))))

(defun1 remove-nils0 (list)
  (loop for i in list
	append (if (null i) nil (list i))))

(defvar1 foo0)

;;-------------------------------------------------------------------------------------

(defflavor 1exposure-test0 ((variable) (test-value)) ()
  (:settable-instance-variables))

(defun 1make-variable-test0 (variable test-value)
  (make-instance 'exposure-test :variable variable :test-value test-value))

(defmethod 1(:test-exposure exposure-test)0 (field)
  field
  (eq (send variable :get-value) test-value))

;;-------------------------------------------------------------------------------------

(defflavor 1member-test0 ((variable) (test-value)) ()
  (:settable-instance-variables))

(defun 1make-member-test0 (variable test-value)
  (make-instance 'member-test :variable variable :test-value test-value))

(defmethod 1(:test-exposure member-test)0 (field)
  field
  (member (send variable :get-value) test-value))

(compile-flavor-methods exposure-test member-test )


;;-------------------------------------------------------------------------------------

(defflavor 1shadow-parameters0 ((shadow-color *white*) (shadow-xoff 3) (shadow-yoff 3)) ()
  (:settable-instance-variables))

(defvar 1*default-b&w-shadow*0 (make-instance 'shadow-parameters))


(defflavor 1border-parameters0 ((border-color *white*) (border-width 1) (use-border? t)
			      (border2-color *white*) (border2-width 1) (use-border2? nil))
	   ()
  (:settable-instance-variables))

(defmethod 1(:width border-parameters)0 ()
  (+ (if use-border? border-width 0) (if use-border2? border2-width 0)))

(defun 1make-border0 (&key (border-color *white*) (border-width 1) (use-border? t)
		    (border2-color *white*) (border2-width 1) (use-border2? nil))
  (make-instance 'border-parameters :border-color border-color :border-width border-width
		 :use-border? use-border? :border2-color border2-color :border2-width border2-width
		 :use-border2? use-border2?))

(defvar 1*default-border*0 (make-border))
(defvar 1*default-thick-border*0 (make-border :border-width 2))


;;----------------------------------------------------------------------------------------
(defflavor 1menu-item-mixin0 () ())
(defmethod 1(:re-init menu-item-mixin)0 ())

(defmacro1 define-menu-item0 (mixin-name var-list component-flavors &rest defflavor-options)
  (let* ((re-init-form
	   (loop for var in var-list
		 collect `(setq ,(first var) ,(second var)) into ans
		 finally (return (cons 'progn ans)))))
    `(progn
       'compile
       (defflavor ,mixin-name
	       ,(loop for var in var-list
		      collect (list (first var) (second var)))
	       ,component-flavors
	 ,@defflavor-options)
       (defmethod (:re-init ,mixin-name :after) ()
	 ,re-init-form))))

(defflavor1 base-menu-item
0	((id) (alu (color:scf -1 -1)) (exposed-p) (width :compute) (height :compute)
	 (item-top 0) (item-left 0) (erase-color) (children nil)
	 (possible-children) (brothers)
	 (font cptfontcc) (documentation) (menu-window) (group) (realign-on-select?) (parent)

	 (label) (label-left :compute) (label-top :compute) (Label-width :compute)
	 (label-height :compute) (label-font cptfontcc) (label-position :left) (label-color)

	 (database) (value)
	 (background-color *40%-gray*) (boxed-string-color *white*) (boxed-string "")

	 (borders) (random-information)

	 (highlight-method :standard-highlight) (mouse-sensitive t) (icon-type)
	 (select-method) (select-parameter) (drawing-method :command-draw) (deexpose-draw)
	 (dependents) (during-select-method) (alignment-x-off 0) (alignment-y-off 0)
	 (expose-test) (extra-draw-method) (shadow-parameters) (cons-cell))
	(si:property-list-mixin)
  (:init-keywords :plist-defaults :item-bottom :item-right :setup :left :top)
  :settable-instance-variables)


(defwhopper 1(:erase-color base-menu-item)0 ()
  (cond (erase-color erase-color)
	(group (send group :background-color))
	(t (send menu-window :erase-color))))

(defmethod 1(:x-scroll base-menu-item)0 () 0)
(defmethod 1(:y-scroll base-menu-item)0 () 0)

(defmethod 1(:expose-dependents base-menu-item)0 ()
  (loop for i in dependents
	do
    (send i :expose-item)))

(defmethod 1(:refresh-window base-menu-item)0 (&rest ignore)
  (send menu-window :refresh))

(defmethod 1(:compute-size-if-needed base-menu-item)0 ()
  (if (eq label-width :compute) (send self :compute-label-width))
  (if (eq label-height :compute) (send self :compute-label-height))
  (if (eq width :compute) (send self :compute-width))
  (if (eq height :compute) (send self :compute-height)))

(defmethod 1(:compute-label-width base-menu-item)0 ()
  (when label
     (scl:with-character-style (label-font menu-window)
      (setq label-width (+ 10 (send menu-window :compute-motion label))))))

(defmethod 1(:compute-label-height base-menu-item)0 ()
  (when label
    (let* ((real-font (si:get-font si:*b&w-screen* nil label-font))
	  (font-height (font-raster-height real-font)))
      (setq label-height (max height (+ font-height 4))))))

(defmethod 1(:compute-width base-menu-item)0 ()
  (scl:with-character-style (font menu-window)
    (setq width (+ 5 (send menu-window :compute-motion boxed-string)))))

(defmethod 1(:compute-label-left base-menu-item)0 ()
  (when label
    (cond ((eq label-position :left)
	   (setq label-left (- item-left label-width 10)))
	  ((eq label-position :right)
	   (setq label-left (+ item-left width 10)))
	  ((memq label-position '(:bottom :top))
	   (setq label-left item-left)))))

(defmethod 1(:compute-label-top base-menu-item)0 ()
  (when label
    (cond ((memq label-position '(:right :left))
	   (setq label-top item-top))
	  ((eq label-position :top)
	   (setq label-top (- item-top 10)))
	  ((eq label-position :bottom)
	   (setq label-top (+ item-top height 10))))))

(defmethod 1(:compute-height base-menu-item)0 ()
  (let* ((real-font (si:get-font si:*b&w-screen* nil font))
	 (font-height (font-raster-height real-font)))
    (setq height (+ font-height 4))))

(defmethod 1(:superior base-menu-item)0 () 
  (if (and group (typep group 'group-menu-item))
      group
      menu-window))

(defmethod 1(:realign-group base-menu-item)0  ()
  (when realign-on-select? (if (eq (send self :realign-on-select?) t)
			       (send self :group)
			       self)))
(defmethod 1(:self-to-realign base-menu-item)0  ()
  self)

;(defmethod 1(:realign-group 0multiple-select-menu-item1)0  ()
;  (when realign-on-select? (if (eq (send self :realign-on-select?) t)
;			       (send (send self :group) :group)
;			       (send self :group))))
;(defmethod 1(:self-to-realign 0multiple-select-menu-item1)0  ()
;  (when realign-on-select? (if (eq (send self :realign-on-select?) t)
;			       (send (send self :group) :group)
;			       (send self :group))))

(defmethod 1(:inside-group? base-menu-item)0 ()
  (multiple-value-bind (x1 y1 x2 y2)
      (send self :absolute-edges)
    (multiple-value-bind (gx1 gy1 gx2 gy2)
	(send group :absolute-edges)
      (and (<= gx1 x1 gx2) (<= gx1 x2 gx2) (<= gy1 y1 gy2) (<= gy1 y2 gy2)))))

(defmethod 1(:clip-sub-items? base-menu-item)0 () nil)

(defmethod1 (:init base-menu-item :after)0 (plist)
  (let ((setup (get plist :setup)))
    (when setup
      (send self setup plist)))
  (setq cons-cell (cons self nil))

2  ;; compute widths and heights if needed
0  (when (eq label-height :compute) (send self :compute-label-height))
  (when (eq label-width :compute) (send self :compute-label-width))
  (when (eq height :compute) (send self :compute-height))
  (when (eq width :compute) (send self :compute-width))
  (when (eq label-left :compute) (send self :compute-label-left))
  (when (eq label-top :compute) (send self :compute-label-top))

  (when (and (get plist :left) (get plist :top))
    (send self :set-position (get plist :left) (get plist :top)))

  (when (eq (send menu-window :superior) tv:main-screen)
    (when borders
      (send borders :set-border-color *white*))
    (setq background-color *black* boxed-string-color *white*)))

(defmethod 1(:default-b&w-setup base-menu-item)0 (plist)
  (when (not (get plist :font))
    (setq font fonts:cptfont))
  (when (not (get plist :label-font))
    (setq label-font fonts:cptfonti)))

(defmethod 1(:translated-value base-menu-item)0 () value)

(defmethod1 (:update-value-from-database base-menu-item)0 (&rest ignore)
  (when database
    (setq value (send database :get-value))))

(defmethod 1(:update-database-from-value base-menu-item)0 ()
  (when database
    (send database :set-value value)))

;;-----------------------------------------------------------------------------------------

(defmethod (:top-group base-menu-item) ()
  (if group
      (send group :top-group)
      self))

(defmethod1 (:set-item-value gt:base-menu-item)0 (&rest ignore)
  (let ((top-group (send self :top-group)))
    (send menu-window 1:pop-item-list0)
    (when (neq (third value) :abort)
      (send (first value) :set-value (third value))
      (send (first value) :update-database-from-value))
    (when (send menu-window :scratch-array)
      (tv:prepare-sheet (menu-window)
	(multiple-value-bind (gx gy)
	    (send top-group :position)
	  (multiple-value-bind (xoff yoff)
	      (send menu-window :inside-edges)
	    (bitblt tv:alu-seta (send top-group :total-width)
		    (send top-group :total-height)
		    (send menu-window :scratch-array) 0 0
		    (send menu-window :screen-array) (+ xoff gx) (+ yoff gy))))
	(when (neq (third value) :abort)
	  (send (first value) :draw-item))))
    (when (neq (third value) :abort)
      (send (first value) :expose-item))
    (when (not (send menu-window :scratch-array))
      (send menu-window :refresh-rectangle-of top-group))
    ))

(defmethod1 (:callback-with-value gt:base-menu-item)0 (&rest ignore)
  (let ((top-group (send self :top-group)))
    (send menu-window 1:pop-item-list0)
    (when (send menu-window :scratch-array)
      (tv:prepare-sheet (menu-window)
	(multiple-value-bind (gx gy)
	    (send top-group :position)
	  (multiple-value-bind (xoff yoff)
	      (send menu-window :inside-edges)
	    (bitblt tv:alu-seta (send top-group :total-width)
		    (send top-group :total-height)
		    (send menu-window :scratch-array) 0 0
		    (send menu-window :screen-array) (+ xoff gx) (+ yoff gy))))))
    (when (not (send menu-window :scratch-array))
      (send menu-window :refresh-rectangle-of top-group))
    (send (first value) (second value) (third value))))

(defmethod1 (:item-list-group base-menu-item)0 ())
(defvar 1*default-color-shadow*0 (make-instance 'shadow-parameters :shadow-color *black* :shadow-xoff 2 :shadow-yoff 2))
(defmethod 1(:choose-from-items 0menu-items-mixin1)
0	   (menu-label item-list caller &optional (select :set-item-value) (callback nil) (cache-result? t))
  (let* ((*window* self)
	 (gg
	  (if (send caller :item-list-group)
	      (send caller :item-list-group)
	      (let* ((items (loop for i in item-list
				  collect
				    (command-menu-item
				      :documentation (second (memq :documentation i))
				      :value (list caller callback (second (memq :value i)))
				      :select-method select 
				      :shadow-parameters *default-color-shadow*
				      :background-color *40%-gray*
				      :boxed-string (car i))))
		     (top-label (label-menu-item :background-color *80%-gray*
						 :boxed-string-color *black* :boxed-string (or menu-label "Select One")
						 :font fonts:cptfontcb :height 14
						 :alignment-x-off 10))
		     (abort-box (command-menu-item
				  :value (list caller callback :abort)
				  :select-method select  :alignment-x-off 16 :alignment-y-off 2
				  :shadow-parameters *default-color-shadow*
				  :boxed-string "ABORT" :background-color
				  *dark-red*))
		     w group)
		(setq w (max (send top-label :width)  (send abort-box :width)
			     (loop for i in items maximize (send i :width))))
		(loop for i in items do (send i :set-width (+ w 0)))
		(send abort-box :set-width (+ w 0))
		(let ((main-group
			(group-menu-item
			  (list
						;make-sidebar-scrolling-group
			    (1make-wide-choice-group0 (+ w 10) (- (send self :height) 40) items 
						    :background-color *80%-gray*)
			    (spacer-menu-item :width 10))
			  :alignment-parameters '(:horizontal 0 0 4) :background-color *80%-gray*)))
		  (setq group
			(group-menu-item
			  (list top-label
				(spacer-menu-item :height 2 :width (send main-group :total-width)
						  :drawing-method :draw-center-line)
				main-group
				abort-box
				)
			  :alignment-parameters '(:vertical 0 0 2)
			  :background-color *80%-gray* :borders *default-thick-border*)))
		group))))
    (send gg :set-height (min (- (send self :height) 5) (send gg :height)))
    (send gg :set-position (force-into-range (- tv:Mouse-x (// (send gg :width) 2))
					     0 (- (send self :inside-width) (send gg :width)))
	  (force-into-range (- (send caller :item-top)  (// (send gg :height) 2))
			    0 (- (send self :inside-height) (send gg :height))))
    (send gg :set-size :static)
    (when cache-result?
      (send caller :set-item-list-group gg))
    (send self :push-new-item-list (list gg) (list gg))
    (when (send self :scratch-array)
      (multiple-value-bind (gx gy)
	  (send gg :position)
	(multiple-value-bind (xoff yoff)
	    (send self :inside-edges)
	  (tv:prepare-sheet (self)
	    (bitblt tv:alu-seta (send gg :total-width) (send gg :total-height)
		    (send self :screen-array) (+ xoff gx) (+ yoff gy)
		    (send self :scratch-array) 0 0)))))
    (send gg :andca)
    (send gg :expose-item)))
 
;;-----------------------------------------------------------------------------------------
(defmethod 1(:border-width base-menu-item)0 ()
  (if borders
      (+ (if (send borders :use-border?) (send borders :border-width) 0)
	 (if (send borders :use-border2?) (send borders :border2-width) 0))
      0))

(defmethod 1(:total-width base-menu-item)0 ()
  (let ((shadow-xoff (if shadow-parameters (abs (send shadow-parameters :shadow-xoff)) 0)))
    (if label
	(if (or (eq label-position :left) (eq label-position :right))
	    (+ width label-width shadow-xoff)
	    (max (+ width shadow-xoff) label-width))
	(+ width shadow-xoff))))

(defmethod 1(:total-height base-menu-item)0 ()
  (let ((shadow-yoff (if shadow-parameters (abs (abs (send shadow-parameters :shadow-yoff))) 0)))
    (if label
	(if (or (eq label-position :top) (eq label-position :bottom))
	    (+ height label-height shadow-yoff)
	    (max (+ shadow-yoff height) label-height))
	(+ shadow-yoff height))))

(defmethod 1(:position base-menu-item)0 ()
  (if label
      (values (min label-left item-left) (min label-top item-top))
      (values item-left item-top)))



(defmethod 1(:set-position base-menu-item)0 (x y)
  (if label
      (cond ((eq label-position :left)
	     (setq label-left x
		   label-top y
		   item-left (+ x label-width)
		   item-top y))
	    ((eq label-position :right)
	     (setq label-left (+ x width)
		   label-top y
		   item-left x
		   item-top y))
	    ((eq label-position :top)
	     (setq label-left x
		   label-top y
		   item-left x
		   item-top (+ y label-height)))
	    ((eq label-position :bottom)
	     (setq label-left x
		   label-top (+ y height)
		   item-left x
		   item-top  y)))
      (setq item-left x
	    item-top y)))

2;; these to become i.v.'s of the window
0(defvar *window-x-offset* -0)
(defvar *window-y-offset* -0)

2;; pixel offset relative to window based on groups this item is a part of.
0(defmethod 1(:offsets base-menu-item)0 ()
  (when (and group (not (instancep group)))
    (setq group (send menu-window :get-item group)))
  (if group
      (multiple-value-bind (g-offset-x g-offset-y)
	  (send group :offsets)
	(multiple-value-bind (g-position-x g-position-y)
	    (send group :position)
	  (values (+  g-position-x  g-offset-x (send group :x-scroll))
		  (+  g-position-y g-offset-y (send group :y-scroll)))))
      (values *window-x-offset* *window-y-offset*)))

2;; returns edges in window coordinates.
0(defmethod 1(:absolute-edges0 1base-menu-item)0 ()
  (multiple-value-bind (xoff yoff)
      (send self :offsets)
    (values (+ xoff item-left) (+ yoff item-top)
	    (+ xoff item-left width -1) (+ yoff item-top height -1))))

(defmethod 1(:are-you-at? base-menu-item)0 (x y)
  (multiple-value-bind (ll tt rr bb)
      (send self :absolute-edges)
    (if (and ( y tt) (< y bb) ( x ll) (< x rr))
	self)))

(defmethod 1(:normalized-inside-position base-menu-item)0 (mx my)
  (multiple-value-bind (left top)	
      (send self :position)
    (values  (// (float (- mx left)) width)
	     (// (float (- my top)) height))))

(defmethod (1:standard-highlight base-menu-item0) (window x y)
  window x y
  (multiple-value-bind (xoff yoff)
      (send self :offsets)
    (values (+ xoff item-left) (+ yoff item-top)
	    (+ xoff item-left width) (+ yoff item-top height))))



;;-----------------------------------------------------------------------------------------

(defmethod1 (:undraw-item base-menu-item)0 (&optional (erase-shadow? t) &rest ignore)
  (when extra-draw-method
    (send self extra-draw-method :undraw))
  (if deexpose-draw
      (send self deexpose-draw)
      (multiple-value-bind (xoff yoff)
	  (send self :offsets)
	(let ((color? (color-window? menu-window))
	      (shadow-yoff (if (and shadow-parameters erase-shadow?)
			       (send shadow-parameters :shadow-xoff) 0))
	      (shadow-xoff (if (and shadow-parameters erase-shadow?)
			       (send shadow-parameters :shadow-yoff) 0)))
	  (setq alu (send menu-window :window-alu (send self :erase-color) alu))
2	  ;; deexposing should always erase the alpha channel
0	  (if color? (send alu :set-plane-mask -1))
	  (if label
	      (send menu-window :draw-rectangle label-width label-height
		    (+ xoff label-left) (+ yoff label-top) alu))
	  (send menu-window :draw-rectangle (+ shadow-xoff width) (+ shadow-yoff height)
		(+ xoff item-left) (+ yoff item-top) alu)))))

2;; other methods shadow this when appropriate
0(defmethod1 (:draw-value base-menu-item)0 ())

(defmethod 1(:draw-shadow base-menu-item)0 ()
  (when shadow-parameters
    (multiple-value-bind (xoff yoff)
	(send self :offsets)
      (send menu-window :draw-rectangle width height
	    (+ item-left xoff (send shadow-parameters :shadow-xoff))
	    (+ item-top yoff (send shadow-parameters :shadow-yoff))
	    (send menu-window :window-alu
		  (send shadow-parameters :shadow-color) alu)))))

2;; test for (or shadow-parameters label) so that you don't calculate all this stuff when you don't need it.
0(defmethod 1(:draw-item base-menu-item)0 ()
  (when (and (neq drawing-method :ignore) *permit-draw-item*)
    (when (or shadow-parameters label)
      (let* ((real-label-font (si:get-font si:*b&w-screen* nil label-font))
	     (font-height (font-raster-height real-label-font))
2	     ;; text is offset to be in center-of item when label position is horizontal.
0	     (text-y-offset (if label
				(if (and (plusp (- label-height font-height))
					 (or (eq label-position :left)
					     (eq label-position :right)))
				    (1+ (// (- label-height font-height) 2))
				    (1+ (// (- label-height font-height) 2)))))
	     xoff yoff (color? (color-window? menu-window)))

	(multiple-value (xoff yoff)
	  (send self :offsets))

	(send self :draw-shadow)

2	;; erase what was there
0	(send self :undraw-item nil)

	(when label
	  (send menu-window :draw-string label (+ label-left xoff string-x-off)
		(- (+ label-top label-height -1) (- yoff) text-y-offset)
		(+ label-left 100 xoff)
		(- (+ label-top label-height -1) (- yoff) text-y-offset) nil label-font
		(if color? (send menu-window :window-alu (or label-color *white*) alu) tv:alu-seta))))
      )

    2;; before drawing any value, get the new value from the database.
0    (send self :update-value-from-database)
    (cond ((symbolp drawing-method) (send self drawing-method))
	  ((and drawing-method (listp drawing-method) (eq (car drawing-method) :items))
	   (loop for m in (cdr drawing-method)
		 do
	     (send self m))))
    (when extra-draw-method
      (send self extra-draw-method :draw))))

(defmethod1 (:select-item base-menu-item :after)0 (&rest ignore)
  (send self :update-database-from-value))

2;; return list of all my children and their children and so on.
0(defmethod (1:all-generations0 1base-menu-item0) ()
  (loop for i in children
	append (append (list i) (send i :all-generations))))

(defmethod 1(:expose-possible-children base-menu-item)0 (&rest ignore)
  (when possible-children
    (genocide children  (send self :superior))
    (setq children nil)
    (loop for i in (setq children (cdr (assoc (send self :value) possible-children)))
	  do
      (when (not (send i :exposed-p))
	(send i :send-if-handles :set-selected-p t)
	(send i :expose-item)))))

(defmethod1 (:exposable base-menu-item)0 ()
  (or (null expose-test)
      (cond ((instancep expose-test)
	     (send expose-test :test-exposure self))
	     ((functionp expose-test)
	     (funcall expose-test self))
	    (t (send self expose-test)))))

(defmethod (1:expose-item0 1base-menu-item0) ()
  (when (and (or (null expose-test)
		 (cond ((instancep expose-test)
			(send expose-test :test-exposure self))
		       ((functionp expose-test)
			(funcall expose-test self))
		       (t (send self expose-test))))
	     (or (not (instancep group)) (not (send group :clip-sub-items?)) (send self :inside-group?)))

    (setq exposed-p t)
    (send (send self :superior) :add-item self)
    (send self :draw-item)
    (send self :expose-possible-children)
    (loop for child in children
	  do
      (and child (not (send child :exposed-p)) (send child :expose-item)))))

(defmethod1 (:refresh-item base-menu-item)0 ()
  (if (not (send self :exposed-p))
      (send self :expose-item)		
      (send self :draw-item)
      (loop for child in children
	    do
	(send child :refresh-item))))

(defmethod1 (:deexpose-item base-menu-item)0 ()
  (setq exposed-p nil)
  (send (send self :superior) :remove-item self)
  (send self :undraw-item))

(defmethod 1(:deexpose-children base-menu-item)0 ()
  (loop for node in children
	do
    (when (and node (send node :exposed-p))
      (send node :deexpose-item)
      (send node :deexpose-children))))

(defmethod1  (:print-self0 1base-menu-item)0  (stream &rest ignore)
  (si:printing-random-object  (self stream :no-pointer)
    (if (and (variable-boundp id) id)
	(format stream "Ms Item~@[ ~a~]" id)
	(format stream "~@[~a~]" (typep self)))))

(defmethod1  (:ignore base-menu-item)0  (&rest ignore))
(defmethod1  (:dont-draw base-menu-item)0  (&rest ignore))

(defmethod 1(:active-left base-menu-item)0 () item-left)
(defmethod 1(:active-top base-menu-item)0 () item-top)
(defmethod 1(:active-width base-menu-item)0 () width)
(defmethod 1(:active-height base-menu-item)0 () height)

;;-------------------------------------------------------------------------------------
(defmethod 1(:draw-with-alu0 1base-menu-item)0 (draw-alu &optional (inner? t))
  (multiple-value-bind (xoff yoff)
      (send self :offsets)
    (if inner?
	(send menu-window :draw-rectangle width height (+ item-left xoff)
	      (+ item-top yoff) draw-alu)
	(multiple-value-bind (px py)
	    (send self :position)
	  (send menu-window :draw-rectangle (send self :total-width)
		(send self :total-height) (+ px xoff)
		(+ py yoff) draw-alu)))))

(defmethod1 (:draw-outline-with-alu base-menu-item)
0	   (draw-alu outline-thickness &optional ww hh (inner? t))
  (multiple-value-bind (xoff yoff)
      (send self :offsets)
    (multiple-value-bind (px py)
	(send self :position)
      (let ((left-side (+ xoff (if inner? (send self :active-left) px)))
	    (top-side (+ yoff (if inner? (send self :active-top) py)))
	    (w (or ww (send self (if inner? :active-width :total-width))))	
	    (h (or hh (send self (if inner? :active-height :total-height)))))
	(send menu-window :draw-rectangle w outline-thickness left-side top-side draw-alu)
	(send menu-window :draw-rectangle outline-thickness h left-side top-side draw-alu)
	(send menu-window :draw-rectangle w outline-thickness left-side (+ top-side h (- outline-thickness))
	      draw-alu)
	(send menu-window :draw-rectangle outline-thickness h (+ left-side w (- outline-thickness)) top-side
	      draw-alu)))))

(defmethod 1(:fill base-menu-item)0 (&optional (inner? t))
  (send menu-window :window-alu boxed-string-color alu)
  (send self :draw-with-alu alu inner?))
(defmethod 1(:seta base-menu-item)0 (&optional (inner? t))
  (send self :draw-with-alu tv:alu-seta inner?))
(defmethod 1(:andca base-menu-item)0 (&optional (inner? t))
  (send self :draw-with-alu tv:alu-andca inner?))

(defmethod1 (:xor base-menu-item)0 (&optional (inner? t))
  (send self :draw-with-alu 
	(if (color-window? menu-window)
	    (send menu-window :window-alu *white* alu tv:alu-xor)
	    tv:alu-xor)
	inner?))


(defmethod1 (:draw-drop-shadow-outline base-menu-item)0	
	   (upper-left-color lower-right-color outline-thickness &optional w h)
  (multiple-value-bind (xoff yoff)
      (send self :offsets)

    (setq alu (send menu-window :window-alu upper-left-color alu))
    (send menu-window :draw-rectangle (or w (1- (send self :active-width)))
	  outline-thickness
	  (+ (send self :active-left) xoff) (+ (send self :active-top) yoff) alu)
    (send menu-window :draw-rectangle outline-thickness (or h (1- height))
	  (+ (send self :active-left) xoff) (+ (send self :active-top) yoff) alu)

    (setq alu (send menu-window :window-alu lower-right-color alu))
    (send menu-window :draw-rectangle (or w (1- (send self :active-width)))
	  outline-thickness
	  (+ 1 (send self :active-left) xoff) (- (+ (send self :active-top) (or h height) yoff) outline-thickness)
	  alu)

    (send menu-window :draw-rectangle outline-thickness (or h (1- height))
	  (- (+ (send self :active-left) (or w (send self :active-width))
		xoff) outline-thickness)
	  (+ 1 (send self :active-top) yoff) alu)


    ))

(defmethod 1(:draw-active-area-background base-menu-item)0 ()
  (send self :draw-background))

(defmethod 1(:draw-background base-menu-item)0 ()
  (multiple-value-bind (xoff yoff)
      (send self :offsets)
    (setq alu (send menu-window :window-alu background-color alu))
    (send menu-window :draw-rectangle width height
	  (+ xoff item-left) (+ yoff item-top) alu)))

(defvar *emboss-color1* (color:make-standard-color))
(defvar *emboss-color2* (color:make-standard-color))

(defmethod 1(:draw-emboss-outline base-menu-item)0 ()
  (color:duplicate-color background-color :rgb *emboss-color1*)
  (color:duplicate-color background-color :rgb *emboss-color2*)
  (send *emboss-color1* :set-intensity (* 2 (send  *emboss-color1* :intensity)))
  (send *emboss-color2* :set-intensity (* .2 (send  *emboss-color2* :intensity)))
  (send *emboss-color1* :set-saturation 0)
  (send *emboss-color2* :set-saturation 0)
  (send self :draw-drop-shadow-outline  *emboss-color1* *emboss-color2* 1))

;;-------------------------------------------------------------------------------------

(defmethod 1(:draw-border-internal base-menu-item)0 (inner?)
  (when borders
    (when (send borders :use-border?)
      (setq alu (send menu-window :window-alu (send borders :border-color) alu))
      (send self :draw-outline-with-alu alu (send borders :border-width) nil nil inner?))
    (when (send borders :use-border2?)
      (setq alu (send menu-window :window-alu (send borders :border2-color) alu))
      (send self :draw-outline-with-alu alu (send borders :border2-width) nil nil inner?))))

(defmethod 1(:draw-border base-menu-item)0 ()
  (send self :draw-border-internal t))

2;; make compute motion work on small windows.
0(defmethod 1(:substring-that-fits base-menu-item)0 (string character-style)
  (scl:with-character-style (character-style menu-window)
    (let ((string-length (string-length string))
	  (string-width (send menu-window :compute-motion string 0 nil nil nil nil 0 nil nil 2000)))
      (if (or (< string-width (- gt:width 4)) (<= string-length 1))
	  string
	  (send self :substring-that-fits
		(substring string 0 (max 1 (min (- string-length 1)
						(fix (* (// (max 0 (- gt:width 4)) (float (max 1 string-width)))
							string-length)))))
		character-style)))))

(defmethod1 (:draw-boxed-string base-menu-item)0 (str fnt back-color str-color &optional (clip? t) (dx 0) (dy 0) (clear? t))
  (multiple-value-bind (xoff yoff)
      (send self :offsets)
    (setq xoff (+ xoff dx) yoff (+ yoff dy))
    (let* ((real-font (si:get-font si:*b&w-screen* nil fnt))
	   (font-height (font-raster-height real-font))
	   (text-y-offset (+ (if (plusp (- height font-height))
				 (1+ (// (- height font-height) 2))
				 0))))
      (when clear?
2	;; draw background
0	(send menu-window :draw-rectangle width height (+ item-left xoff) (+ item-top yoff) 
	      (send menu-window :window-alu back-color alu))
2	;; draw border
0	(send self :draw-border))

2      ;;draw string
0      (send menu-window :draw-string
	    (if clip? (send self :substring-that-fits (string str) fnt) (string str))
	    (+ item-left xoff string-x-off)
	    (max 0 (- (+ item-top height -1) (- yoff) text-y-offset))
	    (+ item-left 100 xoff)
	    (max 0 (- (+ item-top height -1) (- yoff) text-y-offset)) nil fnt
	    (send menu-window :window-alu str-color alu)))))

gt:
(defmethod1 (:draw-icon base-menu-item)0 (back-color icon-color)
  (setq alu (send menu-window :window-alu back-color alu))
  (send self :draw-with-alu alu)
  (setq alu (send menu-window :window-alu icon-color alu))
  (let ((item-right (+ item-left width -1))
	(item-bottom (+ item-top height -1)))
    (multiple-value-bind (xoff yoff)
	(send self :offsets)
      (selectq icon-type
	(:circle (let ((r (// (min width height) 3))
		       (center-x (+ xoff (// (+ item-left item-right) 2)))
		       (center-y (+ yoff (// (+ item-top item-bottom) 2))))
		   (send menu-window :Draw-filled-in-circle  center-x center-y r alu)))
	(:ellipse (let ((center-x (// (+ item-left item-right) 2))
			(center-y (// (+ item-top item-bottom) 2)))
		    (send menu-window :Draw-filled-in-simple-ellipse
			  (+ xoff center-x 1) (+ yoff center-y) (1- (// width 2)) (// height 4) alu)))
	(:outline-circle (let ((r (// (min width height) 3))
		       (center-x (+ xoff (// (+ item-left item-right) 2)))
		       (center-y (+ yoff (// (+ item-top item-bottom) 2))))
		   (send menu-window :Draw-circle  center-x center-y r alu)))
	(:outline-ellipse (let ((center-x (// (+ item-left item-right -2) 2))
			(center-y (// (+ item-top item-bottom) 2)))
		    (send menu-window :Draw-simple-ellipse
			  (+ xoff center-x 2) (+ yoff center-y) (- (// width 2) 3) (// height 4) alu)))
	(:triangle (send menu-window :Draw-triangle (+ xoff item-left) (+ yoff item-bottom) (+ xoff item-right)
			 (+ yoff item-bottom) (+ xoff (// (+ item-left item-right) 2))
			 (+ yoff item-top) alu))
	(:scatter
	 (let ((ll (+ item-left xoff 4))
	       (rr (+ item-right xoff -4))
	       (tt (+ item-top yoff 4))
	       (bb (+ item-bottom yoff -4)))
	   (send menu-window :draw-line ll tt rr tt alu)
	   (send menu-window :draw-line rr tt rr bb alu)
	   (send menu-window :draw-line rr bb ll bb alu)
	   (send menu-window :draw-line ll bb ll tt alu))
	 (send menu-window :Draw-rectangle 2 2 (+ xoff item-left 10) (+ yoff item-top 10) alu)
	 (send menu-window :Draw-rectangle 2 2 (+ xoff item-left 12) (+ yoff item-top 6) alu)
	 (send menu-window :Draw-rectangle 2 2 (+ xoff item-left 15) (+ yoff item-top 2) alu)
	 (send menu-window :Draw-rectangle 2 2 (+ xoff item-left 17) (+ yoff item-top 8) alu)
	 (send menu-window :Draw-rectangle 2 2 (+ xoff item-left 3) (+ yoff item-top 17) alu)
	 (send menu-window :Draw-rectangle 2 2 (+ xoff item-left 7) (+ yoff item-top 8) alu))
	(:polygon (let ((mid-y (// (+ item-top item-bottom) 2))
			(mid-x (// (+ item-left item-right) 2)))
		    (send menu-window :Draw-triangle (+ xoff item-left) (+ yoff mid-y) (+ xoff item-right)
			  (+ yoff mid-y) (+ xoff mid-x) (+ yoff item-bottom) alu)
		    (send menu-window :Draw-triangle (+ xoff mid-x) (+ yoff item-top) (+ xoff mid-x)
			  (+ yoff mid-y) (+ xoff item-right) (+ yoff mid-y) alu)))
	(:outline-polygon (let* ((mid-y (+  yoff (// (+ item-top item-bottom) 2)))
			 (mid-x (+  xoff (// (+ item-left item-right) 2)))
			 (ll (- mid-x 7))
			 (rr (+ mid-x 7))
			 (tt (- mid-y 7))
			 (bb (+ mid-y 7)))
		    (send menu-window :draw-line ll mid-y mid-x tt alu)
		    (send menu-window :draw-line mid-x tt mid-x mid-y alu)
		    (send menu-window :draw-line mid-x mid-y rr mid-y alu)
		    (send menu-window :draw-line rr mid-y mid-x bb alu)
		    (send menu-window :draw-line mid-x bb ll mid-y alu)
		    ))

	(:outline-rectangle
	 (let ((ll (+ item-left xoff 4))
	       (rr (+ item-right xoff -4))
	       (tt (+ item-top yoff 4))
	       (bb (+ item-bottom yoff -4)))
	   (send menu-window :draw-line ll tt rr tt alu)
	   (send menu-window :draw-line rr tt rr bb alu)
	   (send menu-window :draw-line rr bb ll bb alu)
	   (send menu-window :draw-line ll bb ll tt alu)))


	(:rectangle (send menu-window :Draw-rectangle (- width 2) (// height 2) (+ item-left 1 xoff)
			  (+ item-top yoff (// height 4)) alu))
	(:fill-icon
	 (let ((r (// (min width height) 4))
	       (center-x (+ xoff (// (+ item-left item-right) 2)))
	       (center-y (+ yoff (// (+ item-top item-bottom) 2))))
	   (send menu-window :Draw-filled-in-circle  (- center-x 3) center-y r alu)
	   (send menu-window :Draw-filled-in-circle  (+ center-x 3) (- center-y 2) r alu)))
	(:outline-fill-icon
	 (let ((r (// (min width height) 5))
	       (center-x (+ xoff (// (+ item-left item-right) 2)))
	       (center-y (+ yoff (// (+ item-top item-bottom) 2))))
	   (send menu-window :Draw-circle  (- center-x 3) center-y r alu)
	   (send menu-window :Draw-circle  (+ center-x 3) (- center-y 2) r alu)))

	(:diagonal-bar
	 (send menu-window :Draw-line (+ item-left xoff 5) (+ item-top yoff width -5)
	       (+ item-left xoff width -5) (+ item-top yoff 5)  alu)
	 (send menu-window :Draw-line (+ item-left xoff 5) (+ item-top yoff width -4)
	       (+ item-left xoff width -4) (+ item-top yoff 5)  alu))
	(:cross
	 (send menu-window :draw-rectangle 2 (- gt:height 6)
	       (+ item-left xoff -2 (// gt:width 2)) (+ item-top yoff 3) alu)
	 (send menu-window :draw-rectangle (- gt:width 8) 2 (+ item-left xoff 3)
	       (+ yoff -1 item-top (// gt:height 2)) alu)
	 )
	(:square
	 (let* ((size (min 12 (min gt:width gt:height)))
		(dx (// (- width size) 2))
		(dy (// (- height size) 2)))
	   (send menu-window :draw-rectangle size size
		 (+ item-left xoff dx) (+ yoff item-top dy) alu)))
	(:horizontal-bar
	 (send menu-window :draw-rectangle (- gt:width 6) 2 (+ item-left 3 xoff)
	       (+ item-top yoff (// gt:height 2)) alu))
	(:vertical-bar
	 (send menu-window :draw-rectangle 2 (- gt:height 2) (+ item-left xoff (// gt:width 2))
	       (+ yoff item-top 1) alu))
	(:plus
	 (let* ((size 6); (- (min gt:width gt:height) 4))
		(dx (// (- width size) 2))
		(dy (// (- height size) 2))
		)
2	   ;; vertical bar
0	   (send menu-window :draw-rectangle 2 size
		 (+ item-left xoff dx (// size 2) -1) (+ item-top yoff dy) alu)
2	   ;;horizontal
0	   (send menu-window :draw-rectangle size 2
		 (+ item-left dx xoff)
		 (+ -1 yoff dy item-top (// size 2)) alu)
	   ))
	(:minus
	 (let* ((size 6) ;(- (min gt:width gt:height) 4))
		(dx (// (- width size) 2))
		(dy (// (- height size) 2))
		)
2	   ;;horizontal
0	   (send menu-window :draw-rectangle size 2
		 (+ item-left dx xoff)
		 (+ -1 yoff dy item-top (// size 2)) alu)
	   ))
	(:up-triangle
	 (let* ((size (min 12 (min gt:width gt:height)))
		(dx (// (- width size) 2))
		(dy (// (- height size) 2))
	       )
	   (send menu-window :draw-triangle
		 (+ item-left xoff dx (// size 2)) (+ yoff item-top 1 dy)
		 (+ item-left xoff 1 dx) (+ yoff item-top size -1 dy)
		 (+ item-left xoff size -1 dx) (+ yoff item-top size -1 dy) alu)))
	(:small-up-triangle
	 (let* ((size (min 12 (// (min gt:width gt:height) 2)))
		(dx (// (- width size) 2))
		(dy (// (- height size) 2))
	       )
	   (send menu-window :draw-triangle
		 (+ item-left xoff dx (// size 2)) (+ yoff item-top 1 dy)
		 (+ item-left xoff 1 dx) (+ yoff item-top size -1 dy)
		 (+ item-left xoff size -1 dx) (+ yoff item-top size -1 dy) alu)))
	(:down-triangle
	 (let* ((size (min 12 (min gt:width gt:height)))
		(dx (// (- width size) 2))
		(dy (// (- height size) 2)))
	   (send menu-window :draw-triangle
		 (+ item-left xoff (// size 2) dx) (+ yoff item-top size -1 dy)
		 (+ item-left xoff 1 dx) (+ yoff item-top 1 dy)
		 (+ item-left xoff size -1 dx) (+ yoff item-top 1 dy) alu)))
	(otherwise
	 (color:view-image menu-window (eval icon-type) :wdx (+ item-left xoff)
			   :wdy (+ item-top yoff ) :dx -1 :width (1- width) :height height)
	 (when (send self :send-if-handles :selected-p)
	   (send menu-window :draw-rectangle width height
		 (+ item-left xoff) (+ item-top yoff) (color:scf 0 #xff ))))
	))))
;;------------------------------------------------------------------------------------------
(defflavor 1dummy-menu-item0 () (base-menu-item)
  (:default-init-plist :select-method :ignore :drawing-method :ignore :mouse-sensitive nil))

;;------------------------------------------------------------------------------------------
(defflavor1 command-menu-item0 ((command-args)) (base-menu-item)
  (:settable-instance-variables)
  (:default-init-plist :background-color command-color :boxed-string-color *white*
		       :documentation "Execute this command"
		       :drawing-method :command-draw))


;;------------------------------------------------------------------------------------------
(defflavor 1label-menu-item0 () (command-menu-item)
  (:default-init-plist :select-method :ignore :mouse-sensitive nil :select-method :ignore
		       :background-color *white* :boxed-string-color  *black*))

(defmethod 1(:invert-draw label-menu-item)0 ()
  (send self :command-draw)
  (send self :xor))

;;------------------------------------------------------------------------------------------
(defmethod 1(:draw-center-line base-menu-item)0 (&optional lw lh draw-alu)
  (multiple-value-bind (xoff yoff)
      (send self :offsets)
    (let* ((line-width (or lw width))
	   (line-height (or lh 2)))
      (send menu-window :draw-rectangle line-width line-height
	    (+ xoff item-left (// (- width line-width) 2))
	    (+ yoff item-top (// height 2) (- (// line-height 2)))
	    (or draw-alu (send menu-window :window-alu boxed-string-color alu))))))

(defflavor 1spacer0-1menu-item0 () (base-menu-item)
  (:default-init-plist :select-method :ignore :drawing-method :ignore
		       :mouse-sensitive nil))


;;------------------------------------------------------------------------------------------
;;------------------------------------------------------------------------------------------
(defflavor1 paging-menu-item0 ((paging-action :increment) (refresh-method))
      (base-menu-item)
  (:default-init-plist :select-method :page-choose :drawing-method :page-number-draw
		       :documentation nil :Font cptfontcc
		       :boxed-string-color command-color :background-color *80%-gray*)
  (:settable-instance-variables))

(defmethod 1(:documentation paging-menu-item)0 ()
  (cond ((eq paging-action :increment) "L: Increment Page.     M: Increment Row.     R: Increment Page by 5.")
	((eq paging-action :decrement) "L: Decrement Page.     M: Decrement Row.     R: Decrement Page by 5.")
	((eq paging-action :start) "Go to beginning of library")
	((eq paging-action :display) "This displays the current library page.")))

(defvar 1*paging-menu-style*0 :numeric)
(defmethod 1(:init paging-menu-item :after)0 (&rest ignore)
1  0(cond ((eq 1*paging-menu-style*0 :numeric)
2	 ;; kludge for now to avoid changing all callers.
0	 (cond ((eq paging-action :increment) (setq paging-action :decrement))
	       ((eq paging-action :decrement) (setq paging-action :increment)))
	 (setq icon-type (if (eq paging-action :increment) :plus :minus)))
	((eq 1*paging-menu-style*0 :numeric-arrows)
	 (cond ((eq paging-action :increment) (setq paging-action :decrement))
	       ((eq paging-action :decrement) (setq paging-action :increment)))
	 (setq icon-type (if (eq paging-action :increment) :up-triangle :down-triangle)))
	((eq 1*paging-menu-style*0 :spacial-arrows)
	 (setq icon-type (if (eq paging-action :increment) :down-triangle :up-triangle))))

  (when (neq paging-action :display)
    (setq font fonts:cptfontcb))
  (when (eq paging-action :display)
    (setq mouse-sensitive nil)
    (setq background-color *black*)
    (setq boxed-string-color *white*)))

(defmethod (1:page-choose0 1paging-menu-item)0 (mouse-buttons &rest ignore)
  (let ((library (send (send self :group) :group)))
    (cond ((eq paging-action :start)
	   (send library :send-if-handles :set-row-offset 0)
	   (send library :set-current-page 0))
	  ((eq paging-action :display))
	  ((eq paging-action :increment)
	   (selectq mouse-buttons
	     (#\mouse-l 
	      (send library :send-if-handles :set-row-offset 0)
	      (send library :set-current-page
		    (1+ (send library :current-page))))
	     (#\mouse-m
	      (send library :increment-row 1))
	     (#\mouse-r 
	      (send library :send-if-handles :set-row-offset 0)
	      (send library :set-current-page
		    (+ 5 (send library :current-page))))))
	  ((eq paging-action :decrement)
	   (selectq mouse-buttons
	     (#\mouse-l
	      (send library :send-if-handles :set-row-offset 0)
	      (send library :set-current-page
		    (max 0 (- (send library :current-page) 1))))
	     (#\mouse-m (send library :increment-row -1))
	     (#\mouse-r
	      (send library :send-if-handles :set-row-offset 0)
	      (send library :set-current-page
		    (max 0 (- (send library :current-page) 5)))))))
    (loop for i in (send library :item-list)
	  do (send i :expose-item))))


(defmethod 1(:page-number-draw paging-menu-item)0 (&rest ignore)
  (let ((layout (send (send self :group) :group)))
    (cond ((eq paging-action :display)
	   (let* ((page (send layout :current-page)))
	     (send self :draw-boxed-string
		   (if (> width 20)
		       (string-append "Page:" (format nil "~d" (+ page 1)))
		       (format nil "~d" (+ page 1)))
		   font background-color boxed-string-color)))
	  (t
	   (cond ((memq paging-action '(:increment :decrement))
		  (send self :icon-draw))
		 (t
		  (send self :command-draw)))))))

;;----------------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------------

(defflavor1 scroll-bar-menu-item0 ((dependents) (refresh-method)
				 (direction :vertical) (bar-color *40%-gray*)
				 (positioner-color *dark-blue*))
      (base-menu-item)
  (:default-init-plist :select-method :scroll-bar-choose :drawing-method :scroll-bar-draw
		       :boxed-string-color *white* :background-color command-color)
  (:settable-instance-variables))


(defmethod (1:scroll-bar-choose0 1scroll-bar-menu-item)0 (mouse-buttons &rest ignore)
  (ignore mouse-buttons)
  (dolist (d dependents) (send d :draw-item))  
  (when refresh-method (send self refresh-method)))

(defmethod 1(:scroll-bar-draw 0 1scroll-bar-menu-item)0 (&rest ignore)
  (let* ((layout (eval library-layout))
	 (db (send self :get-database))
	 (page-size (send layout :page-size))
	 (box-size-ratio (// (float page-size)
			     (max 1 (length (send db :database-list)))))
	 (box-offset-ratio (// (float (+ (send layout :row-offset)
					 (* (send layout :page-size) (send layout :current-page))))
			       (max 1 (length (send db :database-list))))))
    (print box-size-ratio)
    (send self :draw-with-alu (send menu-window :window-alu bar-color alu))
    (cond ((eq direction :vertical)
	   (send menu-window :draw-rectangle width (ceiling (* height box-size-ratio))
		 item-left (+ item-top (ceiling (* height box-offset-ratio)))
		 (send menu-window :window-alu positioner-color alu)))
	  ((eq direction :horizontal)
	   (send menu-window :draw-rectangle (ceiling (* width box-size-ratio)) height 
		  (+ item-left (ceiling (* width box-offset-ratio))) item-top
		  (send menu-window :window-alu positioner-color alu))))
    (send self :draw-border)
    ))

;;----------------------------------------------------------------------------------------

(defmethod  1(:default-b&w-setup command-menu-item :after)0 (plist)
  (when (not (get plist :font))
    (setq font fonts:cptfontb)))

(defmethod1 (:return-value0 gt:command-menu-item1)0 (&rest ignore)
  (if (or value command-args)
      (throw 'gt:done (if command-args (send (send menu-window :get-item command-args) :value) value))))

(defmethod 1(:command-draw base-menu-item)0 ()
  (send self :draw-boxed-string boxed-string font background-color boxed-string-color
	;; don't clip string. Assume it is designed to fit.
	nil)
  (send self :draw-border)
  )

;;----------------------------------------------------------------------------------------

(defflavor1 doit-menu-item0 () (base-menu-item)
  (:default-init-plist :background-color execute-color :boxed-string-color *black*
		       :drawing-method :command-draw
		       :documentation "Execute this command"))

;;----------------------------------------------------------------------------------------

(defflavor1 sym-font-menu-item0 () (base-menu-item)
  (:default-init-plist :select-method :sym-font-choose :drawing-method :text-draw
		       :documentation "Select a Font"))

(defmethod  1(:sym-font-choose sym-font-menu-item)0 (&rest ignore)
  (if (null *font-menu*)
      (setq *font-menu* (tv:make-window 'tv:momentary-menu
					:superior tv:main-screen
					:geometry '(4 nil nil nil nil nil)
					:label "Select a font:"
					:last-item nil)))
  (let ((default-item (send *font-menu* :last-item)) (ans) (old-sheet tv:mouse-sheet))
    (send *font-menu* :set-fill-p t)
    (send *font-menu* :set-item-list (loaded-tv-fonts-item-list))
    (send *font-menu* :set-last-item default-item)
    (tv:mouse-set-sheet tv:main-screen)
    (setq ans (send *font-menu* :choose))
    (tv:mouse-set-sheet old-sheet)
    (when ans
      (setq value (font-name ans))
      (send self :update-database-from-value)
      (send self :text-draw))))
;;----------------------------------------------------------------------------------------
(defflavor 1boxed-number-menu-item0 ((min 0) (max) (incr-value) (float?) (background?)
				   (display-scale-factor))
	   (base-menu-item)
  (:settable-instance-variables)
  (:default-init-plist :value 0 :select-method :boxed-number-choose
		       :documentation "L: Set Value with Keypad     M,R: Increment or Decrement value"
		       :drawing-method :boxed-number-draw))

(defmethod 1(:init0 1boxed-number-menu-item :after)0 (&rest plist)
  (when (not (get (car plist) :incr-value))
    (if float?
	(setq incr-value .1)
	(setq incr-value 1))))

(defmethod  1(:default-b&w-setup boxed-number-menu-item :after)0 (plist)
2  ;; compute this based on the font, float?, min and max
0  (when (not (get plist :width))
    (setq width 60)))

(defmethod1 (:boxed-number0-1draw0 1boxed-number-menu-item)0 ()
  (if value
      (progn
	(if float? (setq value 2 0(float value))) ;2(// (round (* 100. value)) 100.0)))0	;	2;was
0	(let* ((printable-value (if display-scale-factor (* display-scale-factor value) value))
	       (str (if float?
		       (format nil "~3f" printable-value)
		       (format nil "~d" (round printable-value)))))
	  (setq str (send self :substring-that-fits str font))
	  (send self :draw-boxed-string str font background-color boxed-string-color)
	  (send self :draw-border)
	  ))
      (send self :draw-with-alu (send menu-window :window-alu background-color alu))))

(defconst1 *joke-mode*0 nil)

(defmethod1 (:boxed-number-choose boxed-number-menu-item)0 (mb &rest ignore)
  (send self :update-value-from-database)
  (when value
    (loop for count from 0
	  for incr = (if (< count 20.) incr-value (* 4 incr-value))
	  for first = t then nil
	  for mouse-buttons = mb then (blip-from-buttons (tv:mouse-buttons))
	  do
      (progn
	(when first  (mouse-buttons-wait))
	(when (tv:key-state :shift) (setq incr (* incr 10.)))
	(cond ((eq mouse-buttons #\mouse-r)
	       (setq value (- value incr)))
	      ((eq mouse-buttons #\mouse-m)
	       (setq value (+ value incr)))
	      ((eq mouse-buttons #\mouse-l)
	       (let ((new-answer
		       (with-item-xored self
			 (tv:choose-number  :width *keypad-width*
					    :allow-floatp float?
					    :height *keypad-height* :zoom nil))))
		 (loop until (zerop (tv:Mouse-buttons)))
		 (when new-answer
		   (setq value (if display-scale-factor
				   (// new-answer (float display-scale-factor))
				   new-answer))
		   (if (not float?)
		       (setq value (round value))
		       (setq value (float value)))))))
	(setq value (force-into-possible-range value min max))
	(if (not float?)
	    (setq value (round value)))
	(when ( (tv:Mouse-buttons) 0)
	  (if (and *joke-mode* (> value 90.))
	      (process-sleep (* (abs (- value 90)) 4.)))
	  (process-sleep 3.))
	(send self :update-database-from-value)
	(send self :boxed-number-draw))
	  until (= (tv:mouse-buttons) 0)
	    )))

;;----------------------------------------------------------------------------------------
(defflavor 1slider-menu-item0 ((min 0.0) (max 1.0) (incr-value 1) (float? t)
			     (background? t) (exponent 1.0)
			     (display-mode :percentage)	;or :literal or :none
			     (number-of-digits-displayed 3)
			     (display-value-width :compute)
			     (display-value? t) (mouse-tracking-function #'ignore))
	   (base-menu-item)
  (:default-init-plist :select-method :slider-choose 
		       :drawing-method :slider-draw :mouse-sensitive nil
		       :documentation "L: Set Value     M: Increment or Decrement value     R: Numeric Keypad")
  (:settable-instance-variables))

(defmethod  1(:default-b&w-setup slider-menu-item :after)0 (plist)
  (when (not (get plist :width))
    (setq width 150))
  (when (not (get plist :height))
    (setq height 15))
  (when (not (get plist :shadow-parameters))
    (setq shadow-parameters *default-b&w-shadow*))
  (when (not (get plist :borders))
    (setq borders *default-border*)))

(defmethod 1(:active-left slider-menu-item)0 () (+ item-left display-value-width))
(defmethod 1(:active-width slider-menu-item)0 () (- width display-value-width))

(defmethod 1(:draw-active-area-background slider-menu-item)0 ()
  (multiple-value-bind (xoff yoff)
      (send self :offsets)
    (setq alu (send menu-window :window-alu background-color alu))
    (send menu-window :draw-rectangle (- width display-value-width) height
	  (+ xoff item-left display-value-width) (+ yoff item-top) alu)))

(defmethod1 (:init slider-menu-item0 1:after)0 (plist)
  (if (eq display-value-width :compute)
      (send self :re-initialize))
  (when (and float? (not (get plist :incr-value)))
    (setq incr-value (// (- max min) 100))))

(defmethod1 (:re-initialize slider-menu-item)0 ()
  (if display-value?
      (scl:with-character-style (font menu-window)
	(let ((length (send menu-window :compute-motion
			    (if (or (not float?) (eq display-mode :percentage))
				(format nil "~d " 100)
				(format nil (format nil "~a~a~a" "~"
						    number-of-digits-displayed "f"
						    .080808))))))
	  (setq display-value-width (+ length 2))))
      (setq display-value-width 0)))

(defmethod 1(:draw-shadow slider-menu-item)0 ()
  (multiple-value-bind (xoff yoff)
      (send self :offsets)
    (when shadow-parameters
      (send menu-window :draw-rectangle (- width display-value-width) height
	    (+ item-left xoff (send shadow-parameters :shadow-xoff) display-value-width)
	    (+ item-top yoff (send shadow-parameters :shadow-yoff))
	    (send menu-window :window-alu (send shadow-parameters :shadow-color) alu)))))

(defmethod 1(:slider0-1draw slider-menu-item)0 ()
  (when (not value) (setq value 0))
  (let* ((real-font (tv:with-character-style (font) (send menu-window :current-font)))
	 left top right bottom x-position slider-left slider-width
	 (color? (color-window? menu-window)))
    (multiple-value (left top right bottom)
      (send self :absolute-edges))

    (setq slider-left (+ left display-value-width))
    (setq slider-width (- width display-value-width))

2    ;; draw background-field and border
0    (when background?
      (send self :draw-active-area-background)
2      ;; draw horizontal center-line
0      (send menu-window :draw-rectangle slider-width
	    (if (color-window? menu-window) 2 1) slider-left (// (+ top bottom) 2)
	    (send menu-window :window-alu *white* alu)))

2    ;; draw vertical marker for value
0    (setq x-position
	  (min (1- right)
	       (+ slider-left (fix (* (^ (// (- value min) (float (- max min))) (// exponent))
				      slider-width)))))
    (send menu-window :draw-rectangle 1 height x-position top 
	  (if background?
	      (send menu-window :window-alu *white* alu)
	      (if color? new-xor tv:alu-xor)))

2    ;; print numeric-value
0    (when display-value?
      (scl:with-character-style (font menu-window)
	(let* ((value-string 
		 (if (eq display-mode :percentage)
		     (format nil "~d%" (fix (* 100. value)))
		     (format nil (format nil "~a~a~a" "~" number-of-digits-displayed
					 (if float? "f" "d")) value)))
	       (font-height (font-raster-height real-font))
	       (text-y-offset (+ (if (plusp (- height font-height))
				     (1+ (// (- height font-height) 2))
				     0))))
	  (send menu-window :window-alu (send self :erase-color) alu)
	  (send menu-window :draw-rectangle display-value-width
		height left top alu)
	  (send menu-window :draw-string value-string
		left
		(- bottom string-y-off  text-y-offset)
		right (- bottom string-y-off  text-y-offset)
		nil font
		(send menu-window :window-alu *white* alu)))))
    (send self :draw-border)
    ))

;(defun 1get-mouse-or-tablet-values0 ()
;  (let ((valid nil) (buttons 1) x y)
;    (when tablet:*tablet*
;      (tablet:with-tablet-usurped (tablet:*tablet*)
;	(loop with last-time-valid-point-seen = (sys:%microsecond-clock)
;	      for now = (sys:%microsecond-clock)
;	      for done = (or (and valid (zerop buttons))
;			     (> (time-difference now last-time-valid-point-seen)
;				paint:*paint-with-tablet-timeout-in-microseconds*))
;	      until done
;	      do
;	  (setq valid (tablet:read-point tablet:*tablet*))
;	  (when valid
;	    (setf last-time-valid-point-seen (sys:%microsecond-clock))
;	    (multiple-value (x y buttons)
;	      (send tablet:*tablet* :map-current-tablet-data-to-screen-coordinates))
;	    (when (not (zerop buttons))
;	      (setq tv:mouse-buttons buttons tv:Mouse-x x tv:mouse-y y))
;	    ))))))

(defmethod  1(:slider-choose slider-menu-item)
0	    (&optional (mouse-button #\mouse-left) mouse-x mouse-y
		       (mouse-device :3-button-mouse))
  mouse-y 
  (let (left top right bottom float-position slider-left slider-width)

    (multiple-value (left top right bottom)
      (send self :absolute-edges))

    (setq slider-left (+ left display-value-width))
    (setq slider-width (- width display-value-width 1))

    (setq mouse-x (force-into-range (mouse-window-x menu-window)
				    slider-left right))
    (setq float-position  (+ min (* (^ (// (float (- mouse-x slider-left)) slider-width) exponent)
				    (- max min))))

    (cond ((eq mouse-button #\mouse-l)

	   (when (eq mouse-device :tablet)
	     1(get-mouse-or-tablet-values)0)
	   (setq mouse-x (force-into-range (mouse-window-x menu-window)
					   slider-left right))
	   (without-pointer
	     (loop  do
	       (when (eq mouse-device :tablet)
		 (1get-mouse-or-tablet-values0))
	       (setq mouse-x (force-into-range (mouse-window-x menu-window)
					       slider-left right))

	       (setq float-position
		     (+ min (* (^ (// (float (- mouse-x slider-left)) slider-width) exponent)
			       (- max min))))
	       (setq value float-position) 
	       (when (not float?) (setq value (round value)))
	       (send self :slider-draw)
		    while (not (zerop tv:mouse-buttons))
		      )))
	  ((eq mouse-button #\mouse-m)
	   (setq value (force-into-range (+ gt:value (if (< gt:value float-position) incr-value (- incr-value)))
					 min max))
	   (when (not float?) (setq value (round value))))
	  ((eq mouse-button #\mouse-r)
	   (let ((new-val (if (eq display-mode :percentage)
			      (tv:choose-number :max-value 100. :width gt:*keypad-width*
						:allow-floatp float? :height gt:*keypad-height* :zoom nil :percent t)
			      (tv:choose-number :width gt:*keypad-width*
						:allow-floatp float? :height gt:*keypad-height* :zoom nil))))
	     (when new-val
	       (if (eq display-mode :percentage)
		   (setq value (// new-val 100.0))
		   (setq value new-val))
	       (setq value (force-into-possible-range value min max))
	       (when (not float?) (setq value (round value)))
	       (send self :slider-draw)))))
    (send self :update-database-from-value)
    (send self :slider-draw))
  )


;;----------------------------------------------------------------------------------------
(defflavor 1color-box-menu-item0 ((old-values)) (base-menu-item)
  (:settable-instance-variables)
  (:default-init-plist :select-method :color-choose :drawing-method
		       :color-box-draw 
		       :value  (color:make-standard-color :rgb '(1 1 1))
		       :borders (make-border :use-border? t :border-width 2
					     :border-color *white*)
		       :documentation
		       "L: Select a color from Palette.    M,R:  Select a color with sliders."
		       ))

(defmethod 1(:default-b&w-setup0 1color-box-menu-item :after)0 (plist)
  (when (not (get plist :width))
    (setq width 200))
  (when (not (get plist :borders))
    (setq borders nil)))

2;; just vertically centered, for now
0(defmethod 1(:draw-centered-string base-menu-item)0 (string fnt alu)
  (multiple-value-bind (xoff yoff)
      (send self :offsets)
    (let* ((font (si:get-font si:*b&w-screen* nil fnt))
	   (font-height (font-raster-height font))
	   (text-y-offset (- (+ (if (plusp (- height font-height))
				 (1+ (// (- height font-height) 2))
				 0)))))
      (send menu-window :draw-string string
	    (+ item-left xoff) (+ item-top  height yoff text-y-offset)
	    (+ item-left xoff 200) (+ item-top  height yoff text-y-offset)
	    nil cptfontcc alu))))

(defmethod1 (:color-box-draw0 1base-menu-item)0 ()
  (if (eq (send menu-window :screen) tv:main-screen)
      (send self :draw-boxed-string  (send value :rgb-percentage-string)
	    font background-color
	    boxed-string-color)
      (multiple-value-bind (xoff yoff)
	  (send self :offsets)
	(cond (value
	       (send menu-window :window-alu value alu)
	       (send menu-window :draw-rectangle width height
		     (+ xoff item-left) (+ yoff item-top) alu)
	       (when (and (not (legal-color? value *illegal-color-warning*))
			  (> height 12) (> width 150))
		 (send self :draw-centered-string (format nil "  ----~a Illegal Color --" *illegal-color-warning*)
		       cptfontcc 24bit-xor)))
	      (t (send self :andca) (send self :draw-center-line (- width 8) 2)))))
  (send self :draw-border)
  )

(defmethod 1(:color-list-draw base-menu-item)0 ()
  (multiple-value-bind (xoff yoff)
      (send self :offsets)
    (send self :update-value-from-database)
    (when value
      (loop for i in value
	    with dwidth = (// width (float (length value)))
	    for x from (1+ item-left) by dwidth
	    do
	(when i
	  (setq alu (send menu-window :window-alu i alu))
	  (send menu-window :draw-rectangle (ceiling dwidth) height
		(1- (floor (+ xoff x))) (floor (+ yoff item-top)) alu))))
    (send self :draw-border)
    ))

;;----------------------------------------------------------------------------------------
(defflavor1 text-menu-item0 () (base-menu-item)
  (:default-init-plist :select-method :text-choose :drawing-method :text-draw
		       :documentation "Select a text string"))

(defmethod 1(:default-b&w-setup0 1text-menu-item :after)0 (plist)
  (when (not (get plist :width))
    (setq width 200)))

(defconst1 *last-string*0 "")

(defmethod 1(:text-choose0 1base-menu-item)0 (&rest ignore)
  (setq *last-string* value)
  (setq *last-string*
	(tv:pop-up-readline :prompt "Enter: "
			    :label nil
			    :size '(400 44)
			    :echo-style fonts:cptfont
			    :zoom nil
			    :initial-value value))
  (setq value *last-string*)
  (send self :update-database-from-value)
  (send self :draw-item))

(defmethod1 (:draw0-1text base-menu-item)0 (string) 
  (send self :draw-boxed-string string font background-color boxed-string-color))

(defmethod1 (:text-draw base-menu-item)0 () 
  (send self :draw-boxed-string (if (stringp value)
				    value
				    (or (and (instancep value)
					     (send value :send-if-handles :name))
					(format nil "~a" (or value ""))))
	font background-color boxed-string-color))
;;----------------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------------
(defflavor1 object0-1holder-menu-item0 ((selected-p)(show-activity? nil)) (base-menu-item)
  (:settable-instance-variables)
  (:default-init-plist :drawing-method :object-draw))

(defmethod 1(:object-draw gt:object0-1holder-menu-item)0 ()
  (send self :draw-background)
  (when value
    (send self :update-value-from-database)
    (let ((object-value
	    (if (symbolp value)
		(gt:find-object value)
		value)))
      (send self :draw-text
	    (if (instancep object-value)
		(send object-value :name)
		(if (and (stringp object-value) (find-indirect-spec object-value))
		    (send (find-indirect-spec object-value) :database-name)
		    (or object-value
			(if (> gt:width 50)
			    "      ----"
			    " ----")))))
      (when (and object-value (neq object-value :none) (send self :selected-p))
	(send self :xor))
      (when (and show-activity?
		 (instancep object-value)
		 (memq (send object-value :send-if-handles :active) '(nil :no)))
	(send self :draw-center-line))
      )))

(defmethod 1(:library-object-draw gt:object0-1holder-menu-item)0 ()
  (send self :object-draw)
  (when (eq (eval (first random-information)) value)
    (setq alu (send menu-window :window-alu background-color alu))
    (multiple-value-bind (x1 y1 x2 y2)
	(send self :absolute-edges)
      (setq x2 (- x2 4))
      (send menu-window :draw-triangle (- x2 6) (+ y1 2) (- x2 -1) (+ y1 6) (- x2 6) (+ y1 10)
	    tv:alu-seta))

    ))
;;----------------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------------
(defflavor1 lisp-menu-item0 () (base-menu-item)
  (:default-init-plist :select-method :lisp-choose :drawing-method :lisp-draw
		       :documentation "Select a Lisp Form"))

(defmethod 1(:lisp-choose0 1base-menu-item)0 (&rest ignore)
  (setq value
	(read-from-string
	  (tv:pop-up-readline :prompt "Enter: "
			      :label nil
			      :size '(400 44)
			      :echo-style fonts:tvfont
			      :zoom nil
			      :initial-value (format nil "~s" value))))
  (send self :update-database-from-value)
  (send self :draw-item))

(defmethod1 (:lisp-draw base-menu-item)0 () 
  (send self :draw-boxed-string  (if (stringp value) value (format nil "~s" value))
	font background-color boxed-string-color))
;;----------------------------------------------------------------------------------------
;; This flavor of menu item is used 
(defvar 1*hierarchy-warp-color*0 (color:make-standard-color :rgb '(.5 0 0)))
(defflavor 1hierarchy-warp-menu-item0 ((kill-menu-item-list) (spawn-menu-item-list)) (command-menu-item)
  (:default-init-plist :select-method :hierarchy-warp-choose)
  :settable-instance-variables)

(defmethod 1(:hierarchy-warp-choose hierarchy-warp-menu-item)0 (&rest ignore)
  (tv:prepare-sheet (menu-window)
    (genocide kill-menu-item-list menu-window)
    (loop for i in spawn-menu-item-list
	  do
      (send i :expose-item))
    ))

(defmethod 1(:hierarchy-warp-restore hierarchy-warp-menu-item)0 (&rest ignore)
  (tv:prepare-sheet (menu-window)
    (genocide spawn-menu-item-list menu-window)
    (loop for i in kill-menu-item-list
	  do
      (send i :expose-item))))


;;----------------------------------------------------------------------------------------
;; this can have any number of states, each with its own finite set of values.
;; for example, consider a "primary color" item whose values could be :red, :green or :blue.
;; or for example, consider a instrument type item which could be :flute, :oboe, :piano, ...
;; When selected, the children can change (for example, all the parameters of :piano can appear).
;; How is this handled?  Send all children a :check-visibility message.  They consult their parent or database
;; and decide if they should be visible or not.  If not they undraw.  Then send them all a 
;; :update-visibility and they draw if appropriate.  So really children are just a group of
;; things to be notified in case of a change.  First you notify in terms of undrawing.  Second
;; in terms of drawing.

(defflavor1 item-list-menu-item0 ((item-list) (flat-item-list) (item-list-label) (item-list-group))
      (base-menu-item)
  (:default-init-plist :select-method :item-list-choose :drawing-method :item-list-draw
		       :documentation "L: Choose value from menu.    M,R: Cycle through possible values."
		       :background-color *menu-item-pink*
		       :boxed-string-color *white*)
  (:settable-instance-variables))

(defmethod1 (:ensure-flat-item-list item-list-menu-item :after)0 ()
  (when (not flat-item-list)
    (setq flat-item-list
	  (loop for sublist in (send self :Real-item-list)
		append sublist))))

(defmethod 1(:default-b&w-setup0 1item-list-menu-item :after)0 (plist)
  (when (not (get plist :width))
    (setq width 100)))

(defmethod 1(:item-list-draw item-list-menu-item)0 ()
  (send self :ensure-flat-item-list)
  (or 
    (loop for item in flat-item-list
	  do
      (when (member value item)
	(return (send self :draw-boxed-string (car item) font
		      background-color boxed-string-color))))
    (send self :draw-boxed-string "None" font
	  background-color boxed-string-color)))

(defmethod1 (:real-item-list item-list-menu-item)0 ()
  (if (listp item-list) item-list (eval item-list)))


(defmethod 1(:item-list-choose item-list-menu-item)0 (mbuttons &rest ignore)
  (send self :ensure-flat-item-list)
  (cond ((eq mbuttons #\mouse-l)
	 (let ((new-val (call-menu (send menu-window :screen)
				   (or item-list-label "Choose One")
				   (send self :real-item-list)
				   nil nil self)))
	   (when (neq new-val :abort)
	     (with-group-realigned self
	       (setq value new-val)
	       (send self :update-database-from-value)
	       (send self :draw-item)
	       (send self :expose-possible-children)
	       ))))
	(t
	 (let* ((il flat-item-list)
		(pseudo-value (if value value :really-nil))
		(position (find-position-in-list-equal
			    pseudo-value
			    (if (listp (car il))
				(loop for i in il
				      collect (third i))
				il))))
	   (with-group-realigned self
	     (when position
	       (cond ((eq mbuttons #\mouse-m)
		      (incf position))
		     ((eq mbuttons #\mouse-r)
		      (decf position))
		     ((eq mbuttons #\shift-mouse-m)
		      (setq position 0))
		     ((eq mbuttons #\shift-mouse-r)
		      (setq position (1- (length il)))))
	       (setq value (if (listp (car il))
			       (third (nth (mod position (length il)) il))
			       (nth (mod position (length il)) il)))
	       (send self :update-database-from-value)
	       (send self :draw-item)
	       (send self :expose-possible-children)))))))

;;---------------------------------------------------------------------------------
(defflavor1 name-menu-item0 ((allow-frame-numbers t)) (base-menu-item)
  (:default-init-plist :select-method :choose-name :drawing-method :text-draw
		       :value "foo"
		       :documentation "Select a name")
;  (:default-init-plist :background-color 1*name-menu-item-color*0 :boxed-string-color *black*)
  (:settable-instance-variables))

(defmethod 1(:choose-name name-menu-item)0 (mouse-button &rest ignore)
  (cond ((eq mouse-button #/mouse-l)
	 (send self :text-choose))
	(t (when value 
	     (loop with first = t
		   for inc = (if (eql mouse-button #\mouse-r) -1 1)
		   do (progn
			(setq value (increment-frame-string value inc))
			(send self :text-draw)
			(when first
			  (process-sleep 5)
			  (setq first nil)))
		   while (not (zerop (tv:mouse-buttons))))
	     (send self :update-database-from-value)))))

;;-------------------------------------------------------------------------------------

(defflavor1 project-menu-item0 ((directory-mode? nil) (object-type nil)) (item-list-menu-item)
  (:default-init-plist :select-method :project-choose :drawing-method :project-draw
		       :background-color *40%-gray* :boxed-string-color *white* :value ""
		       :documentation "L: Select a Project.  M,R Cycle through projects.   sh-L: List Project   sh-R Delete this project from the list.")
  (:default-init-plist :background-color 1*file-name-color*0 :boxed-string-color *black*)
  (:settable-instance-variables))

(defmethod 1(:project-draw0 1project-menu-item0) ()
  (if (stringp value)
      (send self :text-draw)
      (send self :draw-boxed-string (send value :string-for-printing)
	    font background-color boxed-string-color t)))

(defun 1project-menu-item0 (&rest plist)
  (lexpr-funcall #'make-item 'project-menu-item plist))

(defun 1define-new-project0 ()
  (tv:choose-variable-values
    `((*default-project* "Project Name" :string)
      (*default-project-directory* "Project Directory" :pathname)))

  (setq *default-project-directory* (fs:parse-pathname *default-project-directory*))
  (setq *default-project-directory* (send *default-project-directory* :new-name nil))
  (setq *default-project-directory* (send *default-project-directory* :new-type nil))
  (setq *default-project-directory* (send *default-project-directory* :new-canonical-type nil))
  (setq *default-project-directory* (send *default-project-directory* :new-version nil))

  (condition-case (error)
       (probef (fs:parse-pathname *default-project-directory*))
     (fs:directory-not-found
       (let ((choice
	       (more-menu-choose `((,(format nil "Create ~a for project" *default-project-directory*) :value :create
				    :font cptfontcc)
				   ("Abort" :value nil :font cptfontcc))
				 1"Directory doesn't exist"0)))
	 (when (not choice) (throw :abort-it nil))
	 (fs:create-directories-recursively *default-project-directory*))))
  (create-project-directories *default-project-directory*)

  (setq *default-project* (make-project *default-project*))
  (consider-new-project *default-project* *default-project-directory*)
  (values *default-project* *default-project-directory*))

(defun 1consider-new-project0 (new-project new-project-directory &optional (query-to-create-directory? t))
  (when (and new-project new-project-directory)

2    ;; insure directory exists
0    (condition-case (error)
	 (probef (fs:parse-pathname new-project-directory))
       (fs:directory-not-found
	 (let ((choice
		 (if query-to-create-directory?
		     (more-menu-choose `((,(format nil "Create ~a and superiors" new-project-directory)
					  :value :create
					  :font cptfontcc)
					 ("Abort" :value nil :font cptfontcc))
				       1"Directory doesn't exist"0)
		     t)))
	   (when (not choice) (throw :abort-it nil))
	   (fs:create-directories-recursively (fs:parse-pathname new-project-directory)))))

    (setq *default-project* new-project
	  *default-project-directory* new-project-directory)
    (cl:pushnew (list (send *default-project* :project-name) *default-project-directory* *default-project*)
		(send *projects* :database-list) :test #'equal)
    (send *projects* :set-database-list
	  (sort (send *projects* :database-list)
		#'(lambda (a b) (string-lessp (car a) (car b)))))))

(defvar 1*allow-directories*0 nil)
(defun 1choose-project-menu0 ()
  (gt:more-menu-choose
    (append `((2"Create a new Project"0 :value :new-project
	       :font fonts:tvfonti
	       :documentation "Specify an unlisted directory")
	      ,(if 1*allow-directories*
0		   '(2"Specify0 2a Directory"0 :value :new-directory
		     :font fonts:tvfonti
		     :documentation "Specify an unlisted directory")))
	    (loop for i in (send *projects* :database-list)
		  collect (list (car i) :value i :font cptfontcc)))
    1"0    1Choose a0 1Project0   1"0))

(defmethod 1(choose-project-from-defaults project-menu-item)0 ()
  (setq fs:*default-pathname-defaults* nil)
  (let ((val (choose-project-menu)))
    (when val
      (cond ((eq val :new-project)
	     (setq directory-mode? nil)
	     (setq label "Project")
	     (define-new-project))
	    ((eq val :new-directory)
	     (setq directory-mode? t)
	     (setq label "Dir:")
	     (choose-directory-from-defaults))
	    (t
	     (setq directory-mode? nil)
	     (setq label "Project")
	     (third val))))))

(defmethod 1(:project-choose project-menu-item)0 (buttons mx my device)
  (cond ((eq buttons #/mouse-l)
	 (with-item-xored-in-style self :red-busy-item
	   (let ((nval (choose-project-from-defaults self)))
	     (when nval
	       (setq value nval)
	       (send self :update-database-from-value)
	       (send self :draw-item)))))))



;;-------------------------------------------------------------------------------------

;;---------------------------------------------------------------------------------
2;; Note that this is different than PATHNAME-MENU-ITEM.  This is for just the file
;; part of the pathname.  This is required to be linked with a DIRECTORY-MENU-ITEM.
;; EDIT-DIRECTORY? specifies whether or not the directory portion can be edited
;; in the POP-UP-READLINE.
0(defflavor 1file-menu-item0 ((force-pathname t) (pathname-type :text)
			   (directory-menu-item-name) (edit-directory?)) (name-menu-item)
  (:default-init-plist :select-method :file-choose :drawing-method :text-draw
		       :value "foo" ;:background-color ;1*name-menu-item-color*
0;		       :boxed-string-color *black*
		       )
  (:settable-instance-variables))

(defmethod 1(:documentation file-menu-item)0 ()
  (if allow-frame-numbers
      "L: Select Filename.     M,R: Increment or Decrement Name.     sh-L: Select full Pathname.  sh-M,R Accelerate Incr or Decr Name."
      "L: Select a Filename.     sh-L: Select a full Pathname"))

(defmethod 1(:update-database-from-value0 1file-menu-item)0 ()
  (when
    (not (catch-error
	   (progn
	     (when database
	       (let* ((db-value (send database :get-value)))
		 (send database :set-value (send (fs:merge-pathnames db-value) :new-name value))))
	     t)
	   nil))
    (format t "~%Error Parsing Pathname: ~a.  Change directory first " value)))
    

(defmethod1 (:update-value-from-database file-menu-item)0 (&rest ignore)
  (catch-error
    (when database
      (let* ((db-value (send database :get-value)))
	(setq value (send (fs:parse-pathname db-value) :name))))))

(defmethod 1(:file-choose file-menu-item)0 (mouse-button &rest ignore)
  (let* ((directory-menu-item (send menu-window :get-item directory-menu-item-name))
	 (directory (if directory-menu-item
			(fs:parse-pathname (send directory-menu-item :value))
			value))
	 (pathname (fs:merge-pathnames directory value)))
    (cond ((or (not allow-frame-numbers)
	       (eql mouse-button #\mouse-l)
	       (eql mouse-button #\sh-mouse-l))
	   (cond ((or (eql mouse-button #\sh-mouse-l) edit-directory?)
		  (let ((new (pop-up-read-pathname pathname :zoom nil :type :image)))
		    (when new
		      (setq new (send (send new :new-type nil) :new-version nil))
		      (setq value (send new :name))
		      (send self :update-database-from-value)
		      (let ((new-dir (send (send (send (send new :new-name nil) :new-type nil) :new-version nil)
					   :string-for-printing)))
			(consider-new-directory new-dir)
			(when directory-menu-item
			  (send directory-menu-item :set-value new-dir)
			  (send directory-menu-item :update-database-from-value)
			  (send directory-menu-item :draw-item))))))
		 (t (let ((new (tv:pop-up-readline :prompt "Enter: "
						   :label nil
						   :size '(400 44)
						   :echo-style fonts:cptfont
						   :zoom nil
						   :initial-value value)))
		      (when new (setq value new)))))
	   (send self :update-database-from-value)
	   (send self :draw-item))
	  (value 
	   (loop with first = t
		 for inc = (if (or (eql mouse-button #\mouse-r)
				   (eql mouse-button #\sh-mouse-r))
			       -1 1)
		 do (progn
		      (if (tv:key-state :shift) (setq inc (* inc 10)))
		      (setq value  (increment-frame-string value inc))
		      (send self :update-database-from-value)
		      (send self :draw-item)
		      (when first
			(process-sleep 5)
			(setq first nil)))
		 while (not (zerop (tv:mouse-buttons))))
	   (send self :update-database-from-value)))))


;;---------------------------------------------------------------------------------
(defflavor1 pathname-menu-item0 ((allow-frame-numbers)  (force-pathname)
			       (pathname-type :text)) (base-menu-item)
  (:default-init-plist :select-method :pathname-choose :drawing-method :pathname-draw
		       :value "local:>foo"
		       :background-color 1*file-name-color*0 :boxed-string-color *black*
		       :documentation "Select a pathname")
  (:settable-instance-variables))

(defmethod 1(:default-b&w-setup pathname-menu-item :after)0 (plist)
  (when (not (get plist :width))
    (setq width 200))
  (when (not (get plist :force-pathname))
    (setq force-pathname t))
  (when (not (get plist :allow-frame-numbers))
    (setq allow-frame-numbers t)))

(defmethod 1(:pathname-draw0 1base-menu-item)0 ()
  (if (stringp value)
      (send self :text-draw)
      (send self :draw-boxed-string (send value :string-for-printing)
	    font background-color boxed-string-color t)))

(defmethod 1(:pathname-choose0 1pathname-menu-item)0 (mouse-button &rest ignore)
  (cond ((or (not allow-frame-numbers)
	     (eql mouse-button #\mouse-l))
	 (setq value
	       (if force-pathname
		   (pop-up-read-pathname value :zoom nil :type :image)
		   (tv:pop-up-readline :prompt "Enter: "
				       :label nil
				       :size '(400 44)
				       :echo-style fonts:cptfont
				       :zoom nil
				       :initial-value value)))
	 (send self :update-database-from-value)
	 (send self :draw-item))
	(value 
	 (loop with first = t
	       with pathname = (fs:parse-pathname value)
	       with new-value = (if force-pathname (send pathname :name) value)
	       for inc = (if (eql mouse-button #\mouse-r) -1 1)
	       do (progn
		    (setq new-value (increment-frame-string new-value inc))
		    (when force-pathname
		      (setq pathname (send pathname :new-name new-value))
		      (setq value (send pathname :string-for-printing)))
		    (when (not force-pathname) (setq value new-value))
		    (send self :pathname-draw)
		    (when first
		      (process-sleep 5)
		      (setq first nil)))
	       while (not (zerop (tv:mouse-buttons))))
	 (send self :update-database-from-value))))

;;--------------------------------------------------------------------------------------
(defvar 1*default-directories*0 nil)
(defvar 1*default-directory*0 "sys:color;graphics-toolkit;")

(defun 1consider-new-directory0 (new-dir)
  (setq *default-directory* new-dir)
  (cl:pushnew *default-directory* *default-directories* :test #'equal)
  (setq *default-directories*
	(sort 
	  (loop for dir in *default-directories*
		collect 
		  (if (stringp dir)
		      dir
		      (send dir :string-for-printing)))
	  #'(lambda (a b) (string-lessp a b)))))

(defun 1choose-directory-from-defaults0 (&optional initial-value)
  (when (not *default-directories*) 
    (setq *default-directories* (list (fs:user-homedir))))
  
  (let ((val (gt:more-menu-choose (cons '(1"2Specify another Directory1"0 :value :new-directory
					  :font fonts:tvfonti
					  :documentation "Specify an unlisted directory")
					(loop for i in *default-directories*
					      collect (list i :value i :font cptfontcc)))
				  1"0    1Choose a directory0    1"0))
	(fs:*default-pathname-defaults* nil)
	new-dir)
    (when val
      (cond ((eq val :new-directory)
	     (setq new-dir
		   (pop-up-read-pathname (or initial-value *default-directory*) :zoom nil :choose-directory? t
					 :size '(400 44) :label nil))
	     (when new-dir

2	       ;; insure directory exists
0	       (condition-case (error)
		    (probef new-dir)
		  (fs:directory-not-found
		    (let ((choice
			    (more-menu-choose `((,(format nil "Create ~a and superiors" new-dir) :value :create
						 :font cptfontcc)
						("Abort" :value nil :font cptfontcc))
					      1"Directory doesn't exist"0)))
		      (when (not choice) (throw :abort-it nil))
		      (fs:create-directories-recursively new-dir))))

	       (setq new-dir (send new-dir :string-for-printing))
	       (consider-new-directory new-dir)
	       new-dir))
	    (t val)))))

(defflavor1 directory-menu-item0 () (item-list-menu-item)
  (:default-init-plist :select-method :directory-choose :drawing-method :pathname-draw
		       :value "local:>foo"
		       :documentation "L: Select a Directory.  M,R Cycle through directories.   sh-L: List Directory   sh-R Delete this directory from the list.")
  (:default-init-plist :background-color 1*file-name-color*0 :boxed-string-color *black*)
  (:settable-instance-variables))

(defun 1legal-file-name-p0 (name)
  (catch-error
    (progn
      (fs:parse-pathname name)
      t) nil))

(defmethod 1(:update-database-from-value0 1directory-menu-item)0 ()
  (when
    (not (catch-error
	   (progn
	     (when database
	       (let* ((db-value (fs:parse-pathname (send database :get-value))))
		 (send database :set-value (fs:merge-pathnames value (send db-value :name)))))
	     t)
	   nil))
    (format t "~%Error Parsing Pathname: ~a" (send database :get-value))
    (send database :set-value (fs:merge-pathnames (fs:parse-pathname "local:>foo") value))))

2;; database value is a pathname.  extract directory part.
0(defmethod1 (:update-value-from-database directory-menu-item)0 (&rest ignore)
  (catch-error
    (when database
      (let* ((db-value (send database :get-value)))
	(setq value (send (send (send (send (fs:parse-pathname db-value) :new-name nil)
				      :new-version nil) :new-type nil)
			  :string-for-printing))))
    nil))

(defmethod 1(:directory-choose directory-menu-item)0 (buttons mx my device)
  (setq item-list *default-directories*)
  (cond ((eq buttons #/mouse-l)
	 (with-item-xored-in-style self :red-busy-item
	   (let ((nval (choose-directory-from-defaults value)))
	     (when nval
	       (setq value nval)
	       (send self :update-database-from-value)
	       (send self :draw-item)))))
	((eq buttons #/sh-mouse-r)
	 (setq *default-directories* (remove value *default-directories*))
	 (send self :item-list-choose #/mouse-m mx my device))
	((eq buttons #/sh-mouse-l)
	 (send menu-window :expose-background-window)
	 (with-item-xored self
	   (loop for i in (fs:directory-list value) do (print (car i)))))
	(t (send self :item-list-choose buttons mx my device))))


1;;;-------------------------------------------------------------------------------------------------
;;;-------------------------------------------------------------------------------------------------


0(defun 1genocide0 (group window)
  (loop for node in group
	do
    (when (and node (send node :exposed-p))
      (send node :deexpose-item)
      (genocide (send node :children) window))))

(defflavor 1multiple-select-menu-item
0	((select-value t) (deselect-value nil) (string "")
	 (select-color toggle-on-color) (deselect-color toggle-off-color)
	 (deselect-boxed-string-color *black*)
	 (select-font fonts:cptfontb) (selection-arrow nil)	; can be :up, :down, nil
	 (selection-style :highlight))		;2can also be 1:BOLDIFY0, 1:RADIO-BUTTONS, :X-MARK
0	(base-menu-item)
  (:settable-instance-variables)
  (:default-init-plist :drawing-method :selected-draw
		       :value :deselected
		       :boxed-string-color *black*
		       :documentation "Click here to toggle this option"
		       :select-method :multiple-select))


(defmethod1 (:init multiple-select-menu-item :after)0 (&rest ignore)
  (when (eq (send menu-window :superior) tv:main-screen)
    (setq select-color *white* boxed-string-color *black*
	  deselect-color *black*
	  deselect-boxed-string-color *white*)))

(defmethod 1(:default-b&w-setup multiple-select-menu-item :after)0 (plist)
  (when (and (not (get plist :selection-style))
	     (not (string-equal boxed-string "")))
    (setq selection-style :boldify))
  (when (and (not (get plist :width))
	     (or (eq selection-style :radio-buttons)
		 (eq selection-style :x-mark)))
    (setq width 15))
  (when (and (not (get plist :shadow-parameters)) (eq selection-style :x-mark))
    (setq shadow-parameters *default-b&w-shadow*)))

(defmethod 1(:selected-p multiple-select-menu-item)0 ()
  (eq value :selected))

(defmethod 1(:set-selected-p multiple-select-menu-item)0 (val)
  (setq value (if val :selected :deselected)))

(defmethod1 (:used-now-p multiple-select-menu-item)0 ()
  (and (send self :selected-p) exposed-p))

(defmethod 1(:translated-value multiple-select-menu-item)0 ()
  (if (eq value :selected) select-value deselect-value))

(defmethod 1(:update-database-from-value multiple-select-menu-item)0 ()
  (when database
    (send database :set-value (send self :translated-value))))

(defmethod1 (:update-value-from-database multiple-select-menu-item)0 (&rest ignore)
  (when database
    (let ((db-value (send database :get-value)))
      (if (eq db-value select-value)
	  (setq value :selected)
	  (setq value :deselected)))))

(defmethod 1(:expose-item multiple-select-menu-item)0 ()
  (when (and (or (null expose-test)
		 (cond ((instancep expose-test)
			(send expose-test :test-exposure self))
		       ((functionp expose-test)
			(funcall expose-test self))
		       (t (send self expose-test))))
	     (or (not (instancep group)) (not (send group :clip-sub-items?)) (send self :inside-group?)))
    (setq exposed-p t)
    (send (send self :superior) :add-item self)
    (send self :draw-item)
    (when (send self :selected-p)
      (loop for child in children
	    do
	(if child (send child :expose-item))))))

(defmethod 1(:compute-width multiple-select-menu-item)0 ()
  (let (w1 (w2 0))
    (scl:with-character-style (font menu-window)
      (setq w1 (+ 5 (send menu-window :compute-motion boxed-string))))
    (when (eq selection-style :boldify)
      (scl:with-character-style (select-font menu-window)
	(setq w2 (+ 5 (send menu-window :compute-motion boxed-string)))))
    (setq width (max w1 w2))
    ))

(defvar 1*use-selection-arrows-p*0 t)
(defmethod1 (:selected-draw multiple-select-menu-item)0 ()
  (if icon-type
      (send self :draw-icon
 	    (if (eq value :selected) select-color deselect-color)
	    boxed-string-color)
      (cond ((eq selection-style :highlight)
	     (send self :draw-boxed-string boxed-string font
		   (if (eq value :selected) select-color deselect-color)
		   (if (eq value :selected)
		       boxed-string-color
		       deselect-boxed-string-color)
		   nil 2;; dont try to clip string, it should fit.
0		   ))
	    ((eq selection-style :radio-buttons)
	     (let ((min-dimension (- (min (// width 2) (// height 2)) 1)) xoff yoff)
	       (multiple-value (xoff yoff)
		 (send self :offsets))
	       (send menu-window :draw-circle (+ xoff item-left (// width 2))
		     (+ yoff item-top (// height 2)) min-dimension
		     (send menu-window :window-alu select-color alu)
		     )
	       (when (eq value :selected)
		 (send menu-window :draw-filled-in-circle (+ xoff item-left (// width 2))
		       (+ yoff item-top (// height 2)) (- min-dimension 3)
		       (send menu-window :window-alu select-color alu)
		       ))))
	    ((eq selection-style :x-mark)
	     (send self :draw-with-alu (send menu-window :window-alu background-color alu))
	     (multiple-value-bind (xoff yoff)
		 (send self :offsets)
	       (setq alu (send menu-window :window-alu select-color alu))
	       (send self :draw-outline-with-alu alu 2)
	       (when (eq value :selected)
		 (send menu-window :draw-line (+ item-left xoff) (+ item-top yoff)
		       (+ item-left xoff width -1) (+ item-top yoff height -1) alu)
		 (send menu-window :draw-line (+ item-left xoff width -1) (+ item-top yoff)
		       (+ item-left xoff) (+ item-top yoff height -1) alu))))
	    ((eq selection-style :boldify)
	     (send self :draw-boxed-string boxed-string
		     (if (eq value :selected) select-font font)
		     (send self :erase-color) select-color
		     nil 2;; dont try to clip string, it should fit.
0		     ))))
  (when (and *use-selection-arrows-p* selection-arrow)
    (setq alu (send menu-window :window-alu select-color alu))
    (multiple-value-bind (x1 y1 x2 y2)
	(send self :absolute-edges)
      (cond ((and (eq selection-arrow :right) (eq value :selected))
	     (send menu-window :draw-rectangle 7 gt:height (- x2 7) y1 alu)
	     (send menu-window :draw-triangle (- x2 6) (+ y1 2) (- x2 -1) (+ y1 6) (- x2 6) (+ y1 10)
		   tv:alu-andca))
	    ((and (eq selection-arrow :down) (eq value :selected))
	     (send menu-window :draw-rectangle 10 gt:height (- x2 10) y1 alu)
	     (send menu-window :draw-triangle (- x2 8) (+ y1 4) (- x2 2) (+ y1 4) (- x2 5) (+ y1 10)
		   tv:alu-andca))))))


(defmethod1 (:multiple-select multiple-select-menu-item)0 (&rest ignore)
  (with-group-realigned self			
    (cond
2      ;not already selected, so select it
0      ((eq value :deselected)
       (setq value :selected)
       (loop for node in children
	     do (send node :expose-item)))
2      ;already selected, so deselect it
0      ((eq value :selected)
       (setq value :deselected)
       (send self :deexpose-children)))
    (send self :update-database-from-value)
    (send self :draw-item)))

;;----------------------------------------------------------------------------------------
;; value is :selected or :deselected.  These are translated via select-value and
;; deselect-value when talking to the database.  (
(defflavor 1selectable-menu-item0 ()
      (multiple-select-menu-item)
  (:settable-instance-variables)
  (:default-init-plist :select-method :standard-select :drawing-method :selected-draw
		       :select-color *cyan*  :deselect-color *menu-80%-gray*
		       :deselect-boxed-string-color *black*
		       :boxed-string-color *black*
		       :documentation "Click here to select this option"
		       ))

(defmethod 1(:deexpose-item-and-children base-menu-item)0 ()
  (when (send self :exposed-p)
    (send self :deexpose-item)
    (loop for i in children do
      (send i :deexpose-item-and-children))))


(defmethod1 (:standard-select selectable-menu-item)
0	   (&rest ignore)

  (with-group-realigned self
    (tv:prepare-sheet (menu-window)
2						;not already selected
0      (when (not (send self :selected-p))
    
2	;; select myself
0	(send self :set-selected-p t)
	(send self :update-database-from-value)

	(send self :draw-item)

						;2deselect all brothers
0	(loop for bro in brothers
	      do
	  (when (and (neq bro self) (send bro :selected-p))
	    (send bro :set-selected-p nil)
	    (send bro :draw-item)))

	(when 1t ;(not realign-on-select?)
2	  ;; deexpose all nephews and neices and their children
0	  (loop for bro in (send self :brothers)
		do
	    (when (neq bro self)
	      (loop for nephew in (send bro :children)
		    do
		(when nephew
		(if (or (neq select-parameter :smart-update)
			(not (member nephew children)))
		    (send nephew :deexpose-item-and-children))))))

	  (loop for node in children
		do (when (and node (if (eq select-parameter :smart-update)
				       (not (send node :exposed-p))
				       t))
		     (send node :expose-item))))))))

(defmethod 1(:draw-emboss-outline selectable-menu-item)0 ()
  (color:duplicate-color (if (send self :selected-p) select-color deselect-color) :rgb *emboss-color1*)
  (color:duplicate-color (if (send self :selected-p) select-color deselect-color) :rgb *emboss-color2*)
  (send *emboss-color1* :set-intensity (* 2 (send  *emboss-color1* :intensity)))
  (send *emboss-color2* :set-intensity (* .8 (send  *emboss-color2* :intensity)))
  (send *emboss-color1* :set-saturation 0)
  (send *emboss-color2* :set-saturation 0)
  (send self :draw-drop-shadow-outline  *emboss-color1* *emboss-color2* 2))

1;;;-------------------------------------------------------------------------------------------------
0(defvar 1*group-background-color*0 *black*)

;; Children of the group and components of the group are different things.
;; Children of the group exist within the groups parent's tree.
;; An item and its children are always in the same group.
;; Components of the group are invisible to everyone but the group and
;; exist in the groups tree structure in the same way that the group
;; exists in its groups tree structure.  
;; X-SCROLL and Y-SCROLL are used by the sub-items.  This items position
;; can stay the same and changing X-SCROLL and Y-SCROLL will change which
;; sub-items you see.
(defflavor1 group-menu-item0 ((x-scroll 0) (y-scroll 0) (item-list nil)
			    (alignment-parameters '(:vertical 0 0 2))
			    (exposed-items nil) 
			    (align-once?) (clip-sub-items? nil) (size :dynamic)	;can be :static
			    (all-items nil) (top-level-nodes)) (base-menu-item)	
  (:default-init-plist :drawing-method :dont-draw :select-method :ignore :mouse-sensitive nil
		       :background-color *group-background-color*)
  (:init-keywords :sub-item-spec :static-height :sub-item-defaults :declare-brothers :equalize-sub-item-width)
  (:settable-instance-variables))

2;; these changes to make nested groups work better.
0(defvar1 *draw-group-subitems*0 t)
(defmethod 1(:draw-item group-menu-item :0before1)0 ()
  (multiple-value-bind (xoff yoff)
      (send self :offsets)
    (let ((w (send self :total-width))
	  (h (send self :total-height)))
      (multiple-value-bind (x y)
	  (send self :position)
	(send menu-window :draw-rectangle w h (+ xoff x) (+ yoff y)
	      (send menu-window :window-alu (send self :background-color) alu)
	      )))))

(defmethod 1(:draw-item group-menu-item :after)0 ()
  (when *draw-group-subitems*
    (loop for i in item-list do
      (when (send i :exposed-p)
	(send i :draw-item))))
  (send self :draw-border)
  )

(defmethod 1(:undraw-from group-menu-item)0 (item)
  (when alignment-parameters
    (let ((start (loop for sub-list on item-list	;
		       when (eq (car sub-list) item) do (return (cdr sub-list)))))
    
      (loop for i in start		
	    do
	(when (send i :exposed-p)
	  (send i :deexpose-item))
	))))

(defmethod 1(:draw-from group-menu-item)0 (item)
  (when alignment-parameters
    (let ((start (loop for sub-list on item-list	;
		       when (eq (car sub-list) item) do (return (cdr sub-list)))))
    
      (loop for i in start		
	    do
	(when (and (send i :exposable) (not (send i :exposed-p)))
	  (send i :expose-item))
	)
      )))

(defmethod 1(:recursively-undraw-from group-menu-item)0 (undraw-from)
  (send self :undraw-from undraw-from)
  (when group
    (send group :recursively-undraw-from self)))

(defmethod 1(:recursively-draw-from group-menu-item)0 (draw-from)
  (send self :draw-from draw-from)
  (when group
    (send group :recursively-draw-from self)))

(defmethod 1(:draw-border group-menu-item)0 ()
  (send self :draw-border-internal t))

(defmethod 1(:add-item group-menu-item)0 (item)
  (when (not (member item exposed-items))
    (if exposed-items
	(setq exposed-items (push item exposed-items))
	(setq exposed-items (list item)))))

(defmethod 1(:remove-item0 1group-menu-item)0 (item)
  (setq exposed-items (delq item exposed-items)))

(defmethod 1(:align group-menu-item)0 (&optional alignment-test)
  (cond (alignment-parameters
	 (multiple-value-bind (x1 y1 x2 y2)
	     (align (first alignment-parameters)
		    (+ (send self :border-width) (second alignment-parameters)
		       (if (and label (eq (first alignment-parameters) :horizontal))
			   label-width 0))
		    (+ (send self :border-width) (third alignment-parameters)
		       (if (and (eq (first alignment-parameters) :vertical) label)
			   label-height 0))
		    (fourth alignment-parameters)
		    item-list
		    alignment-test
		    (or (fifth alignment-parameters) :end)
		    )
	   (when (eq size :dynamic)
	     (send self :set-width (- x2 x1 (* -2 (send self :border-width))))
	     (send self :set-height (- y2 y1 (* -2 (send self :border-width)))))))
	(item-list
	 (loop for i in item-list
	       with minx
	       with miny
	       with maxx
	       with maxy
	       finally (progn (send self :set-width (- maxx minx -1 (* -2 (send self :border-width))))
			      (send self :set-height (- maxy miny -1 (* -2 (send self :border-width)))))
	       do
	   (multiple-value-bind (x1 y1 x2 y2)
	       (send i :absolute-edges)
	     (setq minx (if (or (not minx) (< x1 minx)) x1 minx)
		   miny (if (or (not miny) (< y1 miny)) y1 miny)	
		   maxx (if (or (not maxx) (> x2 maxx)) x2 maxx)
		   maxy (if (or (not maxy) (> y2 maxy)) y2 maxy)))))))

2;; create groups sub-items
0(defmethod 1(:init group-menu-item :after)0 (plist)
  (if (not item-list)
      (setq item-list
	    (loop for sub-item in (get plist :sub-item-spec)
		  for sub-item-id = (first sub-item)
		  for sub-item-flavor = (second sub-item)
		  for new-plist = (append (get plist :sub-item-defaults)
					  (loop for property in (cddr sub-item) by #'cddr
						for plist-value in (cdddr sub-item) by #'cddr
						append `(,property ,plist-value)))
		  collect
		    (eval
		      `(create-menu-item ',sub-item-id ',sub-item-flavor ',menu-window :group ,self ,@new-plist))))
      (loop for i in item-list do (send i :set-group self)))
  (when (get plist :equalize-sub-item-width)
    (let ((max (loop for i in item-list
		     maximize (send i :width))))
      (loop for i in item-list
	    do
	(send i :set-width max))))

;  (when (get plist :static-height)
;    (send group :set-height (get plist :static-height))
;    (send self :set-size :static))

  (when (get plist :declare-brothers)
    (declare-brothers1 nil item-list))
  (when (not top-level-nodes)
    (setq top-level-nodes item-list))
  (loop for i in item-list do (send i :compute-size-if-needed))
  (send self :compute-size-if-needed)
  (send self :align)
  (when align-once? (setq alignment-parameters nil)))

(defmethod1 (:realign group-menu-item)0 ()

  ;2only align exposed items
0  (send self :align :exposable)

2  ;; recursively realign
0  (when (send self :group)
    (send (send self :group) :realign))
  )

(defmethod 1(:are-you-at? group-menu-item)0 (x y)
  (multiple-value-bind (ll tt rr bb)
      (send self :absolute-edges)
2    ;; when no alignment parameters, my width and height are irrelevant.
0    (let ((in-group? (and ( y tt) (< y bb) ( x ll) (< x rr))))
      (when (or (not alignment-parameters) (not mouse-sensitive) in-group?)
	(let ((ans
		(loop for i in exposed-items
		      for there? = (send i :are-you-at? x y)
		      when there? do (return there?))))
	  (or ans (and in-group? self)))))))

;(defwhopper 1(:are-you-at? group-menu-item)0 (x y)
;  (when mouse-sensitive
;    (continue-whopper x y)))

;(defmethod 1(:move-group group-menu-item)0 (&rest ignore)
;  (multiple-value-bind (nx ny)
;      (paint:mouse-specify-rect-fixed-size width height paint:mw)
;    (send self :deexpose-item)
;    (send self :set-total-position nx ny)
;    (send self :expose-item)))

(defmethod (1:expose-item0 1group-menu-item0) ()
2  ;; not quite right since you want a group to be partially visible, can't exclude the whole thing.
0  (when (and (or (not (instancep group)) (not (send group :clip-sub-items?)) (send self :inside-group?)))
    ;; need to recursively :REALIGN all the sub-groups as well as this group.
    (send self :realign) 

2    ;; do what expose needs to do
0    (setq exposed-p t)
    (send (send self :superior) :add-item self)

    (let ((*draw-group-subitems* nil))
      (send self :draw-item))

2    ;; all items in group must be in this group.
    ;; normally they will, but this allows an item to be in multiple groups
    ;; only one of which is exposed.
0    (loop for item in item-list
	  do
      (when item (send item :set-group self)))

    (loop for item in top-level-nodes
	  do
      (and item
	   (send item :exposable)
	   (send item :expose-item)))
    ))

1;;  Change0(d?)1 so groups do undraw their items always
2;; groups only undraw their label and extra-drawings
0(defmethod 1(:undraw-item group-menu-item)0 (&optional ignore undraw-group?)
  (ignore undraw-group?)
  (when extra-draw-method
    (send self extra-draw-method :undraw))

  (multiple-value-bind (xoff yoff)
      (send self :offsets)
    (let ((w (send self :total-width))
	  (h (send self :total-height)))
      (multiple-value-bind (x y)
	  (send self :position)
	(send menu-window :draw-rectangle w h (+ xoff x) (+ yoff y)
	    (send menu-window :window-alu (send self :erase-color) alu)
	    )))))
  
(defmethod1 (:deexpose-item group-menu-item)0 ()
  (setq exposed-p nil)
  (send (send self :superior) :remove-item self)
  (loop for node in item-list
	do
    (when (and node (send node :exposed-p))
      (send node :deexpose-item)
      (send node :deexpose-children)))
  (send self :undraw-item))


(defmethod 1(:border-width group-menu-item)0 ()
  (if borders
      (+ (if (send borders :use-border?) (send borders :border-width) 0)
	 (if (send borders :use-border2?) (send borders :border2-width) 0) 1)
      0))
;;;--------------------------------------------------------------------------------
;;;--------------------------------------------------------------------------------
;;; assoc list is like
;;   '(("Menu Name" item-name item-on-value item-off-value db db-type) ...)
(defflavor 1assoc-group-menu-item0 ((assoc-list) (direction :horizontal)
				  (selection-type :exclusive)
				  (selection-style :boldify)
				  (spacing 4) (items-select-method))
	   (group-menu-item)
  (:settable-instance-variables)
  (:default-init-plist :label-height :compute :height :compute
		       :alignment-parameters '(:horizontal 0 0 4)))

2;; No ordering works. Must draw/undraw whole group.
0(defmethod 1(:draw-from assoc-group-menu-item)0 (ignore)
  (when (and (send self :exposable) (not exposed-p))
    (send self :expose-item)))

(defmethod 1(:undraw-from assoc-group-menu-item)0 (ignore)
  (when exposed-p
    (send self :deexpose-item)))

(defmethod1 (:value assoc-group-menu-item)0 ()
  (cond ((eq selection-type :exclusive)
	 (loop for i in item-list
	       when (send i :selected-p) do (return (send i :select-value))))
	((eq selection-type :inclusive)
	 (loop for i in item-list
	       append (if (send i :selected-p)
			  (list (send i :select-value))
			  nil)))))

(defmethod1 (:set-value assoc-group-menu-item)0 (new-value)
  (cond ((eq selection-type :exclusive)
	 (loop for i in item-list
	       do
	   (if (eq (send i :select-value) new-value)
	       (send i :set-selected-p t)
	       (send i :set-selected-p nil))))
	((eq selection-type :inclusive)
	 (loop for i in item-list
	       do
	   (if (memq (send i :select-value) new-value)
	       (send i :set-selected-p t)	
	       (send i :set-selected-p nil))))))

(defmethod 1(:init assoc-group-menu-item :after)0 (ignore)
  (send self :set-value value)
  (when (eq selection-type :exclusive)
    (declare-brothers1 self item-list)))
1;;;-------------------------------------------------------------------------------------------------
;;;-------------------------------------------------------------------------------------------------

0(gt:defobject 1point0 ((y-value .5) (x-value 0.0))
  (gt:base-general-object-flavor)
  (:settable-instance-variables))

(defmethod1 (:print-self point)0 (stream &rest ignore)
  (format stream "<Point ~a,~a>" x-value y-value))

(defun1 point-x-lessp0 (point-1 point-2)
  (< (send point-1 :x-value) (send point-2 :x-value)))

;;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------

(defflavor 1sub-window-menu-item0 ((sub-window-flavor) (sub-window)) (base-menu-item)
  (:settable-instance-variables)
  (:default-init-plist :select-method :ignore :drawing-method :ignore :mouse-sensitive nil)
  (:init-keywords :window-defaults))

(defmethod1 (:init sub-window-menu-item)0 (plist)
  (let ((defaults (get plist :window-defaults)))
    (multiple-value-bind (x1 y1 x2 y2)
	(send self :absolute-edges)
      (setq sub-window
	    (eval `(tv:make-window ',sub-window-flavor :edges (list ,x1 ,y1 ,x2 ,y2) :superior ,menu-window
				   ,@defaults))))))

(defmethod 1(:expose-item sub-window-menu-item :after)0 ()
  (send sub-window :activate)
  (send sub-window :expose))

(defmethod 1(:deexpose-item sub-window-menu-item :after)0 ()
  (send sub-window :deactivate))

;;;----------------------------------------------------------------------------------
(defflavor 1scrolling-menu-item0 ((scroll-bar-position :top) (scrolling-group)) (base-menu-item)
  (:default-init-plist :select-method :scroll :drawing-method :command-draw)
  (:settable-instance-variables))

(defmethod 1(0:1scroll scrolling-menu-item)0 (&rest ignore)
  (cond ((and (eq scroll-bar-position :top)
	      (= (send scrolling-group :y-scroll) 0))
	 (beep))
	((and (eq scroll-bar-position :top)
	      ( (send scrolling-group :y-scroll) 0))
	 (send scrolling-group :deexpose-item)
	 (send scrolling-group :set-y-scroll (min 0 (+ (send scrolling-group :y-scroll)
						       (send scrolling-group :height)
						       )))
	 (send scrolling-group :expose-item))
	((eq scroll-bar-position :bottom)
	 (send scrolling-group :deexpose-item)
	 (send scrolling-group :set-y-scroll (- (send scrolling-group :y-scroll)
						(send scrolling-group :height)
						))
	 (send scrolling-group :expose-item))))

(defun 1make-scrolling-group0 (w h items &rest plist)
  (let ((sg
	  (lexpr-funcall #'create-menu-item nil 'group-menu-item *window* :item-list items
			 :height h :width w :size :static :alignment-parameters '(:vertical 0 0 2)
			 :clip-sub-items? t plist)))
    (group-menu-item
      (list  (scrolling-menu-item :scroll-bar-position :top 
				  :scrolling-group sg :boxed-string "Scroll Up" :font fonts:tvfontb)
	     sg
	     (scrolling-menu-item :scroll-bar-position :bottom 
				  :scrolling-group sg :boxed-string "Scroll Down" :font fonts:tvfontb))
      :alignment-parameters '(:vertical 0 0 4))))

(defmethod 1(:icon-draw base-menu-item)0 ()
  (send self :draw-icon background-color boxed-string-color))

(defun 1make-wide-choice-group0 (w h items &rest plist)
  (let ((sg
	  (lexpr-funcall #'create-menu-item nil 'group-menu-item *window* :item-list items
			 :alignment-parameters '(:vertical 0 0 2)
			  :width w :clip-sub-items? t plist)))
    (cond ((> (send sg :height) h)
	   (let ((ls
		   (loop for i in items
			 repeat (// (1+ (length items)) 2)
			 collect i))
		 (rs
		   (loop for i in (nthcdr (// (1+ (length items)) 2) items)
			 collect i)))
	     (send sg :set-height (- h 15))
	     (send sg :set-size :static)
	     (lexpr-funcall #'create-menu-item nil 'group-menu-item *window*
			    :alignment-parameters '(:horizontal 0 0 4) :item-list
			    (list
			      (spacer-menu-item :width 12)
			      (lexpr-funcall #'create-menu-item nil 'group-menu-item *window* :item-list ls
					     :alignment-parameters '(:vertical 0 0 2)
					     :width w plist)
			      (lexpr-funcall #'create-menu-item nil 'group-menu-item *window* :item-list rs
					     :alignment-parameters '(:vertical 0 0 2)
					     :width w plist)) plist)))
	  (t (lexpr-funcall #'create-menu-item nil 'group-menu-item *window*
			  :alignment-parameters '(:horizontal 0 0 4) :item-list
			  (list (spacer-menu-item :width 12) sg) plist)))))

(defun 1make-sidebar-scrolling-group0 (w h items &rest plist)
  (let ((sg
	  (lexpr-funcall #'create-menu-item nil 'group-menu-item *window* :item-list items
			 :alignment-parameters '(:vertical 0 0 2)
			  :width w :clip-sub-items? t plist)))
    (cond ((> (send sg :height) h)
	   (send sg :set-height (- h 15))
	   (send sg :set-size :static)
	   (lexpr-funcall #'create-menu-item nil 'group-menu-item *window*
			  :alignment-parameters '(:horizontal 0 0 4) :item-list
			  (list
			    (group-menu-item
			      (list (scrolling-menu-item :scroll-bar-position :bottom  :drawing-method :icon-draw
							 :icon-type :up-triangle :scrolling-group sg :width 12
							 :height 12 :boxed-string-color command-color
							 :background-color *80%-gray*)
				    (scrolling-menu-item :scroll-bar-position :top :drawing-method :icon-draw
							 :icon-type :down-triangle :scrolling-group sg :width 12
							 :height 12 :boxed-string-color command-color
							 :background-color *80%-gray*))
			      :background-color *80%-gray*)
			    sg) plist))
	  (t (lexpr-funcall #'create-menu-item nil 'group-menu-item *window*
			  :alignment-parameters '(:horizontal 0 0 4) :item-list
			  (list (spacer-menu-item :width 12) sg) plist)))))

(defun 1scrolling-menu-item0 (&rest plist)
  (lexpr-funcall #'make-item 'scrolling-menu-item plist))

;;;----------------------------------------------------------------------------------

(defvar 1*plist-defaults*0 nil)

(defun1 make-item0 (flavor &rest plist)
  (setq plist (append plist (or *plist-defaults* (get (locf plist) :plist-defaults))))
  (let ((item (lexpr-funcall #'make-instance flavor
			     :menu-window *window*
			     plist)))
    (when (send item :id)
      (setf (cl:gethash (send item :id) (send  (send item :superior) :msi-hash-table)) item))
    item))


;;;----------------------------------------------------------------------------------


(defflavor 1graph-menu-item0 ((graph-left 0.0) (graph-right 1.0)
			    (graph-top 0.0) (graph-bottom 1.0)
			    (graph-mode :literal) (margin-width 4))
	   (gt:base-menu-item)
  (:default-init-plist :background-color gt:*black* :boxed-string-color gt:*white*
		       :borders (make-border :use-border? t :border-width 1
						       :border-color *white*))
  (:settable-instance-variables))

(defmethod 1(:normalized-inside-position graph-menu-item)0 (mx my)
  (multiple-value-bind (left top right bottom)	
      (send self :absolute-edges)
    (values  (force-into-range (// (float (- mx (+ left margin-width)))
				   (- right left (* 2 margin-width))) 0.0 1.0)
	     (force-into-range (// (float (- my (+ top margin-width)))
				   (- bottom top (* 2 margin-width))) 0.0 1.0))))

(defmethod 1(:pixel-position->point-position graph-menu-item)0 (mx my)
  (if (eq graph-mode :normalized)
      (send self :normalized-inside-position mx my)
      (multiple-value-bind (nx ny)
	  (send self :normalized-inside-position mx my)
	(values
	  (+ graph-left (* nx (- graph-right graph-left)))
	  (+ graph-top (* ny (- graph-bottom graph-top)))))))

(defmethod 1(:point-position->pixel-position graph-menu-item)0 (px py)
  (if (eq graph-mode :normalized)
      (values
	(round (+ gt:item-left margin-width (* (- gt:width (* 2 margin-width)) px)))
	(round (+ gt:item-top margin-width (* (- gt:height (* 2 margin-width)) py))))
      (values
	(round (+ gt:item-left margin-width (* (- gt:width (* 2 margin-width))
				  (// (- px graph-left) (- graph-right graph-left)))))
	(round (+ gt:item-top margin-width (* (- gt:height (* 2 margin-width))
				 (// (- py graph-top) (- graph-bottom graph-top))))))))

;; If mode is :normalized, the points are normalized from 0.0 to 1.0 (which is the size of the
;; menu item.
;; If mode is :literal, the menu-item itself covers a part of the space and
;; may exceed the 0 to 1 range.
(defmethod1 (:draw-point-object graph-menu-item)
0	   (point &optional (draw-alu tv:alu-seta) (point-width 4) (point-height 4))
  (multiple-value-bind (x y)
      (send self :point-position->pixel-position (send point :x-value) (send point :y-value))
    (send gt:menu-window :draw-rectangle point-width point-height x y draw-alu)))

;(defmethod 1(:graph-draw graph-menu-item)0 ()
;  (send self :update-value-from-database)
;  (send self :draw-border)
;  (loop for point in (send gt:value :database-list)
;	for next-point in (cdr (send gt:value :database-list))
;	do
;    (send self :draw-point-object point)
;    (multiple-value-bind (x y)
;	(send self :point-position->pixel-position (send point :x-value) (send point :y-value))
;      (multiple-value-bind (x1 y1)
;	  (send self :point-position->pixel-position (send next-point :x-value) (send next-point :y-value))
;	(send gt:menu-window :draw-line x y x1 y1)))))

(defmethod 1(:graph-draw graph-menu-item)0 ()
  (send self :update-value-from-database)
  (send self :draw-border)
  (loop for point in (send gt:value :database-list)
	do
    (send self :draw-point-object point)))


(defmethod 1(:graph-select graph-menu-item)0 (mb mx my &rest ignore)
  (send self :update-value-from-database)
  (multiple-value-bind (fx fy)
      (send self :pixel-position->point-position mx my)
    (cond ((eq mb #\mouse-l)
	   (let ((p (make-instance 'point :x-value fx :y-value fy)))
	     (send gt:value :add-item-in-sort-position p #'point-x-lessp))))
    (send self :draw-item)))


;;----------------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------------

2;; Note that if a :group is specified, the new item will be put onto its
;; item-list and hash-table, not the window's. (via :superior)
;; CHANGE THIS SO THAT BOXED-STRING IS A SEPARATE ARGUMENT.  IT SHOULDN'T
;; BE SET TO THE LABEL.
0(defmacro1 make-label-menu-item
0	  (item label flavor 
	   item-left item-top item-width item-height
	   label-left label-top label-width label-height window &rest plist)
  `(let ((item-instance (make-instance ,flavor :boxed-string ,label 
				       :menu-window ,window :id ,item
				       :item-left ,item-left :item-top ,item-top
				       :width ,item-width  :height ,item-height
				       :label ,label :label-left ,label-left :label-top ,label-top
				       :label-width ,label-width
				       :label-height ,label-height
				       ,@plist)))
     (push ,item (send (send item-instance :superior) :all-items))
     (setf (cl:gethash ,item (send (send item-instance :superior) :msi-hash-table))
	   item-instance)))

2;; Note that if a :group is specified, the new item will be put onto its
;; item-list and hash-table, not the window's. (via :superior)
0(defmacro1 make-menu-item
0	  (item boxed-string flavor item-left item-top item-width item-height window &rest plist)
  `(let ((item-instance (make-instance ,flavor
				       :menu-window ,window :id ,item
				       :item-left ,item-left :item-top ,item-top
				       :boxed-string ,boxed-string
				       :width ,item-width  :height ,item-height
				       ,@plist)))
     (push ,item (send (send item-instance :superior) :all-items))
     (setf (cl:gethash ,item (send (send item-instance :superior) :msi-hash-table))
	   item-instance)))

(defun1 create-menu0-1item0 (item flavor window &rest plist)
  (setq plist (append plist (or *plist-defaults* (get (locf plist) :plist-defaults))))
  (let ((item-instance (lexpr-funcall #'make-instance flavor
				      :menu-window window :id item
				      plist)))
    (push item (send (send item-instance :menu-window) :all-items))
    (setf (cl:gethash item (send (send item-instance :menu-window) :msi-hash-table))
	  item-instance)))

(defun 1align-items0 (window direction start-x start-y spacing items
		    &optional alignment-test)
  (align direction start-x start-y spacing (send window :get-items items) alignment-test))

(defun 1align0 (direction start-x start-y space items
	      &optional alignment-test (align-from :end))
  (loop for i in items
	with x = start-x
	with y = start-y
	with x-max = start-x
	with y-max = start-y
	for items-x = (+ x (send i :alignment-x-off))
	for items-y = (+ y (send i :alignment-y-off))
	finally (return (values start-x start-y x-max y-max))
	for count from 0
	do
    (when (or (not alignment-test) (send i alignment-test))
      (send i :set-position items-x items-y)
      (if (eq direction :vertical)
	  (cond ((eq align-from :end)
		 (setq y (+ (send i :total-height) items-y space)))
		((eq align-from :start)
		 (setq y (+ items-y space))))
	  (cond ((eq align-from :end)
		 (setq x (+ (send i :total-width) items-x space)))
		((eq align-from :start)
		 (setq x (+ items-x space)))))
      (multiple-value-bind (total-x total-y)
	  (send i :position)
	(setq x-max (max x-max (+ total-x (send i :total-width))))
	(setq y-max (max y-max (+ total-y (send i :total-height))))
	))))

(defmacro 1with-items-aligned0 (direction spacing start-x start-y &rest item-defs)
  `(let ((items (loop for item-def in ',item-defs
		      collect (eval item-def))))
     (align ,direction ,start-x ,start-y ,spacing items)
     items))

(defun1 extract-value0 (column row group)
  (if (listp group)
      (nth row (nth column group))
      group))

(defun 1extract-plist-value0 (column row group)
  (if (and (listp group) (eq (car group) :item-list))
      (nth row (nth column (cdr group)))
      group))

;;;---------------------------------------------------------------------------------

(defun1 make-group0 (group-name group-members group-labels flavor 
		   vertical-space horizontal-space 
		   group-left group-top item-width item-height window
		   &rest plist)
  group-name
  (let ((items
	  (loop for column-group in group-members
		for column-number from 0
						; for displaced labels
		with displaced-label-p = (get (locf plist) :label)
		with label-width = (if displaced-label-p (get (locf plist) :label-width) 0)
		for x-position = (+ group-left (* column-number (+ item-width label-width
								   horizontal-space)))
		append
		  (loop for element in column-group
			for element-number from 0
			for y-position = (+ group-top (* element-number
							 (+ item-height vertical-space)))
			for new-plist = (loop for property in plist by #'cddr
					      for plist-value in (cdr plist) by #'cddr
					      append `(,property
						       ',(extract-plist-value column-number
									      element-number
									      plist-value)))
			collect
			  (eval
			    (if displaced-label-p
				`(make-label-menu-item
				   ',element 
				   ',(extract-value column-number element-number group-labels)
				   ',flavor (+ ,x-position ,label-width) ',y-position
				   ',item-width ',item-height ',x-position ',y-position
				   ',label-width ',item-height  ',window
				   ,@new-plist)
				`(make-menu-item 
				   ',element  ',(extract-value column-number element-number group-labels)
				   ',flavor  ',x-position ',y-position
				   ',item-width ',item-height ',window
				   ,@new-plist))
			    )))))
    items
;    (make-menu-item 'group-name (format nil "~a" group-name) 'group-menu-item group-left group-top 0 0
;		    window :item-list items)
    ))

(defun1 create-group0 (group-name window alignment-parameters group-left group-top group-plist
		     group-members flavor &rest plist)
  group-plist
  (labels ((extract-from-plist (index element)
	     (if (and (listp element) (eq (car element) :item-list))
		 (nth index (cdr element))
		 element)))
    (let ((items
	    (loop for element in group-members
		  for element-number from 0
		  for new-plist = (loop for property in plist by #'cddr
					for plist-value in (cdr plist) by #'cddr
					append `(,property
						 ',(extract-from-plist element-number
								       plist-value)))
		  collect
		    (eval
		      `(create-menu-item ',element ',flavor ',window ,@new-plist)))))
      (gt:create-menu-item group-name 'group-menu-item window :item-left group-left :item-top group-top
			   :alignment-parameters alignment-parameters :item-list items)
      )))


(defun1 declare-dependents0 (window dependee-list dependent-list)
  (loop with ht = (send window :msi-hash-table)
	for dependee in dependee-list
2	;; allow actual items themselves
0	for dependee-item = (or (cl:gethash dependee ht) dependee)
	do
    (send dependee-item :set-dependents
	  (loop for dependent in dependent-list
2		;; allow actual items themselves
0		for dependent-item = (or (cl:gethash dependent ht) dependent)
		collect dependent-item))))

(defun1 declare-brothers0 (window parent list)
  (let ((ht (send window :msi-hash-table)))
    (when parent (setq parent (cl:gethash parent ht)))
    (setq list (loop for l in list collect (cl:gethash l ht) into ans finally (return ans)))
    (declare-brothers1 parent list)))

(defmacro 1declare-parents10 (parent-list child)
  `(progn
     (loop for parent in ,parent-list
	   do
	   (if (send parent :children)
	       (send parent :set-children (append (send  parent :children) (list ,child)))
	       (send parent :set-children (list ,child))))))

(defun 1declare-parents0 (window parent-list child)
  (let ((ht (send window :msi-hash-table)))
    (setq child (cl:gethash child ht))
    (setq parent-list
	  (loop for l in parent-list collect (cl:gethash l ht) into ans finally (return ans)))
    (declare-parents1 parent-list child)))

(defmacro 1declare-children10 (parent children &optional (cget :children) (cset :set-children))
  `(progn
     (if (send ,parent ,cget)
	 (send ,parent ,cset (append (send  ,parent ,cget) ,children))
	 (send ,parent ,cset ,children))))

(defun 1declare-possible0-1children0 (window parent children)
  (let ((ht (send window :msi-hash-table)))
    (setq parent (cl:gethash parent ht))
    (setq children (loop for l in children
			 collect (cons (car l)
				       (loop for ll in (cdr l)
					     collect (cl:gethash ll ht)))))
    (send parent :set-possible-children
	  (append children (send parent :possible-children)))))

(defun 1declare-children0 (window parent children &optional (cget :children) (cset :set-children))
  (let ((ht (send window :msi-hash-table)))
    (setq parent (cl:gethash parent ht))
    (setq children
	  (loop for l in children collect (cl:gethash l ht) into ans finally (return ans)))
    (declare-children1 parent children cget cset)))

(defun1 declare-group0 (window parent item-list &optional (top-level-nodes item-list))
  (let ((ht (send window :msi-hash-table)))
    (when parent (setq parent (cl:gethash parent ht)))
    (setq item-list (loop for l in item-list collect (cl:gethash l ht) into ans finally (return ans)))
    (setq top-level-nodes (loop for l in top-level-nodes collect (cl:gethash l ht) into ans finally (return ans)))
    (send parent :set-item-list item-list)
    (send parent :set-top-level-nodes top-level-nodes)
    (loop for item in item-list
	  do
      (send item :set-group parent))))

;; thing might be *current-palette*, database might be *all-palettes*
(defun 1general-saving-menus0 (window object-type-for-project thing database label unthing default-name	
			     &optional redraw-function pre-choice)
  (let ((choice
	  (or pre-choice
	      (gt:more-menu-choose
		'(("Select"  :value :select-from-memory :documentation       
		   "Select another from memory" :font fonts:hl10)
;			    ("Append"  :value :append-from-memory :documentation
;			     "Append Library from memory to current library" :font fonts:hl10)
		  ("New Library" :value :new-library :documentation
		   "Make new library" :font fonts:hl10)
		  ("Make Copy" :value :make-copy :documentation
		   "Make copy of current library" :font fonts:hl10)
		  ("Delete from Memory" :value :delete-from-memory :documentation
		   "Delete from memory" :font fonts:hl10)
		  ("Erase Current Library" :value :delete-current :documentation
		   "Erase the current library" :font fonts:hl10)
		  ("Save to File" :value :save-to-file
		   :documentation  "Save to file" :font fonts:hl10)
		  ("Read from File" :value :load-from-file
		   :documentation "Load from file" :font fonts:hl10)
		  )
		label)))
	(undatabase database))
    (setq database (eval database))
    (process-sleep 10.)
    (loop until (zerop (tv:mouse-buttons)))
    (send window :clear-input)
    (cond
2      ;; new library
0      (1(eq choice :new-library)
0       (let ((new-name
	       (tv:pop-up-readline :prompt "1Name0: "
				   :echo-style fonts:cptfont
				   :zoom nil
				   :initial-value (eval default-name)
				   :label nil :size '(300 33)))
	     new-thing
	     )
	 (when new-name
	   (set default-name new-name)
	   (setq new-thing (make-instance (typep thing)))
	   (send new-thing :set-database-name new-name)
	   (send database :add-object-at-end new-thing)

2	   ;; set current-database to the newly created one
0	   (set unthing new-thing)
	   (when redraw-function
	     (funcall redraw-function new-thing window))
	   )))
      ;; 2make copy
0      (1(eq choice :make-copy)
0       (let ((new-name
	       (tv:pop-up-readline :prompt "1Name0: "
				   :echo-style fonts:cptfont
				   :initial-value (eval default-name)
				   :zoom nil
				   :label nil
				   :size '(300 33)))
	     new-thing
	     )
	 (when new-name
	   (set default-name new-name)
	   (setq new-thing (copy-spec thing))
	   (send new-thing :set-database-name new-name)
	   (send database :add-object-at-end new-thing)
2	   ;; set current-database to the newly created one
0	   (set unthing new-thing)
	   (when redraw-function
	     (funcall redraw-function new-thing window))
	   )))
2      ;; delete current
0      (1(eq choice :delete-current)
0       (when (confirm "Erase Current Library")
	 (send (eval unthing) :set-database-list nil)
	 (when redraw-function
	   (funcall redraw-function thing window))))
2      ;; delete from memory
0      (1(eq choice :delete-from-memory)
0       (let ((answer
	       (more-menu-choose
		 (loop for i in (send database :database-list)
		       collect `(,(send i :database-name) :value ,i :documentation
				 "Select this one"))
		 "1Delete0 1Library0")))
	 (when answer
	   (when (confirm (format nil "Delete ~a" (send answer :database-name)))
	     (send database :remove-object answer)))))
2      ;; save to file
0      (1(eq choice :save-to-file)
0       (let* ((item-list
		(loop for i in (send database :database-list)
		      collect `(,(send i :database-name) :value ,i :documentation
				"Select this one")))
	      choices project value)
	 (multiple-value (value nil nil choices)
	   (tv:choose-with-menu 
	     :label "Select Libraries to Save"
	     :choices
	     `(("1Abort0" :value :abort 
		:documentation "Exit without doing anything")
	       ("1Do It0" :value :do-it 
		:documentation "Save selections to file"))
	     :multiple-choice-items item-list))
	 (when (and (eq value :do-it) choices)
	   (setq project (choose-project-menu))
	   (when project
	     (setq project (third project))
	     (loop for c in choices
		   do
	       (save-object c project t))))))
2      ;; load from file
0      (1(eq choice :load-from-file)
0       (let ((project (choose-project-menu)))
	 (when project
	   (setq project (third project))
	   (let* ((item-list
		    (loop with dir = (fs:directory-list (resolve-project project object-type-for-project))
			  with files = (mapcar #'first (cdr dir))
			  for file in files
			  collect (list file :value file :documentation "Select this one"))))
	     (multiple-value-bind (nil nil nil choices)
		 (tv:choose-with-menu 
		   :label "Select Libraries to Load"
		   :choices
		   `(("1Abort0" :value :abort 
		      :documentation "Exit without doing anything")
		     ("1Do It0" :value :do-it 
		      :documentation "Load selections to file"))
		   :multiple-choice-items item-list)
	       (when choices
		 (loop for choice in choices
		       do
		   (load-object (make-external-object-tag (send project :project-name) (send choice :name)
							  object-type-for-project))
		   )))))))
2      ;; select from memory
0      (1(eq choice :select-from-memory)
0       (let ((answer
	       (more-menu-choose
		 (loop for i in (send database :database-list)
		       collect `(,(send i :database-name) :value ,i :documentation
				 "Select this one"))
		 "1Select Library0")))
	 (when answer
	   (set unthing answer)
2	   ;; draw newly selected-library
0	   (when redraw-function
	     (funcall redraw-function answer window)))))
2      ;; append from memory
0      (1(eq choice :append-from-memory)
0       (let ((answer
	       (more-menu-choose
		 (loop for i in (send database :database-list)
		       collect `(,(send i :database-name) :value ,i :documentation
				 "Select this one"))
		 "1Append Library0")))
	 (when answer
	   (send thing :set-database-list
		 (append (send thing :database-list)
			 (copy-spec (send answer :database-list))))
	   (when redraw-function (funcall redraw-function thing window)))))
      )))

;;------------------------------------------------------------------------------------------
;;------------------------------------------------------------------------------------------


(defvar *last-selected-item* nil)

(defmethod 1(:execute-select-method base-menu-item)0 (buttons x y device)
  (setq *last-selected-item* self)
  (cond ((listp select-method)
	 (if (eq (car select-method) :items)
	     (dolist (i (cdr select-method))
	       (send self i buttons x y  device))
	     (sys:eval-in-instance self select-method)))
	((functionp select-method)
	 (funcall select-method self buttons x y device))
	(t (send self select-method buttons x y device))))

(defmethod 1(:execute-select-method base-menu-item :after)0 (&rest ignore)
  (send menu-window :clear-input))

(defun1 xored-item-start0 (item &optional (string "Wait"))
  (send item :draw-with-alu (color:scf 255 -1))
  (send item :draw-boxed-string string (send item :font) *red* *black*))

(defun1 xored-item-end0 (item)
  (when (send item :exposed-p)
    (send item :draw-item)))

(defmethod 1(:red-busy-item base-menu-item)0 ()
  (send self :draw-with-alu (color:scf 255 -1))
  (send self :draw-boxed-string "..busy.." (send self :font) *red* *black*))


(defun slider-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'slider-menu-item plist))
(defun boxed-number-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'boxed-number-menu-item plist))
(defun pathname-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'pathname-menu-item plist))

(defun group-menu-item (items &rest plist)
  (let* ((group (lexpr-funcall #'make-item 'group-menu-item :item-list items plist))
	 (hh (get (locf plist) :static-height)))
    (when nil hh
      (send group :set-height hh)
      (send group :set-size :static))
    group))

(defun base-menu-item (&rest plist)
  (lexpr-funcall #'gt:make-item 'gt:base-menu-item plist))

(defun assoc-group-menu-item (sub-item-spec &rest plist)
  (lexpr-funcall #'make-item 'assoc-group-menu-item :sub-item-spec sub-item-spec plist))
(defun text-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'text-menu-item plist))
(defun image-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'image-menu-item plist))
(defun spacer-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'spacer-menu-item plist))
(defun command-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'command-menu-item plist))
(defun dummy-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'dummy-menu-item plist))
(defun label-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'label-menu-item plist))
(defun paging-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'paging-menu-item plist))
(defun scroll-bar-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'scroll-bar-menu-item plist))
(defun doit-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'doit-menu-item plist))
(defun sym-font-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'sym-font-menu-item plist))
(defun color-box-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'color-box-menu-item plist))
(defun object-holder-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'object-holder-menu-item plist))
(defun lisp-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'lisp-menu-item plist))
(defun hierarchy-warp-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'hierarchy-warp-menu-item plist))
(defun item-list-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'item-list-menu-item plist))
(defun name-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'name-menu-item plist))
(defun file-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'file-menu-item plist))
(defun directory-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'directory-menu-item plist))
(defun multiple-select-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'multiple-select-menu-item plist))
(defun selectable-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'selectable-menu-item plist))
(defun graph-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'graph-menu-item plist))
(defun image-icon-menu-item (&rest plist)
  (lexpr-funcall #'make-item 'image-icon-menu-item plist))


(compile-flavor-methods 
  1paging-menu-item0 1base-menu-item0 1boxed-number-menu-item0 1 command-menu-item
0  1doit-menu-item0 1slider-menu-item0 1sym-font-menu-item0 1object0-1holder-menu-item
0  1text-menu-item0 1color-box-menu-item0 1scroll-bar-menu-item
0  1item-list-menu-item0 1multiple-select-menu-item0 1selectable-menu-item
0  1pathname-menu-item0 1lisp-menu-item0 1spacer-menu-item0 1group-menu-item
0  1assoc-group-menu-item0 1label-menu-item dummy-menu-item
0  1directory-menu-item file-menu-item0 1hierarchy-warp-menu-item0)


