;;;-*- Mode: LISP; Package: (IMAGE-PROCESS); Base: 10.; Lowercase: Yes -*- 


;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
(defflavor slave-graphics-image-process-mixin () ()
  (:required-instance-variables tv:parent-screen))

(defmacro D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")with-idle-screens0 ((screen &rest rasters) &body body)
  `(progn (let ((%scr ,screen))
	    (when %scr (tv:wait-remote-screen-idle %scr))
	    ,@(loop for r in rasters collect
				       `(let ((%r (tv:raster-screen ,r)))
					  (when (and %r (neq %r %scr))
					    (setq %scr %r)
					    (tv:wait-remote-screen-idle %scr)))))
	  ,@body))

(defun 1kill-color-generic0 (name)
  (let* ((%name (intern (format nil "%~A" name) (symbol-package name))))
    (fundefine name)
    (fundefine %name)))


(defmacro 1tv:with-sheet-bit-array0 (raster direction fun &rest keywords)
  `(labels ((.do-it. ,@(cond ((and (listp fun)(eql (car fun) 'function))
			      (cdadr fun))
			     ((symbolp fun) `((,raster idx span) (ignore idx span)
					      (,fun)))
			     (t `((,raster idx span) (ignore idx span) ,fun)))))
     (let ((screen (tv:raster-screen ,raster)))
       (if screen
	   (tv:%with-bit-array screen ,raster ,direction #'.do-it. ,@keywords)
	   (tv:with-bit-array ,raster ,direction #'.do-it. ,@keywords)))))

(defun 1%with-displaced-array-10 (array new-bpp continuation)
  (let ((old-bpp (tv:array-element-byte-size array)))
    (if (eql old-bpp new-bpp)
	(funcall continuation array)
	(multiple-value-bind (w h) (decode-raster-array array)
	  (multiple-value-bind (screen sheet) (tv:raster-screen array)
	    (let ((new-w (ceiling (* w old-bpp) new-bpp)))
	      (if screen
		  (let* ((new-ar (send screen :create-screen-array
				       new-w
				       h
				       array
				       (cl:ecase new-bpp
					 (1 'art-1b)
					 (2 'art-2b)
					 (4 'art-4b)
					 (8 'art-8b)
					 (16 'art-16b)
					 (32 'art-fixnum)))))
		    (send screen :inferior-screen-array-adjusted
			  sheet new-ar new-w h
			  array 0 0)
		    (funcall continuation new-ar)
		    )
		  (si:with-stack-list (dims h new-w)
		    (si:with-stack-array (new-ar dims :type 'art-8b
						   :displaced-to array
						   :displaced-conformally t)
		      (funcall continuation new-ar)
		      ))
		  )))))))

(defmacro 1%with-displaced-array0 ((array new-bpp) &body body)
  `(%with-displaced-array-1 ,array ,new-bpp
			   #'(lambda (,array)
			       ,@body)))


(defmacro 1process-rectangle-macro
0	  (array-specs width height mask
	   pixel-function
	   &key
	   (pixel-function-other-args nil)
	   (pixel-function-gets-source t)
	   (pixel-function-gets-dest t)
	   (wrapper)
	   (row-wrapper)
	   (vars)
	   (array-vars)
	   (store-dest t)
	   (value)
	   (bitblt)
	   (loop-body)
	   (x-inc 1)
	   (before-store)
	   (constant-pixel-function t))
  (let* ((y-vars (loop for (a) in array-specs
		       collect (make-symbol (string-append a "-ROW-ADDRESS"))))
	 (x-vars (loop for (a) in array-specs
		       collect (make-symbol (string-append a "-INDEX"))))
	 (span-vars (loop for (a) in array-specs
			  collect (make-symbol (string-append a "-SPAN"))))
	 (initial-vars (loop for (a) in array-specs
			     collect (make-symbol (string-append a "-INITIAL"))))
	 (rarray-vars (loop for (a) in array-specs
			   collect (make-symbol (string-append a "-RASTER"))))
	 (all-pix-vars (loop for (a) in array-specs
			       collect (make-symbol (string-append a "-PIX"))))
	 (fetch-pix-vars (if (or mask pixel-function-gets-dest)
			     all-pix-vars
			     (cons nil (cdr all-pix-vars)))) 
	 (pix-vars `(,@(when (and (second fetch-pix-vars) pixel-function-gets-source)
			 (list (second all-pix-vars)))
		     ,@(when (and (first fetch-pix-vars) pixel-function-gets-dest)
			 (list (first all-pix-vars)))
		     ,@(cddr all-pix-vars)))
	 (mask-var (when (and mask store-dest (not bitblt))
		     (make-symbol (string-append "NOT-" mask ))))
	 (loop-body
	   (cond (bitblt
		  `(multiple-value-bind (sy sx)
		       (floor ,(second initial-vars) ,(second span-vars))
		     (multiple-value-bind (dy dx)
			 (floor ,(first initial-vars) ,(first span-vars))
		       (if (= plane-mask -1)
			   (bitblt alu width height
				   ,(second rarray-vars) sx sy
				   ,(first rarray-vars) dx dy)
			   (let ((tv:bitblt-unpacking-mask plane-mask))
			     (tv:bitblt-masked alu width height
					       ,(second rarray-vars) sx sy
					       ,(first rarray-vars) dx dy))
			   )
		       )))
		 (loop-body)
		 (t `(loop named y-loop
		      for y-offset from 0 below ,height	
			  ,@(loop for v in y-vars
				  as s in span-vars
				  as i in initial-vars
				  nconc `(as ,v from ,i by ,s))
		      do
		       
		  ,@(let ((x-body `(loop named x-loop
			for x-offset from 0 below width
			    ,@(loop for v in x-vars
				    as i in y-vars
				    as f in fetch-pix-vars
				    as a in rarray-vars
				    nconc `(as ,v from ,i by ,x-inc)
				    when f
				      nconc `(as ,f = (aref ,a ,v)))
			as rpix = ,(cond (constant-pixel-function
					  `(,pixel-function
					    ,@pix-vars
					    ,@pixel-function-other-args))
					 (pixel-function-other-args
					  `(cl:apply ,pixel-function
						     ,@pix-vars
						     ,pixel-function-other-args))
					 (t `(funcall ,pixel-function ,@pix-vars)))
			do
		    (ignore x-offset y-offset rpix)
		    ,@before-store
		    ,@(when store-dest
			`((setf (aref ,(first rarray-vars) ,(first x-vars))
				,(if mask 
				     `(logxor rpix (logand ,mask-var
							   (logxor ,(first fetch-pix-vars) rpix)))
				     'rpix))))
		    )))
		      (if row-wrapper
			(list (subst x-body :body row-wrapper))
			(list x-body)
		       ))))))
	 (wrapped-loop-body (if wrapper (subst loop-body :body wrapper) loop-body))
	 (declared-body `(let (,@(unless bitblt
				   (loop for a in rarray-vars collect `(,a ,a)))
			       ,@array-vars
			       ,@vars
			       ,@(when mask-var
				   `((,mask-var (lognot ,mask)))))
			   (declare (sys:array-register-1d
				      ,@(when (neq loop-body :bitblt) rarray-vars)
				      ,@(loop for i in array-vars collect i)
				      ))
			   ,wrapped-loop-body
			   ,@(when value (list value)))
	 ))
    (loop for (a ax ay) in array-specs
	  as atype first (if store-dest
			     (if (or pixel-function-gets-dest mask) :both :output)
			     :input)
		   then :input
	  as rv in rarray-vars
	  as iv in initial-vars
	  as sv in span-vars
	  do
      (setq declared-body `(tv:with-sheet-bit-array
			     ,a ,atype
			     #'(lambda (,rv ,iv ,sv)
				 ,declared-body)
			     :x-offset ,ax
			     :y-offset ,ay
			     :width ,width
			     :height ,height)))
    declared-body
    ))


(defmacro 1with-bitblt-clipping 0(vars &body body)
  (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");
0  2;bitblt clipping checks the bounds and reduces the scope
0  2;of the operation to respect the bounds.
  ;
0  (let (created-width created-height)
    2;created-width and created-height are special logic for DRAW-POINT, where
0    2;there is an implied width of 1
0    (multiple-value-bind (x-vars y-vars width-vars height-vars)
	(loop for (type w h x y left top width height test span) in vars
	      do (ignore left top width height test type)
	      when (and w (not (member w ww))) collect w into ww
	      when (and h (not (member h hh))) collect h into hh
	      when x collect x into xx
	      when y collect (cons y span) into yy
	      finally (return (values xx yy ww hh)))
      `(let (,@(loop with used-vars
		     for (type w h x y left top width height test span) in vars
		     do (ignore type w h width height test span)
		     nconc
		       `(,@(when (and x (not (member x used-vars)))
			     (push x used-vars)
			     `((,x ,(if left `(+ ,x ,left) x))))
			 ,@(when (and y (not (member y used-vars)))
			     (push y used-vars)
			     `((,y ,(if top `(+ ,y ,top) y))))
			 ,@(when (and w (not (member w used-vars)))
			     (push w used-vars)
			     `((,w ,w)))
			 ,@(when (and (null w) width)
			     (push (setq created-width '%.w)
				   width-vars)
			     `((%.w 1)))
			 ,@(when (and (null h) height)
			     (push (setq created-height '%.h) height-vars)
			     `((%.h 1)))
			 ,@(when (and h (not (member h used-vars)))
			     (push h used-vars)
			     `((,h ,h)))
			 )))
	 ,@(loop for (type w h x y left top width height test span) in vars
		 do (ignore type)
		    (when (and (null w) width)
		      (setq w created-width))
		    (when (and (null h) height)
		      (setq h created-height))
		 nconc
		   (let ((forms
			   `(,@(when (and x left)
				 `((when (< ,x ,left)
				     (let ((dif (- ,left ,x)))
				       ,@(loop for x in x-vars collect `(incf ,x dif))
				       ,@(loop for w in width-vars collect `(decf ,w dif))))))
			     ,@(when (and y top)
				 `((when (< ,y ,top)
				     ,(let ((base-form 
					      `(let ((dif (- ,top ,y)))
						 ,@(loop for (y . span) in y-vars
							 as x in x-vars
							 collect
							   (if span
							       `(if ,span
								    (incf ,x (* dif ,span))
								    (incf ,y dif))
							       `(incf ,y dif)))
						 ,@(loop for h in height-vars
							 collect `(decf ,h dif)))))
					(when span
					  (setq base-form
						`(if ,span 
						     (error "~A min Y out of bounds - limit is ~D but value is ~D"
							    ,type ,top ,y)
						     ,base-form)))
					base-form))))
			     ,@(when (and x w left width)
				 (let ((base-form `(+ ,x ,w))
				       (fix-form `(let ((dif (- r right)))
						    ,@(loop for w in width-vars
							    collect `(decf ,w dif)))))
				   (when span
				     (setq base-form `(if ,span
							  (+ ,x ,w (* (1- ,h) ,span))
							  ,base-form))
				     (setq fix-form
					   `(if ,span 
						(error "~A max X out of bounds: limit is ~D but value is ~D"
						       ,type right r)
						,fix-form))
				     )
				   `((let ((r ,base-form)
					   (right (+ ,left ,width)))
				       (when (> r right)
					 ,fix-form)))))
			     ,@(when (and y h top height)
				 (let ((base-form
					 `(let ((b (+ ,y ,h))
						(bottom (+ ,top ,height)))
					    (when (> b bottom)
					      (let ((dif (- b bottom)))
						,@(loop for h in height-vars
							collect `(decf ,h dif)))
					      ))))
				   (when span
				     (setq base-form
					   `(unless ,span
					      ,base-form)))
				   `(,base-form))))))
		     (if test
			 `((when ,test ,@forms))
			 forms)
		     ))
	 ,@(loop for w in width-vars
		 collect
		   `(setq ,w (max 0 ,w)))

	 ,@(loop for h in height-vars
		 collect
		   `(setq ,h (max 0 ,h)))
	 ,@(let ((b body))
	     (when created-width
	       (setq b `((when (> ,created-width 0) ,@b))))
	     (when created-height
	       (setq b `((when (> ,created-height 0) ,@b))))
	     b)))
  ))

(defmacro 1with-error-clipping 0(vars &body body)
  2;
  ;error clipping checks the bounds and declares an error if any are violated
0  2;
0  `(let* (,@(loop for (type w h x y left top width height test span) in vars
		  do (ignore type w h width height test span)
		     nconc
		    `(,@(when (and x left) `((,x (+ ,x ,left))))
		      ,@(when (and y top) `((,y (+ ,y ,top)))))))
     ,@(loop for (type w h x y left top width height test span) in vars
	     nconc
	     (let ((forms
		     `(,@(when (and x left)
			   `((when (< ,x ,left)
			       (ferror "~A min Y out of bounds - limit is ~D but value is ~D"
				       ,type ,left ,x))))
		       ,@(when (and y top)
			   `((when (< ,y ,top)
			       (ferror "~A min Y out of bounds - limit is ~D but value is ~D"
				       ,type ,top ,y))))
		       ,@(when (and x w left width)
			   (let ((base-form `(+ ,x ,w)))
			     (when span
			       (setq base-form `(if ,span
						    (+ ,x ,w (* (1- ,h) ,span))
						    ,base-form)))
			     `((let ((r ,base-form)
				     (right (+ ,left ,width)))
				 (when (> r right)
				   (ferror "~A max X out of bounds: limit is ~D but value is ~D"
					   ,type right r))))))
		       ,@(when (and y h top height)
			   (let ((base-form
				   `(let ((b (+ ,y ,h))
					  (bottom (+ ,top ,height)))
				      (when (> b bottom)
					(ferror "~A max Y out of bounds: limit is ~D but value is ~D"
						,type bottom b)))))
			     (when span
			       (setq base-form
				     `(unless ,span
					,base-form)))
			     `(,base-form)))
		       )))
	       (if test
		   `((when ,test ,@forms))
		   forms)
	       ))
     ,@body
     )
  )

(defmacro 1with-xy-offsets 0(vars &body body)
  2;
  ;error clipping checks the bounds and declares an error if any are violated
0  2;
0  (let (lists)
  `(let* (,@(loop for (type w h x y left top width height test span . keywords)
		      in vars
		  as xy-list = (cl:getf keywords :xy-list)
		  as dy = (cl:getf keywords :y)
		  as dx = (cl:getf keywords :x)
		  do (ignore type w h width height test span )
		  when xy-list do (push (list xy-list left top) lists)
		  nconc
		    `(,@(when (and x left) `((,x (+ ,x ,left))))
		      ,@(when (and y top) `((,y (+ ,y ,top))))
		      ,@(when (and dx left)
			  (loop for x in dx
				nconc
				  `((,x (+ ,x ,left)))))
		      ,@(when (and dy top)
			  (loop for y in dy
				nconc
				  `((,y (+ ,y ,top)))))
		      )
		    ))
     ,@(loop for (xy-list left top) in lists
	     collect
	       `(loop with var = ,xy-list
		      while var do
		  ,@(when left
		      `((incf (first var) ,left)))
		  (pop var)
		  ,@(when top
		      `((incf (first var) ,top)))
		  (pop var)))
     ,@body
     )
  ))

(defvar *ip-generic-defs* (cl:make-hash-table :test #'eql))
(defvar *ip-generic-methods* nil)
(defvar *ip-screen-generic-methods* nil)

(defun 1ip-info0 (fn &optional prop)
  (let ((info (gethash fn *ip-generic-defs*)))
    (cl:case prop
      (nil info)
      (:arglist (second info))
      (otherwise (cl:getf (third info) prop)))))

(defun 1find-%-function0 (for)
  (let ((info (i-p::ip-info for)))
    (or (cl:getf (third info ) :%function)
	(cl:setf (cl:getf (third info) :%function)
		 (intern (format nil "%~A" for) 'i-p)))))

(defun convert-arglist-to-funcall (arglist)
  (loop with keyargs and restargs and optionalargs and end
	for arg in arglist
	until end
	nconc
	  (cond ((eq arg '&key)
		 (setq keyargs t)
		 nil)
		((eq arg '&rest)
		 (setq restargs t)
		 nil)
		((eq arg '&optional)
		 (setq optionalargs t)
		 nil)
		((member arg '(&special &allow-other-keys
					&local))
		 nil)
		((eq arg '&aux)
		 (setq end t))
2						;real args below here
0		(restargs
		 (setq end t)
		 (list arg))
		(keyargs
		 (when (listp arg)
		   (setq arg (car arg)))
		 (list (intern (string arg) :keyword)
		       arg))
		(optionalargs
		 (when (listp arg)
		   (setq arg (car arg)))
		 (list arg))
		(t (list arg))) into new-arglist
	  finally (return (values new-arglist restargs))))

(defsubst1 art-fixnum-rasterp0 (a)
  (and (eq (array-type a) 'art-fixnum)
       (eql (array-#-dims a) 2)))

(defsubst 1rasterp0 (a)
  (eql (array-#-dims a) 2))

(defsubst1 art-1b-rasterp0 (a)
  (and (eq (array-type a) 'art-1b)
       (eql (array-#-dims a) 2)))

(defsubst1 art-8b-rasterp0 (a)
  (and (eq (array-type a) 'art-8b)
       (eql (array-#-dims a) 2)))

(defsubst 18-or-32b-rasterp0 (a)
  (and (member (array-type a) '(art-fixnum art-8b))
       (eql (array-#-dims a) 2)))

(defsubst 1t-or-nil-p0 (a) (or (eql a t)(eql a nil)))

(defvar *standard-late-type-tests*
	'((src art-fixnum-rasterp "an art-fixnum raster")
	  (source art-fixnum-rasterp "an art-fixnum raster")
	  (dest art-fixnum-rasterp "an art-fixnum raster")
	  (1b-source art-1b-rasterp "an art-1b raster")
	  (1b-dest art-1b-rasterp "an art-1b raster")
	  (8b-source art-8b-rasterp "an art-8b raster")
	  (8b-src art-8b-rasterp "an art-8b raster")
	  (8b-dest art-8b-rasterp "an art-8b raster")
	  (32b-source art-fixnum-rasterp "an art-fixnum raster")
	  (32b-dest art-fixnum-rasterp "an art-fixnum raster")
	  (matte art-8b-rasterp "an art-8b raster")
	  (matte-2 art-8b-rasterp "an art-8b raster")
	  ))

(defvar *standard-early-type-tests*
	`((plane-mask fixp "an integer representing a bit mask")
	  (alu ( 0 alu 15) "an integer from 0 to 15")
	  (pressure ( 0 pressure 255) "an integer from 0 to 255")
	  (width fixp "an integer")
	  (height fixp "an integer")
	  (sx fixp "an integer")
	  (sy fixp "an integer")
	  (dx fixp "an integer")
	  (dy fixp "an integer")
	  (mx fixp "an integer")
	  (my fixp "an integer")
	  (mx-2 fixp "an integer")
	  (my-2 fixp "an integer")
	  (value fixp "an integer, representing a color")))

(si:def-defining-form 1def-ip-generic
0   :definer ((name arglist
		   &rest args
		   &key
		   function %function body
		   (function-parent 'def-ip-generic)
		   (width '(w width))
		   (height '(h height))
		   (dest-width '(dest-width))
		   (dest-height '(dest-height))
		   (source-width '(source-width))
		   (source-height '(source-height))
		   (d-x-offset '(x dx))
		   (d-y-offset '(y dy))
		   (s-x-offset '(sx))
		   (s-y-offset '(sy))
		   (source '(source src 8b-src 32b-src 8b-source 32b-source))
		   (dest '(dest 8b-dest 32b-dest))
		   (negative-widths)
		   (clip-source t)
		   (clip-dest t)
		   (clip t)
		   d-x-forms
		   d-y-forms
		   d-xy-list
		   (other-raster-vars)
		   (pixel-function-gets-dest t)
		   (pixel-function)
		   (pixel-function-other-args)
		   (wrapper)
		   (%wrapper)
		   (clip-wrapper)
		   (wrap-source)
		   (convert-to-dest-units nil) ;needed only when s and d are different depths
		   (template)
		   (standard-late-types *standard-late-type-tests*)
		   (standard-early-types *standard-early-type-tests*)
		   (early-types )
		   (late-types)
		   (spans '(dest-span src-span))
		   (screen-from :dest)
		   (clipping-region '(clipping-region))
		   (s-x-*)
		   (d-x-*)
		   )
	     (ignore template pixel-function wrap-source
		     pixel-function-other-args pixel-function-gets-dest)
	     (labels ((find-arg (possibilities name &optional (error-p t))
			(when possibilities
			  (let ((int (intersection possibilities arglist)))
			    (cond ((null int)
				   (when error-p 
				     (ferror "no ~A identified in arglist" name))
				   nil)
				  ((cdr int)
				   (ferror "multiple ~As identified in arglist" name))
				  (t (first int)))))))
	       2;
0	       2;locate various args that may have nonstandard names
0	       2;
0	     (let* ((%name (unless %function
			     (intern (format nil "%~A" name) (symbol-package name))))
		    (rebind-source (find-arg source "Source" nil))
		    (rebind-clipping-region (find-arg clipping-region "clipping-region" nil))
		    (rebind-dest (find-arg dest "Dest" t))
		    (rebind-d-x-offset (when clip-dest
					 (if (eq clip :dest-quad) '%dx
					     (find-arg d-x-offset "dest dx"))))
		    (rebind-d-y-offset (when clip-dest
					 (if (eq clip :dest-quad) '%dy
					     (find-arg d-y-offset "dest dy"))))
		    (rebind-d-width (when clip-dest
				      (if (eq clip :dest-quad) '%dw
					(or (find-arg dest-width "dest width" nil)
					    (find-arg width "dest width")))))
		    (rebind-d-height (when clip-dest
				       (if (eq clip :dest-quad) '%dh
					   (or (find-arg dest-height "dest height" nil)
					       (find-arg height "dest height")))))
		    (rebind-s-x-offset (when clip-source
					 (find-arg s-x-offset "source dx" rebind-source)))
		    (rebind-s-y-offset (when clip-source
					 (find-arg s-y-offset "source dy" rebind-source)))
		    (rebind-s-width (when clip-source
				      (or (find-arg source-width "source width" nil)
					  (find-arg width "source width" source-width))))
		    (rebind-s-height (when clip-source
				       (or (find-arg source-height "source height" nil)
					   (find-arg height "source height" source-height))))
		    (apply)
		    (funcall-arglist)
		    raster-bounds
		    )
	       (multiple-value (funcall-arglist apply)
		 (convert-arglist-to-funcall arglist))

	       2;
0	       2;build the raster bounds list, for source, dest and any others
0	       2;
0	       (when rebind-dest
		 (let ((xoff (or rebind-d-x-offset d-x-forms d-xy-list))
		       (yoff (or rebind-d-y-offset d-y-forms d-xy-list)))
		   (push `(,rebind-dest
			   ,(when xoff '%d-left)
			   ,(when yoff '%d-top)
			   ,(when (or rebind-d-width xoff)
			      '%d-width)
			   ,(when (or rebind-d-height yoff)
			      '%d-height)
			   ,@(when (eq screen-from :dest)
			       `(:screen %screen
				 :window %sheet)))
			 raster-bounds)))
	       (when rebind-source 
		 (push `(,rebind-source
			 ,(when rebind-s-x-offset '%s-left)
			 ,(when rebind-s-y-offset '%s-top)
			 ,(when rebind-s-width '%s-width)
			 ,(when rebind-s-height '%s-height)
			 ,@(when (eq screen-from :source)
			     `(:screen %screen
			       :window %sheet))
			 )
		       raster-bounds))
	       (when (eq screen-from :source)
		 (swapf (first raster-bounds)(second raster-bounds)))
	       (loop for (var2 . 0vars) in other-raster-vars do
		 (push `(,var
			 ,@(loop for str in '("-LEFT" "-TOP" "-WIDTH" "-HEIGHT")
				 as mat = vars then (cdr mat)
2				 ;
				 ;collect left top right bottom when there is a
				 ;matching var
				 ;
0				 collect
				   (when (first mat)
				     (make-symbol (format nil "%~A~A" var str)))))
		       raster-bounds))
	       (setq raster-bounds (nreverse raster-bounds))
	       2;
	       ;emit the actual code
0	       2;
0	       `(progn
		  (puthash ',name
			   '(,name
			     ,(copytree arglist)
			     ,(zl:copytree args))
			   *ip-generic-defs*)
		  (cl:pushnew ',name  *ip-generic-methods*)
		  ,@(when %name
		      `((cl:pushnew ',%name *ip-screen-generic-methods*)
			(defgeneric ,%name (screen sheet ,@arglist)
			  (:function
			    ,@(cond ((listp function-parent)
				     `((declare (sys:function-parent ,@function-parent))))
				    (function-parent
				     `((declare (sys:function-parent ,name
								     ,function-parent)))))
			    ,(let ((form
				     `(or
					(when (and screen sheet)
					  (unless (eq sheet tv:currently-prepared-sheet)
					    (ferror "Window ~A isn't prepared" sheet))
					  (,(if apply 'cl:apply 'funcall)
						   (flavor::generic ,%name)
						   screen sheet ,@funcall-arglist)
					  )
					(with-idle-screens (screen
							      ,@(when (and rebind-source
									   (neq screen-from :source))
								  (list rebind-source))
							      ,@(when (and rebind-dest
									   (neq screen-from :dest))
								  (list rebind-dest))
							      ,@(loop for (r) in other-raster-vars collect r)
							      )
					  ,
					   (cond (function
						(if apply
						    `(cl:apply (function ,function) ,@funcall-arglist)
						    `(,function ,@funcall-arglist)))
					       (body `(progn body))
					       (t (ferror "no lisp implementation specified for ~S"
							  %name)))))))
			       (when %wrapper
				 (setq form (subst form :body %wrapper)))
			       form)))
			(defmethod (,%name tv:basic-screen :default) (sheet ,@arglist)
			  ,@(cond ((listp function-parent)
				   `((declare (sys:function-parent ,@function-parent))))
				  (function-parent
				   `((declare (sys:function-parent ,name
								   ,function-parent)))))
			  (ignore sheet ,@funcall-arglist)
			  nil			2;just say no
0			  )
			(tv:def-pass-to-parent slave-graphics-image-process-mixin ,%name ))
		      )
		  (defgeneric ,name ,arglist
		    (:function
		      ,@(cond ((listp function-parent)
			       `((declare (sys:function-parent ,@function-parent))))
			      (function-parent
			       `((declare (sys:function-parent ,name
							       ,function-parent)))))
		      ,@(let ((types (append early-types standard-early-types)))
			  (loop for arg in funcall-arglist
					    as ch = (cdr (assoc arg types))
					    when ch
					      collect `(check-arg ,arg ,@ch)))
		      ,(loop with body-core-0 =
				   (let* ((types (append late-types standard-late-types))
					  (checks (loop for arg in funcall-arglist
							as ch = (cdr (assoc arg types))
							when ch
							  collect `(check-arg ,arg ,@ch)))
					  (core (if apply
						    `(apply (function ,(or %function %name))
							    %screen %sheet ,rebind-dest
							    ,@(cdr funcall-arglist))
						    `(,(or %function %name)
						      %screen %sheet ,rebind-dest
						      ,@(cdr funcall-arglist))))
					  )
				     (if checks
					 `(progn ,@checks
						 ,core)
					 core))
				 with body-core =
				   (if wrapper
				       (subst body-core-0 :body wrapper)
				       body-core-0)
				 with x-base-form = 
				   `(,(cl:ecase clip
				       ((t :linear) 'with-bitblt-clipping)
				       ((nil) 'with-xy-offsets)
				       ((:dest-quad) 'with-error-clipping)
				       )
				    (,@(when clip-dest
					 `(("Dest" ,rebind-d-width ,rebind-d-height
					    ,rebind-d-x-offset ,rebind-d-y-offset
					    ,(when (or rebind-d-x-offset
						       d-x-forms
						       d-xy-list)
					       '%d-left)
					    ,(when (or rebind-d-y-offset
						       d-y-forms
						       d-xy-list)
					       '%d-top)
					    ,(when (or rebind-d-width
						       rebind-d-x-offset
						       d-x-forms
						       d-xy-list
						       )
					       '%d-width)
					    ,(when (or rebind-d-height
						       rebind-d-y-offset
						       d-y-forms
						       d-xy-list)
					       '%d-height)
					    nil
					    ,(when (eq clip :linear) (first spans))
					    ,@(when d-xy-list
						`(:xy-list ,d-xy-list))
					    ,@(when d-x-forms
						`(:x ,d-x-forms))
					    ,@(when d-y-forms
						`(:y ,d-y-forms))
					    )))
				     ,@(when (and rebind-source clip-source)
					 `(("Source"
					   ,rebind-s-width ,rebind-s-height
					   ,rebind-s-x-offset ,rebind-s-y-offset
					   ,(when rebind-s-x-offset '%s-left)
					   ,(when rebind-s-y-offset '%s-top)
					   ,(when rebind-s-width '%s-width)
					   ,(when rebind-s-height '%s-height)
					   nil
					   ,(when (eq clip :linear) (second spans))
					   )))
				     ,@(when other-raster-vars
					 (loop for (var left top w h) in other-raster-vars
					       as (raster . spec )
						  in (cddr raster-bounds)
					       collect
						 `(,(string var)
						   ,w ,h2 0,left ,top 
						   ,@spec
						   ,raster
						   )))
				     )
				    ,@(when (eq clip :dest-quad)
					(append
					  (loop for i in d-x-forms
						collect `(incf ,i %d-left))
					  (loop for i in d-y-forms
						collect `(incf ,i %d-top))
					  (when d-xy-list
					    `((loop with var = ,d-xy-list
						    while var do
						(incf (first var) %d-left)
						(pop var)
						(incf (frist var) %d-top))))
					  ))
				    ,@(when negative-widths
					(unless
					  (and (eq rebind-s-width rebind-d-width)
					       (eq rebind-d-height rebind-d-height))
					  (ferror "source and destination must be the same size when negative widths are allowed"))
					`((when width-backwards
					    (setq ,rebind-d-width (- ,rebind-d-width)))
					  (when height-backwards
					    (setq ,rebind-d-height (- ,rebind-d-height)))))
				    ,body-core)
			     with d-base-form =
			       (cond (convert-to-dest-units
				      `(let ((s-to-d-unit-shift
					       (- (haulong (sys:array-element-byte-size src))
						  (haulong (sys:array-element-byte-size dest)))))
					 (setq %s-width (lsh %s-width s-to-d-unit-shift))
					 ,x-base-form))
				     (d-x-*
				      `(progn
					 (setq %d-left (,(first d-x-*) %d-left ,(second d-x-*))
					     %d-width (,(first d-x-*) %d-width ,(second d-x-*))
					     )
					 ,x-base-form))
				     (s-x-*
				      `(progn
					 (setq %s-left (,(first s-x-*) %s-left ,(second s-x-*))
					       %s-width (,(first s-x-*) %s-width ,(second s-x-*))
					       )
					 ,x-base-form))
				     (t x-base-form))
			     with c-base-form = 
			       (if rebind-clipping-region
				   `(progn
				      (when ,rebind-clipping-region
					(destructuring-bind
					  (%c-left %c-top %c-right %c-bottom)
					    ,rebind-clipping-region
					  (setq %d-left (max %d-left %c-left)
						%d-top (max %d-top %c-top)
						%d-width (min %d-width
							      (- %c-right %c-top))
						%d-height (min %d-height
							       (- %c-bottom %c-top)))))
				      (with-stack-list (,rebind-clipping-region
							%d-left %d-top
							(+ %d-left %d-width)
							(+ %d-top %d-height))
					,d-base-form))
				   d-base-form)
			     with base-form = (if clip-wrapper
						  (subst c-base-form :body clip-wrapper)
						  c-base-form)

				 for (var left top w h . other-keys) in raster-bounds
				 do
			     (setq base-form
				   `(tv:with-prepared-sheet-or-raster
				      (,var
				       ,@(when left `(:inside-left ,left))
				       ,@(when top `(:inside-top ,top))
				       ,@(when w `(:inside-width ,w))
				       ,@(when h `(:inside-height ,h))
				       :array ,var
				       :force-prepare t
				       ,@other-keys)
				      ,base-form
				      ))
			     finally
			       (let* ((clip-form
					(cl:ecase clip
					  ((t)
					   `(let (,@(when negative-widths
						      `((width-backwards (minusp ,rebind-d-width))
							(height-backwards (minusp ,rebind-d-height))))
						  ,@(when rebind-d-width
						      `((,rebind-d-width ,(if negative-widths
									`(abs ,rebind-d-width)
									`(max 0 ,rebind-d-width)))))
						  ,@(when rebind-d-height
						      `((,rebind-d-height ,(if negative-widths
									 `(abs ,rebind-d-height)
									 `(max 0 ,rebind-d-height)))))
						  ,@(when rebind-source
						      `(,@(unless (or (null rebind-s-width)
								      (eq rebind-s-width rebind-d-width))
							    `((,rebind-s-width (max 0 ,rebind-s-width))))
							,@(unless (or (null rebind-s-width)
								      (eq rebind-s-height rebind-d-height))
							    `((,rebind-s-height (max 0 ,rebind-s-height))))
							))
						  )
					      ,base-form))
					  ((nil :linear :dest-quad) base-form)))
				      (quad-form
					(if (eq clip :dest-quad)
					    `(let* ((,rebind-d-x-offset (min ,@d-x-forms))
						    (,rebind-d-y-offset (min ,@d-y-forms))
						    (%%max-x (max ,@d-x-forms))
						    (%%max-y (max ,@d-y-forms)))
					       ,@(when d-xy-list
						   `((loop for (.x .y) on ,d-xy-list by #'cddr
							       (setq ,rebind-d-x-offset
								     (min ,rebind-d-x-offset
									  .x)
								     %%max-x (max %%max-x .x)
								     ,rebind-d-y-offset
								     (min ,rebind-d-y-offset
									  .y)
								     %%max-y (max %%max-y .y)))))
					       (let* ((,rebind-d-width (- %%max-x
									  ,rebind-d-x-offset))
						      (,rebind-d-height (- %%max-y
									 ,rebind-d-y-offset)))

						 ,clip-form))
					    clip-form))
				      )
				 (return quad-form)))))
		  ))))
   :killer kill-ip-generic
   )



(defun 1%image-process-function
0       (core-function write-mask other-args
	&rest other-keywords &key make-new &allow-other-keys)
  2;
0  2;call this any time to get a graphics function that uses CORE-FUNCTION
0  2;
0  (si:with-rem-keywords (other-keywords other-keywords '(:make-new))
    (let* ((use-write-mask ( write-mask -1))
	   (other-args `(write-mask ,@other-args)))
      (with-stack-list (spec 32 32 
			     :pixel-function core-function
			     :write-mask use-write-mask)
	(color:repack-rectangle-function
	  spec
	  :other-args other-args
	  :other-keywords other-keywords
	  :make-new make-new)))))

(si:def-defining-form 1def-image-process-function
0   :definer ((name core-function write-mask &rest other-keywords
		  &key
		  (source-bpp 32.)
		  (dest-bpp 32.)
		  other-args
		  other-key-args
		  (function-parent 'def-image-process-function)
		  &allow-other-keys)
	     2;
0	     2;put this in a file to get a graphics function that uses CORE-FUNCTION
0	     2;
0	     (si:with-rem-keywords (other-keywords other-keywords
						   '(:other-args :other-key-args
						     :function-parent
						     :source-bpp :dest-bpp))
	       `(color:def-repack-rectangle-function
		  ,source-bpp ,dest-bpp
		  (color:write-mask ,@other-args)
		  (:pixel-function ,core-function
		   :write-mask ,write-mask)
		  :function-parent ,function-parent
		  :other-key-args ,other-key-args
		  :compile :defer
		  :name ,name
		  :other-keywords ,(si:copy-if-necessary other-keywords)
		  ))))

(3 0 (NIL 0) (NIL :BOLD :LARGE) "MEDFNTB");  PAINT system --  code for pixel packing / unpacking / blending
;		    (low level, highly bummed, hardware specific)
;
;  1-20-84  cwr  Created file (moved code from PLib.Lisp).
; Eight bit arithmetic:


0(defmacro 1combine-rgb0 (r g b background)
  `(sys:%logdpbs ,b (byte 16 16)
		 ,g (byte 8 8)
		 ,r (byte 8 0)
		 ,background))

(defmacro 1combine-rgbx0 (r g b background)
  `(sys:%logdpbs ,b (byte 8 16)
		 ,g (byte 8 8)
		 ,r (byte 8 0)
		 ,background))

(defmacro 1combine-rgba0 (r g b alpha)
  `(sys:%logdpbs ,alpha (byte 8 24)
		 ,b (byte 8 16)
		 ,g (byte 8 8)
		 ,r))


#+imach
(defmacro 1ivory-fpa-*0 (a b)
  `(progn
     (cli::%fpa-start fixnum-multiply ,a ,b)
     (cli::%fpa-wait fixnum-multiply)
     (sys:%fixnum (cli::%fpa-result fixnum-multiply))))

(defsubst 1fast-divide-by-2560  (fixnum) (ldb (byte 8 8) fixnum))

#||

(defsubst 1fast-weaver-divide-by-2560 (fixnum)
  (ldb (byte 8 9) (+ fixnum fixnum)))

(defsubst 1weaver-divide-by-2560 (fixnum)
  (ldb (byte 8 9) (+ fixnum (cl:logandc1 #o177 fixnum))))

(defsubst 1fast-weaver-multiply 0(8-bit-fixnum-0 8-bit-fixnum-1 fpa)
  ;3.05 uSec on XL400 w FPA
  (if fpa
      (fast-weaver-divide-by-256
	(#+imach ivory-fpa-* #+3600 * 8-bit-fixnum-0 8-bit-fixnum-1))
      (fast-weaver-divide-by-256
	(* 8-bit-fixnum-0 8-bit-fixnum-1))))

||#

(defsubst 1fast-8x8-fractional-multiply0  (8-bit-fixnum-0  8-bit-fixnum-1 fpa)
2  ;2.67 uSec on XL400 w FPA
0  (if fpa
      (fast-divide-by-256
	(#+imach ivory-fpa-* #+3600 * 8-bit-fixnum-0 8-bit-fixnum-1))
      (fast-divide-by-256
	(* 8-bit-fixnum-0 8-bit-fixnum-1))))


(defsubst 1fast-8x8-fractional-multiply-round0  (8-bit-fixnum-0  8-bit-fixnum-1 fpa)
2  ;2.87 uSec on XL400 w FPA.
0  (if fpa
      (fast-divide-by-256
	(+ 128 (#+imach ivory-fpa-* #+3600 * 8-bit-fixnum-0 8-bit-fixnum-1)))
      (fast-divide-by-256
	(+ 128 (* 8-bit-fixnum-0 8-bit-fixnum-1)))))

(defsubst 1photon-8x8-multiply0 (num1 num2 fpa)
2  ;4.48 usec. This is the most correct thing, and what photon actually does
0  #+3600 (ignore fpa)
  (if #+imach fpa #+3600 nil
      (let ((product (ivory-fpa-* num1 num2)))
	(ldb (byte 8 8)
	     (if (minusp product)
		 (+ #o177400 product (ldb (byte 9 7) product))
		 (+ product (ldb (byte 9 7) product)))))
      (let ((product (* num1 num2)))
	(ldb (byte 8 8)
	     (if (minusp product)
		 (+ #o177400 product (ldb (byte 9 7) product))
		 (+ product (ldb (byte 9 7) product)))))
      ))

(defsubst 1fast-8-bit-blend0 (8-bit-weight value-0 value-1 fpa )
  ;3.65 2uSec on XL400 w FPA0 without round
2  ;3.9002 uSec on XL400 w FPA0 with round
2  ;5.47 uSec on XL400 w FPA with photon-eqv 
0  (ldb (byte 8 0)
       (+ (fast-8x8-fractional-multiply-round ;fastest
	    (- value-1 value-0)
	    8-bit-weight
	    fpa)
	  value-0)))

#||
(defun mtest ()
  ;this demonstrates that fast-weaver-divide is the same as weaver-divide
  (loop with errs = 0 and nerrs = 0
	for a from -255 to 255 do
    (loop for b from -255 to 255
	  as fm = (1photon-8x8-multiply0-slow a b t)
	  as m = (photon-8x8-multiply a b t)
	  unless (= fm m) do (incf errs)
	  do (Incf nerrs ))
    finally (return (values errs nerrs (cl:// errs nerrs)))))

(defun ttest ()
  (let ((a 121)
	(b 124)
	(c 203)
	s r)
    (values ( cl-user::1WITH-SIMPLE-UNROLL-TIMER0 (100)
      (setq r (fast-8-bit-blend 
		b a c t)))
    (list s r))))

(defun a ()
  (loop for i from 0 to 255
	collect
	  (list i
		(fast-8-bit-blend i 255 0 t)
		(uphoton:mix i 0 255.))))
||#





#+3600
(defun CLI::FP-COPROCESSOR-ENABLED-P ())

(defmacro 1def-rectangle-process
0	  (base-name arglist core
	   &key pixel-function-args 
	   (pixel-function-gets-dest t)
	   (use-fpa t)
	   (other-raster-vars)
	   (dest-args '(dest dx dy))
	   (source-args `(src sx sy))
	   (width 'width)
	   (height 'height)
	   (plane-mask 'plane-mask)
	   (function-parent 'def-rectangle-process)
	   &allow-other-keys
	   )
  (let ((pixel-function-fpa-args `(,@pixel-function-args t))
	(pixel-function-no-fpa-args `(,@pixel-function-args nil)))
    `(defun ,base-name ,arglist
       ,@(cond ((listp function-parent)
		`((declare (sys:function-parent ,@function-parent))))
	       (function-parent
		`((declare (sys:function-parent ,base-name
						,function-parent)))))
       (if (= plane-mask -1)
	   ,(let ((x `(process-rectangle-macro
			(,dest-args
			 ,source-args
			 ,@other-raster-vars)
			,width ,height nil ,core
			:pixel-function-gets-dest ,pixel-function-gets-dest
			:pixel-function-other-args ,pixel-function-no-fpa-args)))
	      (if use-fpa
		  `(if (CLI::FP-COPROCESSOR-ENABLED-P)
		       (process-rectangle-macro
			 (,dest-args
			  ,source-args
			  ,@other-raster-vars)
			 ,width ,height nil ,core
			 :pixel-function-gets-dest ,pixel-function-gets-dest
			 :pixel-function-other-args ,pixel-function-fpa-args)
		       ,x)
		  x))
	   ,(let ((x `(process-rectangle-macro
			(,dest-args
			 ,source-args
			 ,@other-raster-vars)
			,width ,height ,plane-mask ,core
			:pixel-function-gets-dest ,pixel-function-gets-dest
			:pixel-function-other-args ,pixel-function-no-fpa-args)))
	      (if use-fpa
		  `(if (CLI::FP-COPROCESSOR-ENABLED-P)
		       (process-rectangle-macro
			 (,dest-args
			  ,source-args
			  ,@other-raster-vars)
			 ,width ,height ,plane-mask ,core
			 :pixel-function-gets-dest ,pixel-function-gets-dest
			 :pixel-function-other-args ,pixel-function-fpa-args)
		       ,x)
		  x))
	   ))))

(defmacro 1def-soft-matte-process
0	  (base-name arglist core
	   &rest keywords
	   &key pixel-function-args 
	   (pixel-function-gets-dest t)
	   (use-fpa t)
	   (function-parent 'def-soft-matte-process)
	   &allow-other-keys
	   )
  #+3600 (ignore use-fpa)
  (let* ((package (symbol-package base-name))
	 (name (intern (format nil "~A-INTERNAL" base-name) package))
	 #+imach
	 (fpa-name (intern (format nil "~A-FPA-INTERNAL" base-name) package))
	 (mask-name (intern (format nil "~A-MASKED-INTERNAL" base-name) package))
	 #+imach
	 (masked-fpa-name (intern (format nil "~A-FPA-MASKED-INTERNAL" base-name) package))
	 )
    (destructuring-bind (dest dx dy source sx sy width height mask . other-args) arglist

    (si:with-rem-keywords (keywords keywords
				    '(:pixel-function-args 
				      :pixel-function-gets-dest
				      :function-parent
				      :mask
				      :use-fpa))
      `(progn
	 ,@(when core
	     `(
	 (def-image-process-function
	   ,name ,core nil
	   :function-parent (,base-name ,function-parent)
	   :pixel-function-args (,@pixel-function-args nil)
	   :pixel-function-gets-dest ,pixel-function-gets-dest
	   :other-args ,other-args
	   ,@(copylist keywords))
	 (def-image-process-function
	   ,mask-name ,core t
	   :function-parent (,base-name ,function-parent)
	   :pixel-function-args (,@pixel-function-args nil)
	   :pixel-function-gets-dest ,pixel-function-gets-dest
	   :other-args ,other-args
	   ,@(copylist keywords))
	 #+imach
	 ,@(when use-fpa
	     `((def-image-process-function
		 ,fpa-name ,core nil
		 :function-parent (,base-name ,function-parent)
		 :pixel-function-args (,@pixel-function-args t)
		 :pixel-function-gets-dest ,pixel-function-gets-dest
		 :other-args ,other-args
		 ,@(copylist keywords))
	       #+imach
	       (def-image-process-function
		 ,masked-fpa-name ,core t
		 :function-parent (,base-name ,function-parent)
		 :pixel-function-args (,@pixel-function-args t)
		 :pixel-function-gets-dest ,pixel-function-gets-dest
		 :other-args ,other-args
		 ,@(copylist keywords))))))
	 (defun ,base-name ,arglist
	   ,@(cond ((listp function-parent)
		    `((declare (sys:function-parent ,@function-parent))))
		   (function-parent
		    `((declare (sys:function-parent ,base-name
						    ,function-parent)))))
	   ,(if core
		`(let ((fun #+imach
			    ,(if use-fpa
				 `(if (CLI::FP-COPROCESSOR-ENABLED-P)
				      (if (eql ,mask -1) #',fpa-name #',masked-fpa-name)
				      (if (eql ,mask -1) #',name #',mask-name))
				 `(if (eql ,mask -1) #',name #',mask-name))
			    #+3600
			    (if (eql ,mask -1) #',name #',mask-name)
			    ))
		   (repack-rectangle-with-bus
		     fun
		     ,width ,height
		     ,source ,sx ,sy
		     ,dest ,dx ,dy
		     ,mask
		     ,@other-args)	
		   )
		`(progn 
		   (ignore ,@arglist)
		   (ferror "no lisp core for defined"))
		)))))
    ))

(defun 1repack-rectangle-with-bus
0       (fun width height source sx sy dest dx dy plane-mask &rest args)
  (tv:with-sheet-bit-array 
    dest :both
    (tv:with-sheet-bit-array
      source :input
      (cl:apply #'color:repack-rectangle-internal fun width height
		source sx sy
		dest dx dy plane-mask args))))


(defmacro 1def-soft-matte0 (base-name arglist core-name
			  &key pixel-function-args
			  (pixel-function-gets-dest t)
			  (use-fpa t)
			  (wrapper)
			  other-raster-vars
			  late-types
			  early-types
			  (function-parent 'def-soft-matte)
			  )
  (let ((package (symbol-package base-name))
	(lisp-name (intern (format nil "LISP-~A" base-name) package)))
    `(progn
       (,(if other-raster-vars 'def-rectangle-process 'def-soft-matte-process)
	,lisp-name ,arglist ,core-name
	:pixel-function-gets-dest ,pixel-function-gets-dest
	:function-parent (,lisp-name ,function-parent)
	:use-fpa ,use-fpa
	,@(when other-raster-vars `(:other-raster-vars ,other-raster-vars))
	:pixel-function-args ,pixel-function-args)

       (def-ip-generic ,base-name ,arglist
	 :function ,lisp-name
	 :function-parent ,function-parent
	 :other-raster-vars ,other-raster-vars
	 :pixel-function ,core-name
	 :pixel-function-gets-dest ,pixel-function-gets-dest
	 :pixel-function-other-args (,@pixel-function-args
				     ,@(when use-fpa (list 'fpa)))
	 :template ,(if pixel-function-gets-dest	
			(cl:ecase (length other-raster-vars)
			  (0 'lisp-2-array-modify-rectangle)
			  (1 'lisp-3-array-modify-rectangle)
			  (2 'lisp-4-array-modify-rectangle))
			(cl:ecase (length other-raster-vars)
			  (0 'lisp-copy-rectangle)
			  (1 'lisp-3-array-copy-rectangle)))
	 :late-types ,late-types
	 :early-types ,early-types
	 :wrapper ,wrapper
	 )
       )))



(4 0 (NIL 0) (NIL :BOLD :VERY-LARGE) "BIGFNTB");;
;; Filtering
;;

0(defmacro1 filter-pixel-3x3x80 (&key
			    (weights '(1 2 1 2 4 2 1 2 1))
			    (combine '+)
			    byte
			    (vars '(r00 r01 r02 r10 r11 r12 r20 r21 r22)))
  (loop with total-weight = 0
	and minus-weight
	for r in vars
	as i from 1
	as w in weights
	collect (let ((core (if (and byte ( i 9)) `(%logldb ,byte ,r) r)))
		   (if (plusp w)
		       (if (eql w 1)
			   core
			   `(sys:%fixnum-multiply ,core ,w))
		       (setq minus-weight t)
		       (if (eql w -1)
			   `(- ,core)
			   `(sys:%fixnum-multiply (- ,core) ,(- w)))))
	  into form
	do (incf total-weight w)
	finally
	  (setq form `(,combine ,@form ,@(when (and ( total-weight 0)
						    (eq combine '+))
					   `(,(// total-weight 2)))))
	  (when (and (eq combine '+) ( total-weight 0))
	    (setq form `(sys:%fixnum-floor ,form ,total-weight)))
	  (when minus-weight (setq form `(min 255 (max 0 ,form))))
	  (return form))
  )

(defmacro 1filter-pixel-3x3x320 (&key
			 (vars '(r00 r01 r02 r10 r11 r12 r20 r21 r22))
			 (combine '+)
			 (weights '(1 2 1 2 4 2 1 2 1)))
  `(combine-rgba

     (filter-pixel-3x3x8 :vars ,vars
			 :byte (byte 8 0)
			 :combine ,combine
			 :weights ,weights)
     (filter-pixel-3x3x8 :vars ,vars
			 :byte (byte 8 8)
			 :combine ,combine
			 :weights ,weights)
     (filter-pixel-3x3x8 :vars ,vars
			 :byte (byte 8 16)
			 :combine ,combine
			 :weights ,weights)
     (filter-pixel-3x3x8 :vars ,vars
			 :byte (byte 8 24)
			 :combine ,combine
			 :weights ,weights)))

(defmacro 1filter-3x3
0	  (array-specs width height mask kernal
	   &key (constant-kernal t) kernal-other-args)

  (let* ((in-place (null (cdr array-specs)))
	 (r0-array (if in-place 'dest 'src))
	 (loop-body 
	   `(let* ((width ,width)
		   (height ,height)
		   (src src)
		   (dest dest)
		   ,@(when mask `((,mask (lognot ,mask))))
		   )
	      (declare (sys:array-register-1d src dest))

	      ,@(when in-place
2		  ;copy the first row to the temp array
0		  `((loop for i from s-idx
			  for j from 0 below width
			  do
		      (setf (aref dest j) (aref src i)))))

	      (loop named y-loop
		    as row from 1 to height
		    ,@(if in-place
			  `(as d-row-idx from s-idx by s-span)
			  `(as d-row-idx from d-idx by d-span))
		    ,@(unless in-place
			`(as r0 = s-idx then r1))
		    as r1 = s-idx then r2
		    as r2 = (if (eql height 1) s-idx (+ s-idx s-span))
			  then (if (eql row height) r2 (+ r2 s-span))
		    do
		(loop named x-loop
		      with sx0 = ,(if in-place 0 'r0)
		      and sx1 = r1
		      and sx2 = r2
		      with r00 and r10 and r20
		      and r01 = (aref ,r0-array sx0)
		      and r11 = (aref src sx1)
		      and r21 = (aref src sx2) 
		      with r02 = r01
		      and r12 = r11
		      and r22 = r21
		      as col from 1 to width
		      as didx from d-row-idx
		      do
		  (setq r00 r01
			r01 r02
			r10 r11
			r11 r12
			r20 r21
			r21 r22)
		  (unless (= col width)
		    (setq r22 (aref src (incf sx2))
			  r02 (aref ,r0-array (incf sx0))
			  r12 ,(if in-place
				   `(setf (aref ,r0-array sx0)
					  (aref src (incf sx1)))
				   `(aref src (incf sx1)))))

		  (setf (aref ,(if in-place 'src 'dest) didx)
			,(if mask
			     `(let ((v (,@(if constant-kernal
					      (list kernal)
					      (list 'funcall kernal))
					r00 r01 r02 r10 r11 r12 r20 r21 r22
					,@kernal-other-args)))
				(logxor v (logand ,mask
						  (logxor v
							  ,(if in-place
							       'r11
							       '(aref dest didx))))))
			     `(,@(if constant-kernal
					      (list kernal)
					      (list 'funcall kernal))
			       r00 r01 r02 r10 r11 r12 r20 r21 r22 ,@kernal-other-args)))
		  ))))
	 (dest-body
	   (if in-place
	       `(si:with-stack-array (dest (1+ ,width) :type (array-type src))
				  ,loop-body)
	       (destructuring-bind (dest dx dy) (second array-specs)
		 `(tv:with-bit-array
		    ,dest :output
		     #'(lambda (dest d-idx d-span)
			 ,loop-body)
		     :width ,width
		     :height ,height
		     :x-offset ,dx
		     :y-offset ,dy))))
	 (src-body
	   (destructuring-bind (src sx sy) (first array-specs)
	     `(tv:with-bit-array
		,src ,(if in-place :both :input)
		#'(lambda (src s-idx s-span)
		    ,dest-body
		    )
		:width ,width
		:height ,height
		:x-offset ,sx
		:y-offset ,sy))))
    src-body
  ))

(defmacro 1filter-with-mask0 (dest dx dy src sx sy width height plane-mask kernal
			    &key kernal-other-args)
  `(if (and (eql ,dest ,src)(eql ,dx ,sx)(eql ,dy ,sy))
       (if (eql ,plane-mask -1)
	   (filter-3x3 ((,dest ,dx ,dy)) ,width ,height nil ,kernal
		       :constant-kernal nil
		       :kernal-other-args ,kernal-other-args)
	   (filter-3x3 ((,dest ,dx ,dy)) ,width ,height ,plane-mask ,kernal
		       :constant-kernal nil
		       :kernal-other-args ,kernal-other-args
		       ))
       (if (eql ,plane-mask -1)
	   (filter-3x3 ((,src ,sx ,sy) (,dest ,dx ,dy)) ,width ,height nil ,kernal
		       :constant-kernal nil
		       :kernal-other-args ,kernal-other-args
		       )
	   (filter-3x3 ((,src ,sx ,sy) (,dest ,dx ,dy)) ,width ,height ,plane-mask ,kernal
		       :constant-kernal nil
		       :kernal-other-args ,kernal-other-args
		       ))))

