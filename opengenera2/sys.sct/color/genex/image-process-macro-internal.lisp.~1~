;;; -*- Package: COLOR; Base: 10.; Mode: LISP; -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>


(defun image-process-macro-internal
       #.`(&rest args
		    &key ,@(loop for i in image-process-macro-all-args
				 collect (intern (string i)))
		    &allow-other-keys)
	  permitted-args


  (let (pixels-per-group
	source-lines-per-group
	multiple-value-fetch
	no-inc-source
	source-span-used
	dest-span-used
	fetch-multiplier
	(args (nconc (copylist args)
		     . #.(let* ((aargs (loop for i in image-process-macro-all-args
					   nconc `(,i ,(intern (string i)))))
			      (half (nthcdr (1- (// (length aargs) 2)) aargs))
			      (half2 (cdr half)))
			 (setf (cdr half) nil)
			 `((list ,@aargs)
			   (list ,@half2)))
		     )))
  (labels ((expand-var (format from-arg operators arg &aux single-source)
	     (destructuring-bind ((func . funargs) other-a)
		 (multiple-value-bind (val found)
		     (gethash format operators)
		   (unless found
		     (warn D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")"~S isn't a known ~A format specifier"0 format arg))
		   val)
	       (when other-a
		 (loop for i in other-a
		       as iname = (if (listp i) (car i) i)
			 do
		   (if (keywordp iname)
		       (selectq iname
			 (:single-source (setq single-source t))
			 (:multiple-value-fetch (setq multiple-value-fetch t))
			 (:no-inc (setq no-inc-source t))
			 (:fetch-multiplier (setq fetch-multiplier (second i)))
			 (:locals (setq locals (nconc (loop for j in (cdr i)
								collect
								  (if (listp j)
								      j
								      (list j nil)))
						      locals)))
			 (:before-line
			  (setq before-line `(progn ,(copytree (cdr i)) ,before-line)))
			 (t (ferror "~S isn't a known directive")))

		   (if (and (null (cddr i))
			    (or (null (second i)) (numberp (second i))))
		       (let ((n (assq iname locals)))
			 (when n (setq locals (delete n locals-per-line)))
			 (push `(,(first i) ,(second i)) locals-per-line)
			 )
		       (let ((n (assq iname other-arrays)))
			 (when n (setq other-arrays (delete n other-arrays))))
		       (push `(,(car i) ,(cond ((null (cddr i))
						(second i))
					       (t
						`(if (arrayp ,(second i))
						     ,(second i)
						     (send ,@(cdr i))))))
			     other-arrays)
		       ))
		   ))
	       (values
		 (when from-arg
		   (cond ((or single-source (null (cdr funargs)))
			  `(,from-arg))
			 (t (loop for i in funargs
				  as j in `(first second third fourth)
				  do (ignore i)
				  collect `(,j ,from-arg)))))
		 func
		 (lexpr-funcall #'construct-form funargs
				     args))))
	   )

    (when (null arglist)
(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")      ;the default arg list
0      (setq arglist '(width height src sx sy dest dx dy)))

    (when (listp rescale)
      (setq source-pixels-per-group (second  rescale)
	    dest-pixels-per-group 1
	    source-lines-per-group 
	    (loop repeat (1- (third rescale))
		  as i from 2
		  collect
		    (make-symbol (format nil "sidx-~D" i)))
	    rescale (first rescale))
      )

    (when (null source-pixels-per-group)
2      ;when not unrolling the X-axis loop
0      (setq source-pixels-per-group 1
	    dest-pixels-per-group 1))

    (setq pixels-per-group (max source-pixels-per-group dest-pixels-per-group))

    (when (and (neq rescale :pixel-average)
	       (or (eq main-loop :copy)
		   (> pixels-per-group 1)))
      (setq rescale nil))

    (when (eq rescale :select)
      (setq rescale-rolled-y nil))

    (multiple-value (fetch separate map combine store)
      (lexpr-funcall #'normalize-image-process-args args))

    (when (and rescale
	       (< (length arglist) 10))
      2;when rescaling, there is a separate dest-height and dest-width
0      (setq arglist (append arglist '(dest-width dest-height))))

    (destructuring-bind (width height src sx sy dest dx dy dest-width dest-height) arglist
      2;Above, bind the user's names for the arguments.  Below, create names
0      2;for the internediate variables we will need in the resulting function
0      (when (or (null dest-width)(eq dest-width 'ignore))
	(setq dest-width width))
      (when (or (null dest-height) (eq dest-height 'ignore))
	(setq dest-height height))

    (multiple-value-bind (sources fetch-operator fetch-args)
	(expand-var fetch src fetch-operators "FETCH")
    (multiple-value-bind (nil map-operator map-args)
	(expand-var map nil map-operators "MAP")
    (multiple-value-bind (nil separate-operator separate-args)
       (expand-var (if (listp separate) (first separate) separate)
		   nil
		   separate-operators "SEPARATE")
    (multiple-value-bind (nil alpha-operator alpha-args)
       (expand-var (when (listp separate) (second separate))
		   nil
		   combine-operators
		   "ALPHA")
    (multiple-value-bind (nil combine-operator combine-args)
        (expand-var combine nil combine-operators "COMBINE")
    (multiple-value-bind (dests store-operator store-args)
	(expand-var store dest store-operators "STORE")

   (let* ((intermediate-values (loop for i from 1 to (+ (if separate-args
							    (length separate-args)
							    (length fetch-args))
							(if alpha-operator 1 0))
				     as j = (or (nth (1- i) intermediate-values)
						(nth (1- i) '(red green blue alpha)))
				     collect j))
	  (per-color-operation (if (listp per-color) (first per-color) per-color))
	  (sars (image-process-macro-make-symbols "src-" sources '(r g b alpha)))
	  (dars (image-process-macro-make-symbols "dest-" dests '(r g b alpha)))
	  (s&s-ars (when (and rescale (neq rescale :select)(neq rescale :pixel-average))
		     (image-process-macro-make-symbols "s&s-" intermediate-values)))
	  (s&s-temps (when (and rescale
				(neq rescale :select)
				(neq rescale :pixel-average)
				(not rescale-rolled-y))
		       (image-process-macro-make-symbols "s-" intermediate-values)))
	  (bitblt (eq per-color-operation :bitblt))
	  (bitblt-function (and bitblt (or (cadr per-color) 'tv:bitblt)))
	  (actual-locals-per-color
	    (loop for color in intermediate-values
		  collect (image-process-macro-make-symbols (string-append color "-") locals-per-color)))
	  (store-local-per-color
	    (cond ((null store-local-per-color) intermediate-values)
		  ((loop for locals in actual-locals-per-color
			   nconc
			   (loop for i in locals-per-color
				 as ii in locals
				 when (eq i store-local-per-color)
				   return (list ii))))
		  (t (list store-local-per-color)
		  )))
	  (all-locals (unless bitblt 
			`(,@intermediate-values
			  ,@(loop for i in actual-locals-per-color
				  append i)
			  ,@locals
			  )))
	  pixel-in-group
	  (rescale-store-type :accum-temp)
	  (store-multiplier (when ( (length dests) (length store-args))
			      (length store-args)))

	  2;these modify the end-of-line target, considering the number of fetches per pixel
0	  (fetch-multiplier (or fetch-multiplier
				(when ( (length sources)(length fetch-args))
				  (length fetch-args)
				  )))
	  )
      2;;when save-last-pixel is required, give it a name unless it has one
0      (when (eq save-last-pixel t)
	(setq save-last-pixel (make-symbol "save-last-pixel")))

      (when write-mask
	(unless (memq 'write-protect-mask all-locals)
	  (push '(write-protect-mask (lognot write-mask)) all-locals)))

      (when (and (or save-last-pixel
		     (when (and store
				(cdr separate-args))
		       (setq save-last-pixel (make-symbol "save-last-pixel"))))
		 (not (memq save-last-pixel all-locals)))
	(push save-last-pixel all-locals))

      (when (eq computed-source-lines t)
	(setq computed-source-lines (make-symbol "computed-source-lines")))
      (when (eq computed-dest-lines t)
	(setq computed-dest-lines (make-symbol "computed-dest-lines")))
    (labels ((nth-value (n)
	       (image-process-macro-nth-value
		 n
		 :store-local-per-color store-local-per-color
		 :rescale-store-type rescale-store-type
		 :s&s-ars s&s-ars
		 :s&s-temps s&s-temps
		 :rescale rescale
		 :pixel-count (* pixels-per-group (1+ (length source-lines-per-group)))
		 :jitter jitter))
	     (separate (val &key (inc '(:next-x)) (index-var 'src-index)(sum nil))
2	       ;;separate the fetched value into color components
0	       (image-process-macro-separate
		 :no-inc no-inc-source
		 :multiple-value-fetch multiple-value-fetch
		 :produce-value val
		 :inc inc
		 :mapped-form (if map-operator
				  `(progn
				     ,@(loop for i in (cdr (fetch index-var))
					     as ma in map-args
					     collect
					       (funcall map-operator i ma)))
		      
				  (fetch index-var))
		 :separate-operator separate-operator
		 :separate-args separate-args
		 :fetch-multiplier fetch-multiplier
		 :intermediate-values intermediate-values
		 :sources sources
		 :save-last-pixel save-last-pixel
		 :alpha-operator alpha-operator
		 :alpha-args alpha-args
		 :index-var index-var
		 :sum sum
		 )
	       )
	     (store-it (val)
		    (image-process-macro-store
		      :return-value val
		      :store-operator store-operator
		      :store-args store-args
		      :store-local-per-color store-local-per-color
		      :dars dars
		      :combine-operator combine-operator
		      :write-mask write-mask
		      :before-store
		       (when val
			 (apply-user-function
			   before-store
2			   ;;combine the N intermediate values into one value,
			   ;;prior to the store step
0			   (let ((val (when combine-operator
					(funcall combine-operator
						 (loop for x in store-local-per-color
						       as i from 1
						       do (ignore x)
						       collect (nth-value i))
						 combine-args))))
			     (when (and save-last-pixel val)
			       (setq val `(setq ,save-last-pixel ,val)))
			     (when jitter
			       (setq val
				     `(let ((random-increment
					      (- (small-range jitter-threshold random-value)
						 jitter-2)))
					,val)))
			     val)))
		      :rescale-store-type rescale-store-type
		      :s&s-ars s&s-ars
		      :s&s-temps s&s-temps
		      :rescale rescale
		      :jitter jitter
		      :pixel-count (* pixels-per-group (1+ (length source-lines-per-group)))
		      ))
	     (fetch (&optional (index-var 'src-index))
	       (if multiple-value-fetch
		   (funcall fetch-operator
			     `(aref ,(first sars) ,index-var)
			     (first fetch-args))
		     
		   `(progn ,@(loop for sa in sars
				   as v = `(aref ,sa ,index-var)
				   as fa in fetch-args
				   collect (funcall fetch-operator v fa)
				     ))))
	     (body (early-exit)
2	       ;;this is the normal X-axis body to handle one pixel,
	       ;;which may be optionally fetched and stored, and may
	       ;;involve an unrolled loop treated as a group
0	       (loop with fetched = 0 and stored = 0 and first = t
		     for i from 0 below pixels-per-group
		     do (setq pixel-in-group i)
		     collect
		     `(progn ,@
		       (loop for index-var in `(src-index ,@source-lines-per-group)
			     nconc
			       `(,@(when early-exit
				     `((when (= dest-index last-x-index) (return nil))))
				 ,(separate (let ((v (apply-user-function-now optional-fetch i)))
					      (when v (incf fetched))
					      v)
					    :index-var index-var
					    :sum (and (eq rescale :pixel-average)
						      (not first)))
				 ,(apply-user-function before-per-color nil)
				 ,(image-process-macro-per-color
				    :per-color per-color
				    :actual-locals-per-color actual-locals-per-color
				    :intermediate-values intermediate-values
				    :pixel-in-group pixel-in-group
				    :pixels-per-group pixels-per-group)
				 ,(apply-user-function after-per-color nil)
				 ,(store-it (let ((v (apply-user-function-now optional-store i)))
					   (when v (incf stored))
					   v))
				 )
			       do (setq first nil)))
		       into val
		     finally
		       (when (> pixels-per-group 1)
			 (unless (= fetched (* source-pixels-per-group
					       (1+ (length source-lines-per-group))))
				    
			   (warn "~D fetched but should be ~D"
				 fetched source-pixels-per-group))
			 (cond ((= stored dest-pixels-per-group))
			       ((and (= dest-pixels-per-group 1)(= stored 0))
				(nconc val (list (store-it t))))
			       (t
				(warn "~D stored but should be ~D"
				      fetched dest-pixels-per-group))))
		       (return val)
		       ))
	     (rescale-x-body ()
2	       ;; this is the X-axis body when rescaling.
0	       `(progn
		  (setq diff-x (- src-x-count dst-x-count))
		  (when fetch-next-time
		    ,(separate t)
		    ,(apply-user-function before-per-color nil)
		    ,(image-process-macro-per-color
				  :per-color per-color
				  :actual-locals-per-color actual-locals-per-color
				  :intermediate-values intermediate-values
				  :pixel-in-group pixel-in-group
				  :pixels-per-group pixels-per-group)
		    ,(apply-user-function after-per-color nil)
		    ,@(when (eq rescale :select)
			(loop for i in s&s-ars
			      as j in intermediate-values
			      collect
				`(setf (aref ,i tmp-dst-index)
				       ,j)))
		    (setq fetch-next-time nil))
		  
		  (if (plusp diff-x)
		      (progn
			,@(unless (eq rescale :select)
			    `((setq accum-count (* dst-x-count y-count))))
			(decf src-x-count dst-x-count)
			(setq dst-x-count ,width)
			)
		      
		      (if (minusp diff-x)
			  (decf dst-x-count src-x-count)
			  (setq dst-x-count ,width)
			  )

		      (setq ,@(unless (eq rescale :select)
				`(accum-count (* src-x-count y-count)))
			    src-x-count ,dest-width
			    fetch-next-time t))
		  
		  ,@(when (neq rescale :select)
		      ;accumulate this pixel's partial
		      (loop for i in (if rescale-rolled-y s&s-ars s&s-temps)
			    as j in intermediate-values
			    collect
			      `(%32b-incf
				 ,(if rescale-rolled-y
				      `(aref ,i tmp-dst-index)
				      i)
				 (* ,j accum-count))))

		  ,@(if (eq rescale :select)
			`((when ( diff-x 0) ,(store-it t)))
			`((when ( diff-x 0)
			    ,@(unless rescale-rolled-y
				(selectq rescale-store-type
				  ((:accum-temp :setq-temp)
				   (loop for src in s&s-temps
					 as dest in s&s-ars
					 collect
					   `(,(if (eq rescale-store-type :accum-temp)
						  '%32b-incf 'setf)
					     (aref ,dest tmp-dst-index)
					     ,src))
				   )
				  ((:store-direct :store-sum)
				   `(,(store-it t))
				   )
				  (t (warn "~S isn't a store type" rescale-store-type))
				  ))
			    (setq ,@(loop for src in s&s-temps
					  collect src collect 0))
			    ,@(unless (eq rescale-store-type :store-direct)
				`((incf tmp-dst-index)))
			    )))
		      ))
	     (rescale-y-body ()
	       2;;this is the Y-axis body when rescaling
0	       `(progn
		  ,@(when rescale-rolled-y
		     `(,(rescale-x-loop t)))
		 (cond (( diff-y 0)
			,@(unless rescale-rolled-y `(,(rescale-x-loop :)))
			(if (zerop diff-y)
			    (progn (setq src-y-count ,dest-height)
				   (setq dst-y-count ,height)
				   (setq sidx ,(if computed-source-lines
						   `(funcall ,computed-source-lines)
						   `(+ sidx src-y-increment)))
				   ,@(when note-progress
				       `((setq sline (1+ sline))))
				   )
			    
			    (decf src-y-count dst-y-count)
			    (setq dst-y-count ,height)
			    )
			,@(when rescale-rolled-y
			    `((loop for tmp-dst-index from 0 below ,dest-width
				    do
				,(store-it t)
				,@(loop for i in s&s-ars
					collect
					  `(setf (aref ,i tmp-dst-index) 0))
				)))
			(setq didx ,(if computed-dest-lines
					`(funcall ,computed-dest-lines)
					`(+ didx dest-y-increment)))
			)
		       (t			;(minusp diff-y)
			,@(unless rescale-rolled-y `(,(rescale-x-loop :<)))
			(decf dst-y-count src-y-count)
			(setq src-y-count ,dest-height)
			(setq sidx ,(if computed-source-lines
					`(funcall ,computed-source-lines)
					`(+ sidx src-y-increment)))
			,@(when note-progress
			   `((setq sline (1+ sline))))
			)
		       ))
	       )
	     (x-loop-core ()
	       `(do
		  ,@(let ((body-sample (body nil)))
		     (when (and print-message (not compiler:compiling-whole-file-p))
		       (format t "~&body is ~S~&"
			       (lexpr-funcall #'construct-form
					      (if (eq print-message :all)
						  body-sample
						  (car body-sample))
					      args)))
		     (if (and rescale (neq rescale :pixel-average))
			 `(,(rescale-x-body))
			 body-sample))
		 ,@(when (> dest-pixels-per-group 1)
		     `(finally
			,@(body t)
			))
		 ))
	     (rescale-x-loop-1 (store-type)
	       2;; store-type is one of 0:ACCUM-TEMP :SETQ-TEMP :STORE-DIRECT :STORE-SUM
	       (setq rescale-store-type store-type)
	       `(loop with src-x-count = ,dest-width
		      and dst-x-count = ,width
		      ,@(unless rescale-rolled-y
			  (loop for var in s&s-temps 
				collect 'and
				collect var
				collect '=
				collect 0))
		      ,@(if (memq rescale-store-type '(:accum-temp :store-sum
						       :setq-temp))
			    `(and tmp-dst-index = 0
				  while (< tmp-dst-index ,dest-width))
			    `(and last-dest-index = (+ dest-index image-width)
				  while (< dest-index  last-dest-index)))
			,@(x-loop-core)
			))
	     (rescale-x-loop (y-part)
	       (cond (rescale-rolled-y
		      (rescale-x-loop-1 :accum-temp))
		     ((eq rescale :select)
		      (if (eq y-part :)
			  (rescale-x-loop-1 :store-direct)
			  `(progn)))
		     (t (if (eq y-part :)
			    `(if ( prev-diff-y 0)
				 ;store this time, and stored last-time
				 ,(rescale-x-loop-1 :store-direct)
				 ;store this time, accumulated last time
				 ,(rescale-x-loop-1 :store-sum))
			    `(if ( prev-diff-y 0)
				 ;accum this time, stored last time
				 ,(rescale-x-loop-1 :setq-temp)
				 ;accum this time, accum last-time
				 ,(rescale-x-loop-1 :accum-temp))))))
	     (catmull-body-sample ()
	       (when (and print-message (not compiler:compiling-whole-file-p))
		 (let ((body-sample
			 `(progn ,(macroexpand-1
				    (apply-user-function before-per-color nil
							 :state :before-fetch))
				 ,(macroexpand-1
				    (second (image-process-macro-per-color
					      :state :before-fetch
					      :per-color per-color
					      :actual-locals-per-color actual-locals-per-color
					      :intermediate-values intermediate-values
					      :pixel-in-group pixel-in-group
					      :pixels-per-group pixels-per-group)))
				 ,(separate t :inc '(:next-y))
				 ,(macroexpand-1
				    (apply-user-function before-per-color nil
							 :state :pre-load))
				 ,(macroexpand-1
				    (second (image-process-macro-per-color
					      :state :pre-load
					      :per-color per-color
					      :actual-locals-per-color actual-locals-per-color
					      :intermediate-values intermediate-values
					      :pixel-in-group pixel-in-group
					      :pixels-per-group pixels-per-group
					      )))
				 ,(macroexpand-1 (apply-user-function
						   before-per-color nil
						   :state :before-store
						   ))
				 ,(macroexpand-1
				    (second (image-process-macro-per-color
					      :state :before-store
					      :per-color per-color
					      :actual-locals-per-color actual-locals-per-color
					      :intermediate-values intermediate-values
					      :pixel-in-group pixel-in-group
					      :pixels-per-group pixels-per-group								    )))
				 ,(apply-user-function after-per-color nil)
				 ,(store-it :no-inc)
				 ,(macroexpand-1
				    (second (image-process-macro-per-color
					      :state :after-store
					      :per-color per-color
					      :actual-locals-per-color actual-locals-per-color
					      :intermediate-values intermediate-values
					      :pixel-in-group pixel-in-group
					      :pixels-per-group pixels-per-group								    )))

				 )))
		   (format t "~&body is ~S~&"
			   (lexpr-funcall #'construct-form
					  body-sample
					  args)))))
	     (catmull-second-pass-x-loop ()
	       (catmull-body-sample)
	       `(loop for v from v-top below v-bottom
		      with src-index = (+ x sx (* src-span (+ sy v)))
		      and aidx
			 ,@(if (eq catmull-speed :fast)
			       `(with inc = (// .g) 
				 as idx0 =  (max 0 (+ (* .g v) .h))
				   then (max 0 idx1)
				 as idx1 from (+ (* .g (1+ v)) .h) by .g
				 )
			       `(as numer from (+ .g f-y-n) by .g
				 as denom from (+ .i f-y-d) by .i
				 as idx0 = (max 0 (// f-y-n f-y-d))
				 then (max 0 idx1)
				 as idx1 = (// numer denom)
				 ))
		      as lim = (min biased-height (fast-ceiling idx1))
		      ,@(dda-loop-vars catmull-speed)
		      initially
			(setq aidx (fast-ceiling idx0))
			,(separate t :inc '(:next-y))
			(initialize-dda-vars ,catmull-speed)
			,(image-process-macro-per-color
			   :state :initialize
			   :per-color per-color
			   :actual-locals-per-color actual-locals-per-color
			   :intermediate-values intermediate-values
			   :pixel-in-group pixel-in-group
			   :pixels-per-group pixels-per-group)
		      do
		  (progn ,(apply-user-function before-per-color nil :state :before-fetch)
			 ,(image-process-macro-per-color
			    :state :before-fetch
			    :per-color per-color
			    :actual-locals-per-color actual-locals-per-color
			    :intermediate-values intermediate-values
			    :pixel-in-group pixel-in-group
			    :pixels-per-group pixels-per-group)
			 ,(separate t :inc '(:next-y))
			 ,(apply-user-function before-per-color nil :state :pre-load)
			 ,(image-process-macro-per-color
			    :state :pre-load
			    :per-color per-color
			    :actual-locals-per-color actual-locals-per-color
			    :intermediate-values intermediate-values
			    :pixel-in-group pixel-in-group
			    :pixels-per-group pixels-per-group)
			 ,(apply-user-function after-per-color nil)
			 )
		  (loop 
		    ,@(when (eq catmull-speed :slow)
			`(with inc and uedge and inc^2 and 2inc^2
			       and 2uinc+inc^2 
			       and 1-uedge and 1-u^2))
		    while (< aidx lim)
		      do
			(progn
			  (update-dda-slow ,catmull-speed) 
			  ,(apply-user-function before-per-color nil :state :before-store)
			  ,(image-process-macro-per-color
			     :state :before-store
			     :per-color per-color
			     :actual-locals-per-color actual-locals-per-color
			     :intermediate-values intermediate-values
			     :pixel-in-group pixel-in-group
			     :pixels-per-group pixels-per-group)
			  ,(apply-user-function after-per-color nil)
			  (let ((dest-index (+ didx (* dest-span aidx))))
			    ,(store-it :no-inc))
			  ,(image-process-macro-per-color
			     :state :after-store
			     :per-color per-color
			     :actual-locals-per-color actual-locals-per-color
			     :intermediate-values intermediate-values
			     :pixel-in-group pixel-in-group
			     :pixels-per-group pixels-per-group)
			  (update-dda-fast ,catmull-speed))
		    do (incf aidx)
		      )
		  finally
		    (when (< aidx biased-height)
		      ,(apply-user-function before-per-color nil :state :before-final-store)
		      ,(image-process-macro-per-color
			 :state :before-final-store
			 :per-color per-color
			 :actual-locals-per-color actual-locals-per-color
			 :intermediate-values intermediate-values
			 :pixel-in-group pixel-in-group
			 :pixels-per-group pixels-per-group)
		      ,(apply-user-function after-per-color nil)
		      (let ((dest-index (+ didx (* dest-span aidx))))
			,(store-it :no-inc))
		      )
		  )
		  )
	     (catmull-first-pass-x-loop ()
	       (catmull-body-sample)
	       `(loop repeat (1+ intermediate-width)
		      with src-index = 0 and aidx 
			,@(if (eq catmull-speed :fast)
			      `(with inc = (// a)
				as idx0 = .b then idx1
				as idx1 from (+ a .b) by a)
			      `(with ilim = (float intermediate-array-width)
				as numer from (+ f-x-n a) by a
				as denom from (+ f-x-d m) by m
				as idx0 = (- (// f-x-n f-x-d)
					     intermediate-first-offset)
				  then idx1
				as idx1 = (min ilim
					       (- (// numer denom)
						  intermediate-first-offset))
				)
			      )
		      as lim = (fast-ceiling idx1)
		      ,@(dda-loop-vars catmull-speed)
		      initially 
			,(separate t)
			(setq aidx (fast-ceiling idx0))
			(initialize-dda-vars ,catmull-speed)
			,(image-process-macro-per-color
			   :state :initialize
			   :per-color per-color
			   :actual-locals-per-color actual-locals-per-color
			   :intermediate-values intermediate-values
			   :pixel-in-group pixel-in-group
			   :pixels-per-group pixels-per-group)
			(setf (aref lma v) idx0)
		      do
		  (progn ,(apply-user-function before-per-color nil :state :before-fetch)
			 ,(image-process-macro-per-color
			    :state :before-fetch
			    :per-color per-color
			    :actual-locals-per-color actual-locals-per-color
			    :intermediate-values intermediate-values
			    :pixel-in-group pixel-in-group
			    :pixels-per-group pixels-per-group)
			 ,(separate t)
			 ,(apply-user-function before-per-color nil :state :pre-load)
			 ,(image-process-macro-per-color
			    :state :pre-load
			    :per-color per-color
			    :actual-locals-per-color actual-locals-per-color
			    :intermediate-values intermediate-values
			    :pixel-in-group pixel-in-group
			    :pixels-per-group pixels-per-group)
			 ,(apply-user-function after-per-color nil))

		  (loop ,@(when (eq catmull-speed :slow)
			    `(with inc and uedge and inc^2 and 2inc^2 and 2uinc+inc^2
				   and 1-uedge and 1-u^2))
			while (< aidx lim)
			  do
			    (progn (update-dda-slow ,catmull-speed)
				   ,(apply-user-function before-per-color nil
							 :state :before-store)
				   ,(image-process-macro-per-color
				      :state :before-store
				      :per-color per-color
				      :actual-locals-per-color actual-locals-per-color
				      :intermediate-values intermediate-values
				      :pixel-in-group pixel-in-group
				      :pixels-per-group pixels-per-group)
				   ,(apply-user-function after-per-color nil)
				   (let ((dest-index (+ didx aidx)))
				     ,(store-it :no-inc))
				   ,(image-process-macro-per-color
				      :state :after-store
				      :per-color per-color
				      :actual-locals-per-color actual-locals-per-color
				      :intermediate-values intermediate-values
				      :pixel-in-group pixel-in-group
				      :pixels-per-group pixels-per-group)
				   (update-dda-fast ,catmull-speed))
			do (incf aidx)
			  )
	       finally
		;; Close the last open box and write out dest pixel.
		 (when (< aidx intermediate-width)
		   ,(apply-user-function before-per-color nil :state :before-final-store)
		   ,(image-process-macro-per-color
		      :state :before-final-store
		      :per-color per-color
		      :actual-locals-per-color actual-locals-per-color
		      :intermediate-values intermediate-values
		      :pixel-in-group pixel-in-group
		      :pixels-per-group pixels-per-group)
		   ,(apply-user-function after-per-color nil)
		   (let ((dest-index (+ didx aidx)))
		     ,(store-it :no-inc))
		   )
		 (setf (aref rma v) idx1)
		 ))
	     (main-x-loop () 
	       `(loop ,@(if (> dest-pixels-per-group 1)
			    `(with final-dest-group =
				   (+ didx
				      (* (floor ,(if store-multiplier
							   `(* ,store-multiplier (:signed-width :destination))
							   `(:signed-width :destination))
						,dest-pixels-per-group)
					 ,dest-pixels-per-group))
				   until (= ,(if dests 'dest-index 'src-index)
					    final-dest-group))
			    2;note that this test had better remain "=" normally,
0			    2;because some loops are backwards in X!
0			    `(until (= ,(if (and dests store-operator)
					    'dest-index
					    'src-index)
				       last-x-index)))
			,@(x-loop-core)))
	     (core-y-loop ()
	       `(as src-index = sidx
		 ,@(if (and dests store-operator)
		       `(as dest-index = didx
			    as last-x-index = (+ didx image-width))
		       `(as last-x-index = (+ sidx image-width)))
		 ,@(loop for (i init) in locals-per-line nconc
			 `(as ,i = ,init))
		 do (ignore last-x-index)
		 ,@(let ((fn (subst (first sars) :source
				    (apply-user-function before-line nil))))
		     ;2this subst is a bit of ad-hoc communication for :yuv-rgb
0		     (when fn (list fn)))
		 (when per-line-function (funcall per-line-function))
		 ,@(cond ((and rescale (neq rescale :pixel-average))
			  nil)
			 (t `(,(main-x-loop))))
		 ,@(let ((fn (apply-user-function after-line nil)))
		     (when fn (list fn)))
		 (when (> (time:time-difference (time:fixnum-microsecond-time) last-time)
			  500000)
		   (allow-sheet-activity ,@(when source-span-used
					     `(src src-span))
					 ,@(when dest-span-used
					     `(dest dest-span)))
		   (setq last-time (time:fixnum-microsecond-time)))
		 ))
	     (rescale-y-loop ()
	       (setq before-line
		     `(progn (setq diff-y (- src-y-count dst-y-count))
			     ,@(unless (eq rescale :select)
				 `((cond ((plusp diff-y)
					  (setq y-count dst-y-count))
					 (t (setq y-count src-y-count)))))
			     ,(apply-user-function before-line nil))
		     after-line
		     `(progn ,(rescale-y-body)
			     ,(apply-user-function after-line nil)))
	       `(loop ,@(when computed-source-lines
			  `(initially
			     (when from-field
			       (ferror "From-Field nust be NIL with computed source lines")))
			  )
		      ,@(when computed-dest-lines
			  `(initially
			     (when to-field
			       (ferror "To-Field nust be NIL with computed dest lines")))
			  )
		      with src-y-count = (:height :destination)
		      and dst-y-count = (:height)
		      and diff-x and diff-y = 0
		      and fetch-next-time = t
		      ,@(unless computed-source-lines
			  `(and src-y-increment = (:next-y)))
		      ,@(unless computed-dest-lines
			  `(and dest-y-increment  = (:next-y :destination)))
			,@(unless (eq rescale :select)
			    `(and y-count = 0
				  and accum-count))
		      ,@(unless computed-source-lines
			  `(and slast = (:last-y)))
		      ,@(when (and computed-source-lines 
				   (not computed-dest-lines))
			  `(and dlast = (:last-y :destination)))
		      and sidx = ,(if computed-source-lines
				      `(funcall ,computed-source-lines)
				      `(:first-y))
		      and didx = ,(if computed-dest-lines
				      `(funcall ,computed-dest-lines)
				      `(:first-y :destination))
			,@(when note-progress
			    `(with sline = 0))
			,@(unless (or rescale-rolled-y (eq rescale :select))
			    `(as prev-diff-y = diff-y))
		      and image-width = ,(if (and dests store-operator)
					     (if store-multiplier
						 `(* ,store-multiplier (:signed-width :destination))
						 `(:signed-width :destination))
					    (if fetch-multiplier
						 `(* ,fetch-multiplier (:signed-width))
						 `(:signed-width)))
		      until (or (eql sidx ,(if computed-source-lines
					       :end
					       'slast))
				,@(when (and dests store-operator)
				    (cond (computed-dest-lines
					   `((eql didx :end)))
					  (computed-source-lines
					   `((eql didx dlast))))
				))
			,@(core-y-loop)
			,@(when note-progress
			    `((tv:note-progress sline (:height))))
		      finally
			,@(when computed-dest-lines
2						;force out the last line
0			    `((funcall ,computed-dest-lines)))
			))
	     (catmull-second-pass-y-loop ()
	       `(progn
		  (setq last-top-edge (1- intermediate-height)
			last-bottom-edge 0)
		  (loop with biased-height = (1- (:height :destination))
			  ,@(when note-progress
			      `(with 2w = (* 2 (:width :source))))
			for x from 0 below width
			for rx from intermediate-first-offset
			as didx from (+ ,(if store-multiplier
					     `(* dx ,store-multiplier)
					     'dx)
					(* (- dy bias-y) dest-span))
			   ,@(when store-multiplier `(by ,store-multiplier))
			as v-top = (first-pass-start self x)
			as v-bottom = (first-pass-end self x)
			   ,@(if (eq catmull-speed :fast)
				 `(with .g = (- f (// (* b e) a))
					as .h = (+ h (// (* e (- rx d)) a)))
				 `(as mx-a = (- (* m rx) a)
				      as b-nx = (- b (* n rx))
				      as d-px = (- d (* p rx))
				      as .e = (// b-nx mx-a)
				      as .f = (// d-px mx-a)
				      as .h = (+ h (* e .f))
				      as .i = (+ n (* m .e))
				      as .j = (+ p (* m .f))
				      as .g = (+ f (* e .e))
				      as f-y-n = (+ (* .g v-top) .h)
				      as f-y-d = (+ (* .i v-top) .j)))
			   ,@(loop for (i init) in locals-per-line nconc `(as ,i = ,init))
			do
		    (when per-line-function (funcall per-line-function))
		    ,(catmull-second-pass-x-loop)
		    ,@(when note-progress
			`((tv:note-progress (+ x (:width :source)) 2w))
			)
		    (when (> (time:time-difference (time:fixnum-microsecond-time) last-time)
			     500000)
		      (allow-sheet-activity ,@(when source-span-used
						`(src src-span))
					    ,@(when dest-span-used
						`(dest dest-span)))
		      (setq last-time (time:fixnum-microsecond-time)))
		    )))
	     (catmull-first-pass-y-loop ()
	       `(let ((LMA FIRST-PASS-START-ARRAY)
		      (RMA FIRST-PASS-END-ARRAY))
		  (declare (sys:array-register lma rma))
		  (ignore src-span)
		  (loop
		       ,@(when note-progress
			   `(with 2h = (* 2 (:height :destination))))
		     for v from 0 below (:height :destination)
		     as didx first (:first-y :destination)
			     then (+ didx (:next-y :destination))
			,@(if (eq catmull-speed :fast)
			      `(as .b = (- (+ (* b v) d) intermediate-first-offset))
			      `(as f-x-n from d by b
				   as f-x-d from p by n))
			,@(loop for (i init) in locals-per-line
				nconc `(as ,i = ,init))
		     do
		    (when per-line-function (funcall per-line-function))
		    (read-scan-line self v sx sy)
		    ,(catmull-first-pass-x-loop)
		    ,@(when note-progress
			`((tv:note-progress v 2h))
			)
		    (when (> (time:time-difference (time:fixnum-microsecond-time) last-time)
			     500000)
		      (allow-sheet-activity ,@(when source-span-used
						`(src src-span))
					    ,@(when dest-span-used
						`(dest dest-span)))
		      (setq last-time (time:fixnum-microsecond-time))))
		  ))
	     (main-y-loop ()
	       `(loop ,@(when note-progress
			  `(for %line-number below (:height)))
		      ,@(if computed-source-lines
			    `(initially (when from-field
					  (ferror "From-Field nust be NIL with computed source lines"))
					as sidx = (funcall ,computed-source-lines)
					,@(loop for s in source-lines-per-group
						do (ignore s)
						nconc
						`(as s = (funcall ,computed-source-lines))))
			    `(with src-y-increment = (:next-y)
				   and last-y-index = (:last-y)
				   for sidx first (:first-y)
				   then ,(if source-lines-per-group	
					     `(+ sidx (* (1+ ,(length source-lines-per-group))
							 src-y-increment))
					     `(+ sidx src-y-increment))
				   ,@(loop as n = 'sidx then s
					   for s in source-lines-per-group
					   nconc `(as ,s = (+ ,n src-y-increment)))
				   ))
		      ,@(when (and computed-source-lines dests store-operator
				   (not computed-dest-lines))
			  `(with last-y-index = (:last-y :destination)))
		      and image-width = ,(if (and dests store-operator)
					     (if store-multiplier
						 `(* ,store-multiplier (:signed-width :destination))
						 `(:signed-width :destination))
					    (if fetch-multiplier
						 `(* ,fetch-multiplier (:signed-width))
						 `(:signed-width)))
		      ,@(when (and store-operator
				   dests)
			  (if computed-dest-lines
			      `(initially (unless (null to-field)
					   (ferror "to-field must be nil with computed-dest-lines"))
					 as didx = (funcall ,computed-dest-lines))
			      `(with dest-y-increment =  (:next-y :destination)
				     as didx first (:first-y :destination)
				     then (+ didx dest-y-increment))))

		      until (or (eql sidx ,(if computed-source-lines
					       :end
					       'last-y-index))
				,@(when (and computed-source-lines
					     dests store-operator
					     (not computed-dest-lines))
				 `((eql didx last-y-index))
				))
			,@(core-y-loop)
			,@(when note-progress
			    `((tv:note-progress %line-number (:height))))
		      finally ,@(when computed-dest-lines
2				  ;force out the last line
0				  `((funcall ,computed-dest-lines)))
			))
	     (bitblt-main-loop ()
	       `(if (or from-field to-field per-line-function)
		    (loop repeat ,height
			  for sy from (if from-field (+ ,sy from-field -1) ,sy)
			  by (if from-field 2 1)
			  as dy from (if to-field (+ ,dy to-field -1) ,dy)
			  by (if to-field 2 1)
			  do
		      (when per-line-function (funcall per-line-function))
		      ,@(loop for d in dars
			      as ss = sars then (or (cdr ss) sars)
			      as (s) = ss
			      collect
				`(,bitblt-function
				  ,alu
				  ,width 1
				  ,s ,sx sy
				  ,d ,dx dy)))
		    ,@(loop for d in dars
			    as ss = sars then (or (cdr ss) sars)
			    as (s) = ss
			   collect
			     `(,bitblt-function
			       ,alu
			       ,width ,height
			       ,s ,sx ,sy
			       ,d ,dx ,dy))))
	     (main-loop ()
	       (let ((val (selectq main-loop
			    (:bitblt
			     (bitblt-main-loop))
			    (:catmull
			     `(progn
				(unless (and (null from-field)(null to-field))
				  (ferror "FROM-FIELD and TO-FIELD must be NIL for catmull rescaling"))
				    ,(cond ((eq catmull-pass :first)
					    (catmull-first-pass-y-loop))
					   ((eq catmull-pass :second)
					    (catmull-second-pass-y-loop)))))
			    (:rescale
			     (rescale-y-loop))
			    ((:change-aspect-ratio :copy nil) (main-y-loop))
			    (t (ferror "~A is an Unknown main loop" main-loop))
			    )))
		 val)
	       ))

      (when computed-source-lines
	(push `(,src (first ,src)) all-locals)
	(push `(,computed-source-lines (second ,src)) all-locals)
	)
      (when computed-dest-lines
	(push `(,dest (first ,dest)) all-locals)
	(push `(,computed-dest-lines (second ,dest)) all-locals)
	)
      (when (and s&s-ars (neq rescale :select))
	(push `(src-ary-size (* ,height ,width)) all-locals))
      (when (and fetch-multiplier sx (> fetch-multiplier 1))
	(push `(,sx (* ,sx ,fetch-multiplier)) all-locals))
      (when (and store-multiplier dx (> store-multiplier 1))
	(push `(,dx (* ,dx ,store-multiplier)) all-locals))

      (let2*0 ((array-locals
	       `(,@(loop for i in (cdr sars)
			 as j in (cdr sources)
			 collect `(,i ,j))
		 ,@(loop for i in (cdr dars)
			 as j in (cdr dests)
			 collect `(,i ,j))
		 ,@(loop for i in s&s-ars collect `(,i ,i))
		 ,@(loop for i in other-arrays
			 collect (if (listp i) i (list i i))
			   )
		 ))
	     (declare-local-arrays
	       (when (or (cdr sources) (cdr dests) s&s-ars other-arrays)
		 `((declare (array-register-1d
			      ,@(append s&s-ars)
			      ,@(append (cdr sars) (cdr dars))
			      ,@(loop for i in other-arrays
				      collect (if (listp i) (first i) i))
			      )
			    ))))
	     (base
	       `(let* (,@all-locals
		       ,@(when (and s&s-ars (neq rescale :select))
			   `((inv-src-ary-size
			       ,(if (neq rescale :truncated)
				    `(sys:%divide-bignum-step 0 2 src-ary-size)
				    `(+ (sys:%divide-bignum-step 0 1 src-ary-size)
					(if (= src-ary-size
					       (logand src-ary-size (- src-ary-size)))
						;test for power of two
					    0 1)
					)				   
				    ))))
		       (last-time (time:fixnum-microsecond-time))
		       )
		  (ignore last-time)
		  ,@(when computed-source-lines `((ignore ,sx ,sy)))
		  ,@(when computed-dest-lines `((ignore ,dx ,dy)))
		  ,@(when pixels-per-group
		      `((ignore ,dest-height ,width)))
		  2;;prepare the source array loop
0		  (tv:with-prepared-sheet-or-raster
		    (,(if (cdr sources) (first sources) src)
		     :array ,(first sars)
		     :array-only t
		     ,@(when (and src fetch-operator)
			 (if (or bitblt computed-source-lines)
				      `(:declare-array-register t)
				      (setq source-span-used t)
				      `(:span src-span))))
		    
		    1;;prepare the destination array loop.  If there
0		    1;;are no destination arrays, use PROGN
0		    (,@(cond ((and dests store-operator)
			      `(tv:with-prepared-sheet-or-raster
				 (,(if (cdr dests) (first dests) dest)
				  :array ,(first dars)
				  :array-only t				  
				  ,@(if (or bitblt computed-dest-lines)
					`(:declare-array-register t)
					(setq dest-span-used t)
					`(:span dest-span)))))
			     (t `(,'progn)))

		     (let* (,@array-locals) ;separate locals and array locals to help
		       ;the frame splitter choose a good place
		       ,@declare-local-arrays

		     
		     ,@(when first `(,first))
		     
		     ,(main-loop)
		     
		     ,@(when last
			 `(,last))
		     ))))))

	(when jitter
	  (setq base `(with-random-variable (random-value)
			(let* ((jitter-threshold (// threshold 2))
			       (jitter-2 (// jitter-threshold 2)))
			  ,base))))
	(when s&s-ars
	  2;;if we are rescaling, generate and dispose of the temporary arrays
0	  (setq base
		`(tv:with-temp-sheet-rasters
		   (,@(loop for i in s&s-ars
			    collect `(,i ,dest-width :type 'art-fixnum
				      :initial-value 0)))
		   ,base)))
	(when note-progress
	  (setq base `(tv:noting-progress (,(if (eq note-progress t)
						"Image process"
						note-progress))
			,base)))
	(lexpr-funcall #'construct-form base
		       :fetch-multiplier fetch-multiplier
		       :store-multiplier store-multiplier
		       args))
    ))))))
    ))))))
