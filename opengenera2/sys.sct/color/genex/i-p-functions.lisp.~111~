;;;-*- Mode: LISP; Package: (IMAGE-PROCESS); Base: 10.; Lowercase: Yes -*- 


D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD :VERY-LARGE) "BIGFNTB");;
;; Dummy functions to perform clipping (for diagnostics)
;;
0;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
(defun (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")lisp-clip-1-internal0 (dest dx dy w h fun)
  (funcall fun dest dx dy w h))
(def-ip-generic 2clip-1-internal0 (dest dx dy w h fun)
  :function lisp-clip-1-internal
  :template :no-template
  :late-types ((dest rasterp "a raster array")))
(defun 2lisp-clip-2-internal0 (dest dx dy src sx sy w h fun)
  (funcall fun dest dx dy src sx sy w h))
(def-ip-generic 2clip-2-internal0 (dest dx dy src sx sy w h fun)
  :function lisp-clip-2-internal
  :template :no-template
  :late-types ((dest rasterp "a raster array")
	       (src rasterp "a raster array")))
(defun 2lisp-clip-3-internal0 (dest dx dy src sx sy matte mx my w h fun)
  (funcall fun dest dx dy src sx sy matte mx my w h))
(def-ip-generic 2clip-3-internal0 (dest dx dy src sx sy matte mx my w h fun)
  :function lisp-clip-3-internal
  :template :no-template
  :late-types ((dest rasterp "a raster array")
	       (src rasterp "a raster array")
	       (matte rasterp "a raster array")))

(defun 2lisp-clip-4-internal0 (dest dx dy src sx sy matte mx my matte-2 mx-2 my-2 w h fun)
  (funcall fun dest dx dy src sx sy matte mx my matte-2 mx-2 my-2 w h))

(def-ip-generic 2clip-4-internal0 (dest dx dy src sx sy matte mx my matte-2 mx-2 my-2 w h fun)
  :function lisp-clip-4-internal
  :template :no-template
  :late-types ((dest rasterp "a raster array")
	       (src rasterp "a raster array")
	       (matte rasterp "a raster array")
	       (matte-2 rasterp "a raster array")))
 
1;;
;; Core functions that process a rectangle
;; using an arbitrary pixel function
;;

0(defun 2lisp-modify-rectangle
0       (dest dx dy width height plane-mask
	pixel-function &rest pixel-function-other-args)
  
  (process-rectangle-macro
    ((dest dx dy))
    width height plane-mask pixel-function
    :constant-pixel-function nil
    :pixel-function-other-args pixel-function-other-args)
 )

(defun 2lisp-copy-rectangle
0       (dest dx dy src sx sy width height plane-mask
	pixel-function &rest pixel-function-other-args)
  (process-rectangle-macro
    ((dest dx dy)
     (src sx sy))
    width height plane-mask pixel-function
    :constant-pixel-function nil
    :pixel-function-gets-dest nil
    :pixel-function-other-args pixel-function-other-args)
  )
(defun 2lisp-3-array-copy-rectangle
0       (dest dx dy src sx sy src2 s2x s2y  width height plane-mask
	pixel-function &rest pixel-function-other-args)
  (process-rectangle-macro
    ((dest dx dy)
     (src sx sy)
     (src2 s2x s2y))
    width height plane-mask pixel-function
    :constant-pixel-function nil
    :pixel-function-gets-dest nil
    :pixel-function-other-args pixel-function-other-args)
  )

(defun 2lisp-2-array-modify-rectangle
0       (dest dx dy src sx sy width height plane-mask
	pixel-function &rest pixel-function-other-args)
  (process-rectangle-macro
    ((dest dx dy)
     (src sx sy))
    width height plane-mask pixel-function
    :constant-pixel-function nil
    :pixel-function-gets-dest t
    :pixel-function-other-args pixel-function-other-args))

(defun 2lisp-3-array-modify-rectangle
0       (dest dx dy src sx sy src2 s2x s2y  width height plane-mask
	pixel-function &rest pixel-function-other-args)
  (process-rectangle-macro
    ((dest dx dy)
     (src sx sy)
     (src2 s2x s2y))
    width height plane-mask pixel-function
    :constant-pixel-function nil
    :pixel-function-gets-dest t
    :pixel-function-other-args pixel-function-other-args))

(defun 2lisp-4-array-modify-rectangle
0       (dest dx dy src sx sy src2 s2x s2y src3 s3x s3y  width height plane-mask
	pixel-function &rest pixel-function-other-args)
  (process-rectangle-macro
    ((dest dx dy)
     (src sx sy)
     (src2 s2x s2y)
     (src3 s3x s3y))
    width height plane-mask pixel-function
    :constant-pixel-function nil
    :pixel-function-gets-dest t
    :pixel-function-other-args pixel-function-other-args))

1;;
;; Comparison Functions, 0(not implemented by microcode)
1;;

0(defmacro 2compare-2-masked0 (s d m fn)
  `(unless (zerop (logand (logxor ,s ,d) ,m))
     (incf errs)
     (setq err-x x-offset
	   err-y y-offset)
     (when ,fn
       (when (funcall ,fn x-offset y-offset ,s ,d)
	 (return-from y-loop nil)))
     (when ( errs max-n) (return-from y-loop nil))
     ))

(defmacro 2compare-2-=-masked0 (s d m fn)
  `(when (eql (logand ,m ,s)(logand ,m ,d))
     (incf errs)
     (setq err-x x-offset
	   err-y y-offset)
     (when ,fn
       (when (funcall ,fn x-offset y-offset ,s ,d)
	 (return-from y-loop nil)))
     (when ( errs max-n) (return-from y-loop nil))
     ))

(defun 2lisp-compare-arrays0 (dest dx dy src sx sy width height plane-mask
			    &key
			    (max-n)
			    (error-fn))
  (let ((max-n (or max-n
		   (1+ (* width height)))))
    (process-rectangle-macro
      ((dest dx dy)
       (src sx sy))
      width height plane-mask
      compare-2-masked
      :pixel-function-other-args (plane-mask error-fn)
      :store-dest nil
      :vars ((plane-mask plane-mask)
	     (err-x)
	     (err-y)
	     (errs 0))
      :value (values errs err-x err-y)
      )
    ))

(def-ip-generic 2compare-arrays
0		(dest dx dy src sx sy width height plane-mask
		      &key (max-n)(error-fn))
  :function lisp-compare-arrays
  :pixel-function compare-2
  :pixel-function-other-args (plane-mask error-fn)
  :template :no-template
  :late-types ((src rasterp "a raster array")
	       (dest rasterp "a raster array")))

(defun 2lisp-compare-arrays0-= (dest dx dy src sx sy width height plane-mask
			      &key
			      (max-n)
			      (error-fn))
  (let ((max-n (or max-n
		   (1+ (* width height)))))
    (process-rectangle-macro
      ((dest dx dy)
       (src sx sy))
      width height plane-mask
      compare-2-=-masked
      :pixel-function-other-args (plane-mask error-fn)
      :store-dest nil
      :vars ((plane-mask plane-mask)
	     (err-x)
	     (err-y)
	     (errs 0))
      :value (values errs err-x err-y)
      )
    ))

(def-ip-generic 2compare-arrays-=
0		(dest dx dy src sx sy width height plane-mask
		      &key (max-n)(error-fn))
  :function lisp-compare-arrays-=
  :pixel-function compare-2-=
  :pixel-function-other-args (plane-mask error-fn)
  :template :no-template
  :late-types ((src rasterp "a raster array")
	       (dest rasterp "a raster array")))

(defun 2lisp-compare-array-constant0 (dest dx dy width height plane-mask constant
				    &key (max-n)(error-fn))
  (let ((max-n (or max-n (1+ (* width height)))))
    (process-rectangle-macro
      ((dest dx dy))
      width height plane-mask
      compare-2-masked
      :pixel-function-other-args (constant plane-mask error-fn)
      :store-dest nil
      :vars ((plane-mask plane-mask)
	     (err-x)
	     (err-y)
	     (errs 0))
      :value (values errs err-x err-y)
      )))

(def-ip-generic 2compare-array-constant
0		(dest dx dy width height plane-mask constant
		      &key (max-n)(error-fn))
  :function lisp-compare-array-constant
  :pixel-function compare-2
  :pixel-function-other-args (plane-mask error-fn)
  :template :no-template
  :late-types ((src rasterp "a raster array")
	       (dest rasterp "a raster array")))

(defun 2lisp-compare-array-constant-=0 (dest dx dy width height plane-mask constant
				    &key (max-n)(error-fn))
  (let ((max-n (or max-n (1+ (* width height)))))
    (process-rectangle-macro
      ((dest dx dy))
      width height plane-mask
      compare-2-=-masked
      :pixel-function-other-args (constant plane-mask error-fn)
      :store-dest nil
      :vars ((plane-mask plane-mask)
	     (err-x)
	     (err-y)
	     (errs 0))
      :value (values errs err-x err-y)
      )))

(def-ip-generic 2compare-array-constant-=
0		(dest dx dy width height plane-mask constant
		      &key (max-n)(error-fn))
  :function lisp-compare-array-constant-=
  :pixel-function compare-2-=
  :pixel-function-other-args (plane-mask error-fn)
  :template :no-template
  :late-types ((src rasterp "a raster array")
	       (dest rasterp "a raster array")))

(defsubst2 bytewise-pixel-difference0 (a b)
  (combine-rgba (abs (- (ldb (byte 8 0) a) (ldb (byte 8 0) b)))
		(abs (- (ldb (byte 8 8) a) (ldb (byte 8 8) b)))
		(abs (- (ldb (byte 8 16) a) (ldb (byte 8 16) b)))
		(abs (- (%logldb (byte 8 24) a) (%logldb (byte 8 24) b)))))

(defmacro 2compare-bytewise-pixel-difference0 (a b m fn)
  `(unless (zerop (logand (bytewise-pixel-difference ,a ,b) ,m))
     (incf errs)
     (setq err-x x-offset
	   err-y y-offset)
     (when ,fn
       (when (funcall ,fn x-offset y-offset ,a ,b)
	 (return-from y-loop nil)))
     (when ( errs max-n) (return-from y-loop nil))
     )) 

(defun 2lisp-compare-arrays-bytewise0 (dest dx dy src sx sy width height plane-mask
				     &key (max-n)(error-fn))
  (let ((max-n (or max-n (1+ (* width height)))))
    (process-rectangle-macro
      ((dest dx dy)
       (src sx sy))
      width height plane-mask
      compare-bytewise-pixel-difference
      :pixel-function-other-args (plane-mask error-fn)
      :store-dest nil
      :vars ((plane-mask plane-mask)
	     (err-x)
	     (err-y)
	     (errs 0))
      :value (values errs err-x err-y)
      )))

(def-ip-generic 2compare-arrays-bytewise
0		(dest dx dy src sx sy width height plane-mask
		      &key (max-n)(error-fn))
  :function lisp-compare-arrays-bytewise
  :pixel-function compare-2bytewise-pixel-difference
0  :pixel-function-other-args (plane-mask error-fn)
  :template :no-template
  :late-types ((src rasterp "a raster array")
	       (dest rasterp "a raster array")))

(defun 2lisp-compare-array-bytewise-constant
0       (dest dx dy width height plane-mask constant
	&key (max-n)(error-fn))
  (let ((max-n (or max-n (1+(* width height)))))
    (process-rectangle-macro
      ((dest dx dy))
      width height plane-mask
      compare-bytewise-pixel-difference
      :pixel-function-other-args (constant plane-mask error-fn)
      :store-dest nil
      :vars ((plane-mask plane-mask)
	     (err-x)
	     (err-y)
	     (errs 0))
      :value (values errs err-x err-y)
      )))

(def-ip-generic 2compare-array-bytewise-constant
0		(dest dx dy width height plane-mask constant
		      &optional (max-n ) (error-fn))
  :function lisp-compare-array-bytewise-constant
  :pixel-function compare-arrays-bytewise
  :pixel-function-other-args (plane-mask error-fn)
  :template :no-template
  :late-types ((src rasterp "a raster array")
	       (dest rasterp "a raster array")))


1;;
;; Bitblt Analogs
;;
0(defsubst2 boole-s-d 0(s d alu) (boole alu s d)) 

(defun 2lisp-copybits0 (dest dx dy src sx sy width height alu plane-mask)
  (process-rectangle-macro
    ((dest dx dy)
     (src sx sy))
    width height plane-mask boole-s-d
    :bitblt t)
  )

(def-ip-generic 2copybits
0		(dest dx dy src sx sy width height alu plane-mask )
  :function lisp-copybits
  :negative-widths t

(3 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")  ;info the code analysis
0  :template lisp-2-array-modify-rectangle
  :convert-to-dest-units t
  :pixel-function boole-s-d
  :pixel-function-other-args (alu)
  :late-types
  ((dest rasterp "an art-8b or art-fixnum raster")
   (src  rasterp "an art-8b or art-fixnum raster"))
  )

(defun 2lisp-copybits-linear
0       (dest dx dy src sx sy width height alu plane-mask src-span dest-span)
  (tv:with-sheet-bit-array
    dest :both
    (tv:with-sheet-bit-array
      src :input
      (let ((tv:bitblt-unpacking-mask plane-mask)
	    (fun (if (= -1 plane-mask) #'bitblt #'tv:bitblt-masked)))
	(if (or src-span dest-span)
	    (loop repeat height
		  as dxa from dx by (or dest-span 0)
		  as dya from dy by (if dest-span 0 1)
		  as sxa from sx by (or src-span 0)
		  as sya from sy by (if src-span 0 1)
		  do
	      (funcall fun alu width 1 src sxa sya dest dxa dya))
	    (funcall fun alu width height src sx sy dest dx dy)))))
  )

(def-ip-generic 2copybits-linear
0		(dest dx dy src sx sy width height alu plane-mask src-span dest-span)
  :function lisp-copybits-linear
  :negative-widths nil
  :clip :linear
3  ;info the code analysis
0  :template lisp-2-array-modify-rectangle
  :pixel-function boole-s-d
  :pixel-function-other-args (alu)
  :late-types
  ((dest 8-or-32b-rasterp "an art-8b or art-fixnum raster")
   (src (eq (array-type src)(array-type dest)) "the same type of array as dest"))
  )


(def-ip-generic 2copybits-wrap
0		(dest dx dy src sx sy width height alu plane-mask)
  :function lisp-copybits
  :%function %copybits
  :negative-widths nil
  :clip-source nil

3  ;info the code analysis
0  :template lisp-2-array-modify-rectangle
  :pixel-function boole-s-d
  :pixel-function-other-args (alu)
3  ;don't need convert-to-dest-units becuause we don't clip the source anyway
0  :wrap-source t
  :late-types ((dest 8-or-32b-rasterp "an art-8b or art-fixnum raster")
	       (src  8-or-32b-rasterp "an art-8b or art-fixnum raster"))
  )

(defsubst 28b-pix-sum 0(a b)
  (+ a b))
(defsubst 232b-pix-sum0 (a b)
  (combine-rgba
    (8b-pix-sum (ldb (byte 8 0) a) (ldb (byte 8 0) b))
    (8b-pix-sum (ldb (byte 8 8) a) (ldb (byte 8 8) b))
    (8b-pix-sum (ldb (byte 8 16) a) (ldb (byte 8 16) b))
    (8b-pix-sum (ldb (byte 8 24) a) (ldb (byte 8 24) b))))

(defun 2lisp-copybits-sum0 (dest dx dy src sx sy width height plane-mask )
  (if (eql 32 (si:array-element-byte-size dest))
      (if (eql plane-mask -1)
	  (process-rectangle-macro
	    ((dest dx dy)
	     (src sx sy))
	    width height nil 32b-pix-sum
	    :pixel-function-gets-dest t)
	  (process-rectangle-macro
	    ((dest dx dy)
	     (src sx sy))
	    width height plane-mask 32b-pix-sum
	    :pixel-function-gets-dest t))
      (if (eql plane-mask -1)
	  (process-rectangle-macro
	    ((dest dx dy)
	     (src sx sy))
	    width height nil 8b-pix-sum
	    :pixel-function-gets-dest t)
	  (process-rectangle-macro
	    ((dest dx dy)
	     (src sx sy))
	    width height plane-mask 8b-pix-sum
	    :pixel-function-gets-dest t)))
  )

(def-ip-generic 2copybits-sum
0		(dest dx dy src sx sy width height plane-mask )
  :function lisp-copybits-sum
  :negative-widths nil
3  ;info the code analysis
0  :template lisp-2-array-modify-rectangle
  :convert-to-dest-units t
  :pixel-function pix-sum
  :late-types
  ((dest rasterp "an art-8b or art-fixnum raster")
   (src  rasterp "an art-8b or art-fixnum raster"))
  )

#||
;count ones in an array
(defsubst count-pixel (a)
  (cli::bits-on-per-fixnum a))

(defun lisp-count-array (dest dx dy width height )
  (i-p:process-rectangle-macro
    ((dest dx dy))
    width height nil
    count-pixel
    :store-dest nil
    :vars ((sum 0))
    :before-store ((incf sum rpix))
    :value (values sum)
    ))

(def-ip-generic count-array (dest dx dy width height)
  :function lisp-count-array
  :pixel-function count-pixel
  :template :no-template
  :late-types ((dest  8-or-32b-rasterp "a raster array")))
||#


1;;
;; Basic drawing functions
;;
0(defsubst 2boole-const-d0 (d const alu) (boole alu const d  ))

(defun 2lisp-draw-rectangle0 (dest dx dy width height alu value plane-mask)
  (tv:with-sheet-bit-array
    dest :both
    (if (and (= plane-mask -1)
	     (= value -1))
	(tv:%draw-rectangle-internal width height dx dy alu dest)

	(multiple-value-bind (alu tv:bitblt-unpacking-constant tv:bitblt-unpacking-mask)
	    (color:combine-alu-and-data
	      alu
	      (color:effective-write-mask value nil (si:array-element-byte-size dest))
	      (color:effective-write-mask plane-mask nil (si:array-element-byte-size dest)))
	  (tv:%draw-rectangle-internal width height dx dy alu dest))))
  )

(defun 2lisp-draw-rectangle-clipped
0       (width height x-bitpos y-bitpos array alu color plane-mask 
	inside-left inside-top inside-right inside-bottom)

  (when (< x-bitpos inside-left)
    (setq width (- width (- inside-left x-bitpos))
	  x-bitpos inside-left))
  (when (< y-bitpos inside-top)
    (setq height (- height (- inside-top y-bitpos))
	  y-bitpos inside-top))
  (setq width (min width (max 0 (- inside-right x-bitpos))))
  (setq height (min height (max 0 (- inside-bottom y-bitpos))))

  (when (and (plusp width) (plusp height))
    (lisp-draw-rectangle array width height x-bitpos y-bitpos alu color plane-mask)))

(def-ip-generic 2draw-rectangle0 (dest dx dy width height alu value plane-mask)
  :function lisp-draw-rectangle

3  ;info the code analysis
0  :template lisp-modify-rectangle
  :pixel-function boole-const-d
  :pixel-function-other-args (value alu)
  :late-types ((dest rasterp "a raster array"))
  )

(defun 2lisp-draw-triangle
0       (dest x1 y1 x2 y2 x3 y3 alu value plane-mask &key clipping-region)	;
  (ignore dest x1 y1 x2 y2 x3 y3 plane-mask value clipping-region)
  (tv:with-sheet-bit-array
    dest :both
    (if (and (= plane-mask -1)
	     (= value -1))
	(tv:%draw-triangle-internal x1 y1 x2 y2 x3 y3 alu dest clipping-region)

	(multiple-value-bind (alu tv:bitblt-unpacking-constant tv:bitblt-unpacking-mask)
	    (color:combine-alu-and-data
	      alu
	      (color:effective-write-mask value nil (si:array-element-byte-size dest))
	      (color:effective-write-mask plane-mask nil (si:array-element-byte-size dest)))
	  (tv:%draw-triangle-internal x1 y1 x2 y2 x3 y3 alu dest clipping-region))))
  )

(def-ip-generic 2draw-triangle
0       (dest x1 y1 x2 y2 x3 y3 alu value plane-mask &key clipping-region)
  :function lisp-draw-triangle
  :d-x-offset nil :d-y-offset nil
  :width nil :height nil
  :early-types ((x1 numberp "a number")
		(y1 numberp "a number")
		(x2 numberp "a number")
		(y2 numberp "a number")
		(x3 numberp "a number")
		(y3 numberp "a number"))
  :late-types ((dest 8-or-32b-rasterp "an art-8b or art-32b raster"))
  :clip nil
  :clipping-region (clipping-region)
  :d-x-forms (x1 x2 x3)
  :d-y-forms (y1 y2 y3)
  :template :no-template
  )

(defsubst 2draw-line-clip-visibility
0	      (point-x point-y clip-left clip-top clip-right clip-bottom)
  (let ((visibility (cond ((< point-x clip-left) 1)
			  ((>= point-x clip-right) 2)
			  (t 0))))
    (cond ((< point-y clip-top) (logior 4 visibility))
	  ((>= point-y clip-bottom) (logior 8 visibility))
	  (t visibility))))

(defun 2clip-line0 (from-x from-y to-x to-y clip-left clip-top clip-right clip-bottom)
  (loop with to-visibility = (draw-line-clip-visibility
			       to-x to-y
			       clip-left clip-top clip-right clip-bottom)
	and exchanged = nil
	as from-visibility = (draw-line-clip-visibility
			       from-x from-y
			       clip-left clip-top clip-right clip-bottom)

	when (zerop (logior from-visibility to-visibility))
	  do (when exchanged (psetq from-x to-x to-x from-x from-y to-y to-y from-y))
	     (return (values from-x from-y to-x to-y))

	unless (zerop (logand from-visibility to-visibility))
3	  ;;If all off the screen, return NIL as a flag
0	  return nil

	     3;;Exchange points to try to make to point visible
0	when (zerop from-visibility)
	  do (psetq from-x to-x to-x from-x from-y to-y to-y from-y
		    from-visibility to-visibility to-visibility from-visibility
		    exchanged (not exchanged))
	do
3    ;;If TO-X = FROM-X then FROM-VISIBILITY = 0, 4 or 8 so there is no danger
    ;; of divide by zero in the next "Push"
0    (cond ((ldb-test (byte 1 0) from-visibility)	;Push toward left edge
	   (setq from-y (+ from-y (truncate (* (- to-y from-y) (- clip-left from-x))
					    (- to-x from-x)))
		 from-x clip-left))
	  ((ldb-test (byte 1 1) from-visibility)	;Push toward right edge
	   (setq from-y (+ from-y (truncate (* (- to-y from-y) (- clip-right from-x 1))
					    (- to-x from-x)))
		 from-x (1- clip-right))))

    (cond ((ldb-test (byte 1 2) from-visibility)	;Push toward top
	   ;;It is possible that TO-Y = FROM-Y at this point because of the effects of
	   ;; the last "Push", but in that case TO-X is probably equal to FROM-X as well
	   ;; (or at least close to it) so we needn't draw anything:
	   (and (= to-y from-y) (return nil))
	   (setq from-x (+ from-x (truncate (* (- to-x from-x) (- clip-top from-y))
					    (- to-y from-y)))
		 from-y clip-top))
	  ((ldb-test (byte 1 3) from-visibility)	;Push toward bottom
	   ;; Same:
	   (and (= to-y from-y) (return nil))
	   (setq from-x (+ from-x (truncate (* (- to-x from-x) (- clip-bottom from-y 1))
				      (- to-y from-y)))
		 from-y (1- clip-bottom))))
    ))

(defun 2lisp-draw-line
0       (dest x1 y1 x2 y2 alu value plane-mask &key clipping-region (draw-end-point t) )

  (destructuring-bind (left top right bottom) clipping-region
    (multiple-value (x1 y1 x2 y2)	; clip and offset the line to
      (clip-line x1 y1 x2 y2 left top right bottom)))

  (tv:with-sheet-bit-array
    dest :both
    (when (and x1 y1 x2 y2)
      (if (and (= plane-mask -1)
	       (= value -1))
	  (tv:%draw-line-internal x1 y1 x2 y2 alu draw-end-point dest)

	  (multiple-value-bind (alu tv:bitblt-unpacking-constant tv:bitblt-unpacking-mask)
	      (color:combine-alu-and-data
		alu
		(color:effective-write-mask value nil (si:array-element-byte-size dest))
		(color:effective-write-mask plane-mask nil (si:array-element-byte-size dest)))
	    (tv:%draw-line-internal x1 y1 x2 y2 alu draw-end-point dest)))))
  )

(def-ip-generic 2draw-line
0       (dest x1 y1 x2 y2 alu value plane-mask &key clipping-region (draw-end-point t))
  :function lisp-draw-line
  :d-x-offset nil :d-y-offset nil
  :width nil :height nil
  :early-types ((x1 numberp "a number")
		(y1 numberp "a number")
		(x2 numberp "a number")
		(y2 numberp "a number"))
  :late-types ((dest 8-or-32b-rasterp "an art-8b or art-32b raster"))
  :clip nil
  :clipping-region (clipping-region)
  :d-x-forms (x1 x2)
  :d-y-forms (y1 y2)
  :template :no-template
  )

#||
(defun 2lisp-draw-1-bit-raster0 (tv:array tv:to-x tv:to-y tv:pattern tv:from-x tv:from-y
			       tv:w tv:h
			       ones-alu ones-value ones-plane-mask
			       zeros-alu zeros-value zeros-plane-mask
			       &key (fast t))

  (ignore fast)
  (tv:with-sheet-bit-array
    dest :both
    (tv:with-sheet-bit-array
      pattern :both
      (if (eql 1 (si:array-element-byte-size tv:array))
	  (tv:draw-1-bit-raster-from-arrays
	    tv:with-lispm-drawing-environment
	    (ones-alu ones-value ones-plane-mask
		      zeros-alu zeros-value zeros-plane-mask)
	    nil
	    )
	  (tv:draw-color-1-bit-raster-from-arrays
	    tv:with-lispm-drawing-environment
	    (ones-alu ones-value ones-plane-mask
		      zeros-alu zeros-value zeros-plane-mask)
	    nil
	    )
	  ))))

(def-ip-generic 2draw-1-bit-raster 0(dest dx dy 1b-src sx sy width height
					ones-alu ones-value ones-plane-mask
					zeros-alu zeros-value zeros-plane-mask
					&key (fast t))
  :function lisp-draw-1-bit-raster
  :template lisp-modify-rectangle
  :pixel-function boole-1b-const-d
  :late-types ((1b-src (eq (array-type 1b-src) 'art-1b) "an art-1b raster"))
  :early-types ((ones-alu ( 0 ones-alu 15) "an alu code")
		(zeros-alu ( 0 zeros-alu 15) "an alu code")
		(ones-plane-mask fixp "an integer representing a plane mask")
		(zeros-plane-mask fixp "an integer representing a plane mask")
		(ones-value-mask fixp "an integer representing a color")
		(zeros-value-mask fixp "an integer representing a color"))
  )
||#


1;; 
;; 1 bit component shuffling
;;

0

(defsubst 2extract-bit0 (s bit)
  (ldb (byte 1 bit) s))
;
;this lisp code runs at about 0.15 seconds on xl1200 for a 640x484 frame
;
(defun 2lisp-unpacking-bitblt-n1
0       (dest dx dy source sx sy width height alu plane-mask bit)
  (tv:with-sheet-bit-array
    dest :both
    (tv:with-sheet-bit-array
      source :input
      (color:%copy-n-1-internal (sys:array-element-byte-size source)
				width height source sx sy dest dx dy alu bit plane-mask))))

(def-ip-generic 2unpacking-bitblt-n1
0		(1b-dest dx dy source sx sy width height alu plane-mask bit)
  :function lisp-unpacking-bitblt-n1
3  ;info the code analysis
0  :screen-from :source
  :template lisp-copy-rectangle
  :pixel-function extract-bit
  :pixel-function-other-args (bit)
  :pixel-function-gets-dest nil
  :dest '1b-dest
  :source 'source
  :late-types ((source rasterp "A raster array"))
  )

(defsubst insert-bit (s d bit)
  (setf (ldb (byte 1 bit) d) s))

(defun 2lisp-unpacking-bitblt-1n
0       (dest dx dy source sx sy width height alu plane-mask bit)

  (tv:with-sheet-bit-array
    dest :both
    (tv:with-sheet-bit-array
      source :input
      (color:%copy-1-n-internal (sys:array-element-byte-size dest) width height
				source sx sy dest dx dy alu bit plane-mask))))

(def-ip-generic 2unpacking-bitblt-1n
0		(dest dx dy 1b-source sx sy width height alu plane-mask bit)
  :function lisp-unpacking-bitblt-1n
3  ;info the code analysis
0  :template lisp-copy-rectangle
  :pixel-function insert-bit
  :pixel-function-other-args (bit)
  :pixel-function-gets-dest t
  :dest 'dest
  :source '1b-source
  :late-types ((dest rasterp "a raster array"))
  )

(defsubst 2extract-component0 (s component)
  (cl:ecase component
    (:red (ldb (byte 8 0) s))
    (:green (ldb (byte 8 8) s))
    (:blue (ldb (byte 8 16) s))
    (:alpha (ldb (byte 8 24) s))))

(defun 2lisp-unpacking-bitblt-32028
0       (dest dx dy source sx sy width height plane-mask component)
  (tv:with-sheet-bit-array
    dest :both
    (tv:with-sheet-bit-array
      source :input
      (color:%copy-32b-8b-internal width height source sx sy dest dx dy tv:alu-seta
				   (cl:ecase component
				     (:red 0)(:green 1)(:blue 2)(:alpha 3))
				   plane-mask))))

(def-ip-generic 2unpacking-bitblt-328
0		(8b-dest dx dy 32b-source sx sy width height plane-mask component)
  :function lisp-unpacking-bitblt-328

3  ;info the code analysis
0  :template lisp-copy-rectangle
  :pixel-function extract-component
  :pixel-function-other-args (component)
  :pixel-function-gets-dest nil
  )

#|| ;use this version later, when we add ALU to the list
(defun 2lisp-unpacking-bitblt-32028
0       (dest dx dy source sx sy width height alu plane-mask component)
 not-now
  (tv:with-sheet-bit-array
    dest :both
    (tv:with-sheet-bit-array
      source :input
  (color:%copy-32b-8b-internal width height source sx sy dest dx dy alu
			       (cl:ecase component
				 (:red 0)(:green 1)(:blue 2)(:alpha 3))
			       plane-mask))))
(def-ip-generic 2unpacking-bitblt-328
0		(8b-dest dx dy 32b-source sx sy width height alu plane-mask component)
 not-now
  :function lisp-unpacking-bitblt-328
3  ;info the code analysis
0  :template lisp-copy-rectangle
  :pixel-function extract-component
  :pixel-function-other-args (component)
  :pixel-function-gets-dest nil
  )
||#

(defmacro redpb-bytes (src r g b a)
  `(let (,@(unless (eql r  0) `((rb (ldb (byte 8 ,r) ,src))))
	 ,@(unless (eql g  8) `((gb (ldb (byte 8 ,g) ,src))))
	 ,@(unless (eql b 16) `((bb (ldb (byte 8 ,b) ,src))))
	 ,@(unless (eql a 24) `((ab (ldb (byte 8 ,a) ,src)))))
     (sys:%logdpbs
       ,@(unless (eql r 0) `(rb (byte 8 0)))
       ,@(unless (eql g 8) `(gb (byte 8 8)))
       ,@(unless (eql b 16) `(bb (byte 8 16)))
       ,@(unless (eql a 24) `(ab (byte 8 24)))
       ,src)))

(defsubst 2reorder-bytes0 (src2 0r g b a)
  (redpb-bytes src r g b a ))


(defun 2lisp-unpacking-bitblt-3232
0       (dest dx dy source sx sy width height
	plane-mask red-pos green-pos blue-pos alpha-pos)

  (macrolet ((coerce-pos (d)
	       `(setq ,d (cl:ecase ,d (:red 0)(:green 8)(:blue 16)(:alpha 24.)
				   ((0 8 16 24) ,d)))))
    (coerce-pos red-pos)
    (coerce-pos green-pos)
    (coerce-pos blue-pos)
    (coerce-pos alpha-pos))

3  ;optimize plane mask
0  (when (and (eql source dest) (eql sx dx)(eql sy dy))
    (when (zerop (ldb (byte 8 0) plane-mask ))
      (setq plane-mask (%logdpb -1 (byte 8 0) plane-mask))
      (setq red-pos 0))
    (when (zerop (ldb (byte 8 8) plane-mask ))
      (setq plane-mask (%logdpb -1 (byte 8 8) plane-mask))
      (setq green-pos 8))
    (when (zerop (ldb (byte 8 16) plane-mask ))
      (setq plane-mask (%logdpb -1 (byte 8 16) plane-mask))
      (setq blue-pos 16))
    (when (zerop (ldb (byte 8 24) plane-mask ))
      (setq plane-mask (%logdpb -1 (byte 8 24) plane-mask))
      (setq alpha-pos 24)))

  (with-stack-list (pos red-pos green-pos blue-pos alpha-pos)
    (let* ((use-write-mask ( plane-mask -1))
	   (other-args `(color:write-mask)))
      (with-stack-list (spec 32 32 
			     :pixel-function 'reorder-bytes
			     :write-mask use-write-mask
			     :pixel-function-args pos)
	(let ((fun (color:repack-rectangle-function
		     spec
		     :other-args other-args
		     )))
	  (repack-rectangle-with-bus
	    fun width height
	    source sx sy
	    dest dx dy
	    plane-mask
	    ))))))

3;;    Unpacking BITBLT
0(def-ip-generic 2unpacking-bitblt-3232
0	   (dest dx dy source sx sy width height plane-mask
		 red-pos green-pos blue-pos alpha-pos)
  :function lisp-unpacking-bitblt-3232
3  ;info the code analysis
0  :template lisp-copy-rectangle
  :pixel-function reorder-bytes
  :pixel-function-other-args (red-pos green-pos blue-pos alpha-pos)
  :pixel-function-gets-dest nil)


(defsubst 2expand-8b0 (src)
  (let ((v (%logdpb src (byte 8 8) src)))
    (%logdpb v (byte 16 16) v)))

(def-image-process-function 2lisp-unpacking-bitblt-832-internal
0			    expand-8b
  nil
  :source-bpp 8
  :pixel-function-gets-dest nil)

(def-image-process-function 2lisp-unpacking-bitblt-832-masked-internal
0			    expand-8b
  t
  :source-bpp 8
  :pixel-function-gets-dest nil)

(defun 2lisp-unpacking-bitblt-8320 (dest dx dy src sx sy width height plane-mask)
  (repack-rectangle-with-bus
    (if (= plane-mask -1)
	#'lisp-unpacking-bitblt-832-internal
	#'lisp-unpacking-bitblt-832-masked-internal)
    width height
    src sx sy
    dest dx dy
    plane-mask
    ))

(def-ip-generic 2unpacking-bitblt-832
0		(32b-dest dx dy 8b-src sx sy width height plane-mask)
  :function lisp-unpacking-bitblt-832

3  ;info the code analysis
0  :template lisp-copy-rectangle
  :pixel-function expand-8b
  :pixel-function-gets-dest nil)


(defsubst 2expand-8b-mapped0 (src table)
  (aref table src))

(def-image-process-function 2lisp-unpacking-bitblt-832-mapped-internal
0			    expand-8b-mapped
  nil
  :source-bpp 8
  :pixel-function-gets-dest nil
  :other-args (table)
  :pixel-function-args (table)
  :vars ((table table))
  :declarations ((sys:array-register table))
  )

(def-image-process-function 2lisp-unpacking-bitblt-832-masked-mapped-internal
0			    expand-8b-mapped
  t
  :source-bpp 8
  :pixel-function-gets-dest nil
  :other-args (table)
  :pixel-function-args (table)
  :vars ((table table))
  :declarations ((sys:array-register table))
  )

(defun 2lisp-unpacking-bitblt-832-mapped
0       (dest dx dy src sx sy width height plane-mask lookup-table)
  (repack-rectangle-with-bus
    (if (= plane-mask -1)
	#'lisp-unpacking-bitblt-832-mapped-internal
	#'lisp-unpacking-bitblt-832-masked-mapped-internal)
    width height
    src sx sy
    dest dx dy
    plane-mask
    lookup-table
    ))

(def-ip-generic 2unpacking-bitblt-832-mapped
0		(32b-dest dx dy 8b-src sx sy width height plane-mask lookup-table)
  :function lisp-unpacking-bitblt-832-mapped
3  ;info the code analysis
0  :template lisp-copy-rectangle
  :pixel-function expand-8b-mapped
  :pixel-function-other-args (lookup-table)
  :pixel-function-gets-dest nil
  :early-types ((lookup-table (and (arrayp lookup-table)
				   (member (array-type lookup-table)
					   '(art-fixnum art-q))
				   ( (array-length lookup-table) 256.))
			      "an art-fixnum  256 elements"))
  )

(def-image-process-function 2lisp-unpacking-bitblt-88-mapped-internal
0			    expand-8b-mapped
  nil
  :source-bpp 8
  :dest-bpp 8
  :pixel-function-gets-dest nil
  :other-args (table)
  :pixel-function-args (table)
  :vars ((table table))
  :declarations ((sys:array-register table))
  )

(def-image-process-function 2lisp-unpacking-bitblt-88-masked-mapped-internal
0			    expand-8b-mapped
  t
  :source-bpp 8
  :dest-bpp 8
  :pixel-function-gets-dest nil
  :other-args (table)
  :pixel-function-args (table)
  :vars ((table table))
  :declarations ((sys:array-register table))
  )

(defun 2lisp-unpacking-bitblt-88-mapped
0       (dest dx dy src sx sy width height plane-mask lookup-table)
  (repack-rectangle-with-bus
    (if (= plane-mask -1)
	#'lisp-unpacking-bitblt-88-mapped-internal
	#'lisp-unpacking-bitblt-88-masked-mapped-internal)
    width height
    src sx sy
    dest dx dy
    plane-mask
    lookup-table
    ))

(def-ip-generic 2unpacking-bitblt-88-mapped
0		(8b-dest dx dy 8b-src sx sy width height plane-mask lookup-table)
  :function lisp-unpacking-bitblt-88-mapped
3  ;info the code analysis
0  :template lisp-copy-rectangle
  :pixel-function expand-8b-mapped
  :pixel-function-other-args (lookup-table)
  :pixel-function-gets-dest nil
  :early-types ((lookup-table (and (arrayp lookup-table)
				   (member (array-type lookup-table)
					   '(art-fixnum art-q))
				   ( (array-length lookup-table) 256.))
			      "an art-fixnum  256 elements"))
  )


(defsubst 2%remap-4-channels0 (value table)
3 ;this core function remaps four input channels
0 (sys:%logdpbs (ldb (byte 8 24) (aref table (ldb (byte 8 24) value))) (byte 8 24)
		(ldb (byte 8 16) (aref table (ldb (byte 8 16) value))) (byte 8 16)
		(ldb (byte 8 8) (aref table (ldb (byte 8 8) value))) (byte 8 8)
		(aref table (ldb (byte 8 0) value))))

(def-image-process-function 2remap-4-channels-internal0 %remap-4-channels nil
			     3;remap 4 channels without a write mask
0  :other-args (table)
  :pixel-function-args (table)
  :vars ((table table))
  :declarations ((sys:array-register table)))

(def-image-process-function 2remap-4-channels-masked-internal0 %remap-4-channels t
			     3;remap 4 channels without a write mask
0  :other-args (table)
  :pixel-function-args (table)
  :vars ((table table))
  :declarations ((sys:array-register table)))

(defun2 remap-4-channels0 (dest dx dy source-array source-x source-y w h plane-mask lookup-table)
  (if ( plane-mask -1)

      (if (and (eql dest source-array)(eql dx source-x)(eql dy source-y))

	  (si:with-stack-array (lookup 256 :type 'art-fixnum)
	    (let ((lookup-table lookup-table)
		  (lookup lookup))
	      (declare (sys:array-register lookup-table look))
	      (loop for i from 0 below 256
		    as dpb-i = (sys:%logdpbs i (byte 8 24)
					     i (byte 8 16)
					     i (byte 8 8)
					     i)
		    do
		3;build a modified lookup table that includes the write mask
0		(setf (aref lookup i)
		      (logxor dpb-i
			      (logand plane-mask
				      (logxor dpb-i (aref lookup-table i)))))))
	    (repack-rectangle-with-bus
	      #'remap-4-channels-internal
	      w h				
	      source-array source-x source-y
	      dest dx dy
	      plane-mask lookup))

	  (repack-rectangle-with-bus
	    #'remap-4-channels-masked-internal
	    w h				
	    source-array source-x source-y
	    dest dx dy
	    plane-mask lookup-table))
      
      (repack-rectangle-with-bus
	#'remap-4-channels-internal
	w h				
	source-array source-x source-y
	dest dx dy
	plane-mask lookup-table)

      ))

(def-ip-generic 2four-component-lookup
0		   (dest dx dy src sx sy width height plane-mask lookup-table)
  :function remap-4-channels

3  ;info the code analysis
0  :template lisp-copy-rectangle
  :pixel-function %remap-4-channels
  :pixel-function-other-args (table)
  :pixel-function-gets-dest nil
  :early-types ((lookup-table (and (arrayp lookup-table)
				   (member (array-type lookup-table)
					   '(art-fixnum art-q))
				   ( (array-length lookup-table) 256.))
			      "an art-fixnum  256 elements")))

(defsubst 2%remap-3-channels0 (value table)
3 ;this core function remaps three input channels
0 (sys:%logdpbs (ldb (byte 12 20) (aref table (ldb (byte 12 20) value))) (byte 12 20)
	       (ldb (byte 12 8) (aref table (ldb (byte 12 8) value))) (byte 12 8)
	       (aref table (ldb (byte 8 0) value))
	       ))

(def-image-process-function 2remap-3-channels-internal0 %remap-3-channels nil
			     3;remap 3 channels without a write mask
0  :other-args (table)
  :pixel-function-args (table)
  :vars ((table table))
  :declarations ((sys:array-register table)))

(def-image-process-function 2remap-3-channels-masked-internal0 %remap-3-channels t
			     3;remap 3 channels without a write mask
0  :other-args (table)
  :pixel-function-args (table)
  :vars ((table table))
  :declarations ((sys:array-register table)))

(defun2 remap-3-channels
0       (dest dx dy source-array source-x source-y w h plane-mask lookup-table)
  (if ( plane-mask -1)

      (if (and (eql dest source-array)(eql dx source-x)(eql dy source-y))

	  (si:with-stack-array (lookup 4096 :type 'art-fixnum)
	    (let ((lookup-table lookup-table)
		  (lookup lookup))
	      (declare (sys:array-register lookup-table look))
	      (loop for i from 0 below 4096
		    as dpb-i = (sys:%logdpbs i (byte 12 20)
					     i (byte 12 8)
					     i)
		    do
		3;build a modified lookup table that includes the write mask
0		(setf (aref lookup i)
		      (logxor dpb-i
			      (logand plane-mask
				      (logxor dpb-i (aref lookup-table i)))))))
	    (repack-rectangle-with-bus
	      #'remap-3-channels-internal
	      w h				
	      source-array source-x source-y
	      dest dx dy
	      plane-mask lookup))

	  (repack-rectangle-with-bus
	    #'remap-3-channels-masked-internal
	    w h				
	    source-array source-x source-y
	    dest dx dy
	    plane-mask lookup-table))
      
      (repack-rectangle-with-bus
	#'remap-3-channels-internal
	w h				
	source-array source-x source-y
	dest dx dy
	plane-mask lookup-table)

      ))

(def-ip-generic 2three-component-lookup
0		   (dest dx dy src sx sy width height plane-mask lookup-table)
  :function remap-3-channels

3  ;info the code analysis
0  :template lisp-copy-rectangle
  :pixel-function %remap-3-channels
  :pixel-function-other-args (table)
  :pixel-function-gets-dest nil
  :early-types ((lookup-table (and (arrayp lookup-table)
				   (member (array-type lookup-table)
					   '(art-fixnum art-q))
				   ( (array-length lookup-table) 4096.))
			      "an art-fixnum  4096 elements")))

#||

(defun 3-component-invert-table (&optional (identity nil))
  (let ((arr (make-array 4096 :type 'art-fixnum :initial-value 0)))
    (declare (sys:array-register arr))
    (loop for i from 0 to 4095 do
      (setf (aref arr i)
	    (sys:%logdpbs (logxor (if identity 0 #xfff) i) (byte 12 20)
			  (logxor (if identity 0 #xfff) i) (byte 12 8)
			  (if ( i 255) (logxor (if identity 0 #xff) i) 0)
			  )))
    arr))

(defvar 3-c (3-component-invert-table))

(defvar i-c (3-component-invert-table t))

(defun invert (w &optional (table 3-c))
  (let* ((scr (send w :screen))
	 (ar (send w :screen-array))
	 (bm (tv:get-remote-bitmap scr ar)))
    (photon:%three-component-lookup scr
      bm 0 0 bm 0 0 (send w :width) (send w :height) table -1)))

||#


(defsubst 2%remap-1-channel0 (value channel table)
3 ;this core function remaps one input channels
0  (aref table (ldb channel value)))

(defsubst 2%remap-channel0 (value channel table)
3 ;this core function remaps one input channels
0  (aref table (cl:ecase channel
		(:red (ldb (byte 8 0) value))
		(:green (ldb (byte 8 8) value))
		(:blue (ldb (byte 8 16) value))
		(:alpha (ldb (byte 8 24) value)))))

(def-image-process-function 2remap-red-channel-internal0 %remap-1-channel nil
			     3;remap 4 channels without a write mask
0  :other-key-args (:channel :red)
  :other-args (table)
  :pixel-function-args ((byte 8 0) table)
  :vars ((table table))
  :declarations ((sys:array-register table)))

(def-image-process-function 2remap-green-channel-internal0 %remap-1-channel nil
			     3;remap 4 channels without a write mask
0  :other-key-args (:channel :green)
  :other-args (table)
  :pixel-function-args ((byte 8 8) table)
  :vars ((table table))
  :declarations ((sys:array-register table)))

(def-image-process-function 2remap-blue-channel-internal0 %remap-1-channel nil
			     3;remap 4 channels without a write mask
0  :other-key-args (:channel :blue)
  :other-args (table)
  :pixel-function-args ((byte 8 16) table)
  :vars ((table table))
  :declarations ((sys:array-register table)))

(def-image-process-function 2remap-alpha-channel-internal0 %remap-1-channel nil
			     3;remap 4 channels without a write mask
0  :other-key-args (:channel :alpha)
  :other-args (table)
  :pixel-function-args ((byte 8 24) table)
  :vars ((table table))
  :declarations ((sys:array-register table)))

(def-image-process-function 2remap-red-channel-masked-internal0 %remap-1-channel t
			     3;remap 4 channels without a write mask
0  :other-key-args (:channel :red)
  :other-args (table)
  :pixel-function-args ((byte 8 0) table)
  :vars ((table table))
  :declarations ((sys:array-register table)))

(def-image-process-function 2remap-green-channel-masked-internal0 %remap-1-channel t
			     3;remap 4 channels without a write mask
0  :other-key-args (:channel :green)
  :other-args (table)
  :pixel-function-args ((byte 8 8) table)
  :vars ((table table))
  :declarations ((sys:array-register table)))

(def-image-process-function 2remap-blue-channel-masked-internal0 %remap-1-channel t
			     3;remap 4 channels without a write mask
0  :other-key-args (:channel :blue)
  :other-args (table)
  :pixel-function-args ((byte 8 16) table)
  :vars ((table table))
  :declarations ((sys:array-register table)))

(def-image-process-function 2remap-alpha-channel-masked-internal0 %remap-1-channel t
			     3;remap 4 channels without a write mask
0  :other-key-args (:channel :alpha)
  :other-args (table)
  :pixel-function-args ((byte 8 24) table)
  :vars ((table table))
  :declarations ((sys:array-register table)))

(defvar remap-1-channel-functions
	(cl:make-array 8 :initial-contents
		       '(remap-red-channel-internal
			 remap-green-channel-internal
			 remap-blue-channel-internal
			 remap-alpha-channel-internal
			 remap-red-channel-masked-internal
			 remap-green-channel-masked-internal
			 remap-blue-channel-masked-internal
			 remap-alpha-channel-masked-internal
			 )))

(defun2 remap-1-channel
0       (dest dx dy source-array source-x source-y w h plane-mask channel lookup-table )
  (let ((index (+ (if (= plane-mask -1) 0 4)
		  (cl:ecase channel
		    ((0 :red) 0)
		    ((8 :green) 1)
		    ((16 :blue) 2)
		    ((24 :alpha) 3)))))
    (repack-rectangle-with-bus
      (aref remap-1-channel-functions index)
	w h				
	source-array source-x source-y
	dest dx dy
	plane-mask lookup-table)
      ))

(def-ip-generic 2one-component-lookup
0		   (dest dx dy src sx sy width height plane-mask component lookup-table)
  :function remap-1-channel

3  ;info the code analysis
0  :template lisp-copy-rectangle
  :pixel-function %remap-channel
  :pixel-function-other-args (channel table)
  :pixel-function-gets-dest nil
  :early-types ((component (member component '(:red :green :blue :alpha))
			   "one of :RED :GREEN :BLUE :ALPHA")
		(lookup-table (and (arrayp lookup-table)
				   (member (array-type lookup-table)
					   '(art-fixnum art-q))
				   ( (array-length lookup-table) 256.))
			      "an art-fixnum  256 elements")))


(defsubst 2make-simple-random0 (range)
  (color:small-range range (color:simple-random)))

1
;;
;; Dithering and Scattering
;;

3;this is exactly what photon microcode does.   
0(defmacro with-photon-random-variable
	  ((range seed &key (seed1 #o75432015))
	   &body body)
  `(let* ((.avar. ,seed1)
	  ,@(when range `((.max. (+ ,range ,range 1))))
	  (.x0. ,seed))
    ,@body))

(defmacro photon-simple-random-in-range (&optional (max '.max.))
  `(multiple-value-bind (nil val)
       (sys:%divide-bignum-step
	 (setq .x0. (sys:%multiply-bignum-step .avar. .x0.))
	 0
	 ,max)
     val))

(defmacro photon-random-row-step ()
  `(setq .x0. (logxor .x0. 1481875831)))


(defun 2lisp-make-random0 (dest dx dy width height max-amount random-seed )
  (macrolet ((random-in-range ()`(lsh (photon-simple-random-in-range) -1)))
    (if (eql 32 (si:array-element-byte-size dest))
	(%with-displaced-array (dest 8)
	  (lisp-make-random dest (* dx 4) dy (* width 4) height max-amount random-seed))
	(process-rectangle-macro
	  ((dest dx dy))
	  width height nil random-in-range
	  :wrapper (with-photon-random-variable (max-amount random-seed) :body)
	  :row-wrapper (progn (photon-random-row-step) :body)
	  :pixel-function-gets-dest nil
	  :pixel-function-other-args nil)
	)))

(def-ip-generic 2make-random0 (dest dx dy width height max-amount random-seed)
  :function lisp-make-random

3  ;info the code analysis
0  :template lisp-modify-rectangle
  :pixel-function make-simple-random
  :pixel-function-other-args (range)
  :pixel-function-gets-dest nil
  :late-types ((dest 8-or-32b-rasterp "an art-8b or art-fixnum raster"))
  :early-types ((max-amount ( 0 max-amount 255) "a small integer from 0 to 255")
		(random-seed fixp "an integer")))


(defun 2lisp-make-random-four-board-internal
0       (dest dx dy width height max-amount random-seed)
  (let ((random-seed (%logdpb (ldb (byte 2 0) dx) (byte 2 15) random-seed)))
    (macrolet ((random-in-range ()`(lsh (photon-simple-random-in-range) -1)))
      (process-rectangle-macro
	((dest dx dy))
	width height nil random-in-range
	:x-inc 4
	:wrapper (with-photon-random-variable (max-amount random-seed) :body)
	:row-wrapper (progn (photon-random-row-step) :body)
	:pixel-function-gets-dest nil
	:pixel-function-other-args nil)))
  )

(defun 2lisp-make-random-four-board0 (dest dx dy width height max-amount random-seed)
  (if (eql 32 (si:array-element-byte-size dest))
      (%with-displaced-array (dest 8)
	(lisp-make-random-four-board
	  dest (* dx 4) dy (* width 4) height max-amount random-seed)
	)
      (loop repeat 4
	    with q-w = (ldb (byte 30 2) width)
	    for w-count first (ldb (byte 2 0) width) then (1- w-count)
	    for o-count first (- 4 (ldb (byte 2 0) dx)) then (1- o-count)
	    for nx from dx
	    for wdth = (if (plusp w-count) (1+ q-w) q-w)
	    do
	(lisp-make-random-four-board-internal
	  dest nx dy wdth
	  height max-amount random-seed)
	)
      ))

(def-ip-generic 2make-random-four-board
0		(dest dx dy width height max-amount random-seed)
  :function lisp-make-random-four-board
3  ;info the code analysis
0  :template lisp-modify-rectangle
  :pixel-function make-simple-random
  :pixel-function-other-args (range)
  :pixel-function-gets-dest nil
  :late-types ((dest 8-or-32b-rasterp "an art-8b or art-fixnum raster"))
  :early-types ((max-amount ( 0 max-amount 255) "a small integer from 0 to 255")
		(random-seed fixp "an integer")))

(defun 2lisp-scatter0 (dest dx dy src sx sy  width height plane-mask
		     x-amount y-amount random-seed)
  3;random number are not exactly what the microcode does
0  (macrolet ((random-offset-source ()
	       `(let ((y (max sy
			      (min s-h
				   (+ syo
				      y-offset
				      (photon-simple-random-in-range 2y-amount)))))
		      (x (max sx
			      (min s-w
				   (+ sxo
				      x-offset
				      (photon-simple-random-in-range 2x-amount))))))
						3;clip to the source rectangle
0		  (aref src (+ x (* y s-span)))))
	     (prep-source (&body body)
	       `(multiple-value-bind (nil nil s-span) (decode-raster-array src)
		  (let ((src src)
			(s-h (+ sy (1- height)))
			(s-w (+ sx (1- width)))
			(sxo (- sx x-amount))
			(syo (- sy y-amount))
			(2x-amount (+ 1 x-amount x-amount))
			(2y-amount (+ 1 y-amount y-amount)))
		    (declare (sys:array-register-1d src))
		    (with-photon-random-variable (nil random-seed)
		      ,@body
		      )))))
      (process-rectangle-macro
	((dest dx dy))
	width height plane-mask random-offset-source
	:pixel-function-gets-dest nil
	:pixel-function-other-args nil
	:row-wrapper (progn (photon-random-row-step) :body)
	:wrapper (prep-source :body)
	)
      ))
  

(def-ip-generic 2scatter
0		(dest dx dy src sx sy
		      width height plane-mask x-amount y-amount random-seed)
  :function lisp-scatter
  
  :template :no-template
  :early-types ((x-amount ( 0 x-amount 255) "a small integer from 0 to 255")
		(y-amount ( 0 y-amount 255) "a small integer from 0 to 255")
		(random-seed fixp "an integer"))
  :late-types
  ((dest 8-or-32b-rasterp "an art-8b or art-fixnum raster")
   (src (eq (array-type src)(array-type dest)) "the same type of array as dest"))
  )


(defun 2lisp-scatter-array0 (dest dx dy
			   src sx sy
			   rx-array rx-x rx-y
			   ry-array ry-x ry-y
			   width height plane-mask
			   half-amount)
  3;random number are not exactly what the microcode does
0  (macrolet ((random-offset-src (rx ry)
	       `(let ((x (max sx
			      (min s-w
				   (+ sxo
				      x-offset
				      ,rx))))
		      (y (max sy
			      (min s-h
				   (+ syo
				      y-offset
				      ,ry)))))
						3;clip to the src rectangle
0		  (aref src (+ x (* y s-span)))))
	     (prep-src (&body body)
	       `(multiple-value-bind (nil nil s-span) (decode-raster-array src)
		  (let ((src src)
			(s-h (+ sy (1- height)))
			(s-w (+ sx (1- width)))
			(sxo (- sx half-amount))
			(syo (- sy half-amount)))
		    (declare (sys:array-register-1d src))
		    ,@body
		    ))))
    (process-rectangle-macro
      ((dest dx dy)
       (rx-array rx-x rx-y)
       (ry-array ry-x ry-y))
      width height plane-mask random-offset-src
      :pixel-function-gets-dest nil
      :pixel-function-other-args nil
      :wrapper (prep-src :body)
      )))

(def-ip-generic 2scatter-array
0		(dest dx dy
		      source sx sy
		      rx-array rx-x rx-y
		      ry-array ry-x ry-y
		      width height plane-mask
		      half-amount)
  :function lisp-scatter-array
  :other-raster-vars   ((rx-array rx-x rx-y width height)
			(ry-array ry-x ry-y width height))
  :template :no-template
  :late-types ((rx-array art-8b-rasterp "an art-8b raster")
	       (ry-array art-8b-rasterp "an art-8b raster")
	       (dest 8-or-32b-rasterp "an art-8b or art-fixnum raster")
	       (source (eq (array-type source)(array-type dest))
		       "the same type of array as dest")
	       )
  :early-types ((rx-x fixp "an integer")
		(rx-y fixp "an integer")
		(ry-x fixp "an integer")
		(ry-y fixp "an integer")
		(half-amount ( 0 half-amount 255) "an integer from 0 to 255"))
  )

(defun 2lisp-dither0 (dest dx dy src sx sy  width height plane-mask amount random-seed
		    &optional (board 0)(extra-width-for-random 0))
  
  (let ((random-seed (dpb board (byte 2 15) random-seed)))
    (if (eql 8 (si:array-element-byte-size dest))
	(macrolet ((random-offset-source (val)
		     `(let ((dl (- (photon-simple-random-in-range) amount)))
			(max 0 (min 255 (+ dl (ldb (byte 8 0) ,val))))
			)))
	  (process-rectangle-macro
	    ((dest dx dy)
	     (src sx sy))
	    width height plane-mask random-offset-source
	    :pixel-function-gets-dest nil
	    :wrapper (with-photon-random-variable (amount random-seed) :body)
	    :vars ((amount amount))
	    :row-wrapper (progn (photon-random-row-step)
				:body
				(loop repeat extra-width-for-random
				      do (photon-simple-random-in-range))
				)
	    ))
	(macrolet ((random-offset-source (val)
		     `(let ((dl (- (photon-simple-random-in-range) amount)))
			(sys:%logdpbs (max 0 (min 255 (+ dl (ldb (byte 8 8) ,val))))
				      (byte 8 8)
				      (max 0 (min 255 (+ dl (ldb (byte 8 16) ,val))))
				      (byte 8 16)
				      (max 0 (min 255 (+ dl (ldb (byte 8 24) ,val))))
				      (byte 8 24)
				      (max 0 (min 255 (+ dl (ldb (byte 8 0) ,val))))
				      ))))
	  (process-rectangle-macro
	    ((dest dx dy)
	     (src sx sy))
	    width height plane-mask random-offset-source
	    :pixel-function-gets-dest nil
	    :wrapper (with-photon-random-variable (amount random-seed) :body)
	    :vars ((amount amount))
	    :row-wrapper (progn (photon-random-row-step)
				:body
				(loop repeat extra-width-for-random
				      do (photon-simple-random-in-range))
				)
	    ))))
  )

(def-ip-generic 2dither0 (dest dx dy src sx sy  width height plane-mask amount random-seed)
  :function lisp-dither
  :template :no-template
  :late-types
  ((dest 8-or-32b-rasterp "an art-8b or art-fixnum raster")
   (src (eq (array-type src)(array-type dest)) "the same type of array as dest"))
  )

(defun 2lisp-dither-four-board
0       (dest dx dy src sx sy  width height plane-mask amount random-seed)

  (if (eql 32 (si:array-element-byte-size dest))

      (lisp-dither dest dx dy src sx sy  width height plane-mask amount random-seed)

      (let* ((scr (tv:raster-screen dest))
	     (size (or (when scr (send scr :%extra-matte-buffer-size))
		       '(400 200)))
	     (buffer-w (lsh (first size) 2))
	     (buffer-h (second size)))
	(loop with end-x = (+ sx width)
	      for s-y from sy by buffer-h
	      for d-y from dy by buffer-h
	      as remaining-h from height downto 1 by buffer-h
	      as this-h = (min buffer-h remaining-h) do
	  (loop for s-x from sx by buffer-w
		as d-x from dx by buffer-w
		as remaining-w from width downto 1 by buffer-w
		as sub-w = (ceiling (min buffer-w remaining-w) 4)
		as seed = (logxor d-x (lsh d-y 8) random-seed)
		do
	    (loop for board from 0 to 3
		  as s-sub-x from s-x by sub-w
		  as d-sub-x from d-x by sub-w
		  as w = (min sub-w (- end-x s-sub-x))
		  do
	      (lisp-dither dest d-sub-x d-y src s-sub-x s-y
			   w this-h plane-mask amount seed board (- sub-w w))))))))

(def-ip-generic 2dither-four-board
0		(dest dx dy src sx sy  width height plane-mask amount random-seed)
  :function lisp-dither-four-board
  :template :no-template
  :late-types
  ((dest 8-or-32b-rasterp "an art-8b or art-fixnum raster")
   (src (eq (array-type src)(array-type dest)) "the same type of array as dest"))
  )

(defsubst 2sum-source0 (val dl half)
  (let ((dl (- dl half)))
    (sys:%logdpbs 
      (max 0 (min 255 (+ dl (ldb (byte 8 8) val))))
      (byte 8 8)
      (max 0 (min 255 (+ dl (ldb (byte 8 16) val))))
      (byte 8 16)
      (max 0 (min 255 (+ dl (ldb (byte 8 24) val))))
      (byte 8 24)
      (max 0 (min 255 (+ dl (ldb (byte 8 0) val))))
      )))

(defun 2lisp-dither-array0 
       (dest dx dy source sx sy
	r-array r-x r-y
	width height
 	plane-mask
	half-amount)
  (process-rectangle-macro
    ((dest dx dy)
     (source sx sy)
     (r-array r-x r-y))
    width height plane-mask sum-source
    :pixel-function-gets-dest nil
    :pixel-function-other-args (half-amount)
    ))


(def-ip-generic 2dither-array
0		(dest dx dy source sx sy
		      r-array r-x r-y
		      width height 
		      plane-mask 
		      half-amount)
  :function lisp-dither-array
  :other-raster-vars   ((r-array r-x r-y width height))
  :pixel-function sum-source
  :template lisp-copy-rectangle
  :late-types ((r-array art-8b-rasterp "an art-8b raster")
	       (dest 8-or-32b-rasterp "an art-8b or art-fixnum raster")
	       (source (eq (array-type source)(array-type dest))
		       "the same type of array as dest"))
  :early-types ((r-x fixp "an integer")
		(r-y fixp "an integer")
		(half-amount ( 0 half-amount 255) "an integer from 0 to 255"))
  )


(defsubst 2filter-pixel-3x3x8-gauss0 (r00 r01 r02 r10 r11 r12 r20 r21 r22)
  (filter-pixel-3x3x8 :vars (r00 r01 r02 r10 r11 r12 r20 r21 r22)
		      :weights (1 2 1 2 4 2 1 2 1)))
(defsubst 2filter-pixel-3x3x32-gauss0 (r00 r01 r02 r10 r11 r12 r20 r21 r22)
  (filter-pixel-3x3x32 :vars (r00 r01 r02 r10 r11 r12 r20 r21 r22)
		       :weights (1 2 1 2 4 2 1 2 1)))

(defun 2lisp-diffuse-filter0 (dest dx dy src sx sy width height plane-mask)
  (if (eql 8 (tv:array-element-byte-size dest))
      (let ((plane-mask (color:effective-write-mask plane-mask nil 8)))
	(filter-with-mask dest dx dy src sx sy width height plane-mask
			  'filter-pixel-3x3x8-gauss))
      (filter-with-mask dest dx dy src sx sy width height plane-mask
			'filter-pixel-3x3x32-gauss)))

(def-ip-generic 2diffuse-filter0 (dest dx dy src sx sy width height plane-mask)
  :function lisp-diffuse-filter
  :pixel-function filter-pixel-3x3x32-gauss
  :template lisp-copy-rectangle
  :late-types
  ((dest 8-or-32b-rasterp "an art-8b or art-fixnum raster")
   (src (eq (array-type src)(array-type dest)) "the same type of array as dest")
  ))

(defsubst 2filter-pixel-3x3x8-edge-finder0 (r00 r01 r02 r10 r11 r12 r20 r21 r22)
  (filter-pixel-3x3x8 :vars (r00 r01 r02 r10 r11 r12 r20 r21 r22)
		      :weights (-1 -1 -1 -1  8 -1 -1 -1 -1)))

(defsubst 2filter-pixel-3x3x32-edge-finder0 (r00 r01 r02 r10 r11 r12 r20 r21 r22)
  (filter-pixel-3x3x32 :vars (r00 r01 r02 r10 r11 r12 r20 r21 r22)
		       :weights  (-1 -1 -1 -1  8 -1 -1 -1 -1))
  )

(defun 2lisp-edge-finder-filter0 (dest dx dy src sx sy width height plane-mask)
  (if (eql 8 (tv:array-element-byte-size dest))
      (let ((plane-mask (color:effective-write-mask plane-mask nil 8)))
	(filter-with-mask dest dx dy src sx sy width height plane-mask
			  'filter-pixel-3x3x8-edge-finder))
      (filter-with-mask dest dx dy src sx sy width height plane-mask
			'filter-pixel-3x3x32-edge-finder)))

(def-ip-generic 2edge-finder-filter0 (dest dx dy src sx sy width height plane-mask)
  :function lisp-edge-finder-filter
  :pixel-function filter-pixel-3x3x32-edge-finder
  :template lisp-copy-rectangle
  :late-types
  ((dest 8-or-32b-rasterp "an art-8b or art-fixnum raster")
   (src (eq (array-type src)(array-type dest)) "the same type of array as dest")
  ))

(defsubst 2filter-pixel-3x3x8-expand0 (r00 r01 r02 r10 r11 r12 r20 r21 r22)
  (filter-pixel-3x3x8 :vars (r00 r01 r02 r10 r11 r12 r20 r21 r22)
		       :weights  (1 1 1 1 1 1 1 1 1)
		       :combine MAX))
(defsubst 2filter-pixel-3x3x32-expand0 (r00 r01 r02 r10 r11 r12 r20 r21 r22)
  (filter-pixel-3x3x32 :vars (r00 r01 r02 r10 r11 r12 r20 r21 r22)
		       :weights  (1 1 1 1 1 1 1 1 1)
		       :combine MAX))
(defun 2lisp-expand-filter0 (dest dx dy src sx sy width height plane-mask)
  (if (eql 8 (tv:array-element-byte-size dest))
      (let ((plane-mask (color:effective-write-mask plane-mask nil 8)))
	(filter-with-mask dest dx dy src sx sy width height plane-mask
			  'filter-pixel-3x3x8-expand))
      (filter-with-mask dest dx dy src sx sy width height plane-mask
			'filter-pixel-3x3x32-expand)))

(def-ip-generic 2expand-filter0 (dest dx dy src sx sy width height plane-mask)
  :function lisp-expand-filter
  :pixel-function filter-pixel-3x3x32-expand
  :template lisp-copy-rectangle
  :late-types
  ((dest 8-or-32b-rasterp "an art-8b or art-fixnum raster")
   (src (eq (array-type src)(array-type dest)) "the same type of array as dest")
   ))

(defsubst 2filter-pixel-3x3x8-shrink0 (r00 r01 r02 r10 r11 r12 r20 r21 r22)
  (filter-pixel-3x3x8 :vars (r00 r01 r02 r10 r11 r12 r20 r21 r22)
		       :weights  (1 1 1 1 1 1 1 1 1)
		       :combine MIN))
(defsubst 2filter-pixel-3x3x32-shrink0 (r00 r01 r02 r10 r11 r12 r20 r21 r22)
  (filter-pixel-3x3x32 :vars (r00 r01 r02 r10 r11 r12 r20 r21 r22)
		       :weights  (1 1 1 1 1 1 1 1 1)
		       :combine MIN))
(defun 2lisp-shrink-filter0 (dest dx dy src sx sy width height plane-mask)
  (if (eql 8 (tv:array-element-byte-size dest))
      (let ((plane-mask (color:effective-write-mask plane-mask nil 8)))
	(filter-with-mask dest dx dy src sx sy width height plane-mask
			  'filter-pixel-3x3x8-shrink))
      
      (filter-with-mask dest dx dy src sx sy width height plane-mask
			'filter-pixel-3x3x32-shrink)))

(def-ip-generic 2shrink-filter0 (dest dx dy src sx sy width height plane-mask)
  :function lisp-shrink-filter
  :pixel-function filter-pixel-3x3x32-shrink
  :template lisp-copy-rectangle
  :late-types
  ((dest 8-or-32b-rasterp "an art-8b or art-fixnum raster")
   (src (eq (array-type src)(array-type dest)) "the same type of array as dest")
   ))


(defmacro 2median-of-args0 (test &rest args)
  (labels ((bubble-sort-on-vars
	     (test vars index arg
		   &optional (truncate-level (length vars)))
	     3;inline bubble sort on local variables.  "truncate level"
0	     3;is used to stop the bubbling early when the result is no
	     ;longer interesting, as when we only want the median and
0	     3;there are few additional args to be bubbled
0	     (let ((len (length vars)))
	       (cond ((eql index 1) `(setq ,(first vars) ,arg))
		     (( index len)
		      `(cond ((,test ,arg ,(nth (- index 2) vars))
			      (setq ,(nth (1- index) vars) ,arg))
			     (t (setq ,(nth (1- index) vars) ,(nth (- index 2) vars))
				,@(unless (zerop truncate-level)
				    (list (bubble-sort-on-vars test vars (1- index)
							       arg (1- truncate-level)))))))
		     (t `(cond ((,test ,arg ,(car (last vars))))
			       (t ,(bubble-sort-on-vars test vars len arg truncate-level)))
			)))))
    (let* ((nargs (length args))
	   (median-number (floor nargs 2))
	   (vars (loop for i from 1 to median-number
		       collect (make-symbol (format nil "VAR-~S" I)))))

      `(let (,@vars)
	 ,@(loop for i from 1 to nargs
		 as truncate-level from 7 downto 0
		 as arg in args
		 collect (bubble-sort-on-vars test vars i arg truncate-level))
	 ,(car (last vars)))
      )))

(defsubst 2filter-noise-kernal0 (r00 r01 r02 r10 r11 r12 r20 r21 r22
					 atypical-black-threshold
					 atypical-white-threshold)
  (let* ((s (+ r00 r01 r02 r10 r12 r20 r21 r22))
	 (d (- (ash r11 3) s)))
    (cond ((> d atypical-white-threshold) 
	   ;median = fourth from the white end 
	   (median-of-args < r00 r01 r02 r10 r12 r20 r21 r22))
	  ((< d atypical-black-threshold)
	   ;median = fourth from the black end
	   (median-of-args > r00 r01 r02 r10 r12 r20 r21 r22))
	  (t r11)
	  )))

(defsubst 2filter-pixel-3x3x8-noise0 (r00 r01 r02 r10 r11 r12 r20 r21 r22
					 atypical-black-threshold
					 atypical-white-threshold)
  (i-p:filter-pixel-3x3x8
    :weights (1 1 1 1 1 1 1 1 1 1 1)
    :vars (r00 r01 r02 r10 r11 r12 r20 r21 r22
					 atypical-black-threshold
					 atypical-white-threshold)
    :combine filter-noise-kernal))

(defsubst 2filter-pixel-3x3x32-noise0 (r00 r01 r02 r10 r11 r12 r20 r21 r22
					 atypical-black-threshold
					 atypical-white-threshold)
  (i-p:filter-pixel-3x3x32
    :weights (1 1 1 1 1 1 1 1 1 1 1)
    :vars (r00 r01 r02 r10 r11 r12 r20 r21 r22
					 atypical-black-threshold
					 atypical-white-threshold)
    :combine filter-noise-kernal))

(defun 2lisp-noise-filter0 (dest dx dy src sx sy width height plane-mask
			  &key
			  (atypical-dark-threshold 0.1)
			  (atypical-bright-threshold 0.1))
  (let* ((bs (si:array-element-byte-size src))
	 (max-val (ash 1 (min 8 bs)))
	 (black-threshold (- (round (if (floatp atypical-dark-threshold)
					(* max-val atypical-dark-threshold 8)
					atypical-dark-threshold))))
	 (white-threshold (round (if (floatp atypical-bright-threshold)
				     (* max-val atypical-bright-threshold 8)
				     atypical-bright-threshold))))
    (if ( bs 8)
	(filter-with-mask dest dx dy src sx sy width height plane-mask
			  'filter-pixel-3x3x8-noise
			  :kernal-other-args (black-threshold white-threshold))
	(filter-with-mask dest dx dy src sx sy width height plane-mask
			  'filter-pixel-3x3x32-noise
			  :kernal-other-args (black-threshold white-threshold))
	)))

(def-ip-generic 2noise-filter0 (dest dx dy src sx sy width height plane-mask
				   &key
				   (atypical-dark-threshold 0.3)
				   (atypical-bright-threshold 0.3))
  :function lisp-noise-filter
  :template lisp-copy-rectangle
  :late-types
  ((dest rasterp "a raster")
   (src (eq (array-type src)(array-type dest)) "the same type of array as dest")
   ))


(defsubst 28-bit-additive-mix-single0  (8-bit-fixnum-0  8-bit-fixnum-1 fpa )
  3;4.06 uSec on XL400 w FPA
0  (let ((.r. (- (+ 8-bit-fixnum-0  8-bit-fixnum-1)
		(fast-8x8-fractional-multiply-round
		  8-bit-fixnum-0
		  8-bit-fixnum-1
		  fpa))))
    (3min0 255 .r.)))

(defsubst 2additive-mix
0	  (24-bit-pixel-0 24-bit-pixel-1 fpa )
  (combine-rgba
    (8-bit-additive-mix-single (ldb (byte 8 0) 24-bit-pixel-0)
			       (ldb (byte 8 0) 24-bit-pixel-1)
			       fpa)
    (8-bit-additive-mix-single (ldb (byte 8 8) 24-bit-pixel-0)
			       (ldb (byte 8 8) 24-bit-pixel-1)
			       fpa)
    (8-bit-additive-mix-single (ldb (byte 8 16) 24-bit-pixel-0)
			       (ldb (byte 8 16) 24-bit-pixel-1)
			       fpa)
    (8-bit-additive-mix-single (ldb (byte 8 24) 24-bit-pixel-0)
			       (ldb (byte 8 24) 24-bit-pixel-1)
			       fpa)
    ))

(def-soft-matte2 additive-color-mixing0 (dest dx dy src sx sy width height plane-mask )
  additive-mix
  :pixel-function-args ())

(defsubst 2subtractive-mix0 (24-bit-pixel-0  24-bit-pixel-1 fpa )
  (combine-rgba
    (fast-8x8-fractional-multiply-round
      (ldb (byte 8 0) 24-bit-pixel-0)
      (ldb (byte 8 0) 24-bit-pixel-1)
      fpa)
    (fast-8x8-fractional-multiply-round
      (ldb (byte 8 8) 24-bit-pixel-0)
      (ldb (byte 8 8) 24-bit-pixel-1)
      fpa)
    (fast-8x8-fractional-multiply-round
      (ldb (byte 8 16) 24-bit-pixel-0)
      (ldb (byte 8 16) 24-bit-pixel-1)
      fpa)
    (fast-8x8-fractional-multiply-round
      (ldb (byte 8 24) 24-bit-pixel-0)
      (ldb (byte 8 24) 24-bit-pixel-1)
      fpa)))

(def-soft-matte2 subtractive-color-mixing0 (dest dx dy src sx sy width height plane-mask )
  subtractive-mix
  :pixel-function-args ()
  )

(defsubst 2max-rgb-internal0 (pixel ignore)
  (let ((val (max (ldb (byte 8 0) pixel)
		  (ldb (byte 8 8) pixel)
		  (ldb (byte 8 16) pixel))))
    (sys:%logdpbs val (byte 8 8)
		  val (byte 8 16)
		  val (byte 8 24)
		  val)))

(def-soft-matte2 max-rgb0 (dest dx dy src sx sy width height plane-mask )
  max-rgb-internal
  :pixel-function-args ()
  :pixel-function-gets-dest nil
  :use-fpa nil
  )


(defsubst 2fast-24-bit-blend
0	  (8-bit-weight  value-0  value-1 fpa)
3  ;14.3 uSec on XL400 w FPA
0  (combine-rgbx
    (fast-8-bit-blend 8-bit-weight
		      (ldb (byte 8 0) value-0)
		      (ldb (byte 8 0) value-1)
		      fpa)
    (fast-8-bit-blend 8-bit-weight
		      (ldb (byte 8 8) value-0)
		      (ldb (byte 8 8) value-1)
		      fpa)
    (fast-8-bit-blend 8-bit-weight
		      (ldb (byte 8 16) value-0)
		      (ldb (byte 8 16) value-1)
		      fpa)
    value-0
    ))


(defsubst 22arg-soft-matte0 (foreground background fpa)
  (let ((matte (%logldb (byte 8 24) foreground)))
    (selector matte eql
      (0  background)
      (255 (%logdpb foreground (byte 24 0) background))
      (t (fast-24-bit-blend matte background foreground fpa)))))

(def-soft-matte2 soft-matte-simple0 (dest dx dy src sx sy width height plane-mask)
  2arg-soft-matte
  )

(defsubst 22arg-multiply-mattes0 (foreground background pressure fpa)
  (fast-8x8-fractional-multiply-round
    pressure
    (fast-8x8-fractional-multiply-round foreground background fpa)
    fpa))

(def-soft-matte2 multiply-mattes
0		(dest dx dy src sx sy src2 sx2 sy2 width height plane-mask pressure)
  2arg-multiply-mattes
  :pixel-function-args (pressure)
  :pixel-function-gets-dest nil
  :other-raster-vars   ((src2 sx2 sy2 width height))
  :late-types ((dest art-8b-rasterp "an art-8b raster")
	       (src art-8b-rasterp "an art-8b raster")
	       (src2 art-8b-rasterp "an art-8b raster"))
  )

(defsubst 2mix-mattes-internal0 (foreground background pressure fpa)
  (fast-8-bit-blend pressure background foreground fpa))
  
(def-soft-matte 2mix-mattes
0		(dest dx dy src sx sy src2 s2x s2y width height plane-mask pressure)
  mix-mattes-internal
  :pixel-function-args (pressure)
  :pixel-function-gets-dest nil
  :other-raster-vars ((src2 s2x s2y width height))
  :late-types ((src2 art-8b-rasterp "an art-8b raster")
	       (src art-8b-rasterp "an art-8b-raster")
	       (dest art-8b-rasterp "an art-8b-raster"))
  :early-types ((s2x fixp "an integer")
		(s2y fixp "an integer"))
  :wrapper (selector pressure eql
	     (255 (%copybits %screen %sheet
			   dest dx dy src sx sy width height tv:alu-seta plane-mask))
	     (0 (%copybits %screen %sheet
			     dest dx dy src2 s2x s2y width height tv:alu-seta plane-mask))
	     (t :body))
  )

(defsubst 22arg-soft-matte-pressure0 (foreground background pressure fpa)
  (let* ((real-matte (fast-8x8-fractional-multiply-round
		       pressure (%logldb (byte 8 24) foreground) fpa)))
    (selector real-matte eql
      (0   background)
      (255 foreground)
      (t (fast-24-bit-blend real-matte background foreground fpa)))))

(def-soft-matte2 soft-matte-pressure0 (dest dx dy src sx sy width height plane-mask pressure)
  2arg-soft-matte-pressure
  :pixel-function-args (pressure)
  )

(defsubst 22arg-soft-matte-with-stencil-and-pressure
0	  (foreground background pressure fpa)
  (let* ((real-matte (fast-8x8-fractional-multiply-round
		       pressure
		       (fast-8x8-fractional-multiply-round
			 (%logldb (byte 8 24) foreground)
			 (- 255. (%logldb (byte 8 24) background))
			 fpa)
		       fpa)))
    (selector real-matte eql
      (0 background)
      (255 foreground)
      (otherwise
	(fast-24-bit-blend real-matte
			   background
			   foreground
			   fpa)))))

(def-soft-matte2 soft-matte-stencil0 (dest dx dy src sx sy width height plane-mask pressure)
  2arg-soft-matte-with-stencil-and-pressure
  :pixel-function-args (pressure))


;(defsubst 2fast-red-channel-blend
0;	   (8-bit-weight  value-0  value-1 fpa )
;3  ;5.12 uSec on XL400 w FPA
0;  (dpb (fast-8-bit-blend 8-bit-weight
;			 (ldb (byte 8 0) value-0)
;			 (ldb (byte 8 0) value-1)
;			 fpa)
;       (byte 8 0)
;       value-1))
;
(defsubst 2fast-red-with-alpha-channel-blend
0	  (8-bit-weight  value-0  value-1 fpa)
3  ;5.12 uSec on XL400 w FPA
0  (%logdpb
    (fast-8-bit-blend 8-bit-weight
		      (%logldb (byte 8 24) value-0)
		      (ldb (byte 8 0) value-1)
		      fpa)
    (byte 8 24)
    value-0))

3;; foreground contains matte.  Matte foreground red with background alpha.
0(defsubst 22arg-soft-matte-red-with-alpha-channel0 (foreground background pressure fpa)
  (let ((matte (fast-8x8-fractional-multiply-round
		       pressure (%logldb (byte 8 24) foreground)
		       fpa)))
    (selector matte eql
      (0   background)
      (255 (%logdpb (ldb (byte 8 0) foreground) (byte 8 24) background))
      (otherwise
       (fast-red-with-alpha-channel-blend matte background foreground fpa)))))


(def-soft-matte 2soft-matte-add-stencil-from-f-red
0		(dest dx dy src sx sy width height plane-mask pressure )
  2arg-soft-matte-red-with-alpha-channel
  :pixel-function-args (pressure))


(defsubst 23arg-soft-matte-add-stencil-from-f-red-extra-matte
0	  (foreground background xm pressure fpa)
  (let ((matte (fast-8x8-fractional-multiply-round
		 pressure
		 (fast-8x8-fractional-multiply-round
		   xm
		   (%logldb (byte 8 24) foreground)
		   fpa)
		 fpa)))
    (selector matte eql
      (0   background)
      (255 (%logdpb (ldb (byte 8 0) foreground) (byte 8 24) background))
      (otherwise
	(fast-red-with-alpha-channel-blend matte background foreground fpa))
      )))

(def-soft-matte 2soft-matte-add-stencil-from-f-red-extra-matte0 
		 (dest dx dy src sx sy matte mx my width height plane-mask pressure )
  3arg-soft-matte-add-stencil-from-f-red-extra-matte
  :pixel-function-args (pressure)
  :other-raster-vars   ((matte mx my width height))
  )


(defsubst 2fast-32-bit-blend
0	  (8-bit-weight  value-0  value-1 fpa)
3  ;18.5 uSec on XL400 w FPA
0  (combine-rgba
    (fast-8-bit-blend 8-bit-weight
		      (ldb (byte 8 0) value-0)
		      (ldb (byte 8 0) value-1)
		      fpa)
    (fast-8-bit-blend 8-bit-weight
		      (ldb (byte 8 8) value-0)
		      (ldb (byte 8 8) value-1)
		      fpa)
    (fast-8-bit-blend 8-bit-weight
		      (ldb (byte 8 16) value-0)
		      (ldb (byte 8 16) value-1)
		      fpa)
    (fast-8-bit-blend 8-bit-weight
		      (ldb (byte 8 24) value-0)
		      (ldb (byte 8 24) value-1)
		      fpa)))


(defsubst 23arg-soft-matte-rgba-extra-matte0 (foreground background matte pressure fpa)
  (let ((matte (fast-8x8-fractional-multiply-round
		pressure matte fpa)))
    (selector matte eql
      (0  background)
      (255 foreground)
      (otherwise
	(fast-32-bit-blend matte background foreground fpa)))))

(def-soft-matte 2soft-matte-rgba-extra-matte0 
		 (dest dx dy src sx sy  matte mx my width height plane-mask pressure)
  23arg-soft-matte-rgba-extra-matte
0  :other-raster-vars   ((matte mx my width height))
  :pixel-function-args (pressure)
  )

(defsubst 24arg-soft-matte-rgba-2-extra-mattes0 (foreground background matte1 matte2 pressure fpa)
  (let ((matte (fast-8x8-fractional-multiply-round
		 (fast-8x8-fractional-multiply-round
		   pressure matte1 fpa)
		 matte2 fpa)))
    (selector matte eql
      (0   background)
      (255 foreground)
      (otherwise
       (fast-32-bit-blend matte background foreground fpa)))))


(def-soft-matte 2soft-matte-rgba-2-extra-mattes0 
		(dest dx dy
		      src sx sy 
		      matte mx my
		      matte-2 mx-2 my-2
		      width height plane-mask pressure
		      )
  4arg-soft-matte-rgba-2-extra-mattes
  :other-raster-vars   ((matte mx my width height)
			(matte-2 mx-2 my-2 width height)
			)
  :pixel-function-args (pressure)
  )

(defsubst 23arg-soft-matte-stencil-rgba-extra-matte0 (foreground background matte pressure fpa)
  (let ((matte (fast-8x8-fractional-multiply-round
		 (fast-8x8-fractional-multiply-round
		   pressure matte fpa)
		 (- 255 (%logldb (byte 8 24) background)) fpa)))
    (selector matte eql
      (0   background)
      (255 foreground)
      (otherwise
       (fast-32-bit-blend matte background foreground fpa)))))

(def-soft-matte 2soft-matte-rgba-stencil-extra-matte0 
		 (dest dx dy
		       src sx sy
		       matte mx my
		       width height plane-mask pressure)
  23arg-soft-matte-stencil-rgba-extra-matte
0  :other-raster-vars   ((matte mx my width height))
  :pixel-function-args (pressure)
  )


(defsubst 24arg-soft-matte-stencil-rgba-extra-matte0 (foreground background matte1 matte2 pressure fpa)
  (let ((matte (fast-8x8-fractional-multiply-round
		 (fast-8x8-fractional-multiply-round
		   (fast-8x8-fractional-multiply-round
		     pressure matte1 fpa)
		   matte2 fpa)
		 (- 255 (%logldb (byte 8 24) background)) fpa)))
    (selector matte eql
      (0   background)
      (255 foreground)
      (otherwise
       (fast-32-bit-blend matte background foreground fpa)))))

(def-soft-matte 2soft-matte-rgba-stencil-2-extra-mattes0 
		(dest dx dy
		      src sx sy 
		      matte mx my
		      matte-2 mx-2 my-2
		      width height plane-mask pressure)
  4arg-soft-matte-stencil-rgba-extra-matte
  :other-raster-vars   ((matte mx my width height)
			(matte-2 mx-2 my-2))
  :pixel-function-args (pressure)
  )

(defsubst 22arg-soft-matte-constant-alpha0 (foreground background pressure fpa)
  (fast-32-bit-blend pressure background foreground fpa)
  )

(def-soft-matte 2soft-matte-simple-constant-alpha
0		(dest dx dy src sx sy width height plane-mask pressure)
  2arg-soft-matte-constant-alpha
  :pixel-function-args (pressure)
  :wrapper (selector pressure eql
	     (0 )
	     (255 (%copybits %screen %sheet dest dx dy src sx sy
			     width height tv:alu-seta plane-mask)
		  )
	     (t :body))
  )

(defsubst2 rgb02ihs-pixel 0(pixel)
  (if (= 0 (ldb (byte 24 0) pixel))
      pixel
      (let ((r (ldb (byte 8 0) pixel))
	    (g (ldb (byte 8 8) pixel))
	    (b (ldb (byte 8 16) pixel)))
	(let* ((v (max r g b))
	       (x (min r g b))
	       (v-x (- v x))
	       (sat (// (ash v-x 8) v)))
	  (if (not (zerop sat))
	      (let* ((lr (// (ash (- v r) 8) v-x))
		     (lg (// (ash (- v g) 8) v-x))	
		     (lb (// (ash (- v b) 8) v-x))
		     (hue (cond ((= r v)
				 (if (= g x) (+ 1280 lb) (- 256 lg)))
				((= g v)
				 (if (= b x) (+ 256 lr) (- 768 lb)))
				(t
				 (if (= r x) (+ 768 lg) (- 1280 lr))))))
		(sys:%logdpbs v (byte 8 0)
			      (min 255 (// hue 6)) (byte 8 8)
			      (min 255 sat) (byte 8 16)
			      pixel))
	      (sys:%logdpbs v (byte 8 0)
			    0 (byte 16 8)
			    pixel))))))

(defun 2lisp-rgbihs0 (dest dx dy src sx sy width height plane-mask)
  (if (= plane-mask -1)
      (process-rectangle-macro
	((dest dx dy)
	 (src sx sy))
	width height nil rgbihs-pixel
	:pixel-function-gets-dest nil
	)
      (process-rectangle-macro
	((dest dx dy)
	 (src sx sy))
	width height plane-mask rgbihs-pixel
	:pixel-function-gets-dest nil
	)))

(def-ip-generic 2rgbihs0 (dest dx dy src sx sy width height plane-mask)
  :function lisp-rgbihs
  :template lisp-copy-rectangle
  :pixel-function rgbihs-pixel
  :pixel-function-gets-dest nil)

(defsubst 2ihsrgb-pixel0 (pixel)
  (let* ((i (ldb (byte 8 0) pixel))
	 (hue (ldb (byte 8 8) pixel))
	 (sat (ldb (byte 8 16) pixel))
	 (h (// hue 43))
	 (f (min 255 (* 6 (max 0 (- hue (* 43 h))))))
	 (m (ldb (byte 8 8) (* i (- 255 sat))))
	 )
    (macrolet ((n () `(ldb (byte 8 8) (* i (- 255 (ldb (byte 8 8) (* sat f))))))
	       (k () `(ldb (byte 8 8) (* i (- 255 (ldb (byte 8 8) (* sat (- 255 f))))))))
      (multiple-value-bind (r g b)
	  (selector h eql
	    (0 (values i (k) m))
	    (1 (values (n) i m))
	    (2 (values m i (k)))
	    (3 (values m (n) i))
	    (4 (values (k) m i))
	    (5 (values i m (n)))
	    (6 (values i (k) m)))
	(sys:%logdpbs r (byte 8 0)
		      g (byte 8 8)
		      b (byte 8 16)
		      pixel)))))

(defun 2lisp-ihsrgb0 (dest dx dy src sx sy width height plane-mask)
  (if (= plane-mask -1)
      (process-rectangle-macro
	((dest dx dy)
	 (src sx sy))
	width height nil ihsrgb-pixel
	:pixel-function-gets-dest nil
	)
      (process-rectangle-macro
	((dest dx dy)
	 (src sx sy))
	width height plane-mask ihsrgb-pixel
	:pixel-function-gets-dest nil
	)))

(def-ip-generic 2ihsrgb0 (dest dx dy src sx sy width height plane-mask)
  :function lisp-ihsrgb
  :template lisp-copy-rectangle
  :pixel-function rgbihs-pixel
  :pixel-function-gets-dest nil)

(defsubst2 rgb02ihs-pixel-x 0(pixel)
  (if (= 0 (ldb (byte 24 0) pixel))
      pixel
      (let ((r (ldb (byte 8 0) pixel))
	    (g (ldb (byte 8 8) pixel))
	    (b (ldb (byte 8 16) pixel)))
	(let* ((v (max r g b))
	       (x (min r g b))
	       (v-x (- v x))
	       (sat (// (ash v-x 12) v)))
	  (if (not (zerop sat))
	      (let* ((lr (// (ash (- v r) 12) v-x))
		     (lg (// (ash (- v g) 12) v-x))	
		     (lb (// (ash (- v b) 12) v-x))
		     (hue (cond ((= r v)
				 (if (= g x) (+ (* 16 1280) lb) (- (* 16 256) lg)))
				((= g v)
				 (if (= b x) (+ (* 16 256) lr) (- (* 16 768) lb)))
				(t
				 (if (= r x) (+ (* 16 768) lg) (- (* 16 1280) lr))))))
		(sys:%logdpbs (min 4095 (// hue 6)) (byte 12 8)
			      (min 4095 sat) (byte 12 20)
			      v ))
	      (sys:%logdpbs 0 (byte 24 8)
			    v))))))

(defun 2lisp-rgbihs-x0 (dest dx dy src sx sy width height plane-mask)
  (if (= plane-mask -1)
      (process-rectangle-macro
	((dest dx dy)
	 (src sx sy))
	width height nil rgbihs-pixel-x
	:pixel-function-gets-dest nil
	)
      (process-rectangle-macro
	((dest dx dy)
	 (src sx sy))
	width height plane-mask rgbihs-pixel-x
	:pixel-function-gets-dest nil
	)))

(defsubst 2ihsrgb-pixel-x0 (pixel)
  (let* ((i (%logldb (byte 8 0) pixel))
	 (hue (%logldb (byte 12 8) pixel))
	 (sat (%logldb (byte 12 20) pixel))
	 (h (// hue 683))
	 (f (min 4095 (* 6 (max 0 (- hue (* 683 h))))))
	 (m (ldb (byte 8 12) (* i (- 4095 sat))))
	 )
    (macrolet ((n () `(ldb (byte 8 12) (* i (- 4095 (ldb (byte 12 12) (* sat f))))))
	       (k () `(ldb (byte 8 12) (* i (- 4095 (ldb (byte 12 12) (* sat (- 4095 f))))))))
      (multiple-value-bind (r g b)
	  (selector h eql
	    (0 (values i (k) m))
	    (1 (values (n) i m))
	    (2 (values m i (k)))
	    (3 (values m (n) i))
	    (4 (values (k) m i))
	    (5 (values i m (n)))
	    (6 (values i (k) m)))
	(sys:%logdpbs r (byte 8 0)
		      g (byte 8 8)
		      b (byte 8 16)
		      pixel)))))

(defun 2lisp-ihsrgb-x0 (dest dx dy src sx sy width height plane-mask)
  (if (= plane-mask -1)
      (process-rectangle-macro
	((dest dx dy)
	 (src sx sy))
	width height nil ihsrgb-pixel-x
	:pixel-function-gets-dest nil
	)
      (process-rectangle-macro
	((dest dx dy)
	 (src sx sy))
	width height plane-mask ihsrgb-pixel-x
	:pixel-function-gets-dest nil
	)))


(def-ip-generic 2rgbihs-x0 (dest dx dy src sx sy width height plane-mask)
  :function lisp-rgbihs-x
  :template lisp-copy-rectangle
  :pixel-function rgbihs-pixel-x
  :pixel-function-gets-dest nil)

(def-ip-generic 2ihsrgb-x0 (dest dx dy src sx sy width height plane-mask)
  :function lisp-ihsrgb-x
  :template lisp-copy-rectangle
  :pixel-function rgbihs-pixel-x
  :pixel-function-gets-dest nil)

#||
;(defun test (r g b)
;  (let* ((pix (sys:%logdpbs b (byte 8 16) g (byte 8 8) r))
;	 (oihs (rgbihs-pixel pix))
;	 (orgb (ihsrgb-pixel oihs))
;	 (nihs (rgbihs-pixel-x pix))
;	 (nrgb (ihsrgb-pixel-x nihs)))
;    (values (list (ldb (byte 8 0) orgb)(ldb (byte 8 8) orgb)(ldb (byte 8 16) orgb))
;	    (list (ldb (byte 8 0) nrgb)(ldb (byte 8 8) nrgb)(ldb (byte 8 16) nrgb))
;	    (list (- (ldb (byte 8 8) oihs)
;		     (lsh (ldb (byte 12 8) nihs) -4))
;		  (- (ldb (byte 8 16) oihs)
;		     (lsh (ldb (byte 12 20) nihs) -4))
;	    ))))
;
||#

1;;
;; Scale functions
;;

0(defun 2lisp-pixel-replication-zoom 0(dest dx dy source sx sy d-width d-height
				    x-scale y-scale plane-mask
				    &key clipping-region
				    note-progress
				    abort-test-function
				    per-line-function
				    )
  (tv:with-sheet-bit-array
    dest :both
    (tv:with-sheet-bit-array
      source :input
  (destructuring-bind (c-l c-t c-r c-b) clipping-region
    (if (and ( (or c-l dx) dx)
	     ( (or c-t dy) dy)
	     ( (or c-r (+ dx d-width)) (+ dx d-width))
	     ( (or c-b (+ dy d-height)) (+ dy d-height)))
	  
	(color:pixel-replication-zoom-rectangle
	  source dest sx sy (1- x-scale)(1- y-scale)
	  dx dy (+ dx d-width) (+ dy d-height)
	  :note-progress note-progress
	  :abort-test-function abort-test-function
	  :per-line-function per-line-function
	  :write-mask plane-mask)

	(multiple-value-bind (s-w s-h) (decode-raster-array source)
	  (loop with dest-height = d-height
		with sy = sy
		with dy = dy
		while (> dest-height 0)
		as source-height =  (min (- s-h sy) (ceiling dest-height y-scale))
		do
	    (loop with dest-width = d-width
		  with sx = sx
		  with dx = dx
		  while (> dest-width 0)
		  as source-width = (min (- s-w sx) (ceiling dest-width x-scale))
		  do

	      (destructuring-bind (c-l c-t c-r c-b) clipping-region
		(setq c-l (max 0 (or c-l 0))
		      c-t (max 0 (or c-t 0))
		      c-r (min (+ dest-width dx) (or c-r (+ dest-width dx)))
		      c-b (min (+ dest-height dy) (or c-b (+ dest-height dy))))
		(if (or ( dx c-r)( dy c-b))
		    t
		    (with-stack-list (clip c-l c-t c-r c-b)


		      (color:zoom-rectangle
			:from-array source
			:to-array dest
			:to-left dx
			:to-top dy
			:to-right (+ dx (* source-width x-scale))
			:to-bottom (+ dy (* source-height y-scale))
			:from-left sx
			:from-top sy
			:from-right (+ sx source-width)
			:from-bottom (+ sy source-height)
			:write-mask plane-mask
			:to-clipping-rectangle clip
			:rescale :select
			))))

	      (let ((w (* source-width x-scale)))
		(incf dx w)
		(setq sx 0)
		(decf dest-width w)
		))
	    (let ((h (* source-height y-scale)))
	      (incf dy h)
	      (setq sy 0)
	      (decf dest-height h))
	    ))
	  
	)))))

(def-ip-generic 2pixel-replication-zoom
0		(dest dx dy source sx sy dest-width dest-height
		      x-scale y-scale plane-mask
		      &key clipping-region
		      note-progress
		      abort-test-function
		      per-line-function)
  :clip t
  :source-width nil
  :source-height nil
  :function lisp-pixel-replication-zoom
  :template :no-template
  :late-types
  ((dest rasterp "a raster")
   (source (eq (array-type source)(array-type dest)) "the same type of array as dest"))
  )

#||

(defun test (w)
  (let* ((scr (send w :screen))
	 (bitm (tv:get-remote-bitmap scr (send w :screen-array) ) ))
    (send w :clear-window)
    (photon:%draw-point scr tv:alu-seta bitm -1 #xff 2 2)
    (photon:%draw-point scr tv:alu-seta bitm -1 #xff00 2 3)
    (photon:%draw-point scr tv:alu-seta bitm -1 #xff0000 3 2)
    (photon:%draw-point scr tv:alu-seta bitm -1 #xffffff 3 3)
    (photon:%scale-aliased-integer
      scr
      bitm 2 2 2 2
      bitm 20 20 20 20 -1 '(0 0 1000 1000))))

||#
  
(defun 2lisp-scale-aliased0 (dest dx dy source sx sy
			   dest-width dest-height
			   source-width source-height
			   plane-mask
			   &key (rescale :select))
  (tv:with-sheet-bit-array
    dest :both
    (tv:with-sheet-bit-array
      source :input
      (color:zoom-rectangle
	:write-mask plane-mask
	:from-array source
	:to-array dest
	:from-left sx
	:from-top sy
	:to-left dx
	:to-top dy
	:from-right (+ sx source-width)
	:from-bottom (+ sy source-height)
	:to-right (+ dx dest-width)
	:to-bottom (+ dy dest-height)
	:rescale rescale))))

(def-ip-generic 2scale-aliased0 
	   (dest dx dy
	    source sx sy
	    dest-width dest-height
	    source-width source-height
	    plane-mask &key (rescale :select))
  :clip t
  :function lisp-scale-aliased
  :template :no-template
  :late-types
  ((dest 8-or-32b-rasterp "an art-8b or art-fixnum raster")
   (source (eq (array-type source)(array-type dest)) "the same type of array as dest"))
  )
  


;;
3;;   Copy to Quad (and aliased versions)

0(defun 2rotate-and-scale 0(dest dx dy source sx sy width height plane-mask
			 &key
			 (rescale :filter)
			 (d-offset-type :normalized-offset)
			 (scale 1)
			 (x-scale scale)
			 (y-scale scale)
			 (rotate 0)
			 (transpose-xy)
			 (intermediate)
			 (intermediate-x 0)
			 (intermediate-y 0)
			 (center-x (// (+ sx width) 2.0))
			 (center-y (// (+ sy height) 2.0))
			 (allow-remote t))
  (with-stack-list (points sx sy
			   (+ sx width) sy 
			   (+ sx width) (+ sy height)
			   sx (+ sy height))
    (destructuring-bind (x0 y0 x1 y1 x2 y2 x3 y3)
	(color:scaled-and-rotated-points
	  rotate points
	  :scale-x x-scale
	  :scale-y y-scale
	  :transpose-xy transpose-xy
	  :center-x center-x
	  :center-y center-y
	)
      (cl:ecase d-offset-type
	(:normalized-offset
	  (let ((minx (- (min x0 x1 x2 x3) dx))
		(miny (- (min y0 y1 y2 y3) dy)))

	    (decf x0 minx)
	    (decf x1 minx)
	    (decf x2 minx)
	    (decf x3 minx)

	    (decf y0 miny)
	    (decf y1 miny)
	    (decf y2 miny)
	    (decf y3 miny)
	  ))
	(:literal))

      (transform
	dest x0 y0 x1 y1 x2 y2 x3 y3
	source sx sy width height
	plane-mask
	:rescale rescale
	:perspective nil
	:intermediate-x intermediate-x
	:intermediate-y intermediate-y
	:intermediate intermediate
	:allow-remote allow-remote
	)
      )))


;;
3;;   Copy to Quad 
0(defun 2lisp-transform-antialiased
0       (dest x1 y1 x2 y2 x3 y3 x4 y4
	source sx sy width height
	plane-mask
	&key
	(floating-point-slop 0.0001)
	(perspective t)
	(error-p t)
	(intermediate)
	(intermediate-x 0)
	(intermediate-y 0)
	(rescale :filter)
	(allow-remote t)
	)
  (ignore allow-remote)
  (tv:with-sheet-bit-array
    dest :both
    (tv:with-sheet-bit-array
      source :input
      (with-stack-list (quad x1 y1 x2 y2 x3 y3 x4 y4)
	(color:transform-quadrangle
	  :from-array source
	  :to-array dest
	  :scratch-array intermediate
	  :scratch-array-left intermediate-x
	  :scratch-array-top intermediate-y
	  :write-mask plane-mask
	  :to-quad quad
	  :from-left sx
	  :from-top sy
	  :from-right (+ sx width)
	  :from-bottom (+ sy height)
	  :perspective perspective
	  :floating-point-slop floating-point-slop
	  :rescale rescale
	  :error-p error-p 
	  ))))
  )

(def-ip-generic 2transform
0		(dest x1 y1 x2 y2 x3 y3 x4 y4
		 source sx sy width height
		 plane-mask
		 &key
		 Intermediate
		 (intermediate-x 0)
		 (intermediate-y 0)
		 (floating-point-slop 0.0001)
		 (perspective t)
		 (rescale :filter)
		 (error-p t)
		 (allow-remote t)
		 )
  :function lisp-transform-antialiased
  :other-raster-vars
   ((intermediate intermediate-x intermediate-y))
  :late-types
  ((dest 8-or-32b-rasterp "an art-8b or art-fixnum raster")
   (source (eq (array-type source)(array-type dest)) "the same type of array as dest")
   (intermediate (or (null intermediate)
		     (eq (array-type intermediate)(array-type dest)))
		 "an art-fixnum raster or NIL"))
  :early-types ((x1 numberp "a number")
		(y1 numberp "a number")
		(x2 numberp "a number")
		(y2 numberp "a number")
		(x3 numberp "a number")
		(y3 numberp "a number")
		(x4 numberp "a number")
		(y4 numberp "a number")
		(intermediate-x fixp "an integer")
		(intermediate-y fixp "an integer")
		(rescale (member rescale '(:select :average :filter  ))
			 ":select :average or :filter")
		(perspective (member perspective '(t nil)) "T or NIL")
		(floating-point-slop floatp "a flonum"))
  :clip :dest-quad
  :d-x-forms (x1 x2 x3 x4)
  :d-y-forms (y1 y2 y3 y4)
  :template :no-template
  )

#||

()

(defun aatest (w &key (xh 0) remote (ix 0))
  (send w :clear-window)
  ;(i-p:draw-rectangle w 16 16 180 (* 30 (+ 6 xh)) 5 #xff -1)
  ;(i-p:draw-rectangle w 0 0 20 20 5 #xff00 -1)
  (i-p:draw-rectangle w 10 10 4 (+ 4 xh) 5 -1 -1)
  (loop repeat 20
	as n from 1
	for dx from ix by 0.3
	for dy from 0 by 0.17
	as y from 20 by (+ 7 xh) do
    (when ( 10 n 12)
    (send w :display-x-y-centered-string
	  (format nil "~A" n)
	  0 y 20 (+ y 7 xh))
    (i-p:transform w
		   (+ 20 dx) (+ y dy)
		   (+ 20 dx 8)(+ y dy)
		   (+ 20 dx 8)(+ y (+ dy xh) 6)
		   (+ 20 dx) (+ y (+ dy xh) 6)
		   w 8 8 8 (+ 8 xh) -1
		   :intermediate w
		   :allow-remote remote
		   :intermediate-x 40
		   :intermediate-y (floor (+ y dy))
		   ))))

(defvar last-quad nil)
(defun ctest (s d1 d2 &key i quad (rescale :filter)(run-lisp t)(run-photon t))
  (let* ((dw (min (send d1 :inside-width)(send d2 :inside-width)))
	 (dh (min (send d1 :inside-height)(send d2 :inside-height)))
	 (iw (when i (send i :inside-width)))
	 (ih (when i (send i :inside-height)))
	 (screen (send s :screen))
	 (red (send screen :compute-color-alu tv:alu-seta :red))
	 (green (send screen :compute-color-alu tv:alu-seta :green))
	 (background (send screen :compute-color-alu 5 0.2 0.3 0.4)))

    (multiple-value-bind (w h)(send s :inside-size)
      (destructuring-bind (x1 y1 x2 y2 x3 y3 x4 y4) quad
      (let ((x1 (or x1 (random dw)))
	    (x2 (or x2 (random dw)))
	    (x3 (or x3 (random dw)))
	    (x4 (or x4 (random dw)))
	    (y1 (or y1 (random dh)))
	    (y2 (or y2 (random dh)))
	    (y3 (or y3 (random dh)))
	    (y4 (or y4 (random dh))))

	(setq last-quad (list x1 y1 x2 y2 x3 y3 x4 y4))
	(format t "~&~S = ~{~d,~d ~}" 'last-quad last-quad)
	(when run-photon
	  (when i (send i :draw-rectangle iw ih 0 0 green))
	  (send d2 :draw-rectangle dw dh 0 0 background)
	  (send d2 :draw-polygon red x1 y1 x2 y2 x3 y3 x4 y4 x1 y1)
	  (let ((*photon-transform* t))

	    (i-p::transform d2 x1 y1 x2 y2 x3 y3 x4 y4
			    s 0 0 w h
			    -1
			    :rescale rescale
			    :intermediate i
			    :error-p nil)))
	(when run-lisp
	  (when i (send i :draw-rectangle iw ih 0 0 green))
	  (send d1 :draw-rectangle dw dh 0 0 background)
	  (send d1 :draw-polygon red x1 y1 x2 y2 x3 y3 x4 y4 x1 y1)
	  (tv:wait-remote-screen-idle screen)
	  (let ((*photon-transform* nil))
	    (i-p::transform d1 x1 y1 x2 y2 x3 y3 x4 y4	
			    s 0 0 w h
			    -1
			    :rescale rescale
			    :intermediate i
			    :error-p nil)))
	)))))

(defun rtest (s d1 d2
	      &key i scale (y-scale scale)(x-scale scale) rotate
	      (rescale :select)(run-lisp t)(run-photon t)(square))
    (multiple-value-bind (w h)(send s :inside-size)
      (let* ((dw (min (send d1 :inside-width)(send d2 :inside-width)))
	     (dh (min (send d1 :inside-height)(send d2 :inside-height)))
	     (max-scale (// (* 100 (min dh dw))
			    (* (min h w ) (sqrt 2) )))
	     (screen (send i :screen))
	     (green (send screen :compute-color-alu 5 0 1.0 0))
	     (background (send screen :compute-color-alu 5 0.2 0.3 0.4))
	     (iw (when i (send i :inside-width)))	
	     (ih (when i (send i :inside-height)))
	     )
      (unless x-scale
	(setq x-scale (max 0.1 (// (random max-scale) 100.0))))
      (unless y-scale
	(setq y-scale (max 0.1 (// (random max-scale) 100.0))))
      (when square (setq x-scale (setq y-scale (min x-scale y-scale))))
      (unless rotate (setq rotate (// (- (random 7200) 3600) 10.0)))
      (when run-photon 
	(when i (send i :draw-rectangle iw ih 0 0 green))
	(send d2 :draw-rectangle dw dh 0 0 background)
	(let ((*photon-transform* t))
	  (rotate-and-scale d2 0 0
			    s 0 0 w h
			    -1
			    :intermediate i
			    :rescale rescale
			    :rotate rotate
			    :x-scale x-scale
			    :y-scale y-scale)))
      (when run-lisp
	(when i (send i :draw-rectangle iw ih 0 0 green))
	(send d1 :draw-rectangle dw dh 0 0 background)
	(tv:wait-remote-screen-idle screen)
	(let ((*photon-transform* nil))
	  (rotate-and-scale d1 0 0
			    s 0 0 w h
			    -1
			    :intermediate i
			    :rescale rescale
			    :rotate rotate
			    :y-scale y-scale
			    :x-scale x-scale))))))
						
(defun rpat (w)
  (let* ((super (send w :screen))
	(g (send super :compute-color-alu tv:alu-seta 0 1.0 0)) 
	(r (send super :compute-color-alu tv:alu-seta 1.0 0 0))
	(b (send super :compute-color-alu tv:alu-seta 0 0 1.0)))
    (send w :draw-rectangle 1280 1024 0 0 g)
    (send w :draw-rectangle 100 100 10 10 b)
    (send w :draw-rectangle 100 2 10 10 r)
    (send w :draw-rectangle 100 2 10 108 r)
    (loop for i from 10 below 110 by 9 do (send w :draw-rectangle 2 100 i 10 r))
    (send w :draw-rectangle 2 100 108 10 r)
    ))

(defun rpat-test (s d i degrees &key photon)
  (let ((super (send s :screen)))
    (send d :draw-rectangle 1280 1024 0 0
	  (send super :compute-color-alu tv:alu-seta 0.2 0.4 0.6))
    (when i (send i :draw-rectangle 1280 1024 0 0
	  (send super :compute-color-alu tv:alu-seta 1.0 1.0 0)))
    (let ((*photon-transform* photon))
    (rotate-and-scale d 10 10 s 10 10 100 100  -1 :scale 1.5 :rotate degrees
		      :intermediate i :intermediate-x 10 :intermediate-y 10))))

||#


#||

  Function (FLAVOR:METHOD %BITBLT-STIPPLE PHOTON-USER)


(defun btest (w h d dx dy s sx sy npoints i-p-f &rest args)
  (tv:prepare-sheet ((tv:sheet-screen d))
    (loop for i from 1 to npoints do
      (lexpr-funcall i-p-f d (+ dx i) (+ dy i) s sx sy w h -1 args))))


(defun %btest (w h d dx dy s sx sy npoints i-p-f &rest args)
  (tv:prepare-sheet (s)
    (tv:prepare-sheet (d)
  (loop for i from 1 to npoints do
      (lexpr-funcall i-p-f color:color-screen d
		     (tv:sheet-screen-array d) (+ dx i) (+ dy i)
		     (tv:sheet-screen-array s) sx sy
		     w h -1 args)))))

;function only  4375 uSec
;2875
;%function only; 775 uSec
;prepared       1225 uSec


||#


1;;
;; Generics to support photometry
;;
0(def-ip-generic 2geometry-fpu-available-p 0(dest)
  :source nil
  :function (lambda (dest) nil)
  :d-x-offset nil :d-y-offset nil
  :clip nil
  :late-types ((dest rasterp "a raster"))
  :width nil :height nil)

(def-ip-generic 2clear-backface-slots0 (dest &optional four-board)
  :function lisp-clear-backface-slots
  :d-x-offset nil :d-y-offset nil
  :width nil :height nil)

(def-ip-generic 2fill-backface-slots0 (dest a b c d &optional four-board)
  :function lisp-fill-backface-slots
  :d-x-offset nil :d-y-offset nil
  :width nil :height nil
  :early-types ((a floatp "a flonum")
		(b floatp "a flonum")
		(c floatp "a flonum")
		(d floatp "a flonum"))
  )

(def-ip-generic 2geometry-recompute-normals0 (array error-array error-flag &optional four-board)
  :function lisp-geometry-recompute-normals
  :d-x-offset nil :d-y-offset nil
  :width nil :height nil
  :late-types ()
  :dest (array)
  :%wrapper (progn :body
		  (when error-flag
		    (when error-flag
		      (when ( 0 (aref error-array 0 0))
			(ferror "Non-contiguous segments encountered")))))
  )

(def-ip-generic 2geometry-draw-faces
0		(8b-dest dx dy width height
			 matrix x-scale y-scale x-center y-center
			 alu value plane-mask data-raster silhouette hardness draw-backfaces)
  :function lisp-geometry-draw-faces
  :width nil :height nil
  :early-types ((x-scale floatp "a flonum")
		(y-scale floatp "a flonum")
		(x-center floatp "a flonum")
		(y-center floatp "a flonum")
		(hardness floatp "a flonum")
		(silhouette t-or-nil-p "T or NIL")
		(draw-backfaces t-or-nil-p "T or NIL")
		(matrix arrayp "an array"))
  :late-types ((data-raster art-fixnum-rasterp "an art-fixnum raster"))
  )

(def-ip-generic 2geometry-draw-edges
0		(8b-dest dx dy width height
			 matrix x-scale y-scale x-center y-center
			 alu value plane-mask
			 data-raster silhouette hardness draw-backfaces)
  :function lisp-geometry-draw-edges
  :width nil :height nil
  :late-types ()
  :early-types ((x-scale floatp "a flonum")
		(y-scale floatp "a flonum")
		(x-center floatp "a flonum")
		(y-center floatp "a flonum")
		(hardness floatp "a flonum")
		(silhouette t-or-nil-p "T or NIL")
		(draw-backfaces t-or-nil-p "T or NIL")
		(matrix arrayp "an array"))
  )

(def-ip-generic 2draw-object-zbuffered
0       (32b-dest dx dy zbuffer zx zy width height matrix x-scale y-scale x-center y-center
	data-raster  plane-mask &optional four-board)
  :function lisp-draw-object-zbuffered
  :s-x-offset (zx)
  :s-y-offset (zy)
  :source (zbuffer)
  :width nil :height nil
  :early-types ((x-scale floatp "a flonum")
		(y-scale floatp "a flonum")
		(x-center floatp "a flonum")
		(y-center floatp "a flonum")
		(hardness floatp "a flonum")
		(matrix arrayp "an array"))
  :late-types ((data-raster art-fixnum-rasterp "an art-fixnum raster")
	       (zbuffer art-fixnum-rasterp "an art-fixnum raster")
	       )
  )

(defvar 2*cached-gamma-table*0 nil)

(defun 2lisp-cache-gamma-table0 (screen table)	
  (ignore screen table)
  )

(def-ip-generic 2cache-gamma-table0 (dest table)
  :function lisp-cache-gamma-table
  :d-x-offset nil
  :d-y-offset nil
  :width nil :height nil
  :clip nil
  :early-types ((table arrayp "An array"))
  :wrapper (progn (setq *cached-gamma-table* table)
		  :body))

(def-ip-generic 2geometry-calculate-face-colors
0		(array  attribute-array attrbase draw-backfaces gamma? obmat normat
			&optional four-board)
  :function lisp-geometry-calculate-face-colors
  :dest (array)
  :d-x-offset nil
  :d-y-offset nil
  :width nil
  :height nil)

(defmacro 2generate-interpolated-row0 (bytes
				     &key color-start color-end width
				     (pixel-function 'progn)
				     (PREFIX "INTERP-")
				     body
				     floating-steps
				     (single-component))
  3;
0  3;generate an interpolation with WIDTH steps from color-start to color-end,
  ;separating colors into components as specified by BYTES, calling PIXEL-FUNCTION
0  3;with the reconstituted colors.
0  3;
  ;Using SINGLE-COMPONENT with this form makes things somewhat more complex so SHADE-TRIANGLE
0  3;can run two interpolations at once and re-initialize one of the interpolations
  ;halfway through.
0  3;
0  (let* ((start-colors (loop for b in bytes
			     as pos = (if (listp b) (third b) b)
			     collect (intern (format nil "~A~S-START" prefix pos))))
	 (ddw (intern (format nil "~AW" prefix)))
	 (ddi-colors (loop for b in bytes
			   as pos = (if (listp b) (third b) b)
			   collect (intern (format nil "~A~S-DDI" prefix pos))))
	 (de0-colors (loop for b in bytes
			   as pos = (if (listp b) (third b) b)
			   collect (intern (format nil "~A~S-DE0" prefix pos))))
	 (dda-colors (loop for b in bytes
			   as pos = (if (listp b) (third b) b)
			   collect (intern (format nil "~A~S-DDA" prefix pos))))
	 (ddi1-colors (loop for b in bytes
			    as pos = (if (listp b) (third b) b)
			    collect (intern (format nil "~A~S-DDI1" prefix pos))))
	 (all-colors `(,ddw
		       ,@(append start-colors ddi-colors
				 (unless floating-steps
				   (append ddi1-colors de0-colors dda-colors)))))
	 (init-form (when (member single-component '(NIL :INIT))
		      `(let ((1-w (progn (setq ,ddw ,width)
					 (max 1 (1- ,ddw)))))
			 ,@(loop for b in bytes
				 as start in start-colors
				 as ddi in ddi-colors
				 as ddi1 in ddi1-colors
				 as de0 in de0-colors
				 as dda in dda-colors
				 nconc
				   `((let ((end ,(if (eq b t)
						     color-end
						     `(%logldb ,b ,color-end))))
				       (setq ,start ,(if (eq b t)
							 color-start
							 `(%logldb ,b ,color-start)))
				       ,@(if floating-steps
					     `((setq ,ddi (// (- end ,start) 1-w)))
					     `((multiple-value (,ddi ,de0)
						 (truncate (- end ,start) 1-w))
					       (cond ((> end ,start)
						      (setq ,de0 (- ,de0)
							    ,ddi1 1))
						     (t (setq ,ddi1 -1)))
					       (setq ,dda (+ (ash ,ddw -1) ,de0 ))))
				       ))))))
	 (step-form (when (member single-component '(NIL :STEP))
		      (loop for start in start-colors
			    as ddi in ddi-colors
			    as ddi1 in ddi1-colors
			    as de0 in de0-colors
			    as dda in dda-colors
			    nconc
			      `((incf ,start ,ddi)
				,@(unless floating-steps
				    `((incf ,dda ,de0)
				      (cond (( ,dda 0)
					     (incf ,dda ,ddw)
					     (incf ,start ,ddi1))))))
			      )))
	 (color-form (when (member single-component '(NIL :COLOR))
		       (if (cdr bytes)
			   `(sys:%logdpbs ,@(loop for s in (cdr start-colors)
						  as b in (cdr bytes) nconc (list s b))
					  ,(first start-colors))
			   (first start-colors)
			   )))
	 (loop-form `(loop repeat ,width
			   do
		       (,pixel-function ,color-form)
		       ,@(when step-form step-form)
		       ))
	 (form `(,init-form
		 ,loop-form)))
    (cond ((eq single-component :bindings)
	   `(let* (,@all-colors)
	     ,body))
	  ((eq single-component :step)
	   `(progn ,@step-form))
	  ((eq single-component :color) color-form)
	  ((eq single-component :init)
	   init-form)
	  (t `(let (,@all-colors)
		,@form)
	  ))
       ))

(defmacro sort-points (predicate pairs &optional side-effect)
  `(WHEN ,predicate
     ,@(loop for (a b) in pairs collect `(swapf ,a ,b))
     ,@(if side-effect `(,side-effect))))

(defun %triangle-initial-state-calc (dy x1 x2)
  (if (zerop dy)
      (values 0 0 0 0 0)			;Horizontal line segment
						;Slanted line segment
      (let* (b i q r				;Temps to hold computations
	     (dx (- x1 x2))	
	     (l (- (* (1+ (* x1 2)) dy) dx)))
	(setq dy (lsh dy 1)			;Multiply by 2
	      dx (lsh dx 1))
	(multiple-value (b i) (truncate l dy))
	(multiple-value (q r) (truncate dx dy))
	(values dy b q i r))))

(defmacro %draw-triangle-core (body-macro row-macro &key colors bytes floating-colors)
  `(progn    ;; First sort points so that   Y1 > Y2 > Y3
     (sort-points (> y2 y1)
		  ((x1 x2)
		   (y1 y2)
		   ,@(when colors `((,(first colors) ,(second colors))))))
     (sort-points (> y3 y1)
		  ((x1 x3)
		   (y1 y3)
		   ,@(when colors `((,(first colors) ,(third colors))))
		   ))
     (sort-points (> y3 y2)
		  ((x2 x3)
		   (y2 y3)
		   ,@(when colors `((,(second colors) ,(third colors))))
		   ))
     (let ((determinant (- (* (- x1 x2) (- y1 y3))
			   (* (- x1 x3) (- y1 y2)))))
       (when (not (zerop determinant))
	 (,body-macro 
	   (macrolet ((triangle-side-setup (x1 y1 x2 y2 c1 c2)
			(let ((b ',bytes))
	       `(LET ((DY (- ,y1 ,y2)))
		  (IF (PLUSP DETERMINANT)	;Setup parms for Left or Right side
		      (progn (MULTIPLE-VALUE (LY XL XLI XLR XLIR)
			       (%triangle-initial-state-calc DY ,x1 ,x2))
			     ,@(when c1
				 `((generate-interpolated-row ,b
							      :color-start ,c1
							      :color-end ,c2
							      :width (- ,y1 ,y2)
							      :floating-steps ,,floating-colors
							      :single-component :init	
							      :prefix "LEFT-")))
			     )
		      (progn (MULTIPLE-VALUE (RY XR XRI XRR XRIR)
			       (%triangle-initial-state-calc DY ,x1 ,x2))
			     ,@(when c1
				 `((generate-interpolated-row ,b
							      :color-start ,c1
							      :color-end ,c2
							      :floating-steps ,,floating-colors
							      :width (- ,y1 ,y2)
							      :single-component :init
							      :prefix "RIGHT-")))
			     ))
		  (SETQ DETERMINANT (- DETERMINANT))))))	;Det used as flag
		
    ,(let ((form `(let (ly xl					;Left side starting Y, X
			xli xlir		;     x incr integer, x incr remainder
			xlr			;     ???
			 
			ry xr			;Right side starting Y, X
			xri xrir		;     x incr integer, x incr remainder
			xrr)			;     ???
		  
		    ;;**************************************************
		    ;; Setup parameters for left and right side of P1-based segment
		  
		    (triangle-side-setup x1 y1 x2 y2 ,(first colors) ,(second colors))
		    (triangle-side-setup x1 y1 x3 y3 ,(first colors) ,(third colors))

		    ;;**************************************************
		    ;; Do the P1-P2, P1-P3 sided triangle segment from Y1 to Y2
		    ;; then if Y is still greater than Y3, there is a
		    ;;    second segment to be done so set up for P1-P3,P2-P3
		    ;; otherwise P2-P3 is horizontal and we're done

		    (do ((y-limit y2 y3)	;Ending Y value
			 (y (1- y1)))		;Starting Y value - used in computing row addr
		      
			((cond ((< y y3))	;The P2-P3 segment is horizontal or just done
			       ((< y-limit y2)	;Otherwise setup for second triangle
				(triangle-side-setup x2 y2 x3 y3
						     ,(second colors) ,(third colors))
				nil)))

		      (do ()
			  ((< y y-limit))
		      
			;; ******************** Setup for Next Line, Optional Draw
		      
			(when (and (<= ymin y) (< y ymax))
			  3;Setup drawing parms when in bounds
0			  (let* ((l-x (max xl xmin))	;Clip on Left
				 (width (- (min xr xmax) l-x)))	;Clip XR on the right
			    (,row-macro width l-x
			     ,@(if colors
				   `((generate-interpolated-row ,bytes
							       :single-component :color
							       :floating-steps ,floating-colors
							       :prefix "LEFT-")
				     (generate-interpolated-row ,bytes
							       :single-component :color
							       :floating-steps ,floating-colors
							       :prefix "RIGHT-"))))
			    ))
		      
			;; ******************** After Drawing Parameter Adjustments
		      
			(decf y)		;Decrement Row counter
		      
			(decf xl xli)		;Increment Left Side parameters
			(cond ((minusp (decf xlr xlir))	;Reached a Jag, XLR-NEGATE
			       (incf xlr ly)
			       (decf xl))
			      ((>= xlr ly)	;XLR-WRAP
			       (decf xlr ly)
			       (incf xl)))
		      
			(decf xr xri)		;Increment Right side parameters
			(cond ((minusp (decf xrr xrir))	;XRR-NEGATE
			       (incf xrr ry)
			       (decf xr))
			      ((>= xrr ry)	;XRR-WRAP
			       (decf xrr ry)
			       (incf xr)))
			,@(when colors
			    `((generate-interpolated-row ,bytes
							 :single-component :step
							 :floating-steps ,floating-colors
							 :prefix "LEFT-")
			      (generate-interpolated-row ,bytes
							 :single-component :step
							 :floating-steps ,floating-colors
							 :prefix "RIGHT-")))
			)
		      ))))
       (if colors
	   `(generate-interpolated-row ,bytes
	      :prefix "LEFT-"
	      :single-component :bindings
	      :floating-steps ,floating-colors
	      :body (generate-interpolated-row ,bytes
		      :prefix "RIGHT-"
		      :single-component :bindings
		      :floating-steps ,floating-colors
		      :body ,form))
	   form)
       )
    ))))))

(defun 2lisp-draw-grad-row-internal
0       (dest x y width color-start color-end plane-mask)
  (macrolet ((set-aref (val)
	       `(progn (setf (aref dest idx) ,val)
		       (incf idx)))
	     (mask-set-aref (new-val)
	       `(let* ((val (aref dest idx)))
		  (setf (aref dest idx)
			(logxor val (logand plane-mask (logxor val ,new-val))))
		  (incf idx)
		  )))
    (let* ((span (si:array-row-span dest))
	   (idx (+ x (* y span)))
	   (byte-size (si:array-element-byte-size dest))
	   (dest dest))
      (declare (sys:array-register-1d dest))
      (if (eql plane-mask -1)
	  (if (eql 8 byte-size)
	      (generate-interpolated-row
		((byte 8 0))
		:color-start color-start
		:color-end color-end
		:width width
		:pixel-function set-aref)
	      (generate-interpolated-row
		((byte 8 0)(byte 8 8)(byte 8 16)(byte 8 24))
		:color-start color-start
		:color-end color-end
		:width width
		:pixel-function set-aref))
	  (if (eql 8 byte-size)
	      (generate-interpolated-row
		((byte 8 0))
		:color-start color-start
		:color-end color-end
		:width width
		:pixel-function mask-set-aref)
	      (generate-interpolated-row
		((byte 8 0)(byte 8 8)(byte 8 16)(byte 8 24))
		:color-start color-start
		:color-end color-end
		:width width
		:pixel-function mask-set-aref))))
    ))

(defun 2lisp-draw-grad-row
0       (dest x y width color-start color-end plane-mask)
  (tv:with-sheet-bit-array
    dest :output 
    (lisp-draw-grad-row-internal dest x y width color-start color-end plane-mask)))

(def-ip-generic 2draw-grad-row
0		(dest x y width color-start color-end plane-mask)
  :function lisp-draw-grad-row
  :height nil
  :template :no-template
  :late-types ((dest 8-or-32b-rasterp "an art-8b or art-fixnum raster"))
  )

(defun 2lisp-draw-grad-triangle
0       (dest x1 y1 x2 y2 x3 y3 color1 color2 color3 plane-mask &key clipping-region)
  (tv:with-sheet-bit-array dest :both
    (macrolet ((draw-triangle-internal (body)
	       `(destructuring-bind (xmin ymin xmax ymax) clipping-region
		  ,body))
	     (draw-triangle-row (width l-x color1 color2)
	       `(lisp-draw-grad-row-internal dest ,l-x y ,width ,color1 ,color2 plane-mask)
	       )
	     )
    (%draw-triangle-core draw-triangle-internal draw-triangle-row
			 :colors (color1 color2 color3)
			 :bytes ((byte 8 0)(byte 8 8)(byte 8 16)(byte 8 24)))
  )))

(def-ip-generic 2draw-grad-triangle
0       (dest x1 y1 x2 y2 x3 y3 color1 color2 color3 plane-mask &key clipping-region)
  :function lisp-draw-grad-triangle
  :d-x-offset nil :d-y-offset nil
  :width nil :height nil
  :early-types ((x1 numberp "a number")
		(y1 numberp "a number")
		(x2 numberp "a number")
		(y2 numberp "a number")
		(x3 numberp "a number")
		(y3 numberp "a number"))
  :clip nil
  :clipping-region (clipping-region)
  :d-x-forms (x1 x2 x3)
  :d-y-forms (y1 y2 y3)
  :template :no-template
  :late-types ((dest 8-or-32b-rasterp "an art-8b or art-fixnum raster"))
  )


#||
;a crude test to compare lisp with photon shading
(defun shade-test (w)
  (let* ((lim (min (// (tv:sheet-inside-width w) 2)
		   (// (tv:sheet-inside-height w) 2)))
	 (mask -1)
	 (x1 (random lim))
	 (x2 (random lim))
	 (x3 (random lim))
	 (y1 (random lim))
	 (y2 (random lim))
	 (y3 (random lim))
	 (c1 (random #xffffff))
	 (c2 (random #xffffff))
	 (c3 (random #xffffff))
	 (scr (tv:sheet-screen w))
	
	 )
    (send scr :set-remote-drawing-enabled t)
    (send w :clear-window)
    (draw-grad-triangle w x1 y1 x2 y2 x3 y3 c1 c2 c3 mask)
    (send scr :set-remote-drawing-enabled nil)
    (draw-grad-triangle w (+ x1 lim) y1 (+ x2 lim) y2 (+ x3 lim) y3 c1 c2 c3 mask)
    (send scr :set-remote-drawing-enabled t)
    (i-p:copybits w 0 lim w 0 0  lim lim tv:alu-seta -1)
    (i-p:copybits w 0 lim w lim 0 lim lim tv:alu-xor -1)
    ))

||#

(defun 2lisp-draw-zbuffered-row-internal
0       (dest x y zbuffer zx zy width z-start z-end color plane-mask)
  (when (and (> z-start 0)(> z-end 0))
    (macrolet ((set-aref (val)
		 `(progn
		    (when (< ,val (sys:%flonum (aref zbuffer z-idx)))
		      (when ( ,val 0.0)
			(setf (aref dest idx) color)
			(setf (aref zbuffer z-idx) (sys:%fixnum ,val))))
		    (incf z-idx)
		    (incf idx)))
	       (mask-set-aref (new-val)
		 `(progn
		    (when (< ,new-val (sys:%flonum (aref zbuffer z-idx)))
		      (when ( ,new-val 0.0)
			   (let* ((val (aref dest idx)))
			     (setf (aref dest idx)
				   (logxor val (logand plane-mask (logxor val color))))
			     )
			   (setf (aref zbuffer z-idx) (sys:%fixnum ,new-val))))
		    (incf z-idx)
		    (incf idx))
		 ))
      (let* ((span (si:array-row-span dest))
	     (idx (+ x (* y span)))
	     (z-span (si:array-row-span zbuffer))
	     (z-idx (+ zx (* zy z-span)))
	     (dest dest)
	     (zbuffer zbuffer)
	     )
	(declare (sys:array-register-1d dest zbuffer))

	(if (eql plane-mask -1)
	    (generate-interpolated-row (t)
	      :color-start z-start
	      :color-end z-end
	      :width width
	      :floating-steps t
	      :pixel-function set-aref)

	    (generate-interpolated-row (t)
	      :color-start z-start
	      :color-end z-end
	      :width width
	      :floating-steps t
	      :pixel-function mask-set-aref)
	    ))
      )))

(defun 2lisp-draw-zbuffered-row
0       (dest x y zbuffer zx zy width z-start z-end color plane-mask)
  (tv:with-sheet-bit-array
    dest :both
    (tv:with-sheet-bit-array
      zbuffer :both
        (lisp-draw-zbuffered-row-internal
	dest x y zbuffer zx zy width z-start z-end color plane-mask))))

(def-ip-generic 2draw-zbuffered-row
0		(dest x y zbuffer zx zy width z-start z-end color plane-mask)
  :function lisp-draw-zbuffered-row
  :height nil
  :template :no-template
  :late-types ((dest 8-or-32b-rasterp "an art-8b or art-fixnum raster")
	       (zbuffer art-fixnum-rasterp "an art-fixnum raster"))
  )

(defun 2lisp-draw-zbuffered-triangle
0       (dest x1 y1 x2 y2 x3 y3 
	zbuffer zx zy
	z1 z2 z3
	color plane-mask
	&key clipping-region)
  (tv:with-sheet-bit-array
    dest :both
    (tv:with-sheet-bit-array
      zbuffer :both
      (macrolet ((draw-triangle-internal (body)
		   `(destructuring-bind (xmin ymin xmax ymax) clipping-region
		      ,body))
		 (draw-triangle-row (width l-x z1 z2)
		   `(lisp-draw-zbuffered-row-internal dest ,l-x y
						      zbuffer (+ ,l-x zx) (+ y zy)
						      ,width ,z1 ,z2 color plane-mask)
		   )
		 )
	(%draw-triangle-core draw-triangle-internal draw-triangle-row
			     :colors (z1 z2 z3)
			     :floating-colors t
			     :bytes (t))
	)))
  )

(def-ip-generic 2draw-zbuffered-triangle
0       (dest x1 y1 x2 y2 x3 y3 zbuffer zx zy  z1 z2 z3 color plane-mask &key clipping-region)
  :function lisp-draw-zbuffered-triangle
  :d-x-offset nil :d-y-offset nil
  :width nil :height nil
  :early-types ((x1 numberp "a number")
		(y1 numberp "a number")
		(x2 numberp "a number")
		(y2 numberp "a number")
		(x3 numberp "a number")
		(y3 numberp "a number")
		(z1 numberp "a number")
		(z2 numberp "a number")
		(z3 numberp "a number")
		)
  :clip nil
  :clipping-region (clipping-region)
  :d-x-forms (x1 x2 x3)
  :d-y-forms (y1 y2 y3)
  :template :no-template
  :late-types ((dest 8-or-32b-rasterp "an art-8b or art-fixnum raster")
	       (zbuffer art-fixnum-rasterp "An art-fixnum raster"))
  )

(defun initialize-zbuffer (buffer dx dy w h
			   &optional (most-distant-value cl:most-positive-single-float))
  (i-p:draw-rectangle buffer dx dy w h tv:alu-seta
		      (sys:%fixnum most-distant-value)
		      -1))

(defmacro 2generate-clipped-filled-circle
0	  (rectangle-function 
	   dest center-x center-y radius alu color plane-mask
	   left top right bottom)

  (labels ((clipped-rectangle (ww hh xx yy )
	     `(let ((w ,ww)
		    (h ,hh)
		    (x ,xx)
		    (y ,yy))
		(when (< x ,left)
		  (setq w (- w (- ,left x))
			x ,left))
		(when (< y ,top)
		  (setq h (- h (- ,top y))
			y ,top))
		(setq w (min w (max 0 (- ,right x))))
		(setq h (min h (max 0 (- ,bottom y))))
		(,rectangle-function ,dest x y w h ,alu ,color ,plane-mask)
		)))
    `(loop with x = ,radius and y = 0 and error = 0 and old-y
	   do
       (setq error (+ error y y 1))
       (cond
	 ;; will the next chord be shorter?
	 ((>= error x)
	  ;; draw the middle region.
	  (cond
3	    ;; if this is the first time through, then draw one big rectangle.
0	    ((null old-y)
	     ,(clipped-rectangle `(+ x x 1) `(+ y y 1) `(- ,center-x x) `(- ,center-y y))
	     (setq old-y y))
3	    ;; otherwise draw upper & lower rectangles.
0	    (t
	     ,(clipped-rectangle `(+ x x 1) `(- y old-y) `(- ,center-x x) `(- ,center-y y))
	     ,(clipped-rectangle `(+ x x 1) `(- y old-y) `(- ,center-x x) `(+ ,center-y old-y 1))
	     (setq old-y y)))
	  (and (= x y) (return t))		;finished?
3	  ;; draw the top line.
0	  ,(clipped-rectangle `(+ y y 1) 1 `(- ,center-x y) `(+ ,center-y x))
3	  ;; draw the bottom line.
0	  ,(clipped-rectangle `(+ y y 1) 1 `(- ,center-x y) `(- ,center-y x))
	  (setq error (- error x x -1)
		x   (1- x))))
       (setq y (1+ y))
       (and (> y x) (return t)))))

(defun 2lisp-draw-filled-in-circle
0       (dest center-x center-y radius alu color plane-mask &key clipping-region)
  (destructuring-bind (left top right bottom) clipping-region
    (generate-clipped-filled-circle
      lisp-draw-rectangle dest center-x center-y radius alu color plane-mask
      left top right bottom)
    ))

(def-ip-generic 2draw-filled-in-circle
0		(dest x y radius alu color plane-mask &key clipping-region)
  :function lisp-draw-filled-in-circle
  :clip nil :width nil :height nil
  :clipping-region (clipping-region)
  :template :no-template
  :late-types ((dest rasterp "a raster array")))

(defmacro 2generate-clipped-circle0 (pixel-function x1 y1 radius left top right bottom)
  3;
0  3;generate a circle, distinguishing two significant cases, where
0  3;the circle intersects the clipping region and where it doesn't
  ;
0  (labels ((clipped-point (clip x y)
	     (if clip
		 `(let ((x ,x)
			(y ,y))
		    (unless (or (< x ,left) (>= x ,right)
				(< y ,top) (>= y ,bottom))
		      (,pixel-function x y)))
		 `(,pixel-function ,x ,y)))
	   (clipped-circle (clip x1 y1 radius)
	     `(IF (= ,RADIUS 0)
		  ,(clipped-point clip x1 y1)
		  (DO ((Y 0)
		       (F 0)			; F is just Y squared without any multiplies
		       (X ,RADIUS))
		      (NIL)
		    ,(CLIPPED-POINT clip `(+ ,X1 X) `(- ,Y1 Y))
		    ,(CLIPPED-POINT clip `(- ,X1 X) `(+ ,Y1 Y))
		    ,(CLIPPED-POINT CLIP `(+ ,X1 Y) `(+ ,Y1 X))
		    ,(CLIPPED-POINT CLIP `(- ,X1 Y) `(- ,Y1 X))
		    (SETQ F (+ F Y Y 1) Y (1+ Y))
		    (COND ((>= F X) (SETQ F (- F X X -1) X (- X 1))))
		    (COND ((> Y X) (RETURN ',pixel-function)))
		    ,(CLIPPED-POINT CLIP `(+ ,X1 X) `(+ ,Y1 Y))
		    ,(CLIPPED-POINT CLIP `(- ,X1 X) `(- ,Y1 Y))
		    ,(CLIPPED-POINT CLIP `(+ ,X1 Y) `(- ,Y1 X))
		    ,(CLIPPED-POINT CLIP `(- ,X1 Y) `(+ ,Y1 X))
		    (COND ((= Y X) (RETURN ',pixel-function)))))
	     ))
    `(if (and (>= (- ,x1 ,radius) ,left)
	      (>= (- ,y1 ,radius) ,top)
	      (< (+ ,x1 ,radius) ,right)
	      (< (+ ,y1 ,radius) ,bottom))
	 ,(clipped-circle nil x1 y1 radius)
	 ,(clipped-circle t x1 y1 radius))
	   ))

(defun 2lisp-draw-circle0 (dest x1 y1 radius alu color plane-mask &key clipping-region)
  3;
0  3;draw a circle on a plain array, distinguishing 8 signigicant cases
0  3; <with/without significant clipping> x <with/without plane mask> x <with/without boolean>
  ;
0  (tv:with-sheet-bit-array
    dest :both
    (macrolet ((set-aref (x y)
		 `(setf (raster-aref dest ,x ,y) color))
	       (mask-set-aref (x y)
		 `(let* ((.x ,x)(.y ,y)(val (raster-aref dest .x .y)))
		    (setf (raster-aref dest .x .y)
			  (logxor val (logand plane-mask (logxor val color))))))
	       (boole-aref (x y)
		 `(let ((.x ,x)(.y ,y))
		    (setf (raster-aref dest .x .y)
			  (boole alu color (raster-aref dest .x .y)))))
	       (mask-aref (x y)
		 `(let* ((.x ,x)
			 (.y ,y)
			 (old (raster-aref dest .x .y)))
		    (setf (raster-aref dest .x .y)
			  (logxor old (logand plane-mask
					      (logxor old (boole alu color old))))))))

      (destructuring-bind (left top right bottom) clipping-region
	(multiple-value-bind (alu color plane-mask)
	    (color:combine-alu-and-data-with-mask alu color plane-mask)
	  (cond ((eql alu tv:alu-seto) (setq alu 5 color -1))
		((eql alu tv:alu-setz) (setq alu 5 color 0)))
	  (if (eql plane-mask -1)
	      (if (eql alu color:alu-x)
		  (generate-clipped-circle set-aref x1 y1 radius left top right bottom)
		  (generate-clipped-circle boole-aref x1 y1 radius left top right bottom)
		  )
	      (if (eql alu color:alu-x)
		  (generate-clipped-circle mask-set-aref x1 y1 radius left top right bottom)
		  (generate-clipped-circle mask-aref x1 y1 radius left top right bottom))
	      )))
      )))


(def-ip-generic 2draw-circle
0		(dest x y radius alu color plane-mask &key clipping-region)
  :function lisp-draw-circle
  :clip nil :width nil :height nil
  :clipping-region (clipping-region)
  :template :no-template
  :late-types ((dest rasterp "a raster array")))



(defmacro 2rgbyuv-line0 (dest dest-x src src-x w &key (scale t)(clip nil))
  (once-only (dest-x src-x)
    `(loop repeat ,w
	   as pix = (aref ,src ,src-x)
	   as r = (ldb (byte 8 0) pix)
	   as g = (ldb (byte 8 8) pix)
	   as b = (ldb (byte 8 16) pix)
	   as y = (color:fixnum-rgbyuv r g b :values :y :scale ,scale :clip ,clip)
	   do (incf ,src-x)
	      (cond ((oddp ,dest-x)
		     (setf (aref ,dest ,dest-x) y)
		     (incf ,dest-x))
		    (t
		     (multiple-value-bind (cb cr)
			 (color:fixnum-rgbyuv r g b :values :uv :clip ,clip :scale ,scale)
		       (setf (aref ,dest ,dest-x) cb)
		       (incf ,dest-x)
		       (setf (aref ,dest ,dest-x) y)
		       (incf ,dest-x)
		       (setf (aref ,dest ,dest-x) cr)
		       (incf ,dest-x)
		       )))
	      )
    ))

(defun 2lisp-rgbyuv0 (dest dx dy src sx sy width height &key (scale t) clip from-field to-field)
  (tv:with-sheet-bit-array
    dest :both
    (tv:with-sheet-bit-array
      src :input
      (let* ((dest dest)
	     (src src)
	     (d-span-0 (si:array-row-span dest))
	     (d-span (if to-field (* d-span-0 2) d-span-0))
	     (s-span-0 (si:array-row-span src))
	     (s-span (if from-field (* s-span-0 2) s-span-0))
	     (first-d (+ dx (* (if to-field (+ dy to-field -1) dy) d-span-0)))
	     (first-s (+ sx (* (if from-field (+ sy from-field -1) sy) s-span-0)))
	     (height (cl:ecase (or to-field from-field)
		       ((nil) height)
		       (1 (ceiling height 2))
		       (2 (floor height 2))))
	     )
	(declare (sys:array-register-1d dest src))
	(cond (scale
	       (if clip
		   (loop repeat height
			 as d-x from first-d by d-span
			 as s-x from first-s by s-span
			 do
		     (rgbyuv-line dest d-x src s-x width :scale t :clip t))
		   (loop repeat height
			 as d-x from first-d by d-span
			 as s-x from first-s by s-span
			 do
		     (rgbyuv-line dest d-x src s-x width :scale t :clip nil))
		   ))
	      (clip
	       (loop repeat height
		     as d-x from first-d by d-span
		     as s-x from first-s by s-span
		     do
		 (rgbyuv-line dest d-x src s-x width :scale nil :clip t)
		 ))
	      (t
	       (loop repeat height
		     as d-x from first-d by d-span
		     as s-x from first-s by s-span
		     do
		 (rgbyuv-line dest d-x src s-x width :scale nil :clip nil)
		 ))
	      )))))

(def-ip-generic 2rgbyuv0 (dest dx dy src sx sy width height
			      &key (scale t) clip from-field to-field)
  :function lisp-rgbyuv
  :late-types ((src art-fixnum-rasterp "a fixnum raster")
	       (dest art-8b-rasterp "an art-8b-raster"))
  :d-x-* (ash -1)
  )

(defmacro 2yuvrgb-line0 (dest dest-x src src-x w &key (scale t) clip)
  (once-only (dest-x src-x)
    `(let* (Cb1 Y1 Cr1
	    Y2 Cb2 Cr2
	    cb3 cr3 y3 )

       (setq Cb3 (aref ,src ,src-x)
	     ,src-x (1+ ,src-x)
	     Y3 (aref ,src ,src-x)
	     ,src-x (1+ ,src-x)
	     Cr3 (aref ,src ,src-x)
	     ,src-x (1+ ,src-x))

       (loop with fin = (ash ,w -1)
	     for idx from 1 to fin do
	 (setq Cb1 Cb3
	       Cr1 Cr3
	       Y1 Y3
	       Y2 (aref ,src ,src-x)
	       ,src-x (1+ ,src-x))
	 (unless (and (eql idx fin) (evenp ,w))
	   (setq Cb3 (aref ,src ,src-x)
		 ,src-x (1+ ,src-x)
		 Y3 (aref ,src ,src-x)
		 ,src-x (1+ ,src-x)
		 Cr3 (aref ,src ,src-x)
		 ,src-x (1+ ,src-x)
		 Cb2 (ash (+ Cb3 Cb1) -1)
		 Cr2 (ash (+ Cr3 Cr1) -1))
	       )
	 (multiple-value-bind (r g b)
	     (color:fixnum-yuvrgb y1 cb1 cr1 :scale ,scale :clip ,clip)
	   (let ((v (combine-rgb r g b 0)))
	     (setf (aref ,dest ,dest-x) v)))
	 (incf ,dest-x)

	 (multiple-value-bind(r g b)
	     (color:fixnum-yuvrgb y2 cb2 cr2 :scale ,scale :clip ,clip)
	   (let ((v (combine-rgba r g b 0)))
	     (setf (aref ,dest ,dest-x) v)))
	 (incf ,dest-x)
	 )
       (when (oddp ,w)
	 (multiple-value-bind (r g b)
	     (color:fixnum-yuvrgb y3 cb3 cr3 :scale ,scale :clip ,clip)
	   (let ((v (combine-rgba r g b 0)))
	     (setf (aref ,dest ,dest-x) v
		   ))))
       ))
    )
(defun 2lisp-yuvrgb0 (dest dx dy src sx sy width height
		     &key (scale t)(clip nil)from-field to-field)
  (tv:with-sheet-bit-array
    dest :both
    (tv:with-sheet-bit-array
      src :input
      (let* ((dest dest)
	     (src src)
	     (d-span-0 (si:array-row-span dest))
	     (d-span (if to-field (* d-span-0 2) d-span-0))
	     (s-span-0 (si:array-row-span src))
	     (s-span (if from-field (* s-span-0 2) s-span-0))
	     (first-d (+ dx (* (if to-field (+ dy to-field -1) dy) d-span-0)))
	     (first-s (+ sx (* (if from-field (+ sy from-field -1) sy) s-span-0)))
	     (height (cl:ecase (or to-field from-field)
		       ((nil) height)
		       (1 (ceiling height 2))
		       (2 (floor height 2))))
	     )
	(declare (sys:array-register-1d dest src))
	(cond (scale
	       (if clip
		   (loop repeat height
			 as d-x from first-d by d-span
			 as s-x from first-d by s-span
			 do
		     (yuvrgb-line dest d-x src s-x width :scale t :clip t))

		   (loop repeat height
			 as d-x from first-d by d-span
			 as s-x from first-s by s-span
			 do
		     (yuvrgb-line dest d-x src s-x width :scale t :clip nil)
		     )))
	      (clip
	       (loop repeat height
		     as d-x from first-d by d-span
		     as s-x from first-s by s-span
		     do
		 (yuvrgb-line dest d-x src s-x width :scale nil :clip t)))
	      (t (loop repeat height
		       as d-x from first-d by d-span
		       as s-x from first-s by s-span
		       do
		   (yuvrgb-line dest d-x src s-x width :scale nil :clip nil)))
	      )))))

(def-ip-generic yuvrgb (dest dx dy src sx sy width height
			      &key (scale t) clip from-field to-field)
  :function lisp-yuvrgb
  :late-types ((dest art-fixnum-rasterp "a fixnum raster")
	       (src art-8b-rasterp "an art-8b-raster"))
  :s-x-* (ash -1)
  )

