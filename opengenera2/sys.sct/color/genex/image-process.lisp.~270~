;;; -*- Package: COLOR; Base: 10.; Mode: LISP; -*-


;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB");;
;; Conversion macros; these should be in sys:window;colors, but it's
;; not worth hassling chambridge for it.
;;
0(defmacro fixnum-rgb->yiq (r g b &environment env)
  (once-only (r g b &environment env)
    `(values (ash (+ (* 77 ,r) (* 150 ,g) (* 29 ,b)) -8)
(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")	     ;I know ASH isn't right for I and Q, because the values can be negative
	     ;but I'd rather accept the error of 1 than do a real divide.
0	     (+ (ash (- (* 153 ,r) (* 71 ,g)(* 82 ,b)) -8) 128)
	     (+ (ash (- (+ (* 54 ,r) (* 80 ,b) ) (* 134 ,g)) -8) 128))))

(defmacro fixnum-rgb->y (r g b &environment env)
  (once-only (r g b &environment env)
    `(ash (+ (* 77 ,r) (* 150 ,g) (* 29 ,b)) -8)))

(defmacro rgb->y (r g b &environment env)
  (once-only (r g b &environment env)
    `(+ (* .299 ,r) (* .587 ,g) (* .114 ,b))))

;
;hack to do with fixnum multiply what is logically a flonum multiply
;
(defconst %uv-scale (// (float #xFF) (- #xF0 #x10)))
(defconst %y-scale (// (float #xFF) (- #xEB #x10)))
(defsubst %fm (v m q &optional s)
  `(ash ,(if (and (listp v) (not s))
	     `(+ ,@(loop for v1 in v as m1 in m
			 collect
			   `(* ,v1 ,(round (* m1 (lsh 1 q))))))
	     `(* ,v ,(round (* m (lsh 1 q)))))
	,(- q)))

;
;1converting from rgb to yuv and back.   
0;if SCALE is T, the values are scaled compatibly with "601 format" video.  This is
;what the abekas does by default.  If CLIP is T, the pixels are not scaled, but instead
;are clipped to values compatible with 601 format.
;
(defmacro 1fixnum-rgbyuv0 (r g b &key (values :yuv) (scale t) clip)
  (let* ((y-scale (if scale %y-scale 1))
	 (uv-scale (if scale %uv-scale 1))
	 (y (%fm `(,r ,g ,b)
		 `(,(// 0.2990 y-scale)
		   ,(// 0.5870 y-scale)
		   ,(// 0.1140 y-scale))
		 20))
	 (u `(+ #x80 ,(%fm `(,r ,g ,b)
			  `(,(// -0.1686 uv-scale)
			    ,(// -0.3311 uv-scale)
			    ,(// 0.4997 uv-scale))
			  20)))
	 (v `(+ #x80 ,(%fm `(,r ,g ,b)
			`(,(// 0.4998 uv-scale)
			  ,(// -0.4185 uv-scale)
			  ,(// -0.0813 uv-scale))
			20))))
    (when scale
      (setq y `(+ ,y #x10))
      )

    (when clip
      (setq y `(min #xeb (max #x10 ,y)))
      (setq u `(min #xf0 (max #x-f0 ,u)))
      (setq v `(min #xf0 (max #x-f0 ,v)))
      )

    (cl:ecase values
      (:y y)
      (:uv `(values ,u ,v))
      (:yuv `(values ,y ,u ,v)))))


(defmacro 1fixnum-yuvrgb0 (y u v &key (scale t) clip (values :rgb))
  (let* ((y-scale (if scale %y-scale 1))
	 (uv-scale (if scale %uv-scale 1))
	 (y1 (%fm (if scale `(- ,y #x10) y) y-scale 21 t))
	 (r `(+ y1 ,(%fm 'v1 (* uv-scale 1.40257) 20)))
	 (g `(+ y1 ,(%fm `(u1 v1) `(,(* uv-scale -.3443692) ,(* uv-scale -.7144071)) 20)))
	 (b `(+ y1 ,(%fm 'u1 (* uv-scale 1.77306) 20)))
	 (max-v (if clip 235. 255.))
	 (min-v (if clip 16. 0))
	 )
    (cl:ecase values
      (:rgb `(Let ((y1 ,y1)
		   (u1 (- ,u #x80))
		   (v1 (- ,v #x80)))
	       (values 
		 (max ,min-v (min ,max-v ,r))
		 (max ,min-v (min ,max-v ,g))
		 (max ,min-v (min ,max-v ,b))
		 )))
      (:y y1)
      )))


#||

(3 0 (NIL 0) (NIL :BOLD :LARGE) "MEDFNTB")Image Processes

2(I'm doubtful if it is appropriate to document this for users, but it does need
to be documented somewhat for internal purposes)

0In release 7.2, color-support (or preferably the base system) will support a 
class of objects known as an IMAGE-PROCESS.  Image-processes are containers
which know how to perform some basic image processing algorithm, using many
different kinds of inputs and outputs.   Associated with each image process
are multiple IMAGE-PROCESS-FUNCTIONS, each of which performs the image process
on a different combination of inputs and outputs.   The image process uses
excessively hairy macrology to automatically generate image process functions
from compact specifications.

The principle motivation for image processes is to remove the dog work
from the rask of providing uniform functionality over the many formats
of data found in the system.   The details of how to create image
processes is subject to change and will not be documented.   Among the
possible image-process-functions, only a subset that are considered needed
will be instantiated.  Instantiating new image-process-functions upon demand
may be possible, but is subject to testing (Ie; if you create a new one, 
you have to assure yourself that it works).

The top level functions which will be supplied to use image processes will be
adept at locating the correct image process function to use, and supplying it
with the correct set of arguments.

as an example of all this, consider the problem of rescaling pictures. 
The relevant complications are:

   (1) We implement three basic techniques
   for rescaling, SELECTION (where a representative pixel is copied) and
   AVERAGING (where all the source pixels are averaged to generate the
   result) and FILTERING (where a more elaborate filter is used)

   (2) The source picture can be 1 bit per pixel, 2 bits per
   pixel, 8 bits per pixel, 32 bits per pixel, or three separate arrays
   making 24 bits per pixel.   8 bit per pixel images are commonly
   associated with a color map, which may be one of several "standard" maps
   or a completely arbitrary color map. 

   (3) There are several different
   techniques for rescaling, in order of decreasing speed: Simple pixel
   replication, Rescaling in X only, and General rescaling.

These are implemented by several different image processes

PIXEL-REPLICATION	interfaces to PIXEL-REPLICATION-ZOOM-RECTANGLE, an extremely
		optimized function for copying pixels an integral number of times,
		with input and output in the same format.

CHANGE-ASPECT-RATIO-4/3
CHANGE-ASPECT-RATIO-3/4
CHANGE-ASPECT-RATIO-19/16
CHANGE-ASPECT-RATIO-16/19	Specialized image process for transforming common
        the cases of aspect ratio from square to "pal", "pal" to square, square to "hdtv", 
        and "hdtv" to square.   These are split out because PAINT needs to perform these
        transformations as fast as possible.

RESCALE-IMAGE	The general rescale process, which picks up any rescaling operations
	not covered by one of the more specialized image processes.


The each image process function is specified by a 5-tuple of keywords,
which synopsize the processing steps to generate each result pixel.

:FETCH		Fetches the source from the array(s), 
:MAP		Maps the fetched source(s)
:SEPARATE       Separate the mapped source into Componets, or in some cases
		Combine the fetched components to a single value.
:COMBINE	Combine the processed components back to a single value
:STORE		Store the result.

The actual function specified by each keyword is somewhat arbitrary, and not
all combinations will work  together to acheive a resonable result.

In addition to the "basic 5" above, each image process can have it's own
extra keywords - for example RESCALE-IMAGE also uses :RESCALE as  a keyword.
The basic concept is that the caller will construct an N-tuple describing the
process he would like to accomplish, and the image process will locate and
invoke the function corresponding to that specification.   If some desirable
combination doesn't exist, it is usually simple to create it, since barring
bugs, the specification is all that is needed to automatically create the function.

||#


(eval-when (eval compile load)

(defvar *special-image-keywords* '(:computed-source-lines
				    :computed-dest-lines
				    :write-mask))

(defvar *special-image-keyword-args* '(:from-field
					:to-field
					:per-line-function)))

(defmacro def-operator (table id &optional fetch-spec other-arrays)
  `(puthash ',id '(,fetch-spec ,other-arrays) ,table))

(defun aref-byte (core spec)
  (destructuring-bind (byte-size byte-pos minus) spec
    (when minus (setq core `(- ,core)))
    (if (null byte-size) core
	`(%logldb (byte ,byte-size ,byte-pos) ,core))))


(defun aref-repeat (core spec )
  `(progn ,(aref-byte core (first spec))))

2;;
;; Fetch operators:   do necessary aref(s) and perform other processing to fetch
;; 0one2 working value, except for R+G+B+A format where all three or four 8-bit 
;; values are fetched directly.
;;

0(defconst fetch-operators (make-hash-table))

(def-operator fetch-operators :yuv-rgb (yuv-to-rgb nil nil nil)
	      (:single-source
		:multiple-value-fetch
		:no-inc
		(:fetch-multiplier 2)
		(:locals cr1 cr2 cr3 cb1 cb2 cb3 y1 y2 y3 %index %last)
		(:before-line 
		  (lambda ()
		    (if (bit-test 2 sx)		2;originally an odd pixel

0			(setq cb1 (aref :source (- src-index 2))
			      y1 (aref :source (- src-index 1))
			      cr1 (aref :source src-index)
			      src-index (1+ src-index)
			      y2 (aref :source src-index)
			      src-index (1+ src-index)
			      cb3 (aref :source src-index)
			      src-index (1+ src-index)
			      y3 (aref :source src-index)
			      src-index (1+ src-index)
			      cr3 (aref :source src-index)
			      cb2 (ash (+ cb3 cb1) -1)
			      cr2 (ash (+ cr3 cr1) -1)
			      %index 2)

			(setq Cb3 (aref :source src-index)
			      src-index (1+ src-index)
			      Y3 (aref :source src-index)
			      src-index (1+ src-index)
			      Cr3 (aref :source src-index)
			      %index 1
			      )
			)
		    (setq %last (dpb 0 (Byte 1 0) (:width));force it to be even
			  src-index (1+ src-index))
		    ))
		))

(defun yuv-to-rgb (core spec)
  (ignore spec)
  (let ((var (third core)))
    `(cond ((evenp %index)
	    (progn (incf %index)
		   (fixnum-yuvrgb y2 cb2 cr2)))
	   (t (progn
		(setq Cb1 Cb3
		      Cr1 Cr3
		      Y1 Y3
		      Y2 ,core
		      ,var (1+ ,var)
		      %index (1+ %index))
		(cond ((< %index %last)
		       (setq Cb3 ,core
			     ,var (1+ ,var)
			     Y3 ,core
			     ,var (1+ ,var)
			     Cr3 ,core
			     ,var (1+ ,var)
			     Cb2 (ash (+ Cb3 Cb1) -1)
			     Cr2 (ash (+ Cr3 Cr1) -1)))
		      (t (setq cb2 cb3 cr2 cr3))
		      )
		(fixnum-yuvrgb y1 cb1 cr1)
		)))))

2;fetch 3 values from one array
0(def-operator fetch-operators :packed-rgb (aref-repeat nil nil nil) (:single-source))
2;fetch 2 values from one array
0(def-operator fetch-operators :packed-yuv (aref-repeat nil nil) (:single-source))

2;just fetch the array
0(def-operator fetch-operators :rgba (aref-byte nil)) 
2;a list of red,green,blue arrays
0(def-operator fetch-operators :r+g+b (aref-byte nil nil nil)) 
2;a list of red,green,blue,alpha arrays
0(def-operator fetch-operators :r+g+b+a (aref-byte nil nil nil nil))
2;fetch an art-fixnum, extract the red
0(def-operator fetch-operators :red (aref-byte (8 0)))
2;fetch an arg-fixnum, extract the green
0(def-operator fetch-operators :green (aref-byte (8 8)))
2;fetch an art-fixnum, extract the blue
0(def-operator fetch-operators :blue (aref-byte (8 16)))
2;fetch an art-fixnum, extract the alpha
0(def-operator fetch-operators :alpha (aref-byte (8 24)))
2;fetch an art-1b, expand to a 2 bits (0 or 3)
0(def-operator fetch-operators :1b-2b (aref-byte (2 0 t)))
2;fetch an art-1b, expand to a 4 bits (0 or 15)
0(def-operator fetch-operators :1b-4b (aref-byte (4 0 t)))
2;fetch an art-1b, expand to 8 bits (0 ot 255)
0(def-operator fetch-operators :1b-8b (aref-byte (8 0 t)))
2;fetch an art-1b, expand to 24 bits (0 or #xFFFFFF)
0(def-operator fetch-operators :1b-24b (aref-byte (24 0 t)))
2;fetch an art-1b, expand to 32 bits (0 or -1)
0(def-operator fetch-operators :1b-32b (aref-byte (nil nil t)))
2;fetch an art-2b, expand to 8 bits (0, 85, 170, or 255)
0(def-operator fetch-operators :2b-8b ((lambda (v ignore) `(* ,v 85)) nil) nil)
2;fetch an art-042b, expand to 8 bits (0, 017, ... 255.)
(def-operator fetch-operators :4b-8b ((lambda (v ignore) `(* ,v 17)) nil) nil)
2;fetch an art-4b, expand to 4 bits (0, 5, 10, or 15)
0(def-operator fetch-operators :2b-4b ((lambda (v ignore) `(* ,v 5)) nil) nil)

(def-operator fetch-operators :IGNORE nil nil)

(defun aref-map (a ignore) `(aref map ,a))
(defconst map-operators (make-hash-table))
2;no map
0(def-operator map-operators nil)
2;map using a derived array, specified jointly by the
;TRANSLAION-ARRAY and TRANSLATION-NAME arguments to the function

0(def-operator map-operators :new-palette
  (aref-map nil)
  ((map translation-array :combine-palettes combination-array)))

(def-operator map-operators :named-with-alpha
  (aref-map nil)
  ((map translation-array :translation-array-with-alpha translation-name default-alpha)))

(def-operator map-operators :named
  (aref-map nil)
  ((map translation-array translation-name)))

2;;
;; Separate operators that take one value generated by :FETCH and :MAP and expand
;; the result to multiple components
;;
0(defconst separate-operators (make-hash-table))

(defun separate-byte (in args vals)
  (loop for v in vals
	as n from 0 
	as a in args
	collect `(setq ,v ,(cond ((listp a)
				  `(%logldb (byte ,@a)
					    ,(cond ((cdr in) (nth n in))
						   (t (first in)))))
				 ((null a)  (cond ((cdr in) (nth n in))
						  (t (first in))))
				 (t a))
		       )))

(defun separate-bins (in args vals)
  (loop for v in vals
	as n from 0
	as a in (first args)
	as pow2+ = (haulong a)
	as pow2- = (haulong (1- a))
	as res = (if (cdr in) (nth n in) (first in))
	collect
	(cond ((memq (second args) '(:r+g+b :packed-rgb))
	       (cond ((= pow2+ pow2-)
						;not a power of 2
		      `(setq ,v (// ,res ,(ceiling 256 a))))
		      ((= 8 pow2-)
		       `(setq ,v ,res))
		      (t `(setq ,v (ldb (byte ,pow2- ,(- 8 pow2-)) ,res)))))
	      (t 
	       (cond ((= pow2+ pow2-)
		      ;not a power of 2
		      `(setq ,v (// (ldb (byte 8 ,(* n 8)) ,res) ,(ceiling 256 a))))
		     ((= 8 pow2-)
		      `(setq ,v `(ldb (byte 8 ,(* n 8)) ,res)))
		     (t `(setq ,v (ldb (byte ,pow2- ,(- (* 8 (1+ n)) pow2-)) ,res))))))
	      ))

(def-operator separate-operators :bins
  (separate-bins (:bins) (:fetch) nil))

2;no separation
0(def-operator separate-operators nil)
2;separate fixnum into 8 bit R,G,and B
0(def-operator separate-operators :rgb (separate-byte (8 0) (8 8) (8 16)))

(def-operator separate-operators :rrr (separate-byte nil nil nil))

(def-operator separate-operators :4r (separate-byte (8 0) (8 0)(8 0)(8 0)))
(def-operator separate-operators :4g (separate-byte (8 8) (8 8)(8 8)(8 8)))
(def-operator separate-operators :4b (separate-byte (8 16) (8 16)(8 16)(8 16)))
(def-operator separate-operators :4a (separate-byte (8 24) (8 24)(8 24)(8 24)))

2;separate fixnum into 8 bit R,G,B,and Alpha
0(def-operator separate-operators :rgba (separate-byte (8 0) (8 8) (8 16) (8 24)))
2;combine R,G,and B into intensity, from either one or three fetched sources.

0(def-operator separate-operators :intensity
  ((lambda (a ignore vals)
     (if (null (cdr a))
	 `((let ((v ,@a))
	     (setq ,(first vals) (fixnum-rgb->i (ldb (byte 8 0) v)
						(ldb (byte 8 8) v)
						(ldb (byte 8 16) v)))))
	 `((setq ,(first vals) (fixnum-rgb->i ,@a)))
	 ))
   nil))

(def-operator separate-operators :r
  ((lambda (a ignore vals)
     (if (null (cdr a))
	 `((let ((v ,@a))
	     (setq ,(first vals) (ldb (byte 8 0) v))))
	 `((progn (ignore ,@(loop for (nil v) in a collect v))
		  (setq ,(first vals) ,(first a))))
	 ))
   nil))
(def-operator separate-operators :g
  ((lambda (a ignore vals)
     (if (null (cdr a))
	 `((let ((v ,@a))
	     (setq ,(first vals) (ldb (byte 8 8) v))))
	 `((progn (ignore ,@(loop for (nil v) in a collect v))
		  (setq ,(first vals) ,(second a))))
	 ))
   nil))

(def-operator separate-operators :b
  ((lambda (a ignore vals)
     (if (null (cdr a))
	 `((let ((v ,@a))
	     (setq ,(first vals) (ldb (byte 8 16) v))))
	 `((progn (ignore ,@(loop for (nil v) in a collect v))
		  (setq ,(first vals) ,(third a))))
	 ))
   nil))

(def-operator separate-operators :alpha
  ((lambda (a ignore vals)
     (if (null (cdr a))
	 `((let ((v ,@a))
	     (setq ,(first vals) (ldb (byte 8 24) v))))
	 `((progn (ignore ,@(loop for (nil v) in a collect v)) (setq ,(first vals) ,(fourth a))))
	 ))
   nil))

(def-operator separate-operators :y
  ((lambda (a ignore vals)
     (if (null (cdr a))
	 `((let ((v ,@a))
	     (setq ,(first vals) (fixnum-rgb->y (ldb (byte 8 0) v)
						(ldb (byte 8 8) v)
						(ldb (byte 8 16) v)))))
	 `((setq ,(first vals) (fixnum-rgb->y ,@a)))
	 ))
   nil))

(def-operator separate-operators :packed-red
  ((lambda (a ignore vals)
     `((setq ,(first vals) ,(first a))
       (setq src-index (+ src-index (:next-x)(:next-x)))))
   nil))

(def-operator separate-operators :packed-green
  ((lambda (a ignore vals)
     `((setq ,(first vals) (progn (setq src-index (+ src-index (:next-x))) ,(first a)))
       (setq src-index (+ src-index (:next-x)))))
   nil))

(def-operator separate-operators :packed-blue
  ((lambda (a ignore vals)
     `((setq ,(first vals) (progn (setq src-index (+ src-index (:next-x) (:next-x)))
				  ,(first a)))))
   nil))


(def-operator separate-operators :packed-y
  ((lambda (a ignore vals)
     `((setq ,(first vals) (progn (setq src-index (+ src-index (:next-x)))
				  (fixnum-yuvrgb ,(first a) nil nil :values :y)
				  ))))
   nil))

(def-operator separate-operators :4r
  ((lambda (a ignore vals)
     (if (null (cdr a))
	 `((let ((v ,@a))
	     (setq ,(first vals)
		   (%logdpb default-alpha (byte 8 24.)
			    (%logdpb v (byte 8 16)
				     (%logdpb v (byte 8 8)
					      v)))
		   )))
	 `((setq ,(first vals)
		 (%logdpb default-alpha (byte 8 24.)
			  (%logdpb ,(first a) (byte 8 16)
				   (%logdpb ,(first a) (byte 8 8)
					    ,(first a))))))
	 ))
   nil))

(def-operator separate-operators :max
  ((lambda (a ignore vals)
     (if (null (cdr a))
	 `((let ((v ,@a))
	     (setq ,(first vals)
		   (max (ldb (byte 8 0) v) (ldb (byte 8 8) v) (ldb (byte 8 16.) v))
		   )))
	 `((setq ,(first vals)
		 (max ,(first a) ,(second a) ,(third a))))
	 ))
   nil))

(def-operator separate-operators :min
  ((lambda (a ignore vals)
     (if (null (cdr a))
	 `((let ((v ,@a))
	     (setq ,(first vals)
		   (min (ldb (byte 8 0) v) (min (ldb (byte 8 8) v) (ldb (byte 8 16.) v)))
		   )))
	 `((setq ,(first vals)
		 (min ,(first a) ,(second a) ,(third a))))
	 ))
   nil))


2;;
;; Combination operators that take result (scaled) values and combine them
;; into a single component for storage
;;
0(defconst combine-operators (make-hash-table))

;;
;; Functions derived from combine operators, used by color maps
;; to build derived maps
;;

(defvar combine-operator-functions (make-equal-hash-table))
(defun combine-operator-function (spec vals &optional other-args)
  (setq spec (selector spec eql (:red :r)(:green :g)(:blue :b) (otherwise spec)))
  (with-stack-list (key spec (length vals))
    (or (gethash key combine-operator-functions)
	(let* ((fun (caar (gethash spec combine-operators)))
	       (efun (when fun (funcall fun vals nil))))
	  (when efun
	    (let ((name (make-symbol (format nil "COMBINE-OPERATOR-FUNCTION-~A-~A"
					     spec (length vals)))))
	    (puthash (copylist key)
		     (compile name `(lambda (,@vals ,@other-args)
				      (ignore ,@vals)
				      ,efun))
		     combine-operator-functions)))))))


(defun combine-bins (values args &key (just-result nil) (dither nil))
  (loop with result = nil
	for v in values
	as combined-power = 1 then (* combined-power a)
	as a in (first args)
	as pow2+ = (haulong combined-power)
	as pow2- = (haulong (1- combined-power))
	do 
    (when dither
      2;
0      2;when dithering, we have to defer conversion to the desired range
0      2;until after adding in the error terms
0      2;
0      (let ((pow1+ (haulong a))
	    (pow1- (haulong (1- a))))
	(cond ((= pow1+ pow1-)
						;not a power of 2
	       (setq v `(// ,v ,(ceiling 256 a))))
	      ((= 8 pow1-))
	      (t (setq v `(ldb (byte ,pow1- ,(- 8 pow1-)) ,v))))))

    (cond ((= combined-power 1) (setq result v))
	  ((= pow2+ pow2-)
	   (setq result `(+ ,result (* ,combined-power ,v))))
	  (t (setq result `(dpb ,v (byte 8 ,pow2-) ,result))))
	finally (return (if just-result result
			    `(incf (aref dest , result))))))

(def-operator combine-operators :bins
  (combine-bins (:bins)))

(defun combine-remap (values args)
  2;;
0  2;; Used by peano mapping, but actually more flexible
0  2;; ...replaying an image through any 3d-histogram array
0  2;;
0  (destructuring-bind (nil dither jitter) args
    (let ((core (combine-bins (if dither
				  `(s-red s-green s-blue)
				  values
				  )
			      args
			      :just-result t
			      :dither dither)))
      (if (or dither jitter)
	  `(let* (,@(loop for i in values
			  as e in '(red-error green-error blue-error)
			  as saved in '(s-red s-green s-blue)
			  collect `(,saved (max 0 (min 255 (+ ,i ,e)))))
		  (core-index ,core)
		  (new-idx (aref hist core-index)))
	     (when (< new-idx 0)
	       (setf (aref hist core-index)
		     (setq new-idx
			   (fixnum-closest-color-in-palette color-map
				 s-red s-green s-blue
				 ))))
	     (let ((exact (aref full-color-translation new-idx)))
	       (setq red-error (ash (- s-red (ldb (byte 8 0) exact)) -1)
		     green-error (ash (- s-green (ldb (byte 8 8) exact)) -1)
		     blue-error (ash (- s-blue (ldb (byte 8 16) exact)) -1)))
	     new-idx)
	  `(aref hist ,core)))))

(def-operator combine-operators :remap
  (combine-remap (:bins)(:dither)(:jitter)))

2;no combination
0(def-operator combine-operators nil)
2;threshold the result to 1 or 0
0(def-operator combine-operators :threshold
  ((lambda (values ignore)
     `(if (>= ,(first values) threshold) white-pixel black-pixel))))

2;map r,g,b into a standard palette specified by COMBINATION-ARRAY
0(def-operator combine-operators :palette
  ((lambda (vals ignore)
     `(+ (aref red-contribution ,(first vals))
	 (aref green-contribution ,(second vals))
	 (aref blue-contribution ,(third vals)))))
  ((red-contribution combination-array :red-contribution)
   (green-contribution combination-array :green-contribution)
   (blue-contribution combination-array :blue-contribution)))

2;map r,g,b into one value specified by COMBINATION-NAME
0(def-operator combine-operators :named-with-alpha
  ((lambda (vals ignore) `(aref gray-contribution ,(first vals))))
  ((gray-contribution combination-array
		      :translation-array-with-alpha combination-name default-alpha)))

(def-operator combine-operators :named
  ((lambda (vals ignore) `(aref gray-contribution ,(first vals))))
  ((gray-contribution combination-array combination-name )))

2;inclusive or R,G and B
0(def-operator combine-operators :ior ((lambda (vals ignore) `(logior ,@vals))))

2;combine R,G,and B into a fixnum
0(def-operator combine-operators :rgb
  ((lambda (vals ignore)
     `(si:%logdpb ,(third vals)
		  (byte 8 16)
		  (si:%logdpb ,(second vals)
			      (byte 8 8)
			      ,(first vals))))))


2;combine R,G,B,and Alpha into a fixnum
0(def-operator combine-operators :rgba
  ((lambda (vals ignore)
     `(si:%logdpb ,(or (fourth vals) 'default-alpha)
		  (byte 8 24)
		  (si:%logdpb ,(third vals)
			      (byte 8 16)
			      (si:%logdpb ,(second vals)
					  (byte 8 8)
					  ,(first vals)))))))

(def-operator combine-operators :default-alpha
  ((lambda (ignore ignore)
     'default-alpha)))
     
(def-operator combine-operators :max
  ((lambda (vals ignore)
     (loop with a = (first vals)
	   for b in (cdr vals)
	   do (setq a `(max ,b ,a))
	   finally (return a))
     )))

(def-operator combine-operators :min
  ((lambda (vals ignore)
     (loop with a = (first vals)
	   for b in (cdr vals)
	   do (setq a `(min ,b ,a))
	   finally (return a))
     )))

(def-operator combine-operators :r
  ((lambda (vals ignore)
     (first vals)
     )))

(def-operator combine-operators :g
  ((lambda (vals ignore)
     (second vals)
     )))

(def-operator combine-operators :b
  ((lambda (vals ignore)
     (third vals)
     )))

(def-operator combine-operators :alpha
  ((lambda (vals ignore)
     (or (fourth vals) 'default-alpha
     ))))

(def-operator combine-operators :intensity
  ((lambda (vals ignore)
     `(fixnum-rgb->i ,(first vals) ,(second vals) ,(third vals))
     )))

(def-operator combine-operators :y
  ((lambda (vals ignore)
     `(fixnum-rgb->y ,(first vals) ,(second vals) ,(third vals))
     )))

2;sum all the intermediate values
0(def-operator combine-operators :+
  ((lambda (vals ignore) `(+ ,@vals))))

2;truncate 8 bits to 2 bits
0(def-operator combine-operators :8b-2b
  ((lambda (vals ignore) `(ldb (byte 2 6) ,@vals))))

2;truncate 042 bits to 2 bits
0(def-operator combine-operators :4b-2b
  ((lambda (vals ignore) `(ldb (byte 2 2) ,@vals))))

2;truncate 8 bits to 042 bits
0(def-operator combine-operators :8b-4b
  ((lambda (vals ignore) `(ldb (byte 4 4) ,@vals))))

2;call the color map to find the closest color
0(def-operator combine-operators :random-palette
  ((lambda (vals ignore)
     `(fixnum-closest-color-in-palette combination-array ,@vals))))


(4 0 (NIL 0) (NIL :ITALIC :LARGE) "MEDFNTI");;
;;Dithered versions of the above
;;
2;threshold the result to 1 or 0
0(def-operator combine-operators :dithered-threshold
  ((lambda (values ignore)
     `(let ((v (+ ,(first values) error-term)))
	(if (>= v  threshold)
	    (progn
	      (setq error-term (- v brightness))
	      white-pixel)
	    (progn (setq error-term v)
		   black-pixel)))))
  ((error-term 0)))

2;map r,g,b into a standard palette specified by COMBINATION-ARRAY
0(def-operator combine-operators :dithered-palette
  ((lambda (vals ignore)
     `(progn
	(let ((rc (aref red-contribution (min 255 (max 0 (- ,(first vals) red-error)))))
	      (gc (aref green-contribution (min 255 (max 0 (- ,(second vals) green-error)))))
	      (bc (aref blue-contribution (min 255 (max 0 (- ,(third vals) blue-error))))))
	  (setq red-error (ash rc -16)
		green-error (ash gc -16)
		blue-error (ash bc -16))
	  (ldb (byte 8 0) (+ rc gc bc))))))
  ((red-contribution combination-array :red-contribution-with-error)
   (green-contribution combination-array :green-contribution-with-error)
   (blue-contribution combination-array :blue-contribution-with-error)
   (red-error 0)
   (green-error 0)
   (blue-error 0)
   ))


2;map r,g,b into one value specified by COMBINATION-NAME
0(def-operator combine-operators :dithered-named
  ((lambda (vals ignore)
     `(progn
	(let ((gc (aref gray-contribution (min 255 (max 0 (- ,(first vals) error-term))))))
	  (setq error-term (ash gc -16))
	  (ldb (byte 8 0) gc)))))
  ((gray-contribution combination-array combination-name)
   (error-term 0))
  )

(def-operator combine-operators :2b-dithered-named
  ((lambda (vals ignore)
     `(progn
	(let ((gc (aref gray-contribution (min 3 (max 0 (- ,(first vals) error-term))))))
	  (setq error-term (ash gc -16))
	  (ldb (byte 8 0) gc)))))
  ((gray-contribution combination-array combination-name)
   (error-term 0))
  )

(def-operator combine-operators :4b-dithered-named
  ((lambda (vals ignore)
     `(progn
	(let ((gc (aref gray-contribution (min 15 (max 0 (- ,(first vals) error-term))))))
	  (setq error-term (ash gc -16))
	  (ldb (byte 8 0) gc)))))
  ((gray-contribution combination-array combination-name)
   (error-term 0))
  )

2;truncate 8 bits to 2 bits
0(def-operator combine-operators :dithered-8b-2b
  ((lambda (vals ignore)
     `(let ((v (min 255 (max 0 ,(- (first vals) error-term)))))
	(setq error-term (- #o77 (ldb (byte 6 0) v)))
	(ldb (byte 2 6) v))))
  ((error-term 0))
   )

2;call the color map to find the closest color
0(def-operator combine-operators :dithered-random-palette
  ((lambda (vals ignore)
     `(multiple-value-bind (val re ge be)
	  (fixnum-closest-color-in-palette-with-error
	    combination-array
	    ,@(loop for v in vals
		    as e in '(red-error green-error blue-error)
		    collect `(min 255 (max 0 (- ,v ,e)))))
	(setq red-error (- re (ash re -1))
	      green-error (- ge (ash ge -1))
	      blue-error (- be (ash be -1)))
	val
	)
     ))
  ((red-error 0)
   (green-error 0)
   (blue-error 0)))

(def-operator combine-operators :dithered-remap
  (combine-remap (:bins)(:dither)(:jitter))
  ((red-error 0)
   (green-error 0)
   (blue-error 0)
   (full-color-translation color-map :full-color-translation-array)))

2;;
;; Store operators:   Take the0 2final value do necessary aset(s)
;; perform other processing to store the single value, except for R+G+B+A
;; format where all three or four 8-bit values are stored directly.
;;
0(defconst store-operators (make-hash-table))

(defmacro aref-masked (ar idx mask)
  (declare lt::(side-effects reader))
  `(cl:logandc2 (aref ,ar ,idx) ,mask))

(cl:defsetf aref-masked (ar idx mask) (new)
  (once-only (ar idx mask)
    `(setf (aref ,ar ,idx)
	   (logxor ,new (cl:logand ,mask (logxor ,new (aref ,ar ,idx)))))))

(defmacro %32b-incf (x n)
  `(setf ,x (%32-bit-plus ,x ,n)))

2;no result
0(def-operator store-operators nil)
2;store the result as a direct ASET
0(def-operator store-operators :rgba (aref-byte nil))
2;store R,G and B arrays, from one value three times or from three values
0(def-operator store-operators :r+g+b (aref-byte nil nil nil))
2;likewise, store R,G,B and Alpha
0(def-operator store-operators :r+g+b+a (aref-byte nil nil nil nil))
2;store RGB (24 bits) into an art-fixnum
0(def-operator store-operators :rgb (aref-byte (24 0)))
2;store Red only into an art-fixnum
0(def-operator store-operators :red (aref-byte (8 0)))
2;store Green only into an art-fixnum
0(def-operator store-operators :green (aref-byte (8 8)))
2;store Blue only into an art-fixnum
0(def-operator store-operators :blue (aref-byte (8 16)))
2;store alpha only into an art-fixnum
0(def-operator store-operators :alpha (aref-byte (8 24)))
2;store three consecutive values in one array
0(def-operator store-operators :packed-rgb (aref-byte nil nil nil) (:single-source))
2;store two consecutive values in one array
0(def-operator store-operators :packed-yuv (aref-byte nil nil) (:single-source))

(def-operator store-operators :packed-yuv-from-rgb
  (:pack-yuv nil nil) (:single-source))


;
#||
 The basic processing model this implements is
 (<<prepare OTHER-ORRAYS (list)>>
    <<prepare source arrays (derived from source)>>
    <<optional prepare destination arrays (derived from dest)>>
    <<FIRST (macro)>>
    (loop repeat height
       <<BEFORE-LINE (macro)>>
       (loop repeat width
	     <<FETCH (keyword)>>
	     <<increment-source>>
	     <<MAP (keyword)>>
	     <<SEPARATE (keyword)>>
	     <<BEFORE-PER-COLOR (macro)>>
	     <<PER-COLOR (macro)>>
	     <<AFTER-PER-colOR (macro)>>
	     <<COMBINE (keyword)>>
	     <<BEFORE-STORE (macro)>>
	     <<STORE (keyword)>>
	     <<increment-dest>>)
	    <<AFTER-LINE (macro)>>
	    )
       <<LAST (macro)>>)
||#

(eval-when (eval compile load)
(defconst image-process-macro-all-args 
	`(2;;
0	  2;; these five are the basic, default key parameters which identify the
	  ;; image process.  Use :KEY-ARGS to augment the list, and :NOT-KEY-ARGS
	  ;; to diminish it
0	  2;;
0	  :arglist
	  :fetch
	  :separate
	  :map
	  :store
	  :combine
	  :main-loop

	  2;;
	  ;; macro calls.  All macros get keyword arguments specifying
	  ;; the key parameters in use
0	  2;;
0	  :first
	  :before-line
	  :optional-fetch
	  :before-per-color :after-per-color
	  :per-color
	  :before-store
	  :optional-store
	  :after-line
	  :last
	  2;;
0	  2;; random other control parameters
0	  2;;
0	  :source-pixels-per-group
	  :dest-pixels-per-group
	  :alu
	  :catmull-speed
	  :catmull-pass
	  :rescale
	  :n-lines-parallel
	  :n-pixels-parallel
	  :rescale-rolled-y  ;old, slower Y loop which 
	  :dither :jitter

2	  ;;
	  ;; lists used to build auxiliary parts of the functions
	  ;;
0	  :intermediate-values   ;names of the components
	  :locals-per-color      ;names of intermediates per-component
	  :locals-per-line
	  :store-local-per-color ;name of the intermediate per-color to store
	  :locals                ;other locals
	  :other-arrays          ;locals which are array registers

	  :note-progress
	  :permitted-args
	  :save-last-pixel
	  :print-message

	  :permutation
	  :permutation-for-destination
	  :ignored-args
	  ,@*special-image-keywords*
	  ,@*special-image-keyword-args*
	  )))

(defun normalize-image-process-args
       (&rest other-args
	&key
	(separate nil)
	(map nil)
	(fetch :rgba)
	(combine nil)
	(store (if (memq combine '(:ior :rrr)) :rgba combine))
	(key-args)
	(non-key-args)
	(default-alpha)
	permitted-args
	ignored-args
	intensity-operator
	silent
	&allow-other-keys)

  (loop for (arg nil) on other-args
		 by #'cddr
	unless (or (eq arg :key-args)
		   (eq arg :non-key-args)
		   (eq arg :intensity-operator)
		   (member arg ignored-args)
		   (member arg image-process-macro-all-args)
		   (member arg permitted-args))
	  do
	    (unless silent
	      (warn "~s isn't a valid arg for image process macro" arg)
	      ))
  (loop for i in non-key-args
	do
    (selector i eq
      (:fetch (setq fetch nil))
      (:separate (setq separate nil))
      (:map (setq map nil))
      (:combine (setq combine nil))
      (:store (setq store nil))))

  (when intensity-operator
    (when (eq default-alpha :intensity) (setq default-alpha intensity-operator))
    (when (eq separate :intensity) (setq separate intensity-operator))
    (when (eq combine :intensity) (setq combine intensity-operator)))
  
  (when (memq combine '(:rgba :rgb))
    (cond (map)
	  ((null default-alpha))
	  ((symbolp default-alpha)
	   (setq separate
		 (list separate default-alpha)))
	  (default-alpha
	   (setq separate (list separate :default-alpha))
	  )))
  
  (values fetch separate
	  (cond ((not (symbolp map)) t)
		(t map))
	  combine store
	  (loop for key in key-args
		as val = (get (locf other-args) key)
		unless (memq key ignored-args)
		nconc `(,key ,val))))

(defun un-normalize-spec (normal-spec)
  (destructuring-bind (fetch separate map combine store other) normal-spec
    `(:fetch ,fetch :separate ,separate :map ,map :combine ,combine :store ,store ,@other)))

(defvar image-process-macro-key-args nil)
(defvar image-process-macro-common-args nil)

(defmacro spec-div-rounded (val)
  `(progn
     (multiple-value-bind (nil dummy)
	 (sys:%multiply-bignum-step ,val inv-src-ary-size)
       (%logldb (byte 8 1) (1+ dummy)))))

(defmacro spec-div (val)
  `(progn
     (multiple-value-bind (nil dummy)
	 (sys:%multiply-bignum-step ,val inv-src-ary-size)
       dummy)))


(defsubst fast-floor-above-0 (float)
  (let* ((.f. (sys:%fixnum float))
	 (frac (logior #o40000000 (ldb sys:%%single-fraction .f.)))
	 (sign (ldb-test sys:%%single-sign .f.))
	 (sfrac (if sign 0 frac))
	 (exp (ldb sys:%%single-exponent .f.)))
    (ash sfrac (- exp 150))))

(defsubst fast-floor (float)
  (let* ((.f. (sys:%fixnum float))
	 (frac (logior #o40000000 (ldb sys:%%single-fraction .f.)))
	 (sign (ldb-test sys:%%single-sign .f.))
	 (sfrac (if sign (- frac) frac))
	 (exp (ldb sys:%%single-exponent .f.)))
    (ash sfrac (- exp 150))))

(defsubst fast-ceiling (float)
  (if (fixnump float)
      float
      (let* ((.f. (sys:%fixnum float))
	     (fr (ldb sys:%%single-fraction .f.))
	     (frac (logior #o40000000 fr))
	     (sign (ldb-test sys:%%single-sign .f.))
	     (sfrac (if sign (- frac) frac))
	     (ex (ldb sys:%%single-exponent .f.))
	     (exp (- ex 150))
	     (fracbits (rot frac exp))
	     (fracmask (lognot (lsh #o77777777 exp))))
	(if (and (zerop ex) (zerop fr))
	    0
	    (+ (ash sfrac exp)
	       (if (bit-test fracmask fracbits) 1 0))))))

(defsubst fast-ceiling-times-2 (float)
  (let* ((.f. (sys:%fixnum float))
	 (fr (ldb sys:%%single-fraction .f.))
	 (frac (logior #o40000000 fr))
	 (sign (ldb-test sys:%%single-sign .f.))
	 (sfrac (if sign (- frac) frac))
	 (ex (ldb sys:%%single-exponent .f.))
	 (exp (- ex 149))
	 (fracbits (rot frac exp))
	 (fracmask (lognot (lsh #o77777777 exp))))
    (if (and (zerop ex) (zerop fr))
	0
      (+ (ash sfrac exp)
	 (if (bit-test fracmask fracbits) 1 0)))))

(defun construct-form (body &rest args
		      &key
		      (arglist '(width height src sx sy dest dx dy dest-width dest-height))
		      (permutation 0)
		      (permutation-for-destination 0)
		      (argument-source :source)
		      (source-span 'src-span)
		      (dest-span 'dest-span)
		      fetch-multiplier
		      store-multiplier
		      &allow-other-keys
		      &aux (from-field 'from-field)
		      (to-field 'to-field)
		      )
  (when (null permutation)(setq permutation 0))
  (when (null permutation-for-destination) (setq permutation-for-destination 0))

  (destructuring-bind (width height src sx sy dest dx dy dest-width dest-height)
      arglist
    (when (or (null dest-width) (eq dest-width 'ignore)) (setq dest-width width))
    (when (or (null dest-height) (eq dest-height 'ignore)) (setq dest-height height))
    (when (bit-test 1 permutation) (swapf dest-width dest-height))
    (when (bit-test 1 permutation-for-destination) (swapf dest-width dest-height))
    (selectq argument-source
      (:source)
      (:destination (setq src dest sx dx sy dy width dest-width height dest-height
			  permutation permutation-for-destination
			  fetch-multiplier store-multiplier
			  from-field to-field
			  source-span dest-span))
      (t (warn "Permutation source must be :SOURCE or :DESTINATION")
	 ))
    (ignore src)
    (labels ((permuted-increment
	       (focus)
	       (let* ((x-inc 1)
		      (x-dec (- (if fetch-multiplier
				     (+ fetch-multiplier fetch-multiplier -1)
				     1)))
		      (y-inc `(ash ,source-span (if ,from-field 1 0)))
		      (y-dec `(- ,y-inc)))
		 (when (bit-test 1 permutation)
		   (setq x-inc (if fetch-multiplier
				   `(- ,y-inc ,(- fetch-multiplier 1))
				   y-inc)
			 x-dec (if fetch-multiplier
				   `(- (+ ,(- fetch-multiplier 1) ,y-inc))
				   y-dec)
			 y-inc (or fetch-multiplier 1)
			 y-dec (- y-inc)))
		 (when (bit-test 2 permutation) (swapf x-inc x-dec))
		 (when (bit-test 4 permutation) (swapf y-inc y-dec))
		 (selectq focus
		   (:line y-inc)
		   (:pixel x-inc)
		   (t (warn "Focus must be pixel or line")))))
	     (permuted-initial-xy
	       (first-p)
	       (let ((last-y `(if ,from-field
				  (+ (ash ,height 1) ,sy ,from-field -1)
				  (+ ,height ,sy)))
		     (first-y `(if ,from-field (+ ,sy ,from-field -1) ,sy))
		     (last-x `(+ ,(if fetch-multiplier
				      `(* ,fetch-multiplier ,width)
				      width)
				 ,sx))
		     (first-x sx)
		     (x-span 1)
		     (y-span source-span)
		     (x-mul (or fetch-multiplier 1))
		     (y-mul 1))
		 (when (bit-test 1 permutation)
		   (swapf last-y last-x)
		   (swapf x-mul y-mul)
		   (swapf first-y first-x)
		   (swapf x-span y-span))
		 (when (bit-test 2 permutation)
		   (swapf first-x last-x)
		   (setq first-x `(- ,first-x ,x-mul))
		   (setq last-x `(- ,last-x ,x-mul))
		   )
		 (when (bit-test 4 permutation)
		   (swapf first-y last-y)
		   (setq first-y `(- ,first-y ,y-mul))
		   (setq last-y `(- ,last-y ,y-mul)))
		 (if first-p
		     `(+ ,(if (eql x-span 1)
			      first-x
			      `(* ,first-x ,x-span))
			 ,(if (eql y-span 1)
			      first-y
			      `(* ,first-y ,y-span)))
		     `(+ ,(if (eql x-span 1)
			     first-x
			     `(* ,first-x ,x-span))
			,(if (eql y-span 1)
			     last-y
			     `(* ,last-y ,y-span))))))
	     (permuted-keyword (word)
	       (selectq word
		 (:next-y (permuted-increment :line))
		 (:next-x (permuted-increment :pixel))
		 (:last-y (permuted-initial-xy  nil))
		 (:first-y (permuted-initial-xy t))
		 (:signed-width
		  (let ((ix (permuted-increment :pixel))
			(wid (permuted-keyword :width)))
		    (cond ((eql ix 1) wid)
			  ((eql ix -1) `(- ,wid))
			  (t `(* ,ix ,wid)))))
		 (:height (if (bit-test 1 permutation) width height))
		 (:width (if (bit-test 1 permutation) height width))
		 (t (when (keywordp word)
		      (let ((val (cl:getf args word args)))
			(cond ((eq val args)
			       (warn "~A isn't a permuted address keyword" word)
			       word)
			      (t val)))))))
	     (transform (form)
	       (if (nlistp form)
		   form
		   (if (keywordp (car form))
		       (if (null (cdr form))
			   (permuted-keyword (car form))
			   (lexpr-funcall #'construct-form
					  `(,(car form))
					  :argument-source (second form)
					  args))
		       (loop for f in form collect (transform f))
		       ))))
      (transform body))))


#||
(defun test (perm)
  (loop for destination in '(:source :destination) collect
    `(,destination
      ,@(loop for word in '(:first-y :next-x :next-y :last-y
				     :width :height :signed-width
			    )
	      collect
		`(,word
		  ,(construct-form `(,word ,destination)  :permutation perm))))))
||#
    
(defmacro image-process-macro (&rest args)
  (declare #.`(arglist (&key ,@image-process-macro-all-args)))
  (let ((val (lexpr-funcall #'image-process-macro-internal
		 (append args
			 image-process-macro-key-args
			 image-process-macro-common-args))))
    val))

(defun image-process-macro-separate
       (&key
	inc
	produce-value
	mapped-form
	separate-operator
	fetch-multiplier
	intermediate-values
	separate-args
	sources
	save-last-pixel
	alpha-operator
	alpha-args
	(index-var 'src-index)
	(sum nil)
	multiple-value-fetch
	no-inc
	)
2  ;;separate the fetched value into color components
0  (selectq produce-value
    (nil nil)
    (t
     (let ((extra-incs 0))
       `(progn
	  ,@(cond ((null separate-operator)
2						;see FETCH-MULTIPLIER calculation
0		   (if multiple-value-fetch
		       `((multiple-value ,intermediate-values ,mapped-form))
		       (loop with ma = mapped-form
			     as srcp first (cdr ma) then (or (cdr srcp) (cdr ma))
			     as (src) = srcp
			     for color in intermediate-values
			     for n from 0 below (or fetch-multiplier (length (cdr ma)))
			     when (and fetch-multiplier (> n 0))
			       collect (progn (incf extra-incs)
					      `(setq ,index-var (+ ,index-var 1)))
			     collect `(setq ,color ,(if sum `(+ ,color ,src) src)))))
		  ((null (cdr separate-args))
		   (let ((val (subst index-var 'src-index 
			  (funcall separate-operator
				   (if (null fetch-multiplier)
				       (cdr mapped-form)
				       (loop with src = (cadr mapped-form)
					     as n from 0 below fetch-multiplier
					     collect
					       `(progn
						  ,@(when (> n 0)
						      (incf extra-incs)
						      `((setq ,index-var
							      (+ ,index-var 1))))
						  ,src)
					       ))
				   separate-args
				   intermediate-values))))
		     (when sum
		       (loop for (op var . rest) in val
			     do (unless (eq op 'setq)
				  (ferror "don't understand op = ~A" op))
				(setf (car rest)
				      `(+ ,var ,(car rest)))))
		     val))
		  (t 
		   (let ((single-fetch (and (null (cdr sources)) (null fetch-multiplier))))
		     `(,@(when single-fetch
			   `((setq ,save-last-pixel ,mapped-form)))
		       ,@(let ((val (subst index-var 'src-index
				(funcall separate-operator
					 (cond (single-fetch (list save-last-pixel))
					       ((null fetch-multiplier) (cdr mapped-form))
					       (t (loop with src = (cadr mapped-form)
							as n from 0 below fetch-multiplier
							collect
							  `(progn ,@(when (> n 0)
								      `((setq ,index-var (+ ,index-var ,inc))))
								  ,src)
							  )))
					 separate-args
					 intermediate-values))))
			   (when sum
			     (loop for (op var . rest) in val
				   do (unless (eq op 'setq)
					(ferror "don't understand op = ~A" op))
				      (setf (car rest)
					    `(+ ,var ,(car rest)))))
			   val
			   )))))
	  ,@(cond ((null alpha-operator) nil)
		  (t `((setq ,(fourth intermediate-values)
			     ,(funcall alpha-operator (butlast intermediate-values 1)
				       alpha-args
				       )))))
	  ,@(unless no-inc
	      `((setq ,index-var (+ ,index-var ,inc)))))))
    )
  )

(defun image-process-macro-nth-value (n &key
				      rescale-store-type
				      s&s-ars
				      s&s-temps
				      rescale
				      store-local-per-color
				      (pixel-count 1)
				      jitter)
  2;;nth value is just the n'th intermediate value, except
0  2;;if we are rescaling, in which case we have to do the
0  2;;conversion to actual values just before we use them.
0  (labels ((nth-rescale-aref (n)
	     (selectq rescale-store-type
	       ((:setq-temp :accum-temp)
		`(aref ,(nth n s&s-ars) tmp-dst-index))
	       (:store-direct
		(nth n s&s-temps))
	       (:store-sum
		`(%32-bit-plus (aref ,(nth n s&s-ars) tmp-dst-index)
		    ,(nth n s&s-temps))
		)
	       (t (warn "~S isn't a store type" rescale-store-type)))))
    (decf n)
    (let ((val (selectq rescale
		 (:truncated `(spec-div ,(nth-rescale-aref n)))
		 (:select
		  (nth n store-local-per-color))
		 (nil (nth n store-local-per-color))
		 (:pixel-average
		  (let ((pow2+ (haulong pixel-count))
			(pow2- (haulong (1- pixel-count))))
		    (if ( pow2+ pow2-)
			`(lsh ,(nth n store-local-per-color) ,(- pow2-))
			`(// ,(nth n store-local-per-color) ,pixel-count))
		    ))
		 ((:rounded :average t)
		  `(spec-div-rounded ,(nth-rescale-aref n)))
		 )))
      (when jitter
	(setq val `(+ random-increment ,val)))
      val))
  )

(defun image-process-macro-store
       (&key
	return-value
	store-operator
	store-args
	store-local-per-color
	dars
	combine-operator
	write-mask
	before-store
	rescale-store-type
	s&s-ars
	s&s-temps
	rescale
	jitter
	(pixel-count 1)
	)
  (labels ((nth-value (n)
	     (image-process-macro-nth-value
	       n
	       :store-local-per-color store-local-per-color
	       :rescale-store-type rescale-store-type
	       :s&s-ars s&s-ars
	       :s&s-temps s&s-temps
	       :rescale rescale
	       :pixel-count pixel-count
	       :jitter jitter)))

2  ;;store the value, after applying combine and so on
0  (cond ((null return-value) nil)
	((null store-operator) before-store)
	(t `(progn
	 ,@(cond
	     ((null dars))
	     ((null (cdr dars))1 
2	      ;;see the STORE-MULTIPLIER calculation
0	      `((let ,(if (null (cdr store-local-per-color))
			  `((val (progn
				   ,before-store
				   ,@(unless combine-operator
				       `(,(nth-value 1)))
				   )))
			  nil)
		  ,@(cond ((eq store-operator :pack-yuv)
			   (setq return-value :no-inc)
			   `((progn ,@(unless (null (cdr store-local-per-color))
					(list before-store))
				  (let (,@(loop for c in store-local-per-color
						as i from 1
						collect `(,c ,(nth-value i))))
				    (if (bit-test 2 dest-index)
					 (let ((y (fixnum-rgbyuv
						    ,@(if (cdr store-local-per-color)
							  store-local-per-color
							  (list 'val 'val 'val))
						    :values :y)))
					   2;
0					   2;include the increment we skipped on the even pixel
0					   2;
0					   (incf dest-index)
					   2;
0					   (setf ,(aref-byte `(aref ,(first dars) dest-index) nil)
						 y)
					   (incf dest-index))
					 (let (y u v)
					   (multiple-value (y u v)
					     (fixnum-rgbyuv
					       ,@(if (cdr store-local-per-color)
						     store-local-per-color
						     (list (first store-local-per-color)
							   (first store-local-per-color)
							   (first store-local-per-color)))))

					   (setf ,(aref-byte `(aref ,(first dars) dest-index) nil)
						 u)
					   (incf dest-index)
					   (setf ,(aref-byte `(aref ,(first dars) dest-index) nil)
						 y)
					   (incf dest-index)
					   (setf ,(aref-byte `(aref ,(first dars) dest-index) nil)
						 v)
					   2;skip the last increment, so the index stays
0					   2;at the expected address.  This makes the end-of-x
0					   2;test work correctly
0					   2;0(incf dest-index)
					   2;
0					   )))
				  )))
			 (t (loop with dest = (first dars)
				  for sa in store-args
				  as n from 1
				  unless (= n 1)
				    collect
				      `(setq dest-index (+ dest-index (:next-x :destination)))
				  collect 
				    `(setf ,(funcall store-operator
						     (if write-mask
							 `(aref-masked ,dest dest-index write-protect-mask)
							 `(aref ,dest dest-index))
						     sa)
					   ,(if (cdr store-local-per-color)
						`(progn
						   ,before-store
						   ,@(unless combine-operator
						       `(,(nth-value n)))
						   )
						'val
						))
				    ))))))
	     (t
	      `(,before-store
		,@(loop for da in dars
			as v = (if write-mask
				   `(aref-masked ,da dest-index write-protect-mask)
				   `(aref ,da dest-index))
			as sa in store-args
			as pv = (funcall store-operator v sa)
			as i from 1
			as iv = (if (cdr store-local-per-color)
				    (nth-value i)
				    'val)
			collect `(setf ,pv ,iv) into tv
			finally (when (null (cdr store-local-per-color))
				  (setq tv `((let ((val ,(nth-value 1)))
					       ,@tv))))
				(return tv)))
	      ))
	 ,@(unless (eq return-value :no-inc)
	     `((setq dest-index (+ dest-index  (:next-x :destination)))))))
      )))

(defun image-process-macro-make-symbols (prefix lst &optional names)
  (loop for i in lst
	as n from 0
	collect (make-symbol (string-append prefix (or (nth n names) i)))))

(defun apply-user-function (fun core &rest other-args)
  2;; this builds in a user function, which can be
0  2;;either NIL, just a function name, or a form.
0  (cond ((null fun)
	 core)
	((nlistp fun)
	 (if (null core)
	     `(,fun ,@(copylist other-args))
	     `(,fun ,core ,@(copylist other-args))))
	(t `(,(car fun)
	     ,@(if core `(,core) nil)
	     ,@(copylist other-args)
	     ,@(cdr fun)))))

(defun apply-user-function-now (fun core &rest other-args)
  (let ((val (lexpr-funcall #'apply-user-function fun core other-args)))
    (eval val)))
	   
(defun image-process-macro-per-color
       (&key
	state
	per-color
	actual-locals-per-color
	intermediate-values
	pixel-in-group
	pixels-per-group)
  (when per-color
    `(progn ,@(loop for color in intermediate-values
		    as color-id in '(:red :green :blue :alpha)
		    as locals in actual-locals-per-color
		    collect
		      (lexpr-funcall #'apply-user-function
				     per-color
				     color
				     `(,color-id
				       ,@(when ( 1 pixels-per-group)
					   `(,pixel-in-group))
				       ,@(when locals
					   `(:locals ,locals))
				       ,@(when state `(:state ,state))
				     ))))))
(defun image-process-macro-internal
       #.`(&rest args
		    &key ,@(loop for i in image-process-macro-all-args
				 collect (intern (string i)))
		    &allow-other-keys)
	  permitted-args


  (let (pixels-per-group
	source-lines-per-group
	multiple-value-fetch
	no-inc-source
	source-span-used
	dest-span-used
	fetch-multiplier
	(args (nconc (copylist args)
		     . #.(let* ((aargs (loop for i in image-process-macro-all-args
					   nconc `(,i ,(intern (string i)))))
			      (half (nthcdr (1- (// (length aargs) 2)) aargs))
			      (half2 (cdr half)))
			 (setf (cdr half) nil)
			 `((list ,@aargs)
			   (list ,@half2)))
		     )))
  (labels ((expand-var (format from-arg operators arg &aux single-source)
	     (destructuring-bind ((func . funargs) other-a)
		 (multiple-value-bind (val found)
		     (gethash format operators)
		   (unless found
		     (warn 1"~S isn't a known ~A format specifier"0 format arg))
		   val)
	       (when other-a
		 (loop for i in other-a
		       as iname = (if (listp i) (car i) i)
			 do
		   (if (keywordp iname)
		       (selectq iname
			 (:single-source (setq single-source t))
			 (:multiple-value-fetch (setq multiple-value-fetch t))
			 (:no-inc (setq no-inc-source t))
			 (:fetch-multiplier (setq fetch-multiplier (second i)))
			 (:locals (setq locals (nconc (loop for j in (cdr i)
								collect
								  (if (listp j)
								      j
								      (list j nil)))
						      locals)))
			 (:before-line
			  (setq before-line `(progn ,(copytree (cdr i)) ,before-line)))
			 (t (ferror "~S isn't a known directive")))

		   (if (and (null (cddr i))
			    (or (null (second i)) (numberp (second i))))
		       (let ((n (assq iname locals)))
			 (when n (setq locals (delete n locals-per-line)))
			 (push `(,(first i) ,(second i)) locals-per-line)
			 )
		       (let ((n (assq iname other-arrays)))
			 (when n (setq other-arrays (delete n other-arrays))))
		       (push `(,(car i) ,(cond ((null (cddr i))
						(second i))
					       (t
						`(if (arrayp ,(second i))
						     ,(second i)
						     (send ,@(cdr i))))))
			     other-arrays)
		       ))
		   ))
	       (values
		 (when from-arg
		   (cond ((or single-source (null (cdr funargs)))
			  `(,from-arg))
			 (t (loop for i in funargs
				  as j in `(first second third fourth)
				  do (ignore i)
				  collect `(,j ,from-arg)))))
		 func
		 (lexpr-funcall #'construct-form funargs
				     args))))
	   )

    (when (null arglist)
2      ;the default arg list
0      (setq arglist '(width height src sx sy dest dx dy)))

    (when (listp rescale)
      (setq source-pixels-per-group (second  rescale)
	    dest-pixels-per-group 1
	    source-lines-per-group 
	    (loop repeat (1- (third rescale))
		  as i from 2
		  collect
		    (make-symbol (format nil "sidx-~D" i)))
	    rescale (first rescale))
      )

    (when (null source-pixels-per-group)
2      ;when not unrolling the X-axis loop
0      (setq source-pixels-per-group 1
	    dest-pixels-per-group 1))

    (setq pixels-per-group (max source-pixels-per-group dest-pixels-per-group))

    (when (and (neq rescale :pixel-average)
	       (or (eq main-loop :copy)
		   (> pixels-per-group 1)))
      (setq rescale nil))

    (when (eq rescale :select)
      (setq rescale-rolled-y nil))

    (multiple-value (fetch separate map combine store)
      (lexpr-funcall #'normalize-image-process-args args))

    (when (and rescale
	       (< (length arglist) 10))
      2;when rescaling, there is a separate dest-height and dest-width
0      (setq arglist (append arglist '(dest-width dest-height))))

    (destructuring-bind (width height src sx sy dest dx dy dest-width dest-height) arglist
      2;Above, bind the user's names for the arguments.  Below, create names
0      2;for the internediate variables we will need in the resulting function
0      (when (or (null dest-width)(eq dest-width 'ignore))
	(setq dest-width width))
      (when (or (null dest-height) (eq dest-height 'ignore))
	(setq dest-height height))

    (multiple-value-bind (sources fetch-operator fetch-args)
	(expand-var fetch src fetch-operators "FETCH")
    (multiple-value-bind (nil map-operator map-args)
	(expand-var map nil map-operators "MAP")
    (multiple-value-bind (nil separate-operator separate-args)
       (expand-var (if (listp separate) (first separate) separate)
		   nil
		   separate-operators "SEPARATE")
    (multiple-value-bind (nil alpha-operator alpha-args)
       (expand-var (when (listp separate) (second separate))
		   nil
		   combine-operators
		   "ALPHA")
    (multiple-value-bind (nil combine-operator combine-args)
        (expand-var combine nil combine-operators "COMBINE")
    (multiple-value-bind (dests store-operator store-args)
	(expand-var store dest store-operators "STORE")

   (let* ((intermediate-values (loop for i from 1 to (+ (if separate-args
							    (length separate-args)
							    (length fetch-args))
							(if alpha-operator 1 0))
				     as j = (or (nth (1- i) intermediate-values)
						(nth (1- i) '(red green blue alpha)))
				     collect j))
	  (per-color-operation (if (listp per-color) (first per-color) per-color))
	  (sars (image-process-macro-make-symbols "src-" sources '(r g b alpha)))
	  (dars (image-process-macro-make-symbols "dest-" dests '(r g b alpha)))
	  (s&s-ars (when (and rescale (neq rescale :select)(neq rescale :pixel-average))
		     (image-process-macro-make-symbols "s&s-" intermediate-values)))
	  (s&s-temps (when (and rescale
				(neq rescale :select)
				(neq rescale :pixel-average)
				(not rescale-rolled-y))
		       (image-process-macro-make-symbols "s-" intermediate-values)))
	  (bitblt (eq per-color-operation :bitblt))
	  (bitblt-function (and bitblt (or (cadr per-color) 'tv:bitblt)))
	  (actual-locals-per-color
	    (loop for color in intermediate-values
		  collect (image-process-macro-make-symbols (string-append color "-") locals-per-color)))
	  (store-local-per-color
	    (cond ((null store-local-per-color) intermediate-values)
		  ((loop for locals in actual-locals-per-color
			   nconc
			   (loop for i in locals-per-color
				 as ii in locals
				 when (eq i store-local-per-color)
				   return (list ii))))
		  (t (list store-local-per-color)
		  )))
	  (all-locals (unless bitblt 
			`(,@intermediate-values
			  ,@(loop for i in actual-locals-per-color
				  append i)
			  ,@locals
			  )))
	  pixel-in-group
	  (rescale-store-type :accum-temp)
	  (store-multiplier (when ( (length dests) (length store-args))
			      (length store-args)))

	  2;these modify the end-of-line target, considering the number of fetches per pixel
0	  (fetch-multiplier (or fetch-multiplier
				(when ( (length sources)(length fetch-args))
				  (length fetch-args)
				  )))
	  )
      2;;when save-last-pixel is required, give it a name unless it has one
0      (when (eq save-last-pixel t)
	(setq save-last-pixel (make-symbol "save-last-pixel")))

      (when write-mask
	(unless (memq 'write-protect-mask all-locals)
	  (push '(write-protect-mask (lognot write-mask)) all-locals)))

      (when (and (or save-last-pixel
		     (when (and store
				(cdr separate-args))
		       (setq save-last-pixel (make-symbol "save-last-pixel"))))
		 (not (memq save-last-pixel all-locals)))
	(push save-last-pixel all-locals))

      (when (eq computed-source-lines t)
	(setq computed-source-lines (make-symbol "computed-source-lines")))
      (when (eq computed-dest-lines t)
	(setq computed-dest-lines (make-symbol "computed-dest-lines")))
    (labels ((nth-value (n)
	       (image-process-macro-nth-value
		 n
		 :store-local-per-color store-local-per-color
		 :rescale-store-type rescale-store-type
		 :s&s-ars s&s-ars
		 :s&s-temps s&s-temps
		 :rescale rescale
		 :pixel-count (* pixels-per-group (1+ (length source-lines-per-group)))
		 :jitter jitter))
	     (separate (val &key (inc '(:next-x)) (index-var 'src-index)(sum nil))
2	       ;;separate the fetched value into color components
0	       (image-process-macro-separate
		 :no-inc no-inc-source
		 :multiple-value-fetch multiple-value-fetch
		 :produce-value val
		 :inc inc
		 :mapped-form (if map-operator
				  `(progn
				     ,@(loop for i in (cdr (fetch index-var))
					     as ma in map-args
					     collect
					       (funcall map-operator i ma)))
		      
				  (fetch index-var))
		 :separate-operator separate-operator
		 :separate-args separate-args
		 :fetch-multiplier fetch-multiplier
		 :intermediate-values intermediate-values
		 :sources sources
		 :save-last-pixel save-last-pixel
		 :alpha-operator alpha-operator
		 :alpha-args alpha-args
		 :index-var index-var
		 :sum sum
		 )
	       )
	     (store-it (val)
		    (image-process-macro-store
		      :return-value val
		      :store-operator store-operator
		      :store-args store-args
		      :store-local-per-color store-local-per-color
		      :dars dars
		      :combine-operator combine-operator
		      :write-mask write-mask
		      :before-store
		       (when val
			 (apply-user-function
			   before-store
2			   ;;combine the N intermediate values into one value,
			   ;;prior to the store step
0			   (let ((val (when combine-operator
					(funcall combine-operator
						 (loop for x in store-local-per-color
						       as i from 1
						       do (ignore x)
						       collect (nth-value i))
						 combine-args))))
			     (when (and save-last-pixel val)
			       (setq val `(setq ,save-last-pixel ,val)))
			     (when jitter
			       (setq val
				     `(let ((random-increment
					      (- (small-range jitter-threshold random-value)
						 jitter-2)))
					,val)))
			     val)))
		      :rescale-store-type rescale-store-type
		      :s&s-ars s&s-ars
		      :s&s-temps s&s-temps
		      :rescale rescale
		      :jitter jitter
		      :pixel-count (* pixels-per-group (1+ (length source-lines-per-group)))
		      ))
	     (fetch (&optional (index-var 'src-index))
	       (if multiple-value-fetch
		   (funcall fetch-operator
			     `(aref ,(first sars) ,index-var)
			     (first fetch-args))
		     
		   `(progn ,@(loop for sa in sars
				   as v = `(aref ,sa ,index-var)
				   as fa in fetch-args
				   collect (funcall fetch-operator v fa)
				     ))))
	     (body (early-exit)
2	       ;;this is the normal X-axis body to handle one pixel,
	       ;;which may be optionally fetched and stored, and may
	       ;;involve an unrolled loop treated as a group
0	       (loop with fetched = 0 and stored = 0 and first = t
		     for i from 0 below pixels-per-group
		     do (setq pixel-in-group i)
		     collect
		     `(progn ,@
		       (loop for index-var in `(src-index ,@source-lines-per-group)
			     nconc
			       `(,@(when early-exit
				     `((when (= dest-index last-x-index) (return nil))))
				 ,(separate (let ((v (apply-user-function-now optional-fetch i)))
					      (when v (incf fetched))
					      v)
					    :index-var index-var
					    :sum (and (eq rescale :pixel-average)
						      (not first)))
				 ,(apply-user-function before-per-color nil)
				 ,(image-process-macro-per-color
				    :per-color per-color
				    :actual-locals-per-color actual-locals-per-color
				    :intermediate-values intermediate-values
				    :pixel-in-group pixel-in-group
				    :pixels-per-group pixels-per-group)
				 ,(apply-user-function after-per-color nil)
				 ,(store-it (let ((v (apply-user-function-now optional-store i)))
					   (when v (incf stored))
					   v))
				 )
			       do (setq first nil)))
		       into val
		     finally
		       (when (> pixels-per-group 1)
			 (unless (= fetched (* source-pixels-per-group
					       (1+ (length source-lines-per-group))))
				    
			   (warn "~D fetched but should be ~D"
				 fetched source-pixels-per-group))
			 (cond ((= stored dest-pixels-per-group))
			       ((and (= dest-pixels-per-group 1)(= stored 0))
				(nconc val (list (store-it t))))
			       (t
				(warn "~D stored but should be ~D"
				      fetched dest-pixels-per-group))))
		       (return val)
		       ))
	     (rescale-x-body ()
2	       ;; this is the X-axis body when rescaling.
0	       `(progn
		  (setq diff-x (- src-x-count dst-x-count))
		  (when fetch-next-time
		    ,(separate t)
		    ,(apply-user-function before-per-color nil)
		    ,(image-process-macro-per-color
				  :per-color per-color
				  :actual-locals-per-color actual-locals-per-color
				  :intermediate-values intermediate-values
				  :pixel-in-group pixel-in-group
				  :pixels-per-group pixels-per-group)
		    ,(apply-user-function after-per-color nil)
		    ,@(when (eq rescale :select)
			(loop for i in s&s-ars
			      as j in intermediate-values
			      collect
				`(setf (aref ,i tmp-dst-index)
				       ,j)))
		    (setq fetch-next-time nil))
		  
		  (if (plusp diff-x)
		      (progn
			,@(unless (eq rescale :select)
			    `((setq accum-count (* dst-x-count y-count))))
			(decf src-x-count dst-x-count)
			(setq dst-x-count ,width)
			)
		      
		      (if (minusp diff-x)
			  (decf dst-x-count src-x-count)
			  (setq dst-x-count ,width)
			  )

		      (setq ,@(unless (eq rescale :select)
				`(accum-count (* src-x-count y-count)))
			    src-x-count ,dest-width
			    fetch-next-time t))
		  
		  ,@(when (neq rescale :select)
		      ;accumulate this pixel's partial
		      (loop for i in (if rescale-rolled-y s&s-ars s&s-temps)
			    as j in intermediate-values
			    collect
			      `(%32b-incf
				 ,(if rescale-rolled-y
				      `(aref ,i tmp-dst-index)
				      i)
				 (* ,j accum-count))))

		  ,@(if (eq rescale :select)
			`((when ( diff-x 0) ,(store-it t)))
			`((when ( diff-x 0)
			    ,@(unless rescale-rolled-y
				(selectq rescale-store-type
				  ((:accum-temp :setq-temp)
				   (loop for src in s&s-temps
					 as dest in s&s-ars
					 collect
					   `(,(if (eq rescale-store-type :accum-temp)
						  '%32b-incf 'setf)
					     (aref ,dest tmp-dst-index)
					     ,src))
				   )
				  ((:store-direct :store-sum)
				   `(,(store-it t))
				   )
				  (t (warn "~S isn't a store type" rescale-store-type))
				  ))
			    (setq ,@(loop for src in s&s-temps
					  collect src collect 0))
			    ,@(unless (eq rescale-store-type :store-direct)
				`((incf tmp-dst-index)))
			    )))
		      ))
	     (rescale-y-body ()
	       2;;this is the Y-axis body when rescaling
0	       `(progn
		  ,@(when rescale-rolled-y
		     `(,(rescale-x-loop t)))
		 (cond (( diff-y 0)
			,@(unless rescale-rolled-y `(,(rescale-x-loop :)))
			(if (zerop diff-y)
			    (progn (setq src-y-count ,dest-height)
				   (setq dst-y-count ,height)
				   (setq sidx ,(if computed-source-lines
						   `(funcall ,computed-source-lines)
						   `(+ sidx src-y-increment)))
				   ,@(when note-progress
				       `((setq sline (1+ sline))))
				   )
			    
			    (decf src-y-count dst-y-count)
			    (setq dst-y-count ,height)
			    )
			,@(when rescale-rolled-y
			    `((loop for tmp-dst-index from 0 below ,dest-width
				    do
				,(store-it t)
				,@(loop for i in s&s-ars
					collect
					  `(setf (aref ,i tmp-dst-index) 0))
				)))
			(setq didx ,(if computed-dest-lines
					`(funcall ,computed-dest-lines)
					`(+ didx dest-y-increment)))
			)
		       (t			;(minusp diff-y)
			,@(unless rescale-rolled-y `(,(rescale-x-loop :<)))
			(decf dst-y-count src-y-count)
			(setq src-y-count ,dest-height)
			(setq sidx ,(if computed-source-lines
					`(funcall ,computed-source-lines)
					`(+ sidx src-y-increment)))
			,@(when note-progress
			   `((setq sline (1+ sline))))
			)
		       ))
	       )
	     (x-loop-core ()
	       `(do
		  ,@(let ((body-sample (body nil)))
		     (when (and print-message (not compiler:compiling-whole-file-p))
		       (format t "~&body is ~S~&"
			       (lexpr-funcall #'construct-form
					      (if (eq print-message :all)
						  body-sample
						  (car body-sample))
					      args)))
		     (if (and rescale (neq rescale :pixel-average))
			 `(,(rescale-x-body))
			 body-sample))
		 ,@(when (> dest-pixels-per-group 1)
		     `(finally
			,@(body t)
			))
		 ))
	     (rescale-x-loop-1 (store-type)
	       2;; store-type is one of 0:ACCUM-TEMP :SETQ-TEMP :STORE-DIRECT :STORE-SUM
	       (setq rescale-store-type store-type)
	       `(loop with src-x-count = ,dest-width
		      and dst-x-count = ,width
		      ,@(unless rescale-rolled-y
			  (loop for var in s&s-temps 
				collect 'and
				collect var
				collect '=
				collect 0))
		      ,@(if (memq rescale-store-type '(:accum-temp :store-sum
						       :setq-temp))
			    `(and tmp-dst-index = 0
				  while (< tmp-dst-index ,dest-width))
			    `(and last-dest-index = (+ dest-index image-width)
				  while (< dest-index  last-dest-index)))
			,@(x-loop-core)
			))
	     (rescale-x-loop (y-part)
	       (cond (rescale-rolled-y
		      (rescale-x-loop-1 :accum-temp))
		     ((eq rescale :select)
		      (if (eq y-part :)
			  (rescale-x-loop-1 :store-direct)
			  `(progn)))
		     (t (if (eq y-part :)
			    `(if ( prev-diff-y 0)
				 ;store this time, and stored last-time
				 ,(rescale-x-loop-1 :store-direct)
				 ;store this time, accumulated last time
				 ,(rescale-x-loop-1 :store-sum))
			    `(if ( prev-diff-y 0)
				 ;accum this time, stored last time
				 ,(rescale-x-loop-1 :setq-temp)
				 ;accum this time, accum last-time
				 ,(rescale-x-loop-1 :accum-temp))))))
	     (catmull-body-sample ()
	       (when (and print-message (not compiler:compiling-whole-file-p))
		 (let ((body-sample
			 `(progn ,(macroexpand-1
				    (apply-user-function before-per-color nil
							 :state :before-fetch))
				 ,(macroexpand-1
				    (second (image-process-macro-per-color
					      :state :before-fetch
					      :per-color per-color
					      :actual-locals-per-color actual-locals-per-color
					      :intermediate-values intermediate-values
					      :pixel-in-group pixel-in-group
					      :pixels-per-group pixels-per-group)))
				 ,(separate t :inc '(:next-y))
				 ,(macroexpand-1
				    (apply-user-function before-per-color nil
							 :state :pre-load))
				 ,(macroexpand-1
				    (second (image-process-macro-per-color
					      :state :pre-load
					      :per-color per-color
					      :actual-locals-per-color actual-locals-per-color
					      :intermediate-values intermediate-values
					      :pixel-in-group pixel-in-group
					      :pixels-per-group pixels-per-group
					      )))
				 ,(macroexpand-1 (apply-user-function
						   before-per-color nil
						   :state :before-store
						   ))
				 ,(macroexpand-1
				    (second (image-process-macro-per-color
					      :state :before-store
					      :per-color per-color
					      :actual-locals-per-color actual-locals-per-color
					      :intermediate-values intermediate-values
					      :pixel-in-group pixel-in-group
					      :pixels-per-group pixels-per-group								    )))
				 ,(apply-user-function after-per-color nil)
				 ,(store-it :no-inc)
				 ,(macroexpand-1
				    (second (image-process-macro-per-color
					      :state :after-store
					      :per-color per-color
					      :actual-locals-per-color actual-locals-per-color
					      :intermediate-values intermediate-values
					      :pixel-in-group pixel-in-group
					      :pixels-per-group pixels-per-group								    )))

				 )))
		   (format t "~&body is ~S~&"
			   (lexpr-funcall #'construct-form
					  body-sample
					  args)))))
	     (catmull-second-pass-x-loop ()
	       (catmull-body-sample)
	       `(loop for v from v-top below v-bottom
		      with src-index = (+ x sx (* src-span (+ sy v)))
		      and aidx
			 ,@(if (eq catmull-speed :fast)
			       `(with inc = (// .g) 
				 as idx0 =  (max 0 (+ (* .g v) .h))
				   then (max 0 idx1)
				 as idx1 from (+ (* .g (1+ v)) .h) by .g
				 )
			       `(as numer from (+ .g f-y-n) by .g
				 as denom from (+ .i f-y-d) by .i
				 as idx0 = (max 0 (// f-y-n f-y-d))
				 then (max 0 idx1)
				 as idx1 = (// numer denom)
				 ))
		      as lim = (min biased-height (fast-ceiling idx1))
		      ,@(dda-loop-vars catmull-speed)
		      initially
			(setq aidx (fast-ceiling idx0))
			,(separate t :inc '(:next-y))
			(initialize-dda-vars ,catmull-speed)
			,(image-process-macro-per-color
			   :state :initialize
			   :per-color per-color
			   :actual-locals-per-color actual-locals-per-color
			   :intermediate-values intermediate-values
			   :pixel-in-group pixel-in-group
			   :pixels-per-group pixels-per-group)
		      do
		  (progn ,(apply-user-function before-per-color nil :state :before-fetch)
			 ,(image-process-macro-per-color
			    :state :before-fetch
			    :per-color per-color
			    :actual-locals-per-color actual-locals-per-color
			    :intermediate-values intermediate-values
			    :pixel-in-group pixel-in-group
			    :pixels-per-group pixels-per-group)
			 ,(separate t :inc '(:next-y))
			 ,(apply-user-function before-per-color nil :state :pre-load)
			 ,(image-process-macro-per-color
			    :state :pre-load
			    :per-color per-color
			    :actual-locals-per-color actual-locals-per-color
			    :intermediate-values intermediate-values
			    :pixel-in-group pixel-in-group
			    :pixels-per-group pixels-per-group)
			 ,(apply-user-function after-per-color nil)
			 )
		  (loop 
		    ,@(when (eq catmull-speed :slow)
			`(with inc and uedge and inc^2 and 2inc^2
			       and 2uinc+inc^2 
			       and 1-uedge and 1-u^2))
		    while (< aidx lim)
		      do
			(progn
			  (update-dda-slow ,catmull-speed) 
			  ,(apply-user-function before-per-color nil :state :before-store)
			  ,(image-process-macro-per-color
			     :state :before-store
			     :per-color per-color
			     :actual-locals-per-color actual-locals-per-color
			     :intermediate-values intermediate-values
			     :pixel-in-group pixel-in-group
			     :pixels-per-group pixels-per-group)
			  ,(apply-user-function after-per-color nil)
			  (let ((dest-index (+ didx (* dest-span aidx))))
			    ,(store-it :no-inc))
			  ,(image-process-macro-per-color
			     :state :after-store
			     :per-color per-color
			     :actual-locals-per-color actual-locals-per-color
			     :intermediate-values intermediate-values
			     :pixel-in-group pixel-in-group
			     :pixels-per-group pixels-per-group)
			  (update-dda-fast ,catmull-speed))
		    do (incf aidx)
		      )
		  finally
		    (when (< aidx biased-height)
		      ,(apply-user-function before-per-color nil :state :before-final-store)
		      ,(image-process-macro-per-color
			 :state :before-final-store
			 :per-color per-color
			 :actual-locals-per-color actual-locals-per-color
			 :intermediate-values intermediate-values
			 :pixel-in-group pixel-in-group
			 :pixels-per-group pixels-per-group)
		      ,(apply-user-function after-per-color nil)
		      (let ((dest-index (+ didx (* dest-span aidx))))
			,(store-it :no-inc))
		      )
		  )
		  )
	     (catmull-first-pass-x-loop ()
	       (catmull-body-sample)
	       `(loop repeat (1+ intermediate-width)
		      with src-index = 0 and aidx 
			,@(if (eq catmull-speed :fast)
			      `(with inc = (// a)
				as idx0 = .b then idx1
				as idx1 from (+ a .b) by a)
			      `(with ilim = (float intermediate-array-width)
				as numer from (+ f-x-n a) by a
				as denom from (+ f-x-d m) by m
				as idx0 = (- (// f-x-n f-x-d)
					     intermediate-first-offset)
				  then idx1
				as idx1 = (min ilim
					       (- (// numer denom)
						  intermediate-first-offset))
				)
			      )
		      as lim = (fast-ceiling idx1)
		      ,@(dda-loop-vars catmull-speed)
		      initially 
			,(separate t)
			(setq aidx (fast-ceiling idx0))
			(initialize-dda-vars ,catmull-speed)
			,(image-process-macro-per-color
			   :state :initialize
			   :per-color per-color
			   :actual-locals-per-color actual-locals-per-color
			   :intermediate-values intermediate-values
			   :pixel-in-group pixel-in-group
			   :pixels-per-group pixels-per-group)
			(setf (aref lma v) idx0)
		      do
		  (progn ,(apply-user-function before-per-color nil :state :before-fetch)
			 ,(image-process-macro-per-color
			    :state :before-fetch
			    :per-color per-color
			    :actual-locals-per-color actual-locals-per-color
			    :intermediate-values intermediate-values
			    :pixel-in-group pixel-in-group
			    :pixels-per-group pixels-per-group)
			 ,(separate t)
			 ,(apply-user-function before-per-color nil :state :pre-load)
			 ,(image-process-macro-per-color
			    :state :pre-load
			    :per-color per-color
			    :actual-locals-per-color actual-locals-per-color
			    :intermediate-values intermediate-values
			    :pixel-in-group pixel-in-group
			    :pixels-per-group pixels-per-group)
			 ,(apply-user-function after-per-color nil))

		  (loop ,@(when (eq catmull-speed :slow)
			    `(with inc and uedge and inc^2 and 2inc^2 and 2uinc+inc^2
				   and 1-uedge and 1-u^2))
			while (< aidx lim)
			  do
			    (progn (update-dda-slow ,catmull-speed)
				   ,(apply-user-function before-per-color nil
							 :state :before-store)
				   ,(image-process-macro-per-color
				      :state :before-store
				      :per-color per-color
				      :actual-locals-per-color actual-locals-per-color
				      :intermediate-values intermediate-values
				      :pixel-in-group pixel-in-group
				      :pixels-per-group pixels-per-group)
				   ,(apply-user-function after-per-color nil)
				   (let ((dest-index (+ didx aidx)))
				     ,(store-it :no-inc))
				   ,(image-process-macro-per-color
				      :state :after-store
				      :per-color per-color
				      :actual-locals-per-color actual-locals-per-color
				      :intermediate-values intermediate-values
				      :pixel-in-group pixel-in-group
				      :pixels-per-group pixels-per-group)
				   (update-dda-fast ,catmull-speed))
			do (incf aidx)
			  )
	       finally
		;; Close the last open box and write out dest pixel.
		 (when (< aidx intermediate-width)
		   ,(apply-user-function before-per-color nil :state :before-final-store)
		   ,(image-process-macro-per-color
		      :state :before-final-store
		      :per-color per-color
		      :actual-locals-per-color actual-locals-per-color
		      :intermediate-values intermediate-values
		      :pixel-in-group pixel-in-group
		      :pixels-per-group pixels-per-group)
		   ,(apply-user-function after-per-color nil)
		   (let ((dest-index (+ didx aidx)))
		     ,(store-it :no-inc))
		   )
		 (setf (aref rma v) idx1)
		 ))
	     (main-x-loop () 
	       `(loop ,@(if (> dest-pixels-per-group 1)
			    `(with final-dest-group =
				   (+ didx
				      (* (floor ,(if store-multiplier
							   `(* ,store-multiplier (:signed-width :destination))
							   `(:signed-width :destination))
						,dest-pixels-per-group)
					 ,dest-pixels-per-group))
				   until (= ,(if dests 'dest-index 'src-index)
					    final-dest-group))
			    2;note that this test had better remain "=" normally,
0			    2;because some loops are backwards in X!
0			    `(until (= ,(if (and dests store-operator)
					    'dest-index
					    'src-index)
				       last-x-index)))
			,@(x-loop-core)))
	     (core-y-loop ()
	       `(as src-index = sidx
		 ,@(if (and dests store-operator)
		       `(as dest-index = didx
			    as last-x-index = (+ didx image-width))
		       `(as last-x-index = (+ sidx image-width)))
		 ,@(loop for (i init) in locals-per-line nconc
			 `(as ,i = ,init))
		 do (ignore last-x-index)
		 ,@(let ((fn (subst (first sars) :source
				    (apply-user-function before-line nil))))
		     ;2this subst is a bit of ad-hoc communication for :yuv-rgb
0		     (when fn (list fn)))
		 (when per-line-function (funcall per-line-function))
		 ,@(cond ((and rescale (neq rescale :pixel-average))
			  nil)
			 (t `(,(main-x-loop))))
		 ,@(let ((fn (apply-user-function after-line nil)))
		     (when fn (list fn)))
		 (when (> (time:time-difference (time:fixnum-microsecond-time) last-time)
			  500000)
		   (allow-sheet-activity ,@(when source-span-used
					     `(src src-span))
					 ,@(when dest-span-used
					     `(dest dest-span)))
		   (setq last-time (time:fixnum-microsecond-time)))
		 ))
	     (rescale-y-loop ()
	       (setq before-line
		     `(progn (setq diff-y (- src-y-count dst-y-count))
			     ,@(unless (eq rescale :select)
				 `((cond ((plusp diff-y)
					  (setq y-count dst-y-count))
					 (t (setq y-count src-y-count)))))
			     ,(apply-user-function before-line nil))
		     after-line
		     `(progn ,(rescale-y-body)
			     ,(apply-user-function after-line nil)))
	       `(loop ,@(when computed-source-lines
			  `(initially
			     (when from-field
			       (ferror "From-Field nust be NIL with computed source lines")))
			  )
		      ,@(when computed-dest-lines
			  `(initially
			     (when to-field
			       (ferror "To-Field nust be NIL with computed dest lines")))
			  )
		      with src-y-count = (:height :destination)
		      and dst-y-count = (:height)
		      and diff-x and diff-y = 0
		      and fetch-next-time = t
		      ,@(unless computed-source-lines
			  `(and src-y-increment = (:next-y)))
		      ,@(unless computed-dest-lines
			  `(and dest-y-increment  = (:next-y :destination)))
			,@(unless (eq rescale :select)
			    `(and y-count = 0
				  and accum-count))
		      ,@(unless computed-source-lines
			  `(and slast = (:last-y)))
		      ,@(when (and computed-source-lines 
				   (not computed-dest-lines))
			  `(and dlast = (:last-y :destination)))
		      and sidx = ,(if computed-source-lines
				      `(funcall ,computed-source-lines)
				      `(:first-y))
		      and didx = ,(if computed-dest-lines
				      `(funcall ,computed-dest-lines)
				      `(:first-y :destination))
			,@(when note-progress
			    `(with sline = 0))
			,@(unless (or rescale-rolled-y (eq rescale :select))
			    `(as prev-diff-y = diff-y))
		      and image-width = ,(if (and dests store-operator)
					     (if store-multiplier
						 `(* ,store-multiplier (:signed-width :destination))
						 `(:signed-width :destination))
					    (if fetch-multiplier
						 `(* ,fetch-multiplier (:signed-width))
						 `(:signed-width)))
		      until (or (eql sidx ,(if computed-source-lines
					       :end
					       'slast))
				,@(when (and dests store-operator)
				    (cond (computed-dest-lines
					   `((eql didx :end)))
					  (computed-source-lines
					   `((eql didx dlast))))
				))
			,@(core-y-loop)
			,@(when note-progress
			    `((tv:note-progress sline (:height))))
		      finally
			,@(when computed-dest-lines
2						;force out the last line
0			    `((funcall ,computed-dest-lines)))
			))
	     (catmull-second-pass-y-loop ()
	       `(progn
		  (setq last-top-edge (1- intermediate-height)
			last-bottom-edge 0)
		  (loop with biased-height = (1- (:height :destination))
			  ,@(when note-progress
			      `(with 2w = (* 2 (:width :source))))
			for x from 0 below width
			for rx from intermediate-first-offset
			as didx from (+ ,(if store-multiplier
					     `(* dx ,store-multiplier)
					     'dx)
					(* (- dy bias-y) dest-span))
			   ,@(when store-multiplier `(by ,store-multiplier))
			as v-top = (first-pass-start self x)
			as v-bottom = (first-pass-end self x)
			   ,@(if (eq catmull-speed :fast)
				 `(with .g = (- f (// (* b e) a))
					as .h = (+ h (// (* e (- rx d)) a)))
				 `(as mx-a = (- (* m rx) a)
				      as b-nx = (- b (* n rx))
				      as d-px = (- d (* p rx))
				      as .e = (// b-nx mx-a)
				      as .f = (// d-px mx-a)
				      as .h = (+ h (* e .f))
				      as .i = (+ n (* m .e))
				      as .j = (+ p (* m .f))
				      as .g = (+ f (* e .e))
				      as f-y-n = (+ (* .g v-top) .h)
				      as f-y-d = (+ (* .i v-top) .j)))
			   ,@(loop for (i init) in locals-per-line nconc `(as ,i = ,init))
			do
		    (when per-line-function (funcall per-line-function))
		    ,(catmull-second-pass-x-loop)
		    ,@(when note-progress
			`((tv:note-progress (+ x (:width :source)) 2w))
			)
		    (when (> (time:time-difference (time:fixnum-microsecond-time) last-time)
			     500000)
		      (allow-sheet-activity ,@(when source-span-used
						`(src src-span))
					    ,@(when dest-span-used
						`(dest dest-span)))
		      (setq last-time (time:fixnum-microsecond-time)))
		    )))
	     (catmull-first-pass-y-loop ()
	       `(let ((LMA FIRST-PASS-START-ARRAY)
		      (RMA FIRST-PASS-END-ARRAY))
		  (declare (sys:array-register lma rma))
		  (ignore src-span)
		  (loop
		       ,@(when note-progress
			   `(with 2h = (* 2 (:height :destination))))
		     for v from 0 below (:height :destination)
		     as didx first (:first-y :destination)
			     then (+ didx (:next-y :destination))
			,@(if (eq catmull-speed :fast)
			      `(as .b = (- (+ (* b v) d) intermediate-first-offset))
			      `(as f-x-n from d by b
				   as f-x-d from p by n))
			,@(loop for (i init) in locals-per-line
				nconc `(as ,i = ,init))
		     do
		    (when per-line-function (funcall per-line-function))
		    (read-scan-line self v sx sy)
		    ,(catmull-first-pass-x-loop)
		    ,@(when note-progress
			`((tv:note-progress v 2h))
			)
		    (when (> (time:time-difference (time:fixnum-microsecond-time) last-time)
			     500000)
		      (allow-sheet-activity ,@(when source-span-used
						`(src src-span))
					    ,@(when dest-span-used
						`(dest dest-span)))
		      (setq last-time (time:fixnum-microsecond-time))))
		  ))
	     (main-y-loop ()
	       `(loop ,@(when note-progress
			  `(for %line-number below (:height)))
		      ,@(if computed-source-lines
			    `(initially (when from-field
					  (ferror "From-Field nust be NIL with computed source lines"))
					as sidx = (funcall ,computed-source-lines)
					,@(loop for s in source-lines-per-group
						do (ignore s)
						nconc
						`(as s = (funcall ,computed-source-lines))))
			    `(with src-y-increment = (:next-y)
				   and last-y-index = (:last-y)
				   for sidx first (:first-y)
				   then ,(if source-lines-per-group	
					     `(+ sidx (* (1+ ,(length source-lines-per-group))
							 src-y-increment))
					     `(+ sidx src-y-increment))
				   ,@(loop as n = 'sidx then s
					   for s in source-lines-per-group
					   nconc `(as ,s = (+ ,n src-y-increment)))
				   ))
		      ,@(when (and computed-source-lines dests store-operator
				   (not computed-dest-lines))
			  `(with last-y-index = (:last-y :destination)))
		      and image-width = ,(if (and dests store-operator)
					     (if store-multiplier
						 `(* ,store-multiplier (:signed-width :destination))
						 `(:signed-width :destination))
					    (if fetch-multiplier
						 `(* ,fetch-multiplier (:signed-width))
						 `(:signed-width)))
		      ,@(when (and store-operator
				   dests)
			  (if computed-dest-lines
			      `(initially (unless (null to-field)
					   (ferror "to-field must be nil with computed-dest-lines"))
					 as didx = (funcall ,computed-dest-lines))
			      `(with dest-y-increment =  (:next-y :destination)
				     as didx first (:first-y :destination)
				     then (+ didx dest-y-increment))))

		      until (or (eql sidx ,(if computed-source-lines
					       :end
					       'last-y-index))
				,@(when (and computed-source-lines
					     dests store-operator
					     (not computed-dest-lines))
				 `((eql didx last-y-index))
				))
			,@(core-y-loop)
			,@(when note-progress
			    `((tv:note-progress %line-number (:height))))
		      finally ,@(when computed-dest-lines
2				  ;force out the last line
0				  `((funcall ,computed-dest-lines)))
			))
	     (bitblt-main-loop ()
	       `(if (or from-field to-field per-line-function)
		    (loop repeat ,height
			  for sy from (if from-field (+ ,sy from-field -1) ,sy)
			  by (if from-field 2 1)
			  as dy from (if to-field (+ ,dy to-field -1) ,dy)
			  by (if to-field 2 1)
			  do
		      (when per-line-function (funcall per-line-function))
		      ,@(loop for d in dars
			      as ss = sars then (or (cdr ss) sars)
			      as (s) = ss
			      collect
				`(,bitblt-function
				  ,alu
				  ,width 1
				  ,s ,sx sy
				  ,d ,dx dy)))
		    ,@(loop for d in dars
			    as ss = sars then (or (cdr ss) sars)
			    as (s) = ss
			   collect
			     `(,bitblt-function
			       ,alu
			       ,width ,height
			       ,s ,sx ,sy
			       ,d ,dx ,dy))))
	     (main-loop ()
	       (let ((val (selectq main-loop
			    (:bitblt
			     (bitblt-main-loop))
			    (:catmull
			     `(progn
				(unless (and (null from-field)(null to-field))
				  (ferror "FROM-FIELD and TO-FIELD must be NIL for catmull rescaling"))
				    ,(cond ((eq catmull-pass :first)
					    (catmull-first-pass-y-loop))
					   ((eq catmull-pass :second)
					    (catmull-second-pass-y-loop)))))
			    (:rescale
			     (rescale-y-loop))
			    ((:change-aspect-ratio :copy nil) (main-y-loop))
			    (t (ferror "~A is an Unknown main loop" main-loop))
			    )))
		 val)
	       ))

      (when computed-source-lines
	(push `(,src (first ,src)) all-locals)
	(push `(,computed-source-lines (second ,src)) all-locals)
	)
      (when computed-dest-lines
	(push `(,dest (first ,dest)) all-locals)
	(push `(,computed-dest-lines (second ,dest)) all-locals)
	)
      (when (and s&s-ars (neq rescale :select))
	(push `(src-ary-size (* ,height ,width)) all-locals))
      (when (and fetch-multiplier sx (> fetch-multiplier 1))
	(push `(,sx (* ,sx ,fetch-multiplier)) all-locals))
      (when (and store-multiplier dx (> store-multiplier 1))
	(push `(,dx (* ,dx ,store-multiplier)) all-locals))

      (let2*0 ((array-locals
	       `(,@(loop for i in (cdr sars)
			 as j in (cdr sources)
			 collect `(,i ,j))
		 ,@(loop for i in (cdr dars)
			 as j in (cdr dests)
			 collect `(,i ,j))
		 ,@(loop for i in s&s-ars collect `(,i ,i))
		 ,@(loop for i in other-arrays
			 collect (if (listp i) i (list i i))
			   )
		 ))
	     (declare-local-arrays
	       (when (or (cdr sources) (cdr dests) s&s-ars other-arrays)
		 `((declare (array-register-1d
			      ,@(append s&s-ars)
			      ,@(append (cdr sars) (cdr dars))
			      ,@(loop for i in other-arrays
				      collect (if (listp i) (first i) i))
			      )
			    ))))
	     (base
	       `(let* (,@all-locals
		       ,@(when (and s&s-ars (neq rescale :select))
			   `((inv-src-ary-size
			       ,(if (neq rescale :truncated)
				    `(sys:%divide-bignum-step 0 2 src-ary-size)
				    `(+ (sys:%divide-bignum-step 0 1 src-ary-size)
					(if (= src-ary-size
					       (logand src-ary-size (- src-ary-size)))
						;test for power of two
					    0 1)
					)				   
				    ))))
		       (last-time (time:fixnum-microsecond-time))
		       )
		  (ignore last-time)
		  ,@(when computed-source-lines `((ignore ,sx ,sy)))
		  ,@(when computed-dest-lines `((ignore ,dx ,dy)))
		  ,@(when pixels-per-group
		      `((ignore ,dest-height ,width)))
		  2;;prepare the source array loop
0		  (tv:with-prepared-sheet-or-raster
		    (,(if (cdr sources) (first sources) src)
		     :array ,(first sars)
		     :array-only t
		     ,@(when (and src fetch-operator)
			 (if (or bitblt computed-source-lines)
				      `(:declare-array-register t)
				      (setq source-span-used t)
				      `(:span src-span))))
		    
		    1;;prepare the destination array loop.  If there
0		    1;;are no destination arrays, use PROGN
0		    (,@(cond ((and dests store-operator)
			      `(tv:with-prepared-sheet-or-raster
				 (,(if (cdr dests) (first dests) dest)
				  :array ,(first dars)
				  :array-only t				  
				  ,@(if (or bitblt computed-dest-lines)
					`(:declare-array-register t)
					(setq dest-span-used t)
					`(:span dest-span)))))
			     (t `(,'progn)))

		     (let* (,@array-locals) ;separate locals and array locals to help
		       ;the frame splitter choose a good place
		       ,@declare-local-arrays

		     
		     ,@(when first `(,first))
		     
		     ,(main-loop)
		     
		     ,@(when last
			 `(,last))
		     ))))))

	(when jitter
	  (setq base `(with-random-variable (random-value)
			(let* ((jitter-threshold (// threshold 2))
			       (jitter-2 (// jitter-threshold 2)))
			  ,base))))
	(when s&s-ars
	  2;;if we are rescaling, generate and dispose of the temporary arrays
0	  (setq base
		`(tv:with-temp-sheet-rasters
		   (,@(loop for i in s&s-ars
			    collect `(,i ,dest-width :type 'art-fixnum
				      :initial-value 0)))
		   ,base)))
	(when note-progress
	  (setq base `(tv:noting-progress (,(if (eq note-progress t)
						"Image process"
						note-progress))
			,base)))
	(lexpr-funcall #'construct-form base
		       :fetch-multiplier fetch-multiplier
		       :store-multiplier store-multiplier
		       args))
    ))))))
    ))))))

(defflavor image-process-function (name specs (funobj) keyword-args arglist
					keyword-arg-keywords
					(key-args) (common-args)
					)
	   ()
  (:default-init-plist :keyword-args nil
		       :arglist '(width height src sx sy dest dx dy))
  :initable-instance-variables
  (:init-keywords :extra-keyword-args)
  :readable-instance-variables)

(defmethod (sys:print-self image-process-function) (stream ignore ignore)
  (printing-random-object(self stream :typep)
    (format stream "~A"
	    name
	    )))

(defmethod ((cl:setf image-process-function-specs) image-process-function) (new-body)
  (setq specs (function-definition self new-body)))

(defmethod (:init image-process-function :after) (plist)
  (setq keyword-args (append (get plist :extra-keyword-args) keyword-args))
  (setf (image-process-function-specs self) specs)
  (setq keyword-arg-keywords
	(loop for i in keyword-args
	      collect (intern (string (if (listp i) (car i) i)) 'keyword)))
  )

(defmethod (function-definition image-process-function) (body)

  (let* ((use-name name)
	 (defun-type (if (listp use-name)
			 (selectq (first use-name)
			   (flavor:method (setq use-name (cdr use-name)) 'defmethod)
			   (t (ferror "Can't handle ~A" name)))
			 'defun))
	 )
    `(,defun-type ,use-name (,@arglist &key ,@keyword-args)
      ,@(if common-args
	    `((compiler-let ((image-process-macro-common-args ',common-args))
		(ignore ,@(loop for i in keyword-args collect (if (listp i) (first i) i)))
		,@body))
	    body))))

(defmethod (compile-self image-process-function) ()
  (let ((spec (if (eq (car specs) 'defmethod)
		  (macroexpand-1 specs)
		  specs)))
    (tv:unprepare-sheet 
      (let ((val (compile (second spec) `(lambda ,@(cddr spec)))))
	(setq funobj (fsymeval (if (listp val) (second val) val)))
	))))

(defmethod (compiled-function image-process-function) ()
  (unless funobj
    (compile-self self))
  funobj)

(defmacro def-image-process
       (name image-process &rest body)

  (loop with compile-specified
	and ip = (if (symbolp image-process)
		     (symeval image-process)
		     image-process)
	with keyword-args = (loop for i in (image-process-keyword-args ip)
				 collect (if (listp i) i (list i nil)))
	and key-args
	and no-alpha
	as (key val . more) on body by #'cddr
	if (keywordp key)
	  nconc (progn (setq body more)
		       (selectq key
			 (:compile (setq compile-specified t))
			 (:key-args (setq key-args val))
			 (:keyword-args (setq keyword-args (append val keyword-args)))
			 )
		       `(,key ,val))
	    into keywords
	else do (loop-finish)
	finally
	  (unless compile-specified
	    (push :return keywords)
	    (push :compile keywords))
	  (loop with super-keys = (image-process-key-args ip)
		for (key val) on key-args by #'cddr
		as interned-val = (intern (string key) 'color)
		unless (or (memq key super-keys)
			   (memq key '(:fetch :store :map :intensity-operator
					      :combine :separate :save-last-pixel))
			   (loop for i in keyword-args
				 as iv = (if (listp i) (car i) i)
				 thereis (eq iv interned-val))
			   (and (eq key :default-alpha)
				(neq (get (locf key-args) :combine) :named-with-alpha)
				(neq (get (locf key-args) :map) :named-with-alpha)
				2;;
0				2;; this is a special hack for :default-alphas, which
0				2;; are combined with the COMBINE operators unless alpha
0				2;; is a constant.  When we combine the two operators,
0				2;; :default-alpha shouldn't be a keyword arg
0				(or no-alpha
				    (and (symbolp val) (setq no-alpha t))))
			   )
		  do (push key super-keys)
		     (push `(,interned-val ,val) keyword-args))
	  (return (cl:apply #'def-image-process-function
			    name image-process
			    (or body `((image-process-macro
					 ,@key-args)))
			    :keyword-args  (reverse keyword-args)
			    keywords))))

(defmethod (image-process-accepts-keyword image-process-function) (which)
  (memq which keyword-arg-keywords))

(defun image-process-accepts-other-args (image-process-function &rest args)
  (loop for (name val) on args by #'cddr
	when val
	  nconc (cond (image-process-function
		       (when (image-process-accepts-keyword image-process-function name)
			 `(,name ,val)))
		      (t `(,name ,val)))))

(defun def-image-process-function (name image-process body
				   &key (compile t)
				   (key-args)
				   (arglist)
				   (non-key-args)
				   (keyword-args)
				   (extra-keyword-args)
				   )

  (let* ((evaled-image-process (eval image-process))
	 (image-process-macro-key-args key-args)
	 (image-key-args (image-process-key-args evaled-image-process))
	 (image-non-key-args (image-process-non-key-args evaled-image-process))
	 (arglist (or arglist
		      (image-process-arglist evaled-image-process)))
	 (keywords1 (or keyword-args
		       (image-process-keyword-args evaled-image-process)))
	 (image-process-macro-common-args
	   `(:permitted-args ,key-args
	     ,@(when arglist `(:arglist ,arglist))
	     :ignored-args ,(image-process-ignored-args evaled-image-process)
	     ,@(image-process-common-args evaled-image-process)))
	 (keys (multiple-value-list (lexpr-funcall #'normalize-image-process-args
				      :key-args image-key-args
				      :non-key-args (append image-non-key-args non-key-args)
				      :permitted-args (append image-key-args key-args)
				      :ignored-args (image-process-ignored-args evaled-image-process)
				      (append key-args image-process-macro-common-args)
				      )))
	 (keywords (if (and (memq :write-mask image-key-args)
			    (let ((kw (sixth keys)))
			      (get (locf kw) :write-mask)))
		       `((write-mask -1) ,@keywords1)
		       keywords1))
	 (ip (make-instance 'image-process-function
			   :name name
			   :common-args image-process-macro-common-args
			   :key-args keys
			   :arglist arglist
			   :extra-keyword-args extra-keyword-args
			   :keyword-args keywords
			   :specs body)))
    (if (memq compile '(:defer :return))
	`(progn
	   ,@(when (eq compile :return) `(,(function-definition ip body)))
	   (remember-image-process
	     ,image-process ',key-args
	     (make-instance 'image-process-function
			    :name ',name
			    :common-args ',image-process-macro-common-args
			    :key-args ',keys
			    :arglist ',arglist
			    :keyword-args ',keywords
			    :extra-keyword-args ',extra-keyword-args
			    :specs ',body
			    ,@(when (eq compile :return)
				`(:funobj
				   (function ,(if (listp name) (second name) name))))))
	   )
	(when (eq compile t) (compile-self ip))
	(remember-image-process
	  evaled-image-process
	  key-args
	  ip)
	ip)))


(defflavor image-process ((name)
			  (create-on-demand t)
			  (method-of)
			  (key-args)
			  (non-key-args)
			  (common-args nil)
			  (ignored-args nil)
			  (arglist '(width height src sx sy dest dx dy))
			  (keyword-args)
			  (propriety-test)
			  (permitted-args)
			  (process-functions (make-equal-hash-table)))
	   ()
  (:init-keywords :main-loop :non-keyword-args)
  (:default-init-plist :main-loop :copy)
  :initable-instance-variables
  :readable-instance-variables
  :writable-instance-variables)

(defmethod (image-process-functions image-process) ()
  (loop for fun being the hash-elements of process-functions
	collect fun))

(defmethod (:init image-process :after) (plist)
  (let ((loop (get plist :main-loop))
	(non-args (get plist :non-keyword-args)))
    (when loop (setq common-args `(:main-loop ,loop ,@common-args)))
    (loop for i in *special-image-keywords*
	  unless (memq i key-args)
	    do (push i key-args))
    (loop for i in *special-image-keyword-args*
	  as ii = (intern (string i) 'color)
	  unless (or (memq ii key-args)
		     (memq i non-args))
	    do (push ii keyword-args))
    (loop for i in key-args
	  unless (memq i permitted-args)
	    do (push i permitted-args))))

(defmethod (sys:print-self image-process) (stream ignore ignore)	
  (printing-random-object (self stream :typep)
    (format stream "~a" name)))

(defmethod (normalize-spec image-process) (spec)
  (multiple-value-list
    (lexpr-funcall #'normalize-image-process-args
		   :permitted-args permitted-args
		   :key-args key-args :non-key-args non-key-args
		   :ignored-args ignored-args
		   :silent t
		   (append spec common-args)
		   )))

(defmethod (remember-image-process image-process)
	   (spec fn &optional (other-image-process self))
  (let ((new (if (listp fn)
		 (find-image-process other-image-process fn)
		 fn)))
    (if new
	(let* ((spec (normalize-spec self spec))
	       (old (gethash spec process-functions)))
	  (when (and old
		     (not (equal (image-process-function-name old)
				 (image-process-function-name new))))
	    (warn "Image process function ~A~% replacing ~A~% for spec ~S"
		  new old spec))
	  (loop for i in (image-process-function-keyword-arg-keywords new)
		unless (memq i permitted-args)
		  do (push i permitted-args))
	  (puthash
	    spec
	    new
	    process-functions))
	(warn "~S doesn't specify a defined function for ~A" fn other-image-process)
	))
  )

(defmethod (call-image-process image-process) (spec &rest args)
  (let ((ip (find-image-process self spec :error-p t)))
    (lexpr-funcall (compiled-function ip) args)))

(defmethod (create-and-call-image-process image-process) (spec &rest args)
  (let ((ip (find-image-process self spec :error-p t :create-p t)))
    (lexpr-funcall (compiled-function ip) args)))

(defmethod (find-image-process image-process)
	   (spec &key error-p create-p compile
		 (method-of method-of))
  (multiple-value-bind (fetch separate map combine store other)
      (lexpr-funcall #'normalize-image-process-args
		     :permitted-args permitted-args
		     :key-args key-args :non-key-args non-key-args
		     :ignored-args ignored-args
		     :silent t
		     (append spec common-args)
		     )
    (with-stack-list (ll fetch separate map combine store other)
      (let ((val (find-normalized-image-process
		   self ll
		   :error-p (if create-p nil error-p))))
	(Unless val
	  (when create-p
	    (let ((spec (create-image-processes self (list (list spec))
						:prefix name
						:compile compile
						:method-of method-of
						)))
	      (eval spec))
	    (setq val (find-normalized-image-process self ll :error-p error-p))
	    ))
	val))))

(defvar *recompile* nil)
(defmethod (find-normalized-image-process image-process) (spec &key error-p)
  (or (if *recompile*
	  (setq *recompile* nil)
	  (gethash spec process-functions))
      (when error-p
	(ferror "No image process for ~A matches ~S" self spec))
      ))


(defmethod (invoke-image-process image-process)
	   (width height src sx sy dest dx dy
		  &key spec &allow-other-keys other-args)
  (let ((ip (find-image-process self spec)))
    (if ip
	(lexpr-funcall (compiled-function ip)
		       width height src sx sy dest dx dy other-args)
	"not found")))



; this does an "image process" between two arrays.  Basicly it macrocodes BITBLT
; with a twist, such as shifting or copying between pixel sizes
; eventually, this should be recast as an image-process-macro operation


(defmacro %copy-image-rectangle
	  (w h src srcx srcy dest destx desty
	   &optional shift)
  (let* ((core (selectq shift
		 (nil '(setf (aref dest dx) (aref src sx)))
		 ((0 8 16 24) `(setf (aref dest dx)
				     (%logdpb (aref src sx) ,(byte 8. shift)
					      (aref dest dx))))
		 ((-8 -16 -24) `(setf (aref dest dx)
				      (ldb ,(byte 8. (abs shift)) (aref src sx))))
		 (t shift)))
	 (bb-spec (selectq shift
		    (nil (dpb 0 (byte 2 1) 0))
		    ((0 8 16 24) (dpb (// shift 8) (byte 2 1) 1))
		    ((-8 -16 -24) (dpb (// shift -8) (byte 2 1) 0))
		    (t nil)))
	 (hardway `(let ((src ,src)
			 (dest ,dest)
			 )
		     (declare (array-register-1d src dest))
		     (loop with srcspan = (multiple-value-bind (nil nil span)
					      (decode-raster-array src)
					    span)
			   and last-time = (time:fixnum-microsecond-time)
			   and destspan = (multiple-value-bind (nil nil span)
					      (decode-raster-array dest)
					    span)
			   repeat ,h
			   as sy from (* ,srcy srcspan) by srcspan
			   as dy from (* ,desty destspan) by destspan
			   do
		       (when (> (time:time-difference (time:fixnum-microsecond-time) last-time)
				500000)
			 (allow-sheet-activity src srcspan dest destspan)
			 (setq last-time (time:fixnum-microsecond-time)))
		       (loop repeat ,w
			     as sx from (+ sy ,srcx)
			     as dx from (+ dy ,destx)
			     do
			 ,core
			 )
		       )))
	 )

    (if bb-spec
	`(if color-microcode-p
	     (tv:bitblt-by-segments  (logior alu-shift ,bb-spec)
				 ,w ,h ,src ,srcx ,srcy ,dest ,destx ,desty
				 :function #'tv:bitblt-unpacked)
	     ,hardway)
	hardway)
    ))


(defun 1create-image-processes
0       (image-process image-processes
	&key
	(prefix :unspecified)
	(compile :return)
	(method-of :unspecified))
  `(progn 
     ,@(loop with evaled-image-process = (if (symbolp image-process)
					     (symeval image-process)
					     image-process)
	     initially (when (eq prefix :unspecified)
			 (setq prefix (image-process-name evaled-image-process)))
		       (when (eq method-of :unspecified)
			 (setq method-of (image-process-method-of evaled-image-process)))
	     for (spec . body ) in image-processes
	     as normal-spec = (normalize-spec evaled-image-process spec)
	     as ignored-args = (image-process-ignored-args evaled-image-process)
	     as (fetch-op separate-op map-op combine-op store-op extra-key-ops)
	       = normal-spec
	     as respec = (loop for (key val) on spec by #'cddr
			       unless (memq key ignored-args)
				 nconc `(,key ,val))
	     as extra-keys = (loop for (nil v) on extra-key-ops by #'cddr
				   collect v)
	     as name = (intern (format nil "~A~{-~A~}-~A~A~A>~A~A"
				       prefix
				       extra-keys
				       (if fetch-op (format nil "F=~A-" fetch-op) "")
				       (if map-op (format nil "M=~A-" map-op) "")
				       (if separate-op (format nil "S=~A-" separate-op) "")
				       (if combine-op (format nil "C=~A-" combine-op) "")
				       (or store-op "X"))
			       'color)
	     collect
	       `(def-image-process
		  ,(if method-of
		       `(flavor:method ,name ,method-of)
		       name)
		  ,image-process
		  :compile ,compile
		  :key-args ,respec
		  ,@body
		  )
	       )))

(defun image-process-specifications (image-process-name &optional compile-uncompiled)
  (let ((image-process (symeval image-process-name))
	(specs))
    (maphash
      #'(lambda (key dat)
	  (ignore key)
	  (when (let ((fun (image-process-function-funobj dat)))
		  (if compile-uncompiled
		    (cond ((eq compile-uncompiled :defer)
			   (null (si:get-source-file-name (si:function-name fun))))
			  (t t))
		    fun))
	    (destructuring-bind (fetch separate map combine store others)
		(image-process-function-key-args dat)
	      (let ((other-args
		      (nconc (loop for keyarg in
				       (image-process-function-keyword-args dat)
				   as key = (if (listp keyarg) (car keyarg) keyarg)
				   as val = (if (listp keyarg) (second keyarg) nil)
				   nconc `(,(intern (string key) :keyword)
					   ,val))
			     others)))
		(when (listp separate)
		  (let ((alpha (second separate)))
		    (setq separate (first separate))
		    (when (eq (scl:getf other-args :default-alpha :nil) :nil)
		      (setq other-args
			    `(:default-alpha
			       ,(if (eq alpha :default-alpha) 255. alpha)
			       ,@other-args)))))
		(push `(:fetch ,fetch
			:map ,map
			:separate ,(if (listp separate) (first separate) separate)
			:combine ,combine
			:store ,store
			,@other-args)
		      specs)))))
      (image-process-process-functions image-process))
    `(,(if (eq compile-uncompiled :defer)
	   'precompile-image-processes
	   'predefine-image-processes)
      ',image-process-name ',specs)))

(defun predefine-image-processes (image-process-name image-processes)
  (loop with image-process = (symeval image-process-name)
	for ip in image-processes
	do (find-image-process image-process ip :error-p t :create-p t :compile t)))

(defmacro precompile-image-processes (image-process-name image-processes)
  (let* ((iname (eval image-process-name))
	 (raw-specs (cdr (create-image-processes (symeval iname)
						 (loop for i in (eval image-processes) collect (list i))
						 :compile :return
						 ))))
    (loop for ip in raw-specs
	  do (setf (third ip) iname))
    `(progn ,@raw-specs)))

(defun all-image-process-specifications
       (&key image-processes compile-uncompiled)
  (declare (special *all-image-processes*))
  (unless image-processes (setq image-processes *all-image-processes*))
  (let ((specs (loop for ip in image-processes
		     collect (image-process-specifications ip compile-uncompiled))))
    `(progn ,@specs
	    )))

(defmethod (compile-all-image-processes image-process) ()
  (loop for ip being the hash-elements of process-functions
	collect (compiled-function ip)))

(defmethod (recompile-all-image-processes image-process) ()
  (loop for ip being the hash-elements of process-functions
	when (image-process-function-funobj ip)
	  collect (compile-self ip)))

(defun 1string-out-stream0 (&key continuation width height stream
			  (stream-dx 0)
			  (buffer-dx 0)
			  (buffer )
			  (array-type (if buffer (array-type buffer) 'art-8b))
			  (to-field)
			  (message :string-out))

  (let* ((first-y :start)
	 (height height)
	 (buffer buffer)
	 (emit-zeros (eql to-field 2))
	 (cont #'(lambda ()
		   (setq first-y
			 (cond ((eq first-y :start)
				stream-dx)
			       ((> height 0)
				(when to-field 
				  (if emit-zeros
				      (progn (funcall stream message
						      buffer
						      (+ buffer-dx width)
						      (+ buffer-dx width width))
					     (decf height))
				      (setq emit-zeros t)
				      ))
				(funcall stream message buffer buffer-dx (+ buffer-dx width))
				(decf height)
				stream-dx)
			       (t :end))))))

    (with-stack-list (dims 1 (+ width buffer-dx (if to-field width 0)))
      (with-stack-array (ar dims :type array-type :displaced-to buffer)
	(funcall continuation cont ar)
	(loop repeat height do
	  (funcall stream message
		   buffer
		   (+ buffer-dx width)
		   (+ buffer-dx width width)))
	))
    ))

(defun 1string-in-stream0 (&key continuation width height stream
			 (stream-dx 0)
			 (buffer-dx 0)
			 (buffer )
			 (array-type (if buffer (array-type buffer) 'art-8b))
			 (from-field)
			 (message :string-in))

  (let* ((height height)
	 (o-height height)
	 (buffer buffer)
	 (cont #'(lambda ()
		   (when (and from-field ( height o-height)(> height 0))
		     (decf height)
		     (funcall stream message nil
			      buffer buffer-dx (+ buffer-dx width)))
		   (cond ((> height 0)
			  (funcall stream message nil buffer buffer-dx (+ buffer-dx width))
			  (decf height)
			  stream-dx)
			 (t :end)))))
    (with-stack-list (dims 1 (+ width buffer-dx))
      (with-stack-array (ar dims :type array-type :displaced-to buffer)
	(funcall continuation cont ar)
	(loop repeat height do
	  (funcall stream message nil buffer buffer-dx (+ buffer-dx width)))
	))
    ))

2;;
;; Continuation function for IO that will be done a block at a time.
;; The buffer must be one continuous buffer, configured as a 2d array.
;; Sequential calls to GET-NEW-BLOCK return the height and absolute index
;; of the next part of the buffer to use.
;;
0(defun 1block-string-in-stream
0       (&key continuation 
	buffer
	height 
	(from-field)
	(get-new-block)
	(per-line-function)
	)
  (multiple-value-bind (nil nil block-span)
      (decode-raster-array (if (listp buffer)
			       (first buffer)
			       buffer))
    (let* ((height height)
	   (o-height height)
	   (block-height 0)
	   (block-index 0)
	   )
      (labels ((get-next-line ()
		 (declare (sys:downward-function))
		 (when per-line-function (funcall per-line-function))
		 (when (zerop block-height)
		   (when (> height 0)
		     (multiple-value (block-height block-index)
		       (funcall get-new-block))
		     (decf height block-height)
		     ))
		 (when (and from-field ( height o-height)(> height 0))
		   (decf block-height)
		   (incf block-index block-span)
		   (when (zerop block-height)
		     (when (> height 0)
		       (multiple-value (block-height block-index)
			 (funcall get-new-block))
		       (decf height block-height)
		       ))
		   )
		 (cond ((> block-height 0)
			(when (zerop block-height)
			  (multiple-value (block-height block-index)
			    (funcall get-new-block))
			  (decf height block-height)
			  )
			(decf block-height)
			(prog1 block-index (incf block-index block-span)))
		       (t :end))
		 ))
	(funcall continuation #'get-next-line buffer)
	(loop while (> height 0) do
2	  ;read the rest of our assigned blocks
0	  (when (zerop block-height)
	    (setq block-height (funcall get-new-block))
	    (decf height block-height))
	  (setq block-height 0))
	))))

(defun 1block-string-out-stream
0       (&key continuation width height 
	(buffer )
	(to-field)
	(zero-value 0)
	(get-new-block)
	(per-line-function)
	)
  (multiple-value-bind (nil nil block-span )
      (decode-raster-array (if (listp buffer)
			       (first buffer)
			       buffer))
    (let* ((height height)
	   (buffer buffer)
	   (emit-zeros (eql to-field 2))
	   (block-height 0)
	   (block-index 0))
      (labels ((write-next-line ()
		 (when per-line-function (funcall per-line-function))
		 (when (zerop block-height)
		   (when (> height 0)
		     (multiple-value (block-height block-index)
		       (funcall get-new-block))
		     (decf height block-height)
		     ))
		 (when (and to-field (> block-height 0))
		   (if emit-zeros
		       (let ((a buffer)
			     (idx block-index))
			 (declare (sys:array-register-1d a))
			 (loop repeat width do (setf (aref a idx) zero-value) (incf idx))
			 (incf block-index block-span)
			 (decf block-height)
			 (when (zerop block-height)
			   (when (> height 0)
			     (multiple-value (block-height block-index)
			       (funcall get-new-block))
			     (decf height block-height)
			     )))
		       (setq emit-zeros t)
		       ))
		 (cond ((> block-height 0)
			(decf block-height)
			(prog1 block-index (incf block-index block-span)))
		       (t :end))))
	(funcall continuation #'write-next-line buffer)
	(loop while (> height 0) do
	  (when (zerop block-height)
	    (multiple-value (block-height block-index)
	      (funcall get-new-block))
	    (decf height block-height))
	  (setq block-height 0))
      ))))
