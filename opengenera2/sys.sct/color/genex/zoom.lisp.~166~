;;; -*- Mode: LISP; Package: COLOR; Base: 10.; Lowercase: Yes -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>


;;
;; Methods shared by screens and ordinary windows for mouse pan/zoom activity
;;

(defflavor pan-zoom-methods-mixin ((keep-mouse-visible-p nil)) ()
  :settable-instance-variables
  :initable-instance-variables)


;;; Macros for testing the geometric relationships of one "rectangular extents
;;; region" to another, as specified by inculsive left-, top-, right- and
;;; bottom-most pixel coordinates.

;;; Tests for overlap of region #1 and region #2
(defmacro extents-overlap-p (l1 t1 r1 b1  l2 t2 r2 b2)
  `(not (or (< ,r1 ,l2)
	    (< ,r2 ,l1)
	    (< ,b1 ,t2)
	    (< ,b2 ,t1))))

;;; Tests for region #1 completely inside the region #2
(defmacro extents-inside-p (l1 t1 r1 b1  l2 t2 r2 b2)
  `(and ( ,l1 ,l2)
	( ,t1 ,t2)
	( ,r1 ,r2)
	( ,b1 ,b2)))

;;;  
;;; Tests for height and width of region #1 being  region #2
(defmacro extents-smaller-p (l1 t1 r1 b1  l2 t2 r2 b2)
  `(and ( (- ,r1 ,l1) (- ,r2 ,l2))
	( (- ,b1 ,t1) (- ,b2 ,t2))))


(defmethod (:valid-zoom-range pan-zoom-methods-mixin) ()
  (values 0 255))

(defmethod (:keep-mouse-visible pan-zoom-methods-mixin)
	   (&optional do-it-anyway)
  
  (let ((scr (send self ':screen))
	(bl tv:mouse-blinker)
	(m-sheet tv:mouse-sheet))
    
    (cond ((and (not do-it-anyway) (not keep-mouse-visible-p)))
	  ((neq self scr)
	   (send scr :keep-mouse-visible))
	  ((or (not (instancep m-sheet))
	       (neq self (send m-sheet :screen))))
	  ((and bl (send bl :visibility))      ;; maybe pan the mouse to keep it on the screen
	   (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
	       (SEND SELF :PAN-ZOOM-VISIBLE-EDGES)
	     (MULTIPLE-VALUE-BIND (X Y)
		 (SEND BL :READ-CURSORPOS)
	       
	       (MULTIPLE-VALUE-BIND (WDX WDY)
		   (TV:SHEET-CALCULATE-OFFSETS (SEND BL :SHEET) SCR)
		 (SETQ X (+ X WDX)
		       Y (+ Y WDY)))
	       
	       (MULTIPLE-VALUE-BIND (DX DY)
		   (SEND BL :SIZE)
		 (LET ((last-rectangle
			 (or (send self :get :last-keep-mouse-visible-rectangle)
			     (send self :putprop 
				   (list x y (+ x dx) (+ y dy))
				   :last-keep-mouse-visible-rectangle))))
		   
		   (LETF ((KEEP-MOUSE-VISIBLE-P NIL))
		   
		     (if  (or ( (- right left) dx)
			      ( (- bottom top) dy))
			  
			  ;; it doesn't fit
			  (cond ((and (= x (first last-rectangle))
				      (= y (second last-rectangle)))
				 (unless (and (= (+ x dx) (third last-rectangle))
					      (= (+ y dy) (fourth last-rectangle)))
				   (send self :pan-from-rectangle
					 (+ x dx (- left right) 1)
					 (+ y dy (- top bottom) 1)
					 (+ x dx)
					 (+ y dy))))
				(t (send self :pan-from-rectangle
					 x y
					 (+ x (- right left -1)) (+ y (- bottom top -1)))))
			  
			  (send self ':pan-from-rectangle
				x y
				(+ x dx) (+ y dy))))
		   
		   (setf (car last-rectangle) x)
		   (pop last-rectangle)
		   (setf (car last-rectangle) y)
		   (pop last-rectangle)
		   (setf (car last-rectangle) (+ x dx))
		   (pop last-rectangle)
		   (setf (car last-rectangle) (+ y dy))
		   )))))
	  )
    ))

(defmethod (:pan-zoom-visible-edges pan-zoom-methods-mixin)
	   (&optional (zoomed-window (send self :screen)) &aux xs ys)
  "return the edges of the visible area of the zoomed window"

  (or (multiple-value (xs ys) (send zoomed-window :send-if-handles :visible-size))
      (multiple-value (xs ys) (send zoomed-window :size)))

    (multiple-value-bind (xp yp xz yz)
	(send self :pan-and-zoom t)
      (if (null xp)
	  (values 0 0 xs ys)
	  (values xp yp
		  (+ xp (// xs (1+ xz)))
		  (+ yp (// ys (1+ yz)))))))


(defmethod (:make-window-visible pan-zoom-methods-mixin ) (window &key always-zoom)
  (multiple-value-bind (left top)
      (tv:sheet-calculate-offsets window self nil)
    (when (and left top)
      (let ((right (+ left (send window :width)))
	    (bottom (+ top (send window :height))))
	(if always-zoom
	    (send self :pan-and-zoom-from-rectangle left top right bottom t self)
	    (send self :pan-and-zoom-from-rectangle-maybe left top right bottom self))))))

(defmethod (:pan-and-zoom-from-rectangle-maybe pan-zoom-methods-mixin)
	   (wl wt wr wb &optional (zoomed-window (send self ':screen)))
  "pan and zoom if necessary to make the specified rectangle visible"
  (multiple-value-bind (sl st sr sb)
      (send self :pan-zoom-visible-edges zoomed-window)
    (cond
      ((extents-inside-p  wl wt wr wb  sl st sr sb))
      ((extents-smaller-p wl wt wr wb  sl st sr sb)
       (send self :pan-from-rectangle wl wt wr wb))
      (t (send self :pan-and-zoom-from-rectangle wl wt wr wb)))))


(defmethod (:pan-from-rectangle pan-zoom-methods-mixin)
	   (left top right bottom &optional (zoomed-window (send self ':screen))
		 &aux sx sy (orig-left left) (orig-top top))
  "pan to center the specified rectangle"
  (when (and left top right bottom)

    (multiple-value (sx sy) (send zoomed-window :size))

    (multiple-value-bind (sl st sr sb)
	(send self :pan-zoom-visible-edges zoomed-window)

      ;; express the dest rectangle as a positive offset from the visible corner

      (when (< left sl)
	(incf left sx)
	(incf right sx))

      (when (< top st)
	(incf top sy)
	(incf bottom sy))

      (let ((newx (cond ((and (or (> left sr) (> right sr))
			      (when (<= orig-left sl)
				(mod orig-left sx)
				)))
			((> right sr)
			 (mod (+ sl (- right sr)) sx))
			(t sl)))
	    (newy (cond ((and (or (> top sb) (> bottom sb))
			      (when (<= orig-top st)
				(mod orig-top sy)
				)))
			((> bottom sb)
			 (+ st (- bottom sb)))
			(t st)))
	    oldx oldy)

	(multiple-value (oldx oldy) (send self :pan t))
	(when (or (not (= newx oldx)) (not (= newy oldy)))
	  (multiple-value-bind (zx zy) (send self :zoom t)
	    (send self :set-pan-and-zoom newx newy zx zy)
	  ))))))

(defmethod (:warp-mouse-to-be-visible pan-zoom-methods-mixin) ()
  (let ((bl tv:mouse-blinker))
    (when (and bl
	       (eq self tv:mouse-sheet)
	       (send bl :visibility))
      (multiple-value-bind (x y)
	  (send bl :read-cursorpos)
	(multiple-value-bind (left top right bottom)
	    (send self ':pan-zoom-visible-edges)
	  
	  (multiple-value-bind (sx sy)
	      (send self :size)
	    (when (< x left) (incf x sx))
	    (when (< y top) (incf y sy)))
	  
	  (when (or (< x left) (> x right)
		    (< y top) (> y bottom))
	    (tv:mouse-warp
	      (// (+ left right) 2)
	      (// (+ top bottom) 2))))))))

(defmethod (:set-pan pan-zoom-methods-mixin :after) (&rest ignore)
  (when keep-mouse-visible-p
    (send self ':warp-mouse-to-be-visible)))
(defmethod (:set-zoom pan-zoom-methods-mixin :after) (&rest ignore)
  (when keep-mouse-visible-p
    (send self ':warp-mouse-to-be-visible)))
(defmethod (:set-pan-and-zoom pan-zoom-methods-mixin :after) (&rest ignore)
  (when keep-mouse-visible-p
    (send self ':warp-mouse-to-be-visible)))

(defmethod (:pan-zoom-from-mouse-rectangle pan-zoom-methods-mixin) 
	   (&optional (zoomed-window (send self ':screen)) &aux (old-sheet tv:mouse-sheet) )
  "use the mouse to specify a rectangle, and pan&zoom to center it"
  (when (eq self zoomed-window)
    (send self ':set-pan-and-zoom 0 0 0 0))
  (unwind-protect
    (let* ((scr (send zoomed-window :screen))
	   (specify-window (if (and (send scr :get :video)
				    (send scr :video-on))
			       zoomed-window
			       self)))
      (tv:mouse-set-sheet specify-window)
      (multiple-value-bind (left top right bottom)
	  (tv:mouse-specify-rectangle nil nil nil nil specify-window 0 0 t)
	(when (and left top right bottom)
	  (when (neq zoomed-window specify-window)
	    ;;not specified on the right real window, so rescale the coordinates
	    (multiple-value-bind (zoomed-width zoomed-height)
		(send zoomed-window :size)
	      (multiple-value-bind (my-width my-height)
		  (send self :size)
		(let* ((x-ratio (// zoomed-width (float my-width)))
		       (y-ratio (// zoomed-height (float my-height))))
		  (setq left (floor (* left x-ratio))
			top (floor (* top y-ratio))
			right (floor (- zoomed-width (* x-ratio (- my-width right))))
			bottom (floor (- zoomed-height (* y-ratio (- my-height bottom)))))))))
	  (send self ':pan-and-zoom-from-rectangle left top right bottom t zoomed-window))
	))
    (tv:mouse-set-sheet old-sheet))
  )

(defmethod (:pan-and-zoom-from-rectangle pan-zoom-methods-mixin)
	   (left top right bottom
		 &optional (make-zoom-square t) (zoomed-window (send self ':screen))
		 &aux w h )
  "pan and zoom to center the specified rectangle"
  (when (and left top right bottom)
    (or (multiple-value (w h) (send self ':send-if-handles ':visible-size))
	(multiple-value (w h) (send self ':inside-size)))

    (let ((x-zoom (max 0 (fix (1- (// w (- right left))))))
	  (y-zoom (max 0 (fix (1- (// h (- bottom top))))))
	  x-d y-d)
      (when make-zoom-square
	(setq x-zoom (setq y-zoom (min x-zoom y-zoom))))
      (setq x-d (// (- w (* (1+ x-zoom) (- right left))) (* (1+ x-zoom) 2))
	    y-d (// (- h (* (1+ y-zoom) (- bottom top))) (* (1+ y-zoom) 2)))
      (multiple-value (w h) (send zoomed-window ':size))
      (send self ':set-pan-and-zoom
	    (mod (- left x-d) w)
	    (mod (- top y-d) h)
	    x-zoom y-zoom))))

(defmethod (:key-set-pan-zoom pan-zoom-methods-mixin)
	   (&optional (zoomed-window (send self ':screen)) &rest args)

  "interactive loop to pan&zoom using the shift keys"
  (lexpr-send self :mouse-pan-zoom zoomed-window
	      :who-line
	      "Left Shift Exits      Left H-S-M-C keys control pan     Right H-S-M-C Shift and Symbol Keys control Zoom"
	      :interpreter-loop :key-set-pan-zoom
	      args)
  )

(defvar *invisible-mouse-at-zoom* 8)
(defmethod (:mouse-pan-zoom pan-zoom-methods-mixin)
	   (&optional
	     (zoomed-window (send self :screen))
	     &key
	     (zoom-as-self (eq self zoomed-window))
	     (gunsight nil)
	     (mouse-sheet)
	     (who-line " L: Zoom In    M: Exit    R: Zoom Out ")
	     (invisible-mouse-at-zoom *invisible-mouse-at-zoom*)
	     (interpreter-loop :mouse-pan-zoom)
	     )

  "interactive loop to use the mouse to pan&zoom"

  (unless zoomed-window
    (setq zoomed-window (send self :screen)))

  (unless zoom-as-self
    (setq zoom-as-self (eq self zoomed-window)))

  (tv:with-prepared-sheet-or-raster
    (zoomed-window
      :screen zoomed-scr
      :window zoomed-sheet
      :width zw-width
      :height zw-height)

    (cond (zoom-as-self (setq gunsight nil))
	  ((and (null gunsight)
		(or (null zoomed-scr)
		    (null zoomed-sheet)
		    (zerop (tv:sheet-all-exposed zoomed-sheet))
		    (null (send zoomed-scr :get :video))
		    (null (send zoomed-scr :video-on))))
	   (setq gunsight t)))
  
    (let* ((old-sheet tv:mouse-sheet)
	   (old-x tv:mouse-x)
	   (old-y tv:mouse-y)
	   (tot-dx 0)
	   (tot-dy 0)
	   wx wy
	   self-width self-height
	   self-vis-width self-vis-height
	   center-x center-y
	   blinker-x-size blinker-y-size
	   px py zx zy
	   blx-raw-scale bly-raw-scale
	   (old-priority (send tv:current-process :priority))
	   )
      (labels ((warp-mouse-and-fix-blinkers (px py zx zy &optional force-update)
		 (setq px (round px)
		       py (round py)
		       zx (round zx)
		       zy (round zy))
		 (multiple-value-bind (hpx hpy hzx hzy)
		     (send self :pan-and-zoom t)
		   (when (or force-update ( px hpx) ( py hpy) ( zx hzx) ( zy hzy))
		     (send self :set-pan-and-zoom px py zx zy)
		     (let ((blx-scale (* blx-raw-scale (// 1.0 (1+ zx))))
			   (bly-scale (* bly-raw-scale (// 1.0 (1+ zy)))))
		     
		       (if gunsight
			   (tv:mouse-warp (mod (fix (* blx-raw-scale center-x)) self-width)
					  (mod (fix (* bly-raw-scale center-y)) self-height))
			   (tv:mouse-warp (mod (fix center-x) zw-width)
					  (mod (fix center-y) zw-height)))
		     
		       (cond ((not zoom-as-self)
			      (let* ((blx-siz (max 10 (+ 6 (fix (* blx-scale self-width)))))
				     (bly-siz (max 10 (+ 6 (fix (* bly-scale self-height))))))
				(send tv:mouse-blinker :set-offsets (// blx-siz 2) (// bly-siz 2))
				(send tv:mouse-blinker :set-size blx-siz bly-siz)
				)
			      (unless (eq gunsight :invisible)
				(tv:blinker-set-visibility tv:mouse-blinker :on))
			      (tv:mouse-set-blinker-cursorpos)
			      )
			     ((and (or (< zx invisible-mouse-at-zoom)
				       (< zy invisible-mouse-at-zoom))
				   (> self-vis-width (* blinker-x-size (1+ zx) 3))
				   (> self-vis-height (* blinker-y-size (1+ zx) 3)))
			      (tv:blinker-set-visibility tv:mouse-blinker :on)
			      )
			     ((send tv:mouse-blinker ':visibility)
			      (send tv:mouse-blinker  ':set-visibility nil))))
		     ))))
	(multiple-value (wx wy)
	  (send self ':wrap))

	(multiple-value (self-width self-height)
	  (send self ':size))
	(multiple-value (self-vis-width self-vis-height)
	  (send self :send-if-handles :visible-size))
	(unless self-vis-width 
	  (setq self-vis-width self-width
		self-vis-height self-height))
      
	(multiple-value (px py zx zy)
	  (send self ':pan-and-zoom t))
      
	(setq blx-raw-scale (if gunsight (// self-width (float zw-width)) 1))
	(setq bly-raw-scale (if gunsight (// self-height (float zw-height)) 1))
      
	;; compute the center point visible
	(setq center-x (mod (+ px (// self-vis-width (* 2 (1+ zx)))) zw-width)
	      center-y (mod (+ py (// self-vis-height (* 2 (1+ zy)))) zw-height))
      
	(loop until (zerop tv:mouse-last-buttons) do (tv:mouse-input))
      
      
	(unwind-protect 
	    (tv:with-mouse-usurped
	    
	      (send self ':set-wrap t t)
	    
	      (cond (mouse-sheet (tv:mouse-set-sheet mouse-sheet))
		    (gunsight (tv:mouse-set-sheet self))
		    (zoomed-sheet (tv:mouse-set-sheet zoomed-window)))

	      (setq tv:who-line-mouse-grabbed-documentation who-line)
	    
	      (send tv:current-process :set-priority (send tv:mouse-process :priority))
	    
	      (if zoom-as-self
		
		  (progn
		    (send zoomed-window :mouse-standard-blinker)
		    (multiple-value (blinker-x-size blinker-y-size)
		      (send tv:mouse-blinker :size)))
		
		  (tv:mouse-set-blinker-definition
		    :box-blinker
		    0 0 :on 
		    :set-size
		    (max 10 (// self-width (1+ zx)))
		    (max 10 (// self-height (1+ zy)))
		    ))
	    
	      (process-sleep 1)  ;; this somehow keeps the mouse blinker in the right state.
	    
	      (warp-mouse-and-fix-blinkers px py zx zy t)
	    
	      (selectq interpreter-loop
		(:mouse-pan-zoom
		 (loop as last-zoom = 0
		       as zoom-wait = (cond ((> zx 30.) 1)
					    (t (fixr (* 30. (// (+ 1.0 (min zx last-zoom))
								(+ 1.0 (max zx last-zoom)))))))
		       for input-wait first nil then (or (zerop tv:mouse-last-buttons) (= zx 255.))
		       do
		   (warp-mouse-and-fix-blinkers px py zx zy)
		   (multiple-value-bind (dx dy) (tv:mouse-input input-wait)
		     (setq last-zoom zx)
		     (selectq tv:mouse-last-buttons
		       (1 (setq zx (min 255. self-vis-height self-vis-width (incf zx))
				tot-dx 0
				tot-dy 0))
		       (2 (loop-finish))
		       (4 (setq zx (max 0 (decf zx))
				tot-dx 0
				tot-dy 0)))
		     (setq zy zx)

		     (incf tot-dx dx)
		     (incf tot-dy dy)
		     (let ((scale (max 1 (// (1+ (min zx zy)) 2))))
		       (setq dx (// tot-dx scale)
			     dy (// tot-dy scale)))
		     (when (or ( dx 0)( dy 0)( zx last-zoom))
		       (setq tot-dx 0
			     tot-dy 0)
		       (when (not zoom-as-self)
			 (setq dx (- dx)
			       dy (- dy)))
		       (setq center-x (mod (- center-x dx) zw-width)
			     center-y (mod (- center-y dy) zw-height))
		   
		       ;; recompute the pan 
		       (setq px (mod (- (fix center-x)
					(// self-vis-width (* 2 (1+ (fix zx)))))
				     zw-width)
			     py (mod (- (fix center-y)
					(// self-vis-height (* 2 (1+ (fix zx)))))
				     zw-height)))
		     )
		   (unless (progn (tv:mouse-input nil) (zerop tv:mouse-last-buttons))
		     (process-sleep zoom-wait "zoom")))
		 )
		(:key-set-pan-zoom
		 (loop with pan-speed-limit = (// (min zw-width zw-height) (* 20.0 (max (1+ zx) (1+ zy))))
		       and zoom-speed-limit = (1+ (// (max (1+ zx) (1+ zy) ) 10.0))
		       and pan-speed = 0 and zoom-speed = 0
		       and some-pan and some-zoom
		       and mp = (if zoom-as-self 1 -1)
		       until (tv:key-state ':left-shift)
		       do
		 
		   (when (or some-pan some-zoom )
		     (warp-mouse-and-fix-blinkers px py zx zy)
		     (when some-pan
		       (unless (tv:key-state some-pan)
			 (setq some-pan nil)))
		     (when some-zoom
		       (unless (tv:key-state some-zoom)
			 (setq some-zoom nil))))
		 
		   (cond ((and some-pan (tv:key-state some-pan))
			  (setq pan-speed (min pan-speed-limit
					       (* 1.05 pan-speed))))
			 (t (setq pan-speed (// pan-speed-limit 20))
			    ))
		 
		   ;; adjust zoom speed
		   (cond ((and some-zoom (tv:key-state some-zoom))
			  (setq zoom-speed (min zoom-speed-limit (* 1.05  zoom-speed))))
			 (t (setq zoom-speed (// zoom-speed-limit 20))))
		 
		   (setq some-zoom nil some-pan nil)
		 
		   (let ((zoom-speed (* mp (if (zerop zoom-speed) 1 zoom-speed)))
			 (pan-speed (* mp (if (zerop pan-speed) 1 pan-speed))))
		   
		     (when (tv:key-state ':right-hyper)
		       (setq some-zoom ':right-hyper)
		       (setq zx (+ zx zoom-speed)))
		   
		     (when (tv:key-state ':right-control)
		       (setq some-zoom ':right-control)
		       (setq zx (- zx zoom-speed)))
		   
		     (when (tv:key-state ':right-super)
		       (setq some-zoom ':right-super)
		       (setq zy (+ zy zoom-speed)))
		   
		     (when (tv:key-state ':right-meta)
		       (setq some-zoom ':right-meta)
		       (setq zy (- zy zoom-speed)))
		   
		     (when (tv:key-state ':right-symbol)
		       (setq some-zoom ':right-symbol)
		       (setq zy (+ zy zoom-speed))
		       (setq zx (+ zx zoom-speed)))
		   
		     (when (tv:key-state ':right-shift)
		       (setq some-zoom ':right-shift)
		       (setq zx (- zx zoom-speed))
		       (setq zy (- zy zoom-speed)))
		   
		     (when (tv:key-state ':left-hyper)
		       (setq some-pan ':left-hyper)
		       (setq center-x (mod (+ center-x pan-speed) zw-width)))
		   
		     (when (tv:key-state ':left-control)
		       (setq some-pan ':left-control)
		       (setq center-x (mod (- center-x pan-speed) zw-width)))
		   
		     (when (tv:key-state ':left-meta)
		       (setq some-pan ':left-meta)
		       (setq center-y (mod (+ center-y pan-speed) zw-height)))
		   
		     (when (tv:key-state ':left-super)
		       (setq some-pan ':left-super)
		       (setq center-y (mod (- center-y pan-speed) zw-height))))
		 
		   ;; range limit zoom
		   (setq zx (min 255. (max 0 zx))
			 zy (min 255. (max 0 zy)))
		 
		   ;; recompute the pan 
		   (setq px (mod (- (fix center-x)
				    (// self-vis-width (* 2 (1+ (round zx)))))
				 zw-width)
			 py (mod (- (fix center-y)
				    (// self-vis-height (* 2 (1+ (round zy)))))
				 zw-height))
		 
		   (process-sleep 1)
		   (process-wait "key down"
		     #'(lambda () (or (tv:key-state :SHIFT)
				      (tv:key-state :HYPER)
				      (tv:key-state :SUPER)
				      (tv:key-state :META)
				      (tv:key-state :CONTROL)
				      (tv:key-state :SYMBOL))))
		   )
		 )
		))
						;undo all the nasties we may have done
	  (send self ':set-wrap wx wy)
	  (tv:mouse-set-sheet old-sheet)
	  (tv:mouse-standard-blinker old-sheet)
	  (cond ((neq old-sheet self)
		 (tv:mouse-warp old-x old-y)))
	  (send tv:current-process :set-priority old-priority)
	  )))))

;;
;; Mixin for an ordinary window, to give it pan/zoom capability
;; 

(defconst *viewport-gunsight-gray* tv:25%-gray
  "The gray-shade used in showing the field of view when mouse-panning.")

(defflavor zoom-window-mixin
	((zoomed-window)
	 (x-zoom 0)
	 (y-zoom 0)
	 (x-pan 0)
	 (y-pan 0)
	 (displayed-x-pan nil)
	 (displayed-y-pan nil) (displayed-x-zoom nil)
	 (displayed-y-zoom) 

	 (zoom-process-function 'update-zoom-window)
	 (background-zoom t)
	 (zoom-process)

	 (normal-name)
	 (zoom-printing-base 10.)
	 (gunsight-gray *viewport-gunsight-gray*)
	 )
	(pan-zoom-methods-mixin si:property-list-mixin)
  (:required-flavors tv:sheet)
  :initable-instance-variables
  (:gettable-instance-variables zoomed-window zoom-process background-zoom)
  (:settable-instance-variables zoom-process-function zoom-printing-base
				background-zoom)
  )

(defmethod (:valid-zoom-range zoom-window-mixin) ()
  (values -15 255))

(defmethod (:set-zoomed-window zoom-window-mixin) (to)
  (setq zoomed-window to
	displayed-x-pan nil))

(defmethod (need-redisplay-p zoom-window-mixin) ()
  (if (eq zoom-process tv:current-process)
      (when zoomed-window
	(let ((xz x-zoom)
	      (yz y-zoom)
	      (xp x-pan)
	      (yp y-pan))
	  xz yz xp yp
	  (not (and 
		 (eql xz displayed-x-zoom)
		 (eql yz displayed-y-zoom)
		 (eql xp displayed-x-pan)
		 (eql yp displayed-y-pan)))))
      t))

(defmethod (:control zoom-window-mixin) ()
  nil)

(defmethod (update-zoom-window zoom-window-mixin) ()
  (if background-zoom
      (loop while (eq zoom-process tv:current-process)
	    do
	(catch-error
	  (progn
	    (send self ':redisplay)
	    (process-wait "wait for pan//zoom" #'need-redisplay-p self))))
      (send self :redisplay)
      ))

(defmethod (:init zoom-window-mixin :after) (ignore)
  (unless zoomed-window
    (setq zoomed-window (send self ':screen)))
  (setq normal-name (send self :label))
  )

(defmethod (start-zoom-process zoom-window-mixin) (run-reason)
  (if background-zoom
      (without-interrupts
	(let ((zip (or zoom-process
		       (setq displayed-x-zoom nil
			     displayed-y-zoom nil
			     displayed-x-pan nil
			     displayed-y-pan nil
			     zoom-process
			     (tv:process-run-function
			       `(:name ,(format nil "Zoom for ~A" (send self ':name))
				 :restart-after-boot t
				 :restart-after-reset nil)
			       zoom-process-function
			       self)))))
	  (when run-reason
	    (send zip :run-reason run-reason)
	    (send zip :revoke-run-reason :enable))
	  ))
      (send tv:current-process :run-reason run-reason)
      (when (and (eq run-reason :one-shot)
		 (not (member :mouse-pan-zoom (send tv:current-process :run-reasons))))
	(setq displayed-x-zoom nil
	      displayed-y-zoom nil
	      displayed-x-pan nil
	      displayed-y-pan nil))
      (stop-zoom-process self t)
      (funcall zoom-process-function self)
      ))

(defmethod (stop-zoom-process zoom-window-mixin) (revoke-reason)
  (without-interrupts
    (let ((zip zoom-process))
      (when zip
	  (when (or (eq revoke-reason t)
		    (progn
		      (send zip :revoke-run-reason revoke-reason)
		      (null (send zip :run-reasons))))
	    (send zip :run-reason :exit)
	    (setq zoom-process nil)
	    ))))
  (unless (or background-zoom (eq revoke-reason t))
    (send tv:current-process :revoke-run-reason revoke-reason))
  )

(defmethod (:clear-window zoom-window-mixin :before) (&optional ignore)
  (stop-zoom-process self t)
  (send self ':set-label normal-name))

;;
;; Methods to emulate a pan-zoom screen
;;
(defmethod (:pan-and-zoom-p zoom-window-mixin) ()
  t)

(defmethod (:change-of-size-or-margins zoom-window-mixin :after) (&rest ignore)
  (when displayed-x-zoom
    (incf displayed-x-zoom)))

(defmethod (:refresh zoom-window-mixin :after) (&optional how)
  (when (and zoom-process
	     (or (not tv:restored-bits-p)
		 (eq how t)
		 (eq how :complete-redisplay)))
    (send self :redisplay)))

(defmethod (:zoom zoom-window-mixin) (&optional ignore)
  (values x-zoom y-zoom))

(defmethod (:set-zoom zoom-window-mixin) (x y &optional ignore)
  (let ((oldx x-zoom)
	(oldy y-zoom))
    (setq x-zoom x
	  y-zoom y)
    (start-zoom-process self :one-shot)
    (values oldx oldy)))

(defmethod (:pan zoom-window-mixin) (&optional ignore)
  (values x-pan y-pan))

(defmethod (:set-pan zoom-window-mixin) (x y &optional ignore)
  (let ((oldx x-pan)
	(oldy y-pan))
    (setq x-pan x
	  y-pan y)
    (start-zoom-process self :one-shot)
    (values oldx oldy)))


(defmethod (:pan-and-zoom zoom-window-mixin) (&optional ignore)
  (values x-pan y-pan x-zoom y-zoom))

(defmethod (:set-pan-and-zoom zoom-window-mixin) (px py zx zy &optional ignore)
  (let ((oldpx x-pan)
	(oldpy y-pan)
	(oldzx x-zoom)
	(oldzy y-zoom))
    (setq x-pan px
	  y-pan py
	  x-zoom zx
	  y-zoom zy)
    (start-zoom-process self :one-shot)
    (values oldpx oldpy oldzx oldzy)))

(defmethod (:vertical-sync-p zoom-window-mixin) ()
  t)

(defmethod (:wrap zoom-window-mixin) (&optional ignore)
  (values nil nil))

(defmethod (:set-wrap zoom-window-mixin) (x y &optional ignore)
  x y
  (send self ':wrap ))

(defun remote-screen-array-p (a)
  (multiple-value-bind (nil nil nil bound) (sys:setup-force-1d-array a)
    ( bound 0)))

(defmethod (:redisplay zoom-window-mixin) ()


  (when (null (send self :label))
    (send self :set-label "zoom"))

  (let* (;; save stable values of these
	 (xzoom x-zoom)
	 (yzoom y-zoom)
	 (xpan x-pan)
	 (ypan y-pan)
	 (real-xpan xpan)
	 (real-ypan ypan)
	 (real-xzoom xzoom)
	 (real-yzoom yzoom)
	 (x-inc (- (min -1 (1- xzoom))))
	 (y-inc (- (min -1 (1- yzoom))))
	 (xpan (if ( xzoom 0) xpan (* x-inc (floor xpan x-inc))))
	 (ypan (if ( yzoom 0) ypan (* y-inc (floor ypan y-inc))))
	 inside-width inside-height
	 aborted
	 )

    (multiple-value (inside-width inside-height)
      (send self :inside-size))

    (labels ((abort-p ()
	       (declare (sys:downward-function))
	       (unless (and (eql x-pan real-xpan)
			    (eql y-pan real-ypan)
			    (eql x-zoom real-xzoom)
			    (eql y-zoom real-yzoom))
		 (setq aborted t))))

      (cond ((and (zerop xzoom) (zerop yzoom))
	     (tv:with-bit-array
	       zoomed-window :input
	       #'(lambda (raster offset span)
		   (multiple-value-bind (dy dx) (floor offset span)
		     (send self :bitblt tv:alu-seta inside-width inside-height
			   raster dx dy 0 0)))
	       :x-offset xpan
	       :y-offset ypan
	       :width inside-width
	       :height inside-height))
	    ((or (null displayed-x-pan)
		 (null displayed-y-pan)
		 (null displayed-x-zoom)
		 (null displayed-y-zoom))
	     (i-p:pixel-replication-zoom
	       self 0 0
	       zoomed-window xpan ypan
	       inside-width inside-height
	       (1+ xzoom)(1+ yzoom)
	       -1)
	       )
	    (t
	     (let* ((dx (if ( xzoom 0)
			    (* (- xpan displayed-x-pan) (1+ xzoom))
			    (// (- displayed-x-pan xpan) (1- xzoom))))
		    (dy (if ( yzoom 0)
			    (* (- ypan displayed-y-pan) (1+ yzoom))
			    (// (- (- displayed-y-pan ypan) (1- yzoom)))))
		    (y-step (max 1 (1+ yzoom)))
		    (x-step (max 1 (1+ xzoom)))
		    (use-bit-array
		      (when (eq t (send self :save-bits))
			(let* ((screen (send self :screen))
			       (round-to (// 32. (send screen :bits-per-pixel)))
			       (rounded-width (* round-to (ceiling tv:width round-to)))
			       )
			  (tv:%screen-allocate-sheet-temporary-bit-array
			    screen self rounded-width tv:height))))
		    (abort-test-function (when use-bit-array
					   #'abort-p))
		    )
	       (unwind-protect
		   (progn

	       (cond ((or ( xzoom displayed-x-zoom)
			  ( yzoom displayed-y-zoom)
			  ( (abs dx) inside-width)
			  ( (abs dy) inside-height))
		      ;; changing zoom level, or moving a long way
		      (i-p:pixel-replication-zoom
			(or use-bit-array self) 0 0
			zoomed-window xpan ypan
			inside-width inside-height
			x-step y-step -1
			:abort-test-function abort-test-function)
		      )
		     (t  D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; be selective about the update
0		      (let* ((common-y-pan (floor (- inside-height (abs dy)) y-step))
			     (common-x-pan (floor (- inside-width (abs dx)) x-step))
			     (common-width (* x-step common-x-pan))
			     (common-height (* y-step common-y-pan))
			     )

			(let (1;bitblt parameters to copy the main part
0			      bb-width bb-height
			      bb-from-x bb-from-y
			      bb-to-x bb-to-y
			      )
			
			  (if ( dx 0)
1			      ;moving bits leftward
0			      (setq bb-width (- inside-width dx)
				    bb-from-x dx
				    bb-to-x 0)
			      1;moving bits rightward
0			      (setq bb-width  (+ inside-width dx)
				    bb-from-x 0
				    bb-to-x (- dx))
			      )
			
			  (if ( dy 0)
			      1;moving bits upward
0			      (setq bb-height (- inside-height dy)
				    bb-from-y dy
				    bb-to-y 0)
			      1;moving bits downward
0			      (setq bb-height (+ inside-height dy)
				    bb-from-y 0
				    bb-to-y (- dy))
			      )
			
			  (if use-bit-array
			      (send self :bitblt-from-sheet tv:alu-seta
				    bb-width bb-height 
				    bb-from-x bb-from-y
				    use-bit-array
				    bb-to-x bb-to-y)
			      (send self :bitblt-within-sheet tv:alu-seta
				    bb-width bb-height 
				    bb-from-x bb-from-y
				    bb-to-x bb-to-y))
			  )
			
			
			(let* (1;replication parameters to redraw complete rows when DY0
0			       (rf-x-pan xpan)
			       (rf-width inside-width)
			       (rf-from-x 0)
			       rf-from-y 
			       rf-y-pan 1	; the y0-1pan parameters depend on the direction
0			       rf-height

			      
						1;replication parameters to redraw columns when DX0
0			       cf-height
			       cf-width
			       cf-from-y cf-from-x
			       cf-x-pan cf-y-pan)

			  (if ( dy 0)

			      1;shifting up, exposes bits on the bottom
0			      (setq rf-y-pan (+ ypan common-y-pan)
				    rf-from-y common-height
				    rf-height (- inside-height common-height)
				    cf-height (- inside-height rf-height)
				    cf-y-pan y-pan
				    cf-from-y 0
				    )

			      1;shifting down, exposes bits on the top
0			      (setq rf-y-pan ypan
				    rf-from-y 0
				    rf-height (- dy)
				    cf-height (- inside-height rf-height)
				    cf-y-pan (+ ypan (floor (- dy) y-step))
				    cf-from-y (- dy)
				    )
			      )

			  (if ( dx 0)
			      1;shifting left, exposes bits on the right
0			      (setq cf-x-pan (+ xpan common-x-pan)
				    cf-from-x common-width
				    cf-width (- inside-width cf-from-x)
				    )
			      1;shifting right, exposes bits on the left
0			      (setq cf-x-pan xpan
				    cf-from-x 0
				    cf-width (- dx)
				    )
			      )

			  (when ( 0 dy)
			    ;;fix up bunch of rows on the bottom or top
			    (i-p:pixel-replication-zoom
			      (or use-bit-array self) rf-from-x rf-from-y
			      zoomed-window rf-x-pan rf-y-pan
			      rf-width rf-height
			      x-step y-step -1
			      :abort-test-function abort-test-function
			      )
			    )

			  (when ( 0 dx)
			    (i-p:pixel-replication-zoom
			      (or use-bit-array self) cf-from-x cf-from-y
			      zoomed-window cf-x-pan cf-y-pan
			      cf-width cf-height
			      x-step y-step -1
			      :abort-test-function abort-test-function
			      ))
			  ))))
	       (when (and use-bit-array (not aborted))
		 (wait-for-vertical-sync 
		   (send self :bitblt tv:alu-seta inside-width inside-height
			 use-bit-array 0 0 0 0))))
		 (when use-bit-array
		   (tv:%screen-deallocate-sheet-temporary-bit-array
		     tv:screen self use-bit-array))
	       ))))
      (unless aborted
	(let ((cl:*print-base* zoom-printing-base)
	      (cl:*print-radix* nil)
	      (nam (send self :label)))

	  (when (listp nam)
	    (setq nam (sixth nam)))
	  
	  (when (or (eq nam normal-name)
		    (not (array-has-leader-p nam)))
	    (setq nam (make-array 40 ':type 'art-string :leader-list '(0))))
	  (setf (array-leader nam 0) 0)
	  (with-output-to-string (str nam)
	    (format str "Pan ~a,~a x ~d on ~a"
		    xpan ypan (1+ (min xzoom yzoom)) zoomed-window))
	  (send self ':set-label nam)
	  )
	(without-interrupts
	  (setq displayed-x-pan real-xpan
		displayed-x-zoom real-xzoom
		displayed-y-zoom real-yzoom
		displayed-y-pan real-ypan)
	  (when (and (= xpan x-pan)
		     (= ypan y-pan)
		     (= xzoom x-zoom)
		     (= yzoom y-zoom))
	    (stop-zoom-process self :one-shot))))
      ))
  )

(defun ultimate-array-and-offset (array)
  (loop with off = 0
	as arr first array then aip
	while (si:array-indirect-p arr)
	as aip = (si:array-indirect-pointer arr)
	while (= 2 (array-#-dims aip))
	as inc = (// (* (si:array-index-offset arr) 32.)
		     (// 32. (si:array-element-byte-size arr)))
	do (incf off inc)
	finally (return (values arr off))))

(defmacro with-sequential-raster
	  ((from-array &key byte-size prefix mask)
	   &body  body)
  (let ((array (intern (string-upcase (string-append prefix "-ARRAY"))))
	(span (intern (string-upcase (string-append prefix "-SPAN"))))
	(index-offset (intern (string-upcase (string-append prefix "-INDEX-OFFSET"))))
	(pre-aref (intern (string-upcase (string-append prefix "-PRE-AREF"))))
	(pre-aset (intern (string-upcase (string-append prefix "-PRE-ASET"))))
	(aref (intern (string-upcase (string-append prefix "-AREF"))))
	(aset (intern (string-upcase (string-append prefix "-ASET"))))
	(finish-aset (intern (string-upcase (string-append prefix "-FINISH-ASET"))))
	(current-word (intern (string-upcase (string-append prefix "-CURRENT-WORD"))))
	#+imach
	(current-index (SELECTQ PREFIX (A 1)(S-TO 1)(T 2)))
	#+3600
	(current-index (intern (string-upcase (string-append prefix "-CURRENT-INDEX"))))
	(bytes-remaining (intern (string-upcase (string-append prefix "-BYTES-REMAINING"))))
	(subword-bits (1- (haulong (// 32. byte-size))))
	)

  `(multiple-value-bind (ultimate-array ultimate-offset)
       (ultimate-array-and-offset ,from-array)
     (multiple-value-bind (nil nil ultimate-span)
	 (decode-raster-array ultimate-array)
       (multiple-value-bind (nil nil ,array)
	   (si:setup-force-1d-array ultimate-array)
	 (setq ,array
	       #+imach (%pointer-plus ,array (// ultimate-offset 32.))
	       #+3600 (%make-pointer-offset (%data-type ,array) ,array
					     (// ultimate-offset 32.)))
	 (#+imach with-block-registers  #+imach (,current-index)

	  #+3600 progn
	 (let* ((ultimate-subword-bits (- 1 (haulong
						 (cdr (assq (array-type ultimate-array)
							    array-elements-per-q)))))
		(,span (lsh ultimate-span ultimate-subword-bits))
		#+3600 (,current-index)
		,@(when mask
		    `((write-prot-mask ,mask )))
		(,index-offset (ldb (byte ,subword-bits
					  (- 5 ,subword-bits))
				    ultimate-offset))
		,@(when ( byte-size 32.)
		    `((,current-word)
		      (,bytes-remaining)))
		)
	   (macrolet
	     ((,pre-aref (x y)
	       `(let ((stray (+ ,',index-offset ,x)))
		  #+imach
		  ,@(if (= ,byte-size 32.)
			`((cli::load-bar ,',current-index
					 (%pointer-plus ,',array
							(+ stray
							   (* ,y ,',span)))))
			`((cli::load-bar ,',current-index
					 (%pointer-plus ,',array
							(+ (ldb (byte (- 32. ,',subword-bits)
								      ,',subword-bits)
								stray)
							   (* ,y ,',span))))
			  (setq ,',current-word
				(lsh (%block-read ,',current-index)
				     (- (%logdpb (ldb (byte ,',subword-bits 0)
						      stray)
						 (byte ,',subword-bits
						       (- 5 ,',subword-bits))
						 0)))
				,',bytes-remaining
				(- (// 32. ,',byte-size)
				   (ldb (byte  ,',subword-bits 0) stray))
				)))
		  #+3600
		  (setq  ,',current-index
			 ,@(if (= ,byte-size 32.)
			       `((%make-pointer-offset (%data-type ,',array) ,',array
						       (+ stray
							  -1
							  (* ,y ,',span))))
			       `((%make-pointer-offset (%data-type ,',array) ,',array
						       (+ (ldb (byte (- 32. ,',subword-bits)
								     ,',subword-bits)
							       stray)
							  -1
							  (* ,y ,',span)))
				 ,',current-word
				 (lsh (si:%p-contents-increment-pointer ,',current-index)
				      (- (%logdpb (ldb (byte ,',subword-bits 0)
						       stray)
						  (byte ,',subword-bits (- 5 ,',subword-bits))
						  0))
				      )
				 ,',bytes-remaining
				 (- (// 32. ,',byte-size)
				    (ldb (byte  ,',subword-bits 0) stray)))))
	       ))
	      (,pre-aset (x y)
	       `(let ((stray (+ ,',index-offset ,x)))
		  #+imach
		  (PROGN
		    ,@(if (= ,byte-size 32.)
			  `((cli::load-bar ,',current-index (%pointer-plus ,',array
									   (+ stray
									      (* ,y ,',span)))))
			  `((cli::load-bar ,',current-index
					   (%pointer-plus ,',array
							  (+ (ldb (byte (- 32. ,',subword-bits)
									,',subword-bits)
								  stray)
							     (* ,y ,',span))))
			    (setq ,',current-word
				  (lsh (%block-read ,',current-index :no-increment t)
				       (- 32 (%logdpb (ldb (byte ,',subword-bits 0)
							stray)
						   (byte ,',subword-bits
							 (- 5 ,',subword-bits))
						   0)))
				  ,',bytes-remaining
				  (- (// 32. ,',byte-size)
				     (ldb (byte  ,',subword-bits 0) stray))
				  )))
		    (SI:PREPARE-FOR-BLOCK-WRITE)
		    )
		  #+3600
		  (setq  ,',current-index
			 ,@(if (= ,byte-size 32.)
			     `((%make-pointer-offset (%data-type ,',array) ,',array
						      (+ stray
							 -1
							 (* ,y ,',span))))
			       
			     `((%make-pointer-offset (%data-type ,',array) ,',array
						   (+ (ldb (byte (- 32. ,',subword-bits)
								 ,',subword-bits)
							   stray)
						      -1
						      (* ,y ,',span)))
			       ,',current-word
			       (lsh (si:%p-contents-offset ,',current-index 1)
				    (- 32 (%logdpb (ldb (byte ,',subword-bits 0)
							stray)
						   (byte ,',subword-bits
							 (- 5 ,',subword-bits))
						   0))
				    )
			       ,',bytes-remaining
			       (- (// 32. ,',byte-size)
				  (ldb (byte  ,',subword-bits 0) stray))))
			 )))
	      (,aref ()
	       (if (= ,byte-size 32.)
		   #+imach `(%block-read ,',current-index)
		   #+3600 `(si:%p-contents-increment-pointer ,',current-index)
		   `(progn
		      (when (= 0 ,',bytes-remaining)
			(setq ,',current-word
			      #+imach (%block-read ,',current-index)
			      #+3600 (si:%p-contents-increment-pointer ,',current-index)
			      ,',bytes-remaining (// 32. ,',byte-size)))
		      (prog1 (ldb (byte ,',byte-size 0) ,',current-word)
			     (setq ,',bytes-remaining (1- ,',bytes-remaining))
			     (setq ,',current-word (ldb (byte (- 32. ,',byte-size)
							      ,',byte-size)
							,',current-word))))))
	      (,aset (val) 
	       ,(if (= byte-size 32.)
		   #+imach
		   (if mask
		       ``(let ((old (%block-read ,',current-index :no-increment t)))
			   (%block-write
			     ,',current-index
			     (logxor old (logand write-prot-mask (logxor old ,val)))
			     ))
		       ``(%block-write ,',current-index ,val))
		   #+3600
		   (if mask
		       ``(let ((old (si:%p-contents-offset ,',current-index 0)))
			   (%p-store-contents-increment-pointer
			     (logxor old (logand write-prot-mask (logxor old ,val)))
			     ,',current-index))
		       ``(%p-store-contents-increment-pointer ,val ,',current-index))
		   ``(progn
		      (setq ,',bytes-remaining (1- ,',bytes-remaining))
		      (setq ,',current-word
			    (%logdpb ,val
				     (byte ,',byte-size (- 32. ,',byte-size))
				     (ldb (byte (- 32. ,',byte-size) ,',byte-size)
					  ,',current-word)))
		      (when (= 0 ,',bytes-remaining)
			#+imach
			,,(if mask
			     ``(let ((old (%block-read ,',current-index :no-increment t)))
				(%block-write ,',current-index
					      (logxor old
						      (logand write-prot-mask
							      (logxor old ,',current-word)))))
			     ``(%block-write ,',current-index ,',current-word))
			#+3600
			,,(if mask
			     ``(let ((old (%p-contents-offset ,',current-index 0)))
				(%p-store-contents-increment-pointer
				  (logxor old (logand write-prot-mask
						      (logxor old ,',current-word)))
				  ,',current-index))
			     ``(%p-store-contents-increment-pointer
				 ,',current-word
				 ,',current-index)
			     )
			(setq ,',bytes-remaining (// 32. ,',byte-size))))))
	      (,finish-aset ()
	       (if (= ,byte-size 32.)
		   ()
		   `(when ( ,',bytes-remaining (// 32. ,',byte-size))
		      (let* ((sc (- (%logdpb ,',bytes-remaining
					     (byte 5 (- 5 ,',subword-bits))
					     0) 32.))
			     (sv (logior (lsh (lsh #+imach (%block-read ,',current-index
									:no-increment t)
						   #+3600 (%p-contents-increment-pointer
							     ,',current-index)
						   sc)
					      (- sc))
					 (lsh ,',current-word (- (+ 32. sc))))))
			#+imach
			,,(if mask
			     ``(let ((old (%block-read ,',current-index :no-increment t)))
			       (%block-write ,',current-index
					     (logxor old (logand write-prot-mask
								(logxor sv old)))))
			     ``(%block-write ,',current-index sv))
			#+3600			
			,,(if mask
			     ``(let ((old (%p-contents-offset ,',current-index 0)))
				(%p-store-contents ,',current-index
						   (logxor sv (logand write-prot-mask
								      (logxor sv old)))))
			     ``(%p-store-contents ,',current-index sv))
			)))))
	     ,@body)
	 )))))))
#||
;;;
;;; These are test functions, which should behave like AREF and ASET respectively
;;; this dosn't completely do the job of testing, since they only tests with
;;; one sequential access rather than many.
;;;
(defun ar (arr x y &optional noerror fo)
  (with-sequential-raster (arr :prefix a :byte-size 8. :mask fo)
    (a-pre-aref x y)
    (let ((av (a-aref))
	  (rv (raster-aref arr x y)))
      (unless (or noerror (= av rv))
	(ferror "Non-match at ~d,~d  sb: ~12o  is:~12o"
		x y rv av))
      av))
  )

(defun as (arr v x y &optional noerror)
  (with-sequential-raster (arr :prefix s-to :byte-size 32.)
    (s-to-pre-aset x y)
    (s-to-aset v)
    (s-to-finish-aset)
    (let ((rv (raster-aref arr x y)))
      (unless (or noerror (= v rv))
	(ferror "Non-match at ~d,~d  sb: ~12o  is:~12o"
		x y rv v))
      v)))


||#

(defun pixel-replication-zoom-rectangle
       (from-sheet-or-array to-sheet-or-array
	x-pan y-pan x-zoom y-zoom
	left top right bottom
	&key
	abort-test-function
	per-line-function
	(note-progress "Pixel Replication Zoom")
	(write-mask -1))
  (tv:noting-progress (note-progress)
    (tv:with-prepared-sheet-or-raster
      (from-sheet-or-array
	:width from-width
	:height from-bottom
	:bits-per-pixel bits-per-pixel) 
      (let* ((x-step (- (min -1 (1- x-zoom))))
	     (y-step (- (min -1 (1- y-zoom))))
	     (y-zoom (max 1 (1+ y-zoom)))
	     (x-zoom (max 1 (1+ x-zoom)))
	     (x-pan (\ x-pan from-width))
	     (y-pan (\ y-pan from-bottom))
	     (n-lines (- bottom top))
	     (to-w (- right left))
	     value
	     (write-mask (effective-write-mask write-mask nil bits-per-pixel))
	     )

	(tv:with-bit-array
	  to-sheet-or-array :output
	  #'(lambda (to-array to-offset to-span)
	      (multiple-value-bind (to-dy to-dx) (floor to-offset to-span)
		(tv:with-bit-array
		  from-sheet-or-array :input
		  #'(lambda (from-array from-offset from-span)
		      (multiple-value-bind (from-dy from-dx) (floor from-offset from-span)
          (let ((from-array from-array)
		(from-width (decode-raster-array from-array))
		(to-array to-array)
		)
	    (declare (sys:array-register-1d from-array to-array))

	    (macrolet ((replicate-region (bits-per-pixel &optional mask)
			 `(with-sequential-raster (to-array
						    :prefix s-to
						    :mask ,mask
						    :byte-size ,bits-per-pixel)
			    (loop with last-to-y = (+ to-dy n-lines)
				  for to-y from to-dy below last-to-y
					   by y-zoom
				  as from-y first from-dy
					    then (let ((next (+ from-y y-step)))
						   (if ( next from-bottom)
						       0 next))
				  as from-idx = from-offset
					      then (if (zerop from-y)
						       from-dx
						       (+ from-idx from-span))
				  as from-lim = (- (+ from-idx from-width) from-dx)

				  do

			      (when (and abort-test-function
					 (funcall abort-test-function))
				(setq value 'abort)
				(return nil)
				)
			      (s-to-pre-aset to-dx to-y)

			      (loop named outer-loop
				    with to-x = to-dx
				    as from-x first from-idx
					      then (let ((next (+ from-x x-step)))
						     (if (< next from-lim)
							 next
							 (- from-idx from-dx)
							 ))
				    as from-pix = (aref from-array from-x)
				    do
				(loop repeat x-zoom
				      do (s-to-aset from-pix)
					 (incf to-x)
				      when ( to-x right)
					do (return-from outer-loop nil)))
			      (s-to-finish-aset)
			      ,(if mask
				   `(let ((tv:bitblt-unpacking-mask write-mask))
				      (tv:bitblt-masked
					tv:alu-seta
					to-w (1- (min (- last-to-y to-y) y-zoom))
					to-array to-dx to-y
					to-array to-dx (1+ to-y)))
				   `(bitblt tv:alu-seta
					    to-w (1- (min (- last-to-y to-y) y-zoom))
					    to-array to-dx to-y
					    to-array to-dx (1+ to-y)))
			      (when per-line-function
				(funcall per-line-function))
			      (when note-progress
				(tv:note-progress to-y n-lines))
			      ))))
	      (if ( write-mask -1)
		  (selector bits-per-pixel =
		    (1 (replicate-region 1 write-mask))
		    (2 (replicate-region 2 write-mask))
		    (4 (replicate-region 4 write-mask))
		    (8 (replicate-region 8 write-mask))
		    (16. (replicate-region 16. write-mask))
		    (32. (replicate-region 32. write-mask))
		    )
		  (selector bits-per-pixel =
		    (1 (replicate-region 1))
		    (2 (replicate-region 2))
		    (4 (replicate-region 4))
		    (8 (replicate-region 8))
		    (16. (replicate-region 16.))
		    (32. (replicate-region 32.))
		    ))
	    )
	  value
	  )))
		  :x-offset x-pan
		  :y-offset y-pan
		  :width (ceiling (- right left ) x-zoom)
		  :height (ceiling (- bottom top) y-zoom))))
	  :x-offset left
	  :y-offset top
	  :width (- right left)
	  :height (- bottom top)
	  )))))


(2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB");;
;; These whoppers make the zoomed-window arg default to our window 
;;

0(defwhopper (:pan-zoom-from-mouse-rectangle zoom-window-mixin) (&optional zw)
  (stop-zoom-process self t)
  (when zw (send self :set-zoomed-window zw))
  (continue-whopper zoomed-window))

(defwhopper (:key-set-pan-zoom zoom-window-mixin) (&optional zw &rest args)
  (stop-zoom-process self t)
  (when zw (send self :set-zoomed-window zw))
  (let-globally (((send si:current-process :priority)
		  (send tv:mouse-process :priority)))
    (lexpr-continue-whopper zoomed-window args)))

(defwhopper (:mouse-pan-zoom zoom-window-mixin) (&optional zw &rest args)
  (stop-zoom-process self t)
  (when zw (send self :set-zoomed-window zw))
  (let-globally (((send si:current-process :priority)
		  (send tv:mouse-process :priority)))
    (unwind-protect
	(progn (start-zoom-process self :mouse-pan-zoom)
	       (lexpr-continue-whopper zoomed-window args))
      (stop-zoom-process self :mouse-pan-zoom))))

(defwhopper (:pan-zoom-visible-edges zoom-window-mixin) (&optional ignore )
  (continue-whopper zoomed-window))

(defwhopper (:pan-and-zoom-from-rectangle-maybe zoom-window-mixin)
	   (wl wt wr wb &optional zw)
  (stop-zoom-process self t)
  (when zw (send self :set-zoomed-window zw))
  (continue-whopper wl wt wr wb zoomed-window))

(defwhopper (:pan-from-rectangle zoom-window-mixin)
	   (left top right bottom &optional zw)
  (stop-zoom-process self t)
  (when zw (send self :set-zoomed-window zw))
  (continue-whopper left top right bottom zoomed-window))

(defwhopper (:pan-and-zoom-from-rectangle zoom-window-mixin)
	   (left top right bottom
		 &optional (make-zoom-square t) zw)
  (stop-zoom-process self t)
  (when zw (send self :set-zoomed-window zw))
  (continue-whopper left top right bottom make-zoom-square zoomed-window))





(defflavor pan-zoom-window () (zoom-window-mixin tv:window)
  (:default-init-plist :save-bits t :blinker-p nil))

(defflavor temporary-pan-zoom-window () (tv:temporary-window-mixin pan-zoom-window))

(tv:defwindow-resource temporary-pan-zoom-window ()
  :MAKE-WINDOW (temporary-pan-zoom-window)
  :REUSABLE-WHEN :DEEXPOSED)

;;
;; A function for the user to call to pop up a zoom window
;;
(defun pop-up-pan-zoom-window (&key
			       (method :mouse-pan-zoom)
			       (sheet tv:mouse-sheet)
			       (edges))
  (destructuring-bind (left top right bottom) edges
    (unless (and left top right bottom)
      (multiple-value (left top right bottom)
	(tv:mouse-specify-rectangle left top right bottom sheet 20 20 t))
      (when (and left top right bottom)
	(using-resource (win temporary-pan-zoom-window)
	  (unwind-protect
	      (progn (send win :set-edges left top right bottom)
		     (send win :set-superior sheet)
		     (send win :set-zoomed-window sheet)
		     (send win :expose)
		     (send win method)
		     )
	    (send win :deactivate)))))))


(tv:add-function-key #/Z 'clear-screen-pan-zoom
		   "no arg  Clear pan and zoom to zero.
		    	1   Change pan and zoom with the shift keys
	      	    	2   Change pan and zoom with the mouse
		        3   Pan and Zoom to a rectangle specified by the mouse
			4   Pop up a magnifier window on the mouse sheet")

(tv:add-function-key #/X 'exchange-mouse-screen "Mouse to the next screen")

(defun exchange-mouse-screen (arg)

  (loop with s = (cond (tv:window-owning-mouse nil)
		       (arg ;; nth screen
			(setq arg (- (length tv:all-the-screens) arg 1))
			(when (>= arg 0)
			  (nthcdr arg tv:all-the-screens)))
		       (t ;; next screen
			(or (cdr (memq tv:mouse-sheet tv:all-the-screens))
			    tv:all-the-screens)))
	while (and s
		   (or (not (send (car s) ':user-visible))
		       (tv:sheet-output-held-p (car s))
		       (and (send (car s) ':invisible-to-mouse-p)
			    (not (or (send (car s) :get :turn-video-on-for-mouse)

				     ;this is the wrong name, but some folks were using it..
				     (send (car s) :get :turn-on-video-for-mouse)))
			    )))
	do (setq s (or (cdr s) tv:all-the-screens))
	finally
	  (if s
	      (tv:mouse-set-sheet (car s))
	      (tv:beep))))

(defun clear-screen-pan-zoom (arg)

  (let ((scr (cond ((eql arg 4) tv:mouse-sheet)
		   ((and (instancep tv:mouse-sheet) 
			 (send tv:mouse-sheet ':operation-handled-p ':pan-and-zoom-p)
			 (send tv:mouse-sheet ':pan-and-zoom-p)
			 (not (send tv:mouse-sheet :send-if-handles :get :ignore-function-z))
			 )
		    tv:mouse-sheet)
		   (t (loop for i in tv:all-the-screens 
			    when (and (send i ':exposed-p)
				      (send i ':operation-handled-p ':pan-and-zoom-p)
				      (send i ':pan-and-zoom-p)
				      (not (send i :send-if-handles :get :ignore-function-z))
				      )
			      do (return i))))))
    (cond ((null scr) (beep))
	  (arg
	   (send current-process ':set-priority 2)
	   (let-globally ((tv:who-line-process tv:current-process))
	     (flavor::eval-in-instance
	       tv:current-process 
	       `(setq tv:whostate
		      ,(selectq arg
			 (1 "Set pan and zoom from control keys")
			 (2 "Mouse pan and zoom")
			 (3 "Mouse Specify Zoomed Rectangle")
			 (t ""))))
	     (tv:who-line-run-state-update)
	     (selectq arg
	       (1 (send scr ':send-if-handles ':key-set-pan-zoom))
	       (2 (send scr ':send-if-handles ':mouse-pan-zoom))
	       (3 (send scr ':send-if-handles ':pan-zoom-from-mouse-rectangle))
	       (4 (pop-up-pan-zoom-window :sheet scr)))
	     ))
	  (t (send scr ':send-if-handles ':set-pan-and-zoom 0 0 0 0)))
  ))

(compile-flavor-methods pan-zoom-window temporary-pan-zoom-window)
