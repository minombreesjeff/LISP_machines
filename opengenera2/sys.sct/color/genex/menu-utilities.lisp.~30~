;;; -*- Mode: LISP; Base: 10.; Package: TV -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

(defmacro using-window ((window &key
				(expose-p t)
				(final-action nil)
				(default-character-style)
				(typein-character-style)
				(echo-character-style)
				(select-p t)
				(warp-mouse t)
				(notification-mode :unspecified)
				(zoom t))
			&body body)
  `(using-window-internal ,window  #'(lambda nil ,@body)
			  :default-character-style ,default-character-style
			  :typein-character-style ,typein-character-style
			  :echo-character-style ,echo-character-style
			  :expose-p ,expose-p :select-p ,select-p
			  :warp-mouse ,warp-mouse :zoom ,zoom
			  :final-action ,final-action
			  ,@(when (neq notification-mode :unspecified)
			      `(:notification-mode ,notification-mode))
			  ))


(defun using-window-internal
       (window continuation
	&key (expose-p t) (select-p t) (warp-mouse t)
	(zoom t) (final-action nil)
	(default-character-style)
	(typein-character-style)
	(echo-character-style)
	(notification-mode :unspecified)
	)

  (declare (sys:downward-funarg continuation))

  (dbg:with-default-bug-report-recipient-system ('graphics-support)
    (let ((old-selected-window selected-window)
	  (screen (sheet-screen window))
	  (width (sheet-width window))
	  (height (sheet-height window))
	  (old-mouse-x mouse-x)
	  (old-mouse-y mouse-y)
	  (old-mouse-sheet mouse-sheet)
	  (old-echo-character-style (send window :echo-character-style))
	  (old-typein-character-style (send window :typein-character-style))
	  (old-notification-mode (send window :notification-mode))
	  (cl:*query-io* window)
	  zoom-x zoom-y pan-x pan-y)

      (unwind-protect
	  (progn 
	    (when (neq notification-mode :unspecified)
	      (send window :set-notification-mode notification-mode))
	    (when zoom
						;record the old pand and zoom
	      (multiple-value (pan-x pan-y zoom-x zoom-y)
		(send screen :send-if-handles :pan-and-zoom))
	      (unless (and pan-x pan-y zoom-x zoom-y)
		(setq zoom nil))
	      )
	  
	    (when expose-p
	      (unless (send window :exposed-p )
		(expose-window-near window
				    (if (eq expose-p t) '(:mouse) expose-p) warp-mouse)))

	    (send window :set-cursor-visibility :on)

	    (when select-p
	      (unless (eq window selected-window)
		(send window :select)))
	  
	    (when zoom
	      (let* ((my-relative-size (max (// (float height)
						(sheet-inside-height screen))
					    (// (float width)
						(sheet-inside-width screen))))
		     (new-zoom (if (fixp zoom) zoom
				   (fix (max 0 (min 20 (1- (// (if (eq zoom t)
								   0.75
								   zoom)
							       my-relative-size))))))))
		(send screen :set-zoom new-zoom new-zoom t)
		(multiple-value-bind (x y)
		    (sheet-calculate-offsets window screen)
		  (send screen :pan-from-rectangle x y (+ x width) (+ y height))
		  (send screen :new-control)
		  )))

	    (when warp-mouse
	      (unless (sheet-calculate-offsets window mouse-sheet nil)
		(mouse-set-sheet screen))
	    
	      (multiple-value-bind (left top)
		  (sheet-calculate-offsets window mouse-sheet nil)
		(when (and left top)
		  (unless (and ( left mouse-x (+ left width))
			       ( top  mouse-y (+ top height)))
		    (mouse-warp (// (+ left left width) 2)
				(// (+ top top height) 2)))))
	    
	      (setq mouse-reconsider t)
	      (mouse-wakeup)
	      )

	    (with-character-style ((if default-character-style
				       default-character-style
				       (send window :default-character-style)) t)
	      (when typein-character-style
		(send window :set-typein-character-style typein-character-style))
	      (when echo-character-style
		(send window :set-echo-character-style echo-character-style))
	      (funcall continuation)
	      ))
	;; Cleanup forms for the unwind-protect start here...
	(when (neq notification-mode :unspecified)
	  (send window :set-notification-mode old-notification-mode))
	(when echo-character-style
	  (send window :set-echo-character-style old-echo-character-style))
	(when typein-character-style
	  (send window :set-typein-character-style old-typein-character-style))
	(when warp-mouse
	  (when (and (instancep old-mouse-sheet)
		     (neq mouse-sheet old-mouse-sheet))
	    (mouse-set-sheet old-mouse-sheet))
	  (when (and old-mouse-x old-mouse-y)
	    (mouse-warp old-mouse-x old-mouse-y))
	  (setq mouse-reconsider t)
	  (mouse-wakeup))

	(when zoom
	  (send screen :set-pan-and-zoom pan-x pan-y zoom-x zoom-y))

	(when (and select-p
		   old-selected-window
		   (neq selected-window old-selected-window)
		   (neq window old-selected-window))
	  (send old-selected-window :select nil))

	(when final-action (send window final-action))
	))))

(defvar *standard-menu-margins-and-labels*
	`(;(DW:MARGIN-BORDERS :THICKNESS 2)
	  (DW:MARGIN-WHITE-BORDERS :THICKNESS 2)
	  ;(DW:MARGIN-LABEL :MARGIN :TOP :BOX NIL :BOX-THICKNESS NIL)
	  ))

(defvar *standard-menu-margins-labels-and-scroll-bars*
	`(;(DW:MARGIN-RAGGED-BORDERS :THICKNESS 2)
	  ;(DW:MARGIN-WHITE-BORDERS :THICKNESS 2)
	  (DW:MARGIN-SCROLL-BAR)
	  ;(DW:MARGIN-LABEL :MARGIN :TOP)
	  ))



;----------------------------------------------------------------------------
;;; Returns the number of "regular" items which are selectable and not special-choices.



(defflavor augment-menu-mixin ((final-button nil)
			       (multiple-choice-items)
			       (regular-choice-items)
			       (momentary-mode t)
			       (set-edges-mode)
			       )
	   (top-box-label-mixin dw:margin-mixin)
  (:settable-instance-variables multiple-choice-items momentary-mode)
  (:initable-instance-variables multiple-choice-items momentary-mode)
  (:locatable-instance-variables set-edges-mode)
  (:default-init-plist :scroll-bars nil
		       :margin-components *standard-menu-margins-labels-and-scroll-bars*
		       )
  (:required-flavors menu-highlighting-mixin basic-menu))

(defwhopper (invert-item augment-menu-mixin)  (item)
  (let ((str (menu-item-string self item)))
    (if (and (instancep str) (send str :operation-handled-p :menu-invert))
	(multiple-value-bind (x y) (send self :item-rectangle item)
	  (when (and x y)
	    (send str :menu-invert self x y)))
	(continue-whopper item))))

(defwhopper (:menu-draw augment-menu-mixin) ()
  ;don't attempt drawing when not exposed.
  (when exposed-p (continue-whopper)))

(defmethod (:mouse-click tv:augment-menu-mixin) (button x y)
  ;this method is duplicated from dw::margin-mixin to overcome a flavor-precedence
  ;problem
  (when dw::mouse-margin-component
    (setq tv:chosen-item nil)
    (dw::mouse-margin-component-mouse-click dw::mouse-margin-component self button x y)))

(defmethod (:who-line-documentation-string augment-menu-mixin) ()
  ;permit the documentation to be a list of items
  (let ((item (and (variable-boundp current-item)
		   (menu-item-who-line-documentation current-item))))
    (if (listp item)
	(lexpr-funcall #'values item)
	item)))

(defmethod (:mouse-moves augment-menu-mixin :after) (x y)
  (unless dw::mouse-margin-component
    (let ((act (send self :get :mouse-moves-action)))
      (when act (funcall act self x y)))))

(defmethod (set-item-list-quietly augment-menu-mixin) (to multiple labl)
  (variable-makunbound item-list) D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");this inhibits geometry twiddling for the :set-label
0  (send self :set-label labl)
  (setq ;item-list nil
	multiple-choice-items multiple
	regular-choice-items to))


(defmethod (:MOUSE-BUTTONS augment-menu-mixin :after) (bd &rest ignore)
  (cond (chosen-item
	 (setq final-button (tv:mouse-button-encode bd (sheet-mouse self)))
	 )
	(t (setq final-button nil))))


(defwhopper (:choose augment-menu-mixin) (&rest args)
  (multiple-value-bind (choice chosen)
      (lexpr-continue-whopper args)
    (values choice chosen final-button))
  )
(defmethod (:choose augment-menu-mixin :after) (&rest ignore)
  (send self :remprop :mouse-moves-action))

(defwrapper (:mouse-buttons augment-menu-mixin) (ignore . body)
  `(let ((item current-item))
     (cond ((and (listp item)
		 (listp (cdr item))
		 (or (get (cddr item) :multiple-choice-item)
		     (and (memq item multiple-choice-items)
			  (not (get (cddr item) :special-choice)))))
	    (send self (if (memq item highlighted-items)
			   ':remove-highlighted-item
			   ':add-highlighted-item)
		  item))
	   (t . ,body))))
(defmethod (:set-chosen-item-and-buttons augment-menu-mixin) (chosen button)
  (setq chosen-item chosen
	final-button button))

(defmethod (construct-item-list augment-menu-mixin) ()
  (let* ((n-columns columns)
	 (end-item (car (last regular-choice-items)))
	 (end-item-empty (and (listp end-item)
			      (listp (cdr end-item))
			      (eq (cadr end-item) :no-select)))
	 (empty-items (loop with n-items = (- (length regular-choice-items)
					      (if end-item-empty 1 0))
			    repeat (cond (*ORDER-MENU-COLUMNWISE* 1)
					 ((> n-columns 1)
					  (let ((spare (\ n-items n-columns)))
					    (if (zerop spare) 0 (- n-columns spare))))
					 ((= n-columns 1) 1)
					 (t 0))
			    collect  '("" :NO-SELECT NIL))))

    (send self :set-item-list
	  (if multiple-choice-items
	      (append regular-choice-items
		      empty-items		
		      multiple-choice-items)
	      regular-choice-items))))

(defmethod (:menu-compute-geometry augment-menu-mixin :before) (&rest ignore)
  (construct-item-list self))

(defmethod (:item-row augment-menu-mixin) (item)
  (loop with idx = -1
	and last-idx = (array-length row-map)
	and end-item = item-list
	as il = item-list then (cdr il)
	as (current-item) = il
	while il
	do
    (when (eq end-item il)
      (incf idx)
      (setq end-item (if (>= idx last-idx) nil (aref row-map (1+ idx)))))
    (when (eq current-item item)
	   (return idx))))

(defmethod (auto-deactivate-p augment-menu-mixin ) (&optional reason)	
  (cond ((eq momentary-mode t) t)
	((eq momentary-mode nil) nil)
	((and (listp momentary-mode)
	      (memq reason momentary-mode)))
	))

(defwhopper (:set-label augment-menu-mixin) (new)
  (let ((font (and (listp new)
		   (getf new :font))))
    (when font
      (setq new (copylist new))
      (remprop (locf new) :font)
      (putprop (locf new) (si:backtranslate-font font) :style)
      ))
  (continue-whopper new))

(defwhopper (:set-scroll-bar-always-displayed-p augment-menu-mixin) (margin new)
  (when (send self :scroll-bar-in-margin margin)
    (continue-whopper margin new)))

;dw likes this message
(defmethod (:clear-history tv:augment-menu-mixin) (&rest ignore) nil)

(defwhopper (:set-edges augment-menu-mixin) (&rest args)
  (unless (eq set-edges-mode :inhibited)
    (lexpr-continue-whopper args)))

;;
;; menu flavor for dynamic mice
;;
(defflavor augmented-menu ()
	   (augment-menu-mixin
	    graphics-mixin
	    menu-highlighting-mixin
	    momentary-menu
	    basic-menu
	    si:property-list-mixin)
  (:default-init-plist :item-list nil :property-list nil
		       ))

(defflavor augmented-command-menu ()
	   (augment-menu-mixin
	    graphics-mixin
	    menu-highlighting-mixin 
	    command-menu
	    si:property-list-mixin
	    show-partially-visible-mixin)
  (:init-keywords :setup)
  (:default-init-plist :item-list nil :property-list nil))


(defflavor augmented-menu-pane ()
	   (pane-mixin
	    augment-menu-mixin
	    graphics-mixin
	    menu-highlighting-mixin
	    basic-menu
	    si:property-list-mixin
	    basic-scroll-bar
	    tv:minimum-window
	    )
  (:default-init-plist :item-list nil :property-list nil :borders nil :label nil
		       :width 20 :height 20))

(defmethod (:mouse-buttons augmented-menu-pane :after) (&rest ignore)
  (send superior :set-chosen-item-and-buttons chosen-item final-button))
(defmethod (:%last-item-in-row-p augmented-menu) (item)
  (let ((next-item (loop for i on (aref row-map 0)
			 as im = (menu-item-string self (car i))
			 when (eq im item)
			 return (cadr i))))
    (loop for i from 0 below (array-length row-map)
	  as (item) = (aref row-map i)
	  when (eql item next-item)
	    return t)))

(defmethod (:menu-print augmented-menu-pane) (window x y)

  (unless (send window :column-row-size)
    (let ((last (send window :%last-item-in-row-p self)))
      (when last
	(let ((cx (- (send window :inside-width) x (send self :width))))
	  (incf x (max 0 (// cx 2)))))))

  (multiple-value-bind (left top) (send window :inside-edges)
    (send self :set-position
	  (+ x left)
	  (+ y top)))

  (if (send self :exposed-p)
      (send self :refresh)
      (when (tv:sheet-within-sheet-p self superior)
	(send self :expose))))

(defmethod (:menu-bounding-box-size augmented-menu-pane) (window &rest ignore)
  (ignore window)
  (send self :size))
 
(defwindow-resource augmented-menu ()
	:make-window (augmented-menu ))

(defwindow-resource augmented-menu-pane ()
	:make-window (augmented-menu-pane ))

;; interlisp NCHARS, except it also can limit the size of an object

(deffunction nchars lambda
	     (obj &optional slashify
		  &special (size-limit 10000)
		  &aux &special (current-size 0) &local toobig)
  (block nchars

    (typecase obj
      (:STRING 
	(let ((val (IF (NOT SLASHIFY)
		       (ARRAY-ACTIVE-LENGTH OBJ)
		       (+ 2 (LOOP FOR I FROM 0 BELOW
				      (MIN (ARRAY-ACTIVE-LENGTH OBJ) SIZE-LIMIT)
				  AS CHAR = (AREF OBJ I)
				  IF (SI:SLASHIFY-WITHIN-STRING-P CHAR)
				    SUM 2 ELSE SUM 1)))))
	  (return-from nchars (values val ( val size-limit)))
	  ))
      (:BIGNUM (when (> (fix (1+ (// (haulong obj) (// (log base) #.(log 2))))) size-limit)
		 (return-from nchars (values size-limit t)))))
    (setq toobig
	  (*catch 'size-limit-exceeded
	    (progn (cond (slashify (prin1 obj #'limited-flatsize-stream))
			 (t (princ obj #'limited-flatsize-stream)))
		   nil)))
    (values current-size toobig)))

;;
;; this is a copy of FLATSIZE-STREAM with the addition of a check against the upper
;; bound size in NCHARS
;;
(defun limited-flatsize-stream (operation &optional arg1 &rest rest)
  (declare (special current-size size-limit))
  (cond ((eq operation ':tyo)
	 (and (fixp size-limit) (>= current-size size-limit) (*throw 'size-limit-exceeded t))
	 (setq current-size (1+ current-size)))
	((eq operation ':which-operations)
	 '(:tyo))
	(t (stream-default-handler 'limited-flatsize-stream operation arg1 rest))))


;;
;; this truncates a name to at most a predetermined size.  If possible,
;; it returns the original.  If any truncation is done, the last three
;; characters are made "..."
;;
(defun truncate-name (name limit
		      &local &optional (slashify t)
		      &aux
		      (nc (nchars name slashify (1+ limit)))
		      &special
		      (current-size 0)
		      (size-limit (cond ((<= nc limit) limit)
					(t (- limit 3)))))
    (with-output-to-string (iostream)
      (let ((iostream iostream)) ;compiler bug in 7.2?
	(declare (special iostream))
	(and (*catch 'size-limit-exceeded
	       (selectq slashify
		 ((t) (prin1 name #'size-limiting-stream))
		 (t (princ name #'size-limiting-stream)))
	       nil)
	     (princ "..." iostream))
	)
      ))
;;
;; this is like NCHARS, except it counts size and optionally limits on
;; the size of a box rather than the plain length of the string
;;
(deffunction bounding-box-chars lambda
	     (obj &optional slashify 
		  &special (width-limit 10000) (length-limit 100)
		  &aux &special
		  (max-width 0)
		  (current-width 0)
		  (current-length 0)
		  &local toobig)
  (block box-nchars
    (typecase obj
      (:BIGNUM (when (> (fix (1+ (// (haulong obj) (// (log base) #.(log 2)))))
			width-limit)
		 (return-from box-nchars (values width-limit 1 t)))))
    (setq toobig
	  (*catch 'size-limit-exceeded
	    (progn (cond (slashify (prin1 obj #'bounding-box-limited-flatsize-stream))
			 (t (princ obj #'bounding-box-limited-flatsize-stream)))
		   nil)))
    (values (max max-width current-width) current-length toobig)))

;;
;; this is a copy of FLATSIZE-STREAM with the addition of a check against the upper
;; bound size for length and width
;;
(defun bounding-box-limited-flatsize-stream (operation &optional arg1 &rest rest)
  (declare (special current-length current-width width-limit length-limit max-width))
  (cond ((eq operation ':tyo)
	 (cond ((char-equal arg1 #\newline)
		(setq max-width (max current-width max-width))
		(setq current-width 0)
		(cond ((fixp length-limit)
		       (setq current-length (1+ current-length))
		       (and (> current-length length-limit)
			    (*throw 'size-limit-exceeded t)))))
	       (t (setq current-width (1+ current-width))
		  (and (fixp width-limit)
		       (> current-width width-limit)
		       (*throw 'size-limit-exceeded t))))
	 )
	((eq operation ':which-operations)
	 '(:tyo))
	(t (stream-default-handler 'bounding-box-limited-flatsize-stream
				   operation arg1 rest))))


;;
;; like truncate-name, except it truncates to a specified box size
;;
(defun truncate-name-to-box (name &special width-limit length-limit
			  &local &optional (slashify t)
			  )
  
  (multiple-value-bind (nil nil xc)
    (bounding-box-chars name slashify width-limit length-limit)

    (cond ((null xc)
	   (cond ((stringp name)
		  name)
		 (slashify (format nil "~S" name))
		 (t (format nil "~A" name))))
	  (t (let ((str (make-array 100 :type 'art-string :leader-list '(0)))
		 (current-width 0)
		 (current-length 0)
		 (current-index 0))
	     (with-output-to-string (iostream str current-index)
	       (labels ((box-size-limiting-stream
			   (operation &optional arg1 &rest rest)
			  (declare (downward-function))
			  (cond ((eq operation ':tyo)
				 (cond ((char-equal arg1 #\newline)
					(send iostream ':tyo arg1)
					(setq current-index (1+ current-index))
					(setq current-width 0)
					(cond ((fixp length-limit)
					       (setq current-length (1+ current-length))
					       (and ( current-length length-limit)
						    (*throw 'size-limit-exceeded t)))))
				       ((fixp width-limit)
					(setq current-width (1+ current-width))
					(cond ((> current-width width-limit)
					       (cond ((= current-width (1+ width-limit))
						      (let ((sl current-index))
							(loop repeat 3 do
							  (when (>= sl 1)
							    (aset #/. str
								  (setq sl (1- sl)))
							    ))))
						     ))
					      (t (send iostream ':tyo arg1)
						 (setq current-index (1+ current-index)))))
				       (t (send iostream ':tyo arg1)
					  (setq current-index (1+ current-index))))
				 )
				((eq operation :string-out)
				 (destructuring-bind (start end) rest
				   (loop for idx from (or start 0)
						 below (or end (array-active-length arg1))
					 do (box-size-limiting-stream
					      :tyo (aref arg1 idx)))))
				((eq operation ':which-operations)
				 '(:tyo :string-out :which-operations))
				((eq operation :operation-handled-p)
				 (memq arg1 '(:tyo :string-out :which-operations)))
				(t (stream-default-handler #'box-size-limiting-stream
							   operation arg1 rest)))))
		 
		 (*catch 'size-limit-exceeded
		   (if slashify
		       (prin1 name #'box-size-limiting-stream)
		       (princ name #'box-size-limiting-stream))
		   ))
		 )
	     (setf (array-leader str 0) current-index)
	     str
	     )
	))))

;;
;; another FLATSIZE-STREAM variant, for truncate-name
;;
(defun size-limiting-stream (operation &optional arg1 &rest rest)
  (declare (special current-size size-limit iostream))
  (cond ((eq operation ':tyo)
	 (and (fixp size-limit) (>= current-size size-limit) (*throw 'size-limit-exceeded t))
	 (setq current-size (1+ current-size))
	 (send iostream ':tyo arg1))
	((eq operation ':which-operations)
	 '(:tyo :operation-handled-p :which-operations))
	((eq operation ':operation-handled-p)
	 (memq arg1 '(:tyo :operation-handled-p :which-operations)))
	(t (stream-default-handler 'size-limiting-stream operation arg1 rest))))

(defun scroll-menu-to-item (menu item
			    &key
			    (position :center)
			    (optional t))
  (let ((item-row (send menu :item-row item)))
    (when item-row
      (multiple-value-bind (top-row total-rows row-height) (send menu :scroll-position)
	(ignore total-rows)
	(let ((n-rows (// (send menu :inside-height) row-height)))
	  (when (and optional (<= top-row item-row (+ top-row n-rows -1)))
	    (return-from scroll-menu-to-item nil))
	  (send menu :scroll-to
		(selectq position
		  (:top item-row)
		  (:center (max 0 (- item-row (// n-rows 2))))
		  (t (max 0 (- item-row n-rows -1))))
		:absolute))
	))))

;;; add center-items arg, make default style work in absence of menu-setup --lgm 9june89
;;; add grayed-items and grayed-values args to work with geo graying mixins --lgm 28aug89

(defun PREPARE-MENU-FOR-CHOOSE
       (menu 
	&key
	choices
	(item-list choices)
	(label nil)
	(momentary-mode t)
	truncatable
	multiple-choices
	(multiple-choice-items multiple-choices)
	highlighted-items 
	highlighted-values 
	grayed-items
	grayed-values
	menu-setup
	label-setup
	near-mode
	default-item
	(scroll-to-item default-item)
	(scroll-to-position :center)
	(default-style '(2 0 (NIL 0) (:JESS :ROMAN :NORMAL) "JESS13")(:jess :roman :large)0)
	center-label
	(center-items t)
	char-aluf
	erase-aluf

	;; 1geometry parameters
0	geometry				;1actually, an alias for number-of-columns
0	(resize  t)
	number-of-columns
	number-of-rows
	(width  (unless resize (send menu :width)))
	(height  (unless resize (send menu :height)))
	maximum-width
	maximum-height
	mouse-moves-action
	scroll-bar
	(plain-margin-components  *standard-menu-margins-and-labels*)
	(scroll-bar-margin-components  *standard-menu-margins-labels-and-scroll-bars*)
	(columnize-choice-list  t)
	(height-already-used  0)
	)

  (let* ((default-style     (or default-style
				(getf menu-setup :set-default-style)))
	 (superior          (sheet-superior menu))
	 (label-setup       (or label-setup
				(getf menu-setup :set-label)))
	 (center-label      (or center-label
				(getf menu-setup :center-label)
				(and label-setup (getf label-setup :center-label))
				))
	 (geometry          (or geometry (getf menu-setup :set-geometry)))
	 (number-of-columns (or number-of-columns
				(getf menu-setup :set-number-of-columns)))
	 (number-of-rows    (or number-of-rows
				(getf menu-setup :set-number-of-rows)))
	 (width             (or width (getf menu-setup :set-width)))
	 (height            (or height (getf menu-setup :set-height)))
	 (superior-height   (tv:sheet-inside-height superior))
	 (superior-width    (tv:sheet-inside-width superior))
	 (maximum-width     (min superior-width
				 (or maximum-width
				     (getf menu-setup :set-maximum-width)
				     superior-width)))
	 (maximum-height    (min (or maximum-height
				     (getf menu-setup :set-maximum-height)
				     superior-height)
				 (- superior-height
				    height-already-used)))
	 (label-string      (if (listp label)
				(getf label :string label)
				label))
	 (label-specs       (when (and (listp label)(nlistp label-string))
			      (let ((sp (copylist label)))
				(remprop (locf sp) :string)
				sp)))
	 (label-is-instance (instancep label-string))
	 (label             (cond ((listp label-string) label-string)
				  ((when label-is-instance 
				     (send label-string :send-if-handles :dynamic-mouse-name)))
				  ((loop for i in item-list with tmp and tried 
					 when (and (listp i) (listp (cdr i))
						   (setq tmp (get i :agent))
						   (neq tried (setq tried tmp))
						   (setq tmp (send tried :send-if-handles
								   :mouse-agent-name-for
								   label-string)))
					   do (return tmp)
					 finally (setq truncatable t)))
				  ((when label-is-instance
				     (send label-string :send-if-handles :name)
				     ))
				  ((or (stringp label-string)
				       (and (instancep label-string)
					    (operation-handled-p label-string :string-for-printing)))
				   (setq truncatable t) label-string)
				  (t (setq truncatable :slash) label-string)))
	 (*ORDER-MENU-COLUMNWISE* columnize-choice-list)
	 )

    (let-globally (((augment-menu-mixin-set-edges-mode menu) :inhibited))

      (multiple-value-bind (char erase) (send superior :default-inferior-alufs)
	(send menu :set-char-aluf (or char-aluf char))
	(send menu :set-erase-aluf (or erase-aluf erase)))

      (when (listp geometry)
	(when geometry (setq number-of-columns (pop geometry)))
	(when geometry (setq number-of-rows (pop geometry)))
	(when geometry (if width (pop geometry) (setq width (pop geometry))))
	(when geometry (if height (pop geometry) (setq height (pop geometry))))
	(when geometry (setq maximum-width (max 5 (min maximum-width (pop geometry)))))
	(when geometry (setq maximum-height (max 5 (min maximum-height (pop geometry)))))
	(setq geometry nil))

      (send menu :putprop mouse-moves-action :mouse-moves-action)
      (let ((menu-geometry (send menu :geometry)))
	(setf (geometry-n-columns menu-geometry) (or geometry number-of-columns))
	(setf (geometry-n-rows menu-geometry) number-of-rows)
	(setf (geometry-inside-width menu-geometry) width)
	(setf (geometry-inside-height menu-geometry) height)
	(setf (geometry-max-width menu-geometry) (max 5 maximum-width))
	(setf (geometry-max-height menu-geometry) (max 5 maximum-height))
	(set-geometry-centered-columns menu-geometry center-items)
	)

      (set-item-list-quietly menu nil nil nil)

      (and default-style (send menu :set-default-style default-style))

      (send menu :set-momentary-mode momentary-mode)

      (loop for (msg val) on menu-setup by #'cddr
	    unless (memq msg '(:center-label :set-label :set-width :set-height
					     :set-maximum-width :set-maximum-height
					     :set-number-of-rows :set-number-of-columns
					     :set-geometry :set-default-style))
	      do (send menu msg val))

      (when label
	(multiple-value-bind (maxw maxh)
	    (send superior :size-in-characters)
	  (setq label (truncate-name-to-box label (- maxw 4)(- maxh 4)
					 (eq truncatable :slash))))
	(cond ((= (string-length label) 0)
	       (setq label nil))))

      (when label
	(loop for (prop val) on label-setup by #'cddr
	      unless (getf label-specs prop) do (setf (getf label-specs prop) val))
	(unless (getf label-specs :style)
	  (when default-style (setf (getf label-specs :style) default-style)))
	(setq label `(:string ,label ,@label-specs))
	(setf (getf label :centered-p) (getf label :centered-p center-label)))

      (when (loop for i in multiple-choice-items thereis (or (nlistp i)(nlistp (cdr i))))
	1;nastiness when some of the multiple choice items aren't lists.
0	1;we need them to be lists to :special-p can be part of the list
0	(let ((new-items))
	  (setq multiple-choice-items
		(loop for i in multiple-choice-items
		      collect (cond ((nlistp i)
				     (let ((v (list i :value i)))
				       (push (cons i v) new-items)
				       v))
				    ((nlistp (cdr i))
				     (let ((v (list (car i) :value (cdr i))))
				       (push (cons i v) new-items)
				       v))
				    (t i))))
	  (setq highlighted-items
		(loop for i in highlighted-items
		      when (or (nlistp i) (nlistp (cdr i)))
			do (let ((subst (assoc i new-items)))
			     (when subst (setq i (cdr subst))))
		      collect i))))

      (set-item-list-quietly menu item-list
			     multiple-choice-items
			     label))

      (construct-item-list menu)

      (when (and (zerop (send menu :height)) item-list)
	(ferror "Menu items are too tall for the space available"))

      (send menu :send-if-handles :set-margin-components
	    (if (or (send menu :scroll-bar-p) (eq scroll-bar t))
		scroll-bar-margin-components
		plain-margin-components))

    (when (operation-handled-p menu :set-highlighted-items)
      (send menu :set-highlighted-items highlighted-items)
      (when highlighted-values
	(loop for i in highlighted-values do (send menu :add-highlighted-value i)))
      )

    (when (operation-handled-p menu :set-grayed-items)
      (send menu :set-grayed-items grayed-items)
      (when grayed-values
	(loop for i in grayed-values do (send menu :add-grayed-value i)))
      )

    (send menu :set-last-item default-item)

    (when (and scroll-to-item scroll-to-position (send menu :scroll-bar-p))
      (scroll-menu-to-item menu scroll-to-item
			   :optional t
			   :position scroll-to-position))

    (when near-mode
      (expose-window-near menu near-mode)
      (when (and default-item (not (memq (car near-mode) '(:mouse :point))))
	 (multiple-value-bind (x y)
	     (funcall menu :item-cursorpos default-item)
	   (and x y
		(funcall menu ':set-mouse-position (+ x (sheet-inside-left menu))
			 (+ y (sheet-inside-top menu)))))))
    ))

(defmethod (:y-scroll-to augment-menu-mixin) (pos type)
  ;; Truncate POS, because the reference point for a line is its top.
  ;; Don't use ROUND or CEILING.
  ;; The units for :RELATIVE-JUMP are whole lines.
  (if (eq type :relative-jump)
      (send self :scroll-to pos :relative)
      (multiple-value-bind (ignore ignore user-line-height ignore)
	  ;; this is a bit of a crock, to use the "obsolete" method, but
	  ;; the information isn't available from the "real" method, y-scroll-to
	  (send self :scroll-position)
1	;arrange to scroll a minumum of 1 line
0	(when ( 0 pos user-line-height) (setq pos user-line-height))
	(when ( (- user-line-height) pos 0) (setq pos (- user-line-height)))
	(send self :scroll-to (// pos user-line-height) type))))

;;
;; modified version of tv:menu-choose.  It uses a flavor of menu that
;; remembers which button was clicked.
;;
(defun choose-with-menu
       (&rest arglist
	&key
	item-list
	(choices item-list)
	(near-mode '(:mouse))
	(mouse main-mouse)
	(superior (cond ((eq (car near-mode) ':window)
			 (sheet-superior (cadr near-mode)))
			((and mouse (mouse-sheet mouse)))
			(t (tv:mouse-default-superior))))
	(menu-or-resource-type 'augmented-menu)
	(submenu-or-resource-type 'augmented-menu-pane)
	(live-window #'ignore)
	(warp-mouse-back
	  (let ((menu-spec (send live-window :keyword-contexts :choice-list-setup)))
	    (getf menu-spec :mouse-warp)))
	(menu-setup (or (send live-window
			      ':keyword-contexts menu-or-resource-type)
			(send live-window
			      ':keyword-contexts ':menu-setup)))
	(label-setup (send live-window
			   ':keyword-contexts :label-setup))
	(resize (if (typep menu-or-resource-type 'tv:sheet) nil t))
	inhibit-choose 
	&allow-other-keys
	)
  (declare (arglist &key choices multiple-choices label
		    (near-mode '(:mouse))
		    (mouse main-mouse)
		    (superior (if (eq (car near-mode) ':window)
				  (sheet-superior (cadr near-mode))
				  (mouse-default-superior)))
		    (menu-or-resource-type 'augmented-menu)
		    (submenu-or-resource-type 'augmented-command-menu)
		    warp-mouse-back
		    (resize (if (typep menu-or-resource-type 'tv:sheet) nil t))
		    inhibit-choose
		    . #,(cdddr (arglist #'tv:prepare-menu-for-choose))
		    ))
  (dbg:with-default-bug-report-recipient-system ('graphics-support) 
    (let (menu allocated-menus all-menus submenus
	  chosen-value chosen-item final-click chosen-items
	  (screen (sheet-screen superior))
	  (submenu-height 0)
	  (m-s mouse-sheet)
	  (mx tv:mouse-x)
	  (my tv:mouse-y))

      (labels ((allocate-menu (menu-or-resource-type &optional (superior superior))
		 (let ((m (if (typep menu-or-resource-type 'tv:sheet)
			      menu-or-resource-type
			      (multiple-value-bind (m d)
				  (allocate-resource menu-or-resource-type superior)
				(push (list menu-or-resource-type m d) allocated-menus)
				m))))
		   (send m :set-superior superior)
		   (push m all-menus)
		   m)))

	(unwind-protect 
	    (let* ((item-list (copylist choices)))
	      (unless (sheet-me-or-my-kid-p m-s superior)
		(mouse-set-sheet screen))
	      (setq menu (allocate-menu menu-or-resource-type))
	      (incf submenu-height (+ (* 2 (send menu :line-height))
				      (multiple-value-bind (nil h)
					  (send menu :maximum-size)
					(- (send superior :inside-height) h))))
	      (loop for il on item-list
		    as (item) = il
		    when (and (listp item)(listp (cdr item))
			      (eq (second item) :submenu))
		      do
			(let* ((arglist (first item))
			       (submenu (getf arglist :menu))
			       (submenu-flavor
				 (or submenu
				     (getf arglist :menu-flavor-or-resource)
				     submenu-or-resource-type))
			       (menu-setup (getf arglist :menu-setup))
			       (new-menu (allocate-menu submenu-flavor superior)))
			  (push new-menu submenus)
			  (si:with-rem-keywords (arglist arglist '(:menu :menu-setup :mouse))
			    (cl:apply #'prepare-menu-for-choose
				      new-menu
				      :menu-setup `(,@(unless submenu
							`(:set-borders nil))
						    ,@menu-setup)
				      :resize (not submenu)
				      :height-already-used submenu-height
				      arglist))
			  1;allocate with real superior, then change to the
0			  1;intermediate, so calculations based on the size of superior
0			  1;aren't screwed by the arbitrary size of the the main menu.
0			  (send new-menu :set-superior menu)
			  (incf submenu-height (send new-menu :height))
			  (setf (first il) `(,new-menu :no-select ,@(or (cddr item)
									`(:no-select))))
			  ))

	      (si:with-rem-keywords
		(arglist arglist '(:superior :live-window :menu-or-resource-type :choices
					     :submenu-or-resource-type :warp-mouse-back
					     :mouse
					     :live-window :inhibit-choose))
		(cl:apply #'prepare-menu-for-choose menu
			  :item-list item-list
			  :near-mode near-mode
			  :resize resize
			  :menu-setup menu-setup
			  :label-setup label-setup
			  arglist))

	      (unless inhibit-choose
		(multiple-value (chosen-value chosen-item final-click)
		  (funcall menu ':choose)))
	      (setq chosen-items (loop for m in all-menus append (send m :highlighted-values)))
	      )

	  (unless (eq m-s mouse-sheet)
	    (when (eq mouse-sheet screen)
	      (mouse-set-sheet m-s)))

	  (when warp-mouse-back
	    (mouse-warp mx my))
	  (loop for m in submenus do (send m :deactivate))
	  (loop for (typ m d) in allocated-menus
		do (deallocate-resource typ m d)))

	(values chosen-value chosen-item final-click chosen-items)
	))))

(defmacro color:wait-for-vertical-sync ( &body body)
  `(loop for \.i from 1
	 do
	 (without-interrupts
	   (when (send tv:screen :get-vertical-sync-with-timeout)
	     (return (progn . ,body))
	     ))
	 when (= \.i 20)
	 do
	 (setq \.i 1)
	 (fsignal "Can't get vertical-sync for ~A" tv:screen)
	 ))

(defgeneric color:get-special-array (&rest args)
  (:method-arglist  which &optional (base-array (send self :screen-array)))
  (:function (when (and (instancep (first args))
			(operation-handled-p (first args) 'color:get-special-array))
	       (cl:apply (flavor:generic color:get-special-array)
			 args)))
  )

(defflavor DISPLAY-WINDOW-MIXIN ((display-window t)
				 (inhibit-refresh nil))
	   ()
  (:required-flavors tv:window)
  :initable-instance-variables
  :settable-instance-variables)

(defgeneric display-window-p
	    (window &rest args)
  (:method-arglist &key predicate min-bits-per-pixel max-bits-per-pixel)
  (:function
    (declare (arglist window &key predicate min-bits-per-pixel max-bits-per-pixel))
    (when (instancep window)
	       (when (operation-handled-p window 'display-window-p)
		 (cl:apply (flavor:generic display-window-p) window args)))))

(defmethod (:init display-window-mixin :after) (ignore)
  (when (eq inhibit-refresh t)
    (setq inhibit-refresh :except-once)))

(defmethod (display-window-p display-window-mixin)
	   (&key min-bits-per-pixel max-bits-per-pixel predicate)
  (and display-window
       (let ((bpp (send (tv:sheet-screen self) :bits-per-pixel)))
	 (and (if min-bits-per-pixel ( bpp min-bits-per-pixel) t)
	      (if max-bits-per-pixel ( bpp max-bits-per-pixel) t)))
       (if predicate (funcall predicate self) t)))

(defwhopper (:refresh display-window-mixin) (&optional option)
  (when (or (member inhibit-refresh '(nil :except-once))
	    (eq option :override)
	    (eq option :size-changed)
	    (eq :use-old-bits option))
    (continue-whopper (if (eq option :override) :complete-redisplay option))
    (cond ((eq inhibit-refresh :once) (setq inhibit-refresh nil))
	  ((eq inhibit-refresh :except-once) (setq inhibit-refresh t)))
    ))

(defflavor DISPLAY-WINDOW ()
	   (display-window-mixin
	    window)
  (:default-init-plist :blinker-p nil))

(defmethod (:who-line-documentation-string display-window) ()
  "R: Menu of operations on this window")

(defmethod (:make-bitmap-and-permit display-window) ()
  "Use '(:make-bitmap-and-permit) as DEEXPOSED-TYPEOUT-ACTION to create a bitmap on demand"
  (if (null (tv:sheet-bit-array scl:self))
      (progn
	(setf (tv:sheet-output-hold-flag scl:self) 0)
	(scl:send scl:self :set-save-bits t)
	(scl:send scl:self :set-deexposed-typeout-action :permit)
	(scl:send scl:self :refresh :new-bitmap))
      (progn ;;else
	(setf (tv:sheet-output-hold-flag scl:self) 0)
	(scl:send scl:self :set-deexposed-typeout-action :permit)))
  )

(defvar *display-window-item-list* nil)


(eval-when (compile load eval)
(defun def-display-window-operation-internal (name options)
  (setq *display-window-item-list*
	(cl:remove name *display-window-item-list*
		   :test #'(lambda (a b) (string-equal a (car b)))))
  (push `(,name ,@options) *display-window-item-list*)))

(defmacro def-display-window-operation (name &rest options)
  `(def-display-window-operation-internal ',name ',options))

(def-display-window-operation "Erase this Window" :value (:clear-window)
			      :documentation "Erase this window")

(def-display-window-operation "Refresh this window" :value (:refresh :override)
  :documentation "Refresh this window, overriding inhibit-refresh")

(defmethod (:mouse-click display-window) (button x y)
  (ignore x y)
  (when (eq button #\mouse-right)
    (process-run-function "handle click"
      #'(lambda (self)
	  (let ((choice (tv:choose-with-menu
			  :choices (sort (copylist *display-window-item-list*)
					 #'(lambda (a b)(string-lessp (car a)(car b))))
			  :label "Operations on this window")))
	    (cond ((listp choice)
		   (if (keywordp (first choice))
		       (cl:apply self choice)
		       (cl:apply (first choice) self (cdr choice))))
		  ((functionp choice)
		   (funcall choice self)))))
      self)))
		
(tv:add-to-system-menu-create-menu "Display window"
				   'display-window
				   "A window for random display operations")

(compile-flavor-methods tv:display-window)


