;;; -*- Mode: LISP; Syntax: Zetalisp; Base: 10; Package: COLOR -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;>

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD :VERY-LARGE) "BIGFNTB")#||

  Rotation, Filtered Scaling, Copy-to-Quad



(2 0 (NIL 0) (NIL :BOLD :LARGE) "MEDFNTB")Part 1: Simple permutations, without scaling, with simple translations


0Permutations are internally represented by permutation numbers,
which are bit-coded as follows:
   bit 0    exchange x and y
   bit 1    reverse x
   bit 2    reverse y

Normally, these permutation are in "destination normal" form, where the
destination is scanned in raster order, and the source is scanned in some
abnormal order.   

For packed-yuv images, we generate "source normal" permutations, because
it's not possible (or at least not easy) to scan packed-yuv images in 
other than raster order.

1||#
0  
(eval-when (compile load eval)

(defconst(3 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB") permute-image0	(4 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");image process for image permutations
0	  (make-instance 'image-process
			 :main-loop :copy
			 :name :permute
			 :create-on-demand nil
			 :arglist '(width height
					  src sx sy
					  dest dx dy ignore ignore)
			 :key-args '(:permutation :permutation-for-destination)
			 :permitted-args '(:default-alpha)
			 :common-args
			 '(:note-progress "Permuting image")))

(defmacro3 create-permutations0 (&key (compile :return))
  (create-image-processes
    'permute-image
    (loop for permutation from 1 to 7
	  collect
	    `((:fetch :rgba :store :rgba :permutation ,permutation))
	  collect
	    `((:fetch :r+g+b :combine :rgba :store :rgba :permutation ,permutation
		      :default-alpha 255)
	      )
	  collect `((:fetch :yuv-rgb :combine :rgba :store :rgba
			   :permutation-for-destination ,permutation
			   :default-alpha 255))
	  collect
	    `((:fetch :packed-rgb :combine :rgba :store :rgba :permutation ,permutation
		      :default-alpha 255))
	    )
    :prefix "PERMUTATION"
    :compile compile
    ))

 )

(def-image-process 3pixel-copy-r+g+b->rgba0 pixel-copy
  :key-args (:fetch :r+g+b :combine :rgba :store :rgba :default-alpha 255 :write-mask t)
  :extra-keyword-args (to-window)
  (cond (color-microcode-p
	 (destructuring-bind (src-r src-g src-b) src
	   (when default-alpha
	     (let ((tv:bitblt-unpacking-constant (lsh default-alpha 24.))
		   (tv:bitblt-unpacking-mask (or write-mask -1)))
	       (if to-window
		   (when (> 24. (useful-bits-per-pixel to-window))
		     (let ((scr (tv:sheet-screen to-window)))
		       (labels ((screen-bitblt (alu w h src sx sy dest dx dy)
				  (ignore src sx sy)
				  (send scr :%draw-rectangle w h dx dy alu to-window dest)))
			 (ignore src sx sy)
			 (image-process-macro :fetch :ignore :store :rgba
					      :main-loop :bitblt
					      :alu tv:alu-seta
					      :from-field nil :to-field to-field
					      :per-color (:bitblt screen-bitblt)
					      ))))
		   (labels ((image-rectangle (alu w h src sx sy dest dx dy)
			      (ignore src sx sy)
			      (tv:%draw-rectangle-internal w h dx dy alu dest)))
		     (image-process-macro :fetch :ignore :store :rgba
					  :alu (logior %extended-alu %masked-alu tv:alu-seta)
					  :main-loop :bitblt
					  :from-field nil :to-field to-field
					  :per-color (:bitblt image-rectangle))
		     ))))
	   (pixel-copy-rgba->r width height src-r sx sy dest dx dy nil nil
			       :from-field from-field
			       :to-field to-field
			       :write-mask write-mask
			       :to-window to-window)
	   (pixel-copy-rgba->g width height src-g sx sy dest dx dy nil nil
			       :from-field from-field
			       :write-mask write-mask
			       :to-window to-window
			       :to-field to-field)
	   (pixel-copy-rgba->b width height src-b sx sy dest dx dy nil nil
			       :from-field from-field
			       :write-mask write-mask
			       :to-window to-window
			       :to-field to-field)
	   ))
	((and write-mask (not (eql write-mask -1)))
	 (image-process-macro 
	   :fetch :r+g+b :combine :rgba :store :rgba :default-alpha 255
	   :write-mask t))
	(t (image-process-macro 
	     :fetch :r+g+b :combine :rgba :store :rgba :default-alpha 255))))

(remember-image-process
  pixel-copy
  '(:fetch :r+g+b :combine :rgba :store :rgba :default-alpha 255)
  '(:fetch :r+g+b :combine :rgba :store :rgba :default-alpha 255 :write-mask t))

(remember-image-process
  pixel-copy
  '(:fetch :r+g+b :combine :rgba :store :rgba :default-alpha 255 :dither t :jitter t
	   :write-mask t)
  '(:fetch :r+g+b :combine :rgba :store :rgba :default-alpha 255 :write-mask t))

(remember-image-process
  pixel-copy
  '(:fetch :r+g+b :combine :rgba :store :rgba :default-alpha 255 :dither t 
	   :write-mask t)
  '(:fetch :r+g+b :combine :rgba :store :rgba :default-alpha 255 :write-mask t))

(remember-image-process
  pixel-copy
  '(:fetch :r+g+b :combine :rgba :store :rgba :default-alpha 255 :dither t)
  '(:fetch :r+g+b :combine :rgba :store :rgba :default-alpha 255))

(remember-image-process
  pixel-copy
  '(:fetch :r+g+b :combine :rgba :store :rgba :default-alpha 255 :dither t :jitter t)
  '(:fetch :r+g+b :combine :rgba :store :rgba :default-alpha 255))


(def-image-process 3pixel-copy-packed-rgb->rgba 0pixel-copy
  :key-args (:fetch :packed-rgb :combine :rgba :store :rgba :default-alpha 255))



(3create-permutations0 :compile :defer)

(remember-image-process permute-image  ;rotate 0
			'(:fetch :packed-rgb :combine :rgba :store :rgba :permutation 0 :default-alpha 255)
			`(:fetch :packed-rgb :combine :rgba :store :rgba :default-alpha 255)
			pixel-copy)

(remember-image-process
  permute-image					;rotate 0
  '(:fetch :r+g+b :combine :rgba :store :rgba :permutation 0 :default-alpha 255)
  `(:fetch :r+g+b :combine :rgba :store :rgba :default-alpha 255)
  pixel-copy)

(remember-image-process
  permute-image					;rotate 0
  '(:fetch :r+g+b :combine :rgba :store :rgba :permutation 0 :default-alpha 255)
  `(:fetch :r+g+b :combine :rgba :store :rgba :default-alpha 255)
  pixel-copy)


(remember-image-process permute-image  ;rotate 0
			'(:fetch :rgba :store :rgba :permutation 0)
			`(:fetch :rgba :store :rgba)
			pixel-copy)

(defun 3permute-raster0 (src sx sy dest dx dy s-width s-height
		       &rest other-args
		       &key x-flip y-flip xy-flip (rotate 0) (permutation 0)
		       (source-image-type (default-image-type src))
		       (dest-image-type (default-image-type dest))
		       from-field to-field per-line-function
		       &allow-other-keys
		       )
  ;;
  ;; Minimal user interface to permuting an image.
  ;; SRC and DEST are rasters, or RGB lists of rasters 
  ;; source is scaled and rotated as specified by X-FLIP Y-FLIP ROTATE and XY-FLIP
  ;; Dest must be large enough for the result.
  ;; If source = dest, you are likely to get something strange.
  ;; rotate is degrees counter clockwise, or alternatively quarter turns counter clockwise
  ;;
  (let* ((s-type (or source-image-type (default-image-type src)))
	 (d-type (or dest-image-type (default-image-type dest)))
	 (perm0 (logxor (+ (if y-flip 4 0)
			   (if x-flip 2 0)
			   (if xy-flip 1 0))
			(cl:ecase rotate
			  ((0 -360 360) 0)
			  ((1 -270 90) 5)
			  ((2 -180 180) 6)
			  ((3 -90 270) 3))
			permutation
			)))
    (cond ((and (eq s-type 'packed-yuv-image)
		(eq d-type 'packed-yuv-image)
		(not (member perm0 '(0 4))))
	   4;big problem.  Both formats require abnormal raster patterns0.
	   (with-stack-list (dims (if from-field (ceiling s-height 2) s-height)
				  (* s-width 3))
	     (tv:with-temp-sheet-raster (temp-rgb dims :type 'art-8b)
	       (permute-raster src sx sy temp-rgb 0 0 s-width s-height
			       :source-image-type 'packed-yuv-image
			       :dest-image-type 'packed-rgb-image
			       :from-field from-field)
	       (cl:apply #'permute-raster temp-rgb 0 0 dest dx dy
			       s-width s-height
			       :source-image-type 'packed-rgb-image
			       :dest-image-type 'packed-yuv-image
			       :per-line-function per-line-function
			       :permutation perm0
			       :from-field nil
			       :to-field to-field
			       other-args
			       ))))

	  (t (si:with-rem-keywords (args other-args
					 '(:from-field :to-field :per-line-function
						       :source-image-type :dest-image-type
						       :x-flip :y-flip :xy-flip :rotate
						       :permutation))
	       (let* ((perm (if (neq s-type 'packed-yuv-image)
				perm0
				(cdr (assoc perm0 '((0 . 0)(3 . 5)(5 . 3)(6 . 6)
						    (1 . 1)(2 . 2)(4 . 4)(7 . 7))))))
		      (perm-spec-key  (list s-type d-type :select nil nil))
		      (perm-spec (or (gethash perm-spec-key rescale-image-specs)
				     (ferror "~A missing from rescale-image-specs"
					     perm-spec-key)))
		      (ip (or (when (eql perm 0)
				(find-image-process pixel-copy perm-spec
						    :create-p nil :error-p nil))
			      (find-image-process
				permute-image 
				(append perm-spec
					`(:mask nil
					  ,@(if (eq source-image-type 'packed-yuv-image)
						`(:permutation-for-destination ,perm)
						`(:permutation ,perm))))
				:create-p t :error-p t)))
		      (ip-args (image-process-accepts-other-args ip args)))

		 (cl:apply (compiled-function ip)
			s-width s-height
			src sx sy
			dest dx dy
			nil nil
			:from-field from-field
			:to-field to-field
			:per-line-function per-line-function
			ip-args
			)
		 ))))))

#||
(IMAGE-PROCESS-MACRO :FETCH
		     :PACKED-RGB
		     :COMBINE
		     :RGBA
		     :STORE
		     :RGBA
		     :DEFAULT-ALPHA
		     255
		     :PERMUTATION
		     6
		     :PERMITTED-ARGS
		     (:FETCH :PACKED-RGB :COMBINE :RGBA :STORE :RGBA :DEFAULT-ALPHA 255)
		     :ARGLIST (WIDTH HEIGHT SRC SX SY DEST DX DY IGNORE IGNORE)
		     :IGNORED-ARGS NIL :MAIN-LOOP :COPY :NOTE-PROGRESS
		     "Permuting image"
		     )

||#
4


2#||


Part 2:   Machinery for the scaling, based on a perspective
matrix transformation.

0 The transform matrix is assumed to be...
	[a e m]
	[b f n]
	[d h p]

 A is X-scale   B is X-skew  D is X-translation
 F is Y-scale   E is Y-skew  H is Y-translation
 P is overall scale
 M is X scale as a function of Y
 N is Y scale as a function of X
 
 The source coord is always [u v 1].

 The basic technique implemented here is described in 1975 Siggraph proceedings,
43-D Transformations of images in scanline order0 by Ed Catmull and Alvy Ray Smith.
P. 279


2||#

0(defflavor 3catmull-transformation
0	4;;
0	4;; There's so much information necessary to hack these transformations,
0	4;; we build them into an instance and use flavors and methods to keep
0	4;; the world straight.
0	4;;
0	(source-height source-width
		       ;source width and height are characteristic of the transformation


	 intermediate-first-offset 
	               ;offset we optimize out of the intermediate-array

         intermediate-width intermediate-height
	 	       ; intermeidate width and height are either the same
	 	       ; as source width and height, or exchanged.  

	 intermediate-array-width
		       ; intermediate-array-width is the intermediate-width transformed
	 	       ; to determine the size of the intermediate array, plus a pixel
		       ; margin so end-of-line boundary conditions don't screw us.
	 intermediate-array-height

	 (source-y-major nil)   ;major source directions.  We decide these based on
	 (source-x-reverse nil)   ;the matric parameters.
	 (source-y-reverse nil)
	 (source-permutation 0) ;the standard encoding of the three above

	 read-scan-line	;permutation function to transfer bits from the source to
	 		;the scanline buffer.
	 (first-pass)	;function to perform pass 1
	 (second-pass)  ;function to perform pass 2
	 (first-pass-ip)
	 (second-pass-ip)

	 (first-pass-spec)
	 (second-pass-spec)
	 (first-pass-other-args)
	 (second-pass-other-args)
	 (first-pass-copy-other-args)
	 (second-pass-copy-other-args)

	 first-start-coordinate	;top-left corner used in the intermediate array
	 last-start-coordinate  ;bottom-left corner used in the intermediate array
	 first-end-coordinate    ;top-right corner used in the intermediate array
	 last-end-coordinate ;bottom-right corner used in the intermediate array

	 (scan-line-buffer)   ;the current scan line, plus margin pixels
	 (first-pass-start-array)  ;active left margin
	 (first-pass-end-array) ;active right margin
	 (intermediate-array) ;the intermediate pass
	 (intermediate-array-left 0)
	 (intermediate-array-top 0)
	 (displaced-intermediate-array)  ;hack for debugging.  Pass in a window screen array

	 dx0 dy0	;; the originally specified corners of the transformation
	 dx1 dy1
	 dx2 dy2
	 dx3 dy3
	 ;;
	 ;; these are intermediates used by the active transformation.
	 ;; in the final version, they should be lexicals.
	 ;;
	 source
	 (source-image-type)

	 source-x
	 source-y

	 dest
	 (dest-image-type)
	 dest-x
	 dest-y
	 (write-mask)
	 (intermediate-array-type)
	 (read-array-type)

	 bias-x  ;bias applied to the intermediate array to make it fit compactly
	 bias-y

	 last-top-edge    ;used tracking the pass 1 edges in pass 2
	 last-bottom-edge

	 (matrix nil)           ;the raw transformation matrix
	 a b d e f h m n p      ;matrix parameters
	 			;zero or negative, the interpolation loses.
	 (speed) 
	 (quad-type)
	 (floating-point-slop 0.0001)
	 (rescale-in-place-on-intermediate)
	 )
	()
  (:conc-name catmull-)
  :writable-instance-variables)

(defmethod (image-process-specs catmull-transformation) ()
  (values first-pass-spec second-pass-spec))

4;;
;; compile-time code to generate a list of the catmull functions we will need.
0(defconst 3catmull-transformation
0	  (make-instance 'image-process		;
			 :main-loop :catmull
			 :method-of 'catmull-transformation
			 :name :catmull-transformation
			 :arglist '(width height src sx sy dest dx dy)
			 :key-args '(:catmull-speed :catmull-pass :dither :jitter)
			 :permitted-args  '(:threshold :brightness :default-alpha
				           :black-pixel :white-pixel
					   :combination-array :combination-name
					   :translation-array :translation-name)
			 :common-args
			 `(:note-progress "Catmull3 0Transformation"
			   :before-per-color bartlet-filter-before-per-color
			   :per-color bartlet-filter-per-color
			   :locals-per-color (prev sum diff next-sum)
			   :store-local-per-color sum
			   )))

4;;
;; Some matrices we use.
;;
0(defconst rotate-90 (make-array '(4 4)))
(si:fillarray rotate-90 '(0 1 0 0  -1 0 0 0  0 0 1 0  0 0 0 1))

(defconst flip-x (make-array '(4 4)))
(si:fillarray flip-x '(-1 0 0 0  0 1 0 0  0 0 1 0  0 0 0 1))

(defconst flip-y (make-array '(4 4)))
(si:fillarray flip-y '(1 0 0 0  0 -1 0 0  0 0 1 0  0 0 0 1))


(defmethod (3transformation-matrix0 catmull-transformation) (&optional mat)
4  ;patch the matrix elements into a real array, so standard tools can
0  4;manipulate it.
0  (let ((mat (or mat matrix (setq matrix (make-array '(4 4) )))))

    (setf (raster-aref mat 0 0) a)
    (setf (raster-aref mat 0 1) b)
    (setf (raster-aref mat 0 2) 0) ;c
    (setf (raster-aref mat 0 3) d)

    (setf (raster-aref mat 1 0) e)
    (setf (raster-aref mat 1 1) f)
    (setf (raster-aref mat 1 2) 0) ;g
    (setf (raster-aref mat 1 3) h)

    (setf (raster-aref mat 2 0) 0)
    (setf (raster-aref mat 2 1) 0)
    (setf (raster-aref mat 2 2) 1) ;keeps the matrix nonsingular
    (setf (raster-aref mat 2 3) 0)

    (setf (raster-aref mat 3 0) m)
    (setf (raster-aref mat 3 1) n)
    (setf (raster-aref mat 3 2) 0) ;o
    (setf (raster-aref mat 3 3) p)
    mat))

(defmethod ((3cl:setf transformation-matrix0) catmull-transformation) (new)
  4;unpack
0  (unless matrix (setq matrix (make-array '(4 4) )))
  (let ((mat new))
    (setf a (raster-aref mat 0 0))
    (setf b (raster-aref mat 0 1))
    (setf d (raster-aref mat 0 3))

    (setf e (raster-aref mat 1 0))
    (setf f (raster-aref mat 1 1))
    (setf h (raster-aref mat 1 3))

    (setf m (raster-aref mat 3 0))
    (setf n (raster-aref mat 3 1))
    (setf p (raster-aref mat 3 3))
    (transformation-matrix self)))

(defmethod (3create-buffers0 catmull-transformation) ()
  4;create the intermediate storage we use.  This includes
0  4;some arrays consed on the data stack, so the caller
0  4;must have done WITH-DATA-STACK.
0  4;
0  (let ((round-to (// 32 (or (cdr (assoc read-array-type array-bits-per-element))
			     32))))
    (with-stack-list (scan-line-dims
		       1
		       (* (ceiling (+ 2 intermediate-width) round-to) round-to))
      (setq scan-line-buffer
	    (make-stack-array scan-line-dims :type read-array-type))))

  (setq first-pass-start-array (make-stack-array intermediate-array-height :type 'art-q)
	first-pass-end-array (make-stack-array intermediate-array-height :type 'art-q))

  (unless displaced-intermediate-array
    (setq intermediate-array-left 0
	  intermediate-array-top 0))

  (with-stack-list (dims (+ 2 (max intermediate-height
				   (if rescale-in-place-on-intermediate
				       (- (1+ (floor (max dy0 dy1 dy2 dy3)))
					  (1- (ceiling (min dy0 dy1 dy2 dy3))))
				       0)
				   )
			    intermediate-array-top)
			 (tv:raster-width-for-bitblt
			   (+ 2 (max intermediate-array-width
				     (if rescale-in-place-on-intermediate
					 source-width
					 0)
				     )
			      intermediate-array-left)
			   intermediate-array-type
			   ))
    (setq intermediate-array
	  (tv:allocate-temp-sheet-raster-and-header
	    dims :type intermediate-array-type
	    :displaced-conformally (and displaced-intermediate-array
					(= (array-#-dims displaced-intermediate-array)
					   2))
	    :initial-value 0
	    :displaced-to displaced-intermediate-array
	    ))
    (when displaced-intermediate-array
      (tv:%draw-rectangle (+ 1 intermediate-array-width) (+ 1 intermediate-height)
			  intermediate-array-left intermediate-array-top
			  tv:alu-setz intermediate-array)
      )
    ))

(defmethod (3discard-buffers0 catmull-transformation) ()
  (tv:deallocate-temp-sheet-raster-and-header intermediate-array)
  (setq first-pass-end-array nil
	first-pass-start-array nil
	intermediate-array nil
	scan-line-buffer nil)
  )



4;;
;; Coordinate transformations, utilities and the like.
;;

0(defmethod (3spill0 catmull-transformation) (&optional (message "") &rest args)
  (format t 3"~2&~?~&X* ~4f Y// ~4f    ~4f~&X// ~4f  Y* ~4f   ~4d~&dX   ~4f  dY ~4f  ** ~4f~&~A0~3A~A"
0	  message args a e m b f n d h p
	  (if source-y-major "Source XY swap " "")
	  (if source-x-reverse "Source X reverse " "")
	  (if source-y-reverse "Source Y reverse " "")))

(defmethod (3raw-xform0 catmull-transformation) (u v)
  4;returns the raw transformation of U,V.  This maps intermediate array
0  4;coordinates to raw destination coordinates
0  (let ((div (+ (* m u) (* n v) p)))
    (values (// (+ (* a u) (* b v) d)
		div)
	    (// (+ (* e u) (* f v) h)
		div))))

(defmethod (3biased-xform0 catmull-transformation) (u v)
4  ;returns the transformation og U,V, including the bias
0  4;to the originally specified destination.  This maps
0  4;intermediate array coordinates to destination array coordinates.
0  (values (- (// (+ (* a u) (* b v) d)
			(+ (* m u) (* n v) p))
	     bias-x)
	  (- (// (+ (* e u) (* f v) h)
			(+ (* m u) (* n v) p))
	     bias-y)))

(defmethod (3permuted-xform0 catmull-transformation) (u v &optional (bias t))
  ;4returns the transformation of U,V, from source to final destination.
0  (when source-y-major (swapf u v))
  (when source-x-reverse (setq u (- intermediate-width u)))
  (when source-y-reverse (setq v (- intermediate-height v)))
  (funcall (if bias #'biased-xform #'raw-xform) self u v))

(defmethod (3raw-bounding-box0 catmull-transformation) ()
  (multiple-value-bind (x1 y1) (raw-xform self 0 0)
    (multiple-value-bind (x2 y2) (raw-xform self source-width 0)
      (multiple-value-bind (x3 y3) (raw-xform self 0 source-height)
	(multiple-value-bind (x4 y4) (raw-xform self source-width source-height)
	  (values (min x1 x2 x3 x4) (min y1 y2 y3 y4)
		  (max x1 x2 x3 x4) (max y1 y2 y3 y4)))))))

(defmethod (3draw-transformed-box0 catmull-transformation)
	   (window dx dy &optional (alu tv:alu-xor))
4  ;debuggging utility
0  (multiple-value-bind (x1 y1) (biased-xform self 0 0)
    (multiple-value-bind (x2 y2) (biased-xform self intermediate-width 0)
      (multiple-value-bind (x3 y3) (biased-xform self intermediate-width intermediate-height)
	(multiple-value-bind (x4 y4)  (biased-xform self 0 intermediate-height)
	  (send window :draw-lines alu
		(round (+ x1 dx)) (round (+ y1 dy))
		(round (+ x2 dx)) (round (+ y2 dy))
		(round (+ x3 dx)) (round (+ y3 dy))
		(round (+ x4 dx)) (round (+ y4 dy))
		(round (+ x1 dx)) (round (+ y1 dy))
		))))))

(defmethod (3draw-specd-box0 catmull-transformation) (window dx dy &optional (alu tv:alu-xor))
4  ;debugging utility
0  (send window :draw-lines alu
	(round (- (+ dx0 dx) bias-x)) (round (- (+ dy0 dy) bias-y))
	(round (- (+ dx1 dx) bias-x)) (round (- (+ dy1 dy) bias-y))
	(round (- (+ dx2 dx) bias-x)) (round (- (+ dy2 dy) bias-y))
	(round (- (+ dx3 dx) bias-x)) (round (- (+ dy3 dy) bias-y))
	(round (- (+ dx0 dx) bias-x)) (round (- (+ dy0 dy) bias-y))
	))

(defmethod (3raw-box0 catmull-transformation) (&optional (bias t))
  (values (multiple-value-list (permuted-xform self 0 0 bias))
	  (multiple-value-list (permuted-xform self source-width 0 bias))
	  (multiple-value-list (permuted-xform self source-width source-height bias))
	  (multiple-value-list (permuted-xform self 0 source-height bias))))

(defmethod (3specified-bounding-box0 catmull-transformation) ()
  (values (min dx0 dx1 dx2 dx3 )(min dy0 dy1 dy2 dy3 )
	  (max dx0 dx1 dx2 dx3 ) (max dy0 dy1 dy2 dy3 )))



2;;
;; Setup the transformation from a reasonable specification.
;; 
;; We support two modes: "Rotation", which include scaling and skewing
;; and the completely general "Copy-to-quad"
;;

0(defun 3scaled-and-rotated-points
0       (degrees-counter-clockwise points &key
	(scale 1)
	(scale-x 1)
	(scale-y 1)
	(transpose-xy nil)
	(center-x 0)
	(center-y 0)
	)

  (unless scale (setq scale 1))
  (unless scale-x (setq scale-x 1))
  (unless scale-y (setq scale-y 1))

  (let ((cos (cosd degrees-counter-clockwise))
	(sin (sind degrees-counter-clockwise)))
    (loop for (x y) on points by #'cddr
	  as xx = (* scale (+ (* cos scale-x (- x center-x))
			   (* sin scale-y (- y center-y))))
	  as yy = (* scale (- (* cos scale-y (- y center-y))
			   (* sin scale-x (- x center-x))))
	  nconc (if transpose-xy `(,yy ,xx) `(,xx ,yy)))))


(defmethod (3setup-rotation0 catmull-transformation)
	   (=width =height degrees-counter-clockwise
		   &key
		   (scale 1)
		   (scale-x 1)
		   (scale-y 1)
		   (transpose-xy nil)
		   (center-x (// =width 2))
		   (center-y (// =height 2))
		   (user:source-permutation 0)
		   (slop 0.0001)
		   )
  (with-stack-list (points 0 0 =width 0 =width =height 0 =height)
    (destructuring-bind (x0 y0 x1 y1 x2 y2 x3 y3)
	(scaled-and-rotated-points
	  degrees-counter-clockwise
	  points
	  :center-x center-x
	  :center-y center-y
	  :transpose-xy transpose-xy
	  :scale-x scale-x
	  :scale-y scale-y
	  :scale scale)
      (setup-copy-to-quad
	self
	=width =height

	x0 y0 x1 y1 x2 y2 x3 y3

	:m=0 t ;these say damn the round off, this is a non-twisting transformation!
	:n=0 t
	:slop slop
	:source-permutation user:source-permutation)
    )))


;;;  Quad corners spec'd in clockwise order from upper left.
;;;  These equations courtesy of Kevin Hunter and Paul Heckbert.
;;;  Who spent all night farting around with Macsyma.  And finally
;;;  had to do them by hand.  Aren't computers fun??
(defmethod (3setup-copy-to-quad0 catmull-transformation)
	   (wid hi ix0 iy0 ix1 iy1 ix2 iy2 ix3 iy3
		&key m=0 n=0 (user:source-permutation 0)
		(slop 0.0001))
  (setq dx0 ix0					;remember the corners
	dy0 iy0
	dx1 ix1
	dy1 iy1
	dx2 ix2
	dy2 iy2
	dx3 ix3
	dy3 iy3
	source-permutation user:source-permutation
	floating-point-slop slop)
  (setq wid (max wid 2)
	hi (max hi 2))

  (normalize-specified-bounding-box self)

  (let* ((t1 (float (- dx1 dx0 )))
	 (t2 (float (- dx2 dx3 )))
	 (t3 (float (- dx2 dx1 )))
	 (t4 (float (- dx0 dx3 )))
	 (t5 (float (- dx3 dx1 )))
	 (t6 (float (- dx2 dx0 )))
	 ( (- (* t3 dy3) (* t5 dy2) (* t2 dy1)))
	 (invwid (// (float wid)))
	 (invhi (// (float hi)))
	 (=a (+ (* T1 (- (* dx2 dy3) (* dx3 dy2))) (* t2 (- (* dx0 dy1) (* dy0 dx1)))))
	 (=b (+ (* t3 (- (* dx3 dy0) (* dx0 dy3))) (* t4 (- (* dx2 dy1) (* dx1 dy2)))))
	 (=d (* dx0 ))
	 (=e (+ (* dy3 (- (* t6 dy1) (* t3 dy0))) (* dy2 (+ (* t4 dy1) (* t5 dy0)))))
	 (=f (+ (* dy3 (- (* t1 dy2) (* t6 dy1))) (* dy0 (+ (* t5 dy2) (* t2 dy1)))))
	 (=h (* dy0 ))
	 (=m (+ (* (- dy3 dy2) t1) (* (- dy1 dy0) t2)))
	 (=n (+ (* (- dy0 dy3) t3) (* (- dy1 dy2) t4))))

    (setq p  
	  a (* =a invwid)
	  b (* =b invhi)
	  d =d
	  e (* =e invwid)
	  f (* =f invhi)
	  h =h
	  m (if m=0 0.0 (* invwid =m))
	  n (if n=0 0.0 (* invhi =n))
	  source-width wid
	  source-height hi)

    (normalize-transformation self)
    )
  )

(defmethod (3normalize-specified-bounding-box0 catmull-transformation) ()
  4;;
0  4;; the SECOND-PASS and FIRST-PASS both expect the coordinates to be positive. To
  ;; make sure they aren't disappointed, we translate the coordinates to
  ;; the X+ Y+ quadrant.  
0  4;;
0  (multiple-value-bind (dx dy) (specified-bounding-box self)
    (setq bias-x (+ 100 (ceiling (- dx)))
	  bias-y (+ 100 (ceiling (- dy)))
	  dx0 (+ dx0 bias-x)
	  dx1 (+ dx1 bias-x)
	  dx2 (+ dx2 bias-x)
	  dx3 (+ dx3 bias-x)
	  dy0 (+ dy0 bias-y)
	  dy1 (+ dy1 bias-y)
	  dy2 (+ dy2 bias-y)
	  dy3 (+ dy3 bias-y))))


(defmethod (3dx-is-positive-p0 catmull-transformation) ()
  (plusp (- (raw-xform self (if source-y-major source-height source-width) 0)
	    (raw-xform self 0 0))))

(defmethod (3make-dx-positive0 catmull-transformation) ()
  (unless (dx-is-positive-p self)
    (let* ((old (transformation-matrix self)))
      (letf (((raster-aref flip-x 0 3)
	      (if source-y-major source-height source-width)))
	(math:multiply-matrices flip-x old old))
      (setf (transformation-matrix self)
	    old)
      )
    (setq source-x-reverse (not source-x-reverse))
    ))

(defmethod (3dy-is-positive-p0 catmull-transformation) ()
  (multiple-value-bind (x1 y1) (raw-xform self 0 0)
    (multiple-value-bind (x2 y2)
	(raw-xform self 0 (if source-y-major source-width source-height))
      (multiple-value-bind (x3 y3)
	  (raw-xform self (if source-y-major source-height source-width) 0)
	(funcall (if (dx-is-positive-p self) #'minusp #'plusp)
		 (- (* (- x1 x2) (- y1 y3)) (* (- y1 y2) (- x1 x3)))))))
  )
	  
(defmethod (3make-dy-positive0 catmull-transformation) ()
  (unless (dy-is-positive-p self) ;when this is a clockwise triangle
    (let* ((old (transformation-matrix self)))
      (setf (raster-aref flip-y 1 3)
	    (if source-y-major source-width source-height))
      (math:multiply-matrices flip-y old old)
      (setf (transformation-matrix self)
	    old))
    (setq source-y-reverse (not source-y-reverse))
    )
  )

(defmethod (3must-not-be-flipped-p0 catmull-transformation) ()
  4;; in Y-major mode, we track edges: x0,y0-x1,y1 and x3,y3-x2,y2
0  4;; if these intersect we have to do vertical first or else not flip
0  (xform-must-not-be-flipped-p dx0 dx1 dx2 dx3)
  )

(defun 3xform-must-not-be-flipped-p0 (dx0 dx1 dx2 dx3)
  (or (and ( dx0 dx3 dx1) ( dx0 dx2 dx1))
      (and ( dx1 dx3 dx0) ( dx1 dx2 dx0))
      (and ( dx3 dx0 dx2) ( dx3 dx1 dx2))
      (and ( dx2 dx0 dx3) ( dx2 dx1 dx3))))

(defmethod (3must-be-flipped-p0 catmull-transformation) ()
4  ;; in X-major mode, we track edges: x0,y0-x3-y3 and x1,y1-x2,y2
0  (xform-must-be-flipped-p dx0 dx1 dx2 dx3)
  )

(defun 3xform-must-be-flipped-p0 (dx0 dx1 dx2 dx3)
  (or (and ( dx0 dx1 dx3) ( dx0 dx2 dx3))
      (and ( dx0 dx1 dx3) ( dx0 dx2 dx3))
      (and ( dx1 dx0 dx2) ( dx1 dx0 dx2))
      (and ( dx1 dx0 dx2) ( dx1 dx0 dx2))
      ))

#|| old version
(defmethod (3rotate-source-p0 catmull-transformation) ()

4    ;;Determine the scan direction.  The edges we are tracking are 
    ;; in X-major mode: x0,y0-x3-y3 and x1,y1-x2-y2
0    4;; in Y-major mode: x0,y0-x1,y1 and x3-y3-x2-y2
    ;; if these lines cross, do the first pass in Y-order
0    4;;
0  (let* ((top-dy (abs (+ (- dy1 dy0) (- dy2 dy3))))
	 (top-dx (abs (+ (- dx1 dx0) (- dx2 dx3))))
	 (prefer-to-flip (> (* top-dy source-width) (* top-dx source-height))))
  (cond ((must-be-flipped-p self)
	 t)
	((must-not-be-flipped-p self)
	 nil)
	(t prefer-to-flip)
	)))||#

(defvar 3*invert-catmul-flip-preference*0 nil)

(defun 3triangle-area0 (x1 y1 x2 y2 x3 y3)
  (let ((det (- (* (- x1 x2) (- y1 y3))
		(* (- x1 x3) (- y1 y2))))  )
    (abs (// det 2.0))
    ))
(defun 3quad-area0 (x1 y1 x2 y2 x3 y3 x4 y4)
  (+ (triangle-area x1 y1 x2 y2 x3 y3)
     (triangle-area x3 y3 x4 y4 x1 y1))
  )
;patch
(defvar 3*expand-penalty*0 (list 1.0 ;pass1 expand
			       -2.0 ;pass1 shrink
			       1.0 ;pass2 expand
			       -0.25 ;pass2 shrink
			       ))

;patch
(defmethod (3rotate-source-p0 catmull-transformation) ()
  ;;
4    ;;Determine the scan direction.  The edges we are tracking are 
    ;; in X-major mode: x0,y0-x3-y3 and x1,y1-x2-y2
0    4;; in Y-major mode: x0,y0-x1,y1 and x3-y3-x2-y2
    ;; if these lines cross, do the first pass in Y-order
0    4;;

0  (cond ((must-be-flipped-p self) t)
	((must-not-be-flipped-p self) nil)
	(t 
4	 ;the option play.  Unfortunately, there isn't any firm guidepost if we
	 ;should flip or not.  The old version of this tried to maximize the area
	 ;of the intermediate, but it turned out that for very rectangular images,
	 ;we decided to rotate prematurely, and ended up with some grossly distorted
	 ;results.  This version tries to make an intermediate whose size ratio to
	 ;the original is as close to 1.0 as possible, that is, an intermediate with
	 ;minimal total distortion
	 ;
0	 (let* ((source-area (* source-width source-height))
		(dest-area (quad-area dx0 dy0 dx1 dy1 dx2 dy2 dx3 dy3))
		(normal-intermediate-area
		  (quad-area dx0 0 dx1 0 dx2 source-height dx3 source-height))
		(flipped-intermediate-area
		  (quad-area dx1 0 dx2 0 dx3 source-width dx0 source-width))
		(pass1-normal-ratio (// normal-intermediate-area source-area))
		(pass2-normal-ratio (// dest-area normal-intermediate-area))
		(pass1-flipped-ratio (// flipped-intermediate-area source-area))
		(pass2-flipped-ratio (// dest-area flipped-intermediate-area))
		(pass1-normal-skew (// (abs (- (+ dx0 dx1)(+ dx2 dx3))) source-height))
		(pass1-flipped-skew (// (abs (- (+ dx1 dx2)(+ dx3 dx0))) source-width))
		(pass1-normal-distortion (if (> pass1-normal-ratio 1.0)
					    (* (first *expand-penalty*) pass1-normal-ratio)
					    (* (second *expand-penalty*)
					       (// pass1-normal-ratio))))
		(pass2-normal-distortion (if (> pass2-normal-ratio 1.0)
					      (* (third *expand-penalty*)
						 pass2-normal-ratio)
					      (* (fourth *expand-penalty*)
						 (// pass2-normal-ratio))))
		(pass1-flipped-distortion (if (> pass1-flipped-ratio 1.0)
					    (* (first *expand-penalty*)
					       pass1-flipped-ratio)
					    (* (second *expand-penalty*)
					       (// pass1-flipped-ratio))))
		(pass2-flipped-distortion (if (> pass2-flipped-ratio 1.0)
					      (* (third *expand-penalty*)
						 pass2-flipped-ratio)
					      (* (fourth *expand-penalty*)
						 (// pass2-flipped-ratio))))

		(flipped-distortion
		  (* (1+ pass1-flipped-skew)
		     (abs (- pass1-flipped-distortion pass2-flipped-distortion)))
		     )

		(normal-distortion
		  (* (1+ pass1-normal-skew)
		     (abs (- pass1-normal-distortion pass2-normal-distortion))))

		(prefer-to-flip (< flipped-distortion normal-distortion))
		(flip (if *invert-catmul-flip-preference*
			  (not prefer-to-flip)
			  prefer-to-flip))
		)


	   #||
	   (format t "~&~%s-size ~A d-size ~A normal-i-size ~A flipped-i-size ~A~&~
 			p1-skew ~4f p1-normal ~A(~A) p2-normal ~A(~A) normal ~A~&~
 			p1-flipped-skew ~4f p1-flipped ~A(~A) p2-flipped ~A(~A) flipped ~A~&~
prefer-to-flip ~A  flip ~A"
		   source-area dest-area normal-intermediate-area flipped-intermediate-area

		   pass1-normal-skew pass1-normal-distortion pass1-normal-ratio
		   pass2-normal-distortion pass2-normal-ratio normal-distortion

		   pass1-flipped-skew pass1-flipped-distortion pass1-flipped-ratio
		   pass2-flipped-distortion pass2-flipped-ratio flipped-distortion 

		   prefer-to-flip flip)
	   (send paint:pc :draw-lines tv:alu-seta
		 (+ 100 dx1) 0
		 (+ 100 dx2) 0
		 (+ 100 dx3) source-width
		 (+ 100 dx0) source-width
		 (+ 100 dx1) 0
		 )
	   (send paint:pc :draw-lines tv:alu-seta
		 dx0 (+ 0 100)
		 dx1 (+ 0 100)
		 dx2 (+ 100 source-height)
		 dx3 (+ 100 source-height)
		 dx0 (+ 0 100)
		 )
	   
	   
	   ||#
	   flip 
	   ))))

(defmethod (3rotate-source-if-appropriate0 catmull-transformation) ()
  (when (rotate-source-p self)
      (let* ((old (transformation-matrix self)))
	(letf (((raster-aref rotate-90 0 3)
		(if source-y-major source-height source-width)))
	  (math:multiply-matrices rotate-90 old old))
	(setf (transformation-matrix self)
	      old))
      (setq source-y-major (not source-y-major))
      (psetq source-y-reverse (not source-x-reverse)
	     source-x-reverse source-y-reverse)
      )
    )

(defun3 classify-quadralateral0 (&key (slop 0.0001) quad)
  4;;
0  4;; Classify the quadralateral as it is interesting to
0  4;; the catmull transformation.  If it is a bowtie or
0  4;; if it is not convex, we can't do it at all.
  ;; if it is a parallelogram, we can use the fast case
0  4;; if it is an aligned square, we may be able to use
0  4;; a non-catmull transformation
0  4;;
0  (destructuring-bind  (x0 y0 x1 y1 x2 y2 x3 y3) quad

    (cond ((not (and x0 y0 x1 y1 x2 y2 x3 y3))
						;not a quadralateral
	   3nil0)
	  ((graphics:line-intersection x0 y0 x3 y3 x1 y1 x2 y2)
	   3:bowtie0)
	  ((not (graphics:line-intersection x0 y0 x2 y2 x1 y1 x3 y3 :open))
	   3:concave0)				
	  ((not (and ( (abs (- (- x0 x3) (- x1 x2))) slop)
		     ( (abs (- (- y0 y3) (- y1 y2))) slop)
		     ( (abs (- (- x0 x1) (- x3 x2))) slop)
		     ( (abs (- (- y0 y1) (- y3 y2))) slop)))
4	   ;not a parallelogram
0	   3:quadralateral0)
	  ((not4 0(or (and ( (abs (- x0 x3)) slop) ( (abs (- y0 y1)) slop))
		    (and ( (abs (- y0 y3)) slop) ( (abs (- x0 x1)) slop))))
	   4;checking for a right angle aligned with the raster
0	   3:parallelogram0)
	  (t 3:rectangle0)))
  )

(defun 3quadralateral-permutation0 (quad)
  (destructuring-bind  (x0 y0 x1 nil x2 y2) quad  
    (if (> x0 x1)
	(logior 1 (if (< y0 y2) 0 4)(if (< x0 x2) 0 2))
	(logior 0 (if ( x0 x2) 0 2)(if (< y0 y2) 0 4)))))

(defmethod (3normalize-transformation0 catmull-transformation) ()
  ;; Some post-optimizing steps.
  (setq source-y-reverse (bit-test source-permutation 4)
	source-x-reverse (bit-test source-permutation 2)
	source-y-major (bit-test source-permutation 1))


  (with-stack-list (quad dx0 dy0 dx1 dy1 dx2 dy2 dx3 dy3)
    (setq quad-type (classify-quadralateral :slop floating-point-slop :quad quad)))

  (let ((runnable (unless (memq quad-type '(:concave :bowtie nil)) quad-type)))

    (when runnable

      (when (memq quad-type `(:parallelogram :rectangle))
	(setq m 0.0 n 0.0))

4      ;; If M and N are zero, divide through by P so we can do the
      ;; "fast" loops.
0      (when (and (zerop m) (zerop n) ( p 1.0))
	(setq a (// a p)
	      b (// b p)
	      d (// d p)
	      e (// e p)
	      f (// f p)
	      h (// h p)
	      p 1.0
	      )
	)

      (setq speed (if (and (= m 0.0)(= n 0.0) (= p 1.0)) :fast :slow))

      (rotate-source-if-appropriate self)

      ;; See if we need to reverse on either pass.  If the "diagonal" coord is
      ;; negative, negate it and reverse on reading.
      (make-dy-positive self)
      (make-dx-positive self)


      (setq intermediate-height (if source-y-major source-width source-height)
	    intermediate-width (if source-y-major source-height source-width))

      (setq source-permutation
	    (logior (if source-y-reverse 4 0)
		    (if source-x-reverse 2 0)
		    (if source-y-major 1 0))
	    )

      (let* ((x0 (raw-xform self 0 0))
	     ;X1 is always greater than X0, because we reversed them above if need be
	     (x2 (raw-xform self intermediate-width intermediate-height))
	     (x3 (raw-xform self 0 intermediate-height)))

	(setq intermediate-first-offset
	      (if ( x2 x3)
						;well formed quadralateral
		  (if (< x3 x0) (floor x3) (floor x0))
						;bowtie quadraleteral
		  (ferror "Bowtie! We shouldn't get here")
						;(if (< x2 x0) (floor x2) (floor x0))
		  )
	      )
	)
      (setq first-start-coordinate
	    (floor (- (raw-xform self 0 0) intermediate-first-offset))
	    last-start-coordinate
	    (floor (- (raw-xform self 0 intermediate-height)
		      intermediate-first-offset))
	    first-end-coordinate
	    (ceiling (- (raw-xform self intermediate-width 0)
			intermediate-first-offset))
	    last-end-coordinate
	    (ceiling (- (raw-xform self intermediate-width intermediate-height) 
			intermediate-first-offset))
	    intermediate-array-width (max first-end-coordinate last-end-coordinate)
	    intermediate-array-height intermediate-height
	    )
      ;(format t " if ~A " intermediate-first-offset)
      )
    (values runnable quad-type)
  ))

(defmethod (3transform-x-first0 catmull-transformation) ()
  (if (first rescale-in-place-on-intermediate)
      (progn
	(lexpr-funcall #'permute-raster source source-x source-y
	       intermediate-array intermediate-array-left (1+ intermediate-array-top)
	       source-width source-height
	       :source-image-type source-image-type
	       :permutation source-permutation
	       first-pass-copy-other-args)
	
	(letf ((source intermediate-array)
	       (source-y-reverse nil)
	       (source-y-major nil))
	  (cl:apply first-pass4 0self 
		    intermediate-width intermediate-height
		    scan-line-buffer intermediate-array-left (1+ intermediate-array-top)
		    intermediate-array intermediate-array-left intermediate-array-top
		    first-pass-other-args))
	)
      ;(format t "~&l ~A" intermediate-array-left)
      (lexpr-funcall first-pass4 0self 
		     intermediate-width intermediate-height
		     scan-line-buffer source-x source-y
		     intermediate-array intermediate-array-left intermediate-array-top
		     first-pass-other-args))

  (if rescale-in-place-on-intermediate
      (let ((dest-h (- (1+ (floor (max dy0 dy1 dy2 dy3)))
		       (1- (ceiling (min  dy0 dy1 dy2 dy3)))))
	    (row intermediate-array-left)
	    )
	(cl:apply second-pass self
		       intermediate-array-width
		       (1+ (floor (max dy0 dy1 dy2 dy3)))
		       intermediate-array (1+ intermediate-array-left) intermediate-array-top
		       intermediate-array intermediate-array-left intermediate-array-top
		       :per-line-function
		        #'(lambda ()
			    (i-p:draw-rectangle intermediate-array
						row intermediate-array-top
						1 dest-h 5 0 -1)
			    (incf row)
			    )
		       second-pass-other-args
		       )

	(cl:apply #'zoom-rectangle :from-array intermediate-array
			:from-left intermediate-array-left
			:from-top intermediate-array-top
			:from-right (+ intermediate-array-left intermediate-array-width )
			:from-bottom (+ intermediate-array-top dest-h)
			:to-array dest
			:to-image-type dest-image-type
			:to-left dest-x
			:to-right (+ dest-x intermediate-array-width)
			:to-top dest-y :to-bottom (+ dest-y dest-h)
			second-pass-copy-other-args
			))
      ;(format t " x ~S  ~S" dest-x (min dx0 dx1 dx2 dx3))
      (cl:apply second-pass self
		intermediate-array-width
		(1+ (floor (max dy0 dy1 dy2 dy3)))
		intermediate-array intermediate-array-left intermediate-array-top
		dest dest-x (- dest-y (- 100 bias-y))
		second-pass-other-args
		))
  )

(defmethod (3read-scan-line0 catmull-transformation) (v sx sy)
  (cond (source-y-major
	 (when source-y-reverse
	   (setq v (- source-width v 1)))
	 (funcall read-scan-line 1 intermediate-width
		  source (+ sx v) sy
		  scan-line-buffer 1 0
		  nil nil))
	(t (when source-y-reverse
	     (setq v (- source-height v 1)))
	   (funcall read-scan-line intermediate-width 1
		    source sx (+ sy v)
		    scan-line-buffer 1 0
		    nil nil)
	   )))


4;;
;; V -after-H PASS
;;
0(defmethod (3first-pass-start0 catmull-transformation) (x)
  (cond (( last-start-coordinate x first-start-coordinate)
	 (loop when ( last-top-edge 0)
		 do (return 0)
	       as margin = (aref first-pass-start-array last-top-edge)
	       while ( margin x) do (decf last-top-edge)
	       finally (return last-top-edge))
	 )
	(( last-end-coordinate x first-end-coordinate)

	 (loop when ( last-top-edge intermediate-height)
		 do (return intermediate-height)
	       as margin = (aref first-pass-end-array last-top-edge)
	       while (< margin x) do (incf last-top-edge)
	       finally (return last-top-edge))
	 )
	(t (setq last-top-edge 0)))
	)

(defmethod (3first-pass-end0 catmull-transformation) (x)
  (cond (( last-start-coordinate x first-start-coordinate)
	 (loop when ( last-bottom-edge intermediate-height)
	       do (return intermediate-height)
	       as margin = (aref first-pass-start-array last-bottom-edge)
	       while ( margin x) do (incf last-bottom-edge)
	       finally (return last-bottom-edge))
	 )
	(( last-end-coordinate x first-end-coordinate)
	 (loop when ( last-bottom-edge 0)
	       do (return 0)
	       as margin = (aref first-pass-end-array (1- last-bottom-edge))
	       while ( margin x) do (decf last-bottom-edge)
	       finally (return last-bottom-edge))
	 )
	(t (setq last-bottom-edge intermediate-height)))
	)




2#||

 Macros used in expanding the bartlet filter

4Bartlet filter is a simple 2 pixel wide triangular filter.  It
therefore uses a window of three pixels at once, where the window
always covers an area of 1.0.   A typical window looks like this

0   ______________________________________________________________________
   |                      |   /\                 |                      |
   |                      | /    \               |                      |
   |                      /        \             |                      |
   | 3 P0 0               / |          \    3P10     |              3P20      |
   |                  /   |            \         |                      |
   |                /     |              \       |                      |
   |              /       |                \     |                      |
   |            /         |                  \   |                      |
   |          /           |                    \ |                      |
   |        /   Part1     |   Part2              \   Part3              |
   |      /               |                      | \  /                 |
   |____/_________________|______________________|___\__________________|

   |....|   ---3 U0 ----    |      ---- 1 ----     |....|  ---- 3U 0----    |


4The triangle filter for one sample covers parts of three pixels.  If 3U
4is taken as the section indicated, the areas of the three parts are

   Part1 = U^2/2
   Part2 = (1 - ((U^2)/2) + ((1-U)^2)/2)
   Part3 = ((1-U)^2)/2

   Area = P0 * U^2/2 + P1 * (1 - ((U^2)/2) + ((1-U)^2)/2) + P2 * ((1-U)^2)/2

Simplifying and factoring out common terms yields

0   4Area = P1 + (P0-P1)*U^20/24  + (P2-P1)*(1-U^2)0/2

(defun fn2 (p0 p1 p2 u)
  (let ((u^2 (* u u))
	(v^2 (* (- 1 u)(- 1 u))))
    (values 
      (+ p1 (* (- p0 p1) u^2 0.5) (* (- p2 p1) v^2 0.5))
      (+ (* p0 u^2 0.5) (* p1 (- 1 (* 0.5 (+ u^2 v^2)))) (* p2 v^2 0.5))
      )))

2||#

0#||
(defun test (2idx v)
  (and (or ( 58 v 60))
       ( 290 2idx 330)))
||#

(defmacro3 bartlet-filter-before-per-color0 (&key state)
  (selectq state
    (:pre-load
     `(incf area 1.0))
    (:before-final-store
     `(setq area (if (= area 0.0) 0.0 (// area))))
    (:before-store
     `(progn
	#|| (when (test aidx v)
	  (format t "~&area ~A 1-uedge ~A" area 1-uedge)) ||#
	(setq area (if (= area 1-uedge) 0.0 (// (- area 1-UEDGE))))
	#||
	(when (test aidx v)
	  (format t " new area ~A " area)) ||#
	))))

(defmacro 3bartlet-filter-per-color0 (current color &key locals state)
  color
  (destructuring-bind (prev sum diff next-sum) locals
    (selectq state
      (:initialize
       `(progn (setq ,sum 0.0
		     ,current 0.0
	       )))
      (:before-fetch
       `(setq ,prev ,current)
       )
      (:pre-load
       `(setq ,current (float ,current)
	      ,diff (ash (- ,current ,prev) -1)
	      ,sum (+ ,sum ,prev ,diff)
	      )
       )
      (:before-final-store
       `(progn
	  (setq ,sum (fmin 255 (fast-floor-above-0 (* ,sum area))))
	  #|| (format t "~&~%~%") ||#
	))
      (:before-store
       (let ((core `(setq ,next-sum (+ (* 1-uedge ,prev) (* 1-u^2 ,diff))
			  ,sum (fmin 255 (fast-floor-above-0 (* (- ,sum ,next-sum) area)))
			  )))
	 `(progn
	    ,core
	    #|| (when (test aidx v)
	      (format t "~&~A:~A (~A-~A)  x ~A ~A = ~A"
		    aidx lim idx0 idx1 
		    1-uedge area ,sum)) ||#
	    )
	 )
       )
      (:after-store
	`(progn 
	 #|| ,@(when (eq color :alpha) `((unless (zerop ,sum)(dbg)))) ||#
	    (setq ,sum ,next-sum		
		  area 1-uedge)) 
       )))
  )

(defmacro3 update-dda-fast0 (catmull-speed)
  (if (eq catmull-speed :fast)
      `(progn
	 #|| (when (test aidx v)
	      (format t "~&1-uedge ~A  inc ~A" 1-uedge inc)) ||#
	 (decf 1-uedge inc)
	 (cond ((minusp 1-uedge)
		(decf 1-uedge (fast-floor 1-uedge))
		(setq uedge (- 1.0 1-uedge)
		      1-u^2 (- 1.0 (* uedge uedge)))
		(when quadratic-dda
		  (setq 2uinc+inc^2 (+ (ash (* uedge inc) 1) inc^2)))
		)
	       (t
		(cond (quadratic-dda
		       (decf 1-u^2 2uinc+inc^2)	;YOW!  Algebra Works!
		       (incf 2uinc+inc^2 2inc^2))
		      (t
		       (setq uedge (- 1.0 1-uedge)
			     1-u^2 (- 1.0 (* uedge uedge)))))))
	 #|| (when (test aidx v)
	      (format t " new 1-uedge ~A" 1-uedge)) ||#
	 )
      ))

(defmacro 3update-dda-slow0 (catmull-speed)
  (when (eq catmull-speed :slow)
      `(if (null inc)
	   (setq inc (// delta)
		 inc^2 (* inc inc)
		 2inc^2 (ash inc^2 1)
		 uedge (* inc (- (float (fast-ceiling idx0)) idx0))
		 2uinc+inc^2 (+ (ash (* uedge inc) 1) inc^2)
		 1-uedge (- 1.0 uedge)
		 1-u^2 (- 1.0 (* uedge uedge)))
	   ;; Not the first; update the DDA variables.
	   (decf 1-uedge inc)
	   (decf 1-u^2 2uinc+inc^2)		;YOW!  Algebra Works!
	   (incf 2uinc+inc^2 2inc^2))
      ))

(defmacro 3initialize-dda-vars0 (catmull-speed)
  `(progn
     ,@(when (eq catmull-speed :fast)
	 `(;(when (zerop v)(format t "~&i ~3f" idx0))
	   (setq uedge (* inc (- (float (fast-ceiling idx0)) idx0))
		 2uinc+inc^2 (+ (ash (* uedge inc) 1) inc^2)
		 1-uedge (- 1.0 uedge)
		 1-u^2 (- 1.0 (* uedge uedge)))
	   ;(when (zerop v)(format t " u ~3f" uedge))
	   ))))

(defun 3dda-loop-vars 0(catmull-speed)
  (if (eq catmull-speed :fast)
      `(with inc^2 = (* inc inc)
	with 2inc^2 = (+ inc^2 inc^2)
	and quadratic-dda = (< inc 0.5)
	and uedge and 2uinc+inc^2 and 1-uedge and 1-u^2 
	and area = 0.0) 
      `(with area = 0.0
	     as delta = (- idx1 idx0))
      ))

(defmethod (3run0 catmull-transformation)
	   (&key user:source user:dest
		 (sx 0)(sy 0)(dx 0)(dy 0)
		 from-field
		 to-field
		 scratch-array
		 (scratch-array-left 0)
		 (scratch-array-top 0)
		 (source-type (default-image-type user:source))
		 (dest-type (default-image-type user:dest))
		 (first-pass-function)
		 (second-pass-function)
		 (read-scan-line-function)
		 (separate)
		 (map)
		 (fetch)
		 (store)
		 (combine)
		 (threshold)
		 (black-pixel 0)
		 (white-pixel -1)
		 (brightness)
		 (dither t)
		 (jitter t)
		 (combination-name)
		 (combination-array)
		 (translation-name)
		 (translation-array)
		 (default-alpha)
		 (write-mask)
		 (other-first-pass-args)
		 (other-second-pass-args)
		 (other-args)
		 (intensity-operator :intensity)
		 (per-line-function)
		 )

  (setq source user:source
	dest user:dest
	source-x sx
	source-y sy
	dest-x dx 
	dest-y dy
	displaced-intermediate-array scratch-array
	intermediate-array-left scratch-array-left
	intermediate-array-top scratch-array-top
	source-image-type source-type
	dest-image-type dest-type
	read-scan-line read-scan-line-function
	first-pass first-pass-function
	second-pass second-pass-function
	)

4  0(determine-image-processes self
			     :fetch fetch :store store :combine combine
			     :map map :separate separate
			     :combination-array combination-array
			     :combination-name combination-name
			     :translation-array translation-array
			     :translation-name translation-name
			     :threshold threshold
			     :black-pixel black-pixel
			     :white-pixel white-pixel
			     :default-alpha default-alpha
			     :brightness brightness
			     :dither dither
			     :jitter jitter
			     :from-field from-field
			     :to-field to-field
			     :other-args other-args
			     :other-second-pass-args other-second-pass-args
			     :other-first-pass-args other-first-pass-args
			     :write-mask write-mask
			     :intensity-operator intensity-operator
			     )

  (when per-line-function
    (push per-line-function first-pass-other-args)
    (push :per-line-function first-pass-other-args)
    (push per-line-function second-pass-other-args)
    (push :per-line-function second-pass-other-args))

  (unwind-protect
      (with-data-stack
	(create-buffers self)
	(transform-x-first self))
    (discard-buffers self))
  )

(defun 3specify-catmull-image-processes
0       (&key source-image-type dest-image-type speed  source-permutation
	fetch store map separate combine intermediate-image-type jitter dither
	write-mask (intensity-operator :intensity)
	rescale-in-place-on-intermediate
	default-alpha)
4  ;;
  ;; This function is used both by the runtime setup for catmull transformation
0  4;; and by the compile-time code that generates all the transformation functions.
  ;;
0  (let* ((intermediate-image-type
4	   ;; determine the type of the intermediate array, depending on the source
	   ;; and destination arrays.
	   ;; (1) All full color destinations use an art-fixnum to hold the intermediate 
	   ;; (2) 1 bit destinations use a 2 bit intermediate if the source material is one
	   ;;     or two bit.
	   ;; (3) Everything else uses an art-8b containing grayscale.
	   ;;
0	   (or intermediate-image-type
	       (selectq dest-image-type
		 ((rgb-image packed-rgb-image 32b-image4 0packed-yuv-image
			     8b-palette-image 8b-random-image
			     4b-random-image 4b-palette-image
			     2b-random-image 2b-palette-image)
		  (selectq source-image-type
		    ((rgb-image packed-rgb-image 32b-image 32b-no-alpha-image
				packed-yuv-image
				8b-palette-image 8b-random-image 
				4b-palette-image 4b-random-image
				2b-palette-image 2b-random-image)
		     '32b-image)
		    (2b-image '4b-image)
		    (b&w-image '2b-image)
		    (t 'false-color-image)))
		 (b&w-image '2b-image)
		 (2b-image '4b-image)
		 (t 'false-color-image))))

	 (read-image-type
	   4;;except in the case of rgb-image, the read function returns just what
0	   4;;it was given.  RGB images get converted to 32b-images.
0	   (cond ((memq source-image-type '(packed-rgb-image rgb-image))
		  (if (eq dest-image-type '32b-image)
		      '32b-no-alpha-image
		      '32b-image)4)
0		 ((first rescale-in-place-on-intermediate) intermediate-image-type)
		 (t source-image-type)))

	 4;;
0	 4;; What's going on here?  We use the information supplied for
0	 4;; ordinary image rescaling to specify the stratedy for converting
0	 4;; image types while doing a catmull transformation.  This assures
0	 4;; that the strategies used are compatable with ordinary rescaling,
0	 4;; and also saves a lot of donkey work specifying them by hand!
0	 4;;
0	 (pass1-spec-key (list read-image-type intermediate-image-type :average nil nil))
	 (pass1-rescale-specs (or (gethash pass1-spec-key rescale-image-specs)
				  (ferror "~A missing from rescale-image-specs"
					  pass1-spec-key)))
	 (pass2-spec-key (list intermediate-image-type
			       (if rescale-in-place-on-intermediate
				   intermediate-image-type
				   dest-image-type)
			       :average dither jitter))
	 (pass2-rescale-specs (or (gethash pass2-spec-key rescale-image-specs)
				  (ferror "~A missing from rescale-image-specs"
					  pass2-spec-key)))
	 (read-image-process-spec
	   `(:fetch ,(cond ((first rescale-in-place-on-intermediate) :rgba)
			   ((eq source-image-type 'packed-rgb-image) :packed-rgb)
			   ((eq source-image-type 'rgb-image) :r+g+b)
			   (t :rgba))
	     :store :rgba
	     :combine ,(if (and (not (first rescale-in-place-on-intermediate))
				(memq source-image-type '(packed-rgb-image rgb-image)))
			   :rgba nil)
	     :permutation ,(if (first rescale-in-place-on-intermediate) 0 source-permutation)
	     :intensity-operator ,intensity-operator
	     ,@(when (memq source-image-type '(packed-rgb-image rgb-image))
		 `(:default-alpha 255))))

	 (pass1-image-process-spec
	   (make-catmull-image-process-spec
	     pass1-rescale-specs speed :first
	     :fetch (cond ((first rescale-in-place-on-intermediate)
			   :rgba)
			  ((member source-image-type '(packed-rgb-image))
			   :rgba)
			  ((listp fetch) (first fetch))
			  (t fetch))
	     :map (if (listp map) (first map) map)
	     :separate (if (listp separate) (first separate) separate)
	     :combine (if (listp combine) (first combine) nil )
	     :store (if (listp store) (first store) nil)
	     :default-alpha (when (get (locf pass1-rescale-specs) :default-alpha)
			      default-alpha)
	     :intensity-operator intensity-operator
	     ))

	 (pass2-image-process-spec
	   (make-catmull-image-process-spec
	     pass2-rescale-specs speed :second
	     :fetch (if (listp fetch) (second fetch) nil)
	     :map (if (listp map) (second map) nil)
	     :separate (if (listp separate) (second separate) nil)
	     :combine (if (listp combine) (second combine) combine )
	     :store (cond (rescale-in-place-on-intermediate :rgba)
			  ((listp store) (second store))
			  (t store))
	     :default-alpha (when (get (locf pass2-rescale-specs) :default-alpha)
			      default-alpha)
	     :write-mask write-mask
	     :intensity-operator intensity-operator
	     ))
	 )
    4;;0    
4    ;; determine the image process to read the source into a
0    4;; scanline buffer, based on the source permutation, 
0    4;; source image type and intermediate image type
0    4;;
0    (values intermediate-image-type
	    read-image-type
	    read-image-process-spec
	    pass1-image-process-spec
	    pass2-image-process-spec
	    pass1-rescale-specs
	    pass2-rescale-specs)

	))


(defun 3make-catmull-image-process-spec0 (raw-list speed pass
					    &key fetch store combine map separate write-mask
					    default-alpha intensity-operator
					    )
  4;;
0  4;; take a rescale image process spec and produce a catmull image process spec
0  4;;
0  (let* ((translation-name (get (locf raw-list) :translation-name))
	 (combination-name (get (locf raw-list) :combination-name))
	 (translation-array (get (locf raw-list) :translation-array))
	 (combination-array (get (locf raw-list) :combination-array))
	 (brightness (get (locf raw-list) :brightness))
	 (dither (get (locf raw-list) :dither))
	 (jitter (get (locf raw-list) :jitter))
	 (jitter-threshold (get (locf raw-list) :jitter-threshold))
	 (default-alpha (or default-alpha (get (locf raw-list) :default-alpha)))
	 (black-pixel (get (locf raw-list) :black-pixel))
	 (white-pixel (get (locf raw-list) :white-pixel))
	 (threshold (get (locf raw-list) :threshold)))
    `(:fetch ,(or fetch (get (locf raw-list) :fetch))
      :store ,(or store (get (locf raw-list) :store))
      :map ,(or map (get (locf raw-list) :map))
      :separate ,(or separate (get (locf raw-list) :separate))
      :combine ,(or combine (get (locf raw-list) :combine))
      :catmull-speed ,speed
      :catmull-pass ,pass
      ,@(when default-alpha `(:default-alpha ,default-alpha))
      ,@(when translation-name `(:translation-name ,translation-name))
      ,@(when translation-array `(:translation-array ,translation-array))
      ,@(when combination-name `(:combination-name ,combination-name))
      ,@(when combination-array `(:combination-array ,combination-array))
      ,@(when brightness `(:brightness ,brightness))
      ,@(when threshold `(:threshold ,threshold))
      ,@(when black-pixel `(:black-pixel ,black-pixel))
      ,@(when white-pixel `(:white-pixel ,white-pixel))
      ,@(when dither `(:dither ,dither))
      ,@(when jitter `(:jitter ,jitter))
      ,@(when jitter-threshold `(:jitter-threshold ,jitter-threshold))
      ,@(when write-mask `(:write-mask ,write-mask))
      ,@(when intensity-operator `(:intensity-operator ,intensity-operator))
      )))

(defmethod (3determine-image-processes0 catmull-transformation)
	   (&key fetch store combine map separate
		 combination-array combination-name
		 translation-array translation-name
		 threshold brightness dither jitter
		 black-pixel white-pixel write-mask
		 default-alpha other-first-pass-args other-second-pass-args other-args
		 from-field to-field (intensity-operator :intensity)
		 )

  4;;
0  4;; find the three image process functions we will use to produce this
0  4;; transformation.
  ;;
0  (let ((source-yuv (eq source-image-type 'packed-yuv-image))
	(dest-yuv (eq dest-image-type 'packed-yuv-image)))
    (when (or source-yuv dest-yuv)
    (setq rescale-in-place-on-intermediate (list source-yuv dest-yuv)
	  second-pass-copy-other-args `(:combination-array ,combination-array
					:combination-name ,combination-name)
	  combination-array nil
	  combination-name nil)
    (when source-yuv
      (setq first-pass-copy-other-args `(:translation-array ,translation-array
					 :translation-name ,translation-name)
	    translation-array nil
	    translation-name nil))
	  ))

  (multiple-value-bind (intermediate-image-type 
			read-image-type
			read-image-process-spec
			pass1-image-process-spec
			pass2-image-process-spec)

      (specify-catmull-image-processes
	:source-image-type source-image-type
	:write-mask write-mask
	:rescale-in-place-on-intermediate rescale-in-place-on-intermediate
	:dest-image-type dest-image-type
	:speed speed
	:source-permutation source-permutation
	:fetch fetch
	:store store
	:map map
	:combine combine
	:separate separate
	:jitter jitter
	:dither dither
	:write-mask write-mask
	:default-alpha default-alpha
	:intensity-operator intensity-operator)

    (setq intermediate-array-type (data-array-type intermediate-image-type)
	  read-array-type (data-array-type read-image-type)
	  first-pass-spec pass1-image-process-spec
	  second-pass-spec pass2-image-process-spec)

    (let ((read-image-process (find-image-process permute-image
						  read-image-process-spec
						  :create-p t
						  :error-p t))
	  (pass1-image-process (find-image-process catmull-transformation
						   pass1-image-process-spec
						   :create-p t
						   :error-p t))
	  (pass2-image-process (find-image-process catmull-transformation
						   pass2-image-process-spec
						   :create-p t
						   :error-p t))
	  )
      (setq read-scan-line (compiled-function read-image-process))
      (setq first-pass-ip pass1-image-process
	    second-pass-ip pass2-image-process)
      (setq first-pass (compiled-function pass1-image-process))
      (setq second-pass (compiled-function pass2-image-process))
      (setq first-pass-other-args 
	    (lexpr-funcall #'image-process-accepts-other-rescale-args
	      pass1-image-process first-pass-spec
	      :jitter jitter
	      :from-field from-field
	      :translation-array translation-array
	      :translation-name translation-name
	      :default-alpha default-alpha
	      (append other-args other-first-pass-args))
	    second-pass-other-args
	    (lexpr-funcall #'image-process-accepts-other-rescale-args
	      pass2-image-process second-pass-spec
	      :combination-array combination-array
	      :combination-name combination-name
	      :to-field to-field
	      :brightness brightness
	      :threshold threshold
	      :black-pixel black-pixel
	      :white-pixel white-pixel
	      :default-alpha default-alpha
	      :write-mask write-mask
	      (append other-second-pass-args other-args)
	      ))
    ))
  )

(defun make-quad-from-edges (from-left from-top from-right from-bottom)

  (cond ((eql from-left from-right))
	((> from-left from-right) (incf from-right))
	(t (decf from-right)))
  (cond ((eql from-top from-bottom))
	((> from-top from-bottom) (incf from-bottom))
	(t (decf from-bottom)))
  (list from-left from-top
	from-right from-top
	from-right from-bottom
	from-left from-bottom))

(defvar 3*scratch-cat*0 (make-instance 'catmull-transformation))

(defun 3intermediate-array-size0 (w h x1 y1 x2 y2 x3 y3 x4 y4)
  (process:without-preemption
    (setup-copy-to-quad
      *scratch-cat*
      w h
      x1 y1 x2 y2 x3 y3 x4 y4
      )
    (values (catmull-intermediate-array-width *scratch-cat*)
	    (catmull-intermediate-array-height *scratch-cat*))
    ))


(defun 3transform-quadrangle
0       (&rest args
	&key

	(from-quad)
	(to-quad)

	from-array
	from-array-stream
	(from-image-type (default-image-type from-array))
	(from-left 0) 4;if full quads are specified, these are the clipping region
0	(from-top 0)
	(from-right)
	(from-bottom)
	(from-field)

	to-array
	to-array-stream
	(to-image-type  (default-image-type to-array))
	(to-left 0) 4;if full quads are specified, these are the clipping region
0	(to-top 0)
	(to-right)
	(to-bottom)
	(to-field)

	(translation-array)
	(combination-array)
	(translation-name)
	(combination-name)
	(threshold)
	(black-pixel 0)
	(white-pixel -1)
	(brightness)
	(dither t)
	(jitter)

	(default-alpha)
	(force-default-alpha nil)

	image-process
	rescale
	fast 

	(pixel-aspect-ratio-slop 1.0)
	(floating-point-slop 0.0001)
	fetch store map combine separate
	(intensity-operator :intensity)

	(error-p t)
	(perspective t)
	(scratch-array)
	(scratch-array-left 0)
	(scratch-array-top 0)
	write-mask
	other-args other-first-pass-args other-second-pass-args
	to-window
	per-line-function
	)

  (ignore fast rescale image-process pixel-aspect-ratio-slop to-window)
  (when per-line-function
    (setq other-first-pass-args
	  (append other-first-pass-args
		  `(:per-line-function ,per-line-function)))
    (setq other-second-pass-args
	  (append other-second-pass-args
		  `(:per-line-function ,per-line-function))))
  (when (and (eq from-image-type '32b-image)
	     force-default-alpha)
    (setq from-image-type '32b-no-alpha-image))

  (when jitter
    (setq dither t)				
    (setq jitter t))

  (when (floatp threshold) (setq threshold (round (* 255 threshold))))
  (let* ((rescale (cond ((eq rescale t) :average)
			(rescale rescale)
			((eq fast t) :select)
			(fast fast)
			(t :filter)))
	 (byte-size (array-element-byte-size (if (listp to-array) (first to-array) to-array)))
	 (write-mask (if (or (eql write-mask -1)
			     (eql write-mask (1- (lsh 1 byte-size))))
			 nil
			 write-mask))
	 )

    (if (and from-quad
	     (neq :rectangle (classify-quadralateral
			       :slop floating-point-slop
			       :quad from-quad)))
	(when error-p
	  4;someday this restriction may be removed..
0	  (ferror "Source quad must be a rectangle aligned with the raster"))

	(unless from-quad
	  (setq from-quad (make-quad-from-edges from-left from-top from-right from-bottom)))

	(unless to-quad
	  (setq to-quad (make-quad-from-edges to-left to-top to-right to-bottom)))

	(destructuring-bind (fx0 fy0 nil nil fx2 fy2 ) from-quad
	  (destructuring-bind (tx0 ty0 tx1 ty1 tx2 ty2 tx3 ty3) to-quad
	    (let* ((from-permutation (quadralateral-permutation from-quad))
		   (from-dx (when from-quad (1+ (abs (- fx0 fx2)))))
		   (from-dy (when from-quad (1+ (abs (- fy0 fy2)))))
		   (from-width (cond ((bit-test 1 from-permutation) from-dy)
				     (t from-dx)))
		   (from-height (cond ((bit-test 1 from-permutation) from-dx)
				      (t from-dy)))
		   (cat (make-instance 'catmull-transformation))
		   (runnable
		     (setup-copy-to-quad cat from-width from-height
					 tx0 ty0 tx1 ty1 tx2 ty2 tx3 ty3
					 :source-permutation from-permutation
					 :slop floating-point-slop
					 :m=0 (not perspective)
					 :n=0 (not perspective)
					 )))
	      (if (not runnable)
		  (when error-p
		    (ferror "Destination quad isn't convex"))

		  (if (and (= (catmull-source-permutation cat) 0)
			   (eq (catmull-quad-type cat) :rectangle)
			   (neq rescale :filter))

		      (si:with-rem-keywords
			(args args '(:scratch-array :scratch-array-left :scratch-array-top))
		      (lexpr-funcall #'zoom-rectangle 
				     :from-left (min fx0 fx2)
				     :from-right (1+ (max fx0 fx2))
				     :from-top (min fy0 fy2)
				     :from-bottom (1+ (max fy0 fy2))
				     :to-left (min tx0 tx2)
				     :to-right (1+ (max tx0 tx2))
				     :to-top (min ty0 ty2)
				     :to-bottom (1+ (max ty0 ty2))
				     :from-quad nil
				     :to-quad nil
				     args
				     ))

		      (when (or to-array-stream from-array-stream)
			(ferror
			  "Catmull image processes aren't suitable for stream processing,~%~
			   but streams are specified"))

		      (when scratch-array
			(let ((iw (catmull-intermediate-array-width cat))
			      (ih (catmull-intermediate-array-height cat)))
			  (multiple-value-bind (w h)
			      (decode-raster-array scratch-array)
			    (unless (and ( iw (+ scratch-array-left w))
					 ( ih (+ scratch-array-top h)))
			      (ferror "scratch array ~S not large enough; size required is ~Dx~D"
				      
				      scratch-array iw ih)))))
		      (let ((once nil)
			    (zoom-rectangle-debug *zoom-rectangle-debug*))

		      (when zoom-rectangle-debug
			(format t "~&Catmul ~S" cat)
			(when (eq zoom-rectangle-debug :break)
			  (call-debugger))
			)
				 
		      (run cat
			   :source from-array
			   :sx fx0
			   :sy fy0 
			   :dest to-array
			   :dx (fix (min tx0 tx1 tx2 tx3))
			   :dy (fix (min ty0 ty1 ty2 ty3))
			   :scratch-array scratch-array
			   :scratch-array-left scratch-array-left
			   :scratch-array-top scratch-array-top
			   :source-type from-image-type
			   :dest-type to-image-type
			   :separate separate
			   :map map
			   :fetch fetch
			   :store store
			   :combine combine
			   :threshold threshold
			   :black-pixel black-pixel
			   :white-pixel white-pixel
			   :default-alpha default-alpha
			   :brightness brightness
			   :dither dither
			   :jitter jitter
			   :from-field from-field
			   :to-field to-field
			   :combination-name combination-name
			   :combination-array combination-array
			   :translation-name translation-name
			   :translation-array translation-array
			   :other-args other-args
			   :other-second-pass-args other-second-pass-args
			   :other-first-pass-args other-first-pass-args
			   :write-mask write-mask
			   :intensity-operator intensity-operator
			   :per-line-function
			   (cond (per-line-function)
				 ((eq zoom-rectangle-debug :break-in)
				  #'call-debugger)
				 ((eq zoom-rectangle-debug :break-in-1)
				  #'(lambda ()
				      (unless once
					(funcall 'dbg)
					(setq once t))))
				 ((eq zoom-rectangle-debug :mode-lock)
				  #'(lambda ()
				      (WHEN (DBG:WHEN-MODE-LOCK-INTERNAL)
					(FUNCALL 'DBG)))))
			   ))
		      (values cat catmull-transformation)
		      ))))
	  ))))


#||

(defun random-good-quad (ww2 wh2 flippable?)
  (labels ((rand (range)
	     (// (random (* range 1000)) 1000.0)))
    (loop repeat 100
	  as x0 = (rand ww2)
	  as x1 = (rand ww2)
	  as x2 = (rand ww2)
	  as x3 = (rand ww2)
	  as quad = (list x0 (rand wh2) x1 (rand wh2)
			    x2 (rand wh2) x3 (rand wh2))
	  as class = (color:classify-quadralateral :quad quad)
	  when (and (not (member class '(nil :bowtie :concave)))
		    (or (not flippable?)
			(not (or (xform-must-not-be-flipped-p x0 x1 x2 x3)
				 (xform-must-be-flipped-p x0 x1 x2 x3)))))
	    return quad
	  finally (return nil))))


(defvar *last* nil)
(defvar *chris-test* (list nil
			   (+ 640 0.0)(+ 512 0.0)
			   (+ 640 312.0) (+ 512 5.0)
			   (+ 640 410.0)(+ 512 203.0)
			   (+ 640 43.0)(+ 512 384.0)
			   nil 0 0 
			   188 175 -1
			   ))
;;
;; this is a test that evaluates quality of catmul transformation,
;; comparing two different methods of drawing.  The methods that
;; can be compared are with "inverted flip preference" or with 
;; "remote" execution.
;;
(defun xftest (window &key (remote nil)(invert-flip nil) specs)
  (unless (or (member remote '(:red :green))
	      (member invert-flip '(:red :green)))
    (error "nothing to test"))
  (multiple-value-bind (ww wh)
      (send window :inside-size)
    (destructuring-bind (xwin x1 y1 x2 y2 x3 y3 x4 y4
			 xswin dx dy xw xh) specs
      (ignore xswin xwin dx dy)

    (let* ((ww2 (// ww 2))
	   (wh2 (// wh 2))
	   (ms (- (min ww2 wh2) 4))
	   (s-w (or xw (1+ (random ms ))))
	   (s-h (or xh (1+ (random ms))))
	   (xform (if x1 nil (random-good-quad ms ms (member invert-flip '(:red :green)))))
	   (green-error 0)
	   (red-error 0)
	   (tmax 0)
	   )

      (when xform
	(setq x1 (pop xform)
	      y1 (pop xform)
	      x2 (pop xform)
	      y2 (pop xform)
	      x3 (pop xform)
	      y3 (pop xform)
	      x4 (pop xform)
	      y4 (pop xform))
	(incf x1 ww2) (incf x2 ww2) (incf x3 ww2) (incf x4 ww2)
	(incf y1 wh2) (incf y2 wh2) (incf y3 wh2) (incf y4 wh2))

	(i-p:draw-rectangle window 0 0 ww wh tv:alu-seta 0 -1)

	(i-p:draw-rectangle window 0 0 s-w s-h tv:alu-seta -1 -1) ;source rect
	;hollow
	(i-p:draw-rectangle window 3 3 (- s-w 6)(- s-h 6) tv:alu-seta 0 -1)


	(i-p:draw-rectangle window ww2 wh2 ww2 wh2 tv:alu-seta 00 #xff0000)
	(i-p:draw-triangle window ww2 wh2 (round x1)(round y1)(round x2)(round y2) tv:alu-xor #xff0000 -1)
	(i-p:draw-triangle window ww2 wh2 (round x2)(round y2)(round x3)(round y3) tv:alu-xor #xff0000 -1)
	(i-p:draw-triangle window ww2 wh2 (round x3)(round y3)(round x4)(round y4) tv:alu-xor #xff0000 -1)
	(i-p:draw-triangle window ww2 wh2 (round x4)(round y4)(round x1)(round y1) tv:alu-xor #xff0000 -1)

	(setq *last* (list window x1 y1 x2 y2 x3 y3 x4 y4
			   window 0 0
			   s-w s-h #xff00
			   :intermediate window
			   :allow-remote (member remote '(t :red))
			   :intermediate-x ww2 :intermediate-y 0))

	(let ((*invert-catmul-flip-preference* (member invert-flip '(t :red))))
	  (i-p:transform window x1 y1 x2 y2 x3 y3 x4 y4
			 window 0 0
			 s-w s-h #xff
			 :intermediate window
			 :allow-remote (member remote '(t :red))
			 :intermediate-x ww2 :intermediate-y 0))

	(let ((*invert-catmul-flip-preference* (member invert-flip '(t :green))))
	  (i-p:transform window x1 y1 x2 y2 x3 y3 x4 y4
			 window 0 0
			 s-w s-h #xff00
			 :intermediate window
			 :allow-remote (member remote '(t :green))
			 :intermediate-x 0 :intermediate-y wh2))



	(tv:with-bit-array
	  window :input
	  #'(lambda (ras idx span)
	      (let ((ras ras))
		(declare (sys:array-register-1d ras))
		(loop repeat wh2
		      as row-idx from idx by span
		      do
		  (loop repeat ww2
			as dx from row-idx
			as pix = (aref ras dx)
			as blue = (ldb (byte 8 16) pix)
			as green = (ldb (byte 8 8) pix)
			as red = (ldb (byte 8 0) pix)
			do (incf tmax blue)
			   (incf red-error (abs (- red blue)))
			   (incf green-error (abs (- green blue))))
		  )))
	  :x-offset ww2
	  :y-offset wh2
	  :width ww2
	  :height wh2)

      (let* ((red-p (* 100 (// red-error (float tmax))))
	     (green-p (* 100 (// green-error (float tmax)))))
	(format t "~&~A error = ~4f%  ~A error = ~4f specs ~S%"
		(cond ((eq remote :red) "Remote")
		      ((eq invert-flip :red) "Inverted")
		      (t "Red (normal)"))
		red-p
		(cond ((eq remote :green) "Remote")
		      ((eq invert-flip :green) "Inverted")
		      (t "Green (normal)"))
		green-p
		*last*
		)
	(values red-p green-p)
      )))))

(defun xf (w &rest args)
  (loop doing
    (multiple-value-bind (normal inverted)
	(cl:apply #'xftest w args)
      (when (or (and (> normal 2.0)(> normal (* 2.0 inverted )))
		(and (> inverted 2.0)(> inverted (* 2.0 normal ))))
	(push (list normal inverted *last*) *worse*))
      #||
      (if (and (> normal (* 1.1 inverted))
	       (> (abs (- normal inverted)) 2.0))
	  (cl:break "Bad ~S - normal ~S inverted ~S" *last* normal inverted))
      ||#
      )))

||#

#||

1Catmull Transformation functions:

0 Running a complete transformation requires three image process
functions:

 (1) A permutation function to permute the source and possibly expand it 
  into the intermediate array type
 (2) A pass 1 Catmull function which stretches the source on the X axis
     and stores the result in an intermediate
 (3) A pass 2 Catmull function which stretches the intermediate on the
     Y axis and stores the final result.

These three processes are kept separate primarily to reduce the number
of functions required to get the full cross product of transformations
from any image type to any image type.

Here's the transformation matrix we implement.  The cells indicate the type
of the intermediate value.

				Destination Type
Source
Type	    1Bit     2Bit    8Bit/Grey   8Bit/Palette  8Bit/Random	RGB	32B
_______________________________________________________________________________________

1Bit        2B       8B	     8B          8B            8B               8B      8B
            
2Bit        2B       8B      8B          8B            8B               8B      8B

8Bit        8B	     8B      8B          8B            8B               8B      8B
Grey

8Bit        8B	     8B      8B          32B           32B              32B     32B
Palette

8Bit        8B	     8B      8B          32B           32B              32B     32B
Random

RGB         8B       8B      8B          32B           32B              32B     32B

32B	    8B       8B      8B          32B           32B              32B     32B

All 32B intermediate values are RGBA
All 8B and 2B intermediate values are grayscale

All "read scan line" functions except the RGB version 
produce the same type as they take, and they are generic over array types, 
so we need only the basic 8 plus 8 more to read rgb and produce 32B

all Pass1 Functions fetch what was produced by "read scan line", so
and store the stame type, so we need 1b-2b, 2b-2b, 8b-8b, 8b-map-8b, 32b-8b
8b-map-32b, 32b-23b

all pass 2 function fetch the intermediate type and store the final type,
so we need only 2B-1B, 8B-1B, 8B-2B, 8B-8B, 8B-Palette, 32B-Palette, 8B-Random
32B-Random, 8B-RGB, 32B-RGB, 8B-32B and 32b-32b

||#


