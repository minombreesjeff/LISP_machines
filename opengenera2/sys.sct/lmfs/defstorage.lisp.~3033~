;;; -*- Syntax: Zetalisp; Mode: LISP; Package: LMFS; Base: 8; Lowercase: YES -*-
;;;
;;; A PL/I like storage-laying-out facility


;;; (I have now determined that "PL/I like" means that 3/4 of a PL/I compiler
;;; is implemented in this file)

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; 3/23/81 version 59 - uses indirect 8bit arrays for everything.
;;; 4/82 Major features of all sorts
;;; 6/82 flag and char-with-length arrays
;;; 9/82 NES signalling, d-error throws, punting, fixes.
;;; 10/83 Unaligned and multi-byte bit fields.
;;; 86-03-30, BIM: ASCII translation support.

;;; "documentation"
;;; See LMFS; FS-DCLS LISP for an extensive use of features herein.
;;;(lmfs:defstorage (STRUCTURE-NAME . OPTIONS)
;;;    FIELD-DEF
;;;    FIELD-DEF
;;;    .........
;;;    FIELD-DEF)
;;;
;;;   Defines a "layout" of 8-bit bytes into bit fields, fixna, char strings, counted
;;;   char strings, flags, substructures, and macros for accessing these objects given
;;;   an art-8b array in which they appear, storing them, and in the case of strings,
;;;   comparing them, as well as the ability to define other kinds of macros.
;;;   Note that all stored objects are "flat" objects, i.e., no Lisp pointers.
;;;   Bytes and bits assigned in Lisp Machine (Hebraic) order in a word.
;;;
;;;    FIELD DEF has the syntax (FIELD-NAME . DATA TYPE DESCRIPTION)
;;; Examples:
;;;    (foo-count  fixnum-bytes 2)          ;16-bit nonnegative integer
;;;    (bar-count  fixnum)                  ;fullword-aligned 4-byte positive integer
;;;    (title      char 8.)                 ;8 char character string, aligned to char
;;;    (subtitle   char-with-length 14.)    ;14 char string stored with 2-byte length
;;;    (glubtitle  short-char-with-length 10.)  ;same, 1-byte length
;;;    (magic      byte)                    ;1-byte integer = (fixnum-bytes 1)
;;;    (valid      flag)		    ;T or NIL, occupies 1 bit
;;;    (type       bit 3)		    ;3-bit nonnegative integer
;;;    (ignore     mod word)		    ;Force alignment to a word.
;;;					    ;any field name starting with "ignore"
;;;					    ;generates no macros; mod takes "word" or "byte"
;;;					    ;Magic words and kwds can be on any package.
;;;    (descrip    mumble)		    ;Previously defined structure name includes
;;;
;;;  DATA TYPE DESCRIPTION  can also be (... array dimlist . DATA-TYPE-DESCRIPTION)
;;;  e.g., (foo-array array (3 2 4) fixnum).  Arrays of structures are legal.
;;;  Array indexing is PL/I-like (unlike Lisp).  This is necessary because of 
;;;  the need for consistent subscripting of substructures: First index/dim describes 
;;;  number of biggest subunits.  First dim may be * for the last element in a structure.
;;;  Arrays of a single dimension need not have the single dimension in a list.
;;;
;;;  If FIELD-NAME is *, no accessors or setter properties are generated for the field,
;;;  but is space is still accounted for.  This is NOT SO for structure's or union's
;;;  or arrays thereof (see below), where * means "don't catenate in a level of name".
;;;  This is also true of "being"'s.
;;;
;;;   Accessor Syntax
;;;   Accessor macro forms have the general syntax
;;;   (ACCESSOR-NAME 8BIT-VALUE)  where 8BIT-VALUE is evaluated to produce a 
;;;   art-8b array which is assumed to have the stucture at its base.  ACCESSOR-NAME
;;;   is constructed as STRUCTURE-NAME-FIELD-NAME in general.  When substructures
;;;   are involved, STRUCTURE-NAME-FIELD-NAME-FIELD2NDLEVEL-NAME... etc.  Note that
;;;   the field names, not the structure names are used at other than the top level.
;;;   If a lowest-level structure has only one component named *, its name is NOT
;;;   incorporated in accessor names (or the "-" before it). This allows you to
;;;   say "a DATE is a FIXNUM that I think of as a DATE", etc.
;;;
;;;   The value of the accessor macro form is a Lisp object; fixna for fixnum and
;;;   bit fields, T/NIL for flags, freshly-consed strings for char/char-with-length.
;;;   When an array reference is involved,  the accessor macro has the syntax
;;;   (ACCESSOR-NAME 8BIT-VALUE SUBSC1 SUBSC2...) where the subscripts are evaluated,
;;;   but not in any guaranteed order!.   A reference to an array with no supplied
;;;   subscripts is called an "aggregate" reference, and produces a multilevel (if needed)
;;;   list of the listed levels of the array (e.g., a single-level list for a 1-dim array).
;;;
;;;   Properties are defined such that accessor macro forms can be SETF'ed; this includes
;;;   aggregate setting of arrays.  Character fields also generate a "compare accessor"..
;;;   (accessor-name-COMPARE 8BIT-VALUE COMPAREVAL) which tests string-equality of any kind
;;;   of defstoraged char-string without consing. Subscripts, if any, follow COMPAREVAL.
;;;
;;;  If :ALTERANT appears among the keywords in OPTIONS, a macro called
;;;  alter-STRUCTURE-NAME is defined (uppercase), which looks exactly like a DEFSTRUCT
;;;  alterant and has the same effect.  :CONSTRUCTOR in the OPTIONS causes a
;;;  make-STRUCTURE-NAME macro to be defined, like DEFSTRUCT, but this actually ALLOCATES
;;;  an art-8b array and initializes it.  "Made" things like this are DESCRIBE-able,
;;;  and get all their fields interpreted by so doing.  Otherwise,
;;;  (lmfs:defstorage-describe 8bit-expression 'structure-name) does that.
;;;
;;;  If :UNION appears among the keywords in OPTIONS, all of the comprising fields
;;;  of the structure are assumed to start at the beginning of the structure.  The
;;;  size of the structure is the maximum size of the comprising fields. That is,
;;;  all the fields overlap, and thus, a many-definitioned structure is created.
;;;
;;;  Substructures or unions can be included as DATA-TYPE-DESCRIPTIONs.  The syntax
;;;  for such a FIELD-DEF is
;;;  (FIELD-NAME structure
;;;		 sub-FIELD-DEF-1
;;;		 sub-FIELD-DEF-2
;;;		 ...)
;;;  If "union" is given instead of "structure", a union is created (all the subfields
;;;  overlap.  Unions and arrays of unions and arrays of structures, etc., are all fine,
;;;  with the single restriction that ARRAYED substructures must (currently)
;;;  be an integral number of bytes.  If FIELD-NAME is *, it is not catenated into
;;;  accessor names of the subfields; otherwise, it would be.
;;;
;;;  A DATA-TYPE-DESCRIPTION starting with "being" factors a declaration:
;;;  (foo being flag
;;;       a b c)
;;;  is equivalent to
;;;  (a flag) (b flag) (c flag)
;;;  * may be used for the FIELD-NAME of a being.  The field-name of the being
;;;  doesn't get used for anything, anyway.
;;;
;;;  Bit field arrays are currently limited to 1, 2, 4, or 8 bits, and
;;;  must align with boundaries of that many bits.  Bit fields (single fields, not arrays)
;;;  may span byte boundaries, and need not align to byte boundaries.  Bit fields
;;;  appearing as part of arrayed structures are may be any size, 
;;;  and are not considered bit field arrays.
;;;
;;;  Macros called structure-name-SIZE-IN-BYTES (and -WORDS, and -BITS) are defined
;;;  for outer level *and* internal structures, as long as they are not named *.
;;;
;;;  For the rest of the features and obscure restrictions read the code yourself.

(defconst *defstorage-package* package)	;The package this was loaded into

;;; WARNING- Due to simple-minded implementation, wrapping form had better not 
;;; contain a wrap-if, or any other gratuitous use of :the-form.
(defmacro wrap-if (cond wrapping-form form)
  (let ((gs (gensym)))
    `(let ((,gs ,form))
       (if ,cond
	   (subst ,gs ':the-form ,wrapping-form)
	   ,gs))))

(defmacro once-onlify-index-offset (form env)
  (let ((do-it-p (gensym))
	(was-ixo (gensym))
	(ggs (gensym)))
    `(let ((,do-it-p (not (atom *defstorage-index-offset*)))
	   (,was-ixo *defstorage-index-offset*))
       (let-if ,do-it-p				;Guaranteed needs wrapping now.
	       ((*defstorage-index-offset* '',ggs))
	 (wrap-if (symbolp ,was-ixo)		;Needs once-onlying at macro time.
		  `(once-only (,,was-ixo &environment ,,env) ,:the-form)
		  (wrap-if ,do-it-p
			   ``(let ((,',',ggs ,,,was-ixo)) ,,:the-form)
			   ,form))))))


;;; Needed runtimes

(defun defstorage%string-equal (8array1 index1 string2 index2 count)
  ;; NIL not allowed, and lengths must fit.
  (let ((8array1 8array1) (string2 string2))
    (declare (sys:array-register 8array1 string2))
    (do () ((zerop count) t)
      (unless (char-equal (code-char (aref 8array1 index1)) (aref string2 index2))
	(return nil))
      (incf index1)
      (incf index2)
      (decf count))))

(defun defstorage-ascii-string= (8array1 index1 string2 index2 count)
  ;; Spaces at the end are insignificant.
  ;; So we cons a string (hi ho, egc) and use string=
  (let ((char-string (ascii-to-string 8array1)))
    (cl:string= char-string string2
		:start1 index1 :end1 (+ index1 count)
		:start2 index2 :end2 (+ index2 count))))

(defun defstorage-unsigned-fixed-decimal-equal (8array1 index1 number2 ignore count)
  (let ((8number (cl:parse-integer (ascii-to-string
				     (substring 8array1 index1 (+ index1 count)))
				   :radix 10.
				   :junk-allowed nil
				   :sign-allowed nil)))
    (= 8number number2)))

(defun array-string-get (8array start end)
  (let ((answer (make-array (- end start) ':type 'art-string))
	(8array 8array))
    (declare (sys:array-register 8array answer))
    (loop for 8ix from start below end
	  for ansx upfrom 0
	  do (setf (aref answer ansx) (code-char (aref 8array 8ix))))
    answer))

(defun defstorage-rt-make-string (8array start len)	;better version
  (let ((answer (make-array len ':type 'art-string))
	(8array 8array))
    (declare (sys:array-register 8array answer))
    (loop for 8ix upfrom start
	  for ansx upfrom 0 below len
	  do (setf (aref answer ansx) (code-char (aref 8array 8ix))))
    answer))

(defun defstorage-rt-make-ascii-string (8array start len)	;best version
  (cl:make-array len :element-type 'cl:string-char :displaced-to 8array :displaced-index-offset start))

(defun defstorage-rt-make-unsigned-fixed-decimal (8array start len)
  (let ((char-form (ascii-to-string 8array)))
    (cl:parse-integer char-form :radix 10. :junk-allowed nil :sign-allowed nil
		      :start start :end (+ start len))))

(defun defmacro%store-substring (val 8array 8start len)
  (let ((8array 8array)
	(val val))
    (declare (sys:array-register 8array val))
    (loop for valx upfrom 0 below len
	  for 8x upfrom 8start
	  do (setf (aref 8array 8x) (char-code (aref val valx))))
    nil))


(defun defstorage-store-ascii-substring (val 8array 8start len)
  (let ((8array 8array)
	(val val))
    (declare (sys:array-register 8array val))
    (loop with val-length = (cl:length val) with ascii-space = (char-to-ascii #\Space)
	  for valx upfrom 0 below len 
	  for 8x upfrom 8start
	  do (setf (aref 8array 8x)
		   (if (< valx val-length) (char-to-ascii (aref val valx))
		       ascii-space)))
    nil))

(defun defstorage-store-unsigned-fixed-decimal (val 8array 8start len)
  (let ((8array 8array)
	(val (string-to-ascii (format nil "~V,'0D" len val))))
    (declare (sys:array-register 8array val))
    (loop for valx upfrom 0 below len
	  for 8x upfrom 8start
	  do (setf (aref 8array 8x) (aref val valx))))
  nil)

(defconstant *BITS-PER-WORD* 32.)
(defconstant *BITS-PER-CHAR* 8.)
(defconstant *CHARS-PER-WORD* 4.)
(defconstant *BYTES-PER-WORD* 4.)
(defconstant *BITS-PER-BYTE* 8.)

(defconst *DEFSTORAGE-DEFAULT-TYPE* 'fixnum)
(defconst *DEFAULT-CHAR-LENGTH* 4)
(defconst *DEFAULT-FIXNUM-BYTES* 4.)
(defconst *DEFAULT-BIT-LENGTH* 1)

(defvar *defstorage-report* nil)
(defvar *defstorage-punt* nil)
(defvar *defstorage-top-level-name* nil)

(defvar *defstorage-word*)
(defvar *defstorage-bit*)
(defvar *defstorage-compile-queue*)
(defvar *defstorage-runtime-info*)
(defvar *defstorage-subscript-expression* nil)
(defvar *defstorage-index-offset*)
(defvar *defstorage-processing-element* nil)
(defvar *defstorage-dimstack* nil)
(defvar *defstorage-multiplier-stack* nil)
(defvar *defstorage-subscript-bitp* nil)
(defvar *defstorage-subscripts* nil)
(defvar *defstorage-reversed-subscripts* nil)
(defvar *bigender* nil)
(defun make-bytespec (length offset)
  `(byte ,length ,(if *bigender* (- 8 offset length)  offset)))
(defun make-aref (array index length offset)
  ``(aref ,,array ,,(if *bigender* ``(- (+ ,,length (* 2 ,,offset)) ,,index 1) index)))

(defflavor defstorage-error-condition (message) (condition)
  (:initable-instance-variables))

(defmethod (:report defstorage-error-condition) (stream)
  (send stream ':string-out message))

(compile-flavor-methods defstorage-error-condition)

(defprop defstorage-error t :error-reporter)
(defun defstorage-error (ctl-string &rest format-args)
  (signal 'defstorage-error-condition
	    ':message (format nil "defstorage: ~1{~:}" ctl-string format-args))
  (let ((was-error *defstorage-punt*)
	(opts `(:function ,*defstorage-top-level-name* :definition-type defstorage)))
    (setq *defstorage-punt* t)
    (compiler:warn opts (string-append "~&~S: " ctl-string) 'defstorage format-args)
    (or was-error
	(compiler:warn opts "~&Fatal error.  No code will be generated for ~S."
		       *defstorage-top-level-name*))
    (*throw 'defstorage-error nil)))

;;; Storage-layout facility

(defmacro defstorage (namespec &body components)
  (let ((*defstorage-punt* nil)			;d-1 will punt if d-error errs.
	(*defstorage-top-level-name* (if (atom namespec)
					 namespec
					 (car namespec))))
    (if (variable-boundp compiler:file-warnings-history)
	(compiler:reset-function-warnings *defstorage-top-level-name* 'defstorage))
    (defstorage1 *defstorage-top-level-name*
		 (and (listp namespec)
		      (cdr namespec))
      components)))

(defprop defstorage "LMFS:DEFSTORAGE Structure" si:definition-type-name)

;;; Work-distributor for defstorage.  Returns a progn 'compile
;;; of all macros to be defined, and appropriate evalwhens.
(defun defstorage1 (structure-name plist components &aux final-bit final-byte final-word
		    alterant)
  (and *defstorage-report* (not (memq ':nocompile plist))
       (format t "~&Compiling (defstorage ~S). " structure-name))
  (let ((*defstorage-word* 0)
	(*defstorage-bit* 0)
	(*defstorage-compile-queue* nil)
	(*defstorage-runtime-info* nil)
	(*defstorage-subscript-expression* nil)
	(*defstorage-processing-element* nil)
	(*defstorage-subscripts* nil)
	(*bigender* (memq :bigender plist))
	(environment-var (gensymbol "ENVIRONMENT-")))
    (defstorage-include structure-name components plist)
    (setq final-bit (defstorage-bit))
    (defstorage-align 'byte)
    (setq final-byte (defstorage-byte))
    (defstorage-align 'word)
    (setq final-word *defstorage-word*)
    (if (or (memq ':constructor plist) (memq ':alterant plist))
	(push `(defmacro ,(setq alterant (fintern "ALTER-~A" structure-name)) (&rest x &environment ,environment-var)
		 (defstorage-mt-alter ',structure-name x ,environment-var))
	      *defstorage-compile-queue*))
    (if (memq ':constructor plist)
	(push (defstorage-construct-constructor structure-name final-byte alterant)
	      *defstorage-compile-queue*))
    (cond (*defstorage-punt*
	   (if (memq ':nocompile plist)		;don't cause get-elt-size to ferror
	       (putprop structure-name '(1 4 32.) 'defstorage-length-info)
	       (if *defstorage-report*
		   (format error-output
			   "~&Compilation of (defstorage ~S) failed due to errors."
			   structure-name))))
	  ((memq ':nocompile plist)
	   (putprop structure-name (list *defstorage-word* final-byte final-bit)
		    'defstorage-length-info)
	   (putprop structure-name (list plist components) 'defstorage-def)
	   nil)
	  (t
	   `(local-declare ((sys:function-parent ,structure-name defstorage))
	      (si:record-source-file-name ',structure-name 'defstorage)
	      (eval-when (compile load eval)
		(putprop ',structure-name ',(list plist components) 'defstorage-def)
 		(putprop ',structure-name
			 ',(sort *defstorage-runtime-info*
				 #'(lambda (x y) (< (second x) (second y))))
			 'defstorage-runtime-info)
		(putprop ',structure-name ,final-byte 'structure-size-in-bytes))
	      (defmacro ,(fintern "~S-SIZE-IN-BITS" structure-name) ()
		`(progn ,',final-bit))
	      (defmacro ,(fintern "~S-SIZE-IN-BYTES" structure-name) ()
		`(progn ,',final-byte))
	      (defmacro ,(fintern "~S-SIZE-IN-WORDS" structure-name) ()
		`(progn ,',final-word))		;first value...
	      . ,(nreverse *defstorage-compile-queue*))))))

(defun defstorage-construct-constructor (sname size-in-bytes alterant)
  (let ((gs (let ((default-cons-area working-storage-area)) (gensym))))
    `(progn 'compile
	    (putprop ',sname 'defstorage-named-structure-invoke 'named-structure-invoke)
	    (defmacro ,(fintern "MAKE-~A" sname) x
	      `(let ((,',gs (make-array ,,size-in-bytes ':type 'art-8b
					':leader-list '(,,size-in-bytes nil)
					':named-structure-symbol ',',sname)))
		 (,',alterant ,',gs . ,x)
		 ,',gs)))))

;;; Compile  a given structure, perhaps as itself, or perhaps
;;; as part of another structure.

(defun defstorage-include (structure-name components plist
			   &aux (union (memq ':union plist)))
  (*catch 'defstorage-error
    (let ((wordbase *defstorage-word*)
	  (bitbase *defstorage-bit*)
	  (bitmax 0))
      (dolist (component components)
	(if (atom component)
	    (setq component `(,component)))
	(if union (setq *defstorage-word* wordbase *defstorage-bit* bitbase))
	(destructuring-bind (component-name component-type . component-spec) component
	  (defstorage-process-element structure-name component-name
	    (or component-type *DEFSTORAGE-DEFAULT-TYPE*) component-spec))
	(if union (setq bitmax (max bitmax (defstorage-bit)))))
      (if union (setq *defstorage-word* (// bitmax *BITS-PER-WORD*)
		      *defstorage-bit* (mod bitmax *BITS-PER-WORD*))))))

;;; Compile one given element.  Handle accessor naming, inclusion
;;; of other structures, inclusion, and included-being.

(defun defstorage-process-element (structure name type spec &aux handler sdef rtype)
  (let ((accessor (if (member name '(* "ignore"))
		      structure
		      (fintern "~A-~A" structure name)))
	(save-queue *defstorage-compile-queue*)
	(save-info *defstorage-runtime-info*))
    (*catch 'defstorage-error
      (if (listp type)
	  (defstorage-error "Type is a list- probable syntax error: ~S" accessor))
      (let* ((*defstorage-processing-element* t)
	     (*defstorage-index-offset* (defstorage-compute-combined-index-offset)))
	(cond
	  ((setq handler (or (get (setq rtype type) 'defstorage-processor)
			     (get (setq rtype (intern-soft type *defstorage-package*))
				  'defstorage-processor)))
	   (cond ((memq rtype '(array structure union))
		  (funcall handler name structure spec))
		 (t (funcall handler accessor structure spec)))
	   (if (and (not (memq rtype '(structure array union being)))
		    (eq name '*))
	       (setq name "ignore")))
	  ((setq sdef (get type 'defstorage-def))
	   (let* ((plist (first sdef))
		  (components (second sdef))
		  (internal (first components)))
	     (if (= (length components) 1)
		 (defstorage-process-element structure name
		   (cadr internal) (cddr internal))
		 (defstorage-include accessor components plist))))
	  (t (defstorage-error "Unknown data type for ~S: ~S" accessor type)))
	(if (and (>= (string-length name) 6)
		 (string-equal "ignore" (substring name 0 6)))
	    (setq *defstorage-compile-queue* save-queue
		  *defstorage-runtime-info* save-info )))))) ;truncate to ignore what we did

(defun (structure defstorage-processor) (name structure spec)
  (defstorage-structure-union name structure spec '(nil)))

(defun (union defstorage-processor) (name structure spec)
  (defstorage-structure-union name structure spec '(nil :union)))

(defun defstorage-structure-union (name structure spec plist)
  (let ((accessor (cond ((eq name '*) structure)
			(t (fintern "~A-~A" structure name))))
	(bits-there (defstorage-bit)))
    (defstorage-include accessor spec plist)
    ;; Generate internal structure size-in-foo's for size of an element.
    (unless (or (eq name '*) (string-equal name "ignore"))
      (let ((bits (- (defstorage-bit) bits-there)))
	(push `(defmacro ,(fintern "~A-~A-SIZE-IN-BYTES" structure name)
			 () '(progn ,(ceiling bits *bits-per-byte*)))
	      *defstorage-compile-queue*)
	(if (zerop (mod bits *bits-per-word*))
	    (push `(defmacro
		     ,(fintern "~A-~A-SIZE-IN-WORDS" structure name) ()
		     '(progn ,(ceiling bits *bits-per-word*)))
		  *defstorage-compile-queue*))))))

;;;  Utilities of all handlers.

;;;  Align next allocation to some boundary.
;;;  Sort of a write-around to defstorage-add-units..

(defun defstorage-align (to-what)
  (let ((old-word *defstorage-word*)
	(old-bit *defstorage-bit*))
    (multiple-value (*defstorage-word* *defstorage-bit*)
      (defstorage-add-units 0 to-what *defstorage-word* *defstorage-bit*))
    (if (and *defstorage-processing-element*
	     (or ( old-word *defstorage-word*)
		 ( old-bit *defstorage-bit*)))
	(setq *defstorage-index-offset* (defstorage-compute-combined-index-offset))))
  *defstorage-word*)

;;; Compute a combined index offset expression, including all subscripts.

(defun defstorage-compute-combined-index-offset (&optional bitp)
  (let ((relevant-offset (if bitp (defstorage-bit) (defstorage-byte))))
    (cond ((zerop relevant-offset)
	   (or *defstorage-subscript-expression* 0))
	  ((null *defstorage-subscript-expression*)
	   relevant-offset)
	  (t ``(+ ,,relevant-offset
		  ,,*defstorage-subscript-expression*)))))

;;; Allocate storage by adding units.



(defun defstorage-add-units (how-many what word bit)
  (let* ((mods (if (numberp what)
		   what
		   (selectq what
		     (word	  *BITS-PER-WORD*)
		     ((byte char) *BITS-PER-CHAR*)
		     (bit	  1)
		     (t  (defstorage-error "Obscure units: ~S, bytes used." what)
			 *BITS-PER-BYTE*))))
	 (gross-bits (* mods (+ how-many
				(// (+  (* word *BITS-PER-WORD*)
					bit mods -1)   ;align to mods, round up
				    mods)))))
    (values (//  gross-bits *BITS-PER-WORD*)		;word
	    (mod gross-bits *BITS-PER-WORD*))))		;bit

(defun defstorage-increment (how-many what)
  (multiple-value (*defstorage-word* *defstorage-bit*)
    (defstorage-add-units how-many what *defstorage-word* *defstorage-bit*)))

(defun defstorage-bit () (+ *defstorage-bit* (* *defstorage-word* *BITS-PER-WORD*)))
(defun defstorage-byte () (// (+ *defstorage-bit* (* *defstorage-word* *BITS-PER-WORD*))
			      *BITS-PER-BYTE*))

;;;
;;;	Actual handlers for different types
;;;

(defun (char-with-length defstorage-processor) (accessor ignore spec)
  (defstorage-char-with-length accessor spec 2))

;;;Note that short-char-with-length needs no special runtime encoding.
(defun (short-char-with-length defstorage-processor) (accessor ignore spec)
  (defstorage-char-with-length accessor spec 1))


(defun defstorage-char-with-length (accessor spec lenl)
  (let ((length (or (car spec) *DEFAULT-CHAR-LENGTH*))
	(environment-var (gensymbol "ENVIRONMENT-"))
	(length-accessor)
	(index-offset)
	(dindex-offset)
	(compare-accessor (fintern "~A-COMPARE" accessor))
	(ml-macro (fintern "~A-MAX-LENGTH" accessor)))
    
;;; Compile length-accessor recursively.
    
    (defstorage-align (if (= lenl 2) 16. 'byte))
    (setq index-offset *defstorage-index-offset*)	;snapshot it here
    
    (setq length-accessor (if (= lenl 1)
			      '*internal-one-byte-length-getter
			      '*internal-two-byte-length-getter))
			      
    (push `(defmacro ,ml-macro () `(progn ,',length))
	  *defstorage-compile-queue*)

    (let (*defstorage-runtime-info*)		;don't let it get out....
      (defstorage-process-element accessor "LENGTH" 'fixnum-bytes (list lenl)))

    ;; There are some once-only'ing problems here.
    (setq dindex-offset
	  (setq *defstorage-index-offset* (defstorage-compute-combined-index-offset)))
        
    (defstorage-encode-runtime-info accessor 'char-with-length (cons length lenl))

    (generate-defstorage-accessor
      accessor '8array
      (cond ((atom index-offset)		;not a subscripted reference
	     `(once-only (8array &environment ,environment-var)
		`(defstorage-rt-make-string
		   ,8array ,,dindex-offset (,',length-accessor ,8array ,,index-offset ))))
	    (t `(once-only (8array &environment ,environment-var)
		  `(let ((..index-offset.. ,,index-offset))
		     (defstorage-rt-make-string
		       ,8array (+ ,,lenl ..index-offset.. )
		       (,',length-accessor ,8array ..index-offset..))))))
      environment-var)

    (generate-defstorage-storer
      accessor '8array 'v
      (cond ((atom index-offset)
	     `(once-only (8array v &environment ,environment-var)
		`(let ((v-stringlen (min ,',length (string-length ,v))))
		   (defmacro%store-substring
		     ,v ,8array ,,dindex-offset v-stringlen)
		   (setf (,',length-accessor ,8array ,,index-offset) v-stringlen))))
	    (t `(once-only (8array v &environment ,environment-var)
		  `(let* ((v-stringlen (min ,',length (string-length ,v)))
			  (..index-offset.. ,,index-offset)
			  (..index-offset+lenl.. (+ ..index-offset.. ,,lenl)))
		     (defmacro%store-substring
		       ,v ,8array ..index-offset+lenl.. v-stringlen)
		     (setf (,',length-accessor ,8array ..index-offset..) v-stringlen)))))
      environment-var)

    (push
      `(defmacro ,compare-accessor (8array value ,@*defstorage-reversed-subscripts* &environment ,environment-var)
	 ;; Hell with aggregate references
	 ;; For a start, they're meaningless
	 (once-only (8array value &environment ,environment-var)
	   `,,(cond ((atom index-offset)
		     ``(let ((datl (,',length-accessor ,8array ,',index-offset)))
			 (and 
			   (= (string-length ,value) datl)
			   (defstorage%string-equal ,8array ,',dindex-offset ,value 0 datl))))
		    (t
		     ``(let* ((..index-offset.. ,,index-offset)
			      (datl (,',length-accessor 8array ..index-offset..)))
			 (and
			   (= (string-length ,value) datl)
			   (defstorage%string-equal
			     ,8array (+ ..index-offset ,,lenl) ,value 0 datl)))))))
      *defstorage-compile-queue*)
    
    (defstorage-increment length 'char)))

(defun (char defstorage-processor)  (accessor ignore spec)
  (let ((length (or (car spec) *DEFAULT-CHAR-LENGTH*))
	(compare-accessor (fintern "~A-COMPARE" accessor)))

    (defstorage-align 'byte)
    (defstorage-encode-runtime-info accessor 'char length)

    (generate-defstorage-accessor
      accessor '8array
      ``(defstorage-rt-make-string ,8array ,,*defstorage-index-offset* ,,length))

    (push
     `(defmacro ,compare-accessor (8array value . ,*defstorage-reversed-subscripts*)
	`(defstorage%string-equal
	   ,8array ,,*defstorage-index-offset* ,value 0 ,',length))
     *defstorage-compile-queue*)

    (generate-defstorage-storer
      accessor '8array 'v
      ``(defmacro%store-substring ,v ,8array ,,*defstorage-index-offset* ,',length))
    (defstorage-increment length 'char)))

(defun (:property ascii-char defstorage-processor) (accessor ignore spec)
  (let ((length (or (car spec) *DEFAULT-CHAR-LENGTH*))
	(compare-accessor (fintern "~A-COMPARE" accessor)))
    (defstorage-align 'byte)
    (defstorage-encode-runtime-info accessor 'char length)
    
    (generate-defstorage-accessor
      accessor '8array
      ``(defstorage-rt-make-ascii-string ,8array ,,*defstorage-index-offset* ,,length))
    
    (push
      `(defmacro ,compare-accessor (8array value . ,*defstorage-reversed-subscripts*)
	 `(defstorage-ascii-string=
	    ,8array ,,*defstorage-index-offset* ,value 0 ,',length))
      *defstorage-compile-queue*)
    
    (generate-defstorage-storer
      accessor '8array 'v
      ``(defstorage-store-ascii-substring ,v ,8array ,,*defstorage-index-offset* ,',length))
    (defstorage-increment length 'char)))

(defun (:property unsigned-fixed-decimal defstorage-processor) (accessor ignore spec)
  (let ((length (or (car spec) *DEFAULT-CHAR-LENGTH*))
	(compare-accessor (fintern "~A-COMPARE" accessor)))
    (defstorage-align 'byte)
    (defstorage-encode-runtime-info accessor 'char length)
    
    (generate-defstorage-accessor
      accessor '8array
      ``(defstorage-rt-make-unsigned-fixed-decimal
	  ,8array ,,*defstorage-index-offset* ,,length))
    
    (push
      `(defmacro ,compare-accessor (8array value . ,*defstorage-reversed-subscripts*)
	 `(defstorage-unsigned-fixed-decimal-equal
	    ,8array ,,*defstorage-index-offset* ,value 0 ,',length))
      *defstorage-compile-queue*)
    
    (generate-defstorage-storer
      accessor '8array 'v
      ``(defstorage-store-unsigned-fixed-decimal
	  ,v ,8array ,,*defstorage-index-offset* ,',length))
    (defstorage-increment length 'char)))

;;;Byte is a special case instead of being fixnum-bytes 1 because the long-field
;;;processor is not modularized well enough so that unnecessary once-onlification
;;;is not done in the one-byte case.
(defun (byte defstorage-processor) (accessor ignore spec)
  (if spec
      (defstorage-error "~S not understood for BYTE field (BYTE fields have no width)."
			spec))
  (defstorage-align 'byte)
  (defstorage-encode-runtime-info accessor 'fixnum-bytes 1)
  (generate-defstorage-accessor
    accessor '8ary ``(aref ,8ary ,,*defstorage-index-offset*))
  (generate-defstorage-storer
    accessor '8ary 'v ``(aset ,v ,8ary ,,*defstorage-index-offset*))
  (defstorage-increment 1 'byte))

(defun (fixnum defstorage-processor)  (accessor &rest ignore)
  (defstorage-align 'word)
  (funcall (get 'fixnum-bytes 'defstorage-processor) accessor nil '(4)))

(defun (fixnum-bytes defstorage-processor) (accessor ignore spec)
  (let ((length (or (car spec) *DEFAULT-FIXNUM-BYTES*)))
    (cond ((or (not (fixp length))
	       (< length 1)
	       (> length 8.))
	   (defstorage-error "Invalid fixnum length: ~D" length))
	  ((= length 1)				;simplifies binding var-x-offset issue
	   (funcall (get 'byte 'defstorage-processor) accessor nil nil))
	  (t
	   (defstorage-align 'byte)
	   (defstorage-encode-runtime-info accessor 'fixnum-bytes length)
	   (defstorage-long-field-processor accessor 0 (* length *BITS-PER-BYTE*))
	   (defstorage-increment length 'byte)))))

(defun defstorage-long-field-processor (accessor bits-not-in-first-byte bit-length)
  (let* ((index-offset (defstorage-byte))
	 (number-of-bytes-involved (// (+ bits-not-in-first-byte bit-length
					  *bits-per-byte* -1)
				       *bits-per-byte*))
	 (bits-not-in-last-byte (- (* number-of-bytes-involved *bits-per-byte*)
				   (+ bits-not-in-first-byte bit-length)))
	 (bits-in-last-byte (- *bits-per-byte* bits-not-in-last-byte))
	 (bits-in-first-byte (- *bits-per-byte* bits-not-in-first-byte))
	 (environment-var (gensymbol "ENVIRONMENT-")))
    (do ((ixo index-offset (1+ ixo))
	 ;; make obj code slightly less gross.. 
	 (cixo (if (null *defstorage-subscript-expression*)
		   index-offset
		   ``,variable-index-offset)
	       (if (numberp cixo)
		   (1+ ixo)
		   ``(+ ,,ctr ,variable-index-offset)))
	 (byte-specifier)
	 (first t nil)
	 (length number-of-bytes-involved (1- length))
	 (ctr 1 (1+ ctr))
	 (ldbr nil)
	 (dpbr nil)
	 (vgen (and *defstorage-subscript-expression*
		    *defstorage-index-offset*)))
	((= length 0)
	 (generate-defstorage-accessor
	   accessor '8ary
	   `(once-only (8ary &environment ,environment-var)
	      ,(if vgen
		   `(let ((variable-index-offset ,vgen))
		      (once-only (variable-index-offset &environment ,environment-var) ,dpbr))
		   dpbr))
	   environment-var)
	 (generate-defstorage-storer
	   accessor '8ary 'val
	   `(once-only (8ary val &environment ,environment-var)
	      ,(if vgen
		   `(let ((variable-index-offset ,vgen))
		      (once-only (variable-index-offset &environment ,environment-var)
			`(progn . ,,ldbr)))
		   ``(progn . ,,ldbr)))
	   environment-var))

      (setq byte-specifier
	    `(byte ,(cond (first bits-in-first-byte)
			  ((= length 1) bits-in-last-byte)
			  (t *bits-per-byte*))
		   ,(if first
			0
			(+ (* (- ctr 2) *bits-per-byte*) bits-in-first-byte))))

      (let* ((basic-ldbr ``(ldb ,',byte-specifier ,val))
	     (areffer (make-aref '8ary 
				  cixo 
				  number-of-bytes-involved
				  index-offset)))

	     (if *bigender*
		 (cond ((and first
			     (plusp bits-not-in-last-byte))
			(setq basic-ldbr
			      ``(dpb ,,basic-ldbr ,',(make-bytespec bits-in-last-byte 0)
				     ,,areffer))
			(setq areffer ``(ldb ,',(make-bytespec bits-in-last-byte 0) ,,areffer)))
		       ((and (= length 1)
			     (plusp bits-not-in-first-byte))
			(setq basic-ldbr
			      ``(dpb ,,basic-ldbr ,',(make-bytespec bits-in-first-byte bits-not-in-first-byte)
				     ,,areffer))
			(setq areffer ``(ldb ,',(make-bytespec bits-in-first-byte bits-not-in-first-byte)
					     ,,areffer))))
		 (cond ((and first
			     (plusp bits-not-in-first-byte))
			(setq basic-ldbr
			      ``(dpb ,,basic-ldbr (byte ,,bits-in-first-byte ,,bits-not-in-first-byte)
				     ,,areffer))
			(setq areffer ``(ldb (byte ,,bits-in-first-byte ,,bits-not-in-first-byte)
					     ,,areffer)))
		       ((and (= length 1)
			     (plusp bits-not-in-last-byte))
			(setq basic-ldbr
			      ``(dpb ,,basic-ldbr (byte ,,bits-in-last-byte 0)
				     ,,areffer))
			(setq areffer ``(ldb (byte ,,bits-in-last-byte 0) ,,areffer)))))
	     (setq ldbr
		   ``((aset ,,basic-ldbr ,8ary
			    ,,(if *bigender*
				  ``(- (+ ,,number-of-bytes-involved
					  (* 2 ,,index-offset)) ,,cixo 1)
				  cixo)) . ,,ldbr))
	(setq dpbr
	      (if (null dpbr)
		  areffer		
		  ``(dpb ,,areffer ,',byte-specifier ,,dpbr)))))))

(defun (bit defstorage-processor)  (accessor ignore spec)
  (let ((xbit (mod *defstorage-bit* *BITS-PER-BYTE*))
	(environment-var (gensymbol "ENVIRONMENT-"))
	(bit-length (or (car spec) *DEFAULT-BIT-LENGTH*)))
    (cond ((and (= bit-length *bits-per-byte*)
		(or *defstorage-subscripts*
		    (zerop xbit)))
	   (funcall (get 'byte 'defstorage-processor) accessor nil nil))
	  (*defstorage-subscript-bitp*		;implies array going on...
	   (cond ((not (mod *bits-per-byte* bit-length))
		  (defstorage-error "Temporary restriction- bit arrays ~
				can only be factors of ~D, not ~D (~A)"
				    *bits-per-byte* bit-length accessor))
		 (t (defstorage-bit-array
		      accessor bit-length 'bit-array 'bit-array-accessor 'bit-array-storer))))
	  ((or (> bit-length *bits-per-byte*)
	       (> (+ xbit bit-length) *bits-per-byte*))
	   (defstorage-encode-runtime-info accessor 'bit bit-length)
	   (defstorage-long-field-processor accessor xbit bit-length)
	   (defstorage-increment bit-length 'bit))
	  ;; Guaranteed to be in one byte.
	  (t

	   (defstorage-encode-runtime-info accessor 'bit bit-length)
	   (let ((byte-specifier (make-bytespec bit-length xbit)))
	     (generate-defstorage-accessor
	       accessor '8ary
	       ``(ldb ,',byte-specifier (aref ,8ary ,,*defstorage-index-offset*)))
	     (generate-defstorage-storer
	       accessor '8ary 'val
	       (once-onlify-index-offset
		 `(once-only (8ary &environment ,environment-var)
		    `(aset
		      (dpb ,val ,',byte-specifier
			   (aref ,8ary ,,*defstorage-index-offset*))
		      ,8ary ,,*defstorage-index-offset*))
		 environment-var)
	       environment-var))
	   (defstorage-increment bit-length 'bit)))))

(defun defstorage-bit-array (accessor bit-length type getter storer)
  (cond ((zerop (mod *defstorage-bit* bit-length)))
	;;Line it up at a boundary of its own kind. 
	(t (defstorage-increment (- bit-length (mod *defstorage-bit* bit-length)) 'bit)))
  (let-if (not *defstorage-subscript-bitp*)
	  ((*defstorage-multiplier-stack* (cons (* *BITS-PER-BYTE*
						   (car *defstorage-multiplier-stack*))
						(cdr *defstorage-multiplier-stack*)))
	   (*defstorage-subscript-expression* ``(* ,',*bits-per-byte*
						   ,,*defstorage-subscript-expression*))
	   (*defstorage-subscript-bitp* t))
    (let ((*defstorage-index-offset* (defstorage-compute-combined-index-offset t))
	  (mask (1- (ash 1 bit-length))))
      (defstorage-encode-runtime-info accessor type bit-length)
      (generate-defstorage-accessor
	accessor '8ary ``(,',getter ,8ary ,,*defstorage-index-offset* ,,mask))
      (generate-defstorage-storer
	accessor `8ary 'v ``(,',storer ,8ary ,v ,,*defstorage-index-offset* ,,mask))
      (defstorage-increment bit-length 'bit))))

(defsubst flag-array-getter (8a ixo &rest ignore)
  (plusp (bit-array-accessor 8a ixo 1)))

(defsubst flag-array-storer (8a v ixo &rest ignore)
  (bit-array-storer 8a (if v 1 0) ixo 1))

(defun (flag defstorage-processor) (accessor &rest ignore)
  (let ((xbit (mod  *defstorage-bit* *BITS-PER-BYTE*))
	(environment-var (gensymbol "ENVIRONMENT-")))
    (cond
      ((null *defstorage-subscript-bitp*)	;includes not subscripting at all
       (defstorage-encode-runtime-info accessor 'flag (ash 1 xbit))
       (generate-defstorage-accessor
	 accessor '8ary
	 ``(bit-test ,,(if *bigender* (ash 1_7 (- xbit)) (ash 1 xbit))
		     (aref ,8ary ,,*defstorage-index-offset*)))
       (generate-defstorage-storer
	 accessor '8ary 'v
	 `(once-only (8ary &environment ,environment-var)
	    ,(once-onlify-index-offset
	       ``(aset
		  ,(let ((byteget `(aref ,8ary ,,*defstorage-index-offset*)))
		     (if (defstorage-conboolable* v)
			 (defstorage-conboole* v ,xbit byteget)
			 `(dpb (if ,v 1 0)
			       ,',(make-bytespec 1 xbit)
			       ,byteget)))
		  ,8ary
		  ,,*defstorage-index-offset*)
	       environment-var))
	 environment-var)
       (defstorage-increment 1 'bit))
      (t					;working in bits => an array of flags
       (defstorage-bit-array accessor 1 'flag-array 'flag-array-getter 'flag-array-storer)))))



(defun (array defstorage-processor) (name structure spec &aux bitp eltsize)
  (destructuring-bind (dims data-type . type-details) spec
    (if (atom dims) (setq dims (list dims)))
    (or (get data-type 'defstorage-def)
	(setq data-type (or (intern-soft data-type *defstorage-package*)
			    (defstorage-error "Unknown array type: ~S" data-type))))
    (setq eltsize (defstorage-get-array-element-size (cons data-type type-details)))
    (or (loop for x in dims
	      always (or (and (fixp x) (plusp x))
			 (eq x '*)))
	(defstorage-error "Invalid array dims: ~S - ~A" dims name))
    (if (or (and (eq (car dims) '*)
		 *defstorage-dimstack*)
	    (memq '* (cdr dims)))
	(defstorage-error "Invalid context for boundless array: ~A" name))

    (defstorage-align (selectq data-type
			((bit flag) (setq bitp t) 'bit)
			(fixnum 'word)
			(t 'byte)))

    (let* ((new-subscript-vars
	     (loop repeat (length dims)
		   for i upfrom (1+ (length *defstorage-subscripts*))
		   collect (fintern "SUBSCRIPT-~D" i)))
	   (*defstorage-reversed-subscripts*
	     (append (reverse *defstorage-subscripts*) new-subscript-vars))
	   (*defstorage-subscripts*
	     (append (reverse new-subscript-vars) *defstorage-subscripts*))
	   (*defstorage-dimstack* (append (reverse dims) *defstorage-dimstack*))
	   (*defstorage-multiplier-stack*
	     (append (loop with gross = 1
			   for coef in (reverse (append (cdr dims) '(1)))
			   collect (* eltsize (setq gross (* gross coef))))
		     *defstorage-multiplier-stack*))
	   (*defstorage-subscript-expression*
	     (compute-defstorage-subscript-expression bitp eltsize dims new-subscript-vars))
	   (*defstorage-subscript-bitp* bitp))	;working in bits?
      ;; It would be too easy to lambda-bind the allocation counters around
      ;; this call. However, only the element-processor knows how to ALIGN
      ;; the array before allocating any.  So we can't.  Maybe the aligner
      ;; should be a separate dispatch?
      (defstorage-process-element structure name data-type type-details)
      ;; Take advantage of knowing that the current allocation must be
      ;; aligned in the units of which the array is allocated.
      ;; Decrement out for the one element allocated by processing the element.
      (let ((eincrement (* eltsize (if bitp 1 *BITS-PER-BYTE*))))
	(let ((tbits (- (defstorage-bit) eincrement)))
	  (setq *defstorage-bit* (mod tbits *BITS-PER-WORD*)	;this word stuff...
		*defstorage-word* (// tbits *BITS-PER-WORD*)))
	(if (not (memq '* dims))
	    (defstorage-increment (* eincrement (apply #'* dims)) 'bit))))))



(defun defstorage-get-array-element-size (spec &aux (type (car spec)))
  (selectq type
    (fixnum 4)
    (byte 1)
    (char-with-length (+ 2 (cadr spec)))
    (short-char-with-length (+ 1 (cadr spec)))
    (flag 1)					;known to be bitp
    ((char bit fixnum-bytes)
     (or (cadr spec)	;note that it knows BIT is bitp
	 (selectq (cadr spec)
	   (char *default-char-length*)
	   (bit *default-bit-length*)
	   (fixnum-bytes *default-fixnum-bytes*))))
    (t (cond ((get type 'structure-size-in-bytes))
	     ;;Until reasonable policy figured out, arrays of sub-byte structures don't work.
	     ((memq type '(structure union))
	      (let ((gs (gensym)))
		(defstorage1 gs '(nil :nocompile) (cdr spec))
		(let ((info (get gs 'defstorage-length-info)))
		  (cond ((null info)
			 (ferror "Can't get length info?? ~S" spec))
			(( (third info) (* (second info) *BITS-PER-BYTE*))
			 (ferror "Can't array structures not integral # of bytes - ~S"
				  spec))
			(t (second info))))))
	     (t (ferror "Can't get structure size: ~S" type))))))

(defun compute-defstorage-subscript-expression (bitp eltsize dims vars)
  (let ((prev-exp				;bug with :the-form in wrapper
	  ;;Really want to combine constant multiply here, but hacking the
	  ;;backquoted crap programmably is too hard and non-modular. Too bad
	  ;;the compiler doesn't hack it.
	  (wrap-if (and bitp *defstorage-subscript-expression*)
		   ``(* ,,:the-form ,',*bits-per-byte*)
		   *defstorage-subscript-expression*)))
   (wrap-if prev-exp
	   ``(+ ,,prev-exp ,,:the-form)
	   (wrap-if (> eltsize 1)
		    ``(* ,,:the-form ,',eltsize)
		    (loop for var in vars
			  for answer first var
				     then ``(+ (* ,,answer ,',dim) ,,var)
			  for dim in (cdr dims)
			  finally (return answer))))))

(defun (mod defstorage-processor)  (ignore ignore spec)
  (let ((realkey (intern-soft (car spec) *defstorage-package*)))
    (if (and realkey (memq realkey '(word bit byte char)))
	(defstorage-align realkey)
	(defstorage-error "Invalid mod specification: ~S" spec))))

(defun (being defstorage-processor)  (ignore sname spec)
  (let ((type (car spec))
	(specs (cdr spec)))

    (if (atom type)
	(setq spec nil)
	(psetq type (car type) spec (cdr type)))

    (dolist (member specs)
      (defstorage-process-element sname member type spec))))


;;;
;;;
;;;   Output department.
;;;   (Potentially) aggregate initializer/lister generators for arrays
;;;   Note that calls to the aggregate reference generators are generated 
;;;   in any case, because they do checking, and we want to minimize
;;;   the amount of duplicated code in generated functions.
;;;

(defun generate-defstorage-accessor (name pointer-var get-one-form &optional (environment-var (gensymbol "ENVIRONMENT-")))
  (push
    `(macro ,name (macroarg ,environment-var)
	    (declare (arglist ,pointer-var . ,*defstorage-reversed-subscripts*))
	    (if (= (length macroarg) ,(+ 2 (length *defstorage-subscripts*)))
		(si:destructuring-bind
		  (nil ,pointer-var . ,*defstorage-reversed-subscripts*) macroarg
		  ,get-one-form)
		;; Let him do error checking.
		(defstorage-mt-aggregate-accessor-generator
		  macroarg ',*defstorage-dimstack*
		  ,environment-var)))
    *defstorage-compile-queue*))

(defun generate-defstorage-storer (name pointer-var value-var set-one-form &optional (environment-var (gensymbol "ENVIRONMENT-")))
  (push
    ;; Ours morts!
    ;; The new compile-time-side-effects-system is needed here
    `(eval-when (compile load eval)
       (cl:defsetf ,name (&whole macroarg
				 &rest ignore
				 ,@(when environment-var
				     `(&environment ,environment-var)))
		   (,value-var)
	 (if (= (length macroarg) ,(+ 2 (length *defstorage-dimstack*)))
	     (si:destructuring-bind
	       (nil ,pointer-var . ,*defstorage-reversed-subscripts*) macroarg
	       ,set-one-form)
	     ;; Let him do error checking.
	     (defstorage-mt-aggregate-storer-generator
	       macroarg ,value-var ',*defstorage-dimstack*
	       ,environment-var))))
    *defstorage-compile-queue*))

;;;  Encode runtime info.

(defun defstorage-encode-runtime-info (name data-type size)
  (if (assq name *defstorage-runtime-info*)
      (defstorage-error "Duplicate definition: ~S" name))
  (push
    `(,name ,(defstorage-bit)
      (,data-type ,size
       ,@(and *defstorage-subscript-expression*
	      `(,*defstorage-dimstack* ,*defstorage-multiplier-stack*))))
	  *defstorage-runtime-info*))

;;; Macro time, not macro-macro time fcns

(defun defstorage-mt-aggregate-accessor-generator (form dims env)
  (defstorage-mt-validate form dims)
  (destructuring-bind (name p) form
    (once-only (p &environment env)	    ;not multiple appearances, but multi iteration
      (loop with gsl = (perm-gensym-list (length dims))
	    with form = `(,name ,p . ,(reverse gsl))
	    finally (return form)
	    for sub in gsl
	    for dim in dims
	    do (setq form `(loop for ,sub from 0 below ,dim collect ,form))))))

(defun defstorage-mt-aggregate-storer-generator (form value dims env)
  (defstorage-mt-validate form dims)
  (destructuring-bind (name p) form
    (once-only (p &environment env)				;not multiple appearances, but multi iteration
      (loop with  gsl = (perm-gensym-list (length dims))
	    with varl = (perm-gensym-list (length dims))
	    with form = `(setf (,name ,p . ,(reverse gsl)) ,(car varl))
	    finally (return form)
	    for sub in gsl
	    for (var next) on varl
	    for dim in dims
	    do (setq form `(loop for ,sub from 0 below ,dim
				 for ,var in ,(or next value)
				 do ,form))))))

(defprop defstorage-mt-validate t :error-reporter)
(defun defstorage-mt-validate (form dims)
  (destructuring-bind (nil p subsclist) form
    (when (null p)
      (ferror "Defstorage data pointer missing or NIL? - ~S"))
    (when (not (null subsclist))		;right number already checked
      (ferror "Wrong number of dimensions: ~S" form))
    (when (memq '* dims)
      (ferror "Aggregate access to * extent array not meaningful - ~S" form))))


(defun perm-gensym-list (len)
  (let ((default-cons-area working-storage-area))
    (loop repeat len collect (gensym))))

(defun defstorage-conboolable* (v)
  (cond ((memq v '(t nil)) t)
	((atom v) nil)
	((atom (cdr v)) nil)
	((memq (cadr v) '(t nil)) t)
	(t nil)))

(defun defstorage-conboole* (val bitno wordgetter)
  (let ((mask (ash 1 bitno))
	(tornil (if (atom val)
		    val
		    (cadr val)))
	(boole 1))
    (if tornil
	(setq boole 7)
	(setq mask (boole 6 -1 mask)))
    `(boole ,boole ,mask ,wordgetter)))

(defun defstorage-mt-alter (structure-name args environment-var)
  (or args (ferror "Bad call to alter a ~S: no object supplied"))
  (let ((obj (car args))
	(info (or (get structure-name 'defstorage-runtime-info)
		  (ferror "Structure ~S has no runtime info?" structure-name))))
    (once-only (obj &environment environment-var)
      (cons
	'progn
	(loop for (name val) on (cdr args) by 'cddr
	      for accessor = (or (loop with sought = (format nil "~A-~A" structure-name name)
				       for (ac) in info
				       when (string-equal (get-pname ac) sought)
					 return ac)
				 (ferror "Unknown slot in ~S: ~S" structure-name name))
	      collect `(setf (,accessor ,obj) ,val))))))

;;; True runtime

(defun bit-array-accessor (8ary cixo mask)
  (logand mask (ash (aref 8ary (// cixo *BITS-PER-BYTE*))
		    (- (mod cixo *BITS-PER-BYTE*)))))

(defun bit-array-storer (8ary v cixo mask)
  (let* ((8off (// cixo *BITS-PER-BYTE*))
	 (shift (mod cixo *BITS-PER-BYTE*))
	 (now (aref 8ary 8off))
	 (smask (ash mask shift)))
    (aset (logxor (logand smask (logxor (logand smask (ash v shift))
					now))
		  now)
	  8ary 8off)))

;;;----------------------------------------------------------------------


;;;  A TOOL  (i.e., crufty, kludgey implementation of symbol finding, etc.)
;;;  Left over from Maclisp, but still useful

(defun defstorage-test-display (sname)
  (let ((def (get sname 'defstorage-def)))
    (if (null def) (ferror "Not a known structure: ~S" sname))
    (defstorage-display-recurse sname def))
  (defstorage-display-sym1
    (cdr (fsymeval (fintern "~A-~A" sname "SIZE-IN-WORDS")))
    (subst nil nil '((x)))
    ()
    "size in words"
    sname))

(defun defstorage-display-recurse (sname def)
  (let ((components (second def)))
    (dolist (component components)
      (let* ((name (first component))
	     (accessor (fintern "~A-~A" sname name)))
	(if (getl accessor `(macro setf))
	    (defstorage-display-sym accessor)
	    (let ((type (second component)))
	      (if (eq type 'being)
		  (progn
		    (setq type (let ((type (third component)))
				 (if (atom type) (list type) type)))
		    (defstorage-display-recurse
		      sname
		      `(,(first def)
			,(mapcar #'(lambda (x) `(,x . ,type)) (cdddr component)))))
		  (if (string-equal (substring name 0 6) "ignore")
		      nil
		      (let ((internal-def
			     (or (get (second component) 'defstorage-def)
				 (ferror "No determinable info: ~S" component))))
			(defstorage-display-recurse accessor internal-def))))))))))

(defun defstorage-display-sym (sym)
  (defstorage-display-sym1
    (cdr (fsymeval sym))
    (subst nil nil '((x array-of-8s)))
    '(array-of-8s)
    "GET" sym)
  (defstorage-display-sym1
    (get sym 'setf)
    (subst nil nil '((x array-of-8s) value))
    '(array-of-8s value)
    "SET" sym))

(defun defstorage-display-sym1 (fcn args argl what sym)
  (format t "~%~%~A: ~A" sym what)
  (let ((random (fintern "*-~A-~A" what sym)))
    (eval
     `(defun ,random ,argl ,(apply fcn args)))
    (eval `(cl:pprint (fdefintion ',random)))))




;;; Another Haarenkoenig.

;;; The point of this overgeneral hair is to address the following issue.  You say,
;;; "Gee, I like the way DEFSTORAGE generates ACCESSOR macros, SETF macros, and
;;; even *COMPARE* macros, but for shoe-horn-trumpet-name, I wish it would generate
;;; a FROBDICATE macro (something of "my" own devising) too!  So I want to tell it
;;; in general, how to define FROBDICATE macros, and then using what it thus defines,
;;; define FROBDICATE macros for shoe-horn-trumpet-name and whatever else I want".

(defmacro defdefstorage-macro-class (class-def-name sysargs runtime-args &body body)
  `(defmacro ,class-def-name (special-macro-name structure-name accessor-name)
     `(defmacro ,special-macro-name ,',runtime-args
	((lambda ,',sysargs
	    . ,',body)
	  . ,(get-defstorage-rtinfo accessor-name structure-name)))))


(defun get-defstorage-rtinfo (accessor structure)
  (let* ((sdef (or (get structure 'defstorage-runtime-info)
		   (ferror "Not a known DEFSTORAGE structure: ~S" structure)))
	 (def (or (assq accessor sdef)
		  (ferror "Can't find info for ~S in DEFSTORAGE structure ~S."
			  accessor structure))))
    (destructuring-bind (nil bit-offset (nil . other-info)) def
      (loop for x in 
	    (list* (// bit-offset *BITS-PER-BYTE*)
		   (mod bit-offset  *BITS-PER-BYTE*)
		   other-info)
	    collect (list 'quote x)))))

;;;          --- The intended use of the above hair ---
;;;
;;;(defdefstorage-macro-class defpartial-lengthed-string-match
;;;       (byte bit maxl ainfo) (p str strl)
;;;     bit maxl ainfo
;;;  `(defstorage%string-equal ,p ,byte ,str 0 ,strl))
;;;
;;;
;;;(defpartial-lengthed-string-match lmfs:partial-compare-dire-file-name
;;;				  lmfs:directory-entry lmfs:directory-entry-file-name)
;;;  
;;;  [M-X Macro Expand] (lmfs:partial-compare-dire-file-name dire nam naml)
;;;



;;; Ze runtime (for interpretive debugging) 8 April 82


;;;
;;; Used for picking up lengths of char-with-lengths
;;;

;;; used to be a defstorage, but that required two-pass compilation of this file.
(defmacro *internal-one-byte-length-getter (p x)
  `(aref ,p ,x))

(defmacro *internal-two-byte-length-getter (p x)     ;both things GUARANTEED TO BE ONCE-ONLIED
  `(dpb (aref ,p ,(cond ((numberp x) (1+ x)) (t `(1+ ,x))))
	(byte 8 8) (aref ,p ,x)))

(defun (:property *internal-two-byte-length-getter setf) (macroarg v)
  (destructuring-bind (nil p x) macroarg	;all things once-onlined
    `(progn (aset (ldb (byte 8 0) ,v) ,p ,x)
	    (aset (ldb (byte 8 8) ,v) ,p
		  ,(if (numberp x)
		       (1+ x)
		       `(1+ ,x))))))

(defselect defstorage-named-structure-invoke
  (:describe (ob &optional (standard-output standard-output))
    (defstorage-describe ob (array-leader ob 1))))

(defun defstorage-describe (p structure)
  (loop with sname = structure
	with snamel = (string-length structure)
	for element-data
	    in (or (get structure 'defstorage-runtime-info)
		   (ferror "Not a known DEFSTORAGE structure: ~S" structure))
	for val = (defstorage-extract-element p element-data)
	do (format t "~&  ~A:~33T~S"
		   (let ((name (car element-data)))
		     (cond ((string-equal sname name 0 0 nil snamel)
			    (substring name (1+ snamel)))
			   (t name)))
		   val))
  p)

(defun describe-defstorage (p structure)
  "Identical to defstorage-describe, whose name is too hard to remember."
  (defstorage-describe p structure))

(defun defstorage-extract-element (p data)
  (destructuring-bind (name bit-offset (type . other-info)) data
    (lexpr-funcall
      (or (get type 'defstorage-describe)
	  (ferror "Describe handler missing? ~S for ~S" type name))
      p
      (// bit-offset *BITS-PER-BYTE*)
      (mod bit-offset *BITS-PER-BYTE*)
      other-info)))

(defun (fixnum defstorage-describe) (p byte bit)
  (funcall (get 'fixnum-bytes 'defstorage-describe) p byte bit 4))

(defun (:property char-with-length defstorage-describe)
          (p byte ignore info &rest rest)
  (let (dims coefs max-length accessor-info)
    (if (numberp info)			;older than defstorage 194
	(setq max-length info accessor-info (car rest) rest (cdr rest))
	(setq max-length (car info) accessor-info (cdr info)))
    (setq dims (first rest) coefs (second rest))
    (cond ((listp accessor-info)		;older defstorage
	   (char-with-length-getter
	     p byte max-length (defstorage-extract-element p accessor-info)))
	  ((null dims)				;new kind of reference, but
						;not subscripted
	   (char-with-length-getter
	     p byte max-length (if (= accessor-info 1)
				   (aref p (1- byte))
				   (*internal-two-byte-length-getter p (- byte 2)))))
	  (t					;appear to be some dimensions
	   (defstorage-describe-arrayed-elements
	     "Arrayed char strings"  (get 'char-with-length 'defstorage-describe)
	     p byte dims coefs max-length accessor-info)))))

(defun char-with-length-getter (p byte max-length len)
  (cond ((> len max-length)
	 (format t "~&WARNING: Length ~S > Max length ~S :" len max-length)
	 (setq len max-length)))
  (defstorage-rt-make-string p byte len))

(defun (char defstorage-describe) (p byte ignore length &optional dims coefs)
  (if dims
      (defstorage-describe-arrayed-elements
	(format nil "Char ~D array" length)
	(get 'char 'defstorage-describe) p byte dims coefs length)
      (defstorage-rt-make-string p byte length)))

(defun (:property char-array defstorage-describe) (&rest rest)
  (lexpr-funcall (get 'char 'defstorage-describe) rest))

(defun (bit defstorage-describe) (p byte bit length &optional dims coefs)
  (cond (dims (defstorage-describe-arrayed-elements
		"Arrayed bit-structure" (get 'bit 'defstroage-describe)
		p byte dims coefs length))
	((> (+ length bit) *bits-per-byte*)
	 (let* ((number-of-bytes-involved (// (+ bit length *bits-per-byte* -1)
					      *bits-per-byte*))
		(bits-in-last-byte (- (+ bit length *bits-per-byte*)
				      (* number-of-bytes-involved *bits-per-byte*)))
		(i (1- number-of-bytes-involved))
		(first t)
		(total 0))
	   (loop for datum = (aref p (+ i byte))
		 for chunk =
		 (cond ((zerop i) (ldb (byte (- *bits-per-byte* bit) bit) datum))
		       (first
			(ldb (byte bits-in-last-byte 0) datum))
		       (t datum))
		 do
		 (setq total
		       (+ (ash total
			       (cond ((zerop i) (- *bits-per-byte* bit))
				     (first bits-in-last-byte)
				     (t *bits-per-byte*)))
			  chunk))
		 (setq first nil)
		 (if (zerop i) (return total))
		 (decf i))))
	(t (ldb (byte length bit) (aref p byte)))))

(defun (flag defstorage-describe) (p byte bit &optional (mask (ash 1 bit)) dims coefs)
  (cond (dims (defstorage-describe-arrayed-elements
		"Flag array" (get 'flag 'defstorage-describe) p byte dims coefs mask))
	(t (bit-test mask (aref p byte)))))

;;;Things packed by bit address
(defun (flag-array defstorage-describe) (p byte bit ignore dims coefs)
  (format t "~&    (Flag array ~S):" (reverse dims))
  (if (memq '* dims)
      '("Variable length array")
      (flag-array-runtime-from-bits
	(let ((getter (get 'bit 'defstorage-describe)))
	  (setq dims (reverse dims) coefs (reverse coefs))	;get biggest thing first
	  (defstorage-bit-array-recursive-getter p getter dims coefs byte bit 1)))))

(defun flag-array-runtime-from-bits (list)
  (loop for l on list
	for val = (car l)
	when (numberp val)
	do (rplaca l (plusp val))
	else do (flag-array-runtime-from-bits val))
  list)

(defun (fixnum-bytes defstorage-describe) (p byte ignore eltlen &optional dims coefs)
  (if dims
      (defstorage-describe-arrayed-elements
	(format nil "Fixnum ~D array" eltlen)
	(get 'fixnum-bytes 'defstorage-describe) p byte dims coefs eltlen)
      (loop with total = 0
	    for i from eltlen downto 1
	    finally (return total)
	    do (setq total (+ (ash total 8.) (aref p (+ byte i -1)))))))

(defun (:property fixnum-byte-array defstorage-describe) (&rest rest)	;compatibility
  (lexpr-funcall (get 'fixnum-bytes 'defstorage-describe) rest))

(defun defstorage-describe-arrayed-elements (descrip fcn p byte dims coefs &rest args)
  (format t "~&~4X(~A ~S):" descrip dims)
  (if (memq '* dims)
      '("Variable extent array.")
      (lexpr-funcall #'defstorage-byte-array-recursive-getter
		     p fcn (reverse dims) (reverse coefs) byte args)))

(defun defstorage-byte-array-recursive-getter (p getter dims coefs byte &rest args)
  (loop with (dim . restdims) = dims
	with (coef . restcoefs) = coefs
	for index from byte below (+ byte (* coef dim)) by coef
	when restdims
             collect (lexpr-funcall
		      #'defstorage-byte-array-recursive-getter p getter restdims restcoefs
		      index args)
	else collect (lexpr-funcall getter p index 0 args)))

(defun (bit-array defstorage-describe) (p byte bit eltlen dims coefs)
  (format t "~&    (Bit ~D array ~S):" eltlen (reverse dims))
  (if (memq '* dims)
      '("Variable length array")
      (let ((getter (get 'bit 'defstorage-describe)))
	(setq dims (reverse dims) coefs (reverse coefs))	;get biggest thing first
	(defstorage-bit-array-recursive-getter p getter dims coefs byte bit eltlen))))

(defun defstorage-bit-array-recursive-getter (p getter dims coefs byte bit eltlen)
  (loop with (dim . restdims) = dims
	with (coef . restcoefs) = coefs
	;; Note that last coef is measured in bits
	for index from 0 below (* coef dim) by coef
	when restdims
             collect (defstorage-bit-array-recursive-getter p getter restdims restcoefs
							     (+ index byte) bit eltlen)
	else collect (funcall getter p
			      (+ byte (// (+ bit index) *BITS-PER-BYTE*))
			      (mod (+ bit index) *BITS-PER-BYTE*)
			      eltlen)))

(sstatus feature defstorage)

