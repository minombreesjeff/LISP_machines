;;; -*- Syntax: Common-lisp; Mode: LISP; Package: NSAGE; Base: 10; Lowercase: T -*-
;;;
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;

;;;All the stuff on what an environment is; the "meanings" for commands

(defvar *COUNTER-TO-DEFAULT-FROM* ()
  "Set up by get-new-counter")

;;; Used to clear out old instances when flavors change incompatibly.
;;; D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")This definition must precede any occurrences of define-environment-attributes
0(defun INVALIDATE-COUNTER-CACHES ()
  (setq *counter-to-default-from* nil)
  (when (fdefinedp 'redo-named-counter-definitions)
    ;; When loading the system for the first time, this won't be defined yet,
    ;; but there is nothing for it to do anyway.
    (redo-named-counter-definitions)))

;;;The instance variables are the dynamic state parameters listed in appendix A of
;;; Brian's thesis.  These are related to the names used externally for environment
;;; attributes, but not on a one-one basis.

(define-environment-attributes font-environment
  (font-family
    :type :symbol
    :inheriting T
    :toplevel TIMES)
  (font-size
    :type vertical-distance
    :inheriting T
    :toplevel "10pt")
  (face-code
    :type :symbol
    :inheriting T
    :toplevel R)
  (environment-character-style
    :type T
    :default NIL)
  )

(defmethod (:font-triple font-environment) ()
  (values font-family font-size face-code))

(defmethod (CHARACTER-STYLE-FROM-ENVIRONMENT FONT-ENVIRONMENT) (device)
  (ignore device)
  (or environment-character-style
      (setq environment-character-style
	    (let ((cs-face (second (assoc face-code *face-code-alist*)))
		  (cs-size (first (find font-family *usage-code-alist*
					:test #'member :key #'rest))))
	      (unless cs-face
		(cerror "Use Roman"
			"Face code ~A not in face code alist." face-code)
		(setq cs-face :roman))
	      (unless cs-size
		(cerror "Use BodyFont (character style size :normal)"
			"Usage code ~a is not in usage code alist" font-family)
		(setq cs-size (or (first (find 'bodyfont *usage-code-alist*
					       :test #'member :key #'rest))
				  (error "Failed to find ~s in usage code alist" 'bodyfont))))
	      (values (si:intern-character-style nil cs-face cs-size))))))

(define-environment-attributes mouse-sensitivity-environment
  (mouse-sensitivity
    :type T
    :inheriting T
    :toplevel NIL))

(define-environment-attributes lisp-splicing-hook-environment
  (lisp-splicing-hook
    :type :symbol
    :default ()))

(define-environment-attributes (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")vertical-justification-environment
0  ;; Actually, there are oodles of attributes of 2formatting-environment
0  ;; that could be in here.  I really introduced this new environment
  ;; so that color patches that include nsage patches could be loaded
  ;; on top of concordia/nsage without screwing things up.  3/23/88 --doughty
  (Group-Next
    :type boolean
    :inheriting t
    :toplevel ())
  (vertical-justification-allowed
    :type (above below around none)
    :default "none"))

(define-environment-attributes formatting-environment
  (line-width					;before column-width
    :type horizontal-distance
    :inheriting T
    :toplevel "6.5inch")			;used to be (send self ':paper-width)
  (minimum-above-spacing
    :type vertical-distance
    :default "0")
  (accept-premature-end				;made up, not in thesis
    :type boolean
    :default ())
  (attached-counter
    :type counter
    :default ())
  (blank-line-action
    :type (ignored paragraph-break word-break keep-line hinge break-and-hinge keep-and-hinge)
    :inheriting T
    :toplevel "paragraph-break")
  (block-disposition	;;---figure out for sure how this interacts with float-disposition.
    :type (none group float footnote)
    :inheriting T
    :toplevel "none")
  (float-disposition
    :type (free group float-defer float-whole-page fixed-location
		;; float-down float-up float-to-line-end? 
		)
    :inheriting T
    :toplevel "free")
  (bold-implementation
    :type (off overstruck tilde)
    :inheriting T
    :toplevel "off")
  (bottom-margin
    :type vertical-distance
    :inheriting T
    :toplevel "0")
  #+Franz   ;;---Since this is internal, let's not hack it yet.
  (box-name					;not in thesis
    :type string
    :inheriting T
    :toplevel "savebox")
  (carriage-return-action
    :type (ignored spaces paragraph-break)
    :inheriting T
    :toplevel "spaces")
  (column-margin
    :type horizontal-distance
    :inheriting T
    :toplevel "0")
  (column-width					;must come after line-width, of course
    :type horizontal-distance
    :inheriting T
    :toplevel "6inches")			;line-width
  (columns 
    :type integer
    :inheriting T
    :toplevel 1)
  (counter-environment				;this is an environment which is wrapped
    :type cmd-or-envr-name			;around this environment's counter
    :inheriting nil
    :default nil)
  (environment-counter				;a counter to increment when this envr
    :type counter				;is entered.
    :inheriting T				;so (figure (center (caption---))) will work
    :toplevel ())
  (fill-mode
    :type (centered flushleft flushright fill)	;each of the first three imply nofill
    :inheriting T
    :toplevel "flushleft")
  (fixed-location
    :type vertical-distance			;well, is this a kludge?
    :default "0")
  (justification
    :type boolean
    :inheriting T
    :toplevel T)
  (hyphen-may-cause-line-break			;hyphenbreak
    :type boolean
    :inheriting T
    :toplevel T)
  (hyphenation
    :type boolean
    :inheriting T
    :toplevel ())
  (indention
    :type horizontal-distance-relative
    :inheriting T
    :toplevel "0")
  (leading-space-action
    :type (retained compressed normalized discarded retained-significant)
    :inheriting T
    :toplevel "normalized")
  (left-margin
    :type horizontal-distance
    :inheriting T
    :toplevel "0")
  (break-on-entry				;break before,around
    :type boolean
    :default ())
  (break-on-exit				;break after, around
    :type boolean
    :default ())
  (minimum-below-spacing
    :type vertical-distance
    :default "0")
  (narrowest-blank
    :type horizontal-distance
    :inheriting T
    :toplevel "0")
  (number-location
    :type (lfl lfr rfl rfr)
    :inheriting T
    :toplevel "lfl")
  (overlong-line-action
    :type (chop wrap keep)
    :inheriting T
    :toplevel "chop")				;which should warn
  (overstrikes-for-bold
    :type integer
    :inheriting T
    :toplevel "0")
  (page-break-on-entry
    :type (yes until-even until-odd no)
    :default "no")
  (page-break-on-exit
    :type boolean
    :default ())
  (page-need
    :type vertical-distance
    :default "0")
  (paragraph-breaks
    ;; paragraph breaks should 1not0 inherit!  This fixes
    ;; problems that arise when you nest, say, enumerate inside multiple,
    ;; inside itemize.  The only time paragraph-breaks should inherit is
    ;; if the environment is "insignificant".  The current test for that
    ;; is whether it 2tab-export0s, and that is implemented by the whopper on 
    ;; :paragraph-breaks below.
    :type (normal limited)
    :default "normal")
  (paragraph-spread 
    :type vertical-distance
    :inheriting T
    :toplevel "1line")
  (picture-scale :type scale :inheriting T :toplevel "1")
  (presentation-type
    :type presentation-type
    :default ())
  (presentation-object
    :type presentation-object
    :default ())
  (process-text-before-entry
    :type contents-list
    :default ())
  (process-text-after-entry
    :type contents-list
    :default ())
  (process-text-before-exit
    :type contents-list
    :default ())
  (process-text-after-exit
    :type contents-list
    :default ())
  (resume-paragraph-on-exit
    :type (no required permitted)
    :default "permitted")
  (right-margin
    :type horizontal-distance
    :inheriting T
    :toplevel "0")
  (running-heads				;pageheading
    :type boolean
    :inheriting T
    :toplevel T)
  (script-displacement				;superscript baseline displacement
    :type vertical-distance-relative
    :inheriting T
    :toplevel "0")
  (script-push					;whether to push line to make room for
    :type boolean				;super/sub scripts
    :inheriting T
    :toplevel ())
  (sink-margin
    :type vertical-distance
    :inheriting T
    :toplevel "0")
  (space-action
    :type (retained compressed normalized discarded retained-significant)
    :inheriting T
    :toplevel "compressed")
  (spacing
    :type vertical-distance
    :inheriting T
    :toplevel "0")
  (tab-export
    :type boolean
    :default ())
  (tab-stops
    :type list
    :inheriting T
    :toplevel (0))				;always a tab-stop at the left margin
  (top-margin 
    :type vertical-distance
    :inheriting T
    :toplevel "0")
  (transformation				;capitalized
    :type (none capitalized initial-capitalized)
    :inheriting T
    :toplevel "none")
  (underlining
    :type (off alphanumeric nonblank all)
    :inheriting T
    :toplevel "off")
  (visibility
    :type boolean
    :inheriting T
    :toplevel T)
  (widest-blank
    :type horizontal-distance
    :inheriting T
    :toplevel "10ems")
  )

(defwhopper 2(:paragraph-breaks formatting-environment)0 ()
  (if (and tab-export (send self :superior))
      (send (send self :superior) :paragraph-breaks)
      (continue-whopper self)))

(define-environment-attributes 2box-environment
0  (box-top-margin
    :type vertical-distance
    :default 0)
  (box-bottom-margin
    :type vertical-distance
    :default 0)
  (box-left-margin
    :type horizontal-distance
    :default 0)
  (box-right-margin
    :type horizontal-distance
    :default 0)
  (box-type
    :type box-type
    :default ())
  (box-flush-right
    :type boolean
    :inheriting t
    :toplevel ()))

;;Physical device parameters which really want to be in a mixin
(define-environment-attributes physical-attributes
  (paper-width
    :type horizontal-distance
    :inheriting T
    :toplevel "8.5inches")
  (paper-height
    :type vertical-distance
    :inheriting T
    :toplevel "11inches")
  (horizontal-width-increment
    :type horizontal-distance			;rational
    :inheriting T
    :toplevel "0")		;#10r(// 1\240 254\100)) 1/240 dots/inch * 1 inch/2.54cm
  (vertical-width-increment
    :type vertical-distance			; rational
    :inheriting T
    :toplevel "0")				; horizontal-width-increment)
  (can-backspace
    :type boolean
    :inheriting T
    :toplevel T)
  (can-bare-carriage-return
    :type boolean
    :inheriting T
    :toplevel T)
  (can-bare-line-feed
    :type boolean
    :inheriting T
    :toplevel T)
  (has-fonts
    :type boolean
    :inheriting T
    :toplevel T)
  (has-lens
    :type boolean
    :inheriting T
    :toplevel ())
  (can-overstrike
    :type boolean
    :inheriting T
    :toplevel T)
  (discrete-pages
    :type boolean
    :inheriting T
    :toplevel T)
  (can-underline
    :type boolean
    :inheriting T
    :toplevel T)
  )

(defmethod (:TOPLEVEL-ATTRIBUTE ENVIRONMENT) (message)
  (if superior
      (send superior :toplevel-attribute message)
      (send self message)))

;;;Adjust an environment, according to a list of attribute/value lists
(defmethod (:ADJUST ENVIRONMENT) (mods)
  (let (new-left-margin new-right-margin new-line-width (box-lm 0) (box-rm 0))
    (loop for (iv val) in mods
	  do (if (not (member iv '(leftmargin rightmargin linewidth)))
		 (send self :set-attribute iv val)
		 (ecase iv
		   (leftmargin
		     (setq new-left-margin
			   (coerce-to-margin 'left val (or superior self))))
		   (rightmargin
		     (setq new-right-margin
			   (coerce-to-margin 'right val (or superior self))))
		   (linewidth
		     (setq new-line-width
			   (coerce-to-type 'horizontal-distance val
					   (send (or superior self) :line-width))))))
	     (when (eq iv 'boxlm) (setq box-lm (coerce-to-type 'horizontal-distance val)))
	     (when (eq iv 'boxrm) (setq box-rm (coerce-to-type 'horizontal-distance val))))
    (when (or new-left-margin new-right-margin new-line-width)
      (when (and new-left-margin new-right-margin new-line-width)
	(zl:fsignal "Only two of LeftMargin, RightMargin and LineWidth may be specified")
	(setq new-line-width nil))
      (when new-line-width
	(setq line-width new-line-width))
      (when new-left-margin
	(setq left-margin new-left-margin))
      (when new-right-margin
	(setq right-margin new-right-margin))
      (when (null new-line-width)
	(setq line-width (- paper-width (+ left-margin right-margin))))
      (when (null new-right-margin)
	(setq right-margin (- paper-width (+ left-margin line-width))))
      (when (null new-left-margin)
	(setq left-margin (- paper-width (+ right-margin line-width)))))
    (incf left-margin box-lm)
    (incf right-margin box-rm)
    (decf line-width (+ box-lm box-rm))
    ))



(define-environment-attributes ESSENTIAL-COUNTER
  (aliased-counter
    :type counter
    :default ())
  (announced
    :type boolean
    :default ())
  (incremented-by
    :type (use tag reference magic)
    :default "use")
  (initial-value
    :type integer
    :default 0)
  (outline
    :type boolean
    :default ())
  (parent-counter
    :type counter
    :default ())
  (template-as-number
    :type template
    :default "@1")
  (template-as-reference
    :type template
    :default "@1")
  (titleform :type contents-list :default ())
  (contentsform :type contents-list :default ())
  )

;;; You're not allowed to patch the COUNTER defflavor without also
;;; invalidating the previously cached instances.
(progn
(defflavor COUNTER
	((name)
	 (value 0)
	 (nesting-depth 0)
	 (child-counters ()))
	(essential-counter)
  (:settable-instance-variables name value nesting-depth)
  (:writable-instance-variables child-counters)
  )
(invalidate-counter-caches))

(defmethod (sys:print-self counter) (stream ignore ignore)
  (sys:printing-random-object (self stream :typep)
    (if name
	(format stream "~a ~d" name value)
	(format stream "~d" value))))

;;The define-environment-attributes macrology is sooo hairy that I can't figure out
;;a good place to squeeze in (:settable-instance-variables attached-counter)
(defmethod (:SET-ATTACHED-COUNTER FORMATTING-ENVIRONMENT) (new-value)
  (check-type new-value (or null counter) "a counter or NIL")
  (setq attached-counter new-value))

(defun GET-NEW-COUNTER ()
  (let ((new-counter (make-instance 'counter))
	(default-counter *counter-to-default-from*))
    (when (or (null default-counter)
	      (neq (sys:%instance-flavor default-counter)
		   (sys:%instance-flavor new-counter)))
      (setq default-counter
	    (setq *counter-to-default-from* (make-instance 'counter)))
      (send default-counter :init-toplevel))
    (send new-counter :setup-internal default-counter default-counter)
    new-counter))

(defmethod (:SET-ATTACHED-COUNTER-IF-NECESSARY FORMATTING-ENVIRONMENT) ()
  (when (null attached-counter)
    (setq attached-counter (get-new-counter))
    (send attached-counter :set-nesting-depth
	  (loop with envr-name = (send self :envr-name)
		for sup = (send self :superior) then (send sup :superior)
		while sup
		count (eq (send sup :envr-name) envr-name)))))

(defmethod (:FIND-ATTACHED-COUNTER FORMATTING-ENVIRONMENT) ()
  (block find-it
    (flet ((find-attached-counter-1 (envr)
	     (let ((attached-counter (send envr :attached-counter)))
	       (cond (attached-counter attached-counter)
		     ((eq (send envr :paragraph-breaks) 'limited)
		      (return-from find-it nil))

		     ;; --- this is operating on the assumption that
		     ;; if an environment causes paragraph breaks
		     ;; itself and wants to be set off from the
		     ;; rest of society, then it must also not
		     ;; want its paragraphs to be numbered by its
		     ;; containing environment.  Note that
		     ;; this contradicts the Scribe manual, but
		     ;; this is a clear case of "Do as Scribe does,
		     ;; not as Scribe says."
		     ((send envr :break-on-entry)
		      (return-from find-it nil))))))
      (loop for envr = self then (send envr :superior)
	    while envr
	    when (find-attached-counter-1 envr) return it))))

(defflavor SAGE-ATTRIBUTE-ERROR (attribute) (error)
  :initable-instance-variables
  :gettable-instance-variables)

(defflavor SAGE-ATTRIBUTE-NAME-ERROR () (sage-attribute-error)
  :initable-instance-variables
  :gettable-instance-variables)

(defflavor SAGE-ATTRIBUTE-VALUE-ERROR (value type) (sage-attribute-error)
  :initable-instance-variables
  :gettable-instance-variables)

(defmethod (:REPORT SAGE-ATTRIBUTE-ERROR :DEFAULT) (stream)
  (format stream "~S is not a valid attribute" attribute))

(defmethod (:REPORT SAGE-ATTRIBUTE-NAME-ERROR) (stream)
  (format stream "~S is not a valid attribute name" attribute))

(defmethod (:PROCEED SAGE-ATTRIBUTE-NAME-ERROR :REPLACEMENT-NAME)
	   (&optional (name (prompt-and-read :string "Attribute name to use instead: ")))
  "Supply a different attribute name."
  (values :replacement-name name))

(defmethod (:REPORT SAGE-ATTRIBUTE-VALUE-ERROR) (stream)
  (format stream "Specifying value ~S for attribute ~S, which requires a value of type ~S"
	  value attribute type))

(defmethod (:PROCEED SAGE-ATTRIBUTE-VALUE-ERROR :REPLACEMENT-VALUE)
	   (&optional (new-value (prompt-and-read :string "Value to use instead: ")))
  "Supply a different value."
  (values :replacement-value new-value))


(defun 2validate-presentation-type0 (putative-type)
  (let ((presentation-type (eval putative-type)))
    #+Ignore
    (unless (dw::presentation-type-p presentation-type)
      (error "~S is not a presentation type" presentation-type))
    (values putative-type presentation-type)))

(defun 2validate-presentation-object0 (putative-object)
  (values putative-object (eval putative-object)))

(defun VALIDATE-DISTANCE (arg direction)
  (cond ((consp arg)
	 ;; I guess we assume it's already parsed and hence validated.
	 ;; We could check its units or something.
	 arg)
	(T
	 (multiple-value-bind (sign number units)
	     (typecase arg
	       (number (values nil arg (canonicalize-units "" direction)))
	       (string (parse-distance arg direction))
	       (otherwise (parse-distance (string arg) direction)))
	   (when (case units
		   ((points inches cm mm pixels picas) T)
		   (characters (eq direction :horizontal))
		   (lines (eq direction :vertical))
		   (otherwise ()))
	     (if sign
		 (list sign number units)
		 (list number units)))))))

(defun COERCE-TO-TYPE (type arg &optional (presently '.losing.))
  (if (not (atom type))
      (coerce-to-enumeration type arg)
      (case type
	(:none (unless (or (eq arg ':none) (null arg))
		 (error "Arg ~s supplied where we expected none" arg)))
	(boolean
	 (cond ((member arg '("T" "yes" "true" "available" "on") :test #'string-equal) T)
	       ((member arg '("F" "NIL" "no" "false" "unavailable" "off") :test #'string-equal) ())
	       (T (error "The arg ~s is not a valid Boolean value" arg))))
	(box-type (coerce-to-box-type arg))
	(contents-list (if (or (null arg) (consp arg)) arg
			   (error "~&This is supposed to be a contents list: ~S" arg)))
	(counter (lookup-counter-by-string arg))
	(cmd-or-envr-name			;no coercion, except to be envrname is symbol
	 (string-upcase-and-intern arg *sage-package*))
	(horizontal-distance
	 (coerce-to-distance arg ':horizontal presently))
	(horizontal-distance-relative
	 (coerce-to-distance arg ':horizontal 0))
	(scale (coerce-to-scale arg presently))
	(integer
	 (typecase arg
	   (number (round arg))
	   (string (let ((maybe-num (read-from-string arg)))
		      (if (numberp maybe-num)
			  (round maybe-num)
			  (error "~&Cannot coerce the string ~s to an integer." arg))))
	   (otherwise (error "~&Cannot coerce ~s to an integer." arg))))
	(line-type
	  (coerce-to-line-type arg))
	(list
	 (if (or (null arg) (consp arg))
	     arg
	     (error "Not a list: ~S" arg)))
	(presentation-type (coerce-to-presentation-type arg))
	(presentation-object (coerce-to-presentation-object arg))
	(rational
	 (error "~&Foo, I can't coerce to rationals yet ~s" arg))
	(:string					;let it blow out if not string
	 (string arg))
	(:symbol
	 (typecase arg
	   (symbol arg)
	   (string (string-upcase-and-intern arg *sage-package*))
	   (otherwise (error "Non-string arg ~s" arg))))
	((template :template) (coerce-to-template arg))
	(vertical-distance
	 (coerce-to-distance arg ':vertical presently))
	(vertical-distance-relative
	 (coerce-to-distance arg ':vertical 0))
	((T) arg)
	(otherwise (error "I don't know how to coerce to type ~s. The arg is ~s"
			   type arg)))))

(defun COERCE-TO-ENUMERATION (type arg)
  (if (or (null arg) (eq arg ':none))
      arg
      (if (and (symbolp arg) (member arg type))	;try not to spend all our time
						; in %string-compare, in the common case
	  arg
	  ;;Is this cleverness or hacking?
	  ;;Rather than doing memq on (string-upcase-and-intern arg "SAGE") which
	  ;;would always copy a string and maybe cons a symbol, instead let string-equal
	  ;;coerce symbols in the list to their pnames and be case-insensitive.
	  (let ((mem (member arg type :test #'string-equal)))
	    (if mem
		(first mem)
		(error "The arg ~s is not in the enumeration ~s" arg type))))))

;;;Expected format is list of template elements.
;;;Each element is list of format codes and strings.
;;;Each format code is a single character or a list of two characters, the first of which is
;;;either a colon or a semicolon.
(defun COERCE-TO-TEMPLATE (arg)
  (if (stringp arg)
      (parse-template arg)
      arg))

(defun COERCE-TO-DISTANCE (arg dir presently) 
  (multiple-value-bind (sign number nil) (canonicalize-distance-units arg dir) 
    (cond ((null sign) 
	   number) 
	  ((eq presently'.losing.) 	   
	   (error "Asked to compute ~a relative distance ~a, but no value presently" 
		   dir arg))
	  (T (ecase sign
	       (+ (+ presently number))
	       (- (- presently number)))))))



;; a scale is a pair (num type)
;; where num is a number and type is {absolute, relative, size}
;; NUM is just a ratio if TYPE is ABSOLUTE or RELATIVE
;; NUM is in microns if TYPE is SIZE
;; coerce-to-scale always wants to return an absolute (or size) scale, though
(defun 2coerce-to-scale0 (arg presently)
  (multiple-value-bind (number type)
      (canonicalize-scale-units arg)
    (case type
      (absolute (list number type))
      (size (list number type))
      (relative
	(when (eq presently '.losing.)
	  (error "A relative scale was specified with no prevailing scale"))
	(list (* number (first presently)) (second presently)))
      (otherwise
	(multiple-value-bind (ignore microns)
	    (canonicalize-distance-units `(,number ,type) :vertical)
	  (list microns 'size))))))

(defun 2coerce-to-line-type0 (arg)
  (cond ((null arg) nil)
	(t
	 ;; would really like to validate this arg, but we can't
	 ;; because the local definitions aren't instantiated at the time
	 ;; we do the coercion
	 (typecase arg
	   (symbol arg)
	   (string (intern (string-upcase arg) *sage-package*)))
	 #+ignore
	 (let ((symbol (typecase arg (symbol arg) (string (intern arg)))))
	   (cond ((line-type-known-p symbol) symbol)
		 (t (error "The arg ~S is not a known line type" arg)))))))

(defun 2coerce-to-box-type0 (arg)
  (cond ((null arg) nil)
	(t
	 ;; would really like to validate this arg, but we can't
	 ;; because the local definitions aren't instantiated at the time
	 ;; we do the coercion
	 (typecase arg
	   (symbol arg)
	   (string (intern (string-upcase arg) *sage-package*)))
	 #+ignore
	 (let ((symbol (typecase arg (symbol arg) (string (intern arg)))))
	   (cond ((box-type-known-p symbol) symbol)
		 (t (error "The arg ~S is not a known box type" arg)))))))

(defun coerce-to-presentation-type (arg)
  (multiple-value-bind (ignore type)
      (validate-presentation-type arg)
    type))

(defun 2coerce-to-presentation-object0 (arg)
  (multiple-value-bind (ignore object)
      (validate-presentation-object arg)
    object))

(defun COERCE-TO-TAB-STOP (arg presently left-margin)
  (multiple-value-bind (sign number nil) (canonicalize-distance-units arg)
    (ecase sign
      ;;Unsigned numbers are relative to prevailing left margin.
      ;;Signed numbers are relative to the previous stop, or the left margin if this is first.
      ((NIL) (+ left-margin number))
      (+ (+ presently number))
      (- (- presently number)))))

(defun COERCE-TO-MARGIN (which-margin val superior)
  (multiple-value-bind (direction attribute)
      (ecase which-margin
	(left (values :horizontal :left-margin))
	(right (values :horizontal :right-margin))
	;;---someday, topmargin and bottommargin
	)
    (multiple-value-bind (sign number nil)
	(canonicalize-distance-units val direction)
      (ecase sign
	;;Unsigned numbers are relative to global margins (i.e., toplevel margins)
	;;Signed numbers are relative to what the margin is now (i.e., superior's margins)
	((NIL) (+ number (send superior :toplevel-attribute attribute)))
	(+ (+ (send superior attribute) number))
	(- (- (send superior attribute) number))))))

(defun CANONICALIZE-DISTANCE-UNITS (arg &optional (dir ':horizontal))
  (declare (values sign number units))
  (multiple-value-bind (sign number units)
      (etypecase arg
	(cons (cond ((= 2 (length arg))
		      (values () (first arg) (second arg)))
		     ((= 3 (length arg))
		      (values (first arg) (second arg) (third arg)))
		     (t (error "The `validated' distance ~s is invalid" arg))))
	(number (values () arg (canonicalize-units "" dir)))
	((or string symbol) (parse-distance arg dir)))
    (unless (zerop number)
      (setq number
	    (case units
	      (points (* number *microns-per-point*))
	      (inches (* number *microns-per-inch*))
	      (characters
	       (* number
		  (ecase dir
		    (:horizontal
		     ;;---Do we care that ens and zeros aren't the same width?
		     (micron-width-of-char 0 #\n)))))
	      (lines
		(* number
		   (+ (* (send *current-sage-device* :leading)
			 *microns-per-point*)
		      (ecase dir
			(:vertical
			  (micron-height-of-font 0))))))
	      (cm (* number 1.0e4))
	      (mm (* number 1.0e3))
	      (pixels (* number *microns-per-device-pixel*))
	      (picas (* number *microns-per-pica*))
	      (otherwise (error "I don't know how to coerce ~s to a ~a distance"
				 arg (string-downcase dir))))))
    (values sign number units)))

;;;Takes a string.  Returns three values: sign, number, units.  It forces units
;;;even when there are none in the string.  This means it chooses wrong for vertical
;;;distances unless you supply the second argument to tell it that context.
(defun PARSE-DISTANCE (string &optional (direction :horizontal))
  (si:coerce-string-arg string)
  (let ((len (string-length string)))
    (if (zerop len)
	(values () 0 ())
	(multiple-value-bind (sign start)
	    (selector (aref string 0) char-equal
	      (#\+ (values '+ 1))
	      (#\- (values '- 1))
	      (otherwise (values () 0)))
	  (multiple-value-bind (number start)
	      (loop with number = 0
		    with exponent = nil
		    for i from start below len
		    for ch = (aref string i)
		    do (cond ((char-equal ch #\SPACE))	; ignore spaces
			     (( (char-code #\0) (char-code ch) (char-code #\9))
			      (setq number
				    (+ (* number 10) (- (char-code ch) (char-code #\0))))
			      (when exponent (decf exponent)))
			     ((char-equal ch #\.)
			      (setq exponent 0))
			     ;; If it's not a space, point, or digit, we're done
			     ((and exponent (not (zerop exponent)))
			      (return (values (si:float-and-scale nil number exponent) i)))
			     (t
			      (return (values number i))))
		    finally (if (and exponent (not (zerop exponent)))
				(return (values (si:float-and-scale nil number exponent) len))
				(return (values number len))))
	    (let ((units
		    (stack-let ((units-string (make-array (- len start)
							  :element-type 'character
							  :fill-pointer (- len start)))
				(trimmed-units-string
				  (make-array (- len start)
					      :element-type 'character
					      :fill-pointer 0)))
		      (replace units-string string :start2 start)
		      (string-trim-into-string trimmed-units-string '(#\space) units-string)
		      (or (canonicalize-units trimmed-units-string direction)
			  (parse-error "I don't recognize the units ~s in ~s"
				       (string-trim " " (substring string start))
				       (string-trim " " string))))))
	      (values sign number units)))))))

;;;Looks at a string, which is assumed to contain a distance unit name.  Returns a canonical
;;;form of whichever name it is.  It assumes that all distances are horizontal unless told
;;;otherwise.
(defun CANONICALIZE-UNITS (string &optional (direction :horizontal))
  (if (plusp (string-length string))
      (loop for (result . tests) in '((inches "in" "inch" "\"")
				      (cm "centimeter" "centimeters")
				      (mm "millimeter" "millimeters")
				      (points "pt" "pts" "point")
				      (characters "char" "chars"
						  "character"
						  "em" "ems")
				      (lines "line")
				      (pixels "dot" "pixel" "scanline")
				      (picas "pica"))
	    when (or (string-equal string result) (member string tests :test #'string-equal))
	    return result)
      (ecase direction
		(:horizontal 'characters)
		(:vertical 'lines))))

(defun 2canonicalize-scale-units0 (arg)
  (declare (values number type))
  (etypecase arg
    (cons (cond ((= 2 (length arg))
		 (values (first arg) (second arg)))
		(t (error "The `validated' scale ~S is invalid" arg))))
    (number (values arg 'absolute))		;--- ?
    ((or string symbol)
     (parse-scale arg))))

(defun 2parse-scale0 (arg)
  (let ((string (string arg)))
    (cond ((zerop (string-length string))
	   (error "A scale of 0 is invalid."))
	  (t (let ((first-char (aref string 0)))
	       (cond ((char-equal first-char #\*)
		      (multiple-value-bind (ignore number)
			  (parse-distance (substring string 1))
			(values number 'relative)))
		     (t
		      (multiple-value-bind (ignore number units)
			  (parse-distance string)
			(cond ((eq units 'characters)	;--- what if they want characters?
			       (values number 'absolute))
			      (t (values number units)))))))))))


(defflavor SAGE-NAME-ERROR (name) (error)
  :initable-instance-variables
  :gettable-instance-variables)

(defflavor SAGE-ENVIRONMENT-NAME-ERROR () (sage-name-error)
  :initable-instance-variables
  :gettable-instance-variables)

(defmethod (:REPORT SAGE-NAME-ERROR :DEFAULT) (stream)
  (format stream "~S is not a valid name" name))

(defmethod (:REPORT SAGE-ENVIRONMENT-NAME-ERROR) (stream)
  (format stream "~S is not a valid environment name" name))

(defmethod (:PROCEED SAGE-ENVIRONMENT-NAME-ERROR :REPLACEMENT-NAME)
	   (&optional (new-name (prompt-and-read :string "Environment to use instead: ")))
  "Supply a different environment name"
  (values :replacement-name new-name))

(defflavor SAGE-COMMAND-NAME-ERROR () (sage-name-error)
  :initable-instance-variables
  :gettable-instance-variables)

(defmethod (:REPORT SAGE-COMMAND-NAME-ERROR) (stream)
  (format stream "~S is not a valid command name" name))

(defmethod (:PROCEED SAGE-COMMAND-NAME-ERROR :REPLACEMENT-NAME)
	   (&optional (new-name (prompt-and-read :string "Command to use instead: ")))
  "Supply a different command name"
  (values :replacement-name new-name))

(defflavor SAGE-COUNTER-NAME-ERROR () (sage-name-error)
  :initable-instance-variables
  :gettable-instance-variables)

(defmethod (:REPORT SAGE-COUNTER-NAME-ERROR) (stream)
  (format stream "~S is not a valid counter name" name))

(defmethod (:PROCEED SAGE-COUNTER-NAME-ERROR :REPLACEMENT-NAME)
	   (&optional (new-name (prompt-and-read :string "Counter to use instead: ")))
  "Supply a different counter name"
  (values :replacement-name new-name))


(defun VERIFY-ARGS (command arglist)
  (let ((all-desc (dd-all command))
	(pos-rslts nil)
	(list-rslts nil)
	(key-rslts nil)
	(rslts nil)
	(doc-type (dd-document-type command)))
    (cond (all-desc
	   (unless (= 1 (length arglist))
	     (error "Arglist ~A for command ~A is invalid" arglist (dd-symbol command)))
	   (setq rslts
		 (ncons (verify-value-type (first arglist) (second all-desc) doc-type))))
	  (t
	   (loop for arg-desc in (dd-positional-args command)
		 for arg = (pop arglist)
		 when arg
		 do (push (verify-value-type arg (second arg-desc) doc-type)
			  pos-rslts))
	   (let ((list-desc (dd-list-of command)))
	     (when list-desc
	       (loop while arglist
		     for list-item = (pop arglist)
		     do (push (verify-value-type list-item (second list-desc) doc-type)
			      list-rslts))))
	   (loop with key-descs = (dd-key-args command)
		 with any-keys-desc = (dd-any-keys command)
		 for (key val) in arglist
		 for key-desc = (assoc key key-descs)
		 do (cond (key-desc
			   (push (list key
				       (verify-value-type val (second key-desc) doc-type))
				 key-rslts))
			  (any-keys-desc
			   (push (list key
				       (verify-value-type val
							  (second any-keys-desc) doc-type))
				 key-rslts))
			  (t
			   (parse-error
			     "The key ~A unaccountably appears in the arglist of @~A."
			     key (dd-symbol command)))))
	   (setq rslts (nconc (nreverse pos-rslts)
			      (nreverse list-rslts)
			      (nreverse key-rslts)))))
    (case (dd-parse-type command)
      (:macro
	(build-sage-macro-call (dd-symbol command) rslts))
      (:reference
	(build-sage-reference rslts))
      (:command
	(make-sage-command (dd-definition command) rslts)))))

(defun VERIFY-VALUE-TYPE (value-list type document-type)
  (let ((value (first value-list)))
    (if (not (atom type))
	(first (if (or (null value) (eq value ':none))
		   (member :none type)
		   (member value type :test #'string-equal)))
	(case type
	  (:none (or (eq value ':none) (null value)))
	  (:boolean
	   (cond ((null value)			;mentioned default
		  T)
		 ((member value '("T" "yes" "true" "available" "on") :test #'string-equal)
		  T)
		 ((member value '("F" "NIL" "no" "false" "unavailable" "off") :test #'string-equal)
		  ())
		 (T (parse-error "~A is not a valid Boolean value" value))))
	  (:cmd-or-envr-name
	   (condition-case ()
	       (validate-command-name value document-type)
	     (sage-command-name-error
	       (condition-case ()
		   (validate-environment-name value document-type)
		 (sage-environment-name-error
		   (parse-error "~A is not a valid command or environment name." value))))))
	  (:contents-list
	   value-list)
	  (:counter-name
	   (validate-counter-name value document-type))
	  (:device-name
	   (let ((dev-type-value (let ((*package* *sage-package*))
				   (read-from-string value))))
	     (when (device-type-p dev-type-value)
	       dev-type-value)))
	  (:document-type
	   (let ((doc-type-value (let ((*package* *sage-package*))
				   (read-from-string value))))
	     (when (document-type-p doc-type-value)
	       doc-type-value)))
	  (:horizontal-distance
	   (validate-distance value :horizontal))
	  (:list-of-fields
	   (loop for field in value-list
		 for valid-field = (validate-field-name field)
		 if valid-field
		   collect valid-field
		 else do (parse-error "Invalid field name: ~A." field)))
	  (:nonnegative-integer
	   (typecase value
	     (number
	      (when (not (minusp value))
		value))
	     (string (let ((num (read-from-string value)))
			(when (and (numberp num) (not (minusp num)))
			  num)))
	     (otherwise ())))
	  (:number
	   (typecase value
	     (number value)
	     (string (let ((num (read-from-string value)))
			(when (numberp num)
			  num)))
	     (otherwise ())))
	  (:positive-integer
	   (typecase value
	     (number
	      (when (plusp value)
		value))
	     (string (let ((num (read-from-string value)))
			(when (and (numberp num) (plusp num))
			  num)))
	     (otherwise ())))
	  (:symbol
	    (string-upcase-and-intern value *sage-package*))
	  (:template
	   (parse-template value))
	  (:text
	   (string value)
	   value)
	  (:string-for-lisp-reading
	   (setq value
		 (using-resource (temp string-temp)
		   (loop for thing in value-list
			 do (cond ((stringp thing) (string-nconc temp thing))
				  ((and (typep thing 'sage-command)
					(eq (send thing :command-name) 'literal-atsign))
				   (string-nconc temp "@"))
				  (t
				   (parse-error
				     "Found ~S in command argument list ~S ~
                                      where only strings were allowed."
				     thing value-list)))
			 finally (return (string-append temp)))))
	   (parse-L-string value))
	  (:variable
	   (string value)
	   value)
	  (:vertical-distance
	   (validate-distance value :vertical))
	  (otherwise value)))))

(defun BUILD-SAGE-REFERENCE (args)
  (let* ((unique-id (second (assoc 'unique-id args)))
	 (unique-index (second (assoc 'unique-index args)))
	 (topic (second (assoc 'topic args)))
	 (type (second (assoc 'type args)))
	 (valid-topic (when (and topic type)
			(validate-topic topic type)))
	 (view (second (assoc 'view args)))
	 (appearance (second (assoc 'appearance args)))
	 (booleans (second (assoc 'booleans args)))
	 (field (second (assoc 'field args))))
    1;;--- Damn, damn, damn.  There was a brief window in which the atom-to-list
0    1;; conversion code at the bottom of this function was broken such that it would
0    1;; listify NIL to (NIL).  Unfortunately, at least one SAB file appears to have
0    1;; been read and written inside that window, so we have to look for singleton
0    1;; lists of NIL and turn them back into just NIL.  -York 8/13/87
0    (when (and (listp field)
	       (= (length field) 1)
	       (eq (first field) nil))
      (setq field nil))

    (setq view (fixup-view view))

1    ;; --- Damn, damn, damn.  There was a brief window in which the extensible-reference
    ;; reading and writing code allowed references to be written out with
    ;; improper booleans.  So we have to check, at least for the time being.
0    (unless (eq view 'crossreference)
      (setq appearance () booleans ()))
    (when (and (eq view 'crossreference)
	       (eq appearance 'Topic)
	       booleans
	       (let ((t-booleans (crossreference-appearance-boolean-names 'Topic)))
		 (not (every #'(lambda (b) (member b t-booleans)) booleans))))
      (cerror "Ignore the booleans and use defaults"
	      "The booleans specified for this crossreference, ~S, are incompatible
with the booleans allowed, ~S" booleans (crossreference-appearance-boolean-names 'Topic))
      (setq booleans (crossreference-appearance-default-booleans 'Topic)))

    ;; --- Kludge alert:  This is here to make old method specs work.
    ;; Remove when new record type system is installed.
    (when (and (symbolp valid-topic)
	       (eq (symbol-package valid-topic) zwei:*utility-package*))
      (setq valid-topic (with-standard-io-environment
			  (read-from-string (symbol-name valid-topic)))))
    (unless valid-topic
      (parse-error
	"Invalid topic or type argument to a reference (arglist ~S)" args))
    (let ((record-group (find-record-group-for-topic-and-type valid-topic type
							      unique-id t unique-index)))
      (make-instance 'sage-reference
		     :record-group record-group
		     :view view
		     :appearance (or appearance (and (eq view 'crossreference) 'See))
		     :booleans booleans
		     :field (if (not (listp field))
				(ncons field)
				field)))))

;;;--- Remove reference stuff.
(defun BUILD-SAGE-MACRO-CALL (macro-name macro-args)
  (when (eq macro-name 'reference)		;args need more validation
    (let* ((topic (second (assoc 'topic macro-args)))
	   (type (second (assoc 'type macro-args)))
	   (valid-topic (when (and topic type)
			  (validate-topic topic type))))
      (when valid-topic
	(setf (second (assoc 'topic macro-args))
	      (if (and (symbolp valid-topic)
		       (eq (symbol-package valid-topic) zwei:*utility-package*))
		  ;; --- Kludge alert:  This is here to make old method specs work.
		  ;; Remove when new record type system is installed.
		  (with-standard-io-environment
		    (read-from-string (symbol-name valid-topic)))
		  valid-topic)))))
  (make-sage-macro-call macro-name macro-args))

(defun ARGLIST-PATTERN (descriptor)
  (values (dd-min-pos-args descriptor)
	  (dd-max-pos-args descriptor)
	  (dd-non-pos-args descriptor)))

(defun EXTRACT-PATTERN (argument-list)
  (cond ((or (null argument-list)	; Eat delimiters, if present.
	     (eq argument-list ':none))  ; Don't eat up delimiters.
	 (values 0 0 nil nil nil nil nil nil))
	((not (consp argument-list))
	 (error "Can't understand this argument-list: ~A" argument-list))
	(t		  
	 (loop for element in argument-list
	       with state = :required
	       with min-positional = 0
	       with max-positional = 0
	       with not-positional = nil
	       with positionals = nil
	       with keys = nil
	       with any-keys = nil
	       with list-of = nil
	       with all = nil
	       when (eq state :finished)
	       do (error "Extra arguments after &LIST-OF, &ANY-KEYS, or &ALL argument.")
	       do (case element
		    (&optional
		     (case state
		       (:required
			(setq state :optional))
		       ((:optional :key :any-keys :all :list-of)
			(error "&OPTIONAL in illegal position in arglist."))
		       (otherwise (error "Illegal state"))))
		    (&key
		     (case state
		       (:required (setq state :key
					not-positional :key))
		       ((:optional :key :any-keys :all :list-of)
			(error "&KEY in illegal position in arglist."))
		       (otherwise (error "Illegal state."))))
		    (&any-keys
		     (case state
		       ((:required :key)
			(setq state :any-keys
			      not-positional :key))
		       ((:optional :any-keys :all :list-of)
			(error "&ANY-KEYS in illegal position in arglist."))
		       (otherwise (error "Illegal state."))))
		    (&all
		     (case state
		       (:required
			(setq state :all
			      not-positional :all))
		       ((:optional :key :any-keys :all :list-of)
			(error "&ALL in illegal position in arglist."))
		       (otherwise (error "Illegal state."))))
		    (&list-of
		     (case state
		       ((:required :optional)
			(setq max-positional :
			      state :list-of))
		       ((:key :any-keys :all :list-of)
			(error "&LIST-OF in illegal position in arglist."))))
		    (otherwise
		     (case state
		       (:required
			(incf min-positional)
			(incf max-positional)
			(push element positionals))
		       (:optional
			(incf max-positional)
			(push element positionals))
		       (:key
			(push element keys))
		       (:any-keys
			(setq state :finished)
			(setq any-keys element))
		       (:list-of
			(setq state :finished)
			(setq list-of element))
		       (:all
			(setq state :finished)
			(setq all element)))))
	       finally (return (values
				 min-positional	; Min number of positional arguments needed.
				 max-positional	; Max number of positional arguments allowed.
				 not-positional	; The type of the non-positional arguments.
				 (nreverse positionals)	; The positional arguments.
				 (nreverse keys)	; The keyword arguments.
				 any-keys	; The any-key argument.
				 list-of	; The list-of argument.
				 all		; The all argument.
				 ))))))

(defun DEFINE-DIRECTIVE-1 (name definition-type parse-type
			   arglist document-type device-type definition
			   &key internal pretty-name)
  (record-source-file-name name definition-type)
  (let ((general-item (send *formatter-directives* :get-hash (string name))))
    (let ((item (when general-item
		  (find-directive-descriptor general-item document-type device-type))))
      (when (and item (neq (dd-parse-type item) parse-type))
	(format *error-output* "~&Warning: Replacing definition for ~S as ~S by ~S"
		name (dd-parse-type item) parse-type)))
    (send *formatter-directives* :put-hash
	  (string name)
	  (install-directive-descriptor
	    :general-item general-item
	    :name name :parse-type parse-type :arglist arglist
	    :document-type document-type :device-type device-type
	    :definition definition)))
  (when (or pretty-name internal)
    (setf (gethash name *formatter-directives-options*)
	  (append (and pretty-name `(:pretty-name ,pretty-name))
		  (and internal `(:internal ,internal))))))

(defun 2directive-pretty-name0 (name)
  (let ((entry (gethash name *formatter-directives-options*)))
    (or (and entry (getf entry :pretty-name))
	(string-capitalize name))))

(defun 2directive-internal-p0 (name)
  (or (and (> (string-length name) 1)
	   (not (null (string-search-char #\- name)))
	   ':hyphen)
      (let ((entry (gethash name *formatter-directives-options*)))
	(and entry (getf entry :internal)))))

(defun DEFINE-SAGE-COMMAND-1 (name arglist keypairs)
  ;;This exists only to spread the last argument.
  (apply 'define-sage-command-2 name arglist keypairs))

(defun DEFINE-SAGE-COMMAND-2 (name arglist &key
			      (document-type 'generic) (device-type 'generic)
			      (definition name)
			      text? starts-with-printing-char?
			      ends-with-newline? ends-with-space?
			      undisplayed? internal pretty-name)
  (record-source-file-name name 'define-sage-command)
  (multiple-value-bind (options some-were-there)
      (gethash definition *formatter-directives-options*)
    ;; Make sure :pretty-name and :internal options reflect what's passed down, which
    ;; means removing options if they used to be there; but don't cons up and save a plist
    ;; just to hold NILs.
    (cond (some-were-there
	   (if pretty-name
	       (setf (getf options :pretty-name) pretty-name)
	       (remf options :pretty-name))
	   (if internal
	       (setf (getf options :internal) internal)
	       (remf options :internal))
	   (setf (gethash definition *formatter-directives-options*) options))
	  (T
	   (when pretty-name
	     (setf (getf options :pretty-name) pretty-name))
	   (when internal
	     (setf (getf options :internal) internal))
	   (when options
	     (setf (gethash definition *formatter-directives-options*) options)))))
  (let ((general-item (send *formatter-directives* :get-hash (string name))))
    (let ((item (when general-item
		  (find-directive-descriptor general-item document-type device-type))))
      (when (and item (neq (dd-parse-type item) ':command))
	(format *error-output* "~&Warning: Replacing definition for ~S as ~S by :COMMAND"
		name (dd-parse-type item))))
    (let ((dd (make-command-descriptor 
		:dd-command-text? (if text? 1 0)
		:dd-command-ends-with-newline? (if ends-with-newline? 1 0)
		:dd-command-ends-with-space? (if ends-with-space? 1 0)
		:dd-command-starts-with-printing-char? (if starts-with-printing-char? 1 0)
		:dd-command-undisplayed? (if undisplayed? 1 0))))
      (send *formatter-directives* :put-hash
	    (string name)
	    (install-directive-descriptor
	      :dd dd :general-item general-item
	      :name name
	      :parse-type :command
	      :arglist arglist
	      :document-type document-type
	      :device-type device-type
	      :definition definition))
      (send *formatter-commands* :put-hash definition dd))))

(defun DEFINE-SAGE-ATTRIBUTE-1 (name argument-type &key pretty-name internal)
  (let* ((general-item (send *environment-attributes* :get-hash (string name))))
    (send *environment-attributes* :put-hash
	  (string name)
	  (install-directive-descriptor
	    :general-item general-item
	    :name name
	    :parse-type (if (eql argument-type :template)
			    :template :attribute)
	    :arglist `((value ,argument-type))
	    :document-type 'generic :device-type 'generic)))
  (when (or pretty-name internal)
    (setf (gethash name *environment-attributes-options*)
	  (append (and pretty-name `(:pretty-name ,pretty-name))
		  (and internal `(:internal ,internal))))))

(defun 2environment-attribute-pretty-name0 (name)
  (let ((entry (gethash name *environment-attributes-options*)))
    (or (and entry (getf entry :pretty-name))
	(string-capitalize name))))

(defun 2environment-attribute-internal-p0 (name)
  (or (and (not (null (string-search-char #\- name)))
	   ':hyphen)
      (let ((entry (gethash name *environment-attributes-options*)))
	(and entry (getf entry :internal)))))

(defun DEFINE-SAGE-COUNTER-ATTRIBUTE-1 (name argument-type)
  (let* ((general-item (send *counter-attributes* :get-hash (string name))))
    (send *counter-attributes* :put-hash
	  (string name)
	  (install-directive-descriptor
	    :general-item general-item
	    :name name :parse-type :attribute :arglist `((,name ,argument-type))
	    :document-type 'generic :device-type 'generic))))

(defun MODIFY-ENVIRONMENT (name document-type device-type definition)
  (let* ((general-item (send *formatter-directives* :get-hash (string name)))
	 (item (when general-item
		 (find-directive-descriptor general-item document-type device-type)))
	 (prev-definition (when item
			    (dd-definition item))))
    (unless item
      (error "Requested Modify for ~S, which has no formatting environment" name))
    (send *formatter-directives* :put-hash
	  (string name)
	  (install-directive-descriptor
	    :general-item general-item
	    :name name
	    :parse-type :environment
	    :arglist ()
	    :document-type document-type :device-type device-type
	    :definition (append prev-definition definition)))))

(defun FIND-DIRECTIVE-DESCRIPTOR (list document-type device-type)
  (second (assoc device-type (cdr (assoc document-type list)))))

;; Things that cache something about the set of directives (like, the
;; presentation-types for environment and command names) need to know
;; when new directives are defined. ---When there is a directive-remover,
;; it will need to incf this tick, too.
(defvar *DIRECTIVE-DEFINITION-TICK* 0)

(defun INSTALL-DIRECTIVE-DESCRIPTOR (&key general-item dd name parse-type arglist
				     document-type device-type definition)
  (incf *directive-definition-tick*)
  (when (null dd) (setq dd (make-directive-descriptor)))
  (setf (dd-symbol dd) (intern (string name) *sage-package*))
  (unless (document-type-p document-type)
    (error "Invalid document type ~A" document-type))
  (unless (device-type-p device-type)
    (error "Invalid device type ~A" device-type))
  (setf (dd-document-type dd) document-type)
  (setf (dd-device-type dd) device-type)
  (setf (dd-parse-type dd) parse-type)
  (setf (dd-definition dd)
	(case parse-type			;do some sort of validation on the definition
	  (:environment
	   (validate-environment-definition definition document-type device-type))
	  (otherwise definition)))
  (setf (dd-arglist dd) arglist)
  (multiple-value-bind (min-pos max-pos non-pos positionals keys any-keys list-of all)
      (extract-pattern arglist)
    (setf (dd-min-pos-args dd) min-pos)
    (setf (dd-max-pos-args dd) max-pos)
    (setf (dd-non-pos-args dd) non-pos)
    (setf (dd-positional-args dd) positionals)
    (setf (dd-key-args dd) keys)
    (setf (dd-any-keys dd) any-keys)
    (setf (dd-list-of dd) list-of)
    (setf (dd-all dd) all))
  (let* ((doc-type-dds (assoc document-type general-item))
	 (dev-type-dd (assoc device-type (cdr doc-type-dds)))
	 (new-comp `(,device-type ,dd)))
    (cond (doc-type-dds
	   (setq general-item (delete doc-type-dds general-item))
	   (when dev-type-dd
	     (setf (cdr doc-type-dds) (delete dev-type-dd (cdr doc-type-dds)))))
	  (t
	   (setq doc-type-dds `(,document-type))))
    (push new-comp (cdr doc-type-dds))
    (push doc-type-dds general-item))		;VERY simple approach, let assq do override
  general-item)

(defun VALIDATE-ENVIRONMENT-DEFINITION (definition document-type device-type)
  ;; Bind document- and device-types in case of subparsing as part of coercion
  (with-document-and-device-types (document-type device-type)
    (let ((attributes ()))
      (dolist (item definition)
	(multiple-value-bind (attr-name attr-val)
	    (cond ((atom item) (values item :none))
		  ((= 2 (length item)) (values-list item))
		  (T (error 'sage-attribute-error
			    :attribute item)))
	  ;; list could contain item like (... (COPY "insert")...)  This means to take
	  ;; the definition for insert (it has to have been defined already or it is
	  ;; an error) and copy it right away into definition for the current thing.
	  ;; Don't share list structure, make new copy because it really is supposed
	  ;; to be equal to start with, not eq.
	  (cond ((eq attr-name 'copy)
		 (let ((def (dd-definition
			      (lookup-directive-descriptor
				attr-val document-type device-type))))
		   (if def
		       (setq attributes (nconc (reverse def) attributes))
		       (error 'sage-attribute-value-error
			      :attribute 'copy
			      :value attr-val
			      :type "a defined environment"))))
		((eq attr-name 'use)
		 (push (list attr-name attr-val) attributes))
		(T (let ((dd (lookup-attribute-descriptor attr-name)))
		     (if (null dd)
			 (error 'sage-attribute-name-error :attribute attr-name)
			 ;; Bind *document-type* and *device-type* so any parsing that
			 ;; gets done during validation will happen with respect to
			 ;; the doc and dev of the environment being defined.
			 (let ((*document-type* document-type)
			       (*device-type* device-type))
			   (multiple-value-bind (attr-name attr-val)
			       (validate-attribute-and-value-type
				 dd
				 ;;---the parser always listifys, so we do too.
				 (list attr-val))
			     (setq attributes
				   (cons (list attr-name attr-val)
					 ;; must delete prior occurrences of this attr, else
					 ;; it will fail to override things like relative
					 ;; distances
					 (delete attr-name attributes :key #'first)))))))))))
      ;; copy-list to cdr-code the list
      (copy-list (nreverse attributes)))))

;;;For parsing.  You give it name and document type, it returns the directive structure:
;;;a list of pairs of (device-type directive-descriptor)
(defun VALIDATE-DIRECTIVE (name &optional (document-type *document-type*))
  (let* ((entry (send *formatter-directives* :get-hash (string name))))
    (when entry
      (cdr (or (assoc document-type entry)
	       (assoc 'generic entry)		;With things ordered right this is (car entry)
	       ;; this next clause fixes sab-file reading to 
	       ;; not blow out when it encounters a directive that doesn't
	       ;; have a generic definition.  Hopefully we'll still get
	       ;; a blowout at format time if the particular book design
	       ;; doesn't have a definition for this directive
	       (and (eq document-type 'generic)
		    (first entry)))))))

(defun VALIDATE-COUNTER-NAME (arg &optional (document-type *document-type*))
  (let ((structure (second (first (validate-directive arg document-type)))))
    (if (and structure (eq (dd-parse-type structure) :counter)) 
	(dd-symbol structure)
	(signal 'sage-counter-name-error :name arg))))

(defun VALIDATE-ENVIRONMENT-NAME (arg &optional (document-type *document-type*))
  (let ((structure (second (first (validate-directive arg document-type)))))
    (if (and structure (eq (dd-parse-type structure) :environment))
	(dd-symbol structure)
	(signal 'sage-environment-name-error :name arg))))

(defun VALIDATE-COMMAND-NAME (arg &optional (document-type *document-type*))
  (let ((structure (second (first (validate-directive arg document-type)))))
    (if (and structure (eq (dd-parse-type structure) :command))
	(dd-symbol structure)
	(signal 'sage-command-name-error :name arg))))

(defun VALIDATE-FIELD-NAME (arg &optional (document-type *document-type*))
  (let ((structure (second (first (validate-directive arg document-type)))))
    (when (and structure (eq (dd-parse-type structure) :sage-field))
      (dd-symbol structure))))

(defun KEY-VALUE-TYPE (cmd-or-envr key)
  (let ((name (dd-symbol cmd-or-envr)))
    (case (dd-parse-type cmd-or-envr)
      (:environment
       (or (dd-parse-type key)
	   (parse-error "~A is not the name of an environment attribute." key)))
      ((:command :macro :reference)
       (let ((key-args-list (dd-key-args cmd-or-envr))
	     (any-keys-arg (dd-any-keys cmd-or-envr)))
	 (or (second (assoc key key-args-list))
	     (second any-keys-arg)
	     (parse-error "~A is not a valid keyword for the ~A command." key name))))
       (otherwise
	 (parse-error
	   "Where did this thing come from?  It isn't a command or environment: ~A." name)))))

(defun LOOKUP-ATTRIBUTE-DESCRIPTOR (arg)
  (let* ((entry (send *environment-attributes* :get-hash (string arg)))
	 (list (when entry (cdr (assoc 'generic entry))))
	 (structure (second (first list))))
    (if (and structure (member (dd-parse-type structure) '(:attribute :template)))
	structure
	())))

;;; This looks up internal command names (tab-to-tab-stop, not ">").
;;; The document-type and device-type are always generic,generic.
(defun LOOKUP-COMMAND-DESCRIPTOR (name)
  (send *formatter-commands* :get-hash name))

(defun LOOKUP-COUNTER-ATTRIBUTE-DESCRIPTOR (name &optional
					    (document-type 'generic)
					    (device-type 'generic))
  (find-directive-descriptor (send *counter-attributes* :get-hash (string name))
			     document-type device-type))

;; Commands to set and clear static counters used by Case commands
(defun 2set-static-value 0(name value)
  (etypecase name
    (string
      (setq name (intern (string-upcase (string-trim '(#\space #\tab #\return) name))
			 (find-package "sage"))))	;ensure the name is in the sage package
    (symbol
      (if (eq (symbol-package name) (find-package "SAGE"))
	  name
	  (error "~S is not a valid sage variable" name))))
  (if value
      (setf (gethash name *static-counters*) value)
      (remhash name *static-counters*)))

(defun 2lookup-static-value 0(name)
  (gethash name *static-counters*))

;; Commands to manipulate bindings made to Case selectors during
;; Format Pages using :Query option in Page Previewer
(defun 2set-format-pages-case-binding 0(name value)
  (if value
      (setf (gethash name *format-pages-case-bindings*) value)
      (remhash name *format-pages-case-bindings*)))

(defun 2lookup-format-pages-case-binding 0(name)
  (gethash name *format-pages-case-bindings*))

(defun 2clear-format-pages-case-bindings 0()
  (clrhash *format-pages-case-bindings*))

;; Used by @Value
(defun 2lookup-ambient-value0 (name &key (error-p T))
  (declare (values value value-type))
  (and (or error-p (variable-boundp *ambient-counters*))
       (ambient-counters-lookup-ambient-value *ambient-counters* name)))

(defmethod 2(ambient-counters-lookup-ambient-value ambient-counters)0 (name)
  (let ((there (assoc name values)))
    (and there (values (second there) (third there)))))

;; @String would call this too
(defun2 set-ambient-value0 (name value value-type)
  (ambient-counters-set-ambient-value *ambient-counters* name value value-type))

(defmethod2 (ambient-counters-set-ambient-value ambient-counters)0 (name value value-type)
  (cond ((and (null value-type) (null value))
	 (setq values (delete name values :key #'first)))
	((null value-type)
	 (error "Caller must supply value-type"))
	(T (let ((there (assoc name values)))
	     (cond (there
		    (setf (second there) value)
		    (setf (third there) value-type))
		   (T (push (list name value value-type) values))))))
  value)

(defun VALIDATE-ATTRIBUTE-AND-VALUE-TYPE (stuff arguments)
  (unless stuff (signal 'sage-attribute-name-error :attribute (dd-symbol stuff)))
  (let* ((sym (dd-symbol stuff))
	 (type (second (first (dd-arglist stuff))))
	 (arg (first arguments))
	 (normalized-value
	   (if (not (atom type))		;what kind of type is it
	       (first (if (or (null arg) (eq arg ':none))	;an enumeration type
			  (member :none type)
			  (member arg type :test #'string-equal)))
	       (ecase type			;one of the other types
		 (:none
		   (case arg
		     ((:none nil T) :none)
		     ))
		 (boolean
		  (cond ((or (eq arg :none)	;---think about this again in a couple days.
			     (member arg '("T" "yes" "true" "available" "on") :test #'string-equal))
			 "T")
			((member arg '("F" "NIL" "no" "false" "unavailable" "off")
			      :test #'string-equal)
			 "F")
			(T ())))
		 (box-type (coerce-to-box-type arg))
		 (line-type (coerce-to-line-type arg))
		 (scale (coerce-to-scale arg '.losing.))
		 (presentation-type (validate-presentation-type arg))
		 (presentation-object (validate-presentation-object arg))
		 (contents-list (let ((*document-type* (or *document-type* 'symanual))
				      (*device-type* (or *device-type* 'generic)))
				  (with-input-from-string (stream arg)
				    (sage-parse stream))))
		 (counter (validate-counter-name arg (dd-document-type stuff)))
		 (cmd-or-envr-name		;no coercion, except to be envrname is symbol
		  (validate-environment-name arg (dd-document-type stuff)))
		 ((horizontal-distance horizontal-distance-relative)
		  (validate-distance arg :horizontal))
		 (integer
		  (typecase arg
		    (number arg)
		    (string (let ((num (read-from-string arg)))
			       (if (numberp num) num)))
		    (otherwise ())))
		 (list (when (or (null arg) (consp arg)) arg))
		 (rational ())			;error, rational not handled now
		 (:string
		  (string arg)			;let it blow out if not string
		  arg)
		 (:symbol
		  (typecase arg
		    ((or symbol string) arg)
		    (otherwise (break "Symbol? ~s" arg) ())))
		 ((:template template) (parse-template arg))
		 ((vertical-distance vertical-distance-relative)
		  (validate-distance arg :vertical))
		 ((T) arg)))))
    (if (or normalized-value (eq type 'contents-list))	;an empty contents list is a valid NIL
	(values sym normalized-value)
	(signal 'sage-attribute-value-error :attribute sym
		:value arg :type type))))


;;; Box & Line stuff
;;; Store global line and box definitions somewhere globally
;;; and use the ambient value mechanism to override them locally.

(defun 2lookup-line-type-definition-10 (line-type document-type device-type)
  (declare (values value found-p))
  (lookup-line-or-box-type-internal line-type 'local-line-definitions
				    *line-type-definition-registry* document-type device-type))

(defun 2lookup-box-type-definition-10 (box-type document-type device-type)
  (declare (values value found-p))
  (lookup-line-or-box-type-internal box-type 'local-box-definitions
				    *box-type-definition-registry* document-type device-type))

(defun 2lookup-line-or-box-type-internal0 (type ambient-value-name global-hash-table
					 document-type device-type)
  (declare (values value found-p))
  (let ((local-definitions (lookup-ambient-value ambient-value-name :error-p nil)))
    (let ((entry
	    (or (and local-definitions
		     (gethash type local-definitions))
		(gethash type global-hash-table))))
      (if entry
	  (let* ((marker '#:marker)
		 (phase1 (getf entry device-type marker)))
	    (if (eq phase1 marker)
		(values nil nil)
		(let ((phase2 (getf phase1 document-type marker)))
		  (if (eq phase2 marker)
		      (values nil nil)
		      (values phase2 T)))))
	  (values nil nil)))))

(defun 2lookup-line-type-definition0 (line-type &optional document-type device-type)
  (declare (values value found-p))
  (lookup-line-or-box-type-definition-internal line-type 'lookup-line-type-definition-1 document-type device-type))

(defun 2lookup-box-type-definition0 (box-type &optional document-type device-type)
  (declare (values value found-p))
  (lookup-line-or-box-type-definition-internal box-type 'lookup-box-type-definition-1
					       document-type device-type))

(defun 2lookup-line-or-box-type-definition-internal0 (type finder document-type device-type)
  (declare (values value found-p))
  (unless document-type
    (setq document-type (if (variable-boundp *document-type*) *document-type* 'generic)))
  (unless device-type
    (setq device-type (if (variable-boundp *device-type*) *device-type* 'generic)))
  (macrolet ((multiple-value-or (&rest clauses)
	       `(block multiple-value-or
		  ,@(loop for x in clauses
			  collect `(multiple-value-bind (.value. .found.) ,x
				     (when .found.
				       (return-from multiple-value-or
					 (values .value. .found.))))))))
    (multiple-value-or
      (funcall finder type document-type device-type)
      (funcall finder type document-type 'generic)
      (funcall finder type 'generic device-type)
      (funcall finder type 'generic 'generic))))

(defun 2map-over-line-or-box-types0 (ambient-value-name global-hash-table
				   document-type device-type continuation)
  (declare (sys:downward-funarg continuation))
  (unless document-type
    (setq document-type (if (variable-boundp *document-type*) *document-type* 'generic)))
  (unless device-type
    (setq device-type (if (variable-boundp *device-type*) *device-type* 'generic)))
  (let ((local-definitions (lookup-ambient-value ambient-value-name :error-p nil)))
    (labels ((mapper-support (key entry)
	       (when (document-and-device-type-match-p entry)
		 (funcall continuation key)))
	     (document-and-device-type-match-p (entry)
	       (let ((value (or (getf entry device-type)
				(getf entry 'generic))))
		 (or (getf value document-type)
		     (getf value 'generic)))))
      (when local-definitions
	(maphash #'mapper-support local-definitions))
      (maphash #'mapper-support global-hash-table))))

(defun 2lookup-line-types0 (&optional document-type device-type)
  (let ((types nil))
    (map-over-line-or-box-types
      'local-line-definitions *line-type-definition-registry*
      document-type device-type
      #'(lambda (type) (push type types)))
    types))

(defun 2lookup-box-types0 (&optional document-type device-type)
  (let ((types nil))
    (map-over-line-or-box-types 'local-box-definitions *box-type-definition-registry*
				document-type device-type
				#'(lambda (type) (push type types)))
    types))

(defun 2line-type-known-p0 (line-type &optional document-type device-type)
  (map-over-line-or-box-types 'local-line-definitions *line-type-definition-registry*
			      document-type device-type
			      #'(lambda (type)
				  (when (eq type line-type)
				    (return-from line-type-known-p t)))))

(defun 2box-type-known-p0 (box-type &optional document-type device-type)
  (map-over-line-or-box-types 'local-box-definitions *box-type-definition-registry*
			      document-type device-type
			      #'(lambda (type)
				  (when (eq type box-type)
				    (return-from box-type-known-p t)))))

(defun 2set-type-definition-10 (hash-table
			      type document-type device-type definition)
  (setq definition (copy-list definition))
  (let ((entry (gethash type hash-table)))
    (cond ((null entry)
	   (setq entry `(,device-type (,document-type ,definition))))
	  (t (let ((sub-entry (getf entry device-type)))
	       (cond ((null sub-entry)
		      (setf (getf entry device-type) `(,document-type ,definition)))
		     (t (setf (getf sub-entry document-type) definition))))))
    (setf (gethash type hash-table) entry)))

(defun 2define-line-type-10 (line-type-name document-type device-type options)
  (set-type-definition-1 *line-type-definition-registry*
			 line-type-name document-type device-type options))

(defun 2define-box-type-10 (box-type-name document-type device-type options)
  (set-type-definition-1 *box-type-definition-registry*
			 box-type-name document-type device-type options))



;;; Takes the directive-descriptor of a command and returns T if the command can be followed
;;; by a pair of delimiters (with or without something inside them), NIL if the command cannot
;;; be followed by a pair of delimiters.
(defun EATS-DELIMITERS (command)
  (neq (dd-arglist command) :none))

;;;rules for the user macro-defining language:
;;;Parameter names go into the argument list.  Parameters are either positional
;;;or keyword, optional or required.  In the invocation, positional parameters come
;;;before keyword paramters.  [What about &rest for positional ones]
;;;In the definition "lambda list", positional parms come first, &optional and &key
;;;can appear in the list.  Anything to the right of &optional is optional (whether
;;;positional or key), anything to the right of &key is a keyword argument.  

;;;  The "contents" of the macro definition is a backquoted list.  The elements in the
;;;list can be strings, anything prefixed with comma, @ directives and lists of the
;;;same kind.
;;;  @ commands with no args can appear right in the list.  Any directive that has args
;;; or contents (like an environment) has to itself be a list.
;;;  The only whitespace that is significant in a macro definition is that within a string.
;;;[Should we have an @newline command or is @* good enough?]
;;;  To get one-time modifications for an environment, you have to use a long form @begin,
;;; which is a list of @begin, the environment name, and a list of mods (pairs or atoms).
(zl:comment
;;;No parameter.  Invocation is @em().
(define-sage-macro EM generic lgp ()
  '(""))

;;;One positional arg.  Invocation is @Bar[] or @bar[6pts]
(define-sage-macro BAR generic lgp (text)
  `((@begin format ((above ',text) group (below ',text)))
    (@tabclear)
    @& (@em) (@end format)))

;;;4 keyword args, all optional.  Invocation is @pageheading[left="hi",right="there"]
(define-sage-macro PAGEHEADING generic generic (&optional left right center line)
  `(@hdg @tabclear ,left @= ,center @> ,right @*
    (@bar 0)
    ,(if line `(@* ',line))))			;---more backquotes? ',' stuff?

;;;Three args, 2 required, one optional.  Invocation @XXX("This, and that, foo",Y="whatever")
;;;or perhaps @XXX(foo,Z=<things>,Y=<stuff>)
;;;Note: we don't have a way to get an optional position arg and a required key arg, unless
;;;we decide that the occurrence of &key resets an "optionality flag".
(define-sage-macro XXX generic generic (X &key Y &optional Z)
  `("Here it is: " ',X @*
    "Y is " ',Y
    ,(if Z `("and Z is " ',Z ".") ".")))
);end of comment


;;;The sage-macro defining macro.

;;;
;;;============================================================
;;; The book-design substrate
;;;============================================================
;;;

;; Truncates infinite recursion while hacking attributes.
;; ---The design flaw needs to be corrected.
(defvar 2*composing-book-design*0 nil)

(defun 2find-dd0 (entry doc-type)
  (or (find-directive-descriptor entry doc-type 'generic)
      (find-directive-descriptor entry 'generic 'generic)
      ;; just get the first dd out of the list
      (second (first (cdr (first entry))))))

(defun 2lookup-directive-descriptor0 (name &optional (document-type *document-type*)
						   (device-type *device-type*))
  (let ((local-directive-definitions
	  (lookup-ambient-value 'local-directive-definitions :error-p nil)))
    (or (and local-directive-definitions
	     (getf local-directive-definitions name))
	;; This is the common case, of course.
	(and (not *composing-book-design*)
	     (let* ((book-design-entry (composed-book-design document-type device-type))
		    (defs (book-design-specifics-envr-definitions book-design-entry)))
	       (gethash name defs)))
	(let* ((entry (send *formatter-directives* :get-hash (string name))))
	  (when entry
	    (or (find-directive-descriptor entry document-type device-type)
		(find-directive-descriptor entry document-type 'generic)
		(find-directive-descriptor entry 'generic device-type)
		(find-dd entry 'generic)))))))

(defun 2lookup-counter-descriptor0 (name &optional (document-type *document-type*)
						 (device-type *device-type*))
  (and (not *composing-book-design*)
       (let* ((book-design-entry (composed-book-design document-type device-type))
	      (defs (book-design-specifics-counter-definitions book-design-entry)))
	 (assoc name defs))))

(defun 2lookup-collector-descriptor0 (name &optional (document-type *document-type*)
						   (device-type *device-type*))
  (and (not *composing-book-design*)
       (let* ((book-design-entry (composed-book-design document-type device-type))
	      (defs (book-design-specifics-collector-definitions book-design-entry)))
	 (assoc name defs))))

(defvar 2*book-design-tick*0 0)

(defmacro 2define-book-design0 (name options &body forms)
  (multiple-value-bind (newforms new-functions)
      (compile-time-check-book-design-forms name options forms)
    `(progn
       (save-book-design ',name ',options ',newforms)
       ,@new-functions)))

(eval-when (eval compile load)
(defun 2compile-time-check-book-design-forms0 (name options forms)
  (when options
    (warn "The options arg to ~s is just a placeholder for future design.  It is being ignored."
	  'define-book-design))
  (flet ((map-collect-if (sequence function)
	   (cons (first sequence)
		 (zwei:zcollecting-into (result)
		   (dolist (item (rest sequence))
		     (catch 'retch
		       (zwei:zcollect result (funcall function item))))
		   result)))
	 (retch (string &rest args)
	   (warn "While processing (~s ~s ...):~%~:?"
		 'define-book-design name string args)
	   (throw 'retch nil)))
    (let ((new-functions ()))
      (values
        (rest
	  (map-collect-if
	    (cons nil forms)
	    (named-lambda forms (form)
	      (unless (consp form)
		(retch "Body forms must be lists.  ~s isn't, and will be ignored." form))
	      (case (first form)
		((use)
		 (map-collect-if
		   form
		   (named-lambda use (what)
		     (unless (symbolp what)
		       (retch "Things in USE clauses must be symbols.  ~s isn't, and will be ignored."
			      what))
		     what)))
		((define modify)
		 (map-collect-if
		   form
		   (named-lambda define-or-modify (what)
		     (when (atom what)
		       (retch "~a clauses can't be atoms.  ~s is, and will be ignored."
			      (first form) what))
		     what)))
		((counters)
		 (map-collect-if
		   form
		   (named-lambda counters (what)
		     (unless (and (consp what) (symbolp (first what)))
		       (retch "~a clauses must be lists, starting with a symbol.~@
				~s isn't, and will be ignored."
			      (first form) what))
		     (let ((substitutes ()))
		       (destructuring-bind (counter-name &rest subforms) what
			 (let ((ok '(:numbered :referenced :title :contents :within
					       :alias :incremented-by :init)))
			   (loop for (key subform) on subforms by #'cddr do
			     (unless (member key ok)
			       (retch "Subforms of ~a clauses must start with one of ~s.~@
					~s is used in ~s, and will be ignored."
				      (first form) ok key what))
			     (when (member key '(:title :contents))
			       (unless (or (symbolp subform)	;names a function to call
					   (and (consp subform)	;an arglist with body
						(consp (first subform))
						(= 2 (length (first subform)))
						(every #'symbolp (first subform))))
				 (retch "Subforms of ~a clauses must be functionoids.~@
				~s ~s isn't."
					(first form) key subform))
			       (when (consp subform)
				 (let ((function-name
					 (sys:fintern "render ~a as ~a for ~a"
						      counter-name key name)))
				   (push `(defun ,function-name ,(first subform)
					    (declare (sys:function-parent ,name define-book-design))
					    (progn ,@(first subform))	;burn the args
					    ,@(rest subform))
					 new-functions)
				   (push (cons subform function-name) substitutes)))))))
		       (if substitutes
			   (sublis substitutes what)
			   what)))))
		((first)
		 (map-collect-if
		   form
		   (named-lambda first (what)
		     (unless (consp what)
		       (retch "FIRST clauses can't be atoms.  ~s is, and will be ignored."
			      what))
		     (case (first what)
		       ((envr init)
			;;---It would be possible to descend a further level here.
			;; I ran out of gumption.
			what)
		       (otherwise
			 (retch "FIRST clauses must start with ENVR or INIT.  ~s doesn't, and will be ignored."
				what))))))
		((collectors)
		 ;; collectors specs look like
		 ;; (collector-name &key name init)
		 ;; the ordering of collectors determines the order in which they
		 ;; appear in the document.
		 ;; Example:
		 ;; (collectors
		 ;;  (contents :name "Table of Contents"
		 ;;            :init init-table-of-contents)
		 ;;  (figures :name "List of Figures")
		 ;;  (tables :name "List of Tables"))
		 (map-collect-if
		   form
		   (named-lambda collectors (what)
		     (condition-case (e)
			  (destructuring-bind (collector-name &key name init)
			      what
			    (ignore collector-name name init)
			    what)
			(si:destructuring-bind-argument-error
			  (retch "~A" e))))))
		(otherwise
		  (retch "Clauses must start with one of {~{~a~^, ~}}.  ~s doesn't, and will be ignored."
			 '(use define modify first counters collectors)
			 form))))))
	(nreverse new-functions))))))

(defflavor 2book-design-entry
0	(name
	 defining-source-file
	 (uses-tick) uses
	 (used-by-tick) used-by
	 definition-forms
	 )
	()
  :initable-instance-variables
  :writable-instance-variables
  )

(defmethod 2(sys:print-self book-design-entry)0 (stream &rest ignore)
  (si:printing-random-object (self stream :typep)
    (write name :stream stream)))

(compile-flavor-methods book-design-entry)

;; Use this instead of a list for (1) better locality; (2) better print-self
;; It registers (a) names  entries; (b) doc&dev-type  entries
(defstruct (2book-design-registry0 :named-array-leader :conc-name
				 (:constructor-make-array-keywords length))
  (fill-pointer 0)
  specifics
  )

(defvar 2*book-design-registry*
0	(make-book-design-registry :length 50))

(defflavor 2book-design-specifics
0	(document-type
	 device-type
	 entry
	 defining-source-file
	 (cache-tick ())
	 envr-definitions toplevel-envrs init-code (counter-definitions)
	 (collector-definitions)
	 )
	()
  :writable-instance-variables
  (:constructor
   make-book-design-specifics (document-type device-type entry defining-source-file)))

(defmethod 2(sys:print-self book-design-specifics)0 (stream &rest ignore)
  (si:printing-random-object (self stream :typep)
    (format stream "~a ~a" document-type device-type)))

(defmethod 2(set-book-design-composition book-design-specifics)0 (&rest values)
  (macrolet ((destructure-key-setq (values &rest vars)
	       ;; I really wanted (destructuring-setq (&key var var..) values)
	       (let ((keys (mapcar (lambda (sym) (intern (string sym) sys:pkg-keyword-package))
				   vars)))
		 `(let ((.values. ,values))
		    (unless (si:validate-defmacro-keywords .values. ',keys)
		      (error "The values ~s do not match the pattern ~s"
			     .values. '(&key ,@vars)))
		    ,@(domap 'list ((key keys) (var vars))
			`(setq ,var (getf .values. ',key)))))))
    (destructure-key-setq values envr-definitions toplevel-envrs
			  counter-definitions collector-definitions
			  init-code cache-tick))
  nil)

(defmethod 2(recompose-book-design book-design-specifics)0 ()
  (when cache-tick				;it was composed at some time
    (unless (eql cache-tick *book-design-tick*)
      (catch-error-restart (error "Skip recomposing book design for ~a ~a"
				  document-type device-type)
	(compose-book-design document-type device-type)))))

(defun 2remove-book-design-specifics0 (document-type device-type)
  (multiple-value-bind (ignore specifics)
      (find-book-design-entry document-type device-type)
    (when specifics
      (setf (book-design-registry-specifics *book-design-registry*)
	    (delete specifics (book-design-registry-specifics *book-design-registry*)))
      T)))

(compile-flavor-methods book-design-specifics)

;; I wish I could think of a better name for this
(defun 2note-book-design-specifics0 (document-type device-type entry-name)
  (let ((new-entry (find-book-design-entry-named entry-name)))
    (when (null new-entry)
      (error "Could not find book design entry named ~s" entry-name))
    (multiple-value-bind (old-entry specifics)
	(find-book-design-entry document-type device-type)
      (ignore old-entry)
      ;;---This could/should query about redefinitions and stuff.  See below.
      (cond (specifics
	     (setf (book-design-specifics-entry specifics) new-entry)
	     (setf (book-design-specifics-defining-source-file specifics)
		   sys:fdefine-file-pathname))
	    (T
	     (setq specifics (make-book-design-specifics
			       document-type device-type new-entry
			       sys:fdefine-file-pathname))
	     (push specifics
		   (book-design-registry-specifics *book-design-registry*)
		   :localize T)))
      specifics)))

;;; --- Should be moved to pkgdcl.
(export '(define-book-design note-book-design-specifics))

;; Run this when you alter something in *book-design-registry*
(defun 2note-book-design-alteration0 ()
  (incf *book-design-tick*)
  (flet ((entry-gone (specific)
	   (null (find-book-design-entry-named
		   (book-design-entry-name
		     (book-design-specifics-entry specific))))))
    (setf (book-design-registry-specifics *book-design-registry*)
	  (delete-if #'entry-gone (book-design-registry-specifics *book-design-registry*)))
    (domap nil ((specific (book-design-registry-specifics *book-design-registry*)))
      (let* ((old-entry (book-design-specifics-entry specific))
	     (new-entry (find-book-design-entry-named (book-design-entry-name old-entry))))
	(when (neq new-entry old-entry)		;don't alter if unnecessary -- IDS size?
	  (setf (book-design-specifics-entry specific) new-entry)))
      ;; Any book designs that have been composed must be recomposed as a result
      ;; of this patching, else an unseemly pause might happen during formatting.
      (recompose-book-design specific))))

(defun 2find-book-design-entry0 (document-type device-type)
  (declare (values entry specifics))
  (assert (and document-type device-type))
  (let ((specifics
	  (find-if (lambda (specifics)
		     (and (eql (book-design-specifics-document-type specifics) document-type)
			  (eql (book-design-specifics-device-type specifics) device-type)))
		   (book-design-registry-specifics *book-design-registry*))))
    (values (and specifics (book-design-specifics-entry specifics))
	    specifics)))

(defun 2find-book-design-entry-named0 (name)
  (find name *book-design-registry*
	:key #'book-design-entry-name))

(defun 2save-book-design0 (name options definition-forms)
  (ignore options)				;it's just a placeholder, after all
  (let ((new-entry
	  (make-instance 'book-design-entry
			 :name name
			 :defining-source-file (or si:patch-source-file-pathname
						   sys:fdefine-file-pathname)
			 :definition-forms definition-forms))
	(entry-already-there
	  (find name *book-design-registry* :key #'book-design-entry-name)))
    (if entry-already-there
	(let ((old-pathname (book-design-entry-defining-source-file entry-already-there))
	      (new-pathname (or si:patch-source-file-pathname
				sys:fdefine-file-pathname)))
	  (progn old-pathname new-pathname)
	  (when (or T
		    ;;---Fix this correctly when there's time.  The problems have
		    ;; to do with recording and querying from patch files.
		    (si:query-about-redefinition
		      name new-pathname "Book design entry" old-pathname))
2	    0(nsubstitute new-entry entry-already-there *book-design-registry*)
	    (note-book-design-alteration)))
	(progn
	  (vector-push-extend new-entry *book-design-registry*)
	  (note-book-design-alteration)))))

(defun 2remove-book-design-entry0 (entry)
  (let ((pos (position entry *book-design-registry*
		       :key (etypecase entry
			      (book-design-entry #'identity)
			      (symbol #'book-design-entry-name)))))
    (when (null pos)
      (error "~s is not in the book design registry" entry))
    (replace *book-design-registry* *book-design-registry*
	     :start1 pos
	     :start2 (1+ pos))
    (decf (fill-pointer *book-design-registry*))
    (setf (book-design-registry-specifics *book-design-registry*)
	  (delete entry (book-design-registry-specifics *book-design-registry*)
		  :key #'book-design-specifics-entry ))
    (note-book-design-alteration)))

(defun 2composed-book-design0 (document-type device-type)
  (assert (and document-type device-type))
  (multiple-value-bind (entry specifics) (find-book-design-entry document-type device-type)
    (when (null entry)
      (setq entry
	    (make-instance 'book-design-entry
			   :name (make-symbol (string-append (string document-type)
							     " "
							     (string device-type)))
			   :defining-source-file nil
			   :definition-forms ()))
      (vector-push-extend entry *book-design-registry*)
      (let ((sys:fdefine-file-pathname nil))	;this is bogus, after all...
	(note-book-design-specifics document-type device-type
				    (book-design-entry-name entry)))
      (multiple-value-setq (entry specifics)
	(find-book-design-entry document-type device-type))
      (assert (and entry specifics)))
    (unless (eql (book-design-specifics-cache-tick specifics) *book-design-tick*)
      (compose-book-design document-type device-type))
    specifics))

(defun 2compose-book-design0 (document-type device-type)
  (assert (and document-type device-type))
  (error-restart (error "Retry composing book design for ~a ~a" document-type device-type)
    (multiple-value-bind (entry specifics) (find-book-design-entry document-type device-type)
      (macrolet ((dbformat (string &rest args)
		   #+Franz
		   `(format *trace-output* ,string ,@args)))
	(let ((toplevel-envrs ())
	      (init-code ()))
	  (zwei:zcollecting-into (envr-definitions counter-definitions collector-definitions)
	    (labels ((do-definition-forms (user)
		       (dbformat "~&do-definition-forms ~s" user)
		       (dolist (form (book-design-entry-definition-forms user))
			 (ecase (first form)
			   ((use) (do-use-form user form))
			   ((define) (do-define-form user form))
			   ((modify) (do-modify-form user form))
			   ((first) (do-first-form user form))
			   ((counters) (do-counter-form user form))
			   ((collectors) (do-collector-form user form))
			   ))
		       (dbformat "~&done-with-definition-forms ~s" user))
		     (do-use-form (user form)
		       (dolist (usee (rest form))
			 (let (subentry)
			   (loop do (setq subentry (find-book-design-entry-named usee))
				 until subentry
				 do (cerror "Retry looking for it (presumably after repair)"
					    "Error in book design definition: ~s is trying ~
				         to use ~s which can't be found"
					    user usee))
			   (do-definition-forms subentry))))
		     (do-define-form (ignore form)
		       (dolist (def (rest form))
			 (destructuring-bind (envr-name &rest envr-mods) def
			   (dbformat "~&  Defining ~s" envr-name)
			   (let ((already-there (member envr-name envr-definitions :key #'first)))
			     (if already-there
				 (setf (first already-there)
				       (list envr-name envr-mods))
				 (zwei:zcollect envr-definitions
						(list envr-name envr-mods)))))))
		     (do-modify-form (user form)
		       (dolist (def (rest form))
			 (destructuring-bind (envr-name &rest envr-mods) def
			   (let ((pair (assoc envr-name envr-definitions)))
			     (dbformat "~&  Modifying ~s" envr-name)
			     (if pair
				 (setf (second pair)
				       (append (second pair) envr-mods))
				 (cerror "skip it"
					 "Error in book design definition: ~s is attempting to modify ~s which is undefined"
					 user envr-name))))))
		     (do-counter-form (user form)
		       (ignore user)
		       (dolist (def (rest form))
			 (destructuring-bind (counter-name &rest subforms) def
			   (dbformat "~&  Counter ~s" counter-name)
			   (let ((already-there (member counter-name counter-definitions
							:key #'first))
				 (counter-def (cons counter-name subforms)))
			     (if already-there
				 (setf (first already-there) counter-def)
				 (zwei:zcollect counter-definitions counter-def))))))
		     (do-collector-form (user form)
		       (ignore user)
		       (dolist (def (rest form))
			 (destructuring-bind (collector-name &rest stuff) def
			   (dbformat "~&  Collector ~s" collector-name)
			   (let ((already-there (member collector-name collector-definitions
							:key #'first))
				 (collector-def (cons collector-name stuff)))
			     (if already-there
				 (setf (first already-there) collector-def)
				 (zwei:zcollect collector-definitions collector-def))))))
		     (do-first-form (ignore form)
		       (zwei:zcollecting-into (top-envrs)
			 (dolist (def (rest form))
			   (destructuring-bind (which thing) def
			     (dbformat "~&  First ~s" which)
			     (ecase which
			       ((envr)
				(destructuring-bind (envr-name &rest envr-mods) thing
				  (dbformat "~&    ~s ~s" envr-name envr-mods)
				  (zwei:zcollect top-envrs
						 (cons envr-name (copy-alist envr-mods)))))
			       ((init)
				(dbformat "~&    ~s" thing)
				(setq init-code (nconc init-code (ncons thing)))))))
			 (when top-envrs
			   ;; This batch overrides any that might have been inherited.
			   (setq toplevel-envrs top-envrs))))
		     (tablize-envr-definitions ()
		       (let ((table (make-hash-table :size (length envr-definitions)
						     :locking nil)))
			 (dolist (envr-def envr-definitions)
			   (destructuring-bind (envr-name envr-mods) envr-def
			     (let ((dd (make-dd-for-envr-definition envr-name envr-mods
								    document-type device-type)))
			       (setf (gethash envr-name table) dd))))
			 table)))
	      (let ((*composing-book-design* T))
		(do-definition-forms entry)
		(set-book-design-composition specifics
					     :cache-tick *book-design-tick*
					     :envr-definitions (tablize-envr-definitions)
					     :counter-definitions counter-definitions
					     :collector-definitions collector-definitions
					     :toplevel-envrs toplevel-envrs
					     :init-code init-code)))))))))

(defun 2make-dd-for-envr-definition0 (envr-name envr-mods document-type device-type)
  (let ((dd (make-directive-descriptor)))
    (setf (dd-symbol dd)
	  (if (eq (symbol-package envr-name) *sage-package*)
	      envr-name
	      (intern (string envr-name) *sage-package*)))
    #+Ignore
    (unless (document-type-p document-type)
      (error "Invalid document type ~A" document-type))
    #+Ignore
    (unless (device-type-p device-type)
      (error "Invalid device type ~A" device-type))
    (setf (dd-document-type dd) document-type)
    (setf (dd-device-type dd) device-type)
    (setf (dd-parse-type dd) :environment)
    (setf (dd-definition dd)
	  (validate-environment-definition envr-mods document-type device-type))
    (setf (dd-arglist dd) nil)
    (multiple-value-bind (min-pos max-pos non-pos positionals keys any-keys list-of all)
	(extract-pattern nil)
      (setf (dd-min-pos-args dd) min-pos)
      (setf (dd-max-pos-args dd) max-pos)
      (setf (dd-non-pos-args dd) non-pos)
      (setf (dd-positional-args dd) positionals)
      (setf (dd-key-args dd) keys)
      (setf (dd-any-keys dd) any-keys)
      (setf (dd-list-of dd) list-of)
      (setf (dd-all dd) all))
    dd))

#||
(defvar *foo-table* (make-hash-table :locking nil))
(dolist (def (book-design-specifics-envr-definitions
	       (find-book-design-entry '3symanual 'lgp2)))
  (setf (gethash (first def) *foo-table*) (second def)))

(defun tst (e)
  (macrolet ((time-of (form)
	       `(- (time-of-1 ,form)
		   (time-of-1 nil)))
	     (time-of-1 (form)
	       `(let ((.start. (sys:%microsecond-clock)))
		  (dotimes (j 100) ,form)
		  (time-difference (sys:%microsecond-clock) .start.))))
    (without-interrupts
      (list
	(let* ((book-design (find-book-design-entry '3symanual 'lgp2))
	       (defs (book-design-specifics-envr-definitions book-design)))
	  (/ (time-of (assoc e defs)) 100.0))
	(/ (time-of (gethash e *foo-table*)) 100.0)))))
||#

(defun 2graph-book-design-uses0 (document-type device-type)
  (fresh-line)
  (let ((entry (find-book-design-entry document-type device-type)))
    (unless entry
      (format t "~&No book design for document type ~S, device-type ~S found."
	      document-type device-type)
      (return-from graph-book-design-uses (values)))
    (dw:format-graph-from-root 
      entry
      (named-lambda printer (entry stream)
	(dw:with-output-as-presentation (:stream stream
					 :type (type-of entry)
					 :object entry)
	  (princ (book-design-entry-name entry) stream)))
      (named-lambda inferior-producer (entry)
	(if (eql (book-design-entry-uses-tick entry) *book-design-tick*)
	    (book-design-entry-uses entry)
	    (zwei:zcollecting-into (usees)
	      (dolist (item (book-design-entry-definition-forms entry))
		(ecase (first item)
		  ((use)
		   (dolist (x (rest item))
		     (let ((entryx (find-book-design-entry-named x)))
		       (when entryx
			 (zwei:zcollect usees entryx)))))
		  ((define modify first counters collectors) )))
	      (setf (book-design-entry-uses entry) usees)
	      (setf (book-design-entry-uses-tick entry) *book-design-tick*)
	      usees)))
      :orientation :horizontal)))

(defun 2graph-book-design-users0 (name)
  (fresh-line)
  (let ((entry (find-book-design-entry-named name)))

    (unless entry
      (format t "~&No book design named ~A found." name)
      (return-from graph-book-design-users (values)))

    (dw:format-graph-from-root 
      entry
      (named-lambda printer (entry stream)
	(dw:with-output-as-presentation (:stream stream
					 :type (type-of entry)
					 :object entry)
	  (princ (book-design-entry-name entry) stream)))
      #'find-book-design-entry-users
      :orientation :horizontal
      :direction :before)))

(defun 2find-book-design-entry-users0 (entry)
  (let ((name (book-design-entry-name entry)))
    (if (eql (book-design-entry-used-by-tick entry) *book-design-tick*)
	(book-design-entry-used-by entry)
	(zwei:zcollecting-into (usees)
	  (domap nil ((subentry *book-design-registry*))
	    (unless (eql subentry entry)
	      (when (if (eql (book-design-entry-uses-tick subentry) *book-design-tick*)
			(member entry (book-design-entry-uses subentry))
			(or (some (named-lambda some-user (def)
				    (and (eql (first def) 'use)
					 (member name (rest def))))
				  (book-design-entry-definition-forms subentry))))
		(unless (member subentry usees)
		  (zwei:zcollect usees subentry)
		  ()))))
	  (setf (book-design-entry-used-by entry) usees)
	  (setf (book-design-entry-used-by-tick entry) *book-design-tick*)
	  usees))))

#+Ignore
(3 0 (NIL 0) (NIL NIL :SMALL) "TVFONT")(defun (4 0 (NIL 0) (NIL :BOLD :SMALL) "TVFONTCB")book-design-entry-less-generic3 (less more)
  (let ((lessdoc (book-design-entry-document-type less))
	(lessdev (book-design-entry-device-type less))
	(moredoc (book-design-entry-document-type more))
	(moredev (book-design-entry-device-type more)))
    (and
      ;; none can be nil
      lessdoc lessdev moredoc moredev
      ;; can't be identical
      (not (and (eq lessdoc moredoc) (eq lessdev moredev)))
      ;; something more generic matches it
      (flet ((mat (ldoc ldev)
	       (and (eq ldoc moredoc) (eq ldev moredev))))
	(or (mat lessdoc 'generic)
	    (mat 'generic lessdev)
	    (mat 'generic 'generic))))))

0;;; Copied almost verbatim out of sap:>rlb>wt>browse-book-design.lisp so that something
;;; useful will be in Concordia 1.0.

;;Some day this will present the above so you can click on them to change them.
(defun 2show-browser-document-and-device-types0 (doc-type dev-type)
  (format T "~&For document type ~s, device type ~s:"
	  doc-type dev-type))

(defun 2show-environment-derivation0 (envr-name-in-question &optional document-type device-type)
  (unless (and document-type device-type)
    (cond ((boundp '*document-type*)
	   (unless document-type
	     (setq document-type *document-type*))
	   (unless device-type
	     (setq device-type *device-type*)))
	  (t (format t "~&You must specify a document type and device type.")
	     (return-from show-environment-derivation (values)))))
  (show-browser-document-and-device-types document-type device-type)
  (with-document-and-device-types (document-type device-type)
    (multiple-value-bind (root-entry specifics)
	(find-book-design-entry document-type device-type)
      (ignore specifics)
      (let ((*package* *sage-package*))		;print a little more cleanly
	(show-environment-derivation-1 envr-name-in-question root-entry)
	(show-environment-derivation-2 envr-name-in-question root-entry)))))

(defun 2show-environment-derivation-10 (envr-name-in-question root-entry)
  (let ((pending (list envr-name-in-question)))
    (labels ((note-pending (new-envr)
	       (setq pending (nconc pending (ncons new-envr))))
	     (show-it (how definer envr-name envr-mods)
	       (let ((indent "    "))
		 (fresh-line)
		 (format T "  ~s (~a by ~s)~%~a"
			 envr-name how
			 (book-design-entry-name definer)
			 indent)
		 (formatting-textual-list (T :filled T :after-line-break indent)
		   (dolist (mod envr-mods)
		     (if (consp mod)
			 (destructuring-bind (attr value) mod
			   (formatting-textual-list-element ()
			     (format T "~:(~a~) ~s" attr value)))
			 (formatting-textual-list-element ()
			   (format T "~:(~a~)" mod)))))))
	     (do-definition-forms (user envr-of-interest)
	       (dolist (form (book-design-entry-definition-forms user))
		 (ecase (first form)
		   ((use) (do-use-form user form envr-of-interest))
		   ((define) (do-define-form user form envr-of-interest))
		   ((modify) (do-modify-form user form envr-of-interest))
		   ((first) )
		   ((counters) )
		   ((collectors) )
		   )))
	     (do-use-form (user form envr-of-interest)
	       (dolist (usee (rest form))
		 (let (subentry)
		   (loop do (setq subentry (find-book-design-entry-named usee))
			 until subentry
			 do (cerror "Retry looking for it (presumably after repair)"
				    "Error in book design definition: ~s is trying ~
				         to use ~s which can't be found"
				    user usee))
		   (do-definition-forms subentry envr-of-interest))))
	     (do-define-or-modify-form (which user form envr-of-interest)
	       (dolist (def (rest form))
		 (destructuring-bind (envr-name &rest envr-mods) def
		   (when (eq envr-name envr-of-interest)
		     (show-it which user envr-name envr-mods)
		     (dolist (mod envr-mods)
		       (multiple-value-bind (attr-name attr-value)
			   (if (consp mod)
			       (values (first mod) (second mod))
			       (values mod :none))
			 (when (member attr-name '(use copy))
			   (note-pending attr-value))
			 ))))))
	     (do-define-form (user form envr-of-interest)
	       (do-define-or-modify-form "Defined" user form envr-of-interest))
	     (do-modify-form (user form envr-of-interest)
	       (do-define-or-modify-form "Modified" user form envr-of-interest))
	     )
      (let ((*composing-book-design* T))
	(loop while pending
	      do
	  (do-definition-forms root-entry (pop pending))))
      )))

(defun 2show-environment-derivation-20 (envr-name-in-question root-entry)
  (macrolet ((dbformat (string &rest args)
	       `(format *trace-output* ,string ,@args)))
    (let ((all-attrs ()))
      (labels ((do-definition-forms (user envr-of-interest)
		 (dolist (form (book-design-entry-definition-forms user))
		   (ecase (first form)
		     ((use) (do-use-form user form envr-of-interest))
		     ((define) (do-define-form user form envr-of-interest))
		     ((modify) (do-modify-form user form envr-of-interest))
		     ((first) )
		     ((counters) )
		     ((collectors) )
		     )))
	       (do-use-form (user form envr-of-interest)
		 (dolist (usee (rest form))
		   (let (subentry)
		     (loop do (setq subentry (find-book-design-entry-named usee))
			   until subentry
			   do (cerror "Retry looking for it (presumably after repair)"
				      "Error in book design definition: ~s is trying ~
				         to use ~s which can't be found"
				      user usee))
		     (do-definition-forms subentry envr-of-interest))))
	       (do-define-or-modify-form (which user form envr-of-interest)
		 (let ((definer-name (book-design-entry-name user)))
		   (dolist (def (rest form))
		     (destructuring-bind (envr-name &rest envr-mods) def
		       (when (eq envr-name envr-of-interest)
			 (dolist (mod envr-mods)
			   (multiple-value-bind (attr-name attr-value)
			       (if (consp mod)
				   (values (first mod) (second mod))
				   (values mod :none))
			     (cond ((member attr-name '(use copy))
				    (do-definition-forms root-entry attr-value))
				   (T (push (list attr-name attr-value definer-name which)
					    all-attrs))))))))))
	       (do-define-form (user form envr-of-interest)
		 (do-define-or-modify-form "Defined" user form envr-of-interest))
	       (do-modify-form (user form envr-of-interest)
		 (do-define-or-modify-form "Modified" user form envr-of-interest))
	       )
	(let ((*composing-book-design* T))
	  (do-definition-forms root-entry envr-name-in-question))
	(let ((attrs-used ()))
	  (dolist (attr all-attrs)
	    (pushnew attr attrs-used :key #'first))
	  (setq all-attrs attrs-used))
	(format T "~&Net result")
	(dolist (attr-stuff all-attrs)
	  (destructuring-bind (attr-name attr-value definer-name which) attr-stuff
	    (fresh-line)
	    (format T "  ~:(~a~) ~s (~a by ~s)" attr-name attr-value which definer-name)))
	))))

;;; --- This should be in the pkgdcl, but I'm not allowed to patch the pkgdcl now.
;;; doughty 21 Jul 88.
(export '(graph-book-design-uses graph-book-design-users show-environment-derivation))


;;;Some stuff to describe an environment, slightly more readably.
;;;Takes an environment, a name, or a gbox.
(defun DESCRIBE-ENVIRONMENT (envr)
  (etypecase envr
    (environment 
      (let ((window *standard-output*))
	(send envr :describe-environment window)))
    (basic-gbox (describe-environment (send envr :environment)))
    (directive-descriptor
      (let ((def (dd-definition envr)))
	(format T "~&The definition of ~s in ~s looks like this: ~{~&     ~s~}"
		(dd-symbol envr) envr def)
	(let ((used (loop for x in def
			  when (and (consp x) (member (first x) '(use copy)))
			    return (second x))))
	  (when used (describe-environment used)))))
    ((or symbol string)
     (let ((dd (with-document-and-device-types ()
		 (lookup-directive-descriptor envr))))
       (cond ((null dd)
	      (format T "~&~s appears to be an undefined environment" envr))
	     (T (describe-environment dd))))))
  envr)

;;Lowercase bold
(format:defformat FORMAT:LCB (:one-arg) (arg params)
  params
  (let* ((stream format:*format-output*))
    (format stream "~'b~(~a~)~" arg)))

(defmethod (:DESCRIBE-ENVIRONMENT ENVIRONMENT) (stream)
  (flet ((noyesx (x) (cond ((null x) "no") ((eq x 'T) "yes") (T x))))
    (format stream "~&The Sage environment ~s has superior ~s"
	    self superior)
    (format stream "~&Current font family ~\\lcb\\ size ~d code ~\\lcb\\"
	    font-family font-size face-code)
    (format stream "~&Left margin ~d, line width ~d, right margin ~d, indentation ~d"
	    left-margin line-width right-margin indention)
    (format stream "~&Fill mode ~\\lcb\\, justification ~\\lcb\\.  ~
			Break on entry, ~\\lcb\\; on exit, ~\\lcb\\."
	    fill-mode (noyesx justification)
	    (noyesx break-on-entry) (noyesx break-on-exit))
    (format stream "~&Spaces ~\\lcb\\, leading spaces ~\\lcb\\.  ~
			Paragraph break style, ~\\lcb\\."
	    space-action leading-space-action paragraph-breaks)
    (format stream "~&Carriage-return action, ~\\lcb\\; blank-line action, ~\\lcb\\."
	    (noyesx carriage-return-action) (noyesx blank-line-action))
    (format stream "~&Resume paragraph on exit, ~\\lcb\\.  ~
			Hyphen may cause line break, ~\\lcb\\;  hyphenation, ~\\lcb\\."
	    (noyesx resume-paragraph-on-exit)
	    (noyesx hyphen-may-cause-line-break) (noyesx hyphenation))
    (format stream "~&Page breaks: on entry, ~\\lcb\\; on exit, ~\\lcb\\."
	    (noyesx page-break-on-entry) (noyesx page-break-on-exit))
    (format stream "~2&Number location ~\\lcb\\, attached counter ~a, environment counter ~a."
	    number-location (or attached-counter "none") (or environment-counter "none"))
    (format stream "~&Block disposition, ~\\lcb\\, Floating disposition, ~\\lcb\\."
	    (noyesx block-disposition)
	    (if (send self :operation-handled-p :floating-disposition)
		(send self :floating-disposition)
		"Not yet implemented"))
    (format stream "~&Paragraphs: spacing ~d, spread ~d, above ~d, below ~d"
	    spacing paragraph-spread minimum-above-spacing minimum-below-spacing)
    (format stream "~&Script Displacement ~d;  Fixed location ~d;  page-need ~d"
	    script-displacement fixed-location page-need)
    (format stream "~&Margins: sink ~d top ~d bottom ~d column ~d column width ~d columns ~d"
	    sink-margin top-margin bottom-margin column-margin column-width columns)
    (format stream "~2&Stuff: premature end, ~\\lcb\\; bold implementation, ~\\lcb\\."
	    (noyesx accept-premature-end) (noyesx bold-implementation))
    (format stream "~&       overlong lines, ~\\lcb\\; running heads, ~\\lcb\\."
	    (noyesx overlong-line-action) (noyesx running-heads))
    (format stream "~&Tabs: export, ~\\lcb\\; stops: ~d"
	    (noyesx tab-export) tab-stops)
    (format stream "~&Transformation, ~\\lcb\\; underlining, ~\\lcb\\; visibility, ~\\lcb\\."
	    (noyesx transformation)
	    (noyesx underlining)
	    (noyesx visibility))
    (format stream "~&Blanks size: narrowest ~d, widest ~d"
	    narrowest-blank widest-blank)
    (format stream "~&Peri-envr text: ~before entry, ~\\lcb\\; after entry, ~\\lcb\\~
			~&before exit, ~\\lcb\\; after exit, ~\\lcb\\~"
	    (if process-text-before-entry "yes" "no")
	    (if process-text-after-entry "yes" "no")
	    (if process-text-before-exit "yes" "no")
	    (if process-text-after-exit "yes" "no"))
    (format stream "~&Device characteristics:")
    (format stream "~&   Paper size: width ~d, height ~d"
	    paper-width paper-height)
    (format stream "~&   Width Increments horizontal ~d, vertical ~d"
	    horizontal-width-increment vertical-width-increment)
    (format stream "~&   Capabilities: ~backspace ~\\lcb\\, ~
				       overstrike ~\\lcb\\, ~
				       underline ~\\lcb\\, ~
				       bare cr ~\\lcb\\, ~
				       bare lf ~\\lcb\\, ~&~
				       fonts ~\\lcb\\, ~
				       lens ~\\lcb\\, ~
				       discrete pages ~\\lcb\\ ~
				       ~"
	    (noyesx can-backspace)
	    (noyesx can-overstrike)
	    (noyesx can-underline)
	    (noyesx can-bare-carriage-return)
	    (noyesx can-bare-line-feed)
	    (noyesx has-fonts)
	    (noyesx has-lens)
	    (noyesx discrete-pages))))
