;;; -*- Syntax: Common-lisp; Mode: LISP; Package: NSAGE; Base: 10; Lowercase: T -*-
;;;
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;

;;;contains the routines for dumping and loading compiled Sage files.
;;;Principal entry points:
;;; WRITE-SAB-RECORD (record stream)  (values start-pointer end-pointer)
;;; READ-SAB-RECORD (stream start-pointer nbytes)  record

(defresource sab-symbol-tables ()
  :constructor (make-hash-table)
  :deinitializer (send object :clear-hash))

(defstruct (sab-table :list)
  symbol-table
  string-table)

(defmacro with-sab-symbol-table ((table read-or-write stream) &body body)
  `(with-sab-symbol-table-1 ,read-or-write
			    ,stream
			    (named-lambda with-sab-symbol-table (,table)
			      (declare (sys:downward-function))
			      ,@body)))

(defmacro with-sab-character-loader ((loader-var stream) &body body)
  `(with-sab-character-loader-1 ,stream
				(named-lambda with-sab-character-loader (,loader-var)
				  (declare (sys:downward-function))
				  ,@body)))

(defmacro with-sab-character-dumper ((dumper-var stream) &body body)
  `(with-sab-character-dumper-1 ,stream
				(named-lambda with-sab-character-dumper (,dumper-var)
				  (declare (sys:downward-function))
				  ,@body)))

(defvar *sab-fat-string-encoding* :bin-character
  ":bin-character or :sab-manual")
(defvar *sab-file-io-trace* nil)		;(setq *sab-file-io-trace* T)

(defun with-sab-symbol-table-1 (read-or-write stream continuation)
  (declare (sys:downward-funarg continuation))
  (flet ((doit (symbol-table string-table)
	   (stack-let ((table (make-sab-table :symbol-table symbol-table
					      :string-table string-table)))
	     (funcall continuation table))))
    (ecase read-or-write
      (:read
	(using-resource (symbol-vector arrays-with-fill-pointer)
	  (ecase *sab-fat-string-encoding*
	    (:bin-character
	      (bin:with-character-loader (loader stream)
		(doit symbol-vector loader)))
	    (:sab-manual
	      (with-sab-character-loader (loader stream)
	        (doit symbol-vector loader))))))
      (:write
	(using-resource (symbol-table sab-symbol-tables)
	  (ecase *sab-fat-string-encoding*
	    (:bin-character
	      (bin:with-character-dumper (dumper stream)
		(doit symbol-table dumper)))
	    (:sab-manual
	      (with-sab-character-dumper (dumper stream)
	        (doit symbol-table dumper)))))))))

(defun read-sab-fat-string (stream table)
  (let* (;;(before (send stream :read-pointer))
	 (result
	   (ecase *sab-fat-string-encoding*
	     (:bin-character
	       (send (sab-table-string-table table) :load-string))
	     (:sab-manual
	       (read-sab-fat-string-1 stream table))))
	 ;;(after (send stream :read-pointer))
	 )
    ;;(push (list before after result) *data2*)
    result))

(defun write-sab-fat-string (string stream table)
  (let (;;(before (send stream :read-pointer))
	)
    (ecase *sab-fat-string-encoding*
      (:bin-character
	(send (sab-table-string-table table) :dump-string string))
      (:sab-manual
	(write-sab-fat-string-1 string stream table)))
    #+Franz
    (let ((after (send stream :read-pointer)))
      (push (list before after (copy-seq string)) *data*))))

(defmacro do-sequence ((var sequenceform) &body forms)
  `(map nil (named-lambda do-sequence (,var) ,@forms) ,sequenceform))

(defmacro do-vector ((var vectorform) &body forms)
  (let ((vector (make-symbol "vector"))
	(index (make-symbol "index")))
    `(let ((,vector ,vectorform))
       (declare (sys:array-register ,vector))
       (dotimes (,index (length ,vector))
	 (let ((,var (aref ,vector ,index)))
	   ,@forms)))))	      

;;; D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (:SWISS :BOLD :VERY-LARGE) "SWISS20B")sab file reading 
0(defparameter *allow-bogus-unique-id-in-sab-file* nil)

(defparameter *allow-not-real-doc-unique-id-in-sab-file* nil)

(defmacro def-sab-reader (code arglist &body body)
  (unless (and (= 2 (length arglist))
	       (member (first arglist) '(stream ignore))
	       (member (second arglist) '(table ignore)))
    (error "Invalid arglist ~s, should be ~s" arglist '(stream table)))
  (let ((name (intern (string-append "READER" code))))
    `(progn 'compile
	    (defun ,name ,arglist
	      (declare (sys:function-parent ,code def-sab-reader))
	      ,@body)
	    (install-sab-code-reader ',name ',code))))

(defmacro with-temp-sab-string ((string-var stream-var) &body body)
  `(using-resource (,string-var string-temp)
     (fill-temp-sab-string ,string-var ,stream-var)
     ,@body))

(defun install-sab-code-reader (name definition-name)
  (let ((code definition-name))
    (loop do (typecase code
	       (fixnum (when ( code 0) (return)))
	       (symbol
		(when (and (get code 'defconstant) (boundp code))
		  (setq code (symbol-value code))
		  (return)))
	       (otherwise))
	     (setq code (dbg:check-arg-1 'code code "a fixnum  0, or a sab code symbol")))
    (let* ((array (zl:local-declare ((special *sab-code-reader-dispatch*))
		    ;;The unusual coding practice herein is because of the order of forms
		    ;;within this file: define the macro, define the function which the
		    ;;macro expansion calls (which uses a variable defvar'ed by
		    ;;the expansion), call the macro
		    *sab-code-reader-dispatch*))
	   (length (array-total-size array))
	   (fun (symbol-function name)))
      (cond ((< code length)
	     (setf (aref array code) fun))
	    ((< code (* 2 length))
	     (adjust-array array (* 2 length))
	     (setf (aref array code) fun))
	    (T (error "It looks like the sab-reader code ~d. for ~s is too darn big."
		       code name))))
    (si:record-source-file-name definition-name 'def-sab-reader)))

(defmacro define-sab-codes ((number-of-codes-var list-of-codes-var reader-dispatch-var)
			    &rest codes)
  (let ((number-of-codes (length codes)))
    `(progn 'compile
	    (defparameter ,number-of-codes-var ,number-of-codes)
	    (defparameter ,list-of-codes-var ',codes)
	    (defvar ,reader-dispatch-var (make-array ,number-of-codes))
	    ,@(loop for code in codes
		    for i from 0
		    collect `(defconstant ,code ,i)))))

(defmacro patch-sab-code (new-sab-code code-value
			  number-of-codes-var list-of-codes-var reader-dispatch-var)
  `(progn
     (setq ,number-of-codes-var
	   (max ,number-of-codes-var (1+ ,code-value)))
     (setq ,list-of-codes-var
	   (replace (make-list ,number-of-codes-var) ,list-of-codes-var))
     (setf (elt ,list-of-codes-var ,code-value) ',new-sab-code)
     (setq ,reader-dispatch-var
	   (replace (make-array ,number-of-codes-var) ,reader-dispatch-var))
     (setf (elt ,reader-dispatch-var ,code-value)
	   ',(intern (string-append "READER" new-sab-code)))
     (defconstant ,new-sab-code ,code-value)))

(define-sab-codes (*number-of-sab-codes* *sab-code-names* *sab-code-reader-dispatch*)
  =sab-code-record=
  =sab-code-type-symbol=
  =sab-code-function-spec=
  =sab-code-field-alist=
  =sab-code-field-name=
  =sab-code-envr=
  =sab-code-envr-name=
  =sab-code-envr-mods=
  =sab-code-attribute-name=
  =sab-code-contents-list=
  =sab-code-fixnum=
  =sab-code-string=
  =sab-code-long-string=
  =sab-code-list=
  =sab-code-symbol-ref=
  =sab-code-uninterned-symbol-def=
  =sab-code-sage-pkg-symbol-def=
  =sab-code-pkg-symbol-def=
  =sab-code-doc-pkg-symbol-def=
  =sab-code-read-from-string=
  =sab-code-simple-command=
  =sab-code-command=
  =sab-code-simple-command-name=
  =sab-code-command-name=
  =sab-code-macro-call=
  =sab-code-macro-name=
  =sab-code-macro-arglist=
  =sab-code-location-pair=
  =sab-code-index=
  =sab-code-callee-triple-list=
  =sab-code-index-item=
  =sab-code-file-attribute-alist=
  =sab-code-keyword-pkg-symbol-def=
  =sab-code-reference=
  =sab-code-fat-string=
  =sab-code-unique-id=
  =sab-code-modification-history=
  =sab-code-token-list=
  =sab-code-file-attribute-string=
  =sab-code-callee-4ple-list=
  =sab-code-picture=
  =sab-code-8-bit-array=
  =sab-code-example-record-marker=
  =sab-code-extensible-reference=
  =sab-code-extensible-reference-take-two=	;yecch
  =sab-code-character=
  )


#+Ignore ; --- patch only!
(patch-sab-code (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")=sab-code-extensible-reference-take-two=0 44
		*number-of-sab-codes* *sab-code-names* *sab-code-reader-dispatch*)
#+Ignore ; --- patch only!
(patch-sab-code 2=sab-code-character=0 45
		*number-of-sab-codes* *sab-code-names* *sab-code-reader-dispatch*)

(defparameter *field-name-to-sab-code-alist*
	      `((unique-id ,=sab-code-unique-id= write-sab-unique-id)
		(version-number ,=sab-code-fixnum= write-sab-fixnum)
		(flags ,=sab-code-fixnum= write-sab-fixnum)
		(location ,=sab-code-location-pair= write-sab-location-pair)
		(tokens ,=sab-code-token-list= write-sab-token-list)
		(keywords ,=sab-code-contents-list= write-sab-contents-list)
		(callee-list ,=sab-code-callee-4ple-list= write-sab-callee-4ple-list)
		;; From old sab files
		(callees ,=sab-code-callee-triple-list= write-sab-callee-triple-list)
		(source-topic ,=sab-code-contents-list= write-sab-contents-list)
		(file-attribute-string ,=sab-code-file-attribute-string=
				       write-sab-file-attribute-string)
		(contents ,=sab-code-contents-list= write-sab-contents-list)
		(arglist ,=sab-code-contents-list= write-sab-contents-list)
		(modification-history ,=sab-code-modification-history=
				      write-sab-modification-history)
		;; From old sab files; same as contents
		(operation ,=sab-code-contents-list= write-sab-contents-list)
		;; From old sab files; same as source-title
		(title ,=sab-code-contents-list= write-sab-contents-list)
		(source-title ,=sab-code-contents-list= write-sab-contents-list)
		(oneliner ,=sab-code-contents-list= write-sab-contents-list)
		(related ,=sab-code-contents-list= write-sab-contents-list)
		(releasenumber ,=sab-code-contents-list= write-sab-contents-list)
		(abbrev ,=sab-code-contents-list= write-sab-contents-list)
		(notes ,=sab-code-contents-list= write-sab-contents-list)
		(glossary ,=sab-code-contents-list= write-sab-contents-list)
		(topic nil write-sab-topic-spec)			;seems bogus
		(type ,=sab-code-type-symbol= write-sab-type-spec)	;seems bogus
		(patched-from ,=sab-code-string= write-sab-string)
		(unique-index ,=sab-code-fixnum= write-sab-fixnum)
		))

(defflavor sab-error () (error))

(defflavor sab-type-invalid (thing should-be)
	   (sab-error)
  :initable-instance-variables)

(defflavor sab-code-invalid (stream code (should-be))
	   (sab-error)
  :initable-instance-variables)

(defmethod (:report sab-error :default) (stream)
  (format stream "SAB error"))

(defvar *sage-command-names-not-to-complain-about* ())

(defflavor invalid-compressed-sab-file-operation () (sab-error))

(defmethod (:report invalid-compressed-sab-file-operation) (stream)
  (format stream "Invalid operation for compressed SAB files"))

(defun fixup-old-doc-symbol-topic (name fields)
  ;; massively conservative
  ;; I don't know if there ever were symbols
  ;; like DOC:|The INPUT Editor|, but if there were
  ;; we don't want to screw with that capitalization...
  (labels ((capital-p (char)
	     (cond  ((alpha-char-p char) (upper-case-p char))
		    (t t)))
	   (capitalize-string (string)
	     (when (every #'capital-p string)
	       (setq string (capitalize-string-as-title (string-downcase string))))
	     string))
    (when (and (symbolp name) (null (symbol-package name)))
      (setq name (or (let ((field (assoc 'source-topic fields)))
		       (when field
			 (filtered-string-from-contents-list (second field))))
		     (capitalize-string (string name))))))
  name)

(defun fixup-view (view)
  (cond ((view-is-crossreference-p (if (consp view) (first view) view))
	 'crossreference)
	(t view)))

;;; This used to be 2flet0ted inside read-sab-record, but proved generally useful
(defun 2read-sab-record-10 (stream)
  (with-sab-symbol-table (table :read stream)
    (read-sab-thing stream table =sab-code-record=)))

(defun 2read-sab-record0 (stream start-pointer nbytes)
  (cond ((operation-handled-p stream :read-bytes)
	 (send stream :read-bytes nbytes start-pointer)
	 (let ((record (read-sab-record-1 stream)))
	   (loop for count from 0		;Eat the eof marker to free server resources
		 while (send stream :tyi)
		 finally (when (and *debugging-sage* (> count 0))
			   (break "Had to read ~d extra bytes to get to end of record"
				  count)))
	   record))
	(T (send stream :set-pointer start-pointer)
	   (let ((record (read-sab-record-1 stream))) ;;--- could verify end pointer, if we wanted.
	     (send stream :set-pointer (send stream :length))	;shut off the firehose
	     record))))

(defvar 2*index-progress-continuation*0 ())

(defun read-sab-index (stream &key progress-note-continuation)
  ;;Bind this to itself for the hairy invalid proceed types
  (let ((*sage-command-names-not-to-complain-about*
	  *sage-command-names-not-to-complain-about*)
	(*index-progress-continuation* progress-note-continuation))
    (with-sab-symbol-table (table :read stream)
      (let ((info (read-sab-thing stream table =sab-code-index=)))
	info))))

(defun read-sab-file-attribute-alist (stream)
  (let ((alist (with-sab-symbol-table (table :read stream)
		 (read-sab-thing stream table =sab-code-file-attribute-alist=))))
    (let ((lsp (assoc :logical-source-pathname alist))
	  ;; Copy the version from the truename into the stream's
	  ;; (presumably logical) pathname.
	  (better-pathname (send (send stream :pathname)
				 :new-version (send (send stream :truename) :version))))
	 (if lsp
	     (setf (second lsp) better-pathname)
	     (push (list :logical-source-pathname better-pathname) alist)))
    alist))

(defun read-sab-thing (stream table required-sab-type)
  (let ((code (send stream :tyi)))
    (when *sab-file-io-trace*
      (format T "~&---Read sab code ~d ~s" code (sab-code-name code)))
    (when required-sab-type
      (unless (= code required-sab-type)
	(signal 'sab-code-invalid :stream stream :code code :should-be required-sab-type)))
    (let ((function (condition-case ()
			(aref *sab-code-reader-dispatch* code)
		      (sys:subscript-out-of-bounds
			(signal 'sab-code-invalid :stream stream :code code)))))
      (if function
	  (funcall function stream table)
	  (signal 'sab-code-invalid :stream stream :code code)))))

(defun fill-temp-sab-string (string stream)
  (let ((code (send stream :tyi)))
    (when *sab-file-io-trace*
      (format T "~&---Read sab code ~d ~s" code (sab-code-name code)))
    (select code
      (=sab-code-string=
       (let ((length (read-8-bit-number stream)))
	 (setf (fill-pointer string) length)
	 (si:read-simple-string-from-binary-stream stream string 0 length)))
      (=sab-code-long-string=
       (let ((length (read-32-bit-number stream)))
	 (when (and *debugging-sage* ( length 2048.))
	   (cerror "Do it anyway"
		   "Attempting to fill a string ~d. bytes long, which seems excessive."
		    length))
	 (setf (fill-pointer string) length)
	 (si:read-simple-string-from-binary-stream stream string 0 length)))
      (otherwise (signal 'sab-code-invalid
			 :stream stream
			 :code code
			 :should-be (list =sab-code-string= =sab-code-long-string=))))))

(def-sab-reader =sab-code-record= (stream table)
  (let ((name (read-sab-thing stream table ()))
	(type (read-sab-thing stream table =sab-code-type-symbol=))
	(field-alist (read-sab-thing stream table =sab-code-field-alist=)))
    (setq name (fixup-old-doc-symbol-topic name field-alist))
    (list 'record name type field-alist)))

(def-sab-reader =sab-code-type-symbol= (stream table)
  (let ((thing (read-sab-thing stream table ())))
    (sab-validate-type-code-symbol thing)
    thing))

(def-sab-reader =sab-code-function-spec= (stream table)
  table
  (with-temp-sab-string (temp stream)
    (flet ((kludge ()
	     (let ((result (maybe-convert-string-to-spec temp)))
	       ;; If temp is a complete loser, even as lisp topic, it will be returned.
	       ;; So, we must copy it before it gets returned to the resource.
	       (if (eq result temp)
		   (copy-string result)
		   result))))
      (with-standard-io-environment
	(condition-case (err)
	     (multiple-value-bind (spec how-far)
		 (read-from-string temp)
	       (cond ((< how-far (string-length temp))
		      ;; if we didn't read it all
		      (kludge))
		     ((typep spec '(or symbol list))
		      (if (sys:validate-function-spec spec)
			  spec
			  (kludge)))
		     ;; Maybe it's @L(#\Return) or something
		     (T spec)))
	   (sys:read-error
	     (kludge)))))))

(def-sab-reader =sab-code-field-alist= (stream table)
  (loop repeat (read-16-bit-number stream)
	collect (multiple-value-bind (field-name sab-code)
		    (read-sab-thing stream table =sab-code-field-name=)
		  (list field-name
			(read-sab-thing stream table sab-code)))))

(def-sab-reader =sab-code-field-name= (stream table)
  (let* ((field-name (read-sab-thing stream table ()))
	 (sab-code (second (sab-validate-field-name field-name))))
    (values field-name sab-code)))

(def-sab-reader =sab-code-unique-id= (stream table)
  (let ((unique-id (read-sab-thing stream table ())))
    (sab-validate-unique-id unique-id)
    unique-id))

(def-sab-reader =sab-code-modification-history= (stream table)
  (let ((thing (read-sab-thing stream table ())))
    (sab-validate-modification-history thing)
    thing))

(def-sab-reader =sab-code-token-list= (stream table)
  (let ((thing (read-sab-thing stream table ())))
    (sab-validate-token-list thing)
    thing))

(def-sab-reader =sab-code-file-attribute-string= (stream table)
  (ignore table)
  (with-temp-sab-string (string stream)
    (unless (string-equal string "")
      (copy-string string))))

(def-sab-reader =sab-code-contents-list= (stream table)
  (loop repeat (read-16-bit-number stream)
	collect (read-sab-thing stream table ())))

(def-sab-reader =sab-code-envr= (stream table)
  (let ((envr-name (read-sab-thing stream table =sab-code-envr-name=))
	(envr-mods (read-sab-thing stream table =sab-code-envr-mods=))
	(contents-list (read-sab-thing stream table =sab-code-contents-list=)))
    (make-sage-envr envr-name envr-mods contents-list)))

(def-sab-reader =sab-code-envr-name= (stream table)
  (let ((thing (read-sab-thing stream table ())))
    (when (equal thing 'sage:bar)
      (setf thing 'sage::old-bar-environment))
    (sab-validate-envr-name thing)
    thing))

(def-sab-reader =sab-code-envr-mods= (stream table)
  (loop repeat (read-16-bit-number stream)
	collect (list (read-sab-thing stream table =sab-code-attribute-name=)
		      (read-sab-thing stream table ()))))

(def-sab-reader =sab-code-fixnum= (stream table)
  table
  (read-32-bit-number stream))

(def-sab-reader =sab-code-string= (stream table)
  table
  (let ((string (make-array (read-8-bit-number stream) :element-type 'string-char)))
    (si:read-simple-string-from-binary-stream stream string)
    string))

(def-sab-reader =sab-code-fat-string= (stream table)
  (read-sab-fat-string stream table))

(def-sab-reader =sab-code-character= (stream table)
  (let ((string (read-sab-thing stream table nil)))
    (assert (stringp string) (string) "The sab object read, ~s, was not a string" string)
    (character string)))

(defun with-sab-character-loader-1 (stream continuation)
  (declare (sys:downward-funarg continuation))
  (ignore stream)
  (sys:with-stack-array (character-style-vector 20 :fill-pointer 0)
    (funcall continuation character-style-vector)))

(defun read-sab-fat-string-1 (stream table)
  (let ((character-style-vector (sab-table-string-table table)))
    (let ((number-of-new-ones (read-byte stream)))
      (dotimes (j number-of-new-ones)
	(vector-push-extend (si:intern-character-style
			      (read-sab-thing stream table ())
			      (read-sab-thing stream table ())
			      (read-sab-thing stream table ()))
			    character-style-vector))
      (let ((length (read-16-bit-number stream)))
	(when *sab-file-io-trace*
	  (format T "~&---reading fat string ~d long" length))
	(let ((string (make-array length :element-type 'character)))
	  (let ((start 0))
	    (loop while (< start length)
		  do
	      (let* ((style-index (read-byte stream))
		     (style (aref character-style-vector style-index)))
		(with-temp-sab-string (temp stream)
		  (when (> (+ (length temp) start) length)
		    (error "Internal error -- inner string too long"))
		  (when *sab-file-io-trace*
		    (format T "~&---read style ~a, string ~s" style temp))
		  (do-vector (char temp)
		    (setf (aref string start) (make-character char :style style))
		    (incf start))))))
	  (when *sab-file-io-trace*
	    (format T "~&---Finally ~s" string))
	  string)))))

(def-sab-reader =sab-code-attribute-name= (stream table)
  (let ((thing (read-sab-thing stream table ())))
    (sab-validate-attribute-name thing)
    thing))

(def-sab-reader =sab-code-long-string= (stream table)
  table
  (let ((length (read-32-bit-number stream)))
    (when (and *debugging-sage* ( length 32768.))	;a PDP-11 address space
      (cerror "Make one anyway"
	      "Attempting to make a string ~d. bytes long, which seems excessive.  Resume if ok."
	       length)
      ;;But, <resume> will do it anyway.
      )
    (let ((string (make-array length :element-type 'string-char)))
      (si:read-simple-string-from-binary-stream stream string)
      string)))

(def-sab-reader =sab-code-list= (stream table)
  (loop repeat (read-16-bit-number stream)
	collect (read-sab-thing stream table ())))

(def-sab-reader =sab-code-symbol-ref= (stream table)
  (let ((symbol-vector (sab-table-symbol-table table)))
    (let ((index (read-16-bit-number stream)))
      (if ( index (fill-pointer symbol-vector))
	  (error "Reference to symbol index ~d., which is beyond the current bound ~d."
		 index (fill-pointer symbol-vector))
	  (aref symbol-vector index)))))

(def-sab-reader =sab-code-uninterned-symbol-def= (stream table)
  (let ((symbol-vector (sab-table-symbol-table table)))
    (let ((sym (with-temp-sab-string (temp stream)
		 (make-symbol (copy-string temp)))))
      (vector-push-extend sym symbol-vector)
      sym)))

(defun read-sab-symbol (stream table package)
  (let ((symbol-vector (sab-table-symbol-table table)))
    (let ((sym (with-temp-sab-string (temp stream)
		 (condition-case ()
		      (intern temp (and package (pkg-find-package package)))
		    (error (let ((*package* (pkg-find-package package t)))
			     (phony-function-spec-intern
			       (slashify-string temp))))))))
      (vector-push-extend sym symbol-vector)
      sym)))

(def-sab-reader =sab-code-sage-pkg-symbol-def= (stream table)
  (read-sab-symbol stream table *sage-package*))

(def-sab-reader =sab-code-doc-pkg-symbol-def= (stream table)
  (let ((symb (reader=sab-code-uninterned-symbol-def= stream table)))
    #+debugging
    (cerror "Go ahead, using the uninterned symbol"
	    "Attempt to read the doc symbol ~A" symb)
    symb))

(def-sab-reader =sab-code-keyword-pkg-symbol-def= (stream table)
  (read-sab-symbol stream table sys:pkg-keyword-package))

(def-sab-reader =sab-code-pkg-symbol-def= (stream table)
  (with-temp-sab-string (pkg stream)
    (read-sab-symbol stream table pkg)))

(def-sab-reader =sab-code-read-from-string= (stream table)
  table
  (with-temp-sab-string (temp stream)
    (multiple-value-bind (thing how-far)
	(with-standard-io-environment
	  (read-from-string temp))
      (when (loop for c from how-far below (string-length temp)
		  for ch = (aref temp c)
		  thereis (not (char-white-space-p ch)))
	(error "There remains unread text in ~s (internal error)" temp))
      thing)))

(def-sab-reader =sab-code-simple-command= (stream table)
  (let ((name (read-sab-thing stream table =sab-code-simple-command-name=)))
    (make-sage-command name)))

(def-sab-reader =sab-code-command= (stream table)
  (let ((name (read-sab-thing stream table =sab-code-command-name=))
	(parameter (read-sab-thing stream table ())))
    ;;---Kludge to get new @L things from old SAB files
    (when (and (eq name 'L)
	       (consp parameter)
	       (stringp (first parameter)))
      (setf (first parameter)
	    (parse-L-string (convert-phony-function-spec-string (first parameter)))))
    (make-sage-command name parameter)))

(def-sab-reader =sab-code-simple-command-name= (stream table)
  (let ((name (read-sab-thing stream table ())))
    (sab-validate-sage-simple-command-name name)
    name))

(def-sab-reader =sab-code-command-name= (stream table)
  (let ((name (read-sab-thing stream table ())))
    (sab-validate-sage-param-command-name name)
    name))

(def-sab-reader =sab-code-macro-call= (stream table)
  (let ((macro-name (read-sab-thing stream table =sab-code-macro-name=))
	(macro-args (read-sab-thing stream table =sab-code-macro-arglist=)))
    (make-sage-macro-call macro-name macro-args)))

(def-sab-reader =sab-code-macro-name= (stream table)
  (let ((name (read-sab-thing stream table ())))
    ;;---sab-validate-sage-macro-name
    (unless (eq (symbol-package name) *sage-package*)
      (signal 'sab-type-invalid :thing name :should-be "a Sage macro name"))
    name))

(def-sab-reader =sab-code-macro-arglist= (stream table)
  (let ((arglist (read-sab-thing stream table ())))
    ;;---Since this isn't pinned down yet, we can't really validate it here.
    arglist))

(def-sab-reader =sab-code-reference= (stream table)
  (let* ((topic (read-sab-thing stream table ()))
	 (type (read-sab-thing stream table =sab-code-type-symbol=))
	 (unique-id (read-sab-thing stream table ()))
	 (view (read-sab-thing stream table ()))
	 (field (read-sab-thing stream table ())))
    (setq topic (fixup-old-doc-symbol-topic topic ()))
    (setq view (fixup-view view))
    (let ((appearance (and (eq view 'crossreference) 'see))
	  (booleans (and (eq view 'crossreference)
			 (crossreference-appearance-default-booleans 'See))))
      (when (eq view 'topic)
	(setq view 'crossreference
	      appearance 'topic
	      booleans (crossreference-appearance-default-booleans 'Topic)))
      (build-sage-reference (alist-nonnull 'topic topic
					   'type type
					   (if (integerp unique-id) 'unique-index 'unique-id)
					   unique-id
					   'view view
					   'appearance appearance
					   'booleans booleans
					   'field field)))))

(def-sab-reader =sab-code-extensible-reference= (stream table)
  (let* ((topic (read-sab-thing stream table ()))
	 (type (read-sab-thing stream table =sab-code-type-symbol=))
	 (unique-id (read-sab-thing stream table ()))
	 (view (read-sab-thing stream table ()))
	 (appearance (read-sab-thing stream table ()))
	 (booleans (crossreference-appearance-default-booleans appearance))
	 (field (read-sab-thing stream table ())))
    (setq topic (fixup-old-doc-symbol-topic topic ()))
    (setq view (fixup-view view))
    (build-sage-reference (alist-nonnull 'topic topic
					 'type type
					 (if (integerp unique-id) 'unique-index 'unique-id)
					    unique-id
					 'view view
					 'appearance appearance
					 'booleans booleans
					 'field field))))

(def-sab-reader =sab-code-extensible-reference-take-two= (stream table)
  (let ((topic (read-sab-thing stream table ()))
	 (type (read-sab-thing stream table =sab-code-type-symbol=))
	 (unique-id (read-sab-thing stream table ()))
	 (view (read-sab-thing stream table ()))
	 (appearance (read-sab-thing stream table ()))
	 (booleans (read-sab-thing stream table ()))
	 (field (read-sab-thing stream table ())))
    (setq topic (fixup-old-doc-symbol-topic topic ()))
    (setq view (fixup-view view))
    (build-sage-reference (alist-nonnull 'topic topic
					 'type type
					 (if (integerp unique-id) 'unique-index 'unique-id)
					    unique-id
					 'view view
					 'appearance appearance
					 'booleans booleans
					 'field field))))

(def-sab-reader =sab-code-location-pair= (stream table)
  table
  (let ((from (read-sab-thing stream table =sab-code-fixnum=))
	(to (read-sab-thing stream table =sab-code-fixnum=)))
    (list from to)))

(def-sab-reader =sab-code-callee-4ple-list= (stream table)
  (loop repeat (read-16-bit-number stream)
	collect (let ((topic (read-sab-thing stream table ()))
		      (type (read-sab-thing stream table =sab-code-type-symbol=))
		      (called-how (read-sab-thing stream table ()))
		      (unique-id (read-sab-thing stream table ())))
		  (setq topic (fixup-old-doc-symbol-topic topic ()))
		  (setq called-how (fixup-view called-how))
		  ;;(sab-validate-sab-topic ---)
		  (list topic type called-how unique-id))))

(def-sab-reader =sab-code-callee-triple-list= (stream table)
  (loop repeat (read-16-bit-number stream)
	collect (let ((topic (read-sab-thing stream table ()))
		      (type (read-sab-thing stream table =sab-code-type-symbol=))
		      (called-how (read-sab-thing stream table ())))
		  (setq topic (fixup-old-doc-symbol-topic topic ()))
		  (setq called-how (fixup-view called-how))
		  ;;(sab-validate-sab-topic ---)
		  (list topic type called-how))))

(def-sab-reader =sab-code-index= (stream table)
  (let ((nthings (read-32-bit-number stream)))
    (tv:noting-progress-if (null *index-progress-continuation*)
	("Reading SAB index")
      (loop repeat nthings
	    for count from 1
	    collecting (read-sab-thing stream table =sab-code-index-item=)
	    do
	(if *index-progress-continuation*
	    (funcall *index-progress-continuation*
		     :numerator count
		     :denominator nthings)
	    (tv:note-progress count nthings))))))

(def-sab-reader =sab-code-index-item= (stream table)
  (let ((topic (read-sab-thing stream table ()))
	(type (read-sab-thing stream table =sab-code-type-symbol=))
	(fields (loop repeat (read-16-bit-number stream)
		      collect (multiple-value-bind (field-name sab-code)
				  (read-sab-thing stream table =sab-code-field-name=)
				(list field-name (read-sab-thing stream table sab-code))))))
    (setq topic (fixup-old-doc-symbol-topic topic fields))
    (list topic type fields)))

(def-sab-reader =sab-code-file-attribute-alist= (stream table)
  (let ((alist (read-sab-thing stream table ())))
    (unless (and (consp alist)
		 (loop for pair in alist
		       always (and (consp pair) (symbolp (first pair)))))
      (signal 'sab-type-invalid :thing alist :should-be "an alist with symbols in all CARs"))
    alist))

(def-sab-reader 2=sab-code-8-bit-array=0 (stream table)
  (ignore table)
  (let ((array-length (read-32-bit-number stream)))
    (let ((array (make-array array-length :element-type '(unsigned-byte 8))))
      (send stream :string-in "filling 8-bit array" array)
      array)))

;; reads type, file-name, picture-name, and binary-encoding
(def-sab-reader 2=sab-code-picture=0 (stream table)
  (let ((type (read-sab-thing stream table ()))
	(file-name (read-sab-thing stream table ()))
	(name (read-sab-thing stream table =sab-code-string=))
	(contents (read-sab-thing stream table ()))
	binary-encoding drawing-function)
    (etypecase contents
      ((array (unsigned-byte 8))
       (setq binary-encoding contents))
      ((and symbol (not null))
       (setq drawing-function contents)))
    (make-sage-picture :type type
		       :file-name file-name
		       :name name
		       :binary-encoding binary-encoding
		       :drawing-function drawing-function)))

(def-sab-reader =sab-code-example-record-marker= (stream table)
  (let ((type (read-sab-thing stream table ()))
	(encoding (read-sab-thing stream table ())))
    (make-example-record-marker :type type
				:encoding encoding)))

(defmethod (:report sab-type-invalid) (stream)
  (format stream "The name ~s does not name ~a" thing should-be))

(defmethod (:proceed sab-type-invalid :use-it-anyway) (&optional ignore)
  "Use it anyway"
  :use-it-anyway)

(defmethod (:proceed sab-type-invalid :install-it) (&optional ignore)
  "Use it, and don't complain any more for the current compilation"
  :install-it)

(defun sab-validate-type-code-symbol (thing)
  (unless (member thing *all-object-types*)
    (signal 'sab-type-invalid :thing thing :should-be "a valid record object type")))

(defun sab-validate-field-name (thing)
  (let ((element (assoc thing *field-name-to-sab-code-alist*)))
    (unless element
      (signal 'sab-type-invalid :thing thing :should-be "a valid record field name"))
    element))

(defun sab-validate-unique-id (thing)
  (unless (and (stringp thing)
	       (ecase (unique-id-validity thing)
		 ((:valid :undefined-reference) t)
		 (:bogus *allow-bogus-unique-id-in-sab-file*)))
    (signal 'sab-type-invalid :thing thing :should-be "a valid unique-id")))

(defun sab-validate-modification-history (thing)
  (unless (or (null thing)
	      (and (consp thing) (every #'modification-history-element-p thing)))
    (signal 'sab-type-invalid :thing thing :should-be "a valid modification history")))

(defun sab-validate-token-list (thing)
  (unless (or (null thing)
	      (and (consp thing)
		   (every (lambda (ele)
			    (or (null ele) (and (consp ele) (every #'stringp ele))))
			  thing)))
    (signal 'sab-type-invalid :thing thing :should-be "a valid token list")))

(defun sab-validate-envr-name (thing)
  ;;---Does the document-type arg to validate-environment-name really want to be generic?
  ;;I suppose that while loading index info the document type is unknown so genericity
  ;;should be enforced?
  (validate-environment-name thing (or *document-type* 'generic)))

(defun sab-validate-attribute-name (thing)
  (unless (lookup-attribute-descriptor (string thing))
    (signal 'sab-type-invalid :thing thing :should-be "a valid environment attribute")))

(defmethod (:report sab-code-invalid) (report-stream)
  (cond ((null should-be)
	 (format report-stream "The stream ~s supplied the code ~d. (~a) which is ~
				not valid as a SAB code."
		 stream code (sab-code-name code)))
	((consp should-be)
	 (format report-stream
		 "The stream ~s supplied the code ~d. (~a), where it was required to ~
			have one of~&"
		 stream code (sab-code-name code))
	 (loop for should in should-be
	       do (format report-stream " ~d. (~a)" should (sab-code-name should))))
	(T (format report-stream "The stream ~s supplied the code ~d. (~a), where ~d. (~a) ~
					was required."
		   stream code (sab-code-name code) should-be (sab-code-name should-be)))))

(defun sab-code-name (code)
  (or (and (typep code 'fixnum) (< -1 code *number-of-sab-codes*)
	   (nth code *sab-code-names*))
      (format () "a sab code ~d." code)))

(defun sab-validate-sage-simple-command-name (name)
  (let ((command-desc (lookup-command-descriptor name)))
    (if command-desc
	(if (let ((arglist (dd-arglist command-desc)))
	      (or (null arglist) (eq arglist :none)))
	    T
	    ;;It is there, but it takes a param
	    (signal-proceed-case (() 'sab-type-invalid :thing name
				  :should-be
				  "the name of a paramless Sage command")
	      (:use-it-anyway T)))
	(let ((no-complaints (lookup-sage-command-not-to-complain-about name)))
	  (ecase no-complaints
	    (simple T)
	    (param ;;It is there, but it was said to take a param
	      (signal-proceed-case (() 'sab-type-invalid :thing name
				    :should-be
				    "the name of a paramless Sage command")
		(:use-it-anyway T)))
	    ((nil) (signal-proceed-case (() 'sab-type-invalid :thing name
				       :should-be
				       "the name of a paramless Sage command")
		   (:use-it-anyway T)
		   (:install-it
		    (dont-complain-about-sage-command name 'simple)
		    T))))))))

(defun sab-validate-sage-param-command-name (name)
  (let ((command-desc (lookup-command-descriptor name)))
    (if command-desc
	t
	#||
	;; Can't do this check now that nothing is dumped as a simple command
	(if (let ((arglist (dd-arglist command-desc)))
	      (and arglist (neq arglist :none)))
	    T
	    ;;It is there, but it does not take params
	    (signal-proceed-case (() 'sab-type-invalid :thing name
				  :should-be
				  "the name of a Sage command that takes params")
	      (:use-it-anyway T)))
	||#
	(let ((no-complaints (lookup-sage-command-not-to-complain-about name)))
	  (ecase no-complaints
	    (param T)
	    (simple
	      ;;It is there, but it was said to take no params
	      (signal-proceed-case (() 'sab-type-invalid :thing name
				    :should-be
				    "the name of a Sage command that takes params")
		(:use-it-anyway T)))
	    ((nil) (signal-proceed-case (() 'sab-type-invalid :thing name
				       :should-be
				       "the name of a Sage command that takes params")
		   (:use-it-anyway T)
		   (:install-it
		    (dont-complain-about-sage-command name 'param)
		    T))))))))

;;Returns NIL, 'simple, or 'param
(defun lookup-sage-command-not-to-complain-about (name)
  (second (assoc name *sage-command-names-not-to-complain-about*)))

(defun dont-complain-about-sage-command (name type)
  (let ((there (assoc name *sage-command-names-not-to-complain-about*)))
    (if there
	(setf (second there) type)
	(push (list name type) *sage-command-names-not-to-complain-about*)))
  name)

#+Franz  ;;This tests the proceed-type stuff.
(defun test-complaints (&optional (takes-param T))
  (let ((*sage-command-names-not-to-complain-about*)
	(*document-type* 'generic)
	(*device-type* 'generic))
    (loop for string = (prompt-and-read :string-or-nil "Command-name: ")
	  while string
	  for sym = (string-upcase-and-intern string "sage")
	  do (format T "~&Validation: ~s"
		     (if takes-param
			 (sab-validate-sage-param-command-name sym)
  			 (sab-validate-sage-simple-command-name sym))))))

;;;some support functions for writing out an index file as a special format binary file.
;;;very simple file format for compact representation and fast loading.  [JW, RLB]

(defun WRITE-8-BIT-NUMBER (stream n)
  (send stream ':tyo (ldb (byte 8 0) n)))	;just low byte

(defun WRITE-16-BIT-NUMBER (stream n)
  (send stream ':tyo (ldb (byte 8 0) n))	;low byte first
  (send stream ':tyo (ldb (byte 8 8) n)))

(defun WRITE-32-BIT-NUMBER (stream n)
  (send stream ':tyo (ldb (byte 8 0) n))	;low byte first
  (send stream ':tyo (ldb (byte 8 8) n))
  (send stream ':tyo (ldb (byte 8 16) n))
  (send stream ':tyo (ldb (byte 8 24) n)))

;;;support functions for loading the binary files of indexes
(defun READ-8-BIT-NUMBER (stream)
  (let ((n (send stream ':tyi)))
    (ldb (byte 8 0) n)))			;just one byte

(defun READ-16-BIT-NUMBER (stream)
  (let ((1st (send stream ':tyi))		;low byte first
	(2nd (send stream ':tyi)))
    (dpb 2nd (byte 8 8)
	 (ldb (byte 8 0) 1st))))

;;;so as to make the order-of-evaluation of the tyi's explicit,
;;;and (the last ldb) to protect against wierdness like negative
;;;numbers (which I've seen...)
(defun READ-32-BIT-NUMBER (stream)
  (let ((1st (send stream ':tyi))		;low byte first
	(2nd (send stream ':tyi))
	(3rd (send stream ':tyi))
	(4th (send stream ':tyi)))
    (dpb 4th (byte 8 24)
	 (dpb 3rd (byte 8 16)
	      (dpb 2nd (byte 8 8)
		   (ldb (byte 8 0) 1st))))))

;;;; 1sab file writing 
0;;;A record is an instance of {LISP,CONCEPT}-RECORD
;;;  Its  <topic> is either a symbol in the DOC: package, or a function spec.
;;;  and  <type> is a symbol (in the NSAGE:: package) from a limited set

;;; The order of things in this list is important, because we do successive TYPEPs
;;; on the keys.
(defparameter 2*type-to-sab-writing-function-alist*
0	      '((fixnum write-sab-fixnum)
		(number write-sab-generic-number)
		(string write-sab-string)
		(symbol write-sab-symbol)
		(cons write-sab-list)
		(sage-directive write-sab-directive)
		(phony-function-spec write-sab-function-spec)
		(character write-sab-character)
		))

(defgeneric 2write-sab-directive0 (sage-directive stream table)
  )

(defun 2write-sab-record0 (record stream)
  (let ((start-pointer (send stream :read-pointer)))
    (with-sab-symbol-table (table :write stream)
     (write-sab-directive record stream table))
    (let ((end-pointer (send stream :read-pointer)))
      (values start-pointer end-pointer))))

(defmethod 2(write-sab-directive doc-record)0 (stream table)
  (write-sab-code stream =sab-code-record=)
  (write-sab-topic-spec name stream table)
  (write-sab-type-spec (record-group-type record-group)
		       stream table)
  (write-sab-record-fields self stream table))

(defun 2write-sab-topic-spec0 (name stream table)
  (if (stringp name)
      (write-sab-string name stream table)
      (write-sab-function-spec name stream table)))

(defun 2write-sab-type-spec0 (name stream table)
  (write-sab-code stream =sab-code-type-symbol=)
  (write-sab-symbol name stream table))

(defun 2write-sab-record-fields0 (record stream table)
  (write-sab-field-alist (doc-record-sab-fields-to-write record) stream table))

(defun 2write-sab-field-alist0 (field-alist stream table)
  (write-sab-code stream =sab-code-field-alist=)
  (write-16-bit-number stream (length field-alist))
  (with-file-attributes-from-sab-field-if t field-alist
    (loop for (field-name field-contents) in field-alist
	  as contents-write-function = (write-sab-field-name field-name stream table)
	  do
      (funcall contents-write-function
	       (if (eql contents-write-function 'write-sab-contents-list)
		   (canonicalize-contents-list field-contents)
		   field-contents)
	       stream table))))

(defgeneric 2doc-record-sab-fields-to-write0 (doc-record) 
  (:method-combination :nconc))

(defmethod 2(doc-record-sab-fields-to-write doc-record)0 ()
  (nconc `((file-attribute-string
	     ,(string-thin (or (doc-record-file-attribute-string self) "")
			   :remove-bits t :error-if :fat)))
	 `((modification-history ,modification-history))
	 (make-non-white-field-alist
	   'oneliner (record-field-contents oneliner)
	   'keywords (record-field-contents keywords)
	   'contents (record-field-contents contents)
	   'related (record-field-contents (doc-record-related self))
	   'releasenumber (doc-record-releasenumber self)
	   'notes (record-field-contents (doc-record-notes self)))))

(defmethod 2(doc-record-sab-fields-to-write lisp-record-type-mixin)0 ()
  (make-non-white-field-alist 'arglist (record-field-contents arglist)))

(defmethod 2(doc-record-sab-fields-to-write concept-record-type-mixin)0 ()
  (make-non-white-field-alist 'abbrev abbrev
			      'source-title (record-field-contents source-title)))

(defun 2write-sab-field-name0 (field-name stream table)
  (let ((contents-write-function (third (sab-validate-field-name field-name))))
    (write-sab-code stream =sab-code-field-name=)
    (write-sab-symbol field-name stream table)
    contents-write-function))

;;; This had better get a canonicalized contents list (no pointy hands, etc.)
(defun 2write-sab-contents-list0 (contents-list stream table)
  (write-sab-code stream =sab-code-contents-list=)
  (write-16-bit-number stream (length contents-list))
  (loop for thing in contents-list
	do (typecase thing
	     (string (write-sab-string thing stream table))
	     (sage-directive (write-sab-directive thing stream table))
	     (otherwise (error "Bad type ~s" thing)))))

(defun 2write-sab-file-attribute-alist0 (stream &rest keypairs)
  (write-sab-code stream =sab-code-file-attribute-alist=)
  (with-sab-symbol-table (table :write stream)
    (write-sab-any-type (apply 'alist-nonnull keypairs) stream table)))

(defun 2write-sab-index-data0 (data stream)
  (with-sab-symbol-table (table :write stream)
    (write-sab-code stream =sab-code-index=)
    (write-32-bit-number stream (length data))
    (tv:dolist-noting-progress (item data "Writing SAB index data")
      (write-sab-index-item item stream table))))

;;Each item is (<record-group> ((<field> <contents>) ...))
(defun 2write-sab-index-item0 (item stream table)
  (write-sab-code stream =sab-code-index-item=)
  (destructuring-bind (record field-alist) item
    (write-sab-topic-spec (doc-record-topic record) stream table)
    (write-sab-type-spec (doc-record-source-type record) stream table)
    (write-16-bit-number stream (count 'file-attribute-string field-alist
				       :key #'first :test-not #'eql))
    (with-file-attributes-from-sab-field-if t field-alist
      (loop with contents-write-function
	    for (field-name field-contents) in field-alist
	    unless (eql field-name 'file-attribute-string)
	      do (setq contents-write-function
		       (write-sab-field-name field-name stream table))
		 (funcall contents-write-function
			  (if (eql contents-write-function 'write-sab-contents-list)
			      (canonicalize-contents-list field-contents)
			      field-contents)
			  stream table)))))

(defun 2write-sab-unique-id0 (unique-id stream table)
  (sab-validate-unique-id unique-id)
  (write-sab-code stream =sab-code-unique-id=)
  (write-sab-string unique-id stream table))

(defun 2write-sab-modification-history0 (history stream table)
  (write-sab-code stream =sab-code-modification-history=)
  (write-sab-any-type history stream table))

(defun 2write-sab-token-list0 (token-list stream table)
  (write-sab-code stream =sab-code-token-list=)
  (write-sab-list token-list stream table))

(defun 2write-sab-location-pair0 (pair stream table)
  (destructuring-bind (from to) pair
    (write-sab-code stream =sab-code-location-pair=)
    (write-sab-fixnum from stream table)
    (write-sab-fixnum to stream table)))

(defun 2write-sab-unique-id-or-index0 (unique-id stream table)
  (etypecase unique-id
    (string (write-sab-unique-id unique-id stream table))
    (integer (write-sab-fixnum unique-id stream table))))

(defun 2write-sab-callee-4ple-list0 (list stream table)
  (write-sab-code stream =sab-code-callee-4ple-list=)
  (write-16-bit-number stream (length list))
  (loop for (topic type called-how unique-id) in list
	do
	(write-sab-topic-spec topic stream table)
	(write-sab-type-spec type stream table)
	;;---should called-how be a view spec?
	(write-sab-any-type called-how stream table)
	(write-sab-unique-id-or-index unique-id stream table)))

(defun 2write-sab-callee-triple-list0 (triple-list stream table)
  (write-sab-code stream =sab-code-callee-triple-list=)
  (write-16-bit-number stream (length triple-list))
  (loop for (topic type called-how) in triple-list
	do
	(write-sab-topic-spec topic stream table)
	(write-sab-type-spec type stream table)
	;;---should called-how be a view spec?
	(write-sab-any-type called-how stream table)))

(defmethod 2(write-sab-directive sage-envr)0 (stream table)
  (write-sab-code stream =sab-code-envr=)
  (write-sab-envr-name envr-name stream table)
  (write-sab-envr-mods envr-mods stream table)
  (write-sab-contents-list contents-list stream table))

(defun 2write-sab-envr-name0 (envr-name stream table)
  (write-sab-code stream =sab-code-envr-name=)
  (write-sab-symbol envr-name stream table))

(defun 2write-sab-envr-mods0 (envr-mods stream table)
  (write-sab-code stream =sab-code-envr-mods=)
  (write-16-bit-number stream (length envr-mods))
  (loop for (attr value) in envr-mods
	do
	(write-sab-attribute-name attr stream table)
	(write-sab-attribute-value value stream table)))

(defun 2write-sab-attribute-name0 (attr stream table)
  (write-sab-code stream =sab-code-attribute-name=)
  (write-sab-symbol attr stream table))

(defun 2write-sab-attribute-value0 (value stream table)
  (write-sab-any-type value stream table))

(defun 2write-sab-any-type0 (value stream table)
  (loop for (type write-function) in *type-to-sab-writing-function-alist*
	when (typep value type)
	  return (funcall write-function value stream table)
	finally (error "Don't know how to write ~S to a SAB file" value)))

(defmethod 2(write-sab-directive sage-command)0 (stream table)
  (write-sab-code stream =sab-code-command=)
  (write-sab-command-name command-name stream table)
  (write-sab-any-type parameter stream table))

(defun 2write-sab-simple-command-name0 (command-name stream table)
  (write-sab-code stream =sab-code-simple-command-name=)
  (write-sab-symbol command-name stream table))

(defun 2write-sab-command-name0 (command-name stream table)
  (write-sab-code stream =sab-code-command-name=)
  (write-sab-symbol command-name stream table))

(defmethod 2(write-sab-directive sage-macro-call)0 (stream table)
  (write-sab-code stream =sab-code-macro-call=)
  (write-sab-macro-name macro-name stream table)
  (write-sab-macro-arglist macro-args stream table))

(defun 2write-sab-macro-name0 (macro-name stream table)
  (write-sab-code stream =sab-code-macro-name=)
  (write-sab-symbol macro-name stream table))

(defun 2write-sab-macro-arglist0 (macro-args stream table)
  (write-sab-code stream =sab-code-macro-arglist=)
  ;;---The exact format of this isn't pinned down yet.
  (write-sab-any-type macro-args stream table))

(defmethod 2(write-sab-directive sage-reference)0 (stream table)
  (write-sab-code stream =sab-code-extensible-reference-take-two=)
  (write-sab-topic-spec (record-group-topic record-group) stream table)
  (write-sab-type-spec (record-group-type record-group) stream table)
  (write-sab-unique-id-or-index (record-group-unique-id-or-index record-group) stream table)
  (write-sab-any-type view stream table)
  (write-sab-any-type appearance stream table)
  (write-sab-any-type booleans stream table)
  (write-sab-any-type field stream table))

(defmethod 2(write-sab-directive sage-picture)0 (stream table)
  (write-sab-code stream =sab-code-picture=)
  ;; write type, file-name, picture-name, and contents (binary-encoding or drawing-function)

  ;; type (probably a keyword)
  (write-sab-symbol type stream table)

  ;; file-name
  (write-sab-pathname-string file-name stream table)

  ;; picture-name
  (write-sab-string name stream table)

  ;; contents
  (if (and drawing-function (symbolp drawing-function))
      (write-sab-symbol drawing-function stream table)	;Dynamic picture
      (write-sab-8-bit-array binary-encoding stream table)))	;Static picture

(defmethod 2(write-sab-directive example-record-marker)0 (stream table)
  (write-sab-code stream =sab-code-example-record-marker=)
  (write-sab-symbol type stream table)
  (if (null encoding)
      (write-sab-symbol encoding stream table)
      (case type
	((:typescript :values)
	  (write-sab-string encoding stream table))
	(otherwise
	  (write-sab-8-bit-array encoding stream table)))))

(defun 2write-sab-pathname-string0 (pathname stream table)
  (typecase pathname
    (pathname (write-sab-string (zwei:fully-qualified-pathname-string pathname) stream table))
    (string (write-sab-string pathname stream table))
    (null (write-sab-symbol nil stream table))))

(defun 2write-sab-8-bit-array0 (array stream table)
  (cond ((null array)
	 (write-sab-symbol nil stream table))
	(t
	 (write-sab-code stream =sab-code-8-bit-array=)
	 (let ((n (array-dimension array 0)))
	   (write-32-bit-number stream n)
	   (send stream :string-out array)))))

(defun 2write-sab-list0 (list stream table)
  (write-sab-code stream =sab-code-list=)
  (write-16-bit-number stream (length list))
  (dolist (thing list)
    (write-sab-any-type thing stream table)))

(defun 2write-sab-fixnum0 (number stream ignore)
  (write-sab-code stream =sab-code-fixnum=)
  (write-32-bit-number stream number))

(defun 2write-sab-generic-number0 (number stream table)
  (using-resource (temp string-temp)
    (with-standard-io-environment
      (format temp "~VR" *print-base* number))
    (write-sab-code stream =sab-code-read-from-string=)
    (write-sab-string temp stream table)))

(defun 2write-sab-string0 (string stream table)
  (cond ((or (not (string-fat-p string))
	     (every #'string-char-p string))
	 (let ((n (string-length string)))
	   (cond ((< n 1_8)
		  (write-sab-code stream =sab-code-string=)
		  (write-8-bit-number stream n)
		  (si:write-simple-string-to-binary-stream
		    stream (string-thin string :remove-bits t :error-if :fat) 0 n))
		 (T (write-sab-code stream =sab-code-long-string=)
		    (write-32-bit-number stream n)
		    (si:write-simple-string-to-binary-stream
		      stream (string-thin string :remove-bits t :error-if :fat) 0 n)))))
	(T
	  (write-sab-code stream =sab-code-fat-string=)
	  (write-sab-fat-string string stream table))))

(defun 2write-sab-character0 (character stream table)
  (write-sab-code stream =sab-code-character=)
  (write-sab-string (string character) stream table))

(defun 2write-sab-file-attribute-string0 (string stream table)
  (write-sab-code stream =sab-code-file-attribute-string=)
  (write-sab-string string stream table))

(defun 2map-over-interval-substrings0 (zwei-interval function)
  (declare (sys:downward-funarg function))
  (let ((number-of-chars (zwei:count-chars zwei-interval)))
    (sys:with-stack-array (string number-of-chars :element-type 'character)
      (let ((i 0))
	(zwei:do-lines-in-interval (zwei-interval line first-index last-index)
	  (replace string line :start1 i :start2 first-index :end2 last-index)
	  (incf i (- last-index first-index))
	  (when (< i number-of-chars)
	    (setf (aref string i) #\return)
	    (incf i))))
      (multiple-value-bind (hand-at-left hand-at-right)
	  (pointy-hands-in-sage-symbol-face)
	(let ((start 0))
	  (flet ((doit (from to type)
		   (when (> to from)
		     (sys:with-stack-array (substring (- to from)
						      :element-type
						      (if (loop for j from from below to
								always (string-char-p
									 (aref string j)))
							  'string-char
							  'character))
		       (replace substring string :start2 from :end2 to)
		       (funcall function substring type)))))
	    (loop
	      (let ((hand-start (string-search-exact-char hand-at-left string :start start)))
		(cond (hand-start
		       (doit start hand-start :normal)
		       (incf hand-start)
		       (let ((hand-end (string-search-exact-char hand-at-right string
							   :start hand-start)))
			 (cond ((null hand-end)
				;; ---This should be more like zmacs unbalanced-parens warning
				(cerror "Leave the opening Lisp face delim as literal text"
					"Failed to find closing Lisp face delimiter")
				(doit start hand-start :normal)
				(setq start hand-start))
			       (T (doit hand-start hand-end :lisp)
				  (setq start (1+ hand-end))))))
		      (T (doit start number-of-chars :normal)
			 (return)))))))
	nil))))

(defun 2with-sab-character-dumper-10 (stream continuation)
  (ignore stream)
  (sys:with-stack-array (character-style-vector 20 :fill-pointer 0)
    (funcall continuation character-style-vector)))

(defun 2write-sab-fat-string-10 (string stream table)
  (when *sab-file-io-trace*
    (format T "~&---writing fat string ~s" string))
  (let ((character-style-vector (sab-table-string-table table)))
    (sys:with-stack-array (styles 256 :element-type 'boolean)
      (do-vector (char string)
	(unless (zerop (char-bits char))
	  (error "Cannot dump chars with nonzero char-bits"))
	(unless (zerop (si:char-char-set-index char))
	  (error "Cannot dump chars not in standard character set"))
	(setf (aref styles (si:char-style-index char)) T))
      (let ((new-ones
	      (loop for i below 256
		    for style = (and (aref styles i) (si:index-character-style i))
		    when (and style (not (find style character-style-vector)))
		      collect style)))
	(write-byte (length new-ones) stream)
	(dolist (new new-ones)
	  (write-sab-symbol (si:cs-family new) stream table)
	  (write-sab-symbol (si:cs-face new) stream table)
	  (write-sab-symbol (si:cs-size new) stream table)
	  (vector-push-extend new character-style-vector)))
      (flet ((map-over-adjacent-fields (function)
	       (let ((start 0)
		     (i 1)
		     (last-style (si:char-style (aref string 0)))
		     (length (length string)))
		 (loop 
		   (when ( i length)
		     (funcall function start length
			      (position last-style character-style-vector))
		     (return))
		   (let ((this-style (si:char-style (aref string i))))
		     (cond ((eq this-style last-style)
			    (incf i))
			   (T
			    (funcall function start i
				     (position last-style character-style-vector))
			    (setq last-style this-style
				  start i
				  i (1+ i))))))
		 nil)))
	(write-16-bit-number stream (length string))
	(map-over-adjacent-fields
	  (named-lambda mapped (start end index)
	    (when *sab-file-io-trace*
	      (format T "~&---substring ~d:~d (~d) ~s"
		      start end (aref character-style-vector index)
		      (substring string start end)))
	    (write-byte index stream)
	    (sys:with-stack-array (thin-string (- end start) :element-type 'string-char)
	      (loop for i from start below end
		    for j from 0
		    do (setf (aref thin-string j) (code-char (char-code (aref string i)))))
	      (write-sab-string thin-string stream table))))))))

#+Franz
(defun test-map-over (interval)
  (map-over-interval-substrings
    interval
    (named-lambda map-over-interval-substrings (substring type)
      (format T "~&~s ~s ~s" type
	      (let ((styles ()))
		(map nil (lambda (ch) (pushnew (si:char-style ch) styles)) substring)
		styles)
	      substring))))

(defmethod 2(write-sab-directive sage-text-structure)0 (stream table)
  (write-sab-string (zwei:string-interval interval) stream table)
  #+Franz
  (map-over-interval-substrings
    interval
    (named-lambda map-over-interval-substrings (substring type)
      (ecase type
	(:normal
	  (write-sab-string substring stream table))
	(:lisp
	  ;; Dump an @L command
	  (when *sab-file-io-trace*
	    (break "---About to write @L(~a) at ~d"
		   (string-thin substring :remove-bits t :error-if :fat)
		   (send stream :read-pointer)))
	  (write-sab-code stream =sab-code-command=)
	  (write-sab-command-name 'L stream table)
	  (write-sab-any-type
	    (list (parse-L-string substring))
	    stream table))))))

(defun 2write-sab-symbol0 (symbol stream table)
  (check-type symbol symbol nil)
  ;; --- Kludge alert:  This is here to make old method specs work.
  ;; Remove when new record type system is installed.
  (when (eq (symbol-package symbol) zwei:*utility-package*)
    (error "Attempt to write symbol ~S in the Zwei Utility Package." symbol))
  ;;---184--- can be removed as soon as system loaded without ever having known doc package.
  (when (let ((pkg (symbol-package symbol)))
	  (and pkg (string-equal (package-name pkg) "DOC")))
    (error "Attempt to write symbol ~S from the old DOC package." symbol))
  (let ((symbol-table (sab-table-symbol-table table)))
    (let ((n (gethash symbol symbol-table)))
      (cond (n
	     (write-sab-code stream =sab-code-symbol-ref=)
	     (write-16-bit-number stream n))
	    (T (setq n (hash-table-count symbol-table))
	       (setf (gethash symbol symbol-table) n)
	       (select (symbol-package symbol)
		 (*sage-package*
		  (write-sab-code stream =sab-code-sage-pkg-symbol-def=))
		 (sys:pkg-keyword-package
		  (write-sab-code stream =sab-code-keyword-pkg-symbol-def=))
		 (NIL
		  (write-sab-code stream =sab-code-uninterned-symbol-def=))
		 (otherwise
		  (write-sab-code stream =sab-code-pkg-symbol-def=)
		  (write-sab-string (zl:pkg-name (symbol-package symbol)) stream table)))
	       (write-sab-string (string symbol) stream table))))))

(defun 2write-sab-function-spec0 (name stream table)
  (write-sab-code stream =sab-code-function-spec=)
  (cond ;; --- Kludge alert:  This is here to make old method specs work.
	;; Remove when new record type system is installed.
	((and (symbolp name)
	      (eq (symbol-package name) zwei:*utility-package*))
	 (with-standard-io-environment
	   (write-sab-string (slashify-string (symbol-name name)) stream table)))
	(t
	 (using-resource (temp string-temp)
	   (with-standard-io-environment
	     (format temp "~s" name))
	   (write-sab-string temp stream table)))))

(defsubst 2valid-sab-code0 (code)
  (and (typep code 'fixnum)
       ( code 0)
       (< code *number-of-sab-codes*)))

(defun 2write-sab-code0 (stream code)
  ;; (check-type code (satisfies valid-sab-code) "a SAB code")
  (loop until (valid-sab-code code)
	do (setq code (dbg:check-type-1 'code code '(satisfies valid-sab-code) "a SAB code")))
  (when *sab-file-io-trace*
    (format T "~&---sab code ~d ~s" code (sab-code-name code)))
  (send stream :tyo code))

;;; These functions are called as part of the one-time sarsab upgrade to new Writer Tools.
;;; Assumes you've done a one-time UID assignment and have no bogoids
;(defun 2save-record-set0 (pathname)
;  (let ((valids 0)
;	(undefs 0))
;    (map-over-topic&type-registry
;      (named-lambda map-over (topic type record-group)
;	(ignore topic type record-group)
;	(ecase (unique-id-validity (record-group-unique-id record-group))
;	  (:valid (incf valids))
;	  (:undefined-reference (incf undefs))
;	  (:bogus (cerror "Continue saving record set without this record group"
;			  "Bogus unique id ~S for record-group ~S"
;			  (record-group-unique-id record-group) record-group)))
;	#||
;	(if (record-group-installed-record record-group)
;	    (incf valids)
;	    (incf undefs))
;	||#
;	)
;      "counting rgs")
;    (print `(valids ,valids undefs ,undefs))
;    (with-open-file (stream pathname :direction :output :characters nil :byte-size 8)
;      (with-sab-symbol-table (symbol-table :write stream)
;	(flet ((yow (number validity)
;		 (write-sab-fixnum number stream nil)
;		 (map-over-topic&type-registry
;		   (named-lambda map-over (topic type record-group)
;		     (flet ((yow1 (topic type)
;			      (ignore type)
;			      (write-sab-topic-spec topic stream symbol-table)
;			      (write-sab-type-spec
;				(let ((record (record-group-installed-record record-group)))
;				  (if record
;				      (doc-record-source-type record)
;				      (record-group-type record-group)))
;				stream symbol-table)
;			      (write-sab-unique-id (record-group-unique-id record-group)
;						   stream symbol-table)))
;		       (ecase (unique-id-validity (record-group-unique-id record-group))
;			 (:valid
;			   (ecase validity
;			     (:valids (yow1 topic type))
;			     (:undefs)))
;			 (:undefined-reference
;			   (ecase validity
;			     (:undefs (yow1 topic type))
;			     (:valids)))
;			 (:bogus ()))))
;		   (string validity))))
;	  (yow undefs :undefs)
;	  (yow valids :valids))))))

(defun 2restore-record-set0 (pathname &optional from-old-doc)
  (with-open-file (stream pathname :direction :in :element-type '(unsigned-byte 8))
    (with-sab-symbol-table (table :read stream)
      (flet ((read-them (which)
	       (let ((n (read-sab-thing stream table =sab-code-fixnum=)))
		 (tv:dotimes-noting-progress (i n which)
		   (let ((topic (read-sab-thing stream table ()))
			 (type (read-sab-thing stream table =sab-code-type-symbol=))
			 (uid (read-sab-thing
				stream table
				(if from-old-doc () =sab-code-unique-id=))))
		     (or (find-record-group-for-topic-and-type topic type uid T)
			 (break "Failed to find ~s" (list topic type uid)))))
		 n)))
	(list :undefs (read-them "reading undefs")
	      :valids (read-them "reading valids"))))))
