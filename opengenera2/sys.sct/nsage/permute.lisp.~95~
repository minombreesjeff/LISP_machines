;;; -*- Syntax: Common-lisp; Mode: LISP; Package: NSAGE; Base: 10 -*-

;;;
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;

#|
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")Things to do to this:

(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")To make it work:
0- Integrate with Sage formatter's native index info

2To make it work better:
0- Test suite: tokenizing. Permuting. Inhibiting. Sorting.
  Capture a bunch of topics, either carefully selected, or even just
  a snapshot of the doc system's topics at one instant in time.  Record
  the topics, and the result of running the permuter.  Have a way
  to compare a new permuter run with the old, listing differences
  intelligently.
- Pack start/end indexes into fields of fixnum intead of list.  Saves conses.
- Get rid of more special variables
- Majorheading stuff  macro (textform)
- meter it some - is performance a problem on big runs?  I think it has been
- Meter inhibited chunks - is it computing envrs and cmds only to throw them away?
  If so, better to inhibit before reconstituting the chunks.
  |#

#||
How to permute an index entry...

Let's consider an example.
	  "@L(:named-array) option for @L(defstruct :type)"
Parsed version:
(#<@L(":named-array") 16124454> " option for " #<@L("defstruct :type") 16124461>)

When we tokenize this stuff, what do we need from it?  The points at
which to break each line.  In this case:
    :named
    option
    defstruct
    :type
(The "for" would be left out eventually.)  The basis for tokenizing is
simple -- space.  There are some special cases due to the environments
and commands: within @L, tokenize on embedded colon as well as space
(but not on leading one).

So what we want to deal with here is the parsed version of the input
line.  But this representation is not string-based to start with
although we can create a special string form for each line, without
consing away the machine.

We use a plain sorting function and put all the knowledge about "hairy"
characters into the routines that create the specialized sorting strings
(starting from the strings and environments).  It looks for patterns to
decide when to ignore a character in the sort.  *foo*, :bar, %bar.  Any
funny characters inside @K environments are used literally, not
suppressed.

We take the parsed version of an index line and turn it into a list of
chunks.  That way we can do the line breaking into halves by just
marching down the list, using each chunk as a potential right half.
When the word at the right half matches one of the words "proscribed"
for that position in the index, then that potential line is quietly
dropped.  The chunks could contain several words if there are words that
don't want to participate in the sorting.  (This could get tricky in the
heuristicating.)

One thing to be quite careful about: make sure that all the correct
spaces get kept for putting the line back together in the final output
form.  This scheme conses somewhat but doesn't have to cons a lot of
lists or strings.

||#

(defvar *SCRIBE-DEVICE* "LGP2")

(defvar *STANDALONE-DOCUMENT* ())
(defvar *CURRENT-MNEMONIC* ())
(defvar *HEADING-MNEMONIC* ())			;for the pageheadings in the final index doc
(defvar *DOCUMENT-TITLE* ())			;for the pageheadings in the final doc
(defvar *DOCUMENT-LAST-PAGE* ())

;;;This is the list of characters that are dropped in the leading position.
;;;More thinking is required to decide if they are also dropped in trailing positions.
;;;(Probably * and : should be dropped in trailing positions)
(defparameter *CHARACTERS-DROPPED-FROM-LISP-OBJECTS* '(#\* #\% #\& #\:))

;;;This list has the standard punctuation characters that might affect sorting
;;;spuriously.  If any of these is being used with a special character meaning,
;;;it belongs in @K environment anyhow (and would thus be protected from dropping).
(defparameter *CHARACTERS-DROPPED-FROM-TEXT* '(#\- #\sp #\( #\) #\[ #\] #\, #\; #\: #\'))

;;;These are exceptions which are real function names (:* is a fragment that shows up
;;;in a keywords field instead).  So far I'm leaving out anything that would be in @K
;;;(like the % that results from tokenizing m-% on the theory that @K environments
;;;don't have anything dropped from them, by definition).
(defparameter *CHARACTERS-DROPPED-EXCEPTIONS* '("*$" "*" "**" "***" ":*" "-" "-$"))

(zl:defstruct (ENTRY :conc-name :list)		;collecting raw material for an index entry
  chunk-list					;contents-list of chunks
  page-string)					;"1-35,3-69"

(zl:defstruct (INDEX-LINE :conc-name :list)
  key						;literal text from index source (hash key)
  contents-lists				;(left-list right-list) for two halves of line
  strings)					;(left-string right-string) for two halves

#+Ignore
(cp:define-command (1com-permute-index
0		     :command-table "GLOBAL")	;---Should be in a writer's comtab
    ((in-file '((sequence pathname))
	      :prompt "IX source files"
	      :provide-default nil)		;---Should have its own history
     (out-file '((TOKEN-OR-TYPE (screen) pathname))
	       :default 'screen			;---Should base default on diry of in-file
	       :prompt "MSS for permuted index")
     &key
     (inhibit '((sequence string))
	      :default nil
	      :provide-default nil		;---Should have own history
	      :prompt "Additional words to inhibit")
     (case-inhibit '((sequence string))
		   :default nil
		   :provide-default nil		;---Should have own history
		   :prompt "Additional case-sensitive words to inhibit"))
   (permuted-sort in-file
		  (unless (eq out-file 'screen) out-file)
		  :inhibit (if inhibit
			       (append inhibit *standard-inhibit-list*)
			       *standard-inhibit-list*)
		  :case-inhibit (if case-inhibit
				    (append case-inhibit *case-sensitive-inhibit-list*)
				    *case-sensitive-inhibit-list*)))

;;;in-file can be a string or a list of strings or pathnames.  Any string can be
;;;an "indirect" spec containing the name of a file that has the names of the files
;;;and so on. e.g. (permuted-sort '("q:>dess>doc>rn>foo.ix" "@q:>dess>doc>newdocs>list.text"))
;;;inhibit is a list of the strings that you don't want to appear as primary sort keys.
;;;e.g. (permuted-sort "@vixen://dess//doc//all.text" ':inhibit sage:*standard-inhibit-list*)
(defun PERMUTED-SORT (in-file &optional out-file &key (inhibit *standard-inhibit-list*)
		      (case-inhibit *case-sensitive-inhibit-list*))
  (let ((*last-sort-start* #\sp)		;beginning of the ASCII printing char order
	(*inhibit-sort-on-these* inhibit)
	(*case-inhibit-sort-on-these* case-inhibit)
	(*standalone-document* nil)
	(*document-last-page* 0)
	(*document-title* "")
	(*heading-mnemonic* "")
	(*current-mnemonic* ""))
    (cond (out-file				;if supplied, it is pathname
	   (with-open-file (out out-file ':direction ':out)
	     (permuted-sort-internal in-file out)
	     (send out ':pathname)))
	  (t					;out-file not supplied, assume terminal-io
	   (permuted-sort-internal in-file *standard-output*)))))

(defmacro set-to-timing ((timing-var) &body body)
  `(let ((.start. (time:microsecond-time)))
     (multiple-value-prog1
       (progn ,@body)
       (setq ,timing-var (time-difference (time:microsecond-time) .start.)))))

;;;Finds the list of files to operate on; collects ALL the lines from these; permutes
;;;and sorts.
(defun PERMUTED-SORT-INTERNAL (specs out-stream)
  (let* (sorted-lines
	 time-doing-everything
	 time-writing-lines time-doing-sort time-prepare-to-sort time-collect-lines
	 (files (reverse (permuted-sort-file-collect specs)))
	 (entry-hash-table (make-hash-table :test #'equal ':size 2000)))
    #+Ignore
    (unless (y-or-n-p "~%The index source files being processed:~{~%~A~}~%~@
			That's all, right? "
		      files)
      (let ((extra-files
	      (reverse (permuted-sort-file-collect
			 (loop for spec = (prompt-and-read ':string
							   "Index source file (or RETURN): ")
			       until (string-equal spec "")
			       collect spec)))))
	(setq files (append files extra-files)))) ;just hope that user checked order carefully
    (when (= (length files) 1) (setq *standalone-document* t))
    (set-to-timing (time-doing-everything)
      (set-to-timing (time-collect-lines)
	(dolist (file files)
	  (permuted-sort-line-collect file entry-hash-table)))
      (let ((lines-to-sort ()))
	(set-to-timing (time-prepare-to-sort)
	  (tv:maphash-noting-progress
	    (lambda (key value)
	      (setq lines-to-sort (process-collected-entries key value lines-to-sort)))
	    entry-hash-table
	    "preparing items for sort"))
	(set-to-timing (time-doing-sort)
	  (tv:noting-progress ("sorting lines")
	    (setq sorted-lines (sort lines-to-sort #'kwic-lessp))))
	;;one known bug in approach to sorting--doesn't ignore trailing punctuation within
	;;a line half.  This isn't necessarily wrong, just maybe unexpected.
	(unless *standalone-document* (setq *heading-mnemonic* "INDEX"	;action over, set it
					    *document-title* "System Index"))
	;;Put out the index prolog with all the boilerplate and formatting modifications
	(format out-stream			;well, it's a start
		"~&@make[symanual]~%~@[@device(~A)~%~]@Set[Page ~D]~%@Unnumbered[Index]~
            ~%@String[Abbrev=<~A>]~%@String[DocTitle=<~A>]~%@String[MajorPartTitle=<Index>]~
            ~%@String[DraftForm=<no>]~%@include[/dess/doc/bp/dmanhdg.mss]~
	    ~%@Modify[L,Hyphenbreak On]~
	    ~%@begin(format,Use NoteStyle,longlines wrap,indent 20picas,spacing .8lines)~
            ~%@Tabclear()~%@Tabset(18picas)"
		*scribe-device*
		*document-last-page* *heading-mnemonic* *document-title*)
	(set-to-timing (time-writing-lines)
	  ;;Put out the text of the index
	  (tv:dolist-noting-progress (line sorted-lines "writing sorted lines")
	    (permuted-line-display out-stream line entry-hash-table)))
	;;Index file epilog
	(format out-stream "~%@end(format)")))
    (flet ((report (usecs text)
	     (let ((seconds (round usecs 1e6)))
	       (format T "~&  Time ~a: " text)
	       (time:print-interval-or-never seconds))))
      (report time-collect-lines "collecting lines")
      (report time-prepare-to-sort "preparing to sort")
      (report time-doing-sort "doing sort")
      (report time-writing-lines "writing lines")
      (let ((item-count (length sorted-lines)))
	(report time-doing-everything "everything")
	(format T " (~d lines)" item-count)))))

;;;returns a list of the input pathnames specified
;;;This wants to guarantee that the order of the pathnames in the final list will be
;;;exactly the reverse of either the lines in the file or the original list.  So the
;;;caller can reverse the result to get EXACTLY what the user specified.  This is so
;;;the writers can control the order of docs in the merged index.
(defun PERMUTED-SORT-FILE-COLLECT (in-file)
  (let (pathnames)
    (typecase in-file
      (string					;could be pathname or indirect file 
       (let ((pos (indirect-file-p in-file)))	;start with @?
	 (if pos				;indirect file, collect recursively
	     (with-open-file (file-list (substring in-file (1+ pos)))	;oops, strip @
	       (loop for spec = (send file-list ':line-in)	;---what to do about EOF?
		     until (string-equal spec "")	;---not right
		     do
		     (if (indirect-file-p spec)
			 (setq pathnames
			       (append (permuted-sort-file-collect spec) pathnames))
			 (push (fs:parse-pathname spec) pathnames))))
	     (push (fs:parse-pathname in-file) pathnames))))	;just a plain filespec string
      (cons
       (loop for spec in in-file
	     do
	     (setq pathnames (append (permuted-sort-file-collect spec) pathnames))))
      (fs:pathname (push in-file pathnames))
      (otherwise
	(format *error-output* "~S is not a list or a string.  Skipping this spec" in-file)))
    pathnames))

(defun INDIRECT-FILE-P (string)
  (let ((pos (string-search-not-set *white-space* string)))
    (when (and pos (char-equal #\@ (aref string pos)))
      pos)))

;;;Creates the entries for the lines in a file.
;;;Assumes that if a document mnemomic is there, it occurs before the first actual
;;;index entry in the file.  Sure hope this is true.  Also, you can't mix files with
;;;mnemonics and files without them.
(defun PERMUTED-SORT-LINE-COLLECT (path entry-hash-table)
  (let (eof
	(line (make-array 1000 :element-type 'string-char :fill-pointer 0)))
    (setq *current-mnemonic* "")		;so you can detect disaster not support it
    (with-open-file-case (in-stream path)
      (fs:file-not-found
	(format *error-output* "~%Skipping this file:  ")
	(send in-stream ':report *error-output*))
      (:no-error
       (loop
	 while (null eof)
	 do
	 (multiple-value-setq (line eof)
	   (get-me-a-whole-line-dammit in-stream line))
	 (unless (or (just-white-space line)	;ignore empty lines
		     (when (environment-equal "COMMENT" line ':begin)	;and comment lines
		       (let* ((end (1+ (string-search-not-set *close-delims* line :from-end t)))
			      (st (1+ (string-search-set *white-space* line :end end :from-end t))))
			 (cond ((and *standalone-document*	;pagenumber for standalone
				     (string-search "Final doc page" line))
				(setq *document-last-page*
				      (1+ (read-from-string line nil nil :start st :end end))))
			       ((and *standalone-document*	;title for pageheadings
				     (string-search "DocTitle is " line))
				(setq *document-title*
				      (substring line
						 (+ (string-search "DocTitle is " line)
						    (string-length "DocTitle is ")) end)))
			       ((string-search "Doc mnemonic is" line)	;mnemonic
				(setq *heading-mnemonic* (substring line st end)) ;heads
				(when (not *standalone-document*)	;for page numbers
				  (setq *current-mnemonic* *heading-mnemonic*)))))
		       t))			;make it still knows it was a comment line
	   (multiple-value-bind (item page)
	       (split-apart-raw-entry line)	;conses the string
	     (send entry-hash-table ':modify-hash item #'process-new-entry page))))))))

;;;This is going to have to take responsibility for growing the line buffer when the
;;;physical line is bigger than it has any right to be.  This results in forwarding
;;;the array and other such hair.
(defun GET-ME-A-WHOLE-LINE-DAMMIT (in-stream line-buffer)
  (let ((size (array-total-size line-buffer))
	eof eol)
    (loop with start = 0
	  do
	  (multiple-value-setq (nil eof eol)	;process a line at a time, no consing
	    (send in-stream ':string-line-in nil line-buffer start))
	  until (or (null eol) eof)		;(null eol) => whole line fit
	  do
	  (setq start (length line-buffer))
	  (setq size (+ size (max 100 (floor size 2))))
	  (setq line-buffer (adjust-array line-buffer size)))
    (values line-buffer eof)))

;;;Takes a raw index entry of the form "@L[Foo]   29,35" and returns two strings
;;; the two parts, "@L[Foo]" and "29,35" (or "" if no page number).
;;;Using a lot of string search here to avoid consing which would otherwise be required as
;;; part of using string-trim.  All the confusing 1+ stuff is a result of the searching
;;; and the fact that you can't just add one to NIL.
;;;Someday a real programmer should change it to do what I meant instead.
(defun SPLIT-APART-RAW-ENTRY (line)
  (let* ((num-end (string-search-set "0123456789" line :from-end t))	;Can page be missing?
	 (entry-end (if num-end (string-search "   " line :end2 num-end :from-end t)
			(string-length line)))
	 (num-start (if entry-end (+ 3 entry-end)	;magic number is length of "   "
			(string-length line)))
	 (entry-start (string-search-not-set *white-space* line)))
    ;;Make sure the text of the line doesn't have any trailing spaces
    (setq entry-end (1+ (string-search-not-set *white-space* line :end entry-end :from-end t)))
    (values (substring line entry-start entry-end)
	    (if num-end (substring line num-start (1+ num-end)) ""))))


;;; Takes the data for an index entry and stores it away.  Used in :modify-hash context.
;;; The key is the literal text line from the source file
;;; Entry is a data structure with the parsed form (contents-list) of the index entry
;;; and the page number info as a string to be printed.
;;; This routine either creates a new entry or merges the new page number info for
;;; an existing entry.
(defun PROCESS-NEW-ENTRY (key current-entry exists-p pages)
  (cond
    (exists-p					;an entry for this key already exists
     (let ((old-pages (entry-page-string current-entry)))	;add new page string to it
       (if (string-equal *current-mnemonic* "")	;warn about error case
	   (format *error-output*
		   "~%Multiple entry found for ~A.  The document needs a mnemonic.~@
                    Only the initial entry will appear in the index; this entry will not."
		   key)
	   (setf (entry-page-string current-entry)	;update existing page-string
		 (string-nconc old-pages
			       ", " (add-volume-number *current-mnemonic* pages))))))
    (t						;Doesn't exist; create new entry for hash key
     (let ((page-array (make-array 100 :element-type 'string-char :fill-pointer 0)))	;to save cons
       (unless *standalone-document*
	 (string-nconc page-array (add-volume-number *current-mnemonic* pages)))
       (setq current-entry
	     (make-entry chunk-list (chunked-contents-list key)
			 page-string (if *standalone-document* pages page-array))))))
  current-entry)

;;;This function adds the volume number at the appropriate places, before page numbers in
;;;string pages. e.g. "45, 67" in volume X becomes "X-45, X-67"
;;;multiple pages are e.g. "33, 56, 24"; single page is e.g. "67"
;;;---Potential problem: it assumes that the volume mnemonics are unorderable.  This means
;;;that it just puts them in the order encountered instead of sorting them somehow.
;;;Thus it is depending on people supplying the IX files in the order in which they go
;;;in the index list (for example, ascending numerical order)
;;;---Bug: A page specification like this won't work: "6, 37-39".  The page "span"
;;;information gets thrown away due to details of the number parsing.  At the moment,
;;;it appears that Scribe doesn't generate these collected page spans so we're not
;;;in trouble yet.
(defun ADD-VOLUME-NUMBER (vol-mnemonic pages-string)
  (let ((page-elements				;convert page number string to a list of nums
	  (loop with start = 0
		with result
		while start
		do
		(multiple-value-bind (number next)
		    (parse-integer :start start :junk-allowed t)	;using the usual system facilities
		  (cond (number
			 (push number result)
			 (setq start (string-search-set "0123456789" pages-string :start next)))
			(t (setq start nil))))
		finally (return (nreverse result)))))	;keeps consing down
    (using-resource (result string-temp)
      (loop for page in page-elements
	    for first = t then nil
	    do
	    (string-nconc result
			  (if first "" ", ")
			  vol-mnemonic
			  "-"
			  (format nil "~D" page))
	    finally (return (copy-string result))))))

;;;Accepts a string containing directives or a contents-list
;;;Returns a contents list transformed into sortable chunks that are usually tokens
;;; but could be phrases.
(defun CHUNKED-CONTENTS-LIST (string &optional context)
  (let ((contents-list (if (stringp string)
			   ;; The following is needed to get stuff in @L right.  It
			   ;; assumes that the mss file was converted from Sage with
			   ;; no alteration of the standard Sage print environment
			   ;; (package SCL, etc.).  We could avoid this assumption
			   ;; by putting attribute lists into mss files and passing
			   ;; them along to the ix files; this requires Scribe hacking -- rom
			   (with-standard-sage-io-environment
			     (let ((*document-type* 'generic)
				   (*device-type* 'generic))
			       (with-input-from-string (s string)
				 (sage-parse s))))
			   string)))		;on recursive call, this arg is contents-list
    (loop for ele in contents-list
	  nconc
	    (typecase ele
	      (string (find-chunks ele context))
	      (sage-text-structure
		(if (zwei:interval-fat-p
		      ;;when there are any fat chars in interval
		      (sage-text-structure-interval ele))
		    (let ((contents-list
			    (dynamic-flet ((make-sage-text-structure-from-string
					       (string superior)
					       (ignore superior)
					       string))
			      (destyle-text-list (list ele)))))
		      (chunked-contents-list contents-list context))
		    (find-chunks (zwei:string-interval (sage-text-structure-interval ele))
				 context)))
	      (sage-envr (chunked-contents-list (send ele :contents-list) ele))
	      (sage-command
		(case (send ele :command-name)
		  ((L)
		   (find-chunks (display-string-from-L-command ele) ele))
		  ((literal-atsign)
		   (find-chunks "@" ele))))
	      (otherwise
		(error "Internal error.  Element ~S is not valid in a contents list." ele)))
	    )))

(defun replace-L-with-LS (contents-list)
  (if (catch 'check
	(labels ((check (contents-list)
		   (dolist (item contents-list)
		     (etypecase item
		       (sage-envr (check (send item :contents-list)))
		       (sage-command
			 (when (eq (send item :command-name) 'L)
			   (throw 'check T)))
		       ((or string sage-text-structure sage-reference) )))))
	  (check contents-list)))
      (labels ((redo-item (item)
		 (etypecase item
		   (sage-envr
		     (make-sage-envr (send item :envr-name)
				     (send item :envr-mods)
				     (redo-contents-list (send item :contents-list))))
		   (sage-command
		     (if (eq (send item :command-name) 'L)
			 (redo-L-command item)
			 item))
		   ((or string sage-text-structure sage-reference) item)))
	       (redo-contents-list (contents-list)
		 (mapcar #'redo-item contents-list))
	       (redo-L-command (command)
		 (make-sage-envr 'LS ()
				 (list (apply #'string-append
					      (mapcar #'display-string-for-lisp-expression
						      (first (send command :parameter))))))))
	(redo-contents-list contents-list))
      contents-list))

;;;Take a string; return it as a list of chunks for later use in line assembly.
;;;We have to preserve all of the input, spaces and all, in pieces that can be put back
;;;together, in order, to reconstitute the appearance of the input line.
;;;A chunk is a "content word" that wants to appear at the right hand side of a kwic
;;;index entry.  
;;;Context is "an environment" (like @K, @I) or "a command" (most importantly @L).
;;;This means that the string is in the contents list of an enviroment of the parameter
;;;a command.  So, we want to return the chunks as environments or commands instead of
;;;strings and we want to use different delimiters for dividing into chunks, depending
;;;on what environment or command it is (i.e. for @L, handle package prefixes).
(defun FIND-CHUNKS (string context)
  (loop with this-chunk-start = (or		;ignore leading spaces
				  (string-search-not-char #\SPACE string :start 0)
				  0)		;handle strings of just spaces
	with max = (string-length string)
	with list-of-chunk-starts		;for the string index of the start of chunks
	with context-name = (when context (typecase context
					    (sage-envr (send context :envr-name))
					    (sage-command
					     (send context :command-name))))
	for next-delim-or-end =
	(if (eq 'L context-name)	;Treat @L differently (package names)
	      ;;For @L, :foo is one chunk, sys:foo is two chunks
	      ;;---If there is a leading colon, we'll assume there can't be an embedded : also
	    (let ((st (string-search-not-char #\sp string :start this-chunk-start)))
	      (when st
		(if (or (char-equal #\: (aref string st))	;detect a leading colon
			(and (< (1+ st) max)	;and uninterned symbols
			     (string-equal string "#:" :start1 st :start2 0 :end1 (+ st 2) :end1 2)))
		    (string-search-char #\sp string :start (1+ st))	;no embedded : allowed
		    (let ((colon-pos (string-search-char #\: string :start (1+ st))))
		      (if colon-pos
			  ;; If a colon, check next char to see if it's a colon too
			  ;; (internal symbol) -- rom
			  (let ((next-pos (1+ colon-pos)))
			    (if (and (< next-pos max)
				     (char-equal #\: (aref string next-pos)))
				next-pos
				colon-pos))
			  ;; If no colon, look for a space
			  (string-search-char #\sp string :start this-chunk-start))))))
	    (string-search-char #\sp string :start this-chunk-start))
	do
;	(format t "~&From ~D to ~D in ~S is ~S; List: ~S"
;		this-chunk-start next-delim-or-end string
;		(substring string this-chunk-start next-delim-or-end)
;		list-of-chunk-starts)
	;;---This could be the place for recognizing phrases 
	;; and only using part of the phrase as the kwic key
	(if list-of-chunk-starts
	    (push this-chunk-start list-of-chunk-starts)
	    (push 0 list-of-chunk-starts))
	(when next-delim-or-end
	  (setq this-chunk-start (1+ next-delim-or-end)))
	while (and next-delim-or-end (< this-chunk-start max))	;In case 1-char chunk at end
	finally
	(return (reconstitute-chunks (nreverse list-of-chunk-starts)
				     context string))))

(defun 1reconstitute-chunks0 (list-of-chunk-starts context string)
  (loop for remainder on list-of-chunk-starts
	for end = (second remainder)
	while remainder
	collect
	  (if context
	      (etypecase context
		(sage-envr (make-sage-envr
			     (send context :envr-name)
			     (send context :envr-mods)
			     (list (substring string (first remainder) end))))
		(sage-command
		  (let ((context-name (send context :command-name)))
		    (if (sage-simple-command-p context-name)
			context
			(let ((string-for-param
				(substring string (first remainder) end)))
			(if (eq context-name 'L)
			    (make-sage-envr 'LS nil (list string-for-param))
			    (make-sage-command
			      context-name
			      (list string-for-param))))))))
	      (substring string (first remainder) end))))

;;; This routine takes the hash entry for each key, which is now a list of chunks,
;;; and just creates one "line" for each of the arrangements that want to appear
;;; in the index.  
;;; For example (a b c) usually becomes three lines: (() (a b c)) ((a) (b c)) ((a b) (c))
;;; It creates an index-line data structures for each of the needed "permutations"
;;; side-effecting on the special variable that is collecting those items.
;;;   Hash key
;;;   A two-element list for the left and right halves, as contents-lists
;;;   A two-element list for the left and right halves, as sortable strings
;;; If one of the elements is a chunk that should not appear as the first element
;;; of the right hand side, that entry gets inhibited here.  The line representing
;;; that combination does not get formed.
(defun 1process-collected-entries0 (key value list-so-far)
  (flet ((make-sortable-string (contents-list)
	   (using-resource (into-string string-temp)
	     (sortable-string-from-contents-list contents-list into-string)
	     (string-trim *white-space* into-string))))
    (do-combinations ((left right) (entry-chunk-list value))
      (unless (matches-inhibit-entry (first right))
	(push (make-index-line
		key key
		contents-lists (list left right)
		strings (list (and left (make-sortable-string left))
			      (make-sortable-string right)))
	      list-so-far))))
  list-so-far)


;;; Each chunk is an element of a contents-list and so can be a string or
;;; a sage-envr or command.
;;; At this point, we are going to make the entirely reasonable assumption that if it
;;; is an environment or command, it contains only one string; no nested environments.
(defun MATCHES-INHIBIT-ENTRY (chunk)
  (multiple-value-bind (string context-name)
      (typecase chunk
	(string chunk)
	(sage-text-structure (error "nyi"))
	;;---This is where the assumption mentioned in the header comment applies
	(sage-envr (values (first (send chunk :contents-list)) (send chunk :envr-name)))
	(sage-command
	  (let ((command-name (send chunk :command-name)))
	    (values
	      (case command-name
		((literal-atsign) "@")
		;; Commented-out stuff below is what it should do if it's
		;; going to use the @L string.  Since it doesn't use the
		;; string, don't go through the effort of computing it.
		;; ((L) (display-string-from-L-command chunk))
		(otherwise ""))
	      command-name))))
    (if (member context-name '(L K))
	nil					;In @L and @K, accept everything
	;;In text and all other environments, make sure the string is "important"
	(let* ((stripped-string (string-trim *white-space* string))
	       (count (string-length stripped-string))
	       ;; Decide whether to use case sensitive search function or not
	       (search-function
		 (if (loop for ele in *case-inhibit-sort-on-these*	;Is word case-sens?
			   thereis (sys:%string-equal stripped-string 0 ele 0 count))
		     #'sys:%string=			;Yes, use case-sens comparison
		     #'sys:%string-equal)))		;No, use any old comparison
;	  (format t "~&String: ~S" stripped-string)
	  (or
	    ;;Check for words that are supposed to be inhibited
	    (loop for ele in *inhibit-sort-on-these*
		  thereis (funcall search-function stripped-string 0 ele 0 count))
	    ;;Check for standalone punctuation that is supposed to be inhibited, esp parens
	    ;;This happens e.g. with (@K(m-X)) which is three elements
	    (using-resource (temp string-temp)
	      (prune-non-sorting-characters stripped-string nil temp)
	      (zerop (length temp))))))))

;;;Takes a contents list and returns a string with just the characters that
;;; the contents-list represents.  It prunes out characters that should not
;;; participate in sorting for the index.  It side-effects on the argument "string"
;;; so make sure that has a fill-pointer or is otherwise equipped to do string-nconc
;;; if you are supplying the argument.
;;;String and context arguments usually supplied in recursive call.  Context is the
;;;environment or command instance.
(defun SORTABLE-STRING-FROM-CONTENTS-LIST (contents-list into-string &optional context)
  (loop for ele in contents-list		;ele is string, envr, or contents-list
	do
    (typecase ele
      ;;right here, figure out which characters to leave out of the sorting
      (string
	(prune-non-sorting-characters ele context into-string))
      (sage-text-structure
	(prune-non-sorting-characters
	  (zwei:string-interval (sage-text-structure-interval ele))
	  context into-string))
      (sage-envr				;Recursive call needed to handle list
	(sortable-string-from-contents-list (send ele :contents-list)
					    into-string ele))
      (sage-command
	(case (send ele :command-name)
	  ((L)
	   (prune-non-sorting-characters (display-string-from-L-command ele)
					 ele into-string))
	  ((literal-atsign)
	   (prune-non-sorting-characters "@" ele into-string))))
      (otherwise ())				;??
      )))

;;; Takes a string and optionally the sage-envr or sage-command that it came from.
;;; Returns a string that can be used for sorting that item.
;;; Once again, we have to do something slightly different for characters within
;;; environments and within text.
;;; @L:  Drop leading * % & from string
;;; @K:  Leave everything alone
;;; Text environments and text:  Drop parens, punctuation.  For now just ()[]
;;; This is really a pattern-matching job but we'll just have to take it easy.
;;;   ---   ***   This implements letter-by-letter indexing   ***   ---
;;;  See the Chicago Manual of Style for an explanation of this kind of sorting.
(defun PRUNE-NON-SORTING-CHARACTERS (string &optional context into-string)
  (let ((dropped-from-text *characters-dropped-from-text*))
    (cond
      ;;There is a set of special cases; causes fragility in code to attempt algorithmically
      ((member string *characters-dropped-exceptions* :test #'string-equal)
       (if into-string
	   (string-nconc into-string string)
	   string))					;Return the string unscathed
      ;;Not an exception, see what to leave out of the string for sorting purposes
      (t
       (let ((context-name (when context (typecase context
					   (sage-envr (send context :envr-name))
					   (sage-command
					    (send context :command-name)))))
	     in-string)
	 (flet ((keep-character-p (char)	;Returns T to keep the character
		  (case context-name
		    (L (if in-string		;Different test applies for leading chars
			   (not (member char '(#\sp #\-) :test #'char-equal))
			   (cond		;State still ambiguous
			     ((member char *characters-dropped-from-lisp-objects*
					 :test #'char-equal)	;Is it a leading char to drop?
			      nil)		;Discard this character
			     (t (setq in-string t)))))	;Keep the character & change the state
		    (K t)			;Anything goes anytime
		    (otherwise			;Textual, drop "unneeded" punctuation
		     (setq in-string t)		;Same treatment everywhere
		     (not (member char dropped-from-text :test #'char-equal))))))
	   (using-resource (new-string string-temp)
	     ;;little state machine, two states, nil for leading space-or-*, T for otherwise
	     ;;The state really matters only to the @L context
	     (loop for c being the array-elements of string
		   do
		   (setq c (make-char c))	;remove char style, if any
		   (cond (in-string		;Into the actual string
			  (when (keep-character-p c)
			    (vector-push-extend c new-string)))
			 (t			;Not known to be into the string yet
			  ;;Keeping leading spaces.  ---Is this right?
			  (cond ((char-equal c #\space) (vector-push-extend c new-string))
				(t (when (keep-character-p c)
				     (vector-push-extend c new-string)))))))
	     (if into-string
		 (string-nconc into-string new-string)
		 (if (string-equal string new-string)
		     string
		     (copy-string new-string))))))))))

;;;The source material for a line is an index-line data structure.
;;; Line1 comes before line2 if its right half is before that of line2.  If the right
;;; halves are the same, then check the left halves.
(defun KWIC-LESSP (line1 line2)
  (let ((left1 (first (index-line-strings line1)))
	(left2 (first (index-line-strings line2)))
	(right1 (second (index-line-strings line1)))
	(right2 (second (index-line-strings line2))))
    (cond ((string-equal right1 right2)		;Right halves are the same
	   (cond ((and (null left1) left2) t)	;Can't use string-lessp reasonably on NIL
		 ((null left2) nil)		;because it coerces to "NIL"
		 (t
		  ;;So base sort on left halves
		  (cond ((string-lessp left1 left2)
			 T)
			((string-equal left1 left2)
			 ;; left halves and right halves are equal.
			 ;; Look at non-sorting chars, so "Paging File" sorts
			 ;; before "Paging-file" even though both sort keys are "pagingfile"
			 ;; Pretty yucky to cons these, but at least it's darn rare.
			 (let ((right1cl
				 (filtered-string-from-contents-list
				   (second (index-line-contents-lists line1))))
			       (right2cl
				 (filtered-string-from-contents-list
				   (second (index-line-contents-lists line2)))))
			   (cond ((string-lessp right1cl right2cl)
				  T)
				 ((string-equal right1cl right2cl)
				  (let ((left1cl
					  (filtered-string-from-contents-list
					    (first (index-line-contents-lists line1))))
					(left2cl
					  (filtered-string-from-contents-list
					    (first (index-line-contents-lists line2)))))
				    (string-lessp left1cl left2cl)))
				 (T nil))))
			(T nil)))))
	  ;;((null right1) t)			;Just for completeness; can't happen here
	  ;;((null right2) nil)			;Just for completeness; can't happen here
	  (T					;Right halves different so sort on them
	   (string-lessp right1 right2)))))

;;;Now to get the info rearranged and printed out, again without consing.
;;;The line is an instance of index-line data structure, so it has the contents-lists
;;; that form the left and right halves of the line, as well as info on how the line
;;; was sorted, contained in the first character of the right half string.
(defun PERMUTED-LINE-DISPLAY (out-stream line entry-hash-table)
  (let* ((entry (send entry-hash-table :get-hash (index-line-key line)))	;for page #
	 (contents-list (index-line-contents-lists line))
	 (left-half (first contents-list))
	 (right-half (second contents-list))
	 (sort-start (char-upcase (aref (second (index-line-strings line)) 0))))
    (unless  (char-equal sort-start *last-sort-start*)
      (send out-stream :string-out
	    ;;majorheading ensures font, flushleft turns off centering, tabs appear cleared
	    (if (char-equal sort-start #\@)
		(format nil "~%@begin(majorheading,flushleft,above 1,below 0)@@@=@@@>@@
@end(majorheading)")
		(format nil "~%@begin(majorheading,flushleft,above 1,below 0)~C@=~C@>~C
@end(majorheading)" sort-start sort-start sort-start)))
      (setq *last-sort-start* sort-start))
    (send out-stream :tyo #\RETURN)
    (send out-stream :string-out "@>")
    (mss-contents-list out-stream left-half t)	;out goes left portion of line
    (send out-stream :string-out "@r[@ @ @ @ ]@\\")	;fixed width spacing
    (mss-contents-list out-stream right-half t)	;right portion
    (send out-stream :string-out "@ @ ")
    ;;(format t "~% page-string:   ~S" (entry-page-string entry))
    (send out-stream ':string-out (entry-page-string entry))))

;;;Call it like this: (environment-equal "foo" "bar@begin[foo]" ':begin)
;;;If this envr contains the beginning of a foo envr, it returns the char position
;;; where the @ is, otherwise nil.  Second value is where name of envr starts if long form.
;;;The symbols for longform are :begin and :end.  You have to say which you are expecting to
;;;match.  Obviously the short form @foo can never match for ':end.
(defun ENVIRONMENT-EQUAL (envr str begin-or-end &optional (from 0))
  (loop	with long-form-p
	with found
	for where = (string-search-flag-char *flag-char* str from)	;where's next real @
	while where				;any more @ to check?
	do
	(setq from (1+ where))
	(multiple-value-setq (found long-form-p)
	   (environment-equal-anchored envr str begin-or-end where))
	(when found
	  (return (values where long-form-p)))))

;;;Just like environment-equal, but looks at a specified position (default 0)
;;;Returns T if envr begins (or with long form, ends) at that position of the string,
;;;and returns non-nil as second value if it was a long-form begin or end (actually
;;;returns what long-form-environment-p returns -- position of name of envr in str)
;;;A lot of the groping around with string-search in here is being done to avoid
;;;consing substrings.
(defun ENVIRONMENT-EQUAL-ANCHORED (envr str begin-or-end &optional (pos 0))
  (if (string-equal "" str)
      (values nil nil)
      (let ((where (long-form-environment-p str pos)))
	(values
	  (if where
	      (progn				;long-form environment found
;	    (setq str (string-trim *white-space* str))	;paranoia - screws up value of where
		(let* ((open-pos (string-search-set *open-delims* str :end where :from-end t))
		       (close-pos (string-search-set "(),=" ;;*arg-break-set*
						     str :start where))
		       (end (1+ (string-search-not-char #\space str :end close-pos :from-end t))))
		  (and (string-equal str (string begin-or-end)	;we got the right long form
				     :start1 (1+ pos)
				     :start2 0 :end1 open-pos)	;begin/end [rejects @begin [foo] due to sp]
		       (string-equal str envr :start1 where :start2 0 :end1 end))))	;we got the name we wanted
	      (unless (eq begin-or-end ':end)	;@foo can never be the end of an envr!!
		(multiple-value-bind (ignore name-start)
		    (flag-char-p *flag-char* str pos)
		  (and name-start
		       (when (> (string-length str) (string-length envr))
			 (string-equal str envr
				       :start1 name-start :start2 0 :end1 (+ name-start (string-length envr))))))))
	  where))))

;;;returns position following delimiter if the string starts with @begin or @end,
;;; followed by delimiter.  So you have index for where the name of envr starts in string
;;;Tried to be impervious to minor syntactic variation in the form of extra white space
;;;like in @begin( foo,...)
;;;This manages to survive "... @begin foo" with no delimiter, correctly returning NIL
;;;but it could well be fragile.
(defun LONG-FORM-ENVIRONMENT-P (str &optional (from 0))
  (unless (string-equal "" str)			;don't do anything if str is null string
    (multiple-value-bind (maybe from)
	(flag-char-p *flag-char* str from)
      (when maybe
	(let* ((open-pos (string-search-set *open-delims* str :start from))
	       (where (1+ (string-search-not-char	;bound the perhaps "begin"
			    #\space str :end open-pos :from-end t))))
	  (if (or (string-equal str "begin" :start1 from :start2 0 :end1 where)
		  (string-equal str "end" :start1 from :start2 0 :end1 where))
	      (string-search-not-char #\space str :start (1+ open-pos))))))))	;start of envr name

;;;Just a bunch of comments, some useful for creating test stream material.

;;; These things are from permute.lisp.74
;;; These are the kludges that were put in for Rel6 to handle the tokenizing
;;; and sorting problems with odd things in index phrases.  Major problems arose
;;; with the fact that just about everything that should be ignored in some
;;; context was a legitimate top level thing to sort on in some other context.
;;;
;;; Instead of blindly heuristicating, one approach would be to classify the
;;; things that are OK to sort on and have a pattern matcher that recognizes those.
;;; Examples: names of keys, e.g. c-X [ is an editor command
;;;   non-text things enclosed in parens (:)
;;;   mouse click names [ Help ] [Show (M)]
;;;
;;; This list below is useful because it has some difficult cases that confuse
;;; any simple-minded or even overly-complicated heuristicating about when
;;; certain "punctuation" can be ignored in the sorting.
;
;=================================================================
;
;(defvar *funny-char-array* (make-array 256 :type 'art-boolean))
;
;(defun set-funny-chars ()
;  (setf (aref *funny-char-array* (char-code #/@)) t)
;  (setf (aref *funny-char-array* (char-code #/()) t)
;  (setf (aref *funny-char-array* (char-code #/))) t)
;  (setf (aref *funny-char-array* (char-code #/[)) t)
;  (setf (aref *funny-char-array* (char-code #/])) t)
;  (setf (aref *funny-char-array* (char-code #/*)) t)
;  (setf (aref *funny-char-array* (char-code #/%)) t)
;  (setf (aref *funny-char-array* (char-code #/&)) t)
;  (setf (aref *funny-char-array* (char-code #/-)) t)
;  (setf (aref *funny-char-array* (char-code #/:)) t)
;  (setf (aref *funny-char-array* (char-code #/ )) t)
;  (setf (aref *funny-char-array* (char-code #/")) t))
;
;(defvar *funny-strings* 
;	'(("@K(c-X [) Zmacs command" (((0 9)(10 15)(16 22)) ((0 5)(6 11)(12 19))))
;	  ("@K(c-X ]) Zmacs command" (((0 9)(10 15)(16 22)) ((0 5)(6 11)(12 19))))
;	  ("@K[c-X )] Zmacs command" (((0 9)(10 15)(16 22)) ((0 5)(6 11)(12 19))))
;	  ("@K(m-<)" (((0 6))  ((0 3))))
;	  ("@K(m->)" (((0 6))  ((0 3))))
;	  ("@K([) Font Editor command" (((6 25))   ((2 21))))
;	  ("@K(]) Font Editor command" (((6 25))   ((2 21))))
;	  ("Init File Form: @K(M-.) on @K(M-)(L)" (((0 15)(16 35))
;						   ((0 15)(16 28))))
;	  ("@L(si:) prefix" (((0 7)(8 13))  ((0 3)(4 10))))
;	  ("@L(#:) Reader Macro"  (((0 6)(7 19))  ((0 2)(3 15))))
;	  ("@L(:array) option for @L(defstruct :type)"  (((0 10)(11 21)(22 42))
;							 ((0 6)(7 17)(18 33))))
;	  ("@L(:array-leader) option for @L(defstruct :type)"
;	                 (((0 17)(18 28)(29 48))
;			  ((0 13)(14 24)(25 40))))
;	  ("@L(:fixnum) option for @L(defstruct :type)"
;	                 (((0 11)(12 22)(23 42))
;			  ((0 7)(8 18)(19 34))))
;	  ("@L(:grouped-array) option for @L(defstruct :type)"
;	                 (((0 18)(19 29)(30 49))
;			  ((0 14)(15 25)(26 41))))
;	  ("@L(:list) option for @L(defstruct :type)"
;	                 (((0 9)(10 20)(21 40))
;			  ((0 3)(6 16)(17 32))))
;	  ("@L(:named-array) option for @L(defstruct :type)"
;	                 (((0 16)(17 27)(28 47))
;			  ((0 12)(13 23)(24 39))))
;	  ("@L(:named-array-leader) option for @L(defstruct :type)"
;	                 (((0 23)(24 34)(35 54))
;			  ((0 19)(20 30)(31 46))))
;	  ("@L(:named-list) option for @L(defstruct :type)"
;	                 (((0 15)(16 26)(27 45))
;			  ((0 11)(12 22)(23 38))))
;	  ("@L(:tree) option for @L(defstruct :type)"
;	                 (((0 9)(10 20)(21 40))
;			  ((0 5)(6 16)(17 32))))
;	  ("@L(time:) package"   (((0 9)(10 17))   ((0 5)(6 13))))
;	  ("@L(:arg :value :both nil trace) Options"  (((0 24)(25 39)) (0  21)(22 35)))
;	  ("@L(zmail :reload)"   (((0 8)(9 17))    ((0 5)(6 13))))
;	  ("New Option to @L(defflavor): :export-instance-variables"
;	   (((0 27) (29  55))    ((0 23)(25 51))))
;	  ("New Option to @L(defstruct): :export"
;	                 (((0 27)(29 36))
;			  ((0 23)(25 32))))
;	  ("Optional Argument :ask Added to @L(zwei:save-all-files)"
;	                 (((0 31)(32 55))
;			  ((0 31)(32 51))))
;	  ("[Show (M)] Document Examiner menu item"  (((1 9)(11 28)(29 38))
;						     ((1 9)(11 28)(29 38))))
;	  ("[Show (R)] Document Examiner menu item" (((1 9)(11 28)(29 38))
;						     ((1 9)(11 28)(29 38))))
;	  ("[Select] Document Examiner menu item" (((1 7)(9 26)(27 36))
;						   ((1 7)(9 26)(27 36))))
;	  ("[Show (M)]" (((1 9)) ((1 9))))
;	  ("[Show (R)]" (((1 9)) ((1 9))))
;	  ("Start Kbd Macro @K(c-X () Zmacs command"  (((0 15)(19 25)(26 39))
;						       ((0 15)(16 20)(22 35))))
;	  ("End Kbd Macro @K[c-X )] Zmacs command" (((0 13)(17 23)(24 37))
;						    ((0 13)(14 18)(20 32))))
;	  ("@L(:arg :value :both nil trace) Options" (((3 7)(8 14)(15 20)(21 24)(25 30)
;						       (32 39))
;						      ((0 4)(5 11)(12 17)(18 21)(22 27)
;						       (28 35))))
;	  ("* :wild pathname component specifier" (((0 1)(2 36))  ((0 1)(2 36))))
;	  ("@begin[T]@@@end[T] character do not delete file flag" (((0 52))
;								   ((0 35))))
;	  ("@@" (((0 2)) ((0 1))))
;	  ("@L(&)-Keywords Accepted by @L(defmacro)" (((6 26)(30 37))
;						      ((2 22)(23 30))))
;	  ("@L(*$) function"   (((3 6)(7 15))
;				((0 2)(3 11))))
;	  ("/"goto/" format directive" (((1 6)(7 13)(14 23)) ((1 5)(7 13)(14 23))))))
;
;
;(Defvar *mousy-stuff*
;	'("[Show (M)]Document Examiner menu item" "[Show (R)] Document Examiner menu item"
;	  "[Select] Document Examiner menu item" "[Show (R)]"        "[Show (M)]"
;	  "@K(c-X [) Zmacs command"               "@K(c-X ]) Zmacs command"
;	  "@K[c-X )] Zmacs command"               "@K(m-<)"
;	  "@K(m->)"
;	  "Start Kbd Macro @K(c-X () Zmacs command"
;	  "End Kbd Macro @K[c-X )] Zmacs command"
;	  "@L(:arg :value :both nil trace) Options"
;	  "@K([) Font Editor command" 
;	  "@K(]) Font Editor command"
;	  "Init File Form: @K(M-.) on @K(M-)(L)"
;	  "@L(si:) prefix"
;	  "@L(#:) Reader Macro"
;	  "@L(:array) option for @L(defstruct :type)"
;	  "@L(:array-leader) option for @L(defstruct :type)"
;	  "@L(:fixnum) option for @L(defstruct :type)"
;	  "@L(:grouped-array) option for @L(defstruct :type)"
;	  "@L(:list) option for @L(defstruct :type)"
;	  "@L(:named-array) option for @L(defstruct :type)"
;	  "@L(:named-array-leader) option for @L(defstruct :type)"
;	  "@L(:named-list) option for @L(defstruct :type)"
;	  "@L(:tree) option for @L(defstruct :type)"
;	  "@L(time:) package"
;	  "@L(:arg :value :both nil trace) Options"
;	  "@L(zmail :reload)"
;	  "New Option to @L(defflavor): :export-instance-variables"
;	  "New Option to @L(defstruct): :export"
;	  "Optional Argument :ask Added to @L(zwei:save-all-files)"
;	  "@L(:arg :value :both nil trace) Options"
;	  "* :wild pathname component specifier"
;	  "@begin[T]@@@end[T] character do not delete file flag"
;	  "@@"
;	  "@L(&)-Keywords accepted by @L(defmacro)"
;	  "@L(*$) function"
;	  "/"goto/" format directive"))
