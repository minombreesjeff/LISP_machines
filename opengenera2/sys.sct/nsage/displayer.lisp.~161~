;;; -*- Syntax: Common-lisp; Mode: LISP; Base: 10; Package: NSAGE; Lowercase: t -*-
;;;
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;

(defmethod (:TABCLEAR ENVIRONMENT) ()
  (setq tab-stops '(0)))

(defmethod (:TABDIVIDE ENVIRONMENT) (count)
  (setq tab-stops (loop with col-width = (floor line-width count)
			for i from 0 below count
			collect (+ left-margin (* i col-width)))))

(defmethod (:TABSET ENVIRONMENT) (stops)
  (unless (null stops)				;save a little work in the common case.
    (when (stringp stops) (setq stops (list stops)))	;wasn't checking args
    (send self :add-tabs (loop for stop in stops
			       and for previous-stop = left-margin then stop
			       collect
				 (setq stop (coerce-to-tab-stop stop previous-stop
								left-margin))))))

;;;Inserts more tabs into the environment's sorted list of tabs.
;;;Uses tab stops already coerced to horizontal distances.
(defmethod (:ADD-TABS ENVIRONMENT) (stops)
  (unless (null stops)
    (setq tab-stops (sort (append tab-stops (copy-list stops)) #'<))
    ;;Eliminate duplicate stops, in case of merging.  This is linear in number of stops,
    ;;where si:eliminate-duplicates is quadratic.  Might make a difference, even for
    ;;reasonable numbers of tabstops.
    (loop for tail on tab-stops
	  for (first second) = tail
	  while second
	  when (= first second)
	  do (setf (rest tail) (cddr tail)))))

;;This is send in the mouse process specifically for screen use; there's no point
;;in trying to make it device-independent.
(defmethod (:SCREEN-DISPLAY-HEIGHT-OF-BOX LINE-HBOX) ()
  (microns-to-pixels (+ height extra-space-above) :screen))

;;This is NOT a user option.
(defvar *DISPLAY-LINE-GBOXES-SHOULD-CLEAR-SCREEN-AREA* T)



#|| ;;Here's sort of what they look like, from Devices.lisp
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL NIL :SMALL) "TVFONT")(defmethod (:DISPLAY-LINE-GBOXES WINDOW-OUTPUT-DEVICE) (line-hbox)
  (display-line-gboxes-on-window window line-hbox))

(defmethod (:DISPLAY-LINE-GBOXES LGP-DEVICE) (line-hbox)
  (send self :increment-cursorpos 0 (send line-hbox :extra-space-above) :microns)
  (send line-hbox :display-gbox-contents))
0||#

#||
1;;; Old version; doesn't work with dynamic windows.
(defun WINDOW-HANDLE-SPACE-ABOVE (window pixel-height pixel-space-above)
  (let ((window-line-height (send window :line-height)))
    (multiple-value-bind (window-visible-left nil window-width window-height)
	(send window :visible-cursorpos-limits)
      (multiple-value-bind (ignore y) (send window :read-cursorpos)
	(cond ((> (+ y
		     pixel-height pixel-space-above	;need room for this line
		     (* 2 window-line-height))	;need room for **more** for the next line
		  window-height)
	       ;; The system's **more** processing is impossibly complicated and hence
	       ;; unpredictably incorrect when you use (as we do) :set-cursorpos,
	       ;; :increment-cursorpos, :tyo <return>, :clear-rest-of-line etc.
	       ;; So we explicitly and conservatively check here for ourselves,
	       ;; and explicitly request **more**.
	       (send window :clear-between-cursorposes 0 y 0	;Hope this won't **more**!
		     (- window-height window-line-height))
	       (cond (tv:more-processing-global-enable 
		      (send window :set-cursorpos 0 (- window-height window-line-height))
		      (let ((window (si:follow-syn-stream window)))
			(setf (tv:sheet-more-flag window) 1)
			(let ((ch (send window :more-exception)))
			  (setf (tv:sheet-more-flag window) 0)
			  (setf (tv:sheet-end-page-flag window) 1)
			  (send window :handle-exceptions)
			  (cond ((listp ch)	;some blip
				 (send window :untyi ch))
				((or (null ch)
				     (char-equal ch #\space))	;ignore, having proceeded
						; the **more**
				 )
				(T		;maybe untyi it?
				 )))))
		     (T (send window :home-cursor)
			(send window :clear-rest-of-line))))
	      (T (let ((more-above
			 (+ pixel-space-above
			    ;;If the pixel-height is more than window-line-height, it's
			    ;;like space-above
			    (max 0 (- pixel-height window-line-height)))))
		   (when (> more-above 0)
		     (when (> more-above window-line-height)
		       (send window :draw-rectangle window-width more-above
			     window-visible-left y (send window :erase-aluf)))
		     ;;Don't change this to :increment-cursorpos because if x  0 then
		     ;; :clear-rest-of-line isn't equivalent to clear-all-of-line.
		     (send window :set-cursorpos 0 (+ y more-above))
		     (send window :clear-rest-of-line)))))))))

(defun WINDOW-HANDLE-SPACE-ABOVE (window pixel-height pixel-space-above)
  (loop with real-window = (si:follow-syn-stream window)
	with added-y = (+ pixel-height pixel-space-above)
	for window-line-height = (tv:sheet-line-height real-window)
	for more-vpos = (tv:sheet-more-vpos real-window)
	for cursor-y = (tv:sheet-cursor-y real-window)
	for new-bottom-y = (+ cursor-y added-y)	;in outside coordinates
	;; No exceptions if output is being truncated
	for truncate-p = (tv:sheet-truncate-output-p real-window :vertical)
	do
    (cond ((and (not truncate-p) more-vpos ( new-bottom-y more-vpos))
	   ;; Need to cause a MORE break
	   (setf (tv:sheet-more-flag real-window) 1)
	   (send window :handle-exceptions))
	  ((and (not truncate-p)
		(> new-bottom-y
		   (+ (tv:sheet-top-margin-size real-window)
		      ;; Not allowed to draw in the "partial line" area at the bottom
		      ;; of a dynamic window
		      (* (floor (tv:sheet-inside-height real-window) window-line-height)
			 window-line-height))))
	   ;; End of page.  Don't do this and MORE at the same time.
	   (setf (tv:sheet-end-page-flag real-window) 1)
	   (send window :handle-exceptions))
	  (t
	   (let ((more-above
		   (+ pixel-space-above
		      ;; If the pixel-height is more than window-line-height, it's
		      ;; like space-above
		      (max 0 (- pixel-height window-line-height)))))
	     (when (> more-above 0)
	       (multiple-value-bind (window-visible-left nil window-width nil)
		   (send window :visible-cursorpos-limits)
		 (multiple-value-bind (ignore y) (send window :read-cursorpos)
		   (when (> more-above window-line-height)
		     (send window :draw-rectangle window-width more-above
			   window-visible-left y (send window :erase-aluf)))
		   ;; Don't change this to :increment-cursorpos because if x  0 then
		   ;; :clear-rest-of-line isn't equivalent to clear-all-of-line.
		   (send window :set-cursorpos 0 (+ y more-above))
		   ;; Gross.  :set-cursorpos messes up more-vpos.  Set it back.
		   (when more-vpos
		     (set-in-instance real-window 'tv:more-vpos more-vpos))
		   (send window :clear-rest-of-line)))))
	   (return (values))))))
0||#




(defmethod (:display-line-gboxes-without-clearing-newlines line-hbox) (&optional window)
  ;; Simplest fix for the time being is the following:
  (let ((*fake-string-special-hack-spaces* nil))
    (with-device-stream (stream)
      (when window (setq stream window))
      (multiple-value-bind (x y)
	  (send stream :read-cursorpos)
	(graphics:with-graphics-translation (stream x y)
	  (graphics:with-graphics-scale (stream (/ *microns-per-device-pixel*))
	    (inside-sage-graphics-transform
	      (display-gbox-contents-new self stream))))))))


    
(defmethod (:VALIDATE-FONT-NUMBER BASIC-GBOX) ()
  (send *current-sage-device* :set-current-style
	(character-style-from-environment environment *current-sage-device*))
  (send *current-sage-device* :current-font-number))



;si:(define-ie-command sage-show-documentation (#\control-shift-d)
;     (with-ie-typein (query-io) (nsage::lookup-manual)))

;;;First crack at a simple "command" for looking up a name from Lisp.
;;;Have to work out how to look up "strings" for which the type is not yet known.  That is
;;; have to work out our equivalent of the read function!!
(defun LOOKUP-MANUAL ()
  (let ((record-group (accept 'record-group :prompt "Look up documentation for")))
    (lookup-manual-internal record-group)))

(defun PROMPT-FOR-DEVICE (&optional (include-screen-as-device t))
  (let ((printer-alist (and (fdefinedp 'get-sage-printer-alist)
			    (get-sage-printer-alist))))
    (cond ((not (or include-screen-as-device printer-alist))
	   nil)
	  (t (let ((previous-devices (and (boundp '*previous-sage-display-target-printers*)
					  *previous-sage-display-target-printers*))
		   (default-device (and (boundp 'hardcopy:*default-text-printer*)
					hardcopy:*default-text-printer*))
		   (number-of-devices (length printer-alist))
		   (default-item ())
		   (items ()))
	       ;; Construct the item list for the choices
	       ;; Always offer :screen first if you offer it at all
	       (when include-screen-as-device
		 (incf number-of-devices)
		 (let ((item '("Screen" :value :screen
			       :documentation "Display the formatted text on the screen")))
		   (push item items)))
	       (cond ((< number-of-devices 5)
		      (setq items (append items printer-alist))
		      (setq default-item
			    (or (rassoc default-device printer-alist)
				(loop for printer in previous-devices
				      thereis (rassoc printer printer-alist)))))
		     (t (flet ((printer-item (p) (list (send p :pretty-name) :value p)))
			  ;; then the default hardcopy device
			  (when (and default-device
				     (sage-can-deal-with-printer default-device))
			    (let ((item (printer-item default-device)))
			      (push item items)
			      (setq default-item item)))
			  ;; then offer the previous printers.
			  ;; This keeps menu to four or fewer items by just listing most
			  ;; recent printers and substituting "[Other printer]" for rest.
			  (loop for printer in previous-devices
				until (> (length items) 2)
				when (and (neq printer default-device)
					  (sage-can-deal-with-printer printer))
				  do (let ((item (printer-item printer)))
				       (push item items)
				       (unless default-item
					 (setq default-item item))))
			  ;; then offer other printers, if any, that aren't already offered;
			  ;; but don't offer a menu of just "[Other printer]" or just
			  ;; "Screen" and "[Other printer]"
			  (cond ((null items)
				 (setq items printer-alist))
				((and (= (length items) 1)
				      (string-equal (first (first items)) "Screen"))
				 (setq items (append items printer-alist)))
				(t (push '("[Other printer]"
					   :value :other-printer
					   :documentation
					   "Choose from menu of available printers")
					 items)
				   (setq items (nreverse items)))))))
	       ;;Now run our uims
	       (let ((choice (tv:menu-choose items
					     (if (= (length items) 1)
						 "Confirm destination"
						 "Choose a destination")
					     '(:mouse) default-item)))
		 (if (eq choice :other-printer)
		     (tv:menu-choose printer-alist "Choose a printer")
		     choice)))))))

;si:(define-ie-command sage-find-any-candidates (#\hyper-super-d)
;     (with-ie-typein (query-io) (nsage::doc-match)))

;;;Lisp world analog of zwei:com-doc-match.
(defun DOC-MATCH (&optional match-string (condition 'logical-or))
  (collect-and-match-string "Enter substring(s) from the topic"
			    #'string-search 'keyword-tokens "Any substring"
			    match-string condition))

;;;Internal function that collects the string argument to use and then calls the zwei
;;;internal version of the matching function.  It has a little hair here to handle the
;;;error condition consed up by zwei:barf in case of there not being any documentation.
;;;I did it this way because it seemed easiest and kept the zwei versions looking tidy.
(defun COLLECT-AND-MATCH-STRING (prompt matching-function match-basis request-type-string
				 &optional match-string (condition 'logical-or))
  (or match-string				;use as is if passed in
      (setq match-string			;otherwise try to collect one
	    (prompt-and-read ':string-or-nil
			     "~A: ~@[(default:~{ ~A~}) ~]"
			     prompt (reverse zwei:*last-match-list*))))
  (or match-string (setq match-string zwei:*last-match-list*))
  (if match-string
    (condition-case ()
	(doc-match-internal
	  match-string matching-function match-basis request-type-string condition)
      (zwei:barf
	(if (consp match-string)
	    (format *error-output* "~&No documentation available for\"~{ ~A~}\"" match-string)
	    (format *error-output* "~&No documentation available for \"~A\"" match-string))))
    (format *error-output* "Currently there is no default. You need to supply a string other than the null string."))
  nil)						;dummy.  Keep it from returning dis-none!!

(defun (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")tokenize-match-string0 (string)
  (if (listp string) string
      ;;---Problem here due to tokenizing.  A single-char string
      ;;can end up with no tokens, for example "/" or "?".  Any
      ;;character that is both an open and a close break is trouble.
      (let ((tokens (tokenize string
			      ':opening-delims *word-open-break*
			      ':trailing-delims *word-close-break*
			      ':trailing-keep *word-close-keep*)))
	(reverse (or tokens (list string))))))

(defun DOC-MATCH-INTERNAL (match-string matching-function match-basis request-type-string
			   condition &key (device :screen))
  (ignore device)				;--- later, fix callers
  (let* ((candidates (candidates-satisfying-condition
		       (setq zwei:*last-match-list*
			     (tokenize-match-string match-string))
		       matching-function match-basis condition))
	 (len (length candidates)))
    (log-lookup-event match-string request-type-string candidates)
    (cond ((null candidates)
	   (zwei:barf "No topic names or keywords contain~{ ~S~} with ~A"
		      zwei:*last-match-list* (string-downcase request-type-string)))
	  (t
	   (add-candidates-to-dex	;record the candidates,in case, but don't show
	     (setq candidates (ddex::sort-candidates-for-display candidates))
	     (format nil "~A match using~{ ~A~}" request-type-string
		     zwei:*last-match-list*)
	     #'ddex::alist-to-item-list nil)
	   (format t "~&Using ~A, found ~D candidate~:P matching~{ ~A~}:"
		   (string-downcase request-type-string) len zwei:*last-match-list*)
	   (loop for (string candidate) in candidates
		 do
	     (cl:fresh-line)
	     (dw:with-output-as-presentation (:type 'record-group
					      :object candidate)
	       (write-string string))))))
  zwei:dis-none)

;si:(define-ie-command sage-find-initial-substring-candidats (#\super-d)
;     (with-ie-typein (query-io) (nsage::initial-substring-doc-match)))

;;;Lisp analog of zwei:com-initial-substring-doc-match
(defun INITIAL-SUBSTRING-DOC-MATCH (&optional match-string (condition 'logical-or))
  (collect-and-match-string "Enter initial substring(s) from the topic"
			    #'initial-substring-match 'keyword-tokens
			    "Initial substring" match-string condition))

;si:(define-ie-command sage-find-whole-word-candidates (#\hyper-d)
;     (with-ie-typein (query-io)
;		     (nsage::whole-word-doc-match)))

;;;Lisp analog of zwei:com-whole-word-doc-match
(defun WHOLE-WORD-DOC-MATCH (&optional match-string (condition 'logical-or))
  (collect-and-match-string "Enter word(s) from the topic"
			    #'string-equal 'keyword-tokens "Exact word"
			    match-string condition))


;;;The set of functions for implementing the guts of the retrieval requests.

;;; 2keyword-token-string0, 2make-keyword-token-string0,
;;; 2*keyword-token-characters*0, 2*more-keyword-token-characters*0,
;;; and 2*unsorted-keyword-token-record-groups*0, 2%%keyword-token-position0, and
;;; 2%%keyword-token-length0 have been moved to defs-formatter.lisp
;;; to avoid circular dependencies.  --RWK

(defun 2search-sorted-keyword-tokens0 (token indices characters)
  (labels ((token-compare (token index)
	       (let* ((word (aref indices index))
		      (token-length (string-length token))
		      (word-length (ldb %%keyword-token-length word))
		      (compare (sys:%string-compare token 0
						    characters
						    (ldb %%keyword-token-position word)
						    word-length)))
		 (if (and (zerop compare) (> token-length word-length))
		     (1+ word-length)
		     compare))))
    (let ((ntokens (length indices)))
      (when (plusp ntokens)
	(let ((below 0)
	      (above ntokens))
	  (loop
	    (assert ( below above))
	    (let* ((middle (floor (+ above below) 2))
		   (compare (token-compare token middle)))
	      (cond ((zerop compare)
		     (return middle))
		    ((plusp compare)
		     (if (= below middle)	;floor rounds down.
			 (return nil)
			 (setq below middle)))
		    (t
		     (if (= above middle)
			 (return nil)
			 (setq above middle)))))))))))

(defun 2keyword-token-record-groups0 (token)
  (declare (values record-groups canonical-token))
  (multiple-value-bind (unsorted found-p key)
      (gethash token *unsorted-keyword-token-record-groups*)
    (unless found-p
      (let ((sorted-index (search-sorted-keyword-tokens token
							*sorted-keyword-token-indices*
							*keyword-token-characters*)))
	(cond (sorted-index
	       (setq unsorted (expand-record-group-halfword-list
				(aref *sorted-keyword-token-record-groups* sorted-index))))
	      (t (add-new-token-to-search-string token))))
      (setq key (copy-seq token *sage-completion-area*))
      (setf (gethash key *unsorted-keyword-token-record-groups*) unsorted))
    (values unsorted key)))

(defun 2set-keyword-token-record-groups0 (token record-groups)
  (setf (gethash token *unsorted-keyword-token-record-groups*) record-groups))

;;; The 2defsetf0 for 2keyword-token-record-groups0  2set-keyword-token-record-groups
0;;; has been moved to defs-formatter.lisp, to avoid circular dependencies.  --RWK

;;; Remake the string from the component keywords.
(defun2 initialize-keyword-token-string0 ()
  ;; No longer need these.
  (setf (fill-pointer *more-keyword-token-characters*) 0)

  (let ((length-needed 1))
    ;; Compute total length required.
    (si:page-in-array *sorted-keyword-token-indices*)
    (let ((indices *sorted-keyword-token-indices*))
      (declare (sys:array-register indices))
      (dotimes (index (sys:vector-length indices))
	(incf length-needed (1+ (ldb %%keyword-token-length (aref indices index))))))
    (cli::page-in-table *unsorted-keyword-token-record-groups*)
    (maphash #'(lambda (token ignore)
		 (incf length-needed (1+ (string-length token))))
	     *unsorted-keyword-token-record-groups*)

    (let* ((old-string *keyword-token-characters*)
	   (new-string old-string)
	   (index 0))
      
      (when (> length-needed (array-total-size new-string))
	(setq new-string (make-keyword-token-string :length length-needed)))

      (setf (aref new-string index) #\null)
      (incf index)

      (let ((indices *sorted-keyword-token-indices*))
	(declare (sys:array-register indices))
	(tv:dotimes-noting-progress (jndex (sys:vector-length indices)
					   "Initializing SAGE matching string")
	  (let* ((word (aref indices jndex))
		 (length (ldb %%keyword-token-length word))
		 (position (ldb %%keyword-token-position word)))
	    (setf (ldb %%keyword-token-position word) index)
	    (setf (aref indices jndex) word)
	    (copy-array-portion old-string position (+ position length)
				new-string index (incf index length)))
	  (setf (aref new-string index) #\null)
	  (incf index)))

      (maphash-noting-progress #'(lambda (token ignore)
				   (let ((length (string-length token)))
				     (copy-array-portion token 0 length
							 new-string index (incf index length)))
				   (setf (aref new-string index) #\null)
				   (incf index))
			       *unsorted-keyword-token-record-groups*
			       "Initializing SAGE matching string")

      (assert (= index length-needed))
      (setf (fill-pointer new-string) index)
      (setq *keyword-token-characters* new-string))))


;;; At full-gc time, should construct a new *string-of-all-tokens*.
;;; Since we don't know if any tokens have been deleted from the hash table,
;;; we must always do this.  We map over the database to construct the string
;;; rather than simply string-appending the two strings together so that
;;; if, at some point, we decide to make the initializer do more interesting
;;; sorting, we don't have to change too much code.
(defun sage-full-gc ()
  (initialize-keyword-token-string)
  (when (and (variable-boundp *compressed-record-groups*)
	     si:*full-gc-for-system-release*)
    (generate-topic-aarray)))

(add-initialization "Compact documentation database"
		    '(sage-full-gc)
		    '(:full-gc))

(defun2 add-new-token-to-search-string0 (token)
  (unless *inhibit-keyword-token-additions*
    (let ((array *more-keyword-token-characters*))
      (when (zerop (fill-pointer array))
	(vector-push-extend #\null array))
      (vector-push-portion-extend array token)
      (vector-push-extend #\null array))))

(defun2 keys-for-substrings0 (substrings)
  ;; Cons the tables on the stack, since we're going to throw them out anyway
  (sys:page-in-array *keyword-token-characters* 0 nil nil)
  (sys:page-in-array *more-keyword-token-characters* 0 nil nil)
  (let ((max-length (loop for string in substrings maximize (string-length string))))
    (sys:with-stack-array (skip (zwei:highest-legal-char-code) :type 'sys:art-fixnum)
      (sys:with-stack-array (reoccurrence max-length :type 'sys:art-fixnum)
	(loop for substring in substrings
	      collecting
		(progn
		  (zwei:generate-boyer-skip-table substring skip)
		  (zwei:generate-boyer-reoccurrence-table substring reoccurrence)
		  (append
		    (keys-for-substrings-internal skip reoccurrence
						  substring *keyword-token-characters*)
		    (keys-for-substrings-internal skip reoccurrence
						  substring *more-keyword-token-characters*)
		    )))))))

(defun2 keys-for-substrings-internal0 (skip-table reoccurrence-table substring from-string)
  (loop with idx = 0
	with end = (string-length from-string)
	while idx
	with keys
	as found-idx = (zwei:boyer-search-internal substring from-string
						   skip-table reoccurrence-table idx end)
	while found-idx
	do
    (let* ((beginning-idx (string-search-char #\null from-string
					      :from-end t
					      :end (1+ found-idx)))
	   (end-idx (string-search-char #\null from-string
					:start (1+ beginning-idx))))
      (push (substring from-string (1+ beginning-idx) end-idx) keys)
      (setq idx end-idx))
	finally (return keys)))

(defun2 keys-for-initial-substrings0 (substrings)
  (keys-for-substrings (loop for s in substrings
			     collect (string-append #\null s))))

;;;Takes a list of words to be checked against the internal "database" of words
;;;Returns a list of words matching each probe word (according to the heuristic rules)
(defun 2keys-for-heuristic-match0 (probes)
   (loop for probe in probes
	 collecting (database-words-matching probe)))

;;;(database-words-matching "advise")
;;;(database-words-matching "progress")
;;;Finds the words from the word database that have stems in common with the
;;;word you are interested in.
;;;This approach uses searching to find the possible words.
(defun 2database-words-matching0 (probe-word)
  (sys:page-in-array *keyword-token-characters* 0 nil nil)
  ;; Remember to use the word itself if it is too short to have any stems!
  (let* (;; The word itself has to be one of its own stems for the prefix-stripping to work
	 (probe-stems (stems-for-word probe-word))
	 (possible-matches			; list of the words that might match each probe
	   (if (= (string-length probe-word) 1)
	       probe-stems			;just an optimization for 1-char words
	       (delete-duplicates
		 (loop for stem in probe-stems
		       ;; It is reasonable to just take "first" here. (There is only one arg
		       ;; to the searching thing so it returns list of just one element.)
		       append (first (keys-for-substrings (list stem))))
		 :test #'string-equal)))
	 (keepers				;list of the words that do match each probe
	   (loop with temp
		 for match in possible-matches
		 do
		 ;;when the probe is in the list of matches, keep that match!
		 (if (string-equal match probe-word)
		     (push match temp)
		     ;;Find out what possible match and probe have in common
		     (let* ((match-stems (stems-for-word match))
			    (common-stems (intersection probe-stems match-stems
							:test #'string-equal)))
		       (when common-stems (push match temp))))
		 finally (return temp))))
;    (format t "~%~S has ~D stems: ~{ ~S ~}"
;	    probe-word (length probe-stems) probe-stems)
;    (format t "~%Possible matches: ~S" possible-matches)
;    (format t "~%Keepers: ~S" keepers)
    keepers))

;;; This list is used to transform a probe word in order to find potential matches for it.
;;; "Un" is here because we use it a lot to mean "the opposite of"
;;; and our usual leading punctuation is here so we can find method names (foo and :foo).
(defvar2 *heuristic-match-prefixes*
0	'("un" ":" "*" "%" "%%"))

;;; This list is used to transform a probe word in order to find potential matches for it.
;;; There is some kind of problem with words like "advise", which get
;;; both "adv" and "advis" as stems.  "Adv" is "clearly", to the naked eye
;;; anyhow, not a stem for "advise".
;;; The idea is right here but this list is too long.  Check the IR literature some day
;;; for ideas.
(defvar2 *heuristic-match-suffixes*
0	'("*" "<" "" "=" "" ">" "" ":" "::"
	  "a" "ability" "able" "aceous" "acious" "acy" "ae" "age" "al" "ality"
	  "ance" "ancy" "ant" "arity" "ary" "asion" "ation" "atious" "ative"
	  "e" "ed" "ee" "en" "ence" "ency" "ent" "er" "ero" "es" "esce"
	  "escency" "escent" "escible" "ese" "esion" "ess" "est" "eth"
	  "etion" "etive" "hood" "i" "ibility" "ible" "ic" "ical" "ice"
	  "ician" "icism" "icist" "icity" "ility" "im" "ine" "ing" "ings"
	  "isation" "ise" "ised" "ish" "ising" "ision" "ism" "ist" "istic"
	  "istical" "ition" "itious" "itis" "itive" "itude" "ity" "ive"
	  "ization" "ize" "ized" "izing" "ment" "mental" "mentality"
	  "ness" "oid" "or" "ory" "ose" "osity" "otion" "ry" "s" "ship"
	  "sion" "tic" "tion" "ure" "usion" "ution" "utive" "y"))

;;; We strip prefixes and suffixes to find something to use as a stem.  There have
;;; to be at least this many characters left or it isn't enough to be useful as a stem.
(defvar 2*minimum-stem-length*0 3)

;;;Define the word to be one of its own stems, always
;;; The word itself has to be one of its own stems for the prefix-stripping to work
(defun 2stems-for-word0 (word)
  (let* ((word-length (string-length word))
	 (without-prefixes
	   (loop for prefix in *heuristic-match-prefixes*
		 for prefix-length = (string-length prefix)
		 when (and ( (- word-length prefix-length) *minimum-stem-length*)
			   (string-equal prefix word :end2 prefix-length))
		 collect (substring word prefix-length)))
	 (without-suffixes
	   (loop for suffix in *heuristic-match-suffixes*
		 for stem-length = (- word-length (string-length suffix))
		 when (and ( stem-length *minimum-stem-length*)	;enough to consider?
			   (string-equal suffix word	;does it match?
					 :start2 stem-length))
		 collect (substring word 0 stem-length))))
;    ;;debugging stuff only
;    (let ((wo-prefix-length (length without-prefixes))
;	  (wo-suffix-length (length without-suffixes)))
;      (format t "~&For ~S, there are ~D matches to try:~%~D found by removing the prefixes: ~{ ~S ~}~%~D found by removing the suffixes: ~{ ~S ~}"
;	      word (+ wo-prefix-length wo-suffix-length)
;	      wo-prefix-length without-prefixes
;	      wo-suffix-length without-suffixes))
    (nconc (ncons word) without-prefixes without-suffixes)))

;;;Creates a list containing all of the "items" that satisfy a query.  An item is
;;;a list ("name" function-spec...)
;;;match-list is list of string tokens, match-cache is a hash table, matching
;;;function is something like #'string-search, match-basis is {:keyword :name},
;;;condition is {logical-and logical-or adjacent}
(defun 2candidates-satisfying-condition0 (match-list matching-function
					match-basis condition)
  (tv:noting-progress ("Finding candidates")
    (let ((possibilities (all-possibilities match-list matching-function)))
      (when possibilities
	(remove-duplicates
	  (record-groups-satisfying-match-basis 
	    (ecase condition
	      ((adjacent logical-and) (reduce #'intersection possibilities))
	      (logical-or (reduce #'union possibilities)))
	    match-list
	    matching-function
	    match-basis
	    condition))))))			;working on a newly-consed list

;;;Contract: Take a list of one or more words to match
;;; For each word, return the list of records that would match that word,
;;; using the particular kind of searching requested.
;;; In all cases except string-equal search, each word is expanded into a list
;;; of matches; a list of records is then collected for that list of matches.
(defun2 all-possibilities0 (match-list &optional (matching-function #'string-search))
  (let ((tokens-lists
	  (select matching-function
	    ((#'string-equal)
	     (map 'list #'ncons match-list))
	    ((#'string-search)
	     (keys-for-substrings match-list))
	    ((#'initial-substring-match)
	     (keys-for-initial-substrings match-list))
	    ((#'heuristic-match)
	     (keys-for-heuristic-match match-list)))))
    (loop for token-list in tokens-lists
	  collect (loop for token in token-list
			append (keyword-token-record-groups token)))))

;;;This function is not just a dispatching flag!  It actually gets called in
;;;the course of the adjacent word order determination (for example).
(defun2 heuristic-match0 (string1 string2)
  (let ((string1-matches (stems-for-word string1))
	(string2-matches (stems-for-word string2)))
    (intersection string1-matches string2-matches :test #'string-equal)))

(defvar2 *validate-records*0 nil)

(defun2 record-groups-satisfying-match-basis0 (candidates match-list
					     matching-function match-basis condition)
  (flet ((token-matcher (token tokens)
	   (find token tokens :test matching-function)))
    (ecase match-basis
      (keyword-tokens
	(if (and (not *validate-records*)
		 (or (neq condition 'adjacent)
		     (= (length match-list) 1))) candidates
	    (tv:noting-progress ("Validating candidates")
	      (loop for rg in candidates
		    ;; must validate each record group because the word-hash-table might
		    ;; not be up-to-date.  Yecch.
		    for count from 0
		    with length = (length candidates)
		    as record = (find-record-for-lookup rg)
		    as tokens = (and record (doc-record-tokens record))
		    when
		      (progn (tv:note-progress count length)
			     (flet ((tester (x) (token-matcher x (apply #'append tokens))))
			       (ecase condition
				 (logical-and (every #'tester match-list))
				 (logical-or (some #'tester match-list))
				 (adjacent (sage-adjacent-tokens
					     tokens match-list matching-function)))))
		      collect rg))))
      (tokens
	(loop for rg in candidates
	      as record = (find-record-for-lookup rg)
	      as tokens = (and record (first (doc-record-tokens record)))
	      when
		(flet ((tester (x) (token-matcher x tokens)))
		  (ecase condition
		    (logical-and
		      (every #'tester match-list))
		    (logical-or
		      (some #'tester match-list))
		    (adjacent (sage-adjacent-tokens (ncons tokens) match-list
						    matching-function))))
		collect rg)))))

;;(fmakunbound 'FIXUP-ALIST-ENTRY)

#||
1;; No longer needed, I think -- doughty
;;;Returns t when each of the tokens in match-list is "in" string (according to
;;;the matching-function.
(defun SAGE-LOGICAL-AND (match-list pair matching-function match-basis)
  (loop with spec = (second pair)
	for token in match-list
	always (containing-word-match
		 token spec matching-function match-basis *word-open-break*
		 *word-close-break* nil *word-close-keep*)))

(defun SAGE-LOGICAL-OR (match-list pair matching-function match-basis)
  (loop for token in match-list
	thereis (containing-word-match
		  token (first pair) matching-function match-basis *word-open-break*
		  *word-close-break* nil *word-close-keep*)))

0||#

(defun2 sage-adjacent-tokens0 (tokens-lists match-list matching-function)
  (flet ((adjacent-tokens-internal (token-list)
	   (loop for remaining-tokens on token-list
		 with first = (first match-list)
		 thereis (and (funcall matching-function first (first remaining-tokens))
			      (loop for match-token in (cdr match-list)
				    for rt = (cdr remaining-tokens) then (cdr rt)
				    always (funcall matching-function
						    match-token (first rt)))))))
    (some #'adjacent-tokens-internal tokens-lists)))


;;; Old guts of displayer, kept around for posterity

1#||

(defun DISPLAY-LINE-GBOXES-ON-WINDOW (window line-hbox)
  (let ((height (send line-hbox :height))
	(extra-space-above (send line-hbox :extra-space-above)))
    (window-handle-space-above window
			       (microns-to-pixels height :screen)
			       (microns-to-pixels extra-space-above :screen))
    (send line-hbox :display-gbox-contents)
    ;;Tell the mouse process that we changed what's on the screen under it.
    (tv:mouse-wakeup (tv:sheet-mouse window))))

(defun WINDOW-HANDLE-SPACE-ABOVE (window pixel-height pixel-space-above)
  (send window :allocate-vertical-space-for-output pixel-height pixel-space-above))

(defmethod (:DISPLAY-GBOX-CONTENTS LINE-HBOX) ()
  (let ((font-number)
	(x-position :start-of-line))
      (do-line-gboxes (gbox first-gbox newline-gbox)
	(when (null font-number)
	  (setq font-number (send gbox :validate-font-number)))
	(multiple-value-setq (font-number x-position)
	  (send gbox :display-gbox *current-sage-device* font-number x-position)))))

(defmethod (beginning-mouse-sensitive-thing? line-hbox) (x-pos gbox)
  (when (and (symbolp x-pos) (neq x-pos :unknown))
    (setq x-pos (hposition+ (send gbox :environment) x-pos)))
  (and mouse-sensitive-groups
       (numberp x-pos)
       (loop with pixels-x-pos = (microns-to-pixels x-pos :screen)
	     for group in mouse-sensitive-groups
	     for start-x = (mouse-group-start-x group)
	     when (= pixels-x-pos start-x)
	       return group)))

(defmethod (ending-mouse-sensitive-thing? line-hbox) (x-pos gbox)
  (when (and (symbolp x-pos) (neq x-pos :unknown))
    (setq x-pos (hposition+ (send gbox :environment) x-pos)))
  (and mouse-sensitive-groups
       (numberp x-pos)
       (loop with pixels-x-pos = (microns-to-pixels x-pos :screen)
	     for group in mouse-sensitive-groups
	     for end-x = (mouse-group-end-x group)
	     when (= pixels-x-pos end-x)
	       return group)))

(defmethod (:mouse-sensitive-thing line-hbox) (x)
  (and mouse-sensitive-groups
       (loop for group in mouse-sensitive-groups
	     for start-x = (mouse-group-start-x group)
	     for end-x = (mouse-group-end-x group)
	     when (and (numberp x)
		       ( start-x x)
		       (< x end-x))
	       return group)))

(defun DISPLAY-GBOX-CHECK-HPOS (device environment x-position gbox)
  (when (symbolp x-position)
    ;;Some checking for starting a centered or right-flushed line
    (cond ((member x-position '(:start-of-line :start-of-paragraph))
	   (let ((fill-mode (send environment :fill-mode)))
	     (case fill-mode
	       ((centered flushright)
		(let ((text-width (loop for gbox = gbox then (box-next gbox)
					until (or (null gbox) (send gbox :newline?))
					sum (send gbox :width)))
		      (line-width (send environment :line-width)))
		  (setq x-position
			(+ (send environment :left-margin)
			   (if (eq fill-mode 'centered)
			       (floor (- line-width text-width) 2)
			       (- line-width text-width))))))
	       (otherwise
		(setq x-position (hposition+ environment x-position))))))
	  (T (setq x-position (hposition+ environment x-position))))
    (send device :set-cursorpos x-position () :micron))
  x-position)

(defmethod (:DISPLAY-GBOX STRING-GBOX) (device font-number x-position)
  (setq x-position (display-gbox-check-hpos device environment x-position self))
  (let ((script-displacement (send environment :script-displacement)))
    (cond ((zerop script-displacement)
	   (send device :string-out string start-index end-index))
	  (T (send device :increment-cursorpos 0 (- script-displacement) :micron)
	     (send device :string-out string start-index end-index)
	     (send device :increment-cursorpos 0 script-displacement :micron))))
  (values font-number (+ x-position width)))

(defmethod (:DISPLAY-GBOX SPACE-GBOX) (device font-number x-position)
  (setq x-position (display-gbox-check-hpos device environment x-position self))
  (send device :tyo #\space)
  (values font-number (+ x-position width)))

(defmethod (:DISPLAY-GBOX TAB-CHARACTER-GBOX) (device font-number x-position)
  (setq x-position (display-gbox-check-hpos device environment x-position self))
  (send device :increment-cursorpos width 0)
  (values font-number (+ x-position width)))

(defmethod (:DISPLAY-GBOX NEWLINE-GBOX) (device font-number ignore)
  (cond (*display-line-gboxes-should-clear-screen-area*
	 (send device :tyo #\newline))
	(T nil))				;just don't touch the cursor, leave at right
  (values font-number :start-of-line))

(defmethod (:DISPLAY-GBOX PSEUDO-PARAGRAPH-BREAK-GBOX) (device font-number x-position)
  (ignore device x-position)
  (values font-number :start-of-paragraph))

(defmethod (:DISPLAY-GBOX PARAGRAPH-BREAK-GBOX) (device font-number ignore)
  (when *debugging-formatter*
    (multiple-value-bind (code font)
	(pi-char-code-and-font (ecase break-type
				 (normal 'paragraph)
				 (limited 'limited-paragraph)))
      (send device :tyo code font)))
  (values font-number (ecase break-type
			(normal :start-of-paragraph)
			(limited :start-of-line))))	;Paragraph-breaks limited.

(defmethod (:DISPLAY-GBOX CURSOR-MOTION-GBOX) (device font-number x-pos)
  (send device :set-cursorpos x-position y-position :micron)
  (values font-number (or x-position x-pos)))

(defmethod (:DISPLAY-GBOX CURSOR-SAVING-ENTRY-GBOX) (device font-number x-pos)
  (multiple-value-bind (x y) (send device :read-cursorpos)
    (setq saved-x-position x
	  saved-y-position y))
  (values font-number x-pos))

(defmethod (:DISPLAY-GBOX CURSOR-SAVING-EXIT-GBOX) (device font-number x-pos)
  (ignore x-pos)
  (send device :set-cursorpos
	(cursor-saving-entry-gbox-saved-x-position entry-gbox)
	(cursor-saving-entry-gbox-saved-y-position entry-gbox))
  (values font-number (cursor-saving-entry-gbox-saved-x-position entry-gbox)))

(defmethod (:DISPLAY-GBOX ENVR-ENTRY-GBOX) (device ignore x-position)
  (ignore device);---
  (values (send self :validate-font-number)
	  x-position))

(defmethod (:DISPLAY-GBOX ENVR-EXIT-GBOX) (ignore ignore x-position)
  (values () x-position))

(defmethod (:DISPLAY-GBOX PRESENTATION-ENTRY-GBOX) (device font-number x-position)
  (vector-push-extend 
    (lexpr-send device :handle-presentation :start *presentation-stack*
		:object presentation-object
		:type presentation-type
		presentation-options)
    *presentations*)
  (values font-number x-position))

(defmethod (:DISPLAY-GBOX PRESENTATION-EXIT-GBOX) (device font-number x-position)
  (send device :handle-presentation :end *presentation-stack*)
  (values font-number x-position))

(defmethod (:DISPLAY-GBOX RECORD-ENTRY-GBOX) (device font-number x-position)
  (let ((presentation
	  (start-record-presentation device NIL *presentation-stack* record)))
    (when presentation
      (vector-push-extend presentation *presentations*)))
  (values font-number x-position))

(defmethod (:DISPLAY-GBOX RECORD-EXIT-GBOX) (device font-number x-position)
  (end-record-presentation device NIL *presentation-stack* (send entry-gbox :record))
  (values font-number x-position))

(defmethod (:display-gbox picture-gbox) (device font-number x-position)
  (setq x-position (display-gbox-check-hpos device environment x-position self))
  (with-device-stream (stream device)
    (multiple-value-bind (width height)
	(cached-width-and-height self)
      (multiple-value-bind (x ignore) (send stream :read-cursorpos)
	;; --- don't call with-room-for-graphics, set up
	;; appropriate transform so we don't get the stupid 
	;; newline afterwards.
	(graphics:with-room-for-graphics (stream height)
	  (graphics:with-graphics-translation (stream x 0)
	    (with-character-style-for-picture (stream picture)
	      (funcall (sage-picture-drawing-function picture) stream)))))
      (values font-number
	      (+ x-position (* width *microns-per-screen-pixel*))))))


    ;;When you add or delete clauses here, remember to update the corresponding ones
    ;;in (simple-command-gbox :width-annotate)
(defmethod (:DISPLAY-GBOX COMMAND-GBOX) (device font-number x-position)
  (command-gbox-display-gbox-old self device font-number x-position))

(define-command-gbox-generic command-gbox-display-gbox-old (device font-number x-position)
  (setq x-position (display-gbox-check-hpos device environment x-position self))
  (command-name-display device command-name font-number x-position))

(define-command-gbox-method (command-gbox-display-gbox-old cb) (device font-number x-position)
  (ignore device)
  ;;---To remind us to do this
  (values font-number x-position))

(define-command-gbox-method (command-gbox-display-gbox-old
			      (collect-right-flushing tab-to-tab-stop collect-centering))
			    (device font-number x-position)
  (let ((x (display-gbox-check-hpos device environment x-position self)))
    (let ((new-x (+ x width)))
      (when (minusp width)
	(when *debugging-sage* (send device :tyo #\!))
	(send device :tyo #\newline))		;---not allowed
      (send device :set-cursorpos new-x () :micron)
      (values font-number new-x))))

(define-command-gbox-method (command-gbox-display-gbox-old em)
			    (device font-number x-position)
  (setq x-position (display-gbox-check-hpos device environment x-position self))
  (let ((script-displacement (send environment :script-displacement)))
    (multiple-value-bind (em-code em-font)
	(pi-char-code-and-font 'em-dash)
      (send device :increment-cursorpos 0 (- script-displacement))
      (send device :tyo em-code em-font)
      (send device :increment-cursorpos 0 script-displacement)
      (values font-number (+ x-position width)))))

(define-command-gbox-method (command-gbox-display-gbox-old
			      (literal-space missing-special-character))
			    (device font-number x-position)
  (setq x-position (display-gbox-check-hpos device environment x-position self))
  (send device :tyo #\space font-number)
  (values font-number (+ x-position width)))

(define-command-gbox-method (command-gbox-display-gbox-old
			      (make string modify include label blankspace))
			    (device font-number x-position)
  ;;---Ignored, or at least not displayed...
  (setq x-position (display-gbox-check-hpos device environment x-position self))
  (values font-number x-position))

(define-command-gbox-method (command-gbox-display-gbox-old newpage)
			    (device font-number x-position)
  (setq x-position (display-gbox-check-hpos device environment x-position self))
  (loop with arg = (first parameter)
	repeat (selector arg eql
		 (nil 1)
		 (otherwise (1+ arg)))
	do (send device :tyo #\page))
  (values font-number :unknown))

(defun COMMAND-NAME-DISPLAY (device command-name font-number x-position)
  (cond ((and *debugging-sage* (not (command-known-not-to-display command-name)))
	 (send device :tyo #\@)
	 (send device :string-out (string command-name))
	 (values font-number (* *microns-per-device-pixel*
				(send device :read-cursorpos))))
	(T (values font-number x-position))))

;;These guys are used by the line-assembler to mark the end of the line.
;;It is pretty much wrong for them to be replaced by newlines before their expansion.
(defmethod (:DISPLAY-GBOX UNEXPANDED-REFERENCE-GBOX) (device font-number x-position)
  (setq x-position (display-gbox-check-hpos device environment x-position self))
  (values font-number :unknown))

||#
