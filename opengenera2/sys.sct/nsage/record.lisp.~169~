;;; -*- Syntax: Common-lisp; Mode: LISP; Package: NSAGE; Base: 10; Lowercase: t -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;

;; This is how you clone a doc record.
;; When the clone is returned, it is "canonicalized", which means that
;; character style (and related things, like sage-pointy-hands) have
;; been removed from sage-text-structures, becoming additional markup
;; structures (like @LISP).

(defflavor D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")unbalanced-language-forms0 () (zwei:barf) )

(defmethod 1(dbg:report unbalanced-language-forms)0 (stream)
  (format stream "Can't delete or copy unbalanced language form delimiters."))

(sys:defvar-resettable 1*check-for-unbalanced-language-forms*0 t t)

(defmacro 1modern-charmap0 ((from-bp to-bp char-var) &body body)
  `(modern-charmap-1 ,from-bp ,to-bp
		     (dw:named-continuation modern-charmap-1 (,char-var)
		       ,@body)))

(defun 1modern-charmap-10 (from-bp to-bp continuation)
  (zwei:charmap (from-bp to-bp)
    (funcall continuation (zwei:charmap-char))))

(defun 1check-for-unbalanced-language-forms0 (bp1 bp2)
  (when *check-for-unbalanced-language-forms*
    (let ((count 0))
      (multiple-value-bind (open close)
	  (pointy-hands-in-sage-symbol-face)
	(modern-charmap (bp1 bp2 char)
	  (cond ((char-equal char open)
		 (incf count))
		((char-equal char close)
		 (decf count))))
	(unless (zerop count)
	  (signal 'unbalanced-language-forms))))))
;; The clone-contents-internal methods are
;; internal to this, and aren't to be called elsewhere.
(defmethod 1(clone-record-contents doc-record)0 ()
  (let ((new (make-instance (type-of self) :record-group record-group)))
    (condition-case ()
	 (copy-doc-record-field-contents new self)
       (unbalanced-language-forms
	 (error "The record \"~a\" contains unbalanced language form delimiters." self)))
    new))

(defgeneric 1clone-contents-internal0 (object)
  (:function
    (typecase object
      (string (copy-string object))
      (sage-directive
	(let ((new-directive (funcall (flavor:generic clone-contents-internal) object)))
	  (when (maintains-connection-flags-p object)
	    (setf (connected-to-previous-line new-directive nil)
		  (connected-to-previous-line object nil)
		  (connected-to-previous-line new-directive t)
		  (connected-to-previous-line object t)
		  (connected-to-next-line new-directive nil)
		  (connected-to-next-line object nil)
		  (connected-to-next-line new-directive t)
		  (connected-to-next-line object t)))
	  new-directive))
      (list
	(mapcar #'clone-contents-internal object))
      (otherwise object)
      )))

;; This is why clone-contents-internal isn't simply clone-record-contents
(defmethod 1(clone-contents-internal doc-record)0 ()
  self)

;;; Should never get called.  The right thing to call is clone-record-field.
(defmethod 1(clone-contents-internal record-field)0 ()
  (make-record-field-internal superior (clone-contents-internal contents)))

(defmethod 1(clone-contents-internal sage-envr)0 ()
  (make-sage-envr envr-name
		  (clone-contents-internal envr-mods)
		  (clone-contents-internal contents-list)))

(defmethod 1(clone-contents-internal sage-command)0 ()
  (make-sage-command command-name (clone-contents-internal parameter)))
(defmethod 1(clone-contents-internal sage-macro-call)0 ()
  (make-sage-macro-call macro-name (clone-contents-internal macro-args)))
(defmethod 1(clone-contents-internal sage-reference)0 ()
  (make-instance 'sage-reference :record-group record-group :view view :field field
1		 :0appearance1 0appearance
		 :booleans booleans))
(defmethod 1(clone-contents-internal sage-text-structure)0 ()
  (check-for-unbalanced-language-forms
    (zwei:interval-first-bp interval) (zwei:interval-last-bp interval))
  (make-instance 'sage-text-structure :text (zwei:string-interval interval)))

(defmethod 1(clone-contents-internal sage-picture)0 ()
  (make-sage-picture
    :type type
    :file-name file-name
    :name name
    :binary-encoding (copy-seq binary-encoding)
    ;; we may have never computed the drawing function
    ;; compute it now so every clone doesn't have to
    :drawing-function (sage-picture-drawing-function self)))

(defmethod 1(clone-contents-internal example-record-marker)0 ()
  (make-example-record-marker :type type :encoding (copy-seq encoding)))

(defgeneric 1clone-record-field0 (record-field &optional new-superior)
  (:function
    (and record-field
	 (funcall (flavor:generic clone-record-field) record-field new-superior))))

(defmethod 1(clone-record-field record-field)0 (&optional new-superior)
  ;; Create an empty record field
  (let ((new-record-field (make-record-field-internal (or new-superior superior) nil)))
    ;; then fill it with a copy of the stuff in the old record field
    (setf (directive-inferiors new-record-field)
	  (canonicalize-contents-list contents new-record-field))
    new-record-field))

;; If you think this is gross, look at DEFINE-ENVIRONMENT-ATTRIBUTES
;; and search for "marines".  At least I deleted the hair having
;; to do with preserving variable-unboundness.
;; It would be nice to not have to invent a different name for each
;; flavor.  I think the alternative is to parallel :list and :inverse-list
;; method combination with :values and :inverse-values.  I'd rather not do that.
(defmacro 1define-instance-variable-copier0 (name flavor &rest variables)
  (setq variables (copy-list variables))
  (let ((getter (dw::fintern "~a-getter" name)))
    `(progn (defmethod (,getter ,flavor) (new-parent)
	      (declare (sys:function-parent ,name define-instance-variable-copier))
	      (progn new-parent)
	      (values ,@(mapcar (lambda (var)
				  (if (consp var)
				      (destructuring-bind (variable type &optional accessor-p)
					  var
					(let ((access-form
						(ecase accessor-p
						  ((nil) variable)
						  (:accessor
						    `(,(intern
							 (string-append 'doc-record- variable))
						      self)))))
					  (ecase type
					    ((nil) `(clone-contents-internal ,access-form))
					    (:contents-list
					      `(canonicalize-contents-list ,access-form
									   new-parent))
					    (:field-alist
					      `(canonicalize-field-alist ,access-form
									 new-parent))
					    (:record-field
					      `(clone-record-field ,access-form new-parent)))))
				      `(clone-contents-internal ,var)))
				variables)))
	    (defmethod (,name ,flavor) (.other-instance.)
	      (declare (sys:function-parent ,name define-instance-variable-copier))
	      (multiple-value-setq ,(mapcar (lambda (var)
					      (if (consp var)
						  (destructuring-bind
						    (variable type &optional accessor-p) var
						    (ignore type accessor-p)
						    variable)
						  var))
					    variables)
		(,getter .other-instance. self))))))

(define-instance-variable-copier 1copy-doc-record-slots0 doc-record
  name
  version-number
  disk-location
  source-file
  (contents :record-field)
  callees
  ;; callers
  (fields :field-alist)
  tokens
  ;; keyword-tokens
  (keywords :record-field)
  (oneliner :record-field)
  (source-topic :record-field :accessor)
  source-type
  document-type
  flags
  ;; installed-record
  ;; previously-installed-records
  ;; published-record				;or version-no and disk-location
  modification-history
  ;; older-file-version-records
  )

(defgeneric 1copy-doc-record-field-contents0 (new-record old-record)
  (:method-combination :progn))

(defmethod 1(copy-doc-record-field-contents doc-record)0 (old-record)
  (copy-doc-record-slots self old-record))

(define-instance-variable-copier 1copy-lisp-record-slots0 lisp-record
  (arglist :record-field))

(defmethod 1(copy-doc-record-field-contents lisp-record)0 (old-record)
  (copy-lisp-record-slots self old-record))

(define-instance-variable-copier 1copy-concept-record-slots0 concept-record
  (source-title :record-field :accessor)
  (abbrev :contents-list))

(defmethod 1(copy-doc-record-field-contents concept-record)0 (old-record)
  (copy-concept-record-slots self old-record))

(defun 1convert-doc-info-to-record0 (topic)
  (let ((info (si:function-spec-get topic 'documentation-info)))
    (typecase info
      (documentation-info
	(copy-stuff-from-doc-info topic (documentation-info-record-type info)))
      (cons (dolist (thing info)
	      (when (typep thing 'documentation-info)
		(copy-stuff-from-doc-info topic (documentation-info-record-type thing))))))))

#||
(2 0 (NIL 0) (NIL NIL :SMALL) "TVFONT");;; Old version for doc-info structures
(defun convert-doc-info-to-record (topic)
  (let ((struct (si:function-spec-get topic 'documentation-info)))
    (when struct
      (loop for (property type) on (documentation-info-source-type struct) by #'cddr
	    do
	(copy-stuff-from-doc-info topic type)))))
0||#

(defun 1copy-stuff-from-doc-info0 (topic type)
  (let ((record (find-record-for-topic-and-type topic type :published :create-p t)))
    (setf (doc-record-name record) topic)
    (macrolet ((copy (from-prop to-accessor)
		 `(setf (,(dw::fintern "DOC-RECORD-~a" to-accessor) record)
			(get-sage-property topic type ',from-prop))))
      (copy source-file source-file)
      (copy source-topic source-topic)
      (copy (make-record-field record :published oneliner) oneliner)
      (copy source-type source-type)
      (when (typep record 'concept-record-type-mixin)
	(copy source-title source-title))
      (copy document-type document-type))
    (setf (doc-record-tokens record)
	  ;; Kludge to get tokens into new-style token lists.  This duplicates title tokens
	  ;; in the keyword tokens, but they can't be separated because some title tokens
	  ;; might also be keyword tokens.
	  (canonicalize-tokens (list (get-sage-property topic type 'tokens)
				     (get-sage-property topic type 'keyword-tokens))))
    (setf (doc-record-available record)
	  (ecase (get-sage-property topic type 'availability)
	    ((nil) T)
	    (off-line nil)))
    (setf (doc-record-disk-location record)
	  (list (let ((location (get-sage-property topic type 'location)))
		  (etypecase location
		    ;;Gone: (basic-doc-record (send location :disk-location))
		    (cons location)
		    (symbol location)))))
    (setf (doc-record-callees record)
	  (let ((alist ()))
	    (dolist (stuff (get-sage-property topic type 'callees))
	      (destructuring-bind (callee-topic callee-type callee-reftype) stuff
		(let ((callee-record-group
			(find-record-group-for-topic-and-type callee-topic callee-type nil t))
		      (there (assoc callee-reftype alist)))
		  (add-record-as-caller callee-record-group record callee-reftype)
		  (if there
		      (push callee-record-group (rest there))
		      (push (list callee-reftype callee-record-group) alist)))))
	    (dolist (item alist)
	      ;; Restore prior order
	      (setf (rest item) (nreverse (rest item))))
	    alist))
    (setf (doc-record-version-number record) 0)	;nothing better?
    record))

(defgeneric 1add-record-as-caller0 (callee-record-group caller-record callee-reftype)
  )

(defmethod 1(add-record-as-caller record-group)0 (caller-record callee-reftype)
  (let ((there (assoc callee-reftype callers)))
    (if there
	;;---area?
	(pushnew caller-record (cdr there) :localize t)
	;;---area? list-in-area?
	(push (list callee-reftype caller-record) callers :localize t)))
  ())

(defgeneric 1remove-record-as-caller0 (callee-record-group caller-record callee-reftype
							 &optional old-installed-record)
  )

(defmethod 1(remove-record-as-caller record-group)0 (caller-record
						    callee-reftype
						    &optional old-installed-record)
  (let ((alist-element (assoc callee-reftype callers)))
    (when alist-element
      (let ((new-caller-list (delete caller-record
				     (delete old-installed-record (cdr alist-element)))))
	(if (null new-caller-list)
	    (setq callers (delete alist-element callers))
	    (setf (cdr alist-element) new-caller-list))))))

(defun 1clear-record-registries0 ()
  (clrhash *unique-idrecord-group-registry*)
  (clrhash *unsorted-keyword-token-record-groups*)
  (setq *sorted-keyword-token-indices* '#())
  (clrhash *phony-function-spec-hash-table*)
  (setf (fill-pointer *topic-aarray*) 0)
  (setf (si:aarray-sort-state *topic-aarray*) 0)
  "Your NSage doc system has been cleared")

(defun 1record-group-topic-and-type-match0 (record-group match-topic match-type)
  (setq match-topic (fixup-old-doc-symbol-topic match-topic nil))
  (and (equalp match-topic (record-group-topic record-group))
       (eq (coerce-record-type match-type 'property)
	   (coerce-record-type (record-group-type record-group) 'property))))

#||
;;;---Debugging
(defun find-null-record-types ()
  (let ((results))
    (dw::map-over-table
      *topic-and-typerecord-group-registry*
      (lambda (key value)
	(ignore key)
	(loop for (nil . record-group) in value
	      for installed-record = (record-group-installed-record record-group)
	      when (and installed-record
			(null (doc-record-source-type installed-record)))
		collect installed-record into ans
	      finally (when ans (push ans results)))))
    results))

(defun get-rid-of-record (record)
  (let ((record-group (doc-record-record-group record)))
    (remhash (record-group-unique-id record-group) *unique-idrecord-group-registry*)
    (let ((alist (dw::table-get *topic-and-typerecord-group-registry*
				(doc-record-name record))))
      (setf (dw::table-get *topic-and-typerecord-group-registry*
			   (doc-record-name record))
	    (remove record-group alist :key #'cdr)))))
||#

;;; Does there need to be a similar method on 1compressed-record-group0?
(defmethod 1(make-record-group-inaccessible-to-ui record-group)0 ()
  (flet ((rg-eql (rg1 rg2)
	   ;; don't know if we really need to be this conservative
	   (or (eql rg1 rg2)
	       (eql (follow-structure-forwarding rg1)
		    (follow-structure-forwarding rg2)))))

    ;; remove from token tables
    (sys:with-data-stack
      (let ((canonical-tokens-done (make-hash-table :area :stack))
	    (record (find-record-for-lookup self)))
	(when record
	  (loop for token-list in (doc-record-tokens record)
		do
	    (loop for token in token-list
		  do
	      (multiple-value-bind (rgs canonical-token)
		  (keyword-token-record-groups token)
		(unless (gethash canonical-token canonical-tokens-done)
		  (setf (keyword-token-record-groups canonical-token)
			(delete self rgs :test #'rg-eql))
		  (setf (gethash canonical-token canonical-tokens-done) t)))))))))
  ;; remove from completion aarray
  (let ((completion (record-group-topic-completion self)))
    (si:aarray-delete *topic-aarray* completion self))
  
  ;; He's dead, Jim
  (setq killed t))

(defmethod 1(remove-record-group-as-caller-from-all-callees record-group)
0	   (&key (published-too t))
  (flet ((fix-record (record)
	   (when record
	     (let ((callees (doc-record-callees record)))
	       (loop for (call-type . callee-record-groups) in callees
		     do
		 (dolist (callee-record-group callee-record-groups)
		   (remove-record-as-caller callee-record-group record call-type)))))))
    ;; ONLY do published record if this is from a patch.
    (when published-too (fix-record published-record))
    (fix-record installed-record)
    (mapc #'fix-record edited-records)))

(defun 1undocument-record-group0 (&key unique-id record-group record-group-name unique-index)
  (ignore record-group-name)
  (unless record-group
    (setq record-group
	  (or (and unique-id (lookup-unique-id-registry unique-id))
	      (and unique-index
		   (let ((rg
			   (index-compressed-record-group unique-index)))
		     (when rg
		       (setq rg (expand-compressed-record-group rg :unique-id unique-id)))
		     rg)))))
  (cond ((null record-group)
	 (cond (unique-id
		(cerror "Proceed without any special action"
			"There is no record with unique id \"~A\"; impossible to undocument it."
			unique-id))
	       (unique-index
		(cerror "Proceed without any special action"
			"There is no record with unique index ~A; impossible to undocument it."
			unique-index))))
	(t
	 ;; this wants to remove the published record as well, as this is the function
	 ;; called by patching.
1	 0(remove-record-group-as-caller-from-all-callees record-group)
	 (make-record-group-inaccessible-to-ui record-group))))

;; When the editor has a way to create brand new legitimate records,
;; it should call another function which hasn't been written yet.
(defun 1find-record-for-topic-and-type0 (topic type record-status
				       &key create-p unique-id (version-number 0)
				       supersede-topic-if-different
				       install-name-p
				       &aux unique-index)
  ;; unique-index is an aux for the time being because I don't know if Mike
  ;; wants it to be a keyword arg as well
  (setq type (coerce-record-type type 'external))
  (unless version-number (setq version-number 0))
  (flet ((extract-appropriate-record (record-group)
	   (ecase record-status
	     (:installed (record-group-installed-record record-group))
	     (:edited (find version-number (record-group-edited-records record-group)
			    :key #'doc-record-version-number :test #'=))
	     (:published (record-group-published-record record-group)))))
    (let* ((record-group (find-record-group-for-topic-and-type topic type unique-id create-p
							       unique-index
							       supersede-topic-if-different
							       install-name-p))
	   (existing-record
	     (and record-group
		  (if (listp record-group)
		      (loop for rg in record-group
			    when (extract-appropriate-record rg)
			      collect it)
		      (extract-appropriate-record record-group)))))
      (let ((record
	      (or existing-record
		  (and create-p
		       (let ((new-record (create-record
					   :record-group record-group :topic topic :type type
					   :version-number version-number)))
			 (ecase record-status
			   (:installed
			     (setf (record-group-installed-record record-group) new-record))
			   (:edited
			     (push new-record (record-group-edited-records record-group)))
			   (:published
			     (setf (record-group-published-record record-group) new-record)))
			 new-record)))))
	(when supersede-topic-if-different
	  (setf (doc-record-name record) topic))
	record))))

(defun 1find-record-group-for-topic-and-type0 (topic type
					     &optional unique-id create-p unique-index
					     supersede-topic-if-different install-name-p)
  (when (null type)
    ;---184--- is this really right?  Seems insane to me.  Is this two functions rolled
    ;into one?
    (return-from find-record-group-for-topic-and-type
      (topic-record-groups topic)))
  (setq type (coerce-record-type type 'external))
  (let ((prop-type (coerce-record-type type 'property)))
    (labels ((install-name (record-group)
	       (maybe-expand record-group)
	       (when install-name-p
		 (setf (record-group-name-installed-p record-group) t)))
	     (add-name-to-completion-table (rg)
	       ;; put the record group into the completion
	       ;; table as well, because we must be able to 
	       ;; find it later!
	       (si:aarray-insert *topic-aarray*
				 (record-group-topic-completion rg) rg))

	     (maybe-expand (record-group)
	       (when (and create-p unique-id)
		 (setq record-group
		       (expand-compressed-record-group record-group
						       :unique-id unique-id)))))
      (cond ((and (null unique-id) (null unique-index))
	     (or (topic-record-group topic prop-type)
		 (and create-p
		      (let ((record-group
			      (make-instance 'record-group
					     :topic topic :type type
					     :unique-id (generate-record-unique-id
							  :validity
							  (ecase create-p
							    ((T) :bogus)
							    ((:valid :undefined-reference
							      :bogus) create-p))))))
			(let ((unique-id-from-record-group
				(record-group-unique-id record-group)))
			  (setf (lookup-unique-id-registry unique-id-from-record-group)
				record-group))
			(setf (record-group-name-installed-p record-group) install-name-p)
			(add-name-to-completion-table record-group)
			record-group))))
	    (T (multiple-value-bind (record-group there?)
		   (lookup-unique-id-registry unique-id)
		 (when (and (not there?) unique-index)
		   (setq record-group (index-compressed-record-group unique-index)
			 there? :compressed))
		 (cond (there?
			(cond ((record-group-topic-and-type-match record-group topic type)
			       (install-name record-group))
			      (T
			       ;; The topic&type in the record group differs from that
			       ;; supplied by the caller.  Perhaps the record was renamed and
			       ;; the caller's information was outdated.
			       ;; First check to see if types match and one topic is a phony
			       ;; function spec that looks like the other topic.  Can happen
			       ;; when a package is created or a symbol exported after the doc
			       ;; is loaded, for instance.
			       ;;---Perhaps take out this warning when we no longer
			       ;; enforce the requirement that topic&type be unique
			       ;;--- Now, only warn when the name for the record group
			       ;;    is "installed"
			       ;; Remove this warning for the time being (1/15/88) because
			       ;; there might be "old names" in references that get
			       ;; loaded (3 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")after0 the record group name gets installed
			       ;; and they should just quietly find the right record group.
			       ;; Unique-IDs are unique, right? -- doughty
			       ;; --- Note that a warning SHOULD be generated if 
			       ;; supersede-topic-if-different is T and the name is already
			       ;; installed, but hopefully the warning about the record
			       ;; being installed from the wrong place will suffice.
			       #+ignore
2			       (when (and (not supersede-topic-if-different)
					  ;; allowed to change the name of a record in a patch
					  ;; file.
					  (record-group-name-installed-p record-group))
				 (let ((rg-topic (record-group-topic record-group))
				       (rg-type (record-group-type record-group)))
				   (unless (and (eql (coerce-record-type type 'property)
						     (coerce-record-type rg-type 'property))
						(or (and (typep rg-topic 'phony-function-spec)
							 (eql rg-topic (lookalike-phony-function-spec
									 topic)))
						    (and (typep topic 'phony-function-spec)
							 (eql topic (lookalike-phony-function-spec
								      rg-topic)))))
				     (warn 
				       "The record group ~s,
  found properly by using unique-id supplied by the caller,
  has topic&type which don't match those provided as a courtesy by the caller,
  which were ~s ~s.
  This may only indicate that the record has been renamed."
				       record-group topic type))))

0			       (when supersede-topic-if-different
				 ;; May have been created earlier via a reference, which need
				 ;; not have had the latest name.
				 ;; Must remove the old name first!
				 (si:aarray-delete-by-name
				   *topic-aarray*
				   (record-group-topic-completion record-group))
				 (setf (record-group-topic record-group) topic)
				 (add-name-to-completion-table record-group)
				 )
			       (install-name record-group)))
			(when (eq there? :compressed)
			  (maybe-expand record-group))
			record-group)
		       (T
			(let ((record-group (topic-record-group topic prop-type)))
			  (cond (record-group
				 (install-name record-group)
				 (ecase (unique-id-validity
					  (record-group-unique-id record-group))
				   (:bogus
				     ;; If caller gives us a non-bogus uid for this record
				     ;; group, put it into the record group.
				     (cond ((eql (unique-id-validity unique-id) :bogus)
					    (break "The caller's bogus uid didn't map to a ~
                                                  record group,~@
					          but caller's courtesy topic&type did map ~
                                                  to a bogus record group"))
					   (T
					    (setf (record-group-unique-id record-group)
						  unique-id)
					    (setf (lookup-unique-id-registry unique-id)
						  record-group)
					    record-group)))
				   (:undefined-reference
				     ;; This record was an undefined reference.  If the caller's
				     ;; uid is "stronger", put it into the rg.  And,
				     ;; put the rg into the uid registry under the caller's uid.
				     (ecase (unique-id-validity unique-id)
				       ((:valid)
					(setf (record-group-unique-id record-group)
					      unique-id)
					(setf (lookup-unique-id-registry unique-id)
					      record-group))
				       ((:undefined-reference :bogus)
					;; We don't want to fiddle with the record if
					;; the caller's uid was not explicitly valid.
					;; But we do put it into the uid registry so we
					;; can find it easier next time.
					(setf (lookup-unique-id-registry unique-id)
					      record-group)
					record-group)))
				   (:valid
				     ;; This is anomalous, we think ---
				     ;; Imagine loading a caller which has a forward
				     ;; reference.  This looks that up by topic&type
				     ;; but finds another record group with the same
				     ;; topic&type.
				     (ecase (unique-id-validity unique-id)
				       (:valid
					 (cond ((string-equal
						  unique-id
						  (record-group-unique-id record-group))
						;; this is EXTRAORDINARILY anomalous.  This
						;; means that the unique id we were given
						;; wasn't registered in the registry but the
						;; record-group was still accessible via topic
						;; and type
						(when *debugging-sage*
						  (cerror "Use the record group found from the topic and type anyway"
							  "Internal error -- the unique id we were given wasn't registered in the
registry but the record-group was still accessible via topic and type.")))
					       (t
						;; this is also anomalous.  This means that
						;; there is a conflict between the seemingly
						;; valid unique id we were given and the
						;; valid one from topic & type.
						;; Further thought indicates that this
						;; happens when there are two different records
						;; with the same name (but different ids)
						;; which probably happened because the same
						;; name exists in two different layered 
						;; products.  Since today (1/15/88) we can't
						;; support multiple record groups with the
						;; same name, give a better error message:
						(cerror "Supersede the installed record, making it inaccessible"
							"The record ~A~@[, previously defined by ~A,~]
is being redefined.  Multiple records with the same name and type are not supported."
							record-group
							(and (record-group-published-record
							       record-group)
							     (doc-record-source-file
							       (record-group-published-record
								 record-group))))
						)))
				       ;; just return the valid record group in the
				       ;; undefined-reference case
				       ((:undefined-reference :bogus) nil))
				     record-group)))
				(T (and create-p
					(let ((record-group
						(make-instance 'record-group
							       :topic topic
							       :type type
							       :unique-id unique-id)))
					  (setf (lookup-unique-id-registry unique-id)
						record-group)
					  (setf (record-group-name-installed-p record-group)
						install-name-p)
					  ;; put the record group into the completion
					  ;; table as well, because we must be able to 
					  ;; find it later!
					  (add-name-to-completion-table record-group)
					  record-group)))))))))))))

(defun 1assure-record-group-unique-id-valid0 (record-group)
  (ecase (unique-id-validity (record-group-unique-id record-group))
    ((:bogus :undefined-reference)
     (let ((unique-id (generate-record-unique-id :validity :valid)))
       (setf (record-group-unique-id record-group) unique-id)
       (setf (lookup-unique-id-registry unique-id) record-group)))
    (:valid ))
  record-group)

(defun 1one-time-assign-unique-ids0 ()
  (maphash-noting-progress
    (named-lambda map-over (uid record-group)
      (ecase (unique-id-validity uid)
	((:bogus)
	 (let ((uid (generate-record-unique-id
		      :validity 
		      (if (find-record-for-lookup record-group)
			  :valid :undefined-reference))))
	   (setf (record-group-unique-id record-group) uid)
	   (setf (lookup-unique-id-registry uid) record-group)))
	((:valid :undefined-reference)
	 )))
    *unique-idrecord-group-registry*
    "Assigning unique IDs"))

;(defun check-unique-id-assignments ()
;  (let ((bogoids ())
;	(undefs ())
;	(number-of-valids 0))
;    (map-over-topic&type-registry
;      (named-lambda map-over (topic type record-group)
;	(ecase (unique-id-validity (record-group-unique-id record-group))
;	  ((:bogus) (push (list topic type) bogoids))
;	  ((:undefined-reference)
;	   (push (list topic type) undefs))
;	  (:valid (incf number-of-valids))))
;      "Checking unique IDs")
;    (format T "~&There are ~d valid records" number-of-valids)
;    (when bogoids
;      (format T "~&YOU HAVE ~d BOGOID~@(~:p~)!!" (length bogoids))
;      ;(mapc #'print bogoids)
;      )
;    (when undefs
;      (format T "~3&(for your information) There are ~d undefined forward references:"
;	      (length undefs))
;      (mapc #'print undefs))
;    `(valid ,number-of-valids bogoid ,(length bogoids) undef ,(length undefs))))

#||
2;; Pre-record-group version
;; When the editor has a way to create brand new legitimate records,
;; it should call another function which hasn't been written yet.
(defun find-record-for-topic-and-type (topic type &optional unique-id)
  (cond ((null unique-id)
	 (multiple-value-bind (record there?)
	     (lookup-topic&type-registry topic type)
	   (if there?
	       record
	       (create-record :topic topic
			      :type type
			      :unique-id (generate-record-unique-id :validity :bogus)))))
	(T (multiple-value-bind (record there?)
	       (lookup-unique-id-registry unique-id)
	     (cond (there?
		    (cond ((doc-record-topic-and-type-match record topic type)
			   record)
			  (T
			   ;; The topic&type in the record differs from that supplied
			   ;; by the caller.  Perhaps the record was renamed and the caller's
			   ;; information was outdated
			   ;;---Perhaps take out this warning when we no longer
			   ;; enforce the requirement that topic&type be unique
			   (break
			     "The record ~s found properly by using unique-id supplied ~@
			       by the caller has topic&type, ~s,~@
			       which don't match that provided as a courtesy by the caller.~@
			       <Resume> will use the record anyway."
			     record (list topic type))
			   record)))
		   (T
		    (multiple-value-bind (record there?)
			(lookup-topic&type-registry topic type)
		      (cond (there?
			     (cond ((eql (unique-id-validity
					   (doc-record-unique-id record))
					 :bogus)
				    ;; If caller gives us a non-bogus uid for this record,
				    ;; put it into the record.
				    (cond ((eql (unique-id-validity unique-id) :bogus)
					   (break "The caller's bogus uid didn't map to a record,~@
					    but caller's courtesy topic&type did map to a bogus record"))
					  (T
					   (setf (doc-record-unique-id record) unique-id)
					   (setf (lookup-unique-id-registry unique-id)
						 record)))
				    record)
				   (T
				    ;; This is anomalous, we think ---
				    ;; Imagine loading a caller which has a forward
				    ;; reference.  This looks that up by topic&type
				    ;; but finds another record with the same topic&type.
				    (break "The caller's uid didn't map to a record,~@
					    but caller's courtesy topic&type did")
				    record)))
			    (T (create-record :topic topic
					      :type type
					      :unique-id unique-id))))))))))
0||#

(defun 1create-record0 (&key topic type (record-group () record-group-p) (version-number 0))
  (unless record-group-p
    (error "Caller must provide record group"))
  (unless version-number (setq version-number 0))
  (let ((record (make-instance (if (lisp-object-type-p type)
				   'lisp-record
				   'concept-record)
			       :name topic
			       :source-type (coerce-record-type type 'external)
			       :record-group record-group
			       :version-number version-number)))
    record))

;;; Rules:

;;; There is no "reader" or "writer" mode, by default.  The default mode is
;;; to use the newest edited record (installed record) if there is one, else use
;;; the published record.

;;; There is a mode in which you can require only published record be used, but this
;;; is 3not0 the default.  There is also a mode in which you can require that the
;;; sab file containing this record be read in if it hasn't been already, but this, too,
;;; is 3not0 the default.
(defvar 1*record-lookup-mode*0 :normal
  "One of :normal, :use-published-record, :edit-newest-record")

(export '(*record-lookup-mode*))

;; (defun 1patch-file-convert-record-lookup-mode0 ()
;;   (setq *record-lookup-mode*
;; 	(ecase *record-lookup-mode*
;; 	  (:reader ':normal)
;; 	  (:writer
;; 	    (ecase *record-lookup-default-action*
;; 	      (:use-published-record ':normal)
;; 	      (:edit-newest-record ':edit-newest-record)
;; 	      (:warn ':normal))))))


(defflavor 1lookup-record-not-found
0	(record-group)
	(error)
  (:initable-instance-variables record-group)
  (:required-init-keywords :record-group))

(defmethod 1(dbg:report lookup-record-not-found)0 (stream)
  (format stream "For ~A ~A, no record suitable for documentation lookup was found."
	  (namespace-type-string record-group)
	  (appropriate-title-rendering record-group 'no-formatting)))

(compile-flavor-methods lookup-record-not-found)

;;; Set to another function by NWT
(defvar 1*record-for-lookup-finding-function*0 'find-record-for-lookup-nsage)

(defun 1find-record-for-lookup0 (record-group &rest keywords-and-values)
  (declare (arglist record-group &key error-p loading-contents))
  (apply *record-for-lookup-finding-function* record-group keywords-and-values))

(defmethod 1(find-record-for-lookup-nsage record-group)0 (&key error-p loading-contents)
  (ignore loading-contents)
  (when (eq *record-lookup-mode* ':edit-newest-record)
    (cerror "Reset *record-lookup-nwt-mode* to :NORMAL and continue."
	    ":EDIT-NEWEST-RECORD is an invalid value for *record-lookup-mode*, because ~@
             you don't have Concordia loaded.")
    (setq *record-lookup-mode* ':normal))
  (let ((record (or installed-record published-record)))
    (if (and (null record) error-p)
	(signal 'lookup-record-not-found :record-group self)
	record)))

;; This will supersede record-for-topic&type.  
;; It reads doc contents from file system if necessary, like the old one.
;; This function will soon be obsolete.  All its current callers will
;; soon have a record, not a topic and type.
(defun 1doc-record-for-record-group0 (record-group &optional (monitor t))
  (let ((record
	  (or (find-record-for-lookup record-group :loading-contents t)
	      (let ((new-record (create-record
				  :record-group record-group
				  :topic (record-group-topic record-group)
				  :type (record-group-type record-group))))
		(setf (record-group-installed-record record-group) new-record)))))
    (when monitor
      ;;---THIS FAILS TO MONITOR LOOKUP log-lookup-event etc.
      #+ignore
      (initialize-formatter-variables-for-record record))
      (find-doc-record-contents record :installed)
    record))

#||
2(defgeneric (4 0 (NIL 0) (NIL :BOLD :SMALL) "TVFONTCB")initialize-formatter-variables-for-record2 (doc-record)
  (:method-combination :progn))

(defmethod 4(initialize-formatter-variables-for-record doc-record)2 ()
  (setq *sage-expansion-history* (ncons record-group))
  )

(defmethod 4(initialize-formatter-variables-for-record concept-record)2 ()
  (setq *inhibit-numbering* nil)		;decide if numbering is OK
  )

(defmethod 4(initialize-formatter-variables-for-record lisp-record)2 ()
  (setq *inhibit-numbering* t)			;decide if numbering is OK
  )
0||#

(defmethod 1(find-doc-record-contents doc-record)0 (record-status)
  (unless (and (doc-record-filled self)
	       (not (doc-record-contents-bogus self)))
    (let ((doc-string))
      (cond ((not (null disk-location))		;---source-file?
	     (fill-doc-record-contents-from-disk self record-status))
	    ((not (null (setq doc-string
			      (ignore-errors
				;; Well, if there were errors, we couldn't get the
				;; documentation, then, could we?  This attempt
				;; at pre-Sage compatibility shouldn't force
				;; users into the debugger.
				(documentation
				  name
				  (or (get (coerce-record-type source-type 'property)
					   'lisp-type)
				      'defun))))))
	     (fill-doc-record-bogus-contents self :doc-string record-status doc-string))
	    ;;---This has the effect of making all bogus documentation, like
	    ;;unknown references, show up as "offline", since they are all "not
	    ;;available".  FILL-DOC-RECORD-CONTENTS-FROM-DISK looks for the
	    ;;file and creates an "offline" bogus record if it doesn't find it.
	    ;;This seems right; but then I don't know what the point of the
	    ;;"available" flag is.
	    ;((not (doc-record-available self))
	     ;(fill-doc-record-bogus-contents self :doc-off-line record-status))
	    (t (fill-doc-record-bogus-contents self :no-doc-available record-status))))))

(defmethod 1(fill-doc-record-bogus-contents doc-record)0 (contents-type record-status
								      &optional raw-contents)
  ;;--- source-topic?
  (let ((bogus-contents
	  (convert-@-to-directives
	    (doc-record-computed-contents-list self contents-type raw-contents)
	    t)))
    (fill-doc-record-computed-contents
      self record-status (if (consp bogus-contents) bogus-contents (list bogus-contents)))
    (setf (doc-record-contents-bogus self) t)))

(defmethod 1(fill-doc-record-computed-contents doc-record)0 (record-status contents-list)
  (setq contents (make-record-field
		   self record-status contents-list))
  (setf (doc-record-filled self) t))

(defgeneric 1doc-record-computed-contents-list0 (doc-record contents-type &optional raw-contents)
  (:method-combination :case))

(defmethod 1(doc-record-computed-contents-list doc-record :doc-string)0 (&optional raw-contents)
  `(@ list
    ,*one-newline*
    "For "
    ,(string-downcase (namespace-type-string record-group)) " "
    ,(appropriate-title-rendering record-group 'no-formatting)	;---
    ", only a documentation string was found:"
    ,*two-newlines*
    (@ verbatim ,raw-contents)))

(defmethod 1(doc-record-computed-contents-list doc-record :doc-off-line)
0	   (&optional raw-contents)
  (ignore raw-contents)
  (let* ((documents (zwei:find-topic-documents record-group))
	 (document-names
	   (mapcar #'(lambda (document)
		       (appropriate-title-rendering document 'formatting))
		   documents)))
    `(@ list
      ,*one-newline*
      "Documentation for "
      ,(string-downcase (namespace-type-string record-group)) " "
      ,(appropriate-title-rendering record-group 'no-formatting)
      " is offline."
      ,*two-newlines*
      ,(cond ((document-p record-group)
	      "This is itself a document.")
	     ((> (length documents) 0)
	      `(@ list "It appears in document" ,(if ( (length documents) 1) "s: " ": ")
		(@ i
		 ,@(loop for comma = () then ", "
			 for dtopic in document-names
			 when comma collect it
			 append dtopic)) "."))
	     (T `(@ list "It does not currently appear in any document.")))
      ,@(when (not (null disk-location))
	  `(,*two-newlines*
	    ,(format nil "The file ~a must be available in order to make this topic ~
                          accessible online.  Install that file from distribution tape ~
                          (or other source)."
		     (disk-location-pathname self)))))))

(defmethod 1(doc-record-computed-contents-list doc-record :no-doc-available)
0	   (&optional raw-contents)
  (ignore raw-contents)
  `(@ list
    ,*one-newline*
    "No documentation available for "
    ,(string-downcase (namespace-type-string record-group)) " "
    ,(appropriate-title-rendering record-group 'no-formatting)
    "."))
  
(defmethod 1(fill-doc-record-contents-from-disk doc-record)0 (record-status)
  (condition-case ()
       ;;---If we ever allow pointy hands, etc., in sab files, we would
       ;; have to either read the file index info at this point to get
       ;; the file attribute list, or store the attribute list with each
       ;; record.  In either case, we'd have to do file-attribute-bindings here
       ;; and canonicalize-record-contents.  This doesn't apply to edited records.
       (destructuring-bind (ignore file-topic file-type field-alist)
	   ;; Warning!  The following destructuring-bind is guaranteed to fail if given a
	   ;; disk-location of nil.  I don't know if this method will ever get called with
	   ;; a null disk-location.  It doesn't seem to have failed up to now.  (mcw)
	   (destructuring-bind (pathname start-byte end-byte)
	       (first disk-location)
	     (with-document-and-device-types ()
	       (keeping-sage-files
		 (read-sab-record (open-sage-file pathname)
				  start-byte
				  (- end-byte start-byte)))))
	 (ignore file-topic file-type)		;--- could verify against slots of self
	 (process-fields-from-sab self field-alist record-status)
	 (setf (doc-record-contents-bogus self) ())
	 (setf (doc-record-filled self) T))
     (fs:file-not-found
       (fill-doc-record-bogus-contents self :doc-off-line record-status))))

;;; This is what the editor uses when reading a sequence of records from a sab file
(defmethod 1(force-fill-doc-record-contents-from-disk doc-record)0 (record-status)
  #||
  (when (eq installed-record self)	;this is the installed record
    (setq installed-record (clone-record-contents self)))
  ||#
  (fill-doc-record-contents-from-disk self record-status))

(defmethod 1(process-fields-from-sab doc-record)0 (sab-fields record-status)
  (setq fields ())
  (with-file-attributes-from-sab-field-if (eql record-status :edited) sab-fields
    (loop for (field-name field-contents) in sab-fields
	  unless (eq field-name 'file-attribute-string)
	    do (process-field-from-sab self field-name field-contents record-status)))
  (setq fields (nreverse fields)))

(defgeneric 1process-field-from-sab0 (doc-record field-name field-contents record-status)
  (:method-combination :case)
  )

(defmethod (process-field-from-sab doc-record 1:otherwise0)
	   (field-name field-contents record-status)
  (ignore record-status)
  ;;nreverse above
  (when field-contents
    (push (list field-name (upgrade-sage-contents-list-for-newthink
			     field-contents record-status self))
	  fields)))

;; These might just become ignore
(defmethod (process-field-from-sab doc-record 1topic0) (field-contents record-status)
  (ignore field-contents record-status)
  (error "It seems bogus to find TOPIC in sab contents"))
(defmethod (process-field-from-sab doc-record 1type0) (field-contents record-status)
  (ignore field-contents record-status)
  (error "It seems bogus to find TYPE in sab contents"))

(defmethod (process-field-from-sab doc-record 1source-topic0) (field-contents record-status)
  ;; See the commentary near the method (doc-record-source-topic doc-record)
  (setq source-topic (shrink-record-field
		       (upgrade-sage-contents-list-for-newthink
			 field-contents record-status self))))

(defmethod (process-field-from-sab doc-record 1oneliner0) (field-contents record-status)
  (setq oneliner (make-record-field self record-status field-contents)))

(defmethod (process-field-from-sab doc-record 1keywords0) (field-contents record-status)
  (setq keywords
	(make-record-field self record-status field-contents)))

(defmethod (process-field-from-sab doc-record 1tokens0) (field-contents record-status)
  (ignore record-status)
  (setq tokens (canonicalize-tokens field-contents)))

(defmethod (process-field-from-sab doc-record 1callee-list0) (field-contents record-status)
  (ignore record-status)
  (add-callees-from-field-alist self field-contents))

(defmethod (process-field-from-sab doc-record 1modification-history0)
	   (field-contents record-status)
  ;;--- Probably not needed when you look up documentation, so install only for edited
  ;;records.
  (when (eql record-status :edited)
    (setq modification-history field-contents)))

;; From old sab files
(defmethod (process-field-from-sab doc-record 1callees0) (field-contents record-status)
  (ignore record-status)
  (add-callees-from-field-alist self field-contents))

(defmethod (process-field-from-sab doc-record1 contents0)
	   (field-contents record-status)
  (setq contents
	(make-record-field self record-status field-contents)))

(defmethod (process-field-from-sab doc-record 1document-type0) (field-contents record-status)
  (ignore record-status)
  (setq document-type field-contents))

(defmethod (process-field-from-sab doc-record1 patched-from0) (field-contents record-status)
  (ignore record-status)
  (setq source-file (fs:parse-pathname field-contents)))

;; If these appear useful, they could be moved from fields to instance vars.
;; 1releasenumber

0(defmethod (process-field-from-sab doc-record 1related0) (field-contents record-status)
  (when field-contents
    (push (list 'related (make-record-field self record-status field-contents))
	  fields)))

(defmethod (process-field-from-sab doc-record1 notes0) (field-contents record-status)
  (when field-contents
    (push (list 'notes (make-record-field self record-status field-contents))
	  fields)))

;;; Lisp record stuff

;;; This method just for compatibility with old SAB files
(defmethod (process-field-from-sab lisp-record-type-mixin1 operation0)
	   (field-contents record-status)
  (setq contents (make-record-field self record-status field-contents)))

(defmethod (process-field-from-sab lisp-record-type-mixin1 arglist0)
	   (field-contents record-status)
  (setq arglist (make-record-field self record-status field-contents)))

;;; Concept record stuff

;;;---For compatibility with old sab files
(defmethod (process-field-from-sab concept-record-type-mixin1 title0)
	   (field-contents record-status)
  (process-field-from-sab self 'source-title field-contents record-status))

(defmethod (process-field-from-sab concept-record-type-mixin1 source-title0)
	   (field-contents record-status)
  (setf (doc-record-source-title self)
	(when field-contents
	  (make-record-field self record-status
			     (upgrade-sage-contents-list-for-newthink
			       field-contents record-status self)))))

(defmethod (process-field-from-sab concept-record-type-mixin1 abbrev0)
	   (field-contents record-status)
  (ignore record-status)
  (setq abbrev field-contents))

#||
2;; This should probably be unnecessary after it's used in a patch
;; But don't do more than comment it out because it's needed every so often.
(defun fix-up-all-source-title-fields ()
  (map-over-topic&type-registry
    (named-lambda map-over (ignore ignore record-group)
      (when record-group
	(flet ((fix-record (record)
		 (when (typep record 'concept-record)
		   (macrolet ((fixit (accessor)
				`(let ((x (,accessor record)))
				   (when (consp x)
				     (setf (,accessor record)
					   (make-record-field-internal record x))))))
		     (fixit doc-record-source-title)))))
	  (fix-record (record-group-installed-record record-group))
	  (fix-record (record-group-published-record record-group))
	  (mapc #'fix-record (record-group-edited-records record-group)))))
    "Fix up all source-title record fields"))
0||#

;;;============================================================
;;; Converting character-style markup to character styles in the strings
;;; Converting strings to sage-text-structures, and installing superior pointers (genealogy)
;;;============================================================

;;; The caller has to pass in a superior structure when thing is a list.  Otherwise, none
;;; of the elements of the list will have a superior.  Of course, some callers
;;; (e.g. the source-topic field contents list) may decide that the things in that
;;; contents list don't want to have a superior.
(defun 1upgrade-sage-contents-list-for-newthink0 (thing record-status &optional superior)
  (case record-status
    (:edited
      (typecase thing
	(cons (setq thing (enstyle-text-list thing () record-status)))
	(sage-directive (introduce-character-style-from-envr thing record-status))
	(otherwise )))

    (otherwise
      (setq thing
	    (typecase thing
	      (cons (destyle-text-list thing))
	      (sage-directive (destyle-text-list (ncons thing)))
	      (otherwise thing)))))
  (if (listp thing)
      (setq thing (upgrade-data-structure-list thing superior))
      (progn
	(unless (null superior)
	  (error "A superior shouldn't have been passed when the first argument is a markup structure.
The structure will be the superior of any of its inferiors."))
	(setf (directive-inferiors thing)
	      (upgrade-data-structure-list (directive-inferiors thing) thing))))
  thing)


;; This gets called only from nearly top level
(defgeneric 1introduce-character-style-from-envr0 (doc-record record-status)
  )

(defmethod 1(introduce-character-style-from-envr sage-directive :default)0 (record-status)
  (ignore record-status)
  self)

;; This is supposed to run before strings have been converted to sage-text-structures.
(defmethod 1(introduce-character-style-from-envr doc-record)0 (record-status)
  (setf (directive-inferiors self)
	(enstyle-text-list (directive-inferiors self) () record-status))
  self)

(defun 1enstyle-text-list0 (list character-style record-status)
  (when (eq record-status :edited)		;avoid useless enstyling
    (setq list
	  (merge-adjacent-sage-text-list
	    (loop for x in list
		  nconc (enstyle-text x character-style record-status)))))
  list)

(defgeneric 1enstyle-text0 (sage-directive character-style record-status)
  (:function
    (etypecase sage-directive
      (string
	(enstyle-text-string sage-directive character-style))
      (sage-directive
	(funcall (flavor:generic enstyle-text) sage-directive character-style
		 record-status)))))

;; Each character of 3string0 has its style changed to (not merged against)3 character-style
0(defun 1enstyle-text-string0 (string character-style)
  (list (if character-style
	    (si:change-string-character-style string character-style)
	    string)))

(defmethod 1(enstyle-text sage-text-structure)0 (character-style record-status)
  (ignore record-status)
  (when character-style
    (zwei:merge-style-interval-internal interval nil t character-style))
  (list self))

(defmethod 1(enstyle-text sage-envr)0 (character-style record-status)
  (labels ((recurse (&optional (face () face-p))
	     (setf (directive-inferiors self)
		   (enstyle-text-list (directive-inferiors self)
				      (if face-p
					  (si:intern-character-style nil face nil)
					  character-style)
				      record-status))
	     (list self))
	   (redo-inferiors (face)
	     (let* ((new-character-style (si:intern-character-style () face ()))
		    (new-inferiors
		      (enstyle-text-list (directive-inferiors self) new-character-style
					 record-status)))
	       (cond ((every (lambda (x) (typep x '(or string sage-text-structure)))
			     new-inferiors)
		      new-inferiors)
		     (T (setf (directive-inferiors self) new-inferiors)
			(list self))))))
    (cond ((null envr-mods)
	   (let ((face (second (assoc envr-name *face-code-alist*))))
	     (cond (face
		    (redo-inferiors face))
		   ((eql envr-name 'LS)
		    (redo-inferiors (second (assoc 'L *face-code-alist*))))
;--- This needs to be fixed somehow.  Examples want most of their text
;    in typewriter face, but not at the cost of losing useful italics.
;		   ((eql envr-name 'example)
;		    (recurse (second (assoc 'T *face-code-alist*))))
		   (T (recurse)))))
;--- ditto
;	  ((eql envr-name 'example)
;	   ;; Hope the example doesn't fiddle with face codes or anything.
;	   (recurse (second (assoc 'T *face-code-alist*))))
	  (T (recurse)))))

(defmethod 1(enstyle-text sage-command)0 (character-style record-status)
  (enstyle-sage-command-text self character-style record-status))

(define-sage-command-generic 1enstyle-sage-command-text0 (character-style record-status
									&optional copy-flags)
  (ignore character-style record-status)
  (cond ((and (eq record-status :edited)
	      #+Ignore
	      (not (command-has-any-keys-args-p self))
	      #+Ignore
	      (command-has-contents-list-args-p self))
	 (ncons (make-editable-sage-command self () copy-flags)))
	(t (list self))))

(defmethod 1(sage-command-arglist-pattern sage-command)0 ()
  (declare (values min-pos max-pos non-pos positionals keys any-keys list-of all))
  (let* ((directive-descriptor (lookup-command-descriptor command-name))
	 (arglist (when directive-descriptor (dd-arglist directive-descriptor))))
	  (extract-pattern arglist)))

(defmethod 1(sage-command-arglist-pattern editable-sage-command)0 ()
  (declare (values min-pos max-pos non-pos positionals keys any-keys list-of all))
  (let* ((directive-descriptor (lookup-command-descriptor command-name))
	 (arglist (when directive-descriptor (dd-arglist directive-descriptor))))
	  (extract-pattern arglist)))

(defmethod 1(command-has-contents-list-args-p sage-command)0 ()
  (multiple-value-bind (ignore ignore ignore positionals keys any-keys list-of all)
      (sage-command-arglist-pattern self)
    (macrolet ((arg-type (arg-spec)
		 `(second ,arg-spec))
	       (arg-name (arg-spec)
		 `(first ,arg-spec)))
      (flet ((return-if-contents-list-arg-p (arg)
	       (when (eq (arg-type arg) ':contents-list)
		 (return-from command-has-contents-list-args-p t))))
	(mapcar #'return-if-contents-list-arg-p positionals)
	(mapcar #'return-if-contents-list-arg-p keys)
	(mapcar #'return-if-contents-list-arg-p any-keys)
	(mapcar #'return-if-contents-list-arg-p list-of)
	(return-if-contents-list-arg-p all)))))

(defmethod 1(command-has-any-keys-args-p sage-command)0 ()
  (multiple-value-bind (ignore ignore ignore ignore ignore any-keys ignore ignore)
      (sage-command-arglist-pattern self)
    (not (null any-keys))))

(defmethod 1(make-editable-sage-command sage-command)0 (new-superior &optional copy-flags)
  (labels ((get-arg-stuff-default (arg-stuff)
	     (and (listp arg-stuff) (second arg-stuff)))
	   (get-arg-stuff-arg (arg-stuff)
	     (cond ((listp arg-stuff) (first arg-stuff))
		   (t arg-stuff))))
    (multiple-value-bind (ignore ignore ignore positionals keys any-keys list-of all)
	(sage-command-arglist-pattern self)
      (let ((editable-sage-command (make-editable-sage-command-internal command-name
									(if copy-flags
									    directive-flags
									    0)))
	    (fields ()))
	(setf (directive-superior editable-sage-command) new-superior)
	(when (and list-of any-keys)
	  (error "We can't handle both &list-of and &any-keys at the same time.  Please report this error."))
	(labels ((make-contents-list-field (contents-list name)
		   (let ((field (make-sage-command-contents-field-internal
				  editable-sage-command () name)))
		     (setf (directive-inferiors field)
			   (upgrade-sage-contents-list-for-newthink
			     contents-list :edited field))
		     (push field fields)))
		 (make-contents-list-all-field (contents-list)
		   (let ((upgraded-contents-list
			   (upgrade-sage-contents-list-for-newthink
			     contents-list :edited editable-sage-command)))
		     (setf (directive-inferiors editable-sage-command) upgraded-contents-list)
		     (return-from make-editable-sage-command editable-sage-command)))

		 (make-field (stuff type name)
		   (case type
		     (:contents-list (make-contents-list-field stuff name))
		     (otherwise
		       (let ((field (make-sage-command-arg-field
				      editable-sage-command 
				      type stuff name)))
			 (push field fields)))))
		 (arg-type (arg-spec) (second arg-spec)))
	  (cond (all
		 (let* ((arg (get-arg-stuff-arg (first all)))
			(default (first parameter)))
		   #+Ignore
		   (make-field default (second all) arg)
		   #-Ignore
		   (if (eq (second all) :contents-list) (make-contents-list-all-field default)
		       (make-field default (second all) arg))))
		(t
		 (let ((positional-parameters
			 (loop for temp in positionals
			       for parm in parameter
			       collect parm))
		       (non-positional-parameters
			 (nthcdr (length positionals) parameter)))
		   (labels ((arg-match (arg-name arg-spec)
			      (or (eql arg-name arg-spec)
				  (and (listp arg-spec)
				       (eql arg-name (first arg-spec)))))
			    (extract-positional-default (variable-name)
			      (nth (position variable-name positionals
					     :key #'car :test #'arg-match)
				   positional-parameters))
			    (extract-key-default (variable-name)
			      (cadr (assoc variable-name non-positional-parameters)))
			    (extract-list-of-default (variable-name)
			      (ignore variable-name)
			      ;; is this guaranteed to be right?
			      non-positional-parameters)
			    )
		     ;; first collect all positional values (experimentation shows that
		     ;; there is at most one)
		     ;; then collect key parameters
		     ;; then collect &list-of or &any-keys parameters
		   
		     ;; positionals
		     (loop for (arg-stuff type) in positionals
			   as arg = (get-arg-stuff-arg arg-stuff)
			   as default-present = (extract-positional-default arg)
			   as default = (or default-present
					    (get-arg-stuff-default arg-stuff))
			   do
		       (make-field default type arg))
		     ;; keys
		     (loop for (arg-stuff type) in keys
			   as arg = (get-arg-stuff-arg arg-stuff)
			   as default-present = (extract-key-default arg)
			   as default = (or default-present
					    (get-arg-stuff-default arg-stuff))
			   do
		       (make-field default type arg))
		   
		     ;;&list-of
		     (when list-of
		       (destructuring-bind (arg-stuff type) list-of
			 (let* ((arg (get-arg-stuff-arg arg-stuff))
				(default-present (extract-list-of-default arg))
				(default (or default-present
					     (get-arg-stuff-default arg-stuff))))
			   (make-field default `(:list-of ,type) arg))))
		   
		     ;;&any-keys
		     (when any-keys
		       (destructuring-bind (arg-stuff type) any-keys
			 (let* ((arg (get-arg-stuff-arg arg-stuff))
				(default-present (extract-list-of-default arg))
				(default (or default-present
					     (get-arg-stuff-default arg-stuff))))
			   (flet ((make-any-keys-field (keyword-name value)
				    (if (eq type :contents-list)
					(let ((field
						(make-sage-command-any-keys-contents-list-field
						  editable-sage-command value keyword-name
						  arg-stuff)))
					  (setf (directive-inferiors field)
						(upgrade-sage-contents-list-for-newthink
						  value :edited field))
					  field)
					(make-sage-command-any-keys-field
					  editable-sage-command keyword-name
					  type 
					  value
					  arg-stuff))))
			   (loop for thing in default
				 do
			     (let ((field (make-any-keys-field (first thing) (second thing))))
			       (push field fields)))
			   (push (make-sage-command-any-keys-field editable-sage-command
								   :new-one
								   type
								   ()
								   arg-stuff)
				 fields))))))))))
	(setf (directive-inferiors editable-sage-command) (nreverse fields))
	editable-sage-command))))

(define-sage-command-method 1(enstyle-sage-command-text L)
0			    (character-style record-status &rest ignore)
  (ignore character-style)
  (ecase record-status
    (:edited
      (destructuring-bind (thing)		;verify list of length 1
	 (enstyle-text 
	   (let ((*print-package* *package*)
		 (*print-readtable* *readtable*)
		 (*sage-print-base* *print-base*)
		 (*sage-read-base* *read-base*))
	     (display-string-from-L-command self))
	   (si:intern-character-style () (second (assoc 'L *face-code-alist*)) ())
	   record-status)
	(multiple-value-bind (at-left at-right) (pointy-hands-in-sage-symbol-face)
	  (list (string-append at-left thing at-right)))))
    ((:installed :published) (list self))))

(defun 1pointy-hands-in-sage-symbol-face0 ()
  (values '#,(symbol-for-editor-buffer 'open-L)
	  '#,(symbol-for-editor-buffer 'close-L)))

(define-sage-command-method (1enstyle-sage-command-text
0			      (tab-to-tab-stop collect-right-flushing collect-centering
					       em em-dash literal-space abbreviation-period))
			    (character-style record-status &rest ignore)
  (ignore character-style)
  (ecase record-status
    (:edited
      (list (make-string 1 :initial-element (symbol-for-editor-buffer command-name))))
    ((:installed :published)
     (list self))))

(define-sage-command-method 1(enstyle-sage-command-text literal-atsign)
0			    (character-style record-status &rest ignore)
  (ignore record-status)
  (list (make-string 1 :initial-element (make-character #\@ :style character-style))))

(defmethod 1(enstyle-text sage-directive :default)0 (character-style record-status)
  (ignore character-style record-status)
  (list self))

(defun 1merge-adjacent-sage-text-list0 (list)
  (let ((result ())
	(merging-what? ())
	(to-merge ()))
    (labels ((do-merger ()
	       (ecase merging-what?
		 (string
		   (unless (null to-merge)
		     (push (apply #'string-append (nreverse to-merge)) result)
		     (setq to-merge ())))
		 (sage-text-structure
		   (unless (null to-merge)
		     (push (merge-sage-texts (nreverse to-merge)) result)
		     (setq to-merge ())))
		 ((nil)
		  (unless (null to-merge)
		    (error "Merging any old thing?")))))
	     (new-state (state)
	       (unless (eq merging-what? state)
		 (do-merger)
		 (setq merging-what? state))))
      (dolist (item list)
	(typecase item
	  (sage-text-structure
	    (new-state 'sage-text-structure)
	    (push item to-merge))
	  (string
	    (new-state 'string)
	    (push item to-merge))
	  (otherwise
	    (new-state nil)
	    (push item result))))
      (new-state nil))
    (nreverse result)))

(defun 1merge-sage-texts0 (list)
  (let* ((new-sage-text-structure (first list))
	 (interval (sage-text-structure-interval new-sage-text-structure)))
    (dolist (text (rest list))
      ;;---Trailing newlines?
      (zwei:insert-interval (zwei:interval-last-bp interval)
			    (sage-text-structure-interval text)))
    new-sage-text-structure))

(defun 1canonicalize-contents-list0 (contents-list &optional superior)
  (assert (listp contents-list))
  (upgrade-data-structure-list
    (destyle-text-list
      (clone-contents-internal contents-list))
    superior))

(defun 1canonicalize-field-alist0 (field-alist &optional superior)
  (let ((field-name-to-sab-code-alist
	  ;; Avoid a compiler warning if this file gets compiled before sab-file
	  (locally (declare (special *field-name-to-sab-code-alist*))
	    *field-name-to-sab-code-alist*)))
    (mapcar (named-lambda each-field (pair)
	      (destructuring-bind (field-name field-contents) pair
		(let ((sab-dumper (third (assoc field-name field-name-to-sab-code-alist))))
		  (list field-name
			(if (eql sab-dumper 'write-sab-contents-list)
			    (if (typep field-contents 'record-field)
				(clone-record-field field-contents superior)
				(canonicalize-contents-list field-contents superior))
			    (clone-contents-internal field-contents))))))
	    field-alist)))

(defun 1destyle-text-list0 (list)
  (let* ((head (ncons nil))
	 (tail head))
    (dolist (thing list)
      (setq tail (destyle-text-nconc thing tail)))
    (cdr head)))

(defgeneric 1destyle-text-nconc0 (sage-directive tail)
  (:function
    (etypecase sage-directive
      (string
	(last (nconc tail (contents-list-from-fat-string sage-directive))))
      (sage-directive
	(funcall (flavor:generic destyle-text-nconc) sage-directive tail)))))

(defmethod 1(insert-returns-as-necessary sage-directive)0 (tail)
  ;; Look for continuation ticks "outside" sage-directive
  (let ((newlist (ncons self)))
    (when (and (maintains-connection-flags-p self)
	       (not (connected-to-previous-line self nil)))
      ;; if we clone 3this0 guy, we don't want to insert 3another0 CR!!
      (setf (connected-to-previous-line self nil) t)
      (push (make-sage-text-structure-from-string #\CR superior) newlist))
    (when (and (maintains-connection-flags-p self)
	       (not (connected-to-next-line self t)))
      (setf (connected-to-next-line self t) t)
      (nconc newlist (ncons (make-sage-text-structure-from-string #\CR superior))))
    (last (nconc tail newlist))))

(defmethod 1(destyle-text-nconc sage-directive :default)0 (tail)
  (insert-returns-as-necessary self tail))

(defmethod 1(destyle-text-nconc sage-envr)0 (tail)
  ;; Look for continuation ticks "inside" envr
  (when (directive-inferiors self)
    (let ((inferiors-newlist (destyle-text-list (directive-inferiors self))))
      (when (and (maintains-connection-flags-p self)
		 (not (connected-to-next-line self nil)))
	(setf (connected-to-next-line self nil) t)
	(push (make-sage-text-structure-from-string #\CR superior) inferiors-newlist))
      (when (and (maintains-connection-flags-p self)
		 (not (connected-to-previous-line self t)))
	(setf (connected-to-previous-line self t) t)
	(nconc inferiors-newlist
	       (ncons (make-sage-text-structure-from-string #\CR superior))))
      (setf (directive-inferiors self) inferiors-newlist)))
  (insert-returns-as-necessary self tail))

(defmethod 1(destyle-text-nconc sage-command)0 (tail)
  (case command-name
    (case
      (when parameter
	(setf parameter
	      (nconc (list (car parameter))
		     (loop for (clause contents) in (cdr parameter)
			   collect (list clause (destyle-text-list contents))))))
      (insert-returns-as-necessary self tail))
    (otherwise
      (insert-returns-as-necessary self tail))))


(defmethod 1(destyle-text-nconc sage-text-structure)0 (tail)
  (let ((list))
    (map-over-interval-substrings
      ;; map-over-interval-substrings takes care of change-old-to-new-symbols-for-editor-buffer
      interval
      (lambda (substring type)
	(ecase type
	  (:normal
	    (decoding-array (substring substring)
	      (let ((pending-text ()))
		(flet ((flush (substr through)
			 (when pending-text
			   (let ((inner-contents-list
				   (contents-list-from-fat-string
				     substr pending-text through)))
			     (dolist (item inner-contents-list)
			       (push (if (stringp item)
					 (make-sage-text-structure-from-string item superior)
					 item)
				     list)))
			   (setq pending-text ()))))
		  (dotimes (i (length substring))
		    (let* ((char (aref substring i))
			   (command
			     ;; The old scheme used different character styles, so use char= to compare.
			     ;; The new scheme uses a different character set, so ignoring style is
			     ;; the right thing.
			     (cond ((char= char (old-symbol-for-editor-buffer 'open-L))
				    (break "Failed to remove old symbol ~s" substring))
				   ((char-equal char '#,(symbol-for-editor-buffer
							  'tab-to-tab-stop))
				    'tab-to-tab-stop)
				   ((char-equal char '#,(symbol-for-editor-buffer
							  'collect-right-flushing))
				    'collect-right-flushing)
				   ((char-equal char '#,(symbol-for-editor-buffer
							  'collect-centering))
				    'collect-centering)
				   ((char-equal char '#,(symbol-for-editor-buffer 'em-dash))
				    'em)
				   ((char-equal char '#,(symbol-for-editor-buffer
							  'literal-space))
				    'literal-space)
				   ((char-equal char '#,(symbol-for-editor-buffer
							  'abbreviation-period))
				    'abbreviation-period)
				   (T ()))))
		      (cond (command
			     (flush substring i)
			     (push (make-sage-command command) list))
			    ((not pending-text)
			     (setq pending-text i)))))
		  (flush substring (length substring))))))
	  (:lisp
	    ;;--- Assumes environment (package, etc.) is correct
	    ;;--- If someone does @L("foo bar") then it gets converted to a fat string
	    ;; (character face sage::lisp) inside the @L command.
	    (push (make-sage-command 'L (ncons (parse-L-string substring))) list)))))
    ;;--- We could fix up the superiors here and avoid upgrade-data-structure-list later
    (last (nconc tail (nreverse list)))))

(defun 1upgrade-data-structure-list0 (list superior)
  (delete nil
	  (mapcar (lambda (item)
		    (if (stringp item)
			(upgrade-text-structure-item item superior)
			(upgrade-data-structure item superior)))
		  list)))

(defun 1upgrade-text-structure-item0 (item superior)
  (make-sage-text-structure-from-string item superior))

(defmethod 1(upgrade-data-structure sage-directive :default)0 (new-superior)
  (setq superior new-superior)
  self)

(defmethod 1(upgrade-data-structure sage-envr)0 (new-superior)
  (setq superior new-superior)
  ;; Inferiors are already in contents-list
  (setq contents-list (upgrade-data-structure-list contents-list self))
  self)

(defmethod 1(upgrade-data-structure sage-macro-call)0 (new-superior)
  (cond ((eq macro-name 'reference)
	 (let ((reference (make-instance
			    'sage-reference
			    :record-group (find-record-group-for-topic-and-type
					    (second (assoc 'topic macro-args))
					    (second (assoc 'type macro-args))
					    () ;;Old sage macro calls never have unique-ids
					    t)
			    :view (second (assoc 'view macro-args))
			    :field (second (assoc 'field macro-args)))))
	   (setf (directive-superior reference) new-superior)
	   reference))
	(t (setq superior new-superior)
	   self)))


;;;; Unique record id generation
(defvar 1*record-unique-id-counter*0 0)

(defvar 1*unique-id-time-encoding*
0	(concatenate 'string
		     (loop for c from (char-code #\A) to (char-code #\Z)
			   collect (code-char c))
		     "-+=@&%"))
(defvar 1*unique-id-char-validity*
0	(let ((arr (make-array 128 :element-type 'boolean)))
	  (map nil (lambda (char)
		     (setf (aref arr (char-code char)) T))
	       *unique-id-time-encoding*)
	  arr))

(defun 1unique-id-validity0 (unique-id)
  (check-type unique-id string)
  (cond ((aref *unique-id-char-validity* (char-code (aref unique-id 0)))
	 :valid)
	((char= (aref unique-id 0) #\?) :bogus)
	((char= (aref unique-id 0) #\*) :undefined-reference)
	(T (error "The uid is excessively bogus"))))

(defun 1generate-record-unique-id0 (&key (validity :valid))
  ;;.46sec/100
  (with-output-to-string (stream)
    (ecase validity
      (:valid )
      (:undefined-reference
	(write-char #\* stream))
      (:bogus
	(write-char #\? stream)))
    ;; since this encodes the real universal time, it could be reversed.
    (let ((encoding  *unique-id-time-encoding*))
      (declare (sys:array-register encoding))
      (loop with time = (time:get-universal-time)
	    for pos from 30 downto 0 by 5 do
	(write-char (aref encoding (ldb (byte 5 pos) time))
		    stream)))
    (write (without-interrupts
	     (setq *record-unique-id-counter*
		   ;; Zmail allows 10 per second.  Not enough?
		   (rem (1+ *record-unique-id-counter*) 1000.)))
	   :stream stream :pretty nil)
    (write net:*local-host* :escape nil :stream stream :pretty nil)))

(defun 1decode-unique-id0 (uid)
  (fresh-line)
  (let ((index 0))
    (case (aref uid 0)
      (#\? (write-string "Bogus ")
       (incf index))
      (#\* (write-string "Undefined reference ")
       (incf index)))
    (write-string "UID, created at ")
    (loop with time = 0
	  for index from index repeat 7
	  for char = (aref uid index)
	  for pos from 30 downto 0 by 5
	  do (setq time (deposit-byte time pos 5 (position char *unique-id-time-encoding*)))
	  finally (format t "~\\date\\" time))))

;;; ----------------

;;; All this stuff used to be in Concordia.

(defvar 1*use-record-group-index-as-unique-id*0 nil)

(defun 1record-group-unique-id-or-index0 (record-group)
  (or (and *use-record-group-index-as-unique-id*
	   (compressed-record-group-index record-group))
      (record-group-unique-id record-group)))

(defun 1make-callee-element0 (&key record-group view)
  (when (record-group-compressed-p record-group)
    (expand-compressed-record-group record-group))
  (list (record-group-topic record-group)
	(record-group-type record-group)
	view
	(record-group-unique-id-or-index record-group)))

;;; 1compute-doc-record-callees0 recursively descends through the record contents 
;;; looking for sage-reference structures, making callee-element structures for them.
;;; It uses :nconc method combination so flavor mixins can contribute callees found
;;; in record-type-specific fields (but perhaps we'll find no callees in arglist
;;; fields...).
(defgeneric 1compute-doc-record-callees0 (doc-record)
  (:method-combination :nconc)
  (:function
    (let ((callee-list (funcall (flavor:generic compute-doc-record-callees) doc-record)))
      (add-callees-from-field-alist doc-record callee-list)
      callee-list)))

(defmethod 1(compute-doc-record-callees doc-record)0 ()
  (nconc (callees-in-record-field contents)
	 (callees-in-record-field (doc-record-source-topic self))
	 (callees-in-record-field oneliner)
	 (mapcan (lambda (key)
		   (callees-in-record-field (second (assoc key fields))))
		 '(related))
	 (mapcan (lambda (key)
		   (callees-in-contents-list (second (assoc key fields))))
		 '())
	 ))

(defmethod 1(compute-doc-record-callees lisp-record-type-mixin)0 ()
  (nconc (callees-in-record-field arglist)))

(defmethod 1(compute-doc-record-callees concept-record)0 ()
  (nconc (callees-in-contents-list
	   (record-field-contents (doc-record-source-title self)))
	 (callees-in-contents-list abbrev)))

(defun 1callees-in-record-field0 (record-field)
  (and record-field
       (callees-in-contents-list (record-field-contents record-field))))

(defun 1callees-in-contents-list0 (contents-list)
  (mapcan #'sage-directive-callees contents-list))

(defgeneric 1sage-directive-callees0 (sage-directive)
  (:function
    (typecase sage-directive
      ;;---Perhaps remove this when we're sure that no contents list has strings
      (string ())
      (otherwise (funcall (flavor:generic sage-directive-callees) sage-directive)))))

(defmethod 1(sage-directive-callees sage-directive :default)0 ()
  ())

(defmethod 1(sage-directive-callees sage-envr)0 ()
  (callees-in-contents-list contents-list))

(defmethod 1(sage-directive-callees sage-macro-call)0 ()
  (when (member macro-name '(reference expand))	;---not really macros yet
    (error "Your reference is a macro call: ~s ~s" macro-name macro-args)
    #+Franz
(5 0 (NIL 0) (NIL NIL :SMALLER) "EINY7")    (let ((topic (second (assoc 'topic macro-args)))
	  (type (second (assoc 'type macro-args)))
	  (field (second (assoc 'field macro-args)))
	  (view (second (assoc 'view macro-args))))
      ;;---The (old) parser or someone seems to make some of these contents-lists.
      (when (and (consp topic) (= 1 (length topic))) (setq topic (first topic)))
      (when (and (consp type) (= 1 (length type))) (setq type (first type)))
      (let ((template-name			;---kludgy, works w/o templates now
	      (cond (field
		     (when (and (consp field) (= (length field) 1))
		       (setq field (first field)))
		     (cond ((consp field) 'expand)
			   ((or (string-search "operation" field)
				(string-search "contents" field))
			    'expand)		;---lacking view templates
			   (T 'crossref)))
		    (view
		     ;;---See remark for field above
		     (when (and (consp view) (= (length view) 1))
		       (setq view (first view)))
		     (cond ((or (symbolp view) (consp view)) view)
				((string-equal view "crossref") 'crossref)
				(T 'expand)))
		    (T 'expand))))
	(list `(,topic ,type ,template-name))))0))

;;;This routine is responsible for saying what kind of reference this is
;;;Every reference is either a crossref or some kind of view.
;;;In some old code, this routine took the law into its own hands and returned
;;;one of two things ('expand or 'crossref) somewhat arbitrarily.
;;;This made it difficult for other places in the code to make informed
;;;decisions about which callees to use in various contexts (like overviews).
(defmethod 1(sage-directive-callees sage-reference)0 ()
  (let ((template-name				;---kludgy, works w/o templates now
	  (cond (field
		 ;;When it is a list of several fields, treat it as 'expand for now
		 ;; because "list of fields" is an outmoded way of specifying a view
		 ;; and we can't guess which one they meant.
		 ;;Otherwise the field name is a legitimate view name.
		 (cond ((and (consp field) (> (length field) 1)) 'expand)
		       ((consp field) (first field))
		       ((symbolp field) field)
		       (T (error
			    "Expected the fields in the reference to be a symbol or list"))))
		(view
		 (cond ((symbolp view) view)
		       ((and (consp view) (= (length view) 1)) (first view))
		       ((string-equal view "crossref") 'crossreference)
		       ((string-equal view "expand") 'expand)
		       (T (error "Expected the view in the reference to be a symbol"))))
		;;When no view or field is specified in the reference, the default is 'expand
		(T 'expand))))
    (list (make-callee-element :record-group record-group :view template-name))))
