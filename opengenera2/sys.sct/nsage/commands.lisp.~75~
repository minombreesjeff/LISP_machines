;;; -*- Syntax: Common-lisp; Mode: LISP; Base: 10; Package: NSAGE; Lowercase: Yes -*-
;;;
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;

;;; Presentation types and commands.

(define-presentation-type general-documentation-printer ()
   :parser ((stream &key type initially-display-possibilities)
	    (let ((loc (send stream :read-location)))
	      (multiple-value-bind (object nil nil)
		  (dw:complete-input
		    stream
		    (lambda (string action)
		      (labels ((complete-name (str act)
				 (declare (sys:downward-function))
				 (let ((bar-idx (string-search-char #\| str)))
				   (if bar-idx
				       (let ((namespace
					       (neti:find-namespace-named
						 (substring str 0 bar-idx))))
					 (with-stack-list (net:*namespace-search-list*
							    namespace)
					   (complete-name (substring str (1+ bar-idx))
							  act)))
				       (dw:suggestion-completer (str :action act)
					 (net:keeping-namespace-server
					   (dolist (namespace net:*namespace-search-list*)
					     (neti:map-over-possible-object-name-completions
					       :printer str namespace
					       (lambda (name)
						 (let ((printer (net:find-object-named
								  :printer name)))
						   (when (sage-can-deal-with-printer printer)
						     (dw:suggest name printer))))))))))))
			(complete-name string action)))
		    :parser
		    (lambda (string)
		      (si:with-parse-ferror ((net:object-not-found
					       formatter-cant-deal-with-printer))
			(let ((printer (net:find-object-named :printer string)))
			  (unless (sage-can-deal-with-printer printer)
			    (signal 'formatter-cant-deal-with-printer :printer printer))
			  printer)))
		    :type type
		    :allow-any-input t
		    :help-offers-possibilities nil
		    :initially-display-possibilities initially-display-possibilities
		    :compress-choices nil
		    :partial-completers '(#\space))
		(dw::presentation-replace-input stream loc (send object :pretty-name))
		(values object 'general-documentation-printer))))
   :printer ((printer stream)
	     (write-string (send printer :pretty-name) stream))
   :description "a printer"
   :abbreviation-for '((and sys:printer
			    ((satisfies sage-can-deal-with-printer))))
   )

(define-presentation-type local-documentation-printer ()
   :parser ((stream &key type initially-display-possibilities)
	    (dw:complete-from-sequence (get-sage-printer-alist) stream
				       :name-key #'car :value-key #'cdr
				       :partial-completers `(#\Space)
				       :type type
				       :initially-display-possibilities
				       initially-display-possibilities))
   :description "a local printer")

(define-presentation-type documentation-printer ()
   :abbreviation-for '((or local-documentation-printer general-documentation-printer))
   :history t
   :printer ((printer stream) (write-string (send printer :pretty-name) stream))
   :description "a printer")

(define-presentation-type documentation-destination ((&key (include-screen t)))
   :history t
   :abbreviation-for `,(if include-screen
			   '((token-or-type (("Screen" . :screen)) documentation-printer))
			   'documentation-printer)
   :describer ((stream &key plural-count)
	       (ignore include-screen)
	       (write-string
		 (cond ((null plural-count) "a destination for formatted output")
		       ((eq plural-count t) "destinations for formatted output")
		       ((numberp plural-count)
			(format nil "~R destinations for formatted output" plural-count))
		       (T (format nil "~A destinations for formatted output" plural-count)))
		 stream)))



;---184--- I believe this is only used by @L.  I would have made that use present
;as a record-group-topic, but I wasn't sure I was allowed to change the package it uses
;to the dynamic one from the standard one.  Too much trouble to change now.
(define-presentation-type record-group-name ()
   :printer ((name stream)
	     (write-string (first name) stream)))

(defun record-group-topic-completion (record-group)
  (topic-completion (record-group-topic record-group)))

(defun topic-completion (topic)
  (when (sys:validate-function-spec topic)
    (loop
      (multiple-value-bind (parent type)
	  (sys:function-parent topic 'defun)
	(if (eq type 'defun)
	    (setf topic parent)
	    (return)))))
  (if (consp topic)
      (list-function-spec-completion topic)
      (typecase topic
	(string topic)
	(character (string topic))
	(symbol (string topic))
	(phony-function-spec (string topic))
	(otherwise nil))))

(defun list-function-spec-completion (topic)
  (with-output-to-string (stream)
    (with-standard-io-environment
      (write-char #\( stream)
      (prin1 (car topic) stream)
      (loop for thing in (cdr topic) do
	(write-char #\space stream)
	(if (keywordp thing)
	    (prin1 thing stream)
	    (princ thing stream)))
      (write-char #\) stream))))

(define-presentation-type record-group-topic ()
   :printer ((topic stream)
	     (if (stringp topic)
		 (write-string topic stream)
		 (prin1 topic stream)))
   )

(define-presentation-type record-group-type ()
   :printer ((type stream)
	     (if (and (concept-type-p type) (neq type 'fragment))
		 (write-string (coerce-record-type :sage-section-record 'print-name) stream)
		 (format stream "~:(~A~)" type)))
   )

(defun topic-record-groups (topic)
  (let ((topic-completion (topic-completion topic)))
    (when topic-completion
      (remove topic (rest (si:aarray-lookup topic-completion *topic-aarray*))
	      :test-not #'equalp :key #'record-group-topic))))

(defun topic-record-group (topic type)
  (find type (topic-record-groups topic)
	:key #'(lambda (record-group)
		 (coerce-record-type (record-group-type record-group) 'property))))

;;; Various cases:
;;;  Normal topic (Introduction to Using the Window System).
;;;  Global symbol (READ).
;;;  Unambiguous local symbol (DW:READ-CHAR-FOR-ACCEPT).
;;;  Duplicates, of which one is accessible (CL:LOOP and ZL:LOOP).
;;;  Duplicates, of which neither is accessible (CHAOS:MAKE-STREAM and TAPE:MAKE-STREAM).
;;;  More than one type for same topic (PRIN1 Function and PRIN1 Variable).
;;;  Normal topic with string-equal name to symbol (Trace and TRACE).
;;;  Message ((FLAVOR:METHOD :READ-CURSORPOS TV:SHEET)).
;;;  Funny syntax (ZL:\)?
;;; Maximally liberal about package prefixes for lisp topics.
;;;  Does not allow packages in @L parts of titles.
(define-presentation-type record-group ((&key (aarray *topic-aarray*)))
   :no-deftype t
   :history t

   :printer ((record-group stream)
	     (let ((topic (record-group-topic record-group))
		   (type (record-group-type record-group)))
	       (present topic 'record-group-topic :stream stream)
	       (when (rest (topic-record-groups topic))
		 (write-char #\space stream)
		 (present type 'record-group-type :stream stream))))
   :parser ((stream &key initially-display-possibilities type)
	    (let ((record-group
		    (block record-group
		      (let ((start-location (send stream :read-location)))
			(destructuring-bind (string . record-groups)
			    (accept `((record-group-topic-set :aarray ,aarray))
				    :stream stream :prompt nil
				    :initially-display-possibilities
				    initially-display-possibilities)
			  (when (null (rest record-groups))
			    (return-from record-group (first record-groups)))
			  (unless (dw:compare-char-for-accept (dw:read-char-for-accept stream)
							      #\space)
			    (sys:with-stack-array (new-string (+ 3 (string-length string))
							      :element-type 'character
							      :fill-pointer 0)
			      (dw::add-quotes-appropriately string new-string :both)
			      (vector-push-extend #\space new-string)
			      (dw::presentation-replace-input stream start-location
							      new-string :dont-quote t)))
			  (let ((alist (loop for record-group in record-groups
					     collect (cons (present-to-string
							     (record-group-type record-group)
							     'record-group-type)
							   record-group))))
			    (accept `((alist-member :alist ,alist)) :stream stream)))))))
	      (values
		;; :no-deftype obligates us to return something of the record-group type.
		(if (record-group-compressed-p record-group)
		    (expand-compressed-record-group record-group)
		    record-group))))

   :description "a documentation topic"
   )

(graphics::define-binary-encoding-for-ptype (record-group "Documentation Topic")
  :encode-object ((object type)
		  (declare (ignore type))
		  (sage::record-group-unique-id object))
  :decode-object ((object type)
		  (declare (ignore type))
		  (sage::lookup-unique-id-registry object))
  :decode-object-printably ((object type)
			    (declare (ignore type))
			    `(sage::lookup-unique-id-registry ,object)))

;;; A cons of a string and a set of record-groups, all of which have the same topic.
(define-presentation-type record-group-topic-set ((&key (aarray *topic-aarray*)))
   :history (()
	     (values (dw::find-accept-history 'record-group)))

   :default-preprocessor ((default &key type)
			  (flet ((lookup-rg-set (rg)
				   (let ((name (record-group-topic-completion rg)))
				     (values (si:aarray-lookup name aarray)
					     type))))
			    (typecase default
			      (compressed-record-group (lookup-rg-set default))
			      (record-group (lookup-rg-set default))
			      (otherwise (values default type)))))

   :parser ((stream &key initially-display-possibilities)
	    (complete-topic-name stream aarray initially-display-possibilities))

   :printer ((set stream)
	     (write-string (first set) stream))
   )

(defun complete-topic-name (stream aarray initially-display-possibilities)
  (multiple-value-bind (record-group nil string)
      (dw:complete-input stream
			 #'(lambda (string &optional (action :complete))
			     (topic-name-completer string aarray action))
			 :type 'record-group
			 :partial-completers '(#\Space)
			 :initially-display-possibilities initially-display-possibilities
			 :compress-choices nil)
    (let ((entry (si:aarray-lookup string aarray)))
      (when (null entry)
	;; Did something funny with packages in completer.
	(return-from complete-topic-name (list* string
						(topic-record-groups
						  (record-group-topic record-group)))))
      (when (null (cddr entry))
	;; No multiple possibilities, just return the answer.
	(return-from complete-topic-name entry))
      (setq string (first entry))
      (let ((possible (multiple-value-bind (symbol found)
			  (intern-soft string)
			(if found
			    (loop for record-group in (rest entry)
				  when (let ((topic (record-group-topic record-group)))
					 (or (not (symbolp topic))
					     (eq topic symbol)))
				    collect record-group)
			    (rest entry)))))

	(when (and possible (null (rest possible)))
	  ;; Only one accessible from current package.
	  (return-from complete-topic-name (cons string possible)))

	(unless (loop for record in (rest entry) thereis (stringp (record-group-topic record)))
	  ;; If there is more than one topic name, and they are all LISP topics, must give
	  ;; prefix.  If one of them is a concept topic, just go on into type code.
	  (let ((topics (delete-duplicates (mapcar #'record-group-topic (rest entry))
					   :test #'equalp)))
	    (when (rest topics)
	      ;; The following is the best we can do in the way of mouse
	      ;; sensitive error reports.
	      (si:with-ie-typeout-if-appropriate (stream)
		(format stream "These are the ")
		(dw:describe-presentation-type 'record-group stream t)
		(format stream " matching ~A:~%" string)
		(format-item-list possible :stream stream :presentation-type 'record-group))
	      (sys:parse-error "~A is ambiguous.  You must type a package prefix." string))))
	(cons string (rest entry))))))

(defun topic-name-completer (string &optional (aarray *topic-aarray*) (action :complete))
  (declare (values new-string success object new-character-pos nmatches))
  (dw:suggestion-completer (string :action action :delimiters zwei:*completing-delims*)
    (labels ((name-subset (name &optional (full-if-needed nil))
	       (if (and full-if-needed
			(or (member action dw::*completion-needs-full-set*)
			    (equal name "")))
		   aarray			;Need to look at everything
		   (multiple-value-bind (nil completions)
		       (zwei:complete-string name aarray zwei:*completing-delims*)
		     completions))))
      ;; Match against exactly what was typed.
      (map 'nil
	   (lambda (element)
	     (let ((name (first element)))
	       (dolist (record-group (rest element))
		 (dw:suggest name record-group))))
	   (name-subset string t))
      ;; If there was a package prefix, match against symbols in that package.
      (let ((colon (string-search-char #\: string)))
	(when colon
	  (let ((package (find-package (substring string 0 colon))))
	    (when package
	      (setq colon (or (string-search-not-char #\: string :start colon)
			      (string-length string)))
	      (let ((prefix (nstring-upcase (substring string 0 colon))))
		(dolist (element (name-subset (substring string colon)))
		  (let ((name (first element))
			(symbol nil))
		    (dolist (record-group (rest element))
		      (let ((topic (record-group-topic record-group)))
			(when (symbolp topic)
			  (when (null symbol)
			    (setq symbol (multiple-value-bind (symbol found)
					     (intern-soft name package)
					   (when (not found)
					     (return))
					   symbol)))
			  (when (eq symbol topic)
			    (dw:suggest (string-append prefix name) record-group)
			    (return))))))))))))
      ;; Messages.  This code is hardly very general.  Allows package prefix on flavor name
      ;; and omission of the word "flavor:method".
      (when (and (> (string-length string) 1)
		 (char-equal (aref string 0) #\())
	(let ((has-type nil)
	      (package nil)
	      (package-index nil)
	      (package-after-index nil)
	      (package-prefix nil))
	  (block setup
	    (let ((index 0))
	      (unless (char-equal (aref string 1) #\:)
		(setq has-type t)
		(setq index (string-search-char #\space string))
		(unless index
		  (return-from setup)))
	      (setq index (string-search-char #\space string :start (1+ index)))
	      (unless index
		(return-from setup))
	      (setq package-index (1+ index))
	      (let ((colon (string-search-char #\: string :start package-index)))
		(unless colon
		  (return-from setup))
		(setq package-prefix (substring string package-index colon))
		(when (setq package (find-package package-prefix))
		  (setq package-after-index (string-search-not-char #\: string :start colon))
		  (setq package-prefix (nstring-upcase
					 (substring string package-index
						    package-after-index)))))))
	  (when (or (not has-type) package)
	    (dolist (element (name-subset (string-append
					    (if has-type "(" "(FLAVOR:METHOD ")
					    (substring string 1 package-index)
					    (if package-after-index
						(substring string package-after-index)
						""))))
	      (let* ((name (first element))
		     (first-space (string-search-char #\space name))
		     (second-space (and first-space
					(string-search-char #\space name
							    :start (1+ first-space))))
		     (third-space (and second-space
				       (string-search-set " )" name
							  :start (1+ second-space)))))
		(when third-space
		  (dolist (record-group (rest element))
		    (let ((topic (record-group-topic record-group)))
		      (when (and (consp topic)
				 (or (null package)
				     (eq (third topic)
					 (intern-soft (substring name (1+ second-space)
								 third-space)
						      package))))
			(dw:suggest (string-append #\(
						   (substring name
							      (if has-type 1 (1+ first-space))
							      (1+ second-space))
						   (if package package-prefix "")
						   (substring name (1+ second-space)))
				    record-group))))))))))
      )))

;;; Make completion table from set of compressed records.
(defun generate-topic-aarray ()
  (let ((aarray (si:make-aarray (+ (send *unique-idrecord-group-registry* :filled-elements)
				   (length *compressed-record-groups*))
				:name "documentation topic completion table"
				:area *sage-completion-area*)))
    (maphash #'(lambda (ignore record-group)
		 (si:aarray-insert aarray
				   (record-group-topic-completion record-group)
				   record-group
				   nil nil nil))	;defer sorting
	     *unique-idrecord-group-registry*)
    (loop for record-group being the array-elements of *compressed-record-groups* do
      (si:aarray-insert aarray
			(record-group-topic-completion record-group)
			record-group
			nil nil nil))			;defer sorting
    (dotimes (index (fill-pointer aarray))
      ;; Properly CDR code and localize.
      (setf (aref aarray index) (copy-list (aref aarray index) *sage-completion-area*)))
    (si:sort-aarray aarray)
    (setq *topic-aarray* aarray)))

(define-presentation-translator form-to-record-group
   (sys:form record-group
    :gesture :select
    :tester ((form)
	     (and (si:validate-function-spec form)
		  (nsage::find-record-group-for-topic-and-type form 'function))))
   (form)
  (nsage::find-record-group-for-topic-and-type form 'function))

#||
;;; So that J. Random expression will work
(dw::define-presentation-translator expression-to-record-group
   (sys:expression record-group
		   :documentation ((expression &key stream)
				   (format stream "~S" expression))
		   :do-not-compose t
		   :tester ((expression &key input-context)
			    (and (si:validate-function-spec expression)
				 (multiple-value-bind (nil nil presentation-args)
				     (dw::decode-presentation-type
				       (dw::presentation-input-context-presentation-type
					 input-context))
				   (let ((allow-any-input (getf presentation-args
								:allow-any-input)))
				     (or allow-any-input
					 (documented-p expression nil)))))))
   (expression)
  (with-stack-list (list "" expression)
    (convert-record-group-name-to-record-group-using-mouse list)))
||#

(defun convert-record-group-name-to-record-group-using-mouse (record-group-name)
  (declare (values record-group found-p))
  (let ((record-groups (cdr record-group-name))
	(the-choice nil))
    (when (not (typep (first record-groups) 'record-group))
      (setq record-groups (find-record-group-for-topic-and-type (first record-groups) nil)))
    (unless record-groups
      (return-from convert-record-group-name-to-record-group-using-mouse
	(values nil nil)))
    ;; --- should really use allow-any-input here, do this later.
    (if (= (length record-groups) 1)
	(setq the-choice (first record-groups))
	(if (or dw:*inside-handler-test-phase* dw:*inside-handler-documentation-phase*)
	    (setq the-choice (first record-groups))
	    (let* ((alist (alist-from-record-group-list record-groups))
		   (choice (dw:menu-choose alist :prompt "Choose one of the following:")))
	      (setq the-choice choice))))
    (values the-choice t)))

(defun ALIST-FROM-RECORD-GROUP-LIST (record-group-list)
  (let ((alist (loop for record-group in record-group-list
		     as type = (record-group-type record-group)
		     collect (list (if (nsage::concept-type-p type)
				       (nsage::coerce-record-type :sage-section-record
								'nsage::print-name)
				       (string-capitalize-words type))
				   (nsage::appropriate-title-rendering record-group
								     'nsage::no-formatting)
				   record-group))))
    (setq alist (stable-sort (sort alist 'string-lessp :key #'car)
			     #'(lambda (e1 e2) (string-lessp (second e1) (second e2)))))
    (loop for ele in alist
	  do (rplaca ele (string-append (first ele) #\space (second ele)))
	     (rplacd ele (cddr ele)))
    alist))

(scl:define-presentation-translator record-group-name-to-record-group
   (record-group-name record-group
		      :tester true
		      :do-not-compose t
		      :documentation ((name)
				      (first name)))
   (record-group-name)
  (convert-record-group-name-to-record-group-using-mouse record-group-name))


;;; Support macros.
(eval-when (eval compile load)
(defun D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")alter-tester0 (tester command-name)
  (let ((block-name (gensym)))
    (destructuring-bind (arglist . body) tester
      `(,arglist
	(block ,block-name
	  (unless (cp:command-in-command-table-p
		    ',command-name
		    cp:*command-table*)
	    (return-from ,block-name nil))
	  ,@body)))))
)

(defmacro 1define-record-group-to-command-translator
0	  (command-name short-name long-name &rest options)
  (let ((record-group-translator-name (dw::fintern
					"RECORD-GROUP-TO-~S-TRANSLATOR" command-name))
	(record-group-name-translator-name
	  (dw::fintern "RECORD-GROUP-NAME-TO-~S-TRANSLATOR" command-name))
	(tester (getf options :tester
		      '((ignore) t))))		;copy-tree?
    `(progn
       (define-presentation-to-command-translator
	 ,record-group-translator-name
	 (record-group
	   :documentation ((ignore &key for-menu-p)
			   (if for-menu-p
			       ,long-name
			       ,short-name))
	   ,@options)
	 (record-group)
	 (cp:build-command ',command-name record-group))
       (define-presentation-to-command-translator
	 ,record-group-name-translator-name
	 (record-group-name
	   :tester ,(alter-tester tester command-name)
	   :do-not-compose t
	   :documentation ((ignore &key for-menu-p)
			   (if for-menu-p
			       ,long-name
			       ,short-name))
	   ,@options)
	 (record-group-name)
	 (let ((record-group
		 (convert-record-group-name-to-record-group-using-mouse
		   record-group-name)))
	   (when record-group
	     (cp:build-command ',command-name record-group)))))))

(cp:define-command (com-format-file :command-table "Document Formatting"
				    :provide-output-destination-keyword nil)
		   ((file '((sequence fs:pathname))
			  :confirm t :prompt "file"
			  :documentation "One or more files to display formatted")
		    &key
		    (destination 'documentation-destination
				 :default :screen
				 :mentioned-default
				 (or (let ((printer
					     (and (boundp 'hardcopy:*default-text-printer*)
						 hardcopy:*default-text-printer*)))
				       (when (and printer
						  (sage-can-deal-with-printer printer))
					 printer))
				     (when (boundp *previous-sage-display-target-printers*)
				       (loop for printer
						 in *previous-sage-display-target-printers*
					     when (sage-can-deal-with-printer printer)
					       return printer)))
				 :documentation "Destination for formatted output")
		    (page-headings 'boolean
				   :default t
				   :documentation
				   "Whether to print page headings in hardcopy"))
  (let-if (not page-headings) ((zwei:*numeric-arg* 0))
    (loop for file in file do
      (cond ((send file ':wild-p)
	     (condition-case (err-or-files)
		  (cdr (fs:directory-list file ':sorted))
		(fs:file-operation-failure (format t "~&Error: ~~A~" err-or-files))
		(:no-error
		  (setq err-or-files
			(loop for (file . nil) in err-or-files
			      collect file))
		 (if (null err-or-files)
		     (format t "~&Error: ~A matches no files." file)
		     (loop for file in err-or-files
			   do (condition-case (err)
				   (with-open-file (in file)
				     (unless (eq destination :screen)
				       (format t "~&Formatting ~A ..." file))
				     (zwei:format-stream
				       (si:make-input-stream-from-tributaries
					 :characters t
					 :string "@begin(text)"
					 :stream in
					 :string "@end(text)")
				       destination in (string file))
				     (unless (eq destination :screen)
				       (format t " Done.")))
				 (fs:file-operation-failure
				   (format t "~&Cannot access ~A: ~~A~" file err))))))))
	    (t
	     (condition-case (err)
		  (with-open-file (in file)
		    (unless (eq destination :screen)
		      (format t "~&Formatting ~A ..." file))
		    (zwei:format-stream (si:make-input-stream-from-tributaries
					  :characters t
					  :string "@begin(text)"
					  :stream in
					  :string "@end(text)")
					destination in
					(string file))
		    (unless (eq destination :screen)
		      (format t " Done.")))
		(fs:file-operation-failure
		  (format t "~&Cannot access ~A: ~~A~" file err))))))))

(defun default-record-group-for-command ()
  #-imach
  (and (not (zerop dbg:*debugger-level*))
       (let ((fspec (sys:function-name
		      (sys:frame-function dbg:*current-frame*))))
	 (and fspec
	      (loop for record-group in (find-record-group-for-topic-and-type
					  fspec nil)
		    as record = (find-record-for-lookup record-group)
		    when (and record
			      (member (coerce-record-type
					(doc-record-source-type record)
					'property)
				      '(:sage-function-record :sage-method-record
					:sage-flavor-internal-function-record)))
		      return record-group)))))

(cp:define-command (com-show-documentation :command-table "Documentation"
					   :provide-output-destination-keyword nil)
    ((record-group 'record-group
		   :prompt "for topic"
		   :confirm t
		   :default (default-record-group-for-command)
		   :documentation "Documentation topic to display")
     &key
     (destination 'documentation-destination
		  :default :screen
		  :mentioned-default
		  (or (let ((printer (and (boundp 'hardcopy:*default-text-printer*)
					  hardcopy:*default-text-printer*)))
			(when (and printer
				   (sage-can-deal-with-printer printer))
			  printer))
		      (when (boundp *previous-sage-display-target-printers*)
			(loop for printer
				  in *previous-sage-display-target-printers*
			      when (sage-can-deal-with-printer printer)
				return printer)))
		  :documentation "Destination for formatted output"))
   (unless (eq destination :screen)
     (format t "~&Printing documentation for ~(~A~) ~A ..."
	     (namespace-type-string record-group)
	     (appropriate-title-rendering record-group 'no-formatting)))
   (if (lookup-manual-internal record-group destination)
       (unless (eq destination :screen) (format t " Done."))
       (unless (eq destination :screen) (format t " [Aborted.]"))))

(cp:define-command (com-show-table-of-contents :command-table "Documentation")
    ((record-group 'record-group
		   :prompt "for topic"
		   :confirm t
		   :default (default-record-group-for-command)
		   :documentation "Documentation topic")
     &key
     (crossreferences 'boolean
		      :default nil
		      :mentioned-default t
		      :documentation "Whether to display crossreferenced topics")
     (sources 'boolean
	      :default nil
	      :mentioned-default t
	      :documentation "Whether to display associated source files")
     (depth 'integer
	    :default nil
	    :documentation "How many levels deep to display"))
   (sage::view-table-of-contents-internal record-group crossreferences sources depth))

(define-record-group-to-command-translator
  com-show-documentation
  "Show Documentation" "Show Documentation")

(define-presentation-to-command-translator
  edit-record-code
   (record-group
     :gesture :edit-1function
0     :tester ((rg)
	      (let ((spec (record-group-topic rg)))
		(and (sys:validate-function-spec spec)
		     (fdefinedp spec)))))
   (record-group)
  `(si:com-edit-definition ,(record-group-topic record-group)))

(define-presentation-to-command-translator
  edit-record-name-code
   (record-group-name
     :gesture :edit-1function
0     :tester ((record-group-name)
	      (let ((spec (second record-group-name)))
		(and (sys:validate-function-spec spec)
		     (fdefinedp spec)))))
   (record-group-name)
  `(si:com-edit-definition ,(second record-group-name)))

(cp:define-command (com-Register-Book :command-table "Documentation"
				      :provide-output-destination-keyword nil)
    ((record-group 'record-group
		   :prompt "Document name"
		   :confirm t
		   :default (default-record-group-for-command)
		   :documentation "Documentation topic name to register")
     &key
     (mnemonic 'string
	       :prompt "Mnemonic"
	       :default ""
	       :documentation "Identifier for use in a Master Index")
     (type 'string
		    :prompt "Type"
		    :default ""
		    :documentation "Book Design to use in formatting")
     (highest-structural-level 'string
			       :prompt "Highest Structural Level"
			       :default ""
			       :documentation "How the document is structured: MajorPart (the default) or Chapter")
;     (boilerplate 'string
;		  :prompt "Boilerplate"
;		  :default ""
;		  :documentation "Frontmatter to use")
     (Symbolics-Copyright 'boolean
			  :prompt "Symbolics Copyright"
			  :mentioned-default t
			  :default nil
			  :documentation "Include the standard Symbolics Copyright")
     (MIT-Copyright 'boolean
		    :prompt "MIT Copyright"
		    :mentioned-default nil
		    :default nil
		    :documentation "Include the MIT Copyright (for work that originated there)")
     (number 'string
		      :prompt "Document Number"
		      :default "999999"
		      :documentation "Part number, stock number or other identifier")

     (release-version 'string
		      :prompt "Release Version"
		      :default ""
		      :documentation "Software version this document corresponds to")
;     (marketing 'string
;		:prompt "Marketing"
;		:default ""
;               :documentation "Is this marketing literature?")

     (author-group 'string
		   :prompt "Author Group"
		   :default ""
		   :documentation "Person or group who wrote the document")
;     (design 'string
;	     :prompt "Design"
;	     :default "")
;     (cover-printer 'string
;		    :prompt "Cover Printer"
;		    :default "")
;     (text-printer 'string
;		   :prompt "Text Printer"
;		   :default "")
;     (printer 'string
;	      :prompt "Printer"
;	      :default "")
;     (confidential 'string
;		   :prompt "Confidential"
;		   :default "")
     (trademarks 'string
		 :prompt "Document Trademarks"
		 :default ""
		 :documentation "Other trademarks to mention")

     )
   (register-book (appropriate-title-rendering record-group 'no-formatting)
		  :mnemonic mnemonic
		  :document-type type
		  :highest-structural-level highest-structural-level
;		  :boilerplate boilerplate
		  :symcopy symbolics-copyright
		  :doc# number
		  :releaseversion release-version
;		  :marketing marketing
		  :MITCopy MIT-Copyright
		  :authorgroup author-group
;		  :design design
;		  :cover-printer cover-printer
;		  :text-printer text-printer
;		  :printer printer
;		  :confidential confidential
		  :doctrademarks trademarks)
   (format t "~&~A has been registered as a book." record-group)
   nil
   )


;; Whizzy user-interface so that you can get documentation via the mouse.

(define-presentation-to-command-translator com-show-documentation-for-function
   (sys:function-spec
     :tester ((fspec)
	      (find-record-group-for-topic-and-type fspec 'function))
     :documentation "Show documentation"
     :gesture nil)
   (fspec)
  `(com-show-documentation ,(find-record-group-for-topic-and-type fspec 'function)))

(define-presentation-translator function-spec-to-record-group
   (sys:function-spec record-group)
   (fspec)
  (find-record-group-for-topic-and-type fspec 'function))

(define-presentation-to-command-translator com-show-documentation-for-command
   (cp:command
     :tester ((command &key presentation)
	      (dw::with-type-decoded (type data-args pr-args)
				     (dw:presentation-type presentation)
		type pr-args
		(find-record-group-for-cp-command (car command)
						  (getf data-args :command-table))))
     :documentation "Show documentation"
     :gesture nil)
   (command &key presentation)
  (dw::with-type-decoded (type data-args pr-args)
			 (dw:presentation-type presentation)
    type pr-args
    `(com-show-documentation
       ,(find-record-group-for-cp-command (car command)
					  (getf data-args :command-table)))))

(define-presentation-translator command-to-record-group
   (cp:command record-group)
   (command &key presentation)
  (dw::with-type-decoded (type data-args pr-args)
			 (dw:presentation-type presentation)
    type pr-args
    (find-record-group-for-cp-command (car command)
				      (getf data-args :command-table))))

(define-presentation-to-command-translator com-show-documentation-for-command-name
   (cp:command-name
     :tester ((command-name &key presentation)
	      (dw::with-type-decoded (type data-args pr-args)
		    (dw:presentation-type presentation)
		 type pr-args
		 (find-record-group-for-cp-command command-name
						   (getf data-args :command-table))))
     :documentation "Show documentation"
     #|| ;;CTD wanted this but I'm not sure if the room it takes up on the
         ;;mouse doc line is worth it. We agreed to wait on it. -kmp 18-May-90
     :documentation ((command-name &key presentation)
		     (dw::with-type-decoded (type data-args pr-args)
			   (dw:presentation-type presentation)
			type pr-args
			(let ((si:*disable-noise-strings* t))
			  (present-to-string
			    `(com-show-documentation
			       ,(find-record-group-for-cp-command
				  command-name
				  (getf data-args :command-table)))
			    'cp:command)))) ||#
     :gesture :describe)
   (command-name &key presentation)
  (dw::with-type-decoded (type data-args pr-args)
	(dw:presentation-type presentation)
     type pr-args
     `(com-show-documentation
	,(find-record-group-for-cp-command command-name
					   (getf data-args :command-table)))))

(define-presentation-translator command-name-to-record-group
   (cp:command-name record-group)
   (command-name &key presentation)
  (dw::with-type-decoded (type data-args pr-args)
			 (dw:presentation-type presentation)
    type pr-args
    (find-record-group-for-cp-command command-name
				      (getf data-args :command-table))))

;; This is a special case so Mouse-Middle can give useful documentation while typing
;; a command-name.  That's why it's on COMMAND-NAME  COMMAND-NAME.
(define-presentation-action com-show-documentation-for-command-name-during-help
   (cp:command-name cp:command-name
    :tester ((command-name &key presentation)
	     (dw::with-type-decoded (type data-args pr-args)
				    (dw:presentation-type presentation)
	       type pr-args
	       (find-record-group-for-cp-command command-name
						 (getf data-args :command-table))))
		    :documentation "Show documentation"
		    :gesture :describe)
   (command-name &key presentation window)
  (dw::with-type-decoded (type data-args pr-args)
			 (dw:presentation-type presentation)
    type pr-args
    (si:with-ie-typeout-if-appropriate (*terminal-io*)
      (let ((*standard-output* window))
	(lookup-manual-internal
	  (find-record-group-for-cp-command command-name
					    (getf data-args :command-table)))))))


;; Given a command-name (e.g., SI:COM-SHOW-HERALD), backtranslate to the
;; record-group which documents the command.  The result is cached, since
;; the algorithm can be slow and consy.
(defun find-record-group-for-cp-command (command-name &optional command-table)
  (when (si:get-source-file-name command-name 'cp:define-command)
    (flet ((find-command (command-table)
	     (let ((command-aarray (cp::command-table-command-aarray command-table)))
	       (when command-aarray
		 (loop for (name . function) being the array-elements of command-aarray
		       doing
		   (when (eql command-name function)
		     ;; We found the command.  Convert the command-name into
		     ;; a documentation topic (I hope), and then find the
		     ;; record-group which corresponds to the topic. 
		     ;;--- I hope this topic reflects most things!  --SWM
		     (let ((record-group
			     (find-sage-record-of-type (string-append name " Command")
						       :sage-fragment-record)))
		       (when record-group (return-from find-command record-group)))))))))
      (let ((record-group
	      (or (get command-name 'command-name-record-group)
		  ;; First try the command-table supplied by the presentation
		  (and command-table (find-command command-table))
		  ;; The passed in command-table cannot be counted upon to be
		  ;; reliable, so scan all the rest of the command tables looking
		  ;; for this command
		  (loop named get-record-group
			for comtab being the hash-elements of cp::*command-table-registry*
			do (let ((record-group (and (neq comtab command-table)
						    (find-command comtab))))
			     (when record-group
			       (return-from get-record-group record-group)))
			finally (return-from get-record-group :none)))))
	;; Cache the record-group, since this computation is "not cheap"
	(setf (get command-name 'command-name-record-group) record-group)
	;; Return the record-group, filtering out :NONE
	(and (neq record-group :none) record-group)))))

(defun find-sage-record-of-type (topic type-or-types)
  (let ((record-groups (find-record-group-for-topic-and-type topic nil)))
    (flet ((try-type (type)
	     (loop for record-group in record-groups
		   as record = (find-record-for-lookup record-group)
		   doing
	       (when (and record
			  (eql (coerce-record-type (doc-record-source-type record) 'property)
			       type))
		 (return-from find-sage-record-of-type record-group)))))
      (if (atom type-or-types)
	  (try-type type-or-types)
	  (dolist (type type-or-types) (try-type type)))
      nil)))



(defvar *activity-documentation-table* (make-hash-table :test #'string-equal))

(defun find-record-group-for-activity (activity-name)
  (when (cli::lookup-activity activity-name :error-p nil)
    (let ((record (or (gethash activity-name *activity-documentation-table*)
		      (setf (gethash activity-name *activity-documentation-table*)
			    (or (find-sage-record-of-type (string-append "The "
									  activity-name
									  " Activity")
							   '(:sage-fragment-record
							     :sage-section-record))
				:none)))))
      (unless (eq record :none) record))))

(define-presentation-to-command-translator com-show-documentation-for-activity-name
   (sys:activity-name
     :tester ((activity-name)
	      (find-record-group-for-activity activity-name))
     :documentation "Show documentation"
     :gesture :describe)
   (activity-name)
  `(com-show-documentation ,(find-record-group-for-activity activity-name)))

(define-presentation-translator activity-name-to-record-group
   (sys:activity-name record-group)
   (activity-name)
  (find-record-group-for-activity activity-name))


(cp:define-command (1com-format-topic 0:command-table "Documentation"
				     :provide-output-destination-keyword nil)
    ((record-group 'record-group
		   :prompt "topic"
		   :confirm t
		   :default (default-record-group-for-command)
		   :documentation "Documentation topic to display")
     &key
     (destination 'documentation-destination
		  :default :screen
		  :mentioned-default
		  (or (let ((printer (and (boundp 'hardcopy:*default-text-printer*)
					  hardcopy:*default-text-printer*)))
			(when (and printer
				   (sage-can-deal-with-printer printer))
			  printer))
		      (when (boundp *previous-sage-display-target-printers*)
			(loop for printer
				  in *previous-sage-display-target-printers*
			      when (sage-can-deal-with-printer printer)
				return printer)))
		  :documentation "Destination for formatted output"))
   (unless (eq destination :screen)
     (format t "~&Printing documentation for ~(~A~) ~A ..."
	     (namespace-type-string record-group)
	     (appropriate-title-rendering record-group 'no-formatting)))
   (keeping-sage-files
     (rooting-record-expansion (record-group)
       (sage-displayer destination
		       (appropriate-title-rendering record-group 'no-formatting)
		       #'formatted-sage-record-line-source
		       record-group))))

;;; --- What's the correct verb here?
(cp:define-command (com-run-documentation-example :command-table "Documentation")
    ((example 'active-example))
   (execute-example-contents (directive-inferiors example)))

(define-presentation-to-command-translator com-run-documentation-example
					   (active-example) (active-example)
  `(com-run-documentation-example ,active-example))

(defun execute-example-contents (contents-list &key update-record)
  (let ((state (if (some #'(lambda (thing)
			     (and (typep thing 'sage-command)
				  (eq (sage-command-command-name thing)
				      'endexamplecompiledprologue)))
			 contents-list)
		   :compiling
		   :evaluating))
	(forms nil))
    (when (eq state :compiling)
      (format t "~&Initializing example ... "))
    (dolist (thing contents-list)
      (typecase thing
	(sage-text-structure
	  (let ((interval (sage-text-structure-interval thing)))
	    (with-standard-io-environment
	      (let ((*package* si:*user-package*)
		    (*readtable* si:*common-lisp-readtable*)
		    (compiler:*inhibit-using-source-locators* t))
		(case state
		  (:compiling
		    (compiler:compile-from-stream (zwei:open-interval-stream interval)
						  nil #'compiler:compile-to-core nil))
		  (:evaluating
		    (let* ((stream (zwei:open-interval-stream interval))
			   (start-bp (send stream :read-bp)))
		      (loop
			(condition-case (form)
			     (read stream)
			   (sys:end-of-file (return))
			   (:no-error
			     (fresh-line)
			     (zwei:stream-out-interval *standard-output*
						       start-bp
						       (setq start-bp (send stream :read-bp)))
			     (push form forms)
			     (shiftf +++ ++ + - form)
			     (shiftf /// // / (multiple-value-list (eval form)))
			     (shiftf *** ** * (first /))
			     (dolist (value /)
			       (print value))))))))))))
	(sage-command
	  (case (sage-command-command-name thing)
	    (endexamplecompiledprologue
	      (format t "done.~&")
	      (setq state :evaluating))))
	(example-record-marker
	  (when update-record
	    (update-example-record-marker thing (nreverse forms)))
	  (setq forms nil))
	;; All hell breaks loose here if the writer put some more complex formatting inside
	;; the example record.
	)))
  ;; This is for the benefit of the ddex typeout window.
  (fresh-line))

(cp:define-command (com-edit-documentation-example :command-table "Documentation")
    ((example 'active-example))
   (multiple-value-bind (buffer point)
       (copy-example-contents-into-examples-buffer (directive-inferiors example))
     (ed `(zwei:buffer-at-position ,buffer ,point))))

(define-presentation-to-command-translator com-edit-documentation-example
					   (active-example :gesture :edit-definition)
					   (active-example)
  `(com-edit-documentation-example ,active-example))

(defun copy-example-contents-into-examples-buffer (contents-list
						   &key (buffer-name "Documentation Examples"))
  (let ((buffer (zwei:find-buffer-named buffer-name))
	(bp nil))
    (cond (buffer
	   (setq bp (zwei:copy-bp (zwei:interval-last-bp buffer)))
	   (let ((zwei:*interval* buffer))
	     (zwei:insert-moving bp "

")))
	  (t
	   (setq buffer (zwei:make-buffer 'zwei:non-file-buffer
					  :name buffer-name
					  :major-mode :lisp
					  :package si:*user-package*))
	   (setq bp (zwei:copy-bp (zwei:interval-first-bp buffer)))))
    (dolist (thing contents-list)
      (typecase thing
	(sage-text-structure
	  (let ((interval (sage-text-structure-interval thing)))
	    (let ((zwei:*interval* buffer))
	      (zwei:insert-interval (zwei:interval-last-bp buffer) interval))))))
    (values buffer bp)))

(cp:define-command (1com-set-sage-variable 0:command-table "Document Formatting")
    ((variable 'sage-variable :prompt "Variable" :confirm t)
     (value 'string :confirm t))
   (set-static-value variable value))

(cp:define-command (1com-clear-sage-variable0 :command-table "Document Formatting")
    ((variable 'sage-variable :prompt "Variable"))
   (set-static-value variable nil))

(cp:define-command (1com-list-sage-variables0 :command-table "Document Formatting")
    ()
   (if (zerop (hash-table-count *static-counters*))
       (format t "~&There are no sage variables set at this time.")
       (format t "~2&~'bVariable~20tValue~")
       (maphash #'(lambda (key val)
		    (format t "~&~a~20t~s" key val))
		*static-counters*)))


;;;Support for Find String CP command to search sab files
(defun find-wt-strings (strings file &key stop-if-found)
  (let ((match-count 0)
	(file-count 0)
	(failures 0))
    (condition-case ()
	 (multiple-value-bind (record-info nil)
	     (get-record-info-from-file file)
	   (loop for record in record-info
		 as record-name = (record-info-name record)
		 as record-type = (record-info-type record)
		 as contents = (second (assoc 'contents
					      (record-info-record-fields record)))
		 with file-name-printedp
		 as record-name-printedp = nil
		 do
	     (labels ((find-em (line &optional (from 0) (to (length line)))
			(dolist (string strings)
			  (when (string-search string line :start2 from :end2 to)
			    (incf match-count)
			    (unless file-name-printedp
			      (format t "~&~@\\presentation\\" file `((cl:pathname)))
			      (setq file-name-printedp t)
			      (incf file-count))
			    (let ((record-group
				    (find-record-group-for-topic-and-type record-name
									  record-type)))
			      (unless record-name-printedp
				(format t "~&~5t~:[~a~*~;~@\\presentation\\~]"
					record-group (or record-group record-name)
					`((record-group)))
				(setq record-name-printedp t))
			      (format t "~&~10t~s" (substring line from to)))
			    (when stop-if-found
			      (return-from find-wt-strings
				(values match-count file-count failures))))))
		      (for-contents-list (contents-list)
			(mapc #'for-directive contents-list))
		      (for-directive (directive)
			(cl:typecase directive
			  (string
			    (do-lines-of-string ((directive)(from to))
			      (find-em directive from to)))
			  (sage-text-structure
			    (zwei:do-lines ((line from to)
					    ((sage-text-structure-interval directive)))
			      (find-em line from to)))
			  (sage-envr
			    (for-contents-list (send directive :contents-list)))
			  (sage-command
			    (string-search-command directive #'for-contents-list)))))
	       (for-contents-list contents))))
       (fs:file-not-found
	 (incf failures)
	 (format si::error-output
		 "~&~%Skipping file ~A because it could not be found" file)))
    (values match-count file-count failures)))

(define-sage-command-generic string-search-command (searcher)
  (ignore searcher))

(define-sage-command-method (string-search-command L) (searcher)
  (stack-let ((buffer (make-array 256 :element-type 'character
				  :fill-pointer 0)))
    ;; There's a better way to say this, but I can't
    ;; find it...
    (loop for (piece . more) on string
	  do
      ;; FORMAT lets you "write" to a string with fill pointer.
      (format buffer "~s" piece)
      (when more (format buffer " ")))
    (funcall searcher (list buffer))))

(define-sage-command-method (string-search-command index) (searcher)
  (funcall searcher entry))
