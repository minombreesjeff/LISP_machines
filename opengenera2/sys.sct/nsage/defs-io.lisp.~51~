;;; -*- Syntax: Common-lisp; Mode: LISP; Package: NSAGE; Base: 10; Lowercase: t -*-
;;;
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;

(defvar D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")*charset&stylefont-cache-tick*0 0)

(defflavor 1output-device
0	;; everything but font cache gets initialized in :with-device-prepared
	(display-device-type
	 face-code-alist
	 (leading 2.5)				;points
	 font-table
	 current-font-number
	 current-font
	 current-style
	 merged-current-style
	 default-style
	 (charset&stylefont-cache
	   (make-instance 'si:variable-style-font-cache
			  :global-tick-symbol '*charset&stylefont-cache-tick*))
	 )
	()
  (:gettable-instance-variables current-font-number face-code-alist leading)
  (:required-methods
   :width-of-char-in-font :height-of-font :with-device-prepared))

(defmethod 1(:handle-presentation output-device)0 (key output-stack &rest options)
  (ignore key output-stack options)
  )

(defmethod 1(start-record-presentation output-device)0 (stream output-stack record)
  (ignore stream output-stack record)
  )

(defmethod 1(end-record-presentation output-device)0 (stream output-stack record)
  (ignore stream output-stack record)
  )

(defmethod 1(device-display-gbox output-device)0 (gbox stream font-number x-motion
						current-extra-width-per-space)
  (display-gbox-new gbox stream self font-number x-motion current-extra-width-per-space))

(defflavor 1basic-window-output-device
0	(window)
	(output-device)
  (:initable-instance-variables window)
  (:gettable-instance-variables window))

(defmethod 1(:handle-presentation basic-window-output-device)0 (key output-stack &rest options)
  (when (operation-handled-p window 'dw::push-presentation-stack)
    (ecase key
      (:start
	(apply #'dw::push-presentation-stack window output-stack options))
      (:end
	(dw::pop-presentation-stack window output-stack)))))

(defmethod 1(start-record-presentation basic-window-output-device)0 (stream output-stack record)
  (unless stream (setq stream window))		;compatibility 
  (when (operation-handled-p stream 'dw::push-presentation-stack)
    (dw::push-presentation-stack stream output-stack
				 :object record
				 :type (type-of record)
				 :single-box t)))

(defmethod 1(end-record-presentation basic-window-output-device)0 (stream output-stack record)
  (unless stream (setq stream window))		;compatibility 
  (when (operation-handled-p stream 'dw::pop-presentation-stack)
    (let ((top-presentation (elt output-stack (1- (fill-pointer output-stack)))))
      (when top-presentation
	(let ((object (dw:presentation-object top-presentation))
	      (type (dw:presentation-type top-presentation)))
	  (when (and (eq object record)
		     (eq type (type-of record)))
	    (dw::pop-presentation-stack stream output-stack)))))))


(defgeneric 1window-p0 (window)
  (:method (si:stream) nil)
  (:method (tv:sheet) t))

(defflavor 1window-output-device
0	()
	(basic-window-output-device)
  (:required-init-keywords :window))

(defresource 1window-output-devices0 (window)
  :constructor (make-instance 'window-output-device :window window)
  :initializer (send object :initialize window))

#|  so I don't have to retype it all the time	
(progn
  (clear-resource 'window-output-devices))
|#

(defflavor 1dex-output-device
0	((window '|DEX output device uninitialized window|))
	(basic-window-output-device))

(defmethod 1(start-record-presentation dex-output-device)0 (stream output-stack record)
  ;; don't do anything.  We don't want record contents to be sensitive
  ;; in the document examiner
  (ignore stream output-stack record)
  )

(defmethod 1(end-record-presentation dex-output-device)0 (stream output-stack record)
  ;; ditto here
  (ignore stream output-stack record)
  )


;;; Speed up accesses that end up using the same file several times in a row.
;;;  (e.g. almost any section record)
(defvar 1*sage-open-streams*0 ())			;a list of structures (str path stream ref)
(defvar 1*sage-use-dafile*0 T)			;This really means, "Use it if it's LMFS"

(defstruct 1(file-stream)
0  string					;filespec string
  pathname					;pathname object
  stream					;stream object
  refcount)					;maybe needed someday

(defvar 1*number-of-sage-files-to-keep*0 30)

(defun 1close-one-kept-sage-file0 ()
  (when (listp *sage-open-streams*)
    (let ((victim (first (last *sage-open-streams*))))
      (close-file-retrying (file-stream-stream victim))
      (without-interrupts
	(setq *sage-open-streams*
	      (or (delete victim *sage-open-streams*)
		  :none))))))

(defun 1close-file-retrying0 (stream)
  (condition-case ()
       (si:close-open-stream stream ())
     (error (si:close-open-stream stream T))))

;;;Cribbed from >sys>network>namespaces.lisp, at DCP's suggestion.
;;;This is used by copy-sage-record
(defmacro 1keeping-sage-files0 (&body body)
  `(keeping-sage-files-1
     (named-lambda keeping-sage-files () ,@body)))

(defun 1keeping-sage-files-10 (continuation)
  (declare (sys:downward-funarg continuation))
  (fs:with-automatic-login-to-sys-host
    (let ((top-level-p (null *sage-open-streams*))
	  (auto-close-retry t))
      (let-if top-level-p ((*sage-open-streams* ':none)	;flag until we get to fill it
			   )
1	0(unwind-protect
	    (loop
	      (conditions:restart-case
		(condition-case-if auto-close-retry (condition)
		     (return (funcall continuation))
		   ((sys:network-error fs:qfile-system-bug sys:stream-closed)
		    (setq auto-close-retry nil)
		    (conditions:invoke-restart 'close-sage-streams-and-retry)))
		(close-sage-streams-and-retry ()
					      :report "Close all SAGE streams and try again"
					      (close-sage-files))))
	  (when top-level-p			;when exiting the top level, close down files
	    (close-sage-files)))))))

(defun 1close-sage-files0 ()
  (unless (eq ':none *sage-open-streams*)	;in-memory stuff, no files got opened in body
    (loop for s in *sage-open-streams* do
      (close-file-retrying (file-stream-stream s)))
    (setq *sage-open-streams* :none)))

;;; Takes arg of pathname or filespec string that you want to have open, 
;;; and returns a stream.
;;; Currently this just keeps everything open that was needed during a particular
;;; lookup, to avoid having to re-open the file for several contained records.
;;; This function assumes that it is being called within the context of keeping-sage-files.
;;; When we get here, *sage-open-streams* is either :NONE or a list of file-stream structures,
(defun 1open-sage-file0 (pathname)
  (let* ((check-function (typecase pathname
			   (string #'string-equal)	;for filespec string
			   (fs:pathname #'eq)))	;assume it is pathname.
	 (requested-file (when (and *sage-open-streams* (neq *sage-open-streams* ':none))
			   (loop for s in *sage-open-streams*
				 for spec = (typecase pathname
					      (string (file-stream-string s))
					      (fs:pathname (file-stream-pathname s)))
				 when (funcall check-function pathname spec)
				 return s)))
	 (requested-stream (and requested-file (file-stream-stream requested-file))))
    (or requested-stream			;already open
	(let ((new (make-file-stream)))		;not ok, always make a new one
	  (typecase pathname
	    (string				;starting from string
	     (setf (file-stream-pathname new) (fs:parse-pathname pathname))
	     (setf (file-stream-string new) pathname))
	    (fs:pathname
	      (setf (file-stream-string new) (send pathname ':string-for-printing))
	      (setf (file-stream-pathname new) pathname))
	    (otherwise (error "Needed a string or a pathname, got ~S, a ~S"
			       pathname (type-of pathname))))
	  (loop while (and (listp *sage-open-streams*)
			   (> (length *sage-open-streams*) *number-of-sage-files-to-keep*))
		do
	    (close-one-kept-sage-file))
	  (let ((direct (and *sage-use-dafile*
			     (typep (send (fs:parse-pathname (file-stream-pathname new))
					  :translated-pathname)
				    'fs:lmfs-pathname))))	;---Surely  a better way
	    (with-open-file (f (file-stream-pathname new)	;open up
			       :characters nil :byte-size 8	;in binary mode
			       :direct direct)
	      (setf (file-stream-stream new) f)
	      ;;set read pointer to the end to shut off fire-hose of bytes (for efficiency)
	      (unless direct (send f :set-pointer (send f ':length)))
	      ;;Cleanly transfer the responsibility for closing the open stream
	      ;; from with-open-file to keeping-sage-files
	      (without-interrupts		;make this clean!
		(when (eq *sage-open-streams* :none)	;special flag: this is the first one
		  (setq *sage-open-streams* nil))
		(push new *sage-open-streams*)
		(setq f nil)			;tell with-open-file not to try to close
		(file-stream-stream new)	;return the stream!
		)))))))


(defvar 1*previous-sage-display-target-device*0 :screen
  "This exists so the functions that prompt for a device can offer a default choice")

(define-sage-printer-type-function 1sage-null-printer-type0 null (device)
  (error "Null device?"))
(define-sage-printer-type-function 1sage-symbol-printer-type0 symbol (device)
  (if (keywordp device)
      device
      (error "Bad device name ~s" device)))
(define-sage-printer-type-function 1sage-window-printer-type0 window-output-device (device)
  :screen)

(defun 1sage-type-of-printer0 (device)
  ;;Changes here require changes in WITH-SAGE-DEVICE-INTERNAL
  (block found
    (dolist (fn *sage-printer-type-functions*)
      (let ((result (funcall fn device)))
	(when result (return-from found result))))
    ;;If we wanted to be overly dwimmish, we could accept strings here,
    ;;and call si:get-hardcopy-device on them.  Oh well.
    (error "Can't deal with ~s as a device" device)))

(defflavor 1formatter-cant-deal-with-printer
0	(printer)
	(error)
  (:initable-instance-variables printer)
  (:required-init-keywords :printer))

(defmethod 1(:report formatter-cant-deal-with-printer)0 (stream)
  (format stream "~A cannot handle formatted output." printer))

(defun 1sage-can-deal-with-printer0 (printer)
  (do-sage-printer-types (type nil)
    (let ((lisp-type (and (fdefinedp 'get-sage-printer-type-attribute)
			  (get-sage-printer-type-attribute type :lisp-object-typep))))
      (when (and lisp-type (typep printer lisp-type))
	(return T)))))


(defvar 1*current-sage-device*0)

;;;Most places are supposed to use SAGE-DISPLAYER.
;;;Those that need to format several records to a single
;;;device stream are allowed to use this themselves.
;;;In the body you call display-on-device like so:
;;;(display-on-device device #'formatted-sage-record-line-source(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI") record-group0)

;;;This takes a device, like a printer, initializes things and
;;;binds device-var to an encapsulation.  Then it runs the body
;;;in that context.
(defmacro 1with-sage-device0 ((device &optional type &rest options) &body body)
  `(with-sage-device-internal ,device ,type
			      (named-lambda with-sage-device ()
				(declare (sys:downward-function))
				,@body)
			      . ,options))

(defun 1with-sage-device-internal0 (device type continuation &rest options)
  (declare (sys:downward-funarg continuation))
  (if (typep device 'output-device)
      (with-document-and-device-types (() (send device :output-device-type))
	(funcall continuation))
      (flet ((doit (dev)
	       (let ((*current-sage-device* dev))
		 (with-document-and-device-types (() (send dev :output-device-type))
		   (send dev :with-device-prepared continuation)))))
	(let ((device-type (or type (sage-type-of-printer device))))
	  (case device-type
	    (:screen
	      (let ((window (if (eq device :screen) *terminal-io* device)))
		;; Don't blow out with Show Doc from a remote terminal
		(unless (window-p window)
		  (format *error-output*
			  "~&Documentation output can be displayed only on windows and printers.")
		  (signal 'sys:abort))
		(setq *previous-sage-display-target-device* :screen)
		(using-resource (dev window-output-devices window)
		  (doit dev))))
	    (:dex-background
	      (when (eq device :dex-background)
		(error "Internal error: Expected a Document Examiner frame as the first~@
                    argument to WITH-SAGE-DEVICE-INTERNAL, but got :DEX-BACKGROUND instead."))
	      (doit (make-instance 'dex-output-device
				   :window (zl:named-lambda dex-background-pseudo-window
							    (operation &rest args)
					     (operation-upon-dex-in-background
					       device operation args)))))
	    (:dex (doit (make-instance 'dex-output-device :window device)))
	    (otherwise
	      (let ((flavor (and (fdefinedp 'get-sage-printer-type-attribute)
				 (get-sage-printer-type-attribute device-type
								  :sage-device-flavor))))
		(cond (flavor
		       (setq *previous-sage-display-target-device* device)
		       (when (boundp '*previous-sage-display-target-printers*)
			 (pushnew device *previous-sage-display-target-printers* :replace T))
		       (doit (apply #'make-instance flavor :printer device options)))
		      (t (error
			   "Don't know how to make sage-device for ~s ~s"
			   device-type device)))))
	    )))))

(defvar 1*presentation-stack*0)
(defvar 1*presentations*0)

(defmacro 1with-presentation-stack0 ((&optional (length 10)) &body body)
  `(with-presentation-stack-internal ,length
				     (lambda () ,@body)))

(defun 1with-presentation-stack-internal0 (length continuation)
  (sys:with-stack-array (*presentation-stack* length :fill-pointer 0 :element-type t)
    (sys:with-stack-array (*presentations* length :fill-pointer 0 :element-type t)
      (ignore *presentations*)
      (unwind-protect
	  (funcall continuation)
	(loop for i below (fill-pointer *presentation-stack*)
	      do
	  (send *current-sage-device* :handle-presentation :end *presentation-stack*))))))

(defvar 1*default-character-style-for-pictures*0 '(:fix :roman :normal))

(defmacro 1with-character-style-for-picture0 ((stream picture) &body body)
  `(with-character-style-for-picture-internal
     ,stream ,picture
     (named-lambda with-character-style-for-picture (,stream) ,@body)))

(defun 1with-character-style-for-picture-internal0 (stream picture continuation)
  (declare (sys:downward-funarg continuation))
  (ignore picture)
  (with-character-style ((default-character-style-for-picture picture stream)
			  stream :bind-line-height T)
    (funcall continuation stream)))

(defvar 1*microns-per-device-pixel*0)

(defparameter 1*microns-per-inch*0 (fround 1.0 39.37e-6))

(defparameter 1*microns-per-point*
0	  ;; microns/inch / pts/inch
	  (/ *microns-per-inch* 72.289))

(defparameter 1*microns-per-pica*
0	  (* *microns-per-point* 12))

(defparameter 1*screen-pixels-per-inch*0 100.0)

(defparameter 1*microns-per-screen-pixel*
0	  (/ *microns-per-inch* *screen-pixels-per-inch*))

(defun 1rounded-quotient0 (si:numerator si:denominator)
  si:
  (let ((number (rational-quotient numerator denominator)))
    (cond ((single-float-p number)
	   (with-float-operating-mode ((:round :nearest))
	     (%convert-single-to-fixnum number)))
	  ((double-float-p number)
	   (with-double-components (number d-high d-low)
	     (with-float-operating-mode ((:round :nearest))
	       (%convert-double-to-fixnum d-high d-low))))
	  (T (values (round number))))))

(defmacro 1microns-to-pixels0 (number units)
  (case units
    (:screen `(rounded-quotient ,number *microns-per-screen-pixel*))
    (:device `(rounded-quotient ,number *microns-per-device-pixel*))
    ;;Is this overly dwimmish?
    (otherwise `(rounded-quotient ,number ,units))))

(defmacro 1with-device-toplevel-environment0 ((envr-var) &body body)
  `(with-device-toplevel-environment-1
     (named-lambda with-device-toplevel-environment (,envr-var)
       ,@body)))

(defun 1with-device-toplevel-environment-10 (continuation)
  (declare (sys:downward-funarg continuation))
  (let* ((specifics
	   (with-document-and-device-types ()
	     (composed-book-design *document-type* *device-type*)))
	 (toplevel-envrs (book-design-specifics-toplevel-envrs specifics)))
    (funcall
      continuation
      (if toplevel-envrs
	  (let* ((top-envr (take-environment-from-cache))
		 (envr-to-go top-envr))
	    (send top-envr :init-toplevel)
	    (destructuring-bind ((topmost-envr-name &rest topmost-envr-mods) &rest others)
		toplevel-envrs
	      (let ((envr-dd (lookup-directive-descriptor topmost-envr-name)))
		(assert (and envr-dd (eql (dd-parse-type envr-dd) :environment)))
		(loop for (attr val) in (dd-definition envr-dd)
		      do (send top-envr :set-attribute attr val))
		(loop for (attr val) in topmost-envr-mods
		      do (send top-envr :set-attribute attr val))
		(setf (symbol-value-in-instance top-envr 'line-width)
		      (- (send top-envr :paper-width)
			 (send top-envr :left-margin)
			 (send top-envr :right-margin))))
	      (dolist (next-envr others)
		(destructuring-bind (envr-name &rest envr-mods) next-envr
		  (let ((new-envr (take-environment-from-cache)))
		    (setup-inheritance envr-to-go new-envr envr-name envr-mods)
		    (setq envr-to-go new-envr)))))
	    envr-to-go)
	(make-toplevel-environment)))))



;;; 
(si:define-character-style-families si:*b&w-screen* si:*standard-character-set*
  ;; it wants to say body = title7 = display = title0 = normal
  ;; heading = title3
  '(:family 1sans-serif-body
0    (:size
      :normal					;10.5 Century Schoolbook
     (:face :roman (:style :swiss :roman :normal)	;HL12
	    :italic (:style :swiss :italic :normal)	;HL12I
	    :bold (:style :swiss :bold :normal)		;HL12B
	    :bold-italic (:style :swiss :bold-italic :normal)	;HL12BI
	    smallcaps (:style :fix :roman :normal)	;CPTFONT
	    typewriter (:style :fix :roman :normal)	;CPTFONT
	    lisp (:style sans-serif-body :bold :normal)	;HL12B
	    programlanguage (:style :fix :roman :normal)	;CPTFONT
	    keyboardinput (:style :fix :roman :normal)	;CPTFONT
	    symbol fonts:symbol12
	    math fonts:math12
	    greek fonts:hippo12)
     :large
     (:face :roman (:style :swiss :roman :large)
	    :italic (:style :swiss :italic :large)
	    :bold (:style :swiss :bold :large)
	    :bold-italic (:style :swiss :bold-italic :large)
	    smallcaps (:style sans-serif-body :roman :normal)
	    typewriter (:style :fix :roman :large)
	    lisp (:style sans-serif-body :bold :large)
	    programlanguage (:style :fix :roman :large)
	    keyboardinput (:style :fix :roman :large)
	    symbol fonts:symbol12
	    math fonts:math12
	    greek fonts:hippo12)
     :small
     (:face :roman (:style :swiss :roman :small)
	    :italic (:style :swiss :italic :small)
	    :bold (:style :swiss :bold :small)
	    :bold-italic (:style :swiss :bold-italic :small)
	    smallcaps (:style :fix :roman :very-small)
	    typewriter (:style :fix :roman :small)
	    lisp (:style sans-serif-body :bold :small)
	    programlanguage (:style :fix :roman :small)
	    keyboardinput (:style :fix :roman :small)
	    symbol fonts:symbol12
	    math fonts:math12
	    greek fonts:hippo12)
     smallbody					;8.5 Helvetica
     (:face :roman (:style sans-serif-body :roman :small)
	    :italic (:style sans-serif-body :italic :small)
	    :bold (:style sans-serif-body :bold :small)
	    :bold-italic (:style sans-serif-body :bold-italic :small)
	    smallcaps (:style :fix :roman :small)
	    typewriter (:style :fix :roman :small)
	    lisp (:style sans-serif-body :bold :small)
	    programlanguage (:style :fix :roman :small)
	    keyboardinput (:style :fix :roman :small)
	    symbol fonts:symbol10		;---
	    math fonts:math10			;---
	    greek fonts:hippo10			;---
	    )
     title2				;10.5 Helvetica Bold
     (:face :roman (:style :swiss :bold :normal)
	    :italic (:style :swiss :bold-italic :normal)
	    :bold (:style :swiss :bold :normal)
	    :bold-italic (:style :swiss :bold-italic :normal)
	    smallcaps (:style :swiss :roman :small)
	    typewriter (:style :fix :roman :normal)
	    lisp (:style :swiss :bold :normal)
	    programlanguage (:style :fix :roman :normal)
	    keyboardinput (:style :fix :roman :normal)
	    symbol fonts:symbol12
	    math fonts:math12
	    greek fonts:hippo12
	    )
     title3				;12.5 Helvetica Bold
     (:face :roman (:style :swiss :bold :large)
	    :italic (:style :swiss :bold-italic :large)
	    :bold (:style :swiss :bold :large)
	    :bold-italic (:style :swiss :bold-italic :large)
	    smallcaps (:style :swiss :roman :normal)
	    typewriter (:style :fix :roman :large)
	    lisp (:style :swiss :bold :large) 
	    programlanguage (:style :fix :roman :large)
	    keyboardinput (:style :fix :roman :large)
	    symbol fonts:symbol12		;---
	    math fonts:math12			;---
	    greek fonts:hippo12			;---
	    )
     title5				;15.5 Helvetica Bold
     (:face :roman (:style :swiss :bold :very-large)
	    :italic (:style :swiss :bold-italic :very-large)
	    :bold (:style :swiss :bold :very-large)
	    :bold-italic (:style :swiss :bold-italic :very-large)
	    smallcaps (:style :swiss :roman :large)
	    typewriter (:style :fix :roman :very-large)
	    lisp (:style :swiss :bold :very-large)
	    programlanguage (:style :fix :roman :very-large) 
	    keyboardinput (:style :fix :roman :very-large)
	    symbol fonts:symbol12		;---
	    math fonts:math12			;---
	    greek fonts:hippo12			;---
	    )
     title6				;10.5 Century Schoolbook roman
     (:face :roman (:style :swiss :bold :normal)
	    :italic (:style :swiss :bold-italic :normal)
	    :bold (:style :swiss :bold :normal)
	    :bold-italic (:style :swiss :bold-italic :normal)
	    smallcaps (:style :swiss :roman :small)
	    typewriter (:style :fix :roman :normal)
	    lisp (:style :swiss :bold :normal)
	    programlanguage (:style :fix :roman :normal)
	    keyboardinput (:style :fix :roman :normal)
	    symbol fonts:symbol12		;---
	    math fonts:math12			;---
	    greek fonts:hippo12			;---
	    ))))

;; This is here so that when sage's character faces escape its own environment
;; (like in bug mail or Spell or something) they won't all have to print with lozenges.
(si:define-character-style-families si:*b&w-screen* si:*standard-character-set*
  ;; it wants to say body = title7 = display = title0 = normal
  ;; heading = title3
  '(:family 1:fix
0    (:size
      :normal					;10.5 Century Schoolbook
     (:face smallcaps (:style :fix :roman :normal)	;CPTFONT
	    typewriter (:style :fix :roman :normal)	;CPTFONT
	    lisp (:style sans-serif-body :bold :normal)	;HL12B
	    programlanguage (:style :fix :roman :normal)	;CPTFONT
	    keyboardinput (:style :fix :roman :normal)	;CPTFONT
	    symbol fonts:symbol12
	    math fonts:math12
	    greek fonts:hippo12)
     :large
     (:face smallcaps (:style sans-serif-body :roman :normal)
	    typewriter (:style :fix :roman :large)
	    lisp (:style sans-serif-body :bold :large)
	    programlanguage (:style :fix :roman :large)
	    keyboardinput (:style :fix :roman :large)
	    symbol fonts:symbol12
	    math fonts:math12
	    greek fonts:hippo12)
     :small
     (:face smallcaps (:style :fix :roman :very-small)
	    typewriter (:style :fix :roman :small)
	    lisp (:style sans-serif-body :bold :small)
	    programlanguage (:style :fix :roman :small)
	    keyboardinput (:style :fix :roman :small)
	    symbol fonts:symbol12
	    math fonts:math12
	    greek fonts:hippo12)
     smallbody					;8.5 Helvetica
     (:face smallcaps (:style :fix :roman :small)
	    typewriter (:style :fix :roman :small)
	    lisp (:style sans-serif-body :bold :small)
	    programlanguage (:style :fix :roman :small)
	    keyboardinput (:style :fix :roman :small)
	    symbol fonts:symbol10		;---
	    math fonts:math10			;---
	    greek fonts:hippo10			;---
	    )
     title2				;10.5 Helvetica Bold
     (:face smallcaps (:style :swiss :roman :small)
	    typewriter (:style :fix :roman :normal)
	    lisp (:style :swiss :bold :normal)
	    programlanguage (:style :fix :roman :normal)
	    keyboardinput (:style :fix :roman :normal)
	    symbol fonts:symbol12
	    math fonts:math12
	    greek fonts:hippo12
	    )
     title3				;12.5 Helvetica Bold
     (:face smallcaps (:style :swiss :roman :normal)
	    typewriter (:style :fix :roman :large)
	    lisp (:style :swiss :bold :large) 
	    programlanguage (:style :fix :roman :large)
	    keyboardinput (:style :fix :roman :large)
	    symbol fonts:symbol12		;---
	    math fonts:math12			;---
	    greek fonts:hippo12			;---
	    )
     title5				;15.5 Helvetica Bold
     (:face smallcaps (:style :swiss :roman :large)
	    typewriter (:style :fix :roman :very-large)
	    lisp (:style :swiss :bold :very-large)
	    programlanguage (:style :fix :roman :very-large) 
	    keyboardinput (:style :fix :roman :very-large)
	    symbol fonts:symbol12		;---
	    math fonts:math12			;---
	    greek fonts:hippo12			;---
	    )
     title6				;10.5 Century Schoolbook roman
     (:face smallcaps (:style :swiss :roman :small)
	    typewriter (:style :fix :roman :normal)
	    lisp (:style :swiss :bold :normal)
	    programlanguage (:style :fix :roman :normal)
	    keyboardinput (:style :fix :roman :normal)
	    symbol fonts:symbol12		;---
	    math fonts:math12			;---
	    greek fonts:hippo12			;---
	    ))))

(si:define-character-style-families si:*b&w-screen* si:*standard-character-set*
  ;; it wants to say body = title7 = display = title0 = normal
  ;; heading = title3
  '(:family 1centuryschoolbook-body
0    (:size
      :normal					;10.5 Century Schoolbook
     (:face :roman fonts:lexi12
	    :italic fonts:lexi12i
	    :bold fonts:lexi12b
	    :bold-italic (:style :dutch :bold-italic :normal)
	    smallcaps (:style :fix :roman :normal)
	    typewriter (:style :fix :roman :normal)
	    lisp (:style centuryschoolbook-body :bold :normal)
	    programlanguage (:style :fix :roman :normal)
	    keyboardinput (:style :fix :roman :normal)
	    symbol fonts:symbol12
	    math fonts:math12
	    greek fonts:hippo12)
     :large
     (:face :roman (:style :dutch :roman :large)
	    :italic (:style :dutch :italic :large)
	    :bold (:style :dutch :bold :large)
	    :bold-italic (:style :dutch :bold-italic :normal)
	    smallcaps (:style :fix :roman :normal)
	    typewriter (:style :fix :roman :normal)
	    lisp (:style centuryschoolbook-body :bold :normal)
	    programlanguage (:style :fix :roman :normal)
	    keyboardinput (:style :fix :roman :normal)
	    symbol fonts:symbol12
	    math fonts:math12
	    greek fonts:hippo12)
     :small
     (:face :roman (:style :dutch :roman :small)
	    :italic (:style :dutch :italic :small)
	    :bold (:style :dutch :bold :small)
	    :bold-italic (:style :dutch :bold-italic :small)
	    smallcaps (:style :fix :roman :small)
	    typewriter (:style :fix :roman :small)
	    lisp (:style centuryschoolbook-body :bold :small)
	    programlanguage (:style :fix :roman :small)
	    keyboardinput (:style :fix :roman :small)
	    symbol fonts:symbol12
	    math fonts:math12
	    greek fonts:hippo12)
     smallbody					;8.5 Helvetica
     (:face :roman (:style :swiss :roman :small)
	    :italic (:style :swiss :italic :small)
	    :bold (:style :swiss :bold :small)
	    :bold-italic (:style :swiss :bold-italic :small)
	    smallcaps (:style centuryschoolbook-body smallcaps :small)
	    typewriter (:style centuryschoolbook-body typewriter :small)
	    lisp (:style centuryschoolbook-body lisp :small)
	    programlanguage (:style centuryschoolbook-body programlanguage :small)
	    keyboardinput (:style centuryschoolbook-body keyboardinput :small)
	    symbol fonts:symbol10		;---
	    math fonts:math10			;---
	    greek fonts:hippo10			;---
	    )
     title2				;10.5 Helvetica Bold
     (:face :roman (:style :swiss :bold :normal)
	    :italic (:style :swiss :bold-italic :normal)
	    :bold (:style :swiss :bold :normal)
	    :bold-italic (:style :swiss :bold-italic :normal)
	    smallcaps (:style centuryschoolbook-body :roman :small)
	    typewriter (:style centuryschoolbook-body typewriter :normal)
	    lisp (:style centuryschoolbook-body :bold :normal)
	    programlanguage (:style centuryschoolbook-body programlanguage :normal)
	    keyboardinput (:style centuryschoolbook-body keyboardinput :normal)
	    symbol fonts:symbol12
	    math fonts:math12
	    greek fonts:hippo12
	    )
     title3				;12.5 Helvetica Bold
     (:face :roman (:style :swiss :bold :large)
	    :italic (:style :swiss :bold-italic :large)
	    :bold (:style :swiss :bold :large)
	    :bold-italic (:style :swiss :bold-italic :large)
	    smallcaps (:style centuryschoolbook-body :roman :normal)
	    typewriter (:style centuryschoolbook-body typewriter :large)
	    lisp (:style centuryschoolbook-body lisp :large) 
	    programlanguage (:style centuryschoolbook-body programlanguage :large)
	    keyboardinput (:style centuryschoolbook-body keyboardinput :large)
	    symbol fonts:symbol12		;---
	    math fonts:math12			;---
	    greek fonts:hippo12			;---
	    )
     title5				;15.5 Helvetica Bold
     ;; This would like to use :very-larger or :much-larger or :larger-larger or :larger2 
     (:face :roman (:style :swiss :bold :very-large)
	    :italic (:style :swiss :bold-italic :very-large)
	    :bold (:style :swiss :bold :very-large)
	    :bold-italic (:style :swiss :bold-italic :very-large)
	    smallcaps (:style :swiss :roman :larger)
	    typewriter (:style :fix :roman :very-large)
	    lisp (:style :swiss :bold :very-large)
	    programlanguage (:style :fix :roman :very-large) 
	    keyboardinput (:style :fix :roman :very-large)
	    symbol fonts:symbol12		;---
	    math fonts:math12			;---
	    greek fonts:hippo12			;---
	    )
     title6				;10.5 Century Schoolbook roman
     (:face :roman (:style centuryschoolbook-body :bold :normal)
	    :italic (:style centuryschoolbook-body :bold-italic :normal)
	    :bold (:style centuryschoolbook-body :bold :normal)
	    :bold-italic (:style centuryschoolbook-body :bold-italic :normal)
	    smallcaps (:style centuryschoolbook-body :roman :small)
	    typewriter (:style :fix :roman :normal)
	    lisp (:style centuryschoolbook-body :bold :normal)
	    programlanguage (:style :fix :roman :normal)
	    keyboardinput (:style :fix :roman :normal)
	    symbol fonts:symbol12		;---
	    math fonts:math12			;---
	    greek fonts:hippo12			;---
	    ))))

(si:define-character-style-families si:*b&w-screen* si:*standard-character-set*
  '(:size
     * (:family
	 1serif-body0 (:face :roman (:style :dutch :roman :same)	;TR12
			   :italic (:style :dutch :italic :same)	;TR12I
			   :bold (:style :dutch :bold :same)	;TR12B
			   :bold-italic (:style :dutch :bold-italic :same)	;TR12BI
			   smallcaps (:style :fix :roman :same)	;CPTFONT
			   typewriter (:style :fix :roman :same)	;CPTFONT
			   lisp (:style :dutch :bold :same)	;TR12B
			   programlanguage (:style :fix :roman :same)	;CPTFONT
			   keyboardinput (:style :fix :roman :same)	;CPTFONT
			   ))
     :normal (:family 1serif-body0 (:face symbol fonts:symbol12
					math fonts:math12
					greek fonts:hippo12))
	  ))

#+Ignore
(defun 1set-up-approachability-translations0 (sizes)
  (condition-bind ((si:invalid-character-style-component
		     (named-lambda si:invalid-character-style-component (condition)
		       (case (send condition :which-component)
			 ((si:family)
			  (send condition :proceed :make-it-valid))))))
    (flet ((change-family (style)
	     (if (eq (si:cs-family style) 'centuryschoolbook-body)
		 (si:intern-character-style 'approachability
					    (si:cs-face style)
					    (si:cs-size style))
		 style)))
      ;; They start out just like centuryschoolbook
      (si:map-over-character-style-translations
	(named-lambda si:map-over-character-style-translations
		      (display-device character-set character-style translation)
	  (when (eq (si:cs-family character-style) 'centuryschoolbook-body)
	    (si:make-character-style-translation
	      (if (and (consp translation)
		       (eql (first translation) :style))
		  `(:style ,(change-family (second translation)))
		  translation)
	      (change-family character-style)
	      display-device character-set)))))
    (loop for (face-letter face-component) in '(("" :roman) ("I" :italic) ("B" :bold))
	  do
      (si:make-character-style-translation
	(format nil "LWCenturySchoolbook84~a" face-letter)
	`(approachability ,face-component smallbody)
	lgp:*lgp2-printer*))
    (dolist (size sizes)
      (let ((size-code (intern (format nil "SIZE~d" size))))
	(si:make-character-style-translation
	  `(:style (approachability :bold ,size-code))
	  `(approachability lisp ,size-code)
	  lgp:*lgp2-printer*)))
    (set-up-outline-translations "Century702Schoolbook~d"
				 'approachability
				 :roman sizes)
    (set-up-outline-translations "Century702Schoolbook-Bold~d"
				 'approachability
				 :bold sizes)
    (set-up-outline-translations "Courier~dB"
				 'approachability
				 'keyboardinput sizes)
    (set-up-outline-translations "Times~dBI"	;---too bad
				 'approachability
				 :bold-italic sizes)
    ))

;; (set-up-approachability-translations '(11 13 14 17 20 21 24 64))

#+Ignore
(defun 1set-up-outline-translations0 (outline-font-format-string cs-family cs-face sizes)
  (dolist (size sizes)
    (let ((cs-size (intern (format nil "SIZE~d" size)))
	  (font (format nil outline-font-format-string size)))
      (unless (find cs-size *usage-code-alist*
		    :test #'member :key #'rest)
	(setq *usage-code-alist*
	      (append *usage-code-alist* (list (list cs-size cs-size)))))
      (let ((this-style
	      (condition-bind ((si:invalid-character-style-component
				 (lambda (cond) (send cond :proceed :make-it-valid))))
		(si:intern-character-style nil nil cs-size)
		(si:intern-character-style cs-family cs-face cs-size))))
	(si:make-character-style-translation
	  font this-style
	  lgp::*lgp2-printer* si:*standard-character-set*)
	(si:make-character-style-translation
	  `(:style ,(si:intern-character-style cs-family cs-face :large))	;---
	  this-style
	  si:*b&w-screen* si:*standard-character-set*))))
  (si:invalidate-all-character-style-caches)
  )

#+Ignore
(defun 1set-up-bogus-outline-translations0 (cs-family cs-face sizes)
  (dolist (size sizes)
    (let ((cs-size (intern (format nil "SIZE~d" size)))
	  (font (list :style (si:intern-character-style cs-family :bold :normal))
		))
      (unless (find cs-size *usage-code-alist*
		    :test #'member :key #'rest)
	(setq *usage-code-alist*
	      (append *usage-code-alist* (list (list cs-size cs-size)))))
      (let ((this-style
	      (condition-bind ((si:invalid-character-style-component
				 (lambda (cond) (send cond :proceed :make-it-valid))))
		(si:intern-character-style nil nil cs-size)
		(si:intern-character-style cs-family cs-face cs-size))))
	(si:make-character-style-translation
	  `(:style ,(si:intern-character-style cs-family cs-face :large))	;---
	  this-style
	  si:*b&w-screen* si:*standard-character-set*))))
  (si:invalidate-all-character-style-caches)
  )

#+Ignore
(defun set-up-the-outline-translations (for-real)
  (let ((sizes '(11 13 14 17 20 21 24 64)))
    (cond (for-real
	   (set-up-outline-translations "Century702Schoolbook"
					'centuryschoolbook-body
					:roman sizes)
	   (set-up-outline-translations "Century702Schoolbook"
					'sans-serif-body	;---
					:roman sizes))
	  (T (set-up-bogus-outline-translations
	       'centuryschoolbook-body :roman sizes)
	     (set-up-bogus-outline-translations
	       'sans-serif-body :roman sizes)))))

#+Ignore
(set-up-the-outline-translations nil)

(defvar 1*screen-default-character-style*0 '(sans-serif-body :roman :normal))
;;(defvar 1*lgp1-default-character-style*0 '(centuryschoolbook-body :roman :normal))
(defvar 1*lgp2-default-character-style*0 '(centuryschoolbook-body :roman :normal))
(defvar 1*dmp1-default-character-style*0 '(normal-body :roman :normal))

(export '(*screen-default-character-style*
	   ;;*lgp1-default-character-style*
	   *lgp2-default-character-style*
	   *dmp1-default-character-style*))

;;(defvar 1*lgp1-default-heading-character-style*0 '(:fix :italic :normal))
(defvar 1*lgp2-default-heading-character-style*0 '(:swiss :italic :small))
(defvar 1*dmp1-default-heading-character-style*0 '(:fix :italic :normal))

;;; Alist of symbolic face codes to Lisp Machine style faces.
;;; You must define new style families if you add any faces to this alist.
(defvar 1*face-code-alist*
0	'((R :roman)
	  (B :bold)
	  (I :italic)
	  (P :bold-italic)
	  (C smallcaps)				;this is supposed to be small caps
	  (T typewriter)
	  (L lisp)				;for Lisp face
	  (F programlanguage)			;for "foreign language" reserved words--see SR
	  (K keyboardinput)			;for keys
	  (S symbol)
	  (M math)
	  (G greek)
;    (A :italic)
;    (E ?)
;    (U ?)
;    (Y ?)
;    (Z ?)
	  ))

;; This is an alist of char-style-face-code, things-that-map-to-preferred
;; ---It really wants to be per-device
;; See also set-up-outline-translations
(defvar 1*usage-code-alist*
0	'((:normal chardef bodyfont displayfont titlefont7 titlefont0)
	  (smallbody smallbodyfont)
	  (title2 titlefont2)
	  (title3 titlefont3 headingfont)
	  (title5 titlefont5)
	  (title6 titlefont6)
	  ))

(defun 1symbol-for-editor-buffer0 (name &key (error-p T))
  (macrolet ((ch (c)
	       `',(code-char (send *editor-symbols-character-set* :name-char c))))
    (case name
      (open-L (ch "open-L"))
      (close-L (ch "close-L"))
      (tab-to-tab-stop (ch "tab"))
      (collect-right-flushing (ch "tab-right-flush"))
      (collect-centering (ch "tab-center"))
      ((em em-dash) (ch "em-dash"))
      (literal-space (ch "space"))
      (abbreviation-period (ch "period"))
      (otherwise
	(cond (error-p
	       (error "The symbol ~s is not among those defined (internal error)" name))
	      (T nil)))
      )))

(eval-when (compile load eval)
(si:define-character-style-families si:*b&w-screen* si:*standard-character-set*
  '(:size :normal
    (:face 1symbols-in-editor-buffer
0     (:family sans-serif-body fonts:edsymbol12
	      serif-body fonts:edsymbol12
	      normal-body fonts:edsymbol12
	      centuryschoolbook-body fonts:edsymbol12
	      :fix fonts:edsymbol12))))
)

(defun 1old-symbol-for-editor-buffer0 (name)
  (macrolet ((ch (c)
	       `',(make-character c :style '(nil symbols-in-editor-buffer nil))))
    (ecase name
      (open-L (ch #\a))
      (close-L (ch #\b))
      (tab-to-tab-stop (ch #\c))
      (collect-right-flushing (ch #\d))
      (collect-centering (ch #\e))
      (em-dash (ch #\-))
      (literal-space (ch #\space))
      (abbreviation-period (ch #\.))
      )))
