;;-*- Syntax: Common-lisp; Mode: Lisp; Package: Nsage; Lowercase: T; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;Parts of the Sage formatter having to do with filling, 
;; assembling lines, and annotating them.

(defunD,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB") annotate-line-breaks-for-filling0 (gbox)
  (when gbox
    (loop with x = (send (send gbox :environment) :left-margin)
	  with gbox = gbox
	  do (multiple-value-setq (gbox x) (send gbox :consider-line-breaks-for-filling x))
	  while gbox)))

;;1:consider-line-breaks-for-filling 
0;;Each gbox is asked to break lines where appropriate.  Each method returns the next
;;gbox to be looked at, and the x where (that next) will be placed.  The next gbox
;;is normally the successor of the current gbox, except that when a newline is inserted
;;somewhere before the current one, the continuation point is at that newline.

(defmethod1 (:consider-line-breaks-for-filling0 1basic-gbox0 1:default)0 (x)
  (values next x))

(defmethod 1(:consider-line-breaks-for-filling0 1space-gbox)0 (x)
  (let ((x-past-width (hposition+ environment x width)))
    (ecase (send environment :fill-mode)
      ((centered flushleft flushright)
       (let* ((overlong-line-action (send environment :overlong-line-action))
	      (right-edge
		(ecase overlong-line-action
		  ((chop wrap) (- (send environment :paper-width)
				  (send environment :right-margin)))
		  (keep (send environment :paper-width)))))
	 (if (< x-past-width right-edge)
	     (values next x-past-width)
	     (ecase overlong-line-action
	       (chop (splice-box-out self)
		     (when *signal-line-too-long*
		       (signal 'line-too-long :string (string #\space)
			       :start-index 0
			       :end-index 1
			       :losing-start 0
			       :losing-end 1
			       :line-action overlong-line-action))
		     (values next right-edge))
	       ((wrap keep)
		(let ((prev-text (gbox-prev-text self))
		      (xpos (ecase overlong-line-action
				      (wrap (+ (send environment :left-margin)
					       (send environment :indention)))
				      (keep 0))))
		  (cond ((or (null prev-text)
			     (send prev-text :ends-with-newline?))
			 (splice-replace-box
			   self (make-cursor-motion-gbox environment xpos nil))
			 (when *signal-line-too-long*
			   (signal 'line-too-long :string (string #\space)
				   :start-index 0
				   :end-index 1
				   :losing-start 0
				   :losing-end 1
				   :line-action overlong-line-action))
			 (values next xpos))
			(t (splice-boxes-after
			     prev (make-newline-gbox environment)
			     (make-cursor-motion-gbox environment xpos nil))
			   (when *signal-line-too-long*
			     (signal 'line-too-long :string (string #\space)
				     :start-index 0
				     :end-index 1
				     :losing-start 0
				     :losing-end 1
				     :line-action overlong-line-action))
			   (values self xpos)))))))))
      (fill
	(if (< x-past-width (+ (send environment :left-margin)
			       (send environment :line-width)))
	    (values next x-past-width)
	    (let ((newline (make-newline-gbox environment)))
	      (splice-replace-box self newline)
	      (values newline :unknown)))))))

(defmethod 1(:consider-line-breaks-for-filling0 1tab-character-gbox)0 (x)
  (let* ((left-margin (send environment :left-margin))
	 (tab-distance (* 8. width))		;tab stops are eight spaces apart
	 (x-before-width (hposition+ environment x))
	 (minimum-x-past-width (+ x-before-width width))	;tab at least 1 space
	 (x-past-width
	   (loop for stop = left-margin then (+ stop tab-distance)
		 when (> stop minimum-x-past-width)
		   return stop)))
    (ecase (send environment :fill-mode)
      (fill
	(cond ((< x-past-width (+ left-margin (send environment :line-width)))
	       (setq width (- x-past-width x-before-width))
	       (values next x-past-width))
	      (T (splice-box-before self (make-newline-gbox environment))
		 (setq width tab-distance)
		 (values next (+ left-margin tab-distance)))))
      ((centered flushleft flushright)
       (let* ((overlong-line-action (send environment :overlong-line-action))
	      (right-edge
		(ecase overlong-line-action
		  ((chop wrap) (- (send environment :paper-width)
				  (send environment :right-margin)))
		  (keep (send environment :paper-width)))))
	 (cond ((< x-past-width right-edge)
		(setq width (- x-past-width x-before-width))
		(values next x-past-width))
	       (t (ecase overlong-line-action
		    (chop (splice-box-out self)
			  (when *signal-line-too-long*
			    (signal 'line-too-long :string (string #\tab)
				    :start-index 0
				    :end-index 1
				    :losing-start 0
				    :losing-end 1
				    :line-action overlong-line-action))
			  (values next right-edge))
		    ((wrap keep)
		     (let ((prev-text (gbox-prev-text self))
			   (xpos (ecase overlong-line-action
				   (wrap (+ (send environment :left-margin)
					    (send environment :indention)))
				   (keep 0))))
		       (cond ((or (null prev-text)
				  (send prev-text :ends-with-newline?))
			      (splice-replace-box
				self (make-cursor-motion-gbox environment xpos nil))
			      (when *signal-line-too-long*
				(signal 'line-too-long :string (string #\tab)
					:start-index 0
					:end-index 1
					:losing-start 0
					:losing-end 1
					:line-action overlong-line-action))
			      (values next xpos))
			     (t (splice-boxes-after
				  prev (make-newline-gbox environment)
				  (make-cursor-motion-gbox environment xpos nil))
				(when *signal-line-too-long*
				  (signal 'line-too-long :string (string #\tab)
					  :start-index 0
					  :end-index 1
					  :losing-start 0
					  :losing-end 1
					  :line-action overlong-line-action))
				(values self xpos)))))))))))))

(defun-in-flavor (1wrap-long-line0 string-gbox)
	      (overlong-line-action font place-to-chop x-past-width)
  (cond ((or (null place-to-chop)
	     ( place-to-chop start-index))
	 ;; Whole string is lost
	 (let ((prev-text (gbox-prev-text self))
	       (xpos (ecase overlong-line-action
		       (wrap (+ (send environment :left-margin)
				(send environment :indention)))
		       (keep 0))))
	   (cond ((or (null prev-text)
		      (send prev-text :ends-with-newline?))
		  ;; Weird.  Some very wide single char at beginning of string.
		  ;; Get rid of that char and try again.
		  (cond ((> (- end-index start-index) 1)
			 (incf start-index)
			 (send self :width-annotate font)
			 (splice-box-before
			   self (make-cursor-motion-gbox environment xpos nil))
			 (when *signal-line-too-long*
			   (signal 'line-too-long :string string
				   :start-index (1- start-index)
				   :end-index end-index
				   :losing-start (1- start-index)
				   :losing-end end-index
				   :line-action overlong-line-action))
			 (values self xpos))
			(t (splice-replace-box
			     self (make-cursor-motion-gbox environment xpos nil))
			   (when *signal-line-too-long*
			     (signal 'line-too-long :string string
				     :start-index start-index
				     :end-index end-index
				     :losing-start start-index
				     :losing-end end-index
				     :line-action overlong-line-action))
			   (values next xpos))))
		 (t (splice-boxes-after
		      prev (make-newline-gbox environment)
		      (make-cursor-motion-gbox environment xpos nil))
		    (when *signal-line-too-long*
		      (signal 'line-too-long :string string
			      :start-index start-index
			      :end-index end-index
			      :losing-start start-index
			      :losing-end end-index
			      :line-action overlong-line-action))
		    (values self xpos)))))
	(( place-to-chop end-index)
	 (values next x-past-width))
	(t (let ((xpos (ecase overlong-line-action
			 (wrap (+ (send environment :left-margin)
				  (send environment :indention)))
			 (keep 0)))
		 (new (make-string-gbox environment string place-to-chop end-index)))
	     (send new :width-annotate font)
	     (splice-boxes-after self (make-newline-gbox environment)
				 (make-cursor-motion-gbox environment xpos nil) new)
	     (when *signal-line-too-long*
	       (signal 'line-too-long :string string
		       :start-index start-index
		       :end-index end-index
		       :losing-start place-to-chop
		       :losing-end end-index
		       :line-action overlong-line-action))
	     (setq end-index place-to-chop)
	     (send self :width-annotate font)
	     (values new xpos)))))

(defun-in-flavor (1chop-long-line0 string-gbox)
	      (overlong-line-action font place-to-chop x x-past-width right-edge)
  (cond ((or (null place-to-chop)
	     ( place-to-chop start-index))
	 ;; Whole string is lost
	 (ecase (send environment :fill-mode)
           ((centered flushleft flushright)
	    (splice-box-out self)
	    (when *signal-line-too-long*
	      (signal 'line-too-long :string string
		      :start-index start-index
		      :end-index end-index
		      :losing-start start-index
		      :losing-end end-index
		      :line-action overlong-line-action))
	    (values next right-edge))
	   (fill
	     ;; In fill mode we want to salvage any part of the string
	     ;; that follows a space and can be moved down to next line.
	     ;; -----When hyphenbreak, look for hyphens.
	     (let ((space-loc (string-search-char #\space string :start start-index :end end-index))
		   (prev-text (gbox-prev-text self)))
	       (cond ((null space-loc)		;No space
		      (splice-box-out self)
		      (when *signal-line-too-long*
			(signal 'line-too-long :string string
				:start-index start-index
				:end-index end-index
				:losing-start start-index
				:losing-end end-index
				:line-action overlong-line-action))
		      (values next right-edge))
		     ((= space-loc start-index)	;Space is first
		      (cond ((= end-index (1+ start-index))
			     (cond ((or (null prev-text)
					(send prev-text :ends-with-newline?))
				    (splice-box-out self)
				    (values next x))
				   (t (let ((newline (make-newline-gbox environment)))
					(splice-replace-box self newline)
					(values newline x)))))
			    (t (incf start-index)
			       (send self :width-annotate font)
			       (unless (or (null prev-text)
					   (send prev-text :ends-with-newline?))
				 (splice-box-before self (make-newline-gbox environment)))
			       (values self :start-of-line))))
		     (( (1+ space-loc) end-index)	;Space is last
		      (cond ((or (null prev-text)
				 (send prev-text :ends-with-newline?))
			     (splice-box-out self)
			     (when *signal-line-too-long*
			       (signal 'line-too-long :string string
				       :start-index start-index
				       :end-index end-index
				       :losing-start start-index
				       :losing-end end-index
				       :line-action overlong-line-action))
			     (values next x))
			    (t (let ((newline (make-newline-gbox environment)))
				 (splice-replace-box self newline)
				 (when *signal-line-too-long*
				   (signal 'line-too-long :string string
					   :start-index start-index
					   :end-index end-index
					   :losing-start start-index
					   :losing-end end-index
					   :line-action overlong-line-action))
				 (values newline x)))))
		     (t (when *signal-line-too-long*
			  (signal 'line-too-long :string string
				  :start-index start-index
				  :end-index (1+ space-loc)
				  :losing-start start-index
				  :losing-end (1+ space-loc)
				  :line-action overlong-line-action))
			(setq start-index (1+ space-loc))
			(send self :width-annotate font)
			(unless (or (null prev-text)
				    (send prev-text :ends-with-newline?))
			  (splice-box-before self (make-newline-gbox environment)))
			(values self :start-of-line)))))))
	(( place-to-chop end-index)
	 (values next x-past-width))
	(t (ecase (send environment :fill-mode)
	     ((centered flushleft flushright)
	      (when *signal-line-too-long*
		(signal 'line-too-long :string string
			:start-index start-index
			:end-index end-index
			:losing-start place-to-chop
			:losing-end end-index
			:line-action overlong-line-action))
	      (setq end-index place-to-chop)
	      (send self :width-annotate font)
	      (values next right-edge))
	     (fill
	       ;; In fill mode we want to salvage any part of the string
	       ;; that follows a space and can be moved down to next line.
	       ;; -----When hyphenbreak, look for hyphens.
	       (let ((space-loc (string-search-char #\space string :start place-to-chop :end end-index)))
		 (cond ((null space-loc)	;No space
			(when *signal-line-too-long*
			  (signal 'line-too-long :string string
				  :start-index start-index
				  :end-index end-index
				  :losing-start place-to-chop
				  :losing-end end-index
				  :line-action overlong-line-action))
			(setq end-index place-to-chop)
			(send self :width-annotate font)
			(values next right-edge))
		       (( (1+ space-loc) end-index)	;Space is last
			(when *signal-line-too-long*
			  (signal 'line-too-long :string string
				  :start-index start-index
				  :end-index (1+ space-loc)
				  :losing-start place-to-chop
				  :losing-end (1+ space-loc)
				  :line-action overlong-line-action))
			(setq end-index place-to-chop)
			(send self :width-annotate font)
			(splice-boxes-after self (make-newline-gbox environment))
			(values next :unknown))
		       (t
			(let ((new (make-string-gbox environment string (1+ space-loc)
						     end-index)))
			  (send new :width-annotate font)
			  (splice-boxes-after self (make-newline-gbox environment) new)
			  (when *signal-line-too-long*
			    (signal 'line-too-long :string string
				    :start-index start-index
				    :end-index (1+ space-loc)
				    :losing-start place-to-chop
				    :losing-end (1+ space-loc)
				    :line-action overlong-line-action))
			  (setq end-index place-to-chop)
			  (send self :width-annotate font)
			  (values next :unknown))))))))))

(defun-in-flavor (1wrap-or-chop-long-line0 string-gbox) (x x-past-width)
  (let* ((overlong-line-action (send environment :overlong-line-action))
	 (right-edge
	   (ecase overlong-line-action
	     ((chop wrap) (- (send environment :paper-width)
			     (send environment :right-margin)))
	     (keep (send environment :paper-width)))))
    (if (< x-past-width right-edge)
	(values next x-past-width)
	(multiple-value-bind (font place-to-chop)
	    (ecase overlong-line-action
	      ;; even though we're not in a filled environment, Scribe
	      ;; seems to back up to the most recent space rather than
	      ;; just chopping the word in half.  Never accuse us of not
	      ;; being bug-for-bug compatible.
	      (wrap (find-place-to-break string start-index end-index environment
					 (hposition+ environment x) right-edge #'false))
	      ((chop keep)
	       (find-place-to-chop string start-index end-index environment
				   (hposition+ environment x) right-edge)))
	  (ecase overlong-line-action
	    ((wrap keep)
	     (wrap-long-line overlong-line-action font place-to-chop x-past-width))
	    (chop (chop-long-line overlong-line-action font place-to-chop x x-past-width
				  right-edge)))))))

(defun-in-flavor (1force-string-gbox-line-break0 string-gbox) (x x-past-width)
  (let ((next-line) (x-there))
    (loop for gbox = prev then (box-prev gbox)
	  while gbox
	  do (multiple-value-setq (next-line x-there)
	       (send gbox :attempt-line-break))
	  when next-line
	  do (if (eq next-line :no-further)
		 (setq next-line ())
		 next-line)
	  and do (return))
    (if next-line
	(values next-line x-there)
	(wrap-or-chop-long-line x x-past-width))))

(defmethod 1(:consider-line-breaks-for-filling0 1string-gbox)0 (x)
  (let ((x-past-width (hposition+ environment x width)))
    (ecase (send environment :fill-mode)
      ((centered flushleft flushright)
       (wrap-or-chop-long-line x x-past-width))
      (fill
	(let ((right-edge (- (send environment :paper-width)
			     (send environment :right-margin))))
	  (cond ((< x-past-width right-edge)
		 (values next x-past-width))
		(T
		 (flet ((should-I-hyphenate (spaces-to-left-of-point space-width x-at-point)
			  ;;--- This is too simplistic, because it ignores
			  ;; everything about the envr attributes of the spaces it
			  ;; is imagining it could stretch.  Rather than make it
			  ;; do a better job following the Scribe model, rewrite all
			  ;; this to follow the TeX model.
			  (let* ((spaces-to-left-of-box
				   (count-spaces-from-gbox-back-to-beginning-of-line prev))
				 (total-stretch-needed (- right-edge x-at-point))
				 (one-space-stretch (- (send environment :widest-blank)
						       space-width))
				 (total-stretchable
				   (* (+ spaces-to-left-of-box
						 spaces-to-left-of-point)
				      one-space-stretch)))
			    #+Ignore
			    (format T "~&~a hyphenate - need ~d, have ~d (~d @ ~d)"
				    (if (< total-stretchable total-stretch-needed)
					"Will"
					"Refuse to")
				    total-stretch-needed total-stretchable
				    (+ spaces-to-left-of-box
				       spaces-to-left-of-point)
				    one-space-stretch)
			    (and (< total-stretchable total-stretch-needed)
				 ;; If we were to stretch the spaces,
				 ;; it wouldn't fill the line.
				 (send environment :hyphenation)))))
		   (multiple-value-bind (font place-to-break break-upon-or-after)
		       (find-place-to-break string start-index end-index
					    environment (hposition+ environment x) right-edge
					    #'should-I-hyphenate)
		     (cond ((null place-to-break)
			    (force-string-gbox-line-break x x-past-width))
			   ((and (= place-to-break start-index)	;the space is first...
				 (eq break-upon-or-after (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI"):replace0))	;...and going
			    (cond ((= end-index (1+ start-index))	;only that space
				   (let ((newline (make-newline-gbox environment)))
				     (splice-replace-box self newline)
				     (values newline :unknown)))
				  (T (incf start-index)
				     (splice-box-before self (make-newline-gbox environment))
				     (send self :width-annotate font)
				     (values self :start-of-line))))
			   (( (1+ place-to-break) end-index)	;the space is last
			    (splice-boxes-after self (make-newline-gbox environment))
			    (ecase break-upon-or-after
			      (2:replace0 (decf end-index))
			      (2:after0 )
			      (:hyphenate
				(splice-boxes-after self
						    (make-string-gbox environment "-" 0 1))))
			    (send self :width-annotate font)
			    (values next (hposition+ environment x width)))
			   (T (let ((new (make-string-gbox environment string
							   (ecase break-upon-or-after
							     (2:replace0 (1+ place-to-break))
							     ((2:after0 :hyphenate)
							      place-to-break))
							   end-index)))
				#+Ignore
				(format T "~&--Doing break ~s || ~s"
					(substring string start-index place-to-break)
					(substring string place-to-break end-index))
				(send new :width-annotate font)
				(if (eq break-upon-or-after :hyphenate)
				    (let ((hyphen (make-string-gbox environment "-" 0 1)))
				      (send hyphen :width-annotate font)
				      (splice-boxes-after self hyphen
							  (make-newline-gbox environment)
							  new))
				    (splice-boxes-after self (make-newline-gbox environment)
							new))
				(setq end-index place-to-break)
				(send self :width-annotate font)
				#+Ignore
				(when (> (hposition+ environment x width) right-edge)
				  (break "~&Returning ~s ~d" next
					 (hposition+ environment x width)))
				(values new :start-of-line)))))))))))))

(defun 1count-spaces-from-gbox-back-to-beginning-of-line0 (gbox)
  (loop for box = gbox then (box-prev box)
	while (and box (not (typep box 'newline-gbox)))
	sum (count-spaces-in-gbox box)))

(defgeneric 1count-spaces-in-gbox0 (basic-gbox)
  (:method (basic-gbox :default) 0)
  (:method (doubly-linked-list-head :default) 0)
  (:method (space-gbox) 1)
  (:method (string-gbox)
   (count #\space string :start start-index :end end-index :test #'char-equal)))

(defun 1break-word-at-hyphen-if-possible0 (word hyphen-break font width-available)
  (when hyphen-break
    (flet ((find-previous-hyphen (end)
	     (string-search-set hyphen-break word :from-end t :end end)))
      (let ((word-length (length word)))
	(loop for hyphen-position = (find-previous-hyphen word-length)
				then (find-previous-hyphen hyphen-position)
	    while hyphen-position
	    do
	(unless (or (= (+ hyphen-position 2) word-length)
		    (= hyphen-position 1))
	  ;; don't hyphenate here if we're going to end up with something like "foo-
	  ;; b" or "f-
	  ;; bar".
	  (let ((chunk-width (micron-width-of-string
			       font word 0 (1+ hyphen-position))))
	    (when ( chunk-width width-available)
	      (return-from break-word-at-hyphen-if-possible
		(values (1+ hyphen-position) :after))))))))))


(defmacro 1map-over-chunks0 ((string string-start string-end chunk-ends)
			   (chunk-var chunk-start-var chunk-end-var char-var)
			   &body body)
  `(map-over-chunks-1 ,string ,string-start ,string-end ,chunk-ends
		      (dw:named-continuation map-over-chunks
					     (,chunk-var ,chunk-start-var ,chunk-end-var
					      ,char-var)
			,@body)))

(defun 1map-over-chunks-10 (string start-index end-index chunk-ends continuation)
  (loop	for start = start-index then (1+ chunk-end)
	for real-chunk-end = (string-search-set chunk-ends string :start start :end end-index)
	for chunk-end = (or real-chunk-end end-index)
	do
    (sys:with-stack-array (chunk (- chunk-end start) :element-type 'character)
      (replace chunk string :start2 start :end2 chunk-end)
      (let ((match-char (and real-chunk-end (aref string chunk-end))))
	(funcall continuation chunk start chunk-end match-char))
      (unless real-chunk-end (loop-finish)))))

(defun1 find-place-to-break0 (string start-index end-index environment
			    x right-edge should-I-hyphenate)
  (declare (values font place-to-break break-upon-or-after))
  (let* ((font (gbox-font-from-environment environment))
	 (space-width (micron-width-of-string font " "))
	 (place-to-break ())
	 (break-upon-or-after ())
	 (x-at-start-of-chunk x))
    (block do-it
      (map-over-chunks (string start-index end-index " ")
		       (chunk chunk-start chunk-end space-char)
	(ignore space-char)
	(let ((chunk-width (micron-width-of-string font chunk)))
	  (cond (( (+ x-at-start-of-chunk chunk-width) right-edge)
		 ;; This word doesn't fit.
		 ;; Quickly check to see if breaking at hyphenbreak would satisfy us.
		 ;; This doesn't negotiate; i.e., if breaking at the hyphen means we
		 ;; have to stretch whitespace more than, say, breaking after the hyphen
		 ;; would, we don't handle that well.  We still need a "penalty" scheme.
		 (when (send environment :hyphen-may-cause-line-break)
		   (multiple-value-bind (break upon-or-after)
		       (break-word-at-hyphen-if-possible
			 chunk *hyphen-chars*
			 font (- right-edge x-at-start-of-chunk))
		     (when break
		       (setq place-to-break (+ break chunk-start)
			     break-upon-or-after upon-or-after)
		       (return-from do-it (values)))))
		 ;; Ok.  Try hyphenating it.
		 (when (funcall should-I-hyphenate
				(count #\space chunk
				       :test #'char-equal)
				space-width
				x-at-start-of-chunk)
		   ;; break the word down at possible hyphens, because hyphens
		   ;; screw the hyphenator.
		   (map-over-chunks (chunk 0 (length chunk) *hyphen-chars*)
				    (sub-chunk sub-start sub-end char)
		     (ignore sub-end)
		     (let ((sub-chunk-width (micron-width-of-string font sub-chunk))
			   (hyphen-width (or (and char (micron-width-of-char font char))
					     0)))
		       (cond (( (+ x-at-start-of-chunk sub-chunk-width hyphen-width)
				 right-edge)
			      (multiple-value-bind (break upon-or-after)
				  (attempt-word-hyphenation
				    font sub-chunk
				    (- right-edge x-at-start-of-chunk))
				(when break
				  (setq place-to-break (+ break chunk-start sub-start)
					break-upon-or-after upon-or-after)))
			      (return-from do-it (values)))
			     (t (incf x-at-start-of-chunk sub-chunk-width)
				(incf x-at-start-of-chunk hyphen-width))))))
		 (return-from do-it (values)))
		(( (+ x-at-start-of-chunk chunk-width space-width)
		    right-edge)
		 ;; The word fits, but the space following it doesn't.
		 ;; Just get replace the space.
		 (setq place-to-break chunk-end
		       break-upon-or-after :replace)
		 (return-from do-it (values)))
		(( (1+ chunk-end) end-index)
		 ;;The space fits too, but is at the end of the string
		 (setq place-to-break chunk-end
		       break-upon-or-after :replace)
		 (return-from do-it (values)))
	  (T
	   ;; This word fit.  Set up to replace the space at its end,
	   ;; if the next one doesn't.
	   (setq place-to-break chunk-end
		 break-upon-or-after :replace)
	   (incf x-at-start-of-chunk
		 (+ chunk-width space-width)))))
	))
    (values font place-to-break break-upon-or-after)))

(defun 1attempt-word-hyphenation0 (font string width-available)
  (declare (values place-to-break break-upon-or-after))
  ;; well, maybe there's weird punctuation around it, or in it.---
  (macrolet ((dbformat (format-string &rest format-args)
	       #+Ignore
	       `(format T ,format-string ,@format-args)))
  (let ((real-start (position-if #'alpha-char-p string)))
    (when real-start
      (let ((real-end (position-if-not #'alpha-char-p string :start real-start)))
	(when (null real-end) (setq real-end (length string)))
	(let ((hyphen-width (micron-width-of-string font "-"))
	      (width-of-prologue (micron-width-of-string font string 0 real-start))
	      (width-of-epilogue (micron-width-of-string font string real-end))
	      place-to-break break-upon-or-after)
	  (decf width-available (+ width-of-prologue width-of-epilogue))

	  (sys:with-stack-array (word (- real-end real-start) :element-type 'character)
	    (replace word string :start2 real-start :end2 real-end)

	    (funcall-with-hyphenation-vector
	      word
	      (named-lambda funcall-with-hyphenation-vector (hv)
		(loop with x-at-start-of-chunk = 0
		      for start = 0 then break
		      for break being array-elements of hv
		      do
		  (let ((chunk-width (micron-width-of-string font word start break)))
		    (cond (( (+ x-at-start-of-chunk chunk-width) width-available)
			   ;; This chunk doesn't fit.
			   (dbformat "~&In ~s, chunk ~s doesn't fit"
				     word (substring word start break))
			   (loop-finish))
			  (( (+ x-at-start-of-chunk chunk-width hyphen-width)
			      width-available)
			   ;; The word fits, but a hyphen following it doesn't.
			   (dbformat "~&In ~s, chunk ~s fits, but following hyphen doesn't"
				     word (substring word start break))
			   (loop-finish))
			  (T
			   ;; This chunk fit.  Set up to break after it,
			   ;; if the next chunk doesn't fit.
			   (dbformat "~&In ~s, chunk ~s fits."
				     word (substring word start break))
			   (setq place-to-break break
				 break-upon-or-after :hyphenate)
			   (incf x-at-start-of-chunk chunk-width))))))))
	  (when place-to-break
	    (dbformat "~&Breaking word ~s as \"~a-~a\""
		    (substring string real-start)
		    (substring string real-start (+ real-start place-to-break))
		    (substring string (+ real-start place-to-break)))
	    (values (+ real-start place-to-break) break-upon-or-after))))))))

;;; Returns the index of the first character that won't fit on
;;; the current line.  Doesn't try to break at word boundaries.
;;; This is for unfilled environments, or filled ones when the
;;; line can't be broken any other way.
(defun 1find-place-to-chop0 (string start-index end-index environment x right-edge)
  (declare (values font place-to-chop))
  (let ((font (gbox-font-from-environment environment))
	(max-width (- right-edge x))
	(place-to-chop))
    (when (plusp max-width)
      (setq place-to-chop
	    (decoding-array (str string)
	      (loop with width = 0
		    for i from start-index below end-index
		    do (incf width (micron-width-of-char font (aref str i)))
		    when ( width max-width)
		      return i
		    finally (return end-index)))))
    (values font place-to-chop)))

(defmethod1 (:consider-line-breaks-for-filling0 1newline-gbox)0 (x)
  x
  (values next :start-of-line))

(defmethod 1(:consider-line-breaks-for-filling0 1paragraph-break-gbox)0 (x)
  x
  (values next (ecase break-type
		 (normal (if indented :start-of-paragraph :start-of-line))
		 (limited :start-of-line))))

(defmethod 1(:consider-line-breaks-for-filling pseudo-paragraph-break-gbox)0 (x)
  x
  (values next (ecase break-type
		 (normal (if indented :start-of-paragraph :start-of-line))
		 (limited :start-of-line))))

(defmethod 1(:consider-line-breaks-for-filling0 1cursor-motion-gbox)0 (x)
  (values next (or x-position x)))

(defun-in-flavor (1set-tab-command-widths0 command-gbox) (x-arg)
  (let ((x (hposition+ environment x-arg))
	(left-margin (send environment :left-margin)))
    (flet ((find-tab (k)
	     (declare (sys:downward-function))
	     (if (< k left-margin)
		 left-margin
		 (dolist (stop (send environment :tab-stops))
		   (when (< k stop) (return stop))))))
      (case command-name
	((collect-right-flushing collect-centering)
	 (multiple-value-bind (text-width next-gbox)
	     (loop for gbox = next then (box-next gbox)
		   until (or (null gbox) (send gbox :tab-terminating-gbox?))
		   sum (send gbox :width) into text-width
		   finally (return (values text-width gbox)))
	   (let* ((x-after-text (+ x text-width))
		  (line-width (send environment :line-width))
		  (next-x (or (and next-gbox
				   (send next-gbox :tab-terminating-tab-gbox?)
				   (find-tab x-after-text))
			      (let ((right (+ left-margin line-width)))
				(if (< x-after-text right) right ())))))
	     (cond ((null next-x)
		    (let ((newline (make-hard-newline-gbox environment)))
		      (splice-box-before self newline)
		      (unless (< text-width line-width)
			(splice-box-out self))	;hopeless to try to right flush, so punt
		      (values newline :start-of-line)))
		   (T (ecase command-name
			(collect-centering
			  (setq width (floor (- next-x x-after-text) 2))
			  (when next-gbox (send next-gbox :splice-other-end-of-centering-tab))
			  (values next (+ x width)))
			(collect-right-flushing
			  (setq width (- next-x x-after-text))
			  (when (minusp width)
			    (zl:fsignal "Neg width ~s next-x ~s x-after-text ~s text-width ~s"
				     width next-x x-after-text text-width))
			  (values next (+ x width -1))	;one micron less in case of roundoff?
			  )))))))
	(tab-to-tab-stop
	 (let ((next-x (find-tab x)))
	   (cond (next-x
		  (setq width (- next-x x))
		  (values next next-x))
		 ((and next (send next :tab-terminating-tab-gbox?))
		  (splice-box-out self)
		  (values next x))
		 (T ;;we're past all tab stops, turn into a newline
		  (let ((newline (make-hard-newline-gbox environment)))
		    (splice-replace-box self newline)
		    (values newline :start-of-line))))))))))

(defmethod 1(:splice-other-end-of-centering-tab0 1basic-gbox0 1:default)0 ()
  ())
(defmethod 1(:splice-other-end-of-centering-tab0 1command-gbox)0 ()
  (case command-name
    ((collect-centering collect-right-flushing)
     (splice-box-before self (make-command-gbox environment 'tab-to-tab-stop)))
    (otherwise ())))

(defmethod1 (:consider-line-breaks-for-filling0 1command-gbox)0 (x)
  (command-gbox-consider-line-breaks-for-filling self x))

(define-command-gbox-generic 1command-gbox-consider-line-breaks-for-filling0 (x)
  (values next x))

(define-command-gbox-method 1(command-gbox-consider-line-breaks-for-filling
0			      1dynamic-left-margin)
0			    (x)
  (flet ((make-mm (microns) (/ microns 1e3)))
    (let ((global-margin (send environment :toplevel-attribute :left-margin))
	  (current-margin (send environment :left-margin)))
      ;; ---Fiddling with Indent here isn't exactly the right thing, although probably
      ;; no one will ever notice as long as @$ is only used in titles which don't
      ;; exactly use multiple paragraphs
      (send environment :adjust `((leftmargin (,(make-mm (- x global-margin)) mm))
				  (indent (- ,(make-mm (- x current-margin)) mm))))))
  (values next x))

(define-command-gbox-method 1(command-gbox-consider-line-breaks-for-filling
			     (tab-to-tab-stop collect-right-flushing collect-centering))
0			   (x)
  (set-tab-command-widths x))

(define-command-gbox-method 1(command-gbox-consider-line-breaks-for-filling
			     (literal-space missing-special-character))
0			   (x)
  (values next (hposition+ environment x width)))

(define-command-gbox-method 1(command-gbox-consider-line-breaks-for-filling
			      (replicate-pattern replicate-pattern-aligned))
0			    (x-arg)
  (let ((x (hposition+ environment x-arg)))
    (let ((next-tab-stop
	    (or (let ((left-margin (send environment :left-margin)))
		  (and (< x left-margin) left-margin))
		(dolist (stop (send environment :tab-stops))
		  (when (< x stop) (return stop)))
		(let ((line-width (+ (send environment :left-margin)
				     (send environment :line-width))))
		  (and (< x line-width) line-width)))))
      (cond ((null next-tab-stop)
	     ;; past the right margin, even.
	     (splice-box-out self)
	     (values next x))
	    (T (setq width (- next-tab-stop x))
	       (width-annotate-gboxes parameter)
	       (let ((width-of-one-batch 0))
		 (do-box-successors (box parameter)
		   (incf width-of-one-batch (send box :width)))
		 (let* ((initial-round-up
			  (ecase command-name
			    (replicate-pattern 0)
			    (replicate-pattern-aligned
			      (if (zerop width-of-one-batch)
				  0
				  (multiple-value-bind (ignore round-up)
				      (ceiling x width-of-one-batch)
				    (- round-up))))))
			(width-after-round-up (- width initial-round-up 1))
			;; the magic number 1 above is to cause the
			;; stuff that gets filled in to end just before
			;; the place where the tabstop is so that we
			;; don't accidently pass the tabstop and go to
			;; the next one.  I wonder if there is a less
			;; kludgy way to do this.
			)
		   (multiple-value-bind (number-of-batches final-round-up)
		       (if (zerop width-of-one-batch)
			   (values 0 width-after-round-up)
			   (floor width-after-round-up width-of-one-batch))
		     #+Ignore
		     (progn
		       (format T "~&x ~d next-tab-stop ~d (tabs ~d)"
			       x next-tab-stop (send environment :tab-stops))
		       (format T "~&round by ~d to ~d, then ~d copies at ~d, finally round ~d"
			       initial-round-up (+ initial-round-up x)
			       number-of-batches width-of-one-batch final-round-up))
		     (let ((predecessor self)
			   (x-at-predecessor x))
		       (flet ((insert-cursor-motion (delta-x)
				(incf x-at-predecessor delta-x)
				(setq predecessor
				      (splice-boxes-after
					predecessor (make-cursor-motion-gbox environment
									     x-at-predecessor
									     nil))))
			      (insert-copies (how-many)
				(if (block yup
				      (do-box-successors (gbox parameter)
					(unless (typep gbox 'string-gbox)
					  (return-from yup nil)))
				      T)
				    ;; all were STRING-GBOX, efficiency
				    ;; hack to only make one box for all
				    ;; of it.
				    (setq predecessor
					  (splice-boxes-after
					    predecessor
					    (clone-gbox-chain-replicating parameter how-many)))
				    (dotimes (j how-many)
				      (declare (ignore j))
				      (do-box-successors (gbox parameter)
					(setq predecessor
					      (splice-boxes-after predecessor
								  (clone-gbox gbox))))))
				(incf x-at-predecessor (* width-of-one-batch how-many))))
			 (cond ((zerop number-of-batches)
				(insert-cursor-motion width))
			       (T (when (> initial-round-up 0)
				    (insert-cursor-motion initial-round-up))
				  (insert-copies number-of-batches)
				  (when (> final-round-up 0)
				    (insert-cursor-motion final-round-up))))
			 (assert (< (- x-at-predecessor next-tab-stop) 10))
			 ;;(brief-gboxes self)
			 (splice-box-out self)
			 (values predecessor next-tab-stop)))))))))))

(defmethod 1(clone-gbox string-gbox)0 ()
  (let ((new (make-string-gbox environment string start-index end-index)))
    (send new :set-width width)
    new))

(defun 1clone-gbox-chain-replicating0 (string-gbox count)
  (let ((length-once 0)
	(width-once 0)
	(element-type 'string-char))
    (do-box-successors (gbox string-gbox)
      (incf length-once (- (send gbox :end-index) (send gbox :start-index)))
      (incf width-once (send gbox :width))
      (when (eq (array-element-type (send gbox :string)) 'character)
	(setq element-type 'character)))
    (let* ((total-length (* count length-once))
	   (new-string
	     (make-string total-length
			  :element-type element-type
			  :area (sys:%area-number (send string-gbox :string)))))
      (let ((i 0))
	(loop repeat count do
	  (do-box-successors (gbox string-gbox)
	    (let ((start-index (send string-gbox :start-index))
		  (end-index (send string-gbox :end-index))
		  (string (send string-gbox :string)))
	      (replace new-string string :start1 i :start2 start-index :end2 end-index)
	      (incf i (- end-index start-index))))))
      (let ((new-gbox (make-string-gbox (send string-gbox :environment)
					new-string 0 total-length)))
	(send new-gbox :set-width (* count width-once))
	new-gbox))))

(define-command-gbox-method 1(command-gbox-consider-line-breaks-for-filling tabclear)0 (x)
  (send environment :tabclear)
  (splice-box-out self)
  (values next x))

(define-command-gbox-method 1(command-gbox-consider-line-breaks-for-filling em)0 (x)
  (values next (hposition+ environment x width)))

;;;Handle @tabset during considering-line-breaks-for-filling so that the tab stops will be
;;;used for tabs following the @tabset command and not for tabs preceding the @tabset command.
(define-command-gbox-method 1(command-gbox-consider-line-breaks-for-filling tabdivide)0 (x)
  (send environment :tabdivide (first parameter))
  (splice-box-out self)
  (values next x))

(define-command-gbox-method 1(command-gbox-consider-line-breaks-for-filling tabset)0 (x)
  (send environment :tabset parameter)
  (splice-box-out self)
  (values next x))

(define-command-gbox-method 1(command-gbox-consider-line-breaks-for-filling dynamic-tab-stop)
0			    (x-arg)
  (let ((x (hposition+ environment x-arg)))
    (send environment :tabset (list (list (/ (- x (send environment :left-margin)) 1e3) 'mm)))
    (splice-box-out self)
    (values next x)))

(define-command-gbox-method 1(command-gbox-consider-line-breaks-for-filling newpage)0 (x)
  ;; Surround with newlines.  This gross kludge works by tyoing #\page to
  ;; the output stream.  On the screen this produces a lozenged PAGE
  ;; character.  We want it to appear on a line by itself.
  (ignore x)
  (let ((prev-text (gbox-prev-text self)))
    (unless (or (null prev-text)
		(send prev-text :ends-with-newline?))
      (splice-box-before self (make-newline-gbox environment))))
  (let ((next-box next))
    (unless (and (not (null next-box))
		 (send next-box :newline?))
      (splice-boxes-after self (setq next-box (make-newline-gbox environment))))
    (values next-box :unknown)))

(defmethod 1(:consider-line-breaks-for-filling0 1envr-entry-gbox)0 (x)
  (send environment :tab-import-from-superior)
  (send self :validate-font-number)
  (values next (if (send environment :box-type)
		   (hposition+ environment x (send environment :box-left-margin))
		   x)))

(defmethod 1(:consider-line-breaks-for-filling0 1envr-exit-gbox)0 (x)
  (when (send environment :tab-export)
    (send environment :tab-export-to-superior))
  (when next (send next :validate-font-number))
  (values next 
	  (if (and (send environment :box-type)
		   (not (send environment :break-on-exit)))
	      (hposition+ environment x (send environment :box-right-margin))
	      x)))

(defmethod 1(:consider-line-breaks-for-filling picture-gbox)0 (x)
  (let ((x-plus-width (hposition+ environment x (send self :width)))
	(right-edge (- (send environment :paper-width)
		       (send environment :right-margin))))
    (when (and (> x-plus-width right-edge)
	       (neq (send environment :overlong-line-action ) 'keep))
      (setq overflow-amount (/ (- x-plus-width right-edge) *microns-per-screen-pixel*)))
    (values next
	    (min right-edge x-plus-width))))


(defmethod 1(:tab-import-from-superior0 1formatting-environment)0 ()
  (send self :add-tabs (send (send self :superior) :tab-stops)))

(defmethod 1(:tab-export-to-superior0 1formatting-environment)0 ()
  (send (send self :superior) :add-tabs tab-stops))

(defmethod 1(:consider-line-breaks-for-filling0 1unexpanded-reference-gbox)0 (ignore)
;;  (splice-box-before self (make-newline-gbox environment))
  (values next :start-of-paragraph))

(defmethod 1(:consider-line-breaks-for-filling rfstr-support-gbox)0 (x-arg)
  (if (eql type 'other-end)
      (progn
	(cerror "splice it out anyway"
		"other end of rfstr-support-gbox should have been spliced out: ~s" self)
	(splice-box-out self)
	(values next x-arg))
      (let ((x (hposition+ environment x-arg))
	    (x-at-right-of-contents
	      (- (send environment :toplevel-attribute :paper-width)
		 (ecase type
		   (rfstr (send environment :toplevel-attribute :right-margin))
		   (rmstr (send environment :right-margin)))))
	    (contained-width
	      (loop for gbox = next then (box-next gbox)
		    until (or (null gbox) (eql gbox other-end))
		    sum (send gbox :width))))
	(let ((cursor-saving-entry-gbox (make-cursor-saving-entry-gbox environment))
	      (cursor-saving-exit-gbox (make-cursor-saving-exit-gbox environment)))
	  (setf (cursor-saving-entry-gbox-exit-gbox cursor-saving-entry-gbox)
		cursor-saving-exit-gbox)
	  (setf (cursor-saving-exit-gbox-entry-gbox cursor-saving-exit-gbox)
		cursor-saving-entry-gbox)
	  (splice-boxes-after self
			      cursor-saving-entry-gbox
			      (make-cursor-motion-gbox
				environment
				(- x-at-right-of-contents contained-width)
				nil))
	  (splice-boxes-after other-end cursor-saving-exit-gbox))
	(splice-box-out self)
	(splice-box-out other-end)
	;; skip over the boxes that were inside the rfstr because we don't want
	;; the 1:consider-line-breaks-for-filling0 handler for string-gboxes wrapping or
	;; chopping the string because it just happens to end up in the margin!
	(values (box-next (box-next other-end)) x))))


;;1:attempt-line-break0 is used in a loop which is searching backwards in a line looking
;;for a place to break it. It is supposed to break the line at the rightmost place it can.
;; If it did, it returns the newline-gbox (as a restart point) and some x which is 
;; probably useless since the newline will reset the x anyway.  Attempting line break
;; at a newline returns the special marker 1:no-further0 to terminate that loop.

(defmethod 1(:attempt-line-break doubly-linked-list-head)0 ()
  :no-further)

(defmethod1 (:attempt-line-break0 1basic-gbox0 1:default)0 ()
  ())

(defmethod1 (:attempt-line-break0 1newline-gbox)0 ()
  :no-further)

(defmethod 1(:attempt-line-break0 1unexpanded-reference-gbox)0 ()
  :no-further)

(defmethod 1(:attempt-line-break0 1command-gbox)0 ()
  (case command-name
    (tab-to-tab-stop :no-further)
    (otherwise ())))

(defmethod1 (:attempt-line-break0 1space-gbox)0 ()
  (let ((newline (make-newline-gbox environment)))
    (splice-replace-box self newline)
    (values newline (send environment :left-margin))))

(defmethod 1(:attempt-line-break0 1tab-character-gbox)0 ()
  (let ((newline (make-newline-gbox environment)))
    (splice-box-before self newline)
    (values next (+ width (send environment :left-margin)))))

(defmethod1 (:attempt-line-break0 1string-gbox)0 ()
  (let ((space-loc (string-search-char #\space string :start start-index :end end-index :from-end t)))
    (when space-loc
      ;; Since we're backing up, we have to make sure the current font number
      ;; reflects the environment for 2this0 gbox, not the next.
      (send self :validate-font-number)
      (let ((font (gbox-font-from-environment environment))
	    (newline (make-newline-gbox environment)))
	(cond (( (1+ space-loc) end-index)	;the space is the last char
	       (decf end-index)
	       (splice-boxes-after self newline))
	      (T (let ((new (make-string-gbox environment string (1+ space-loc) end-index)))
		   (send new :width-annotate font)
		   (splice-boxes-after self newline new)
		   (setq end-index space-loc))))
	(send self :width-annotate font)
	(values newline (send environment :left-margin))))))


(defun 1assemble-line-hboxes0 (gbox)
  (with-temp-list-head (head)
    (let ((current-line head)
	  (first-gbox-in-current-line ())
	  (predecessor-deferred? ()))
      (do-box-successors (gbox gbox)
	(when (null first-gbox-in-current-line)
	  (setq first-gbox-in-current-line gbox))
	(multiple-value-bind (line next-line deferred?)
	    (send gbox :assemble-line-hbox first-gbox-in-current-line predecessor-deferred?)
	  (setq predecessor-deferred? deferred?)
	  (when line
	    (when current-line
	      (splice-boxes-after current-line line))
	    (setq current-line line)
	    (when next-line
	      (splice-boxes-after current-line next-line)
	      (setq current-line next-line))
	    (setq first-gbox-in-current-line ()
		  predecessor-deferred? ()))))
      (when first-gbox-in-current-line
	;; This used to ensure that there was text in the partial
	;; left-over lines, but this isn't really practical, given that
	;; there are many things like @TAG, etc, that aren't text but
	;; are useful to be on a line by themselves.
	(let ((last-gbox (loop for gbox = first-gbox-in-current-line then next-gbox
			       for next-gbox = (box-next gbox)
			       when (null next-gbox) return gbox)))
	  (let ((newline-gbox (send last-gbox :make-finishing-newline)))
	    (splice-boxes-after last-gbox newline-gbox)
	    (let ((line (send newline-gbox :assemble-line-hbox first-gbox-in-current-line ())))
	      (splice-boxes-after current-line line))))))))

(defmethod 1(:make-finishing-newline0 1basic-gbox0 1:default)0 ()
  (make-newline-gbox environment))
;;If the last gbox is envr-exit, we don't want to make a newline of that envr,
;;but splice it in outside the envr!  The symptom is making wrong environment tiny.
(defmethod 1(:make-finishing-newline0 1envr-exit-gbox)0 ()
  (make-newline-gbox (send environment :superior)))

(defmethod 1(:assemble-line-hbox0 1basic-gbox0 1:default)0 (ignore ignore)
  ())

(defun 1assemble-line-hbox-unless-successor-will0 (gbox first-gbox-in-current-line)
  ;; we want to include all following envr-exit-gboxes on this line
  (let ((next-box (box-next gbox)))
    (if (and next-box (send next-box :valid-after-newline-p))
	(values nil nil t)
	(make-line-hbox (or first-gbox-in-current-line gbox) gbox))))

(defmethod 1(:assemble-line-hbox0 1newline-gbox)0 (first-gbox-in-current-line predecessor-deferred)
  (ignore predecessor-deferred)
  (assemble-line-hbox-unless-successor-will self first-gbox-in-current-line))

(defun 1exit-gbox-assemble-line-hbox0 (exit-gbox first-gbox-in-current-line predecessor-deferred)
  ;; we want to include all following envr-exit-gboxes on this line
  (when predecessor-deferred
    (assemble-line-hbox-unless-successor-will exit-gbox first-gbox-in-current-line)))

(defmethod 1(:assemble-line-hbox envr-exit-gbox)0 (first-gbox-in-current-line
						  predecessor-deferred)
  (exit-gbox-assemble-line-hbox self first-gbox-in-current-line predecessor-deferred))

(defmethod 1(:assemble-line-hbox presentation-exit-gbox)0 (first-gbox-in-current-line
						  predecessor-deferred)
  (exit-gbox-assemble-line-hbox self first-gbox-in-current-line predecessor-deferred))

(defmethod 1(:assemble-line-hbox record-exit-gbox)0 (first-gbox-in-current-line
						  predecessor-deferred)
  (exit-gbox-assemble-line-hbox self first-gbox-in-current-line predecessor-deferred))

(defmethod 1(:assemble-line-hbox box-support-gbox)0 (first-gbox-in-current-line
						    predecessor-deferred)
  (when (eq type 'last)
    (exit-gbox-assemble-line-hbox self first-gbox-in-current-line predecessor-deferred)))

(defmethod 1(:assemble-line-hbox0 1unexpanded-reference-gbox)0 (first-gbox-in-current-line ignore)
  (if (and first-gbox-in-current-line (neq first-gbox-in-current-line self))
      (values (make-line-hbox first-gbox-in-current-line self)
	      (make-unexpanded-reference-line-hbox self))
      (make-unexpanded-reference-line-hbox self)))

(defmethod 1(:valid-after-newline-p basic-gbox :default)0 ()
  ())

(defmethod 1(:valid-after-newline-p envr-exit-gbox)0 ()
  t)
(defmethod 1(:valid-after-newline-p record-exit-gbox)0 ()
  nil)

(defmethod 1(:valid-after-newline-p presentation-exit-gbox)0 ()
  t)

(defmethod 1(:valid-after-newline-p box-support-gbox)0 ()
  (eq type 'last))

(defmethod 1(:valid-after-newline-p command-gbox)0 ()
  ;; we used to explicitly enumerate TAG and INDEX, but there
  ;; are probably other commands we should worry about.
  ;; (not text?) seems to be a pretty reasonable test.
  (not (send self :text?)))

(defmethod 1(:assemble-line-hbox command-gbox)0 (first-gbox-in-current-line predecessor-deferred)
  (when (send self :valid-after-newline-p)
    (exit-gbox-assemble-line-hbox self first-gbox-in-current-line predecessor-deferred)))


(defun 1annotate-line-heights0 (hbox)
  (do-box-successors (hbox hbox)
    (send hbox :annotate-line-heights)))

;(defmethod 1(:annotate-line-heights0 1line-hbox)0 ()	;original
;  (setq height 0
;	line-baseline 0)
;  (let ((font ()))
;    (do-line-gboxes (gbox first-gbox newline-gbox)
;      (when (null font) (setq font (send gbox :validate-font-number)))
;      (multiple-value-bind (this-height this-baseline new-font)
;	  (send gbox :annotate-line-heights font)
;	(setq height (max height this-height)
;	      font new-font
;	      line-baseline (max line-baseline this-baseline))))))

;;; Ascenders and descenders case, not yet ready for consumption.
(defmethod 1(:annotate-line-heights line-hbox)0 ()
  (let ((ascenders 0)
	(descenders 0)
	(font ()))
    (do-line-gboxes (gbox first-gbox newline-gbox)
      (when (null font) (setq font (send gbox :validate-font-number)))
      (multiple-value-bind (this-height this-baseline new-font)
	  (send gbox :annotate-line-heights font (eq gbox first-gbox))
	(setq ascenders (max ascenders this-baseline))
	(setq descenders (max descenders (- this-height this-baseline)))
	(setq font new-font)))
    (setq height (+ ascenders descenders))
    (setq line-baseline ascenders)))

(defmethod 1(:annotate-line-heights0 1basic-gbox0 1:default)0 (font first-gbox-in-line?)
  (cond ((send self :ink? first-gbox-in-line?)
	 (multiple-value-bind (height baseline)
	     (micron-height-of-font font)
	   (values height baseline font)))
	(t (values 0 0 font))))

(defmethod 1(:annotate-line-heights0 1envr-entry-gbox)0 (ignore ignore)
  (let ((font (send self :validate-font-number)))
    (multiple-value-bind (height baseline) (micron-height-of-font font)
      (values height baseline font))))

(defmethod 1(:annotate-line-heights0 1envr-exit-gbox)0 (ignore ignore)
  (values 0 0 ()))

(defmethod 1(:annotate-line-heights picture-gbox)0 (font ignore)
  (multiple-value-bind (width height)
      (cached-width-and-height self)
    (ignore width)
    (values
      (* height *microns-per-screen-pixel*)
      (* height *microns-per-screen-pixel*)
      font)))

(defmethod 1(:annotate-line-spread0 1line-hbox)0 ()
  (let ((prev-extra-space-below (or (and prev (send prev :extra-space-below))
				    0)))
    (setq extra-space-above prev-extra-space-below
	  prev-extra-space-below 0)
    (let ((deferred-above-spacing ())
	  (deferred-below-spacing ()))
      (do-line-gboxes (gbox first-gbox newline-gbox)
	(multiple-value-bind (above below spacing deferred-above deferred-below
			      additional-above additional-below	;for boxes...
			      paragraph-spread)	;easiest kludge for tonight
	    (send gbox :annotate-line-spread (eq gbox first-gbox))
	  (cond (deferred-above-spacing
		 (setq above (max above deferred-above-spacing (or deferred-above 0))
		       deferred-above-spacing ()))
		(deferred-above
		 (setq deferred-above-spacing deferred-above)))
	  (cond (deferred-below-spacing
		 (setq below (max below deferred-below-spacing (or deferred-below 0))
		       deferred-below-spacing ()))
		(deferred-below
		 (setq deferred-below-spacing deferred-below)))
	  (unless paragraph-spread (setq paragraph-spread 0))
	  (let ((extra-spacing (- spacing height)))
	    (setq extra-space-above (max above extra-space-above
					 (+ extra-spacing paragraph-spread)))
	    (setq prev-extra-space-below (max below prev-extra-space-below extra-spacing)))
	  (when additional-above
	    (incf extra-space-above additional-above))
	  (when additional-below
	    (incf prev-extra-space-below additional-below))))
      (setq extra-space-below
	    (max prev-extra-space-below
		 (or deferred-above-spacing 0)
		 (or deferred-below-spacing 0))))))

(defmethod 1(:annotate-line-spread0 1basic-gbox)0 (ignore)
  (values 0 0 (send environment :spacing)))

(defmethod 1(:annotate-line-spread0 1envr-entry-gbox)0 (ignore)
  (values 0 0 0 (send environment :minimum-above-spacing)))

(defmethod 1(:annotate-line-spread0 1envr-exit-gbox)0 (ignore)
  (values 0 0 0 () (send environment :minimum-below-spacing)))

(defmethod 1(:annotate-line-spread box-support-gbox)0 (ignore)
  (ecase type
    (first
      (values 0 0 0 () () (compute-additional-spread self)))
    (last 
      (values 0 0 0 () () 0 additional-bottom-margin)
      )))

(defmethod 1(compute-additional-spread basic-gbox :default)0 ()
  (values 0 0 next))

(defmethod 1(compute-additional-spread newline-gbox)0 ()
  (values 0 0 nil))

(defmethod 1(compute-additional-spread box-support-gbox)0 ()
  (multiple-value-bind (above below)
      (spread-for-this-box self)
    (let ((box (box-next self)))
      (loop do
	(multiple-value-bind (a b next-box)
	    (compute-additional-spread box)
	  (incf above a)
	  (incf below b)
	  (when (or (null next-box)(eq next-box other-end)) (loop-finish))
	  (setq box next-box))))
    (setq additional-top-margin above)
    ;; Additional-bottom-margin is used here just to cache the needed
    ;; bottom margin for this particular environment so that the other end
    ;; can just return it.  additional-bottom-margin will also be used for a different
    ;; purpose in the 1annotate-line-box-widths0 phase, where it will hold
    ;; actual fudge-factor that must be added in when drawing the box so that all
    ;; of the stuff inside the box will be included.
    (setf (box-support-gbox-additional-bottom-margin other-end) below)
    (values above below (box-next other-end))))

(defmethod 1(spread-for-this-box box-support-gbox)0 (&optional (prevailing-top-spread 0)
							     (prevailing-bottom-spread 0))
  (declare (values above below to-left to-right))
  (multiple-value-bind (left top right bottom) (box-margins self)
    (ignore left right)
    (values (+ top prevailing-top-spread) (+ bottom prevailing-bottom-spread))))
	    
(defmethod 1(:annotate-line-spread record-exit-gbox)0 (ignore)
  (values 0 0 0))

(defmethod 1(:annotate-line-spread field-start-gbox)0 (ignore)
  (values 0 0 0))

(defmethod 1(:annotate-line-spread field-end-gbox)0 (ignore)
  (values 0 0 0))

(defmethod 1(:annotate-line-spread0 1paragraph-break-gbox)0 (ignore)
  ;;Quoth the DBA, "Paragraph spread has no meaning in unfilled environments,
  ;; because these have no paragraphs."  I guess here's one place to "---fix" that.
  (values (ecase (send environment :fill-mode)
	    (fill (send environment :paragraph-spread))
	    ((centered flushleft flushright) 0))
	  0
	  0))

(defmethod 1(:annotate-line-spread0 1paragraph-break-gbox)0 (ignore)
  ;;Quoth the DBA, "Paragraph spread has no meaning in unfilled environments,
  ;; because these have no paragraphs."  I guess here's one place to "---fix" that.
  (values 0 0 (send environment :spacing) ()()()() 
	  (when (eq (send environment :fill-mode) 'fill)
	    (send environment :paragraph-spread))))

(defmethod 1(:annotate-line-spread0 1command-gbox)0 (ignore)
  (case command-name
    (blankspace
     (values 0
	     (let ((dist (coerce-to-type 'vertical-distance (first parameter) 0)))
	       (case *device-type*		;---this is a dangerous kludge
		 (generic (min (* 1 *microns-per-inch*) dist))	;because this assumes "screen"
		 (otherwise dist)))
	     (send environment :spacing)))
    (otherwise (values 0 0 
		       (if (send self :text?)
			   (send environment :spacing)
			   0)))))

(defmethod 1(:annotate-line-spread newline-gbox)0 (first-gbox-p)
  (values 0 0 (if first-gbox-p (send environment :spacing) 0)))

(defmethod 1(:total-width-and-height0 1line-hbox)0 ()
  (values (let ((width (send (send first-gbox :environment) :left-margin)))
	    (do-line-gboxes (gbox first-gbox newline-gbox)
	      (incf width (or (send-if-handles gbox :width) 0)))
	    width)
	  (+ height extra-space-above)))

;;; Justifying
;;; This doesn't actually 2do0 any justification, because that'd be too
;;; expensive.  However, it does remember enough information so the display phase
;;; can do the justification for us.
(defun 1horizontal-justification-allowed-p0 ()
  (multiple-value-bind (value value-type)
      (lookup-ambient-value 'justification :error-p nil)
    (if value-type
	value
	#+Ignore
	(cerror "Proceed with justification on"
		"Justification has not been declared on or off" )
	#+Ignore
	(set-ambient-value 'justification t 'justification)
	t)))

(defun 1vertical-justification-allowed-p0 ()
  (multiple-value-bind (value value-type)
      (lookup-ambient-value 'verticaljustification :error-p nil)
    (if value-type
	value
	nil)))

(defmethod 1(justify-line-if-necessary line-hbox)0 ()
  (flet ((ok-to-justify-line-p (line)
	   (when (horizontal-justification-allowed-p)
	     (let ((next-line (box-next line)))
	       (and next-line
		    ;;; If the next line really is all white-space, then this line must end a paragraph
		    ;;; and justification isn't necessary.
		    (not (line-all-white-p next-line))
		    (not (first-line-of-paragraph-p next-line
						    :for-widow-elimination-p nil)))))))
    (when (and (ok-to-justify-line-p self)
	       (let ((justify? nil))
		 (do-line-gboxes (gbox first-gbox newline-gbox)
		   (when (send gbox :ink? (eq gbox first-gbox))
		     (let ((envr (send gbox :environment)))
		       (if (and (send envr :justification)
				(eq (send envr :fill-mode) 'fill))
			   (setq justify? t)
			   (setq justify? nil))))
		   (when (and (send gbox :newline?) (send gbox :hard-newline))
		     (setq justify? nil)
		     (return)))
		 justify?))
      (let ((extra-width-per-space (calculate-line-width-and-spaces self)))
	(setf (getf property-list :extra-width-per-space) extra-width-per-space)))))

2;;; Used for broken underlining.  Returns a list of indices into STRING
;;; that mark where underlining should begin and end.  The phase is
;;; defined to be ON - OFF - ON - OFF...  In other words, underlining
;;; starts at the START index.  So the first number in the returned list
;;; indicates the place where underlining should stop, the second number
;;; indicates where it should start again, etc.  If underlining should
;;; be off to start, the first number will be START.  The last number is
;;; always END.  PREDICATE is a function that takes a character and
;;; returns non-nil iff it should be underlined.
0(defun find-underlinable-substrings (string start end predicate)
  (loop with underlining = nil
	for index from start below end
	when (neq underlining (funcall predicate (aref string index)))
	  collect index into indices
	  and do (setq underlining (not underlining))
	finally (return (nconc indices (list end)))))

(defmethod (underline-gbox basic-gbox) ()
  (let* ((envr (make-environment-inferior-to environment 'UnderlineBox ()))
	 (envr-entry (make-envr-entry-gbox envr))
	 (envr-exit (make-envr-exit-gbox envr)))
    (setq environment envr)
    (splice-box-before self envr-entry)
    (splice-boxes-after self envr-exit)
    (send envr-entry :set-exit-gbox envr-exit)
    (send envr-exit :set-entry-gbox envr-entry)
    (send envr-entry :annotate-for-box-support)))

(defmethod (add-underlining line-hbox) ()
  (do-line-gboxes (gbox first-gbox newline-gbox)
    (add-underlining gbox))
  2;; add-underlining may have spliced some gboxes before the first gbox
0  2;; on this line, so recompute first-gbox.
0  (setq first-gbox
	(loop with prev-newline = (and prev (send prev :newline-gbox))
	      for gbox = first-gbox then prev-gbox
	      for prev-gbox = (box-prev gbox) do
	  (when (eq prev-newline prev-gbox)		    
	    (return gbox)))))

(defmethod (add-underlining fake-line-hbox) ())

(defmethod (add-underlining basic-gbox :default) ())

(defmethod (add-underlining string-gbox) ()
  (flet ((underline-words (type)
	   (let ((places-to-split (find-underlinable-substrings
				    string start-index end-index
				    (ecase type
				      (nonblank #'char-white-space-p)
				      (alphanumerics #'alphanumericp)))))
	     (loop with underline
		   with new-gbox
		   for start = start-index then end
		   for end in places-to-split
		   for first-time = t then nil
		   do
	       (setq underline (if first-time ( start end) (not underline))
		     new-gbox (unless (= start end)
				(make-string-gbox environment string start end)))
	       (when new-gbox
		 (splice-box-before self new-gbox)
		 (send new-gbox :width-annotate nil))
	       (when underline
		 (underline-gbox new-gbox)))
	     (splice-box-out self))))
    (ecase (send environment :underlining)
      (off)
      (all
	(underline-gbox self))
      (nonblank
	(underline-words 'nonblank))
      ((alphanumeric alphanumerics)
       (underline-words 'alphanumerics)))))

(defmethod (add-underlining space-gbox) ()
  (ecase (send environment :underlining)
    ((off nonblank alphanumeric alphanumerics))
    (all (underline-gbox self))))

(defmethod (add-underlining command-gbox) ()
  (ecase (send environment :underlining)
    ((off nonblank alphanumeric alphanumerics))
    (all
      (when (member command-name
		    '(literal-space tab-to-tab-stop collect-right-flushing
				    collect-centering dynamic-tab-stop))
	(underline-gbox self)))))

(defmethod 1(extra-width-per-space line-hbox)0 ()
  (getf property-list :extra-width-per-space 0))

(defmethod 1(calculate-line-width-and-spaces line-hbox)0 ()
  (declare (values extra-width-per-space))
  (let* ((plausible-line-environment
	   (do-line-gboxes (gbox first-gbox newline-gbox)
	     (when (send gbox :ink? (eq gbox first-gbox)) (return (send gbox :environment)))))
	 (line-width (send plausible-line-environment :line-width)))
    (let ((x-position 0)
	  (spaces 0)
	  (first-justify-gbox (find-first-justify-gbox self))
	  (found-first-justify-gbox? nil)
	  (indentation nil))
      (do-line-gboxes-exclusive (gbox first-gbox newline-gbox)
	(multiple-value-bind (x-pos sp indent)
	    (calculate-line-width-and-spaces gbox x-position spaces )
	  (when (eq gbox first-justify-gbox)
	    (setq found-first-justify-gbox? t))
	  (unless found-first-justify-gbox?
	    (setq spaces 0))
	  (setq x-position x-pos
		spaces sp
		indentation (or indent indentation))))
      ;; what we're stretching to is the width minus wherever the line 
      ;; actually starts.
      (when indentation (decf line-width indentation))
      (cond ((zerop spaces) 0)
	    (t
	     (let ((extra-whitespace (- line-width x-position)))
	       (/ extra-whitespace spaces)))))))

(defmethod 1(find-first-justify-gbox line-hbox)0 ()
  (let ((last-gbox first-gbox))
    (do-line-gboxes-exclusive (gbox first-gbox newline-gbox)
      (setq last-gbox (find-first-justify-gbox-1 gbox last-gbox)))
    last-gbox))

(defmethod 1(find-first-justify-gbox-1 basic-gbox)0 (last-gbox)
  last-gbox)

(defmethod 1(find-first-justify-gbox-1 command-gbox)0 (last-gbox)
  (case command-name
    ((tab-to-tab-stop) self)
    (otherwise last-gbox)))

(defmethod 1(calculate-line-width-and-spaces basic-gbox)0 (x-motion spaces)
  (values (hposition+ environment x-motion (send self :width))
	  (+ spaces (count-spaces-in-gbox self))))

(defmethod 1(calculate-line-width-and-spaces paragraph-break-gbox)0 (x-motion spaces)
  (values x-motion spaces
	  (when (and indented (eq break-type 'normal))
	    (send environment :indention))))

(defmethod 1(calculate-line-width-and-spaces pseudo-paragraph-break-gbox)0 (x-motion spaces)
  (values x-motion spaces 
	  (when (and indented (eq break-type 'normal))
	    (send environment :indention))))

;;; Stuff useful for page annotation
(defmethod 1(:annotate-page-info line-hbox)0 ()
  (let ((page-need 0)
	(last-env nil)
	(float-disposition 'free)
	(hinge-p nil)
	(page-break nil)
	(fill-vertically nil)
	(group-next nil)
	(footnotes nil)
	(sink-margin 0))
    (do-line-gboxes (gbox first-gbox newline-gbox)
      (unless hinge-p
	(setq hinge-p (send gbox :hinge-p)))
      (unless page-break
	(setq page-break (send gbox :page-break)))
      (unless fill-vertically
	(setq fill-vertically (send gbox :fill-vertically?)))
      (when (send gbox :footnote-p)
	(push gbox footnotes))
      (let ((gbox-environment (send gbox :environment)))
	(unless group-next
	  (when (and (send gbox :ink? (eq gbox first-gbox))
		     (send gbox-environment :group-next))
	    (setq group-next t)))
	(unless (eq last-env gbox-environment)
	  (setq last-env gbox-environment)
	  (setq page-need
		(max page-need (send gbox-environment :page-need)))
	  (setq sink-margin (max sink-margin (send gbox-environment :sink-margin)))
	  (let ((env-float-disposition (send gbox-environment :float-disposition)))
	    (ecase env-float-disposition
	      ((free) nil)			;do nothing
	      ((group) (setq float-disposition 'group))
	      ((float-defer float-whole-page fixed-location)
	       #+ignore
	       (unless (eq float-disposition 'free)
		 (zl:fsignal "Float disposition of ~S with prevailing disposition of ~S,
which we aren't sure how to deal with" env-float-disposition float-disposition))
 	       (setq float-disposition env-float-disposition))
	      )))))
    (setf (getf property-list :float-disposition) float-disposition
	  (getf property-list :page-need) page-need
	  (getf property-list :hinge-p) hinge-p
	  (getf property-list :page-break) page-break
	  (getf property-list :fill-vertically) fill-vertically
	  (getf property-list :group-next) group-next
	  (getf property-list :footnotes) (reverse footnotes)
	  (getf property-list :sink-margin) sink-margin
	  )))

(defmethod 1(:annotate-page-info fake-line-hbox)0 () ())
(defmethod 1(first-line-of-paragraph-p fake-line-hbox)0 (&rest ignored) t)
(defmethod 1(justify-line-if-necessary fake-line-hbox)0 () nil)

(defmethod 1(:float-disposition line-hbox)0 ()
  (getf property-list :float-disposition))

(defmethod 1(:page-need line-hbox)0 ()
  (getf property-list :page-need))

(defmethod 1(:page-break line-hbox)0 ()
  (getf property-list :page-break))

(defmethod 1(:set-page-break line-hbox)0 (n)
  (setf (getf property-list :page-break) n))

(defmethod 1(:sink-margin line-hbox)0 ()
  (getf property-list :sink-margin))

(defmethod 1(:footnote-p basic-gbox :default)0 () nil)
(defmethod 1(:footnote-p command-gbox)0 ()
  (eq command-name 'foot))

(defmethod 1(:hinge-p basic-gbox :default)0 ()
  nil)

(defmethod 1(:hinge-p command-gbox)0 ()
  (case command-name
    (hinge t)
    (otherwise nil)))

(defmethod 1(:hinge-p envr-entry-gbox)0 ()
  (and (neq (send environment :float-disposition) 'free)
       (eq (send (send environment :superior) :float-disposition) 'free)
       'before))

(defmethod 1(:hinge-p envr-exit-gbox)0 ()
  (and (neq (send environment :float-disposition) 'free)
       (eq (send (send environment :superior) :float-disposition) 'free)))

(defmethod 1(:hinge-p line-hbox)0 ()
  (getf property-list :hinge-p))

(defmethod 1(:page-break basic-gbox :default)0 ()
  nil)

(defmethod 1(:page-break command-gbox)0 ()
  (command-gbox-page-break self))

(define-command-gbox-generic 1command-gbox-page-break0 ()
  nil)

(define-command-gbox-method 1(command-gbox-page-break newpage)0 ()
  (cond ((null n) 0)
	((symbolp n) n)
	((zerop n) n)
	;; this wants to incf the value because
	;; Scribe's definition of 0 is different from
	;; the recursive definition of what (1- 1) would be
	;; if we're currently at the top of a page.
		(t (1+ n))))

(defmethod 1(:fill-vertically line-hbox)0 ()
  (getf property-list :fill-vertically))

(defmethod 1(:fill-vertically? basic-gbox)0 ()
  nil)

(defmethod 1(:fill-vertically? envr-entry-gbox)0 ()
  (when (send environment :break-on-entry)
    ;; this isn't quite good enough.  We need to be able to detect
    ;; "free-standing" subheadings.
    (let ((allowed (send environment :vertical-justification-allowed)))
      (ecase allowed
	((none below) nil)
	((above around) 'above)))))

(defmethod 1(:fill-vertically? envr-exit-gbox)0 ()
  (when (send environment :break-on-exit)
    (let ((allowed (send environment :vertical-justification-allowed)))
      (ecase allowed
	((none above) nil)
	((below around) 'below)))))

(defmethod 1(:starts-chapter-p basic-gbox :default)0 () nil)
(defmethod 1(:starts-chapter-p command-gbox)0 ()
  (eq command-name 'chapter))

;;; Box & Line stuff
;;; When you find an box-exit gbox then you back up over previous lines figuring
;;; out how wide the box should be.

(defmethod 1(annotate-line-box-widths line-hbox)0 ()
  (do-line-gboxes (gbox first-gbox newline-gbox)
    (annotate-gbox-box-widths gbox self)))

(defmethod 1(annotate-gbox-box-widths basic-gbox :default)0 (line)
  (ignore line)
  nil)

(defmethod (number-of-spaces basic-gbox :default) ()
  0)

(defmethod (number-of-spaces string-gbox) ()
  (count #\Space string :start start-index :end end-index))

(defmethod (number-of-spaces space-gbox) ()
  1)

;;; Rules are as follows:  If the box all fits on one line, then draw
;;; it surrounding the stuff on that line.  Otherwise, draw it such that it 
;;; is as wide as line-width.
(defmethod 1(annotate-gbox-box-widths box-support-gbox)0 (line)
  (when (eq type 'last)
    (let* ((line-containing-box-entry
	     (loop for line = line then (box-prev line)
		   when (line-contains-gbox-p line other-end)
		     return line))
	   (even-more-additional-height 0)
	   (box-flush-right-p
	     (or (neq line line-containing-box-entry)
		 (and (send environment :break-on-entry)
		      (or (send environment :box-flush-right)
			  (eq (send environment :fill-mode) 'fill)))))
	   (gboxes nil)
	   (other-gboxes ()))
       (macrolet ((unless-match-gbox (gbox-var gboxes-var &body body)
		   `(when (typep ,gbox-var 'box-support-gbox)
		      (let ((match-gbox (if (eq (box-support-gbox-type ,gbox-var) 'first)
					    ,gbox-var
					    (box-support-gbox-other-end ,gbox-var))))
			(unless (member match-gbox ,gboxes-var)
			  ,@body
			  (push match-gbox ,gboxes-var))))))

	(cond (box-flush-right-p
	       (setq box-width (+ (send environment :box-left-margin)
				  (send environment :box-right-margin)
				  (send environment :line-width))))
	      (t (setq box-width
		       (let ((wid 0))
			 (do-line-gboxes (gbox other-end self)
			   (incf wid (send gbox :width))
			   (incf wid (* (number-of-spaces gbox)
					(extra-width-per-space line)))
			   (unless-match-gbox gbox gboxes
					      (multiple-value-bind (le nil ri nil)
						  (box-margins gbox)
						(incf wid (+ le ri)))))
			 wid))))
	(let ((wid 0))
	  (do-line-gboxes (gbox (if (eq line line-containing-box-entry)
				    other-end
				    (send line :first-gbox)) self)
	    (incf wid (send gbox :width))
	    (unless-match-gbox gbox gboxes
			       (multiple-value-bind (le to ri bo) (box-margins gbox)
				 (ignore to bo)
				 (incf wid (+ le ri))))
	    (unless-match-gbox gbox other-gboxes
			       (multiple-value-bind (le to ri bo) (box-margins gbox)
				 (ignore le to ri)
				 (incf even-more-additional-height bo))))
	  (maxf box-width wid))
	(setq additional-bottom-margin even-more-additional-height)
	(unless (eq line-containing-box-entry line)
	  (setf (box-support-gbox-box-origin other-end) :start-of-line))))))
