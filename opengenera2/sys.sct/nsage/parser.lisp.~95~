;;; -*- Base: 10; Syntax: Common-lisp; Mode: LISP; Package: NSAGE; -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; A SAGE-LEXER handle the lexer class operations of the parser by filtering
;;; the input from the real stream.
;;; This behavior is controlled by the value of the lexer's state.

(defparameter *legal-lexer-states*
	  `(:transparent        ; The initial state.  Pass everything unchanged.
	    :raise              ; Convert everything to uppercase.
	    :filter-white       ; Throw away all whitespace.
	    ))

(defflavor sage-lexer (stream		; The raw stream
			state		; Lexer state
			buffer		; Hold partially completed tokens.
			untyi-buffer	; Support for infinite-untyi.
			white-buffer	; Support for :match-oneof-ch-saving-whitespace
			stream-buffer stream-buffer-start stream-buffer-end
			(stream-is-buffered)
			)
	   ()
  (:gettable-instance-variables))

(defmethod (:init sage-lexer :after) (ignore)
  (setq buffer (make-array 10000. :element-type 'string-char :fill-pointer 0))
  (setq untyi-buffer (make-array 10. :element-type 'string-char :fill-pointer 0))
  (setq white-buffer (make-array 10. :element-type 'string-char :fill-pointer 0))
  (setq stream-buffer (make-array 500. :element-type 'character)
	stream-buffer-start 0 stream-buffer-end 0))

(defmethod (:reset sage-lexer) (new-stream)
  (setq stream new-stream
	state :transparent)
  (setf (fill-pointer buffer) 0)
  (setf (fill-pointer untyi-buffer) 0)
  (setq stream-buffer-start 0
	stream-buffer-end 0
	stream-is-buffered (typep stream 'si:buffered-input-stream)))

(defresource sage-lexer ()
  :constructor (make-instance 'sage-lexer)
  :initial-copies 1)

(defvar *sage-lexer*)

(defmacro with-sage-lexer ((stream) &body body)
  `(using-resource (*sage-lexer* sage-lexer)
     (send *sage-lexer* :reset ,stream)
     .,body))

(defmethod (:set-state sage-lexer) (new-state)
  (if (member state *legal-lexer-states*)
      (setq state new-state)
      (error "Illegal state ~A" new-state)))

(defmacro with-lexer-state ((lexer-state) &body body &aux (old-lexer-state (gensym)))
  `(let ((,old-lexer-state (send *sage-lexer* :state)))
     (unwind-protect
       (progn     
	 (send *sage-lexer* :set-state ,lexer-state)
	 .,body)
       (send *sage-lexer* :set-state ,old-lexer-state))))


;;; This supports infinite untyi.
(defmethod (:untyi sage-lexer) (ch)
  (when ch (vector-push-extend (thin-character-if-necessary ch) untyi-buffer)))

;;; This guy is only used by the :tyi method.
(defmacro sage-lexer-tyi-internal ()
  `(cond ((plusp (fill-pointer untyi-buffer))
	  (vector-pop untyi-buffer))
	 ((< stream-buffer-start stream-buffer-end)
	  (prog1 (aref stream-buffer stream-buffer-start)
		 (incf stream-buffer-start)))
	 (t (send stream :tyi))))

(defmethod (:tyi sage-lexer) ()
  (case state
    (:transparent
     (sage-lexer-tyi-internal))
    (:raise
     (let ((ch (sage-lexer-tyi-internal)))
       (and ch (char-upcase ch))))
    (:filter-white
     (loop for ch = (sage-lexer-tyi-internal)
	   until (or (null ch) (not (char-white-space-p ch)))
	   finally (return ch)))
    (otherwise
     (cond ((member state *legal-lexer-states*)
	    (error "Lexer state ~A not handled by :TYI" state))
	   (t
	    (error "Illegal lexer state ~A" state))))))

(defmethod (:read-input-buffer sage-lexer) (&optional eof no-hang-p)
  (cond (stream-is-buffered
	 (send stream :read-input-buffer eof no-hang-p))
	((< stream-buffer-start stream-buffer-end)
	 (values stream-buffer stream-buffer-start stream-buffer-end))
	(T
	 (multiple-value-bind (length-so-far eof-p more-on-line)
	     (send stream :string-line-in eof stream-buffer 0 (1- (length stream-buffer)))
	   (setq stream-buffer-start 0
		 stream-buffer-end length-so-far)
	   (cond (eof-p
		  (if (> length-so-far 0)
		      (values stream-buffer stream-buffer-start stream-buffer-end)
		      nil))
		 (more-on-line
		  (values stream-buffer stream-buffer-start stream-buffer-end))
		 (T (setf (aref stream-buffer length-so-far) #\return)
		    (incf stream-buffer-end)
		    (values stream-buffer stream-buffer-start stream-buffer-end)))))))

(defmethod (:advance-input-buffer sage-lexer) (new-pointer)
  (if stream-is-buffered
      (send stream :advance-input-buffer new-pointer)
      (setq stream-buffer-start (or new-pointer stream-buffer-end))))

;;; Get rid of any whitespace that comes before the next non-whitespace char.
(defmethod (:strip-white sage-lexer) ()
  (with-lexer-state (:filter-white)
    (send self :untyi (send self :tyi))))

;;; Returns T and eats the next char if it matches, otherwise returns nil and
;;; leaves the char in the lexer.
(defmethod (:match-ch sage-lexer) (match-ch)
  (let ((ch (send self :tyi)))
    (cond ((null ch) nil)
	  ((char-equal ch match-ch)
	   t)
	  (t
	   (send self :untyi ch)
	   nil))))

;;; Same as :match-ch, but takes one of a set of chars.
(defmethod (:match-oneof-ch sage-lexer) (match-set)
  (let ((ch (send self :tyi)))
    (cond ((null ch) nil)
	  ((member ch match-set :test #'char-equal)
	   ch)
	  (t
	   (send self :untyi ch)
	   nil))))

;;; Same as :match-oneof-ch, but "peeks around" any intervening whitespace.
(defmethod (:match-oneof-ch-saving-whitespace sage-lexer) (match-set)
  (setf (fill-pointer white-buffer) 0)
  (loop for ch = (send self :tyi)
	while ch
	while (char-white-space-p ch)
	do (vector-push-extend (thin-character-if-necessary ch) white-buffer)
	finally (and ch (send self :untyi ch)))
  (let ((ch (send self :match-oneof-ch match-set)))
    (or ch
	(loop until (zerop (fill-pointer white-buffer))
	      do (vector-push-extend (vector-pop white-buffer) untyi-buffer)
	      finally (return nil)))))


;;; Matches an entire string.  Has the same semantics as :match-ch.
(defmethod (:match sage-lexer) (str)
  (setf (fill-pointer buffer) 0)
  (loop with failure-flag = nil
	for match-ch being the array-elements of str
	for ch = (send self :tyi)
	when (null ch)
	  do (return nil)
	for thin-ch = (thin-character-if-necessary ch)
	if (char-equal match-ch ch)
	  do (vector-push-extend thin-ch buffer)
	else do (setq failure-flag t)
		(vector-push-extend thin-ch untyi-buffer)
	until failure-flag
	finally (cond ((null failure-flag)
		       (return t))
		      (t
		       (loop until (zerop (fill-pointer buffer))
			     do (vector-push-extend (vector-pop buffer) untyi-buffer))
		       (return nil)))))

;;; Snarf everything up to the first occurance of an end-char.  Leave the
;;; delimiting char in the lexer.
(defmethod (:delimited-string sage-lexer) (&rest end-chars)
  (setf (fill-pointer buffer) 0)
  (block found-end
    ;; Loop one-by-one for chs in untyi-buffer.
    (dotimes (ignore (fill-pointer untyi-buffer))
      (let ((ch (send self :tyi)))
	(when (null ch) (return-from found-end nil))
	(when (member ch end-chars :test #'(lambda (a b)
					     (cond ((null a) (null b))
						   ((null b) nil)
						   (t (char-equal a b)))))
	  (when ch (send self :untyi ch))
	  (return-from found-end nil))
	(vector-push-extend (thin-character-if-necessary ch) buffer)))
    ;;search for end-char-set in stream's input
    (sys:with-data-stack
      (multiple-value-bind (one-char end-char-set)
	  (if (= (length end-chars) 1)
	      (values (first end-chars) ())
	      (values () (sys:make-stack-array (length end-chars)
					       :element-type 'string-char
					       :initial-contents end-chars)))
	(loop
	  (multiple-value-bind (stream-buf stream-buf-start stream-buf-end)
	      (send self :read-input-buffer ())
	    (when (null stream-buf) (return-from found-end nil))
	    (let ((pos (if one-char
			   (sys:%string-search-char
			     one-char stream-buf stream-buf-start stream-buf-end)
			   (cli::%string-search-array-set
			     stream-buf stream-buf-start stream-buf-end end-char-set))))
	      (string-nconc-portion-hacking
		state buffer
		stream-buf stream-buf-start (or pos stream-buf-end))
	      (send self :advance-input-buffer pos)
	      (when pos (return-from found-end nil))))))))
    ;; Since this can read arbitrarily large amounts of text, it can potentially
    ;; cause the buffer to grow.  So, follow-structure-forwarding to make things
    ;; maximally efficient.
    (setq buffer (follow-structure-forwarding buffer))
    (if (zerop (fill-pointer buffer))
	nil
	(string-append buffer)))

(defun string-nconc-portion-hacking (state buffer stream-buf stream-buf-start stream-buf-end)
  (check-type state (member :transparent :raise :filter-white))
  (when (eql state :filter-white)
    (setq stream-buf-start (or (string-search-not-set *white-space* stream-buf
						      :start stream-buf-start
						      :end stream-buf-end)
			       stream-buf-end)))
  (let* ((portion-length (- stream-buf-end stream-buf-start))
	 (buffer-start (fill-pointer buffer))
	 (buffer-end (+ buffer-start portion-length)))
    ;; this shouldn't need extension very often -- it starts out 10,000 long
    (when (> buffer-end (sys:array-length buffer))
      (setq buffer 
	    (sys:adjust-array-size
	      buffer (+ (sys:array-length buffer)
			(cond ((< (sys:%structure-total-size
				    (follow-structure-forwarding buffer))
				  sys:page-size)
			       (max portion-length #o100))
			      (t (max (truncate (sys:array-length buffer) 4)
				      portion-length)))))))
    (dw::copy-string-eliminating-style stream-buf stream-buf-start stream-buf-end
				       buffer buffer-start buffer-end)
    (when (eql state :raise)
      (nstring-upcase buffer :start buffer-start :end buffer-end))
    (setf (fill-pointer buffer) buffer-end)
    (values buffer buffer-end)))

(defmacro keyword-char-p (ch &environment env)
  (once-only (ch &environment env)
    `(and ,ch
	  (or (alphanumericp ,ch)
	      (member ,ch '(#\# #\& #\%) :test #'char-equal)))))

;;; *delim-stack* is a list of all the pending close delimiters.
(defvar *delim-stack* nil)

(defmacro with-delim-stacked ((delim) &body body)
  `(with-stack-list* (*delim-stack* ,delim *delim-stack*)
     .,body))

(defmacro current-delim ()
  `(car *delim-stack*))

;;; *directive-stack* is a list of all the open directives.
(defvar *directive-stack* nil)

(defmacro with-directive-stacked ((envr form) &body body)
  `(with-stack-list* (*directive-stack* ,envr ,form *directive-stack*)
     .,body))

(defmacro current-directive-form ()
  `(second *directive-stack*))
	 
(defmacro current-directive ()
  `(first *directive-stack*))

;;; A keyword is either any individual character or any number of characters
;;; in the set {A..Z, a..z, 0..9, #, &, %}
;;; This returns up to two values.  The first value is the interned keyword, or null
;;; if it is not in the database.  If the keyword was not found, then the second
;;; value is the string representation of the keyword.
(defmethod (:keyword sage-lexer) (type)
  (setf (fill-pointer buffer) 0)
  (loop for ch = (send self :tyi)
	for thin-ch = (when ch (thin-character-if-necessary ch))
	until (not (keyword-char-p ch))
	do ;; Perhaps this should use array-push-extend, but since the buffer
	   ;; is always at least 10,000. chars long and since I can't imagine
	   ;; any keyword seeming that long in even the most grossly mutilated
	   ;; source file, let's bum some speed.
	   (vector-push thin-ch buffer)
	finally (unless (null ch)
		  (if (and (zerop (fill-pointer buffer))
			   (not (member ch *delim-stack* :test #'char-equal)))
		      ;; The last char is part of the keyword iff it is the only
		      ;; character, since, as a delimiting char, it can not be a
		      ;; legal part of a longer keyword.
		      (vector-push thin-ch buffer)
		      (vector-push-extend thin-ch untyi-buffer)))
		(let ((object-or-null
			(and (> (fill-pointer buffer) 0)
			     (case type
			       (:directive (lookup-directive-descriptor buffer))
			       (:attribute (lookup-attribute-descriptor buffer))
			       (:symbol (intern buffer *sage-package*))
			       (:string (string-append buffer))
			       (otherwise (error "What kinda keyword type is ~S?" type))))))
		  (if object-or-null
		      (return object-or-null)
		      (return (values object-or-null (string-append buffer)))))))

(compile-flavor-methods sage-lexer)


(defstruct (sage-field (:type :list))
  name
  contents)

;;; Define the parser and some new parse directives.  Perhaps this stuff should
;;; go in parser-macros, but I would rather keep that file language-independent.
(eval-when (compile load eval)
(defselect sage-parser
  (:parse-literal-string (eb str)
   `(progn
      (let ((stuff ,(cond ((= (string-length str) 1)
			   `(send *sage-lexer* :match-ch ,(character str)))
			  (t
			   `(send *sage-lexer* :match ,str)))))
	(cond (stuff)
	      ((null ,eb) nil)
	      (t
	       (parse-error ,(format nil "Expected to find ~S" str)))))))
  (:default-separator (ignore) t)
  (:parser-error (&rest args)
   `(parse-error ,@(copy-list args))))

(define-keyword-parser defsage-parse defsage-parse-primitive sage-parser)

(defun (in-delimiters :parser-pattern-expander) (eb &rest patterns)
  (let ((opener (gensym))
	(closer (gensym)))
    `(let* ((,opener (parse-open-delim ,eb))
	    (,closer (and ,opener (cdr (assoc ,opener *delim-pairs* :test #'char-equal)))))
       (and ,closer
	    (with-delim-stacked (,closer)
	      ,(pattern-expand-sequence eb patterns)
	      (parse-close-delim t))))))

(defun (with-directive-stacked :parser-pattern-expander) (eb envr-and-form &rest patterns)
  `(with-directive-stacked ,envr-and-form
     ,(pattern-expand-sequence eb patterns)))

;;; Add comma to the list of delimiters.  Don't parse the delimiter or comma.
(defun (before-comma :parser-pattern-expander) (eb &rest patterns)
  `(with-stack-list (delims (current-delim) #\,)
     (with-delim-stacked (delims)
       ,(pattern-expand-sequence eb patterns))))

(defun (n-times :parser-pattern-expander) (eb n-times &rest patterns)
  eb
  `(let ((rslt-list (loop for n from 0 below ,n-times
			  for rslt = ,(pattern-expand-sequence nil patterns)
			  collect rslt
			  always rslt)))
     (if (and (= ,n-times 0)
	      (null rslt-list))
	 :empty-list
	 rslt-list)))

(defun (upto-n-times :parser-pattern-expander) (eb n-times &rest patterns)
  eb
  `(let ((rslt-list (loop for n from 0 below ,n-times
			  for rslt = ,(pattern-expand-sequence nil patterns)
			  while rslt
			  collect rslt)))
     (or rslt-list :empty-list)))

(defun (with-lexer-state :parser-pattern-expander) (eb state &rest patterns)
  `(with-lexer-state (,state) ,(pattern-expand-sequence eb patterns)))

(defun (lisp :parser-pattern-expander) (eb &rest lisp)
  eb
  `(progn ,@lisp))
);eval-when

(defflavor sage-parse-error ()
	   (error)
  :initable-instance-variables)

(defflavor sage-default-parse-error (msg args)
	   (sage-parse-error)
  :initable-instance-variables)

(defmethod (:report sage-parse-error :default) (stream)
  (format stream "Parse error."))

(defmethod (:init sage-default-parse-error :after) (ignore)
  (setq args (copy-list args)))

(defmethod (:report sage-default-parse-error) (stream)
  (apply #'format stream (string-append "Parse error: " msg) args))

;;; Temporary, until we devise the real error handler.
(defprop parse-error t :error-reporter) 
(defun parse-error (format-string &rest format-args)
  (error 'sage-default-parse-error :msg format-string :args format-args))

(defflavor missing-end-of-directive (directive)
	   (sage-parse-error)
  :initable-instance-variables)

(defmethod (:report missing-end-of-directive) (stream)
  (format stream "Parse error: Missing end of ~A ~A."
	  (dd-parse-type directive) (dd-symbol directive)))

(defflavor unmatched-end ()
	   (sage-parse-error))

(defmethod (:report unmatched-end) (stream)
  (format stream "Parse error: Unmatched @END."))

(defflavor sage-scribe-mismatch (directive)
	   (sage-parse-error)
  :initable-instance-variables)

(defmethod (:report sage-scribe-mismatch) (stream)
  (format stream "Parse error: Directive @~A was not of the type expected."
	  (dd-symbol directive)))

(defflavor short-scribe-in-sage ()
	   (sage-scribe-mismatch))

(defmethod (:report short-scribe-in-sage) (stream)
  (format stream "Parse error: Formatting directive @~A seen where a record field ~
                  was expected."
	  (dd-symbol directive)))

(defflavor short-sage-in-scribe ()
	   (sage-scribe-mismatch))

(defmethod (:report short-sage-in-scribe) (stream)
  (format stream "Parse error: Record field @~A seen where a formatting directive ~
                  was expected."
	  (dd-symbol directive)))

(defflavor long-scribe-in-sage (stack)
	   (sage-scribe-mismatch)
  :initable-instance-variables)

(defmethod (:init long-scribe-in-sage :after) (ignore)
  (setq stack (copy-list stack)))

(defmethod (:report long-scribe-in-sage) (stream)
  (format stream "Parse error: Formatting directive @BEGIN~C~A~C seen where a ~
                  record field was expected."
	  (car (rassoc (car stack) *delim-pairs* :test #'char-equal))
	  (dd-symbol directive)
	  (car stack)))

(defflavor long-sage-in-scribe (stack)
	   (sage-scribe-mismatch)
  :initable-instance-variables)

(defmethod (:init long-sage-in-scribe :after) (ignore)
  (setq stack (copy-list stack)))

(defmethod (:report long-sage-in-scribe) (stream)
  (format stream "Parse error: Record field @BEGIN~C~A~C seen where a ~
                  formatting directive was expected." 
	  (car (rassoc (car stack) *delim-pairs* :test #'char-equal))
	  (dd-symbol directive)
	  (car stack)))

(defflavor nested-sage-records ()
	   (sage-scribe-mismatch))

(defmethod (:report nested-sage-records) (stream)
  (format stream "Parse error: Record begun within another record."))

(defflavor text-between-sage-fields (text)
	   (sage-scribe-mismatch)
  :initable-instance-variables)

(defmethod (:report text-between-sage-fields) (stream)
  (format stream "Parse error: The text ~S was found where a record field was expected.  ~
                  It would have been discarded." text))

;;; *** Eventually, have a stack of long form delimiters so this can be more clever.
(defflavor long-form-mismatch (opener closer)
	   (sage-parse-error)
  :initable-instance-variables)

(defmethod (:report long-form-mismatch) (stream)
  (format stream "Parse error: @BEGIN(~A) was closed with @END(~A)."
	  (dd-symbol opener) (dd-symbol closer)))

(defflavor unterminated-comment ()
	   (sage-parse-error))

(defmethod (:report unterminated-comment) (stream)
  (format stream "Parse error: End of input in middle of comment."))

(defflavor bad-arglist (arguments directive)
	   (sage-parse-error)
  :initable-instance-variables)

(defmethod (:report bad-arglist) (stream)
  (let ((*print-length* nil))
    (format stream "Parse error: ~A @~A was called with ~:[no args~;~:*~S~].  ~
                    Its proper arglist is ~S."
	    (dd-parse-type directive) (dd-symbol directive)
	    arguments (dd-arglist directive))))

#||
(defun test-parser (string)
  (let ((*document-type* 'symanual)
	(*device-type* 'lgp2))
    (with-input-from-string (s string)
      (sage-parse s))))
||#

;;; **** Silly kludge for compatibility with oldthink. ****
;;;I'll say it's silly.  It keeps records from parsing correctly when they have
;;;trailing whitespace.
(defun sage-parse-one-defn (istream)
  (let* ((records (sage-parse istream)))
    (flet ((recordp (r) (typep r 'doc-record)))
      (selector (count-if #'recordp records) =
	(0 (if (null records)
	       ()
	       (error "No record found in this stream.  Found ~S" records)))
	(1 (find-if #'recordp records))
	(otherwise
	  (error "Found more than one record in this stream: ~S" records))))))

(defvar *catch-parser-errors* t)

;;; General top level that returns a list of what it found or nil it found nothing.
(defun sage-parse (istream)
  ;; can't use TYPECASE or TYPEP on ZWEI:INTERVAL-STREAM as Zwei may not be loaded.
  (let ((zwei-present (get 'zwei:interval-stream 'sys:flavor)))
    (condition-case-if (and *catch-parser-errors*
			    (or (typep istream 'si:input-character-stream-from-tributaries)
				(and zwei-present
				     (typep istream 'zwei:interval-stream))))
		       (err)
	 ;; Caller will need to do upgrade-sage-contents-list-for-newthink
	 ;; otherwise loading database.bin calls sage-parse calls u-sage-c-l-for-newthink
	 ;; calls enstyle... which needs database.bin already loaded to execute
	 ;; enstyle (because of with-sage-command-args)
	 (with-sage-lexer (istream)
	   (parse-sage-top-level t))
       (sage-parse-error
	 (beep)
	 (let ((real-stream
		 (typecase istream
		   (si:input-character-stream-from-tributaries
		     (second (send istream :key-pairs)))
		   (otherwise istream))))
	   (cond
	     ((and zwei-present
		   (typep real-stream 'zwei:interval-stream))
	      (typecase istream
		(si:input-character-stream-from-tributaries
		  (let* ((line-count (send istream :line-count))
			 (index (+ (send istream :prev-chars)
				   (send istream :stream-input-index)))
			 (interval (send real-stream :interval))
			 (line (zwei:bp-line
				 (zwei:forward-line
				   (zwei:interval-first-bp interval) line-count))))
		    (zwei:move-point
		      (zwei:create-bp line (min index (zwei:line-length line))))))
		(otherwise
		  (zwei:move-point (send real-stream :read-bp))))
	      (send-if-handles zwei:*typein-window* :prepare-for-typeout)
	      (send zwei:*typein-window* :fresh-line)
	      (send err :report zwei:*typein-window*))
	     (t
	      (send *error-output* :fresh-line)
	      (send err :report *error-output*))))
	 nil))))

;;; Used when you want only records.  Throws away everything else.  Typically
;;; the only other stuff that will be in the list is strings of whitespace, but
;;; like the great bard once said: "Who knows what gubbish lurks in the heart of 
;;; all files.  The parser know!"  (Sorry, I got carried away for a moment there).
;;; Now returns list of comments as a second value -- rom 5-17-87.
(defun parse-sage-records (istream)
  (let ((temp-rslts (sage-parse istream)))
    (loop for rec in temp-rslts
	  when (typep rec 'doc-record)
	    collect rec into records
	  else when (and (typep rec 'sage-envr)
			 (eql (send rec :envr-name) 'commentary))
		 collect rec into comments
	  finally (return (values records comments)))))

;;; This is set to T when we are in a long-form, :SEEN after we have seen the @END
;;; and NIL otherwise.
(defvar *sage-@end-ok*)

;;; This can be one of
;;; :TOP-LEVEL  -- In between records.  We also accept scribe stuff here
;;;                so that commands like M-X Format Region can work.
;;; :SAGE       -- Looking for sage record fields.
;;; :SCRIBE     -- Inside a record field, looking for scribe stuff.
(defvar *parser-state* :top-level)

;;; This is used when parsing arglists to determine whether or not a comma
;;; is expected.  It should be bound to T when parsing the first arg and NIL
;;; otherwise.
(defvar *doing-first-arg*)

;;; Kludge to handle the fact that nil can't be the return value
;;; of a successful parser-production so we use the symbol :EMPTY-LIST
;;; to represent an empty list.
(defmacro body-or-nil (body)
  `(if (eq ,body :empty-list) nil ,body))

;;; Parse any number of declarations or text.  This guy should not be called
;;; recursively.
(defsage-parse parse-sage-top-level () (things)
  ((let ((*sage-@end-ok* nil)
	 (*parser-state* :top-level))
     (= things (zero-or-more-of () parse-sage-thing))))
  (body-or-nil things))

;;; Parse any number of declarations or text.  Returns :EMPTY-LIST if
;;; zero things were found.
(defsage-parse parse-sage-recursive-top-level () (things)
  ((let ((*sage-@end-ok* nil)
	 (*parser-state* :scribe))
     (= things (zero-or-more-of () parse-sage-thing))))
  things)

;;; Parse any number of declarations or text, delimited by "@END".
(defsage-parse parse-sage-recursive-top-level-long-form (&optional no-@end-ok)
							(things (*sage-@end-ok* t))
  ((= things (zero-or-more-of (:continue-if (neq *sage-@end-ok* :seen))
	       parse-sage-thing)))
  (unless (or (eq *sage-@end-ok* :seen)
	      no-@end-ok)
    (error 'missing-end-of-directive :directive (current-directive)))
  ;; Strip off the bogus value that came from parsing the @END
  (if (eq *sage-@end-ok* :seen)
      (or (nbutlast things) :empty-list)
      things))

;;; Parse the stuff that can appear as an argument (the value of a keyword argument
;;; or an entire positional arg).
(defsage-parse parse-sage-recursive-top-level-argument () (thing)
  ((let ((*sage-@end-ok* nil)
	 (form (current-directive-form)))
     (lisp (send *sage-lexer* :strip-white))
     (one-of ()
       (in-delimiters
	 (= thing (selectq-pattern form
		    (:short (parse-sage-recursive-top-level))
		    (:long (parse-sage-recursive-top-level-long-form t)))))
       (before-comma
	 (= thing (selectq-pattern form
		    (:short (parse-sage-recursive-top-level))
		    (:long (parse-sage-recursive-top-level-long-form t))))))))
  thing)


;;; Parse a single declaration or text.
(defsage-parse parse-sage-thing () (thing)              
  ((= thing (one-of ()
	      parse-declaration
	      parse-text)))
  thing)

;;; Parse a declaration.  Dispatches to the proper handler to parse the
;;; declaration.
(defsage-parse parse-declaration () (directive rslt)
  ("@"
   (= directive (parse-keyword :directive))
   (selectq-pattern (dd-parse-type directive)
     (:environment (= rslt (parse-short-envr directive)))
     (:sage-field (= rslt (parse-short-sage-field directive)))
     (:begin (= rslt (parse-long-form)))
     ((:command :macro :reference) (= rslt (parse-command directive)))
     (:end (= rslt (lisp (if *sage-@end-ok*
			     (setq *sage-@end-ok* :seen)
			     (error 'unmatched-end)))))
     (:comment (in-delimiters
		 (= rslt (lisp (make-sage-envr
				 'commentary ()
				 (let ((string (send *sage-lexer* :delimited-string
						     (current-delim))))
				   (when string (list string))))))))
		    (otherwise (lisp (error "What kind of directive type is a ~A, anyway?"
					    (dd-parse-type directive))))))
  rslt)

;;; Parse a short form environment
(defsage-parse parse-short-envr (envr) (body)
  ((with-directive-stacked (envr :short)
     (eval (when (eq *parser-state* :sage)
	     (error 'short-scribe-in-sage :directive envr))        
       (in-delimiters (= body parse-sage-recursive-top-level)))))
  (make-sage-envr (dd-symbol envr) nil (body-or-nil body)))

(defsage-parse parse-short-sage-field (field) (body)
  ((with-directive-stacked (field :short)
     (eval (unless (eq *parser-state* :sage)
	     (error 'short-sage-in-scribe :directive field))
       (in-delimiters (= body parse-sage-recursive-top-level)))))
  (make-sage-field :name (dd-symbol field) :contents (body-or-nil body)))

;;; Parse a long form environment.
;;; The "@BEGIN" has already been removed by our caller
(defsage-parse parse-long-form () (directive type attributes body close-envr)
  ((let ((*parser-state* *parser-state*))       ; Create a new binding contour here
     (with-directive-stacked (nil :long)        ; and fill it in later.
       (in-delimiters
	 (lisp (send *sage-lexer* :strip-white))
	 (= directive (parse-keyword :directive))
	 (eval (setf (current-directive) directive)
	   (selectq-pattern (setq type (dd-parse-type directive))
	     ((:environment :command)
	      (eval (when (eq *parser-state* :sage)
		      (error 'long-scribe-in-sage :directive directive :stack *delim-stack*))
		(= attributes (parse-envr-attributes))))
	     (:sage-field
	      (eval (unless (eq *parser-state* :sage)
		      (error 'long-sage-in-scribe :directive directive :stack *delim-stack*))
		(lisp (setq *parser-state* :scribe))))
	     (:sage-record
	      (eval (unless (eq *parser-state* :top-level)
		      (error 'nested-sage-records))
		(lisp (setq *parser-state* :sage))))
	     (:comment
	      )
	     (otherwise
	       (lisp (parse-error "~A is not an environment or field name."
				  (dd-symbol directive)))))))
       (if (eq type :comment)
	   ;; We have to special case comments 'cuz they don't follow the usual
	   ;; delimiter rules.
	   (= body (parse-long-form-comment))
	   ;; Otherwise, we can do things in the normal way.
	   (= body (if (member type '(:command :macro :reference))
		       (parse-command-long-form)
		       (parse-sage-recursive-top-level-long-form)))
	   ;; The @END may or may not have been removed.  (To be precise, it will have
	   ;; been removed unless we are parsing a command and the last argument was buried
	   ;; in delimiters.  So, optionally parse @END.
	   (if (eq type :command)
	       (one-of (:bind ((end nil)))
		 (then
		   ("@"
		    (= end (parse-keyword :directive)))
		   (unless (eq (dd-parse-type end) :end)
		     (error "The parser expected to see \"@END\" but found \"@~A\".  ~
			      Please send a bug report." (dd-symbol end)))
		   t)
		 (lisp t))
	       (lisp t))
	   (in-delimiters
	     (=  close-envr (parse-keyword :directive)))
	   (lisp (or (eq close-envr directive)
		     (error 'long-form-mismatch :opener directive :closer close-envr)))))))
  (case type
    (:environment
     (make-sage-envr (dd-symbol directive) (body-or-nil attributes) (body-or-nil body)))
    (:command
     (if (setq attributes (body-or-nil attributes))
	 (make-sage-envr (dd-symbol (find-transparent-environment)) attributes (list body))
	 body))
    (:sage-field
     (make-sage-field :name (dd-symbol directive) :contents (body-or-nil body)))
    (:sage-record
     (make-sage-record (body-or-nil body)))
    (:comment
      (make-sage-envr 'commentary () body))
    (otherwise
     (error "Nothing but a loser!"))))

;;; Parse a long form comment.  By the nature of comments, this has to parse
;;; the @END(COMMENT) completely before it can determine that the comment is
;;; finished.
(defsage-parse-primitive parse-long-form-comment (ignore)
  (let ((body ())
	(pending-body ()))
    ;; Looking for @END<delim>COMMENT<matching-delim>
    (loop
      (let ((string (send *sage-lexer* :delimited-string *flag-char*)))
	(when string (push string body)))
      (push (string (send *sage-lexer* :tyi)) pending-body)	;eat the @
      (multiple-value-bind (matches mismatch-string)
	  (parse-long-form-comment-1 "END")
	(when mismatch-string (push mismatch-string pending-body))
	(when matches
	  (send *sage-lexer* :strip-white)	;throw this away, too bad.
	  (let ((open-delim (send *sage-lexer* :tyi)))
	    (push (string open-delim) pending-body)
	    (let ((close-delim (and open-delim (cdr (assoc open-delim *delims*
							   :test #'char-equal)))))
	      (when close-delim
		(multiple-value-bind (matches mismatch-string)
		    (parse-long-form-comment-1 (symbol-name (dd-symbol (current-directive))))
		  (when mismatch-string (push mismatch-string pending-body))
		  (when matches
		    (send *sage-lexer* :strip-white)	;throw this away, too bad.
		    (let ((ch (send *sage-lexer* :tyi)))
		      (when (and ch (char-equal ch close-delim))
			(return))
		      (push (string ch) pending-body)))))))))
      (setq body (nconc pending-body body)
	    pending-body nil))
    ;; (reduce #'string-append (nreverse body))
    (let ((length (loop for string in body sum (length string)))
	  (fatness (some #'string-fat-p body)))
      (let ((result (make-array length :element-type (if fatness 'character 'string-char))))
	(let ((i 0))
	  (dolist (string (nreverse body))
	    (replace result string :start1 i)
	    (incf i (length string))))
	(list result)))))

#||
    (loop with done = nil
	  until done
	  do (catch 'no-good
	       (with-lexer-state (:filter-white)
		 (loop for ch = (send *sage-lexer* :tyi)
		       when (null ch)
			 do (error 'unterminated-comment)
		       until (char-equal ch *flag-char*))
		 (parse-long-form-comment-1 "END")
		 (send *sage-lexer* :strip-white)
		 (setq ch (send *sage-lexer* :tyi))
		 (let ((close-delim (and ch (cdr (assoc ch *delims* :test #'char-equal)))))
		   (when (null close-delim)
		     (and ch (send *sage-lexer* :untyi ch))
		     (throw 'no-good nil))
		   (parse-long-form-comment-1
		     (symbol-name (dd-symbol (current-directive))))
		   (send *sage-lexer* :strip-white)
		   (let ((ch (send *sage-lexer* :tyi)))
		     (unless (and ch (char-equal ch close-delim))
		       (and ch (send *sage-lexer* :untyi ch))
		       (throw 'no-good nil))
		     (setq done t))))))
||#

(defun parse-long-form-comment-1 (string)
  (declare (values matches mismatch-string))
  (send *sage-lexer* :strip-white)		;too bad
  (sys:with-stack-array (save (length string) :element-type 'character :fill-pointer 0)
    (dotimes (i (length string))
      (let ((match-ch (aref string i))
	    (ch (send *sage-lexer* :tyi)))
	(when (null ch) (error 'unterminated-comment))
	(unless (char-equal ch match-ch)
	  (send *sage-lexer* :untyi ch)
	  (return-from parse-long-form-comment-1
	    (values nil (and (> i 0) (copy-string save)))))
	(vector-push ch save)))
    (values T (copy-string save))))

(defsage-parse parse-command-long-form () (arguments)
  ((let ((*doing-first-arg* t))
     (= arguments (parse-command-args))))
  (when (and (null arguments)
	     (plusp (arglist-pattern (current-directive))))
    (error 'bad-arglist :arguments arguments :directive (current-directive)))
  (verify-args (current-directive) arguments))

(defsage-parse parse-command (command) (min-args rest-type arguments)
  ((with-directive-stacked (command :short)
     (eval (progn
	     (when (eq *parser-state* :sage)
	       (error 'short-scribe-in-sage :directive command))
	     (multiple-value-setq (min-args nil rest-type)
	       (arglist-pattern command)))
       (let ((*doing-first-arg* t))
	 (one-of ()
	   (if (eats-delimiters command)
	       ;; The normal case: arguments are inside delimiters and separated by commas.
	       (in-delimiters
		 (= arguments (parse-command-args))))
	   ;; Also accept no delimiters in the no argument case.
	   (lisp (cond ((or (plusp min-args)
			    (eq rest-type :all))
			(error 'bad-arglist :arguments arguments :directive command))
		       (t t))))))))
  (when (and (null arguments)
	     (plusp min-args))
    (error 'bad-arglist :arguments arguments :directive command))
  (verify-args command arguments))

(defsage-parse parse-command-args () (min-args max-args rest-type
					     req-args opt-args rest-args)
  ((one-of ()
     (eval (multiple-value-setq (min-args max-args rest-type)
	     (arglist-pattern (current-directive)))
       (then
	 ((= req-args (n-times min-args (parse-pos-arg)))
	  (= opt-args (if (eq max-args :)
			  (zero-or-more-of () (parse-pos-arg))
			  (upto-n-times (- max-args min-args) (parse-pos-arg)))))
	 t)
       (= rest-args (selectq-pattern rest-type
		      (nil (lisp :empty-list))
		      (:key (parse-keyed-args))
		      (:all (selectq-pattern (current-directive-form)
			      (:short (parse-sage-recursive-top-level))
			      (:long (parse-sage-recursive-top-level-long-form t)))))))
     ;; This second clause of the one-of is a kludge to get the lisp code below to run
     ;; even when not all of the arguments are present, for the sake of generating a
     ;; decent error message.
     (lisp t)))
  (setq req-args (body-or-nil req-args)
	opt-args (body-or-nil opt-args)
	rest-args (body-or-nil rest-args))
  (nconc req-args opt-args (if (eq rest-type :all)
			       (list rest-args)
			       rest-args)))

(defsage-parse parse-envr-attributes () (attributes)
  ((let ((*doing-first-arg* nil))
     (= attributes (zero-or-more-of ()
		     (parse-keyed-arg :attribute
				      (if (eq (dd-parse-type (current-directive))
					      :environment)
					  (current-directive)
					  (find-transparent-environment)))))))
  (body-or-nil attributes))

(defsage-parse parse-keyed-args () (args)
  ((= args (zero-or-more-of () (parse-keyed-arg :symbol (current-directive)))))
  args)

(defsage-parse parse-keyed-arg (lexer-type verification-directive) (key value)
  ((if *doing-first-arg*
       (lisp (setq *doing-first-arg* nil) t)
       (eval (send *sage-lexer* :strip-white) ","))
   (lisp (send *sage-lexer* :strip-white))
   (= key (parse-keyword lexer-type))
   (parse-equate-char)
   (= value (selectq-pattern (key-value-type verification-directive key)
	      (:template
	       (find-template))
	      (:list-of-fields
	       (parse-list-of-words))
	      (otherwise                 
		(parse-sage-recursive-top-level-argument)))))
  (case lexer-type
    (:symbol
     (setq value (body-or-nil value)))
    (:attribute
     (multiple-value-setq (key value)
       (validate-attribute-and-value-type key (body-or-nil value))))
    (otherwise (error "Illegal keyword type ~A." lexer-type)))
  (list key value))

(defsage-parse parse-pos-arg () (rslt)
  ((if *doing-first-arg*
       (lisp (setq *doing-first-arg* nil) t)
       (eval (send *sage-lexer* :strip-white) ","))
   (= rslt (parse-sage-recursive-top-level-argument)))
  (body-or-nil rslt))

(defsage-parse parse-list-of-words () (rslt rslts)
  ((in-delimiters
     (eval (send *sage-lexer* :strip-white)
       (= rslt (parse-keyword :string)))
     (lisp (push rslt rslts))
     (zero-or-more-of ()
       (then
	 ((eval (send *sage-lexer* :strip-white) ",")
	  (eval (send *sage-lexer* :strip-white)
	    (= rslt (parse-keyword :string)))
	  (lisp (push rslt rslts)))))))
  (nreverse rslts))


(defsage-parse-primitive parse-text (ignore)
  (let* ((delims (current-delim))
	 (text (if (listp delims)
		   (lexpr-send *sage-lexer* :delimited-string *flag-char* delims)
		   (send *sage-lexer* :delimited-string *flag-char* delims))))
    (when (eq *parser-state* :sage)
      (unless (every #'char-white-space-p text)
	(error 'text-between-sage-fields :text text))
      (setq text ""))
    text))

(defsage-parse-primitive parse-keyword (ignore type)
  (multiple-value-bind (object string)
      (with-lexer-state (:raise)
	(send *sage-lexer* :keyword type))
    (cond (object object)
	  ((zerop (string-length string))
	   nil)
	  (T (parse-error "~S is not defined as a ~A." string type)))))

(defsage-parse-primitive parse-open-delim (eb)
  (or (send *sage-lexer* :match-oneof-ch-saving-whitespace *open-delims*)
      (and eb (parse-error "Expected an open delimiter."))))

(defsage-parse-primitive parse-close-delim (eb)
  (or (send *sage-lexer* :match-ch (current-delim))
      (when eb
	(let ((desired (current-delim))
	      (found (send *sage-lexer* :tyi)))
	  (cond ((or (null found) (not (member found *close-delims* :test #'char-equal)))
		 (parse-error "Missing close-delimiter ~C." desired))
		(t
		 (parse-error "Found closing delimiter ~C but expected ~C."
			      found desired)))))))

(defsage-parse-primitive parse-equate-char (ignore)
  (with-lexer-state (:filter-white)
    (send *sage-lexer* :match-oneof-ch *equate-chars*))
  (send *sage-lexer* :strip-white)
  t)


(defun make-sage-record (raw-fields &aux type topic source-topic last-topic-field fields)
  (loop with type-list
	for field in raw-fields
	unless (equalp field "")
	  do (case (sage-field-name field)
	       (type
		(setq type-list (sage-field-contents field))
		(unless (= (length type-list) 1)
		  (parse-error "A type must be a simple string, not ~A" type-list))
		(when type
		  (parse-error "Multiple types ~A and ~A for same record."
			       type (car type-list)))
		(setq type (coerce-record-type (car type-list))))
	       (topic
		(when last-topic-field
		  (parse-error "Multiple topics ~A and ~A for same record."
			       last-topic-field (sage-field-contents field)))
		(setq last-topic-field (sage-field-contents field) ))
	       (otherwise
		(push field fields))))
  ;;Capture for source form as well as validating this as symbol
  (setq source-topic last-topic-field)		;this is a contents list already
  (setq topic (catch ':no-such-record (validate-topic last-topic-field type)))
  (cond ((not (or type topic))
	 (parse-error "Record has neither type nor topic."))
	((null type)
	 (parse-error "Record with topic ~A has no type." topic))
	((null topic)
	 (parse-error "Record with type ~A has no topic." type))
	(t
	 ;;--- Note kludgery in not installing record as either edited or installed
	 ;; in its record group
	 (let* ((record-group (find-record-group-for-topic-and-type topic type nil t nil t))
		(record (create-record :topic topic :type type :record-group record-group)))
	   (setf (doc-record-source-topic record)
		 (shrink-record-field 
		   (upgrade-sage-contents-list-for-newthink source-topic :installed)))
	   (process-fields-from-sab record fields :installed)
	   record))))

;;; This is the interface that the sage parser uses to extract a template.
;;; The real template parsing happens in the validation stage.  (This may
;;; be changed when and if type coercion happens in the parser).
(defsage-parse find-template () (rslt)
  ((in-delimiters
     (= rslt (lisp (send *sage-lexer* :delimited-string (current-delim))))))
  (list rslt))

;;; Template parser

(defparameter *TEMPLATE-FLAG-CHAR* #\@)			;Template command esc char
(defparameter *TEMPLATE-NEW-FIELD-CHAR* #\,)

(defparameter *TEMPLATE-CONDITIONAL-CHARS* ":;")

#+Ignore ;;The old definition
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL NIL :SMALLER) "EINY7");;; Legal template parser states:
;;; :INITIAL-STATE ---- At the start of a field.
;;; :TEXT ------------- Reading ordinary characters.
;;; :FLAGGED-IN-TEXT -- Encountered the flag char while in :TEXT state (may be quoting).
;;; :FLAGGED ---------- Encountered the flag char.
(defun parse-template (input-string)
  (with-stack-array (string 100 :element-type 'character :fill-pointer 0)
    (loop with state = :initial-state
	  with little-list = nil
	  with big-list = nil
	  for index from 0 below (string-length input-string)
	  for ch = (aref input-string index)
	  do (case state
	       (:initial-state
		(setf (fill-pointer string) 0)
		(selector ch char-equal
		  (*template-flag-char*
		   (setq state :flagged))
		  (otherwise
		   (decf index)
		   (setq state :text))))
		(:text
		 (selector ch char-equal
		   (*template-flag-char*
		    (setq state :flagged-in-text))
		   (otherwise
		    (vector-push-extend ch string))))
		(:flagged-in-text
		 (selector ch char-equal
		   (*template-flag-char*
		    (vector-push-extend ch string)
		    (setq state :text))
		   (otherwise
		    (decf index)
		    (setq state :flagged)
		    (push (with-input-from-string (s string)
			    (sage-parse s))
			  little-list))))                  
		(:flagged
		 (selector ch char-equal
		   (*template-flag-char*
		    (vector-push-extend ch string)
		    (setq state :text))
		   (*template-new-field-char*
		    (push (nreverse little-list) big-list)
		    (setq little-list nil)
		    (setq state :initial-state))
		   (otherwise
		     (cond ((member ch *template-conditional-chars* :test #'char-equal)
			    ---))
		    (push ch little-list)
		    (setq state :initial-state))))
		(otherwise
		 (error "Illegal state: ~A" state)))
	     finally (selectq-every state
		       (:initial-state)
		       ((:text :flagged-in-text)
			(push (with-input-from-string (s string)
				(sage-parse s))
			      little-list))
		       ((:flagged :flagged-in-text)
			(parse-error "Stray ~C in template." *template-flag-char*)))
		     (push (nreverse little-list) big-list)
		     (return (nreverse big-list)))))

0(defun parse-template (input-string)
  (let ((index 0)
	(limit (length input-string)))
    (labels ((get-char (&key end-ok)
	       (if ( index limit)
		   (if end-ok
		       ()
		       (parse-error "Unexpected end of counter template ~s" input-string))
		   (prog1 (char input-string index)
			  (incf index))))
	     (parse-field ()
	       (sys:with-stack-array (string 100 :element-type 'character :fill-pointer 0)
		 (let ((field ()))
		   (flet ((flush-string ()
			    (when (> (fill-pointer string) 0)
			      (push (with-input-from-string (s string)
				      (sage-parse s))
				    field)
			      (setf (fill-pointer string) 0))))
		     (loop
		       (let ((char (get-char :end-ok T)))
			 (select char
			   (*template-flag-char*
			     (let ((next-char (get-char)))
			       (cond ((char-equal next-char *template-flag-char*)
				      (vector-push-extend next-char string))
				     ((char-equal next-char *template-new-field-char*)
				      (flush-string)
				      (return (nreverse field)))
				     ((position next-char *template-conditional-chars*
						:test #'char-equal)
				      (flush-string)
				      (push (list next-char (get-char)) field))
				     (T (flush-string)
					(push next-char field)))))
			   ((nil)
			    (flush-string)
			    (return (nreverse field)))
			   (otherwise
			     (vector-push-extend char string))))))))))
      (loop for field = (parse-field) while field
	    collect field))))

#||
;;; (2 0 (NIL 0) (NIL :BOLD :LARGE) "MEDFNTB")TEMPLATE PARSER TEST SUITE CODE
0;;; This code can't be loaded until after database.bin is loaded,
;;; so it's commented-out here.  You can compile it out of your buffer, for now.

(defun construct-template-parser-data (data)
  (labels ((frob-list (list)
	     (when (consp list)
	       (mapl (lambda (tail)
		       (let ((item (first tail)))
			 (when (consp item)
			   (if (eql (first item) '!)
			       (setf (first tail) (eval (second item)))
			       (frob-list item)))))
		     list))))
    (dolist (datum data)
      (destructuring-bind (string &rest expected) datum
	(ignore string)
	(frob-list expected))))
  data)

(defparameter *test-template-parser-data*
	      (construct-template-parser-data
		'(("123" (("123")))
		  ("@1" (#\1))
		  ("@1@,@i" (#\1) (#\i))
		  ("@1.@,@i." (#\1 (".")) (#\i (".")))
		  ("@1@#@:.@;zy@,*"
		   (#\1 #\# (#\: #\.) (#\; #\z) ("y"))
		   (("*")))
		  ("1@@@@" (("1" (! (make-sage-command 'literal-atsign)))))
		  ("@$[a@,b@,c]" (#\$ ("a") ("b") ("c")))
		  ("@@+[@1]" ---)
		  )))

(defun test-template-equal (x y)
  (cond ((eql x y)
	 T)
	((and (consp x) (consp y))
	 (every #'test-template-equal x y))
	((typep x 'sage-command)
	 (and (typep y 'sage-command)
	      (eql (send x :command-name)
		   (send y :command-name))
	      (equal (send x :parameter)
		     (send y :parameter))))
	(T (equal x y))))

(defun test-template-parser ()
  (let ((lost ()))
    (dolist (test *test-template-parser-data*)
      (destructuring-bind (string &rest expected-result) test
	(let ((actual-result
		(with-document-and-device-types ()
		  (condition-case (err)
		       (parse-template string)
		     (error (princ-to-string err))))))
	  (unless (test-template-equal actual-result expected-result)
	    (format T "~&For ~s, ~%~14<got~> ~s ~%~14<but expected~> ~s"
		    string actual-result expected-result)
	    (setq lost T)))))
    (not lost)))

(zwei:defcom com-test-parser "Test sage parser on the region" ()
  (print
    (zwei:region (start-bp end-bp)
      (with-open-stream (in (zwei:open-interval-stream start-bp end-bp T))
	(with-document-and-device-types ()
	  (sage-parse in)))))
  zwei:dis-none)

foo@begin(comment)abc@end(comment)mumble
foo@begin(comment)@pageheading[@end(comment)mumble
foo@begin(comment)@pageheading[@end(gack)@end(comment)mumble
foo@begin(comment)@pageheading[@end(gack)@end(comment]@end(comment)mumble  )
foo@begin(comment)@pageheading[@end(gack)@end(commentary)@end(comment)mumble
||#
