;;;-*- Syntax: Common-lisp; Mode: Lisp; Package: Nsage; Lowercase: T; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;The parts of the formatter having to do with line-sources, 
;; unexpanded-reference expansion, horizontal annotation, environment caching, 
;; and various little formatter utilities.

;;; D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")HOW IT IS THAT YOU DO FORMATTING:
0;;; Do ((2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")formatted-sage-record-line-source 1record-group0).
;;; What it returns is a source of lines.  You send that source 2:take-line0 messages.
;;; Each line it returns is a line-hbox, already annotated.  When you have exhausted
;;; the source, it returns NIL.

;;; For debugging.  Signals a line-too-long condition whenever a line is
;;; wrapped or chopped.
(defvar 2*signal-line-too-long*0 nil)

(defflavor 2line-too-long
0	(string start-index end-index losing-start losing-end line-action)
	(condition)
  (:settable-instance-variables))

(defmethod 2(:report0 2line-too-long)0 (stream)
  (format stream "Found line too long while formatting.  Longlines mode = ~A.~&String: ~S~
                  ~&Lost: ~S" line-action (substring string start-index end-index)
		  (substring string losing-start losing-end)))

(defmethod 2(:proceed0 2line-too-long0 2:no-action)0 ()
  "Continue formatting."
  :no-action)

(defflavor 2source-of-formatted-sage-lines
0	   (first-line-hbox
	    available-line-hbox
	    extra-space-below)
  ()
  :abstract-flavor
  :settable-instance-variables)

(defun-in-flavor (2init-annotation0 source-of-formatted-sage-lines) (gbox)
  (setq gbox (horizontal-annotate-gbox gbox))
  (annotate-line-breaks-for-filling gbox)
  (setq first-line-hbox (assemble-line-hboxes gbox)
	available-line-hbox first-line-hbox
	extra-space-below 0))

;;Debugging only.
(defvar 2*make-environments-tiny*0 T)

(defmethod 2(:take-line0 2source-of-formatted-sage-lines)0 ()
  (when available-line-hbox
    (loop for line = (send available-line-hbox :expand-references)
	  while (and line (neq line :no-expansion-needed))
	  do (setq available-line-hbox line))
    (let ((line available-line-hbox))
      (setq available-line-hbox (box-next line))
      (when available-line-hbox
	;;Expand the next line in case it has to be attached to the end of this one.
	(loop for following-line = (send available-line-hbox :expand-references)
	      until (eq following-line :no-expansion-needed)
	      do (setq available-line-hbox following-line)
	      while following-line))
      (when (send line :line-annotation-needed)
	(send line :annotate-line-heights)
	;; Mouse-sensitivity annotation replaced by presentation gboxes
	;(send line :annotate-mouse-sensitivity)
	(send line :annotate-line-spread)
	(send line :annotate-page-info)
	(justify-line-if-necessary line)
	(add-underlining line)
	(annotate-line-box-widths line)
	(when *make-environments-tiny*
	  (send line :make-environments-tiny)))
      (values line extra-space-below))))

;;;Provide a way of resetting where you are taking the lines from
(defmethod 2(:take-it-from0 2source-of-formatted-sage-lines)0 (&optional line-hbox)
  (setq available-line-hbox
	(or line-hbox
	    first-line-hbox)))

(defflavor 2source-of-formatted-sage-record-lines
0	   (record-group first-doc-record)
  (source-of-formatted-sage-lines)
  (:required-init-keywords :record-group)
  :settable-instance-variables)

(defun 2formatted-sage-record-line-source 0(record-group)
  (make-instance 'source-of-formatted-sage-record-lines :record-group record-group))

(defmethod 2(:init0 2source-of-formatted-sage-record-lines)0 (ignore)
  (with-ambient-counters
    (with-document-and-device-types ()
      (setq first-doc-record (doc-record-for-record-group record-group))
      (let (prior-long-line)
	(condition-bind-default
	  ((line-too-long
	     #'(lambda (condition)
		 (declare (sys:downward-function))
		 (unless *in-dex-background*
		   (let ((string (send condition :string)))
		     (format *error-output*
			     "~:[~2&>> While formatting ~A ~A:~;~2*~]~2&Line too long.  ~
                        Longlines mode = ~A~&  String: ~S~&  Lost: ~S"
			     prior-long-line (namespace-type-string record-group)
			     (appropriate-title-rendering record-group 'no-formatting)
			     (send condition :line-action)
			     (nsubstring string (send condition :start-index)
					 (send condition :end-index))
			     (nsubstring string (send condition :losing-start)
					 (send condition :losing-end)))
		     (setq prior-long-line t)))
		 (send condition :proceed :no-action))))
	  (init-annotation (copy-record-into-gbox first-doc-record)))))))

(defflavor 2source-of-formatted-sage-text-lines
0	   (contents)
  (source-of-formatted-sage-lines)
  (:required-init-keywords :contents)
  :settable-instance-variables)

(defun 2formatted-sage-text-line-source0 (contents &optional suppress-init)
  (make-instance 'source-of-formatted-sage-text-lines
		 :contents (if suppress-init
			       contents
			       (append (init-directives-from-book-design)
				       contents))))

(defmethod 2(:init0 2source-of-formatted-sage-text-lines)0 (ignore)
  (with-ambient-counters
    (with-document-and-device-types ()
      (init-annotation
	(with-device-toplevel-environment (envr)
	  (with-temp-list-head (head)
	    (splice-contents-list head envr contents)))))))

(defflavor 2source-of-formatted-sage-gboxed-lines0 ()
	   (source-of-formatted-sage-lines)
  (:init-keywords :first-gbox)
  (:required-init-keywords :first-gbox)
  :settable-instance-variables)

(defmethod 2(:init0 2source-of-formatted-sage-gboxed-lines)0 (init-plist)
  (with-document-and-device-types ()
    (let ((gbox (getf (cdr init-plist) :first-gbox)))
      (init-annotation gbox))))

(defun 2init-directives-from-book-design0 ()
  (making-sage-directives ()
    (mapc #'funcall
	  (book-design-specifics-init-code
	    (composed-book-design *document-type* *device-type*)))))

;;; Why this uses EXTRA-SPACE-ABOVE:
;;; See (:take-line source-of-formatted-sage-lines).  That is where line
;;; annotation, mouse-sensitivity annotation, line-spread annotation,
;;; and conversion to tiny environments happen, in that order.  These
;;; happen only when :LINE-ANNOTATION-NEEDED returns true.  This used to
;;; check whether HEIGHT was bound, but HEIGHT is bound during line
;;; annotation.  EXTRA-SPACE-ABOVE is bound during line-spread
;;; annotation.  Suppose you get an error in mouse-sensitivity
;;; annotation and abort out of it.  Then HEIGHT is bound, but
;;; EXTRA-SPACE-ABOVE is not.  Checking EXTRA-SPACE-ABOVE here is a
;;; little better indication that the line-annotation phase was really
;;; completed.  There should really be another instance variable,
;;; something like LINE-ANNOTATION-FINISHED, that is initialized to NIL
;;; and set to T only when the line-annotation phase is really done.
(defmethod 2(:line-annotation-needed0 2line-hbox)0 ()
  ;;This is a little distasteful, but it'll do.
  (not (variable-boundp extra-space-above)))

(defmethod 2(:line-annotation-needed0 2fake-line-hbox)0 ()
  (not (variable-boundp height)))

(defmethod 2(:unexpanded-p line-hbox)0 ()
  nil)
(defmethod 2(:unexpanded-p unexpanded-reference-line-hbox)0 ()
  t)


(defmethod 2(:expand-references0 2line-hbox)0 ()
  :no-expansion-needed)

(defmethod 2(:expand-references0 2fake-line-hbox)0 ()
  :no-expansion-needed)

(defmethod 2(:expand-references0 2unexpanded-reference-line-hbox)0 ()
  (let (prior-long-line)
    (condition-bind-default
      ((line-too-long
	 #'(lambda (condition)
	     (declare (sys:downward-function))
	     (unless *in-dex-background*
	       (let ((record-group (send gbox :record-group))
		     (string (send condition :string)))
		 (format *error-output*
			 "~:[~2&>> While formatting ~A ~A:~;~2*~]~2&Line too long.  ~
                        Longlines mode = ~A~&  String: ~S~&  Lost: ~S~&"
			 prior-long-line (namespace-type-string record-group)
			 (appropriate-title-rendering record-group 'no-formatting)
			 (send condition :line-action)
			 (nsubstring string (send condition :start-index)
				     (send condition :end-index))
			 (nsubstring string (send condition :losing-start)
				     (send condition :losing-end)))
		 (setq prior-long-line t)))
	     (send condition :proceed :no-action))))
      (let ((new-gbox (send gbox :reference-expand-self)))
	(setq new-gbox (or (horizontal-annotate-gbox new-gbox)
			   1;; This kludge is needed because if the unexpanded
			   ;; reference is a contents to an empty record (or one with
			   ;; just whitespace), 0horizontal-annotate-gbox1 returns NIL.
			   ;; There really should be a NO-OP GBOX, I guess.
			   ;;0						1 - ctd 10/3/90
0			   (let ((dummy-gbox
				   (make-string-gbox (send gbox :environment) "" 0 0)))
			     (width-annotate-gboxes dummy-gbox)
			     dummy-gbox)))
	(setq new-gbox
	      ;; need this temp-list because this might want to splice
	      ;; out the first gbox (e.g. TABCLEAR) or something.
	      (with-temp-list-head (head)
		(splice-box-chain-after head new-gbox)
		(annotate-line-breaks-for-filling new-gbox)))
	(let* ((new-line-hbox (assemble-line-hboxes new-gbox))
	       (last-line-in-chain (loop for box = new-line-hbox then box-next
					 for box-next = (box-next box)
					 when (null box-next) return box))
	       (old-next (box-next gbox)))	; what came after the unexpanded gbox
	  ;;Splice the gbox expansion into the chain, in place of the unexpanded gbox
	  (splice-box-chain-after gbox new-gbox)
	  (let ((prev-text (gbox-prev-text gbox))
		newline)
	    (cond ((send new-line-hbox :unexpanded-p)
		   
		   ;; we can't do any line splicing until we've expanded
		   ;; the next guy.  Replace the original unexpanded gbox
		   ;; with the new unexpanded gbox and go on
		   ;(dbg:whistle)
		   (setq newline (send new-line-hbox :gbox))
		   (splice-box-out gbox))
		  ((or (null prev-text)
		       (and (send prev-text :paragraph-break?)
			    (line-contains-gbox-p prev prev-text)
			    ))
		   ;; Merge the expansion with the previous line in either
		   ;; of these circumstances (details of merging are below).
		   ;;- - -
		   ;; All previous stuff is like @pageheading and @string and Enter
		   ;; and otherwise not text at all, in which case prev-text is NIL.
		   ;;- - -
		   ;; The previous text is a paragraph break 1and0 it's
		   ;; in the previous line.  I think this extra check is useful
		   ;; to avoid problems that stem from:
		   ;;
		   ;; (3 0 (NIL 0) (SAGE:SANS-SERIF-BODY SYMBOL :NORMAL) "SYMBOL12")0 <exit>
		   ;; <unexpanded-gbox>
		   ;; current-line
		   ;;
		   ;; In this case, the prev-text is the paragraph break, but
		   ;; current-line does not want to be attached to its previous line.
		   
		   ;;line must be attached to the prev one.  The 1contents0 of the first line 
		   ;;of the expansion is spliced onto the tail of the previous line; so, we
		   ;;don't want to splice the (first) line itself in at all.
		   (setq newline (send new-line-hbox :newline-gbox))
		   (splice-box-out gbox)
		   ;;If new-line-hbox were a list, we'd CDR it
		   (setq new-line-hbox (box-next new-line-hbox))
		   (when new-line-hbox (setf (box-prev new-line-hbox) ())))
		  (T				;the new line stays separate from the prev one
		   (setq newline (make-newline-gbox (send gbox :environment)))
		   (splice-replace-box gbox newline)))
	    ;; The previous line ended with this unexpanded gbox.  Replace it.
	    ;; :assemble-line-hbox for an unexpanded-reference-gbox creates
	    ;; two lines, one that ends with SELF and an unexpanded-reference-line-hbox
	    ;; whose gbox is also SELF.  This is why this code expects to find this line's
	    ;; gbox as the :newline-gbox of the previous line.
	    ;; However, view=contents expansions may result
	    ;; in an unexpanded-reference-line-hbox being spliced in with no preceding
	    ;; line that ends with this gbox.  This code used to signal an error when
	    ;; the previous line didn't end with this unexpanded gbox.  That check
	    ;; is useless now.
	    (when prev
	      (let ((old-prev-next (send prev :newline-gbox)))
		(when (eq old-prev-next gbox)
		  (send prev :set-newline-gbox newline))))
	    ;; if the stuff that was after the unexpanded gbox is :valid-after-newline-p
	    ;; then it wants to be part of the last line in the spliced in chain
	    (unless (send last-line-in-chain :unexpanded-p)
	      (let ((end-box nil)
		    (next-line-first-gbox (when next (send-if-handles next :first-gbox))))
		(loop for box = old-next then (box-next box)
		      while (and box
				 (neq box next-line-first-gbox)
				 (send box :valid-after-newline-p))
		      do (setq end-box box))
		(when end-box
		  (send last-line-in-chain :set-newline-gbox end-box)))))
	  
	  ;;Splice the line-hbox expansion into the chain, in place of the unexpanded hbox
	  (when new-line-hbox
	    (splice-box-chain-after self new-line-hbox))
	  (splice-box-out self)
	  next)))))

(defmethod 2(:reference-expand-self0 2unexpanded-reference-gbox)0 ()
  (with-temp-list-head (head)
    (let* ((*sage-expansion-history* (cons record-group within-records))
	   (*prevailing-heading-generator*
	     ;; If there isn't one, don't do anything, we must be
	     ;; in s-c-S mode.
	     (when prevailing-heading-generator
	       (clone-self prevailing-heading-generator)))
	   (predecessor head)
	   (record (doc-record-for-record-group record-group ()))
	   (restriction (doc-record-hardcopy-restriction record)))
      (flet ((unrestricted ()
	       (cond ((consp view)		;This had better be a list of fields
		      (loop for field in view
			    do (setq predecessor
				     (splice-field record
						   ;; Some loser uses field=operation!
						   (if (eql field 'operation) 'contents field)
						   predecessor environment))))
		     ((or (null view)
			  (string-equal view "Expand"))	;Any other names for "everything"?
		      ;; If there isn't one, don't do anything, see above
		      (when *prevailing-heading-generator*
			(increment-heading *prevailing-heading-generator*))
		      (setq predecessor
			    (splice-everything record predecessor environment)))
		     ((string-equal view "Contents")
		      (setq predecessor
			    (splice-field record 'contents predecessor environment)))
		     ((string-equal view "Precis")
		      (setq predecessor
			    (splice-precis record predecessor environment)))
		     (T (error "Requested undefined view: ~s" view)))))
	(if restriction
	    (multiple-value-bind (restriction-note-contents-list did-actually-restrict)
		(funcall restriction record 'contents-list)
	      (if did-actually-restrict
		  (setq predecessor (splice-contents-list predecessor environment
							  restriction-note-contents-list))
		  (unrestricted)))
	    (unrestricted))))))

(defgeneric 2line-contains-gbox-p0 (line gbox))

(defmethod 2(line-contains-gbox-p fake-line-hbox)0 (ignore)
  nil)

(defmethod 2(line-contains-gbox-p unexpanded-reference-line-hbox)0 (ignore)
  nil)

(defmethod 2(line-contains-gbox-p line-hbox)0 (match-gbox)
  (do-line-gboxes (gbox first-gbox newline-gbox)
    (when (eq gbox match-gbox) (return t))))


;;Mess around with temp-list-head so if the first gbox needs to replace itself,
;;we still have a way to point to the chain.
(defvar 2*debug-annotation-phases*0 ())

(defun2 horizontal-annotate-gbox0 (first-gbox)
  (with-temp-list-head (head)
    (flet ((trc (string)
	     (when *debug-annotation-phases*
	       (format T "~&~a" string)
	       (when (fboundp 'brief-gboxes)
		 (funcall 'brief-gboxes head ())))))
      (setf (box-next head) first-gbox)
      (when first-gbox (setf (box-prev first-gbox) head))
      (do-box-successors (gbox (box-next head))
	(send gbox :process-definitions))
      ;; must process definitions 1before0 inserting any generated text
      ;; because definitions may change the way counters are rendered,
      ;; or whether environments break-on-exit, etc.
      (do-box-successors (gbox (box-next head))
	(send gbox :insert-generated-text))
      (do-box-successors (gbox (box-next head))
	(send gbox :strip-page-characters))
      (do-box-successors (gbox (box-next head))
	(send gbox :canonicalize-leading-spaces))
      (progn "annotate newlines"
	     (trc "Before :annotate-newlines")
	     (do-box-successors (gbox (box-next head))
	       (send gbox :annotate-newlines)))
      ;; canonicalize-leading-spaces again, now that more newlines
      ;; may be present
      (do-box-successors (gbox (box-next head))
	(send gbox :canonicalize-leading-spaces))
      (progn "canonicalize paragraph breaks"
	     (trc "After :annotate-newlines, before :canonicalize-paragraph-breaks")      
	     (do-box-successors (gbox (box-next head))
	       (send gbox :canonicalize-paragraph-breaks))
	     (trc "After :canonicalize-paragraph-breaks"))
      ;; Handle the UnindentParagraph command
      (progn "unindent paragraphs"
	     (let ((unindent? nil))
	       (do-box-successors (gbox (box-next head))
		 (setq unindent?
		       (send gbox :unindent-paragraphs unindent?)))))
      (insert-counter-numbers (box-next head))
      (do-box-successors (gbox (box-next head))
	(send gbox :annotate-for-box-support))
      (do-box-successors (gbox (box-next head))
	(send gbox :transform-characters))
      (progn "canonicalize spaces"
	     (do-box-successors (gbox (box-next head))
	       (send gbox :canonicalize-spaces)))
      (width-annotate-gboxes (box-next head))
      (trc "After canonicalize-spaces, before :line-break-annotate")
      (progn "line break annotate"
	     (do-box-successors (gbox (box-next head))
	       (send gbox :line-break-annotate))
	     (trc "After :line-break-annotate"))
      (progn "shuffle environment breaks"
	     (shuffle-environment-breaks (box-next head))
	     (trc "After shuffle-environment-breaks"))
      )))

(defmethod2 (:annotate-newlines0 2basic-gbox0 2:default)0 () ())
(defmethod2 (:annotate-newlines0 2newline-gbox)0 ()
  (let ((carriage-return-action (send environment :carriage-return-action)))
    (ecase carriage-return-action
      (1paragraph-break0				;1crbreak
0	;;Don't hack with blank-line-action, I guess.  Only @verse uses this anyway.
	(splice-boxes-after self (make-paragraph-break-gbox
				   environment
				   (send environment :paragraph-breaks))))
      (1(ignored spaces0)				;1---Really?
0       (let ((blank-line-action (send environment :blank-line-action)))
	 (let ((prev-text (gbox-prev-text self)))
	   (when (and (not (send self :hard-newline))
		      (or (null prev-text)
			  (send prev-text :ends-with-newline?)))
	     (ecase blank-line-action
	       ((1ignored0)			;1"blanklines ignored"
0		(splice-box-out self))
	       ((1word-break0)			;1??
0		;;This means, do whatever space-action says.
		;;So replace with spaces for annotation later on.
		(splice-replace-box self (make-space-gbox environment)))
	       ((1paragraph-break0)		;1"blanklines break"
0		(splice-replace-box self (make-paragraph-break-gbox
					   environment
					   (send environment :paragraph-breaks))))
	       ((1keep-line0)			;1"blanklines kept"
0		;; harden yourself so another phase doesn't take you out
		(send self :set-hard-newline T)
		)
	       ((1hinge0)				;1"blanklines hinge"
0		(splice-replace-box self (make-command-gbox environment 'hinge)))
	       ((1break-and-hinge0)		;1"blanklines hingebreak"
0		(splice-boxes-after self
				    (make-paragraph-break-gbox
				      environment
				      (send environment :paragraph-breaks))
				    (make-command-gbox environment 'hinge))
		(splice-box-out self))
	       ((1keep-and-hinge0)		;1"blanklines hingekeep"
0		(splice-boxes-after self (make-command-gbox environment 'hinge)))
	       ))))))))

(defmethod 2(:annotate-newlines0 2command-gbox)0 ()
  (command-gbox-annotate-newlines self))

(define-command-gbox-generic 2command-gbox-annotate-newlines0 ()
  (unless (send self :text?)
    (strip-newline-from-lone-directive self)))

(define-command-gbox-method 2(command-gbox-annotate-newlines force-line-break)0 ()
  ;; Force ONLY a line break, not a paragraph
  ;; break, so if there is a following newline
  ;; get rid of it.
  (let ((next-text (gbox-next-text self)))
    (when (and next-text (send next-text :newline?))
      (splice-box-out next-text)))
  (splice-replace-box self (make-hard-newline-gbox environment)))

(define-command-gbox-method 2(command-gbox-annotate-newlines (blankspace newpage))0 ()
  ;; a blankspace command needs to be on a line by itself
  ;; this means that even @blankspace(0) turns into one blank line.
  (let ((next-text (gbox-next-text self))
	(prev-text (gbox-prev-text self)))
    (when next-text
      (if (send next-text :newline?)
	  (send next-text :set-hard-newline t)
	  (splice-boxes-after self (make-hard-newline-gbox environment))))
    (when prev-text
      (if (send prev-text :ends-with-newline?)
	  (send-if-handles prev-text :set-hard-newline t)
	  (splice-box-before self (make-hard-newline-gbox environment))))))

(defmethod 2(:annotate-newlines0 2envr-entry-gbox)0 ()
  (strip-newline-from-lone-directive self)
  (when (send environment :break-on-entry)
    (flet ((flush-next-newline ()
	     (let ((next-text (gbox-next-text self)))
	       (when (and next-text (env-inside (send next-text :environment) environment))
		 (send next-text :flush-newline)))))
      (let ((prev-text (gbox-prev-text self)))
	(cond ((or (null prev-text) (send prev-text :paragraph-break?))
	       )
	      (t
	       (ecase (send environment :fill-mode)
		 ((fill)
		  (unless 
		    ;; don't want 1n0 (one per nested environment)
		    ;; hard-newlines inserted, just one.
		    (send-if-handles prev-text :hard-newline)
		    (splice-box-before self
				       (make-hard-newline-gbox (send environment :superior))))
		  (flush-next-newline))
		 ((centered flushright flushleft)
		  ;;Harden an existing newline, if any, to make sure some later annotation
		  ;;phase doesn't flush it.  
		  ;; However, 1only0 harden existing newlines OUTSIDE of this environment
		  (let ((prev-text (gbox-prev-text self)))
		    (cond ((or (null prev-text) (send prev-text :paragraph-break?))
			   ;;If there is nothing earlier, or this is at start of a paragraph,
			   ;;this must be at beginning of a line, so nothing to do.
			   )
			  ((send prev-text :ends-with-newline?)
			   (send-if-handles prev-text :set-hard-newline T))
			  (T
			   ;; Put the initial newline before the
			   ;; envr-entry-gbox, so the space above the
			   ;; envr gets put above the envr, not above
			   ;; some line before the envr.  The only
			   ;; reasonable environment for the newline
			   ;; is the superior of this environment.
			   (splice-box-before self
					      (make-hard-newline-gbox
						(send environment :superior)))
			   ;;  When a newline has actually been inserted, take out
			   ;;  any immediately following newline, to avoid a
			   ;;  spurious line containing only the envr entry.
			   (flush-next-newline))))))))))))

(defmethod 2(:annotate-newlines0 2envr-exit-gbox)0 ()
  (strip-newline-from-lone-directive self)
  (when (send environment :break-on-exit)
    (let* ((prev-text (gbox-prev-text self))
	   (prev-text-inside? (when prev-text
				(env-inside (send prev-text :environment)
					    environment))))
      (unless (or (null prev-text) (and prev-text-inside?
					(send-if-handles prev-text :hard-newline)))
	(let ((next-text (gbox-next-text self)))
	  (unless (or (null next-text) (send-if-handles next-text :hard-newline))
	    (cond ((and prev-text-inside? (send prev-text :ends-with-newline?))
		   (send-if-handles prev-text :set-hard-newline T))
		  ((send next-text :newline?)
		   (send-if-handles next-text :set-hard-newline T))
		  (T ;;Put the final newline after the envr-exit-gbox, so the
		   ;;space below the envr gets put below the envr, not below
		   ;;some line after the envr.  The only reasonable environment
		   ;;for the newline is the superior of this environment.
		   (splice-boxes-after
		     self (make-hard-newline-gbox (send environment :superior)))))))))))

(defun 2strip-newline-from-lone-directive0 (directive-gbox)
  (let ((prev-text (gbox-prev-text directive-gbox))
	(next-text (gbox-next-text directive-gbox)))
    (when (and (or (null prev-text)
		   (send prev-text :ends-with-newline?))
	       next-text (send next-text :newline?))
      (splice-box-out next-text))))

;;2:line-break-annotate0 puts in newlines where envr entry and exit needs it.
;;Also converts force-line-break commands to newlines.


(defmethod2 (:line-break-annotate0 2basic-gbox0 2:default)0 ()
  ())

(defmethod2 (:line-break-annotate0 2paragraph-break-gbox)0 ()
  (let ((prev-text (gbox-prev-text self)))
    (when (and (not (null prev-text))		;must be previous text
	       (or
		 ;; either the previous text is a paragraph break in
		 ;; this environment
		 (and (typep prev-text (type-of self))
		      (eql (send prev-text :environment) environment))
		 ;; or it doesn't end with a newline
		 (not (send prev-text :ends-with-newline?))))
      (splice-box-before self (make-newline-gbox environment)))))

(defun 2env-inside0 (e1 e2)
  ;;(loop for s being e1 and its superiors ...)
  (loop for prev-superior = e1
			  then (send prev-superior :superior)
	while prev-superior
	thereis (eq prev-superior e2)))

;;The intent here is to remove consecutive paragraph breaks which can arise
;;sometimes from multiple blank lines.
(defmethod2 (:canonicalize-paragraph-breaks0 2basic-gbox0 2:default)0 () ())
(defmethod2 (:canonicalize-paragraph-breaks0 2paragraph-break-gbox)0 ()
  ;;break-type is used below, and in :display-gbox method.
  (let ((prev-text (gbox-prev-text self)))
    (cond ((gbox-next-text self)		;only keep paragraph breaks followed by text
	   (when prev-text
	     (cond ((typep prev-text (type-of self))
		    ;;Figure out which of two consecutive paragraph breaks to keep.
		    ;;If the current one is a full break, always keep it, toss the prev one.
		    ;;The tricky part is if the prev one was a full break and the current one
		    ;;is a limited break; then, if the current one is in an environment
		    ;;superior to the other, keep the current one; if not, keep the prev one.
		    (ecase break-type
		      (1normal0			;If this one is a full break, keep it always.
			(splice-box-out prev-text))
		      (1limited
0			;;If the current (limited) break is in a superior environment,
			;;keep it; otherwise keep the previous (full) break.
			(if (env-inside (send prev-text :environment) environment)
			    (splice-box-out prev-text)
			    (splice-box-out self)))))
		   ((send prev-text :ends-with-newline?)
		    (send prev-text :flush-extra-newline))
		   (T
		    ()))))
	  (T (when (and prev-text (typep prev-text (type-of self)))	;discard trailing ones
	       (splice-box-out prev-text))
	     (splice-box-out self)))))

(defun 2environment-specially-hacks-paragraphs0 (environment)
  ;; break-on-entry only means paragraph-break-on-entry when
  ;; blank-line-action is "break"  -- This is Dennis' theory.
  ;; Augmenting the theory because I forgot about CRBreak.
  (when (or (member (send environment :blank-line-action)
		    '(paragraph-break break-and-hinge))
	    (eq (send environment :carriage-return-action)
		'paragraph-break))
    ;; only need to splice in the pseudo-paragraph-break
    ;; if the environment understands the concept of paragraphs.
    ;; This means BLANKLINES BREAK or BLANKLINES HINGEBREAK
    ;; need to refine this heuristic a little.
    ;; Only need to splice in if the environment understands paragraphs
    ;; and 1changes0 the LEFT-MARGIN or the INDENT.
    ;; Consider GROUP inside ENUMERATE.
    (let ((superior (send environment :superior)))
      (or (null superior)
	  (send environment :attached-counter)
	  ( (send environment :left-margin)
	     (send superior :left-margin))
	  ( (send environment :indention)
	     (send superior :indention))))))


(defmethod 2(:canonicalize-paragraph-breaks envr-entry-gbox)0 ()
  (when (send environment :break-on-entry)
    (when (environment-specially-hacks-paragraphs environment)
      (let ((next-text (gbox-next-text self)))
	(unless (or (null next-text) (send next-text :paragraph-break?))
	  (let ((box
		  (make-pseudo-paragraph-break-gbox
		    environment (send environment :paragraph-breaks))))
	    (splice-boxes-after self box))))))
  )


(defmethod 2(:canonicalize-paragraph-breaks pseudo-paragraph-break-gbox)0 ()
  (let ((prev-text (gbox-prev-text self)))
    (when (and prev-text (send prev-text :paragraph-break?))
      ;; if the previous text is a paragraph break and has the same counter as
      ;; we do, then we must be for cursor-motion only
      (let* ((prev-text-envr (send prev-text :environment))
	     (prev-text-envr-counter (send prev-text-envr :find-attached-counter)))
	(when (and prev-text-envr-counter
		   (eq prev-text-envr-counter (send environment :find-attached-counter)))
	  (setq for-cursor-motion-only t))))))

;;; Support for making the @UnindentParagraph command work.
(defmethod 2(:unindent-paragraphs basic-gbox :default)0 (unindent?)
  unindent?)

(defmethod 2(:unindent-paragraphs paragraph-break-gbox)0 (unindent?)
  (when unindent?
    (unless (environment-specially-hacks-paragraphs environment)
      (setq indented nil)))
  nil)

(defmethod 2(:unindent-paragraphs pseudo-paragraph-break-gbox)0 (unindent?)
  (ignore unindent?)
  nil)

(defmethod 2(:unindent-paragraphs command-gbox)0 (unindent?)
  (command-gbox-unindent-paragraphs self unindent?))

(define-command-gbox-generic 2command-gbox-unindent-paragraphs0 (unindent?)
  unindent?)

(define-command-gbox-method 2(command-gbox-unindent-paragraphs UnindentParagraph)0 (ignore)
  t)

(defmethod 2(:annotate-for-box-support basic-gbox :default)0 () ())
(defmethod 2(:annotate-for-box-support envr-entry-gbox)0 ()
  (when (send environment :box-type)
    (let ((box-entry-gbox (make-box-support-gbox environment 'first))
	  (box-exit-gbox (make-box-support-gbox environment 'last)))
      (setf (box-support-gbox-other-end box-entry-gbox) box-exit-gbox
	    (box-support-gbox-other-end box-exit-gbox) box-entry-gbox)
      (splice-boxes-after self box-entry-gbox)
      (splice-box-before exit-gbox box-exit-gbox))))

;;2:flush-extra-newline0 is send only from 2(paragraph-break-gbox :canonicalize-paragraph-breaks)
0;;and only to those flavors that claim 2:ends-with-newline?
0(defmethod 2(:flush-extra-newline0 2newline-gbox)0 ()
  (unless (send self :hard-newline)
    (splice-box-out self)))
(defmethod 2(:flush-extra-newline0 2paragraph-break-gbox)0 ()
  (splice-box-out self))
(defmethod 2(:flush-extra-newline0 2command-gbox)0 ()
  ())
(defmethod 2(:flush-extra-newline0 2unexpanded-reference-gbox)0 ()
  ())

;; 2shuffle-environment-breaks0 makes sure, for example, the paragraph- or line-break which
;; satisfies a break-on-entry environment actually is outside that environment.
;; When two adjacent environments fight over a break, I'm not sure that it matters 
;; which gets it.

(defun 2shuffle-environment-breaks0 (gbox)
  (do-box-successors (gbox gbox)
    (send gbox :shuffle-environment-breaks)))

(defun 2shuffle-entry-gbox-internal0 (entry-gbox &optional clobber-environments)
  (let ((environment (send entry-gbox :environment)))
    (when (eq (send environment :fill-mode) 'fill)
      (let ((next-text (gbox-next-text entry-gbox)))
	(when (and next-text
		   (send next-text :newline?)
		   (not (send next-text :hard-newline))	;don't move hard-newlines
		   ;; Don't move unexpanded-references
		   (not (send-if-handles next-text :unexpanded-reference-gbox?))
		   (eq (send next-text :environment) environment))
	  (when (loop for gbox = (box-next entry-gbox) then (box-next gbox)
		      do (cond ((null gbox) (return ()))
			       ((eq gbox next-text) (return T))
			       ((neq (send gbox :environment) environment)
				(return ()))))
	    (loop with supenv = (send environment :superior)
		  for gbox = (box-next entry-gbox) then (box-next gbox)
		  when clobber-environments do (send gbox :set-environment supenv)
		  until (eq gbox next-text)
		  finally (splice-box-out entry-gbox)
			  (box-set-prev-and-next entry-gbox () ())
			  (splice-boxes-after next-text entry-gbox))))))))
  
(defun 2shuffle-exit-gbox-internal0 (exit-gbox &optional clobber-environments)
  (let ((environment (send exit-gbox :environment)))
    (when (eq (send environment :fill-mode) 'fill)
      ;; only want to shuffle things if the environment allows shuffling
      (let ((prev-text (gbox-prev-text exit-gbox)))
	(when (and prev-text
		   (send prev-text :ends-with-newline?)
		   ;; don't move newlines if they're hard
		   (not (send-if-handles prev-text :hard-newline))
		   ;; Don't move unexpanded-references
		   (not (send-if-handles prev-text :unexpanded-reference-gbox?))
		   (loop for gbox = prev-text then (box-next gbox)
			 until (eq gbox exit-gbox)
			 always (eq (send gbox :environment) environment)))
	  (when clobber-environments
	    (loop with supenv = (send environment :superior)
		  for gbox = prev-text then (box-next gbox)
		  until (eq gbox exit-gbox)
		  do (send gbox :set-environment supenv)))
	  (splice-box-out exit-gbox)
	  (box-set-prev-and-next exit-gbox () ())
	  (splice-box-before prev-text exit-gbox)))))
  )

(defmethod 2(:shuffle-environment-breaks0 2basic-gbox0 2:default)0 ()
  ())

(defmethod 2(:shuffle-environment-breaks0 2envr-entry-gbox)0 ()
  (shuffle-entry-gbox-internal self t))

(defmethod 2(:shuffle-environment-breaks envr-exit-gbox)0 ()
  (shuffle-exit-gbox-internal self t))

(defmethod 2(:shuffle-environment-breaks box-support-gbox)0 ()
  (ecase type
    (first (shuffle-entry-gbox-internal self))
    (last (shuffle-exit-gbox-internal self))))

;;; No need to shuffle record-entry-gboxes because it's reasonable for paragraph
;;; breaks to be 1inside0 them.

(defmethod 2(:shuffle-environment-breaks record-exit-gbox)0 ()
  (shuffle-exit-gbox-internal self))


;;;Splice in text for things like @pageref commands.
;;;---Since we aren't hacking @tag and pages yet, this just turns into
;;;text for the referenced tag.

(defmethod 2(:insert-generated-text0 2basic-gbox0 2:default)0 ()
  ())

(defmethod 2(:insert-generated-text command-gbox)0 ()
  (command-gbox-insert-generated-text self))

(define-command-gbox-generic 2command-gbox-insert-generated-text0 ()
  ())

(define-command-gbox-method 2(command-gbox-insert-generated-text Bar)0 ()
  (splice-contents-list self environment
			(making-sage-directives ()
			  (in-environment (t zone)
			    (sage-command t 'tabclear)
			    (in-environment (t ux)
			      (sage-command t 'collect-right-flushing)))))
  (splice-box-out self))

(define-command-gbox-method 2(command-gbox-insert-generated-text0 2LayeredError)0 ()
  (splice-contents-list
    self environment
    (making-sage-directives ()
      (in-environment (() description leftmargin "+20" indent "-25" below 0)
	(in-environment (() transparent facecode t)
	  (princ error-name))
	(sage-command () 'tab-to-tab-stop)
	(in-environment (() transparent facecode l)
	  (princ lisp-error-flavor)))))
  (splice-box-out self))

(define-command-gbox-method 2(command-gbox-insert-generated-text defline-section)0 ()
  (assert (listp title))
  (let ((command (lisp-dictionary-tab-command topic)))
    (render-section-command self 'defline-section
			    (if command (cons command title) title)
			    :lookup)))

(define-command-gbox-method 2(command-gbox-insert-generated-text DictionaryTabs)0 ()
  ;; The DictionaryTabs command doesn't itself actually generate any text.
  ;; This method, however, must be in sync with the above code for defline-section,
  ;; which looks up the DictionaryTabs style parameter to decide what to emit.
  ;; So this sets that style parameter.  It should probably be fixed to use something
  ;; besides a style parameter, which, after all, will confuse someone into trying
  ;; to set this with @Style(DictionaryTabs=...) instead of @DictionaryTabs(Style=...).
  (let ((style-parameters (lookup-ambient-value 'style-parameters :error-p nil)))
    (pushnew (list 'DictionaryTabs
		   (string-upcase-and-intern style *sage-package*))
	     style-parameters
	     :replace T :key #'first)
    (set-ambient-value 'style-parameters style-parameters 'style-parameters)))

(define-command-gbox-method 2(command-gbox-insert-generated-text DynamicText)0 ()
  (splice-contents-list self environment
			(making-sage-directives ()
			  (funcall function)))
  (splice-box-out self))

(defun 2replace-splice-contents-between-strings0 (environment predecessor before contents after)
  (flet ((spl (pred string)
	   (unless (zerop (length string))
	     (splice-boxes-after pred (make-string-gbox environment string
							0 (string-length string))))))
    (let ((original predecessor))
      (setq predecessor (spl original before)
	    predecessor (splice-contents-list predecessor environment contents)
	    predecessor (spl predecessor after))
      (splice-box-out original)
      predecessor)))

(defun 2splice-footnote-generated-text0 (gbox)
  (let* ((counter (note-ambient-counter-touch 'FootnoteCounter 'use))
	 (cloned-counter (clone-counter-and-lineage counter))
	 (counter-gbox (make-counter-command-gbox gbox)))
    (let ((contents-list
	    (making-sage-directives ()
	      (in-environment (() +)		;--- This should be in the counter template
		(sage-command () 'counter-value-as-number (list cloned-counter))))))
      (setf (counter-command-gbox-cloned-counter counter-gbox) cloned-counter)
      (splice-contents-list gbox (send gbox :environment) contents-list)
      (splice-box-before gbox counter-gbox)
      (splice-box-out gbox))))
      
;;; Handling footnotes.
(define-command-gbox-method 2(command-gbox-insert-generated-text foot)0 ()
  (let* ((param-list (copy-list (first parameter)))
	 (first-ele (first param-list)))
    (when (stringp first-ele)
      (setf (car param-list) (string-left-trim *white-space* first-ele)))
    (let* ((last-cons (last param-list))
	   (last-ele (first last-cons)))
      (when (stringp last-ele)
	(setf (car last-cons) (string-right-trim *white-space* last-ele)))
      (cond (*root-document*
	     ;; if we're formatting pages
	     ;; splice in the box for the footnote counter
	     ;; and leave the footnote here in the line for later reference.
	     (setf (first parameter) param-list)
	     (splice-footnote-generated-text self)
	     )
	    (t
	     ;; otherwise just put the footnote in line (in parens)
	     (replace-splice-contents-between-strings
	       environment self "(" param-list ")"))))))

(define-command-gbox-method 2(command-gbox-insert-generated-text note)0 ()
  ;;---Kludge the footnote in line (in parens), since we don't do pages yet.
  (let* ((param-list (copy-list (first parameter)))
	 (first-ele (first param-list)))
    (when (stringp first-ele)
      (setf (car param-list) (string-left-trim *white-space* first-ele)))
    (let* ((last-cons (last param-list))
	   (last-ele (first last-cons)))
      (when (stringp last-ele)
	(setf (car last-cons) (string-right-trim *white-space* last-ele)))
      (replace-splice-contents-between-strings
	environment self "(" param-list ")"))))

;; Methods for 2majorpart0 2chapter0 2section0 2appendixsection0 2subsection0 2subsubsection
0;; have been moved to counter.lisp

(define-command-gbox-method 2(command-gbox-insert-generated-text blocklabel)0 ()
  (send (make-sage-envr 'text '((FACECODE B)) (first parameter))
	:splice-gbox-self
	self environment)
  (splice-box-out self))

(define-command-gbox-method 2(command-gbox-insert-generated-text (rfstr rmstr))0 ()
  (let ((text (first parameter)))		;aaugh!
    (let ((this-end (make-rfstr-support-gbox environment command-name))
	  (other-end (make-rfstr-support-gbox environment 'other-end)))
      (setf (rfstr-support-gbox-other-end this-end) other-end)
      (setf (rfstr-support-gbox-other-end other-end) this-end)
      (let ((predecessor self))
	(setq predecessor (splice-boxes-after predecessor this-end))
	(setq predecessor (splice-contents-list predecessor environment text))
	(setq predecessor (splice-boxes-after predecessor other-end)))
      (splice-box-out self))))

(define-command-gbox-method 2(command-gbox-insert-generated-text
			      (replicate-pattern replicate-pattern-aligned))
0			    ()
  ;; Scarf up everything following up to "the next command", and save it away.
  ;; We'll take this to mean up to the next non-text thing.
  ;; By "scarf up" we mean to splice out the gboxes which constitute "everything".
  (let ((last-to-remove
	  (do-box-successors (box next)
	    (unless (gbox-taken-as-replicated-pattern box)
	      (return (box-prev box))))))
    (cond ((eq last-to-remove self)
	   ;; Nothing follows, nothing to do, remove this
	   (splice-box-out self))
	  (T (let ((new-next (box-next last-to-remove))
		   (first-to-remove next))
	       (setq next new-next)
	       (setf (box-prev new-next) self)
	       (setf (box-prev first-to-remove) nil)
	       (setf (box-next last-to-remove) nil)
	       ;; ---I wonder whether this can slip past later phases.
	       ;; The alternative is to turn this into another kind of command gbox,
	       ;; sort of like where counter-command-gboxes come from.
	       (setq parameter first-to-remove))))))

(defgeneric 2gbox-taken-as-replicated-pattern0 (basic-gbox)
  (:method (basic-gbox :default) ())
  (:method (string-gbox) T))

;;; Get rid of PAGE characters.
(defmethod 2(:strip-page-characters0 2basic-gbox0 2:default)0 ()
  ())

(defmethod 2(:strip-page-characters0 2string-gbox)0 ()
  (loop for ch-loc = (string-search-char #\page string :start start-index :end end-index)
	do (cond ((null ch-loc)
		  (when ( start-index end-index)
		    (splice-box-out self))
		  (return (values)))
		 (( ch-loc start-index)
		  (incf start-index))
		 (( ch-loc (1- end-index))
		  (decf end-index)
		  (return (values)))
		 (t (let ((new (make-string-gbox environment string start-index ch-loc)))
		      (splice-box-before self new)
		      (setq start-index (1+ ch-loc)))))))

;;;Splice in text from counters.
;;;Whenever a paragraph begins within a numbered environment, put in the counter text.
;;;Skip over any limited paragraph breaks.
(defun 2insert-counter-numbers0 (gbox)
  (do-box-successors (gbox gbox)
    (send gbox :insert-counter-numbers)))

(defmethod2 (:insert-counter-numbers0 2basic-gbox0 2:default)0 ()
  )

(defmethod 2(:insert-counter-numbers0 2paragraph-break-gbox)0 ()
  (ecase break-type
    (limited ())				; do nothing
    (normal
      (insert-counter-numbers-internal self environment))
    ))

(defmethod 2(:insert-counter-numbers pseudo-paragraph-break-gbox)0 ()
  (unless for-cursor-motion-only
    (ecase break-type
      (limited ())
      (normal
	(insert-counter-numbers-internal self environment)))))

(defun 2insert-counter-numbers-internal0 (gbox environment)
  (let ((counter (send environment :find-attached-counter)))
    (when counter
      (let ((next-text (gbox-next-text gbox)))
	(when (and next-text
		   (env-inside (send next-text :environment) environment))
	  (note-counter-touch counter 'use)
	  (splice-boxes-after
	    (send counter :counter-number-gbox gbox environment)
	    ;;---This needs to hack number-location
	    (make-command-gbox environment 'tab-to-tab-stop)))))))

(defmethod2 (:counter-reference-gbox0 2counter)0 (predecessor envr)
  (splice-contents-list predecessor envr
			(counter-value-contents-list self :reference)))
		       
(defmethod2 (:counter-number-gbox0 2counter)0 (predecessor envr)
  (splice-contents-list predecessor envr
			(counter-value-contents-list
			  self :number
			  (send envr :counter-environment))))

#+Ignore
(4 0 (NIL 0) (NIL NIL :SMALL) "TVFONT")(defmethod(5 0 (NIL 0) (NIL :BOLD :SMALL) "TVFONTCB") (:counter-value-gbox4 5counter)4 (template predecessor envr)
  (using-resource (str string-temp)
    (let ((element (nth (mod nesting-depth (length template)) template)))
      (flet ((flush (old-gbox envr)
	       (let ((n (string-length str)))
		 (if (zerop n)
		     old-gbox
		     (let ((gbox (make-string-gbox envr (copy-string str) 0 n)))
		       (setf (fill-pointer str) 0)
		       (splice-boxes-after old-gbox gbox)
		       gbox)))))
	(loop with first
	      for code in element
	      do (if (consp code)
		     (cond ((and (characterp (setq first (first code)))
				 (char-equal first #\;))
			    (when (null parent-counter)
			      (vector-push-extend (second code) str)))
			   ((and (characterp first)
				 (char-equal first #\:))
			    (when parent-counter
			      (vector-push-extend (second code) str)))
			   (t			;code had better be a contents list
			    (setq predecessor (flush predecessor envr))
			    (setq predecessor
				  (splice-contents-list predecessor envr code))))
		     (selector (make-char code) char=
		       (#\1 (format str "~d" value))
		       ((#\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
			(format str "~v,'0d" (- (char-code code)
						(char-code #\0))))
		       (#\' (format str "~d~a"
				    value
				    (selector (mod value 10.) =
				      (1 "st")
				      (2 "nd")
				      (3 "rd")
				      (otherwise "th"))))
		       (#\A
			(setf (char-code code) (+ (char-code #\A) (mod (1- value) 26.)))
			(vector-push-extend code str))
		       (#\a
			(setf (char-code code) (+ (char-code #\a) (mod (1- value) 26.)))
			(vector-push-extend code str))
		       (#\I (format str "~@R" value))
		       (#\i (format str "~(~@r~)" value))
		       (#\o (format str "~R" value))
		       (#\O (format str "~:(~r~)" value))
		       (#\f (format str "~:R" value))
		       (#\F (format str "~:(~:r~)" value))
		       (#\* (format str "~v,,,'*<~>" (min value 12.)))
		       (#\# (when parent-counter
			      (setq predecessor
				    (send parent-counter :counter-reference-gbox
					  (flush predecessor envr) envr))))
		       (otherwise (vector-push-extend code str)))))
	(flush predecessor envr)))))

0(defmethod 2(counter-value-contents-list counter)0 (reference-or-number
						   &optional envr-to-splice)
  (counter-value-contents-list1
    (ecase reference-or-number
      (:reference template-as-reference)
      (:number template-as-number))
    value parent-counter nesting-depth envr-to-splice))

(defun 2counter-value-contents-list10 (template value parent-counter nesting-depth
				     envr-to-splice)
  (and template
       (making-sage-directives ()
	 (when envr-to-splice (setq envr-to-splice (ncons envr-to-splice)))
	 (in-environment1-if envr-to-splice (t envr-to-splice)
	   (let ((element (nth (mod nesting-depth (length template)) template)))
	     (loop with first
		   for code in element
		   do (if (consp code)
			  (cond ((and (characterp (setq first (first code)))
				      (char-equal first #\;))
				 (when (null parent-counter)
				   (write-char (second code))))
				((and (characterp first)
				      (char-equal first #\:))
				 (when parent-counter
				   (write-char (second code))))
				(t		;code had better be a contents list
				 (sage-contents-list T code)))
			  (selector (make-char code) char=
			    (#\1 (format T "~d" value))
			    ((#\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
			     (format T "~v,'0d" (- (char-code code)
						   (char-code #\0))))
			    (#\' (format T "~d~a"
					 value
					 (selector (mod value 10.) =
					   (1 "st")
					   (2 "nd")
					   (3 "rd")
					   (otherwise "th"))))
			    (#\A
			     (setf (char-code code) (+ (char-code #\A) (mod (1- value) 26.)))
			     (write-char code))
			    (#\a
			     (setf (char-code code) (+ (char-code #\a) (mod (1- value) 26.)))
			     (write-char code))
			    ((#\B #\b)
			     ;; A B C...Z AA AB AC .. AZ BA BB .. ZZ
			     (let ((lowest (char-code (if (upper-case-p (make-char code))
							  #\A #\a))))
			       (labels ((do26 (n)
					  (when (> n 0)
					    (multiple-value-bind (quo rem) (floor (1- n) 26)
					      (do26 quo)
					      (write-char (code-char (+ lowest rem)))))))
				 (do26 value))))
			    (#\I (format T "~@R" value))
			    (#\i (format T "~(~@r~)" value))
			    (#\o (format T "~R" value))
			    (#\O (format T "~:(~r~)" value))
			    (#\f (format T "~:R" value))
			    (#\F (format T "~:(~:r~)" value))
			    (#\* (format T "~v,,,'*<~>" (min value 12.)))
			    (#\# (when parent-counter
				   (sage-contents-list
				     T
				     (counter-value-contents-list parent-counter :reference))))
			    (otherwise (write-char code))))))))))
  
(defmethod 2(:transform-characters0 2basic-gbox0 2:default)0 () ())
(defmethod 2(:transform-characters0 2string-gbox)0 ()
  (ecase (send environment :transformation)
    (1none
0      ())
    (1capitalized
0      (splice-replace-box
	self (make-string-gbox environment
			       (string-upcase (substring string start-index end-index))
			       0 (- end-index start-index))))
    (1initial-capitalized
0      (splice-replace-box
	self (make-string-gbox environment
			       (string-initial-upcase
				 (substring string start-index end-index))
			       0 (- end-index start-index))))))

(defmethod2 (:canonicalize-leading-spaces0 2basic-gbox0 2:default)0 () ())
(defmethod2 (:canonicalize-leading-spaces0 2string-gbox)0 ()
  (let ((leading-space-action (send environment :leading-space-action)))
    (ecase leading-space-action
      (1discarded
0	(let ((prev-text (gbox-prev-text self)))
	  (when (or (null prev-text) (send prev-text :ends-with-newline?))
	    (loop while (and (< start-index end-index)
			     (char-white-space-p (aref string start-index)))
		  do (incf start-index)))))
      (1retained-significant
0	;;If a space or tab character are found,
	;;replace with a literal-space command or tab-character-gbox, repectively.
	(let ((prev-text (gbox-prev-text self)))
	  (when (or (null prev-text) (send prev-text :ends-with-newline?))
	    (loop while (< start-index end-index)
		  for char = (aref string start-index)
		  while (member char '(#\space #\tab) :test #'char-equal)
		  do (splice-box-before
		       self
		       (if (char-equal char #\tab)
			   (make-tab-character-gbox environment)
			   (make-command-gbox environment 'literal-space)))
		  do (incf start-index)
		  finally (when ( start-index end-index)
			    (splice-box-out self))))))
      (1retained
0	;;Do nothing.
	)
      ((1compressed normalized0)
       ;;---Normalized means compress to a single space even after a period.
       (let ((prev-text (gbox-prev-text self)))
	 (when (or (null prev-text) (send prev-text :ends-with-newline?))
	   (loop while (and (< (1+ start-index) end-index)
			    (char-equal (aref string start-index) #\space)
			    (char-equal (aref string (1+ start-index)) #\space))
		 do (incf start-index))))))))

(defmethod2 (:canonicalize-spaces0 2basic-gbox0 2:default)0 () ())
(defmethod2 (:canonicalize-spaces0 2newline-gbox)0 ()
  (unless (variable-boundp hard-newline)
    (setq hard-newline ()))
  (ecase (send environment :fill-mode)
    (fill
      (unless hard-newline
	(when (eq (send environment :carriage-return-action) 'spaces)
	  (let ((prev-text (gbox-prev-text self)))
	    (if (and prev-text
		     (or (send prev-text :ends-with-space?)
			 (send prev-text :tab-terminating-tab-gbox?)))
		(splice-box-out self)
		(splice-replace-box self (make-space-gbox environment)))))))
    ((centered flushleft flushright)
     )))

(defmethod2 (:canonicalize-spaces0 2space-gbox)0 ()
  (let ((space-action (send environment :space-action)))
    (ecase space-action
      ((1normalized compressed0)
       ;;---Compressed is supposed to compress to two spaces after sentence-ending
       ;;punctuation.  Two spaces is correct only for fixed-width output, so we
       ;;consider these cases to be the same.
       (let ((prev-text (gbox-prev-text self)))
	 (when (and prev-text (send prev-text :ends-with-space?))
	   (splice-box-out self))))
      (1retained
0	;;Do nothing
	)
      (1retained-significant
0	;;Make the space into a literal-space command
	(splice-replace-box self (make-command-gbox environment 'literal-space)))
      ((1discarded0) (splice-box-out self))
      )))

(defmethod 2(:canonicalize-spaces0 2command-gbox)0 ()
  (case command-name
    (ignore-white-space
     (loop for next-text-gbox = next then (box-next next-text-gbox)
	   while next-text-gbox
	   do (send next-text-gbox :strip-leading-whitespace)
	   until (send next-text-gbox :starts-with-printing-char?))
     (splice-box-out self))
    (otherwise ())))

(defun-in-flavor (2string-gbox-canonicalize-spaces-retained0 string-gbox) ()
  ;;Just replace tab characters in the string with tab-character-gboxes.
  (let ((tab-loc (string-search-char #\tab string :start start-index :end end-index)))
    (when tab-loc
      (let ((after-tab-loc (string-search-not-char #\tab string
						   :start (1+ tab-loc) :end end-index)))
	(when after-tab-loc
	  (splice-boxes-after self (make-string-gbox environment string
						     after-tab-loc end-index)))
	(splice-box-list-after
	  self
	  (loop repeat (- (or after-tab-loc end-index) tab-loc)
		collect (make-tab-character-gbox environment))))
      (setq end-index tab-loc)
      (when ( start-index end-index)
	(splice-box-out self)))))

(defconstant 2*string-space-set*0 '#.(coerce '(#\space #\tab) 'string))

(defun-in-flavor (2string-gbox-canonicalize-spaces-retained-significant0 string-gbox) ()
  ;;If a space or tab character is found,
  ;;replace with a literal-space command or tab-character-gbox, respectively.
  (let* ((space-loc (string-search-set *string-space-set* string
				       :start start-index :end end-index)))
    (when space-loc
      (let ((after-space-loc (string-search-not-set *string-space-set* string
						    :start (1+ space-loc) :end end-index)))
	(when after-space-loc
	  (splice-boxes-after self (make-string-gbox environment string
						     after-space-loc end-index)))
	(splice-box-list-after
	  self
	  (loop repeat (- (or after-space-loc end-index) space-loc)
		collect (if (char-equal (aref string space-loc) #\tab)
			    (make-tab-character-gbox environment)
			    (make-command-gbox environment 'literal-space)))))
      (setq end-index space-loc)
      (when ( start-index end-index)
	(splice-box-out self)))))

(defun-in-flavor (2string-gbox-canonicalize-spaces-compressed0 string-gbox) ()
  ;;If the previous text ends with a space, get rid of leading spaces here.
  (let ((prev-text (gbox-prev-text self)))
    (when (and prev-text (send prev-text :ends-with-space?))
      (loop while (and (< start-index end-index)
		       (char-equal (aref string start-index) #\space))
	    do (incf start-index))))
  ;;Loop over all spaces in this string.  If there are any noncanonical spaces (more
  ;;than one, or a tab), split this string into the prefix, a space-gbox, and the suffix.
  (loop for start = start-index then (1+ space-loc)
	for space-loc = (string-search-set *string-space-set* string
					   :start start :end end-index)
	while space-loc
	for after-space-loc =
	    (string-search-not-set *string-space-set* string
				   :start (1+ space-loc) :end end-index)
	do (cond ((null after-space-loc)	;nothing left but space(s)
		  (when (or (> end-index (1+ space-loc))	;more than one space
			    (not (char-equal (aref string space-loc) #\space)))	;or not space
		    (setq end-index space-loc))
		  (splice-boxes-after self (make-space-gbox environment))
		  (loop-finish))
		 ((or (> after-space-loc (1+ space-loc))	;more than one
		      (not (char-equal (aref string space-loc) #\space)))	;or not space
		  (splice-boxes-after self
				      (make-space-gbox environment)
				      (make-string-gbox environment string
							after-space-loc end-index))
		  (setq end-index space-loc)
		  (loop-finish))
		 (T )))
  (when ( start-index end-index)
    (splice-box-out self)))

(defmethod2 (:canonicalize-spaces0 2string-gbox)0 ()
  (let ((space-action (send environment :space-action)))
    (ecase space-action
      (1retained0					;1"spaces kept"
0	(string-gbox-canonicalize-spaces-retained))
      (1retained-significant0			;1"spaces nobreak"
0	(string-gbox-canonicalize-spaces-retained-significant))
      ((1compressed0 1normalized0)			;1"spaces compact"0, 1"spaces normalize"
0       ;;---Compressed is supposed to compress to two spaces after sentence-ending
       ;;punctuation.  Two spaces is correct only for fixed-width output, so we
       ;;consider these cases to be the same.  space-gbox canonicalization does it too.
       (string-gbox-canonicalize-spaces-compressed))
      ((1discarded0)				;1"spaces ignored"
0       ;;If any spaces are found, split this string into the prefix and the suffix.
       (let ((space-loc (string-search-set *string-space-set* string
					   :start start-index :end end-index)))
	 (when space-loc
	   (let ((after-space-loc (string-search-not-set *string-space-set* string
							 :start (1+ space-loc) :end end-index)))
	     (when after-space-loc
	       (splice-boxes-after self (make-string-gbox environment string
							   after-space-loc end-index))))
	   (setq end-index space-loc)
	   (when ( start-index end-index)
	     (splice-box-out self))))))))

(defmethod 2(:strip-leading-whitespace0 2basic-gbox)0 () ())

(defmethod 2(:strip-leading-whitespace0 2string-gbox)0 ()
  (let ((nonspace-loc (string-search-not-set *white-space* string :start start-index :end end-index)))
    (if (null nonspace-loc)
	(splice-box-out self)
	(setq start-index nonspace-loc))))

(defmethod 2(:strip-leading-whitespace0 2space-gbox)0 ()
  (splice-box-out self))
(defmethod 2(:strip-leading-whitespace0 2newline-gbox)0 ()
  (splice-box-out self))

(defun2 width-annotate-gboxes0 (gbox)
  (let ((font ()))
    (do-box-successors (gbox gbox)
      (when (null font) (setq font (send gbox :validate-font-number)))
      (setq font (send gbox :width-annotate font)))))

;;2:width-annotate0 -- each gbox remembers its width in microns.
;; Save a little time here by using the envr-switch markers and
;;encacheing the font: each method returns the current font, except
;;envr-exit which returns NIL.  Each method also accepts NIL which
;;means the font has to be looked up from the environment.

(defmethod2 (:width-annotate0 2basic-gbox0 2:default)0 (font)
  font)

(defmethod2 (:width-annotate0 2space-gbox)0 (font)
  (when (null font) (setq font (gbox-font-from-environment environment)))
  (setq width (micron-width-of-char font #\space))
  font)
    
(defmethod 2(:width-annotate picture-gbox)0 (font)
  (cached-width-and-height self)
  font)

(defmethod2 (:width-annotate0 2string-gbox)0 (font)
  (when (null font) (setq font (gbox-font-from-environment environment)))
  (setq width (micron-width-of-string font string start-index end-index))
  font)

(defmethod2 (:width-annotate0 2envr-entry-gbox)0 (ignore)
  (send self :validate-font-number))

(defmethod2 (:width-annotate0 2envr-exit-gbox)0 (ignore)
  ())

    ;;When you add or delete clauses here, remember to update the corresponding ones
    ;;in (simple-command-gbox :display-gbox)
(defmethod 2(:width-annotate0 2command-gbox)0 (font)
  (when (null font) (setq font (gbox-font-from-environment environment)))
  (command-gbox-width-annotate self font)
  font)

(define-command-gbox-generic 2command-gbox-width-annotate0 (font)
  (unless (command-known-not-to-display command-name)
    (setq width (micron-width-of-command-name-display font command-name))))

(define-command-gbox-method 2(command-gbox-width-annotate hsp)0 (font)
  (ignore font)
  (setq width (coerce-to-distance distance :horizontal 0)))

(define-command-gbox-method 2(command-gbox-width-annotate cb)0 (font)
  (ignore font)
  ())					;---To remind us to do this


(define-command-gbox-method 2(command-gbox-width-annotate
			      (collect-centering collect-right-flushing tab-to-tab-stop))
0			    (font)
  (ignore font)) ;;Taken care of otherwise

(define-command-gbox-method 2(command-gbox-width-annotate em)0 (font)
  ;; The following comment appears to be obsolete, so I'm making it work
  ;; correctly.  --rom 1-19-86
  ;;---This can't be done right right now, because we don't have the device available.
  ;;So, make it be the same as "m" in the current font, hoping it won't look too funny.
; (setq width (micron-width-of-char font #\m)))
  (ignore font)
  (multiple-value-bind (char fnt)
      (pi-char-code-and-font 'em-dash)
    (setq width (micron-width-of-char fnt char))))

(define-command-gbox-method 2(command-gbox-width-annotate
			      (literal-space missing-special-character))
0			    (font)
  (setq width (micron-width-of-char font #\space)))

(defun 2micron-width-of-command-name-display0 (font command-name)
  (if *debugging-sage*
      (+ (micron-width-of-char font #\@)
	 (micron-width-of-string font (string command-name)))
      0))

(defun 2command-known-not-to-display0 (command-name)
  (not (zerop (dd-command-undisplayed? (lookup-command-descriptor command-name)))))

(defun2 micron-width-of-string0 (font string &optional (start-index 0) end-index)
  (send *current-sage-device* :width-of-string-in-font font string start-index end-index))

(defun 2micron-width-of-char0 (font char)
  (send *current-sage-device* :width-of-char-in-font char font))

(defun 2micron-height-of-font0 (font)
  (declare (values font-height baseline))
  (send *current-sage-device* :height-of-font font))

(defun 2make-toplevel-environment 0()
  (let ((envr-list
	  (let ((device-type (send *current-sage-device* :output-device-type)))
	    (or (assoc device-type *toplevel-environment-alist*)
		(let ((top-envr (take-environment-from-cache)))
		  (send top-envr :init-toplevel)
		  ;;--- Move some more declarative stuff into database.lisp
		  (multiple-value-bind (toplevel-mods next-level-definition)
		      (get-toplevel-mods-and-next-level-definition device-type)
		    (loop for (attr val) in toplevel-mods
			  do (send top-envr :set-attribute attr val))
		    (setf (symbol-value-in-instance top-envr 'line-width)
			  (- (send top-envr :paper-width)
			     (send top-envr :left-margin)
			     (send top-envr :right-margin)))
		    (let* ((envr (make-environment-inferior-to
				   top-envr
				   (first next-level-definition)
				   (rest next-level-definition)))
			   (inner-envr (make-environment-inferior-to
					 envr
					 (send envr :envr-name)
					 ()))
			   (envr-list (list device-type inner-envr envr top-envr)))
		      (push envr-list *toplevel-environment-alist*)
		      envr-list)))))))
    (destructuring-bind (nil envr superior &rest ignore) envr-list
      (setup-inheritance superior envr 'transparent ())
      (send envr :set-envr-name (send superior :envr-name))
      envr)))

(defun2 make-environment-inferior-to0 (superior-environment envr-name envr-mods)
  (let ((new-env (take-environment-from-cache)))
    (when (eq new-env superior-environment)
      (error "You got an environment already allocated, ~s (internal error)" new-env))
    (setup-inheritance superior-environment new-env envr-name envr-mods)
    new-env))

(defun 2take-environment-from-cache0 ()
  (incf *environments-taken-from-cache*)
  (let ((e (or (without-interrupts
		 (and *environment-cache*
		      (send *environment-cache* :take-self-from-cache)))
	       (make-instance 'environment))))
    ;;(location-makunbound (locate-in-instance e 'face-code) 'face-code) ;---debugging only
    e))

(defmethod 2(:take-self-from-cache0 2environment)0 ()
  ;;Must be called without-interrupts
  (unless (eq envr-name :in-cache) (zl:fsignal "Weird ~s" self))
  (setq *environment-cache* superior
	superior ()
	envr-name ()
	attached-counter ())
  self)

(defun 2return-environment-to-cache0 (environment)
  (progn
    (incf *environments-returned-to-cache*)
    (send environment :return-self-to-cache)))
	
(defmethod 2(:return-self-to-cache0 2environment)0 ()
  (setq attached-counter ()
	envr-name :in-cache)
  (without-interrupts
    (setq superior *environment-cache*
	  *environment-cache* self)))

(defflavor 2tiny-environment0 (character-style indention left-margin)
	   ()
  :settable-instance-variables
  (:constructor 2make-tiny-environment0 (character-style indention left-margin))
  (:default-init-plist :area *sage-formatter-area*))

(defgeneric 2tiny-environment?0 (environment)
  (:method (environment)
   nil)
  (:method (tiny-environment)
   T))

(defmethod 2(character-style-from-environment tiny-environment)0 (device)
  (ignore device)
  character-style)

(defmethod 2(:script-displacement0 2tiny-environment0 2:default)0 () 0)
(defmethod 2(:fill-mode0 2tiny-environment0 2:default)0 () ())

(defflavor 2tiny-script-environment0 (script-displacement)
	   (tiny-environment)
  :settable-instance-variables
  (:constructor 2make-tiny-script-environment
0		(character-style indention left-margin script-displacement))
  (:default-init-plist :area *sage-formatter-area*))

(defflavor 2tiny-fill-mode-environment0 (fill-mode line-width)
	   (tiny-environment)
  :settable-instance-variables
  (:constructor 2make-tiny-fill-mode-environment
0		(character-style indention left-margin fill-mode line-width))
  (:default-init-plist :area *sage-formatter-area*))

(defflavor 2tiny-box-environment0 (box-type box-left-margin box-top-margin
					  box-right-margin box-bottom-margin)
	   (tiny-environment)
  :settable-instance-variables
  (:constructor 2make-tiny-box-environment0 (character-style indention left-margin
							   box-type box-left-margin
							   box-top-margin box-right-margin
							   box-bottom-margin))
  (:default-init-plist :area *sage-formatter-area*))

(defmethod 2(:tiny-environment0 2environment)0 ()
  (let (tiny-kind)
    (flet ((alter-kind (new-kind) (setq tiny-kind (if tiny-kind 'loser new-kind))))
      (when (not (eql script-displacement 0))
	(alter-kind 'script))
      (ecase fill-mode
	((fill) )
	((centered flushright flushleft) (alter-kind 'fill)))
      (when box-type (alter-kind 'box))
      )
    (let ((character-style (character-style-from-environment self *current-sage-device*)))
      (ecase tiny-kind
	((nil) (make-tiny-environment character-style indention left-margin))
	(script (make-tiny-script-environment character-style indention left-margin
					      script-displacement))
	(fill (make-tiny-fill-mode-environment character-style indention left-margin
					       fill-mode line-width))
	(box (make-tiny-box-environment character-style indention left-margin
					box-type box-left-margin box-top-margin
					box-right-margin box-bottom-margin))
	(loser ())))))

(defmethod 2(:make-environments-tiny0 2fake-line-hbox)0 () ())
(defmethod 2(:make-environments-tiny0 2line-hbox)0 ()
  (do-line-gboxes-exclusive (gbox first-gbox newline-gbox)
    (send gbox :make-environments-tiny)))

(defmethod 2(:make-environments-tiny0 2basic-gbox0 2:default)0 () ())
(defmethod 2(:make-environments-tiny0 2envr-exit-gbox)0 ()
  (let ((env environment)
	(tiny (send environment :tiny-environment)))
    (when tiny
      (send entry-gbox :set-environment tiny)
      (setq environment tiny)
      (loop for gbox = (box-next entry-gbox) then do-next
	    until (eq gbox self)
	    for do-next = (send gbox :make-environment-tiny env tiny))
      (return-environment-to-cache env))))

;;Most just need to check and set.
(defmethod 2(:make-environment-tiny0 2basic-gbox0 2:default)0 (should-be tiny)
  (unless (eq should-be environment)
    (zl:fsignal "Making wrong environment tiny.  Should be ~s, have ~s (internal error)"
	     should-be environment))
  (setq environment tiny)
  next)

;;Skip over inner environments
(defmethod 2(:make-environment-tiny0 2envr-entry-gbox)0 (ignore ignore)
  (box-next exit-gbox))

(defun2 gbox-font-from-environment0 (environment)
  (ignore environment)
  (send *current-sage-device* :current-font-number))

(defun2 hposition+0 (environment x &rest addends)
  (when (symbolp x)
    (setq x (ecase x
	      (1:start-of-line0 (send environment :left-margin))
1	      (:start-of-paragraph
0		(ecase (send environment :fill-mode)
		  ((fill nil)
		   (let ((left-margin (send environment :left-margin))
			 (indention (send environment :indention)))
		     (+ left-margin indention)))
		  ;; :start-of-paragraph really means :start-of-line
		  ;; for unfilled environments.
		  ((centered flushleft flushright)
		   (send environment :left-margin))))
	      (1:unknown
0	       (zl:fsignal "The current horizontal position is supposed to be unknown,~@
			  yet something is trying to use it. ~c will use left margin."
			#\resume)
	       (send environment :left-margin))
	      )))
  (+ x (reduce #'+ addends)))

;;;This is what converts that macro language above into directives.
;;;---It could offer some error recovery.
(defun 2convert-@-to-directives0 (list &optional return-list-if-asked)
  (declare (values directive-or-list-if-asked it-was-a-list))
  (compiler:matchp list
    (('@ (directive . params) . contents)
     (convert-@-contents-list-to-directives directive params contents return-list-if-asked))
    (('@ directive . contents)
     (convert-@-contents-list-to-directives directive () contents return-list-if-asked))
    ((* . *)
     (zl:fsignal "The list is supposed to start with \"@\" ~s" list))
    (string (typecase string
	      ((or string sage-directive) string)
	      (otherwise
		(zl:fsignal "Non-string atom ~s" string)
		"")))))

(defun 2convert-@-contents-list-to-directives0 (name mods contents return-list-if-asked)
  (sys:flet ((lister ()
	       (declare (sys:downward-function))
	       (loop with (directive it-was-a-list)
		     for x in contents
		     do (multiple-value-setq (directive it-was-a-list)
			  (and x		;conveniently ignore NIL in contents list
			       (convert-@-to-directives x T)))
		     when it-was-a-list
		       append directive
		     else when x
			    collect directive)))
    (if (and (eq name 'list) return-list-if-asked)
	(values (lister) T)
	(let ((directive (lookup-directive-descriptor name 'generic 'generic)))
	  (if (null directive)
	      (zl:fsignal "Undefined directive ~s" name)
	      (ecase (dd-parse-type directive)
		(:environment
		 (make-sage-envr
		   name
		   (loop for x in mods
			 collect (compiler:matchp x
				   ((name val) (list name val))
				   (name (if (symbolp name)
					     (list name)
					     (error "Bad mod spec ~s" x)))))
		   (lister)))
		 (:command
		  (when mods
		    (error "For the command ~s can't hack mods ~s"
			    directive mods))
		  (if (eq (dd-arglist directive) :none)
		      (if contents
			  (error "For the simple command ~s, can't hack contents ~s"
				  directive contents)
			  (make-sage-command (dd-definition directive)))
		      (make-sage-command name contents)))
		 (:reference
		   (when mods
		     (error "Can't hack mods for references"))
		     (let* ((unique-id (second (assoc 'unique-id contents)))
			    (topic (second (assoc 'topic contents)))
			    (type (second (assoc 'type contents)))
			    (view (second (assoc 'view contents)))
			    (field (second (assoc 'field contents)))
			    (record-group (find-record-group-for-topic-and-type
					    topic type unique-id t)))
		       (make-instance 'sage-reference
				      :record-group record-group
				      :view (if (or (null view) (consp view))
						view
						(ncons view))
				      :field (if (or (null field) (consp field))
						 field
						 (ncons field)))))
		 ))))))

(defun2 splice-box-before0 (existing-box new-box)
  (let ((old-prev (box-prev existing-box)))
    (when (null old-prev)
      (error "May not splice in before the very first box in the chain, ~s"
	      existing-box))
    (box-set-prev-and-next new-box old-prev existing-box)
    (setf (box-next old-prev) new-box)
    (setf (box-prev existing-box) new-box)))

(defun2 splice-boxes-after0 (existing-box &rest new-boxes)
  (splice-box-list-after existing-box new-boxes))

(defun2 splice-box-list-after0 (existing-box list-of-new-boxes)
  (let ((old-next (box-next existing-box)))
    (loop for old-box = existing-box then new-box
	  for (new-box . more) on list-of-new-boxes
	  do (progn (setf (box-prev new-box) old-box)
		    (setf (box-next old-box) new-box))
	  when (null more)
	  do (progn (setf (box-next new-box) old-next)
		    (when old-next (setf (box-prev old-next) new-box))
		    (return new-box)))))

(defun 2splice-box-chain-after0 (existing-box first-of-chain)
  (let ((old-next (box-next existing-box))
	(chain-last (loop for box = first-of-chain then box-next
			  for box-next = (box-next box)
			  when (null box-next) return box)))
    (setf (box-next existing-box) first-of-chain)
    (setf (box-prev first-of-chain) existing-box)
    (setf (box-next chain-last) old-next)
    (when old-next (setf (box-prev old-next) chain-last))
    chain-last))

(defun 2splice-box-chain-out0 (first-of-chain last-of-chain)
  (let ((old-previous (box-prev first-of-chain))
	(old-next (box-next last-of-chain)))
    (when (null old-previous)
      (error "May not splice out the very first box in the chain, ~S" first-of-chain))
    (setf (box-next old-previous) old-next)
    (when old-next
      (setf (box-prev old-next) old-previous))
    (setf (box-prev first-of-chain) nil
	  (box-next last-of-chain) nil)))

(defun 2splice-box-chain-after-box-chain0 (existing-chain-head new-chain-head)
  (flet ((last-of-chain (chain-head)
	   (loop for box = chain-head then box-next
		 for box-next = (box-next box)
		 when (null box-next) return box)))
    (let ((existing-chain-last (last-of-chain existing-chain-head)))
      (setf (box-prev new-chain-head) existing-chain-last)
      (setf (box-next existing-chain-last) new-chain-head))))

(defun2 splice-box-out0 (box)
  (send box :splice-self-out))
(defmethod 2(:splice-self-out0 2doubly-linked-list-mixin)0 ()
  (when (null prev)
    (error "May not splice out the very first box in the chain, ~s" self))
  (setf (box-next prev) next)
  (when next (setf (box-prev next) prev)))

(defun2 splice-replace-box0 (old-box new-box)
  (send old-box :splice-replace-self new-box))

(defmethod 2(:splice-replace-self0 2doubly-linked-list-mixin)0 (new-box)
  (when (null prev)
    (error "May not splice out the very first box in the chain, ~s" self))
  (box-set-prev-and-next new-box prev next)
  (setf (box-next prev) new-box)
  (when next (setf (box-prev next) new-box)))

(defun 2gbox-prev-text0 (gbox)
  (loop for gbox = (box-prev gbox) then (box-prev gbox)
	while gbox
	when (send gbox :text?) return gbox))

(defun 2gbox-next-text0 (gbox)
  (loop for gbox = (box-next gbox) then (box-next gbox)
	while gbox
	when (send gbox :text?) return gbox))

(defmethod 2(:text?0 2doubly-linked-list-head)0 () ())
(defmethod2 (:text?0 2basic-gbox0 2:default)0 () ())
(defmethod2 (:text?0 2string-gbox)0 ()
  (> end-index start-index))
(defmethod2 (:text?0 2space-gbox)0 () T)
(defmethod2 (:text?0 2newline-gbox)0 () T)
(defmethod2 (:text?0 2paragraph-break-gbox)0 () T)
(defmethod2 (:text?0 pseudo-2paragraph-break-gbox)0 () T)
(defmethod2 (:text? command-gbox)0 ()
  (case command-name
    ((cb collect-centering collect-right-flushing em force-line-break literal-space
			missing-special-character replicate-pattern replicate-pattern-aligned
			tab-to-tab-stop)
     T)
    ((dynamic-tab-stop permit-word-break force-end-of-sentence dynamic-left-margin
		       save-absolute-horizontal-position
		       move-to-saved-absolute-horizontal-position
		       ignore-white-space tabclear)
     ())
    ((blankspace caption) T)
    (otherwise
      ;;---This comment existed:
      ;;---Remove this bug, and the one in dd-command-text?, after Rel 6 freeze
     (ecase (dd-command-text? (lookup-command-descriptor command-name))
       ((1 T) T)
       ((0 NIL) NIL)))))

(defmethod 2(:text?0 2unexpanded-reference-gbox)0 ()
  T)

(defmethod 2(:text? picture-gbox)0 ()
  t)

(defmethod 2(:text? box-support-gbox)0 ()
  t)

(defmethod 2(:text? envr-entry-gbox)0 ()
  (when environment
    (when (send environment :box-type)
      t)))

(defmethod 2(:ink? basic-gbox :default)0 (first-gbox-in-line?)
  (ignore first-gbox-in-line?)
  ())

(defmethod 2(:ink? string-gbox)0 (ignore) t)
(defmethod 2(:ink? space-gbox)0 (ignore) t)	;?
(defmethod 2(:ink? paragraph-break-gbox)0 (ignore) nil)	;?
(defmethod 2(:ink? pseudo-paragraph-break-gbox)0 (ignore) nil)
(defmethod 2(:ink? newline-gbox)0 (first-gbox-in-line?) first-gbox-in-line?)
(defmethod 2(:ink? picture-gbox)0 (ignore) t)

(defmethod 2(:ink? command-gbox)0 (ignore)
  (case command-name
    ((em hsp literal-space replicate-pattern replicate-pattern-aligned) t)
    (otherwise nil)))



(defmethod2 (:ends-with-newline?0 2basic-gbox0 2:default)0 () ())
(defmethod2 (:ends-with-newline?0 2newline-gbox)0 () T)
(defmethod2 (:ends-with-newline?0 2paragraph-break-gbox)0 () T)
(defmethod2 (:ends-with-newline?0 2command-gbox)0 ()
  (case command-name
    ((cb collect-centering collect-right-flushing dynamic-left-margin dynamic-tab-stop em
			force-end-of-sentence literal-space missing-special-character
			move-to-saved-absolute-horizontal-position permit-word-break
			replicate-pattern replicate-pattern-aligned
			save-absolute-horizontal-position tab-to-tab-stop tabclear)
     ())
    ((force-line-break) T)
    (otherwise
      (ecase (dd-command-ends-with-newline? (lookup-command-descriptor command-name))
	((1 T) T)
	((0 NIL) NIL)))))

(defmethod 2(:ends-with-newline?0 2unexpanded-reference-gbox)0 ()
  T)

(defmethod 2(:unexpanded-reference-gbox?0 2basic-gbox0 2:default)0 () ())
(defmethod 2(:unexpanded-reference-gbox?0 2unexpanded-reference-gbox)0 () t)

(defmethod2 (:ends-with-space?0 2basic-gbox0 2:default)0 () ())
(defmethod2 (:ends-with-space?0 2space-gbox)0 () T)
(defmethod2 (:ends-with-space?0 2string-gbox)0 ()
  (and (> end-index start-index)
       (char-equal (aref string (1- end-index)) #\space)))
(defmethod2 (:ends-with-space?0 2command-gbox)0 ()
  ()						;---
  )

(defmethod 2(:starts-with-printing-char?0 2basic-gbox0 2:default)0 () ())
(defmethod 2(:starts-with-printing-char?0 2string-gbox)0 ()
  (and (> end-index start-index)		;string has length
       (not (char-white-space-p (aref string start-index)))))
(defmethod 2(:starts-with-printing-char?0 2command-gbox)0 ()
  (command-gbox-starts-with-printing-char? self))

(define-command-gbox-generic 2command-gbox-starts-with-printing-char?0 ()
  (ecase (dd-command-starts-with-printing-char? (lookup-command-descriptor command-name))
    ((1 T) T)
    ((0 NIL) NIL)))

(define-command-gbox-method 2(command-gbox-starts-with-printing-char?
			       (cb collect-centering collect-right-flushing
				   dynamic-left-margin dynamic-tab-stop force-end-of-sentence
				   force-line-break ignore-white-space
				   move-to-saved-absolute-horizontal-position
				   permit-word-break save-absolute-horizontal-position
				   tab-to-tab-stop tabclear))
0			     ()
  ())

(define-command-gbox-method 2(command-gbox-starts-with-printing-char?
			       (em literal-space missing-special-character replicate-pattern
				   replicate-pattern-aligned))
0			     ()
  T)

(define-command-gbox-method 2(command-gbox-starts-with-printing-char? label)0 ()
  ;;---When we do page/section numbers, stop ignoring this
  ())

(define-command-gbox-method 2(command-gbox-starts-with-printing-char?
			       (blankspace tabdivide tabset))
0			     ()
  ())

(defmethod 2(:starts-with-printing-char?0 2unexpanded-reference-gbox)0 ()
  T)

;;;Whether this gbox can terminate a segment of text that "tabs" as a unit.
(defmethod 2(:tab-terminating-gbox?0 2basic-gbox0 2:default)0 () ())
(defmethod 2(:tab-terminating-gbox?0 2command-gbox)0 ()
  (case command-name
    ((collect-centering collect-right-flushing tab-to-tab-stop)
     T)
    (otherwise
     ())))
(defmethod 2(:tab-terminating-gbox?0 2newline-gbox)0 () T)
(defmethod 2(:tab-terminating-gbox?0 2unexpanded-reference-gbox)0 () T)

;;...and a variation
(defmethod 2(:tab-terminating-tab-gbox?0 2basic-gbox0 2:default)0 () ())
(defmethod 2(:tab-terminating-tab-gbox?0 2command-gbox)0 ()
  (case command-name
    ((collect-centering collect-right-flushing tab-to-tab-stop)
     T)
    (otherwise
     ())))

(defmethod 2(:width0 2basic-gbox0 2:default)0 () 0)
(defmethod 2(:width picture-gbox)0 ()
  (* (cached-width-and-height self) *microns-per-screen-pixel*))
(defmethod 2(cached-width-and-height picture-gbox)0 ()
  (declare (values pixel-width pixel-height))
  (if cached-height
      (values cached-width cached-height)
      (multiple-value-bind (width height)
	  (with-device-stream (stream)
	    (with-character-style-for-picture (stream picture)
	      (dw:continuation-output-size (sage-picture-drawing-function picture) stream)))
	(ecase scale-type
	  (absolute
	    (values (setq cached-width (* width scale))
		    (setq cached-height (* height scale))))
	  (size
	    ;; SCALE is the number of microns that this picture should fit
	    ;; in
	    ;; width and height are in pixels
	    (let ((micron-width (* width *microns-per-screen-pixel*))
		  (micron-height (* height *microns-per-screen-pixel*)))
	      ;; for now, scale so that the picture will fit inside
	      ;; SCALE microns in height
	      (let* ((max-edge micron-height)	;(max micron-width micron-height))
		     (scale-by (/ scale max-edge)))
		;; change the scale appropriately so we don't have to redo
		;; this computation.
		(setq scale scale-by
		      scale-type 'absolute)
		(values (setq cached-width (* width scale-by))
			(setq cached-height (* height scale-by))))))))))

(defmethod 2(:record-entry-gbox? basic-gbox :default)0 () ())
(defmethod 2(:record-entry-gbox? record-entry-gbox)0 () t)

(defmethod 2(:newline?0 2basic-gbox0 2:default)0 () ())
(defmethod 2(:newline?0 2newline-gbox)0 () T)

(defmethod 2(:paragraph-break?0 2basic-gbox0 2:default)0 () ())
(defmethod 2(:paragraph-break?0 2paragraph-break-gbox)0 () T)
(defmethod 2(:paragraph-break?0 2unexpanded-reference-gbox)0 () T)

;;; I'm not sure it would be wise for pseudo-paragraph-break-gboxes to answer
;;; "Yes" to the above.
(defmethod 2(:pseudo-paragraph-break? basic-gbox :default)0 () ())
(defmethod 2(:pseudo-paragraph-break? pseudo-paragraph-break-gbox)0 () t)

;;;If it's a paragraph break, remove it and return T, otherwise return nil.
(defmethod 2(:flush-paragraph-break0 2basic-gbox0 2:default)0 () ())
(defmethod 2(:flush-paragraph-break0 2unexpanded-reference-gbox)0 () ())
(defmethod 2(:flush-paragraph-break0 2paragraph-break-gbox)0 ()
  (splice-box-out self)
  T)

(defmethod 2(:flush-newline0 2basic-gbox0 2:default)0 () ())
(defmethod2 (:flush-newline0 2newline-gbox)0 ()
  (splice-box-out self))
(defmethod2 (:flush-newline0 2command-gbox)0 ()
  (case command-name
    (force-line-break
     (splice-box-out self))
    (otherwise ())))

;;; Box & Line stuff
(defun 2box-line-widths0 (box-type)
  (multiple-value-bind (box-options found-p)
      (lookup-box-type-definition box-type)
    (unless found-p
      (error "~A is not a known box type." box-type))
    (multiple-value-bind (left-type top-type right-type bottom-type)
	(decode-box-type-options box-options)
      (values (typed-line-width left-type)
	      (typed-line-width top-type)
	      (typed-line-width right-type)
	      (typed-line-width bottom-type)))))

(defun 2typed-line-width0 (line-type)
  (cond ((null line-type) 0)
	(t
	 (let ((line-options (lookup-line-type-definition line-type)))
	   (unless line-options
	     (error "~A is not a known line type." line-type))
	   (destructuring-bind (&key weight (groove 0) &allow-other-keys) line-options
	     (+ weight groove))))))


(defmethod 2(box-margins box-support-gbox)0 ()
  (declare (values left-margin top-margin right-margin bottom-margin))
  (cond ((send environment :box-type)
	 (let ((left (send environment :box-left-margin))
	       (top (send environment :box-top-margin))
	       (right (send environment :box-right-margin))
	       (bottom (send environment :box-bottom-margin)))
	   (multiple-value-bind (left-line top-line right-line bottom-line)
	       (box-line-widths (send environment :box-type))
	     (values (+ left-line left)
		     (+ top-line top)
		     (+ right-line right)
		     (+ bottom-line bottom)))))
	(t (values 0 0 0 0))))
