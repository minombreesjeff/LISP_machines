;;; -*- Syntax: Common-lisp; Mode: LISP; Package: NSAGE; Base: 10; Lowercase: t -*-
;;;
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;

;;;The commands, environments, macros, and counters
(defvar *FORMATTER-DIRECTIVES* (make-hash-table :test #'string-equal))
(defvar *FORMATTER-COMMANDS* (make-hash-table))
(defvar *COUNTER-ATTRIBUTES* (make-hash-table :test #'string-equal))
(defvar *ENVIRONMENT-ATTRIBUTES* (make-hash-table :test #'string-equal))
(defvar D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")*formatter-directives-options*0 (make-hash-table))
(defvar 1*environment-attributes-options*0 (make-hash-table))
(defvar *FORMATTER-DOCUMENT-TYPES* ())
(defvar *FORMATTER-DEVICE-TYPES* ())
(defvar 1*line-type-definition-registry*0 (make-hash-table))
(defvar 1*box-type-definition-registry*0 (make-hash-table))
(defvar 1*Line-Types*0 nil)
(defvar 1*Box-Types*0 nil)

(defmacro DEFINE-DOCUMENT-TYPE (name)
  `(eval-when (compile load eval)
     (define-document-type-1 ,name)))

(defun DEFINE-DOCUMENT-TYPE-1 (name)
  (setq name (intern (string name) *sage-package*))
  (unless (member name *formatter-document-types*)
    (push name *formatter-document-types*))
  name)

(defun DOCUMENT-TYPE-P (sym)
  (and (member sym *formatter-document-types*)
       T))

(defmacro DEFINE-DEVICE-TYPE (name)
  `(eval-when (compile load eval)
     (define-device-type-1 ,name)))

(defun DEFINE-DEVICE-TYPE-1 (name)
  (setq name (intern (string name) *sage-package*))
  (unless (member name *formatter-device-types*)
    (push name *formatter-device-types*))
  name)

(defun DEVICE-TYPE-P (dev)
  (and (member dev *formatter-device-types*) T))

;;;The structure of the components slot:
;;;   ((generic (generic <Directive ...>) (lgp <Directive...>)
;;;    (symanual (lgp <Directive...>) (generic <Directive...>)))
;;;There's (potentially) one list for each Document type and with that, the contents
;;;of each document-type list are device types.  The document and device types appear
;;;in the lists in any order.  There is no requirement that every device type appears
;;;for every document type, or that every document type appears for a particular name.
;;;(e.g. consider ReturnAddress, which would be available only for document type Letter)
;;;Definitions that want to apply to all document and device types appear classified as
;;;"generic".  Things that apply to across all device types for a single document type
;;;are classified as the "generic" device type.  The accessor functions take care of
;;;looking for things in the right order so that overriding and defaulting work right.

(defstruct (DIRECTIVE-DESCRIPTOR :named (:conc-name "DD-")
		      (:print "#<Directive ~A ~A>"
		       (dd-parse-type directive-descriptor) (dd-symbol directive-descriptor))
		      (:make-array (:area *sage-formatter-area*)))
  symbol					;as symbol
  ;; :begin :end :comment :environment :command :macro :macro-key-arg :macro-pos-arg
  ;; :sage-field :sage-record :font :counter :attribute
  parse-type

  ;; Bibliography: ()
  ;; blankpage: (&optional ((n 1) :positive-integer))
  ;; --> (0 1 nil)
  ;; blankspace: ((distance :vertical-distance))
  ;; --> (1 1 nil)
  ;; case: ((selector :variable) &any-keys (clauses :text)))
  ;; --> (1 1 :key)
  ;; pageheading: (&key (left :text) (right :text) (middle :text) (immediate :none)
  ;;			(even :none) (odd :none) (line :text))))
  ;; --> (0 0 :key)
  ;; chapter: (&all (chapter :text))
  ;; --> (0 0 :all)
  ;; tabset: (&list-of (tabs :horizontal-position))
  ;; --> (0 : nil)

  arglist
  min-pos-args
  max-pos-args
  non-pos-args

  positional-args
  key-args
  any-keys
  list-of
  all

  ;; when lambda list is expected
  ;; argument-pattern
  document-type					;context for definition
  device-type					;context for definition
  ;;for envr, the attr/value pairs; for command, the message name to send to the formatter
  definition)

(defstruct (COMMAND-DESCRIPTOR :named (:conc-name nil)
			       (:make-array (:area *sage-formatter-area*))
			       (:print "#<Directive ~A ~A>"
				(dd-parse-type command-descriptor)
				(dd-symbol command-descriptor))
			       (:include directive-descriptor))
  ((dd-command-text? 0 :byte (byte 1 0))
   (dd-command-ends-with-newline? 0 :byte (byte 1 1))
   (dd-command-ends-with-space? 0 :byte (byte 1 2))
   (dd-command-starts-with-printing-char? 0 :byte (byte 1 3))
   (dd-command-undisplayed? 0 :byte (byte 1 4))
   ))

(defmacro DEFINE-SAGE-ENVIRONMENT (name document-type device-type
				   &optional other-options definition)
  (declare (arglist name document-type device-type other-options definition))
  (unless definition
    (setq definition other-options
	  other-options nil))
  `(define-directive-1 ',name 'define-sage-environment ':environment
		       () ',document-type ',device-type ,definition . ,other-options))

(defmacro DEFINE-SAGE-FIELD (name)
  `(define-directive-1 ',name 'define-sage-field ':sage-field
		       () 'generic 'generic ()))

(defmacro DEFINE-SAGE-MACRO (name document-type device-type arglist definition)
  `(define-directive-1 ',name 'define-sage-macro ':macro
		       ',arglist ',document-type ',device-type ',definition))

(defmacro DEFINE-SAGE-REFERENCE (document-type device-type arglist definition)
  `(define-directive-1 'reference 'define-sage-reference ':reference
		       ',arglist ',document-type ',device-type ',definition))

(defmacro DEFINE-SAGE-COUNTER (name document-type device-type definition)
  `(define-directive-1 ',name 'define-sage-counter ':counter
		       () ',document-type ',device-type ,definition))

(defmacro DEFINE-SAGE-FONT (name document-type device-type definition)
  `(define-directive-1 ',name 'define-sage-font ':font
		       () ',document-type ',device-type ,definition))

(defmacro DEFINE-SAGE-DIRECTIVE (name parse-type document-type device-type
				 &optional definition)
  `(define-directive-1 ',name 'define-sage-directive ',parse-type
		       () ',document-type ',device-type ,definition))

(defmacro DEFINE-SAGE-COMMAND (name arglist &rest keypairs)
  (declare (arglist name arglist &key document-type device-type definition
		    text? starts-with-printing-char? ends-with-newline? ends-with-space?
		    pretty-name internal))
  `(eval-when (compile load eval)
     (define-sage-command-1 ',name ',arglist ',(copy-list keypairs))))

(defmacro DEFINE-SAGE-ATTRIBUTE (name argument-type environment-flavor
				 other-options &optional form)
  (unless form
    (setq form other-options
	  other-options nil))
  `(with-defining-stuff ,name define-sage-attribute	;includes record-source-file-name
     (define-sage-attribute-1 ',name ',argument-type . ,other-options)
     (defmethod (:set-attribute ,environment-flavor ,name) (raw-arg)
       ,(if (consp form)
	    (cond ((eq argument-type ':none)
		   `(progn (coerce-to-type ':none raw-arg)	;for error?
			   ,form))		;body, actually
		  ((eq (first form) 'lambda)
		   `(,form (coerce-to-type ',argument-type raw-arg)))
		  (T (error "Ill-formed function ~s" form)))
	    `(setq ,form (coerce-to-type ',argument-type raw-arg ,form))))))

(defmacro DEFINE-SAGE-COUNTER-ATTRIBUTE (name argument-type form)
  `(with-defining-stuff ,name
			define-sage-counter-attribute	;includes record-source-file-name
     (define-sage-counter-attribute-1 ',name ',argument-type)
     (defmethod (:set-attribute essential-counter ,name) (raw-arg)
       ,(if (consp form)
	    (cond ((eq argument-type ':none)
		   `(progn (coerce-to-type ':none raw-arg)	;for error?
			   ,form))		;body, actually
		  ((eq (first form) 'lambda)
		   `(,form (coerce-to-type ',argument-type raw-arg)))
		  (T (error "Ill-formed function ~s" form)))
	    `(setq ,form (coerce-to-type ',argument-type raw-arg ,form))))))

(defmacro 1define-line-type0 (line-type-name document-type device-type &rest options
			    &key weight groove halftone character rawfont)
  (ignore weight groove halftone character rawfont)
  `(progn (pushnew ',line-type-name *line-types*)
	  (define-line-type-1 ',line-type-name ',document-type ',device-type ',options)))

(defmacro 1define-box-type0 (box-type-name document-type device-type
			   &rest options &key left top right bottom horizontal vertical all)
  (ignore left top right bottom horizontal vertical all)
  `(progn (pushnew ',box-type-name *box-types*)
	  (define-box-type-1 ',box-type-name ',document-type ',device-type ',options)))


(defmacro WITH-DEFINING-STUFF (name deftype &body body)
  `(zl:local-declare ((sys:function-parent ,name ,deftype))
     (record-source-file-name ',name ',deftype)
     ,@body))

(defsubst .FOO.P (x) (eq x '.foo.))

(defun VERIFY-INSTANCE-FLAVORS-EQ (self-instance other-instance)
  (check-type other-instance instance)
  (unless (eq (sys:%instance-flavor other-instance)
	      (sys:%instance-flavor self-instance))
    (error "The self-instance ~s and the other-instance ~s must be of identical flavors"
	    self-instance other-instance)))

(defmacro DEFINE-ENVIRONMENT-ATTRIBUTES (name &body environment-stuff)
  (multiple-value-bind (instance-var-names superior-vars default-vars
			toplevel-setqs types-seen)
      (process-attribute-types environment-stuff)
    types-seen					;ignored, sigh
    `(with-defining-stuff ,name define-environment-attributes 
       ;;define the flavor
       (defflavor ,name
	       ,instance-var-names
	       ()
	 :gettable-instance-variables
	 (:method-combination :set-attribute :case
			      :init-toplevel :progn
			      :setup-internal :progn))
       ;; clear out caches of old instances
       (invalidate-environment-caches)
       (invalidate-counter-caches)
       ;;a method to setup the toplevel values, even (especially) if inherited
       (defmethod (:init-toplevel ,name) ()
	 ,@toplevel-setqs
	 self)
       ;;a method to run in the context of the inner envr, for it to inherit from
       ;;superior and default
       (defmethod (:setup-internal ,name) (superior default)
	 ,(if (null superior-vars)
	      `(ignore superior)
	      `(progn (verify-instance-flavors-eq self superior)
		      (multiple-value-setq ,superior-vars
			;;Euch, ick, bletch, barf, so tell it to the marines
			(letf ((self superior))
			  (values ,@superior-vars)))))
	 ,(if (null default-vars)
	      `(ignore default)
	      `(progn (verify-instance-flavors-eq self default)
		      ;;See above
		      (multiple-value-setq ,default-vars
			(letf ((self default))
			  (values ,@default-vars)))))
	 self)
       )))

(defun PROCESS-ATTRIBUTE-TYPES (environment-stuff)
  (declare (values instance-var-names superior-variables default-variables
		   toplevel-setqs types-seen))
  (loop with types-seen = ()
	for clause in environment-stuff
	for (name . keypairs) = clause
	for type = '.foo.
	for inheriting = ()
	for default = '.foo.
	for toplevel = '.foo.
	do (zl:keyword-extract keypairs .list. (type inheriting default toplevel))
	;;A little error checking
	do (cond ((.foo.p type) (error "No type ~s" clause))
		 ((and inheriting (not (.foo.p default)))
		  (error "Both inheriting and default ~s" clause))
		 ((and inheriting (.foo.p toplevel))
		  (error "inheriting but no toplevel ~s" clause))
		 ((and (not (.foo.p default)) (not (.foo.p toplevel)))
		  (error "Default and toplevel ~s" clause))
		 ((and (.foo.p default) (.foo.p toplevel))
		  (error "Neither default nor toplevel ~s" clause))
		 ;;--anything else? check type for being known?
		 )
	collect name into instance-var-names
	when inheriting
	  collect name into superior-variables
	  else collect name into default-variables
	collect `(setq ,name (coerce-to-type ',type ',(if inheriting toplevel default)))
	  into toplevel-setqs
	unless (member type types-seen) do (push type types-seen)
	finally (return (values instance-var-names
				superior-variables default-variables
				toplevel-setqs
				types-seen))))

(defun SETUP-INHERITANCE (old-envr new-envr new-envr-name mods)
  (let ((new-flavor (sys:%instance-flavor new-envr))
	(superior old-envr)
	(default *environment-to-default-from*))
    (unless (eq (sys:%instance-flavor superior) new-flavor)
      (error "Incompatible flavor changes have scrod you.
Flavor of new ~s is ~s,
Flavor of superior ~s is ~s"
	      new-envr new-flavor superior (sys:%instance-flavor superior)))
    (when (or (null default) (neq (sys:%instance-flavor default) new-flavor))
      (when default
	(zl:fsignal "Incompatible flavor changes have scrod you. <Resume> to try fix."))
      (setq default (setq *environment-to-default-from* (make-instance 'environment)))
      (send default :init-toplevel))
    (send new-envr :set-envr-name new-envr-name)
    (send new-envr :setup-internal superior default)
;;---This is supposed to get it from find-formatting-environment-named, except that
    ;;that isn't done yet.
    (let ((envr-dd (lookup-directive-descriptor new-envr-name)))
      (cond ((null envr-dd)
	     (cerror "Treat it as TRANSPARENT"
		     "~a, which should be an environment, is undefined" new-envr-name)
	     ;; To do nothing here is to treat it as transparent.
	     )
	    ((eql (dd-parse-type envr-dd) :environment)
	     (send new-envr :adjust
		   (dd-definition envr-dd)))
	    (T (cerror "Treat it as TRANSPARENT"
		       "~a, which should be an environment, is defined as a ~a"
		       new-envr-name (dd-parse-type envr-dd))
	       ;; To do nothing here is to treat it as transparent.
	       )))
    (when mods (send new-envr :adjust mods))
    new-envr))

#|
(2 0 (NIL 0) (NIL NIL :SMALL) "TVFONT")(defun find-formatting-environment-named (name)
  (ferror "You aren't supposed to call this yet")
  (let ((specs (get name 'formatting-environment)))
    (typecase specs
      ((:null :list)
       (let ((envr (make-instance 'environment)))
	 (send envr :init-toplevel)
	 (send envr :set-envr-name name)
	 (send envr :adjust (or specs
				;;---cache it from *default-command*, if not there.
				;;The idea is that completely unknown envrs should do
				;;something not completely random.
				(get *default-command* 'formatting-environment)))
	 (setf (get name 'formatting-environment) envr)
	 envr))
      (environment specs)
      (otherwise (ferror "What is this, from ~s?  ~s"
			 `(get ,name 'formatting-environment) specs)))))
0|#

;;; You're not allowed to patch the ENVIRONMENT defflavor without also
;;; invalidating the previously cached instances.
(progn
(defflavor ENVIRONMENT
	(envr-name superior)
	(physical-attributes font-environment formatting-environment
	 mouse-sensitivity-environment box-environment lisp-splicing-hook-environment
	 vertical-justification-environment)
  :gettable-instance-variables
  :settable-instance-variables
  (:method-combination :set-attribute :case
		       :init-toplevel :progn
		       :setup-internal :progn)
  (:default-init-plist :area *sage-record-area*))
(invalidate-environment-caches))

(defmethod (SYS:PRINT-SELF ENVIRONMENT) (stream &rest ignore)
  (si:printing-random-object (self stream :typep)
    (princ (if (variable-boundp envr-name) envr-name "unbound")
	   stream)))

(defmethod (:SETUP-INTERNAL ENVIRONMENT) (new-superior ignore)
  (setq superior new-superior))

(defmethod (:INIT-TOPLEVEL ENVIRONMENT) ()
  (setq envr-name "TopLevel" superior ()))

(defmethod (:INIT-SELF-AS-SPAWNEE ENVIRONMENT) (new-name previous)
  (setq envr-name (if (atom new-name)
		      new-name
		      (list (first new-name) '---))
	superior previous))

;;; Set of records that are "the same" in having the same unique id.
;;; The defflavor must come before methods for SAGE-REFERENCE, which
;;; has record-group as an instance variable.
(defflavor RECORD-GROUP
	(unique-id
	 (topic "??")
	 (type nil)
	 (callers nil)
	 (installed-record nil)
	 (edited-records nil)
	 (published-record nil)
	 (killed nil))
	()
;;; Don't include :ordered-instance-variables because the slight speed increase
;;; isn't worth the debugging grief caused by not error-checking
  :initable-instance-variables
  :writable-instance-variables
  (:default-init-plist :area *sage-record-area*)
  )

;;; Some record groups get created by reading references (or callee lists)
;;; from SAB files.  These references have names associated with them that
;;; may or may not match the real name for the record when it's finally read
;;; from the sab file.
(defvar 1*record-group-name-uninstalled-p-table*0 (make-hash-table))

(defmethod 1(record-group-name-installed-p record-group)0 ()
  (not
    (gethash self *record-group-name-uninstalled-p-table*)))

(defmethod 1((setf record-group-name-installed-p) record-group)0 (value)
  (if value
      ;; try to keep the table small
      (remhash self *record-group-name-uninstalled-p-table*)
      (setf (gethash self *record-group-name-uninstalled-p-table*) t))
  ;; canonicalize the return value just in case anyone
  ;; calls this for value.
  (not (null value)))

#||
(3 0 (NIL 0) (NIL NIL :SMALLER) "EINY7");;;--- Destructive version.  Makes sure that the record-group is still called
;;; by its callers and that each caller is still pointed to by its record group.
;;; Suspected sources of slowness are paging in the caller records and doing
;;; the MEMBER on each caller's callees.  This could be quite bad for callers
;;; that are dictionaries with lots of callees.
(defmethod (VERIFY-CALLERS RECORD-GROUP) ()
  (setq callers
	(delete-if-not
	  #'cdr
	  (mapl (named-lambda mapl (tails)
		  (setf (first tails)
			(let* ((per-type-caller-list (first tails))
			       (ref-type (first per-type-caller-list)))
			  (delete-if-not
			    (named-lambda verify-caller (caller)
			      (or (eq caller ref-type)
				  (and (member self (cdr (assoc ref-type
								(doc-record-callees caller))))
				       ;; Flush records that are garbage (no longer pointed to
				       ;; by their own record groups)
				       (let ((caller-rg (doc-record-record-group caller)))
					 (or (eq caller (record-group-installed-record
							  caller-rg))
					     (member caller (record-group-edited-records
							      caller-rg))
					     (eq caller (record-group-published-record
							  caller-rg)))))))
			    per-type-caller-list))))
		callers))))

(defmethod (RECORD-GROUP-CALLERS RECORD-GROUP) ()
  (verify-callers self)
  callers)

(defmethod ((SETF RECORD-GROUP-CALLERS) RECORD-GROUP) (new-callers)
  (setq callers new-callers))
0||#

(defmethod (SYS:PRINT-SELF RECORD-GROUP) (stream ignore slashify-p)
  (flet ((print-self (stream)
	   (format stream "~s ~:(~a~)~:[~; [~'iKilled~]~]"
		   (if (variable-boundp topic) topic "??")
		   (if (variable-boundp type) type "??")
		   killed)))
    (if slashify-p
	(sys:printing-random-object (self stream :typep)
	  (print-self stream))
	(print-self stream))))

(defsubst DOCUMENTED-P (record-group)
  (find-record-for-lookup record-group))

;;;We'll have a book registry.  It is an alist of the symbol for the name of the
;;;book and the registered-book structure that represents that book.
(defvar *BOOK-REGISTRY* ())

;;;Uses the defbook facility
(defun DOCUMENT-P (record-group)
  (when (concept-type-p (record-group-type record-group))	; could be a function and a
						; book with the same name
    ;; A BOOK is all the documentation contained in one bound volume
    ;; The BOOK level of organization has been slipped in above DOCUMENTS
    ;; might need the document structure someday
    (registered-book-for-record-group record-group)))

;;;For rendering the "canonical" name for the type of a particular topic.
;;;Concept topics are always referred to as "Section", no matter what.
;;;For lisp, you have to use the name that the user thinks is right, like "macro"
;;;instead of "function" for defstruct, in spite of the fact that macro and function
;;;are synonyms for our internal purposes.
(defun NAMESPACE-TYPE-STRING (record-group &optional record-for-source-type)
  (if (concept-type-p (record-group-type record-group))
      (coerce-record-type :sage-section-record 'print-name)
      (let* ((installed-record (or record-for-source-type
				   (find-record-for-lookup record-group)))
	     (type (if installed-record
		       (doc-record-source-type installed-record)
		       (record-group-type record-group))))
	(string-capitalize-words type))))


;;; You ask the prevailing heading generator to tell you what the type of this
;;; section is (i.e. Chapter, Section, etc.).
(sys:defvar-resettable 1*prevailing-heading-generator*0 nil)

(defflavor 1section-heading-generator-mixin
0	(current-value)
	()
  :writable-instance-variables
  :initable-instance-variables
  (:default-init-plist :area *sage-formatter-area*)
  )

(defmethod 1(sys:print-self section-heading-generator-mixin)0 (stream ignore ignore)
  (sys:printing-random-object (self stream :typep)
    (write current-value :stream stream)))

(defmethod 1(next-value section-heading-generator-mixin)0 ()
  (if (eq current-value 'initial)
      (default-value self)
      (next-value-1 self)))
      
(defmethod 1(increment-heading section-heading-generator-mixin)0 ()
  (setq current-value (next-value self)))

(defmacro 1define-section-heading-generator0 (name &rest ordered-list-of-headings)
  (let ((flavor-name name)
	(default-value (first ordered-list-of-headings))
	(constructor-name (sys:fintern "MAKE-~A" name))
	(ordered-list-of-headings (copy-list ordered-list-of-headings)))
    `(progn (defflavor ,flavor-name
		    ()
		    (section-heading-generator-mixin)
	      (:constructor ,constructor-name (&optional (current-value 'initial)))
	      (:default-init-plist :area *sage-formatter-area*)
	      )
	    (defmethod (1default-value0 ,flavor-name) ()
	      ',default-value)
	    (defmethod (1next-value-10 ,flavor-name) ()
	      (let ((sublist (rest (member current-value ',ordered-list-of-headings))))
		(if sublist
		    (first sublist)
		    current-value)))
	    (compile-flavor-methods ,flavor-name)	;get the constructor defined
	    (defmethod (1clone-self0 ,flavor-name) ()
	      (,constructor-name current-value)))))

;;; The two current generators:
(define-section-heading-generator 1majorpart-heading-generator
0  majorpart chapter section subsection subsubsection subheading)

(define-section-heading-generator 1chapter-heading-generator
0  chapter section subsection subsubsection subheading)


(defvar 1*root-document*0 ())

;;; Like 1*root-document*0 only it's used by Producer to generate 
;;; the "see the section foo in the book bar" message.
(defvar 1*External-Formatting-Root-Document*0 ())

(defmacro 1rooting-record-expansion0 ((root-record-group &optional root-document) &body body)
  `(rooting-record-expansion-1 ,root-record-group ,root-document
			       (named-lambda rooting-record-expansion () ,@body)))

(defun 1rooting-record-expansion-10 (root-record-group
				   root-document
				   continuation)
  (stack-let* ((*root-document* (or root-document
				    (and (registered-book-for-record-group root-record-group)
					 root-record-group)
				    (in-which-book root-record-group)
				    root-record-group))
	       (*sage-expansion-history* (list root-record-group))
	       (*prevailing-heading-generator* (appropriate-initial-heading-generator
						 root-record-group))
	       (*inhibit-numbering*
		 (and (lisp-object-type-p (record-group-type root-record-group))
		      T)))
    (with-document-and-device-types ((document-type-for-record-group *root-document*)
				     ())
      (funcall continuation))))

(defmacro 1nesting-record-expansion0 ((callee-record-group
				      &optional (expansion-history '*sage-expansion-history*))
				    &body body)
  `(nesting-record-expansion-1 ,callee-record-group ,expansion-history
			       (named-lambda nesting-record-expansion () ,@body)))

(defun 1nesting-record-expansion-10 (callee-record-group expansion-history continuation)
  (stack-let ((*sage-expansion-history* (cons callee-record-group expansion-history))
	      (*prevailing-heading-generator*
		(appropriate-initial-heading-generator callee-record-group)))
    (funcall continuation)))

;;;---this needs some design
;;;Goal: Get the right number, which is used to index into a list of Scribe
;;;structure commands.
;;;The Complications:
;;;  Some books start with @majorpart and some start with @chapter
;;;  Any time you want to convert an isolated record that isn't a book, it wants to
;;;  be a chapter.
;;;  Often you have majorparts that need to be converted on their own; using chapter
;;;  as top level gives wrong impression to reviewers and writers.
;;;We're relying on the book registry here.  The default top level, if the registry
;;;doesn't say, is @majorpart.
(defun 1appropriate-initial-heading-generator0 (record-group &optional top-level)
  (flet ((find-level (rg)
	   (let ((book (registered-book-for-record-group rg)))
	     (when book
	       (getf (registered-book-extended-properties book)
		     'highest-structural-level))))
	 (make-heading-generator (type &optional document-p)
	   (ecase type
	     (chapter (make-chapter-heading-generator
			(if document-p 'initial type)))
	     (majorpart (make-majorpart-heading-generator
			  (if document-p 'initial type))))))
    (if (document-p record-group)
	(let ((level (find-level record-group)))
	  (if level
	      (make-heading-generator level t)
	      (make-heading-generator 'majorpart t)))
	(if top-level
	    (make-majorpart-heading-generator top-level)
	    (make-heading-generator
	      (let ((parents (record-group-callers record-group)))
		(if (member *root-document* (rest (assoc 'expand parents))
			    :key #'doc-record-record-group)
		    ;;find the right level for the ROOT document (the topic's parent)
		    (or (find-level *root-document*) 'majorpart)
		    'chapter)))))))

(defun 1appropriate-section-level0 ()
  (if *inhibit-numbering*
      'subheading
      (section-heading-generator-mixin-current-value *prevailing-heading-generator*)))

;;;always gets the book in which the writer wants to think of this topic as occurring now
(defun 1in-which-book0 (record-group)
  (let ((possibilities (zwei:find-topic-documents record-group)))
    (cond ((= (length possibilities) 1)		;no ambiguity
	   (first possibilities))
	  ((null possibilities) nil)		;not in a book at all
	  (t 
	   (when possibilities
	     (dw:menu-choose
	       (loop for p in possibilities
		     collect `(,(appropriate-title-rendering p 'no-formatting) ,p))
	       :prompt "In which document?"))))))

;;;; SAGE DIRECTIVES

;;The base flavor
(defflavor SAGE-DIRECTIVE ((superior) (directive-flags 0))
	   ()
  :abstract-flavor
  (:writable-instance-variables (directive-superior superior))
  (:default-init-plist :area *sage-record-area*)
  )

(defun 1describe-sage-directive-flags0 (integer flag-descriptions mismatch)
  (if (zerop integer)
      (format T "(none)")
      (loop with first = T
	    for bit-number from 0
	    for n = integer then (ash n -1)
	    until (zerop n)
	    when (oddp n)
	      do
		(let ((name (first (find bit-number flag-descriptions
					 :key #'second :test #'=))))
		  (if first
		      (setq first ())
		      (format T ", "))
		  (if name
		      (format T "~@(~a~)"
			      (subseq (string name)
				      (mismatch mismatch (string name))))
		      (format T "<~d>" bit-number))))))

(defmacro 1def-def-sage-directive-flags0 (flavor-name iv-name flag-prefix)
  (let ((special-variable (sys:fintern "*~S-BOOLEAN-FLAG-NAMES*" flavor-name))
	(macro (sys:fintern "DEFINE-~S-BOOLEAN" flavor-name))
	(mismatch (format nil "~S-" flavor-name)))
    `(progn (defvar ,special-variable ())
	    (defmacro ,macro (name bit-number)
	      `(progn (defmethod (,name ,',flavor-name) ()
			(declare (sys:function-parent ,name ,',macro))
			(ldb-test (byte 1 ,bit-number) ,',iv-name))
		      (defmethod ((setf ,name) ,',flavor-name) (new-value)
			(declare (sys:function-parent ,name ,',macro))
			(setf (ldb (byte 1 ,bit-number) ,',iv-name) (if new-value 1 0))
			new-value)
		      (pushnew (list ',name ,bit-number)
			       ,',special-variable
			       :key #'first :replace t)))
	    (defmethod (:describe ,flavor-name :after) ()
	      (unless (zerop ,iv-name)
		(format t "~&  ~A flags (~D) decode as " ,flag-prefix ,iv-name)
		(describe-sage-directive-flags ,iv-name ,special-variable ,mismatch))))))

(def-def-sage-directive-flags sage-directive directive-flags "Directive")

(define-sage-directive-boolean sage-directive-header-unconnected-to-previous 0)
(define-sage-directive-boolean sage-directive-header-unconnected-to-next 1)
(define-sage-directive-boolean sage-directive-trailer-unconnected-to-previous 2)
(define-sage-directive-boolean sage-directive-trailer-unconnected-to-next 3)
(define-sage-directive-boolean sage-directive-cloned-p 4)

;;; new mixin to define inferior-hacking methods on
(defflavor SAGE-DIRECTIVE-INFERIORS-MIXIN () ())

(defflavor SAGE-ENVR (envr-name envr-mods contents-list)
	   (sage-directive-inferiors-mixin sage-directive)
  :settable-instance-variables
  (:writable-instance-variables (directive-inferiors contents-list))
  (:constructor make-sage-envr (envr-name envr-mods contents-list))
  (:constructor 1regenerate-sage-envr0 (contents-list envr-name envr-mods directive-flags))
  (:default-init-plist :area *sage-formatter-area*))

(defmethod (SYS:PRINT-SELF SAGE-ENVR) (stream depth slashify-p)
  (if (and *print-level* (> depth *print-level*))
      (format stream "##")
      (if slashify-p
	  (si:printing-random-object (self stream)
	    (format stream "@~a" envr-name)
	    (when envr-mods (format stream "[~a]" envr-mods))
	    (when contents-list (prin1 contents-list stream)))
	  (dolist (x contents-list)
	    (princ x stream)))))

;;Commands with no params, like tab-to-tab-stop
#+patch-only
(defflavor SAGE-SIMPLE-COMMAND ()
	   (sage-command)
  (:required-instance-variables command-name)
  :settable-instance-variables
  (:default-init-plist :area *sage-formatter-area*))

;;Commands with params, like @chapter
(defflavor SAGE-COMMAND (command-name (parameter))
	   (sage-directive)
  :settable-instance-variables
  :writable-instance-variables
  (:constructor MAKE-SAGE-COMMAND-INTERNAL (command-name parameter))
  (:default-init-plist :area *sage-formatter-area*))

(defmethod (SYS:PRINT-SELF SAGE-COMMAND) (stream prindepth slashify-p)
  (ignore prindepth)
  (if slashify-p
      (si:printing-random-object (self stream)
	(write self :stream stream :escape nil))
      (let ((short-name
	      (case command-name
		(abbreviation-period ".")
		(em "-")
		((force-line-break literal-space missing-special-character) " ")
		(literal-atsign "@"))))
	(write-char #\@ stream)
	(cond (short-name
	       (write-string short-name stream))
	      (T
	       (write command-name :stream stream :escape nil)
	       (cond ((null parameter) )
		     ((stringp parameter)
		      (format stream "~\\{}\\" parameter))
		     (T (format stream "~\\{}\\" (write-to-string parameter)))))))))

;;---This instantiator needs more design.  
;;Need a way for various places to dispatch on the command name.
;;Does that mean each command wants to be its own flavor? Or each command have its own 
;;message name?  For now, let everyone do (selectq (SEND COMMAND :COMMAND-NAME) ...)
;; But, see define-sage-command-generic and define-sage-command-method
(defun MAKE-SAGE-COMMAND (name &optional parameter)
  (if (sage-simple-command-p name)
      (if parameter
	  (error "The `simple' command ~s is trying to have parameter ~s" name parameter)
	  (make-sage-command-internal name ()))
      (make-sage-command-internal name parameter)))

(defun SAGE-SIMPLE-COMMAND-P (command-name)
  (let ((dd (lookup-command-descriptor command-name)))
    (cond ((null dd)
	   (error 'sage-command-name-error :name command-name))
	  ((let ((arglist (dd-arglist dd)))
	     (and arglist (neq arglist :none)))
	   nil)
	  (T T))))

(defflavor SAGE-MACRO-CALL (macro-name macro-args)
	   (sage-directive)
  :settable-instance-variables
  (:constructor MAKE-SAGE-MACRO-CALL (macro-name macro-args))
  (:default-init-plist :area *sage-formatter-area*))

(defmethod (SYS:PRINT-SELF SAGE-MACRO-CALL) (stream &rest ignore)
  (si:printing-random-object (self stream)
    (format stream "@~a~:s" macro-name macro-args)))

(defflavor 1editable-sage-command0 (command-name inferiors)
	   (sage-directive-inferiors-mixin sage-directive)
  :settable-instance-variables
  :initable-instance-variables
  (:writable-instance-variables command-name (directive-inferiors inferiors))
  (:constructor 1make-editable-sage-command-internal0 (command-name
						      &optional (directive-flags 0)))
  (:constructor 1regenerate-editable-sage-command0 (inferiors command-name directive-flags))
  (:default-init-plist :area *sage-formatter-area*))

(defmethod 1(sys:print-self editable-sage-command)0 (stream prindepth slashify-p)
  (ignore prindepth)
  (if slashify-p
      (si:printing-random-object (self stream)
	(write self :stream stream :escape nil))
      (let ((short-name
	      (case command-name
		(abbreviation-period ".")
		(em "-")
		((force-line-break literal-space missing-special-character) " ")
		(literal-atsign "@"))))
	(write-char #\@ stream)
	(cond (short-name
	       (write-string short-name stream))
	      (T
	       (write command-name :stream stream :escape nil)
	       (loop for inferior in inferiors
		     do
		 (format-sage-command-arg-for-title inferior stream)))))))

;;---This kludge is for using environment-header-line for the diagrams
(defmethod 1(:envr-name editable-sage-command)0 ()
  command-name)

(defflavor 1sage-command-contents-field0 ((field-name "??")
			       contents)
	   (sage-directive-inferiors-mixin sage-directive)
  :initable-instance-variables
  (:readable-instance-variables field-name)
  (:writable-instance-variables
   contents
   (directive-inferiors contents))
  (:constructor 1make-sage-command-contents-field-internal0 (superior contents
							   &optional (field-name "??")))
  (:constructor 1regenerate-sage-command-contents-field0 (contents field-name directive-flags))
  (:default-init-plist :area *sage-formatter-area*))

(defmethod 1(sys:print-self sage-command-contents-field)0 (stream &rest ignore)
  (sys:printing-random-object (self stream :typep)
    (write field-name :stream stream)))

;;---This kludge is for using environment-header-line for the diagrams
(defmethod 1(:envr-name sage-command-contents-field)0 ()
  field-name)

(defflavor 1sage-command-arg-field0 ((field-name "??")
				   type
				   value
				   (value-p))
	   (sage-directive-inferiors-mixin	;; why??
	    sage-directive)
  :readable-instance-variables
  (:constructor 1make-sage-command-arg-field0 (superior type value &optional (field-name "??")
						      &aux (value-p value)))
  (:constructor 1regenerate-sage-command-arg-field0 (type value directive-flags
							&optional (field-name "??")
							(value-p value)))
  (:default-init-plist :area *sage-formatter-area*))

(defmethod 1(directive-inferiors sage-command-arg-field)0 ()
  ())

(defflavor 1sage-command-any-keys-field0 (keyword-name)
	   (sage-command-arg-field)
  :readable-instance-variables
  (:constructor 1make-sage-command-any-keys-field0 (superior keyword-name type value field-name
							   &aux (value-p value)))
  (:constructor 1regenerate-sage-command-any-keys-field0 (keyword-name type value field-name
								     value-p))
  (:default-init-plist :area *sage-formatter-area*))

(defmethod 1(format-sage-command-arg-for-title sage-command-any-keys-field)
0	   (stream &key for-source-compare)
  (ignore for-source-compare)
  (unless (eq keyword-name :new-one)
    (when (or value value-p)
      (let ((ptype (sage-typepresentation-type type)))
	(write-string ", " stream)
	(format stream "~:(~A~) " keyword-name)
	(present value ptype :stream stream)))))

(defflavor 1sage-command-any-keys-contents-list-field0 (keyword-name)
	   (sage-command-contents-field)
  (:constructor 1make-sage-command-any-keys-contents-list-field
0   (superior contents keyword-name field-name))
  (:constructor 1regenerate-sage-command-any-keys-contents-list-field0 (contents keyword-name field-name))
  (:default-init-plist :area *sage-formatter-area*))

(defmethod 1(:envr-name sage-command-any-keys-contents-list-field)0 ()
  keyword-name)

(defmethod 1(format-sage-command-arg-for-title sage-directive :default)
0	   (stream &key for-source-compare)
  (ignore stream for-source-compare))

(defmethod 1(format-sage-command-arg-for-title sage-command-contents-field)
0	   (stream &key for-source-compare)
  (when for-source-compare
    (let ((string (filtered-string-from-contents-list (directive-inferiors self))))
      (when string
	(format stream " ~:(~a~) " field-name)
	(write-string string stream)))))

(defmethod 1(format-sage-command-arg-for-title sage-command-arg-field)
0	   (stream &key for-source-compare)
  (ignore for-source-compare)
  (when value
    (case type
      ((:boolean boolean :none)
       (format stream ", ~:(~A~)" field-name))
      (otherwise (let ((ptype (sage-typepresentation-type type)))
		   (write-string ", " stream)
		   (format stream "~:(~A~) " field-name)
		   (present value ptype :stream stream))))))

;;; Jes' like 1define-sage-command-generic0.  Perhaps one day I'll merge these
;;; two flavors back together.
(defmacro 1define-editable-sage-command-generic0 (g-f-name method-arglist
						&body default-case-body)
  (let ((form
	  `(defgeneric ,g-f-name (editable-sage-command ,@method-arglist)
	     (:method-combination command-name-case)
	     (:method (editable-sage-command :otherwise)
	      (declare (sys:function-parent ,g-f-name define-sage-command-generic))
	      (ignore)
	      ,@default-case-body))))
    `(progn (incf *sage-command-generic-tick*)
	    ,form)))

(defmacro 1define-editable-sage-command-method0 ((g-f command-name) method-arglist &body body)
  `(progn
     (incf *sage-command-generic-tick*)
     (defmethod (,g-f editable-sage-command ,command-name) (,@method-arglist)
       ,@body)))

(setf (get 'define-editable-sage-command-generic 'zwei:definition-function-spec-type) 'defun)
(setf (get 'define-editable-sage-command-method 'si:definition-type-name)
      "Editable Sage Command Method")

(defun 1(:property define-editable-sage-command-method zwei:definition-function-spec-parser)
0       (bp-after-definer)
  (find-command-method-fspec bp-after-definer 'editable-sage-command))

;; Should not allow null variable names  (e.g., "")
;; Should have a history and completion space.
(define-presentation-type 1sage-variable 0()
   :history t
   :parser ((stream)
	    (let ((string (string-trim '(#\space #\tab #\return)
				       (dw:read-standard-token stream))))
	      (when (string-equal string "")
		;; trigger default-supplying mechanism
		(zl:parse-ferror "No default supplied."))
	      (values
		(intern (string-upcase string) (find-package "sage")))))
   :printer ((var stream)
	     (write-string (string var) stream)))

(defun 1sage-typepresentation-type0 (type &aux sequence-p)
  (when (and (listp type) (eq (first type) ':list-of))
    (setq type (second type) sequence-p t))
  (let ((ptype
	  (cond ((listp type)
		 `(member ,@type))
		(t (case type
		     ((:template template) 'template)
		     ((:horizontal-distance horizontal-distance
		       :vertical-distance vertical-distance
		       horizontal-distance-relative vertical-distance-relative)
		      (let ((direction
			      (case type
				((:horizontal-distance horizontal-distance
				  horizontal-distance-relative)
				 :horizontal)
				(otherwise :vertical))))
			`((distance :direction ,direction
				    :relative-p t))))
		     ((boolean integer)
		      type)
		     ((box-type line-type)
		      `((or ,type symbol)
			:description ,(with-output-to-string (s)
					(dw:describe-presentation-type type s))))
		     (presentation-type '((sys:form) :edit-trivial-errors-p nil))
		     (presentation-object '((sys:form) :edit-trivial-errors-p nil))
		     (:sage-variable 'sage-variable)
		     ((:symbol :variable)
		      'symbol)
		     (:none
		       'boolean)
		     (:text 'string)
		     (:positive-integer '((integer 1)))
		     (:nonnegative-integer '((integer 0)))
		     (:number 'number)
		     (:boolean 'boolean)
		     (:document-type 'document-type)
		     (:device-name 'device-name)
		     (:cmd-or-envr-name 'sage-markup-name)
		     ((contents-list :contents-list)
		      'contents-list)
		     (:string-for-lisp-reading 'string-for-lisp-reading)
		     (otherwise 't))))))
    (if sequence-p `(sequence ,ptype) ptype)))


;;; Expansions and crossrefs
(defflavor 1SAGE-REFERENCE
0	(record-group
	 (view ())
	 (appearance 'see)
	 (booleans ())
	 (field ()))			;---flush field?
	(sage-directive)
  :initable-instance-variables
  :writable-instance-variables
  (:constructor MAKE-SAGE-REFERENCE
   (record-group view field &optional (appearance 'see)
		 (booleans (crossreference-appearance-default-booleans appearance))
		 directive-flags))
  (:default-init-plist :area *sage-formatter-area*)	;right area?
  )

;(defmethod (flavor:transform-instance sage-reference) ()
;  (unless booleans
;    (when appearance
;      (setq booleans (crossreference-appearance-default-booleans appearance)))))

(defmethod (SYS:PRINT-SELF SAGE-REFERENCE) (stream &rest ignore)
  (si:printing-random-object (self stream)
    (format stream "@REFERENCE ((TOPIC ~S) (TYPE ~S)~@[ (VIEW ~S)~]~@[ (FIELD ~S)~])"
	    (if (and (variable-boundp record-group) record-group)
		(record-group-topic record-group)
		"??")
	    (if (and (variable-boundp record-group) record-group)
		(record-group-type record-group)
		"??")
	    view field)))

(defvar 1*crossreference-appearance-templates*0 ())			;alist

(defun 1crossreference-appearance-booleans0 (appearance)
  (get appearance 'appearance-booleans))

(defun 1crossreference-appearance-boolean-names0 (booleans)
  (loop for thing in booleans
	as name = (if (atom thing) thing (first thing))
	collecting name))

(defun 1crossreference-appearance-booleans-for-accept0 (appearance)
  (let ((booleans-&-defaults (crossreference-appearance-booleans appearance)))
    (loop for thing in booleans-&-defaults
	  as coerce-thing = (if (atom thing) (ncons thing) thing)
	  as name = (first coerce-thing)
	  collecting (list* (or (getf (cddr coerce-thing) :Pretty-name)
				(string-capitalize-words name))
			   :value name
			   (nthcdr 2 coerce-thing)))))

(defun 1crossreference-appearance-default-booleans0 (appearance)
  (let ((booleans-&-defaults (crossreference-appearance-booleans appearance)))
    (loop for thing in booleans-&-defaults
	  when (and (listp thing) (second thing))
	  collect (first thing))))

(defun 1massage-crossreference-appearance-arglist-and-body0 (body booleans)
  (let ((arglist (first body))
	(rest-body (rest body))
	(booleans (crossreference-appearance-boolean-names booleans)))
    (setq arglist (append arglist (and booleans `(&key ,@booleans))))
    `(,arglist ,@rest-body)))

(defmacro 1define-crossreference-appearance0 (appearance-name documentation booleans
					    &key formatter editor)
  (declare (zwei:indentation 0 3 1 2))
  (let ((formatter-function
	  (and formatter
	       (sys:fintern "~S-FORMATTER-APPEARANCE-FUNCTION" appearance-name)))
	(editor-function
	  (and editor
	       (sys:fintern "~S-EDITOR-APPEARANCE-FUNCTION" appearance-name))))
    `(progn ,(when formatter
	       `(defun ,formatter-function
		       ,@(massage-crossreference-appearance-arglist-and-body
			   formatter booleans)))
	    ,(when editor
	       `(defun ,editor-function
		       ,@(massage-crossreference-appearance-arglist-and-body
			   editor booleans)))
	    (define-crossreference-appearance-1
	      ',appearance-name ',documentation ',booleans
	      ,(and formatter `#',formatter-function)
	      ,(and editor `#',editor-function)))))

(defun 1define-crossreference-appearance-10 (view-name documentation booleans formatter editor)
  (setf (get view-name 'appearance-booleans) booleans)
  (pushnew (list view-name formatter editor :documentation documentation)
	   *crossreference-appearance-templates* 
	   :key #'first :replace t))

(define-presentation-type 1crossreference-appearance-template0 ()
   :description "an appearance template"
   :parser ((stream &key original-type)
	    (values
	      (dw:complete-from-sequence *crossreference-appearance-templates* stream
					 :type original-type
					 :name-key #'(lambda (thing)
						       (string-capitalize (first thing)))
					 :value-key #'first)))
   :choose-displayer ((stream object query-identifier &key original-type)
		      (dw:accept-values-choose-from-sequence
			stream *crossreference-appearance-templates* object query-identifier
			:type original-type
			:key #'first))
   :printer ((thing stream)
	     (write-string (string-capitalize thing) stream)))


;;; Pictures
(defflavor 1sage-picture
0	((type)				; :graphic-editor, :ns, :etc
	 (file-name)			; where is the source for this picture?
	 (name "unnamed")			; which picture in the file
	 binary-encoding		; picture-type specific encoding
	 (drawing-function)			;cache
	 )
	(sage-directive)
  (:constructor MAKE-SAGE-PICTURE (&key type file-name name binary-encoding drawing-function))
  (:writable-instance-variables type file-name name binary-encoding)
  :initable-instance-variables
  (:default-init-plist :area *sage-record-area*)
  )

(defmethod 1((setf sage-picture-binary-encoding) sage-picture :after)0 (ignore)
  (setq drawing-function nil))

(defmethod 1(sage-picture-drawing-function sage-picture)0 ()
  (unless drawing-function
    (setq drawing-function
	  (graphics:binary-decode-graphics-from-array-into-function binary-encoding)))
  drawing-function)

(defmethod 1(default-character-style-for-picture sage-picture)0 (stream)
  (ignore stream)
  (locally (declare (special *default-character-style-for-pictures*))
	   *default-character-style-for-pictures*))

(defvar 1*known-picture-types-registry*0 nil)

(defmacro 1define-picture-type0 (type &key binary-encoding edit-drawing argument-reader)
  `(progn (pushnew ,type *known-picture-types-registry*)
	 (setf (get ',type 'binary-encoding) ',binary-encoding)
	 (setf (get ',type 'edit-drawing) ',edit-drawing)
	 (setf (get ',type 'pathname-and-picture-name-reader) ',argument-reader)))

;;; Just what I think is essential for Book 7.  Eventually, should have all the things
;;; that were in the summer project.
(define-presentation-type active-example ()
   ;;--- I have no idea how to register these.  Perhaps these should be records rather
   ;;than inferior environments, giving them the record-group namespace?
   :printer ((ignore stream)
	     (write-string "this example" stream))
   :parser ((stream)
	    (dw:read-char-for-accept stream)
	    (sys:parse-error "You can only select examples by clicking with the mouse,
since there is no way to name them."))
   )

;;;--- What's the right noun for these things associated with examples that show the result?
(defflavor example-record-marker
	((type :typescript)			;:typescript, :picture, :bitmap
	 (encoding nil)				;a string or a binary encoding.
	 (drawing-function nil))		;a cache
	(sage-directive)
  (:constructor make-example-record-marker (&key type encoding))
  (:writable-instance-variables type encoding)
  :initable-instance-variables
  (:default-init-plist :area *sage-record-area*)
  )

(defmethod (sage-picture-drawing-function example-record-marker) ()
  (unless (or drawing-function (member type '(:typescript :values)))
    (setq drawing-function
	  (graphics:binary-decode-graphics-from-array-into-function encoding)))
  drawing-function)

(defmethod 1(default-character-style-for-picture example-record-marker)0 (stream)
  (ignore stream)
  (locally (declare (special *default-character-style-for-pictures*))
	   *default-character-style-for-pictures*))

;; The point of convergence between Sage and Zwei is the zwei:markup-structure-text-node.
;; Here in SAGE-DEFS is minimal support to get it compiled.  The rest should live
;; in a file more naturally zwei: based.

(defflavor ZWEI:MARKUP-STRUCTURE-NODE
	(zwei:markup-structure
	 (zwei:total-indentation nil)
	 (zwei:record-view :all)
	 (zwei:node-view :normal)
	 )
	(zwei:node)
  :initable-instance-variables
  (:writable-instance-variables
   ;; These have to be named explicitly.  Otherwise, the flavor system will
   ;; use the prevailing NSAGE package to intern the string-append of
   ;; markup-structure-node- and the instance variable.
   (zwei:markup-structure-node-record-view zwei:record-view)
   (zwei:markup-structure-node-node-view zwei:node-view)
   (zwei:markup-structure-node-markup-structure zwei:markup-structure)
   (zwei:markup-structure-node-total-indentation zwei:total-indentation))
  :locatable-instance-variables
  (:default-init-plist :area *sage-record-area*))

(defmethod (SYS:PRINT-SELF ZWEI:MARKUP-STRUCTURE-NODE) (stream ignore slashify-p)
  (cond ((and slashify-p (variable-boundp zwei:markup-structure) zwei:markup-structure)
	 (sys:printing-random-object (self stream :typep)
	   (brief-print-self zwei:markup-structure stream)))
	(slashify-p
	 (sys:printing-random-object (self stream :typep)
	   (cl:write-string "--" stream)))
	(t (sys:print-self zwei:markup-structure stream nil nil))))

(defflavor ZWEI:MARKUP-STRUCTURE-TEXT-NODE () (zwei:markup-structure-node))

;;; New sage structure for text leaves, repacing plain strings
(defflavor SAGE-TEXT-STRUCTURE (interval) (sage-directive)
  :initable-instance-variables
  :readable-instance-variables
  (:init-keywords :text))

(defmethod (MAKE-INSTANCE SAGE-TEXT-STRUCTURE) (&key text &allow-other-keys)
  (cond ((variable-boundp interval)
	 (when text
	   (scl:error "The caller specified both :INTERVAL and :TEXT, which is inconsistent")))
	(T (setq interval (make-sage-zwei-interval))
	   (setf (zwei:markup-structure-node-markup-structure interval) self)
	   (when text
	     (zwei:insert (zwei:interval-last-bp interval) text)))))

(defun MAKE-SAGE-ZWEI-INTERVAL (&optional (flavor 'zwei:markup-structure-text-node))
  (let ((interval (zwei:create-interval nil nil flavor)))
    ;; create-interval sets bp-buffer of the first- and last-bps of
    ;; the new interval to be the interval itself.  This is inappropriate
    ;; when we'll splice the interval into a real buffer.  NIL is
    ;; the proper thing, so put it there.
    (setf (zwei:bp-buffer-internal (zwei:interval-first-bp interval)) nil)
    (setf (zwei:bp-buffer-internal (zwei:interval-last-bp interval)) nil)
    interval))

(defun MAKE-SAGE-TEXT-STRUCTURE-FROM-STRING (string superior)
  (let ((thing (make-instance 'sage-text-structure :text string)))
    (setf (directive-superior thing) superior)
    thing))

(defflavor DOC-RECORD
	(record-group
	 (name "??")
	 (version-number)
	 (disk-location ())
	 (source-file)
	 (contents ())
	 (callees ())
	 (fields ())
	 (tokens)
	 (keywords)
	 (oneliner)
	 (source-topic)
	 (source-type)
	 (document-type)
	 (flags 0)
	 (modification-history ())
	 )
	(sage-directive-inferiors-mixin sage-directive)
  :initable-instance-variables
  (:writable-instance-variables
   (directive-inferiors contents)
   (doc-record-topic name))
  (:writable-instance-variables
   ;; All but source-topic, which has its own methods
   record-group name version-number disk-location source-file contents callees fields
   tokens keywords oneliner source-type document-type flags modification-history)
  (:default-init-plist :area *sage-record-area*)
  )

(def-def-sage-directive-flags doc-record flags "Record")

(define-doc-record-boolean doc-record-available 0)
(define-doc-record-boolean doc-record-modified 1)
(define-doc-record-boolean doc-record-filled 2)
(define-doc-record-boolean doc-record-contents-bogus 3)
(define-doc-record-boolean doc-record-installed 4)
(define-doc-record-boolean doc-record-published 5)
(define-doc-record-boolean doc-record-checkpointed 6)

(defmacro define-doc-record-extension-field (field-name flavor-name)
  (let ((getter (dw::fintern "~a-~a" flavor-name field-name)))
    `(progn
       (defmethod (,getter ,flavor-name) ()
	 (declare (sys:function-parent ,field-name define-doc-record-extension-field))
	 (second (assoc ',field-name fields)))
       (defmethod ((setf ,getter) ,flavor-name) (.new-value.)
	 (declare (sys:function-parent ,field-name define-doc-record-extension-field))
	 (let ((pair (assoc ',field-name fields)))
	   (if (null .new-value.)
	       (setq fields (delete pair fields))
	       (if pair
		   (setf (second pair) .new-value.)
		   (push (list ',field-name .new-value.) fields)))
	   .new-value.)))))

(define-doc-record-extension-field related doc-record)
(define-doc-record-extension-field releasenumber doc-record)
(define-doc-record-extension-field notes doc-record)
(define-doc-record-extension-field title-for-document-examiner doc-record)
(define-doc-record-extension-field file-attribute-string doc-record)
(define-doc-record-extension-field hardcopy-restriction doc-record)
(define-doc-record-extension-field patched-from doc-record)

(defmethod (sys:print-self doc-record) (stream ignore slashify-p)
  (flet ((format-pretty-name (stream)
	   (present (doc-record-record-group self)
		    'record-group
		    :stream stream)))
    (if slashify-p
	(sys:printing-random-object (self stream :typep)
	  (format-pretty-name stream)
	  (write-string " " stream)
	  (write-string
	    (cond ((eq self (record-group-published-record record-group))
		   "/p/")
		  ((eq self (record-group-installed-record record-group))
		   "/i/")
		  (T (let ((n (position self (record-group-edited-records record-group))))
		       (if n
			   (format nil "/e#~d/" (1+ n))
			   "/?/"))))
	    stream))
	(format-pretty-name stream))))

;; This definition must follow 2(define-doc-record-extension-field title-for-document-examiner doc-record)
0(defmethod 1(record-group-title-for-document-examiner record-group)0 ()
  (let ((record (find-record-for-lookup self)))
    (if record
	(let ((title (doc-record-title-for-document-examiner record)))
	  (if title
	      title
	      (setf (doc-record-title-for-document-examiner record)
		    (present-to-string self 'record-group))))
	(present-to-string self 'record-group))))

(defmethod (doc-record-source-topic doc-record) ()
  (setq source-topic (fatten-record-field source-topic self)))

(defmethod ((setf doc-record-source-topic) doc-record) (new-source-topic)
  ;; Assume that if it's a contents-list, it's upgraded already
  (setq source-topic new-source-topic))

(defmethod (disk-location-pathname doc-record) (&key (allow-patch-file t))
  (when disk-location
    (labels ((extract-pathname (possible-pathname)
	       (if (consp possible-pathname)
		   (first possible-pathname)
		   possible-pathname))
	     (file-is-patch-file-p (file)
	       ;; kludge here is asking the :BIN file rather than
	       ;; asking the sab file itself!
	       (send (send (send file :new-pathname :type :bin)
			   :generic-pathname)
		     :get :patch-file)))
      (when disk-location
	(loop for element in disk-location
	      as pathname = (extract-pathname element)
	      when (or allow-patch-file
		       (not (file-is-patch-file-p pathname)))
		return pathname)))))

(defstruct (modification-history-element (:type list))
  version-number
  user-id
  universal-time)

(defun modification-history-element-p (thing)
  (and (consp thing)
       (= (length thing) 3)
       (integerp (first thing))
       (stringp (second thing))
       (integerp (third thing))))

(defflavor lisp-record-type-mixin
	((arglist ()))
	()
  (:required-instance-variables contents)
  (:writable-instance-variables 
   (doc-record-arglist arglist))
  )

(defflavor concept-record-type-mixin
	((source-title ())			;for an external version of topic, optional
	 (abbrev ()))				;for documents only, for printing
	()
  (:required-instance-variables contents)
  (:writable-instance-variables
   ;; Source-title not included here.  It has its own method.
   )
  )

(defflavor lisp-record
	()
	(lisp-record-type-mixin doc-record)
  )

(defflavor concept-record
	()
	(concept-record-type-mixin doc-record)
  )

(defmethod (doc-record-source-title concept-record-type-mixin) ()
  (when source-title
    (setq source-title (fatten-record-field source-title self))))

(defmethod ((setf doc-record-source-title) concept-record-type-mixin) (new-source-title)
  ;; Assume that if it's a contents-list, it's upgraded already
  (setq source-title new-source-title))

(defgeneric 1record-field-contents0 (record-field)
  (:function
    (and record-field (funcall (flavor:generic record-field-contents) record-field))))

(defflavor 1record-field
0	(contents)
	(sage-directive-inferiors-mixin sage-directive)
  :initable-instance-variables
  (:writable-instance-variables
   contents
   (directive-inferiors contents))
  (:constructor make-record-field-internal (superior contents)))

(defmethod 1(sys:print-self record-field)0 (stream &rest ignore)
  (sys:printing-random-object (self stream :typep)
    (write (or (record-field-field-name self) "??")
	   :stream stream)))

;;; For source-compare purposes.
(defflavor 1fake-record-field0 ((envr-name "??")) ()
  :gettable-instance-variables
  (:constructor 1make-fake-record-field0 (envr-name)))

(defun 1upgrade-record-field-name0 (name)
  (case name
    (source-title 'display-name)
    (source-topic 'record-name)
    (otherwise name)))

;; Good thing this isn't needed very often.
(defmethod 1(record-field-field-name record-field)0 ()
  (upgrade-record-field-name
    (block found-it
      (when (typep superior 'doc-record)
	(let ((fl (sys:%instance-flavor superior)))
	  (dolist (var (flavor::flavor-all-instance-variables fl))
	    (when (eq self (symbol-value-in-instance superior var T))
	      (return-from found-it var))))
	(loop for (field-name field) in (doc-record-fields superior)
	      when (eq self field)
		do (return-from found-it field-name))))))

(defmethod 1(doc-record-field-contents-field? record-field)0 ()
  (eq self (doc-record-contents superior)))

;;---This kludge is for using environment-header-line for the diagrams
(defmethod 1(:envr-name record-field)0 ()
  (record-field-field-name self))

(defun 1make-record-field0 (superior record-status un-upgraded-contents)
  (let ((record-field (make-record-field-internal superior nil)))
    (setf (record-field-contents record-field)
	  (upgrade-sage-contents-list-for-newthink
	    un-upgraded-contents record-status record-field))
    record-field))

;;; These next two want to come after the 1record-field0 type is defined.  --RWK

(defun shrink-record-field (thing)
  (flet ((shrink-contents-list (contents-list)
	   (declare (values string-or-nil did-string))
	   (if (and (= 1 (length contents-list))
		    (typep (first contents-list) 'sage-text-structure))
	       (values
		 (zwei:string-interval (sage-text-structure-interval (first contents-list)))
		 T)
	       contents-list)))
    (etypecase thing
      (string thing)
      ((list)
       (multiple-value-bind (new-string string-p)
	   (shrink-contents-list thing)
	 (if string-p new-string thing)))
      ((record-field)
       (multiple-value-bind (new-string string-p)
	   (shrink-contents-list (record-field-contents thing))
	 (if string-p new-string thing))))))

;;; Space bum for the source-topic field, which is in every doc-record in the world.
;;; It would like to be a record-field containing a contents-list, but that's
;;; pretty big.  So, bum it some by making it start out as tiny as possible.
;;; Specifically, if it can be represented as a simple string, do so.  Else,
;;; leave it as a contents list.  Upon reference, make the record-field and store it
;;; back for next time.  This requires that all references, even those of methods,
;;; go through this generic function instead of simply using the instance variable.
(defun fatten-record-field (thing record)
  (etypecase thing
    (null nil)
    (string
      ;; The record-status that upgrade-sage-contents-list-for-newthink wants
      ;; is used for decoding pointy-hands and such things, which won't be
      ;; supplied here.
      ;; Use :EDITED rather than :INSTALLED so that the new code we put
      ;; into upgrade-sage-contents-list-for-newthink gets triggered properly.
      ;; I think I can convince myself that fatten-record-field really 
      ;; wants to upgrade the data-structures (and do the enstyling).
      ;; In any event, I have observed "working behavior" with this change.
      ;; -- Doughty
      (make-record-field record :edited (list thing)))
    (cons
      (make-record-field-internal record thing))
    (record-field thing)))


;;; print directives a little more briefly than print-self does.
(defgeneric BRIEF-PRINT-SELF (object stream)
  (:function
    (dw:with-output-as-presentation (:object object :type (type-of object))
      (typecase object
	(list
	  (format stream "--list(~d)--" (length object)))
	(string (write object :stream stream))
	(otherwise
	  (funcall (flavor:generic brief-print-self) object stream))))))

(defmethod (BRIEF-PRINT-SELF SAGE-DIRECTIVE :DEFAULT) (stream)
  (princ (type-of self) stream))

(defmethod (BRIEF-PRINT-SELF SAGE-TEXT-STRUCTURE) (stream)
  (sys:stack-let ((string (make-array 32 :element-type 'character :fill-pointer 0)))
    (flet ((ch (ch) (vector-push ch string)))
      (ch #\")
      (condition-case ()
	   (let ((count 0))
	     (zwei:charmap ((zwei:interval-first-bp interval)
			    (zwei:interval-last-bp interval))
	       (when (> (incf count) 20)
		 (ch #\ )
		 (zwei:charmap-return))
	       (let ((char (zwei:charmap-char)))
		 (ch (if ( (char-code char) #o200) #\ char)))))
	 (error (ch #\)))
      (ch #\"))
    (write-string string stream)))

(defmethod (BRIEF-PRINT-SELF SAGE-ENVR) (stream)
  (format stream "@~a" envr-name))

(defmethod (BRIEF-PRINT-SELF SAGE-COMMAND) (stream)
  (format stream "#~a" command-name))

(defun 1view-is-crossreference-p0 (view)
  (or (member view '(crossref crossreference))
      (member view '(crossref crossreference) :test #'string-equal)))

(defmethod (BRIEF-PRINT-SELF SAGE-REFERENCE) (stream)
  (format stream "~a(~A)"
	  (if (view-is-crossreference-p (if (consp view) (first view) view))
	      'crossreference 'reference)
	  (let ((name (and (variable-boundp record-group)
			   record-group
			   (record-group-topic record-group))))
	    (if (and name (not (stringp name)))
		(appropriate-title-rendering record-group 'no-formatting)
		name))))

(defmethod 1(brief-print-self sage-picture)0 (stream)
  (write-string name stream))

(defmethod (BRIEF-PRINT-SELF DOC-RECORD) (stream)
  (format stream "~a" (appropriate-title-rendering record-group 'no-formatting)))

(defmethod (BRIEF-PRINT-SELF record-field) (stream)
  (format stream "~A field" (or (record-field-field-name self) "??")))

;;; compile-flavor-methods has to be here because loading the database calls
;;; their constructors, and a constructor isn't defined until flavor methods
;;; compiled.  Too bad, because more methods get defined later.  Perhaps we
;;; could define constructors by hand, or coerce the flavor system into cooperation.
(compile-flavor-methods
  sage-envr
  #+patch-only sage-simple-command
  sage-command
  sage-macro-call
  sage-text-structure
  sage-picture
  example-record-marker
  editable-sage-command
  fake-record-field
  sage-command-contents-field
  sage-command-arg-field
  sage-command-any-keys-field
  sage-command-any-keys-contents-list-field
  )

;;--- SAGE-MACRO-DEFINITION needs further thought

;;--- named counters

;;Something for the parser
(defvar *TRANSPARENT-ENVIRONMENT* ())

(defun FIND-TRANSPARENT-ENVIRONMENT ()
  (or *transparent-environment*
      (setq *transparent-environment* 
	    (lookup-directive-descriptor "TRANSPARENT" 'generic 'generic))))

#||
;;; (4 0 (NIL 0) (:SWISS :BOLD NIL) "HL12B")define-sage-command-generic0				(5 0 (NIL 0) (:SWISS NIL NIL) "HL12")Macro
0;;;    (6 0 (NIL 0) (:SWISS :ITALIC NIL) "HL12I")name-for-generic-function5 (6g-f-arglist...5) &body 6body-of-default-case
0;;; 
;;; Defines 6name-for-generic-function0 to be a generic function, which can be applied
;;; to instances of sage-basic-command (that is, the parsed structure for Sage commands
;;; like @\ and @L and @pageheading, etc).  The generic function dispatches, upon the
;;; 6command-name 0of the command, to the appropriate method defined by
;;; define-sage-command-method.  6body-of-default-case0 is run for commands
;;; with no specific method of their own.
;;;
;;; 1Note0: Any file containing define-sage-command-generic cannot be (7 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")compiled
0;;; until after sys:sage;database has been 7loaded0.
;;;
;;;
;;; 4define-sage-command-method0				5Macro
0;;;    (6generic-function command-name0) 5(6g-f-arglist...5)0 5&body0 6body-of-method
0;;;
;;; Defines a method for 6generic-function0 for instances of sage-basic-command whose
;;; command-name is 6command-name0.  6command-name0 can also be a list of
;;; command names.  Here's the hair: in 6body-of-method0, all
;;; the command args defined in the Sage database are lexically accessible.
;;; That is, the command's instance variable named 7parameter0 is destructured
;;; inside a carefully constructed 7let0 enclosing the body.
;;;
;;; 1Note0: Any file containing define-sage-command-method cannot be 7compiled
0;;; until after sys:sage;database has been 7loaded0.
;;;
;;;For example:

;;; Defines how most sage commands might draw themselves in editor diagrams
(define-sage-command-generic basic-command-editor-diagram-draw (window)
  (format window "~a" command-name))

;;; Defines how @Make sage commands might draw themselves in editor diagrams.
(define-sage-command-method (basic-command-editor-diagram-draw Make) (window)
  (with-character-face (:italic window)
    (format window "Type ~a (form ~d)" type form)))v

;;; In the above, the variables 7type0 and7 form0 are available because
;;; the definition of @Make says so:
(define-sage-command 1Make0 ((type :document-type) &key (form :number))
  :undisplayed? T)
||#

(define-method-combination command-name-case (&OPTIONAL (ORDER ':MOST-SPECIFIC-FIRST))
	((CASE-DOCUMENTATION "case-documentation" :FIRST ORDER (:CASE-DOCUMENTATION))
	 (WHICH-OPERATIONS "which-operations" :FIRST ORDER (:WHICH-OPERATIONS))
	 (OTHERWISE "otherwise" :FIRST ORDER (:OTHERWISE))
	 (CASES "case ~S" :REMOVE-DUPLICATES ORDER (*)))
  (:ORDER CASES CASE-DOCUMENTATION WHICH-OPERATIONS OTHERWISE)
  (:ARGLIST IGNORE &REST ARGS)
  (:METHOD-TRANSFORMER
    ;; The cases methods receive funny arguments, and the arguments may be different for
    ;; each case, so don't bother validating them.
    (:INHIBIT-CHECKING T))

  (LET ((ALIST (LOOP FOR CASE IN CASES
		     COLLECT (LIST (let ((key (FIRST (flavor:METHOD-OPTIONS CASE))))
				     (if (atom key) (list key) key))
				   CASE))))
    `(scl:CASE command-name
       ,@(LOOP FOR (SUBTYPE METHOD) IN ALIST
	       COLLECT `(,SUBTYPE
			 ,(flavor:CALL-COMPONENT-METHOD METHOD :APPLY ARGS)))
       ((:CASE-DOCUMENTATION)
	,(IF CASE-DOCUMENTATION
	     (flavor:CALL-COMPONENT-METHOD CASE-DOCUMENTATION :APPLY ARGS)
	     `(flavor::GET-CASE-DOCUMENTATION (FIRST ,ARGS) ',ALIST)))
       ((:WHICH-OPERATIONS)
	,(IF WHICH-OPERATIONS
	     (flavor:CALL-COMPONENT-METHOD WHICH-OPERATIONS :APPLY ARGS)
	     `(VALUES ',(loop for (key) in alist append key) ',(NOT (NULL OTHERWISE)))))
       (OTHERWISE
	,(IF OTHERWISE
	     (flavor:CALL-COMPONENT-METHOD OTHERWISE)
	     `(flavor::CASE-METHOD-COMBINATION-MISSING-METHOD SELF ',flavor:GENERIC command-name ,ARGS))))))

(defvar *sage-command-generic-tick* 0)

(defmacro DEFINE-SAGE-COMMAND-GENERIC (g-f-name method-arglist &body default-case-body)
  (let ((form
	  `(defgeneric ,g-f-name (sage-command ,@method-arglist)
	     (:method-combination command-name-case)
	     (:method (sage-command :otherwise)
	      (declare (sys:function-parent ,g-f-name define-sage-command-generic))
	      (ignore)
	      ,@default-case-body))))
    `(progn (incf *sage-command-generic-tick*)
	    ,form)))

(defmacro DEFINE-SAGE-COMMAND-METHOD ((g-f command-name) method-arglist &body body)
  `(progn
     (incf *sage-command-generic-tick*)
     (defmethod (,g-f sage-command ,command-name) (,@method-arglist)
       ,(if (consp command-name)
	    `(progn ,@body)
	    `(with-sage-command-args (,command-name self)
	       ,@body)))))

(setf (get 'define-sage-command-generic 'zwei:definition-function-spec-type) 'defun)
(setf (get 'define-sage-command-method 'si:definition-type-name) "Sage Command Method")

(defun (:property define-sage-command-method zwei:definition-function-spec-parser)
       (bp-after-definer)
  (find-command-method-fspec bp-after-definer 'sage-command))

(defun find-command-method-fspec (bp-after-definer flavor)
  (let ((after-method-bp (zwei:forward-sexp bp-after-definer)))
    (when after-method-bp
      (multiple-value-bind (method-spec error-p)
	  (zwei:read-fspec-item-from-interval bp-after-definer after-method-bp)
	(if (or error-p (symbolp method-spec))
	    (values nil nil nil t)
	    (let ((fspec (destructuring-bind (g-f-name command-case) method-spec
			   `(flavor:method ,g-f-name ,flavor,command-case))))
	      (if 
		(si:validate-function-spec fspec)
		;; cons the string if we are really returning. No choice.
		(values fspec 'defun (zwei:string-interval bp-after-definer after-method-bp t)
			nil)
		(values nil nil nil t))))))))

(defmacro WITH-SAGE-COMMAND-ARGS ((command-name instance) &body body)
  (let* ((dd (gethash command-name *formatter-commands*))
	 (min-pos-args (dd-min-pos-args dd))
	 (max-pos-args (dd-max-pos-args dd))
	 (positional-args (dd-positional-args dd))
	 (vars-used-in-body
	   (lt:mapforms (sys:named-lambda mapforms (form kind usage free-vars)
			  (ignore usage)	;SETQS get lost!
			  (when (eq kind 'lt:symeval)
			    (unless (member form lt:*mapforms-bound-variables*)
			      (unless (get form 'special)
				(pushnew form free-vars))))
			  free-vars)
			`(progn ,@body)
			:bound-variables ())))
    (labels ((some-non-pos (dd)
	       (or (dd-non-pos-args dd)
		   (dd-any-keys dd)
		   (dd-list-of dd)
		   (dd-all dd)))
	     (do-non-pos (value)
	       (let ((key-args (dd-key-args dd)))
		 (when key-args
		   (return-from do-non-pos
		     (multiple-value-bind (let-spec ignores)
			 (loop for (var) in key-args
			       when (member var vars-used-in-body)
				 collect `(,var (second (assoc ',var ,value))) into let-spec
				 and collect var into ignores
			       finally (return (values let-spec ignores)))
		       `(let ,let-spec
			  (progn ,@ignores)
			  ,@body)))))
	       (flet ((if-there (arg-spec)
			(when arg-spec
			  (if (member (first arg-spec) vars-used-in-body)
			      `(let ((,(first arg-spec) ,value))
				 (progn ,(first arg-spec))
				 ,@body)
			      `(progn ,@body)))))
		 (or (if-there (dd-any-keys dd))
		     (if-there (dd-list-of dd))
		     (let ((arg-spec (dd-all dd)))
		       (when arg-spec
			 (when (member (first arg-spec) vars-used-in-body)
			   `(let ((,(first arg-spec) (first ,value)))
			      (progn ,(first arg-spec))
			      ,@body))))
		     `(progn ,@body)))))
      (let ((outer-body
	      (cond (positional-args
		     (let ((pos-args-spec (map 'list #'first positional-args)))
		       (mapl (lambda (tail)
			       (unless (member (if (atom (first tail))
						   (first tail)
						   (first (first tail)))
					       vars-used-in-body)
				 (setf (first tail) 'nil)))
			     pos-args-spec)
		       (when ( min-pos-args max-pos-args)
			 (if (zerop min-pos-args)
			     (push '&optional pos-args-spec)
			     (push '&optional (nthcdr min-pos-args pos-args-spec))))
		       (let ((ignores
			       (delete nil
				       (mapcar (lambda (x)
						 (cond ((listp x) (first x))
						       ((eql (char (string x) 0) #\&) nil)
						       (T x)))
					       pos-args-spec))))
			 (if (some-non-pos dd)
			     `(zl:destructuring-bind (,@pos-args-spec &rest .more.) .parameter.
				(ignore .more. ,@ignores)
				,(do-non-pos '.more.))
			     `(zl:destructuring-bind (,@pos-args-spec) .parameter.
				(ignore ,@ignores)
				,@body)))))
		    (T (if (some-non-pos dd)
			   (do-non-pos '.parameter.)
			   `(progn ,@body))))))
	(if (block found
	      ;; Another little code walk, which doesn't have to expand macros or anything
	      ;; because we know the only occurrences of .parameter. are those we put there.
	      (labels ((ck (thing)
			 (cond ((eq thing '.parameter.)
				(return-from found T))
			       ((consp thing)
				(loop while (consp thing)
				      do (ck (pop thing))
				      finally (ck thing))))))
		(ck outer-body)))
	    `(let ((.parameter. (sage-command-parameter ,instance)))
	       .parameter.
	       ,outer-body)
	    outer-body)))))

(zl:comment
  ;; This must not reference .parameter. because it will be unbound!
  (with-sage-command-args (tab-to-tab-stop foo) (mumble))
  ;; This should not reference .parameter. because the body doesn't
  ;; use 7distance0, an arg to blankspace, but it's okay if it does.
  (with-sage-command-args (blankspace foo) (mumble ) nil))

;;;============================================================
;; Do over sage node and its directive-superiors
(defmacro do-sage-superiors ((node-var first-node) &body body)
  `(block nil
     (do-sage-superiors-1 ,first-node
			  (named-lambda do-sage-superiors (,node-var)
			    ,@body
			    ;; The NIL here keeps the compiler from compiling the body
			    ;; for value instead of effect
			    nil))))

(defun do-sage-superiors-1 (first-node continuation)
  (declare (sys:downward-funarg continuation))
  (loop for node = first-node then (directive-superior node)
	until (null node)
	do (funcall continuation node)))

(defmacro do-zwei-sage-superiors ((zwei-node its-sage-node starting-zwei-node) &body body)
  `(block nil
     (do-zwei-sage-superiors-1 ,starting-zwei-node
			       (named-lambda do-zwei-sage-superiors
					     (,zwei-node ,its-sage-node)
				 ,@body
				 ;; The NIL here keeps the compiler from compiling the body
				 ;; for value instead of effect
				 nil))))

(defun do-zwei-sage-superiors-1 (starting-zwei-node continuation)
  (declare (sys:downward-funarg continuation))
  (loop for zwei-node = starting-zwei-node then (zwei:node-superior zwei-node)
	for sage-node = (and (typep zwei-node 'zwei:markup-structure-node)
			     (zwei:markup-structure-node-markup-structure zwei-node))
	while (and zwei-node sage-node)
	do (funcall continuation zwei-node sage-node)))

;;; --- Exports.  These should be moved to pkgdcl.
(export '(define-box-type define-line-type define-sage-attribute define-sage-command
			  define-crossreference-appearance))

;; (Moved from concordia)
(defvar 1zwei:*using-connection-markers* 0t)

(defgeneric 1(setf connected-to-previous-line)0 (sage-thing trailer-p new-val)
  (:method (sage-directive :default)
   (if trailer-p
       (setf (sage-directive-trailer-unconnected-to-previous self) (not new-val))
       (setf (sage-directive-header-unconnected-to-previous self) (not new-val)))
   new-val))


(defgeneric 1(setf connected-to-next-line)0 (sage-thing trailer-p new-val)
  (:method (sage-directive :default)
   (if trailer-p
       (setf (sage-directive-trailer-unconnected-to-next self) (not new-val))
       (setf (sage-directive-header-unconnected-to-next self) (not new-val)))
   new-val))

(defgeneric 1maintains-connection-flags-p0 (sage-thing)
  (:method (sage-directive :default) zwei:*using-connection-markers*))

(defgeneric 1connected-to-previous-line0 (sage-thing trailer-p)
  (:method (sage-directive :default)
   (not (if trailer-p
	    (sage-directive-trailer-unconnected-to-previous self)
	    (sage-directive-header-unconnected-to-previous self)))))

(defgeneric 1connected-to-next-line0 (sage-thing trailer-p)
  (:method (sage-directive :default)
   (not (if trailer-p
	    (sage-directive-trailer-unconnected-to-next self)
	    (sage-directive-header-unconnected-to-next self)))))
