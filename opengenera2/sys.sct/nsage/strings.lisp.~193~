;;; -*- Syntax: Common-lisp; Mode: LISP; Package: NSAGE; Base: 10; -*-
;;;
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;

;;;Package of various functions for string handling in Sage.  Some of these are going to be
;;;generally useful things, not dependent on Sage particularly.

;;;  Since this file wants to work standalone, its defvars stay here.

;;combines flag-char, white-space, punctuation
(defparameter *WORD-BREAK* '(#\@ #\SPACE #\LF #\CR #\TAB #\FF #\/ #\? #\. #\, #\' #\" #\; #\: #\\
   #\| #\` #\~ #\] #\) #\( #\[ #\} #\> #\{ #\< #\+ #\= #\_ #\- #\* #\& #\^ #\% #\$ #\# #\!))

;;;Using this instead of the parser's idea of punctuation because we don't want characters
;;;that are likely to be part of the "word" to be stripped off before string comparison.
(eval-when (eval load compile)
(defvar *TITLE-PUNCTUATION* '(#\, #\. #\; #\" #\( #\) #\? #\! #\/)))	;no "'" --doughty
(defvar *LOWERCASE-IN-TITLES* '("a" "an" "and" "as" "by" "for" "is" "in" "of" "on"
				"or"		;"out" removed per jo 7feb84
				"the" "to" "up" "with"))

;;;Now officially obsolete.
;(defvar *UPPERCASE-IN-TITLES* '("ASCII" "EOF" "FED" "FEP"  "FSPT" "GC" "IDS"
;				"IEEE" "ISO" "ITS" "IV" "LGP" "LMFS" "LM-2"
;				"LOGTRAN" "MAR" "NDS" "NFEP" "NFILE" "PC" "QFILE"
;				"SCL" "TD-80" "TENEX" "TOPS-20" "TV" "UNIX" "UNIBUS"
;				"VAX" "VMS" "XT-1140"))

;;;Given a topic identifier, return a title, appropriately rendered.  The primary
;;;job is to take care of proper capitalizing.  It also considers "markup".
;;;The rules are complex.  The appropriateness depends on the conditions under which
;;;the requester wants to use the title.  This is specified by the "usage" argument.
;;;Usage: 'no-formatting  Caller wants a string with no vestiges of markup.  This is
;;;          intended for things like completion aarrays and fixed width font menus.
;;;          Lisp objects get upcased; concept titles are subjected to the caps rules; 
;;;          @L environments get upcased to simulate the abandoned markup for this only.
;;;       'formatting  Caller wants a contents list.  Start with the source-topic, else
;;;          the symbol pname.  Lisp objects get downcased; concept titles subjected to
;;;          caps rules.
;;;       'formatting-using-title-field  Same as formatting in behavior but start with
;;;          the title field, else source-topic, else symbol pname.
;;;NOTE: The converter has to use this to get the capitalizing right but this hands
;;;back a contents list for concept records, not a string.  Converter takes it from there.
(defun APPROPRIATE-TITLE-RENDERING (record-group usage &optional record-for-source-topic)
  (check-type usage (member no-formatting formatting formatting-using-title-field))
  (let* ((topic (record-group-topic record-group))
	 (type (record-group-type record-group))
	 (installed-record (or record-for-source-topic (find-record-for-lookup record-group)))
	 (source-topic (and installed-record
			    (record-field-contents
			      (doc-record-source-topic installed-record))))
	 (source-title (and installed-record 
			    (concept-type-p (doc-record-source-type installed-record))
			    (record-field-contents
			      (doc-record-source-title installed-record))))
	 (capitalize-p t))
    ;;---Lisp objects don't have source-topics.  Assume that if type is NIL and there
    ;;isn't a source topic that this is safe to render as a lisp object title.
    (cond
      ((and (or source-topic
		(and source-title (non-white-contents-list source-title)
		     (eq usage 'formatting-using-title-field)))
	    (concept-type-p type)) ;ordinary concept topic
       (let ((contents-list
	       (if (eq usage 'formatting-using-title-field)
		   (if source-title source-title source-topic)
		   source-topic)))
	 (when (eq contents-list source-topic)
	   (setq capitalize-p nil))
	 ;;---Perhaps we could think of a faster way to determine whether the
	 ;; contents list needs to be "canonicalized".  It is necessary to
	 ;; avoid calling any of these title-hacking functions on un-canonicalized
	 ;; editor markup -- they blow out trying to put the little marker chars
	 ;; into their thin strings.
	 (when (member installed-record (record-group-edited-records record-group))
	   (setq contents-list (canonicalize-contents-list contents-list)))
	 (setq contents-list (capitalize-as-title contents-list usage t D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")capitalize-p0))
	 (ecase usage			;usage determines type of thing to return
	   (no-formatting
	    (filtered-string-from-contents-list contents-list))
	   ((formatting formatting-using-title-field)
	    contents-list))))
      ;;ordinary lisp topic or topic with unspecified type
      ((and (or (lisp-object-type-p type) (null type)))	; (and ...(null source-topic))
       (ecase usage				;we have no markup to worry about here
	 (no-formatting
	  (string-for-lisp-object-title topic :upcase))	;just plain
	 ((formatting formatting-using-title-field)
	  ;wants lower-case, contents list
	  (list (string-for-lisp-object-title topic :downcase)))))
      ((and (null source-topic) (concept-type-p type))	;ordinary concept with no source topic
       ;;happens when one record refers to another that isn't loaded or existing yet
       (let ((string (capitalize-as-title topic usage)))
	 (ecase usage
	   (no-formatting string)
	   ((formatting formatting-using-title-field)
	    (list string)))))
      ((and source-topic (lisp-object-type-p type))	;there is an @ in the lisp name
       (error "I believe it is impossible to have a source-topic for a lisp object type"))
      (T (error "Unrecognized category: ~S ~S" topic type)))))

;;;This takes either a contents list, symbol, or string.  It returns the same kind of 
;;;object as it received (except symbol --> string!).
;;;It applies capitalizing rules according to the usage required
(defun CAPITALIZE-AS-TITLE (prototitle usage &optional (first-time t) (capitalize-p t))
   (typecase prototitle
     (null "")					;to avoid returning "NIL"
     (string (if capitalize-p
		 (capitalize-string-as-title prototitle)
		 prototitle))
     (symbol
      (capitalize-string-as-title		;makes a copy of the string; can't fiddle
	(string-downcase (symbol-name prototitle)) t capitalize-p))	;the pname itself!!
     (phony-function-spec			;shouldn't arise but just in case
       (capitalize-string-as-title (string-downcase (format nil "~A" prototitle))
				   t capitalize-p))
     (cons
       ;contents list
       (capitalize-contents-list-as-title prototitle usage first-time capitalize-p))
     (otherwise
       (error "Trying to use ~S, a ~A, as a title.  Can't handle this."
	       prototitle (type-of prototitle)))))

;;;Capitalizes the words in a string according to "rules" embodied in 
;;;special variable *lowercase-in-titles*.
;;;The same capitalizing rules apply, once something is a string, no matter what
;;;context the title will be used in.  This is because you can't guess whether
;;;there was any structure or markup.  Hence, no "usage" arg.
;;; Bummed to not use TOKENIZE 5/5/87 --doughty
(defun CAPITALIZE-STRING-AS-TITLE (string &optional (capitalize-initial t) (capitalize-p t))
  (if (not capitalize-p) string
  (sys:with-stack-array (result 50 :element-type 'character
				:fill-pointer 0)
    (dw::do-delimited-substrings
      ((string) (char start end))
      (sys:with-stack-array (substring (- end start)
				       :type (si:array-type string)
				       :displaced-to string
				       :displaced-index-offset start)
	(cond ((member substring *lowercase-in-titles*
		       :test #'string-equal)
	       (if capitalize-initial
		   (add-and-casify-in-place result string start end
					    'capitalize)
		   (add-and-casify-in-place result string start end
					    'lower)))
	      ((position-if #'upper-case-p substring)
	       (string-nconc-portion result string start end))
	      (t (add-and-casify-in-place result string start end
					  'capitalize)))
	(unless (= end start)
	  (setq capitalize-initial nil)))
      ((#\space #\return) (vector-push-extend #\space result))
      (#.*title-punctuation*	;try this w/o special-casing apostrophes
       (vector-push-extend char result)))
    (copy-string result))))

;;;Capitalizes the words in the strings and directives in a contents-list.
;;;Returns a contents list for further munging by whatever is using it.
;;;This is pretty much just a loop to feed things to capitalize-string-as-title
;;;except for the case of @L directives, which have to get capitalized according
;;;to the usage argument.
(defun CAPITALIZE-CONTENTS-LIST-AS-TITLE (contents-list usage
					  &optional (first t) (capitalize-p t))
  (loop with result-list
	for ele in contents-list
	for first-time = first then nil
	do (typecase ele
	     (string (push (if capitalize-p
			       (capitalize-string-as-title ele first-time)
			       ele) result-list))
	     ((or sage-envr sage-command sage-text-structure)
	      (push (send ele :capitalize-self-as-title usage first-time capitalize-p)
		    result-list))
	     (otherwise (error "Unrecognized component ~S in contents-list ~S"
				ele contents-list)))
	finally (return (nreverse result-list))))

;;;We have an environment directive here.  This is probably something like @I, @L, @K.
;;;During formatting we are just using standard capitalizing rules, so we'll just route
;;; it back to capitalize-contents-list-as-title.  When we aren't formatting, however,
;;; we need to ignore markup (i.e. convert the environment contents into a string),
;;; capitalize other stuff, and uppercase an @L, leave case alone on @K.
(defmethod (:CAPITALIZE-SELF-AS-TITLE SAGE-ENVR) (usage first capitalize-p)
  (ecase usage
    (no-formatting
     (let ((string (filtered-string-from-contents-list contents-list)))	;ignore markup
       (case envr-name
	 (K (capitalize-as-key-name string))	;notation convention rules if @K
	 (LS (string-upcase string))
	 ;; usual caps rules for others
	 (otherwise (capitalize-string-as-title string first capitalize-p)))))
    ((formatting formatting-using-title-field)
     ;side-effect on the contents-list of the envr
     (setq contents-list
	   (case envr-name
	     (K (capitalize-k-envr-as-title contents-list usage first capitalize-p))
	     (LS (capitalize-ls-envr-as-title contents-list usage first capitalize-p))
	     (otherwise (capitalize-contents-list-as-title contents-list usage first capitalize-p))))
     self)))

(defmethod (:CAPITALIZE-SELF-AS-TITLE SAGE-TEXT-STRUCTURE) (usage first capitalize-p)
  (let ((string (capitalize-string-as-title (zwei:string-interval interval) first capitalize-p)))
    ;; Needed for @LS.  No sage-text-structure that is sent this message
    ;; should have Lisp-face chars that come from @L.  Package and syntax
    ;; would not display correctly.
    (flet ((char-has-lisp-face (char)
	     (eql (si:cs-face (si:char-style char)) 'lisp)))
      (ecase usage
	(no-formatting
	  (modify-chars-in-string string #'char-upcase :predicate #'char-has-lisp-face)
	  (string-thin string :remove-bits t :error-if :fat))
	((formatting formatting-using-title-field)
	 (modify-chars-in-string string #'char-downcase :predicate #'char-has-lisp-face)
	 ;;---Is this right?
	 ;;(make-sage-text-structure-from-string string superior)
	 #+ignore
	 (let ((bp (zwei:delete-interval interval)))
	   (zwei:insert bp string))
	 self)))))

(defmethod (:CAPITALIZE-SELF-AS-TITLE SAGE-COMMAND) (usage first capitalize-p)
  (ignore first capitalize-p)
  (case command-name
    (L (ecase usage
	 (no-formatting (display-string-from-L-command self :upcase))
	 ((formatting formatting-using-title-field) self)))
    (otherwise self)))

;;;This is a very special case thing.  It is for dealing with the contents-list for
;;; an @LS environment.  i.e. this is not used in the 'no-formatting context.
;;; Any plain @LS part has to be rendered in lower case
;;; (as appropriate for the usage) but any nested part has to be dealt with normally.
(defun CAPITALIZE-LS-ENVR-AS-TITLE (contents-list usage first capitalize-p)
  (loop with result-list			;have to downcase @LS part
	for ele in contents-list		;and treat any nested envr inside @LS normally
	do
        (typecase ele
	  (string (push (nstring-downcase ele :start 0 :end nil) result-list))
	  ((or sage-envr sage-command sage-text-structure)
	    (push (send ele :capitalize-self-as-title usage first capitalize-p)
		  result-list))
	  (otherwise (error "Unrecognized component ~S in contents-list ~S"
			     ele contents-list)))
	finally (return (nreverse result-list))))

(defun CAPITALIZE-K-ENVR-AS-TITLE (contents-list usage first capitalize-p)
  (loop with result-list
	for ele in contents-list		;in case any nested envr inside @K
	do
	(typecase ele
	  (string (push (capitalize-as-key-name ele) result-list))
	  ((or sage-envr sage-command sage-text-structure)
	    (push (send ele :capitalize-self-as-title usage first capitalize-p) result-list))
	  (otherwise (error "Unrecognized component ~S in contents-list ~S"
			     ele contents-list)))
	finally (return (nreverse result-list))))

;;;The notation conventions for naming can be found in the documentation.  However
;;;this is how it works.  Key modifiers are in lower case; all other key names are in
;;;upper case.  Hence c-m-ABORT, SYSTEM HELP, c-sh-C, and so on.
(defvar *MODIFIER-KEY-ABBREVIATIONS* '("c-" "m-" "s-" "h-" "sh-" "sy-" "mouse-"))

;;;For each "word", grope along to find the boundary between any modifier names and
;;;the "real" key names.  Then downcase the modifiers and upcase everything after them.
;;;Test cases: "c-abort" "c-sh-C" "c-X c-F" "clear input" "select"
(defun CAPITALIZE-AS-KEY-NAME (string)
  (let ((substrings (loop with end = (string-length string)
			  for from = 0 then (string-search-not-char #\space string :start to)
			  while from
			  for to = (or (sys:%string-search-char #\space string from end) end)
			  collect (list from to))))
    (loop for (start end) in substrings		;deal with each substring independently
	  do					;first, find where modifiers end
	  (loop for spot = start then pos
		for pos = (loop for key in *modifier-key-abbreviations*
				for pos = (string-search key string :start2 spot :end2 end)
				when pos return (+ pos (string-length key)))
		while pos
		finally (casify-in-place #'char-downcase string start spot)
		(casify-in-place #'char-upcase string spot end))))
  string)

;;; Can return a fat string.  The theory is that callers who want the string thinned
;;; should call STRING-THIN on the string returned.
(defun FILTERED-STRING-FROM-CONTENTS-LIST (contents-list &optional preserve-newlines)
  (typecase contents-list
    (string contents-list)			;for some reason, it is already a string
    (null NIL)					;NIL, not the string "NIL"!
    (symbol (string contents-list))		;it's already a symbol, give it back as string
    (otherwise
      (let (indexes)
	(using-resource (temp fat-string-temp)
	  (dolist (thing contents-list)
	    (typecase thing
	      (string (string-nconc temp (string-thin thing :remove-bits t :error-if :fat)))
	      (symbol (string-nconc temp (string thing)))
	      (cons (break "This is an obsolete form of contents list: ~S~%from ~S"
			      thing contents-list))
	      (otherwise
		(let ((numbers (send-if-handles thing :filter-formatter-directives temp)))
		  (when numbers (setq indexes (nconc numbers indexes)))))))
	  (values (if preserve-newlines
		      (copy-string temp)
		      (collapse-chars-for-intern (copy-string temp)))
		  indexes))))))

(defmethod (:FILTER-FORMATTER-DIRECTIVES SAGE-ENVR) (format-dest)
  (let ((from (fill-pointer format-dest))
	indexes)
    (dolist (thing contents-list)
      (if (stringp thing)
	  (format format-dest "~a" thing)
	  (let ((numbers (send-if-handles thing :filter-formatter-directives format-dest)))
	    (when numbers (setq indexes (nconc numbers indexes))))))
    (push `(,from ,(fill-pointer format-dest)) indexes)))

(defmethod (:FILTER-FORMATTER-DIRECTIVES SAGE-TEXT-STRUCTURE) (format-dest)
  (format format-dest "~A" (zwei:string-interval interval)))

(defmethod (:FILTER-FORMATTER-DIRECTIVES SAGE-COMMAND) (format-dest)
  (sage-command-filter-formatter-directives self format-dest))

;; The define-sage-command-generic and -method for sage-command-filter-formatter-directives
;; have been moved into filter-directives.lisp for purposes of compilation order.


;;;Change any hard RETURN into a single space; replace multiple spaces with a single space.
(defun COLLAPSE-CHARS-FOR-INTERN (string &optional (ch #\SPACE))
  (setq string (string-replace-substring string #\return #\space))
  (loop with start = 0
	with next
	for pos = (string-search-char ch string :start start)
	while pos
	do (setq next (or (string-search-not-char ch string :start pos) (string-length string)))
	(unless (if next (= next (1+ pos)))
	  (let* ((rest-len (- (string-length string) next))
		 (new-len (+ 1 pos rest-len)))
	    (copy-array-portion string next (string-length string)
				string (1+ pos) new-len)
	    (adjust-array string new-len)))
	(setq start (1+ pos)))
  string)

;;;appends a range from one string to a destination string, adjusting the case of the
;;;piece being added.
(defun ADD-AND-CASIFY-IN-PLACE (dest source from to case)
  (let ((offset (fill-pointer dest)))
    (string-nconc-portion dest source from to)
    (ecase case
      (stet ())
      (capitalize				;survive leading punctuation
       (let* ((end (+ offset (- to from)))
	      (start-pos (position-if #'alpha-char-p dest :start offset :end end)))
	 (when start-pos
	   (let ((next-pos (1+ start-pos)))
	     (casify-in-place #'char-upcase dest start-pos next-pos)
	     (casify-in-place #'char-downcase dest next-pos end)))))
      (upper (casify-in-place #'char-upcase dest offset (+ offset (- to from))))
      (lower (casify-in-place #'char-downcase dest offset (+ offset (- to from)))))))

;;;adjust the case of a range of characters in a string.  First arg is the casifying
;;;function to apply to each of the characters in the specified range.  String has to
;;;be one for which aref and setf will work.
(defun CASIFY-IN-PLACE (fcn string &optional (from 0) to)
  (let ((length (string-length string)))
    (setq to (if to (min to length) length)))
  (decoding-array (string string)
    (loop for i from from below to
	  do (setf (aref string i) (funcall fcn (aref string i))))))

(defun MODIFY-CHARS-IN-STRING (string function &key (start 0) end (predicate #'true))
  (declare (sys:downward-funarg *))
  (when (null end) (setq end (string-length string)))
  (let ((string string))
    (declare (sys:array-register string))
    (loop for i from start below end
	  for char = (aref string i)
	  when (funcall predicate char)
	    do (setf (aref string i) (funcall function char)))))

;;This used to hack optional 2nd and 3rd args (real-spec-p t) (device ':paper)
;;That functionality has been replaced by 
;;		DISPLAY-LISP-OBJECT-TITLE (stream spec real-spec-p device)
(defun STRING-FOR-LISP-OBJECT-TITLE (spec &optional (case :downcase))
  ;; --- Kludge alert:  This is here to make old method specs work.
  ;; Remove when new record type system is installed.
  (when (and (symbolp spec)
	     (eq (symbol-package spec) zwei:*utility-package*))
    (setq spec (with-standard-io-environment (read-from-string (symbol-name spec)))))
  (display-string-for-lisp-expression spec case))

(defun DISPLAY-STRING-FOR-LISP-EXPRESSION (expression &optional (case :downcase))
  (with-standard-sage-io-environment
    (let ((*print-case* case))
      ;; If someone did @L("foo bar") that gets written to sab file as fat string
      ;; (character face sage::lisp), and this will print it that way.  So make it thin.
      ;;---I guess if someone really wants a string with character style they shouldn't
      ;; put it inside an @L.  If they want something not in standard character set
      ;; this must be changed.
      (string-thin (prin1-to-string expression)
		   :remove-bits t :error-if :fat))))

(defun DISPLAY-STRING-FROM-L-COMMAND (command &optional (case :downcase))
  (using-resource (temp string-temp)
    (loop for list = (first (send command :parameter)) then cdr
	  while list
	  for cdr = (cdr list)
	  for thing = (first list)
	  do (string-nconc temp (display-string-for-lisp-expression thing case))
	     (when cdr (string-nconc temp #\space)))
    (copy-string temp)))

(defun 1lisp-topic-link-sort-key0 (topic)
  (using-resource (into-string string-temp)
    (using-resource (package-string string-temp)
      (labels ((separate (string)
		 (when (> (length string) 0)
		   (string-nconc string " ")))
	       (portion (string &optional from to)
		 (when (null from) (setq from 0))
		 (when (null to) (setq to (string-length string)))
		 (let ((number-of-*s 0))
		   (dw::do-delimited-substrings
		     ((string :start from :end to)
		      (char start-index end-index))
		     (string-nconc-portion into-string string start-index end-index)
		     (#\*
		      (ignore char)
		      (incf number-of-*s)))
		   (dotimes (ignore number-of-*s)
		     (vector-push-extend #\* into-string))))
	       (render-symbol (sym)
		 (separate into-string)
		 (let ((rendering (display-string-for-lisp-expression sym)))
		   (let ((colon (position #\: rendering)))
		     (cond (colon
			    (portion rendering (1+ colon))
			    (when (> colon 0)
			      (separate package-string)
			      (string-nconc-portion package-string rendering 0 colon)))
			   (T (portion rendering)))))))
	(let ((name topic))
	  (etypecase name
	    (symbol (render-symbol name))
	    (cons
	      (cond ((eql (first name) 'flavor:method)
		     (destructuring-bind (ignore message flavor &rest stuff) name
		       (render-symbol message)
		       (render-symbol flavor)
		       (when stuff
			 (separate into-string)
			 (with-output-to-string (stream into-string)
			   (dolist (ick stuff)
			     (princ " " stream)
			     (princ ick stream))))))
		    (T (with-output-to-string (stream into-string)
			 (let ((first T))
			   (dolist (ick name)
			     (unless first
			       (princ " " stream)
			       (setq first nil))
			     (princ ick stream)))))))
	    (phony-function-spec
	      (error "Can't hack phony function specs ~s" name))))
	(when (> (length package-string) 0)
	  (separate into-string)
	  (string-nconc-portion into-string package-string))
	(copy-string into-string)))))


(defun STRING-INITIAL-UPCASE (string &optional (from '0) (to (string-length string)))
  (loop with delims = '(#\space #\-)
	for delim-pos = from then (string-search-set delims string :start after-delim :end to)
	while delim-pos
	for after-delim = (string-search-not-set delims string :start delim-pos :end to)
	while after-delim
	do (setf (aref string after-delim) (char-upcase (aref string after-delim))))
  string)

;;;Wow.  Does this really work when several delimiters appear in a row?  
;;;e.g. (string-initial-capitalize "user-friendly computer")
;;; This appears to have no callers. 5/5/87 --doughty
(defun STRING-INITIAL-CAPITALIZE (string &optional (word-delimiter-list '(#\space #\-)) (from '0) (to nil))
  (setq string (string-trim '(#\SPACE #\LF #\CR #\TAB #\FF) (string-downcase string)))
  (loop for delim in word-delimiter-list
	do
	(setf (aref string from) (char-upcase (aref string from)))	;first one always
	(loop for pos in (string-search-char-all delim string nil from to)
	      do (incf pos)
	      for ch = (char-upcase (aref string pos))
	      do (setf (aref string pos) ch)))
  string)

;;;OK.  this is needed for cases where you need to some kind of significant processing on
;;;the basis of a flag character in a string.  (Take @ as a random example...)
;;;This returns a list of the character positions of char in the string specified.
;;;This function is NOT case-sensitive ordinarily, although you can specify it to be so.
(defun STRING-SEARCH-CHAR-ALL (char string &optional (case nil) (from '0) (to nil))
  (let ((cheq (if case #'char= #'char-equal)))	;pick which function to use based on case
    (loop for i from from below (or to (length string))
	  for ch = (aref string i)
	  when (funcall cheq ch char)
	  collect i)))

;;;Looks at a string and finds the first occurrence of an UNquoted use of a character
;;; that gets quoted with the usual quoting conventions.  This is being defined here
;;; for Sage so examples are in its terms.
;;;A case to handle: (string-search-flag-char #\@ "foo @@ bar @foo") should return 11
(defun STRING-SEARCH-FLAG-CHAR (char string &optional (from 0) (to (string-length string)))
  (let (flag-pos)
    (loop while (< from to)
	  for pos = (string-search-char char string :start from)
	  while pos
	  do
	  (multiple-value-setq (flag-pos from)
	    (flag-char-p char string pos))
	  (when flag-pos (return flag-pos)))))

;;;Determines whether the occurrence of char in the string at index is an unquoted use
;;;of the character.  So @ is yes, @@ is no, @@@ is yes and so on.
;;;It returns two values:
;;;(1) index of unquoted use or nil if either quoted use or none at all
;;;(2) the index of the last string position examined in the course of all this 
(defun FLAG-CHAR-P (char string index)
  (when (char-equal char (aref string index))	;of course, the char has to be there first
    (let* ((nonflag (or (string-search-not-char char string :start index) ;first nonflag spot
			(string-length string)))
	   (diff (rem (- nonflag index) 2)))	;number of flag chars following index
      (values (unless (zerop diff) (1- nonflag)) nonflag))))

;;;Returns t when applying matching-function to word and successive tokens within spec
;;;succeeds at least once.  Actually it returns t on first success.
;;;match-basis is {keyword-tokens tokens} depending on which is being matched
(defun CONTAINING-WORD-MATCH (word spec matching-function match-basis
			      &optional (open *word-break*) (close *word-break*)
			      open-keep close-keep)
  (let ((token-list
	  (or (typecase spec
		(symbol (or (tokens-for-match-basis spec match-basis)
			     (tokenize (format nil "~A" spec)
				       ':opening-delims open ':trailing-delims close
				       ':trailing-keep close-keep ':open-or-keep open-keep)))
		((or cons phony-function-spec)
		 (tokens-for-match-basis spec match-basis))	;for (:method ...
		(otherwise			;strings and any random untokenized things
		  (tokenize (if (stringp spec)	;---stopgap really, not meaningful for keywrds
				spec
				(format nil "~A" spec))
			    ':opening-delims open ':trailing-delims close
			    ':open-or-keep open-keep ':trailing-keep close-keep))))))
    (loop for token in token-list
	  thereis (funcall matching-function word token))))

(defun TOKENS-FOR-MATCH-BASIS (spec match-basis)
  (let ((proto (get-sage-property spec nil match-basis)))
    (cond ((eq match-basis 'tokens) proto)	;name tokens are unique
	  (t (loop for (nil token-list) on proto by #'cddr
		   nconc (loop for sublist in token-list append sublist))))))

(defun INITIAL-SUBSTRING-MATCH (key string)
  (and string
       (let ((len (length key)))
	 (unless (= len 0)
	   (sys:%string-equal key 0 string 0 len)))))

#||Not called -- RLB 17Dec84
;;; returns T if string is an initial substring of line
(defun STRING-INITIAL-SUBSTRING-MATCH (line string)
  (let ((length (string-length string)))
    (if ( (string-length line) length)
	(string-equal line string 0 0 length length))))
||#

(defmacro RESET-TOKENIZER-STATE (ch)
  `(progn
     (cond ((member ,ch trailing-keep :test #'char-equal) ':in-delim)
	   ((member ,ch trailing-delims :test #'char-equal) ':in-delim)
	   ((member ,ch open-or-keep :test #'char-equal) ':maybe-in-word)
	   ((member ,ch opening-delims :test #'char-equal) ':in-delim)
	   ((member ,ch trailing-can-delimit-null-token :test #'char-equal) ':in-null-thing)
	   (t ':in-word))))

(defmacro TOKENIZE-LOG-RESULT (return-style limit)
  `(progn
     (ecase ,return-style
       (:string (push (substring string first-ch ,limit) token-list))
       (:index (push (list first-ch ,limit) token-list)))))

;;;If I wanted to use the zwei approach to abstractions for delimiters, I could try it.
;;;You have to bind *mode-word-syntax-table* to something.  make-sparse-syntax-table
;;;makes a syntax table.  Then you can use zwei:word-syntax etc for classifying chars.
;;;The opening-delims arg specifies the chars that are delimiters before a word;
;;;trailing-delims specifies the chars that delimit the end of a word
;;;All of the delimiters are tossed out, unless they happen to be in the open-or-keep or
;;;trailing-keep list.  trailing-keep is the list of trailing delims that belong as part of
;;;the word.  For example to parse sys:foo as two words, you would make : a trailing delim.
;;;open-or-keep is trickier.  This is a list of things that are usually open delims (and hence
;;;not part of the word) but if they are encountered "stand-alone", they are words.
;;;This returns a list of word strings [reverse order]
;;;by default or with :return-style :index, returns list of indexes into the string.
;;;open-or-keep and trailing-keep can either be subsets of the main delims or disjoint.
;;;Colon is a disaster:  It wants to be kept delimiter, or standalone, or leading in a
;;;word.  Unfortunately no char can be both open-or-keep and trailing-keep.
(defun TOKENIZE (string &key (opening-delims *word-break*) (trailing-delims *word-break*)
		 (return-style :string) open-or-keep trailing-keep
		 trailing-can-delimit-null-token)
  (when string
    (check-type string (satisfies stringp) "a string")
    (and open-or-keep trailing-keep		;check the meaningfulness of the args
	 (loop for ch in open-or-keep
	       when (member ch trailing-keep :test #'char-equal)
	       do
	       (format *error-output*
		       "~&Potential for ambiguity due to overlapping open and trailing delimiters to keep:~%~S and ~S for parse string ~A"
		       open-or-keep trailing-keep string)))
    (loop with current-state = ':in-delim
	  for i from 0 below (string-length string)
	  for ch = (aref string i)
	  with first-ch = 0
	  with token-list
	  do
;	(format t "~%Before state: ~S, Ch: ~C" current-state ch)
	  ;;Theory of the state changing.  A word in progress has to be ended by a trailing
	  ;;delimiter.  An opening delimiter without an intervening trailing delimiter is
	  ;;simply not treated as a delimiter.
	  (case current-state
	    (:in-word				;maybe end of word detected
	     (cond ((member ch trailing-keep :test #'char-equal)
		    (setq current-state ':maybe-in-delim))
		   ((member ch trailing-delims :test #'char-equal)
		    (tokenize-log-result return-style i)
		    (setq current-state ':in-delim))))
	    (:maybe-in-word			;so open punctuation can be standalone word
	     (cond ((member ch open-or-keep :test #'char-equal))	;no change in state
		   ((member ch trailing-keep :test #'char-equal)	;this might be a word already
		    (setq current-state ':maybe-in-delim))	;continue looking for end
		   ((member ch trailing-delims :test #'char-equal)	;jig is up, this is a word
						; consisting of delim
		    (tokenize-log-result return-style i)
		    (setq current-state ':in-delim))
		   (t (setq current-state ':in-word	;alphabetic, so word starts here
			    first-ch i))))
	    (:in-delim				;maybe beginning of word detected
	     (cond ((member ch open-or-keep :test #'char-equal)	;order matters
		    (setq first-ch i current-state ':maybe-in-word))
		   ((member ch trailing-can-delimit-null-token :test #'char-equal)
		    (setq first-ch i current-state ':in-null-thing))
		   ((member ch trailing-keep :test #'char-equal)	;because in delims,
						; this char not trailing now
		    (setq first-ch i current-state ':in-word))
		   ((or (member ch opening-delims :test #'char-equal)
			(member ch trailing-delims :test #'char-equal)))	;no-ops here
		   (t (setq first-ch i current-state ':in-word))))	;unclassified chars
	    (:maybe-in-delim
	     (cond ((member ch trailing-keep :test #'char-equal))	;no change in state
		   ((member ch trailing-delims :test #'char-equal) (tokenize-log-result return-style i)
		    (setq current-state ':in-delim))
		   ((member ch open-or-keep :test #'char-equal) (tokenize-log-result return-style i)
		    (setq first-ch i
			  current-state ':maybe-in-word))
		   ((member ch opening-delims :test #'char-equal) (tokenize-log-result return-style i)
		    (setq first-ch i
			  current-state ':in-word))
		   (t (tokenize-log-result return-style i)
		      (setq first-ch i current-state ':in-word))))
	    (:in-null-thing
	     (tokenize-log-result return-style i)
	     (setq first-ch i
		   current-state (reset-tokenizer-state ch)))
	    (otherwise (format t "~%Bad value for current-state: ~S" current-state)))
;	(format t "~%After state: ~S, Result: ~S" current-state token-list)
	  finally
	  (if (member current-state '(:in-word :maybe-in-word :maybe-in-delim))
	      (tokenize-log-result return-style (string-length string)))
	  (return token-list))))

;;;Returns t if strings are equal.  If either of the strings contains a Scribe environment,
;;;it compares the strings without the environment framework.
(defun FILTERED-STRING-EQUAL (string1 string2 filter-function)
  (string-equal (funcall filter-function string1)
		(funcall filter-function string2)))

;;;Returns t if string1 is alphabetically less than string2.  If either of the strings
;;;contains a Scribe environment, it compares the strings without the environment framework.
(defun FILTERED-STRING-LESSP (string1 string2 filter-function)
  (string-lessp (funcall filter-function string1)
		(funcall filter-function string2)))

;;;This is because of how mem works.  I refuse to cons the substring in order to do
;;;(mem #'string-equal (substring ...) list) etc etc.
;;;So this packages the info needed to do substring extract into a list which is the first arg
;;;i.e. call it like so (s-s-e '("foobar" 0 3) "foo")) ==> t
(defun SPECIAL-STRING-EQUAL (string-from-to string2)
  (let ((string1 (first string-from-to))
	(from (second string-from-to))
	(to (third string-from-to)))
;    (format t "~%Considering status of ~A relative to ~A"
;      (substring string1 from to) string2)
    (string-equal string1 string2 :start1 from :start2 0 :end1 to)))

(defun SPECIAL-STRING= (string-from-to string2)
  (let ((string1 (first string-from-to))
	(from (second string-from-to))
	(to (third string-from-to)))
;    (format t "~%Considering status of ~A relative to ~A"
;      (substring string1 from to) string2)
    (string= string1 string2 :start1 from :start2 0 :end1 to)))

;;;Takes a string and replaces some substring of it with another string
;;;This worries about consing, so uses substring as sparingly as possible.
;;;If substring is the null string, no replacement gets done
;;;Replacement can be the null string.
;;;Copies string only if necessary, changes original if possible.
;;; Will return a fat string if either string or replacement is fat.
(defun STRING-REPLACE-SUBSTRING (string substring replacement &optional (times ':all) (from 0) (to (string-length string)))
  (unless (stringp substring) (setq substring (string substring)))	;ensure type
  (unless (stringp replacement) (setq replacement (string replacement)))
  (let* ((old-len (string-length substring))
	 (new-len (string-length replacement))
	 (same-length (= new-len old-len))	;nil for no length adjusting
	 (all (eq times ':all)))
    (unless (= old-len 0)			;substring is null, stop now
      (flet ((doit (temp)
	       (loop with start = from
		     for count = 0 then (1+ count)
		     for pos = (string-search substring string :start2 start :end2 to)
		     for first-time = t then nil
		     while (and pos (if all t (< count times)))
		     do
		 (if (and first-time ( from 0) (not same-length))	;if needed to copy first part
		     (string-nconc-portion temp string 0 from))
		 (if same-length
		     (loop for i from 0 below new-len
			   do
		       (setf (aref string pos) (aref replacement i))
		       (incf pos)
			   finally (setq start pos))
		     (progn			;progn just for clarity
		       (string-nconc-portion temp string start pos)
		       (string-nconc temp replacement)
		       (setq start (+ pos old-len))))
		     finally
		       (unless same-length (string-nconc-portion temp string start
								 (string-length string))))
	       (unless same-length
		 (setq string (copy-string temp)))))
	(if (or (string-fat-p string) (string-fat-p replacement))
	    (using-resource (temp fat-string-temp) (doit temp))
	    (using-resource (temp string-temp) (doit temp))))))
  string)

(defun STRING-TRIM-INTO-STRING (to-string char-set from-string
				&optional (from-begin 0) from-end)
  (declare (values to-string to-string-end))
  (let ((begin (string-search-not-set char-set from-string :start from-begin :end from-end)))
    (if begin
	(let ((end (string-search-not-set char-set from-string :start from-begin :end from-end  :from-end t)))
	  (vector-push-portion-extend to-string from-string begin (1+ end)))
	(values to-string (fill-pointer to-string)))))

;;;takes a string and returns two values, the substring up to but not including a delimiter
;;;char specified, and the rest of the string after but not including the delimiter
(defun GET-DELIMITED-STRING (delimiters str &optional (from 0) to)
  (si:coerce-to-list delimiters
    (when (null to) (setq to (string-length str)))
    (cond ((= 0 (string-length str))		;if empty already
	   (values (copy-string "")
		   (copy-string "")))
	  ((= from to)
	   (values (substring str from to)
		   (substring str from to)))
	  (T (let ((where (string-search-set delimiters str :start from :end to)))
		   (if (null where)		;no more delimiters, just remainder is word
		       (values (substring str from to)
			       (copy-string ""))
		       (values (substring str from where)
			       (substring str (1+ where) to))))))))

(defun SLASHIFY-STRING (string)
  (declare (values new-string length-diff))
  (using-resource (temp string-temp)
    (let ((string string)
	  (string-length (string-length string)))
      (declare (sys:array-register string))
      (loop with slash = (si:pttbl-slash *readtable*)
	    with open-quote = (si:pttbl-open-quote-string *readtable*)
	    with close-quote = (si:pttbl-close-quote-string *readtable*)
	    ;; not used -- see commented-out stuff below
;	    with open-paren = (si:pttbl-open-paren readtable)
	    for i from 0 below string-length
	    for prev-char = char
	    for char = (aref string i)
	    when (or (and (si:slashify-within-string-p char)
			  ;; Don't double slashes in #\ or #/, or double quotes
			  (not (or (and prev-char (char-equal prev-char #\#)
					(char-equal char slash))
				   (char-equal char open-quote)
				   (char-equal char close-quote))))
		     ;; The Lisp printer puts a slash in front of an open paren after
	             ;; a newline.  Don't do it here.
;		     (and prev-char (char-equal prev-char #\return)
;			  (char-equal char open-paren))
		     )
	      do (vector-push-extend slash temp)
	    do (vector-push-extend char temp))
      (if (string-equal string temp)
	  (values string 0)
	  (values (string-append temp) (- (string-length temp) string-length))))))

(defun STRING-REPLACE-PORTION (string replacement-string &optional (idx1 0) (idx2 0) lim1
			       lim2)
  (setq string (string string) replacement-string (string replacement-string))
  (unless lim1 (setq lim1 (string-length string)))
  (unless lim2 (setq lim2 (string-length replacement-string)))
  (let ((replacement-length (- lim2 idx2))
	(old-length (- lim1 idx1))
	(new-limit lim1))
    (cond ((= replacement-length old-length)
	   (copy-array-portion replacement-string idx2 lim2 string idx1 lim1))
	  (t (setq new-limit (+ idx1 replacement-length))
	     (let* ((old-string-length (string-length string))
		    (new-string-length
		      (+ replacement-length (- old-string-length old-length))))
	       (cond ((< replacement-length old-length)
		      (when (> old-string-length lim1)
			(copy-array-portion string lim1 old-string-length
					    string new-limit new-string-length))
		      (unless (array-has-leader-p string)
			(adjust-array string new-string-length)))
		     (t
		      (when (> new-string-length (array-total-size string))
			(adjust-array string new-string-length))
		      (when (> old-string-length lim1)
			(loop for new-i downfrom (1- new-string-length)
			      for old-i from (1- old-string-length) downto lim1
			      do (setf (aref string new-i) (aref string old-i))))))
	       (copy-array-portion replacement-string idx2 lim2 string idx1 new-limit)
	       (when (array-has-leader-p string)
		 (setf (fill-pointer string) new-string-length)))))
    new-limit))

(defun DOUBLE-CHARS-IN-STRING (char-set string &optional (from 0) to)
  (unless to (setq to (string-length string)))
  (using-resource (temp1 string-temp)
    (using-resource (temp2 string-temp)
      (string-nconc temp1 string)
      (loop with i = from
	    with found-one = nil
	    for char-pos = (string-search-set char-set temp1 :start i :end to)
	    while char-pos
	    for char = (aref temp1 char-pos)
	    do (string-nconc temp2 char char)
	       (setq i (string-replace-portion temp1 temp2 char-pos 0 (1+ char-pos)))
	       (setf (fill-pointer temp2) 0)
	       (incf to)
	       (setq found-one t)
	    finally (return (if found-one
				(string-append temp1)
				string))))))

(defsubst THIN-CHARACTER-IF-NECESSARY (char)
  (if (not (char-fat-p char))
      char
      (make-character-thin char)))

(defun MAKE-CHARACTER-THIN (char)
  (let ((thin-char (code-char (char-code char))))
    (if (not (char-fat-p thin-char))
	thin-char
	(error "The fat character ~S could not be made thin because it is not in~@
                     the standard character set." char))))

;;;Checks the string to see what delimiter pairs would be safe.
;;;It returns two values, the first open delim that would be OK, nil if none, and its close.
;;;For the *delims* case, it returns 0 (can mean to use long form) if none OK.
;;;---Not very general though when your string has lots of various close delims.
(defun CHOOSE-SAFE-DELIM (string &optional (delims *delims*) (from 0) to)
  (loop for (first . last) in delims
	when (null (string-search-char last string :start from :end to))
	  return (values first last)))

(format:defformat FORMAT:{} (:one-arg) (string ignore)
  (multiple-value-bind (open close)
      (choose-safe-delim string)
    (write-char open format:*format-output*)
    (princ string format:*format-output*)
    (write-char close format:*format-output*)))

;;;Returns t when its arg is a string that consists only of whitespace characters, nil owise.
(defun JUST-WHITE-SPACE (string)
   (when (stringp string)
     (not (string-search-not-set *white-space* string))))

(defun NON-WHITE-CONTENTS-LIST (contents-list)
  (and contents-list
       (notevery (named-lambda notevery (x)
		   (let ((string
			   (typecase x
			     (string x)
			     (sage-text-structure
			       (zwei:string-interval
				 (sage-text-structure-interval x))))))
		     (and string (every #'char-white-space-p string))))
		 contents-list)
       contents-list))

(defun MAKE-NON-WHITE-FIELD-ALIST (&rest name-thing-pairs)
  (loop for (name thing) on name-thing-pairs by #'cddr
	collect (list name (non-white-contents-list thing))))

(defun 1trim-whitespace-from-ends-of-contents-list0 (contents-list)
  (let ((result-cl contents-list)
	(cl-copied nil))
    ;; trim whitespace from the left
    (loop do
      (when (null result-cl)
	(return nil))
      (let ((front (first result-cl)))
	(multiple-value-bind (result how-done)
	    (trim-whitespace-from-end-of-directive front :left)
	  (ecase how-done
	    (:all-gone (pop result-cl))
	    (:unchanged (loop-finish))
	    (:trimmed
	      (setq result-cl (cons result (rest result-cl)))
	      (loop-finish))))))
    ;; trim whitespace from the right
    (loop do
      (when (null result-cl)
	(return nil))
      (let ((back (first (last result-cl))))
	(multiple-value-bind (result how-done)
	    (trim-whitespace-from-end-of-directive back :right)
	  (ecase how-done
	    (:all-gone
	      (setq result-cl
		    (if cl-copied
			(nbutlast result-cl)
			(progn (setq cl-copied T)
			       (nbutlast (copy-list result-cl))))))
	    (:unchanged (loop-finish))
	    (:trimmed
	      (unless cl-copied
		(setq cl-copied T)
		(setq result-cl (copy-list result-cl)))
	      (setf (first (last result-cl)) result))))))
    result-cl))

(defgeneric 1trim-whitespace-from-end-of-directive0 (sage-directive which-end)
  (:function
    (ecase which-end
      (:left
	(if (stringp sage-directive)
	    (if (and (> (length sage-directive) 0)
		     (char-white-space-p (char sage-directive 0)))
		(let ((result (string-left-trim *white-space* sage-directive)))
		  (values result
			  (if (zerop (length result))
			      :all-gone :trimmed)))
		(values sage-directive :unchanged))
	    (funcall (flavor:generic trim-whitespace-from-end-of-directive)
		     sage-directive which-end)))
      (:right
	(if (stringp sage-directive)
	    (let ((len (length sage-directive)))
	      (if (and (> len 0)
		     (char-white-space-p (char sage-directive (1- len))))
		  (let ((result (string-right-trim *white-space* sage-directive)))
		    (values result
			    (if (zerop (length result))
				:all-gone :trimmed)))
		  (values sage-directive :unchanged)))
	    (funcall (flavor:generic trim-whitespace-from-end-of-directive)
		     sage-directive which-end)))))
  (:method (sage-directive :default)
   (ignore which-end)
   (values self :unchanged))
  (:method (sage-text-structure)
   (ecase which-end
     (:left
       (if (char-white-space-p (zwei:bp-char (zwei:interval-first-bp interval)))
	   (let ((zwei:*interval* interval))
	     (let ((start-bp (zwei:forward-over *white-space-list*
						(zwei:interval-first-bp interval))))
	       (if (zwei:bp-= start-bp (zwei:interval-last-bp interval))
		   (values nil :all-gone)
		   (let ((new-directive (make-instance 'sage-text-structure)))
		     (setf (directive-superior new-directive)
			   (directive-superior self))
		     (let ((new-int (sage-text-structure-interval new-directive)))
		       (setf (zwei:interval-first-bp new-int) start-bp)
		       (setf (zwei:interval-last-bp new-int)
			     (zwei:interval-last-bp interval)))
		     (values new-directive :trimmed)))))
	   (values self :unchanged)))
     (:right
       (if (char-white-space-p (zwei:bp-char-before (zwei:interval-last-bp interval)))
	   (let ((zwei:*interval* interval))
	     (let ((end-bp (zwei:backward-over *white-space-list*
					       (zwei:interval-last-bp interval))))
	       (if (zwei:bp-= end-bp (zwei:interval-first-bp interval))
		   (values nil :all-gone)
		   (let ((new-directive (make-instance 'sage-text-structure)))
		     (setf (directive-superior new-directive)
			   (directive-superior self))
		     (let ((new-int (sage-text-structure-interval new-directive)))
		       (setf (zwei:interval-first-bp new-int)
			     (zwei:interval-first-bp interval))
		       (setf (zwei:interval-last-bp new-int) end-bp))
		     (values new-directive :trimmed)))))
	   (values self :unchanged))))))

;;; Parses a string into a list that can become the car of the parameter for @L.
;;; The idea is to use read-from-string and return valid Lisp expressions where
;;; possible.  It does condition-binding for some reader errors to proceed with
;;; phony function specs, so you can get a list with some Lisp expressions and
;;; some phony function specs.  If it encounters a read error that it can't
;;; proceed from, it just punts and creates a phony function spec for the
;;; rest of the string.  Always returns a list.
(defun parse-L-string (string)
  (let* ((trimmed-string (string-trim *white-space* string))
	 (start 0)
	 (end (string-length trimmed-string))
	 (thing-read)
	 (result))
    (condition-case ()
	 (loop
	   while (< start end)
	   do (flet ((package-locked-handler (err)
		       (when (dbg:proceed-type-p err :replacement-symbol)
			 (sys:proceed
			   err :replacement-symbol
			   (phony-function-spec-intern
			     (with-output-to-string (str)
			       (print-phony-symbol
				 (send err :symbol) str (send err :package)))))))
		     (external-symbol-handler (err)
		       ;; Dwim: use internal symbol if possible
		       (condition-case ()
			    (intern (send err :string) (send err :package))
			  (error ())
			  (:no-error (when (dbg:proceed-type-p err :internal)
				       (sys:proceed err :internal))))))
		(condition-bind
		  (((sys:read-package-locked
		      sys:read-name-conflict-in-export-from-locked-package)
		    #'package-locked-handler)
		   (sys:read-external-symbol-not-found #'external-symbol-handler))
		  (multiple-value-setq (thing-read start)
		    (read-from-string trimmed-string t nil :start start :end end))))
	      (push thing-read result))
       (sys:read-error (push (phony-function-spec-intern
			       (substring trimmed-string start end))
			     result)))
    (let ((type-to-sab-writing-function-alist
	    ;; Avoid a compiler warning if this file gets compiled before sab-file
	    (locally (declare (special *type-to-sab-writing-function-alist*))
	      *type-to-sab-writing-function-alist*)))
      (labels ((ensure-sab-validity (list)
		 (mapl (lambda (tails)
			 (let ((thing (first tails)))
			   (if (consp thing)
			       (ensure-sab-validity thing)
			       (unless (validate-for-sab thing)
				 (setf (first tails)
				       (phony-function-spec-intern
					 (prin1-to-string thing)))))))
		       list))
	       (validate-for-sab (thing)
		 (loop for (type) in type-to-sab-writing-function-alist
		       thereis (typep thing type))))
	(ensure-sab-validity (nreverse result))))))

;;; Function that converts between canonical and context-dependent representations
;;; of @L and phony function spec strings.
;;; Usually used in one of two situations:
;;; (1)  It gets a string, assumed suitable as input to READ-FROM-STRING, and has
;;; to canonicalize it.  In the canonical form, symbols always have package prefixes
;;; and never have slashified pnames (except that they do have vertical bars when
;;; needed).  This is like a combination of reading and interning.
;;; (2)  It gets a string in canonical form and has to convert it to a representation
;;; suitable for the current context (with or without package prefix, slashified or
;;; not).  This is like printing.
;;; The reason this deals entirely in strings, instead of other objects, is that it
;;; has to handle cases that would be impossible in Lisp.  For example, it has to
;;; allow bogus symbols in locked packages.
;;; CANONICALIZE-P:  T means we are given a string suitable for reading and are to
;;; convert it to canonical form.  NIL means we are given a canonical string and
;;; are to convert it to a form appropriate to the current context (package and syntax).
;;; SLASHIFY-P is meaningful only when CANONICALIZE-P is NIL.  T means, roughly, to
;;; use PRIN1.  NIL means to use PRINC.
;;; At present this tries to do something intelligent only for symbols.  It sets
;;; up handlers for read errors.  It then uses READ-FROM-STRING to read through
;;; the string, moving over list delimiters in an attempt to get at atoms.  If
;;; it reads a symbol it performs the appropriate conversion on its printed
;;; representation in the string.  If it gets a package-related error, it tries
;;; to deal with it as best it can, pretending that the symbol is real when
;;; possible.
;;; It always returns a new string.
;;; Some known bugs and limitations:
;;; -- Unnecessary slashes inside symbol PR's are kept in the canonical version.
;;; -- Slashes inside strings probably don't work right.
;;; -- If a package prefix appears in front of a list, the symbols inside the
;;;    list get the wrong package.  So "nsage::(do-this do-that)" doesn't work.
;;; -- It doesn't try to canonicalize numbers, so using @L with a nonstandard
;;;    base won't work.
(defun CONVERT-PHONY-FUNCTION-SPEC-STRING (string &optional canonicalize-p (slashify-p t))
  (using-resource (result-string string-temp)
    (let ((index 0)
	  (to-pkg *package*))
      ;; Set up error handlers.  These are bound by CONDITION-BIND below.
      ;; They can side-effect the result string and change the value of
      ;; INDEX, which is used as the beginning point for the next call
      ;; to READ-FROM-STRING.  They have to throw to the tag ERROR-HANDLED.
      (flet ((package-handler (err)
	       ;; Handles most package-related errors, like attempts to intern
	       ;; symbols in locked packages.  Tries to pretend the symbols are real.
	       (declare (sys:downward-function))
	       (setq index
		     (convert-phony-symbol-in-string
		       result-string
		       (typecase err
			 (sys:read-external-symbol-not-found (send err :string))
			 (otherwise (symbol-name (send err :symbol))))
		       (send err :package) index (send err :location)
		       canonicalize-p slashify-p slashify-p to-pkg
		       (typep err 'sys:read-external-symbol-not-found)))
	       (throw 'error-handled nil))
	     (other-handler (err)
	       ;; Handles other read errors.
	       (declare (sys:downward-function))
	       (setq index (send err :location))
	       (throw 'error-handled nil)))
	(labels ((package-not-found-handler (err)
		   ;; Handles package-not-found errors.
		   ;; Tries to pretend the package is real.
		   (declare (sys:downward-function))
		   (let* ((pkg-name (send err :name))
			  (pkg-string (slashify-string pkg-name))
			  (err-loc (min (send err :location) (string-length result-string)))
			  (pkg-first-char-pos
			    (string-search pkg-string result-string :start2 index :end2
					   err-loc :from-end t))
			  (pkg-end
			    (and pkg-first-char-pos
				 (+ pkg-first-char-pos (string-length pkg-string))))
			  (pkg-limit
			    (and pkg-end
				 ;; First convert the package name itself
				 (convert-phony-symbol-in-string
				   result-string pkg-name si:pkg-user-package
				   pkg-first-char-pos pkg-end nil
				   (unless canonicalize-p slashify-p) nil)))
			  (result-string-length (string-length result-string)))
		     ;; Find the end of the bogus package prefix
		     (when (and pkg-limit (< pkg-limit result-string-length))
		       (let* ((int-prefix (si:pttbl-internal-package-prefix *readtable*))
			      (int-length (string-length int-prefix))
			      (int-limit (+ pkg-limit int-length)))
			 (if (and ( int-limit result-string-length)
				  (string-equal int-prefix result-string :start1 0
						:start2 pkg-limit :end1 int-length
						:end2 int-limit))
			     (setq pkg-limit int-limit)
			     (when (char-equal (si:pttbl-package-char *readtable*)
					       (aref result-string pkg-limit))
			       (incf pkg-limit)))))
		     (cond ((null pkg-limit) (setq index err-loc))
			   (t 
			    ;; Try to read and convert what follows the bogus package
			    ;; prefix
			    (setq index pkg-limit)
			    (when (< index result-string-length)
			      (condition-bind
				(((sys:read-package-locked
				    sys:read-name-conflict-in-export-from-locked-package
				    sys:read-external-symbol-not-found)
				  #'package-handler)
				 (sys:read-package-not-found #'package-not-found-handler)
				 (sys:read-error #'other-handler))
				(multiple-value-bind (exp limit)
				    (let ((*package* si:pkg-user-package))
				      (read-from-string result-string t nil
							:start index))
				  (setq index
					(if (symbolp exp)
					    (convert-phony-symbol-in-string
					      result-string (symbol-name exp)
					      (symbol-package exp) index limit
					      nil (unless canonicalize-p slashify-p) nil)
					    limit))))))))
		   (throw 'error-handled nil)))
	  ;; Start by slashifying the string if it's already canonical
	  (string-nconc result-string (if canonicalize-p string (slashify-string string)))
	  ;; Proceed through the string calling READ-FROM-STRING
	  (loop for result-string-length = (string-length result-string)
		do ;; First throw away parentheses -- try to get at an atom
	    (loop for i from index below result-string-length
		  for char = (aref result-string i)
		  while (or (char-equal char #\()
			    (char-equal char #\))
			    (char-white-space-p char))
		  do (incf index))
	    (if ( index result-string-length)
		(loop-finish)
		(catch 'error-handled
		  (condition-bind
		    (((sys:read-package-locked
			sys:read-name-conflict-in-export-from-locked-package
			sys:read-external-symbol-not-found)
		      #'package-handler)
		     (sys:read-package-not-found #'package-not-found-handler)
		     (sys:read-error #'other-handler))
		    (multiple-value-bind (exp limit)
			(read-from-string result-string t nil :start index)
		      (setq index
			    (typecase exp
			      (symbol
				(convert-phony-symbol-in-string
				  result-string (symbol-name exp) (symbol-package exp)
				  index limit canonicalize-p slashify-p))
			      (list
				(let ((delim-pos
					(string-search-set
					  '(#\( #\' #\`) result-string :start index
					  :end limit)))
				  (if delim-pos (1+ delim-pos) limit)))
			      (otherwise limit)))))))))))
    (string-append result-string)))

;;; This gets a string, usually the pname of a symbol, and a containing string
;;; that ought to have the pname inside somewhere.  The function also gets
;;; the symbol's package.  Optional args include starting and ending limits
;;; in the containing string, and some parameters that control what it does.
;;; Its contract is to find the printed representation of the symbol in the
;;; containing string and convert that (IN PLACE) to something else.  Usually
;;; you have one of two situations:
;;; (1)  The containing string is something that is being read, and you want to
;;; convert the printed representation of the symbol to a canonical form,
;;; always with package prefix and without slashification.
;;; (2)  The containing string is already in canonical form, and you want
;;; to convert the printed representation of the symbol to something
;;; appropriate to the current context (with or without package prefix,
;;; slashification, etc.).  Note that the containing string can't really
;;; be in canonical form:  the caller must have slashified it first.
;;; The symbol doesn't have to be real.  The whole point is to handle things
;;; that the Lisp reader and printer can't deal with.
;;; This won't work with some legitimate but unusual cases.  It can deal
;;; with some symbols whose PR's have vertical bars or leading shashes.
;;; Thus, :|3600| and :/3600 both work.  It probably doesn't work with
;;; weird combinations of vertical bars and slashes.
;;; Returns the index of the next character in the containing string
;;; following the symbol's new PR.
(defun CONVERT-PHONY-SYMBOL-IN-STRING (containing-string sym-string sym-pkg
				       &optional (start-index 0) limit canonicalize-p
				       (slashify-p t) (prefix-p slashify-p) (to-pkg *package*)
				       force-single-colon)
  (declare (values next-index))
  ;; When canonicalizing, don't slashify, but always print package prefix
  (when canonicalize-p (setq slashify-p nil to-pkg nil prefix-p t))
  (let ((containing-string-length (string-length containing-string)))
    (setq limit (if limit (min limit containing-string-length) containing-string-length))
    ;; Find limits of symbol pname in the containing string.
    ;; Start from the end so that in "NSAGE::SAGE" you get the pname, not the package.
    (let* ((search-string (slashify-string sym-string))
	   (symbol-first-char-pos
	     (string-search search-string containing-string :start2 start-index :end2 limit :from-end t))
	   (symbol-limit (and symbol-first-char-pos
			      (+ symbol-first-char-pos (string-length search-string)))))
      (if (null symbol-first-char-pos)
	  (setq symbol-limit limit)
	  (let (colon-pos pkg-first-char-pos unint-p)
	    (when (> symbol-first-char-pos start-index)
	      (let ((prefix-last-pos (1- symbol-first-char-pos)))
		(cond ((and (> limit symbol-limit)
			    (char-equal (si:pttbl-open-quote-symbol *readtable*)
					(aref containing-string prefix-last-pos))
			    (char-equal (si:pttbl-close-quote-symbol *readtable*)
					(aref containing-string symbol-limit)))
		       ;; Symbol pname is surrounded by vertical bars.  Adjust
		       ;; limits, and slashify if canonicalizing (to get vertical
		       ;; bars in the canonical string).
		       (setq symbol-first-char-pos prefix-last-pos
			     symbol-limit (1+ symbol-limit)
			     prefix-last-pos (1- prefix-last-pos))
		       (when canonicalize-p (setq slashify-p t)))
		      ((char-equal (si:pttbl-slash *readtable*)
				   (aref containing-string prefix-last-pos))
		       ;; Symbol pname preceded by a slash.  Adjust limits,
		       ;; and slashify if canonicalizing.
		       (setq symbol-first-char-pos prefix-last-pos
			     prefix-last-pos (1- prefix-last-pos))
		       (when canonicalize-p (setq slashify-p t))))
		(when (> symbol-first-char-pos start-index)
		  ;; There's something in front of the symbol pname.  Find out
		  ;; if it's a package prefix.
		  (let* ((unint-prefix (si:pttbl-uninterned-prefix *readtable*))
			 (unint-length (string-length unint-prefix))
			 (unint-start (- symbol-first-char-pos unint-length)))
		    (if (and ( unint-start start-index)
			     (string-equal unint-prefix containing-string :start1 0
					   :start2 unint-start :end1 unint-length
					   :end1 symbol-first-char-pos))
			;; Uninterned symbol prefix (#:)
			(setq colon-pos unint-start unint-p t)
			(let* ((int-prefix (si:pttbl-internal-package-prefix *readtable*))
			       (int-length (string-length int-prefix))
			       (int-start (- symbol-first-char-pos int-length)))
			  (if (and ( int-start start-index)
				   (string-equal int-prefix containing-string :start1 0
						 :start2 int-start :end1 int-length
						 :end1 symbol-first-char-pos))
			      ;; Internal symbol (::)
			      (setq colon-pos int-start)
			      (let ((prefix-last-pos (1- symbol-first-char-pos)))
				(when (char-equal (si:pttbl-package-char *readtable*)
						  (aref containing-string prefix-last-pos))
				    ;; Colon
				  (setq colon-pos prefix-last-pos))))))))))
	    (setq pkg-first-char-pos
		  (cond ((null colon-pos) symbol-first-char-pos)
			((or unint-p (= colon-pos start-index)) colon-pos)
			(t
			 ;; Find the start of the package name
			 (loop with char-array = *pkg-name-char-array*
			       with length = (length char-array)
			       for i from (1- colon-pos) downto start-index
			       for char-code = (char-code (aref containing-string i))
			       unless (and (< char-code length)
					   (not (null (aref char-array char-code))))
				 return (1+ i)
			       finally (return start-index)))))
	    (using-resource (temp1 string-temp)
	      (with-output-to-string (stream temp1)
		(print-phony-symbol sym-string stream sym-pkg to-pkg slashify-p prefix-p
				    force-single-colon))
	      ;; Replace the appropriate part of the containing string with
	      ;; the printed representation that we want.
	      (setq symbol-limit (string-replace-portion
				   containing-string temp1 pkg-first-char-pos 0
				   symbol-limit)))))
      symbol-limit)))

;;; This is a modified version of SI:PRINT-PNAME-STRING and SI:PKG-SYMBOL-PREFIX.
;;; We go into the guts of the Lisp printer so we can print bogus symbols as
;;; they would appear in Lisp.  We deal with the pname and the package separately,
;;; so we can print any string as if it represented a symbol in any package.
;;; We can also print a "symbol" with a package prefix but without slashification
;;; of the pname, as we need to do when canonicalizing @L and phony function spec
;;; strings.
;;; SYMBOL is usually a string representing the pname.
;;; STREAM is the stream on which to print.
;;; FROM-PKG is a real package, the supposed home package of the symbol.  If NIL
;;;   this is treated as an uninterned symbol.
;;; TO-PKG is the package relative to which we want to print the symbol.  It can
;;;   be NIL, which will always result in a package prefix when PREFIX-P is T.
;;; SLASHIFY-P means to slashify the pname.
;;; PREFIX-P means to print a package prefix unless TO-PKG is the same as the
;;;   FROM-PKG or uses FROM-PKG (same rules as PRIN1).
(defun PRINT-PHONY-SYMBOL (symbol stream from-pkg &optional (to-pkg *package*) (slashify-p t)
			   (prefix-p t) force-single-colon)
  (setq symbol (string symbol))
  (when prefix-p
    (cond (from-pkg
	   (when (or (eq from-pkg sys:pkg-keyword-package)
		     (null to-pkg)
		     (and (neq from-pkg to-pkg)
			  (not (member from-pkg (si:pkg-use-list to-pkg)))
			  (multiple-value-bind (found1 flag1)
			      (find-symbol symbol from-pkg)
			    (not (and flag1
				      (multiple-value-bind (found2 flag2)
					  (find-symbol symbol to-pkg)
					(and flag2 (eq found1 found2))))))))
	     (si:pkg-package-prefix
	       #'(lambda (name ignore flag)
		   ;; Flag is NIL if single-colon (external package prefix) required,
		   ;;           T if double-colon (internal package prefix) required,
		   ;;  or :SYNTAX if triple-colon (syntax prefix) required.
		   (si:print-pname-string name slashify-p stream)
		   (cond ((eq flag :syntax)
			  (dotimes (i 3)
			    (declare (ignore i))
			    (funcall stream :tyo (si:pttbl-package-char *readtable*))))
			 (flag
			   (funcall stream :string-out
				    (si:pttbl-internal-package-prefix *readtable*)))
			 (t
			   (funcall stream :tyo (si:pttbl-package-char *readtable*)))))
	       from-pkg to-pkg t 0
	       (unless force-single-colon
		 (multiple-value-bind (nil flag)
		     (find-symbol symbol from-pkg)
		   (and (eq flag :internal)
			(neq (si:pkg-prefix-intern-function from-pkg) 'intern)))))))
	  (*print-gensym*
	   (funcall stream :string-out (si:pttbl-uninterned-prefix *readtable*)))))
  (si:print-pname-string symbol slashify-p stream))

(defmacro do-delimited-substrings-exact
	  (((string &key (start 0) end)
	    (char-var start-index-var end-index-var))
	   substring-form
	   &body character-clauses
	   &environment env)
  (let ((special-characters (loop for (chars) in character-clauses
				  when (atom chars)
				    collect chars
				  else append chars)))
    (once-only (string &environment env)
      `(let ((,start-index-var ,start)
	     (.end. (or ,end (string-length ,string))))
	 (loop
        (let ((.next-index. ,(if (null (rest special-characters))
				 `(sys:%string-search-exact-char ,(first special-characters)
							   ,string ,start-index-var .end.)
				 `(%string-search-array-set-exact
				    ',(coerce special-characters 'string)
				    #+Franz
				    ',(cons COMPILER:EVAL-AT-LOAD-TIME-MARKER
					    `(coerce ',special-characters 'string))
				    ,string ,start-index-var .end.))))
	  (let ((,end-index-var (or .next-index. .end.)))
	    ,substring-form)
	  (when (null .next-index.)
	    (return nil))
	  (let ((,char-var ,(if (null (rest special-characters))
				(first special-characters)
				`(aref ,string .next-index.))))
	    . ,(if (null (rest character-clauses))
		   (rest (first character-clauses))
		   `((selector ,char-var char=
		      . ,character-clauses))))
	  (setq ,start-index-var (1+ .next-index.))))))))

(defun %string-search-array-set-exact (set string start end)
  (let ((string string)
	(set set)
	(set-length (string-length set)))
    (declare (sys:array-register string set))
    (do* ((i start (1+ i)))
	 (( i end) nil)
      (let ((char (aref string i)))
	(do ((j 0 (1+ j)))
	    (( j set-length) nil)
	  (when (char= char (aref set j))
	    (return-from %string-search-array-set-exact i)))))))

(defun 1contents-list-from-fat-string0 (string &optional (start 0) end)
  (when (null end) (setq end (string-length string)))
  (let ((result-list ()))
    (loop do
      (when ( start end) (loop-finish))
      (multiple-value-bind (start-of-run end-of-run style-of-run)
	  (find-character-style-run string start end)
	(let ((directive 
		(let ((substring (string-thin
				   (substring string start-of-run end-of-run)
				   :remove-bits t :error-if :fat)))
		  (if (eql style-of-run si:*null-style*)
		      substring
		      (let ((envr-name (envr-name-for-character-style style-of-run)))
			(cond ((null envr-name)
			       (cerror
				 "Ignore the character style change"
				 "The character style ~s is unacceptable for formatter output.~@
				  This occurred in string ~s" 
				 style-of-run substring)
			       substring)
			      (T (make-sage-envr envr-name () (list substring)))))))))
	  (push directive result-list))
	(setq start end-of-run)))
    (nreverse result-list)))

(defun 1find-character-style-run0 (string start end)
  (declare (values start-of-run end-of-run style-of-run))
  ;;(terpri);---
  (decoding-array (string string)
    (let* ((initial-char (aref string start))
	   (prevailing-style (si:char-style initial-char))
	   (index-of-return nil))
      (when (char-equal initial-char #\return)
	(setq prevailing-style si:*null-style*))
      (loop for i from (1+ start) below end
	    do
	(let* ((char (aref string i))
	       (char-style (si:char-style char)))
	  (when (char-equal char #\return)
	    (setq char-style si:*null-style*))
	  ;;(format T "~:c[~a] " char char-style);---
	  (cond ((neq char-style prevailing-style)
		 (cond ((char-equal char #\return)
			(unless index-of-return
			  (setq index-of-return i)))
		       (index-of-return
			(return (values start index-of-return prevailing-style)))
		       (T (return (values start i prevailing-style)))))
		(T (setq index-of-return nil))))
	    finally
	      (if index-of-return
		  (return (values start index-of-return prevailing-style))
		  (return (values start end prevailing-style)))))))

(defun 1envr-name-for-character-style0 (character-style)
  (declare (values envr-name-or-nil))
  (setq character-style (si:parse-character-style character-style))
  (let* ((family (si:cs-family character-style))
	 (face (si:cs-face character-style))
	 (face-code (and face (first (find face *face-code-alist* :key #'second))))
	 (size (si:cs-size character-style)))
    ;; This modestly disgusting kludge makes it consider
    ;; character styles of the form (sage::mumble (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")face0 :normal) to be (nil 2face0 nil).
    ;; It's because losers keep marking sage formatter output and yanking
    ;; it into buffers.  I believe this preserves their intent.
    (cond ((and family (not (eq (symbol-package family) *sage-package*)))
	   nil)
	  ((and size (not (eq size :normal)))
	   nil)
	  ((and face (null face-code))
	   nil)
	  ((null face) nil)
	  (T (if (eql face-code 'L) 'LS face-code)))))

#+Ignore
(defun 1test-clf0 ()
  (let ((string (format nil "Foo ~'ibar~
Mumble

~'igack~
~'ifoo~

~'b

baz~
")))
    (contents-list-from-fat-string string)))

(defmethod 1(contents-list-from-sage-text-structure sage-text-structure)0 ()
  (let ((list ()))
    (map-over-interval-substrings
      interval
      (lambda (substring type)
	(ecase type
	  (:normal
	    (setq list (nreconc (contents-list-from-fat-string substring) list)))
	  (:lisp
	    ;;--- Assumes environment (package, etc.) is correct
	    ;;--- If someone does @L("foo bar") then it gets converted to a fat string
	    ;; (character face sage::lisp) inside the @L command.
	    (push (make-sage-command 'L (ncons (parse-L-string substring))) list)))))
    (nreverse list)))

;;;---keywords is supposed to be a list of contents lists, one for each line.  It
;;;seems to be a contents list instead.  I guess we have to split up the lines.
;;;I'll assume that all strings with newlines in them appear at top level in the
;;;contents-list; this is the same as saying that no envrs markup crosses lines,
;;;which is supposed to be the case.
;;; Well, contents-list-from-sage-text-structure lets character style markup
;;; cross line boundaries.
(defun 1convert-contents-list-to-keywords-list0 (contents-list)
  (let ((lists ())
	(list ()))
    (labels ((in-a-line (thing envr-nest)
	       (dolist (e envr-nest)
		 (setq thing (make-sage-envr (first e) (second e) (list thing))))
	       (push thing list))
	     (end-of-line ()
	       (when list
		 (push (nreverse list) lists)
		 (setq list ())))
	     (frob-contents-list (cl envr-nest)
	       (dolist (thing cl)
		 (typecase thing
		   (string
		     (loop with whitespace = '(#\sp #\tab #\page)
			   for start first (if list 0 (string-search-not-set whitespace thing))
				     then (string-search-not-set whitespace thing :start (1+ eol))
			   while start
			   for eol = (string-search-char #\newline thing :start start)
			   while eol
			   for last-real-char-pos = (string-search-not-set
						      whitespace thing :end eol :start start :from-end t)
			   when last-real-char-pos
			     do (in-a-line (substring thing start (1+ last-real-char-pos))
					   envr-nest)
			   when list
			     do (end-of-line)
			   finally
			     (when start
			       (in-a-line (substring thing start) envr-nest))))
		   (sage-text-structure
		     (frob-contents-list
		       (contents-list-from-sage-text-structure thing)
		       envr-nest))
		   (sage-envr
		     (frob-contents-list
		       (send thing :contents-list)
		       (cons (list (send thing :envr-name) (send thing :envr-mods))
			     envr-nest)))
		   (otherwise
		     (in-a-line thing envr-nest))))))
      (frob-contents-list contents-list ()))
    (nreverse (if list (cons (nreverse list) lists) lists))))
