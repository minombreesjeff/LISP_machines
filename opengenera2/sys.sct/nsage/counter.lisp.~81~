;;; -*- Syntax: Common-lisp; Mode: LISP; Package: NSAGE; Base: 10; Lowercase: T -*-
;;;
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;


(defmethod D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")(:process-definitions basic-gbox :default)0 ()
  )

(defmethod 1(:process-definitions command-gbox)0 ()
  (command-gbox-process-definitions self))

(define-command-gbox-generic 1command-gbox-process-definitions0 ()
  )

(define-command-gbox-method 1(command-gbox-process-definitions modify)0 ()
  (unless *inhibit-@modify-and-@define*
    (let* ((old-dd (lookup-directive-descriptor environment))
	   (new-dd (copy-directive-descriptor
		     (or old-dd 
			 ;;---More polite error needed
			 (error "~s is undefined" environment))))
	   (new-attributes (validate-environment-definition
			     (rest parameter) *document-type* *device-type*))
	   (new-definition (copy-tree (dd-definition old-dd))))
      (dolist (pair new-attributes)
	(pushnew pair new-definition
		 :replace T
		 :key #'first))
      (setf (dd-definition new-dd)
	    new-definition)
      (multiple-value-bind (local-directive-definitions type)
	  (lookup-ambient-value 'local-directive-definitions :error-p nil)
	(assert (member type '(local-directive-definitions nil)))
	(setf (getf local-directive-definitions environment) new-dd)
	(set-ambient-value 'local-directive-definitions
			   local-directive-definitions
			   'local-directive-definitions)))))

;; It occurs to me that no Concordia user will be able to
;; type in any markup defined by @Define because it won't
;; be in the completion space of the c-sh-M command.
(define-command-gbox-method 1(command-gbox-process-definitions define)0 ()
  (unless *inhibit-@modify-and-@define*
    (let* ((old-directive-name (or use 'transparent))
	   (old-dd (lookup-directive-descriptor old-directive-name))
	   (new-dd (copy-directive-descriptor
		     (or old-dd
			 ;;---More polite error needed
			 (error "~s is undefined" old-directive-name)))))
      (ecase (dd-parse-type new-dd)
	(:environment
	  (let ((new-attributes (validate-environment-definition
				  (rest parameter) *document-type* *device-type*))
		(new-definition (copy-tree (dd-definition old-dd))))
	    (dolist (pair new-attributes)
	      (pushnew pair new-definition
		       :replace T
		       :key #'first))
	    (setf (dd-definition new-dd)
		  new-definition)))
	(:command
	  ;;---More polite error needed
	  (assert (or (null (rest parameter))
		      (and (null (rest (rest parameter)))
			   (eql (first (second parameter)) 'use)))
		  ()
		  "Command definitions may not have local mods")))
      (multiple-value-bind (local-directive-definitions type)
	  (lookup-ambient-value 'local-directive-definitions :error-p nil)
	(assert (member type '(local-directive-definitions nil)))
	(setf (getf local-directive-definitions environment) new-dd)
	(set-ambient-value 'local-directive-definitions
			   local-directive-definitions
			   'local-directive-definitions)))))

(define-command-gbox-method 1(command-gbox-process-definitions DefineLineType)0 ()
  (let ((hash-table (lookup-ambient-value 'local-line-definitions)))
    (unless hash-table
      (setq hash-table (make-hash-table))
      (set-ambient-value 'local-line-definitions hash-table 'local-line-definitions))
    (set-type-definition-1 hash-table name *document-type* *device-type*
			   `(:weight ,weight
			     :groove ,groove))))

(define-command-gbox-method 1(command-gbox-process-definitions DefineBox)0 ()
  (let ((hash-table (lookup-ambient-value 'local-box-definitions)))
    (unless hash-table
      (setq hash-table (make-hash-table))
      (set-ambient-value 'local-box-definitions hash-table 'local-box-definitions))
    (set-type-definition-1 hash-table name *document-type* *device-type*
			   `(:left ,left
			     :top ,top
			     :right ,right
			     :bottom ,bottom
			     :horizontal ,horizontal
			     :vertical ,vertical
			     :all ,all))))

;; ---I sure don't know which phase this belongs in...
(define-command-gbox-method 1(command-gbox-process-definitions Set)0 ()
  (loop for (counter-name new-value) in values do
    (unless (eq counter-name 'page)		;pages are done in a different phase
      (let ((counter (find-counter-named counter-name :error-p T)))
	(send counter :set-value (coerce-to-counter-value new-value (send counter :value)))))))

(defmethod 1(fiddle-with-page-number command-gbox)0 ()
  (command-gbox-fiddle-with-page-number self))

(define-command-gbox-generic 1command-gbox-fiddle-with-page-number0 ()
  )

(define-command-gbox-method 1(command-gbox-fiddle-with-page-number Set)0 ()
  (loop for (counter-name new-value) in values do
    (when (eq counter-name 'page)
      (let ((page-counter (find-page-counter)))
	(send page-counter :set-value
	      (coerce-to-counter-value new-value (send page-counter :value)))))))

(defun 1coerce-to-counter-value0 (new-value presently)
  ;; the new-value is supposed to be a (perhaps signed) number,
  ;; or a counter name, or something defined with  @string.
  (block did-it
    (labels ((doit (number)
	       (return-from did-it number))
	     (do-string (string)
	       (ignore-errors
		 (multiple-value-bind (number end-index)
		     (read-from-string string)
		   (when (and (integerp number)
			      (= end-index (length string)))
		     (doit number)))))
	     (parse-set-command-arg-as-number (string)
	       (if (numberp string)
		   string
		   (let ((sign nil)
			 (start 0)
			 (end (string-length string)))
		     (setq start (string-search-not-set *white-space* string :start start))
		     (setq end (1+ (string-search-not-set *white-space* string
							  :start start
							  :from-end T)))
		     (selector (aref string start) char-equal
		       (#\+ (setq sign '+) (incf start))
		       (#\- (setq sign '-) (incf start)))
		     (unless (find-if-not #'digit-char-p string :start start :end end)
		       (let ((number (parse-integer string
						    :start start :end end
						    :sign-allowed nil)))
			 (values number sign)))))))
      ;; Try it as a (perhaps signed) number
      (multiple-value-bind (number sign) (parse-set-command-arg-as-number new-value)
	(when number
	  (ecase sign
	    ((+) (doit (+ number presently)))
	    ((-) (doit (- number presently)))
	    ((nil) (doit number)))))
      ;; Try it as a counter
      (let ((other-counter (find-counter-named new-value :error-p nil :by-string T)))
	(when  other-counter
	  (doit (send other-counter :value))))
      ;; Try it as a prevailing value
      (multiple-value-bind (value value-type)
	  (lookup-ambient-value new-value)
	(ecase value-type
	  (number (doit value))
	  (counter
	    (note-counter-touch value 'reference)
	    (doit (send value :value)))
	  (string (do-string value))
	  (contents-list
	    (do-string
	      (filtered-string-from-contents-list value)))))
      ;; Otherwise it's a loser
      (error "The value for Set, ~s, doesn't work" new-value))))

;; @Label picks up the prevailing section counter.
;; @Tag picks up the counter attached to the prevailing environment.
(define-command-gbox-method 1(command-gbox-insert-generated-text label)0 ()
  (let ((section-counter (lookup-ambient-value 'sectionnumber)))
    (when section-counter
      (save-tag-value (first parameter) 
		      (clone-counter-and-lineage section-counter)))))

;;; Scribe manual (white) page 77, "Using tag before caption ensures that your
;;; crossreferences will be wrong."
(define-command-gbox-method 1(command-gbox-insert-generated-text tag)0 ()
  (let ((counter (or (send environment :attached-counter)
		     (send environment :environment-counter))))
    (when counter
      (save-tag-value (first parameter) (clone-counter-and-lineage counter)))))

(define-command-gbox-generic 1tags-note-page-number0 ()
  )

(define-command-gbox-method 1(tags-note-page-number (label tag))0 ()
  (let ((page (lookup-ambient-value 'page)))
    (when page
      (save-tag-page (first parameter)
		     (clone-counter-and-lineage page)))))

(defflavor 1tag-data
0	((value)
	 (page) 
	 (referenced)				;NIL, T, or :ERROR
	 (timestamp nil)	;to distinguish formatter runs
	 )
	()
  :writable-instance-variables
  :initable-instance-variables
  (:constructor make-tag-data (&key value page referenced (timestamp *formatter-timestamp*))))


(defmethod 1(:fasd-form tag-data)0 ()
  `(make-tag-data :value ',value :page ',page))

(defmethod 1(tag-data-value-and-page tag-data)0 ()
  (values value page))

(defun 1upgrade-tag-info-to-tag-data0 (tag-info)
  (destructuring-bind (value page) tag-info
    (make-tag-data :value value :page page)))

(defun 1maybe-convert-old-format-tag-values0 (tag-values)
  (cond ((listp (second tag-values))
	 (loop for (thing pair) on tag-values by #'cddr
	       appending `(,thing ,(upgrade-tag-info-to-tag-data pair))))
	(t tag-values)))

(defmethod 1(tag-data-funcall-on-value-and-page tag-data)0 (continuation)
  (declare (sys:downward-funarg continuation))
  (funcall continuation value)
  (funcall continuation page))

(defun 1counter-eql0 (thing1 thing2)
  (or (eql thing1 thing2)
      (and thing1 thing2
	   (counter-eql-1 thing1 thing2))))

(defmethod 1(counter-eql-1 counter)0 (other-counter)
  (and (eql name (send other-counter :name))
       (eql value (send other-counter :value))
       (eql nesting-depth (send other-counter :nesting-depth))))

;;; If this tag has been referenced this run, set referenced to :ERROR.
;;; If this tag has been referenced erroneously this run, remember that.
;;; If this tag has not been referenced this run, clear :ERROR.
(defmethod 1(set-tag-value tag-data)0 (new-value)
  (when (not (counter-eql new-value value))
    (cond ((and timestamp (= timestamp *formatter-timestamp*))
	   (when referenced 
	     (setq referenced ':error)))
	  (t (setq referenced nil))))
  (setq value new-value))


(defmethod 1(set-tag-page tag-data)0 (new-page)
  (when (not (counter-eql new-page page))
    (cond ((and timestamp (= timestamp *formatter-timestamp*))
	   (when referenced 
	     (setq referenced ':error)))
	  (t (setq referenced nil))))
  (setq page new-page))

(defmethod 1(set-tag-referenced tag-data)0 ()
  (cond ((and (null value) (null page))
	 (setq referenced ':ERROR timestamp *formatter-timestamp*))
	((and timestamp (= timestamp *formatter-timestamp*))
	 (unless (eq referenced ':error)
	   (setq referenced t)))
	(t (setq referenced t timestamp *formatter-timestamp*))))

(defun 1save-tag-value0 (tag-name value)
  (unless (symbolp tag-name)
    (setq tag-name (string-upcase-and-intern tag-name *sage-package*)))
  (let ((tag-values (lookup-ambient-value 'tag-values)))
    (let ((tag-data (getf tag-values tag-name)))
      (cond (tag-data
	     (set-tag-value tag-data value))
	    (t
	     (setq tag-data (make-tag-data :value value))
	     (setf (getf tag-values tag-name) tag-data)
	     (set-ambient-value 'tag-values tag-values 'tag-values))))))

(defun 1save-tag-page0 (tag-name page)
  (unless (symbolp tag-name)
    (setq tag-name (string-upcase-and-intern tag-name *sage-package*)))
  (let ((tag-values (lookup-ambient-value 'tag-values)))
    (let ((tag-data (getf tag-values tag-name)))
      (cond (tag-data
	     (set-tag-page tag-data page))
	    (t (setq tag-data (make-tag-data :page page))
	       (setf (getf tag-values tag-name) tag-data)
	       (set-ambient-value 'tag-values tag-values 'tag-values))))))

(defun 1lookup-tag-values0 (tag-name)
  (declare (values value page))
  (unless (symbolp tag-name)
    (setq tag-name (string-upcase-and-intern tag-name *sage-package*)))
  (let ((tag-values (lookup-ambient-value 'tag-values :error-p nil)))
    (let ((tag-data (getf tag-values tag-name)))
      (cond (tag-data
	     (set-tag-referenced tag-data))
	    (t (setq tag-data (make-tag-data :referenced :error))
	       (setf (getf tag-values tag-name) tag-data)
	       (set-ambient-value 'tag-values tag-values 'tag-values)))
      (tag-data-value-and-page tag-data))))

(define-command-gbox-method 1(command-gbox-insert-generated-text pageref)0 ()
  (multiple-value-bind (value page) (lookup-tag-values (first parameter))
    (ignore value)
    (splice-replace-ref-gbox self page (first parameter))))

(define-command-gbox-method (1command-gbox-insert-generated-text0 1ref0) ()
  (multiple-value-bind (value page) (lookup-tag-values (first parameter))
    (ignore page)
    (splice-replace-ref-gbox self value (first parameter))))

(define-presentation-type 1undefined-ref-gbox0 ((&key gbox))
   :expander T)

(defun 1show-forward-ref0 (gbox)
  (format T "~&This is a ~(~a~) to tag \"~a\""
	  (send gbox :command-name)
	  (ignore-errors (first (send gbox :parameter)))))

(defun 1show-forward-ref-translator-documentation0 (object &key presentation &allow-other-keys)
  (ignore object)
  (dw:with-presentation-type-arguments
    (undefined-ref-gbox (dw:presentation-type presentation))
    (format nil "Tag \"~a\""
	    (ignore-errors (first (send gbox :parameter))))))

;; For Lisp Listener
(define-presentation-translator 1form-show-forward-ref
0   (undefined-ref-gbox
     sys:form
     :documentation show-forward-ref-translator-documentation)
   (obj &key presentation)
  (ignore obj)
  (dw:with-presentation-type-arguments
    (undefined-ref-gbox (dw:presentation-type presentation))
    `(show-forward-ref ,gbox)))

(zwei:define-presentation-to-editor-command-translator 1zwei-show-forward-ref
0   (undefined-ref-gbox
     "Show Forward Ref" zwei:*standard-comtab*
     :gesture :select
     :documentation show-forward-ref-translator-documentation)
   (obj &key presentation)
  (ignore obj)
  (dw:with-presentation-type-arguments
    (undefined-ref-gbox (dw:presentation-type presentation))
    `(show-forward-ref ,gbox)))

(defun 1splice-replace-ref-gbox0 (gbox value string)
  (prog1
    (if value
	(send (make-sage-command 'counter-value-as-reference (list value))
	      :splice-gbox-self gbox (send gbox :environment))
	(splice-contents-list
	  gbox
	  (send gbox :environment)
	  (making-sage-directives ()
	    (if (lookup-style-parameter 'hide-undefined-tags)
		(in-environment1 (() `(s presentationtype
					 '((undefined-ref-gbox :gbox ,gbox))))
		  (write-string "!"))
		(write-string (string string))))))
    (splice-box-out gbox)))

(defun 1find-page-counter0 (&key (if-does-not-exist :create))
  (multiple-value-bind (page-counter type)
      (lookup-ambient-value 'page :error-p nil)
    (cond (page-counter
	   (unless (eql type 'counter)
	     (error "Page value ~s not of type COUNTER (Internal error)" page-counter))
	   page-counter)
	  (T
	   (ecase if-does-not-exist
	     (:create
	       (let ((new-counter (get-new-counter)))
		 (send new-counter :set-attribute
		       'incrementedBy 'magic)
		 (send new-counter :set-name 'page)
		 (send new-counter :set-value 0)
		 (set-ambient-value 'page new-counter 'counter)
		 new-counter))
	     ((nil) nil)
	     (:error
	       (error "PAGE-COUNTER is not set up yet")))))))

(defun 1find-footnote-counter0 ()
  (find-or-create-counter 'FootnoteCounter))

(defun 1do-style-command-args0 (parameter environment)
  (dolist (pair parameter)
    (destructuring-bind (param value) pair
      (let ((param-structure (lookup-style-command-parameter param)))
	(if param-structure
	    (process-style-command-argument param-structure value environment)
	    (cerror "ignore it"
		    "The style command parameter ~s is undefined" param)
	    )))))

(defmethod 1(make-instance ambient-counters :after)0 (&rest ignore)
  (ambient-counters-set-ambient-value
    self 'time-at-start (get-universal-time) 'time))

(defun 1find-counter-named0 (counter-name &key error-p by-string)
  (ambient-counters-find-counter-named *ambient-counters* counter-name
				       error-p by-string))

(defmethod 1(ambient-counters-find-counter-named ambient-counters)0 (counter-name
								    error-p by-string)
  (or (second (assoc counter-name counters))
      (and by-string (second (assoc counter-name counters :test #'string-equal)))
      (if error-p
	  (error "Cannot find counter named ~s" counter-name)
	  ())))

(defmethod 1(ambient-counters-add-counter-named ambient-counters)0 (counter-name counter)
  (pushnew (list counter-name counter)
	   counters
	   :key #'first :replace t))

(defmethod 1(establish-counter-parental-bonding counter)0 (parent)
  (setq parent-counter parent)
  (when parent (pushnew self (counter-child-counters parent)))
  self)

(defun 1find-or-create-counter0 (counter-name)
  (note-ambient-counter-touch counter-name ()))

(defun 1note-ambient-counter-touch0 (counter-name how-touched)
  (ambient-counters-note-ambient-counter-touch *ambient-counters* counter-name how-touched))

(defmethod 1(ambient-counters-note-ambient-counter-touch ambient-counters)
0	   (counter-name how-touched)
  (let ((counter (second (assoc counter-name counters))))
    (cond (counter
	   (note-counter-touch counter how-touched))
	  (T
	   (setq counter (get-new-counter-named counter-name))
	   (send counter :set-nesting-depth 0)	;---always?
	   (ambient-counters-add-counter-named self counter-name counter)
	   (note-counter-touch counter how-touched)))
    counter))

(defmethod 1(note-counter-touch counter)0 (how-touched)
  (check-type how-touched (member nil use tag reference magic))
  (when (eql how-touched incremented-by)
    (incf value)
    (when aliased-counter
      (note-counter-touch aliased-counter how-touched)
      (send aliased-counter :set-value value))
    (map nil #'reset-counter-to-initial-value child-counters)))

(defmethod 1(reset-counter-to-initial-value counter)0 ()
  (setq value initial-value))

;;; This is sort of like part of the formatter database in that
;;; it remembers the definitions for named-counters
(defvar 1*named-counters*0 ())

(defstruct (1named-counter-definition0 :list)
  name instance within attributes)

;; Call this to define one
(defun 1define-named-counter0 (counter-name &rest attributes)
  (let ((counter (get-new-counter)))
    (with-document-and-device-types ()		;parsing @$ for instance
      (loop for (attr value) on attributes by #'zl:rest2
	    unless (eql attr 'within)
	      do (send counter :set-attribute attr value)))
    (pushnew (make-named-counter-definition
	       :name counter-name
	       :instance counter
	       :within (getf attributes 'within)
	       :attributes (copy-tree attributes))
	     *named-counters*
	     :key #'named-counter-definition-name :replace t)))

;; Recompute these, like when the counter defflavor changes incompatibly
(defun 1redo-named-counter-definitions0 ()
  (with-document-and-device-types ()
    (dolist (definition *named-counters*)
      (let ((counter (get-new-counter)))
	(loop for (attr value) on (named-counter-definition-attributes definition)
			by #'zl:rest2
	      unless (eql attr 'within)
		do (send counter :set-attribute attr value))
	(setf (named-counter-definition-instance definition) counter)))))

(defun 1lookup-named-counter-definition0 (counter-name &key (error-p T))
  (loop
    (catch 'retry
      (return
	(or (find counter-name *named-counters* :key #'named-counter-definition-name)
	    (when error-p
	      (cerror "Retry looking it up"
		      "Cannot find counter definition for ~s" counter-name)
	      (throw 'retry nil)))))))

(defun 1get-new-counter-named0 (counter-name)
  (let* ((definition (lookup-counter-descriptor counter-name))
	 (new-counter (get-new-counter)))
    ;;(when (null definition) (break "Unknown counter ~s" counter-name))
    (with-document-and-device-types ()		;parsing @$ for instance
      (loop for (attr value) on (rest definition) by #'cddr do
	(let ((other (second (assoc attr
				    '#.(loop for x in '(:numbered :referenced :alias :init)
					     collect (list x (intern (string x))))))))
	  (cond (other
		 (send new-counter :set-attribute other value))
		((eq attr :incremented-by)
		 (send new-counter :set-attribute 'incrementedby value))
		((member attr '(:within :title :contents)) )
		(T (error "Unrecognized attribute ~s (internal error)" attr))))))
    (send new-counter :set-name counter-name)
    (let ((within (getf (rest definition) :within)))
      (when within (send new-counter :set-attribute 'within within)))
    new-counter))

(defun 1lookup-counter-by-string0 (counter-name)
  (when counter-name
    (find-counter-named counter-name :by-string T)))

(defmethod 1(clone-counter-and-lineage counter)0 ()
  (let ((new-counter (make-instance (type-of self))))
    (flavor::%block-copy-allow-null self new-counter
				    (flavor::flavor-instance-size (sys:%instance-flavor self)))
    (set-parent-and-children new-counter
			     (and parent-counter
				  (clone-counter-and-lineage parent-counter))
			     '-clones-have-no-child-counters-)
    new-counter))

(defmethod 1(set-parent-and-children counter)0 (new-parent new-children)
  (setq parent-counter new-parent
	child-counters new-children))

(define-sage-command-method 1(sage-command-splice-gbox-self value)0 (predecessor environment)
  (ignore environment)
  (flet ((splice-string (string)
	   (setq predecessor
		 (splice-boxes-after predecessor
				     (make-string-gbox environment string 0 (length string))))))
    (when (stringp name)
      (setq name (string-upcase-and-intern name *sage-package*)))
    (multiple-value-bind (value value-type)
	(lookup-ambient-value name)
      (case value-type
	((nil)
	 (let ((str (predefined-formatter-string name predecessor)))
	   (when str
	     (splice-string str))))
	(number
	  (splice-string (write-to-string value)))
	(counter
	  (note-counter-touch value 'reference)
	  (setq predecessor (send value :counter-reference-gbox predecessor environment)))
	(string
	  ;;--- this should lookup the string value, of course
	  (splice-string value))
	(contents-list
	  (setq predecessor (splice-contents-list predecessor environment value)))
	(otherwise
	  (when *debugging-sage*
	    (cerror "Insert the PRINC of it"
		    "Don't know how to insert value of ~s, for ~s" value name))
	  (splice-string (write-to-string value))))))
  predecessor)

(defun 1predefined-formatter-string0 (name &optional gbox)
  (case name
    ((date day month time timestamp weekday year)
     (let ((time-at-start (lookup-ambient-value 'time-at-start)))
       (multiple-value-bind (second minute hour
			     date month year
			     day-of-the-week daylight-savings-p timezone)
	   (decode-universal-time time-at-start)
	 (ignore second minute hour daylight-savings-p timezone)
	 (flet ((get-month ()
		  (time:month-string month))
		(get-weekday ()
		  (time:day-of-the-week-string day-of-the-week)))
	   (ecase name
	     (date
	       (format-date-in-lookup-style time-at-start 'date nil))
	     (day (format nil "~d" date))
	     (month (get-month))
	     (time
	       (format-date-in-lookup-style time-at-start 'time nil))
	     (timestamp
	       (format-date-in-lookup-style time-at-start 'timestamp nil))
	     (weekday (get-weekday))
	     (year (format nil "~d" year)))))))
    (page
      ;; Caller should have caught this
      ;; "<page>"
      "")
    ((sectionnumber sectiontitle)
     ;;---Want a way for @value(firstsectionnumber) to turn into sectionnumber
     ;; if firstsectionnumber isn't defined yet.
     "")
    (device
      ;; The output device for this run.  Taken from the @Device command in the mss
      ;; file or the DeviceName parameter of the .DEV file, the "Device" command-line
      ;; option, or supplied by default from the Site file.
      ;;---
      (format nil "~A" *device-type*))
    (devicename
      ;; The name of the output device for this run, for example,
      ;; PostScript Page Description Language.  Taken from the DeviceTitle
      ;; parameter of the .DEV file.
      ;;---
      "")
    (document-type
      (format nil "~A" *document-type*))
    (filedate
      (format-date-in-lookup-style (get-universal-time) 'filedate nil))
    (fullmanuscript
      ;; the full file specification of the manuscript (root) file being processed
      ;;---
      "")
    (genericdevice
      ;; name of the device class to which the selected output device belongs
      ;;---
      "")
    (manuscript
      ;; name of the manuscript (root) file being processed, for example, USER1.MSS
      ;;---
      "")
    (nickname
      (send si:*user* :nickname))
    (personalname
      (send si:*user* :personal-name))
    (rootfiledate
      ;; If multiple files are in use (via @Include), RootFileDate is the date
      ;; and time of last update of the root file, for example, 19 June 1985 at 12:02
      (format-date-in-lookup-style (get-universal-time) 'filedate nil))
    (scribeversion
      ;;are you kidding?
      "")
    (site
      ;; The abbreviation for the site name.  Taken from the site code field in SCRIBE.SIT.
      ;;---
      "")
    (sitename
      ;; The name of the site.  Taken from the site name field in SCRIBE.SIT.
      ;;---
      "")
    (sourcefile
      ;;Search backwards up the gbox chain looking for a record-entry-gbox.
      ;;When found, get the source file name from the record
      (if gbox
	  (let ((source-file
		  (loop for g = gbox then (box-prev g) while g do
		    (when (typep g 'record-entry-gbox)
		      (return (doc-record-source-file (send g :record)))))))
	    (if source-file
		(send source-file :string-for-printing)
		""))
	  ""))
    (username neti:user-id)
    (otherwise
      ;;(format nil "<~a>" name)
      "")))

(define-sage-command-method 1(sage-command-splice-gbox-self counter-value-as-reference)
0			    (predecessor environment)
  (ignore environment)
  (flet ((splice-string (string)
	   (setq predecessor
		 (splice-boxes-after predecessor
				     (make-string-gbox environment string 0 (length string))))))
    (let ((value (etypecase counter-name
		   (counter counter-name)
		   (symbol
		     (lookup-ambient-value counter-name)))))
      (typecase value
	(number
	  (splice-string (write-to-string value)))
	(counter
	  (setq predecessor (send value :counter-reference-gbox predecessor environment)))
	(string
	  ;;--- this should lookup the string value, of course
	  (splice-string value))
	(otherwise
	  (cerror "Insert the PRINC of it"
		  "Don't know how to insert value for ~s" value)
	  (splice-string (write-to-string value))))))
  predecessor)

(define-sage-command-method 1(sage-command-splice-gbox-self counter-value-as-number)
0			    (predecessor environment)
  (flet ((splice-string (string)
	   (setq predecessor
		 (splice-boxes-after predecessor
				     (make-string-gbox environment string 0 (length string))))))
    (let ((value (etypecase counter-name
		   (counter counter-name)
		   (symbol
		     (lookup-ambient-value counter-name)))))
      (typecase value
	(number
	  (splice-string (write-to-string value)))
	(counter
	  (setq predecessor (send value :counter-number-gbox predecessor environment)))
	(string
	  ;;--- this should lookup the string value, of course
	  (splice-string value))
	(otherwise
	  (cerror "Insert the PRINC of it"
		  "Don't know how to insert value for ~s" value)
	  (splice-string (write-to-string value))))))
  predecessor)


(eval-when (eval load compile)
(define-sage-command 1already-has-gbox-kludge0 ((gbox T))
  )
)

(define-command-gbox-method 1(command-gbox-insert-generated-text already-has-gbox-kludge)0 ()
  (send gbox :set-environment environment)
  (splice-replace-box self gbox))

(defun 1render-section-command0 (gbox counter-type contents-list renderer)
  (note-ambient-counter-touch counter-type nil)
  (when (eql renderer :lookup)
    (setq renderer
	  (or (getf (rest (lookup-counter-descriptor counter-type)) :title)
	      (find-fallback-renderer counter-type :title))))
  (let ((counter (find-counter-named counter-type)))
    (flet ((set-if-null (names value type)
	     (dolist (name names)
	       (when (null (lookup-ambient-value name :error-p nil))
		 (set-ambient-value name value type)))))
      (set-if-null '(firstsectionnumber topsectionnumber) counter 'counter)
      (set-if-null '(firstsectiontitle topsectiontitle) contents-list 'contents-list))
    (set-ambient-value 'sectionnumber counter 'counter)
    (set-ambient-value 'sectiontitle contents-list 'contents-list)
    (set-ambient-value 'lastsectionnumber counter 'counter)
    (set-ambient-value 'lastsectiontitle contents-list 'contents-list)
    (assert (listp contents-list))
    (let ((counter-gbox (make-counter-command-gbox gbox)))
      (let ((result
	      (splice-contents-list
		gbox (send gbox :environment)
		(making-sage-directives ()
		  (note-ambient-counter-touch counter-type 'use)
		  (funcall renderer
			   (cons (make-sage-command 'already-has-gbox-kludge
						    (list counter-gbox))
				 contents-list)
			   (list (make-sage-command 'counter-value-as-number
						    '(sectionnumber))))))))
	(let ((counter-clone (clone-counter-and-lineage counter)))
	  (setf (counter-command-gbox-cloned-counter counter-gbox) counter-clone)
	  (save-tag-value (send gbox :command-name) counter-clone))
	(splice-box-out gbox)
	result))))

(defgeneric 1reconsider-sections0 (basic-gbox)
  (:method (basic-gbox :default)
   ())
  (:method (command-gbox)
   (command-gbox-reconsider-sections self)))

(define-command-gbox-generic 1command-gbox-reconsider-sections0 ()
  )

;; rerun the style command between pages
(define-command-gbox-method 1(command-gbox-reconsider-sections style)0 ()
  (do-style-command-args parameter environment))

(define-command-gbox-method 1(command-gbox-reconsider-sections defline-section)
0			    ()
  (command-gbox-reconsider-sections-1 
    (counter-command-gbox-cloned-counter self)
    command-name title))

(define-command-gbox-method 1(command-gbox-reconsider-sections (majorpart chapter section subsection appendix prefatory))
0			    ()
  (command-gbox-reconsider-sections-1 
    (counter-command-gbox-cloned-counter self)
    command-name (first parameter)))

(defun 1command-gbox-reconsider-sections-10 (clone command-name title)
  (let ((aliased-counter (send clone :aliased-counter)))
    (labels ((reset-children (counter)
	       (let ((children (counter-child-counters counter)))
		 (block did-a-child
		   (dolist (child children)
		     (let ((child-name (send child :name)))
		       ;; This is the point
		       (set-ambient-value child-name nil 'contents-list))
		     (reset-children child)
		     (return-from did-a-child nil))))))
      ;; Deal with this counter
      (set-ambient-value command-name title 'contents-list)
      (save-tag-value command-name clone)
      (reset-children
	(find-counter-named (send clone :name) :error-p nil))
      ;; Deal with its alias, if any
      (when aliased-counter
	(set-ambient-value (send aliased-counter :name) title 'contents-list)
	(save-tag-value (send aliased-counter :name) aliased-counter)
	(reset-children
	  (find-counter-named (send aliased-counter :name) :error-p nil)))))
  (flet ((set-if-null (names value type)
	   (dolist (name names)
	     (when (null (lookup-ambient-value name :error-p nil))
	       (set-ambient-value name value type)))))
    (set-if-null '(firstsectionnumber topsectionnumber) clone 'counter)
    (set-if-null '(firstsectiontitle topsectiontitle) title 'contents-list))
  (set-ambient-value 'sectionnumber clone 'counter)
  (set-ambient-value 'sectiontitle title 'contents-list)
  (set-ambient-value 'lastsectionnumber clone 'counter)
  (assert (listp title))
  (set-ambient-value 'lastsectiontitle title 'contents-list)
  ())

(define-command-gbox-method 1(command-gbox-insert-generated-text majorpart)0 ()
  (render-section-command self 'majorpart title :lookup))

(define-command-gbox-method 1(command-gbox-insert-generated-text chapter)0 ()
  (render-section-command self 'chapter title :lookup))

(define-command-gbox-method 1(command-gbox-insert-generated-text appendix)0 ()
  (render-section-command self 'appendix title :lookup))

(define-command-gbox-method 1(command-gbox-insert-generated-text prefatory)0 ()
  (render-section-command self 'prefatory title :lookup))

(define-command-gbox-method 1(command-gbox-insert-generated-text section)0 ()
  (render-section-command self 'section (first parameter) :lookup))

(define-command-gbox-method 1(command-gbox-insert-generated-text appendixsection)0 ()
  (render-section-command self 'appendixsection (first parameter) :lookup))

(define-command-gbox-method 1(command-gbox-insert-generated-text subsection)0 ()
  (render-section-command self 'subsection (first parameter) :lookup))

(define-command-gbox-method 1(command-gbox-insert-generated-text subsubsection)0 ()
  (render-section-command self 'subsubsection (first parameter) :lookup))

(define-command-gbox-generic 1render-for-table-of-contents0 ()
  )

(defun 1render-for-toc0 (gbox counter-type toc-type contents-list renderer)
;;  (note-ambient-counter-touch counter-type nil)	;---is this needed??
  (ignore counter-type)
  (when (eql renderer :lookup)
    (setq renderer
	  (or (getf (rest (lookup-counter-descriptor counter-type)) :contents)
	      (find-fallback-renderer counter-type :contents))))
  (let ((toc-stream-name
	  (ecase toc-type
	    (contents 'table-of-contents-stream)
	    (figures 'table-of-figures-stream)
	    (tables 'table-of-tables-stream))))
    (multiple-value-bind (toc-stream type)
	(lookup-ambient-value toc-stream-name :error-p nil)
      (if toc-stream
	  (assert (eql type 'stream))
	  (let ((stream (make-instance 'sage-directive-stream)))
	    (set-ambient-value toc-stream-name stream 'stream)
	    (setq toc-stream stream)))
      (let ((*standard-output* toc-stream))
	(let ((counter-contents 
		(list (make-sage-command
			'counter-value-as-reference
			(list (counter-command-gbox-cloned-counter gbox))))))
	  (funcall renderer contents-list counter-contents))))))

(defun 1render-regular-toc0 (environment title counter-contents)
  (in-environment1 (() environment)
    (in-presentation (()
		      :type 'page-number
		      :object (filtered-string-from-contents-list
				(counter-value-contents-list (lookup-ambient-value 'page)
							     :reference))
		      :presentation-options '(:single-box t))
      (idirs
	counter-contents
	(spaces 2)
	(command dynamic-left-margin)
	(command rfstr 
		 ;; --- let's us figure out what we really want here!
		 ;; sticking random nconses everywhere is doomed to failure
		 (ncons (making-sage-directives ()
			  (sage-command () 'counter-value-as-number
					(list
					  (clone-counter-and-lineage
					    (lookup-ambient-value 'page)))))))
	title))))

(defun 1render-approachability-toc0 (environment title counter-contents)
  (in-environment1 (() environment)
    (in-presentation (()
		      :type 'page-number
		      :object (filtered-string-from-contents-list
				(counter-value-contents-list (lookup-ambient-value 'page)
							     :reference))
		      :presentation-options '(:single-box t))
      (idirs
	counter-contents
	(spaces 2)
	(command dynamic-left-margin)
	title
;       (spaces 3)
;		 (command counter-value-as-number
;			  (list
;			    (clone-counter-and-lineage
;			      (lookup-ambient-value 'page)))))
	(command rfstr
		 (ncons (making-sage-directives ()
			  (sage-command () 'counter-value-as-number
					(list
					  (clone-counter-and-lineage
					    (lookup-ambient-value 'page)))))))))))

(defun 1render-counterless-toc0 (environment title)
  (in-environment1 (() environment)
    (in-presentation (()
		      :type 'page-number
		      :object (filtered-string-from-contents-list
				(counter-value-contents-list (lookup-ambient-value 'page)
							     :reference))
		      :presentation-options '(:single-box t))
      (idirs
	(command rfstr
		 (ncons (making-sage-directives ()
			  (sage-command () 'counter-value-as-number
					(list
					  (clone-counter-and-lineage
					    (lookup-ambient-value 'page)))))))
	title))))

(define-command-gbox-method 1(render-for-table-of-contents majorpart)0 ()
  (render-for-toc self 'majorpart 'contents (first parameter) :lookup))

(define-command-gbox-method 1(render-for-table-of-contents (chapter appendix))0 ()
  (render-for-toc self 'chapter 'contents (first parameter) :lookup))

(define-command-gbox-method 1(render-for-table-of-contents section)0 ()
  (render-for-toc self 'section 'contents (first parameter) :lookup))

(define-command-gbox-method 1(render-for-table-of-contents appendixsection)0 ()
  (render-for-toc self 'appendixsection 'contents (first parameter) :lookup))

(define-command-gbox-method 1(render-for-table-of-contents subsection)0 ()
  (render-for-toc self 'subsection 'contents (first parameter) :lookup))

(define-command-gbox-method 1(render-for-table-of-contents defline-section)0 ()
  ;; Do nothing at all for toc
  )

;; They are all collected here so I can find out when they're used.
;; It's supposed to use the real database now.
(defun 1find-fallback-renderer0 (counter-type title-or-contents)
  (ecase title-or-contents
    (:title
      (ecase counter-type
	(majorpart
	  (named-lambda 1render-majorpart-head0 (title counter-contents)
	    (declare (sys:downward-function))
	    (idirs
	      (envr HD0
		    "PART "
		    counter-contents
		    (command force-line-break)
		    (command blankspace '((1 cm)))
		    title))))
	((chapter appendix prefatory)
	 (named-lambda 1render-chapter-head0 (title counter-contents)
	   (declare (sys:downward-function))
	   (idirs
	     (envr (HD1 above 2 below 2 facecode b)
		   counter-contents (spaces 2) title))))
	(section
	  (named-lambda 1render-section-head0 (title counter-contents)
	    (declare (sys:downward-function))
	    (idirs
	      (envr (HD2 above 2 below 2) counter-contents (spaces 2) title))))
	(appendixsection
	  (named-lambda 1render-appendixsection-head0 (title counter-contents)
	    (declare (sys:downward-function))
	    (idirs
	      (envr (HD2 above 2 below 2) counter-contents (spaces 2) title))))
	(subsection
	  (named-lambda 1render-subsection-head0 (title counter-contents)
	    (declare (sys:downward-function))
	    (idirs
	      (envr (HD3 above 1 below 1) counter-contents (spaces 2) title))))
	(subsubsection
	  (named-lambda 1render-subsubsection-head0 (title counter-contents)
	    (declare (sys:downward-function))
	    (idirs
	      (envr (HD3 above 1 below 1) counter-contents (spaces 2) title))))
	))
    (:contents
      (ecase counter-type
	(majorpart
	  (named-lambda 1render-majorpart-0toc (title counter-contents)
	    (declare (sys:downward-function))
	    (render-regular-toc '(TC0) title counter-contents)))
	(chapter
	  (named-lambda render-chapter-toc (title counter-contents)
	    (declare (sys:downward-function))
	    (render-regular-toc '(Tc1) title counter-contents)))
	(section
	  (named-lambda render-section-toc (title counter-contents)
	    (declare (sys:downward-function))
	    (render-regular-toc '(Tc2) title counter-contents)))
	(appendixsection
	  (named-lambda render-appendixsection-toc (title counter-contents)
	    (declare (sys:downward-function))
	    (render-regular-toc '(Tc2) title counter-contents)))
	;;--appendixsection
	(subsection
	  (named-lambda render-subsection-toc (title counter-contents)
	    (declare (sys:downward-function))
	    (render-regular-toc '(Tc3) title counter-contents)))
	(subsubsection
	  ;;subsubsections don't appear in ToC
	  #'ignore)
	))))

(defmethod 1(render-for-index basic-gbox :default)0 ()
  )

(defmethod 1(render-for-index command-gbox)0 ()
  (command-gbox-render-for-index self))

(define-command-gbox-generic 1command-gbox-render-for-index0 ()
  )

;; 1IndFinalPage
0;; 1Itag0 code
(define-command-gbox-method 1(command-gbox-render-for-index index)0 ()
  (let ((string-to-sort-on
	  (ecase (lookup-style-parameter 'indexstyle)
	    ((nil permuted simple)
	     ())
	    (multilevel
	      (making-sage-directives ()
		(idirs entry " 1"))))))
    (add-to-index-database
      (clone-counter-and-lineage (lookup-ambient-value 'page))
      entry string-to-sort-on
      (look-back-for-record-entry self))))

(defun 1look-back-for-record-entry0 (gbox)
  (loop for gbox = gbox then (box-prev gbox) while gbox
	do
    (when (typep gbox 'record-entry-gbox)
      (return (send gbox :record)))))

;; This is the fundamental command.  Scribe has macro definitions for Index etc
;; which turn into calls to this.
(define-command-gbox-method (1command-gbox-render-for-index0 1IndexEntry0) ()
  (add-to-index-database
    (if (eq number 'T)
	(clone-counter-and-lineage (lookup-ambient-value 'page))
	number)
    entry key
    record))

(define-command-gbox-method 1(command-gbox-render-for-index indexPrimary)0 ()
  (add-index-as-multilevel-primary entry (look-back-for-record-entry self)))

(defun 1add-index-as-multilevel-primary0 (entry record)
  (let ((string-to-sort-on
	  (ecase (lookup-style-parameter 'indexstyle)
	    ((nil permuted simple)
	     ())
	    (multilevel
	      (making-sage-directives ()
		(idirs entry " 1"))))))
    (add-to-index-database nil entry string-to-sort-on record)))

(define-command-gbox-method 1(command-gbox-render-for-index indexSecondary)0 ()
  (let ((record (look-back-for-record-entry self)))
    (add-index-as-multilevel-primary primary record)
    (add-to-index-database
      (clone-counter-and-lineage (lookup-ambient-value 'page))
      (making-sage-directives ()
	(idirs (spaces 3) secondary))
      (making-sage-directives ()
	(sage-contents-list T primary)
	(write-string " 2 ")
	(sage-contents-list T (strip-leading-nonsorting-words secondary)))
      record)))

(defun 1strip-leading-nonsorting-words0 (contents-list)
  (let ((*inhibit-sort-on-these* *standard-inhibit-list*)
	(*case-inhibit-sort-on-these* *case-sensitive-inhibit-list*))
    (let ((chunks (chunked-contents-list contents-list)))
      (if (matches-inhibit-entry (first chunks))
	  (rest chunks)
	  contents-list))))

;; ---these more structured guys (IndexEntry, IndexSecondary) will need more arguments
(defun 1add-to-index-database0 (page-counter contents-list string-to-sort-on record)
  (multiple-value-bind (index-db type)
      (lookup-ambient-value 'index-database :error-p nil)
    (if index-db
	(assert (eql type 'index-database))
	(let ((db (make-index-database)))
	  (set-ambient-value 'index-database db 'index-database)
	  (setq index-db db)))
    (add-index-entry index-db page-counter
		     (canonicalize-contents-list contents-list)
		     string-to-sort-on
		     record)))

(defflavor 1index-database
0	((entries ()))
	()
  (:constructor make-index-database ())
  :writable-instance-variables)

(defflavor 1index-database-entry
0	(page-counter contents-list string-to-sort-on record)
	()
  (:constructor make-index-database-entry
   (page-counter contents-list string-to-sort-on record))
  :readable-instance-variables
  )

(defmethod 1(add-index-entry index-database)0 (page-counter contents-list string-to-sort-on
							  record)
  (push (make-index-database-entry page-counter contents-list string-to-sort-on record)
	entries))

(defmethod 1(directives-for-index index-database)0 ()
  (tv:noting-progress ("Preparing index entries for sort")
    (mapc #'set-up-string-to-sort-on entries))
  (tv:noting-progress ("Sorting index entries")
    (setq entries (sort entries #'index-database-entry-lessp)))
  (tv:noting-progress ("Sending index entries")
    (let ((directives
	    (making-sage-directives ()
	      (in-environment (() indexenv)
		(let ((entries-to-do (length entries))
		      (entries-done 0)
		      (entries entries))
		  (send-directives-for-index-entries
		    (named-lambda next-entry ()
		      (tv:note-progress (incf entries-done) entries-to-do)
		      (pop entries))))))))
      directives)))

(defmethod 1(set-up-string-to-sort-on index-database-entry)0 ()
  (using-resource (into-string string-temp)
    (etypecase string-to-sort-on
      (string (prune-non-sorting-characters string-to-sort-on nil into-string))
      (cons
	(sortable-string-from-contents-list string-to-sort-on into-string))
      (null
	(sortable-string-from-contents-list contents-list into-string)
	(ecase (lookup-style-parameter 'indexstyle)
	  ((nil permuted simple)
	   ())
	  (multilevel
	    (string-nconc into-string " 1"))))
      (sage-text-structure
	(prune-non-sorting-characters
	  (string-thin (zwei:string-interval string-to-sort-on)))))
    (setq string-to-sort-on (string-trim *white-space* into-string))))

(defun 1send-directives-for-index-entries0 (next-entry)
  (let ((this-string ())
	(this-contents-list ())
	(this-number ()))
    ;; ---It wouldn't be too hard to extend this to recognize runs of page numbers
    ;; (22,23,24,25) and turn them into hyphenated runs (22-25).  I've exhausted
    ;; today's supply of gumption, however.
    (loop
      (let ((entry (funcall next-entry)))
	(when (null entry) (return nil))
	(let* ((entry-string (index-database-entry-string-to-sort-on entry))
	       (entry-contents-list (index-database-entry-contents-list entry))
	       (entry-counter (index-database-entry-page-counter entry))
	       (entry-number (and entry-counter (send entry-counter :value))))
	  (cond ((and (string= entry-string this-string)
		      (contents-list-equal entry-contents-list this-contents-list))
		 (unless (eql entry-number this-number)
		   (when entry-number
		     (when this-number (write-string ", "))
		     (sage-command () 'counter-value-as-number
				   (list entry-counter)))
		   (setq this-number entry-number)))
		(T
		 (terpri)
		 (setq this-string entry-string
		       this-contents-list entry-contents-list
		       this-number entry-number)
		 (in-presentation (()
				   :type (type-of entry)
				   :object entry
				   :presentation-options '(:single-box t))
		   (sage-contents-list () entry-contents-list)
		   (write-string ", ")
		   ;;(sage-command () 'collect-right-flushing)
		   (when entry-number
		     (sage-command () 'counter-value-as-number
				   (list entry-counter)))))))))))

(defgeneric 1contents-list-equal0 (contents1 contents2)
  (:function
    (cond ((and (consp contents1) (consp contents2))
	   (loop
	     (unless (or (eql (car contents1) (car contents2))
			 (contents-list-equal (car contents1) (car contents2)))
	       (return nil))
	     (setq contents1 (cdr contents1)
		   contents2 (cdr contents2))
	     (cond ((endp contents1)
		    (return (endp contents2)))
		   ((endp contents2) (return nil)))))
	  ((and (atom contents1) (atom contents2))
	   (or (eql contents1 contents2)
	       (and (eql (type-of contents1) (type-of contents2))
		    (or (and (typep contents1 'sage-directive)
			     (funcall (flavor:generic contents-list-equal)
				      contents1 contents2))
			(and (stringp contents1)
			     (string= contents1 contents2))))))
	  (T nil)))
  (:method (sage-envr)
   (and (eq envr-name (send contents2 :envr-name))
	(let ((other-mods (send contents2 :envr-mods)))
	  (or (and (null envr-mods) (null other-mods))
	      (contents-list-equal envr-mods (send contents2 :envr-mods))))
	(contents-list-equal contents-list (send contents2 :contents-list))))
  (:method (sage-command)
   (and (eq command-name (send contents2 :command-name))
	(let ((other-parameter (send contents2 :parameter)))
	  (or (and (null parameter) (null other-parameter))
	      (contents-list-equal parameter other-parameter)))))
  (:method (sage-text-structure)
   (zwei:interval-equal interval nil nil
			(sage-text-structure-interval contents2) nil nil
			T))
  (:method (sage-reference)
   (and (eq (sage-reference-decode-view self)
	    (sage-reference-decode-view contents2))
	(eq record-group (sage-reference-record-group contents2))))
  (:method (sage-macro-call)
   (and (eq macro-name (send contents2 :macro-name))
	(contents-list-equal macro-args (send contents2 :macro-args))))
  (:method (sage-picture)
   (and (eq type (sage-picture-type contents2))
	(equal file-name (sage-picture-file-name contents2))
	(equal name (sage-picture-name contents2)))))

(defsubst 1combine-contents-list-hashes0 (h1 h2)
  (logxor (rot h1 11) (rot h2 7)))

(defgeneric 1contents-list-hash0 (contents)
  (:function
    (typecase contents
      (cons
	(let ((hash (contents-list-hash (first contents))))
	  (dolist (x (rest contents))
	    (setq hash (combine-contents-list-hashes hash (contents-list-hash x))))
	  hash))
      (sage-directive
	(funcall (flavor:generic contents-list-hash) contents))
      (otherwise (sxhash contents))))
  (:method (sage-envr)
   (combine-contents-list-hashes
     (contents-list-hash envr-name)
     (combine-contents-list-hashes
       (contents-list-hash envr-mods)
       (contents-list-hash contents-list))))
  (:method (sage-command)
   (combine-contents-list-hashes
     (contents-list-hash command-name)
     (contents-list-hash parameter)))
  (:method (sage-text-structure)
   (contents-list-hash-zwei-interval interval))
  (:method (sage-reference)
   (combine-contents-list-hashes
     (contents-list-hash (sage-reference-decode-view self))
     (contents-list-hash record-group)))
  (:method (sage-macro-call)
   (combine-contents-list-hashes
     (contents-list-hash macro-name)
     (contents-list-hash macro-args)))
  (:method (sage-picture)
   (combine-contents-list-hashes
     (contents-list-hash type)
     (combine-contents-list-hashes
       (contents-list-hash file-name)
       (contents-list-hash name))))
  (:method (record-group)
   (sxhash self))
  (:method (doc-record)
   (sxhash self))
  )

(defun 1contents-list-hash-zwei-interval0 (interval)
  (let ((hash nil))
    (zwei:do-lines-in-interval (interval line first-index last-index)
      (stack-let ((a (make-array (- last-index first-index)
				 :element-type (array-element-type line)
				 :displaced-to line
				 :displaced-index-offset first-index)))
	(if (null hash)
	    (setq hash (sys:sxhash-string a))
	    (setq hash (combine-contents-list-hashes
			 hash
			 (combine-contents-list-hashes
			   (si:sxhash-character #\return)
			   (sys:sxhash-string a)))))))
    hash))

;;(FUNDEFINE '(FLAVOR:METHOD DIRECTIVES-FOR-INDEX INDEX-DATABASE-ENTRY))
#+Ignore
(2 0 (NIL 0) (NIL NIL :SMALL) "TVFONT")(defmethod (3 0 (NIL 0) (NIL :BOLD :SMALL) "TVFONTCB")(directives-for-index index-database-entry)2 ()
  (in-presentation (()
		    :type (type-of self)
		    :object self
		    :presentation-options '(:single-box t))

    (sage-contents-list () contents-list)
    (sage-command () 'collect-right-flushing)
    (sage-command () 'counter-value-as-number
		  (list page-counter)))
  (terpri))

0(defun 1index-database-entry-lessp0 (entry1 entry2)
  (let ((dif (string-compare (index-database-entry-string-to-sort-on entry1)
			     (index-database-entry-string-to-sort-on entry2))))
    (cond ((< dif 0) T)
	  ((> dif 0) nil)
	  (T (let ((cl1 (index-database-entry-contents-list entry1))
		   (cl2 (index-database-entry-contents-list entry2)))
	       (if (contents-list-equal cl1 cl2)
		   (flet ((counter-value (e)
			    (let ((counter (index-database-entry-page-counter e)))
			      (and counter (send counter :value)))))
		     (let ((v1 (counter-value entry1))
			   (v2 (counter-value entry2)))
		       (cond ((eql v1 v2) nil)
			     ((null v1) T)
			     ((null v2) nil)
			     (T (< v1 v2)))))
		   ;; I hope it is rare that we get (4 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")here0!
		   (string-lessp (filtered-string-from-contents-list cl1)
				 (filtered-string-from-contents-list cl2))))))))

(defmacro 1map-over-index-database0 (database entry-var &body body)
  `(map-over-index-database-1 ,database
			      (dw:named-continuation map-over-index-database (,entry-var)
				,@body)))

(defmethod 1(map-over-index-database-1 index-database)0 (continuation)
  (declare (sys:downward-funarg continuation))
  (loop for entry in entries do
    (funcall continuation entry)))

(defmethod 1(find-index-entry-matching index-database)0 (string &key (test #'string-equal))
  (map-over-index-database self entry
    (when (funcall test string (index-database-entry-string-to-sort-on entry))
      (return-from find-index-entry-matching entry))))

(defmethod 1(record-group-index-completion record-group)0 ()
  (cond ((concept-type-p type)
	 (record-group-topic-completion self))
	(t
	 (let ((record (find-record-for-lookup self)))
	   (format nil "~A ~A"
		   (record-group-topic-completion self)
		   (coerce-record-type (doc-record-source-type record) 'print-name))))))

(defmethod 1(find-index-entry-for-record-group index-database)0 (record-group)
  (let ((key (record-group-index-completion record-group)))
    (find-index-entry-matching self key)))

(define-command-gbox-method 1(command-gbox-insert-generated-text caption)0 ()
  (let ((counter (or (send environment :environment-counter)
		     (send environment :attached-counter))))
    (when counter
      (note-counter-touch counter 'use)
      (setq counter (clone-counter-and-lineage counter)))
    (let* ((counter-gbox (make-counter-command-gbox self))
	   (result
	     (splice-contents-list
	       self environment
	       (making-sage-directives ()
		 (in-environment (() CaptionEnv)
		   (when counter
		     (in-environment (() CaptionCounterEnv)
		       (sage-command () 'counter-value-as-number (list counter))
		       (sage-command () 'already-has-gbox-kludge (list counter-gbox))))
		   (sage-contents-list ()
				       (trim-whitespace-from-ends-of-contents-list
					 caption)))))))
      (when counter
	(setf (counter-command-gbox-cloned-counter counter-gbox) counter)
	(splice-box-out self))
      result)))

(define-command-gbox-method 1(render-for-table-of-contents caption)0 ()
  (when (typep self 'counter-command-gbox)
    ;; There will be no counter if the Caption command was not within Figure or Table.
    (let ((counter (counter-command-gbox-cloned-counter self)))
      (render-for-toc self self
		      (ecase (send counter :name)
			(figurecounter 'figures)
			(tablecounter 'tables))
		      (trim-whitespace-from-ends-of-contents-list caption)
		      (named-lambda render-regular-toc (title counter-contents)
			(render-regular-toc '(TcC) title counter-contents))))))

(defflavor 1permuted-index-database-entry
0	(left-half
	 right-half
	 left-half-string-to-sort-on
	 right-half-string-to-sort-on
	 page-numbers
	 unpermuted-entry)
	()
  (:constructor 1make-permuted-index-database-entry
0   (left-half right-half
	      left-half-string-to-sort-on right-half-string-to-sort-on
	      page-numbers unpermuted-entry)))

(defmethod 1(permuted-index-database-entry-sort-strings permuted-index-database-entry)0 ()
  (values left-half-string-to-sort-on right-half-string-to-sort-on))
(defmethod 1(permuted-index-database-entry-secondary-sort-strings permuted-index-database-entry)0 ()
  (values
    (filtered-string-from-contents-list left-half)
    (filtered-string-from-contents-list right-half)))

(defmethod 1(directives-for-permuted-index index-database)0 ()
  (let ((permuted-entries (set-up-permuted-index-entries entries)))
    (tv:noting-progress ("Sorting index entries")
      (setq permuted-entries
	    (sort permuted-entries #'permuted-index-database-entry-lessp)))
    (let ((directives
	    (making-sage-directives ()
	      (sage-command T 'unnumbered '(index))
	      (in-environment (T permutedindexenv)
		(sage-command T 'tabclear)
		(sage-command T 'tabset '("18picas"))
		(let ((sort-start #\null))
		  (tv:dolist-noting-progress (e permuted-entries "Sending index entries")
		    (setq sort-start
			  (send-directives-for-permuted-index e sort-start))))))))
      directives)))

(defmethod 1(send-directives-for-permuted-index permuted-index-database-entry)0 (sort-start)
  (let ((this-start (char-upcase (aref right-half-string-to-sort-on 0))))
    (unless (char-equal this-start sort-start)
      (in-environment (T permutedindexheaderenv)
	(write-char this-start)
	(sage-command T 'collect-centering)
	(write-char this-start)
	(sage-command T 'collect-right-flushing)
	(write-char this-start))
      (setq sort-start this-start)))
  (terpri)
  (in-presentation (()
		    :type (type-of unpermuted-entry)
		    :object unpermuted-entry
		    :presentation-options '(:single-box t))
    (sage-command T 'collect-right-flushing)
    (sage-contents-list T left-half)
    (in-environment (T R) (loop repeat 4 do (sage-command T 'literal-space)))
    (sage-command T 'tab-to-tab-stop)
    (sage-contents-list T right-half)
    (loop repeat 4 do (sage-command T 'literal-space))
    (let ((comma nil)
	  (pending-strings ()))
      (flet ((flush-pending-strings ()
	       (when pending-strings
		 (setq pending-strings (nreverse pending-strings))
		 (let ((length 0)
		       (element-type 'string-char))
		   (dolist (string pending-strings)
		     (incf length (length string))
		     (when (string-fat-p string) (setq element-type 'character)))
		   (let ((larger-string (make-array length :element-type element-type)))
		     (let ((i 0))
		       (dolist (string pending-strings)
			 (replace larger-string string :start1 i)
			 (incf i (length string))))
		     (sage-contents-list T (list larger-string))))
		 (setq pending-strings ()))))
	(dolist (pagen page-numbers)
	  (when comma (push ", " pending-strings))
	  (let ((counter-contents-list (counter-value-contents-list pagen :reference)))
	    (cond ((and (= 1 (length counter-contents-list))
			(stringp (first counter-contents-list)))
		   (push (first counter-contents-list) pending-strings))
		  (T (flush-pending-strings)
		     (sage-contents-list T counter-contents-list))))
	  (setq comma T))
	(flush-pending-strings))))
  sort-start)

(defun 1set-up-permuted-index-entries0 (index-entries)
  (dolist (e index-entries)
    (set-string-to-sort-on-to-filtered-string-from-contents-list e))
  (let ((permuted-entries ()))
    (let ((table (make-hash-table :test #'string-equal))
	  (*inhibit-sort-on-these* *standard-inhibit-list*)
	  (*case-inhibit-sort-on-these* *case-sensitive-inhibit-list*)
	  )
      (tv:dolist-noting-progress (entry index-entries "Adding index entries to table")
	(add-index-entry-to-hash-table entry table))
      (tv:maphash-noting-progress
	(named-lambda maphash (key entries)
	  (ignore key)
	  (setq permuted-entries
		(make-permutable-index-entries
		  (first entries)
		  (flet ((counter-value (c) (send c :value)))
		    (sort (delete-duplicates
			    (delete nil (mapcar #'index-database-entry-page-counter entries))
			    :key #'counter-value)
			  #'< :key #'counter-value))
		  permuted-entries)))
	table "Merging index table entries"))
    permuted-entries))

(defmethod 1(set-string-to-sort-on-to-filtered-string-from-contents-list index-database-entry)
0	   ()
  (setq string-to-sort-on (filtered-string-from-contents-list contents-list)))

(defmethod 1(add-index-entry-to-hash-table index-database-entry)0 (table)
  (modify-hash table string-to-sort-on
	       (lambda (ignore value ignore)
		 (cons self value))))

(defmethod 1(make-permutable-index-entries index-database-entry)0 (page-counters list-so-far)
  (do-combinations ((left right) (chunked-contents-list contents-list))
    (unless (matches-inhibit-entry (first right))
      (flet ((make-sortable-string (contents-list)
	       (using-resource (into-string string-temp)
		 (sortable-string-from-contents-list contents-list into-string)
		 (string-trim *white-space* into-string))))
	(push (make-permuted-index-database-entry
		(trim-whitespace-from-ends-of-contents-list left)
		(trim-whitespace-from-ends-of-contents-list right)
		(make-sortable-string left) (make-sortable-string right)
		page-counters self)
	      list-so-far))))
  list-so-far)

(defun 1permuted-index-database-entry-lessp0 (e1 e2)
  (multiple-value-bind (left1 right1)
      (permuted-index-database-entry-sort-strings e1)
    (multiple-value-bind (left2 right2)
	(permuted-index-database-entry-sort-strings e2)
      (cond ((string-equal right1 right2)		;Right halves are the same
	     (cond ((and (null left1) left2) t)	;Can't use string-lessp reasonably on NIL
		   ((null left2) nil)		;because it coerces to "NIL"
		   (t
		    ;;So base sort on left halves
		    (cond ((string-lessp left1 left2)
			   T)
			  ((string-equal left1 left2)
			   ;; left halves and right halves are equal.
			   ;; Look at non-sorting chars, so "Paging File" sorts
			   ;; before "Paging-file" even though both sort keys are "pagingfile"
			   ;; Pretty yucky to cons these, but at least it's pretty rare.
			   (permuted-index-database-entry-secondary-lessp e1 e2)
			   )
			  (T nil)))))
	    ;;((null right1) t)			;Just for completeness; can't happen here
	    ;;((null right2) nil)		;Just for completeness; can't happen here
	  (T					;Right halves different so sort on them
	   (string-lessp right1 right2))))))

(defun 1permuted-index-database-entry-secondary-lessp0 (e1 e2)
  (multiple-value-bind (left1 right1)
      (permuted-index-database-entry-secondary-sort-strings e1)
    (multiple-value-bind (left2 right2)
	(permuted-index-database-entry-secondary-sort-strings e2)
      (cond ((string-lessp right1 right2)
	     T)
	    ((string-equal right1 right2)
	     (string-lessp left1 left2))
	    (T nil)))))

(compile-flavor-methods permuted-index-database-entry tag-data)
