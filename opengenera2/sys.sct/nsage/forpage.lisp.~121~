;;;-*- Syntax: Common-lisp; Mode: Lisp; Package: Nsage; Lowercase: T; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;; The parts of the formatter having to do with page formatting.
;; Take lines until they add up in height to a column.
;; Take columns until they number columns-per-page (often 1 column per page)
;; Take pages until they run out

;;---SINK is from the top of page, not top margin -- Scribe Rel5 Release Notes, p. 20.

;;---debugging code moved to end of this file
(pushnew #p"sys:nsage;.bfd.newest" fed:*screen-font-bfd-search-paths*)

;;; Flavor definitions moved to box-flavors.lisp, to break a circular dependency.  --RWK

(defmacro D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")do-lines-in-column0 ((line-var column-box) &body body)
  `(do-lines-in-column-1 ,column-box
			 (named-lambda do-lines-in-column (,line-var)
			   (declare (sys:downward-function))
			   ,@body)))

(defmethod 1(do-lines-in-column-1 column-box)0 (continuation)
  (do-box-successors (line first-line)
    (funcall continuation line)
    (when (eql line last-included-line) (loop-finish))))

(defmacro 1do-gboxes-in-line-hbox0 ((gbox-var hbox) &body body)
  `(do-gboxes-in-line-hbox-1 ,hbox
			     (named-lambda do-gboxes-in-line-hbox (,gbox-var)
					   (declare (sys:downward-function))
					   ,@body)))

(defmethod 1(do-gboxes-in-line-hbox-1 line-hbox)0 (continuation)
  (do-line-gboxes (gbox first-gbox newline-gbox)
    (funcall continuation gbox)))

(defun 1take-line-but-not-tiny0 (source)
  (let ((*make-environments-tiny* nil))
    (send source :take-line)))

(defun 1take-line-but-not-tiny-saving-state0 (source)
  (let ((line (take-line-but-not-tiny source)))
    (prog1 line
	   (send source :take-it-from line))))

(defflavor 1auxiliary-page-data
0	((footnotes nil)
	 (footnotes-separator-size nil)
	 (linesfootnotes nil)
	 (fixed-location-lines nil))
	()
  :writable-instance-variables
  (:constructor 1make-stack-auxiliary-page-data0 (&key (area :stack))))

(defmethod 1(data-for-page-box auxiliary-page-data)0 ()
  (list footnotes footnotes-separator-size fixed-location-lines))

(defmacro 1with-stack-auxiliary-page-data0 ((data) &body body)
  `(with-stack-auxiliary-page-data-1
     (dw:named-continuation with-stack-auxiliary-page-data (,data)
       ,@body)))

(defun 1with-stack-auxiliary-page-data-10 (continuation)
  (sys:with-data-stack
    (let ((auxiliary-page-data (make-stack-auxiliary-page-data))
	  (hash-table (make-hash-table :area :stack)))
      (setf (auxiliary-page-data-linesfootnotes auxiliary-page-data) hash-table)
      (funcall continuation auxiliary-page-data))))

(defun 1show-page-number-help0 (pages stream string-so-far)
  (ignore string-so-far)			;so far
  (format stream "~&You are being asked to enter a page number for one of the pages in this document.")
  (let ((start-of-run nil)
	(end-of-run nil)
	(runs nil))
    (labels ((process-page-number (page)
	       (let ((pn (page-box-page-number page)))
		 (cond ((and end-of-run
			     (page-box-list-of-columns page)
			     (= (1+ (cdr end-of-run)) (cdr pn)))
			(setq end-of-run pn))
		       ((page-box-list-of-columns page)
			(when end-of-run (emit-current-run))
			(setq start-of-run pn
			      end-of-run pn))
		       (t nil))))
	     (emit-current-run ()
	       (push (cons start-of-run end-of-run) runs)))
      (map () #'process-page-number pages)
      (emit-current-run))
    (setq runs (nreverse runs))
    (flet ((present-run (run stream)
	     (destructuring-bind (start-of-run . end-of-run) run
	       (cond ((eq start-of-run end-of-run)
		      (format stream "~A" (car start-of-run)))
		     (t
		      (format stream "a page number between ~A and ~A"
			      (car start-of-run) (car end-of-run)))))))
      (cond ((= (length runs) 1)
	     (format stream "~&You may enter ")
	     (present-run (first runs) stream))
	    (t
	     (format stream "~&The possible choices are:")
	     (indenting-output (stream 2)
	       (terpri stream)
	       (format-textual-list runs
				    #'present-run
				    :conjunction "or"
				    :stream stream))))
      (write-char #\. stream))))

(define-presentation-type 1page-number0 ((&key pages))
   :description "page"
   :parser ((stream &key original-type initially-display-possibilities)
	    (flet ((key (p)
		     (car (page-box-page-number p))))
	      (values
		(dw:with-accept-help (((:subhelp :override)
					(lambda (stream stuff-so-far)
					  (show-page-number-help pages stream stuff-so-far))))
		(dw:completing-from-suggestions (stream
						  :type original-type
						  :initially-display-possibilities
						  initially-display-possibilities)
		  (map () (lambda (p)
			    (when (page-box-list-of-columns p)
			      (dw:suggest (key p) (key p)))) pages))))))
   :printer ((thing stream)
	     (write-string thing stream)))

(defun 1construct-page-counter-info0 (page-counter)
  (cons
    (filtered-string-from-contents-list
      (counter-value-contents-list page-counter :reference))
    (send page-counter :value)))

(defun 1take-page0 (source-of-formatted-sage-lines heading-state previous-page)
  (let ((source source-of-formatted-sage-lines))
    (when (send source :available-line-hbox)
      (set-up-page-ambient-values))
    (with-stack-auxiliary-page-data (auxiliary-page-data)
      (let ((first-line (take-line-but-not-tiny source)))
	(when first-line
	  (let ((page-env (send (send first-line :first-gbox) :environment)))
	    (send source :take-it-from first-line)
	    (let ((columns
		    (loop repeat (send page-env :columns)
			  for first-time = t then nil
			  for column = (new-take-column
					 source page-env
					 :at-top-of-page-p first-time
					 :auxiliary-page-data auxiliary-page-data)
			  when column collect it
			  else do (loop-finish))))
	      (loop for (first second) on columns
		    do (setf (box-next first) second)
		       (when second (setf (box-prev second) first)))
	      (let ((page-box (make-page-box columns)))
		(setf (page-box-page-environment page-box) page-env)
		(setf (box-prev page-box) previous-page)
		(when previous-page
		  (setf (box-next previous-page) page-box))
		(setf (page-box-page-number page-box)
		      (construct-page-counter-info (find-page-counter)))
		(setf (page-box-auxiliary-page-data page-box)
		      (data-for-page-box auxiliary-page-data))
		(annotate-page-dependents page-box)
		;; Redo this in case something has fiddled with page number
		(setf (page-box-page-number page-box)
		      (construct-page-counter-info (find-page-counter)))
		(flet ((headings (immediate even-or-odd head-or-foot
					    left center right second-line)
			 (declare (sys:downward-function))
			 (update-heading-state
			   heading-state
			   immediate even-or-odd head-or-foot
			   left center right second-line)))
		  (annotate-page-box-headings page-box #'headings))
		(page-box-format-headings
		  page-box
		  (copy-page-headings (heading-state-this-heading heading-state))
		  (copy-page-headings (heading-state-this-footing heading-state))
		  (copy-page-tabs (heading-state-page-tabs heading-state)))
		(advance-page-heading-state heading-state)
		page-box))))))))

(defun 1set-up-page-ambient-values0 ()
  (let ((page-counter (find-page-counter)))
    (send page-counter :set-value (1+ (send page-counter :value))))
  (let ((sectionnumber (lookup-ambient-value 'sectionnumber :error-p nil))
	(sectiontitle (lookup-ambient-value 'sectiontitle :error-p nil)))
    (if sectionnumber
	(set-ambient-value 'topsectionnumber sectionnumber 'counter)
	(set-ambient-value 'topsectionnumber nil nil))
    (if sectiontitle
	(set-ambient-value 'topsectiontitle sectiontitle 'contents-list)
	(set-ambient-value 'topsectiontitle nil nil))
    (set-ambient-value 'firstsectionnumber nil nil)
    (set-ambient-value 'firstsectiontitle nil nil))
  ())

(defun 1make-dummy-page0 (previous-page)
  (assert (not (null previous-page)))
  (let ((page-box (make-page-box ())))
    (setf (page-box-page-environment page-box)
	  (page-box-page-environment previous-page))
    (setf (box-prev page-box) previous-page)
    (setf (box-next previous-page) page-box)
    (let ((new-number (1+ (cdr (page-box-page-number previous-page)))))
      (setf (page-box-page-number page-box)
	    (cons (format nil "~D" new-number) new-number)))
    page-box))

(defmethod 1(advance-page-heading-state heading-state)0 ()
  (setq this-heading (copy-page-headings next-heading)
	this-footing (copy-page-headings next-footing))
  nil)

(defmethod 1(update-heading-state heading-state)0 (immediate even-or-odd head-or-foot
						  left center right second-line)
  (cond ((eq head-or-foot ':tabs)
	 (alter-tabs page-tabs left center right))
	(t
	 (labels ((alter (heading footing)
		    (ecase head-or-foot
		      (:head (alter-it heading))
		      (:foot (alter-it footing))))
		  (alter-it (heading)
		    (ecase even-or-odd
		      (:even
			(alter-heading-even heading left center right second-line))
		      (:odd
			(alter-heading-odd heading left center right second-line))
		      (:both
			(alter-heading-both heading left center right second-line))))
		  )
	   (when immediate
	     (alter this-heading this-footing))
	   (alter next-heading next-footing)))))

(defmethod 1(alter-tabs page-tabs)0 (new-first-line new-second-line new-y)
  (setq first-line new-first-line second-line new-second-line
	y-location (coerce-to-distance new-y :vertical 0)))

(defmethod 1(alter-heading-even page-headings)0 (left center right second-line)
  (setq even-left left
	even-center center
	even-right right
	even-second-line second-line))

(defmethod 1(alter-heading-odd page-headings)0 (left center right second-line)
  (setq odd-left left
	odd-center center
	odd-right right
	odd-second-line second-line))

;; Alters headings for both even and odd pages.
(defmethod 1(alter-heading-both page-headings)0 (left center right second-line)
  (setq even-left left odd-left left
	even-center center odd-center center
	even-right right odd-right right
	even-second-line second-line odd-second-line second-line))

(defmethod 1(annotate-page-box-headings page-box)0 (headings-function)
  (dolist (column list-of-columns)
    (do-lines-in-column (line column)
      (do-gboxes-in-line-hbox (gbox line)
	(annotate-page-box-headings gbox headings-function)))))

(defmethod 1(annotate-page-box-headings basic-gbox :default)0 (ignore)
  )
(defmethod 1(annotate-page-box-headings command-gbox)0 (headings-function)
  (command-annotate-page-box-headings self headings-function))

(define-command-gbox-generic 1command-annotate-page-box-headings
0			     (headings-function)
  (ignore headings-function)
  )

;;---If it's an error to specify both the parser should have said so.
;; Too bad it doesn't/can't
(defun 1decide-even-or-odd0 (even odd)
  (cond (even :even)
	(odd :odd)
	(T :both)))

(define-command-gbox-method 1(command-annotate-page-box-headings pageheading)
0			    (headings-function)
  (funcall headings-function
	   immediate (decide-even-or-odd even odd) :head
	   left center right line))

(define-command-gbox-method 1(command-annotate-page-box-headings pagefooting)
0			    (headings-function)
  (funcall headings-function
	   immediate (decide-even-or-odd even odd) :foot
	   left center right line))

(define-command-gbox-method 1(command-annotate-page-box-headings pagetabs)
0			    (headings-function)
  (funcall headings-function 'ignore 'ignore :tabs first second ylocation 'ignore))


(defmethod 1(page-box-format-headings page-box)0 (heading-spec footing-spec &optional page-tabs)
  (setq this-heading heading-spec
	this-footing footing-spec
	this-tabs page-tabs)
  ;;things like  @begin(hdg) left @= center @> right @* second-line @end(hdg)
  (flet ((doit (envr-name spec)
	   (let ((contents-list (page-headings-contents-list spec (cdr page-number))))
	     (and contents-list
		  (let ((source
			  (formatted-sage-text-line-source
			    (list (make-sage-envr envr-name ()
						  (cons (make-sage-command 'tabclear)
							contents-list)))
			    T)))
		    (let ((first-line (take-line-but-not-tiny source)))
		      ;If headings or footings are invisible, you won't get any gboxes
		      (when first-line
			(let* ((first-gbox (send first-line :first-gbox))
			       (envr (send first-gbox :environment))
			       (fixed-location (send envr :fixed-location)))
			  (when (zerop fixed-location)
			    (break "Losing zero fixed-location"))
			  (loop while (take-line-but-not-tiny source))
			  (send source :take-it-from)
			  (loop for line = (send source :take-line)
				while line
				do (when *make-environments-tiny*
				     (send line :make-environments-tiny)))
			  (values source fixed-location)))))))))
    (multiple-value-setq (formatted-heading heading-location)
      (doit 'HDG this-heading))
    (multiple-value-setq (formatted-footing footing-location)
      (doit 'FTG this-footing))
    (setq formatted-tabs (doit 'TBS this-tabs))
    (setq formatted-tabs-y-location (page-tabs-y-location this-tabs))
    ))

(defmethod 1(page-headings-contents-list page-headings)
0	   (page-number)
  (flet ((doit (left center right second)
	   (append left
		   (and center (list (make-sage-command 'collect-centering)))
		   center
		   (and right (list (make-sage-command 'collect-right-flushing)))
		   right
		   (and second (list (string #\newline)))
		   second)))
    (if (evenp page-number)
	(doit even-left even-center even-right even-second-line)
	(doit odd-left odd-center odd-right odd-second-line))))

(defmethod 1(page-headings-contents-list page-tabs)0 (page-number)
  (ignore page-number)
  (append first-line (and second-line (list (string #\Newline))) second-line))


(defmethod 1(annotate-page-dependents page-box)0 ()
  (dolist (column list-of-columns)
    (do-lines-in-column (line column)
      (do-gboxes-in-line-hbox (gbox line)
	(annotate-page-dependents gbox)))))

(defmethod 1(annotate-page-dependents basic-gbox :default)0 ()
  )

(defmethod 1(annotate-page-dependents command-gbox)0 ()
  ;; Remember!  These are not phases, but rather all operations
  ;; are performed on each box before moving on to the next one.
  (reconsider-sections self)
  (fiddle-with-page-number self)
  (render-for-table-of-contents self)
  (render-for-index self)
  (tags-note-page-number self)
  )



(defmethod 1(reannotate-line-hbox line-hbox)0 ()
  ;; this is enough to make take-line reannotate the line
  (variable-makunbound extra-space-above)
  )

(defmethod 1(line-has-significance-after-splicing line-hbox)0 ()
  (do-line-gboxes (gbox first-gbox newline-gbox)
    (unless (or (send gbox :newline?)
		(send gbox :paragraph-break?))
      (return-from line-has-significance-after-splicing t))))

(defun 1splice-line-hbox-chain-out0 (first-line-hbox last-line-hbox entry-gbox exit-gbox)
  (let* ((first-line-first-gbox (send first-line-hbox :first-gbox))
	 (last-line-last-gbox (send last-line-hbox :newline-gbox))
	 (new-first-line first-line-hbox)
	 (new-last-line last-line-hbox)
	 (take-it-from? nil))

    ;; if the entry gbox isn't the first gbox of first-line-hbox, then
    ;; we need to "substring" the first-line-hbox
    (unless (eq first-line-first-gbox entry-gbox)
      (setq new-first-line
	    (make-line-hbox first-line-first-gbox (box-prev entry-gbox)))
      
      (when (line-has-significance-after-splicing new-first-line)
	(setq take-it-from? new-first-line)
	(cond ((null (box-prev first-line-hbox))
	       ;; if it's the first line, we still want to splice in
	       ;; before it because we know that's ok
	       (setf (box-prev first-line-hbox) new-first-line)
	       (setf (box-next new-first-line) first-line-hbox))
	      (t
	       (splice-box-before first-line-hbox new-first-line)))
	(reannotate-line-hbox new-first-line))

      (setf (send first-line-hbox :first-gbox) entry-gbox)
      (reannotate-line-hbox first-line-hbox)
      )

    ;; ditto for exit gboxes
    (unless (eq last-line-last-gbox exit-gbox)
      (setq new-last-line
	    (make-line-hbox (box-next exit-gbox) last-line-last-gbox))
      (when (line-has-significance-after-splicing new-last-line)
	(unless take-it-from?
	  (setq take-it-from? new-last-line))
	(splice-boxes-after last-line-hbox new-last-line)

	(reannotate-line-hbox new-last-line))

      (setf (send last-line-hbox :newline-gbox) exit-gbox)
      (reannotate-line-hbox last-line-hbox)
      )

    (let ((first-gbox-in-chain (send first-line-hbox :first-gbox))
	  (last-gbox-in-chain (send last-line-hbox :newline-gbox)))
      (splice-box-chain-out first-gbox-in-chain last-gbox-in-chain))

    (when (box-next last-line-hbox)
      (reannotate-line-hbox (box-next last-line-hbox)))

    (splice-box-chain-out first-line-hbox last-line-hbox)
    take-it-from?))

(defun 1splice-line-hbox-chain-after-box-chain0 (existing-chain-head-hbox new-chain-head-hbox)
  (flet ((last-of-chain (chain-head)
	   (loop for box = chain-head then box-next
		 for box-next = (box-next box)
		 when (null box-next) return box)))
    (let* ((existing-chain-last-hbox (last-of-chain existing-chain-head-hbox))
	   (existing-chain-last-gbox (send existing-chain-last-hbox :newline-gbox))
	   (new-chain-first-gbox (send new-chain-head-hbox :first-gbox)))
      ;; fix gboxes
      (setf (box-next existing-chain-last-gbox) new-chain-first-gbox)
      (setf (box-prev new-chain-first-gbox) existing-chain-last-gbox)

      ;; fix hboxes
      (setf (box-prev new-chain-head-hbox) existing-chain-last-hbox)
      (setf (box-next existing-chain-last-hbox) new-chain-head-hbox))))

(defun 1splice-line-hbox-chain-after0 (existing-line-hbox chain-first-hbox)
  (let* ((existing-line-last-gbox (send existing-line-hbox :newline-gbox))
	 (chain-first-gbox (send chain-first-hbox :first-gbox)))
    
    (splice-box-chain-after existing-line-last-gbox chain-first-gbox)
    (splice-box-chain-after existing-line-hbox chain-first-hbox)))

;{force, forcewarn, ignore, warn}
(defvar 1*widow-action*0 'force)

(defun 1set-widow-action0 (new-value)
  (check-type new-value (member force forcewarn ignore warn))
  (setq *widow-action* new-value))

(defun 1format-widow-or-orphan-warning0 (type)
  (ecase type
    (widow
      (format t "~&It is ~:[being left at the top of the page~;being put in the margin of the previous page~]." (eq *widow-action* 'forcewarn)))
    (orphan
      (format t "~&It is ~:[being left at the bottom of the page~;being moved to the next page~]." (eq *widow-action* 'forcewarn)))))

(defmethod 1(warn-about-widow-or-orphan-line line-hbox)0 (type)
  (ecase *widow-action*
    ((Force Ignore) nil)
    ((Warn ForceWarn)
     (fresh-line)
     (write-char #\")
     (format-line-for-error-message-purposes self *standard-output*)
     (write-char #\")
     (format t " is a~:[ widow~;n orphan~] line." (eq type 'orphan))
     (format-widow-or-orphan-warning type))))

(defmethod 1(format-line-for-error-message-purposes line-hbox)0 (&optional
								(stream *standard-output*))
  (do-line-gboxes (gbox first-gbox newline-gbox)
    (format-gbox-for-error-message-purposes gbox stream)))

(defmethod 1(format-gbox-for-error-message-purposes basic-gbox :default)0 (stream)
  (ignore stream)
  )

(defmethod 1(format-gbox-for-error-message-purposes string-gbox)0 (stream)
  (write-string (substring string start-index end-index) stream))

(defmethod 1(format-gbox-for-error-message-purposes space-gbox)0 (stream)
  (write-char #\space stream))

(defmethod 1(format-gbox-for-error-message-purposes tab-character-gbox)0 (stream)
  (write-char #\Tab stream))

(defmethod 1(format-gbox-for-error-message-purposes cursor-motion-gbox)0 (stream)
  (write-char #\Space stream))

(defmethod 1(format-gbox-for-error-message-purposes command-gbox)0 (stream)
  (format-command-gbox-for-error-message-purposes self stream))

(define-command-gbox-generic 1format-command-gbox-for-error-message-purposes0 (stream)
  (ignore stream)
  ())

(define-command-gbox-method 1(format-command-gbox-for-error-message-purposes tab-to-tab-stop)
0			    (stream)
  (write-char #\Tab stream))

(define-command-gbox-method 1(format-command-gbox-for-error-message-purposes
			      (collect-right-flushing collect-centering
			       literal-space missing-special-character))0 (stream)
  (write-char #\Space stream))

(define-command-gbox-method 1(format-command-gbox-for-error-message-purposes em)0 (stream)
  (write-char #\- stream))

;;; Take column calls take-box again and again until
;;; the page is full.
;;; --- If something didn't fit on the last page, it goes down on this page
;;; no matter what, even if it means breaking a group.  A nice extension to this
;;; would be to put it back on the last page, now that we've actually decided
;;; to go ahead and break the group.
;;; Bite the bullet and make this a flavor-based program.
(defflavor 1box-taker
0	(
	 ;; the following are local state variables from 1take-box
0	 (at-top-of-box-p t)
	 (first-line nil)
	 (last-line nil)
	 (last-hinge-line nil)
	 (last-hinge-line-available-height nil)
	 (line-that-didnt-fit nil)

	 ;; the following are arguments to 1take-box
0	 source
	 available-height
	 floating-lines
	 (at-top-of-page-p)
	 (at-top-of-column-p)
	 (top-margin 0)
	 (bottom-margin 0)
	 (column-height 0)
	 (auxiliary-page-data))
	()
  (:constructor 1make-stack-box-taker0 (source available-height floating-lines
				       &key
				       at-top-of-page-p at-top-of-column-p (top-margin 0)
				       (bottom-margin 0) (column-height 0)
				       auxiliary-page-data
				       (area :stack))))

(defmacro 1with-stack-box-taker0 ((box-taker source available-height floating-lines params)
				&body body)
  `(with-stack-box-taker-1
     (dw:named-continuation with-stack-box-taker (,box-taker)
       ,@body)
     ,source ,available-height ,floating-lines
     ,params))

(defun 1with-stack-box-taker-10 (continuation source available-height floating-lines params)
  (sys:with-data-stack
    (let ((box-taker (apply #'make-stack-box-taker source available-height floating-lines params)))
      (funcall continuation box-taker))))

(defun 1take-box0 (source available-height floating-lines &rest args)
  (declare
    (arglist source available-height floating-lines
	     &key at-top-of-page-p at-top-of-column-p (top-margin 0) (bottom-margin 0)
	     (column-height 0)
	     auxiliary-page-data)
    (values first-line last-line remaining-height floating-lines end-of-page-p))	;?
  (with-stack-box-taker (box-taker source available-height floating-lines args)
    (take-box-1 box-taker)))

;; Here are the LABELS from 1take-box
0(defun-in-flavor 1(at-top-of-page-p box-taker)0 ()
  (and at-top-of-page-p at-top-of-box-p))

(defun-in-flavor 1(take-next-line box-taker)0 ()
  (declare (values line line-height))
  (let ((line (take-line-but-not-tiny source)))
    (when line
      (let ((page-break (send line :page-break)))
	(flet ((quick-return ()
		 (send source :take-it-from line)
		 (return-from take-next-line nil)))
	  (cond ((null page-break) nil)
		((eq page-break 'until-even)
		 (let ((page-counter (lookup-ambient-value 'page)))
		   (unless (and (evenp (send page-counter :value))
				(at-top-of-page-p))
		     (quick-return))))
		((eq page-break 'until-odd)
		 (let ((page-counter (lookup-ambient-value 'page)))
		   (unless (and (oddp (send page-counter :value))
				(at-top-of-page-p))
		     (quick-return))))
		((zerop page-break)
		 (when (not (at-top-of-page-p))
		   (quick-return)))
		(t (decf (send line :page-break))
		   (send source :take-it-from line)
		   (return-from take-next-line nil)))))

      (let ((height (send line :height))
	    (extra-space-above (send line :extra-space-above))
	    (page-need (send line :page-need)))
	(when (at-top-of-page-p)
	  (setq extra-space-above
		(max 0 (- (send line :extra-space-above) top-margin))))

	;; adjust this line's extra-space-above if it's not low enough on the page.
	(let ((sink-margin (send line :sink-margin)))
	  (unless (zerop sink-margin)		;quick test
	    (let ((where-we-are-now
		    (+ ; top-margin
		       (- column-height bottom-margin top-margin available-height)
		       extra-space-above
		       ;height
		       )))
	      (unless ( where-we-are-now sink-margin)
		(incf (send line :extra-space-above) (- sink-margin where-we-are-now))
		(setq extra-space-above (send line :extra-space-above))))))
	(cond ((< (+ extra-space-above (max height page-need))	;hmm
		  available-height)
	       (values line (+ height extra-space-above)))
	      ;; if the line is too big but we're at the top of the page
	      ;; put it down anyway
	      ((at-top-of-page-p)
	       ;; --- this is a potentially risky change that appears
	       ;; necessary.  I'd commented out a previous version of this
	       ;; that used 1at-top-of-page-p0 as the test, not 1(at-top-of-page-p)0.
	       ;; That caused all the output to come on one page!  (5/10/88 Doughty)
	       (values line (+ height extra-space-above)))
	      (t
	       (send source :take-it-from line)	;if the line doesn't fit, back up
	       (setq line-that-didnt-fit line)
	       nil))))))

(defun 1lines-share-same-group-p0 (line1 line2)
  (let ((envr1 (find-prevailing-floating-environment line1 nil))
	(envr2 (find-prevailing-floating-environment line2 nil)))
    (eq envr1 envr2)))

(defun 1find-prevailing-floating-environment0 (line-hbox &optional (just-float t))
  (let ((env
	  (do-line-gboxes (gbox (send line-hbox :first-gbox)
				(send line-hbox :newline-gbox))
	    (let* ((environment (send gbox :environment))
		   (float-disposition (send environment :float-disposition)))
	      (when (if just-float
			(member float-disposition
				'(float-defer float-whole-page fixed-location))
			(neq float-disposition 'free))
		(return environment))))))
    (when env
      (loop for e = env then sup
	    for sup = (send e :superior)
	    unless (and sup
			(eq (send e :float-disposition)
			    (send sup :float-disposition)))
	      return e))))

(defun 1find-envr-entry-gbox0 (line-hbox environment)
  (do-line-gboxes (gbox (send line-hbox :first-gbox)
			(send line-hbox :newline-gbox))
    (when (typep gbox 'envr-entry-gbox)
      (when (eq (send gbox :environment) environment)
	(return gbox)))))

(defun 1find-envr-exit-gbox0 (line-hbox exit-gbox)
  (do-line-gboxes (gbox (send line-hbox :first-gbox)
			(send line-hbox :newline-gbox))
    (when (eq gbox exit-gbox)
      (return gbox))))

(defun-in-flavor 1(splice-out-floating-lines box-taker)0 (current-line)
  (declare (values height-reclaimed last-line))
  (let ((height-reclaimed 0)
	first-of-chain
	last-of-chain
	entry-gbox
	exit-gbox
	(prev))
    ;; back up to start of this group
    (loop for back-line = current-line then (box-prev back-line)
	  with prevailing-environment = (find-prevailing-floating-environment current-line)
	  as envr-entry-gbox = (find-envr-entry-gbox back-line prevailing-environment)
	  do
      (incf height-reclaimed
	    (+ (send back-line :height)
	       (send back-line :extra-space-above)))
		   
	  when envr-entry-gbox
	    do
      ;; --- this might want to be at-top-of-column-p, I can't decide.
      ;; The idea is that if we've backed up to the top of the page
      ;; there's really no need to splice things out because they
      ;; won't fit on the next page either.
	      (when (and at-top-of-page-p
			 (eq back-line first-line))
		(throw 'backed-up-to-start-of-page t))
	      (setq first-of-chain back-line)

      ;; change the last line on the page to reflect the fact
      ;; that we spliced some stuff out.
	      (when (eq last-line current-line)
		(setq last-line (box-prev back-line)))
	      (send source :take-it-from first-of-chain)
	      (setq entry-gbox envr-entry-gbox)
	      (loop-finish))

    ;; set exit-gbox
    (setq exit-gbox (send entry-gbox :exit-gbox))

    ;; now, find end of this floating group using roughly the same mechanism.
    (loop for forward-line = (take-line-but-not-tiny source)
	  as envr-exit-gbox = (find-envr-exit-gbox forward-line exit-gbox)
	  when envr-exit-gbox
	    do
	      (setq last-of-chain forward-line)
	      (loop-finish))
    ;; at this point we know that first-of-chain and last-of-chain
    ;; span the set of gboxes we must remove.  However, the entry-gbox
    ;; may not be the first-gbox in first-of-chain and the exit-gbox
    ;; may not be the last-gbox in the last-of-chain.
    (setq prev (box-prev first-of-chain))
    (let ((take-it-from
	    (splice-line-hbox-chain-out first-of-chain last-of-chain
					entry-gbox exit-gbox)))
      (when take-it-from
	(setq prev (box-prev take-it-from))
	(send source :take-it-from take-it-from)))

    ;; throw away the footnotes as well
    ;; (except that splitting lines in half might change the EQness here.  Shit.
    (splice-out-footnotes-for-region self first-of-chain last-of-chain)

    (if floating-lines
	(splice-line-hbox-chain-after-box-chain floating-lines first-of-chain)
	(setq floating-lines first-of-chain))
    (values height-reclaimed prev)))

(defmethod 1(back-up-over-group-next-lines box-taker)0 (&optional (start-line last-line))
  (declare (values box-before-group-next height-reclaimed))
  (let ((height-reclaimed 0)
	(new-last-line ()))
    (loop for line = start-line then (box-prev line)
	  do
      (cond ((getf (send line :property-list) :group-next)
	     (incf height-reclaimed (send line :height))
	     (incf height-reclaimed (send line :extra-space-above))
	     (when (eq line first-line) 
	       (setq height-reclaimed 0
		     new-last-line ())
	       (loop-finish)))
	    (t (setq new-last-line line) (loop-finish))))
    (values new-last-line height-reclaimed)))

(defun 1line-fits-in-margin-p0 (line margin
			      &optional (max-line-height (coerce-to-distance
							   "1line" :vertical 0)))
  (let ((line-height (+ (send line :height) (send line :extra-space-above))))
    (and (< line-height margin)
	 ( line-height max-line-height))))
    
(defun-in-flavor 1(finish-box box-taker)0 ()
  (cond ((null last-line)
	 ;; didn't collect ANY lines for this box must be at the end of
	 ;; page.

	 1;;We know this is wrong!  See the private patch 
	 ;;sap:>widzinski>wt>patch>fix-floating-figures for the correct code.

	 0(values nil nil nil floating-lines t))	;---
	(t
	 (cond ((or (null line-that-didnt-fit)
		    (eq last-line 'float)	;kludge after kludge after kludge
		    ;; if there isn't a line after this that didn't
		    ;; fit, or if the line that didn't fit isn't from the same
		    ;; group as the line that did fit, then there's no problem,
		    ;; we're done
		    (not (lines-share-same-group-p last-line line-that-didnt-fit)))
		;; well, that's not actually true.
		;; If the line that didn't fit can be floated, then we should float
		;; it and continue.
		(cond ((and line-that-didnt-fit
			    (member (send line-that-didnt-fit :float-disposition)
				    '(float-defer float-whole-page)))
		       ;; Kludge.  Easier than inventing a different
		       ;; flow of control for this code, since I have to redesign
		       ;; this anyway for the recursive formatter.
		       (when (eq last-line 'float) (setq last-line nil))
		       (splice-out-floating-lines line-that-didnt-fit)
		       (values first-line last-line available-height
			       floating-lines nil))
		      (t
		       (values first-line last-line available-height
			       floating-lines t))))
	       (t
		(let ((float-disposition (send last-line :float-disposition)))
		  (ecase float-disposition

		    ((free)
		     (flet ((standard-return-values ()
			      ;; last line fit on page, allowed to break here,
			      ;; must be end of page.
			      (values first-line last-line available-height
				      floating-lines t)))
		       (cond ((neq last-line first-line)
			      (cond ((orphan-line-p last-line source)
				     (warn-about-widow-or-orphan-line
				       last-line 'orphan)
				     (ecase *widow-action*
				       ((ignore warn) (standard-return-values))
				       ((force forcewarn)
					;; put this line on the next page
					(send source :take-it-from last-line)
					(values first-line (box-prev last-line)
						(+ available-height
						   (send last-line :height)
						   (send last-line
							 :extra-space-above))
						floating-lines t))))
				    ((widow-line-p line-that-didnt-fit source)
				     (ecase *widow-action*
				       ((ignore warn) 
					(warn-about-widow-or-orphan-line
					  line-that-didnt-fit 'widow)
					(standard-return-values))
				       ((force forcewarn)

					;; put the line-that-didnt-fit down
					;; anyway, if it'll fit in the margin.
					(unless (line-fits-in-margin-p line-that-didnt-fit
								       bottom-margin)
					  (return-from finish-box
					    (standard-return-values)))

					;; certainly we need to check
					;; to see if there's a footnote
					;; on the widow line.
					(when (getf (send line-that-didnt-fit
							  :property-list)
						    :footnotes)
					  ;; Make this more of a PASCAL program!!
					  (return-from finish-box
					    (standard-return-values)))

					;; do the warning here, after we've decided
					;; to do something
					(warn-about-widow-or-orphan-line
					  line-that-didnt-fit 'widow)

					;; read out the line that didn't fit
					(take-line-but-not-tiny source)
					(values first-line line-that-didnt-fit
						(- available-height
						   (send line-that-didnt-fit
							 :height)
						   (send line-that-didnt-fit
							 :extra-space-above))
						floating-lines t))))
				    (t
				     (if (getf (send last-line :property-list) :group-next)
					 (multiple-value-bind (ll hr)
					     (back-up-over-group-next-lines self)
					   (when ll
					     (incf available-height hr)
					     (setq last-line ll))
					   (standard-return-values))
					 (standard-return-values)))))
			     (t (standard-return-values)))))

		    ((group)
		     (cond ((and last-hinge-line
				 (neq last-hinge-line first-line))
			    ;; not backing up to the start of the page
			    ;; last line didn't fit on page, back up to last
			    ;; hinge point
			    (multiple-value-bind (hinge-point height-reclaimed)
				(back-up-over-group-next-lines
				  self (box-prev last-hinge-line))
			      (cond ((null hinge-point)
				     ;; backed up to start of page
				     (values first-line last-line
					     available-height floating-lines t))
				    (t
				     (setq last-hinge-line (box-next hinge-point))
				     (incf available-height height-reclaimed)
				     (send source :take-it-from last-hinge-line)
				     (splice-out-footnotes-for-region
				       self last-hinge-line last-line)
				     (values first-line (box-prev last-hinge-line)
					     last-hinge-line-available-height
					     floating-lines t)))))
			   (t
			    ;; since we're backing up to the start of the
			    ;; page, nothing better to do than just finish the
			    ;; page here
			    (values first-line last-line available-height
				    floating-lines t))))
		    ((float-defer float-whole-page)
		     ;; we're allowed to float this group.  However, if
		     ;; we're already at the top of a column, what's the point?
		     ;; --- really, right here we should at least try to back up
		     ;; to a known hinge point to try over.
		     (cond ((and at-top-of-box-p
				 (or (and (eq float-disposition 'float-defer)
					  at-top-of-column-p)
				     (and (eq float-disposition 'float-whole-page)
					  at-top-of-page-p)))
			    (cond ((and last-hinge-line
					(neq last-hinge-line first-line))
				   ;; there was a hinge point in this page,
				   ;; let's use it
				   (send source :take-it-from last-hinge-line)
				   (values first-line (box-prev last-hinge-line)
					   last-hinge-line-available-height
					   floating-lines t))
				  (t (values first-line last-line available-height
					     floating-lines t))))
			   (t
			    (catch 'backed-up-to-start-of-page
			      (multiple-value-bind (reclaimed-height l-l)
				  (splice-out-floating-lines last-line)
				(incf available-height reclaimed-height)
				(return-from finish-box
				  (values first-line l-l
					  available-height floating-lines nil))))
			    (values first-line last-line available-height
				    floating-lines nil))))
		    ((fixed-location)
		     ;; --- no idea what to do here, yet.
		     (values first-line last-line
			     available-height floating-lines t)))))))))

(defmethod 1(splice-out-footnotes-for-region box-taker)0 (first-line last-line)
  (loop for line = last-line then (box-prev line)
	do
    (splice-out-footnotes-for-line self line)
    (when (eq line first-line) (loop-finish))))

;;; This makes sure that any footnotes for a line are removed.
(defmethod 1(splice-out-footnotes-for-line box-taker)0 (line)
  (let ((linesfootnotes (auxiliary-page-data-linesfootnotes auxiliary-page-data)))
    (let ((first-footnote-hbox (gethash line linesfootnotes)))
      (when first-footnote-hbox
	(let* ((first-gbox (send first-footnote-hbox :first-gbox))
	       (prev-hbox (box-prev first-footnote-hbox))
	       (prev-gbox (box-prev first-gbox)))
	  (cond (prev-hbox
		 (setf (box-next prev-hbox) nil)
		 (setf (box-next prev-gbox) nil))
		(t
		 ;; otherwise, this must be the only footnote we've collected
		 (setf (auxiliary-page-data-footnotes auxiliary-page-data) nil)))
	  (setf (gethash line linesfootnotes) nil)
	  ;; must increment available-height by the footnotes reclaimed
	  (let ((footnote-height (if (auxiliary-page-data-footnotes auxiliary-page-data)
				     0
				     (footnote-separator-height
				       (get-sage-stream *current-sage-device*)))))
	    ;; this relies on the fact that we splice out footnotes from bottom to top.
	    (do-box-successors (box first-footnote-hbox)
	      (incf footnote-height (+ (send box :height) (send box :extra-space-above))))
	    (incf available-height footnote-height)))))))

(defun-in-flavor 1(handle-line-footnotes box-taker)0 (footnotes-line)
  (let ((line-footnotes (getf (send footnotes-line :property-list) :footnotes)))
    (when line-footnotes
      (loop for footnote in line-footnotes
	    do
	(let ((contents-list (first (send footnote :parameter))))
	  (and contents-list
	       (let ((footnotes-source
		       (formatted-sage-text-line-source
			 (making-sage-directives ()
			   (in-environment (() fnenv)
			     (in-environment (() +)	;--- this should be in template
			       (sage-command () 'counter-value-as-number
					     (list (counter-command-gbox-cloned-counter
						     footnote))))
			     (sage-contents-list () contents-list)))
			 t)))
		 (loop for line = (send footnotes-source :take-line)
		       with first-line = nil
		       with this-footnote-height =
			 (if (auxiliary-page-data-footnotes auxiliary-page-data)
			     0
			     ;; include room for line
			     (let ((stream (get-sage-stream
					     *current-sage-device*)))
			       (footnote-separator-height stream)))
		       while line
		       do
		   (unless first-line (setq first-line line))
		   (incf this-footnote-height
			 (+ (send line :height) (send line :extra-space-above)))
		       finally
			 (decf available-height this-footnote-height)
			 (cond ((minusp available-height)
				;; no room for both the line and its footnotes.
				;; better put the line on the next page, unless
				;; this line is the top line on the page, in
				;; which case there's not much we can do.
				(unless (at-top-of-page-p)
				  (send source :take-it-from footnotes-line)
				  (setq line-that-didnt-fit footnotes-line)
				  (throw 'return-from-take-box (finish-box))))
			       (t
				;; remember that the footnotes for this line
				;; begin with first-line.
				(let ((linesfootnotes
					(auxiliary-page-data-linesfootnotes
					  auxiliary-page-data)))
				  (unless (gethash footnotes-line linesfootnotes)
				    (setf (gethash footnotes-line linesfootnotes)
					  first-line)))
				(let ((footnote-hbox-chain (auxiliary-page-data-footnotes
							     auxiliary-page-data)))
				  (if footnote-hbox-chain
				      (splice-line-hbox-chain-after-box-chain
					footnote-hbox-chain first-line)
				      (setf (auxiliary-page-data-footnotes auxiliary-page-data)
					    first-line))
				  (setf (auxiliary-page-data-footnotes-separator-size
					  auxiliary-page-data)
					(footnote-separator-width)))))))))))))

(defmethod 1(handle-line-fixed-location box-taker)0 (line)
  (when (eq (send line :float-disposition) 'fixed-location)
    (let* ((envr (find-prevailing-floating-environment line nil))
	   (fixed (send envr :fixed-location))
	   (entry-gbox (find-envr-entry-gbox line envr))
	   (exit-gbox (send entry-gbox :exit-gbox))
	   (last-of-chain))
      (letf ((at-top-of-page-p t)
	     (at-top-of-box-p t))
	;; bind above so footnotes annotater won't try to finish out this page
	;; if things don't fit.  (After all, "Fixed" means just that, even
	;; if you get ugly overwriting.)
	(loop for forward-line = line then (take-line-but-not-tiny source)
	      as envr-exit-gbox = (find-envr-exit-gbox forward-line exit-gbox)
	      do
	  (handle-line-footnotes forward-line)
	  (when envr-exit-gbox
	    (setq last-of-chain forward-line)
	    (loop-finish))))
      (unless last-of-chain
	(error "Couldn't find end of fixed enviroment"))
      (let ((line-extra-space-above (send line :extra-space-above))
	    (ll-extra-space-above (send last-of-chain :extra-space-above)))
	(let ((take-it-from (splice-line-hbox-chain-out
			      line last-of-chain entry-gbox exit-gbox)))
	  (when take-it-from
	    (send source :take-it-from take-it-from))
	  ;; because this gets clobbered by 1splice-line-hbox-chain-out
0	  (setf (send line :extra-space-above) line-extra-space-above)
	  (setf (send last-of-chain :extra-space-above) ll-extra-space-above)
	  ;; add this to the set of fixed stuff for this page
	  (push `(,line ,fixed) (auxiliary-page-data-fixed-location-lines auxiliary-page-data))
	  t)))))

(defmethod 1(take-box-1 box-taker)0 ()
  (catch 'return-from-take-box
    (loop doing
      (multiple-value-bind (line line-height)
	  (take-next-line)
	(cond ((null line)
	       (throw 'return-from-take-box (finish-box)))
	      ((and floating-lines
		    (member (send line :float-disposition)
			    '(float-defer float-whole-page)))
	       ;; This really is a huge Pascal Program
	       ;; SETQ line-that-didnt-fit and last-line
	       ;; to trigger floating-splicing mechanism
	       (setq line-that-didnt-fit line)
	       (unless last-line (setq last-line 'float))
	       (throw 'return-from-take-box (finish-box)))
	      (t
	       (unless (handle-line-fixed-location self line)
		 (when (send line :hinge-p)
		   (setq last-hinge-line line)
		   (setq last-hinge-line-available-height available-height))
		 (unless (zerop line-height) (setq at-top-of-box-p nil))
		 (decf available-height line-height)
		 (handle-line-footnotes line)
		 (unless first-line (setq first-line line))
		 (setq last-line line))))))))

(defun 1new-take-column0 (source page-env
			&key (at-top-of-page-p t) auxiliary-page-data
			&aux (at-top-of-column-p t))
  (let* ((top-margin (send page-env :top-margin))
	 (bottom-margin (send page-env :bottom-margin))
	 (column-height (send page-env :paper-height))
	 (top-y (- column-height top-margin))
	 (available-height (- top-y bottom-margin))
	 (floating-lines nil)
	 (first-line nil)
	 (last-line nil))
    (loop doing
      (multiple-value-bind (f-l l-l av-hei fl-li end-of-page-p)
	  (take-box source available-height floating-lines
		    :at-top-of-column-p at-top-of-column-p
		    :at-top-of-page-p at-top-of-page-p
		    :column-height column-height
		    :top-margin top-margin
		    :bottom-margin bottom-margin
		    :auxiliary-page-data auxiliary-page-data)
	(when (and f-l l-l)
	  (setq at-top-of-column-p nil
		at-top-of-page-p nil))
	(when end-of-page-p
	  (let ((column
		  (make-column-box :first-line (or first-line f-l)
				   :last-included-line (or l-l last-line)
				   :top-y top-y
				   :available-height av-hei)))
	    (when *make-environments-tiny*
	      (do-lines-in-column (line column)
		(send line :make-environments-tiny)))
	    ;; splice in floating lines so they'll be 
	    ;; read the next time we start a column
	    (when floating-lines
	      (let* ((line-to-splice-after 
		       (or l-l last-line (box-prev (send source :available-line-hbox))))
		     (line-after-that (box-next line-to-splice-after)))
		;; --- what if there aren't any more lines in the source
		;; but there are still some lines floating??
		(splice-line-hbox-chain-after
		  line-to-splice-after
		  floating-lines)
		(when line-after-that
		  (reannotate-line-hbox line-after-that)))
	      (send source :take-it-from floating-lines))
	    (return-from new-take-column column)))

	(setq available-height av-hei
	      floating-lines fl-li)
	(unless first-line (setq first-line f-l))
	(when l-l (setq last-line l-l))))))

;;; A line satisfies widow-line-p if it's the last line of a paragraph of
;;; more than one line.
(defun 1widow-line-p0 (line source)
  ;; expects line to be the next line available from the source.
  (when (line-all-white-p line)
    (return-from widow-line-p nil))
  (unless (first-line-of-paragraph-p line)
    (let ((next-line (take-line-but-not-tiny source)))
      (when (or (null next-line)
		(neq next-line line))
	(cerror "Proceed, ignoring the error" "widow-line-p is being asked of a line other than the first line on the page"))
      (prog1
	(let ((line-after-that (take-line-but-not-tiny source)))
	  (or (null line-after-that)
	      (first-line-of-paragraph-p line-after-that)
	      (line-all-white-p line-after-that)))
	(send source :take-it-from next-line)))))

;;; A line satisfies orphan-line-p if it's the first line of a paragraph and it's
;;; "smaller" than two normal lines, (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")and0 it's not a one-line paragraph.
;;; Hmm.  Maybe one-line paragraphs should always go on the next page
;;; so we avoid situations where we split
;;;
;;; Example:
;;;
;;; (defun foo ...)
;;;
;;; at the blank line.
(defun 1orphan-line-p0 (line source)
  (when (first-line-of-paragraph-p line)
    (let* ((height (send line :height))
	   (environment (send (send line :first-gbox) :environment))
	   (font-height (send environment :font-size))
	   (spacing (send environment :spacing)))
      (unless (> height (* 2 (+ font-height spacing (send *current-sage-device* :leading))))
	;; Here's where we figure out whether it's a one-line paragraph
	(let ((next-line (take-line-but-not-tiny source)))
	  (unwind-protect
	      (when (and next-line
			 (first-line-of-paragraph-p next-line))
		(return-from orphan-line-p nil))
	    (send source :take-it-from next-line))
	  t)))))

;; This is true if the line is made up solely of boxes that don't generate any
;; output.
(defmethod 1(line-all-white-p line-hbox)0 ()
  (let ((first-gbox-in-line t))
    (do-line-gboxes (gbox first-gbox newline-gbox)
      (when (send gbox :ink? first-gbox-in-line)
	(return-from line-all-white-p nil))
      (setq first-gbox-in-line nil)))
  t)

(defmethod 1(first-line-of-paragraph-p line-hbox)0 (&key (for-widow-elimination-p t))
  ;; if this line has a lot of whitespace above
  ;; it, where a lot is defined as more than one line's worth
  ;; then it is the first line of a paragraph as far as
  ;; widow and orphan elimination goes.
  (when for-widow-elimination-p
    ;; And if it's all blank, it's not the first line as far as widow and orphan
    ;; elimination goes.
    (when (line-all-white-p self)
      (return-from first-line-of-paragraph-p nil))
    (let* ((environment (send first-gbox :environment))
	   (font-height (send environment :font-size))
	   (spacing (send environment :spacing)))
      (when (> extra-space-above (+ font-height spacing (send *current-sage-device* :leading)))
	(return-from first-line-of-paragraph-p t))))
	   
  (do-line-gboxes (gbox first-gbox newline-gbox)
    (when (send gbox :ink? (eq gbox first-gbox))
      (return nil))
    (when (or (send gbox :paragraph-break?)
	      (send gbox :pseudo-paragraph-break?)
	      ;; this ensures that the first lines of records that are spliced in with
	      ;; view=contents (or precis) are considered to start paragraphs
	      ;; for the purposes of widow and orphan elimination
	      (send gbox :record-entry-gbox?))
      (return t))))



(compile-flavor-methods clump-box column-box page-box page-headings page-tabs heading-state
			box-taker auxiliary-page-data)

;;; Format pages

(defmacro 1with-line-source0 ((source name previous-ambient-values) &body body)
  `(with-source-1 ,name ,previous-ambient-values
		  (named-lambda with-line-source (,source) ,@body)))

;; This definition clearly belongs somewhere else
(defmacro 1with-document-type-for-record-group0 ((record-group) &body body)
  `(with-document-and-device-types ((document-type-for-record-group ,record-group) ())
     ,@body))

(defun 1with-source-10 (name previous-ambient-values continuation)
  (declare (sys:downward-funarg continuation))
  (let ((record-group
	  (etypecase name
	    (string (accept-from-string 'record-group name))
	    (doc-record (doc-record-record-group name))
	    (record-group name))))
    (with-ambient-counters 
      (when previous-ambient-values
	(dolist (kind '(tag-values citation-values))
	  (let ((previous 
		  (let ((*ambient-counters* previous-ambient-values))
		    (lookup-ambient-value kind :error-p nil))))
	    (when previous
	      (set-ambient-value kind previous kind)))))
      (with-sage-device (hardcopy:*default-text-printer* nil
							 :hardcopy-options
							 `(:deferred T
							   ))
	(with-document-type-for-record-group (record-group)
	  ;; Need to expand all references up front so figure counters come out in
	  ;; the right order
	  (let ((*expand-references-when* :immediate))
	    (let ((line-source (formatted-sage-record-line-source record-group)))
	      (keeping-sage-files
		(with-presentation-stack ()
		  (with-document-and-device-types ()
		    (funcall continuation line-source)))))))))))

(defun format-pages (source previous-ambient-values &key (do-index T) (do-toc T))
  (declare (values pages final-heading-state final-ambient-values))
  (keeping-sage-files 
    (rooting-record-expansion (source)
      (with-document-and-device-types ()
	(with-line-source (line-source source previous-ambient-values)
	  (let ((numerator 0))
	    (flet ((note-page-progress ()
		     (incf numerator)
		     ;; half way across at 14 = (sqrt 200) 
		     (tv:note-progress (/ (log numerator) (log 200)))))
	      (tv:noting-progress-alterable-note ("Formatting pages")
		(let ((heading-state (make-heading-state)))
		  (zwei:zcollecting-into (pages)
		    (loop for previous-page = nil then page
			  for page = (block page
				       (catch-error-restart ((sys:abort sys:error)
							     "Stop taking pages at page ~d"
							     numerator)
					 (return-from page
					   (take-page line-source heading-state previous-page)))
				       ())
			  do
		      (tv:format-progress-note () "Formatting page ~d" (1+ numerator))
		      (note-page-progress)
		      (if page
			  (zwei:zcollect pages page)
			  (loop-finish)))
		    (when do-index
		      (collect-index (first (last pages))
				     heading-state
				     (named-lambda collect-index-page (page)
				       (tv:format-progress-note
					 ()
					 "Formatting index, page ~d"
					 (1+ numerator))
				       (note-page-progress)
				       (zwei:zcollect pages page)
				       nil)))
		    (let* ((toc-pages
			     (when do-toc
			       (zwei:zcollecting-into (toc-pages)
				 (collect-table-of-contents nil
							    heading-state
							    (named-lambda collect-contents-page (page)
							      (tv:format-progress-note
								()
								"Formatting contents, page ~d"
								(1+ numerator))
							      (note-page-progress)
							      (zwei:zcollect toc-pages page)
							      nil))
				 toc-pages)))
			   (registered-book (find source *book-registry*
						  :key 'registered-book-cached-record-group))
			   (frontmatter-pages
			     (when (and registered-book do-toc (fboundp 'format-frontmatter))
			       (let ((frontmatter-directives
				       (funcall 'format-frontmatter registered-book)))
				 (zwei:zcollecting-into (frontmatter-pages)
				   (let ((line-source 
					   (formatted-sage-text-line-source
					     frontmatter-directives T)))
				     (loop for previous-page = nil then page
					   for page = (take-page line-source heading-state
								 previous-page)
					   do (if page
						  (zwei:zcollect frontmatter-pages page)
						  (loop-finish))))
				   frontmatter-pages)))))
		      (when toc-pages
			;; splice the page-box chains together
			(let ((last-toc-page (first (last toc-pages)))
			      (first-body-page (first pages)))
			  (setf (box-next last-toc-page) first-body-page)
			  (setf (box-prev first-body-page) last-toc-page)))
		      (when frontmatter-pages
			;; splice the page-box chains together
			(let ((last-frontmatter-page (first (last frontmatter-pages)))
			      (first-body-page (if toc-pages
						   (first toc-pages)
						   (first pages))))
			  (setf (box-next last-frontmatter-page) first-body-page)
			  (setf (box-prev first-body-page) last-frontmatter-page)))
		      (let ((the-pages (append frontmatter-pages toc-pages pages)))
			(when (vertical-justification-allowed-p)
			  (vertically-justify-facing-pages the-pages))
			(values the-pages
				heading-state
				*ambient-counters*)))))))))))))

(defun 1format-end-pages0 (topic previous-ambient-values)
  (declare (values pages final-heading-state final-ambient-values))
  (with-document-and-device-types ()
    (with-line-source (line-source topic previous-ambient-values)
      (ignore line-source)
      (let ((*ambient-counters* previous-ambient-values))
	(let ((heading-state (make-heading-state)))
	  (zwei:zcollecting-into (pages)
	    (flet ((collect-page (page)
		     (zwei:zcollect pages page)
		     nil))
	      (collect-index (first (last pages))
			     heading-state
			     #'collect-page)
	      (collect-table-of-contents (first (last pages))
					 heading-state
					 #'collect-page))
	    (values pages heading-state *ambient-counters*)))))))

(defun 1collect-index0 (previous-page heading-state collect-page)
  (multiple-value-bind (index-database type)
      (lookup-ambient-value 'index-database :error-p nil)
    (when (eq type 'index-database)
      (let ((index-descriptor (lookup-collector-descriptor 'index)))
	(unless index-descriptor
	  (error "No definition found for collector ~A" 'index))
	(destructuring-bind (ignore &key name init) index-descriptor
	  (let ((index-directives
		  (let ((index-directives
			  (ecase (lookup-style-parameter 'indexstyle)
			    ((permuted)
			     (directives-for-permuted-index index-database))
			    ((multilevel)
			     (directives-for-index index-database)))))
		    (making-sage-directives ()
		      (when init (funcall init))
		      (when name
			(etypecase name
			  (string (sage-command t 'prefatory (ncons (ncons name)))
				  (sage-command t 'force-line-break))	;---HDX should do this
			  (symbol (funcall name))))
		      (sage-contents-list t index-directives)))))
	    (let ((line-source 
		    (formatted-sage-text-line-source index-directives T)))
	      (loop for previous-page = previous-page then page
		    for page = (take-page line-source heading-state
					  previous-page)
		    do (if page
			   (funcall collect-page page)
			   (loop-finish))))))))))

(defun 1collect-table-of-contents0 (previous-page heading-state collect-page)
  (let ((prefatory-directives ()))
    (flet ((get-table-of-whatever (collector-name stream-name)
	     (let ((directives
		     (multiple-value-bind (stream type)
			 (lookup-ambient-value stream-name :error-p nil)
		       (when (eql type 'stream)
			 (sage-directive-stream-finalize-directives stream)))))
	       (when directives			;??
		 (let ((collector-descriptor (lookup-collector-descriptor collector-name)))
		   (unless collector-descriptor
		     (error "No definition found for collector ~A" collector-name))
		   (destructuring-bind (ignore &key name init) collector-descriptor
		     (setq prefatory-directives
			   (making-sage-directives ()
			     (sage-contents-list t prefatory-directives)
			     (when init 
			       (funcall init))
			     (when name
			       (etypecase name
				 (string
				   (idirs
				     (when (eql collector-name 'contents)
				       (command set '((page 3))))
				     (lisp (sage-command T 'prefatory (list (list name))))
				     (command force-line-break)	;---HDX should do this
				     (command collect-right-flushing)
				     "Page"
				     (command force-line-break)))
				 (symbol
				   (funcall name))))
			     (sage-contents-list t directives)))))))))
      (get-table-of-whatever 'contents 'table-of-contents-stream)
      (get-table-of-whatever 'figures 'table-of-figures-stream)
      (get-table-of-whatever 'tables 'table-of-tables-stream))
    #+Ignore
    (setq prefatory-directives
	  (making-sage-directives ()
	    (in-environment (T ContentsEnv)
	      (sage-contents-list T prefatory-directives))))
    (let ((line-source 
	    (formatted-sage-text-line-source prefatory-directives T)))
      (loop for number-of-pages from 0
	    for previous-page = previous-page then page
	    for page = (take-page line-source heading-state
				  previous-page)
	    do (if page
		   (funcall collect-page page)
		   (loop-finish))
	    finally (unless (evenp number-of-pages)
		      (funcall collect-page (make-dummy-page previous-page)))
	       ))))

;;; Displaying pages on various devices:

(define-presentation-type 1page-box-border0 ()
   :expander T)

(defun 1set-cursorpos-for-more-break0 (stream distance &optional (clear t) &aux (fudge-factor 3))
  (let ((line-height (send stream :line-height)))
    (multiple-value-bind (x y)
	(graphics:transform-point 0 0 (graphics:stream-transform stream))
      (multiple-value-bind (ignore height)
	  (graphics:transform-distance 0 distance (graphics:stream-transform stream))
	(incf height fudge-factor)
	(cond (clear
	       (send stream :set-cursorpos (round x) (round y))
	       (send stream :allocate-vertical-space-for-output (round height) line-height))
	      (t
	       (send stream :set-cursorpos (round x) (round (+ y height)))))))))

(defun 1display-page0 (page-box stream
		     &key draw-bounding-box	;are both keywords really necessary?
		     draw-handles
		     set-cursorpos? &aux max-page-y)
  (let ((page-envr (page-box-page-environment page-box))
	(leftover-presentations nil))
    (let ((pwidth (send page-envr :paper-width))
	  (pheight (send page-envr :paper-height)))
      (when draw-bounding-box
	(graphics:draw-rectangle 0 0 pwidth pheight
				 :filled nil
				 :stream stream))
      (when draw-handles
	(flet ((rect (x data)
		 (graphics:with-graphics-translation (stream x 0)
		   (dw:with-output-as-presentation (:stream stream
						    :object data
						    :type 'page-box-border
						    :single-box T
						    :allow-sensitive-inferiors nil)
		     (multiple-value-bind (w h)
			 (graphics:untransform-distance
			   5 5 (graphics:stream-transform stream))
		       (graphics:draw-rectangle (- w) (- h) w h
						:stream stream
						:gray-level .5)
		       (graphics:draw-rectangle (- w) (- h) w h
						:stream stream
						:filled nil)))))
	       (funny-eq (thing other-thing)
		 (or (eq thing other-thing)
		     (eq thing 't)
		     (eq thing ':both))))
	  (when (funny-eq draw-handles :right)
	    (rect pwidth (list 'foo :right)))
	  (when (funny-eq draw-handles :left)
	    (rect 0 (list 'foo :left))))))
    (with-presentation-stack-new
      (stream
	:incoming-stack (page-box-presentation-stack-leftover-presentations page-box)
	:when-leftover (lambda (leftovers)
			 (setq leftover-presentations leftovers)
			 (when leftovers
			   (let ((next-page (box-next page-box)))
			     (when next-page
			       (unless (page-box-presentation-stack-leftover-presentations
					 next-page)
				 (setf (page-box-presentation-stack-leftover-presentations
					 next-page)
				       leftovers)))))))
      
      (when (page-box-formatted-heading page-box)
	(display-page-heading stream page-envr 
			      (page-box-formatted-heading page-box)
			      (page-box-heading-location page-box)))
      (loop for column in (page-box-list-of-columns page-box)
	    for column-number from 0
	    do (graphics:with-graphics-translation
		 (stream (* column-number (+ (send page-envr :column-margin)
					     (send page-envr :column-width)))
			 0)
		 (let ((y (send page-envr :top-margin))
		       (line-number 0)
		       (at-top-of-column-p t))
		   ;; allocate vertical space for margin
		   (when set-cursorpos?
		     (set-cursorpos-for-more-break stream y))
		   
		   ;; useful for debugging.

		   #+Ignore
		   (flet ((draw-vertical-line (x-pos)
			    (graphics:draw-line x-pos 0
						x-pos (send page-envr :paper-height)
						:stream stream))
			  (draw-horizontal-line (y-dist)
			    (let ((y-dist (coerce-to-distance y-dist :vertical 0)))
			      (graphics:draw-line 0 y-dist
						  (send page-envr :paper-width) y-dist
						  :stream stream))))
		     (draw-horizontal-line "1inch")
		     (draw-horizontal-line "2inch")
		     (draw-horizontal-line "3inch")
		     (draw-horizontal-line "4inch")
		     (draw-horizontal-line "5inch")
		     

;		     (draw-vertical-line 33731.273)
;		     (draw-vertical-line 37497.242)
;		     (draw-vertical-line 38438.74)
;		     (draw-vertical-line (3 0 (NIL 0) (:FIX :BOLD :NORMAL) "CPTFONTCB")51426.610)
		     )

		   (do-lines-in-column (line column)
		     (let* ((height (send line :height))
			    (extra-space-above (send line :extra-space-above)))
		       (when at-top-of-column-p
			 (setq extra-space-above
			       (max 0 (- extra-space-above (send page-envr :top-margin))))
			 (when (or (> extra-space-above 0) (> height 0))
			   (setq at-top-of-column-p nil)))
		       (when set-cursorpos?
			 (graphics:with-graphics-translation (stream 0 y)
			   ;; allocate enough space for the extra-space above
			   (set-cursorpos-for-more-break
			     stream
			     (+ height extra-space-above))))
		       (incf y extra-space-above)
		       (graphics:with-graphics-translation (stream 0 y)
			 (inside-sage-graphics-transform
			   (incf line-number)
			   (display-gbox-contents-new line stream)))
		       (when set-cursorpos?
			 (graphics:with-graphics-translation (stream 0 y)
			   (set-cursorpos-for-more-break stream height ())))
		       (incf y height)
		       (setq max-page-y y)
		       )))))
      (when (page-box-formatted-footing page-box)
	(display-page-heading stream page-envr 
			      (page-box-formatted-footing page-box)
			      (page-box-footing-location page-box)))
      (when (page-box-auxiliary-page-data page-box)
	;; this page might not have been constructed with take-page (see
	;; make-dummy-page)
	(destructuring-bind (footnotes separator-width fixed-stuff)
	    (page-box-auxiliary-page-data page-box)
	  (when footnotes
	    (display-page-footnotes stream page-envr footnotes
				    max-page-y
				    separator-width))
	  (when fixed-stuff
	    (loop for (line loc) in fixed-stuff
		  do
	      (display-page-fixed-location-line stream page-envr line loc)))))
      (when (page-box-formatted-tabs page-box)
	(display-page-tabs stream page-envr 
			   (page-box-formatted-tabs page-box)
			   (page-box-formatted-tabs-y-location page-box)
			   (cdr 
			     (page-box-page-number page-box))
			   )))
    leftover-presentations))

(defun 1display-page-heading0 (stream page-environment line-source fixed-location)
  ;; 2y0 increases going down the page
  (let ((y (cond ((not (numberp fixed-location))
		  (error "fixed-location not number ~s" fixed-location))
		 ((< fixed-location 0)
		  ;; bottom of text is (abs fixed-location) above bottom of page
		  (let ((height (loop for l = (send line-source :take-line)
				      while l
				      sum (send l :height)
				      sum (send l :extra-space-above))))
		    (- (send page-environment :paper-height)
		       (+ height (abs fixed-location)))))
		 (T fixed-location))))
    (send line-source :take-it-from)
    (loop for line = (send line-source :take-line)
	  while line
	  do
      (incf y (send line :extra-space-above))
      (graphics:with-graphics-translation (stream 0 y)
	(inside-sage-graphics-transform
	  (display-gbox-contents-new line stream)))
      (incf y (send line :height)))))

(defvar 1*default-footnote-separator-width*0 #,(coerce-to-distance "1.5inches" :horizontal 0))
(defun 1footnote-separator-width0 ()
  (let ((style-parameter (lookup-style-parameter 'footsepsize)))
    (if style-parameter (coerce-to-distance style-parameter :horizontal 0)
	*default-footnote-separator-width*)))
(defun 1footnote-separator-height0 (stream)
  (multiple-value-bind (ignore y)
      (graphics:untransform-distance
	0 1 (graphics:stream-transform stream))
    y))
  
(defun 1display-page-footnotes0 (stream page-environment first-line max-y separator-width)
  (let ((footnotes-height (+ (footnote-separator-height stream)
			     (loop for l = first-line then (box-next l)
				   while l
				   sum (send l :height)
				   sum (send l :extra-space-above)))))
    (let* ((top-of-page-margin (- (send page-environment :paper-height)
				  (send page-environment :bottom-margin)))
	   (y (max max-y (- top-of-page-margin footnotes-height)))
	   (left-margin (send page-environment :left-margin)))
      (graphics:draw-line left-margin y
			  (+ left-margin separator-width) y
			  :stream stream)
      ;; ignore issues about widow-lines in margin for time being
      (loop for line = first-line then (box-next line)
	    while line
	    do
	(incf y (send line :extra-space-above))
	(graphics:with-graphics-translation (stream 0 y)
	  (inside-sage-graphics-transform
	    (display-gbox-contents-new line stream)))
	(incf y (send line :height))))))

(defun 1display-page-fixed-location-line0 (stream page-environment line location)
  (when (minusp location)
    (let ((total-height
	    (loop for line = line then (box-next line)
		  while line
		  sum (send line :extra-space-above)
		  sum (send line :height))))
      (setq location (- (send page-environment :paper-height)
			(- location)
			total-height))))
  (loop for line = line then (box-next line)
	while line
	do
    (incf location (send line :extra-space-above))
    (graphics:with-graphics-translation (stream 0 location)
      (inside-sage-graphics-transform
	(display-gbox-contents-new line stream)))
    (incf location (send line :height))))

(defvar *page-tab-width* (coerce-to-distance "42points" :horizontal 0))
(defvar *page-tab-height* (coerce-to-distance ".625inch" :vertical 0))
(defvar *page-tab-offset* (coerce-to-distance ".25inch" :horizontal 0))


(defun display-page-tabs (stream page-environment line-source y-location page-number)
  ;; 2y0 increases going down the page
  (let* ((y y-location)
	 (evenp (or (null page-number) (evenp page-number)))
	 (margin (if evenp 0 (send page-environment :paper-width)))
	 (x-at-margin
	   (if evenp
	       *page-tab-offset*
	       (- (send page-environment :paper-width) *page-tab-width* *page-tab-offset*))))
    (send line-source :take-it-from)
    (let ((lines
	    (loop for line = (send line-source :take-line)
		  while line
		  collect line)))
      (let* ((total-height
	       (loop for line in lines
		     summing (send line :height)))
	     (offset (max 0 (floor (/ (- *page-tab-height* total-height) 2)))))
	(incf y offset)
	(loop for line in lines
	      do
	  (let* ((total-line-width (send line :total-width-and-height))
		 (first-gbox-margin (send (send (send line :first-gbox) :environment)
					  :left-margin))
		 (line-width (- total-line-width first-gbox-margin))
		 (x-offset (max 0 (floor (/ (- *page-tab-width* line-width) 2)))))
	    (graphics:with-graphics-translation (stream 
						  (+ x-at-margin x-offset)
						  y)
	      (inside-sage-graphics-transform
		(display-gbox-contents-new line stream 0))))
	  (incf y (send line :height)))
	(if evenp
	    (graphics:draw-lines `(,margin ,y-location
				   ,(+ *page-tab-width* *page-tab-offset*) ,y-location
				   ,(+ *page-tab-width* *page-tab-offset*) ,(+ y-location *page-tab-height*)
				   ,margin ,(+ y-location *page-tab-height*))
			     :stream stream)
	    (graphics:draw-lines `(,margin ,y-location
				   ,(- margin *page-tab-width* *page-tab-offset*) ,y-location
				   ,(- margin *page-tab-width* *page-tab-offset*) ,(+ y-location *page-tab-height*)
				   ,margin ,(+ y-location *page-tab-height*))
			     :stream stream))))))
	

(defun 1preview-page0 (page-box
		     &optional (stream *standard-output*) window-page-height
		     &key (draw-handles ':both) (for-size-only nil))
  (setq stream (si:follow-syn-stream stream))
  (when (null window-page-height)
    (setq window-page-height
	  (- (multiple-value-bind (ignore top ignore bottom)
		 ;; ---want to flush secondary viewport
		 (send stream :visible-cursorpos-limits)
	       (- bottom top))
	     (* 3 (send stream :line-height)))))
  (let* ((page-envr (page-box-page-environment page-box))
	 (paper-width (send page-envr :paper-width))
	 (paper-height (send page-envr :paper-height)))
    (with-sage-device (stream :screen)
      (with-sage-device-stream-prepared (stream :stream-height window-page-height
						:paper-height paper-height)
	;; for error checking
	;(sys:set-in-instance *current-sage-device* 'window 'foo)
	(unless for-size-only
	  (display-page page-box stream
			:draw-bounding-box t :draw-handles draw-handles))
	(graphics:transform-distance paper-width paper-height
				     (graphics:stream-transform stream))))))

(defun 1hardcopy-pages0 (the-pages starting-page-number number-of-pages printer
		       &key (title "Document Formatter Output"))
  (with-sage-device (printer nil :hardcopy-options `(:title ,title))
    (with-sage-device-stream-prepared (stream)
      (setf (send stream :new-page-hook) nil)
      (display-pages-internal stream the-pages starting-page-number number-of-pages))))

(defun 1display-pages-internal0 (stream pages
			       &optional (starting-page-number 0)
			       (number-of-pages (length pages)))
  (tv:dotimes-noting-progress (i number-of-pages "Sending pages")
    (let ((page-box (aref pages (+ starting-page-number i))))
      (unless (zerop i)
	(eject-page *current-sage-device* stream))
      (display-page page-box stream))))

(defun 1hardcopy-page0 (page-box printer)
  (sys:with-stack-array (the-pages 1 :element-type 't :initial-element page-box)
    (hardcopy-pages the-pages 1 1 printer)))

#|| ;;debugging
(defun 1from-microns0 (&rest stuff)
  #+Franz ;;test case here
  (loop for i below 20
      do (from-microns (* (/ i 16) *microns-per-inch*)))
  (fresh-line)
  (fresh-line)
  (dolist (x stuff)
    (cond ((numberp x)
	   (multiple-value-bind (cm mm) (truncate (round x 1000) 10)
	     (format T " ~d.~d=" cm mm))
	   (let ((inch-16ths (round (* 16 (/ x *microns-per-inch*)))))
	     (multiple-value-bind (inch 16ths) (truncate inch-16ths 16)
	       (if (zerop 16ths)
		   (format T "~d" inch)
		   (multiple-value-bind (num den)
		       (ecase 16ths
			 ((1 3 5 7 9 11 13 15)
			  (values 16ths 16))
			 ((2 6 10 14)
			  (values (/ 16ths 2) 8))
			 ((4 12)
			  (values (/ 16ths 4) 4))
			 ((8)
			  (values (/ 16ths 8) 2)))
		     (format T "~d+~v~d/~d~" inch '(nil nil :smaller) num den))))))
	  (T (format T " ~s" x)))))

(defvar 1*experimental-record*0)

(defun 1install-experimental-record0 (record)
  (setq *experimental-record* record)
  (setf (record-group-installed-record (doc-record-record-group record))
	record)
  (setf (doc-record-filled record) t)
  record)

(defun 1show-page0 (page-box)
  (with-sage-device ((cli::follow-synonym-stream *standard-output*) :screen)
    (fresh-line)
    (with-presentation-stack ()
      (kludging-document-and-device-types 
	(dolist (column-box (page-box-list-of-columns page-box))
	  (do-lines-in-column (line column-box)
	    (send *current-sage-device* :display-line-gboxes line) (zl:tyi)))))))

;Almost enough to get s-c-C to work:

(defun test (scale &key (stream *standard-output*)) 
  (graphics:with-room-for-graphics (stream 500)
    (graphics:with-graphics-scale (stream scale)
      (graphics:draw-string-image "Foobar" 100 100 :stream stream))))

zwei:
(defun PARSE-AND-SHOW-REGION-INTERNAL (description &key (show-also nil)
				       (page-headings "") (force-compile nil))
  (flet ((show-it (page-headings-to-use)
	   (when show-also
	     (nsage::keeping-sage-files
	       (nsage::sage-displayer show-also page-headings-to-use
				      #'nsage::formatted-sage-record-line-source
				      topic
				      (nsage::get-sage-property
					topic property 'nsage::source-type))))))
  (let ((doc-source-name (send (send *interval* ':pathname) ':string-for-printing)))
    (cond ((window-mark-p *window*)		;there's a region
	   (typein-line "")
	   (typein-line "~A region" description)
	   (region (start end)
		   (check-interval-sections start end t)
		   (loop with this-end-bp and records-so-far and suppress-redefinition-queries
			 with this-start-bp = start
			 while (bp-< this-start-bp end)
			 do
		     (multiple-value-bind (node ignore error-p)	;find limits for this defn
			 (send (send *interval* :major-mode)
			       ':definition-interval this-start-bp)
		       (when error-p (barf error-p))
		       (setq this-start-bp (interval-first-bp node)	;find limits
			     this-end-bp (interval-last-bp node))
		       (multiple-value-bind (section-node-ok topic property)	;identify node
			   (section-node-ok-p this-start-bp force-compile)
			 (cond (section-node-ok	;is it already compiled?
				(typein-line "The definition does not need compiling.")
				(show-it page-headings))
			       (t		;check region only when compiling is necessry
				;; check validity of region
				(when (bp-< this-start-bp start)
				  (move-point start)
				  (barf "The region contains an incomplete definition here."))
				(when (bp-< end this-end-bp)
				  (move-point end)
				  (barf "The region contains an incomplete definition here."))
				(let ((record
					(nsage::with-document-and-device-types
					  ('nsage::symanual show-also)
					  (let ((nsage::*ask-user* t))
					    (nsage::sage-parse-one-defn
					      (open-interval-stream
						this-start-bp this-end-bp t))))))
				  (when (null record)
				    (setf (window-mark-p *window*) nil)
				    (must-redisplay *window* dis-mark-goes)
				    (barf))
				  (when (or suppress-redefinition-queries
					    (let ((redefine-p
						    (nsage::redefine-topic-p
						      topic (send record :type)
						      doc-source-name t records-so-far)))
					      (if (eq redefine-p :proceed)
						  (setq suppress-redefinition-queries t)
						  redefine-p)))
				    (nsage::install-experimental-record record)
				    ;;(nsage::install-record-cleanly record doc-source-name)
				    (push (list topic property) records-so-far)
				    (update-interval-compile-tick this-start-bp this-end-bp t)
				    (show-it page-headings)))))))
		     ;; now, for the "next node" definition
		     ;; ---kludge, usually right
		     (setq this-start-bp (search this-end-bp "@topic" nil t)))))
	  (t					;no region, take a definition
	   (check-interval-sections *interval*)	;??too much horsepower??
	   (multiple-value-bind (node name error-p)
	       (send (send *interval* :major-mode) ':definition-interval (point))
	     (when error-p (barf error-p))
	     (multiple-value-bind (section-node-ok topic property)
		 (section-node-ok-p (point) force-compile)	;see if it needs compiling
	       (setq name "the definition")
	       (typein-line "")
	       (typein-line "~A ~A" description name)
	       (cond (section-node-ok
		      (typein-line "Definition for ~A ~A does not need compiling."
				   (nsage::namespace-type-string topic property) name)
		      (show-it (when page-headings name)))
		     (t				;yes, needs compiling
		      (let* ((start-bp (interval-first-bp node))
			     (end-bp (interval-last-bp node))
			     (record (nsage::with-document-and-device-types
				       ('nsage::symanual show-also)
				       (let ((nsage::*ask-user* t))
					 (nsage::sage-parse-one-defn
					   (open-interval-stream start-bp end-bp t))))))
			(when (and record (nsage::redefine-topic-p
					    topic (nsage::doc-record-source-type record)
					    doc-source-name))
			  (nsage::install-experimental-record record)
			  ;;(nsage::install-record-cleanly record doc-source-name)
			  (update-interval-compile-tick start-bp end-bp t)
			  (show-it (when page-headings "the definition"))))))))))))
  (typein-line "Done ~A." description)
  dis-bps)

;; From parser.lisp
;; added :INSTALLED to process-fields-from-sab.
;;---It has been patched into NSAGE, so it isn't needed here.

;;End of debugging
||#

;;; Vertical justification stuff
(defmethod 1(page-available-height page-box)0 ()
  (loop for column in list-of-columns
	maximize (column-box-available-height column)))

#||
(define-page-previewer-command 1(com-test-vertical-justification)
0    ()
   (vertically-justify-facing-pages
     (coerce current-pages 'list)))

(define-presentation-translator 1microns-to-inches0 (number sys:form
							  :gesture :hyper-left
							  :documentation "Convert this to inches")
				(number)
  `(/ ,number *microns-per-inch*))
||#


(defun 1vertically-justify-facing-pages0 (pages)
  (tv:noting-progress ("Matching vertical heights")
    (let ((denominator (round (length (rest pages)) 2)))
      (loop for (left-page right-page) on (rest pages) by #'cddr	;ignore first page
	    for count from 0
	    do
	(tv:note-progress count denominator)
	(when (and (page-box-list-of-columns left-page)
		   right-page
		   (page-box-list-of-columns left-page)
		   (not (last-page-of-chapter-p right-page)))
	  (let ((left-page-available-height (page-available-height left-page))
		(right-page-available-height (page-available-height right-page)))
	    (when (and left-page-available-height right-page-available-height)
	      ;; only need to do this when there's text on 2both0 pages
	      (cond ((> left-page-available-height right-page-available-height)
		     (vertically-justify-page-to left-page right-page-available-height))
		    (t (vertically-justify-page-to
			 right-page left-page-available-height ))))))))))

(defmethod 1(vertically-justify-page-to page-box)0 (to)
  (loop for column in list-of-columns
	do
    (vertically-justify-column-to column to self)))

(defvar 1*vertical-whitespace-stretch-max*0 #,(coerce-to-distance "0.5inches" :vertical 0))

(defmethod 1(vertically-justify-column-to column-box)0 (to page)
  ;; need to figure out how to ignore the first heading on the page, probably
  (let ((needed-whitespace (- available-height to)))
    (when (> needed-whitespace 0)		;some filling necessary
      (let ((above-lines nil)
	    (below-lines nil)
	    (at-top-p t))
	(do-lines-in-column (line self)
	  (unless at-top-p 
	    (let ((fv (send line :fill-vertically)))
	      (case fv
		(above (unless (member (box-prev line) below-lines) (push line above-lines)))
		(below 
		  (unless (eq line last-included-line)	;avoiding space at bottom!
		    (push line below-lines))))))
	  (when (and at-top-p (send line :height))
	    (setq at-top-p nil)))
	(flet ((warning (why &rest why-args)
		 (format t "~&Unable to vertically justify page ~A:  ~~?~."
			 (car (page-box-page-number page)) why why-args)))
	  (cond ((or above-lines below-lines)
		 (let ((needed-whitespace-per-line
			 (/ needed-whitespace (+ (length above-lines)
						 (length below-lines)))))
		   (cond ((> needed-whitespace-per-line
			     *vertical-whitespace-stretch-max*)
			  (warning "Would need to stretch lines more than allowed"))
			 (t
			  (dolist (line above-lines)
			    (incf (send line :extra-space-above) needed-whitespace-per-line)
			    (decf available-height needed-whitespace-per-line))
			  (dolist (line below-lines)
			    (incf (send line :height) needed-whitespace-per-line)
			    (decf available-height needed-whitespace-per-line))))))
		(t (warning "There is no whitespace that can be stretched"))))))))

(defmethod 1(first-page-of-chapter-p page-box)0 ()
  (loop for column in list-of-columns
	do
    (do-lines-in-column (line column)
      (do-line-gboxes (gbox (send line :first-gbox) (send line :newline-gbox))
	(when (send gbox :starts-chapter-p)
	  (return-from first-page-of-chapter-p t))))))

(defmethod 1(last-page-of-chapter-p page-box)0 ()
  (or (null next)
      (first-page-of-chapter-p next)))
