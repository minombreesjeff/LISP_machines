;;; -*- Syntax: Common-lisp; Mode: Lisp; Package: (DDEX :USE SCL); Lowercase: T; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

#||D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")  How the Document Examiner's data structures fit together
0The frame (dex-frame) "is" the activity.  Its flavor includes 1dex0.
Here's an idea of what the instance variables are and what flavor they are.
Corresponding numbers in parens indicate EQ items.

The activity (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")is-a0 
1dex
0    current-viewing-context (0)
      2is-a 1dex-viewing-context
0		name
		viewer-contents
		  2is-a 1dex-viewer-contents
0			  view-item-array (1)
			  view-item-pixels
			  view-item-lines
			  current-item-number
		candidate-contents
		  2is-a 1dex-candidates-contents
0		  	  contents
		  	  current-reason
		  	  contents-history
		  	  query-history
		bookmarks-contents
		  2is-a 1dex-bookmarks-contents
0		  	  contents
		  	  first-unseen-index
    viewer-pane
      2is-a 1dex-viewer-pane
0	       current-viewing-context (0)
	       items-array (1)
	       ...other stuff for display...
    candidate-pane
    bookmark-pane
    command-pane
||#


(defun 1default-dex0 ()
  (send (dw:find-program-window (choose-doc-ex-for-screen nil)) :program))

;;;This runs in the Select key process, so try to keep it simple, short, and
;;;not dex-related.
(defmethod 1(make-instance doc-ex0 1:after)0 (&rest ignored)
  ;; pane stuff moved into top-level initializations
  (setq current-viewing-context (find-context-named self "Default Viewer" :create))
  (push current-viewing-context viewing-contexts)
  )

(defmethod (initialize-doc-ex doc-ex) ()
  (macrolet ((set-pane (name)
	       `(unless ,name
		  (let ((pane (dw:get-program-pane ',name)))
		    (unless pane
		      (error "No pane named ~s" ',name))
		    (setq ,name pane)))))
    (set-pane viewer-pane)
    (set-pane candidate-pane)
    (set-pane bookmark-pane)
    (set-pane command-pane)
    (setf (send viewer-pane :current-viewing-context) current-viewing-context)
    (send viewer-pane :set-scroll-position-function
	  'scroll-for-document-examiner)
    ))

;(define-doc-ex-command (com-show-stuff)
;    ()
;   (multiple-value-bind (x y)
;       (send viewer-pane :read-cursorpos)
;     (format t "~&cursor-x: ~S, cursor-y: ~S" x y)))

(defmethod (add-viewing-context doc-ex) (context)
  (nconc viewing-contexts (ncons context)))

(defmethod 1(:select-viewing-context0 doc-ex1)0 (new-context &optional create-p first-time)
  (when (or (null current-viewing-context)
	    (neq new-context current-viewing-context)
	    first-time)
    (when current-viewing-context
      (send current-viewing-context :set-dynamic-window-state
	    (snapshot-dynamic-window-state viewer-pane)))
    (setq current-viewing-context (find-context-named self new-context create-p))
    (cond (current-viewing-context
	   (setq viewing-contexts			;maintain "viewer history" like stack
		 (delete current-viewing-context viewing-contexts))
	   (push current-viewing-context viewing-contexts)
	   (send viewer-pane :reset-context current-viewing-context first-time)
	   (send current-viewing-context :reset-context self first-time))
	  (t
	   (setq current-viewing-context (first viewing-contexts))	;in case this exists
	   (format *error-output* "~&Unable to find or create ~A." new-context)))
    (let ((candidates (send (send current-viewing-context :candidates-contents) :contents)))
      (unless candidates
	(send current-viewing-context :replace-candidates
	      (make-default-candidates) "Table of contents for the document set")))))

;(defmethod 1(:hardcopy-viewing-context0 1dex)0 (context-or-name printer &optional (seen-only t))
;  (let* ((context (find-context-named context-or-name))
;	 (bookmarks-contents (send context :bookmarks-contents))
;	 (bookmarks (send bookmarks-contents :contents))
;	 (max (if seen-only
;		  (send bookmarks-contents :first-unseen-index)
;		  (array-active-length bookmarks))))
;    (with-sage-device (printer nil :page-headings "")
;      (loop for i from 0 below max
;	    for item = (aref bookmarks i)
;	    do
;	(display-on-device #'formatted-sage-record-line-source
;			   (send item :topic) (send item :type))))))

(defmethod 1(:kill-viewing-context0 doc-ex1)0 (context-or-name)
  (let ((context (find-context-named self context-or-name)))
    (cond (context
	   (setq viewing-contexts		;maintain "viewer history"
		 (delete context viewing-contexts))
	   (when (eq context current-viewing-context)	;killing the current one
	     (setq current-viewing-context (first viewing-contexts))
	     (if (null current-viewing-context)	;if you've deleted everything make empty one
		 (send self :select-viewing-context "Default Viewer" :create))
	     (send viewer-pane :reset-context current-viewing-context)
	     (send current-viewing-context :reset-context self)))
	  (t					;no such context
	   (format *error-output* "No viewing context named ~A exists.  Can't kill it."
		   context-or-name)))))

(defflavor 1dex-viewing-context
0	(name
	 viewer-contents			;flavor capturing stuff looked at
	 dynamic-window-state
	 candidates-contents			;flavor capturing queries
	 top-candidate-index			;display state
	 bookmarks-contents			;flavor capturing bookmarks
	 current-bookmark			;display state
	 top-bookmark-index			;display state
	 (active-item)				;item that is scrollable
	 record-lookup-mode
	 )					
	()
  :settable-instance-variables)

(defun 1make-dex-viewing-context0 (&key name)
  (make-instance 'dex-viewing-context
		 :name name
		 :dynamic-window-state (make-dynamic-window-state)
;					 (doc-ex-viewer-pane dw:*program*))
		 :viewer-contents (make-dex-viewer-contents)
		 ;;knowledge about contents of candidates pane
		 :candidates-contents (make-dex-candidates-contents)
		 ;;knowledge about contents of bookmarks pane
		 :bookmarks-contents (make-dex-bookmarks-contents)
		 :record-lookup-mode (symbol-value-globally 'nsage::*record-lookup-mode*)))

(defmethod 1(flavor::print-self0 1dex-viewing-context)0 (stream &rest ignore)
  (si:printing-random-object (self stream :typep)
    (prin1 name stream)))

(defmethod (1find-context-named0 doc-ex) (new-context &optional create-p error-p)
  (etypecase new-context
    ((or string symbol)			;look for it in the list of known ones
     (let ((existing-p (loop for c in viewing-contexts
			     when (string-equal (send c :name) new-context)	;---right?
			       return c)))
       (cond (existing-p)			;exists, return it
	     (create-p (make-dex-viewing-context :name new-context))	;make new one
	     (error-p (error "No known viewing context named ~S" new-context))	;wants error
	     (t nil))))				;nil means can't find it
    (dex-viewing-context new-context)))		;already know which one to choose

;;;Change the contents of the candidates and bookmarks
;;;You might think this ought to handle the viewer contents also.  The modularity
;;;is bad here.  The "context" doesn't know enough about the viewer (pane) so we
;;; let our caller take care of fixing up the viewer-pane context.
(defmethod (:reset-context dex-viewing-context) (program &optional first-time)
;  (send (dw:get-program-pane 'viewer-pane) :clear-history)	;?
  (setq nsage::*record-lookup-mode*
	(if (and (variable-boundp record-lookup-mode)
		 (not (null record-lookup-mode)))
	    record-lookup-mode
	    (symbol-value-globally 'nsage::*record-lookup-mode*)))
  (unless first-time
    (send self :refresh-display program)))

;(defmethod 1(:reset-context0 1dex-viewing-context)0 (frame)
;  (let ((c-p (send frame :candidate-pane))
;	(b-p (send frame :bookmark-pane)))
;    (setf (send c-p :items) (send candidates-contents :contents))	;find right items
;    (when (variable-boundp top-candidate-index)	;tell it the display state
;      (set-in-instance c-p 'tv:top-item top-candidate-index))
;    (set-in-instance b-p 'tv:items (send bookmarks-contents :contents))	;find right bookmarks
;    (when (variable-boundp top-bookmark-index)	;tell it the display state
;      (set-in-instance b-p 'tv:top-item top-bookmark-index))
;    (when (variable-boundp current-bookmark)	;tell it display state
;      (set-in-instance b-p 'tv:current-item current-bookmark))
;    (send self :refresh-display frame)))	;sometimes get double display, sometimes not

(defun notify-cursorpos ()
  (multiple-value-bind (x y)
      (send (dw:get-program-pane 'viewer-pane) :read-cursorpos)
    (tv:notify nil "Cursorpos: (~S,~S)" x y)))

;;;Redisplay all the content panes.  Does the command pane need redisplay?
(defmethod 1(:refresh-display0 1dex-viewing-context)0 (program)
  (redisplay-candidates program)
  ;(redisplay-bookmarks program)
  (send (doc-ex-viewer-pane program) :refresh))

;;;Put a new set of candidates into the candidate contents and pane
(defmethod 1(:replace-candidates0 1dex-viewing-context)0 (new-candidates reason)
  (send candidates-contents :replace-candidates new-candidates reason))

(defmethod 1(:remember-candidates0 1dex-viewing-context)0 (new-candidates reason)
  (send candidates-contents :remember-candidates new-candidates reason))

(defmethod 1(:current-view-item0 1dex-viewing-context)0 ()
  (send viewer-contents :current-view-item))

;;;This is for interfacing the DEX to the rest of the LispM world
(defmethod 1(:add-item-to-context0 1dex-viewing-context)0 (item)
  (nsage::catch-unsupplied-type ()				;fail very quietly
    (setq item (send self :add-item-to-bookmarks item))
    (setq active-item item)
    (let ((currently-displayed-item (currently-displayed-item self)))
      (when currently-displayed-item
	(update-last-cursorpos currently-displayed-item)))
    (when item (send self :display-dex-item item (dw:get-program-pane 'viewer-pane)))))

;(defmethod 1(:background-add-item-to-context0 1dex-viewing-context)0 (frame item)
;  (catch-unsupplied-type ()				;fail very quietly
;    (setq item (send self :add-item-to-bookmarks frame item))
;    (when item
;      (send item :prepare-documentation (send frame :viewer-pane))
;      (loop repeat 50.			   ;Performance hack: format a few lines for startup
;	    with source = (send item :line-source)
;	    while (send source :take-line))
;      ;;Pretend user had clicked on the item
;      (send frame :force-kbd-input `(:bookmark ,item () #\mouse-L-1)))))

;;;Adding an item means adding it to the bookmarks
;;;The "current item" in the bookmarks is the item being displayed in the viewer rather
;;;than the bookmark just added.
;;;If the "new" item is already known about, abandon it and use the existing item
;;;in the rest of the business.  This is because we don't want to accumulate a bunch
;;;of different representations for the same item that are "same-record-p" but not "eq".
;;;---This has a bug for items that are in different viewers; they appear to be different
;;;This returns the item that is REALLY being talked about.

(defmethod 1(:add-item-to-bookmarks0 1dex-viewing-context)0 (item)
  (let ((index (send bookmarks-contents :known-bookmark item)))
    (cond (index			;added before?
	   (setq item (aref (send bookmarks-contents :contents) index)))
	  (T				;new item
	   (vector-push-extend item (send bookmarks-contents :contents))
	   (redisplay-bookmarks dw:*program*))))
  item)

(defun-in-flavor (set-potential-active-item dex-viewing-context) ()
  ;; only the last item has potential as the active item
  (let ((potential-active-item (last-item self)))
    (when potential-active-item
      (if (send potential-active-item :last-presentation)
	  (setq active-item potential-active-item)
	  (setq active-item nil)))))

;;;displaying an item means taking an item that already exists (i.e. is a bookmark)
;;;and making its formatted representation show up in the viewer.
;;;Frob also the ordering of the bookmarks to keep it the same as the order in the
;;;viewer.  Thus all seen bookmarks come before any unseen ones.
(defmethod 1(:display-dex-item0 1dex-viewing-context)0 (item pane
							 &key (hbox :saved) background-p)
  (unwind-protect
      (let ((reposition-successful))
	(send item :prepare-documentation pane)
	(send viewer-contents :select-view-item self item)	;get it known about in contents
	(when (send self :in-viewer-p item)
	  ;; if it's already in the viewer we just want to scroll the viewer-pane
	  ;; to the right place
	  ;; --- Later, scroll to the right place w/in the item.
	  ;; If there's a given hbox, make sure that that hbox is at the top of the
	  ;; screen.
	  (let* ((first-presentation (send item :first-presentation))
		 (box (dw::presentation-displayed-box first-presentation))
		 (first-hbox (send item :first-hbox)))
	    (cond ((or (eq hbox :start)
		       (and (eq hbox :saved)
			    (eq item (currently-displayed-item self))))
		   (let* ((above (send first-hbox :extra-space-above))
			  (pixels (nsage::microns-to-pixels above :screen)))
		     (setq reposition-successful t)
		     (unless background-p
		       (send pane :set-viewport-position 0 (- (dw::box-top box) pixels)))))
		  ((eq hbox :saved)
		   (let* ((above (send first-hbox :extra-space-above))
			  (pixels (nsage::microns-to-pixels above :screen))
			  (last-cursorpos (send item :last-cursorpos)))
		     (setq reposition-successful t)
		     (unless background-p
		       (if (eq last-cursorpos :start)
			   (send pane :set-viewport-position
				 0 (+ (- (dw::box-top box) pixels)))
			   (send pane :set-viewport-position
				 0 (+ (dw::box-top box) last-cursorpos))))))
		  (t
		   ;; start with the first hbox and sum vertical positions until
		   ;; reach the desired hbox
		   (let ((total-offset
			   (loop for box = first-hbox then (nsage::box-next box)
				 with barrier-hbox = (send item :barrier-hbox)
				 when (eq box barrier-hbox)
				   return nil
				 until (eq box hbox)
				 summing (send box :screen-display-height-of-box))))
		       (when total-offset
			 (unless background-p
			   (send pane :set-viewport-position
				 0 (+ (dw::box-top box) total-offset)))
			 (setq reposition-successful t)))))))
	(unless reposition-successful
	  (send pane :display-dex-item item (if (symbolp hbox) nil hbox))))
    (let ((seen-contexts (send item :seen-contexts)))
      (when (send item :last-hbox)		;have to have shown SOME lines
      (unless (member self seen-contexts)	;if this is the first time it is being shown
	(setf (send item :seen-contexts)	;in this context, record knowing about it
	      (push self seen-contexts))
	)))
    (when (eq (send item :barrier-hbox) :all)
      (set-potential-active-item))
    (sort-bookmarks bookmarks-contents)
    ;(redisplay-bookmarks dw:*program*)
    ))

(defmethod 1(:display-0more-of-1dex-item0 1dex-viewing-context)0 (item upper-top)
  ;; for now, rely on the fact that someone above us has checked this out  
  (setq active-item item)
  (let* ((last-presentation (send item :last-presentation))
	 (presentation-top (dw::box-top (dw::presentation-displayed-box last-presentation)))
	 (y-cursor (- presentation-top (second (dw:presentation-object last-presentation))))
	 (viewer-pane (dw:get-program-pane 'viewer-pane))
	 (next-topic (next-item self item))
	 (next-topic-top nil)
	 (moved-stuff nil)
	 (cursor-viewport (send viewer-pane :cursor-viewport))
	 (reposition-viewer
	   (not (= upper-top (dw:box-top cursor-viewport)))))
    (unwind-protect-case ()
	(progn
	  1(send viewer-pane :close-current-output-displayed-string)0	;!!!!!!
	  ;; get rid of the ellipsis presentation
	  (sys:without-aborts
	    ("The document examiner is removing the ellipsis marker from the topic \"~A\".~@
              Aborting now could cause you to be unable to scroll through or see more of ~@
              this topic later." (send item :string))
	    (send viewer-pane
		  :erase-displayed-presentation last-presentation)
	    (setf (send item :last-presentation) nil))
	  (when next-topic
	    ;; If there's a "next topic", then we must bump it down a little.
	    (let* ((first-presentation (send next-topic :first-presentation))
		   (first-hbox (send next-topic :first-hbox))
		   (additional-height (nsage::microns-to-pixels (send first-hbox :extra-space-above) :screen))
		   (top (- (dw::box-top (dw::presentation-displayed-box first-presentation))
			   additional-height))
		   (available-whitespace (- top y-cursor)))
	      ;; Top is where the next item actually begins.
	      ;; available-whitespace is the amount of whitespace between the cursor
	      ;; and the beginning of the next topic.
	      ;; Needed-whitespace is the amount of whitespace we're going to try to fill up.
	      (let ((needed-whitespace (- (+ upper-top (dw::box-height cursor-viewport))
					  y-cursor)))
		(when (> needed-whitespace available-whitespace)
		  (setq moved-stuff t)
		  (setq next-topic-top (+ top (- needed-whitespace available-whitespace)
					  additional-height))
		  (send viewer-pane :experimental-move-region
			top  (+ top (- needed-whitespace available-whitespace)))))))
	  (send viewer-pane :set-cursorpos 0 y-cursor :pixel)
	  (if reposition-viewer
	      (send viewer-pane :set-viewport-position 0 upper-top)
	      (send viewer-pane :redraw-inside-sets
		    (dw:make-box
		      0 y-cursor
		      (dw::box-width cursor-viewport) (dw:box-bottom cursor-viewport))))
				 
	  (let ((left-over-space
		  (send viewer-pane :display-more-of-dex-item item (send item :barrier-hbox))))
	    (when (and moved-stuff (eq (send item :barrier-hbox) :all))
	      (send viewer-pane :experimental-move-region
		    next-topic-top (- next-topic-top left-over-space)))))
      (:abort
	;; if we've aborted
	;; must a) put in ellipsis at this point
	;;      b) bump stuff back up
	(unless (eq (send item :barrier-hbox) :all)	;unless done with item
	  (setf (send item :last-presentation)
		(send viewer-pane :insert-ellipsis item (send item :last-hbox) :visible t)))
	(when moved-stuff
	  (multiple-value-bind (x y) (send viewer-pane :read-cursorpos)
	    (ignore x)
	    (send viewer-pane :experimental-move-region next-topic-top y)))
	(setq active-item nil)			;for now, make nothing active.
	#+ignore (set-potential-active-item))))	;this topic should no longer be active
  (when (eq (send item :barrier-hbox) :all)
    (set-potential-active-item))
  (sort-bookmarks bookmarks-contents)
  ;(redisplay-bookmarks dw:*program*)
  )

(defmethod 1(:in-viewer-p0 1dex-viewing-context)0 (item)
  (when item (member self (send item :seen-contexts))))

;;; Make this faster, somehow?
(defmethod (currently-displayed-item dex-viewing-context) ()
  ;; The "currently displayed item" is the first item in the bookmarks
  ;; that has some portion of its contents visible in the current viewport
  (currently-displayed-item bookmarks-contents self))

(defmethod (first-item dex-viewing-context) ()
  (first-item-in-context bookmarks-contents self))

(defmethod (last-item dex-viewing-context) ()
  (last-item-in-context bookmarks-contents self))

(defmethod (next-item dex-viewing-context) (item)
  (next-item-in-context bookmarks-contents item self))

(defmethod (in-viewport-p dex-viewing-context) (item)
  ;; Well, we shouldn't have to figure-out the viewport stuff every time...
  (let* ((first-presentation (send item :first-presentation))
	 (total-height (send item :item-pixels))
	 (first-hbox (send item :first-hbox))
	 (additional-height (nsage::microns-to-pixels (send first-hbox :extra-space-above) :screen)))
    ;; -- This additional-height thing is a temporary kludge.  This only gives us
    ;; the additional height for this item, not for the item following us, which is what
    ;; we want.
    (let ((top (dw::box-top (dw::presentation-displayed-box first-presentation))))
      (dw::box-overlaps-region-p
	(send (dw:get-program-pane 'viewer-pane) :cursor-viewport)
	0 top nil (+ top total-height (- additional-height))))))


;;;---I can't decide if the following level of hiding is necessary or just
;;; redundant and confusing.  For now it seems necessary in one case or maybe two
;;; and so, because parallelism is easier to understand ...

(defflavor dynamic-window-state
	((displayed-presentations (dw::make-coordinate-sorted-set))
	 (displayed-strings (dw::make-displayed-strings-array))
	 (displayed-graphics (dw::make-coordinate-sorted-set))
	 (viewport-x 0)
	 (viewport-y 0)
	 (cursor-x 0) (cursor-y 0)
	 maximum-x-position
	 maximum-y-position)
	()
  :readable-instance-variables
  :writable-instance-variables
  :initable-instance-variables)

(defun make-dynamic-window-state ()
  (make-instance 'dynamic-window-state :maximum-x-position 0
		 :maximum-y-position 0))

;(defmethod (make-dynamic-window-state dex-viewer-pane) ()
;  (multiple-value-bind (left top right bottom)
;      (dw::box-edges dw::cursor-viewport)
;    (make-instance 'dynamic-window-state
;		   :maximum-x-position right
;		   :maximum-y-position bottom)))


;(defmethod (:deactivate dex-viewer-pane :before) (&rest ignored)
;  (send dw:*program* :deactivate))

(defmethod (snapshot-dynamic-window-state dex-viewer-pane) ()
  ;; DOESN'T COPY
  (multiple-value-bind (x y) (send self :viewport-position)
    (multiple-value-bind (cx cy) (send self :read-cursorpos)
      (make-instance 'dynamic-window-state
		     :displayed-presentations dw::displayed-presentations
		     :displayed-strings dw::displayed-strings
		     :displayed-graphics dw::displayed-graphics
		     :viewport-x x
		     :viewport-y y
		     :cursor-x cx
		     :cursor-y cy
		     :maximum-x-position dw::maximum-x-position
		     :maximum-y-position dw::maximum-y-position))))

(defflavor 1dex-viewer-contents
0	((view-item-array nil)			;array of the bookmarks that have been seen
	 (view-item-pixels nil)			;parallel array with pixel # of first lines
	 (view-item-lines nil)			;parallel array with user-line-number of "
	 current-item-number			;index into the view-item-array
	 ;(dynamic-window-state)		;info about the viewer pane
	 )
	()
  :settable-instance-variables)

(defun 1make-dex-viewer-contents0 ()
  (make-instance 'dex-viewer-contents
		 :view-item-array (make-array 100. :fill-pointer 0)	;array of topic ids
		 :current-item-number 0
		 :view-item-pixels		;each bookmark knows pixel # of its beginning
		 (make-array 100. :fill-pointer 0)
		 :view-item-lines (make-array 100. :fill-pointer 0)	;line# of beginning
;		 :dynamic-window-state (make-instance 'dynamic-window-state)
		 ))


(defmethod 1(:current-view-item0 1dex-viewer-contents)0 ()
  (let ((item (aref view-item-array current-item-number)))
    (unless (eq item '|Invalid item 0 in empty array|) item)))

(defmethod 1(:select-view-item0 1dex-viewer-contents)0 (context item)
  (cond ((send context :in-viewer-p item)	;shown already in viewer
	 (setq current-item-number (position item view-item-array)))
	(T					;install the item before positioning to it
	 (setq current-item-number (vector-push-extend item view-item-array))
	 (send self :compute-total-height-of-items))))	;recomputes first line "cache"

;;; --- take out first-unseen-index
(defflavor 1dex-bookmarks-contents
0	((contents nil)
	 first-unseen-index)			;index of either first unseen or next empty
	()
  :settable-instance-variables)

(defun 1make-dex-bookmarks-contents0 ()
  (make-instance 'dex-bookmarks-contents
		 :contents (make-array 100. :fill-pointer 0)
		 :first-unseen-index 0))

(defmethod 1(:matching-bookmark dex-bookmarks-contents)0 (item)
  (loop for b being the array-elements of contents
	when (same-record-p b item)
	return b))

(defmethod 1(:known-bookmark0 1dex-bookmarks-contents)0 (item)
  (loop for b being the array-elements of contents
	for i = 0 then (1+ i)
	when (same-record-p b item)
	return i))

;;; --- remove?
;(defmethod 1(:mark-item-seen0 1dex-bookmarks-contents)0 (frame item)
;  (let ((index (sage:find-position-in-array item contents)))
;    (unless (< index first-unseen-index)	;if already seems to be seen, don't fiddle
;      (incf first-unseen-index)			;changed status of item from seen to unseen
;      )))

;; Sorts the contents so that unseen bookmarks come last.  Leaves rest alone
(defmethod (sort-bookmarks dex-bookmarks-contents) ()
  (stable-sort contents
	#'(lambda (item1 item2)
	    (and (send item1 :seen-contexts)
		 (not (send item2 :seen-contexts)))))
  (setq first-unseen-index (find-first-unseen-index self)))

(defmethod (last-displayed-item dex-bookmarks-contents) ()
  (let ((idx (find-first-unseen-index self)))
    (when (and idx (not (zerop idx)))
      (aref contents (1- idx)))))

(defmethod (find-first-unseen-index dex-bookmarks-contents) ()
  (loop for item being the array-elements of contents
	for count from 0
	when (not (send item :seen-contexts))
	  return count))

(defmethod (currently-displayed-item dex-bookmarks-contents) (context)
  (loop for item being the array-elements of contents
	while (send context :in-viewer-p item)	;only look at displayed items
	when (in-viewport-p context item)
	  return item))

(defmethod (first-item-in-context dex-bookmarks-contents) (context)
  (when (> (fill-pointer contents) 0)
    (let ((item (aref contents 0)))
      (when (send context :in-viewer-p item)
	item))))

(defmethod (last-item-in-context dex-bookmarks-contents) (context)
  (unless (zerop (fill-pointer contents))
    (loop for idx downfrom (1- (fill-pointer contents))
	  as item = (aref contents idx)
	  when (send context :in-viewer-p item)
	    return item)))

(defmethod (next-item-in-context dex-bookmarks-contents) (item context)
  (let ((idx (loop for idx below (fill-pointer contents)
		   when (eq item (aref contents idx))
		     return idx)))
    (when idx
      (let ((next-item-idx (1+ idx)))
	(unless ( next-item-idx (fill-pointer contents))
	  (let ((next-item (aref contents next-item-idx)))
	    (when (send context :in-viewer-p next-item)
	      next-item)))))))


(defflavor 1dex-candidates-contents
0	((contents nil)
	 current-reason				;index into the query history
	 (contents-history nil)			;the various sets of candidates
	 (query-history nil)			;what caused set of candidates to exist
	 )
	()
  :settable-instance-variables)

(defun 1make-dex-candidates-contents0 ()
  (make-instance 'dex-candidates-contents))

;;;---To be designed: "history" mechanism so you can see previous queries and reinvoke
;;;one.  (But not reinstate the candidates that resulted from a previous query.  The 
;;;document contents might eventually be dynamic so you should always decache.)
;;;Here the list is supposed to be a list of dex-items (in which type might still be nil).
;;;Actually a list of dex-items or lists of dex-items (i.e. recursive structure) where
;;;the list level indicates depth of nesting in the structure.
(defmethod 1(:replace-candidates0 1dex-candidates-contents)0 (candidates reason)
  (cond
    (candidates
     (setq contents candidates)
     (let* ((existing-reason (position candidates contents-history)))
       (if existing-reason
	   (setq current-reason existing-reason)	;we've seen it before, "select" it
	   (progn
	     (setq current-reason (length query-history))	;a new one, add it
	     (setq contents-history (nconc contents-history (list candidates)))
	     (setq query-history (nconc query-history (list reason))))))	;items -> menu
     (redisplay-candidates dw:*program*)
     )
    (t (beep))))				;no candidates, don't make it empty 

(defmethod 1(:find-and-replace-candidates0 1dex-candidates-contents)0 (reason)
  (let ((index (position reason query-history)))
    (if index
	(send self :replace-candidates (nth index contents-history) reason)
	(error "Can't find this reason in the query history: ~A" reason))))

;;;This is like :replace-candidates but it just sticks them in the history without
;;;affecting the current candidates list.
(defmethod 1(:remember-candidates0 1dex-candidates-contents)0 (candidates reason)
  (let* ((existing-reason (position candidates contents-history)))
    (unless existing-reason
      (setq contents-history (nconc contents-history (list candidates)))
      (setq query-history (nconc query-history (list reason))))))

;;;The data structure for the "item" in a Document Examiner.
;;;---Design errors: currently when the same topic is shown in two different
;;;viewers, you get two items and two sets of formatted lines.  This is in
;;;spite of the seen-contexts instance variable here, which gives the impression
;;;that the item has multiple uses.  When this gets fixed, fix the item-position
;;;also to give per-viewer position information.
(defflavor 1dex-item
0	((record-group nil)
	 (string "no name")			;name used for printing
	 (seen-contexts nil)			;list of contexts wh docn is being displayed
	 (level 0)				;indicates level of nesting in candidates
	 (nsage::line-source nil)		;"active" object, answers requests for lines
	 (item-pixels 0)			;including the separator bar
	 (item-lines 0)				;including the separator bar
	 (last-hbox nil)			;the last hbox (shown) in the item
	 (barrier-hbox :none)			;:none, :all, or last hbox shown
	 (item-position nil)			;hbox to start displaying at when selected
	 (first-presentation)			;presentation of the title
	 (last-presentation)			;nil or new-ellipsis bar.
	 (last-cursorpos :start)		;offset from top of first-presentation
	 )
	()
  :settable-instance-variables)

(defun 1dex-item-p0 (item)
  (typep item 'dex-item))

(defun 1make-dex-item-from-topic-and-type0 (topic type &optional string level &aux record-group)
  (let ((record-groups (nsage::find-record-group-for-topic-and-type topic type)))
    (cond ((atom record-groups)
	   (setq record-group record-groups))
	  ;; type might have been NIL
	  ((= (length record-groups) 1)
	   (setq record-group (first record-groups)))
	  (t
	   (setq record-group
		 (dw:menu-choose (nsage::alist-from-record-group-list record-groups)
				 :prompt "Choose one of the following:"))))
    (when record-group
      (make-dex-item record-group string level))))

(defun 1make-dex-item0 (record-group &optional string level)
  (make-instance 'dex-item
		 :record-group record-group
		 :string (or string
			     (nsage::appropriate-title-rendering record-group
								 'nsage::no-formatting))
		 :level (or level 0)))

;;;So it can show itself properly when the item is printed out by anything
(defmethod 1(flavor::print-self0 1dex-item)0 (stream &rest ignore)
  (si:printing-random-object (self stream :typep)
    (prin1 (or string (nsage::record-group-topic record-group)) stream)))

(defmethod 1(:first-hbox0 1dex-item)0 ()
  (send nsage::line-source :first-line-hbox))

(defmethod 1(additional-space-above dex-item)0 (&key (unit :pixel))
  (let ((first-hbox (send self :first-hbox)))
    (when first-hbox
      (let ((space (send first-hbox :extra-space-above)))
	(ecase unit
	  (:micron space)
	  (:pixel (nsage::microns-to-pixels space :screen)))))))

;;;Usually you call this within the context of with-line-source-from to get the
;;;line source pointer positioned to where you want to read from.
(defmethod 1(:take-line0 1dex-item)0 ()
  (let ((new-line (send nsage::line-source :take-line)))
    (cond ((eq barrier-hbox :all))		;no adjustment, they've all been seen
	  ((null new-line)			;we just read past the last one, no adjust
	   (setq barrier-hbox :all))
 	  (t					;we don't have them all yet so check heights
	   (when (or (eq barrier-hbox (nsage::box-prev new-line))
		     (eq barrier-hbox :none))	;we are passing the barrier
	     (incf item-lines 1)		;so resume accumulating the height
	     (incf item-pixels (send new-line :screen-display-height-of-box))
	     (setq last-hbox new-line)		;this one never goes null validly
	     (setq barrier-hbox new-line))))
    (values new-line barrier-hbox)))

;;;Safely returns the hbox after the one provided
(defmethod 1(:next-line0 1dex-item)0 (hbox)
  (nsage::with-line-source-from (hbox 1)
    (send self :take-line)))


;(defmethod 1(:print-item0 1dex-bookmarks-text-scroll-pane)0 (item line-no item-no)
;  (ignore line-no item-no)
;  (multiple-value-bind (x y)
;      (send self :read-cursorpos)
;    (unless (send item :seen-contexts)		;the user has not looked at it yet
;      (send self :draw-1-bit-raster (send self :inside-width) (send self :line-height)
;	    *gray-for-marking* 0 0 x y tv:char-aluf color:alu-noop))
;    (send self :item item :bookmark #'dex-bookmarks-print-item)
;;;;---This looks like it might be more robust than the current tangle of :after whatever
;;;;methods.  Look into it sometime.  Works without for now.
;;    (if (eq item tv:current-item) (tv:update-mark-current-item))))
;    ))
;
;(defun 1dex-bookmarks-print-item0 (item stream)
;  (format stream "~A~@[ ~A~]" (send item :string)
;	  (namespace-type-string (send item :topic) (send item :type))))

(defmethod (update-last-cursorpos dex-item) ()
  (let ((viewer-pane (dw:get-program-pane 'viewer-pane)))
    (multiple-value-bind (x y) (send viewer-pane :viewport-position)
      (ignore x)
      (let ((item-top (dw::box-top (dw::presentation-displayed-box first-presentation))))
	(setq last-cursorpos
	      (- y item-top))))))


;;;Manage taking out an item.  Have it removed from contents data structures and
;;;make sure the displays are udpated.
(defmethod 1(:remove-view-item0 1dex-viewing-context)0 (item)
  (let* ((bookmarks (send bookmarks-contents :contents))
	 (viewer-pane (dw:get-program-pane 'viewer-pane))
	 (index (position item bookmarks))	;being removed
	 (next-item (when index (next-item-from-index bookmarks-contents index self)))
	 )
    (send bookmarks-contents :remove-bookmark index)
    ;(redisplay-bookmarks dw:*program*)
    (cond ((empty-p bookmarks-contents self)
	   ;; if removing the last topic, clear out the history just in case.
	   (send viewer-pane :clear-history))
	  ((send self :in-viewer-p item)
	   (remove-item-from-display viewer-pane item next-item)
	   (unless (currently-displayed-item self)
	     ;; if nothing is in the viewer, display the last item.
	     (send self :add-item-to-context (last-item self))))))
  (setf (send item :seen-contexts) (delete self (send item :seen-contexts))))

(defmethod 1(:remove-matching-view-item dex-viewing-context)0 (item)
  (let ((item (send bookmarks-contents :matching-bookmark item)))
    (when item
      (send self :remove-view-item item))))

(defmethod (next-item-from-index dex-bookmarks-contents) (item-index context)
  (let ((new-index (1+ item-index)))
    (when (< new-index (fill-pointer contents))
      (let ((item (aref contents new-index)))
	(when (send context :in-viewer-p item)
	  item)))))

(defmethod (empty-p dex-bookmarks-contents) (context)
  (or (zerop (fill-pointer contents))		;no items
      (not (send context :in-viewer-p (elt contents 0)))))

(defmethod 1(:remove-bookmark0 1dex-bookmarks-contents)0 (item-index)
;  (format t "Removing bookmark item ~D, array-active-length is ~D"
;	  item-index (length contents))
  (replace contents contents :start1 item-index :start2 (1+ item-index))
  (decf (fill-pointer contents)))

;;;Take a view-item out of the viewer.  This eventually affects the display if it was visible
;;;but really shouldn't affect it if the item wasn't showing.
(defmethod 1(:remove-view-item0 1dex-viewer-contents)0 (item)
  (let ((viewer-index (position item view-item-array)))	;which one to take out
    (when viewer-index
      (nsage::remove-item-from-array view-item-array viewer-index)	;take item out of array
      (when (zerop (length view-item-array))
	;; In case somebody tries to do something with this.
	;; CHOOSE-NEW-CURRENT-ITEM below leaves CURRENT-ITEM-NUMBER at 0
	;; when the array is empty.
	(setf (aref view-item-array 0) '|Invalid item 0 in empty array|))
      (send self :compute-total-height-of-items)	;recompute cache
      (cond ((= viewer-index current-item-number)	;are we removing the marked current item?
	     (multiple-value-bind (new-item new-index)	;yes so we need to choose new one
		 (choose-new-current-item view-item-array viewer-index)
	       (setq current-item-number new-index)
	       new-item))			;returns the item that should now be current
	    ((< viewer-index current-item-number)	;removing one in front of ourselves
	     (aref view-item-array (decf current-item-number)))	;so adjust the index
	    (T (aref view-item-array current-item-number))))))	;same item is current

;;; --- remove this?
;(defmethod 1(:reformat-item0 1dex-viewing-context)0 (item)
;  (send self :remove-view-item item)
;  (send item :set-line-source ())
;  (send self :add-item-to-context item))

(defmethod 1(:find-table-of-contents-for-item0 1dex-viewing-context)0 (item)
  (let* ((record-group (send item :record-group))
	 (item-list (caller-list-to-item-list	;include topic as parent of the tree
		      (list `(,record-group nsage::expand
			      ,(nsage::table-of-contents record-group))))))
    (nsage::log-lookup-event record-group "Table of contents (menu)" t)
    (when item-list
      (send self :replace-candidates
	    (when (> (length item-list) 1) item-list)	;inhibit if topic is the only thing
	    (format nil "Table of contents using \"~A\"" (send item :string))))
    (when ( (length item-list) 1)
      (barf dw:*program* "~A ~A contains no other topics."
	    (nsage::namespace-type-string record-group)
	    (nsage::appropriate-title-rendering record-group 'nsage::no-formatting)))))

;;;Random support functions and stuff

;;;given an array from which something has been deleted and the index where the
;;;deleted something used to be.  choose a new something.  the most obvious one
;;;is the one at the same index, if there happens to be one.  (Returns new thing and index)
(defun 1choose-new-current-item0 (array old-current-index)
  (declare (values new-item new-index))
  (let ((new-length (length array)))
    (cond ((= 0 new-length) (values nil 0))			;no new item
	  (( old-current-index new-length)
	   (let ((last (1- new-length)))	;item deleted was the last one
	     (values (aref array last) last)))
	  (t (values (aref array old-current-index) old-current-index)))))	;same is OK

(defun 1same-record-p0 (item1 item2)
  ;; can this be made more efficient?
  (and (eq (nsage::record-group-topic (send item1 :record-group))
	   (nsage::record-group-topic (send item2 :record-group)))
       (eq (nsage::coerce-record-type (nsage::record-group-type (send item1 :record-group))
				      'nsage::property)
	   (nsage::coerce-record-type (nsage::record-group-type (send item2 :record-group))
				      'nsage::property))))

;;;The data structure that you get from the match cache is an alist of
;;;(("str" sym) "str" sym)...)  Each of the pairs has to be turned into a dex-item
;;;instance
;;;Don't worry yet about duplicating zillions of small flavor instances.
(defun 1alist-to-item-list (alist)
0  (loop for (string symbol) in alist
	collect
	(make-dex-item symbol nil string)))

;;;From a table of contents, you get a recursive list structure that has to get
;;;unpacked into a flat list of dex-items indicating record-group, level, title.
;;;"level" is used by the item printer to indicate nesting depth.
;;;Note: be very careful that the top level topic and type have made it into the list.
(defun 1caller-list-to-item-list (caller-list &optional (level 0))
0  (loop for (record-group ref-type children) in caller-list
	when (eq ref-type 'nsage::expand)
	collect
	(make-dex-item record-group nil level)
;	(list topic type level (nsage::appropriate-record-title topic type))
	into result
	when children
	nconc (caller-list-to-item-list children (1+ level)) into result
	finally (return result)))
 
(defun 1make-default-candidates0 ()
  (let ((aarray sage:*topic-aarray*))
    (si:prepare-for-aarray-lookups aarray (length nsage::*book-registry*))
    (loop with candidates-list
	  for registered-book in nsage::*book-registry*
	  for book-title = (nsage::registered-book-title registered-book)
	  when (si:aarray-lookup book-title aarray t)
	    ;; Use push instead of collect to make list more likely to be in "right" order
	    do (push (make-dex-item (nsage::registered-book-record-group
				      registered-book)
				    book-title) candidates-list)
	  finally (return candidates-list))))

;;;Interface between the rest of Sage in other activities and the DEX.

;;;---Some issues:
;;;-Logging of topics.  Make sure that once DEX starts logging its own topics that
;;;this doesn't result in double logging.
;;;-Selecting a default viewing context within the default dex?
;;;-Order of adding to dex vs. displaying in the user context (perhaps spinning off the
;;;process first can make that overlap with the interminable wait for Opennnnnnnnn. But
;;;then maybe it tried to find and format it twice?)

(defmacro nsage::1in-background-dex0 ((dex-var) &body body)
  `(ddex::enqueue-background-dex-request
     (lambda (,dex-var) ,@body)))

;;; I've decided to say that if you show documentation anywhere but in the dex, you
;;; only get a bookmark in the dex.  (It doesn't take very long to reformat it
;;; anyway.)

(defvar *context-to-use-for-background-lookups* "Background")

(defun nsage::1add-bookmark-to-dex0 (record-group)
  (let ((background-context *context-to-use-for-background-lookups*))
    ;; snapshot *context-to-use-for-background-lookups* because
    ;; it may be bound and will not be bound inside the dex.
    (when (nsage::documented-p record-group)	    ;not-so-paranoid check, avoid making garbage
      (nsage::in-background-dex (dex)
	(let ((context-to-use
		(if background-context
		    (let ((context 
			    (find-context-named dex
						background-context t)))
		      (add-viewing-context dex context)
		      context)
		    (doc-ex-current-viewing-context dex))))
	  (let ((item (make-dex-item record-group)))
	    (send context-to-use :add-item-to-bookmarks item)
	    (if (eq context-to-use (doc-ex-current-viewing-context dex))
		(send context-to-use :add-item-to-context item)
		(display-dex-item-in-background context-to-use item))))))))

(defun nsage::LOOKUP-MANUAL-INTERNAL (nsage::record-group
				      &optional (nsage::device-type :screen))
  nsage::
  (catch-unsupplied-type (:beep)
     (let ((error-p nil))
       (unwind-protect-case ()
	   (keeping-sage-files
	     ;; if we get an unhandled error in the body, there is no reason
	     ;; to get it again trying to put the same broken thing into dex.
	     (condition-bind-default ((error (lambda (ignore)
					       (setq error-p t)
					       nil)))
	       (sage-displayer device-type
			       (appropriate-title-rendering record-group 'no-formatting)
			       #'formatted-sage-record-line-source
			       record-group)))
	 (:normal (unless error-p (add-bookmark-to-dex record-group)))
	 (:abort (unless error-p (add-bookmark-to-dex record-group))))
       t)))

(defun nsage::1add-candidates-to-dex0 (menu reason converter-function visible-p)
  (nsage::in-background-dex (dex)
    (let ((context-to-use
	    (if *context-to-use-for-background-lookups*
		(let ((context
			(find-context-named dex
					    *context-to-use-for-background-lookups* t)))
		  (add-viewing-context dex context)
		  context)
		(doc-ex-current-viewing-context dex))))
      (send context-to-use
	    (if visible-p :replace-candidates :remember-candidates)
	    (funcall converter-function menu) reason))))

;;This is basically like APPLY, except that it happens in the background, 
;;and that it tries hard not to cons up multiple DEXes.
(defun 1enqueue-background-dex-request0 (function &rest request)
  (setq request (list (cons function (copy-list request))))
  (without-interrupts
    (cond ((null *dex-background-request-queue*)
	   (setq *dex-background-request-queue* request)
	   )
	  (T (setq *dex-background-request-queue*
		   (nconc *dex-background-request-queue* request))))))

(defmethod 1(add-to-command-queue doc-ex)0 (function &rest request)
  (setq request (list (cons function (copy-list request))))
  (without-interrupts
    (cond ((null command-queue)
	   (setq command-queue request)
	   )
	  (T (setq command-queue
		   (nconc command-queue request))))))

;;; This is kind of yecchy, but it'll do
(defmacro 1in-dex-command-queue0 ((doc-ex) &body body)
  `(add-to-command-queue ,doc-ex
			 (lambda (ignore)
			   ,@body)))

(defun 1invoke-dex-to-lookup-topic0 (record-group &optional (dex-program (default-dex)))
  (send (dw:program-frame dex-program) :select)
  (in-dex-command-queue (dex-program)
    (let ((*standard-output* 'si:null-stream))
      (cp:execute-command 'com-show-documentation record-group)))
  (values))

