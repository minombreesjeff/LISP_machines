;;; -*- Syntax: Common-lisp; Mode: Lisp; Package: DDEX; Lowercase: T; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Note:  For the time being, any new command that operates on the
;;; viewer will have to do a (prepare-viewer) first.  I may choose to
;;; hide this through macrology.

;; Utility macro
(defmacro D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")add-command-to-menu0 (name (&key gesture documentation) command-table menu-levels
			       command-name &rest command-args)
  `(dw:define-command-menu-handler (,name ,command-table ,menu-levels :gesture ,gesture
				    :documentation ,documentation)
				   ()
     (dw::standard-command-menu-handler ',command-name ,@command-args)))

;;; Macro needed in order to define commands as being on submenus.
(defmacro 1define-command-and-menu0 (menu-item default-command-for-left-click submenu-level
				   &optional documentation-for-left-click
					     command-table menu-levels)
  (let ((translator-function-name
	  (sys:fintern "LEFT-ON-~A-AT-~A-~A-MENU-COMMAND-TRANSLATOR"
		       menu-item (first menu-levels) command-table))
	(documentation-function-name
	  (sys:fintern "LEFT-ON-~A-AT-~A-~A-MENU-COMMAND-DOCUMENTATION"
		       menu-item (first menu-levels) command-table))
	(left-translation
	  (if default-command-for-left-click
	      `(dw:standard-command-menu-handler ',default-command-for-left-click)
	    `(apply #'dw::invoke-subcommand-menu
		    ,submenu-level ,menu-item
		    :gesture :right		;hmm?
		    :command-table (or ',command-table cp:*command-table*)
		    args))))
    `(progn (defun ,translator-function-name (&rest args &key gesture &allow-other-keys)
	      (case gesture
		(:right (apply #'dw::invoke-subcommand-menu
			       ,submenu-level ,menu-item 
			       :command-table (or ',command-table cp:*command-table*)
			       args))
		(:left ,left-translation)))
	    (defun ,documentation-function-name (&rest args &key gesture &allow-other-keys)
	      (case gesture
		(:left ',documentation-for-left-click)
		(:right (apply ',translator-function-name args))))
	    (dw::add-command-menu-handler ,menu-item ',command-table ',menu-levels
					  '(:left :right)
					  ,(if documentation-for-left-click
					       `',documentation-function-name
					       `',translator-function-name)
					  ',translator-function-name nil))))

(defmethod 1(dw::sort-subcommand-menu doc-ex)0 (menu-items menu-level &rest ignored)
  (let ((preferred-other-commands-ordering
	  '("Help" "Select Viewer" "Reselect Candidates" "Read Private Document")))
    (flet ((order-menu-items (preferred-ordering)
	     (flet ((menu-item-lessp (item1 item2)
		      (< (or (position item1 preferred-ordering
				       :test #'string-equal)
			     1_6)
			 (or (position item2 preferred-ordering
				       :test #'string-equal)
			     1_6))))
	       (sort menu-items #'menu-item-lessp))))
      (case menu-level
	(:show-commands menu-items)
	(:other-commands (order-menu-items preferred-other-commands-ordering))
	(otherwise menu-items)))))

;;;Parts of the Document Examiner having to do with its toplevel loop, interaction
;;;with Command Processor and Input Editor, and its <Help> and Overview.

(define-command-and-menu "Show" () :show-commands () small-doc-ex (:small-top-level))
(define-command-and-menu "Other" () :other-commands () small-doc-ex (:small-top-level))

(define-doc-ex-command-and-documentation
  (1com-show-documentation
0    :documentation "Shows a topic from the documentation set in the current viewer.")
    ((record-group 'nsage::record-group :default nil))
   (let ((item (make-dex-item record-group)))
     (prepare-viewer)
     (send current-viewing-context :add-item-to-context item)))

(add-command-to-menu "Show Documentation" (:gesture (:left :right)
					   :documentation "Shows a topic in the viewer")
		     doc-ex (:top-level)
		     com-show-documentation)
(add-command-to-menu "Show Documentation" (:gesture (:left :right)
					   :documentation "Shows a topic in the viewer")
		     small-doc-ex (:show-commands)
		     com-show-documentation)

(define-doc-ex-command-and-documentation
  (1com-show-overview
0    :documentation "Shows context information for a topic.")
    ((record-group 'nsage::record-group :default nil))
   (display-overview-graph record-group *standard-output*))

(add-command-to-menu "Show Overview" (:gesture (:left :right)
				      :documentation "Shows context information for a topic")
		     doc-ex (:top-level)
		     com-show-overview)
(add-command-to-menu "Show Overview" (:gesture (:left :right)
				      :documentation "Shows context information for a topic")
		     small-doc-ex (:show-commands)
		     com-show-overview)

(define-doc-ex-command-and-documentation
1  (com-show-candidates
0    :documentation "Shows the topics relevant to a particular index word or phrase")
    ((string 'candidate-substring :prompt "word(s)" :confirm t)
     &key
     (matching '((member exact heuristic substring initial)) :default 'heuristic)
     (multiple-word-order '((member adjacent any)) :default 'any))
   (let ((condition (ecase multiple-word-order
		      ;; Another possibility would be "same order" allowing intervening words
		      ;; or "nearby" to allow intervening words but any order
		      (adjacent 'sage::adjacent)
		      (any 'sage::logical-and)))
	 (matching-function (ecase matching
			      (exact #'string-equal)
			      (substring #'string-search)
			      (initial #'sage::initial-substring-match)
			      (heuristic #'sage::heuristic-match))))
     (dynamic-dex-doc-match-internal self string matching-function
				     'sage::keyword-tokens
				     (nstring-capitalize
				       (string-append
					 matching " search "
					 multiple-word-order " order"))
				     condition)))

(add-command-to-menu "Show Candidates" (:gesture (:left :right)
					:documentation
					"Shows topic names associated with a word")
		     doc-ex (:top-level)
		     com-show-candidates)
(add-command-to-menu "Show Candidates" (:gesture (:left :right)
					:documentation
					"Shows topic names associated with a word")
		     small-doc-ex (:show-commands)
		     com-show-candidates)

(define-doc-ex-command (1com-add-bookmark0)
    ((record-group 'nsage::record-group :default nil))
   (let ((item (make-dex-item record-group)))
     (send current-viewing-context :add-item-to-bookmarks item)))

(define-doc-ex-command (1com-remove-item0)
    ;; does this really mean that the presentation type should be dex-item?
    ((item 'bookmark :default nil
	   :prompt "item"))
   (prepare-viewer)
   (send current-viewing-context :remove-view-item item))

(define-doc-ex-command-and-documentation
  (1com-show-table-of-contents
0    :documentation "Fills the current candidates list with the table of contents for a topic.")
    ((record-group 'nsage::record-group
	    :default nil
	    :prompt "for topic"))
   (let ((item (make-dex-item record-group)))
     (send current-viewing-context :find-table-of-contents-for-item item)))

(add-command-to-menu "Show Table of Contents"
		     (:gesture (:left :right)
		      :documentation "Shows the table of contents for a topic")
		     doc-ex (:top-level)
		     com-show-table-of-contents)
(add-command-to-menu "Show Table of Contents"
		     (:gesture (:left :right)
		      :documentation "Shows the table of contents for a topic")
		     small-doc-ex (:show-commands)
		     com-show-table-of-contents)

; --- needs work.
(define-doc-ex-command-and-documentation
  (1com-document-examiner-documentation
0    :documentation "Shows the full Document Examiner documentation.")
    ()
   (let* ((record-group (nsage::find-record-group-for-topic-and-type
			  "Document Examiner" 'nsage::section))
	  (item (make-dex-item record-group)))
     (prepare-viewer)
     (send current-viewing-context :add-item-to-context item)))

(add-command-to-menu "Help" (:gesture :middle
			     :documentation "Show full documentation")
		     doc-ex (:top-level)
		     com-document-examiner-documentation)
(add-command-to-menu "Help" (:gesture :middle
			     :documentation "Show full documentation")
		     small-doc-ex (:other-commands)
		     com-document-examiner-documentation)

(cp:install-commands 'doc-ex '(sage::com-set-sage-variable
				sage::com-clear-sage-variable
				sage::com-list-sage-variables))

(defparameter 1*dex-self-help-body-text*
0	     '("The Document Examiner shows you documentation and maintains 
a history of topics you have read during a session.  There are single key commands,
named commands, and a command menu at the lower right.  Click [Help (M)]
to see full documentation."))

(defvar 1*preferred-dex-keystroke-order-for-help*0 '(#\Scroll #\Meta-Scroll
						   #\Control-Scroll #\Control-Meta-Scroll
						   #\Help
						   #\Refresh
						   #\Meta-< #\Meta->))

(defvar 1*refused-dex-keystrokes-for-help*0 '(#\c-V #\m-V))

(defun 1show-dex-keystroke-commands-help0 (keystroke-command-forms)
  (labels ((format-char (char stream )
	     (write-string (proper-text-for-char char) stream))
	   (format-documentation (documentation)
	     (typecase documentation
	       (string (format t documentation))
	       (function (funcall documentation *standard-output* ))))
	   (document-set (keyset )
	     (loop for (nil keystrokes documentation) in keyset
		   do
	       (let ((interesting-keystrokes
		       (remove-if #'(lambda (char)
				      (member char *refused-dex-keystrokes-for-help*
					      :test #'char=)) keystrokes)))
		 (when interesting-keystrokes
		   (sage::in-item ()
		     (sage::in-environment (() sage::k)
		       (format-textual-list interesting-keystrokes #'format-char))
		     (sage::sage-tab )
		     (format-documentation documentation ))))))
	   (any-member (charset1 charset2)
	     (intersection charset1 charset2 :test #'char=))
	   (many-char= (charset1 char)
	     (member char charset1 :test #'char=)))
    (let (preferred others)
      (loop for stuff in keystroke-command-forms
	    for chars = (second stuff)
	    do (cond ((any-member chars *preferred-dex-keystroke-order-for-help*)
		      (push stuff preferred))
		     ;((any-member chars *refused-dex-keystrokes-for-help*))
		     (t (push stuff others))))
      (setq preferred (sort preferred
			    (lambda (charset1 charset2)
			      (< (position (second charset1)
					   *preferred-dex-keystroke-order-for-help*
					   :test #'many-char=)
				 (position (second charset2)
					   *preferred-dex-keystroke-order-for-help*
					   :test #'many-char=))))
	    others (nreverse others))
      (document-set preferred )
      (document-set others ))))

;;;This does what I wish (format () "~:c" char) would do.
(defun 1proper-text-for-char0 (char)
  (let ((losers '(#\space #\return #\tab #\backspace))
	(code (char-code char)))
    (cond ((and (< code #o200) ( code (char-code #\space)))
	   (format () "~c" char))
	  (T (using-resource (string sage::string-temp)
	       ;;get the bucky chars, on a space.
	       (format string "~c" (make-char #\space (char-bits char)))
	       (decf (fill-pointer string))	;get rid of the space
	       (format string (if (or (member char losers :test #'char-equal)
				      ( code #o200))
				  "~:c"
				  "~c")
		       (code-char code))
	       (copy-seq string))))))

(defmacro 1collecting-or-showing0 (type &body body)
  `(flet ((body () .,body))
     (ecase ,type
       (:collect (sage::making-sage-directives () (body)))
       (:show (sage::sage-formatting () (body))))))

(defun 1show-dex-help0 (&optional (type ':show))
  (collecting-or-showing type
    (show-dex-help-1)))

(defun 1show-dex-help-10 ()
  (let* ((sage::keystroke-commands
	   (loop for elt in *dex-command-help-alist*
		 when (second elt)
		   collect elt))
	 (sage::other-commands (set-difference *dex-command-help-alist*
					       sage::keystroke-commands
					       :key #'car)))

    sage::
    (flet ((format-command-pretty-name (command-symbol &optional (stream *standard-output*))
	     (if stream
		 (present command-symbol '((cp:command-name :command-table doc-ex))
			  :stream stream)
		 (present-to-string command-symbol
				    '((cp:command-name :command-table doc-ex)))))
	   (format-documentation (documentation &optional (stream *standard-output*))
	     (typecase documentation
	       (string (format stream documentation))
	       (function (funcall documentation stream)))))

      (sage::in-environment (() text facecode r spacing 0)
	(sage-paragraph)
	(map nil #'princ ddex::*dex-self-help-body-text*)
	(sage-paragraph)
	(when keystroke-commands
	  (write-string "The single key commands:")
	  (terpri)
	  (flet ((indent (sign) (format () "~a12" sign)))
	    (sage::in-environment1 (() `(description spread 0 above 0
						     indent ,(indent "-") leftmargin ,(indent "+")))
	      (sage::in-item ()
		(sage::in-environment (() i) "Key" (sage-tab) "Description"))
	      (ddex::show-dex-keystroke-commands-help keystroke-commands)))
	  (sage-paragraph))
	(when other-commands
	  (setq other-commands (sort other-commands #'string-lessp :key #'car))
	  (write-string "The named commands:")
	  (sage-paragraph)
	  (sage::in-environment (() description above 0 spread "0.3lines")
	    (in-item () (in-environment (() i) "Name" (sage-tab) "Description"))
	    (loop for (command keystrokes documentation) in other-commands
		  do (sage::in-item ()
		       (format-command-pretty-name command)
		       (sage-tab)
		       (format-documentation documentation)))))))))

(defun 1reset-help-record-group0 ()		;(reset-help-record-group)
  (let ((record-group (sage:find-record-group-for-topic-and-type
			"Document Examiner Command Summary"
			'sage::section)))
    (when record-group
      (setf (sage::record-group-installed-record record-group) nil
	    (sage::record-group-published-record record-group) nil))))

(defmethod 1(construct-dex-help-for-commands-record-group doc-ex)0 (&optional (force-p))
  (declare (values record-group changed-p))
  (let ((topic "Document Examiner Command Summary")
	(type 'sage::section))
    (let ((record (sage::find-record-for-topic-and-type topic type :installed :create-p t))
	  (new-p (null *dex-self-help-tick-shown*))
	  (changed-p (or force-p (neq *dex-self-help-tick* *dex-self-help-tick-shown*))))
      (when changed-p
	(sage::fill-doc-record-computed-contents record :installed
						 (show-dex-help :collect)))
      (setq *dex-self-help-tick-shown* *dex-self-help-tick*)
      (values
	(sage:doc-record-record-group record)
	(unless new-p changed-p)))))

(define-doc-ex-command-and-documentation
  1(com-help0 :keyboard-accelerator #\Help
	    :documentation "Shows the Document Examiner command summary."1)
0  ()
  (multiple-value-bind (record-group changed-p)
      (construct-dex-help-for-commands-record-group self)
    (let ((item (make-dex-item record-group)))
      (prepare-viewer)
      (when changed-p
	(send current-viewing-context :remove-matching-view-item item))
      (send current-viewing-context :add-item-to-context item))))

(add-command-to-menu "Help" (:gesture (:left :right)
			     :documentation "Shows the Document Examiner command summary.")
		     doc-ex (:top-level)
		     com-help)
(add-command-to-menu "Help" (:gesture (:left :right)
			     :documentation "Shows the Document Examiner command summary.")
		     small-doc-ex (:other-commands)
		     com-help)

;;; When the system comes up, the initial window tells you
;;; "Type <select> D to select Document Examiner to read online documentation".
;;; Clicking there wants to select the Document Examiner, but in such a way
;;; as to make it offer its own help first.  Here is that "side door".

(defun 1sage::select-document-examiner-with-self-help0 (&optional (dex (default-dex)))
  (send (dw:program-frame dex) :select)
  (in-dex-command-queue (dex)
    (let ((*standard-output* 'si:null-stream))
      (cp:execute-command 'com-help)))
  (values))

(define-doc-ex-command-and-documentation
  (1com-beginning-of-topic
0    :documentation "Shows the current topic from the beginning.")
    ((topic 'bookmark
	    :prompt "topic"
	    :default (currently-displayed-item current-viewing-context)))
   (prepare-viewer)
   (display-item self :beginning topic))

(define-doc-ex-command-and-documentation
  (1com-end-of-topic
0    :documentation "Shows the last screen displayed for the current topic.")
    ((topic 'bookmark
	    :prompt "topic"
	    :default (currently-displayed-item current-viewing-context)))
   (prepare-viewer)
   (display-item self :end topic))

(define-presentation-to-command-translator
1  com-beginning-of-topic
0   (bookmark :gesture nil
	     :documentation ((ignore &key for-menu-p)
			     (if for-menu-p
				 "Go to the beginning of this topic"
				 "Beginning of Topic")))
   (bookmark)
  (cp:build-command 'com-beginning-of-topic bookmark))

(define-doc-ex-command-and-documentation
  (1com-reselect-candidates
0    :documentation "Presents a menu of previous Show Candidates commands.")
    ()
   (let* ((context current-viewing-context)
	  (candidates-contents (send context :candidates-contents))
	  (history (send candidates-contents :query-history)))
     (if history
	 (let ((choice (dw:menu-choose history :prompt
				       "Select results from a previous Show Candidates command.")))
	   (when choice
	     (send candidates-contents :find-and-replace-candidates choice)))
	 (format command-pane "No previous results to choose from yet."))))

(add-command-to-menu "Reselect Candidates" (:gesture (:left :right)
			     :documentation
			     "Presents a menu of previous Show Candidates commands.")
		     doc-ex (:top-level)
		     com-reselect-candidates)
(add-command-to-menu "Reselect Candidates" (:gesture (:left :right)
			     :documentation
			     "Presents a menu of previous Show Candidates commands.")
		     small-doc-ex (:other-commands)
		     com-reselect-candidates)

(define-presentation-type viewer ()
   :history t
   :parser ((stream &key type initially-display-possibilities)
	    (dw:complete-from-sequence
	      (doc-ex-viewing-contexts dw:*program*)
	      stream
	      :name-key (lambda (context) (send context :name))
	      :type type
	      :partial-completers '(#\space #\-)
	      :initially-display-possibilities initially-display-possibilities))
   :printer ((context stream)
	     (write-string (send context :name) stream)))

(define-doc-ex-command-and-documentation
  (1com-select-viewer
0    :menu-level :viewer-commands
    :documentation "Selects or creates a viewer, prompting for a name.")
    ((viewer `((type-or-string viewer))
	     :default (or (second viewing-contexts) current-viewing-context)
	     :confirm t
	     :prompt "viewer name"))
   (prepare-viewer)
   (send self :select-viewing-context viewer :create)
   current-viewing-context)

(define-command-and-menu "Select Viewer" com-select-viewer :viewer-commands
			 "Selects another viewer, prompting for name"
			 doc-ex (:top-level))
(define-command-and-menu "Select Viewer" com-select-viewer :viewer-commands
			 "Selects another viewer, prompting for name"
			 small-doc-ex (:other-commands))

(define-doc-ex-command (1com-select-previous-viewer0)
    ((number 'number
	     :default 1
	     :prompt "number"))
   (prepare-viewer)
   (let ((number-of-viewers-to-choose-from (length viewing-contexts)))
     (flet ((select-previous-viewer (n)
	      (if (> n number-of-viewers-to-choose-from)
		  (beep)
		  (send self :select-viewing-context (elt viewing-contexts (1- n))))))
       (when (= number 1) (setq number 2))
       (select-previous-viewer number))))

(defun 1com-select-previous-viewer-command-accelerator0 (arg-p arg)
  (declare (dw::accelerator-for com-select-viewer))
  (cp::command-accelerator-internal
    (lambda (ignore arg)
      (list 'com-select-previous-viewer
	    arg))
    arg-p
    arg
    :argument-allowed t
    :echo :default))

(cp:add-command-accelerator 'doc-ex 'com-select-previous-viewer-command-accelerator '#\c-m-L)
(install-dex-command-documentation
  'com-select-previous-viewer '(#\c-m-L)
  "Selects the previous viewer.")

;;; This makes "Space" at top-level get rid of the typeout window if 
;;; it's visible.  Naturally, this should NOT echo.
(define-doc-ex-command (1com-remove-typeout-window0 :keyboard-accelerator #\Space :echo nil)
    ()
   (prepare-viewer)
   (send viewer-pane :new-scroll-position))

(define-doc-ex-command-and-documentation
  (1com-remove-viewer
0    :documentation "Removes a viewer, prompting for the name, and selecting a new one."
    :menu-accelerator t
    :menu-level :viewer-commands)
    ((viewer 'viewer
	     :default current-viewing-context
	     :confirm t
	     :prompt "viewer name"))
   (prepare-viewer)
   (send self :kill-viewing-context viewer))



;;; What happens when you click on a candidate or a bookmark
;;; Left means Show
;;; Middle means Overview
;;; Sh-Middle means Bookmark or Discard
;;; Find Table Of Contents and Remove have no gestures.
(defmacro 1define-bookmark-to-command-translator
0	  (command-name short-name long-name &rest options)
  (let ((bookmark-translator-name (dw::fintern
				     "BOOKMARK-TO-~S-TRANSLATOR" command-name)))
    `(define-presentation-to-command-translator
       ,bookmark-translator-name
       (bookmark
	 :documentation ((ignore &key for-menu-p)
			 (if for-menu-p
			     ,long-name
			     ,short-name))
	 ,@options)
	 (bookmark)
	 (cp:build-command ',command-name
			   (convert-bookmark-to-record-group bookmark)))))

(defun 1convert-bookmark-to-record-group0 (bookmark)
  (send bookmark :record-group))

;;; Show
(nsage::define-record-group-to-command-translator
  com-show-documentation
  "Show documentation" "Put this topic in viewer")
  
(define-bookmark-to-command-translator
  com-show-documentation
  "Show documentation" "Put this topic in viewer")
    
;;; Overview
(nsage::define-record-group-to-command-translator
  com-show-overview
  "Overview" "Show overview of this topic" 
  :gesture :middle)

(define-bookmark-to-command-translator
  com-show-overview
  "Show overview of topic" "Show overview of this topic"
  :gesture :middle)

;;; shift-middle click
(nsage::define-record-group-to-command-translator
  com-add-bookmark
  "Bookmark" "Put in a bookmark"
  :gesture :shift-middle)

(define-presentation-to-command-translator
  bookmark-to-com-remove-item-translator
  (bookmark
    :gesture :shift-middle
    :documentation ((ignore &key for-menu-p)
		    (if for-menu-p
			"Discard this topic"
			"Discard topic")))
  (bookmark)
  (cp:build-command 'com-remove-item bookmark))

;;; Table of contents
(define-bookmark-to-command-translator
  com-show-table-of-contents
  "" "Show table of contents"
  :gesture nil)

(nsage::define-record-group-to-command-translator
  com-show-table-of-contents
  "" "Show table of contents"
  :gesture nil)


;;;---This really needs to be context-dependent
;(defmethod 1(:com-help0 1dex)0 (ignore)
;  (dex-help-for-commands self))
;
;;;make help stuff to be a dex-item
;(defun 1dex-help-for-commands 0(dex-frame)
;  ;;This is the right way.  Make a full-fledged topic and install it correctly.
;  (let ((item (make-dex-item 'doc:|DOCUMENT EXAMINER COMMAND SUMMARY| 'sage:section))
;	(current-viewing-context (send dex-frame :current-viewing-context)))
;    ;;Decache if the comtab has changed
;    (sage:caching-based-on-tick (*dex-comtab-tick*
;				  =dex-command-help-tick=
;				  =dex-command-help-source=)
;      (sage:make-record-from-string 'doc:|DOCUMENT EXAMINER COMMAND SUMMARY| 'sage:section
;				 'computed-from-code
;				 (dex-self-help-text))
;	)
;      (send current-viewing-context :add-item-to-context dex-frame item))))
;
;(defconst 1*dex-self-help-body-text*
0;	  '("The Document Examiner shows you documentation and maintains a history
;	    of topics you have read during a session.  There are single key commands,
;            named commands, and a command menu at the lower right.  Click [Help (M)]
;            to see full documentation."))
;
;;;the newer version(5/31/85)
;(defun 1dex-self-help-text0 ()
;  ;;The params here have been fiddled a little in the interests of getting more on
;  ;;the first screen.  Appearance has been compromised a little.
;  ;;This documentation gets cached for speed.  When you want to change anything
;  ;; eval this out of the buffer to cause decache: 1(incf *dex-comtab-tick*)0 
;  (let* (;;An unused stub.  Apparently intended for including a document fragment
;	 (existing-inclusion-refs
;	   (get-sage-property 'doc:|DOCUMENT EXAMINER SELF HELP| 'section 'callees)))
;    ;;---This is a kludge that tries to guess whether the help summary contains implicit
;    ;;references to documented commands.  It can't get it right even most of the time by
;    ;;just interning something from the text in DOC.
;    (flet ((long-comtab ()
;	     (loop for (name text) in *dex-long-name-comtab*
;		   for doc-title = (string-upcase-and-intern name "DOC")
;		   unless (memq doc-title existing-inclusion-refs)
;		     append `(,(let ((documented-p (documented-p doc-title ())))
;				 (if documented-p 
;				     `(@ (transparent
;					   (mouse-sensitivity
;					     (concept ,doc-title :SAGE-SECTION-RECORD)))
;				       ,name)
;				     name))
;			      (@ /) ,text ,*two-newlines*))))
;      (convert-@-to-directives
;	`(@ (text (facecode r) (spacing 0))
;	  ,@ *dex-self-help-body-text*
;	  ,*two-newlines*
;	  "The single key commands:" ,*one-newline*
;	  (@ (description (spread 0) (above 0)) ,*two-newlines*
;	   (@ i "Key" (@ /) "Description")
;	   ,*two-newlines*
;	   ,@(format-dex-char-comtab))
;	  ,*two-newlines*
;	  "The named commands:" ,*two-newlines*
;	  (@ (description (above 0) (spread "0.3lines"))
;	   ,*two-newlines*
;	   (@ i "Name" (@ /) "Description")
;	   ,*two-newlines*
;	   ,@(get-sage-property			;---time bomb, assumes doc in memory not disk
;	       'doc:|DOCUMENT EXAMINER SELF HELP| 'section 'location)
;	   ,@(long-comtab))
;	  )))))
;
;(defun 1format-dex-char-comtab0 ()
;  (let ((preferred-order
;	  '(#\Scroll #\Meta-Scroll 
;	    #\Control-Scroll #\Control-Meta-Scroll
;	    #\Help
;	    #\Refresh
;	    #\Meta-< #\Meta->))
;	(refused '(#\Control-V #\Meta-V))
;	(preferred ())
;	(others ()))
;    (loop for stuff in *dex-comtab*
;	  for (char text) = stuff
;	  do (cond ((mem #'char-equal char preferred-order)
;		    (push stuff preferred))
;		   ((mem #'char-equal char refused))
;		   (T (push stuff others))))
;    (setq preferred
;	  (sortcar preferred
;		   (lambda (x y)
;		     (< (cl:position x preferred-order :test #'char-equal)
;			(cl:position y preferred-order :test #'char-equal))))
;	  others (nreverse others))
;    (flet ((wow (list)
;	     (loop for (char text) in list
;		   append `((@ k ,(proper-text-for-char char)) (@ \) ,text
;			    ,*two-newlines*))))
;      (nconc (wow preferred) (wow others)))))
;
;#+Franz ;;Code to format comtab name references (perhaps use c-U m-X Eval Into Buffer)
;(defun 1format-name-comtab0 ()
;  (loop for (name doc) in *dex-long-name-comtab*
;	do (format T "~&@Reference(Topic={~a},Type={Section},Field={Topic})@~~~%@\~a~2%"
;		   name doc)))
;



(define-doc-ex-command (1com-refresh0 :keyboard-accelerator #\refresh)
    ()
   (prepare-viewer)
   (send current-viewing-context :refresh-display self))

;(define-doc-ex-command (com-goto-beginning)
;    ()
;   ;; --- how do we deal with the help text?
;   (send viewer-pane :set-viewport-position 0 0))

(define-doc-ex-command-and-documentation
  (1com-goto-beginning0 :keyboard-accelerator #\m-<
		      :documentation "Positions the viewer to the first topic.")
    ()
   (prepare-viewer)
   (let ((first-item (first-item current-viewing-context)))
     (if first-item (display-item self :beginning first-item)
	 ;; maybe this beep really wants to be
	 ;; (send viewer-pane :set-viewport-position 0 0)
	 ;; ??
	 (beep))))

(define-doc-ex-command-and-documentation
  (1com-goto-end0 :keyboard-accelerator #\m->
		:documentation "Positions the viewer to the last screen displayed for the last topic.")
    ()
   (prepare-viewer)
   (let ((last-item (last-item current-viewing-context)))
     (if last-item
	 (display-item self :end last-item)
	 (beep))))



(defmethod1 (display-item0 1doc0-1ex)0 (location &optional item)
  (let ((current-item (or item (currently-displayed-item current-viewing-context))))
    (if current-item
	(ecase location
	  (:beginning
	    (send current-viewing-context
		  :display-dex-item current-item viewer-pane :hbox :start
		  ))
	  (:end					;might be longer than window, might not
	    (let ((window-height (tv:sheet-inside-height viewer-pane)))
	      (if ( (send current-item :item-pixels) window-height)	;fits?
		  (send current-viewing-context	;yes, just redisplay it
			:display-dex-item current-item viewer-pane :hbox :start
			)
		  ;;
		  (loop with height = 0
			for line = (send current-item :last-hbox) then (nsage::box-prev line)
			until (> height window-height)	;go until you've gotten one too many
			do
		    (incf height (send line :screen-display-height-of-box))
			finally
			  (send current-viewing-context ;now move forward to the right one
				:display-dex-item current-item viewer-pane
				:hbox (and line (nsage::box-next line))))))))
	(beep))))

(define-doc-ex-command (1com-show-more-of-topic0)
    ((item 'bookmark :default nil
	   :prompt "topic"))
   (prepare-viewer)
   (let ((last-presentation (send item :last-presentation)))
     (cond ((null last-presentation)
	    (beep))
	   (t
	    ;; clear the screen, remove the ellipsis presentation
	    ;; and show more of the topic.
	    (multiple-value-bind (ignore top)
		(send (dw:get-program-pane 'viewer-pane) :viewport-position )
	      (send current-viewing-context :display-more-of-dex-item item top)
	      )
	    ))))

(define-presentation-to-command-translator show-more-of-topic
					   (sage-ellipsis)
  (sage-ellipsis)
  `(com-show-more-of-topic ,(first sage-ellipsis)))


;;; The (current) scrolling theory:
;;; There is an "active-topic".  For the time being, the 1active-topic
0;;; is the last displayed topic in the viewer.  You should NEVER see the
;;; ellipsis marker for the active topic.  That is, if the ellipsis marker for that
;;; topic would ever be on the screen, read more stuff from the file system to prevent
;;; that from happening.
;;;
;;; Later, we'll think about how to make topics that aren't at the end be active.

(define-doc-ex-command (1com-scroll-viewer0)
    ((type '((member :screen :line :beginning :end))
	   :prompt "by" :default :screen)
     (count 'integer :default +1 :prompt "repeat count"))
   (prepare-viewer)
   (let ((tv:*asynchronous-window-operation* t))
     ;; pretend that the scroll bar was used to scroll this
     ;; so that our window-wakeup-handler will run and reformat stuff
     ;; if necessary.
     (cp::scroll-window-command-internal type count :y viewer-pane))
   )

(cp:define-command-accelerator 1scroll-viewer-forward
0			       "doc-ex" (#\scroll #\c-V)
			       () (numeric-arg-p numeric-arg)
  `(com-scroll-viewer
     ,(case numeric-arg-p
	((nil :sign) :screen)
	(:infinity :end)
	(otherwise :line))
     ,numeric-arg))

(cp:define-command-accelerator 1scroll-viewer-backward
0			       "doc-ex" (#\m-scroll #\m-V)
			       () (numeric-arg-p numeric-arg)
  `(com-scroll-viewer
     ,(case numeric-arg-p
	((nil :sign) :screen)
	(:infinity :beginning)
	(otherwise :line))
     ,(- numeric-arg)))

(install-dex-command-documentation 'scroll-viewer-forward '(#\Scroll #\c-V)
				   "Shows the next screen or topic in the viewer.")

(install-dex-command-documentation 'scroll-viewer-backward '(#\m-Scroll #\m-V)
				   "Shows the previous screen or topic in the viewer.")

(define-doc-ex-command (1com-scroll-typeout-window0)
    ((type '((member :screen :line :beginning :end))
	   :prompt "by" :default :screen)
     (count 'integer :default +1 :prompt "repeat count"))
   (cp::scroll-window-command-internal type count :y *standard-output*))

(cp:define-command-accelerator 1scroll-typeout-window-forward
0			       "doc-ex" (#\c-scroll)
			       () (numeric-arg-p numeric-arg)
  `(com-scroll-typeout-window
     ,(case numeric-arg-p
	((nil :sign) :screen)
	(:infinity :end)
	(otherwise :line))
     ,numeric-arg))

(cp:define-command-accelerator 1scroll-typeout-window-backward
0			       "doc-ex" (#\c-m-scroll)
			       () (numeric-arg-p numeric-arg)
  `(com-scroll-typeout-window
     ,(case numeric-arg-p
	((nil :sign) :screen)
	(:infinity :beginning)
	(otherwise :line))
     ,(- numeric-arg)))

(install-dex-command-documentation 'scroll-typeout-window-forward '(#\c-Scroll)
				   "Shows the next screen of the typeout window.")

(install-dex-command-documentation 'scroll-typeout-window-backward '(#\c-m-Scroll)
				   "Shows the previous screen of the typeout window.")


(define-doc-ex-command (1com-scroll-search0)
    ;; decide how to handle typeout window later.
    ((direction '((member :forward :backward))
		:prompt "direction"
		:default :forward))
   (prepare-viewer)
   (dw::scroll-search-internal
     viewer-pane direction
     (ecase direction
       (:forward (send viewer-pane :viewport-displayed-strings-start-index))
       (:backward (send viewer-pane :viewport-displayed-strings-end-index)))))

(cp:define-command-accelerator 1scroll-search-forward
0			       "doc-ex" (#\super-S)
			       () ()
  `(com-scroll-search :forward))

(cp:define-command-accelerator 1scroll-search-backward
0			       "doc-ex" (#\super-R)
			       () ()
  `(com-scroll-search :backward))

(install-dex-command-documentation 'scroll-search-forward '(#\super-s)
				   "Searches forward for a given string.")

(install-dex-command-documentation 'scroll-search-backward '(#\super-r)
				   "Searches backward for a given string.")

;;; Should this be a DW routine?
(defun 1kill-ring-push-marked-text-of-windows0 (&rest windows)
  (let ((string
	  (reduce (lambda (x y)
		    (cond ((and x y)
			   (string-append x #\return y))
			  (x x)
			  (y y)))
		  (loop for window in windows
			when (operation-handled-p window :region-strings)
			  collect (send window :region-strings-into-string))))
	(interval (zwei:create-interval nil nil (make-instance 'zwei:kill-ring-interval))))
    (cond (string
	   (zwei:insert (zwei:interval-last-bp interval) string)
	   (send zwei:*kill-history* :push interval))
	  (beep))))

(defun 1kill-ring-clear-region-strings-of-windows0 (&rest windows)
  (loop for window in windows
	with cleared-some
	when (send-if-handles window :region-strings)
	  do
	    (setq cleared-some t)
	    (send window :clear-region-strings)
	finally
	  (unless cleared-some (beep))))

(define-doc-ex-command-and-documentation
  (1com-clear-marked-text
0    :keyboard-accelerator #\super-G
    :documentation "Unmarks marked text.")
    ()
   (apply #'kill-ring-clear-region-strings-of-windows
	  (send dw:*program-frame* :exposed-inferiors)))

(define-doc-ex-command-and-documentation
  (1com-push-marked-text0 :keyboard-accelerator #\super-W
			:documentation "Pushes marked text onto the kill ring.")
    ()
   (apply #'kill-ring-push-marked-text-of-windows
	  (send dw:*program-frame* :exposed-inferiors)))

#||
;;; Test functions
(define-doc-ex-command (com-move-topic-down)
    ((topic 'bookmark)
     (amount 'integer :default 200))
   (let ((start-presentation (send topic :first-presentation)))
     (when start-presentation
       (multiple-value-bind (left top)
	   (dw::box-edges (dw::presentation-displayed-box start-presentation))
	 (send viewer-pane :experimental-move-region top (+ top amount))))))

(define-doc-ex-command (com-clear-history)
    ()
   (send viewer-pane :clear-history))

(define-doc-ex-command (com-insert-ellipsis)
    ((dex-item 'bookmark :default nil :prompt "topic"))
   (send dex-item
	 :set-last-presentation
	 (send viewer-pane :insert-ellipsis dex-item (send dex-item :last-hbox))))

(define-doc-ex-command (com-remove-ellipsis)
    ((item 'bookmark :default nil :prompt "topic"))
   (let ((last-presentation (send item :last-presentation)))
     (send viewer-pane :erase-displayed-presentation last-presentation)))

(define-doc-ex-command (com-evaluate-form)
    ((form 'sys:expression :default nil))
   (print (eval form)))

||#



;(defmethod 1(:command-loop0 1dex)0 ()
;  (send command-pane :fresh-line)
;  (flet ((doit ()
;	   (declare (sys:downward-function))
;	   (loop do
;	     (let ((values
;		     (multiple-value-bind (thing key) (send self :read-command)
;		       (if (listp key)		;It's really clause from the command alist
;			   (destructuring-bind (string doc message . message-args) key
;			     (ignore string doc)
;			     (lexpr-send self :command-message message message-args))
;			   (selectq key
;			     (:blip
;			      (send self :command-blip (first thing) (rest1 thing)))
;			     (:command
;			      (destructuring-bind (char numeric-arg) (rest1 thing)
;				(send self :command-char char numeric-arg)))
;			     (otherwise
;			      (if *debugging-sage*
;		 		  (fsignal "What key? ~s ~s" thing key)
;				  (beep))))))))
;	       (send command-pane :clear-window)
;	       (if (and (listp values) (eq (first values) 'sage:print-string))
;		   (cl:apply #'format command-pane (cdr values)))))))
;    ;;I need (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")keeping-sage-files-if
0;    (if *input-wait-before-closing-files*
;	(keeping-sage-files (doit))
;	(doit))))


;;;Private document stuff
;;;Has to be written to not depend on having the writers tools, hence the
;;;very simplistic approach taken (for Release 6.0)
;;; --- And copied for 7.2.  -- Doughty

(define-doc-ex-command-and-documentation
  (1com-save-private-document
0    :documentation "Saves the current bookmarks as a private document."
    :menu-accelerator t
    :menu-level :private-document-commands)
    ((pathname '((pathname) :default-type :private-document)
	       :default (send (fs:merge-pathnames "private" (fs:default-pathname))
			      :new-canonical-type :private-document)
	       :confirm t))
   (save-private-document current-viewing-context pathname))

(define-doc-ex-command-and-documentation
  (1com-read-private-document
0    :menu-level :private-document-commands
    :documentation "Reads a private document into a viewer, viewing all topics.")
    ((pathname '((pathname) :default-type :private-document)
	       :default (send (fs:merge-pathnames "private" (fs:default-pathname))
			      :new-canonical-type :private-document)
	       :confirm t))
   (read-load-private-document self pathname
			       #'(lambda (record-group)
				   (send current-viewing-context :add-item-to-context
					 (make-dex-item record-group)))))

(define-command-and-menu
  "Read Private Document" com-read-private-document :private-document-commands
  "Reads a private document into a viewer, viewing all topics."
  doc-ex (:top-level))
(define-command-and-menu
  "Read Private Document" com-read-private-document :private-document-commands
  "Reads a private document into a viewer, viewing all topics."
  small-doc-ex (:other-commands))

(define-doc-ex-command-and-documentation
  (1com-load-private-document
0    :documentation "Loads the bookmarks for a private document without viewing any topics."
    :menu-accelerator t
    :menu-level :private-document-commands)
    ((pathname '((pathname) :default-type :private-document)
	       :default (send (fs:merge-pathnames "private" (fs:default-pathname))
			      :new-canonical-type :private-document)
	       :confirm t))
   (read-load-private-document self pathname
			       #'(lambda (record-group)
				   (send current-viewing-context :add-item-to-bookmarks
					 (make-dex-item record-group)))))


(defmethod 1(save-private-document dex-viewing-context)0 (pathname)
  (save-private-document bookmarks-contents pathname))

(defmethod 1(save-private-document dex-bookmarks-contents)0 (pathname)
  (with-open-file (stream pathname :direction :output :characters nil :byte-size 8)
    (nsage::with-sab-symbol-table (symbol-table :write stream)
      (nsage::write-16-bit-number stream (fill-pointer contents))
      (loop for item being the array-elements of contents
	    as topic = (nsage::record-group-topic (send item :record-group))
	    as type = (nsage::record-group-type (send item :record-group))
	    do
	(nsage::write-sab-topic-spec topic stream symbol-table)
	(nsage::write-sab-type-spec (nsage::coerce-record-type type 'nsage::external)
				    stream symbol-table)))))

(defmethod 1(read-load-private-document doc-ex)0 (doc-pathname action-function
							     &optional (context-p t))
  (declare (sys:downward-funarg action-function))
  (when context-p
    (apply 'com-select-viewer
	   (cp:read-command-arguments 'com-select-viewer :stream *query-io*
				      :prompt "Viewer to select")))
  (with-open-file (stream doc-pathname :characters nil :byte-size 8)
    (nsage::with-sab-symbol-table (table :read stream)
      (loop repeat (nsage::read-16-bit-number stream)
	    for topic = (nsage::read-sab-thing stream table ())    ;odd, but it knows best
	    for type = (nsage::read-sab-thing stream table nsage::=sab-code-type-symbol=)
	    as record-group = (nsage::find-record-group-for-topic-and-type topic type)
	    do
	(funcall action-function record-group)))))

(fs:define-canonical-type :private-document "PSB")
(defprop :private-document 8. :binary-file-byte-size)
