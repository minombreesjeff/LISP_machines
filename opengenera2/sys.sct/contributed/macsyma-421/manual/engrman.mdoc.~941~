  -*- Mode: Text -*-
/* >                                                                         */
/* > **********************************************************************  */
/* > The software, data, and information contained herein are proprietary    */
/* > to, and comprise valuable trade secrets of, Macsyma Inc., which         */
/* > intends to keep such software, data, and information confidential and   */
/* > to preserve them as trade secrets.  They are given in confidence by     */
/* > Macsyma Inc. pursuant to a written license agreement, and may be        */
/* > used, copied, transmitted, and stored only in accordance with the       */
/* > terms of such license.                                                  */
/* >                                                                         */
/* > ** Copyright (c) 1982 - 1998 Macsyma Inc.  All rights reserved.         */
/* > ** Portions copyright (c) 1982 Massachusetts Institute of Technology.   */
/* > **                        All rights reserved.                          */
/* >                                                                         */
/* > Common Lisp Macsyma, PC Macsyma, Lisp Machine Macsyma, and              */
/* > CL-Macsyma are trademarks of Macsyma Inc.                               */
/* >                                                                         */
/* > Macsyma (R) and Macsyma Newsletter (R) are registered                   */
/* > trademarks of Macsyma Inc.                                              */
/* >                                                                         */
/* > All product names used herein which are not the trademarks of           */
/* > Macsyma Inc. are the trademarks of their respective owners.             */
/* >                                                                         */
/* > Type  describe(trade_secret);  in Macsyma to see other proprietary      */
/* > copyrights and trademarks.                                              */
/* >                                                                         */
/* > Type  describe(acknowledgments);  in Macsyma to see acknowledgments     */
/* > and copyright notices for contributed software.                         */
/* >                                                                         */
/* > RESTRICTED RIGHTS LEGEND                                                */
/* > Use, duplication, and disclosure by the Government are subject to       */
/* > restrictions as set forth in subdivision (c)(1)(ii) of the Rights in    */
/* > Technical Data and Computer Software Clause at DFAR 52.227-7013.        */
/* >                                                                         */
/* >      Macsyma Inc.                                                       */
/* >      20 Academy Street                                                  */
/* >      Suite 201                                                          */
/* >      Arlington, Massachusetts 02476                                     */
/* >      United States of America                                           */
/* >      781-646-4550                                                       */
/* >                                                                         */
/* > **********************************************************************  */
/* >                                                                         */


Note well:  1) ampersand (&) at the beginning of a line starts a new
section 2) Periods are not allowed as the first non-blank character on any
line

RJP and RHB 2/29/96 try to enforce better style rules so:
     more blank lines to separate sections within an entry
     separate Do example,, Do demo paragraph
     separate See also, which goes last
     Default and package references look neater.

&Abracadabra - The magic word.  (You were expecting maybe a genie?)

&"!" 

The factorial operator, which is the product of all the integers from 1
up to its argument.  Thus 5! = 1*2*3*4*5 = 120.  The value of the option
FACTORIAL_LIMIT default:FALSE gives the highest factorial which is
automatically expanded.  If it is FALSE then all integers are expanded.
See also the FACTORIAL, MINFACTORIAL, and FACTCOMB commands.

Do EXAMPLE(FACTORIAL_LIMIT); for an example.

&"!!"

Stands for double factorial which is defined as the product of all the
consecutive odd (or even) integers from 1 (or 2) to the odd (or even)
argument.  Thus 8!! is 2*4*6*8 = 384.

&"#" 

The syntactic logical operator "Not equals".  IS(A#B)  is equivalent 
to  IS(NOT A=B) .

See also "=", EQUAL, and NOTEQUAL.

&"^" 

The infix notation for the scalar exponentiation operator, as in A^B
where A and B are both scalars.

&"^`" 

The postfix notation for the transpose operator, as in A^` where A is a
matrix.

Do EXAMPLE(TRANSPOSE); for an example.

See also "^*", "^~`", "^~*", and TRANSPOSE.

&"^*" 

The postfix notation for the conjugate transpose operator, as in A^*
where A is a matrix.

Do EXAMPLE(TRANSPOSE); for an example.

See also "^`", "^~`", "^~*", "*^", CONJUGATE, and TRANSPOSE.

&"*^" 

The postfix notation for the conjugate function, as in A*^.

Do EXAMPLE(CONJUGATE); for an example.

See also CONJUGATE, "^*", and "^~*".

&"^~`" 

The postfix notation for the counter-transpose operator (reflection
about the counter-diagonal), as in A^~` where A is a matrix.

Do EXAMPLE(TRANSPOSE); for an example.

See also "^*", "^`", "^~*", and TRANSPOSE.

&"^~*" 

The postfix notation for the conjugate counter-transpose operator
(reflection about the counter-diagonal and conjugated), as in A^~*
where A is a matrix.

Do EXAMPLE(TRANSPOSE); for an example.

See also "^*", "^`", "^~*", CONJUGATE, and TRANSPOSE.

&"%"

The last D-line computed by MACSYMA (whether or not it was printed
out).  (See also "%%".)

&"%%"

The value of the last computation performed while in a Macsyma BREAK.
Also may be used in compound statements in the nth statement to refer to
the value of the (n-1)th statement.  

For example,  
  F(N):=(INTEGRATE(X^N,X),SUBST(3,X,%%)-SUBST(2,X,%%));

is equivalent to
  F(N):=BLOCK([%%], %%:INTEGRATE(X^N,X),SUBST(3,X,%%)-SUBST(2,X,%%));

This will also work for communicating between the (n-1)th and nth
(non-atomic) BLOCK statements.  Translation and compilation of %% is
now supported.

See also "%".

&%%a_0 

[PHYCON package] Bohr radius

&%alpha 

[PHYCON package] Fine structure constant

&%%C 

[PHYCON package] The speed of light in vacuum 

&%C 

See %K1

&%C1 

[PHYCON package] First radiation constant

&%C2 

[PHYCON package] Second radiation constant

&%CATALAN 

Catalan's constant, which has been variously denoted by, lambda G, and
beta(2). It is unanimously defined to be

    inf                   1      2     2       3
   ====         n    psi (-) - pi    pi - psi (-) 
   \       (- 1)        1 4                  1 4  
    >   ---------- = ------------- = ------------ .  
   /             2         8               8
   ==== (2 n + 1)
   n = 0

Currently %CATALAN has a NUMER property of 0.9159656 and a CONSTANT
property.  It is used in the trigamma and dilogarithm simplification
routines to permit reduction to closed forms.

&%%E 

[PHYCON package] elementary charge

&%E 

The Macsyma representation for the base of natural logarithms

&%E_B 

[PHYCON package] Hartree Energy

&%E_TO_NUMLOG default:FALSE 

When TRUE, "r" some rational number, and "x" some expression,
%E^(r*LOG(x)) will be simplified into x^r .  (If "r" is an integer,
this simplification happens by default.)  It should be noted that the
RADCAN command also does this transformation, and more complicated
transformations of this type as well.

&%EDISPFLAG default:FALSE 

If TRUE, MACSYMA displays %E to a negative symbolic exponent as a
quotient, i.e. %E^-X as 1/%E^X.

&%EMODE default:TRUE 

When TRUE %E^(%PI*%I*X) will be simplified as follows: it will become
COS(%PI*X)+%I*SIN(%PI*X) if X is an integer or a multiple of 1/2, 1/3,
1/4, or 1/6 and thus will simplify further.  For other numerical X it
will become %E^(%PI*%I*Y) where Y is X-2*k for some integer k such
that ABS(Y)<1.  If %EMODE is FALSE no simplification of %E^(%PI*%I*X)
will take place.

See also DEMOIVRE.

&%ENUMER default:FALSE 

When TRUE will reliably cause %E to be converted into 2.781...
whenever NUMER is TRUE.  The default is that this conversion will take
place only if the exponent in %E^X evaluates to a number.

&%EPSILON_0 

[PHYCON package] vacuum permittivity

&%%G 

[PHYCON package] gravitational constant

&%GAMMA 

The Euler-Mascheroni constant.  The notation %GAMMA is used for
consistency with standard texts which use the Greek letter gamma; it
can be defined as follows:
                                      M
                                     ====
                                     \     1
           %GAMMA   =    limit    ((  >    -) - LOG(M))
                         M -> INF    /     N
                                     ====
                                     N = 1

Currently %GAMMA has a NUMER property of 0.577215665 and a CONSTANT
property.  It is used along with the Polygamma simplification routines
to permit their reduction to closed forms.

&%%H 

[PHYCON package] Planck's constant

&%HBAR 

[PHYCON package] %h/(2*%pi)

&%I 

The Macsyma representation for "i", the square root of -1 .  Some
commands and switches which handle %I are, LOGNEG, REALPART,
IMAGPART, RECTFORM, POLARFORM, ABS, CARG, and CABS.

See COMPLEX for a partial summary of commands for complex arithmetic.

&%IARGS default:TRUE 

Provides automatic simplification of trigonometric functions for some
angles of the form %I*X.  If TRUE, this option variable enables the
conversion of trigonometric (hyperbolic) functions of expressions
proportional to %I to hyperbolic (trigonometric) functions.  If FALSE,
this conversion is inhibited.

&%J [index](expr) 

This function has been renamed BESSEL_J

&%K_B 

[PHYCON package] Boltzmann constant

&%K1 and %K2

Arbitrary constants of integration introduced into solutions of second
order differential equations returned by the ODE package.

Generally, when MACSYMA introduces a system symbol, the symbol usually
begins with a `%' sign, to avoid using letters and names which the user
may have employed.

See also %R.

%C

Arbitrary constants of integration introduced into solutions of first
order differential equations returned by the ODE package.

Generally, when MACSYMA introduces a system symbol, the symbol usually
begins with a `%' sign, to avoid using letters and names which the user
may have employed.

See also %R.

&%L_PLANCK 

[PHYCON package] Planck length

&%M_E 

[PHYCON package] Electron mass

&%M_N 

[PHYCON package] Neutron mass

&%M_P 

[PHYCON package] Proton mass

&%M_PLANCK 

[PHYCON package] Planck mass

&%MU_0 

[PHYCON package] vacuum permeability

&%N 

When SOLVE solves certain trig and exponential problems 
it introduces arbitrary integers spelled e.g. %n1 .

E.g. for SOLVE(sin(x),x);  ->  [x = %pi %n1] .

See also SOLVE, ALLSOLVE, ARBINT_NAME, and ARBINT_NUM.

&%N_A 

[PHYCON package] Avogadro's Number mol^-1

&%PHI 

The constant (SQRT(5)+1)/2 = 1.618033989.  If you want the Rational
Function Package to know about %PHI do TELLRAT(%PHI^2-%PHI-1)$
ALGEBRAIC:TRUE$ .  

See also FIBTOPHI.

&%PHI_0 

[PHYCON package] Magnetic Flux quantum

&%PI 

The Macsyma representation for pi.

&%PIARGS default:TRUE 

Provides automatic simplification of trigonometric functions for some
angles of the form R*%PI and R*%PI+B, where R is a rational number.
If TRUE, the automatic simplification of trigonometric and inverse
trigonometric functions is enabled.  Expressions of the form
trigfun(R*%PI+B) are simplified if R is an integer multiple of 1/2 (or
%I/2, for hyperbolics), or if B is 0 and the result is expressible in
non-nested radicals.  If FALSE, these evaluations are inhibited.
Inverse trigonometric functions will reconstruct, where possible, the
rational multiples of %PI, including many cases where radicals are
nested.

%PIARGS:ALL will force trigfun(R*%PI) into algebraic (probably nested
radical) form when R has the form integer/(8*3*5*17) (or half that, for
TAN and COT).  These are the known cases (excluding iterated half
angles, and multiples of %PI/257 and %PI/65537) which avoid complex
subexpressions.

If the denominator of R contains a higher power of 2, and you want
(nested) radicals, HALFANGLES:TRUE will force iterated application of
the halfangle formulas.  

Do EXAMPLE(%PIARGS); for an  executable example and DEMO(TRIG_ANGLES);
for a longer demonstration. 

&%POS

Solutions returned by the inequality solver INEQ_LINSOLVE denote real
parameters which are positive by the symbols %POS1, %POS2, ... .  
The integer in the name is the value of the system variable %PZNUM.

See also %PZ, %R, %K1, %C.

&%PZ

Solutions returned by the inequality solver INEQ_LINSOLVE denote real
parameters which are non-negative by the symbols %PZ1, %PZ2, ... .
The integer in the name is the value of the system variable %PZNUM.

See also %POS, %R, %K1, %C.

&%R 

When %R variables are introduced in solutions by ALGSYS or LINSOLVE,
they are named by concatenating "%R" with the number held in %RNUM.

Generally, when Macsyma introduces a system symbol, the symbol usually
begins with a `%' sign, to avoid using letters and names which the user
may have employed.

See also %POS, %PZ, %K1 and %C.

&%R_GAS

[PHYCON package] Universal Gas constant

&%R_INF 

[PHYCON package] Rydberg constant

&%RNUM_LIST default:[] 

When %R variables are introduced in solutions by ALGSYS or LINSOLVE,
they are named by concatenating "%R" with the number held in %RNUM.
Resetting the %RNUM option variable restarts the sequence.  %RNUM must 
be a nonnegative integer.  The %R variables are added to %RNUM_LIST in 
the order they are created.  This is convenient for doing substitutions 
into the solution later on.  It's recommended to use this list rather 
than doing CONCAT('%R,J).

&%SIGMA 

[PHYCON package] Stefan-Boltzmann constant

&%T_P 

[PHYCON package] Planck time

&%TH(i) 

refers to the value returned by the ith previous computation.  That is,
if the next expression to be computed is D(j) this is D(j-i).  This is
useful in BATCH files or for referring to a group of D expressions.  For
example, if SUM is initialized to 0 then FOR I:1 THRU 10 DO
SUM:SUM+%TH(I) will set SUM to the sum of the last ten D expressions.

&%Y [index](expr) 

This function has been renamed BESSEL_Y 

&"'" 

(single quote) has the effect of preventing evaluation.  For example,
'(F(X)) means do not evaluate the expression F(X).  'F(X) means return
the noun form of F applied to [X].

Example:

  (c1) A: 1$
  (c2) B: A$
  (c3) C:'A$
  (c4) B;
  (d4)                 1
  (c5) C;
  (d5)                 a

See also "''", NOUN, NOUNIFY, VERB, VERBIFY.

&"''" 

(two single quotes) causes an extra evaluation to occur. For example,
''c4; will re-execute line C4.  ''(F(X)) means evaluate the expression
F(X) an extra time.  ''F(X) means return the verb form of F applied to
[X].

See also "'", NOUN, NOUNIFY, VERB, VERBIFY.

&":" 

The assignment operator.  E.g. A:3 sets the variable A to 3.  The
right-hand side is evaluated and assigned to the symbol on the left hand
side.

Note that assigning a list value to a variable should be done with
COPYLIST, because the assignment operator ":" will merely make a pointer
to the former list.  For example:

  (c1) LIS: [A,B,C]$
  (c2) X: LIS$
  (c3) Y: X$
  (c4) Z: COPYLIST(LIS)$
  (c5) SET_ELEMENT(X, 1, D)$
  (c6) X;
  (d6)                         [d, b, c]
  (c7) Y;
  (d7)                         [d, b, c]
  (c8) Z;
  (d7)                         [a, b, c]

Similarly, matrix assignments should be made with COPYMATRIX.

See also "::".

&"::" 

Assignment operator.  :: assigns the value of the expression on its
right to the value of the quantity on its left, which must evaluate to
an atomic variable or subscripted variable.  Do DEMO(PASS_OUT); for a
demonstration of how "::" can be used to pass computed values out of
Macsyma functions.

See also ":", which is the usual assignment operator.

&"::=" 

The "::=" is used instead of ":=" to indicate that what follows is a
macro definition, rather than an ordinary functional definition.  

See also MACROS.

&":=" 

The function definition operator.  For example, F(X):=SIN(X) defines a
function F.

&"." 

The dot operator, for matrix multiplication and general non-commutative
multiplication. When "." is used in this way, spaces should be left on
both sides of it, e.g. A . B.  This distinguishes it plainly from a
decimal point in a floating point number.

As the general noncommutative multiplication operator, "." can be made
to act like a general multilinear operator, through the switches which
control its linearity properties.  These switches are DOT, DOT0NSCSIMP,
DOT0SIMP, DOT1SIMP, DOTASSOC, DOTCONSTRULES, DOTDISTRIB, DOTEXPTSIMP,
DOTIDENT, DOTSCRULES.

When "." is used in this way, spaces should be left on both sides of
it, e.g. A . B.  This distinguishes it plainly from a decimal point
in a floating point number.

Do USAGE(DOTOPERATOR); for more information.

See also ATENSOR, MATRIX_SUMMARY.

Warning: In the vector calculus package VECT, "." is used for the
inner product of vectors.  VECT makes "." a commutative operator by
executing the statement DECLARE(".",COMMUTATIVE); .  In order to
reuse "." as the general noncommutative multiplication operator,
enter the command REMOVE(".",COMMUTATIVE); .

&"3D" 

A keyword to 3 dimensional plotting functions which causes
two-dimensional slices of the image to be plotted in 3 dimensional
space, without hidden line removal.

See also NOT3D.

&"?" 

As prefix to a function or variable name, signifies that the function
or variable is a LISP token, not a Macsyma token.

&"=" 

Denotes an equation to Macsyma.  In the data base routines in Macsyma,
"=" denotes a total relation that holds between two expressions if and
only if the expressions are syntactically identical.

See also EQUAL, IS, EQUALP, "#", and NOTEQUAL.

&ABORT() 

Terminates the ongoing computation and returns to the innermost
Macsyma command loop.

&ABS(X) 

Absolute value of X.  The behavior is controlled by ABS_USES_CABS.
Note: The DELINT package alters the form of the derivative of ABS.

Do EXAMPLE(ABS); for an example. 

See also CABS and CARG.

For character-based display, ABSBOXCHAR[|] is the character used to
draw absolute value signs around expressions which are more than a
single line high.

&ABSBOXCHAR default: |

This is the character used to draw absolute value signs around
expressions which are more than a single line high.  In FANCY_DISPLAY
mode, ABSBOXCHAR is not used.

&ABS_USES_CABS default:FALSE

Tells ABS() whether it may use CABS().
If ABS_USES_CABS is FALSE, ABS of such a quantity remains as ABS.
E.g.   ABS(A+%I*B)  ->  ABS(%I*B+A) .

If ABS_USES_CABS is TRUE, ABS of a complex quantity computes its
  complex modulus. 
E.g.  ABS(A+%I*B);  ->  CABS(A+%I*B)  ->  SQRT(B^2+A^2) .

&ACKNOWLEDGMENT 

Papers that reference Macsyma should contain the following
acknowledgment:

(work (or computations) reported in this paper)...... was
done with the aid of Macsyma, a large symbolic manipulation
program developed at the MIT Laboratory for Computer Science
and supported from 1975 to 1983 by the National Aeronautics
and Space Administration under grant NSG 1323, by the Office
of Naval Research under grant N00014-77-C-0641, by the U. S.
Department of Energy under grant ET-78-C-02-4687, and by the
U. S. Air Force under grant F49620-79-C-020, between 1982 and
1992 by Symbolics, Inc. of Burlington, Mass., and since 1992
by Macsyma Inc. of Arlington, Mass.  Macsyma is a registered
trademark of Macsyma Inc.

&ACKNOWLEDGMENTS

Macsyma includes many capabilities developed by many people at many
institutions for which we are grateful.  This entry contains legal
acknowledgments for contributed software.  If this entry is missing
an acknowledgment you feel it should contain, please get in touch
with Macsyma Inc.

This version of Macsyma (except where noted) contains:

[1] implementations of the Spear/Buchberger Grobner basis algorithm 
and Spear's ideal contraction algorithm.  We are grateful to Gail 
Zacharias, the original author, for permission to distribute them. 
(Original source file: MIT-MC:SHARE;GROB 202 .)
  Copyright (c) 1984, 1985 Gail Zacharias.
  Enhancements copyright (c) 1986, 1987, 1988 Macsyma, Inc.  
  All rights reserved.

[2] an implementation of the Pullman/Strauss Jordan Form algorithm.  
We are grateful to Nicholas Strauss, the original author, and the 
MIT SCHEME project, for permission to distribute it.
(Original source file: MIT-MC:SHARE;EIGEN 8 .)
  Copyright (c) 1985 Massachusetts Institute of Technology.
  Enhancements copyright (c) 1987, 1988 Macsyma, Inc.  
  All rights reserved.

[3] an improved Poisson series package using code supplied by 
Professor Richard Fateman.
  Copyright (c) 1982 Massachusetts Institute of Technology.
  Additional changes copyright (c) 1986 Richard J. Fateman.
  Enhancements copyright (c) 1988 Macsyma, Inc.  
  All rights reserved.

[4] a new partial differentiation package named NDIFF, developed at 
GTE Laboratories Incorporated, Waltham, MA 02254.
  Copyright (c) 1988, 1987, 1986, 1985, 1984, 1983, 1982 Macsyma, Inc.  
  Portions copyright (c) 1982 Massachusetts Institute of Technology.
  Portions copyright (c) 1986, 1985, 1984 GTE Laboratories Incorporated.
  All rights reserved.

[5] an operator algebra package named OPALG, developed at 
GTE Laboratories Incorporated, Waltham, MA 02254.
  Copyright (c) 1988, 1987, 1986, 1985, 1984, 1983, 1982 Macsyma, Inc.  
  Portions copyright (c) 1982 Massachusetts Institute of Technology.
  Portions copyright (c) 1986, 1985, 1984 GTE Laboratories Incorporated.
  All rights reserved.

[6] the GENTRAN numerical code generation facility.
  Copyright (c) 1986 Barbara Gates and Paul S. Wang, Kent State Univ.,
                     Kent, Ohio 44242.
  Enhancements copyright (c) 1988 Macsyma, Inc.  
  All rights reserved.

[7] the ODEFI ordinary differential equation solver using first integrals, 
based on the Prelle-Singer algorithm.
  Implemented by Roman Shtokhamer, Dept. of CIS, Univ. of Delaware.

[8] the TEX package for the conversion of Macsyma expressions into TeX.
It is based on a package written by Prof. Richard J. Fateman of the U. of 
Calif. at Berkeley.
  Copyright (c) 1987 Richard J. Fateman
  Enhancements copyright (c) 1989 Macsyma, Inc.  
  All rights reserved.

[9] the GENINV package for computing the Moore-Penrose matrix 
pseudo-inverse. 
  Designed and developed by Dr. Daniel Zwillinger and Dr. Michael J. Sousa
  of MathResources, Arlington, MA.

[10] the ODELIN2 package for second order linear ODEs.  
  Designed and implemented by Prof. Shunro Watanabe of Tsuda College, 
  Kodaira, Tokyo, Japan.

[11] extensions to the inverse Laplace transform package.
  Designed and implemented by Michael Clarkson of Institute of Space and
  Celestial Science, York University, York, Canada, and also of Centre de 
  Morphologie, Ecole des Mines, Fontainbleu, France.

[12] The PDELIE package
  Designed and implemented by Peter Vafeades of Trinity University, San
  Antonio, Texas. Copyright Trinity University and Peter Vafeades.

[13] The FEYNBOUND package
  Designed and implemented by Anthony D. Kennedy of Florida State University
  and William E. Caswell.

[14] (Lisp machine only) access to the Eispack library of routines, which 
  is made available through the National Energy Software Center in
  Argonne, IL. 

[15] The MATRICE package
  Designed and implemented by Michael Wester of the University of New Mexico.

[16] The interface between Matlab command vocabulary and Macsyma data
  types, designed and partially implemented by David H. Wood of the
  University of Delaware.

[17] The SOLVER package
  Designed and implemented by Eckhard Hennig and Ralf Sommer of the
  University of Kaiserslautern, drawing on a previous design and
  implementation by Hennig Trispel and Ralf Sommer at the University
  of Braunschweig, Germany.

[18] LAPACK (NUMKIT)
  Access to the LAPACK library of routines through NUMKIT, which are
  available through NETLIB. You can find detailed documentation on LAPACK
  in the LAPACK Users' Guide (1995, SIAM) and through the Internet
  at http://www.netlib.org/lapack/lug/lapack_lug.html. 

[19] The STOCH package
  Designed and implemented by Michael D. Stern, M.D. of Johns Hopkins
  University, now at National Institutes of Health.

[20] The CARLSON elliptic integrals package
  Initially designed and implemented by Jim FitzSimons of Cherrytree 
  Associates, based on the work of Bill C. Carlson of Ames Laboratory 
  and the Department of Mathematics, Iowa State University.

Do DESCRIBE(TRADE_SECRET); for information about proprietary copyrights
and trademarks.

&ACKNOWLEDGEMENT 

See ACKNOWLEDGMENT.
&ACKNOWLEDGEMENTS 

See ACKNOWLEDGMENTS.

&ACOS 

Arc Cosine

&ACOSD 

Same as the ACOS function, except the output is in degrees.

&ACOSH 

Hyperbolic Arc Cosine

&ACOT

Arc Cotangent

&ACOTD 

Same as the ACOT function, except the output is in degrees.

&ACOTH

Hyperbolic Arc Cotangent

&ACSC

Arc Cosecant

&ACSCD

Same as the ACSC function, except the output is in degrees.

&ACSCH

Hyperbolic Arc Cosecant

&ACTIVATE(cont1, cont2, ...) 

Causes the specified contexts conti to be activated.  The facts in these
contexts are used in making deductions and retrieving information.  The
facts in these contexts are not listed when FACTS(); is done.  The
variable ACTIVECONTEXTS is the list of contexts which are active by way
of the ACTIVATE function.

See CONTEXT for a general description of the context mechanism.

&ACTIVECONTEXTS default:[] 

A list of the contexts which are active by way of the ACTIVATE function,
as opposed to being active because they are subcontexts of the current
context.

See CONTEXT for a full description of the context mechanism.

&ADAPLOT

 Library package for adaptive density plotting.  The two main functions
are ADAPLOT2 and ADAPARAMPLOT2.

Do USAGE(ADAPLOT); for more information.

Do DEMO(ADAPLOT); for a demonstration.

&ADAPARAMPLOT2(xexpr,yexpr,tlow,thigh,xlow,xhigh,ylow,yhigh,optional-args)

Generates adaptive density parametric plots in two dimensions, whereby
the number of plot points is adjusted based on the curvature of the
curve.  

Do USAGE(ADAPLOT); for more information.

Do EXAMPLE(ADAPARAMPLOT2); for an example.

See also ADAPLOT2, PARAMPLOT.

&ADAPLOT2(yexpr, xvar, xlow, xhigh, ylow, yhigh, optional-args) 

Generates adaptive density plots in two dimensions, whereby the number
of plot points is adjusted based on the curvature of the curve.  Do
USAGE(ADAPLOT); for more information.

Do EXAMPLE(ADAPLOT2); for an example.

&ADDCOL(M, list1, list2, ..., listn) 

Appends the column(s) given by the zero or more lists (or matrices)
onto the matrix M.

Do EXAMPLE(ADDCOL); for an example.

See also ADDROW.

&ADDITIVE 

If DECLARE(F,ADDITIVE) has been executed, then:
(1) If F is univariate, whenever the simplifier encounters F applied to
    a sum, F will be distributed over that sum.  I.e. F(Y+X); will
    simplify to F(Y)+F(X).
(2) If F is a function of 2 or more arguments, additivity is defined as
    additivity in the first argument to F, as in the case of 'SUM or
    'INTEGRATE, i.e. F(H(X)+G(X),X); will simplify to F(H(X),X)+F(G(X),X).
This simplification does not occur when F is applied to expressions of
the form SUM(X[I],I,lower-limit,upper-limit).

ADDITIVE is a member of OPPROPERTIES.  It can be asserted with
DECLARE, withdrawn with REMOVE, and detected with GETPROP.

Do EXAMPLE(ADDITIVE); for an example.

&ADDROW(M, list1, list2, ..., listn) 

Appends the row(s) given by the zero or more lists (or matrices)
onto the matrix M.

Do EXAMPLE(ADDROW); for an example. 

See also ADDCOL.

&ADEFINT

[FOURIER Package] An internal command located in the FOURIER
package. This command computes Fourier coefficients, sin or cos
coefficients of functions, including forms with absolute value. 

See USAGE(FOURIER); for more information.

&ADJOINT(mat) 

Computes the classical adjoint of the matrix mat, which is equal to
the inverse matrix multiplied by the determinant.  Having computed the
adjoint of a matrix, ADJ:ADJOINT(MAT), for example, the determinant
can be gotten by DET:ROW(MAT,1) . COL(ADJ,1) , and then the inverse of
MAT can be gotten from ADJ/DET .  In fact, this is what the
INVERT_USING_MINORS function does.

Do EXAMPLE(ADJOINT); for an example. 

&AGD(X) 

[ALGFUNCS package] Inverse Gudermannian function.  It equals
LOG(TAN(%PI/4+X/2)). 

&AI(x)

See AIRY_AI.

&AIRY(x) 

The Airy function Ai of real argument X.  

The library file AIRY contains routines to evaluate the Airy functions
Ai(X), Bi(X), and their derivatives dAi(X), dBi(X).  Ai and Bi satisfy
the Airy equation diff(y(x),x,2)-x*y(x)=0.  

Do USAGE(AIRY) for more information.

See also AIRY_AI, AIRY_BI, AIRY_AI_DERIV, AIRY_BI_DERIV.

&AIRY_AI(x) 

[AIRY package] The Airy function Ai of real argument X.  

Do USAGE(AIRY); for more information.

See also AIRY_BI, AIRY_AI_DERIV, AIRY_BI_DERIV.

&AIRY_AI_DERIV(x) 

[AIRY package] Computes the derivative AIRY_AI_DERIV(x):=d(Ai(x))/dx.

&AIRY_BI(x)

[AIRY package] The Airy function Bi(X).

Do USAGE(AIRY); for more information.

See also AIRY_AI, AIRY_AI_DERIV, AIRY_BI_DERIV.

&AIRY_BI_DERIV(x)

[AIRY package] Computes the derivative AIRY_BI_DERIV(x):=d(Bi(x))/dx.

&ALAGUERRE_L(N, A, X) 

[SPECFUN package] computes the associated Laguerre polynomial
L(N,A,X) for nonnegative integer N, and real A>-1.

ALAGUERRE_L[N](A,X) is an alternative syntax, which stores the
associated Laguerre polynomials of order less than or equal to N.

Do LOAD(SPECFUN); to access this function.

See also LAGUERRE_L.

&ALEGENDRE_P(N, M, X) 

[SPECFUN package] Computes the associated Legendre polynomial of
the first kind P(N,M,X) for integers N >= M > 0.

ALEGENDRE_P[N,M](X) is an alternative syntax, which stores the associated
Legendre polynomials of order less than or equal to N.

Do LOAD(SPECFUN); to access this function.

See also ALEGENDRE_Q, LEGENDRE_P, LEGENDRE_Q.

&ALEGENDRE_Q(N, M, X) 

[SPECFUN package] Computes the associated Legendre polynomial of
the second kind Q(N,M,X) for nonnegative integer N, M.

Do LOAD(SPECFUN); to access this function.

See also ALEGENDRE_P, LEGENDRE_P, LEGENDRE_Q.

&ALG_TYPE default:UNIVERSAL

[ATENSOR package] Determines the commutation or anticommutation
relations to be used in the tensor algebra whose operation is denoted by
".".  When ATENSOR is loaded, DOTSCRULES and DOTDISTRIB are set to TRUE
and DOTEXPTSIMP is set to FALSE.  The permissible values of ALG_TYPE
are:

 UNIVERSAL This yields a universal tensor algebra generated by all
           symbols which are not declared SCALAR.

 GRASSMANN This yields a Grassmann (i.e. antisymmetric) algebra over all
           symbols which are not declared to be SCALAR. The defining 
           relation is that U.V + V.U = 0.

 CLIFFORD  This yields a Clifford algebra over all symbols which are
           not declared to be SCALAR. The defining relation is that
           U.V + V.U = 2 SF(U,V), where AF is a symmetric,
           scalar-valued function.

 SYMMETRIC This yields a Grassmann (i.e. antisymmetric) algebra over
           all symbols which are not declared to be SCALAR. The
           defining relation is that U.V - V.U = 0.

 SYMPLECTIC This yields a symplectic algebra over all symbols which are
            not declared to be SCALAR. The defining relation is that 
            U.V - V.U = 2 AF(U,V), where AF is an antisymmetric 
            scalar-valued function.

 LIE_ENVELOP This yields a Lie enveloping algebra over all symbols which 
             are not declared to be SCALAR. The defining relation is
             that U.V - V.U = 2 AV(U,V), where AF) is an antisymmetric
             function. 

&ALGDELTA default:1.e-5

This variable is used by ALGSYS when generating approximate solutions
to algebraic equations via ALLROOTS.  It is used in a residual test to
help determine whether the solutions found are valid and satisfy the
original equations.  The default value may be too strict in some
circumstances, especially with single precision.  It can be relaxed to
1.e-4, or the calculation can be repeated with dfloats or bigfloats.

&ALGEBRA

See ALGEBRA_SUMMARY.

&ALGEBRA_SUMMARY

Macsyma does many kinds of algebra, including

Arithmetic
----------

 - integers (FACTOR_NUMBER, GCD, LCM)
 - exact rational, algebraic, and transcendental numbers
   (ALGEBRAIC, FACTOR_NUMBER, TELLRAT, CF)
 - floating point numbers (SFLOAT, DFLOAT, BFLOAT, NUMER)
 - complex arithmetic 
   (COMPLEX, CABS, CARG, RECTFORM, POLARFORM, CONJUGATE)

Polynomial and rational function algebra
----------------------------------------

 - factoring (FACTOR, CFACTOR, FACSUM, FACTORSUM, FACTOROUT, GFACTOR,
   GCFACTOR, GFACTORSUM, PARTFRAC, POLYDECOMP)
 - expanding (EXPAND, EXPANDWRT, DISTRIB, MULTTHRU, RATEXPAND)
 - simplifying expressions 
   (RATSIMP, FULLRATSIMP, COMBINE, COLLECTTERMS, MULTTHRU, XTHRU)
 - roots (ALLROOTS,, ROOTS, PLOYSOLVE, REALROOTS)

Simplification of logarithms, radicals
--------------------------------------

 - LOGCONTRACT, LOGEXPAND, LOGSIMP
 - RADCAN, RADEXPAND, ROOTSCONTRACT, DENEST_SQRT, DENEST_SQRTS
 
Solving equations
-----------------

 - finding roots of algebraic equations
   (LINSOLVE, SOLVE, ALGSYS, MATSOLVE, SOLVER, GROBNER,
    ALROOTS, ROOTS)
 - solution of recurrence equations (DIFFERENCEQ)
 - inequalities (INEQ_LINSOLVE, INEQSIMP, INEQ_REVERSE)

Miscellaneous Algebra
---------------------

 - trigonometry (see TRIG_SUMMARY and POISSON)
 - manipulation of sums and products (SUM, NUSUM, SUMEXPAND,
   INTOSUM, NICEINDICES, SIMPSUM, SUMCONTRACT, CLOSEDFORM, PRODUCT) 
 - matrix algebra (see MATRIX_SUMMARY)
 - tensor algebra (see ATENSOR and TENSOR_SUMMARY)
 - assigning properties to symbolic variables (ASSUME, DECLARE, PUT)

If your version of Macsyma has an option menu system, then you can
open the category ALGEBRA to get lists of subtopics and common
commands.  For each command listed, you can obtain a description and
an executable example.

Macsyma has many other special capabilities for algebraic computation.
Consult the Macsyma Reference Manual for more information.

Do DEMO(ALGEBRA); for an introductory demonstration of algebra in
Macsyma.  See DEMOS_ALGEBRA for a list of algebra demonstration in
Macsyma.

&ALGEBRAIC default:FALSE

When set to TRUE, the rational function package simplifies algebraic
functions (such as SQRT(X)) and algebraic integers to take effect.
Algebraic integers are defined with the command TELLRAT, and the
simplification is performed by the command RAT.  

Do EXAMPLE(ALGEBRAIC); and EXAMPLE(TELLRAT); for examples.

See also RAT, TELLRAT, ALGEBRAICP.

&ALGEBRAICP(expr) 

Returns TRUE if and only if expr is considered to be algebraic relative
to the rational function package.  E.g., SQRT(X), %I, and SQRT(2) are
expressions for which ALGEBRAICP returns TRUE.  For example, this is one
way to determine if you want to set ALGEBRAIC to TRUE when you are
planning to do calculations involving the rational function package.

Do EXAMPLE(ALGEBRAICP); for an example.

See also ALGEBRAIC, TELLRAT, PREDICATES.

&ALGEPSILON default:10^8

The value of epsilon used by ALGSYS.

&ALGEXACT default:FALSE

ALGEXACT affects the behavior of ALGSYS as follows:

 - If ALGEXACT is TRUE, ALGSYS always calls SOLVE and then uses
   REALROOTS when SOLVE fails to return a solution.
 - If ALGEXACT is FALSE, ALGSYS calls SOLVE only if the eliminant
   was not univariate, or if it was a quadratic or biquadratic.

Thus ALGEXACT:TRUE does not guarantee that all solutions will be exact,
solutions, just that ALGSYS will first try as hard as it can to give
exact solutions, and will yield approximations only when all exact
methods fail.

Do EXAMPLE(ALGEXACT); for an example.

&ALGFAC(poly, alg) 

Factors the polynomial poly over afield including the algebraic number
alg.

For example:

 (c1) ALGFAC(A^2+B^2, %I);

 (d1)                (b - %i a) (b + %i a)

Do EXAMPLE(ALGFAC); for an example.

See also FACTOR, GFACTOR, GCFACTOR.

&ALGFUNCS

A library package which contains a collection of miscellaneous
algebraic functions. 

Do USAGE(ALGFUNCS); for more information.

&ALGSYS([exp1, exp2, ...], [var1, var2, ...]) 

Solves the list of simultaneous polynomials or polynomial equations
(which can be non-linear) for the list of variables.  The symbols %R1,
%R2, etc.  will be used to represent arbitrary parameters when needed
for the solution (the variable %RNUM_LIST holds these).  In the process
described below, ALGSYS is entered recursively if necessary.

The algorithm proceeds as follows:

1) If ALGSYS_USES_TRIANGSYS is set to TRUE (the default), ALGSYS uses
TRIANGSYS instead of the ALGSYS resultant-based elimination techniques. 
In this case any call ALGSYS(equation_list, var_list) is equivalent to

BLOCK([TRIANGSYS_OUTPUT_FORMAT:'ROOT_OF],
 ROOT_VALUES(TRIANGSYS(equation_list, variable_list), 'BIQUAD));

except perhaps for more optimal variable ordering used by ALGSYS.

TRIANGSYS is usually much faster than the other techniques ALGSYS 
might use, so this default binding of ALGSYS_USES_TRIANGSYS should 
not be changed except in exceptional circumstances.

2) Otherwise, if USE_GROBNER is set to TRUE, ALGSYS first calls GROBNER.

3) Then the equations are FACTORed and split into subsystems.

4) For each subsystem Si, an equation E and a variable var are
   selected (the var is chosen to have lowest nonzero degree).  Then
   the resultant of E and Ej with respect to var is computed for each
   of the remaining equations Ej in the subsystem Si.  This yields a
   new subsystem S'i in one fewer variables (var has been eliminated). 
   The process now returns to (1).

5) Eventually, a subsystem consisting of a single equation is obtained.
   If the equation is multivariate and no approximations in the form of
   floating point numbers have been introduced, then SOLVE is called to
   find an exact solution.  (The user should realize that SOLVE may not
   be able to produce a solution or if it does the solution may be a
   very large expression.)

   If the equation is univariate and is either linear, quadratic, or
   biquadratic, then again SOLVE is called if no approximations have
   been introduced.  If approximations have been introduced or the
   equation is not univariate and neither linear, quadratic, or
   biquadratic, then if the switch REALONLY (default:FALSE) is TRUE,
   the function REALROOTS is called to find the real-valued solutions.
   If REALONLY:FALSE then ALLROOTS is called which looks for real and
   complex-valued solutions.  If ALGSYS produces a solution which has
   fewer significant digits than required, the user can change the value
   of ALGEPSILON (default:10^8) to a higher value.  If ALGEXACT
   (default:FALSE) is set to TRUE, SOLVE will always be called.

5) Finally, the solutions obtained in step (4) are re-inserted into
   previous levels and the solution process returns to (1).

The user should be aware of several caveats:

 - When ALGSYS encounters a multivariate equation which contains
   floating point approximations (usually due to its failing to find
   exact solutions at an earlier stage), then it does not attempt to
   apply exact methods to such equations and instead prints the message:
        "ALGSYS cannot solve - system too complicated."

 - Interactions with RADCAN can produce large or complicated
   expressions.  In that case, the user may use PICKAPART or REVEAL to
   analyze the solution.  Occasionally, RADCAN may introduce an apparent
   %I into a solution which is actually real-valued.  

Do EXAMPLE(ALGSYS); for examples, and DEMO(ALGSYS); for a larger
demonstration.

See also SOLVE, TRIANGSYS, ROOT_VALUES, and ROOTS.

&ALGSYS_USES_TRIANGSYS default:TRUE

If ALGSYS_USES_TRIANGSYS is set to TRUE (the default), ALGSYS uses
TRIANGSYS instead of the ALGSYS resultant-based elimination techniques 
which are used when ALGSYS_USES_TRIANGSYS is FALSE.

See ALGSYS, SOLVE, and TRIANGSYS for more information.

&ALIAS(newname1, oldname1, newname2, oldname2, ...)  

Provides an alternate name for a (user or system) function, variable,
array, etc.  ALIAS takes any even number of arguments.

Do EXAMPLE(ALIAS); for an example.

See also ALIASES.

&ALIASES default:[] 

Atoms which have a user defined alias (set up by the ALIAS, ORDERGREAT,
ORDERLESS functions or by DECLAREing the atom a NOUN).

&ALLBUT(arg1 {, arg2, ...})

Excludes the indicated parts from a list or other structure. It works
with the PART commands (i.e. PART, INPART, SUBSTPART, SUBSTINPART,
DPART, and LPART).

For example,

 (c1) EXPR: E+D+C+B+A$

 (c2) PART(EXPR, [2,5]);

 (d2)                 d + a

 (c3) PART(EXPR, ALLBUT(2,5));

 (d3)               e + c + b

ALLBUT also works with the KILL command, KILL(ALLBUT(name1,...,namek))
will do a KILL(ALL) except it will not KILL the names specified.  (Note:
namei means a name, such as a function name such as U, F, FOO, or G, not
an infolist such as FUNCTIONS.)

&ALLROOTS(poly) 

Finds all the real and complex roots of the real or complex polynomial
poly which must be univariate and may be an equation, for example poly=0.

ALLROOTS will reject an input which is not a polynomial.  It requires
that the numerator of the input expression after RATting must be a
polynomial, and it requires that the denominator be at most a complex
number.  As a result of this ALLROOTS will always return an equivalent
(but factored) expression, if POLYFACTOR is TRUE.

ALLROOTS is implemented using single precision floating point numbers.
ALLROOTS may give inaccurate results in case of multiple roots.  (If
poly is real and you get inaccurate answers, you may want to try
ALLROOTS(%I*poly); Alternatively, try ROOTS which supports bfloats.)  

ROOTSEPSILON is used by ALLROOTS as follows:  When the polynomial 
argument to ALLROOTS is given in terms of integer or rational number 
coefficients, these coefficients are DFLOATed if ROOTSEPSILON is 
smaller than SFLOAT_EPSILON;  otherwise they are SFLOATed.

See also ROOTS for a double-precision implementation which is more robust.

POLYFACTOR default:FALSE
  When TRUE, causes ALLROOTS to display the polynomial as a product of
  factors.

Algorithms:
----------

 - For complex polynomials an algorithm by Jenkins and Traub is used
   (Algorithm 419, Comm. ACM, vol. 15, (1972), p. 97).  

 - For real polynomials the algorithm used is due to Jenkins (Algorithm
   493, TOMS, vol. 1, (1975), p. 178). 

Do EXAMPLE(ALLROOTS); for an example.

See also ALGSYS, ELIMINATE, GROBNER, LINSOLVE, LSQ_LINSOLVE, NROOTS,
NTHROOT, REALROOTS, RATCOEF, ROOTS, ROOTSEPSILON, SOLVE, TAYLOR_SOLVE.

&ALLSOLVE default:TRUE

If TRUE, e.g.  SOLVE(sin(x)=a,x);  will include arbitrary integers 
in the solution.

See also SOLVE and ARBINTS.

&ALLSYM default:FALSE

[ITENSOR package] If TRUE then all indexed objects are assumed
symmetric in all of their covariant and contravariant indices.  
If FALSE then no symmetries are assumed in any tensor indices, (except
those which may be specified with DECLARE_ISYMMETRY).  Derivative
indices are always taken to be symmetric among one another, except
when frame fields are being used.

See also DECLARE_ISYMMETRY, ISYMMETRIES, REMOVE_ISYMMETRY.

&ALPHABETIC 

Declaring a symbol to be ALPHABETIC adds it to Macsyma's alphabet
(initially A-Z,% and _).  Thus, DECLARE("~",ALPHABETIC) enables you
to use names such as NEW~VALUE.

&ALWAYS_USE_SCIENTIFIC_NOTATION default:FALSE

If set to TRUE, scientific notation will be used in the display and
TeXing of all floating point numbers.  This is sometimes desirable for
uniformity.  E.g. the number 2300.5 prints in scientific notation as
2.3005e+3 .

Do EXAMPLE(ALWAYS_USE_SCIENTIFIC_NOTATION); for an example.

See also  FLOAT_PRINT_DIGITS_AFTER_POINT, FLOAT_PRINT_WIDTH, TEX.


&AND

Used in predicates along with OR and NOT.

&ANGMOM_1(psi)

Angular momentum differential operator in the x2-x3 plane in spherical 
coordinates theta and phi, where theta is the angle with the north pole.

Do DEMO(ANGMOM); for a demonstration.

See also ANGMOM_2, ANGMOM_3, ANGMOM_1I2, ANGMOM_1I2C, ANGMOM_1_CART,
ANGMOM_2_CART, ANGMOM_3_CART.

&ANGMOM_1_CART(psi)

Angular momentum differential operator in the x2-x3 plane in Cartesian
coordinates x1, x2, x3.

Do DEMO(ANGMOM); for a demonstration.

See also ANGMOM_1, ANGMOM_2, ANGMOM_3, ANGMOM_1I2, ANGMOM_1I2C,
ANGMOM_2_CART, ANGMOM_3_CART.

&ANGMOM_1I2(psi)

Angular momentum differential operator L1 + i L2 in spherical coordinates
theta and phi, theta is the angle with the north pole.

Do DEMO(ANGMOM); for a demonstration.

See also ANGMOM_1, ANGMOM_2, ANGMOM_3, ANGMOM_1I2C, ANGMOM_1_CART,
ANGMOM_2_CART, ANGMOM_3_CART.

&ANGMOM_1I2C(psi)

Angular momentum differential operator L1 - i L2 in spherical coordinates
theta and phi, theta is the angle with the north pole.

Do DEMO(ANGMOM); for a demonstration.

See also ANGMOM_1, ANGMOM_2, ANGMOM_3, ANGMOM_1I2, ANGMOM_1_CART,
ANGMOM_2_CART, ANGMOM_3_CART.

&ANGMOM_2(psi)

Angular momentum differential operator in the x3-x1 plane in spherical
coordinates theta and phi, where theta is the angle with the north pole.

Do DEMO(ANGMOM); for a demonstration.

See also ANGMOM_1, ANGMOM_3, ANGMOM_1I2, ANGMOM_1I2C, ANGMOM_1_CART,
ANGMOM_2_CART, ANGMOM_3_CART.

&ANGMOM_2_CART(psi)

Angular momentum differential operator in the x2-x3 plane in Cartesian
coordinates x1, x2, x3.

Do DEMO(ANGMOM); for a demonstration.

See also ANGMOM_1, ANGMOM_2, ANGMOM_3, ANGMOM_1I2, ANGMOM_1I2C,
ANGMOM_1_CART, ANGMOM_3_CART.

&ANGMOM_3(psi)

Angular momentum differential operator in the x1-x2 plane in spherical
coordinates theta and phi, where theta is the angle with the north pole.

Do DEMO(ANGMOM); for a demonstration.

See also ANGMOM_1, ANGMOM_2, ANGMOM_1I2, ANGMOM_1I2C, ANGMOM_1_CART,
ANGMOM_2_CART, ANGMOM_3_CART.

&ANGMOM_3_CART(psi)

Angular momentum differential operator in the x2-x3 plane in Cartesian
coordinates x1, x2, x3.

Do DEMO(ANGMOM); for a demonstration.

See also ANGMOM_1, ANGMOM_2, ANGMOM_3, ANGMOM_1I2, ANGMOM_1I2C,
ANGMOM_1_CART, ANGMOM_2_CART.

&ANTID(expr, x, u(x))

Same as the function ANTIDIFF(expr,x,u(x)), except that ANTID returns
a list of two parts, the first part is the integrated part of the
expression and the second part of the list is the non-integrable
remainder.

The main functions in package ANTID are ANTIDIFF and ANTID.  

Do USAGE(ANTID); for more information.

Do EXAMPLE(ANTIDIFF); and DEMO(ANTID); for executable demonstrations.

See INTEGRATION_SUMMARY for a summary of Macsyma's commands for 
integration.

&ANTIDERIVATION - OPPROPERTY

A function F that is declared to be an antiderivation satisfies

  F(u * v) -> F(u) * v - u * F(v)
  F(u . v) -> F(u) . v - u . F(v)

All antiderviations are declared LINEAR, which means that 

- Antiderivations are linear with respect to addition and with
  respect to multiplication by constants in their first argument
  only. 

- Antiderivations are generalized differential operators. If the
  first argument is free of the second, then the antiderivation
  returns 0 .

Antiderivations respect the multiplicative operators on the list 
ANTIDERIVATION_MULTIPLICATIONS (default:[".", "~"]).

Do EXAMPLE(ANTIDERIVATION); for an executable example and 
DEMO(DERIVATION); for a longer demonstration.

See also DERIVATION, LINEAR.

&ANTIDIFF(expr, x, u(x)) 

Evaluates the integral of the expression expr, which may involve the
unknown function u(x) and its derivatives.  Contained in the library
file ANTID.  See ANTID for more information.

Do EXAMPLE(ANTIDIFF); for an example.

See INTEGRATION_SUMMARY for a summary of Macsyma's commands for 
integration.

&ANTISYMMETRIC 

If DECLARE(H, ANTISYMMETRIC); is done, this tells the simplifier that
H is antisymmetric.  E.g. H(X,Z,Y) will simplify to - H(X, Y, Z).
That is, it will give (-1)^n times the result given by SYMMETRIC or
COMMUTATIVE, where n is the number of interchanges of two arguments
necessary to convert it to that form.  ANTISYMMETRIC is a member of
the FEATURES list and OPPROPERTIES.  It can be asserted with DECLARE,
withdrawn with REMOVE, and detected with FEATUREP.

Do EXAMPLE(ANTISYMMETRIC); for an example.

See also SYMMETRIC.

&APOTHEM_REGULAR_POLYGON

See GEOFUNCS.

Do EXAMPLE(APOTHEM_REGULAR_POLYGON); for an example.

&APPEND(list1, list2, ...) 

Returns a single list of the elements of list1 followed by the elements
of list2,...  APPEND also works on general expressions, for example:

 (c1) APPEND(F(A,B), F(C,D,E));
 (d1)                      f(a,b,c,d,e).

Do EXAMPLE(APPEND); for an example.

See LISTS for a summary of operations on lists in Macsyma.

&APPENDFILE(filename) 

Acts like WRITEFILE(filename) but appends new output to the file whose
name is specified by the argument.  A subsequent CLOSEFILE will delete
the original file and rename the appended file.

See FILES_SUMMARY for more information about file manipulation
commands in Macsyma.

&APPLY(function, arglist) 

Returns the result of applying the function to the arglist, where
function is a function, special form, LAMBDA expression, or operator
(e.g. "+"), and arglist is a list of arguments to function.

APPLY is used in several situations, such as:

1. When an extra evaluation of the arguments to a function (or special
   form) is desired. 

2. For convenience, when the arguments to a function are already
   available in the form of a list.

3. For convenience, when applying an n-ary operator to a list of arguments.

In general the first argument to APPLY should be preceded by a ' to make
it evaluate to itself.  Since some atomic variables have the same name
as certain functions the values of the variable would be used rather
than the function because APPLY has its first argument evaluated as well
as its second.

Do EXAMPLE(APPLY); for examples of the uses described above.

See also APPLY_NOUNS, ARRAYAPPLY, INFAPPLY, NEST_APPLY.

&APPLY_CYCLES(cycleslist, list1) 

Applies the permutation represented by the list of cycles cycleslist to
the list list1.  See USAGE(PERMUTATIONS); for related commands.

Do EXAMPLE(APPLY_CYCLES); for an example.

See USAGE(PERMUTATIONS); for related commands.

&APPLY_NOUNS(exp {, nouns}) 

Causes the application of noun forms in an expression.  For example,
EXP:'DIFF(X^2/2,X); APPLY_NOUNS(EXP); gives X.  This gives the same
result as EV(EXP,NOUNS); except that it can be faster and use less
storage.

You can specify particular nouns to apply:
APPLY_NOUNS(expr, name1, ..., namen);
or
APPLY_NOUNS(expr, [name1, ..., namen]);  .

APPLY_NOUNS also can be used in translated code, where EV may cause
problems.  Note that it is called APPLY_NOUNS, not EV_NOUNS, because
what it does is to APPLY the rules corresponding to the noun-form
operators, which is not evaluation.  

Do EXAMPLE(APPLY_NOUNS); for an example.

See also NOUN, NOUNS.

&APPLY_PERMUTATION(permlist, list1) 

Applies the permutation represented by the list permlist to the list
list1.  

Do EXAMPLE(APPLY_PERMUTATION); for an example.

See USAGE(PERMUTATIONS); for related commands.

&APPLY1(exp, rule1, ..., rulen) 

Repeatedly applies the first rule to exp until it fails, then
repeatedly applies the same rule to all subexpressions of exp, from
left to right, until the first rule has failed on all subexpressions.
Call the result of transforming exp in this manner exp'.  Then the
second rule is applied in the same fashion starting at the top of
exp'.  When the final rule fails on the final subexpression, the
application is finished.  The rules are defined with DEFRULE and
removed with REMOVE.  MAXAPPLYDEPTH (default:10000) is the maximum
depth to which APPLY1 and APPLY2 will delve.

Do EXAMPLE(APPLY1); for an example.

See also APPLY2, APPLYB1, APPLYB2.  See RULES_SUMMARY for a summary of
pattern matching rules in Macsyma.

&APPLY2(exp, rule1, ..., rulen) 

Differs from APPLY1 in that if the first rule fails on a given
subexpression, then the second rule is repeatedly applied, etc.  Only
if they all fail on a given subexpression is the whole set of rules
repeatedly applied to the next subexpression.  If one of the rules
succeeds, then the same subexpression is reprocessed, starting with
the first rule.  The rules are defined with DEFRULE and removed with
REMOVE.  MAXAPPLYDEPTH (default:10000) is the maximum depth to which
APPLY1 and APPLY2 will delve.

Do EXAMPLE(APPLY2); for an example.

See also APPLY1, APPLYB1, APPLYB2.  See RULES_SUMMARY for a summary of
pattern matching rules in Macsyma.

&APPLYB1(exp, rule1, ..., rulen) 

APPLYB1 is similar to APPLY1 but works from the "bottom up" instead of
from the "top down".  That is, it processes the smallest subexpression
of exp, then the next smallest, etc.  The rules are defined with
DEFRULE and removed with REMOVE.  MAXAPPLYHEIGHT (default:10000) is
the maximum height to which APPLYB1 will reach before giving up.

Do EXAMPLE(APPLYB1); for an example.

See also APPLY1, APPLY2, APPLYB2.  See RULES_SUMMARY for a summary of
pattern matching rules in Macsyma.

&APPLYB2(exp, rule1, ..., rulen) 

APPLYB2 is similar to APPLY2 but, like APPLYB1, works from the "bottom
up" instead of from the "top down".  It starts with the lowest level of
the first subexpression.  If the first rule fails on a given
subexpression, then the next rule in the argument list is repeatedly
applied.  Only if they all fail on a given subexpression is the whole
set of rules repeatedly applied to the next subexpression.  If one of
the rules succeeds, then the same subexpression is reprocessed, starting
with the first rule.  The rules are defined with DEFRULE and removed
with REMOVE.

Do EXAMPLE(APPLYB2); for an example.

See also APPLY1, APPLY2, APPLYB1.  See RULES_SUMMARY for a summary of
pattern matching rules in Macsyma.

&APROPOS(string) 

Takes a character string as argument and returns a list of valid
DESCRIBE topics which have string somewhere in their name.  Thus,
APROPOS("EXP"); will return a long list of all the flags and functions
which have EXP as part of their names, such as EXPAND, EXP,
EXPONENTIALIZE.  Thus if you can only remember part of the name of
something you can use this command to find the rest of the name.
Similarly, you could say APROPOS("TR_"); to find a list of many of the
switches relating to the TRANSLATOR (most of which begin with "TR_").

Do EXAMPLE(APROPOS); for an example.

See also FIND_SYMBOL.  See HELP for a summary of on-line help
facilities in Macsyma.

&ARBINT_NAME default:%N
 
The alphabetic prefix used in generating the names of arbitrary integers.

See also SOLVE, ALLSOLVE, ARBINT_NUM, ARBINTS, and %N.

&ARBINT_NUM default:0 

The numeric suffix used in generating the names of arbitrary integers.
If set to FALSE then the name will consist only of ARBINT_NAME with 
no numeric suffix.

See also SOLVE, ALLSOLVE, ARBINT_NAME, and ARBINTS.

&ARBINTS default:[]

A list containing the arbitrary integers created by SOLVE.
E.g. for SOLVE(sin(x),x);  ->  [x = %pi %n1] .

See also SOLVE, ALLSOLVE, ARBINT_NAME, ARBINT_NUM, and %N.

&AREA_CIRCLE(radius)

[GEOFUNCS package] Returns the area of a circle of the
specified radius.

&AREA_CUBE(edge)

[GEOFUNCS package] Returns the surface area of a cube with edges
of the specified length.

&AREA_ELLIPSE(major, minor)

[GEOFUNCS package] Returns the area of an ellipse with axes
of length major and minor.

&AREA_EQUITRIANGLE(edge)

[GEOFUNCS package] Returns the area of an equilateral triangle
with specified edge.

&AREA_POLYGON(vertex_coords)

[GEOFUNCS package] Computes the area of a polygon which is specified
the its vertices.  The input vertex_coords specifies the coordinates
of N vertices, either as an N-by-2 matrix of pairs [x,y] or as a
list of lists of pairs [x,y]. 

Do EXAMPLE(AREA_POLYGON); for an example.

See also AREA_REGULAR_POLYGON.

&AREA_PYRAMID3(edge)

[GEOFUNCS package] Returns the surface area of a pyramid with 
a triangular base, with each edge having the specified length.

&AREA_PYRAMID4(edge)

[GEOFUNCS package] Returns the surface area of a pyramid with 
a square base, with each edge having the specified length.

&AREA_RECTANGULOID(a, b, c)

[GEOFUNCS package] Returns the surface area of the rectangular
solid with sides of length a, b, and c.

&AREA_REGULAR_POLYGON(numsides, edge)

[GEOFUNCS package] Returns the area of a regular polygon with
numsides sides and the indicated edge length.

See also AREA_POLYGON.

&AREA_RIGHT_CONE(radius, height)

[GEOFUNCS package] Returns the surface area of a right cone with
the indicated radius and height.

&AREA_RIGHT_CYLINDER(radius, height)

[GEOFUNCS package] Returns the surface area of a right cylinder
with the indicated radius and height.

&AREA_SPHERE(radius)

[GEOFUNCS package] Returns the surface area of a sphere with the
indicated radius.

&AREA_SPHERICAL_POLYGON(radius, n, anglesum)

[GEOFUNCS package] Returns the area of a spherical polygon whose
angles sum to anglesum, on a sphere with the indicated radius.

&AREA_SPHERICAL_TRIANGLE(radius, angle1, angle2, angle3)

[GEOFUNCS package] Returns the area of the spherical triangle with
angles angle1, angle2, angle3, on a sphere with the specified radius.

&AREA_SQUARE(edge)

[GEOFUNCS package] Returns the area of a square with the specified
edge.

&AREA_TETRAHEDRON(p0, p1, p2, p3)

[GEOFUNCS package] Returns the surface area of a tetrahedron in 
3-space which is specified by four vertices p0, p1, p2, p3. Each
of p0, p1, p2, p3 must be a list of length 3, specifying the 
coordinates of one vertex. Orientation of the faces is ignored.

Do EXAMPLE(AREA_TETRAHEDRON); for an example.

&AREA_TRAPEZOID(base1, base2, height)

[GEOFUNCS package] Returns the area of a trapezoid with the specified
base1, base2 and height.

&AREA_TRIANGLE(a, b, c)

[GEOFUNCS package] Returns the area of a triangle with sides 
a, b, and c.

&ARGS(exp)

Returns a list of the args of exp.  I.e. it is essentially 
equivalent to SUBSTPART("[",exp,0) .  (Both ARGS and SUBSTPART
depend on the setting of INFLAG.)

Do EXAMPLE(ARGS); for an example.

&ARITHMETIC_TERM(a, d, n)

[ALGFUNCS package] Returns nth term in the arithmetic progression 
a, a+d, ..., a+kd, ...

&ARITHSUM(a, d, n)

[ALGFUNCS package] Returns the sum of the first n terms in the
arithmetic progression  a, a+d, a+2d, ...

&ARRAY(name, dim1, dim2, ..., dimk) 

Sets up a k-dimensional array.  A maximum of five dimensions may be
used.  The subscripts for the ith dimension are the integers running
from 0 to dimi.  If the user assigns to a subscripted variable before
declaring the corresponding array, an undeclared array is set up.  If
the user has more than one array to be set up the same way, they may all
be set up at the same time, by ARRAY([list-of-names],dim1, dim2, ...,
dimk).

Undeclared arrays, otherwise known as hashed arrays (because hash
coding is done on the subscripts), are more general than declared
arrays.  The user does not declare their maximum size, and they grow
dynamically by hashing as more elements are assigned values.  The
subscripts of undeclared arrays need not even be numbers.  However,
unless an array is rather sparse, it is probably more efficient to
declare it when possible than to leave it undeclared.  The ARRAY
function can be used to transform an undeclared array into a declared
array.

Do USAGE(ARRAYS); for an overview of array commands in Macsyma.

Do EXAMPLE(ARRAY); for an example.  DO DEMO(ARRAY); for a lengthier
demonstration of arrays.  Do DEMO(PASS_OUT); for an example of using
ARRAYMAKE to pass computed array values out of functions.

See also ARRAYAPPLY, ARRAYINFO, ARRAYMAKE, ARRAYP, ARRAYS,
ARRAYSETAPPLY, FILLARRAY, LISTARRAY, REARRAY, REMARRAY. 

See ARRAY_SUMMARY for a summary of commands for manipulating arrays
in Macsyma.

&ARRAY_SUMMARY 

                SUMMARY OF MACSYMA'S ARRAY COMMANDS

ACTIVITY                        COMMAND 
--------                        ------- 
1. Access the value of an       arrayname[i1,..,ir]
   array element
                                ARRAYAPPLY(arrayname,[i1,..,ir])

   ARRAYAPPLY is used when the arrayname is not declared to be an array
   in the local block.  It evaluates the arrayname.  Sometimes helps
   the compiler to compile code with arrays correctly.

2. Access an element of an      arrayname[i1,..,ir]
   array, to bind it to a value ARRAYMAKE(arrayname,[i1,...,ir])

   ARRAYMAKE sometimes helps the compiler to compile correctly. 

   Assign a value to an array    ARRAYSETAPPLY(arrayname,
   element                          list-of-subscripts, value)

3. Define an array function     arrayname[i1,..,ir]:=(body)

   array functions behave much like a user-defined functions, except
   (1)computed values are stored for future reference,
   (2) the [i1,..,ir] must be valid array indices.

                                ARRAY(arrayname,i1,..,ir,FUNCTION)

   Optional declaration of FUNCTION property.

4. Define an array of           arrayname[i1,..,ir](x1,..,xn):=(body)   
   functions
                                arrayname[i1,..,ir]:= LAMBDA([x1,..,xn],body)

   arrayname[i1,..,ir] has as its value a function of (x1,..,xn).

5. Assign values to all         FILLARRAY(arrayname, list_or_array_or_matrix)      
   elements of an array

6. Convert to other indexed data structures

   - to lists                   LISTARRAY(arrayname)
   - to column vector           GENVECTOR(arrayname)
   - to a rectangular matrix    GENMATRIX(arrayname,dim1,dim2)


7. Reorganize elements of       REARRAY(arrayname,dim1,...,dimr)
   an array

8. Check whether a symbol       ARRAYP(arrayname)
   has array properties 

   Returns TRUE or FALSE. 

9. Generate list of all         ARRAYS                                  
   symbols which have arrays
   associated with them.

10. Get information about       ARRAYINFO(arrayname)
    an array

   Tells whether the array is declared or undeclared, and
   - for declared arrays, the rank and dimensions;
   - for undeclared arrays, the indices which have values.

11. Remove an array             REMARRAY(arrayname)


        SUMMARY OF PROGRAMMING WITH ARRAYS IN MACSYMA

ARRAY FEATURE           ALTERNATIVES                    
-------------   -------------------------------------------
Rank and        Declared Array: ARRAY(arrayname,dim1,..,dimr)
Dimension       Declaring array rank and dimension increases
                efficiency of array storage and access times.

                UNDECLARED ARRAY (the default if no rank and
                dimensions are specified)
                Undeclared arrays offer the flexibility of
                choosing the rank at the first reference to
                the array, and enlarging dimensions during
                execution.
                        
Mode            Declared Mode: MODE_DECLARE(arrayname, modename),
                Declared modes are more efficient, just        
                as for non-array variables. modename is one of:
                ANY, BOOLEAN, FIXNUM, FLOAT, NUMBER.

                Undeclared Mode: (Default, if no rank and
                dimensions are specified.)
                Undeclared modes offer users the flexibility
                to mix modes in one array, and to change
                modes of array elements during execution.

Completeness    Complete Array: ARRAY(arrayname,COMPLETE,dim1,..,dimr)
                An array is "Complete" if each of its entries is
                assigned a value before the array element is
                referenced.

                Incomplete Array (Default, if the array is not
                declared Complete.)

Local or Global Local to a Block: BLOCK([arrayname],...). 
Array           This localizes the value of the arrayname symbol to
Properties      the block.

                ?MLOCAL(arrayname), and ?MUNLOCAL() at the end of the
                block.  This makes the array rank-dimension declaration
                local to the block.

&ARRAYAPPLY(arrayname, [sub1, ... ,subk]) 

ARRAYAPPLY is like APPLY except the first argument is an array. 
That is, 
 - the symbol arrayname is evaluated,
 - the subscripts subi are evaluated, and
 - the corresponding array element is returned.  

Do EXAMPLE(ARRAYAPPLY); for an example. 

See also ARRAY, ARRAYS.  See ARRAY_SUMMARY for a summary of commands
for manipulating arrays in Macsyma.

&ARRAYINFO(a) 

Returns a list of information about the array a.  For hashed arrays it
returns a list of "HASHED", the number of subscripts, and the subscripts
of every element which has a value.  For declared arrays it returns a
list of "DECLARED", the number of subscripts, and the bounds that were
given the ARRAY function when it was called on a.

Do USAGE(ARRAYS); for an overview of array commands in Macsyma.

Do EXAMPLE(ARRAYINFO); for an example.

See also ARRAY_SUMMARY for a summary of commands for manipulating
arrays in Macsyma.

&ARRAYMAKE(arrname, [i1,i2,...]) 

Returns the unevaluated array element arrname[i1,i2,...] without
referencing the array arrname to find the value of the array element.

Do DEMO(PASS_OUT); for an example of using ARRAYMAKE to pass computed
array values out of functions.

See also ARRAY, ARRAYS.  See ARRAY_SUMMARY for a summary of commands
for manipulating arrays in Macsyma.

&ARRAYP(arg) 

Returns TRUE if arg is a symbol that designates an array.
Otherwise, ARRAYP returns FALSE. 

Example:
 (c1) ARRAYP('FOO);

 (d1)                           false

 (c2) ARRAY(FOO,3,3)$

 (c3) ARRAYP('FOO);

 (d3)                           true

See also ARRAY, ARRAYS.  See ARRAY_SUMMARY for a summary of commands
for manipulating arrays in Macsyma.

&ARRAYS default:[] 

a list of all the arrays that have been allocated,
both declared and undeclared.  

Do USAGE(ARRAYS); for an overview of array commands in Macsyma.

Do EXAMPLE(ARRAYS); for an example. Do DEMO(PASS_OUT); for an example
of using ARRAYMAKE to pass computed array values out of functions.

See also ARRAY, ARRAYAPPLY, ARRAYINFO, ARRAYMAKE, ARRAYP,
ARRAYSETAPPLY, FILLARRAY, LISTARRAY, REARRAY, REMARRAY.

See ARRAY_SUMMARY for a summary of commands for manipulating arrays
in Macsyma.

&ARRAYSETAPPLY(arrayname, list-of-subscripts, value) 

Assigns value to the array element arrayname[sub1,...,subk],
where list-of-subscripts is [sub1,...,subk].

See ARRAY_SUMMARY for a summary of commands for manipulating arrays in
Macsyma.

&AS 

Abramowitz and Stegun, Handbook of Mathematical Functions.

&ASEC

Arc Secant

&ASECD

Same as the ASEC function, except the output is in degrees.

&ASECH

Hyperbolic Arc Secant

&ASIN

 Arc Sine

&ASIND

Same as the ASIN function, except the output is in degrees.

&ASINH

Hyperbolic Arc Sine

&ASKCSIGN(expr) 

Returns one of {POS,NEG,ZERO,COMPLEX}.  If expr is a complex
expression, then ASKCSIGN returns COMPLEX, whereas ASKSIGN might
err out in this case.

Example:
 (c1) ASKCSIGN(%I);
 (d1)                   complex
 (c2) ASKSIGN(%I);
 "Error: SIGN called on an imaginary argument: %I" .

Do EXAMPLE(ASKCSIGN); for an example.

See also ASKSIGN, SIGN, SIGNUM, IS.

&ASKEXP default:[] 

Contains the expression upon which ASKSIGN is called.  A user may enter
a Macsyma break and inspect this expression in order to answer questions 
asked by ASKSIGN.

&ASKINTEGER(exp {, optional-arg}) 

ASKINTEGER attempts to determine from the database whether exp is an
INTEGER, or is EVEN or ODD.  

Arguments:
 - exp is any valid Macsyma expression.
 - optional-arg is EVEN, ODD, or INTEGER and defaults to INTEGER if 
   it is not specified.

If ASKINTEGER cannot determine whether exp satisfies the specified
condition, then it asks the user for the information.  The answer
given by the user remains valid until another command input line
is processed.

Do EXAMPLE(ASKINTEGER); for an example.

See also ASKSIGN, IS, QUERY, READ.

&ASKSIGN(exp) 

ASKSIGN attempts to determine from the database whether exp is 
POS, NEG or ZERO.  exp is any valid Macsyma expression.

If ASKSIGN cannot determine whether exp is POS, NEG or ZERO, then
it asks the user for the information.  The answer given by the user
remains valid until another command input line is processed.

Do EXAMPLE(ASKSIGN); for an example.

See also ASKCSIGN, SIGN, SIGNUM, ASKINTEGER, IS, and ASKEXP.

&ASSIGNMENT 

Macsyma has three assignment operators, ":", "::" and "<:" .

 - : assigns the value of the expression on its right to the symbol
   or list on its left.  For example, 
   - A:3 sets the variable A to 3.
   - [A,B]:[1,2] sets the variable A to 1 and the variable B to 2.

 - :: assigns the value of the expression on its right to the value
   of the quantity on its left.

 - <: assigns the value of the expression on its right to the symbol
   or list on the left. When certain Macsyma functions appear on the
   right side of "<:", "<:" causes these functions (which behave like
   related Matlab functions) to check number of arguments expected
   to the left of "<:" and alter the computation performed by the
   Macsyma function to the right of "<:" to deliver the required
   number of values.

For these operators, the left hand side must evaluate to an atomic
variable or subscripted variable or a list. If the left hand side is
a list, then the right hand side must be a list of the same length, 
and each element of the left hand list is assigned a value from the
corresponding position in the right hand list.


&ASSOC(key, eqn_list {, defaultvalue}) 

Returns the right hand side of the first equation encountered in eqn_list
whose left hand side is key.  If the key does not match the left hand
side of any equation in eqn_list, then ASSOC returns defaultvalue, which
defaults to FALSE if it is not specified.

Do EXAMPLE(ASSOC); for an example.

&ASSUME(pred1, pred2, ...) 

ASSUME adds information specified by pred1, pred2, ... about symbolic
variables to the Macsyma database.  It first checks the specified
predicates for redundancy and consistency with current information in
the database.  If the predicates are consistent and non-redundant, they
are added to the database; if inconsistent or redundant, no action is
taken.  

ASSUME returns a list whose entries are the predicates added to the
database and the atoms REDUNDANT or INCONSISTENT where applicable.  You
can view the assumptions about a symbol with the command FACTS, and you
can remove assumptions with the command FORGET.

Do USAGE(PROPERTIES); for an overview of Macsyma commands to manage
properties of symbols.

Do EXAMPLE(ASSUME); for an example.

See also ASSUME_POS, ASSUME_POS_PRED, ASSUMESCALAR, DECLARE, FACTS, 
and FORGET.

Macsyma's CONTEXT mechanism enables you to manipulate large numbers
of database assumptions by collecting them into groups called 
"contexts". See CONTEXT for a description of the context facility.

&ASSUME_POS default:FALSE

When using INTEGRATE and other commands, one often introduces parameters
which are real and positive or one's calculations can often be 
constructed so that this is true.  

If ASSUME_POS = TRUE, then Macsyma will assume that all parameters
are positive.  Information specified with ASSUME or any contextual
information present will take precedence over ASSUME_POS.

Setting ASSUME_POS:TRUE cuts down on the number of questions Macsyma
needs to ask.   

The user can control what types of parameters are affected by
ASSUME_POS.  By default, ASSUME_POS affects those parameters which
satisfy SYMBOLP(x) OR SUBVARP(x).  The user can change this by setting
the option ASSUME_POS_PRED (default:FALSE) to the name of a predicate
function of one argument.  For example, you can specify that only
symbols are be affected by ASSUME_POS.

 (c1) ASSUME_POS:TRUE$

 (c2) ASSUME_POS_PRED:'SYMBOLP$

 (c3) SIGN(A);

 (d3)                         pos

 (c4) SIGN(A[1])

 (d4)                         pnz

See also ASSUME.

&ASSUME_POS_PRED default:FALSE

May be set to a function of one argument to control what will be
considered a parameter for the "assumptions" that INTEGRATE will make.

See also ASSUME and ASSUME_POS .

&ASSUMESCALAR default:TRUE

Given an expression exp for which NONSCALARP(exp) is FALSE, ASSUMESCALAR
determines whether exp is assumed to behave like a scalar for certain
transformations.

Let exp represent any non-list/non-matrix for which NONSCALARP(exp)
is FALSE, and let "[1,2,3]" represent any list or matrix.

 - If ASSUMESCALAR is FALSE, then exp*[1,2,3]; and exp.[1,2,3]; do not
   simplify, so that exp behaves like a non-scalar for the commutative
   multiplication operator "*" and for the noncommutative multiplication
   operator ".".

 - If ASSUMESCALAR is TRUE, then exp*[1,2,3]; gives [exp,2*exp,3*exp],
   but exp.[1,2,3]; gives exp.[1,2,3]; ,  so that exp behaves like a
   scalar for  "*" but not for "." .

 - If ASSUMESCALAR is ALL or SCALARP(exp) is TRUE or CONSTANTP(exp)
   is TRUE, then exp*[1,2,3]; and exp.[1,2,3]; give [exp,2*exp,3*exp],
   so that exp behaves like a scalar for "*" and for "." .

Do EXAMPLE(ASSUMESCALAR); for an example.

See also SCALAR, NONSCALAR, CONSTANT and LISTARITH.

&ASSUMESCALARP(input) 

Returns TRUE for scalar input and FALSE for nonscalar input.  Otherwise
this function tests the option variable ASSUMESCALAR for values TRUE or
ALL to authorize treating input as a scalar.

Do EXAMPLE(ASSUMESCALARP); for an example.

See also ASSUMESCALAR, MAT_BLOCK_PACK.

&ASYMBOL default:V

[ATENSOR package] The symbol for the subscripted variable which
designates the basis elements for the vector space which generates the
tensor algebra.  Symbols of the form ASYMBOL[1] etc. are recognized as
basis elements of the underlying vector space.

&ASYMPA 

A library file containing simplification functions for asymptotic
analysis, including the big-O and little-o functions that are widely
used in complexity analysis and numerical analysis.  See USAGE(ASYMPA);
for more information.

&ASYMPTOTES(expr, x {, side})

[CALFUNCS package] Computes left and right asymptotes of the
expression expr as a univariate function of the independent variable
x.  If the flag side is 'left (respectively 'right), then only the
left (respectively right) asymptote is returned.  The asymptotes are
returned as the elements of a list, each element of which is an
expression in the independent variable x.

Do EXAMPLE(ASYMPTOTES); for an executable example.

&AT(exp, eqns)

Replaces the variables in exp (which can be any expression) with the
values specified in the single equation or list of equations eqns.  If
a subexpression of exp depends on any of the variables in list but it
hasn't had an ATVALUE specified, then AT returns a noun form.

Do EXAMPLE(AT); for an example.

See also ATVALUE.

&ATAN

The principal branch of the Arc Tangent.  It returns a value between
-%PI/2 and %PI/2.

&ATAN2(Y, X) 

Returns the value of ATAN(Y/X) in the interval -%PI to %PI.  In
situations where X may take on the value zero, ATAN2(Y,0) will return
%PI/2 or -%PI/2 depending on the sign of Y (and assuming Y#0), whereas
the expression ATAN(Y/0) will cause an error.

See also ATAN, ATAN2D, ATAND.

&ATAN2D

Same as the ATAN2 function, except the output is in degrees.

&ATAND

Same as the ATAN function, except the output is in degrees.

&ATANH

Hyperbolic Arc tangent

&ATEN_EXP(cnum)

[ATENSOR package] Returns the exponential of the Clifford multivector 
cnum.  (A multivector is an antisymmetric form, which is represented
in ATENSOR by the operator "~".)  The exponential is computed from
the series

        ATEN_EXP(cnum) = sum((oo cnum)^n/n!, n ,0, inf) .

When using ATEN_EXP, you must be using Clifford algebras (or special
cases COMPLEX, DIRAC, PAULI, QUATERNION).

Do EXAMPLE(ATEN_EXP); for an executable example and DEMO(ATEN_EXP);
for a longer demonstration.

&ATEN_REVERSE(expr)

[ATENSOR package] Reverses all arguments of the dot operator "."
in the expression expr.

Do EXAMPLE(ATEN_REVERSE); for an example.

&ATENSIMP( expr {, flag})

[ATENSOR package] Applies the fundamental simplification rules
for each type of tensor algebra defined by the option variable 
ALG_TYPE, or as set by INIT_ATENSOR.

See USAGE(ATENSOR); for more information.

&ATENSOR 

A library package for computing with various multilinear tensor
algebras, using basis-independent, or basis-dependent notation.
The types of algebras provided (determined by the option variable
ALG_TYPE) include:
 - universal tensor algebras,
 - symmetric tensor algebras,
 - Grassmann (antisymmetric) algebras,
 - Clifford algebras,
 - symplectic algebras,
 - Lie enveloping algebras.

The function INIT_ATENSOR(algebratype, optional_dimensions) provides
an easy way to define the most common types of tensor algebras. It
also sets up special cases of the general algebras given above, such 
as the quaternions and the Pauli and Dirac algebras.

The package ATENSOR autoloads when you invoke the function INIT_ATENSOR.
Do USAGE(ATENSOR); for more information.

Do DEMO(ATENSOR); and DEMO(CLIFFORD); for demonstrations.

See also TENSOR_SUMMARY, "." , USAGE(DOTOPERATOR);, DEMO(DOTOPERATOR);.

&ATOM(exp) 

If exp is atomic (i.e. a number or name) then ATOM returns TRUE, else
FALSE.  Thus ATOM(5) is TRUE while ATOM(A[1]) and ATOM(SIN(X)) are
FALSE.  (Assuming A[1] and X are unbound.)

Do EXAMPLE(ATOM); for an example. 

See also MAPATOM and SYMBOLP.

&ATOMGRAD 

The atomic gradient property of an expression.  May be set by GRADEF.

&ATOMIC_MASS(atomsymbol) 

Returns the atomic mass in a.m.u. of the chemical element denoted by
atomsymbol.

Do EXAMPLE(ATOMIC_MASS); for an example.

See also ATOMIC_NUMBER, MOLECULAR_MASS, PERIODIC_TABLE, and
PHYSICAL_CONSTANTS.

&ATOMIC_NUMBER(atomsymbol) 

Returns the atomic number of the chemical element denoted by atomsymbol.

Do EXAMPLE(ATOMIC_NUMBER); for an example.

See also ATOMIC_MASS, MOLECULAR_MASS, PERIODIC_TABLE, and
PHYSICAL_CONSTANTS.

&ATRIGHSWITCH default:FALSE

If TRUE, expresses ACOSH(X) by convention as %I*ACOS(X), and ASECH(X) by
convention as %I*ASEC(X).  ATRIGHSWITCH is an EVFLAG.

Do EXAMPLE(ATRIGHSWITCH); for an example.

See also ATRIGSWITCH.

&ATRIGSWITCH default:FALSE

If TRUE, expresses ASEC(X) as ACOS(1/X), and ACSC(X) as ASIN(1/X).
ATRIGSWITCH is an EVFLAG.

Do EXAMPLE(ATRIGSWITCH); for an example.

See also ATRIGHSWITCH.

&ATVALUE(form, eqns, value) 

Enables the user to assign the boundary value to form at the points
specified by list.

 (c1) ATVALUE(F(X,Y), [X=0,Y=1], A^2)$

Arguments:

 - form must be a function, f(v1,v2,...), or a derivative,
   DIFF(f(v1,v2,...),vi,ni,vj,nj,...) in which the functional arguments
   explicitly appear (ni is the order of differentiation with respect
   vi).

 - eqns is an equation (such as vi = expr) or list of equations which
   determine the "boundary" at which the value is given.

The symbols @1, @2,... are used in the output display to represent the
functional variables v1,v2,... .

You can display the atvalues of the functions f1,f2,... which were
previously specified by ATVALUE with the command 
PRINTPROPS([f1, f2, ...], ATVALUE).

If PRINTPROPS is given a first argument of ALL, then atvalues for all
functions which have them will be displayed.

Do EXAMPLE(ATVALUE); for an example.

See also AT.

&AUGCOEFMATRIX([eq1, ...], [var1, ...]) 

Returns the augmented coefficient matrix for the system of linear
equations eq1,... in the variables var1,...  .  This is the coefficient
matrix with a column adjoined for the constant terms in each equation
(i.e. those not dependent upon var1,...).  

Do EXAMPLE(AUGCOEFMATRIX); for an example.

See also COEFMATRIX.

&AUTOLOAD - See SETUP_AUTOLOAD.

&AVERAGE_PERIODIC_ODE(eqs, dep_vars, indep_var, perturb_var,
truncation_order, near_id_truncation_order) 

Implements the perturbation method of averaging for ODE's.  Periodic
averaging is a perturbation technique which can be used to study
time-dependent periodic ordinary differential equations.  It constructs
a near-identity change of coordinates which reduces the given
time-dependent differential equation to one which is independent of time
through some order in the perturbation parameter.  

Do USAGE(AVG_PODE); for more information.

Do DEMO(AVG_PODE); for a demonstration.

&AVG_PODE 

A library package which implements the method of averaging, for
perturbation analysis of time-dependent periodic ordinary differential
equations.  The main user command is AVERAGE_PERIODIC_ODE.  

Do USAGE(AVG_PODE); for more information

Do DEMO(AVG_PODE); for a demonstration.

See also LINDSTEDT, MSCALES for other perturbation methods for 
ODEs.

&B_BACKSUB(ba, veca, dim, nsband) 

[BANDMAT package] Performs back substitution on the load vector VECA
using BA, which is the reduced form of the banded matrix.  

Arguments:
 - Both VECA and BA are arrays.
 - DIM is the dimension of the (square) matrix BA and of VECA.
 - NSBAND is the bandwidth of the matrix BA.

See USAGE(BANDMAT); for more information.

See also B_BACKSUBF, SB_BACKSUB, B_REDUCE.

&B_BACKSUBF(ba, veca, dim, nsband) 

[BANDMAT package] A version of B_BACKSUB which is optimized for
floating point.  

Arguments:
 - BA and VECA must be declared floating point arrays.
 - DIM is the dimension of the (square) matrix BA and of VECA.
 - NSBAND is the bandwidth of the matrix BA.

&B_MULTV(wa, ba, va, dim, nsband) 

[BANDMAT package] Multiplies the banded matrix stored as the array
BA times the vector stored as the array VA.  The result is stored in
the array WA.  DIM is the dimension of the (square) matrices WA and
BA and of VECA.  NSBAND is the bandwidth of the matrices WA and BA.

See also B_MULTV and SB_MULTV.

&B_MULTVF(wa, ba, va, dim, nsband) 

[BANDMAT package] A version of B_MULTV for declared single and double
float arrays, which is more efficient in those cases.  All the arrays
must be declared floating point arrays.  DIM is the dimension of the
(square) matrices WA and BA and of VECA. NSBAND is the bandwidth of the
matrices WA and BA.

See also B_MULTV.

&B_REDUCE(ba, dim, nsband) 

[BANDMAT package] Performs Gauss reduction on a banded matrix.  BA is
the name of an array which stores the input matrix. BA is overwritten
with the reduced matrix.  See the BANDMAT package for more information.
DIM is the dimension of the (square) matrix BA.  NSBAND is the bandwidth
of the matrix BA.

See also B_REDUCEF, B_BACKSUB, SB_REDUCE.

&B_REDUCEF(ba, dim, nsband) 

[BANDMAT package] A version of B_REDUCE which is optimized for
floating point.  BA must be a declared floating point array.  DIM is the
dimension of the (square) matrix BA.  NSBAND is the bandwidth of the
matrix BA.

&BACKSUBST default:TRUE

Setting BACKSUBST to FALSE will prevent back substitution after 
equations have been triangularized.  This may be necessary in very big
symbolic problems where back substitution would cause the generation of
extremely large expressions.

&BACKTRACE default:[] 

When DEBUGMODE:ALL, BACKTRACE has as its value a list of all functions
currently entered when a break occurs.

See also TOBREAK, TO_LISP, DEBUGMODE, TRACE, TIMER, SETCHECK,
SETCHECKBREAK.

&BANDMAT

A library package which contains utilities for computing with
banded matrices.  The utilities currently include

1. conversion from full matrix storage to banded and symmetric
   banded storage schemes,
2. matrix reduction and backsubstitution for banded and symmetric
   banded matrices.

Floating point versions of the elimination routines are provided,
in order to run floating point problems more efficiently.  All
matrices are stored as arrays, and not as Macsyma matrices.

A banded matrix has its nonzero entries restricted to a narrow band
around the diagonal.  These matrices occur often in finite element
and finite difference equations, or more generally in problems
where nodes are connected to neighboring nodes but not to distant
nodes.

Do USAGE(BANDMAT); for more information. 

Do DEMO(BANDMAT); for a demonstration.

See MATRIX_SUMMARY for a summary of Macsyma's capabilities in matrix
algebra.

&BAND2FULLA(fa, ba, dim, nsband) 

[BANDMAT package] Converts a banded matrix, stored as an array BA, to
full matrix storage, and returns the result in an array FA.  See the
BANDMAT package for more information.

&BAR_CHART( list_of_vals {, optional_args})

Constructs a vertical bar chart from a list of values. 

Arguments:

 - list_of_vals is a list whose elements are non-negative numbers
   and lists of non-negative numbers.
   o If list_of_vals is a list of non-negative numbers, then each
     number is plotted as the height of a separate bar.
   o If any element of list_of_vals is itself a list of numbers, then
     these numbers are the heights of layers in a stacked bar whose
     total height is the sum of the numbers in this list.
 - Optional_args are the same as the optional arguments to the PLOT
   command, plus the line type codes can be themselves lists of
   non-negative integers and lists of non-negative integers. This
   enables users to specify colors for the layers in a stacked bar
   chart.

Two option variables specifically control the behavior of BAR_CHART.

BAR_SPACING default:1.0

  Specifies the spacing between bars.

BAR_WIDTH_FRACTION default:0.5

  Specifies the width of each bar as a fraction of bar spacing.

Do EXAMPLE(BAR_CHART); for an example.

&BARTLETT_WINDOW(t, t0, t1)

Computes the Bartlett Window function:

  if t<t0 or t>t1 then 0 else WELCH_WINDOW(t,t0,t1)^2.

Do EXAMPLE(BARTLETT_WINDOW); for an example and DEMO(POWER_SPECTRUM);
for longer demonstration.

See also POWER_SPECTRUM.

&BASHINDICES(expr) 

Transforms the expression expr by giving each summation and product a
unique index.  This gives CHANGEVAR greater precision when it is working
with summations or products.  The form of the unique index is J<number>.
The quantity <number> is determined by referring to GENSUMNUM, which can
be changed by the user.  For example, GENSUMNUM:0$ resets it.

Do EXAMPLE(BASHINDICES); for an example. 

&BASIC 

A library package of predefined Macsyma macros.  Do LOAD(BASIC); to
load these macros.

Do USAGE(BASIC); for information.

Do DEMO(BASIC); for a demonstration of these macros. 

See also MACROS.

&BATCH(file-specification) 

Reads in and evaluates Macsyma command lines from a file.  A batch file
consists of a set of Macsyma command lines, each with its terminating ;
or $, which may be further separated by spaces, carriage- returns,
form-feeds, and the like.

The BATCH function reads in the command lines from the file one at a
time, echoes them on the user console, and executing them.  Control is
returned to the user console only when serious errors occur or when the
end of the file is met.  The user may quit out of the file-processing at
any time.

BATCH files may be created using a text editor or by use of the
STRINGOUT command.

See FILES_SUMMARY for more information about file management.

See also STRINGOUT, BATCHLOAD, BATCON, DEMO, LOAD, FILE_PATHNAMES,
BATCH_MAKE_NOTEBOOK. 

&BATCH_MAKE_NOTEBOOK default:TRUE

When FALSE, batch execution of a file causes input commands and
comments to appear in text sections instead of as input sections. This
is useful for detecting the location of input errors, because the
display stops at the point where the parser detects that there is no
possible way to complete the command string as a correct input
command.

This option variable is available only in Macsyma 2.0 and successors.

&BATCHKILL default:FALSE

If TRUE then the effect of all previous BATCH files is nullified
because a KILL(ALL) and a RESET() will be done automatically when the
next one is read in.  If BATCHKILL is bound to any other atom then a
KILL of the value of BATCHKILL will be done.

&BATCHLOAD(file-specification)

Batches in the file silently without terminal output or labels.

See also BATCH, BATCON, LOAD.

See FILE_PATHNAMES for information about how to specify file
pathnames in Macsyma. See FILES_SUMMARY for more information about
file manipulation commands in Macsyma.

&BATCON(arg1, arg2)

Continues processing the last BATCH or DEMO or EXAMPLE from the point
where it was interrupted.  The optional arguments, ARG1 and ARG2,
allow you to determine more precisely where processing of an
interrupted file begins and ends.

Arguments:

 - ARG1 controls where processing begins.  If it is TRUE, processing
   begins at the command line where the interruption occurred.  If it
   is FALSE, processing begins at the command line before the
   interruption.  ARG1 can also be a tag, or an integer n which is
   interpreted as the nth line of the interrupted file.  N can be
   calculated from the variable BATCOUNT, e.g. BATCON(BATCOUNT-5); .

 - ARG2 controls where processing ends.  If it is TRUE, processing
   ends at the end of the file.  If it is FALSE, processing ends at
   the next tag.  ARG2 can also be a tag, or an integer n which is
   interpreted as the nth line of the interrupted file.  N can be
   calculated from the variable BATCOUNT, e.g. BATCON(BATCOUNT+5); .

See also BATCH.

See FILE_PATHNAMES for information about how to specify file pathnames
in Macsyma.  See FILES_SUMMARY for more information about file
manipulation commands in Macsyma.

&BATCOUNT default:0 

May be set to the number of the last expression BATCHed in from a
file.  Thus BATCON(BATCOUNT-1) will resume BATCHing from the
expression before the last BATCHed in from before.

See also BATCH.

&BC2(eqn, xval1, yval1, xval2, yval2)

Applies boundary conditions to a general solution of a second order
ordinary differential equation, and returns a particular solution.

Arguments:
 - EQN is a solution equation which is returned by one of Macsyma's
   ODE solver commands.
 - XVAL1 is an equation which specifies the first value of the
   independent variable at which a boundary condition is to be 
   assigned.
 - YVAL1 is an equation which specifies the initial value of the 
   dependent variable at the first boundary point.
 - XVAL2 is an equation which specifies the second value of the
   independent variable at which a boundary condition is to be
   assigned.
 - YVAL2 is an equation which specifies the initial value of the 
   dependent variable at the second boundary point.

Do EXAMPLE(BC2); for an example.  

See also IC1, IC2, ODE_IBC, ODE.

&BERN(n)

Gives the nth Bernoulli number for integer n.  If ZEROBERN
(default:TRUE) is set to FALSE, then BERN excludes the zero BERNOULLI
numbers.

Do EXAMPLE(BERN); for an example. 

See also BURN.

&BERNOULLI_DENSITY(X, N, P)

[UNIPROB package] See BINOMIAL_DENSITY(X,N,P).

&BERNOULLI_DISTRIB(X, N, P)

[UNIPROB package] See BINOMIAL_DISTRIB(X,N,P).

&BERNPOLY(v, n)

Generates the nth Bernoulli polynomial in the variable v.

Do EXAMPLE(BERNPOLY); for an example. 

See BERN for Bernoulli numbers.

&BESSEL(Z,NU)

See BESSEL_J[NU](Z) and BESSEL_Y[NU](Z).

&BESSEL_I [NU](Z)

Returns the modified Bessel function of the first kind for real NU and
complex Z.

    Arguments             Returned value
   NU            Z     
 -----------  ------      -----------------
 integer+1/2   exact      symbolic expression
 integer+1/2   float      floatnum
 integer       real float numerical value

An array BESSEL_I_ARRAY is set up such that BESSEL_I_ARRAY[I] =
BESSEL_I[I+NU- FLOOR(NU)](Z).  

Do USAGE(BESSEL); for more information about Bessel functions.

Do EXAMPLE(BESSEL_FUNCTION_PLOTS); for an example showing Bessel functions.

Do DEMO(BESSEL); for a demonstration of Bessel functions.

&BESSEL_J [NU](Z)

Returns the Bessel function of the first kind for real NU and
complex Z.

      Arguments              Returned value
   NU            Z     
 -----------  ------         -----------------
 integer+1/2   exact         symbolic expression
 integer+1/2   float         float
 integer       float         numerical value
 float>=0.0    complex float complex float 

An array BESSEL_J_ARRAY is set up such that BESSEL_J_ARRAY[I] =
BESSEL_J[I+NU- FLOOR(NU)](Z).  If Z is complex, then the array
CBESSEL_J_ARRAY is set up for complex values.  

Do USAGE(BESSEL); for more information about Bessel functions.

Do EXAMPLE(BESSEL_FUNCTION_PLOTS); for an example showing Bessel functions.

Do DEMO(BESSEL); for a demonstration of Bessel functions.

See SPECIAL_FUNCTIONS for more information about special functions
in Macsyma.

&BESSEL_K [NU](Z)

Returns the modified Bessel function of the second kind for real NU
and complex Z.

      Arguments              Returned value
   NU            Z     
 -----------  ------         -----------------
 integer+1/2  exact          symbolic expression
 integer+1/2  float          float
 float        float          real float 

Do USAGE(BESSEL); for more information about Bessel functions.

Do EXAMPLE(BESSEL_FUNCTION_PLOTS); for an example showing Bessel functions.

Do DEMO(BESSEL); for a demonstration of Bessel functions.

&BESSEL_Y [NU](Z)

Returns the Bessel function of the second kind for real NU and
complex Z.

      Arguments              Returned value
   NU            Z     
 -----------  ------         -----------------
 integer+1/2  exact          symbolic expression
 integer+1/2  float          float
 integer      float>0.0      numerical value
 float>=0.0   float>0.0      real float

Do USAGE(BESSEL); for more information about Bessel functions.

Do EXAMPLE(BESSEL_FUNCTION_PLOTS); for an example showing Bessel functions.

Do DEMO(BESSEL); for a demonstration of Bessel functions.

See SPECIAL_FUNCTIONS for more information about special functions
in Macsyma.

&BETA(X, Y) 

Same as GAMMA(X)*GAMMA(Y)/GAMMA(X+Y).

Do EXAMPLE(BETA); for an example.

See also MAKEFACT, MAKEGAMMA.

&BETA_BINOMIAL_DENSITY(x, n, alpha, beta)

[UNIPROB package] The density function

(BINOMIAL(N,X)*BINOMIAL(ALPHA+BETA+1,ALPHA+1))
   * (GAMMA(X+alpha)*GAMMA(n+beta-x)/GAMMA(N+ALPHA+BETA)).

&BETA_BINOMIAL_DISTRIB(x, N, alpha, beta) 

[UNIPROB package] The distribution function for the
BETA_BINOMIAL_DENSITY.

&BETA_DENSITY(x, alpha, beta) 

[UNIPROB package] The beta density function

                       beta - 1  alpha - 1
                (1 - x)         x
        f(x) =  --------------------------     0 < x < 1
                   beta(alpha, beta)

        f(x) =             0                   otherwise.


Do EXAMPLE(BETA_DENSITY); for an example.

See also BETA_DISTRIB.

&BETA_DISTRIB(x, alpha, beta) 

[UNIPROB package] The beta distribution.

Do EXAMPLE(BETA_DISTRIB); for an example.

See also BETA_DENSITY, INV_BETA_DISTRIB.

&BETA_INCOMPLETE(a, b, x)

Computes the incomplete beta function numerically:

I_x(a, b) = INTEGRATE(t^(a-1)*(1-t)^(b-1),t,0,z) BETA(a, b)

          =  1/a*x^a*HYPER_2F1(a, 1-b, 1+a, x)/ BETA(a, b)

Do EXAMPLE(BETA_INCOMPLETE); for an example.

See also BETA_DENSITY, BETA_DISTRIB and INV_BETA_DISTRIB.

&BEZOUT(p1, p2, var)

An alternative to the RESULTANT command.  It returns a matrix.
DETERMINANT of this matrix is the desired resultant.

Do EXAMPLE(BEZOUT); for an example. 

&BFAC

This command is obsolete, use BFFAC.

&BFEIGENVALUES_BY_SCHUR(A)

A bigfloat version of EIGENVALUES_BY_SCHUR.  

See also EIGENS_BY_SCHUR.

&BFFAC(exp, n)

[BFFAC package] BFLOAT version of the Factorial (shifted Gamma)
function.  The 2nd argument is how many digits to retain and return.
It's a good idea to request a couple of extra.  This and related
functions are available in the package BFFAC.  

Do USAGE(BFFAC); for more information.

See also GAMMA, CGAMMA, FACTORIAL.

&BFHZETA(S, H, BFPREC)

[BFFAC package] Gives BFPREC digits of SUM((K+H)^-S,K,0,INF).

&BFLOAT(X)

Converts all numbers and functions of numbers to bigfloat numbers.
Setting BFPRECISION (default:20) to N, sets the bigfloat precision
to N digits.  If FLOAT2BF (default:FALSE) is FALSE, a warning message
is printed when a floating point number is converted into a bigfloat
number (since this may lead to loss of precision).  If TRUE, no
message appears when numbers are converted to bigfloat.

BFLOAT(X, digits)

Is equivalent to BLOCK([BFPRECISION:digits], BFLOAT(X)) .

Do EXAMPLE(BFLOAT); for an example.  Do DEMO(FLOATNUMS); for a larger
demonstration of floating point arithmetic.

Functions for manipulating bigfloat numbers include BFLOATP, BFTORAT,
BFTRUNC, FLOAT2BF.

Built-in bigfloat functions in Macsyma include BFFAC, BFPSI, BFZETA,
CBFFAC, BROMBERG.

See also SFLOAT, DFLOAT.

&BFLOATP(exp)

If exp is a bigfloat number, then returns TRUE, else returns FALSE.

See also BFLOAT.

&BFPRECISION default:20

Controls the floating point precision of BIGFLOATS.  Can be set to an
integer representing the desired precision.

Do EXAMPLE(BFPRECISION); for an example.

See also BFPRINT_PRECISION.

&BFPRINT_PRECISION default:0

The number of digits to print when printing a bigfloat number. 

It possible to compute with a large number of digits of precision, but
have the answer printed out with a smaller number of digits.  
 - If BFPRINT_PRECISION=0 (the default), or >= BFPRECISION, then the
   value of BFPRECISION controls the number of digits used for
   printing.
 - If BFPRINT_PRECISION has a value between 2 and BFPRECISION-1, then
   it controls the number of digits used. 
 - If the value of BFPRINT_PRECISION is negative, then 
   BFPRECISION + BFPRINT_PRECISION digits are printed, but at least
   two.  For example, setting BFPRINT_PRECISION:-3$ means that all but
   the last three digits (but at least two) of a BFLOAT should be
   printed regardless of the value of BFPRECISION. The minimal number
   of digits used is 2, one to the left of the point and one to the
   right.
 - The value 1 for BFPRINT_PRECISION is illegal.

See also BFPRECISION.

&BFPSI(n, z, bfprec)

Computes PSI[n](z) (polygamma) to precision bfprec for real arg and
integer order.  For digamma, BFPSI0(z, bfprec) is more direct.  Note
that BFPSI0(1,bfprec) provides BFLOATed %GAMMA.

See also BFPSI0.

&BFPSI0(z, bfprec)

Computes PSI[0](z) (digamma) to precision bfprec for real arguments.
Note that BFPSI0(1,bfprec) provides BFLOATed %GAMMA.

See also BFPSI.

&BFTORAT default:TRUE

Controls the conversion of bfloats to rational numbers.  
 - If BFTORAT:FALSE, RATEPSILON will be used to control the conversion
   (this results in relatively small rational numbers).  
 - If BFTORAT:TRUE, the rational number generated will accurately
   represent the bfloat.

&BFTRUNC default:TRUE - causes trailing zeroes in non-zero bigfloat
numbers not to be displayed.  Thus, if BFTRUNC:FALSE, BFLOAT(1);
displays as 1.000000000000000B0.  Otherwise, this is displayed as 1.0B0.

Do EXAMPLE(BFTRUNC); for an example.

&BFZETA(exp, n)

[BFFAC package] BFLOAT version of the Riemann Zeta function. 

Arguments:
 - EXP may be a bigfloat, real, or complex number.
 - N is how many digits to retain and return.  It is a good idea
   to request a couple of extra.

See also, ZETA, and ZETADERIV.

&BI(x)

See AIRY_BI.

&BIGNUM

A subtype of integer, containing those integers which are so large
they cannot be stored in a single machine word. The only bound on the
size of a representable integer is the total available virtual address
space that is available to Macsyma.

&BINDTEST

DECLARE(symbol, BINDTEST) causes symbol to signal an error if ever it
is used in a computation unbound.  This works only if the symbol is
globally unbound.

&BINOM_CONTRACT(expr)

Simplifies linear combinations of binomial coefficients in expr by
shifting upper and lower indices and then combining.

Do EXAMPLE(BINOM_CONTRACT); for an example.

See also INTO_BINOM. 

&BINOMIAL(X, Y)

The binomial coefficient X*(X-1)*...*(X-Y+1)/Y!.  If X and Y are
integers, then the numerical value of the binomial coefficient is
computed.  If Y, or the value X-Y, is an integer, the binomial
coefficient is expressed as a polynomial.

An alternative name for BINOMIAL is BINOM.

Do EXAMPLE(BINOMIAL); for an example. 

See also COMBINATION, GAMMA, FACTORIAL, MAKEFACT, MAKEGAMMA.
 
&BINOMIAL_DENSITY(x, n, p)

[UNIPROB package] The binomial density function, sometimes called the
Bernoulli density function.  The probability that the event will
happen x times in n number of tries, where p is the probability that
an event will happen in a single try.  The probability density
function is given by:
                        n - x  x
  binomial(n, x) (1 - p)      p

Do USAGE(UNIPROB); for more information.

Do DEMO(UNIPROB); for a demonstration.

&BINOMIAL_DISTRIB(x, n, p)

[UNIPROB package] The binomial distribution, sometimes called the
Bernoulli distribution.  The probability that the event will happen x
times in n number of tries, where p is the probability that an event
will happen in a single try.  The probability function is given by:
                            n - x  x
      binomial(n, x) (1 - p)      p

Do EXAMPLE(BINOMIAL_DISTRIB); for and example.

&BINOMIAL_MODULUS default:FALSE

If set to a positive integer, serves as the modulus by which results
of BINOMIAL(integer, positive_integer) are reduced.

For large integers, this is dramatically faster than taking MOD of a
huge intermediate binomial.  It also differs from MOD by returning a
nonnegative residue, instead of the residue nearest 0.

&BISECT

A library package which finds roots of univariate equations using the
method of weighted bisection.  The main user function in the package
is ROOT_BY_BISECTION.  

Do USAGE(BISECT); for more information.

Do EXAMPLE(ROOT_BY_BISECTION); for an example, and DEMO(BISECT); for a
longer demonstration.

See also NEWTON for Newton iteration.

&BISECTION_DEP_TOLER default:0.0

The tolerance in the expression value for ROOT_BY_BISECTION.  The root
search terminates when the value of the expression is less than this
amount.

&BISECTION_ERROR default:TRUE

Controls what happens when the function ROOT_BY_BISECTION is called
with limit arguments that yield values of the same sign for the
expression evaluated at those points.  
 - If BISECTION_ERROR=TRUE, then an error will be signaled.
 - If BISECTION_ERROR is set to a floating-point number, then
   that number will be returned.

&BISECTION_INDEP_TOLER default:0.0

The tolerance in the independent variable for ROOT_BY_BISECTION.  The
root search terminates when the bounds on the root differ by less than
this amount.

&BISECTION_ITER_LIMIT default:1000

The maximum number of iterations that ROOT_BY_BISECTION will perform.

&BLACK_BODY_FREQUENCY(Te, NU)

Computes the radiation of a black body at temperature Te (kelvin) 
at frequency nu (GHz) using the general formula

   2*%C1*NU^5/(EXP(%%C*%C2/(Te*NU)-1)/(%%C)^5

See UNITS, BLACK_BODY_WAVELENGTH, or BLACK_BODY_RADIATION.

&BLACK_BODY_RADIATION(Te, l1, l2)

Computes the radiation of a black body at temperature Te (kelvin) between
wavelengths l1 and l2 (in microns) using the forumla
 
    integrate(BLACK_BODY_WAVELENGTH(Te,x),x,l1,l2)

See UNITS and BLACK_BODY_WAVELENGTH.

&BLACK_BODY_WAVELENGTH(Te, L1)

Computes the radiation of a black body at temperature Te (kelvin) 
at wavelength l1 (microns) using the general formula

   2*%C1/(EXP(%C2/(Te*L1)-1)/l1^5

See UNITS.

&BLACK_SCHOLES(s, tau, e, r, sigma)

Computes the Black-Scholes valuation formula for a European call
option, where
  s   = current stock price
  e   = exercise price
  tau = time remaining before expiration   
  sigma = standard deviation of the continuously compounded
        annual rate of return on the stock
  r   = continuously compounded riskless rate of interest

Do EXAMPLE(BLACK_SCHOLES); for an executable example.

See also USAGE(FINANCE); for related functions.

&BLACKMAN_WINDOW(t, t0, t1)

Computes the Blackman Window function:

  if t<t0 or t>t1
   then 0 
   else 0.42 - 0.5*cos(2*%pi*t/(t1-t0)) + 0.08*cos(4*%pi*t/(t1-t0)).

Do EXAMPLE(BLACKMAN_WINDOW); for an example and DEMO(POWER_SPECTRUM);
for longer demonstration.

See also POWER_SPECTRUM.

&BLOCK([v1,...,vk], statement1, ..., statementj)

Blocks in Macsyma are somewhat analogous to subroutines or procedures
in other computer languages.  Blocks are like compound statements but
also enable the user to label statements within the block and to
assign "dummy" variables to values which are local to the block.  The
vi are variables which are local to the BLOCK and the statementi are
any Macsyma expressions.  If no variables are to be made local then
the list may be omitted.  A block uses these local variables to avoid
conflict with variables having the same names used outside of the
block (i.e. global to the block).  In this case, upon entry to the
block, the global values are saved onto a stack and are inaccessible
while the block is being executed.  The local variables then are
unbound so that they evaluate to themselves.  They may be bound to
arbitrary values within the block but when the block is exited the
saved values are restored to these variables.  The values created in
the block for these local variables are lost.  Where a variable is
used within a block and is not in the list of local variables for that
block it will be the same as the variable used outside of the block.

If it is desired to save and restore other local properties besides
VALUE, for example ARRAY (except for complete arrays), FUNCTION,
DEPENDENCIES, ATVALUE, MATCHDECLARE, ATOMGRAD, CONSTANT, and NONSCALAR
then the function LOCAL should be used inside of the block with
arguments being the names of the variables.

The value of the block is the value of the last statement or the value
of the argument to the function RETURN which may be used to exit
explicitly from the block.  The function GO may be used to transfer
control to the statement of the block that is tagged with the argument
to GO.  To tag a statement, precede it by an atomic argument as
another statement in the BLOCK.

For example:   BLOCK([X],X:1,LOOP,X:X+1,...,GO(LOOP),...).  
The argument to GO must be the name of a tag appearing within the
BLOCK.  One cannot use GO to transfer to a tag in a BLOCK other than
the one containing the GO.

Blocks typically appear on the right side of a function definition
but can be used in other places as well.

Do EXAMPLE(BLOCK); for an example. 

&BLOCKMAT(matrix)

[MATFUNCS Package] Takes a block matrix (a matrix whose entries are
appropriately dimensioned matrices) and returns a regular matrix.

Do EXAMPLE(BLOCKMAT); for an example. 

See also MAT_UNBLOCKER.

&BOOLEANP(input)

Boolean predicate distinguishes Boolean (literally either TRUE or
FALSE) input from all other input.

&BOOLSIMP(expr)

Simplifies Boolean expressions. EXPR must be a Boolean expression in
{and, or, not} of at most two variables and uses the Macsyma rational
function package and modulo 2 arithmetic to construct a simple
canonical representative to the truth value function equivalent of the
given input expression.

You must set PREDERROR to FALSE to use BOOLSIMP.  This is necessary 
because Macsyma's usual truth value analysis is trivariate: 
{true, false, unknown}.

Do EXAMPLE(BOOLSIMP); for examples and DEMO(BOOLEAN); for a longer
demonstration.

See also PREDERROR, LOGIC_TABLE, TAUTOLOGYP.

&BOTHCOEF(exp, var) - returns a list whose first member is the
coefficient of var in exp (as found by RATCOEF if exp is in CRE form
otherwise by COEFF) and whose second member is the remaining part of
exp.  That is, [A,B] where exp=A*var+B.

Do EXAMPLE(BOTHCOEF); for an example.

&BOX(expr {, _label_})

Returns expr enclosed in a box.  The box is actually part of the
expression.  If _label_ is specified, the box will appear with the
title _label_.  If _label_ is too long, it is truncated.

BOXCHAR default:"*"

  Is the character used to draw the box in this and in the DPART and
  LPART functions.

Do EXAMPLE(BOX); for an example.

See also DPART, LPART, REMBOX.

&BOXCHAR default:"*"

Is the character used to draw the box in the BOX and in the DPART and
LPART functions.

&BREAK(arg1, ...)

Evaluates and prints its arguments and then causes a Macsyma
breakpoint, at which the user can examine and change his environment.
Type EXIT; to continue the computation.  Type ABORT; to abort the
computation and return to the innermost command loop.

Typing Control-C in some versions of Macsyma (or Control-Suspend on a
Symbolics machine) causes Macsyma to enter a break from any point
interactively.  If DEBUGMODE=LISP, then the breakpoint entered by
Control-C or Control-Suspend will be a Lisp breakpoint rather than
a Macsyma breakpoint.

Do EXAMPLE(BREAK); for an example.

See also TOBREAK, TO_LISP, DEBUGMODE, TRACE, BACKTRACE, TIMER, SETCHECK,
SETCHECKBREAK.

&BREAK_PROMPT default:"_"

Is the prompt used by Macsyma while in a breakpoint.

&BREAKUP default:TRUE

If TRUE, when SOLVE solves a cubic or quartic equation, it displays
the algebraic root (which is common to all the solution expressions)
on an E-line, and expresses the solution expressions in terms of the
E-line label.

BREAKUP:TRUE works only when PROGRAMMODE (default:TRUE) is FALSE.

Do EXAMPLE(BREAKUP); for an example.

&BROMBERG(exp, var, ll, ul)
 or
BROMBERG(function, ll, ul)

A bigfloat implementation of the Romberg algorithm for numerical
integration.  Its use is identical that of the ROMBERG function,
except that

 - ROMBERGTOL is called BROMBERGTOL (default:1.B-4),
 - ROMBERGABS is called BROMBERGABS (default:0.0B0),
 - ROMBERGIT  is called BROMBERGIT  (default:11),
 - ROMBERGMIN is called BROMBERGMIN (default:0).

See ROMBERG for more information.

Do EXAMPLE(BROMBERG); for an example, and DEMO(BROMBERG); for a longer
demonstration.

&BUG("message")

[Lisp Machine Macsyma only] Sends a message to Macsyma Mail.  This may
be used for reporting bugs or suspected bugs in Macsyma.  Expressions
may be included by referring to them, outside double quotes, e.g.

BUG("I am trying to integrate",D3,"but it asks for more list space.
What should I do?");

&BUILDQ

See MACROS .

Do EXAMPLE(BUILDQ); for an example. 

Also see DEMO(BUILDQ); and DEMO(BUILDQ1); .

&BURN(N)

[BFFAC package] Is like BERN(N), but without computing all of the
uncomputed Bernoulli numbers of smaller index.  So BURN works
efficiently for large, isolated N.

BURN uses an observation of W. Dubuque that (rational) Bernoulli
numbers can be approximated by (transcendental) zetas with tolerable
efficiency.

&BUT_UPON_RETURN

An infix form of UNWIND_PROTECT for the common situation where there
is only one "guardform".

See also UNWIND_PROTECT.

For example:

 (c1) FOO:[A,B,C]$

 (c2) BLOCK([OLD_FOO_FIRST:FOO[1]],
           (FOO[1]:D,PRINT(FOO),'DONE)
           BUT_UPON_RETURN FOO[1]:OLD_FOO_FIRST);
 [d, b, c]

 (d2)                                  done

 (c3) FOO;

 (d3)                                [a, b, c]


&BYPARTS(expr, u)
 or
BYPARTS(expr, u, x, y, ...)

Transforms the integrals in the expression expr, i.e., the forms
      'INTEGRATE(integrand, var)
  and 'INTEGRATE(integrand, var, lowerlimit, upperlimit).

U identifies the part of the expression used in the integration by
parts formula

        /                  /
       |                  |
       |                  |
       | u dv  =  u v  -  | v du  .
       |                  |
      /                  /

dv is defined by dv := integrand/u .

BYPARTS takes optional arguments which, if present, are the names 
of variables, and means transform only those integrals over those 
variables.  This is particularly useful for nested integrals, where 
it is only the outer integral which is to be transformed.

Do EXAMPLE(BYPARTS); for an example, and DEMO(BYPARTS); for a longer
demonstration.  Please note that the answer returned by BYPARTS contains 
an integral noun form, so you sometimes want to follow it by calling 
APPLY_NOUNS to compute the returned integral.  Also, BYPARTS can 
sometimes be used to reduce a double integral with a variable limit 
to single integrals.

&BYPASS_ROOTS_CHECK default:TRUE

[ROOTS package] If TRUE, skip checking that the list of roots satisfies
the polynomial equation.


&BZETA

This function is obsolete. See BFZETA.

&CABS(exp)

Returns the complex absolute value (the complex modulus) of exp.

Do EXAMPLE(CABS); for an example. 

See also ABS, COMPLEX, CARG.

&CALCULUS

See CALCULUS_SUMMARY.

&CALCULUS_SUMMARY

Macsyma does many kinds of calculus, including

 - differentiation and limits - see DIFF, LIMIT;
 - integration - see INTEGRATION_SUMMARY for a summary;
 - ordinary differential equations - see ODE; 
 - partial differential equations -see PDELIE;
 - integral equations - see INTEQN; 
 - Laplace transforms - see LAPLACE;
 - Fourier series and transforms - see FOURIER;
 - Taylor and Laurent series - see TAYLOR;
 - vector calculus - see VECT;
 - tensor calculus - see TENSOR_SUMMARY;
 - generation of finite difference equations - do USAGE(FDIF_PDE); 
 - operator algebra - see OPALG; 
 - optimization - see OPTVAR and OPTMIZ.

In Macsyma's mathematical topic browser, you can select the topic
CALCULUS to get lists of subtopics and common commands.  For each
command listed, you can obtain a description and an executable
example.

Macsyma has many other special capabilities in calculus. Consult the
Macsyma Reference Manual for more information.

Do DEMO(CALCULUS); for an introductory demonstration of calculus in
Macsyma.  See DEMOS_CALCULUS for a list of calculus demonstrations
in Macsyma.

&CALFUNCS

A library package which contains a collection of miscellaneous
functions from differential and integral calculus. 

Do USAGE(CALFUNCS); for more information.

&CANFORM(exp)

Obsolete. See ICANFORM.

&CANONLT default:ORDERLESSP

Specifies an order.  The default order is ORDERLESSP.  The value of
CANONLT must be a strict total preorder (a function of two arguments
that returns TRUE or FALSE such that the associated relation is
transitive and irreflexive).

 (c1) H(N):=FOR I DO IF N=(2^I)*FLOOR(N/(2^I)) THEN RETURN(I-1)$

H returns the largest positive integer E such that N is divisible by
2^E (N is assumed to be a positive integer).  Next define an order
function F by:

 (c2) F(A,B):=IS( H(A) < H(B) )$

With this order, 9 is less than 2 and 6 is equivalent to 10.

 (c3) CANONLT:F$

Then all functions in the SET package return the elements of the set
both sorted, (according to the function F, and with all redundancies
eliminated.

 (c4) SETIFY([6,20,2,9,8,12]);
 (d4)                       [9, 2, 12, 8]

&CANTEN(exp)

See ICANTEN.

&CARDINAL_STRING(integer)

Returns the string representing the cardinal value of integer.

 (c1) CARDINAL_STRING(42);
 (d1)                       forty-two

See STRING_SUMMARY for related commands.

&CARG(exp)

Returns the argument (phase angle) of exp.  Due to the conventions and
restrictions, principal value cannot be guaranteed unless exp is
numeric.

Do EXAMPLE(CARG); for an example.

See also COMPLEX, CABS.

&CARLSON_R_C(x ,y)

Evaluates numerically the Carlson elliptic integral

 CARLSON_R_C(x, y) = CARLSON_R_F(x, y, y)

See CARLSON_R_F for more information.

Do DEMO(CARLSON); for a demonstration of all the Carlson elliptic integrals.

See also CARLSON_R_D, CARLSON_R_E, CARLSON_R_F, CARLSON_R_J,
ELLIPTIC_E_BY_CARLSON, ELLIPTIC_F_BY_CARLSON and ELLIPTIC_PI_BY_CARLSON,
JACOBI_AM_BY_CARLSON.

See also ELLIPTIC_F, ELLIPTIC_E.


&CARLSON_R_D(x ,y, z)

Evaluates numerically the Carlson elliptic integral

   CARLSON_R_D(x,y,z) = CARLSON_R_J(x, y, z, z)

See CARLSON_R_J for more information.

Do DEMO(CARLSON); for a demonstration of all the Carlson elliptic integrals.

See also EP_ERRTOL, CARLSON_R_C, CARLSON_R_E, CARLSON_R_F, CARLSON_R_J,
ELLIPTIC_E_BY_CARLSON, ELLIPTIC_F_BY_CARLSON and ELLIPTIC_PI_BY_CARLSON,
JACOBI_AM_BY_CARLSON.

See also ELLIPTIC_F, ELLIPTIC_E.

&CARLSON_R_F(x ,y, z)

Evaluates numerically the Carlson elliptic integral of the first kind

1/2 *integrate(1/sqrt((x+t)*(y+t)*(z+t)),t,0,inf)

Do DEMO(CARLSON); for a demonstration of all the Carlson elliptic integrals.

See also EP_ERRTOL, CARLSON_R_C, CARLSON_R_D , CARLSON_R_J,
ELLIPTIC_E_BY_CARLSON, ELLIPTIC_F_BY_CARLSON and ELLIPTIC_PI_BY_CARLSON,
JACOBI_AM_BY_CARLSON.

See also ELLIPTIC_F, ELLIPTIC_E.


&CARLSON_R_J(x ,y, z, p)

Evaluates numerically the Carlson elliptic integral of the thrid kind

3/2 * integrate(1/(t+p)*1/sqrt((x+t)*(y+t)*(z+t)),t,0,inf)

Do DEMO(CARLSON); for a demonstration of all the Carlson elliptic integrals.

See also EP_ERRTOL, CARLSON_R_C, CARLSON_R_D, CARLSON_R_E, CARLSON_R_F,
ELLIPTIC_E_BY_CARLSON, ELLIPTIC_F_BY_CARLSON and ELLIPTIC_PI_BY_CARLSON,
JACOBI_AM_BY_CARLSON.

See also ELLIPTIC_F, ELLIPTIC_E.

&CARTAN

The exterior calculus package.  The exterior calculus of differential
forms is a basic tool of differential geometry developed by Elie
Cartan and has important applications in the theory of partial
differential equations.  The present implementation is due to F.B.
Estabrook and H.D. Wahlquist.

CARTAN performs exterior products, exterior derivatives, Lie
derivatives, and contraction of vectorfields and differential forms.

Do USAGE(CARTAN); for more information.

Do DEMO(CARTAN); for a demonstration.

&CASE(keyword, ['list-of-indicators1,form1]
 {, ['list-of-indicators2, form2], ..., ['list-of-indicatorsN, formN]}) 

[BASIC package] Evaluates keyword and compares it with the list of
indicators in the subsequent arguments.  The indicators are not
evaluated.  If keyword is a member of the list of indicators then the
corresponding form is evaluated and the result is returned.  If a
single indicator is given then it need not be a list.  If the final
indicator is either OTHERWISE or TRUE then the final form is
evaluated.

Do EXAMPLE(CASE); for an example.

&CATCH(exp1, ..., expn)

Evaluates its arguments one by one; if the structure of the expi leads
to the evaluation of an expression of the form THROW(arg), then the
value of the CATCH is the value of THROW(arg).  This "non-local
return" thus goes through any depth of nesting to the nearest
enclosing CATCH.  There must be a CATCH corresponding to a THROW, else
an error is generated.  If the evaluation of the expi does not lead to
the evaluation of any THROW then the value of the CATCH is the value
of expn.

 (c1) G(L):=CATCH(MAP(LAMBDA([X],
        IF X<0 THEN THROW(X) ELSE F(X)),L))$

 (c2) G([1,2,3,7]);
 (d2)                     [f(1), f(2), f(3), f(7)]

 (c3) G([1,2,-3,7]);
 (d3)                                - 3

The function G returns a list of F of each element of L if L consists
only of non-negative numbers; otherwise, G "catches" the first
negative element of L and "throws" it up.

Do EXAMPLE(CATCH); for an example.

See also ERRCATCH, THROW.

&CAUCHY(x_list {, y_list})

Produces a square matrix whose general element is
1/(x_list[i]+y_list[j]), where x_list and y_list are lists or vectors.
If y_list is not input, it defaults to x_list.  

Exception: If the first input is a scalar k, CAUCHY(k) is the same as
CAUCHY([1,2,...,k]) .

Do EXAMPLE(CAUCHY); for an example.

&CAUCHYSUM default:FALSE

When multiplying together sums with INF as their upper limit, if
SUMEXPAND is TRUE and CAUCHYSUM is set to TRUE then the Cauchy product
will be used rather than the usual product.  In the Cauchy product the
index of the inner summation is a function of the index of the outer
one rather than varying independently.  That is:
SUM(F(I),I,0,INF)*SUM(G(J),J,0,INF) becomes
SUM(SUM(F(I)*G(J-I),I,0,J),J,0,INF).

See also LINEARDISTRIB, SUMEXPAND, and SUMCONTRACT.

&CAUCHY_DENSITY(x, alpha, beta)

[UNIPROB package] The density function
1/(%pi*beta*(1+((x-alpha)/beta)^2)).

Do USAGE(UNIPROB); for more information.

Do DEMO(UNIPROB); for a demonstration.

See also CAUCHY_DISTRIB.

&CAUCHY_DISTRIB(x, alpha, beta)

[UNIPROB package] The cumulative distribution for the CAUCHY_DENSITY.

See also CAUCHY_DENSITY and INV_CAUCHY_DISTRIB.

&CBFFAC(z, bfprec)

A factorial for complex bfloats.

Do USAGE(BFFAC); for more information.

Do EXAMPLE(CBFFAC); for an example.

&CCURRIND default:0

[GENTRAN package] number of blank spaces printed at the beginning of
each line of C code generated by the GENTRAN or GENTRANIN commands.

&CDISPLAY(name)

[CTENSOR package] Will display the unique nonzero components of
virtually all the metric tensors, connection coefficients, and
curvature tensors in CTENSOR; also the FRAME_BRACKET FB, the torsion
tensor TR, the contortion tensor KT, and the conformal nonmetricity
vector NM.  If the object to be displayed is represented as a matrix
(LG,UG,LFG,UFG,FR,FRI), then the function CDISPLAY must be called as
CDISPLAY('name);.

&CDIV11(tens, dis)

[CTENSOR package] Computes the covariant divergence of a (1,1) tensor
tens, and stores the result in the array CDIV[i].

                   j
     CDIV  :  tens        (sum over j),
         i        i  ;j

where ";" denotes covariant differentiation.  If the argument dis has
the value TRUE, then the nonzero components of CDIV are displayed.

&CEILING(exp)

Converts its numerical argument by truncating toward plus infinity.
I.e. the result is the smallest integer that is not smaller than the
argument.  CEIL is an alias for CEILING.

diff(ceiling(x),x); gives 0 .

Examples:

argument  FLOOR  CEILING  FIX  ROUND 
 2/3       0      1        0    1
-2/3      -1      0        0   -1

Do EXAMPLE(CEILING); for an example.

See also FIX, FLOOR, ROUND.

&CENTERPLOT default:[]

VIEWPT and CENTERPLOT determine the perspective view taken for
plotting commands.  They are defaulted to be unbound. 

o VIEWPT may be set to a list of 3 numbers and gives the point
  from which the projection should be made.

o CENTERPLOT may likewise be set to a list of 3 numbers and gives
  a point on the line of sight.

o Set PLOT_PHI (default:30) and PLOT_THETA (default:30) as an
  alternative to setting VIEWPT.	

The projection will be made onto a plane perpendicular to a 
line joining VIEWPT and CENTERPLOT.

If VIEWPT and CENTERPLOT are unbound (the default) then they will be
chosen as follows: the extreme values of the coordinates are determined.
This gives the two points min: [xmin,ymin,zmin], max:[xmax,ymax,zmax].
CENTERPLOT is chosen as (min+max)/2, and VIEWPT is chosen as
max+3*(max-min).  The view is then one in which the z axis is vertical,
the x axis is increasing towards you to the left and the y axis is
increasing towards you to the right.

If CENTERPLOT is FALSE then the old type of perspective view will be
given (like setting the x and z components of CENTERPLOT to the
corresponding components of VIEWPT).

Do EXAMPLE(CENTERPLOT); for an example.

See also PLOT_ROLL.

&CF(exp)

Converts exp into a continued fraction.  exp is an expression composed
of arithmetic operators and lists which represent continued fractions.
A continued fraction a+1/(b+1/(c+...)) is represented by the list
[a,b,c,...].  a,b,c,.. must be integers.  Exp may also involve SQRT(n)
where n is an integer.  In this case CF will give as many terms of the
continued fraction as the value of the variable CFLENGTH (default:1)
times the period.  Thus the default is to give one period.  (CF binds
LISTARITH to FALSE so that it may carry out its function.)

Do EXAMPLE(CF); for an example, and DEMO(CONTFRAC); for a longer
demonstration.

See also CFDISREP, CFEXPAND, and CFLENGTH .

&CFACTOR(poly,var)

[POLSOL package] expresses the polynomial poly in factored form over
the complex field, if possible.  CFACTOR combines the commands
FACTORFORM and POLYSOLVE.

Do EXAMPLE(CFACTOR); for an example.

&CFDISREP(list)

Converts the continued fraction represented by list into general
representation.

 (c1) CF([1,2,-3]+[1,-2,1]);

 (d1)                 [1, 1, 1, 2]

 (c2) CFDISREP(%);

                            1
 (d2)                1 + ---------
                               1
                         1 + -----
                                 1
                             1 + -
                                 2

Do EXAMPLE(CFDISREP); for an example.

See also CF, CFEXPAND, and CFLENGTH .

&CFEXPAND(x)

Gives a matrix of the numerators and denominators of the next-to-last
and last convergents of the continued fraction x.

 (c1) CF(SQRT(3)), CFLENGTH:4;
 (d1)                 [1, 1, 2, 1, 2, 1, 2, 1, 2]

 (c2) CFEXPAND(%);
                              [265  97]
 (d2)                         [       ]
                              [153  56]

 (c3) D2[1,2]/D2[2,2],NUMER;
 (d3)                        1.7321428

Do EXAMPLE(CFEXPAND); for an example.

See also CF, CFDISREP, and CFLENGTH .

&CFLENGTH default:1

The number of times the repeating tail of a continued fraction is
displayed by the function CF.  Thus the default is to display the
repeating tail one time.

&CFLOAT_MATRIXP(exp)

Returns TRUE if exp is a matrix consisting entirely of floating point 
numbers (but not bigfloats) or complex floating point numbers, else 
FALSE.

If CFLOAT_MATRIXP(mat); is TRUE and USE_MATRIX_LU is TRUE and Macsyma 
is linked to LAPACK routines, then Macsyma might automatically use 
these routines for various matrix operations if the matrix is 
sufficiently large.

Do EXAMPLE(CFLOAT_MATRIXP); for an example.

See also CNUMERICAL_MATRIXP, DET_BY_LU, INVERT_BY_LU.

&CFRAME_FLAG default:FALSE

[CTENSOR package] When TRUE, CTENSOR computes using the frame field
inverse stored in the matrix FRI and the fiber metric stored in the
matrix LFG.

To calculate with frame fields, specify CFRAME_FLAG:TRUE;, then
specify
 - the dimension of the manifold, DIM,
 - the coordinate list, CT_COORDS,
 - the covariant fiber metric LFG,
 - and the frame field inverse, FRI.
Then invoke the command CMETRIC(); to initialize the computation.

&CGAMMA(z)

Returns the value of the GAMMA function in the complex plane at z.
z can be symbolic or numeric.

Do EXAMPLE(CGAMMA); for an example.

CGAMMA(z) is a function in the package also named CGAMMA.  The CGAMMA
package contains the functions CGAMMA(z), CGAMMA2(real,imag) and
LOGCGAMMA2(real,imag), all three of which autoload.

Do USAGE(CGAMMA); for more information.

See also BFFAC, GAMMA, FACTORIAL.

&CGAMMA2(real, imag)

See CGAMMA.

&CGEODESIC(dis)

[CTENSOR package] Computes the geodesic equations of motion for a
given affine connection, and stores them in the array GEOD[i].  If the
argument dis is TRUE then the equations are displayed.

CGEODESIC(dis, s)
  Uses the optional argument s as the path parameter in the geodesic
  equations.  If s is not specified, then CGEODESIC uses the name %S
  for the path parameter.

&CHANGE_SUM_LIMITS(expr, lim, incr)

[ALGFUNCS package] Re-expresses a summation by changing the lower or
upper limit of the summation by the amount incr (which must be an
integer), and expressing explicitly the terms which are necessary so
that the final result is equivalent to the initial expression expr.

Do EXAMPLE(CHANGE_SUM_LIMITS); for an example.

See also CHANGEVAR.

&CHANGENAME(old, new, exp)

[ITENSOR package] An obsolete version of the command ICHANGENAME.
Please note that CHANGENAME reverses the order of the first two 
arguments, compared to ICHANGNAME.

&CHANGEVAR(exp, f(x,y), y, x)

Makes the change of variable given by f(x,y)=0 in all integrals
occurring in exp with integration with respect to x; y is the new
variable.

CHANGEVAR can also be used to make changes in the indices of a sum or
product.  However, this change must be a shift, e.g. i=j+... , not a
higher degree function.

Do EXAMPLE(CHANGEVAR); for examples.

See also ODE_INDEPTRAN.

&CHANGEVAR_MULTIPLE_SOLUTIONS default:WARN

Determines how CHANGEVAR responds when it finds multiple solutions
to a change of variables.  There are four possible settings.


 Setting   CHANGEVAR's Response
 -------   --------------------
 NO_WARN   Returns the last solution returned by SOLVE.
           Does not print a warning message.

 WARN      Prints a warning message, and returns the last solution
           returned by SOLVE. 

 ERR       CHANGEVAR signals an error.

 ASK       CHANGEVAR asks the user to select the desired solution.

Do EXAMPLE(CHANGEVAR_MULTIPLE_SOLUTIONS); for an example.

&CHAR(lhs, rhs, dep_var, indep_var, order, initial_value_list)

[RECUR package] Implements the characteristic polynomial method.  
This method is applicable only to linear constant-coefficient 
difference equations.

lhs and rhs are the left and right hand sides respectively of the
linear difference equation.  dep_var is the dependent variable and
indep_var is the independent variable.  order is the order of the 
difference equation, and initial_value_list is a list of equations which
assign the initial values.

Do DEMO(RECUR); for a demonstration of the RECUR package.

For solving recurrence equations, users should first try the command
DIFFERENCEQ.

&CHAR_GRAPH(xlist, ylist {, xlabel, ylabel})

Generates an ASCII character plot of the two lists of data points, and
labels the axes as indicated or omits labels if just the first two
arguments are given.

ASCII character plots are useful for sending graphs in ASCII electronic
mail, and in some other situations.  Normally lists of points are
plotted with modern graphics using the GRAPH command.

Other calling syntaxes are:

CHAR_GRAPH([x1, x2, x3, ..., xn], [y1, y2, y3, ..., yn])
  Generates an ASCII character plot from the two sets of data points.

CHAR_GRAPH([[x1, y1], [x2, y2], ..., [xn, yn]])
  Generates an ASCII character plot specified by the list of
  coordinate pairs.

CHAR_GRAPH(xset, [yset1, yset2,..., ysetn] {, optional-args})
  Generates an ASCII character plot where the xset list of ordinate
  numbers is re-used with multiple lists yseti of abscissa numbers. 
  For example CHAR_GRAPH([0,1], [[0,1], [1,2]]).

See also, GRAPH, CHAR_MULTIGRAPH, CHAR_PARAMPLOT, CHAR_PLOT,
PLOTHEIGHT.  See PLOTTING_SUMMARY for  a more complete list of
Macsyma's plotting capabilities. 

&CHAR_MULTIGRAPH([[xset1, yset1], ..., [xsetn, ysetn]], optional-args)

Allows the user to produce an ASCII character scatter-graph involving
several x-domains each with a single y-range.  For example,
CHAR_MULTIGRAPH([[[0,1], [0,1]], [[3,4], [1,2]]]).

ASCII character plots are useful for sending graphs in ASCII
electronic mail, and in some other situations.  Normally lists of
points are plotted with modern graphics using the GRAPH command.

See also GRAPH, CHAR_GRAPH, CHAR_PARAMPLOT, CHAR_PLOT, PLOTHEIGHT.

&CHAR_PARAMPLOT(f1(t), f2(t), t, low, hi)

Generates an ASCII character plot of the plane curve
f(t)=(f1(t),f2(t)) with parameter t.  The syntax is basically like
that of plot.  For example,

  CHAR_PARAMPLOT(COS(T),SIN(T),T,0,2*%PI)

CHAR_PARAMPLOT([f1(t), g1(t), ...h1(t)], [f2(t), g2(t),..., h2(t)], t,
low, hi {, list of plotting characters})
  Generates an ASCII plot of the plane curves

   f(t) = (f1,f2), g(t) = (g1,g2),...,h(t) = (h1,h2)

  using the specified plotting characters or the default "*". 
  For example,

  CHAR_PARAMPLOT([COS(T),COS(T)+7], [SIN(T),SIN(T)],T,0,2*%PI,["@"])

  plots two circles using the character "@" at each plot point.

ASCII character plots are useful for sending graphs in ASCII
electronic mail, and in some other situations.  Normally parametric
curves are plotted with modern graphics using the PARAMPLOT command.

See also PARAMPLOT, CHAR_GRAPH, CHAR_PLOT, PLOTHEIGHT.  See
PLOTTING_SUMMARY for a more complete list of Macsyma's plotting
capabilities. 

&CHAR_PLOT(exp, var, low, high)

Produces an ASCII character plot of the expression exp as var (the
independent variable) ranges from low to high.  An optional fifth
argument of INTEGER causes CHAR_PLOT to choose only integer values for
var in the given domain.  For graphics terminals there are routines
which do more sophisticated plots.  See PLOT.

CHAR_PLOT(F(x), x, [x1, x2, x3, ..., xn])
  Plots the function F(x) for the values x1,x2,x3,...,xn.

ASCII character plots are useful for sending graphs in ASCII
electronic mail, and in some other situations.  Normally expressions
are plotted with modern graphics using the PLOT command.

See PLOTTING_SUMMARY for a more complete list of Macsyma's plotting
capabilities.

See also PLOT, CHAR_GRAPH, CHAR_PARAMPLOT, PLOTHEIGHT.

&CHARACTERS

Macsyma allows the user to type a number of control characters in
order to get interesting effects.

The treatment of control characters may one of two different kinds.

 - Synchronous characters are used only by the reader; if typed at a
   time when no read operation is in effect, they are buffered until
   the next read operation happens and then acted upon.

 - Asynchronous characters, sometimes called "interrupt characters",
   take effect at the instant they are typed.  The asynchronous
   characters recognized by Macsyma are:

   Pause key (MS-Windows implementations)
   Control-G (UNIX implementations)
   Control-Abort (Symbolics implementations)

     Asynchronously aborts a computation and returns control to
     the innermost top-level Macsyma.

   Control-C (UNIX implementations)
   Control-Suspend (Symbolics implementations)

     Asynchronously enters a breakpoint in Macsyma and suspends 
     the computation.  At this point the user is in a Macsyma break 
     loop such as that which would be created by executing BREAK().
     If a user function was being executed at the time of the break,
     its argument values may be printed or changed.  Aside from this,
     it is almost like being at top-level Macsyma.  To exit and 
     resume the computation type EXIT; .  To flush the ongoing
     computation, type ABORT; .

   Control-] (Symbolics implementations)

     Asynchronously prints the time used so far in a computation
     (without interrupting it).  In some computations, such as PLOT 
     and ROMBERG this may also print other information about how
     far the computation has gotten.

&CHARPOLY(M, var)

Computes the characteristic polynomial for Matrix M with respect to
var.  That is, DETERMINANT(M - DIAGMATRIX(LENGTH(M),var)).

Do EXAMPLE(CHARPOLY); for an example. 

See also NCHARPOLY.

&CHEB_RATLSQ_MAXC default: 100

Maximum size of the sums of the orders of polynomials used
by RATIONAL_CHEBYSHEV_COEFF.

&CHEB_RATLSQ_MAXIT default: 5

Maximum number of iterations used by RATIONAL_CHEBYSHEV_COEFF.

&CHEBYSHEV

There are four functions for computing Chebyshev polynomials 
in the SPECFUN package:
 - CHEBYSHEV_T(N,X) and CHEBYSHEV_T[N](X) for Chebyshev polynomials T
 - CHEBYSHEV_U(N,X) and CHEBYSHEV_U[N](X) for Chebyshev polynomials U.

For numerical evaluation of Chebyshev approximation, see
CHEBYSHEV_COEFF, CHEBYSHEV_EVALUATE.

For rational Chebyshev approximations, see CHEBYSHEV_RATIONAL_APPROX.

Do EXAMPLE(CHEBYSHEV_COEFF); for an example.

Do DEMO(cheb_int); or DEMO(CHEBRATA); for
other demos.

&CHEBYSHEV_EVALUATE(a, b, c, x)

Evaluates the Chebyshev expansion numerically at the x in the finite
interval [a, b]. The numerical coefficients are in the list c.

See also CHEBYSHEV_COEFF.

Do EXAMPLE(CHEBYSHEV_COEFF); for an example.

&CHEBYSHEV_COEFF(a, b, func, n)

Computes the Nth order coefficents of the Chebyshev polynomial
exansion of func on the finite interval [a, b]. a and b must be
numbers.

func must return single or double precision numbers.

CHEBYSHEV_COEFF returns a list.

See also CHEBYSHEV_EVALUATE, CHEBYSHEV_DERIVATIVE, CHEBYSHEV_INTEGRATE,
RATIONAL_CHEBYSHEV_COEFF.

Do EXAMPLE(CHEBYSHEV_COEFF); for an example.

Do DEMO(CHEB_ECON); for an demonstration of Chebyshev economization.

&CHEBYSHEV_DERIVATIVE(a, b, c, n)

Computes the list of coefficients of the derivative of nth order Chebyshev
expansion whose numerical coefficients are given by the list c in
the finite interval [a, b].

See also CHEBYSHEV_EVALUATE, CHEBYSHEV_COEFF, RATIONAL_CHEBYSHEV_COEFF,
CHEBYSHEV_INTEGRATE.

Do EXAMPLE(CHEBYSHEV_DERIVATIVE); for an example.

Do DEMO(CHEBDERV); for a demo.

Do DEMO(CHEB_ECON); for an demonstration of Chebyshev economization.

&CHEBYSHEV_INTEGRATE(a, b, cofs, n)

If cofs is the list of Chebyshev coefficients returned by CHEBYSHEV_COEFF
on the interval [a,b] approximating f(x) , then CHEBYSHEV_INTEGRATE
returns the list of numerical Chebyshev coefficients approximating 
g(x) =  INTEGRATE(F(T), T, a, x); on [a, b].

Note that the constant of integration for g is chosen so that g(a)=0. 

Do EXAMPLE(CHEBYSHEV_INTEGRATE); for an example.

Do DEMO(CHEBINT); for a demo. 

See also CHEBYSHEV_DERIVATIVE, CHEBYSHEV_EVALUATE,
RATIONAL_CHEBYSHEV_COEFF.

&CHEBYSHEV_T(N, X)

[SPECFUN package] computes the Chebyshev polynomial T(N,X), where N is
a nonnegative integer.

CHEBYSHEV_T[N](X) is an alternative syntax, which stores the
Chebyshev polynomials of order less than or equal to N.

Do LOAD(SPECFUN); to access this function.

See also CHEBYSHEV_U.

&CHEBYSHEV_U(N, X)

[SPECFUN package] computes the Chebyshev polynomial U(N,X), where N is
a nonnegative integer.

CHEBYSHEV_U[N](X) is an alternative syntax, which stores the Chebyshev
polynomials of order less than or equal to N.

Do LOAD(SPECFUN); to access this function.

See also CHEBYSHEV_T.

&CHECK_EV(mat, values, vectors {,type})

Checks to see if the list of eigenvalues in values and eigenvectors
in vectors consistently represent eigenstructure of mat. Values and
vectors are returned by EIGENS_BY_SCHUR or LEFT_EIGENS_BY_SCHUR.
Type is 'right (default) or 'left. If 'right, CHECK_EV calculates

 ||(mat-values[j]*I).vectors[j] ||

for values and vectors. If 'left, it calculates

 || vectors[j].(mat-values[j]*I) ||.

Values and vectors are the forms output by EIGENS_BY_SCHUR,
RIGHT_EIGENS_BY_SCHUR or LEFT_EIGENS_BY_SCHUR.

Do DEMO(NUMKIT);


&CHECK_ROOTS(poly, list)

[ROOTS Package] When list is determined by ROOTS(poly), CHECK_ROOTS(poly,
list) checks to see how well each root satisfies the original equation
by computing  CABS(poly) at the root.

&CHI_SQUARE_DENSITY(x, dof)

[UNIPROB package] The chi-square density function

                     dof/2 - 1   - x/2
                    x          %e
        f(x) =     ------------------   x > 0
                      dof/2       dof
                     2      gamma(---)
                                   2
        f(x) =             0            x <= 0.

See also CHI_SQUARE_DISTRIB.

&CHI_SQUARE_DISTRIB(x, dof)

[UNIPROB package] The chi-square distribution.

Do EXAMPLE(CHI_SQUARE_DISTRIB); for an example.

See also CHI_SQUARE_DENSITY, INV_CHI_SQUARE_DISTRIB.

&CHOLESKY_DECOMP(A)

Produces the Cholesky factorization of the numerical, square, positive
definite, Hermitian matrix A.  The value returned is the lower
triangular matrix L that satisfies L L^* = A.

&CHOLESKY_DECOMP_SYMB(A)

Calculates the lower Cholesky decomposition of a square, positive
definite, symmetric matrix A.  This function does not check for
positive definiteness. The value returned is a lower triangular
matrix.

Do EXAMPLE(CHOLESKY_DECOMP); for an example and DEMO(CHOLESKY); for
a longer demonstration.

See also INVERT_BY_CHOLESKY, MATSOLVE_BY_CHOLESKY, CHOLESKY_DECOMP,
MATSOLVE_BY_LU_SYMB, MATSOLVE_BY_LU.

&CHOOSE_VARIABLE_VALUES(variables, prompt)

Presents a menu containing the indicated variables and allows you to
modify any or all of their values.

The variables may be either a list of variables or a list of lists. If
variables is a list of variables, a suitable prompt for each variable's
value is automatically chosen by Macsyma. If variables is a list of
lists, the first element of each list should be a variable and the
second element should be a string which is to be used as the prompt for
that variable's value.

The prompt is optional and is used to generate a message which
introduces the menu. If supplied, it should fit in the sentence "You are
editing <prompt>."  This function is affected by the setting of
PREFERRED_MENU_STYLE.

&CHR1

This function has been renamed ICHR1.

&CHR2

This function has been renamed ICHR2.

&CHRISTOF(dis)

[CTENSOR package] Computes the Christoffel symbols of the first and
second kinds, and stores then in the arrays LCS[i,j,k] and MCS[i,j,k]
respectively.  MCS[i,j,k] is defined so that the final index k is
contravariant.

The value of the argument DIS determines what is displayed.

 DIS    CHRISTOF displays:
 ---    -----------------
 ALL    the unique non-zero values of LCS[i,j,k] and MCS[i,j,k]
 LCS    the unique non-zero values of LCS[i,j,k]
 MCS    the unique non-zero values of MCS[i,j,k]
 FALSE  nothing

The array LCS is removed before exiting the function CHRISTOF.

&CIRCLE_FROM_POINTS(p1, p2, p3)

[GEOFUNCS package] Returns [center, radius] of a circle determined by 3
points in 2-space. Each of p1, p2, p3 is a list of length two.

Do EXAMPLE(CIRCLE_FROM_POINTS); for an example.

See also COMPLEX_CIRCLE_FROM_POINTS.

&CIRCULANT(col)

Generates a circulant matrix from a list or vector containing the
elements of the first column of the matrix. The i,j element of the
matrix contains col[k], where k = i-j+1, mod n, where n is the
length of the input col.

Do EXAMPLE(CIRCULANT); for an example.

See also GENCIRCULANT, TOEPLITZ.

&CIRCUMFERENCE_CIRCLE(rad)

[GEOFUNCS package] Returns the circumference 2*%PI*RAD of a circle of
radius RAD.

&CIRCUMFERENCE_ELLIPSE(semi1, semi2)

[GEOFUNCS package] Returns the circumference of an ellipse with half-axes
semi1 and semi2.  

&CLEAR default:TRUE - When TRUE, the plot window is cleared before
beginning a new plot. When FALSE, the new plot is superimposed on the old
one.  Clearing occurs just before a new plot is done.

CLEAR is often used with WAIT to superimpose plots created by consecutive
plot commands.  For example,

(block([wait:false], plot(sin(x),x,0,10)),
 block([clear:false], plot(cos(x),x,0,10)))$

An alternative way to superimpose plots is the use the keywords FIRST,
SAME, and LAST in the plot commands.  For example:

(plot(sin(x),x,0,10,first),
 plot(cos(x),x,0,10,same),
 plot(sin(2*x),x,0,5,same,last))$

See also WAIT, COMBINE_PLOTS.

&CLEAR_CTENSOR() [CTENSOR package] See INIT_CTENSOR.

&CLEAR_MACSYMA_OUTPUT_HISTORY()

(Symbolics Lisp Machine only) Clears the output history of the current
Macsyma frame (i.e. window) if you are in a Macsyma frame.  For
current windows implementations of Macsyma on PC's and workstations,
the output history can be cleared using the menu item
FILE|CLEAR-OUTPUT.

&CLEARSCREEN()

Clears the screen on some implementations of Macsyma.  For
current of Macsyma on workstations,  this command causes the output 
history to scroll upward, so that the current screen starts out blank.
(The same as typing control-L on Symbolics Lisp machines.)

&CLIFFORD

For Clifford algebras, see the ATENSOR package.  

You can also define a Clifford algebra with vector generators 
s[1], s[2] ... with the commands

 (c1) matchdeclare([[ii,jj], integerp)$

 (c2) tellsimpafter(s[ii]^^2, 1)$

 (c3) tellsimpafter(s[ii].s[jj],-s[jj].s[ii],ii>jj)$

 (c4) compile_rules(all)$

&CLINELEN default:80

[GENTRAN package] maximum number of characters printed on each line of
C code generated by the GENTRAN or GENTRANIN commands.

&CLOSE_TEX_FILE({TRUE})

Closes the file opened by WRITE_TEX_FILE.  If an argument is given,
which must be TRUE, then \end is written on a new line at the end of
the TEX file before closing the file.

&CLOSEDFORM(expr)

[NUSUM1 package] is the main function in the NUSUM1 package for
simplifying expressions.  CLOSEDFORM scans its argument for SUMs,
PRODs, INDEFSUMs, and INDEFPRODs to simplify.  The user should call
CLOSEDFORM for this purpose rather than calling NUSUM directly.  In
particular, this will attack definite (infinite) sums of rational
functions, using a mechanism distinct from NUSUM, which is for
INdefinite sums.

CLOSEDFORM default:TRUE

Is an option variable in the ODE package which controls ODE's approach
to solving the Hypergeometric or Whittaker equations.  When FALSE,
generation of hypergeometric series is suppressed.

&CLOSEFILE(filename)

Closes a file opened by WRITEFILE and gives it the name filename.  If
filename is not specified, the command CLOSEFILE(); closes the file
using the same filename with which the WRITEFILE was opened.

To save a file consisting of the display of all input and output during
some part of a session with Macsyma the user issues a WRITEFILE,
transacts with Macsyma, then issues a CLOSEFILE.  Alternatively, the
user can open a WRITEFILE, issue the PLAYBACK command, and then
CLOSEFILE.

Note that WRITEFILE saves only a copy of the display of expressions,
not the expressions themselves.  To save the actual expressions in
internal form, use the SAVE function.  The expression can then be
brought back into Macsyma via the LOAD function.  To save expressions
in a linear form which may then be BATCHed in later, use the STRINGOUT
command.

See FILENAMES and FILE_PATHNAMES for information about how to specify
file pathnames in Macsyma.  See FILES_SUMMARY for more information
about file manipulation commands in Macsyma.

&CMETRIC()

[CTENSOR package] Performs some initial computations involving the
metric tensor when beginning a computation with CTENSOR.  Using the
value of the covariant metric tensor (stored in the matrix LG),
CMETRIC computes
 - the determinant of the metric and stores it in the variable GDET,
 - the contravariant metric and stores it in the matrix UG,
 - whether the metric is diagonal, and sets the flag DIAGMETRIC 
   accordingly.

If frame fields are used, then (starting with the values of the covariant
fiber metric LFG and the frame field inverse FRI) CMETRIC computes
 - the frame field and stores it in the matrix FR,
 - the covariant coordinate metric and stores it in the matrix LG,
 - the contravariant coordinate metric and stores it in the matrix UG,
 - FDET, the determinant of FR,
 - and FGDET, the determinant of LFG.

CMETRIC(); autoloads CTENSOR, if it is not already loaded.

&CNUMERICAL_MATRIXP(exp)

Returns TRUE if exp is a matrix consisting entirely of integers, rational 
numbers, floating point numbers (but not bigfloats), or complex numbers 
in rectangular form of the above types, else FALSE.

If CNUMERICAL_MATRIXP(mat); is TRUE and USE_MATRIX_LU is TRUE then 
DETERMINANT, INVERT, and MATSOLVE_BY_LU will automatically use fast LU 
methods.

Do EXAMPLE(CNUMERICAL_MATRIXP); for an example.

See also NUMERICAL_MATRIXP, DET_BY_LU, INVERT_BY_LU.

&COEFF(exp, v, n)

Obtains the coefficient of v^n in exp.  n may be omitted if it is 1.
v may be an atom, or complete subexpression of exp e.g., X, SIN(X),
A[I+1], X+Y, etc. (In the last case the expression (X+Y) should occur
in exp).  Sometimes it may be necessary to expand or factor exp in
order to make v^n explicit.  This is not done automatically by COEFF.

 (c1) COEFF(2*A*TAN(X)+TAN(X)+B=5*TAN(X)+3,TAN(X));

 (d1)                         2 a + 1 = 5

 (c2) COEFF(Y+X*%E^X+1,X,0);
 (d2)                            y + 1

Do EXAMPLE(COEFF); for an example.  

See also BOTHCOEF, RATCOEF.

&COEFMATRIX([eq1, ...], [var1, ...])

The coefficient matrix for the variables var1,... of the system of
linear equations eq1,...

Do EXAMPLE(COEFMATRIX); for an example.

See also AUGCOEFMATRIX.

&COGRAD(function, covector)

[CTENSOR package] Computes the covariant gradient of a scalar
function, and stores the result in the array named covector.
                 
     covector  :  function      
             i            ,i

&COL(M,i)

Returns the ith column of the matrix M, in the form of a matrix.

Do EXAMPLE(COL); for an example.

See also COLS, ROW.

&COLLAPSE(expression)

Collapses its argument by causing all of its common (i.e. equal)
subexpressions to share (i.e. use the same cells), thereby saving
space.  (COLLAPSE is a subroutine used by the OPTIMIZE command.)
Thus, calling COLLAPSE may be useful after loading in a SAVE file.
You can collapse several expressions together by using
COLLAPSE([expr1,...,exprN])$.  Similarly, you can collapse the
elements of the array A by doing COLLAPSE(LISTARRAY('A))$.

See also OPTIMIZE.

&COLLECTTERMS(expr, arg1, ...  argn)

[FACEXP package] combines terms in the expression expr which have
similar dependencies on the arg1,...,argn, without exerting the effort
required to resimplify the entire expression.  arg1,...,argn have
equal priority.  COLLECTTERMS collects only terms at the top level of
the expression expr, and does not combine or factor subexpressions at
lower levels in expr. (To affect lower levels as well, use FACSUM).

COLLECTERMS can take as arguments all of the arguments which can be
given to FACSUM with the exception of NEXTLAYERFACTOR, which has no
effect on COLLECTTERMS.  

In a typical application of COLLECTTERMS, several expressions which
have been simplified with FACSUM or FACTORFACSUM are added together
in expr.  COLLECTTERMS provides a low-cost way to combine terms which
have similar dependency in the arg1,...,argn.  The advantage of
COLLECTTERMS is that it returns a form similar to FACSUM, but since
it is adding forms that have already been processed by FACSUM, it does
not need to repeat that effort.   This capability is especially useful
when the expressions to be summed are very large. For more information
do USAGE(FACEXP); .

Do EXAMPLE(COLLECTTERMS); for an example.

&COLOR

See COLORS.

&COLOR_CYCLES default:FALSE

In Macsyma 2.2.3 and 421 and successors, COLOR_CYCLES controls 
whether the hue values produced by COLOR_FUNCTION are subjected
to further linear transformation.

- If COLOR_CYCLES:FALSE, then the returned value of COLOR_FUNCTION
   is not transformed using COLOR_CYCLES and COLOR_MIN.

- If not false, then COLOR_CYCLES must be a number. The hue values
  returned by COLOR_FUNCTION have been linearly mapped onto the
  interval [COLOR_MIN, COLOR_MIN+COLOR_CYCLES].

Hue 0 is red, with increasing values orange, yellow, green, cyan 
(at 0.5), blue, violet, and magenta, finally returning to red at 1.
The fractional part of the hue number (that is, the hue number
modulo 1) determines the hue.

Do DEMO(COLORS); for a demonstration of color control.

See also COLOR_FUNCTION, COLOR_MIN and COLOR_NORMALIZE.

&COLOR_FUNCTION default: color_rainbow_in_z (third coordinate)

The symbolic name of a function of the coordinates [X1,X2,X3].  The
value returned by this function is the color hue index, which
determines the color to be used at each point of a colored plot.  As
the color hue index increases through the interval [0.,1.], the colors
range from red through the rainbow back to red.  For values greater
than 1.0, the fractional part of the color index is used to obtain a
value in the range [0.,1.] .

For example, if COLORF(X1,X2,X3):=SQRT(X1*X1+X2*X2+X3*X3) then 
COMPILE(COLORF) and COLOR_FUNCTION:COLORF makes the color hue a
function of the radius of each plot point from the coordinate center
(0,0,0).  The intensity and color saturation are set automatically.

In Macsyma 2.0 and successors, COLOR_FUNCTION can control intensity-
hue-saturation (IHS) color coordinates or red-green-blue (RGB) color
coordinates.  The color function must return a list of three numbers
or a list of three numbers plus a symbol.  For example,
 - [0.667,0.833,0.50] specifies IHS color coordinates.
 - [0.667,0.833,0.5,IHS] specifies the same IHS color coordinates.
 - [0.82,0.82,0.918,RGB] specifies the same color in RGB coordinates.

The default COLOR_FUNCTION, COLOR_RAINBOW_IN_Z, simulates
- CFUNC(X,Y,Z):=Z, COMPILE(CFUNC), COLOR_FUNCTION:CFUNC,
- COLOR_CYCLES:1.
- COLOR_MIN:0.

See COLORS for a list of built-in constant colors that can be 
specified with COLOR_FUNCTION.

Do DEMO(COLORS); for a demonstration of color control.

See also COLORS, COLOR_CYCLES, COLOR_MIN and COLOR_NORMALIZE.

&COLOR_MIN default:0.02

Specifies the color hue at one end of the spectrum which appears on a
plotted image.  As the color hue index increases through the interval
[0,1], the colors range from red through the rainbow back to red.

In Macsyma 2.2.3 and 421 and successors, COLOR_MIN is active only
when COLOR_CYCLES:TRUE. 

Do DEMO(COLORS); for a demonstration of color control.

See also COLOR_CYCLES, COLOR_FUNCTION and COLOR_NORMALIZE.

&COLOR_NORMALIZE default:FALSE

In Macsyma 2.2.3 and 421 and successors, COLOR_NORMALIZE controls
whether the input arguments to COLOR_FUNCTION are normalized in plots.

o If COLOR_NORMALIZE:FALSE, then COLOR_FUNCTION is applied to
  actual geometric coordinates (x,y,z), not normalized coordinates;

o If COLOR_NORMALIZE:TRUE, then COLOR_FUNCTION is applied to
  normalized spatial coordinates (%x,%y,%z), where 
    %x: (x-xmin1)/(xmax1-xmin1)
    %y: (y-ymin1)/(ymax1-ymin1)
    %z: (z-zmin1)/(zmax1-zmin1) .

The normalized spatial coordinates are used to compute all
three color coordinates (IHS or RGB), wherever spatial coordinates
appear in COLOR_FUNCTION.

Do EXAMPLE(COLOR_NORMALIZE); for an example.

Do DEMO(COLORS); for a demonstration of color control.

See also COLOR_FUNCTION, COLOR_CYCLES and COLOR_MIN.

&COLORS

Colors of plotted lines are controlled from Macsyma by line type
codes of the form "[integer]" as a keyword to the plotting command.
See the Macsyma Reference Manual for more information.

Colors of plotted surfaces are controlled from Macsyma by the option
variable COLOR_FUNCTION. 

Macsyma has the following built-in colors.  

    color_red
    color_dark_red
    color_orange
    color_yellow
    color_olive
    color_yellow_green
    color_green
    color_dark_green
    color_cyan
    color_blue_green
    color_blue
    color_dark_blue
    color_magenta
    color_purple
    color_white
    color_gray
    color_black

To make a plotted surface all of one color, say magenta,
set COLOR_FUNCTION: COLOR_MAGENTA before submitting the plot
command.

See also COLOR_CYCLES, COLOR_MIN, COLOR_FUNCTION, COLOR_NORMALIZE.

&COLS(mat, c)

[MATFUNCS package] Returns the submatrix of matrix M consisting of
columns whose indices are specified in the list `c'.

&COLUMNVECTOR(list1)

[EIGEN package] Takes a list list1 as its argument and returns a
column vector the components of which are the elements of the list.
The first element is the first component, etc.  (This is useful if you
want to use parts of the outputs of the functions in this package in
matrix calculations.)

Do LOAD("EIGEN"); to use it.

&COLVECTORP(_input_)

Tests for a column vector.  Must be an empty matrix or a one-column
matrix.  Notice there is no way to DECLARE a variable to be a vector
(or a matrix).  The vector must be explicitly formed.

Do EXAMPLE(COLVECTORP); for an example.

See also VECTORP, ROWVECTORP, MATRIXP, SQUARE_MATRIXP.

&COMBINATION(n, r)

[ALGFUNCS package] Returns the number of combinations of r objects
taken from a population of n objects.  BINOMIAL(n,r) = n!/r!/(n-r)!

See also BINOMIAL.

&COMBINE(exp)

Simplifies the sum exp by combining terms with the same denominator
into a single term.

Do EXAMPLE(COMBINE); for an example.

See also RNCOMBINE.

&COMBINE_PLOTS(list_of_plots, {args})

[FUNCTS Package]  Combines the plots in the list list_of_plots
into one plot.  The plots must be all two dimensional or all
three dimensional.  list_of_plots can contain plot commands or
strings which evaluate to plot commands.

COMBINE_PLOTS is more convenient way to combine plots than the
older graphics switches CLEAR, WAIT, FIRST, SAME and LAST.

Do EXAMPLE(COMBINE_PLOTS); for an example.

&COMMAND

A Macsyma function which performs some operation.  E.g.  INTEGRATE,
DIFF, etc.  DESCRIBE(command) means use the name of a Macsyma command
in place of the word "command", e.g.  DESCRIBE(INTEGRATE); .

&COMMENT

See COMMENTS.

&COMMENTS

Comments in Macsyma text input files are represented as strings
delimited by the symbols /* and */ .  Macsyma does not execute strings
which are contained inside comment delimiters.

/* This is a comment. */

&COMMUTATIVE

If DECLARE(H,COMMUTATIVE); is done, this tells the simplifier that H
is a commutative function.  E.g. H(X,Z,Y) will simplify to H(X, Y, Z).
This is the same as SYMMETRIC.  COMMUTATIVE is a member of
OPPROPERTIES and FEATURES.  It can be asserted with DECLARE, withdrawn
with REMOVE, and detected with FEATUREP.

Do EXAMPLE(COMMUTATIVE); for an example.

&COMPANION(p, x {, C})

[MATRICE package] generates the generalized hypercompanion matrix
associated with the polynomial p when p is taken as a function of x.
If p is factored, then this matrix will be a direct sum of the
hypercompanion matrices associated with each unique factor.  The
resultant matrix has the property that its characteristic polynomial
is p.  If a third argument is provided to COMPANION then a matrice
will be produced (attached to C) instead of a matrix.

Do EXAMPLE(COMPANION); for an example.  See also MATRICE.

&COMPFILE(filespec, f1, f2, ..., fn)

Compiles functions fi into the file filespec. 

See FILES_SUMMARY, FILENAMES, FILE_PATHNAMES for how to specify files
in Macsyma.

See also COMPILE and COMPILE_FILE.

&COMPGRIND default:FALSE

When TRUE function definitions output by COMPFILE are pretty-printed.

&COMPILE(function1, function2, ...)

Compiles the functions.  In implementations where intermediate file
output is necessary to do this compilation, the name of function1 as
the first name of the file that holds the lisp output.

COMPILE(ALL); or COMPILE(FUNCTIONS); will compile all functions.

Do EXAMPLE(COMPILE); for an example.

See also COMPILE_FILE, COMPILE_RULE, TRANSLATE, and TRANSLATE_FILE.

&COMPILE_FILE(inputfile {, outputfile})

Compiles a file of Macsyma code or Lisp code, called inputfile, into a
binary outputfile. If inputfile is a Macsyma code file, Macsyma first
uses TRANSLATE_FILE to translate inputfile from Macsyma code to Lisp
code, then compiles the Lisp code into binary.

If you do not specify outputfile, then Macsyma names the compiled file
INPUTFILE.BIN.

Do EXAMPLE(COMPILE_FILE); for an example.

See also COMPILE.

See FILENAMES and FILE_PATHNAMES for information about how to specify
file pathnames in Macsyma.  See FILES_SUMMARY for more information
about file manipulation commands in Macsyma. 

&COMPILE_RULE('rulename1, 'rulename2, ...)

Compiles the rules with the names rulename1, rulename2, ... as given
by DEFRULE, TELLSIMP, TELLSIMPAFTER or DEFMATCH.  (Rules are
implemented in Macsyma as Lisp functions.)

For example, the first rule modifying F is called FRULE1.  So, to
compile it you would type COMPILE_RULE(FRULE1); .  COMPILE_RULE(ALL);
or COMPILE_RULE(RULES); compiles all the rules on the list RULES.

&COMPILE_RULES_IN_TR_FILES default:TRUE

Controls the automatic compilation of rules in translated files upon
loading.  If it is set to FALSE, rules are not compiled.  In some
versions of Macsyma, especially UNIX Macsymas, this speeds up loading
library files.

&COMPLEMENT(a, b)

Returns the relative complement of a in b, that is, the set of
elements of b which are not in a.

Do USAGE(SET); for more about operations on sets in Macsyma.

Do EXAMPLE(COMPLEMENT); for an example. 

See also SETDIFFERENCE.

&COMPLEX

A complex expression is specified in Macsyma by adding the real part
of the expression to %I times the imaginary part.  Thus the roots of
the equation X^2-4*X+13=0 are 2+3*%I and 2-3*%I.  Note that
simplification of products of complex expressions can be effected by
expanding the product.  Simplification of quotients, roots, and other
functions of complex expressions can usually be accomplished by using
the functions REALPART, IMAGPART, RECTFORM, POLARFORM, ABS, CARG.

Do EXAMPLE(COMPLEX); for an example.

COMPLEX - Property

A symbol can be declared COMPLEX if it is known to represent a complex
number or a function that takes only complex values.  COMPLEX is a
member of the FEATURES list.  It can be asserted with DECLARE,
withdrawn with REMOVE, and detected with FEATUREP.

See also CABS, CARG, REALPART, IMAGPART, RECTFORM, POLARFORM,
CONJUGATE, %IARGS.

&COMPLEX_CIRCLE_FROM_POINTS(z1, z2, z3)

[GEOFUNCS package] Returns [center, radius] of a circle determined by 3
points in 2-space. Each of z1, z2, z3 is a complex number.

Do EXAMPLE(COMPLEX_CIRCLE_FROM_POINTS); for an example.

See also CIRCLE_FROM_POINTS.

&COMPLEX_INTEGRATE default:FALSE

If set to TRUE enables the definite integration of some integrands
that contain %I.

Example:

 (c1) INTEGRATE(1/(X^2+1),X,-1,1);
 (d1)                          %pi/2 

 (c2) INTEGRATE(1/(X-%I)/(X+%I),X,-1,1);
 (d2)                            0 (which is incorrect)  

 (c3) INTEGRATE(1/(X-%I)/(X+%I),X,-1,1), COMPLEX_INTEGRATE:TRUE;
 (d3)                          %pi/2  

COMPLEX_INTEGRATE works by overriding LOGABS:TRUE mode which is 
necessary for doing real integration, which is the usual case for 
definite integration.

Do EXAMPLE(COMPLEX_INTEGRATE); for an example.

&COMPLEX_PLOT3D( z-expr, xvar, xlow, xhigh, yvar, ylow, yhigh {, view})

Plots the possibly complex expression z-expr as a function of the
variables xvar with range [xlow, xhigh] and yvar with range 
[ylow,yhigh].

The optional variable view (default:'RECTFORM) can be one or more of 
- 'RECTFORM - plots the real and imaginary parts of z-expr.
- 'REALPART - plots real part of z-expr.
- 'IMAGPART - plots imaginary part of z-expr.
- 'POLARFORM - plots complex absolute value and argument of z-expr.
- 'CABS      - plots complex absolute value of z-expr.
- 'CARG      - plots complex argument of z-expr.

If more than one of these symbols are included in view, then one plot
is generated for each symbol.

Do EXAMPLE(COMPLEX_PLOT3D); for an example.

&COMPLEXITY(expr)

[MATRICE package] Produces a measure of the complexity of the Macsyma
expression expr.  The result returned is a list of the classification
of expr followed by its complexity within that classification.  The
possible classifications are
 - RATIONAL (rational number or integer),
 - FLOAT (floating point number),
 - BIGFLOAT (extended precision floating point number [bigfloat]),
 - EXPRESSION (expression that is not a simple number).

The corresponding complexities are respectively, the sum of the
absolute value of the numerator plus the denominator of a rational
number (integers are considered to have a denominator of one), the
absolute value of a regular or extended precision floating point
number and the number of operators and atomic operands of a general
expression.

Do EXAMPLE(COMPLEXITY); for an example and DEMO(COMPLEXITY); for a
longer demonstration.

See also NDIGITS and COUNT_OPS.

&COMPONENTS(tens, exp)

[ITENSOR package] Assigns an indicial tensor tens the value exp, which
is an expression built of indicial tensors.  The variable COMPONENTS
stores a list of all symbols for which components have been specified.
Assignments made with COMPONENTS can be removed with REMCOMPS.

&CONCAT(arg1 {, arg2, ...})

Evaluates its arguments and returns the concatenation of their values
resulting in a name or a quoted string the type being given by that of
the first argument.  Thus if X is bound to 1 and D is unbound then
CONCAT(X,2)="12" and CONCAT(D,X+1)=D2.

Do EXAMPLE(CONCAT); for an example.

See also STRING.

&CONDITION_BY_SVD(mat)

Calculates the condition number of the numerical matrix mat as the ratio of
the largest singular value of mat to the smallest. 

Do EXAMPLE(CONDITION_BY_SVD);

See also SVD, SVD_NUMERICAL, SVD_NUMERICAL_REAL, NUMKIT.

&CONJUGATE(X)

Returns the complex conjugate of its argument.

It is represented in display as the postfix operator "*^" 
which can also be used for input.

Do EXAMPLE(CONJUGATE); for an example.

See also COMPLEX.

&CONMETDERIV(exp, tensor)

[ITENSOR package] Simplifies the expression exp which contains
coordinate derivatives of the metric tensor, using Christoffel
symbols.

Do EXAMPLE(CONMETDERIV); for an example.

&CONS(exp, list)

Returns a new list constructed of the element exp as its first
element, followed by the elements of list.  CONS also works on other
expressions besides lists, for example:

 (c1) CONS(X, F(A,B,C));
 (d1)                    f(x,a,b,c).

Do EXAMPLE(CONS); for an example.

See also LISTS.

&CONS_SIZE(expr)

Returns an integer which is the size of expr in "Macsyma cells".
This is the same as the Lisp cons-size of the expression except that
atomic operators ("+", "*", SIN, F, etc.)  count as 1 even if they
take more than one Lisp cell.  (I.e., "SIMP" flags, etc., on the
operators are ignored.)

CONS_SIZE(atom); is 0 .

CONS_SIZE provides a metric for the complexity of expressions.
Since relative complexity is usually what's important here, the 
number CONS_SIZE returns is for the internal representation of the 
expression, for the sake of efficiency.  If the CONS_SIZE of the 
external representation is desired, CONS_SIZE(DISPFORM(expr,'ALL)); 
can be used.

See also COMPLEXITY, COUNT_OPS.

&CONSTANT - Property

Makes an object a constant as is %PI.  If you DECLARE an object
CONSTANT, it is treated specially in certain simplifications. For
example, if A is CONSTANT, and F is linear, F(A*X); => A F(X).
CONSTANT can be removed with REMOVE.  It can be detected with
CONSTANTP.

&CONSTANTFUN - Property

You can declare a function to be a constant.  DECLARE(F,CONSTANTFUN);
means that F(x1,x2,...,xn); is a CONSTANT for all arguments F is
called on.

&CONSTANTP(exp)

If exp is a constant (i.e.  composed of numbers and %PI, %E, %I or any
variables bound to a constant or DECLAREd CONSTANT), then returns
TRUE; else FALSE.  Any function whose arguments are constant is also
considered to be a constant.

Do EXAMPLE(CONSTANTP); for an example.

See also NUMBERP, SCALARP, PREDICATES.

&CONSTFACTOR(exp)

Gives the factors satisfying the CONSTANTP predicate which
(syntactically) multiply the expression exp.  (Returns 1 if exp 
is a sum.)

 (c1) %I*ASIN(2)/2^(N+2)/ZETA(%I)/ZETA(Y);

                                  %i asin(2)
 (d1)                     -----------------------
                                    n + 2
                          zeta(%i) 2      zeta(y)

 (c2) CONSTFACTOR(%);

                                 %i asin(2)
 (d2)                            ----------
                                  zeta(%i)

Do EXAMPLE(CONSTFACTOR); for an example.

See also NUMFACTOR.

&CONSTOP(c)

[OPALG package] returns the constant operator which itself returns
the value c.  When subsequently applied to any number of arguments,
the result is the constant c.

&CONT_FUTURE_VALUE(cash_flow, duration, d_rate {, tvar, quadflag})

[FINANCE package] Returns the future value of the continuous cash_flow
which extends over time duration, with specified discount rate d_rate.

You can specify a symbolic variable tvar which represents time in
the expressions for cash flow and discount rate. 

If you specify the optional variable quadflag, then the present
value is evaluated by numerical integration using the method quadflag.
At this time, the only quadrature method supported are QUADRATR and
ROMBERG.

Do EXAMPLE(CONT_FUTURE_VALUE); for an executable example.

See also CONT_PRESENT_VALUE, DISCRETE_FUTURE_VALUE and USAGE(FINANCE);
for other related functions.

&CONT_PRESENT_VALUE(cash_flow, duration, d_rate {, tvar, quadflag})

[FINANCE package] Returns the present value of the continuous cash_flow
which extends over time duration, with specified discount rate d_rate.

You can specify a symbolic variable tvar which represents time in
the expressions for cash_flow and d_rate. 

If you specify the optional variable quadflag, then the present
value is evaluated by numerical integration using the method 
quadflag. At this time, the only quadrature methods supported are
QUADRATR and ROMBERG.

Do EXAMPLE(CONT_PRESENT_VALUE); for an executable example.

See also CONT_FUTURE_VALUE, DISCRETE_PRESENT_VALUE and USAGE(FINANCE);
for other related functions.

&CONTENT(p1, var1, ..., varn, content_var)

Returns a list whose first element is the greatest common divisor of
the coefficients of the terms of the polynomial p1, in the variable
content_var.  This is the content.  The second element of the list is
the polynomial p1 divided by the content, and RATSIMPed with respect
to the RATVARS var1, ..., varn.  Any other previously declared RATVARS
are ignored.  Example:

 (c1) CONTENT(2*X*Y+4*X^2*Y^2,Y);

 (d1)            [2*x, 2*x*y^2+y].

Do EXAMPLE(CONTENT); for an example.

&CONTEXT default:INITIAL

The name of the current database CONTEXT.  Any symbolic atom can be a
context name.

GENERAL DISCUSSION OF DATABASE CONTEXTS

The context mechanism enables you to collect under one context name
a set of user-assume FACTS, and to turn on or off each named set of
assumed FACTS as a group while simplifying expressions by referring
to the name of the context.

Each database context is a collection of user-assumed FACTS (such as 
ASSUME(X>0)$) which can be turned on or off as a group by referring to
the name of the context.  If the specified context does not exist it
will be created by an invisible call to NEWCONTEXT.  

The current context can changed by assigning its name as the value of
the variable CONTEXT.  When a context is the current context,
 - All assumptions in the current CONTEXT are applied when simplifying
   expressions.  (However, the name of the current context is not
   added to the list ACTIVECONTEXTS.)
 - All new FACTS added with ASSUME (or forgotten with FORGET) are
   added to the current context.
 - The command FACTS(); displays the FACTS in the current context.

A context can be made an active context using the command ACTIVATE
(and can be deactivated with the command DEACTIVATE). When a context
is active,
 - The name of the context is added to the list ACTIVECONTEXTS.
 - All assumptions in the active context(s) are applied when
   simplifying expressions.
 - All new FACTS added with ASSUME or forgotten with FORGET are added
   to the current context, and not to the active context(s).
 - The command FACTS(); displays the FACTS in the current context, and
   not those in the active context(s).  (Note: This can be a source
   of confusion because assumptions in active contexts affect
   simplifications but do not appear on the list FACTS(); .)

Only one context can be the current context at one time, though any
number of contexts can be active at one time.

The facts contained in a context will be retained in storage until 
 - either that context is made the current context and the user
   destroys the FACTS individually by using FORGET,
 - or the user destroys all the FACTS in a context as a group by using
   KILLCONTEXT. (Note:  It is necessary to DEACTIVATE a context before
   removing it with KILLCONTEXT.)

When a fresh Macsyma is started up, the user is in a context called
INITIAL, which has GLOBAL as a subcontext.  Contexts exist in a formal
hierarchy, with the root always being the context GLOBAL, which contains
information which some Macsyma functions need.  Larger contexts can be
defined which contain a smaller context using the command SUPCONTEXT.

Do DEMO(CONTEXTS); for a demonstration of how to define and use various
contexts of user-defined facts, and to switch contexts during a 
computation.

The commands which deal with contexts are: 
 - NEWCONTEXT, CONTEXT, CONTEXTS, SUPCONTEXT, KILLCONTEXT,
 - ACTIVATE, ACTIVECONTEXTS, DEACTIVATE,
 - ASSUME, FACTS, and FORGET.

&CONTEXTS default:[INITIAL,GLOBAL]

Is a list of the contexts which currently exist, including the
currently active context.

Do DEMO(CONTEXTS); for a demonstration of how to define and use various
contexts of user-defined facts, and to switch contexts during a 
computation.

The commands which deal with contexts are: 
 - NEWCONTEXT, CONTEXT, CONTEXTS, SUPCONTEXT, KILLCONTEXT,
 - ACTIVATE, ACTIVECONTEXTS, DEACTIVATE,
 - ASSUME, FACTS, and FORGET.

See CONTEXT for a general description of the context mechanism for
databases.

&CONTINUE

Typing TO_LISP(); while in Macsyma causes LISP to be entered.  The
user can now type any LISP S-expression and have it evaluated.  Typing
(CONTINUE) causes Macsyma to be re-entered.

&CONTINUOUS_MOMENT('expr, order)

[UNIPROB package] Returns moments and generating functions of a number
of continuous probability distributions. expr is the name of the
distribution and it must be preceded by a single quote mark.  order
must be a positive integer.  order=1 returns the mean, and order=2
returns the variance.  Higher moments are moments of
(random_variable-mean)^r.

Do EXAMPLE(CONTINUOUS_MOMENT); for an example.

See also DISCRETE_MOMENT.

&CONTINUOUS_POISSON_DISTRIB(x, lambda)

The cumulative continuous Poisson distribution function, equal
to integrate(poisson_density(z,lambda),z,0,x).

See also POISSON_DENSITY, DISCRETE_POISSON_DISTRIB.

&CONTOUR

A keyword for the PLOT3D command to allow contour plotting.  
The preferred way to generate contourplots is to use the commands
CONTOURPLOT and CONTOURPLOT3D.

&CONTOURPLOT(z_funs, var,low,high, var1,low1,high1 {,'arg1,...,'argn})  

Calculates a contour plot of z_fun in the specified range of the two
independent variables.

The option variables CONTOURS, ZMAX, and ZMIN determine what contours
are displayed.  Changing CONTOURS does not require any more points to
be calculated, so you can change CONTOURS in a Macsyma break, after a
plot, or before using REPLOT.  

The contours are drawn using linear interpolation, so they tend to
look rough, especially near saddle points, unless PLOTNUM0 and
PLOTNUM1 are large.  Since the contour tracking algorithm is quite
smart, all contours are either closed loops, or terminate at the
boundaries of the region.  arg1,..., argn are optional arguments.
Labeling of contours is controlled by LABELCONTOURS.

Do EXAMPLE(CONTOURPLOT); for an example.

See also CONTOURPLOT3D, CONTOURS, LABELCONTOURS, PLOTNUM0, PLOTNUM1,
PLOTNUMPREC, IMPLICIT_PLOT.

See PLOTTING_SUMMARY for a summary of plotting capabilities in
Macsyma.

&CONTOURPLOT3D(z-funs, var-range, var1-range {, arg1, ...,argn})

Creates a contour plot in the same way as CONTOURPLOT, except that the
plot is represented in 3 dimensions instead of compressed into a
plane.  Options for CONTOURPLOT3D are identical for those of
CONTOURPLOT. Labeling of contours is controlled by LABELCONTOURS.

Do EXAMPLE(CONTOURPLOT3D); for an example.

See also IMPLICIT_PLOT.  See PLOTTING_SUMMARY for a summary of
plotting capabilities in Macsyma.

&CONTOURS default:20

If CONTOURS is a positive integer, then CONTOURPLOT plots
approximately CONTOURS contours.  The level values are A * 10^n,
where A = 1,2, or 5 .

If CONTOURS is a negative integer, then ABS(CONTOURS); evenly spaced
contours are drawn.  You may want to set CONTOURLABELS:FALSE to
suppress the printing of long numbers, or reduce the value of
PLOTNUMPREC.

If COUNTOURS is a list of numbers, then those numbers are used as the
level height of the contours.  The numbers in the list can be in any
order.

&CONTRACT(exp)

Obsolete. See ICONTRACT.

&CONTRAGRAD(function, vector)

[CTENSOR package] Computes the contravariant gradient of a scalar
function, and stores the result in the array named vector.

           i                      ji        
     vector  :  function    metric      (sum over j)   
                        ,j

&CONTROL

For a description of the various Control-characters which Macsyma uses
to control computation, see CHARACTERS.

&CONVERT_OBSOLETE_SAVE_FILE(oldsavefile, newsavefile)

Does syntactic conversion of an OLDSAVEFILE, trying to make it
loadable in the latest system.  The output of the conversion is
NEWSAVEFILE.

&CONVERT_TO_DE(exp)

[NDIFF and OPALG packages] Converts expression exp from the new
partial differentiation representation to Macsyma's usual
noun-derivative notation.  Used when results must interact with
code which uses the usual differentiation representation.

&COORD(tensor1 {,..., tensorn})

See ICOORD.

&COPYLIST(L)

Creates a copy of the list L.  Thus,
 - LIST2:COPYLIST(L); results in a new list LIST2 which is distinct
   from the list L, whereas
 - LIST2:LIST1; results in the symbol LIST2 pointing to the same copy
   of the list as the symbol L.

Do EXAMPLE(COPYLIST); for an example.

See also LISTS, COPYMATRIX.

&COPYMATRIX(M)

Creates a copy of the matrix M.  This is the only way to make a copy
aside from recreating M elementwise.  Copying a matrix may be useful
when SETELMX is used.  Thus,
 - MAT2:COPYLIST(M); results in a new matrix MAT2 which is distinct
   from the matrix M, whereas
 - MAT2:M; results in the symbol MAT2 pointing to the same copy
   of the matrix as the symbol M.

Do EXAMPLE(COPYMATRIX); for an example.

See also COPYLIST.  See MATRIX_SUMMARY for a summary of matrix algebra
in Macsyma.

&COPYRIGHT

Do DESCRIBE(TRADE_SECRET); for copyright information.

&COS

Cosine

&COS_INT(x)

Represents Ci(x) = %gamma + log(x) + integrate((cos(t)-1)/t,t,0,x) .

See also EXP_INT.

&COSD

The COS function, except the input argument is in degrees.

&COSFFT(array1, direction)

[FFT package] Computes the Fast Cosine Transform of array1.  The
entries of array1 must be floating point numbers, and the length of
array1 must be a power of two.  direction (either 1 or -1) indicates
whether the transform is from the time domain to the frequency domain
(1) or the other way around (-1).

Do USAGE(FFT); for more information.

Do EXAMPLE(COSFFT); for an example.

See also SINFFT, FFT. See FOURIER_COS_COEFFS for symbolic Fourier cosine
transforms.

&COSH

Hyperbolic Cosine

&COSH_INT(X)

Represents Chi(x) = %gamma + log(x) + integrate((cosh(t)-1)/t,t,0,x) .

See also EXP_INT.

&COT

Cotangent
&COTD

The COT function, except the input argument is in degrees.

&COTH

Hyperbolic Cotangent

&COUNT_ELEMENTS(lis, expr {, pred})

[Functs Package] Returns an integer which is the number of times EXPR
appears as an element of the list LIS. The optional argument PRED
defaults to "=" but can be specified as any predicate of two
arguments.

Do EXAMPLE(COUNT_ELEMENTS); for an executable example.

&COUNT_OPS(expr)

Counts the number of floating point (and other) operations in expr.
The results are returned as a list of lists.  The first elements of
the inner lists are operators (such as +, -, *, /, ^, etc.) and the
second elements are the corresponding number of times these operators
would be applied in expr to compute a numerical value.  Note that "-"
refers to negations, not subtractions, so that x - y is considered to
really be x + (-y).

Do EXAMPLE(COUNT_OPS); for an example.

&COUNTER

[ITENSOR Package] This function has been renamed ICOUNTER.

&COVDIFF(exp, i1, ..., in)

[ITENSOR package] returns the covariant derivative of exp with respect
to the coordinate variables with indices i1,...,in, in terms of the
Christoffel symbols of the second kind (ICHR2).  In order to evaluate
these, one should use EV(exp,ICHR2).

Index conventions are chosen so that the covariant derivative of a
vector is given by

               i               i           i       k
 COVDIFF(vector , j ) =  vector    + ICHR2   vector  .
                               ,j         jk

&COVERS(x)

[ALGFUNCS package] 1-sin(x).

&CPU

See SHOWTIME and STATUS for information about finding the CPU time
for your computation.

&CRE 

Canonical Rational Expressions constitute a kind of representation
which is especially suitable for expanded polynomials and rational
functions (as well as for partially factored polynomials and rational
functions when RATFAC (default:FALSE) is set to TRUE).  In this CRE
form an ordering of variables (from most to least main) is assumed for
each expression.  Polynomials are represented recursively by a list
consisting of the main variable followed by a series of pairs of
expressions, one for each term of the polynomial.  The first member of
each pair is the exponent of the main variable in that term and the
second member is the coefficient of that term which could be a number
or a polynomial in another variable again represented in this form.
Thus the principal part of the CRE form of 3*X^2-1 is (X 2 3 0 -1) and
that of 2*X*Y+X-3 is (Y 1 (X 1 2) 0 (X 1 1 0 -3)) assuming Y is the
main variable, and is (X 1 (Y 1 2 0 1) 0 -3) assuming X is the main
variable. "Main"-ness is usually determined by reverse alphabetical
order.

The "variables" of a CRE expression needn't be atomic.  In fact any
subexpression whose main operator is not + - * / or ^ with integer
power will be considered a "variable" of the expression (in CRE form)
in which it occurs.  For example the CRE variables of the expression
X+SIN(X+1)+2*SQRT(X)+1 are X, SQRT(X), and SIN(X+1).  If the user does
not specify an ordering of variables by using the RATVARS function
Macsyma will choose an alphabetic one.  Integer exponents in CRE
expressions are assumed to be fixnums.

In general, CRE's represent rational expressions, that is, ratios of
polynomials, where the numerator and denominator have no common
factors, and the denominator is positive.  The internal form is
essentially a pair of polynomials (the numerator and denominator)
preceded by the variable ordering list.

If an expression to be displayed is in CRE form or if it contains any
subexpressions in CRE form, the symbol /R/ will follow the line label.
See the RAT function for converting an expression to CRE form, and
RATDISREP for converting from CRE form to general representation.
The function RATP(exp) checks whether an expression is in CRE form.

An extended CRE form is used for the representation of TAYLOR series.
The notion of a rational expression is extended so that the exponents
of the variables can be positive or negative rational numbers rather
than just positive integers and the coefficients can themselves be
rational expressions as described above rather than just polynomials.
These are represented internally by a recursive polynomial form which
is similar to and is a generalization of CRE form, but carries
additional information such as the degree of truncation.

As with CRE form, the symbol /T/ follows the line label of such
expressions.

See also RAT.

&CSC 

Cosecant

&CSCD

The CSC function, except the input argument is in degrees.

&CSCH

Hyperbolic Cosecant

&CSETUP()

[CTENSOR package] A command which can initiate an interactive session
using the CTENSOR package.  CSETUP automatically loads CTENSOR (if it
is not already loaded), then prompts the user to specify the dimension
of the manifold, the names of the coordinates, and a metric tensor.
If the dimension is 2, 3 or 4 then the list of coordinates defaults to
[X,Y], [X,Y,Z] or [X,Y,Z,T] respectively.

The user can enter the metric either interactively, or from a file by
specifying its ordinal position in the file.  As an example of a file
of common metrics, see the file TENSOR;CMETRICS.

A sample CTENSOR session is begun below using the CSETUP function.
A static, spherically symmetric metric (standard coordinates) is
specified (which might lead to a derivation of the Schwarzschild
solution, for example). 

 (c2) CSETUP();
 Enter the dimension of the coordinate system: 
 3;
 Do you wish to change the coordinate names?
 N;
 Do you want to
 1. Enter a new metric?
 2. Enter a metric from a file?
 3. Approximate a metric with a Taylor series?
 Enter 1, 2 or 3 
 1;

 Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4.
 General Answer 1, 2, 3 or 4
 1;

 Row 1 Column 1:  A;

 Row 2 Column 2:  R^2;

 Row 3 Column 3:  R^2*SIN(Y)^2;

 Matrix entered.
 Enter functional dependencies with the DEPENDS function or 'N' if
 none  DEPENDS(A,R);
 Do you wish to see the metric? 
 Y; 
                            [ A  0       0      ]
                            [                   ]
                            [     2             ]
                            [ 0  R       0      ]
                            [                   ]
                            [         2    2    ]
                            [ 0  0   R  SIN (Y) ]

 Do you wish to see the metric inverse? 
 N;

&CSIGN(expr)

Returns the "complex sign" of expr.  That is, if expr is complex,
CSIGN returns COMPLEX, else it returns whatever SIGN(expr) returns.

expr is considered to be complex:
(1) if FEATUREP(expr, 'COMPLEX) returns TRUE, or 
(2) if SIGN determines that expr is complex.

&CSIGNUM(expr) - returns the "complex signum" of expr.  

Definition:

  csignum(z) =  0 if z=0
             =  1 if Re(z)>0 or Re(z)=0 and Im(z)>0
             = -1 if Re(z)<0 or Re(z)=0 and Im(z)<0

That is,
  csignum(z) =  1 if z is in the right half plane or on the 
                   pos. imaginary axis;
             = -1 if z is in the left half plane or on the 
                   the neg. imaginary axis;
             =  0 if z is the origin.

CSIGNUM is a natural extension of SIGNUM to the complex plane.  
For real z, csignum(z) = signum(z) .
For all z (real or complex), sqrt(z^2) = csignum(z)*z .
Also, csignum(-z) = - csignum(z) .

Do EXAMPLE(CSIGNUM); for an example.

&CSIMPLIST default:['FACTOR,'TRIGSIMP,'RATSIMP]

[CTENSOR package] a list of functions which are applied by CTENSIMP
inside many of the functions in the CTENSOR package.

&CT_COORDS default:'CT_COORDS

[CTENSOR package] Stores a list of names of the local coordinates to
be used in CTENSOR (for example CT_COORDS:[X,Y,Z] in three dimensional
Cartesian coordinates).  The coordinates can be redefined with the
assignment CT_COORDS:[j1,j2,...jn] where the j's are the new
coordinate names.  The length of the list CT_COORDS must equal the
dimension of the manifold, as specified by the variable DIM.  A call
to CT_COORDS will return the list of coordinate names.  The function
CSETUP asks the user whether he wants to change the coordinate names.

CT_COORDS was formerly called OMEGA.

&CT_COORDSYS(coordinate_system {, extra_args})

[CTENSOR package] Sets up many common coordinate systems and
user-defined coordinate systems for use with the component tensor
analysis package CTENSOR.  The command assigns values to the CTENSOR
variables
 - DIM, the number of dimensions,
 - CT_COORDS, a list of names of the individual coordinate functions,
 - LG, a matrix which represents the covariant (with lowered indices)
   metric tensor. 

The argument coordinate_system can be of two types.

  - A symbolic name.  For example, the command CT_COORDSYS(SPHERICAL3D)$
    sets up spherical coordinates [r,theta,phi] in 3 dimensions.

  - A list of coordinate transform information, of the form
    [[x1(u1,..,un),...,xn(u1,..,un)],u1,...,un], where u1,..,un are
    the names of the coordinate symbols, and the xi(u1,..,un) express
    the Cartesian coordinate xi in terms of u1,..,un .  For example,
    CT_COORDSYS([[r*cos(phi)*sin(theta),r*sin(phi)*sin(theta),
       r*cos(phi)],r,theta,phi]
    sets up spherical coordinates [r,theta,phi] in 3 dimensions.

Do USAGE(COORDSYS); for a list of pre-defined coordinate systems and
for more information. 

Do EXAMPLE(CT_COORDSYS); for an example and DEMO(COORDSYS); for a
longer demonstration. 

See also VECT_COORDSYS and VECT_ORT, which perform similar functions
for vector calculus using the VECT package.

&CTAYLOR(expr)

[CTENSOR package] Computes a Taylor series representation for the
expression expr, if CTAYSWITCH is TRUE.  The Taylor parameters used by
CTAYLOR are

 - CTAYVAR, the variable (or list of variables) with respect to which
   Taylor series are computed.
 - CTAYPOW, the point (or list of variable values) at which the Taylor
   series is computed.
 - CTAYPT, the highest order term (or list of orders) to be included
   in the Taylor expansion.

&CTENSIMP(expr)

[CTENSOR package] Applies the functions in the list CSIMPLIST to the
expression expr, starting from the first element of the list and
finishing with the last. CTENSIMP appears inside the CTENSOR commands
CHRISTOF, RIEMANN, LRIEMANN, URIEMANN, RICCI, URICCI, EINSTEIN, WEYL,
RINVARIANT, and FRAME_BRACKET.

&CTENSOR

The component tensor computation package.  Component tensor
computation means that the individual components of tensors have
values which are mathematical expressions involving local coordinates
and other variables.  The tensors are represented as arrays or
matrices. Tensor operations like covariant differentiation and index
contraction are carried out at the component level.

CTENSOR autoloads when any of the functions CMETRIC, INIT_CTENSOR, or
CSETUP is invoked (if it is not already loaded).  It can also be loaded
by typing LOAD(CTENSOR);.

Do USAGE(CTENSOR); for more information.

For on-line demonstrations, do
 DEMO(CTENSOR);     General relativity, Schwarzschild solution
 DEMO(CTENSOR1);    Elasticity theory
 DEMO(C2SPHERE);    Riemannian geometry of a 2-sphere
 DEMO(KERR_NEWMAN); General relativity, Kerr-Newman solution
 DEMO(ROB_WALKER);  General relativity, Robertson-Walker cosmology
 DEMO(TENS_PDE);    Fluid mechanics and finite difference generation
 DEMO(COORDSYS);    Generating equations in curvilinear coordinates.

For writing tensor differential equations in specific coordinate
systems, see CT_COORDS.

For related tensor capabilities of Macsyma, see also TENSOR_SUMMARY,
ITENSOR, and ATENSOR.

&CTORSION_FLAG default:FALSE

[CTENSOR package] When TRUE, CTENSOR computes using the affine torsion
tensor stored in the array TR.  The contortion tensor is stored in the
array KT and the modified torsion in the array ST.

To calculate with affine torsion, specify CTORSION_FLAG:TRUE;, then
specify  
 - the dimension of the manifold, DIM,
 - the coordinate list, CT_COORDS,
 - the covariant fiber metric LFG,
 - and the torsion TR.
Then invoke the command CMETRIC(); to initialize the computation.

&CTRANSFORM(tensor_as_matrix, {transforms}) 

[CTENSOR package] This function performs a coordinate transformation
upon an arbitrary two-tensor, represented as a matrix or a two-index
array. 

If some or all of the transforms are not given, then CTRANSFORM
prompts the user for interactive input of the coordinate
transformation functions, and returns the transformed tensor as a
(square) matrix.  

Do EXAMPLE(CTRANSFORM); for an example.

&CURL(exp)

[VECT package] is the curl operator

&CURRENT_LET_RULE_PACKAGE default:DEFAULT_LET_RULE_PACKAGE

The name of the rule package that is presently being used.  The user
may reset this variable to the name of any rule package previously
defined via the LET command.  Whenever any of the functions comprising
the let package are called with no package name, the value of
CURRENT_LET_RULE_PACKAGE is used.  

For example, a command such as LETSIMP(expr,rule_pkg_name); causes the
rule package rule_pkg_name to be used for that LETSIMP command only,
and the value of CURRENT_LET_RULE_PACKAGE is not changed.

See also LET and LETRULES.

&CURSOR default:$

is the prompt symbol of the Macsyma editor.  See also CURSORDISP.

&CURSORDISP default:TRUE

 - If TRUE, causes the displayer to draw expressions in a logical
   sequence.  This only works with a console which can do cursor
   movement.
 - If FALSE, expressions are simply printed line by line. 
   CURSORDISP is FALSE when a WRITEFILE is open for writing.

&CURV_TOL default:0.1

[ADAPLOT package] A single precision floating point number, this is
the maximum allowable change in curve angular direction (in radians)
at a plot point, for large line segments. (The limit can be exceeded
slightly.) The maximum permitted value of dt (or dx) is
4*(t_high-t_low)/plotnum. Normally, CURV_TOL is used to control the
number of plot points.

&CURVATURE

This function has been renamed ICURVATURE.

&CURVSURF(expr, varlist {, arg})

Computes symbolic expressions for the intrinsic (Gaussian) and
extrinsic curvatures of 2-dimensional surfaces embedded in flat
Cartesian 3-dimensional space.

Basic Input
-----------

The embedded surface can be specified in three ways.

1. Surface specified by z=f(x,y), where (x,y,z) are Cartesian
   coordinates.  
   - expr is the expression for z.
   - varlist is a list of two coordinate names, such as [x,y]. 

2. Surface specified parametrically as [x(s,t),y(s,t),z(s,t)],
   where (s,t) are two parameters. 
   - expr is a list of three expressions [x,y,z].
   - varlist is a list of two parameter names, such as [s,t].
   For parametric surfaces, the coordinates need not be 
   Cartesian; however the additional output (discussed below)
   assumes Cartesian coordinates in all cases.

3. Surface specified implicitly as f(x,y,z)=constant.
   - expr is the implicit expression f(x,y,z).
   - varlist is a list of three coordinate names, such as [x,y,z].


Basic Output
------------

CURVSURF returns the value of the intrinsic Gaussian curvature
 of the surface.


Additional Input and Output
---------------------------

In the case when the coordinates are Cartesian, additional
embedding information can be computed for the specified surface.
The optional argument to CURVSURF, arg, can be assigned the value
TRUE or ALL.  

o If arg is TRUE or ALL, then CURVSURF
  - sets the variable SURFNORMAL = 3-vector normal to the surface,
    and displays this value;
  - sets the variable SURFMETRIC equal to the intrinsic metric
    tensor of the surface, and displays this value.

o If arg is ALL, then CURVSURF
  - sets the variable SURFFORM2 = extrinsic curvature tensor
    of the surface (also called the second fundamental curvature
    form), and displays this value;
  - sets the variable SURFMEANCURV equal to the mean extrinsic
   curvature of the surface.

Normally, SURFMETRIC and SURFFORM2 are 2-by-2 matrices which
represent rank 2 tensors on the two-dimensional surface.  In the
case of implicitly defined surfaces, SURFMETRIC and SURFFORM2
become 3-by-3 matrices which represent rank 2 tensors in 3-space,
and both forms are null in the direction of SURFNORMAL.

The mean extrinsic curvature can be derived as the trace of the
matrix SURFMETRIC^^(-1) . SURFFORM2 .  For implicitly defined 
surfaces, the normal direction must be excluded from these matrices
when performing the matrix inversion.

Built-in Simplification
-----------------------

CURVSURF applies simplification functions to intermediate and
final results.  The simplification commands are specified in the
list CURVSURFSIMPS (default:[RATSIMP, TRIGSIMP, ROOTSCONTRACT]).
You can change the option variable CURVSURFSIMPS to be any list
of Macsyma commands or user-defined Macsyma functions.

Do EXAMPLE(CURVSURF); for an executable example and DEMO(CURVSURF);
for a longer demonstration. 

See also SURFACE_NORMAL and UNIT_SURFACE_NORMAL.  See also
COLOR_FUNCTION which enables you to color surfaces by their
curvature.

&DATEPLOT default:FALSE

If TRUE, the date is given at the top right corner of a plot, in a
long form if no title is specified, or in a shorter form if a title is
specified.

&DEACTIVATE(cont1, cont2, ...)

Causes the specified contexts conti to be deactivated.

See CONTEXT for a general description of the context mechanism.

&DEBUG

The option variable DEBUGMODE makes available to the user debugging
features of varying degrees of power and complexity.

See also TOBREAK, TO_LISP, DEBUGMODE, TRACE, TIMER, SETCHECK,
SETCHECKBREAK.

&DEBUGMODE default:FALSE

Controls the kind of break point which Macsyma enters for debugging.
The possible values are:

 - FALSE (the default) - causes Macsyma to return to toplevel when
   a Macsyma error occurs.

 - TRUE - causes Macsyma to enter a Macsyma break loop whenever a
   Macsyma error occurs.

 - ALL - causes Macsyma to enter a Macsyma break loop whenever a
   Macsyma error occurs.  The user may examine BACKTRACE for the
   list of functions currently entered. 

 - LISP - the Lisp debugger will be used instead of the Macsyma
   debugger.  This setting is more powerful and more complicated to
   use.  It is primarily of interest to Macsyma implementors.

See also TOBREAK, TO_LISP, TRACE, TIMER, SETCHECK, SETCHECKBREAK,
BATCH_MAKE_NOTEBOOK.

&DECIBEL(X)

Computes the decibel of X, defined as 10*LOGB(10,x).

&DECLARE(a1, f1, a2, f2, ...)

Gives the atom ai the flag fi.  The ai's and fi's may also be lists of
atoms and flags respectively in which case each of the atoms gets all
of the properties.  The possible flags and their meanings are:

CONSTANT
  Makes ai a constant as is %PI.

MAINVAR
  Makes ai a MAINVAR.  The ordering scale for atoms: numbers
  < constants (e.g. %E,%PI) < scalars < other variables < mainvars.

SCALAR
  Makes ai a scalar.

NONSCALAR
  Makes ai behave as does a list or matrix with respect to
  the dot operator.

NOUN
  Makes the function ai a noun so that it won't be evaluated
  automatically.

EVFUN
  makes ai known to the EV function so that it will get applied
  if its name is mentioned.  Initial evfuns are FACTOR, TRIGEXPAND,
  TRIGREDUCE, BFLOAT, RATSIMP, RATEXPAND, and RADCAN.

EVFLAG
  Makes ai known to the EV function so that it will be bound
  to TRUE during the execution of EV if it is mentioned.  Initial
  evflags are FLOAT, PRED, SIMP, NUMER, DETOUT, EXPONENTIALIZE,
  DEMOIVRE, KEEPFLOAT, LISTARITH, TRIGEXPAND, SIMPSUM, ALGEBRAIC,
  RATALGDENOM, FACTORFLAG, %EMODE, LOGARC, LOGNUMER, RADEXPAND,
  RATSIMPEXPONS, RATMX, RATFAC, INFEVAL, %ENUMER, PROGRAMMODE,
  LOGNEG, LOGABS, LETRAT, HALFANGLES, EXPTISOLATE,
  ISOLATE_WRT_TIMES, SUMEXPAND, CAUCHYSUM, NUMER_PBRANCH, M1PBRANCH,
  DOTSCRULES, and LOGEXPAND.

 The VECT package also adds a group of evflags for simplification of
 vector formulae.

BINDTEST
  Causes ai to signal an error if it ever is used in a
  computation unbound.  DECLARE([var1, var2, ...], BINDTEST) causes
  Macsyma to give an error message whenever any of the vari occur
  unbound in a computation.

Macsyma currently recognizes and uses the following features of
objects: EVEN, ODD, INTEGER, RATIONAL, IRRATIONAL, REAL, IMAGINARY,
and COMPLEX.

The useful features of functions include: INCREASING, DECREASING,
ODDFUN (odd function), EVENFUN (even function), COMMUTATIVE (or
SYMMETRIC), ANTISYMMETRIC, LASSOCIATIVE and RASSOCIATIVE.

DECLARE(F,INCREASING) is in all respects equivalent to
ASSUME(KIND(F,INCREASING)).  The ai and fi may also be lists of
objects or features.  The command FEATUREP(object,feature) may be
used to determine if an object has been DECLAREd to have "feature".  

DECLARE(VAR, SPECIAL) makes the symbol VAR into a global 
variable.

Properties created by DECLARE can be removed by REMOVE.

Do EXAMPLE(DECLARE); for an example.

See also FEATURE.

&DECLARE_DESCRIPTION(topic, string)

Allows you to add online documentation about topics such as new
functions you've defined.  You can then obtain the information using
the commands APROPOS and DESCRIBE.  If string is a string, this sets
things up so that APROPOS will include topic in the list of symbols
which it searches and DESCRIBE(topic) will print the given string.

DECLARE_DESCRIPTION(topic, FALSE)
  Removes the documentation associated with topic.

DECLARE_DESCRIPTION(topic, UNKNOWN)
  Makes APROPOS find the given topic without making you write a
  documentation string.  This is intended primarily for use during
  development work.  Commands or packages being released to other
  users are encouraged to have properly declared documentation
  strings. 

&DECLARE_GAUSSIAN( x1 {, x2, ... xn})

[STOCH package] Gives each of its arguments, which must be atomi
variables previously declared as random variables using RANDOMIZE,
the properties of Gaussian random variables.

&DECLARE_ISYMMETRY(tensor, m, [sym1,..,symn])

[ITENSOR package] Declares symmetry properties of tensor which has m
covariant (lower) and contravariant (upper) indices.  Each of the
expression symi express symmetries, antisymmetries or cyclic symmetries
among tensor indices. 

For example, the rank 5 tensor B can be declared to have symmetries by

   DECLARE_ISYMMETRY( B, 5, [SYM(1,2), ANTI(3,4)] ); .

Then B is
 - symmetric in the first and second covariant indices, 
 - and antisymmetric in the third and fourth covariant indices.

The variable ISYMMETRIES stores a list of all symbols-with-tensor-ranks
which have been assigned indicial tensor symmetry properties with
DECLARE_ISYMMETRY.  Information declared with DECLARE_ISYMMETRY can be
displayed using DISP_ISYMMETRY and removed using REMOVE_ISYMNMETRY.

&DECREASING - Property

A symbol can be declared DECREASING if it is known to represent a
strictly decreasing function.  DECREASING is a member of the FEATURES
list.  It can be asserted with DECLARE, withdrawn with REMOVE, and
detected with FEATUREP.

Do EXAMPLE(DECREASING); for an example. 

&DECSYM(tensor, m, [sym1,..,symn])

Obsolete. See DECLARE_ISYMMETRY.

&DEFAULT_LET_RULE_PACKAGE

The name of the rule package used when one is not explicitly set by
the user with LET or by changing the value of
CURRENT_LET_RULE_PACKAGE. 

&DEFCON(tensor1 {, tensor2, tensor3})

See DEFINE_ICONTRACTION.

&DEFINE(f(x1, ...), body)

Is equivalent to f(x1,...):=''body but when used inside functions the
body is evaluated at execution time rather than at the time of
definition of the function which contains it.

Do EXAMPLE(DEFINE); for an example.

&DEFINE_ICONTRACTION(tensor1 {, tensor2, tensor3})

[ITENSOR package] Gives tensor1 the property that any contraction
(with the appropriate indices) of a product of tensor1 and tensor2
results in tensor3.

If only one argument, tensor1, is given, then any contraction 
(having the appropriate indices) of the product of tensor1 with 
any indexed object (say tensor_obj) will yield an indexed object 
with the name tensor_obj, and with a new set of indices reflecting 
the contractions performed.

For example, if IMETRIC: G, then DEFINE_ICONTRACTION(G) implements
the raising and lowering of indices through contraction with the
metric tensor. 

More than one DEFINE_ICONTRACTION can be given for the same indexed
object; the latest one given which applies in a particular 
contraction will be  used.

ICONTRACTIONS is a list of those indexed objects which have
been given contraction properties with DEFINE_ICONTRACTION. 
Information entered with DEFINE_ICONTRACTION can be displayed
with DISP_ICONTRACTION and removed with REMOVE_ICONTRACTION. 

See also ICONTRACT.

&DEFINE_PHYSICAL_UNITS()

Makes available a number of physical constants for Macsyma
calculations without loading the entire UNITS package.

See also UNITS and PHYSICAL_CONSTANTS.

&DEFINE_VARIABLE(name, default-binding, mode, optional-documentation)

Introduces a global variable into the Macsyma environment.  This is
for user-written packages, which are often translated or compiled.
E.g.: DEFINE_VARIABLE(FOO,TRUE,BOOLEAN);  does the following:
 1) MODE_DECLARE(FOO,BOOLEAN); sets it up for the translator.
 2) If the variable is unbound, it sets it:  FOO:TRUE.
 3) DECLARE(FOO,SPECIAL); declares it special.
 4) Sets up an assign property for it to make sure that it never 
    gets set to a value of the wrong mode.
    E.g.  FOO:44 would be an error once FOO is defined BOOLEAN.

See also MODE_DECLARE for a list of the possible "modes".

The optional 4th argument is a documentation string.  When
TRANSLATE_FILE is used on a package which includes documentation
strings, a second file is output in addition to the LISP file which
will contain the documentation strings, formatted suitably for use in
manuals, usage files, or (for instance) DESCRIBE.

With any variable which has been DEFINE_VARIABLE'd with mode other
than ANY, you can give a VALUE_CHECK property, which is a function of
one argument called on the value the user is trying to set the
variable to.

PUT('G5,LAMBDA([U],IF U#'G5 THEN ERROR("Don't set G5")),'VALUE_CHECK);
Use DEFINE_VARIABLE(G5,'G5,ANY_CHECK, "this ain't supposed to be set
by anyone but me.")

ANY_CHECK is a mode which means the same as ANY, but which keeps
DEFINE_VARIABLE from optimizing away the assign property.

&DEFINT(exp, var, low, high)

DEFinite INTegration, the same as INTEGRATE(exp,var,low,high).

Do EXAMPLE(DEFINT); for an example.  Do DEMO(DEFINT); and
DEMO(DEFINT1); for longer demonstrations.

See also INTANALYSIS, LDEFINT, TLDEFINT, and LAPLACE_CALL.  See 
INTEGRATION_SUMMARY for a summary of integration commands in Macsyma. 

&DEFMATCH(progname, pattern, parm1, ..., parmn)

Creates a function, progname, that tests an expression to see if it
matches pattern.  The pattern is some expression containing pattern
variables and parameters.  The parmi are the formal parameters in the
argument list of progname and are given explicitly as arguments to
DEFMATCH.  The pattern variables (if supplied) were given implicitly
in a previous MATCHDECLARE function.

For example:
 (c1) NONZEROANDFREEOF(X, E):=  IF E#0 AND FREEOF(X, E)
            THEN TRUE ELSE FALSE$

This defines a function to test if the expression E is non-zero and free
of X.  IS(E#0 AND FREEOF(X, E)) is an equivalent function definition for
NONZEROANDFREEOF.

Now, define some pattern variables:  A to match an expression that is
non-zero and free of X and B to match an expression that is free of X:

 (c2) MATCHDECLARE(A, NONZEROANDFREEOF(X), B, FREEOF(X))$

Now, use DEFMATCH to create a function, LINEAR:

 (c3) DEFMATCH(LINEAR, A*X+B, X)$

This function makes use of the pattern variables A and B set up in the
MATCHDECLARE to create a pattern for an expression that is linear in X.
X is the functional argument to LINEAR.

 (c4) LINEAR(3*Z+(Y+1)*Z+Y^2,Z);
                                  2
 (d4)                       [b = y , a = y + 4, x = z]

LINEAR(3*Z+(Y+1)*Z+Y^2,Z); is matched against A*X+B.  B matches Y^2, A
matches Y+4, and X matches Z.

(The built-in Macsyma command LINEAR_MATCH does something similar to
the function LINEAR in the example above.)

If the match is successful, DEFMATCHed functions return a list of
equations whose left sides are the pattern variables and parameters and
whose right sides are the expressions which the pattern variables and
parameters matched.  The pattern variables, but not the parameters,
are set to the matched expressions.  If the match fails, the function
returns FALSE.

Any variables not declared as pattern variables in MATCHDECLARE or as
parameters in DEFMATCH that occur in pattern match only themselves so
that if the third argument to the DEFMATCH in C3 had been omitted, then
LINEAR would only match expressions linear in X, not in any other
variable.

A pattern which contains no parameters or pattern variables returns TRUE
if the match succeeds.  Rules installed by means of DEFMATCH can be
removed with REMOVE.  Rules installed by means of DEFMATCH are added to
the list RULES.

Do EXAMPLE(DEFMATCH); for more examples.

&DEFRULE(rulename, pattern, replacement)

Defines and names a replacement rule for the given pattern.  Sharper
definition of the pattern to be matched is made possible by the
function MATCHDECLARE.  Application of the rule is under explicit
user control, through APPLY1 and related functions.

If the rule named rulename is applied to an expression, every
subexpression matching the pattern will be replaced by the
replacement.  All variables in the replacement which have been
assigned values by the pattern match are assigned those values in the
replacement which is then simplified.  The rules themselves can be
treated as functions which will transform an expression by one
operation of the pattern match and replacement.  If the pattern fails,
the original expression is returned.  Pattern matching rules which are
automatically applied are defined by the commands TELLSIMPAFTER and
TELLSIMP.

Rules created with DEFRULE can be displayed with DISPRULE, and removed
with REMOVE(rulename, RULE); .

Do EXAMPLE(DEFRULE); for an example.

&DEFTAYLOR(function, exp)

Allows the user to define the TAYLOR series (about 0) of an arbitrary
function of one variable as exp which may be a polynomial in that
variable or which may be given implicitly as a power series using the
SUM function.

In order to display the information given to DEFTAYLOR one can use
POWERSERIES(F(X),X,0). 

 (c1) DEFTAYLOR(F(X),X^2+SUM(X^I/(2^I*I!^2),I,4,INF));
 (d1)                          [f]

 (c2) TAYLOR(%E^SQRT(F(X)),X,0,4);

                      2         3          4
                     x    3073 x    12817 x
 (d2)/r/     1 + x + -- + ------- + -------- +  . . .
                     2     18432     307200

Do EXAMPLE(DEFTAYLOR); for an example.

&DELETE(exp1, exp2)

Removes all occurrences of exp1 from exp2.  exp1 may be a term of
exp2 (if it is a sum) or a factor of exp2 (if it is a product).

 (c1)  DELETE(SIN(X),X+SIN(X)+Y);

 (d1)               y + x

DELETE(exp1, exp2, integer) removes the first integer occurrences of
exp1 from exp2.  Of course, if there are fewer than integer
occurrences of exp1 in exp2 then all occurrences will be deleted.

Do EXAMPLE(DELETE); for examples.

&DELFILE(filespec)

Deletes the file given by filespec.

See FILENAMES and FILE_PATHNAMES for information about how to specify
file pathnames in Macsyma.  See FILES_SUMMARY for more information
about file manipulation commands in Macsyma.

&DELINT(expr, var {, lower_limit, upper_limit})

Accepts an expression which may contain a Dirac delta function, expr,
and a variable of integration, var, and returns the indefinite
integral, or the definite integral if limits of integration are
specified.  The delta function is represented by DELTA(var) in expr;
the step function (which results from indefinite integration of
DELTA(var)) is represented by SIGNUM(var)/2.

If there is no delta function in expr whose argument depends on var,
then DELINT calls INTEGRATE.  

Do EXAMPLE(DELINT); for an example and DEMO(DELINT); for a longer
demonstration. 

See also DELTASIMP.

See INTEGRATION_SUMMARY for a summary of integration commands in
Macsyma.

&DELTA(x)

The Dirac delta generalized function.  Currently only DELTASIMP,
FOURIER, LAPLACE, ILT and DELINT know about the DELTA function.

DELTA is the symmetric Dirac delta function which has half its
weight on each side of zero.  However, LAPLACE currently treats
DELTA as having all its weight in the region t>0 . 

Do EXAMPLE(DELTA); for an example.

See also DELTASIMP, DELINT.

&DELTASIMP(expr, x)

[DELINT package] Performs simplifications on the expression expr, if
expr contains Dirac DELTA functions whose arguments depend on the
variable x.  For example,

 (c1) DELTASIMP(DELTA(A*X));
 (d1)                      delta(x)/|a|

Do EXAMPLE(DELTASIMP); for an example.

See also DELINT and SIGNUMSIMP.

&DEMO(file_specification)

Same as BATCH, except that execution pauses after each command line
and continues only when the user tells it to continue, with the
appropriate keyboard or mouse gesture.  Type a space or a carriage
return after each command to tell the demo to proceed.  Type
anything else to terminate the demo.

Do EXAMPLE(DEMO); for an example.

See DEMOS for a list of demonstrations in Macsyma.  To access the
source code for any demo or example file, see UNPACK_TOPIC.

See also EXAMPLE.

See FILENAMES for information about how to specify file pathnames
in Macsyma.  See FILES_SUMMARY for more information about file
manipulation commands in Macsyma.  See FILE_PATHNAMES for the
pathname conventions.

&DEMOIVRE(exp)

Causes %E^(A+B*%I) to become %E^A*(COS(B)+%I*SIN(B)) if B is free of
%I.  A and B are not expanded.

DEMOIVRE default:FALSE

If TRUE will cause %E^(A+B*%I) to become %E^A*(COS(B)+%I*SIN(B)) if B
is free of %I.  A and B are not expanded.  (DEMOIVRE:TRUE; has the 
reverse effect  of EXPONENTIALIZE:TRUE;) 

Do EXAMPLE(DEMOIVRE); for an example.

See also DEMOIVREH, EXPONENTIALIZE and %EMODE.

&DEMOIVREH(exp {, vars})

[ALGFUNCS package] Causes exponential expressions to be expressed in
terms of real or complex hyperbolic trigonometric functions. 
For example,

 (c1) EXP(X)+EXP(-X)
 (d1)                2*cosh(x)
 (c2) EXP(X+%I*Y)
 (d2)        sinh(%i*y+x) + cosh(%i*y+x)

Optional arguments:
 - If one optional arguments VAR are specified, then %I*DUMMY is
   substituted for VAR, DEMOIVRE is called to create circular trig
   functions, and -%I*VAR is substituted for DUMMY.  
 - If several optional arguments are specified, then the process
   for one variable is carried out for each variable in succession.
 - If vars is a list of atomic variables, then substitutions are made
   for all the variables, then DEMOIVRE is applied, then the
   reverse substitutions are made.

Do EXAMPLE(DEMOIVREH); for an example.

See also DEMOIVRE, EXPONENTIALIZE and %EMODE.

&DEMONSTRATION

Macsyma contains over 200 executable demonstrations of library
packages and applications of Macsyma to various problems.  For a list
of available demonstration files, click with you mouse on
HELP | DEMOS .

You can run a Demonstration in several ways:
 - Click on the name of the Demonstration in the list HELP | DEMOS ,
 - Click on the name of the Demonstration when they appear
   in the hypertext descriptions of various topics,
 - Type DEMO(demo_name); .

See also EXAMPLE.

&DEMOS
              MACSYMA DEMONSTRATION FILES

This section is a list of 250 executable demonstrations showing how
to solve various types of problems with Macsyma.  (Macsyma also has
over 750 executable examples to exhibit the proper use of individual
commands.)

    Topic Area                  Description
-----------------     -------------------------------------------
 DEMOS_ARITHMETIC     Demonstrations of different types of numbers

 DEMOS_ALGEBRA        Mathematics based on finite processes only

 DEMOS_LINEAR_ALGEBRA Linear algebra and matrices

 DEMOS_CALCULUS       Limits, differentiation, integration, integral
                      transforms, integral equations, vector
                      and tensor calculus 

 DEMOS_DIFF_EQUATIONS Ordinary and partial differential equations

 DEMOS_ECONOMICS      Cash flows, derivative securities 

 DEMOS_GEOMETRY       Mathematics with parallelism, lengths, angles

 DEMOS_NUMERICAL_ANAL Roots of equations, integration, statistics,
                      least squares, special functions

 DEMOS_PHYSICS        Mechanics, electromagnetism, elasticity, waves,
                      general relativity, quantum mechanics

 DEMOS_PLOTTING       2D and 3D graphics, animation

 DEMOS_UTILITIES      Rule-based pattern matching, facts database,
                      debugging and metering, translation to other
                      languages, and other programming features.

The following demonstrations give an overview of Macsyma.

Demo Name                         Description
----------------       --------------------------------------
 DEMO(BEGIN);          Beginning demonstration
 DEMO(GENERAL);        General demonstration
 DEMO(GENERAL1);       General demonstration
 DEMO(GENERAL2);       General demonstration
 DEMO(GENERAL3);       General demonstration
 DEMO(GENERAL4);       General demonstration

Any demonstration can be launched by clicking on the name of the
demonstration, or by issuing the keyboard command DEMO(demo_name); .

To access the source code for any demo or example file, see 
UNPACK_TOPIC.

&DEMOS_ALGEBRA 

Demo Name                         Description
----------------       --------------------------------------
 DEMO(ALGEBRA);        Introductory demonstration of algebra

Factoring
 DEMO(ALGFAC);         Factoring polynomials
 DEMO(FACEXP);         Finely controlled factoring and expansion
 DEMO(FACTOR);         Basic factoring

Algebraic Equations and Inequalities
 DEMO(ALGSYS);         Solving algebraic equations
 DEMO(EQUATIONS);      Manipulating equations
 DEMO(INEQSIMP);       Manipulation of inequalities
 DEMO(INEQSOL);        Solving linear inequalities
 DEMO(LINSOLVE2);      Solving linear equations
 DEMO(POLSOL);         Find roots of polynomials
 DEMO(SOLVE);          Solve command
 DEMO(SOLVER);         Solver command
 DEMO(SOLVER1);        Deformation of an elastic beam 
 DEMO(SOLVER2);        Two-stage common-emitter transistor amplifier
                       circuit

Sums and Recurrence Equations
 DEMO(DIFFER);         Recurrence equations
 DEMO(NUSUM);          Summation of series
 DEMO(NUSUM1);         Summation of series, more advanced
 DEMO(RECUR);          Recurrence equations
 DEMO(SUM);            The sum command

Groups, Rings and Algebras
 DEMO(ATENSOR);        Tensor algebras
 DEMO(BOSON);          Boson creation/annihilation operators
 DEMO(CARTAN1);        Quaternions, Lie groups
 DEMO(CLIFFORD);       Introduction to Clifford algebras
 DEMO(DOTOPERATOR);    Macsyma's dot multiplication operator
 DEMO(FERMION);        Fermion creation/annihilation operators
 DEMO(SPIN_GROUPS);    Algebra and geometry of spin groups

Logic
 DEMO(BOOLEAN);        Boolean algebra 
 DEMO(IFEXPAND);       Simplification of IF statements
 DEMO(MLTLOGIC);       Truth tables in multivalued logic
 DEMO(MLTLOGIC1);      Tautologies in multivalued logic 
 EXAMPLE(BOOLSIMP);    Simplification of Boolean expressions

Trigonometry
 DEMO(POISSON);        Poisson series
 DEMO(TRIG);           General trigonometry demonstration
 DEMO(TRIG_ANGLES);    Trigonometric functions at special angles
 DEMO(TRIG_EQUATIONS); Trigonometric equations

Miscellaneous Algebra
 DEMO(COMPLEXITY);     Measuring complexity of expressions
 DEMO(FACTORIALS);     Manipulating factorials
 DEMO(FORMAT);         Controlled restructuring of expressions
 DEMO(FORMAT1);        Controlled restructuring of expressions
 DEMO(LRATS);          Lratsubst, Fullratsubst commands 
 DEMO(MULTISMP);       Computing with multilinear functions
 DEMO(OPALG);          Operator algebra
 DEMO(OPERATORS);      User-defined algebraic operators
 DEMO(PERMUTATIONS);   Computing with permutations
 DEMO(RADCAN);         Canonical forms of radical expressions
 DEMO(SET);            Introductory set theory computations
 DEMO(SET1);           Find all equivalence relations on a set
 DEMO(STOPEX);         Controlled expansion of expressions

See TRIG_SUMMARY for an overview of trigonometry in Macsyma.

See ALGEBRA_SUMMARY for an overview of algebra in Macsyma.

For an overview of demonstration topics, see DEMOS.

&DEMOS_ARITHMETIC 

Demo Name                         Description
----------------       --------------------------------------
 DEMO(COMPLEX);        Complex numbers and expressions
 DEMO(CONTFRAC);       Continued fractions
 DEMO(FIBONACCI);      Fibonacci numbers
 DEMO(FLOATNUMS);      Floating point numbers
 DEMO(SQDNST);         Denest radicals

For an overview of demonstration topics, see DEMOS.

&DEMOS_CALCULUS 

Demo Name                         Description
----------------       --------------------------------------
 DEMO(CALCULUS);       Introductory demonstration of calculus

Differential Calculus
 DEMO(CART2CYL);       Coordinate transform: Cartesian to cylindrical
 DEMO(CYL2CART);       Coordinate transform: cylindrical to Cartesian
 DEMO(CYL2SPH);        Coordinate transform: cylindrical to spherical
 DEMO(DIFCALC1);       Introduction to differential calculus
 DEMO(GENDIFF);        Derivatives of order k, k not yet specified
 DEMO(JACOBIAN);       Introduction to Jacobians in integrals
 DEMO(LAGRANGE);       Lagrange multipliers
 DEMO(LIMIT);          Limits of expressions
 DEMO(LIMIT1);         Limits of expressions
 DEMO(LINE_INTEGRALS); Introduction to line integrals
 DEMO(NDIFF);          New differentiation function for partial derivatives
 DEMO(OPTMIZ);         Find stationary points of a function
 DEMO(OPTVAR);         Calculus of variations, mechanics
 DEMO(REVERT);         Revert Taylor Series
 DEMO(TAYLOR);         Taylor series
 DEMO(TAYSOLVE);       Taylor series solutions of equations

Integral Calculus
 DEMO(ANTID);          Integrand with unspecified function
 DEMO(BYPARTS);        Integration by parts
 DEMO(DEFINT);         Definite integration
 DEMO(DEFINT1);        Definite integration
 DEMO(DELINT);         Integrands with Dirac delta functions
 DEMO(ELLIPINT);       Elliptic integrals
 DEMO(EXP_INT);        Exponential integrals
 DEMO(GAMMAINT);       Gamma integrals
 DEMO(INTEGRATE);      General demo of integration
 DEMO(INTEGRATE1);     Indefinite integration
 DEMO(INTXXX);         A challenging definite integral
 DEMO(PSI_INTEGRAL);   Psi and Hurwitz Zeta integrals
 DEMO(RISCH);          Risch integration
 DEMO(ROUGHINT);       Integration
 DEMO(SPECINT);        Some Laplace integrals
 DEMO(ZETAINT);        Zeta integrals

Numerical Integration
 DEMO(BROMBERG);       Romberg integration, bigfloat version
 DEMO(CARLSON);        Elliptic integrals by Carlson's method
 DEMO(CHINTEQN);       A challenging integral equation
 DEMO(QQ);             Newton-Cotes method for integration
 DEMO(QUADRATR);       Extrapolated Gaussian quadrature
 DEMO(RUGKUT);         Runge-Kutta method for numerical solution of ODEs   
 DEMO(ODESTIFF);       Numerical solution of stiff systems of ODEs
 DEMO(MULTIPLE_INTEGRAL);  Multiple integrals with ROMBERG.

See INTEGRATION_SUMMARY for an overview of integration in Macsyma.

Fourier, Laplace and Wavelet Transforms
 DEMO(FFT);            Numerical Fourier transforms
 DEMO(FOURIER);        Fourier transforms and series
 DEMO(FOURIERT);       Fourier transforms
 DEMO(HAARWAVE);       Haar wavelet transform, symbolic computation
 DEMO(LAPLACE);        Laplace transform
 DEMO(ILT);            Inverse Laplace transform
 DEMO(NILT);           Inverse Laplace transform

Vectors and Tensors
 DEMO(ATENSOR);        Tensor algebras
 DEMO(BOSON);          Boson creation/annihilation operators
 DEMO(C2SPHERE);       Riemann geometry of a 2-sphere
 DEMO(CARTAN);         Differential forms
 DEMO(CARTAN1);        Quaternions, Lie groups
 DEMO(CLIFFORD);       Introduction to Clifford algebras
 DEMO(COORDSYS);       Sets up coordinate systems for tensor analysis
 DEMO(CTENSOR);        Schwarzschild solution: black hole
 DEMO(FERMION);        Fermion creation/annihilation operators
 DEMO(ITENSOR);        Indicial tensors, introductory demo
 DEMO(ITENSOR1);       Riemann geometry, basic computations
 DEMO(CONSTANT_CURV);  Riemann geometry, spaces of constant curvature
 DEMO(ITENSOR6);       Metric with dummy indices
 DEMO(ITENSIMP);       Simplification of indicial tensors
 DEMO(IVARY);          Variational derivatives of indicial tensors
 DEMO(IVARY1);         Variation of Maxwell and Einstein Lagrangians
 DEMO(NONMETRIC);      Introduction to nonmetric connections
 DEMO(PFAFF);          Computation of Pfaffians
 DEMO(VECT);           Vector calculus
 DEMO(VECT_CURL);      Tutorial on curl in vector calculus
 DEMO(VECT_DIV);       Tutorial on divergence in vector calculus
 DEMO(VECT_PDE);       Vector PDEs, electrodynamics, finite differences

See TENSOR_SUMMARY for an overview of tensors in Macsyma. 

Stochastic Calculus
 DEMO(STOCH);          Introduction to stochastic variables package
 DEMO(STOCH1);         Stochastic error analysis of RLC circuit
 DEMO(STOCH2);         Stochastic error analysis of measurement
 DEMO(STOCH3);         Optimal discrete filtering of stochastic signal
 DEMO(STOCH4);         Series approximations of stochastic expressions

See CALCULUS_SUMMARY for an overview of calculus in Macsyma.

For an overview of demonstration topics, see DEMOS.

&DEMOS_DIFF_EQUATIONS

Demo Name                         Description
----------------       --------------------------------------
Ordinary Differential Equations - Symbolic Solutions
 DEMO(DYNAMICSYS);     Solve 5th order linear system of ODEs
 DEMO(ODE);            First demo for ODEs
 DEMO(ODE1);           Second demo for ODEs
 DEMO(ODE2);           Simple ODEs
 DEMO(ODEFI);          First order ODEs
 DEMO(ODELIN2);        Second order linear ODEs
 DEMO(ODELINSYS);      Linear systems of ODEs
 DEMO(ODETRIAL);       Simple power series trial solution to ODEs
 DEMO(ODETRIX);        Some exercises in solving linear ODEs
 DEMO(TRAN_MAT);       Control theory, transfer function matrix

Ordinary Differential Equations - Numerical Solutions
 DEMO(ODENSOL);        Numerical solution of (systems of) ODEs
 DEMO(ODENSOL1);       Numerical solution of (systems of) ODEs and 
                          MFE DataViewer and graphics
 DEMO(ODENSOL2);       Numerical solution of (systems of) ODEs with
                          procedures and DataViewer
 DEMO(ODENSOL3);       Numerical Solutions with timing and spline
                          fitting of adaptive solution.
 DEMO(ODENSOL4);       Numerical itegration and phase space plots for
                         a set of equations known to be in 1st order form
 DEMO(ODESTIFF);       Numerical solution of stiff systems of ODEs
 DEMO(RUGKUT);         Runge-Kutta method for numerical solution of ODEs   

Ordinary Differential Equations - Series and Perturbation Solutions
 DEMO(AVG_PODE);       Perturbation theory: periodic averaging for ODEs
 DEMO(LINDST);         Peturbation theory: Lindstedt's method for ODEs
 DEMO(LINDST1);        More Lindstedt's method for ODEs
 DEMO(MSCALES);        Method of multiple scales for ODEs
 DEMO(TAY_ODE);        Taylor series solutions of ODEs

Partial Differential Equations
 DEMO(HEATEQ1);        Generate heat equation in various coordinate systems
 DEMO(PDELIE);         Lie symmetries and solutions: the heat equation 
 DEMO(PL_HEAT);        Lie symmetries and solutions: the heat equation
 DEMO(PL_BLASIUS);     Lie symmetries and solution: the Blasius ODE
 DEMO(PL_KDVPAR);      Lie symmetries/solution: Korteweg-deVries equation
 DEMO(PL_ONE_STEP);    A nonlinear partial differential equation
 DEMO(PL_LAPLACE_3D);  The three-dimensional Laplace equation
 DEMO(PL_NLS);         A nonlinear system of PDEs
 DEMO(QMECH1);         Quantum mechanical equations in various coordinates
 DEMO(TENS_PDE);       Tensor PDEs, fluid mechanics, finite differences
 DEMO(VECT_PDE);       Vector PDEs, electrodynamics, finite differences
 DEMO(FDIF_PDE);       Finite difference generation, small package
 DEMO(FDIFF);          Finite difference generation, larger package

Integral Equations
 DEMO(INTEQN);         Integral equations

For an overview of demonstration topics, see DEMOS.

&DEMOS_ECONOMICS 

Demo Name                         Description
----------------       --------------------------------------
Economics and Finance
 DEMO(CASHFLOW);       Present values and discounted cash flows
 DEMO(ECON1);          Microeconomic model of a consumer
 DEMO(MORTGAGE);       Present values and discounted cash flows
 DEMO(OPTION_PRICE);   Black-Scholes option pricing

For an overview of demonstration topics, see DEMOS.

&DEMOS_GEOMETRY 

Demo Name                         Description
----------------       --------------------------------------
General
 DEMO(COORDSYS);       Sets up coordinate systems for tensor analysis
 DEMO(GEOFUNCS);       Miscellaneous geometry functions
 EXAMPLE(SOLVE_TRIANGLE); Solve for missing parts of a triangle.

Differential Geometry
 DEMO(C2SPHERE);       Riemann geometry of a 2-sphere
 DEMO(CONFORMAL);      Conformal transformations of Euclidean space
 DEMO(CONFORMAL1);     Infinitesimal conformal transformations
 DEMO(CONFORMAL2);     Conformal inversion
 DEMO(CONSTANT_CURV);  Riemann geometry, spaces of constant curvature
 DEMO(CURVSURF);       Extrinsic and intrinsic curvature of surfaces
 DEMO(DEFECTS);        Plots of defects in lattices
 DEMO(GAUSS_BONNET);   Theorem linking curvature and topology
 DEMO(ITENSOR1);       Basic curvature computations in Riemannian geometry
 DEMO(RIEMANN1);       Introduction to Riemannian geometry
 DEMO(RIEMANN2);       Spheres and hyperspheres as Riemannian manifolds
 DEMO(RIEMANN3);       Riemannian manifolds defined by z=f(x,y)
 DEMO(RIEM_CURV1);     Curvature as angular deficit of a disk
 DEMO(RIEM_CURV2);     Curvature as convergence of parallel geodesics
 DEMO(RIEM_CURV3);     Curvature as path-dependence of parallel
                       translation

For an overview of demonstration topics, see DEMOS.

&DEMOS_LINEAR_ALGEBRA

Demo Name                         Description
----------------       --------------------------------------
General
 DEMO(MATRIX);         General matrix demonstration

 DEMO(COMPLEXMAT);     Complex matrices as real matrices
 DEMO(EIGEN);          Find eigenvalues and eigenvectors
 DEMO(MATRIX1);        Modifying matrix operations
 DEMO(MATRIX2);        Block structured matrices
 DEMO(MATRIXTHEORY1);  Introduction to matrix theory
 DEMO(MATRIXTHEORY2);  Introduction to inner products
 DEMO(MATEXP);         Matrix exponentiation
 DEMO(MATSOLVE);       Solve matrix equations
 DEMO(UNITARYMAT);     Unitary matrices as orthogonal matrices

Determinant and Inverse
 DEMO(GENINV);         Generalized matrix inverse
 DEMO(MAT6INVERT);     Invert and display a 6x6 full symbolic matrix
 DEMO(NCHRPL);         Efficient computation of char. polynomials
 DEMO(PFAFF);          Compute Pfaffians

Normal Forms
 DEMO(CHOLESKY);       Cholesky factorization of matrices
 DEMO(JORDAN);         Jordan form
 DEMO(LU);             LU decomposition of matrices
 DEMO(QR);             QR decomposition of matrices
 DEMO(SCHUR);          Schur decomposition of matrices 
 DEMO(SVD);            Singular value decomposition of matrices

Miscellaneous
 DEMO(BANDMAT);        Banded matrix utilities
 EXAMPLE(LP_BY_SIMPLEX); Linear Programming by simplex method
 DEMO(MARKOV2);        Discrete and continuous 2-state Markov processes
 DEMO(MATCONVOLVE);    Matrix convolution operations
 DEMO(MATFUNCS);       More predefined matrix functions
 DEMO(MATLAB);         Translate Matlab function files to Macsyma language
 DEMO(MATRICE);        Demonstration of "matrice" objects
 DEMO(MATRICE1);       Demonstration of "matrice" objects 


See MATRIX_SUMMARY for an overview of matrix algebra in Macsyma.

For an overview of demonstration topics, see DEMOS.

&DEMOS_NUMERICAL_ANAL

Demo Name                         Description
----------------       --------------------------------------
Finding Roots of Equations
 DEMO(BISECT);         Find root by bisection method
 DEMO(MINFUNC);        Find minima of univariate real-valued functions
 DEMO(NEWTON);         Newton's method for solving (simultaneous) equations
 DEMO(SEEKROOT);       Finding simultaneous multiple roots of equations

Numerical Integration
 DEMO(BROMBERG);       Romberg integration, bigfloat version
 DEMO(QQ);             Newton-Cotes method for integration
 DEMO(QUADRATR);       Extrapolated Gaussian quadrature
 DEMO(ODENSOL);        Numerical solution of (systems of) ODEs
 DEMO(ODENSOL1);       Numerical solution of (systems of) ODEs and
                          MFE DataViewer and graphics
 DEMO(ODENSOL2);       Numerical solution of (systems of) ODEs with
                          procedures and DataViewer
 DEMO(RUGKUT);         Runge-Kutta method for numerical solution of ODEs   
 DEMO(ODESTIFF);       Numerical solution of stiff systems of ODEs
 DEMO(MULTIPLE_INTEGRAL);  Multiple integrals with ROMBERG.

Probability and Statistics
 DEMO(BAYES);          Bayesian probability analysis of diagnostic tests
 DEMO(DICE);           Probability Theory: Conway's dice
 DEMO(LSQ);            Linear least squares fitting of curves to data
 DEMO(LSQ1);           Nonlinear least squares fitting of curves to data
 DEMO(MARKOV2);        Discrete and continuous 2-state Markov processes
 DEMO(MULTPROB);       Multivariate probability distributions
 DEMO(STATS);          Statistical functions
 DEMO(STOCH);          Introduction to stochastic variables package
 DEMO(STOCH1);         Stochastic error analysis of RLC circuit
 DEMO(STOCH2);         Stochastic error analysis of measurement
 DEMO(STOCH3);         Optimal discrete filtering of stochastic signal
 DEMO(STOCH4);         Series approximations of stochastic expressions
 DEMO(UNIPROB);        Univariate probability distributions

Special Functions
 DEMO(BESSEL);         Bessel functions
 DEMO(CGAMMA);         Complex gamma function
 DEMO(COMPLEXFUN);     Graphs of complex analytic functions 
 DEMO(FUNCTS);         More predefined functions
 DEMO(HYPER_F);        Hypergeometric functions
 DEMO(LEGENDRE);       Legendre polynomials
 DEMO(ORTHPOLY);       Orthogonality for families of orthogonal polynomials
 DEMO(SPECFUN);        Families of orthogonal functions
 DEMO(ZETA);           The Zeta function

Miscellaneous Numerical Analysis
 DEMO(CHEBDERV);       Chebyshev Approximation to a Derivative
 DEMO(CHEB_ECON);      Chebyshev Economization
 DEMO(CHEBRATA);       Chebyshev approximation using
                       rational functions.
 DEMO(CHEBINT);        Chebyshev approximation of an integral
 DEMO(DIMEN);          Dimensional analysis
 DEMO(FDIF_PDE);       Finite difference generation, small package
 DEMO(FDIFF);          Finite difference generation, larger package
 DEMO(INTERPOL);       Interpolate in numerical tables 
 DEMO(INTERPOL1);      Interpolate in numerical tables using splines
 DEMO(NATURAL_SPLINE); Spline fit to numerical data in 1D and 2D


For an overview of demonstration topics, see DEMOS.

&DEMOS_PHYSICS

Demo Name                         Description
----------------       --------------------------------------
General Physics
 DEMO(BALLISTICS);     Ballistics of cannon ball
 DEMO(BALLISTIC2);     Ballistics of cannon ball with wind
 DEMO(DYNAMICSYS);     Solve fifth order linear dynamic system
 DEMO(NEWTONGRAV);     Introduction to Newtonian gravitation
 DEMO(OSCILLATOR);     General solution of linear oscillator
 DEMO(TENS_PDE);       Fluid mechanics, PDEs, finite differences
 DEMO(UNITS);          Converts physical units of measure to MKS
 DEMO(UNITS1);         Converts physical units of measure to English
 DEMO(UNITS2);         Some units conversion and estimation problems
 DEMO(UNITS3);         Physical quantities and temperatures

Elasticity and Waves
 DEMO(CTENSOR1);       Elasticity, incompatibility tensor
 DEMO(DEFECTS);        Plots of defects in lattices
 DEMO(ITENSOR2);       Elastic strain, using indicial tensors
 DEMO(SOLVER1);        Deformation of an elastic beam 
 DEMO(STRAIN1);        Derive strain tensor in elasticity of solids
 DEMO(STRESS1);        Derive stress tensor in elasticity of solids
 DEMO(STRESTRA);       Stress-strain relations, plane stress, plane strain
 DEMO(STRING1);        Animated model of plucked guitar/violin string
 DEMO(STRING2);        Animated model of plucked damped guitar string

Electromagnetism
 DEMO(MAXWELL);        Maxwell's vector PDEs in various coordinates
 DEMO(SOLVER2);        Two-stage common-emitter transistor amplifier
 DEMO(STOCH1);         Stochastic error analysis of RLC circuit
 DEMO(VECT_PDE);       Maxwell's equations, finite differences

Quantum Mechanics
 DEMO(ANGMOM);         Angular momentum operators and spherical harmonics
 DEMO(ANGMOM1);        Derivation of angular momentum operators
 DEMO(BOSON);          Boson creation/annihilation operators
 DEMO(FERMION);        Fermion creation/annihilation operators
 DEMO(HYDROGEN1);      Schrodinger wave functions for Hydrogen atom 
 DEMO(QMECH1);         Quantum mechanical equations in various coordinates
 DEMO(QMOSCILLATOR);   Quantum mechanical harmonic oscillator
 DEMO(QMPOLAR);        Polar decomposition of Klein-Gordon equation
 DEMO(QMWELL1);        Particle in a 1-dimensional potential well
 DEMO(QMWELL2);        Particle in a 1-D potential well with hill
 DEMO(SPIN_GROUPS);    Algebra and geometry of spin groups
 DEMO(FEYNBOUND);      Asymptotic behavior of Feynman integrals
                       (Not shipped, available on request)

Statistical Mechanics and Thermodynamics
 DEMO(STATFLUID1);     Foundations of statistical fluid mechanics
 DEMO(STATMECH1);      Foundations of statistical mechanics
 DEMO(THERMODYN1);     Foundations of thermodynamics

Special Relativity
 DEMO(SPRELATIVITY);   Derivation of Lorentz transformations

General Relativity
 DEMO(CTENSOR);        Schwarzschild solution: black hole
 DEMO(GENRELATIVITY);  Introduction to general relativity (advanced topic)
 DEMO(ROB_WALKER);     Robertson-Walker cosmological solution
 DEMO(KERR_NEWMAN);    Kerr-Newman solution: charge, rotating black hole
 DEMO(ITENSOR3);       Weak field approx. to Einstein equations
 DEMO(ITENSOR4);       Verify that div(Einstein) = 0
 DEMO(ITENSOR5);       Verify that curvature invariant = 0
 DEMO(IVARY1);         Variation of Maxwell and Einstein Lagrangians
 DEMO(MAGGRAV);        Gravitational field of a strong magnetic field
 DEMO(WORMHOLE);       Morris-Thorne exact wormhole solution

For an overview of demonstration topics, see DEMOS.

&DEMOS_PLOTTING 

Demo Name                         Description
----------------       --------------------------------------
Graphics, 2D
 DEMO(ADAPLOT);        Adaptive density plotting
 DEMO(IMPLICIT_PLOT);  Plot implicit functions
 DEMO(PLOT_VECT);      Plot vector fields in 2D and 3D
 DEMO(PLOT_VECT1);     Plot vector fields from numerical data
 DEMO(PLOTPOLAR);      Polar coordinate plots
 DEMO(PLOT2NUM);       Plot interpolations of 2D numerical data

Graphics, 3D
 DEMO(COLORS);         Control of colors in 3D plots
 DEMO(COMPLEXFUN);     Graphs of complex analytic functions 
 DEMO(DEFECTS);        Plots of defects in lattices
 DEMO(MOBIUS);         Plot and animate a Mobius strip
 DEMO(ORTHCOR3);       Plotting 3D orthogonal coordinate systems
 DEMO(PLOT);           General plotting demonstration
 DEMO(PLOT3D);         Plot functions of x,y in 3D
 DEMO(PLOTSURF);       Plots of parametric surfaces
 DEMO(PLOT_VECT);      Plot vector fields in 2D and 3D
 DEMO(PLOT3NUM);       Plot interpolations of 3D numerical data

Animation
 EXAMPLE(PLOT_ANIMATE); Animated plots

See PLOTTING_SUMMARY for an overview of graphics in Macsyma.

For an overview of demonstration topics, see DEMOS.

&DEMOS_UTILITIES 

Demonstration of features of the Macsyma programming language,
translation to other languages, and other miscellaneous topics.

Demo Name                         Description
----------------       --------------------------------------
Pattern Matching
 DEMO(LETRULES);       "Let" pattern matcher
 EXAMPLE(TELLSIMP);    Automatic pattern matching rules
 EXAMPLE(TELLSIMPAFTER);   "       "       "       "
 EXAMPLE(DEFRULE);     User-applied pattern matching rules

See RULES_SUMMARY for an overview of pattern matching rules in
Macsyma.

Database of Facts
 DEMO(CONTEXTS);       User-defined contexts of assumed facts
 EXAMPLE(ASSUME);      Assuming relational information
 EXAMPLE(DECLARE);     Declaring information about a symbol
 EXAMPLE(PUT);         Defining new types of information about
                       symbols

Macros
 DEMO(BUILDQ);         Building macros
 DEMO(BUILDQ1);        Building macros - advanced
 DEMO(MACRO);          Basic Macro demonstration
 DEMO(MACROEXP);       Macro expansion
 DEMO(SUBMAC);         Substitution macros

Debugging and Metering Tools
 DEMO(TRACE);          The trace debugging tool
 EXAMPLE(SHOWTIME);    Report time required by a command line
 EXAMPLE(TIMER);       Metering time spent inside functions
 EXAMPLE(SETCHECK);    Reporting when a variable is assigned a value
 EXAMPLE(BREAK);       Interrupting a program during execution

Other Language Utilities
 DEMO(ARRAY);          Arrays in Macsyma
 DEMO(BASIC);          List utilities:  prog1, push, pop
 DEMO(DIMIND);         Display of indexed variables
 DEMO(DISOL);          Isolate multiple variables
 DEMO(EVALUATION);     Macsyma's facilities for evaluation
 DEMO(FGGENERAL);      Array functions, gradef
 DEMO(FUNCTIONS);      Macsyma's facilities for function 
 DEMO(LISTS);          Facilities for Lists
 DEMO(LOOKATAT);       Macsyma's  "AT" function
 DEMO(OPERATORS);      User-defined algebraic operators
 DEMO(PASS_OUT);       How to pass values out of functions

Interfaces to Other Languages
 DEMO(GENTRAN);        Generate FORTRAN from Macsyma
 DEMO(GENTRAN2);       Generate FORTRAN from Macsyma, second demo
 DEMO(GENTRANC);       Generate `C' from Macsyma
 DEMO(GENTRANR);       Generate Ratfor from Macsyma
 DEMO(MATLAB);         Translate Matlab function files to Macsyma language
 EXAMPLE(TEX);         Generate TeX from Macsyma

For an overview of demonstration topics, see DEMOS.

&DENEST_SQRT(exp)

Denests SQRTs in the expression exp of simple, numerical, binomial
surds, where possible.

 (c1) DENEST_SQRT((408*SQRT(2)+577)^(1/24));
                                               1/12
 (d1)                         (12 sqrt(2) + 17)

 (c2) DENEST_SQRTS((408*SQRT(2)+577)^(1/24));
                                             1/3
 (d2)                           (sqrt(2) + 1)

Do EXAMPLE(DENEST_SQRT); for examples.

See also DENEST_SQRTS, RADCAN, RADEXPAND, ROOTSCONTRACT, ROOTSCONMODE.

&DENEST_SQRTS(exp)

Sometimes it helps to apply DENEST_SQRT more than once, on an
expression such as (19601-13860 SQRT(2))^(7/4).  The function
DENEST_SQRTS exists for this purpose.  In fact,
DENEST_SQRTS(exp):= INFAPPLY('DENEST_SQRT,exp)$

Do EXAMPLE(DENEST_SQRTS); for examples.

See also DENEST_SQRT.

&DENOM(exp)

Returns the denominator of the rational expression exp.

Do EXAMPLE(DENOM); for an example.

See also NUM, RATDENOM.

&DEPENDENCIES default:[]

The list of atoms which have functional dependencies (set up by
the DEPENDS or GRADEF functions).

&DEPENDS(funlist1, varlist1, funlist2, varlist2,...)

Declares functional dependencies for variables to be used by DIFF.
DEPENDS([F,G],[X,Y],[R,S],[U,V,W],U,T) informs DIFF that F and G
depend on X and Y, that R and S depend on U,V, and W, and that U
depends on T.  The arguments to DEPENDS are evaluated.  The variables
in each funlist are declared to depend on all the variables in the
next varlist.  A funlist can contain the name of an atomic variable or
array.  In the latter case, it is assumed that all the elements of the
array depend on all the variables in the succeeding varlist.
Initially, DIFF(F,X) is 0; executing DEPENDS(F,X) causes future
differentiations of F with respect to X to give dF/dX or Y (if
DERIVABBREV:TRUE).

 (c1) DEPENDS([F,G], [X,Y], [R,S], [U,V,W],U,T);
 (d1)           [f(x, y), g(x, y), r(u, v, w), s(u, v, w), u(t)]

 (c2) DEPENDENCIES;
 (d2)           [f(x, y), g(x, y), r(u, v, w), s(u, v, w), u(t)]
 (c3) DIFF(R.S,U);
                                dr           ds
 (d3)                           -- . s + r . --
                                du           du

Since Macsyma knows the chain rule for symbolic derivatives, it takes
advantage of the given dependencies as follows:

 (c4) DIFF(R.S,T);
                            dr du             ds du
 (d4)                      (-- --) . s + r . (-- --)
                            du dt             du dt
If we set

 (c5) DERIVABBREV:TRUE;
 (d5)                                 true

then re-executing the command C4, we obtain

 (c6) ''C4;
 (d6)                      (r  u ) . s + r . (s  u )
                             u  t              u  t

 - To display dependencies of a variable VAR, use the command
   GETPROP(VAR,DEPENDENCY); .  
 - To eliminate a previously declared dependency, use the command
   REMOVE(VAR,DEPENDENCY); .  For example, to say that R no longer
   depends on U as declared in C1, type REMOVE(R,DEPENDENCY).
   This eliminates all dependencies which have been declared for R.  

 (c7) REMOVE(R,DEPENDENCY);
 (d7)                                 done

 (c8) ''C4;
 (d8)                             r . (s  u )
                                   u    t

NOTE: DIFF and GENDIFF are the only Macsyma commands which use
DEPENDENCIES information.  The arguments to INTEGRATE, LAPLACE etc.
must be given their dependencies explicitly in the command, e.g.,
INTEGRATE(F(X),X).

Do EXAMPLE(DEPENDS); for an example.

&DERIVABBREV default:FALSE

If TRUE will cause derivatives to display as subscripts.

&DERIVATION - OPPROPERTY

A function F that is declared to be a derivation satisfies

  F(u * v) -> F(u) * v + u * F(v)
  F(u . v) -> F(u) . v + u . F(v)

All derivations are declared LINEAR, which means that 

- Derivations are linear with respect to addition and with respect
  to multiplication by constants in their first argument only. 

- Derivations are generalized differential operators.  If the first
  argument is free of the second, then the derivation returns 0 .

Derivations respect the multiplicative operators on the list 
DERIVATION_MULTIPLICATIONS (default:["*", "."]).

Do EXAMPLE(DERIVATION); for an executable example and DEMO(DERIVATION); 
for a longer demonstration.

See also ANTIDERIVATION, LINEAR.

&DERIVDEGREE(exp, dv, iv)

Finds the highest degree of the derivative of the dependent variable
dv with respect to the independent variable iv occurring in exp.

 (c1) 'DIFF(Y,X,2)+'DIFF(Y,Z,3)*2+'DIFF(Y,X)*X^2$
 (c2) DERIVDEGREE(%,Y,X);
 (d2)                           2

Do EXAMPLE(DERIVDEGREE); for an active example.

&DERIVLIST(var1, ..., vark)

Causes only differentiations with respect to the indicated
variables, within the EV command.

&DERIVSUBST default:FALSE

Controls non-syntactic substitutions such as
SUBST(X,'DIFF(Y,T),'DIFF(Y,T,2)); If DERIVSUBST is set to true, this
gives 'DIFF(X,T).

&DESCRIBE(cmd)

Displays information about "cmd", which may be any Macsyma command,
switch or variable.  Other topics and key words can also be DESCRIBEd.
For example, DESCRIBE(TRIG_SUMMARY); shows a summary of the
trigonometric functions and simplifications implemented in Macsyma.
Some function names or operators may require quotation marks around
them, e.g.  DESCRIBE("DO"); or DESCRIBE(".");.

Do EXAMPLE(DESCRIBE); for an example.

See also APROPOS(string), which allows you to locate command names
even if you aren't sure of the full name. 

&DESOLVE

This command has been renamed ODELINSYS.  While DESOLVE still works at
this time, you are encouraged to use ODELINSYS instead.

&DET(M)

An alias for DETERMINANT.

&DET_BY_LU(A)

Computes the determinant of the numerical square matrix A using its
LU factorization.  Also called DETERMINANT_BY_LU.

See also LU_DECOMP, NUMERICAL_MATRIXP, and CNUMERICAL_MATRIXP.

&DETERMINANT(M)

Computes the determinant of M by a method similar to Gaussian
elimination.  The form of the result depends upon the setting of the
switch RATMX.  There is a special routine for dealing with
determinants for sparse matrices which can be used by setting the
switch SPARSE:TRUE.  DETERMINANT has the alias DET.

Do EXAMPLE(DETERMINANT); for an example.

See also NEWDET.

&DETERMINANT_BY_LU(A)

Computes the determinant of the numerical square matrix A using its
LU factorization.  Also called DET_BY_LU.

See also LU_DECOMP, INVERT_BY_LU, NUMERICAL_MATRIXP, and
CNUMERICAL_MATRIXP. 

&DETOUT default:FALSE

If TRUE will cause the determinant of a matrix whose inverse is
computed to be kept outside of the inverse.  For this switch to have
an effect DOALLMXOPS and DOSCMXOPS must be FALSE.  Alternatively this
switch can be given to EV which causes DOALLMXOPS and DOSCMXOPS to be
set to FALSE correctly.

Do EXAMPLE(DETOUT); for an example.

See also ADJOINT.

&DFLOAT(exp)

Converts integers, rational numbers, single-floats, bigfloats and
built-in numerical constants (i.e. %pi, %e, %phi, and %gamma) in exp
to double-floats.  If your machine does not support double-floats,
you'll get single-floats instead.

Do EXAMPLE(DFLOAT); for an example.

See also SFLOAT, BFLOAT.

&DFLOAT_EPSILON

A synonym for DFLOAT_PLUS_EPSILON.

&DFLOAT_MINUS_EPSILON

Returns the smallest positive double floating point number EPS in the
current implementation such that IS(1.d0 - EPS = 1.d0); returns FALSE.

See also DFLOAT_PLUS_EPSILON, SFLOAT_MINUS_EPSILON.

&DFLOAT_PLUS_EPSILON

Returns the smallest positive double floating point number EPS in the
current implementation such that IS(1.d0 + EPS = 1.d0) returns FALSE.

See also DFLOAT_MINUS_EPSILON, SFLOAT_PLUS_EPSILON.

&DFLOATP(exp)

if exp is a dOuble precision floating point number, then returns TRUE,
else FALSE.

See also SFLOATP, BFLOATP, FLOATP, DFLOAT.

&DIAG_MATRIX(a1, ..., ak)

[MATFUNCS package] Returns a diagonal k x k matrix with diagonal
elements a1, ... , ak.

Do EXAMPLE(DIAG_MATRIX); for an example.

See also DIAGMATRIX.

&DIAGMATRIX(n, x)

Returns a diagonal matrix of size n by n with the diagonal elements
all x.  An identity matrix is created by DIAGMATRIX(n,1), or one may
use IDENT(n).

Do EXAMPLE(DIAGMATRIX); for an example.

See also DIAG_MATRIX.

&DIAGMETRIC default:FALSE

[CTENSOR package] If DIAGMETRIC is TRUE special routines compute all
geometrical objects (which contain the metric tensor explicitly) by
taking into consideration the diagonality of the metric.  Reduced run
times will, of course, result.  Note: this option is set by CMETRIC
and CSETUP if a diagonal metric is specified.

&DIFF(exp, v1, n1, v2, n2, ...)

Differentiates exp with respect to each vi, ni times.  If just the
first derivative with respect to one variable is desired then the form
DIFF(exp,v) may be used.  If the noun form of the function is required
(as, for example, when writing a differential equation), 'DIFF should
be used and this will display in a two dimensional format.

DERIVABBREV default:FALSE - if TRUE will cause derivatives to display
as subscripts.

DIFF(exp) gives the "total differential", that is, the sum of the
derivatives of exp with respect to each of its variables times the
function DEL of the variable.  No further simplification of DEL is
offered.

 (c1) DIFF(EXP(F(X)),X,2);
                              2
                       f(x)  d             f(x)  d         2
 (d1)                %e     (--- f(x)) + %e     (-- (f(x)))
                               2                 dx
                             dx

In the indicial tensor package, DIFF(tensor,var); treats var as a
variable which is extrinsic to the manifold.  Use IDIFF(tensor,index);
to perform coordinate derivatives.

When the flag DIFF_CANONICALIZE (default:TRUE) is set to TRUE, partial
derivatives commute.

DIFF - [flag] causes all differentiations indicated in exp to be
performed.

Do EXAMPLE(DIFF); for an example.

See also GENDIFF and PDERIVOP, the partial derivative operator,
and DERIVATION and ANTIDERIVATION.

Other forms of differentiation in Macsyma are included in the ITENSOR
package (IDIFF, COVDIFF, EXTDIFF, and LIEDIFF), and the CARTAN package
for exterior calculus of differential forms.

&DIFF_CANONICALIZE default:TRUE

When TRUE, DIFF and the operator algebra package OPALG assume that
partial derivatives commute.

&DIFF_INTO_EXPECT default:TRUE

[STOCH package] 

 - When TRUE, 'diff(<<expr>>,nonran) is simplified to 
   <<diff(expr,nonran)>>, permitting the differential operator to
   act on the contents of <<...>>. 

 - When FALSE, this simplification is inhibited.  DIFF_INTO_EXPECT
   is bound to FALSE by STOCH_DIFFOUT and STOCH_TAYLOR.

&DIFFER

A library file which solves linear constant-coefficient ordinary
difference equations.  DIFFER can solve both nth-order equations and
first-order systems.  DIFFER can also apply specified initial
conditions to the solution. The main user-level function in the DIFFER
package is DIFFERENCEQ.

Do USAGE(DIFFER); for more information.

Dp DEMO(DIFFER); for a demonstration.

&DIFFERENCE(list {, k})

Kth forward difference of a list.  If a value of k is not input, it
defaults to 1.  When k=1, the jth item on the output list is list[j+1]
- list[j].  The output list has one fewer elements.  The function
MAT_DIFF does the same thing as DIFFERENCE when applied to lists, and
MAT_DIFF is also defined for matrices.  See MAT_DIFF, which acts like
DIFFERENCE on lists, and MAT_DIFF is also defined on matrices.

Do EXAMPLE(DIFFERENCE) for an example.

See also MAT_DIFF and DIFFERENCE_TABLE.

&DIFFERENCE_TABLE(list {, order})

Matrix of forward differences of a list to specified order.  If a
value of order is not input, it defaults to its maximum possible
value, giving LENGTH(list) columns.  The kth difference, padded by
leading zeros, forms the (k+1)th column of the output matrix.

Do example(DIFFERENCE_TABLE) for an example.

See also MAT_DIFF.

&DIFFERENCEQ(equation, nth-term {, initial_conditions})

[DIFFER package] solves linear constant-coefficient ordinary
difference equations.  DIFFERENCEQ can solve both single nth-order 
equations and homogeneous first-order systems.

Arguments:
 - equation    a (list of) difference equation(s)
 - nth_term    a (list of) subscripted variable(s), like F[N]

Initial conditions can be specified in two ways.
 - Set the appropriate term to the desired value, as in:  F[0]:1.
 - Specify them as optional arguments to DIFFERENCEQ, in the form
   of a list of initial conditions of the form F[0]=1.  
The second method of specifying initial conditions is the preferred
method, but the first is retained for compatibility with earlier
versions.

DIFFERENCEQ can also solve homogeneous systems of equations.

Do USAGE(DIFFER); for more information.

Do EXAMPLE(DIFFERENCEQ); for an example and DEMO(DIFFER); for a
longer demonstration.

&DIFFERVERBOSE default:FALSE

[DIFFER package] If TRUE, DIFFERENCEQ displays information about its
arguments as intermediate expressions.

Do EXAMPLE(DIFFERVERBOSE); for an example.  

See also VERBOSE.

&DIFFOP(var1, num1, ..., varn, numn)

[OPALG package] The differentiation operator.  The arguments to DIFFOP
indicate the derivative with respect to each vari numi times. The
option variable DIFF_CANONICALIZE (default: TRUE) determines
whether differentiation operators commute.

&DILOGARITHM

See POLYLOGARITHMS.

&DILOGARITHMS

See POLYLOGARITHMS.

&DILOGS

See POLYLOGARITHMS.

&DIM default:4

[CTENSOR package] DIM is the dimension of the manifold with the
default 4.  The command DIM:N; will reset the dimension to any other
integral value.

&DIMEN

A library package which performs automatic dimensional analysis of
expressions and equations.  

Do USAGE(DIMEN); for more information.

Do DEMO(DIMEN); for a demonstration.

See also DIMEN_LIST_OF_EQUATIONS.

&DIMEN_LIST_OF_EQUATIONS

[DIMEN package] A list of expressions and equations used in the
automatic dimensional analysis package DIMEN.

Do USAGE(DIMEN); for more information.

Do DEMO(DIMEN); for a demonstration.

&DIMENSION(equation or list of equations)

[DIMEN package] Enables the user to over-ride or supplement the
prespecified relations for automatic dimensional analysis. 

Do USAGE(DIMEN); for more information.

See also NONDIMENSIONALIZE.

&DIMIND

This package contains functions to support the display of indexed
expressions of the form:

  'INDEXED(expn, upperindex, lowerindex) or
  'INDEXED(expn, upperindex)  {no lower indices}

where:

  expn = any Macsyma expression,
  upper/lower-index = []      {no indices} or
                      index   {one index} or
                      [index, index, ...]   {one or more indices}
  index = any Macsyma expression except a list, [...]

Indexed objects display like:

                          |N
  'INDEXED(U,N,[I,J]) => U|
                          |I,J

This file contains support functions for the FDIFF finite difference
and analysis package.  This work is described in:  Wirth, Michael C.,
"On the Automation of Computational Physics.", Ph.D. thesis, Davis
School of Applied Science, University of California, September 1980.

Do DEMO(DIMIND); for a demonstration.

&DIRAC_C(arg)

[DIRACMAT package] Returns the 4-by-4 Dirac matrix corresponding to the
symplectic form on 4-spinors (an antisymmetric 2-tensor) with two upper
indices if the sign of arg is positive, and two lower indices if the sign
of arg is negative.

DIRAC_C uses the matrix representation determined by the value of the 
option variable DIRAC_REP.

See also DIRAC_GAMMA, DIRAC_GAMMA1, PAULI_C.

&DIRAC_GAMMA(index1 {, index2, ... indexk})

[DIRACMAT package] Returns the 4-by-4 Dirac matrix corresponding the
product of the Dirac algebra elements
 gamma[index1] @ ... @ gamma[indexk] where "@" means the Clifford
product of the Dirac algebra (matrix multiplication in the matrix
representation).  The metric tensor is assumed to have signature
( + - - - ).

Each indexi specifies the space-time index of a Dirac algebra element. 
Integers in the range [0,1,2,3] specify contravariant space-time 
indices, and integers in the range [0,-1,-2,-3] specify covariant 
space-time indices.

DIRAC_GAMMA uses the matrix representation determined by the value of the 
option variable DIRAC_REP.

Do DEMO(DIRACMAT); and DEMO(DIRACMAT1); for demonstrations.

See also DIRAC_GAMMA1, PAULI_SIGMA.

&DIRAC_GAMMA1(index1 {, index2, ... indexk})

[DIRACMAT package] Returns the Dirac matrix corresponding the
antisymmetrized product of the Dirac algebra elements
 gamma[index1] ^ ... ^ gamma[indexk] where "^" means the antisymmetrized
Clifford product of the Dirac algebra.  The metric tensor is assumed to
have signature ( + - - - ). 

Each indexi specifies the space-time index of a Dirac algebra element. 
Integers in the range [0,1,2,3] specify contravariant space-time indices, 
and integers in the range [0,-1,-2,-3] specify covariant space-time 
indices.

DIRAC_GAMMA1 uses the matrix representation determined by the value of the 
option variable DIRAC_REP.

Do DEMO(DIRACMAT); and DEMO(DIRACMAT1); for demonstrations.

See also DIRAC_GAMMA, PAULI_SIGMA1.

&DIRAC_H(arg)

[DIRACMAT package] Returns the 4-by-4 Dirac matrix corresponding to the
Hermitian form on 4-spinors (a Hermitian 2-tensor) with two upper indices
if the sign of arg is positive, and two lower indices if the sign of arg
is negative.

DIRAC_H uses the matrix representation determined by the value of the 
option variable DIRAC_REP.

See also DIRAC_GAMMA, DIRAC_GAMMA1.

&DIRAC_REP (default: ENERGY_SPIN)

[DIRACMAT package] Determines which matrix representations of the
Dirac algebra with 2-by-2 or 4-by-4 complex matrices to use.  The
allowed values of DIRAC_REP are: 

- 'WEYL_2 - a representation in which Dirac algebra elements map to
  2-by-2 matrices This is not a faithful representation, that is,
  some Dirac elements are mapped to the same matrix.

- 'WEYL_4 - a representation in which even Dirac algebra elements map
  to block diagonal matrices with two 2-by-2 blocks.

- 'ENERGY_SPIN - a representation which polarizes 4-spinors into two 
  positive energy spinors with z-spin up/down and two negative energy 
  spinors with z-spin up/down.

See also DIRAC_GAMMA, DIRAC_GAMMA1, DIRAC_C, DIRAC_H.

&DIRAC

For Dirac delta functions, see DELTA, DELTASIMP, DELINT.

For Dirac algebra, see ATENSOR.

For Dirac matrices and spinors, see USAGE(DIRACMAT).

&DIRACMAT

The DIRACMAT package contains Pauli and Dirac matrices for spinor
computations. 

Do USAGE(DIRACMAT); for more information.

Do DEMO(DIRACMAT); DEMO(DIRACMAT1); and DEMO(DIRAC_EQN); for
demonstrations.

&DISCRETE_ANNUITY(pv, duration, d_rate)

[FINANCE package] Returns the annuity required to generate present
value pv over duration time periods at discount rate d_rate.

Do EXAMPLE(DISCRETE_ANNUITY); for an executable example.

See also USAGE(FINANCE); for related functions.

&DISCRETE_FUTURE_VALUE(cash_flow, duration, d_rate {, g_rate})

[FINANCE package] Returns the future value of the discrete period-
end cash_flow which extends over time duration, with specified
discount rate d_rate.

Either cash_flow or d_rate can be lists, with the same meaning as
list inputs to DISCRETE_PRESENT_VALUE. 

The optional argument g_rate is a growth rate in cash flow for each
period after the first. 

Do EXAMPLE(DISCRETE_FUTURE_VALUE); for an executable example.

See also DISCRETE_PRESENT_VALUE, CONT_FUTURE_VALUE and USAGE(FINANCE);
for other related functions.

&DISCRETE_IRR(cf_list, duration {, guess})

[FINANCE package] Returns the internal rate of return for the cash
flow given by the list cf_list. If the length of cf_list is not
equal to duration, then cf_list is truncated or its last element is
repeated to generate a discrete cash flow with duration periods. 

Do EXAMPLE(DISCRETE_IRR); for an executable example.

See also USAGE(FINANCE); for related functions.

&DISCRETE_MOMENT(expr, order)

[UNIPROB package] This function recalls moments and generating
functions of a number of discrete probability distributions. expr is
the name of the distribution and it must be preceded by a single quote
mark.  order must be a positive integer. order=1 returns the mean,
and order=2 returns the variance. Higher moments are moments of
(random_variable-mean)^r.

Do EXAMPLE(DISCRETE_MOMENT); for an example.

See also CONTINUOUS_MOMENT.

&DISCRETE_POISSON_DISTRIB(x, lambda)

The cumulative discrete Poisson distribution function, equal to
sum(poisson_density(i,lambda),i,0,x).

Do EXAMPLE(DISCRETE_POISSON_DISTRIB); for an example.

See also POISSON_DENSITY, CONTINUOUS_POISSON_DISTRIB.

&DISCRETE_PRESENT_VALUE(cash_flow, duration, d_rate {, g_rate})

[FINANCE package] Returns the present value of the discrete period-
end cash_flow which extends over duration periods, with specified
discount rate d_rate.

If cash_flow is a list, then it specifies the cash flow in each
period.  If the length of the list cash_flow is less than duration,
then the last element of cash_flow is repeated in the remaining
periods.

If d_rate is a list, then it specifies the discount rate for each 
period.  If the length of the list d_rate is less than duration,
then the last element of d_rate is repeated in the remaining
periods.

The optional argument g_rate is a growth rate in cash flow for
each period after the first. 

Do EXAMPLE(DISCRETE_PRESENT_VALUE); for an executable example.

See also DISCRETE_FUTURE_VALUE, CONT_FUTURE_VALUE and USAGE(FINANCE);
for other related functions.

&DISJOINTP(a, b)

If the lists a and b have no common elements, then returns TRUE,
otherwise FALSE.

See also PREDICATES.

&DISOLATE(exp, var1, var2, ..., varN)

[DISOL package] A multi-variable form of the command ISOLATE(exp, var)
which isolates more than one variable simultaneously.  

Do EXAMPLE(DISOLATE); for an example, and DEMO(DISOL); for a longer
demonstration.

See also ISOLATE.

&DISP(expr1 {, expr2, ...})

Displays the value of the expression expri centered in the screen
display.

Do EXAMPLE(DISP); for an example.

See also DISPLAY, DISPTERMS, LDISP, LDISPLAY, PICKAPART, and REVEAL.

&DISP_ICONTRACTION(tensor1 {, tensor2, ...})

[ITENSOR package] Displays the contraction properties of the tensori
which have been specified by DEFINE_ICONTRACTION.  
DISP_ICONTRACTION(ALL); displays all the contraction properties.

&DISP_ISYMMETRY(tensor, m)

[ITENSOR package] Displays symmetries declared by DECLARE_ISYMMETRY
as a list of lists, or returns [] if there are none. The first element
of the inner list is one of the atoms SYM, ANTI, or CYL.  The second
element is a list of lists of the index positions that have this
property in the indices of tensor. 

The list ISYMMETRIES lists all tensor symmetries.

The symmetries are used by ICANFORM and ITENFORM to simplify tensor
expressions.

See also ISYMMETRIES.
 
&DISPCON(tensor1 {, tensor2, ...})

Obsolete. See DISP_ICONTRACTION.

&DISPFLAG default:TRUE

If set to FALSE within a BLOCK will inhibit the display of output
generated by the SOLVE functions when using PROGRAMMODE:FALSE called
from within the BLOCK.  Termination of the command line with a dollar
sign, $, sets DISPFLAG to FALSE.

&DISPFORM(exp)

Returns the external representation of exp (wrt its main operator).
This should be useful in conjunction with PART which also deals with
the external representation.  Suppose EXP is -A .  Then the internal
representation of EXP is "*"(-1,A), while the external representation
is "-"(A).  DISPFORM(exp, ALL) converts the entire expression (not just
the top-level) to external format.

&DISPFUN(f1 {, f2, ...})

Displays the definition of the user defined functions f1, f2, ...
which may also be the names of array associated functions, subscripted
functions, or functions with constant subscripts which are the same as
those used when the functions were defined.  DISPFUN(ALL) will display
all user defined functions as given on the FUNCTIONS and ARRAYS lists
except subscripted functions with constant subscripts.  E.g. if the
user has defined a function F(x), DISPFUN(F); will display the
definition.

Do EXAMPLE(DISPFUN); for an example.

&DISPLAY(expr1, expr2, ...)

Displays equations whose left side is expri unevaluated, and whose
right side is the value of the expression centered on the line.  This
function is useful in blocks and FOR statements in order to have
intermediate results displayed.  The arguments to DISPLAY are usually
atoms, subscripted variables, or function calls.

Examples:

 (c1) DISPLAY(B[1,2]);

                                      2
                         b     = x - x
                          1, 2

 (d1)                            done

Do EXAMPLE(DISPLAY); for an example.

See also DISP, DISPTERMS, LDISP, LDISPLAY, PICKAPART, and REVEAL.

&DISPLAY_CASE default:REVERSE_CASE

Controls the case of Macsyma output display.  There are four possible
settings: REVERSE_CASE, LOWER_CASE, UPPER_CASE and INITIAL_CAPS.

 - REVERSE_CASE causes all Macsyma output symbols to appear in lower
   case, except that any  symbol preceded by a backslash "\" has its
   case reversed.

 - LOWERCASE causes all Macsyma output symbols to appear in lower
   case letters.

 - UPPER_CASE causes all Macsyma output symbols to appear in upper
   case letters.

 - INITIAL_CAPS causes Macsyma output symbols to appear with the 
   first letters (and the first letters after each underscore "_")
   to appear in upper case, and all other letters to appear in
   lower case.

UPPER_CASE is the only setting that actually supports mixed case
output, for example, when you type ALIAS(\e,%E); .
    
DISPLAY_CASE affects display only.  It cannot affect linearizations
(for example the output of STRING or MEDIT or the linearized parts of
mouse presentations) because these  objects may be used for further
machine processing which could be broken if you modify their case.

Do EXAMPLE(DISPLAY_CASE); for an example.

See also DISPLAY2D, FANCY_DISPLAY.

&DISPLAY_FORMAT_INTERNAL default:FALSE

If set to TRUE will cause expressions to be displayed without being
transformed in ways that hide the internal mathematical
representation.  The display then corresponds to what the INPART
command returns rather than the PART command.  Examples:

User     PART       INPART

a-b;      A - B     A + (- 1) B

           A            - 1
a/b;       -         A B
           B
                       1/2
sqrt(x);   SQRT(X)    X

          4 X        4
X*4/3;    ---        - X
           3         3

&DISPLAY_TEX default:FALSE

If set to TRUE will cause all display output lines (d-lines) to appear
in TeX form on the screen, instead of appearing in normal
2-dimensional output form.

Other possible values for DISPLAY_TEX are: 
 - TEX which is the same as TRUE, and
 - LATEX which means that LATEX code is produced instead of TEX.

Starting from an ASCII text batch file with comments, DISPLAY_TEX can
be used to generate documents in which the Macsyma comments appear as
ASCII text, the math input commands appear with their c-line labels,
and the math output lines are in TeX form.  Here's how:
 - Set DISPLAY_TEX: FALSE.
 - Load the batch file in as an unexecuted notebook, using
   o either the menu command File | Make Notebook
   o or the keyboard command MAKE_NOTEBOOK.
 - Set DISPLAY_TEX: TRUE or LATEX.
 - Select the input commands which you want to execute.  You can
   select all input with the menu command Edit | Select | Input.
 - Execute the input commands using the menu command
   Edit | Reexecute.
 - Save the notebook as an ASCII text file using the menu command
   File | Save As | Filename.TXT .

Do EXAMPLE(DISPLAY_TEX); for an example.

See also TEX and LATEX.

&DISPLAY2D default:TRUE

If set to FALSE will cause the standard display to be a string
(1-dimensional) form rather than a display (2-dimensional) form.  This
may be of benefit for users on printing consoles who would like to
conserve paper.

See also DISPLAY_CASE, FANCY_DISPLAY, FANCY_FONT_NAME,
FANCY_FONT_SIZE, FANCY_WIDTH, FANCY_WRITEFILE.

&DISPRULE(rulename1 {, rulename2, ...})

Displays rules with the names rulename1, rulename2, which were defined
and named by DEFRULE, TELLSIMP, TELLSIMPAFTER or by DEFMATCH. For
example, the first rule modifying SIN will be called SINRULE1.
DISPRULE(ALL); will display all rules.

See also RULES.

&DISPSYM(tensor, m)

See DISP_ISYMMETRY. 

&DISPTERMS(expr)

Displays its argument in parts one below the other.  That is, first
the operator of 'expr' is displayed, then each term in a sum, or
factor in a product, or part of a more general expression is displayed
separately.  This is useful if expr is too large to be otherwise
displayed.  For example if P1, P2, ...  are very large expressions
then the display program may run out of storage space in trying to
display P1+P2+...  all at once.  However, DISPTERMS(P1+P2+...) will
display P1, then below it P2, etc.  When not using DISPTERMS, if an
exponential expression is too wide to be displayed as A^B it will
appear as EXPT(A,B) (or as NCEXPT(A,B) in the case of A^^B).

Do EXAMPLE(DISPTERMS); for an example.

See also REVEAL.

&DISTANCE2_COORDSYS( point1, point2 {, coordsys} )

[GEOFUNCS package] Computes the squared distance between point1
and point2 in the coordinate system coordsys.

Input:

 - point1 is a list of the coordinate values of a point.

 - point2 is a list of the same length as point1.

 - coordsys is the name of a coordinate system which is known
   to the VECT_ORT package.  If coordsys is not specified,
   then Cartesian coordinates are assumed, and the length of
   the lists point1 and point2 specify the dimension of the
   space. The coordinates are given in the same order as in
   the VECT_ORT package.

Do EXAMPLE(DISTANCE2_COORDSYS); for an executable example.

&DISTINCT_ROOTS(rootlist {, root_tol})

Accepts a list of numbers or equations and tries to eliminate
near-duplicate points. rootlist can be either 
- a list of lists of numbers,
- a list of lists of equations var=number. 
When rootlist contains equations, the left hand sides of the 
equations are repeated in the output but otherwise are ignored
by DISTINCT_ROOTS.

root_tol (optional, default:100*float_plus_epsilon) specifies
the distance within which two roots are considered to be 
identical.

Do EXAMPLE(DISTINCT_ROOTS); for an example.

&DISTRIB(exp)

Distributes sums over products.  It differs from EXPAND in that it
works at only the top level of an expression, i.e. it doesn't recurse
and it is faster than EXPAND.  It differs from MULTTHRU in that it
expands all sums at that level.  For example,


 DISTRIB((A+B)*(C+D))        ->  A C + A D + B C + B D 
 MULTTHRU ((A+B)*(C+D))      ->  (A + B) C + (A + B) D

 DISTRIB (1/((A+B)*(C+D)))   ->  1/ ((A+B) *(C+D))
 EXPAND(1/((A+B)*(C+D)),1,0) ->  1/(A C + A D + B C + B D)

Do EXAMPLE(DISTRIB); for an example.

See also EXPAND, MULTTHRU.

&DIV(exp)

[VECT package] The divergence operator.

&DIVIDE(p1, p2, var1, ..., varn)

Computes the quotient and remainder of the polynomial p1 divided by
the polynomial p2, in a main polynomial variable, varn.  The other
variables are as in the RATVARS function.  The result is a list whose
first element is the quotient and whose second element is the
remainder.

 (c1) DIVIDE(X+Y,X-Y,X);
 (d1)                        [1, 2 y]

 (c2) DIVIDE(X+Y,X-Y);
 (d2)                      [ - 1, 2 x]

(Note that Y is the main variable in C2.)

Do EXAMPLE(DIVIDE); for an example.

&DIVISORS(n)

[ALGFUNCS package] Returns a list of the divisors of the positive
integer n.

Do EXAMPLE(DIVISORS); for an example.

&DIVSUM(n, k)

Adds up all the factors of n raised to the kth power.
If only one argument is given then k is assumed to be 1.

Do EXAMPLE(DIVSUM); for an example.

&DO

The DO statement is used for performing iteration.  Its usual form is
analogous to that used in several other programming languages; DO in
Macsyma also has other features.

There are three variants of the usual DO statement which differ only in
their terminating conditions.  They are:

 - FOR variable : initial-value STEP increment THRU limit DO body
 - FOR variable : initial-value STEP increment WHILE condition DO body
 - FOR variable : initial-value STEP increment UNLESS condition DO body

(Alternatively, the STEP may be given after the termination condition or
limit.)

The initial-value, increment, limit, and body can be any expressions.
If the increment is 1 then "STEP 1" may be omitted.

do USAGE("DO"); for more discussion of standard forms and special
capabilities of DO in Macsyma.

Do EXAMPLE("DO"); for an example.

&DO_EXPECT(expr)

[STOCH package] Activates nounified forms of <<...>> so that they
carry out further self-simplification which has become possible as
a result of other transformations of the expression or definition
of new moments by SET_MOMENT.  The effect is similar to 
                         EV(expr, "<<"); 
except that DO_EXPECT causes the application of <<...>> even in 
forms which are not evaluated,  such as the first argument of 'SUM.

&DOALLMXOPS default:TRUE

If TRUE all operations relating to matrices are carried out.  If it is
FALSE then the setting of individual switches govern which operations
are performed. These switches are DOMXEXPT, DOMXMXOPS, DOMXNCTIMES,
DOSCMXOPS, DOSCMXPLUS.

Do EXAMPLE(DOALLMXOPS); for an example.

&DOCUMENTATION 

The main pieces of hardcopy documentation which come with Macsyma are:

 - The Macsyma User's Guide: a volume of annotated examples and
   practice problems which help users take the next steps.  This
   volume covers only a small portion of Macsyma (but the most
   commonly used parts).
 - The Macsyma Mathematics and System Reference Manual: A definitive
   description of the user-level mathematical and system commands in
   Macsyma.
 - The Macsyma Graphics and User Interface Reference Manual: A
   definitive description of user-level graphics commands and options
   in Macsyma, and a description of the Macsyma Front End Notebook
   software.
 - Release Notes: document the changes in each version of Macsyma
   since the last Reference Manual was published; and other
   version-specific information.
 - Installation Guide: describes how to install Macsyma.

Various other books about the use of Macsyma are available.

For information about hardcopy documentation, write to:
   Macsyma Inc.
   20 Academy Street
   Suite 201
   Arlington, MA 02476
   tel: 1-800-macsyma (1-800-622-7962)
   email: info@macsyma.com
   URL:  http://www.macsyma.com

&DOMAIN default:REAL

If set to COMPLEX, SQRT(X^2) will remain SQRT(X^2) instead of
returning ABS(X).  The notion of a "domain" of simplification is still
in its infancy, and controls little more than this at the moment.

&DOMXEXPT default:TRUE

If DOALLMXOPS:FALSE, then this switch controls whether elementwise
exponentiation of matrices is expanded.

 - If TRUE, then
   %E^MATRIX([1,2],[3,4]); -> MATRIX([%E,%E^2],[%E^3,%E^4])
   MATRIX([1,2],[3,4])^2;  -> MATRIX([1,4],[9,16])

 - If FALSE, then these transformations are inhibited.

In general, this transformation affects expressions of the form
<base>^<power> where <base> is an expression assumed scalar or
constant, and <power> is a list or matrix.

Do EXAMPLE(DOMXEXPT); For an example.

See also DOALLMXOPS.

&DOMXMXOPS default:TRUE

If DOALLMXOPS:FALSE, then this switch controls whether matrix-matrix
operations are performed.

 - If TRUE then all matrix-matrix or matrix-list operations are
   carried out (but not scalar-matrix operations).

 - If FALSE, then they are not carried out.

Do EXAMPLE(DOMXMXOPS); For an example.

See also DOALLMXOPS.

&DOMXNCTIMES default:FALSE

If DOALLMXOPS:FALSE and DOMXMXOPS:FALSE, then this switch controls
whether matrix multiplications are expanded.

 - If TRUE then matrix multiplications are carried out.

 - If FALSE, then they are not carried out.

Do EXAMPLE(DOMXNCTIMES); For an example.

See also DOALLMXOPS.

&DONTFACTOR default:[]

May be set to a list of variables with respect to which factoring is
not to occur.  (It is initially empty).  Factoring also will not take
place with respect to any variables which are less important (using
the variable ordering assumed for CRE form) than those on the
DONTFACTOR list.

Do EXAMPLE(DONTFACTOR); For an example.

&DOSCMXOPS default:FALSE

If DOALLMXOPS:FALSE, then this switch controls whether scalar-matrix
operations are expanded.

 - If TRUE, then scalar-matrix operations are performed.

 - If FALSE, then they are not carried out.

Do EXAMPLE(DOSCMXOPS); For an example.

See also DOALLMXOPS.

&DOSCMXPLUS default:FALSE

If DOALLMXOPS:FALSE, then this switch controls whether scalar-matrix
operations are expanded.

 - If TRUE, then SCALAR + MATRIX gives a matrix answer.  

 - If FALSE, then SCALAR + MATRIX is not reduced to a matrix.

Do EXAMPLE(DOSCMXPLUS); for an example.

See also DOALLMXOPS.

&DOT - "."

The dot operator, for matrix (non-commutative) multiplication.  When
"." is used in this way, spaces should be left on both sides of it,
as in  A . B .  This distinguishes it plainly from a decimal point
in a floating point number.

The option variables which control behavior of the DOT operator are:
DOT0NSCSIMP, DOT0SIMP, DOT1SIMP, DOTASSOC, DOTCONSTRULES, DOTDISTRIB,
DOTEXPTSIMP, DOTIDENT, DOTSCRULES, SKEW_DOT_MULT.

Do USAGE(DOTOPERATOR); for more information, and DEMO(DOTOPERATOR); for
a demonstration.

See also ATENSOR, a package which implements tensor algebras using the
dot operator.

&DOT0NSCSIMP default:TRUE

Causes a non-commutative product of zero and a nonscalar term to be
simplified to a commutative product.  Note that this transformation
also occurs automatically when DOTCONSTRULES (default:TRUE) or
DOT0SIMP (default:TRUE) is TRUE.

&DOT0SIMP default:TRUE

Causes a non-commutative product of zero and a scalar term to be
simplified to a commutative product.  Note that this transformation
also occurs automatically when DOTCONSTRULES (default:TRUE) is TRUE.

&DOT1SIMP default:TRUE

Causes a non-commutative product of one and another term to be
simplified to a commutative product.  Note that this transformation
also occurs automatically when DOTCONSTRULES (default:TRUE) is TRUE.

&DOTASSOC default:TRUE

When TRUE causes (A . B) . C to simplify to A . (B . C)  .

&DOTCONSTRULES default:TRUE

Causes a non-commutative product of a constant and another term to be
simplified to a commutative product.  Turning on this flag effectively
turns on DOT0SIMP, DOT0NSCSIMP, and DOT1SIMP as well.

&DOTDISTRIB default:FALSE

If TRUE will cause A . (B+C) to simplify to A . B + A . C .

&DOTEXPTSIMP default:TRUE

When TRUE causes A . A to simplify to A^^2 .

&DOTIDENT default:1

The value to be returned by X^^0 .

&DOTSCRULES default:FALSE

When TRUE will cause the following simplifications.

   Input       Simplifies to
 ---------     -------------
  A . SC        SC*A
  SC . A        SC*A
 A . (SC*B)     SC*(A . B)

Do EXAMPLE(DOTSCRULES); for an example.

&DOUBLE_EXPONENTIAL_DENSITY(x, alpha, beta)

[UNIPROB package] The density function
   1/(2*beta) *exp (-abs(x-alpha)/beta)) .

This is a synonym for the LAPLACE_DENSITY.

&DOUBLE_EXPONENTIAL_DISTRIB(x, alpha, beta)

[UNIPROB package] The cumulative distribution function for the
DOUBLE_EXPONENTIAL_DENSITY.  This is a synonym for the
LAPLACE_DISTRIB.

&DPART(exp, n1, ..., nk)

Selects the same subexpression as PART, but instead of just returning
that subexpression as its value, it returns the whole expression with
the selected subexpression displayed inside a box.  The box is
actually part of the expression.

 (c1) DPART(X+Y/Z^2,1,2,1);

                        y
 (d1)                  ---- + x
                          2
                      *****
                      * z *
                      *****

Do EXAMPLE(DPART); for an example.

See also BOX, LPART, REMBOX.

&DSCALAR(function)

[CTENSOR package] Applies the scalar d'Alembertian to the scalar
function.

 (c41) DEPENDENCIES(FIELD(R));
 (d41)                           [field(r)]

 (c42) DSCALAR(FIELD);

 (d43)
     -m
   %e  ((field  n - field  m + 2 field   ) r + 4 field )
              r  r       r  r         r r             r
 - -----------------------------------------------------
                              2 r

&DT_FACTOR default:4.0

[ADAPLOT package] A single precision floating point number, this
represents the factor by which curvature tolerance increases for
shorter curve segments. Raising DT_FACTOR makes the curvature
tolerance larger for short line segments, while leaving the tolerance
unchanged for the longest line permissible segments.

&DT_RATE default:2.0

[ADAPLOT package] A single precision floating point number which must
be greater than 1.0, this is the maximum factor by which step size can
be increased or decreased in one iteration at a plot point.

&DT_RATIO default:40.0

[ADAPLOT package] A single precision floating point number, this is
the ratio of largest to smallest permissible step size between plot
points. This is used to control the minimum size limit for line
segments.

&DUMMY

[ITENSOR Package]  This function has been renamed IDUMMY.

&DUMMYX

[ITENSOR Package]  This function has been renamed IDUMMYX.

&DUPE(e, n)

[MATRICE package] creates a list containing n copies of the item e.
For example, DUPE(e, 3) => [e, e, e].

&E

The base of natural logarithms, e, is represented in Macsyma as %E.

&ECHELON(M)

Produces the echelon form of the matrix M.  That is, M with elementary
row operations performed on it such that the first non-zero element in
each row in the resulting matrix is a one and the column elements
under the first one in each row are all zero.

                         [2  1 - a  -5 b ]
 (d2)                    [               ]
                         [a    b      c  ]

 (c3) ECHELON(D2);

                  [      a - 1        5 b      ]
                  [1   - -----      - ---      ]
                  [        2           2       ]
 (d3)             [                            ]
                  [                2 c + 5 a b ]
                  [0     1         ------------]
                  [                       2    ]
                  [                2 b + a  - a]

Do EXAMPLE(ECHELON); for an example.

&EDIT()

(Macsyma 419 and successors only) Enters the Macsyma editor.
EDIT(thing) enters the editor and edits THING.  If THING is a string
or list, it is taken as a filename.  If THING is a symbol, it is taken
as the name of a function to edit.  This latter feature (editing a
particular function) is not fully implemented.

&EDITOR

There is a line editor in Macsyma, which you may enter by calling the
MEDIT function.  The text editors in Windows systems are now normally
used for editing commands strings instead of the Macsyma editor.

Commands are terminated by two dollarsigns.  An additional two 
dollarsigns will return you to Macsyma and evaluate the expression.

Some useful commands:

Command         Action
-------         ______
nC              moves the cursor past n characters.
nR              moves the cursor past n characters in the
                 reverse direction (nR = -nC).

nSstring$       moves the cursor to the right (left if n is
                 negative) of the nth occurrence of "string" in
                 the input string.

(  and  )       moves the cursor left (right) from the current
                 position over the next balanced pair of parentheses
                 (or brackets).

[  and ]       same as (  and  ).

nD              deletes n characters, and saves them in the
                 "save-register" (see the GR command below).

nK              deletes all the characters through the nth carriage return
                 (0K kills left), and saves them in the "save-register";
                 e.g., K deletes the remainder of this line.

Istring$        inserts the characters "string" at the current cursor
                 position.  The cursor is positioned at the right of
                 the inserted text.  If no argument is given then the
                 string of the last I command which had one is used.

GR              inserts at the current cursor position the characters
                 deleted by the last use of D or K.  Thus GR may be used
                 in combination with D or K to move characters from one
                 place to another in the input string; or to recover
                 from an accidental use of D or K.  There is only one
                 "save-register".

&EIGEN

The library package EIGEN contains functions for computing eigenvalues
and eigenvectors and related matrix computations.  EIGEN autoloads
when either one of the commands EIGENVALUES or EIGENVECTORS are
invoked.  Otherwise, do LOAD(EIGEN); to access the package.

Do USAGE(EIGEN); for more information.
Do DEMO(EIGEN); for a demonstration.

&EIGENMETHOD default:SOLVE

[MATRICE package] Specifies the method EIGENVALUES will use to
determine the roots of a characteristic polynomial.  

 - If EIGENMETHOD is the atomic value SOLVE then characteristic
   polynomial roots will be solved for using the Macsyma function
   SOLVE.
 - Otherwise, the value of EIGENMETHOD will be taken to be the name of
   a factoring operator (e.g., FACTOR, GFACTOR) and only those factors
   that are linear with respect to this operator will have their roots
   solved for, while higher degree irreducible factors will be
   consolidated into the residual polynomial.

Do DEMO(EIGEN); for a demonstration.  See also MEIGENVALUES.

&EIGENS_BY_JACOBI(mat)

Computes the eigenvalues and eigenvectors of a real, symmetric matrix
mat by successive Jacobi transformations.  The matrix is assumed to
have no more than EIGENVALUES_BY_JACOBI_NMAX rows or columns.

EIGENS_BY_JACOBI returns a list whose elements are of
 - a list of eigenvalues;
 - a list of corresponding normalized eigenvectors;
 - the number of Jacobi rotations used.

A matrix whose columns are the corresponding normalized 
eigenvectors is returned in JACOBI_MATRIX.

Do EXAMPLE(EIGENS_BY_JACOBI); for an example. 

See also EIGENVALUES_BY_JACOBI_NMAX, EIGENVALUES_BY_SCHUR, 
EIGENS_BY_SCHUR.

&EIGENS_BY_SCHUR(A {, mode})

Returns a list of eigenvalues and eigenvectors of the matrix A.
Schur decomposition via EIGENVALUES_BY_SCHUR is used to identify
eigenvalues. mode (default:'single) is a flag used to control
whether the calculation proceeds in 'single, 'double or 'bfloat
precision. In some cases, EIGENS_BY_SCHUR may not be able to identify
all eigenvectors corresponding to repeated eigenvalues. However these
cases are unlikely to occur in practice.

EIGENS_BY_SCHUR returns a list whose elements are
 - a list of eigenvalues;
 - a matrix whose columns are the corresponding normalized
    right eigenvectors
 - the number Schur iterations used.

A matrix of the corresponding eigenvectors is returned in schur_matrix.

Do EXAMPLE(EIGENS_BY_SCHUR); for an example.

For complex floating point matrices, do USAGE(NUMKIT);

For left eigenvectors, do USAGE(NUMKIT);

See also EIGENVALUES_BY_SCHUR, BFEIGENVALUES_BY_SCHUR, EIGENVECTORS,
EIGENS_BY_JACOBI.

&EIGENS_BY_SCHUR_REAL(A, {,mode})

Version of EIGENS_BY_SCHUR that works with real matrices only.

See  EIGENS_BY_SCHUR.

&EIGENVALUES(mat)

[EIGEN package] Computes the eigenvalues of the matrix mat and returns
as its value a list containing two sublists.  
 - The first sublist specifies the eigenvalues determined.
 - The second sublist contains their corresponding multiplicities.

If the characteristic polynomial of the matrix mat is not completely
factorable, then the list of multiplicities will be followed by the
residual polynomial that results from removing the solvable factors
from the characteristic polynomial.  The residual polynomial will be
expressed in terms of the global variable MCHARPOLY_VAR.  EIGENVALUES
by default uses SOLVE to find the roots of the characteristic
polynomial and so deficiencies in SOLVE can affect the results
returned by this function.  For example, SOLVE can generate very messy
eigenvalues in some cases.  You may want to simplify the answers
yourself before you go on and assign the results to KNOWNEIGVALS.
SOLVE can also return a not-so-obviously real expression for an
eigenvalue which is supposed to be real.

Do EXAMPLE(EIGENVALUES); for an example and DEMO(EIGEN); for a longer
demonstration.  

See also EIGENMETHOD, NUMEIGS and MEIGENVALUES, EIGENVALUES_BY_JACOBI,
EIGENVALUES_BY_SCHUR.

&EIGENVALUES_BY_JACOBI_NMAX  default:1000

Maximum size of the matrix allowed for EIGENS_BY_JACOBI.

See also  EIGENS_BY_JACOBI.

&EIGENVALUES_BY_SCHUR(A {, mode})

Returns a list of the numerical eigenvalues of the numerical
matrix A. Schur decomposition of an arbitrary square real matrix A is
performed using an accelerated QR algorithm. mode (default:'single)
is a flag that controls whether the calculation proceeds in 'single or
'double precision.

The option variable SCHUR_QR_ITERATES (default:30) controls the
maximum number of QR iterations performed for each eigenvalue.

After executing EIGENVALUES_BY_SCHUR, 
 - SCHUR_TOTAL_ITERATES is the total number of QR steps used.
 - SCHUR_FORM contains the numerically derived Schur form of
   the matrix A, if SCHUR_FORM_FLAG is TRUE.

The value of EIGENVALUES_BY_SCHUR_FLAG indicates convergence.  If 0,
convergence is successful.  If it is equal to N, the maximum number of QR
iterations has been exceeded for the Nth eigenvalue.
                             
Do EXAMPLE(EIGENVALUES_BY_SCHUR); for an example.

For complex floating point matrices, do USAGE(NUMKIT);

See also SCHUR_FORM, BFEIGENVALUES_BY_SCHUR, EIGENS_BY_SCHUR,
EIGENS_BY_JACOBI.

&EIGENVECTORS(mat)

[EIGEN package] Computes the eigenvalues and corresponding
eigenvectors of the matrix mat.  

EIGENVECTORS returns a list of the form
[[e_1, m_1, [v_11, v_12, ...]], [e_2, m_2, [v_21, v_22, ...]], ...],
where
 -  e_i is the ith distinct eigenvalue,
 -  m_i is its corresponding multiplicity and
 -  v_ij are the eigenvectors that correspond to e_i (presented as
lists).

In some cases, EIGENVECTORS may be unable to determine the
eigenvectors corresponding to a particular eigenvalue, in which case
the list of eigenvectors for that eigenvalue will be empty.
EIGENVECTORS calls EIGENVALUES so if EIGENVALUES produced a residual
polynomial, EIGENVECTORS will return as the last sublist of its output
an item of the form [Roots_of(residual_polynomial, variable), 1, []],
indicating that the roots of this residual polynomial with respect to
the variable will produce the remainder of the eigenvalues for the
_matrix_.

Do EXAMPLE(EIGENVECTORS); for an example and DEMO(EIGEN); for a
longer demonstration.  

See also NONDIAGONALIZABLE, HERMITIANMATRIX, KNOWNEIGVALS, LISTEIGVALS,
UNITEIGENVECTORS, EIGENS_BY_JACOBI, EIGENS_BY_SCHUR.

&EIGENVECTORS_BY_SCHUR(matrix {, mode})

See EIGENS_BY_SCHUR.

&EIGHTH(exp)

Returns the eighth part of exp.  It is affected by INFLAG, in the same
way as FIRST.

&EIGPOLYLIST

[JORDAN_FORM package] is a list that contains the invariant factor
information for a matrix M after JORDAN_FORM(M) has been called. It is
used by JORDAN_SIMTRAN.

&EINSTEIN(dis)

[CTENSOR package] Computes the mixed Einstein tensor, and stores it in
the array EIN[i,j], where "i" is a covariant (lower) index and "j" is
a contravariant (upper) index.  EINSTEIN uses the mixed Ricci tensor
stored in the array URIC (or causes URIC to be computed by URICCI if
it is not present).

If the argument dis is TRUE, then the non-zero values of the mixed
Einstein tensor EIN[i,j] will be displayed.

If RATEINSTEIN:TRUE (default:TRUE), then EINSTEIN will perform
rational simplification on the components of EIN.

If RATFAC:TRUE (default:FALSE), then the components will also be
factored.  

See also LEINSTEIN, RIEMANN, LRIEMANN, URIEMANN, RICCI, URICCI,
SCURVATURE, WEYL. 

&ELEVENTH

There is no ELEVENTH function, Macsyma only has ten fingers.

&ELIMINATE([eq1,eq2,...,eqn], [v1,v2,...,vk])

Eliminates variables from equations (or expressions assumed equal to
zero) by taking successive resultants.  This returns a list of n-k
expressions with the k variables v1,...,vk eliminated.  First v1 is
eliminated yielding n-1 expressions, then v2 is, etc.  If k=n then a
single expression in a list is returned free of the variables
v1,...,vk.  In this case SOLVE is called to solve the last resultant
for the last variable.

Example:

 (c1) EXP1:2*X^2+Y*X+Z;

                                     2
 (d1)                   z + x y + 2 x

 (c2) EXP2:3*X+5*Y-Z-1;

 (d2)                - z + 5 y + 3 x - 1

 (c3) EXP3:Z^2+X-Y^2+5;

                        2    2
 (d3)                  z  - y  + x + 5

 (c4) ELIMINATE([EXP3,EXP2,EXP1], [Y,Z]);

             8         7         6          5          4
 (d3) [7425 x  - 1170 x  + 1299 x  + 12076 x  + 22887 x

                                3         2
                        - 5154 x  - 1291 x  + 7688 x + 15376]

Do EXAMPLE(ELIMINATE); for an example.

See also MATRIX_ELIMINATE.

&ELLIPTIC

See ELLIPTIC_INTEGRALS and JACOBIAN_ELLIPTIC_FUNCTIONS.

&ELLIPTIC_E(PHI, M)

Incomplete elliptic integral of second kind.  It is defined as

  E(phi|m) = integrate(sqrt(1-m*sin(th)^2),th,0,phi) 
           = integrate(sqrt(1-m*t^2)/sqrt(1-t^2),t,0,sin(phi)) .

See ELLIPTIC_INTEGRALS for related commands.

See also ELLIPTIC_E_BY_CARLSON.

&ELLIPTIC_EC(M)

Complete elliptic integral of second kind.  It is defined as

  E(m) = ELLIPTIC_E(%pi/2,m) .

See ELLIPTIC_INTEGRALS for related commands.

&ELLIPTIC_E_BY_CARLSON(PHI, M)

Evaluates the elliptic function ELLIPTIC_E(PHI,M) using Carlson's
elliptic integrals.

Do DEMO(CARLSON); for a demonstration of all the Carlson elliptic
integrals.

See also ELLIPTIC_E, ELLIPTIC_F, ELLIPTIC_PI, EP_ERRTOL, CARLSON_R_C, 
JACOBI_AM_BY_CARLSON, CARLSON_R_D, CARLSON_R_F, and CARLSON_R_J.

&ELLIPTIC_F(PHI, M)

Incomplete elliptic integral of first kind.  It is defined as

  F(phi|m) = integrate(1/sqrt(1-m*sin(th)^2),th,0,phi) 
           = integrate(1/sqrt((1-t^2)*(1-m*t^2)),t,0,sin(phi)) .

See ELLIPTIC_INTEGRALS for related commands.

See also ELLIPTIC_F_BY_CARLSON.

&ELLIPTIC_F_BY_CARLSON(PHI, M)

Evaluates the elliptic function ELLIPTIC_F(PHI,M) using Carlson's
elliptic integrals.

Do DEMO(CARLSON); for a demonstration of all the Carlson elliptic
integrals.

See also ELLIPTIC_E, ELLIPTIC_F, ELLIPTIC_PI, EP_ERRTOL, CARLSON_R_C, 
JACOBI_AM_BY_CARLSON, CARLSON_R_D, CARLSON_R_F, and CARLSON_R_J.

&ELLIPTIC_INTEGRALS

Macsyma contains routines for the numerical evaluation,
simplification, differentiation, etc. of ELLIPTIC_INTEGRALS.  
The ELLIPTIC_INTEGRALS available are:

 - ELLIPTIC_KC(Mod) - Complete elliptic integral of the first kind.
 - ELLIPTIC_EC(Mod) - Complete elliptic integral of the second kind.
 - ELLIPTIC_F(Phi,Mod) - Incomplete elliptic integral of the first kind.
 - ELLIPTIC_E(Phi,Mod) - Incomplete elliptic integral of the
   second kind. 
 - ELLIPTIC_PI(Characteristic,Phi,Mod) - Incomplete elliptic integral 
   of the third kind. 
 
In these functions, the argument Mod satisfies 0<=Mod<1 .  (Notation
of Abramowitz and Stegun, Chapters 16 and 17.  Also see Gradshteyn
and Ryzhik (GR), Table of Integrals, Series, and Products).

ELLIPTIC_KC(1/2), ELLIPTIC_EC(1/2), and several other similar 
entities can be expressed in terms of GAMMA functions by just 
calling MAKEGAMMA on them.

Macsyma also evaluates numerically Carlson's elliptic integrals

 - ELLIPTIC_F_BY_CARSON(PHI,M) - Incomplete elliptic integrals
   of the first kind using Carlson's elliptic integrals.
 - ELLIPTIC_E_BY_CARSON(PHI,M) - Incomplete elliptic integrals
   of the second kind using Carlson's elliptic integrals.
 - ELLIPTIC_PI_BY_CARSON(N,PHI,M) - Incomplete elliptic integrals
   of the third kind using Carlson's elliptic integrals.
 - JACOBI_AM_BY_CARLSON(U,M) - See JACOBI_AM.

See also CARLSON_R_C, EP_ERRTOL, CARLSON_R_D, CARLSON_R_F, CARLSON_R_J.

Do DEMO(CARLSON); for a demonstration.

Macsyma also computes symbolic derivatives of the elliptic integral
functions.

Do DEMO(ELLIPINT); for a demonstration.

See also JACOBIAN_ELLIPTIC_FUNCTIONS.

&ELLIPTIC_KC(M)

Complete elliptic integral of first kind.  It is defined as 

  K(m) = ELLIPTIC_F(%pi/2,m) .

See ELLIPTIC_INTEGRALS for related commands.

&ELLIPTIC_PI(N, PHI, M)

Incomplete elliptic integral of third kind.  It is defined as

  Pi(n; phi|m) 
    = integrate(1/((1-n*sin(th)^2)*sqrt(1-m*sin(th)^2)),th,0,phi)
    = integrate(1/((1-n*t^2)*sqrt((1-t^2)*(1-m*t^2))),t,0,sin(phi)) .

See ELLIPTIC_INTEGRALS for related commands.

See also ELLIPTIC_PI_BY_CARLSON.

&ELLIPTIC_PI_BY_CARLSON(N, PHI, M)

Evaluates the elliptic integral of the third kind using Carlson's 
elliptic integrals.

Do DEMO(CARLSON); for a demonstration of all the Carlson elliptic 
integrals.

See also ELLIPTIC_E, ELLIPTIC_F, ELLIPTIC_PI, EP_ERRTOL, CARLSON_R_C, 
JACOBI_AM_BY_CARLSON, CARLSON_R_D, CARLSON_R_F, and CARLSON_R_J.

&EMATRIX(m, n, x, i, j)

Will create an m by n matrix all of whose elements are zero except for
the i,j element which is x.

Do EXAMPLE(EMATRIX); for an example.

&ENABLE_MORE_PROCESSING default:TRUE

(Symbolics Lisp machine only) Turns "more processing" on and off.

&ENDCONS(exp, _list_)

Returns a new list consisting of the elements of the list _list_ followed
by exp. ENDCONS also works on general expressions, for example:

 (c1) ENDCONS(X,F(A,B,C));

 (d1)                     f(a,b,c,x)

Do EXAMPLE(ENDCONS); for an example.

&ENTERMATRIX(m, n)

Prompts the user to enter a matrix interactively element by element
with Macsyma requesting values for each of the m*n entries.

 (c1) ENTERMATRIX(3,3);

 Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4.
 General Answer 1, 2, 3 or 4
 1;

 Row 1 Column 1:  A;

 Row 2 Column 2:  B;

 Row 3 Column 3:  C;

 Matrix entered.
                                  [ a  0  0 ]
                                  [         ]
 (d1)                             [ 0  b  0 ]
                                  [         ]
                                  [ 0  0  c ]

Do EXAMPLE(ENTERMATRIX); for an example.

&ENTERTENSOR(name)

[ITENSOR package] Prompts the user to build a tensor interactively,
with any number of algebraic and derivative indices.

&ENTIER(X)

A synonym for FLOOR(X).

&EP_ERRTOL default:1.d-4

Error tolerance used by Carlson elliptic integrals.

See CARLSON_R_C, CARLSON_R_D, CARLSON_R_F and CARLSON_R_J.

&EQUAL(expr1, expr2)

Returns TRUE (or FALSE) if and only if expr1 and expr2 are equal (or
not equal) for all possible values of their variables as determined by
RATSIMP and Macsyma's data base inferencing mechanisms.  EQUAL is often
used with an "IS".  For example:

 IS(EQUAL((X+1)^2,X^2+2*X+1)) returns TRUE 
 if X is unbound, then
 IS((X+1)^2=X^2+2*X+1)        returns FALSE

 IS(EQUAL(RAT(0),0))          returns TRUE
 IS(RAT(0)=0)                 returns FALSE

If a determination can't be made by EQUAL, then EQUAL will signal an
error, whereas = always returns TRUE or FALSE.  All variables
occurring in exp are presumed to be real valued.  EV(exp, PRED) is
equivalent to IS(exp).

 (c1) ASSUME(X>=0, X<=0)$

 (c2) IS(EQUAL(X,0));
 (d2)                               true

 (c3) ASSUME(A>=B, B>=C, C>=A)$

 (c4) IS(EQUAL(A,C));
 (d4)                               true

 (c5) IS(EQUAL(0,0.0));
 (d5)                               true

Do EXAMPLE(EQUAL); for an example.

See also EQUALP, IS, "=", NOTEQUAL.

&EQUALP(expr1, expr2)

[FOURIER package] Returns TRUE if IS(EQUAL(expr1,expr2)) is TRUE and
FALSE otherwise. However, EQUALP does not signal error in cases when
EQUAL would.

See also EQUAL, IS, "=" .

&EQUALSCALE default:FALSE

If this option variable is set to TRUE, plotting commands ensure that
the physical distance scales are the same in both directions.  Thus if
the window is rectangular, and EQUALSCALE is FALSE, a circle appears
as an ellipse, whereas with EQUALSCALE:TRUE it appears as a circle.

Do EXAMPLE(EQUALSCALE); for an example.

&EQUATIONP(x)

Returns TRUE if and only if x is an equation.  Otherwise,
it returns FALSE.  For example, EQUATIONP(x=y) returns TRUE.

See also PREDICATES.

&ERF(X)

The error function, whose derivative is  2*EXP(-X^2)/SQRT(%PI). 

Do EXAMPLE(ERF); for an example.

See also ERFC, WERF, INV_ERF.  See SPECIAL_FUNCTIONS for a summary of
special functions in Macsyma.

&ERFC(X)

erfc(x) = 1 - erf(x) .

Do EXAMPLE(ERFC); for an example.

See also ERF.  See SPECIAL_FUNCTIONS for a summary of special 
functions in Macsyma.

&ERFFLAG default:TRUE

If FALSE, then RISCH cannot introduce the ERF function into an
answer if there were none in the integrand to begin with.

&ERRCATCH(exp1 {, exp2, ...})

Evaluates its arguments one by one and returns a list of the value of
the last one if no error occurs.  If an error occurs in the evaluation
of any argument, ERRCATCH "catches" the error and immediately returns
[] (the empty list).

This function is useful in BATCH files where one suspects an error
might occur which would otherwise have terminated the BATCH if the
error weren't caught.

Do EXAMPLE(ERRCATCH); for an example.

See also ERROR, CATCH, THROW.

&ERREXP default:ERREXP

When an error occurs in the course of a computation, Macsyma prints
out an error message and terminates the computation.  ERREXP is set to
the offending expression and the message "ERREXP contains the
offending expression" is printed.  The user can then type ERREXP; to
see this expression, which may help to diagnose the problem.

&ERRINTSCE default:TRUE

Suppose that the first argument to the INTSCE routine is not of the
form

  EXP(A*X+B)*COS(C*X)^N*SIN(C*X)^M

If ERRINTSCE is TRUE, then the regular integration program will be
invoked.  If it is FALSE, then INTSCE will err out.

&ERROR(arg1 {, arg2, ...})

Will evaluate and print its arguments and then will cause an error
return to top level Macsyma or to the nearest enclosing ERRCATCH.
This is useful for breaking out of nested functions if an error
condition is detected.

The variable ERROR is obsolete. 

See also ERROR_STRING, ERROR_LIST, ERREXP, ERRCATCH, ERRORFUN,
ERROR_SIZE.

&ERROR_LIST default:[No error.]

This system variable contains the most recent error message in its raw
form as a Macsyma list, first the error message text with its embedded
format directives, followed by the arguments to the format statement.

&ERROR_SIZE default:10

Controls the size of the expression that is printed in an error
message.  The size is given in CONS_SIZE, or the number of cells the
expression takes up.  For example, let U:(C^D^E+B+A)/(COS(X-1)+1); .
U has an error size of 24.  So if ERROR_SIZE has value < 24 then

 (c1) ERROR("The function", FOO,"doesn't like", U,"as input.");

prints as:

 The function FOO doesn't like ERREXP1 as input.

If ERROR_SIZE>24 then as:
                                  e
                                 d
                                c   + b + a
 The function FOO doesn't like -------------- as input.
                               cos(x - 1) + 1

Expressions larger than ERROR_SIZE are replaced by symbols, and the
symbols are set to the expressions.  The symbols are taken from the
user-settable list ERROR_SYMS:[ERREXP1,ERREXP2,ERREXP3].

&ERROR_STRING default:"No error."

This system variable contains the most recent error message in the
form of a Macsyma string.

&ERROR_SYMS default:[ERREXP1,ERREXP2,ERREXP3]

In error messages, expressions larger than ERROR_SIZE are replaced by
symbols, and the symbols are set to the expressions.  The symbols are
taken from the list ERROR_SYMS, and are initially ERREXP1, ERREXP2,
ERREXP3, etc.  After an error message is printed, e.g. "The function
FOO doesn't like ERREXP1 as input.", the user can type ERREXP1; to see
the expression.  ERROR_SYMS may be set by the user to a different set
of symbols, if desired.

&ERRORFUN default:FALSE

If ERRORFUN evaluates to the name of a function of no arguments, then
that function will be executed whenever an error occurs.  This is
useful in BATCH files where the user may want his Macsyma killed or
his terminal logged out if an error occurs.  In these cases ERRORFUN
would be set to QUIT or LOGOUT.

&ERRORMSG()

Reprints the last error message.  This is helpful if the message has
gone off the screen.  

ERRORMSG default: TRUE

If TRUE, an error message will be printed when an error occurs 
inside an ERRCATCH. If FALSE, then printing of error messages from
inside an ERRCATCH is suppressed.

&EULER(n)

Gives the nth Euler number for integer n.  For the Euler-Mascheroni
constant, see %GAMMA.

Do EXAMPLE(EULER); for an example.

See also EULERPOLY for Euler polynomials.

&EULER_LAGRANGE(f, depvar_list, indepvar_list)

[OPTVAR package] Derives the Euler-Lagrange equations for
calculus-of-variations problems, where

 - F = expression for the integrand of the stationary functional,
       augmented by Lagrange multipliers times the integrands of
       any isoperimetric constraints and/or differential expressions
       constrained to equal zero. The multipliers should be written
       as functions  of the independent variables in the latter case.
 - depvar_list = a list of the dependent variables.
 - indepvar_list = a list of the independent variables. 

For convenience, square brackets may be omitted from 1-element lists.

See USAGE(OPTVAR); for more information.

Do EXAMPLE(EULER_LAGRANGE); for an executable example and do 
DEMO(OPTVAR); for a longer demonstration. 

See also IVARIATION.

&EULERIAN(x,y)

The yth element of the xth row of the Eulerian triangle.  (See Knuth, 
Vol. 3, or Graham, Knuth, and Patashnik.)  If x and y are integers, then 
the numerical value is computed.  If y or the value x-y is an integer, 
the result is given as a linear combination of powers of integers.

                                  5   49  205        
                              1   -   --  ---  . . .
                                  4   36  144

                                1   1   1
                            1   -   -   -  . . .
                                2   3   4 

         Eulerian(0,0) =  1


       Eulerian(1,0) =  1


                      1   1
                                   (Invisible values are 0.)

                    1   4   1


                  1  11  11   1


                1  26  66  26   1

                       .
                       .
                       .
Do EXAMPLE(EULERIAN); for an example.

&EULERPOLY(v, n)

Generates the nth Euler polynomial in the variable v.

Do EXAMPLE(EULERPOLY); for an example.

See also EULER for Euler numbers.

&EV(exp {, arg1, ..., argn})

EV is one of Macsyma's most powerful and versatile commands.  It
evaluates the expression exp in the environment specified by the argi.
This is done in steps, as follows:

 1) First the environment is set up by scanning the argi.

 2) During step (1), a list is made of the non-subscripted
    variables appearing on the left side of equations in the argi or
    in the value of some argi if the value is an equation.  The
    variables (both subscripted variables which do not have associated
    array functions, and non-subscripted variables) in the expression
    exp are replaced by their global values, except for those
    appearing in this list.  Usually, exp is just a label or %, so
    this step simply retrieves the expression named by the label, so
    that EV may work on it.

 3) If any substitutions are indicated by the argi, they are
    carried out now.

 4) The resulting expression is then re-evaluated (unless one of
    the argi was NOEVAL) and simplified according the argi.  Note that
    any function calls in exp will be carried out after the variables
    in it are evaluated and that EV(F(X)) thus may behave like
    F(EV(X)). 

 5) If one of the argi was EVAL, steps (3) and (4) are repeated.

Do USAGE(EV); for more information.

Do EXAMPLE(EV); for an example and DEMO(EVALUATION); for a longer
demonstration.

See also EVAL, "'", "''".

&EVAL(exp)

Causes an extra post-evaluation of exp to occur.

EVAL - This keyword to EV causes an extra post-evaluation to occur.
EVAL is an evflag by default.

Do EXAMPLE(EVAL); for an example.

See also EV, INFEVAL.

&EVAL_STRING(string)

Parses the string argument and sends the result to the Macsyma
evaluator.

Example:

 (c1) A:2$

 (c2) EVAL_STRING("a+b*c");

 (d2)                         b*c+2.


Do EXAMPLE(EVAL_STRING); for an example.

See STRING_SUMMARY for related commands.

&EVEN - Property

A symbol can be declared EVEN if it is known to represent an even
integer or a function that takes only even integral values.  EVEN is a
member of the FEATURES list.  It can be asserted with DECLARE,
withdrawn with REMOVE, and detected with FEATUREP.

See also ODD, EVENFUN.

&EVENFUN - Property

A symbol can be declared EVENFUN if it is known to
represent an even function.  EVENFUN is a member of the FEATURES list.
It can be asserted with DECLARE, withdrawn with REMOVE, and detected
with FEATUREP.

Do EXAMPLE(EVENFUN); for an example.

&EVENP(exp)

If exp is an even integer, then returns TRUE .  Otherwise returns
FALSE.

Do EXAMPLE(EVENP); for an example.

See also PREDICATES.

&EVFLAG default:[]

An option variable which is known to the EV function.  An EVFLAG will
be bound to TRUE during the execution of EV if it is mentioned in the
call to EV, as in EV(%,SIMPSUM);.  Initial evflags are:

%EMODE, %ENUMER, ALGEBRAIC, ASSUME_POS, ASSUME_SQUARE_MATRIXP,
ATRIGHSWITCH, ATRIGSWITCH, CAUCHYSUM, COMPLEX_INTEGRATE, DEMOIVRE,
DOTSCRULES, EXPONENTIALIZE, EXPTISOLATE, FACTORFLAG,
FACTOR_USES_RATSIMP, FLOAT, FULL_LOGCON, GENFLOAT, GENLOGICAL,
GENNUMER, GENTRANOPT, GENTRANSEG, GLOBALSOLVE, HALFANGLES, INFEVAL,
ISOLATE_WRT_TIMES, KEEPFLOAT, LETRAT, LIMSUBST, LISTARITH,
LISTCONSTVARS, LOGABS, LOGARC, LOGEXPAND, LOGEXPAND_EXPT, LOGNEG,
LOGNUMER, M1PBRANCH, MATRIX_ELEMENTS_ASSUMED_SCALAR, NUMER_PBRANCH,
POLYFACTOR, PRODHACK, PROGRAMMODE, RADEXPAND, RADSUBSTFLAG,
RATALGDENOM, RATFAC, RATMX, RATSIMPEXPONS, RETURN_NUMMOD, SIMP,
SIMPLE_VECTOR_P, SIMPPROD, SIMPSUM, SOLVEEXPLICIT, SUMEXPAND, SUMHACK,
TLIMSWITCH, TRIGEXPAND, USE_GROBNER, USE_MATRIX_LU, USE_MINORS

The PROPERTIES command can be used to indicate which symbols are evflags.

&EVFUN - A function which is known to the EV function.  An EVFUN will
get applied if its name is mentioned in the call to EV.  Initial
evfuns are:

BFLOAT, DELTASIMP, DFLOAT, FACTOR, FACTOR_NUMBER, FULLRATSIMP,
LOGCONTRACT, POLARFORM, RADCAN, RATEXPAND, RATSIMP, RECTFORM,
ROOTSCONTRACT, SFLOAT, TRIGREDUCE.

The PROPERTIES command can be used to indicate which symbols are evfuns.

&EVUNDIFF(exp)

[ITENSOR package] Evaluates tensor expression exp by turning off the
IDIFF operation (using UNDIFF), then evaluating (using EVAL), then
turning on IDIFF again (using REDIFF) and reevaluating.  For example,
Christoffel symbols which are inside indicial derivatives can be
evaluated in terms of the metric before the indicial derivative is
performed.

See also UNDIFF and REDIFF.

&EXAMPLE(command)

Will start up an executable example of an individual command.  Larger
executable examples and executable demonstrations of library packages
area accessible with the DEMO command.  After each command line in an
EXAMPLE or DEMO program, execution will pause and wait for a space to
be typed.

Do EXAMPLE(EXAMPLE); for an example.

To access the source code for any demo or example file, see
UNPACK_TOPIC.

See also DEMO, HELP, and FILE_PATHNAMES.

&EXIT()

Exits Macsyma without disturbing any state which has been built up so
that it may later be re-entered and its use continued.

EXIT is different than QUIT in that EXIT is not allowed to do any
implicit KILL(ALL) or RESET(), as QUIT is permitted to do.

&EXP(X)

The exponential function.  It is represented internally as %E^X.

Do EXAMPLE(EXP); for an example.

&EXP_INT(X)

The exponential integral function, given by

  EXP_INT(x)  represents Ei(x)  = integrate(exp(t)/t,t,minf,x) 
  SIN_INT(x)  represents Si(x)  = integrate(sin(t)/t,t,0,x) 
  COS_INT(x)  represents Ci(x)  
               = %gamma + log(x) + integrate((cos(t)-1)/t,t,0,x) 
  SINH_INT(x) represents Shi(x) = integrate(sinh(t)/t,t,0,x) 
  COSH_INT(x) represents Chi(x) =
               = %gamma + log(x) + integrate((cosh(t)-1)/t,t,0,x) 

Macsyma knows some simplification and numerical capabilities. 
For example:
  sin_int(-x);  ->  - sin_int(x) .
  exp_int({neg. sfloat}) -> sfloat
  exp_int(-0.5);  ->  - 0.5597735

  diff(exp_int(x),x);  ->  exp(x)/x 
  diff(sin_int(x),x);  ->  sin(x)/x 
  diff(cos_int(x),x);  ->  cos(x)/x 
  diff(sinh_int(x),x); ->  sinh(x)/x 
  diff(cosh_int(x),x); ->  cosh(x)/x 

Do DEMO(EXP_INT); for a demonstration of integrals which result in
exponential integrals, and of simplification of these special
functions.

&EXPAND(exp)

Expands the expression exp by making the following changes.

 - Multiplies out products of sums and exponentiated sums;
 - Splits numerators of rational expressions which are sums into
   their respective terms;
 - distributes (commutative and non-commutative) multiplication
   over addition at all levels of exp.

For polynomials one should usually use RATEXPAND which uses a more
efficient algorithm.

MAXNEGEX default:1000 and MAXPOSEX default:1000
  Control the maximum negative and positive exponents, respectively,
  which will expand.

EXPAND(exp,p,n)
  Expands exp, using p for MAXPOSEX and n for MAXNEGEX.  This is
  useful in order to expand part but not all of an expression.

EXPON default:0
  The exponent of the largest negative power which is automatically
  expanded (independent of calls to EXPAND).  For example if EXPON is
  4 then (X+1)^(-5) will not be automatically expanded.

EXPOP default:0
  The highest positive exponent which is automatically expanded.  Thus
  (X+1)^3, when typed, will be automatically expanded only if EXPOP is
  greater than or equal to 3.  If it is desired to have (X+1)^N
  expanded where N is greater than EXPOP then executing
  EXPAND((X+1)^N) will work only if MAXPOSEX is not less than N.

The EXPAND flag used with EV (see EV) causes expansion.

Do EXAMPLE(EXPAND); for an example.

See also COMBINE, RNCOMBINE, DISTRIB, EXPANDWRT, MULTTHRU, XTHRU,
RAT and RATEXPAND.

The file FACEXP defines several related functions (including FACSUM
and COLLECTTERMS) which provide the user with the ability to structure
expressions by controlled expansion.

Do USAGE(FACEXP); for more information.

Do DEMO(FACEXP); for a demonstration.

&EXPANDALL default:FALSE

[VECT package] When TRUE, the VECTORSIMP command applies all the
simplification rules for coordinate-free vector calculus expressions
which are available in the VECT package. 

See USAGE(VECT); for more information.

See also VECTORSIMP, EXPANDCROSS, EXPANDCURL, EXPANDDIV, EXPANDDOT,
EXPANDGRAD, EXPANDLAPLACIAN.

&EXPANDCROSS default:FALSE

[VECT package] When TRUE, the VECTORSIMP command applies all the
simplification rules for vector cross products for coordinate-free
vector expressions which are available in the VECT package.

See USAGE(VECT); for more information.

Do EXAMPLE(EXPANDCROSS); for an example.

See also VECTORSIMP, EXPANDALL.

&EXPANDCURL default:FALSE

[VECT package] When TRUE, the VECTORSIMP command applies all the
simplification rules for curls of coordinate-free vector expressions
which are available in the VECT package.

See USAGE(VECT); for more information.

Do EXAMPLE(EXPANDCURL); for an example.

See also CURL, VECTORSIMP, EXPANDALL.

&EXPANDDIV default:FALSE

[VECT package] When TRUE, the VECTORSIMP command applies all the
simplification rules for divergences of coordinate-free vector
expressions which are available in the VECT package.

See USAGE(VECT); for more information.

Do EXAMPLE(EXPANDDIV); for an example.

See also DIV, VECTORSIMP, EXPANDALL.

&EXPANDDOT default:FALSE

[VECT package] When TRUE, the VECTORSIMP command applies all the
simplification rules for dot products of coordinate-free vector
expressions which are available in the VECT package. 

See USAGE(VECT); for more information.

Do EXAMPLE(EXPANDDOT); for an example.

See also DOT, VECTORSIMP, EXPANDALL.

&EXPANDGRAD default:FALSE

[VECT package] When TRUE, the VECTORSIMP command applies all the
simplification rules for gradients of coordinate-free vector
expressions which are available in the VECT package.

See USAGE(VECT); for more information.

Do EXAMPLE(EXPANDGRAD); for an example.

See also GRAD, VECTORSIMP, EXPANDALL.

&EXPANDLAPLACIAN default:FALSE

[VECT package] When TRUE, the VECTORSIMP command applies all the
simplification rules for Laplacians of coordinate-free vector
expressions which are available in the VECT package.

See USAGE(VECT); for more information.

Do EXAMPLE(EXPANDLAPLACIAN); for an example.

See also LAPLACIAN, VECTORSIMP, EXPANDALL.

&EXPANDWRT(exp {, var1, var2, ...})

Expands the expression exp with respect to the vari.  The vari may be
variables, operators, or expressions.

All products involving the vari appear explicitly.  The form returned
will be free of products of sums of expressions that are not free of
the vari.  

Options:
-------

 - If EXPANDWRT_DENOM (default:FALSE) is set to TRUE, then
   denominators are expanded.
 - If EXPANDWRT_NONRAT (default:TRUE) is set to TRUE, then
   subexpressions such as the arguments of nonrational functions are
   expanded.

Do EXAMPLE(EXPANDWRT); for an example and DEMO(STOPEX); for a longer
demonstration.

See also DISTRIB, EXPAND, EXPANDWRT_FACTORED, MULTTHRU, and RATEXPAND.

&EXPANDWRT_DENOM default:FALSE

Controls the treatment of rational expressions by EXPANDWRT.
 - If TRUE, then both the numerator and denominator of the expression
   will be expanded according to the arguments of EXPANDWRT.
 - If EXPANDWRT_DENOM is FALSE, then only the numerator will be
   expanded in that way.  Do LOAD("STOPEX") to use.

&EXPANDWRT_FACTORED(exp, var1, var2, ..., varN)

Is similar to EXPANDWRT, but treats expressions that are products
somewhat differently.  EXPANDWRT_FACTORED will perform the required
expansion only on those factors of exp that contain the variables in
the argument list of EXPANDWRT_FACTORED.  Do LOAD("STOPEX") to use
this function.

&EXPANDWRT_NONRAT default:TRUE

Controls the treatment of nonrational expressions, such as the
arguments of nonrational functions, by EXPANDWRT. 
 - If TRUE, then such expressions are expanded by EXPANDWRT.
 - If FALSE, then they are not expanded.

&EXPECT_DISTRIB default:TRUE

[STOCH package] When TRUE, expectation operator <<...>> distributes
over finite sums.

&EXPECT_UNDER_INTEGRAL default:FALSE

[STOCH package] When TRUE, expectation operator <<...>> distributes
inside of integrals.

&EXPECT_UNDER_SUM default:FALSE

[STOCH package] When TRUE, expectation operator <<...>> distributes
inside of formal sums (i.e., 'SUM(...)).

&EXPON default:0

The exponent of the largest negative power which is automatically
expanded (independent of calls to EXPAND).  For example if EXPON is 4
then (X+1)^(-5) will not be automatically expanded.

See also EXPOP and EXPAND.

&EXPONENTIAL_DENSITY(x, lambda)

[UNIPROB package] The density function lambda*exp(-lambda*x).

See also EXPONENTIAL_DISTRIB.

&EXPONENTIAL_DISTRIB(x, lambda)

[UNIPROB package] The cumulative distribution function for the
EXPONENTIAL_DENSITY. 

See also EXPONENTIAL_DENSITY and INV_EXPONENTIAL_DISTRIB.

&EXPONENTIALIZE default:FALSE if TRUE will cause all circular
and hyperbolic functions to be converted to exponential form.
(Setting DEMOIVRE:TRUE; will reverse the effect.)

EXPONENTIALIZE(exp) will cause the conversion to exponential
form of an expression without setting the switch or having to
re-evaluate the expression with EV.

Do EXAMPLE(EXPONENTIALIZE); for an example.

See also TRIG_SUMMARY, DEMOIVRE.

&EXPOP default:0

The highest positive exponent which is automatically expanded.  Thus
(X+1)^3, when typed, will be automatically expanded only if EXPOP is
greater than or equal to 3.  If it is desired to have (X+1)^n expanded
where n is greater than EXPOP then executing EXPAND((X+1)^n) will work
only if MAXPOSEX is not less than n.

Do EXAMPLE(EXPOP); for an example.

See also EXPON and EXPAND.

&EXPT(A,B)

If an exponential expression is too wide to be displayed as A^B it
will appear as EXPT(A,B) (or as NCEXPT(A,B) in the case of A^^B).

&EXPTDISPFLAG default:TRUE

If TRUE, then Macsyma displays expressions with negative exponents
using quotients e.g., X^(-1) as 1/X.

&EXPTISOLATE default:FALSE

If TRUE will cause ISOLATE(expr,var); to examine exponents of atoms
(like %E) which contain var.

&EXPTSUBST default:FALSE

If TRUE permits substitutions such as Y for %E^X in %E^(A*X) to take
place.

&EXPUNGE_PHYSICAL_CONSTANTS()

See PHYSICAL_CONSTANTS.

See also EXPUNGE_UNITS() in the UNITS package.

&EXPUNGE_UNITS()

[UNITS package] removes the current set of UNITS defined by USE_UNITS.

See also UNITS.

&EXSEC(x) 

[ALGFUNCS package] sec(x) - 1 .

&EXT_DIFF(exp)

[CARTAN package] Computes the exterior derivative of exp, which should
be a exterior differential form.

Do DEMO(CARTAN); for an example. See also EXTDIFF.

&EXTDIFF(expr, k)

[ITENSOR package] Computes the exterior derivative of the differential
form (antisymmetric covariant tensor field) expr. This operation does
not depend on the affine connection. k is the additional derivative
index which appears in the result.

See also EXT_DIFF.

&EXTGCD(poly_or_integer, poly_or_integer)

[ALGFUNCS package] Computes the extended Euclidean algorithm for the
integers and/or univariate polynomials with integer coefficients.
Returns the list [p(x), a(x), b(x)] where q(x) and r(x) are the
arguments to EXTGCD, p(x) is their g.c.d., and a(x) and b(x) satisfy
Bezout's identity

 p(x) = a(x)*q(x) + b(x)*r(x) .

See also EXTGCD_INTEGER.

&EXTGCD_INTEGER(a, b)

[ALGFUNCS package] Computes the extended Euclidean algorithm
for the integers only.

See also EXTGCD.

&EZGCD(p1 {, p2, ...})

Gives a list whose first element is the g.c.d of the polynomials
p1,p2,...  and whose remaining elements are the polynomials divided by
the g.c.d.  This function always uses the EZGCD algorithm.

Do EXAMPLE(EZGCD); for an example.

&F_DENSITY(x, df1, df2)

[UNIPROB package] The F probability density function


   df1/2      df2   df1     df2/2  df1/2-1             -df2/2 - df1/2
df1     gamma(--- + ---) df2      x       (df1 x + df2)
               2     2
---------------------------------------------------------------------
                                df1        df2
                          gamma(---) gamma(---)
                                 2          2
                                                                x > 0

f(x) =                          0                               x <= 0.


Do EXAMPLE(F_DENSITY); for an example.

See also F_DISTRIB.

&F_DISTRIB(x, df1, df2)

[UNIPROB package] The cumulative F probability distribution. 

Do EXAMPLE(F_DISTRIB); for an example.

See also F_DENSITY, INV_F_DISTRIB.

&F_TEST(data1, data2)

Computes the numerically F statistic for two samples data1 and data2,
possibly of different lengths, and computes the probability that they
have unequal variances.

Do EXAMPLE(F_TEST); for an example.

See also F_DENSITY, F_DISTRIB, INV_F_DISTRIB.

&FACEXP

The FACEXP package contains several related functions that provide the
user with the ability to structure expressions by controlled
expansion.  

Do USAGE(FACEXP); for more information.

Do DEMO(FACEXP); for a demonstration.

&FACEXPAND default:TRUE

Controls whether the irreducible factors returned by FACTOR are in
expanded (the default) or recursive (normal CRE) form.

&FACSUM(exp {, arg1, arg2, ...})

[FACEXP package] Returns a form of exp which depends on the argi.  The
argi can be any form suitable for RATVARS, or they can be lists of
such forms.  
 - If the argi are not lists, then the form returned will be fully
   expanded with respect to the argi, and the coefficients of the argi
   will be factored.  These coefficients will be free of the argi,
   except perhaps in a non-rational sense.
 - If any of the argi are lists, then all such lists will be combined
   into a single list, and instead of calling FACTOR on the
   coefficients of the argi, FACSUM will call itself on these
   coefficients, using this newly constructed single list as the new
   argi for this recursive call.  This process can be repeated to
   arbitrary depth by nesting the desired elements in lists. 

Do USAGE(FACEXP); for more information.

Do EXAMPLE(FACSUM); for an example, and do DEMO(FACEXP); for a longer
demonstration.

See also FACSUM_COMBINE, NEXTLAYERFACTOR.

&FACSUM_COMBINE default:TRUE

[FACEXP package] Controls the form of the final result returned by
FACSUM when its argument is a quotient of polynomials.  If
FACSUM_COMBINE is FALSE then the form will be returned as a fully
expanded sum as described under FACSUM, but if TRUE, then the formed
returned is a ratio of polynomials, with each polynomial in the form
described above.  The TRUE setting of this switch is useful when one
wants to FACSUM both the numerator and denominator of a rational
expression, but does not want the denominator to be multiplied through
the terms of the numerator.

&FACT_REFLECT(exp)

Implements the factorial reflection formula (AS p. 256 6.1.17).

Do EXAMPLE(FACT_REFLECT); for an example.

&FACTCOMB(exp)

Tries to combine the coefficients of factorials in exp with the
factorials themselves by converting, for example, (N+1)*N!  into
(N+1)!.

SUMSPLITFACT default:TRUE

If set to FALSE will cause MINFACTORIAL to be applied after a
FACTCOMB.

 (c1) (N+1)^2*N!^2;
                                       2   2
 (d1)                           (n + 1)  n!

 (c2) FACTCOMB(%);
                                          2
 (d1)                             (n + 1)!

Do EXAMPLE(FACTCOMB); for an example.

See also "!" .

&FACTOR(exp)

Factors the expression exp, containing any number of variables or
functions, into factors irreducible over the integers.

FACTOR(exp, p)

Factors exp over the field of integers with an element adjoined
whose minimum polynomial is p.

Options:
-------

FACTORFLAG default:FALSE

  If FALSE suppresses the factoring of integer factors of rational
  expressions.

DONTFACTOR default:[] 

  May be set to a list of variables with respect to which factoring is
  not to occur.  (It is initially empty).  Factoring also will not
  take place with respect to any variables which are less important
  (using the variable ordering assumed for CRE form) than those on the
  DONTFACTOR list.

SAVEFACTORS default:FALSE

  If TRUE causes the factors of an expression which is a product of
  factors to be saved by certain functions in order to speed up later
  factorizations of expressions containing some of the same factors.

INTFACLIM default:1000

  Is the largest divisor which will be tried when factoring a bignum
  integer.  If set to FALSE (this is the case when the user calls
  FACTOR explicitly), or if the integer is a fixnum (i.e. fits in one
  machine word), complete factorization of the integer will be
  attempted.  The user's setting of INTFACLIM is used for internal
  calls to FACTOR.  Thus, INTFACLIM may be reset to prevent Macsyma
  from taking an inordinately long time factoring large integers.

NEWFAC default:FALSE

  May be set to true to use the new factoring routines.

When FACTOR is applied to integers, note that the value returned by
FACTOR when used in other computations may not lead to a simplified
result.  It is advisable to resimplify an expression after FACTORing
it.  

Do USAGE(FACTORING); For more information about factoring in Macsyma.

Do EXAMPLE(FACTOR); for examples.

See also CFACTOR, FACSUM, FACTOR_NUMBER, FACTOROUT, FACTORSUM,
GCFACTOR, GFACTOR, and GFACTORSUM.


&FACTORFORM(list_of_roots, var)

Reconstructs the expression originally given to POLYSOLVE.
It returns a form factored over the complex plane.  There is no need
for var to be the same as in the expression being POLYSOLVEd.

Do EXAMPLE(FACTORFORM); for an example.

See also CFACTOR, POLYSOLVE.


&FACTOR_NUMBER(number {,intfaclim[false],winfun["["],losefun[winfun]})

An alternative to FACTOR for prime factorization of integers and
rationals.  The underlying algorithm (a combination of methods due
to Pollard, the Chudnovksys, and Schroeppel) is the same, but
FACTOR_NUMBER makes it easier to elect and detect partial
factorizations, and for users' programs to manipulate the resulting
primes and powers.

Example:

 (c1) FACTOR_NUMBER(99);
 (d1)                     [3^2,11^1]

 (c2) FACTOR_NUMBER(100/99);
 (d2)                [2^2,3^-2,5^2,11^-1]

With one argument, FACTOR_NUMBER undertakes complete factorization,
and returns a list of each prime to its corresponding power (even when
the power is 1), with the primes in increasing order.

You can convert this result to a list of pairs by SUBST("[","^",%),
and convert it back to 100/99 by RESIMPLIFY(APPLY("*",%)).

The optional second argument is INTFACLIM, which limits the size of
numbers tried as divisors (resulting in partial factorization) in
case full factorization might take too long.  For example,

 (c3) FACTOR_NUMBER(100/99,3);
 (d3)                [25,2^2,3^-2,11^-1]

Binding INTFACLIM to 3 caused FACTOR_NUMBER to abandon the
factorization of 25.  All factors not known to be prime are combined
into the first element of the answer list.  The larger the INTFACLIM,
the more time will be spent looking for factors smaller than
INTFACLIM.  In this example, despite setting INTFACLIM:3,
FACTOR_NUMBER(100/99,3) was able to certify the primality of 11, or
else it would have returned [25/11,2^2,3^-2].

For the casual user, the absence of an exponent on the first answer
element indicates incomplete factorization, e.g.,
FACTOR_NUMBER((10^23-1)/9,999) -> [11111111111111111111111] failed
to find any factor or certify primality, while
FACTOR_NUMBER((10^23-1)/9,9999) -> [11111111111111111111111^1]
succeeded in proving the argument was prime.

The third argument, if supplied, is APPLYed to the answer, e.g.,
smallest_prime_factor(n):=
      FACTOR_NUMBER(n,FALSE,lambda([first,[rest]],first(first)))$

But this could waste much time by continuing the factorization after
finding the smallest factor.  The fourth argument to FACTOR_NUMBER, if
supplied, is applied instead of the third in the case of incomplete
factorization.  E.g.,

any_prime_factor(n):=
 FACTOR_NUMBER(n,69,lambda([first,[rest]],first(first)),
               lambda([undone,[done]],
                 if done=[] then smallest_prime_factor(n)
                 else first(first(done))))$

The fourth argument can also disambiguate a rare mishap when
incompletely factoring nonintegers:  Since Macsyma stores 1/x
as x^-1, there is no way (after the fact) to tell whether
[1/11111111111111111111111] is completely factored or completely
unfactored.

Another way to disambiguate this case is to negate the factorand:
FACTOR_NUMBER(9/(1-10^23),999) -> [-1/11111111111111111111111]
(failure) while FACTOR_NUMBER(9/(1-10^23),9999) ->
[(-1)^1,1/11111111111111111111111] (success).  I.e., complete
factorizations of negative numbers start with (-1)^1, while
incomplete factorizations lump the minus sign with the unfactored
first element.

A floating factorand is regarded as the rational to which it is
exactly equal, rather than some "nice" rational approximation.
Thus, FACTOR_NUMBER(1/3.0) will never return [3^-1].

Do EXAMPLE(FACTOR_NUMBER); for examples.

See also FACTOR.

&FACTOR_USES_RATSIMP default:TRUE

If TRUE, FACTOR calls on RATSIMP to prepare the expression for
factoring.

&FACTORFACSUM(exp, arg1, arg2,  ...argN)

[FACEXP package] Returns a form of exp which is obtained by calling
FACSUM on the factors of exp with the argI as arguments.  If any of
the factors of exp is raised to a power, both the factor and the
exponent will be processed in this way.

See also FACSUM, COLLECTTERMS.

&FACTORFLAG default:FALSE

If FALSE, suppresses the factoring of integer factors of rational
expressions. If TRUE, FACTOR and related commands factor integer
factors of rational expressions into primes.

Do EXAMPLE(FACTORFLAG); for an example.

&FACTORIAL(X)

The factorial function.  FACTORIAL(X) = X! .  "!" is the postfix
notation for FACTORIAL. The double factorial operator is !!.

Do EXAMPLE(FACTORIAL); for an example. 

See also BFFAC, FACTCOMB, GAMMA, CGAMMA, GENFACT, MINFACTORIAL,
SUMSPLITFACT, MAKEGAMMA, and FACT_REFLECT.

&FACTORIAL_LIMIT default:FALSE

If FACTORIAL_LIMIT is numeric, and x is integer or rational, and 
|x| > FACTORIAL_LIMIT, then automatic expansion of x! is inhibited. 
Thus, a negative value disables all rational factorials. 

If FACTORIAL_LIMIT is FALSE then all such factorials are expanded.

For example,
block([FACTORIAL_LIMIT:69],minfactorial(999999!/1000001!))
gets 1/1000001000000 "the easy way".

Do EXAMPLE(FACTORIAL_LIMIT); for an example.

&FACTOROUT(exp, var1 {, var2, ...})

Rearranges the sum exp into a sum of terms of the form
f(var1,var2,...)*g where g is a product of expressions not containing
the vari's and f is factored.

Do EXAMPLE(FACTOROUT); for an example.

&FACTORSUM(exp)

Factors the expression exp, then tries to group terms in each factor
of exp into groups of terms such that their sum is factorable.  It can
recover the result of EXPAND((X+Y)^2+(Z+W)^2) but it can't recover
EXPAND((X+1)^2+(X+Y)^2) because the terms have variables in common.

Example:

 (c1) (X+1)*((U+V)^2+A*(W+Z)^2),EXPAND;

       2      2                            2      2
 (d1) a x z  + a z  + 2 a w x z + 2 a w z + a w  x + v  x

                      2        2    2            2
         + 2 u v x + u  x + a w  + v  + 2 u v + u

 (c2) FACTORSUM(%);
                                   2          2
 (d2)                 (x + 1) (a (z + w)  + (v + u) )

Do EXAMPLE(FACTORSUM); for an example.

See also FACTOR, FACTORFACSUM, GFACTORSUM.

&FACTS(item)

 - If 'item' is the name of a context then FACTS returns a list
   of the facts in the specified context.
 - If no argument is given, it lists the current context.  
 - If 'item' is not the name of a context then it returns a list of
   the facts known about 'item' in the current context.  Facts that
   are active, but in a different context, are not listed.  

Do USAGE(PROPERTIES); for an overview of Macsyma commands to manage
properties of symbols.

See also ASSUME, FORGET, CONTEXT.

&FALSE

The Boolean constant, false. (NIL in LISP)

&FANCY_DISPLAY default:TRUE

If TRUE, then screen output is in fancy display mode.  If FALSE, then
screen output is in ASCII text mode using a fixed width font.

Fancy display mode enables Macsyma to draw symbols for integral signs,
summation signs, product signs, %E, %pi, and Greek letters.
Exponents, superscripts and subscripts appear at half-height and in a
reduced size.  The display makes decisions about when to break long
lines and when to scroll horizontally.  Users can choose which font to
use from among those installed in the window system.  Many other
display features are included in this display mode.

Do EXAMPLE(FANCY_DISPLAY); for an example.

See also DISPLAY_CASE, FANCY_FONT_NAME, FANCY_FONT_SIZE, FANCY_WIDTH,
FANCY_WRITEFILE.

&FANCY_ECHO default:FALSE

If TRUE, then screen input is in fancy display mode.  If FALSE, then
screen input is in ASCII text mode using a fixed width font. This
feature is only available in Macsyma 2.0 and its successors.

Fancy echo mode enables Macsyma to draw symbols for integral signs,
summation signs, product signs, %E, %pi, and Greek letters in input
sections.  Exponents, superscripts and subscripts appear at
half-height and in a reduced size.

See also FANCY_DISPLAY.

&FANCY_FONT_NAME default:"Times New Roman"

The name of the font used for fancy display mode.  Any font which is
installed in the windows system can be used for fancy display.

FANCY_FONT_NAME, FANCY_FONT_SIZE, FANCY_WIDTH, and FANCY_WRITEFILE are
used only in Macsyma 419 and successors and not in Macsyma 2.0 and
successors.

See also DISPLAY_CASE, FANCY_DISPLAY, FANCY_FONT_SIZE, FANCY_WIDTH,
FANCY_WRITEFILE.

&FANCY_FONT_SIZE default:16

The point size of the font used in fancy display mode.

FANCY_FONT_NAME, FANCY_FONT_SIZE, FANCY_WIDTH, and FANCY_WRITEFILE are
used only in Macsyma 419 and successors and not in Macsyma 2.0 and
successors.

See also DISPLAY_CASE, FANCY_DISPLAY, FANCY_FONT_NAME, FANCY_WIDTH,
FANCY_WRITEFILE.

&FANCY_WIDTH default:0

The width of the fancy display output, expressed in pixels.  This
number is used to determine where to break long lines.   When it is
set to zero, the line-breaking software uses its estimate of the width
of the screen to decide when to line-break.

FANCY_FONT_NAME, FANCY_FONT_SIZE, FANCY_WIDTH, and FANCY_WRITEFILE are
used only in Macsyma 419 and successors and not in Macsyma 2.0 and
successors.

See also DISPLAY_CASE, FANCY_DISPLAY, FANCY_FONT_NAME,
FANCY_FONT_SIZE, FANCY_WRITEFILE.

&FANCY_WRITEFILE default:FALSE

In Macsyma 419, default:TRUE.

If TRUE, then writefile output is in fancy display mode.  If FALSE,
then writefile output is in ASCII text mode using a fixed width font.


FANCY_FONT_NAME, FANCY_FONT_SIZE, FANCY_WIDTH, and FANCY_WRITEFILE are
used only in Macsyma 419 and successors and not in Macsyma 2.0 and
successors.

See also DISPLAY_CASE, FANCY_DISPLAY, FANCY_FONT_NAME,
FANCY_FONT_SIZE, FANCY_WIDTH.

&FDIF_PDE

A library package for generating finite difference equations from
differential equations.

Do USAGE(FDIF_PDE); for more information.

Do DEMO(FDIF_PDE); for a demonstration.

&FEATURE

A nice adjunct to the system.  STATUS(FEATURE) gives you a list of
system features.  Any of these "features" may be given as a second
argument to STATUS(FEATURE,...);.  If the specified feature exists,
TRUE will be returned, else FALSE.  Note: these are system features,
and not really "user related".

See FEATURES for more user-oriented features.

&FEATUREP(a, f)

Attempts to determine whether the object a has the feature f on the
basis of the facts in the current database.  If so, it returns TRUE,
else FALSE.

Example:

 (c1) DECLARE(J,EVEN)$
 (c2) FEATUREP(J,INTEGER);
 (d2)                                true

Do EXAMPLE(FEATUREP); for an example.

See also FEATURES, PREDICATES.

&FEATURES

Macsyma has built-in properties which are handled by the database.
These are called FEATURES.  For example, one can do DECLARE(N,EVEN),
so that (-1)^N simplifies to 1.  Features can be displayed with the
FEATUREP command, and removed with the REMOVE command.

The built-in features in Macsyma are:  ANTISYMMETRIC, COMMUTATIVE, 
COMPLEX, CONSTANTFUN, DECREASING, EVEN, EVENFUN, INCREASING, INTEGER, 
IRRATIONAL, NONINTEGER, ODD, ODDFUN, POSFUN, RATIONAL, REAL, 
SYMMETRIC, and THREADABLE.

Users can also DECLARE their own FEATURES.  Do EXAMPLE(FEATUREP); for
an example.

The information list FEATURES evaluates to a list of the known FEATURES in
Macsyma, including user-defined features.  

Note: system "features" may be checked with STATUS(FEATURE,...); .
See DESCRIBE(STATUS); or DESCRIBE(FEATURE); for more information.

Do USAGE(PROPERTIES); for an overview of Macsyma commands to manage
properties of symbols.

See also PROPERTIES, OPPROPERTIES.  

&FEYNBOUN

The FEYNBOUN package determines the asymptotic behavior of Feynman
integrals. Given a topological description of a Feynman diagram as a set
of lines and vertices, together with information about the mass of the
virtual particle corresponding to each line and the momentum entering at
each external leg, it will tell one the leading asymptotic behavior of
that graph as some sets of masses get much larger than others.

See USAGE(FEYNBOUN); for more information.

Do DEMO(FEYNBOUN); for an executable demonstration.

&FFT(flag, direction, array1 {, optionalarray2})

[FFT package] Computes the Fast Fourier transform of array1. 

Arguments:

 1 array1 and optionalarray2 must be arrays of the same length, which
   must be a power of two.
 2 direction (either 1 or -1) indicates whether the transform is from
   the time to the frequency domain or vice versa. 
 3 flag can be one of
   TRUE - Takes a complex Fourier transform.  
       If two arrays are given, then array1 gives the real parts and
       optionalarray2 gives the imaginary parts.
       If only array1 is given, then the even-numbered elements are
       the real parts, and the odd-numbered elements are the imaginary
       parts.
   REAL - Transforms real data.
   COMPLEX - Transforms complex data, which is contained in array1.
       The second array, if present, is simply transformed separately,
       and returned with the first FFT in a two-element list.

The library file FFT contains the Fast Fourier transform package.
Do USAGE(FFT); for more information, 

Do EXAMPLE(FFT); for an example, and do DEMO(FFT); for a longer
demonstration.

See also MODFFT, COSFFT, SINFFT.  See also FOURIER for symbolic
Fourier transforms.

&FFT_2D(type, dir, A, n1, n2, {,[t0, t1]})

Calculates the 2 dimensional FFT of the matrix or array A, whose size is n1
X n2 (N1 and N2 must be powers of 2) in the direction dir (default +1). Dir
is +1 for forward transform, -1 for inverse transforms. Type is one of
'real, 'complex or 'true.

If the option variable FFT2_PLOT_POWER is not FALSE, then the 2D power
spectrum of the input will be calculated and displayed. The frequency
components are normalized by assuming a signal duration of t1-t0
(default: t1=1, t0=0).

Results are stored in MFE variables FFT_A, IFFT_A and PS_K_A for the
transform, its inverse and power spectrum, where K is the integer value of
POWER_COUNTER2D.

Do EXAMPLE(FFT_2D); for an example.

&FFT_3D(type, dir, A, n1, n2, n3, {,[t0, t1]})

Calculates the 3 dimensional FFT of the matrix or array A, whose size is n1
x n2 x n3 (n1, n2 and n3 must be powers of 2) in the direction dir (default
+1). Dir is +1 for forward transform, -1 for inverse transforms. Type is one of
'real, 'complex or 'true.

If the option variable FFT3_PLOT_POWER is not FALSE, then the 3D power
spectrum of the input will be calculated. The frequency
components are normalized byassuming a signal duration of t1-t0
(default: t1=1, t0=0).

Results are stored in MFE variables FFT_A, IFFT_A and PS_K_A for the
transform, its inverse and power spectrum, where K is the integer value of
POWER_COUNTER3D.

Do EXAMPLE(FFT_3D); for an example.

&FFT2_PLOT_POWER (default: TRUE)

If TRUE, then FFT_2D will compute and plot the 2D power spectrum based on a
2D FFT of input data.

See also FFT_2D.


&FFT3_PLOT_POWER (default: TRUE)

If TRUE, then FFT_3D will compute the 3D power spectrum based on a
3D FFT of input data.

See also FFT_3D.


&FIB(n)

The nth Fibonacci number with FIB(0)=0, FIB(1)=1, and
FIB(-N)=(-1)^(N+1) * FIB(N).  

PREVFIB is FIB(n-1), the Fibonacci number preceding the last one
computed.

Do EXAMPLE(FIB); for an example.

See also FIBTOPHI.

&FIBTOPHI(exp)

Converts any FIB(n) to its closed form definition.  This involves the
constant %PHI (= (SQRT(5)+1)/2 ~ 1.618033989).  If you want the
Rational Function Package to know about %PHI, do
TELLRAT(%PHI^2-%PHI-1)$ ALGEBRAIC:TRUE$ .

Do EXAMPLE(FIBTOPHI); for an example.

&FIFTH(exp)

Returns the fifth part of exp.  It is affected by INFLAG, in the same
way as FIRST.

&FILE

See FILES_SUMMARY.

&FILE_PATHNAMES

When specifying file pathnames from the Macsyma environment, you can
use the pathname syntax which is specific to your type of platform,
enclosed in double quote marks.  (MS-Windows is an exception in that
each backslash must be replaced by two backslashes.)  For example, if
Macsyma is stored on the directory named MACGOLD, then the following
commands load the Macsyma system file "functs" and the user file
"myfile" on the user's home directory (named HOMEDIR) on subdirectory
MYSUBDIR:

Platform       Command
----------     -----------
MS-Windows     LOAD("c:\\macgold\\share\\functs.fas")$
               LOAD("c:\\homedir\\mysubdir\\myfile.mac")$

UNIX           LOAD("c:/macgold/share/functs.o")$
               LOAD("c:/homedir/mysubdir/myfile.macsyma")$

Symbolics      LOAD("c:>macgold>share>functs.bin")$ (or .ibin)
               LOAD("c:>homedir>mysubdir>myfile.macsyma")$

All Systems    LOAD("macsyma:share;functs.bin")$
               LOAD("macsyma:share;functs")$
               LOAD("functs")$
               LOAD('functs)$
               LOAD(functs)$

Under "All Systems," the first line uses Macsyma's generic pathname
specification scheme which works across all platforms. Note that the
logical directory name "macsyma" translates to the name of the directory
where Macsyma software is located.  A colon is used to separate
directory names, and a semicolon separates the subdirectory name from
the file name.  The file type extension (see below for more information)
is the logical name ".bin", whose literal interpretation varies across
platforms.  The generic pathname specification scheme using ":" and ";"
is supported for pathnames in the Macsyma directory.

Macsyma has a logical pathname scheme which uses logical names for the
name of the directory where Macsyma is installed, and for filename
extensions.  The logical pathname scheme is supported only for
directories which are specified in the list FILE_SEARCH.  The commands
on the last three lines above use Macsyma's FILE_SEARCH facility.  When
you load a file by its name only, Macsyma checks for a file of that name
in several directories.  The directories currently on the FILE_SEARCH
list are:

     your home directory (denoted by the symbol "FALSE")
     macsyma:library1;
     macsyma:share;
     macsyma:library2;
     macsyma:ode;
     macsyma:tensor;

For example, if your user home directory is named HOMEDIR, you can load
a file with either of the commands

LOAD("myfile.bin")$
LOAD("myfile")$ (will search for a binary first, then Lisp, then
    Macsyma. 

The name of your user home directory is returned by the Macsyma
command USER_HOMEDIR_PATHNAME(); .


FILENAME EXTENSIONS

Macsyma's logical pathname scheme uses three logical pathnames
extensions:  .macsyma .lisp, and .bin.  These translate into literal
pathname extensions as follows

Logical     ------  Actual Extensions  ------
Extensions  DOS-Windows    UNIX    Symbolics
----------  ----------- ---------- ----------
macsyma     MAC         macsyma    macsyma
lisp        LSP         lsp        lisp
bin         FAS         o          bin, ibin

The logical file extensions are contained in the Macsyma variable
FILE_TYPES.  The default value of FILE_TYPES is: [bin, lisp , macsyma],
where "bin" means one of [.o .fas .bin .ibin] on different platforms,
and "lisp" means .lsp on DOS_WINDOWS and UNIX.

Other filename extensions used in Macsyma are:

          Shortened
Extension  for DOS  Type of file
--------- --------- --------------------
demo       dem      Executable demonstration file,
                    written in the Macsyma language.
example    exa      Executable example of a command,
                    written in the Macsyma language.
pack       pck      Packed demo or example files in Macsyma language.
                    Access the source code with UNPACK_TOPIC("name.demo");
                    or UNPACK_TOPIC("name.example");
gentran    gen      Template files used in certain demonstrations of 
                    the GENTRAN package.  These files contain a mixture
                    of Macsyma language and Fortran or C.
plt        plt      Plot files (for versions of Macsyma which have
                    file-based graphics.

When you do not specify a filename extension, various Macsyma file
commands check for a default filename extension.  The table below
describes these default extensions.

      
Macsyma command Default file types, in order of search
--------------- --------------------------------------------- 
LOAD            from the FILE_TYPES list, in that order. 
BATCH           .macsyma
COMPILE_FILE    .macsyma .lisp
DEMO            .demo
EXAMPLE         .example
USAGE           .usage

See FILES_SUMMARY for more information about file manipulation
commands in Macsyma.

&FILE_SEARCH

The list of directories which will be searched when the LOAD function
is used.

FILE_SEARCH("filename"); searches on those directories and devices
specified by the FILE_SEARCH variable, and returns the name of the first
file it finds.  This function is invoked by the LOAD function, which is
why LOAD("FFT") finds and loads SHARE;FFT.BIN .  In addition to
directory names, FALSE can also occur in this list.  If it does, it
means to use the system default directory (generally your home
directory) for merging.  By default, FALSE is the first element of the
FILE_SEARCH list so that personal files will have precedence over system
files with the same name.

You may do FILE_SEARCH:CONS(directorystring, FILE_SEARCH); to add other
directories to the search rules, e.g.
FILE_SEARCH:CONS("MYBOX:[JDOE]",FILE_SEARCH)$

To add a directory to FILE_SEARCH for all users at your site, add this
form to your Macsyma language site-wide init file.  See INIT for more
information about INIT files.

&FILELENGTH(filespec)

Gives the length of the file specified by filespec in blocks and
fractions of blocks.

See FILENAMES and FILE_PATHNAMES for information about how to specify
file pathnames in Macsyma.  See FILES_SUMMARY for more information about
file manipulation commands in Macsyma.

&FILENAME_MERGE("filename1", "filename2", ...)

merges together filenames, using a "*" convention for unspecified
components of filenames, with the leftmost filenames getting
precedence.

&FILENAMES

Filenames and filepathnames are specified differently for different
operating systems.  Macsyma provides a generalized format for
specifying file pathnames in all versions.  This format is of the form
"directory:subdirectory;filename.extension" .

When specifying pathnames inside Macsyma on a DOS-Windows system, each
backslash in DOS and MS-Windows filenames must be replaced by two
consecutive backslashes in Macsyma. For example
c:\macsyma\user\mystuff.mac becomes in Macsyma
"c:\\macsyma\\user\\mystuff.mac", enclosed in double quote marks when
used in Macsyma commands.

See FILES_SUMMARY for more information on file manipulation commands.
See FILE_PATHNAMES for the pathname conventions.

&FILES - See FILES_SUMMARY.

&FILES_SUMMARY

A file is simply an area on a particular storage device which contains
data or text. Files on disks are figuratively grouped into
"directories".  A directory is just a list of all the files stored
under a given directory name.  

See FILENAMES for formats used to specify file pathnames in Macsyma.
DOS/MS-Windows users in particular should view this.

File names and pathnames:
 filename conventions                     FILENAMES
 pathname conventions                     FILE_PATHNAMES

Basic File operations:
 display the length of a file             FILELENGTH
 print on the screen the contents a file  PRINTFILE
 rename a file                            RENAMEFILE
 delete a file                            DELFILE

Retrieving information from a file
 Load a library file                      LOAD
 Execute a batch job                      BATCH, BATCON, DEMO
 Read numerical data from a file          READ_NUMERICAL_DATA,
                                          READ_NUM_DATA_TO_ARRAY,
                                          READ_NUM_DATA_TO_MATRIX

Placing information into a file
 Write a particular expression to a file  STRINGOUT
 Write specified data to a file           WRITE_DATA_TO_FILE
 Write all screen output to a file        WRITEFILE, APPENDFILE
 Close a WRITEFILE                        CLOSEFILE 
 Write generated FORTRAN or C to a file   GENTRANOUT, GENTRANSHUT

 Compile a file                           COMPILE_FILE,
 Translate a file to Lisp                 TRANSLATE_FILE  
 Save/load the state of Macsyma in a file SAVE, LOAD


&FILLARRAY(array1, list-or-array-or-matrix)

Fills array1 from list-or-array-or-matrix.  FILLARRAY returns its 
first argument.

If array1 is a floating-point (integer) array, then list-or-array-or-matrix 
should be either a list or matrix of floating-point (integer) numbers or 
another floating-point (integer) array.  If the dimensions of the arrays 
are different, array1 is filled in row-major order.  If there are not
enough elements in the list or array then the last element is used to 
fill out the rest of array1.  If there are too many then the remaining 
ones are thrown away.  

In case the second argument is a matrix it must be compatible in 
size with array1.   By `compatible' is meant: 

Suppose we have an  m x n  matrix M.

If array1 is declared via  array(A,m,n)  then 1-basing is 
used:  M[i,j] -> A[i,j]  (1 <= i <= m, 1 <= j <= n) .

If array1 is declared via  array(A,m-1,n-1)  then 0-basing
is used:  M[i,j] -> A[i-1,j-1]  (1 <= i <= m, 1 <= j <= n) .

Otherwise the matrix and array1 are not compatible and 
 fillarray(a,m);  will signal an error.

Do EXAMPLE(FILLARRAY); for an example.

See also LISTARRAY.  See ARRAY_SUMMARY for a summary of commands for
manipulating arrays in Macsyma.

&FIND_SYMBOL(string)

Searches all symbols in Macsyma, including any names which the user
has mentioned in the current session, and returns a list of those
symbols which have the given string somewhere in their name.

See also APROPOS.

&FIRST(exp)

Returns the first part of expression exp, where exp may be

 a list    the first element of the list
 a matrix  the first row of a matrix
 a sum     the first term of a sum

Note that FIRST and its related functions, SECOND, THIRD, FOURTH,
FIFTH, SIXTH, SEVENTH, EIGHTH, NINTH, TENTH, REST and LAST, work
either on the form of exp which is displayed on output, or on the form
which is typed on input.   
 - If INFLAG (default:FALSE) is set to FALSE, these functions operate
   on the displayed form of the expression exp.
 - If INFLAG (default:FALSE) is set to TRUE, these functions operate
   on the internal form of exp.

Note that the simplifier re-orders expressions.  Thus 
 - If INFLAG=FALSE, then  FIRST(X+Y)  ->  Y
 - If INFLAG=TRUE,  then  FIRST(X+Y)  ->  X
FIRST(Y+X) gives the same results.

In plotting functions, the optional arguments FIRST, SAME, and LAST
are used to superimpose plots.

Do EXAMPLE(FIRST); for an example.

See also SECOND, THIRD, ..., TENTH, FIRST_ELEMENTS.

&FIRST_ELEMENTS(expr, n)

[FUNCTS package] Returns the first n elements of the list or
expression expr.

Do EXAMPLE(FIRST_ELEMENTS); for an executable example.

See also FIRST, LAST_ELEMENTS, PART, REST.

&FIX(x)

Converts its numerical argument by truncating toward zero.  

Examples:

argument  FLOOR  CEILING  FIX  ROUND 
 2/3       0      1        0    1
-2/3      -1      0        0   -1

Do EXAMPLE(FIX); for an example.

See also CEILING, FLOOR, ROUND.

&FIXNUM

A subtype of integer which specifies a range of integers that are
efficient to represent.  Usually FIXNUMs are those integers which can
be stored in a single machine word. Although the range of FIXNUMs is
machine dependent, integers of type FIXNUM will always be of smaller
magnitude than integers of type BIGNUM.

&FLATTEN(expr)

Flattens an expression expr with respect to its topmost operator.
Usually expr is a list, in which case FLATTEN removes all outer 
list structure below the top.

As a simple example, flatten([[a,b],[c,d]]); gives [a, b, c, d] .

FLATTEN is similar to DECLAREing a function NARY and to 
MAT_UNBLOCKER but is different from both.

For many cases where expr is a list, PARTITION_LIST is an inverse
operation to FLATTEN.

Do EXAMPLE(FLATTEN); for an executable example.

&FLIPFLAG default:FALSE

[ITENSOR package] Affects the order in which renaming of tensor
indices proceeds with the command RENAME. When FLIPFLAG is FALSE, the
indices will be renamed according to the order of the covariant
indices; when TRUE, according to the order of the contravariant
indices.

&FLOAT default:FALSE

If TRUE, all rational numbers and bigfloats are converted to floating
point numbers automatically during simplification.  This option
variable is an EVFLAG by default.

FLOAT(exp)

This function is obsolete.  Use SFLOAT, DFLOAT or BFLOAT instead.

&FLOATP(exp)

If exp is a floating point number, then returns TRUE, else returns
FALSE.  

See also SFLOATP, DFLOATP, BFLOATP, FLOAT.

&FLOAT_MINUS_EPSILON

An obsolete synonym for SFLOAT_MINUS_EPSILON.

&FLOAT_PLUS_EPSILON

An obsolete synonym for SFLOAT_PLUS_EPSILON.

&FLOAT_PRINT_DIGITS_AFTER_POINT default:FALSE

Controls the number of digits to print after the decimal point when
displaying floating point numbers.  

FLOAT_PRINT_DIGITS_AFTER_POINT must be FALSE or a non-negative
integer. If it is a non-negative integer, then that is the number of
digits that will be printed after the decimal point.  Bigfloat numbers
are not affected by this variable.

The two variables FLOAT_PRINT_DIGITS_AFTER_POINT and FLOAT_PRINT_WIDTH
are essentially independent of one another, but when both are set, the
settings should be compatible.

&FLOAT_PRINT_WIDTH default:0

Controls the width of the field used to display floating point
numbers.  FLOAT_PRINT_WIDTH must be an integer.

 - If FLOAT_PRINT_WIDTH=0, then the width of the field in which a
   floating point number is printed depends on the number of
   characters in the number.

 - If FLOAT_PRINT_WIDTH is a positive integer, then floating point
   numbers are displayed in a field of fixed width of that size,
   including the sign of the number, if any.  If necessary, the number
   is shortened and rounded to fit.  If the floating point number is
   shorter than FLOAT_PRINT_WIDTH, then the number is right-justified
   in the field, and the left part of the field is padded with spaces.

 - If FLOAT_PRINT_WIDTH is a negative integer, then floating point
   numbers are displayed as when FLOAT_PRINT_WIDTH is positive, with
   one exception:  if the number is shorter than FLOAT_PRINT_WIDTH
   then the number fills the field starting from the left side.

See also FLOAT_PRINT_DIGITS_AFTER_POINT, INTEGER_PRINT_WIDTH.

&FLOAT2BF default:FALSE

If FALSE, then a warning message is printed when a floating point
number is converted into a bigfloat number (since this may lead to
loss of precision).

&FLOATNUM_SUMMARY

Floating point numbers are numbers expressed as a mantissa of specified
precision and an exponent of ten.  A floating point number 
representation is specified by the number of digits precision of the 
mantissa and the range of the exponent of ten.

Macsyma has three kinds of floating point numbers.

o single precision floating point numbers, called sfloats.

  Examples: 1.4142135 or 1.4142135e0

  Sfloats have about 7 digits of precision in the mantissa and
  exponents of ten roughly in the range [-38,38].

o double precision floating point numbers, called dfloats.

  Example: 1.4142135623730951d0

  Dfloats have about 14 digits of precision in the mantissa and
  exponents of ten roughly in the range [-306,306].

o arbitrary precision floating point numbers, called bigfloats or
  bfloats.

  Examples: 1.4142135623730950488b0
            1.4142135623730950488016887242096980785696718753770b0

  Bfloats have an arbitrary precision in the mantissa which is 
  settable by the use, which defaults to 20 digits.  Exponents
  have a range which is limited only by the hardware and software
  limitations of your computer.



Functions which create or manipulate floatnums in Macsyma.

                         Sfloats      Dfloats      Bfloats
                         -------      -------      -------
Convert to floats        SFLOAT       DFLOAT       BFLOAT
Check for floats         SFLOATP      DFLOATP      BFLOATP
                         FLOATP       FLOATP

Set precision of bfloats                           BFPRECISION


Option variables which alter the behavior of floatnums in Macsyma.

                         Sfloats      Dfloats      Bfloats
                         -------      -------      -------
Control conversion of
rationals to floats      KEEPFLOAT    KEEPFLOAT

Notification of
conversion to bfloats    FLOAT2BF     FLOAT2BF

Display of floatnums     FLOAT_PRINT_DIGITS_AFTER_POINT
                         FLOAT_PRINT_WIDTH
                                                   BFPRINT_PRECISION
                                                   BFTRUNC

Precision of floats
in generated FORTRAN     FORTRAN_FLOAT_PRECISION



System variables which provide information about floatnums in Macsyma
on your computer.

                         Sfloats               Dfloats  
                         -------               -------  
Largest positive float   MOST_POSITIVE_SFLOAT  MOST_POSITIVE_DFLOAT
Largest negative float   MOST_NEGATIVE_SFLOAT  MOST_NEGATIVE_DFLOAT

float closest to zero    LEAST_POSITIVE_SFLOAT LEAST_POSITIVE_DFLOAT
                         LEAST_NEGATIVE_SFLOAT LEAST_NEGATIVE_DFLOAT

Finest resolution        SFLOAT_PLUS_EPSILON   DFLOAT_PLUS_EPSILON
                         SFLOAT_MINUS_EPSILON  DFLOAT_MINUS_EPSILON

See NUMBER_TYP9E_COERCION for a summary of Macsyma's policies
on automatic conversions of number types.

&FLOATNUMP is now obsolete. See FLOATP instead.

&FLOATP(exp)

If exp is a floating point number, then returns TRUE, else returns FALSE.

Do EXAMPLE(FLOATP); for an example.

See also PREDICATES.

&FLOOR(exp)

Returns the largest integer less than or equal to exp where exp is numeric.  
ENTIER and FLOOR are synonyms.

diff(floor(x),x); gives 0 .

Examples:

  argument  FLOOR  CEILING  FIX  ROUND 
  --------  -----  -------  ---  -----
   2/3       0      1        0    1
  -2/3      -1      0        0   -1

Do EXAMPLE(FLOOR); for an example.

See also MAKEFLOOR.

&FLUSH(exp, tensor1, tensor2, ...)

[ITENSOR package] Sets to zero, in exp, all occurrences of the tensori
that have no derivative indices.

&FLUSHD(exp, tensor1, tensor2, ...)

[ITENSOR package] Sets to zero, in exp, all occurrences of the tensori
that have derivative indices.

&FLUSH1DERIV(exp, tensor)

[ITENSOR package] Sets to zero, in exp, all occurrences of tensor that
have exactly one derivative index.

&FLUSHND(exp, tensor, n)

[ITENSOR package] Sets to zero, in exp, all occurrences of the
differentiated object tensor that have n or more derivative indices as
the following example demonstrates.

 (c1) ISHOW(A([I,@J,@R],K,R) + A([I,@J,@R,@S],K,R,S)); 
                                j r s     j r
 (d1)                          a       + a
                                i,k r s   i,k r

 (c2) ISHOW(FLUSHND(D1,A,3));
                                      j r
 (d2)                                a
                                      i,k r

&FOR

Used in iterations.  See "DO" for a description of Macsyma's iteration
facilities.

&FORGET(pred1 {, pred2, ...})

Removes relations established by ASSUME.  The predicates may be
expressions equivalent to (but not necessarily identical to) those
previously ASSUMEd.  FORGET(list) is also a legal form.

Do EXAMPLE(FORGET); for an example.

See also ASSUME, CONTEXT.  

See also REM, REMFUNCTION, REMOVE, REMRULE, REMVALUE for commands
to remove other types of information from the Macsyma environment.
Do USAGE(PROPERTIES); for an overview of Macsyma commands to manage
properties of symbols.

&FORTCURRIND default:0

[GENTRAN package] Specifies the number of blank spaces printed at the
beginning of each line (after column 6) of FORTRAN code generated with
the GENTRAN or GENTRANIN command.

&FORTINDENT default:0

Controls the left margin indentation of expressions printed out by the
FORTRAN command.  0 gives normal printout (i.e. 6 spaces), and
positive values will causes the expressions to be printed farther to
the right.

&FORTLINELEN default:72

[GENTRAN package] Specifies the maximum number of characters printed
on each line of FORTRAN code generated with the GENTRAN or GENTRANIN
command.

&FORTMX(matname, mat)

This command is now obsolete.

Converts a Macsyma matrix mat into a sequence of FORTRAN assignment
statements of the form matname(i,j)=<corresponding matrix element>.
FORTMX(matname,mat); may now be done as FORTRAN(matname=mat);.  (If
"matname" is bound, FORTRAN('matname=mat); may be necessary.)

Please convert code that uses the FORTMX command as it may be flushed
some day.

&FORTRAN(exp)

Converts the expression exp into a FORTRAN linear expression in legal
FORTRAN.  If exp is a bound symbolic atom, then X={value of X} will be
generated.  For example,

 (c1) X:A*B$
 (c2) FORTRAN(X)$
       X=A*B

In particular, if the value of exp is a matrix, then FORTRAN(exp);
will generate the appropriate assignment statements of the form
name(i,j)=<corresponding matrix element>.  For example,

 (c3) M: [A, B ; C, D]$
 (c4) FORTRAN(M)$
       M(1,1)=A
       M(1,2)=B
       M(2,1)=C
       M(2,2)=D

Format of Generated Output:
--------------------------
 - Generated FORTRAN code has 6 spaces inserted at the beginning of
   each line, continuation lines, and ** rather than ^ for
   exponentiation.
 - FORTINDENT (default:0) controls the left margin of expressions
   printed out. A value of 0 yields the normal margin (i.e. indented 6
   spaces).  Increasing it will cause the expression to be printed
   further to the right.
 - When the option FORTSPACES (default:FALSE) is TRUE, then the
   FORTRAN command fills out to 80 columns using spaces.

Do EXAMPLE(FORTRAN); for an example.

See also GENTRAN, which has a more powerful generator of FORTRAN code. 

&FORTRAN_FLOAT_PRECISION default:DOUBLE

On all platforms FORTRAN_FLOAT_PRECISION affects what happens when
FORTRAN is called on bfloats or rational numbers or other such stuff.
It has two possible values: DOUBLE and SINGLE.

On platforms other where dfloats are the only "machine" floats
available in Macsyma, and they are printed in Macsyma or Lisp as
sfloats, FORTRAN_FLOAT_PRECISION controls how FORTRAN prints floats, 
i.e. with `d's or not.  The Lispm doesn't need this help as the user
can choose to use sfloats or dfloats as they wish and the FORTRAN
command will follow suit.

&FORTRAN_LINEL default:FALSE

Is the override line length to use in FORTRAN code if default length
is wrong.  If this is FALSE, the default will be the minimum of 72 and
the current line length (see LINEL).

&FORTSPACES default:FALSE

If TRUE, the FORTRAN command fills out to 80 columns using spaces.

&FOURIER(expr, x, xi)

[FOURIERT package] The FOURIER command computes the symbolic Fourier
transform of expr in the variable x and produces the transform in the
variable xi. The INV_FOURIER command computes the inverse transform.
The FOURIER and INV_FOURIER commands work with infinite or finite
intervals, and can compute symbolic transforms involving abs, signum,
and delta functions.

Do EXAMPLE(FOURIER); for an example and DEMO(FOURIERT); for a longer
demonstration of Fourier transforms.

The FOURIER package computes symbolic Fourier integral coefficients
and transforms on finite and infinite intervals.

Do USAGE(FOURIER); for more information.

Do DEMO(FOURIER); for a demonstration of Fourier series.

The FFT package computes numerical provides Fast Fourier Transforms.
Do USAGE(FFT); for more information and DEMO(FFT); for a demonstration.

See also FOURIER_COEFFS, FOURIER_SERIES, FOURIER_EXPAND,
FOURIER_COS_COEFFS, FOURIER_SIN_COEFFS, FOURIER_INT_COEFFS,
FOURIER_COSINT_COEFFS and FOURIER_SININT_COEFFS. 

&FOURIER_COEFFS(f, x, p)

[FOURIER package] Computes the Fourier cosine and sine coefficients of
function f(x) on the interval [-p,p].

Do EXAMPLE(FOURIER_COEFFS); for an example.

&FOURIER_COS_COEFFS(f, x, p)

[FOURIER package] Computes the Fourier cosine coefficients of the even
function f(x) on the interval [0,p].

Do EXAMPLE(FOURIER_COS_COEFFS); for an example.

See also FOURIER_SIN_COEFFS, FOURIER_COSINT_COEFFS, COSFFT and
FOURIER_COEFFS.

&FOURIER_COSINT_COEFFS(f, x)

[FOURIER package] Computes Fourier cosine integral coefficients for
f(x) on the interval [0,INF).

Do EXAMPLE(FOURIER_COSINT_COEFFS); for an example.

See also FOURIER_SININT_COEFFS, FOURIER_INT_COEFFS and FOURIER_COEFFS.

&FOURIER_DPREC

Do USAGE(FFT)$

&FOURIER_EXPAND(clist, x, p, climit)

[FOURIER package] Generates the Fourier series from the list of
Fourier coefficients clist, up through climit terms (climit can be
INF).  x and p have the same meaning as in FOURIER_COEFFS.

Do EXAMPLE(FOURIER_EXPAND); for an example.

See also FOURIER_COEFFS and FOURIER_SERIES.

&FOURIER_INT_COEFFS(f, x)

[FOURIER package] Computes the Fourier integral coefficients for f(x)
on the interval (MINF,INF):
  A[z] := integrate(f(x)*cos(z*x),x,minf,inf)/%pi
  B[z] := integrate(f(x)*sin(z*x),x,minf,inf)/%pi

The Fourier integral is given by
  F(z) := 1/2*(A[z] - %i*B[z]) .

Do EXAMPLE(FOURIER_INT_COEFFS); for an example.

See also FOURIER_COSINT_COEFFS, FOURIER_SININT_COEFFS and FOURIER_COEFFS.

&FOURIER_SCALEP

Do USAGE(FFT)$ for more information.

&FOURIER_SERIES(f, x, p)

[FOURIER package] Generates the infinite Fourier series of F(X)
defined on the interval [-p,p].  FOURIER_SERIES(F,X,P) is the same as
FOURIER_EXPAND(FOURIER_COEFFS(F, X, P), X, P, 'INF) .

Do EXAMPLE(FOURIER_SERIES); for an executable example and
DEMO(FOURIER); for a longer demonstration. 

&FOURIER_SIN_COEFFS(f, x, p)

[FOURIER package] Computes the Fourier sine coefficients of the odd
function f(x) on the interval [0,p].

Do EXAMPLE(FOURIER_SIN_COEFFS); for an example.

See also FOURIER_COS_COEFFS, FOURIER_SININT_COEFFS, SINFFT and
FOURIER_COEFFS.

&FOURIER_SININT_COEFFS(f, x)

[FOURIER package] Computes Fourier sine integral coefficients for f(x)
on the interval [0,INF).

See also FOURIER_COSINT_COEFFS, FOURIER_INT_COEFFS and FOURIER_COEFFS.

&FOURTH(exp)

Returns the fourth part of exp.  It is affected by INFLAG, in the same
way as FIRST.

&FPPREC

An obsolete name for BFPRECISION.

&FPPRINTPREC

An obsolete name for BFPRINT_PRECISION.

&FR

[CTENSOR package] the frame field, stored as a matrix.
                                  i             
   frame_vector : coord_vector  FR     (sum over i).
               a              i    a

In the ITENSOR package, the frame field is denoted by IFR. 

See also FRI.

&FRAME_BRACKET(ff, ffi, diagframe)

[CTENSOR package] Computes the structure coefficients of the Lie
algebra defined by the Lie brackets of a vector frame field, and
stores the result in the array FB[a,b,c].  fr and fri are the frame
field and inverse frame field respectively (expressed as a matrices),
and diagframe [TRUE or FALSE] indicates whether fr is a diagonal
matrix.  (Redundant input is used in order to avoid recalculating fr
and diagframe when FRAME_BRACKET is called internally by CTENSOR).

                                          c
   [ frame_vector , frame_vector ] = FB     coord_vector  (sum over c)
                 a              b      a b              c

&FREEOF(x1, x2, ..., exp)

If the xi do not occur in the expression exp, then returns TRUE,
otherwise returns FALSE.  The xi are atoms or they may be subscripted
names, functions (e.g.  SIN(X) ), or operators enclosed in "s.

If 'var' is a "dummy variable" in exp, then FREEOF(var,exp); will
return TRUE.  Example:  FREEOF(I,'SUM(F(I),I,0,N)); returns TRUE.

Do EXAMPLE(FREEOF); for an example.

See also NON_ZERO_AND_FREEOF and PREDICATES.

&FRI

[CTENSOR package] The frame field inverse, stored as a matrix.
                                   a             
   coord_vector : frame_vector  FRI     (sum over a).
               i              a     i

In the ITENSOR package, the frame field inverse is denoted by IFRI. 

See also FR.

&FULL_LOGCON default:TRUE

If TRUE, LOGCONTRACT sorts the expression it is given to enable
enhanced contraction opportunities.  If FULL_LOGCON is FALSE, then
LOGCONTRACT will contract only what it sees syntactically in the
expression.

&FULLMAP(fn, exp1, ...)

Is similar to MAP but FULLMAP will keep mapping down all subexpressions 
until the main operators of the expi (if there are more than one) are 
no longer the same or until mapatoms are met.  

The user should be aware that FULLMAP is used by the Macsyma simplifier 
for certain matrix manipulations; thus, the user might see an error 
message concerning FULLMAP even though FULLMAP was not explicitly called 
by the user.  FULLMAP is affected by the setting of INFLAG. 

Example:

 (c1) A+B*C$

 (c2) FULLMAP(G,%);

 (d2)              g(b) g(c) + g(a)

 (c3) MAP(G,D1);

 (d3)                g(b c) + g(a)

Do EXAMPLE(FULLMAP); for an example.

See also FULLMAPL, MAP, INFLAG and MAPATOM.

&FULLMAPL(fn, list1, ...)

Is similar to FULLMAP but it only maps onto lists and matrices.

 (c1) FULLMAPL("+",[3,[4,5]],[[A,1],[0,-1.5]]);

 (d1)                      [[a + 3, 4], [4, 3.5]]

Do EXAMPLE(FULLMAPL); for an example.

See also FULLMAP, MAP, MATRIXMAP, OUTERMAP.

&FULLRATSIMP(exp)

FULLRATSIMP repeatedly applies RATSIMP followed by non-rational
simplification to an expression until no further change occurs.
FULLRATSIMP(exp,var1,...,varn) takes one or more arguments as do
RATSIMP and RAT.

If exp is a non-rational expression, then one call to RATSIMP followed
by non-rational ("general") simplification may not be sufficient to
return a fully simplified result.  Sometimes, more than one
application of RATSIMP may be necessary.

Example:

 (c1) EXP : (X^(A/2)+1)^2*(X^(A/2)-1)^2/(X^A-1)$

 (c2) RATSIMP(EXP);
                                  2 a      a
                                 x    - 2 x  + 1
 (d2)                            ---------------
                                      a
                                     x  - 1

 (c3) FULLRATSIMP(EXP);
                                       a
 (d3)                                 x  - 1

 (c4) RAT(EXP);
                               a/2 4       a/2 2
                             (x   )  - 2 (x   )  + 1
 (d4)/R/                     -----------------------
                                      a
                                     x  - 1


Do EXAMPLE(FULLRATSIMP); for an example.

&FULLRATSUBST(a, b, c)

Is the same as RATSUBST except that it calls itself recursively on its
result until that result stops changing.  This function is useful when
the replacement expression and the replaced expression have one or
more variables in common.  FULLRATSUBST will also accept its arguments
in the format of LRATSUBST.  That is, the first argument may be a
single substitution equation or a list of such equations, while the
second argument is the expression being processed.

Do EXAMPLE(FULLRATSUBST); for an example, and DEMO(LRATS); for a 
longer demonstration.

See also RATSUBST, LRATSUBST, SUBST, SUBSTPART.

&FULL2BANDA(ba, fa, dim, nsband)

[BANDMAT package] Converts a matrix in full storage scheme to banded
storage scheme. The full matrix is input as an array FA, and the
banded matrix is output as an array BA.  dim is the dimension of the
(square) matrices and of the vectors, and NSBAND is the bandwidth.

Do USAGE(BANDMAT); for more information.

&FULL2SBANDA(sba, fa, dim, nsband)

[BANDMAT package] Converts a matrix in full storage scheme to
symmetric banded storage scheme. The full matrix is input as an array
FA, and the banded matrix is output as an array BA.  If the input
matrix is not symmetric, then FULL2SBANDA will use the upper band to
define the symmetric banded matrix.  dim is the dimension of the
(square) matrices and of the vectors, and NSBAND is the
half-bandwidth.

Do USAGE(BANDMAT); for more information.

&FUNCSOLVE(eqn, g(t))

[NUSUM package] Gives [g(t) = ...]  or [], depending on whether or not
there exists a rational function g(t) satisfying eqn, which must be a
first order, linear polynomial in (for this case) g(t) and g(t+1).

 (c1) FUNCSOLVE((N+1)*F(N)-(N+3)*F(N+1)/(N+1) =
      (N-1)/(N+2),F(N));
                                    n
 (d1)                 f(n) = ---------------
                             (n + 1) (n + 2)

Warning: this is a very rudimentary implementation--many safety checks
and obvious generalizations are missing.

FUNCSOLVE autoloads the NUSUM package.

Do EXAMPLE(FUNCSOLVE); for an example.

&FUNCTION

To define a function in Macsyma you use the := operator.  For example,
F(X):=SIN(X) defines a function F.

See also DEFINE, FUNMAKE, FUNMAKE_NO_SIMP, LAMBDA.

&FUNCTIONS default:[]

Evaluates to a list of the names of all user defined functions (set up
by f(x):=...).

Do EXAMPLE(FUNCTIONS); for an example.

For special functions defined in Macsyma, see also SPECIAL_FUNCTIONS,
SPECFUN.

&FUNCTS

A library package which contains a collection of miscellaneous
functions. 

Do USAGE(FUNCTS); for more information.

Do DEMO(FUNCTS); for a demonstration.

See also ALGFUNCS CALFUNCS, GEOFUNCS and MATFUNCS.

&FUNDEF(funname)

Returns the function definition associated with "funname".
FUNDEF(funname); is similar to DISPFUN(funname); except that FUNDEF
does not invoke display.

Do EXAMPLE(FUNDEF); for an example.

&FUNMAKE(funname, [arg1 ,..., argn])

Returns funname(arg1,...,argn) without calling the function funname.

Do EXAMPLE(FUNMAKE); for an example.

See also ":=" and FUNMAKE_NO_SIMP.

&FUNMAKE_NO_SIMP(funname, [arg1, ..., argn])

Returns funname(arg1,...,argn) without calling the function funname,
nor permitting any subsequent automatic simplification on the
resulting funname(arg1,...,argn), by falsely recording that the
expression has already been simplified.

You can construct "unstable" or illegal expressions like 2+2, or 1/0,
which may even be ill-formed and undisplayable.  The utility of such
subversion, besides fulfilling basic antisocial urges, is pretty much
limited to constructing unsimplified displays, or arguments to
TELLSIMP (e.g.  TELLSIMP(''(FUNMAKE_NO_SIMP("^",[0,0])),1);), or for
reference to deliberately unsimplified subexpressions (e.g. 2^1,
SIGNUM(1/x)) occasionally returned by the simplifier.  Any serious
attempt to compute with results from FUNMAKE_NO_SIMP without first
RESIMPLIFYing them will probably violate Macsyma's internal
conventions, and lead to unpleasant surprises.

Do EXAMPLE(FUNMAKE_NO_SIMP); for an example.

See also ":=" and FUNMAKE.

&GAMALG

This package is no longer supported.

&GAMMA_INCOMPLETE(a, x)

Computes the incomplete GAMMA  function numerically.

The Incomplete GAMMA function is

GAMMA_INCOMPLETE(a, x) = INTEGRATE(exp(-t)*t^(a-1),t,0,x);

Do EXAMPLE(GAMMA_INCOMPLETE); for an example.

See also GAMMA_INCOMPLETE_C.

&GAMMA_INCOMPLETE_C(a, x)

Computes the incomplete GAMMA (complement) function numerically.

The Incomplete GAMMA (complement) function is

GAMMA_INCOMPLETE(a, x) = INTEGRATE(exp(-t)*t^(a-1),t,x,inf);

Do EXAMPLE(GAMMA_INCOMPLETE); for an example.

See also GAMMA_INCOMPLETE_C.

&GAMMA(X)

The gamma function.  GAMMA(I)=(I-1)!  for I a positive integer.  For
the Euler-Mascheroni constant, see %GAMMA.  The variable GAMMALIM
(default:1000000) controls simplification of the gamma function.

GAMMA(A, X)
  Is one variant of the "Incomplete Gamma Function", and is defined as
  'INTEGRATE(EXP(-T)*T^(A-1),T,X,INF).  It is related to the GAMMA
  function by: GAMMA(A)=GAMMA(A,0).

See CGAMMA for the complex gamma function.  

See also BFFAC, CBFFAC, FACTORIAL, MAKEFACT, MAKEGAMMA, GAMMA_DISTRIB,
and GAMMA_REFLECT.

&GAMMA_DENSITY(x, alpha, beta)

[UNIPROB package] The gamma probability density

                 alpha - 1   - x/beta
                x          %e
        f(x) =  ---------------------    x > 0
                                alpha
                gamma(alpha) beta

        f(x) =         0                 x <= 0.

See also GAMMA_DISTRIB, WISHART_MDF.

&GAMMA_DISTRIB(x, alpha, beta)

[UNIPROB package] The cumulative gamma distribution.

See also GAMMA_DENSITY, INV_GAMMA_DISTRIB.

&GAMMA_REFLECT(exp)

Implements the gamma reflection formula (AS p. 256 6.1.17).

Do EXAMPLE(GAMMA_REFLECT); for an example.

&GAMMALIM default:1000000

Controls simplification of the gamma function for integral and
rational number arguments.  If the absolute value of the argument is
not greater than GAMMALIM, then simplification will occur.  Note that
the FACTORIAL_LIMIT switch controls simplification of the result of
GAMMA of an integer argument as well.

&GAUSS_LEGENDRE_COEFF(a, b, N)

Calculates the N-point gauss-legendre coefficients for quadrature
on the finite interval [a, b] using BFLOATs. Returns a list in the
form [x,w] where x are the abscissas, and w are the corresponding
weights.

&GAUSS_LEGENDRE_INT(f, a, b {, N})
 or
GAUSS_LEGENDRE_INT(f(x), x, a, b {, N})

Numerically integrates the univariate function f over the finite
interval [a,b] using an N point Gauss-Legendre quadrature using
BFLOATs (N=20 default). If N#20 or BFPRECISION#20 then new quadrature
points are calculated. 

Do EXAMPLE(GAUSS_LEGENDRE_INT); for an example;

&GAUSSIMP(expr)

[STOCH package] Performs simplifications of expression expr
containing Gaussian random variables.  GAUSSIMP reduces all 
expectation values of the form <<GPOL*nonran^QPOL>> (where GPOL
is a polynomial  {possibly 1} in Gaussian random variables, and
QPOL is a  polynomial {possibly zero} of degree 2 or less in
Gaussian variables), to expressions containing only means and
(co)variances of the Gaussian variables.  This is done by means
of the following three rules:

 - << gpoly >> -> polynomials in means and variances,

 - << nonran^gexpr >>  ->  nonran^<< gexpr >>
    * exp((<<expand(gexpr^2)>>-<<expand(gexpr)>>^2) * log(nonran)^2/2)

 - << gpoly * nonran^qpol >> -> computed_value

where gpoly is a polynomial in Gaussian variables, subscripted 
variables, functions, subscripted functions and  formal sums and 
integrals of such functions, nonran is an expression containing no 
random variables, and gexpr is an expression which is Gaussian 
(i.e., a linear combination, not necessarily finite, of Gaussian 
random variables and functions), and computed_value indicates the 
expression which would be obtained by integrating over the joint 
distribution function of the Gaussian variables.  This simplification
is performed sequentially over statistical dependency groups, so that
it is actually possible to simplify expressions such as 
<<exp(x^2*y^2)>> (x and y Gaussian but from separate statistical 
dependency groups); however in this case the result depends on the 
order in which the dependency groups were declared by RANDOMIZE.  

NOTE: The present version of GAUSSIMP does not check whether the 
expectation value << gpol*exp(qpol) >> is actually convergent, which 
depends on the magnitude of the coefficients of positive quadratic 
terms in qpol in relation to the variances of the Gaussian variables.
In such a case, computed_value is actually an analytic continuation 
of the (non-convergent) expectation value.  The presence of square 
roots of negative expressions probably indicates such non-convergence;
their absence is not proof of convergence, since cancellations may
occur between multiple non-convergent dimensions of the expectation 
integral.

&GAUSSIMP_USES_RECURSION default:FALSE

[STOCH package] 

 - When TRUE, GAUSSIMP will simplify expressions of the form  
   << gpoly >> by means of a recursive rule.

 - When FALSE, such expressions are replaced by an explicitly computed 
   value.  For zero-mean and/or uncorrelated random variables, the 
   direct computation is faster.  However, when multiple, correlated, 
   nonzero-mean variables are involved, the direct computation requires
   the handling of very large intermediate expressions, and the 
   recursive rule may be substantially faster.

&GC_VERBOSE default:FALSE

If set to TRUE, allows garbage collection messages to be printed. If
FALSE, the default, all garbage collection messages are suppressed.

&GCD(p1, p2 {, var1, ...})

Computes the greatest common divisor of p1 and p2.  The flag GCD
(default:SPMOD) determines which algorithm is employed.  Setting GCD
to EZ, SUBRES, RED, or SPMOD selects the EZGCD, subresultant PRS, 
reduced, or modular algorithm, respectively.  If GCD:FALSE then 
GCD(p1,p2,var) will always return 1 for all var.  Many functions 
(e.g.  RATSIMP, FACTOR, etc.) cause gcd's to be taken implicitly.  
For homogeneous polynomials it is recommended that GCD:SUBRES 
be used.  To take the gcd when an algebraic is present, e.g.  
GCD(X^2-2*SQRT(2)*X+2,X-SQRT(2)); , ALGEBRAIC must be TRUE and
GCD must be either ALGEBRAIC or SUBRES.  If you set GCD:'ALGEBRAIC$
then Macsyma will select the SUBRES algorithm if algebraics are
present, and the SPMOD algorithm if algebraics are not present.  
(This is an example of a polyalgorithmic approach in Macsyma.  
It may take a little time to check whether algebraics are present, 
but that time spent may be worth it.

The GCD flag, default:SPMOD, if FALSE will also prevent the 
greatest common divisor from being taken when expressions are 
converted to CRE form.  This will sometimes speed the calculation 
if gcds are not required.

Do EXAMPLE(GCD); for an example.

See also EZGCD.

&GCDIVIDE(poly1, poly2)

[ALGFUNCS package] Divides poly1 by poly2, but removes common
factors of poly1 and poly2 first.

&GCDN(A)

[MATRICE package] Returns the greatest common divisor of the elements
in the list, matrix or matrice A.  

See also MATRICE.

&GCFACTOR(n)

Factors the Gaussian integer n over the Gaussians, i.e.  numbers of the
form a + b i where a and b are rational integers (i.e.  ordinary
integers).  Factors are normalized by making a and b non-negative.

Do EXAMPLE(GCFACTOR); for an example.  

See also FACTOR, GFACTOR.

&GD(x)

[ALGFUNCS package] The Gudermannian function of x.  It equals
2*ATAN(%E^x)-%PI/2.   

See also AGD(X).

&GEGENBAUER

The SPECFUN package has two functions for computing Gegenbauer
polynomials for -1/2 < A and A # 0:
GEGENBAUER_C(N,A,X) and GEGENBAUER_C[N](A,X) .

&GEGENBAUER_C(N, A, X)

[SPECFUN package] Computes the Gegenbauer polynomial C(N,A,X) for
nonnegative integer N and real A > -1/2, A#0.

GEGENBAUER_C[N](A,X)
  Is an alternative syntax, which stores the Gegenbauer polynomials of
  order less than or equal to N.

Do LOAD(SPECFUN); to access this function.

&GEN_STUDENTS_MDF(Z, P, Q, n {, pdet, qdet})

The multivariate generalized Students probability density function
with zero mean value.

Arguments:
 - Z is a p x q matrix of independent random variables, 
   where each element of Z is a real number.
 - P is a p x p positive definite symmetric matrix.
 - Q is a q x q positive definite symmetric matrix.
 - n is the number of degrees of freedom.  It can be a number or 
   mathematical expression.
 - pdet is the determinant of the matrix P.  If you know vdet,
   you can specify it and save the time needed to recompute it.
 - qdet is the determinant of the matrix Q.  If you know wdet,
   you can specify it and save the time needed to recompute it.

                            (n-p)/2      q/2
                      det(Q)       det(P)
 GEN_STUDENTS_MDF = k -----------------------
                                          n/2
                      det(Q + Z^` . P . Z)

Do EXAMPLE(GEN_STUDENT_MDF); for an example.

See also STUDENTS_MDF, STUDENTS_T_DENSITY.

&GENCIRCULANT(array, rows {, cols, offset, stepsize})

Generates a circulant matrix from the array. If a selected element of
the array doesn't exist a symbolic one will be created.  On the main
diagonal is array[offset]. At the upper right corner is
array[offset+cols-1].  After the first row, each succeeding row is
advanced to the right by stepsize (default:1) with wraparound to the
left of the row.  If omitted, offset defaults to zero. If cols is also
omitted, it is taken to be equal to rows.

Do EXAMPLE(GENCIRCULANT); for an example.

See also CIRCULANT, GENMATRIX and GENVECTOR.

&GENDIFF(exp, var, n)

Differentiates exp with respect to var n times, where n may be
symbolic.  For example, when N is a nonnegative integer,

  GENDIFF(EXP(A*X),X,N); returns  A^N*EXP(A*X), 
whereas
  DIFF((EXP(A*X),X,N);   returns 'DIFF((EXP(A*X),X,N) .

GENDIFF can return derivatives of rational expressions in the
expressions (a*x^2+b*x+c)^n, and exp(a*x+b).  The numerator can 
include factors of log, cos, sin, cosh, sinh applied to (a*x+b).
GENDIFF can also return expressions for the derivative of a product
f1(x)*...*fn(x), where the fi(x) are unspecified functions.

Do EXAMPLE(GENDIFF); for an example and DEMO(GENDIFF); for a longer
demonstration.

See also DIFF.

&GENERATE

[ITENSOR package] This function has been renamed IC_CONVERT.

&GENF(lhs, rhs, dep_var, indep_var, order, initial_value_list)

[RECUR package] Implements the generating function method for solving
difference equations.  This method is applicable only to linear
constant-coefficient difference equations.  It might give incorrect
answers when applied to variable-coefficient difference equations.
The argument lhs is the recurrence equation being solved; rhs is the
inhomogeneous part of the expression, or zero; dep_var is the name of
the dependent variable; indep_var is the independent variable; order
is the order of the equation;initial_value_list, if given, is a list of
assignments specifying initial conditions.

For solving recurrence equations, users should first try the command
DIFFERENCEQ.

&GENFACT(X, Y, Z)

Is the generalized factorial of X which is:

  X*(X-Z)*(X-2*Z)*...*(X-(Y-1)*Z).

Thus, for integral X, GENFACT(X,X,1)=X!  and GENFACT(X,X/2,2)=X!!
which works for odd X because GENFACT takes CEILING of fractional Y.

Do EXAMPLE(GENFACT); for an example.

See also FACTORIAL.

&GENHANKEL(arrname, numrows {, numcols})

Generates a Hankel matrix with entries arrname[0], arrname[1] and so
forth.  numrows is the number of rows, and numcols is the number of
columns. If numcols is not specified, then it defaults to numrows, so
that the resulting matrix is square.

Do EXAMPLE(GENHANKEL); for an example.

See also HANKEL.

&GENINDEX default:I

Is the alphabetic prefix used to generate the next variable of
summation when necessary.

&GENINV

The GENINV library package has a function which computes the
Moore-Penrose generalized inverse of a matrix, using the function
PINV.  It also has a function LSQ_LINSOLVE which uses the generalized
inverse to find the least-squares solution of inconsistent systems of
linear equations.

Do  USAGE(GENINV); for more information.

Do DEMO(GENINV); for a demonstration. 

&GENMATRIX(arrayname, i2 {, j2 , i1, j1})

Generates a matrix from the array arrayname using arrayname(i1,j1) for
the first (upper-left) element and arrayname(i2,j2) for the last
(lower-right) element of the matrix.  If j1=i1 then j1 may be omitted.
If j1=i1=1 then i1 and j1 may both be omitted.  If i2=j2 and i1=j1=1,
then j2, i1, and j1 can all be omitted.  If a selected element of the
array doesn't exist a symbolic one will be used.

 (c1) H[I,J]:=1/(I+J-1)$

 (c2) GENMATRIX(H,3,3);
                            [   1  1]
                            [1  -  -]
                            [   2  3]
                            [       ]
                            [1  1  1]
 (d2)                       [-  -  -]
                            [2  3  4]
                            [       ]
                            [1  1  1]
                            [-  -  -]
                            [3  4  5]

Do EXAMPLE(GENMATRIX); for an example.

See also MATRIX, GENVECTOR, GENHANKEL, GENTOEPLITZ, GENVANDERMONDE. 

&GENSUMNUM default:0

The numeric suffix used to generate the next variable of summation.
If it is set to FALSE then the index will consist only of GENINDEX
with no numeric suffix.

&GENTOEPLITZ(arrname, numrows {, numcols, 'symmetric})

Generates a Toeplitz matrix with diagonal entries arrname[0],
subdiagonal elements arrname[-1], superdiagonal elements arrname[1]
and so forth. numrows specifies the number of rows, and numcols the
number of columns.  If numcols is unspecified, it defaults to numrows,
so that the resulting matrix is square.  If 'symmetric is specified,
then the matrix elements above the diagonal are repeated below the
diagonal by transposing, yielding a symmetric matrix.

Do EXAMPLE(GENTOEPLITZ); for an example.

See also TOEPLITZ.

&GENTRAN(statement1, statement2, ..., statementn {,[f1, f2, ..., fm]})

[GENTRAN package] translates Macsyma user level expressions into
FORTRAN, C, or RATFOR.  The language GENTRAN produces is determined by
the option variable GENTRANLANG (default:FORTRAN).


Arguments:
---------

 - statement1, statement2, ..., statementn 
   is a sequence of one or more statements, each of which is any
   Macsyma user level expression, (simple, compound, or block)
   statement, or procedure definition that can be translated into the
   target language.  Do USAGE(GENTRAN); for a listing of the special
   forms which can be translated.  A substantial subset of expressions
   and statements in the Macsyma programming language can be
   translated directly into numerical code.  You have the option of
   evaluating a Macsyma expression prior to translation.

 - [f1, f2, ..., fm]
   is an optional argument list containing one or more output
   destinations for generated code.  If no output destination is
   given, the generated code is simply written to the current output
   file, which is the terminal if no other files were specified (with
   GENTRANOUT, for example).  The possible output destinations are:

   a string  =  the name of an output file, e.g. "Mycode.fortran"
   TRUE      =  the terminal
   FALSE     =  the currently open output file(s) (see the function
                GENTRANOUT)
   ALL       =  all files currently open for output by GENTRAN, as
                determined by an explicit call to GENTRANOUT.

Examples:
--------

GENTRAN(statement, ["MYCODE.FORTRAN"]);
  outputs the translation of statement to the file MYCODE.FORTRAN.

GENTRAN(statement, ["MYCODE.FORTRAN",TRUE]);
  outputs the translation of statement to the file MYCODE.FORTRAN
  and also displays it on the terminal.

GENTRAN(statement, ["MYCODE.FORTRAN","PROGRAM.TXT",TRUE]);

   outputs the translation of statement to two files, MYCODE.FORTRAN
   and PROGRAM.TXT and also displays it on the terminal.

Return Value and Output:
-----------------------

GENTRAN returns (a list of) the name(s) of file(s) to which code was
written.

GENTRAN has facilities for directing the generated code to files.
GENTRANOUT opens a file or files to store the output from subsequent
calls to GENTRAN, and GENTRANSHUT closes the files.  When these files
are open, you can use GENTRANPUSH and GENTRANPOP to add and remove
files from the list of output files.  (See GENTRANOUT, GENTRANSHUT,
GENTRANPUSH, and GENTRANPOP.)  You can direct different pieces of the
translated output to different places.

Template Mode for Mixed-Language Files:
--------------------------------------

The GENTRANIN command enables GENTRAN to process template files which
contain both Macsyma code and FORTRAN (or C) code.  In template mode,
GENTRAN excises the Macsyma code, performs the indicated symbolic
computation, generates FORTRAN (C) code, and puts the generated
FORTRAN (C) code in the place where the Macsyma code was in the input
template file.

Do USAGE(GENTRAN); for more information.

Do DEMO(GENTRAN); and DEMO(GENTRAN2); for demonstrations of
generation of FORTRAN, and DEMO(GENTRANC); for a demonstration of
generation of C language code.

See also FORTRAN for a weaker FORTRAN generation command.

&GENTRANIN(f1, f2, ..., fn {, [g1, g2, ..., gm]})

[GENTRAN package] Translates the code in one or more files into
FORTRAN, C or RATFOR.  The file can contain a mixture of a foreign
language (FORTRAN, C or RATFOR) and Macsyma language.

Arguments:

 - Each argument f1, f2, ..., fn specifies a source of code to be
   translated, and has one of the following forms.

   Form of fi  Input Source
   ------      ------------
   a string    the name of a template (input) file,
               e.g. "translate-me.macsyma"
   TRUE        Display generated output on the terminal.

   GENTRANIN processes each template file f1, f2, ..., fn
   sequentially. 

 - [g1, g2, ..., gm] is an optional argument list which, if supplied,
   specifies one or more output destinations. 

   Form of gi    Output Location
   ----------    ---------------
   a string     the name of an output file, e.g. "mycode.fortran"
   TRUE         the terminal
   FALSE        the currently open output file(s)
                (see the function GENTRANOUT)
   ALL          all files currently open for output by GENTRAN, as
                determined by an explicit call to GENTRANOUT.

  If [f1, f2, ..., fm] is not supplied, then generated code is
  written to the current output file(s).


A template file may contain any number of parts, each of which is of
one of two types.
 - Active parts.  Active parts of template files consist of Macsyma
   language statements.  The contents of each active part are sent
   to Macsyma for evaluation.  The result of each evaluation is sent
   to the output file(s).  Typically, active parts consist of calls
   to GENTRAN, so that the result of evaluation is a statement in the
   target language (FORTRAN, C or RATFOR, depending on the value of
   the global variable GENTRANLANG).  Each active part starts with
   the delimiter << and ends with the delimiter >>.

 - Passive parts.  Passive parts of template files are assumed to
   contain code in the target language.  Each passive part is copied
   to the output.  Each comment delimited by the appropriate characters,
    C ... <cr>    for Fortran (beginning in column 1) or
    * ... <cr>    for Fortran (beginning in column 1),
    /* ... */     for C, and
    # ... <cr>    for Ratfor
   is also copied in its entirety to the output.  The character
   sequences << and >> do not delimit active regions within comments.


The result of processing a template file with GENTRANIN is a file in
the target language, where the passive parts of the original template
file have been replicated, and active parts have been replaced by
generated code in the target language.


GENTRANIN returns the name(s) of (all) file(s) which are written to by
the command.  The returned value(s) of GENTRANIN are printed only on
the terminal.

Do USAGE(GENTRAN); for a listing of the types of Macsyma expressions
that can be translated by GENTRAN.

Do EXAMPLE(GENTRAN); for an example of the GENTRAN command.

For demonstrations of the GENTRAN package, do
 DEMO(GENTRAN);  \
 and               for demonstrations of generating Fortran code, 
 DEMO(GENTRAN2); / 
 DEMO(GENTRANC); for a demonstration of generating C code,
 DEMO(GENTRANR); for a demonstration of generating RATFOR code.

&GENTRANLANG default:FORTRAN

[GENTRAN package] selects the target numerical language for the
GENTRAN and GENTRANIN commands.  Currently, GENTRANLANG must be
FORTRAN, RATFOR, or C.

&GENTRANOUT(f1 {, f2, ..., fn})

[GENTRAN package] Opens one or more files for output of code generated
by the GENTRAN or GENTRANIN commands.  Each argument f1, f2, ..., fn
specifies one or more output destinations.  The possible forms of the
fi are:
  Form of fi    Output location
  ----------    ---------------
   a string     the name of an output file, e.g. "mycode.fortran"
   TRUE         the terminal
   FALSE        the current output file(s)
   ALL          all files currently open for output by Gentran, from a
                previous call to GENTRANOUT, for example.

GENTRANOUT returns the list of current output file(s) after the command
has been executed.

See also GENTRANSHUT.

&GENTRANSHUT(f1, f2, ..., fn)

[GENTRAN package] closes one or more files opened by the GENTRAN or
GENTRANOUT commands.  Each argument f1, f2, ..., fn designates one
or more files. The possible forms for the fi are:

  Form of fi   Output Location
  ----------   ---------------
   a string    the name of an output file
   FALSE       the current output file(s)
   ALL         all files currently open for output by Gentran

GENTRANSHUT returns (a list of) the current output file(s) after the
command has been executed.

&GENVANDERMONDE(arrayname, numrows {, numcols})

Generates a Vandermonde matrix with second column arrayname[1],...,
arrayname[numrows].  numrows is the number of rows, and numcols is the
number of columns.  If numcols is not specified, then it defaults to
numrows, so that the resulting matrix is square.

Do EXAMPLE(GENVANDERMONDE); for an example.

See also VANDERMONDE.

&GENVECTOR(arrayname, i2 {, i1})

Generates a column matrix from array arrayname using arrayname(i1) for
the first (top) element and arrayname(i2) for the last (bottom)
element of the matrix.  If i1 = 1 then i1 can be omitted.  If a
selected element of arrayname doesn't exist, a symbolic one is used.

Do EXAMPLE(GENVECTOR); for an example.

See also GENMATRIX.

&GEODESIC

[ITENSOR package] This function has been renamed IGEODESIC_COORDS.

&GEOFUNCS

This library package contains a collection of formulas from elementary
geometry for finding lengths, areas, and volumes of common geometric
figures. 

Do USAGE(GEOFUNCS); for more information.

Do DEMO(GEOFUNCS); for a demonstration.

See also FUNCTS.

&GEOMETRIC_DENSITY(X, P)

[UNIPROB package] The density function p*(1-p)^x.

&GEOMETRIC_DISTRIB(X, P)

[UNIPROB package] The cumulative distribution function of the
GEOMETRIC_DENSITY.

&GEOMETRIC_TERM(a, r, n)

[ALGFUNCS package] Returns the nth term in the geometric
progression a, a*d, ..., a*(k-1)*d, ... 

&GEOMETRY - See GEOMETRY_SUMMARY.

&GEOMETRY_SUMMARY

Macsyma performs many kinds of computations in geometry.
Unless otherwise noted, see USAGE(GEOFUNCS); for more
information on these topics.

- Lengths and areas of two dimensional figures. 
- Lengths, areas, and volumes of three dimensional figures.
- Rotation matrices in 2 and 3 dimensions. 
  See ROTMAT2, ROTMAT3, ROTMATX, ROTMATY, ROTMATZ.
- Intrinsic and extrinsic curvature of 2 dimensional surfaces:
  see CURVSURF and SURFACE_NORMAL.
- In N dimensions, find distances and perpendiculars between
  points, lines and hyperplanes; also areas and volumes of
  N-spheres: see INTERSECT_LINE_HYPERPLANE, PERP_LINE_LINE,
  PERP_POINT_HYPERPLANE, PERP_POINT_LINE.
- Spheres in N dimensions: see SPHERE_SURFACE, SPHERE_VOLUME.
- Trigonometry: see TRIG_SUMMARY.
- Plotting of standard 3D geometric figures: see PLOT_3D_FIGURE.
- Spherical geometry: see AREA_SPHERICAL_TRIANGLE,
  AREA_SPHERICAL_POLYGON.
- Riemannian geometry: see ITENSOR and CTENSOR. 

&GEOSUM(a, r, n)

[ALGFUNCS package] Returns the sum of the first n terms in the
geometric progression  a, a*r, a*r^2, ... . n can be infinity.

&GET(a, i)

Retrieves the user property indicated by i associated with atom a or
returns FALSE if a doesn't have property i.

 (c1) PUT(%E,'TRANSCENDENTAL,'TYPE);
 (d1)                            transcendental

 (c2) PUT(%PI,'TRANSCENDENTAL,'TYPE)$

 (c3) PUT(%I,'ALGEBRAIC,'TYPE)$

 (c4) TYPEOF(EXP) := BLOCK([Q],
       IF NUMBERP(EXP)
         THEN RETURN('ALGEBRAIC),
       IF NOT ATOM(EXP)
         THEN RETURN(MAPLIST('TYPEOF, EXP)),
       Q : GET(EXP, 'TYPE),
       IF Q=FALSE
         THEN ERRCATCH(ERROR(EXP,"is not numeric."))
         ELSE Q)$

 (c5) TYPEOF(2*%E+X*%PI);
 X is not numeric.
 (d5)         [[transcendental, []], [algebraic, transcendental]]

 (c6) TYPEOF(2*%E+%PI);
 (d6)            [transcendental, [algebraic, transcendental]]  ;

Do EXAMPLE(GET); for an example.

See also REM.  Do USAGE(PROPERTIES); for an overview of Macsyma
commands to manage properties of symbols.

&GET_VAR_DOMAIN(var, tolerance)

Displays an approximation of the current real region that var is
restricted to, or FALSE if there are no restrictions.  Tolerance,
which is optional (default:0.1), is a floating-point number that
represents the acceptable error tolerance for end point approximation.

Do EXAMPLE(GET_VAR_DOMAIN); for an example.

&GET_VAR_DOMAIN_DEFINITION(var)

Displays the constructor formula for the current real region that var
is restricted to.

&GETCHAR(a, i)

Returns the ith character of the quoted string or atomic name a.

Do EXAMPLE(GETCHAR); for an example.

&GETCHARN(a, i)

Returns the octal character code of the ith character of the quoted
string or atomic name a.

See also GETCHAR.

&GETPROP(symbol, prop)

Returns the prop property of symbol.  The properties it can locate
are:

 - FUNCTION (or FUNDEF)
 - DEPENDENCY (or DEPENDS or DEPEND)
 - MATCHDECLARE, TELLRAT, NOUN, and FEATURE
 - RULE (for DEFRULE, DEFMATCH, TELLSIMP, or TELLSIMPAFTER rules)
 - members of OPPROPERTIES
 - members of FEATURES
 - POSSIBLE_VALUES for Option Variables
 - CONSTANT, NONSCALAR, SCALAR, MAINVAR, EVFUN, EVFLAG,
   SPECIAL, NONARRAY, and BINDTEST
   NOUN, FEATURE, TELLRAT, OPERATOR 
   OPERATOR (or OP)
 - RULE_OF, RULES_FOR

Do USAGE(PROPERTIES); for an overview of Macsyma commands to manage
properties of symbols.

Do EXAMPLE(GETPROP); for examples.

&GFACTOR(exp)

Factors the polynomial exp over the Gaussian integers (i.e. the
integers with SQRT(-1) = %I adjoined).  This is like FACTOR(exp,A^2+1)
where A plays the role of %I.

 (c1) GFACTOR(X^4-1);
 (d1)        (x - 1) (x + 1) (x + %i) (x - %i)

Do EXAMPLE(GFACTOR); for an example.

&GFACTORSUM(exp)

Is similar to FACTORSUM but applies GFACTOR instead of FACTOR.  That
is, factoring is performed over the Gaussian integers (i.e.  the
integers with SQRT(-1) = %I adjoined).

Do EXAMPLE(GFACTORSUM); for an example.


&GLOBALSOLVE default:FALSE

If set to TRUE then variables which are SOLVEd for by LINSOLVE will be
assigned the values found in the solution of the set of simultaneous
linear equations.

&GLOG

This function has been removed.  The LOG function should be used
instead.  If you have a SAVEd file with expressions in it containing
GLOG, you want to substitute LOG for GLOG.

&GO(tag)

Is used within a BLOCK to transfer control to the statement of the
block which is tagged with the argument to GO.  To tag a statement,
precede it by an atomic argument as another statement in the BLOCK.
For example: BLOCK([X],X:1,LOOP,X+1,...,GO(LOOP),...).  The argument
to GO must be the name of a tag appearing in the same BLOCK.  One
cannot use GO to transfer to tag in a BLOCK other than the one
containing the GO.

Do EXAMPLE(GO); for an example.

&GRAD(exp)

[VECT package] Is the grad operator, which returns the gradient of
its argument.

&GRADEF(f(x1, ..., xn), g1, ..., gn)

Defines the derivatives of the function f with respect to its n
arguments.  That is, df/dxi = gi, etc.  If fewer than n gradients, say
i, are given, then they refer to the first i arguments of f.  The xi
are merely dummy variables as in function definition headers and are
used to indicate the ith argument of f.  All arguments to GRADEF
except the first are evaluated so that if g is a defined function then
it is invoked and the result is used.  Gradients are needed when, for
example, a function is not known explicitly but its first derivatives
are and it is desired to obtain higher order derivatives.  GRADEF may
also be used to redefine the derivatives of Macsyma's predefined
functions (e.g.  GRADEF(SIN(X),SQRT(1-SIN(X)^2)) ).  It is not
permissible to use GRADEF on subscripted functions.

GRADEFS 

  Is a list of the functions which have been given gradients by use of
  the GRADEF command (i.e. GRADEF(f(x1, ..., xn), g1, ..., gn)).
  PRINTPROPS([f1,f2,...],GRADEF) may be used to display the GRADEFS
  of the functions f1,f2,..

GRADEF(a,v,exp)

  May be used to state that the derivative of the atomic variable a
  with respect to v is exp.  This automatically does a DEPENDS(a,v).

PRINTPROPS([a1,a2,...], ATOMGRAD)
  may be used to display the atomic gradient properties of a1,a2,...

Do EXAMPLE(GRADEF); for an example.

See also ATOMGRAD.

&GRADEFS default:[]

A list of the functions which have been given gradients by use of the
GRADEF command (i.e. GRADEF(f(x1, ..., xn), g1, ..., gn).)

&GRAMSCHMIDT(_list_)

[EIGEN package] Takes as its argument a list of lists, _list_,
representing a list of vectors which are not necessarily orthogonal
(with respect to the inner product defined by INNERPRODUCT), and
returns a list of the independent sublists in _list_ after they have
been orthogonalized.  Returned results can contain integers that are
factored.  This is due to the fact that the function FACTOR is used to
simplify each substage of the Gram-Schmidt algorithm.  This prevents
the expressions from getting very messy and helps to reduce the sizes
of the numbers which are produced along the way.

Do EXAMPLE(GRAMSCHMIDT); for an example and DEMO(EIGEN); for a longer
demonstration.

&GRAPH(x-lists, y-lists, optional-args)

Plots points specified by the first x-lists and y-lists.

The format for x-lists can be one of
  i)  [x-pt1,x-pt2, .. ,x-pti, .. ,x-ptn] where x-pti evaluates to a
      number

  ii) arrayname where arrayname is the name of a declared
      one-dimensional array of floating point numbers

  iii) 2d-arrayname where 2d-arrayname is the name of a declared
      two-dimensional array of floating point numbers (i.e. by
      ARRAY(2d-arrayname, FLOAT, max-row-index,max-col-index);)

  iv) [x-list1,x-list2, .. ,x-listi, .. ,x-listk] where x-listi can
      have the form of either i) or ii).

The format of y-lists is similar.  The format of optional-args is the
same as for PLOT.

Do EXAMPLE(GRAPH); for an example.

For making graphs with text characters, see CHAR_GRAPH.

See also GRAPH_POINTS, GRAPH3D.

&GRAPH_POINTS(pnts {, optional_args})

[PLTFUNCS package] Plots points whose coordinates are expressed
in the form [[x1,y1], [x2,y2], ... ] .

Do EXAMPLE(GRAPH_POINTS); for an executable example.

&GRAPH_POINTS(pnts {, optional_args})

[PLTFUNCS package] Plots points whose coordinates are expressed
in the form [[x1,y1], [x2,y2], ... ] .  The optional arguments
are the same as those accepted by GRAPH.

Do EXAMPLE(GRAPH_POINTS); for an executable example.

See also GRAPH, GRAPH3D_POINTS.

&GRAPH2(x-lists, y-lists, optional-args)

Plots points specified by the first x-lists and y-lists.

The format for x-lists can be one of
  i)  [x-pt1,x-pt2, .. ,x-pti, .. ,x-ptn] where x-pti evaluates to a
      number

  ii) arrayname where arrayname is the name of a declared
      one-dimensional array of floating point numbers

  iii) 2d-arrayname where 2d-arrayname is the name of a declared
      two-dimensional array of floating point numbers (i.e. by
      ARRAY(2d-arrayname, FLOAT, max-row-index,max-col-index);)

  iv) [x-list1,x-list2, .. ,x-listi, .. ,x-listk] where x-listi can
      have the form of either i) or ii).

The format of y-lists is similar.  The format of optional-args is the
same as for PLOT2.

(Note that GRAPH2 is more similar to the Macsyma function 
CHAR_MULTIGRAPH than to CHAR_GRAPH.)

&GRAPH_WITH_ERRORS(xlist, ylist, other_args)

Implements the GRAPH command with error bars.  The input arguments
are:

o xlist : a list of numbers for the horizontal coordinate.

o ylist : a list of lists, in which each inner is a list of three
  numbers:
  - the lower error limit,
  - the data value for the vertical axis, and
  - the upper error limit.
  Any element of ylist except the first can be a number, which is
  the data value, and tghe lower and upper error limits from the
  previous point are applied.

o other_args : the same optional arguments accepted by GRAPH.
  In particular, other_args enables you to control line types
  and plot point symbols.

The option variable GRAPH_ERROR_TYPE indicates the type of error
information supplied by the user. The permitted values of
GRAPH_ERROR_TYPE are:

o relative : specified error limits are relative to the data value.

o absolute : specified error limits are absolute limits.

o percentage: specified error numbers are percentages of the 
  data values, from which error limits are to be computed.

GRAPH_WITH_ERRORS supports only single lines of data, and not
multiple lines as are supported by GRAPH.  Use COMBINE_PLOTS to
combine several lines with error bars on the same graph.

Do EXAMPLE(GRAPH_WITH_ERRORS); for an example.

See also GRAPH.

&GRAPH3D(x-lists, y-lists, z-lists, optional-args)

Takes 3 arguments (GRAPH2 takes 2) and interprets them as lists of x,
y, and z points which it uses to draw lines using the 3d
transformations.  It can be used to add lines (e.g. axes) to your 3D
plot.  The hidden line routines are not used.

Do EXAMPLE(GRAPH3D); for an example.

See also GRAPH, GRAPH3D_POINTS.

&GRAPH3D_POINTS(pnts {, optional_args})

See also GRAPH, GRAPH_POINTS.

[PLTFUNCS package] Plots points whose coordinates are expressed
in the form [[x1,y1,z1], [x2,y2,z2], ... ] . The optional
arguments are the same as those accepted by GRAPH3D.

Do EXAMPLE(GRAPH3D_POINTS); for an executable example.

See also GRAPH3D, GRAPH_POINTS.

&GREEK

In Macsyma 2.1 and successors, you can obtain most Greek letters in
formatted math output display by typing their English spelling. For
example, theta displays as the Greek letter, and \theta displays as
the capital Greek letter. 

&GRIND(arg)

Prints out arg in a more readable format than the STRING command.  It
returns DONE as its value.

The GRIND switch, default:FALSE, if TRUE will cause the STRING,
STRINGOUT, and PLAYBACK commands to use "grind" mode instead of
"string" mode.  For PLAYBACK, "grind" mode can also be turned on (for
processing input lines) by specifying GRIND as an option.

Do EXAMPLE(GRIND); for an example.

See STRING_SUMMARY for related commands.

&GROB_LC(poly {, vars})

[GROBNER package] Returns the leading coefficient of poly.  

Do USAGE(GROBNER); for more information.

&GROB_LDEG(poly {, vars})

[GROBNER package] Returns the leading degree (exponent of the leading
term) of poly.

Do USAGE(GROBNER); for more information.

&GROB_LT(poly {, vars})

[GROBNER package] Returns the leading term of the polynomial poly.

Do USAGE(GROBNER); for more information.

&GROB_REDUCE(poly, ideal {, vars})

[GROBNER package] Returns a polynomial which is equal to poly modulo
the ideal but is "reduced".  In particular if `ideal' is a Grobner
basis, returns 0 if and only if poly is equivalent to 0 under the
`side relations' given by the ideal. Vars is used to specify the ring
and the ordering. 

Do USAGE(GROBNER); for more information.

&GROB_S_POLY(poly1, poly2 {, vars})

[GROBNER package] Returns the "s-polynomial" of poly1 and poly2.

Do USAGE(GROBNER); for more information.

&GROB_TOT_REDUCE(poly, ideal {, vars})

[GROBNER package] Like GROB_REDUCE but reduces all terms of poly, not
just the leading term.  When `ideal' is a Grobner basis, the total
reduction of any poly is unique up to multiplication by a constant.

Do USAGE(GROBNER); for more information.

&GROBNER(list_of_polys {, vars})

[GROBNER package] Computes the Grobner basis of the ideal generated by
the polynomials in list_of_polys.  "vars" are the polynomial ring
variables -- any other symbols occurring in the ideal are then taken
to be in the coefficient field.  If vars are not specified, all the
symbols occurring in the ideal are interpreted as variables of the
polynomial ring.  For example:

  GROBNER( [x^2*y-y*x,y^3-x^2] ); ==>     Grobner basis over k[x,y]
  GROBNER( [x^2*y-y*x,y^3-x^2], [y]); ==> Grobner basis over k(x)[y]

By default the Grobner basis is taken with the lexicographic order
(but see the variable GROBNER_TOT_ORDER below).  The variables are
ordered as specified by vars if given. If no vars are given, a random
ordering is chosen.  For example, GROBNER( ideal, [x,y,z] ); =>
Grobner over k(..)[x,y,z] with lexicographic order with x < y < z.

Do EXAMPLE(GROBNER); for an example. 

The GROBNER library implements the Spear/Buchberger Grobner
basis algorithm and some applications.  The main use of Grobner bases
is for deciding equivalence of (polynomial) expressions under side
relations.  They can also be used for solving systems of polynomial
equations, and for finding polynomial relations among equations. 

Do USAGE(GROBNER); for more information about the GROBNER library.

&GROBNER_COEF_DIVIDE default:FALSE

[GROBNER package] If TRUE, allow division in the coefficient ring,
i.e. allow the result to explicitly appear in the field generated by
the coefficients. Note that even when FALSE, the result is only valid
over the coefficient field, but the generators will be chosen over the
coefficient ring.  (GROB_REDUCE and GROB_TOT_REDUCE bind this to TRUE
so that the reduction corresponds to the "intuitive" one.)

Do USAGE(GROBNER); for more information.

&GROBNER_FUNCTIONS

[GROBNER package] A list of all the GROBNER library functions which
have been loaded.

Do USAGE(GROBNER); for more information.

&GROBNER_GENVAR_INDEX default:0

[GROBNER package] The index of the last variable generated in this
session. 

Do USAGE(GROBNER); for more information.

&GROBNER_GENVAR_PREFIX default:%G

[GROBNER package] The prefix for variable names generated in grobner
functions such as POLY_RELATIONS.

Do USAGE(GROBNER); for more information.

&GROBNER_PRIMITIVE default:TRUE

[GROBNER package] If TRUE, an attempt is made to keep polynomials
primitive.  This helps reduce coefficient growth, but will slow down
the computation when content doesn't get large anyway.  If 'NUMERIC,
only numeric content will be divided out.

Do USAGE(GROBNER); for more information.

&GROBNER_RAT default:TRUE

[GROBNER package] If FALSE, Grobner results are converted to standard
representation.  By default, all results are left in CRE form.

Do USAGE(GROBNER); for more information.

&GROBNER_TOT_ORDER default:FALSE

[GROBNER package] If FALSE, use strict lexicographic ordering.  If
TRUE, use total-degree order, with ties broken by reverse
lexicographic order.  If lexicographic, use total-degree order, with
ties broken by normal lexicographic order.  Note that POLY_RELATIONS,
ID_CONTRACT and ID_INTERSECT ignore this flag because the algorithms
they use depend on lexicographic order.  GROB_LT, GROB_LC and
GROB_LDEG also ignore this flag.

Do USAGE(GROBNER); for more information.

&GROBNER_TOT_REDUCE default:TRUE

[GROBNER package] If TRUE, all steps in Grobner computation use total
reduction rather than just leading-term reduction.  It is not clear at
this point which is more efficient.  If you have trouble with space,
try it with the switch set both ways.

Do USAGE(GROBNER); for more information.

&GROBNER_TRACE default:FALSE

[GROBNER package] If TRUE, prints certain trace information on the
progress of a Grobner basis computation. 

Do USAGE(GROBNER); for more information.

&GROBNER_UNION(ideal1, ideal2, ..., idealn, vars)

[GROBNER package] Finds a grobner basis for the union of the ideals,
assuming that each ideal is already a grobner basis in the order
specified by vars and the current setting of GROBNER_TOT_ORDER.  Note
that vars is a required argument, unlike the other functions.
GROBNER_UNION is more efficient than
GROBNER(append(ideal1,...idealn),vars), but the latter works even if
some subideal is not a Grobner basis in the given order. 

Do USAGE(GROBNER); for more information.

&GROW_SPACE(space, increment)

(PC Macsyma only) Increases the amount of memory available for certain
types of data.

Arguments:

 - Space may be one of BIGNUM, LIST, ARRAY, SYMBOL, STRING,
   FIXED_LENGTH_ARRAY, or VARIABLE_LENGTH_ARRAY.  

 - Increment is either the number of objects or the number of bytes by
   which the space is to be increased, depending on whether or not the
   object is of fixed size.  For example:

 (c1) GROW_SPACE(BIGNUM, 50000)$

The standard Macsyma function SHOW_SPACE will also be useful to you
for optimizing space sizes.

See also SHOW_SPACE.

&GUMBEL_DENSITY(x, alpha, beta)

[UNIPROB package] The density function  exp(-exp(-(x-alpha)/beta)).

See also GUMBEL_DISTRIB.

&GUMBEL_DISTRIB(x, alpha, beta)

[UNIPROB package] The cumulative distribution for the GUMBEL_DENSITY.

See also GUMBEL_DENSITY and INV_GUMBEL_DISTRIB.

&HADAMARD(N)

Returns a Hadamard matrix of order N, that is, a square matrix H with
elements 1 or -1 such that H . H^` = H^` . H = N*IDENT(N).

An N-by-N Hadamard matrix with N>2 exists only if
REMAINDER(N,4)=0. HADAMARD is implemented only in the 
cases where N, N/12 or N/20 is a power of 2. 

Do EXAMPLE(HADAMARD); for an example.

&HALFANGLES(exp)

Causes the simplification of half-angles in exp without setting the
switch or having to re-evaluate the expression with EV.
INFAPPLY('HALFANGLES,exp); and EV(exp,HALFANGLES); simplify all
levels.  For example, exp = SIN(X/64).

CAVEAT:
     HALFANGLES(SIN(X/2)); gives SQRT(1-COS(X))/SQRT(2)
and  HALFANGLES(COS(X/2)); gives SQRT(COS(X)+1)/SQRT(2) .
However, both of these have a sign ambiguity and are only valid for
certain X.  (For example, the former is valid for X in [0,2*%PI] and
the latter for X in [-%PI,%PI] .)  The correct answers are
SIGNUM(SIN(X/2))*SQRT(1-COS(X))/SQRT(2) and
SIGNUM(COS(X/2))*SQRT(COS(X)+1)/SQRT(2) , respectively.

HALFANGLES default:FALSE
  If TRUE causes half-angles to be simplified away.

Do EXAMPLE(HALFANGLES); for an example.


&HAMMING_WINDOW(t, t0, t1)

Computes the Hamming Window function:

  if t<t0 or t>t1 then 0 else 0.54 - 0.46*cos(2*%pi*t/(t1-t0))).

Do EXAMPLE(HAMMING_WINDOW); for an example and DEMO(POWER_SPECTRUM);
for a longer demonstration.

See also POWER_SPECTRUM.

&HANKEL(first_col {, last_row})

Returns a Hankel matrix whose first column is given by the elements of
the list first_col, and whose last row is given by the elements of the
list last_row. If last_row is not specified, then it defaults to a
list of zeros of the same length as first_row. The last element of
first_col overrides the first element of last_row to determine the
lower left matrix element.

Do EXAMPLE(HANKEL); for an example.

See also GENHANKEL.

----

Macsyma has two functions for computing spherical Hankel functions
in the SPECFUN package:
Spherical Hankel, 1st kind: SHANKEL_H1(N,X) and SHANKEL_H1[N](X)
Spherical Hankel, 2nd kind: SHANKEL_H2(N,X) and SHANKEL_H2[N](X)

&HANKEL_SYMBOL(N,K)

[FUNCTS package] Calculates the Hankel symbol (n,k) defined as

  (n,k)  =  GAMMA(N+K+1/2)
           ------------------
            K! GAMMA(N-K+1/2)

The internal calculations are performed in double precision.

&HANNING_WINDOW(t, t0, t1)

Computes the Hanning Window function:

  if t<t0 or t>t1 then 0 else 1/2*(1-cos(2*%pi*t/(t1-t0))).

Do EXAMPLE(HANNING_WINDOW); for an example and DEMO(POWER_SPECTRUM);
for a longer demonstration.

See also POWER_SPECTRUM.

&HARDCOPY()

Creates a hardcopy from a plot file.  Currently available only on Unix
systems and Symbolics systems.

On Unix systems:
 - When PLOTMODE:FIG, the HARDCOPY command first converts the FIG file
   to a Postscript file and then spools the Postscript file to a
   printer.  The HARDCOPY command issues the shell command "lpr
   ~/macsyma.plot.ps".  This spools the Postscript file created by the
   FIG drawing tool to the default printer.
 - When PLOTMODE:UNIX, the HARDCOPY command issues the shell command
   "hardcopy ~/macsyma.plot".  This command requires that the script
   "hardcopy" already be created, which issues the correct output
   command. 

See PLOTTING_SUMMARY for more information.

&HARMONIC(nterms, power[1], start[1])

Equivalent to

         nterms
         ====
         \               1
          >     -------------------- ,
         /                     power
         ====   (start + k - 1)
         k = 1
         
except capable of invoking polygammas and Bernoulli polynomials
in case of (possibly unknown) integer powers of known sign.

Example:

 (c1) HARMONIC(3);
                          11
 (d1)                     --
                          6

 (c2) HARMONIC(123456789, -10);
 (d2) 92314959405797863182649550652185543796079073323825111005635#
     00403978042080998209406212075
(quickly)

 (c3) HARMONIC(N-1, -2);
                             2
                      3   3 n    n
                     n  - ---  + -
                           2     2
 (d3)                -------------
                           3

 (c4) HARMONIC(3, X, 4);

                     1    1    1
 (d4)                -- + -- + --
                      x    x    x
                     6    5    4

 (c5) HARMONIC(X, 1-ABS(ODD), 0);

        bernpoly(x, abs(odd)) - bern(abs(odd))
 (d5)   --------------------------------------
                       abs(odd)

(because abs(odd) is a positive integer)

 (c7) HARMONIC(1/2, 3, 1/4);
                             3
 (d7)                   2 %pi

(I.e. sum(k^-3,k,1/4,inf)-sum(k^-3,k,3/4,inf).)

Do EXAMPLE(HARMONIC); for an example.

Other Harmonics - There are two functions for computing spherical
harmonics in the SPECFUN package: 

    SHARMONIC_Y(N,M,TH,PH) and SHARMONIC_Y[N,M](TH,PH)
    For |M| <= N

&HARMONIC_TERM(a, b, c, n)

[ALGFUNCS package] Returns the nth term of the harmonic series
a/b, a/(b+c), ... , a/(b+kc), ...

&HARMONICS

See Harmonic and POISSON.

&HAV(x)

[ALGFUNCS package] (1-cos(x))/2 .

&HEIGHT_PYRAMID3(edge)

[GEOFUNCS package] Returns the height of a pyramid with a triangular
base and six edges of equal length.

&HEIGHT_PYRAMID4(edge)

[GEOFUNCS package] Returns the height of a pyramid with a square base
and eight edges of equal length.

&HELP

Macsyma has several on-line HELP facilities.  The main keyboard
commands are: 

- PRIMER(); starts the on-line Macsyma primer.
- DESCRIBE(topic); gives textual description of a specified topic or
  command.
- USAGE(package); gives a (lengthier) textual description of an
  library package.
- EXAMPLE(command); gives an executable example of the use of a Macsyma
  command.
- DEMO(topic); gives a (longer) executable demonstration of a whole
  topical area, usually one covered by a library file.

If unsure about what topics are available, do APROPOS(string); to see
a list of DESCRIBEd topic names which contain the specified string in
their names.

In Macsyma 2.2 and successors, you can type on a command line any
query that ends with a question mark (?) and get executable tips
in return.

If your Macsyma has a Windows front end, click with your mouse on 
Help, then on Front-End-Help to get a listing of how to use the
Help system.  

Do DESCRIBE(DOCUMENTATION); For information about hardcopy
documentation.

&HERMITE

There are two functions for computing Hermite polynomials in the
SPECFUN package: HERMITE_H(N,X) and HERMITE_H[N](X).

&HERMITE_H(N, X)

[SPECFUN package] Computes the Hermite polynomial H(N,X) for
nonnegative integer N.

HERMITE_H[N](X) is an alternative syntax, which stores the Hermite
polynomials of order less than or equal to N.

Do LOAD(SPECFUN); to access this function.

&HERMITIAN(A {, B})

[MATRICE package] takes the Hermitian (complex conjugate transpose) of
the matrix or matrice A.  If A is a matrix then no second argument
should be specified and HERMITIAN will return as its value the matrix
that is the Hermitian of A.  Otherwise, if A is a matrice then a
matrice representing the Hermitian of A will be attached to the symbol
B and HERMITIAN will return as its value the description of B produced
by MATRICEINFO.  See also MATRICE.

&HESSENBERG(A {, flag})

[MATRICE package] transforms the square matrix A into upper Hessenberg
form (H) using similarity transformations.  If the optional flag is
SIMILARITY_MATRIX or SIMILARITY_MATRICES, then HESSENBERG will return
the list [H, S] or [H, S, S^^(-1)] respectively, where H = S^^(-1) A
S.  The first argument to HESSENBERG may also be a list like [A, D].
In this case, A must be a Hermitian matrix and D a diagonal matrix
with real, positive diagonal elements.  The similarity transformation
will then be applied to D^^(-1) A, corresponding to the eigenproblem A
x = lambda D x.  The algorithm used in this situation will put D^^(-1)
A into general tridiagonal form by applying a mostly symmetry
preserving transformation (fast Givens rotations).

Do EXAMPLE(HESSENBERG); for an example and DEMO(MATRICE1); for a
longer demonstration.  Do also USAGE(MATRICE); and see MHESSENBERG.

&HESSIAN(func, list_of_vars)

[Matfuncs package] Computes the matrix of second derivatives of the 
function or expression func with respect to the specified list of
variables.  

Do EXAMPLE(HESSIAN); for and example.

&HEURISTIC_PRECISION_LIMIT default:200

When a positive integer, this option variable authorizes use of an
unproven, numerical heuristic to decide inequalities and integer
properties of constant expressions.

 (c1) BLOCK([HEURISTIC_PRECISION_LIMIT:FALSE],CSIGN(1+COS(355/113)));

 (d1)                            pnz

 (c2) BLOCK([HEURISTIC_PRECISION_LIMIT:22],CSIGN(1+COS(355/113)));

 (d2)                            pos

Note the time cost for this case.  Yet

 (c3) BLOCK([HEURISTIC_PRECISION_LIMIT:FALSE], ATAN(2*%PHI-SQRT(5)));

 (d3)                   atan(2 %phi - sqrt(5))

 (c4) BLOCK([HEURISTIC_PRECISION_LIMIT:22], ATAN(2*%PHI-SQRT(5)));

                                  %pi
 (d4)                             ---
                                   4

I.e., if successful, simplifications often save time.  (This would have
taken no longer for heuristic_precision_limit:99999 .)

The heuristic attempts to estimate the numerical precision (BFPRECISION)
necessary to resolve the question, as a function of the complexity of
the expression.  If this estimate exceeds HEURISTIC_PRECISION_LIMIT,
Macsyma gives up, for the sake of time.

 (c5) BLOCK([HEURISTIC_PRECISION_LIMIT:9],FEATUREP(LOG(1+%E^44),
      NONINTEGER));

 (d5)                              false

 (c6) BLOCK([HEURISTIC_PRECISION_LIMIT:99999],FEATUREP(LOG(1+%E^44),
      NONINTEGER));

 (d6)                               true

Although we are currently unaware of a counterexample to this
heuristic, we wouldn't be terribly surprised to see one.  So, because
of this concern, the FALSE setting to HEURISTIC_PRECISION_LIMIT is
provided to turn off the heuristic.

&HGFRED(num_list, denom_list, arg)

Simplifies the hypergeometric function with numerator parameters
specified by num_list, denominator parameters specified by denom_list,
and argument specified by arg and returns a closed-form representation
if possible.  Otherwise, a result of the form
HYPER_F[n,m](list1,list2,arg) where list1 is a list of length n and
list2 is a list of length m is returned.

An error is signaled if num_list and denom_list are not specified as
lists.

In general, 

 hyper_f[n,m]([a1...an], [b1...bm], x) = 

        INF
        ====                                            k
        \     pochhammer(a1, k) ... pochhammer(an, k)  x
         >    ---------------------------------------  -
        /     pochhammer(b1, k) ... pochhammer(bm, k)  k!
        ====
        K = 0

Examples:
   
 (c1) HGFRED([1], [], X);
                              1
 (d1)                       -----
                            1 - x
   
 (c2) HGFRED([], [], X);
                               x
 (d2)                        %e
   
 (c3) HGFRED([1,2,3], [3], X);

 (d3)               hyper_f    ([1, 2], [], x)
                           2, 0

Note:  A definition of HYPER_F_SUM is provided in the file SPECFUN2. 
To access this file, it is necessary to load SPECFUN.
   
 (c4) LOAD("SPECFUN")$
 A:>climax>share>specfun.bin.12 being loaded.
 A:>climax>share>specfun2.bin.4 being loaded.

 (c5) EVAL(SUBST(HYPER_F_SUM,HYPER_F,D3));
 
                    inf
                    ====
                    \      n
 (d4)                >    x  (n + 1)!
                    /
                    ====
                    n = 0
   
Do EXAMPLE(HGFRED); for an example.

See also HYPER_F.

&HIDE

(Optional argument to the three-dimensional plotting functions, now
obsolete) Hidden lines in the plot are not drawn.

&HILBERT(n)

Generate a Hilbert matrix.  The general element is 
H[i,j] = 1/(i+j-1).  Hilbert matrices are poorly conditioned for
inversion. 

Do EXAMPLE(HILBERT); for an example.

See also INVHILBERT, HANKEL, and GENHANKEL.

&HIPOW(exp, v)

The highest explicit exponent of v in exp.  Sometimes it may be
necessary to expand exp since this is not done automatically by HIPOW.
Thus HIPOW(Y^3*X^2+X*Y^4,X) is 2.

Do EXAMPLE(HIPOW); for an example.

See also LOPOW.

&HISTOGRAM(data {,binsz, low, high})

Draws a histogram of the list of data with data extrema low (default:
MIN(data)) and high (default: MAX(data))  using a bin size binsz (default
(high-low)/21.

The list data contains numbers only, and is assumed to be floating point.

Do EXAMPLE(HISTOGRAM); for an example.

See also BAR_CHART.



&HORNER(exp, var)

Will convert exp into a rearranged representation as in Horner's rule,
using var as the main variable if it is specified.  Var may also be
omitted in which case the main variable of the CRE form of exp is
used.  HORNER sometimes improves stability and numerical efficiency if
expr is to be numerically evaluated.  It is also useful if Macsyma is
used to generate programs to be run in FORTRAN or C.

Do EXAMPLE(HORNER); for an example.

See also OPTIMIZE, FORTRAN, GENTRAN, COUNT_OPS.

&HYPER_F [p,q](l1, l2 {, z})

Numerically evaluates the generalized hypergeometric series 
pFq[a1,a2,...,ap; b1,b2,...,bq |z), where

 - l1 is the list [a1,...,ap]
 - l2 is [b1,...,bq] 
 - z defaults to 1.

The current implementation analytically continues only for the cases
p = 2, q = 1, and p = 1, q = 0.  Otherwise, numerical convergence
necessitates p <= q, or p = q+1 and |z| < 1, or that the series
terminate by virtue of l1 containing a nonpositive integer.

See USAGE(HYPER_F); for definitions and more information about
hypergeometric functions.

Do EXAMPLE(HYPER_F); for an example and DEMO(HYPER_F); for a longer
demonstration.

See also HYPER_2F1 and HYPER_ORDER.

&HYPER_2F1(a, b, c {, z})

Computes the numerical value of the hypergeometric function 2F1[a,b;c|z], 
where z defaults to 1.  If some of a, b, c, and z are non-numeric, 
HYPER_2F1 will sometimes compute a symbolic value, but usually 
returns unevaluated.

Do EXAMPLE(HYPER_2F1); for an example and DEMO(HYPER_F); for a longer
demonstration.

See also HYPER_F and HYPER_ORDER.

&HYPER_ORDER(param1, param2,...) 

When Macsyma encounters more than one permutation of a given hyper_f 
parameter tuple, it canonicalizes to the first ordering encountered.  
Thus

 (c1) HYPER_2F1(A,B,C,Z) - HYPER_2F1(B,A,C,Z);
 (d1)                                0

because [b,a] becomes [a,b].  HYPER_ORDER asserts a new preferred ordering:

 (c2) HYPER_2F1(A,B,C,Z) - (HYPER_ORDER(B,A),HYPER_2F1(B,A,C,Z));
 (d2)          hyper_2f1(a, b, c, z) - hyper_2f1(b, a, c, z)

 (c3) HYPER_2F1(A,B,C,Z) - HYPER_2F1(B,A,C,Z);
 (d3)                                0

but now because [a,b] becomes [b,a].

Do EXAMPLE(HYPER_ORDER); for an example.

&HYPERGEOMETRIC

For simplification of hypergeometric functions, see HGFRED.

See also HYPER_F, HYPER_2F1, HYPER_ORDER, HYPERGEOMETRIC_DENSITY, 
and HYPERGEOMETRIC_DISTRIBUTION.

&HYPERGEOMETRIC_DENSITY(X, M, K, N)

[UNIPROB package] The hypergeometric density function
 BINOMIAL(K,N)*BINOMIAL(M-K,N-X)/BINOMIAL(M,N).

&HYPERGEOMETRIC_DISTRIB(X, M, K, N)

[UNIPROB package] The cumulative distribution function for the
HYPERGEOMETRIC_DENSITY.

&HYPERGEOMETRIC_FUNCTIONS

For simplification of hypergeometric functions, see HGFRED.

&HYPGEO

See SPECINT.

&IBASE default:10

The base for inputting numbers.  The value assigned to this variable
must be an integer between 2 and 36 inclusive.  If IBASE is assigned a
value greater than 10, Macsyma provides no way to specify digits above
9.  This does not affect floating-point numbers or bigfloats.

&IC_CONVERT(eqn)

[ITENSOR package] Converts an ITENSOR equation eqn into a CTENSOR
assignment statement.  Enable indicial tensor results to be converted
to component tensor form for further computation.

 - Implied sums over dummy indices are made explicit.
 - Indexed objects are transformed into arrays (with covariant indices
   first, then contravariant).
 - Derivatives of indexed objects are replaced by the noun form of
   DIFF with respect to the part of CT_COORDS specified by the 
   derivative index in the indicial equation eqn.
 - Do loops are introduced to sum over all free indices in eqn.

IC_CONVERT is affected by the option variable METRICCONVERT. When
frame fields or torsion are used, IC_CONVERT is also affected by
the flags IFRAME_FLAG and ITORSION_FLAG.

See DEMO(HEATEQ1); DEMO(QMECH1); and DEMO(TENS_PDE); for 
demonstrations of conversion of indicial tensor equations to 
specific coordinate systems. 

&IC1(eqn, xval, yval)

Applies initial conditions to a general solution of a first order
ordinary differential equation, and returns a particular solution. 
The arguments are:

Arguments:

 - eqn is a solution equation which is returned by one of Macsyma's
   ODE solver commands.
 - xval is an equation which specified the value of the independent
   variable at which the initial conditions are to be specified.
 - yval is an equation which specifies the initial value of the
   dependent variable.

Do EXAMPLE(IC1); for an example.

See also BC2, IC2, ODE_ICONDS, ODE_IBC, and ODE.

&IC2(eqn, xval, yval, dydxval)

Applies initial conditions to a general solution of a second order
differential equations, and returns a particular solution.  The
arguments of the command are:

Arguments:

 - eqn is a solution equation which is returned by one of Macsyma's
   ODE solver commands.
 - xval is an equation which specified the value of the independent
   variable at which the initial conditions are to be specified.
 - yval is an equation which specifies the initial value of the
   dependent variable.
 - dydxval is an equation which specifies the initial value of the
   first derivative of the dependent variable.

Do EXAMPLE(IC2); for an example.  

See also BC2, IC1, ODE, ODE_ICONDS, and ODE_IBC.

&ICANFORM(exp)

[ITENSOR package] Simplifies exp by renaming dummy indices and
reordering all indices as dictated by symmetry conditions imposed on
them.  If ALLSYM is TRUE then all indices are assumed symmetric;
otherwise only symmetry information provided by DECLARE_ISYMMETRY
declarations will be used.  The dummy indices are renamed in the same
manner as in the RENAME function.

When ICANFORM is applied to a large expression, the calculation may take
a considerable amount of time.  This time can be shortened by calling
RENAME on the expression first.  Also see the example under 
DECLARE_ISYMMETRY. 

Note: ICANFORM may not be able to reduce an expression completely to
its simplest form although it will always return a mathematically
correct result.

Do DEMO(ITENSIMP); for a demonstration of some tensor simplifications.

See also ITENFORM, ICANTEN.

&ICANTEN(exp)

[ITENSOR package] Simplifies exp by renaming (see RENAME) and
permuting dummy indices.  ICANTEN is restricted to sums of tensor
products in which no derivatives are present, and assumes that all
tensors are symmetric.  As such it is limited and should only be used
if ICANFORM and ITENFORM is not capable of carrying out the required
simplification.  For most purposes, ICANTEN is obsolete.

See also ICANFORM.

&ICC2

[ITENSOR package] The symbol used to denote the connection
coefficients, when frame fields or affine torsion are included in
indicial tensor computations. ICC2 are composed of the Christoffel
symbols (ICHR2), the frame coefficients (IFC2), and the contortion
tensor (IKT2):

          i           i        i        i         i
     ICC2    =  ICHR2   + IFC2   - IKT2   + INMC2   .
         jk          jk       jk       jk        jk

&ICHANGENAME(new, old, exp)

[ITENSOR package] Changes the name of all indexed objects called old
to new in expression exp. Old can be either a symbol or a list of the
form [name, m, n], in which case only those indexed objects called
name with m covariant indices and n contravariant indices are renamed
to new.

&ICHR1([i,j,k])

[ITENSOR package] Returns the Christoffel symbol of the first kind
expressed in terms of the metric IMETRIC.  If IMETRIC:G; then

   ICHR1([i,j,k]) = (g      + g      - g     )/2 .
                      ik,j     jk,i     ij,k

&ICHR2([i,j,@k])

[ITENSOR package] Returns the Christoffel symbols of the second kind
in terms of the metric IMETRIC.  If IMETRIC:G; then

                      ks
   ICHR2([i,j,@k]) = g    (g      + g      - g     )/2 .
                            is,j     js,i     ij,s

&ICONTRACT(exp)

[ITENSOR package] Carries out all possible contractions in exp, which
may be any well-formed expression involving sums and products of
tensors.  This function uses the contraction information which has
been specified using the DEFINE_ICONTRACTION function.

 - The indices are sorted into alphabetical order; hence if the tensors
   are not completely symmetric, this causes a permutation of tensor
   indices.
 - All dummy indices are renamed using the symbols %1,%2,...  to permit
   the expression to be simplified as much as possible by reducing
   equivalent terms to a canonical form.

For best results exp should be fully expanded before applying ICONTRACT.
RATEXPAND is the fastest way to expand products and powers of sums if
there are no variables in the denominators of the terms.  The GCD switch
should be FALSE if GCD cancellations are unnecessary.

&ICOORD(tensor1 {,..., tensorn})

[ITENSOR package] Gives tensork the property that
DIFF(tensork([@j]),i); returns KDELTA([I,@J]).  Thus when tensork
is used as a contravariant vector, it behaves like a coordinate
function with respect to covariant differentiation.  ICOORDS is a list
of all indexed objects having this property.  The coordinate property
can be removed with the command REMOVE_ICOORD.

&ICOORDS

[Itensor package] ICOORDS is a list of all indexed objects having the
indicial coordinate property declared by ICOORD.

&ICOUNTER default:0

[ITENSOR package] Determines the numerical suffix to be used in the
next dummy index generated in the ITENSOR package, i.e. ICOUNTER+1.
The prefix is determined by the option IDUMMYX (default:%).  

See also IDUMMY and INDICES.

&ICURVATURE([@i,j,k,h])

[ITENSOR package] computes the Riemann curvature tensor of an affine
connection.  The conventions used for the curvature tensor are given
by:
           i             i          i        i       r        i       r
 ICURVATURE    = d ICHR2  - d ICHR2  + ICHR2   ICHR2  - ICHR2   ICHR2  ,
           jkh    k     hj   h     kj       kr      hj       hr      kj

where ICHR2 are the Christoffel symbols of the second kind. For
non-Riemannian connections, the ICHR2 are generalized to ICC2, the
indicial connection coefficients.

See also IRICCI, ISCURVATURE and IWEYL.

&ID_CONTRACT(ideal, subvars {, vars})

[GROBNER package] Returns the contraction of ideal to the subring
generated by subvars.  E.g. ID_CONTRACT( [x^3*y-y^2,x^2*y], [y] );
returns the intersection of (x^3*y-y^2,x^2*y)k[x,y] and k[y].  Vars
may specify all the occurring vars, or just the ones not already
occurring in subvars (or anything in between), whatever is most
convenient.

&ID_INTERSECT(ideal1, ideal2 {, vars})

[GROBNER package] Returns the intersection of the two ideals.  

Do USAGE(GROBNER); for more information.

&ID_MEMBER(poly, ideal {, vars})

[GROBNER package] Returns TRUE if and only if poly is a member of
ideal.  Same as IS(GROB_REDUCE(poly, GROBNER(ideal, vars))=0); . 

Do USAGE(GROBNER); for more information.

&ID_REDUCE(ideal1, ideal2 {, vars})

[GROBNER package] The same as
DELETE(0,MAP(LAMBDA([p],GROB_REDUCE(p,ideal2,vars)),ideal1)), but
saves some overhead since ideal2 needs to be converted to internal
representation only once.

Do USAGE(GROBNER); for more information.

&ID_TOT_REDUCE(ideal1, ideal2 {, vars})

[GROBNER package] This is to GROB_TOT_REDUCE as ID_REDUCE is to
GROB_REDUCE.

Do USAGE(GROBNER); for more information.

&IDEMPOTENT - Property

A function can be declared IDEMPOTENT if it represents an idempotent
function (that is, f(f(x))=f(x)).  

IDEMPOTENT is a member of the FEATURES list.  It can be asserted with
DECLARE, withdrawn with REMOVE, and detected with FEATUREP.

Do EXAMPLE(IDEMPOTENT); for an example.

&IDENT(n)

Produces an n by n identity matrix.

Do EXAMPLE(IDENT); for an example.

See also DIAGMATRIX, MAT_IDENT and DIAG_MATRIX.

&IDIFF(exp, index)

[ITENSOR package] returns the coordinate derivative of the tensor exp
with respect to the coordinate numbered by index.  Note that the
command DIFF takes derivatives with respect to parameters extrinsic to
the manifold geometry.

See also IVARIATION.

&IDUMMY()

[ITENSOR package] increments ICOUNTER and returns as its value a
symbol of the form %N, where N is a positive integer, equal to the
(new) value of ICOUNTER.  The prefix is determined by the option
variable IDUMMYX (default:%).  The resulting symbol is used as a
tensor index in the ITENSOR package.  This function guarantees that
dummy tensor indices which are needed in forming expressions will not
conflict with indices already in use.

See also INDICES.

&IDUMMYX default:%

[ITENSOR package] The prefix which is used by the IDUMMY function in
generating dummy tensor index names.

&IEQN(inteqn, unk, tech, n, guess)

[INTEQN package] Command for solving integral equations.  

Arguments:

 - inteqn is the integral equation; unk is the unknown function;
 - tech is the technique to be tried (tech = FIRST means: try the
   first technique which finds a solution; tech = ALL means: try all
   applicable techniques);
 - n is the maximum number of terms to take for TAYLOR, NEUMANN,
   FIRSTKINDSERIES, or FREDSERIES (it is also the maximum depth of
   recursion for the differentiation method);
 - guess is the initial guess for NEUMANN or FIRSTKINDSERIES.

 Default values for the 2nd THRU 5th parameters are:
 - unk: P(X), where P is the first function encountered in an
   integrand which is unknown to Macsyma and X is the variable which
   occurs as an argument to the first occurrence of P found outside of
   an integral in the case of SECONDKIND equations, or is the only
   other variable besides the variable of integration in FIRSTKIND
   equations.  If the attempt to search for X fails, the user will be
   asked to supply the independent variable;
 - tech: FIRST;
 - n: 1;
 - guess: NONE, which will cause NEUMANN and FIRSTKINDSERIES to use
   F(X) as an initial guess.

Do USAGE(INTEQN); for more information.

Do EXAMPLE(IEQN); for an example, and DEMO(INTEQN); for a longer
demonstration.  

&IEQNPRINT default:TRUE

[IEQN package] Governs the behavior of the result returned by the IEQN
command (which see).  If IEQNPRINT is set to FALSE, the lists returned
by the IEQN function are of the form

   [SOLUTION, TECHNIQUE USED, NTERMS, FLAG]

where FLAG is absent if the solution is exact.  Otherwise, it is the
word APPROXIMATE or INCOMPLETE corresponding to an inexact or non-closed
form solution, respectively.  If a series method was used, NTERMS gives
the number of terms taken (which could be less than the n given to IEQN
if an error prevented generation of further terms).

&IF

The IF statement is used for conditional execution.  The syntax is:

    IF condition THEN expression1 ELSE expression2.

The result of an IF statement is expression1 if condition is true and
expression2 if it is false.  expression1 and expression2 are any
Macsyma expressions (including nested IF statements), and condition is
an expression which evaluates to TRUE or FALSE and is composed of
relational and logical operators which are as follows:

  Operator name       Symbol      Type

  greater than        >           relational infix
  equal to            = , EQUAL   "  "
  not equal to        #           "  "
  less than           <           "  "
  greater than        >=
     or equal to                   "  "
  less than           <=
    or equal to                   "  "
  and                 AND         logical infix
  or                  OR          "  "
  not                 NOT         logical prefix

Do EXAMPLE("IF"); for an example.  

See also IF_EXPAND.

&IF_EXPAND(expr)

Applies various simplifications to expressions involving conditional
(if-then) statements.  For example,

 (c1) IF_EXPAND(IF CONDITION1 THEN RESULT1 ELSE RESULT1);

 (d1)                             result1

 (c2) IF_EXPAND((IF COND1 THEN T1 ELSE F1)+(IF COND1 THEN T2 ELSE f2));

 (d2)               if cond1 then t1+t2 else f1+f2

 (c3) IF_EXPAND((IF X<0 THEN T1 ELSE F1)*(IF NOT 0>X THEN T2 ELSE f2));

 (d3)                if x<0 then f2*t1 else f1*t2

Do EXAMPLE(IF_EXPAND); for an executable example and DEMO(IFEXPAND); 
for a longer demonstration.

&IFB

[ITENSOR package] The symbol used to denote the Lie brackets of frame
fields.

See also IFR.

&IFC2([i, j, @k])

[ITENSOR package] Computes the contribution to the connection
coefficients ICC2 arising from the frame fields.

See also IFR and ICC2.

&IFR

[ITENSOR package] the frame field.
                                       i             
       frame_vector : coord_vector  IFR     (sum over i).
                   a              i     a

In the CTENSOR package, the frame field is denoted by FR. 

See also IFRI.

&IFRAME_FLAG default:FALSE

[ITENSOR package] When TRUE, ITENSOR computes using frame fields, and
the indicial frame field Lie brackets, denoted by the tensor IFB.
This flag also causes command IC_CONVERT to convert names of frame
brackets and frame fields into CTENSOR notation.

&IFRAMES()

[ITENSOR package] Assigns components to the frame brackets, IFB, in
terms of the frame fields, IFR, and inverse frame fields, IFRI.  Also
sets up contraction properties of IFR and IFRI to express their
inverse relationship.

&IFRI

[ITENSOR package]  - the frame field inverse.
                                        a             
       coord_vector : frame_vector  IFRI     (sum over a).
                   i              a      i

In the CTENSOR package, the frame field inverse is denoted by FRI. 

See also IFR.

&IFT(real-array, imag-array)

[FFT package] Inverse Fourier Transform.  Do LOAD("FFT"); to load in
this package.  These functions (FFT and IFT) perform a (complex) fast
Fourier transform on either 1 or 2 dimensional FLOATING-POINT arrays,
obtained by:  ARRAY(<ary>,FLOAT,<dim1>); or
ARRAY(<ary>,FLOAT,<dim1>,<dim2>); For 1D arrays <dim1> must equal
2^n-1, and for 2D arrays <dim1>=<dim2>=2^n-1 (i.e. the array is
square).  (Recall that Macsyma arrays are indexed from a 0 origin so
that there will be 2^n and (2^n)^2 arrays elements in the above two
cases.)  

Do USAGE(FFT); for more information.

&IGEODESIC_COORDS(exp, metricname)

[ITENSOR package] Rewrites tensor expression exp with undifferentiated
Christoffel symbols and first derivatives of the metric set to zero,
as in geodesic coordinates.

&IKT2([i,j], [k])

[ITENSOR package] Computes the contortion tensor, which is defined in
terms of the affine torsion.

See also ICC2.

&ILT(exp, lvar, ovar)

Computes the inverse Laplace transform of exp with respect to lvar and
parameter ovar.  exp must be a ratio of polynomials whose denominator
has only linear and quadratic factors.  By using the functions LAPLACE
and ILT together with the SOLVE or LINSOLVE functions the user can
solve a single differential or convolution integral equation or a set
of them.  

The option USE_NILT tells ILT when to use NILT. The option variable
NILT_USER_EXTENSION allows user specified inverse Laplace transforms to
be specified.

Do USAGE(NILT); for information.

Do EXAMPLE(ILT); for an example, and DEMO(NILT); for a longer
demonstration.

&IMAGINARY - Property

A symbol can be declared IMAGINARY if it is known to represent an
imaginary number or a function that takes only imaginary values.
IMAGINARY is a member of the FEATURES list.  It can be asserted with
DECLARE, withdrawn with REMOVE, and detected with FEATUREP.

&IMAGPART(exp)

Returns the imaginary part of the expression exp.

Do EXAMPLE(IMAGPART); for an example.  

See also COMPLEX, REALPART, IMAGINARY.

&IMETRIC(G)

[ITENSOR package] Specifies the metric symbol to be G, by
 - assigning the variable IMETRIC:G;
 - setting up the contraction properties of the metric G by executing
   the commands DEFINE_ICONTRACTION(G); and 
   DEFINE_ICONTRACTION(G,G,KDELTA);
 - declaring the metric tensor to be symmetric by executing the
   commands DECLARE_ISYMMETRY(G,2,[SYM(1,2)]);.

The variable IMETRIC, default:"...", is bound to the metric, assigned
by the IMETRIC(G) command.

&IMPLICIT_PLOT(expr, x, xlo, xhi, y, ylo, yhi)

Plots the graph of which is implicitly specified by expr in the (x,y)
plane.  expr can be either an expression in x and y or an equation of
two expressions in x and y.  xlo and xhi are the lower and upper
limits of the x-coordinate and ylo and yhi are the lower and upper
limits of the y-coordinate.  IMPLICIT_PLOT uses Macsyma's CONTOURPLOT
machinery to generate the plot.

Do EXAMPLE(IMPLICIT_PLOT); for an example, and DEMO(IMPLICIT_PLOT);
for a longer demonstration.

See also CONTOURPLOT and PARAMPLOT.  See PLOTTING_SUMMARY for an
overview of plotting capabilities in Macsyma.

&IMPROVE_LU_SOLVE(MAT, VEC {, N})

Solves the numerical matrix equation MAT.X = VEC for X using N
(default:1) iterative improvements.

Do EXAMPLE(IMPROVE_LU_SOLVE); for an example.

&INCHAR default:c

The alphabetic prefix of the names of expressions typed by the user.

Do EXAMPLE(INCHAR); for an example.

See also OUTCHAR and LINECHAR.

&INCREASING - Property

A symbol can be declared INCREASING if it is known to represent a
strictly increasing function.  INCREASING is a member of the FEATURES
list.  It can be asserted with DECLARE, withdrawn with REMOVE, and
detected with FEATUREP.

Do EXAMPLE(INCREASING); for an example.  

See also FEATURES.

&INDEFPROD(expr, var)

[NUSUM package] Means PROD(expr, var, <unknown>, var).  INDEFPROD is the
inverse of the UNPROD operator.  That is, UNPROD(INDEFPROD(G(N),N),N)
= G(N).

&INDEFSUM(expr, var)

[NUSUM package] Means SUM(expr, var, <unknown>, var).  INDEFSUM is the
inverse of the UNSUM operator.  That is, UNSUM(INDEFSUM(G(N),N),N) =
G(N).  Also known as UNDIFFERENCE.

&INDEXED(expn, upperindex, lowerindex)

[DIMIND package] Contains functions to support the display of indexed
expressions.  INDEXED is invoked preceded by a single quote, as in
'INDEXED(u,n,[i,j]).  

Do USAGE(DIMIND); for more information.

Do EXAMPLE(INDEXED); for an example.

For display in indicial tensors in the ITENSOR representation, see
ISHOW in the ITENSOR package.

&INDICES(exp)

[ITENSOR package] returns a list of two elements.  The first is a list
of the free indices in exp (those that occur only once); the second is
the list of dummy indices in exp (those that occur exactly twice).

&INEQ_REVERSE(ineq)

Reverses the inequalities in ineq.  By `inequalities' we mean `true
inequalities' i.e. a>b, a<b, a>=b, a<=b and a#b, as well as
`equality' i.e. a=b .  For example,

  INEQ_REVERSE(A>B);   ->  B < A
  INEQ_REVERSE(A<=B);  ->  B >= A
  INEQ_REVERSE(A#B);   ->  B # A

Do EXAMPLE(INEQ_REVERSE); for an example.

See also INEQSIMP and INEQ_LINSOLVE.

&INEQUALITIES

See INEQUALITY.

&INEQUALITY

Macsyma has the usual inequality operators:
  <   less than
  >   greater than
  >=  greater than or equal to
  <=  less than or equal to.

See also INEQSIMP and INEQ_REVERSE for simplifying inequalities,
and INEQ_LINSOLVE for solving systems of inequalities and equations.

&INEQ_LINSOLVE(ineqs, vars)

Tries to solve a system of simultaneous real linear equations and
inequalities for the variables vars.

Arguments:
---------

 - ineqs is a list of linear equations and linear inequalities,
   whose main operators are "=", "<", ">", "<=", and ">=".
   The inequalities can contain symbolic coefficients and symbolic
   constants.  For example a*x+2*y<c is an acceptable inequality in
   the variables [x, y].   

 - vars is a list of symbolic variables [var1, var2, ...] which appear
   in the system of inequalities, and which are to be solved for.

Output:
------

INEQ_LINSOLVE returns a list with two elements, each of which is
itself a list.

 - The first element is a list of equations of the form
   [var1= ..., var2= ... ] which are parametric solutions for the
   variables which appear in the list vars.  The solution is presented
   in parametric form, so that the right-hand sides of the equations
   contain arbitrary real parameters
   - %R1, %R2, ... are arbitrary real numbers.
   - %POS1, %POS2, ... are arbitrary positive numbers.
   - %PZ1, %pz2, ... are arbitrary non-negative numbers.

 - The second element is a list of the constraint expressions which
   must be zero in order that the equations above satisfy the
   equations and inequalities ineqs.  When INEQ_LINSOLVE  can find a
   complete solution, this list is empty.

The counters which control the indexing of the names of the parameters
%RI, %POSi, and %PZi are %RNUM, %POSNUM and %PZNUM respectively, each
of which has default value 0 . 

Do EXAMPLE(INEQ_LINSOLVE); for an example, and DEMO(INEQSOL); for a
longer demonstration.

See also INEQSIMP and INEQ_REVERSE.

&INEQSIMP(exp)

Simplifies expressions containing inequalities.  By `inequalities' we
mean `true inequalities' i.e. a>b, a<b, a>=b, a<=b and a#b,
as well as `equality' i.e. a=b .  For example,

 INEQSIMP(C + (A >= B));        ->  C + A >= C + B
 INEQSIMP(-2 * (A > B));        ->  - 2 A < - 2 B
 INEQSIMP((A > B) + (C > D));   ->  C + A > D + B
 INEQSIMP((A > B) + (C >= D));  ->  C + A > D + B
 INEQSIMP((A > B) + (D < C));   ->  C + A > D + B
 INEQSIMP(INEQ_REVERSE(A>B) + (D<C)); -> D + B < C + A

Do EXAMPLE(INEQSIMP); for an example and DEMO(INEQSIMP); for a 
longer demonstration.

See also INEQ_REVERSE and INEQ_LINSOLVE.

&INF

Real positive infinity.  See also MINF, INFINITY.

&INFAPPLY(fun, expr)

Keeps applying fun to expr until it stops changing.  For example,

 - INFAPPLY('RATSIMP,expr); returns the same result as
   FULLRATSIMP(expr);
 - INFAPPLY('HALFANGLES,expr); returns the same result as
   EV(expr,HALFANGLES); .

 (c1) DENEST_SQRT((408*SQRT(2)+577)^(1/24));
                                               1/12
 (d1)                         (12 sqrt(2) + 17) ;

 (c2) INFAPPLY('DENEST_SQRT,(408*SQRT(2)+577)^(1/24));  
                                             1/3
 (d2)                           (sqrt(2) + 1)

&INFEVAL(exp)

Evaluates exp in "infinite evaluation mode', which means as many
times as needed until the result stops changing.

INFEVAL

An EVFLAG that leads to an "infinite evaluation" mode.  EV repeatedly
evaluates an expression until it stops changing.  To prevent a
variable, say X, from being evaluated away in this mode, simply
include X='X as an argument to EV.  Of course expressions such as
EV(X,X=X+1,INFEVAL); will generate an infinite loop. Use this feature
with caution.

Do EXAMPLE(INFEVAL); for an example.  

&INFINITY

Complex infinity, an infinite magnitude of arbitrary phase arbitrary
angle.

See also INF and MINF.

&INFIX(oper {, lbp, rbp, lpos, rpos, pos})

Defines the symbol oper to be an INFIX operator.

All arguments after the first are optional, where

  oper = the symbol or string which denotes the operator,
  lbp  = left binding power           (default:180),
  rbp  = right binding power          (default:180),
  lpos = left part of speech          (default:any),
  rpos = right part of speech         (default:any),
  pos  = part of speech of the result (default:any).

A Macsyma INFIX operator is a function of two arguments. The operator
symbol appears between its two arguments. For example, A^2.

The Macsyma term INFIX differs from the mathematical term "infix."

 - In mathematical terminology, infix refers to an operator which is
   represented by a symbol or symbols located between each pair of
   consecutive arguments, whether it is a binary operator or an nary
   operator (nary in the mathematical sense of having any number of
   arguments).  

 - In Macsyma terminology, INFIX refers only to a binary operator
   which is represented by a symbol located between or among its
   arguments.

If you want a nary infix operator (in the mathematical sense of nary,
that is, accepting any number of arguments), then you must use a
Macsyma NARY operator.

Do USAGE(OPERATORS); for more information on defining operators.  

Do EXAMPLE(INFIX); for an example, and DEMO(OPERATORS); for a longer
demonstration.

See also PREFIX, POSTFIX, NARY, NOFIX, MATCHFIX.

&INFLAG default:FALSE

If set to TRUE, the functions for part extraction will look at the
internal form of exp.  Note that the simplifier re-orders expressions.
Thus FIRST(X+Y) will be X if INFLAG is TRUE and Y if INFLAG is FALSE.
(FIRST(Y+X) gives the same results).  Also, setting INFLAG to TRUE and
calling PART/SUBSTPART is the same as calling INPART/SUBSTINPART.
Functions affected by the setting of INFLAG are: PART, SUBSTPART,
FIRST, REST, LAST, LENGTH, the FOR ... IN construct, MAP, FULLMAP,
MAPLIST, REVEAL, ARGS and PICKAPART.

&INFOLISTS default:[LABELS,VALUES,FUNCTIONS,MACROS,ARRAYS,MYOPTIONS,
PROPS,ALIASES,RULES,DEPENDENCIES,GRADEFS,LET_RULE_PACKAGES,FEATURES]

A list of the names of all of the information lists in Macsyma.  These
are:

LABELS

  All bound C,D, and E labels.

VALUES

 All bound atoms, i.e. user variables, not Macsyma options or
 switches, (set up by : , :: , or functional binding). 

FUNCTIONS

  All user defined functions (set up by f(x):=...).

ARRAYS

  Declared and undeclared arrays (set up by ARRAY, : , :: ,
  or :=...)

MACROS

  Any Macros defined by the user.

MYOPTIONS

  All options ever reset by the user (whether or not they get reset
  to their default value).

RULES

  User defined pattern matching and simplification rules (set up
  by TELLSIMP, TELLSIMPAFTER, DEFMATCH, or, DEFRULE.)

ALIASES

  Atoms which have a user defined alias (set up by the ALIAS,
  ORDERGREAT, ORDERLESS functions or by DECLAREing the atom a NOUN).

DEPENDENCIES

  Atoms which have functional dependencies (set up by the DEPENDS or
  GRADEF functions).

GRADEFS

  Functions which have user defined derivatives (set up by the GRADEF
  function).

PROPS

  Atoms which have any property other than those mentioned above, such
  as atvalues, matchdeclares, etc. as well as properties specified in
  the DECLARE function.

LET_RULE_PACKAGES

  A list of all the user-defined let rule packages plus the special
  package DEFAULT_LET_RULE_PACKAGE.  (DEFAULT_LET_RULE_PACKAGE is the
  name of the rule package used when one is not explicitly set by the
  user.)

&INIT

When you enter Macsyma, the system automatically attempts to load 
system-wide and personal INIT files.  INIT files are not required, 
but they are used to customize Macsyma by defining certain functions, 
setting option variable assignments, loading desired packages, etc.  

The default name of the system-wide Macsyma INIT file in PC Macsyma 
is "init.lsp" ("init.lisp" elsewhere) on the system subdirectory 
in the Macsyma hierarchy.

The default name of the personal Macsyma INIT file in PC Macsyma 
is "mac-init.mac" and "macsyma-init.macsyma" elsewhere.  This file 
would be located on the user's home directory.

The INIT file can be in the Lisp language or in the Macsyma 
language or it can be object code.  A Macsyma language INIT file can 
LOAD Lisp language files.  Similarly, a Lisp language INIT file can 
load Macsyma language files by using the Lisp form ($load "pathname") .
Macsyma is shipped with a system-wide Lisp language INIT file seed 
but the user can change this.

The order of INIT file search is first for a binary file, then for 
a Lisp language file, and lastly for a Macsyma language file.

A sample Macsyma language Macsyma INIT file follows:

   /* This is an empty Macsyma initialization file.
      Macsyma commands which you place in this file will be 
      executed each time you execute the command 
      INITIALIZE_MACSYMA();. */

   showtime:true$ 
       
   pi:dfloat(%pi)$

   setup_autoload("share;mypkg",j0,j1,jn)$


Also: "SETUP_AUTOLOAD" can be used to make functions in BATCH files
autoloading, meaning that you can then use (for instance, here) the
functions j0, j1 and jn from the mypkg  package directly because when
you use the function the mypkg package will be loaded in for you
automatically.  If the filename extension is not specified 
(such as .mac,.lsp, .fas ; see FILE_PATHNAMES for more information),
then it searches first for a binary file, then for a Lisp file, and 
lastly for a Macsyma source file.

&INIT_ATENSOR(algebra_name, optional_dims)

[ATENSOR package] This function sets the values of ALG_TYPE, AFORM and
ADIM, to generate specific tensor algebras over real vector spaces.
Some possible values of ALGEBRA_NAME are:

 COMPLEX: generates complex numbers as a Clifford algebra over a
        1-dimensional real vector space, 

 QUATERNION: generates quaternions as a Clifford algebra over a
        2-dimensional real vector space,

 PAULI: generates the Pauli algebra as a Clifford algebra over a
        3-dimensional real vector space.

 DIRAC: generates the Dirac algebra as a Clifford algebra over a
        4-dimensional real vector space, with metric signature
        (+,+,+,-). 

Other allowed values for ALGEBRA_NAME are UNIVERSAL, GRASSMANN,
SYMMETRIC, CLIFFORD, and SYMPLECTIC.  In the case of CLIFFORD, you
have the option of specifying OPTIONAL_DIMS, which is one, two, or
three nonnegative integers which are the number of positive-definite
dimensions, degenerate dimensions, and negative-definite dimensions in
the bilinear form.  If no optional dimensions are specified, then the
symmetric bilinear form SF is not evaluated.  In the case of
SYMPLECTIC, you have the option of specifying one or two nonnegative
integers which are the number of nondegenerate dimensions (an even
integer) and the number of degenerate dimensions of the symplectic
bilinear form.  If no optional dimensions are specified, then the
antisymmetric bilinear form AF is not evaluated.

Note that algebras of Boson (Fermion) creation and annihilation operators 
form symplectic (Clifford) algebras.

The bilinear forms SF, AF and AV which appear in the fundamental
algebraic relations listed above can be evaluated in the case when the
vector arguments to SF, AF or AV are identifiable as basis elements of
the underlying vector space.

&INIT_CARTAN(coord_list)

[CARTAN package] Initializes some global variables for the CARTAN
package.  coord_list is an ordered list of coordinates.

&INIT_CTENSOR()

[CTENSOR package] Clears out old values and arrays left over from
previous computations with CTENSOR.  Also resets CTENSOR flags.

&INIT_ITENSOR()

[ITENSOR package] Initializes the ITENSOR package, including the
user-specified tensor components, symmetries, contraction properties,
coordinate symbols, and the option variables (ALLSYM, DIM, ICOUNTER,
IDUMMYX, IFRAME_FLAG, IMETRIC, ITORSION_FLAG, and METRICCONVERT).  If
an ITENSOR session has been interrupted so that some of the lists
storing information are modified, then INIT_ITENSOR may fail to clean
out some of the associated properties.

&INIT_PHYSICAL_CONSTANTS()

[PHYCON package] See PHYSICAL_CONSTANTS.

&INITIALIZE_MACSYMA()

Cleans up the Macsyma computation environment.  It performs four
operations:
 1. Kills user-defined variables, functions, properties, etc. 
    as if KILL(ALL) had been done.
 2. Resets system variables to their defaults as if RESET(ALL)
    had been done.
 3. Restarts the Macsyma process.
 4. Reloads your initialization file (if it exists).

&INM

[ITENSOR package] See INONMET.

&INMC2([i,j], [k])

[ITENSOR package] Computes the contribution to the connection
coefficients from the conformal nonmetricity vector, with one
contravariant index.

See also ICC2.

&INNERPRODUCT(X, Y)

[EIGEN package] Takes two LISTS of equal length as arguments and
returns their inner (scalar) product defined by (Complex Conjugate of
X).Y (The "dot" operation is the same as the usual one defined for
vectors).   Do LOAD("EIGEN"); to access it.

&INONMET_FLAG default:FALSE

[ITENSOR package] When TRUE, ITENSOR computes using conformal
nonmetricity vector, denoted by the symbol INM.  This flag also causes
command IC_CONVERT to convert the name INM into CTENSOR notation.

&INPART(exp, n1, ..., nk)

Is similar to PART but works on the internal representation of the
expression rather than the displayed form and thus may be faster since
no formatting is done.  Care should be taken with respect to the order
of subexpressions in sums and products (since the order of variables
in the internal form is often different from that in the displayed
form) and in dealing with unary minus, subtraction, and division
(since these operators are removed from the expression).  PART(X+Y,0)
or INPART(X+Y,0) yield "+" (which must be enclosed in double quote
marks to be used in comparisons and so forth).  For example, IF
INPART(D9,0)="+" THEN ...

 (c1)  X+Y+W*Z;

 (d1)                  w z + y + x

 (c2)  INPART(D1,3,2);

 (d2)                  z
 (c3)  PART(D1,1,2);

 (d3)                  z

 (c4) 'LIMIT(F(X)^G(X+1),X,0,MINUS);
                                       g(x + 1)
 (d4)                      limit   f(x)
                           x ->0-

 (c5) INPART(%,1,2);
 (d5)                            g(x + 1)

Do EXAMPLE(INPART); for an example.  

See also PART.

&INRT(X, n)

Takes two integer arguments, X and n, and returns the integer nth root
of the absolute value of X.

Do EXAMPLE(INRT); for an example.  

&INTANALYSIS default:TRUE

When TRUE, DEFINT checks for poles in the interval of integration.
When FALSE, DEFINT bypasses this time-consuming check, but this can
lead to wrong answers if there are poles.  The FALSE setting should
be used with caution.

See also INTANALYSIS_WARN and INTANALYSIS_CONTINUE.

&INTANALYSIS_CONTINUE default:TRUE

If INTANALYSIS is TRUE (the default) and definite integration cannot 
determine whether there are poles in the interval of integration, 
then if INTANALYSIS_CONTINUE is TRUE (the default), MACSYMA will 
continue and try to do the integral.  If INTANALYSIS_WARN is TRUE 
(the default), messages to this effect are printed.

If INTANALYSIS_CONTINUE is FALSE, then MACSYMA will not continue in 
this case and the noun-form will be returned.

&INTANALYSIS_WARN default:TRUE

If TRUE and when INTANALYSIS is TRUE, if definite integration cannot 
determine whether there are poles in the interval of integration; 
the integrand involves only known functions; and INTANALYSIS_CONTINUE 
is FALSE, then a message is printed suggesting that you might want to 
try the problem with INTANALYSIS set to FALSE.

See also INTANALYSIS_CONTINUE.

&INTEGCONSTPREFIX default:%INTEGCONST

Together with INTEGCONSTNUM, this option variable gives the user
control over the naming of integration constants.  INTEGCONSTPREFIX 
is the alphabetic prefix used when generating names, and INTEGCONSTNUM 
is the numeric suffix used.  Macsyma introduces integration constants 
when computing indefinite integrals of equations.

&INTEGCONSTNUM default:0

Together with INTEGCONSTPREFIX, this option variable gives the user
control over the naming of integration constants.  INTEGCONSTPREFIX 
is the alphabetic prefix used when generating names, and INTEGCONSTNUM 
is the numeric suffix used.  If INTEGCONSTNUM is set to FALSE, then 
no numeric suffix is used.  Macsyma introduces integration constants 
when computing indefinite integrals of equations.

&INTEGER

Property and argument to PLOT.

When a symbol is declared INTEGER, automatic simplifications can
exploit this fact.  For example, SIN(n*%pi) simplifies to 0 if n is
declared INTEGER.  A symbol can be declared INTEGER if it is known to
represent a number that is an integer or a function that takes only
integral values.  INTEGER is a member of the FEATURES list.  It can be
asserted with DECLARE, withdrawn with REMOVE, and detected with
FEATUREP.

In the PLOT function, the variable range for the plot can take the
form of 'low, high, INTEGER' meaning that the variable takes on only
integer values in the range specified by low and high.

Do EXAMPLE(INTEGER); for an example.

See also EVEN, ODD, INTEGERP.

&INTEGER_PRINT_WIDTH default:0

Defines the width of integer fields as a fixed number of characters.
When INTEGER_PRINT_WIDTH=0, integer fields are of variable width.  If
an integer will not fit in a field of specified width, the field is
enlarged, so the display of the integer is not truncated.

Do EXAMPLE(INTEGER_PRINT_WIDTH); for an example.

See also FLOAT_PRINT_WIDTH, FLOAT_PRINT_DIGITS_AFTER_POINT.

&INTEGERP(exp)

Returns TRUE if exp is an integer else FALSE.

Do EXAMPLE(INTEGERP); for an example.

See also EVENP, ODDP, PREDICATES.

&INTEGOP(arg1, ..., argn)

[OPALG package] The integration operator. When given one argument
arg1, INTEGOP(arg1) means indefinite integration with respect to the
variable arg1. Definite integration with limits [arg2,arg3] can be
represented as INTEGOP(arg1,arg2,arg3).

&INTEGRAL

See INTEGRATION_SUMMARY.

&INTEGRAL_EQUATIONS

See IEQN and USAGE(INTEQN); .

&INTEGRALS

See INTEGRATION_SUMMARY.

&INTEGRATE(exp, var)

Finds the indefinite integral of exp with respect to var or returns an
integral expression (the noun form) if it cannot.

INTEGRATE(exp, var, low, high)

Finds the definite integral of exp with respect to var from low to high.  
It returns the noun form if it cannot perform the integration.

Do EXAMPLE(INTEGRATE); for an example.  

To split a definite integral over subintervals, see INTERVAL_INTEGRATE.

Do USAGE(INTEGRATE); for more information on INTEGRATE.

See also INTANALYSIS, ANTIDIFF, BYPARTS, DEFINT, LDEFINT, TLDEFINT, RISCH.

See INTEGRATION_SUMMARY for an overview of integration capabilities in
Macsyma.

&INTEGRATE_DATA(xlist, ylist)

Computes the numerical integral of the y-axis data given by ylist at the
x-axis values xlist using all of the points. xlist and ylist must have the
same length and must describe a functional relational. Multivalued data is
not allowed. xlist must be non-decreasing. Otherwise, xlist need not
describe equally spaced data, or data at any special quadrature points.
ylist can describe wildly varying data.

INTEGRATE_DATA optionally plots the data points if the flag 
INTEGRATE_DATA_SHOW_DATA is TRUE.

The interpolation method for the data between points is INTEGRATE_DATA_TYPE,
which can be 'LINEAR, 'SPLINE [Default] or 'REVERSE.

INTEGRATE_DATA can take data from a DataViewer as well.

Do EXAMPLE(INTEGRATE_DATA); for a practical example.

See also QUADRATR, INTEGRATION_SUMMARY.

&INTEGRATE_DATA_TYPE default:'SPLINE

See INTEGRATE_DATA.

&INTEGRATE_DATA_SHOW_DATA default:'FALSE

See INTEGRATE_DATA.

&INTEGRATION_SUMMARY

Macsyma has several routines for performing indefinite and definite
integration.

Indefinite Integration
----------------------

 - The INTEGRATE with two arguments makes use of most of the methods
   for indefinite integration available in Macsyma. 
 - The RISCH command evaluates indefinite integrals using the Risch
   algorithm.  INTEGRATE calls RISCH when appropriate.
 - INTSCE implements a special fast algorithm for integrating
   expressions consisting of sine, cosine and exponential functions.
 - The command POISINT in the POISSON package uses a special
   representation and algorithm to integrate Poisson series
   efficiently.
 - The ANTIDIFF command finds indefinite integrals of expressions
   which include derivatives of an unspecified function. 
 - DEFINT evaluates indefinite integrals of expressions which include
   Dirac delta functions.

Definite Integration
--------------------

 - The INTEGRATE command with four arguments is the main tool for 
   performing definite integrals. INTEGRATE uses most of the other
   techniques listed below, including DEFINT, SPECINT and LAPLACE.
 - The commands LDEFINT, and TLDEFINT perform definite integrals
   by taking limits with respect to the lower and upper limits of
   integration.  
 - RESIDUE computes the residue integral in the complex plane.
 - INTERVAL_INTEGRATE splits an integral over several user-specified
   intervals.  This is useful for integrating expressions which
   include ABS, SIGNUM, UNIT_STEP and UNIT_RAMP.
 - The option variable COMPLEX_INTEGRATE (default:FALSE), when TRUE,
   enables Macsyma to evaluate some complex integrals.
 - The FOURIER package extends the definite integration capabilities
   in Macsyma to do more Fourier transforms. 
 - The commands LAPLACE and SPECINT perform Laplace integrals.
 - DEFINT evaluates definite integrals of expressions which include
   Dirac delta functions.

Transforming Integrals
----------------------

 - BYPARTS performs integration by parts, using a specified 
   decomposition of the integrand into a function and a differential.
 - CHANGEVAR implements a change of variables in a definite or
   indefinite integral.

General Numerical Integration
-----------------------------

 - QUADRATR implements extrapolated Gauss quadrature.  This tends
   to be the most reliable and stable method of numerical integration
   in Macsyma. Works with single and double precision numerical
   data, not BFLOATs.
 - GAUSS_LEGENDRE_INT implements Gauss-Legendre quadrature. Works with
   BFLOATs.
 - The Romberg method, using the command ROMBERG and BROMBERG.  
   See DEMO(MULTIPLE_INTEGRAL); for multiple integrals with
   ROMBERG.
 - QUANC8 implements the Newton-Cotes 8 panel quadrature rule for
   adaptive integration.
 - SIMPSON implements Simpson's rule.
 - TRAPRULE implements the trapezoidal rule. 
 - QUAD_INF integrates over intervals with one or both endpoints at
   infinity, using any of the other numerical quadrature methods.
 - INTEGRATE_DATA integrates numerical data given in the form of 
   lists. The data need not be equally spaced.

Special Numerical Integrals
---------------------------

 - Macsyma evaluates ELLIPTIC_INTEGRALS numerically.
 - Macsyma evaluates exponential integrals with the commands EXP_INT,
   SIN_INT, COS_INT, SINH_INT and COSH_INT.
 - FFT implements fast Fourier transforms.
 - Macsyma evaluates JACOBIAN_ELLIPTIC_FUNCTIONS numerically.

Generally speaking, Macsyma handles symbolic integrals which are
integrable in terms of the "elementary functions" (rational
functions, trigonometric, logs, exponentials, radicals, etc.) and a
few extensions (error function, dilogarithm). 

See DEMOS_CALCULUS for a list of demonstrations of integration.

&INTERRUPTS

There are several ways the user can interrupt a Macsyma computation.
On PC Macsyma, you can push the pause key, or click with your mouse on
the "interrupt button located at the edge of the Macsyma window. 

See also CHARACTERS.

&INTERSECT(l1, ... , ln)

a synonym for INTERSECTION.

Do EXAMPLE(INTERSECT); for an example.  

&INTERPOL

A package for locating and interpolating values of functions from
tabulated numerical data, using polynomials, rational functions, and
splines.

Do USAGE(INTERPOL); for more information.

Do DEMO(INTERPOL); for a demonstration of interpolation using
polynomials and rational functions, and DEMO(INTERPOL1); for a
demonstration of interpolation using splines.

&INTERPOL_DEFAULT_NUM default:4

Controls the number of coefficients used by TABLE_LOOKUP and
TABLE_LOOKUP2 in the interpolation functions. Its value can be any
integer >= 2 or a list of two such integers. 

Do USAGE(INTERPOL); for more information.

Do DEMO(INTERPOL); for a demonstration of interpolation using polynomials and rational functions, and DEMO(INTERPOL1); for a
demonstration of interpolation using splines.

&INTERPOL_METHOD default:'polynomial

Controls the interpolation method used by TABLE_LOOKUP.  Possible
values are 'POLYNOMIAL and 'RATIONAL.  At present TABLE_LOOKUP2 always
uses polynomial interpolation.

&INTERPOLIST(lis, n)

Given a nonempty list lis, produces a list of length n (>1) with the
same first and last elements, and interior elements linearly
interpolated.  

Example: 

 (c1) INTERPOLIST([A,B], 3);

 (d1)                   [a,(a+b)/2,b]

 (c2) INTERPOLIST([A,B,C,D], 3);

 (d2)                   [a,(b+c)/2,d]


Do EXAMPLE(INTERPOLIST); for an example.

See also MAKELIST.

&INTERSECT_LINE_HYPERPLANE(line1, hplane1)

[GEOFUNCS package] Finds the point of intersection of a line 
with an N-1 dimensional hyperplane in an N-dimensional space.

Arguments:

 - line1 is a list which specifies a line. It can have one of two forms.
   - [P, A] where P is an N-tuple of numbers or expressions, and 
     represents a point on a line in N-space. A is an N-tuple of numbers
     or expressions, and represents a vector in N-space.
   - [P, R, 'points], where P and R are N-tuples representing points
     on the line, and the symbol 'points indicates that R is interpreted
     as a point and not as a vector.
 - hplane1 is a list of length N+1 which specifies the hyperplane. If the
   equation of the hyperplane is b1*x1+ ... + bn*xN = b0, then 
   hplane1: [b1, ..., bN, b0] .

The function returns a list of length N which is the coordinates of the
point of intersection of the line and the hyperplane.  If there is no
intersection, it returns the empty list []. If the line lies in the 
hyperplane, then the entire line is returned as a solution.

Do EXAMPLE(INTERSECT_LINE_HYPERPLANE); for an example.

&INTERSECTION(l1, ... , ln)

Returns the intersection of the lists l1,...ln.  The function takes an
arbitrary number of lists as arguments.

Do EXAMPLE(INTERSECT); for an example.  

See also SET and USAGE(SET); for more about operations on sets in
Macsyma.

&INTERVAL_INTEGRATE(expr, var, lo {, mid1,...,midk}, hi)

[CALFUNCS package] Integrates the expression expr with respect to
variable var between the limits lo and hi.  The optional arguments
mid1 ... midk cause Macsyma to break up the integral into a sum of
integrals over the intervals [lo,mid1], [mid1,mid2], ... [midk,hi].

The limits of integration are explicitly ASSUMEd to be real and
strictly monotonically increasing.  If the data base routines
determine that this is not so, an error is signaled.

This procedure enables Macsyma to evaluate integrals containing 
functions with point discontinuities or discontinuous slopes, 
such as ABS, SIGNUM, UNIT_STEP and UNIT_RAMP.

Do EXAMPLE(INTERVAL_INTEGRATE); for an example.

&INTFACLIM default:1000

Is the largest divisor which will be tried when factoring a bignum
integer.  If set to FALSE (this is the case when the user calls FACTOR
explicitly), or if the integer is a fixnum (i.e.  fits in one machine
word), complete factorization of the integer will be attempted.  The
user's setting of INTFACLIM is used for internal calls to FACTOR.
Thus, INTFACLIM may be reset to prevent Macsyma from taking an
inordinately long time factoring large integers.

&INTO_BINOM(expr)

Shifts the upper and lower indices of binomial coefficients to absorb,
where possible, any multiplying factors.

Do EXAMPLE(INTO_BINOM); for an example.

See also BINOM_CONTRACT.  

&INTOPOIS(A)

[POISSON package] Converts A into a Poisson encoding.

Do EXAMPLE(INTOPOIS); for an example.  

&INTOPROD(expr)

[NUSUM package] Is analogous to INTOSUM, except that it works for
products.

&INTOSUM(expr)

Takes all external factors that multiply a summation, and put them
inside the summation.  If the index is used in the outside expression,
then the function tries to find a reasonable index, the same as it
does for SUMCONTRACT.  This is essentially the reverse idea of the
OUTATIVE property of summations, but note that it does not remove this
property, it only bypasses it.  In some cases, a
SCANMAP(MULTTHRU, expr) may be necessary before the INTOSUM.

Do EXAMPLE(INTOSUM); for an example.

See also SUM, NUSUM, SUMCONTRACT, SIMPSUM

&INTSCE(expr, var)

Uses an efficient method for integrating an expression expr, which
consists of products of sines, cosines and exponentials of the form

  EXP(A*X+B)*COS(C*X)^N*SIN(C*X)^M .

If it is not in the above form then the regular integration program
will be invoked if the switch ERRINTSCE (default:TRUE) is TRUE.  If it
is FALSE then INTSCE will err out.  INTSCE is contained in a library
file called INTSCE, and was written by Richard Bogen.

Do EXAMPLE(INTSCE); for an example.  

&INV

An alias for the matrix inversion function INVERT.

&INV_BETA_DISTRIB(y, alpha, beta)   

The inverse of the cumulative beta probability distribution
function. 

See also BETA_DISTRIB.

&INV_CAUCHY_DISTRIB(y, alpha, beta)

[UNIPROB package] The inverse of the cumulative Cauchy
 probability distribution function.

See also CAUCHY_DISTRIB.

&INV_CHI_SQUARE_DISTRIB(y, dof)

The inverse of the cumulative chi square probability
distribution function. 

See also CHI_SQUARE_DISTRIB.

&INV_CONTINUOUS_POISSON_DISTRIB(y, lambda)

The inverse of the cumulative continuous Poisson probability
distribution function.

See also CONTINUOUS_POISSON_DISTRIB.

&INV_ERF(x)

[CALFUNCS package] The inverse function of the error function
ERF(x).

Do EXAMPLE(INV_ERF) for an example.

&INV_EXPONENTIAL_DISTRIB(y, lambda)

[UNIPROB package] The inverse of the cumulative 
exponential probability distribution function.

See also EXPONENTIAL_DISTRIB.

&INV_F_DISTRIB(y, df1, df2)

The inverse of the cumulative F probability distribution
function. 

See also F_DISTRIB.

&INV_FOURIER(expr, xi, x)

[FOURIER package] Computes the inverse Fourier transform of expr using
the transform variable xi. If expr: fourier(func,x,xi); then
is(func=inv_fourier(expr,xi,x)) is TRUE.

Do EXAMPLE(INV_FOURIER); for an example, and DEMO(FOURIERT); for a
longer demonstration. 

See also FOURIER.

&INV_GAMMA_DISTRIB(y, alpha, beta)

The inverse of the cumulative gamma probability distribution
function. 

See also GAMMA_DISTRIB.

&INV_GUMBEL_DISTRIB(y, alpha, beta)

[UNIPROB package] The inverse of the cumulative Gumbel
probability distribution function.

See also GUMBEL_DISTRIB.

&INV_LAPLACE_DISTRIB(y, alpha, beta)

[UNIPROB package] The inverse of the cumulative Laplace
probability distribution function.

See also LAPLACE_DISTRIB.

&INV_LOGISTIC_DISTRIB(y, alpha, beta)

[UNIPROB package] The inverse of the cumulative logistic
probability distribution function.

See also LOGISTIC_DISTRIB.

&INV_LOGNORMAL_DISTRIB(y, mu, var)

[UNIPROB package] The inverse of the cumulative lognormal
probability distribution function.

See also LOGNORMAL_DISTRIB.

&INV_MAXWELL_DISTRIB(y, beta)

The inverse of the cumulative Maxwell probability distribution
function.

See also MAXWELL_DISTRIB.

&INV_NORMAL_DISTRIB(y, mean, variance)

[UNIPROB package] The inverse of the cumulative normal
probability distribution function.

See also NORMAL_DISTRIB.

&INV_PARETO_DISTRIB(y, x0, theta)

[UNIPROB package] The inverse of the cumulative Pareto
probability distribution function.

See also PARETO_DISTRIB.

&INV_STANDARD_NORMAL_DISTRIB(y)

[UNIPROB package] The inverse of the cumulative standard
normal probability distribution function.

See also STANDARD_NORMAL_DISTRIB.

&INV_STUDENTS_T_DISTRIB(y, dof)

The inverse of the cumulative students t probability
distribution function. 

See also STUDENTS_T_DISTRIB.

&INV_UNIFORM_DISTRIB(y, a, b)

[UNIPROB package] The inverse of the cumulative uniform
(continuous) probability distribution function.

See also UNIFORM_DISTRIB.

&INV_WEIBULL_DISTRIB(y, a, b)

[UNIPROB package] The inverse of the cumulative Weibull
probability distribution function.

See also WEIBULL_DISTRIB.

&INV_WISHART_MDF(Z, V, nu {, zdet, vdet})

The multivariate Wishart probability density function with zero mean
value.  The inverted Wishart distribution is like a multivariate
inverted gamma distribution.

 - Z is an m x m positive definite symmetric matrix of random
   variables.
 - V is the precision matrix, an m x m positive definite symmetric
   matrix which is the inverse of the covariance matrix.
 - nu is the number of degrees of freedom.  It can be a number or 
   a mathematical expression.
 - zdet is the determinant of the matrix Z.  If you know zdet,
   you can specify it and save the time needed to recompute it.
 - vdet is the determinant of the matrix V.  If you know vdet,
   you can specify it and save the time needed to recompute it.

                           nu/2
                     det(V)             1
 WISHART_MDF = k ---------------- exp(- - trace(Z^^-1 . V))
                       (nu+m+1)/2       2
                 det(Z)
                                    m
                                  -----
               nu*m/2   m*(m-1)/4  | |
  where 1/k = 2      %pi           | | Gamma((nu+1-i)/2)
                                   | |
                                   i=1  

Do EXAMPLE(INV_WISHART_MDF); for an example.

See also WISHART_MDF, GAMMA_DENSITY.

&INVERT(mat)

Finds the inverse of the matrix mat using the method indicated by the
switch USE_MINORS (default: FALSE).

 - When USE_MINORS is FALSE, the method used is one based on Gaussian
   elimination.

 - When USE_MINORS is set to TRUE, minors are used to compute the inverse.

The USE_MINORS:TRUE setting allows the user to compute the inverse 
of a matrix with bfloat entries or polynomials with floating point 
coefficients without converting to CRE-form.  The DETERMINANT command 
is used to compute cofactors, so if RATMX is FALSE (the default) the 
inverse is computed without changing the representation of the elements. 

The DETOUT flag if TRUE keeps the determinant factored out of the inverse.

Note: The results are not automatically expanded.
 - If the matrix originally had polynomial entries, better appearing
   output can be generated by EXPAND(INVERT(mat)),DETOUT.
 - If it is desirable to then divide through by the determinant this
   can be accomplished by
   EXPAND(ADJOINT(mat))/EXPAND(DETERMINANT(mat)).

INVERT(mat):=ADJOINT(mat)/DETERMINANT(mat).

INVERT has the alias INV.

Do EXAMPLE(INVERT); for an example.  

See also "^^" , INVERT_USING_MINORS, INVERT_HANKEL, INVERT_BY_LDU,
INVERT_BY_CHOLESKY, INVERT_BY_LU, INVERTC, MAT_LDIV, MAT_RDIV, 
INVERT_PSYMHANKEL, MOORE_PENROSE_INVERSE, SHERMAN_MORRISON and
SPARSE.  

See MATRIX_SUMMARY for a summary of Macsyma's capabilities in
matrix algebra.

&INVERT_BY_CHOLESKY(A)

Computes the inverse of the numerical, square, positive definite,
Hermitian matrix A using its Cholesky factorization.

Do EXAMPLE(INVERT_BY_CHOLESKY); for an example.

See also CHOLESKY_DECOMP.

&INVERT_BY_LDU(M)

Inverts the square matrix M using LDU decomposition.

See also INVERT, LDU_DECOMP, INVERT_BY_LU, INVERT_BY_CHOLESKY.

&INVERT_BY_LU(M)

Computes the inverse of the numerical square matrix M using its LU
factorization.

Do EXAMPLE(INVERT_BY_LU); for an example.  

See also INVERT, LU_DECOMP, LU_COMPUTE_CONDITION, INVERT_BY_LDU, 
INVERT_BY_LU_SYMB, NUMERICAL_MATRIXP, and CNUMERICAL_MATRIXP.

&INVERT_BY_LU_SYMB(M)

Computes the inverse of the symbolic square matrix M using its LU
factorization.

Do DEMO(MAT6INVERT); for an example.  

See also INVERT, LU_DECOMP_SYMB, MATSOLVE_BY_LU_SYMB

&INVERT_HANKEL(M)

Inverts the Hankel matrix M.

&INVERT_PERMUTATION(permlist)

Returns the inverse of the permutation represented by the list
permlist.  

See USAGE(PERMUTATIONS); for related commands.

Do EXAMPLE(INVERT_PERMUTATION); for an example.

&INVERT_PSYMHANKEL(M)

Inverts the persymmetric Hankel matrix M. 

&INVERT_TOEPLITZ(M)

Inverts the Toeplitz matrix M.

&INVERT_USING_MINORS(mat)

Inverts the matrix mat using an adjoint method that uses minors.
INVERT and ^^-1 call this function when the USE_MINORS switch is set
to TRUE.

&INVERTC(mat)

Inverts the complex numerical matrix mat.  INVERTC is more efficient
that INVERT because, while INVERT uses symbolic code for complex
matrices, INVERTC converts n x n complex numerical matrices to 2n x 2n
real matrices and inverts using LU decomposition.

Do EXAMPLE(INVERTC); for an example.

&INVHILBERT(n)

Returns the inverse of the Hilbert matrix of size n.

Do EXAMPLE(INVHILBERT); for an example.

&INVOLUTION - Property

A function can be declared INVOLUTION if it represents a function in
involution (that is, g(g(x))=x).  INVOLUTION is a member of the
FEATURES list.  It can be asserted with DECLARE, withdrawn with
REMOVE, and detected with FEATUREP.

Do EXAMPLE(INVOLUTION); for an example.

&IRICCI([j,h])

[ITENSOR package] computes the Ricci curvature tensor of an affine
connection as an indicial tensor.  The conventions used for the Ricci
curvature tensor are given by:

                      k
 IRICC    = ICURVATURE
      j h              j k h

See also ICURVATURE, ISCURVATURE and IWEYL.

&IRRATIONAL - Property

A symbol can be declared IRRATIONAL if it is known to represent an
irrational number or a function that takes only irrational values.
IRRATIONAL is a member of the FEATURES list.  It can be asserted with
DECLARE, withdrawn with REMOVE, and detected with FEATUREP.

&IRREDUCIBLE

This command is obsolete.

&IS(exp)

Attempts to determine whether exp (which must evaluate to a predicate)
is provable from the facts in the current database.  IS returns TRUE
if the predicate is true for all values of its variables consistent
with the database and returns FALSE if it is false for all such
values.  Otherwise, its action depends on the setting of the switch
PREDERROR (default: TRUE).  IS errs out if the value of PREDERROR is
TRUE and returns UNKNOWN if PREDERROR is FALSE.

Macsyma assumes variables are real unless they are DECLAREd COMPLEX 
or the variable DOMAIN is set to COMPLEX.

Macsyma uses an algorithm for making sign inferences on univariate 
polynomials (the Tarski algorithm) but an algorithm has not been 
implemented for multivariate polynomials (including multivariate 
linear inequalities).  So Macsyma knows that is(x^2-x+1>0); is true,
but if assume(a>b); is done then is(a>b); is true, but Macsyma doesn't 
know if a+1>b .

Do EXAMPLE(IS); for an example.  

See also EQUAL, SIGN, MAYBE, PREDICATES, and PREDERROR.

&ISHOW(exp)

[ITENSOR package] Displays the indicial tensor object exp with
covariant indices as subscripts, and contravariant indices as
superscripts.  The derivative indices will be displayed as subscripts,
separated from the covariant indices by a comma.

To display upper and lower indices for expressions which are not
indicial tensors in the ITENSOR representation, see INDEXED.

&ISOLATE(exp, var)

returns exp with subexpressions which are sums and which do not
contain var replaced by intermediate expression labels (these being
atomic symbols like E1, E2, ...).  This is often useful to avoid
unnecessary expansion of subexpressions which don't contain the
variable of interest.  Since the intermediate labels are bound to the
subexpressions they can all be substituted back by evaluating the
expression in which they occur.

EXPTISOLATE default:FALSE

  If TRUE will cause ISOLATE to examine exponents of atoms (like %E)
  which contain var.

ISOLATE_WRT_TIMES default:FALSE

  If TRUE, then ISOLATE will also isolate with respect to products.
  E.g. compare both settings of the switch on ISOLATE(A*B*C,C); .

Do EXAMPLE(ISOLATE); for an example.  

See also ISOLATE_WRT_TIMES, DISOLATE.

&ISOLATE_WRT_TIMES default:FALSE

If set to TRUE, then ISOLATE will also isolate with respect to products. For
example, compare both settings of the switch on ISOLATE(A*B*C,C); .

&ISQRT(X)

Takes one integer argument and returns the "integer SQRT" of its
absolute value.

Do EXAMPLE(ISQRT); for an example.  

See also INRT.

&ITENFORM(expr {, method1, method2})

[ITENSOR package] Combines various methods for simplifying the
indicial tensor EXPR.  Normally, ITENFORM applies ICANFORM to the
expression and then checks whether any of the terms in the result are
zero tensors (for example, the product of a symmetric tensor with an
antisymmetric tensor).  The optional simplification strategies are:

 - RENAME    (apply RENAME with both possible values of FLIPFLAG)
 - ICANFORM  (reapply ICANFORM). 
 - ALL       tries all possible strategies.

If optional methods are specified, they will be performed directly after
the initial application of ICANFORM.  The optional methods may produce a
more simplified version of the original expression, but may take much
more time to execute.  ITENFORM is usually the most powerful and the
most time-consuming simplification command in ITENSOR.

Do DEMO(ITENSIMP); for a demonstration of ITENFORM and other ITENSOR 
simplification commands.

See also ICANFORM, ICANTEN, FLIPFLAG, RENAME.

&ITENSOR

The indicial tensor computation package.  Indicial tensor computation
means performing tensor computations while treating tensors as indexed
symbols whose components are not assigned specific values.  Tensor
operations such as covariant differentiation, curvature computations,
and tensor contraction can be carried out at this level.

ITENSOR can be loaded by typing LOAD("ITENSOR"); , or by invoking the
autoloading commands INIT_ITENSOR or IMETRIC.

Do USAGE(ITENSOR); for more information.  

For demonstrations, do
 DEMO(ITENSOR);        Indicial tensors, introductory demo
 DEMO(ITENSOR1);       Riemann geometry, basic computations
 DEMO(CONSTANT_CURV);  Riemann geometry, spaces of constant curvature

Do DEMO(TENS_PDE); for a demonstration of ITENSOR working with CTENSOR,
the component tensor package, to manipulate tensor partial differential
equations.

See also TENSOR_SUMMARY for an overview of tensors in Macsyma.

&ITENSR 

The indicial tensor computation package has been renamed ITENSOR.

&ITERATION

Macsyma provides a DO loop for iteration. 

See also DO.

&ITORSION_FLAG default:FALSE

[ITENSOR package] When TRUE, ITENSOR computes using affine torsion
tensor, denoted by the symbol ITR, and the contortion tensor, denoted
by the symbol IKT2.  This flag also causes command IC_CONVERT to
convert names of torsion and contortion into CTENSOR notation.

&ITR

[ITENSOR package] is the symbol used for the affine torsion tensor.

&ISCURVATURE([])

[ITENSOR package] computes the scalar curvature of an affine connection
as an indicial tensor.  The conventions used for the scalar curvature
are given by: 

                                    j h
 ISCURVATURE  :=  IRICCI     IMETRIC
                        j h

See also ICURVATURE, IRICCI and IWEYL.

&IWEYL([i,j,k,h])

[ITENSOR package] computes the Weyl curvature tensor of an affine
connection as an indicial tensor.  The conventions used for the
Weyl curvature tensor are given by: 


  IWEYL        := ICURVATURE        - Z      g
       i j k l              i j k l    [j|[l  k]|i]

                 4              1
  where  Z   := --- IRICCI   - --- ISCURVATURE g
          jl    n-2       jl   n-1              jl


See also ICURVATURE, IRICCI, ISCURVATURE, WEYL.

&ISYMMETRIES

[ITENSOR package] A list of all the declared symmetries of indicial
tensors.

See also DECLARE_ISYMMETRY, REMOVE_ISYMMETRY.

&IVARIATION(itensor1, atomtensor)

[ITENSOR package] Computes the variational derivative of the indicial
tensor itensor1 with respect to the atomic tensor atomtensor.  
IVARIATION takes into account symmetries of atomtensor which have
been declared with DECLARE_ISYMMETRY.  Itensor1 and atomtensor can contain 
derivative indices.  

IVARIATION has the following limitations.

- IVARIATION computes the variation of itensor1 only with respect
  to atomtensor, without making any changes in the variance of the
  indices of atomtensor. 

- IVARIATION does not currently do integration by parts, as if
  itensor were the integrand in a variational integral.

Do EXAMPLE(IVARIATION); for an executable example.  Do DEMO(IVARY); 
for a longer demonstration.

See also IDIFF.

&JACOBI(p, q)

Is the Jacobi symbol of p and q.

Do EXAMPLE(JACOBI); for an example.  

See also JACOBI_P, JACOBIAN_ELLIPTIC_FUNCTIONS.

&JACOBI_AM(U, M)

A Jacobi elliptic function: amplitude U with modulus M

See also JACOBI_AM_BY_CARLSON.

&JACOBI_AM_BY_CARLSON(u, m)

Calculates the elliptic function with amplitude u and modulus m for
double precision and bfloat numbers u, m.

See also JACOBI_AM. 

Do DEMO(CARLSON); for a demonstration of all the Carlson elliptic integrals.

See also CARLSON_R_D, CARLSON_R_E, CARLSON_R_F, CARLSON_R_J,
ELLIPTIC_E_BY_CARLSON, ELLIPTIC_F_BY_CARLSON and ELLIPTIC_PI_BY_CARLSON .

See also ELLIPTIC_F, ELLIPTIC_E.


&JACOBI_AM1(U, m1)

A Jacobi elliptic function: amplitude U with complementary modulus M1

&JACOBI_CN(U, M)

The Jacobi elliptic function cn.

  JACOBI_CN(U,M):=COS(JACOBI_AM(U,M)); 

&JACOBI_DN(U, M)

The Jacobi elliptic function dn.

  JACOBI_DN(U,M):=SQRT(1-M*JACOBI_SN(U,M)^2); 

&JACOBI_MATRIX

A matrix whose columns are normalized eigenvectors corresponding to
the list of eigenvalues returned by EIGENS_BY_JACOBI.

See EIGENS_BY_JACOBI.

&JACOBI_P(N, A, B, X)

[SPECFUN package] Computes the Jacobi polynomial P(N,A,B,X) for
nonnegative integer N and real A,B > -1.

JACOBI_P[N](A,B,X) is an alternative syntax, which stores the Jacobi
polynomials of order less than or equal to N.

Do LOAD(SPECFUN); to access this function.

&JACOBI_POLYNOMIALS_P

There are two functions for computing Jacobi polynomials in the
SPECFUN package:
    JACOBI_P(N,A,B,X) and JACOBI_P[N](A,B,X)  For -1 < A,B

&JACOBI_SN(U, M)

The Jacobi elliptic function sn.

  JACOBI_SN(U,M):=SIN(JACOBI_AM(U,M));

&JACOBIAN(funclist, varlist)

[MATFUNCS package] Computes the Jacobian matrix of the list of
functions `funclist' in the list of variables `varlist'.

Example:

 (c1) JACOBIAN([F(X,Y),G(X,Y)],[X,Y]);

              [ diff(f(x,y),x)  diff(f(x,y),y) ]
 (d1)         [                                ]
              [ diff(g(x,y),x)  diff(g(x,y),y) ]

The Jacobian actually is the determinant of this matrix and is 
sometimes given as partial(F,G,...,H)/partial(x,y,...,z) .

Do EXAMPLE(JACOBIAN); for an example.

&JACOBIAN_ELLIPTIC_FUNCTIONS

Macsyma has the functions

  JACOBI_AM(U,M)   - amplitude U with modulus M
  JACOBI_AM1(U,M1) - amplitude U with complementary modulus M1
  JACOBI_AM(U,M) := JACOBI_AM1(U,1-M); so use JACOBI_AM1 if M ~ 1
  JACOBI_SN(U,M) := SIN(JACOBI_AM(U,M));
  JACOBI_CN(U,M) := COS(JACOBI_AM(U,M));
  JACOBI_DN(U,M) := SQRT(1-M*JACOBI_SN(U,M)^2); .
  
  JACOBI_AM_BY_CARLSON(U,M) - amplitude U with modulus M

See also ELLIPTIC_INTEGRALS and JACOBI.

&JORDAN_FORM(M)

[JORDAN_FORM package] Computes the Jordan Normal Form of the square
matrix M.

Do USAGE(JORDAN_FORM); for more information.

Do EXAMPLE(JORDAN_FORM); for an example; do DEMO(JORDAN); for a
longer demonstration.

See also JORDAN_SIMTRAN and JORDAN_MATRIX_EXPT.

&JORDAN_MATRIX_EXPT(mat, power)

Computes MAT^^POWER by first reducing the matrix mat to Jordan form.
JORDAN_FORM need not be called before JORDAN_MATRIX_EXPT.

See also MATRIX_EXP.

&JORDAN_SIMTRAN(mat)

[JORDAN_FORM package] Computes a similarity matrix P such that
P^^(-1). mat. P = J, where J is in Jordan canonical form. Note that
JORDAN_FORM must be called on mat previously to ensure that
EIGPOLYLIST is set to contain the correct invariant factor structure.

Do EXAMPLE(JORDAN_SIMTRAN); for an example.

&JULIAN_DATE(JD)

Computes the calendar day and time of the Julian Day number.

Do EXAMPLE(JULIAN_DATE); for an example.

See also JULIAN_DAY.

&JULIAN_DAY({month, day, year, hour, min, sec})

Returns the Julian date of the epoch described by its optional arguments.
If no arguments are provided, JULIAN_DATE uses the system clock. 

Do EXAMPLE(JULIAN_DAY); for an example.

See JULIAN_DATE.

&K_DELTA(m, n)

[ALGFUNCS package] Semantic Kronecker delta function which returns a
value only when m-n contains no nonconstant variables. K_DELTA can
remain in an expression until m-n becomes constant, at which time
K_DELTA evaluates as follows:  if ZEROP(m-n) is TRUE then return 1
else return 0.

Do EXAMPLE(K_DELTA) for an example.

See also KDELTA and KRON_DELTA.

&KAISER_WINDOW(t, t0, t1, wa)

Computes the Kaiser Window function:

  if t<t0 or t>t1 
   then 0
   else bessel_i[0](wa*sqrt(((t1-t0)/2)^2-(t-(t1-t0)/2)^2))/
         bessel_i[0](wa*(t1-t0)/2).

Do EXAMPLE(KAISER_WINDOW); for an example and DEMO(POWER_SPECTRUM);
for a longer demonstration.

See also POWER_SPECTRUM.

&KDELTA(L1)

[ITENSOR package] The generalized Kronecker delta function, where L1
is the list of covariant and contravariant indices.  KDELTA([i,@j])
returns the ordinary Kronecker delta.  The command EV(EXP,KDELTA)
causes the evaluation of an expression containing KDELTA([]) to the
dimension of the manifold. 

See also K_DELTA and KRON_DELTA.

&KEEP_BLOCK_MATRIX default:FALSE                   option variable 

When set to TRUE, the action of MAT_UNBLOCKER is inhibited. This
preserves the form of a matrix with elements that are themselves
matrices.

See also MAT_UNBLOCKER.

&KEEPFLOAT default:FALSE

If set to TRUE will prevent floating point numbers from being
rationalized when expressions which contain them are converted to CRE
form.

Do EXAMPLE(KEEPFLOAT); for an example.

&KILL(arg1, arg2, ...)

Eliminates its arguments from the Macsyma system.  If argi is a
variable (including a single array element), function, or array, the
designated item with all of its properties is removed from core.  If
argi=LABELS then all input, intermediate, and output lines to date
(but not other named items) are eliminated.  If argi=CLABELS then only
input lines will be eliminated; if argi=ELABELS then only intermediate
E-lines will be eliminated; if argi=DLABELS only the output lines will
be eliminated.  If argi is the name of any of the other information
lists (the elements of the Macsyma variable INFOLISTS), then every
item in that class (and its properties) is KILLed and if argi=ALL then
every item on every information list previously defined as well as
LABELS is KILLed.  If argi=a number (say n), then the last n lines
(i.e. the lines with the last n line numbers) are deleted.  If argi is
of the form [m,n] then all lines with numbers between m and n
inclusive are killed.  Note that KILL(VALUES) or KILL(variable) will
not free the storage occupied unless the labels which are pointing to
the same expressions are also KILLed.  Thus if a large expression was
assigned to X on line C7 one should do KILL(D7) as well as KILL(X) to
release the storage occupied.

KILL(ALLBUT(name1,...,namek) will do a KILL(ALL) except it will not
KILL the names specified.  (Note: namei means a name such as U, V, F,
G, not an infolist such as FUNCTIONS.)

    KILL removes all properties from the given argument thus
KILL(VALUES) will kill all properties associated with every item on
the VALUES list whereas the REMOVE set of functions
(REMVALUE,REMFUNCTION,REMARRAY,REMRULE) remove a specific property.
Also the latter print out a list of names or FALSE if the specific
argument doesn't exist whereas KILL always has value "DONE" even if
the named item doesn't exist.

    Note that killing expressions will not help a problem when
allocation level has gotten too high.  In this cases no amount of
killing will cause the size of these spaces to decrease.  Killing
expressions only causes some spaces to get emptied out but not made
smaller.

Do EXAMPLE(KILL); for an example.

&KILLCONTEXT(context1, context2, ... , contextn)

Kills the specified contexts.  If one of them is the current context,
the new current context will become the first available subcontext of
the current context which has not been killed.  If the first available
unkilled context is GLOBAL then INITIAL is used instead.  If the
INITIAL context is killed, a new INITIAL is created, which is empty of
facts.  KILLCONTEXT doesn't allow the user to kill a context which is
currently active, either because it is a subcontext of the current
context, or by use of the function ACTIVATE.

See CONTEXT for a general description of the context mechanism.

&KILLPLOTS(plotname1, ... , plotnamen)

Frees the array storage used by the specified plots. KILLPLOTS(ALL);
AND KILLPLOTS(PLOTS); applies KILLPLOTS to all members of the list
PLOTS.

KILLPLOTS does not KILL plotnamei, and leaves the filename
information inserted by SAVEPLOTS. If you never want to reference
a plot again, it is best to do a KILLPLOTS followed by a KILL,
since KILLPLOTS completely removes the arrays of the plot from the
system, which KILL might not do.

Available only in versions of Macsyma with NAMEPLOT.

See PLOTTING_SUMMARY for more information.

&KNOWNEIGVALS default:FALSE

If set to TRUE, the EIGEN package assumes the eigenvalues of the
matrix are known and stored under the global name LISTEIGVALS.

The function ALGSYS is used in EIGENVECTORS to solve for the
eigenvectors.  Sometimes if the eigenvalues are messy, ALGSYS is
not able to produce a solution.  In that case, try to simplify the
eigenvalues by first finding them using EIGENVALUES and then
using your own methods to simplify them further.  You can then use
the option variable KNOWNEIGVALS to proceed further.

See also EIGENVALUES, EIGENVECTORS, UNITEIGENVECTORS, LISTEIGVALS,
KNOWNEIGVECTS.

&KNOWNEIGVECTS default:FALSE

If set to TRUE, the EIGEN package assumes that the eigenvectors of the
matrix are known and are stored under the global name LISTEIGVECTS.
LISTEIGVECTS should be set to a list similar to the output of
EIGENVECTORS.  If KNOWNEIGVECTS is set to TRUE and the list of
eigenvectors is given, the setting of the flag NONDIAGONALIZABLE may
not be correct.  If that is the case, please set it to the correct
value. It is assumed that you would not try to diagonalize a matrix
the eigenvectors of which do not span a vector space of the
appropriate dimension (which would be mathematically in correct).

See also EIGENVALUES, EIGENVECTORS, UNITEIGENVECTORS,
LISTEIGVECTS, KNOWNEIGVALS.

&KRON_DELTA(m, n)

If m=n then returns 1 else 0.

Do EXAMPLE(KRON_DELTA); for an example.

See also K_DELTA and KDELTA.

&KRONECKER

See K_DELTA, KDELTA, KRON_DELTA.

&KRYLOV(vec_or, Mat_or {, cols })

Generates Krylov matrix of input matrix and vector.  The product
Mat_or^^(k-1) . vec_or forms the kth column of the output.  The
optional argument specifies the number of columns in the output; the
default is to produce a square output matrix.  The second input is
usually a square matrix, in which case, the first input can be a
vector or list.  Otherwise, both inputs can be singleton lists or
scalars.

Do EXAMPLE(KRYLOV); for an example.

&KUMMER_M(a,b,z)

One of the primary linearly independent solutions to Kummer's equation 
 z*w'' + (b - z)*w' - a*w = 0 .  kummer_m is the confluent hypergeometric 
function  kummer_m(a,b,z) = 1F1(a;b;z) .  Macsyma cannot numerically 
evaluate KUMMER_M at this time.

See also SPECIAL_FUNCTIONS, ODELIN2, and DEMO(ODELIN2); .

&KUMMER_U(a,b,z)

One of the primary linearly independent solutions to Kummer's equation 
 z*w'' + (b - z)*w' - a*w = 0 .  kummer_u is the confluent hypergeometric 
function  kummer_u(a,b,z) = z^-a*2F0(a;1+a-b;;-1/z) .  Macsyma cannot 
numerically evaluate KUMMER_U at this time.

See also SPECIAL_FUNCTIONS, ODELIN2, and DEMO(ODELIN2); .

&LABEL(text1, ..., textn)

Special form of CONCAT which composes labels for plots.  If one of
the arguments is a symbol with a value, then the equation arg=value
appears in the result.

&LABELCONTOURS default:TRUE

Provides labels for contourplots produced by CONTOURPLOT or
CONTOURPLOT3D. If FALSE, the labels are suppressed.

&LABELS(char)

Takes a char C,D,or E as arg and generates a list of all
C-labels,D-labels, or E- labels, respectively.  (If you've generated
many E- labels via SOLVE, then FIRST(REST(LABELS(C))); reminds you
what the last C-label was.)

LABELS will take as arg any symbolic name, so if you have reset
INCHAR, OUTCHAR, or LINECHAR, it will return the list of labels
whose first character matches the first character of the arg you
give to LABELS.

The variable, LABELS, default:[], is a list of C, D, and E lines
which are bound.

&LAGUERRE

Macsyma's SPECFUN package has four functions for computing Laguerre
polynomials:

 - For Laguerre polynomials: LAGUERRE_L(N,X) and LAGUERRE_L[N](X)
 - For Associated Laguerre polynomials: 
       ALAGUERRE_L(N,A,X) and ALAGUERRE_L[N](A,X)
       For -1 < A.

&LAGUERRE_L(N, X)

[SPECFUN package] Computes the Laguerre polynomial L(N,X) for
nonnegative integer N.

LAGUERRE_L[N](X) is an alternative syntax, which stores the Laguerre
polynomials of order less than or equal to N.

Do LOAD(SPECFUN); to access this function.

See also ALAGUERRE_L.

&LAMBDA(arglist, form1, ..., formn)

Is used to pass functional arguments to other functions or for
defining a function to be applied just once (instead of using :=).
arglist is a list of arguments, and the formi are forms to be
evaluated in succession.

Do EXAMPLE(LAMBDA); for an example.

&LAP_VAR 

The Laplace transform approach used by definite integration uses a
 positive parameter named LAP_VAR.

See also LAPLACE_CALL.

&LAPLACE(exp, ovar, lvar)

Takes the Laplace transform of exp with respect to the variable ovar
and transform parameter lvar.  Exp may only involve the functions EXP,
LOG, SIN, COS, SINH, COSH, and ERF.  It may also be a linear, constant
coefficient differential equation in which case ATVALUE of the
dependent variable will be used.  These may be supplied either before
or after the transform is taken.  Since the initial conditions must be
specified at zero, if one has boundary conditions imposed elsewhere he
can impose these on the general solution and eliminate the constants
by solving the general solution for them and substituting their values
back.  Exp may also involve convolution integrals.  Functional
relationships must be explicitly represented in order for LAPLACE to
work properly.  That is, if F depends on X and Y it must be written as
F(X,Y) wherever F occurs as in LAPLACE('DIFF(F(X,Y),X),X,S).  LAPLACE
is not affected by DEPENDENCIES set up with the DEPENDS command.

 (c1) LAPLACE(%E^(2*T+A)*SIN(T)*T,T,S);

                      a
                  2 %e  (s - 2)
 (d1)            ---------------
                         2     2
                 ((s - 2)  + 1)

The command ILT performs inverse Laplace transforms.  

Do EXAMPLE(LAPLACE); and EXAMPLE(ILT); for short examples, and
DEMO(LAPLACE); for a longer demonstration.

&LAPLACE_CALL default:TRUE

  Value  Effect
  -----  --------------------------------
  TRUE   DEFINT uses LAPLACE to compute integrals which have the
         form of Laplace transforms, which it cannot otherwise
         easily handle.

  FALSE  The LAPLACE command is not called by DEFINT.

  ALL    Certain integrands are transformed into the Laplace
         transform form; the LAPLACE command is then tried.

This Laplace transform approach uses a positive parameter named LAP_VAR.

&LAPLACE_DENSITY(x, alpha, beta)

[UNIPROB package] The density 1/(2*beta)*exp(-abs(x-alpha)/beta).

See also LAPLACE_DISTRIB.

&LAPLACE_DISTRIB(x, alpha, beta)

[UNIPROB package] The cumulative distribution for the LAPLACE_DENSITY.

See also LAPLACE_DENSITY and INV_LAPLACE_DISTRIB.

&LAPLACIAN(exp)

[VECT package] The Laplacian operator.

&LASSOCIATIVE

If DECLARE(G,LASSOCIATIVE); is done, this tells the simplifier that G
is left-associative.  E.g.  G(G(A,B),G(C,D)) will simplify to
G(G(G(A,B),C),D).  LASSOCIATIVE is a member of the FEATURES list.  It
can be asserted with DECLARE, withdrawn with REMOVE, and detected with
FEATUREP.

Do EXAMPLE(LASSOCIATIVE); for an example.

See also DOTASSOC, RASSOCIATIVE.

&LAST(exp)

Returns the last part (term, row, element, etc.) of the exp. LAST is
affected by the setting of INFLAG.

Do EXAMPLE(LAST); for an example.

See also FIRST, LAST_ELEMENT, PART, REST.

In plotting functions, the optional arguments FIRST, SAME, and LAST
are used to superimpose plots.

&LAST_ELEMENTS(expr, n)

[FUNCTS package] Returns the last n elements of the list or 
expression expr.

Do EXAMPLE(LAST_ELEMENTS); for an executable example.

See also FIRST_ELEMENTS, LAST, PART, REST.

&LASTTIME

The time to compute the last expression in milliseconds presented as a
list of "time" and "gctime".

&LATEX(expr1, ... , exprn)

The same as the TEX function except for quotients a/b it outputs
\frac {a}{b} instead of {{a}\over{b}} .  This function is still
experimental.  See TEX for more information.

Do EXAMPLE(LATEX); for an example.

See also TEX.

&LCM(exp1, exp2, ...)

[ALGFUNCS package] Returns the Least Common Multiple of its
arguments.

Do EXAMPLE(LCM); for an example.

&LDEFINT(exp, var, ll, ul)

Returns the definite integral of exp by using LIMIT to evaluate the
indefinite integral of exp with respect to var at the upper limit ul
and at the lower limit ll.

Do EXAMPLE(LDEFINT); for an example.

See also DEFINT, TLDEFINT.

&LDISP(expr1, expr2, ...)

Displays each expression expr1, ... on a line, like DISP, but also
generates intermediate line labels.

Do EXAMPLE(LDISP); for an example.

See also DISP, DISPLAY, LDISPLAY, PICKAPART, REVEAL.

&LDISPLAY(expr1, expr2, ...)

Is like DISPLAY but also generates intermediate labels.

Do EXAMPLE(LDISPLAY); for an example.

See also DISP, DISPLAY, LDISP, PICKAPART, REVEAL.

&LDU_DECOMP(M)

Computes the LDU decomposition of the square matrix M. The function
returns the result as a list [L,D,U], where L is a lower triangular
matrix with 1's on its diagonal, U is an upper triangular matrix with
1's on its diagonal, and D is a diagonal matrix.

Do EXAMPLE(LDU_DECOMP); for an example.

See also MATRIX_SUMMARY for a summary of Macsyma's matrix algebra
capabilities.

&LEAST_NEGATIVE_DFLOAT

Contains the negative double floating point number in the current
implementation which is closest to (but not equal to) 0.

See also LEAST_NEGATIVE_FLOAT, LEAST_POSITIVE_DFLOAT.

&LEAST_NEGATIVE_FLOAT

Contains the negative floating point number in the current
implementation which is closest to (but not equal to) 0.

See also LEAST_POSITIVE_FLOAT, LEAST_NEGATIVE_DFLOAT.

&LEAST_POSITIVE_DFLOAT

Contains the positive double floating point number in the current
implementation which is closest to (but not equal to) 0.

See also LEAST_NEGATIVE_DFLOAT, LEAST_POSITIVE_FLOAT.

&LEAST_POSITIVE_FLOAT

Contains the positive floating point number in the current
implementation which is closest to (but not equal to) 0.

See also LEAST_NEGATIVE_FLOAT, LEAST_POSITIVE_DFLOAT.

&LEGENDRE

There are seven functions for computing Legendre polynomials in the
SPECFUN package:

 - Legendre polynomials, 1st kind: LEGENDRE_P(N,X) and LEGENDRE_P[N](X)
 - Legendre polynomials, 2nd kind: LEGENDRE_Q(N,X) and LEGENDRE_Q[N](X)
 - Associated Legendre polynomials 1st kind:
     ALEGENDRE_P(N,M,X) and ALEGENDRE_P[N,M](X)
     For 0 < M <= N
 - Associated Legendre polynomials, 2nd kind:
     ALEGENDRE_Q(N,M,X).

&LEFT_EIGENS_BY_SCHUR(mat)

Calculates the eigenvalues and left eigenvectors of the matrix mat.

This routine is NumKit specific. Do USAGE(NUMKIT); for more information.

See also EIGENS_BY_SCHUR.

&LEGENDRE_P(N, X)

[SPECFUN package] Computes the Legendre polynomial of the first kind
P(N,X) for nonnegative integer N.

LEGENDRE_P[N](X) is an alternative syntax, which stores the Legendre
polynomials of order less than or equal to N.

Do LOAD(SPECFUN); to access this function.

See also LEGENDRE_Q, ALEGENDRE_P, ALEGENDRE_Q.

&LEGENDRE_Q(N, X)

[SPECFUN package] Computes the Legendre polynomial of the second kind
Q(N,X) for nonnegative integer N.

LEGENDRE_Q[N](X) is an alternative syntax, which stores the Legendre
polynomials of order less than or equal to N.

Do LOAD(SPECFUN); to access this function.

See also LEGENDRE_P, ALEGENDRE_P, ALEGENDRE_Q.

&LEINSTEIN(dis) 

[CTENSOR package] Computes the covariant Einstein tensor, and stores
it in the array LEIN[i,j], where "i" and "j" are covariant (lower)
indices.  

LEINSTEIN uses as input the covariant Ricci tensor stored in the array
RIC (or causes it to be computed by RICCI if it is not present).

If RATEINSTEIN=TRUE (default:TRUE), then LEINSTEIN does rational
simplification on the components of LEIN.  If RATFAC=TRUE
(default:FALSE), then the components will also be factored.  

If the argument dis is TRUE, then the non-zero values of the mixed
Einstein tensor EIN[i,j] will be displayed.

See also EINSTEIN, RIEMANN, LRIEMANN, URIEMANN, RICCI, URICCI,
SCURVATURE, WEYL. 

&LENGTH(exp)

Gives (by default) the number of parts in the external (displayed)
form of exp.  For lists this is the number of elements, for matrices
it is the number of rows, and for sums it is the number of terms.
(See DISPFORM).  The LENGTH command is affected by the INFLAG switch
[default FALSE].  So, e.g. LENGTH(A/(B*C)); gives 2 if INFLAG is FALSE
(Assuming EXPTDISPFLAG is TRUE), but 3 if INFLAG is TRUE (the internal
representation is essentially A*B^-1*C^-1).

Do EXAMPLE(LENGTH); for an example.

See also NTERMS, PICKAPART, REVEAL.

&LET(prod, repl, predname, arg1, arg2, ..., argn)

Defines a substitution rule for LETSIMP such that prod gets replaced
by repl.  prod is a product of positive or negative powers of the
following types of terms:

1) Atoms which LETSIMP will search for literally unless previous
   to calling LETSIMP the MATCHDECLARE function is used to associate
   a predicate with the atom.  In this case LETSIMP will match the
   atom to any term of a product satisfying the predicate.

2) Kernels such as SIN(X), N!, F(X,Y), etc.  As with atoms above
   LETSIMP will look for a literal match unless MATCHDECLARE is used
   to associate a predicate with the argument of the kernel.

A term to a positive power will only match a term having at least that
power in the expression being LETSIMPed.  A term to a negative power
on the other hand will only match a term with a power at least as
negative.  In the case of negative powers in "product" the switch
LETRAT must be set to TRUE (see below).

If a predicate is included in the LET function followed by a list of
arguments, a tentative match (i.e. one that would be accepted if the
predicate were omitted) will be accepted only if
predname(arg1',...,argn') evaluates to TRUE where argi' is the value
matched to argi.  The argi may be the name of any atom or the argument
of any kernel appearing in prod.  repl may be any rational expression.
If any of the atoms or arguments from prod appear in repl the
appropriate substitutions will be made.

LETRAT default:FALSE
   When FALSE, LETSIMP will simplify the numerator and denominator of
  expr independently and return the result.  Substitutions such as
  N!/N goes to (N-1)!  will fail.  To handle such situations LETRAT
  should be set to TRUE, then the numerator, denominator, and their
  quotient will be simplified in that order.

LET Rule Packages
-----------------

Macsyma permits you to define rule packages, where each rule package
is a collection of transformation rules which can be applied as a
group by referring the name of the rule package.  You can work with
several rule packages at once.  

 - To insert a rule into the rule package pkg_name, do
   LET([prod,repl,pred,arg1,...],pkg_name).

 - To apply the rules in package pkg_name, do LETSIMP(expr,pkg_name).
   The function LETSIMP(expr,pkg_name1,pkg_name2,...)  is equivalent
   to  LETSIMP(expr,pkg_name1) followed by LETSIMP(%,pkg_name2) etc.

CURRENT_LET_RULE_PACKAGE
  is the name of the rule package that is presently being used.  The
  user may reset this variable to the name of any rule package
  previously defined via the LET command.  Whenever any of the
  functions comprising the let package are called with no package name
  the value of CURRENT_LET_RULE_PACKAGE is used.  If a call such as
  LETSIMP(expr, rule_pkg_name); is made, the rule package rule_pkg_name
  is used for that LETSIMP command only, i.e.  the value of
  CURRENT_LET_RULE_PACKAGE is not changed.

DEFAULT_LET_RULE_PACKAGE
  is the name of the rule package which is assumed when no other
  name is supplied to any of the functions.  Whenever a LET includes
  a rule package name that is used as the CURRENT_LET_RULE_PACKAGE.

See RULES_SUMMARY for an overview of rule-based pattern matching
capabilities in Macsyma.

Do DEMO(LETRULES); for an executable demonstration of the LET pattern
matching facility.

&LET_RULE_PACKAGES default:DEFAULT_LET_RULE_PACKAGE

The value of LET_RULE_PACKAGES is a list of all the user-defined let
rule packages plus the special package DEFAULT_LET_RULE_PACKAGE.
DEFAULT_LET_RULE_PACKAGE is the name of the rule package used when one
is not explicitly set by the user.

Do EXAMPLE(LET); for an example.  Do DEMO(LETRULES); for a longer
demonstration.

See also LETRULES, LETSIMP.  See RULES_SUMMARY for an overview of
rule-based pattern matching capabilities in Macsyma.

&LETRAT default:FALSE

When FALSE, LETSIMP will simplify the numerator and denominator of
expr independently and return the result.  Substitutions such as N!/N
goes to (N-1)! will fail.  To handle such situations LETRAT should be
set to TRUE, then the numerator, denominator, and their quotient will
be simplified in that order.

&LETRULES()

Displays the rules in the current rulepackage (initially
DEFAULT_LET_RULE_PACKAGE).  LETRULES(name) displays the rules in the
named rulepackage.  The current rulepackage is the value of
CURRENT_LET_RULE_PACKAGE.

Do EXAMPLE(LETRULES); for an example. 

Do DEMO(LETRULES); for an executable demonstration of the LET
pattern matching facility.

See also RULES_SUMMARY for an overview of rule-based pattern
matching capabilities in Macsyma.

See also LET, LETSIMP.  See RULES_SUMMARY for an overview of
rule-based pattern matching capabilities in Macsyma.

&LETSIMP(exp)

Will continually apply the substitution rules previously defined by
the function LET until no further change is made to exp.
LETSIMP(expr, rule_pkg_name); will cause the rule package rule_pkg_name
to be used for that LETSIMP command only, i.e.  the value of
CURRENT_LET_RULE_PACKAGE is not changed.

Do EXAMPLE(LETSIMP); for an example. 

Do DEMO(LETRULES); for an executable demonstration of the LET
pattern matching facility.

See also LET, LETRULES.  See RULES_SUMMARY for an overview of
rule-based pattern matching capabilities in Macsyma.

&LEVI_CIVITA(L)

[ITENSOR package] Is the permutation (or Levi-Civita) tensor density,
which returns 1 if the list L consists of an even permutation of
integers, -1 if it consists of an odd permutation, and 0 if some
indices in L are repeated.

&LFG

[CTENSOR package] When frame fields are used in CTENSOR, this symbol
is reserved for the matrix which stores the components of the
covariant fiber metric tensor.

See also FR and FRI.

&LG

[CTENSOR package] In CTENSOR, this symbol is reserved for the matrix
which stores the components of the covariant metric tensor.

&LHOSPITALLIM default:5

The maximum number of times L'Hospital's rule is used in LIMIT.  
This prevents infinite looping in cases like LIMIT(COT(X)/CSC(X),X,0).

&LHS(eqn)

The left side of the equation eqn.  If eqn is not an equation,
LHS(exp) returns exp.  To extract the left hand side of an inequality, 

Do EXAMPLE(LHS); for an example.

See also RHS.

&LI

This is the notation Macsyma uses for Polylogarithms and Dilogarithms.

See also POLYLOGARITHMS and LI2_REFLECT.

&LI2_REFLECT(exp)

Implements the dilogarithm reflection formula (AS p. 1004 27.7.3).

Do EXAMPLE(LI2_REFLECT); for an example.

See also POLYLOGARITHMS.

&LIBRARY

Macsyma has two LIBRARY directories, LIBRARY1 and LIBRARY2.  LIBRARY1
is used for key Macsyma system packages, that are kept out of the core
system to make the Macsyma image smaller.

LIBRARY2 is used for Macsyma system and user contributed packages
that we perceive as being of perhaps lesser importance.  You
might wish to remove some or all of the contents of this directory
from your disks if disk space is tight.

&LIE_DIFF(vector1, vector_or_form)

[CARTAN package] Computes the Lie derivative of vector_or_form with
respect to vector1.

Do DEMO(CARTAN); for an example. 

See also LIEDIFF.

&LIEDIFF(v, exp)

[ITENSOR package] Computes the Lie derivative of the tensor field exp,
with respect to the vector field whose symbol is v.  While exp is a
full tensor expression, v is merely the symbolic name from which
ITENSOR constructs as vector field.  This operation does not depend on
the affine connection.

See also LIE_DIFF.

&LIMIT(exp, var, val, dir)

Finds the limit of exp as the real variable var approaches the value
val from the direction dir.  Dir may have the value PLUS for a limit
from above, MINUS for a limit from below, or may be omitted (implying
a two-sided limit is to be computed).  For the method see Wang, P.,
"Evaluation of Definite Integrals by Symbolic Manipulation" - Ph.D.
Thesis - MAC TR-92 October 1971.  LIMIT uses the following special
symbols: INF (positive infinity) and MINF (negative infinity).  On
output it may also use UND (undefined), IND (indefinite but bounded)
and INFINITY (complex infinity).

LHOSPITALLIM default:5
  is the maximum number of times L'Hospital's rule is used in LIMIT.
  This prevents infinite looping in cases like
  LIMIT(COT(X)/CSC(X),X,0). 

TLIMSWITCH default:FALSE
  When true will cause the limit package to use Taylor series when
  possible.

LIMSUBST default:FALSE
  Prevents LIMIT from attempting substitutions on unknown forms.  This
  is to avoid bugs like LIMIT(F(N)/F(N+1),N,INF); giving 1.  Setting
  LIMSUBST to TRUE will allow such substitutions.

Since LIMIT is often called upon to simplify constant expressions,
for example, INF-1, LIMIT may be used in such cases with only one
argument, e.g. LIMIT(INF-1);

Do EXAMPLE(LIMIT); for an example. Do DEMO(LIMIT); and DEMO(LIMIT1);
for longer demonstrations.

See also TLIMIT, TLIMSWITCH.

&LIMSUBST default:FALSE

Prevents LIMIT from attempting substitutions on unknown forms.  This
is to avoid bugs like LIMIT(F(N)/F(N+1),N,INF); giving 1.  Setting
LIMSUBST to TRUE will allow such substitutions.

&LIN

(Optional argument to the two-dimensional plotting functions) Both x
and y scales are linear.

&LINCHANGE(expr, trans)

Changes indices in sums and products in expr by linear
transformations.  For example,

 - linchange(expr,-n) reverses the direction of sums and products
   over n.
 - linchange(expr,2*n) will convert each sum or product over n
   into two sums or products over even and odd n.

Do EXAMPLE(LINCHANGE); for an example.

&LINDST

A library package for applying Lindstedt's perturbation method to
weakly periodic or autonomous perturbations of the simple harmonic
oscillator. 

See LINDSTEDT.

&LINDSTEDT(eq, perturb_var, truncation_order {, initial_conditions})

Implements Lindstedt's perturbation method for weakly periodic or
autonomous perturbations of the simple harmonic oscillator.  The
program calculates a series expansion of a periodic solution which is
uniformly valid in the independent variable.

Do USAGE(LINDST); for more information.

Do EXAMPLE(LINDSTEDT); for an example. Do DEMO(LINDST); and
DEMO(LINDST1); for longer demonstrations.

For other perturbation methods for ODEs, see also AVG_PODE, MSCALES.

&LINEAR - OPPROPERTY

For univariate f so declared, "expansion" F(X+Y) -> F(X)+F(Y), F(A*X)
-> A*F(X) takes place where A is a "constant".  For functions F of >=2
args, "linearity" is defined to be as in the case of 'SUM or
'INTEGRATE, i.e. F(A*X+B,X) -> A*F(X,X)+B*F(1,X) for A,B FREEOF X.
(LINEAR is just ADDITIVE + OUTATIVE.)  LINEAR is a member of
OPPROPERTIES.  It can be asserted with DECLARE, withdrawn with REMOVE,
and detected with GETPROP.

Do EXAMPLE(LINEAR); for an example.

See also MULTILINEAR, LINEAR_MATCH.

&LINEAR_MATCH(expr, var)

[ALGFUNCS package] If expr is linear in var of the form a*var+b,
then the list [fn_b = b, fn_a = a, fn_x = var] is returned, and the
variables fn_a, fn_b (but not fn_x) are bound to the values indicated
in the list.  Otherwise returns FALSE.

See also LINEAR, QUADRATIC_MATCH.

&LINEARDISTRIB(expr)

Distributes summations and integrals.  For example,

 (c1) LINEARDISTRIB(SUM(A[i]+B[i],i,1,N));

 (d1)              sum(a[i],i,1,n))  + sum(b[i],i,1,n))

See also SUM, SUMEXPAND and SUMCONTRACT.

&LINECHAR default:e

The alphabetic prefix of the names of intermediate displayed
expressions.

See also INCHAR and OUTCHAR.

&LINEDISP default:TRUE

Allows the use of line graphics in the drawing of equations on those
systems which support them (e.g. the Lisp Machine).  This can be
disabled by setting LINEDISP to FALSE.  It is automatically disabled
during WRITEFILE.

&LINEL default:[]

The number of characters which are printed on a line.  It is initially
set by Macsyma to the line length of the type of terminal being used
(as far as is known) but may be reset at any time by the user.

&LINENUM

The line number of the last expression.

&LINLOG

(Optional argument to the two-dimensional plotting functions) Causes
the y axis to appear on a log[10] scale.

See also LOGLIN and LOGLOG.

&LINSOLVE([exp1,exp2,...], [var1, var2,...] {, [rhs1, rhs2,...]})

Solves the list of simultaneous linear equations for the list of
variables.  The expi must each be linear in the variables and may be
equations.  LINSOLVE can be provided with a list of right-hand sides
(RHSs) as an optional third argument (this will be a list of lists
with each sublist corresponding to one RHS).  In this case, the expi
should just be expressions which are homogeneous in the vari (i.e.,
all constants should be contained in the RHSs).  A list of solution
vectors will then be returned.  If any of the RHSs is inconsistent,
the corresponding solution that is returned will be the list
[INCONSISTENT].  LINSOLVE does no error checking to assure linearity.

GLOBALSOLVE default:FALSE
  If set to TRUE then variables which are SOLVEd for by LINSOLVE will
  be set to the solution of the set of simultaneous linear equations.

BACKSUBST default:TRUE
  If set to FALSE will prevent back substitution after the equations
  have been triangularized.  This may be necessary in very big
  problems where back substitution would cause the generation of
  extremely large expressions.

LINSOLVE_PARAMS default:TRUE
  If TRUE, LINSOLVE also generates the %Ri symbols used to represent
  arbitrary parameters described in the manual under ALGSYS.  If
  FALSE, LINSOLVE behaves as before, i.e.  when it meets up with an
  under-determined system of equations, it solves for some of the
  variables in terms of others.

If LINSOLVE is given an incompatible set of linear equations, then it
displays the message INCONSISTENT. See SOLVE_INCONSISTENT_EQN_NOS,
SOLVE_INCONSISTENT_TERMS, and SOLVE_INCONSISTENT_ERROR.

Example:

 (c1) X+Z=Y$

 (c2) 2*A*X-Y=2*A^2$

 (c3) Y-2*Z=2$

 (c4) LINSOLVE([D1,D2,D3],[X,Y,Z]), GLOBALSOLVE:TRUE;

 (d4)      [ x : a + 1, y : 2 a, z : a - 1 ]

Do EXAMPLE(LINSOLVE); for an example and DEMO(LINSOLVE2); for a longer
demonstration.

For floating point problems, see MATSOLVE_BY_LU, IMPROVE_LU_SOLVE.
See also MATLINSOLVE and MATSOLVE, MATSOLVE_BY_SVD, LSQ_LINSOLVE, and
INEQ_LINSOLVE.

&LINSOLVE_PARAMS default:TRUE

If TRUE, LINSOLVE also generates the %Ri symbols used to represent
arbitrary parameters (see ALGSYS for more information). If FALSE, when
LINSOLVE encounters an under-determined system of equations, it solves
for some of the variables in terms of others.

&LINSOLVEWARN default:TRUE

If FALSE will cause the message "Dependent equations eliminated" to be
suppressed.

&LIST2COMPANION(lis_or)

Companion matrix from list of polynomial coefficients, beginning with
highest power, and proceeding to constant.  Also accepts vectors.
Recover coefficients of monic form of polynomial by using MAT_POLY.

Example:

 (c1) LIST2COMPANION([ACOEF3,ACOEF2,ACOEF1,ACOEF0]);

                               [         acoef0 ]
                               [ 0  0  - ------ ]
                               [         acoef3 ]
                               [                ]
                               [         acoef1 ]
 (d1)                          [ 1  0  - ------ ]
                               [         acoef3 ]
                               [                ]
                               [         acoef2 ]
                               [ 0  1  - ------ ]
                               [         acoef3 ]
 (c2) MAT_POLY(%);

                              acoef2  acoef1  acoef0
 (d2)                     [1, ------, ------, ------]
                              acoef3  acoef3  acoef3

Do  EXAMPLE(LIST2COMPANION); for an example.

See also MAT_POLY, CHARPOLY, MAT_COMPAN,  POLY2COMPANION, and 
HYPERCOMPANION.

&LIST2HORNER(coef_list, variable)

Recover a polynomial in Horner form from a list or vector of
coefficients given in order of decreasing powers.

Do  EXAMPLE(LIST2HORNER); for an example.

See also  LIST2POLY, POLY2LIST, HORNER.

&LIST2POLY(coeflis_or, var)

Creates a Macsyma polynomial from a list or vector of coefficients
given in order of decreasing powers of the variable var.  This is
inverse to the action of POLY2LIST.

Do EXAMPLE(LIST2POLY); for an example.

See also POLY2LIST.

&LISTARITH default:TRUE

If FALSE causes any arithmetic operations with lists to be suppressed;
when TRUE, list-matrix operations are contagious causing lists to be
converted to matrices yielding a result which is always a matrix.
However, list-list operations should return lists.

Do EXAMPLE(LISTARITH); for an example.

&LISTARRAY(array)

Returns a list of the elements of a declared or hashed array.  the
order is row-major.  For declared arrays, elements which have not been
defined will be shown by #####.  For hashed arrays obviously Macsyma
has no notion of undefined elements.

Do EXAMPLE(LISTARRAY); for an example.

See also ARRAYINFO.  See ARRAY_SUMMARY for a summary of commands
for manipulating arrays in Macsyma.

&LISTCONSTVARS default:FALSE

If TRUE will cause LISTOFVARS to include %E, %PI, %I, and any
variables declared constant in the list it returns if they appear in
the expression LISTOFVARS is called on.  The default is to omit these.

&LISTDUMMYVARS default:TRUE

If FALSE, "dummy variables" in the expression will not be included in
the list returned by LISTOFVARS.  (The meaning of "dummy variables" is
as given in DESCRIBE(FREEOF):  "Dummy variables" are mathematical
things like the index of a sum or product, the limit variable, and the
definite integration variable.) 

Example:

  LISTOFVARS       LISTOFVARS('SUM(F(I),I,0,N)); returns
  ----------       -------------------------------------
  TRUE             [I,N]
  FALSE            [N]

&LISTEIGVALS default:FALSE

If KNOWNEIGVALS is set to TRUE, the EIGEN package assumes that the
eigenvalues of the matrix are known and stored in the global variable
LISTEIGVALS.  The variable LISTEIGVALS should be set to a list similar
to the output of the command EIGENVALUES.

See also KNOWNEIGVALS, EIGENVALUES, LISTEIGVECTS

&LISTEIGVECTS default:FALSE

If KNOWNEIGVECTS is set to TRUE, the EIGEN package assumes that the
eigenvectors of the matrix are known and stored in the global variable
LISTEIGVECTS.  The variable LISTEIGVECTS should be set to a list
similar to the output of the command EIGENVECTORS.

See also KNOWNEIGVECTS, EIGENVECTORS, LISTEIGVALS

&LISTOFVARS(exp)

Returns a list of the variables in exp.  

LISTCONSTVARS default:FALSE
  If TRUE will cause LISTOFVARS to include %E, %PI, %I, and any
  variables declared constant in the list it returns if they appear in
  exp.  The default is to omit these.

 (c1) LISTOFVARS(F(X[1]+Y)/G^(2+A));

 (d1)                            [x[1], y, a, g]

Do EXAMPLE(LISTOFVARS); for an example.

See also LISTCONSVARS, LISTDUMMMYVARS.

&LISTP(exp)

Returns TRUE if exp is a list else FALSE.

See also PREDICATES.

&LISTRATVARS(exp)

Returns a list of the RATVARS (CRE variables) of EXP.

&LISTS

Macsyma performs many types of computations with lists of symbolic or
numerical data, including

 - building and manipulating lists of data;
 - set theory operations - do USAGE(SET)$ for more information;
 - arrays, both hashed and declared.

If your version of Macsyma has an option menu system, then you can
open the category LISTS to get lists of subtopics and common
commands. For each command listed, you can obtain a description
and an executable example.

Do EXAMPLE(LISTS); for an example, and DEMO(LISTS); for a longer
demonstration of the use of lists.

See also APPEND, CONS, ENDCONS, COPYLIST, DELETE, FIRST, LAST,
LENGTH, LISTARRAY, LISTARITH, LISTP, MAKELIST, MAPLIST, MEMBER,
REST, REVERSE, SUBLIST.

Many other special capabilities for manipulation of lists and
arrays are available in Macsyma.

&LMXCHAR default:[

The character used to display the (left) delimiter of a matrix.
This is used in ASCII text display of matrices. (Used in WRITEFILES,
but not in Macsyma's formatted screen display of matrices).

See also RMXCHAR.

&LOAD("filename")

Locates and loads in the file indicated by its argument. The argument
is a file specification represented as a "string" (i.e. inside
quotation marks), or as list (i.e. inside square brackets).  If only a
filename with no directory is specified, then the directories
specified by FILE_SEARCH will be searched, and the first file
encountered with the specified name will be loaded.

LOAD will work on both LOADFILEable and BATCHable files.  For
example, LOAD("EIGEN") will load the EIGEN package without the
need for the user to be aware of the details of whether the
package was compiled, translated, or saved. Note:  LOAD will use
BATCHLOAD if it finds the file is BATCHable (which means that it
will BATCH the file in "silently" without terminal output or labels).

Other Macsyma commands to load in files are: LOADFILE, BATCH, and 
DEMO.  Do DESCRIBE(COMMAND); for more information.  LOADFILE works for files 
written with SAVE;  BATCH and DEMO for those files written with 
STRINGOUT or created as lists of commands with a text editor.

See FILENAMES for information about how to specify file pathnames in
Macsyma.  See FILES_SUMMARY for more information about file manipulation
commands in Macsyma.  See also FILE_PATHNAMES for the pathname
conventions.

&LOADFILE("filename")

Loads a file as designated by "filename".  This function can be used
to bring back quantities that were stored from a prior Macsyma
session by use of the SAVE command.  The file must be a file of Lisp
functions and expressions, not of Macsyma command lines, in which
case LOAD, BATCH, or DEMO can be used.

See FILENAMES for information about how to specify file pathnames 
in Macsyma.  See FILES_SUMMARY for more information about file
manipulation commands in Macsyma.

&LOADPLOTS(filename)

Loads a file of plots created by SAVEPLOTS.  filename defaults exactly
as with LOADFILE. It also sets the file defaults. LOADPLOTS may be
done within a batch file.  Available only in some versions of Macsyma.

See PLOTTING_SUMMARY for more information.

&LOADPRINT default:TRUE

Governs the printing of messages accompanying loading of files.  The
following options are available:  

 Value        Effect
 ------       -------
 TRUE         Always print the message.
 'LOADFILE    Print only when the LOADFILE command is used.
 'AUTOLOAD    Print only when a file is automatically loaded in.
              (e.g. the integration file SIN FASL).
 FALSE        Never print the loading message.

&LOCAL(v1, v2, ...)

Causes the variables v1,v2,... to be local with respect to all the
properties in the statement in which this function is used.  LOCAL may
only be used in BLOCKs, in the body of function definitions or LAMBDA
expressions, or in the EV function and only one occurrence is
permitted in each.  LOCAL is independent of CONTEXT.

In recent implementations of Macsyma, LOCAL does not work correctly.
It is replaced by using ?MLOCAL(v1, v2, ..) early in the block, and
?MUNLOCAL() near the end of the block.

&LOG_GAMMA(x)

Computes the logarithm of the GAMMA function.

The argument can be symbolic, floating point, complex or BFLOAT.

Do EXAMPLE(LOG_GAMMA); for an example.

See also LOGCGAMMA2, CGAMMA, BFFAC, CBFFAC.


&LOG(x)

The principal branch of the natural logarithm. 

This also can be given as ln(x).

LOG10(x)
  Computes the logarithm of x to the base 10. 

LOGB(b,x)
  Computes logarithms in base b.  LOG10(x) computes logarithms in
  base 10.  

Do EXAMPLE(LOG); for an example.

See also LOG10, LOGB, DECIBEL, LOGCONTRACT, LOGEXPAND, LOGNUMER and
LOGSIMP.

LOG
  (Optional argument to the two-dimensional plotting functions) Causes
  both axes to appear on a log[10] scale.

&LOG10(x)

Logarithm in base 10 of x.

See also LOG, LOGB, DECIBEL.

&LOGABS default:FALSE

When doing indefinite integration where logs are generated, e.g.
INTEGRATE(1/X,X), the answer is given in terms of LOG(ABS(...)) if
LOGABS is TRUE, but in terms of LOG(...) if LOGABS is FALSE.  For
definite integration, the LOGABS:TRUE setting is used, because here
"evaluation" of the indefinite integral at the endpoints is often
needed.

&LOGAND(x, y)

[ALGFUNCS package] Logical AND of x and y.

&LOGARC default:FALSE

If TRUE will cause the inverse circular and hyperbolic functions to be
converted into logarithmic form.

LOGARC(exp) will cause this conversion for a particular expression
without setting the switch or having to re-evaluate the expression with
EV.

Do EXAMPLE(LOGARC); for an example.

&LOGARITHMIC_DENSITY(x, p)

[UNIPROB package] the density function for the logarithmic
distribution is
   (1-p)^x/(-x*log(p))

&LOGARITHMIC_DISTRIB(x, p)

[UNIPROB package] The distribution function for the
LOGARITHMIC_DENSITY.

&LOGB(_base_, x)

The logarithm of X to base _base_.  See also LOG.

&LOGCGAMMA2

See CGAMMA.

&LOGCONTRACT(exp)

Recursively scans an exp, transforming subexpressions of the form
a1*LOG(b1) + a2*LOG(b2) + c into LOG(RATSIMP(b1^a1 * b2^a2)) + c

Example:

 (c1) 2*(A*LOG(X) + 2*A*LOG(Y))$

 (c2) LOGCONTRACT(%);
                                         2  4
 (d3)                             a log(x  y )

If you do DECLARE(N,INTEGER); then LOGCONTRACT(2*A*N*LOG(X)); gives
A*LOG(X^(2*N)).  The coefficients that "contract" in this manner are
those such as the 2 and the N here which satisfy
FEATUREP(coeff, INTEGER).  The user can control which coefficients are
contracted by setting the option LOGCONCOEFFP [FALSE] to the name of a
predicate function of one argument. For example, if you like to
generate SQRTs, you can do

  LOGCONCOEFFP:'LOGCONFUN$
  LOGCONFUN(M):=FEATUREP(M,INTEGER) OR RATNUMP(M)$ .
  Then
  LOGCONTRACT(1/2*LOG(X)); gives LOG(SQRT(X)).

Caveat: LOGCONTRACT does a syntactic transformation which is not 
generally valid.  For example,  2*log(x)  does not equal  log(x^2) 
in general.  E.g. when x = -1, 2*log(x) = 2*i*pi ; while  log(x^2) = 0 .

Do EXAMPLE(LOGCONTRACT); for an example.

See also LOGCONCOEFFP, LOGEXPAND, LOGSIMP, FULL_LOGCON.

&LOGCONCOEFFP default:FALSE

Controls which coefficients are contracted when using LOGCONTRACT.  It
may be set to the name of a predicate function of one argument.  For
example, if you like to generate SQRTs, you can do

  LOGCONCOEFFP:'LOGCONFUN$
  LOGCONFUN(M):=FEATUREP(M,INTEGER) OR RATNUMP(M)$ .
  Then
  LOGCONTRACT(1/2*LOG(X)); gives LOG(SQRT(X)).

&LOGEXPAND default:TRUE

  Value   Effect
  -----   ------------------------------
  TRUE    LOG(A^B) becomes B*LOG(A), but only when
          mathematically valid, e.g. A>0 and B real.
          LOG(A*B) simplifies to LOG(A)+LOG(B) when 
          mathematically valid, e.g. if A>0.

  ALL     LOG(A^B) becomes B*LOG(A).
          LOG(A*B) simplifies to LOG(A)+LOG(B), without
          checking for validity.

  SUPER   LOG(A/B) simplifies to LOG(A)-LOG(B) for rational
          numbers A/B, A#1.  (LOG(1/B), for B integer, always
          simplifies.)   

  FALSE   All of these simplifications are turned off.

Also, if LOGEXPAND is ALL or SUPER, LOG(EXP(Z)) will give Z even 
when Z might be complex.

Do EXAMPLE(LOGEXPAND); for an example.

See also TAYLOR_LOGEXPAND.

&LOGIC_TABLE(vars, props {, p})

[MLTLOGIC package] Computes a logic table for the propositions
props, for all possible truth values for the logical variables
in the list vars.

Inputs:
- vars is a list of propositional variables
- props is a list of propositions (constructed with the 
  propositional variables in vars)
- p is the number of truth-values of the Logic (a prime number).
  p is optional and defaults to 2 for Boolean logic.

Intermediate outputs:
- The truth table of the propositions in props.

The MLTLOGIC package sets the option variable PREDERROR:TRUE.

Do EXAMPLE(LOGIC_TABLE); for an executable example.

See also PREDERROR, BOOLSIMP, TAUT_CONSEQUENCEP, TAUTOLOGYP.

&LOGISTIC_DENSITY(x, alpha, beta)

[UNIPROB package] The logistic probability density function is

  exp(-(x-alpha)/beta) *(1+exp(-(x-alpha)/beta))^2

See also LOGISTIC_DISTRIB.

&LOGISTIC_DISTRIB(x, alpha, beta)

[UNIPROB package] The probability distribution function of the
LOGISTIC_DENSITY.

See also LOGISTIC_DENSITY and INV_LOGISTIC_DISTRIB.

&LOGLIN

(Optional argument to the two-dimensional plotting functions) Causes
the x axis to appear on a log[10] scale.

See also LINLOG and LOGLOG.

&LOGLOG

(Optional argument to the two-dimensional plotting functions) Causes
both axes to appear on a log[10] scale.

See also LOGLIN and LINLOG.

&LOGNEG default:TRUE

When TRUE and x is a negative integer or rational number, 
  LOG(x) simplifies to LOG(-x)+%I*%PI.
When ALL, this simplification happens for all x such that SIGN(x)=NEG.
When FALSE, this simplification does not happen.

LOGNEG is an EVFLAG.

Do EXAMPLE(LOGNEG); for an example.

See also LOGEXPAND and LOGNUMER.

&LOGNORMAL_DENSITY(x, mu, var)

[UNIPROB package] The density function

  1/(X*SQRT(2*%PI*VAR)) *EXP(-(LOG(X)-MU)^2/(2*VAR)).

See also LOGNORMAL_DISTRIB.

&LOGNORMAL_DISTRIB(x, mu, var)

[UNIPROB package] The distribution function for the
LOGNORMAL_DENSITY.

Do EXAMPLE(LOGNORMAL_DISTRIB); for an example.

See also LOGNORMAL_DENSITY and INV_LOGNORMAL_DISTRIB.

&LOGNUMER default:FALSE

If TRUE then negative floating point arguments to LOG will always be
converted to their absolute value before the log is taken.  If NUMER
is also TRUE, then negative integer arguments to LOG will also be
converted to their absolute value.

Do EXAMPLE(LOGNUMER); for an example.

&LOGOR(x, y)

[ALGFUNCS package] Logical OR of x and y.

&LOGOUT()

Causes the user to be logged out.  This may be useful when it is
desired to BATCH in a file and have the terminal logged out
automatically when the computations are finished.  In some
implementations, this command will terminate all running jobs or
forks; on other systems, LOGOUT(); works like QUIT(TRUE); .

&LOGSIMP default:TRUE

If FALSE then no simplification of %E to a power containing LOGs is
done.

Do EXAMPLE(LOGSIMP); for an example.

&LOGXOR(x, y)

[ALGFUNCS package] Logical Exclusive OR of x and y.

&LOPOW(exp, v)

The lowest exponent of v which explicitly appears in exp.  Thus,
LOPOW((X+Y)^2+(X+Y)^A,X+Y) is MIN(A,2).

Do EXAMPLE(LOPOW); for an example.

See also HIPOW.

&LORENTZ

[ITENSOR package] This function has been renamed LORENTZ_GAUGE.

&LORENTZ_GAUGE(exp)

[ITENSOR package] Imposes the Lorentz condition by substituting 0 for
all indexed objects in exp that have a derivative index identical to a
contravariant index.

&LP_BY_SIMPLEX(objfun {, constraint1, ..., constraintM} {, v1, ..., vN})

Applies the simplex algorithm, maximizing the linear objective
function objfun = a[0,1]*v1 + ...  + a[0,N]*vN subject to the
primary constraints v1 >= 0, ..., vN >= 0, and simultaneously
subject to M additional linear constraints

  a[i,1]*v1 + ... + a[i,N]*vN <= b[i] >= 0   i = 1, ..., m1
  a[j,1]*v1 + ... + a[j,N]*vN >= b[j] >= 0   j = m1+1, ..., m1+m2
  a[k,1]*v1 + ... + a[k,N]*vN  = b[k] >= 0   k = m1+m2+1, ..., M.

The objective function and the constraints should be fully expanded
and all the coefficients a[m,n] must be numbers.

LP_BY_SIMPLEX returns as its value a list containing the maximum of the
objective function followed by the solution list; returns INF if the
solution is unbounded; or NO_SOLUTION if no solution satisfies the given
constraints.

Do EXAMPLE(LP_BY_SIMPLEX); for an example.

&LPART(label, expr, n1, ..., nk)

Is similar to DPART but uses a labeled box.  A labeled box is similar
to the one produced by DPART but it has a name in the top line.

Do EXAMPLE(LPART); for an example.

See also BOX, DPART, REMBOX.

&LRATSUBST(list, exp)

Is analogous to SUBST(list_of_equations, exp) except that it uses
RATSUBST instead of SUBST.  The first argument of LRATSUBST must be an
equation or a list of equations identical in format to that accepted
by SUBST.  The substitutions are made in the order given by the list
of equations, that is, from left to right.

Do EXAMPLE(LRATSUBST); for an example.  Do DEMO(LRATS); for a
longer demonstration.

See also RATSUBST, FULLRATSUBST, SUBST, SUBLIS, SUBSTPART.

&LRIEMANN(dis)

[CTENSOR package] Computes the components of the covariant Riemann
curvature tensor, and stores them in the array LRIEM[i,j,k,l], where
all four indices are covariant (lower).  LRIEMANN starts with the
(1,3) Riemann tensor as computed by RIEMANN (or calls RIEMANN if the
(1,3) curvature tensor is not yet present).  

RATRIEMANN default:TRUE
  If RATRIEMANN is TRUE then rational simplification will be done.  If
  RATFAC (default:FALSE) is TRUE then each of the components will also
  be factored.  If the argument dis is TRUE, the non-zero components
  are displayed.

&LRSETQ(var, exp)

[GENTRAN package] Where var is any matrix or array element with
indices which, after evaluation, will result in expressions that can
be translated by GENTRAN; and exp is any user level expression which,
after evaluation, will result in an expression that can be translated
by GENTRAN into the target language.

This is equivalent to var[EVAL(s1),EVAL(s2),...] : EVAL(exp) where
s1, s2, ... are indices.

&LSETQ(var, exp)

[GENTRAN package] Where var is any user level matrix or array element
with indices which, after evaluation will result in expressions that
can be translated by GENTRAN, and exp is any user level expression
that can be translated into the target language.

This is equivalent to var[EVAL(s1),EVAL(s2),...] : exp where 
s1, s2, ...  are indices.

&LSQ

The LSQ package performs general linear and nonlinear least squares
fit of curves to data.  The main functions in this package are LSQ1,
LSQ_LINEAR and LSQ_NONLINEAR.  

Do USAGE(LSQ); for more information.

Do DEMO(LSQ); and DEMO(LSQ1); for demonstrations.

See also LSQ_LINSOLVE and LSQ_ODE.

&LSQ_CHI2

[LSQ package] Holds the chi-squared error measure for the functions
LSQ1, LSQ_LINEAR, and LSQ_NONLINEAR. 

Do USAGE(LSQ); for more information.

&LSQ_DCHI2_TOL default:0.01

[LSQ package] This option variable determines the halting conditions
for the function LSQ_NONLINEAR. If changes in LSQ_CHI2 > LSQ_DCHI2_TOL
then iterate again, unless the iteration limit has been reached. See
LSQ_ITERATION_MAX.  

Do USAGE(LSQ); for more information.

&LSQ_DEVIATIONS default:[]

[LSQ package] Can be assigned as a value, a list
of standard deviations of the data points from the functions LSQ1,
LSQ_LINEAR, and LSQ_NONLINEAR.  The length of the list must equal the
number of data points.  The LSQ_ERROR terms are divided by their
respective deviations in the computation of the Chi-squared measure of
goodness of fit, LSQ_CHI2. When LSQ_DEVIATIONS has the default value
[], the deviations are assumed to be 1. 

Do USAGE(LSQ); for more information.

&LSQ_ERROR default:[]

[LSQ package] Can be assigned as a value, the list of residuals
between actual and fitted data in LSQ1, LSQ_LINEAR, and LSQ_NONLINEAR.

Do USAGE(LSQ); for more information.

&LSQ_INFLOAT default:'FLOAT

[LSQ package] Determines whether the numerical arguments to LSQ1,
LSQ_LINEAR, and LSQ_NONLINEAR are converted to floating point before
intermediate computations are performed. The value of LSQ_INFLOAT can
be the name of any univariate function such as SFLOAT, DFLOAT, and
BFLOAT, as well as RATIONAL and FALSE.  If the value is RATIONAL, then
all internal arithmetic is performed with rational numbers. If the
value is 'FLOAT then the types of the input data determine the types
used in internal computations.

Do USAGE(LSQ); for more information.

&LSQ_ITERATION_COUNTER default:0

[LSQ package] Holds the number of iterations which have been performed
in the function LSQ_NONLINEAR.

Do USAGE(LSQ); for more information.

&LSQ_ITERATION_MAX default:25

[LSQ package] The maximum allowed number of iterations by
LSQ_NONLINEAR.

Do USAGE(LSQ); for more information.

&LSQ_LAMBDA_INIT default:1/100

[LSQ package] The initial value of the lambda parameter in the
Marquardt algorithm.  If lambda=0 then Marquardt uses a pure gradient
method.  This variable applies only to LSQ_NONLINEAR.

Do USAGE(LSQ); for more information.

&LSQ_LAMBDA_FACTOR default:10

[LSQ package] If LSQ_CHI2 increases (decreases) from the previous
iteration, then lambda is multiplied (divided) by this factor for the
next iteration.  This variable applies only to LSQ_NONLINEAR.
 
&LSQ_LINEAR(indepvals, depvals, functions, indepvars)

[LSQ package] Performs linear least square fits with arbitrary shape
functions with an arbitrary number of independent variables.

Arguments:

 - `indepvals' is a list of the values of the independent variables;
   if the independent variables are x,y,z, then it is of the form
   [ [x1,y1,z1], [x2,y2,z2], . . . , [xlast,ylast,zlast] ];
 - `depvals' is a list of the values of the trial data to be fit;
 - `functions' is a list of the shape functions to be used (written
     as Macsyma expressions, not as Macsyma functions);
 - `indepvars' is a list or sequence of the names of the independent 
   variables, in the same order in which they are specified in the 
   `indepvals' list.

Actions:

 - returns the fitted function,
 - stores the values of fit parameters in a list as the value of
   the option variable LSQ_PARAMVALS,
 - stores the list of residuals between actual and fitted data as
   the value of the option variable LSQ_ERROR
 - stores the Chi-squared error measure as the value of the option
   variable LSQ_CHI2.

Do EXAMPLE(LSQ); for an example of this command. Do DEMO(LSQ); for
a longer demonstration of this and other commands in the LSQ
package.

See also LSQ1, LSQ_NONLINEAR.

&LSQ_LINSOLVE(list-of-equations {, list-of-variables})

[GENINV package] Computes the Moore-Penrose inverse and uses it to
compute the least- squares solution to the set of equations specified
by list-of-equations.  The second argument, list-of-variables,
specifies the variables to be solved for.  If this argument is not
given then LSQ_LINSOLVE solves for the list given by
LISTOFVARS(list-of-equations).

Do EXAMPLE(LSQ_LINSOLVE); for an example.  

Do USAGE(GENINV); for more information.

See also LSQ_LINSOLVE_BY_SVD.

See also LSQ_ODE for least squares fit of a parameterized ordinary
differential equation to numerical data. See also MATSOLVE_BY_SVD.

&LSQ_LINSOLVE_BY_SVD(A, B)

Solves the system by equations A.x = B using the SVD of A.  

See also LSQ_LINSOLVE.

&LSQ_LINSOLVE_BY_QR(mat, rhs)

Solves the system of equations mat.x = rhs using the QR decomposition
of mat.  (Available for NUMKIT only)

Do DEMO(NUMKIT); DEMO(NUMKIT1); for longer demos of NUMKIT routines.

See also LSQ_LINSOLVE_BY_SVD, LSQ_LINSOLVE, LSQ_LINSOLVE_BY_QRCOMPLETE.

&LSQ_LINSOLVE_BY_QRCOMPLETE(mat, rhs)

Solves the system of equations mat.x = rhs using the QR decomposition
of mat.  (Available for NUMKIT only)

Do DEMO(NUMKIT); DEMO(NUMKIT1); for longer demos of NUMKIT routines.

See also LSQ_LINSOLVE_BY_SVD, LSQ_LINSOLVE, LSQ_LINSOLVE_BY_QR.


&LSQ_NONLINEAR(indepvals, depvals, func, indepvars, params
{, paramguess})

[LSQ package] Finds the values of the fit parameters params which
provide the best fit of the function func(indepvars) to the data
indepvals and depvals.  The function func may depends on the fit
parameters params in a nonlinear fashion.  LSQ_NONLINEAR uses the
Marquardt algorithm for least squares fit.  

Arguments:

 - "indepvals" is a list of the values of the independent variables at 
   which values of the dependent variable are given; if the
   independent variables are x,y,z, then indepvals has the form
   [[x1,y1,z1], [x2,y2,z2], . . . , [xlast,ylast,zlast]] where each
   xi, yi and zi is a floating point number.
 - "depvals" is a list of the values of func at each of the points
   specified in the list indepvals.
 - "func" is a function to be fit to the data.  It is a function of
   the independent variables indepvars and also depends on the fit 
   parameters params. (This mathematical function is entered
   as a Macsyma expression, not as a Macsyma function.)
 - "indepvars" is a list of the symbolic names of the independent 
   variables, in the same order as is used in indepvals.
 - "params" is a list of the symbolic names of the fit parameters
   in the fit function func.
 - "paramguess" is a list of initial guesses for the fit parameters.

Actions:

 - returns the fitted function,
 - stores the optimal values of fit parameters as a list in the option
   variable LSQ_PARAMVALS, and as a list of equations in LSQ_PARAMEQS,
 - stores the number of iterations performed in the option variable
   LSQ_ITERATION_COUNTER,
 - stores the list of residuals between actual and fitted data as the
   value of the option variable LSQ_ERROR,
 - stores the Chi-squared error measure as the value of the option
   variable LSQ_CHI2,
 - if VERBOSE=TRUE then prints on each iteration the values of LSQ_CHI2
   and the current estimates for the fit parameters.

LSQ_NONLINEAR has several conditions for halting iteration.
 - If (change in LSQ_CHI2) < LSQ_DCHI2_TOL then halt.
 - If LSQ_ITERATION_COUNTER exceeds LSQ_ITERATION_MAX then halt.

Do EXAMPLE(LSQ_NONLINEAR); for an example of this command.  Do DEMO(LSQ1);
for a longer demonstration.

See also LSQ1, LSQ_LINEAR.

&LSQ_ODE(indepvals, depvals, odeqn, depvar, indepvar, params {,paramguess}) 

Fits the data represented by the list of abscissa values indepvals and the
list of ordinate values depvals to an ordinary differential equation in
either of these forms:
                                    2
   dy                              d y
   --   = f(y, t, p1,...,pn)       ---  = f(y, y', t, p1,...,pn)
   dt                                2
                                   dt

Arguments:

 indepvar  = independent variable (represented by t in the equation above)
 depvar    = dependent variable (represented by y in the equation above)
 odeqn     = an ordinary differential equation in depvar and indepvar
             of the form shown above, with the highest derivative
             isolated on the left-hand side
 params    = a list of fit parameters to be determined by LSQ_ODE
             (represented by p1,...,pn in the equation above)
 paramguess= an optional list of initial guesses for the values of the
             parameters params.

LSQ_ODE approximates the first derivatives of depvar (and the second
derivatives when fitting a second order differential equation) using a
three-point quadratic approximation scheme.

LSQ_ODE calls LSQ_NONLINEAR to compute the parameter values.  All the

option variables which control the behavior of LSQ_NONLINEAR affect
LSQ_ODE, and all the output variables produced by LSQ_NONLINEAR are
produced by LSQ_ODE.

Do EXAMPLE(LSQ_ODE); for an example.

See also the LSQ package and LSQ_LINSOLVE.

&LSQ_PARAMEQS default:[]

[LSQ package] Is a list of the equations of fit parameters, whose
value is assigned by LSQ_LINEAR, and LSQ_NONLINEAR.  See also
LSQ_PARAMVALS.

Do USAGE(LSQ); for more information. 

&LSQ_PARAMVALS default:[]

[LSQ package] Is a list of the values of fit parameters whose value is
assigned by LSQ_LINEAR, and LSQ_NONLINEAR.  See also LSQ_PARAMEQS.

Do USAGE(LSQ); for more information.

&LSQ_REFLOAT default:FALSE

[LSQ package] Determines how the final data will be presented by LSQ1,
LSQ_LINEAR, and LSQ_NONLINEAR. The value of LSQ_REFLOAT can be any
univariate function, such as SFLOAT, DFLOAT, and BFLOAT, or it can be
the value FALSE.  If FALSE, then no transformation of the final
results is performed.

Do USAGE(LSQ); for more information.

&LSQ1(abscissa,data, degree {, indepvar})

[LSQ package] Performs least squares fit with polynomial shape
functions with one independent variable.  Returns the result as a
polynomial in the variable indepvar (which defaults to "t" if it is
not specified).  While LSQ_LINEAR also solves these problems, LSQ1 is
more efficient for the univariate case.

 - "abscissa" is a list of the values (floatnums) of the independent
   variable at which values of the dependent variable are given; 
 - "data" is a list of the values of the data at each point
   specified in the list abscissa.
 - "degree" is the degree of the polynomial to be used in the fit;
 - "indepvar" is the variable used in the fitted polynomial. If it is
   not specified, it defaults to "t".

Do EXAMPLE(LSQ1); for an example of this command.

See also LSQ_LINEAR, LSQ_NONLINEAR.


&LU_BACKSUB(LU, B {, r, c})

Uses back substitution to solve the numerical matrix equation LU X = B,
where LU contains the packed LU factorization of a numerical square matrix
produced by say, LU_DECOMP. The arguments r and c are optional lists
specifying what row or column permutations were performed during the
original decomposition.

Do EXAMPLE(LU_BACKSUB); for an example.

See also LU_DECOMP, MATSOLVE_BY_LU, LU_DECOMP_SYMB, LU_BACKSUB_SYMB,
MATSOLVE_BY_SVD, IMPROVE_LU_SOLVE, MATSOLVE_BY_LU_SYMB, NUMKIT and
MATRIX_SUMMARY.

&LU_BACKSUB_SYMB(mat, vec)

Performs back substitutions to solve the linear equation mat.X =
vec. The matrix mat must be pre-calculated by LU_DECOMP_SYMB. 

Do EXAMPLE(LU_BACKSUB_SYMB); for an example.

See also LU_PIVOT, LU_DECOMP_SYMB, MATSOLVE_BY_LU_SYMB, LU_BACKSUB
and MATRIX_SUMMARY. 

&LU_COMPUTE_CONDITION default:FALSE

If TRUE, will cause various LU functions to compute an estimated
condition number of the matrix they are factoring (currently, only
INVERT_BY_LU).  The norm used is determined by the value of
LU_CONDITION_NORM.  The resulting condition number is assigned to the
global variable LU_CONDITION.  The condition number will be exact for
the function INVERT_BY_LU.

Do DEMO(LU); for an extended example of LU matrix decomposition.

&LU_CONDITION_NORM default:INFINITY

Is the norm used to compute the condition number of a matrix
undergoing LU factorization.  Other possible values are 1 and
FROBENIUS

See also MAT_NORM and MAT_NORM_NUMERICAL.

&LU_CONDITION

Is the estimated condition number computed during the last LU
factorization.

See also LU_COMPUTE_CONDITION, LU_CONDITION_NORM, LU_DECOMP.

&LU_DECOMP(A)

Produces the LU factorization of the numerical matrix A.  Either
partial (row) or full row and column pivoting is performed depending
on the value of the global flag LU_FULL_PIVOTING.  LU_DECOMP returns
a list of the form [LU, r {, c}].  LU will hold the packed LU
factorization of A, containing the L matrix below the diagonal and the
U matrix on and above the diagonal.  L also has a diagonal of ones
which are not shown.  r and c are lists indicating what row and column
permutations, respectively, were performed during the decomposition.

APPLY('LU_MATRICES, LU_DECOMP(A))
  Returns the list of matrices [L, U, R, C] where L U is the
  factorization of R A C (R and C are permutation matrices indicating
  what row and column swaps were performed, respectively, during the
  factorization.)

Do EXAMPLE(LU_DECOMP); for an example and DEMO(LU); for a longer
demonstration.

See also LU_COMPUTE_CONDITION, DETERMINANT_BY_LU, INVERT_BY_LU,
MATSOLVE_BY_LU, LU_BACKSUB, LU_MATRICES, LU_DECOMP_SYMB, 
LU_BACKSUB_SYMB,INVERT_BY_LU_SYMB, MATSOLVE_BY_LU_SYMB and 
MATRIX_SUMMARY.

&LU_DECOMP_SYMB(A)

Calculate the LU decomposition of the positive definite real square
matrix A with or without partial pivoting. The function returns the L
matrix below the diagonal, and the U matrix on or above the diagonal.
The L matrix has a diagonal of 1's which are not shown. When LU_DECOMP
uses pivoting, it returns the LU decomposition of a row-permuted
version if A.

Do EXAMPLE(LU_DECOMP_SYMB); for an example. Do DEMO(LU); for an
extended example of LU matrix decomposition.

See also LU_DECOMP, LU_BACKSUB_SYMB, LU_PIVOT. 

&LU_FULL_PIVOTING default:FALSE

If FALSE, the LU decomposition of matrices is performed using partial
(row) pivoting, otherwise it is performed using full row and column
pivoting.

Do DEMO(LU); for an extended example of LU matrix decomposition.

See also LU_DECOMP_SYMB.

&LU_MATRICES

Works on output from LU_DECOMP.  APPLY('LU_MATRICES, LU_DECOMP(A))
returns the list of matrices [L, U, R, C] where L U is the
factorization of R A C (R and C are permutation matrices indicating
what row and column swaps were performed, respectively, during the
factorization.)

&LU_PIVOT default:TRUE

Controls whether LU_DECOMP_SYMB uses row-pivoting.  When
LU_PIVOT:FALSE, pivoting is not performed, and diagonal entries of the
matrix M must be nonzero.  The matrices L and U satisfy L . U = M .

&M1PBRANCH default:FALSE

"Principal branch for -1 to a power".

Quantities such as (-1)^(1/3) [i.e. "odd" rational exponent] and 
(-1)^(1/4) [i.e. "even" rational exponent] are now handled as 
indicated in the following chart:
 
     DOMAIN:REAL (default) |                 DOMAIN:COMPLEX
                           |   M1PBRANCH:FALSE(default)   M1PBRANCH:TRUE
(-1)^(1/3):      -1        |    (-1)^(1/3)               1/2+%i*sqrt(3)/2
(-1)^(1/4):   (-1)^(1/4)   |    (-1)^(1/4)         sqrt(2)/2+%i*sqrt(2)/2

Do EXAMPLE(M1PBRANCH); for an example.

&MACRO

See MACROS.

&MACROEXPANSION default:FALSE

Controls advanced features which affect the efficiency of macros.
Possible settings:
 FALSE -- Macros expand normally each time they are called.
 EXPAND -- The first time a particular call is evaluated, the
   expansion is "remembered" internally, so that it doesn't have to be
   recomputed on subsequent calls making subsequent calls faster.  The
   macro call still GRINDs and DISPLAYs normally, however extra memory is
   required to remember all of the expansions.
 DISPLACE -- The first time a particular call is evaluated, the
   expansion is substituted for the call.  This requires slightly less
   storage than when MACROEXPANSION is set to EXPAND and is just as fast,
   but has the disadvantage that the original macro call is no longer
   remembered and hence the expansion will be seen if DISPLAY or GRIND is
   called.

See documentation for TRANSLATE and MACROS for more information.

&MACROS

Macsyma has a Macro facility.  

Documentation and demonstrations of this facility and related topics
are available in the following demo files: DEMO(MACRO);
DEMO(MACROEXP); DEMO(BASIC); EXAMPLE(BUILDQ); DEMO(BUILDQ);.

BUILDQ
  Is a Macsyma function for constructing pieces of code to be
  executed.  It is very useful in conjunction with macros, but may
  have other applications as well.

See also BASIC for some predefined macros provided with Macsyma.

&MAIL("message")

[Lisp Machine Macsyma only] Will send mail to Macsyma.  This may be
used to report problems or bugs.

MAIL(username, "message") will send mail to a specific user.

Expressions may be included by referring to them, outside double
quotes, when (and only when) a username is given, e.g.

MAIL(JDOE,"I am trying to integrate",D3,"but it asks for more list
space.  What should I do?");

&MAINVAR

You may DECLARE variables to be MAINVAR.  The ordering scale for atoms
is essentially: numbers < constants (e.g. %E,%PI) < scalars < other
variables < mainvars.  For example, compare
  EXPAND((X+Y)^4);
with
 (DECLARE(X,MAINVAR), EXPAND((X+Y)^4)); .  

Note: Care should be taken if you elect to use the above feature.  For
example, if you subtract an expression in which X is a MAINVAR from
one in which X isn't a MAINVAR, resimplification e.g. with
EV(expression, SIMP) may be necessary if cancellation is to occur.
Also, if you SAVE an expression in which X is a MAINVAR, you probably
should also SAVE X.

Do EXAMPLE(MAINVAR); for an executable example.

See also ORDERLESS and ORDERGREAT.

&MAKE_ARRAY(type, dim1, dim2, ..., dimn)

Creates an array.  "type" may be 'ANY, 'FLONUM, 'FIXNUM, 'HASHED or
'FUNCTIONAL.  This is similar to the ARRAY command, except that the
created array is a functional array object.  The advantage of this
over ARRAY is that it doesn't have a name, and once a pointer to it
goes away, it will also go away.  e.g.  Y:MAKE_ARRAY(....); Y now
points to an object which takes up space, but do Y:FALSE, and Y no
longer points to that object, so the object will get garbage
collected.  Note: the "dimi" here are different from the ARRAY
command, since they go from 0 to i-1, i.e.  a "dimension" of 10 means
you have elements from 0 to 9.

Y:MAKE_ARRAY('FUNCTIONAL,'F,'HASHED,1) - The second argument to
MAKE_ARRAY in this case is the function to call to calculate array
elements, and the rest of the arguments are passed recursively to
MAKE_ARRAY to generate the "memory" for the array function object.

&MAKE_NOTEBOOK(filespec)

Takes a batch file specified by filespec and returns the same file in
notebook format. This command does not execute the notebook.
Available only in Macsyma 2.0 and successors.

&MAKEBOX(exp)

[ITENSOR package] Displays exp in the same manner as SHOW; however,
any tensor d'Alembertian occurring in exp will be indicated using the
symbol [].  For example, []P([M,@N]) represents
G([@I,@J])*P([M,@N],I,J).

&MAKEFACT(exp)

Transforms occurrences of BINOMIAL, GAMMA functions, BETA functions, 
and some ELLIPTIC_KC(r) and ELLIPTIC_EC(r) for simple algebraic r 
occurring in exp to factorials.

Do EXAMPLE(MAKEFACT); for an example.

See also MAKEGAMMA.

&MAKEFLOOR(exp)

Transforms occurrences of NUMMOD, CEILING, and ROUND occurring 
in exp to FLOOR.

Do EXAMPLE(MAKEFLOOR); for an example.

&MAKEGAMMA(exp)

Transforms occurrences of BINOMIAL, FACTORIAL, BETA functions, 
and some ELLIPTIC_KC(r) and ELLIPTIC_EC(r) for simple algebraic r 
occurring in exp to GAMMA functions.

Do EXAMPLE(MAKEGAMMA); for an example.

See also MAKEFACT.

&MAKELIST(exp, var, lo, hi) 
 or
MAKELIST(exp, var, val_list)

Returns a list of the values of the expression exp which are derived
by evaluating the variable var. The values of var are either the
integers from lo to hi inclusive, or by the list of values val_list.

The first calling syntax of MAKELIST is analogous to that of SUM,
whereas in the second case MAKELIST is similar to MAP.

Examples:

 (c1) MAKELIST(CONCAT(X,I),I,1,6)

 (d1)                [x1, x2, x3, x4, x5, x6]

 (c2) MAKELIST(X=Y,Y,[A,B,C])

 (d2)                    [x=a, x=b, x=c]

You can make lists of integers using the sequence operator "..",
for example
 (c1)  1 .. 4;

 (d1)                    [1, 2, 3, 4]

 (c2) 1..2..9;

 (d2)                    [1, 3, 5, 7, 9]

Do EXAMPLE(MAKELIST); for an example.

&MANUAL

See DOCUMENTATION.

&MAP(fn, exp1 {, exp2, ...})

Returns an expression whose leading operator is the same as that of
the expi but whose subparts are the results of applying fn to the
corresponding subparts of the expi.  Fn is either the name of a
function of n arguments (where n is the number of expi) or is a LAMBDA
form of n arguments.  MAP is affected by the setting of INFLAG.

MAPERROR default:TRUE
  If FALSE will cause all of the mapping functions to
  1) stop when they finish going down the shortest expi if not all
     of the expi are of the same length and
  2) apply fn to [exp1, exp2,...]  if the expi are not all the same
     type of object.  If MAPERROR is TRUE then an error message will
     be given in the above two instances.

One of the uses of this function is to MAP a function (e.g.
PARTFRAC) onto each term of a very large expression where it
ordinarily wouldn't be possible to use the function on the entire
expression due to an exhaustion of list storage space in the
course of the computation.

 (c1) MAP(F,X+A*Y+B*Z);
 (d1)                        f(b z) + f(a y) + f(x)

Do EXAMPLE(MAP); for an example.

See also FULLMAP, FULLMAPL, MAPLIST, MATRIXMAP, OUTERMAP, SCANMAP.

&MAPATOM(expr)

Returns TRUE if and only if expr is treated by the MAPping routines as
an "atom", a unit.  "Mapatoms" are atoms, numbers (including rational
numbers), and subscripted variables.

Do EXAMPLE(MAPATOM); for an example.

See also ATOM and SYMBOLP.

&MAPERROR default:TRUE

 Value  Effect
 -----  ------
 FALSE  Causes all mapping functions (e.g. MAP(fn,exp1,exp2,...)) to
        (1) stop when they finish going down the shortest expi if not
            all of the expi are of the same length and
        (2) apply fn to [exp1, exp2,...] if the expi are not all the
            same type of object.

 TRUE   An error message is returned in the two situations above.

See also MAP.

&MAPLE

If you use Maple, look at the TOP_5_TIPS for information about Macsyma.

&MAPLIST(fn, exp1, exp2, ...)

Returns a list of the applications of fn to the parts of the expi.
This differs from MAP(fn,exp1,exp2,...)  which returns an expression
with the same main operator as expi has (except for simplifications
and the case where MAP does an APPLY).  Fn is of the same form as in
MAP.  MAPLIST is affected by the setting of INFLAG.

Do EXAMPLE(MAPLIST); for an example.

See also MAP.

&MAT_ABSORDERLESSP(x, y)

Orders complex numbers by magnitude.  Uses "<" on absolute values and
uses Macsyma ORDERLESSP when "<" is undecidable.

Do EXAMPLE(MAT_ABSORDERLESSP) for an example.

See also MAT_ORDERLESSP, ORDERLESSP, ASSUME, MAT_SORT.

&MAT_ALL(list_or)

Is the logical AND applied to lists, vectors, or matrices.  When
applied to a matrix, it is applied columnwise yielding a list.  By
convention, MAT_ALL returns TRUE when applied to an empty list or
matrix.

Do EXAMPLE(MAT_ALL); for an example.  

See also MAT_ANY.

&MAT_ANY(list_or)

Is the logical OR applied to lists, vectors, or matrices. When
applied to a matrix, it is applied columnwise yielding a list.  By
convention, MAT_ANY returns FALSE when applied to an empty list or
matrix.

Do EXAMPLE(MAT_ANY); for an example.  

See also MAT_ALL.

&MAT_ATAN2(x, y)

Two argument arctan function.  The inputs can be any mixture of
scalars, lists, or matrices as long as they both have the same number
of rows and columns.

An exception is  made if one argument is a scalar (or a
singleton list or a 1x1 matrix). In this case, SCALARMATRIXP
may affect the result by causing 1x1 any matrices to be
converted to scalars.  

A matrix is returned if one of the inputs is a matrix, otherwise 
a list is returned if one of the inputs is a list, and otherwise
a scalar.  

See also ATAN2, ASUMESCALARP.

&MAT_BLOCK_PACK()

Sets defaults for the usual operations with matrices whose elements
are themselves matrices. Atoms like a and b are assumed nonscalar they
are elements of a matrix.

Actions:

 KEEP_BLOCK_MATRIX: TRUE -- Inhibits MAT_UNBLOCKER
 ASSUMESCALAR: ALL       -- x . matrix([a, b])
                            -> matrix([x . a, x . b])
 SCALARMATRIXP: FALSE    -- Keeps 1 x 1 matrices from becoming
                            scalars
 DOTSCRULES: TRUE
 MATRIX_ELEMENT_ADD:  "+"
 MATRIX_ELEMENT_MULT: "."
 MATRIX_ELEMENT_TRANSPOSE: "^`" -- alternatively, "^*" for Hermitian
 MATRIX_ELEMENTS_ASSUMED_SCALAR: FALSE

Do EXAMPLE(MAT_BLOCK_PACK); for an example.

See also MAT_UNBLOCK_PACK (for returning to matrices whose elements
are scalars) and MAT_UNBLOCKER.

&MAT_BREAK

Causes termination of a loop.  In nested loops only the current loop
is terminated.

Do EXAMPLE(MAT_BREAK); for an example.

See also RETURN.

&MAT_CLOCK

Returns a six element row vector containing the current time and date
in integer form:  [year, month, day, hour, minute, seconds].

&MAT_COMPAN(list_or)

Transpose (consistent with Matlab usage) of the companion matrix given
input list of polynomial coefficients, beginning with highest power,
and proceeding to constant.  Also accepts vectors.

See also LIST2COMPANION, POLY2COMPANION, HYPERCOMPANION.

&MAT_COMPUTER

Returns a string containing the name of your computer. For example,
the returned value can be PC, SUN4, Symbolics 3600.
 
See also STATUS.

&MAT_CONVERT_TO_BOOLEAN(expr)

Converts nonzero numbers and nonzero number elements in matrices and
lists to TRUE; and converts zeros and zero elements in matrices and
lists to FALSE.  This function is useful in conjunction with
translating Matlab function files into Macsyma since Macsyma uses
TRUE and FALSE for Boolean variables while Matlab uses 1 and 0.

Do EXAMPLE(MAT_CONVERT_TO_BOOLEAN); for an example.

See also TRANSLATE_MATLAB_FILE.

&MAT_CORRCOEF(list_or)

Finds the correlation coefficients of a vector, matrix, or list.  The
calculations for a matrix are performed columnwise.  Multiple lists
can be entered and each list is treated as a column.

Do EXAMPLE(MAT_CORRCOEF) for an example.

See also UNIVARIATE STATISTICS, MULTIVARIATE_STATISTICS.

&MAT_COSM(mat)

Matrix cosine function of a square matrix.  Depends on finding the
eigenvalues of the matrix mat, which in general can not be done
exactly.  In floating point cases, the result may be unstable if mat
is not normal.

Do EXAMPLE(MAT_COSM) for an example.

See also MAT_EXPM, MAT_SQRTM, MAT_FCNM.

&MAT_COV(list_or)

Finds the covariance of a vector, matrix, or list.  The calculations
for a matrix are performed columnwise.  Multiple lists can be entered
and each list is treated as a column.

Do EXAMPLE(MAT_COV) for an example.

&MAT_CUMPROD(list_or)

Cumulative product on list or vector.  Applies columnwise on matrices.
Also sums multiple inputs as in MAT_CUMPROD(1, 2, 3, 4).

Do EXAMPLE(MAT_CUMPROD); for an example.

See also MAT_PROD, MAT_CUMSUM.

&MAT_CUMSUM(list_or)

Cumulative sum on list or vector.  Applies columnwise on matrices.
Also sums multiple inputs as in MAT_CUMSUM(1, 2, 3, 4).

Do EXAMPLE(MAT_CUMSUM); for an example.

See also MAT_SUM, MAT_CUMPROD.

&MAT_DIAG(_input_ {, k})

Applied to a matrix M returns a vertical vector of the diagonal
elements M[i,i] of the matrix.  MAT_DIAG applied to a _vector_or_list_
V returns a square matrix with v[i] on the diagonal.  With an optional
second argument, MAT_DIAG(Mat,k) extracts the kth diagonal. The index
k = -1 corresponds to the first subdiagonal, k = 0 to the main
diagonal, etc.

MAT_DIAG is affected by option variables KEEP_BLOCK_MATRIX
and MATRIX_ELEMENT_ASSUMED_SCALAR. 

Do EXAMPLE(MAT_DIAG); for an example.

See also MAT_TRI, MAT_TRIU.

&MAT_DIFF(list_or_matrix {, K})

Computes the Kth forward difference of a the elements of the first
argument, where the first argument is a list or a matrix. MAT_DIFF
acts on the columns of matrices.  If K is not specified, then K=1 is
assumed.

 First argument             Returned value
 --------------            ---------------
 list of length N           list of length N-K
 row vector of length N     row vector of length N-K
 column vector of length N  column vector of length N-K
 matrix of size M x N       matrix of size (M-K) x N

Do EXAMPLE(MAT_DIFF); for an example.

&MAT_EIG(Amat)

Returns a column vector of the eigenvalues of Amat.
[ U, D ] <: MAT_EIG(Amat) returns a list of two matrices, [ U, D ]  
the same size as Amat such that Amat U = U D, with D diagonal.

Do EXAMPLE(MAT_EIG); for an example.

&MAT_ERROR(string)

Prints string and returns to Macsyma.

See also ERROR, MAT_EVAL, ERRCATCH.

&MAT_EVAL(expr)

Evaluates and returns an expression or string containing an
expression.

MAT_EVAL(try, catch) evaluates "try" and returns it if 
no error occurs. Otherwise, the evaluation of "catch" is
returned.

MULTIPLE RETURNS NOT SUPPORTED, as in
   [X, Y, Z, ...] <: MAT_EVAL(input) 
returns multiple output arguments from the expression or
string "input". 

See also ERROR, EVAL_STRING, ERRCATCH.

&MAT_EXIST('X)
 or
MAT_EXIST("X")

Returns

   0   if input does not exist (has no value or function property)
   1   if input has been assigned a value
   2   if input is a user-defined function
   5   if input is a system function.

&MAT_EXPM(Mat)

Matrix exponential function of a square matrix.  Depends on finding
the eigenvalues of Mat, which in general can not be done exactly.  In
floating point cases, the result may be unstable if Mat is not normal.
Implemented for all square matrices.

See also MAT_FCNM, MATRIX_EXP.

&MAT_EYE(input {, n})

Generates an identity matrix which can be
 - square: MAT_EYE(m),
 - rectangular: MAT_EYE(m, n), or
 - the size of the input matrix: MAT_EYE(Mat).

However, if the option variable SIZE_OF_FLAG is set to TRUE, then
MAT_EYE(MAT_SIZE(Mat)) will produce an output the same size as that of
Mat.

Do EXAMPLE(MAT_EYE); for an example.

See also SIZE_OF_FLAG.

&MAT_FEVAL(funname, expr1, expr2, ..., exprN)

Forms funname(expr1, expr2, ..., exprN) and evaluates it as a Macsyma
expression.  The input funname can be a string or a variable.

See also APPLY.

&MAT_FLIPLR(mat_or)

Reverses the order of the columns of a matrix.  List input is
reversed, and scalar input is returned unchanged.

Do EXAMPLE(MAT_FLIPLR); for an example.  

See also MAT_FLIPUD.

&MAT_FLIPUD(mat_or)

Reverses the order of the rows of a matrix. List or scalar input is
returned unchanged.

Do EXAMPLE(MAT_FLIPUD); for an example.  

See also MAT_FLIPLR.

&MAT_FLOPS

Returns accumulated CPU time in milliseconds.  Counting flops is
meaningless in general symbolic computation.  This function is not
resetable.

See also TIMER, TIMER_DEVALUE, TIMER_INFO, STATUS(RUNTIME).

&MAT_FUNM(mat, fcn)
 or
MAT_FUNM(fcn, mat)

Function of a square matrix mat.  As an example, MAT_FUNM(A,cos) is
the matrix cosine function.  Depends on finding the eigenvalues of
Mat, which in general can not be done exactly.  In floating point
cases, the result may be unstable if Mat is not normal.

Do EXAMPLE(MAT_FUNM) for an example.

See also MAT_EXPM, MAT_SQRTM, MAT_LOGM, MATRIX_FUN.

&MAT_HILB(n)

Generates a Hilbert matrix of size n.  The ijth element is
1/(i+j-1).  Noted for being ill-conditioned for inversion.

Do EXAMPLE(MAT_HILB); for an example.

See also INVERT_HANKEL, MAT_INVHILB (the exact inverse).

&MAT_IDENT(input {, n})

Generates an identity matrix which can be
 - square: MAT_IDENT(m),
 - rectangular: MAT_IDENT(m,n), or
 - the size of an input matrix: MAT_IDENT(Mat). 

However, if the option variable SIZE_OF_FLAG is set to TRUE, then
MAT_IDENT(MAT_SIZE(Mat)) will produce an output the same size as
that of Mat.

Do EXAMPLE(MAT_IDENT); for an example.

See also SIZE_OF_FLAG, KEEP_BLOCK_MATRIX,
MATRIX_ELEMENTS_ASSUMED_SCALAR.

&MAT_IEEE

Returns TRUE if your version of Macsyma features IEEE floating point
arithmetic.  Identical to MAT_ISIEEE.

&MAT_INPUT("string to prompt user")

Prints the string, pauses, and then reads in and evaluates one
expression.  For example:  N:MAT_INPUT("Enter the number of
variables").  Recall strings must be enclosed by double quote marks.

See also READ.

&MAT_INVHILB(n)

Generates the exact inverse of the Hilbert matrix of order n. The
elements of this matrix are integers.  Both the Hilbert matrix and its
inverse are ill-conditioned for inversion.

Do EXAMPLE(MAT_INVHILB); for an example.

See also MAT_HILB, INVERT_HANKEL.

&MAT_ISEMPTY(input)

Returns TRUE if input is an empty list or empty matrix.

&MAT_ISIEEE

Returns TRUE if your version of Macsyma features IEEE floating point
arithmetic.  Identical to MAT_IEEE.

&MAT_KRON(A, B)

Forms the Kronecker product matrix from two input matrices A and B.

Do EXAMPLE(MAT_KRON); for an example.

&MAT_LDIV

Matrix division from the left.  A MAT_LDIV B is the solution of the
equation A X = B, and may contain arbitrary constants if A is
singular.  The matrices A and B must have the same number of rows.
List input is treated as a row vector, and scalar input as a 1x1
matrix.  The notation </ is also used for MAT_LDIV, as in A </ B .

Do EXAMPLE(MAT_LDIV); for an example.

See also MAT_RDIV, MAT_INV, PINV, MATLINSOLVE, LINSOLVE.

&MAT_LENGTH(mat_or)

Returns the length of a vector or the maximum dimension of a matrix.
List input is treated as a row vector and scalar input as a 1x1
matrix.

Do EXAMPLE(MAT_LENGTH); for an example.

See also MAT_NROWS, MAT_NCOLS, MAT_SIZE.

&MAT_LINSPACE(x1, xN {, N})

Generates a list with N evenly spaced elements from x1 to xN.   If the
optional last argument is not provided, N = 10 is used.

Do EXAMPLE(MAT_LINSPACE) for an example.

See also MAT_LOGSPACE, and the sequence operator ".." .

&MAT_LOGM(mat)

Matrix logarithm function of a square matrix.  Depends on finding the
eigenvalues of the matrix mat, which in general can not be done
exactly.  In floating point cases, the result may be unstable if mat
is not normal.  Of course, some matrices, like [< 0,1 ; 0,0 >], do not
have any logarithms.

Do EXAMPLE(MAT_LOGM); for an example.

See also MAT_EXPM, MAT_SQRTM, MAT_FCNM, MATRIX_EXP.

&MAT_LOGSPACE(e1, e2 {, N})

Generates a list with N logarithmically spaced elements from 10^e1 to
10^e2.  However, if e2 is %PI, the elements range from 10^e1 to pi.
If the optional last argument is not provided, N = 10 is used.

Do EXAMPLE(MAT_LOGSPACE); for an example.

See also MAT_LINSPACE, and the sequence operator ".. " .

&MAT_LOWER(input)

Coerces input to lower type, when possible. Returns the only element
of a 1 x 1 matrix, returns the only element of a list of length 1
(regarding the list as a row vector), or returns a list of the
elements of a row vector.  Column vectors and other matrices are
unchanged.  Unaffected by the option variable SCALARMATRIXP.  This
function is inverse to MAT_RAISE.

See also MAT_RAISE, SCALARMATRIXP.

&MAT_LTIFR(A, b, s)

Calculates the linear time-invariant frequency response of the system
(s I - A) g(s[i]) = b for each element of the frequencies on the input
vector s.  That is,

                 G(.., i): (s[i] I - A) LDIV b .

The column vector b must have as many rows as matrix A.  The
matrix G is returned.  Its size is MAT_SIZE(A) rows and 
MAT_LENGTH(s) columns.

Do EXAMPLE(MAT_LTIFR); for an example.

&MAT_MAT

Defines matrix input functions. It allows matrices to be input in
forms like [< a,b,c ; d,e,f >]; . In this form, commas separate
elements in the same row, and the semicolon indicates the start of a
new row. The elements a, b, etc. can be matrices, lists, scalars or
atoms.

Do EXAMPLE(MAT_MAT); for an example.

&MAT_MAX(x {, x2, ..., xN})

Maximum on multiple inputs or maximum of a list or vector.  Applies
columnwise on matrices, producing a list.  Supports MAT_MAX(1,2,3,4).

Do EXAMPLE(MAT_MAX); for an example.  

See also MAX, MAT_MIN.

&MAT_MEAN(list_or)

Averages a list or vector.  Applies columnwise on matrices, returning
a list.  Also averages multiple inputs as in MAT_MEAN(1,2,3,4).

Do EXAMPLE(MAT_MEAN); for an example.

See also SAMPLE_MEAN.

&MAT_MEDIAN(list_or)

Median in a list or vector. If the number of items is odd, the middle
item of the list is returned; otherwise, the middle two items are
averaged. Applies columnwise on matrices, returning a list.  Also
accepts multiple inputs as in MAT_SUM(1, 2, 3, 4).  Assumes ordering
by ORDERLESS.

Do EXAMPLE(MAT_MEDIAN); for an example.  

See also SAMPLE_MEDIAN, ORDERLESS.

&MAT_MIN(x {, x2, ..., xN})

Minimum on multiple inputs or minimum of a list or vector.  Applies
columnwise on matrices, producing a list.  Supports MAT_MIN(1,2,3,4).

Do EXAMPLE(MAT_MIN); for an example.  

See also MIN, MAT_MAX.

&MAT_NARGIN

A local variable available inside functions definitions. Gives number
of input arguments.

See also MAT_NARGOUT.

&MAT_NARGOUT default:1

Global variable generated by the assignment operator "<:" giving the
number of expected outputs of a function call. If MAT_NARGOUT is equal
to N > 1, the function is to return a list of length N.

See also MAT_NARGIN.

&MAT_NCOLS(Mat_or)

Number of columns in a matrix. List input is treated as a row vector
and scalar input as a 1x1 matrix.

See also MAT_NROWS, MAT_LENGTH, MAT_SIZE.

&MAT_NORM(a {, p})

Calculates the P-norm of the matrix or matrice A. 

 Value of P   Norm
 ----------   --------
   1          1-norm
   2          Euclidean 2-norm
  INF or
 INFINITY     infinity-norm
 MINF         minus-infinity-norm
 F, FRO,
 FROBENIUS    F-norm = sqrt(trace(A^* . A))
 or SCHUR 

If P is omitted, the default is the F-norm.  If A is a vector,
however, P may be any integer > 2 in addition to the above
possibilities.

Do EXAMPLE(MAT_NORM); for an example. 

See also MATRICE, LU_CONDITION_NORM and  MAT_NORM_NUMERICAL.

&MAT_NORM_NUMERICAL(A {,type})

Calculates the matrix norm of A of type type (Default: 2). Type may be
'inf, 1, 2, 'f, 'frobenius, or minf.  The Macsyma routines allow general
real or complex floating point matrices when NUMKIT is available.
Otherwise, only real matrices are acceptable. 

See also MAT_NORM and LU_CONDITION_NORM

&MAT_NROWS(Mat_or)

Number of rows in a matrix.  List input is treated as a row vector
and scalar input as a 1x1 matrix.

See also MAT_NCOLS, MAT_LENGTH, MAT_SIZE.

&MAT_ONES(input {, n})

Generates a matrix of ones which can be
 - square: MAT_ONES(m),
 - rectangular: MAT_ONES(m,n), or
 - the size of an input matrix: MAT_ONES(Mat).

If the option variable SIZE_OF_FLAG is set to TRUE, then
MAT_ONES(MAT_SIZE(Mat)) will produce an output the same size as
that of Mat.

Do EXAMPLE(MAT_ONES); for an example.

See also SIZE_OF_FLAG.

&MAT_ORDERLESSP(x, y)

Combines the ordering of real numbers and symbolic expressions.  It
orders real numbers using "<", and uses the Macsyma predicate
function ORDERLESSP when "<" is undecidable.

Do EXAMPLE(MAT_ORDERLESSP); for an example.

See also MAT_ABSORDERLESSP, ORDERLESSP, MAINVAR, ASSUME, 
DECLARE, MAT_SORT.

&MAT_PASCAL(n)

The upper-left half forms Pascal's triangle of order n - 1 .  The
whole matrix is a diamond-shaped section of Pascal's triangle of order
2 (n - 1).  The general ijth element is given by BINOMIAL(i+j-2,i-1).
These matrices have integer entries, and so do their inverses. Pascal
matrices of all orders have determinant 1, yet they are
ill-conditioned for inversion.

Do EXAMPLE(MAT_PASCAL); for an example.

&MAT_PAUSE(n)

Suspends computation for n seconds.  Invokes SLEEP(n). MAT_PAUSE()
Suspends computation awaiting carriage return. Invokes PAUSE().

Do EXAMPLE(MAT_PAUSE); for an example.

See also SLEEP, PAUSE.

&MAT_POLY(Mat_or)

Returns (-1)^n * characteristic polynomial of an input matrix.
Returns a list of its coefficients, from highest powers to lowest.
MAT_POLY(list_or) applied to a list of roots, returns a list of the
coefficients of a polynomial with these roots.  Scalar input is
treated as a 1x1 matrix.

See also POLY2LIST.

&MAT_POLYFIT(list_or, degree)

Polynomial fit to a list or vector of values of the desired
polynomial.  The output is a list of coefficients of a polynomial of
the specified degree.  This list of coefficients in order of
decreasing powers of the polynomial.

See also LSQ.

&MAT_POLYVALM(coeflist_or, mat_or)

The same function as MATRIX_LIST2POLY.

&MAT_PROD(list_or)

Multiplies elements of a list or vector.  Applies columnwise on
matrices, returning a list.  Also multiplies multiple inputs as in
MAT_PROD(1,2,3,4).

Do EXAMPLE(MAT_PROD); for an example.  

See also MAT_CUMPROD, MAT_SUM.

&MAT_QR(Mat_or {, 'unnormalized})

Orthogonal-triangular decomposition.

[Q, R] <: MAT_QR(A) produces an upper triangular matrix R of the same
      size as A and a matrix Q such that A = Q*R,  and Q^* . Q = I.
      QR(A) simply returns R.
[Q, R] <: MAT_QR(A, 'unnormalized) is recommended for symbolic
      matrices. This returns an upper triangular matrix R of same size
      as A and a matrix Q such that A = Q R, and Q^* .  Q is diagonal.

This name is provided as a convenience for Matlab users. The normal 
Macsyma name for this function is QR_DECOMP.

Do EXAMPLE(MAT_QR); for an example.

See also QR_DECOMP.

&MAT_QUAD8(funcname, lo, hi {, tol {, p1, p2, ..., pN}})

Approximates an integral of funcname using the Newton-Cotes 8 panel method.

Do EXAMPLE(MAT_QUAD8); for an example.  

See also  QUANC8, ROMBERG, BROMBERG, TRAPRULE, SIMPSON.

&MAT_QUOT(x, y)

Special case of QUOTIENT.  Returns the quotient of x divided by y for
integers or univariate polynomials. Applies elementwise to any mixture
of scalars, lists, or matrices if they both have the same number of
rows and columns.

An exception is made if one argument is a scalar (or a singleton list
or a 1x1 matrix). In this case, SCALARMATRIXP may affect the result by
causing any 1x1 matrices to be converted to scalars.  A matrix is
returned if one of the inputs is a matrix, otherwise a list is
returned if one of the inputs is a list, and otherwise a scalar.

Do EXAMPLE(MAT_QUOT); for an example.

See also MAT_REM, REMAINDER, QUOTIENT.

&MAT_RAISE(input)

Converts an expression or a list to a matrix, regardless of the option
variable SCALARMATRIXP.  However, SCALARMATRIXP may affect subsequent
results causing 1x1 matrices to be converted to scalars.  This
function is inverse to MAT_LOWER.

Do EXAMPLE(MAT_RAISE); for an example.  

See also MAT_LOWER, SCALARMATRIXP.

&MAT_RAND(input {, n})

Generates a matrix of random numbers between 0 and 1.  
Double float numbers are generated by default but an optional 
third argument can be used for specifying the desired type 
(2.0d0, 'SFLOAT, 'BFLOAT, etc.)

The output matrix can be
 - square: MAT_RAND(m),
 - rectangular: MAT_RAND(m, n),
 - or the size of an input matrix: MAT_RAND(Mat).

If the option variable SIZE_OF_FLAG is set to TRUE, then
MAT_RAND(MAT_SIZE(Mat)) will produce an output the same size as that
of Mat.

Do EXAMPLE(MAT_RAND); for an example.

See also SIZE_OF_FLAG.

&MAT_RANK

Returns the rank of a matrix.  List input is treated as a row vector
and scalar input as a 1x1 matrix.

Do EXAMPLE(MAT_RANK); for an example.  

&MAT_RDIV

Matrix division from the right.  B MAT_RDIV A is the solution of the
equation X A = B, and may contain arbitrary constants if A is
singular.  The matrices A and B must have the same number of columns.
List input is treated as a row vector, and scalar input as a 1x1
matrix.  The notation /> is also used for MAT_RDIV, as in B /> A .

Do EXAMPLE(MAT_RDIV); for an example.

See also MAT_LDIV, MAT_INV, PINV, MATLINSOLVE, LINSOLVE.

&MAT_REM(x, y)

Special case of REMAINDER.  Returns the remainder of x divided by y
for integers or univariate polynomials.  Applies elementwise to any
mixture of scalars, lists, or matrices if they both have the same
number of rows and columns.  An exception is made if one argument is a
scalar (or a singleton list or a 1x1 matrix). In this case,
SCALARMATRIXP may affect the result by causing 1x1 any matrices to be
converted to scalars. A matrix is returned if one of the inputs is a
matrix, otherwise a list is returned if one of the inputs is a list,
and otherwise a scalar.

Do EXAMPLE(MAT_REM); for an example.

See also MAT_QUOT, REMAINDER, QUOTIENT.

&MAT_ROT90(Mat_or {, k})

Rotates a matrix 90 degrees counterclockwise.

         [ 1   10  ]
         [         ]                         [ 10  50  250 ]
         [ 5   50  ]   --- MAT_ROT90 --->    [             ]
         [         ]                         [ 1   5   25  ]
         [ 25  250 ]

(List input is treated as a row vector and scalar input as 
a 1x1 matrix.) An optional second argument allows the matrix
to be rotated more than once or change the direction of the
rotation by making this argument negative.

Do EXAMPLE(MAT_ROT90); for an example.

&MAT_SEQCHUB(N {, 'extrema })

Generates list of the N zeros of the Chebyshev polynomial T[N], unless
optional argument is provided.  In this case, the extrema of T[N-1]
are returned.
  
See also MAT_LINSPACE, MAT_LOGSPACE.
  
&MAT_SINM(Mat)

Matrix sine function of a square matrix.  Depends on finding the
eigenvalues of Mat, which in general can not be done exactly.  In
floating point cases, the result may be unstable if Mat is not normal.

Do EXAMPLE(MAT_SINM) for an example.

See also MAT_EXPM, MAT_SQRTM, MAT_FCNM.

&MAT_SIZE(mat_or)

Size of a matrix.  Returns a list of the form [number of rows, number
of columns].  List input is treated as a row vector and scalar input
as a 1x1 matrix.

Do EXAMPLE(MAT_SIZE); for an example.

See also MAT_NROWS, MAT_NCOLS, MAT_LENGTH, SIZE_OFP.

&MAT_SLEEP(n)

Suspends computation for N seconds.  N is a required argument.

See also SLEEP, PAUSE.

&MAT_SORT(list_or {, predicate_function})

Orders a list in ascending order; applies columnwise on matrices.
Returns permuted indices if called by [sorted, indices] <:
MAT_SORT(input {, predicate_function}).

MAT_SORT takes an optional second argument of a "less than" 
type predicate. Some forethought may be needed, since symbolic
comparisons like a < b may be undecidable.  The default
ordering is ORDERLESSP. 

Do EXAMPLE(MAT_SORT); for an example.  

See also ORDERLESS, ORDERLESSP, MAINVAR, ASSUME, DECLARE,
MAT_ORDERLESSP, MAT_ABSORDERLESSP.

&MAT_SQRT(MAT)

Calculates a matrix square root C of a real, symmetric positive
definite matrix numerical MAT such C is real, symmetric and positive
definite. C is not unique

&MAT_SQRTM(Mat)

Matrix square root function of a square matrix.  Depends on finding
the eigenvalues of Mat, which in general cannot be done exactly.  In
floating point cases, the result may be unstable if Mat is not normal.
Of course, some matrices, like [< 0,1 ; 0,0 >], do not have any square
roots.

Do EXAMPLE(MAT_SQRTM) for an example.

See also MAT_EXPM, MAT_LOGM, MAT_FCNM.

&MAT_STARTUP

Reloads the initialization file macsyma-init.macsyma (if it exists)
from your home directory.

&MAT_STD(list_or)

Returns the standard deviation of a list or vector.  Applies
columnwise on matrices, returning a list.  Also accepts multiple
inputs as in MAT_STD(1,2,3,4).

Do EXAMPLE(MAT_STD); for an example.  

See also SAMPLE_STANDARD_DEVIATION, MAT_VAR, SAMPLE_VARIANCE.

&MAT_SUM(list_or)

Returns the sum of a list or vector.  Applies columnwise on matrices,
returning a list.  Also sums multiple inputs as in MAT_SUM(1,2,3,4).

Do EXAMPLE(MAT_SUM); for an example.

See also MAT_CUMSUM, MAT_PROD.

&MAT_SVD

Returns the numerical singular value decomposition of its first argument.
It has several calling syntaxes.

MAT_SVD(A)
  Returns a vector of the singular values of A in sorted order.

[U, S, V] <: MAT_SVD(Mat_or {, 0 }) 
  Returns and assigns three matrices [U, S, V] with S a diagonal
  matrix of the same size as A with real, nonnegative diagonal
  elements, and  unitary matrices U and V such that
  A = U . S . V^*  .


[U, S, V] <: MAT_SVD(A, 0)
  Returns an "economy size" decomposition of A. If A has fewer
  columns, say n, than rows, then the returned matrix U has only n
  columns and S is nxn.  Nevertheless, A = U . S . V^* .

Do EXAMPLE(MAT_SVD); for an example.

See also SVD.

&MAT_TANM(mat)

Matrix tangent function of a square matrix.  Depends on finding the
eigenvalues of the matrix mat, which in general can not be done
exactly.  In floating point cases, the result may be unstable if mat
is not normal.  Of course, some matrices do not have tangents.

Do EXAMPLE(MAT_TANM) for an example.

See also MAT_EXPM, MAT_SQRTM, MAT_FCNM.

&MAT_TRIL(Mat_or {, k})

Returns the lower triangular part of the input, zeroing out all other
entries.  List input is treated as a row vector and scalar input as a
1x1 matrix.

With an optional second argument, MAT_DIAG(Mat, k) extracts from
the  kth diagonal and below.  The index k = -1 corresponds to
the first subdiagonal , k = 0 to the main diagonal, etc.

Do EXAMPLE(MAT_TRIL);

See also MAT_TRIU, MAT_DIAG.

&MAT_TRIU(Mat_or {, k})

Returns the upper triangular part of the input, zeroing out all other
entries.  List input is treated as a row vector and scalar input as a
1x1 matrix.

With an optional second argument, MAT_DIAG(Mat,k) extracts from the 
kth diagonal and above.  The index k = -1 corresponds to  the first 
subdiagonal, k = 0 to the main diagonal, etc.

Do EXAMPLE(MAT_TRIU);

See also MAT_TRIL, MAT_DIAG.

&MAT_TRUE(list_or)

MAT_TRUE(x) is the same as MAT_ALL(MAT_ALL(x)).  It is used by
TRANSLATE_MATLAB_FILE.

&MAT_UNBLOCKER(block_mat_or)

Removes the inner matrix structure of a matrix with some elements that
are matrices.  However, if the option variable KEEP_BLOCK_MATRIX is
TRUE, MAT_UNBLOCKER returns its input unchanged.

Do EXAMPLE(MAT_UNBLOCKER); for an example.  

See also KEEP_BLOCK_MATRIX, MAT_BLOCK_PACK.

&MAT_UNBLOCK_PACK()

Resets to the usual operations with matrices whose elements are
scalars.  Atoms are assumed scalar when they are elements of a matrix.
The defaults restored by MAT_UNBLOCK_PACK are:

 KEEP_BLOCK_MATRIX: FALSE -- Allows MAT_UNBLOCKER to act
 ASSUMESCALAR: TRUE       -- x . matrix([a, b])
                              -> matrix([x * a, x * b])
 SCALARMATRIXP: TRUE      -- makes 1x1 matrices become scalars
 DOTSCRULES: FALSE
 MATRIX_ELEMENT_ADD: "+"
 MATRIX_ELEMENT_MULT: "*"
 MATRIX_ELEMENT_TRANSPOSE: FALSE
 MATRIX_ELEMENTS_ASSUMED_SCALAR: TRUE

Do EXAMPLE(MAT_UNBLOCK_PACK); for an example.  

See also MAT_BLOCK_PACK and MAT_UNBLOCKER.

&MAT_VANDER(list_or, cols)

Returns column reversed version of the Vandermonde matrix (consistent
with Matlab usage).  This puts the elements of list_or into the next
to last column.  Returns a square matrix unless optional 2nd variable
is given which determines the number of columns.

Do EXAMPLE(MAT_VANDER); for an example.

See also VANDERMONDE and GENVANDERMONDE.

&MAT_VAR(list_or)

Variance of a list or vector. Applies columnwise on matrices,
returning a list.  It also accepts multiple inputs as in
MAT_VAR(1,2,3,4).

Do EXAMPLE(MAT_VAR); for an example.  

See also SAMPLE_VARIANCE, MAT_STD, SAMPLE_STANDARD_DEVIATION.

&MAT_WHO

Prints a list of the names of all variables that have been assigned
values.  VALUES is the name of a list maintained by the system. The
value of a variable can be removed with REMVALUE.   Do INFOLISTS;
to see the names of the other lists.

See also VALUES, INFOLISTS.

&MAT_ZEROS(input {, n})

Generates a matrix of zeros which can be
 - square: MAT_ZEROS(m),
 - rectangular: MAT_ZEROS(m,n), or
 - the size of an input matrix: MAT_ZEROS(Mat).

If the option variable SIZE_OF_FLAG is set to TRUE,
MAT_ZEROS(MAT_SIZE(Mat)) will produce an output the same size
as that of Mat.

Do EXAMPLE(MAT_ZEROS); for an example.

See also ZEROMATRIX and SIZE_OF_FLAG.

&MATCHDECLARE(patternvar, predicate, ...)

Permits patternvar to match only expressions for which the predicate
is not FALSE.  The matching is accomplished by one of the functions
which define pattern matching rules (DEFRULE, TELLSIMPAFTER and
TELLSIMP) or patterns (DEFMATCH).

For example,
 - MATCHDECLARE(P,TRUE) will permit P to match any expression.
 - MATCHDECLARE(Q,EVENP) will permit Q to match any even integer.
 - MATCHDECLARE(R,FREEOF(X,%E)) causes R to match any expression 
   not containing X or %E.  The predicate (in this case FREEOF)
   is written without the last argument which should be the one
   against which the pattern variable is to be tested.  Note that
   the patternvar and the arguments to the predicate are evaluated
   at the time the match is performed.

NOTE: MATCHDECLARE variables are supposed to be matched with
expressions, not operators.  Operators (i.e. items in the operator
position of expressions, including names of subscripted variables)
are assumed to be constant.

Any even number of arguments may be given.  The odd numbered
arguments may also be a list of pattern variables all of which
are to have the same associated predicate.

For pattern matching, predicates refer to functions which are
either FALSE or not FALSE (any non FALSE value acts like TRUE).

Do EXAMPLE(MATCHDECLARE); for an example.

&MATCHFIX(oper, matchoper {, argpos, pos})

Defines the symbol oper to be a matchfix operator, with matching right
symbol matchoper.

MATCHFIX operators are functions of any number of arguments which are
passed to the function as a list.  The arguments occur between the
main operator and its "matching" delimiter.

Arguments:

 - oper       the left hand symbol in the matchfix notation,
 - matchoper  the matching right-hand symbol,
 - argpos     part of speech of the arguments (default:ANY),
 - rpos       right part of speech (default:ANY),
 - pos        part of speech of the result (default:ANY).

All arguments after the first two are optional.

Do USAGE(OPERATORS); for more information on defining operators.

Do DEMO(OPERATORS); for a demonstration.

See also PREFIX, POSTFIX, INFIX, NARY, NOFIX.

&MATCONVOLVE

The MATCONVOLVE library contains three functions, MATCONVOLVE_DIRECT,
MATCONVOLVE_POLY, and MATCONVOLVE_FFT, each of which convolves two
matrices to make a third, larger matrix.

Do USAGE(MATCONVOLVE) for more information.

Do DEMO(MATCONVOLVE); for a demonstration.

&MATCONVOLVE_DIRECT(A, B)

[MATCONVOLVE package] Computes the matrix which is the convolution of
two given matrices. If A is M x N and B is P X Q, then the convolution
C is defined to be the M+P-1 X N+Q-1 matrix with

            ====
            \
    C     =  >    A      B
     i, j   /      k, n   i - k + 1, j - n + 1
            ====
            k, n

with k and n ranging everywhere the summand is defined. 

&MATCONVOLVE_FFT(A, B)

[MATCONVOLVE package] Computes a single-precision, complex, floating
point approximation to the convolution defined by MATCONVOLVE_DIRECT.
Requires that input matrices are numeric. It introduces roundoff noise
and in both real and imaginary parts, but may be faster than
MATCONVOLVE_DIRECT for very large input matrices.

See also MATCONVOLVE_POLY.

&MATCONVOLVE_POLY(A, B)

[MATCONVOLVE package] Computes the same matrix as MATCONVOLVE_DIRECT
via generating functions and COEFMATRIX. It may be faster than
MATCONVOLVE_DIRECT in some cases, depending on the size of the input
matrices and the data type of their elements.

&MATDESOLVE(matrix_equation, vector_variable)

This command has been renamed ODEMATSYS.  While MATDESOLVE still
works, you are encouraged to use ODEMATSYS instead.

&MATEIGENS

NUMKIT Routine.

Do USAGE(NUMKIT); for more information.

&MATEIGENSCOMPLEX

NUMKIT Routine.

Do USAGE(NUMKIT); for more information.

&MATFUNCS

A library package containing miscellaneous matrix-related functions.

Do USAGE(MATFUNCS); for more information. 

Do DEMO(MATFUNCS); for a demonstration.

&MATGENSOLVE

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MATGENSOLVEX

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MATGENSUBST

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MATGENSUBSTX

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MATHEMATICA

If you use Mathematica, look at the TOP_5_TIPS for information about
using Macsyma.

&MATHEMATICAL_CONSTANTS

Macsyma contains the following pre-defined mathematical constants.

 %catalan - Catalan's constant
 %e       - the base of the natural logarithms
 %gamma   - the Euler-Mascheroni constant
 %i       - a square root of -1
 %phi     - (sqrt(5)+1)/2
 %pi      - The ratio of the circumference to the diameter of a circle

 inf      - real positive infinity
 minf     - real negative infinity
 infinity - complex infinity

 true     - Boolean truth value
 false    - Boolean truth value

See also PHYSICAL_CONSTANTS.


&MATHERMSOLVE

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MATHERMSOLVEX

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MATHERMSUBST

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MATHERMSUBSTX

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MATHIEU_A [a,b](x)

A Mathieu function which is a general solution of Mathieu's equation: 

 2*(x-1)*x*'diff(y,x,2)+(2*x-1)*'diff(y,x)+(a*x-(b+a)/2)*y = 0 

which can be solved by ODE.  Macsyma has no other built in knowledge 
of this function.

See also MATHIEU_B, ODE, and ODELIN2.

&MATHIEU_B [a,b](x)

A Mathieu function which is a general solution of Mathieu's equation: 

 2*(x-1)*x*'diff(y,x,2)+(2*x-1)*'diff(y,x)+(a*x-(b+a)/2)*y = 0 

which can be solved by ODE.  Macsyma has no other built in knowledge 
of this function.

See also MATHIEU_A, ODE, and ODELIN2.

&MATLAB

Macsyma supports nearly all of the language features and functionality
of Matlab.

If you know the name of a Matlab function, you can usually
find the name of the comparable Macsyma function in one of
three ways: 

 - The Matlab command name may be the same as in Macsyma.
   For example HANKEL and TOEPLITZ are the same in Macsyma
   and Matlab.

 - The Macsyma name may be of the form MAT_name.
   For example EYE -> MAT_EYE.  

 - Macsyma may have a closely related function which does
   not behave like the Matlab command of the same name.
   For example, Macsyma's SVD does not do what Matlab's
   SVD does, while Macsyma's MAT_SVD command does what
   Matlab's SVD command does.
   Other examples of this type of name include MAT_MAX, 
   MAT_MIN, and MAT_SUM.

Even when it is not documented in Macsyma, the name
MAT_Matlabname often works for the Matlab command
Matlabname.

An important difference between the Macsyma and Matlab
languages is that Macsyma distinguishes Boolean, fixnum
and floating point data types, while Matlab does not.

Macsyma can translate Matlab command files to Macsyma
command files.

Do USAGE(MATLAB_TRANSLATOR); for more information.

Do DEMO(MATLAB); for a demonstration of the translator.

&MATLINSOLVE([linear_matrix_equations], [vector_variables])

[MATSOLVE package] Solves a linear matrix equation for the vector
variable given as an argument, in a manner analogous to LINSOLVE.
MATLINSOLVE can be given single matrix equation without brackets as
well as single matrix variables. The equation(s) can be matrix,
vector, or scalar equations and the variables can be either vectors,
matrices, or scalars.  MATLINSOLVE returns a list of solution
equations, with matrices in the original form.

MATLINSOLVE solves only linear matrix equations whereas
MATSOLVE solves linear and nonlinear matrix equations. 
Internally, MATLINSOLVE calls LINSOLVE while MATSOLVE calls
SOLVE. If you want to solve nonlinear matrix equations, such
as eigenvalue equations where both the eigenvalue and the
eigenvector are unknown, then use MATSOLVE. MATLINSOLVE
preserves floating point numbers, whereas MATSOLVE converts
them to rational numbers in order to use nonlinear algebraic
methods if needed. 

Do EXAMPLE(MATLINSOLVE); for an example.

See also LINSOLVE, MATSOLVE, MATRIX_ELIMINATE.

&MATLSQQR

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MATLSQQRCOMPLETE

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MATLSQSVD

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MATRICE(symbol, options, object)

[MATRICE package] Creates a matrice described by the options with its
elements taken from the object and attaches the newly created matrice
to the symbol. The object may be a matrix, a two-dimensional array,
the word ZEROES (in which case the matrice will be filled with
zeroes), the pseudofunction VALUE(k) (in which case the nonzero
portion of the matrice will be filled with the value specified by k),
or a list of lists.  In the last case, the (sub)lists will be used to
fill the secondary arrays of the matrice directly so that this
operation performs the inverse of ICE2LIST.  (As a shorthand, a single
unlistified expression will abbreviate a sublist of identical copies
of this expression.)  If the object is omitted then MATRICE will call
ENTERMATRICE.  The options consist of zero or more descriptors
providing the parameters of the matrice.  If a descriptor is a
positive integer or a list containing a single positive integer then
the number will be taken for the row and column dimension of the
matrice.  If a descriptor is a list containing two positive integers
then the first integer will be taken to be the row dimension and the
second the column dimension of the matrice. (Note that if the object
that is provided to MATRICE is a matrix or a two-dimensional array
then the OBJECT's dimensions will be used for the matrice and so do
not need to be explicitly specified.)  A descriptor may also indicate
the mathematics of the matrice (REAL or COMPLEX - default:REAL), the
form of its elements (NUMERICAL, CRE [Canonical Rational Expressions]
or GENERAL_EXPRESSIONS [the default]) or its type (default is
GENERAL).  The possible types that may be specified are given in the
first column of the following table:

   GENERAL                  m x n
   HERMITIAN                n x n
  +GENERAL_BANDED           n x n*
  +HERMITIAN_BANDED         n x n
   UPPER_TRIANGULAR         m x n
   LOWER_TRIANGULAR         m x n
   UPPER_HESSENBERG         n x n
   LOWER_HESSENBERG         n x n
   SYMMETRIC                n x n    REAL HERMITIAN
  +BANDED                   n x n*   GENERAL_BANDED
   DIAGONAL                 m x n    GENERAL_BANDED(1)
   TRIDIAGONAL              n x n    GENERAL_BANDED(2)
   HERMITIAN_TRIDIAGONAL    n x n    HERMITIAN_BANDED(2)
  +SYMMETRIC_BANDED         n x n    REAL HERMITIAN_BANDED
   SYMMETRIC_TRIDIAGONAL    n x n    REAL HERMITIAN_BANDED(2)
   TRIANGULAR               m x n    UPPER_TRIANGULAR
   HESSENBERG               n x n    UPPER_HESSENBERG

  *May be m x n if the half-bandwidth is 1.

The first 8 entries are the basic matrice types while 
the remaining entries designate certain special aliases
whose equivalents are given in the third column of the
table.  The second column displays the possible dimensions
each matrice of the indicated type can take.  Here, m
and n are positive integers where m need not be equal
to n. The (banded) types preceded by a plus (+) can
also be given in the form of pseudo-functions with the
half-bandwidth as their argument (for example,
GENERAL_BANDED(3) indicates a type of GENERAL_BANDED
with a half-bandwidth of 3).  If any necessary descriptors
are omitted and cannot be defaulted then their values
will be prompted for interactively.  MATRICE returns as
its value the description of the newly created matrice
produced by MATRICEINFO. 

Do USAGE(MATRICE); for more information, including information on the
following functions: ENTERMATRICE, TRANSMUTE, COPYMATRICE, MAPMATRICE,
RENAMEMATRICE, ICE2IX, ICE2LIST, REMMATRICE, MATRICEP, MATRICEINFO.

Do DEMO(MATRICE2); for a demonstration.

&MATRICES

See MATRIX_SUMMARY.

&MATRIX(row1, ..., rown)

Defines a rectangular matrix with the indicated rows.  Each row has
the form of a list of expressions, e.g.  [A, X^2, Y, 0] is a list of
4 elements.

Do EXAMPLE(MATRIX); for an example.

See also GENMATRIX, MAT_MAT.

For a description of Macsyma's capabilities in matrix algebra, see
MATRIX_SUMMARY.

&MATRIX_ELEMENT_ADD default:"+"

May be set to "?"; may also be the name of a function, or a LAMBDA
expression.  In this way, a rich variety of algebraic structures may
be simulated.

Do DEMO(MATRIX1); and DEMO(MATRIX2); for demonstrations.

See also MATRIX_SUMMARY.

&MATRIX_ELEMENT_MULT default:"*"

May be set to "."; may also be the name of a function, or a LAMBDA
expression.  In this way, a rich variety of algebraic structures may
be simulated.

Do DEMO(MATRIX1); and DEMO(MATRIX2); for demonstrations.

See also MATRIX_SUMMARY.

&MATRIX_ELEMENT_TRANSPOSE default:FALSE

Other useful settings are TRANSPOSE and NONSCALARS; may also be the
name of a function, or a LAMBDA expression.  In this way, a rich
variety of algebraic structures may be simulated.

Do DEMO(MATRIX1); and DEMO(MATRIX2); for demonstrations of these
capabilities.

See also MATRIX_SUMMARY.

&MATRIX_ELEMENTS_ASSUMED_SCALAR default:TRUE

This option variable is used by DET, INV and some Matlab-type
functions. If the option variable MATRIX_ELEMENTS_ASSUMED_SCALAR is
TRUE, then the corresponding arithmetic operations can be carried out
using scalar arithmetic, regardless of the type of the matrix
elements.

Do EXAMPLE(MATRIX_ELEMENTS_ASSUMED_SCALAR); for an example.

See also DETERMINANT, INVERSE, MAT_DIAG, MAT_UNBLOCKER,
MAT_BLOCK_PACK.

&MATRIX_ELIM(mats, lis)

[MATFUNCS package] Eliminates variables from linear matrix
equations, where the variables to be eliminated are specified
by the list lis of positive integers.

For example, eliminating variable v2 from the equation

| m11  m12 |   | v1 |   | b1 |
|          | . |    | = |    |
| m21  m22 |   | v2 |   | b2 |

yields the matrix equation

| m11-m12.(m22^^-1).m21 | . | v1 | = | b1 | .

Arguments:
 - mats is either 
   - a square matrix, or 
   - a list whose first element is a square matrix and each of 
     whose remaining elements is a column vector of the same
     size as the dimension of the square matrix.
 - lis is a list of positive integers, each of which is less
   than or equal to the dimension of the square matrix in mats.
   The integers in lis specify the variables which are to be
   eliminated from the equation matrix.variables=vector.

Returned Value:
 - If mats is a matrix, then MATRIX_ELIM returns the matrix
   which would result from eliminating variables in positions
   indicated by the list of integers lis.
 - If mats is a list, then MATRIX_ELIM returns a list consisting
   of the matrix and vectors of mats after eliminating the
   variables.
   
Do EXAMPLE(MATRIX_ELIM); for an example.

See also MATRIX_ELIMINATE.

&MATRIX_ELIMINATE(mats, vec1, vec2)

[MATFUNCS package] Eliminates variables from linear matrix
equations, where the variables to be eliminated are specified
by the column vector vec2, whose elements must be a subset
of the elements of the column vector vec1.

For example, eliminating variable v2 from the equation

| m11  m12 |   | v1 |   | b1 |
|          | . |    | = |    |
| m21  m22 |   | v2 |   | b2 |

yields the matrix equation

| m11-m12.(m22^^-1).m21 | . | v1 | = | b1 | .

Arguments:
o mats is either 
  - a square matrix, or 
  - a list whose first element is a square matrix and each of 
    whose remaining elements is a column vector of the same
    size as the dimension of the square matrix.
o vec1 is either
  - a list of variables of the same length as the dimension of
    the square matrix in mats, or
  - a column vector of the same size as the dimension of the
    square matrix in mats.
o vec2 is either
  - a list of variables, each element of which is also an 
    element of vec1, or
  - a column vector, each element of which is also an
    element of vec1.  vec2 consists of the variables which
    are to be eliminated from the equation matrix.var1=vector.

Returned Value:
o If mats is a matrix, then MATRIX_ELIMINATE returns the matrix
  which would result from eliminating variables in vec2.
o If mats is a list, then MATRIX_ELIMINATE returns a list
  consisting of the matrix and vectors of mats after
  eliminating the variables in vec2.
   
Do EXAMPLE(MATRIX_ELIMINATE); for an example.

See also MATRIX_ELIM. 

&MATRIX_EXP(mat, var)

Computes the matrix exponential of mat, which should be a square
matrix.  var evaluates to a symbol.  This function returns
EXP(MAT*VAR), or FALSE if it is unsuccessful.

Do USAGE(MATRIX_EXP); for more information.

Do EXAMPLE(MATRIX_EXP); for an example and DEMO(MAT_EXP); for a
longer demonstration.

For rotation matrices in 2 and 3 dimensions, see ROTMAT2, 
ROTMAT3, ROTMATX, ROTMATY, ROTMATZ.

&MATRIX_EXP_EXACT default:ALL

Controls the way in which MATRIX_EXP factors the characteristic
polynomial of the matrix.
 - When TRUE, the polynomial is factored exactly using
   GFACTOR, and if the factorization is not successful
   then the program returns FALSE.
 - When MATRIX_EXP_EXACT is FALSE, an approximate
   factorization of the characteristic polynomial is
   obtained by means of ALLROOTS.
 - When MATRIX_EXP_EXACT is ALL then the program attempts
   to find the exact result, but if this is not possible
   then it returns an approximate one.

&MATRIX_EXP_STATUS

A global status variable in the MATEXP package.  It returns EXACT if
the returned result is exact or if the approximate method is
inappropriate, and APPROXIMATE otherwise.

&MATRIX_FUN(mat, fcn)
 or
MATRIX_FUN(fcn, mat)

Numerical function of a square real, symmetric, positive definite
matrix mat. As an example, MATRIX_FUN(A, cos) is the matrix cosine
function. MATRIX_FUN depends on finding the numerical Singular Value
Decomposition of mat.  Because mat is real, symmetric and positive
definite, the SVD is numerically stable.

Do EXAMPLE(MATRIX_FUN) for an example.

See also MAT_FUNM, SVD_NUMERICAL, MAT_SQRT.

&MATRIX_GCD(mat {, gcdtype})

[Matfuncs package] Pulls out the GCD of the elements of the 
matrix mat.  Returns the GCD as a scalar coefficient times
the matrix/GCD, without carrying out the scalar-matrix 
multiplication.

The optional argument gcdtype can be either 'SYNTACTIC_GCD
(the default) or 'EZGCD.  

Do EXAMPLE(MATRIX_GCD); for an example.

See also MATRIX_GCDLIST.

&MATRIX_GCDLIST(mat {, gcdtype})

[Matfuncs package] Pulls out the GCD of the elements of the 
matrix mat.  Returns a list whose first element is the GCD 
and whose second element is the matrix/GCD.

The optional argument gcdtype can be either 'SYNTACTIC_GCD
(the default) or 'EZGCD.  

Do EXAMPLE(MATRIX_GCDLIST); for an example.

See also MATRIX_GCD.

&MATRIX_LIST2POLY(coeflist_or, Mat_or)

Returns a polynomial evaluated at a matrix argument.   The polynomial
is given as a list of coefficients in order of decreasing powers of
the polynomial variable.  The first input may be a vector or scalar,
and the second is treated as a 1x1 matrix if it is a scalar.  This
function is inverse to the action of POLY2LIST applied to a matrix.
This function also has the name MAT_POLYVALM.

See also LIST2POLY, POLY2LIST, MATRIX_POLY.

&MATRIX_POLY(poly, mat)

Calculates a polynomial of a matrix argument. The constant term, if
any, is interpreted as a constant times the identity matrix.  The
matrix mat is assumed to be a square matrix.  The polynomial is
assumed to be univariate, although symbolic coefficients are allowed.
Both mat and poly are assumed to be real.

Do EXAMPLE(MATRIX_POLY); for an example.

See also MATRIX_LIST2POLY, MATRIX_FUN, MAT_FUNM.

&MATRIX_SUMMARY

Macsyma performs many kinds of matrix operations. 

Matrix multiplication is effected by using the dot operator, "."
(which is also used to represent general non-commutative algebraic
operations).  The exponential of the "."  operator is "^^" .  Thus,
for a matrix A, A . A = A^^2 and, if it exists, A^^-1 is the inverse
of A.

The operations +,-,*,^ are all element-by-element operations; all
operations are normally carried out in full, including the . (dot)
operation.  Many switches exist for controlling simplification rules
involving dot and matrix-list operations.

You can enter the MathHelp topic browser category LINEAR ALGEBRA or
MATRICES (at the top of the Macsyma window) to get lists of subtopics
and common commands.  For each command listed, you can obtain a
description and an executable example.

Matrix operations include

Defining matrices
-----------------

  - general commands: AUGCOEFMATRIX, COEFMATRIX, COPYMATRIX,
      ENTERMATRIX, GENMATRIX, GENVECTOR, MATRIX,
  - Defining a matrix element: SETELMX, SET_ELEMENT,
  - Extracting parts of matrices: COL, ROW, MINOR, SUBMATRIX,
      matrixname[i,j]
  - Enlarging a matrix: ADDCOL, ADDROW
  - Mapping a function over a matrix: MATRIXMAP
  - Evaluating a polynomial with a matrix argument: MATRIX_POLY
  - Evaluating a function with a matrix argument: MAT_FUNM,
      MATRIX_FUN
       
Generation of special matrices
------------------------------

    CAUCHY, CIRCULANT, COMPANION, DIAG_MATRIX, DIAGMATRIX, EMATRIX,
    HADAMARD, HILBERT, IDENT, HANKEL, TOEPLITZ, VANDERMONDE,
    ZEROMATRIX 

Basic matrix algebra operations
-------------------------------

  - Matrix multiplication: "." , "^^"
  - Determinants: CHARPOLY, NCHARPOLY, DETERMINANT,
      DETERMINANT_BY_LU, NEWDET, DETOUT, SPARSE, PERMANENT 
  - Matrix norms: MAT_NORM
  - Inverses and related functions: "^^" , ADJOINT, ECHELON, 
      INVERT, INVERT_BY_LU, INVERT_BY_LDU, INVERT_BY_CHOLESKY,
      INVERT_TOEPLITZ, INVERT_HANKEL, MAT_LDIV, MAT_RDIV, 
      PINV, MAT_NORM, INVERT_PSYMHANKEL, INVHILBERT,
      SHERMAN_MORRISON, WOODBURY
  - Rank and related functions: RANK, NULLSPACE, TRIANGULARIZE,
      MATRIX_TRACE
  - TRANSPOSE, "^`", "^*", "^~`", "^~*"
  - Extracting rows and columns: ROW, COL, ROWS, COLS
  - Swapping rows and columns: SWAP_ROWS, SWAP_COLS

Eigenanalysis
-------------

  - Symbolic: EIGENVALUES, EIGENVECTORS
  - Numerical: EIGENVALUES_BY_SCHUR, EIGENS_BY_SCHUR,
    EIGENS_BY_JACOBI
  - Matrix exponentiation: MATRIX_EXP

Normal forms
------------

  - LU decomposition: LU_DECOMP, LU_BACKSUB, LU_DECOMP_SYMB,
      LU_BACKSUB_SYMB
  - LDU decomposition: LDU_DECOMP
  - QR decomposition: QR_DECOMP
  - Cholesky factorization: CHOLESKY_DECOMP
  - Jordan normal form: JORDAN_FORM
  - Schur form: SCHUR_FORM
  - Singular value decomposition: SVD, MAT_SVD, SVD_NUMERICAL

Solving matrix equations
------------------------

  - Linear algebraic equations: MATLINSOLVE, MATSOLVE, 
      MATSOLVE_BY_LU, MATSOLVE_BY_CHOLESKY, MATSOLVE_BY_SVD,
      IMPROVE_LU_SOLVE, SOLVE_L1XY, SOLVE_TOEPLITZ
  - Linear matrix ODEs: ODEMATSYS, TRANSFER_MATRIX
  - Eliminate variables from matrix equations:
    MATRIX_ELIM, MATRIX_ELIMINATE.

Sparse matrix utilities
-----------------------

  - SPARSE
  - Banded matrix utilities: BANDMAT package

Assorted matrix functions
-------------------------

  - in package MATFUNCS
  - Predicates which check for matrices: MATRIXP, SQUARE_MATRIXP,
      VECTORP 
  - Also do APROPOS(MAT_); for a list of commands, most 
    of which are matrix utility commands.

Customized control of matrix operations 
---------------------------------------

  - DOMXEXPT, DOMXMXOPS, DOMXNCTIMES, DOSCMXOPS, DOSCMXPLUS
  - LISTARITH, RATMX, SCALARMATRIXP
  - MATRIX_ELEMENT_ADD, MATRIX_ELEMENT_MULT, 
    MATRIX_ELEMENT_TRANSPOSE
    

Do USAGE(MATRICE); for information about specialized matrix
structures in Macsyma.

Do USAGE(MATLAB_TRANSLATOR); for information about the 
Matlab-to-Macsyma translator.

For demonstrations, do
 DEMO(MATRIX);   (general introduction)
 DEMO(MATRIX1);  (altering matrix operations)
 DEMO(MATRIX2);  (block structured matrices)

See topic DEMOS_LINEAR_ALGEBRA for a larger list of matrix
demonstrations.

&MATRIX_TRACE(mat)

Returns the trace [sum of the elements on the main diagonal] of the
matrix mat.

Do EXAMPLE(MATRIX_TRACE); for an example.

See also MATRIX_SUMMARY.

&MATRIXLIKEP(input)

Returns TRUE for matrices, lists, and scalars, as all of these can be
regarded as special cases of matrices.

Do EXAMPLE(MATRIXLIKEP); for an example.  

See also ASSUMESCALARP, MAT_RAISE.

&MATRIXMAP(fn, mat)

Maps the function fn onto each element of the matrix mat.

Do EXAMPLE(MATRIXMAP); for an example. 

See also MAP, MAPLIST, MATRIX_SUMMARY.

&MATRIXP(exp)

Returns TRUE if exp is a matrix else FALSE.

See also MATRIX_SUMMARY, PREDICATES.

&MATSOLVE([matrix_equation], [vector_variable])

[MATSOLVE package] Solves a linear matrix equation for the
vector_variable in a manner analogous to SOLVE.  The equations can be
matrix, vector, or scalar equations and the variables can be either
vectors, matrices, or scalars.  MATSOLVE can be given single matrix
equation without brackets as well as single matrix variables.
MATSOLVE returns a list of solution equations, with matrices in the
original form. 

Do USAGE(MATSOLVE); for more information.

Do EXAMPLE(MATSOLVE); for an example, and DEMO(MATSOLVE); for a
longer demonstration.

For symbolic problems, see MATSOLVE_BY_LU_SYMB. For floating point
problems, see MATSOLVE_BY_LU and MATSOLVE_BY_SVD.  See also MATLINSOLVE,
SOLVE, MATRIX_SUMMARY, IMPROVE_LU_SOLVE.

&MATSOLVE_BY_CHOLESKY(A, B)

Solves the numerical matrix equation A X = B for X using the Cholesky
factorization of A (which needs to be square, positive definite and
Hermitian).

Do EXAMPLE(MATSOLVE_BY_CHOLESKY); for an example.

See also CHOLESKY_DECOMP, MATSOLVE_BY_SVD.

&MATSOLVE_BY_LU(A, B)

Solves the numerical matrix equation A X = B for X using the LU
factorization of A (which needs to be square).

Do EXAMPLE(MATSOLVE_BY_LU); for an example and DEMO(LU); for a
longer demonstration.

See also MATSOLVE_BY_LU_SYMB, LU_DECOMP_SYMB, LU_BACKSUB_SYMB,
INVERT_BY_LU, MATSOLVE, MATLINSOLVE, MATSOLVE_BY_SVD, IMPROVE_LU_SOLVE,
MATSOLVE_BY_LU_SYMB and INVERT_BY_LU_SYMB.

&MATSOLVE_BY_LU_SYMB(A, B)

Solves the symbolic matrix equation A X = B for X using the LU
factorization of A (which needs to be square).

For symbolic linear equations, LU solution methods are often much faster
than other methods, but yield more complicated results which are not
as well formatted.

Do EXAMPLE(MATSOLVE_BY_LU_SYMB); for an example.

See also LU_DECOMP_SYMB, LU_BACKSUB_SYMB, MATSOLVE_BY_LU,
CHOLESKY_DECOMP_SYMB.

&MATSOLVE_BY_SVD(A, B {, TOL})

Solves the numerical matrix equation A X = B for X using the Singular
Value Decomposition of A. A may be singular, or stiff (large condition
number). Also, A need not be square. A and B must have numbers only
(not bfloats). TOL (default:[DFLOAT_EPSILON * MAT_NROWS(A)]) is an
optional argument to specify when a Singular Value of A is 0. When A
is invertible, MATSOLVE_BY_SVD and MATSOLVE_BY_LU produce equivalent
answers.

When B is not a vector, but is a Matrix, then MATSOLVE_BY_SVD solve
the matrix equation A. XX = B for the matrix XX using the SVD of A.

Do EXAMPLE(MATSOLVE_BY_SVD); for a longer illustration.

See also MATSOLVE_BY_LU, MATSOLVE_BY_CHOLESKY, SVD, SVD_NUMERICAL,
LSQ_LINSOLVE, LSQ_LINSOLVE_BY_SVD.

&MATSYMDEFSOLVE

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MATSYMDEFSOLX

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MATSYMDEFSUBST

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MATSYMDEFSUBSTX

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MATSYMINDSOLVE

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MATSYMINDSOLX

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MATSYMINDSUBST

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MATSYMINDSUBSTX

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MATSVD

NUMKIT routine

See USAGE(NUMKIT); for more information.

&MAX(X1, X2, ...)

Returns the maximum of its arguments (or returns a simplified form if
some of its arguments are non-numeric).

MAX also finds the maximum of a list when called with one argument:
MAX([X1,X2,...,Xn]) .

Do EXAMPLE(MAX); for an example.

See also MAT_MAX, MIN.

&MAXAPPLYDEPTH default:10000

The maximum depth to which APPLY1 and APPLY2 will delve.

&MAXAPPLYHEIGHT default:10000

The maximum height to which APPLYB1 will reach before giving up.

&MAXNEGEX default:1000

The largest negative exponent which will be expanded by the EXPAND
command.

See also MAXPOSEX.

&MAXPOSEX default:1000

The largest exponent which will be expanded with the EXPAND command.

See also MAXNEGEX.

&MAXPSIFRACDENOM default:9999

Controls simplification of PSI[0](P/Q) for P and Q integers and 0 <
P/Q < 1 (i.e. the fractional part of arguments).  The largest Q for
which simplification occurs.

See also POLYGAMMA.

&MAXPSIFRACNUM default:9999

Controls simplification of PSI[0](P/Q) for P and Q integers and 0 <
P/Q < 1 (i.e. the fractional part of arguments).  The largest P for
which simplification occurs.

See also POLYGAMMA.

&MAXPSINEGINT default:-9999

For negative X > MACPSINEGINT no closed forms will be computed.

See also POLYGAMMA.

&MAXPSIPOSINT default:9999

The largest value of the integer part of X for which a closed form
will be computed.

See POLYGAMMA.

&MAXTAYORDER default:TRUE

If TRUE, then during algebraic manipulation of (truncated) Taylor
series, TAYLOR will try to retain as many terms as are certain to be
correct.

&MAXWELL_DENSITY(x, beta)

[UNIPROB package] The Maxwell density function is

  4/(sqrt(%PI)*beta^3) * x^2 *EXP(-(x/beta)^2).

See also MAXWELL_DISTRIB.

&MAXWELL_DISTRIB(x, beta)

[UNIPROB package] The Maxwell distribution function is

 ERF(x/beta) -2*x*EXP(-(x/beta)^2/(sqrt(%PI)*beta) .

See also MAXWELL_DENSITY, INV_MAXWELL_DISTRIB.

&MAYBE(pred)

Attempts to determine whether the specified predicate is provable from
the facts in the current database. MAYBE returns TRUE if the predicate
is true for all values of its variables consistent with the database
and returns FALSE if it is false for all such values.  Otherwise, it
returns UNKNOWN.  The UNKNOWN mode is not supported in translated
code.

Do EXAMPLE(MAYBE); for an example.

See also PREDERROR and IS.

&MCHARPOLY_VAR default:%LAMBDA

[MATRICE package] Is the variable in which MEIGENVALUES will express
the residual polynomial if this function is called with a matrice as
the argument.

See also EIGENVALUES.

&MEAN

See SAMPLE_MEAN.

&MEDIAN

See SAMPLE_MEDIAN.

&MEDIT(exp)

Invokes the old Macsyma editor on exp.  exp is optional and defaults
to the previously edited value, or to the last thing which was saved
by INPUT_SAVE if that was more recent.  See EDITOR for more
information on the old Macsyma editor.

In Macsyma 419 and successors, the Input Editor can be opened from the
menus at the top of the screen, or by typing control-E.

&MEDIT_PROMPT, default:"->"

Is the prompt used by Macsyma while in the editor.

&MEIGENVALUES(A {, lambda})

[MATRICE package] Computes the eigenvalues of the matrice A or of the
characteristic polynomial p written in terms of the variable lambda.
MEIGENVALUES returns as its value a list containing two sublists.  The
first sublist specifies the eigenvalues determined, while the second
lists their corresponding multiplicities.  If the characteristic
polynomial of A (or p) is not completely factorable then the list of
multiplicities will be followed by the residual polynomial that
results from removing the solvable factors from the characteristic
polynomial.  The residual polynomial will be expressed in terms of the
variable MCHARPOLY_VAR if MEIGENVALUES is called with a matrice as the
argument.  MEIGENVALUES by default uses SOLVE to find the roots of the
characteristic polynomial and so deficiencies in SOLVE can affect the
results returned by this function.

See also EIGENMETHOD, NUMEIGS, MVERBOSE, MATRICE, MCHARPOLY,
EIGENVALUES.

&MEMBER(exp, list)

Returns TRUE if exp occurs as a member of list (not within a member).
Otherwise FALSE is returned.  Member also works on non-list
expressions, e.g. MEMBER(B, F(A,B,C)); -> TRUE.

Do EXAMPLE(MEMBER); for an example.

See also SET.

&MERGE_PLOT_FILES([infile1, infile2])
 or
MERGE_PLOT_FILES([infile1,infile2,...], outfile)
 or 
MERGE_PLOT_FILES([[infile1,[[tx,ty,tz],[sx,sy,sz]]],infile2], outfile) 

(Macsyma 419 and successors) Merges plot files into a new file. The
resulting image is an overlay of the input plots using range and
perspective information from the aggregate. This function takes 1
required and 1 optional argument.

The required first argument is a list of infile entries. Each entry 
may be either the name of a file or a list consisting of a filename
followed by a transformation list. The transformation list consists of
a translation and a scaling, each specified by a list of 3 floating
point numbers, one for each axis. The effect is to transform the infile
data first by the translation then by the scaling, before merging it in
the outfile. The default translation is [0,0,0] and the default scaling
is [1,1,1].

The optional second argument, outfile, is specified as a file name or
file pathname in double quotation marks. If not supplied, outfile
defaults to PLOT_FILE.  When file names are used without pathnames,
Macsyma assumes that the files are located in the directory PLOT_DIRECTORY
(which defaults to "macsyma:plots;") with a filetype of PLOT_FILE_TYPE
(which defaults to "plt").

Available only in some versions of Macsyma.  See PLOTTING_SUMMARY for
more information.

See PLOTTING_SUMMARY for a summary of the plotting capabilities
in Macsyma.

&METRIC

[ITENSOR package] This function has been renamed IMETRIC.

&METRICCONVERT

[ITENSOR package] Option variable which affects the command IC_CONVERT
which converts ITENSOR equations to CTENSOR assignment statements.  If
TRUE, causes all occurrences of the metric (in an ITENSOR equation) to
be renamed LG or UG (which are the names of the covariant and
contravariant forms of the metric tensor in CTENSOR).

&MFE

MFE is the Macsyma Front End User Interface. MFE supoports notebooks with
reexecutable sections, graphics, text sections and DataViewers.

See also MFE_ENABLED_P, MFE_GET, MFE_PUT, MFE_UPDATE_NOW.


&MFE_ENABLED_P()

Returns TRUE if the user interface supports the Macsyma Front End (MFE) 
and FALSE otherwise.

&MFE_GET(mfe_name {, macs_name})

Places data from the MFE array mfe_name into the Macsyma environment.  

  mfe_name       macs_name    Result
  --------       ---------    ------
  MFE scalar     (ignored)    returns a scalar
  1D MFE array   not given    returns a list filled with values from MFE
  2D MFE array   not given    returns a matrix filled with values from MFE
  >2D MFE array  not given    returns nested list structure
  MFE array      given        fills array macs_name with data from MFE,
                              and returns the array name macs_name.

See also MFE_PUT.

&MFE_KILL(mfe_var)

Deletes the MFE variable mfe_var.

&MFE_PUT(macs_name, mfe_name)

Places data from Macsyma into an MFE array.  

  macs_name      Result
  ---------      ------
  scalar         Assigns scalar value to mfe_name
  list           Creates 1D MFE array
  matrix         Creates 2D MFE array
  array          Creates corresponding MFE array 

See also MFE_GET.

&MFE_UPDATE_NOW()

Updates DataViewers and graphics of MFE variables.

&MIN(X1, X2, ...)

Returns the minimum of its arguments (or returns a simplified form if
some of its arguments are non-numeric).

MIN also finds the minimum of a list when called with one argument:
MIN([X1,X2,...,Xn]) .

Do EXAMPLE(MIN); for an example.

See also MAT_MIN, MAX.

&MIN_BRACKET(XA, XB, F)

[MINFUNC package] Given univariate real-valued function F and two
distinct initial points XA and XB, MIN_BRACKET returns three points
[XA,XB,XC] which bracket a minimum of the function.  This means that
these conditions are satisfied:

 (XA < XB < XC or XA > XB > XC) and  F(XB) < F(XA) and F(XB) < F(XC).

The routine also returns the values of F at the three points,
returning the list [[XA,XB,XC],[F(XA),F(XB),F(XC)]] .

If the inputs to MIN_BRACKET are given as double-precision numbers,
then the bracketing values are returned in double precision.

Do EXAMPLE(MIN_BRACKET); for an example.

See also MIN_FUNCTION, MIN_DFUNCTION, which utilize the output of
MIN_BRACKET to isolate minima of functions.

&MIN_FUNCTION(XA, XB, XC, F)

[MINFUNC package] Finds a minimum of a univariate scalar function F by
Brent's method, starting with a bracketing triple of points
[XA,XB,XC], such as is produced by MIN_BRACKET. 

 If VERBOSE=TRUE then each intermediate guess [XMIN,F(XMIN)] is
printed on each iteration.

If the inputs to MIN_FUNCTION are given as double-precision numbers,
then the bracketing values are returned in double precision.

Do EXAMPLE(MIN_FUNCTION); for an example.

See also MIN_DFUNCTION.

&MIN_DFUNCTION(XA, XB, XC, F, DF)

[MINFUNC package] Finds a minimum of a univariate scalar function F by
Brent's method using the derivative DF, starting with a bracketing
triple of points [XA,XB,XC], such as is produced by MIN_BRACKET.  If
VERBOSE=TRUE then each intermediate guess [XMIN,F(XMIN)] is printed on
each iteration.

If the inputs to MIN_DFUNCTION are given as double-precision numbers,
then the bracketing values are returned in double precision.

Do EXAMPLE(MIN_DFUNCTION); for an example.

See also MIN_FUNCTION.

&MINCLINELEN default:40

[GENTRAN package] Specifies the minimum number of characters printed
on each line of C code generated by the GENTRAN or GENTRANIN commands.

&MINF

Real minus infinity.

See also INF, INFINITY.

&MINFACTORIAL(exp)

Examines exp for occurrences of two factorials which differ by an
integer.  It then turns one into a polynomial times the other.  If exp
involves binomial coefficients then they will be converted into ratios
of factorials.

 (c1) N!/(N+1)!;
                                     n!
 (d1)                             --------
                                  (n + 1)!

 (c2) MINFACTORIAL(%);
                                      1
 (d2)                               -----
                                    n + 1

Do EXAMPLE(MINFACTORIAL); for an example.

&MINFORTLINELEN default:40

[GENTRAN package] Specifies the minimum number of characters printed
on each line of FORTRAN code generated with the GENTRAN or GENTRANIN
command.

&MINFUNC

A package for finding the minima of real-valued univariate functions
using numerical methods.  The main commands are:

 - MIN_FUNCTION for finding the minimum of a function,
 - MIN_DFUNCTION for finding the minimum of a function when you
   can compute its derivative,
 - MIN_BRACKET for bracketing a minimum in a range.

Do USAGE(MINFUNC); for more information.

Do DEMO(MINFUNC); for a demonstration.

For finding critical points of functions symbolically, see the OPTMIZ
package.  

For numerical roots of functions, see ALLROOTS, NROOTS, REALROOTS,
NEWTON, ROOT_BY_BISECTION and ROOTS.

&MINOR(M, i, j)

Computes the i,j minor of the matrix M.  That is, M with row i and
column j removed.

Do EXAMPLE(MINOR); for an example.

See also MATRIX_SUMMARY.

&MINRATLINELEN default:40

[GENTRAN package] Specifies the minimum number of characters printed
on each line of Ratfor code generated by the GENTRAN or GENTRANIN
commands.

&MOD(poly {, m})

Converts the polynomial poly to a modular representation with respect
to the current modulus which is the value of the variable MODULUS.

MOD(poly, m)
  Specifies a MODULUS m to be used for converting poly, if it is
  desired to override the current global value of MODULUS.

Do EXAMPLE(MOD); for an example.

See also MODULUS, NUMMOD.

&MODE

See SAMPLE_MODE.

&MODFFT(array1, direction)

[FFT package] Returns the integer FFT of array1 modulo 2^16+1.

Do USAGE(FFT); for more information.

Do EXAMPLE(MODFFT); for an example.

&MODE_CHECKP default:TRUE

If TRUE, MODE_DECLARE checks the modes of bound variables.

&MODE_CHECK_WARNP default:TRUE

If TRUE, mode errors are described.

&MODE_CHECK_ERRORP default:FALSE

If TRUE, MODE_DECLARE calls error.

&MODE_DECLARE(y1, mode1, y2, mode2, ...)

MODEDECLARE is a synonym for this.  MODE_DECLARE is used to declare
the modes of variables and functions for subsequent translation or
compilation of functions.  Its arguments are pairs consisting of a
variable yi, and a mode which is one of BOOLEAN, FIXNUM, LIST, NUMBER,
RATIONAL, or FLOAT.  Each yi may also be a list of variables all of
which are declared to have modei.

If yi is an array, and if every element of the array which is
referenced has a value then ARRAY(yi, COMPLETE, dim1, dim2, ...)
rather than ARRAY(yi, dim1, dim2, ...) should be used when first
declaring the bounds of the array.  If all the elements of the array
are of mode FIXNUM (FLOAT), use FIXNUM (FLOAT) instead of COMPLETE.
Also if every element of the array is of the same mode, say m, then
MODE_DECLARE(COMPLETEARRAY(yi),m)) should be used for efficient
translation.  Also numeric code using arrays can be made to run faster
by declaring the expected size of the array, as in:

MODE_DECLARE(COMPLETEARRAY(A[10,10]),FLOAT)

for a floating point number array which is 10 x 10.

Additionally one may declare the mode of the result of a function by
using FUNCTION(F1,F2,...) as an argument; here F1,F2,... are the names
of functions.  For example, the expression

MODE_DECLARE([FUNCTION(F1,F2,...),X],FIXNUM,Q,COMPLETEARRAY(Q),FLOAT)

declares that X and the values returned by F1,F2,... are single-word
integers and that Q is an array of floating point numbers.
MODE_DECLARE is used either immediately inside of a function
definition or at top-level for global variables.  

Do EXAMPLE(MODE_DECLARE); for some examples.

See also MODE_IDENTITY.

&MODE_IDENTITY(arg1, arg2)

A special form used with MODE_DECLARE and MACROS to delcare, e.g., a
list of lists of flonums, or other compound data object.  The first
argument to MODE_IDENTITY is a primitive value mode name as given to
MODE_DECLARE (i.e. [FLOAT,FIXNUM,NUMBER, LIST,ANY]), and the second
argument is an expression which is evaluated and returned as the value
of MODE_IDENTITY.  However, if the return value is not allowed by the
mode declared in the first argument, an error or warning is signaled.
The important thing is that the MODE of the expression as determined
by the Macsyma to Lisp translator, will be that given as the first
argument, independent of anything that goes on in the second argument.

Example:

  X:3.3; MODE_IDENTITY(FIXNUM,X); yields an error.

  MODE_IDENTITY(FLONUM,X) returns 3.3 .

This has a number of uses, e.g., if you knew that FIRST(L) returned a
number then you might write MODE_IDENTITY(NUMBER,FIRST(L)).  However,
a more efficient way to do it would be to define a new primitive,
FIRSTNUMB(X)::=BUILDQ([X],MODE_IDENTITY(NUMBER,X))$ and use FIRSTNUMB
every time you take the first of a list of numbers.

&MODRESULT

This switch is obsolete.  The RESULTANT switch should be used.

&MODULUS default:FALSE

If set to a positive prime p, then all arithmetic in the rational
function routines will be done modulo p.  That is all integers will be
reduced to less than p/2 in absolute value (if p=2 then all integers
are reduced to 1 or 0).  This is the so called "balanced" modulus
system, e.g. N MOD 5 = -2, -1, 0, 1, or 2.  Warning:  If EXP is
already in CRE form when you reset MODULUS, then you may need to
re-rat EXP, e.g. EXP:RAT(RATDISREP(EXP)), in order to get correct
results.  If MODULUS is set to an even number, then RAT(N); gives a
value in {-N/2+1, ..., N/2} for N an integer.  E.g., when MODULUS is
4, RAT(N); can give one of {-1, 0, 1, 2}.

If MODULUS is set to a positive non-prime integer, this setting will be
accepted, but a warning will be given.  An error is generated if MODULUS
is set to 1, 0 , a negative integer, or a non-integer.

See also MOD, MODULUS_WARN, NUMMOD.

&MODULUS_WARN default:FALSE

If set to FALSE, suppresses the warning about setting MODULUS to a
non-prime.

&MOEBIUS_MU(integer)

Returns 1 if integer is the product of an even number of distinct
primes; -1 if an odd number; and 0 if divisible by any square besides
1.

&MOLECULAR_MASS(expr)

Returns the molecular mass in a.m.u. of the chemical compound whose
composition is represented by expr, where expr is a linear combination
of atomic symbols with numerical coefficients.

Do EXAMPLE(MOLECULAR_MASS); for an example.

See also ATOMIC_MASS, ATOMIC_NUMBER, PERIODIC_TABLE, 
PHYSICAL_CONSTANTS.

&MOORE_PENROSE_INVERSE(matrix)

The current name for this command is PINV. 

&MORE Processing

The term used to describe the action of a CRT console when it stops at
the bottom of the screen to allow the user to finish reading.  See
PAGEPAUSE and MOREWAIT for more information.

&MOREWAIT default:FALSE

Controls the action of more processing.  In its default FALSE setting,
a space typed at --More Display?-- will continue the display, a rubout
(or delete) will flush the display of the expression (to both the
terminal and any WRITEFILE which is open) and anything else will flush
only output to the terminal.  Type-ahead is allowed (i.e. you can
begin typing the next command-line and the display to the console will
be flushed and your typing will be saved and put on the C-line).
"carriage return" is frequently used for this last function of just
flushing the output to the terminal.  If MOREWAIT is set to TRUE, then
space and rubout work as above, but only carriage return is enabled to
flush display to the terminal, and type-ahead is ignored.  If
MOREWAIT is set to ALL, then only space (to continue output) and
carriage return (to flush it) are enabled, and any other characters
(including rubout) are ignored.  This may be useful for users on noisy
connections where rubouts transmitted by the phone line sometimes
flush output accidentally.

&MOST_NEGATIVE_DFLOAT

Returns the double float number in the current implementation of
Macsyma closest to negative infinity.

See also MOST_POSITIVE_DFLOAT, MOST_NEGATIVE_SFLOAT.

&MOST_NEGATIVE_FIXNUM

Returns the negative fixnum in the current implementation of
Macsyma with the greatest magnitude.

See also MOST_POSITIVE_FIXNUM.

&MOST_NEGATIVE_FLOAT

A synonym for MOST_NEGATIVE_SFLOAT.

&MOST_NEGATIVE_SFLOAT

Returns the floating point number in the current implementation
of Macsyma which is closest to negative infinity.

See also MOST_POSITIVE_SFLOAT, MOST_NEGATIVE_DFLOAT.

&MOST_POSITIVE_FIXNUM

Returns the positive fixnum in the current implementation of Macsyma
with the greatest magnitude.

See also MOST_NEGATIVE_FIXNUM.

&MOST_POSITIVE_DFLOAT

Returns the double float number in the current implementation of
Macsyma closest to positive infinity.

See also MOST_NEGATIVE_DFLOAT, MOST_POSITIVE_SFLOAT.

&MOST_POSITIVE_FLOAT

A synonym for MOST_POSITIVE_SFLOAT.

&MOST_POSITIVE_SFLOAT

Returns the floating point number in the current implementation of
Macsyma which is closest to positive infinity.

See also MOST_NEGATIVE_SFLOAT, MOST_POSITIVE_DFLOAT.

&MSCALES

Library package for finding approximate symbolic solutions to ordinary
differential equations by the method of multiple scales.  The main
function in the package is MULTIPLE_SCALES(eqs, vars, indep_var,
perturb_var, order).

Do USAGE(MSCALES); for more information, and DEMO(MSCALES); for a
demonstration.

For other perturbation methods for ODE's, see also AVG_PODE,
LINDSTEDT.

&MULTILINEAR - one of the OPPROPERTIES

Makes the simplifier treat a function as multilinear with respect to
constants or scalars, in some or all of its arguments, and have
automatic simplification in a manner analogous to the LINEAR property,
except that it applies to more than one argument and it uses a SCALARP
test instead of CONSTANTP when bringing factors out.  MULTILINEAR is
asserted via DECLARE.  The OUTATIVE property for MULTILINEAR will
bring factors with the SCALAR property (this includes CONSTANTs)
outside of the body of the function.

Do USAGE(MULTISMP); for more information.

Do EXAMPLE(MULTILINEAR); for an example, and DEMO(MULTISMP); for a
longer demonstration.

&MULTINOMIAL({n1, n2,..., nk})

[Algfuncs package] Returns the multinomial coefficient
(n1+..+nk)!/(n1!*...*nk!) . 

Do EXAMPLE(MULTINOMIAL); for an example.

&MULTIPLE_SCALES(eqs, vars, indep_var, perturb_var, order)

Finds approximate symbolic solutions to ordinary differential
equations by the method of multiple scales.  It is contained in the
package MSCALES.

Do USAGE(MSCALES); for more information.

Do DEMO(MSCALES); for a demonstration.

&MULTIPLICATIVE - one of the OPPROPERTIES

Can be asserted with DECLARE, withdrawn with REMOVE, and detected with
GETPROP.  If DECLARE(F,MULTIPLICATIVE) has been executed, then:

(1) If F is univariate, whenever the simplifier encounters F applied
    to a product, F will be distributed over that product.  I.e. F(X*Y);
    will simplify to F(X)*F(Y).

(2) If F is a function of 2 or more arguments, multiplicativity is
    defined as multiplicativity in the first argument to F, i.e.
    F(G(X)*H(X),X); will simplify to F(G(X),X)*F(H(X),X).
    This simplification does not occur when F is applied to expressions
    of the form PRODUCT(X[I],I,lower-limit,upper-limit).

Do EXAMPLE(MULTIPLICATIVE); for an example.

&MULTIPLICITIES default:NOT_SET_YET

Will be set to a list of the multiplicities of the individual
solutions returned by SOLVE or REALROOTS.

&MULTIPLY_CONJUGATES(expr) clears the radicals in expr by multiplying
by all its conjugates and expanding.  For example:

 (c1) X-2*SQRT(X+1)+(X+2)^(1/3);
                           1/3
 (d1)               (x + 2)    - 2 sqrt(x + 1) + x
 
 (c2) MULTIPLY_CONJUGATES(%);
            6       5       4       3       2
 (d2)      x  - 12 x  + 38 x  + 60 x  - 71 x  - 140 x - 60
 
 (c3) REALROOTS(%);
 (d3)                  [x = - 1, x = 1.7742649]
 
 (c4) MAKELIST(SUBST(Y,D1),Y,%);
 (d4)                          [0, 0.0]
 
Note that the resulting polynomial will usually gain "spurious"
roots which are not roots of expr.

Do EXAMPLE(MULTIPLY_CONJUGATES); for more examples.

&MULTIVARIATE_STATISTICS(data_matrix {, rcswitch})

Computes elementary population statistics for a square or nonsquare
matrix of data.  The input data_matrix is a matrix of floating point
sample data. Calculates row means, variances and row-row and
column-column correlations.

The optional argument rcswitch (default:ROWS) should have the value
ROWS, COLS or ALL.  MULTIVARIATE_STATISTICS stores the row and column
statistics in the option variables

  Variable      Stored information
  --------      ------------------
  row_means     List of means  of each row
  row_std_devs  List of standard deviations of each row
  col_means     List of means  of each column
  col_std_devs  List of standard deviations of each column
  row_row_corr  The row-row correlation matrix
  col_col_corr  The column-column correlation matrix

Do EXAMPLE(MULTIVARIATE_STATISTICS); for an example.

&MULTPROB

A package of multivariate probability density functions.

Do USAGE(MULTPROB); for more information.

Do DEMO(MULTPROB); for a demonstration.

&MULTTHRU(exp1 {, exp2})

Multiplies a factor (which should be a sum) of exp1 by the other
factors of exp1.  That is, exp1 is f1*f2*...*fn where at least one
factor, say fi, is a sum of terms.  Each term in that sum is
multiplied by the other factors in the product.  (Namely all the
factors except fi).  MULTTHRU does not expand exponentiated sums.
This function is the fastest way to distribute products (commutative
or noncommutative) over sums.  Since quotients are represented as
products MULTTHRU can be used to divide sums by products as well.

MULTTHRU(exp1, exp2) multiplies each term in exp2 (which should be a
sum or an equation) by exp1.  If exp1 is not itself a sum then this
form is equivalent to MULTTHRU(exp1*exp2).

Example:

 (c1) X/(X-Y)^2-1/(X-Y)-F(X)/(X-Y)^3;

                1        x         f(x)
 (d1)       - ----- + -------- - --------
              x - y          2          3
                      (x - y)    (x - y)

 (c2) MULTTHRU((X-Y)^3,%);

                     2
 (d2)       - (x - y)  + x (x - y) - f(x)

Do EXAMPLE(MULTTHRU); for an example.

See also DISTRIB, EXPAND.

&MVERBOSE default:FALSE

[MATRICE package] If TRUE, will cause comments about the progress of
various Matrice package functions (e.g., HESSENBERG) to be printed as
their execution proceeds.  If MVERBOSE is ALL, then very detailed
comments will be produced.  These latter comments provide detailed
information mainly for debugging purposes.

&MYOPTIONS default:[]

All options ever reset by the user (whether or not they get reset to
their default value).

&NAMEPLOT(plotname)

Names the plot created by the last call to one of the plotting
functions plotname. plotname must be either an atom or an array
element. plotname is added to the list PLOTS.

Available only in versions of Macsyma for Symbolics Lisp Machines.
See PLOTTING_SUMMARY for more information.

Do EXAMPLE(NAMEPLOT); for an example.

&NARY(oper {, bp, argpos, pos})

Defines the symbol oper to be a NARY operator. All arguments after
the first are optional; they are 
   bp   = binding power (default:180),
 argpos = left part of speech (default:ANY), 
   pos  = part of speech of the result (default:ANY).

An NARY (pronounced enn-ary) function or operator takes any number of
arguments.  Macsyma has a NARY command to create NARY operators, and
a NARY property which adds full associativity to functions and to NARY
operators.

Note: In Macsyma, the term "operator" refers to a function which is
represented by an operator symbol located between each consecutive
pair of its arguments, as in A + B or A * B * C.


NARY                                                     Opproperty

  DECLARE(oper, NARY) tells the simplifier to treat the function or
  operator oper as a fully associative function or operator.
  For example, G( G(A,B), G(C,D) )  simplifies to G(A, B, C, D).

  The property NARY is a member of the OPPROPERTIES list.  It can
  be asserted with DECLARE, withdrawn with REMOVE and detected with
  GETPROP.

Do USAGE(OPERATORS); for more information on defining operators.

Do EXAMPLE(NARY); for an example, and DEMO(OPERATORS); for a longer
demonstration.  

See also PREFIX, POSTFIX, INFIX, NOFIX, MATCHFIX.

&NCEXPT(A, B)

If an (non-commutative) exponential expression is too wide to be
displayed as A^^B it will appear as NCEXPT(A,B).

&NCHARPOLY(mat, var)

[NCHRPL package] Returns the characteristic polynomial of the matrix
mat with respect to var.  This is an alternative to CHARPOLY.
NCHARPOLY works by computing traces of powers of the given matrix,
which are known to be equal to sums of powers of the roots of the
characteristic polynomial.  From these quantities the symmetric
functions of the roots can be calculated, which are nothing more than
the coefficients of the characteristic polynomial.  CHARPOLY works by
forming the determinant of mat - var * IDENT(MAT_NROWS(mat)) .  Thus
NCHARPOLY is to be preferred, for example, in the case of large dense
matrices filled with integers, since it avoids polynomial arithmetic
altogether.

Do EXAMPLE(NCHARPOLY); for an example, and DEMO(NCHRPL); for a longer
demonstration.

See also CHARPOLY.

&NDIFF

The new partial differentiation package. The user-level commands are
CONVERT_TO_DE, NEWDIFF, and PDERIVOP.

Do USAGE(NDIFF); for more information.

Do DEMO(NDIFF); for a demonstration.

&NDIGITS(e)

[MATRICE package] Counts the number of digits comprising the integer
or rational number e.  If e is a rational number then NDIGITS will
return the ratio of the number of digits in the numerator to the
number of digits in the denominator.  If e is a list or a matrix,
NDIGITS will map itself onto the elements of the list or matrix.  This
function is useful when doing expression swell analyses.

Do EXAMPLE(NDIGITS); for an example.

Do DEMO(COMPLEXITY); for a demonstration.  See also COMPLEXITY.

&NEG_A_PART(exp, n1, ..., nk)

Changes a part to its negative.  Takes arguments like PART does.

Examples:

  EXP:(A-B)*(C-D)$ 
  NEG_A_PART(EXP,1); gives -(B-A)*(C-D)
  NEG_A_PART(EXP,2); gives -(A-B)*(D-C) .

See also NEG_A_SUBST.

&NEG_A_SUBST(sum, expr)

"Neg a subst of sum in expr".  

Example:
  NEG_A_SUBST(A-B, (A-B)^10001); gives -(B-A)^10001 .

See also NEG_A_PART.

&NEGATIVE_BINOMIAL_DENSITY(x, r, p)

[UNIPROB package] The negative binomial density function

  binomial(r+x-1,x)*p^r*(1-p)^x . 

&NEGATIVE_BINOMIAL_DISTRIB(x, r, p)

[UNIPROB package] The distribution function for the
NEGATIVE_BINOMIAL_DENSITY.

&NEGDISTRIB default:TRUE

When TRUE allows -1 to be distributed over an expression.  E.g. -(X+Y)
becomes -Y-X.  Setting it to FALSE will allow -(X+Y) to be displayed
like that.  This is sometimes useful but be very careful: like the
SIMP flag, this is one flag you do not want to set to FALSE as a
matter of course or necessarily for other than local use in your
Macsyma.

&NEGSUMDISPFLAG default:TRUE

When TRUE, X-Y displays as X-Y instead of as -Y+X.  Setting it to
FALSE causes the special check in display for the difference of two
expressions to not be done.  One application is that thus A+%I*B and
A-%I*B may both be displayed the same way.

&NEST_APPLY(func, expr, n)

[FUNCTS package] Returns the nth iterate of the function func 
applied to the argument expr. 

Example: 

 (c1) nest_apply(f, x, 2);
 (d1)                   f(f(x))

Do EXAMPLE(NEST_APPLY); for an executable example.

See also APPLY, NEST_APPLY_LIST.

&NEST_APPLY_LIST(func, expr, n)

[FUNCTS package] Returns a list of iterates of the function
func applied to the argument expr, up to the nth iterate.

Example:

 (c1) nest_apply_list(f, x, 2);
 (d1)             [ x, f(x), f(f(x)) ]

Do EXAMPLE(NEST_APPLY_LIST); for an executable example.

See also APPLY, NEST_APPLY.

&NEUMANN

Macsyma has two functions for computing spherical Neumann functions in
the SPECFUN package: SNEUMANN_N(N,X) and SNEUMANN_N[N](X).

&NEW_MAT_SUBSCR_MODE default:TRUE

Controls whether indices to 1-by-n and n-by-1 matrices return a matrix
element or a row of the matrix. For example:

                                   NEW_MAT_SUBSCR_MODE:
  Input                           TRUE             FALSE
  ---------------                ------           -------
  1-by-3 row matrix:
  matrix([a,b,c])[1];              a              [a,b,c]
  matrix([a,b,c])[1,1];            a                 a

  3-by-1 column matrix:
  matrix([a],[b],[c])[2];          b                [b]
  matrix([a],[b],[c])[2,1];        b                 b

  PART is unaffected.
  part(matrix([a,b,c]),1));     [a,b,c]           [a,b,c]

Do EXAMPLE(NEW_MAT_SUBSCR_MODE); for an example.

&NEWCONTEXT(name)

Creates a new (empty) context, called name, which has GLOBAL as its
only subcontext.  The new context created will become the currently
active context.

See CONTEXT for a general description of the context mechanism.

&NEWDET(mat {, n})

Computes the determinant of mat using the Johnson-Gentleman tree minor
algorithm.  mat may be the name of a matrix or array.  The argument n
is the order; it is optional if mat is a matrix.

Do EXAMPLE(NEWDET); for an example.

See also DETERMINANT.

&NEWDIFF default:FALSE (TRUE when NDIFF or OPALG are loaded)

[NDIFF and OPALG packages] The differentiation command DIFF calls the
new partial differentiation code if and only if NEWDIFF is set to
TRUE.

&NEWTON(fun, vars, start {, itmax})

[NEWTON package] Applies Newton's method to n-variate functions FUN of
n variables VARS from initial starting point START.  The number of
iterations, ITMAX, is optional, and defaults to 25.  If the residual
is less than the tolerance specified by the option variable NEWTON_TOL
(see below) then the point is returned; otherwise, an error is
generated.  Any non-floating components of START are SFLOATed prior to
iteration.  If any of the starting values is a bigfloat, then the
problem is solved using bigfloats.  Similarly for double floats. 

You can control aspects of NEWTON with the option variables
NEWTON_EVAL_JACOBIAN, NEWTON_TOL, and NEWTON_OPTIMIZE.  The number
of iterations completed in the most recent execution of NEWTON is
stored in the variable NEWTON_ITERATION_COUNTER. If VERBOSE:TRUE,
then NEWTON prints out the current trial solution after each
iteration.

Do USAGE(NEWTON); for more information.

You can help NEWTON to solve complex problems more quickly by
simplifying equations and expressions before giving them to
NEWTON.  For example, multiplying an equation by a term which
eliminates the VARS from the denominators simplifies the
expressions for the Jacobian, which is obtained by symbolic
differentiation.

Do EXAMPLE(NEWTON); for an example, and DEMO(NEWTON); for a longer
demonstration.

See also ROOT_BY_BISECTION, ALLROOTS, REALROOTS, SOLVE and ROOTS.

&NEWTON_EVAL_JACOBIAN default:1

[NEWTON package] Controls how often the Jacobian matrix is
re-evaluated during iteration by NEWTON.

 Value  Effect
 -----  ----------------------
  0     The Jacobian matrix obtained from a multivariate function is
        evaluated at the initial point and the resulting matrix is
        used in the iteration.  Iteration schemes:

        x[n+1] := x[n] - f(x[0])/f'(x[n])        (univariate)
        x[n+1] := x[n] - Df(x[0])^^-1 . f(x[n])  (multivariate)

  1     The Jacobian matrix is re-evaluated numerically at the start
        of each iteration.   

 >=1    The Jacobian matrix is re-evaluated numerically every
        NEWTON_EVAL_JACOBIAN number of iterations.  Iteration 
        schemes for NEWTON_EVAL_JACOBIAN >= 1: 

        x[n+1] := x[n] - f(x[n])/f'(x[n])        (univariate)
        x[n+1] := x[n] - Df(x[n])^^-1 . f(x[n])  (multivariate)


See also NEWTON_TOL, NEWTON_OPTIMIZE.

&NEWTON_OPTIMIZE default:FALSE

[NEWTON package] When TRUE, NEWTON applies RATSIMP and then OPTIMIZE
to the iteration function in an attempt to speed up floating point
evaluation.  Setting this variable to TRUE is more likely to help for
problems which take many iterations and which use complicated
functions.

&NEWTON_SEARCH(funclist, varlist, corner1, corner2
 {, num_intervals, newton_iters, root_tol})

Attempts to find all simultaneous roots of a list of N functions
in a cube in N-dimensional space.

Arguments:
---------
 - funclist is a list of N functions or equations.
 - varlist is a list of N the independent variables.
 - corner1 is a list of the N coordinates of one corner of
   the rectanguloid region to be searched for roots.
 - corner2 is a list of the N coordinates of the opposite
   corner of the rectanguloid region to be searched.
 - num_intervals (optional, default:[10,...,10]) is a list
   of the number of search intervals to be located along
   each coordinate direction.
 - newton_iters (optional, default:25) specifies the number of
   newton iteration steps before NEWTON halts without converging
   to a root.
 - root_tol (optional, default:100*float_plus_epsilon) specifies
   the distance within which two roots are considered to be 
   identical.

Returned Value:
--------------
SEEK_APPROX_ROOTS returns a list of possible solution points in the
search region.  Each point is represented as a list of floating 
point numbers. These points are often suitable for use as starting
points for NEWTON iteration.

Methods: NEWTON_SEARCH performs these operations.
 - Calls SEEK_APPROX_ROOTS which attempts to find possible 
   approximate roots in the specified rectangle, using a secant 
   method in N dimensions.
 - Calls DISTINCT_ROOTS to eliminate potential roots which are 
   closer than ROOT_TOL to one another.
 - Calls NEWTON to each possible approximate root, to converge on 
   a root.
 - Calls DISTINCT_ROOTS to eliminate roots which are closer than 
   ROOT_TOL to one another.

Do EXAMPLE(NEWTON_SEARCH); for an example.

&NEWTON_TOL default:1.0e-6

[NEWTON package] Sets the tolerance for the residual in Newton's
method.  Iteration terminates when the residual is less than this
value.  The residual is computed via the Euclidean norm.

&NEXTLAYERFACTOR default:FALSE

[FACEXP package] If TRUE will force the recursive calls of FACSUM to
be applied to the factors of the factored form of the coefficients of
the argi.  If FALSE then FACSUM will be applied to each coefficient as
a whole whenever recursive calls to FACSUM occur as described above.
In addition, inclusion of the atom NEXTLAYERFACTOR in the argument
list of FACSUM has the effect of NEXTLAYERFACTOR:TRUE, but for the
next level of the expression ONLY.  Since NEXTLAYERFACTOR is always
bound to either TRUE or FALSE, it must be presented single-quoted
whenever it is used in this way.

&NICEINDICES(expr)

Change all the indices of sums and products in the expression expr to
something more easily understandable.  It makes each index it can "I" ,
unless "I" is in the internal expression, in which case it
sequentially tries J,K,L,M,N,I0,I1,I2,I3,I4,...  until it finds a
legal index.

Do EXAMPLE(NICEINDICES); for an example.

See also SUM and NICEINDICESPREF.

&NICEINDICESPREF default:[I,J,K,L,M,N]

The list which NICEINDICES uses to find indices for sums and products.
This allows the user to set the order of preference of how NICEINDICES
finds the "nice indices".  E.g.  NICEINDICESPREF:[Q,R,S,T,INDEX]$.
Then if NICEINDICES finds that it cannot use any of these as indices
in a particular summation, it uses the first as a base to try and tack
on numbers.  Here, if the list is exhausted, Q0, then Q1, etc., will
be tried.

&NILT(exp, lvar, ovar)

Computes the inverse Laplace transform of exp with respect to lvar and
parameter ovar; this is an extension of the ILT command.

Do USAGE(NILT); for more information.

Do DEMO(NILT); for a demonstration.

See also ILT, LAPLACE. 

&NILT_USER_EXTENSION

An option for ILT.

&NINTH(exp)

Returns the ninth part of exp.  It is affected by INFLAG, in the same
way as FIRST.

&NOEVAL

Suppresses the evaluation phase of EV.  This is useful in conjunction
with other switches and in causing expressions to be resimplified
without being reevaluated.

&NOFIX(oper {, pos})

Defines the symbol oper to be a nofix operator. The second argument
pos is optional, and defines the part of speech of the result.

A NOFIX operator is a function of no arguments.  The mere presence of
such an operator in a command will cause the corresponding function to
be evaluated.  For example, when one types "exit;" to exit from a
Macsyma break, "exit" is behaving similar to a NOFIX operator.

Do USAGE(OPERATORS); for more information on defining operators.

See also PREFIX, POSTFIX, INFIX, NARY, MATCHFIX.

&NOLABELS default:FALSE

If TRUE then no labels will be bound except for E lines generated by
the solve functions.  This is most useful in the "BATCH" mode where it
eliminates the need to do KILL(LABELS) in order to free up storage.

&NON_ZERO_AND_FREEOF(x, e)

Returns TRUE if e is nonzero and x does not occur in e, else returns
FALSE.

See also FREEOF.

&NONDIMENSIONALIZE(U)

[DIMEN Package] Returns a list of nondimensional combinations of the
physical quantities in U. U is a list of indeterminates representing
classes of physical quantities such as VELOCITY or LENGTH, for which
dimensions have previously been established by the DIMENSION function.

Do USAGE(DIMEN); for more information.

Do DEMO(DIMEN); for a demonstration.

See also DIMEN_LIST_OF_EQUATIONS.

&NONINTEGER - Property

A symbol can be declared NONINTEGER if it is known to represent a
number that is not an integer or a function that takes only
nonintegral values.  NONINTEGER is a member of the FEATURES list.  It
can be asserted with DECLARE, withdrawn with REMOVE, and detected with
FEATUREP.

&NONSCALAR - Property

DECLARE(ai, NONSCALAR)$ makes ai behave as does a list or matrix with
respect to the dot operator.  You can DECLARE an object NONSCALAR if
you do not want it to be treated as a scalar with respect to the
built-in field.  This affects simplification of expressions involving
the dot operator.  NONSCALAR can be removed with REMOVE.  It can be
detected with NONSCALARP.

&NONSCALARP(exp)

Returns TRUE if exp is declared NONSCALAR, that is it contains atoms
declared as nonscalars, lists, or matrices.

See also PREDICATES.

Do EXAMPLE(NONSCALARP); for an example.

&NOPRINT default:FALSE

An option to TRACE.  When tracing functions, setting NOPRINT to TRUE
suppresses printing.

See TRACE_OPTIONS.

&NORMAL_DENSITY(x, mean, variance)

[UNIPROB package] The normal probability density function

                                    2
                          (x - mean)
                        - -----------
                          2 variance
                        %e
        f(x) =   --------------------------------
                 sqrt(2) sqrt(%pi) sqrt(variance)

where  -inf < x < inf.

Do EXAMPLE(NORMAL_DENSITY); for an example.

See also NORMAL_DISTRIB, NORMAL_MDF.

&NORMAL_DISTRIB(x, mean, variance)

[UNIPROB package] The cumulative normal distribution.

Do EXAMPLE(NORMAL_DISTRIB); for an example.

See also NORMAL_DENSITY, STANDARD_NORMAL_DISTRIB, 
INV_NORMAL_DISTRIB, GAUSS. 

&NORMAL_MDF(Z, V {, vdet})

[MULTPROB package] The multivariate normal probability density
function with zero mean value.

Arguments:

 - Z is a vector of independent random variables of length m,
   where the elements of Z are real numbers.
 - V is the "precision matrix", an m x m positive definite
   symmetric matrix which is the inverse of the covariance matrix.
 - vdet is the determinant of the matrix V.  If you know vdet,
   you can specify it and save the time needed to recompute it.

When the dimension of the distribution is 1, then Z and V can
be atomic variables or expressions.
                    1/2
              det(V)           1
 NORMAL_MDF = ---------- exp(- - Z^` . V . Z)
                     m/2       2
              (2*%pi)


Do EXAMPLE(NORMAL_MDF); for an example.

See also NORMAL_DENSITY, STANDARD_NORMAL_DENSITY.

&NOSTRING

A keyword to the PLAYBACK command.  When NOSTRING is specified,
PLAYBACK displays all input lines when playing back rather than
STRINGing them.  If the keyword GRIND is specified, then the display
will be in a more readable format.  One may include any number of
options as in PLAYBACK([5,10],20,NOSTRING,TIME,SLOW).

&NOT

Used in predicates along with AND and OR.

&NOT3D

A keyword to PLOT3D which causes two-dimensional slices of the image
to be superimposed in one two-dimensional plane.  Specifically 1 2D
curve of z vs. x for each y value, and so is a convenient way to plot
several curves on the same plot.  Exactly the same plot points are
calculated by PLOT3D as in the ordinary case when NOT3D is not
specified.

NOT3D is not currently supported in Macsyma 2.0 and successors.

&NOTEQUAL(expr1, expr2)

IS(NOTEQUAL(A,B))  is the same as  IS(NOT EQUAL(A,B)) .

See also EQUAL, "=", "#", IS.

&NOUN

When a symbol fi is DECLAREd to be a NOUN, then a function with the
name fi becomes a noun, which means that it will not evaluate
automatically.

Example:

 (c1) FACTOR(9);
                                    2
 (d1)                              3

 (c2) 'FACTOR(9);
 (d2)                          factor(9)

See also NOUNIFY, VERB, and VERBIFY, "'", "''".

&NOUNDISP default:FALSE

If TRUE will cause NOUNs to display with a single quote.  This switch
is always TRUE when displaying function definitions.

&NOUNIFY(f)

Returns the noun form of the function name f.  This is needed if one
wishes to refer to the name of a verb function as if it were a noun.
Note that some verb functions will return their noun forms if they
can't be evaluated for certain arguments.  This is also the form
returned if a function call is preceded by a quote.

Do EXAMPLE(NOUNIFY); for an example.

See also "'".

&NOUNS - an EVFLAG

When used as an option to the EV command, converts all "noun" forms
occurring in the expression being EV'd to "verbs", i.e.  evaluates
them.

See also NOUN, NOUNIFY, VERB, and VERBIFY.

&NROOTS(poly, low, high)

Finds the number of real roots of the real univariate polynomial poly
in the half-open interval (low, high].  The endpoints of the interval
may also be MINF,INF respectively for minus infinity and plus
infinity.  The method of Sturm sequences is used.

Example:

 (c1) POLY1:X^10-2*X^4+1/2$
 (c2) NROOTS(POLY1,-6,9.1);
 (d2)                               4

Do EXAMPLE(NROOTS); for an example.

See also SOLVE, LINSOLVE, TAYLOR_SOLVE, NTHROOT, ALLROOTS, REALROOTS,
RATCOEF and ROOTS.

&NTERMS(exp)

Returns the number of terms that exp would have if it were fully
expanded out and no cancellations or combination of terms occurred.
Note that expressions like SIN(E), SQRT(E), EXP(E), etc.  count as
just one term regardless of how many terms E has (if it is a sum).

Do EXAMPLE(NTERMS); for an example.

See also LENGTH, PICKAPART, REVEAL.

&NTERMST(tens)

[CTENSOR package] Gives the user a quick picture of the "size" of the
double subscripted (array) tens.  It returns a list of pairs whose
second elements give the number of terms in the components specified
by the first elements.

&NTHROOT(p, n)

Where p is a polynomial with integer coefficients and n is a positive
integer returns q, a polynomial over the integers, such that q^n=p or
prints an error message indicating that p is not a perfect nth power.
This routine is much faster than FACTOR or even SQFR.

Do EXAMPLE(NTHROOT); for an example.

See also SOLVE, LINSOLVE, TAYLOR_SOLVE, NROOTS, ALLROOTS, REALROOTS,
RATCOEF.

&NTRIG - This package is obsolete.  See TRIG_SUMMARY.

&NULLSPACE(mat)

Returns a list of vectors (given as lists) that forms a basis for the
null space of the matrix mat.  The null space of a matrix mat is a
list of basis vectors whose linear combinations satisfy the matrix
equation mat . x = 0 .  (Also, the null space is spanned by the
eigenvectors with eigenvalue = 0 .)

Do EXAMPLE(NULLSPACE); for an example.

&NUM(exp)

Returns the numerator, exp1, of the rational expression
exp = exp1/exp2.

Do EXAMPLE(NUM); for an example.

&NUMAUGEND(exp)

Returns the numerical term in the sum exp.

Example:

 (c1) NUMAUGEND(X+2*Y+%I+%PI+1/2);
                                    1
 (d1)                               -
                                    2
&NUMBERP(exp)

Returns TRUE if exp is an integer, a rational number, a floating point
number or a bigfloat else FALSE.

Do EXAMPLE(NUMBERP); for an example.

See also CONSTANTP, RATNUMP, SCALARP, PREDICATES.

&NUMEIGS default:FALSE

[MATRICE package] If TRUE, will cause EIGENVALUES to numerically
solve for the roots (using the Macsyma function ALLROOTS) of any
univariate residual polynomials left over during the course of
computing the exact roots of matrix characteristic polynomials.  If
NUMEIGS is FALSE then only exact roots will be returned by
EIGENVALUES.  

See also MEIGENVALUES.

&NUMER

Causes some mathematical functions (including exponentiation) with
numerical arguments to be evaluated in floating point.  It causes each
variable in exp which has been given a NUMERVAL to be replaced by its
value.  If you set NUMER, FLOAT will automatically be set to the same
value.

See also PREDICATES, %ENUMER.

&NUMER_PBRANCH default:FALSE

Affects the simplification of R1^R2 where R1 and R2 are floating point
numbers and R1<0.  When NUMER_PBRANCH is FALSE, R1^R2 is unchanged.
When NUMER_PBRANCH is TRUE, R1^R2 is simplified via R1^R2 =
(-R1)^R2*COS(P*R2) + %I*(-R1)^R2*SIN(%PI*R2)].  NUMER_PBRANCH is an
EVFLAG.

&NUMERICAL_MATRIXP(exp)

Returns TRUE if exp is a matrix consisting entirely of integers, rational 
numbers, and floating point numbers (but not bigfloats), else FALSE.
If NUMERICAL_MATRIXP(mat); is TRUE and USE_MATRIX_LU is TRUE then 
DETERMINANT, INVERT, and MATSOLVE_BY_LU will automatically use fast LU 
methods.

Do EXAMPLE(NUMERICAL_MATRIXP); for an example.

See also CNUMERICAL_MATRIXP, DET_BY_LU, INVERT_BY_LU.

&NUMERVAL(var1, exp1, var2, exp2, ...)

Declares vari to have a numerical value of expi which is evaluated and
substituted for the variable in any expressions in which the variable
occurs if the NUMER flag is TRUE. See the EV function.

&NUMFACTOR(exp)

Gives the numerical factor multiplying the expression exp which should
be a single term.  If the GCD of all the terms in a sum is desired the
CONTENT function may be used.

 (c1) GAMMA(7/2);

 (d1)               15 sqrt(%pi)
                    ------------
                         8

 (c2) NUMFACTOR(%)
                     15
 (d2)                --
                      8

Do EXAMPLE(NUMFACTOR); for an example.

See also CONSTFACTOR.

&NUMKIT

An optional add-on product which speeds up certain of Macsyma's
numerical operations, mostly in linear algebra. NUMKIT also works
with real and complex floating point matrices, but not with BFLOATs or
RATNUMs.

The following Macsyma commands seamlessly use NUMKIT:

Solution of Matrix Equations
   MATSOLVE_BY_LU
 
Matrix Inversion
   INVERT, INVERT_BY_LU

LU Decomposition
   LU_DECOMP, LU_BACKSUB

Determinant
   DETERMINANT, DET, DETERMINANT_BY_LU, DET_BY_LU
         
Singular Value Decomposition
   SVD_NUMERICAL, SVD, MATSOLVE_BY_SVD,
   LSQ_LINSOLVE_BY_SVD, CONDITION_BY_SVD(mat), RANK_BY_SVD

Eigenvalues and EigenVectors
   EIGENVALUES_BY_SCHUR, EIGENS_BY_SCHUR, EIGENS_BY_SCHUR_REAL
   SCHUR_FORM, SCHUR_FORM_REAL, RIGHT_EIGENS_BY_SCHUR

Least Square Solvers for Overdetermined or Underdetermined or
Singular Matrices
   LSQ_LINSOLVE_BY_SVD, LSQ_LINSOLVE_BY_QR,
   LSQ_LINSOLVE_BY_QRCOMPLETE

Numerical root finding for univariate polynomials
   ROOTS

Matrix Utilities
   MAT_NORM_NUMERICAL

In addition, there are routines that are NUMKIT specific.  They include

 LEFT_EIGENS_BY_SCHUR, SVD_NUMERICAL for complex matrices, SCHUR_FORM for
 complex matrices.

NumKit can be called directly from Macsyma.

Do USAGE(NUMKIT); for more information.

Do DEMO(NUMKIT); for a general introduction.

Do DEMO(NUMKIT1); for a more detailed set of examples of NUMKIT.

Do DEMO(NUMKIT2); for an example of residual error analysis in solving a
linear system.

&NUMKITP()

Predicate that returns TRUE if NUMKIT is available on your machine;
otherwise FALSE.

&NUMMOD(num, den)

Computes the periodic sawtooth function which generalizes the
remainder and "fraction part" functions.  For real num and den,
nummod(num,den) = num - den*floor(num/den) .  

Example:

 (c1) NUMMOD(6/5,1);
 (d1)                     1/5

Do EXAMPLE(NUMMOD); for executable examples.

See also RETURN_NUMMOD and MAKEFLOOR.

&NUMPARTITIONS(n)
 and
NUMPARTITIONS[n]

[ALGFUNCS package] Returns the number of partitions of the
positive integer n.

Do EXAMPLE(NUMPARTITIONS); for an example.

&NUMTERMS default:5

[ODESERIES package] Causes the diagnostic in the ODESERIES routine to
compute a different number of terms for the Taylor coefficients when
determining the nature of the singularities in the differential
equation.

See ODESERIES.

&NUMBER_TYPE_COERCION

Macsyma uses the following general rules in coercing data types
of numbers and expressions.   They are quite complex and reflect
an attempt to optimize Macsyma's default behavior over a wide
variety of situations. The rules used in Macsyma are similar to 
and consistent with the rules used in most mathematical programming
languages.

1 An expression that has only exact numbers and expressions
  remains exact. More generally, 

1.1 Macsyma tries to return the same degree of exactness or 
  floating accuracy as it is given on input.

  Example:
  (c1) [ sin(1), sin(1.0), sin(1.0d0), sin(1.0b0) ];

  (d1) [sin(1), 0.84147, 0.8414709848079d0, 8.4147098480789650665b-1]

1.2 Input of mixed floating type is coerced so as to not lose 
  accuracy. Integers and rational numbers will be floated, but
  not nonrational constants like sqrt(2), %pi and %e.

  Example:
  (c1) [1.+1.,  1.+1.d0 ,  1.+1.b0 ,  1.+1 , 1.+1/2 ,  1.+%pi;
      1.d0+1., 1.d0+1.d0, 1.d0+1.b0, 1.d0+1,1.d0+1/2, 1.d0+%pi;
      1.b0+1., 1.b0+1.b0, 1.b0+1.b0, 1.b0+1,1.b0+1/2, 1.b0+%pi;
        1+1. ,   1+1.d0 ,   1+1.b0 ,   1+1 ,  1+1/2 ,  1+%pi;
      1/2+1. , 1/2+1.d0 , 1/2+1.b0 ,  1/2+1, 1/2+1/2, 1/2+%pi;
      %pi+1. , %pi+1.d0 , %pi+1.b0 , %pi+1 , %pi+%pi, %pi+%pi ];

  (d1) |   2.0 ,   2.0d0 ,   2.0b0 ,   2.0 ,  1.5 , %PI+1.0   |
       |  2.0d0,   2.0d0 ,   2.0b0 , 2.0d0 , 1.5d0, %PI+1.0d0 |
       |  2.0b0,   2.0b0 ,   2.0b0 , 2.0b0 , 1.5b0, %PI+1.0b0 |
       |   2.0 ,   2.0d0 ,   2.0b0 ,    2  ,  3/2 ,    %PI+1  |
       |   1.5 ,   1.5d0 ,   1.5b0 ,   3/2 ,   1  ,   %PI+1/2 |
       |%PI+1.0,%PI+1.0d0,%PI+1.0b0, %PI+1 , 2*%PI,    2*%PI  |


2 Most commands which are given exact inputs or floatnum inputs
  will produce exact or floatnum outputs of the same type. However,
  if bigfloats are not supported, they will be replaced by rational
  numbers in internal computations and in results.

  Example:
  (c1) [linsolve(1-2*x, x), linsolve(1-2.0*x, x), 
      linsolve(1-2.0d0*x, x), linsolve(1-2.0b0*x, x)];

  (d1)       [[x = 1/2], [x = 0.5], [x = 0.5d0], [x = 1/2]]


3 Some commands whose algorithms are considered to require exact 
  numbers will convert floating point numbers to rational
  approximants by default.  

  Examples:
  (c1) solve(x^2+2.0*x+1,x);
  RAT replaced 2.0 by 2/1 = 2.0

  (d1)                         [x =  - 1]

  (c2) factor(x^2+2.0*x+1);
  RAT replaced 2.0 by 2/1 = 2.0

  (d2)                          (x+1)^2

  Macsyma has options to suppress this conversion to rationals in 
  some cases where this is sensible (e.g. RATSIMP), but not in 
  cases where this does not make sense (e.g. SOLVE).

  Examples:
  (c1) ratsimp(3.4*x+7.*y/x);
  RAT replaced 3.4 by 17/5 = 3.4
  RAT replaced 7.0 by 7/1 = 7.0

  (d1)                 (35*y + 17*x^2)/(5*x)

  (c2) ratsimp(3.4*x+7.*y/x), keepfloat:true;

  (d2)                  (7.0*y + 3.4*x^2)/x

4 Some commands have algorithms which are considered to be inherently 
  floating point. These commands convert exact inputs to sfloat 
  computation and output. When given sfloats or dfloats or bfloats, 
  they will compute and return floatnums of the same type.

  Examples:
  (c1) [lsq1([1,2,3],[1,4,9],1), lsq1([1.,2.,3.],[1,4,9],1),
   lsq1([1.d0,2.d0,3.d0],[1,4,9],1)];

  (d1) [4.0*t - 3.33333, 4.0*t - 3.33333, 4.0d0*t - 3.33333333333332d0]

  However, LSQ1 needs to be told explicitly to use bfloats.
  (c2) lsq1([1.b0,2.b0,3.b0],[1,4,9],1);

  (d2)                      4.0*t - 3.33333

  (c3) block([lsq_infloat:'bfloat, lsq_refloat:'bfloat],
        lsq1([1.b0,2.b0,3.b0],[1,4,9],1));

  (d3)          4.0b0 * t - 3.3333333333333333333b0
 
  NEWTON pays attention only to the number type of the initial guess,
  and does not analyze the number types occurring in the expression
  whose roots are sought.

  (c1) [ newton(1-2*x, x, 0), newton(1-2*x, x, 0.0),
        newton(1-2*x, x, 0.0d0), newton(1-2*x, x, 0.0b0)];

  (d1)    [[x = 0.5], [x = 0.5], [x = 0.5d0], [x = 5.0b-1]]

  (c2) [ newton(1-2*x, x, 0), newton(1-2.0*x, x, 0),
        newton(1-2.0d0*x, x, 0), newton(1-2.0b0*x, x, 0)];

  (d2)       [[x = 0.5], [x = 0.5], [x = 0.5], [x = 0.5]]


5 Float-only matrix routines may default to double float output,
  because most matrix operations on large (10-by-10 or more) 
  matrices rely on double floats to maintain stability.

  Example:
  (c1) eigens_by_schur( [2, 1 ; 0 ,3] );

  (d1) [[3.0d0, 2.0d0], [ | 0.70710678118654d0|, |1.0d0|], 0]
                          | 0.70710678118654d0|  |  0  |

6 Complex expressions are usually handled by applying the rules above
  for real expressions to the real and imaginary parts separately.

  Examples:
  (c1) 1+2*%i + 1.0 + 3*%i;

  (d1)                         5*%i + 2.0

  Macsyma does not automatically simplify complex multiplications and
  other complex expressions.  
  (c1) (1+2*%i)*(1.0 + 3*%i);

  (d1)                  (2*%i + 1) * (3*%i + 1.0)

  You can simplify with various commands.
  (c2) [ rectform(d1), expand(d1) ];

  (c2)              [ 5.0 * %i - 5.0, 5.0 * %i - 5.0 ]

  (c3) ratexpand(d1);
  RAT replaced 1.0 by 1/1 = 1.0

  (d3)                         5*%i - 5

  KEEPFLOAT prevents conversions to CRE form from removing floatnums.
  (c3) ratexpand(d1), keepfloat:true;
  RAT replaced 1.0 by 1/1 = 1.0

  (d3)                         5.0*%i - 5.0

See also FLOATNUM_SUMMARY.

&NUMPRINT(exp1, exp2, ...)

NUMPRINT is the same as PRINT except that it prints negative numbers 
etc. without a space after the minus sign.  NUMPRINT works this way 
in FANCY_DISPLAY:FALSE mode.  It is used by WRITE_DATA_TO_FILE.

&NUSUM(expr, var, low, high)

[NUSUM package] Performs indefinite summation of exp with respect to
var using a decision procedure due to R.W. Gosper.  exp and the
potential answer must be expressible as products of nth powers,
factorials, binomials, and rational functions.  The terms "definite"
and "indefinite summation" are used analogously to "definite" and
"indefinite integration".  To sum indefinitely means to give a closed
form for the sum over intervals of variable length, not just e.g.  0
to inf.  Thus, since there is no formula for the general partial sum
of the binomial series, NUSUM can't do it.  NUSUM has been extended to
handle cases where expr is the sum of several hypergeometric terms,
instead of just one.

Definition (Knuth):  g(n) is a hypergeometric term with respect to n if
and only if g(n+1)/g(n) is a rational function of n.  Thus g is a
simple product of rational functions, factorials, binomials,
sin(a+%pi*n), gammas, nth powers of constants, and (the general case)
explicit PRODUCTs (to upper limit n) of rational functions.  Thus
{sum(g(n))} = the generalized hypergeometric functions.

The library package NUSUM contains many advanced capabilities for
finding closed form representations of series and products.  The
function NUSUM is contained in this package and autoloads.

Do USAGE(NUSUM); for more information.

Do EXAMPLE(NUSUM); for an example, and DEMO(NUSUM); for a longer
demonstration.

See also SUM, SUMCONTRACT, INTOSUM, BASHINDICES, NICEINDICES, SIMPSUM,
NUSUM1, and CLOSEDFORM.

&NUSUM1

This package attempts to find closed-form representations of series
and products.  It also contains a program which solves first-order
linear inhomogeneous difference equations.  This enhanced version was
contributed by R.W. Gosper.

Do USAGE(NUSUM1); for more information.

Do DEMO(NUSUM1); for a demonstration.

See also NUSUM, SUM, SUMCONTRACT, INTOSUM, BASHINDICES, NICEINDICES,
SIMPSUM, and CLOSEDFORM.

&NZETA(Z)

Returns the complex value of the Plasma Dispersion Function for
complex Z.  NZETAR(Z) returns REALPART(NZETA(Z)).  NZETAI(Z) returns
IMAGPART(NZETA(Z)).  This function is related to the complex error
function by NZETA(Z) = %I*SQRT(%PI)*EXP(-Z^2)*(1-ERF(-%I*Z)).

&OBASE default:10

The base for display of numbers.  The value assigned to this variable
must be an integer between 2 and 36 inclusive.  If OBASE is assigned a
value greater than 10, letters of the alphabet are used to represent
digits above 9.  This option variable does not affect floating-point
numbers or bigfloats.

&ODD - Property

A symbol can be declared ODD if it is known to represent an odd
integer or a function that takes only odd integral values.  ODD is a
member of the FEATURES list.  It can be asserted with DECLARE,
withdrawn with REMOVE, and detected with FEATUREP.

&ODDFUN - Property

A symbol can be declared ODDFUN if it is known to represent an odd
function.  ODDFUN is a member of the FEATURES list.  It can be
asserted with DECLARE, withdrawn with REMOVE, and detected with
FEATUREP.

Do EXAMPLE(ODDFUN); for an example.

See also EVEN, ODDFUN.

&ODDP(exp)

Returns TRUE if exp is an odd integer.  FALSE is returned in all other
cases.

Do EXAMPLE(ODDP); for an example.

See also EVENP, PREDICATES.

&ODE(equation, y, x)

Attempts to solve a first or second order ordinary differential equation 
for y as a function of x.  Some ODEs of higher than second order are 
also solved.  ODE is a master command for many of the ordinary 
differential equation solvers in Macsyma, combined in such a way as to 
attempt more and more difficult methods as simpler methods fail to find 
solutions.  ODE first applies the command ODE2 (a collection of basic 
method for solving differential equations).  In addition, ODE has a 
number of user features which can assist an experienced ODE solver 
if the basic system cannot handle the equation.

Do USAGE(ODE); For more information.  

Initial conditions and boundary conditions can be specified using the
commands IC1, IC2, BC2, ODE_ICONDS, and ODE_IBC.

Do EXAMPLE(ODE); for an example.  For demonstrations, do
  DEMO(ODE);
  DEMO(ODE1);
  DEMO(ODE2);
  DEMO(ODEFI);
  DEMO(ODELIN2); .  
See DEMOS_CALCULUS for a longer list of ODE demonstrations.

See also 
  ODE2 - basic solution methods,
  ODEFI - first order ODEs, first integrals,
  ODELIN2 - linear second order ODEs,
  ODELINSYS, ODEMATSYS - solutions of linear systems of ODEs,
  ODESERIES - Frobenius series solutions of second order linear ODEs,
  TAYLOR_ODE - Taylor series solutions of (systems of) ODEs,

  AVG_PODE, LINDST, MSCALES - perturbation methods for nonlinear ODEs.
  ODE_INDEPTRAN - transformation of independent variable.
  LSQ_ODE - find best fit of parameterized ODE to numerical data.

  ODE_NUMSOL - numerical solutions of (systems of) ODEs,
  RUNGE_KUTTA - numerical solutions of (systems of) ODEs,
  ODE_STIFFSYS - numerical solutions of stiff systems of ODEs,

&ODE_DIRECTION_FIELD2D(deq, x, xlo, xhi, y, ylo, yhi {, ics})

Plots the direction field of a first order autonomous differential
equation. Deq is a first order differential equation, such as

     A*dy/dx  = f(x,y) , or

     G(dy/dx) = 0

It must be possible to explicitly solve for dy/dx. X is the 
independent variable, y is the dependent variable, and xlo, xhi,
ylo, yhi are bounds of the region in the (x,y) plane where the
direction field will be displayed. 

Ics are optional arguments. They are points [x0,y0], ..., [xN,yN] through
which solution curvese are computed and plotted along with the direction
field. You can set ODF_STEP (default:0.1) to adjust the step size for
numerical integration.

Do EXAMPLE(ODE_DIRECTION_FIELD2D); for an example.

See also ODE_PHASE_PLOT2D.

&ODE_IBC(solution, xcond1, ycond1 {, xcond2, ycond2})

Imposes the specified initial/boundary conditions on the general
solution of the first or second order ordinary differential equation
as found by one of Macsyma's ODE solver commands.  The original
differential equation will be assumed to have been first order (and
hence contain arbitrary constant %C) if only xcond1 and ycond1 are
specified, otherwise it will be assumed to have been second order (and
thus contain arbitrary constants %K1 and %K2.)  The xcondi are
equations (of the form x = xi) specifying values of the independent
variable, while the ycondi are equations involving the dependent
variable and its derivative at the corresponding xi [e.g., x = 0 and y
+ 'diff(y, x) = 1].  This function is a generalization of IC1, IC2 and
BC2.

Do EXAMPLE(ODE_IBC); for an example.  

See also IC1, IC2, BC2, ODE, ODE_ICONDS.

&ODE_ICONDS(solution, xcond, ycond1, ycond2, ... ycondn)

Imposes the specified initial conditions on the general solution of 
the ordinary differential equation as found by one of Macsyma's 
ODE solver commands.  The differential equation can be of any order.
This function is a generalization of IC1 and IC2, which ODE_ICONDS
calls for equations of first and second order.

Do EXAMPLE(ODE_ICONDS); for an example.  

See also IC1, IC2, BC2, ODE, ODE_IBC.

&ODE_INDEPTRAN(DEQ, Y, X, Z, F)

Transforms the ordinary differential equation DEQ in Y(X) to an
equation in Y(Z) using the relationship Z=F(X).  ODE_INDEPTRAN works
for ODEs of arbitrary order.

Do EXAMPLE(ODE_INDEPTRAN); for an example.

See also CHANGEVAR.

&ODE_NUMSOL(DIFFEQ, DEP_VAR, INDEP_VAR, DEP_VAR_INIT, INDEP_VAR_START,
INDEP_VAR_END, STEPSIZE {, TYPE})

Numerically integrates an ODE  or system of ODEs from some
initial point.  The ODEs must be given in explicit form as
equations (similar to what one would give to the Macsyma routine ODE).
A second calling syntax for ODE_NUMSOL is:

ODE_NUMSOL(list_of_equations, list_of_dep_vars, indep_var,dep_var_inits,
indep_var_start, indep_var_end, stepsize {, type})

DIFFEQ must be an ODE in dependent variable DEP_VAR as a function
of independent variable INDEP_VAR.  DEP_VAR_INIT must be an equation,
or list of equations, for the required initial conditions.  Initial
conditions must be supplied using forms of 'AT to describe them.

The optional variable TYPE describes the integration algorithm. TYPE
is either 'RUNGE_KUTTA_4 or 'RK4 for a fixed stepsize 4th order
Runge-Kutta scheme.   TYPE is 'RK5 or 'RK5F for a fixed stepsize 5th
order scheme. TYPE is 'RUNGE_KUTTA_5 or 'RK5A for an adaptive
5th order variable stepsize algorithm. 

You can place numerical data from the solution in an MFE
DataViewer (See ODNS_MFE_OUTPUT). 

You can view the solution "in progress" in an MFE graphics section
(See ODNS_MFE_PLOT).

Do USAGE(ODE_NUMSOL); for more information.

Do EXAMPLE(ODE_NUMSOL); for an example and DEMO(ODENSOL); and
DEMO(ODENSOL1); for longer demonstrations including

    - placing solution data in DataViewers  DEMO(ODENSOL1);

    - graphing solution data                DEMO(ODENSOL1);

    - using procedures                      DEMO(ODENSOL2);

    - comparing fixed step sizes            DEMO(ODENSOL3);
       with adaptive solutions

    - solving first order systems           DEMO(ODENSOL4);

See also ODE_NUMSOL1 to generate a functional procedure as the 
solution. Do DEMO(ODENSOL2); for a demonstration. 

See also RUNGE_KUTTA, ODE_PLOT and ODE_STIFFSYS

&ODE_NUMSOL_FIRST_ORDER_SYSTEM(diffeq, dep_var, indep_var, dep_var_init,
 indep_var_start, indep_var_end, stepsize {, type})

[ODENSOL package] Solves a system of equations known to be in the form
of a first order system. Returns a list a names of the solutions,
and their first derivatives as well as an association list. Optionally,
returns data in a DataViewer.  

The arguments to ODE_NUMSOL_FIRST_ORDER_SYSTEM are the same as
to ODE_NUMSOL.

Do USAGE(ODE_NUMSOL); for more information.

See also ODNS_FIRST_ORDER_RESULTS and ODNS_FIRST_ORDER_NAMES.

Do DEMO(ODENSOL4); for a demonstration.

This routine is available only with Macsymas that support MFE variables.

&ODE_NUMSOL1(diffeq, dep_var, indep_var, dep_var_init, ic, stepsize)

[ODENSOL package] Returns a procedure that numerically integrates 
a single Nth order ODE from an initial point using ODE_NUMSOL
with default settings.

The procedure will calculate the solution a new point x by:

   1) extending the interval where values are already calculated by
      calling ODE_NUMSOL.
or
   2) interpolating using the previously calculated values by
      by the method specified by ODNS_INTERPOLATE (linear, spline,
      or polynomial; [default: spline])

Do USAGE(ODE_NUMSOL); for more information.

Do DEMO(ODENSOL2); for a demonstration.

&ODE_PHASE_PLOT2D(deq1,deq2, t,tlo,thi, x,xlo,xhi, y,ylo,yhi, ics)

Plots phase space (x,y) portraits on the direction field of the
differential equation given by

  deq1:   dx/dt= f1(x,y)
  deq2:   dy/dt= f2(x,y)

The equations must be an autonomous system.

The initial conditions ics for the numerical solutions are lists in 
the form [[t0,x0,y0], ..., [tN, xN, yN]] .

You can set ODF_STEP (default:0.1) to adjust the step size for numerical
integration.

The phase space plot (x,y) is drawn in the box [xlo, ylo] X
[xhi,yhi]. 

t0 must lie inside [tlo, thi].

Do EXAMPLE(ODE_PHASE_PLOT2D); for an example.

See also ODE_DIRECTION_FIELD2D.

&ODE_STIFFSYS(eqn, dep_var, indep_var, dep_var_init, indep_var_start,
indep_var_end, stepsize)

Finds numerical solutions for stiff systems of differential equations
using the fourth order Rosenbrock method.  The arguments to
ODE_STIFFSYS are:

 - eqn - a list of ODEs given explicitly
 - dep_var - a list of dependent variables
 - indep_var - the independent (time) variable
 - dep_var_init - a list of initial conditions, in the
    form of equations 
 - indep_var_start - the initial time
 - indep_var_end - the final time
 - stepsize  - the step size for the independent variable 

Do EXAMPLE(ODE_STIFFSYS); for an executable example,
and DEMO(ODESTIFF); for a longer demonstration.

See also RUNGE_KUTTA and ODE_NUMSOL.

&ODE_SUMMARY

Macsyma has three major classes of methods for solving ordinary 
differential equations.

o Exact symbolic methods: Macsyma includes most basic methods for
  solving first and second order ODEs and some methods for higher
  order equations.

  - Finding general solutions (many methods):                      ODE
  - Applying boundary conditions:   IC1, IC2, BC2, ODE_IBC, ODE_ICONDS
  - Linear systems of ODEs:                    ODELINSYS, ODEMATSYS
  - Transfer function matrix for linear control:       TRANSFER_MATRIX

o Numerical methods

  - Runge-Kutta 4th and 5th order fixed step methods and
    5th order adaptive step method:            ODE_NUMSOL, ODE_NUMSOL1
  - Stiff systems of ODEs by Rosenbrock's method:      ODE_STIFFSYS
  - Best fit for parameters from numerical data:               LSQ_ODE

o Approximate symbolic methods

  - Taylor series methods:                       ODESERIES, TAYLOR_ODE
  - Perturbation methods:            LINDSTEDT, AVERAGE_PERIODIC_ODE, 
                                                       MULTIPLE_SCALES
    

Other utilities are available.

o Transforming independent variables in ODEs:         ODE_INDEPTRAN

o Plotting of ODEs:          ODE_DIRECTION_FIELD2D, ODE_PHASE_PLOT2D

Do USAGE(ODE); for more information on the general solver ODE.

See DEMOS_CALCULUS for a list of executable demonstrations of solving
ODEs.

&ODE2(exp, dvar, ivar)

Solves a class of ordinary differential equations which is a subset of
those solved by the ODE command.  ODE2 takes three arguments: an ODE
of first or second order (only the left hand side need be given if the
right hand side is 0), the dependent variable, and the independent
variable.  When successful, it returns either an explicit or implicit
solution for the dependent variable.  If ODE2 cannot obtain a solution
for whatever reason, it returns FALSE, after perhaps printing out an
error message.

ODE2 is one of the differential equation solvers called by the
command ODE.  If ODE2 cannot solve a given equation, it is
possible that ODE can.

Do USAGE(ODE2); for more information.

Do EXAMPLE(ODE2); for an example, and DEMO(ODE2); for a longer
demonstration.

See ODE for a summary of Macsyma commands for solving ODEs.

&ODEFI(equation, dependent_variable, independent_variable)

Finds first integrals of first order ordinary differential equations
using the Prelle-Singer algorithm.

Do USAGE(ODEFI); for more information.

Do EXAMPLE(ODEFI); for an executable example, and DEMO(ODEFI); for a
longer demonstration.

See also ODE, ODE2, ODELIN2.

&ODELIN2(diffeqn, depvar, indepvar)

The ODELIN2 package solves 2nd order Linear ODEs.  It uses a technique
based on the hypergeometric equation.  It was contributed by Dr.
Shunro Watanabe of the Department of Mathematics, Tsuda College,
Kodaira, Tokyo 187, Japan.

Do USAGE(ODELIN2); for more information.

Do DEMO(ODELIN2); for a demonstration.

See ODE for a summary of Macsyma commands for solving ODEs.

&ODELINSYS([eq1,...,eqn], [var1,...,varn])

Solves a set of linear differential equations eq1,...,eqn in the
dependent variables var1,...,varn.  The functional relationships must
be explicitly indicated in both the equations and the variables. 

Example:

 (c1) 'DIFF(F,X,2)=SIN(X)+'DIFF(G,X);

 (c2) 'DIFF(F,X)+X^2-F=2*'DIFF(G,X,2);

 is NOT the proper format.  The correct way is:

 (c3) 'DIFF(F(X),X,2)=SIN(X)+'DIFF(G(X),X);

 (c4) 'DIFF(F(X),X)+X^2-F(X)=2*'DIFF(G(X),X,2);

 (c5) ODELINSYS([D3,D4],[F(X),G(X)]);

If initial conditions at 0 are known, they may be supplied before
calling ODELINSYS by using ATVALUE.  If ODELINSYS cannot obtain a
solution, it returns "FALSE".

Do USAGE(ODELINSYS); for more information.

Do EXAMPLE(ODELINSYS); for an example and DEMO(ODELINSYS); for a
longer demonstration.  

See ODEMATSYS for solving matrix linear differential equations.
See also ODE_NUMSOL, RUNGE_KUTTA and ODE_STIFFSYS for numerical
solutions of systems of ODEs.

&ODEMATSYS(matrix_equation, vector_variable)

[MATSOLVE package] Solves a linear matrix differential equation for
the vector_variable in a manner analogous to ODELINSYS -- except that
the linear differential equations are expressed as matrix
differential equations.  The functional relationships in the equations
must be explicitly indicated, as in ODELINSYS.  ODEMATSYS returns a
list of solution equations, of the form vector_variable =
solution_vector.

Do USAGE(ODEMATSYS); for more information.

Do EXAMPLE(ODEMATSYS); for an example, and DEMO(MATSOLVE); for a
longer demonstration.

See also ODELINSYS.

&ODESERIES(eqn, y, x)

Computes the solution of a second order linear differential equation
eqn by the method of Frobenius.  (substitution of infinite series).
The program determines the recurrence relation among the coefficients
of the power series, and if that is a function of only one subscripted
variable, determines a complete solution in terms of an infinite
series or a sum of infinite series.

Do EXAMPLE(ODESERIES); for an example. 

ODESERIES is also a keyword for ODE command which causes ODE to use
the methods of the ODESERIES command to solve differential equations.

See also ODE, TAYLOR_ODE.

&ODETUTOR default:FALSE

If TRUE, ODETUTOR gives much information about the path ODE or ODELIN2
takes to reach a solution.

Do DEMO(ODE); or DEMO(ODELIN2); for examples.

See also ODE, ODE2, ODELIN2,.

&ODF_STEP default:0.1d0

Default step_size for numerical integration used by ODE_PHASE_PLOT2D and
ODE_DIRECTION_FIELD2D.

&ODNS_CHECK_SINGULAR default: FALSE

If TRUE, ODE_NUMSOL will stop integrating if it encounters a singularity.
This can be useful to stop needless computations in a problem with
a singularity.

&ODNS_DATAVIEWER default: FALSE

If TRUE, ODE_NUMSOL will try to place its numerically computed solution
in a DataViewer. 

Do DEMO(ODENSOL1); for a demonstration.

&ODNS_FIRST_ORDER_NAMES default: []

List of names of the variables and their first derivatives calculated by
ODE_NUMSOL_FIRST_ORDER_SYSTEM. 

Do DEMO(ODENSOL4); for a demonstration.

&ODNS_FIRST_ORDER_RESULTS default: []

Association list returned by ODE_NUMSOL_FIRST_ORDER_SYSTEM.

Do DEMO(ODENSOL4); for a demonstration.

&ODNS_FLOATER default:'DFLOAT

Method used by ODE_NUMSOL and ODE_NUMSOL1 to convert arguments
to floating point representation.

&ODNS_INTERPOLATE default:'SPLINE

The method used by the procedure returned by ODE_NUMSOL1 for
calculating solutions of a differential equation.

Do DEMO(ODENSOL2); for a demonstration.

See also ODE_NUMSOL1.

&ODNS_MFE_OUTPUT default:'FALSE

Option variable that controls if ODE_NUMSOL places its numerical solution
in a DataViewer Section. If not FALSE,  ODNS_MFE_OUTPUT is the name of an
MFE variable that holds the ODE_NUMSOL solution of the differential
equation.

&ODNS_MFE_PLOT default:'FALSE

Option variable that controls if ODE_NUMSOL shows a solution of a
differential equation in "progress." The resulting plot is in an MFE
graphics section.

Displays single differential equations only.

Do DEMO(ODENSOL1); for an example;

&ODNS_NAMELIST

A list that describes the name transformations used by ODE_NUMSOL
between the original dependent variables in the different equations,
and the variables in the first order system of equations used in the
numerical solution.

This list is for information purposes only.

&ODNS_VARS

A list that describes the names of variables in the first order
system of equations that ODE_NUMSOL introduces to solve numerical
differential equations.

This list is for information purposes only.

&ONE_OF(ITEMS, PROMPT, ABORTP, PREFERRED_STYLE)

Enables the user to select an element from the list ITEMS.

 - If ITEMS is the empty list [], then ONE_OF returns FALSE
   immediately (or if ABORTP is TRUE, then aborts). 

 - If ITEMS is a single-element list, then ONE_OF returns that
   element without querying the user for confirmation. 

 - In all other cases, ONE_OF calls SELECT_ONE_OF so that the user
   can decide which ITEM to choose.

DO EXAMPLE(ONE_OF); for an example.

See also SELECT_ONE_OF.

&OP(exp)

Returns the operator of exp.  OP(exp); returns the same answer as
PART(exp,0); .  OP is affected by INFLAG.

See also OPERATORP, PART.  

&OPALG

The operator algebra package, for manipulating algebraic, differential
and integral operators.  This includes the partial differentiation
package.

Do USAGE(OPALG); for more information.

Do DEMO(OPALG); for a demonstration.

&OPERATOR

See OPERATORS

&OPERATORP(expr, op)

Returns TRUE if op is the main operator in the expression expr.

OPERATORP(expr, list-of-operators) similarly returns TRUE if
one of the operators in list-of-operators is the main operator in the
expression expr.

OPERATORP is affected by the INFLAG switch.

Examples:

The following all return TRUE:

 OPERATORP(X+Y, "+");
 OPERATORP(SIN(X), ['SIN,'COS]);
 OPERATORP(F[I](X),F[I]);
 BLOCK([INFLAG:TRUE],OPERATORP(X/Y,"*"));

The following all return FALSE:

 OPERATORP(X+Y, "*");
 OPERATORP(1,"+");

Do EXAMPLE(OPERATORP); for an executable example.

See also OP.

&OPERATORS

Macsyma uses the standard operators.

Arithmetic operators: the four basic operations + , - , * , / , and
  ^  (or **) for exponentiation,
  .  for non-commutative multiplication,
  ^^ for non-commutative exponentiation,
  !  for factorial,
  !! for double factorial.

Equality inequality operators: = , # , > , < , >= , <= .

When named as operators by the user, all of the operators above
should be referred to as quoted strings, such as "+" and "*".  This
enables Macsyma to determine that the operators are not active in
the normal way.

Logical operators: AND, OR, NOT .

Assignment operators:
   :  for variable assignment (e.g. A:3 sets A to 3).
   := for function definition (e.g. F(X):=SIN(X) defines a function F).
   :: for variable assignment, where the value on the right is assigned
      to the value of the expression on the left (e.g. A:B, A::3 sets B to 3).
  ::= for macro definition.

Macsyma enables users to define their own operators.  Do
USAGE(OPERATORS); for more information.

Macsyma has an operator algebra package.

Do USAGE(OPALG); for more information.

Note: In Macsyma, the term "operator" refers to a function which is
represented by an operator symbol located between each consecutive
pair of its arguments, as in A + B or A * B * C.

&OPPROPERTIES

The list of the special operator-properties handled by the Macsyma
simplifier: LINEAR, MULTILINEAR, ADDITIVE, MULTIPLICATIVE, OUTATIVE,
EVENFUN, ODDFUN, COMMUTATIVE, SYMMETRIC, ANTISYMMETRIC, NARY,
LASSOCIATIVE, RASSOCIATIVE, IDEMPOTENT, INVOLUTION, SKEW_DOT_MULT,
DERIVATION, and ANTIDERIVATION.

Do USAGE(PROPERTIES); for an overview of Macsyma commands to manage
properties of symbols.

&OPPROPERTY

See OPPROPERTIES.

&OPSCALAR

[OPALG package] A variable which is DECLAREd to have the OPSCALAR
property is treated as a scalar with respect to the operator algebra.
(The existing SCALAR property uses simplifications which are sometimes
inconsistent with operator algebra.)  OPSCALAR is a member of the
FEATURES property list, can be detected with the function OPSCALARP,
and can be removed with REMOVE.

&OPSCALARFUN

[OPALG package] A variable which is DECLAREd to have the OPSCALAR
property is treated as a scalar with respect to the operator algebra.
An OPSCALARFUN is a function which, when applied to its arguments, is
declared to return an OPSCALAR.  OPSCALARFUN is a member of the
FEATURES property list, can be detected with the function OPSCALARP,
and can be removed with REMOVE.

&OPSCALARP(exp)

[OPALG package] Returns TRUE if the expression exp is OPSCALAR; that
is, exp is one of the following:
 - a number (including rational numbers, bigfloats, etc.)
 - a symbol that is declared CONSTANT, OPSCALAR, or INTEGER, but
   is not the name of a function.
 - a functional form f(x), where f is declared OPSCALARFUN
 - an expression op(arg1,...,argn), where op is not one of
   DIFFOP, INTEGOP, or CONSTOP, and OPSCALARP(argi) is TRUE 
   for all i.

&OPSUBST(operator1, operator2, expr)

Acts like SUBST, except that it only substitutes for the operators in
the expression expr.  The operators substituted for must be symbolic
atoms, e.g.  OPSUBST(A,B[1],B[1](x)); is not supported.  Alternative
syntaxes are:

 - OPSUBST(eqn, expr) where eqn is an equation;
 - OPSUBST([eqn1, ..., eqnk], expr) where each of eqn1,...,eqnk are
   equations.

OPSUBST default:TRUE
  If FALSE, SUBST will not attempt to substitute into the operator of
  an expression, such as an array name.  
  Example:
   OPSUBST:TRUE     SUBST(X^2,R,R+R[0])); -> x^2 + (x^2)[0]
   OPSUBST:FALSE    SUBST(X^2,R,R+R[0])); -> x^2 + r[0] .

The basic arithmetic operators are specified as arguments to OPSUBST by
enclosing them in double quotes, as "+", "-", "*", "/" "=" .

Note that you cannot substitute "-" (minus) for "+" (addition operator),
because "-" is a unary operator (operating only on one argument), while
"+" is a nary operator (operating on n arguments).  Nor can you substitute
"+" for "-".

Do EXAMPLE(OPSUBST); for an example.

&OPTIMIZE(exp)

Returns an expression that produces the same value and side effects as
exp but does so more efficiently by avoiding the recomputation of
common subexpressions.  OPTIMIZE also has the side effect of
"collapsing" its argument so that all common subexpressions are
shared.

Do EXAMPLE(OPTIMIZE); for an example.

See also HORNER, COUNT_OPS.

&OPTIMPREFIX default:%

The prefix used for generated symbols by the OPTIMIZE command.

&OPTIONS()

Enters the OPTIONS network, which is a structured list of Macsyma
commands.  The top of the structure is a list of subjects.  You select
a subject from a menu (with the mouse or by typing its number followed
by a ";", depending on which version of Macsyma you have) to see the
list of commands available for that subject.  Selecting a command from
the list displays a menu of the switches and options associated with
that command.  To move back up the structure, the menu choice BACK (or
typing BACK;, depending on which version of Macsyma you have) goes
back up one level, and TOP gets you back to the top of the structure.
EXIT quits out of OPTIONS.

OPTIONS(command); gives the various commands and switches associated
with command.

&OPTIONSET default:FALSE

If TRUE, Macsyma will print out a message whenever a Macsyma option is
reset.  This is useful if the user is doubtful of the spelling of some
option and wants to make sure that the variable he assigned a value to
was truly an option variable.

&OPTMIZ

The OPTMIZ package finds the stationary points of a multivariate
objective function, either unconstrained or subject to equality and/or
inequality constraints.  The main user-level function is STAP.

Do USAGE(OPTMIZ); for more information.

Do DEMO(OPTMIZ); for a demonstration.

&OPTVAR

The OPTVAR package finds analytical solutions to various problems in
the calculus of variations, including optimal control problems.

Do USAGE(OPTVAR); for more information.

Do DEMO(OPTVAR); for a demonstration.

&OR

Used in predicates along with AND and NOT.

&ORDERGREAT(V1, ..., Vn)

Sets up aliases for the variables V1, ..., Vn such that V1 > V2 > ...
> Vn > any other variable not mentioned as an argument.  Note that the
ORDERGREAT/ORDERLESS system does not affect the mathematical
comparisons "<" and ">", but only affects the ordering predicates
ORDERGREATP and ORDERLESSP.  The ordering is canceled by UNORDER().

Do EXAMPLE(ORDERGREAT); for an example.

See also ORDERLESS, ORDERGREATP, ORDERLESSP, UNORDER, CANONLT, SORT.
See also MAINVAR for another ordering scheme.

&ORDERGREATP(exp1, exp2)

Returns TRUE if exp2 precedes exp1 in the ordering set up with the
ORDERGREAT function.

See also PREDICATES.

&ORDERLESS(V1, ..., Vn)

Sets up aliases for the variables V1, ..., Vn such that V1 < V2 < ...
< Vn < any other variable not mentioned as an argument.  Thus the
complete ordering scale is: numerical constants < declared constants <
declared scalars < first argument to ORDERLESS < ...  < last argument
to ORDERLESS < variables which begin with A < ...  < variables which
begin with Z < last argument to ORDERGREAT < ... < first argument to
ORDERGREAT < declared MAINVARs.  Note that the ORDERGREAT/ORDERLESS
system does not affect the mathematical comparisons "<" and ">", but
only affects the ordering predicates ORDERGREATP and
ORDERLESSP. The ordering is canceled by UNORDER(). 

Do EXAMPLE(ORDERLESS); for an example.  

See also ORDERGREAT, ORDERLESSP, ORDERGREATP, UNORDER, CANONLT, SORT.
See also MAINVAR for another ordering scheme.

&ORDERLESSP(exp1, exp2)

Returns TRUE if expression exp1 precedes expression exp2 in the
ordering set up by the ORDERLESS command.

See also PREDICATES.

&ORDINAL_STRING(integer)

Returns the string representing the ordinal value of integer.

 (c1) ORDINAL_STRING(42);
 (d1)                       forty-second

See STRING_SUMMARY for related comnands.

&ORTHPOLY_WEIGHT(function_name, indices, var)

[SPECFUN package] Returns the weight function W(var) for the 
indicated family of orthogonal functions.  indices is the appropriate
superscripts and subscripts for the function as specified in the
documentation for each family of orthogonal functions, separated
by commas.

&OUTATIVE

If DECLARE(F,OUTATIVE) has been executed, then:

 - If F is univariate, whenever the simplifier encounters F applied
   to a product, that product will be partitioned into factors that
   are constant and factors that are not and the constant factors will
   be pulled out.  I.e. F(A*X); will simplify to A*F(X) where A is a
   constant.  Non-atomic constant factors will not be pulled out.

 - If F is a function of 2 or more arguments, outativity is defined as
   in the case of 'SUM or 'INTEGRATE, i.e. F(A*G(X),X); will simplify
   to A*F(G(X),X) for A free-of X.  Initially, 'SUM, 'INTEGRATE, and
   'LIMIT are declared to be OUTATIVE.  OUTATIVE is a member of
   OPPROPERTIES.

It can be asserted with DECLARE, withdrawn with REMOVE, and detected
with GETPROP.

Do EXAMPLE(OUTATIVE); for an example.

&OUTCHAR default:d

The alphabetic prefix of the names of outputted expressions.

See also INCHAR and LINECHAR.

&OUTERMAP(fn, list1, ...)

A generalization of FULLMAPL, that maps over lists and matrices.  With
just two arguments, it's the same as FULLMAPL.  If OUTERMAP is given
three or more argument and at least one argument (not including the
first) is a list, then it takes the Cartesian product of the second
through last arguments, and maps the first argument over the
products.

Examples:

 (c1) FULLMAPL("=",[A,B],[1,2]);
 (d1)                        [a = 1, b = 2]
 (c2) OUTERMAP("=",[A,B],[1,2]);
 (d2)               [[a = 1, a = 2], [b = 1, b = 2]]

Do EXAMPLE(OUTERMAP); for an example.

&OUTOFPOIS(A)

[POISSON package] converts A from Poisson encoding to general
representation.  If A is not in Poisson form, it will make the
conversion, i.e.  it will look like the result of
OUTOFPOIS(INTOPOIS(A)).  This function is thus a canonical simplifier
for sums of powers of SIN's and COS's of a particular type.

Do EXAMPLE(OUTOFPOIS); for an example.

&PACK_HERM(mat {, UPLO})

Packs the input Hermitian matrix mat into 1 dimensional list. If UPLO
is 1 (default), it packs the lower triangular part, otherwise, the
upper triangular part.

This routine is used by NumKit.

&PACK_HERMMAT(mat {, UPLO})

Packs the input Hermitian matrix mat into a triangular matrix. If UPLO
is 1 (default), it packs the lower triangular part, otherwise, the
upper triangular part. The other triangular part is ignored and set to
zero. 

This routine is used by NumKit.

&PACK_SYM(mat {, UPLO})

Packs the input symmetric matrix mat into 1 dimensional list. If UPLO is 1
(default), it packs the lower triangular part, otherwise, the upper
triangular part.

This routine is used by NumKit.

&PACK_SYMMAT(mat {, UPLO})

Packs the input symmetric matrix mat into a matrix. If UPLO is 1
(default), it packs the lower triangular part, otherwise, the upper
triangular part. The other triangular part is ignored and set to zero.

This routine is used by NumKit.

&PACKAGEFILE default:FALSE

Package designers who use SAVE or TRANSLATE to create packages (files)
for others to use may want to set PACKAGEFILE:TRUE$ to prevent
information from being added to Macsyma's information-lists (e.g.
VALUES, FUNCTIONS) except where necessary when the file is loaded in.
In this way, the contents of the package will not get in the user's
way when he adds his own data.  Note that this will not solve the
problem of possible name conflicts.  Also note that the flag simply
affects what is output to the package file.  Setting the flag to TRUE
is also useful for creating Macsyma INIT files.

&PADE(taylor-series, num-deg-bound, denom-deg-bound)

Returns a list of all rational functions which have the given
Taylor-series expansion where the sum of the degrees of the numerator
and the denominator is less than or equal to the truncation level of
the power series, i.e.  are "best" approximants, and which
additionally satisfy the specified degree bounds.  Its first argument
must be a univariate Taylor-series; the second and third are positive
integers specifying degree bounds on the numerator and denominator.

PADE's first argument can also be a Laurent series, and the degree
bounds can be INF which causes all rational functions whose total
degree is less than or equal to the length of the power series to be
returned.  Total degree is num-degree + denom-degree.  Length of a
power series is "truncation level" + 1 - minimum(0,"order of series").

Do EXAMPLE(PADE); for an example.

&PAGEPAUSE(more_message, continue_message)

Does pausing such as what happens at an end-of-page.  Arguments are
optional.

&PARAMPLOT(x-exprs, y-exprs, var, var-range, optional-args)
or 
PARAMPLOT([[x1,y1],...,[xn,yn]], var, var-range, optional-args)

Plots parameterized curves in two dimensions.

Arguments for first calling syntax:

  - x-exprs is a list of expressions in the variable var,
    [x-expr1, x-expr2, .. ,x-expri, .. ,x-exprn] .
  - y-exprs is of the same form,
    [y-expr1,y-expr2, .. ,y-expri, .., y-exprk] .

  max(n,k) curves will be plotted.  They will be (assuming n > k):
     x-expr1 vs. y-expr1, .. ,x-exprk vs. y-exprk,
     x-expr(k+1) vs. y-exprk, .. ,x-exprn vs. y-exprk

  The syntax for the first two arguments is the same as that for the
  first argument to PLOT.

Arguments for second calling syntax:

  The first argument is a list of pairs of expressions
  [xi(var), yi(var)] which depend on the variable var.  Each pair is
  plotted as the horizontal and vertical coordinate of a paramterized
  curve.  

  This is the same calling syntax as is used by PLOTSURF and
  by PARAMPLOT3D. 

The format for the remaining arguments is the same as for PLOT.
PARAMPLOT calls either PARAMPLOT2 or CHAR_PARAMPLOT, depending on your
terminal type (usually PARAMPLOT2 for bit-mapped display terminals and
CHAR_PARAMPLOT otherwise). 

Do EXAMPLE(PARAMPLOT); for an example.

See also PARAMPLOT3D.  See PLOTTING_SUMMARY for an overview of plotting
capabilities in Macsyma.

&PARAMPLOT2(x-exprs, y-exprs, variable, var-range, optional-args)

Plots x-exprs as the x coordinate against y-exprs as the y coordinate.

The format for the first two arguments is the same as that for the
first argument to PLOT2.  Thus if x-exprs is [x-expr1, x-expr2, ..
,x-expri, .. ,x-exprn] and y-exprs is [y-expr1,y-expr2, .. ,y-expri, ..,
y-exprk], then max(n,k) curves will be plotted.  They will be
(assuming n > k):
   x-expr1 vs. y-expr1, .. ,x-exprk vs. y-exprk,
   x-expr(k+1) vs. y-exprk, .. ,x-exprn vs. y-exprk

The format for the remaining arguments is the same as for PLOT2.

PARAMPLOT2(x-funs, y-funs, var-range, optional-args)
  Efficiently evaluates its first 2 arguments in the same way that the
  alternative form of PLOT2 works.

Examples
  TRANSLATE:TRUE;       causes automatic translation
  F(X):=(MODE_DECLARE(X,FLOAT),COS(X)); 
  G(X):=(MODE_DECLARE(X,FLOAT),SIN(X));
  PARAMPLOT2(F,G,0,2*%PI); plots F(x) vs G(x) as x goes from 0 to 2*%PI

  PARAMPLOT2(SIN(T),COS(T),T,0,2*%PI); plots sin(T) for the x-axis and
  cos(T) for the y-axis as T takes on PLOTNUM values between 0 and
  2*%PI.  (If EQUALSCALE is TRUE this draws a circle.)

&PARAMPLOT3D([[xexpr,yexpr,zexpr]], var, varlow, varhigh)

Generates parametric plots of curves embedded in three dimensional
space.  One curve is specified by the expressions XEXPR, YEXPR, and
ZEXPR, and parameterized by the variable var.  The limits on the curve
parameter var are varlow and varhigh.  Multiple curves can be plotted
with one call to PARAMPLOT3D by giving a list-of-lists such as
[[xexpr1,yexpr1,zexpr1],[xexpr2,yexpr2,zexpr2]] as the first argument
to PARAMPLOT3D.

Alternatively, each curve can also be expressed as a function which
returns a list of three floating point numbers.  If only one curve is
plotted, no list brackets are needed.  Multiple curves can be
represented as a list of such functions.

PLOTNUM default:100
  Is the number of points PARAMPLOT3D plots.

Do EXAMPLE(PARAMPLOT3D); for an example.

See also PARAMPLOT.  See PLOTTING_SUMMARY for a summary of plotting
capabilities in Macsyma.

&PARSEWINDOW default:10

The maximum number of "lexical tokens" that are printed out on each
side of the error-point when a syntax (parsing) error occurs.  This
option is especially useful on slow terminals.  Setting it to -1
causes the entire input string to be printed out when an error occurs.

&PARETO_DENSITY(x, x0, theta)

[UNIPROB package] The density function

    theta*(x0/x)^theta/x.

See also PARETO_DISTRIB.

&PARETO_DISTRIB(x, x0, theta)

[UNIPROB package] The distribution function for the PARETO_DENSITY.

See also PARETO_DENSITY and INV_PARETO_DISTRIB.

&PART(exp, n1, ..., nk)

Returns the part of expression exp as specified by the indices
n1,...,nk.  First part n1 of exp is obtained, then part n2 of that,
etc.  The result is part nk of ... part n2 of part n1 of exp.  Thus
PART(Z+2*Y,2,1) returns 2.  PART can be used to obtain an element of a
list, a row of a matrix, etc.

PART is affected by the setting of INFLAG.

If the last argument to a Part function is a list of indices then
several subexpressions are picked out, each one corresponding to an
index of the list.  Thus PART(X+Y+Z,[1,3]) is Z+X.

PIECE holds the last expression selected by using the Part
functions.

If PARTSWITCH (default:FALSE) is set to TRUE then END is returned when
a selected part of an expression doesn't exist, otherwise an error
message is given.

Do EXAMPLE(PART); for an example.

See also PIECE, DPART, INPART, LPART, PICKAPART, REVEAL,
FIRST_ELEMENTS, LAST_ELEMENTS.

&PARTFRAC(exp, var)

Expands the expression exp in partial fractions with respect to the
main variable, var.  PARTFRAC does a complete partial fraction
decomposition.  The algorithm employed is based on the fact that the
denominators of the partial fraction expansion (the factors of the
original denominator) are relatively prime.  The numerators can be
written as linear combinations of denominators, and the expansion
falls out.

Do EXAMPLE(PARTFRAC); for examples.

&PARTITION(exp, var)

partitions exp (which may be a sum, product, list, or whatever) into 
a list of two expressions.  The first is exp of only those ARGS 
(first level addends, factors, elements, ...) which are FREEOF var.  
The second element of the result is exp with only those args containing 
var.

PARTITION(exp, var, op) forces the operator of exp to be op.  E.g.,
PARTITION(poly, x, "+") will reliably separate the polynomial poly into
two polynomials, respectively free and dependent of x, whereas
PARTITION(poly, x) may not, because poly might degenerate to a monomial
which will be mistaken for a product or even an unpartitionable atom.

Examples:

    (c1) partition(2*a*x*f(x),x);

    (d1)                 [2 a, x f(x)]

    (c2) partition(a+b,x);

    (d2)                 [a + b, 0]

    (c3) partition(a+b,x,"*");

    (d3)                 [a + b, 1]


    (c4) partition([a,b,f(a),c],a); 

    (d4)                [[b, c], [a, f(a)]]

Do EXAMPLE(PARTITION); for other examples.

&PARTITION_LIST(lis, n1 {, n2})

Partitions elements of a list into sublists each of length n1,
shifting n2 elements forward for each sublist.  If n2 is not
specified, then it defaults to the value of n1.

For many cases, FLATTEN is an inverse operation to PARTITION_LIST.

Do EXAMPLE(PARTITION_LIST); for an example.

&PARTS

Macsyma has many facilities for extracting and manipulating parts of
large expressions or data structures; mapping functions over the parts
of expressions or lists; and making substitutions of one expression
for the parts of a list or expression.

In the MathHelp topic browser (at the top of the Macsyma window), you
can open the category PARTS AND TERMS to get lists of subtopics and
common commands. For each command listed, you can obtain a description
and an executable example.

See also PART, DPART, INPART, LPART, PIECE, SUBSTPART, SUBSTINPART,
PARTSWITCH.

&PARTSWITCH default:FALSE

If set to TRUE then END is returned when a selected PART of an
expression doesn't exist, otherwise an error message is given.

&PASCAL(n)

Returns a matrix whose upper-left half forms Pascal's triangle of
order n-1.  The whole matrix is a diamond-shaped section of Pascal's
triangle of order 2(n-1).  The general ijth element is given by
BINOMIAL(I+J-2,I-1).  These matrices have integer entries and so do
their inverses.  Pascal matrices of all orders have determinant 1, yet
they are ill-conditioned for inversion.

Do EXAMPLE(PASCAL); for an example.

&PAULI_C(arg)

[DIRACMAT package] Returns the 2-by-2 Pauli spin matrix corresponding 
to the symplectic form on 2-spinors (an antisymmetric 2-tensor) with
two upper indices if the sign of arg is positive, and two lower indices
if the sign of arg  is negative.

See also PAULI_SIGMA, PAULI_SIGMA1, DIRAC_C.

&PAULI_SIGMA(index1 {, index2, ... indexk})

[DIRACMAT package] Returns the 2-by-2 Pauli spin matrix corresponding the
product of the Pauli algebra elements sigma[index1] @ ... @ sigma[indexk]
where "@" means the Clifford product of the Pauli algebra (matrix
multiplication in the matrix representation).  The metric tensor is
assumed to have signature ( + + + ).  Each indexi specifies the spatial
index of a Pauli algebra element. 

PAULI_SIGMA uses the matrix representation determined by the value of the 
option variable DIRAC_REP.

Do DEMO(DIRACMAT); and DEMO(DIRACMAT1); for demonstrations.

See also PAULI_SIGMA1, DIRAC_GAMMA.

&PAULI_SIGMA1(index1 {, index2, ... indexk})

[DIRACMAT package] Returns the Pauli spin matrix corresponding the
antisymmetrized product of the Pauli algebra elements
sigma[index1] ^ ... ^sigma[indexk] where "^" means the antisymmetrized
Clifford product of the Pauli algebra.  The metric tensor is assumed to
have signature ( + + + ).  Each indexi specifies the spatial index of a
Pauli algebra element. 

DIRAC_GAMMA1 uses the matrix representation determined by the value of the 
option variable DIRAC_REP.

Do DEMO(DIRACMAT); and DEMO(DIRACMAT1); for demonstrations.

See also PAULI_SIGMA, DIRAC_GAMMA1.

&PAULI

For Pauli algebra, see ATENSOR.

For Pauli matrices and spinors, see USAGE(DIRACMAT).

&PAUSE(more_message, continue_message, flush_message)

Does DEMO-style pausing.  The message more_message is printed as a
user prompt to respond to the pause.  If the user presses the return
key or space bar, then the message continue_message is printed.  If
the user enters any other response, then the message flush_message is
printed, and the paused process aborts.

If flush_message is provided, and if the user asked to continue, then
the returned value is TRUE, else it is FALSE.  Otherwise, PAUSE always
returns TRUE.

See also PAUSE_PROMPT, READ.

&PAUSE_PROMPT default:"Pausing. Type Return to continue."

This string is used as a prompt by PAUSE and functions which call
PAUSE, such as DEMO and PLAYBACK(SLOW).

&PDELIE

This package analyzes differential equation systems using Lie symmetry
group methods.  The analysis starts by determining the symmetry
vectorfields for the particular differential system, be they geometric
or of Bessel-Haagen type.  The user may then compute structure
constants for Lie subalgebras generated by the symmetry vectorfields.
Lie algebras or subalgebras may then be used to reduce the
differential system to one involving fewer dependent and independent
variables.  This usually leads to either an ordinary differential
equation or an algebraic system.  The reduced equations sometimes can
be solved to give explicit symbolic solutions for the original system
of equations.  When the system is variational, the user may compute
the Noether conservation laws of the system.  The main commands in the
package are PL_SYMMETRY and PL_SOLVE.

Do USAGE(PDELIE); for more information.

The following demonstration files are available for PDELIE:
  DEMO(PDELIE); - introductory demonstration, the heat equation. 
  DEMO(PL_HEAT); - the heat equation.
  DEMO(PL_BLASIUS); - the Blasius nonlinear ordinary differential
    equation.
  DEMO(PL_KDVPAR); - the Korteweg de Vries equation with a scalar
    parameter.
  DEMO(PL_ONE_STEP); - a nonlinear partial differential equation.
  DEMO(PL_LAPLACE_3D); - the three-dimensional Laplace equation. 
  DEMO(PL_NLS); - a nonlinear system of partial differential
    equations. 

Another package called SYMMGRP is similar to PDELIE. It is available
separately from Macsyma. Do USAGE(SYMMGRP); for more information.

&PDERIVOP(NAME, NUM1, ..., NUMN)

[NDIFF and OPALG packages] The partial or positional derivative
operator.  It allows partial derivatives to be represented
positionally, as in "the derivative of f with respect to its first
argument," rather than symbolically as in "the derivative of f with
respect to x."

Do USAGE(NDIFF); and USAGE(OPALG); for more information.

Do DEMO(NDIFF); for a demonstration.

See also DIFF and GENDIFF.

&PERIMETER_POLYGON(vertex_coords)

[GEOFUNCS package] Computes the perimeter of a polygon which is
specified the its vertices.  The input vertex_coords specifies the
coordinates of N vertices, either as an N-by-2 matrix of pairs [x,y]
or as a list of lists of pairs [x,y].

Do EXAMPLE(PERIMETER_POLYGON); for an example.

&PERM_MAT(n, i, j {, A})

[MATRICE package] Creates the n x n permutation matrix/matrice P[i,j].
If a fourth argument is not provided then PERM_MAT will return the
specified permutation matrix as its value.  Otherwise, PERM_MAT will
create the specified permutation matrice and attach it to the symbol
A, returning as its value the description of the created matrice
provided by MATRICEINFO.

See also MATRICE.

&PERMANENT(mat, n)

Computes the permanent of the matrix mat.  A permanent is like a
determinant but with no sign changes.

Do EXAMPLE(PERMANENT); for an example.

&PERMULT(permlist1 {, permlist2, ...})

Multiplies the permutations represented by the lists permlist1,
permlist2, ... .  The permutations are applied to a list starting from
the right-most one and moving to the left.

See USAGE(PERMUTATIONS); for related commands.

Do EXAMPLE(PERMULT); for an example.

&PERMUTATION(n, r)

[ALGFUNCS package] Returns the number of permutations of r objects
taken from a population of n objects. n!/(n-r)!

&PERMUTATION_DECOMP(permlist)

Decomposes permutation permlist into a product of cycles.  The
permutation provided as input is represented as a list of all the
integers from 1 through N.  As input, the list [I1,I2,...,In]
represents the permutation 1->I1, 2->I2, ..., n->In.  The output is a
list of lists, where each of the inner lists is a cycle.  In the
output, the list [I1,I2,...,Ik] represents the cycle I1->I2,
I2->I3,..., Ik->I1.  The cyclic decomposition is in canonical form,
with the lowest integer in each cycle in the first position, and the
cycles ordered by their first elements.

The following variables are assigned values by PERMUTATION_DECOMP:

PERMUTATION_INDEX
  Is set equal to the index of the permutation, which is the number of
  transpositions in the permutation. 

PERMUTATION_PARITY
  is set to EVEN or ODD, if the permutation is even or odd.

Do EXAMPLE(PERMUTATION_DECOMP); for an example.

See USAGE(PERMUTATIONS); for related commands.

See also PERMUTATIONS, PERMUTATIONS_LEX, SORT.

&PERMUTATION_INDEX

PERMUTATION_DECOMP(permlist) sets this variable equal to the index of
the permutation permlist, which is the number of transpositions in the
permutation.

Do EXAMPLE(PERMUTATION_DECOMP) for an example.

See also PERMUTATION_DECOMP.

&PERMUTATION_PARITY

PERMUTATION_DECOMP(permlist) sets this variable equal to EVEN or ODD,
if the permutation permlist is even or odd.

Do EXAMPLE(PERMUTATION_DECOMP); for an example.

See also PERMUTATION_DECOMP.

&PERMUTATION_UNDECOMP(cycleslist)

Converts a list of cycles in normal form back to the undecomposed
permutation.  This function is the inverse of PERMUTATION_DECOMP.

Do USAGE(PERMUTATIONS); for related commands.

Do EXAMPLE(PERMUTATION_UNDECOMP); for an example.

&PERMUTATIONS(list_of_elements)

Returns a list consisting of all permutations of the elements in
list_of_elements.  The order of the permutations in the returned list
is not specified.

Do EXAMPLE(PERMUTATIONS); for an example. 

See USAGE(PERMUTATIONS); for related commands.

See also PERMUTATIONS_LEX, PERMUTATION_DECOMP, SET, SORT.

&PERMUTATIONS_LEX(list_of_elements)

Returns a list consisting of all permutations of the elements in
list_of_elements.  The permutations are returned in lexicographic
order.

Do EXAMPLE(PERMUTATIONS_LEX); for an example.

See also PERMUTATIONS, PERMUTATION_DECOMP, SORT.

&PERP_LINE_LINE(line1, line2)

[GEOFUNCS package] Finds the line segment from line {P + s*A | s real}
to the line {Q + t*A | t real} which is perpendicular to both lines.

Arguments: 

 - line1 is a list which specifies a line. It can have one of two forms.
   - [P, A] where P is an N-tuple of numbers or expressions, and 
     represents a point on a line in n-space. A is an N-tuple of numbers
     or expressions, and represents a vector in N-space.
   - [P, R, 'points], where P and R are N-tuples representing points
     on the line, and the symbol 'points indicates that R is interpreted
     as a point and not as a vector.
 - line2 is a list which specifies the second line, and can have the same
   structures as line1.

The function returns a list of length 3.  
 - The first two elements are each a list of length n which represents
   the intersection of the perpendicular segment with one of the lines
   line1 and line2.
 - The third element is the symbol 'points, which indicates that the 
   lists in the first two positions are to be interpreted as points.

Do EXAMPLE(PERP_LINE_LINE); for an example.

See also PERP_POINT_LINE.

&PERP_POINT_HYPERPLANE( point1, hplane)

[GEOFUNCS package] Computes the point at which the line through point1
and perpendicular to the hyperplane hplane intersects hplane.

Input:

 - point1 is a list of Cartesian coordinates of a point in N space.

 - hplane is a list of length N+1 of the form [a1, ..., aN, a0],
   which specify a hyperplane which satisfies the equation
   a1*x1 + ... + aN*xN = a0.

The function returns a list of length N which contains the Cartesian
coordinates of the intersection point.

Do EXAMPLE(PERP_POINT_HYPERPLANE); for an executable example.

&PERP_POINT_LINE(P, line1)

[GEOFUNCS package] Finds the line segment from point P which is
perpendicular to line {Q + t*A | t real}.

Arguments: 

 - P is an N-tuple (list) of numbers or expressions, and represents an
   isolated point in N-space.
 - line1 is a list which specifies a line. It can have one of two forms.
   - [Q, A] where Q is an N-tuple of numbers or expressions, and 
     represents a point on a line in N-space. A is a N-tuple of numbers
     or expressions, and represents a vector in N-space.
   - [Q, A, 'points], where Q and A are N-tuples representing points
     on the line, and the symbol 'points indicates that A is interpreted
     as a point and not as a vector.

The function returns a list of length n, which represents the point
where the perpendicular segment intersects the line {Q + t*A | t real}
which was specified in the input.

Do EXAMPLE(PERP_POINT_LINE); for an example.

See also PERP_LINE_LINE.

&PERSPECTIVE default:TRUE

When PERSPECTIVE is set to FALSE, the 3D plotting functions create
plots with a non-perspective view.  This is equivalent to extending
the viewing position out to infinity along the direction specified by
PLOT_PHI and PLOT_THETA, equivalently along the line connecting the
origin and VIEWPT. 

&PFAFFIAN(N, PLIST)

Returns the Pfaffian of its list argument.  N is an integer which
denotes the order of the Pfaffian to be expanded.  PLIST is a list
of the elements of the Pfaffian.  The Pfaffian is the square root of
the determinant of an antisymmetric matrix.  For example, consider
the matrix

                        |  0  A  B  C  |
                        | -A  0  D  E  |
                        | -B -D  0  F  |.
                        | -C -E -F  0  |

The Pfaffian is defined as the square root of the determinant of this
matrix.

You can evaluate the Pfaffian

                        |  A  B  C  |
                              D  E  |
                                 F  |

with the command    PFAFFIAN(3,[A,B,C,D,E,F]);

Do DEMO(PFAFF); for a demonstration of Pfaffians.

&PFEFORMAT default:FALSE

If TRUE causes rational numbers to display in a linear form and 
denominators which are integers to display as rational number 
multipliers.  PFEFORMAT stands for "Partial Fraction Expansion" format.

&PHYCON

The physical units package.  

See PHYSICAL_CONSTANTS.

&PHYSICAL_CONSTANTS

Macsyma has the following physical constants available:

%%a_0           Bohr radius
%E_b            Hartree Energy
%m_e            Electron Mass
%m_p            Proton Mass
%m_n            Neutron Mass                            
%%c             Speed of light in vacuum                
%epsilon_0      Vacuum permittivity             
%mu_0           Vacuum permeability
%%G             Gravitational constant                  
%%h             Planck's constant                       
%hbar           %h/(2*%pi)                              
%m_p            Planck mass
%l_p            Planck length
%T_p            Planck time
%%e             Elementary charge                       
%Phi_0          Magnetic Flux quantum
%alpha          Fine structure constant
%R_inf          Rydberg constant
%R_gas          Universal Gas constant
%N_a            Avogadro's Number mol^-1
%k_b            Boltzmann constant
%sigma          Stefan-Boltzmann constant
%c1             First radiation constant
%c2             Second radiation constant

The variable %PHYSICAL_CONSTANTS is a list of the names
of the physical constants in the PHYCON package.

Do INIT_PHYSICAL_CONSTANTS(); to make them accessible.
Do EXPUNGE_PHYSICAL_CONSTANTS(); to remove them.

PHYSICAL_CONSTANTS are also available in the UNITS package.

Do DEMO(PHYCON); for a demonstration.

See also MATHEMATICAL_CONSTANTS.

&PHYSICS

Many of Macsyma's facilities can be used to perform computations 
in physics.  

For a listing of worked demonstration problems in physics, see 
DEMOS_PHYSICS.

The FEYNBOUN package determines the asymptotic behavior of Feynman
integrals.

The DIRACMAT package generates and manipulates Dirac matrices. 

The ITENSOR and CTENSOR packages are particularly useful for 
general relativity and continuum mechanics.

&PI

"pi" is represented in Macsyma as %PI.

&PICKAPART(exp, depth)

Assigns E labels to all subexpressions of exp down to the specified
integer depth.  This is useful for dealing with large expressions and
for automatically assigning parts of an expression to a variable
without having to use the part functions.  The setting of INFLAG also
affects PICKAPART.

Do EXAMPLE(PICKAPART); for an example.

See also REVEAL.

&PIECE

Holds the last expression selected when using the Part functions.  It
is set during the execution of the function and thus may be referred
to in the function itself.

&PINV(mat)

[GENINV package] Computes the Moore-Penrose generalized inverse (or
pseudoinverse) of the matrix mat.  This implementation is based on
work by Dr. Daniel Zwillinger and Dr. Michael J. Sousa.

PINV_RANK
  A global variable which contains the rank of the matrix as computed
  by PINV.

PINV_TOL default:1.0e-5
  The tolerance used to determine when the algorithm terminates when
  the matrix contains floating-point numbers and KEEPFLOAT:TRUE.
  Note:  although PINV will execute the inversion algorithm in
  floating-point arithmetic, it will usually fail due to round-off
  error.  It is advisable to rationally approximate floats (either
  explicitly, via RAT, or implicitly, by not setting KEEPFLOAT:TRUE)
  when computing the pseudo-inverse and return to floating- point
  representation via BFLOAT and/or SFLOAT/DFLOAT.

Do USAGE(GENINV); for more information.

Do EXAMPLE(PINV); for an example.

&PL_SOLVE(vector1 {, vector2, ...})

[PDELIE package] Finds solutions of a (system of ) PDEs, using Lie
symmetry vectors found by PL_SYMMETRY.

Do USAGE(PDELIE); for more information.

&PL_SYMMETRY(PL_EQ, PL_DV, PL_IV, PL_PAR, PL_VL)

[PDELIE package] Initiates computation of the Lie symmetry vectors of
a system of partial differential equations.  It returns a list of all
symmetry vectors of the system. After finding the Lie symmetry vector
fields, the function PL_SOLVE can sometimes compute exact solutions
to the PDE's in the list PL_EQ.

Do USAGE(PDELIE); for more information.

&PLAYBACK(arg)

"Plays back" input and output lines.  If arg=n (a number) the last n
expressions (Ci, Di, and Ei count as 1 each) are "played-back", while
if arg is omitted, all lines are.  If arg=INPUT then only input lines
are played back.  If arg=OUTPUT then only output lines are played
back.  If arg=[m,n] then all lines with numbers from m to n inclusive
are played-back.  If m=n then [m] is sufficient for arg.

PLAYBACK accepts keywords which modify its behavior.

 - SLOW causes the PLAYBACK to appear in line-at-a-time mode similar
   to the  DEMO command, in which Macsyma waits after each line for 
   the user to press a key before continuing.  This is useful in
   conjunction with SAVE or STRINGOUT when creating a
   secondary-storage file in order to pick out useful expressions.  

 - TIME causes the computation times to be displayed with each
   command. 

 - GCTIME or TOTALTIME causes PLAYBACK to display a complete breakdown

 - GRIND causes the STRINGed version of input to be shown in a more
   readable format.  (See GRIND.)

One may include any number of options as in
PLAYBACK([5,10], 20, TIME, SLOW).

Do EXAMPLE(PLAYBACK); for an example.

&PLOG(X) - this function is obsolete.

&PLOT(y-exprs, variable, var-range, optionals-args)

Plots y-exprs on the y axis as variable (the x axis) takes on values
specified by var-range.

y-exprs can take one of two forms:

  i.  expr plots a curve of expr against variable
 ii. [expr1,expr2, .. ,expri, .. ,exprn] plots n curves of expri
     against variable. expri gets evaluated in the context
     FLOAT(EV(expri, variable=value gotten from var-range, NUMER)).
     It is an error if this doesn't result in a floating point number.

var-range can have the following forms:

  i. low,high, where low and high evaluate to numbers.  low may be
     either greater or less than high.  variable will take on PLOTNUM
     values equally spaced between low and high.
     (Note that the first argument will be evaluated at low first e.g.
     PLOT2(1/X,X,-1,-3); calculates 1/(-1.0) before 1/(-3.0). This will
     only make a difference if the computation of the first arg changes a
     variable which changes the value returned by subsequent computation.
     Whether or not low < high, min(low,high) will be on the left of the
     plot.)
 ii. low,high,INTEGER.  As in i), except variable will take on all
     integer values between low and high inclusive.
iii. [val1,val2, ... , valn] .  variable takes the values specified
     by the list
 iv. arrayname where arrayname is the name of a declared
     floating-point one-dimensional array (i.e. declared by
     ARRAY(arrayname,FLOAT, max-index);).  variable takes the values from
     arrayname[0] thru arrayname[max-index] (max-index is the maximum index
     of arrayname

optional-args can be any of the following:

   i. X-Label, Y-Label or Title descriptor (three "strings", in the order
      in which they appear in the argument list.  FALSE means no label.)
  ii. Line type descriptor
 iii. FIRST, SAME and LAST
  iv. POLAR, LOG, LINLOG, LOGLIN

The optional arguments may appear in any order.  The rule for evaluation
of the optional args is as follows.  If the argument is atomic it gets
evaluated.  The resulting arguments are the ones that get used.

PLOT calls one of two 2-d plotting functions (PLOT2 and CHAR_PLOT),
depending on which is appropriate for your terminal type (usually PLOT2
for bit-mapped display terminals and CHAR_PLOT otherwise).

Do EXAMPLE(PLOT); for an example.

See also PLOT2, PLOT3D.  See PLOTTING_SUMMARY for a summary of plotting
capabilities in Macsyma.

&PLOT_3D_FIGURE(figname_, displace_, scale_ {, angles_})

Plots some standard geometric figures in 3D. The input arguments are:

 - figname_ is the name of the geometric figure to be plotted. 
     Current choices include 'ANNULUS, 'ASTROIDAL_ELLIPSE, 'CYLINDER,
     'CUBE, 'ICOSAHEDRON, 'MOEBIUS_STRIP, 'SPHERE, 'TORUS.

 - displace_ is a list of 3 numbers which are the coordinates
     of the center of the annulus.

 - scale_ is a single positive number or a list of three numbers
     which give the scaling of the figure in three directions.

     For an annulus, Moebius band or torus, scale_ can be a list 
     of 4 positive numbers, where the fourth number is the ratio 
     of the width (or outer radius) of the annulus, Moebius band 
     or torus to the inner radius.  
     If not specified, this ratio defaults to 0.3333.

 - angles_ consists of one, two or three rotation angles expressed
   in radians (optional).

Do EXAMPLE(PLOT_3D_FIGURE); for an example.

&PLOT_ANIMATE(param, lo, hi, plot_command {, optional-args})

Animates the plot_command with animation parameter param, which varies
between lo and hi values during the animation.  plot_command can any
static Macsyma 2D or 3D plot command, where the parameter param is
included in the plotted expression.

Optional-args can have the value CYCLIC. When the animated figure is a
periodic function of the animation variable param, CYCLIC causes the
animation to run smoothly through points where param changes from hi
to lo.

Do EXAMPLE(PLOT_ANIMATE); for an example.

See also PLOTNUM_ANIMATE.

&PLOT_COMPILE_FUNCTIONS default: 80

The plotting commands (e.g. PLOT, CONTOURPLOT, etc.) automatically
compile plot functions if they will be evaluated this many times or more.

In versions of Macsyma without a compiler, try setting
PLOT_COMPILE_FUNCTIONS to FALSE.

See also PLOTTING_SUMMARY.

&PLOT_DATA(mat)

Plots a matrix of data as functions of the integer matrix indexes as
coordinates.

Do EXAMPLE(PLOT_DATA); for an example.

&PLOT_FILE default:"macsyma.plt"

(Macsyma 419 and successors) In versions of Macsyma with file-based
graphics, this option variable stores the name of the file which the
plotting commands write when a plot file is generated.

&PLOT_NOW default:TRUE

When a plotting command is given, Macsyma computes the plot data (and
stores it in a file in versions with file-based graphics).  If when
PLOT_NOW:TRUE, then Macsyma draws the image in a plot window
immediately.  When false, Macsyma does not display the plot.  The plot
can be displayed using REPLOT(); (or REDRAW_PLOT_FILE in version with
file-based graphics).

&PLOT_ODE(DE, Y, X, IC, X0, X1, DX {, METH})

Plots the numerical solution Y of the differential equation DE 
vs. the independent variable X from X0 to X1. ODE_NUMSOL performs the
numerical integration using default stepsize DX and optional method METH.
Numerical data from the solution is available in the Macsyma
arrays ODNS_XP and ODNS_YP. 

Do USAGE(ODE_NUMSOL); for more information.

Do EXAMPLE(PLOT_ODE); for an example.

See also ODE_NUMSOL.

&PLOT_OPTIONS

A system variable which stores a list of the option variables which
affect plotting.

See also PLOTRESET.

&PLOT_PHI default:30

Determines the angle of rotation in the x-y plane of the viewpoint
of a 3D plot. The angle is expressed in degrees.  PLOT_PHI:0 means
that you view the plot from the positive x-axis direction.

Do EXAMPLE(PLOT_PHI); for an example.

See also PLOT_THETA, VIEWPT.

&PLOT_ROLL default:0.

The angle of rotation (in degrees) of a plotted image about the line
of sight.  When using the default viewpoint (VIEWPT) in the first
octant, for which PLOT_PHI:30 and PLOT_THETA:30, a value of zero
means that the X-Y plane is horizontal. 

Do EXAMPLE(PLOT_ROLL); for an example.

See also PLOT_PHI, PLOT_THETA, VIEWPT and CENTERPLOT.  See 
PLOTTING_SUMMARY for a summary of the plotting capabilities in
Macsyma.

&PLOT_SIZE default:FALSE

Determines the size of the plotted object as a percentage of the
linear size of the plotting window in the Macsyma Graphics package.
PLOT_SIZE must be an integer between 2 and 2000 inclusive.

Do EXAMPLE(PLOT_SIZE); for an example.

&PLOT_STYLE default: FALSE

Determines the plot style (group of MFE attributes) applied to the MFE
graphic. Built-in plot styles in Macsyma include
     
      Midnight
      Outer_Space
      Scientific2D
      Scientific3D
      Sky_Blue
      Slide2D
      Slide2D_NoGrid
      Slide3D
      Slide3D_NoGrid
      White_Space
      X_dollar
      X_hour
      X_percent
      Y_dollar
      Y_hour
      Y_percent

Do EXAMPLE(PLOT_STYLE); for examples of different graphics styles.

&PLOT_TESSELLATION default:4

A value of 4 means that two-dimensional surfaces are tessellated with
quadrilaterals.  A value of 3 means that two-dimensional surfaces are
tessellated with triangles.  Currently PLOT_TESSELLATION affects the
behavior of PLOTSURF, and not PLOT3D.

Do EXAMPLE(PLOT_TESSELLATION); for an example.

See PLOTTING_SUMMARY for a summary of the plotting capabilities in
Macsyma.

&PLOT_THETA default:30

Determines the angle of elevation above the x-y plane of the viewpoint
of a 3D plot. The angle is expressed in degrees.  PLOT_THETA:0 means
that you view the plot from the x-y plane.

Do EXAMPLE(PLOT_THETA); for an example.

See also PLOT_PHI, VIEWPT.

&PLOT_VECT_HEAD default:TRUE

When this option variable is set to FALSE, PLOT2_VECT and
PLOT3D_VECT plot direction fields instead of vector fields.  The
shaft of each arrow is centered at the plot point, and no head is
drawn.

&PLOT_VECT_HEAD_ANGLE default:0.5236

A floating point number which specifies the angle between the shaft of
the vector and head edges of the head of the vector.

&PLOT_VECT_HEAD_SIZE default:0.100

A floating point number which specifies the length of the edges of the
vector head, as a fraction of the length of the vector shaft.

&PLOT_VECT_NUM_MULTIPLE default:0.5

A numerical multiplier used to scale PLOTNUM0 and PLOTNUM1, used in
PLOT2_VECT. This option variable affects the density and location of points
used to draw vector plots.

&PLOT_VECT_SCALE default:TRUE

Controls scaling of the lengths of vectors when plotted using
PLOT2_VECT and PLOT3D_VECT. It can have three types of values.

- FALSE -  Vectors are plotted with their actual lengths.  No
  re-scaling occurs.

- TRUE -  Vectors are plotted with lengths that are normalized
  to fit approximately in the region of the plot.  For example,
  if you plot on the unit square a vector field whose longest
  vector has length 100, then the entire vector field will be 
  rescaled so that is roughly fits in the unit square.

  When PLOT_VECT_HEAD:TRUE, PLOT2_VECT and PLOT3D_VECT return
  a floating point number, which is the factor by which the
  plotted vectors need to be multiplied to obtain the actual
  vectors before rescaling.

- The name of a univariate function - That function is applied
  to the length of the vector at each plot point, to rescale it.
  The function can be either a system function (such as 'LOG)
  or a user-defined function.  If the scaling function results
  in a negative number or negative infinity, for example 
  LOG(veclength<1) or LOG(veclength=0), then the length of the
  vector is set to zero. 

See also PLOT2_VECT, PLOT3D_VECT.

&PLOT2(y-exprs, variable, var-range, optionals-args)

Plots y-exprs on the y axis as variable (the x axis) takes on values
specified by var-range.

y-exprs can take one of two forms:

  i.  expr plots a curve of expr against variable
 ii. [expr1,expr2, .. ,expri, .. ,exprn] plots n curves of expri
     against variable. expri gets evaluated in the context
     FLOAT(EV(expri,variable=value gotten from var-range, NUMER)).
     It is an error if this doesn't result in a floating point number.

var-range can have the following forms:

  i. low,high, where low and high evaluate to numbers.  low may be
     either greater or less than high.  variable will take on PLOTNUM
     values equally spaced between low and high.
     (Note that the first argument will be evaluated at low first e.g.
     PLOT2(1/X,X,-1,-3); calculates 1/(-1.0) before 1/(-3.0). This will
     only make a difference if the computation of the first arg changes a
     variable which changes the value returned by subsequent computation.
     Whether or not low < high, min(low,high) will be on the left of
the
     plot.)
 ii. low,high,INTEGER.  As in i), except variable will take on all
     integer values between low and high inclusive.
iii. [val1,val2, ... , valn] .  variable takes the values specified
      by the list
 iv. arrayname where arrayname is the name of a declared
     floating-point one-dimensional array (i.e. declared by
     ARRAY(arrayname,FLOAT, max-index);).  variable takes the values from
     arrayname[0] thru arrayname[max-index] (max-index is the maximum index
     of arrayname

optional-args can be any of the following:

   i. X-Label, Y-Label or Title descriptor
  ii. Line type descriptor
 iii. FIRST, SAME and LAST
  iv. POLAR, LOG, LINLOG, LOGLIN

The optional arguments may appear in any order.  The rule for evaluation
of the optional args is as follows.  If the argument is atomic it gets
evaluated.  The resulting arguments are the ones that get used.

If you want to plot more than 3-4 curves on the same plot investigate
using the NOT3D option to PLOT3D.

Examples

  PLOT2(SIN(X),X,-%PI,%PI);     plots sin(X) against X as X takes on
                                PLOTNUM values between -%PI to %PI
  PLOT2(X!,X,0,6,INTEGER);      plots X! as X takes integral values
                                between 0 and 6
  PLOT2([X+1,X^2+1],X,-1,1);    plots 2 curves on top of each other

PLOT2(y-funs,var-range,optionals-args)
  is the alternative form for PLOT2.  y-funs must be a function of one
  argument or a list of functions of one argument.  The functions must
  be either translated or compiled functions which return a floating
  point number when it is given floating point arg (or integer arg if
  the INTEGER arg to PLOT2 is given).  This form of PLOT2 acts as
  though you had given a argument to the y-funs, and also specified
  that argument as the variable in the form above.  E.g.
  PLOT2(F,-2,2); acts like PLOT2(F(X),X,-2,2); This is supposed to
  provide a quicker evaluation of the first arg and for that reason NO
  checking is done on the result.  If the wrong kind of number is
  returned, the resulting plot will not be meaningful.

Example:

  TRANSLATE:TRUE;
  F(X):=(MODE_DECLARE(X,FLOAT),EXP(-X*X));
  PLOT2(F,-2,2);
  PLOT2(F,[-2,-1,0,1,2]); 
  ARRAY(V,FLOAT,10);
  FOR I FROM 0 THRU 10 DO V[I]:FLOAT(I*I);
  PLOT2(F,V);

Note:  PLOT2 does not work in some implementations.

See also PLOT.  

See PLOTTING_SUMMARY for a summary of the plotting capabilities in
Macsyma.

&PLOT2_VECT(vecfield, var1, min1, max1, var2, min2, max2
{, optional-args})  

Plots vector fields in two dimensions.

Do USAGE(PLOT_VECT); for more information.

Do EXAMPLE(PLOT2_VECT); for an example and DEMO(PLOT_VECT); for a
longer demonstration.

See also PLOT_VECT_SCALE, PLOT_VECT_HEAD, PLOT3D_VECT.

See PLOTTING_SUMMARY for a summary of the plotting capabilities in
Macsyma.

&PLOT3D(z-exprs, x-var, var0-range, y-var, var1-range {, optional-args})

Makes a 3-dimensional plot of z-exprs against x-var and y-var.
z-exprs can be a single expression or list of expressions.

The format of z-exprs is the same as for PLOT2.  The context of
evaluation is 

 FLOAT(EV(z-expri, x-var=value gotten from var0-range,
       y-var=value gotten from var1-range,NUMER)).

The format for var0-range and var1-range is the same as for PLOT2
except that if var0-range is of the form low,high then x-var will take
on PLOTNUM0 values, and if var1-range is of the form low,high then
y-var will take on PLOTNUM1 values.

The format of optional-args is the same as for PLOT2 except that
additional options NOT3D, \3D, and CONTOUR are available.

PLOT3D(z-funs,var0-range,var1-range,optional-args) is analogous to the
alternative form for PLOT2.  z-funs must be a function or list of
functions of 2 arguments, which must return a floating point argument
when given floating point (integer, if the INTEGER argument is used
for either var0-range or var1-range) arguments.  The functions must be
translated or compiled.  If you expect to make several 3D plots this
form is recommended.

 A simple example is 
  TRANSLATE:TRUE;       causes automatic translation
  G(X,Y):=(MODE_DECLARE(X,FLOAT),EXP(-X*X-Y*Y));   defines a function G
  PLOT3D(G,-2,2,-2,2);  plots it 

Do EXAMPLE(PLOT3D); for an example.

See also COMPLEX_PLOT3D, PLOTSURF, CONTOURPLOT, PLOTNUM0, PLOTNUM1,
CROSSHATCH, UNDERSIDE.  See PLOTTING_SUMMARY for a summary of the
plotting capabilities in Macsyma.

&PLOT3D_VECT(vecfield, var1,min1,max1, var2,min2,max2, var3,min3,max3
{, 'arg1,...,'argn})

Plots a three-dimensional vector field.

Arguments:

 - VECFIELD is a list of three expressions, for the three components
   of the vector field; or a list of three functions; or one
   function whose value is a list of three values.
 - VAR1, MIN1, MAX1 are the name and limits of the first variable.
 - VAR2, MIN2, MAX2 are the name and limits of the second variable.
 - VAR3, MIN3, MAX3 are the name and limits of the third variable.
 - 'ARGI are all the optional plotting variables allowed for the
   special form GRAPH3D. (However, placing plot symbols at each
   point will result in plotting the symbol at the head, tail, and
   arrow tips of each vector drawn.)

The option variables PLOTNUM0, PLOTNUM1 and PLOTNUM2 control the number
of plot points in the horizontal and vertical directions respectively.
If PLOTNUM2 is not specified, then PLOT3D_VECT assigns it the value of
PLOTNUM1.  The arguments MIN1, MIN2, MAX1, MAX2, MIN3 and MAX3 do not
control the plot size directly.  XMIN, XMAX, YMIN, YMAX, ZMIN and ZMAX
do this, as for other plotting functions.

Do USAGE(PLOT_VECT); for more information.

Do EXAMPLE(PLOT3D_VECT); for an example and DEMO(PLOT_VECT); for a
longer demonstration.

See also PLOT2_VECT.

See PLOTTING_SUMMARY for a summary of plotting capabilities in
Macsyma.

&PLOTBELL default:TRUE

When FALSE inhibits the dinging of the bell.

&PLOTBOUNDS default:TRUE

When TRUE, Macsyma plots display the maximum and minimum of X and Y
(and Z in 3D plots) at the bottom of the plots.  Setting PLOTBOUNDS to
FALSE suppresses display of the dataline.

&PLOTERROR default:TRUE

Governs what happens when Macsyma encounters an error while trying to
evaluate a plot point.
 - If PLOTERROR is TRUE, then an error occurs. 
   If DEBUGMODE is TRUE when this occurs, a Macsyma break is entered,
   and you can ask for the value of PLOTERROR, which is temporarily
   bound to the form being evaluated.  
 - If the value of PLOTERROR is a floating point number, then that
   value is used as the value of the erroneous form.
 - If PLOTERROR is FALSE, then the result is the value of
   PLOTUNDEFINED, and the plot point is skipped in the plotting.

PLOTERROR does not work when the plotted object is a compiled function.
Therefore it is usually necessary to set PLOT_COMPILE_FUNCTIONS: FALSE
when using PLOTERROR.

Do EXAMPLE(PLOTERROR); for an example.

See PLOTTING_SUMMARY for a summary of the plotting capabilities in
Macsyma.

&PLOTFACES(FACES)

Plots polygonal faces in 3 dimensions.  FACES is a list or array, 
declared or hashed, of polygonal faces, where 

 - each face is a list of points, and 
 - each point is a list of three [x,y,z] coordinates.  The coordinates 
   need not be floating point numbers.

In many cases, PLOTFACES is more convenient than PLOTSURF([NODES,FACES]),
because the FACES needn't be a complete array, or an array at all; and 
the nodes are computed for you.

Do EXAMPLE(PLOTFACES); for an example.

See also PLOTSURF.

&PLOTGAP default:20

Spacing between multiple plots on the same screen.  Units are the
`native' units of the display device, usually corresponding to pixels.

&PLOTHEIGHT default:24

For the character plotting commands, PLOTHEIGHT determines the height
of the area used for plotting, in terms of characters. 

See also CHAR_PLOT, CHAR_GRAPH, CHAR_MULTIGRAPH, CHAR_PARAMPLOT.

&PLOTMODE

An option variable which specifies the format of the plot output.  The
default and other possible values depend on the machine and (for
hardcopy) the output device.

                       WINDOWS    UNIX     Symbolics
                       -------   -------   ---------
default value          WINDOWS   WINDOWS    DISPLAY

Other possible values                      TEKTRONIX

See the Release Notes for your Macsyma for the possible values for
your version of Macsyma.

See PLOTTING_SUMMARY for a summary of the plotting capabilities in
Macsyma.

&PLOTNUM default:100

Specifies the number of points PLOT2 and PARAMPLOT2 plot when given
the low,high type of variable range.  The default when PLOT2 is first
called is 100.  Higher values may be suitable for complicated plots.

In 3D plots, PLOTNUM0 and PLOTNUM1 (default:30) determine the number
of plot points in the two directions.

Do EXAMPLE(PLOTNUM); for an example.

See also PLOT, PARAMPLOT, PLOTNUM0, PLOTNUM1.  See PLOTTING_SUMMARY
for a summary of the plotting capabilities in Macsyma.

&PLOTNUM_ANIMATE default:10

Specifies the number of frames in the animation produced by the
PLOT_ANIMATE command.

&PLOTNUM0 default:30

In 3D plots, PLOTNUM0 determines the number of plot points in the
x-direction (i.e. in the direction of the first variable), and
PLOTNUM1 (default:30) the number of plot points in the y-direction,
when given the low,high type of variable range.

See also PLOT3D, PLOTSURF, PLOTNUM, PLOTNUM1.  See PLOTTING_SUMMARY for
a summary of the plotting capabilities in Macsyma.

Do EXAMPLE(PLOTNUM0); for an example.

&PLOTNUM1 default:30

In 3D plots, PLOTNUM1 determines the number of plot points in the
y-direction (i.e. in the direction of the second variable), and
PLOTNUM0 (default:30) the number of plot points in the x-direction,
when given the low,high type of variable range.

See also PLOT3D, PLOTSURF, PLOTNUM0, PLOTNUM.  See PLOTTING_SUMMARY
for a summary of the plotting capabilities in Macsyma.

Do EXAMPLE(PLOTNUM0); for an example.

&PLOTNUM2

Determines the number of plot points in the vertical
direction for PLOT3D_VECT.

&PLOTNUMPREC default:2

Specifies the number of digits displayed to the right of the decimal
in numbers which appear in plots generated by Macsyma.  Affected
numbers appear in the minimum and maximum coordinate values displayed
at the bottom of the plot, on the axis labels, and in the legends for
contours in contour plots.

&PLOTRESET()

Resets all user options associated with Macsyma plotting.

See also PLOT_OPTIONS.

&PLOTS

Evaluates to a list of named plots in the current environment.
Plots are added to the list with NAMEPLOT, and removed with KILLPLOTS.

PLOTS is available only in those versions of Macsyma which use the
NAMEPLOT scheme for naming and saving plots (currently DOS systems and
Symbolics systems; but currently SAVEPLOTS is not supported on DOS
systems).  For versions of Macsyma with file-based plotting, where each
plot creates a plot file (currently Unix systems), PLOTS is not
needed.

&PLOTSURF

This function plots two-dimensional surfaces embedded in
three-dimensional space.  Each surface is represented in parametric
form as

                     [ X(S,T) , Y(S,T) , Z(S,T) ],

where S and T are continuous real parameters, and X(S,T), Y(S,T) and
Z(S,T) are real-valued continuous functions.  PLOTSURF plots a grid of
PLOTNUM0 x PLOTNUM1 plot points, and interpolates quadrilaterals
between the plot points.  PLOTSURF permits you to construct a surface
from several sections, each of which is plotted at PLOTNUM0 x PLOTNUM1
plot points.  (PLOTNUM0 and PLOTNUM1 can be lists of integers, so that
each surface section can have a nodal grid of a different integer size.)

PLOTSURF has three calling syntaxes, in which the surface(s) are
specified by mathematical expressions, functions, or arrays:

1.  PLOTSURF([[X1,Y1,Z1],...,[XN,YN,ZN]],S,SLO,SHI,T,TLO,THI) , where

    - The first argument represents N surfaces with N triples of
      expressions.  Each expression evaluates to a floating-point number
      and may reference the variables S, and T.
    - S and T are the parameters used to specify the surface.
    - SLO and SHI give the lower and upper limits of the parameter S.
    - TLO and THI give the lower and upper limits of the parameter T.

2a. PLOTSURF([F1,F2,...,FN],SLO,SHI,TLO,THI) , where

    - The first argument represents n surfaces with n functions, each of
      which has two arguments and returns a triple of floating-point
      numbers.  Each function must have been defined before the call to
      PLOTSURF.  Note that the arguments to the functions F1,...,FN do
      not appear explicitly in the call to PLOTSURF, either in the list
      [F1,...,FN] or in the other arguments to PLOTSURF.
    - SLO and SHI give the lower and upper limits of the first parameter.
    - TLO and THI give the lower and upper limits of the second parameter. 

2b. PLOTSURF(F,SLO,SHI,TLO,THI) 

    When only one surface is plotted as in example 2a, the list brackets 
    surrounding the function name F may be omitted.

3.  PLOTSURF([NODES,POLYGONS]) - Plots a surface which is specified by
    node points and polygons.  In this case, the surface to be plotted
    is not specified in parametric form.  The two arguments are:
    - NODES is a two-index array of nodal coordinates, where the first
      index is the node number, and the second index is one of [0,1,2]
      to specify the first, second or third coordinate. (Arrays in
      Macsyma start with index value 0 .)  The value of each element in
      the array is a floating point number. Note: The arrays must be 
      complete arrays.
    - POLYGONS is a one-index array, where the index is the number of
      a polygon in the image.  Each element of the array is a list of
      three or more (up to 32) integers, which specifies the nodes which
      form the corners of a polygonal face.  Triangles, quadrilaterals
      and other n-gons can be mixed in the same image.  (Note that the
      amount of storage allocated for each face is determined by the 
      n-gon with the greatest number of sides.)

Do EXAMPLE(PLOTSURF); for an example and DEMO(PLOTSURF); for 
a longer demonstration.

For options which modify the behavior of PLOTSURF, see also PLOTNUM0,
PLOTNUM1, CENTERPLOT, PLOT_ROLL, PLOT_PHI, PLOT_THETA, VIEWPT,
PLOT_TESSELLATION, COLOR_FUNCTION, COLOR_CYCLES, COLOR_MIN.

See also PLOT3D, PLOTFACES.

See PLOTTING_SUMMARY for a summary of the plotting capabilities in Macsyma.

&PLOTTING

See PLOTTING_SUMMARY.

&PLOTTING_SUMMARY

Macsyma has a large number of graphics commands, ranging from simple
plots of specified functions and data points to plotting 3 dimensional
surfaces.

Creating 2D Plots
-----------------

The main plotting functions for two dimensional plots are:
 - PLOT, for plotting a function of one variable, such as y=f(x).
 - CONTOURPLOT, for plotting the level contours of the function z=f(x,y).
 - IMPLICIT_PLOT, for plotting curves which are specified implicitly
   as an expression=0 or as an equation.
 - GRAPH, for plotting list(s) of points in two dimensions.
 - PARAMPLOT, for plotting a parameterized curve in two dimensions.
 - PLOT2_VECT, for plotting vector fields in two dimensions.
 - ADAPLOT, a package for adaptive density plotting in two dimensions.
 - POLE_ZERO and POLE_ZERO_LIST, for pole-zero plots.

Creating 3D Plots
-----------------

The main plotting functions for three dimensional plots are:
 - PLOT3D and PLOT_DATA, for plotting a function of two variables,
   such as Z=F(X,Y).
 - PLOTSURF, for plotting 2-dimensional surfaces embedded in 3-space,
   and specified in terms of two parameters as [X(S,T),Y(S,T),Z(S,T)].
 - PLOTFACES, for plotting polygonal surfaces in 3-space.
 - CONTOURPLOT3D, for plotting the level contours of the function
   z=f(x,y) in three dimensions.
 - GRAPH3D, for plotting list(s) of points in three dimensions.
 - PARAMPLOT3D, for plotting a parameterized curve in three dimensions.
 - PLOT3D_VECT, for plotting vector fields in three dimensions.
 - COMPLEX_PLOT3D, for plotting real and imaginary parts of complex
   expressions or magnitude and phase of complex expressions.

Macsyma has a built-in command for plotting some standard geometric
figures in 3D.  See PLOT_3D_FIGURE.

Editing Plots
-------------

You can select a PLOT_STYLE from among Macsyma's built-in styles or
create your own styles. 

You can also modify plots from the Macsyma command line in a number of
ways:

 - change plot axes (XAXIS, YAXIS, TICKNUM, TICKSIZE),
 - change plot scale (PLOT_SIZE, EQUALSCALE, 
   XMAX, XMIN, YMAX, YMIN, ZMAX, ZMIN),
 - change plot scales in 3D plots (PLOT_SIZE, EQUALSCALE,
   XMAX3D, XMIN3D, YMAX3D, YMIN3D, ZMAX3D, ZMIN3D)
 - change the number of  plot points (PLOTNUM, PLOTNUM0, PLOTNUM1),
 - set plot labels (LABEL, XLABEL, YLABEL PLOTBOUNDS, TITLE, DATEPLOT),
 - determine plot line types and plot point symbols in 2D plots,
 - superimpose plots (COMBINE_PLOTS, also FIRST, SAME, LAST,
   CLEAR, WAIT),
 - choose the plot position on your screen (TOP, BOTTOM, LEFT, RIGHT).
 - choose coordinate systems in 2D plots (POLAR, LOGLOG, LINLOG, 
   LOGLIN, LIN),
 - change 3D perspective (PLOT_PHI, PLOT_THETA, VIEWPT, CENTERPLOT,
   PLOT_ROLL, PERSPECTIVE, REVERSE),
 - choose quadrilateral or triangular tessellation for 3D surface
   plots (PLOT_TESSELLATION),
 - change color of 3D plots (COLOR_CYCLES, COLOR_FUNCTION, COLOR_MIN,
   COLOR_NORMALIZE).

The system variable PLOT_OPTIONS returns a list of the option variables 
which can be used to alter the appearance of plots.

The command PLOTRESET(); resets all plot options to their default
values.

Macsyma will compile plot functions if they are evaluated more
than PLOT_COMPILE_FUNCTIONS number of times.

Animating Plots
---------------

You can animate plots with PLOT_ANIMATE, and with commands in the
VIEW-CONTROL dialog in the MACSYMA-FRONT-END window.

File Operations
---------------

Most versions of Macsyma enable you to store plots in files and
retrieve them. Versions of Macsyma which use Window systems save plots
in files using commands in the Macsyma Front End.  The availability of
commands for managing plot access and storage vary somewhat across
versions of Macsyma, and are summarized below (Y=yes, o=not available).

                    PC DOS/
                    WINDOWS   UNIX   Symbolics
                     -----    -----    -----  
  RENAME_PLOT_FILE     Y        Y        o
  NAMEPLOT             o        o        Y
  SAVEPLOTS            o        o        Y
  LOADPLOTS            o        o        Y
  KILLPLOTS            o        o        Y

  REPLOT               Y        Y        Y
  REDRAW_PLOT_FILE     o        Y        o
  REVIEW_PLOT          o        o        Y
  REDRAW_PLOT          o        o        o
  HARDCOPY             o        o        Y

  MERGE_PLOT_FILES     o        Y        o
  PLOT_FILE            o        Y        o

  PLOTMODE             Y        Y        Y
   - default setting WINDOWS WINDOWS  DISPLAY
   - other settings                  TEKTRONIX

Macsyma can send plots to printers with a variety of standard formats,
such as Tektronix 4010 and 4013.  Nearly all versions include
Postscript capabilities.

Text Character Graphics
-----------------------

Character plots can be generated for use in ASCII electronic mail, for
example.  See CHAR_GRAPH, CHAR_MULTIGRAPH, CHAR_PARAMPLOT, CHAR_PLOT,
PLOTHEIGHT.


See DEMOS_PLOTTING for demonstrations of plotting in Macsyma.

&POCHHAMMER(N, I)

The Pochhammer symbol which is equivalent to GAMMA(N+I)/GAMMA(N) .
For integer I, this expression is computed.  In particular, for
integer I>=0, this gives N*(N+1)*...*(N+I-1) .  (The Pochhammer symbol
is drawn (n)_i , where _ means subscript.)

&POISDIFF(A, B)

[POISSON package] Differentiates A with respect to B.  B must occur
only in the argument of the trigonometric functions or only in the
coefficients. 

Do EXAMPLE(POISDIFF); for an example.

&POISEXPT(base, exponent1)

[POISSON package] Functionally identical to INTOPOIS(A^B).  exponent1
must be a non-negative integer.

Do EXAMPLE(POISEXPT); for an example.

&POISINT(A, B)

[POISSON package] Integrates A with respect to B, with the same
Restrictions on A and B as for POISDIFF.  Non-periodic terms in B are
dropped if B is in the arguments of the trigonometric functions.

Do EXAMPLE(POISINT); for an example.

&POISLIM default:30

[POISSON package] Determines the allowable domain of the integer
coefficients of the POISVARS in the arguments of the trigonometric
functions, that is, the highest acceptable harmonics of the basic trig
functions.  The highest harmonic is determined by dividing POISLIM by
the number of POISVARS. Using the default value of 30 with the default
value of 6 POISVARS, the harmonic integer coefficients can be in the
interval [-2^(30/6-1)+1,+2^(30/6-1)], or [-15,+15], but it can be set
to [-2^(n-1), 2^(n-1)] for any positive integer n.

&POISMAP(series, sinfn, cosfn)

[POISSON package] Maps the functions sinfn on the sine terms and cosfn
on the cosine terms of the Poisson series given.  sinfn and cosfn are
functions of two arguments which are a coefficient and a trigonometric
part of a term in series respectively.

Do EXAMPLE(POISMAP); for an example.

&POISPLUS(A, B)

[POISSON package] Is functionally identical to INTOPOIS(A+B).

Do EXAMPLE(POISPLUS); for an example.

&POISSIMP(A)

[POISSON package] Converts A into a Poisson series for A in
general representation.

Do EXAMPLE(POISSIMP); for an example.

&POISSON

The Poisson package manipulates Poisson series, which is a finite sum
each term of which is of the form P*TRIG(Q), where TRIG is either SIN
or COS, P can be a general expression, and Q must be a linear
combination of the angle variables POISVARS (default:[U,V,W,X,Y,Z])
with integer coefficients.  These variables can be changed by setting
the variable POISVARS, and the acceptable range for the integer
coefficients can be changed by setting the variable POISLIM. In
general, the angle variables must not occur in the coefficients P.

Conversion of an expression to a Poisson series expands all products or
powers of sines and/or cosines into sums. To display an expression which
is stored in Poisson encoding, it is usually necessary to convert it
into general representation using the functions OUTOFPOIS or PRINTPOIS.
The Symbol /P/ follows the line label of Poisson series expressions.
Do USAGE(POISSON); for more information.

Do DEMO(POISSON); for a demonstration.

See also INTOPOIS, OUTOFPOIS, POISDIFF, POISEXPT, POISINT, POISLIM,
POISMAP, POISPLUS, POISSIMP, POISSUBST, POISTIMES, POISTRIM, POISVARS,
PRINTPOIS. 

&POISSON_DENSITY(x, lambda)

The Poisson density function.  For x>=0 and lambda>=0, this is

                       x   - lambda
                 lambda  %e
        f(x) =   ------------------    
                     gamma(x+1)


This is the density function for the discrete Poisson distribution
and the continuous Poisson distribution.

Do EXAMPLE(POISSON_DENSITY); for an example.

See also CONTINUOUS_POISSON_DISTRIB and DISCRETE_POISSON_DISTRIB.

&POISSON_DISTRIB(x, lambda)

This command is obsolete.

See CONTINUOUS_POISSON_DISTRIB and DISCRETE_POISSON_DISTRIB.

&POISSUBST(A, B, C)
 or
POISSUBST(A, B, C, D, N)

[POISSON package] Substitutes A for B in C.  C is a
Poisson series.

1. If B is one of the variables U, V, W, X, Y, or Z then A must be an
   expression linear in those variables (e.g. 6*U+4*V). 

2. If B is other than one of those variables, then A must also be free
   of those variables, and furthermore, free of sines or cosines.

POISSUBST(A, B, C, D, N)
  Is a special type of substitution which operates on A and B as in
  type (1) above, but where D is a Poisson series, expands COS(D) and
  SIN(D) to order N so as to provide the result of substituting A+D
  for B in C.  The idea is that D is an expansion in terms of a small
  parameter.

Example:

 (c1) POISSUBST(U,V,COS(V),E,3);

 (d1) cos(u)*(1-e^2/2) - sin(u)*(e-e^3/6)

Do EXAMPLE(POISSUBST); for an example.

&POISTIMES(A, B)

[POISSON package] Is functionally identical to INTOPOIS(A*B).

Do EXAMPLE(POISTIMES); for an example.

&POISTRIM()

[POISSON package] Is a reserved function name which (if the user has
defined it) gets applied during Poisson multiplication.  It is a
predicate function of 6 arguments which are the coefficients of the U,
V,..., Z in a term.  Terms for which POISTRIM is TRUE (for the
coefficients of that term) are eliminated during multiplication.

&POISVARS default:[U,V,W,X,Y,Z]

[POISSON package] The value of this option variable specifies a list
of allowed angle variables, and can contain no more than six
variables. Ordinarily, the number of variables in POISVARS times
POISLIM should be kept under 30 if computation time and space is of
concern.

&POLAR

(Optional Argument to the two-dimensional plotting functions) Denotes
a polar coordinate system.  The arguments of the 2D plotting functions
then denote r and theta instead of y and x respectively.

&POLARFORM(exp)

Returns R*%E^(%I*THETA) where R and THETA are purely real.

Do EXAMPLE(POLARFORM); for an example.

See also COMPLEX, POLARFORMLIST, RECTFORM.

&POLARFORMLIST(expr)

Returns a list consisting of the complex absolute value and complex
phase of expression expr.  It is usually faster than using CABS and
CARG separately.

Do EXAMPLE(POLARFORMLIST); for an example.

See also COMPLEX, POLARFORM, RECTFORMLIST.

&POLARTORECT(magnitude-array, phase-array)

[FFT package] Converts from magnitude/phase form into real/imaginary
form putting the real part in the magnitude array and the imaginary
part into the phase array (<real>=<magnitude>*COS(<phase>) and
<imaginary>=<magnitude>*SIN(<phase>).)  This function is part of the
FFT package.  Like FFT and IFT this function accepts 1 or 2
dimensional arrays.  However, the array dimensions need not be a power
of 2, nor need the 2D arrays be square.

&POLE_ZERO(h)

POLE_ZERO performs the following tasks:

 - Calculates the numerical poles and zeros of the function h.
   (H is assumed to be a ratio of polynomials.)  
 - Draws the poles and zeros in the complex plane.
 - Optionally draws the unit circle.
 - Displays the poles amnd zeros in a DataViewer.
 - Returns a list of the lists of zeros and poles.

Do  EXAMPLE(POLE_ZERO); for an example and DEMO(POLE_ZERO); for a
longer demonstration.

See also POLE_ZERO_LIST.

&POLE_ZERO_LIST(poles, zeros {, draw_unit_circle})

Draws the lists of poles (with a one symbol) and zeros (with
another) in the complex plane. If the optional argument
draw_unit_circle is supplied, also draws the unit circle.

See also POLE_ZERO.

&POLY_COEFFP  default:'INTEGERP

[FUNCTS package] Global variable used by POLYNOMIALP to specify the
coefficient domain.  Some possible choices are:  INTEGERP, NUMBERP,
CONSTANTP.  POLYNOMIALP(%i*z-4*%e,z); is FALSE with POLY_COEFFP equal
to INTEGERP, but TRUE when equal to CONSTANTP.

See also POLYNOMIALP, POLY_EXPONENTP.

&POLY_DISCRIMINANT(exp, var)

Computes the discriminant of a polynomial, with respect to var.  I.e.
the square of the product of the differences of all pairs of roots.

Do EXAMPLE(POLY_DISCRIMINANT); for an example.

&POLY_EXPONENTP default:'POSINTP

[FUNCTS package] Global variable used by POLYNOMIALP to specify the
exponent domain.

See also POLYNOMIALP, POLY_COEFFP.

&POLY_INTERPOLATE(X, XA, YA, N)

[INTERPOL package] Given N points specified by pairs of real numbers
(XA[I],YA[I]) where I=0,...,N-1 (XA and YA are arrays), and given a
real number X, this function returns a value Y(X) which is determined
by interpolation using a polynomial of degree N-1.  After exiting, the
variable POLY_INT_ERROR_EST contains an estimate of the interpolation
error.

Do EXAMPLE(POLY_INTERPOLATE); for an example.

See also POLY_INTERPOLATE2, RAT_INTERPOLATE.

&POLY_INTERPOLATE2(X1, X2, X1A, X2A, YA, N1, N2)

[INTERPOL package] Given N1 x N2 points specified by real numbers
(X1A[I],X2A[J],YA[I,J]) where I=0,...,N1-1, J=0,...,N2-1 (X1A, X2A and
YA are arrays), and given real numbers (X1,X2), this function returns
a value Y(X1,X2).  This value is determined by interpolation using a
polynomial of degree N2-1 in the X2 direction, followed by a
polynomial of degree N1-1 in the X1 direction.

Do EXAMPLE(POLY_INTERPOLATE2); for an example.

See also POLY_INTERPOLATE, TABLE_LOOKUP2.

&POLY_RELATIONS(poly_list {, vars})

[GROBNER package] Returns generators for the ideal of polynomial
relations among elements of poly_list.  Poly_list is a list [p1,..pk]
where each pi can be either a polynomial or an equation of the form
"name = polynomial".  For example POLY_RELATIONS( [f=x*y,g=x^2*y^2] );
returns [F^2-G].  When a pi is just a polynomial, the system will make
up a name for it, of the form %Gnn.  E.g. POLY_RELATIONS( [x*y,
x^2*y^2] ); will return [%G2 = X*Y, %G1 = X^2*Y^2] and then
[%G2^2-%G1].

&POLY_REVERT(test_poly, x, shape_polys)

[SPECFUN package] Returns the list of coefficients needed to express a
polynomial `test_poly' in terms of a basis of `shape_polys'.

Arguments:

 - `Test_poly' is a univariate polynomial in the variable `x'.
 - `x' is an atomic variable.
 - `shape_polys' is a list of polynomials in order of ascending degree.
   No two polynomials on the list should have the same maximal degree.

Do LOAD(SPECFUN); to access this function.

&POLYDECOMP(poly, var)

Returns a list of polynomials [f1(var),f2(var),...fn(var)] such that
poly = f1(f2(...fn(var)...)).  There is no other decomposition which
involves more polynomials excepting linear fi.

Do EXAMPLE(POLYDECOMP); for an example.

&POLYFACTOR default:FALSE

When TRUE causes ALLROOTS or ROOTS to display the polynomial as a product of
roots. 

&POLYGAMMA

Basic simplification routines for the polylogs and polygamma functions
have been introduced in Macsyma.  We have decided to use subscripted
notation in order to be consistent with standard reference texts for
these functions.  (Note that the Macsyma notation doesn't imply
Macsyma can produce the definitions.)

Notation:
  PSI[N](X) = DIFF(PSI[0](X),X,N) where PSI[0](X)
  = DIFF(LOG(GAMMA(X)),X) 

Simplification:
  Closed forms for: (in SIN, COS, or ZETA functions) rational X, N =
  0; N integer, > -1 and X an integer, or a rational number p/q with
  q = 2, 3, 4, or 6.

Notes: Currently there are no numerical routines for the polygammas.
The following option variables permit some control over
simplification, they must be set to fixnum (integer) values.

MAXPSIPOSINT default:9999
  The largest value of the integral part of X for which a closed form
  will be computed.

MAXPSINEGINT default:9999
  For negative X less than MACPSINEGINT no closed forms will be
  computed.

MAXPSIFRACNUM default:9999
  The largest value of P for which simplification occurs for
  PSI[0](P/Q) for P and Q integers and 0 < P/Q < 1 (i.e. the
  fractional part of arguments).

MAXPSIFRACDENOM default:9999
  The largest value of Q  for which simplification occurs for
  PSI[0](P/Q) for P and Q integers and 0 < P/Q < 1 (i.e. the
  fractional part of arguments).


&POLYGAMMAS

See POLYGAMMA.

&POLYLOGARITHM

See POLYLOGARITHMS.

&POLYLOGARITHMS

Basic simplification routines for the polylogs and polygamma functions
have been introduced in Macsyma.  We have decided to use subscripted
notation in order to be consistent with standard reference texts for
these functions.  (Note that the Macsyma notation doesn't imply
Macsyma can produce the definitions.)

Notation:
  LI[N](X) = INTEGRATE(LI[N-1](T)/T,T,0,X) where LI[1](X)
  = - LOG(1-X)

Simplification:
  Closed forms for argument 1, -1 when N is +integral (involving ZETA
  functions); closed form for LI[2](1/2); numerical routine for
  LI[2](X).  Fast numeric routines are now available for LI[2](x) and
  LI[3](x).  Chebyshev expansions are used in the approximations.

Notes: The extension for large real values of X is adopted following
Lewin, i.e. when X is greater than unity LI[2](X) has - %I %PI LOG(X)
as its imaginary part.  Currently this only affects the numerical
routine.

&POLYLOGS

See POLYLOGARITHMS.

&POLYNOMIALP(expr, var_or_vars {, preds})

[ALGFUNCS package] Tests whether expr is a polynomial in the given
var or vars.  POLYNOMIALP uses the global variables POLY_COEFFP and
POLY_EXPONENTP.  POLYNOMIALP(%i*z-4*%e,z); is FALSE with POLY_COEFFP
equal to INTEGERP, but TRUE when equal to CONSTANTP.

Do EXAMPLE(POLYNOMIALP); for an example.

&POLYSIGN(X)

Same as SIGNUM but always returns a numerical result by looking at the
numerical factor of the highest degree term in X.

&POLYSOLVE(exp, var)

Finds the roots of polynomials over the complex field.

Do EXAMPLE(POLYSOLVE); for an example, and DEMO(POLSOL); for a longer
demonstration. 

See also CFACTOR.

&POLY2COMPANION(poly, var)

Companion matrix of input Macsyma polynomial.  The monic form of the
original polynomial can be recovered by CHARPOLY.

Example:

 (c41) A*X^3+B*X^2+C*X+D;

                          3      2
 (d41)                 a x  + b x  + c x + d

 (c42) POLY2COMPANION(%,X);

                               [         d ]
                               [ 0  0  - - ]
                               [         a ]
                               [           ]
                               [         c ]
 (d42)                         [ 1  0  - - ]
                               [         a ]
                               [           ]
                               [         b ]
                               [ 0  1  - - ]
                               [         a ]

Do EXAMPLE(POLY2COMPANION); for an example.

See also CHARPOLY, LIST2COMPANION, MAT_COMP, HYPERCOMPANION.

&POLY2LIST(poly, var)

Converts a polynomial in the variable var to a list of coefficients in
order of decreasing powers of var.  The polynomial can be recovered by
LIST2POLY.

See also LIST2POLY.

&POLY2MAT(poly, variable1, variable2)

Converts a polynomial in two variables into a matrix of its
coefficients.  Powers of variable1 are different in different rows,
powers of variable1 are different in different rows.  Denoting the
output of this function by M, the original polynomial can be
recovered by

    VANDERMONDE([variable1],mat_nrows(M)) 
                    . M . 
    VANDERMONDE([variable2],mat_ncols(M))^`

Do EXAMPLE(POLY2MAT) for an example.

See also POLY2LIST.

&POP(list, type)

Removes the first element from list and returns the element.

Do EXAMPLE(POP); for an executable example.

&POPULATION_VARIANCE(_sample_)

[STATS package] Returns the population variance of the list _sample_.
_sample_ may contain symbolic entries.

Population_variance := sum(sample[i]^2-sample_mean^2)/(sample_size-1).

&POPULATION_STANDARD_DEVIATION(_sample_)

[STATS package] The positive square root of the POPULATION_VARIANCE of
the list _sample_.  _sample_ may contain symbolic entries.

&POSFUN

(POSitive FUNction) DECLARE(F,POSFUN); causes IS(F(X)>0); to evaluate
to TRUE.  POSFUN is a member of the FEATURES list.  It can be asserted
with DECLARE, withdrawn with REMOVE, and detected with FEATUREP.

Do EXAMPLE(POSFUN); for an example.

&POSINTP(X)

[ALGFUNCS package] Returns TRUE if x is a positive integer;
otherwise FALSE.

&POSITION(X, L {, flag})

[FUNCTS package] Returns the index of the first position where x 
occurs in L.  If x does not occur in L then FALSE is returned.

If the optional argument flag= 'ALL, then returns a list of all
indices of positions at which x occurs in L. If x does not occur 
in L then [] is returned.

Do EXAMPLE(POSITION); for an example.

&POSTFIX(oper {, lbp, lpos, pos})

Defines the symbol oper to be a POSTFIX operator.  POSTFIX operators,
like PREFIX operators, are functions of a single argument, but in
this case the argument immediately precedes an occurrence of the
operator in the input string, e.g. 3! .

All arguments after the first are optional, where

  oper = the symbol or string which denotes the operator,
  lbp  = left binding power           (default:180),
  lpos = left part of speech          (default:ANY),
  pos  = part of speech of the result (default:ANY).

Do USAGE(OPERATORS); for more information.

Do DEMO(OPERATORS); for a demonstration.

See also PREFIX, INFIX, NARY, NOFIX, MATCHFIX.

&POTENTIAL_ZERO_LOCATION default:0

[VECT package] Determines the coordinates of the point used as the
lower limit of integration in the vector integration functions
SCALAR_POTENTIAL and VECTOR_POTENTIAL.

The value of POTENTIAL_ZERO_LOCATION must not be a list, or must be
of the form 
 [indeterminatej=expressionj, indeterminatek=expressionk, ...].
If the value is not a list, then this value is used as the right hand
sides of equations in a list such as the one shown above.

&POWER_SPECTRUM(func, t, t0, t1 {, window})

performs the following tasks:

 - Graphs the real function func(t) between t0 and t1.
 - Samples func(t) at N equally spaced points and graphs
   the sample points. N must be a power of 2.
 - Computes the FFT of the sample points.
 - Graphs the Real and Imaginary part of the FFT.
 - Computes the Power Spectrum P.
 - Graphs the Power Spectrum as a function of frequency.
 - Places the sample points, the FFT, the frequencies and the
   power spectrum in a DataViewer.
 - Returns an association list of the form
   ['time =..., 'signal=..., 'frequency=..., 'power_spectrum=...]

Optionally, you can supply the name of a Window function
to apply to the time signal.  Possible values of the optional
argument window are:

  Rectangular
  Bartlett
  Welch
  Hamming
  Hanning
  Kaiser
  Blackman

If you choose 'kaiser as a window function, you must also supply
an additional argument for the numerical value of the parameter wa.
See KAISER_WINDOW below.

Mathematical Description:
------------------------

Suppose a real function of time is sampled at N equally spaced 
points func(t_j), for j=0,...,N-1 between t0 and t1 and those
sample points are Fourier transformed by an FFT into N transform
points F_k given by

   F_k = SUM(func(t_j)*exp(2*%pi*%i*j*k/N),j,0,N-1)  k=0...N-1.

One often makes the following statements about the power spectrum P:

 - The sample spacing is (t1-t0)/N
 - The critical or Nyquist frequency is f_c = 2N/(t1-t0)
 - The highest sample frequency is  N/(t1-t0)
 - The power spectrum is defined at N/2+1 frequencies f_k
   f_k= k/(t1-t0), k=0,1,...,N/2
 - P(0) = abs(F_0)^2/N^2
 - P(f_k) = (abs(F_k)^2 + abs(F_(N-k))^2)/N^2   k=1,2,...,(N/2-1)
 - P(f_(N/2)) = abs(F_(N/2))^2/N^2

Do EXAMPLE(POWER_SPECTRUM); for an example.

See also RECTANGULAR_WINDOW, BLACKMAN_WINDOW, BARTLETT_WINDOW,
WELCH_WINDOW, HAMMING_WINDOW, HANNING_WINDOW, KAISER_WINDOW.

See also POWER_SEPCTRUM_UNEVEN_DATA when the data samples are not equally
spaced. 

&POWER_SPECTRUM_UNEVEN_DATA(tlist, ylist)

Computes the power spectrum of data ylist given at times tlist using the
Lomb method. The data need not be sampled at a constant rate. There is no
need for the number of data to be a power of 2. No assumptions are made
about missing data. Additionally, probabilities that the peak power is
significant at the 10%, 1% and 0.1% are plotted with the power spectrum as
well as the original data. Data is returned in the association list
POWER_SPECTRUM_DATA.

Do EXAMPLE(POWER_SPECTRUM_UNEVEN_DATA); for an example.

See also POWER_SPECTRUM.

&POWER_SPECTRUM_DATA

Association list of results returned by POWER_SPECTRUM_UNEVEN_DATA.

See POWER_SEPECTRUM_UNEVEN_DATA for details.

&POWERDISP default:FALSE

If TRUE will cause sums to be displayed with their terms in the
reverse order.  Thus polynomials would display as truncated power
series, i.e., with the lowest power first.

Do EXAMPLE(POWERDISP); for an example.

&POWERS(expr, var)

Returns the powers of var occurring in expr.  This function returns a
list of all the powers of var occurring at the top level of expr.  It
may be necessary to expand expr before applying POWERS or you may get
an incorrect answer.

This function has many uses, e.g. if you want to find all the
coefficients of x in a polynomial poly you can use

    MAP(LAMBDA([POW],COEFF(POLY,X,POW)),POWERS(POLY,X)); .

Do EXAMPLE(POWERS); for an example.

&POWERSERIES(exp, var, pt)

Generates the general form of the power series expansion for exp in
the variable var about the point pt (which may be INF for infinity).
If POWERSERIES is unable to expand exp, the TAYLOR function may give
the first several terms of the series.

Do EXAMPLE(POWERSERIES); for an example.

When VERBOSE (default:FALSE) is TRUE, POWERSERIES will print comments
about the its progress as execution proceeds.

&POWERSET(s)

Returns the set of all subsets of s.

Do EXAMPLE(POWERSET); for an example.

See also SET, SUBPOWERSET.

&PRED - an EVFLAG

Causes PREDICATES (expressions which evaluate to TRUE or FALSE) to be
evaluated.

&PREDICATES

Macsyma contains many built-in predicates to test the type or
structure of variables and expressions.  Most of them end in the
letter P to indicate that they are predicates.  Here is a partial list
of predicates.

Testing numbers:
  NUMBERP, CONSTANTP, RATNUMP, ZEROP
  INTEGERP, EVENP, ODDP, POSINTP, PRIMEP
  SFLOATP, DFLOATP, BFLOATP, FLOATP 
  SCALARP, NONSCALARP, ASSUMESCALARP

Testing variables and symbols:
  ATOM, MAPATOM, SUBVARP, SYMBOLP

Testing expression types:
  ALGEBRAICP, EQUATIONP, OPERATORP, RATP, TAYLORP, SUBVARP
  FEATUREP

Testing arrays lists, matrices and sets:
  ARRAYP, LISTP, MATRIXP, SQUARE_MATRIXP, VECTORP
  SETP, SUBSETP, DISJOINTP, MEMBER

Testing strings:
  STRINGP, STRING_EQUAL, SUBSTRINGP

Testing relations:
  EQUAL, FREEOF, NON_ZERO_AND_FREEOF, ORDERLESSP, ORDERGREATP

See also IS, PREDERROR.

&PREDERROR default:TRUE

If TRUE, an error message is signaled whenever the predicate of an IF
statement or an IS function fails to evaluate to either TRUE or FALSE.
If FALSE, UNKNOWN is returned instead in this case.  The
PREDERROR:FALSE mode is not supported in translated code.

See also IS and MAYBE.

&PREFERRED_GREETING_STYLE default:DISPLAY

Only on Symbolics Lisp machines.

Allows the user to designate which style of greeting he would prefer
in menu-oriented interactions.  Possible settings are PRINT and
DISPLAY.  In some cases, it may not be possible to satisfy the
preference, in which case an appropriate style may be chosen by the
system without regard to the setting of this variable.

The DISPLAY greeting style uses fancy line-drawing and multiple fonts
and works only on certain terminals.

The PRINT greeting style uses simple typeout and works on any kind of
terminal.

Note: Although the default value of PREFERRED_GREETING_STYLE in all
implementations is DISPLAY, that style is in fact implemented
currently only for Symbolics Lisp machines.  In other implementations,
the system will (for the time being) always use a style of PRINT.
This may change in some future release, however, so we felt it best to
provide a uniform preference default even if the perceived behavior
might vary.

&PREFERRED_MENU_STYLE default:MOUSE

Only on Symbolics Lisp machines.

Allows the user to designate which style of menu he would prefer in
menu-oriented interactions.  Possible settings are KEYBOARD and MOUSE.
In some cases, it may not be possible to satisfy the preference, in
which case an appropriate style may be chosen by the system without
regard to the setting of this variable.

The MOUSE menu style is a pop-up style menu.  The mouse is used to point
at an item in order to select it.

The KEYBOARD menu style involves the presentation of items in a more
traditional Macsyma typeout style with numbers beside each item.
In this style, selection is done by typing the item's number followed
by a ";".

Note: Although the default PREFERRED_MENU_STYLE in all implementations
is MOUSE, the mouse style is in fact implemented currently only for 
Symbolics Lisp machines.  On other implementations, the system will
(for the time being) always use a menu style of KEYBOARD.  This may
change in some future release, however, so we felt it best to provide
a uniform preference default even if the perceived behavior might
vary. 

&PREFIX(oper {, rbp, rpos, pos})

Defines the symbol oper to be a POSTFIX operator.  A PREFIX operator
is one which signifies a function of one argument, which argument
immediately follows an occurrence of the operator.

All arguments after the first are optional, where

  oper = the symbol or string which denotes the operator,
  rbp  = right binding power          (default:180),
  rpos = right part of speech         (default:ANY),
  pos  = part of speech of the result (default:ANY).

Do USAGE(OPERATORS); for more information.

Do DEMO(OPERATORS); for a demonstration.

See also  POSTFIX, INFIX, NARY, NOFIX, MATCHFIX.

&PRIME(n)

Gives the nth prime.  PRIME(1) = 2, PRIME(10^13) = 323780508946309.
MAXPRIME is now obsolete, as is the old, slow primes file.  But large
n (e.g. > 10^9) can consume O(n^(2/3)) time and O(n^(1/2)) space.
Closely spaced (or repeated) primes, however, come cheap, after the
first.

Do EXAMPLE(PRIME); for an example.

&PRIME_PI(x)

Is the PI(x) function from number theory, counting the number of
primes <= x.  PRIME_PI(1) = 0, PRIME_PI(%pi) = 2,
PRIME_PI(323780508946309) = 10^13.  I.e., PRIME_PI(PRIME(n)) = n, and
PRIME(PRIME_PI(n)) = the largest prime <= n.  Large x (e.g. > 10^10)
can consume O(x^(2/3)) time and O(x^(1/2)) space, but closely spaced
(or repeated) x come cheap, after the first.

&PRIMEP(n {, odds})

PRIMEP(n)
  Returns TRUE if n is a prime, FALSE if not.  For convenience,
  PRIMEP(n) = PRIMEP(-n) = PRIMEP(1/n).  When the integer is so large
  that PRIMEP might take too long, then the following option can be
  used: 

PRIMEP(n,odds)
  Returns TRUE if it can prove n is a prime, FALSE if it can prove n
  is composite, and PROBABLY if it was only able to establish the
  specified odds against compositeness.  Thus, PRIMEP(-euler(38),10^6)
  returning PROBABLY means the odds are > a million to one against
  factoring.  In fact, although they certainly exist, we have never
  seen a composite n for which PRIMEP(n,1) returns PROBABLY, and never
  expect to see one which fools PRIMEP(n,10^6).  We are told that the
  Generalized Riemann Hypothesis implies that PRIMEP(n,2^(4 ln n)^2)
  is infallible, but would be willing to bet that so is PRIMEP(n,n).
  PRIMEP(n,odds) will never return PROBABLY for n < 10^12, nor for 
  odds > n.

  As a special case intended to save time for very large n, odds = 0
  attempts only a quick check for small factors before giving up and
  returning PROBABLY.

Do EXAMPLE(PRIMEP); for an example.

See also PREDICATES.

&PRIMER()

Starts up the on-line PRIMER in Macsyma.  PRIMER(HELP); offers a menu
of available primer scripts.  PRIMER(script); will start the primer
with a particular script.

&PRINT(exp1, exp2, ...)

Evaluates and displays its arguments one after the other "on a line"
starting at the leftmost position.  If expi is unbound or is preceded
by a single quote or is enclosed in "s then it is printed literally.
For example, PRINT("THE VALUE OF X IS ",X).  The value returned by
PRINT is the value of its last argument.  No intermediate lines are
generated.  (For "printing" files, see the PRINTFILE function.)

&PRINT_PROVISOS default:TRUE

This switch, when set to FALSE, turns off the printing of any provisos
generated by a computation.

&PRINTFILE(file-specification)

Prints the contents of the file specified on the terminal.

See FILENAMES for information about how to specify file pathnames in
Macsyma.  See FILES_SUMMARY for more information about file manipulation
commands in Macsyma.

&PRINTPOIS(A)

[POISSON package] Prints a Poisson series in a readable format.  In
common with OUTOFPOIS, it will convert A into a Poisson encoding
first, if necessary.

Do EXAMPLE(PRINTPOIS); for an example.

&PRINTPROPS(a, i)

Displays the property with the indicator i associated with the atom a.
a may also be a list of atoms or the atom ALL in which case all of the
atoms with the given property will be used.  For example,
PRINTPROPS([F,G],ATVALUE).  PRINTPROPS is used for properties that
cannot otherwise be displayed, i.e. for ATVALUE, ATOMGRAD, GRADEF, and
MATCHDECLARE.

Do EXAMPLE(PRINTPROPS); for an example.

&PROBABILITY_FUNCTIONS

 - The UNIPROB package contains many discrete and continuous
   univariate probability density and distribution functions.
 - The MULTPROB package contains some continuous multivariate density
   and distribution functions.

Do USAGE(UNIPROB); and USAGE(MULTPROB); for more information.

Do DEMO(UNIPROB); and DEMO(MULTPROB); for demonstrations.

&PRODCONTRACT(expr)

[NUSUM package] Is analogous to SUMCONTRACT, except that it works for
PRODUCTs.  Currently, it is more vigorous than SUMCONTRACT, being
willing to change variables if it leads to compatible limits.

DO LOAD(NUSUM); to access PRODCONTRACT.

&PRODGUNCH(exp, variable, incr)

[NUSUM1 package] transforms the input expression by changing the
variable by the specified increment. The resulting expression is
multiplied by appropriate factors to maintain the same value as the
input. For example:

 (c1) (2*N+1)!;
 (d1)                               (2 n + 1)!
 (c2) % = PRODGUNCH(%,N,1);
                                       (2 (n + 1) + 1)!
 (d2)                    (2 n + 1)! = -------------------
                                      (2 n + 2) (2 n + 3)


&PRODHACK default:FALSE

If set to TRUE then PRODUCT(F(I),I,3,1); will yield 1/F(2), by the
identity PRODUCT(F(I),I,A,B) = 1/PRODUCT(F(I),I,B+1,A-1) when A>B.

&PRODUCT(exp, ind, lo, hi)

Returns the product of the values of exp as the index ind varies from
lo to hi.  The evaluation is similar to that of SUM.  No
simplification of products is available at this time.  If hi is one
less than lo, we have an "empty product" and PRODUCT returns 1 rather
than erring out.

An alternative name for PRODUCT is PROD.

Example:

 (c1)  PRODUCT(X+I*(I+1)/2,I,1,4);

 (d1)             (x + 1) (x + 3) (x + 6) (x + 10)

Do EXAMPLE(PRODUCT); for an example.

See also PRODHACK.

&PROFILER

See TIMER.

&PROG1(exp1, ..., expn)

[BASIC package] The function PROG1 is similar to the function BLOCK in
that it evaluates each expression in the argument list in turn, but
unlike BLOCK, which returns the result of the last expression, PROG1
returns the result of the first expression.

&PROGRAMMODE default:TRUE

When FALSE will cause SOLVE, REALROOTS, ALLROOTS, and LINSOLVE (but
not ALGSYS) to print each solution expression on a labeled E-line, and
to return as final value the list of E-labels.  

When TRUE, SOLVE, etc.  return solution expressions as elements in a
list.  (Except when BACKSUBST is set to FALSE, in which case
PROGRAMMODE is automatically set to FALSE.)

Do EXAMPLE(PROGRAMMODE); for an example.

See also BREAKUP.

&PROMPT

See BREAK_PROMPT and PAUSE_PROMPT.

&PROPERTIES(a)

Returns a list showing the names of all the properties associated with
the atom a.

Do USAGE(PROPERTIES); for an overview of Macsyma commands to manage
properties of symbols.

Do EXAMPLE(PROPERTIES); for an example.

&PROPERTY

See PROPERTIES.

&PROPS

Returns a list of atoms which have any property other than those
explicitly mentioned in INFOLISTS, such as ATVALUE, MATCHDECLARE, as
well as properties specified in the DECLARE function.

&PROPVARS(prop)

Returns a list of those atoms on the PROPS list which have the
property indicated by prop.  Thus PROPVARS(ATVALUE) will yield a list
of atoms which have atvalues.

Do USAGE(PROPERTIES); for an overview of Macsyma commands to manage
properties of symbols.

Do EXAMPLE(PROPVARS); for an example.

&PROVISOS default:[]

PROVISOS contains all of the assumptions generated in the course of
processing the last C-line.  The PROVISOS list is emptied only when
new provisos are made in the course of processing a new C-line (or by
KILL(ALL);or RESET(PROVISOS);).  See also PRINT_PROVISOS.

&PSEXPAND default:FALSE

If TRUE will cause extended rational function expressions to display
fully expanded.  (RATEXPAND will also cause this.)  

If FALSE, multivariate expressions will be displayed just as in the
rational function package.  If PSEXPAND:MULTI, then terms with the
same total degree in the variables are grouped together.

&PSI(X)

Derivative of LOG(GAMMA(X)).  At this time, Macsyma does not have
numerical evaluation capabilities for PSI.  For information on the
PSI[N](X) notation, see POLYGAMMA.

&PSI[n](X)

See POLYGAMMA.

&PUSH(val, list)

Adds the expression val to the beginning of the list pointed to by
list and returns the new list as the result.

Do EXAMPLE(PUSH); for an executable example.

&PUT(a, p, i)

Associates with the atom a the property p with the indicator i.  This
enables the user to give an atom any arbitrary property.  Properties
which are added with PUT can be retrieved with GET and removed with
REM.  

Do USAGE(PROPERTIES); for an overview of Macsyma commands to manage
properties of symbols.

Do EXAMPLE(PUT); for an example.

&QUAD_INF(expr, var, low, hi {, method})

[CALFUNCS package] Performs numerical integration with infinite
limits of integration.

 - low (the lower limit of integration) can be MINF, 
 - hi  (the upper limit of integration) can be INF, 
 - or both low and hi can be infinite.

QUAD_INF converts an infinite interval of integration into the 
interval (0,1) by using changes of variable and other transformations.

The key change of variables (implicitly) used is:
   changevar('integrate(f(x),x,1,inf),x=1/y,y,x);
     = 'integrate(f(1/y)/y^2,y,0,1) .

The (optional) fifth argument is the quadrature method to use.
If not supplied, QUADRATR is used.  If supplied, it must support 
the four argument syntax quadrature(expr,var,low,hi) . 

Do EXAMPLE(QUAD_INF); for an example.

&QUAD_RANDOM_QUADRATURE default:FALSE

Is a flag used by QUADRATR. If TRUE, QUADRATR will pick random
quadrature points for its integrations. If FALSE, fixed quadrature
points are used. 

When random quadrature points are picked, QUADRATR can return
results that differ from call to call at the level of QUAD_EPSILON.

&QUADRATIC_MATCH(expr, var)

[ALGFUNCS package] If the expression expr is quadratic in var of
the form a*var^2+b*var+c, then QUADRATIC_MATCH returns the list
[fn_c = c, fn_a = a, fn_b = b, fn_x = var], and the variables fn_a,
fn_b, fn_c and fn_x are bound to the values indicated in the list.
Otherwise returns FALSE. 

See also LINEAR_MATCH.

&QUADRATR(f, a, b)
 or
QUADRATR(f(x), x, a, b)

Numerically integrates the univariate function f over the finite
interval [a,b] using extrapolated Gaussian quadrature.  Either a or b
may be singularities of f, but they must be finite.  The numerical
value of the integral is returned, to relative accuracy QUAD_EPSILON.

QUADRATR works with single or double precision floating point numbers, not
BFLOATs.

QUADRATR, QUAD_SUB_ADAPT, and QUAD_SUB_NONADAPT also have both three
and four argument syntax .

QUADRATR also assigns values to these variables: 
 - QUAD_NPTS - the total number of function calls of f.
 - QUAD_ICHECK - If 0, everything is fine. If #0, then
   accuracy may be less than QUAD_EPSILON. In this case, try
   QUAD_SUB_ADAPT or QUAD_SUB_NONADAPT for refined calculations.

Set QUAD_ICHECK_WARN to FALSE (default TRUE) to turn off warning 
messages about insufficient accuracy.

See also QUAD_RANDOM_QUADRATURE.

Do USAGE(QUADRATR); for more information.

Do EXAMPLE(QUADRATR); for an example and DEMO(QUADRATR); for a longer
demonstration.

See also ROMBERG, QUANC8, QUAD_INF, INTEGRATE_DATA, and
GAUSS_LEGENDRE_INT.

&QUADRATURE - See QUADRATURE_SUMMARY.

&QUADRATURE_SUMMARY

Macsyma has ten methods of numerical integration of functions
and expressions.

CHEBYSHEV_INTEGRATE integrates a function which is approximated
  by a sum of Chebyshev polynomials.

GAUSS_LEGENDRE_INT integrates a univariate function over a
  finite interval using Gauss-Legendre quadrature with bigfloats.

INTEGRATE_DATA integrates a univariate function which is defined
  by lists of values of independent and dependent variables.

QUAD_INF integrates a univariate function over an infinite
  interval.

QUADRATR integrates a univariate function over a finite
  interval using extrapolated Gaussian quadrature.

QUANC8 integrates a univariate function over a finite
  interval using adaptive Newton-Cotes 8th order polynomial 
  quadrature. 

RIEM_SUM_LEFT, RIEM_SUM_MIDDLE, RIEM_SUM_RIGHT integrate a 
  univariate function using Riemann sums.

ROMBERG integrates a univariate function over a finite
  interval using the Romberg method.  BROMBERG is a bigfloat
  version of ROMBERG.  ROMBERG can be nested to integrate
  bivariate functions or higher order integrals. Do
  DEMO(MULTIPLE_INTEGRAL);

SIMPSON integrates a univariate function over a finite
  interval using Simpson's rule.

TRAPRULE integrates a univariate function over a finite
  interval using the trapezoidal rule.  

&QUANC8('function-name, lo, hi)

[QQ package] Performs numerical integration using adaptive
Newton-Cotes 8th order polynomial quadrature.  Absolute and relative
error checks are used.

It will divide the interval only when necessary to achieve the error
conditions specified by the global variables QUANC8_RELERR (default:
1.0e-4) and QUANC8_ABSERR (default:1.0e-8) which give the relative
error test:  

 |integral(function)-computed value| < quanc8_relerr*|integral(function)|   

and the absolute error test:

 |integral(function)-computed value| < quanc8_abserr.

The function-name should be quoted.  The 4 arg version will compute the
integral of the function or expression (first arg) with respect to the
variable (second arg) over the interval from lo to hi as in QUANC8(<f(x)
or expression in x>,x,lo,hi).

Do USAGE(QQ); for more information.  Do LOAD("QQ"); to access the file.  

Do EXAMPLE(QUANC8); for an example, and DEMO(QQ); for a longer
demonstration.

See also QUADRATR, ROMBERG, QUAD_INF and GAUSS_LEGENDRE_INT.

&QUERY(arg1, ..., argn)

Prints arg1,..., argn and then prompts the user to answer YES or Y, NO or N
(followed by $ or ;).  If you answer YES, then QUERY returns the value
TRUE.  If you answer NO, then QUERY returns the value FALSE.

Do EXAMPLE(QUERY); for an example.

See also ASKINTEGER, ASKSIGN, READ, SELECT_ONE_OF.

&QPUT(a, p, i)

Is similar to PUT but it doesn't have its arguments evaluated.

&QQ

The library file QQ contains a function QUANC8 which can take either 3 or 4
arguments.  The 3 arg version computes the integral of the function
specified as the first argument over the interval from lo to hi as in
QUANC8('function-name,lo,hi); .

Do USAGE(QQ); for more information.

Do EXAMPLE(QUANC8); for an example, and DEMO(QQ); for a longer
demonstration.

&QR_DECOMP(A)

Computes the QR factorization of the m x n numerical matrix A.  QR_DECOMP
returns a list of the matrices Q and R, where Q is column unitary (m >= n;
also row unitary if m = n and A is nonsingular) and R is upper triangular
with A = Q R.

Do EXAMPLE(QR_DECOMP); for an example and DEMO(QR); for a longer
demonstration.

See also QR_DECOMP_SYMB.

&QR_DECOMP_SYMB(A)

Computes the QR factorization of the m x n symbolic (or numerical) matrix
A. QR_DECOMP_SYMB returns a list of the matrices Q and R, where Q is
column unitary (m >= n; also row unitary if m = n and A is nonsingular) and
R is upper triangular with A = Q R.

Do EXAMPLE(QR_DECOMP_SYMB); for an example.

See also QR_DECOMP for numerical matrices.

&QUIT()

Leaves Macsyma.

It is intended that you should call QUIT when you are done with a
Macsyma session and do not intend to return.  See also, EXIT() which can
be used to exit when you do intend to return.

The actual effect of QUIT is controlled by the variable
QUIT_REALLY_QUITS [FALSE].  If TRUE, QUIT would forcibly reinitialize
Macsyma by calling INITIALIZE_MACSYMA. When QUIT_REALLY_QUITS is FALSE,
QUIT simply behaves like EXIT.  This is primarily to allow a comfortable
transition between an old behavior of QUIT and this new behavior.  If
you mean to exit only temporarily, you should call EXIT explicitly.

An argument to QUIT overrides the default value of QUIT_REALLY_QUITS,
so QUIT(TRUE) will call INITIALIZE_MACSYMA regardless of the setting of
QUIT_REALLY_QUITS.

On a Symbolics Computer, QUIT(ALL) does what QUIT(TRUE) does and also
clears your dynamic windows Macsyma output history.

Note: The abort character (sometimes called the "quit" character) for
Macsyma on Symbolics Computers is Control-Abort.  In other
implementations it is Control-G. Typing this character will immediately
terminate an ongoing computation and return to the interactive command
loop by calling the function ABORT (not QUIT).  See ABORT.

&QUIT_REALLY_QUITS default:TRUE

Determines the default action for the function QUIT if the optional
argument is not specified.  When QUIT_REALLY_QUITS is TRUE, typing QUIT();
destroys any Macsyma state you've created and ends your session. When
QUIT_REALLY_QUITS is FALSE, typing QUIT(); lets you leave Macsyma,
preserving your current state.  This is the same as typing EXIT(); .

&QUNIT(n)

Gives the principal unit of the real quadratic number field SQRT(n) where n
is an integer, i.e.  the element whose norm is unity.  This amounts to
solving Pell's equation A^2- n*B^2=1.

Example:

 (c1) QUNIT(17);
 (d1)              sqrt(17)+4

 (c2)  EXPAND(%*(SQRT(17)-4));

 (d2)               1

Do EXAMPLE(QUNIT); for an example.

&QUOTIENT(p1, p2, var1, ...)

Computes the quotient of the polynomial p1 divided by the polynomial
p2.

Do EXAMPLE(QUOTIENT); for an example.


&RADCAN(exp)

Simplifies exp, which can contain logs, exponentials, and radicals, by
converting it into a form which is canonical over a large class of
expressions and a given ordering of variables; that is, all functionally
equivalent forms are mapped into a unique form.  For a somewhat larger
class of expressions, RADCAN produces a regular form.  Two equivalent
expressions in this class will not necessarily have the same appearance,
but their difference will be simplified by RADCAN to zero.  For some
expressions RADCAN can be quite time consuming.  This is the cost of
exploring certain relationships among the components of the expression for
simplifications based on factoring and partial-fraction expansions of
exponents.

%E_TO_NUMLOG default: FALSE
  When set to TRUE, for "r" some rational number, and "x" some
  expression, %E^(r*LOG(x)) will be simplified into x^r .

Caveat: RADCAN makes assumptions which can cause problems with
branches.  So it needs to be used with care.

E.g. When LOGEXPAND is ALL, RADCAN((a^b)^c);  gives  a^(b*c)  
     which is not valid when a=-1,b=2,c=1/2 .

     RADCAN((a*b)^c);  gives  a^c*b^c  which is not valid when 
     a=-1,b=-1,c=1/2 .

     RADCAN(log((c-b)^2));  gives  2*log(c-b)  which is not 
     valid when b=2,c=1 .

Do EXAMPLE(RADCAN); for an example.

See also RADEXPAND, ROOTSCONTRACT, ROOTSCONMODE, DENEST_SQRT.

&RADEXPAND default:TRUE

If set to ALL will cause nth roots of factors of a product which are
powers of n to be pulled outside of the radical.  E.g. if RADEXPAND is
ALL, SQRT(16*X^2) will become 4*X .

In particular, consider SQRT(X^2).

(a) If RADEXPAND is ALL or ASSUME(X>0) has been done, SQRT(X^2) will 
    become X.
(b) If RADEXPAND is TRUE and DOMAIN is REAL (its default), SQRT(X^2) 
    will become ABS(X).
(c) If RADEXPAND is FALSE, or RADEXPAND is TRUE and DOMAIN is COMPLEX, 
    SQRT(X^2) will be returned.

(The notion of DOMAIN with settings of REAL or COMPLEX is still in 
its infancy.  Note that its setting here only matters when RADEXPAND is 
TRUE.)

Do EXAMPLE(RADEXPAND); for an example.

See also RADCAN, ROOTSCONTRACT, ROOTSCONMODE, DENEST_SQRT.

&RADICAL_MEMBER(poly, ideal {, vars})

[GROBNER package] Returns TRUE if and only if some power of poly is a
member of the ideal.  Same as
ID_MEMBER(1,append([T*poly-1],ideal),append(vars,[T])) where T is a new
variable.

&RADICALS

Macsyma has many facilities for manipulating radicals.  See RADCAN,
RADEXPAND, ROOTSCONTRACT, ROOTSCONMODE, DENEST_SQRT.

&RADIUS_REGULAR_POLYGON

See GEOFUNCS.

&RADSUBSTFLAG default:FALSE

if TRUE permits RATSUBST to make substitutions such as U for SQRT(X) in X.

&RANDOM(N)

If supplied, N must be a positive integer or floating point number or 
bfloat number.  RANDOM(N) returns a number of the same kind between zero 
inclusive and N exclusive.  An approximately uniform distribution is used.  
If N is an integer, then N can be no larger than MOST_POSITIVE_FIXNUM.

If no argument is given, RANDOM() returns a random integer between 
MOST_NEGATIVE_FIXNUM/2 and MOST_POSITIVE_FIXNUM/2.

See also RANDOM_ARRAY, GAUSS.

&RANDOM_ARRAY(x, N)

[STATS Package] Computes N random numbers between 0 and 1 using a universal
random number generator which returns uniformly distributed numbers in the
array x.  The universal random number generator used here passes all of the
tests for random number generators and has a period of 2^144, is completely
portable (gives bit identical results on all machines with at least 24-bit
mantissas in the floating point representation).  The algorithm is a
combination of a Fibonacci sequence (with lags of 97 and 33, and operation
"subtraction plus one, modulo one") and an "arithmetic sequence" (using
subtraction). The number generator is initialized by
RANDOM_ARRAY_INIT(seedlist).

Do EXAMPLE(RANDOM_ARRAY); for an example.

See also RANDOM_ARRAY_INIT, RANDOM, GAUSS. 

&RANDOM_ARRAY_INIT({seedlist})

[STATS Package] Initializes the universal random number generator
RANDOM_ARRAY. The optional argument seedlist (default:[1802,9373]) can be
used to initialize the random number generator. The first element IJ must
be such that 0 <= IJ <= 31328 while the second element KL must be such that
0 <= KL <= 30081.

See also RANDOM_ARRAY.

&RANDOM_GAUSS(mean, sd)

Returns a random floating point number from a normal distribution with
mean MEAN and standard deviation SD.  This is part of the BESSEL
function package.

See also RANDOM, NORMAL_DENSITY.

&RANDOMIZE(x1 {, x2, ..., xn})

[STOCH package] Defines x1, ..., xn as random variables in a
common statistical dependency roup.  If none of the arguments 
has previously been RANDOMIZE'd, a new dependency group is created.
If some of the arguments already belong to a dependency group,
the new ones will be assigned to that group.  If arguments belong
to more than one dependency group, those groups will be merged
into one, and any arguments not previously RANDOMIZE'd will be
put in the merged group.

&RANK(M)

computes the rank of the matrix M.  That is, the order of the largest
non-singular subdeterminant of M.  Caveat: RANK may return the wrong answer
if it cannot determine that a matrix element that is equivalent to zero is
indeed so.

Do EXAMPLE(RANK); for an example.

See also RANK_BY_SVD.

&RANK_BY_SVD(M)

Computes the rank of the numerical matrix M by determining the number of
of non-zero singular values. For these purposes, a singular value is
considered to be zero if it is less than MAX(MAT_SIZE(M)) * DFLOAT_EPSILON
* (largest singular value of M).

Do EXAMPLE(RANK_BY_SVD); for an example.

See also RANK.


&RASSOCIATIVE

DECLARE(G,RASSOCIATIVE); tells the simplifier that G is
right-associative.  E.g.  G(G(A,B),G(C,D)) will simplify to
G(A,G(B,G(C,D))).  RASSOCIATIVE is a member of the FEATURES list.  It
can be asserted with DECLARE, withdrawn with REMOVE, and detected with
FEATUREP.

Do EXAMPLE(RASSOCIATIVE); for an example.

See also DOTASSOC, LASSOCIATIVE.

&RAT(exp, v1, ..., vn)

Converts exp to CRE form by expanding and combining all terms over a common
denominator and canceling out the greatest common divisor of the numerator
and denominator as well as converting floating point numbers to rational
numbers within a tolerance of RATEPSILON[2.0E-8].  The variables are
ordered according to the v1,...,vn as in RATVARS, if these are specified.
RAT does not generally simplify functions other than + , - , * , / , and
exponentiation to an integer power whereas RATSIMP does handle these cases.
Note that atoms (numbers and names) in CRE form are not the same as they
are in the general form.  Thus RAT(X)- X results in RAT(0) which has a
different internal representation than 0.

RATFAC default:FALSE

  When TRUE, invokes a partially factored form for CRE rational
  expressions.  During rational operations the expression is
  maintained as fully factored as possible without an actual call to
  the factor package.  This should always save space and may save some
  time in some computations.  The numerator and denominator are still
  made relatively prime. For example,

    RAT((X^2 -1)^4/(X+1)^2); returns (X-1)^4*(X+1)^2,

  but the factors within each part may not be relatively prime.

RATPRINT default:TRUE

  If FALSE, suppresses the printout of the message informing the user
  of the conversion of floating point numbers to rational numbers.

KEEPFLOAT default:FALSE
  If TRUE, prevents floating point numbers from being converted to
  rational numbers.

Do EXAMPLE(RAT); for an example.

See also RATCOEF, RATDIFF, RATDISREP, RATEXPAND, RATFAC, RATNUMER,
RATDENOM, RATNUMP, RATP, RATSIMP.

&RAT_INTERPOLATE(X, XA, YA, N)

[INTERPOL package] Given N points specified by pairs of real numbers
(XA[I],YA[I]) where I=0,...,N-1 (XA and YA are arrays), and given a real
number X, this function returns a value Y(X) which is determined by
interpolation using a rational function with N coefficients which are
divided between the numerator and denominator as evenly as possible.  After
exiting, the variable RAT_INT_ERROR_EST contains an estimate of the
interpolation error.

Do EXAMPLE(RAT_INTERPOLATE); for an example.

See also POLY_INTERPOLATE.

&RATALGDENOM default:TRUE

If TRUE, allows rationalization of denominators wrt.  radicals to take
effect.  To do this one must use CRE form with the ALGEBRAIC switch set to
TRUE, i.e. ALGEBRAIC:TRUE$

&RATCHRISTOF default:TRUE

[CTENSOR package] If TRUE, rational simplification will be performed
on the non-zero components of the Christoffel symbols. If RATFAC:TRUE,
then the components will also be factored.

&RATCOEF(exp, v, n)

Returns the coefficient, C, of the expression v^n in the expression exp.  n
may be omitted if it is 1.  C will be free (except possibly in a
non-rational sense) of the variables in v.  If no coefficient of this type
exists, zero will be returned.  RATCOEF expands and rationally simplifies
its first argument and thus it may produce answers different from those of
COEFF which is purely syntactic.  Thus RATCOEF((X+1)/Y+X,X) returns (Y+1)/Y
whereas COEFF returns 1.  RATCOEF(exp,v,0), viewing exp as a sum, gives a
sum of those terms which do not contain v.  Therefore if v occurs to any
negative powers, RATCOEF should not be used.  Since exp is rationally
simplified before it is examined, coefficients may not appear quite the way
they were envisioned.

Example:

 (c1) S:A*X+B*X+5$

 (c2) RATCOEF(S,A+B);

 (d2)               x

Do EXAMPLE(RATCOEF); for an example.

&RATCURRIND default:0

[GENTRAN package] Specifies the number of blank spaces printed at the
beginning of each line of Ratfor code generated by the GENTRAN or
GENTRANIN commands.

&RATDENOM(exp)

Returns the denominator of the rational expression exp.  If exp is in
general form then the DENOM function should be used instead, unless
one wishes to get a CRE result.

Do EXAMPLE(RATDENOM); for an example.

&RATDENOMDIVIDE default:TRUE

If FALSE, will stop the splitting up of the terms of the numerator of
RATEXPANDed expressions from occurring.

&RATDIFF(exp, var)

Differentiates the rational expression exp (which must be a ratio of
polynomials or a polynomial in the variable var) with respect to var.
For rational expressions this is much faster than DIFF.  The result is
returned in CRE form if the argument is in CRE form, otherwise it is
returned in general representation.  However, RATDIFF should not be
used on factored CRE forms; use DIFF instead for such expressions.

Do EXAMPLE(RATDIFF); for an example.

&RATDISREP(exp)

Changes its argument from CRE form to general form.  This is sometimes
convenient if one wishes to stop the "contagion", or use rational
functions in non-rational contexts.  Most CRE functions will work on
either CRE or non-CRE expressions, but the answers may take different
forms.  If RATDISREP is given a non-CRE for an argument, it returns
its argument unchanged.

Do EXAMPLE(RATDISREP); for an example.

See also TOTALDISREP.

&RATEINSTEIN default:TRUE

[CTENSOR package] If TRUE, rational simplification will be performed
on the non-zero components of Einstein tensors; if RATFAC:TRUE then
the components will also be factored.

&RATEPSILON default:2.0e-8

Specifies the tolerance used in the conversion of floating point
numbers to rational numbers.

&RATEXPAND(exp)

Expands the expression exp by multiplying out products of sums and
exponentiated sums, combining fractions over a common denominator,
canceling the greatest common divisor of the numerator and
denominator, then splitting the numerator (if a sum) into its
respective terms divided by the denominator.  This is accomplished by
converting exp to CRE form and then back to general form.

RATEXPAND default:FALSE
  If TRUE, will cause CRE expressions to be fully expanded when they
  are converted back to general form or displayed.  If FALSE, then
  they will be put into a recursive form. 

RATDENOMDIVIDE default:TRUE
  If FALSE will stop the splitting up of the terms of the numerator of
  RATEXPANDed expressions from occurring.

KEEPFLOAT default:FALSE
  If set to TRUE will prevent floating point numbers from being
  rationalized when expressions which contain them are converted to
  CRE form.

Do EXAMPLE(RATEXPAND); for an example.

See also RAT, RATSIMP.

&RATFAC default:FALSE

When TRUE, invokes a partially factored form for CRE rational
expressions.  During rational operations the expression is maintained
as fully factored as possible without an actual call to the factor
package.  This should always save space and may save some time in some
computations.  The numerator and denominator are still made relatively
prime.  Example:

 (c1) RAT((X^2 -1)^4/(X+1)^2), RATFAC:TRUE;
 (d1) /R/                   (x-1)^4*(x+1)^2

but the factors within each part may not be relatively prime.

In the CTENSOR (Component tensor computation) package, if RATFAC is
TRUE, it causes the Ricci, Einstein, Riemann, and Weyl tensors and the
Scalar Curvature to be factored automatically.  Note: when using CTENSOR,
RATFAC should be set to TRUE only in cases where the tensor components
are known to consist of few terms.

Caveats: 

If some expressions are already in CRE form when you change the setting 
of RATFAC, you should RATDISEP those expressions first if you wish to 
continue working with them with a different setting of RATFAC.

The RATFAC and RATWEIGHT schemes are incompatible and may not both be 
used at the same time.

Do EXAMPLE(RATFAC); for an example.

&RATIONAL - Property

A symbol can be declared RATIONAL if it is known to represent a
rational number or a function that takes only rational values.
RATIONAL is a member of the FEATURES list.  It can be asserted with
DECLARE, withdrawn with REMOVE, and detected with FEATUREP.

&RATIONAL(X)

[FUNCTS package] Finds a rational expression with (real or complex)
rational coefficients which is close to the expression X, and returns
it in general representation.  Similar to RAT, which returns its
result in CRE form.

&RATIONAL_CHEBYSHEV_COEFF(func, a, b, m, k)

Computes a list of coefficients of a rational polynomial approximation
to func in the interval [a,b]. func, a and b must be finite numbers.

The approximation is func(x) =  PM(x)/PK(x)

where PM is a polynomial of degree m and PK is a polynomial of degree k,
whose leading term is 1. Thus, there are m+k+1 degrees of freedom in the
approximation. The approximation is found iteratively by solving equations
such that the maximum deviations are minimized.

Do DEMO(CHEBRATA); for an demo.

See also CHEBYSHEV_COEFF, CHEBYSHEV_INTEGRATE, CHEBYSHEV_DERIVATIVE.

&RATLINELEN default:80

[GENTRAN package] Specifies the maximum number of characters printed
on each line of Ratfor code generated by the GENTRAN or GENTRANIN
commands.

&RATMX default:FALSE

If FALSE, will cause determinant and matrix addition, subtraction, and
multiplication to be performed in the representation of the matrix
elements and will cause the result of matrix inversion to be left in
general representation.  If it is TRUE, the 4 operations mentioned
above will be performed in CRE form and the result of matrix inverse
will be in CRE form.  Note that this may cause the elements to be
expanded (depending on the setting of RATFAC) which might not always
be desired.

Do EXAMPLE(RATMX); for an example.

See also RAT.

&RATNUM_TO_EXPT_EXPAND default:TRUE

If TRUE, then (m/n)^x, when n and m are numbers, is transformed into
m^x/n^x.  (This transformation is also performed if there is something
special about m or x; e.g., x is some kind of number (integer, float,
bfloat, rational), or m is 1, or m is -1 and x is of even or odd type,
etc.)  The idea is that you may wish to cut down on the growth in the
number of x's.

Do EXAMPLE(RATNUM_TO_EXPT_EXPAND); for an example.

&RATNUMER(exp)

Returns the numerator of the rational expression exp.  If exp is in
general form then the NUM function should be used instead, unless one
wishes to get a CRE result.

Do EXAMPLE(RATNUMER); for an example.

&RATNUMP(exp)

If the expression exp is a rational number (includes integers), then
returns TRUE else returns FALSE.

Do EXAMPLE(RATNUMP); for an example.

See also NUMBERP, INTEGERP, PREDICATES.

&RATP(exp)

If the expression exp is in CRE or extended CRE form, then returns
TRUE, else returns FALSE.

See also PREDICATES.

&RATPRINT default:TRUE

If FALSE, suppresses the printout of the message informing the user of
the conversion of floating point numbers to rational numbers.

&RATRIEMAN

This switch has been renamed RATRIEMANN.

&RATRIEMANN default:TRUE

[CTENSOR package] One of the switches which controls simplification of
Riemann tensors.  If TRUE, then rational simplification will be done; if
RATFAC:TRUE then each of the components will also be factored.

See also RIEMANN, LRIEMANN, URIEMANN, RICCI, URICCI, SCURVATURE,
EINSTEIN, WEYL.

&RATSIMP(exp {, v1, v2, ..., vn})

"Rationally" simplifies (similar to RATEXPAND) the expression exp and
all of its subexpressions including the arguments to non- rational
functions.  The result is returned as the quotient of two polynomials
in a recursive form, i.e.  the coefficients of the main variable are
polynomials in the other variables.  Variables may, as in RATEXPAND,
include non-rational functions (e.g. SIN(X^2+1) ) but with RATSIMP,
the arguments to non-rational functions are rationally simplified.
Note that RATSIMP is affected by some of the variables which affect
RATEXPAND.

RATSIMP(exp, v1, v2, ..., vn)
  Enables rational simplification with the specification of variable
  ordering as in RATVARS.

RATSIMPEXPONS default:FALSE

  If TRUE will cause exponents of expressions to be RATSIMPed
  automatically during simplification.

Do EXAMPLE(RATSIMP); for on-line examples.

See also FULLRATSIMP, RATSIMPEXPONS.

&RATSIMPEXPONS default:FALSE 

if TRUE will cause exponents of expressions to be RATSIMPed automatically
during general simplification.

Do EXAMPLE(RATSIMPEXPONS); for an example.

&RATSUBST(a, b, c)

Substitutes a for b in c.  b may be a sum, product, power, etc.
RATSUBST knows more about the meaning of expressions than SUBST, which
performs a purely syntactic substitution.

Example:

 (c1) SUBST(A,X+Y,X+Y+Z)

 (d1)                      x+y+z 

 (c2) RATSUBST(A,X+Y,X+Y+Z);

 (d2)                       z+a

RADSUBSTFLAG default:FALSE
  If TRUE permits RATSUBST to make substitutions like U for SQRT(X)
  in X. 

Do EXAMPLE(RATSUBST); for examples.

See also FULLRATSUBST, LRATSUBST, SUBST.

&RATVARS default:[]

A list in which the rightmost variable vn will be the main variable of
future rational expressions in which it occurs, and the other
variables will follow in sequence.  If a variable is missing from the
RATVARS list, it will be given lower priority than the leftmost
variable v1.  The arguments to RATVARS can be either variables or
non-rational functions such as SIN(X).

Do EXAMPLE(RATVARS); for an example.

RATVARS(v1, v2, ..., vn)

Assigns to the option variable RATVARS the value [v1,,...,vn]. 

See also RATWEIGHT.

&RATWEIGHT(v1, w1, ..., vn, wn)

Assigns a weight of wi to the variable vi.  This causes a term to be
replaced by 0 if its weight exceeds the value of the variable RATWTLVL
(default:FALSE which means no truncation).  The weight of a term is
the sum of the products of the weight of a variable in the term times
its power.  Thus the weight of 3*v1^2*v2 is 2*w1+w2.  This truncation
occurs only when multiplying or exponentiating CRE forms of
expressions.

Note: The RATFAC and RATWEIGHT schemes are incompatible and may not
both be used at the same time.

Do EXAMPLE(RATWEIGHT); for an example.

See also RATVARS, RATWTLVL, RATWEIGHTS.

&RATWEIGHTS

A list of weight assignments (set up by the RATWEIGHT function),
RATWEIGHTS; or RATWEIGHT(); will show you the list.
KILL(...,RATWEIGHTS), and SAVE(...,RATWEIGHTS); both work.

&RATWEYL default:TRUE

[CTENSOR package] One of the switches controlling the simplification
of components of the Weyl conformal tensor.  If TRUE, then the
components will be rationally simplified; if RATFAC is TRUE then the
results will be factored as well.

See also RATWEIGHT, WEYL.

&RATWTLVL default:FALSE

Used in combination with the RATWEIGHT function to control the
truncation of rational (CRE form) expressions (for the default value
of FALSE, no truncation occurs).

&RAYLEIGH_DENSITY(x, beta)

[UNIPROB package] The Rayleigh density function is
  x/beta^2 * exp(-(x/beta)^2/2)
for nonnegative x and beta.

See also RAYLEIGH_DISTRIB.

&RAYLEIGH_DISTRIB(x, beta)

[UNIPROB package] The Rayleigh distribution function is
  1 - EXP(-(x/beta)^2/2)
for nonnegative x and beta.

See also RAYLEIGH_DENSITY and INV_RAYLEIGH_DISTRIB.

&READ(expr1, ..., exprn)

Evaluates and prints its arguments, then reads in and evaluates one
expression.  For example:  A:READ("ENTER THE NUMBER OF VALUES").

Do EXAMPLE(READ); for an example using READ in an interactive program.

See also READONLY, READ_SIMPLE, READONLY_SIMPLE, ASKINTEGER, ASKSIGN,
QUERY, READ_NUMERICAL_DATA, READ_NTH_OBJECT, SELECT_ONE_OF.

&READ_NUM_DATA_TO_ARRAY(filename, arrayname)

Uses READ_NUMERICAL_DATA to input numerical data into a declared array of
compatible dimensions.

Do EXAMPLE(READ_NUM_DATA_TO_ARRAY); for an example.

See also READ_NUMERICAL_DATA, READ_NUM_DATA_TO_MATRIX, WRITE_DATA_TO_FILE.

&READ_NUM_DATA_TO_MATRIX(filename, numrows, numcols)

Uses READ_NUMERICAL_DATA to input numerical data into a matrix of the
specified number of rows and columns.

Do EXAMPLE(READ_NUM_DATA_TO_MATRIX); for an example.

See also READ_NUMERICAL_DATA, READ_NUM_DATA_TO_ARRAY, WRITE_DATA_TO_FILE.

&READ_NUMERICAL_DATA(filename {, startpoint, readlength})

Reads the contents of the specified file and returns the results as a
Macsyma list.  The file can contain integers or floating-point numbers
(single- or double-precision), separated by spaces, tabs, or returns.
The optional argument startpoint specifies which entry will be the
first one read in, and the optional argument readlength specifies how
many numbers to read from the file.

In order to be recognized by READ_NUMERICAL_DATA, floating point
numbers must appear with a digit after the decimal point. For example,
use 1.0 not 1. (1. will be treated as the integer 1)

Do EXAMPLE(READ_NUMERICAL_DATA); for an example.

See also READ, LOAD, READ_NUM_DATA_TO_MATRIX, READ_NUM_DATA_TO_ARRAY,
WRITE_DATA_TO_FILE.

&READ_SIMPLE(string1)

Prints the string string1, then reads in and evaluates one expression.
It differs from READ in that it accepts only one argument which must
be a string, and it asks for the input data to be typed on the same
line as the printed message.

See also READ, READONLY_SIMPLE.

&READONLY(expr1, ..., exprn)

Evaluates and prints its arguments, then reads in an expression (which
in contrast to READ is not evaluated).

See also READ.

&READONLY_SIMPLE(string1)

Prints the string string1, then reads in an expression (which in
contrast to READ is not evaluated).  It differs from READONLY in that
it accepts only one argument which must be a string, and it asks for
the input data to be typed on the same line as the printed message.

See also READ, READONLY, READ_SIMPLE.

&REAL - Property

A symbol can be declared REAL if it is known to represent an real
number or a function that takes only real values.  REAL is a member of
the FEATURES list.  It can be asserted with DECLARE, withdrawn with
REMOVE, and detected with FEATUREP.

See also COMPLEX, REALPART.

&REALONLY default:FALSE

if TRUE causes ALGSYS to return only those solutions which are free of %I.

&REALPART(exp)

Returns the real part of exp.  REALPART and IMAGPART will work on
expressions involving trigonometric and hyperbolic functions, as well
as SQRT, LOG, and exponentiation.

Do EXAMPLE(REALPART); for an example.

See also IMAGPART, COMPLEX.

&REALROOTS(poly {, bound})

Finds all of the real roots of the real univariate polynomial poly
within a tolerance of bound which, if less than 1, causes all integral
roots to be found exactly.  The parameter bound may be arbitrarily
small in order to achieve any desired accuracy.  The first argument
may also be an equation.  REALROOTS sets MULTIPLICITIES, useful in
case of multiple roots.  REALROOTS(poly) is equivalent to
REALROOTS(poly, ROOTSEPSILON).  

REALROOTS(poly {, bound, lower_limit, upper_limit})

  Finds the real roots of poly as described above occurring in the 
  closed interval [lower_limit, upper_limit] .  If not supplied, 
  the interval defaults to (MINF, INF) .

ROOTSEPSILON default:1.0E-7

  Is a real number used to establish the confidence interval (and
  type) for the roots.

Do EXAMPLE(REALROOTS); for an example.

See also SOLVE, LINSOLVE, TAYLOR_SOLVE, NROOTS, NTHROOT, ALLROOTS,
RATCOEF.

&REARRAY(array, dim1, ... , dimk)

Can be used to change the size or dimensions of an array.  The new
array will be filled with the elements of the old one in row-major
order.  If the old array was too small, FALSE, 0.0 or 0 will be used
to fill the remaining elements, depending on the type of the array.
The type of the array cannot be changed.

Do EXAMPLE(REARRAY); for an example.

See also ARRAY.  See ARRAY_SUMMARY for a summary of commands for
manipulating arrays in Macsyma.

&RECTANGULAR_WINDOW(t, t0, t1)

Computes the rectangular Window function:

  if t<t0 or t>t1 then 0 else 1.

See also POWER_SPECTRUM.

&RECTFORM(exp)

returns an expression of the form A + B*%I, where A and B are purely real.

Do EXAMPLE(RECTFORM); for an example.

See also COMPLEX, RECTFORMLIST, REALPART, IMAGPART.

&RECTFORMLIST(expr)

Returns a list consisting of the real and imaginary parts of expression
expr. It is usually faster than using REALPART and IMAGPART separately.

Do EXAMPLE(RECTFORMLIST); for an example.

See also COMPLEX, RECTFORM.

&RECTTOPOLAR(real-array, imag-array)

[FFT package] Undoes POLARTORECT.  The phase is given in the range
from -%PI to %PI.  Like FFT and IFT this function accepts 1 or 2
dimensional arrays.  However, the array dimensions need not be a power
of 2, nor need the 2D arrays be square.

&RECUR

A library package which solves linear recurrence relations and linear
difference equations.  It implements four separate solution methods.

Do USAGE(RECUR); for more information

Do DEMO(RECUR); for a demonstration.

For solving recurrence equations, users should first try the command
DIFFERENCEQ in the DIFFER package.

&REDIFF(exp)

[ITENSOR package] Replaces occurrences of IDIFF whose places are being held
by the symbol 'UNDIFF.

See also UNDIFF and EVUNDIFF.

&REDRAW_PLOT_FILE(filename)

Redraws the plot stored in the file filename.  Filename is optional;
if it is not given, then the current plot file is used.

Available only in some versions of Macsyma.  See PLOTTING_SUMMARY for
more information.

&REFCHECK default:FALSE

If TRUE causes a message to be printed each time a bound variable is used
for the first time in a computation.

&REFERENCE

Do DESCRIBE(ACKNOWLEDGMENT); for more information.

&REGULAR_POLYGON(n)

Draws a regular polygon of n sides. The optional argument center
can be a list of three numbers which specifies the location of the
center of the figure.  The optional argument scale can be a number
which changes the size of the figure.

Do EXAMPLE(REGULAR_POLYGON); for an example.

&REHASH_ARRAY(array_name)

Recomputes the hash for the array array_name if array_name is a hashed
array and returns DONE.  If array_name is a declared array,
REHASH_ARRAY returns FALSE.  Otherwise, REHASH_ARRAY signals an error.

Hashed arrays which have any non-integer subscripts use an incompatible
hash if they're created in a Macsyma atop one Lisp vendor's Lisp and
they're loaded into a Macsyma atop another Lisp vendor's Lisp.  The hash
is different because the Lisps are different.  REHASH_ARRAY computes a
new hash for the array so it can be used.  Functionally, REHASH_ARRAY is
a no-op if array_name is a hashed array and no re-hashing is needed.

&RELAXED_ROOTS default:TRUE

Option variable that sets relaxed or strict confidence bounds
on root finding by ROOTS.

See also ROOTS_TOL.

&REM(a, i)

removes the property indicated by i from the atom a.

Do USAGE(PROPERTIES); for an overview of Macsyma commands to manage
properties of symbols.

Do EXAMPLE(REM); for an example.  

See also PUT, GET, REMOVE, REMARRAY, REMFUNCTION, REMLET, REMRULE,
REMVALUE.

&REMAINDER(p1, p2, var1, ..., varn)

Computes the remainder of the polynomial p1 divided by the polynomial p2.

Do EXAMPLE(REMAINDER); for an example.

&REMARRAY(name1, ..., namen)

Removes arrays and array associated functions and frees the storage
occupied.  If name is ALL then all arrays are removed.  It may be necessary
to use this function if it is desired to redefine the values in a hashed
array.

Do EXAMPLE(REMARRAY); for an example.

See also ARRAYS.

&REMBOX(expr, arg)

Removes boxes from expr according to arg.  If arg is UNLABELED then all
unlabelled boxes are removed.  If arg is the name of some label then only
boxes with that label are removed.  If arg is omitted then all boxes
labeled and unlabelled are removed.

Do EXAMPLE(REMBOX); for an example.

See also BOX, DPART, LPART.

&REMCOMPS(tensor)

[ITENSOR package] Unbinds all values from tensor which were assigned
with the function COMPONENTS. REMCOMPS(ALL); removes all component
assignments from indicial tensors.

&REMCON(tensor1 {, ..., tensorn})

Obsolete. See REMOVE_ICONTRACTION.

&REMCOORD(tensor1 {, ..., tensorn})

Obsolete. See REM0VE_ICOORD.

&REMFUNCTION(f1, f2, ...) 

removes the user defined functions f1,f2,... from Macsyma.  If there is
only one argument of ALL then all functions are removed.

&REMLET(prod {, name})

Deletes the substitution rule, prod --> repl, most recently defined by the
LET function.  If name is supplied the rule is deleted from the rule
package name.  REMLET() and REMLET(ALL) delete all substitution rules from
the current rulepackage.  If the name of a rulepackage is supplied, e.g.
REMLET(ALL, name), the rulepackage, name, is also deleted.  If a
substitution is to be changed using the same product, REMLET need not be
called, just redefine the substitution using the same product (literally)
with the LET function and the new replacement and/or predicate name.
Should REMLET(product) now be called the original substitution rule will be
revived.

See also REMRULE.

&REMOVE(args)

Removes some or all of the properties associated with variables or
functions.

REMOVE(a1, p1, a2, p2, ...)  removes the property pi from the atom ai.
Ai and pi may also be lists as with DECLARE.  Pi may be any property
e.g.  FUNCTION, MODE_DECLARE, etc.  It may also be TRANSFUN implying
that the translated LISP version of the function is to be removed.
This is useful if one wishes to have the Macsyma version of the
function executed rather than the translated version.  Pi may also be
OP or OPERATOR to remove a syntax extension given to ai.  If ai is
"ALL" then the property indicated by pi is removed from all atoms
which have it.  Unlike the more specific remove functions (REMVALUE,
REMARRAY, REMFUNCTION, and REMRULE) REMOVE does not indicate when a
given property is non-existent; it always returns "DONE".

Do EXAMPLE(REMOVE); for an example.

See also REM, REMARRAY, REMFUNCTION, REMLET, REMRULE, REMVALUE.

&REMOVE_ICONTRACTION(tensor1 {, ..., tensorn})

[ITENSOR package] Removes all the contraction properties from the
tensori.  REMOVE_ICONTRACTION(ALL) removes all contraction properties
from all indicial tensors. 

See also DECLARE_ISYMMETRY.

&REM0VE_ICOORD(tensor1 {, ..., tensorn})

[ITENSOR package] Removes the coordinate differentiation property from
the tensori which was established by the function ICOORD. 
REMOVE_ICOORD(ALL); removes this property from all indicial tensors.

See also ICOORD.

&REMOVE_ISYMMETRY(tensor, m)

[ITENSOR package] Removes all symmetries of the specified tensor
(which has m covariant and contravariant indices) which were
specified by DECLARE_ISYMMETRY.  REMOVE_ISYMMETRY(ALL); removes all
symmetry properties from indicial tensors.  REMOVE_ISYMMETRY does not
affect the value of the option variable ALLSYM.

See DECLARE_ISYMMETRY.

&REMOVE_TREND_POLY(x_values, y_values {,method})

Fits the data given by lists (x_values, y_values) with a polynomial of
order method (default: 1) using LSQ1. In addition to plotting the original
data, the polynomial fit and the residuals are also plotted.
REMOVE_POLY_TREND also stores the data and residuals in MFE variables and
displays them in a DataViewer.

Do EXAMPLE(REMOVE_TREND_POLY); for an example.

See also LSQ1.

&REMPART(exp, n)

removes the nth part of expression exp.

Do EXAMPLE(REMPART); for an example.

&REMRULE(function, rulename)

will remove a rule with the name rulename from the function which was
placed there by TELLSIMP, TELLSIMPAFTER or DEFRULE.  Rules created using
DEFRULE are assigned names by the user.  Rules created using TELLSIMP or
TELLSIMPAFTER have names which are automatically generated.  These
generated rulenames have three parts: a prefix, the fragment "RULE", and a
suffix.  The prefix is either a symbol fragment representing the name of
the function, or a string representing the main operator of the expression.
The suffix simply numbers rules which have the same prefix.

If rulename is ALL, then all rules are be removed.

REMRULE also updates the RULES list by removing from it any rules it
eliminates.

See also REMLET, KILL.

&REMSYM(tensor, m)

Obsolete. See REMOVE_ISYMMETRY.

&REMVALUE(name1, name2, ...)

Removes the values of user variables (which can be subscripted) from
the system.  If name is ALL then the values of all user variables are
removed.  Values are those items given names by the user as opposed to
those which are automatically labeled by Macsyma as Ci, Di, or Ei.

&RENAME(exp)

[ITENSOR package] Returns an expression equivalent to exp but with the
dummy indices in each term chosen from the set [!1,!2,...].  Each
dummy index in a product will be different; for a sum RENAME will try
to make each dummy index in a sum the same.  In addition, the indices
will be sorted alphanumerically.

&RENAMEFILE(oldfilespec, newfilespec)

Gives a new name to a file.  RENAMEFILE can move a file to different
devices on most operating systems.

Arguments:

 - Oldfilespec may be any file, expressed in string format, for
   example  "c:\\mydirectory\\filename.ext".
 - Newfilespec may be any file, expressed in string format.

The string format for file specifications can be of two types.

 - Any file specifications can be expressed in literal form, for
   example "c:\\mydirectory\\filename.ext". 

 - If a file is in the Macsyma directory, then a logical filespec
   can be used, for example "macsyma:share;newname.bin" in place of
   the literal "c:\\macsyma2\\share\\newname.fas".

Attempting to change the name of a file that does not exist, or to
rename a file to the name of a file that exists already will generate
an error.  Hence, it is not possible to inadvertently destroy a file
using this command.

See FILE_PATHNAMES for more information about representing file
specifications in Macsyma.

&RENAME_PLOT_FILE(filename)

(In those versions of Macsyma with file-based graphics) Renames the
current plot file to filename.  This command lets the user store the
most recent plot in a uniquely named file; otherwise, the next plot
will overwrite the default plot file.

Available only in some versions of Macsyma.  See PLOTTING_SUMMARY
for more information.

&REPLOT(plotname, arg1, ..., argn)

Replots the plot named plotname.  REPLOT(); and REPLOT(TRUE); both replot
the last plot. arg1,...,argn are are optional arguments which supersede
values used when the plot was created.

Do EXAMPLE(REPLOT); for an example.

Available only in some versions of Macsyma.  See PLOTTING_SUMMARY
for more information.

&REPLOT4(plotname1, ..., plotnamen)
 
Only on Symbolics Lisp machines. 

Replots up to four plots in different parts of the screen. The plotnamei
must be the names of named plots. It locates the first plot in the upper
left, then the upper right, then the lower left, then the lower right.

Do EXAMPLE(REPLOT4); for an example.

&RESET(arg1, ..., argn)

Causes Macsyma to reset one or more option variables to their default
values.  The optional argument arg allows you to specify more precisely
which option variables you want to reset. The argi can have the following
values:

 var       - to reset a particular option variable.
 MYOPTIONS - to reset all user option variables on the MYOPTIONS list.

You can also do RESET(ALL) to restore the default values of all
option variables (including many internal variables that are not
documented).

See also INITIALIZE_MACSYMA.

&RESIDUE(exp, var, val)

computes the residue in the complex plane of the expression exp when the
variable var assumes the value val.  The residue is the coefficient of
(var-val)^(-1) in the Laurent series for exp.

 (c1) RESIDUE(S/(S^2+A^2),S,A*%I);

                         1
 (d1)                    -
                         2

 (c2) RESIDUE(SIN(A*X)/X^4,X,0);

                         3
                        a
 (d2)                 - --
                        6

Do EXAMPLE(RESIDUE); for an example.

&RESIMPLIFY(expr)

Takes expr through the simplification stage again.  That is,
RESIMPLIFY invokes the simplifier on expr again, ignoring the SIMP
flags on the operators of expr.

Many option variables (e.g. EXPOP, EXPON, EXPONENTIALIZE, TRIGSIGN) as
well as the OPPROPERTIES are handled during the simplification stage,
so you can reset some of these and call RESIMPLIFY to transform expr
in some way.

Do EXAMPLE(RESIMPLIFY); for an example.

&REST(exp, n)

Returns exp with its first n elements removed if n is positive and its
last -n elements removed if n is negative.  If n is 1 it may be
omitted.  Exp may be a list, matrix, or other expression.  REST is
affected by the setting of INFLAG.

Do EXAMPLE(REST); for an example.

See also FIRST, FIRST_ELEMENTS, PART, LAST, LAST_ELEMENTS.

&RESTRUCTURE(expr {, transform-templates})

[FORMAT package] Recursively arranges expression expr according to the
chain of templates, transform-templates. RESTRUCTURE walks down the
operator tree of the expression, and re-arranges expressions at each
level as indicated by the templates for that level.

Do USAGE(FORMAT); for more information.

Do EXAMPLE(RESTRUCTURE); for an executable example. Do DEMO(FORMAT);
and DEMO(FORMAT1); for longer demonstrations.

&RESULTANT(p1, p2, var)

Computes the resultant of the two polynomials p1 and p2, eliminating
the variable var.  The resultant is a determinant of the coefficients
of var in p1 and p2 which equals zero if and only if p1 and p2 have a
non-constant factor (i.e. a root) in common, or if they have a common
root at infinity (i.e., simultaneously vanishing leading
coefficients).  If p1 or p2 can be factored, it may be desirable to
call FACTOR before calling RESULTANT.

RESULTANT default:SUBRES

Controls which algorithm will be used to compute the resultant.  The
permitted values of RESULTANT are:

 - SUBRES for subresultant prs [the default],
 - MOD for modular resultant algorithm,
 - RED for reduced prs. 

On most problems SUBRES should be best.  On some large degree
univariate or bivariate problems MOD may be better.  Another
alternative is the BEZOUT command which takes the same arguments as
RESULTANT and returns a matrix.  DETERMINANT of this matrix is the
desired resultant.

Do EXAMPLE(RESULTANT); for an example.

&RETURN(value)

May be used to exit explicitly from a BLOCK or DO statement, returning
its argument as the value of the BLOCK or DO.

Do EXAMPLE(RETURN); for an executable example.

See also BLOCK.

&RETURN_NUMMOD default:FALSE

When TRIGINVERSES is TRUE this switch controls whether expressions
such as atan(tan(x)) return an expression involving NUMMOD or simply
return unchanged.  RETURN_NUMMOD is an evflag.

See also NUMMOD and TRIGINVERSES.

&REVEAL(exp, depth)

Displays the expression exp to the specified integer depth with the
length of each part indicated.  Sums will be displayed as Sum(n) and
products as Product(n) where n is the number of subparts of the sum or
product.  Exponentials will be displayed as EXPT.  REVEAL is affected
by the setting of INFLAG.

 (c1) INTEGRATE(1/(X^3+2),X)$

 (c2) REVEAL(%,2);

 (d2)                    Negterm + Quotient + Quotient

 (c3) REVEAL(D1,3);
                                      ATAN         LOG
 (d3)                 - Quotient + ---------- + ----------
                                   Product(2)   Product(2)

Do EXAMPLE(REVEAL); for an example.

See also PICKAPART.

&REVERSE(list)

Reverses the order of the members of the list (not the members
themselves).  REVERSE also works on general expressions, e.g.
REVERSE(A=B); gives B=A.

Do EXAMPLE(REVERSE); for an example.

REVERSE default:FALSE

  In the Plotting functions, if TRUE cause a left-handed coordinate
  system to be assumed.

&REVERSE_CASE

The default setting for the option variable DISPLAY_CASE.

&REVERT

The REVERT command has been renamed TAYLOR_REVERT.  

Do USAGE(REVERT); for more information.

&RHS(eqn)

The right side of the equation eqn.  If eqn is not an equation,
RHS(exp) returns 0.

Do EXAMPLE(RHS); for an example.

See also LHS.

&RICCI(dis)

[CTENSOR package] Computes the components of the covariant Ricci curvature
tensor, and stores them in the array RIC[i,j].

                 k
     RIC   : RIEM
        jl        jkl

If the argument dis is TRUE, then the unique nonzero components are
displayed.

See also RIEMANN, LRIEMANN, URIEMANN, URICCI, SCURVATURE, EINSTEIN,
LEINSTEIN, WEYL.

&RIEM_SUM_LEFT(expr, x, a, b, n)

Returns the Riemann sum approximation to the definite integral of the
expression expr on the interval [a,b], with n subintervals.  The
expression expr is evaluated at the left-hand endpoint of each
subinterval.

Do EXAMPLE(RIEM_SUM_LEFT); for an example.

See also RIEM_SUM_MIDDLE, RIEM_SUM_RIGHT.

&RIEM_SUM_MIDDLE(expr, x, a, b, n)

Returns the Riemann sum approximation to the definite integral of the
expression expr on the interval [a,b], with n subintervals.  The
expression expr is evaluated at the midpoint of each subinterval.

Do EXAMPLE(RIEM_SUM_MIDDLE); for an example.

See also RIEM_SUM_LEFT, RIEM_SUM_RIGHT.

&RIEM_SUM_RIGHT(expr, x, a, b, n)

Returns the Riemann sum approximation to the definite integral of the
expression expr on the interval [a,b], with n subintervals.  The
expression expr is evaluated at the right-hand endpoint of each
subinterval.

Do EXAMPLE(RIEM_SUM_RIGHT); for an example.

See also RIEM_SUM_LEFT, RIEM_SUM_MIDDLE.

&RIEMANN(dis)

[CTENSOR package] Computes the (1,3) mixed Riemann curvature tensor,
and stores it in the array RIEM[i,j,k,l], where i is a contravariant
(upper) index, and j,k,l are covariant (lower) indices.

         i              i           i        i      m        i      m
     RIEM     : d  MCS    - d  MCS    + MCS    MCS    - MCS    MCS
          jkl    k    lj     l    kj       km     lj       lm     kj

If the argument dis is TRUE, then the unique nonzero components are
displayed.

See also LRIEMANN, RATRIEMANN, URIEMANN, RICCI, URICCI, SCURVATURE,
EINSTEIN, LEINSTEIN, WEYL.

&RIGHT_EIGENS_BY_SCHUR(mat)

Calculates the eigenvalues and right eigenvectors of the matrix mat.

This is another name for EIGENS_BY_SCHUR.

Do USAGE(NUMKIT); for information about numerical linear
algebra.


&RINVARIANT()

[CTENSOR package] Computes the invariant obtained by contracting the
tensors LRIEM[i,j,k,l]*URIEM[i,j,k,l], and stores it in the variable
KINVARIANT.  This object is not automatically simplified since it can be
very large.

&RISCH(exp, var)

Integrates exp with respect to var using the transcendental case of the
Risch algorithm.  (The algebraic case of the Risch algorithm has not been
implemented.)  This currently handles the cases of nested exponentials and
logarithms which the main part of INTEGRATE can't do.  INTEGRATE will
automatically apply RISCH if given these cases.

ERFFLAG default:TRUE
  If FALSE, prevents RISCH from introducing the ERF function in the
  answer if there were none in the integrand to begin with.

Do EXAMPLE(RISCH); for an example.

See also INTEGRATE, INTEGRATION_SUMMARY.

&RMXCHAR default:]

The character used to display the (right) delimiter of a matrix (see also
LMXCHAR).

&RNCOMBINE(exp)

Combines all terms of the expression exp which have identical
denominators or denominators that differ from each other by numerical
factors only.  

This is slightly different from the behavior of COMBINE, which
collects terms that have identical denominators.  Setting
PFEFORMAT:TRUE and using COMBINE will achieve results similar to those
that can be obtained with RNCOMBINE, but RNCOMBINE takes the
additional step of cross-multiplying numerical denominator factors.
This results in neater forms, and the possibility of recognizing some
cancellations.

Do EXAMPLE(RNCOMBINE); for an example.

See also COMBINE.

&ROMBERG(expr, var, ll, ul)
 or 
ROMBERG(fun, ll, ul)

Performs numerical integration using the Romberg method.
 - The first way to call the function, where expr is an expression in
   the variable var, is simpler but less efficient.
 - The second way, where fun is a univariate function, is more
   efficient.  fun must be translated into LISP. 

Do USAGE(ROMBERG); for more information.

Note: ROMBERG does not double evaluate, so e.g. ROMBERG(d5,x,0,1); 
where d5 is an expression in x, does not work.  You must say 
ROMBERG(eval(d5),x,0,1); instead.

Do EXAMPLE(ROMBERG); for an example.  

The behavior of ROMBERG is affected by the option variables
ROMBERGABS, ROMBERGIT, ROMBERGMIN, ROMBERGTOL.

BROMBERG is a higher precision, bigfloat implementation of the
Romberg algorithm.  

Note: ROMBERG assumes that the integrand does not have singularities,
even integrable singularities, within the range of integration. In this
case, try QUADRATR which does handle problems with integrable
singularities.

Do  DEMO(MULTIPLE_INTEGRAL); to see how to perform multiple integration
with ROMBERG.

See also QUADRATR, GAUSS_LEGENDRE_INT, SIMPSON, QUANC8, QUAD_INF,
TRAPRULE. 

&ROMBERGABS default:0.0

Assuming that successive estimates produced by ROMBERG are Y[0], Y[1], Y[2]
etc., then ROMBERG will return after N iterations if (roughly speaking)
 (ABS(Y[N]-Y[N-1]) <= ROMBERGABS
   OR
  ABS(Y[N]-Y[N-1])/(IF Y[N]=0.0 THEN 1.0 ELSE Y[N]) <= ROMBERGTOL)
is TRUE.

The condition on the number of iterations given by ROMBERGMIN must
also be satisfied.

Do USAGE(ROMBERG); for more information.

&ROMBERGIT default:11

The accuracy of the ROMBERG integration command is governed by the
error tolerance ROMBERGTOL and by ROMBERGIT, which is the maximum
number of iterations of ROMBERG.

Do USAGE(ROMBERG); for more information.

&ROMBERGMIN default:0

The minimum number of subintervals into which ROMBERG divides the interval
of integration is 2^(ROMBERGMIN+2).

Do USAGE(ROMBERG); for more information.

&ROMBERGTOL default:1.e-4

The accuracy of the ROMBERG integration command is governed by the
global variables ROMBERGTOL (default:1.E-4) and ROMBERGIT
(default:11).  ROMBERG will return its current result if two
successive iterative refinements yield approximations to the integral
which differ by less than ROMBERGTOL.

Do USAGE(ROMBERG); for more information.

&ROOT_BY_BISECTION(exp, var, lo, hi)

  Searches for a root of a univariate expression `exp' as the
  independent variable `var' varies between limits lo and hi using a
  weighted bisection method.

ROOT_BY_BISECTION(fun, lo, hi)

  Is a variant of ROOT_BY_BISECTION that searches for the root of a
  function fun.

Do USAGE(BISECT); for more information.

Do EXAMPLE(ROOT_BY_BISECTION); for an example, and DEMO(BISECT); for
a longer demonstration.

See also NEWTON.

&ROOT_OF(polynomial {,var})

Expressions of the form ROOT_OF(polynomial,var) are generated by TRIANGSYS
if TRIANGSYS_OUTPUT_FORMAT = 'ROOT_OF (this is the default when SOLVE and
ALGSYS call TRIANGSYS, i.e. in the default case when ALGSYS_USES_TRIANGSYS
is true).  Such an expression denotes any solution of polynomial for var.
For example, ROOT_OF(X^N-1) denotes any N'th root of unity.  You may
enumerate all the possible choices of roots in ROOT_OF expressions via
the ROOT_VALUES command, see its documentation for further details. 
Note that ROOT_VALUES is the only command which currently has any 
knowledge of ROOT_OF expressions.

See also TRIANGSYS.

&ROOT_VALUES(solutions {,approx_type})

ROOT_VALUES enables one to successively refine the solutions
generated by TRIANGSYS (and hence SOLVE and ALGSYS).  The first 
argument should be the solutions generated by one of these commands,
or any single element of such a list of solutions.

ROOT_VALUES permits control over two different aspects of the solutions.

- First, ROOT_VALUES allows one to specify that certain types of ROOT_OF
  expressions should be solved completely and the solution list should
  be expanded (via a back-substitution process) to represent all possible
  solutions that arise from all the various roots of the ROOT_OF. 
  The values of approx_type controlling this behavior are as follows:

  o EXACT:  SOLVE is called to obtain solutions of all ROOT_OF 
    expressions.  Any ROOT_OF that cannot be solved in closed form by 
    SOLVE remains in ROOT_OF notation.

  o RADICAL:  SOLVE is called only to solve binomial polynomials of
    the form a*X^n+b, i.e. those whose roots are radicals.

  o BIQUAD:  SOLVE is called only to solve biquadratic polynomials,
    i.e. polynomials that are either quadratic, or even quartics.

- Second, ROOT_VALUES allows one to specify that all solutions should
  be converted to a numerical type, and that numerical approximations
  should be computed for all ROOT_OFs. The values of approx_type 
  controlling this behavior are as follows:

  o SFLOAT:  single-float approximations are computed using ALLROOTS.

  o DFLOAT:  double-float approximations are computed using ROOTS 
    with the Laguerre method.

  o BFLOAT:  bigfloat approximations are computed using ROOTS with
    the Laguerre method.

  o APPROX:  same as SFLOAT.

  In all cases, if REALONLY is true then REALROOTS is used instead 
  to compute only the real roots. Since REALROOTS uses exact 
  approximations, it may be desirable in circumstances where stability
  is problematic.

- Finally, one may specify a mixture or symbolic and numerical root
  computation by specifying that any polynomials that cannot be
  solved exactly should then be solved numerically. Such behavior is 
  controlled by the following values for approx_type:

  o MIXED_SFLOAT: roots of unsolvable polynomials are computed to
    single-precision

  o MIXED_DFLOAT: roots of unsolvable polynomials are computed to 
    double-precision

  o MIXED_BFLOAT: roots of unsolvable polynomials are computed using 
    bigfloats, with precision specified via the value of BFPRECISION.

  o MIXED: same as MIXED_SFLOAT

The approx_type argument is optional, and if unsupplied, the first
element of ROOT_VALUES_DEFAULT_ARGS is used.

See also TRIANGSYS, ALGSYS, SOLVE.

&ROOT_VALUES_APPROX_TYPES 

default: [EXACT, RADICAL, BIQUAD, MIXED, APPROX, SFLOAT, DFLOAT, BFLOAT,
         MIXED_SFLOAT, MIXED_DFLOAT, MIXED_BFLOAT]

A list of valid approximation types for ROOT_VALUES.

See also ROOT_VALUES_DEFAULT_ARGS.

&ROOT_VALUES_DEFAULT_ARGS default: [EXACT]

A list containing the default values to be used for the optional
arguments to ROOT_VALUES that are unsupplied in a call to ROOT_VALUES.
Currently ROOT_VALUES takes only one optional argument, the second
argument, which specifies the type of root approximation desired.
This argument must be one of the following symbols in the list 
ROOT_VALUES_APPROX_TYPES.

See also ROOT_VALUES.

&ROOTS(poly {, method}) 

Finds roots of the polynomial poly using the following methods:

 1) finds eigenvalues of the companion matrix (default method = 'MATRIX);

 2) finds roots by Laguerre's algorithm (method ='LAGUERRE);

 3) finds roots by Jenkins-Traub algorithm (method='JT; same as ALLROOTS).

 4) Method = 'factor uses method (1) to calculate the roots, but factors the
    polynomial first. (This method should be used only when the polynomial
    has integer or rational numbers as coefficients.)

Finds the real and complex roots of the real or complex polynomial
poly which must be univariate and may be an equation, e.g.  poly=0.
ROOTS will find single precision, double precision or bigfloat roots.
The coefficients of poly may be real or complex.  If the optional
argument method is 'JT, 'JENKINS-TRAUB, then ALLROOTS is called.  
The default method is 'MATRIX, where roots are found by calculating the
eigenvalues of the companion matrix of poly.

In addition, if the flag POLYFACTOR (default:FALSE) is TRUE, solution
roots are displayed in the form (x-r1)*(x-r2)*...*(x-rn).

Roots of multiplicity greater than 1 are displayed without their
multiplicities.

Distinct roots are sorted according to increasing real part.

ROOTS is implemented using single or double precision or big
floating point numbers.   ROOTS may give inaccurate results in case of
multiple roots if the polynomial is unfactored.  Accuracy may be
improved: by adjusting ROOTS_TOL, by using rational numbers as
coefficients as well as factoring, or by using bfloats.

ROOTS will reject input which is not univariate.

Accuracy of found answers can be improved by calling ROOTS_POLISH_LIST. Or
ROOTS_POLISH initially. ROOTS_POLISH uses NEWTON to perform root polishing.
Do EXAMPLE(ROOT_POLISH); for an example.

Overall accuracy may be improved: 

1. By adjusting ROOTS_TOL (default 1.d-9), by using rational numbers as
coefficients as well as factoring, or by using bfloats.

2. Using ROOTS_POLISH or ROOTS_POLISH_LIST, which takes approximate roots
and polishes them with a NEWTON iteration.

ROOTS will reject input which is not univariate.

Accuracy of found answers can be improved by calling ROOTS_POLISH_LIST. Or
ROOTS_POLISH initially. ROOTS_POLISH uses NEWTON to perform root polishing.
Do EXAMPLE(ROOT_POLISH); for an example.

Use ZERO_FIND or ZERO_FIND_LIST to find roots of functions.

Do EXAMPLE(ROOTS); for an example. Do also EXAMPLE(ROOTS_POLISH); .

Do DEMO(ROOTS); for more detailed examples.

See also ALGSYS, ELIMINATE, GROBNER, LINSOLVE, LSQ_LINSOLVE, NROOTS,
NTHROOT, REALROOTS, RATCOEF, SOLVE, TAYLOR_SOLVE, ALLROOTS, ROOTS_TOL,
CHECK_ROOTS, BYPASS_ROOTS_CHECK, ROOTS_POLISH, ROOTS_POLISH_LIST, ZERO_FIND
or ZERO_FIND_LIST.

&ROOTS_POLISH(poly {, method ,tol})

ROOTS_POLISH uses a polynomial root finding method (default:  ROOTS)
method to find roots of the univariate polynomial poly and then
perform NEWTON iteration to improve the accuracy. tol is an optional
tolerance for finding zeros. It defaults to ROOTS_TOL. If tol is a
BFLOAT or rational number, then NEWTON uses BFLOAT precision. Method must be
supplied if tol is.

Do EXAMPLE(ROOTS_POLISH); for an example.

See also NEWTON, ROOTS_POLISH_LIST, ZERO_FIND, ZERO_FIND_LIST,
ROOTS_POLISH_ITER.


&ROOTS_POLISH_ITER default: 25

Controls the number of NEWTON iterations that ROOTS_POLISH uses.

&ROOTS_POLISH_LIST(func, list {,tol})

Like ROOTS_POLISH, ROOTS_POLISH_LIST improves the accuracy of the list
of approximate roots of func by NEWTON iteration. tol is an optional
tolerance for finding zeros. It defaults to ROOTS_TOL.  If tol is a
BFLOAT or rational number, NEWTON uses BFLOAT precision.

The list of roots can be the output of ROOTS or ALLROOTS or SOLVE or
even guesses, and must be supplied in the form

    [ x= R1, x=R2, ...]

where each approximate root Ri is numerical.

Do EXAMPLE(ROOTS_POLISH); for an example.

You can also use ROOTS_POLISH_LIST for roots of real functions, not
just polynomials.

See also NEWTON, ZERO_FIND, ZERO_FIND_LIST, ROOTS_POLISH_ITER.

&ROOTS_POLY_EXACT default TRUE

If TRUE, ROOTS will use exact formula for numerical roots of polynomials
upto  and including fourth order.

See ROOTS, SOLVE.

&ROOTS_TOL default:1.d-9

A positive real number used to establish confidence intervals for the
root found by ROOTS.

A complex root z will be considered real if 
   ABS(IMAGPART(z)) <  tiny * ABS(REALPART(z))

If the option variable RELAXED_ROOTS is TRUE, then tiny = ROOTS_TOL 
(the default). Otherwise, tiny = 3.d-16 for DFLOAT numbers
and 30.d0^(1-BFPRECISION) for bfloat numbers.

&ROOTSCONMODE default:TRUE

Determines the behavior of the ROOTSCONTRACT command.

Do EXAMPLE(ROOTSCONMODE); for an example.

&ROOTSCONTRACT(exp)

Converts products of roots into roots of products.

For example, ROOTSCONTRACT(SQRT(X)*Y^(3/2)); gives SQRT(X*Y^3).  When
RADEXPAND (default:TRUE) is TRUE and DOMAIN (default:REAL) is REAL,
ROOTSCONTRACT converts ABS into SQRT, e.g.
ROOTSCONTRACT(ABS(X)*SQRT(Y)); gives SQRT(X^2*Y).

The option variable ROOTSCONMODE (default:TRUE) affects ROOTSCONTRACT
as follows:

 Problem            ROOTSCONMODE   Result of applying ROOTSCONTRACT
 -------            ------------   -------------------------
 X^(1/2)*Y^(3/2)      FALSE           (X*Y^3)^(1/2)
 X^(1/2)*Y^(1/4)      FALSE           X^(1/2)*Y^(1/4)
 X^(1/2)*Y^(1/4)      TRUE            (X*Y^(1/2))^(1/2)
 X^(1/2)*Y^(1/3)      TRUE            X^(1/2)*Y^(1/3)
 X^(1/2)*Y^(1/4)      ALL             (X^2*Y)^(1/4)
 X^(1/2)*Y^(1/3)      ALL             (X^3*Y^2)^(1/6)

 - When ROOTSCONMODE:FALSE, ROOTSCONTRACT contracts only with respect
   to rational number exponents whose denominators are the same.
 - When ROOTSCONMODE:TRUE, ROOTSCONTRACT combines rational number
   exponents where one denominator divides the other.
 - ROOTSCONMODE:ALL contracts all rational number exponents, by
   extracting the lcm (least common multiple) of the denominators of
   the exponents. 

Caveat: Care should be taken when using ROOTSCONTRACT since the
syntactic transformation it provides is not always valid.  E.g.
ROOTSCONTRACT(SQRT(X)*SQRT(Y)-SQRT(X*Y)); gives 0 which is not valid
when X = Y = -1 .  (The correct answer then is -2 .)

ROOTSCON_SIMPLIFIER default:'RATSIMP

  Determines the simplification function that ROOTSCONTRACT uses to
  simplify its result.  ROOTSCON_SIMPLIFIER can be set to the name of
  any simplification function of one argument.  ROOTSCONTRACT uses
  RATSIMP in a manner similar to LOGCONTRACT.

Do EXAMPLE(ROOTSCONTRACT); to execute the above examples and more.

See also RADCAN, RADEXPAND, ROOTSCONMODE, DENEST_SQRT,
ROOTSCON_SIMPLIFIER.

&ROOTSCON_SIMPLIFIER default:'RATSIMP

Determines the simplification function that ROOTSCONTRACT uses to
simplify its result.  ROOTSCON_SIMPLIFIER can be set to the name of
any simplification function of one argument.

&ROOTSEPSILON default:1.0e-6 in PC Macsyma; 1.0e-7 elsewhere

A real number used to establish the confidence interval for the roots
found by the REALROOTS function.  The type of ROOTSEPSILON (float,
bfloat, etc.) controls the type of the answer returned by REALROOTS.

The user still has to be careful to set ROOTSEPSILON sufficiently 
small to get the desired accuracy no matter what the number type, 
and to set BFPRECISION large enough to match ROOTSEPSILON's 
smallness when the latter is set to a bfloat.

ROOTSEPSILON is also used by ALLROOTS as follows:  When the polynomial 
argument to ALLROOTS is given in terms of integer or rational number 
coefficients, these coefficients are DFLOATed if ROOTSEPSILON is 
smaller than SFLOAT_EPSILON;  otherwise they are SFLOATed.

&ROTATIONS

For rotation matrices in 2 dimensions, see ROTMAT2.

For rotation matrices in 3 dimensions, see ROTMAT3, ROTMATX, ROTMATY,
ROTMATZ.

For counterclockwise rotation of a matrix, see MAT_ROT90.

For general matrix exponentiation, see MATRIX_EXP.  

&ROTMAT2(phi)

[MATFUNCS package] Returns the 2x2 rotation matrix in the x-y plane,
with angle of rotation phi and positive orientation.  That is, the
positive x-axis (as a column vector) rotates into the positive y-axis.

Do EXAMPLE(ROTMAT2); for an example.

See also ROTMATX, ROTMATY, ROTMATZ, ROTMAT3.

&ROTMAT3(theta, phi {, alpha})

[MATFUNCS package] Returns the 3x3 rotation matrix in x-y-z space,
where theta and phi are spherical coordinates. theta=0 on the equator
(x-y plane) and phi is the angle of rotation in the x-y plane.
The optional angle alpha rolls the figure about the (original) x-axis.

Do EXAMPLE(ROTMAT3); for an example.

See also ROTMATX, ROTMATY, ROTMATZ, ROTMAT2.

&ROTMATX(gamma)

[MATFUNCS package] Returns the 3x3 rotation about the X-axis in x-y-z
space, with positive orientation.

Do EXAMPLE(ROTMATX); for an example.

See also ROTMATY, ROTMATZ, ROTMAT2, ROTMAT3.

&ROTMATY(beta)

[MATFUNCS package] Returns the 3x3 rotation about the Y-axis in x-y-z
space, with positive orientation.

Do EXAMPLE(ROTMAT3); for an example.

See also ROTMATX, ROTMATZ, ROTMAT2, ROTMAT3.

&ROTMATZ(alpha)

[MATFUNCS package] Returns the 3x3 rotation about the Z-axis in x-y-z
space, with positive orientation.

Do EXAMPLE(ROTMATZ); for an example.

See also ROTMATX, ROTMATY, ROTMAT2, ROTMAT3.

&ROUND(X)

Rounds to the nearest integer.  If X is half way between two integers,
ROUND returns the nearest even integer.  Examples:

  argument  FLOOR CEILING  FIX  ROUND 
  --------  ----- ------- ----- -----
   2/3       0      1       0     1
  -2/3      -1      0       0    -1

Do EXAMPLE(ROUND); for an example.

See also CEILING, FIX, FLOOR.

&ROW(mat, i)

gives a matrix of the ith row of matrix mat.

Do EXAMPLE(ROW); for an example. 

&ROWS(mat, r)

[MATFUNCS package] Returns the submatrix of matrix M consisting of rows
whose indices are specified in the list `r'.  Do LOAD(MATFUNCS); to access
this function.

&ROWVECTORP(input)

Tests for a row vector.  Must be an empty matrix or a one-row matrix (and
not a list or a scalar).  Notice there is no way to DECLARE a variable to
be a vector (or a matrix).  The vector must be specifically formed.

Do EXAMPLE(ROWVECTORP); for an example.

See also VECTORP, COLVECTORP, MATRIXP, SQUARE_MATRIXP.

&RUGKUT

A library package for the numerical integration of initial-value ordinary
differential equation problems, using the Runge-Kutta method.  The main
function in the package is RUNGE_KUTTA.

Do USAGE(RUGKUT); for more information.

Do DEMO(RUGKUT); for a demonstration.

&RULES default:[]

Returns a list of names which have rules added to them by DEFRULE,
DEFMATCH, TELLSIMP, or TELLSIMPAFTER. Use DISPRULE to display rules
you have already defined. RULES is one of the INFOLISTS.

See RULES_SUMMARY for an overview of rule-based pattern matching
capabilities in Macsyma.

&RULES_SUMMARY

         Summary of Macsyma Pattern Matching Commands
         --------------------------------------------

                   Type #1       Type #2           Type #3      

                  General Rule,   General Rule,   Rational
ACTION            Automatically   User-Applied    Function
                  Applied         By Name         Rule
----------        --------------- ------------  -----------
Define a Pattern   <---  MATCHDECLARE(var,pred) --->
Match Variable

Define a Pattern  TELLSIMP,       DEFRULE,      LET
Matching Rule     TELLSIMPAFTER   DEFMATCH

Apply a Rule      (automatically  APPLY1,       LETSIMP
                   applied)       APPLY2,
                                  APPLYB1

Display          <--  PRINTPROPS(var,MATCHDECLARE)  -->
Matchdeclare
Properties              

Display a Rule   <- DISPRULE(rulename)*->       LETRULES(pkgname)** 

Display all      <---   RULES   --->            -
Rule Names

Remove a Rule    <- REMOVE(rulename,RULE) ->    REMLET(expr,rulename)
                  <-------   KILL(rulename)   ------->
                    REMRULE

* For rules of type #1, rulenames are assigned automatically, and can
  be found by evaluating RULES, and then calling DISPRULE to verify
  what rule the rulename refers to.

See also LETRAT.

&RUNGE_KUTTA(eqn, dep_var, indep_var, dep_var_init, indep_var_start,
indep_var_end, stepsize)

[RUGKUT package] Numerically integrates an ODE, or system of
ODEs, from some initial point.  The ODEs may be either given in
explicit form as equations (similar to what one would give to the
Macsyma routine ODE) or implicitly as functions defining the
derivative as a function of the dependent and independent variables.

Do USAGE(RUGKUT); for more information.

Do EXAMPLE(RUNGE_KUTTA); for an example, and DEMO(RUGKUT); for a
longer demonstration.

See also ODE_NUMSOL and ODE_STIFFSYS.

&SAMPLE_MEAN(sample_list)

[STATS package] Returns the arithmetic mean of sample_list.  sample_list
may contain symbolic entries.

&SAMPLE_MEDIAN(_sample_ {, pred})

[STATS package] Returns the median value of elements of the list
_sample_. _sample_ can have symbolic entries and use assumed information.
By default, SAMPLE_MEDIAN uses "<" as a predicate to sort the elements of
_sample_. You can supply a different predicate with the optional argument
pred.

Do EXAMPLE(SAMPLE_MEDIAN); for an example. 

&SAMPLE_MODE(_sample_)

[STATS package] Computes the mode of the list _sample_, and returns a
list of elements that tie for the highest count.  Also stores the mode
count in the variable SAMPLE_MODE_COUNT.  (The mode of a 
list of elements is the most frequently occurring element.)

Do EXAMPLE(SAMPLE_MODE); for an example.

&SAMPLE_STANDARD_DEVIATION(_sample_)

[STATS package] The positive square root of the variance of the list.
_sample_ may contain symbolic entries.

&SAMPLE_VARIANCE(_sample_)

[STATS package] Returns the variance of a list.  _sample_ may contain
symbolic entries.

&SAVE(filespec, arg1, arg2, ..., argi)

SAVEs those Macsyma objects which are described by the argi in
re-executable form in a file specified by filespec.  The argi's
specify which Macsyma objects are to be SAVEd.

 - arg= ALL tells Macsyma to SAVE the entire contents of your current
   Macsyma computation environment.  

 - argi=VALUES, or argi=FUNCTIONS (or any other items on the
   INFOLISTS) tells Macsyma to SAVE all symbols with their VALUES, or
   all definitions of FUNCTIONS (or all information associated with
   any objects included in any specified INFOLIST).

 - arg=atomicname, where atomicname is the name of an atomic variable,
   means to SAVE all objects named by the symbol atomicname, including
   variable values, functions, macros, rules and arrays.

 - arg=[m,n] where m and n are integers and m<n tells Macsyma to SAVE
   all line labels and their values for lines whose numbers lie
   between m and n inclusive. 

 - arg=CLABELS, DLABELS or ELABELS means to SAVE all corresponding 
   labeled lines and their values.  C and D lines may also be saved,
   but it is better to give them explicit names, which may be done 
   in the command line, for example SAVE(filespec,RESULT1=D15);

SAVE returns a list of the form [filespec,...], where ... are the
names of the objects saved.  Warnings are printed out in the
case of large files, or if an empty file is accidentally generated. 
It is possible to do a SAVE when a WRITEFILE is in progress.

Files saved with SAVE should be reloaded with LOAD.  

See FILENAMES and FILE_PATHNAMES for information about how to
specify file pathnames in Macsyma.  See FILES_SUMMARY for more
information about file manipulation commands in Macsyma.

&SAVEDEF default:TRUE

If TRUE, will cause the Macsyma version of a user function to remain when
the function is TRANSLATEd.  This permits the definition to be displayed by
DISPFUN and allows the function to be edited.  If SAVEDEF is FALSE, the
names of translated functions are removed from the FUNCTIONS list.

&SAVEFACTORS default:FALSE

If TRUE, causes the factors of an expression which is a product of factors
to be saved by certain functions in order to speed up later factorizations
of expressions containing some of the same factors.

&SAVEPLOTS(filename, plotname1,..., plotnamen)

Saves the plots plotnamei in the file plotname. SAVEPLOTS(filename,ALL); or
SAVEPLOTS(filename,PLOTS); will save all the plots in the list PLOTS.

Available only in some versions of Macsyma.  See PLOTTING_SUMMARY
for more information.

&SB_BACKSUB(sba, veca, dim, nsband)

[BANDMAT package] Performs backsubstitution on the load vector VECA using
the reduced form of the symmetric banded matrix SBA.  Both VECA and SBA are
specified as arrays.  DIM is the dimension of the (square) matrix SBA and
of VECA.  NSBAND is the half-bandwidth of the matrix SBA.

See also SB_BACKSUBF, B_BACKSUB, SB_REDUCE.

&SB_BACKSUBF(sba, veca, dim, nsband)

[BANDMAT package] A version of SB_BACKSUB which is optimized for floating
point.  SBA and VECA must be declared floating point arrays.  DIM is the
dimension of the (square) matrix SBA and of VECA.  NSBAND is the
half-bandwidth of the matrix SBA.

&SB_MULTV(wa, sba, va, dim, nsband)

[BANDMAT package] Multiplies the symmetric banded matrix stored as the
array SBA times the vector stored as the array VA.  The result is stored in
the array WA.  DIM is the dimension of the (square) matrices WA and SBA and
of VECA.  NSBAND is the half-bandwidth of the matrices.

See also SB_MULTVF and B_MULTV.

&SB_MULTVF(wa, sba, va, dim, nsband)

[BANDMAT package] A version of SB_MULTV for declared single and double
float arrays, which is more efficient in those cases.  All the arrays must
be declared floating point arrays.  DIM is the dimension of the (square)
matrices WA and SBA and of VECA.  NSBAND is the half-bandwidth of the
matrices.

See also SB_MULTV.

&SB_REDUCE(sba, dim, nsband)

[BANDMAT package] Performs Gauss reduction on a symmetric banded matrix.
SBA is the name of an array which stores the input matrix. SBA is
overwritten with the reduced matrix.  DIM is the dimension of the (square)
matrix SBA.  NSBAND is the half-bandwidth (including the diagonal) of SBA.

See also SB_REDUCEF, SB_BACKSUB, B_REDUCE.

&SB_REDUCEF(sba, dim, nsband)

[BANDMAT package] A version of SB_REDUCE which is optimized for floating
point.  SBA must be a declared floating point array.  DIM is the dimension
of the (square) matrix SBA.  NSBAND is the half-bandwidth (including the
diagonal) of SBA.

&SBAND2FULLA(fa, sba, dim, nsband)

[BANDMAT package] Converts a symmetric banded matrix, stored as an array
SBA, to full matrix storage, and returns the result in an array FA.  See
the BANDMAT package for more information.  DIM is the dimension of the
(square) matrices, and NSBAND is the half-bandwidth (including the
diagonal) of the matrices.

&SBESSEL_J(N, X)
 or
SBESSEL_J[N](X)

[SPECFUN package] Computes the spherical Bessel functions J(N,X) for
nonnegative integers N.

SBESSEL_J[N](X) is an alternative syntax, which stores the spherical
Bessel functions of order less than or equal to N.

Do LOAD(SPECFUN); to access this function.

See BESSEL and USAGE(BESSEL) for more information about Bessel 
functions in Macsyma.

&SCALAR - Property

You can DECLARE an object SCALAR if you want it to be treated as a
scalar with respect to the built-in field.  This affects
simplification of expressions involving the DOT operator.  SCALAR can
be removed with REMOVE.  It can be detected with SCALARP.

&SCALAR_POTENTIAL(givengradient)

[VECT package] Returns the scalar potential of the vector field
givengradiant, in the current coordinate system.

The calculation makes use of the global variable
POTENTIAL_ZERO_LOCATION (default:0) to determine the lower limit of
integration. The success of the integrations invoked by
SCALAR_POTENTIAL may depend upon the values and order of the point
specified by POTENTIAL_ZERO_LOCATION.

&SCALARMATRIXP default:TRUE

If TRUE, then whenever a 1 x 1 matrix is produced as a result of
computing the dot product of matrices it will be converted to a
scalar, namely the only element of the matrix.  If set to ALL, then
this conversion occurs whenever a 1 x 1 matrix is simplified.  If set
to FALSE, no conversion will be done.

See also MATRIX_SUMMARY.

&SCALARP(exp)

Is TRUE if exp is a number, constant, or variable DECLAREd SCALAR, or
composed entirely of numbers, constants, and such variables, but not
containing matrices or lists.

Do EXAMPLE(SCALARP); for an example.

See also NONSCALARP, NUMBERP, CONSTANTP, PREDICATES.

&SCANMAP(function, exp {, BOTTOMUP})

Recursively applies function to exp, in a "top down" manner.  This is
most useful when "complete" factorization is desired.

SCANMAP(function, expression, BOTTOMUP)
  Applies function to exp in a "bottom-up" manner.  For example, for
  undefined F,

  - SCANMAP(F,A*X+B) -> F(A*X+B) -> F(F(A*X)+F(B)) ->
    F(F(F(A)*F(X))+F(B))

  - SCANMAP(F,A*X+B,BOTTOMUP) -> F(A)*F(X)+F(B) ->
    F(F(A)*F(X))+F(B) -> F(F(F(A)*F(X))+F(B))

  In this case, you get the same answer both ways.

Do EXAMPLE(SCANMAP); for an example. 

See also MAP, FULLMAP, FULLMAPL, MAPLIST, MATRIXMAP.

&SCHUR_FORM(A)

Computes and returns the Schur form of the square floating point
matrix A.  The result is also stored as the value of the option variable
SCHUR_FORM.

The option variable SCHUR_FORM contains the Schur form of a matrix 
computed by the last call to either of the functions
EIGENVALUES_BY_SCHUR or SCHUR_FORM or EIGENS_BY_SCHUR.

Do EXAMPLE(SCHUR_FORM); for an example.

See also EIGENVALUES_BY_SCHUR, EIGENS_BY_SCHUR.

For complex floating point matrices, do USAGE(NUMKIT);

&SCHUR_FORM_REAL(A)

Computes and returns the Schur form of the square floating point
matrix A.  The result is also stored as the value of the option variable
SCHUR_FORM.

The option variable SCHUR_FORM contains the Schur form of a matrix 
computed by the last call to either of the functions
EIGENVALUES_BY_SCHUR or SCHUR_FORM or EIGENS_BY_SCHUR.

Do EXAMPLE(SCHUR_FORM); for an example.

See also EIGENVALUES_BY_SCHUR, EIGENS_BY_SCHUR.

Note: works with real matrices only.
For complex floating point matrices, do USAGE(NUMKIT);

&SCSIMP(exp, rule1, rule2,...,rulen)

(Sequential Comparative Simplification [Stoute]) Takes an expression
(its first argument) and a set of identities, or rules (its other
arguments) and tries simplifying.  If a smaller expression is
obtained, the process repeats.  Otherwise after all simplifications
are tried, it returns the original answer.

Do EXAMPLE(SCSIMP); for an example.


&SCURVATURE()

[CTENSOR package] Returns the scalar curvature (obtained by contracting
the Ricci tensor.

See also RIEMANN, LRIEMANN, URIEMANN, RICCI, EINSTEIN, LEINSTEIN,
WEYL. 

&SEC

Secant
&SECD

Same as the SEC function, except the input argument is in degrees.

&SECH

Hyperbolic Secant

&SECOND(exp)

Returns the second part of exp.  It is affected by INFLAG, in the same way
as FIRST.

&SEEK_APPROX_ROOTS(funclist, varlist, corner1, corner2
  {, num_intervals})

Attempts to find possible approximate simultaneous roots
of a list of N functions in a cube in N-dimensional space.

Arguments:
---------
 - funclist is a list of N functions or equations.
 - varlist is a list of N the independent variables.
 - corner1 is a list of the N coordinates of one corner of
   the rectanguloid region to be searched for roots.
 - corner2 is a list of the N coordinates of the opposite
   corner of the rectanguloid region to be searched.
 - num_intervals (optional, default:[10,...,10]) is a list
   of the number of search intervals to be located along
   each coordinate direction.
In the case of one independent variable, all arguments can
be specified without list brackets.

The lists varlist, corner1, and corner2 should be of equal length.
If num_intervals is shorter than varlist (or is not a list), then
it is filled out by repeating the last element specified in 
num_intervals.  

Returned Value:
--------------
SEEK_APPROX_ROOTS returns a list of possible solution points in the 
search region.  Each point is represented as a list of floating point
numbers.  These points are often suitable for use as starting points 
for NEWTON iteration.

Methods:  SEEK_APROX_ROOTS divides the search region into smaller 
regions.  If each element of funclist changes sign on the vertices
of a subregion, then use the secant method (linear interpolation) to 
locate a potential root. 

SEEK_APPROX_ROOTS can miss roots of two kinds.
- roots of functions which are sharply peaked (relative to the 
  scale of the subdivision by boxes).  In this case, a denser
  subdivision by boxes must be used.
- roots at (or near) an extremum the function, such as
  SEEK_APPROX_ROOTS(x^2,x,-1,1).

Do EXAMPLE(SEEK_APPROX_ROOTS); for an example and DEMO(SEEKROOT); for
a longer demonstration.

&SELECT_ONE_OF(ITEMS, PROMPT, ABORTP, PREFERRED_STYLE)

Presents a menu of the given ITEMS (a list) and prompt (a string) and
lets the user select one.  If the user types NONE; then none of the
choices is selected.  When none of the items is selected,
SELECT_ONE_OF will return FALSE unless ABORTP (default:FALSE) is TRUE,
in which case it will abort (see ABORT).  The argument PREFERRED_STYLE
may be used to override the setting of PREFERRED_MENU_STYLE.

Do EXAMPLE(SELECT_ONE_OF); for an example.

See also ASKSIGN, ONE_OF, QUERY, READ.

&SET

Macsyma provides a Set package, which contains the basic primitives of
set theory, and uses Macsyma's list representation.  The notation for
both input and output is [ ... ] rather than { ... } .  The functions
provided are:  INTERSECT, UNION, COMPLEMENT, SETDIFFERENCE,
SYMMDIFFERENCE, POWERSET, SETIFY, SUBSET, SETP, SUBSETP, DISJOINTP,
and CANONLT.

Do USAGE(SET); for more information, and DEMO(SET); and DEMO(SET1);
for demonstrations. 

See also PERMUTATIONS, PERMUTATIONS_LEX, and PERMUTATION_DECOMP.

&SET_ELEMENT(list-or-matrix, i {, j}, value)

Sets the ith element of list or the i,jth element of matrix to value.

 SET_ELEMENT corresponds to the ":" method of setting as follows:
 SET_ELEMENT(list,   i,    value)        list[i]:value
 SET_ELEMENT(matrix, i, j, value)        matrix[i,j]: value
 SET_ELEMENT(matrix, i,    row)          matrix[i]:row

where row is a list of the appropriate length.

However, unlike the ":" method for assignment which returns value or 
row, SET_ELEMENT returns the altered list or matrix.

SET_ELEMENT avoids the ambiguous subscripted syntax of the ":" method 
for assignment, so it is better for use in programs.  

SET_ELEMENT(matrix,i,j,value) is the same as SETELMX(value,i,j,matrix) 
except with a more rational order of arguments.

Do EXAMPLE(SET_ELEMENT); for an example.

&SET_MOMENT(PROD, VAL)

SET_MOMENT is a macro which takes two arguments:

 - PROD is a product of powers of random variables, subscripted
   random variables, random functions or subscripted random 
   functions, and is not evaluated.

 - VAL is an expression for the moment which is being defined as
   the expectation value of PROD.  VAL is not evaluated, allowing
   for expressions such as 
            "<x[i],x[j]>=if i=j then sigma else 0" .

 The moment of the product PROD is defined by VAL, and a display
 of <PROD>=VAL is returned for confirmation.  The first call to
 SET_MOMENT in which PROD contains a random variable VAR defines
 the number of subscripts (if any) and the number of functional 
 arguments (if any) of VAR.  All subsequent references to VAR must 
 have the same numbers of subscripts and arguments, until VAL has been 
 UNRANDOMIZE'd.  All the variables in PROD must belong to the same 
 dependency group.  Moments of products involving more than one
 dependency group will be automatically factored by <<..>>.

SET_MOMENT should not be used to define moments higher than second 
degree when all the variables in PROD have been declared Gaussian, 
since such moments are uniquely determined by the means and 
(co)variances of the Gaussian variables.  Higher degree moments in 
Gaussian variables are expressed in terms of first and second 
moments by GAUSSIMP. 

&SET_ZERO_MEAN( x1 {, x2, ... xn})

[STOCH package] Sets the means of its arguments (which should be
random variables, functions, subscripted random variables or
functions) to zero using SET_MOMENT.

&SETCHECK default:FALSE

A debugging tool.  If set to a list of variables (which can be
subscripted) will cause a printout whenever the variables, or
subscripted occurrences of them, are bound (with : or :: or function
argument binding).  The printout consists of the variable and the
value it is bound to.  SETCHECK may be set to ALL or TRUE thereby
including all variables.  Note: No printout is generated when a
SETCHECKed variable is set to itself, e.g. X:'X.

Do EXAMPLE(SETCHECK); for an example. 

See also BREAK, SETCHECKBREAK, TRACE.

&SETCHECKBREAK default:FALSE

A debugging tool.  If set to ALL or TRUE will cause a (MACSYMA-BREAK)
to occur whenever one of the variables on the SETCHECK list is bound.
The break occurs before the binding is done.  At this point, SETVAL
holds the value to which the variable is about to be set.  Hence, one
may change this value by resetting SETVAL.

If set to a subset of the SETCHECK list, then a (MACSYMA-BREAK) will
occur for these variables (and not all of SETCHECK).

See also BREAK, SETCHECK, TRACE.

&SETDIFFERENCE(a, b)

returns the set of elements of a which are not in b.  Note:
SETDIFFERENCE(a,b); is just COMPLEMENT(b,a);.

Do EXAMPLE(SETDIFFERENCE); for an example. 

See also SET.

&SETELMX(x, i, j, M)

Changes the i,j element of matrix M to x.  The altered matrix is
returned as the value.  The notation M[i,j]:x may also be used,
altering M in a similar manner, but returning x as the value.

Do EXAMPLE(SETELMX); for an example.

See also SET_ELEMENT and MATRIX_SUMMARY.

&SETIFY(list)

Converts list to a set.  For example,

 SETIFY([2,X,2,3,8,X]); -> [2, 3, 8,x].

Do EXAMPLE(SETIFY); for an example.

See also SET.

&SETP(_list_)

Returns TRUE if the list _list_ is a set, otherwise returns FALSE.

See also SET, PREDICATES.

&SETS - See SET.

&SETUP_AUTOLOAD(filespec, func1,..., funcN)

Attaches an autoload property to each function name func1,...,funcn.
After executing this command, if a function with one of the names
func1,...funcn is called when no function definition is currently
loaded, then Macsyma will load the file with file specification
filespec, and use the definition of funcI contained in that file.

As with the other file-handling commands in Macsyma, the arguments
to SETUP_AUTOLOAD are not evaluated. 

Example:

 (c1) SETUP_AUTOLOAD("MACSYMA:SHARE;MYTOOLS.BIN",MYFUNCTION)$ 
 (c2) MYFUNCTION(0.0); 

Note: SETUP_AUTOLOAD does not work for array functions.

See also SHOW_AUTOLOAD.

&SETVAL

Holds the value to which a variable is about to be set when a
SETCHECKBREAK occurs.  Hence, one may change this value by resetting
SETVAL.  (See SETCHECKBREAK).

&SEVENTH(exp)

Returns the seventh part of exp.  It is affected by INFLAG, in the
same way as FIRST.

&SFLOAT(exp)

Converts integers, rational numbers, double-floats, bigfloats and
built-in numerical constants (i.e. %PI, %E, %PHI, %CATALAN and %GAMMA)
in exp to single-floats.

Do EXAMPLE(SFLOAT); for an example.

See also DFLOAT, BFLOAT, NUMER.

&SFLOAT_MINUS_EPSILON

Contains the smallest negative single floating point number EPS,
such that IS(1.0 - EPS = 1.0) is FALSE.

See also SFLOAT_PLUS_EPSILON, DFLOAT_MINUS_EPSILON.

&SFLOAT_PLUS_EPSILON

Contains the smallest positive single floating point number EPS,
such that IS(1.0 + EPS = 1.0) is FALSE.

See also SFLOAT_MINUS_EPSILON, DFLOAT_PLUS_EPSILON.

&SFLOATP(exp)

If the expression exp is a floating point number, then returns TRUE, 
else returns FALSE. 

See also SFLOAT, DFLOATP, FLOATP.

&SHARMONIC_Y(N, M, TH, PH)
 or
SHARMONIC_Y[N,M](TH,PH)

[SPECFUN package] Computes the spherical harmonic Y(N,M,TH,PH) for
integers |M| <= N.

SHARMONIC_Y[N,M](TH,PH)
  Is an alternative syntax, which stores the spherical harmonics of
  order less than or equal to N.

Do LOAD(SPECFUN); to access this function.

&SHANKEL_H1(N,X)
 or
SHANKEL_H1[N](X)

[SPECFUN package] Computes the spherical Hankel functions of the first
kind H1(N,X) for nonnegative integers N.

SHANKEL_H1[N](X)
  Is an alternative syntax, which stores the spherical Hankel
  functions of order less than or equal to N.

Do LOAD(SPECFUN); to access this function.

See also SHANKEL_H2.

&SHANKEL_H2(N,X)
 or
SHANKEL_H2[N](X)

[SPECFUN package] Computes the spherical Hankel functions of the
second kind H2(N,X) for nonnegative integers N.

SHANKEL_H2[N](X)
  Is an alternative syntax, which stores the spherical Hankel
  functions of order less than or equal to N.

Do LOAD(SPECFUN); to access this function.

See also SHANKEL_H1.

&SHERMAN_MORRISON(Ainv, U, V)

Given a square matrix Ainv and two vectors U and V, computes
the inverse of the square matrix (A + U x V), where

 - Ainv = inverse matrix of A,
 - "x" denotes outer product,
 - U and V can be lists, row vectors or column vectors.

This command uses the Sherman-Morrison formula

                              (Ainv . U) . (V . Ainv)
 (A + U x V)^^-1 =  Ainv - ------------------------------
                                1 + (V . Ainv . U)

Do EXAMPLE(SHERMAN_MORRISON); for an example.

See also WOODBURY.

&SHOW

[ITENSOR package] This function has been renamed ISHOW.

&SHOW_AUTOLOAD(function)

If function is autoloadable, SHOW_AUTOLOAD returns the name of the
file in which function is defined, in a form suitable as a argument to
the LOAD function.  If function is not autoloadable, SHOW_AUTOLOAD
returns FALSE.

See also SETUP_AUTOLOAD.

&SHOW_MACSYMA_SOURCE_WITH_TEX_CODE default:TRUE

If this option is TRUE, then TEX writes the Macsyma expressions it's
called on as comments preceding the TeX translations it generates.

Example:

 (c1) 'INTEGRATE(%E^(-X^2),X)=INTEGRATE(%E^(-X^2),X);

                      /      2
                      [   - x       sqrt(%pi) erf(x)
 (d1)                 i %e     dx = ----------------
                      ]                    2
                      /

 (c2) TEX(%);
 % 'INTEGRATE(%E^-X^2,X) = SQRT(%PI)*ERF(X)/2
 $$ \int {e^ {-{ x^{2} }}}{\,dx}={{\sqrt{\pi}\,\left({\rm erf\>}x
  \right)}\over{2}} $$

 (d2)                              done

&SHOW_SPACE(option)

Prints information about the state of internal storage.  This might include
descriptions of the amount of memory in use, etc.

Possible values for option are:
 FALSE - prints out a minimal amount of information.

 TRUE  - prints out an intermediate amount of information.

 ALL   - prints out a maximal amount of information.

Just what SHOW_SPACE prints is dependent on the operating system.
Also, on some operating systems SHOW_SPACE(TRUE); may print the same
information as SHOW_SPACE(FALSE); or SHOW_SPACE(ALL); .

&SHOWRATVARS(exp)

obsolete synonym for LISTRATVARS(exp)

&SHOWTIME default:FALSE

 - If SHOWTIME:TRUE, then the computation time will be printed
   automatically after each command.  

 - If SHOWTIME:ALL, Macsyma also prints out (when not zero) the amount
   of time spent in garbage collection GC) in the course of a
   computation (in addition to the CPU time).  This time is of course
   included in the time printed out as "time=" .

(It should be noted that since the "time=" time only includes
computation time and not any intermediate display time or time it
takes to load in library files, and since it is difficult to
ascribe "responsibility" for GCs, the gctime printed will include
all gctime incurred in the course of the computation and hence may
in rare cases even be larger than "time=").

The following key combination enables you to check time used so far
in a computation without interrupting the computation:

See also TIME, TIMER.

&SIGN(exp)

Attempts to determine the sign of its specified expression on the
basis of the facts in the current database.  It returns one of the
following answers: POS (positive), NEG (negative), ZERO, PZ (positive
or zero), NZ (negative or zero), PN (positive or negative), or PNZ
(positive, negative, or zero, i.e. nothing known).

Macsyma assumes variables are real unless they are DECLAREd COMPLEX 
or the variable DOMAIN is set to COMPLEX.

Do EXAMPLE(SIGN); for an example. 

See also ASKSIGN, SIGNUM, CSIGN, IS, PREDERROR, and PREDICATES.

&SIGNUM(X)

If X is a number, then SIGNUM(X) returns the sign of X as a number.

  Input     Output
  -----     ------
  X < 0       -1
  X = 0        0
  X > 0        1

If X is not numeric, then a simplified but equivalent form is
returned.  For example, SIGNUM(-X) gives -SIGNUM(X).

DIFF(SIGNUM(X),X); gives 0 unless the DELINT package is loaded in 
which case it gives  2*DELTA(x) .  Type GRADEF(SIGNUM(X),0);  if 
you want to convert it back to zero after loading DELINT.

Do EXAMPLE(SIGNUM); for an example. 

See also SIGNUMSIMP, ASKSIGN, SIGN.

&SIGNUMSIMP(expr)

[DELINT package] Performs simplifications on the expression expr, if
expr contains SIGNUM functions. 

See also DELTASIMP.

&SIMILARITYTRANSFORM(mat)

[EIGEN package] Takes a matrix mat as input and returns the same
output as the UNITEIGENVECTORS command (eigenvalues, multiplicities,
and normalized eigenvectors).

The command determines whether the matrix mat is diagonalizable. 

 - If mat is diagonalizable, then the flag NONDIAGONALIZABLE is set to
   FALSE, and two global matrices LEFTMATRIX and RIGHTMATRIX will be 
   generated, which have the property that LEFTMATRIX . MAT .
   RIGHTMATRIX is a diagonal matrix with the eigenvalues of MAT on the
   diagonal. 

 - If mat is not diagonalizable, then the flag NONDIAGONALIZABLE is
   set to TRUE and these two matrices are not generated.

If the flag HERMITIANMATRIX is TRUE then LEFTMATRIX is the complex
conjugate of the transpose of RIGHTMATRIX.  Otherwise LEFTMATRIX is the
inverse of RIGHTMATRIX.  The columns of RIGHTMATRIX are the unit
eigenvectors of MAT.  The other flags (see EIGENVALUES and EIGENVECTORS)
have the same effects since SIMILARITYTRANSFORM calls the other
functions in the package in order to form RIGHTMATRIX.

&SIMP default:TRUE

An option variable which if true, causes an expression to be simplified.
If FALSE, automatic simplification is inhibited.  The simplifier takes an
expression and if possible, makes the expression smaller and more
manageable using built-in algebra. Unless SIMP is set to FALSE, Macsyma
always returns a simplified expression. This option variable should not
normally be set to false except for local use inside a block.

&SIMPLE_VECTOR_P default:FALSE

If TRUE, NONSCALARs are assumed to be "simple vectors", i.e.  vectors
all of whose components are scalars.  This is the setting used by the
VECT package.

If SIMPLE_VECTOR_P is TRUE and  DECLARE([V,V1,V2],NONSCALAR)$ 
has been done, then 

(1) SCALARP(V[x]); is TRUE, since V[x] represents a component of 
    the vector V.

(2) SCALARP(V1.V2); is TRUE, since this is just the dot product of two
    vectors.  In general, SCALARP(V1.V2. ... .Vn); is TRUE for n even,
    and the Vi all NONSCALARP.

Do EXAMPLE(SIMPLE_VECTOR_P); for an example.

&SIMPLIFY(expr)

Invokes the general simplifier on expr.  Normally, SIMPLIFY(EXPR);
is the same as expr; since Macsyma normally simplifies expressions
anyway.  SIMPLIFY does not bind SIMP to TRUE.

Macsyma assumes variables are real unless they are DECLAREd COMPLEX 
or the variable DOMAIN is set to COMPLEX.

Do EXAMPLE(SIMPLIFY); for an example.

&SIMPSON(f, a, b, n)

Performs numerical integration of the function f using Simpson's rule.  The
lower and upper limits of integration are a and b, and the number of
subintervals is n. Simpson's rule requires an even number of intervals
i.e. the last argument to SIMPSON must be an even integer. 

Do EXAMPLE(SIMPSON); for an example. 

See also ROMBERG, BROMBERG, TRAPRULE, QUADTRATR, QUANC8.

&SIMPSUM default:FALSE

 - If TRUE, the result of a SUM is simplified.  This simplification
   may sometimes be able to produce a closed form.

 - If FALSE or if 'SUM is used, the value is a sum noun form which is
   a representation of the sigma notation used in mathematics.

Do EXAMPLE(SIMPSUM); for an example.

See also SUM, NUSUM, SUMCONTRACT, INTOSUM.

&SIN

Sine

&SIN_INT(X)

Represents Si(x)  = integrate(sin(t)/t,t,0,x) .

See also EXP_INT.

&SIND

same as the SIN function, except the input argument is in degrees.

&SINFFT(array1, direction)

[FFT package] Computes the Fast Sine Transform of array1.  The entries of
array1 must be floating point numbers, and the length of array1 must be a
power of two.  direction (either 1 or -1) indicates whether the transform
is from the time domain to the frequency domain (1) or the other way around
(-1).

Do USAGE(FFT); for more information.

Do EXAMPLE(SINFFT); for an example.

See also COSFFT and FFT. See FOURIER_SIN_COEFFS for symbolic Fourier
sine transforms.

&SINH

Hyperbolic Sine

&SINH_INT(X)

represents Shi(x) = integrate(sinh(t)/t,t,0,x) .

See also EXP_INT.

&SIXTH(exp)

Returns the sixth part of exp.  It is affected by INFLAG, in the same way
as FIRST.

&SIZE

To determine the size of an expression use NTERMS, LENGTH, CONS_SIZE,
and STRING_LENGTH.

&SIZE_OF_FLAG default:FALSE

When set to TRUE, this option variable enables the functions MAT_EYE,
MAT_ONES, MAT_ZEROS, MAT_RAND to be applied as, for example,
MAT_EYE(MAT_SIZE(Mat)), which is preferred to the usage MAT_EYE(Mat)
(which requires SIZE_OF_FLAG to be FALSE).

See also SIZE_OFP, MAT_EYE, MAT_ONES, MAT_ZEROS, MAT_RAND.
See also MAT_NROWS, MAT_NCOLS, MAT_LENGTH, SIZE_OFP.

&SIZE_OFP(_input_)

Returns TRUE if input_ might have been returned by MAT_SIZE, that is,
if _input_ is a list of two non-negative integers. Used in cases like
MAT_EYE(MAT_SIZE(Mat)), which is preferred to the usage MAT_EYE(Mat).

See also SIZE_OF_FLAG.

&SKEW_DOT_MULT - Property

SKEW_DOT_MULT stands for skew dot multiplicative.  A function can be
declared SKEW_DOT_MULT if it represents a function with the properties

  h(x1 . x2 . ... . xn); -> h(xn) . ... . h(x1) 

  h(x^^n); -> h(x)^^n ,  where n is an integer.

TRANSPOSE, DETERMINANT, and INVERSE are examples of functions with the
property SKEWE_DOT_MULT.  SKEW_DOT_MULT is a member of the FEATURES
list.  It can be asserted with DECLARE, withdrawn with REMOVE, and
detected with FEATUREP.

&SLEEP(N)

Suspends execution of the current Macsyma process for N seconds before
proceeding. The argument N is required.

&SMALL_TO_ZERO(EXPR,EPS)

[FUNCTS package] Replaces all numbers in expr smaller in absolute value 
than eps by zero.

Do EXAMPLE(SMALL_TO_ZERO); for an example.

&SNEUMANN_N(N, X)
 or
SNEUMANN_N[N](X)

[SPECFUN package] Computes the spherical Neumann functions
N(N,M,TH,PH) for nonnegative integers N.

SNEUMANN_N[N](X)
  Is an alternative syntax, which stores the spherical Neumann
  functions of order less than or equal to N.

Do LOAD(SPECFUN); to access this function.

&SOLVE(exp, var)
 or
SOLVE([eq1, ..., eqn], [v1, ..., vn])

SOLVE(exp, var)
  Solves the algebraic equation exp for the variable var and returns a
  list of solution equations in var.  If exp is not an equation, it is
  assumed to be an expression to be set equal to zero.  Var may be a
  function (e.g. F(X)), or other non-atomic expression except a sum or
  product.  It may be omitted if exp contains only one variable.  Exp
  may be a rational expression, and may contain trigonometric
  functions, exponentials, etc.  SOLVE also solves some equations
  involving radicals.

  SOLVE is primarily for solving equations exactly.  For floating 
  point solutions, see the functions NEWTON, etc.

SOLVE([eq1, ..., eqn], [v1, ..., vn])
  Solves a system of simultaneous (linear or non-linear) polynomial
  equations by calling LINSOLVE or ALGSYS and returns a list of the
  solution lists in the variables.  In the case of LINSOLVE this list
  would contain a single list of solutions.  It takes two lists as
  arguments.  The first list (eqi, i=1,...,n) represents the equations
  to be solved; the second list is a list of the unknowns to be
  determined.  If the total number of variables in the equations is
  equal to the number of equations, the second argument-list may be
  omitted.

When a root cannot be expressed in radicals, SOLVE can return an
expression ROOT_OF(polynomial) which can be converted to floating
point values by ROOT_VALUES and used by other operations.

If SOLVE is given an incompatible set of linear equations, then SOLVE 
displays the message INCONSISTENT. (See SOLVE_INCONSISTENT_EQN_NOS,
SOLVE_INCONSISTENT_TERMS, and SOLVE_INCONSISTENT_ERROR). 

Do USAGE(SOLVE); for more information.

Do EXAMPLE(SOLVE); for an example, and DEMO(SOLVE); for a longer 
demonstration. 

See also ALGSYS, ALLROOTS, ALLSOLVE, ARBINTS, DIFFERENCEQ, 
ELIMINATE, GROBNER, IEQN, LINSOLVE, LSQ_LINSOLVE, NROOTS, NTHROOT, 
ODE, REALROOTS, RATCOEF, SOLVER, TAYLOR_SOLVE, ROOTS, NEWTON, and 
ROOT_BY_BISECTION.

&SOLVE_INCONSISTENT_EQN_NOS default:[]

Set by LINSOLVE to a list of the inconsistent equation numbers.

See also SOLVE_INCONSISTENT_TERMS and SOLVE_INCONSISTENT_ERROR.

&SOLVE_INCONSISTENT_ERROR default:TRUE

If TRUE, SOLVE and LINSOLVE give an error if they meet up with a set
of inconsistent linear equations, e.g. SOLVE([A+B=1,A+B=2]).  If
FALSE, they return [] in this case.  (This is the new mode, previously
gotten only by calling ALGSYS.)

See also SOLVE_INCONSISTENT_EQN_NOS and SOLVE_INCONSISTENT_TERMS.

&SOLVE_INCONSISTENT_TERMS default:[]

Set by LINSOLVE to a list of the subexpressions which if they could be
equivalent to 0 would convert a system of inconsistent equations into
a system of dependent equations.

Do EXAMPLE(SOLVE_INCONSISTENT_TERMS); for an example.

See also SOLVE_INCONSISTENT_EQN_NOS and SOLVE_INCONSISTENT_ERROR.

&SOLVE_TOEPLITZ(M, B)

Solves the matrix equations M . X = B, where M is a Toeplitz matrix
and B is a vector (or a matrix).  Multiple vectors can be specified at
one time by making B a matrix with several columns.

&SOLVE_TRIANGLE(arg1, arg2, arg3, problem_type)

[GEOFUNCS Package] Returns all three sides and all three angles of a
plane triangle, given any three of these six quantities.

Each expression arg1, arg2, arg3 represents either an angle or the
length of a side of the triangle.  The fourth argument, problem_type,
is a three-character symbol or string composed of the letters "a"
and "s", where the ith letter indicates whether argi, is an "angle"
or a "side".  For example, SOLVE_TRIANGLE(a, gamma, b,'sas) means that
a and b are sides and gamma is an angle.

arg1, arg2 and arg3 are located consecutively around the triangle. 
The first side in the argument list is labeled side #1, and the
second (if any) is side #2.  The angles # 1,2,3 are those opposite
to sides #1,2,3 respectively.

This diagram summarizes the positions of the angles and sides.

                  angle1
                    /\
            side3 /    \ side2
                /        \
              /____________\
       angle2     side1     angle3


Do EXAMPLE(SOLVE_TRIANGLE); for an example.

&SOLVEDECOMPOSES default:TRUE

If TRUE, will induce SOLVE to use POLYDECOMP (see POLYDECOMP) in attempting
to solve polynomials.

&SOLVEEXPLICIT default:FALSE

If TRUE, inhibits SOLVE from returning implicit solutions i.e. of the form
F(x)=0.

&SOLVEFACTORS default:TRUE

If FALSE then SOLVE will not try to factor the expression.  The FALSE
setting may be desired in some cases where factoring is not necessary.

&SOLVENULLWARN default:TRUE

If TRUE the user will be warned if he calls SOLVE with either a null
equation list or a null variable list.  For example, SOLVE([],[]); would
print two warning messages and return [].

&SOLVER([eq1, ..., eqn], [v1, ..., vm] {, [p1, ..., pk]})

Tries to solve arbitrary systems of simultaneous linear or non-linear
parametric equations by employing heuristic search and valuation strategies
in combination with the SOLVE and LINSOLVE commands. If the equations
cannot be solved explicitly - either because there exists no analytic
solution or because the symbolic solution is too complex - the Solver
attempts to solve a subset and returns the nonlinear kernel that could not
be solved.  These kernel equations can then be solved with numerical
techniques.

SOLVER takes three lists as arguments. The first list (eqi, i=1,...,n)
represents the equations to be solved. The second list (vi, i=1,...,m)
is a list of the unknowns to be determined. The third list (pi,
i=1,...,k) holds the parameter symbols of the system. It may be
omitted if there are no parameters.

The SOLVER attempts to solve [eq1, ..., eqn] for [v1, ..., vm] in
terms of the parameters [p1, ..., pk]. If the list of unknowns does
not contain all symbols which appear in the system then SOLVER tries
to eliminate all variables which are neither specified as a variable
vi or a parameter pj.

Do USAGE(SOLVER); for more information.

Do EXAMPLE(SOLVER); for an example.  Do DEMO(SOLVER); DEMO(SOLVER1);
and DEMO(SOLVER2); for longer demonstrations.

See also SOLVE.

&SOLVERADCAN default:FALSE

If TRUE then SOLVE will use RADCAN which will make SOLVE slower but will
allow certain problems containing exponentials and logs to be solved.

&SOLVETRIGWARN default:TRUE

If set to FALSE will inhibit printing by SOLVE of the warning message
saying that it is using inverse trigonometric functions to solve the
equation, and thereby losing solutions.  But this won't happen when
ALLSOLVE (default:TRUE) is TRUE.

&SORT(list {, optional-predicate})

Sorts the list using a suitable optional-predicate of two arguments
(such as "<" or ORDERLESSP).  If the optional-predicate is not given,
then Macsyma's built-in ordering predicate is used.

SORT is not destructive to its input list.

Do EXAMPLE(SORT); for an example.

See also CANONLT, ORDERGREAT, ORDERLESS, ORDERGREATP, ORDERLESSP,
UNORDER.

&SPARSE 

SPARSE is used in two ways in Macsyma:

- The option variable SPARSE (default:FALSE)

  If set to TRUE, then the DETERMINANT and INVERT functions use
  special routines for computing the determinant and inverse,
  respectively, of a sparse matrix. The SPARSE option variable is
  only for computing with matrices stored in the general matrix
  representation, using algorithms for sparse matrices.

  Do EXAMPLE(SPARSE); for examples.

- Macsyma has a special sparse matrix representation which can
  give very good performance for large sparse matrices.  

  Do USAGE(SPARSE); for more information.

  Do DEMO(SPARSE); for a demonstration.

&SPARSE_ADD_COLS(mat_to, mat_from, col1, ..., coln)

[SPARSE package] Starting with the sparse matrix mat_from, adds
columns given in SPARSE_ROW_ELEMS form, that is, each column is
specified as [[row_index,value], ...] .  The value returned is
the symbol mat_to.  mat_to and mat_from can be the same sparse
matrix name.  

Do USAGE(SPARSE); for more information.

Do EXAMPLE(SPARSE_ADD_COLS); for an example.

&SPARSE_ADD_ROWS(mat_to, mat_from, row1, ..., rown)

[SPARSE package] Starting with the sparse matrix mat_from, adds
rows given in SPARSE_ROW_ELEMS form, that is, each row is specified
as [[col_index,value], ...] .  The value returned is the symbol
mat_to.  mat_to and mat_from can be the same sparse matrix name. 

Do USAGE(SPARSE); for more information.

Do EXAMPLE(SPARSE_ADD_ROWS); for an example.

&SPARSE_DELETE_COLS(mat_to, mat_from, col_list)

[SPARSE package] Deletes the columns specified by col_list, a list
of integers, from the sparse matrix mat_from.  The value returned
is the symbol mat_to. mat_to and mat_from can be the same sparse
matrix name. 

Do USAGE(SPARSE); for more information.

Do EXAMPLE(SPARSE_DELETE_COLS); for an example.

&SPARSE_DELETE_ROWS(mat_to, mat_from, row_list)

[SPARSE package] Deletes the rows specified by row_list, a list
of integers, from the sparse matrix mat_from.  The value returned
is the symbol mat_to. mat_to and mat_from can be the same sparse
matrix name.  

Do USAGE(SPARSE); for more information.

Do EXAMPLE(SPARSE_DELETE_ROWS); for an example.

&SPARSE_MATRIXP(x)

[SPARSE package] Tests whether x is declared a sparse matrix.

Do USAGE(SPARSE); for more information.

Do EXAMPLE(SPARSE_MATRIXP); for an example.

&SPARSE_NEXT_COL_INDEX (default: 0)

[SPARSE package] Assigned to by SPARSE_NEXT_ROW_ELEM.

Do USAGE(SPARSE); for more information.

&SPARSE_NEXT_ROW_ELEM(mat, i, j)

[SPARSE package] Given a sparse matrix mat, returns the (value of
the) next sparse matrix element after mat[i,j] in row i.  Its
column index is returned as the value of SPARSE_NEXT_COL_INDEX.

If there are no nonzero matrix elements after mat[i,j] in 
row i then SPARSE_NEXT_ROW_ELEM(mat,i,j) returns zero, and 
more importantly SPARSE_NEXT_COL_INDEX is set to 0 .

To get the first nonzero matrix element in row i , call
SPARSE_NEXT_ROW_ELEM(mat,i,0) .

Do USAGE(SPARSE); for more information.

Do EXAMPLE(SPARSE_NEXT_ROW_ELEM); for an example.

&SPARSE_SUBMATRIX(mat_to, mat_from, row_list, col_list)

[SPARSE package] Deletes the specified rows and columns from the
sparse matrix mat_from.  The value returned is the symbol mat_to. 
mat_to and mat_from can be the same sparse matrix name. 

Do USAGE(SPARSE); for more information.

Do EXAMPLE(SPARSE_SUBMATRIX); for an example.

&SPARSE_VECTORP(x)

[SPARSE package] Tests whether x is declared a sparse vector.

Do USAGE(SPARSE); for more information.

Do EXAMPLE(SPARSE_VECTORP); for an example.

&SPARSE_ROW_COUNT(mat, i)

[SPARSE package] Returns the count of nonzero elements in
row i of the sparse matrix mat.

Do USAGE(SPARSE); for more information.

Do EXAMPLE(SPARSE_ROW_COUNT); for an example.

&SPARSE_ROW_ELEMS(mat, i)

[SPARSE package] Returns a list of the nonzero elements in 
row i of the sparse matrix mat.

Do USAGE(SPARSE); for more information.

Do EXAMPLE(SPARSE_ROW_ELEMS); for an example.

&SPARSE_ROW_INDICES(mat, i)

[SPARSE package] Returns a list of the column indices of the
nonzero elements in row i of the sparse matrix mat.

Do USAGE(SPARSE); for more information.

Do EXAMPLE(SPARSE_ROW_INDICES); for an example.

&SPARSE_TRANSPOSE(mat_to, mat_from)

[SPARSE package] Returns the transpose of the sparse matrix
mat_from as the sparse matrix mat_to.  The value returned is
the symbol mat_to. mat_to and mat_from can be the same sparse
matrix name. 

Do USAGE(SPARSE); for more information.

Do EXAMPLE(SPARSE_TRANSPOSE); for an example.

&SPARSE_ZERO_ROWS(mat)

[SPARSE package] Returns a list of the indices of the zero
rows of the sparse matrix mat.

Do USAGE(SPARSE); for more information.

Do EXAMPLE(SPARSE_ZERO_ROWS); for an example.

&SPECFUN - A package for computing special functions.  The following
special functions are available:

 - Chebyshev polynomials           CHEBYSHEV_T
                                   CHEBYSHEV_U
 - Gegenbauer polynomials          GEGENBAUER_C
 - Hermite polynomials             HERMITE_H
 - Laguerre polynomials            LAGUERRE_L
 - Associated Laguerre polynomials ALAGUERRE_L
 - Legendre polynomials,
          1st kind                 LEGENDRE_P
          2nd kind                 LEGENDRE_Q
 - Associated Legendre polynomials,
          1st kind                 ALEGENDRE_P
          2nd kind                 ALEGENDRE_Q
 - Jacobi polynomials              JACOBI_P
 - Spherical Bessel functions      SBESSEL_J
 - Spherical Hankel functions,
          1st kind                 SHANKEL_H1
          2nd kind                 SHANKEL_H2
 - Spherical harmonics             SHARMONIC_Y
 - Spherical Neumann functions     SNEUMANN_N

When called as FUNCTION(X, ..), these functions autoload.  When called
with the syntax FUNCTION([N][x,..), it is necessary to do
LOAD(SPECFUN); to access these functions.

Do USAGE(SPECFUN); for more information.

Do DEMO(SPECFUN); for a demonstration.

See SPECIAL_FUNCTIONS for a summary of special functions in Macsyma.
See PROBABILITY_FUNCTIONS for information regarding density and
distribution functions.

&SPECIAL_FUNCTIONS

Macsyma contains many special functions, some of which can be
evaluated symbolically and numerically, some of which can be evaluated
only numerically.  Other special functions cannot be evaluated, but
are used to express results of certain integrals and solutions of
differential equations.

Many of the special functions which can be evaluated symbolically and
numerically are contained in the library package SPECFUN.  To access
this package, do LOAD(SPECFUN);. 

                Special Functions in Macsyma
                ----------------------------

In this notation, K, N and M must be integers, N>=0 .
A, B, X, MU, NU, TH and PH are real numbers.
Z is a complex number.

Name                            Macsyma Name
----------                      ------------
Airy functions                  AIRY_AI(X)
                                AIRY_BI(X)
Derivatives of Airy functions   AIRY_AI_DERIV(X)
                                AIRY_BI_DERIV(X)

Bateman function K              BATEMAN_K[NU](Z)

Bernoulli polynomials           BERNPOLY(X,N)

Bessel functions, 1st kind      BESSEL_J[NU](Z)
                                BESSEL(Z,NU)

Bessel functions, 2nd kind      BESSEL_Y(NU,Z)

Modified Bessel functions,      
    1st kind                    BESSEL_I[NU](Z)
                                I0(X), I1(X), IN(X,N)

Modified Bessel functions,
    1st kind, times exp(-|X|)   G0(X), G1(X), GN(X,N)

Modified Bessel functions,
    2nd kind                    BESSEL_K[N](Z)

Chebyshev polynomials T         CHEBYSHEV_T(N,X)
                                CHEBYSHEV_T[N](X)
Chebyshev polynomials U         CHEBYSHEV_U(N,X)
                                CHEBYSHEV_U[N](X)

Cosine integral                 COS_INT(X)

Cosh integral                   COSH_INT(X)

Error function                  ERF(Z)
Complementary error function    ERFC(Z)
Complex error function          WERF(Z)
Inverse error function          INV_ERF(X)

Complete elliptic integrals,
    first kind                  ELLIPTIC_KC(Mod) \  0<=Mod<1       
    second kind                 ELLIPTIC_EC(Mod) / 

Incomplete elliptic integrals,
    first kind                  ELLIPTIC_F(Phi,Mod)  \  0<=Mod<1       
    second kind                 ELLIPTIC_E(Phi,Mod)  / 
                                ELLIPTIC_E_BY_CARLSON(Phi, Mod)
                                ELLIPTIC_F_BY_CARLSON(Phi, Mod)

Carlson's Elliptic integrals    CARLSON_R_C
                                CARLSON_R_D
                                CARLSON_R_F
                                CARLSON_R_J

Euler polynomials               EULERPOLY(X,N)

Exponential integral            EXP_INT(X)

Gamma function                  GAMMA(X)
                                GAMMAGREEK(A,X)
Incomplete gamma function       GAMMA(A,X)
                                GAMMA_INCOMPLETE(A,X)
Complex gamma function          CGAMMA(Z)
Complex bigfloat gamma          CBFAC(Z,BFPREC)
        
Solutions to the hypergeometric GAUSS_A(a,b,g,x)
differential equation           GAUSS_B(a,b,g,x)

Gegenbauer polynomials          GEGENBAUER_C(N,A,X)   \  -1/2 < A
                                GEGENBAUER_C[N](A,X)  /   A # 0

Hankel functions                HANKEL_H[mu,nu](z)

Hermite polynomials             HERMITE_H(N,X)
                                HERMITE_H[N](X)

Hurwitz Zeta function           BFHZETA(S,H,BFPREC)

Hypergeometric Functions        HYPER_F[p,q](list1,list2,x)

Jacobi polynomials              JACOBI_P(N,A,B,X)     \  -1 < A,B
                                JACOBI_P[N](A,B,X)    /

Jacobian elliptic functions     JACOBI_AM(X,Mod)   \    
                                JACOBI_AM1(X,Mod1)  |   
                                JACOBI_CN(X,Mod)        0<=Mod<=1
                                JACOBI_SN(X,Mod)    |   Mod1:=Mod-1
                                JACOBI_DN(X,Mod)   /
                                JACOBI_AM_BY_CARLSON(X,MOD)

Kummer's Confluent              KUMMER_M(a,b,z)
Hypergeometric Functions.       KUMMER_U(a,b,z)

Laguerre polynomials            LAGUERRE_L(N,X)
                                LAGUERRE_L[N](X)

Associated Laguerre polynomials ALAGUERRE_L(N,A,X)    \ -1 < A
                                ALAGUERRE_L[N](A,X)   /

Legendre polynomials, 1st kind  LEGENDRE_P(N,X)
                                LEGENDRE_P[N](X)

Legendre polynomials, 2nd kind  LEGENDRE_Q(N,X)
                                LEGENDRE_Q[N](X)

Associated Legendre polynomials ALEGENDRE_P(N,M,X)    \ 0 < M <= N
    1st kind                    ALEGENDRE_P[N,M](X)   /

Associated Legendre polynomials ALEGENDRE_Q(N,M,X)
    2nd kind

Lommel S function               LOMMEL_S[MU,NU](Z)

Lommel s function               LOMMEL_S_LITTLE[MU,NU](Z)

Mathieu functions               MATHIEU_A[a,b](z)
                                MATHIEU_B[a,b](z)

Parabolic cylinder functions    PARABOLIC_CYLINDER_D[NU](Z)

Polygamma functions             PSI[N](X)
                                BFPSI(N,X,BFPREC)

Polylogarithm functions         LI[N](X)

Plasma dispersion function      NZETA(Z)

Riemann Zeta function           ZETA(X)
                                BFZETA(X)

Sine integral                   SIN_INT(X)

Sinh Integral                   SINH_INT(X)

Spherical Bessel functions      SBESSEL_J(N,X)
                                SBESSEL_J[N](X)
Spherical Hankel functions,
    1st kind                    SHANKEL_H1(N,X)
                                SHANKEL_H1[N](X)
Spherical Hankel functions,
    2nd kind                    SHANKEL_H2(N,X)
                                SHANKEL_H2[N](X)

Spherical harmonics             SHARMONIC_Y(N,M,TH,PH)  \  |M| <= N
                                SHARMONIC_Y[N,M](TH,PH) /

Spherical Neumann functions     SNEUMANN_N(N,X)
                                SNEUMANN_N[N](X)

Struve functions H              STRUVE_H[NU](Z)
Modified Struve functions L     STRUVE_L[NU](Z)

Whittaker function              WHITTAKER_M[K,MU](X)
Whittaker function              WHITTAKER_W[K,MU](X)

See the following topics for more information about special
functions in Macsyma:

 - HGFRED - Hypergeometric functions.
 - BFFAC - Factorial and Riemann Zeta functions.  
 - Do USAGE(BESSEL); for information about Bessel functions J[n](x)
      and modified Bessel functions I[n](x).
 - SPECINT - integrals involving special functions.   

The SPECFUN package contains 16 families of orthogonal polynomials,
Bessel functions, and spherical harmonics, evaluated symbolically and
numerically.

The FUNCTS package contains miscellaneous functions utility functions.

See PROBABILITY_FUNCTIONS for information about discrete and continuous
probability density and distribution functions. 

&SPECINT

The Hypergeometric Special Functions Package HYPGEO is still under
development.  At the moment it will find the Laplace Transform or
rather, the integral from 0 to INF of some special functions or
combinations of them.  The factor, EXP(-s*var) must be explicitly
stated.  The syntax is as follows:

SPECINT(EXP(-s*var)*expr, var);

where var is the variable of integration and expr may be any
expression containing special functions (at your own risk). See
SPECIAL_FUNCTIONS for explanation of names of special functions
in Macsyma.

Do DEMO(SPECINT); for a demonstration.

&SPHERE_SURFACE(dim, rad)

[GEOFUNCS package] Returns the surface area of a sphere in dim
dimensions with radius rad.

&SPHERE_VOLUME(dim, rad)

[GEOFUNCS package] Returns the volume of a sphere in dim dimensions
with radius rad.

&SPLINE_COEFF(XA, YA, YSP, N {, [DY0,DYLAST]})

[INTERPOL package] Creates an array YSP of spline coefficients used to
interpolate Y with respect to X, using N data points.  XA and YA are
arrays of length N (indices running from 0 to N-1). XA or YA can also
be lists with N numerical elements.  The array XA must be monotonic.
DY0 and DYLAST are the values of the first derivative of Y with
respect to X at the first and last endpoint of the X-coordinate.  If
DY0 and DYLAST are not provided, or if they are 'NATURAL, a natural
boundary condition for the corresponding endpoint is used.  (y''=0).
 
This function prepares the spline coefficients needed by the command
SPLINE_INTERPOLATE.

Do EXAMPLE(SPLINE_COEFF); for an example, and DEMO(INTERPOL1);
for a longer demonstration.

&SPLINE_FLOATER default:'DFLOAT

Method used by SPLINE_COEFF and SPLINE_INTERPOLATE to convert
arguments to floating point representation.

&SPLINE_INTERPOLATE(x, xa, ya, ysc, n)

[INTERPOL package] Given a value X and arrays XA and YA of length N
(running from 0 to N-1), and given array (of length N) YSC with the
spline coefficients of Y with respect to X, interpolate a value Y(X)
using cubic spline methods and N data points.  The array XA must be
monotonic. The spline coefficients needed by SPLINE_INTERPOLATE can be
produced using the command SPLINE_COEFF.

Do EXAMPLE(SPLINE_INTERPOLATE); for an example, and DEMO(INTERPOL1);
for a longer demonstration.

&SQFR(exp)

Is similar to FACTOR except that the polynomial factors are
"square-free." That is, they have factors only of degree one.  This
algorithm, which is also used by the first stage of FACTOR, utilizes
the fact that a polynomial has in common with its nth derivative all
its factors of degree > n.  Thus by taking gcds with the polynomial of
the derivatives with respect to each variable in the polynomial, all
factors of degree > 1 can be found.

Example:

 (c1) EXP;
                            4      3      2
 (d1)                    4 x  + 4 x  - 3 x  - 4 x - 1
 (c2) FACTOR(EXP);
                                                   2
 (d2)                     (x - 1) (x + 1) (2 x + 1)
 (c3) SQFR(EXP);
                                      2   2
 (d3)                        (2 x + 1)  (x  - 1)


Do EXAMPLE(SQFR); for an example.

&SQRT(X)

Returns the principal square root of X.  E.g.  sqrt(4); gives 2 .
It is represented internally by X^(1/2).

RADEXPAND default:TRUE
  If TRUE, will cause nth roots of factors of a product which are
  powers of n to be pulled outside of the radical, e.g. SQRT(16*X^2)
  will become 4*X only if RADEXPAND is TRUE.

Do EXAMPLE(SQRT); for an example.

See also ISQRT, INRT, ROOTSCONTRACT, DENEST_SQRT, SQRTDISPFLAG.

&SQRTDENEST(exp)

Now obsolete.  See DENEST_SQRT.

&SQRTDISPFLAG default:TRUE

If FALSE causes SQRT to display with exponent 1/2.

&SQUARE_MATRIXP(x)

Returns TRUE if and only if x is a square matrix.

See also MATRIX_SUMMARY, PREDICATES.

&SRRAT(exp)

Has been renamed to TAYTORAT.

&SSTATUS(keyword, arg)

Changes the status information returned by STATUS for the keyword and
arg given. the expression STATUS(SSTATUS); returns a list of keywords
that are valid in the current implementation.

The only keyword currently accepted by STATUS is FEATURE. This turns 
on the feature arg so that future calls to STATUS(FEATURE,ARG) return TRUE. 
This can be useful for package writers, to keep track of what FEATURES they 
have loaded in.

&STACK_SYMMETRIC(mat)

Returns a column vector of the independent elements of a real symmetric
matrix mat.

If mat is [1,2,3;
           2,4,5;
           3,5,6]

then STACK_SYMMETRIC(mat) is

     [1;
      2;
      3;
      4;
      5;
      6]

Do EXAMPLE(STACK_SYMMETRIC); for an example.

&STANDARD_NORMAL_DENSITY(X)

[UNIPROB package] The standard normal probability density function

                        2
                       x
                     - -
                       2
                   %e
      f(x) = ----------------  .
             sqrt(2) sqrt(%pi)


Do EXAMPLE(STANDARD_NORMAL_DENSITY); for an example.

See also STANDARD_NORMAL_DISTRIB, NORMAL_DENSITY, GAUSS.

&STANDARD_NORMAL_DISTRIB(X)

[UNIPROB package] The standard normal cumulative distribution
function.

Do EXAMPLE(STANDARD_NORMAL_DISTRIB); for an example.

See also STANDARD_NORMAL_DENSITY, NORMAL_DISTRIB, 
INV_STANDARD_NORMAL_DISTRIB, GAUSS.

&STANDARDIZE_SIGNS(exp)

Arranges all the algebraic signs in expression exp in a standard
manner, which assists in recognizing cancellations and
simplifications.

Do EXAMPLE(STANDARDIZE_SIGNS); for an example.

&STAP - See STATIONARY_POINT.

&STARDISP default:FALSE

If TRUE, will cause multiplication to be displayed explicitly with a
"*" between operands.

&STATIONARY_POINT(objective, lezeros, eqzeros, decisionvars)

Finds critical points of a multivariate objective function subject to
equality and/or inequality constraints. 

The arguments of STATIONARY_POINT are

 - OBJECTIVE is an expression denoting the objective function or the
   label of such an expression.
 - LEZEROS is a list of expressions which are constrained to be less
   than or equal to zero.  Use [] if no such constraints.
 - EQZEROS is a list of expressions which are constrained to equal
   zero, or the label of such a list.  Use [] if there are no such
   constraints.
 - DECISIONVARS is a list of the decision variables or the label of
   such a list.  May use [] if all variables in objective and
   constraints are decision variables.

For convenience, brackets may be omitted from one-expression lists,
and trailing [] arguments may be omitted.

STAP is an obsolete name for STATIONARY_POINT.

Do USAGE(OPTMIZ); for more information.

Do EXAMPLE(STATIONARY_POINT); for an example, and DEMO(OPTMIZ); for
a longer demonstration.

&STATISTICS

See STATISTICS_SUMMARY.

&STATISTICS_SUMMARY

Macsyma has a variety of capabilities for statistical computations.


1. DESCRIPTIVE STATISTICS

   - Macsyma has several commands for means, medians and variances
     of random data samples and populations: SAMPLE_MEAN,
     SAMPLE_MEDIAN, SAMPLE_VARIANCE, POPULATION_VARIANCE and others.

   - The commands UNIVARIATE_STATISTICS and MULTIVARIATE_STATISTICS
     compute sample statistics of univariate and multivariate
     data.

   Do USAGE(STATS); for more information.

   Do DEMO(STATS); for a demonstration.


2. LEAST SQUARES FITS and REGRESSION

   - Univariate and multivariate linear and nonlinear least squares
     fits of parameterized functions to data.  The main commands
     are LSQ1, LSQ_LINEAR, LSQ_NONLINEAR.

     Do USAGE(LSQ); for more information.

     Do DEMO(LSQ); and DEMO(LSQ1); for demonstrations.

   - LSQ_LINSOLVE finds least squares solutions to systems of linear
     equations as LSQ_LINSOLVE_BY_SVD.

   - LSQ_ODE finds least squares fits of parameterized ordinary
     differential equations to data.


3. PROBABILITY DISTRIBUTIONS AND DENSITY FUNCTIONS

   - Many discrete univariate distributions.  

     Do USAGE(UNIPROB); for more information.

     Do DEMO(UNIPROB); for a demonstration. 

   - Many continuous univariate distributions.

     Do USAGE(UNIPROB); for more information.

     Do DEMO(UNIPROB); for a demonstration. 

   - Continuous multivariate density functions:
     NORMAL_MDF, STUDENTS_MDF, GEN_STUDENTS_MDF, 
     WISHART_MDF and INV_WISHART_MDF. 
  
     Do USAGE(MULTPROB); for more information.

     Do DEMO(MULTPROB); for a demonstration.

&STATS

The STATS package is a collection of elementary statistical functions.

Do USAGE(STATS); for more information.

Do DEMO(STATS); for a demonstration.

See also STATISTICS_SUMMARY.

&STATUS(keyword, arg)

Returns status information for the keyword and arg given.  Specifying
arg is either illegal, optional, or required, depending on the
keyword.

This function allows you to obtain a variety of information about
Macsyma. For example, STATUS(DAY); returns the day of the week, while
STATUS(FREECORE); tells you about Macsyma's memory usage.

Not all implementations support all possible keywords to status.  The
expression STATUS(STATUS); returns a list of the keywords that are
valid in the current implementation.  The complete list of keywords
accepted by STATUS follows.

 - TIME - The time used so far in the computation.

 - DAY - The day of the week.

 - DATE - A list of the year, month, and day.

 - DAYTIME - A list of the hour, minute, and second.

 - RUNTIME - Accumulated CPU time times the atom "MSEC" in the
   current  Macsyma.

 - REALTIME - The real time (in sec) elapsed since the user started up 
   this Macsyma.

 - GCTIME - The garbage collection time used so far in the current
   computation.

 - TOTALGCTIME - Gives the total garbage collection time used in
   Macsyma so far.

 - FREECORE - Gives information about Macsyma's memory usage.

 - FEATURE - Gives you a list of features that are currently turned
   on.  If given a second argument, a string which is the name of a
   feature, STATUS will return TRUE if the feature is currently
   turned on, and FALSE if the feature is turned off. Features can
   be turned on using SSTATUS.

 - FEATURES - Gives you a list of features that are currently turned
   on. (This is the same as using FEATURE with no arguments.)

 - SSTATUS - A list of the keywords recognized by SSTATUS in the
   current implementation.

 - STATUS - A list of keywords recognized by STATUS in the current 
   implementation.

&STIRLING(expr {, vars})

[ALGFUNCS package] Stirling's formula for z! and gamma(z), which are
approximately equal for large z.  STIRLING returns the first term of
Stirling's asymptotic series:

  z! ~ sqrt(2*%pi*z)*z^z*exp(-z)*S(z) , 

         where S(z) = 1 + 1/(12*z) + 1/(288*z^2) - 139/(51840*z^3) 
                        - 571/(2488320*z^4) + ...
               (AS p. 257 6.1.37)

  z! = gamma(z+1) = z*gamma(z) . 

Examples:

 (c1) STIRLING(Z!,Z);

 (d1)         sqrt(2)*sqrt(%pi)*%e^((z+1/2)*log(z)-z)  

 (c2) STIRLING(GAMMA(Z),Z);

 (d2)         sqrt(2)*sqrt(%pi)*%e^((z-1/2)*log(z)-z)

The results (d1) and (d2) can be converted to the form z^(z+-1/2) by
using BLOCK([RATEXPAND:TRUE],RADCAN(STIRLING(EXPR,Z))); .

STIRLING takes any expression and if called on one argument, converts
all factorials and gammas of one argument appearing in that expression
as shown above.  If given more than one argument, only such factorials
and gammas which contain any of the auxiliary arguments (variables)
are converted.

Examples:

 (c3) STIRLING(GAMMA(Z),Z);

 (d3)           sqrt(2)*sqrt(%pi)*%e^((z-1/2)*log(z)-z)

 (c4) STIRLING(GAMMA(W)*GAMMA(Z),Z);

 (d4)       sqrt(2)*sqrt(%pi)*gamma(w)*%e^((z-1/2)*log(z)-z)


Do EXAMPLE(STIRLING); for an example.

&STIRLING_S1(n,k)

The unsigned Stirling number of the first kind.

        .
         .   1                                    
          .
             3  1                                 
                                              
             1  1  1                              
                                              
     Stirling_S1(0,0)   = 1                           

                          1                       

                          1    1         (Invisible values are 0.)
                                              
      Stirling_S1(3,1) =  2    3    1             

                          6   11    6   1         
                                              
                         24   50   35   10  1     
                                              
                         120  274  225  85  15  1 

Stirling_s1(n,k) = Stirling_s2(-k,-n) .   An explicit formula is
returned in certain cases where k or n-k is an integer.  
Caution:  Abramowitz & Stegun suppose an alternating sign.

Do EXAMPLE(STIRLING_S1)$ for an example.

&STIRLING_S2(n,k)

The Stirling number of the second kind.

        .
         .    1                               
          .                                    
              3  1                            
                                          
              2  1  1                         
                                          
 Stirling_S2(0,0)   =  1                      

                          1                   
                                   
                          1  1            (Invisible values are 0.)
                                          
    Stirling_S2(3,1)   =  1  3   1            

                          1  7   6   1        
                                          
                          1  15  25  10  1    
                                          
                          1  31  90  65  15  1
                                 . . .

Stirling_s2(n,k) = Stirling_s1(-k,-n) .  An explicit formula 
is returned in certain cases where k or n-k is an integer.

Do EXAMPLE(STIRLING_S2)$ for an example.

&STOCH

The STOCH Package provides facility to define stochastic (random) 
variables and compute and simplify the expectation values of
expressions containing those variables.  The package contains
facilities 

o to define multiple mutually statistically independent systems
  of random variables,

o to use properties of Gaussian random variables in simplifying
  expected values,

o to use subscripted random variables and stochastic processes
  (stochastic functions of deterministic variables, which may be 
  subscripted),

o to pre-enter expressions defining moments of the random variables
  and apply these automatically during the simplification of
  expectation values of expressions.

Do USAGE(STOCH); for more information.

Do DEMO(STOCH); DEMO(STOCH1); and DEMO(STOCH2) for demonstrations.

&STOCH_DIFFOUT(expr)

[STOCH package] Simplifies expr, replacing expectations of products
of derivatives with respect to the arguments of stochastic functions 
(processes) by derivatives of expectation values.  Thus, for example, 
                    <<f(x(t))*'diff(g(x(t)),t)>>, 
where x(t) is a random process, becomes
            at(diff(<<f(x(t))*g(x(t_@1))>>,t_@1),[t_@1=t]). 

All differentiations with respect to arguments of stochastic 
processes are factored out of the expectation, and the 
differentiation is applied, thereby expressing the expectation 
containing derivatives in terms of expectations of the random 
functions themselves.  Derivatives with respect to other variables,
and derivatives which are not at the top level of a nounified 
expectation, are unaffected.

&STOCH_TAYLOR(<<expr>>,vars,{order})

[STOCH package] Approximates its argument, which should be a nounified
expectation value, as the expectation value of a Taylor series in
the random variables VARS expanded about their mean  values.  Gaussian 
simplification is applied, which will make the output a function of 
the means and covariances of VARS (Ito's  Lemma), if all of VARS are 
Gaussian random variables.  VARS may be one random variable, or a 
list of such variables.  The optional argument ORDER is the order of 
the expansion, as would be given to TAYLOR.  ORDER defaults to 2 if 
it is not specified.  If EXPR is a product containing, at top level,
derivatives with respect to the arguments of random functions, the 
derivations are factored out by STOCH_DIFFOUT before series expansion.
No other form of non-local functional dependency (e.g. integrals, 
formal sums, derivatives etc.) on random processes is presently 
supported.

&STOCH_USES_SUBSCRIPTED_RANVARS default:TRUE

[STOCH package] 

 - When TRUE, RANDOMIZE(x) makes x[i] into mutually dependent 
   random variables.
 - When FALSE, subscripted variables are considered distinct, and
   can be separately RANDOMIZED.

In either case, all subscripted forms of the same atomic variable 
should have the same number of subscripts, so that SET_MOMENT 
will work correctly.

 - When STOCH_USES_SUBSCRIPTED_RANVARS is TRUE,
              SET_MOMENT(x[i]*x[j]*...*x[n],FOO(i,j,...,n) 
   defines the moment "generically", that is, as an array functional
   relationship true for all values of the subscripts.  In this case, 
   all the subscripts must be distinct, so that the call to SETMOMENT
   defines the entire functional relationship.  Once this has been 
   done, a call such as  SET_MOMENT(x[1]*x[3],BAH), where all 
   subscripts are numeric, will reset that particular moment, 
   overriding the generic definition.  For example:

       SET_ZERO_MEAN(x[i]);
       SET_MOMENT(x[i]*x[j],0);
       SET_MOMENT(x[1]*x[1],sigma[1]);
       SET_MOMENT(x[2]*x[2],sigma[2]);
        .        .        . 
   defines x[i] as mutually uncorrelated random variables of variance 
   sigma[i].  A better way to do this would be:

       SET_ZERO_MEAN(x[i]);
       SET_MOMENT(x[i]*x[j],if i=j then 0 else sigma[i]);

 - When STOCH_USES_SUBSCRIPTED_RANVARS is FALSE,
               SET_MOMENT(x[a]*x[b]*...*x[n],foo)
   defines the moment only for the actual subscripts a,b,...n, where 
   x[a],x[b] etc. are considered to be the names of different random 
   variables.

&STOCH_USES_MOMENTS default:TRUE

[STOCH package] 

 - When TRUE, moments installed by SET_MOMENT are automatically used 
   during the simplification of expectation values. 

 - When FALSE, they are not used, and the noun form <<x*y*...*z>> is
   returned instead.

&STOCH_VARIANCE(expr)

[STOCH package] A convenience function which computes the variance
of a stochastic expression expr in terms of expected values. 

&STRING(expr)

Converts the expression expr to a string in the form of the input
syntax for the given expression.  If GRIND is TRUE, the resulting
string may contain line breaks making the expression more readable.

In many situations, the inverse of STRING is EVAL_STRING.

Do EXAMPLE(STRING); for an example.

See STRING_SUMMARY for related commands.

&STRING_CAPITALIZE(string)

Returns a string with only the leading character capitalized.

See STRING_SUMMARY for related commands.

&STRING_DOWNCASE(string)

Returns a string containing only lower-case characters.

See STRING_SUMMARY for related commands.

&STRING_EQUAL(string1, string2)

Predicate which returns TRUE if string1 and string2 are identical,
ignoring case.  If case is important, use "=".

See STRING_SUMMARY for related commands.

&STRING_LEFT_TRIM(string)

Removes leading characters <space>, <tab>, and <newline> from string.

See STRING_SUMMARY for related commands.

&STRING_LENGTH(exp)

Returns the number of characters in the expression exp when
represented by a string.  For example, 

 (c1) STRING_LENGTH("x+2*a")$

 (d1)                           5

See STRING_SUMMARY for related commands.

&STRING_RIGHT_TRIM(string)

Removes trailing characters <space>, <tab>, and <newline> from string.

See STRING_SUMMARY for related commands.

&STRING_SUMMARY

The main commands for manipulating strings in Macsyma are:

Command          Description
---------------  ----------------------------------

 STRING          Converts an expression to a string
 GRIND           Prints string in a more readable format
 EVAL_STRING     Evaluates a string as an expression
 CONCAT          Concatenates strings
 SUBSTRING       Extracts a substring

 GETCHAR         Get a character from a string
 GETCHARN

 CARDINAL_STRING Returns word string for a number
 ORDINAL_STRING  Returns word string for ordinal number

 STRINGP         Test whether an expression is a string
 SUBSTRINGP      Test for a specified substring of a string
 STRING_EQUAL    Test whether two strings are equal

 STRING_CAPITALIZE Controls casification of strings
 STRING_DOWNCASE
 STRING_UPCASE

 STRING_LENGTH   Returns the length of a string

 STRING_TRIM     Trims leading and trailing spaces and so forth
 STRING_TRIM_LEFT
 STRING_TRIM_RIGHT

 STRINGOUT       Write an expression to a file as a string

&STRING_TRIM(string)

Removes leading and trailing characters <space>, <tab>, and <newline>
from string.

See STRING_SUMMARY for related commands.

&STRING_UPCASE(string)

Returns a string containing only upper-case characters.

See STRING_SUMMARY for related commands.

&STRINGOUT(filename, a1, a2, ...)

Outputs expression(s) designated by the arguments a1, ...  to a file
with the specified filename in a linear format.  Such files are then
used by the BATCH or DEMO commands. The ai are usually c labels or may
be one of the following:

 - INPUT     the values of all input lines are written to the
             file. 

 - FUNCTIONS all of the user's function and macro definitions are 
             written to the file. 

 - VALUES    all the variables to which the user has assigned values 
             will be written to the file.
  
 - [m,n]     all input labels in the range m through n inclusive are
             written to the file. (m,n are positive integers.)
  
 - varname   the value of the variable named varname is to be written 
             to the file.

This function may be used to create a file of FORTRAN statements by
doing some simple editing on the strungout expressions.  If the GRIND
switch is set to TRUE, then STRINGOUT will use GRIND format instead of
STRING format.  Note: a STRINGOUT may be done while a WRITEFILE is in
progress.

See STRING_SUMMARY for related commands.

See FILES_SUMMARY for more information about file manipulation
commands in Macsyma.  See FILENAMES and FILE_PATHNAMES for
information about how to specify file pathnames in Macsyma.

&STRINGP(exp)

Returns TRUE if and only if exp is a string, else FALSE. 

Examples:

 - STRINGP('FOO)    ->   FALSE
 - STRINGP("FOO")   ->   TRUE
 - STRINGP(3)       ->   FALSE

Do EXAMPLE(STRINGP); for an example.

See STRING_SUMMARY for related commands.  See also PREDICATES.

&STRINGS

See STRING_SUMMARY.

&STUDENTS_MDF(Z, V, nu {, vdet})

The multivariate Students probability density function with zero mean
value.

Arguments:

 - Z is a vector of independent random variables of length m,
   where the elements of z are real numbers.
 - V is a positive definite symmetric matrix, related to the 
   covariance matrix sigma by V = nu/(nu-2) * sigma^^-1 .
 - nu is the number of degrees of freedom.  It can be a number
   or mathematical expression.
 - vdet is the determinant of the matrix V.  If you know vdet,
   you can specify it and save the time needed to recompute it.

When the dimension of the distribution is 1, then Z and V can
be atomic variables or expressions.

                  nu/2                       1/2
                nu     Gamma((nu+m)/2) det(V)
 STUDENTS_MDF = -------------------------------- (nu + Z^`.V.Z)
                         m/2
                       nu    Gamma(nu/2)

Do EXAMPLE(STUDENT_MDF); for an example.

See also GEN_STUDENTS_MDF, STUDENTS_T_DENSITY.

&STUDENTS_T_DENSITY(x, dof)

[UNIPROB package] The student's t probability density function

                              dof + 1
                        gamma(-------)
                                2
        -----------------------------------------------
                                               dof + 1
                                         2     -------
                                  dof   x         2
        sqrt(%pi) sqrt(dof) gamma(---) (--- + 1)
                                   2    dof

Do EXAMPLE(STUDENTS_T_DENSITY); for an example.

See also STUDENTS_T_DISTRIB, STUDENTS_MDF.

&STUDENTS_T_DISTRIB(x, dof)

[UNIPROB package] The student's t distribution.  

Do EXAMPLE(STUDENTS_T_DISTRIB); for an example.

See also STUDENTS_T_DENSITY, INV_STUDENTS_T_DISTRIB.

&SUBLIS(list, expr)

Allows multiple substitutions into an expression in parallel.

Example:

 (c1) SUBLIS([A=B,B=A],SIN(A)+COS(B));

 (d1)                      sin(b) + cos(a)

The variable SUBLIS_APPLY_LAMBDA (default:TRUE) controls
simplification after SUBLIS.

Do EXAMPLE(SUBLIS); for an example.

See also SUBST, RATSUBST.

&SUBLIS_APPLY_LAMBDA default:TRUE

Controls whether LAMBDA's substituted are applied in simplification
after SUBLIS is used or whether you have to do an EV to get things to
apply.  TRUE means do the application.

&SUBLIST(L, F)

Returns the list of elements of the list L for which the function F
returns TRUE.  For example,

 (c1) SUBLIST([1,2,3,4], EVENP);

 (d1)                       [2,4]

Do EXAMPLE(SUBLIST); for an example.

See also SUBSET, SUBLISTS.

&SUBLISTS(L, F)

Returns a list of two lists.
 - a list of the elements of the list L for which the function F
   returns TRUE.
 - a list of the elements of L for which F does not return TRUE. 

For example,  

 (c1) SUBLISTS([1,2,3,4], EVENP);

 (d1)                    [[2,4], [1,3]]

Do EXAMPLE(SUBLISTS); for an example.

See also SUBLIST, SUBSET.

&SUBMAT(mat, r, c)

[MATFUNCS package] Returns the submatrix of matrix M consisting of
rows whose indices are specified in the list `r', and whose columns
are specified in the list `c'. Do LOAD(MATFUNCS); to access this
function.

&SUBMATRIX(m1, ..., M, n1, ...)

Creates a new matrix composed of the matrix M with rows mi deleted,
and columns ni deleted.

Do EXAMPLE(SUBMATRIX); for an example.

&SUBPOWERSET(given_set, k)

Returns a list of all subsets of the set given_set which have exactly
k elements. Given_set must be a list with distinct elements, and k
must be a non-negative integer.

Do EXAMPLE(SUBPOWERSET); for an example.

See also SET, POWERSET.

&SUBSCRMAP

This option variable is obsolete.

&SUBSET(A, F)

Returns the set of elements of A which satisfy the condition F.  
The argument F should be a function of one argument that returns 
TRUE or FALSE.  For example,

 (c1) SUBSET([1,2,X,X+Y,Z,X+Y+Z], ATOM);

 (d1)                           [1, 2, z]

 (c2) SUBSET([1,2,7,8,9,14], EVENP);

 (d2)                          [2, 8, 14]

Do EXAMPLE(SUBSET); for an example.

See also SUBSETP and SUBLIST.  Do DESCRIBE(SET); and USAGE(SET); for 
more information about operations on sets in Macsyma.

&SUBSETP(a, b)

Decides whether or not a is a subset of b and returns TRUE or FALSE
accordingly.

See also SET, PREDICATES.

&SUBST(a, b, c)
 or
SUBST(eq1, exp)
 or 
SUBST([eq1,...,eqk], exp)

Substitutes a for b in c.  b must be an atom, or a complete
subexpression of c.  For example, X+Y+Z is a complete subexpression of
2*(X+Y+Z)/W while X+Y is not.  

When b does not have these characteristics, one may sometimes
accomplish the substitution using SUBSTPART or RATSUBST.

Alternatively, if b is of the form e/f then one could use
SUBST(a*f,e,c) while if b is of the form e^(1/f) then one could use
SUBST(a^f,e,c).  The SUBST command also discerns the X^Y in X^-Y so
that SUBST(A,SQRT(X),1/SQRT(X)) returns 1/A.

a and b may also be operators of an expression enclosed in "s or they
may be function names.  If one wishes to substitute for the
independent variable in derivative forms then the AT function should
be used.  

Note:  SUBST is an alias for SUBSTITUTE.

SUBST(eq1, exp) and SUBST([eq1,...,eqk],exp)
  are other permissible forms.  The eqi are equations indicating
  substitutions to be made.  For each equation, the right side will be
  substituted for the left in the expression exp.

EXPTSUBST default:FALSE
  If TRUE, permits substitutions like Y for %E^X in %E^(A*X) to take
  place.

OPSUBST default:TRUE
  If FALSE, SUBST will not attempt to substitute into the operator of
  an expression.  For example, (OPSUBST:FALSE, SUBST(X^2,R,R+R[0]));
  will substitute x^2 for the scalar R but not for the array name R.

Examples:

 (c1) SUBST(A, X+Y, X+(X+Y)^2+Y);
                                  2
 (d1)                    y + x + a

 (c2) SUBST(-%I, %I, A+B*%I);
 (d2)                             a - %i b

(Note that (c2) is one way of obtaining the complex conjugate of an
analytic expression.)

Do EXAMPLE(SUBST); for an example.

See also SUBLIS, RATSUBST, SUBSTPART.

&SUBSTINPART(x, exp, n1, ...)

Acts like SUBSTPART but works on the internal representation of exp.

 (c1) X . 'DIFF(F(X),X,2);
                                    2
                                   d
 (d1)                         x . (--- f(x))
                                     2
                                   dx

 (c2) SUBSTINPART(D^2,%,2);
                                       2
 (d2)                             x . d

 (c3) SUBSTINPART(F1,F[1](X+1),0);

 (d3)                            f1(x + 1)

              Additional Information

If the last argument to a part function is a list of indices then
several subexpressions are picked out, each one corresponding to an
index of the list.  Thus PART(X+Y+Z,[1,3]) is Z+X.

PIECE
  Holds the value of the last expression selected when using the
  part functions. 

PARTSWITCH default:FALSE
  If set to TRUE, then END is returned when a selected part of an
  expression doesn't exist, otherwise an error message is given.

Examples:

 (c1)  27*Y^3+54*X*Y^2+36*X^2*Y+Y+8*X^3+X+1;

             3         2       2            3
 (d1)    27 y  + 54 x y  + 36 x  y + y + 8 x  + x + 1

 (c2)  PART(D1,2,[1,3]);

                   2
 (d2)          54 y

 (c3)  SQRT(PIECE/54);

 (d3)            y

 (c4)  SUBSTPART(FACTOR(PIECE),D1,[1,2,3,5]);

                           3
 (d4)           (3 y + 2 x) + y + x + 1

 (c5) 1/X+Y/X-1/Z;
                                  1   y   1
 (d5)                           - - + - + -     ;
                                  z   x   x

 (c6) SUBSTPART(XTHRU(PIECE),%,[2,3]);

                                 y + 1   1
 (d6)                            ----- - -
                                   x     z

Also, setting the option INFLAG to TRUE and calling PART/SUBSTPART is
the same as calling INPART/SUBSTINPART.

Do EXAMPLE(SUBSTINPART); for an example.

See also SUBST, SUBLIS, SUBSTPART, RATSUBST.

&SUBSTPART(x, exp, n1, ..., nk)

Substitutes x for the subexpression picked out by the rest of the
arguments as in PART.  It returns the new value of exp.  x may be some
operator to be substituted for an operator of exp.  In some cases it
needs to be enclosed in double quotation marks (for example,
SUBSTPART("+",A*B,0); -> B + A ).

Examples:

 (c1) 1/(X^2+2);
                                     1
 (d1)                              ------
                                    2
                                   x  + 2

 (c2) SUBSTPART(3/2,%,2,1,2);
                                     1
 (d2)                             --------
                                   3/2
                                  x    + 2

 (c3) A*X+F(B,Y);
 (d3)                          a x + f(b, y)

 (c4) SUBSTPART("+",%,1,0);
 (d4)                         x + f(b, y) + a


Also, setting the option INFLAG to TRUE and calling PART/SUBSTPART is
the same as calling INPART/SUBSTINPART.

Do EXAMPLE(SUBSTPART); for an example.

See also SUBST, SUBLIS, SUBSTINPART, RATSUBST.

&SUBSTRING(string1, start {, end})

Extracts a substring from the string string1.  The extent of the
substring is determined by the argument start and the optional
argument end.  If end is not specified then the length of string1 is
used.  If either start or end is non-positive then it is indexed
backwards from the end.

See STRING_SUMMARY for related commands.

&SUBSTRINGP(substring1, string1)

If substring1 is a substring of string1, then returns TRUE, else
returns FALSE.

See STRING_SUMMARY for related commands.  See also PREDICATES.

&SUBVARP(exp)

If the expression exp is a subscripted variable (for example A[I]),
then returns TRUE, else returns FALSE.

See also PREDICATES.

&SUM(exp, ind, lo, hi)

Performs a summation of the values of exp as the index ind varies from
lo to hi.  If the upper and lower limits differ by an integer then
each term in the sum is evaluated and added together.  Otherwise, if
the SIMPSUM (default:FALSE) is TRUE the result is simplified.  This
simplification may sometimes be able to produce a closed form.  If
SIMPSUM is FALSE or if 'SUM is used, the value is a SUM noun form
which is a representation of the sigma notation used in mathematics.

If hi is one less than lo, we have an "empty sum" and SUM returns 0 
rather than erring out.

Sums may be differentiated, added, subtracted, or multiplied with some
automatic simplification being performed.

SUM evaluates its first argument only once like almost every other
Macsyma command.  This implies that things like F(X):=SUM(X,I,1,3)$
F(-X); (Answer: -3*X) and SUM(T[I],I,1,3); (Answer: retrieve and sum
up T[1],T[2],T[3] without reevaluating the elements) will work
correctly whereas I^2; SUM(%,I,1,3); (Answer: 3*I^2) will not (if the
desired answer is 14).  To do the latter one will have to type
SUM(EV(%),I,1,3); or SUM(''%,I,1,3); .  (PRODUCT and ROMBERG behave
similarly.)

CAUCHYSUM default:FALSE
  When TRUE, causes the Cauchy product to be used when multiplying
  sums together rather than the usual product.  In the Cauchy product
  the index of the inner summation is a function of the index of the
  outer one rather than varying independently.

GENINDEX default:I
  Is the alphabetic prefix used to generate the next variable of
  summation.

GENSUMNUM default:0
  Is the numeric suffix used to generate the next variable of
  summation.  If it is set to FALSE then the index will consist only
  of GENINDEX with no numeric suffix.

Do EXAMPLE(SUM); for examples.  

See also NUSUM, SIMPSUM, SUMEXPAND, SUMHACK, INTOSUM, SUMCONTRACT,
BASHINDICES, NICEINDICES.

&SUM_UP(summand, index, lo, hi)

[ALGFUNCS package] Explicitly evaluate the summation indicated with
finite limits by calling SUM.

&SUMCONTRACT(expr)

Combines all sums of an addition that have upper and lower bounds that
differ by constants.  The result will be an expression containing one
summation for each set of such summations added to all appropriate
extra terms that had to be extracted to form this sum.  SUMCONTRACT
will combine all compatible sums and use one of the indices from one
of the sums if it can, and then try to form a reasonable index if it
cannot use any supplied.  It may be necessary to do an INTOSUM(expr)
before the SUMCONTRACT.

Do EXAMPLE(SUMCONTRACT); for an example

See also SUM, NUSUM, SIMPSUM, SUMEXPAND, LINEARDISTRIB, SUMHACK, 
INTOSUM, BASHINDICES and NICEINDICES.

&SUMEXPAND(expr)

[ALGFUNCS package] Expand summations whose summands are themselves
sums.  For example,

 (c1) SUMEXPAND(SUM(A[i]+B[i],i,1,N));

 (d1)              sum(a[i],i,1,n))  + sum(b[i],i,1,n))


SUMEXPAND default:FALSE
  If TRUE, products of sums and exponentiated sums are converted into
  nested sums.  

Example:

 (c1) SUMEXPAND:TRUE$

 (c2) SUM(F(I),I,0,M)*SUM(G(J),J,0,N);

 (d2)           'sum('sum(f(i1)*g(i2),i2,0,n),i1,0,m)

 (c3) SUM(F(I),I,0,M)^2;

 (d3)           'sum('sum(f(i3)*f(i4),i4,0,m),i3,0,m)

If FALSE, the sums are left as they are.

Do EXAMPLE(SUMEXPAND); for an example.

See also SUM, NUSUM, CAUCHYSUM, LINEARDISTRIB, SUMCONTRACT, SUMHACK, 
INTOSUM, BASHINDICES and NICEINDICES.

&SUMHACK default:FALSE

If set to TRUE, then SUM(F(I),I,3,1); will yield -F(2), by the
identity SUM(F(I),I,A,B) = - SUM(F(I),I,B+1,A-1) when A>B.

See also SUM, NUSUM.

&SUMSPLITFACT default:TRUE

If set to FALSE, causes MINFACTORIAL to be applied after a FACTCOMB.

&SUPCONTEXT(newcontext, oldcontext)

Creates a new context (called newcontext) which is a supercontext of
oldcontext.  If oldcontext is not specified, the current context (the
value of CONTEXT) will be assumed.  If oldcontext is specified, it
must already exist as a context.

See CONTEXT for a general description of the context mechanism.

&SURFACE_NORMAL(surf, list_of_vars)

[CURVSURF package] Returns a normal vector field to the 2-surface
specified by surf which is embedded in 3-space.  The surface can
be specified as

- a function z=f(x,y), in which case the call to SURFACE_NORMAL
  is of the form SURFACE_NORMAL(f(x,y), [x,y]);

or

- a parametric surface [x(s,t), y(s,t), z(s,t)] in which case
  the call to SURFACE_NORMAL is of the form
  SURFACE_NORMAL([x(s,t),y(s,t),z(s,t)], [s,t]); .

or

- an implicit surface f(x,y,z)=constant, in which case the call
  to SURFACE_NORMAL is of the form 
  SURFACE_NORMAL(f(x,y,z), [x,y,z]); .

Do EXAMPLE(SURFACE_NORMAL); for an example.

See also UNIT_SURFACE_NORMAL and CURVSURF.

&SVD(A)

Computes the singular value decomposition of the matrix A and returns
a list of the singular values of A.  

SVD(A, 'SVD_MATRICES) returns a list of the form [s, U, V], where s is
the list of the singular values of A, and U and V are matrices that
satisfy A = U S V^* with S being the diagonal matrix corresponding to
s.  If A is m x n, then V will be unitary and n x n.  However, due to
differences in the algorithms employed, for floating point matrices U
will be column orthogonal and m x n and S will be n x n, while for
exact matrices, U will be unitary and m x m and S will be m x n. 

Do DEMO(SVD); for a demonstration.

For complex floating point matrices, do USAGE(NUMKIT);

See also SVD_NUMERICAL, MAT_SVD.

&SVD_NUMERICAL(A)

Computes the singular value decomposition of the matrix A numerically.
SVD_NUMERICAL(A); returns a list of the form [s, U, V], where s is the
list of the singular values of A, and U and V are matrices that
satisfy A = U S V^* with S being the diagonal matrix.  The matrix A
cannot contain symbolic entries or BFLOAT numbers.

Do EXAMPLE(SVD_NUMERICAL); for an example.

For complex floating point matrices, do USAGE(NUMKIT);

See also SVD, MAT_SVD.

&SVD_NUMERICAL_REAL(A)

Form of SVD_NUMERICAL that works with real matrices only.

See SVD_NUMERICAL.

&SVD_SYMB

Returns the singular value decomposition of its first argument.

SVD_SYMB uses algorithms for exact eigenvalue calculations. It
may not be reliable for matrices larger than 4 X 4. For numerical
SVD calculations, see SVD_NUMERICAL or SVD.

SVD_SYMB has several calling syntaxes.


SVD_SYMB(A)
  Returns a vector of the singular values of A in sorted order.

[U, S, V] <: SVD_SYMB(Mat_or {, 0 {, predicate_function}}) 
  Returns and assigns three matrices [U, S, V] with S a diagonal
  matrix of the same size as A with real, nonnegative diagonal
  elements, and  unitary matrices U and V such that
  A = U . S . V^*  .

  The elements of the diagonal matrix S are sorted even though
  they may be symbolic.  Notice they may not remain ordered after
  elements are evaluated. The default ordering is given by the
  standard internal ordering equivalent to ORDERLESSP, unless the
  last argument of SVD_SYMB is another ordering predicate function
  of two variables. 

[U, S, V] <: SVD_SYMB(A, 0)
  Returns an "economy size" decomposition of A. If A has fewer
  columns, say n, than rows, then the returned matrix U has only n
  columns and S is nxn.  Nevertheless, A = U . S . V^* .

Do EXAMPLE(SVD_SYMB); for an example.

See also SVD, SVD_NUMERICAL, SVD_NUMERICAL_REAL.

&SWAP_COLS(mat,i,j)

[MATFUNCS package] - swaps columns i and j in the matrix mat.
If i (or j) is negative then the ith (resp. jth) row is multiplied
by -1 before it  is moved to the jth (resp. ith) position.

Do EXAMPLE(SWAP_COLS); for an example.

See also SWAP_ROWS.

&SWAP_ROWS(mat,i,j) 

[MATFUNCS package] - swaps rows i and j in the matrix mat.
If i (or j) is negative then the ith (resp. jth) row is multiplied
by -1 before it is moved to the jth (resp. ith) position.

Do EXAMPLE(SWAP_ROWS); for an example.

See also SWAP_COLS.

&SYMBOLP(exp)

Returns TRUE if "exp" is a symbol, else FALSE.  For example,

 - SYMBOLP('FOO)  -> TRUE
 - SYMBOLP("FOO") -> FALSE
 - SYMBOLP(23)    -> FALSE.

See also PREDICATES.

Do EXAMPLE(SYMBOLP); for an example.

See also ATOM, MAPATOM.

&SYMMDIFFERENCE(a, b)

Returns the symmetric difference of a and b, which is equal to
UNION(SETDIFFERENCE(A,B),SETDIFFERENCE(B,A)).

Do EXAMPLE(SYMMDIFFERENCE); for an example.

See also SET.

&SYMMETRIC

If DECLARE(H,SYMMETRIC); is done, this tells the simplifier that H is
a symmetric function.  E.g. H(X,Z,Y) will simplify to H(X, Y, Z).
This is the same as COMMUTATIVE.  SYMMETRIC is a member of the
FEATURES list and OPPROPERTIES.  It can be asserted with DECLARE,
withdrawn with REMOVE, and detected with FEATUREP.

Do EXAMPLE(SYMMETRIC); for an example.

&SYMMETRIES

Obsolete. See ISYMMETRIES.

&SYMPLECTIC

For symplectic matrices, see SYMPLECTIC_MATRIX.

For symplectic algebras, see the ATENSOR package.  

&SYMPLECTIC_MATRIX(dim {, a1, ..., ak})

[MATFUNCS package] Returns the normal form dim-by-dim symplectic 
matrix with entries a1, ..., ak. If no ak are not given, they are 
assumed to be equal to 1. If not all ak are given, the last element
is repeated.

Do EXAMPLE(SYMPLECTIC_MATRIX); for an example.

&SYNTACTIC_GCD(expr1 {, expr2, ..., exprn})

Returns the syntactic GCD of several expressions, i.e. the GCD of 
what is explicit syntactically in the expressions.

 (c1) SYNTACTIC_GCD(A*B/C,1/C);
                                        1
 (d1)                                   -
                                        c

 (c2) SYNTACTIC_GCD(A*B^2/C,A*B/C);
                                       a b
 (d2)                                  ---
                                        c

See also UNDISTRIB.


&T_PAIR_TEST(DATA1,DATA2)

Computes Student's t statistic for two samples numerically with the
assumption that the two samples can be paired. The lists data1 and data2
contain the sample data, and must be of equal length. T_PAIR_TEST also
computes the probability that t has the value computed.

Do EXAMPLE(T_TEST); for an example

See also T_UNEQUAL_VARIANCE_TEST and T_TEST.

See also STUDENTS_T_DISTRIB, STUDENTS_T_DENSITY, INV_STUDENTS_T_DISTRIB.

&T_TEST(DATA1,DATA2)

Computes Student's t statistic for two samples numerically. The lists data1
and data2 contain the sample data, and can be of unequal length. T_TEST
also computes the probability that t has the value computed.

Do EXAMPLE(T_TEST); for an example

See also T_UNEQUAL_VARIANCE_TEST and T_PAIR_TEST.

See also STUDENTS_T_DISTRIB, STUDENTS_T_DENSITY, INV_STUDENTS_T_DISTRIB.

&T_UNEQUAL_VARIANCE_TEST(DATA1,DATA2)

Computes Student's t statistic for two samples numerically with the
assumption that the variances of each population are unequal. The lists
data1 and data2 contain the sample data, and can be of unequal length.
T_UNEQUAL_VARIANCE_TEST also computes the probability that t has the value
computed.

Do EXAMPLE(T_TEST); for an example

See also T_TEST and T_PAIR_TEST.

See also STUDENTS_T_DISTRIB, STUDENTS_T_DENSITY, INV_STUDENTS_T_DISTRIB.

&TABLE_HUNT(X, XA, N {, J1})

[INTERPOL package] Given a monotonic 1-dimensional floating point
array XA of length N, (having indices from 0 through N-1) and given a
real number X, this function returns the integer J such that XA[J] and
XA[J+1] bracket the value X.  If the value of X lies beyond either end
of the monotonic table, then TABLE_HUNT returns -1 or N.

You can save execution time if you can specify a reasonably accurate
guess J1 which is near the answer J.  Specifying J1 is optional. 

Do EXAMPLE(TABLE_HUNT); for an example.

See also TABLE_LOCATE, TABLE_LOOKUP.

&TABLE_LOCATE(X, XA, N {, J1, J2})

[INTERPOL package] Given a monotonic 1-dimensional floating point
array XA of length N, (having indices from 0 through N-1) and given a
real number X, this function returns the integer J such that XA[J] and
XA[J+1] bracket the value X.  If the value of X lies beyond either end
of the monotonic table, then TABLE_LOCATE returns -1 or N.

You can save execution time if you can specify integers J1 and J2
such that XA[J1] and XA[J2] bracket the value X.  You may also specify
only J1, so that XA[J1] and XA[N-1] bracket the value X.  Specifying
J1 and J2 is optional.  If you can approximate the answer J but you
cannot bracket it with certainty, then use TABLE_HUNT.

Do EXAMPLE(TABLE_LOCATE); for an example.

See also TABLE_HUNT, TABLE_LOOKUP.

&TABLE_LOOKUP(X, XA, YA, N {, NI})

[INTERPOL package] Given N pairs of N floating point numbers
(XA[I],YA[I]), and given a floating point number X, interpolate a
value Y(X). The array XA must be monotonic.  NI controls the number of
coefficients in the interpolation functions.  If NI is not specified,
it defaults to the value of INTERPOL_DEFAULT_NUM (default:3).

After calling TABLE_LOOKUP, the variable JTABLE contains the
integer index of the nearest lower table entry below X.

Note that TABLE_LOOKUP performs a piecewise polynomial fit using only
a few data points news the value X, while POLY_INTERPOLATE,
RAT_INTERPOLATE and SPLINE_INTERPOLATE use all the data points in
the input arrays.

Do EXAMPLE(TABLE_LOOKUP); for an example.

See also TABLE_INTERPOLATE, TABLE_LOOKUP2.

&TABLE_LOOKUP2(X1, X2, X1A, X2A, YA, N1, N2 {, NI})

[INTERPOL package] Given a table of N1 x N2 triples of floating point
numbers (X1A[I],X2A[J],YA[I,J]), and given a pair of floating point
numbers (X1, X2), interpolate a value Y(X1,X2). The arrays X1A and X2A
must be monotonic.

NI1 and NI2 control the number of coefficients in the interpolation
polynomials in the X1 and X2 directions:  interpolate with polynomials
with NI1 and NI2 free coefficients in directions X1 and X2. If NI1 and
NI2 are not specified, they default to the value of
INTERPOL_DEFAULT_NUM (default:3).
  
After calling TABLE_LOOKUP2, the variables JTABLE1 and JTABLE2 contain
the integer index of the nearest lower table entry below X and Y
respectively. 

Example:

 (c1) FOR I:0 THRU 10 DO A[I]:2*I;
 (d1)                                done

 (c2) FOR I:0 THRU 10 DO B[I]:2*I;
 (d2)                                done

 (c3) FOR I:0 THRU 10 DO (FOR J:0 THRU 10 DO Y[I,J]:10-I);
 (d3)                                done 

 (c4) TABLE_LOOKUP2(5,5,A,B,Y,11,11);
 (d4)                                15/2

 (c5) JTABLE1;
 (d5)                                 2

 (c6) JTABLE2;
 (d6)                                 2

 (c7) Y[JTABLE1,JTABLE2];
 (d7)                                 8
   

Note that TABLE_LOOKUP2 performs a piecewise polynomial fit using only
a few data points near the point (X1,X2), whereas POLY_INTERPOLATE2
uses all the data points in the input arrays.

Do EXAMPLE(TABLE_LOOKUP2); for an example.

See also TABLE_INTERPOLATE2, TABLE_LOOKUP.

&TAN

Tangent

&TAND

Same as the TAN function, except the input argument is in degrees.

&TANH

Hyperbolic Tangent

&TAUT_CONSEQUENCEP(vars, props {, p})

[MLTLOGIC package] Determines whether the second proposition in the
list props is a tautological consequence of the first proposition in
props.

Inputs:
- vars is a list of propositional variables
- props is a list of 2 propositions (constructed with the 
  propositional variables in vars)
- p is the number of truth-values of the Logic (a prime number).
  p is optional and defaults to 2 for Boolean logic.

Output:
- Returns TRUE or FALSE depending on whether the second 
  proposition in props is a tautological consequence of the 
  first proposition in props.

The MLTLOGIC package sets the option variable PREDERROR:TRUE.

Do EXAMPLE(TAUT_CONSEQUENCEP); for an executable example.

See also PREDERROR, BOOLSIMP, LOGIC_TABLE and TAUTOLOGYP.

&TAUTOLOGYP(vars, prop {, p})

[MLTLOGIC package] Determines whether the proposition prop is a
tautology in the logical variables in the list vars.

Inputs:
- vars is a list of propositional variables
- prop is a proposition (constructed with the propositional 
  variables in vars)
- p is the number of truth-values of the Logic (a prime number).
  p is optional and defaults to 2 for Boolean logic.

Output:
- Returns TRUE or FALSE, depending on whether the proposition 
  prop is a tautology.

The MLTLOGIC package sets the option variable PREDERROR:TRUE.

Do EXAMPLE(TAUTOLOGYP); for an executable example.

See also PREDERROR, BOOLSIMP, LOGIC_TABLE and TAUT_CONSEQUENCEP.

&TAYLOR(exp, var, pt, ord)
 or
TAYLOR(exp, [var1,pt1,ord1], [var2,pt2,ord2],...)
 or
TAYLOR(exp, [var1, var2, ...], pt, ord)
 or
TAYLOR(exp, [x,pt,ord,ASYMP])

Expands the expression exp in a truncated Taylor series (or Laurent
series, if required) in the variable var around the point pt.  The
terms through (var-pt)^ord are generated.  If exp is of the form
f(var)/g(var) and g(var) has no terms up to degree ord then TAYLOR
will try to expand g(var) up to degree 2*ord.  If there are still no
non-zero terms TAYLOR will keep doubling the degree of the expansion
of g(var) until reaching ord*2^n where n is the value of the variable
TAYLORDEPTH default:3).  If MAXTAYORDER (default:TRUE) is set to TRUE,
then during algebraic manipulation of (truncated) Taylor series,
TAYLOR will try to retain as many terms as are certain to be correct.

TAYLOR(exp, [var1,pt1,ord1], [var2,pt2,ord2], ...)
  Returns a truncated power series in the variables vari about the
  points pti, truncated at ordi.

TAYLOR(exp, [var1, var2, ...], pt, ord)
  where each of pt and ord may be replaced by a list which will
  correspond to the list of variables.  That is, the nth items on each
  of the lists will be associated together.

TAYLOR(exp, [x,pt,ord,ASYMP])
  Returns an expansion of exp in negative powers of (x-pt).  The
  highest order term will be (x-pt)^(-ord).  The ASYMP is a syntactic
  device and not to be assigned to.

PSEXPAND default:FALSE
  If TRUE, will cause extended rational function expressions to
  display fully expanded.  (RATEXPAND will also cause this.) If FALSE,
  multivariate expressions will be displayed just as in the rational
  function package.  If PSEXPAND:MULTI, then terms with the same total
  degree in the variables are grouped together.

Do EXAMPLE(TAYLOR); for an example, and DEMO(TAYLOR); for a longer 
demonstration.

See also:
  POWERSERIES   (find infinite series expansion of an expression)
  TAYLOR_REVERT (find Taylor series of the inverse function)
  TAYLOR_ODE    (find Taylor series solution to system of ODE's) 
  TAYLOR_SOLVE  (find Taylor series solution to an equation)
  DEFTAYLOR     (assign a Taylor series of a function)
and
  TAYLORDEPTH, TAYLORINFO, TAYLORP, TAYLOR_LOGEXPAND,
  TAYLOR_ORDER_COEFFICIENTS, TAYLOR_SIMPLIFIER, 
  TAYLOR_TRUNCATE_POLYNOMIALS, TAYLOR_ZERO_WARN.

&TAYLOR_LOGEXPAND default:FALSE

Controls expansions of logarithms in TAYLOR series.  When TRUE all
logs are expanded fully so that zero-recognition problems involving
logarithmic identities do not disturb the expansion process.  However,
this scheme is not always mathematically correct since it ignores
branch information.  If TAYLOR_LOGEXPAND is set to FALSE, then the
only expansion of logs that will occur is that necessary to obtain a
formal power series.

See also LOGEXPAND.

&TAYLOR_ODE(eqs, dep_vars, indep_var, order, ic_list)

Generates TAYLOR series solutions for (single or systems of) ordinary
differential equation initial value problems.

Do USAGE(TAY_ODE); for more information.

Do EXAMPLE(TAYLOR_ODE); for a short example, and DEMO(TAY_ODE); for a
longer demonstration.

See also TAYLOR.

&TAYLOR_ORDER_COEFFICIENTS default:TRUE

Controls the ordering of coefficients in the expression.  The default
(TRUE) is that coefficients of TAYLOR series will be ordered
canonically.

&TAYLOR_REVERT(given-series {, var, hipower})

Finds TAYLOR series representations of the inverse function F_INV,
given the TAYLOR series of the function F(X).

Do USAGE(REVERT); for more information.

Do EXAMPLE(TAYLOR_REVERT); for an example, and DEMO(REVERT); for a 
longer demonstration.

See also TAYLOR.

&TAYLOR_SIMPLIFIER default:SIMPLIFY

Determines the simplification function that TAYLOR uses to simplify
coefficients of power series.  Its value is the name of a
simplification function of one argument.

&TAYLOR_SOLVE(eqn, dependent_var, independent_var, point, truncation)

Attempts to compute a series solution Y:dependent_var to E(Y,X):eqn by
employing the classical Newton-Puiseaux algorithm combined with the
method of undetermined coefficients.  The solution Y will be a CRE
series at P:point in V:independent_var truncated to order
T:truncation.  E(Y,X) may be any equation analytic in the sense that
TAYLOR is able to compute its series expansion at P. 

Differential equations and multivariate systems of equations are not
currently handled, but the algorithm will be extended for these cases
in the future.

Do USAGE(TAYSOLVE); for more information.

Do EXAMPLE(TAYLOR_SOLVE); for an example, and DEMO(TAYSOLVE) for a
longer demonstration.

See also TAYLOR, SOLVE, LINSOLVE, NROOTS, NTHROOT, ALLROOTS, REALROOTS,
RATCOEF.

&TAYLOR_SOLVE_CHOOSE_COEF default:TRUE

Controls whether the user will be queried by TAYLOR_SOLVE to determine
which solution to use when the coefficient equation can be solved in
closed-form by SOLVE.

Do USAGE(TAYSOLVE); for more information.

&TAYLOR_TRUNCATE_POLYNOMIALS default:TRUE

When FALSE polynomials input to TAYLOR are considered to have infinite
precision; otherwise (the default) they are truncated based upon the
input truncation levels.

&TAYLOR_ZERO_WARN default:TRUE

Controls the warnings TAYLOR issues when it assumes an expression to
be zero.  If it is reset to FALSE, TAYLOR doesn't warn at all.

&TAYLORDEPTH default:3

Controls the behavior of TAYLOR when it is asked to expand an
expression to order less than the order of the first nontrivial term.
Let var be the expansion variable and ord be the required order of
the expansion. If the expression is of the form f(var)/g(var) and
g(var) has no terms up to degree ord, then TAYLOR tries to expand
g(var) up to degree 2*ord.  If there are still no nonzero terms,
TAYLOR keeps doubling the degree of the expansion of g(var) until
reaching ord*2^taylordepth.

&TAYLORINFO(exp)

Returns FALSE if exp is not a TAYLOR series.  Otherwise, a list of
lists is returned describing the particulars of the Taylor expansion.
For example,

 (c1) TAYLOR((1-Y^2)/(1-X),X,0,3,[Y,A,INF]);
              2                        2
 (d1)/R/ 1 - a  - 2 a (y - a) - (y - a)
 
                     2                        2
             + (1 - a  - 2 a (y - a) - (y - a) ) x

          2                        2   2
  + (1 - a  - 2 a (y - a) - (y - a) ) x

                     2                        2   3
             + (1 - a  - 2 a (y - a) - (y - a) ) x

      + . . .

 (c2) TAYLORINFO(D1);
 (d2)                       [[y, a, inf], [x, 0, 3]]

&TAYLORP(exp)

Returns TRUE if and only if the expression 'exp' is in Taylor series
representation.

See also PREDICATES.

&TAYTORAT(exp)

Converts exp from TAYLOR form to CRE form, i.e. it is like
RAT(RATDISREP(exp)) although much faster.

Do EXAMPLE(TAYTORAT); for an example.

&TELLRAT(poly)

Adds to the ring of algebraic integers known to Macsyma, the element
which is the solution of the polynomial with integer coefficients.
Macsyma initially knows about %I and all roots of integers.
TELLRAT(X); means substitute 0 for X in rational functions. 

When TELLRATing a multivariate polynomial, e.g.  TELLRAT(X^2-Y^2);,
there would be an ambiguity as to whether to substitute Y^2 for X^2 or
vice versa.  The system will pick a particular ordering, but if the
user wants to specify which, e.g.  TELLRAT(Y^2=X^2); provides a syntax
which says replace Y^2 by X^2.  TELLRAT and UNTELLRAT both can take
any number of arguments, and TELLRAT(); returns a list of the current
substitutions.  Note: When you TELLRAT reducible polynomials, you want
to be careful not to attempt to rationalize a denominator with a zero
divisor.

- To detect a TELLRAT property for the variable X, do PROPERTIES(X); . 
- To display the TELLRAT property of X, do GETPROP(X, TELLRAT); .
- To remove the TELLRAT properties of X, do UNTELLRAT(X); .

ALGEBRAIC default:FALSE
  Must be set to TRUE in order for the simplification of algebraic
  integers to take effect.

Example:

 (c1) TELLRAT(W^3-1);
                                      3
 (d1)                               [w  - 1]

 (c2) ALGEBRAIC:TRUE;
 (d2)                                 true

 (c3) RAT(1/(W^2-W));
                                       1
 (d3) /R/                            ------
                                      2
                                     w  - w

 (c4) RATALGDENOM;
 (d4)                                 true
  

Do EXAMPLE(TELLRAT); for an example.

See also ALGEBRAIC.

&TELLSIMP(pattern, replacement {, condition})

Is similar to TELLSIMPAFTER, except that the transformation rule is
applied before the built-in simplification rules.  The pattern may not
be a sum, product, single variable, or number.

When to use TELLSIMP and TELLSIMPAFTER:
 - Use TELLSIMP when it is important to modify the expression before
   the simplifier works on it.  For example, if the simplifier "knows"
   something about the expression, but what it returns is not to your
   liking then use TELLSIMP.  
 - If the simplifier "knows" something about the main operator of the
   expression, but is simply not doing enough for you, you probably
   want to use TELLSIMPAFTER.  

RULES is a list of names having simplification rules added to them by
DEFRULE, DEFMATCH, TELLSIMP, or TELLSIMPAFTER.

The Macsyma simplifier allows recursive application of rules. To avoid
infinite recursion induced by a rule returning its input, TELLSIMP and
TELLSIMPAFTER allow an optional argument condition which indicates the
conditions necessary for the rule to be applied.  More precisely, the
rule will be applied only if IS(condition) evaluates to TRUE. Such
evaluation will not occur until all the pattern variables upon which a
condition depends have been bound as matched.

Do EXAMPLE(TELLSIMP); for an example.

See also TELLSIMPAFTER.  See RULES_SUMMARY for an overview of
rule-based pattern matching capabilities in Macsyma.

&TELLSIMPAFTER(pattern, replacement {, condition})

Defines a replacement for pattern which the Macsyma simplifier uses
after it applies the built-in simplification rules.  The pattern may
be anything but a single variable or a number.

The Macsyma simplifier has been modified to allow recursive application
of rules. To avoid infinite recursion induced by a rule returning its
input, TELLSIMP and TELLSIMPAFTER allow an optional argument condition
which indicates the conditions necessary for the rule to be applied. 
More precisely, the rule will be applied only if IS(condition) evaluates
to TRUE. Such evaluation will not occur until all the pattern
variables upon which a condition depends have been bound as matched.

Do EXAMPLE(TELLSIMPAFTER); for an example.

See also TELLSIMP.  See RULES_SUMMARY for an overview of rule-based
pattern matching capabilities in Macsyma.

&TEMP_CONVERT(x, y)

[UNITS package] converts the dimensionful quantity x which explicitly 
involves temperature to the temperature described by y.

In case of 0 degrees, (e.g.  0*'celsius_degree), you can specify x with a
list as [0,'deg_c]. In case of ambiguity with 0 degrees, TEMP_CONVERT will
return an answer using list notation.

Temperatures can be 'celsius_degree, 'fahrenheit_degree, 'kelvin or
'rankine as well as  'deg_c, 'deg_f, 'deg_k or 'deg_r.

Do DEMO(UNITS3); for a demonstration of temperature conversion.

See also UNIT_CONVERT.

&TENSOR

See TENSOR_SUMMARY.

&TENSOR_SUMMARY

Tensor analysis, with Riemannian (and more general affine)
connections, is the "absolute differential calculus" which is valid in
all coordinate systems on differentiable manifolds.  It is often the
most powerful way to state and solve problems in many branches of
continuum mechanics, including solid mechanics, fluid mechanics,
electrodynamics, and general relativity.

Macsyma has five main (vector and) tensor packages:
  ITENSOR package for indicial tensor computations
  CTENSOR package for component tensor computations
  ATENSOR package for tensor algebras, including Clifford algebras
  CARTAN  package for exterior calculus of differential forms
  VECT    package for vector calculus.

For a demonstration of CTENSOR, ITENSOR and other packages working
together to automate tensor calculus, do DEMO(TENS_PDE);.

Macsyma's dot operator "." can be used to construct tensor algebras,
as in ATENSOR.  Do DEMO(DOTOPERATOR); for a demonstration.  

You can DECLARE a function to be a DERIVATION or an ANTIDERIVATION
on ordinary products and on tensor algebras.

Macsyma has facilities for user to define their own OPERATORS, which
can be used to define tensor algebras, Lie algebras, etc.
Do DEMO(OPERATORS);  for a demonstration.

&TENSORS

See TENSOR_SUMMARY.

&TENTH(exp)

Returns the tenth part of exp.  It is affected by INFLAG, in the same
way as FIRST.

&TEX(expr1, ..., exprn)

Converts the Macsyma language expressions expri into TeX.  By default,
the TeX output is written to the screen display, but it can be made to
write to the screen display and/or a file.

The function TEX is contained in a library package, also called TEX,
which contains facilities for controlling output to files, character
spacing, and inclusion of Macsyma source expressions as comments in
the TeX output.

Do USAGE(TEX); for more information.

Do EXAMPLE(TEX); for executable examples.

See also DISPLAY_TEX, LATEX.

&TEX_LINEL default:70

Controls the line length of each line generated by the TEX command.
If set to a non-positive integer then no carriage returns will be 
inserted in the TEX source generated due to overly long lines.

&TEX_MULT_SPACE default:THIN

Controls how much space is used between terms in a product, such as in
TEX(X*Y^2*Z^3); .

Possible settings are:
 - NONE      no space is used.
 - THIN      \\, is used.
 - MEDIUM    \\> is used.

&THIRD(exp)

Returns the third part of exp.  It is affected by INFLAG, in the same
way as FIRST.

&THREADABLE

One can declare a function of one variable to be THREADABLE.  
This means it applies elementwise to lists, matrices, and equations.
THREADABLE is a member of the FEATURES list.  It can be asserted 
with DECLARE, withdrawn with REMOVE, and detected with FEATUREP.

Do EXAMPLE(THREADABLE); for an example.

See also MAP and MATRIXMAP.

&THROW(exp)

Evaluates exp and throws the value back to the most recent CATCH.
THROW is used with CATCH as a structured nonlocal exit mechanism.

&TICKNUM default:10

Specifies the number of ticks on each axis.  The ticks always come at
"nice" values of the coordinate.  Setting TICKNUM to a negative number
causes about ABS(TICKNUM) ticks to be drawn, but PLOT will not round
the maximum and minimum values on your axes to the nearest tickmark.
TICKNUM can be a list of two numbers, where the first refers to the
ticks on the X axis, and the second to the ticks on the Y axis.

&TICKSIZE default:6

Determines the size of the tickmarks on each axis.  Can be assign to
be a list of two numbers, one for each axis.

&TIME(Di1 {, Di2, ...})

Returns a list of the times in milliseconds taken to compute the Di,
where each Di is the label of an output line.  Each time in the list
will be either an integer runtime or a list of two integers,
representing [totaltime, gctime].  (Note: The variable SHOWTIME,
default:FALSE, may be set to TRUE to have computation times printed
out with each D-line.)

The following key combination enables you to check time used so far
in a computation without interrupting the computation:

 Control-] (Symbolics Lisp Machine only)

   Asynchronously prints the time used so far in a computation
   (without interrupting it).  In some computations, such as PLOT 
   and ROMBERG this may also print other information about how
   far the computation has gotten.

See also SHOWTIME, TIMER.

&TIMEDATE()

Returns the current date and time as a string.

See also TIMEDATE_FORMAT.

&TIMEDATE_FORMAT default:LONG

Controls the presentation style of the time/date string returned by
TIMEDATE.  Possible values are
 - SHORT (for a date such as "03/31/97 21:30:42")
 or
 - LONG (for a date such as "Monday, March 31, 1997, 9:30pm").

&TIMER(F {, F2, ...})

Puts a timer-wrapper on the function F, and optionally F2, ..., within
the TRACE package.  TIMER_INFO displays the CPU time information
collected by TIMER.  The timer-wrapper is removed from the function F
with the command UNTIMER(F {,F2,...});.  TIMER may be called on more
than one function at a time.

Do EXAMPLE(TIMER); for an example.

See also UNTIMER, SHOWTIME, TIMER_DEVALUE, TIMER_INFO, TIME.

&TIMER_DEVALUE default:TRUE

When set to TRUE, the time charged against a function by TIMER is the
time spent dynamically inside the function devalued by the time spent
inside other timed functions.

See also TIMER.

&TIMER_INFO(F)

[TRACE package] Prints the information on timing which is stored by
the TIMER function.

This information can also be accessed by
 - GET('F,'CALLS);
 - GET('F,'RUNTIME);
 - GET('F,'GCTIME); . 

&TITLE default:TITLE

The value of this option variable, which must be a string, appears as
the title in any plot drawn by Macsyma.  

See PLOTTING_SUMMARY for an overview of commands which control
plotting in Macsyma.

See also XLABEL, YLABEL.

&TLDEFINT(exp, var, ll, ul)

Is just LDEFINT with TLIMSWITCH set to TRUE.

&TLIMIT(exp, var, val, dir)

Is the same as the function LIMIT with TLIMSWITCH set to TRUE.

&TLIMSWITCH default:FALSE

If TRUE, will cause the LIMIT package to use TAYLOR series when
possible.

See also TLIMIT.

&TO_LISP()

Enters a LISP break from Macsyma.  How you return to MACSYMA depends
on the version of Macsyma you have:
 - On a PC, typing :2 or :ABORT will abort execution and typing :1 or
   :Continue will return to Macsyma.
 - In Unix versions, type :Q or :C number
   (the possible options and numbers will be displayed on your
   screen), or type (CONTINUE).
 - On Symbolics computers, press RESUME.

&TOBREAK()

Causes the previous Macsyma break, which was exited by typing
TOPLEVEL, to be re-entered. See EXIT(); . 

&TOEPLITZ(first_col {, first_row})

Returns a Toeplitz matrix with first column first_col. If first_row is
specified, then this will be the first row of the Toeplitz matrix.  If
first_row is not specified, then a symmetric Toeplitz matrix is
returned.  When determining the upper left element, the first element
of the first column takes precedence over the first element of the
first row. Both first_col and first_row are lists.

Do EXAMPLE(TOEPLITZ); for an example.

See also GENTOEPLITZ.

&TOP_5_TIPS

The Top 5 Tips for getting acquainted with Macsyma are


1.  The first step to getting help in Macsyma is to type a question
on a (c) line followed by a ?  to enter MathTips. Also, you can type
F1 with the cursor positioned on a word the Help system recognizes.
Don't forget about the other choices on the Help menu. 

2.  Input commands are not case sensitive in Macsyma.

3.  Basic Conventions:

   PC or MFE interface:
   Use Enter at a (Cnn) prompt to execute your command;

   Use Control-Enter for a new line without executing;

   Use * for multiplication, as in 2*x (not 2 x or 2x);

   Use : for assignment (e.g. a:4);

   Use = for equations (e.g. solve(x^2-x=0, x) solves the equation for x);

   Use := to define functions (e.g. f(x):=sin(x*x)+2);

   Use parentheses for functions (e.g. sin(x) not Sin[x] or sin x.);

   Use [ ] for lists/collections (e.g. [x,y,z] is a list of 3 variables);

   Use [ ] for matrices (e.g. [a,b;c,d] is a 2 x 2 matrix).

4.  Macsyma names its results Dnn, corresponding to Cnn.

5.  Use % to refer to the previous output expression (e.g. the last
  Dnn). Macsyma denotes common mathematical constants as %pi for
  3.14159..., %e for the base of natural logs, %i for sqrt(-1).


You can write programs with Macsyma commands. Look at more information

        BLOCK
        IF  THEN   ELSE 
        DO
        FOR .

&TOPLEVEL

During a break one may type TOPLEVEL;.  This will cause top-level
Macsyma to be entered recursively.  Labels will now be bound as usual.
Everything will be identical to the previous top-level state except
that the computation which was interrupted is saved.  The function
TOBREAK() will cause the break which was left by typing TOPLEVEL; to
be re-entered.  If TOBREAK is given any argument whatsoever, then the
break will be exited, which is equivalent to typing TOBREAK()
immediately followed by EXIT;.

&TOTALDISREP(exp)

Converts every subexpression of exp from CRE to general form.  If exp
is itself in CRE form then this is identical to RATDISREP but if not
then RATDISREP would return exp unchanged while TOTALDISREP would
"totally disrep" it.  This is useful for RATDISREPping expressions
e.g., equations, lists, matrices, etc. which have some subexpressions
in CRE form.

&TOTIENT(n)

Returns the number of integers less than or equal to n which are
relatively prime to n.

Do EXAMPLE(TOTIENT); for an example.

&TR_ARRAY_AS_REF default:TRUE

If TRUE runtime code uses the value of the variable as the array.

&TR_BOUND_FUNCTION_APPLYP default:TRUE

Gives a warning if a bound variable is found being used as a function.

&TR_FILE_TTY_MESSAGESP default:FALSE

Determines whether messages generated by TRANSLATE_FILE during
translation of a file will be sent to the TTY.  If FALSE (the
default), messages about translation of the file are only inserted
into the UNLISP file.  If TRUE, the messages are sent to the TTY and
are also inserted into the UNLISP file.

&TR_FLOAT_CAN_BRANCH_COMPLEX default:TRUE

States whether the arc functions might return complex results.  The
arc functions are SQRT, LOG, ACOS, etc.  For example, when it is TRUE
then ACOS(X) will be of mode ANY even if X is of mode FLOAT.  When
FALSE then ACOS(X) will be of mode FLOAT if and only if X is of mode
FLOAT.

&TR_FUNCTION_CALL_DEFAULT default:GENERAL

Affects how function calls are translated.

 - FALSE means give up and call MEVAL;
 - EXPR means assume Lisp fixed arg function;
 - GENERAL, the default, gives code good for MEXPRS and MLEXPRS but
   not MACROS.  

GENERAL assures variable bindings are correct in compiled code.  In
GENERAL mode, when translating F(X), if F is a bound variable, then it
assumes that APPLY(F,[X]) is meant, and translates a such, with
appropriate warning.  There is no need to turn this off.  With the
default settings, no warning messages implies full compatibility of
translated and compiled code with the Macsyma interpreter.

&TR_GEN_TAGS default:FALSE

If TRUE, TRANSLATE_FILE generates a tags file for use by the text
editor.

&TR_NUMER default:FALSE

If TRUE, NUMER properties are used for atoms which have them, e.g.
%PI.

&TR_OPTIMIZE_MAX_LOOP default:100

The maximum number of times the macro-expansion and optimization pass
of the translator will loop in considering a form.  This is to catch
MACRO expansion errors, and non-terminating optimization properties.

&TR_OUTPUT_FILE_DEFAULT default:LISP

This is the second file name to be used for translated lisp output.

&TR_SEMICOMPILE default:FALSE

If TRUE, TRANSLATE_FILE and COMPFILE output forms whose macros will be
expanded but not compiled into machine code by the lisp compiler.

&TR_STATE_VARS default:[TRANSCOMPILE, TR_SEMICOMPILE,
TR_WARN_UNDECLARED, TR_WARN_MEVAL, TR_WARN_FEXPR, TR_WARN_MODE,
TR_WARN_UNDEFINED_VARIABLE, TR_FUNCTION_CALL_DEFAULT, TR_ARRAY_AS_REF,
TR_NUMER]

The list of the switches that affect the form of the translated
output.  This information is useful to system people when trying to
debug the translator.  By comparing the translated product to what
should have been produced for a given state, it is possible to track
down bugs.

&TR_TRUE_NAME_OF_FILE_BEING_TRANSLATED default:FALSE

Is bound to the quoted string form of the true name of the file most
recently translated by TRANSLATE_FILE.

&TR_VERSION default:FALSE

The version number of the translator.

&TR_WARN_BAD_FUNCTION_CALLS default:TRUE

Gives a warning when function calls are being made which may not be
correct due to improper declarations that were made at translate time.

&TR_WARN_FEXPR default:COMPFILE

Gives a warning if any FEXPRs are encountered.  FEXPRs should not
normally be output in translated code, all legitimate special program
forms are translated.

&TR_WARN_MEVAL default:COMPFILE

Gives a warning if the function MEVAL gets called.  If MEVAL is called
that indicates problems in the translation.

&TR_WARN_MODE default:ALL

Gives a warning when variables are assigned values inappropriate for their
mode.

&TR_WARN_UNDECLARED default:COMPILE

Determines when to send warnings about undeclared variables to the TTY.

&TR_WARN_UNDEFINED_VARIABLE default:ALL

Gives a warning when undefined global variables are seen.

&TR_WARNINGS_GET()

Prints a list of warnings which have been given by the translator during
the current translation.

&TR_WINDY default:TRUE

Generate "helpful" comments and programming hints.

&TRACE({name1, name2, ...})

Gives a trace printout whenever the functions mentioned are called.
TRACE() prints a list of the functions currently under TRACE.  To
remove tracing, use UNTRACE. TRACE is among the most powerful tools
for debugging programs.

Do USAGE(TRACE) for more information.

Do EXAMPLE(TRACE); for an example, and DEMO(TRACE); for a longer
demonstration.

See also TRACE_OPTIONS, TIMER, BREAK, SETCHECK, SETCHECKBREAK.

Note: If you are looking for the trace of a matrix, see MATTRACE.

&TRACE_OPTIONS(F, option1, option2,...)

Gives the function F the options indicated.  An option is either a
keyword or an expression.  The possible Keywords are:

 Keyword     Meaning of return value
 ----------  ---------------------------
 NOPRINT     If TRUE do no printing. 
 BREAK       If TRUE give a breakpoint.
 LISP_PRINT  If TRUE use lisp printing.
 INFO        Extra info to print.
 ERRORCATCH  If TRUE errors are caught.

A keyword means that the option is in effect. Deactivate an option by
typing TRACE_OPTIONS(f, option:FALSE) .  Using a keyword as an
expression, e.g. NOPRINT(predicate_function) means to apply the
predicate_function (which is user-defined) to some arguments to
determine if the option is in effect.  The argument list to this
predicate_function is always [LEVEL, DIRECTION, FUNCTION, ITEM] where
LEVEL is the recursion level for the function.  DIRECTION is either
ENTER or EXIT.  FUNCTION is the name of the function.  ITEM is either
the argument list or the return value.

Do DEMO(TRACE); for a demonstration.

&TRADE_SECRET

The software, data, and information contained herein are proprietary
to, and comprise valuable trade secrets of, Macsyma Inc., which
intends to keep such software, data, and information confidential and
to preserve them as trade secrets.  They are given in confidence by
Macsyma Inc. pursuant to a written license agreement, and may be
used, copied, transmitted, and stored only in accordance with the
terms of such license.

** Copyright (c) 1982 - 1998 Macsyma Inc.  All rights reserved. 
** Portions copyright (c) 1982 Massachusetts Institute of Technology.
**                        All rights reserved.

COMMON LISP MACSYMA, PC MACSYMA, LISP MACHINE MACSYMA, and 
CL-MACSYMA are trademarks of Macsyma Inc.

MACSYMA (R) and MACSYMA Newsletter (R) are registered 
trademarks of Macsyma Inc.

All product names used herein which are not the trademarks of
Macsyma Inc. are the trademarks of their respective owners.

 
RESTRICTED RIGHTS LEGEND
Use, duplication, and disclosure by the Government are subject to 
restrictions as set forth in subdivision (c)(1)(ii) of the Rights in 
Technical Data and Computer Software Clause at DFAR 52.227-7013.
 
     Macsyma Inc.
     20 Academy Street
     Suite 201
     Arlington, Massachusetts 02476-6436
     United States of America
     tel: 781-646-4550

See ACKNOWLEDGMENTS to see acknowledgments and copyright notices for
contributed software.

&TRANSBIND default:FALSE

If TRUE, removes global declarations in the local context.  This
applies to variables which are formal parameters to functions which
one is TRANSLATE-ing from Macsyma code to LISP.

&TRANSCOMPILE default:FALSE

If true, TRANSLATE will generate the declarations necessary for
possible compilation.  The COMPFILE command uses TRANSCOMPILE:TRUE;.

&TRANSFER_MATRIX(A, B, C, D, VAR)

Returns the transfer function matrix of a linear multivariable
time-independent system described by the state-space equations

             'DIFF(Y,T) = A.Y + B.U
                      Z = C.Y + D.U .

Do USAGE(TRAN_MAT); for more information.

Do EXAMPLE(TRANSFER_MATRIX); for an example, and DEMO(TRAN_MAT); for
a longer demonstration.

&TRANSLATE(f1 {, f2, ...})

Translates the user defined functions f1,f2,... from the Macsyma
language to LISP (i.e. it makes them EXPRs).  This results in a gain
in speed when they are called.

Functions to be translated should include a call to MODE_DECLARE at
the beginning when possible in order to produce more efficient code.
For example:

F(X1,X2,...):=BLOCK([v1,v2,...],
        MODE_DECLARE(v1,mode1,v2,mode2,...),...)

where the X1,X2,...  are the parameters to the function and the
v1,v2,... are the local variables.  The names of translated functions
are removed from the FUNCTIONS list if SAVEDEF is FALSE and are added
to the PROPS lists.  Functions should not be translated unless they
are fully debugged.  Also, expressions are assumed simplified; if they
are not, correct but non- optimal code gets generated.  Thus, the user
should not set the SIMP switch to FALSE which inhibits simplification
of the expressions to be translated.

TRANSLATE default:FALSE
  If the switch TRANSLATE is TRUE, then user-defined functions are
  automatically translated to LISP.  Note that translated functions
  may not behave the same as untranslated versions, because certain
  incompatibilities may exist between the LISP and Macsyma versions.
  Principally, the RAT function with more than one argument and the
  RATVARS function should not be used if any variables are
  MODE_DECLAREd CRE.  Also the PREDERROR:FALSE setting will not
  translate.

TRANSRUN default:TRUE
  If FALSE will cause the interpreted version of all functions to be
  run (provided they are still around) rather than the translated
  version. 

The result returned by TRANSLATE is a list of the names of the
functions TRANSLATEd.

Do APROPOS(TR_) to see a list of option variable which affect the
behavior of the translator.

To translate a batch file to Lisp, use TRANSLATE_FILE.  

See also TRANSLATE_FILE, COMPILE, COMPILE_FILE.

&TRANSLATE_FILE(file {, output-file})

Translates a file of Macsyma code (a batch file) into a file of LISP
code.  The argument output-file is optional and is the name of the
translated file.  If you do not specify output-file, Macsyma names the
translated file file.lisp where the file extension is determined by
the value of the option variable TR_OUTPUT_FILE_DEFAULT
(default:lisp).

For example, the command TRANSLATE_FILE(TEST); translates a file
called TEST.MACSYMA into TEST.LISP. It also produce a file of
translator warning messages of various degrees of severity.  This
file contains valuable information for tracking down bugs in
translated code. This file also contains the name of the user, the
date, and the version of Macsyma.  In this case, the file is called
test.unlisp.

Do APROPOS(TR_) to see a list of option variable which affect the
behavior of the translator.

To translate a function into Lisp, use TRANSLATE.

See also COMPILE, COMPILE_FILE, FILE_PATHNAMES, FILES_SUMMARY,
FILENAMES.

&TRANSLATE_MATLAB_FILE(in-file {, inherit-existing-environment
{, out-file}})

Translates Matlab ".M" files into Macsyma command files.

The input file is a Matlab "function file" - it must define a 
function, and may not contain arbitrary commands.

Do DEMO(MATLAB); for a demonstration.

See also MAT_CONVERT_TO_BOOLEAN.

&TR_OUTPUT_FILE_DEFAULT  default: lisp

Default extension used by TRANSLATE_FILE.

&TRANSPOSE(Mat_or)

Returns the transpose of a matrix.  TRANSPOSE(A) and A^` are the same
thing.  List input is treated as a row vector and scalar input as a
1x1 matrix.
  
Macsyma has four postfix operators related to transpose:
  
 "^`"  ,  where A^` is the transpose of A,
  
 "^*"  ,  where A^* is the conjugate (Hermitian) transpose of A,
  
 "^~`" ,  where A^~` is the counter-transpose of A (reflection about
          the counter-diagonal),
  
 "^~*" ,  where A^~* is the conjugate (Hermitian) counter-transpose.

Do EXAMPLE(TRANSPOSE); for an example.

See also TRANSPOSE_LISTS.

&TRANSPOSE_LISTS(expr)

[FUNCTS package] Transposes a list of lists-of-equal-length. 

Example:

 (c1) [[a,b,c], [d,e,f]];
 (d1)           [[a,d], [b,e], [c,f]]

Do EXAMPLE(TRANSPOSE_LISTS); for an executable example.

See also TRANSPOSE.

&TRANSRUN default:TRUE

If FALSE, causes the interpreted version of all functions to be run
(provided they are still around) rather than the translated version.

&TRAPRULE(f, a, b, n)

Performs numerical integration of the function f using the trapezoidal
rule.  The lower and upper limits of integration are a and b, and the
number of subintervals is n.

Do EXAMPLE(TRAPRULE); for an example.

See also ROMBERG, BROMBERG, QUADRATR, QUANC8, SIMPSON.

&TRIANGSYS([exp1, ..., expn], [var1, ..., varn])

TRIANGSYS accepts the same arguments as does ALGSYS, but instead
of solving the system of equations it just triangularizes them,
using pseudo-division based elimination techniques.  Such techniques
may be viewed as a nonlinear generalization of the triangularization
performed during Gaussian elimination.  TRIANGSYS is employed by
ALGSYS (and hence SOLVE) when ALGSYS_USES_TRIANGSYS is TRUE.
TRIANGSYS returns a list of solutions, each solution consisting
of a triangularized list of polynomials.  Such a list will be
of the following form, where say [var1,...,varn] = [u,v,...,y,z],


  [   p1(u)
      p2(u,v)
       .
       .
       .
     p[n-1](u,v,...,y)
       p[n](u,v,...,y,z)  ]

Thus to solve such a system one need only solve the first equation,
back-substitute each root into the remaining equations, and iterate,
just as in the back-substitution process in Gaussian elimination.
This may be accomplished using the ROOT_VALUES command.  Note that
some of the polynomials p[i] may be identically zero if the system is
not zero-dimensional.  For further description of recent work on such 
elimination techniques see, e.g. Dongming Wang, An Elimination Method 
Based on Seidenberg's Theory and Its Applications, pp. 301-328 in:
Computational Algebraic Geometry, F. Eyssette, A. Galligo (eds.),
Birkhauser Publ. Comp., 1993.

Do EXAMPLE(TRIANGSYS); for an example.

See also ROOT_VALUES, ALGSYS, SOLVE, 

&TRIANGSYS_OUTPUT_FORMAT default: POLY

Controls the output format of the solutions generated by TRIANGSYS.
Possible values are the followings symbols:

   ROOT_OF: solutions are expressed as equations using the
     ROOT_OF notation, e.g. x = root_of(a*x^2+b*x+c, x).

   EQUATION: solutions are expressed implicitly as equations, e.g. a*x^2+b*x+c=0.

   POLY: solutions are expressed implicitly as polynomials, e.g. a*x^2+b*x+c.

&TRIANGULARIZE(M)

produces the upper triangular form of the matrix M which needn't be square.

Do EXAMPLE(TRIANGULARIZE); for an example.

See also MATRIX_SUMMARY.

&TRIG_SUMMARY

Macsyma has many capabilities for performing computations involving
trigonometric expressions, including

 - applying many types of trigonometric identities;
 - computation with POISSON series;
 - computation of FOURIER series and transforms.

The trigonometric functions defined in Macsyma are:  ACOS, ACOSH, 
ACOT, ACOTH, ACSC, ACSCH, ASEC, ASECH, ASIN, ASINH, ATAN, ATAN2,
ATANH, COS, COSH, COT, COTH, CSC, CSCH, SEC, SECH, SIN, SINH, TAN, 
and TANH. 

Other functions include GD, AGD, VERS, COVERS, EXSEC, and HAV.

Commands for manipulating trigonometric expressions are: TRIGCONTRACT,
TRIGEXPAND, TRIGREDUCE, TRIGSIMP, POISSIMP DEMOIVRE, EXPONENTIALIZE,
and the option variables %PIARGS, %IARGS, HALFANGLES, TRIGEXPAND,
TRIGEXPANDPLUS, TRIGEXPANDTIMES, TRIGINVERSES, TRIGSIGN.

The trigonometric simplification routines will use declared
information in some simple cases.  Declarations about variables are
used as follows, e.g.

 (c5) DECLARE(J, INTEGER, E, EVEN, O, ODD)$

 (c6) SIN(X + (E + 1/2)*%PI);

 (d6)                      COS(X)

 (c7) SIN(X + (O + 1/2) %PI);

 (d7)                     - COS(X)

The user can add trigonometric identities to the system using the
pattern matching capabilities of the system.

Do DEMO(TRIG); for a short demonstration.  

Do DEMO(TRIG_ANGLES) to illustrate some of some more advanced
treatments of special angles.

&TRIGCONTRACT(x)

Tries to transform a sum of trigonometric functions into a product of
trigonometric functions. It many situations, TRIGCONTRACT is
essentially an inverse for TRIGREDUCE. The current version of
TRIGCONTRACT works only on sums of sines and cosines.

Do EXAMPLE(TRIGCONTRACT); for an example.

See also TRIG_SUMMARY, TRIGREDUCE, TRIGEXPAND, TRIGSIMP.

&TRIGEXPAND(exp)

Expands trigonometric and hyperbolic functions of sums of angles and
of multiple angles occurring in exp.  For best results, exp should be
expanded.  To enhance user control of simplification, this function
expands only one level at a time, expanding sums of angles or multiple
angles.  To obtain full expansion into sines and cosines immediately,
set the switch TRIGEXPAND:TRUE.

TRIGEXPAND default:FALSE

  If TRUE, causes expansion of all expressions containing SINs and COSs
  occurring subsequently.

HALFANGLES default:FALSE

  If TRUE, causes half-angles to be simplified away.

TRIGEXPANDPLUS default:TRUE

  Controls the "sum" rule for TRIGEXPAND, expansion of sums (e.g.
  SIN(X+Y)) will take place only if TRIGEXPANDPLUS is TRUE.

TRIGEXPANDTIMES default:TRUE

 Controls the "product" rule for TRIGEXPAND, expansion of products
  (e.g. SIN(2*X)) will take place only if TRIGEXPANDTIMES is TRUE.

Example:

 (c1) X+SIN(3*X)/SIN(X),TRIGEXPAND=TRUE,EXPAND;

                               2           2
 (d1)                     - sin (x) + 3 cos (x) + x

 (c2) TRIGEXPAND(SIN(10*X+Y));

 (d2)               cos(10 x) sin(y) + sin(10 x) cos(y)


Do EXAMPLE(TRIGEXPAND); for an example.

See also TRIG_SUMMARY, TRIGCONTRACT, TRIGREDUCE, TRIGSIMP.

&TRIGEXPANDPLUS default:TRUE

Controls the "sum" rule for TRIGEXPAND.  Thus, when the TRIGEXPAND
command is used or the TRIGEXPAND switch set to TRUE, expansion of
sums (e.g.  SIN(X+Y)) will take place only if TRIGEXPANDPLUS is TRUE.

&TRIGEXPANDTIMES default:TRUE

Controls the "product" rule for TRIGEXPAND.  Thus, when the TRIGEXPAND
command is used or the TRIGEXPAND switch set to TRUE, expansion of
products (e.g. SIN(2*X)) will take place only if TRIGEXPANDTIMES is
TRUE.

&TRIGINVERSES default:TRUE

Controls the simplification of the composition of trigonometric and
hyperbolic functions with their inverse functions: 

 - If TRUE, then the arcfunction(function(x)) simplification is turned
   off.
 - If ALL, then both e.g.  ATAN(TAN(X)) and TAN(ATAN(X)) simplify to
   X.
 - If FALSE, then both the arcfun(fun(x)) and fun(arcfun(x))
   simplifications are turned off.

Beware that the setting ALL is risky when arguments contain
unconstrained symbols!  The simplification of ATAN(TAN(A)) to A is
valid only within half a period of the origin.  When A = 3*%PI/4,
ATAN(TAN(3*%PI/4)) = ATAN(-1) = -%PI/4.  The answer 3*%PI/4 (= A)
would be incorrect, since the range of ATAN is defined to be [-%PI/2,
%PI/2].  TRUE and FALSE are the only settings of TRIGINVERSES which
are immune to branch errors, and thus preserve the consistency of,
e.g., ATAN(TAN(3*%PI/4)) = SUBST(3*%PI/4,'A,ATAN(TAN('A))).

Do DEMO(TRIG_ANGLES) for a demonstration.

&TRIGONOMETRY

See TRIG_SUMMARY.

&TRIGREDUCE(exp, var)

Combines products and powers of trigonometric and hyperbolic SINs and
COSs of var into those of multiples of var.  It also tries to
eliminate these functions when they occur in denominators.  If var is
omitted then all variables in exp are used. 

 (c4) TRIGREDUCE(-SIN(X)^2+3*COS(X)^2+X);

 (d4)                        2 cos(2 x) + x + 1


Do EXAMPLE(TRIGREDUCE); for an example.  

See also TRIG_SUMMARY, TRIGCONTRACT, TRIGEXPAND, TRIGSIMP, POISSIMP

&TRIGSIGN default:TRUE

If TRUE permits simplification of negative arguments to trigonometric
functions.  E.g., SIN(-X) will become -SIN(X) only if TRIGSIGN is TRUE.

&TRIGSIMP(expr)

Employs the identities 

     sin(x)^2 + cos(x)^2 = 1  and  cosh(x)^2 - sinh(x)^2 = 1

to simplify expressions containing tan, sec, etc. to sin, cos, sinh,
cosh so that further simplification may be obtained by using
TRIGREDUCE on the result.

Do USAGE(TRIGSIMP); for more information.

Do EXAMPLE(TRIGSIMP); for an example.

See also TRIG_SUMMARY, TRIGCONTRACT, TRIGEXPAND, TRIGREDUCE, %PIARGS.

&TRUE

The Boolean constant, true. (T in LISP)

&TRUNC(exp)

Causes exp which is in general representation to be displayed as if
its sums were truncated TAYLOR series.  E.g. compare EXP1:X^2+X+1;
with EXP2:TRUNC(X^2+X+1); .  Note that IS(EXP1=EXP2); gives TRUE.

Do EXAMPLE(TRUNC); for an example.

&TRYLIST default:[]

[ODE package] For each function r(x) in TRYLIST the DESOL routine in
the ODE package changes the dependent variable via y(x) = r(x)*v(x)
and solving the resulting equation for v(x), then re-transforming to
find y(x). 

&TTYOFF default:FALSE

if TRUE stops printing output to the console.

&TYPE(type, v1, v2, ..., vn)

[GENTRAN package] Type declarations are automatically generated each
time a subprogram heading is generated.  Type declarations are
constructed from information stored in GENTRAN's symbol table.  The
user can place entries into the symbol table explicitly through calls
to the special GENTRAN function TYPE.

v1, v2, ..., vn is one or more variables (optionally subscripted to
indicate array dimensions), or variable ranges (two letters separated
by "-" and enclosed in double quotes).  v's are not evaluated unless
given as arguments to EVAL.  type is a variable type in the target
language.  It should be a string or an atom.  type is not evaluated
unless given as an argument to EVAL.

The TYPE function can also be used to declare subprogram types (i.e.,
SUBROUTINE or FUNCTION) for FORTRAN and Ratfor code, and function types
for FORTRAN, Ratfor, and C code.

Entries are placed in the symbol table for each variable or variable
range declared in the call to this function.  The function call itself
is removed from the statement group being translated.  Then after
translation, type declarations are generated from these symbol table
entries before the resulting executable statements are printed.

&UNDECLAREDWARN default:COMPFILE

A switch in the Translator.

There are four relevant settings:

   SETTING     | ACTION
  ------------------------------------------------------------
   FALSE       | never print warning messages.
   COMPFILE    | warn when in COMPFILE
   TRANSLATE   | warn when in TRANSLATE and when TRANSLATE:TRUE
   ALL         | warn in COMPFILE and TRANSLATE            
  ------------------------------------------------------------

Do MODE_DECLARE(<variable>,ANY) to declare a variable to be a general
Macsyma variable (i.e. not limited to being FLOAT or FIXNUM).  The
extra work in declaring all your variables in code to be compiled
should pay off.

&UNDERSIDE default:TRUE

(Not in Macsyma 2.0 and successors) When TRUE, PLOT3D shows the
underside of a figure, when it is visible.

&UNDIFF(exp)

[ITENSOR package] Returns an expression in which all occurrences of
indicial derivatives are replaced by the symbol 'UNDIFF.  This useful
for turning off indicial differentiation in order to evaluate
arguments of IDIFF before performing the differentiations. The command
REDIFF replaces the occurrences of IDIFF in the expression, and
evaluates them.

See also EVUNDIFF (which is usually more useful).

&UNDISTRIB(sum_of_terms)

Is sort of a reverse of DISTRIB.  It works by obtaining the syntactic
GCD of the term in the sum, e.g. the GCD of what is explicit
syntactically in the expression.  The syntactic GCD is found with
SYNTACTIC_GCD.

 (c1) EXP:A*B/C+A*B^2/C+A*B^3/C+A*B^4/C;
                                4      3      2
                             a b    a b    a b    a b
 (d1)                        ---- + ---- + ---- + ---
                              c      c      c      c
 (c2) UNDISTRIB(%);
                                    3    2
                              a b (b  + b  + b + 1)
 (d2)                         ---------------------
                                        c
 (c3) ARGS(EXP);
                                 4     3     2
                              a b   a b   a b   a b
 (d3)                        [----, ----, ----, ---]
                               c     c     c     c
 (c4) APPLY('SYNTACTIC_GCD,%);
                                       a b
 (d4)                                  ---
                                        c

&UNIFORM_DENSITY(x, a, b)

[UNIPROB package] The uniform density function is

              1
            -----
            b - a

See also UNIFORM_DISTRIB.

&UNIFORM_DISTRIB(x, a, b)

[UNIPROB package] The uniform distribution function is
integrate(UNIFORM_DENSITY(z,a,b),z,a,x) .

See also UNIFORM_DENSITY and INV_UNIFORM_DISTRIB.

&UNION(a {, b, c, ...})

Returns the union of a, b, c...  The function can be applied to an
arbitrary number of arguments.

Do EXAMPLE(UNION); for an example.

Do DESCRIBE(SET); and USAGE(SET); for more about operations on sets
in Macsyma.

&UNIPROB 

A package of discrete and continuous univariate probability densities
and distribution functions.

Do USAGE(UNIPROB); for more information.

Do DEMO(UNIPROB); for a demonstration.

&UNIT_CONVERT(x, y)

[UNITS package] Converts the dimensional quantity x to the consistent
dimensional quantity y.  For example, UNIT_CONVERT(volt/amp,'ohm)
will produce 1 'ohm, but UNIT_CONVERT(volt/amp,'pound) will signal an
error. If the optional evflag verbose:'true, then UNIT_CONVERT will also
produce an e-line illustrating the conversion equation.

See also TEMP_CONVERT to convert quantities involving temperature.

See also PHYSICAL_CONSTANTS. If you are just interest in the numerical
values of some of the common universal physical constants, do
INIT_PHYSICAL_CONSTANTS(); to make them accessible.

Do EXPUNGE_UNITS(); to remove quantities defined by the UNITS package.

Do DEMO(UNITS3); for examples of using UNIT_CONVERT and TEMP_CONVERT.

&UNIT_PLATEAU(x1 {, x2, ... xn, type})

Returns a plateau of unit width and centered at the origin
in N dimensions. 

The optional argument "Type" can be either 'square (the default)
or 'circular, which produces a circular plateau in N dimensions
centered at the origin.

Do EXAMPLE(UNIT_PLATEAU); for an example.

See also UNIT_RAMP and UNIT_STEP.

&UNIT_RAMP(x)

Defined as

  UNIT_RAMP(x):=(x+ABS(x))/2$

which is 0 if x<=0; x if x>=0 .

See also UNIT_PLATEAU and UNIT_STEP.

&UNIT_STEP(x)

Defined as
   UNIT_STEP(x):=(1+SIGNUM(x))/2$

which is 0 if x<0; 1/2 if x=0; 1 if x>0 .

See also UNIT_PLATEAU and UNIT_RAMP.

&UNIT_SURFACE_NORMAL(surf, list_of_vars)

[CURVSURF package] Returns a unit length normal vector field to
the 2-surface specified by surf which is embedded in 3-space.  
The surface can be specified as

- a function z=f(x,y), in which case the call to UNIT_SURFACE_NORMAL
  is of the form UNIT_SURFACE_NORMAL(f(x,y), [x,y]);

or

- a parametric surface [x(s,t), y(s,t), z(s,t)] in which case
  the call to UNIT_SURFACE_NORMAL is of the form
  UNIT_SURFACE_NORMAL([x(s,t),y(s,t),z(s,t)], [s,t]); .

or

- an implicit surface f(x,y,z)=constant, in which case the call
  to UNIT_SURFACE_NORMAL is of the form 
  UNIT_SURFACE_NORMAL(f(x,y,z), [x,y,z]); .


Do EXAMPLE(UNIT_SURFACE_NORMAL); for an example.

See also SURFACE_NORMAL and CURVSURF.

&UNITEIGENVECTORS(_matrix_)

[EIGEN package] Produces an output similar to EIGENVECTORS(_matrix_)
except that the eigenvectors are all of unit length.

See also NONDIAGONALIZABLE, HERMITIANMATRIX, KNOWNEIGVALS,
LISTEIGVALS, KNOWNEIGVECTS, LISTEIGVECTS.

&UNITS

A library package which converts a wide range of physical units of
measure into their SI, MKS, CGS or English equivalent units.

Do USAGE(UNITS); for more information.

For demonstrations, do:
 DEMO(UNITS);          Converts physical units of measure to MKS
 DEMO(UNITS1);         Converts physical units of measure to English
 DEMO(UNITS2);         Order of magnitude estimates of quantities
 DEMO(UNITS3);         Physical quantities and temperatures.

See also PHYSICAL_CONSTANTS.

&UNITVECTOR(X)

[EIGEN package] Takes a list X as its argument and returns a unit
list.  (i.e. a list with unit magnitude).  Do LOAD("EIGEN"); to access
this function.

&UNIVARIATE_STATISTICS(data_list {, _switch_})

Computes elementary population statistics for the univariate data in
data_list.  Data_list is a list of (single or double precision)
floating point sample data.

UNIVARIATE_STATISTICS returns the list of values
[mean, std. error, population variance, pop. skewness, pop. kurtosis]. 

If the optional argument _switch_ is ALL, then UNIVARIATE_STATISTICS
first prints on an intermediate line the list of values
[coefficient of variation, mean_deviation, sample_standard_deviation].

Do EXAMPLE(UNIVARIATE_STATISTICS); for an example.

&UNIVERSAL_TIME()

[FUNCTS package] Returns an integer which represents current clock
time. In some versions of Macsyma, this integer is the number of
seconds since the beginning of the year 1900.

Do EXAMPLE(UNIVERSAL_TIME); for an example.

&UNIX_CALL("string")

[UNIX Macsyma only] Passes string to the Bourne shell (/bin/sh) of the
UNIX operating system for execution.

&UNKNOWN(exp)

Returns TRUE if and only if exp contains an operator or function not
known to the built-in simplifier.

&UNORDER()

Stops the aliasing created by the last use of the ordering commands
ORDERGREAT and ORDERLESS.  ORDERGREAT and ORDERLESS may not be used
more than one time each without calling UNORDER.

Do EXAMPLE(UNORDER); for an example.

&UNPACK_HERM(list {, UPLO})

Unpacks the input list into a Hermitian matrix. If UPLO is 1
(default), it unpacks the lower triangular part, otherwise, the upper
triangular part. The remaining elements are filled in by Hermitian
symmetry.

This routine is used by NUMKIT.

&UNPACK_HERMMAT(mat {, UPLO})

Unpacks the input matrix mat into a Hermitian matrix. If UPLO is 1
(default), it packs the lower triangular part, otherwise, the upper
triangular part. The remaining elements are filled in by Hermitian
symmetry.

This routine is used by NUMKIT.

&UNPACK_SYM(list {, UPLO})

Unpacks the input list into a symmetric matrix. If
UPLO is 1 (default), it packs the lower triangular part, otherwise, the
upper triangular part. The remaining elements are filled by symmetry.

This routine is used by NUMKIT.

&UNPACK_SYMMAT(mat {, UPLO})

Unpacks the input matrix mat into a symmetric matrix. If UPLO is 1
(default), it packs the lower triangular part, otherwise, the upper
triangular part. The remaining elements are filled in by symmetry.

This routine is used by NUMKIT.

&UNPACK_TOPIC(topicname {,to_file})

Unpacks source code for examples or demonstrations, so you can access
the code for your own use.

Macsyma examples and demonstrations are packed in large files in order
to conserve disk space.  UNPACK_TOPIC("examplename.example"); or
UNPACK_TOPIC("demoname.demo"); creates a file in the example or demo
directory containing the source code for the example or demo.

If a second argument is supplied to UNPACK_TOPIC it is used as the 
destination of the unpacked file.

&UNPROD(expr, var)

[NUSUM package] Returns the first backward quotient, analogous to
UNSUM for products.  UNPROD is the inverse of the INDEFPROD operator,
also in the NUSUM package.  UNPROD(F(N),N) = F(N)/F(N-1).

&UNRANDOMIZE(x1 {, x2, ..., xn})

[STOCH package] Removes all stochastic attributes of its arguments.
UNRANDOMIZE() or UNRANDOMIZE(ALL) will remove all random  variables
and their attributes.

&UNSUM(expr, var)

[NUSUM package] Returns the first backward difference, analogous to
DIFF for sums.  UNSUM is the inverse of the INDEFSUM operator.
UNSUM(F(N),N) = F(N) - F(N-1).

Do EXAMPLE(UNSUM); for an example.

&UNTELLRAT(kernel1, kernel2, ...)

Takes kernels as arguments and removes TELLRAT properties from the 
given kernels and returns the list of the current TELLRAT extensions. 
For example, UNTELLRAT(X,COS(Y)); .

UNTELLRAT(ALL);  removes all user TELLRAT extensions.

&UNTIMER(F {, F2, ...})

Removes the timer-wrapper from the function F and optionally, F2,... .
UNTIMER may be called on more than one function at a time.  UNTIMER()
removes the timer-wrapper from all functions.

See also TIMER, SHOWTIME, TIMER_DEVALUE, TIMER_INFO, TIME.

&UNTRACE({name1, ...})

Removes tracing invoked by the TRACE function.  UNTRACE() removes
tracing from all functions.

Do EXAMPLE(UNTRACE); for an example.

&UNWIND_PROTECT(form, guardform1, guardform2, ...)

Tries to execute FORM.  If it executes, successfully, its value is
returned.  Whether or not it executes successfully, the guardforms are
executed before UNWIND_PROTECT returns (and their values are
discarded).

Example:

 (c1) ASSUME(X>3)$

 (c2) UNWIND_PROTECT((ASSUME(X>4),IS(X>4)),FORGET(X>4));

 (d2)                               true

 (c3) IS(X>4);
 Macsyma was unable to evaluate the predicate:
 X > 4
 Returned to Macsyma Toplevel.

 (c4) IS (X>3);

 (d4)                               true

See also BUT_UPON_RETURN.

&URICCI(dis)

[CTENSOR package] Computes the components of the mixed Ricci curvature
tensor, and stores then in the array URIC[i,j], where "i" is a
covariant (lower) index, and "j" is a contravariant (upper) index.
URICCI starts with (or computes) the covariant Ricci tensor (see
RICCI), then raises the second index with the contravariant metric
tensor.  If the argument dis is TRUE, then the nonzero components are
displayed.

See also RIEMANN, LRIEMANN, URIEMANN, RICCI, SCURVATURE, EINSTEIN,
WEYL.

&URIEMANN(dis)

[CTENSOR package] Computes the components of the totally contravariant
Riemann curvature tensor, and stores them in the array URIEM[i,j,k,l],
where all the indices are contravariant (upper).  URIEMANN starts with
the (1,3) Riemann tensor returned by RIEMANN (or computes it, if it is
not already available).  If dis is TRUE, then the nonzero components
of URIEM are displayed.

See also RIEMANN, LRIEMANN, RATRIEMANN, RICCI, URICCI, SCURVATURE,
EINSTEIN, WEYL.

&USAGE(package)

Displays the contents of the file package.USAGE which should document
how to use the package.  Some usage files describe in-core
capabilities in greater depth than the DESCRIBE command.

Do EXAMPLE(USAGE); for an example.

Users can supply .USAGE files for packages they write.  If the
directory where the .USAGE file is stored is included in Macsyma's
FILE_SEARCH list, these user-supplied files can be accessed with
the USAGE command.  See FILE_SEARCH for how to add a directory to
the FILE_SEARCH list.  See FILE_PATHNAMES for the pathname
conventions.

&USE_GROBNER default:TRUE

When set to TRUE tells ALGSYS to use GROBNER first.  This method of
solving systems of polynomial equations is contained in the Grobner
library, a package that implements the Spear/Buchberger Grobner basis
algorithm and some applications.

&USE_MATRIX_LU default:TRUE

System variable which controls whether LU decomposition is used for
(complex) numerical matrices by DETERMINANT and INVERT.  Numerical 
matrices in Macsyma are matrices, all of whose elements are integers, 
single or double floats, or rational numbers, or complex numbers of 
the same type.

See also NUMERICAL_MATRIXP and CNUMERICAL_MATRIXP.

&USE_NUMKIT_P()

Checks if NUMKIT is available to use in your Macsyma. Returns TRUE
or FALSE.

&USE_MINORS default:FALSE

Controls the method used for matrix inversion for non-numerical
matrices.  When it is FALSE, the default, a method based on Gaussian
elimination is used.  When USE_MINORS is set to TRUE, an adjoint
method using minors is used.  For numerical matrices, (matrices all of
whose elements are integers, single or double floats, or rational
numbers) inversion uses LU decomposition, and USE_MINORS has no
effect.

&USE_NILT default:TRUE

When not FALSE then ILT will call NILT on any expression which it
cannot transform.  Otherwise, ILT will not call NILT.

&USE_NUMKIT default: TRUE

Option variable that describes conditions for using NUMKIT.

   - 'TRUE   use NUMKIT, if available, when the problem is "big enough."
 
   - 'FALSE  never use NUMKIT routines.

   - 'ALL   always use NUMKIT.

See USAGE(NUMKIT); for more information.

Do DEMO(NUMKIT); DEMO(NUMKIT1); or DEMO(NUMKIT2); for examples of using
NUMKIT. 

&USE_NUMKIT_P(Func, Size)

Checks if NUMKIT is available to use in your Macsyma. Returns TRUE
or FALSE. Func is the NUMKIT function and size is the number of elements of
the problem matrix. 

&USE_OPERATORS default:FALSE

[OPALG package] The operator algebra code is used if and only if
USE_OPERATORS is set to TRUE.  When the OPALG package loads, it sets
USE_OPERATORS to TRUE.

&USE_TABS_FOR_DISPLAY default:TRUE

Controls whether tab characters or spaces are used in non-cursor
positioned Macsyma output.  A WRITEFILE with FANCY_WRITEFILE:FALSE is
an example.

&USE_UNITS(system)

[UNITS package] Initializes the UNITS package to use one of the four
systems of units - SI, MKS, CGS, or ENGLISH.  A system of units is
defined in terms of five fundamental quantities: length, time, mass,
charge and temperature.

See also UNITS and PHYSICAL_CONSTANTS.

&USE_WEIERSTRASS_FIX default:TRUE

The Weierstrass substitutions e.g., u=tan(x/2) are used by INTEGRATE
to convert trigonometric integrals into algebraic integrals.  A
correction to the answer is sometimes needed to eliminate a spurious
discontinuity which can occur.  If FALSE, the Weierstrass correction
is never applied; if ALL, the correction is always applied; if TRUE,
the correction is applied only when the integrand is univariate, i.e.
contains no parameters.

&USER_HOMEDIR_PATHNAME()

Returns a pathname for the user's home directory.  This is usually the
directory where you keep personal files such as initialization files
and mail.

&VANDERMONDE(list_of_vars {, numcols})

Returns a Vandermonde matrix with second column specified by the list
list_of_vars.  Equivalently, list_of_vars is a list of the variables
which are raised to powers moving from left to right in the
Vandermonde matrix.  If numcols is specified, then the matrix
returned has numcols columns.  If numcols is not specified, then
numcols defaults to length(second_col), that is, the matrix returned
is square.

Do EXAMPLE(VANDERMONDE); for an example.

See also GENVANDERMONDE.

&VALUES default:[]

Returns a list of the names of all bound atoms, i.e. user variables,
not Macsyma Options or Switches, (set up by : , :: , or functional
binding).

See also INFOLISTS.

&VARC1(lhs, rhs, dep_var, indep_var, order, {initial_value_list})

[RECUR package] Solves the difference equation by solving an
associated ODE first.  This works on linear first- and
second-order variable-coefficient difference equations. The
argument lhs is the recurrence equation being solved; rhs is the
inhomogeneous part of the expression, or zero; dep_var is the name
of the dependent variable; indep_var is the independent variable;
order is the order of the equation; initial_value_list, if given,
is a list of assignments specifying initial conditions.

For solving recurrence equations, users should first try the command
DIFFERENCEQ.

&VARC2(lhs, rhs, dep_var, indep_var, order, initial_value_list)

[RECUR package] Like VARC1 except it only works on linear
first-order variable-coefficient difference equations. The
argument lhs is the recurrence equation being solved; rhs is the
inhomogeneous part of the expression, or zero; dep_var is the name
of the dependent variable; indep_var is the independent variable;
order is the order of the equation; initial_value_list, if given,
is a list of assignments specifying initial conditions.

For solving recurrence equations, users should first try the command
DIFFERENCEQ.

&VEC2LIST(vec)

forms a list from the elements of a row or column vector vec.

Do EXAMPLE(VEC2LIST); for an example.

&VECT

The vector analysis package.  VECT can combine and simplify symbolic
expressions including dot products and cross products, together with
the gradient, divergence, curl, and Laplacian operators.  The
distribution of these operators over sums or products is under user
control, as are various other expansions, including expansion into
components in any specific orthogonal coordinate systems.  There is
also a capability for deriving the scalar or vector potential of a
field.  Do LOAD("VECT"); to load this package.

The package contains the commands VECTORSIMP, VECT_COORDSYS,
VECT_EXPRESS, SCALAR_POTENTIAL, and VECTOR_POTENTIAL.  

Do USAGE(VECT); for more information.

Do DEMO(VECT); and DEMO(VECT_PDE); for demonstrations.

The library file VECT_ORT contains definitions of various
orthogonal curvilinear coordinate systems, in a form usable by the
VECT package.  CT_COORDSYS defines coordinate systems for the
CTENSOR package.

The CARTAN package for exterior calculus also contains some vector
calculus operations.  See CARTAN for more information.

Warning:  The VECT package declares "." to be a commutative operator.
In order to restore "." to its usual status as the noncommutative matrix
multiplication operation, do REMOVE(".",COMMUTATIVE); when done with
the VECT package.

See also VECT_ORT, CARTAN, CTENSOR, ITENSOR.

&VECT_COORDSYS(coordinate_transform)

[VECT package] Sets up the VECT package to operate in the orthogonal
coordinate system specified by the input coordinate_transform.

coordinate_transform must evaluate to the form
  [[expression1, expression2, ...], coord1, coord2,...], 
where
 - [coord1, coord2,...] are the names of the curvilinear coordinates,
 - [expression1, expression2, ...] is a set of expressions which
   express a set of rectangular Cartesian coordinates in terms of the
   curvilinear coordinates [coord1,coord2,...].

VECT_COORDSYS makes the following assignments:
 - VECT_COORDS is set to the vector [coord1, coord2,...] .
 - VECT_DIM is set to the length of this vector.  
 - SF[1], SF[2], ..., SF[VECT_DIM] are set to the coordinate scaling
   factors in each direction, and SFPROD is set to the product of
   these expressions.

Initially, VECT_COORDS is [X, Y, Z], VECT_DIM is 3, and SF[1]=SF[2]=
SF[3]=SFPROD=1, corresponding to 3-dimensional Cartesian coordinates.

To expand an expression in the current coordinate system (either the
default 3D Cartesian coordinates or others specified with VECT_COORDSYS),
use the command VECT_EXPRESS.

The VECT_ORT package contains names for 20 pre-programmed coordinate
systems, so that these names evaluate to the form required by 
VECT_COORDSYS.

Invoking the command VECT_COORDSYS will load the VECT package if it is
not already loaded.

See also VECT_ORT, VECT_EXPRESS.  Also the function CT_COORDSYS, which
sets up orthogonal and other coordinate systems for component tensor
analysis.

&VECT_CROSS default:FALSE

[VECT package] If TRUE allows DIFF(X~Y,T) to work where ~ is the vector
cross product.

&VECT_EXPRESS(expression)

[VECT package] Expands an expression in terms of the current coordinate
system as specified by the command VECT_COORDSYS.  The result uses the noun
form of any derivatives arising from expansion of the vector differential
operators.  To force evaluation of these derivatives, the built-in EV
function can be used together with the DIFF evflag, after using the
built-in DEPENDS function to establish any new implicit dependencies.

See also VECT_ORT for pre-defined orthogonal coordinate systems
for use with the VECT package and with VECT_EXPRESS.

&VECT_ORT

A library file which contains definitions of various orthogonal curvilinear
coordinate systems, in a form usable by the VECT package.  For example,

    VECT_COORDSYS(POLARCYLINDRICAL);

is the same as typing

    VECT_COORDSYS([[R*COS(THETA),R*SIN(THETA),Z],R,THETA,Z]); .

Definitions for the following coordinate systems are included in
the file.

  2 Dimensions       3 Dimensions          3D Spherical-like Systems
  -------------      -------------         -------------------------
   CARTESIAN2D       CARTESIAN3D           SPHERICAL *
   POLAR *           POLARCYLINDRICAL *    OBLATESPHEROIDAL
   ELLIPTIC          ELLIPTICCYLINDRICAL   OBLATESPHEROIDALSQRT
   CONFOCALELLIPTIC  CONFOCALELLIPSOIDAL   PROLATESPHEROIDAL
   BIPOLAR           BIPOLARCYLINDRICAL    PROLATESPHEROIDALSQRT
   PARABOLIC         PARABOLICCYLINDRICAL
                     PARABOLOIDAL
                     CONICAL
                     TOROIDAL

  * For these coordinate systems, VECT_COORDSYS implements the
    assumption ASSUME(R>=0)$.

The variable VECT_COORDINATE_SYSTEMS evaluates to a list of the
names of the coordinate systems available in VECT_ORT, and each
name evaluates to a list suitable as input to the command
VECT_COORDSYS. Each name, when preceded by "%", evaluates to a
list of the information needed to specify that coordinate system. 
For example %CARTESIAN2D evaluates to [[x,y], x, y] .

The command VECT_COORDSYS, when given as argument one of the coordinate
system names in VECT_ORT, will load the VECT_ORT package. 
Otherwise, you can access the package by doing LOAD("VECT_ORT"); .

The VECT_EXPRESS command converts vector algebra and calculus
expressions into the coordinate system specified by the command
VECT_COORDSYS. 

&VECTOR

See VECT

&VECTOR_CROSS(vec1, vec2)

[GEOFUNCS package] Returns the vector cross product of vectors vec1
and vec2 in two or three dimensions. vec1 and vec2 must be lists of
length 2 or 3.

Do EXAMPLE(VECTOR_CROSS); for an example.

&VECTOR_POTENTIAL(given_curl)

[VECT package] Returns the vector potential of a vector whose curl is
given_curl, in the current coordinate system.

POTENTIAL_ZERO_LOCATION

  Has a similar role as for SCALAR_POTENTIAL, (i.e. determines the
  point which serves as the lower limit of integration), but the order
  of the left-hand sides of the equations must be a cyclic permutation
  of the coordinate variables.

&VECTORP(expr)

Tests the expression expr to see whether it is a vector.  To be a
vector, expr must be an empty matrix or a one-row matrix or a
one-column matrix (and not a list or a scalar). Notice there is no way
to DECLARE a variable to be a vector (or a matrix). The vector must be
specifically formed.

Do EXAMPLE(VECTORP); for an example.

See also ROWVECTORP, COLVECTORP, MATRIXP, SQUARE_MATRIXP.

&VECTORS

See VECT

&VECTORSIMP(vectorexpression)

[VECT package] This function employs some non-controversial
simplifications, together with various optional expansions according to the
settings of the following global flags:

EXPANDALL, EXPANDDOT, EXPANDDOTPLUS, EXPANDCROSS, EXPANDCROSSPLUS,
EXPANDCROSSCROSS, EXPANDGRAD, EXPANDGRADPLUS, EXPANDGRADPROD,
EXPANDDIV, EXPANDDIVPLUS, EXPANDDIVPROD, EXPANDCURL, EXPANDCURLPLUS,
EXPANDCURLCROSS, EXPANDCURLCURL, EXPANDCURLPROD, EXPANDLAPLACIAN,
EXPANDLAPLACIANPLUS, EXPANDLAPLACIANPROD.

All these flags have default value FALSE.  The PLUS suffix refers
to employing additivity or distributivity.  The PROD suffix refers
to the expansion for an operand that is any kind of product.  When
TRUE, each flag causes the VECTORSIMP command to perform a
particular simplification:

- EXPANDCROSSCROSS replaces p~(q~r) with (p.r)*q-(p.q)*r.
- EXPANDCURLCURL replaces CURL CURL p  with  GRAD DIV p + DIV GRAD p.
- EXPANDLAPLACIANTODIVGRAD refers replaces the LAPLACIAN operator
  with DIV GRAD.

Three other flags, EXPANDCROSS, EXPANDPLUS and EXPANDPROD, have
the same effect as setting to TRUE all flags which include the
suffix CROSS or PLUS or PROD, respectively.  For convenience, all
of these flags have been declared EVFLAG.

Invoking the command VECTORSIMP will load the VCET package if it is
not already loaded.

&VERB

the opposite of "noun", i.e. a function form which "does something"
("action" - for most functions the usual case).  E.g.  INTEGRATE integrates
a function, unless it is DECLAREd to be a "noun", in which case it
represents the INTEGRAL of the function.

See NOUN, NOUNIFY, VERBIFY, "'", "''".

&VERBIFY(f)

returns the function name f in its verb form.

See also VERB, NOUN, NOUNIFY, "'", "''".

&VERBOSE default:FALSE

if TRUE will cause comments about the progress of POWERSERIES, NEWTON and
other commands to be printed as execution proceeds.

See also DIFFERVERBOSE, ODETUTOR.

&VERS(X)

[ALGFUNCS package]  1 - COS(X) .

&VERSION default:2 or 420

Is the version number of Macsyma.  This is useful if the user wants to
label his output, or to associate bugs with a particular version.

VERSION() - is a function which returns a list of information including
the major and minor version numbers.

&VIEWPT default:[] 

VIEWPT and CENTERPLOT determine the perspective view taken for plotting
commands.  They are defaulted to be unbound.  VIEWPT may be set to a list
of 3 numbers and gives the point from which the projection should be made.
CENTERPLOT may likewise be set to a list of 3 numbers and gives a point on
the line of sight.  The projection will be made onto a plane perpendicular
to a line joining VIEWPT and CENTERPLOT.

The values of VIEWPT and CENTERPLOT from the previous 3D plot are stored
in the variables VIEWPT1 and CENTERPLOT1.  They are useful to look at
before changing VIEWPT or CENTERPLOT.

If VIEWPT and CENTERPLOT are unbound (the default) then they will be
chosen as follows: the extreme values of the coordinates are determined.
This gives the two points min: [xmin,ymin,zmin], max:[xmax,ymax,zmax].
CENTERPLOT is chosen as (min+max)/2, and VIEWPT is chosen as
max+3*(max-min).  The view is then one in which the z axis is vertical,
the x axis is increasing towards you to the left and the y axis is
increasing towards you to the right.

If CENTERPLOT is FALSE then the old type of perspective view will be
given (like setting the x and z components of CENTERPLOT to the
corresponding components of VIEWPT).

Do EXAMPLE(VIEWPT); for an example.

See also PLOT_PHI, PLOT_THETA, PLOT_ROLL, PLOT_SIZE.

&VOL_CONE(base, height)

[GEOFUNCS package] Returns the volume of a conical solid with
specified base area and height, which is base*height/3.

&VOL_CUBE(edge)

[GEOFUNCS package] Returns the volume of a cube with specified edge,
which is edge^3. 

&VOL_PYRAMID3(edge)

[GEOFUNCS package] Returns the volume of an equilateral pyramid with a
triangular base and with specified edge.

&VOL_PYRAMID4(edge)

[GEOFUNCS package] Returns the volume of an equilateral pyramid with a
square base and with specified edge.

&VOL_RECTANGULOID(length, width, height)

[GEOFUNCS package] Returns the volume of a rectangular solid with
specified length, width and height, which is length*width*height.

&VOL_CIRCULAR_CONE(radius, height)

[GEOFUNCS package] Returns the volume of a cone with circular base of
specified radius and specified height.

&VOL_CIRCULAR_CYLINDER(radius, height)

[GEOFUNCS package] Returns the volume of a circular cylinder with
specified radius and height.

&VOL_SPHERE(radius)

[GEOFUNCS package] Returns the volume of 3-sphere with specified
radius, which is 4/3*%pi*radius^3.

&VOL_TETRAHEDRON(p0, p1, p2, p3)

[GEOFUNCS package] Returns the volume of a tetrahedron in 3-space
which is specified by four vertices p0, p1, p2, p3. Each of p0, p1,
p2, p3 must be a list of length 3, specifying the Cartesian
coordinates of one vertex.

Do EXAMPLE(VOL_TETRAHEDRON); for an example.

&WAIT default:TRUE

When TRUE, Macsyma waits for you to press the SPACE bar after a plot
before processing continues. When FALSE, Macsyma does not wait before
processing continues.

WAIT is often used with CLEAR to superimpose plots created by consecutive
plot commands.  For example,

(block([wait:false], plot(sin(x),x,0,10)),
 block([clear:false], plot(cos(x),x,0,10)))$

An alternative way to superimpose plots is the use the keywords FIRST,
SAME, and LAST in the plot commands.  For example:

(plot(sin(x),x,0,10,first),
 plot(cos(x),x,0,10,same),
 plot(sin(2*x),x,0,5,same,last))$

See also CLEAR, COMBINE_PLOTS.

&WEIBULL_DENSITY(x, a, b)

[UNIPROB package] The density function

  a*b*x^(b-1)*EXP(-a*x^b).

See also WEIBULL_DISTRIB.

&WEIBULL_DISTRIB(x, a, b)

[UNIPROB package] The distribution function for the WEIBULL_DENSITY.

See also WEIBULL_DENSITY and INV_WEIBULL_DISTRIB.

&WELCH_WINDOW(t, t0, t1)

Computes the Welch Window function:

  if t<t0 or t>t1 then 0 else 1-abs(t-(t1-t0)/2)*2/(t1-t0).

Do EXAMPLE(WELCH_WINDOW); for an example and DEMO(POWER_SPECTRUM);
for a longer demonstration.

See also POWER_SPECTRUM, BARTLETT_WINDOW.

&WERF(Z)

The error function of complex argument.  It's definition is:  
WERF(Z) := EXP(-Z^2)*(1 - ERF(-%I*Z)) .

Do EXAMPLE(WERF); for an example.  See also ERF.

&WEYL(dis)

[CTENSOR package] Computes the components of the Weyl conformal
tensor, and stores them in the array W[i,j,k,l].  If the switch
RATWEYL is set to TRUE, then the components will be rationally
simplified.  If RATFAC is TRUE then the results will be factored as
well.  If the argument dis is TRUE, then the non-zero components are
displayed.

See also RIEMANN, LRIEMANN, URIEMANN, RICCI, URICCI, SCURVATURE,
EINSTEIN, IWEYL.

&WHO()

[Lisp Machine Macsyma only] Prints out the currently logged in users.

&WISHART_MDF(Z, V, nu {, zdet, vdet})

The multivariate Wishart probability density function with zero mean value.
The Wishart distribution is like a multivariate gamma distribution.

Arguments:

 - Z is an m x m positive definite symmetric matrix of random
   variables.
 - V is the precision matrix, an m x m positive definite symmetric
   matrix which is the inverse of the covariance matrix.
 - nu is the number of degrees of freedom.  It can be a number or 
   a mathematical expression.
 - zdet is the determinant of the matrix Z.  If you know zdet,
   you can specify it and save the time needed to recompute it.
 - vdet is the determinant of the matrix V.  If you know vdet,
   you can specify it and save the time needed to recompute it.

                       
                       (nu-m-1)/2      nu/2      1
 WISHART_MDF = k det(Z)          det(V)    exp(- - trace(V . Z))
                                                 2
                                    m
                                  -----
               nu*m/2   m*(m-1)/4  | |
  where 1/k = 2      %pi           | | Gamma((nu+1-i)/2)
                                   | |
                                   i=1

Do EXAMPLE(WISHART_MDF); for an example.

See also GAMMA_DENSITY, INV_WISHART_MDF.

&WOODBURY(Ainv, U, V)

Given a square matrix Ainv and two matrices U and V, computes
the inverse of the square matrix (A + U . V), where

 - Ainv = inverse of n x n matrix A, 
 - U is a n x p matrix, where 1<=p<=n,
 - V is a p x n matrix, where 1<=p<=n.

This command uses the Woodbury formula

 (A + U . V)^^-1 = 
  A^^-1 - (A^^-1 . U) . (I + (V . A^^-1 . U))^^-1 . (V . A^^-1)

where I = n x n identity matrix.

Do EXAMPLE(WOODBURY); for an example.

See also SHERMAN_MORRISON.

&WRITE_DATA_TO_FILE(filename, data {,arg})

[FUNCTS package] Writes data which is a list, matrix, 1-index declared
array or scalar to a file specified by filename.  If arg='append, then
the data is appended to an existing file with the given pathname, if
such a file already exists.

WRITE_DATA_TO_FILE uses the function NUMPRINT to print numerical data.

An alternative procedure is to use MFE_PUT and the MFE data export
facility as follows. Suppose you have a Macsyma list named MY_DATA
which you want to export to a file.

 (c4) MFE_PUT(MY_DATA, NEWNAME);

In MFE, click on Data-Export, specify a file name, the variable
name NEWNAME, and pick either CSV format, or fixed field. 

See also WRITEFILE, READ_NUMERICAL_DATA, MFE_PUT.

&WRITE_TEX_FILE({TRUE}, {filename})

If TRUE is specified, the TeX output is written to the terminal.  If a
filename is specified, the TeX output is appended to the file indicated.
This means that if the file exists, the output is appended to it.  If
the file does not exist, a new file is created with the specified name,
and output is written to it.  Only one TeX file can be opened at a time.
The TEX function writes both to the terminal and to a file if and only
if it is called with two arguments.

The file can be closed with the CLOSE_TEX_FILE.

&WRITEFILE(filepathname)

Opens up a file for recording input and output in a file.  All
interaction between the user and Macsyma is recorded in this file, just
as it is on the console.  Comments which appear in batch files are
written into the writefile.  Comments typed interactively at the
terminal between /* and */ are not recorded, except when running batch
files; use strings ("..."  items) for comments.

The resulting WRITEFILE captures only a transcript of the display of a
computation session, and does not capture the expressions themselves.
To save the actual expressions in internal form, use the SAVE command.
SAVEd files can be brought back into Macsyma via the LOAD function.
To save expressions in a linear form which may then be BATCHed in later,
use the STRINGOUT command.

Do EXAMPLE(WRITEFILE); for an example.

See also WRITEFILE_ON, APPENDFILE, CLOSEFILE, WRITE_DATA_TO_FILE.

&WRITEFILE_ON

A system variable which takes on the values TRUE and FALSE to indicate
whether a writefile is currently open and receiving output, or not. While a
WRITEFILE is in progress, the user can set WRITEFILE_ON to FALSE to cause
output to not go to the file.

See FILE_PATHNAMES for how to specify file pathnames in Macsyma.

See also WRITEFILE.

See also APPENDFILE, CLOSEFILE, FANCY_WRITEFILE.

See FILENAMES for information about how to specify file pathnames in
Macsyma.  See FILES_SUMMARY for more information about file manipulation
commands in Macsyma.

&WRONG_NUMBER_OF_ARGS_ERROR(name)

signals the error:  "Wrong number of arguments to name."

&WRONSKIAN(funclist, var)

[MATFUNCS package] Computes the Wronskian matrix of the list of functions
`funclist' in the variable `var'.

Example:

 (c1) WRONSKIAN([F(X),G(X),H(X)],X);

              [      f(x)            g(x)            h(x)      ]
 (d1)         [  diff(f(x),x)    diff(g(x),x)    diff(h(x),x)  ]
              [ diff(f(x),x,2)  diff(g(x),x,2)  diff(h(x),x,2) ]

The term "Wronskian" usually refers to the determinant of this matrix.

Do EXAMPLE(WRONSKIAN); for an example.

&XAXIS default:ALL

If set to TRUE/FALSE, then the x-axis and tick marks are drawn/suppressed
(in PLOT commands).  If set to ALL, draw the x-axis and print the maximum
and minimum values of this coordinate in a line beneath the plot.

&XLABEL default:XLABEL

The value of this option variable can be set to a string, which will
appear as the label for the X-axis (the axis for the first variable)
in any 2D or 3D plot drawn by Macsyma.  See PLOTTING_SUMMARY for an
overview of commands which control plotting in Macsyma.

See also YLABEL, TITLE.

&XMAX default:'XMAX
 and
XMIN default:'XMIN

Determine the max and min values of the "x" coordinate in plots.  The
default value causes plot commands to determine these limits from the
expression being plotted.  In 3D plots, these variables refer to the
coordinate values after perspective transformations.

See also. YMAX, ZMAX, XMAX3D, YMAX3D, ZMAX3D.

&XMAX3D default:'XMAX3D
 and
XMIN3D default: 'XMIN3D

In 3D plots, these variables refer to the coordinate values before
perspective transformations.

See also XMAX, YMAX, ZMAX, YMAX3D, ZMAX3D.

&XMIN 

See XMAX.

&XMIN3D

See XMAX3D.

&XTHRU(exp)

Combines all terms of exp (which should be a sum) over a common
denominator without expanding products and exponentiated sums as
RATSIMP does.  XTHRU cancels common factors in the numerator and
denominator of rational expressions but only if the factors are
explicit.  If any sums in exp contain embedded sums, use
SCANMAP(XTHRU,EXP); to get all the sums XTHRUed.  Sometimes it is
better to use XTHRU before RATSIMPing an expression in order to cause
explicit factors of the gcd of the numerator and denominator to be
canceled thus simplifying the expression to be RATSIMPed.

Do EXAMPLE(XTHRU); for an on-line example.

See also COMBINE, EXPAND, MULTTHRU, RATSIMP.

&YAXIS default:ALL

If set to TRUE/FALSE, then the y-axis and tick marks are
drawn/suppressed (in PLOT commands).  If set to ALL, draw the y-axis
and print the maximum and minimum values of this coordinate in a line
beneath the plot.

&YLABEL default:YLABEL

The value of this option variable can be set to a string, which will
appear as the label for the Y-axis (the axis for the second variable)
in any 2D or 3D plot drawn by Macsyma.  See PLOTTING_SUMMARY for an
overview of commands which control plotting in Macsyma.

See also XLABEL, TITLE.

&YMAX default:'YMAX
 and
YMIN default:'YMIN

Determine the max and min values of the "y" coordinate in plots.  The
default value causes plot commands to determine these limits from the
expression being plotted.  In 3D plots, these variables refer to the
coordinate values after perspective transformations.

See also. XMAX, ZMAX.

&YMAX3D default:'YMAX3D
 and
YMIN3D default:'YMIN3D

In 3D plots, these variables refer to the coordinate values before
perspective transformations.

See also XMAX, ZMAX, XMAX3D, ZMAX3D.

&YMIN 

See YMAX.

&YMIN3D

See YMAX3D.

&ZERO_FIND(func, var, hi, lo {, tol})

Finds a real zero of the univariate function func(var) searching in the
interval [hi,lo] using a ROOT_BY_BISECTION followed by a NEWTON step to
polish the approximate numerical root. tol is an optional numerical
tolerance for finding a root (default: ROOTS_TOL).

Do EXAMPLE(ZERO_FIND); for an example.

See also ROOTS_POLISH, ROOTS_POLISH_LIST and ZERO_FIND_LIST.

&ZERO_FIND_LIST(func, var_list {,tol})

Finds a list of real zeroes of the univariate function func whose
approximate values are given in the list var_list. The form of var_list is

   [var=R1, ... , var=RN].

tol is an optional numerical tolerance for root finding (default:
ROOTS_TOL).

See also ROOTS_POLISH, ROOTS_POLISH_LIST and ZERO_FIND.

&ZEROBERN default:TRUE

if set to FALSE excludes the zero BERNOULLI numbers.

See also BERN.

&ZEROEQUIV(exp, var)

Tests whether the expression exp in the variable var is equivalent to
zero.  It returns either TRUE, FALSE, or DONTKNOW.

Examples:

 (c1) ZEROEQUIV(SIN(2*X) - 2*SIN(X)*COS(X),X);

 (d1)                             true

 (c2) ZEROEQUIV(%E^X+X,X);

 (d2)                             false

On the other hand,

 (c3) ZEROEQUIV(LOG(A*B) - LOG(A) - LOG(B),A);

 (d3)                            dontknow

because of the presence of an extra parameter.

Restrictions on the use of ZEROEQUIV are:

(1) Do not use functions that Macsyma does not know how to
    differentiate and evaluate.

(2) If the expression has poles on the real line, there may be errors
    in the result (but this is unlikely to occur).

(3) If the expression contains functions which are not solutions to
    first order differential equations (e.g.  Bessel functions) there
    may be incorrect results.

(4) The algorithm uses evaluation at randomly chosen points for carefully
    selected subexpressions.  This is always a somewhat hazardous
    business, although the algorithm tries to minimize the potential for
    error.

Do EXAMPLE(ZEROEQUIV); for an example.

See also ZEROP.

&ZEROMATRIX(m, n)

Takes integers m,n as arguments and returns an m by n matrix of 0's.

Do EXAMPLE(ZEROMATRIX); for an example.

See also MAT_ZEROS and the MATRIX_SUMMARY.

&ZEROP(expr)

Returns TRUE if expr is a `zero' of some type, i.e.
MEMBER(expr,[0,0.0,0.0d0,0.0b0]) is TRUE; else ZEROP(expr) returns FALSE.
ZEROP could be defined as ZEROP(EXPR):=NUMBERP(EXPR) AND EQUAL(EXPR,0)$

Do EXAMPLE(ZEROP); for an example.

See also ZEROEQUIV, PREDICATES.

&ZETA(X)

Gives the Riemann Zeta function for certain integer values of X.

See also ZETA%PI, BFZETA, ZETADERIV and ZETA_REFLECT.

&ZETA_REFLECT(exp)

implements the Zeta reflection formula (AS p. 807 23.2.6).

Do EXAMPLE(ZETA_REFLECT); for an example.

&ZETA%PI default:TRUE

If FALSE, suppresses ZETA(n) giving coeff*%PI^n for n even.

&ZETADERIV(X {, N})

Returns the derivative of the Riemann Zeta function of order N at the
point X.  X is a real or complex single float, double float, or bigfloat
number.  N is a non-negative integer.  If N is not specified, it defaults
to 1.

Do EXAMPLE(ZETA); for an example.

See also ZETA, BFZETA.

&ZMAX default:'ZMAX
 and
ZMIN default: 'ZMIN

In contour plots, determines the max and min values of the "z"
coordinate for which contours are calculated.  These variables are
ignored if CONTOURS is a list.

See also XMAX, YMAX, XMAX3D, YMAX3D, ZMAX3D.

&ZMAX3D default:'ZMAX3D
 and
ZMIN3D default:'ZMIN3D

In 3D plots, these variables refer to the coordinate values before
perspective transformations.

See also XMAX, YMAX, ZMAX, XMAX3D, YMAX3D.

&ZMIN 

See ZMAX.

&ZMIN3D

See ZMAX3D.

&ZUNDERFLOW default:TRUE

If FALSE, an error will be signaled if floating point underflow occurs.

&"["

[ and ] are the characters which Macsyma uses to delimit a list.

&^^

The non-commutative exponentiation operator.  The inverse of a matrix
may be obtained by using a negative exponent, i.e.  M^^-1.

See also INVERT.

