;;; -*- Mode: LISP; Syntax: ansi-common-lisp; Package: http; Base: 10; Patch-File: t -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; Patch file for CL-HTTP version 67.52
;;; Reason: Patch in file data caching.
;;; Function HTTP::BYTE-RANGE-PARAMETERS:  return end position.
;;; Function HTTP::%WRITING-BINARY-FILE:  abstract HTTP envelop into macro.
;;; Function HTTP::%%WRITE-BINARY-FILE:  use it.
;;; Function HTTP::%%CACHING-WRITE-BINARY-FILE:  use it in caching version.
;;; Written by JCMa, 6/03/98 12:11:07
;;; while running on Lispm Machine Thomas Jefferson from FEP0:>COMLINK-38-76-KBCW-1-A-MIT-8-5.ilod.1
;;; with Genera 8.5, Experimental IP-TCP Documentation 422.0, NFS Server 439.0,
;;; Mailer 438.0, Print Spooler 439.0, Domain Name Server 436.0,
;;; Experimental Lock Simple 435.1, Compare Merge 404.0, VC Documentation 401.0,
;;; Logical Pathnames Translation Files NEWEST, Experimental Conversion Tools 436.0,
;;; Metering 444.0, Metering Substrate 444.0, Hacks 440.0, CLIM 72.0,
;;; Genera CLIM 72.0, PostScript CLIM 72.0, Experimental CLIM Documentation 71.27,
;;; Statice Runtime 466.0, Statice 466.0, Statice Browser 466.0,
;;; Statice Server 466.0, 8-5-Patches 1.1, MAC 413.0,
;;; Relatus Natural Language Environment 183, RELATUS Utilities 29.2,
;;; Experimental Gnoscere Representation System 13.7,
;;; Dynamic Window Hardcopy Extensions 4.1, Background Bug Reporting 12.0,
;;; Experimental Relatus Parser Semantic Perception 27.1, Showable Procedures 36.3,
;;; Binary Tree 34.0, Experimental Reference System 32.2,
;;; Experimental Semantic Inversion 19.2, Experimental Lexical Classifier 3.0,
;;; Experimental Gnoscere Activity System 6.2, Flavor Resource 1.0,
;;; Relatus Parser 5.6, Experimental Relatus Generator 6.2,
;;; Lisp System Extensions 72.2, Object Resource 36.0, Agent Utilities 45.0,
;;; Working LispM Mailer 7.0, HTTP Server 67.51, W3 Presentation System 7.0,
;;; CL-HTTP Server Interface 52.0, Symbolics Common Lisp Compatibility 3.0,
;;; Comlink Packages 5.1, Comlink Utilities 9.41, COMLINK Cryptography 1.1,
;;; Routing Taxonomy 8.3, COMLINK Database 10.110, Email Servers 11.21,
;;; Comlink Customized LispM Mailer 6.14, Dynamic Forms 12.18,
;;; Communications Linker Server 38.77, Lambda Information Retrieval System 18.24,
;;; Experimental Joshua 237.3, Experimental Start3 NEWEST, Jcma 41,
;;; Experimental Knowledge-Based Collaboration Webs System 19.0,
;;; Experimental The Project Planner 13.0, W4 Constraint-Guide Web Walker 38.3,
;;; HTTP Client Substrate 1.9, HTTP Proxy Server 2.10, HTTP Client 48.4,
;;; Experimental Image Substrate 438.1, Experimental Essential Image Substrate 431.0,
;;; W4 Examples 10.0, Ivory Revision 4A, IFEP 328, FEP0:>I328-loaders.flod(24),
;;; FEP0:>I328-info.flod(24), FEP0:>I328-debug.flod(24), FEP0:>I328-lisp.flod(25),
;;; FEP0:>I328-kernel.fep(44), Boot ROM version 320, Device PROM version 325,
;;; Genera application 5.6.1a1, MacIvory SCSI Manager Server 4.3.2a1,
;;; Toolbox Servers 4.2, MacIvory & RPC library 6.3.4a1,
;;; MacIvory life support 4.3.8a1, Symbolics keyboard 2.1.1a1,
;;; Macintosh System Software 8.1, 1152x820 Screen with Genera fonts,
;;; Machine serial number 30376, Macintosh Quadra 800, Symbolics Keyboard,
;;; Add support for Apple's Gestalt and Speech Managers. (from SYS:MAC;MACIVORY-SPEECH-SUPPORT.LISP.1),
;;; Domain Fixes (from CML:MAILER;DOMAIN-FIXES.LISP.33),
;;; Don't force in the mail-x host (from CML:MAILER;MAILBOX-FORMAT.LISP.23),
;;; Make Mailer More Robust (from CML:MAILER;MAILER-FIXES.LISP.15),
;;; Patch TCP hang on close when client drops connection. (from HTTP:LISPM;SERVER;TCP-PATCH-HANG-ON-CLOSE.LISP.10),
;;; Add CLIM presentation and text style format directives. (from FV:SCLC;FORMAT.LISP.20),
;;; Deny some hosts access to some servers. (from CML:LISPM;HOST-SERVICE-ACCESS-CONTROL.LISP.4),
;;; Fix Statice Lossage (from CML:LISPM;STATICE-PATCH.LISP.3),
;;; COMLINK Mailer Patches. (from CML:LISPM;MAILER-PATCH.LISP.102),
;;; Clim patches (from CML:DYNAMIC-FORMS;CLIM-PATCHES.LISP.48),
;;; Hacks to DW to let us kludge by. (from PROJECT-PLANNER:CODE;SYSTEM-PATCHES.LISP.6),
;;; Prevent reset of input buffer on tcp reset by HTTP servers. (from HTTP:LISPM;W4;RECEIVE-TCP-SEGMENT-PATCH.LISP.7),
;;; Provide MIME Type on Document formats. (from KBCW:SUBSTRATE;DB-DOCUMENT-MIME-TYPE.LISP.25).



(SCT:FILES-PATCHED-IN-THIS-PATCH-FILE 
  "HTTP:SERVER;UTILS.LISP.356"
  "HTTP:SERVER;SERVER.LISP.739")


;========================
(SCT:BEGIN-PATCH-SECTION)
; From buffer data-cache.lisp >http>server W: (66)
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-Common-Lisp; Base: 10; Mode: lisp; Package: HTTP -*-")

(PROGN
;;; -*- Syntax: Ansi-Common-Lisp; Base: 10; Mode: lisp; Package: HTTP -*-

;;; (C) Copyright 1998, John C. Mallery.
;;;     All Rights Reserved.
;;;
;;;------------------------------------------------------------------- 
;;;
;;; DATA CACHING IN DYNAMIC MEMORY
;;;

(defparameter *data-cache-window-frequency* 250
  "The default window within which data source access frequencies are computed.")

(defparameter *data-universe-revalidation-interval* (* 15. 60.) ;default to 15 minutes
  "The default interval in seconds between revalidation of data cached by data universes.")

(defparameter *data-universe-maximum-cache-size* 5000000        ;default to 5 megabytes
  "The default maximize amount of memory in bytes which cached data may consume in any single data universe.")

(defparameter *data-universe-maximum-cache-elements* 100
  "The default maximize number of elements allowed in any single data universe at any one time.")

(defparameter *data-universe-audited-elements* 100
  "The default number of elements audited for caching.")

;;;------------------------------------------------------------------- 
;;;
;;; CLASS DEFINITIONS
;;;

(defclass data-universe-cache-mixin
          ()
    ((minimum-frequency-data-cache :initform nil :initarg :minimum-frequency-data-cache :accessor minimum-frequency-data-cache)
     (current-window :initform 0 :initarg :current-window :reader current-cache-window)
     (window-frequency :initform *data-cache-window-frequency* :initarg :window-frequency :accessor cache-window-frequency)))

(defclass file-data-universe
          (basic-data-universe)
    ())

(defmethod print-object ((universe basic-data-universe) stream)
  (with-slots (name) universe
    (print-unreadable-object (universe stream :type t :identity t)
      (when name
        (princ name stream)))))

(defclass data-auditor-cache--mixin
          ()
    ((current-window :initform 0 :initarg :window :accessor current-cache-window)))

(defclass data-auditor
          (data-auditor-cache--mixin)
    ((reference-count :initform 0 :initarg :reference-count :accessor %data-auditor-reference-count)
     (last-reference :initform 0 :initarg :last-reference :accessor %data-auditor-last-reference)
     (universe :initform 0 :initarg :universe :accessor data-auditor-universe)
     (datum :initform nil :initarg :datum :accessor data-auditor-datum))
  (:documentation "Class that records access statistics for data."))

(defmethod print-object ((auditor data-auditor) stream)
  (let ((datum (data-auditor-datum auditor)))
    (print-unreadable-object (auditor stream :type t :identity t)
      (when datum
        (princ datum stream)))))

(defclass data-cache-cache--mixin
          ()
    ((current-window :initform 0 :initarg :window :accessor current-cache-window)
     (previous-reference-count :initform 0 :initarg :previous-reference-count :accessor data-cache-previous-reference-count)))

(defclass basic-data-cache
          (data-cache-cache--mixin)
    ((array :initform nil :initarg :array :accessor data-cache-array)
     (size :initform 0 :initarg :size :accessor data-cache-size)
     (universe :initform nil :initarg :universe :accessor data-cache-universe)
     (update-time :initform nil :initarg :update-time :accessor data-cache-update-time)
     (revalidation-time :initform nil :initarg :revalidation-time :accessor data-cache-revalidation-time)
     (revalidation-interval :initarg :revalidation-interval :accessor data-cache-revalidation-interval)
     (lock :initform nil :initarg :lock :accessor data-cache-lock)
     (reference-count :initform 0 :initarg :reference-count :accessor data-cache-reference-count)
     (last-reference :initform nil :initarg :last-reference :accessor data-cache-last-reference)
     (wired-p :initform nil :initarg :wired-p :accessor data-cache-wired-p))
  (:documentation "The basic data cache class from which all instances are built."))

(defclass file-data-cache-mixin
          ()
    ((pathname :initform nil :initarg :pathname :accessor data-cache-pathname)
     (version :initform 0 :initarg :version :accessor data-cache-version)
     (last-modification :initform 0 :initarg :last-modification :accessor data-cache-last-modification))
  (:documentation "A mixin class that enables data caches to keep the contents of files in memory."))

(defclass binary-file-data-cache
          (file-data-cache-mixin basic-data-cache)
    ()
  (:documentation "A mixin class for caching binary file data in memory."))

(defclass crlf-file-data-cache
          (binary-file-data-cache)
    ((crlf-pathname :initform nil :initarg :crlf-pathname :accessor data-cache-crlf-pathname))
  (:documentation "A mixin class for caching CFLF canonicalizable file data in memory."))

;; Print method for file data caches.
(defmethod print-object ((data-cache file-data-cache-mixin) stream)
  (let ((pathname (data-cache-pathname data-cache)))
    (print-unreadable-object (data-cache stream :type t :identity t)
      (when pathname
        (princ pathname stream)))))


;;;------------------------------------------------------------------- 
;;;
;;; UTILS
;;;

(define-macro with-data-cache-lock ((data-cache &optional (mode :write)) &body body)
  "Grabs the lock for DATA-CACHE with mode MODE within the scope of BODY."
  `(let ((lock (data-cache-lock ,data-cache)))
     (with-lock-held (lock ,mode "Data Wait")
       . ,body)))

(declaim (inline get-pathname-data-cache))

(defun get-pathname-data-cache (pathname)
  (get-value pathname :data-cache))

(defun set-pathname-data-cache (pathname data-cache)
  (setf (get-value pathname :data-cache) data-cache))

(defun remove-pathname-data-cache (pathname)
  (remove-value pathname :data-cache))

(declaim (inline get-pathname-data-auditor))

(defun get-pathname-data-auditor (pathname)
  (get-value pathname :data-auditor))

(defun set-pathname-data-auditor (pathname data-auditor)
  (setf (get-value pathname :data-auditor) data-auditor))

(defun remove-pathname-data-auditor (pathname)
  (remove-value pathname :data-auditor))


;;;------------------------------------------------------------------- 
;;;
;;; OPERATIONS ON DATA-UNIVERSES
;;;

(defparameter *standard-data-universe* nil
  "Holds the current data universe object.")

(define-macro with-data-universe ((universe) &body body)
  "Binds data-universe as the standard data universe within body."
  `(let ((*standard-data-universe* ,universe)) . ,body))

(declaim (inline standard-data-universe))

(defun standard-data-universe ()
  "Returns the current data universe object."
  *standard-data-universe*)

(defparameter *data-universe-class* 'file-data-universe
  "The standard class for new data universes.")

(defvar *data-universes* nil
  "All known data universes.")

(define intern-data-universe (universe &key (if-does-not-exist :error) (class *data-universe-class*))
  "Interns UNIVERSE and returns the data universe object.
IF-DOES-NOT-EXIST indicates the action to take if data-universe 
does not already exist and can be any of :SOFT, :CREATE, :ERROR.
CLASS is the class of universe to create and NAME is the name for
a newly created universe."
  (declare (values data-universe newly-created-p))
  (etypecase universe
    (string
      (or (find universe *data-universes* :test #'equalp :key #'data-universe-name)
          (ecase if-does-not-exist
            (:soft nil)
            (:create (values (register-data-universe (make-instance class :name universe)) t))
            (:error (error "No data universe named, ~S, exists." universe)))))
    (basic-data-universe universe)))

(defmethod register-data-universe ((universe basic-data-universe))
  (pushnew universe *data-universes*)
  (unless *standard-data-universe*
    (setq *standard-data-universe* universe))
  universe)

(define-generic unintern-data-universe (universe)
  (declare (values uninterned-p universe)) 
  (:documentation "Uninterns data-universe."))

(defmethod unintern-data-universe ((universe basic-data-universe))
  (when (member universe *data-universes*)
    (setq *data-universes* (delete universe *data-universes*))
    (when (eq universe *standard-data-universe*)
      (setq *standard-data-universe* nil))
    (values t universe)))

(defmethod unintern-data-universe ((universe string))
  (let ((dc (intern-data-universe universe :if-does-not-exist :soft)))
    (when dc
      (unintern-data-universe dc))))

(defmethod initialize-instance :after ((universe basic-data-universe) &key &allow-other-keys)
  (let ((size (data-universe-cache-table-size universe))
	(audit-size (data-universe-auditor-table-size universe)))
    (setf (data-universe-cache-table universe) (make-hash-table :test #'equal :size size)
	  (data-universe-auditor-table universe) (make-hash-table :test #'equal :size audit-size))
    universe))

(define-generic data-universe-increment-total-cache-size (universe &optional delta)
  (:documentation "Increments the total cache size of UNIVERSE  by DELTA,
which defaults to 1. The operation is thread safe."))

(defmethod data-universe-increment-total-cache-size ((universe basic-data-universe) &optional (delta 1))
  (with-slots (total-cache-size) universe
    (atomic-incf total-cache-size delta)))

(define-generic cache-data (universe data-source &key revalidation-interval wired-p &allow-other-keys)
  (declare (values data-cache))
  (:documentation "Primary method for caching DATA-SOURCE in the data universe, UNIVERSE."))

(defmethod cache-data ((universe file-data-universe) (data-source pathname) &key revalidation-interval wired-p &allow-other-keys)
  (let ((path (data-universe-cache-key universe data-source))
        (interval (or revalidation-interval (data-universe-revalidation-interval universe)))
        cache)
    (setq cache (cond ((crlf-canonicalizable-pathname-p path)
                       (make-instance 'crlf-file-data-cache
                                      :pathname path
                                      :crlf-pathname (crlf-pathname path)
                                      :revalidation-interval interval
                                      :wired-p wired-p
                                      :universe universe))
                      (t (make-instance 'binary-file-data-cache
                                        :pathname path
                                        :revalidation-interval interval
                                        :wired-p wired-p
                                        :universe universe))))
    (register-data universe cache)
    cache))

(defmethod cache-data ((universe file-data-universe) (data-source string) &key revalidation-interval wired-p &allow-other-keys)
  (cache-data universe (pathname data-source) :revalidation-interval revalidation-interval :wired-p wired-p))

(defmethod cache-data ((universe basic-data-universe) (data-sources cons) &rest args)
  (declare (dynamic-extent args))
  (loop for entry in data-sources
        do (typecase entry
             (atom (apply #'cache-data universe entry args))
             (cons (destructuring-bind (data-source . args) entry
                     (let ((nargs `(,@args ,.args)))
                       (declare (dynamic-extent nargs))
                       (apply #'cache-data universe data-source nargs))))))) 

(defmethod cache-data ((universe string) data-sources &rest args)
  (declare (dynamic-extent args))
  (apply #'cache-data (intern-data-universe universe) data-sources args))

#|
(define-cached-data ("Standard-Pathname-Cache")
		    ("w.ai.mit.edu:>http>www>cl-http>cl-http.html" :wired-p t))
|#

(define-generic decache-data (universe data-source))

(defmethod decache-data ((universe basic-data-universe) data-source)
  (let ((data-cache (find-data-cache universe data-source nil)))
    (when data-cache
      (decache-data universe data-cache))))

(defmethod decache-data ((universe basic-data-universe) (data-cache basic-data-cache))
  (unregister-data universe data-cache))

(defmethod decache-data :around ((universe basic-data-universe) (data-cache file-data-cache-mixin))
  (when (call-next-method)
    (let* ((pathname (data-cache-pathname data-cache))
           (auditor (get-pathname-data-auditor pathname))
           (count (data-cache-reference-count data-cache))
           (access-time (data-cache-last-reference data-cache))
           (window (current-cache-window data-cache))
           (u (data-cache-universe data-cache)))
      (cond (auditor
	     (setf (%data-auditor-reference-count auditor) count
		   (%data-auditor-last-reference auditor) access-time
		   (current-cache-window auditor) window
		   (data-auditor-universe auditor) auditor))
	    (t (setq auditor (make-instance 'data-auditor :universe u :datum pathname
					    :window window :reference-count count
					    :last-reference access-time))
	       (register-data u auditor)))
      t)))

(defmethod decache-data ((universe null) (data-cache basic-data-cache))
  (decache-data (data-cache-universe data-cache) data-cache))

(define-generic find-data-cache (universe data-source &optional error-p)
  (declare (values data-cache))
  (:documentation "Finds the data cache for DATA-SOURCE in UNIVERSE."))

(defmethod find-data-cache ((universe basic-data-universe) data-source &optional (error-p t))
  (cond ((gethash (data-universe-cache-key universe data-source) (data-universe-cache-table universe)))
        (error-p (error "DATA-SOURCE, ~S, is not cached in ~S." data-source universe))
        (t nil)))

(define-generic register-data (universe data-cache))

(defmethod register-data ((universe basic-data-universe) (data-cache basic-data-cache))
  (with-slots (cached-elements total-cache-size) universe
    (setf (gethash (data-universe-cache-key universe data-cache) (data-universe-cache-table universe)) data-cache)
    (atomic-incf cached-elements)
    (atomic-incf total-cache-size (data-cache-size data-cache))
    data-cache))

(defmethod register-data :after ((universe file-data-universe) (data-cache file-data-cache-mixin))
  (let ((old-data-cache (get-pathname-data-cache (data-cache-pathname data-cache))))
    (when old-data-cache
      (error "A data cache, ~S, already exists for ~A." old-data-cache (data-cache-pathname data-cache)))
    (set-pathname-data-cache (data-cache-pathname data-cache) data-cache)
    data-cache))

(defmethod register-data :after ((universe basic-data-universe) (data-cache crlf-file-data-cache))
  (setf (gethash (data-cache-crlf-pathname data-cache) (data-universe-cache-table universe)) data-cache)
  data-cache)

(defmethod register-data ((universe basic-data-universe) (data-auditor data-auditor))
  (setf (gethash (data-universe-cache-key universe data-auditor) (data-universe-auditor-table universe)) data-auditor)
  data-auditor)

(defmethod register-data :after ((universe file-data-universe) (data-auditor data-auditor))
  (let ((pathname (data-auditor-datum data-auditor)))
    (setf (get-pathname-data-auditor pathname) data-auditor)
    data-auditor))

(define-generic unregister-data (universe data-cache-or-auditor)
  (declare (values removed-p old-data-cache-or-auditor)))

(defmethod unregister-data ((universe basic-data-universe) (data-cache basic-data-cache))
  (with-slots (cached-elements total-cache-size) universe
    (let ((cache-table (data-universe-cache-table universe)))
      (when (remhash (data-universe-cache-key universe data-cache) cache-table)
        (atomic-decf cached-elements)
        (atomic-decf total-cache-size (data-cache-size data-cache))
        t))))

(defmethod unregister-data :after ((universe file-data-universe) (data-cache file-data-cache-mixin))
  (remove-pathname-data-cache (data-cache-pathname data-cache)))

(defmethod unregister-data :after ((universe basic-data-universe) (data-cache crlf-file-data-cache))
  (let ((cache-table (data-universe-cache-table universe)))
    (remhash (data-cache-crlf-pathname data-cache) cache-table)))

(defmethod unregister-data :around ((universe basic-data-universe) data-cache)
  (let ((removed-p (call-next-method)))
    (values (not (null removed-p)) data-cache)))

(defmethod unregister-data ((universe basic-data-universe) (data-auditor data-auditor))
  (when (remhash (data-universe-cache-key universe data-auditor) (data-universe-auditor-table universe))
    t))

(defmethod unregister-data :after ((universe file-data-universe) (data-auditor data-auditor))
  (let ((pathname (data-auditor-datum data-auditor)))
    (remove-pathname-data-auditor pathname)
    data-auditor))

(define-generic data-universe-cache-key (universe data-source)
  (:documentation "Returns a canonicalization of DATA-SOURCE suitable for use as a cache key."))

(defmethod data-universe-cache-key (universe data-source)
  (declare (ignore universe))
  data-source)

(defmethod data-universe-cache-key ((universe file-data-universe) (data-source string))
  (data-universe-cache-key universe (pathname data-source)))

(defmethod data-universe-cache-key ((universe file-data-universe) (data-source pathname))
  (make-pathname :version nil :defaults data-source))

(defmethod data-universe-cache-key ((universe file-data-universe) (data-source logical-pathname))
  (data-universe-cache-key universe (translate-logical-pathname data-source)))

(defmethod data-universe-cache-key ((universe basic-data-universe) (data-source data-auditor))
  (data-auditor-datum data-source))

(define-generic get-data-cache (universe data-source)
  (declare (values data-cache))
  (:documentation "Returns the data-cache object associated with DATA-SOURCE in the data universe, UNIVERSE."))

(defmethod get-data-cache ((universe basic-data-universe) data-source)
  (gethash (data-universe-cache-key universe data-source) (data-universe-cache-table universe)))

(define-generic remove-data-cache (universe data-source)
  (declare (values removed-p old-data-cache))
  (:documentation "Removes the data cache for DATA-SOURCE from the data universe, UNIVERSE."))

(defmethod remove-data-cache ((universe basic-data-universe) data-source)
  (unregister-data universe (get-data-cache universe data-source)))

(define-generic recache-data-cache (universe data-source)
  (:documentation "Recaches the data associated with DATA-SOURCE in the data universe UNIVERSE."))

(defmethod recache-data-cache ((universe basic-data-universe) data-source)
  (let ((cache (get-data-cache universe data-source)))
    (when cache 
      (recache-data cache))))

(define-generic map-data-caches (universe function)
  (:documentation "Maps FUNCTION over all the data caches associated with the data universe, UNIVERSE.
FUNCTION is called with the arguments (DATA-SOURCE-KEY DATA-CACHE-OBJECT)."))

(defmethod map-data-caches ((universe basic-data-universe) function)
  (declare (dynamic-extent function))
  (maphash function (data-universe-cache-table universe)))

(define-generic map-data-auditors (universe function)
  (:documentation "Maps FUNCTION over all the data auditors associated with the data universe, UNIVERSE.
FUNCTION is called with the arguments (DATA-SOURCE-KEY DATA-AUDITOR-OBJECT)."))

(defmethod map-data-auditors ((universe basic-data-universe) function)
  (declare (dynamic-extent function))
  (maphash function (data-universe-auditor-table universe)))

(define-generic recache-data-universe (universe)
  (:documentation "Recaches all cached data in UNIVERSE."))

(defmethod recache-data-universe ((universe file-data-universe))
  (flet ((recache-item (pathname data-cache)
           (unless (crlf-pathname-p pathname) 
             (with-data-cache-lock (data-cache :write)
               (recache-data data-cache)))))
    (map-data-caches universe #'recache-item)))

(define-generic clear-data-universe (universe)
  (:documentation "Clears all cached data in UNIVERSE."))

(defmethod clear-data-universe ((universe basic-data-universe))
  (flet ((uncache-item (key data-cache)
           (declare (ignore key))
           (unregister-data universe data-cache)))
    (declare (dynamic-extent #'uncache-item))
    (map-data-caches universe #'uncache-item)
    (map-data-auditors universe #'uncache-item)))

(define-generic ensure-current-data (data-universe-or-data-cache)
  (:documentation "Ensures that data-universe-or-data-cache holds the most recent information
from the associated data source."))

(defmethod ensure-current-data ((universe basic-data-universe))
  (flet ((ensure-fresh-item (key data-cache)
           (declare (ignore key))
           (ensure-current-data data-cache)))
    (map-data-caches universe #'ensure-fresh-item)))

(define-generic set-minimum-frequency-data-cache (universe)
  (:documentation "Sets the minimum frequency data cache of the data universe, universe,
to the lowest-frequency volatile data cache in the current cache window."))

(defmethod set-minimum-frequency-data-cache ((universe data-universe-cache-mixin))
  (setf (minimum-frequency-data-cache universe) (data-universe-sweep-for-data-cache
						  universe :minimum-frequency :current-window-volatile)))


;;;------------------------------------------------------------------- 
;;;
;;; SWEEPING DATA UNIVERSES
;;;

(defmacro collect-data-cache (universe accessor predicate &optional constraint)
  `(loop with best-data-cache and best-value and data-cache-value
         for data-cache being the hash-values in (data-universe-cache-table ,universe)
         ,@(when constraint
             (destructuring-bind (condition filter) constraint
                 `(,condition (,filter data-cache))))
         do (cond ((null best-data-cache)
                   (psetq best-data-cache data-cache
                          best-value (,accessor data-cache)))
                  ((,predicate (setq data-cache-value (,accessor data-cache)) best-value)
                   (psetq best-data-cache data-cache
                          best-value data-cache-value)))
         finally (return (values best-data-cache best-value))))

(define-generic data-universe-sweep-for-data-cache (universe case context)
  (:documentation "Finds the data cache satifying CASE in the data universe, UNIVERSE,
according to CONTEXT. The table below enumerates possible values.

              CASE                CONTEXT

        :MINIMUM-FREQUENCY      :CURRENT-WINDOW
        :MINIMUM-FREQUENCY      :CURRENT-WINDOW-WIRED
        :MINIMUM-FREQUENCY      :CURRENT-WINDOW-VOLATILE
        :MAXIMUM-FREQUENCY      :CURRENT-WINDOW
        :MAXIMUM-FREQUENCY      :CURRENT-WINDOW-WIRED
        :MAXIMUM-FREQUENCY      :CURRENT-WINDOW-VOLATILE
        :MINIMUM-FREQUENCY      :PREVIOUS-WINDOW
        :MINIMUM-FREQUENCY      :PREVIOUS-WINDOW-WIRED
        :MINIMUM-FREQUENCY      :PREVIOUS-WINDOW-VOLATILE
        :MAXIMUM-FREQUENCY      :PREVIOUS-WINDOW
        :MAXIMUM-FREQUENCY      :PREVIOUS-WINDOW-WIRED
        :MAXIMUM-FREQUENCY      :PREVIOUS-WINDOW-VOLATILE
        :LEAST-RECENT-ACCESS    :ALL
        :LEAST-RECENT-ACCESS    :WIRED
        :LEAST-RECENT-ACCESS    :VOLATILE
        :MOST-RECENT-ACCESS     :ALL
        :MOST-RECENT-ACCESS     :WIRED
        :MOST-RECENT-ACCESS     :VOLATILE
        :MINIMUM-SIZE           :ALL
        :MINIMUM-SIZE           :WIRED
        :MINIMUM-SIZE           :VOLATILE
        :MAXIMUM-SIZE           :ALL
        :MAXIMUM-SIZE           :WIRED
        :MAXIMUM-SIZE           :VOLATILE"))

(defmethod data-universe-sweep-for-data-cache ((universe data-universe-cache-mixin)
                                               (case (eql :minimum-frequency)) (context (eql :current-window)))
  (collect-data-cache universe data-cache-reference-count <))

(defmethod data-universe-sweep-for-data-cache ((universe data-universe-cache-mixin)
                                               (case (eql :minimum-frequency)) (context (eql :current-window-wired)))
  (collect-data-cache universe data-cache-reference-count < (when data-cache-wired-p)))

(defmethod data-universe-sweep-for-data-cache ((universe data-universe-cache-mixin)
                                               (case (eql :minimum-frequency)) (context (eql :current-window-volatile)))
  (collect-data-cache universe data-cache-reference-count < (unless data-cache-wired-p)))

(defmethod data-universe-sweep-for-data-cache ((universe data-universe-cache-mixin)
                                               (case (eql :maximum-frequency)) (context (eql :current-window)))
  (collect-data-cache universe data-cache-reference-count >))

(defmethod data-universe-sweep-for-data-cache ((universe data-universe-cache-mixin)
                                               (case (eql :maximum-frequency)) (context (eql :current-window-wired)))
 (collect-data-cache universe data-cache-reference-count > (when data-cache-wired-p)))

(defmethod data-universe-sweep-for-data-cache ((universe data-universe-cache-mixin)
                                               (case (eql :maximum-frequency)) (context (eql :current-window-volatile)))
  (collect-data-cache universe data-cache-reference-count > (unless data-cache-wired-p)))

(defmethod data-universe-sweep-for-data-cache ((universe data-universe-cache-mixin)
                                               (case (eql :minimum-frequency)) (context (eql :previous-window)))
  (collect-data-cache universe data-cache-previous-reference-count <))

(defmethod data-universe-sweep-for-data-cache ((universe data-universe-cache-mixin)
                                               (case (eql :minimum-frequency)) (context (eql :previous-window-wired)))
  (collect-data-cache universe data-cache-previous-reference-count < (when data-cache-wired-p)))

(defmethod data-universe-sweep-for-data-cache ((universe data-universe-cache-mixin)
                                               (case (eql :minimum-frequency)) (context (eql :previous-window-volatile)))
  (collect-data-cache universe data-cache-previous-reference-count < (unless data-cache-wired-p)))

(defmethod data-universe-sweep-for-data-cache ((universe data-universe-cache-mixin)
                                               (case (eql :maximum-frequency)) (context (eql :previous-window)))
  (collect-data-cache universe data-cache-previous-reference-count >))

(defmethod data-universe-sweep-for-data-cache ((universe data-universe-cache-mixin)
                                               (case (eql :maximum-frequency)) (context (eql :previous-window-wired)))
(collect-data-cache universe data-cache-previous-reference-count > (when data-cache-wired-p)))

(defmethod data-universe-sweep-for-data-cache ((universe data-universe-cache-mixin)
                                               (case (eql :maximum-frequency)) (context (eql :previous-window-volatile)))
 (collect-data-cache universe data-cache-previous-reference-count > (unless data-cache-wired-p)))

(defmethod data-universe-sweep-for-data-cache ((universe basic-data-universe)
                                               (case (eql :least-recent-access)) (context (eql :all)))
  (collect-data-cache universe data-cache-last-reference <))

(defmethod data-universe-sweep-for-data-cache ((universe basic-data-universe)
                                               (case (eql :least-recent-access)) (context (eql :wired)))
  (collect-data-cache universe data-cache-last-reference < (when data-cache-wired-p)))

(defmethod data-universe-sweep-for-data-cache ((universe basic-data-universe)
                                               (case (eql :least-recent-access)) (context (eql :volatile)))
  (collect-data-cache universe data-cache-last-reference < (unless data-cache-wired-p)))

(defmethod data-universe-sweep-for-data-cache ((universe basic-data-universe)
                                               (case (eql :most-recent-access)) (context (eql :all)))
  (collect-data-cache universe data-cache-last-reference >))

(defmethod data-universe-sweep-for-data-cache ((universe basic-data-universe)
                                               (case (eql :most-recent-access)) (context (eql :wired)))
 (collect-data-cache universe data-cache-last-reference > (when data-cache-wired-p)))

(defmethod data-universe-sweep-for-data-cache ((universe basic-data-universe)
                                               (case (eql :most-recent-access)) (context (eql :volatile)))
(collect-data-cache universe data-cache-last-reference > (unless data-cache-wired-p)))

(defmethod data-universe-sweep-for-data-cache ((universe basic-data-universe)
                                               (case (eql :minimum-size)) (context (eql :all)))
  (collect-data-cache universe data-cache-size <))

(defmethod data-universe-sweep-for-data-cache ((universe basic-data-universe)
                                               (case (eql :minimum-size)) (context (eql :wired)))
  (collect-data-cache universe data-cache-size < (when data-cache-wired-p)))

(defmethod data-universe-sweep-for-data-cache ((universe basic-data-universe)
                                               (case (eql :minimum-size)) (context (eql :volatile)))
 (collect-data-cache universe data-cache-size < (unless data-cache-wired-p)))

(defmethod data-universe-sweep-for-data-cache ((universe basic-data-universe)
                                               (case (eql :maximum-size)) (context (eql :all)))
 (collect-data-cache universe data-cache-size >))

(defmethod data-universe-sweep-for-data-cache ((universe basic-data-universe)
                                               (case (eql :maximum-size)) (context (eql :wired)))
 (collect-data-cache universe data-cache-size > (when data-cache-wired-p)))

(defmethod data-universe-sweep-for-data-cache ((universe basic-data-universe)
                                               (case (eql :maximum-size)) (context (eql :volatile)))
(collect-data-cache universe data-cache-size > (unless data-cache-wired-p)))


;;;------------------------------------------------------------------- 
;;;
;;; CACHE MIGRATION POLICY
;;;

(define-generic data-universe-advance-current-window (universe)
  (:documentation "Advances the window within which data source hit frequencies are compared."))

(defmethod data-universe-advance-current-window ((universe data-universe-cache-mixin))
  (with-slots (current-window window-frequency) universe
    (atomic-incf current-window window-frequency)))

(defmethod initialize-instance :after ((universe data-universe-cache-mixin) &key &allow-other-keys)
  (data-universe-advance-current-window universe)
  universe)


;;;------------------------------------------------------------------- 
;;;
;;; CACHING DATA AND WRITING FROM CACHE
;;;

(defmethod initialize-instance :after ((data-cache basic-data-cache) &key &allow-other-keys)
  (setf (data-cache-lock data-cache) (make-lock (data-cache-name data-cache)))
  data-cache)

(defmethod initialize-instance :before ((data-cache file-data-cache-mixin) &key pathname &allow-other-keys)
  (setf (data-cache-pathname data-cache) pathname)
  data-cache)

(define-generic data-cache-reset-revalidation-time (data-cache &optional universal-time)
  (:documentation "Resets the time when the cache should be revalidated."))

(defmethod data-cache-reset-revalidation-time ((data-cache basic-data-cache) &optional (universal-time (get-universal-time)))
  (setf (data-cache-revalidation-time data-cache) (+ universal-time (data-cache-revalidation-interval data-cache))))

(defmethod data-cache-name ((data-cache basic-data-cache))
  (symbol-name (type-of data-cache)))

(defmethod data-cache-name ((data-cache file-data-cache-mixin))
  (format nil "~A" (data-cache-pathname data-cache)))

(define-generic recache-data (data-cache &optional stream length)
  (declare (values data-array))
  (:documentation "Recaches the data in DATA-CACHE.
STREAM is an input stream to the data source.
LENGTH is number of bytes to read into the cache."))

(defmethod recache-data ((data-cache basic-data-cache) &optional stream length)
  (declare (values data-array))
  (let ((array (data-cache-array data-cache))
        (old-size (data-cache-size data-cache))
        offset)
    (unless (and array length (< length (array-total-size array)))
      (setq array nil))
    (prog1 (setf (data-cache-array data-cache) (binary-stream-copy-into-8-bit-array stream length 0 array))
           (unless (zerop (setq offset (- length old-size)))
             (data-universe-increment-total-cache-size (data-cache-universe data-cache) offset))
           (let ((ut (get-universal-time)))
             (setf (data-cache-size data-cache) length
                   (data-cache-update-time data-cache) ut)
             (data-cache-reset-revalidation-time data-cache ut)))))

(defmethod recache-data :around ((data-cache file-data-cache-mixin) &optional file-stream length)
  (multiple-value-prog1 (call-next-method data-cache file-stream (or length (file-length-in-bytes file-stream)))
    (setf (data-cache-last-modification data-cache) (file-stream-modification-date file-stream)
          (data-cache-version data-cache) (file-stream-version file-stream))))

(defmethod recache-data :around ((data-cache binary-file-data-cache) &optional source length)
  (with-open-file (file-stream (or source (data-cache-pathname data-cache))
                               :direction :input :element-type '(unsigned-byte 8))
    (call-next-method data-cache file-stream (or length (file-length file-stream)))))

(defmethod recache-data :around ((data-cache crlf-file-data-cache) &optional source length)
  (declare (ignore source))
  (ensure-crlf-canonical-file (data-cache-pathname data-cache))
  (call-next-method data-cache (data-cache-crlf-pathname data-cache) length))

(define-generic write-cache-data (data-cache stream &optional start end)
  (:documentation "Writes the contents of DATA-CACHE to STREAM
starting from START upto but not including END. This operation is
protected from other threads corrupting the cache by recaching during a write."))

(defmethod write-cache-data ((data-cache basic-data-cache) stream &optional (start 0) end)
  (with-data-cache-lock (data-cache :read)
    (binary-stream-copy-from-8-bit-array (data-cache-array data-cache) stream start end)))

(declaim (inline %valid-data-cache-p))

(defun %valid-data-cache-p (data-cache &optional last-modification)
  (and (data-cache-array data-cache)
       (if last-modification (< last-modification (data-cache-update-time data-cache)) t)))

(define-generic valid-data-cache-p (data-cache &optional last-modification)
  (:documentation "Returns non-null when the data in DATA-CACHE is valid.
If last-modification is provided, this returns non-null only if
the cache has been refreshed before last-modification. last-modification
is in universal time."))

(defmethod valid-data-cache-p ((data-cache basic-data-cache) &optional last-modification)
  (%valid-data-cache-p data-cache last-modification))

(define-generic recache-if-necessary (data-cache &optional last-modification access-time)
  (:documentation "When the cache becomes stale, this automatically recaches the data in DATA-CACHE."))

(defmethod recache-if-necessary ((data-cache basic-data-cache) &optional last-modification (access-time (get-universal-time))
                                 &aux revalidation-time)
  (unless last-modification
    ;; Check the last modification of the resource every revalidation interval.
    (when (and (setq revalidation-time (data-cache-revalidation-time data-cache))
               (< revalidation-time access-time))
      (data-cache-reset-revalidation-time data-cache access-time)       ;reset the revalidation time
      (setq last-modification (data-source-last-modification data-cache))))
  ;; Quick check for cache validity without locking
  (unless (valid-data-cache-p data-cache last-modification)
    (with-data-cache-lock (data-cache :write)
      ;; Check again with log grabbed in case another process already updated the cache.
      (unless (valid-data-cache-p data-cache last-modification)
        (recache-data data-cache)))))

(define-generic data-source-last-modification (data-cache)
  (:documentation "Returns the universal time when the data source was last modified."))

(defmethod data-source-last-modification ((data-cache file-data-cache-mixin))
  (file-modification-date (data-cache-pathname data-cache)))

(defmethod ensure-current-data ((data-cache basic-data-cache))
  (recache-if-necessary data-cache))

;; This could open the file three times to recache, but if no change
;; dominates, it only touches the the disk once.   3/19/98 -- JCMa.
(defmethod ensure-current-data ((data-cache file-data-cache-mixin))
  (recache-if-necessary data-cache (data-source-last-modification data-cache)))

(define-generic note-data-access (universe auditor &optional access-time)
  (:documentation "Records the data access."))

(defmethod note-data-access ((universe basic-data-universe) (auditor data-auditor) &optional (access-time (get-universal-time)))
  (with-slots (reference-count last-reference) auditor
    (let ((cache-window (current-cache-window universe)))
      (setf last-reference access-time)
      (if (eql cache-window (current-cache-window auditor))
          (atomic-incf reference-count)
          (setf (current-cache-window auditor) cache-window
                (%data-auditor-reference-count auditor) 1))
      auditor)))

(defmethod note-data-access ((universe basic-data-universe) (data-cache basic-data-cache) &optional (access-time (get-universal-time)))
  (with-slots (reference-count last-reference) data-cache
    (let ((cache-window (current-cache-window universe)))
      (setf last-reference access-time)
      (if (eql cache-window (current-cache-window data-cache))
          (atomic-incf reference-count)
          (setf (current-cache-window data-cache) cache-window
                (data-cache-previous-reference-count data-cache) (data-cache-reference-count data-cache)
                (data-cache-reference-count data-cache) 1))
      data-cache)))

(defmethod note-data-access :after ((universe data-universe-cache-mixin) (data-cache data-cache-cache--mixin)
                                    &optional access-time)
  (declare (ignore access-time))
  (with-slots (minimum-frequency-data-cache) universe
    (flet ((swap-data-cache-p (data-cache1 data-cache2)
             (or (null data-cache1)
                 (< (data-cache-reference-count data-cache1) (data-cache-reference-count data-cache2)))))
      (unless (data-cache-wired-p data-cache)
        (www-utils::atomic-conditional-replacef minimum-frequency-data-cache #'swap-data-cache-p data-cache))
      data-cache)))

(define-macro with-data-cache ((pathname &key last-modification (variable 'data-cache)) form &body body)
  "When PATHNAME has an in-memory data cache, FORM is evaluated instead of BODY,
which handles the normal uncached case. When LAST-MODIFICATION is provided, data cached before LAST-MODIFICATION
is recached. LAST-MODIFICATION is in universal time."
  `(let ((,variable (access-pathname-data ,pathname ,last-modification (server-request-time *server*))))
     (cond (,variable ,form)
	   (t . ,body))))

(define-generic data-cache-note-reference (data-cache)
  (:documentation "Atomically notes each reference to DATA-CACHE."))

(defmethod data-cache-note-reference ((data-cache basic-data-cache))
  (with-slots (reference-count) data-cache
    (atomic-incf reference-count)))

(define-generic data-cache-reset-reference-count (data-cache))

(defmethod data-cache-reset-reference-count ((data-cache basic-data-cache))
  (with-slots (reference-count) data-cache
    (setf reference-count 0)))
)

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;UTILS.LISP.356")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-common-lisp; Package: HTTP; Base: 10; Mode: lisp -*-")

;;;------------------------------------------------------------------- 
;;;
;;; COPYING BYTES
;;;

(define byte-range-parameters (start last resource-length)
  "Returns values suitable for returning a resource range.
START and LAST are the positions of the first and last bytes.
The logic is defined by the HTTP 1.1 spec in the section discussing ranges.
Ports and applications may specialize this method to optimize data transfer rates."
  (declare (values start end content-length))
  (cond ((and start last)
         (values start (1+ last) (- (1+ last) start)))
        (start
         (values start resource-length (- resource-length start)))
        (last
         (values (- resource-length last) resource-length last))
        (t (error "No byte range was specfied."))))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SERVER.LISP.739")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Syntax: ANSI-Common-Lisp; Package: http; Base: 10 -*-")

;;;------------------------------------------------------------------- 
;;;
;;; WRITING BINARY FORMATS
;;;

;; Only handle a single range spec until chunking content transfer available
;; to ship over the mime multipart ranges.  6/25/96 -- JCMa.
(defmacro %writing-binary-file ((stream url content-type resource-length last-modification version &key charset)
                                range-copy-form copy-form)
  `(let ((expires (expiration-universal-time ,url)))
     (handling-conditional-get (stream :last-modification ,last-modification :character-set ,charset
                                       :entity-tag ,version :expires expires :termination-line-p t)
       (let ((cache-control (url:response-cache-control-directives ,url))
             (languages (languages ,url))
             (range (get-header :range)))
         ;; if more than one range, send whole resource for now.  6/25/96 -- JCMa.
         (cond ((and range (null (cddr range))) ;; Send a byte range
                (destructuring-bind (start-byte last-byte) (second range)
                  (multiple-value-bind (start end content-length) 
                      (byte-range-parameters start-byte last-byte ,resource-length)
                    (let ((headers `(:content-range (:bytes ,start ,end ,content-length))))
                      (declare (dynamic-extent headers))
                      (with-successful-response (,stream content-type :status :partial-content :bytes content-length
                                                 :last-modification ,last-modification
                                                 :character-set ,charset
                                                 :entity-tag ,version :expires expires :cache-control cache-control
                                                 :content-location ,url
                                                 :content-language languages
                                                 :additional-mime-headers headers
                                                 :termination-line-p t)
                        ,range-copy-form)))))
               ;; Send the full content
               (t (with-successful-response (,stream ,content-type :status :success :bytes ,resource-length
                                             :last-modification ,last-modification
                                             :character-set ,charset
                                             :entity-tag ,version :expires expires :cache-control cache-control
                                             :content-location ,url
                                             :content-language languages
                                             :termination-line-p t)
                    ,copy-form)))))))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SERVER.LISP.739")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Syntax: ANSI-Common-Lisp; Package: http; Base: 10 -*-")

(defun %%write-binary-file (pathname url content-type stream &optional charset last-modification version)
  (with-open-file (file-stream pathname :direction :input :element-type '(unsigned-byte 8))
    (let ((resource-length (file-stream-length-in-bytes file-stream)))
      (unless-every
        (last-modification (setq last-modification (file-stream-modification-date file-stream)))
        (version (setq version (file-stream-version file-stream))))
      (%writing-binary-file
        (stream url content-type resource-length last-modification version :charset charset)
        (stream-copy-byte-range file-stream stream start end)
        (stream-copy-until-eof file-stream stream :binary)))))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SERVER.LISP.739")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Syntax: ANSI-Common-Lisp; Package: http; Base: 10 -*-")

(PROGN
(declaim (notinline %write-document-crlf-from-pathname))

(defun %write-document-crlf-from-pathname (url pathname content-type stream &optional charset last-modification version)
  (with-data-cache (pathname :last-modification last-modification)
                   (%%caching-write-binary-file data-cache url content-type stream charset last-modification version)
    (let ((crlf-pathname (ensure-crlf-canonical-file pathname)))
      (%%write-binary-file crlf-pathname url content-type stream charset last-modification version))))
)

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SERVER.LISP.739")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Syntax: ANSI-Common-Lisp; Package: http; Base: 10 -*-")

(PROGN
(declaim (notinline %write-binary-file-from-pathname))

(defun %write-binary-file-from-pathname (url pathname content-type stream &optional charset last-modification version)
  (with-data-cache (pathname :last-modification last-modification)
                   (%%caching-write-binary-file data-cache url content-type stream charset last-modification version)
    (%%write-binary-file pathname url content-type stream charset last-modification version)))
)

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SERVER.LISP.739")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Syntax: ANSI-Common-Lisp; Package: http; Base: 10 -*-")

(PROGN
(declaim (notinline %write-binary-file))

(defun %write-binary-file (url content-type stream &optional charset last-modification version)
  (let ((pathname (url:translated-pathname url)))
    (if pathname
        (handler-case
          (%write-binary-file-from-pathname url pathname content-type stream charset last-modification version)
          (file-not-found () (error 'document-not-found :url url)))
        (error 'document-not-found :url url))))
)

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SERVER.LISP.739")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Syntax: ANSI-Common-Lisp; Package: http; Base: 10 -*-")

(PROGN
(declaim (notinline %write-crlf-file))

(defun %write-crlf-file (url content-type stream &optional charset)
  (let ((pathname (url:translated-pathname url)))
    (cond
      (pathname
       (handler-case
         (%write-document-crlf-from-pathname url pathname content-type stream charset)
         (file-not-found () (error 'document-not-found :url url))))
      (t (error 'document-not-found :url url)))))
)

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SERVER.LISP.739")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Syntax: ANSI-Common-Lisp; Package: http; Base: 10 -*-")

(define write-any-document-from-pathname (url pathname stream &optional (content-type nil content-type-supplied-p)
                                              charset)
  "Writes any content type from a PATHNAME for URL on STREAM.
CONTENT-TYPE and CHARSET should be supplied, but will default by guessing from pathname."
  (cond (content-type-supplied-p
         (etypecase content-type
           (keyword (setq content-type (mime-content-type-spec content-type)))
           (cons)))
        (t (setq content-type (mime-content-type-spec pathname))))
  ;; content-type needs to be expanded before calling copy mode.
  (ecase (mime-content-type-copy-mode content-type)
    (:text
      (%write-document-from-pathname url pathname content-type stream charset))
    (:crlf
      (%write-document-crlf-from-pathname url pathname content-type stream charset))
    (:binary (%%write-binary-file pathname url content-type stream charset))))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SERVER.LISP.739")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Syntax: ANSI-Common-Lisp; Package: http; Base: 10 -*-")

(PROGN
(defmacro %writing-write-binary-range ((stream url content-type last-modification version 
                                               &key charset start end)
                                       range-copy-form)
  `(let ((expires (expiration-universal-time ,url)))
     (handling-conditional-get (,stream :last-modification ,last-modification :character-set ,charset
                                :entity-tag ,version :expires expires :termination-line-p t)
       ;; Send a byte range
       (with-successful-response (,stream ,content-type :status :success :bytes (- ,end ,start)
                                  :last-modification ,last-modification
                                  :character-set ,charset
                                  :entity-tag ,version :expires expires
                                  :cache-control (url:response-cache-control-directives ,url)
                                  :content-location ,url
                                  :content-language (languages ,url)
                                  :termination-line-p t)
         ,range-copy-form))))

(defun %%write-binary-range (url pathname content-type stream start end &optional charset last-modification version)
  (with-open-file (file-stream pathname :direction :input :element-type '(unsigned-byte 8))
    (unless-every
      (last-modification (setq last-modification (file-stream-modification-date file-stream)))
      (version (setq version (file-stream-version file-stream))))
    (%writing-write-binary-range
      (stream url content-type last-modification version :charset charset :start start :end end)
      (stream-copy-byte-range file-stream stream start end))))

(defun %%caching-write-binary-file (data-cache url content-type stream &optional charset last-modification version)
  (let ((resource-length (data-cache-size data-cache)))
    (unless-every
      (last-modification (setq last-modification (data-cache-last-modification data-cache)))
      (version (setq version (data-cache-version data-cache))))
    (%writing-binary-file
      (stream url content-type resource-length last-modification version :charset charset)
      (with-binary-stream (stream :output)
        (write-cache-data data-cache stream start end))
      (with-binary-stream (stream :output)
        (write-cache-data data-cache stream 0 resource-length)))
    (data-cache-note-reference data-cache)))

(defun %%caching-write-binary-range (data-cache url content-type stream start end &optional charset last-modification version)
  (unless-every
    (last-modification (setq last-modification (data-cache-last-modification data-cache)))
    (version (setq version (data-cache-version data-cache))))
  (%writing-write-binary-range
    (stream url content-type last-modification version :charset charset :start start :end end)
    (binary-stream-copy-from-8-bit-array (data-cache-array data-cache) stream start end)))

(declaim (notinline %write-document-crlf-range-from-pathname))

(defun %write-document-crlf-range-from-pathname (url pathname content-type stream start end 
                                                     &optional charset last-modification version)
  (with-data-cache
    (pathname :last-modification last-modification)
    (%%caching-write-binary-range data-cache url content-type stream start end charset last-modification version)
    (let ((crlf-pathname (ensure-crlf-canonical-file pathname)))
      (%%write-binary-range url crlf-pathname content-type stream start end charset last-modification version))))
)

;========================
(SCT:BEGIN-PATCH-SECTION)
; From buffer data-cache.lisp >http>server W: (66)
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-Common-Lisp; Base: 10; Mode: lisp; Package: HTTP -*-")

(mapc #'(lambda (x) (export (intern x :http) :http))
      '("*DATA-CACHE-WINDOW-FREQUENCY*"
	"*DATA-UNIVERSE-MAXIMUM-CACHE-ELEMENTS*"
	"*DATA-UNIVERSE-MAXIMUM-CACHE-SIZE*"
	"*DATA-UNIVERSE-REVALIDATION-INTERVAL*"
	"CACHE-DATA"
	"CLEAR-DATA-UNIVERSE"
	"DEFINE-CACHED-DATA"
	"ENSURE-CURRENT-DATA"
	"INTERN-DATA-UNIVERSE"
	"RECACHE-DATA-CACHE"
	"RECACHE-DATA-UNIVERSE"
	"REMOVE-DATA-CACHE"
	"STANDARD-DATA-UNIVERSE"
	"UNINTERN-DATA-UNIVERSE"
	"WITH-DATA-UNIVERSE"))

;========================
(SCT:BEGIN-PATCH-SECTION)
; From buffer data-cache.lisp >http>server W: (67)
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-Common-Lisp; Base: 10; Mode: lisp; Package: HTTP -*-")

(defmethod cache-data ((universe basic-data-universe) (data-sources null) &rest args)
  (declare (dynamic-extent args)
	   (ignore args))
  (intern-data-universe universe))

;========================
(SCT:BEGIN-PATCH-SECTION)
; From buffer data-cache.lisp >http>server W: (67)
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-Common-Lisp; Base: 10; Mode: lisp; Package: HTTP -*-")

(defmethod note-data-access ((universe file-data-universe) (datum pathname) &optional (access-time (get-universal-time)))
  (let ((auditor (get-pathname-data-auditor datum)))
    (cond (auditor
           (note-data-access universe auditor access-time))
          (t (setq auditor (make-instance 'data-auditor
					  :universe universe :datum datum
					  :window (current-cache-window universe)
					  :reference-count 1 :last-reference access-time))
	     (register-data universe auditor)))))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SERVER.LISP.739")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Syntax: ANSI-Common-Lisp; Package: http; Base: 10 -*-")

;;;------------------------------------------------------------------- 
;;;
;;;  STATIC FILE EXPORT-TYPE, PLUS METHODS FOR :GET AND :HEAD
;;;

;; IANA maintains a list of assigned content types per RFC 1590 that can be found at
;;; ftp://ftp.isi.edu/in-notes/iana/assignments/media-types/media-types

(define-url-export-types
  (:html-file :html (:text :html :charset :iso-8859-1)
              :copy-mode #.+standard-text-copy-mode+ :data-type :html :alternate-extensions (:htm))
  (:shtml-file :shtml (:text :html :charset :iso-8859-1)
               :copy-mode #.+standard-text-copy-mode+ :data-type :html :alternate-extensions (:stm)
               :url-class url:http-template-object :no-methods (:header :document))
  (:text-file :text (:text :plain :charset :iso-8859-1) :copy-mode #.+standard-text-copy-mode+
              :alternate-extensions (:txt :lisp :c :h :script))
  (:lisp-file :lisp (:text :plain :charset :iso-8859-1) :copy-mode #.+standard-text-copy-mode+
              :alternate-extensions (:lsp) :data-type :lisp)
  (:gif-image :gif (:image :gif) :copy-mode :binary)
  (:png-image :png (:image :png) :copy-mode :binary)
  (:x-bitmap-image :xbm (:image :x-xbitmap) :copy-mode #.+standard-text-copy-mode+)
  (:jpeg-image :jpeg (:image :jpeg) :copy-mode :binary 
               :alternate-extensions (:jpe :jpg))
  (:pict-image :pict (:image :pict) :copy-mode :binary :alternate-extensions (:pic))
  (:tiff-image :tiff (:image :tiff) :copy-mode :binary
               :alternate-extensions (:tif))
  (:basic-audio :au (:audio :basic):copy-mode :binary
                :alternate-extensions (:snd))
  (:aiff-audio :aiff (:audio :aiff) :copy-mode :binary :alternate-extensions (:aif))
  (:wav-audio :wav (:audio :x-wav) :copy-mode :binary)
  (:real-audio :ram (:audio :x-pn-realaudio) :copy-mode :binary :alternate-extensions (:ra))
  (:mpeg-video :mpeg (:video :mpeg) :copy-mode :binary
               :alternate-extensions (:mpe :mpg))
  (:quicktime-video :qt (:video :quicktime) :copy-mode :binary
                    :alternate-extensions (:mov :moov))
  (:pdf-file :pdf (:application :pdf) :copy-mode :binary)
  (:postscript-file :ps (:application :postscript) :copy-mode #.+standard-text-copy-mode+
                    :alternate-extensions (:eps :epsf))
  ;;  MAC related
  (:talk-file :talk (:plugin :talker) :copy-mode #.+standard-text-copy-mode+ :data-type :audio) ;obsolete
  (:talk-audio :talk (:plugin :talker) :copy-mode #.+standard-text-copy-mode+ :data-type :audio)
  (:binhex-file :hqx (:application :mac-binhex40):copy-mode #.+standard-text-copy-mode+)
  (:stuffit-file :sit (:application :x-stuffit) :copy-mode :binary)
  (:mac-binary-file :macbin (:application :x-macbinary) :copy-mode :binary
                    #+mac-cl-http :alternate-extensions #+mac-cl-http(:bin))
  (:compressed-file :zip (:application :x-compressed) :copy-mode :binary
                    :alternate-extensions (:z :gz :tgz))
  (:shockwave-file :dir (:application :x-director) :copy-mode :binary :alternate-extensions (:dcr))
  ;; PC related
  (:executable-file :exe (:application :octet-stream) :copy-mode :binary)
  (:rtf-file :rtf (:text :richtext) :copy-mode #.+standard-text-copy-mode+)
  (:word-file :word (:application :msword) :copy-mode :binary :alternate-extensions (:doc))
  (:power-point-file :ppt (:application :msppt) :copy-mode :binary)
  (:excel-file :xl (:application :excel) :copy-mode :binary)
  ;; Java related
  (:java-file :java (:text :plain :charset :iso-8859-1) :copy-mode #.+standard-text-copy-mode+ :data-type :text)
  (:java-binary :class (:application :x-java-binary) :copy-mode :binary)
  (:java-script-file :javascript (:text :plain :charset :iso-8859-1) :copy-mode #.+standard-text-copy-mode+ :data-type :text)
  ;; VRML related
  (:vrml-world :vrml (:x-world :x-vrml) :copy-mode #.+standard-text-copy-mode+ :data-type :world :alternate-extensions (:wrl))
  ;; Apple QuickDraw3D Meta File format
  (:3dmf-world :3dmf (:x-world :x-3dmf) :copy-mode :binary :data-type :world :alternate-extensions (:3dm :qd3d :qd3))
  ;; Apple Meta Content Format file
  (:mcf-file :mcf (:image :vasa) :copy-mode #.+standard-text-copy-mode+)
  ;; Research related
  (:lisp-sexp-file :sexp (:application :lisp-sexp) :copy-mode #.+standard-text-copy-mode+ :data-type :text)
  ;; URN Resolution Format
  (:uri-file :uri (:text :uri-list) :copy-mode #.+standard-text-copy-mode+ :data-type :text)
  ;; http message= request|response & http-headers & message-body RFC 2068
  (:http-message-file :http (:message :http) :copy-mode :binary)
  ;; SMTP message headers & message-body RFC 1521
  (:smtp-message-file :msg (:message :rfc822) :copy-mode :text)
  ;; NNTP Message headers & message-body RFC 1026
  (:nntp-message-file :news (:message :news) :copy-mode :text))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SERVER.LISP.739")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Syntax: ANSI-Common-Lisp; Package: http; Base: 10 -*-")

(define-standard-directory-export-types (:html :text :lisp :image :audio :video :application :world))

;========================
(SCT:BEGIN-PATCH-SECTION)
; From buffer data-cache.lisp >http>server W: (67)
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-Common-Lisp; Base: 10; Mode: lisp; Package: HTTP -*-")

(defparameter *data-universe-audit-accesses* nil
  "The default value for whether data elements are audited by new data universes.")


;========================
(SCT:BEGIN-PATCH-SECTION)
; From buffer data-cache.lisp >http>server W: (67)
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-Common-Lisp; Base: 10; Mode: lisp; Package: HTTP -*-")

(defclass basic-data-universe
          (data-universe-cache-mixin)
    ((name :initform nil :initarg :name :accessor data-universe-name)
     (cache :initform nil :initarg :cache :accessor data-universe-cache-table)
     (cache-size :initform *data-universe-maximum-cache-elements* :initarg :cache-size :accessor data-universe-cache-table-size)
     (total-cache-size :initform 0 :initarg :total-cache-size :accessor data-universe-total-cache-size)
     (cached-elements :initform 0 :initarg :cached-elements :accessor data-universe-cached-elements)
     (revalidation-interval :initform *data-universe-revalidation-interval* :initarg :revalidation-interval
                            :accessor data-universe-revalidation-interval)
     (maximum-cache-size :initform *data-universe-maximum-cache-size* :initarg :maximum-cache-size
                         :accessor data-universe-maximum-cache-size)
     (maximum-cache-elements :initform *data-universe-maximum-cache-elements* :initarg :maximum-cache-elements
			     :accessor data-universe-maximum-cache-elements)
     (audit-access-p :initform *data-universe-audit-accesses* :initarg audit-access-p :accessor data-universe-audit-access-p)
     (auditor-table :initform nil :initarg auditor-table :accessor data-universe-auditor-table)
     (auditor-table-size :initform *data-universe-audited-elements* :initarg :auditor-table-size
			 :accessor data-universe-auditor-table-size)))


;========================
(SCT:BEGIN-PATCH-SECTION)
; From buffer data-cache.lisp >http>server W: (67)
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-Common-Lisp; Base: 10; Mode: lisp; Package: HTTP -*-")

(defun access-pathname-data (pathname &optional last-modification (access-time (get-universal-time)) &aux universe)
  "Returns the data-cache object or null if pathname is not in the cache."
  (declare (values data-cache-or-null))
  (when (setq universe *standard-data-universe*)
    (let ((data-cache (get-pathname-data-cache pathname)))
      (cond (data-cache
	     (recache-if-necessary data-cache last-modification access-time)
	     (note-data-access (data-cache-universe data-cache) data-cache access-time)
	     data-cache)
	    ((data-universe-audit-access-p universe)
	     (note-data-access universe pathname access-time)
	     nil)
	    (t nil)))))


;========================
(SCT:BEGIN-PATCH-SECTION)
; From buffer data-cache.lisp >http>server W: (67)
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-Common-Lisp; Base: 10; Mode: lisp; Package: HTTP -*-")

(define-macro define-cached-data ((data-universe &key (clear-data-universe-p t)
						 (audit-access-p '*data-universe-audit-accesses*)
						 (data-universe-class ''file-data-universe)) &rest data-sources)
  "Defines DATA-SOURCES as the initial data cached in DATA-UNIVERSE.
CLEAR-DATA-UNIVERSE-P controls whether existing universes are cleared
before the new data is cached. AUDIT-ACCESS-P controls whether
the universe tracks accesses of uncached data."

  `(multiple-value-bind (universe new-p)
       (intern-data-universe ,(string data-universe) :if-does-not-exist :create :class ,data-universe-class)
     ,(if clear-data-universe-p
          `(unless new-p
             (clear-data-universe universe))
          'new-p)
     (setf (data-universe-audit-access-p universe) ,audit-access-p)
     (cache-data universe ',data-sources)
     universe))

