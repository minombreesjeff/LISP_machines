;;; -*- Mode: lisp; Syntax: ansi-common-lisp; Base: 10; Package: http; Patch-File: t -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; Patch file for CL-HTTP version 67.13
;;; Reason: Add a bunch of fixes and install Server-Parsed HTML.
;;; 
;;; Function HTTP:ENSURE-CRLF-CANONICAL-FILE:  update docs for new second value, newly-updated-p.
;;; Function (CLOS:METHOD HTTP:ENSURE-CRLF-CANONICAL-FILE (T)):  implement.
;;; Function (CLOS:METHOD HTTP:ENSURE-CRLF-CANONICAL-FILE (LISP:PATHNAME)):  implement for lisp.
;;; Function (CLOS:METHOD HTTP:ENSURE-CRLF-CANONICAL-FILE (STRING)):  always call the specialized version.
;;; CLOS class URL::TEMPLATE-MIXIN:  new mixin.
;;; CLOS class URL::HTTP-TEMPLATE-OBJECT:  new.
;;; Function URL::PARSE-TEMPLATE:  new.
;;; Function HTTP::SHOW-PREFERENCES:  fix declaration.
;;; Function HTTP::CONCATENATE-LINES:  fix declaration.
;;; Function NS11::%NOTE-IMAGE:  fix declaration.
;;; Function WWW-UTILS:WITH-BINARY-STREAM:  fix up documentation.
;;; Function WWW-UTILS::WITH-TEXT-STREAM:  new.
;;; Function (CLOS:METHOD HTTP::INITIALIZE-LOG-FILENAME (HTTP::FILE-LOGGING-MIXIN)):  martinize.
;;; Add :shtml-file export type.
;;; Function (CLOS:METHOD URL:INITIALIZE-SPECIALIZATION (url::http-template-object T T)):  new.
;;; Function (CLOS:METHOD HTTP:EXPORT-URL (URL:HTTP-MINIMUM-OBJECT (EQL :SHTML-FILE)) :AFTER):  -
;;; Function (CLOS:METHOD HTTP:WRITE-DOCUMENT-HEADERS (url::http-template-object (EQL :SHTML-FILE) T)):  -
;;; Function (CLOS:METHOD HTTP:WRITE-DOCUMENT (url::http-template-object (EQL :SHTML-FILE) T)):  -
;;; Function (CLOS:METHOD URL::PARSE-TEMPLATE (T (EQL :SHTML))):  define for lispm.
;;; Written by JCMa, 11/02/97 17:49:24
;;; while running on Lispm Machine Thomas Jefferson from FEP0:>ComLink-38-69-HTTP-67-A-MIT-8-5.ilod.1
;;; with Genera 8.5, Experimental IP-TCP Documentation 422.0, NFS Server 439.0,
;;; Mailer 438.0, Print Spooler 439.0, Domain Name Server 436.0,
;;; Experimental Lock Simple 435.1, Compare Merge 404.0, VC Documentation 401.0,
;;; Logical Pathnames Translation Files NEWEST, Experimental Conversion Tools 436.0,
;;; Metering 444.0, Metering Substrate 444.0, Hacks 440.0, CLIM 72.0,
;;; Genera CLIM 72.0, PostScript CLIM 72.0, Experimental CLIM Documentation 71.27,
;;; Statice Runtime 466.0, Statice 466.0, Statice Browser 466.0,
;;; Statice Server 466.0, 8-5-Patches 1.1, MAC 413.0, Showable Procedures 36.3,
;;; Binary Tree 34.0, Working LispM Mailer 7.0, HTTP Server 67.12,
;;; W3 Presentation System 7.0, CL-HTTP Server Interface 52.0,
;;; Symbolics Common Lisp Compatibility 3.0, Comlink Packages 5.0,
;;; Comlink Utilities 9.38, COMLINK Cryptography 1.0, Routing Taxonomy 8.2,
;;; COMLINK Database 10.87, Email Servers 11.18,
;;; Comlink Customized LispM Mailer 6.14, Dynamic Forms 12.16,
;;; Communications Linker Server 38.70,
;;; Experimental Lambda Information Retrieval System 12.24, Jcma 41,
;;; HTTP Proxy Server 2.2, HTTP Client Substrate 1.4, Ivory Revision 4A, IFEP 328,
;;; FEP0:>I328-loaders.flod(24), FEP0:>I328-info.flod(24), FEP0:>I328-debug.flod(24),
;;; FEP0:>I328-lisp.flod(25), FEP0:>I328-kernel.fep(44), Boot ROM version 320,
;;; Device PROM version 325, Genera application 5.6.1a1,
;;; MacIvory SCSI Manager Server 4.3.2a1, Toolbox Servers 4.2,
;;; MacIvory & RPC library 6.3.4a1, MacIvory life support 4.3.8a1,
;;; Symbolics keyboard 2.1.1a1, Macintosh System Software 8.0,
;;; 1152x820 Screen with Genera fonts, Machine serial number 30376,
;;; Macintosh Quadra 800, Symbolics Keyboard,
;;; Add support for Apple's Gestalt and Speech Managers. (from SYS:MAC;MACIVORY-SPEECH-SUPPORT.LISP.1),
;;; Domain Fixes (from CML:MAILER;DOMAIN-FIXES.LISP.33),
;;; Don't force in the mail-x host (from CML:MAILER;MAILBOX-FORMAT.LISP.23),
;;; Make Mailer More Robust (from CML:MAILER;MAILER-FIXES.LISP.15),
;;; Patch TCP hang on close when client drops connection. (from HTTP:LISPM;SERVER;TCP-PATCH-HANG-ON-CLOSE.LISP.10),
;;; Add CLIM presentation and text style format directives. (from FV:SCLC;FORMAT.LISP.20),
;;; Deny some hosts access to some servers. (from CML:LISPM;HOST-SERVICE-ACCESS-CONTROL.LISP.4),
;;; Fix Statice Lossage (from CML:LISPM;STATICE-PATCH.LISP.3),
;;; COMLINK Mailer Patches. (from CML:LISPM;MAILER-PATCH.LISP.102),
;;; Clim patches (from CML:DYNAMIC-FORMS;CLIM-PATCHES.LISP.48).

;;; Patch file for CL-HTTP version 67.13
;;; Written by JCMa, 11/04/97 22:59:40
;;; while running on Lispm Machine Thomas Jefferson from FEP0:>ComLink-38-69-HTTP-67-A-MIT-8-5.ilod.1
;;; with Genera 8.5, Experimental IP-TCP Documentation 422.0, NFS Server 439.0,
;;; Mailer 438.0, Print Spooler 439.0, Domain Name Server 436.0,
;;; Experimental Lock Simple 435.1, Compare Merge 404.0, VC Documentation 401.0,
;;; Logical Pathnames Translation Files NEWEST, Experimental Conversion Tools 436.0,
;;; Metering 444.0, Metering Substrate 444.0, Hacks 440.0, CLIM 72.0,
;;; Genera CLIM 72.0, PostScript CLIM 72.0, Experimental CLIM Documentation 71.27,
;;; Statice Runtime 466.0, Statice 466.0, Statice Browser 466.0,
;;; Statice Server 466.0, 8-5-Patches 1.1, MAC 413.0, Showable Procedures 36.3,
;;; Binary Tree 34.0, Working LispM Mailer 7.0, HTTP Server 67.13,
;;; W3 Presentation System 7.0, CL-HTTP Server Interface 52.0,
;;; Symbolics Common Lisp Compatibility 3.0, Comlink Packages 5.0,
;;; Comlink Utilities 9.38, COMLINK Cryptography 1.0, Routing Taxonomy 8.2,
;;; COMLINK Database 10.87, Email Servers 11.18,
;;; Comlink Customized LispM Mailer 6.14, Dynamic Forms 12.16,
;;; Communications Linker Server 38.70,
;;; Experimental Lambda Information Retrieval System 12.24, Jcma 41,
;;; Ivory Revision 4A, IFEP 328, FEP0:>I328-loaders.flod(24),
;;; FEP0:>I328-info.flod(24), FEP0:>I328-debug.flod(24), FEP0:>I328-lisp.flod(25),
;;; FEP0:>I328-kernel.fep(44), Boot ROM version 320, Device PROM version 325,
;;; Genera application 5.6.1a1, MacIvory SCSI Manager Server 4.3.2a1,
;;; Toolbox Servers 4.2, MacIvory & RPC library 6.3.4a1,
;;; MacIvory life support 4.3.8a1, Symbolics keyboard 2.1.1a1,
;;; Macintosh System Software 8.0, 1152x820 Screen with Genera fonts,
;;; Machine serial number 30376, Macintosh Quadra 800, Symbolics Keyboard,
;;; Add support for Apple's Gestalt and Speech Managers. (from SYS:MAC;MACIVORY-SPEECH-SUPPORT.LISP.1),
;;; Domain Fixes (from CML:MAILER;DOMAIN-FIXES.LISP.33),
;;; Don't force in the mail-x host (from CML:MAILER;MAILBOX-FORMAT.LISP.23),
;;; Make Mailer More Robust (from CML:MAILER;MAILER-FIXES.LISP.15),
;;; Patch TCP hang on close when client drops connection. (from HTTP:LISPM;SERVER;TCP-PATCH-HANG-ON-CLOSE.LISP.10),
;;; Add CLIM presentation and text style format directives. (from FV:SCLC;FORMAT.LISP.20),
;;; Deny some hosts access to some servers. (from CML:LISPM;HOST-SERVICE-ACCESS-CONTROL.LISP.4),
;;; Fix Statice Lossage (from CML:LISPM;STATICE-PATCH.LISP.3),
;;; COMLINK Mailer Patches. (from CML:LISPM;MAILER-PATCH.LISP.102),
;;; Clim patches (from CML:DYNAMIC-FORMS;CLIM-PATCHES.LISP.48).


(SCT:FILES-PATCHED-IN-THIS-PATCH-FILE 
  "HTTP:LISPM;SERVER;LISPM.LISP.347"
  "HTTP:SERVER;UTILS.LISP.340"
  "HTTP:SERVER;URL-CLASS.LISP.5"
  "HTTP:SERVER;WEB-CONFIGURATION.LISP.37"
  "HTTP:SERVER;UTILS.LISP.341"
  "HTTP:SERVER;NETSCAPE-1-1.LISP.126"
  "HTTP:SERVER;SERVER.LISP.696"
  "HTTP:LISPM;SERVER;LISPM.LISP.349"
  "HTTP:LISPM;SERVER;LISPM.LISP.350"
  "HTTP:SERVER;LOG.LISP.160"
  "HTTP:SERVER;PLIST.LISP.26"
  "HTTP:SERVER;URL.LISP.300"
  "HTTP:SERVER;URL.LISP.302"
  "HTTP:LISPM;SERVER;LISPM.LISP.352"
  "HTTP:SERVER;SERVER.LISP.698"
  "HTTP:SERVER;URL.LISP.303"
  "HTTP:LISPM;SERVER;LISPM.LISP.354"
  "HTTP:LISPM;SERVER;LISPM.LISP.355"
  "HTTP:LISPM;SERVER;PATCH;CL-HTTP-67;CL-HTTP-67-13.LISP.21"
  "HTTP:SERVER;URL.LISP.304"
  "HTTP:SERVER;URL.LISP.305"
  "HTTP:SERVER;URL.LISP.306"
  "HTTP:SERVER;SHTML.LISP.4")


(eval-when (load compile eval)
  (mapc #'(lambda (x)
	    (export (intern x :url) :url))
	'("HTTP-TEMPLATE-OBJECT" "TEMPLATE-PARAMETERS" "TEMPLATE-UPDATE-TIME" "PARSE-TEMPLATE"
	  "CLEAR-TEMPLATE-CACHE" "CLEAR-ALL-TEMPLATE-CACHES"))

  (mapc #'(lambda (x)
	    (export (intern x :www-utils) :www-utils))
	'("WITH-TEXT-STREAM"))

  (mapc #'(lambda (x)
	    (export (intern x :http) :http))
	'("DEFINE-SHTML-ACTION" "PARSE-SHTML-TEMPLATE")))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;UTILS.LISP.340")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-common-lisp; Package: HTTP; Base: 10; Mode: lisp -*-")

(define-generic ensure-crlf-canonical-file (pathname)
  (declare (values crlf-canonicalized-pathname newly-updated-p))
  (:documentation "Returns the CRLF canonicalized version of pathname.
Ensures that the CRLF version exists and is current.
The second returned value, newly-updated-p, is non-null whenever
a new CRLF file is written."))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;UTILS.LISP.340")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-common-lisp; Package: HTTP; Base: 10; Mode: lisp -*-")

;; this should have locking to avoid race conditions.   6/24/96 -- JCMa.
(defmethod ensure-crlf-canonical-file (pathname)
  (multiple-value-bind (valid-crlf-cache-p source-pathname crlf-pathname canonical-pathname)
      (valid-crlf-cache-file-p pathname)
    (cond (valid-crlf-cache-p crlf-pathname)
          (t (values (crlf-canonicalize-file source-pathname canonical-pathname) t)))))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:LISPM;SERVER;LISPM.LISP.347")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: WWW-UTILS; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:FIX :ROMAN :NORMAL);-*-")

;; This has locking to avoid race conditions. 7/3/96 -- JCMa.
(defmethod http:ensure-crlf-canonical-file ((pathname fs:pathname))
  (declare (values crlf-canonicalized-pathname newly-updated-p))
  (flet ((clean-up-crlf-files (pathname)
           (loop with wild-pathname = (scl:send pathname :new-pathname :version :wild)
                 and files-deleted-p
                 for (file) in (cdr (fs:directory-list wild-pathname ':fast ':sorted))
                 unless (eql file pathname)
                   do (scl:send (http::crlf-origin-pathname file) :remprop :crlf-pathname)      ;remove pointer
                      (scl:send file :delete)   ;delete old cr-lf pathname
                      (setq files-deleted-p t)
                 finally (when files-deleted-p
                           (scl:send wild-pathname :expunge)))))
    (declare (inline clean-up-crlf-files))
    (loop
      (multiple-value-bind (valid-crlf-cache-p source-pathname crlf-pathname canonical-pathname)
          (http:valid-crlf-cache-file-p pathname)
        (cond (valid-crlf-cache-p (return-from http:ensure-crlf-canonical-file crlf-pathname))
              ((pathname-crlf-lock-idle-p source-pathname)
               ;; small window here where two threads could update the same file twice.   7/4/96 -- JCMa.
               (let ((new-crlf-pathname nil))
                 (with-pathname-crlf-locked (source-pathname)
                   (setq new-crlf-pathname (http:crlf-canonicalize-file source-pathname canonical-pathname)))
                 (when (and new-crlf-pathname
                            (not (eq new-crlf-pathname crlf-pathname)))
                   (clean-up-crlf-files new-crlf-pathname))
                 (return-from http:ensure-crlf-canonical-file (values new-crlf-pathname t))))
              (t (process-wait "CRLF Wait" #'pathname-crlf-lock-idle-p source-pathname)))))))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;UTILS.LISP.340")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-common-lisp; Package: HTTP; Base: 10; Mode: lisp -*-")

(defmethod ensure-crlf-canonical-file ((pathname string))
  (ensure-crlf-canonical-file (pathname pathname)))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;UTILS.LISP.340")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-common-lisp; Package: HTTP; Base: 10; Mode: lisp -*-")

(defmethod valid-crlf-cache-file-p ((pathname string))
  (valid-crlf-cache-file-p (pathname pathname)))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;UTILS.LISP.340")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-common-lisp; Package: HTTP; Base: 10; Mode: lisp -*-")

(defmethod decode-crlf-file ((pathname string) &optional destination-pathname)
  (decode-crlf-file (pathname pathname) destination-pathname))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;UTILS.LISP.340")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-common-lisp; Package: HTTP; Base: 10; Mode: lisp -*-")

(defmethod crlf-canonicalize-file ((pathname string) &optional destination-pathname)
  (crlf-canonicalize-file (pathname pathname) destination-pathname))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;UTILS.LISP.340")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-common-lisp; Package: HTTP; Base: 10; Mode: lisp -*-")

(defmethod crlf-origin-pathname ((pathname string))
  (crlf-origin-pathname (pathname pathname)))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;UTILS.LISP.340")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-common-lisp; Package: HTTP; Base: 10; Mode: lisp -*-")

(defmethod crlf-pathname ((pathname string))
  (crlf-pathname (pathname pathname)))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;URL-CLASS.LISP.5")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Syntax: Ansi-common-lisp; Package: URL; Base: 10 -*-")

(defclass template-mixin
          ()
    ((template-parameters :initform nil :initarg :template-parameters :accessor template-parameters)
     (template-update-time :initarg :template-update-time :accessor template-update-time))
  (:documentation "Add templates to static files."))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;URL-CLASS.LISP.5")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Syntax: Ansi-common-lisp; Package: URL; Base: 10 -*-")

(defclass http-template-object
          (template-mixin alternate-url-mixin caching-object-mixin http-minimum-object)
    ()
  (:documentation "Root class for standard HTTP template objects on the server."))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;WEB-CONFIGURATION.LISP.37")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-Common-Lisp; Base: 10; Mode: lisp; Package: http -*-")

(defun show-preferences (stream types)
  (flet ((accept-preference (preference stream)
           (with-paragraph (:stream stream)
             (with-rendition (:bold :stream stream)
               (enumerating-item (stream)
                 (w3p:accept (preference-presentation-type preference)
                             :stream stream 
                             :view w3p:+html-view+ 
                             :present-p t
                             :default (funcall (preference-value-getter preference))
                             :prompt (preference-prompt preference) 
                             :prompt-mode :raw
                             :display-default nil
                             :query-identifier (preference-query-identifier preference)
                             :insert-default t
                             :active-p t)))
             (break-line :stream stream)
             (with-rendition (:italic :stream stream)
               (write-string (preference-description preference) stream)))))
    (declare (inline accept-preference))
    (with-emphasis (:quotation :stream stream)
      (with-font (:size 2 :stream stream)
        (with-rendition (:italic :stream stream)
          (with-section-heading ("Overview" :stream stream)
            (with-enumeration (stream :enumerate :type :capital-letters)
              (loop for type in types
                    for i from 0
                    do (let ((ref (princ-to-string i)))
                         (declare (dynamic-extent ref))
                         (enumerating-item (stream)
                           (note-anchor (preference-type-display-string type) :local-reference ref :stream stream)))))))))
    (horizontal-line :stream stream)
    (with-enumeration (stream :definition)
      (loop for type in types
            for i from 0
            for head = (preference-type-display-string type)
            for documentation = (preference-type-description type)
            do (flet ((note-preference-type (stream)
                        (let ((ref (princ-to-string i)))
                          (declare (dynamic-extent ref))
                          (with-anchor-noted (:tag ref :stream stream)
                            (with-font (:size 5 :stream stream)
                              (with-rendition (:bold :stream stream)
                                (fast-format stream "~C. ~A" (aref "ABCDEFGHIJKLMNOPQRSTUVWXYZ" i) head)))))))
                 (declare (dynamic-extent #'note-preference-type))
                 (enumerating-item (stream :head #'note-preference-type)
                   (when documentation
                     (write-string documentation stream))
                   (with-enumeration (stream :enumerate)
                     (loop for preference in (preference-type-inferiors type)
                           when (standard-preference-p preference)
                             do (accept-preference preference stream)))))))))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;UTILS.LISP.341")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-common-lisp; Package: HTTP; Base: 10; Mode: lisp -*-")

(defun concatenate-lines (lines &optional (trim-predicate #'white-space-char-p))
  "Concatenates line with lines trimming leading and trailing characters satisfying trim-predicate."
  (flet ((compute-concatenation-spec (lines)
           (loop for string in lines
                 for length = (length string)
                 for end = (1+ (the fixnum (or (position-if-not trim-predicate string :start 0 :end length :from-end t) -1)))
                 for start = (or (position-if-not trim-predicate string :start 0 :end end ) 0)
                 for size = (- (the fixnum end) (the fixnum start))
                 collect `(,start ,end ,size . ,string) into subseq-specs
                 unless (zerop size)
                   sum size into total-size
                   and sum 1 into n-lines
                 finally (return (values subseq-specs (if (zerop n-lines)
                                                          total-size
                                                          (+ (the fixnum (1- (the fixnum n-lines)))
                                                             (the fixnum total-size))))))))
    (declare (inline compute-concatenation-spec))
    (cond ((cdr lines)
           (multiple-value-bind (line-specs total-size)
               (compute-concatenation-spec lines)
             (declare (dynamic-extent line-specs))
             (let ((string (make-string total-size)))
               (with-fast-array-references ((string string string))
                 (loop with start2 = 0 and end2 = 0
                       for (spec . more-specs) = line-specs then more-specs
                       for (start end size . new-line) = spec
                       do (unless (zerop size)
                            (setq end2 (+ (the fixnum start2) (the fixnum size)))
                            (copy-vector-portion new-line start end string start2 end2)
                            (cond ((and more-specs (not (zerop (caddar more-specs))))
                                   (setf (aref string end2) #\space)
                                   (setq start2 (1+ (the fixnum end2))))
                                  (t (setq start2 end2))))
                       while more-specs))
               string)))
          (t (car lines)))))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;NETSCAPE-1-1.LISP.126")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Package: netscape1.1; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:FIX :ROMAN :NORMAL);-*-")

;; html spec says to always provide alternative text
(defun %note-image (stream image-url alternative-text alignment accept-coordinates-at-url
                           border vertical-space horizontal-space width height)
  (flet ((write-element (stream image-url image-url-string alignment alternative-text accept-coordinates-at-url)
           (flet ((alignment-value (alignment)
                    (unless (member alignment *image-alignment-values*)
                      (error "Unknown alignment, ~S, for an image." alignment))
                    (symbol-name alignment))
                  (write-integer-arg (stream option value)
                    (check-type value integer)
                    (%write-command-key-arg stream option value t)))
             (declare (inline alignment-value write-integer-arg))
             (%issue-command ("IMG" stream)
               ;; Automagically insert image sizes when algorithms available.
               (when (and image-url (not (or width height)) http:*image-sizes-default-automatically*)
                 (multiple-value-setq (width height)
                   (url:image-size image-url)))
               (cond-every
                 (image-url-string
                   (%write-command-key-arg stream "SRC" image-url-string))
                 (alignment
                   (%write-command-key-arg stream "ALIGN" (alignment-value alignment)))
                 (alternative-text
                   (check-type alternative-text string)
                   (%write-command-key-arg stream "ALT" alternative-text))
                 (accept-coordinates-at-url (%write-command-key-arg stream "ISMAP"))
                 (border (write-integer-arg stream "BORDER" border))
                 (vertical-space (write-integer-arg stream "VSPACE" vertical-space))
                 (horizontal-space (write-integer-arg stream "HSPACE" horizontal-space))
                 (width (write-integer-arg stream "WIDTH" width))
                 (height (write-integer-arg stream "HEIGHT" height)))))))
    (declare (dynamic-extent #'write-element))
    (let* ((url-string (url:name-string-without-search-suffix image-url nil))
           (real-image-url (typecase image-url
                             (string nil)
                             (t (intern-url url-string)))))
      (declare (dynamic-extent url-string))
      (case accept-coordinates-at-url
        ((nil :no-url)
         (write-element stream real-image-url url-string alignment alternative-text accept-coordinates-at-url))
        (t (with-anchor-noted (:reference (if (eq accept-coordinates-at-url t)
                                              url-string
                                              (url:name-string-without-search-suffix accept-coordinates-at-url nil))
                               :stream stream)
             (write-element stream real-image-url url-string alignment alternative-text accept-coordinates-at-url)))))))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SERVER.LISP.696")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Syntax: ANSI-Common-Lisp; Package: http; Base: 10 -*-")

;;;------------------------------------------------------------------- 
;;;
;;;  STATIC FILE EXPORT-TYPE, PLUS METHODS FOR :GET AND :HEAD
;;;

;; IANA maintains a list of assigned content types per RFC 1590 that can be found at
;;; ftp://ftp.isi.edu/in-notes/iana/assignments/media-types/media-types

(define-url-export-types
  ;; NNTP Message headers & message-body RFC 1026
  (:nntp-message-file :news (:message :news) :copy-mode :text))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:LISPM;SERVER;LISPM.LISP.349")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: WWW-UTILS; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:FIX :ROMAN :NORMAL);-*-")

;;;------------------------------------------------------------------- 
;;;
;;; STREAM HACKING
;;;

(define-macro with-binary-stream ((stream direction) &body body)
  "Turns STREAM into a binary stream within the scope of BODY.
DIRECTION can be :OUTPUT, :INPUT, or :BOTH."
  `(unwind-protect
       (progn ,(ecase direction
                 (:output `(tcp::binary-output-mode ,stream))
                 (:input `(tcp::binary-input-mode ,stream))
                 (:both `(progn (tcp::binary-output-mode ,stream)
                                (tcp::binary-input-mode ,stream))))
              ,@body)
     ,(ecase direction
        (:output `(tcp::ascii-output-mode ,stream))
        (:input `(tcp::ascii-input-mode ,stream))
        (:both `(progn (tcp::ascii-output-mode ,stream)
                       (tcp::ascii-input-mode ,stream))))))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:LISPM;SERVER;LISPM.LISP.350")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: WWW-UTILS; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:FIX :ROMAN :NORMAL);-*-")

(define-macro with-text-stream ((stream direction) &body body)
  "Turns STREAM into an TEXT stream within the scope of BODY.
DIRECTION can be :OUTPUT, :INPUT, or :BOTH."
  `(unwind-protect
       (progn ,(ecase direction
                 (:output `(tcp::ascii-output-mode ,stream))
                 (:input `(tcp::ascii-input-mode ,stream))
                 (:both `(progn (tcp::ascii-output-mode ,stream)
                                (tcp::ascii-input-mode ,stream))))
              ,@body)
     ,(ecase direction
        (:output `(tcp::ascii-output-mode ,stream))
        (:input `(tcp::ascii-input-mode ,stream))
        (:both `(progn (tcp::ascii-output-mode ,stream)
                       (tcp::ascii-input-mode ,stream))))))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;LOG.LISP.160")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-common-lisp; Package: HTTP; Base: 10; Mode: LISP -*-")

(defmethod initialize-log-filename ((log file-logging-mixin))
  (with-slots (name port filename log-file-name) log
    (let* ((pathname (translated-pathname *standard-log-directory*))
           (name-for-file (concatenate 'string log-file-name "-" (write-to-string port :base 10.))))
      (unless (probe-directory pathname)
        (www-utils:create-directories-recursively pathname))
      (setf filename (www-utils:%make-log-pathname
		       (pathname-device pathname)
                       (pathname-directory pathname) name-for-file (or (pathname-host pathname) (host-domain-name (local-host)))))
      log)))                                    ;must return log


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;PLIST.LISP.26")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Syntax: Ansi-Common-Lisp; Base: 10; Mode: lisp; Package: http-*-")

(defmethod (setf get-value) (value (plist property-list-mixin) indicator &optional default)
  (declare (ignore default))
  (with-slots (plist) plist
    (setf (getf plist indicator) value)))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SERVER.LISP.698")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Syntax: ANSI-Common-Lisp; Package: http; Base: 10 -*-")

(eval-when (compile load eval)
  (defun %define-url-export-type (export-type extension mime-content-type
                                              &optional (copy-mode :text)
                                              (url-class 'url:http-object)
                                              alternate-extensions data-type
					      no-methods)
    (flet ((charset-arg (content-type)
             (case (first content-type)
               (:text `((character-set url)))
               (t nil))))
      (unless data-type
        (setq data-type (first mime-content-type)))
      `(progn
         ;; set up mappings between mime, extension, and export type.
         (setf (%mime-content-type-spec ,extension) ',mime-content-type)
         (setf (export-type-for-pathname-type ,extension ) ,export-type)
         (setf (primary-pathname-extension ,extension) ,extension)
         (url:note-pathname-extension-type ,extension ,data-type ,copy-mode)
         (url::%note-content-type-copy-mode ,extension ,copy-mode)
         ,.(when alternate-extensions
             `((dolist (ext ',alternate-extensions)
                 (setf (export-type-for-pathname-type ext ) ',export-type)
                 (setf (primary-pathname-extension ext) ,extension)
                 (url:note-pathname-extension-type ext ,data-type ,copy-mode))))
         ;; write headers
	 ,(unless (member :header no-methods)
	    `(defmethod write-document-headers ((url ,url-class) (translation (eql ,export-type)) stream)
	       ,(ecase copy-mode
		  ((:text :binary)
		   `(%write-document-headers url ,extension stream ,@(charset-arg mime-content-type)))
                                       
		  (:crlf
		    `(%write-crlf-headers url ,extension stream ,@(charset-arg mime-content-type))))))
         ;; write body
	 ,(unless (member :document no-methods)
	    `(defmethod write-document ((url ,url-class) (translation (eql ,export-type)) stream)
	      ,(ecase copy-mode
		 (:text 
		   `(%write-document url ,extension stream ,@(charset-arg mime-content-type)))
		 (:binary
		   `(%write-binary-file url ,extension stream ,@(charset-arg mime-content-type)))
		 (:crlf
		   `(%write-crlf-file url ,extension stream ,@(charset-arg mime-content-type))))))
         ;; define searchable images
         ,.(case data-type
             (:image
               `((defmethod export-url ((url url:http-searchable-object) (translation (eql ,export-type)) &rest args)
                   (%export-url-searchable-object url translation args)))))
         ;; define the export method
	 ,(unless (member :export no-methods)
	    `(defmethod export-url ((url ,url-class) (translation (eql ,export-type)) &rest args)
	      (%export-url-object url translation args))))))

  (define-macro define-url-export-type (export-type file-extension mime-content-type
                                                    &key (copy-mode :text)
                                                    alternate-extensions  data-type 
                                                    (url-class 'url:http-object) no-methods)
    "Top-level method for defining a new EXPORT-TYPE for a static, file-located data source.
FILE-EXTENSION is a keyword denoting the primary extension used  for the pathname type.
DATA-TYPE is a keyword that describes the type of resource.  The default is to use the
major mime type, but some cases will want to specialize it.  It can be any of :TEXT, :LISP,
:HTML ,:IMAGE, :AUDIO, :VIDEO, :WORLD, or :APPLICATION. 
MIME-CONTENT-TYPE is a keyword list of (major-type subtype).
COPY-MODE is either :TEXT, :BINARY, or :CRLF.
ALTERNATE-EXTENSIONS is an optional list of keywords denoting alternative extensions used for
the pathname type.
Automatic definition of methods can be suppessed with NO-METHODS, which is a list 
and accepts values :EXPORT, :HEADER, :DOCUMENT."
    (%define-url-export-type export-type file-extension mime-content-type
                             copy-mode url-class 
                             alternate-extensions
                             data-type no-methods))

  (defmacro define-url-export-types (&rest export-type-specs)
    "Expands into a series of calls to DEFINE-URL-EXPORT-TYPE."
    `(progn
       ,.(loop for entry in export-type-specs
               nconc (destructuring-bind (export-type file-extension mime-content-type
                                                      &key (copy-mode :text)
                                                      alternate-extensions data-type
                                                      (url-class 'url:http-object)
						      no-methods)
                         entry
                       (rest 
                         (%define-url-export-type
                           export-type file-extension
                           mime-content-type
                           copy-mode url-class 
                           alternate-extensions
                           data-type
			   no-methods))))))

  )

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SERVER.LISP.698")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Syntax: ANSI-Common-Lisp; Package: http; Base: 10 -*-")

;;;------------------------------------------------------------------- 
;;;
;;;  STATIC FILE EXPORT-TYPE, PLUS METHODS FOR :GET AND :HEAD
;;;

;; IANA maintains a list of assigned content types per RFC 1590 that can be found at
;;; ftp://ftp.isi.edu/in-notes/iana/assignments/media-types/media-types

(define-url-export-types
  (:shtml-file :shtml (:text :html :charset :iso-8859-1)
	       :copy-mode #.+standard-text-copy-mode+ :data-type :html :alternate-extensions (:stm)
	       :url-class url:http-template-object :no-methods (:header :document)))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;URL.LISP.300")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Syntax: Ansi-common-lisp; Package: (URL :use (future-common-lisp) :colon-mode :internal); Base: 10 -*-")

(defmethod initialize-specialization ((url http-template-object) class init-args)
  (with-class-change-for-initialize-specialization (url class init-args)
    url))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SERVER.LISP.698")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Syntax: ANSI-Common-Lisp; Package: http; Base: 10 -*-")

(defmethod export-url :before ((url url:http-minimum-object) (translation (eql :shtml-file)) &rest args)
  (url:initialize-specialization url 'url:http-template-object args)
  url)

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SERVER.LISP.698")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Syntax: ANSI-Common-Lisp; Package: http; Base: 10 -*-")

(defmethod write-document-headers ((url url::http-template-object) (translation (eql :shtml-file)) stream)
  (%write-document-headers-no-pathname url :html stream))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;URL.LISP.302")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Syntax: Ansi-common-lisp; Package: (URL :use (future-common-lisp) :colon-mode :internal); Base: 10 -*-")


(define-generic parse-template (template-mixin content-type &optional pathname)
  (declare (values template-parameters))
  (:documentation "Parses a template for content-type into an executable form.
Specialize this method on content-type for each kind of template.
A parser MUST return a list of (START END INSERTION-FUNCTION). START and END are
byte offsets in the template. INSERTION-FUNCTION is a function called on (URL STREAM).
The runtime server sends the bytes from START to end followed by an application 
of INSERTION-FUNCTION. When START is EQL to END, no bytes are sent. When 
INSERTION-FUNCTION is null, no function application occurs."))

(defmethod parse-template (url content-type &optional pathname)
  (declare (ignore pathname))
  (error "No template parser method is defined for (URL::PARSE-TEMPLATE ,S ,S)." url content-type))

(defmethod parse-template :around ((url template-mixin) content-type &optional pathname)
  (setf (template-parameters url) (call-next-method url content-type pathname)
	(template-update-time url) (get-universal-time)))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:LISPM;SERVER;LISPM.LISP.352")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: WWW-UTILS; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:FIX :ROMAN :NORMAL);-*-")

(defconstant +shtml-tag-start+ #.(tcp::string-to-8-bit-vector "<!--#"))
(defconstant +shtml-tag-start-length+ #.(length "<!--#"))
(defconstant +shtml-tag-end+ #.(tcp::string-to-8-bit-vector "-->"))
(defconstant +shtml-tag-end-length+ #.(length "-->"))

;========================
(SCT:BEGIN-PATCH-SECTION)
; From buffer shtml.lisp >http>server W: (2)
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(PROGN
;;;   -*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-

;;;
;;; (c) Copyright  1997, John C. Mallery
;;;     All Rights Reserved.
;;;

(in-package :http)


;;;------------------------------------------------------------------- 
;;;
;;; SERVER SIDE HTML
;;;
;;; the Netscape SHTML is documented at the bottom of:
;;; http://developer.netscape.com/library/documentation/enterprise/unix/cgibas.htm

(defvar *shtml-action-table* (make-hash-table :test #'equal)
  "A table mapping strings to functions defined for server-parsed HTML.")

(defvar *shtml-actions* nil
  "A lis actions defined for server-parsed HTML.")

(defun %shtml-action-name-string (action &optional (start 0 start-supplied-p) (end nil end-supplied-p) mung-string-p)
  (etypecase action
    (string
      (cond ((or start-supplied-p end-supplied-p)
	     (nstring-downcase (subseq action start end)))
	    (mung-string-p (nstring-downcase action))
	    (t (string-downcase action))))
    (symbol (string-downcase (symbol-name action)))))

;; Tokenize actions for faster lookup
(define-header-keywords "execute" "include")

)

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SERVER.LISP.698")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Syntax: ANSI-Common-Lisp; Package: http; Base: 10 -*-")

(PROGN

(declaim (inline %write-template-from-pathname))

(defun %write-template-from-pathname (url pathname content-type stream &optional charset)
  (multiple-value-bind (crlf-pathname newly-updated-p)
      (ensure-crlf-canonical-file pathname)
    (when (or newly-updated-p (null (url::template-parameters url)))
      (url:parse-template url content-type crlf-pathname))
    (%%write-binary-template-file crlf-pathname url content-type stream charset)))

(defun %write-template-file (url content-type stream &optional charset)
  (let ((pathname (url:translated-pathname url)))
    (cond
      (pathname
       (handler-case
         (%write-template-from-pathname url pathname content-type stream charset)
         (file-not-found () (error 'document-not-found :url url))))
      (t (error 'document-not-found :url url)))))

(defmethod write-document ((url url::http-template-object) (translation (eql :shtml-file)) stream)
  (%write-template-file url :shtml stream (character-set url)))
)

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:LISPM;SERVER;LISPM.LISP.354")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: WWW-UTILS; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:FIX :ROMAN :NORMAL);-*-")

(declaim (special http::*server-line-buffer* http::*line-buffer-size*))

(defun vector-to-string (vector &optional (start 0) (end (length vector)) (buffer http::*server-line-buffer*) (buf-start 0))
  (let* ((length (- end start))
	 (string (or buffer (make-array length :element-type 'scl:string-char :fill-pointer 0))))
    (with-fast-array-references ((vector vector vector) (string string string))
      (loop for idx1 upfrom start below end
	    for idx2 upfrom (or buf-start 0)
	    for byte = (aref vector idx1)
	    for char = (if (member byte '#.(mapcar #'si:char-to-ascii  '(#\return #\linefeed))) #\space (si:ascii-to-char byte))
	    do (setf (aref string idx2) char)
	    finally (setf (fill-pointer string) (1+ idx2))
		    (return (values string length))))))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:LISPM;SERVER;PATCH;CL-HTTP-67;CL-HTTP-67-13.LISP.21")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Syntax: ansi-common-lisp; Base: 10; Package: http; Patch-File: t -*-")

(define validate-shtml-action (string &optional (start 0) end)
  "Returns the executable function if string denotes a valid server-parsed HTML action."
  (let ((action (%shtml-action-name-string string start end t)))
    (declare (dynamic-extent action))
    (or (gethash action *shtml-action-table*)
	(error "Undefined SHTML action, ~A." action))))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.4")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(eval-when (:compile-toplevel :load-toplevel :execute)

(defconstant +shtml-function-prefix+ "SHTML-ACTION-")

)

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.4")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(eval-when (:compile-toplevel :load-toplevel :execute)

(defun shtml-function-name (symbol)
  (declare (values shtml-function-name))
  (intern (concatenate 'string +shtml-function-prefix+ (symbol-name symbol)) (symbol-package symbol)))

)

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.4")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(define unregister-shtml-action (shtml-function)
  "Unregisters SHTML-FUNCTION for server-parsed HTML, making it no longer accessible from SHTML."
  (check-type shtml-function symbol)
  (let ((action (shtml-action-name shtml-function)))
    (declare (dynamic-extent action))
    (remhash (%shtml-action-name-string action) *shtml-action-table*)
    (setq *shtml-actions* (delete shtml-function *shtml-actions*))))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.4")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(define unregisters-all-shtml-actions ()
  "Unregisters all functions implementing server-parsed HTML actions."
  (clrhash *shtml-action-table*)
  (setq *shtml-actions* nil))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;URL.LISP.304")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Syntax: Ansi-common-lisp; Package: (URL :use (future-common-lisp) :colon-mode :internal); Base: 10 -*-")

(defmethod clear-template-cache ((url template-mixin))
  (setf (template-parameters url) nil
	(template-update-time url) nil))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;URL.LISP.304")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Syntax: Ansi-common-lisp; Package: (URL :use (future-common-lisp) :colon-mode :internal); Base: 10 -*-")

(define-generic clear-template-cache (template-mixin)
  (:documentation "Clears cached parameters and update times on TEMPLATE-MIXIN."))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;URL.LISP.305")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Syntax: Ansi-common-lisp; Package: (URL :use (future-common-lisp) :colon-mode :internal); Base: 10 -*-")

(define clear-all-template-caches ()
  "Clears all cached parameters and update times on URL templates."
  (map-url-table #'(lambda (name-string url)
		     (declare (ignore name-string))
		     (url:clear-template-cache url))))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;URL.LISP.306")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Syntax: Ansi-common-lisp; Package: (URL :use (future-common-lisp) :colon-mode :internal); Base: 10 -*-")

(defmethod clear-template-cache (url)
  (declare (ignore url)))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.4")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(defun shtml-action-name (shtml-function-name)
  (declare (values shtml-action-string))
  (%shtml-action-name-string (symbol-name shtml-function-name) #.(length +shtml-function-prefix+)))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.4")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(define register-shtml-action (shtml-function)
  "Registers SHTML-FUNCTION for server-parsed HTML.
SHTML-FUNCTION must be an fbound symbol."
  (check-type shtml-function (and symbol (satisfies fboundp)))
  (let ((action (shtml-action-name shtml-function)))
  (setf (gethash action *shtml-action-table*) shtml-function)
  (push-ordered shtml-function *shtml-actions* #'string<)
  action))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.4")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(define show-shtml-actions (&key (stream *standard-output*))
  "Describes the defined SHTML actions on stream."
  (loop for action in *shtml-actions*
	do (format stream "~&~S ~S: ~&~5TSHTML Tag: ~A~&~5T~:[Undocumented~;~:*~D~]"
		   action (arglist action) (shtml-action-name action) (documentation action 'function))))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SERVER.LISP.701")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Syntax: ANSI-Common-Lisp; Package: http; Base: 10 -*-")

;;;------------------------------------------------------------------- 
;;;
;;; WRITING BINARY TEMPLATES
;;;

(defun %%write-binary-template-file (pathname url content-type stream &optional charset)
  (let ((template-parameters (url::template-parameters url)))
    (cond (template-parameters
	   (with-open-file (file-stream pathname :direction :input :element-type '(unsigned-byte 8))
	     (let ((expires (expiration-universal-time url))
		   (cache-control (url:response-cache-control-directives url))
		   (languages (languages url)))
	       (with-successful-response (stream content-type :status :success
						 :last-modification (get-universal-time)
						 :character-set charset
						 :expires expires
						 :cache-control cache-control
						 :content-location url
						 :content-language languages
						 :termination-line-p t)
		 (with-binary-stream (stream :output)
		   (loop for (start end function . param-alist) in template-parameters
			 for n-bytes = (unless (eql start end) (- end start))
			 when n-bytes
			   do (file-position file-stream start)
			      (stream-copy-bytes file-stream stream n-bytes)
			 when function
			   do (funcall function url stream param-alist)))))))
	  (t (%%write-binary-file pathname url content-type stream charset)))))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.7")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(defmethod parse-shtml-template (pathname)
  (declare (ignore pathname))
  (error "Not Implemented: Each platform must define this operation."))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.8")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(defmethod parse-shtml-template ((pathname string))
  (parse-shtml-template (pathname pathname)))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;URL.LISP.307")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Syntax: Ansi-common-lisp; Package: (URL :use (future-common-lisp) :colon-mode :internal); Base: 10 -*-")

(defmethod parse-template (url (content-type (eql :shtml)) &optional pathname)
  (declare (ignore url))
  (http:parse-shtml-template (and pathname (pathname pathname))))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.9")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(defmacro with-shtml-parameters ((parameters plist) &body body)
  (loop for var in parameters
	for keyword = (symbolize (symbol-name var) *keyword-package*)
	collect `(,var (getf ,plist ,keyword)) into bindings
	finally (return `(let ,bindings . ,body))))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.9")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(defmethod get-shtml-operation (method parameter-plist)
  (error "Unknown SHTML method, ~S with arguments ~S" method parameter-plist))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.9")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(eval-when (:compile-toplevel :execute :load-toplevel)
(defconstant *shtml-tag-open* "<!--#")
(defconstant *shtml-tag-close* "-->"))

(define parse-shtml-element (element &optional (start 0) (end (length element)))
  "Parses a full SHTML element and returns a funcallable function or errors."
  (declare (values function parameter-plist)
	   (fixnum end))
  (let* ((end1 (- end #.(length *shtml-tag-close*)))
	 (pos (position #\# element :start start :end end1))
	 (start1 (1+ (the fixnum pos)))
	 (pos1 (and pos (position-if #'white-space-char-p element :start start1 :end end1)))
	 (method (and pos1 (%tokenize-header-keyword element start1 pos1)))
	 (plist (parse-equal-sign-delimited-pairs element (1+ (the fixnum pos1)) end1 #\space t)))
    (get-shtml-operation method plist)))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.9")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(define-generic parse-shtml-template (pathname)
  (declare (values template-parameters))
  (:documentation "Parses the contents of PATHNAME and returns TEMPLATE-PARAMETERS.
TEMPLATE-PARAMETERS is a list of (START-INDEX END-INDEX FUNCTION . PARAMETER-PLIST).
START-INDEX is a byte-offset from which binary copying starts.
END-OFFSET is a byte-offset at which binary copying stops.
The byte at START-INDEX is included. The byte at END-OFFSET is excluded.
FUNCTION and PARAMETER-plist are the values returned by calling 
PARSE-SHTML-ELEMENT on a string containing an SHTML tag with indices including
the entire element. 

Each platform should specialize this method on pathname. The byte offsets
must refer to the actual bytes shipped by the server. Thus, platforms performing
CRLF translation must define this operation to use the CRLF version of PATHNAME."))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:LISPM;SERVER;LISPM.LISP.358")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: WWW-UTILS; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:FIX :ROMAN :NORMAL);-*-")

(defmethod http:parse-shtml-template ((pathname pathname))
  (declare (values template-parameters))
  (flet ((find-tag-start (buffer start end)
	   (search +shtml-tag-start+ buffer :start1 0 :end1 +shtml-tag-start-length+ :start2 start :end2 end :test #'=))
	 (find-tag-end (buffer start end)
	   (search +shtml-tag-end+ buffer :start1 0 :end1 +shtml-tag-end-length+ :start2 start :end2 end :test #'=))
	 (make-entry (read-start read-end buffer s-idx e-idx &optional element-begin)
	   (let ((element (if element-begin
			      (vector-to-string buffer s-idx e-idx element-begin (fill-pointer element-begin))
			      (vector-to-string buffer s-idx e-idx http::*server-line-buffer* 0))))
	     (multiple-value-bind (function plist)
		 (http::parse-shtml-element element 0 (fill-pointer element))
	     (list* read-start read-end function plist)))))
    (declare (dynamic-extent find-tag-start find-tag-end))
    (with-open-file (file-stream pathname :direction :input :element-type '(unsigned-byte 8))
      (using-resource (http::*server-line-buffer* http::line-buffer http::*line-buffer-size*)
	(loop with buffer and offset and limit and buffer-pos and element-size and element-begin
	      and read-start = 0 and read-end = 0 and read-offset = 0
	      do (multiple-value-setq (buffer offset limit) (scl:send file-stream :read-input-buffer))
	      unless buffer
		unless (zerop read-offset)
		  collect (list read-start (+ read-start read-offset))
		    end
		  and do (loop-finish)
	      while buffer
	      do (setq buffer-pos offset)
	      when element-begin
		collect (let* ((end (or (find-tag-end buffer buffer-pos limit)
					(error "Unbalanced element at byte ~D, ~S" read-end element-begin)))
			       (buffer-pos1 (+ end +shtml-tag-end-length+)))
			  (incf element-size (- buffer-pos1 offset))
			  (prog1 (make-entry read-start read-end buffer offset buffer-pos1 element-begin)
				 (setq element-begin nil
				       buffer-pos buffer-pos1
				       read-start (+ read-end element-size)
				       element-size 0)))
	      nconc (loop for start = (find-tag-start buffer buffer-pos limit)
			  while start
			  for end = (find-tag-end buffer (+ start +shtml-tag-start-length+) limit)
			  do (setq read-end (+ read-start read-offset (- start buffer-pos))
				   read-offset 0)
			  when end
			    collect (prog2 (setq buffer-pos (+ end +shtml-tag-end-length+))
					   (make-entry read-start read-end buffer start buffer-pos)
					   (setq read-start (+ read-end (- buffer-pos start))))
			  else do (setq element-begin (vector-to-string buffer start limit)
					element-size (- limit start))
				  (loop-finish))
	      do (unless (or element-begin (= read-start limit))	;keep track of bytes to read.
		   (incf read-offset (- limit buffer-pos)))
		 (scl:send file-stream :advance-input-buffer))))))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.12")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(define-macro define-shtml-action (name parameters (&key (output-mode :text) documentation) &body body)
  "Defines an action named NAME for server-parsed HTML.
Actions are inserted into static HTML using the tag <!--#execute action=name -->.
PARAMETERS is a list of the SHTML parameters for the action. These are automatically
bound to the parameter string present in the HTML or NIL. When a parameter is an
integer, it is automatically converted to an integer. To avoid security
holes, extreme care should be exercised when converting these values to Lisp objects.
The current URL and the HTTP stream to the client are bound within BODY.
BODY may emit HTML on STREAM and access URL or HTTP:*SERVER*.
The STREAM output mode within BODY is controlled by OUTPUT-MODE,
which can be :TEXT, :BINARY, :MANUAL."
  (let ((fname (shtml-function-name name))
	(url-sym (intern "URL" *package*))
	(stream-sym (intern "STREAM" *package*))
	(body (ecase output-mode
		(:text `(www-utils::with-text-stream (stream :output) . ,body))
		(:binary `(with-binary-stream (stream :output) . ,body))
		(:manual `(progn . body)))))
    `(progn
       (defun ,fname (,url-sym ,stream-sym parameter-plist)
	 #+Genera(declare (sys:function-parent ,fname define-shtml-action))
	 ,documentation
	 ,url-sym parameter-plist		;ignore
	 ,(if parameters
	      `(with-shtml-parameters (,parameters parameter-plist)
		 ,body)
	      body))
       (register-shtml-action ',fname))))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.13")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(defun %shtml-insert-file (file url stream)
  (let* ((default (translated-pathname url))
	 (path (pathname file))
	 (pathname (make-pathname :name (pathname-name path) :type (pathname-type path) :version :newest :defaults default)))
    (with-open-file (file pathname :direction :input :if-does-not-exist :error)
      (stream-copy-until-eof file stream :text))))

;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.14")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(define-shtml-action insert-file (file)
		     (:output-mode :text :documentation "Inserts the contents of FILE, which must be a text/* file
in the same directory as the HTML file containing the tag.")
D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ROMAN NIL) "CPTFONT")  (%shtml-insert-file file url stream))


0;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.16")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(define-shtml-action date-time (format)
		     (:output-mode :text :documentation "Displays the current date and time according to FORMAT,
which can be ISO, Local, or GMT.")
  (let ((ut (get-universal-time)))
    (ecase (if format (%tokenize-header-keyword format) :iso)
      (:iso (write-standard-time ut stream))
      (:gmt (write-time ut stream 0))
      (:local (print-date-time :universal-time ut :stream stream)))))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.16")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(define-shtml-action number-of-visitors ()
		     (:output-mode :text :documentation "Writes the number of visitors to the current Web page.")
  (flet ((get-visit-count (counter)
	   (let ((count (1+ (handler-case
			      (with-open-file
				(file counter :direction :input :element-type *standard-character-type*)
				(read file nil 0))
			      (file-error () 0)))))
	     (with-open-file (file counter :direction :output :element-type *standard-character-type*
				   :if-does-not-exist :create :if-exists :overwrite)
	       (write count :base 10 :stream file))
	     count)))
    (let* ((path (translated-pathname url))
	   (counter (make-pathname :type "counter" :defaults path)))
      (write (get-visit-count counter) :base 10 :stream stream))))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.16")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(defmethod get-shtml-operation ((method (eql :eval)) parameter-plist)
  (let ((action (getf parameter-plist :action)))
    (cond (action
	   (values (validate-shtml-action action 0 (length action))
		   parameter-plist))
	  (t (error "SHTML ~S element contains no action, ~S." parameter-plist)))))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.16")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(defun %shtml-include-file (url stream parameter-plist)
  (with-shtml-parameters ((file) parameter-plist)
    (%shtml-insert-file file url stream)))


;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SHTML.LISP.16")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: LISP; Package: http; BASE: 10; Syntax: ANSI-Common-Lisp; Default-Character-Style: (:fix :roman :normal);-*-")

(defmethod get-shtml-operation ((method (eql :include)) parameter-plist)
  (values '%shtml-include-file parameter-plist))



;========================
(SCT:BEGIN-PATCH-SECTION)
(SCT:PATCH-SECTION-SOURCE-FILE "HTTP:SERVER;SERVER.LISP.705")
(SCT:PATCH-SECTION-ATTRIBUTES
  "-*- Mode: lisp; Syntax: ANSI-Common-Lisp; Package: http; Base: 10 -*-")

(setf (documentation 'export-url 'function)

      "HTTP:EXPORT-URL is the primary method that exports URLS to make them
accessible via the http server. URL is either a string or an interned URL to
be exported.  EXPORT-TYPE is the method to use in exporting URL.


I. Basic Export Types: These involve making the contents of a file accessible via
a URL. These types require URLs that are object (i.e., have a name and extension).

        :HTML-FILE (&key pathname)
        :TEXT-FILE (&key pathname)
        :RTF-FILE (&key pathname)

        :GIF-IMAGE (&key pathname)
        :JPEG-IMAGE (&key pathname)
        :X-BITMAP-IMAGE (&key pathname)
        :PICT-IMAGE (&key pathname)
        :TIFF-IMAGE (&key pathname)

        :BASIC-AUDIO (&key pathname)
        :AIFF-AUDIO (&key pathname)
        :WAV-AUDIO (&key pathname)

        :MPEG-VIDEO (&key pathname)
        :QUICKTIME-VIDEO (&key pathname)

        :VRML-WORLD (&key pathname)

        :DIRECTORY (&key pathname immediate-export recache recursive-p)
        :HTML-DIRECTORY (&key pathname immediate-export recache recursive-p)
        :TEXT-DIRECTORY (&key pathname immediate-export recache recursive-p)
        :LISP-DIRECTORY (&key pathname immediate-export recache recursive-p)
        :IMAGE-DIRECTORY (&key pathname immediate-export recache recursive-p)
        :AUDIO-DIRECTORY (&key pathname immediate-export recache recursive-p)
        :VIDEO-DIRECTORY (&key pathname immediate-export recache recursive-p)
        :WORLD-DIRECTORY (&key pathname immediate-export recache recursive-p)
        :APPLICATION-DIRECTORY (&key pathname immediate-export recache recursive-p)

:DIRECTORY exports all files whose resource type is known.
Others export a specific content type, and ignore other file types.
When recursive-p is non-null, all subdirectories are also exported.
Otherwise, subdirectories are ignored.

When *AUTO-EXPORT* is non-null, new files are automatically exported when they
are scoped by one of these directory export types. Auto-export occurs on
demand for the GET and HEAD methods. If *AUTO-EXPORT* is :ON-DEMAND,
files are exported when they are first requested rather than at the
time the directory is exported. When exporting a directory, a non-null
argument to :IMMEDIATE-EXPORT overrides lazy directory exporting. In general,
on-demand directory exports trade faster server start up for a slightly slower
first access to a file URL within the directory. When :RECACHE is non-null,
a directory export updates the export parameters for every inferior. This
parameter forces traversal of the entire structure, like a non-null
:IMMEDIATE-EXPORT would.

A directory-style list in HTML is the default content returned for the
get method on a URL directory path. This behavior is customized by
providing a response function via the :DIRECTORY-WRITER keyword.  This
response function is called with the arguments (URL STREAM) and must
return non-null when it handles the response. If it declines to handle
the response, it may return NIL, and the standard method will list the
directory as usual. HTTP:WRITE-INDEXED-DIRECTORY-LISTING is a directory
writer that will serve the contents of an index.html file found in
the directory. Other computed returns are possible.

Note that the presence in file or directory names of escaped characters 
(see *ESCAPED-CHARACTERS*) will lead to inconsistent results, and possibly
errors. Space and question mark are examples.

        :PDF-FILE  (&key pathname)
        :POSTSCRIPT-FILE (&key pathname)

        :BINHEX-FILE (&key pathname)
        :STUFFIT-FILE  (&key pathname)
        :COMPRESSED-FILE (&key pathname)
        :MAC-BINARY-FILE (&key pathname)

        :WORD-FILE  (&key pathname)
        :POWER-POINT-FILE (&key pathname)
        :EXCEL-FILE  (&key pathname)

The following export types support inline plug-ins on the client side.
Plug-ins can be referenced using NS2.0:WITH-EMBEDDED-SCRIPT

        Inline speech synthesis is available using a macintalk plug-in
        from http://www.mvpsolutions.com/PlugInSite/Talker.html

        :TALK-AUDIO (&key pathname)

The Java language provides applets that execute on the client.  This kind of
mobile code is supported with the following export types and the HMTL
generation macro WITH-JAVA-APPLET.
        
        :JAVA-FILE (&key pathname)
        :JAVA-BINARY (&key pathname)
        :JAVA-SCRIPT-FILE (&key pathname)

:JAVA-FILE exports the source code whereas :JAVA-BINARY provides the byte
compiled binary to the client running the applet. :JAVA-SCRIPT-FILE exports
the browser scripting language, JavaScript, which is simpler and easier to use
than Java itself.

II. Redirect Export Types: These export types inform the client to
look elsewhere for a URL.  They work for the GET and HEAD operations.
The exported URL can be either an HTTP object or an HTTP path.

        :REDIRECT (&key alternate-urls pathname)
        :TEMPORARY-REDIRECT (&key alternate-urls pathname)

Alternatively, a computed response may call REDIRECT-REQUEST to issue a
redirect rather than serving content itself.

III. Search Export Types: these involve performing searches using the search
index or map search facilities in HTTP. Search URLs must end with ? so that
the system can composed the right combination of classes. In all cases, the
response function must compute the answer and return HTML over the http stream
to the client.

General Purpose Searches

        :SEARCH (&key response-function search-parser search-database)

        This exports a URL that performs searches by calling RESPONSE-FUNCTION with
        the arguments URL and STREAM. The search database and search parameters are
        cached on the URL and accessible via URL:SEARCH-DATABASE and URL:SEARCH-KEYS.

        The optional export argument SEARCH-PARSER is the parser that obtains URL:SEARCH-KEYS
        from the suffix of a search URL. Several parsers are predefined:

                URL:STANDARD-PARSE-SEARCH-INFO: This standard parser for
                search URLs. It tests whether the search info encodes form or
                list data and calls the appropriate of the next two parsers.

                URL:PARSE-SEARCH-INFO: This normal parser for search URLs
                produces a list of search parameters using + as the delimiter.

                URL:PARSE-SEARCH-INFO-AS-QUERY-ALIST: This parser for URL
                encoded form values returns an alist just like posting a form
                would. This parser should be used when an HTML form is
                returned to a search URL.  However, this method of returning
                form values is limited to 1024 characters total in the URL,
                and therefore, it's use in new code is deprecated.

        Users may provide other specialized parsers. They should accept
        the arguments (url-string start end) and need not located the ?
        suffix delimiter.

        The export argument, SEARCH-WRITER, allows a URL to specialize how the
        parsed presentation on URL:SEARCH-KEYS is written. Several writers are
        predefined.

                URL:STANDARD-WRITE-SEARCH-INFO: This standard writer for
                search URLs. It tests whether the search info encodes form or
                list data and calls the appropriate of the next two writers.

                URL:WRITE-SEARCH-INFO: This normal writer for search URLs
                produces a list of search parameters using + as the delimiter.

                URL:WRITE-SEARCH-INFO-AS-QUERY-ALIST: This writer for URL
                encoded form values that prints alist values as name value pairs
                using the urlencoding syntax.
 
Image Searches

   Image Maps

        :IMAGE-MAP (&key pathname export-type map-format map-pathname
                         search-parser search-writer)

        This exports the image in PATHNAME as IMAGE-EXPORT-TYPE and
        establishes a response function based on the image map in MAP-PATHNAME
        whose MAP-FORMAT is either :CERN or :NCSA. EXPORT-TYPE is the
        appropriate image search export type (see below).

   Direct Searches

        These provide direct control over the response function for image searches.

        :GIF-IMAGE (&key pathname response-function search-database
                         search-parser search-writer)
        :JPEG-IMAGE (&key pathname response-function search-database
                          search-parser search-writer)
        :PNG-IMAGE (&key pathname response-function search-database
                         search-parser search-writer)
        :X-BITMAP-IMAGE (&key pathname response-function search-database
                              search-parser search-writer)
        :PICT-IMAGE (&key pathname response-function search-database)
                          search-parser search-writer)
        :TIFF-IMAGE (&key pathname response-function search-database
                          search-parser search-writer)

        These export types allow the client's user to click on images and
        invoke a response from the server.  These URL are both objects and
        searchable.  When they are requested without the ? suffix, the
        contents of their associate image file is returned.  When the ? suffix
        appears, their RESPONSE-FUNCTION is called on the arguments URL and
        STREAM. See the macro HTTP:WITH-IMAGE-COORDINATES automatically binds
        the X and Y coordinates.

III Computed Export Types: These compute responses returned to clients.

        :COMPUTED (&key response-function pathname) RESPONSE-FUNCTION is
        called with the arguments URL and STREAM and is responsible for
        returning HTML to the client. :COMPUTED has an optional pathname
        so that the computation may reference a file, if necessary.
        
        :HTML-FORM (&key response-function pathname server) :HTML-FORM returns
        the contents of PATHNAME when it is requested via GET.  When there is
        a POST, its RESPONSE-FUNCTION is called with URL, STREAM, and
        FORM-ALIST.  FORM-ALIST is an alist of (QUERY RAW-VALUE) for all the
        queries in the form that the client returns. QUERY is a keyword.  When
        a client returns multiple raw-values for a QUERY, these are aggregated
        into a list of the values associated with the query in a single,
        order-preserving entry.

        :COMPUTED-FORM (&key form-function response-function server)
        :COMPUTED-FORM is a cross between :COMPUTED and :HTML-FORM
        that provides FORM-FUNCTION to generate html just like :COMPUTED
        and RESPONSE-FUNCTION to handle the post method when form values
        are returned. FORM-FUNCTION is called with the arguments URL and STREAM
        and is responsible for returning HTML to the client. response-function
        takes the same arguments as :HTML-FORM.

        :SCRIPT (&key script) Script is a client-side script defined with
        NS2.0:DEFINE-SCRIPT. These scripts may merely deliver a static copy
        of the client-side script, or they may perform a computation that
        emits an appropriate script.

        :SHTML-FILE (&key pathname) This is a computed response that
	is inserted in a static HTML file containing server-parsed HTML. When
	an SHTML element is found by the server, it inserts the result of a
	computation in place of the SHTML element.  SHTML elements are
	delimted by <!--# and --> and look like:

              <!--#include file=\"insert.text\"-->

	INCLUDE is a type of operation and FILE is a parameter for the
	operation.


              <!--#eval action=date-time format=\"iso\"-->
	
	EVAL is type of operation. ACTION is the specific operation to perform
	and format is a parameter for the operation. Predefined actions are
	documented by HTTP:SHOW-SHTML-ACTIONS. New SHTML actions are defined
	with HTTP:DEFINE-SHTML-ACTION. Files with the extention shtml are
	autoexported by HTML directory export types.

IV. Export Parameters and Issues

1. Portable Exports: The #u reader macro merges a partial URL specification
against the default for the local host. Use this when you be able to load the
same exports file on different hosts. The #u reader macro has an extended syntax
that allows you to overview the default host and port specified by
the server configuration. The syntax is 

     #u(url-string :host host-string :port port-number)

URL-STRING is a relative URI. HOST-STRING is the domain name or
IP string for the host. PORT-NUMBER is an integer.


2. Subnet Security: secure-subnets are a list of IP addresses, where
0 is a wildcard. 128.52.0.0 matches all the subnets at the AI lab.

     DEFINE-SECURE-SUBNETS restricts access globally to the server.

     :SECURE-SUBNETS allows access to be specified at the level of
     URLs as they are exported.

3. Expiration: The expiration time for a url is issued as an EXPIRES header so
that proxy servers can determine when they need to refresh their cache.

Expiration is controlled by providing the :EXPIRATION when exporting any URL.
If expiration is not provided, the default is no expiration date.

The :EXPIRATION keyword takes one argument, which is either keyword or a list
of (keyword &rest arguments).

     Arguments                       Meaning

 :NO-EXPIRATION-HEADER        --  No EXPIREs header is issued.
 :NEVER                       --  EXPIRES header indicates one year from now.
 (:INTERVAL <universal-time>) --  EXPIRES header indicates now + <universal-time>.
 (:TIME <universal-time>)     --  EXPIRES header indicates an <universal-time>.
 (:FUNCTION <function-spec>)  --  EXPIRES header indicates universal time computed by
                                  applying <function-spec> to URL.  <function-spec>
                                  should return a universal for use in the EXPIRES header
                                  or NIL, in which case no EXPIRES header is issued.

4. Character Sets: The :CHARACTER-SET keyword allows any URLs whose content
type is TEXT (e.g., text/plain, text/html) to be exported with character sets
other than the HTTP default :ISO-8859-1, or subsets. The valid character sets
for HTTP are:  :US-ASCII, :ISO-8859-1, :ISO-8859-2, :ISO-8859-3, :ISO-8859-4,
:ISO-8859-5, :ISO-8859-6, :ISO-8859-7, :ISO-8859-8, :ISO-8859-9, :ISO-2022-JP,
:ISO-2022-JP, :ISO-2022-KR, :UNICODE-1-1, :UNICODE-2-2-UTF-7,
:UNICODE-2-2-UTF-7.  Whenever TEXT content types use a character set other
than :ISO-8859-1, the HTTP requires explicit specification via this export
keyword.

6. Languages:  The :LANGUAGE keyword may be supplied for any exported
URL. The value is a sequence of keywords denoting the language(s) in which the
resource is written. HTTP 1.1 defines these keywords in section 3.10 to
conform with RFC 1766. They can be a two-letter ISO 639 language abbreviation,
optionally with a two-letter ISO 3166 country code as a subtag.

7. Documentation: Keywords and a descriptive string can be attached to URLs at
export time.  For directory exports, note that these arguments apply to ALL
URLs exported during the directory walk.

     :KEYWORDS                  A list of keywords.
     :DOCUMENTATION             A string describing the URL.


8. Virtual Hosts: HTTP 1.1 requires a virtual hosting facility,
which this server implements. You can define a virtual host (or
vanity name) that will be served by the physical server from
the same IP address. Any URIs served by a virtual host must be
exported by specifying the absolute URI, including host and port
number.  The #u reader macro may be useful here.  The following
operators are available for use with virtual hosts:

     ADD-VIRTUAL-HOST: Adds a virtual host on a virtual port and
                       and makes URLs served by that host available
                       to HTTP 1.1 or greater clients.

     REMOVE-VIRTUAL-HOST: Makes the virtual host unavailable, but does
                          does not remove any URLs it exports.

9. New static export types for data stored in files can be defined with
DEFINE-URL-EXPORT-TYPE.

10. HTTP 1.1 Cache Control: The keywords below may be supplied when exporting
any URL in order to statically control how downstream proxies and caches
handle the content associated with a URL.

        :PUBLIC -- If the value is T, the entire message is cachable by any
        cache even if it would not normally be cached.

        :PRIVATE -- If the value is T, the entire message is intended for a
        single user and must not be cached by a shared cache. If the value is
        a list of keywords denoting specific header, then only these headers
        should be considered private.

        :NO-CACHE -- If the value is T, the entire message must not be cached
        by any cache along the request chain.  If the value is a list of
        keywords denoting specific headers, then only these headers should be
        discarded before caching.

        :NO-STORE -- If the value is T, the entire message must not be stored
        in any non-volatile storage by any cache along the request chain.

        :MAX-AGE -- The value is the number of seconds for which the response
        is valid, after which it should be revalidated.  This directive
        overrides the expiration header, thus allowing HTTP 1.1 server to
        provide a longer expiration time to HTTP 1.1 servers and proxies.
        This defaults to a value derived from the expiration time.

        :MUST-REVALIDATE -- If the value is T, caches and proxies must not
        serve the resource without revalidating it once it becomes stale, even
        if configured to operate with state data. Servers should send this
        directive if and only if failure to revalidate will result in
        incorrect operation. Recipients must not take any automated action
        that violates this directive.

        :PROXY-REVALIDATE -- If the value is T, this directive is the same as
        :MUST-REVALIDATE except that it applies only to proxies and not
        non-shared user caches. It can be used on response to an authenticated
        request to permit the user's cache to store and later return the
        response without needing to revalidate it.

        :NO-TRANSFORM -- If the value is T, caches and proxies must not change
        the body of the message or change headers describing the content.

11. Property List: The PROPERTY-LIST keyword adds a property list of
alternating keywords and value to a URL.  These properties can be read
and set via GET-VALUE.")
