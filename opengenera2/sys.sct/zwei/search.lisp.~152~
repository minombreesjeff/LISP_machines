;;;-*- Syntax: Zetalisp; Mode: LISP; Package: ZWEI; Base: 8 -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Functions and commands for doing searching

;;; First value is BP found at, or NIL if not found.
;;; If LINES-TO-SEARCH is not NIL, it is a number of lines to give up after.
;;; In that case, if we give up, the first value is a bp to where to resume,
;;; and the second value is T.  The resumption bp is such that no occurrences
;;; are missed by being split across it (this could happen in reverse searches
;;; if the bp were chosen randomly).
(DEFUN SEARCH (BP STRING &OPTIONAL REVERSEP FIXUP-P LINES-TO-SEARCH LIMIT-BP
				   (CASE-DEPENDENT-P NIL)	;---
				   SKIP-TABLE REOCCURRENCE-TABLE
			 &AUX NLPOS)
  CASE-DEPENDENT-P
  (OR LIMIT-BP (SETQ LIMIT-BP (IF REVERSEP
				  (INTERVAL-FIRST-BP *INTERVAL*)
				  (INTERVAL-LAST-BP *INTERVAL*))))
  (PROG SEARCH ()
   (RETURN
    (COND ((NUMBERP STRING)
	   (IF (NOT REVERSEP)
	       ;; Forward search for a character.
	       (CHARMAP-PER-LINE (BP LIMIT-BP (IF FIXUP-P (COPY-BP LIMIT-BP) NIL))
				 ((AND LINES-TO-SEARCH
				       (ZEROP (SETQ LINES-TO-SEARCH
						    (1- LINES-TO-SEARCH)))
				       (RETURN-FROM SEARCH
					 (VALUES (CREATE-BP LINE *FIRST-INDEX*)
						 T))))
		 (AND (CHAR-EQUAL STRING (CHARMAP-CHAR))
		      (CHARMAP-RETURN (CHARMAP-BP-AFTER))))
	       ;; Reverse search for a character.
	       (RCHARMAP-PER-LINE (BP LIMIT-BP (IF FIXUP-P (COPY-BP LIMIT-BP) NIL))
				  ((AND LINES-TO-SEARCH
					(ZEROP (SETQ LINES-TO-SEARCH
						     (1- LINES-TO-SEARCH)))
					(RETURN-FROM SEARCH
					  (VALUES (END-OF-LINE LINE)
						  T))))
		 (AND (CHAR-EQUAL STRING (RCHARMAP-CHAR))
		      (RCHARMAP-RETURN (RCHARMAP-BP-BEFORE))))))
	  ((SETQ NLPOS (STRING-SEARCH-CHAR #\CR STRING))
	   (SEARCH-CR-FULL BP (STRING STRING) REVERSEP FIXUP-P NLPOS LINES-TO-SEARCH LIMIT-BP))
	  (T
	   (IF (NOT REVERSEP)
	       ;; Search forward for a 1-line string.
	       (DO ((LINE (BP-LINE BP) (LINE-NEXT-IN-BUFFER LINE))
		    (LEN (STRING-LENGTH STRING))
		    (FROM-INDEX (BP-INDEX BP) 0)
		    (LAST-LINE (BP-LINE LIMIT-BP)))
		   ((AND LINES-TO-SEARCH
			 (ZEROP (SETQ LINES-TO-SEARCH (1- LINES-TO-SEARCH))))
		    (RETURN-FROM SEARCH (VALUES (CREATE-BP LINE FROM-INDEX) T)))
		 (LET ((LASTP (OR (NULL LINE) (EQ LINE LAST-LINE))))
		   (LET ((INDEX (IF (AND SKIP-TABLE REOCCURRENCE-TABLE)
				    (BOYER-SEARCH-INTERNAL
				      STRING LINE
				      SKIP-TABLE REOCCURRENCE-TABLE
				      FROM-INDEX (STRING-LENGTH LINE))
				  (STRING-SEARCH STRING LINE FROM-INDEX))))
		     (COND ((AND (NOT (NULL INDEX))
				 (OR (NOT LASTP)
				     ( INDEX (- (BP-INDEX LIMIT-BP) LEN))))
			    (RETURN (CREATE-BP LINE (+ INDEX LEN))))
			   (LASTP
			    (RETURN (IF FIXUP-P (COPY-BP LIMIT-BP) NIL)))))))
	       ;; Search backward for a 1-line string.
	       (DO ((LINE (BP-LINE BP) (LINE-PREVIOUS-IN-BUFFER LINE))
		    (LEN (STRING-LENGTH STRING))
		    (FROM-INDEX (BP-INDEX BP) NIL)
		    (FIRST-LINE (BP-LINE LIMIT-BP)))
		   ((AND LINES-TO-SEARCH
			 (ZEROP (SETQ LINES-TO-SEARCH (1- LINES-TO-SEARCH))))
		    (RETURN-FROM SEARCH (VALUES (END-OF-LINE LINE) T)))
		 (LET ((FIRSTP (EQ LINE FIRST-LINE)))
		   (LET ((INDEX (STRING-REVERSE-SEARCH STRING LINE FROM-INDEX)))
		     (COND ((AND (NOT (NULL INDEX))
				 (OR (NOT FIRSTP)
				     ( INDEX (- (BP-INDEX LIMIT-BP) LEN))))
			    (RETURN (CREATE-BP LINE INDEX)))
			   (FIRSTP
			    (RETURN (IF FIXUP-P (COPY-BP LIMIT-BP) NIL)))))))))))))

;;; Subroutine of SEARCH.  Used to search for a string containing a CR.
;;; NLPOS is the index in STRING of the first CR.
(DEFUN SEARCH-CR-FULL (BP STRING REVERSEP FIXUP-P NLPOS LINES-TO-SEARCH LIMIT-BP)
  (PROG SEARCH-CR-FULL ((STRING-LENGTH (STRING-LENGTH STRING)))
    (RETURN
      (IF (NOT REVERSEP)
	  (LET ((CHAR1 (AREF STRING 0))
		(CRLEADS (ZEROP NLPOS))
		(LAST-LINE (BP-LINE LIMIT-BP)))
	     (WHEN (EQ (BP-LINE BP) LAST-LINE)
	       (RETURN-FROM SEARCH-CR-FULL (IF FIXUP-P (COPY-BP LIMIT-BP) NIL)))
	     (DO-NAMED LUPO
		 ((LINE (IF (AND (NOT CRLEADS)
				 ( (- (LINE-LENGTH (BP-LINE BP)) (BP-INDEX BP)) NLPOS))
			    (BP-LINE BP)
			    (LINE-NEXT-IN-BUFFER (BP-LINE BP)))
			(LINE-NEXT-IN-BUFFER LINE)))
		 ((OR (NULL LINE)
		      (AND (NOT CRLEADS) (EQ LINE LAST-LINE)))
		  ;; Since string contains a NEWLINE, it cannot start on LAST-LINE.
		  ;; Unless the NEWLINE is at the beginning.
		  (IF FIXUP-P (COPY-BP LIMIT-BP) NIL))
	       (LET ((START-INDEX (IF CRLEADS 0 (- (LINE-LENGTH LINE) NLPOS))))
		 (COND ((OR CRLEADS
			    (AND ( START-INDEX 0)
				 (CHAR-EQUAL CHAR1 (AREF LINE START-INDEX))))
			(LET ((I (IF CRLEADS 1 0)))
			  (CHARMAP ((CREATE-BP LINE START-INDEX) LIMIT-BP
				    (IF ( I STRING-LENGTH)
					(RETURN-FROM LUPO (CHARMAP-BP-BEFORE))))
			    (IF ( I STRING-LENGTH)
				(RETURN-FROM LUPO (CHARMAP-BP-BEFORE)))
			    (IF (NOT (CHAR-EQUAL (CHARMAP-CHAR) (AREF STRING I)))
				(CHARMAP-RETURN NIL))
			    (SETQ I (1+ I)))))))
	       (AND CRLEADS (EQ LINE LAST-LINE)
		    (RETURN (IF FIXUP-P (COPY-BP LIMIT-BP) NIL)))
	       (AND LINES-TO-SEARCH
		    (ZEROP (SETQ LINES-TO-SEARCH (1- LINES-TO-SEARCH)))
		    (RETURN-FROM SEARCH-CR-FULL (VALUES (BEG-OF-LINE LINE) T)))))
	  (SETQ NLPOS (STRING-REVERSE-SEARCH-CHAR #\CR STRING))
	  (LET ((CHARL (AREF STRING (1- STRING-LENGTH)))
		;; One less than number of chars after the last CR.
		(START-INDEX (- STRING-LENGTH NLPOS 2))
		(FIRST-LINE (BP-LINE LIMIT-BP)))
	    (WHEN (EQ (BP-LINE BP) FIRST-LINE)
	       (RETURN-FROM SEARCH-CR-FULL (IF FIXUP-P (COPY-BP LIMIT-BP) NIL)))
	    (DO-NAMED LUPO
		((LINE (IF (> (BP-INDEX BP) START-INDEX)
			   (BP-LINE BP)
			   (LINE-PREVIOUS-IN-BUFFER (BP-LINE BP)))
		       (LINE-PREVIOUS-IN-BUFFER LINE))
		 (CRTRAILS (CHAR-EQUAL CHARL #\CR)))
		((OR (NULL LINE) (EQ LINE FIRST-LINE))
		 (IF FIXUP-P (COPY-BP LIMIT-BP) NIL))
	      (COND ((OR CRTRAILS (AND (> (LINE-LENGTH LINE) START-INDEX)
				       (CHAR-EQUAL CHARL (AREF LINE START-INDEX))))
		     (LET ((I (1- STRING-LENGTH)))
		       (RCHARMAP ((CREATE-BP LINE (1+ START-INDEX)) LIMIT-BP
				  (IF (< I 0)
				      (RETURN-FROM LUPO (RCHARMAP-BP-AFTER))))
			 (IF (< I 0)
			     (RETURN-FROM LUPO (RCHARMAP-BP-AFTER)))
			 (IF (NOT (CHAR-EQUAL (RCHARMAP-CHAR) (AREF STRING I)))
			     (RCHARMAP-RETURN NIL)
			     (SETQ I (1- I)))))))
	      (AND LINES-TO-SEARCH
		   (ZEROP (SETQ LINES-TO-SEARCH (1- LINES-TO-SEARCH)))
		   (RETURN-FROM SEARCH-CR-FULL (VALUES (BEG-LINE (CREATE-BP LINE 0) 1) T)))
	      ))))))

;;; Word search infernal function
(DEFUN WORD-SEARCH (BP KEY &OPTIONAL REVERSE-P FIXUP-P LIMIT-BP
				     (CASE-DEPENDENT-P NIL)	;---
			   &AUX LEN KEY1 LEN1)
  CASE-DEPENDENT-P
  (OR LIMIT-BP (SETQ LIMIT-BP (IF REVERSE-P
				  (INTERVAL-FIRST-BP *INTERVAL*)
				  (INTERVAL-LAST-BP *INTERVAL*))))
  (SETQ LEN (STRING-LENGTH KEY))
  (DO ((I 0 (1+ I)))
      ((OR ( I LEN) ( (WORD-SYNTAX (AREF KEY I)) WORD-ALPHABETIC))
       (SETQ LEN1 I KEY1 (NSUBSTRING KEY 0 I))))
  (COND ((NOT REVERSE-P)
         (DO-NAMED LINES
             ((LINE (BP-LINE BP) (LINE-NEXT-IN-BUFFER LINE))
              (LIMIT (BP-LINE LIMIT-BP))
              (IDX (BP-INDEX BP) 0))
             (NIL)
           (DO-NAMED PER-LINE
               ((LLEN (LINE-LENGTH LINE)))
               (NIL)
             (OR (SETQ IDX (STRING-SEARCH KEY1 LINE IDX))	;Find first word in line
                 (RETURN NIL))
	     (DO-NAMED MATCH-REMAINING-WORDS
		 ((I IDX)			;I index of character in line
		  (J LEN1)			;J index in search key
		  (LINE1 LINE)			;Copy these in case we advance to next line
		  (LLEN1 LLEN))
		 (NIL)
	       ;; Space forward in line to end of this word
	       (DO NIL (NIL)
		 (AND (OR ( I LLEN1)
			  ( (WORD-SYNTAX (AREF LINE1 I)) WORD-ALPHABETIC))
		      (RETURN NIL))
		 (SETQ I (1+ I)))
	       ;; Space forward in key to start of next word
	       ;; If key exhausted, the search succeeds
	       (DO NIL (NIL)
		 (COND (( J LEN)
			(RETURN-FROM LINES (CREATE-BP LINE1 I)))	;Point after last word
		       ((= (WORD-SYNTAX (AREF KEY J)) WORD-ALPHABETIC)
			(RETURN NIL)))
		 (SETQ J (1+ J)))
	       ;; Space forward in line to start of next word.  This may actually
	       ;; be on the next line.
	       (DO NIL (NIL)
		 (COND (( I LLEN1)		;This line used up, advance to next
			(AND (EQ LINE1 LIMIT) (RETURN-FROM MATCH-REMAINING-WORDS))
			(SETQ LINE1 (LINE-NEXT-IN-BUFFER LINE1)
			      LLEN1 (LINE-LENGTH LINE1)
			      I 0))
		       ((= (WORD-SYNTAX (AREF LINE1 I)) WORD-ALPHABETIC)
			(RETURN NIL))
		       (T
			(SETQ I (1+ I)))))
	       ;; Check that these two words match
	       (DO ((CH1 (AREF LINE1 I))
		    (CH2 (AREF KEY J)))
		   (NIL)
		 (COND (( (WORD-SYNTAX CH2) WORD-ALPHABETIC)	;key can be shorter than data
			(RETURN NIL))				;allowing word abbreviation
		       ((NOT (CHAR-EQUAL CH1 CH2))
			(RETURN-FROM MATCH-REMAINING-WORDS)))
		 (SETQ CH1 (IF ( (SETQ I (1+ I)) LLEN1) #\CR (AREF LINE1 I)))
		 (SETQ CH2 (IF ( (SETQ J (1+ J)) LEN) #\CR (AREF KEY J)))))
	     (SETQ IDX (1+ IDX)))		;search for next instance of first word
           (AND (EQ LINE LIMIT)
                (RETURN (AND FIXUP-P (COPY-BP LIMIT-BP))))))
        (T
         (DO-NAMED LINES
             ((LINE (BP-LINE BP) (LINE-PREVIOUS-IN-BUFFER LINE))
              (LIMIT (BP-LINE LIMIT-BP))
              (FORWARD-LIMIT (BP-LINE (INTERVAL-LAST-BP *INTERVAL*)))
	      (IDX (BP-INDEX BP) NIL))
             (NIL)
           (DO-NAMED PER-LINE
               ((LLEN (LINE-LENGTH LINE)))
               (NIL)
             (OR (AND (OR (NULL IDX) (NOT (MINUSP IDX)))
		      (SETQ IDX (STRING-REVERSE-SEARCH KEY1 LINE IDX)))
                 (RETURN NIL))
	     (DO-NAMED MATCH-REMAINING-WORDS
		 ((I IDX)			;I index of character in line
		  (J LEN1)			;J index in search key
		  (LINE1 LINE)			;Copy these in case we advance to next line
		  (LLEN1 LLEN))
		 (NIL)
	       ;; Space forward in line to end of this word
	       (DO NIL (NIL)
		 (AND (OR ( I LLEN1)
			  ( (WORD-SYNTAX (AREF LINE1 I)) WORD-ALPHABETIC))
		      (RETURN NIL))
		 (SETQ I (1+ I)))
	       ;; Space forward in key to start of next word
	       ;; If key exhausted, the search succeeds
	       (DO NIL (NIL)
		 (COND (( J LEN)
			(RETURN-FROM LINES (CREATE-BP LINE IDX))) ;Point before first word
		       ((= (WORD-SYNTAX (AREF KEY J)) WORD-ALPHABETIC)
			(RETURN NIL)))
		 (SETQ J (1+ J)))
	       ;; Space forward in line to start of next word.  This may actually
	       ;; be on the next line.
	       (DO NIL (NIL)
		 (COND (( I LLEN1)		;This line used up, advance to next
			(AND (EQ LINE1 FORWARD-LIMIT) (RETURN-FROM MATCH-REMAINING-WORDS))
			(SETQ LINE1 (LINE-NEXT-IN-BUFFER LINE1)
			      LLEN1 (LINE-LENGTH LINE1)
			      I 0))
		       ((= (WORD-SYNTAX (AREF LINE1 I)) WORD-ALPHABETIC)
			(RETURN NIL))
		       (T
			(SETQ I (1+ I)))))
	       ;; Check that these two words match
	       (DO ((CH1 (AREF LINE1 I))
		    (CH2 (AREF KEY J)))
		   (NIL)
		 (COND (( (WORD-SYNTAX CH2) WORD-ALPHABETIC)	;key can be shorter than data
			(RETURN NIL))				;allowing word abbreviation
		       ((NOT (CHAR-EQUAL CH1 CH2))
			(RETURN-FROM MATCH-REMAINING-WORDS)))
		 (SETQ CH1 (IF ( (SETQ I (1+ I)) LLEN1) #\CR (AREF LINE1 I)))
		 (SETQ CH2 (IF ( (SETQ J (1+ J)) LEN) #\CR (AREF KEY J)))))
	     (SETQ IDX (+ IDX (STRING-LENGTH KEY1) -1)))
           (AND (EQ LINE LIMIT)
                (RETURN (AND FIXUP-P (COPY-BP LIMIT-BP))))))))

(DEFUN SEARCH-SET (BP LIST &OPTIONAL REVERSEP FIXUP-P LIMIT-BP
				     (CASE-DEPENDENT-P NIL)	;---
			   &AUX CH)
  CASE-DEPENDENT-P
  (OR LIMIT-BP (SETQ LIMIT-BP (IF REVERSEP
				  (INTERVAL-FIRST-BP *INTERVAL*)
				  (INTERVAL-LAST-BP *INTERVAL*))))
  (IF (NOT REVERSEP)
      (CHARMAP (BP LIMIT-BP (AND FIXUP-P LIMIT-BP))
	(AND (MEM #'CHAR-EQUAL (SETQ CH (CHARMAP-CHAR)) LIST)
	     (CHARMAP-RETURN (VALUES (CHARMAP-BP-AFTER) CH))))
      (RCHARMAP (BP LIMIT-BP (AND FIXUP-P LIMIT-BP))
	(AND (MEM #'CHAR-EQUAL (SETQ CH (RCHARMAP-CHAR)) LIST)
	     (RCHARMAP-RETURN (VALUES (RCHARMAP-BP-BEFORE) CH))))))

(DEFVAR *LAST-DELIMITED-SEARCH-STRING* NIL)
(DEFVAR *LAST-DELIMITED-SEARCH-STRING-WITH-DELIMITERS*)

;;; DELIMITED-SEARCH moved to later in the file, after the FSM search code.

(DEFUN SEARCH-RING-PUSH (STRING FCN)
  (LET ((STRING (CAAR *SEARCH-RING*)))
    (WHEN (OR (CHARACTERP STRING)
	      (AND (STRINGP STRING)
		   ( (STRING-LENGTH STRING) 1)))
      (SETQ *SEARCH-RING* (CDR *SEARCH-RING*))))
  (PUSH (LIST STRING FCN) *SEARCH-RING*)
  (AND (> (LENGTH *SEARCH-RING*) *SEARCH-RING-MAX*)
       (DELETE-LAST-ELEMENT *SEARCH-RING*)))

(DEFUN SEARCH-RING-POP (&AUX KEY FCN)
  (COND ((NULL *SEARCH-RING*)
	 (BARF))
	(T
	 (SETQ KEY (CAAR *SEARCH-RING*)
	       FCN (CADAR *SEARCH-RING*))
	 (SETQ *SEARCH-RING*
	       (NCONC (CDR *SEARCH-RING*)
		      (RPLACD *SEARCH-RING* NIL)))
	 (VALUES KEY FCN))))

;;; Returns the number of replacements that were made.
(DEFUN REPLACE-STRING (BP FROM TO &OPTIONAL TIMES)
  ;; If from isn't all lowercase, user probably has something specific in mind
  ;; also if the two strings are string-equal (but different case).
  (LET-BUFFER-VARIABLE (*CASE-REPLACE-P*
			 (AND (NOT (STRING-HAS-SOME-UPPERCASE-P FROM))
			      (NOT (STRING-EQUAL FROM TO))
			      *CASE-REPLACE-P*))
    (LET-BUFFER-VARIABLE (*STYLE-REPLACE-P*
			   (AND (OR (NOT (STRING-HAS-SOME-STYLE-P FROM))
				    (NOT (STRING-HAS-SOME-STYLE-P TO)))
				(NOT (STRINGS-HAVE-SAME-STYLE FROM TO))
				*STYLE-REPLACE-P*))
      (OR TIMES (SETQ TIMES -1))
      (WITH-UNDO-SAVE-SPARSE ("Replace" BP
			      :TEST (NOT *UNDO-EACH-REPLACE-SEPARATELY*)
			      :FLAVOR 'SPARSE-REPLACE-CHANGE-RECORD
			      :FROM-STRING FROM :TO-STRING TO)
	(DO ((I 0 (1+ I))
	     (LEN (STRING-LENGTH FROM))
	     BP1)
	    ((= I TIMES) I)
	  (OR (SETQ BP (SEARCH BP FROM)) (RETURN I))
	  (SETQ BP1 (FORWARD-CHAR BP (- LEN)))
	  (COND (*SPARSE-CHANGE-ARRAY*
		 (RECORD-SPARSE-CHANGE BP1 BP (STRING-LENGTH TO))
		 (LET ((*ENABLE-CHANGE-RECORDING* NIL))
		   (SETQ BP (CASE-REPLACE BP1 BP TO T))))
		(T
		 (WITH-CUSTOM-UNDO-SAVE (BP1 BP
					     (MAKE-REPLACE-CHANGE-RECORD BP1 BP 
						(FINALIZE-BP-POSITIONS BP-POSITIONS) OLD-TEXT)
					     :OLD-TEXT OLD-TEXT)
		   (SETQ BP (CASE-REPLACE BP1 BP TO T))))))))))

;; Replace the given interval with the given chars.  If *case-replace-p*
;; is set, attempt to maintain case compatibility.  Returns a BP to the end
;; of the newly inserted stuff.
(DEFUN CASE-REPLACE (BP1 BP2 TO &OPTIONAL IN-ORDER-P)
  (LET (BP WORD-FIRST-CHAR WORD-SECOND-CHAR STRING-FIRST-CHAR)
    (FLET ((FIRST-NON-WS-CHAR (START-BP LAST-BP)
	     (LET ((BP (FORWARD-OVER *WHITESPACE-CHARS* START-BP (FORWARD-CHAR LAST-BP 1 T))))
	       (WHEN (BP-D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")=0 LAST-BP BP)		; whole string of interest is whitespace
		 (SETQ BP START-BP))		; so give up and use first character
	       (BP-CHAR BP))))
      (OR IN-ORDER-P (ORDER-BPS BP1 BP2))
      (WITH-BP (BP3 BP1 ':NORMAL)
	(COND ((NOT *CASE-REPLACE-P*)
	       (SETQ STRING-FIRST-CHAR (FIRST-NON-WS-CHAR BP1 BP2))
	       (DELETE-INTERVAL BP1 BP2 T)
	       (INSERT BP3 (IF *STYLE-REPLACE-P*
			       TO
			     (IN-CURRENT-STYLE TO (SI:CHAR-STYLE-INDEX STRING-FIRST-CHAR)))))
	      (T
	       ;; Get the string's first char, to determine current character style
	       (SETQ STRING-FIRST-CHAR (FIRST-NON-WS-CHAR BP1 BP2))
	       ;; Get the first alphabetic char, and following char.
	       (SETQ BP (FORWARD-TO-WORD BP1 1 T))
	       (IF (BP-< BP BP2)
		   (PROGN 
		     (SETQ WORD-FIRST-CHAR (BP-CHAR BP))
		     (SETQ BP (FORWARD-CHAR BP 1 T))
		     (SETQ WORD-SECOND-CHAR (BP-CHAR BP)))
		   ;; All whitespace, give up
		   (SETQ WORD-FIRST-CHAR (SETQ WORD-SECOND-CHAR STRING-FIRST-CHAR)))
	       ;; Now do the replacement, leaving BP3 and BP2 denoting the region.
	       ;; Try to preserve style by copying it from the first character replaced
	       (DELETE-INTERVAL BP1 BP2)
	       (SETQ BP2 (INSERT BP3 (IF *STYLE-REPLACE-P*
					 TO
				       (IN-CURRENT-STYLE
					 TO (SI:CHAR-STYLE-INDEX STRING-FIRST-CHAR)))))
	       (COND ((UPPER-CASE-P WORD-FIRST-CHAR)
		      (COND ((OR (UPPER-CASE-P WORD-SECOND-CHAR)
				 (AND (NOT (LOWER-CASE-P WORD-SECOND-CHAR))
				      (SEND (SEND *INTERVAL* :MAJOR-MODE) ':ALL-UPPERCASE)))
			     ;; They are both upper case or the second one is not alphabetic
			     ;; and this mode has all uppercase.  Uppercasify the whole thing.
			     (UPCASE-INTERVAL BP3 BP2 T))
			    (T
			     ;; Only the first is uppercase.  Capitalize on this fact.
			     (UPCASE-CHAR BP3)))))
	       BP2))))))



;;; FSM character search

;; These bits live in the char-bits field of either the input string
;; or the fsm string
(DEFCONST %FSM-CTL-FLAG #2r0001)	;this is a control character in input string
(DEFCONST %FSM-NOT      #2r0001)	;match any but this char
(DEFCONST %FSM-STAR     #2r0010)	;match zero or more of this char
(DEFCONST %FSM-SET      #2r0100)	;match member of set
(DEFCONST %FSM-STAR1	#2r1000)	;match one or more of this char
(DEFCONST %FSM-NOOP (CODE-CHAR 377 17))	;ignore this when building fsm

;;; Set lists, a list in place of a character means all characters in that range
;;; inclusive.  A symbol in place of the whole list means a predicate applied to
;;; all characters.
(DEFVAR *FSM-SEARCH-SET-LIST*
  '((#\SP #\TAB #\BS)			;0 - linear whitespace
    (#\SP #\TAB #\BS #\CR)		;1 - all whitespace
    ((#/A #/Z) (#/a #/z))		;2 - alphabetic
    ((#/0 #/9))				;3 - digits
    ((#/A #/Z))				;4 - uppercase
    FSM-WORD-DELIMITER-CHAR-P		;5 - word delimiter
    FSM-ATOM-DELIMITER-CHAR-P		;6 - atom delimiter
    FSM-TRUE				;7 - any character
    FSM-SYMBOL-DELIMITER-CHAR-P		;8 - symbol delimiter or colon
    ))

(DEFVAR *FSM-STRING-LIST* NIL)		;strings last searched for
(DEFVAR *FSM-CHARACTER-TABLE*)		;character  character_type
(DEFVAR *FSM-STATE-TABLE*)		;state,character_type  new_state
(DEFVAR *FSM-WORD-TABLE*)		;state  word_found
(DEFVAR *FSM-SEARCH-SET-TABLE*)		;search_set  list of character_type's
(DEFVAR *FSM-BACKPOINTER-TABLE*)	;state  back_state
(DEFVAR *FSM-CHARACTER-SET-TABLE*)	;character  set_number's
(DEFVAR *FSM-CHARACTER-SET-TABLE-16*)	;indirect array to above

;;; Build the fsm from the string list
(DEFUN BUILD-FSM (STRING-LIST
		  &OPTIONAL (CASE-DEPENDENT-P NIL)	;---
		  &AUX NCHARN NSTATES)
  ;; This used to use *ALPHABETIC-CASE-AFFECTS-SEARCH* as an argument, expecting
  ;; that to change comparisons hererin. That don't work any more.
  (SETQ *FSM-STRING-LIST* STRING-LIST)
  (SETQ NCHARN (BUILD-FSM-CHARACTER-SET STRING-LIST CASE-DEPENDENT-P))
  (SETQ NSTATES (BUILD-FSM-TREE STRING-LIST NCHARN))
  (CLEAN-FSM NSTATES NCHARN))

;;; Build up the character translation tables, returns number of character types
(DEFUN BUILD-FSM-CHARACTER-SET (STRING-LIST CASE-DEPENDENT-P &AUX (MAXCHAR 0))
  ;; First pass, get all the alphabetic characters
  (OR (VARIABLE-BOUNDP *FSM-CHARACTER-TABLE*)
      (SETQ *FSM-CHARACTER-TABLE* (MAKE-ARRAY 400 :TYPE 'SYS:ART-FAT-STRING)))
  (SI:FILL-ARRAY *FSM-CHARACTER-TABLE* NIL (CODE-CHAR 0))
  (TV:DOLIST-NOTING-PROGRESS (STRING STRING-LIST "Building FSM search character type tables")
    (DO ((I 0 (1+ I))
	 (LEN (STRING-LENGTH STRING))
	 (CH) (CHAR))
	(( I LEN))
      (OR (BIT-TEST %FSM-SET (CHAR-BITS (SETQ CHAR (AREF STRING I))))
	  (COND ((CHAR= (AREF *FSM-CHARACTER-TABLE* (SETQ CH (CHAR-CODE CHAR)))
			(CODE-CHAR 0))
		 (ASET (CODE-CHAR (SETQ MAXCHAR (1+ MAXCHAR))) *FSM-CHARACTER-TABLE* CH)
		 (AND (NOT CASE-DEPENDENT-P)
		      (OR (AND (CHAR CHAR #/A) (CHAR CHAR #/Z))
			  (AND (CHAR CHAR #/a) (CHAR CHAR #/z)))
		      (ASET (CODE-CHAR MAXCHAR) *FSM-CHARACTER-TABLE* (LOGXOR CH 40))))))))
  ;; Second pass, get the character types for all the sets mentioned
  (IF (NOT (VARIABLE-BOUNDP *FSM-CHARACTER-SET-TABLE*))
      (SETQ *FSM-CHARACTER-SET-TABLE* (MAKE-ARRAY '(400 16.) :TYPE 'ART-1B)
	    *FSM-CHARACTER-SET-TABLE-16*
	      (MAKE-ARRAY 400 :TYPE 'SYS:ART-16B
			  ':DISPLACED-TO *FSM-CHARACTER-SET-TABLE*))
      (SI:FILL-ARRAY *FSM-CHARACTER-SET-TABLE-16* NIL 0))
  (LET ((LEN (LENGTH *FSM-SEARCH-SET-LIST*)))
    (IF (OR (NOT (VARIABLE-BOUNDP *FSM-SEARCH-SET-TABLE*))
	    (< (ARRAY-LENGTH *FSM-SEARCH-SET-TABLE*) LEN))
	(SETQ *FSM-SEARCH-SET-TABLE* (MAKE-ARRAY LEN))
	(SI:FILL-ARRAY *FSM-SEARCH-SET-TABLE* NIL NIL)))
  (TV:DOLIST-NOTING-PROGRESS (STRING STRING-LIST "Building FSM search sets")
    (DO ((I 0 (1+ I))
	 (LEN (STRING-LENGTH STRING))
	 (CH) (CHAR))
	(( I LEN))
      (SETQ CHAR (AREF STRING I))
      (AND (CHAR CHAR %FSM-NOOP)
	   (BIT-TEST %FSM-SET (CHAR-BITS CHAR))
	   (NOT (AREF *FSM-SEARCH-SET-TABLE* (SETQ CH (CHAR-CODE CHAR))))
	     (LET ((LIST NIL))
	       (MAP-OVER-FSM-SEARCH-SET CH
		 #'(LAMBDA (SET CH &AUX CHARN)
		     (IF (CHAR= (SETQ CHARN (AREF *FSM-CHARACTER-TABLE* (CHAR-CODE CH)))
				(CODE-CHAR 0))
			 (ASET 1 *FSM-CHARACTER-SET-TABLE* (CHAR-CODE CH) SET)
			 (SETQ CHARN (CHAR-CODE CHARN))	;Numbers in *FSM-SEARCH-SET-TABLE*
			 (OR (MEM #'= CHARN LIST) (PUSH CHARN LIST)))))
	       (ASET (NREVERSE LIST) *FSM-SEARCH-SET-TABLE* CH)))))
  ;; Now assign character types for all the set intersections
  (DO ((CH 0 (1+ CH))
       (SET-ALIST NIL)
       (MASK) (ENTRY))
      (( CH 400))
    (COND ((NOT (ZEROP (SETQ MASK (AREF *FSM-CHARACTER-SET-TABLE-16* CH))))
	   (COND ((NOT (SETQ ENTRY (ASSQ MASK SET-ALIST)))
		  (PUSH (SETQ ENTRY (CONS MASK (SETQ MAXCHAR (1+ MAXCHAR)))) SET-ALIST)
		  (DO ((SET 0 (1+ SET))
		       (BIT 0001 (+ BIT 0100)))
		      (( SET 16.))
		    (AND (LDB-TEST BIT MASK)
			 (PUSH MAXCHAR (AREF *FSM-SEARCH-SET-TABLE* SET))))))
	   (ASET (CODE-CHAR (CDR ENTRY)) *FSM-CHARACTER-TABLE* CH))))
  ;; Finally return the number of character types
  (1+ MAXCHAR))

;;; Apply FUNCTION to all members of a character set,
;;; FUNCTION is caled with SET-NUMBER and character
(DEFUN MAP-OVER-FSM-SEARCH-SET (SET-NUMBER FUNCTION &AUX SET)
  (SETQ SET (NTH SET-NUMBER *FSM-SEARCH-SET-LIST*))
  (IF (NLISTP SET)
      (DOTIMES (CH 400)
	(AND (FUNCALL SET (CODE-CHAR CH)) (FUNCALL FUNCTION SET-NUMBER (CODE-CHAR CH))))
      (DOLIST (CHAR SET)
	(IF (LISTP CHAR)
	    (DO ((CH (CHAR-CODE (CAR CHAR)) (1+ CH))
		 (LIM (CHAR-CODE (CADR CHAR))))
		((> CH LIM))
	      (FUNCALL FUNCTION SET-NUMBER (CODE-CHAR CH)))
	    (FUNCALL FUNCTION SET-NUMBER CHAR)))))

(DEFUN FSM-WORD-DELIMITER-CHAR-P (CH)
  (OR (> (CHAR-CODE CH) 220) (= (WORD-SYNTAX CH) WORD-DELIMITER)))

(DEFUN FSM-ATOM-DELIMITER-CHAR-P (CH)
  (OR (> (CHAR-CODE CH) 220) (= (ATOM-WORD-SYNTAX CH) WORD-DELIMITER)))

(DEFUN FSM-SYMBOL-DELIMITER-CHAR-P (CH)
  (OR (> (CHAR-CODE CH) 220)
      (LET ((SYNTAX (LIST-SYNTAX CH)))
	(NOT (OR (= SYNTAX LIST-ALPHABETIC)
		 (= SYNTAX LIST-SLASH)
		 (= SYNTAX LIST-VERTICAL-BAR))))))

(DEFUN FSM-TRUE (IGNORE) T)

;;; Build the actual tree from the strings, NCHARN is the number of character types,
;;; Returns the number of states
(DEFUN BUILD-FSM-TREE (STRING-LIST *NCHARN* &AUX (*MAXSTATE* 0))
  (DECLARE (SPECIAL *NCHARN* *MAXSTATE*))
  (UNLESS (VARIABLE-BOUNDP *FSM-STATE-TABLE*)
    (SETQ *FSM-STATE-TABLE* (MAKE-ARRAY '(1000. 200) ':TYPE 'ART-16B)))
  (SI:FILL-ARRAY *FSM-STATE-TABLE* NIL 0)
  (UNLESS (VARIABLE-BOUNDP *FSM-WORD-TABLE*)
    (SETQ *FSM-WORD-TABLE* (MAKE-ARRAY 1000. ':TYPE 'ART-Q)))
  (SI:FILL-ARRAY *FSM-WORD-TABLE* NIL NIL)
  (TV:DOLIST-NOTING-PROGRESS (STRING STRING-LIST "Building FSM search tree")
    (BUILD-FSM-TREE-1 STRING 0 0 (STRING-LENGTH STRING)))
  (1+ *MAXSTATE*))

;; Handle a single character
(DEFUN BUILD-FSM-TREE-1 (STRING INDEX STATE LENGTH &AUX CHAR NOT-P STAR-P SET-P CH STAR1-P)
  (DECLARE (SPECIAL *NCHARN*))
  (COND (( INDEX LENGTH)
	 (WHEN ( STATE (ARRAY-LENGTH *FSM-WORD-TABLE*))
	   (ADJUST-ARRAY-SIZE *FSM-WORD-TABLE* (+ STATE (// STATE 2)))
	   (ARRAY-GROW *FSM-STATE-TABLE* (ARRAY-LENGTH *FSM-WORD-TABLE*) 200))
	 (ASET STRING *FSM-WORD-TABLE* STATE))	;End of string, save winner
	((CHAR= (SETQ CHAR (AREF STRING INDEX)) %FSM-NOOP)
	 (BUILD-FSM-TREE-1 STRING (1+ INDEX) STATE LENGTH))
	(T
	 (LET ((BITS (CHAR-BITS CHAR)))
	   (SETQ NOT-P (BIT-TEST %FSM-NOT BITS)
		 STAR-P (BIT-TEST %FSM-STAR BITS)
		 SET-P (BIT-TEST %FSM-SET BITS)
		 STAR1-P (BIT-TEST %FSM-STAR1 BITS)
		 CH (CHAR-CODE CHAR)))
	 (IF SET-P
	     (LET ((SET (AREF *FSM-SEARCH-SET-TABLE* CH)))
	       (IF NOT-P
		   (DOTIMES (NCH *NCHARN*)
		     (OR (MEM #'= NCH SET)
			 (BUILD-FSM-TREE-2 STRING INDEX STATE LENGTH NCH STAR-P STAR1-P)))
		   (DOLIST (NCH SET)
		     (BUILD-FSM-TREE-2 STRING INDEX STATE LENGTH NCH STAR-P STAR1-P))))
	     (SETQ CH (CHAR-CODE (AREF *FSM-CHARACTER-TABLE* CH)))
	     (IF NOT-P
		 (DOTIMES (NCH *NCHARN*)
		   (OR (= NCH CH)
		       (BUILD-FSM-TREE-2 STRING INDEX STATE LENGTH NCH STAR-P STAR1-P)))
		 (BUILD-FSM-TREE-2 STRING INDEX STATE LENGTH CH STAR-P STAR1-P))))))

;; Handle a single state transition
(DEFUN BUILD-FSM-TREE-2 (STRING INDEX STATE LENGTH CHARN STAR-P STAR1-P &AUX NEW-STATE)
  (DECLARE (SPECIAL *MAXSTATE*))
  (AND (OR STAR-P STAR1-P) (ASET (SETQ NEW-STATE STATE) *FSM-STATE-TABLE* STATE CHARN))
  (WHEN (OR (NOT STAR-P) STAR1-P)
    (WHEN (ZEROP (SETQ NEW-STATE (AREF *FSM-STATE-TABLE* STATE CHARN)))
      (ASET (SETQ NEW-STATE (SETQ *MAXSTATE* (1+ *MAXSTATE*)))
	    *FSM-STATE-TABLE* STATE CHARN)
      (WHEN ( *MAXSTATE* (CL:ARRAY-DIMENSION *FSM-STATE-TABLE* 0))
	(SETQ *FSM-STATE-TABLE* (CL:ADJUST-ARRAY *FSM-STATE-TABLE*
						 (LIST (FLOOR (* *MAXSTATE* 1.5))
						       (CL:ARRAY-DIMENSION *FSM-STATE-TABLE*
									   1)))))))
  (BUILD-FSM-TREE-1 STRING (1+ INDEX) NEW-STATE LENGTH))

;;; Clean up the fsm and build up the backpointers
(DEFUN CLEAN-FSM (NSTATES NCHARS)
  ;; Initialization
  (IF (OR (NOT (VARIABLE-BOUNDP *FSM-BACKPOINTER-TABLE*))
	  (< (ARRAY-LENGTH *FSM-BACKPOINTER-TABLE*) NSTATES))
      (SETQ *FSM-BACKPOINTER-TABLE* (MAKE-ARRAY NSTATES ':TYPE 'ART-Q))
      (SI:FILL-ARRAY *FSM-BACKPOINTER-TABLE* NIL NIL))
  ;; Fill in *FSM-BACKPOINTER-TABLE*.  For state A, reached by sequence WXYZ, the backpointer
  ;; of A is the state that would be reached by sequence XYZ (no W on the front).
  (TV:DOTIMES-NOTING-PROGRESS (STATE NSTATES "Finishing FSM search tables (pass 1)")
    (DOTIMES (CH NCHARS)
      (LET ((NEW-STATE (AREF *FSM-STATE-TABLE* STATE CH)))
	(AND (> NEW-STATE STATE) (NULL (AREF *FSM-BACKPOINTER-TABLE* NEW-STATE))
	     (LET ((GCTAIL (LET ((BACKPTR (AREF *FSM-BACKPOINTER-TABLE* STATE)))
			     (IF BACKPTR (AREF *FSM-STATE-TABLE* BACKPTR CH) 0))))
	       (ASET GCTAIL *FSM-BACKPOINTER-TABLE* NEW-STATE))))))
  ;; Use the computed backpointers to fill in the failure transitions in the state table
  (TV:DOTIMES-NOTING-PROGRESS (STATE NSTATES "Finishing FSM search tables (pass 2)")
    (LET ((BACKPTR (AREF *FSM-BACKPOINTER-TABLE* STATE)))
      (WHEN BACKPTR
	(UNLESS (AREF *FSM-WORD-TABLE* STATE)
	  (ASET (AREF *FSM-WORD-TABLE* BACKPTR) *FSM-WORD-TABLE* STATE))
	(DOTIMES (CH NCHARS)
	  (WHEN (ZEROP (AREF *FSM-STATE-TABLE* STATE CH))
	    (ASET (AREF *FSM-STATE-TABLE* BACKPTR CH)
		  *FSM-STATE-TABLE* STATE CH))))
      ;; Recycle the table to make it useful somehow for FSM-STRING-SEARCH, FSM-EXPR-SEARCH
      (AND (LET ((WORD (AND BACKPTR (AREF *FSM-WORD-TABLE* BACKPTR))))
	     (OR (NULL WORD) (EQ WORD (AREF *FSM-WORD-TABLE* STATE))))
	   (ASET (AND BACKPTR (AREF *FSM-BACKPOINTER-TABLE* BACKPTR))
		 *FSM-BACKPOINTER-TABLE* STATE)))))

(DEFSUBST FSM-CHARACTER-TABLE (CHAR)
  (LET ((CODE (CHAR-CODE CHAR)))
    (IF (< CODE 400) (AREF *FSM-CHARACTER-TABLE* CODE) (CODE-CHAR 0))))

;;; Attempt a matching of a string
(DEFUN MATCH-FSM (STRING)
  (DO ((I 0 (1+ I))
       (LEN (STRING-LENGTH STRING))
       (LIST NIL)
       (STATE 0)
       (CH))
      (( I LEN) (NREVERSE LIST))
    (SETQ CH (FSM-CHARACTER-TABLE (AREF STRING I))
	  STATE (AREF *FSM-STATE-TABLE* STATE CH))
    (DO ((STATE STATE (AREF *FSM-BACKPOINTER-TABLE* STATE))
	 (OSTATE NIL STATE)
	 (WORD))
	((OR (NULL STATE) (EQ STATE OSTATE)))
      (OR (SETQ WORD (AREF *FSM-WORD-TABLE* STATE))
	  (RETURN NIL))
      (PUSH (LIST (1+ I) WORD) LIST))))

;;; Look for a matching pattern via fsm search
(DEFUN FSM-STRING-SEARCH (KEY STRING &OPTIONAL FROM TO
				     &AUX (LEN (STRING-LENGTH STRING))
					  (STRINGS (CAR KEY)) (EXPR (CADR KEY))
					  (CR-P (CADDR KEY)))
  (OR (EQ STRINGS *FSM-STRING-LIST*)
      (BUILD-FSM STRINGS))
  (OR FROM (SETQ FROM (IF CR-P -1 0)))
  (OR TO (SETQ TO (IF CR-P (1+ LEN) LEN)))
  (DO ((I FROM (1+ I))
       (LIST NIL)
       (STATE 0)
       (CH))
      (( I TO)
       (SETQ LIST (NREVERSE LIST))
       (IF EXPR (FUNCALL EXPR LIST) (CAAR LIST)))
    (SETQ CH (FSM-CHARACTER-TABLE (IF (OR (MINUSP I) ( I LEN)) #\CR (AREF STRING I)))
	  STATE (AREF *FSM-STATE-TABLE* STATE (CHAR-CODE CH)))
    (DO ((STATE STATE (AREF *FSM-BACKPOINTER-TABLE* STATE))
	 (OSTATE NIL STATE)
	 (WORD))
	((OR (NULL STATE) (EQ STATE OSTATE)))
      (OR (SETQ WORD (AREF *FSM-WORD-TABLE* STATE))
	  (RETURN NIL))
      (PUSH (LIST (1+ I) WORD) LIST))))

;;; Do fsm search within lines
(DEFUN FSM-SEARCH-WITHIN-LINES (BP KEY &OPTIONAL REVERSE-P FIXUP-P IGNORE LIMIT-BP
				       &AUX (START-LINE (BP-LINE BP))
					    (START-INDEX (BP-INDEX BP)))
  (OR LIMIT-BP (SETQ LIMIT-BP (IF REVERSE-P
				  (INTERVAL-FIRST-BP *INTERVAL*)
				  (INTERVAL-LAST-BP *INTERVAL*))))
  (IF (NOT REVERSE-P)
      (DO ((LINE START-LINE (LINE-NEXT-IN-BUFFER LINE))
	   (LAST-LINE (BP-LINE LIMIT-BP))
	   (LAST-INDEX (BP-INDEX LIMIT-BP))
	   (INDEX))
	  (NIL)
	(AND (SETQ INDEX (FSM-STRING-SEARCH KEY LINE
					    (AND (EQ LINE START-LINE) START-INDEX)
					    (AND (EQ LINE LAST-LINE) LAST-INDEX)))
	     (RETURN (CREATE-BP LINE INDEX)))
	(AND (EQ LINE LAST-LINE)
	     (RETURN (AND FIXUP-P LIMIT-BP))))
      (DO ((LINE START-LINE (LINE-NEXT-IN-BUFFER LINE))
	   (FIRST-LINE (BP-LINE LIMIT-BP))
	   (FIRST-INDEX (BP-INDEX LIMIT-BP))
	   (INDEX))
	  (NIL)
	(AND (SETQ INDEX (FSM-STRING-SEARCH KEY LINE
					    (AND (EQ LINE FIRST-LINE) FIRST-INDEX)
					    (AND (EQ LINE START-LINE) START-INDEX)))
	     (RETURN (CREATE-BP LINE INDEX)))
	(AND (EQ LINE FIRST-LINE)
	     (RETURN (AND FIXUP-P LIMIT-BP))))))

;;; Search by characters
(DEFUN FSM-SEARCH (BP STRINGS &OPTIONAL REVERSE-P FIXUP-P IGNORE LIMIT-BP (STATE 0)
			      &AUX WORD)
  (OR LIMIT-BP (SETQ LIMIT-BP (IF REVERSE-P
				  (INTERVAL-FIRST-BP *INTERVAL*)
				  (INTERVAL-LAST-BP *INTERVAL*))))
  (WHEN REVERSE-P
    (FERROR "Backwards FSM search does not work, please complain nicely to Bug-Zwei."))
  (OR (EQ STRINGS *FSM-STRING-LIST*)
      (BUILD-FSM STRINGS))
  (CHARMAP (BP LIMIT-BP (AND FIXUP-P LIMIT-BP))
    (SETQ STATE (AREF *FSM-STATE-TABLE* STATE
					(CHAR-CODE (FSM-CHARACTER-TABLE (CHARMAP-CHAR)))))
    (AND (SETQ WORD (AREF *FSM-WORD-TABLE* STATE))
	 (CHARMAP-RETURN (VALUES (CHARMAP-BP-AFTER) WORD STATE)))))

(DEFUN FSM-EXPR-SEARCH (BP KEY &OPTIONAL REVERSE-P FIXUP-P IGNORE LIMIT-BP (STATE 0)
			       &AUX (STRINGS (CAR KEY)) (EXPR (CADR KEY)) LIST)
  (WHEN REVERSE-P
    (FERROR "Backwards FSM search does not work, please complain nicely to Bug-Zwei."))
  (OR (EQ STRINGS *FSM-STRING-LIST*)
      (BUILD-FSM STRINGS))
  (CHARMAP (BP LIMIT-BP (AND FIXUP-P LIMIT-BP))
    (SETQ STATE (AREF *FSM-STATE-TABLE* STATE
		      (CHAR-CODE (FSM-CHARACTER-TABLE (CHARMAP-CHAR)))))
    (DO ((STATE STATE (AREF *FSM-BACKPOINTER-TABLE* STATE))
	 (OSTATE NIL STATE)
	 (WORD))
	((OR (NULL STATE) (EQ STATE OSTATE)))
      (OR (SETQ WORD (AREF *FSM-WORD-TABLE* STATE))
	  (RETURN NIL))
      (PUSH (LIST (CHARMAP-BP-BEFORE) WORD) LIST)))
  (SETQ LIST (NREVERSE LIST))
  (IF EXPR (FUNCALL EXPR LIST) (CAAR LIST)))

(DEFUN DELIMITED-SEARCH (BP STRING &OPTIONAL REVERSE-P FIXUP-P LIMIT-BP)
  ;; don't trip over repeat (c-S c-A c-D) handing in the same array with altered contents:
  (SETQ STRING (IF (STRING-EQUAL STRING *LAST-DELIMITED-SEARCH-STRING*)
		   *LAST-DELIMITED-SEARCH-STRING-WITH-DELIMITERS*
		   (LET* ((LENGTH (STRING-LENGTH STRING))
			  (NEW-STRING (MAKE-ARRAY (+ LENGTH 2) ':TYPE SYS:ART-FAT-STRING)))
		     (ASET (CODE-CHAR 5 %FSM-SET) NEW-STRING 0)
		     (COPY-ARRAY-PORTION STRING 0 LENGTH NEW-STRING 1 (1+ LENGTH))
		     (ASET (CODE-CHAR 5 %FSM-SET) NEW-STRING (1+ LENGTH))
		     (SETQ *LAST-DELIMITED-SEARCH-STRING* (SUBSTRING STRING 0)	;make a copy
			   *LAST-DELIMITED-SEARCH-STRING-WITH-DELIMITERS*
			   (NCONS NEW-STRING)))))
  (SETQ BP (FSM-SEARCH BP STRING REVERSE-P FIXUP-P NIL LIMIT-BP))
  (AND BP (IF REVERSE-P (IBP BP) (DBP BP))))


(DEFVAR *SEARCH-MINI-BUFFER-COMTAB*)
(DEFVAR *STRING-SEARCH-MINI-BUFFER-COMTAB*)
(DEFVAR *SEARCH-CONTROL-H-COMTAB*)
(DEFVAR *STRING-SEARCH-CONTROL-H-COMTAB*)
(DEFVAR *STRING-SEARCH-SINGLE-LINE-COMTAB*)
(DEFUN INITIALIZE-EXTENDED-SEARCH ()
  (COND ((NOT (VARIABLE-BOUNDP *SEARCH-MINI-BUFFER-COMTAB*))
	 (SETQ *SEARCH-CONTROL-H-COMTAB*
	       (SET-COMTAB NIL '(#/( COM-EXTENDED-SEARCH-OPEN
				 #/) COM-EXTENDED-SEARCH-CLOSE
				 #/ COM-EXTENDED-SEARCH-OR
				 #\c-O COM-EXTENDED-SEARCH-OR
				 #/ COM-EXTENDED-SEARCH-AND
				 #/& COM-EXTENDED-SEARCH-AND
				 #\c-A COM-EXTENDED-SEARCH-AND
				 #/~ COM-EXTENDED-SEARCH-NOT
				 #\c-N COM-EXTENDED-SEARCH-NOT
				 #\SP COM-EXTENDED-SEARCH-WHITESPACE
				 #/- COM-EXTENDED-SEARCH-DELIMITER
				 #/: COM-EXTENDED-SEARCH-SYMBOL-DELIMITER
				 #/A COM-EXTENDED-SEARCH-ALPHABETIC
				 #/9 COM-EXTENDED-SEARCH-DIGIT
				 #/* COM-EXTENDED-SEARCH-SOME
				 #\c-X COM-EXTENDED-SEARCH-ANY
				 #\HELP COM-DOCUMENT-CONTAINING-PREFIX-COMMAND
				 )))
	 (SET-COMTAB-CONTROL-INDIRECTION *SEARCH-CONTROL-H-COMTAB*)
	 (SETQ *SEARCH-MINI-BUFFER-COMTAB*
	       (SET-COMTAB NIL
			   (LIST #\HELP 'COM-DOCUMENT-EXTENDED-SEARCH
				 #\c-H (MAKE-EXTENDED-COMMAND *SEARCH-CONTROL-H-COMTAB*))))
	 (SET-COMTAB-INDIRECTION *SEARCH-MINI-BUFFER-COMTAB* *MINI-BUFFER-COMTAB*)))
  (COND ((NOT (VARIABLE-BOUNDP *STRING-SEARCH-CONTROL-H-COMTAB*))
	 (SETQ *STRING-SEARCH-CONTROL-H-COMTAB*
	       (SET-COMTAB NIL '(#\c-B COM-EXTENDED-SEARCH-BEGINNING
				 #\c-E COM-EXTENDED-SEARCH-END
				 #\c-F COM-EXTENDED-SEARCH-TOP-LINE
				 #\c-R COM-EXTENDED-SEARCH-REVERSE)))
	 (SET-COMTAB-INDIRECTION *STRING-SEARCH-CONTROL-H-COMTAB* *SEARCH-CONTROL-H-COMTAB*)
	 (SETQ *STRING-SEARCH-MINI-BUFFER-COMTAB*
	       (SET-COMTAB NIL (LIST #\ALTMODE 'COM-END-OF-MINI-BUFFER
				     #\END 'COM-END-OF-MINI-BUFFER
				     #\HELP 'COM-DOCUMENT-EXTENDED-SEARCH
				     #\c-H (MAKE-EXTENDED-COMMAND
					     *STRING-SEARCH-CONTROL-H-COMTAB*))))
	 (SET-COMTAB-INDIRECTION *STRING-SEARCH-MINI-BUFFER-COMTAB*
				 *MINI-BUFFER-MULTI-LINE-COMTAB*)))
  (COND ((NOT (VARIABLE-BOUNDP *STRING-SEARCH-SINGLE-LINE-COMTAB*))
	 (SETQ *STRING-SEARCH-SINGLE-LINE-COMTAB*
	       (SET-COMTAB NIL '(#\CR COM-END-OF-MINI-BUFFER)))
	 (SET-COMTAB-INDIRECTION *STRING-SEARCH-SINGLE-LINE-COMTAB*
				 *STRING-SEARCH-MINI-BUFFER-COMTAB*))))

(ADD-INITIALIZATION "INITIALIZE-EXTENDED-SEARCH" '(INITIALIZE-EXTENDED-SEARCH)
		    '(:NORMAL) '*EDITOR-INITIALIZATION-LIST*)

(DEFUN GET-SEARCH-MINI-BUFFER-WINDOW ()
  (FUNCALL *MODE-LINE-WINDOW* ':SEARCH-MINI-BUFFER-WINDOW))

(DEFUN GET-EXTENDED-SEARCH-STRINGS (PROMPT &AUX STR STRINGS EXPR CR-P FUNCTION)
  (DECLARE (VALUES FUNCTION ARG))
  (SETQ STR (GET-EXTENDED-SEARCH-16B-STRING PROMPT))
  (MULTIPLE-VALUE (STRINGS EXPR CR-P)
    (PARSE-EXTENDED-SEARCH-STRING STR))
  (IF (OR (LISTP STRINGS) CR-P)
      (SETQ FUNCTION 'FSM-STRING-SEARCH
	    STRINGS (LIST (IF (LISTP STRINGS) STRINGS (NCONS STRINGS)) EXPR CR-P))
      (SETQ FUNCTION 'STRING-SEARCH))
  (VALUES FUNCTION STRINGS STR))

(DEFCOM COM-DOCUMENT-EXTENDED-SEARCH "Simple help for hairy search" ()
  (FORMAT T "~%You are typing in a search string.  Control-H is a prefix for more commands.")
  DIS-NONE)

(DEFCONST %FSM-OPEN-NEST 0)
(DEFCOM COM-EXTENDED-SEARCH-OPEN "Beginning of new nesting level" ()
  (INSERT-MOVING-POINT (CODE-CHAR %FSM-OPEN-NEST %FSM-CTL-FLAG))
  DIS-TEXT)

(DEFCONST %FSM-CLOSE-NEST 1)
(DEFCOM COM-EXTENDED-SEARCH-CLOSE "End of nesting level" ()
  (INSERT-MOVING-POINT (CODE-CHAR %FSM-CLOSE-NEST %FSM-CTL-FLAG))
  DIS-TEXT)

(DEFCONST %FSM-INFIX-OR 2)
(DEFCOM COM-EXTENDED-SEARCH-OR "Infix or of two strings" ()
  (INSERT-MOVING-POINT (CODE-CHAR %FSM-INFIX-OR %FSM-CTL-FLAG))
  DIS-TEXT)

(DEFCONST %FSM-INFIX-AND 3)
(DEFCOM COM-EXTENDED-SEARCH-AND "Infix and of two strings within lines" ()
  (INSERT-MOVING-POINT (CODE-CHAR %FSM-INFIX-AND %FSM-CTL-FLAG))
  DIS-TEXT)

(DEFCONST %FSM-NOT-CHAR 4)
(DEFCOM COM-EXTENDED-SEARCH-NOT "Negation on next character" ()
  (INSERT-MOVING-POINT (CODE-CHAR %FSM-NOT-CHAR %FSM-CTL-FLAG))
  DIS-TEXT)

(DEFCONST %FSM-WHITESPACE 5)
(DEFCOM COM-EXTENDED-SEARCH-WHITESPACE "Match any whitespace character" ()
  (INSERT-MOVING-POINT (CODE-CHAR %FSM-WHITESPACE %FSM-CTL-FLAG))
  DIS-TEXT)

(DEFCONST %FSM-ANY-NUMBER 6)
(DEFCOM COM-EXTENDED-SEARCH-SOME "Match any number of next character" ()
  (INSERT-MOVING-POINT (CODE-CHAR %FSM-ANY-NUMBER %FSM-CTL-FLAG))
  DIS-TEXT)

(DEFCONST %FSM-DELIMITER 7)
(DEFCOM COM-EXTENDED-SEARCH-DELIMITER "Match any delimiter" ()
  (INSERT-MOVING-POINT (CODE-CHAR %FSM-DELIMITER %FSM-CTL-FLAG))
  DIS-TEXT)

(DEFCONST %FSM-ALPHABETIC 10)
(DEFCOM COM-EXTENDED-SEARCH-ALPHABETIC "Match any alphabetic character" ()
  (INSERT-MOVING-POINT (CODE-CHAR %FSM-ALPHABETIC %FSM-CTL-FLAG))
  DIS-TEXT)

(DEFCONST %FSM-ANYTHING 11)
(DEFCOM COM-EXTENDED-SEARCH-ANY "Match any character" ()
  (INSERT-MOVING-POINT (CODE-CHAR %FSM-ANYTHING %FSM-CTL-FLAG))
  DIS-TEXT)

(DEFCONST %FSM-DIGIT 12)
(DEFCOM COM-EXTENDED-SEARCH-DIGIT "Match any digit character" ()
  (INSERT-MOVING-POINT (CODE-CHAR %FSM-DIGIT %FSM-CTL-FLAG))
  DIS-TEXT)

(DEFCONST %FSM-SYMBOL-DELIMITER 13)
(DEFCOM COM-EXTENDED-SEARCH-SYMBOL-DELIMITER "Match any symbol delimiter or colon" ()
  (INSERT-MOVING-POINT (CODE-CHAR %FSM-SYMBOL-DELIMITER %FSM-CTL-FLAG))
  DIS-TEXT)

(DEFCOM COM-EXTENDED-STRING-SEARCH "Search for a hairy string
String is read in a mini-buffer in which Control-H is a prefix for special search features."
	()
  (EXTENDED-STRING-SEARCH-INTERNAL NIL))

(DEFCOM COM-EXTENDED-REVERSE-STRING-SEARCH "Search for a hairy string backward
String is read in a mini-buffer in which Control-H is a prefix for special search features."
	()
  (EXTENDED-STRING-SEARCH-INTERNAL T))

;;--- These should probably be per-process, but I'm too lazy right now  --SWM
(DEFVAR *EXTENDED-STRING-SEARCH-BJ-P*)
(DEFVAR *EXTENDED-STRING-SEARCH-ZJ-P*)
(DEFVAR *EXTENDED-STRING-SEARCH-REVERSE-P*)
(DEFVAR *EXTENDED-STRING-SEARCH-TOP-LINE-P*)
(DEFVAR *EXTENDED-STRING-SEARCH-LAST-STRING* NIL)
(DEFVAR *EXTENDED-STRING-SEARCH-LAST-ARG*)
(DEFVAR *EXTENDED-STRING-SEARCH-LAST-FUNCTION*)
(DEFVAR *EXTENDED-STRING-SEARCH-SKIP-TABLE* NIL)
(DEFVAR *EXTENDED-STRING-SEARCH-REOCCURRENCE-TABLE* NIL)

(DEFVAR *EXTENDED-SEARCH-CHARACTER-NAMES*
  '("(" ")" "OR" "AND" "NOT" "WHITESPACE" "SOME" "DELIMITER" "ALPHABETIC" "ANY" "DIGIT"
    "SYMBOL-DELIMITER"))

(DEFMACRO WITH-EXTENDED-SEARCH-DISPLAY (&BODY BODY)
  `(LET ((TV:*FUNNY-CHAR-HOOK*
	   #'(LAMBDA (CH)
	       (AND (NOT (ZEROP (CHAR-BITS CH)))
		    (NTH (CHAR-CODE CH) *EXTENDED-SEARCH-CHARACTER-NAMES*)))))
     ,@BODY))

(DEFUN EXTENDED-STRING-SEARCH-INTERNAL (REVERSE-P)
  (LET ((BP (POINT)))
    (MULTIPLE-VALUE-BIND (FUNCTION ARG REVERSE-P BJ-P TOP-LINE-P)
	(GET-EXTENDED-STRING-SEARCH-STRINGS REVERSE-P)
      (WHEN BJ-P
	(SETQ BP (IF REVERSE-P (INTERVAL-LAST-BP *INTERVAL*) (INTERVAL-FIRST-BP *INTERVAL*))))
      (UNLESS (SETQ BP (FUNCALL FUNCTION BP ARG REVERSE-P))
	(WITH-EXTENDED-SEARCH-DISPLAY
	  (BARF "Search failed: ~A" *EXTENDED-STRING-SEARCH-LAST-STRING*)))
      (WHEN TOP-LINE-P
	(RECENTER-WINDOW *WINDOW* ':START BP)))
    (LET ((ORIG-PT (COPY-BP (POINT))))
      (MOVE-POINT BP)
      (MAYBE-PUSH-POINT ORIG-PT)))
  DIS-BPS)

;;; Read a string for string search and then return the function to use
(DEFUN GET-EXTENDED-STRING-SEARCH-STRINGS (&OPTIONAL *EXTENDED-STRING-SEARCH-REVERSE-P*
						     (PROMPT "Search:")
						     (COMTAB
						       *STRING-SEARCH-MINI-BUFFER-COMTAB*)
						     (DEFAULT
						       *EXTENDED-STRING-SEARCH-LAST-STRING*)
					   &AUX (*EXTENDED-STRING-SEARCH-BJ-P* NIL)
						(*EXTENDED-STRING-SEARCH-ZJ-P* NIL)
						(*EXTENDED-STRING-SEARCH-TOP-LINE-P* NIL))
  (DECLARE (VALUES FUNCTION ARG REVERSE-P BJ-P TOP-LINE-P SKIP REOCCURRENCE))
  (LET ((STRING (GET-EXTENDED-SEARCH-16B-STRING
		  PROMPT DEFAULT COMTAB
		  '((*EXTENDED-STRING-SEARCH-BJ-P* "BJ ")
		    (*EXTENDED-STRING-SEARCH-ZJ-P* "ZJ ")
		    (*EXTENDED-STRING-SEARCH-REVERSE-P* "Reverse ")
		    (*EXTENDED-STRING-SEARCH-TOP-LINE-P* "Top line ")))))
    (UNLESS (EQ STRING *EXTENDED-STRING-SEARCH-LAST-STRING*)
      (SETQ *EXTENDED-STRING-SEARCH-LAST-STRING* STRING)
      (MULTIPLE-VALUE-BIND (STRINGS EXPR CR-P)
	(PARSE-EXTENDED-SEARCH-STRING STRING)
	(IF (LISTP STRINGS)
	    (IF EXPR
		(SETQ *EXTENDED-STRING-SEARCH-LAST-FUNCTION* 'FSM-SEARCH-WITHIN-LINES
		      *EXTENDED-STRING-SEARCH-LAST-ARG* (LIST STRINGS EXPR CR-P))
	      (SETQ *EXTENDED-STRING-SEARCH-LAST-FUNCTION* 'FSM-SEARCH
		    *EXTENDED-STRING-SEARCH-LAST-ARG* STRINGS))
	  (SETQ *EXTENDED-STRING-SEARCH-LAST-FUNCTION* 'SEARCH
		*EXTENDED-STRING-SEARCH-LAST-ARG* STRINGS
		;; Always reallocate these tables, in case the user has
		;; nested Tags Searches
		*EXTENDED-STRING-SEARCH-SKIP-TABLE*
		  (GENERATE-BOYER-SKIP-TABLE STRINGS)
		*EXTENDED-STRING-SEARCH-REOCCURRENCE-TABLE*
		  (GENERATE-BOYER-REOCCURRENCE-TABLE STRINGS))))))
  (VALUES *EXTENDED-STRING-SEARCH-LAST-FUNCTION* *EXTENDED-STRING-SEARCH-LAST-ARG*
	    *EXTENDED-STRING-SEARCH-REVERSE-P*
	    (OR *EXTENDED-STRING-SEARCH-BJ-P* *EXTENDED-STRING-SEARCH-ZJ-P*)
	    *EXTENDED-STRING-SEARCH-TOP-LINE-P*
	    *EXTENDED-STRING-SEARCH-SKIP-TABLE*
	    *EXTENDED-STRING-SEARCH-REOCCURRENCE-TABLE*))

(DEFCOM COM-EXTENDED-SEARCH-BEGINNING "" ()
  (COND ((SETQ *EXTENDED-STRING-SEARCH-BJ-P* (NOT *EXTENDED-STRING-SEARCH-BJ-P*))
	 (SETQ *EXTENDED-STRING-SEARCH-ZJ-P* NIL
	       *EXTENDED-STRING-SEARCH-REVERSE-P* NIL)))
  DIS-NONE)

(DEFCOM COM-EXTENDED-SEARCH-END "" ()
  (COND ((SETQ *EXTENDED-STRING-SEARCH-ZJ-P* (NOT *EXTENDED-STRING-SEARCH-ZJ-P*))
	 (SETQ *EXTENDED-STRING-SEARCH-BJ-P* NIL
	       *EXTENDED-STRING-SEARCH-REVERSE-P* T)))
  DIS-NONE)

(DEFCOM COM-EXTENDED-SEARCH-TOP-LINE "" ()
  (SETQ *EXTENDED-STRING-SEARCH-TOP-LINE-P* (NOT *EXTENDED-STRING-SEARCH-TOP-LINE-P*))
  DIS-NONE)

(DEFCOM COM-EXTENDED-SEARCH-REVERSE "" ()
  (IF (SETQ *EXTENDED-STRING-SEARCH-REVERSE-P* (NOT *EXTENDED-STRING-SEARCH-REVERSE-P*))
      (SETQ *EXTENDED-STRING-SEARCH-BJ-P* NIL)
      (SETQ *EXTENDED-STRING-SEARCH-ZJ-P* NIL))
  DIS-NONE)

(DEFVAR *EXTENDED-SEARCH-CR-P*)
(DEFUN PARSE-EXTENDED-SEARCH-STRING (STRING &AUX *EXTENDED-SEARCH-CR-P* STRINGS EXPR LEN)
  (MULTIPLE-VALUE (STRINGS EXPR LEN)
    (PARSE-EXTENDED-SEARCH-STRING-1 (STRING-APPEND STRING) 0 (STRING-LENGTH STRING) 0))
  (AND (NLISTP STRINGS)
       (DOTIMES (I LEN)
	 (AND (NOT (ZEROP (CHAR-BITS (AREF STRINGS I))))	;? is this adequate?
	      (RETURN T)))
       (SETQ STRINGS (NCONS STRINGS)))
  (OR STRINGS (SETQ STRINGS ""))
  (AND EXPR
       (LET ((SYMBOL (GENSYM)))
	 (FSET SYMBOL `(LAMBDA (MATCHING-LIST) ,EXPR))
	 (COMPILE SYMBOL)
	 (SETQ EXPR SYMBOL)))
  (VALUES STRINGS EXPR *EXTENDED-SEARCH-CR-P*))

(DEFUN PARSE-EXTENDED-SEARCH-STRING-1 (STRING INDEX LENGTH PAREN-LEVEL)
  (DO ((I INDEX (1+ I))
       (SYN) (CH)
       (NEW-STRINGS) (NEW-EXPR)
       (OLD-STRINGS) (OLD-EXPR))
      (NIL)
    (MULTIPLE-VALUE (SYN CH I)
      (PARSE-EXTENDED-SEARCH-STRING-SYNTAX STRING I LENGTH))
    (IF (ZEROP SYN)
	(AND OLD-STRINGS (IF (LISTP OLD-STRINGS)
			     (DO ((OS OLD-STRINGS (CDR OS)))
				 ((NULL OS))
			       (SETF (CAR OS) (STRING-APPEND (CAR OS) CH)))
			     (SETQ OLD-STRINGS (STRING-APPEND OLD-STRINGS CH))))
	(OR OLD-STRINGS
	    (SETQ OLD-STRINGS (AND (NOT (= INDEX I)) (SUBSTRING STRING INDEX I))))
	(COND ((BIT-TEST 120000 SYN)		;EOF or CLOSE
	       (IF (PLUSP PAREN-LEVEL)
		   (AND (= SYN 100000)		;EOF
			(BARF "End of string inside parenthesis"))
		   (AND (= SYN 20000)		;CLOSE
			(BARF "Unmatched close")))
	       (RETURN (VALUES OLD-STRINGS OLD-EXPR I))))
	(COND ((= SYN 40000)			;OPEN
	       (MULTIPLE-VALUE (NEW-STRINGS NEW-EXPR I)
		 (PARSE-EXTENDED-SEARCH-STRING-1 STRING (1+ I) LENGTH (1+ PAREN-LEVEL)))
	       (IF (NOT OLD-STRINGS)
		   (SETQ OLD-STRINGS NEW-STRINGS)
		   (AND OLD-EXPR (BARF "I don't know how to combine these"))
		   (COND ((LISTP NEW-STRINGS)
			  (AND (LISTP OLD-STRINGS)
			       (BARF "I don't know how to combine these"))
			  (DO ((NS NEW-STRINGS (CDR NS)))
			      ((NULL NS) (SETQ OLD-STRINGS NEW-STRINGS))
			    (SETF (CAR NS) (STRING-APPEND OLD-STRINGS
							  (CAR NS)))))
			 ((LISTP OLD-STRINGS)
			  (DO ((OS OLD-STRINGS (CDR OS)))
			      ((NULL OS))
			    (SETF (CAR OS) (STRING-APPEND (CAR OS) NEW-STRINGS))))
			 (T
			  (SETQ OLD-STRINGS (STRING-APPEND OLD-STRINGS
							   NEW-STRINGS)))))
	       (SETQ OLD-EXPR NEW-EXPR))
	      (T		  
	       (OR OLD-STRINGS (BARF "Special token at the beginning of the string"))
	       (AND (OR (= SYN 10000) NEW-EXPR)
		    (OR OLD-EXPR
			(SETQ OLD-EXPR (IF (LISTP OLD-STRINGS)
					   (CONS 'OR
						 (MAPCAR #'EXTENDED-SEARCH-STRING-MATCHER
							 OLD-STRINGS))
					   (EXTENDED-SEARCH-STRING-MATCHER OLD-STRINGS)))))
	       (OR (CL:LISTP OLD-STRINGS)
		   (SETQ OLD-STRINGS (NCONS OLD-STRINGS)))
	       (MULTIPLE-VALUE (NEW-STRINGS NEW-EXPR I)
		 (PARSE-EXTENDED-SEARCH-STRING-1 STRING (1+ I) LENGTH PAREN-LEVEL))
	       (OR (CL:LISTP NEW-STRINGS)
		   (SETQ NEW-STRINGS (NCONS NEW-STRINGS)))
	       (IF (= SYN 4000)			;OR
		   (RETURN (VALUES (NCONC OLD-STRINGS NEW-STRINGS)
				   (AND NEW-EXPR `(OR ,OLD-EXPR ,NEW-EXPR))
				   I))
		   (OR NEW-EXPR			;AND
		       (SETQ NEW-EXPR (CONS 'OR
					    (MAPCAR #'EXTENDED-SEARCH-STRING-MATCHER
						    NEW-STRINGS))))
		   (RETURN (VALUES (NCONC OLD-STRINGS NEW-STRINGS)
				   `(AND ,OLD-EXPR ,NEW-EXPR)
				   I))))))))

(DEFUN PARSE-EXTENDED-SEARCH-STRING-SYNTAX (STRING INDEX LENGTH &OPTIONAL NOT-TOP-LEVEL
					    &AUX CH)
  (IF ( INDEX LENGTH)
      (IF NOT-TOP-LEVEL (BARF "EOF in special context") (VALUES 100000 NIL INDEX))
      (VALUES (IF (ZEROP (CHAR-BITS (SETQ CH (AREF STRING INDEX))))
		  (PROG1 0 (AND (CHAR-EQUAL CH #\CR) (SETQ *EXTENDED-SEARCH-CR-P* T)))
		(SELECTOR (SETQ CH (CHAR-CODE CH)) =
		  (%FSM-OPEN-NEST  40000)
		  (%FSM-CLOSE-NEST 20000)
		  (%FSM-INFIX-OR    4000)
		  (%FSM-INFIX-AND  10000)
		  ((%FSM-NOT-CHAR %FSM-ANY-NUMBER)
		   (MULTIPLE-VALUE-BIND (SYN NCH)
		       (PARSE-EXTENDED-SEARCH-STRING-SYNTAX STRING (1+ INDEX)
							    LENGTH T)
		     (OR (ZEROP SYN) (BARF "NOT modifier on a special character"))
		     (ASET (SETQ CH (PROG2 (CL:SETF (CHAR-BITS NCH)
						    ;; LOGIOR preserves %FSM-SET bit
						    (LOGIOR (CHAR-BITS NCH)
							    (SELECTOR CH =
							      (%FSM-NOT-CHAR   %FSM-NOT)
							      (%FSM-ANY-NUMBER %FSM-STAR1))))
					   NCH))
			   STRING INDEX)
		     ;; Overwrite the second character of the two-char sequence
		     (ASET %FSM-NOOP STRING (SETQ INDEX (1+ INDEX))))
		   0)
		  ((%FSM-WHITESPACE %FSM-DELIMITER %FSM-SYMBOL-DELIMITER
		    %FSM-ALPHABETIC %FSM-ANYTHING %FSM-DIGIT)
		   (ASET (SETQ CH (CODE-CHAR (SELECTOR CH =
					       (%FSM-WHITESPACE 0)
					       (%FSM-DELIMITER  5)
					       (%FSM-SYMBOL-DELIMITER 8)
					       (%FSM-ALPHABETIC 2)
					       (%FSM-ANYTHING   7)
					       (%FSM-DIGIT	3))
					     %FSM-SET))
			 STRING INDEX)
		   0)
		  (OTHERWISE 0)))
	      (CHARACTER CH) INDEX)))

(DEFUN EXTENDED-SEARCH-STRING-MATCHER (STRING)
  `(DO L MATCHING-LIST (CDR L) (NULL L)
     (AND (EQ (CADAR L) ',STRING) (RETURN (CAAR L)))))

;;; Special handling for search strings
(DEFSTRUCT (16B-STRING :ARRAY-LEADER :NAMED (:MAKE-ARRAY (:LENGTH 20. :TYPE 'ART-FAT-STRING)))
  (16B-STRING-LENGTH 0))

(DEFPROP 16B-STRING 16B-STRING-NAMED-STRUCTURE-INVOKE NAMED-STRUCTURE-INVOKE)
(DEFSELECT 16B-STRING-NAMED-STRUCTURE-INVOKE
  ((:PRINT-SELF) (STRING &OPTIONAL (STREAM STANDARD-OUTPUT) IGNORE SLASHIFY-P
			 &AUX READABLE-P LOZENGE-P)
   (AND (NOT (SETQ READABLE-P (ASS #'CHAR-EQUAL #/" (SI:RDTBL-/#-MACRO-ALIST READTABLE))))
	(SETQ LOZENGE-P (SEND STREAM ':OPERATION-HANDLED-P ':DISPLAY-LOZENGED-STRING)))
   (COND (SLASHIFY-P
	  (AND READABLE-P (FUNCALL STREAM ':TYO #/#))
	  (FUNCALL STREAM ':TYO (SI:PTTBL-OPEN-QUOTE-STRING READTABLE))))
   (LOOP FOR CH BEING THE ARRAY-ELEMENTS OF STRING
	 DO (IF (AND (NOT (ZEROP (CHAR-BITS CH))) LOZENGE-P)
		(SEND STREAM ':DISPLAY-LOZENGED-STRING
		      (NTH (CHAR-CODE CH) *EXTENDED-SEARCH-CHARACTER-NAMES*))
		(AND SLASHIFY-P
		     (< (CHAR-CODE CH) (SI:RDTBL-LIMIT READTABLE))
		     (NOT (ZEROP (LOGAND 16 (SI:RDTBL-BITS READTABLE (CHAR-CODE CH)))))
		     (FUNCALL STREAM ':TYO (SI:PTTBL-SLASH READTABLE)))
		(AND (NOT READABLE-P) (SETQ CH (MAKE-CHAR CH)))
		(SEND STREAM ':TYO CH)))
   (AND SLASHIFY-P
	(FUNCALL STREAM ':TYO (SI:PTTBL-CLOSE-QUOTE-STRING READTABLE)))))

(DEFUN 16B-STRING-NAME-STRING (16B-STRING)
  (WITH-OUTPUT-TO-STRING (STRING-STREAM)
    (PRINC 16B-STRING
	   #'(LAMBDA (OP &REST ARGS)
	       (SELECTQ OP
		 (:OPERATION-HANDLED-P
		  (OR (EQ (FIRST ARGS) ':DISPLAY-LOZENGED-STRING)
		      (LEXPR-SEND STRING-STREAM :OPERATION-HANDLED-P ARGS)))
		 (:DISPLAY-LOZENGED-STRING
		  (SEND STRING-STREAM :TYO #/<)
		  (SEND STRING-STREAM :STRING-OUT (FIRST ARGS))
		  (SEND STRING-STREAM :TYO #/>))
		 (OTHERWISE
		  (LEXPR-SEND STRING-STREAM OP ARGS)))))))

(DEFUN MY-/#/"-MACRO (IGNORE STREAM)
  (DO ((STRING (MAKE-16B-STRING))
       (CHAR)
       (SLASH-P NIL))
      (NIL)
    (SETQ CHAR (FUNCALL STREAM ':TYI))
    (COND (SLASH-P
	   (SETQ SLASH-P NIL)
	   (ARRAY-PUSH-EXTEND STRING CHAR))
	  ((CHAR-EQUAL CHAR #/")
	   (RETURN STRING))
	  ((CHAR-EQUAL CHAR #//)
	   (SETQ SLASH-P T))
	  (T
	   (ARRAY-PUSH-EXTEND STRING CHAR)))))

(DEFVAR SHARPSIGN-DOUBLEQUOTE-SYNTAX-READTABLE-ALIST NIL)

(DEFUN INITIALIZE-SHARPSIGN-DOUBLEQUOTE-READTABLE-FOR-SYNTAX (SYNTAX-NAME)
  (LET* ((ENTRY (ASSOC SYNTAX-NAME SHARPSIGN-DOUBLEQUOTE-SYNTAX-READTABLE-ALIST))
	 (RT (SECOND ENTRY)))
    (UNLESS (CL:READTABLEP RT)
      (SETQ RT (ZL:COPY-READTABLE
		 (SI:READTABLE-FOR-SYNTAX SYNTAX-NAME)
		 ))
      (SETF (SI:READTABLE-NAME RT)
	    (FORMAT NIL "~a+~a" (SI:READTABLE-NAME RT) '|#"|))
      (SET-SYNTAX-/#-MACRO-CHAR #/" 'MY-/#/"-MACRO RT)
      (IF ENTRY
	  (SETF (SECOND ENTRY) RT)
	  (PUSH (LIST SYNTAX-NAME RT) SHARPSIGN-DOUBLEQUOTE-SYNTAX-READTABLE-ALIST)))
    RT))

(DEFUN SEARCH-MINI-BUFFER-STRING-INTERVAL (&AUX INT STRING)
  (SETQ INT (WINDOW-INTERVAL (GET-SEARCH-MINI-BUFFER-WINDOW)))
  (LET ((LEN (COUNT-CHARS INT)))
    (SETQ STRING (MAKE-16B-STRING 16B-STRING-LENGTH LEN
				  MAKE-ARRAY (:LENGTH LEN))))
  (LET ((INT-STRING (STRING-INTERVAL INT)))
    (COPY-ARRAY-CONTENTS INT-STRING STRING)
    (RETURN-ARRAY INT-STRING))
  STRING)

;;; Return a string itself, suitable for printing and reading back
(DEFUN GET-EXTENDED-SEARCH-16B-STRING (PROMPT &OPTIONAL (DEFAULT T)
							(COMTAB *SEARCH-MINI-BUFFER-COMTAB*)
							(OTHER-MODE-LINE NIL))
  (LET ((PUSH-DEFAULT (COND ((EQ DEFAULT T)
			     (SETQ DEFAULT (SEND *SEARCH-HISTORY* ':ELEMENT 0))
			     NIL)
			    (T DEFAULT)))
	(*CONTEXT-HISTORY* *SEARCH-HISTORY*)
	(*MINI-BUFFER-WINDOW* (GET-SEARCH-MINI-BUFFER-WINDOW)))
    (WITH-STACK-LIST (PROMPT-WITH-DEFAULT PROMPT " (Default: " DEFAULT ")"
					  '(:RIGHT-FLUSH " (Extended search characters)"))
      (WITH-STACK-LIST (PROMPT-WITHOUT-DEFAULT PROMPT
					       '(:RIGHT-FLUSH " (Extended search characters)"
						 ))
	(SETQ PROMPT (IF DEFAULT PROMPT-WITH-DEFAULT PROMPT-WITHOUT-DEFAULT))
	(WITH-EXTENDED-SEARCH-DISPLAY
	  (FUNCALL *SEARCH-HISTORY* ':FUNCALL-WITH-DEFAULT (AND PUSH-DEFAULT DEFAULT)
		   #'EDIT-IN-MINI-BUFFER COMTAB NIL NIL (APPEND OTHER-MODE-LINE PROMPT))))))
  (COND ((LET ((INT (WINDOW-INTERVAL (GET-SEARCH-MINI-BUFFER-WINDOW))))
	   (NOT (BP-= (INTERVAL-FIRST-BP INT) (INTERVAL-LAST-BP INT))))
	 (LET ((STRING (SEARCH-MINI-BUFFER-STRING-INTERVAL)))
	   (SEND *SEARCH-HISTORY* ':PUSH STRING)
	   STRING))
	((NULL DEFAULT)
	 (BARF "There is no default."))
	(T
	 DEFAULT)))

;;; Parse something read back
(DEFUN PARSE-EXTENDED-SEARCH-16B-STRING (STRING &AUX FUNCTION STRINGS EXPR)
  (DECLARE (VALUES FUNCTION KEY))
  (MULTIPLE-VALUE (STRINGS EXPR)
    (PARSE-EXTENDED-SEARCH-STRING STRING))
  (COND ((NLISTP STRINGS)
	 (SETQ FUNCTION 'SEARCH))
	(EXPR
	 (SETQ FUNCTION 'FSM-EXPR-SEARCH
	       STRINGS (LIST STRINGS EXPR)))
	(T
	 (SETQ FUNCTION 'FSM-SEARCH)))
  (VALUES FUNCTION STRINGS))


;; Boyer-Moore search routines

;; The skip table tells the searcher how far it can slide the pattern over the
;; source string when there is a mismatch.  It is as long as our "alphabet",
;; and is constructed as follows: for all the characters CH in the alphabet,
;; if CH occurs in that pattern, then skip(CH) is set to (pattern-length - J)
;; where J is the position of the rightmost occurrence of CH in the pattern,
;; otherwise skip(CH) is set to pattern-length.  If the table is passed in
;; as an argument, don't allocate it, just side-effect it.
(defun generate-boyer-skip-table (pattern-string &optional table)
  (let* ((pattern pattern-string)
	 (pattern-length (string-length pattern))
	 (pattern-length-1 (1- pattern-length))
	 (skip-table-size (highest-legal-char-code)))
    (declare (sys:array-register pattern))
    (if (null table)
	(setq table (make-array skip-table-size :type 'art-fixnum
						:initial-value pattern-length))
      (si:fill-array table skip-table-size pattern-length))
    (let ((table table))
      (declare (sys:array-register table))
      (macrolet ((rightmost-occurrence (char compare-function)
		   ;; Find the rightmost occurrence of CHAR in the pattern
		   `(loop for j downfrom pattern-length-1 to 0
			  when (,compare-function ,char (aref pattern j))
			    do (return j)))
		 (do-skip-table (compare-function flipcase)
		   ;; We set the initial value above, so only look at characters in the
		   ;; pattern (and only do them once!)
		   `(loop for character being the array-elements of pattern
			  as char = (char-code character)
			  when (= (aref table char) pattern-length)
			    do (setf (aref table char)
				     (- pattern-length 1
					(rightmost-occurrence character ,compare-function)))
			       ,@(when flipcase
				   '((setf (aref table (char-code (char-flipcase character)))
					   (aref table char)))))))
	;; Hacking the compare function at compile-time makes a big difference!
	(if *alphabetic-case-affects-search*
	    (do-skip-table char= nil)
	  (do-skip-table char-equal t))))
    table))

;; Too bad we can't make this examine the buffer and just look for the
;; highest character code therein
(defun highest-legal-char-code ()
  (loop for i below 256.
	for j from 0 by 256.
	for charset = (aref si:*char-set-table* i)
	when charset
	  maximize (+ j (send (if (atom charset) charset (car charset))
			      :n-characters))))

;; The reoccurrance table tells the searcher how far it can slide the pattern
;; over the source string so as to align a discovered occurrence in the source
;; string of some terminal substring of the pattern.  The table is just a
;; convenient representation of the rightmost plausible reoccurrence of the
;; terminal substring of the pattern.  If the table is passed in as an argument,
;; don't allocate it, just side-effect it.
(defun generate-boyer-reoccurrence-table (pattern-string &optional table)
  (let* ((pattern pattern-string)
	 (pattern-length (string-length pattern))
	 (pattern-length-1 (1- pattern-length)))
    (declare (sys:array-register pattern))
    (if (null table)
	(setq table (make-array pattern-length :type 'art-fixnum
					       :initial-value pattern-length))
      (si:fill-array table pattern-length pattern-length))
    (let ((table table))
      (declare (sys:array-register table))
      (macrolet ((unify (str1 from1 to1 str2 from2 to2 compare-function)
		   ;; Like string-equal, except that when the index is negative,
		   ;; it matches.  IDX1 will never be out of bounds, by definition
		   ;; of rightmost-plausible-reoccurrence.  An initial bounds check
		   ;; for STR2 is used to indicate an immediate failure.
		   `(loop initially (when (> ,to2 pattern-length-1) (return nil))
			  for idx1 upfrom ,from1 to ,to1
			  for idx2 upfrom ,from2 to ,to2
			  always (or (minusp idx2)
				     (,compare-function (aref ,str1 idx1)
							(aref ,str2 idx2)))))
		 (rightmost-plausible-reoccurrence (j compare-function)
		   ;; Find rightmost plausible reoccurrence, with the constraint
		   ;; that the sub-pattern is not preceded by the same character
		   ;; as the final character in the sub-pattern unless it is the
		   ;; first character.  NB: this can go negative!
		   `(loop for k downfrom pattern-length-1
			  when (and (or ( k 0)
					(not (,compare-function (aref pattern (1- k))
								(aref pattern ,j))))
				    (unify pattern (1+ ,j) pattern-length-1
					   pattern k (+ k pattern-length-1 (- j) -1)
					   ,compare-function))
			    do (return k)))
		 (do-reoccurrence-table (compare-function)
		   `(loop for j upfrom 0 below pattern-length
			  do (setf (aref table j)
				   (-  pattern-length
				       (rightmost-plausible-reoccurrence
					 j ,compare-function))))))
      ;; Hacking the compare function at compile-time makes a big difference!
      (if *alphabetic-case-affects-search*
	  (do-reoccurrence-table char=)
	(do-reoccurrence-table char-equal))))
    table))

;; Slow user-interface function (slow because it has to generate the tables
;; each and every time it is called)
(defun boyer-search (pattern source
		     &optional (from-char 0) (to-char (string-length source)))
  ;; Cons the tables on the stack, since we're going to throw them out anyway
  (si:with-stack-array (skip (highest-legal-char-code) :type 'art-fixnum)
    (si:with-stack-array (reoccurrence (string-length pattern) :type 'art-fixnum)
      (generate-boyer-skip-table pattern skip)
      (generate-boyer-reoccurrence-table pattern reoccurrence)
      (boyer-search-internal pattern source skip reoccurrence from-char to-char))))

;; If the pattern and the source string are of "reasonable" lengths (pattern
;; longer than 2 and source string longer than about 20), then Boyer-Moore runs
;; in about one-half to two-thirds the time of the normal string search function,
;; depending on the value of *alphabetic-case-affects-search*.  Once its
;; tables have been set up, the Boyer-Moore search is from 3 to 5 times faster
;; than the normal function.
(defun boyer-search-internal (pattern-string source-string
			      skip-table reoccurrence-table
			      from-char to-char)
  (let* ((source source-string)
	 (pattern pattern-string)
	 (pattern-length-1 (1- (string-length pattern)))
	 (skip skip-table)
	 (reoccurrence reoccurrence-table))
    (declare (sys:array-register source) (sys:array-register pattern)
	     (sys:array-register skip) (sys:array-register reoccurrence))
    (macrolet ((do-boyer-search (compare-function)
		 `(loop named matched
			;; We start at the rightmost end of the pattern, offset by from-char
			with i = (+ from-char pattern-length-1)
			as j = pattern-length-1
			;; Quit when we've gone too far
			when ( i to-char)
			  do (return nil)
			;; If the last character of the pattern matches against the source
			;; string, then try to matc up the entire pattern
			do (loop when (minusp j)
				   do (return-from matched (1+ i))
				 if (,compare-function (aref source i) (aref pattern j))
				   do (decf i)
				      (decf j)
				 else do (return))
			   ;; If unsuccessful, slide the pattern over as far as possible
			   (incf i (max (aref skip (char-code (aref source i)))
					(aref reoccurrence j))))))
      ;; Hacking the compare function at compile-time makes a big difference!
      (if *alphabetic-case-affects-search*
	  (do-boyer-search char=)
	(do-boyer-search char-equal)))))
