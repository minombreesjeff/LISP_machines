;;; -*- Mode:LISP; Package:ZWEI; Base:8 -*-
;;; Zwei searching and replacing commands

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; see ZWEI;COMA for comments.

;;; Character search

(DEFCONST *STRING-SEARCH-OPTION-DOCUMENTATION*
"While you are entering the search string, the following characters have special meanings:
c-B     Searches forward from the beginning of the buffer.
c-E     Searches backwards from the end of the buffer.
c-F     Leaves the point at the top of the window, if the window must be recentered.
c-G     Aborts the search.
c-D     Gets a string to search for from the ring buffer of previously-searched strings.
c-M     Appends any marked text in the buffer to the search string.
c-L     Redisplays the typein line.
c-Q     Quotes the next character.
c-R     Reverses the direction of the search.
c-S     Does the search, then comes back to the command loop.
c-U     Flushes all characters typed so far.
c-V     Delimited Search: Searches for occurrences of the string surrounded by delimiters.
c-W     Word Search: Searches for words in this sequence regardless of intervening
             punctuation, whitespace, newlines, and other delimiters.
c-Y     Appends the string on top of the ring buffer to the search string.
RUBOUT  Rubs out the previous character typed.
CLEAR-INPUT  Flushes all characters typed so far.
END	Does the search and exits.
c-Mouse-Middle	Searches for what the mouse is pointing at.

If you search for the empty string, it uses the default.  Otherwise, the
string you type becomes the default, and the default is saved on a ring
buffer unless it is a single character.")

(DEFCOM COM-CHAR-SEARCH DOC-CHAR-SEARCH (KM)
   (CHAR-SEARCH-INTERNAL NIL))

(DEFCONST *CHAR-SEARCH-OPTION-DOCUMENTATION-FORMAT* "
Special characters:
c-A     Does ~0@*~:[~;Reverse ~]String Search (see below).
c-B     Searches forward from the beginning of the buffer.
c-E     Searches backward from the end of the buffer.
c-F     Leaves the point at the top of the window, if the window must be recentered.
c-G     Cancels the search.
c-I     Does ~0@*~:[~;Reverse ~]Incremental Search.
c-R     ~0@*~:[Searches backward.~
            ~;Repeats the last backward search.~]
c-S     ~0@*~:[Repeats the last search.~
            ~;Searches forward.~]~1@*~:[~;
c-sh-U  Tries to clean up after people who got ~0@*~:[~;Reverse ~]Char Search from ~
        c-~0@*~:[S~;R~] when
        they expected ~0@*~:[~;Reverse ~]Incremental Search:
          Undoes the last buffer insertion and then does ~0@*~:[~;Reverse ~]Incremental Search
          for the string removed (plus the character to its ~0@*~:[left~;right~], ~
          if appropriate).
        For example, if you've typed c-~0@*~:[S~;R~] T H I N G (accidentally inserting /"HING/"
        into the buffer), typing c-~0@*~:[S~;R~] c-sh-U will undo the insertion and put you
        into ~0@*~:[an ~;a Reverse ~]Incremental Search for /"THING/".~]
ABORT   Cancels the search.
HELP    Prints this text.

~0@*~:[~;Reverse ~]String Search, which you enter from c-A, reads in a string
  and searches ~0@*~:[~;backward ~]for it.~2%")

(DEFUN DOC-CHAR-SEARCH (COMMAND IGNORE TYPE &OPTIONAL BACKWARD)
  (SELECTQ TYPE
    (:NAME (GET COMMAND 'COMMAND-NAME))
    ((:FULL :SHORT)
     (FORMAT T "Search~:[~; backward~] for a single character." BACKWARD)
     (WHEN (EQ TYPE ':FULL)
       (FORMAT T *CHAR-SEARCH-OPTION-DOCUMENTATION-FORMAT*
	       BACKWARD
	       ;; The second argument is true if this command is installed as the
	       ;; standard search command.
	       (LET ((STANDARD-SEARCH-COMMAND
		       (IF BACKWARD
			   (COMMAND-LOOKUP #\c-R *COMTAB*)
			   (COMMAND-LOOKUP #\c-S *COMTAB*))))
		 (EQ COMMAND STANDARD-SEARCH-COMMAND)))
       (FUNCALL STANDARD-OUTPUT :STRING-OUT *STRING-SEARCH-OPTION-DOCUMENTATION*)))))

(DEFCOM COM-REVERSE-CHAR-SEARCH DOC-REVERSE-CHAR-SEARCH (KM)
   (CHAR-SEARCH-INTERNAL T))

(DEFUN DOC-REVERSE-CHAR-SEARCH (COMMAND ANYTHING TYPE)
  (DOC-CHAR-SEARCH COMMAND ANYTHING TYPE T))

(DEFVAR *LAST-CHAR-SEARCH-FAILURE* NIL)
(DEFVAR *LAST-CHAR-SEARCH-FORWARD* T)

(DEFUN CHAR-SEARCH-INTERNAL (REVERSEP)
  (UNWIND-PROTECT
    (PROG (XCHAR CHAR BJP ZJP TOP-P STRING BP FAILED-P QUOTE-P
	   (ORIG-PT (COPY-BP (POINT))) (ARG *NUMERIC-ARG*)
	   (FCN 'SEARCH))
	(AND (MINUSP ARG) (SETQ REVERSEP (NOT REVERSEP) ARG (- ARG)))
     LOOP (COND ((OR FAILED-P			;Force redisplay on failing search
		     (NULL (SETQ XCHAR (EDITOR-INPUT :NO-HANG T))))
		 (TYPEIN-LINE-WITH-REDISPLAY "~:|")
		 (AND BJP (TYPEIN-LINE-MORE "Begin "))
		 (AND ZJP (TYPEIN-LINE-MORE "End "))
		 (AND TOP-P
		      (TYPEIN-LINE-MORE "Top Line "))
		 (AND REVERSEP (TYPEIN-LINE-MORE "Reverse "))
		 (AND QUOTE-P (TYPEIN-LINE-MORE "Quoted-ascii "))
		 (TYPEIN-LINE-MORE "Search: ")))
	  (COND ((NOT FAILED-P)
		 (SETQ CHAR (OR XCHAR
				(TYPEIN-LINE-ACTIVATE
				  (EDITOR-INPUT))))
		 (COND (QUOTE-P
			(AND (NOT (ZEROP (CHAR-BITS CHAR)))
			     (SETQ CHAR (CODE-CHAR (LOGAND (CHAR-CODE CHAR) 37))))
			(SETQ STRING CHAR)
			(SEARCH-RING-PUSH CHAR FCN))
		       ((CHAR-EQUAL CHAR #\c-A)
			(RETURN (LET ((*CURRENT-COMMAND* 'COM-STRING-SEARCH))
				  (COM-STRING-SEARCH-INTERNAL REVERSEP BJP ZJP TOP-P))))
		       ((AND (CHAR-EQUAL CHAR #\c-R) (NOT REVERSEP))
			(SETQ REVERSEP (NOT REVERSEP))
			(GO LOOP))
		       ((CHAR-EQUAL CHAR #\c-B)
			(SETQ BJP T ZJP NIL REVERSEP NIL)
			(GO LOOP))
		       ((CHAR-EQUAL CHAR #\c-E)
			(SETQ ZJP T BJP NIL REVERSEP T)
			(GO LOOP))
		       ((CHAR-EQUAL CHAR #\c-F)
			(SETQ *CENTERING-FRACTION* 0.0s0 TOP-P T)
			(GO LOOP))
		       ((MEM #'CHAR-EQUAL CHAR '(#\c-G #\ABORT))
			(FUNCALL *TYPEIN-WINDOW* ':MAKE-COMPLETE)
			(GO QUIT))
		       ((CHAR-EQUAL CHAR #\c-I)
			(RETURN (LET ((*CURRENT-COMMAND* 'COM-INCREMENTAL-SEARCH))
				  (INCREMENTAL-SEARCH REVERSEP))))
		       ((OR (CHAR-EQUAL CHAR #\c-S)
			    (AND REVERSEP (CHAR-EQUAL CHAR #\c-R)))
			(OR *SEARCH-RING* (BARF))
			(SETQ STRING (CAAR *SEARCH-RING*)
			      FCN (CADAR *SEARCH-RING*)))
		       ((CHAR-EQUAL CHAR #\c-Q)		;Funny ascii compatibility
			(SETQ QUOTE-P T)
			(GO LOOP))
		       ((CHAR-EQUAL CHAR #\c-sh-U)
			(UNLESS (MEMBER *LAST-COMMAND-CHAR* '(#\c-S #\c-R))
			  ;; This only works if what the user had expected was
			  ;; incremental search (normally on c-S or c-R)
			  (BEEP) (GO LOOP))
			(LET* ((BUFFER (BP-CHANGE-RECORDING-BUFFER (POINT)))
			       (HISTORY (IF BUFFER (BUFFER-CHANGE-HISTORY BUFFER))))
			  (WHEN HISTORY
			    (LET ((MOST-RECENT-CHANGE (FIRST HISTORY)))
			      (WHEN (TYPEP MOST-RECENT-CHANGE 'INSERT-RECORD)
				(LET* ((BP1 (CHANGE-RECORD-FIRST-BP MOST-RECENT-CHANGE))
				       (BP2 (CHANGE-RECORD-LAST-BP MOST-RECENT-CHANGE))
				       (BP0 (FORWARD-CHAR BP1 -1))
				       (BP3 (FORWARD-CHAR BP2  1)))
				  (WHEN (AND (OR (BP-= (POINT) BP1) (BP-= (POINT) BP2))
					     (EQ *LAST-COMMAND-TYPE* 'SELF-INSERT)
					     (IF *LAST-CHAR-SEARCH-FORWARD* BP0 BP3))
				    (SETQ STRING
					  (IF *LAST-CHAR-SEARCH-FAILURE*	;heuristic
					      ;; In this case, we can't divine what the
					      ;; first char of the search string was from
					      ;; the buffer state, so we try global state.
					      ;; If the user has been in another buffer
					      ;; searching around in the interim, this might
					      ;; do something foolish, but c'est la vie.
					      ;; c-sh-R will undo the effect!
					      (STRING-APPEND *LAST-CHAR-SEARCH-FAILURE*
							     (STRING-INTERVAL BP1 BP2))
					      ;; This case is less heuristic, since we can
					      ;; tell something from the buffer state...
					      (IF *LAST-CHAR-SEARCH-FORWARD*
						  (STRING-INTERVAL BP0 BP2)
						  (STRING-APPEND
						    (STRING-INTERVAL BP2 BP3)
						    (STRING-INTERVAL BP1 BP2)))))
				    (UNDO-COMMAND NIL NIL NIL NIL T)
				    (MUST-REDISPLAY *WINDOW* DIS-TEXT) 
				    (LET ((*MODE-LINE-LIST*
					    (LIST
					      (FORMAT NIL
						      "Insertion ~:[after last Char Search~;~
						       before last Reverse Char Search~] ~
						       undone.  Press ~A to redo the Undo."
						      (NOT *LAST-CHAR-SEARCH-FORWARD*)
						      (KEY-FOR-COMMAND 'COM-QUICK-REDO
								       *COMTAB*)))))
				      (REDISPLAY-MODE-LINE))
				    (MOVE-BP (POINT) (IF *LAST-CHAR-SEARCH-FORWARD* BP0 BP3))
				    (DOTIMES (I (STRING-LENGTH STRING))
				      (SEND STANDARD-INPUT :FORCE-KBD-INPUT
					    (CODE-CHAR (CHAR-CODE	;Strip style
							 (AREF STRING I)))))
				    (LET ((*CURRENT-COMMAND* 'COM-INCREMENTAL-SEARCH))
				      (RETURN (INCREMENTAL-SEARCH REVERSEP)))))))))
			(BEEP)
			(GO LOOP))
		       ((CHAR-EQUAL CHAR #\HELP)
			(PRINT-DOC ':FULL *CURRENT-COMMAND*)
			(FORMAT T "~2&Type any character to flush:")
			(CHECK-FOR-TYPEOUT-WINDOW-TYPEOUT)
			(GO LOOP))
		       ((MEMQ CHAR TV:KBD-INTERCEPTED-CHARACTERS)
			(ZWEI-KBD-INTERCEPT-CHARACTER CHAR *TYPEIN-WINDOW*)
			(GO LOOP))
		       ((NOT (ZEROP (CHAR-BITS CHAR)))		;Random control character
			(BEEP)
			(GO LOOP))
		       (T
			(SETQ STRING CHAR)
			(SEARCH-RING-PUSH CHAR FCN)))))
	  (AND (OR (NULL XCHAR) FAILED-P)
	       (IF (CHARACTERP STRING)
		   (TYPEIN-LINE-MORE "~C~C" STRING #\END)
		   (TYPEIN-LINE-MORE "~A~C" STRING #\END)))
	  (SETQ BP (AND (NOT FAILED-P)
			(DO ((I 0 (1+ I))
			     (BP (COND (BJP (INTERVAL-FIRST-BP *INTERVAL*))
				       (ZJP (INTERVAL-LAST-BP *INTERVAL*))
				       (T (POINT)))
				 (FUNCALL FCN BP STRING REVERSEP)))
			    ((OR ( I ARG) (NULL BP))
			     BP))))
	  (COND (BP
		 (SETQ *LAST-CHAR-SEARCH-FAILURE* NIL)
		 (SETQ *LAST-CHAR-SEARCH-FORWARD* (NOT REVERSEP))
		 (MOVE-POINT BP))
		((OR FAILED-P (NULL XCHAR))
		 (SETQ *LAST-CHAR-SEARCH-FAILURE* (STRING STRING))
		 (SETQ *LAST-CHAR-SEARCH-FORWARD* (NOT REVERSEP))
		 (TYPEIN-LINE-MORE " Search failed.")
		 (BARF))
		(T
		 (SETQ FAILED-P T)
		 (GO LOOP)))			;Failed search typed ahead
    QUIT (MAYBE-PUSH-POINT ORIG-PT)
	 (RETURN DIS-BPS))
    (FUNCALL *MODE-LINE-WINDOW* ':DONE-WITH-MODE-LINE-WINDOW)))

(DEFCOM COM-STRING-SEARCH
	(LAMBDA (COMMAND CHAR TYPE)
	  (DOC-STRING-SEARCH COMMAND TYPE "Search for a specified string.")) (KM)
    (COM-STRING-SEARCH-INTERNAL NIL NIL NIL NIL))

(DEFCOM COM-REVERSE-STRING-SEARCH
	(LAMBDA (COMMAND CHAR TYPE)
	  (DOC-STRING-SEARCH COMMAND TYPE "Search backward for a specified string.")) (KM)
    (COM-STRING-SEARCH-INTERNAL T NIL NIL NIL))

(DEFUN DOC-STRING-SEARCH (COMMAND TYPE SHORT-STRING)
  (SELECTQ TYPE
    (:NAME (GET COMMAND 'COMMAND-NAME))
    ((:SHORT :FULL)
     (FUNCALL STANDARD-OUTPUT ':STRING-OUT SHORT-STRING)
     (COND ((EQ TYPE ':FULL)
	    (FUNCALL STANDARD-OUTPUT ':FRESH-LINE)
	    (FUNCALL STANDARD-OUTPUT ':STRING-OUT *STRING-SEARCH-OPTION-DOCUMENTATION*))))))

;; A special hack is needed to stop an altmode that follows a S from searching.
;; That is what HACK1 and HACK2 are for.
;; --- needs multi-section revisit.
(DEFUN COM-STRING-SEARCH-INTERNAL (REVERSEP BJP ZJP TOP-P &AUX TEM)
  (SELECT-WINDOW *WINDOW*)	;Flush typeout before TYPEIN-LINE-ACTIVATE
  (UNWIND-PROTECT
      (TYPEIN-LINE-ACTIVATE
	(PROG ((STRING (MAKE-ARRAY 10 ':TYPE 'ART-STRING ':FILL-POINTER 0))
	       (ORIG-PT (COPY-BP (POINT))) (FCN 'SEARCH) (RING-PUSHED NIL)
	       XCHAR CHAR BLIP HACK1 HACK2 ECHOED-P FAILED-P)
	   REDIS (COND ((NULL (SETQ XCHAR (AND (NOT ECHOED-P)
					       (EDITOR-INPUT :NO-HANG T))))
			(SETQ ECHOED-P T)			;Started to echo now
			(TYPEIN-LINE-WITH-REDISPLAY "~:|")
			(AND BJP (TYPEIN-LINE-MORE "Begin "))
			(AND ZJP (TYPEIN-LINE-MORE "End "))
			(AND TOP-P (TYPEIN-LINE-MORE "Top Line "))
			(AND REVERSEP (TYPEIN-LINE-MORE "Reverse "))
			(TYPEIN-LINE-MORE (SELECTQ FCN
					    (SEARCH "String search: ")
					    (WORD-SEARCH "Word search: ")
					    (DELIMITED-SEARCH "Delimited search: ")))
			(TYPEIN-LINE-MORE "~A" STRING)))
		 (AND FAILED-P (GO FAILED))
		 (GO LOP1)
	    LOOP (SETQ XCHAR (AND (NOT ECHOED-P)
				  (EDITOR-INPUT :NO-HANG T)))
	    LOP1 (MULTIPLE-VALUE (CHAR BLIP)
		   (OR XCHAR (EDITOR-INPUT :SCROLL T :ANY-TYI 'COMMAND)))
		 (IGNORE BLIP)
		 (SETQ HACK2 HACK1 HACK1 NIL)
		 (COND ((AND (LISTP CHAR) (EQ (FIRST CHAR) 'SI:INPUT-EDITOR))
			;; Now we have a region, get it into the search string
			(SETQ STRING (APPEND-SEARCH-STRING STRING (THIRD CHAR)))
			(GO REDIS))
		       ((AND (LISTP CHAR) (EQ (FIRST CHAR) 'PRESENTATION-COMMAND))
			(LET ((VALUE (SECOND CHAR)))
			  (APPLY (FIRST VALUE) (REST1 VALUE)))
			(GO LOOP))
		       ((LISTP CHAR)
			(BEEP)
			(GO LOOP))
		       ((CHAR-EQUAL CHAR #\c-B)
			(SETQ BJP T ZJP NIL REVERSEP NIL)
			(GO REDIS))
		       ((CHAR-EQUAL CHAR #\c-E)
			(SETQ BJP NIL ZJP T REVERSEP T)
			(GO REDIS))
		       ((CHAR-EQUAL CHAR #\c-F)
			(SETQ *CENTERING-FRACTION* 0.0s0 TOP-P T)
			(GO REDIS))
		       ((CHAR-EQUAL CHAR #\c-G)
			(FUNCALL *TYPEIN-WINDOW* ':MAKE-COMPLETE)
			(BARF))
		       ((CHAR-EQUAL CHAR #\c-D)
			(MULTIPLE-VALUE (TEM FCN)
			  (SEARCH-RING-POP))
			(SETQ STRING 
			      (IF (CHARACTERP TEM)
				  (APPEND-SEARCH-STRING (MAKE-ARRAY 10 :TYPE 'ART-STRING
								       :FILL-POINTER 0)
							TEM)
				  TEM))
			(GO REDIS))
		       ((CHAR-EQUAL CHAR #\c-L)
			(GO REDIS))
		       ((CHAR-EQUAL CHAR #\c-M)
			(IF (NOT (WINDOW-REGION-P))
			    (BEEP)
			    (REGION (BP1 BP2 :ENFORCE-SINGLE-SECTION T)
			      (SETQ STRING (APPEND-SEARCH-STRING STRING
					     (STRING-INTERVAL BP1 BP2 T))))
			    (SETF (WINDOW-MARK-P *WINDOW*) NIL)
			    (MUST-REDISPLAY *WINDOW* DIS-MARK-GOES)
			    (REDISPLAY *WINDOW* ':NONE))
			(GO REDIS))
		       ((CHAR-EQUAL CHAR #\c-Q)
			(SETQ CHAR (EDITOR-INPUT))
			(SETQ CHAR (CODE-CHAR (LOGAND (IF (CHAR-BIT CHAR :CONTROL)
							  37 377)
						      (CHAR-CODE CHAR))))
			(GO NORMAL))
		       ((CHAR-EQUAL CHAR #\c-R)
			(SETQ REVERSEP (NOT REVERSEP))
			(GO REDIS))
		       ((CHAR-EQUAL CHAR #\c-S)
			(COND ((EQUAL "" STRING)
			       (WHEN *SEARCH-RING*
				 (SETQ STRING (CAAR *SEARCH-RING*)
				       FCN (CADAR *SEARCH-RING*))))
			      ((NOT RING-PUSHED)
			       (SETQ RING-PUSHED T)
			       (SEARCH-RING-PUSH STRING FCN)))
			(LET ((TEM (FUNCALL FCN
					    (COND (ZJP (INTERVAL-LAST-BP *INTERVAL*))
						  (BJP (INTERVAL-FIRST-BP *INTERVAL*))
						  (T (POINT)))
					    STRING
					    REVERSEP)))
			  (COND ((NULL TEM)
				 ;; Next line commented out for Emacs compatibility
				 ;(BEEP)
				 (GO FAILED))
				(T (MOVE-POINT TEM)
				   (MUST-REDISPLAY *WINDOW* DIS-BPS)
				   (AND (WINDOW-READY-P *WINDOW*)	;Minibuffer
					(REDISPLAY *WINDOW* ':POINT))
				   (SETQ BJP NIL ZJP NIL)
				   (AND TOP-P
					(SETQ *CENTERING-FRACTION* 0.0s0))
				   (SETQ HACK1 T))))
				    (IF (NULL XCHAR)
					(GO LOOP)
					(SETQ ECHOED-P T)
					(GO REDIS)))
		       ((CHAR-EQUAL CHAR #\c-U)
			(STORE-ARRAY-LEADER 0 STRING 0)
			(GO REDIS))
		       ((CHAR-EQUAL CHAR #\c-V)
			(SETQ FCN 'DELIMITED-SEARCH)
			(GO REDIS))
		       ((CHAR-EQUAL CHAR #\c-W)
			(SETQ FCN 'WORD-SEARCH)
			(GO REDIS))
		       ((CHAR-EQUAL CHAR #\c-Y)
			(SETQ STRING (APPEND-SEARCH-STRING STRING (CAAR *SEARCH-RING*)))
			(GO REDIS))
		       ((CHAR= CHAR #\RUBOUT)
			(OR (ZEROP (ARRAY-LEADER STRING 0))
			    (ARRAY-POP STRING))
			(GO REDIS))
		       ((CHAR= CHAR #\CLEAR-INPUT)
			(STORE-ARRAY-LEADER 0 STRING 0)
			(GO REDIS))
		       ((OR (CHAR= CHAR #\END) (CHAR= CHAR #\ALTMODE))
			(OR XCHAR
			    (TYPEIN-LINE-MORE "~C" #\END))
			(UNLESS HACK2
			  (COND ((EQUAL "" STRING)
				 (WHEN *SEARCH-RING*
				   (SETQ STRING (CAAR *SEARCH-RING*)
					 FCN (CADAR *SEARCH-RING*))))
				((NOT RING-PUSHED)
				 (SEARCH-RING-PUSH STRING FCN)))
			  (DO ((ARG (ABS *NUMERIC-ARG*) (1- ARG))
			       (BP (COND (ZJP (INTERVAL-LAST-BP *INTERVAL*))
					 (BJP (INTERVAL-FIRST-BP *INTERVAL*))
					 (T (POINT)))))
			      (( ARG 0) (MOVE-POINT BP))
			    (OR (SETQ BP (FUNCALL FCN BP STRING REVERSEP))
				(GO FAILED))))
			(MAYBE-PUSH-POINT ORIG-PT)
			(RETURN DIS-BPS))
		       ((CHAR= CHAR #\HELP)
			(PRINT-DOC ':FULL *CURRENT-COMMAND*)
			(FORMAT T "~&Type any character to flush:")
			(CHECK-FOR-TYPEOUT-WINDOW-TYPEOUT)
			(GO REDIS))
		       ((MEMQ CHAR TV:KBD-INTERCEPTED-CHARACTERS)
			(ZWEI-KBD-INTERCEPT-CHARACTER CHAR *TYPEIN-WINDOW*)
			(GO REDIS))
		       ((NOT (ZEROP (CHAR-BITS CHAR)))		;Random control character
			(BEEP)
			(GO REDIS)))
		 (SETQ CHAR (MAKE-CHAR CHAR))	;Clear style and bits
	  NORMAL (SETQ STRING (APPEND-SEARCH-STRING STRING CHAR))
		 (IF XCHAR
		     (GO REDIS)
		     (SETQ ECHOED-P T)			;Started to echo
		     (TYPEIN-LINE-MORE "~C" CHAR)
		     (GO LOOP))
	  FAILED (COND (XCHAR			;Typed ahead failing search, force redisplay
			(SETQ FAILED-P T ECHOED-P T)
			(GO REDIS))
		       (FAILED-P			;Typed ahead last time
			(TYPEIN-LINE-MORE "~C" #\END)))
		 (TYPEIN-LINE-MORE " Search failed.")
		 (BARF)))
    (FUNCALL *MODE-LINE-WINDOW* ':DONE-WITH-MODE-LINE-WINDOW)))

;;; conc MORE onto the end of STRING and return the new STRING
;;; STRING always has a fill-pointer
;;; MORE can be a character or a string; its style is stripped
;;; Makes STRING bigger if necessary in both length and fatness
(DEFUN APPEND-SEARCH-STRING (STRING MORE)
  (COND ((CHARACTERP MORE)
	 (SETF (SI:CHAR-STYLE-INDEX MORE) 0)
	 (WHEN (CHAR-FAT-P MORE)
	   (UNLESS (STRING-FAT-P STRING)
	     (LET* ((LEN (FILL-POINTER STRING))
		    (NEW (MAKE-ARRAY (ARRAY-LENGTH STRING) :TYPE 'ART-FAT-STRING
							   :FILL-POINTER LEN)))
	       (COPY-ARRAY-PORTION STRING 0 LEN NEW 0 LEN)
	       (SETQ STRING NEW))))
	 (ARRAY-PUSH-EXTEND STRING MORE))
	((STRING-FAT-P MORE)
	 (UNLESS (STRING-FAT-P STRING)
	   (WHEN (LOOP FOR CH BEING THE ARRAY-ELEMENTS OF MORE
		       DO (SETF (SI:CHAR-STYLE-INDEX CH) 0)
		       THEREIS (CHAR-FAT-P CH))
	     (LET* ((LEN (FILL-POINTER STRING))
		    (NEW (MAKE-ARRAY (ARRAY-LENGTH STRING) :TYPE 'ART-FAT-STRING
				     :FILL-POINTER LEN)))
	       (COPY-ARRAY-PORTION STRING 0 LEN NEW 0 LEN)
	       (SETQ STRING NEW))))
	 (LOOP FOR CH BEING THE ARRAY-ELEMENTS OF MORE
	       DO (SETF (SI:CHAR-STYLE-INDEX CH) 0)
		  (ARRAY-PUSH-EXTEND STRING CH)))
	(T (APPEND-TO-ARRAY STRING MORE)))
  STRING)

(DEFUN ZWEI-KBD-INTERCEPT-CHARACTER (CHAR WINDOW)
  (LET ((DONE-FLAG))
    (UNWIND-PROTECT
      (PROGN (TV:KBD-INTERCEPT-CHARACTER CHAR WINDOW)
	     (SETQ DONE-FLAG T))
      (IF (NOT DONE-FLAG)
	  (FUNCALL WINDOW ':MAKE-COMPLETE)))))

;;; Incremental search.

(DEFCOM COM-INCREMENTAL-SEARCH DOC-INCREMENTAL-SEARCH (KM)
   (INCREMENTAL-SEARCH (< *NUMERIC-ARG* 0)))

(DEFCONST *INCREMENTAL-SEARCH-OPTION-DOCUMENTATION-FORMAT* "
As characters are typed in, the accumulating string is displayed in the
minibuffer and searched for ~:[~;backward ~]at the same time.  During this input:

RUBOUT  Removes a character and backs up the search to the last match.
c-Q     Quotes the next character, to prevent it from terminating the search.
c-S     ~:*~:[Repeats the search with the present string.~
            ~;Reverses the search to search forward.~]
c-R     ~:*~:[Reverses the search to search backward.~
            ~;Repeats the backward search with the present string.~]
END     Completes the search at the present location; the string is saved as the default.
ABORT   Aborts the search at the present search location.
CLEAR-INPUT  Clears the string and returns the search to its starting point.
c-G     When the search is in an unsuccessful state, rubs out characters until
          its state becomes successful;
        when the search is in a successful state, returns the search to its
          starting point and aborts it (equivalent to CLEAR-INPUT ABORT).
HELP    Prints this text.

If ~:*~:[c-S~;c-R~] is typed with an empty search string, the previous search string
is used again as the default.  

END with an empty search string enters ~:*~:[~;Reverse ~]String Search (see below).

c-W, m-W, and c-m-W with an empty search string rebinds these characters for the remaining
search and they behave as follows:

c-W     Grabs the char at the end of the present location and appends it to the search string.
m-W     Grabs the word at the end of the present location and appends it to the search string.
c-m-W   Grabs the sexp at the end of the present location and appends it to the search string.

Any other command character terminates the search (and then executes that command).

~:*~:[~;Reverse ~]String Search, which you enter from END with an empty string, reads in 
  a string, then searches ~:*~:[~;backward ~]for it.
")

(DEFUN DOC-INCREMENTAL-SEARCH (COMMAND IGNORE TYPE)
  (SELECTQ TYPE
    (:NAME (GET COMMAND 'COMMAND-NAME))
    ((:FULL :SHORT)
     (FUNCALL STANDARD-OUTPUT :STRING-OUT
	      "Searches for a character string while you type it.")
     (WHEN (EQ TYPE ':FULL)
       (FORMAT STANDARD-OUTPUT *INCREMENTAL-SEARCH-OPTION-DOCUMENTATION-FORMAT* NIL)
       (FUNCALL STANDARD-OUTPUT ':STRING-OUT *STRING-SEARCH-OPTION-DOCUMENTATION*)))))

(DEFCOM COM-REVERSE-INCREMENTAL-SEARCH DOC-REVERSE-INCREMENTAL-SEARCH (KM)
   (INCREMENTAL-SEARCH (> *NUMERIC-ARG* 0)))

(DEFUN DOC-REVERSE-INCREMENTAL-SEARCH (COMMAND IGNORE TYPE)
  (SELECTQ TYPE
    (:NAME (GET COMMAND 'COMMAND-NAME))
    ((:FULL :SHORT)
     (FUNCALL STANDARD-OUTPUT :STRING-OUT
	      "Searches backward for a character string while you type it.")
     (WHEN (EQ TYPE ':FULL)
       (FORMAT STANDARD-OUTPUT *INCREMENTAL-SEARCH-OPTION-DOCUMENTATION-FORMAT* T)
       (FUNCALL STANDARD-OUTPUT ':STRING-OUT *STRING-SEARCH-OPTION-DOCUMENTATION*)))))

;;; Kludgey incremental search fixed arrays.
(DEFVAR *IS-STRING* NIL)
(DEFVAR *IS-BP* NIL)
(DEFVAR *IS-STATUS* NIL)
(DEFVAR *IS-REVERSE-P* NIL)
(DEFVAR *IS-POINTER* NIL)
(DEFVAR *IS-OPERATION* NIL)

(DEFUN INITIALIZE-INCREMENTAL-SEARCH-GLOBALS ()
  (WHEN (NULL *IS-STRING*)
    (SETQ *IS-STRING* (MAKE-ARRAY 200 ':TYPE 'ART-STRING ':FILL-POINTER 0)
	  ;; All of the arrays below constitute a push-down stack.
	  *IS-BP* (MAKE-ARRAY 200 ':FILL-POINTER 0)
	  ;; STATUS is NIL for a failing search, T for a successful one,
	  ;; and :GO for one that is still looking.
	  *IS-STATUS* (MAKE-ARRAY 200 ':FILL-POINTER 0)
	  ;; T if the search is reverse at this level.
	  *IS-REVERSE-P* (MAKE-ARRAY 200 ':FILL-POINTER 0)
	  ;; This points to the end of the part of *IS-STRING* active at this level.
	  *IS-POINTER* (MAKE-ARRAY 200 ':FILL-POINTER 0)
	  ;; This is what sort of thing the char at this level is:
	  ;; :NORMAL, :REVERSE or :REPEAT.
	  *IS-OPERATION* (MAKE-ARRAY 200 ':FILL-POINTER 0))))

(DEFMACRO PUSH-ISEARCH-STATUS ()
    '(PUSH-ISEARCH-STATUS-1 (SETQ P (1+ P))))

(DEFUN PUSH-ISEARCH-STATUS-1 (P)
    (COND ((= P (ARRAY-LENGTH *IS-REVERSE-P*))
           (ADJUST-ARRAY-SIZE *IS-REVERSE-P* (+ P 100))
           (ADJUST-ARRAY-SIZE *IS-STATUS* (+ P 100))
           (ADJUST-ARRAY-SIZE *IS-OPERATION* (+ P 100))
           (ADJUST-ARRAY-SIZE *IS-BP* (+ P 100))
           (ADJUST-ARRAY-SIZE *IS-POINTER* (+ P 100))))
    (ASET (AREF *IS-REVERSE-P* (1- P)) *IS-REVERSE-P* P)
    (ASET (AREF *IS-POINTER* (1- P)) *IS-POINTER* P)
    (ASET ':GO *IS-STATUS* P))

;;; This is how incremental search manages to allow both type-ahead and rubout-ahead:
;;; What to do is kept in five stacks, arrays in the *IS-...* variables.
;;; Input of normal characters pushes onto the end using index P,
;;; and rubout pops off at the same index.  *IS-REVERSE-P* remembers the
;;; search direction at each level, *IS-OPERATION* remembers the type of search
;;; (:NORMAL for a normal character, :REVERSE for a R or S that reverses,
;;; or :REPEAT for a R or S that repeats), *IS-POINTER* is the length of
;;; the search string at that level.

;;; In parallel, with lower priority, the entries thus pushed are processed
;;; by searching according to them.  P1 is the index of the entry or "level"
;;; which is currently being worked on.  P1 advances only when the level is
;;; determined to be successful or failing.  Advancing involves examining the three
;;; *IS-...* entries of the next level to see what to do.  If P1 meets P, then there is no
;;; work to do for the moment.  The state of this process is kept in *IS-STATUS*
;;; and *IS-BP*.  *IS-BP* is the bp of the place found at a given level or the 
;;; place at which searching is going on.  *IS-STATUS* is T for a successful search,
;;; NIL for a failing one, and :GO if it isn't known yet.  New levels are pushed
;;; (via P) in the :GO state.

;;; Rubbing out decrements P1 if necessary to keep it no greater than P.
;;; The searching process is not confused because it keeps all its state
;;; in *IS-STATUS* and *IS-BP* and all that is needed is to change P1.

;;; Updating the echo area is under input in priority, but above actual searching.
;;; Thus, as soon as there is no type-ahead everything will be correct.
;;; This is because the echo area is presumed to be fast to update.
;;; Buffer redisplay is lower than searching, of course.
(DEFVAR *RUBOUT-KILLS-LAST-SEARCH-STRING* NIL)
(DEFVARIABLE *INCREMENTAL-SEARCH-ALWAYS-GRAB* NIL SCL:BOOLEAN
  "Enables c-W, m-W, & c-m-W to always grab at the present location
instead of only with an empty search string.")
  
(DEFUN INCREMENTAL-SEARCH (REVERSE-P)
  (INITIALIZE-INCREMENTAL-SEARCH-GLOBALS)
  (SELECT-WINDOW *WINDOW*)	;Flush typeout before TYPEIN-LINE-ACTIVATE
  (TYPEIN-LINE "")		;Necessary if in the mini-buffer
  (UNWIND-PROTECT
      (TYPEIN-LINE-ACTIVATE
	(SI:WITH-STACK-ARRAY
	    ;; Allocate an skip-table on the stack to avoid consing too much.
	    ;; We don't bother with the reoccurrence table because (1) it's size
	    ;; changes for each pattern string, and (2) it's small anyway.
	    (SKIP-RESOURCE (HIGHEST-LEGAL-CHAR-CODE) :TYPE 'ART-FIXNUM)
	  (PROG (CHAR		; The current command.
		 REAL-CHAR	; The one to :UNTYI if need be
		 XCHAR		; Upcase version of character
		 MUST-REDIS	; T => The echo-area must be completely redisplayed.
		 (GRAB-MODE     ; T => c-W, m-W, & c-m-W grab from the present location.
		   *INCREMENTAL-SEARCH-ALWAYS-GRAB*)
		 PROCESSING-GRAB; T => We are processing a grab, finish before next grab.
		 (P 0)		; The stack pointer into *IS-BP*, etc. for input and rubout
		 (P1 0)		; The pointer for which search we are doing.
				; Can never exceed P.
		 SUPPRESSED-REDISPLAY ; T if the last input char was read before
				      ; redisplay had a chance to finish.
				      ;  A G read that way acts like a failing search quit.
		 (BP (POINT))	; The POINT.
		 BP1		; Aux BP used for actual searching.
		 NEW-BP
		 TIME-OUT	; Set by SEARCH when it times out so we can check input.
		 INPUT-DONE	; An altmode or control char has been seen.
				; Do not look for input any more; just search, then exit.
		 (ORIG-PT)	; Original position of POINT.
		 (SKIP-TABLE NIL)
		 (OLD-SKIP-TABLE NIL)
		 (REOCCURRENCE-TABLE NIL)
		 (OLD-REOCCURRENCE-TABLE NIL)
		 )
    
		(SETQ ORIG-PT (COPY-BP BP))
		(SETQ BP1 (COPY-BP BP))		; This is reused to save consing.
		(STORE-ARRAY-LEADER 0 *IS-STRING* 0); Clear out the search string.
		(ASET T *IS-STATUS* 0)		; Initialize the stacks.
		(ASET REVERSE-P *IS-REVERSE-P* 0)
		(ASET ':NORMAL *IS-OPERATION* 0)
		(ASET 0 *IS-POINTER* 0)
		(ASET (COPY-BP BP) *IS-BP* 0)
		(SETQ MUST-REDIS T)		; Initially we must redisplay.
		(GO CHECK-FOR-INPUT)
		
		;; Come here if there is input, or nothing to do until there is input.
	     INPUT
		(SETQ SUPPRESSED-REDISPLAY NIL)
		(AND (WINDOW-READY-P *WINDOW*)	;In case of minibuffer
		     (REDISPLAY *WINDOW* ':POINT))    ; Redisplay point position while waiting.
		(OR (= (WINDOW-REDISPLAY-DEGREE *WINDOW*) DIS-NONE)
		    (SETQ SUPPRESSED-REDISPLAY T))
		(MULTIPLE-VALUE (CHAR REAL-CHAR)
		  (EDITOR-INPUT :SCROLL T :MOUSE :RETURN
				:ANY-TYI 'COMMAND))	; allow the mouse to work!
		(UNLESS (CHARACTERP CHAR)		; eliminate mouse clicks now
		  (SETQ INPUT-DONE T)
		  ;; This is admittedly a kludge, but it's the simplest way to
		  ;; get EDITOR-INPUT to execute the mouse-clicked command
		  (SETQ *YANKED-MINI-BUFFER-COMMAND* CHAR)
		  (GO CHECK-FOR-INPUT))	    
		(SETQ XCHAR (CHAR-UPCASE CHAR))
		(COND ((NOT (OR (NOT (ZEROP (CHAR-BITS CHAR)))
				(CHAR-EQUAL CHAR #\ALTMODE) (CHAR-EQUAL CHAR #\END)
				(CHAR-EQUAL CHAR #\RUBOUT) (CHAR-EQUAL CHAR #\CLEAR-INPUT)
				(CHAR-EQUAL CHAR #\HELP) (CHAR-EQUAL CHAR #\SCROLL)
				(MEM #'CHAR-EQUAL CHAR TV:KBD-INTERCEPTED-CHARACTERS)))
		       (GO NORMAL))
		      ((MEMQ XCHAR '(#\c-S #\c-R))
		       (PUSH-ISEARCH-STATUS)
		       (ASET ':REPEAT *IS-OPERATION* P)
		       (LET ((NEW-REVERSE-P (CHAR= XCHAR #\c-R)))
			 (COND   ;; In reverse mode, just go to forward.
			   ((NEQ (AREF *IS-REVERSE-P* P) NEW-REVERSE-P)
			    (ASET NEW-REVERSE-P *IS-REVERSE-P* P)
			    (SETQ MUST-REDIS T)
			    (ASET ':REVERSE *IS-OPERATION* P))
			   ((ZEROP (AREF *IS-POINTER* P))
			    (LET ((STRING (STRING (OR (CAAR *SEARCH-RING*) (BARF)))))
			      (IF *RUBOUT-KILLS-LAST-SEARCH-STRING*
				  (PROGN
				    (COPY-ARRAY-CONTENTS STRING *IS-STRING*)
				    (ASET (ARRAY-ACTIVE-LENGTH STRING) *IS-POINTER* P))
				(LOOP FOR MORE FIRST NIL THEN T
				      FOR CHAR BEING THE ARRAY-ELEMENTS OF STRING
				      WHEN MORE
					DO (PUSH-ISEARCH-STATUS)
				      DO (LET ((IDX (AREF *IS-POINTER* P)))
					   (AND ( IDX (ARRAY-LENGTH *IS-STRING*))
						(ADJUST-ARRAY-SIZE *IS-STRING* (+ IDX 100)))
					   (ASET CHAR *IS-STRING* IDX)
					   (ASET (1+ IDX) *IS-POINTER* P))
					 (ASET ':NORMAL *IS-OPERATION* P))))
			    (SETQ MUST-REDIS T))))
		       (GO CHECK-FOR-INPUT))
		      ((AND (OR (CHAR= XCHAR #\c-W)
				(CHAR= XCHAR #\m-W)
				(CHAR= XCHAR #\c-m-W))
			    (OR GRAB-MODE
				(AND (ZEROP P) (SETQ GRAB-MODE T))))
		       (LET* ((CURRENT    (AREF *IS-POINTER* P))
			      (FOUND-BP   (IF (AREF *IS-REVERSE-P* P)
					      (FORWARD-CHAR BP1 CURRENT)
					      BP1))
			      (FORWARD-BP (COND
					    ((CHAR= XCHAR #\c-W)   (FORWARD-CHAR FOUND-BP))
					    ((CHAR= XCHAR #\m-W)   (FORWARD-WORD FOUND-BP))
					    ((CHAR= XCHAR #\c-m-W) (FORWARD-SEXP FOUND-BP))))
			      (WORD (IF FORWARD-BP
					(WITH-INTERVAL-READ-LOCKED (FOUND-BP FORWARD-BP T)
					  (MULTIPLE-VALUE-BIND (LENGTH WIDTH)
					      (PREPARE-TO-RECORD FOUND-BP FORWARD-BP)
					    (COPY-INTERVAL-INTO-STRING-OR-INTERVAL
					      FOUND-BP FORWARD-BP LENGTH WIDTH)))
					(PROGN (BEEP) (GO CHECK-FOR-INPUT)))))
			 (OR MUST-REDIS (TYPEIN-LINE-MORE "~A" WORD))
			 (PUSH-ISEARCH-STATUS)
			 (LET ((IDX (1- (+ (STRING-LENGTH WORD) CURRENT))))
			   (WHEN ( IDX (ARRAY-LENGTH *IS-STRING*))
			     (ADJUST-ARRAY-SIZE
			       *IS-STRING* (+ CURRENT (* 100 (CEILING (- IDX CURRENT) 100)))))
			   (UNLESS (STRING-FAT-P *IS-STRING*)
			     (WHEN (STRING-FAT-P WORD)
			       (LET ((NEW-STRING
				       (MAKE-ARRAY (ARRAY-LENGTH *IS-STRING*)
						   :FILL-POINTER (FILL-POINTER *IS-STRING*)
						   :TYPE 'ART-FAT-STRING)))
				 (COPY-ARRAY-CONTENTS *IS-STRING* NEW-STRING)
				 (STRUCTURE-FORWARD *IS-STRING* NEW-STRING 2 2)
				 (SETQ *IS-STRING* NEW-STRING)
				 (RETURN))))
			   (LOOP AS CHAR BEING THE ARRAY-ELEMENTS OF WORD
				 AS INDEX FROM CURRENT TO IDX
				 DO (ASET CHAR *IS-STRING* INDEX)
				 FINALLY (ASET (1+ IDX) *IS-POINTER* P))
			   (ASET ':NORMAL *IS-OPERATION* P)
			   (SETQ PROCESSING-GRAB T)
			   (GO DO-SOME-WORK))))
		      ((CHAR= XCHAR #\c-Q)
		       (SETQ CHAR (MAKE-CHAR (EDITOR-INPUT)))
		       (GO NORMAL))
		      ((CHAR= XCHAR #\c-G)
		       (COND ((AND (OR SUPPRESSED-REDISPLAY (NEQ (AREF *IS-STATUS* P) T))
				   (PLUSP P))
			      ;; G in other than a successful search
			      ;; rubs out until it becomes successful.
			      (SETQ P (DO ((P (1- P) (1- P)))
					  ((EQ (AREF *IS-STATUS* P) T) P)))
			      (SETQ P1 (MIN P P1) MUST-REDIS T)
			      (GO CHECK-FOR-INPUT))
			     (T
			      (MOVE-POINT (AREF *IS-BP* 0))
			      (FUNCALL *TYPEIN-WINDOW* ':MAKE-COMPLETE)
			      (RETURN NIL))))
		      ((MEMQ CHAR TV:KBD-INTERCEPTED-CHARACTERS)
		       (ZWEI-KBD-INTERCEPT-CHARACTER CHAR *TYPEIN-WINDOW*)
		       (GO CHECK-FOR-INPUT))
		      ((OR (CHAR= CHAR #\ALTMODE) (CHAR= CHAR #\END))
		       (AND (ZEROP P)
			    (RETURN (LET ((*CURRENT-COMMAND* 'COM-STRING-SEARCH))
				      (COM-STRING-SEARCH-INTERNAL REVERSE-P NIL NIL NIL))))
		       (SETQ INPUT-DONE T)
		       (GO CHECK-FOR-INPUT))
		      ((CHAR= CHAR #\RUBOUT)
		       (COND (( P 0)		; If he over-rubbed out,
			      (BEEP)		;   that is an error.
			      (GO CHECK-FOR-INPUT))
			     (T
			      ;; Rubout pops all of these PDLs.
			      (SETQ P (1- P))
			      (SETQ P1 (MIN P P1))
			      (SETQ MUST-REDIS T)
			      (GO CHECK-FOR-INPUT))))
		      ((CHAR= CHAR #\CLEAR-INPUT)
		       (SETQ P 0 P1 0 MUST-REDIS T)
		       (GO CHECK-FOR-INPUT))
		      ((CHAR= CHAR #\HELP)
		       (PRINT-DOC ':FULL *CURRENT-COMMAND*)
		       (FORMAT T "~2&Type any character to flush:")
		       (CHECK-FOR-TYPEOUT-WINDOW-TYPEOUT)
		       (GO CHECK-FOR-INPUT))
		      (T
		       (FUNCALL STANDARD-INPUT ':UNTYI REAL-CHAR)
		       (SETQ INPUT-DONE T)
		       (GO CHECK-FOR-INPUT)))
		(FERROR NIL "A clause fell through.")
		
		;; Normal chars to be searched for come here.
	     NORMAL
		(OR MUST-REDIS (TYPEIN-LINE-MORE "~C" CHAR))
		(PUSH-ISEARCH-STATUS)
		(LET ((IDX (AREF *IS-POINTER* P)))
		  (AND ( IDX (ARRAY-LENGTH *IS-STRING*))
		       (ADJUST-ARRAY-SIZE *IS-STRING* (+ IDX 100)))
		  (WHEN (CHAR-FAT-P CHAR)
		    (UNLESS (STRING-FAT-P *IS-STRING*)
		      (LET ((NEW-STRING (MAKE-ARRAY (ARRAY-LENGTH *IS-STRING*)
						    :FILL-POINTER (FILL-POINTER *IS-STRING*)
						    :TYPE 'ART-FAT-STRING)))
			(COPY-ARRAY-CONTENTS *IS-STRING* NEW-STRING)
			(STRUCTURE-FORWARD *IS-STRING* NEW-STRING 2 2)
			(SETQ *IS-STRING* NEW-STRING))))
		  (ASET CHAR *IS-STRING* IDX)
		  (ASET (1+ IDX) *IS-POINTER* P))
		(ASET ':NORMAL *IS-OPERATION* P)
		;; Come here after possibly processing input to update the search tables
		;; to search for a while.  First, if necessary and not suppressed
		;; update the search string displayed in the echo area.
	     CHECK-FOR-INPUT
		;; If there is input available, go read it.
		;; Otherwise, do work if there is work to be done.
		(AND (NOT INPUT-DONE)
		     (FUNCALL STANDARD-INPUT ':LISTEN)
		     (GO INPUT))
	     DO-SOME-WORK
		;; Now do some work for a while, then go back to CHECK-FOR-INPUT.
		(COND (MUST-REDIS
		       (SETQ MUST-REDIS NIL)
		       (TYPEIN-LINE "~:|")
		       (OR (AREF *IS-STATUS* P1) (TYPEIN-LINE-MORE "Failing "))
		       (AND (AREF *IS-REVERSE-P* P) (TYPEIN-LINE-MORE "Reverse "))
		       (TYPEIN-LINE-MORE "I-Search: ")
		       (STORE-ARRAY-LEADER (AREF *IS-POINTER* P) *IS-STRING* 0)
		       (TYPEIN-LINE-MORE "~A" *IS-STRING*)))
		;; Now see what sort of state the actual search is in, and
		;; what work there is to do.  P1 points at the level of the
		;; table on which we are actually working.
		(MOVE-BP BP1 (AREF *IS-BP* P1))
		;; Display point at the end of the last search level which has succeeded.
		(DO ((P0 P1 (1- P0)))
		    ((EQ (AREF *IS-STATUS* P0) T)
		     (MOVE-POINT (AREF *IS-BP* P0))))
		(MUST-REDISPLAY *WINDOW* DIS-BPS)
		(COND ((EQ (AREF *IS-STATUS* P1) ':GO)
		       ;; If we are about to repeat a search, generate the Boyer-Moore
		       ;; tables for the pattern string and cache them.  Do not generate
		       ;; the tables if they are already cached.
		       (IF (OR TIME-OUT (CHAR= XCHAR #\c-S))
			   (WHEN (AND (NULL OLD-SKIP-TABLE) (NULL OLD-REOCCURRENCE-TABLE))
			     (SETQ OLD-SKIP-TABLE (GENERATE-BOYER-SKIP-TABLE
						    *IS-STRING* SKIP-RESOURCE)
				   OLD-REOCCURRENCE-TABLE (GENERATE-BOYER-REOCCURRENCE-TABLE
							    *IS-STRING*)))
			 (SETQ OLD-SKIP-TABLE NIL
			       OLD-REOCCURRENCE-TABLE NIL))
		       ;; We need an additional check here, because of the interaction between
		       ;; additional c-S'es and typeahead.  If you type, say "FEPFS" c-S in a
		       ;; long buffer with "FEP" at the beginning of the buffer and "FEPFS" at
		       ;; the end of the buffer, then *IS-STRING* can get out of sync with the
		       ;; reoccurrence table.  This code gets them back in sync.
		       (WHEN (AND OLD-REOCCURRENCE-TABLE
				  ( (ARRAY-LENGTH OLD-REOCCURRENCE-TABLE)
				     (STRING-LENGTH *IS-STRING*)))
			 (SETQ OLD-SKIP-TABLE (GENERATE-BOYER-SKIP-TABLE
						*IS-STRING* SKIP-RESOURCE)
			       OLD-REOCCURRENCE-TABLE (GENERATE-BOYER-REOCCURRENCE-TABLE
							*IS-STRING*)))
		       (SETQ SKIP-TABLE OLD-SKIP-TABLE
			     REOCCURRENCE-TABLE OLD-REOCCURRENCE-TABLE)
				       
		       ;; If the level we were working on is still not finished,
		       ;; search at most 100 more lines. If we find it or the end of the buffer
		       ;; before then, this level is determined and we can work on the next.
		       ;; Otherwise, we remain in the :GO state and do 100 more lines next time
		       (MULTIPLE-VALUE (NEW-BP TIME-OUT)
			 (SEARCH BP1 *IS-STRING*
				 (AREF *IS-REVERSE-P* P1) NIL 100
				 NIL *ALPHABETIC-CASE-AFFECTS-SEARCH*	;---
				 SKIP-TABLE REOCCURRENCE-TABLE))
		       ;; What happened?
		       (COND (TIME-OUT
			      ;; Nothing determined.  NEW-BP has where we stopped.
			      (MOVE-BP BP1 NEW-BP))
			     ((NULL NEW-BP)
			      ;; This search was determined to be a failure.
			      (OR (AND (MEMQ ':MACRO-ERROR
					     (FUNCALL STANDARD-INPUT ':WHICH-OPERATIONS))
				       (FUNCALL STANDARD-INPUT ':MACRO-ERROR))
				  (BEEP))
			      (ASET NIL *IS-STATUS* P1)
			      (MOVE-BP BP1 (AREF *IS-BP* (1- P1)))
			      (MOVE-POINT BP1)
			      (SETQ MUST-REDIS T))
			     (T ;; This search level has succeeded.
			      (ASET T *IS-STATUS* P1)
			      (MOVE-POINT NEW-BP)
			      (MOVE-BP BP1 NEW-BP))))
		      (( P P1)
		       ;; This level is finished, but there are more pending levels typed ahead
		       (SETQ P1 (1+ P1))
		       (ASET (SETQ BP1 (COPY-BP BP1)) *IS-BP* P1)
		       (STORE-ARRAY-LEADER (AREF *IS-POINTER* P1) *IS-STRING* 0)
		       (COND ((NULL (AREF *IS-STATUS* (1- P1)))
			      (COND ((NEQ (AREF *IS-OPERATION* P1) ':REVERSE)
				     ;; A failing search remains so unless we reverse direction
				     (ASET NIL *IS-STATUS* P1))
				    (T ;; If we reverse direction, change prompt line.
				     (SETQ MUST-REDIS T))))
			     ((EQ (AREF *IS-OPERATION* P1) ':NORMAL)
			      ;; Normal char to be searched for comes next.
			      ;; We must adjust the bp at which we start to search
			      ;; so as to allow the user to extend the string already found.
			      (MOVE-BP
				BP1 (FORWARD-CHAR
				      BP1 (COND ((AREF *IS-REVERSE-P* P1)
						 (COND ((= (ARRAY-ACTIVE-LENGTH *IS-STRING*) 1)
							0)
						       (T (ARRAY-ACTIVE-LENGTH *IS-STRING*))))
						(T (- 1 (ARRAY-ACTIVE-LENGTH *IS-STRING*))))
						  T))))
		       (WHEN PROCESSING-GRAB	    ;Finish Grab work so we don't grab twice
			 (SETQ PROCESSING-GRAB NIL) ;from same BP.
			 (GO DO-SOME-WORK)))
		      ;; If there is nothing left to do, and terminator seen, exit.
		      (INPUT-DONE
		       (SEARCH-RING-PUSH
			 ;; Entries on the search ring should have a leader
			 (STRING-NCONC (MAKE-ARRAY (ARRAY-ACTIVE-LENGTH *IS-STRING*)
						   ':TYPE (ARRAY-TYPE *IS-STRING*)
						   ':FILL-POINTER 0)
				       *IS-STRING*)
			 'SEARCH)
		       (TYPEIN-LINE-MORE "~C" #\END)
		       (MAYBE-PUSH-POINT ORIG-PT)
		       (SELECT-WINDOW *WINDOW*)
		       (RETURN NIL))
		      ;; Nothing to do and no terminator, wait for input.
		      (T (GO INPUT)))
		(GO CHECK-FOR-INPUT)
		
		)))
    (FUNCALL *MODE-LINE-WINDOW* ':DONE-WITH-MODE-LINE-WINDOW))
  DIS-BPS)


;;; If there is a region, use it (for compatibilty)
(COMPILER:MAKE-OBSOLETE WITH-QUERY-REPLACE-INTERVAL "use WITH-BOUNDED-INTERVAL instead")
(DEFMACRO WITH-QUERY-REPLACE-INTERVAL ((REGION-P-VAR) &BODY BODY)
  `(WITH-BOUNDED-INTERVAL (,REGION-P-VAR)
     ,@BODY))

(DEFCOM COM-REPLACE-STRING
	"Replaces all occurrences of a given string with another.
It prompts first for the string to remove and second for the string to replace
it with.  A numeric argument (n) means to make n replacements.  By default, it
replaces all occurrences of the first string that occur following point in the
buffer.

Usually it attempts to match the case of the replacements with the case of the
string being replaced.  This behavior is controlled by zwei:*case-replace-p*.
When it is null, case matching does not take place." ()
  (LET ((FIRST-BP (POINT))
	(LAST-BP (IF (WINDOW-REGION-P) (MARK) (POINT))))
    (WITH-BOUNDED-INTERVAL (REGION-P)
      (WITH-INTERVAL-WRITE-LOCKED (FIRST-BP LAST-BP)
	(LET* ((FROM (TYPEIN-LINE-HISTORY-READLINE *REPLACE-HISTORY* NIL T
		      "Replace ~:[all~*~;next ~D~] occurrences ~:[in the region ~]of:"
		      *NUMERIC-ARG-P* *NUMERIC-ARG* (NOT REGION-P)))
	       (TO (TYPEIN-LINE-HISTORY-READLINE *REPLACE-HISTORY* T NIL
		    "Replace ~:[all~*~;next ~D~] occurrences ~:[in the region ~]of /"~A/" with:"
		    *NUMERIC-ARG-P* *NUMERIC-ARG* (NOT REGION-P) FROM)))
	  (TYPEIN-LINE "~D replacement~:P."
	   (REPLACE-STRING (POINT) FROM TO (AND *NUMERIC-ARG-P* *NUMERIC-ARG*)))
	  DIS-TEXT)))))
(DEFCOM COM-QUERY-REPLACE
	"Replaces occurrences of one string with another, asking about each occurrence.
It prompts first for the string to remove and second for the string to replace
it with.  A numeric argument means to consider only the cases where the string
to remove occurs as a word (rather than within a word).  When it finds an
occurrence of the first string, it stops and waits for you to supply
confirmation by typing a character.

Space   Replaces the first string and moves to its next occurrence.
Rubout  Skips this occurrence and moves to the next one.
Comma   Replaces this occurrence and redisplays the result, waiting for further
        confirmation (in the form of Space, c-R, or End).
Period  Replaces this occurrence and stops.
End     Stops without doing any replacement.
!    Replaces all remaining occurrences without any more prompting.
^    Returns to the site of the previous occurrence  (actually, pops the point pdl).
c-W  Deletes this occurrence and enters a recursive editing level.
c-R  Enters a recursive editing level without doing any replacement or deletion.
c-L  Redisplays the screen.

Any other character causes this command to terminate (the character is then
read as input by the editor).

Usually it attempts to match the case of the replacements with the case of the
string being replaced.  This behavior is controlled by zwei:*case-replace-p*.
When it is null, case matching does not take place." ()
  (WITH-BOUNDED-INTERVAL (REGION-P)
    (MULTIPLE-VALUE-BIND (FROM TO)
	(QUERY-REPLACE-STRINGS REGION-P *NUMERIC-ARG-P*)
      (QUERY-REPLACE FROM TO *NUMERIC-ARG-P*)
      (TYPEIN-LINE "Query replace done.")
      DIS-TEXT)))

(DEFCOM COM-ATOM-QUERY-REPLACE
	"Replaces a delimited atom with a string, prompting about each occurrence.
This command has the same options as Query Replace.  See the documentation for
Query Replace." ()
  (ATOM-WORD-SYNTAX-BIND
    (LET ((*NUMERIC-ARG-P* T))
      (COM-QUERY-REPLACE))))

(DEFUN QUERY-REPLACE-STRINGS (REGION-P BREAKS &OPTIONAL (TYPE "replace") RETURN-EMPTY)
  (LET ((FROM (TYPEIN-LINE-HISTORY-READLINE
		*REPLACE-HISTORY* NIL (NOT RETURN-EMPTY)
	        "Query-~A some ~:[~;delimited ~]occurrences ~:[in the region ~]of:"
		TYPE BREAKS (NOT REGION-P))))
    (WHEN (PLUSP (STRING-LENGTH FROM))
      (VALUES FROM
	      (TYPEIN-LINE-HISTORY-READLINE
		*REPLACE-HISTORY* T NIL
		"Query-~A some ~:[~;delimited ~]occurrences ~:[in the region ~]of /"~A/" with:"
		TYPE BREAKS (NOT REGION-P) FROM)))))

(DEFVAR *QUERY-FROM*)				;These are for the mode line
(DEFVAR *QUERY-TO*)

(DEFUN STRINGS-HAVE-SAME-STYLE (STRING1 STRING2)
  (IF (STRING-EQUAL STRING1 STRING2)
      (LOOP FOR CHAR1 BEING THE ARRAY-ELEMENTS OF STRING1
	    FOR CHAR2 BEING THE ARRAY-ELEMENTS OF STRING2
	    ALWAYS (= (SI:CHAR-STYLE-INDEX CHAR1) (SI:CHAR-STYLE-INDEX CHAR2)))
    ;; If the string are not equal, claim that they have the same style (ouch)
    T))

(DEFUN STRING-HAS-SOME-STYLE-P (STRING)
  (LOOP FOR CHAR BEING THE ARRAY-ELEMENTS OF STRING
	THEREIS (NOT (ZEROP (SI:CHAR-STYLE-INDEX CHAR)))))

(DEFUN STRING-HAS-SOME-UPPERCASE-P (STRING)
  (LOOP FOR CHAR BEING THE ARRAY-ELEMENTS OF STRING
	THEREIS (UPPER-CASE-P CHAR)))

;;; This is the normal form of query replace
(DEFUN QUERY-REPLACE (*QUERY-FROM* *QUERY-TO* &OPTIONAL BREAKS BUFFER (START-BP (POINT)))
  ;; If from isn't all lowercase, user probably has something specific in mind
  ;; also if the two strings are string-equal (but different case).
  (LET-BUFFER-VARIABLE (*CASE-REPLACE-P*
			 (AND (NOT (STRING-HAS-SOME-UPPERCASE-P *QUERY-FROM*))
			      (NOT (STRING-EQUAL *QUERY-FROM* *QUERY-TO*))
			      *CASE-REPLACE-P*))
    (LET-BUFFER-VARIABLE (*STYLE-REPLACE-P*
			   (AND (OR (NOT (STRING-HAS-SOME-STYLE-P *QUERY-FROM*))
				    (NOT (STRING-HAS-SOME-STYLE-P *QUERY-TO*)))
				(NOT (STRINGS-HAVE-SAME-STYLE *QUERY-FROM* *QUERY-TO*))
				*STYLE-REPLACE-P*))
      (QUERY-REPLACE-INTERNAL *QUERY-FROM* *QUERY-TO* #'QUERY-REPLACE-SEARCH BREAKS
			      BUFFER START-BP))))

(DEFUN QUERY-REPLACE-SEARCH (BP QUERY-FROM IGNORE &AUX BP1)
  (AND (SETQ BP1 (SEARCH BP QUERY-FROM))
       (VALUES BP1 (FORWARD-CHAR BP1 (- (STRING-LENGTH QUERY-FROM))))))

(DEFMACRO QREP ()
  `(UNLESS FLAG-2
     (COND (*SPARSE-CHANGE-ARRAY*
	    (RECORD-SPARSE-CHANGE BP1 BP2 (STRING-LENGTH *QUERY-TO*))
	    (LET ((*ENABLE-CHANGE-RECORDING* NIL))
	      (MOVE-BP BP2 (CASE-REPLACE BP1 BP2 *QUERY-TO* T))))
	   (T
	    (WITH-CUSTOM-UNDO-SAVE (BP1 BP2
				    (MAKE-REPLACE-CHANGE-RECORD BP1 BP2
						(FINALIZE-BP-POSITIONS BP-POSITIONS) OLD-TEXT)
				    :OLD-TEXT OLD-TEXT)
	      (MOVE-BP BP2 (CASE-REPLACE BP1 BP2 *QUERY-TO* T)))))
     (MOVE-POINT BP2)
     (MUST-REDISPLAY *WINDOW* DIS-TEXT)))

;;; General query replace.  Note: POINT is moved around.
;;; BREAKS means only consider things surrounded by delimiters.
;;; Function is called on with BP and QUERY-FROM and QUERY-to, it should return two bps to
;;; the area of the thing found or NIL.
;;; FLAG-1 and FLAG-2 implement the hairy COMMA command.
;;;--- Reimplemented in more modern style by Dodds, 11/12/86 15:13:37, and fixed so that
;;;--- that the "^" feature works, to go back to the "previous" occurrence.  This
;;;--- feature needs to be fixed better sometime, or removed.  As presently implemented,
;;;--- it abuses the window point-pdl to store each occurrence as it is passed.  It has
;;;--- been fixed up so that stepping back is limited to the number of points actually
;;;--- stored by this function; it used to step back to whatever random points were
;;;--- there, into other buffers, etc.  But there are still a number of things wrong
;;;--- with this arrangement:  1> This storage is severely limited:  *POINT-PDL-MAX* = 8;
;;;--- 2> stepping back pops off the point-pdl each time, then when a forward command
;;;--- is given (RUBOUT or SPACE), the query-replace picks up from where it last was
;;;--- (which is correct), losing the record of all the previous occurrences that have
;;;--- been backed over.  The function should be redone with internal functions that
;;;--- implement an internal point-pdl setup, which includes saving and restoring a
;;;--- previous point in the stack.  If that's worth it, for this marginal feature.
(DEFUN QUERY-REPLACE-INTERNAL (QUERY-FROM QUERY-TO FUNCTION BREAKS BUFFER START-BP)
  (LET ((BP1 NIL)
	(BP2 (COPY-BP START-BP))
	(DO-THE-REST NIL)
	(PD-COUNT 0)
	CHAR UCHAR FLAG-1 FLAG-2)
    (WITH-INTERVAL-WRITE-LOCKED
	;;--- Should this really write-lock the entire buffer?
        ;; Who can tell what we are going to get here?
        ((OR BUFFER (BP-BUFFER-INTERNAL START-BP) *INTERVAL*))
      (WITH-UNDO-SAVE-SPARSE ("Query Replace" START-BP
			      :TEST (NOT *UNDO-EACH-REPLACE-SEPARATELY*)
			      :FLAVOR 'SPARSE-REPLACE-CHANGE-RECORD
			      :FROM-STRING QUERY-FROM :TO-STRING QUERY-TO)
	(FLET ((QR-POINT-PDL-PUSH (BP WINDOW)
		 (POINT-PDL-PUSH BP WINDOW)
		 (SETQ PD-COUNT (MIN *POINT-PDL-MAX* (1+ PD-COUNT))))
	       (QR-POINT-PDL-POP (WINDOW)
		 (DECF PD-COUNT)
		 (POINT-PDL-POP WINDOW)))
	  (BIND-MODE-LINE ("Query Replacing " *QUERY-FROM* " => " *QUERY-TO*)
	    (QR-POINT-PDL-PUSH (POINT) *WINDOW*)
	    (LOOP DOING
	      (SETQ FLAG-2 FLAG-1 FLAG-1 NIL)
	      (UNLESS FLAG-2
		(LET-IF BUFFER ((*INTERVAL* BUFFER))
		  (MULTIPLE-VALUE (BP2 BP1)
		    (FUNCALL FUNCTION BP2 QUERY-FROM QUERY-TO)))
		(UNLESS BP2
		  (RETURN NIL)))
	      (WHEN (OR FLAG-2
			(NOT BREAKS)		; If we don't care about breaks, go ahead.
			(AND			; Both beginning and end must be breaks.
			  (OR (BP-= BP2 (INTERVAL-LAST-BP *INTERVAL*))	; EOB counts as a break.
			      (= (WORD-SYNTAX (BP-CHAR BP2)) WORD-DELIMITER))
			  (OR (BP-= BP1 (INTERVAL-FIRST-BP *INTERVAL*))
			      (= (WORD-SYNTAX (BP-CHAR-BEFORE BP1)) WORD-DELIMITER))))
		;; Move point after checking delimiters
		(UNLESS FLAG-2
		  (AND BUFFER (QUERY-REPLACE-MAKE-BUFFER-CURRENT BUFFER))
		  (MOVE-POINT BP2)
		  (MUST-REDISPLAY *WINDOW* DIS-BPS))
		;; We want to offer this string for replacement.
		(IF DO-THE-REST
		    (QREP)
		  (QR-POINT-PDL-PUSH (POINT) *WINDOW*)
		  (PROG ()
		     GETCHAR
			(REDISPLAY *WINDOW* ':POINT)
			(REDISPLAY-MODE-LINE)
			(SETQ CHAR (EDITOR-INPUT))
			(OR (CHARACTERP CHAR) (GO GETCHAR))	;Ignore special request
			(SETQ UCHAR (CHAR-UPCASE CHAR))
			(COND ((CHAR= UCHAR #/^)
			       (UNLESS (PLUSP (1- PD-COUNT))
				 (BEEP)
				 (GO GETCHAR))
			       (QR-POINT-PDL-POP *WINDOW*)	;Already done once
			       (MULTIPLE-VALUE-BIND (BP1 PLINE)
				   (QR-POINT-PDL-POP *WINDOW*)
				 (MOVE-POINT BP1)
				 (REDISPLAY-POINT-ON-PLINE (POINT) *WINDOW* PLINE))
			       (MUST-REDISPLAY *WINDOW* DIS-BPS)
			       (REDISPLAY *WINDOW* ':POINT)
			       (QR-POINT-PDL-PUSH (POINT) *WINDOW*);Establish new POINT
			       (GO GETCHAR))
			      ((MEMQ UCHAR '(#\Clear-Screen #\c-L))
			       (MUST-REDISPLAY *WINDOW*
					       (IF (CHAR= UCHAR #\Clear-Screen) DIS-ALL
						 (COM-RECENTER-WINDOW)))
			       (REDISPLAY *WINDOW* ':POINT)
			       (GO GETCHAR))
			      ((MEMQ UCHAR TV:KBD-INTERCEPTED-CHARACTERS)
			       (ZWEI-KBD-INTERCEPT-CHARACTER CHAR *TYPEIN-WINDOW*)
			       (FUNCALL *TYPEOUT-WINDOW* ':MAKE-COMPLETE)
			       (REDISPLAY-ALL-WINDOWS)
			       (GO GETCHAR))
			      ((MEMQ UCHAR '(#/? #\HELP))
			       (PRINT-DOC ':FULL *CURRENT-COMMAND*)
			       (FORMAT T "~&Type any character to flush:")
			       (CHECK-FOR-TYPEOUT-WINDOW-TYPEOUT)
			       (REDISPLAY-ALL-WINDOWS)
			       (GO GETCHAR))))
		  (SELECTQ UCHAR
		    (#\SP (QREP))			;Space: Replace and continue.
		    (#\RUBOUT NIL)		;Rubout: Continue.
		    (#/,				;Comma:
		     (QREP)
		     (SETQ FLAG-1 T))
		    ((#\ALTMODE #\END)		;Altmode: Quit.
		     (TYPEIN-LINE "Exiting query replace.")
		     (RETURN NIL))
		    (#/. (QREP)			;Point: Replace and quit.
		     (TYPEIN-LINE "Exiting query replace.")
		     (RETURN NIL))
		    (#\c-R			;C-R: Recurse.
		     (CONTROL-R)
		     (MOVE-POINT BP2)		;Put point back where it belongs
		     (MUST-REDISPLAY *WINDOW* DIS-BPS)
		     (SETQ FLAG-1 (NOT FLAG-2)))	;Normally stay, after comma move on
		    (#\c-W			;C-W: Delete, and recurse.
		     (DELETE-INTERVAL (POINT) BP1)
		     (MUST-REDISPLAY *WINDOW* DIS-TEXT)
		     (CONTROL-R))
		    (#/! (QREP)			;!: Do this and rest.
		     (SETQ DO-THE-REST T))
		    (OTHERWISE
		     (FUNCALL STANDARD-INPUT ':UNTYI CHAR)
		     (TYPEIN-LINE "Aborting query replace.")
		     (RETURN 'ABORTED))))))))))))

(DEFUN QUERY-REPLACE-MAKE-BUFFER-CURRENT (BUFFER)
  (SEND *CURRENT-COMMAND-LOOP* ':SET-INTERVAL BUFFER))

(DEFCOM COM-QUERY-EXCHANGE
	"Exchanges two strings, using Query Replace to replace each with the other.
It prompts for the two strings and then moves through the buffer, searching
for both at the same time.  When it finds either, it stops to prompt about
replacing the first string with the second one or the second string with the
first one.

A positive numeric argument means to consider only the cases where the strings
to replace occur as a word (rather than within a word).  A negative numeric
argument means to consider only delimited atoms, rather than words. 

This command has the same options as Query Replace.  See the documentation for
Query Replace." ()
  (LET ((FIRST-BP (POINT))
	(LAST-BP (IF (WINDOW-REGION-P) (MARK) (POINT))))
    (WITH-BOUNDED-INTERVAL (REGION-P)
      (WITH-INTERVAL-WRITE-LOCKED (FIRST-BP LAST-BP)
	(MULTIPLE-VALUE-BIND (FROM TO)
	    (QUERY-REPLACE-STRINGS REGION-P *NUMERIC-ARG-P* "exchange")
	  (LET-IF (AND *NUMERIC-ARG-P* (MINUSP *NUMERIC-ARG*))
		  ((*MODE-WORD-SYNTAX-TABLE* *ATOM-WORD-SYNTAX-TABLE*))
	    (QUERY-REPLACE-LIST (POINT) (LIST FROM TO) (LIST TO FROM)
				*NUMERIC-ARG-P*)
	    (TYPEIN-LINE "Query replace done.")
	    DIS-TEXT))))))

(DEFCOM COM-MULTIPLE-QUERY-REPLACE "Replaces occurrences of any number of strings with other strings, asking about each change.
It prompts for the strings in pairs, first for the string to remove and second
for the string to replace it with.  When you have entered all the pairs you
need, end it with Return.  Then it begins searching for any of the strings and
stops when it finds any occurrence, waiting for you to supply confirmation.

A positive numeric argument means to consider only the cases where the strings
to replace occur as a word (rather than within a word).  A negative numeric
argument means to consider only delimited atoms, rather than words. 

This command has the same options as Query Replace.  See the documentation for
Query Replace." ()
  (WITH-BOUNDED-INTERVAL (REGION-P)
    (LET-IF (AND *NUMERIC-ARG-P* (MINUSP *NUMERIC-ARG*))
	    ((*MODE-WORD-SYNTAX-TABLE* *ATOM-WORD-SYNTAX-TABLE*))
      (MULTIPLE-VALUE-BIND (FROM-LIST TO-LIST)
	  (MULTIPLE-QUERY-REPLACE-STRINGS REGION-P *NUMERIC-ARG-P*)
	(QUERY-REPLACE-LIST (POINT) FROM-LIST TO-LIST *NUMERIC-ARG-P*)
	(TYPEIN-LINE "Query replace done.")
	DIS-TEXT))))

(DEFUN QUERY-REPLACE-LIST (START-BP FROM-LIST TO-LIST &OPTIONAL BREAKS BUFFER 
			   &AUX *QUERY-FROM* *QUERY-TO* (*STATE* 0)
			   (*OTHER-TO-CHOICES* NIL))
  (DECLARE (SPECIAL *STATE* *OTHER-TO-CHOICES*))
  (LET ((*BP* (POINT)))
    (DECLARE (SPECIAL *BP*))
    (QUERY-REPLACE-INTERNAL FROM-LIST TO-LIST #'QUERY-REPLACE-SEARCH-LIST BREAKS
			    BUFFER START-BP)))

(DEFUN QUERY-REPLACE-SEARCH-LIST (BP FROM-LIST TO-LIST &AUX TEM)
  (DECLARE (SPECIAL *BP* *STATE* *OTHER-TO-CHOICES*))
  (UNLESS (BP-= BP *BP*)
    (SETQ *STATE* 0				;If bp has moved, reset state
	  *OTHER-TO-CHOICES* NIL))
  (IF *OTHER-TO-CHOICES*
      (SETF `(,*QUERY-FROM* ,*QUERY-TO*) (POP *OTHER-TO-CHOICES*))
    (SETQ *QUERY-FROM* NIL)
    (MULTIPLE-VALUE (*BP* TEM *STATE*)
      (FSM-SEARCH BP FROM-LIST NIL NIL NIL NIL *STATE*))
    (WHEN *BP*
      (LOOP FOR FROM IN FROM-LIST
	    FOR TO IN TO-LIST
	    DO (WHEN (EQUAL FROM TEM)
		 (IF (NULL *QUERY-FROM*)
		     (SETQ *QUERY-FROM* TEM
			   *QUERY-TO* TO)
		     (PUSH (LIST FROM TO) *OTHER-TO-CHOICES*))))))
  (WHEN *QUERY-FROM*
    (VALUES *BP* (FORWARD-CHAR *BP* (- (STRING-LENGTH *QUERY-FROM*))))))

(DEFUN MULTIPLE-QUERY-REPLACE-STRINGS (REGION-P BREAKS &AUX FROM-LIST TO-LIST)
  (DO ((FROM) (TO)) (NIL)
    (MULTIPLE-VALUE (FROM TO)
      (QUERY-REPLACE-STRINGS REGION-P BREAKS "replace" T))
    (OR FROM (RETURN (VALUES (NREVERSE FROM-LIST) (NREVERSE TO-LIST))))
    (PUSH FROM FROM-LIST)
    (PUSH TO TO-LIST)))

;;; Miscellaneous searching commands

(DEFCOM COM-OCCUR
	"Displays any lines, following point, that contain a given string.
By default, it shows all of the lines that it finds (following point).  With a
numeric argument (n), it shows the next n lines containing the string." ()
  (COM-LIST-MATCHING-LINES))

(DEFCOM COM-LIST-MATCHING-LINES
	"Displays any lines, following point, that contain a given extended search string.
By default, it shows all of the lines that it finds (following point).  With a
numeric argument (n), it shows the next n lines containing the string." ()
  (LET ((CNT (IF *NUMERIC-ARG-P* *NUMERIC-ARG* 7777777))
	KEY FUNCTION REVERSE-P BJ-P)
    (MULTIPLE-VALUE (FUNCTION KEY REVERSE-P BJ-P)
      (GET-EXTENDED-STRING-SEARCH-STRINGS NIL "Show lines containing:"
					  *STRING-SEARCH-SINGLE-LINE-COMTAB*))
    (DO ((BP (COND ((NOT BJ-P) (POINT))
		   ((NOT REVERSE-P) (INTERVAL-FIRST-BP *INTERVAL*))
		   (T (INTERVAL-LAST-BP *INTERVAL*))))
	 (I 0 (1+ I)))
	(( I CNT) NIL)
      (OR (SETQ BP (FUNCALL FUNCTION BP KEY REVERSE-P)) (RETURN NIL))
      (PRESENT-LINE BP *TYPEOUT-WINDOW*)
      (UNLESS REVERSE-P
	(OR (SETQ BP (BEG-LINE BP 1))		; leave us at bol.
	    (RETURN NIL)))))
  (SEND *TYPEOUT-WINDOW* :LINE-OUT "Done.")
  DIS-NONE)

(DEFCOM COM-KEEP-LINES
	"Keeps only those lines (following point) that contain the specified string.
Lines preceding point are not affected." ()
  (COM-DELETE-NON-MATCHING-LINES))

(DEFCOM COM-DELETE-NON-MATCHING-LINES
	"Delete all lines (following point) that do not contain the specified string.
Lines preceding point are not affected." ()
  (MULTIPLE-VALUE-BIND (FUNCTION KEY)
      (GET-EXTENDED-STRING-SEARCH-STRINGS NIL "Keep lines containing:"
					  *SEARCH-MINI-BUFFER-COMTAB*)
    (WITH-INTERVAL-WRITE-LOCKED (*INTERVAL*)
      (LET ((BP (BEG-LINE (POINT) 0))
	    (NEW-BP))
	(DO () (())
	  ;; BP points just after the last matching line.
	  (SETQ NEW-BP (FUNCALL FUNCTION BP KEY NIL))
	  (COND ((NULL NEW-BP)
		 ;; No more matching lines => delete all after there.
		 (DELETE-INTERVAL BP (INTERVAL-LAST-BP *INTERVAL*) T)
		 (RETURN)))
	  ;; Else delete all from there to beginning of the matching line.
	  (DELETE-INTERVAL BP (BEG-LINE NEW-BP 0) T)
	  ;; Set BP to point after the new matching line.
	  (OR (SETQ BP (BEG-LINE NEW-BP 1)) (RETURN NIL))))))
  DIS-TEXT)

(DEFCOM COM-FLUSH-LINES
	"Deletes any lines (following point) that contain the specified string.
Lines preceding point are not affected." ()
  (COM-DELETE-MATCHING-LINES))

(DEFCOM COM-DELETE-MATCHING-LINES
	"Deletes any lines (following point) that contain the specified string.
Lines preceding point are not affected." ()
  (MULTIPLE-VALUE-BIND (FUNCTION KEY)
      (GET-EXTENDED-STRING-SEARCH-STRINGS NIL "Flush lines containing:"
					  *SEARCH-MINI-BUFFER-COMTAB*)
    (WITH-INTERVAL-WRITE-LOCKED (*INTERVAL*)
      (LET ((BP (BEG-LINE (POINT) 0)))
	(DO () (())
	  (OR (SETQ BP (FUNCALL FUNCTION BP KEY)) (RETURN NIL))
	  (DELETE-INTERVAL (BEG-LINE BP 0) (SETQ BP (BEG-LINE BP 1 T)))))))
  DIS-TEXT)

(DEFCOM COM-HOW-MANY
	"Counts how many times a certain substring occurs in the buffer, following point." ()
  (COM-COUNT-OCCURRENCES))

(DEFCOM COM-COUNT-OCCURRENCES
	"Counts how many times a certain substring occurs in the regions or
in the buffer following point if there is no region." ()
  (WITH-BOUNDED-INTERVAL (REGION-P)
    (MULTIPLE-VALUE-BIND (FUNCTION KEY REVERSE-P BJ-P)
	(GET-EXTENDED-STRING-SEARCH-STRINGS NIL "How many occurrences of:"
					    *STRING-SEARCH-SINGLE-LINE-COMTAB*)
      (DO ((BP (COND ((NOT BJ-P) (POINT))
		     ((NOT REVERSE-P) (INTERVAL-FIRST-BP *INTERVAL*))
		     (T (INTERVAL-LAST-BP *INTERVAL*)))
	       (FUNCALL FUNCTION BP KEY REVERSE-P))
	   (N 0 (1+ N)))
	  ((NULL BP)
	   (TYPEIN-LINE "~D. occurrence~:P of ~A~:[ in the region~].~%"
			(1- N) KEY (NOT REGION-P))))))
  DIS-NONE)

(DEFMACRO WITH-COUNTING-INTERVAL ((INTERVAL START-BP END-BP NAME) &BODY BODY)
  `(LET (,START-BP ,END-BP ,NAME)
     (IF (NOT (WINDOW-MARK-P *WINDOW*))
	 (SETQ ,START-BP (INTERVAL-FIRST-BP ,INTERVAL)
	       ,END-BP (INTERVAL-LAST-BP ,INTERVAL)
	       ,NAME "buffer")
       (SETQ ,START-BP (POINT) ,END-BP (MARK) ,NAME "region")
       (AND (BP-< ,END-BP ,START-BP) (SWAPF ,START-BP ,END-BP)))
     (LET ((,INTERVAL (CREATE-INTERVAL ,START-BP ,END-BP)))
       ,@BODY)))

(DEFUN COUNT-COMMAND-INTERNAL (MOVER MOVE-NAME)
  (WITH-COUNTING-INTERVAL (*INTERVAL* START-BP END-BP NAME)
    (LET ((COUNT 0)
	  (BP START-BP))
      (IF (NEQ MOVER 'FORWARD-INTERVAL)
	  (LOOP WHILE (SETQ BP (FUNCALL MOVER BP))
		DO (INCF COUNT))
	(INCF COUNT))
      (TYPEIN-LINE "~D. ~A~P in the ~A"
		   COUNT MOVE-NAME COUNT NAME)))
  DIS-NONE)

(DEFCOM COM-COUNT-LINES
	"Counts the lines in the region or in the buffer if there is no region." (KM)
  (WITH-COUNTING-INTERVAL (*INTERVAL* START-BP END-BP NAME)
    (TYPEIN-LINE "~D. line~:P in the ~A"
		 (1- (COUNT-LINES *INTERVAL* NIL NIL NIL T)) NAME))
  DIS-NONE)

(DEFCOM COM-COUNT-CHARS
	"Counts the characters in the region or in the buffer if there is no region." (KM)
  (WITH-COUNTING-INTERVAL (*INTERVAL* START-BP END-BP NAME)
    (TYPEIN-LINE "~D. character~:P in the ~A"
		 (COUNT-CHARS *INTERVAL*) NAME))
  DIS-NONE)

(DEFCOM COM-COUNT-PAGES
	"Counts the pages in the region or in the buffer if there is no region." (KM)
  (COUNT-COMMAND-INTERNAL #'FORWARD-PAGE "page"))

(DEFCOM COM-QUANTITY-COUNT "Counts number of objects of given type.
Counts objects in the region if there is one, otherwise objects in the buffer." (KM)
  (COUNT-COMMAND-INTERNAL *QUANTITY-MODE* *QUANTITY-MODE-NAME*))

(DEFCOM COM-COUNT-WORDS
	"Counts the words in the region or in the buffer if there is no region." (KM)
  (COUNT-COMMAND-INTERNAL #'FORWARD-WORD "word"))

(DEFCOM COM-COUNT-PARAGRAPHS
	"Counts the paragraphs in the region or in the buffer if there is no region." (KM)
  (COUNT-COMMAND-INTERNAL #'FORWARD-PARAGRAPH "paragraph"))
