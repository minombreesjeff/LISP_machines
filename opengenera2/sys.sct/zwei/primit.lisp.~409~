;;; -*- Syntax: Zetalisp; Base: 8; Mode: LISP; Package: ZWEI -*-
;;; Primitive data structure manipulation for ZWEI.

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; For things that don't allow an interval to span sections of a VC-FILE-BUFFER
;;; This returns the interval or barfs.
;;; The END-BP can be just past the end of a section, so as to cover the whole section.
(DEFUN ASSURE-SINGLE-SECTION-INTERVAL-1
       (START-BP END-BP 
	&OPTIONAL
	(MESSAGE "This operation is not allowed across multiple sections.")
	RETURN-THIS-INSTEAD-OF-BARFING)	
  (DECLARE (VALUES START-BP END-BP))
  (LET ((NODE (BP-TOP-LEVEL-LINE-LINKED-NODE START-BP)))
    (COND ((OR (EQ NODE (BP-TOP-LEVEL-LINE-LINKED-NODE END-BP))
	       ;; END-BP is not in same node, but if it's just past the end, allow anyway
	       (AND (ZEROP (BP-INDEX END-BP))
		    (EQ (BP-LINE END-BP)
			(LINE-NEXT-IN-BUFFER (BP-LINE (NODE-LAST-BP NODE))
					     :BUFFER (OR (BP-BUFFER START-BP) *INTERVAL*)))))
	   (VALUES START-BP END-BP))
	  (RETURN-THIS-INSTEAD-OF-BARFING)
	  (T (BARF MESSAGE)))))

;;;--- stub. Remove in 351, unless we want to allow loading 7.0 zwei tools unrecompiled.
(DEFUN INSURE-INTERVAL-REACHABLE (BP1 BP2 &OPTIONAL IN-ORDER-P &REST IGNORE)
  (GET-INTERVAL-1 BP1 BP2 IN-ORDER-P))

(DEFUN GET-INTERVAL-1 (BP1 BP2 &OPTIONAL IN-ORDER-P)
  (DECLARE (VALUES BP1 BP2))
  (LET ((ALREADY-IN-ORDER-P
	  (OR IN-ORDER-P (AND BP2 (OR (BP-= BP1 BP2) (BP-< BP1 BP2))))))
    (COND ((NULL BP2)
	   (SETQ BP2 (INTERVAL-LAST-BP BP1)
		 BP1 (INTERVAL-FIRST-BP BP1)))
	  ((NOT ALREADY-IN-ORDER-P) (ORDER-BPS BP1 BP2))))
  (VALUES BP1 BP2))


(DEFUN REGION-1 (START-BP END-BP ENFORCE-SINGLE-SECTION CONTINUATION)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION))
  (IGNORE ENFORCE-SINGLE-SECTION)
  (FUNCALL CONTINUATION START-BP END-BP)
  D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; All relevant code should now be capable of crossing hard section boundaries
0  1;; for itself, so that mapping should not be needed. This code is left
0  1;; in case I (margulies) prove disasterously wrong.
0#|
  (IF ENFORCE-SINGLE-SECTION
      (PROGN
	(ASSURE-SINGLE-SECTION-INTERVAL START-BP END-BP T
					"The region spans a hard section boundary.")
	(FUNCALL CONTINUATION START-BP END-BP))
      (MAP-OVER-SECTIONS-IN-INTERVAL 
	(INTERVAL-HOME-BUFFER *INTERVAL*)
	START-BP END-BP
	CONTINUATION))
|#
)

(DEFUN REGION-LINES-1 (START-BP STOP-BP ENFORCE-SINGLE-SECTION CONTINUATION)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION))
  (IGNORE ENFORCE-SINGLE-SECTION)
  (INTERVAL-LINES (START-BP STOP-BP) (START-LINE STOP-LINE)
    (FUNCALL CONTINUATION START-LINE STOP-LINE))
  1;; see REGION-1
0  #|
  (IF ENFORCE-SINGLE-SECTION
      (PROGN
	(ASSURE-SINGLE-SECTION-INTERVAL START-BP STOP-BP T
					"The region spans a hard section boundary.")
	(INTERVAL-LINES (START-BP STOP-BP) (START-LINE STOP-LINE)
	  (FUNCALL CONTINUATION START-LINE STOP-LINE)))
      (INTERVAL-LINES (START-BP STOP-BP) (START-LINE STOP-LINE)
	(MAP-OVER-LINES-IN-INTERVAL
	  (INTERVAL-HOME-BUFFER *INTERVAL*) 
	  START-LINE STOP-LINE
	  CONTINUATION)))
|#
)

(DEFUN WITH-REGION-BPS-1 (EMPTY-OK CONTINUATION)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION))
  (UNLESS (IF EMPTY-OK (WINDOW-MARK-P *WINDOW*) (WINDOW-REGION-P *WINDOW*))
    (BARF "There is no region."))
  (IF (OR (BP-= (POINT) (MARK)) (BP-< (POINT) (MARK)))	;point is first
      (FUNCALL CONTINUATION (POINT) (MARK))
      (FUNCALL CONTINUATION (MARK) (POINT)))) 


;;;--- remove in 351, unless we are trying to support the loading of old
;;;--- zwei hacks.
(DEFUN INSURE-REGION-REACHABLE (&REST IGNORE)
  (DECLARE (VALUES POINT MARK POINT-FIRST-P))
  (VALUES (POINT) (MARK) (OR (BP-= (POINT) (MARK)) (BP-< (POINT) (MARK)))))

 ;;; This might be common lisp
(DEFUN STRING-OUT (STRING &OPTIONAL (STREAM STANDARD-OUTPUT) (START 0) END)
  (SEND STREAM :STRING-OUT (STRING STRING) START END))

(DEFUN CREATE-LINE (ARRAY-TYPE SIZE NODE)
  (MAKE-LINE :MAKE-ARRAY (:TYPE ARRAY-TYPE :LENGTH SIZE)
	     LINE-TICK *TICK* LINE-LENGTH SIZE
	     LINE-NODE NODE))

(DEFUN CREATE-BP (LINE INDEX &OPTIONAL STATUS BUFFER)
  (LET ((DEFAULT-CONS-AREA *BP-AREA*))
    (IF STATUS
	(LET ((BP (MAKE-BP BP-LINE LINE BP-INDEX INDEX
			   BP-STATUS STATUS
			   BP-BUFFER-INTERNAL (OR BUFFER (INTERVAL-BUFFER *INTERVAL*)))))
	  (PUSH BP (LINE-BP-LIST LINE))
	  BP)
	(MAKE-TEMP-BP BP-LINE LINE BP-INDEX INDEX))))

(DEFUN COPY-BP (BP &OPTIONAL STATUS BUFFER)
  (CREATE-BP (BP-LINE BP) (BP-INDEX BP) STATUS (AND STATUS (OR BUFFER (BP-BUFFER BP)))))

;;; With no args, make empty interval.
;;; With one arg, turn string into interval.
;;; With two args, they are limiting bps.
;;; Third argument can be a newly-created interval to use
(DEFUN CREATE-INTERVAL (&OPTIONAL ARG1 ARG2 (NODE-P T) &AUX INTERVAL)
  (SETQ INTERVAL (IF (TYPEP NODE-P 'INTERVAL) NODE-P
		     (MAKE-INSTANCE
		       (SELECTQ NODE-P
			 ((NIL) 'INTERVAL)
			 ((T) 'NODE)
			 (OTHERWISE NODE-P)))))
  (OR ARG2
      (LET ((LINE (CREATE-LINE 'ART-STRING 0 INTERVAL)))
        (SETF (INTERVAL-FIRST-BP INTERVAL) (CREATE-BP LINE 0 ':NORMAL INTERVAL))
	(SETF (INTERVAL-LAST-BP INTERVAL) (CREATE-BP LINE 0 ':MOVES INTERVAL))))
  (AND ARG1
       (COND (ARG2
              (SETF (INTERVAL-FIRST-BP INTERVAL) ARG1)
              (SETF (INTERVAL-LAST-BP INTERVAL) ARG2))
             (T
              (LET ((*ENABLE-CHANGE-RECORDING* NIL))
		(INSERT-THING (INTERVAL-FIRST-BP INTERVAL) ARG1)))))
  ;; Commands such as c-% and m-% when operating on explicit regions, create their own
  ;; interval & temporarily bind it to *interval*
  (LET ((MUNG-REGION-ARRAY (AND (VARIABLE-BOUNDP *INTERVAL*) *INTERVAL*
				(SEND-IF-HANDLES ZWEI:*INTERVAL* :GET 'MUNG-REGION-ARRAY))))
    (WHEN (AND MUNG-REGION-ARRAY (EQ NODE-P 'TOP-LEVEL-NODE))
      (SEND INTERVAL :PUTPROP (SEND *INTERVAL* :GET 'ZWEI:PROGRAM-SYNTACTIC-STRUCTURE)
			      'ZWEI:PROGRAM-SYNTACTIC-STRUCTURE)
      (SEND INTERVAL :PUTPROP (SEND *INTERVAL* :MAJOR-MODE) :MAJOR-MODE)
      (SEND INTERVAL :PUTPROP MUNG-REGION-ARRAY 'MUNG-REGION-ARRAY)))
  INTERVAL)

;;; More comprehensible interface to the above function.
;;; (make-interval type &key initial-line &rest init-args &allow-other-keys)
;;;
;;;  type is the type. NIL defaults to INTERVAL initial-controls whether
;;;  a line is created.  If it is NIL, the interval has no contents
;;;  unless defined by init-keywords of the interval flavor.  If it is
;;;  T, an empty line is created.  If it is a string, its contents are
;;;  copied into the interval.  The function of supplying
;;;  create-interval with an already-consed interval and stuffing that
;;;  is not provided by this, but by another function.

(DEFUN MAKE-INTERVAL (TYPE &REST P-INIT-ARGS &KEY INITIAL-LINE &ALLOW-OTHER-KEYS)
  "Creates an interval.  If :INITIAL-LINE is nil, the interval has no contents
unless defined by init args.  If it is t, it starts with an empty line.
If it is a string, the string is inserted."
  (DECLARE (ARGLIST TYPE &REST TYPE-INIT-ARGS &KEY (INITIAL-LINE NONE)))
  (UNLESS TYPE (SETQ TYPE 'INTERVAL))
  (LET* ((INIT-ARGS (SI:REM-KEYWORDS P-INIT-ARGS '(:INITIAL-LINE)))
	 (INTERVAL (CL:APPLY #'MAKE-INSTANCE TYPE INIT-ARGS)))
    (WHEN INITIAL-LINE
      (INITIALIZE-INTERVAL INTERVAL INITIAL-LINE))
    INTERVAL))

(DEFUN (:PROPERTY MAKE-INTERVAL COMPILER:STYLE-CHECKER) (FORM)
  (FLAVOR:CHECK-INIT-KEYWORDS (SECOND FORM)
			      (SI:REM-KEYWORDS (CDDR FORM) '(:INITIAL-LINE))))

(DEFUN INITIALIZE-INTERVAL (INTERVAL INITIAL-CONTENTS)
  (LET ((LINE (CREATE-LINE 'ART-STRING 0 INTERVAL)))
    (SETF (INTERVAL-FIRST-BP INTERVAL) (CREATE-BP LINE 0 :NORMAL INTERVAL))
    (SETF (INTERVAL-LAST-BP INTERVAL) (CREATE-BP LINE 0 :MOVES INTERVAL))
    (WHEN (STRINGP INITIAL-CONTENTS)
      (LET ((*ENABLE-CHANGE-RECORDING* NIL))
	(INSERT (INTERVAL-LAST-BP INTERVAL) INITIAL-CONTENTS)))))

(DEFUN CREATE-INTERVAL-WITH-LINE (LINE &OPTIONAL (FLAVOR 'NODE))
  (LET ((INTERVAL (MAKE-INSTANCE FLAVOR)))
    (SETF (INTERVAL-FIRST-BP INTERVAL) (CREATE-BP LINE 0 ':NORMAL INTERVAL))
    (SETF (INTERVAL-LAST-BP INTERVAL) (CREATE-BP LINE (LINE-LENGTH LINE) ':MOVES INTERVAL))
    (SETF (LINE-NODE LINE) INTERVAL)
    INTERVAL))

;;; There are two forms:  (MOVE-BP <bp> <to-bp>) and (MOVE-BP <bp> <line> <index>)
;;; Note well: This does not change the BP's buffer.  If you are moving a permanent BP
;;;  to a different buffer, you have to worry about that yourself, maybe by 
;;;  calling MOVE-BP-TO-BP-AND-BUFFER.
(DEFUN MOVE-BP (BP LINE &OPTIONAL INDEX &AUX OLINE)
  (SETQ OLINE (BP-LINE BP))
  (COND ((NULL INDEX)
	 (SETQ INDEX (BP-INDEX LINE) LINE (BP-LINE LINE)))
	;; If we were not passed a BP, check that the INDEX is in range.
	((> INDEX (LINE-LENGTH LINE))
	 (FERROR NIL "The index ~O is greater than the length of the line ~S"
		 INDEX LINE)))
  (COND ;; If it is to the same line, there can be no problem.
    ((EQ OLINE LINE)
     (SETF (BP-INDEX BP) INDEX))
    (T
     (COND ((BP-STATUS BP)
	    ;; It is a permanent bp changing lines.  Fix relocation lists.
	    (SETF (LINE-BP-LIST OLINE) (DELQ BP (LINE-BP-LIST OLINE)))
	    (PUSH BP (LINE-BP-LIST LINE))))
     (SETF (BP-LINE BP) LINE)
     (SETF (BP-INDEX BP) INDEX)))
  BP)

(DEFUN MOVE-BP-TO-BP-AND-BUFFER (BP TO-BP)
  (UNLESS (BP-STATUS BP)
    (FERROR "~S is not a permanent BP" BP))
  (MOVE-BP BP TO-BP)
  (SETF (BP-BUFFER-INTERNAL BP) (BP-BUFFER TO-BP))
  BP)

;;; Move a BP backward over one character.
;;; Return the bp, altered.
;;; At the beginning of the interval, return nil and don't alter it.
;;; FIXUP-P means return the unaltered bp instead of nil.
(DEFUN DBP (BP &OPTIONAL FIXUP-P)
  (COND ((BP-= BP (INTERVAL-FIRST-BP *INTERVAL*))
	 (AND FIXUP-P BP))
	((= (BP-INDEX BP) 0)
	 (MOVE-BP BP (LINE-PREVIOUS-IN-BUFFER (BP-LINE BP))
		  (LINE-LENGTH (LINE-PREVIOUS-IN-BUFFER (BP-LINE BP)))))
	(T (MOVE-BP BP (BP-LINE BP) (1- (BP-INDEX BP))))))

;;; Move a BP forward over one character.
;;; Return the bp, altered.
;;; At the end of the interval, return nil and don't alter it.
;;; FIXUP-P means return the unaltered bp instead of nil.
(DEFUN IBP (BP &OPTIONAL FIXUP-P)
  (COND ((BP-= BP (INTERVAL-LAST-BP *INTERVAL*))
	 (AND FIXUP-P BP))
	((= (BP-INDEX BP) (LINE-LENGTH (BP-LINE BP)))
	 (MOVE-BP BP (LINE-NEXT-IN-BUFFER (BP-LINE BP)) 0))
	(T (MOVE-BP BP (BP-LINE BP) (1+ (BP-INDEX BP))))))

;;; Mark a buffer as changed
;;; Call this before changing it as it may err out if the buffer is read-only.
(DEFUN MUNG-BP-INTERVAL (BP)
  (TICK)
  (MUNG-NODE (BP-NODE BP)))

;;; Call this before changing it as it may err out if the buffer is read-only.
;;; Returns the line, which may have changed if it was a copy-on-write line.
;;; Also updates the BP's LINE if the line was copied.
(DEFUN MUNG-BP-LINE-AND-INTERVAL (BP &AUX (LINE (BP-LINE BP)))
  (TICK)
;--- I don't think this is needed any more
;  (WHEN (LINE-DIAGRAM LINE) (BARF "Diagram line"))
  (MUNG-NODE (BP-NODE BP))
  (COND ((LINE-COPY-ON-WRITE LINE)
	 (SETQ LINE (COPY-MUNGED-LINE LINE))
	 (SETF (BP-LINE BP) LINE))
	(T
	 (SETF (LINE-TICK LINE) *TICK*)
	 (SETF (LINE-CONTENTS-PLIST LINE) NIL)))
  LINE)

(DEFUN REPOINT-WINDOW-PLINES (OLD-LINE NEW-LINE)
  (LOOP FOR WINDOW IN *WINDOW-LIST*
	DO
    (LOOP FOR LX FROM 0 BELOW (WINDOW-N-PLINES WINDOW)
	  WHEN (EQ (PLINE-LINE WINDOW LX) OLD-LINE)
	    DO (SETF (PLINE-LINE WINDOW LX) NEW-LINE))))
						
(DEFUN COPY-MUNGED-LINE (LINE)
  (LET ((NEW-LINE (CREATE-LINE (ARRAY-TYPE LINE) (LINE-LENGTH LINE) (LINE-NODE LINE))))
    (REPOINT-WINDOW-PLINES LINE NEW-LINE)
    (COPY-ARRAY-CONTENTS LINE NEW-LINE)
    (SETF (LINE-PLIST NEW-LINE) (LINE-PLIST LINE))
    (SETF (LINE-PLIST LINE) NIL)
    (LET ((NEXT (LINE-NEXT LINE))
	  (PREVIOUS (LINE-PREVIOUS LINE)))
      (SETF (LINE-NEXT NEW-LINE) NEXT)
      (WHEN NEXT
	(SETF (LINE-PREVIOUS NEXT) NEW-LINE))
      (SETF (LINE-PREVIOUS NEW-LINE) PREVIOUS)
      (WHEN PREVIOUS
	(SETF (LINE-NEXT PREVIOUS) NEW-LINE)))
    (DOLIST (BP (SETF (LINE-BP-LIST NEW-LINE) (LINE-BP-LIST LINE)))
      (SETF (BP-LINE BP) NEW-LINE))
    (SETF (LINE-BP-LIST LINE) NIL)
    NEW-LINE))

;;; Nodes

;;; --- perhaps this should just return NIL, and BP-TOP-LEVEL-NODE should catch NIL?
(DEFUN BP-NODE (BP)
  "This required *INTERVAL* to be bound if the LINE-NODE of BP-LINE is not a NODE or is nil."
  (LET ((LINE (BP-LINE BP)))
    (IF (NOT (AND (LINE-NODE LINE) (SEND (LINE-NODE LINE) :NODE-P)))
	*INTERVAL*
	(DO ((NODE (LINE-NODE LINE) (OR (NODE-NEXT NODE) (NODE-SUPERIOR NODE)))	
	     (INDEX (BP-INDEX BP))
	     (LAST-BP))
	    ((OR (NEQ LINE (BP-LINE (SETQ LAST-BP (INTERVAL-LAST-BP NODE))))
		 ( (BP-INDEX LAST-BP) INDEX)
		 (EQ (BP-LINE (NODE-FIRST-BP NODE)) (BP-LINE (NODE-LAST-BP NODE))))
	     NODE)))))

(DEFUN BP-TOP-LEVEL-NODE (BP)
  (DO ((NODE (BP-NODE BP) SUPERIOR)
       (SUPERIOR))
      ((NULL (SETQ SUPERIOR (NODE-SUPERIOR NODE)))
       NODE)))

(DEFUN BP-TOP-LEVEL-LINE-LINKED-NODE (BP)
  (NODE-TOP-LEVEL-LINE-LINKED-NODE (BP-NODE BP)))

(DEFUN BP-BUFFER (BP)
  (OR (BP-BUFFER-INTERNAL BP)			;Permanent BP
      (AND *INTERVAL*
	   (INTERVAL-BUFFER *INTERVAL*))))	;Temporary BP

;Usually this returns INTERVAL, but if INTERVAL is a narrowing of a buffer as used
;by things like Query Replace and Zmail, this returns the parent buffer.
;(BP-BUFFER-INTERNAL (INTERVAL-FIRST-BP INTERVAL)) is for the benefit of temporary
;intervals that are not linked into the node structure, because NODE-SUPERIOR
;of them will not return their parent buffer.
;Checking for NAMED-BUFFER before doing the above is because Zmail's line-and-node
;structure for a message is somewhat confused.
;Searching upwards for a NAMED-BUFFER rather than just calling NODE-TOP-LEVEL-NODE
;is because of the way Zmail organizes its data structures; perhaps this should be
;changed if that is changed.

(DEFGENERIC INTERVAL-BUFFER (INTERVAL)
  (:METHOD (NAMED-BUFFER) SELF)
  (:METHOD (INTERVAL) (OR (BP-BUFFER-INTERNAL (INTERVAL-FIRST-BP SELF))
			  (AND (VARIABLE-BOUNDP *INTERVAL*) *INTERVAL*)
			  SELF))
  (:METHOD (NODE) 
   (LOOP FOR BUFFER = (OR (BP-BUFFER-INTERNAL (INTERVAL-FIRST-BP SELF)) SELF)
		    THEN SUPERIOR
	 AS SUPERIOR = (NODE-SUPERIOR BUFFER)
	 WHEN (TYPEP BUFFER 'NAMED-BUFFER)
	   RETURN BUFFER
	 UNLESS SUPERIOR
	   RETURN (IF (EQ BUFFER SELF) BUFFER (INTERVAL-BUFFER BUFFER)))))

;;; PREFERRED is for disambiguating for VC ViewSpecs
(DEFGENERIC INTERVAL-HOME-BUFFER (INTERVAL &OPTIONAL PREFERRED))

(DEFMETHOD (INTERVAL-HOME-BUFFER INTERVAL) (&OPTIONAL PREFERRED)
  (LET ((DIRECT-UP (INTERVAL-BUFFER SELF)))
    (IF (EQ DIRECT-UP SELF) SELF
	(INTERVAL-HOME-BUFFER DIRECT-UP PREFERRED))))	; recurse, so that if our parent
						;  has a different method, it gets a shot.

(DEFUN LINE-TOP-LEVEL-NODE (LINE)
  (IF (NOT (AND (LINE-NODE LINE) (SEND (LINE-NODE LINE) :NODE-P)))
      *INTERVAL*
      (DO* ((NODE (LINE-NODE LINE) SUPERIOR)
	    (SUPERIOR (AND NODE (NODE-SUPERIOR NODE)) (NODE-SUPERIOR NODE)))
	   ((NULL SUPERIOR) NODE))))

(DEFUN LINE-TOP-LEVEL-LINE-LINKED-NODE (LINE)
  (NODE-TOP-LEVEL-LINE-LINKED-NODE (LINE-NODE LINE)))

(DEFUN NODE-TOP-LEVEL-NODE (NODE)
  (DO ((NODE NODE SUPERIOR)
       (SUPERIOR))
      ((NULL (SETQ SUPERIOR (NODE-SUPERIOR NODE)))
       NODE))) 

;;; Normal intervals don't have unlinked lines, so this is the same as NODE-TOP-LEVEL-NODE
(DEFMETHOD (NODE-TOP-LEVEL-LINE-LINKED-NODE NODE) ()
  (IF SUPERIOR (NODE-TOP-LEVEL-LINE-LINKED-NODE SUPERIOR) SELF))

;NODE is not allowed to be a temporary interval not linked into the node structure
(DEFUN NODE-IN-BUFFER-P (NODE BUFFER)
  (LOOP DO
    (COND ((NULL NODE)
	   (RETURN NIL))
	  ((EQ NODE BUFFER)
	   (RETURN T))
	  ((SEND NODE :INFERIOR-TO-NODE BUFFER)
	   (RETURN T)))
    (SETQ NODE (NODE-SUPERIOR NODE))))

;;; Normal intervals don't have unlinked lines
(DEFMETHOD (:NEXT-UNLINKED-LINE NODE :DEFAULT) (LINE)
  (IGNORE LINE)
  NIL)

(DEFMETHOD (:PREVIOUS-UNLINKED-LINE NODE :DEFAULT) (LINE)
  (IGNORE LINE)
  NIL)

(DEFMETHOD (:MAJOR-MODE INTERVAL :DEFAULT) ()
  (MAJOR-MODE-FROM-KEYWORD ':FUNDAMENTAL))

(DEFMETHOD (:MAJOR-MODE NODE :DEFAULT) ()
  (OR
    (WHEN SUPERIOR
      (SEND SUPERIOR :MAJOR-MODE))
    (MAJOR-MODE-FROM-KEYWORD ':FUNDAMENTAL)))

(DEFMETHOD (:MAJOR-MODE BUFFER :DEFAULT) ()
  (OR (SEND SELF ':GET ':MAJOR-MODE)
      (MAJOR-MODE-FROM-KEYWORD ':FUNDAMENTAL)))

(DEFMETHOD (:MUNG NODE) (INNERMOST)
  ;; Mung the superior first, since it might be read-only
  (WHEN SUPERIOR
    (SEND SUPERIOR :MUNG NIL))
  (WHEN (EQ TICK ':READ-ONLY)
    (BARF "Read-only"))
  ;; Update our tick to match the current state of what is under us
  (SETF TICK *TICK*)
  ;; Inform the major mode, in case it is interested
  ;; if we have no major mode, then don't bother to send the message.
  (LET ((MM (SEND SELF :MAJOR-MODE)))
    (WHEN MM (SEND MM :MUNG-NODE SELF INNERMOST *TICK*))))

(DEFMETHOD (:MUNG-NODE MAJOR-MODE :DEFAULT) (NODE INNERMOST TICK)
  (IGNORE NODE INNERMOST TICK)
  NIL)

;;; Return T if X is after or at LINE, NIL if X is before LINE.
;;; This is written in a funny way to avoid crossing section boundaries if it isn't necessary,
;;; so that this can be called without binding *INTERVAL*.
(DEFUN SEARCH-FOR-LINE (X LINE)
  (LET ((BUFFER (LINE-TOP-LEVEL-NODE LINE)))
    (UNLESS (EQ (LINE-TOP-LEVEL-NODE X) BUFFER)
      (SETQ BUFFER (INTERVAL-BUFFER *INTERVAL*)))
    (LOOP FOR FORWARD = LINE THEN (LINE-NEXT-IN-BUFFER FORWARD :BUFFER BUFFER)
	  FOR BACKWARD = (LINE-PREVIOUS-IN-BUFFER LINE :BUFFER BUFFER)
		       THEN (LINE-PREVIOUS-IN-BUFFER BACKWARD :BUFFER BUFFER)
	  DO (COND ((EQ X FORWARD) (RETURN T))
		   ((EQ X BACKWARD) (RETURN NIL))
		   ((NULL FORWARD) (RETURN NIL))
		   ((NULL BACKWARD) (RETURN T))))))

(DEFUN BEG-LINE-P (BP)
  (OR (= (BP-INDEX BP) 0)
      (BP-= BP (INTERVAL-FIRST-BP *INTERVAL*))))

(DEFUN END-LINE-P (BP)
  (OR (= (BP-INDEX BP) (LINE-LENGTH (BP-LINE BP)))
      (BP-= BP (INTERVAL-LAST-BP *INTERVAL*))))

(DEFUN BEG-OF-LINE (LINE)
  (CREATE-BP LINE (IF (EQ LINE (BP-LINE (INTERVAL-FIRST-BP *INTERVAL*)))
		      (BP-INDEX (INTERVAL-FIRST-BP *INTERVAL*))
		      0)))

(DEFUN END-OF-LINE (LINE)
  (CREATE-BP LINE (IF (EQ LINE (BP-LINE (INTERVAL-LAST-BP *INTERVAL*)))
		      (BP-INDEX (INTERVAL-LAST-BP *INTERVAL*))
		      (LINE-LENGTH LINE))))

(DEFUN KILL-INTERVAL (BP1 &OPTIONAL BP2 IN-ORDER-P (FORWARDP T) EXPLICIT-P (SAVE-P T))
  (GET-INTERVAL BP1 BP2 IN-ORDER-P)
  (AND *KILL-INTERVAL-SMARTS*
       (NOT EXPLICIT-P)
       (OR (AND (EQ (BP-LINE BP1) (BP-LINE BP2)) (BEG-LINE-P BP1))
	   (AND (MEM #'CHAR-EQUAL (BP-CHAR-BEFORE BP1) *BLANKS*)
		(NOT (BEG-LINE-P (BACKWARD-OVER *BLANKS* BP1)))))
       (MOVE-BP BP2 (FORWARD-OVER *BLANKS* BP2)))
  (LET ((MERGE (AND (EQ *LAST-COMMAND-TYPE* 'KILL)
		    (EQ *KILL-HISTORY-USER* *CURRENT-COMMAND-LOOP*)))
	(KILL-RING-INTERVAL (AND SAVE-P (KILL-RING-SAVE-INTERVAL BP1 BP2 T FORWARDP)))
	BUFFER)
    (WHEN (AND *ENABLE-CHANGE-RECORDING*
	       (SETQ BUFFER (BP-CHANGE-RECORDING-BUFFER BP1)))
      (RECORD-ACCUMULATED-CHANGES BUFFER)	;Don't merge with anything except kills
      (BLOCK CHANGE-RECORD
	(WHEN MERGE
	  (LET ((CURRENT (FIRST (BUFFER-CHANGE-HISTORY BUFFER))))
	    (COND ((AND KILL-RING-INTERVAL FORWARDP (TYPEP CURRENT 'KILL-RECORD)
			(BP-= (CHANGE-RECORD-LAST-BP CURRENT) BP1)
			(EQ (BP-BUFFER (INTERVAL-FIRST-BP (CHANGE-RECORD-OLD-TEXT CURRENT)))
			    KILL-RING-INTERVAL))
		   (LET* ((OLD-TEXT (CHANGE-RECORD-OLD-TEXT CURRENT))
			  ;; Position OLD-START and OLD-END around OLD-TEXT as it
			  ;; was before merging
			  (OLD-START (INTERVAL-FIRST-BP OLD-TEXT))
			  ;; Should be (INTERVAL-LAST-BP OLD-TEXT), but apparently
			  ;; that sometimes gets moved by KILL-RING-SAVE-INTERVAL and
			  ;; other times does not get moved.  So recompute where it should be.
			  (OLD-END (FORWARD-CHAR (INTERVAL-LAST-BP KILL-RING-INTERVAL)
						 (- (COUNT-CHARS BP1 BP2 T NIL))
						 T OLD-TEXT)))
		     (MULTIPLE-VALUE-BIND (NIL NIL BP-POSITIONS)
			 (PREPARE-TO-RECORD BP1 BP2 NIL (CHANGE-RECORD-FIRST-BP CURRENT)
					    (CHANGE-RECORD-LAST-BP CURRENT)
					    (1- (COUNT-LINES OLD-START OLD-END T OLD-TEXT))
					    (BP-INDEX OLD-END)
					    (CHANGE-RECORD-BP-POSITIONS CURRENT))
		       (SETF (CHANGE-RECORD-BP-POSITIONS CURRENT)
			     (FINALIZE-BP-POSITIONS BP-POSITIONS))
		       (MOVE-BP (INTERVAL-LAST-BP (CHANGE-RECORD-OLD-TEXT CURRENT))
				(INTERVAL-LAST-BP KILL-RING-INTERVAL))
		       (MOVE-BP (CHANGE-RECORD-LAST-BP CURRENT) BP2)
		       (RETURN-FROM CHANGE-RECORD))))
		  ((AND KILL-RING-INTERVAL (NOT FORWARDP) (TYPEP CURRENT 'KILL-RECORD)
			(BP-= (CHANGE-RECORD-FIRST-BP CURRENT) BP2)
			(EQ (BP-BUFFER (INTERVAL-FIRST-BP (CHANGE-RECORD-OLD-TEXT CURRENT)))
			    KILL-RING-INTERVAL))
		   (MULTIPLE-VALUE-BIND (NIL NIL BP-POSITIONS)
		       (PREPARE-TO-RECORD BP1 BP2 T (CHANGE-RECORD-FIRST-BP CURRENT)
					  (CHANGE-RECORD-LAST-BP CURRENT) 0 0
					  (CHANGE-RECORD-BP-POSITIONS CURRENT))
		     (SETF (CHANGE-RECORD-BP-POSITIONS CURRENT)
			   (FINALIZE-BP-POSITIONS BP-POSITIONS))
		     (MOVE-BP (INTERVAL-FIRST-BP (CHANGE-RECORD-OLD-TEXT CURRENT))
			      (INTERVAL-FIRST-BP KILL-RING-INTERVAL))
		     (MOVE-BP (CHANGE-RECORD-FIRST-BP CURRENT) BP1)
		     (RETURN-FROM CHANGE-RECORD)))
		  (BUFFER
		   ;; Going to make a new change-record when the kill-ring-interval
		   ;; was merged and hence doesn't correspond.  Just make our own copy.
		   (SETQ KILL-RING-INTERVAL NIL)))))
	;; Make a MUNG-NODE-RECORD if necessary
	(MUNG-NODES-IN-INTERVAL BP1 BP2 T T)
	;; Now record the current contents of the interval, if possible sharing the
	;; copy of the old-text that was already made for the kill-ring.
	(UNLESS KILL-RING-INTERVAL
	  (SETQ KILL-RING-INTERVAL (CREATE-INTERVAL NIL NIL
						    (MAKE-INSTANCE 'KILL-RING-INTERVAL)))
	  (INSERT-INTERVAL (INTERVAL-FIRST-BP KILL-RING-INTERVAL) BP1 BP2 T))
	(CL:PUSH (MULTIPLE-VALUE-BIND (NIL NIL BP-POSITIONS)
		     (PREPARE-TO-RECORD BP1 BP2)
		   (MAKE-KILL-RECORD (SETQ BP1 (COPY-BP BP1 ':NORMAL))
				     BP1		;EQ BP's since it's a deletion
				     (FINALIZE-BP-POSITIONS BP-POSITIONS)
				     ;; Backwards status of these BPs is to keep them
				     ;; from moving if subsequent kill-ring merging happens
				     (CREATE-INTERVAL
				       (COPY-BP (INTERVAL-FIRST-BP KILL-RING-INTERVAL) ':MOVES)
				       (COPY-BP (INTERVAL-LAST-BP KILL-RING-INTERVAL) ':NORMAL)
				       NIL)))
		 (BUFFER-CHANGE-HISTORY BUFFER)
		 :AREA *CHANGE-RECORD-AREA*))))
  ;; If some DELETE-INTERVAL-1 method gets an error, then the undo history
  ;; has already been amended, and the kill-ring already has the interval 
  ;; on it.  It's up to each method to call BACK-OUT-OF-KILL-INTERVAL.
  (LET ((*ENABLE-CHANGE-RECORDING* NIL))
    (DELETE-INTERVAL BP1 BP2 T)))

;; Back out of the last call to KILL-INTERVAL
;;--- This is not completely right.  It's not straightforward to fix this
;;--- because of undo merging, and the case where undo has been disabled
;;--- for some duration, etc.
(defun back-out-of-kill-interval (from-bp &optional to-bp in-order-p)
  (get-interval from-bp to-bp in-order-p)
  ;; Pop the top element on the kill ring, ignoring kill-ring merging issues
  ;; (if there indeed are any)
  (send *kill-history* :pop)
  ;; Flush the very last thing saved on the undo list as best as possible
  (let* ((buffer (bp-change-recording-buffer from-bp))
	 (history (and buffer (buffer-change-history buffer))))
    (when history
      ;;--- This can lose pieces of the undo history due to merging
      (pop (buffer-change-history buffer)))))


(DEFUN KILL-INTERVAL-ARG (BP1 BP2 ARG)
  (IF (PLUSP ARG)
      (KILL-INTERVAL BP1 BP2 T T)
      (KILL-INTERVAL BP2 BP1 T NIL)))

;; Returns the KILL-RING-INTERVAL
(DEFUN KILL-RING-SAVE-INTERVAL (BP1 &OPTIONAL BP2 IN-ORDER-P FORWARDP &AUX INT)
  (GET-INTERVAL BP1 BP2 IN-ORDER-P)
  (WITHOUT-INTERRUPTS			;Interlock against kills in other processes
    (COND ((AND (EQ *LAST-COMMAND-TYPE* 'KILL)
		(EQ *KILL-HISTORY-USER* *CURRENT-COMMAND-LOOP*))
	   ;; Merge with previous kill
	   (SETQ INT (SEND *KILL-HISTORY* ':ELEMENT 0))
	   (UNLESS (TYPEP INT 'KILL-RING-INTERVAL)
	     (SETQ INT (CREATE-INTERVAL INT NIL (MAKE-INSTANCE 'KILL-RING-INTERVAL)))
	     (SEND *KILL-HISTORY* :REPLACE-TOP INT))
	   (INSERT-INTERVAL (COND (FORWARDP
				   (SETF (KILL-RING-INTERVAL-CHAR-AFTER INT) (BP-CHAR BP2))
				   (INTERVAL-LAST-BP INT))
				  (T (SETF (KILL-RING-INTERVAL-CHAR-BEFORE INT)
					   (BP-CHAR-BEFORE BP1))
				     (INTERVAL-FIRST-BP INT)))
			    (COPY-INTERVAL BP1 BP2 T)))
	  (T
	   (SETQ INT (COPY-INTERVAL BP1 BP2 T (MAKE-INSTANCE 'KILL-RING-INTERVAL
							     :CHAR-BEFORE (BP-CHAR-BEFORE BP1)
							     :CHAR-AFTER (BP-CHAR BP2))))
	   (SEND *KILL-HISTORY* :PUSH INT)))
    (SETQ *KILL-HISTORY-USER* *CURRENT-COMMAND-LOOP*)
    INT))

(DEFUN STRINGS-INTO-KILL-RING-INTERVAL (&REST STRINGS)
  (LET* ((INTERVAL (ZWEI:CREATE-INTERVAL NIL NIL (MAKE-INSTANCE 'ZWEI:KILL-RING-INTERVAL)))
	 (AT-BP (INTERVAL-LAST-BP INTERVAL))
	 (FIRST-P T))
    (DOLIST (STRING STRINGS)
      (IF FIRST-P
	  (SETQ FIRST-P NIL)
	  (INSERT AT-BP #\NEWLINE))
      (INSERT AT-BP STRING))
    INTERVAL))

;;; BP had better not be a :MOVES type bp
(DEFUN INSERT-KILL-RING-THING (BP THING)
  (WITH-BP (BP1 (INSERT-THING BP THING) ':MOVES)
    (WHEN *KILL-INTERVAL-SMARTS*
      (COND ((LOOKING-AT (FORWARD-OVER *BLANKS* BP) (OR *COMMENT-START* *COMMENT-BEGIN*))
	     ;; Yanking a comment.  Re-indent each line of it.  So c-m-; c-Y works.
	     (LOOP FOR BP = BP THEN (FORWARD-LINE BP) DO
	       (COND ((NOT (AND BP (BP-< BP BP1))) (RETURN))	;Reached end of yanked text
		     ((LOOKING-AT (FORWARD-OVER *BLANKS* BP)
				  (OR *COMMENT-START* *COMMENT-BEGIN*))
		      (INDENT-FOR-COMMENT BP))
		     ((STRING-SEARCH-NOT-SET *BLANKS* (BP-LINE BP))
		      (RETURN)))))		;Stop at first non-blank non-comment line
	    ((MEM #'CHAR-EQUAL (BP-CHAR-BEFORE BP) *BLANKS*)
	     (DELETE-OVER *BLANKS* BP))
	    (T (FIXUP-WHITESPACE BP (AND (TYPEP THING 'KILL-RING-INTERVAL)
					 (KILL-RING-INTERVAL-CHAR-BEFORE THING)))))
      (IF (MEM #'CHAR-EQUAL (BP-CHAR BP1) *BLANKS*)
	  (DELETE-BACKWARD-OVER *BLANKS* BP1)
	  (FIXUP-WHITESPACE BP1 (AND (TYPEP THING 'KILL-RING-INTERVAL)
				     (KILL-RING-INTERVAL-CHAR-AFTER THING)))))
    (COPY-BP BP1)))

;;; Predict (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")fixup-whitespace0.
;;; 2:force-left0 2t0 indicates we're going to do an insertion on the left side,
;;;   so suppress checking for the beginning of the line.
;;; 2:force-right0 2t0 indicates we're going to do an insertion on the right side,
;;;   so suppress checking for the end of the line.
(DEFUN FIND-FIXUP-WHITESPACE (BP &KEY FORCE-LEFT FORCE-RIGHT)
  (LET* ((BP1 (BACKWARD-OVER *BLANKS* BP))
	 (BP2 (FORWARD-OVER *BLANKS* BP))
	 (BP3 (FORWARD-CHAR BP1 -1))
	 (CH1 (IF BP3 (BP-CHAR BP3) #\CR))
	 (CH2 (BP-CHAR BP2))
	 (SOME-SPACE (NOT (BP-= BP1 BP2))))
    ;;Do nothing if at start or end of line, or if we've got funny syntax
    (UNLESS (OR (AND (NOT FORCE-LEFT) (CHAR-EQUAL CH1 #\CR))
		(AND (NOT FORCE-RIGHT) (CHAR-EQUAL CH2 #\CR))
		(AND (SEND (SEND *INTERVAL* :MAJOR-MODE) ':NON-LISP-SYNTAX BP1)
		     SOME-SPACE))		;If any funny syntax, leave whitespace there
      (VALUES BP1 BP2 T))))

(DEFUN FIXUP-WHITESPACE (BP DELIMITER &AUX )
  (MULTIPLE-VALUE-BIND (BP1 BP2)
      (FIND-FIXUP-WHITESPACE BP)
    (WHEN (AND BP1 BP2)
      (LET* ((BP3 (FORWARD-CHAR BP1 -1))
	     (CH1 (IF BP3 (BP-CHAR BP3) #\CR))
	     (CH2 (BP-CHAR BP2))
	     (SYN1 (LIST-SYNTAX CH1))
	     (SYN2 (LIST-SYNTAX CH2))
	     (SOME-SPACE (NOT (BP-= BP1 BP2)))
	     (FUNNY-SYNTAX (SEND (SEND *INTERVAL* :MAJOR-MODE)
				 ':NON-LISP-SYNTAX BP1)))
	(DELETE-INTERVAL BP1 BP2 T)		;Remove any pre-existing white space
	(AND (OR SOME-SPACE			;Keep one space if appropriate
		 (NULL DELIMITER)		;Insert new space if that's appropriate
		 (= (IF FUNNY-SYNTAX (WORD-SYNTAX DELIMITER) (ATOM-WORD-SYNTAX DELIMITER))
		    WORD-DELIMITER))
	     (IF FUNNY-SYNTAX
		 (AND ( (WORD-SYNTAX CH1) WORD-DELIMITER)
		      ( (WORD-SYNTAX CH2) WORD-DELIMITER))
	       (AND ( SYN1 LIST-OPEN) ( SYN1 LIST-SINGLE-QUOTE) ( SYN1 LIST-COLON)
		    ( SYN1 LIST-DELIMITER) ( SYN2 LIST-DELIMITER)
		    ( SYN2 LIST-CLOSE)))
	     (INSERT BP1 (IN-CURRENT-STYLE #\SP)))))))

(DEFUN COUNT-LINES (FROM-BP &OPTIONAL TO-BP IN-ORDER-P INTERVAL FROM-BP-IS-INTERVAL)
  (LET ((BUFFER (COND (INTERVAL (INTERVAL-BUFFER INTERVAL))
		      (TO-BP (AND (VARIABLE-BOUNDP *INTERVAL*)
				  *INTERVAL*
				  (INTERVAL-BUFFER *INTERVAL*)))
		      (T (IF FROM-BP-IS-INTERVAL FROM-BP (INTERVAL-BUFFER FROM-BP))))))
    (UNLESS TO-BP				;1-arg case
      (SETQ FROM-BP (INTERVAL-FIRST-BP BUFFER)
	    TO-BP (INTERVAL-LAST-BP BUFFER)
	    IN-ORDER-P T))
    (OR IN-ORDER-P (ORDER-BPS FROM-BP TO-BP))
    (DO ((LINE (BP-LINE FROM-BP) (LINE-NEXT-IN-BUFFER LINE :BUFFER BUFFER))
	 (LAST-LINE (BP-LINE TO-BP))
	 (I 1 (1+ I)))
	((OR (NULL LINE)				; fell off end of chain
	     (EQ LINE LAST-LINE))
	 (IF (NULL LINE) (1- I) I)))))

(DEFUN COUNT-CHARS (FROM-BP &OPTIONAL TO-BP IN-ORDER-P COUNT-DIAGRAMS)
  (GET-INTERVAL FROM-BP TO-BP IN-ORDER-P)
  (LET ((FIRST-LINE (BP-LINE FROM-BP))
	(FIRST-INDEX (BP-INDEX FROM-BP))
	(LAST-LINE (BP-LINE TO-BP))
	(LAST-INDEX (BP-INDEX TO-BP)))
    (MACROLET ((LINE-OR-DIAGRAM-LENGTH (LINE)
		 `(IF (AND COUNT-DIAGRAMS (LINE-DIAGRAM ,LINE))
		      #.(CL:LENGTH "<Diagram Line>")
		      (LINE-LENGTH ,LINE))))
      (IF (EQ FIRST-LINE LAST-LINE)
	  (COND ((ZEROP LAST-INDEX) 0)
		((AND COUNT-DIAGRAMS (LINE-DIAGRAM FIRST-LINE))
		 #.(CL:LENGTH "<Diagram Line>"))
		(T (- LAST-INDEX FIRST-INDEX)))
	(DO ((LINE (LINE-NEXT-IN-BUFFER FIRST-LINE) (LINE-NEXT-IN-BUFFER LINE))
	     (I 1 (+ 1 I (LINE-OR-DIAGRAM-LENGTH LINE))))
	    ((EQ LINE LAST-LINE)
	     (+ I
		(IF (AND COUNT-DIAGRAMS (LINE-DIAGRAM FIRST-LINE))
		    #.(CL:LENGTH "<Diagram Line>")
		    (- (LINE-LENGTH FIRST-LINE) FIRST-INDEX))
		(COND ((ZEROP LAST-INDEX) 0)
		      ((AND COUNT-DIAGRAMS (LINE-DIAGRAM LAST-LINE))
		       #.(CL:LENGTH "<Diagram Line>"))
		      (T LAST-INDEX)))))))))

(DEFUN LINE-N-CHARS (LINE)
  (LET ((FIRST-BP (INTERVAL-FIRST-BP *INTERVAL*))
	(LAST-BP (INTERVAL-LAST-BP *INTERVAL*)))
    (- (IF (EQ LINE (BP-LINE LAST-BP))
	   (BP-INDEX LAST-BP)
	   (LINE-LENGTH LINE))
       (IF (EQ LINE (BP-LINE FIRST-BP))
	   (BP-INDEX FIRST-BP)
	   0))))

(DEFUN SWAP-BPS (BP1 BP2)
  (LET ((LINE (BP-LINE BP1))
	(INDEX (BP-INDEX BP1)))
    (MOVE-BP BP1 BP2)
    (MOVE-BP BP2 LINE INDEX)))

(DEFUN SWAP-POINT-AND-MARK ()
  (INSURE-REGION-REACHABLE)
  (LET ((LINE (BP-LINE (POINT)))
	(INDEX (BP-INDEX (POINT))))
    (MOVE-POINT (MARK))
    (MOVE-MARK LINE INDEX)))

(DEFUN FLUSH-BP (BP)
  (LET ((LINE (BP-LINE BP)))
    (SETF (LINE-BP-LIST LINE) (DELQ BP (LINE-BP-LIST LINE) 1))))

(DEFUN BP-< (BP1 BP2)
  (LET ((LINE1 (BP-LINE BP1))
	(LINE2 (BP-LINE BP2)))
    (COND ((EQ LINE1 LINE2)
	   (< (BP-INDEX BP1) (BP-INDEX BP2)))
	  (T (NOT (SEARCH-FOR-LINE LINE1 LINE2))))))

(DEFUN BP-= (BP1 BP2)
  (AND (EQ (BP-LINE BP1) (BP-LINE BP2))
       (= (BP-INDEX BP1) (BP-INDEX BP2))))

(DEFUN BP-MIN (BP1 BP2)
  (IF (BP-< BP1 BP2) BP1 BP2))

(DEFUN BP-MAX (BP1 BP2)
  (IF (BP-< BP1 BP2) BP2 BP1))

;;; (BP- FIRST-BP BP LAST-BP), assuming (BP- FIRST-BP LAST-BP)
(DEFUN BP-IN-RANGE (BP FIRST-BP LAST-BP)
  (LET ((LINE (BP-LINE BP))
	(FIRST-LINE (BP-LINE FIRST-BP))
	(LAST-LINE (BP-LINE LAST-BP)))
    (COND ((EQ FIRST-LINE LAST-LINE)
	   (AND (EQ LINE FIRST-LINE)
		( (BP-INDEX FIRST-BP) (BP-INDEX BP) (BP-INDEX LAST-BP))))
	  ((EQ LINE FIRST-LINE)
	   ( (BP-INDEX BP) (BP-INDEX FIRST-BP)))
	  ((EQ LINE LAST-LINE)
	   ( (BP-INDEX BP) (BP-INDEX LAST-BP)))
	  (T
	   (LET ((BUFFER (LINE-TOP-LEVEL-NODE FIRST-LINE)))
	     (UNLESS (EQ (LINE-TOP-LEVEL-NODE LAST-LINE) BUFFER)
	       (SETQ BUFFER *INTERVAL*))
	     (DO ((L (LINE-NEXT-IN-BUFFER FIRST-LINE :BUFFER BUFFER)
		     (LINE-NEXT-IN-BUFFER L :BUFFER BUFFER)))
		 ((OR (EQ L LAST-LINE) (NULL L)) NIL)
	       (WHEN (EQ L LINE) (RETURN T))))))))

(DEFUN BP-CHAR (BP)
  (LET ((LINE (BP-LINE BP))
	(INDEX (BP-INDEX BP)))
    (COND ((= INDEX (LINE-LENGTH LINE)) #\CR)
	  (T (AREF LINE INDEX)))))

(DEFUN BP-CHAR-BEFORE (BP)
  (LET ((INDEX (BP-INDEX BP)))
    (COND ((ZEROP INDEX) #\CR)
	  (T (AREF (BP-LINE BP) (1- INDEX))))))

;;; Returns either NIL or the thing it deleted.
(DEFUN DELETE-LAST-ELEMENT (LIST)
  (AND (> (LENGTH LIST) 1)
       (DO ((L LIST (CDR L)))
	   ((NULL (CDDR L))
	    (PROG1 (CADR L) (RPLACD L NIL))))))

(DEFUN POINT-PDL-PUSH (BP WINDOW &OPTIONAL EXPLICIT (NOTIFICATION T) &AUX TEM)
  (SETQ TEM (LIST (COPY-BP BP ':NORMAL (WINDOW-INTERVAL WINDOW))
		  (PLINE-OF-POINT T WINDOW BP)))
  (AND EXPLICIT (SETQ TEM (NCONC TEM (NCONS EXPLICIT))))
  (PUSH TEM (WINDOW-POINT-PDL WINDOW))
  (AND (> (LENGTH (WINDOW-POINT-PDL WINDOW)) *POINT-PDL-MAX*)
       (FLUSH-BP (CAR (DELETE-LAST-ELEMENT (WINDOW-POINT-PDL WINDOW)))))
  (AND NOTIFICATION (TV:SHEET-EXPOSED-P *TYPEIN-WINDOW*)
       (TYPEIN-LINE *AUTO-PUSH-POINT-NOTIFICATION*)))

;Rotate nth (1-origin!) element to the front of the list, rotating the
;part of the list before it.  With a negative arg rotate the same amount
;backwards.  With an arg of 1 rotate the whole list BACKWARDS, i.e. bring
;up the same element as with an arg of 2 but store the old front at the back.
;Zero arg is undefined, do nothing I guess.  Note that 2 and -2 do the same thing.
;Doesn't barf if N is too big.  Alters the list in place.
(DEFUN ROTATE-TOP-OF-LIST (LIST N)
  (AND (= (ABS N) 1) (SETQ N (* N -1 (LENGTH LIST))))
  (COND ((PLUSP N)
	 (SETQ N (MIN (LENGTH LIST) N))
	 (DO ((I 0 (1+ I))
	      (LIST LIST (CDR LIST))
	      (NTH (NTH (1- N) LIST) OLD)
	      (OLD))
	     (( I N))
	   (SETQ OLD (CAR LIST))
	   (SETF (CAR LIST) NTH)))
	((MINUSP N)
	 (SETQ N (MIN (LENGTH LIST) (MINUS N)))
	 (DO ((I 1 (1+ I))
	      (LIST LIST (CDR LIST))
	      (FRONT (CAR LIST)))
	     (( I N) (SETF (CAR LIST) FRONT))
	   (SETF (CAR LIST) (CADR LIST)))))
  LIST)

(DEFUN POINT-PDL-POP (WINDOW)
  (LET ((PDL (WINDOW-POINT-PDL WINDOW)))
    (OR PDL (BARF))
    (LET ((ENTRY (CAR PDL)))
      (SETF (WINDOW-POINT-PDL WINDOW) (NCONC (CDR PDL) (RPLACD PDL NIL)))
      (VALUES-LIST ENTRY))))

(DEFUN POINT-PDL-EXCH (BP WINDOW ARG-P ARG &AUX PDL ENTRY)
  (SETQ PDL (WINDOW-POINT-PDL WINDOW))
  (AND (EQ ARG-P ':CONTROL-U) (SETQ ARG 0))
  (DO ((ARG (ABS ARG))
       (PDL (IF (MINUSP ARG) (REVERSE PDL) PDL) (CDR PDL))
       (ENT))
      ((OR (< ARG 0) (NULL PDL))
       (SETQ ENTRY (OR ENT (BARF))))
    (COND ((THIRD (CAR PDL))
	   (SETQ ENT (CAR PDL)
		 ARG (1- ARG)))))
  (SETF (WINDOW-POINT-PDL WINDOW)
	(CONS (LIST (COPY-BP BP ':NORMAL (WINDOW-INTERVAL WINDOW))
		    (PLINE-OF-POINT NIL WINDOW BP)
		    T)
	      (NCONC (DELQ ENTRY (DEL-IF #'(LAMBDA (E) (BP-= (CAR E) BP)) PDL))
		     (NCONS ENTRY))))
  (VALUES-LIST ENTRY))

;;; Move POINT to a BP, displayed at PLINE (which may be NIL)
(DEFUN POINT-PDL-MOVE (BP PLINE)
  (MOVE-POINT BP)
  (AND PLINE (REDISPLAY-POINT-ON-PLINE BP *WINDOW* PLINE)))

;;; Everything that moves POINT should call this function
;;; Arguments are a BP or a LINE and an INDEX
(DEFUN MOVE-POINT (BP &OPTIONAL INDEX)
  (MOVE-WINDOW-POINT *WINDOW* BP INDEX))

(DEFGENERIC BUFFER-CHANGE-POINT-TOP-LEVEL-NODE (BUFFER NEW-POINT-TOP-LEVEL-NODE)
  "This generic function is applied to WINDOW-INTERVAL of a window whenever the 
point is moving from one bp-top-level-node to another."
  )

(DEFGENERIC BUFFER-NO-LONGER-CURRENT (BUFFER)
  "This generic function is applied to WINDOW-INTERVAL of *WINDOW* when
it is changing to some other buffer."
  (:METHOD (INTERVAL) NIL)			;keep out of trouble.
  ;; ordinary zmacs buffer's don't need to do anything special for this.
  )


(DEFGENERIC EDITOR-CHANGE-WINDOW-INTERVAL (EDITOR WINDOW NEW-INTERVAL)
  (:METHOD (EDITOR)
   (SEND SELF :SET-WINDOW-INTERVAL WINDOW NEW-INTERVAL))
  (:METHOD (ZMACS-TOP-LEVEL-EDITOR)
   ;;special action for The Window.
   (IF (EQ WINDOW *WINDOW*)
       (MAKE-BUFFER-CURRENT NEW-INTERVAL)
       ;;otherwise, just like any other editor.
       ;; note that MAKE-BUFFER-CURRENT eventually does this for itself.
       (SEND SELF :SET-WINDOW-INTERVAL WINDOW NEW-INTERVAL))))

(DEFGENERIC EDITOR-MOVE-POINT-CAN-CHANGE-INTERVALS (EDITOR)
  (:METHOD (EDITOR) NIL)
  (:METHOD (ZMACS-TOP-LEVEL-EDITOR) T))

(DEFUN MOVE-WINDOW-POINT (WINDOW BP &OPTIONAL INDEX)
  ;; macrolet replaces the normal POINT macro with one that uses the argument.
  (LET ((INTERVAL (WINDOW-INTERVAL WINDOW)))
    (MACROLET ((POINT () `(WINDOW-POINT WINDOW)))
      (LET ((TARGET-BUFFER (COND (INDEX (INTERVAL-BUFFER (LINE-TOP-LEVEL-NODE BP)))
				 ((BP-BUFFER-INTERNAL BP))
				 ((INTERVAL-BUFFER (BP-TOP-LEVEL-NODE BP)))))
	    (CURRENT-T-L-N (BP-TOP-LEVEL-LINE-LINKED-NODE (POINT)))
	    (NEW-NODE (IF INDEX (LINE-NODE BP) (BP-NODE BP)))	;only used for complaints.
	    (NEW-T-L-N (IF INDEX (LINE-TOP-LEVEL-LINE-LINKED-NODE BP)
			   (BP-TOP-LEVEL-LINE-LINKED-NODE BP))))
	(UNLESS (EQ CURRENT-T-L-N NEW-T-L-N)
	  (UNLESS (NODE-IN-BUFFER-P NEW-T-L-N TARGET-BUFFER)
	    (DEBUGGING-BARF
	      "Bad argument passed to MOVE-POINT.  Please report this ZWEI bug.
    The node ~S, whose top-level-node is ~S, is not in the buffer ~S."
	      NEW-NODE NEW-T-L-N TARGET-BUFFER))
	  (WHEN (AND (VARIABLE-BOUNDP *CURRENT-COMMAND-LOOP*) *CURRENT-COMMAND-LOOP*
		     (EDITOR-MOVE-POINT-CAN-CHANGE-INTERVALS *CURRENT-COMMAND-LOOP*))
	    (COND ((EQ TARGET-BUFFER INTERVAL)
		   (BUFFER-CHANGE-POINT-TOP-LEVEL-NODE TARGET-BUFFER NEW-T-L-N))
		  (T
		   (EDITOR-CHANGE-WINDOW-INTERVAL *CURRENT-COMMAND-LOOP* WINDOW TARGET-BUFFER)
		   (SETQ INTERVAL (WINDOW-INTERVAL WINDOW))))))
	;; The next check can only be made when we are playing with
	;; *INTERVAL* / *WINDOW*, since narrowings are never done for
	;; other windows. 
	;;
	;; If INTERVAL is a narrowing of a buffer, make sure we aren't moving outside
	;; of it.  This check is expensive if INTERVAL is large, but will not be done
	;; in most cases because usually we will find
	;; (EQ (WINDOW-INTERVAL *WINDOW*) *INTERVAL*).
	(WHEN (EQ WINDOW *WINDOW*)
	  (LET ((STAR-INTERVAL-STAR *INTERVAL*))
	    (UNLESS (EQ INTERVAL STAR-INTERVAL-STAR)
	      (LET ((BP (IF INDEX (CREATE-BP BP INDEX) BP))
		    ;; Bind this so that we can use BP-< across hard section boundaries.
		    (*INTERVAL* (INTERVAL-BUFFER STAR-INTERVAL-STAR)))
		(WHEN (OR (BP-< BP (INTERVAL-FIRST-BP STAR-INTERVAL-STAR))
			  (BP-< (INTERVAL-LAST-BP STAR-INTERVAL-STAR) BP))
		  (DEBUGGING-BARF
		    "Attempt to move to part of the current buffer outside of the current interval.
Please report this ZWEI bug."))))))
	;; If desired, attempt to select a character style corresponding to insertion area.
	(WHEN *UPDATE-TYPEIN-CHARACTER-STYLE-WHEN-MOVING*
	  (LET ((LINE BP)
		(INDEX INDEX))
	    (WHEN (NULL INDEX)
	      (SETQ LINE (BP-LINE BP) INDEX (BP-INDEX BP)))
	    (UNLESS (AND (EQ (BP-LINE (POINT)) LINE)
			 (= (BP-INDEX (POINT)) INDEX))
	      (LET* ((CHAR-BEFORE (AND (PLUSP INDEX) (AREF LINE (1- INDEX))))
		     (STYLE-BEFORE (AND CHAR-BEFORE (SI:CHAR-STYLE-INDEX CHAR-BEFORE)))
		     (CHAR-AFTER (AND (< INDEX (LINE-LENGTH LINE)) (AREF LINE INDEX)))
		     (STYLE-AFTER (AND CHAR-AFTER (SI:CHAR-STYLE-INDEX CHAR-AFTER))))
		(LET ((STYLE (COND ((NULL STYLE-AFTER)
				    (OR STYLE-BEFORE 0))
				   ((NULL STYLE-BEFORE)
				    STYLE-AFTER)
				   ((= STYLE-BEFORE STYLE-AFTER)
				    STYLE-BEFORE)
				   ;; Prefer a printing character's style.
				   ((MEM #'CHAR-EQUAL CHAR-BEFORE *WHITESPACE-CHARS*)
				    STYLE-AFTER)
				   ((MEM #'CHAR-EQUAL CHAR-AFTER *WHITESPACE-CHARS*)
				    STYLE-BEFORE)
				   ;; Have two different possibilities, must check how
				   ;; we got here.  If we came from the right on the same
				   ;; line (c-B or m-B), use the right style still, else
				   ;; the left if from the left or far away.
				   ((EQ *UPDATE-TYPEIN-CHARACTER-STYLE-WHEN-MOVING* :AFTER)
				    STYLE-AFTER)
				   ((EQ *UPDATE-TYPEIN-CHARACTER-STYLE-WHEN-MOVING* :BEFORE)
				    STYLE-BEFORE)
				   ((LET ((POINT (POINT)))
				      (AND (EQ LINE (BP-LINE POINT))
					   (< INDEX (BP-INDEX POINT))))
				    ;; Moving to left from same line.
				    STYLE-AFTER)
				   (T STYLE-BEFORE))))
		  (WHEN ( STYLE *STYLE*)
		    (SETQ *STYLE* STYLE)
		    (WHEN (ZMACS-BUFFER-P TARGET-BUFFER)
		      (SETF (BUFFER-TYPEIN-CHARACTER-STYLE TARGET-BUFFER)
			    (AREF SI:*CHARACTER-STYLE-INDEX-TABLE* STYLE)))
		    (UPDATE-STYLE-NAME)))))))
	;; Finally, move point to desired place within this interval.
	(MOVE-BP-TO-VALID-POSITION-IN-BUFFER TARGET-BUFFER (POINT) BP INDEX)
	;; Return NIL in case called from PROCESS-SPECIAL-COMMAND for :TYPEOUT-EXECUTE
	NIL))))

(DEFUN MOVE-WINDOW-MARK (WINDOW BP &OPTIONAL INDEX)
  (MOVE-BP-TO-VALID-POSITION-IN-BUFFER (INTERVAL-BUFFER (WINDOW-INTERVAL WINDOW))
				       (WINDOW-MARK WINDOW) BP INDEX))

(DEFUN MOVE-MARK (BP &OPTIONAL INDEX)
  (MOVE-WINDOW-MARK *WINDOW* BP INDEX))

;;; Default method is straightforward
(DEFMETHOD (MOVE-BP-TO-VALID-POSITION-IN-BUFFER NODE) (BP LINE INDEX)
  (MOVE-BP BP LINE INDEX))

(DEFUN POINT-PDL-PURGE (BUFFER)
  (WHEN (AND (BOUNDP '*CURRENT-COMMAND-LOOP*) *CURRENT-COMMAND-LOOP*)
    (POINT-PDL-PURGE-INTERNAL *CURRENT-COMMAND-LOOP* BUFFER)))

(DEFUN ROTATE-POINT-PDL (WINDOW N &AUX POINT ENTRY LIST)
  (SETQ POINT (WINDOW-POINT WINDOW)
	ENTRY (LIST (COPY-BP POINT ':NORMAL (WINDOW-INTERVAL WINDOW))
		    (PLINE-OF-POINT T WINDOW POINT)
		    T)
	LIST (CONS ENTRY (WINDOW-POINT-PDL WINDOW)))
  (ROTATE-TOP-OF-LIST LIST N)
  (SETQ ENTRY (CAR LIST))
  (POINT-PDL-MOVE (CAR ENTRY) (CADR ENTRY))
  DIS-BPS)

(DEFUN MAYBE-PUSH-POINT (BP)
  (AND *AUTO-PUSH-POINT-OPTION*
       (BPS-FAR-APART BP (POINT) *AUTO-PUSH-POINT-OPTION*)
       (POINT-PDL-PUSH BP *WINDOW*)))

;;; Change the font of a character or a string
(DEFUN IN-CURRENT-STYLE (X &OPTIONAL (STYLE *STYLE*))
  (CL:ETYPECASE X
    (CL:CHARACTER
      (IF (CHAR-EQUAL X #\RETURN)
	  #\RETURN
	  (PROGN (SETF (SI:CHAR-STYLE-INDEX X) STYLE) X)))
    (STRING
      (IF (AND (ZEROP STYLE)
	       (NOT (STRING-FAT-P X)))
	  X
	  (LOOP WITH LENGTH = (STRING-LENGTH X)
		WITH S = (MAKE-ARRAY
			   LENGTH
			   :TYPE
			   ;; We can only use thin strings if the new string is being
			   ;; cast in the default style and all characters put in it have
			   ;; default character set and zero Bits.
			   (IF (AND (ZEROP STYLE)
				    (LOOP FOR I BELOW LENGTH
					  AS CHAR = (AREF X I)
					  ALWAYS (AND (ZEROP (SI:CHAR-BITS CHAR))
						      (ZEROP (SI:CHAR-CHAR-SET-INDEX CHAR)))))
			       'ART-STRING
			     'ART-FAT-STRING))
		FOR I BELOW LENGTH
		DO (SETF (AREF S I) (IN-CURRENT-STYLE (AREF X I) STYLE))
		FINALLY (RETURN S))))))

(DEFUN LINE-BLANK-P (LINE &OPTIONAL (DIAGRAM-IS-BLANK NIL) (START 0))
  (LET ((BLANKS *BLANKS*))
    (COND ((CHARACTERP LINE)
	   (MEM #'CHAR-EQUAL LINE BLANKS))
	  ;; Diagrams count as blank for most applications
	  ((LINE-DIAGRAM LINE) DIAGRAM-IS-BLANK)
	  (T
	   (LET ((LINE LINE))
	     (DECLARE (SYS:ARRAY-REGISTER LINE))
	     (DO ((I (IF (EQ LINE (BP-LINE (INTERVAL-FIRST-BP *INTERVAL*)))
			 (BP-INDEX (INTERVAL-FIRST-BP *INTERVAL*))
		       0)
		     (1+ I))
		  (LIM (IF (EQ LINE (BP-LINE (INTERVAL-LAST-BP *INTERVAL*)))
			   (BP-INDEX (INTERVAL-LAST-BP *INTERVAL*))
			 (LINE-LENGTH LINE))))
		 (( I LIM) T)
	       (OR (< I START)
		   (MEM #'CHAR-EQUAL (AREF LINE I) BLANKS)
		   (RETURN NIL))))))))

(DEFUN RANGE (X MIN MAX)
  (MAX MIN (MIN MAX X)))

;;; True if there is a non-empty region
(DEFUN WINDOW-REGION-P (&OPTIONAL (WINDOW *WINDOW*))
  (AND (WINDOW-MARK-P WINDOW)
       (NOT (BP-= (WINDOW-POINT WINDOW) (WINDOW-MARK WINDOW)))))

;;; If any of the BPs on the point pdl are the same as point,
;;; then they are useless; flush them.  Except, leave at least
;;; one BP on the pdl.
(DEFUN CLEAN-POINT-PDL (WINDOW)
  (DO ((L (WINDOW-POINT-PDL WINDOW) (CDR L))
       (PT (WINDOW-POINT WINDOW)))
      ((OR (NULL (CDR L))
	   (NOT (BP-= (CAAR L) PT)))
       (SETF (WINDOW-POINT-PDL WINDOW) L))
    (FLUSH-BP (CAAR L))))

(DEFUN STRING-MATCH (PATTERN SUBJECT)
  (LET ((PATTERN-LENGTH (STRING-LENGTH PATTERN)))
    (COND ((AND ( (STRING-LENGTH SUBJECT) PATTERN-LENGTH)
		(STRING-EQUAL PATTERN SUBJECT 0 0 PATTERN-LENGTH PATTERN-LENGTH))
	   PATTERN-LENGTH)
	  (T NIL))))

;;; Returns :BLANK, :COMMENT, :ATOM, :NORMAL, or :DIAGRAM, depending on the
;;; first non-blank character.
(DEFUN LINE-TYPE (LINE)
  (IF (LINE-DIAGRAM LINE)
      ':DIAGRAM
    (LET* ((LINE LINE)
	   (BLANKS *BLANKS*))
      (DECLARE (SYS:ARRAY-REGISTER LINE))
      (DO ((I (IF (EQ LINE (BP-LINE (INTERVAL-FIRST-BP *INTERVAL*)))
		  (BP-INDEX (INTERVAL-FIRST-BP *INTERVAL*))
		0)
	      (1+ I))
	   (LIM (IF (EQ LINE (BP-LINE (INTERVAL-LAST-BP *INTERVAL*)))
		    (BP-INDEX (INTERVAL-LAST-BP *INTERVAL*))
		  (LINE-LENGTH LINE))))
	  (( I LIM) ':BLANK)
	(LET ((CH (AREF LINE I)))
	  (OR (MEM #'CHAR-EQUAL CH BLANKS)
	      (RETURN (VALUES (COND ((LET ((IDX (FIND-COMMENT-START LINE)))
				       (AND IDX ( IDX I)))
				     ':COMMENT)
				    ((CHAR-EQUAL CH #\FF) ':FORM)
				    ((= (LIST-SYNTAX CH) LIST-ALPHABETIC)
				     ':ATOM)
				    (T ':NORMAL))
			      I))))))))

;;; Like LINE-TYPE, except that it is much faster since it does not depend on
;;; lines being parsed.  Used only during sectionization.
(DEFUN FAST-LINE-TYPE (LINE)
  (IF (LINE-DIAGRAM LINE)
      ':DIAGRAM
    (LET* ((LINE LINE))
      (DECLARE (SYS:ARRAY-REGISTER LINE))
      (DO ((I (IF (EQ LINE (BP-LINE (INTERVAL-FIRST-BP *INTERVAL*)))
		  (BP-INDEX (INTERVAL-FIRST-BP *INTERVAL*))
		0)
	      (1+ I))
	   (LIM (IF (EQ LINE (BP-LINE (INTERVAL-LAST-BP *INTERVAL*)))
		    (BP-INDEX (INTERVAL-LAST-BP *INTERVAL*))
		  (LINE-LENGTH LINE))))
	  (( I LIM) ':BLANK)
	(LET ((CH (AREF LINE I)))
	  (OR (CHAR-EQUAL CH #/Space) (CHAR-EQUAL CH #/Tab)
	      (RETURN (COND ((COMMENT-STARTS-AT-INDEX-P LINE I)
			     ':COMMENT)
			    ((= (LIST-SYNTAX CH) LIST-ALPHABETIC)
			     ':ATOM)
			    ((CHAR-EQUAL CH #\FF) ':FORM)
			    (T ':NORMAL)))))))))

;;; Uppercasify the character pointed to by BP.
(DEFUN UPCASE-CHAR (BP)
  (LET ((LINE (BP-LINE BP))
	(INDEX (BP-INDEX BP)))
    (COND ((< INDEX (LINE-LENGTH LINE))
	   (SETQ LINE (MUNG-BP-LINE-AND-INTERVAL BP))
	   (PREPARE-TO-CHANGE BP (CREATE-BP LINE (1+ INDEX)))
	   (ASET (CHAR-UPCASE (AREF LINE INDEX)) LINE INDEX)))))

;;; Lowercasify the character pointed to by BP.
(DEFUN DOWNCASE-CHAR (BP)
  (LET ((LINE (BP-LINE BP))
	(INDEX (BP-INDEX BP)))
    (COND ((< INDEX (LINE-LENGTH LINE))
	   (SETQ LINE (MUNG-BP-LINE-AND-INTERVAL BP))
	   (PREPARE-TO-CHANGE BP (CREATE-BP LINE (1+ INDEX)))
	   (ASET (CHAR-DOWNCASE (AREF LINE INDEX)) LINE INDEX)))))

;;; Uppercasify all characters in the specified interval.
(DEFUN UPCASE-INTERVAL (BP1 &OPTIONAL BP2 IN-ORDER-P)
  (GET-INTERVAL BP1 BP2 IN-ORDER-P)
  (WITH-INTERVAL-WRITE-LOCKED (BP1 BP2 T)
    ;; Make a MUNG-NODE-RECORD if necessary
    (MUNG-NODES-IN-INTERVAL BP1 BP2 T T)
    ;; Now record the current contents of the interval
    (PREPARE-TO-CHANGE BP1 BP2)
    (CHARMAP (BP1 BP2 NIL)
      (LET ((BEFORE (CHARMAP-CHAR)))
	(LET ((AFTER (CHAR-UPCASE BEFORE)))
	  (COND ((NOT (EQL BEFORE AFTER))
		 (CHARMAP-SET-CHAR AFTER))))))))

;;; Lowercasify all characters in the specified interval.
(DEFUN DOWNCASE-INTERVAL (BP1 &OPTIONAL BP2 IN-ORDER-P)
  (GET-INTERVAL BP1 BP2 IN-ORDER-P)
  (WITH-INTERVAL-WRITE-LOCKED (BP1 BP2 T)
    ;; Make a MUNG-NODE-RECORD if necessary
    (MUNG-NODES-IN-INTERVAL BP1 BP2 T T)
    ;; Now record the current contents of the interval
    (PREPARE-TO-CHANGE BP1 BP2)
    (CHARMAP (BP1 BP2 NIL)
      (LET ((BEFORE (CHARMAP-CHAR)))
	(LET ((AFTER (CHAR-DOWNCASE BEFORE)))
	  (COND ((NOT (EQL BEFORE AFTER))
		 (CHARMAP-SET-CHAR AFTER))))))))

(DEFVAR *ALIASES-FOR-RELEVANT-FUNCTION-NAME*
	'((FLAVOR:METHOD    . 1)
	  (FLAVOR:NCWHOPPER . 1)
	  (FLAVOR:WRAPPER   . 1)
	  (FLAVOR:WHOPPER   . 1)))

;; DEFINED-P can be T, NIL, or :ANY meaning "this must be a defined function",
;; "this can be anything at all", or "this must at least be in an editor buffer".
(DEFUN RELEVANT-FUNCTION-NAME (BP &OPTIONAL STRINGP (DEFINED-P T) (FUNCALL-SPECIAL T) ALIAS-P)
  (DECLARE (VALUES FUNCTION-NAME BP STRIP-ARGUMENTS))
  (WITH-NODE-READ-LOCKED ((BP-NODE-TO-LOCK BP))
    (MULTIPLE-VALUE-CALL
      #'(LAMBDA (FSPEC &REST MORE)
	  (LET ((ALIAS (WHEN (AND ALIAS-P (NOT (ATOM FSPEC)))
			 (LET ((ENTRY (ASSQ (CAR FSPEC) *ALIASES-FOR-RELEVANT-FUNCTION-NAME*)))
			   (WHEN ENTRY (NTH (CDR ENTRY) FSPEC))))))
	    (VALUES-LIST (CONS (OR ALIAS FSPEC) MORE))))
      (SEND (SEND *INTERVAL* :MAJOR-MODE) :RELEVANT-FUNCTION-NAME
	    BP STRINGP DEFINED-P FUNCALL-SPECIAL))))

;;; Return T if BPs are at least N lines apart, i.e. at least N-1 lines intervene between
;;; (Used by MAYBE-PUSH-POINT.)
(DEFUN BPS-FAR-APART (BP1 BP2 N)
  (LET ((LINE1 (BP-LINE BP1))
	(LINE2 (BP-LINE BP2)))
    (NOT (OR (DO ((L LINE1 (LINE-NEXT L))
		  (I 0 (1+ I)))
		 (( I N) NIL)
	       (IF (EQ L LINE2) (RETURN T))
	       (IF (NULL L) (RETURN NIL)))
	     (DO ((L LINE1 (LINE-PREVIOUS L))
		  (I 0 (1+ I)))
		 (( I N) NIL)
	       (IF (EQ L LINE2) (RETURN T))
	       (IF (NULL L) (RETURN NIL)))))))

;;; Return T if BPs are more than N characters apart.
(DEFUN BPS-CHARS-FAR-APART (BP1 BP2 N)
  (LET ((LINE1 (BP-LINE BP1))
	(LINE2 (BP-LINE BP2)))
    (IF (EQ LINE1 LINE2)
	(> (ABS (- (BP-INDEX BP1) (BP-INDEX BP2))) N)
	;; This is written in a funny way to avoid crossing section boundaries if it
	;; isn't necessary, so that this can be called without binding *INTERVAL*.
	(LET ((BUFFER (LINE-TOP-LEVEL-NODE LINE1)))
	  (UNLESS (EQ (LINE-TOP-LEVEL-NODE LINE2) BUFFER)
	    (SETQ BUFFER *INTERVAL*))
	  (NOT (OR ;; Search forward from BP1 for BP2
		   (DO ((L LINE1 (LINE-NEXT-IN-BUFFER L :BUFFER BUFFER))
			(I (- (BP-INDEX BP1)) (+ I (LINE-LENGTH L) 1)))	;Chars from BP1 to L[0]
		       ((> I N) NIL)
		     (IF (EQ L LINE2) (RETURN ( (+ I (BP-INDEX BP2)) N)))
		     (IF (NULL L) (RETURN NIL)))
		   ;; Search forward from BP2 for BP1
		   (DO ((L LINE2 (LINE-NEXT-IN-BUFFER L :BUFFER BUFFER))
			(I (- (BP-INDEX BP2)) (+ I (LINE-LENGTH L) 1)))	;Chars from BP2 to L[0]
		       ((> I N) NIL)
		     (IF (EQ L LINE1) (RETURN ( (+ I (BP-INDEX BP1)) N)))
		     (IF (NULL L) (RETURN NIL)))))))))

(DEFUN PARAGRAPH-INTERVAL (BP &OPTIONAL (N 1) &AUX OTHER-BP)
  (LET ((TEMP-BP (DO ((BP BP (FORWARD-LINE BP 1)))
		     ((NULL BP)
		      (INTERVAL-LAST-BP *INTERVAL*))
		   (IF (NOT (LINE-BLANK-P (BP-LINE BP)))
		       (RETURN BP)))))
    (SETQ TEMP-BP (FORWARD-PARAGRAPH TEMP-BP 1 T))
    (SETQ TEMP-BP (FORWARD-PARAGRAPH TEMP-BP -1 T))
    (SETQ OTHER-BP (FORWARD-PARAGRAPH TEMP-BP N T))
    (CREATE-INTERVAL TEMP-BP OTHER-BP)))

;;; Interval I/O

(DEFUN MAKE-HACK-FONTS-STYLE-CHECKER (FUNCTION POSITION &OPTIONAL MORE-P)
  (CHECK-ARG-TYPE FUNCTION :SYMBOL)
  (FLET ((CHECK-HACK-FONTS-ARGUMENT (FORM)
	   (WHEN (AND (> (LENGTH FORM) POSITION)
		      (OR (NOT MORE-P)
			  (NTH POSITION FORM)))
	     (COMPILER:WARN NIL "~S no longer uses the hack-fonts argument." FUNCTION))))
    (PUTPROP FUNCTION #'CHECK-HACK-FONTS-ARGUMENT 'COMPILER:STYLE-CHECKER)))

;;--- remove this someday
(DEFUN INTERVAL-STREAM (FROM-BP &OPTIONAL TO-BP IN-ORDER-P HACK-FONTS)
  (IGNORE HACK-FONTS)
  (OPEN-INTERVAL-STREAM FROM-BP TO-BP IN-ORDER-P))
(COMPILER:MAKE-OBSOLETE INTERVAL-STREAM
			"INTERVAL-STREAM has been replaced by OPEN-INTERVAL-STREAM")
(MAKE-HACK-FONTS-STYLE-CHECKER 'INTERVAL-STREAM 4)

(DEFUN OPEN-INTERVAL-STREAM (FROM-BP &OPTIONAL TO-BP IN-ORDER-P
			     &KEY (FLAVOR 'INTERVAL-STREAM))
  (LET ((STREAM (MAKE-INSTANCE FLAVOR)))
    (INITIALIZE-INTERVAL-STREAM STREAM FROM-BP TO-BP IN-ORDER-P)
    STREAM))

(DEFRESOURCE INTERVAL-STREAMS (FROM-BP &OPTIONAL TO-BP IN-ORDER-P
				       &KEY
				       (SELECTOR ':TEXT)	;---no longer used
				       (FLAVOR 'INTERVAL-STREAM))
  :CONSTRUCTOR (MAKE-INSTANCE FLAVOR)
  :MATCHER (EQ (FLAVOR:FLAVOR-NAME (SYS:%INSTANCE-FLAVOR OBJECT)) FLAVOR)
  :INITIALIZER (INITIALIZE-INTERVAL-STREAM OBJECT FROM-BP TO-BP IN-ORDER-P)
  )

(DEFMACRO WITH-INTERVAL-STREAM ((STREAM FROM-BP &OPTIONAL TO-BP IN-ORDER-P &KEY
					FLAVOR) &BODY BODY)
  `(USING-RESOURCE (,STREAM INTERVAL-STREAMS ,FROM-BP ,TO-BP ,IN-ORDER-P
		    ,@(WHEN FLAVOR `(:FLAVOR ,FLAVOR)))
     ,@BODY))

;;--- remove this someday
;;; Return an interval stream outputing at BP
(DEFUN INTERVAL-STREAM-INTO-BP (BP &OPTIONAL HACK-FONTS)
  (IGNORE HACK-FONTS)
  (OPEN-INTERVAL-STREAM BP BP T))
(COMPILER:MAKE-OBSOLETE INTERVAL-STREAM-INTO-BP
			"INTERVAL-STREAM-INTO-BP is obsolete, use OPEN-INTERVAL-STREAM")
(MAKE-HACK-FONTS-STYLE-CHECKER 'INTERVAL-STREAM-INTO-BP 2)

(DEFUN REST-OF-INTERVAL-STREAM (BP)
  (OPEN-INTERVAL-STREAM BP (INTERVAL-LAST-BP *INTERVAL*) T))

;;;--- these need to be replaced, or people just shoved into using OPEN-EDITOR-STREAM.
;;; Copy from the stream into the interval until EOF.
;;; Returns a BP to where the end of the inserted text is.
(DEFUN STREAM-INTO-BP (STREAM BP &OPTIONAL HACK-FONTS)
  (IGNORE HACK-FONTS)
  (LET ((INT-STREAM (OPEN-INTERVAL-STREAM BP BP T)))
    (STREAM-COPY-UNTIL-EOF STREAM INT-STREAM LINE-LEADER-SIZE)
    (FUNCALL INT-STREAM ':READ-BP)))
(MAKE-HACK-FONTS-STYLE-CHECKER 'STREAM-INTO-BP 3)

;;; Copy from the interval into the stream.
(DEFUN STREAM-OUT-INTERVAL (STREAM FROM-BP &OPTIONAL TO-BP IN-ORDER-P HACK-FONTS
			    WARN-IF-PARENTHESES-UNBALANCED)
  (IGNORE HACK-FONTS)
  (GET-INTERVAL FROM-BP TO-BP IN-ORDER-P)
  (FUNCALL (IF WARN-IF-PARENTHESES-UNBALANCED
	       #'STREAM-COPY-UNTIL-EOF-CHECKING-PARENTHESES
	       #'STREAM-COPY-UNTIL-EOF)
    (OPEN-INTERVAL-STREAM FROM-BP TO-BP T)
    STREAM))
(MAKE-HACK-FONTS-STYLE-CHECKER 'STREAM-OUT-INTERVAL 5 T)


(DEFFLAVOR INTERVAL-STREAM
	(INTERVAL BUFFER
	 LINE INDEX				;Point to the next character returned.
						;If INDEX is NIL, we're at EOF.
	 STOP-INDEX				;Where to stop in this line (usually the end).
	 LAST-LINE LAST-INDEX			;Where interval ends
	 NODE-LEVEL				;These are for compiler warnings
	 LAST-NODE-LEVEL
	 OUTPUT-LINE-NODE			;put this in line-node of new lines.
	 (RETURN-DIAGRAMS-AS-LINES NIL)
	 (CURRENT-CHARACTER-STYLE SI:*NULL-STYLE*)
	 )
	(SI:BIDIRECTIONAL-STREAM SI:CHARACTER-STREAM)
  (:SETTABLE-INSTANCE-VARIABLES RETURN-DIAGRAMS-AS-LINES)
  (:GETTABLE-INSTANCE-VARIABLES INTERVAL)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (INITIALIZE-INTERVAL-STREAM INTERVAL-STREAM)
	   (FROM-BP &OPTIONAL TO-BP IN-ORDER-P)
  (SETQ NODE-LEVEL NIL LAST-NODE-LEVEL NIL)
  (WHEN (AND (NULL TO-BP)
	     (NOT (INSTANCEP FROM-BP)))
    (SETQ TO-BP FROM-BP))			;support INTERVAL-STREAM-INTO-BP
  (SETQ BUFFER					;NIL or the containing (Zmacs) buffer
	(COND ((IF TO-BP			;Arguments are two BPs
		   (BP-BUFFER-INTERNAL FROM-BP)	;FROM-BP's buffer if it knows it
		   (AND (TYPEP FROM-BP 'BUFFER)	;Argument is an interval
			FROM-BP)))		;Use interval if it is a buffer
	      ((AND (VARIABLE-BOUNDP *INTERVAL*)	;Current buffer if known
		    (TYPEP *INTERVAL* 'BUFFER))
	       *INTERVAL*)
	      (T NIL)))				;NIL if we have literally no idea (not Zmacs)
  ;; try to bind *interval* to something if we possibly can.
  (LET-IF (OR BUFFER (AND (NOT (VARIABLE-BOUNDP *INTERVAL*))
			  (NULL TO-BP)))
	  ((*INTERVAL* (OR BUFFER (INTERVAL-HOME-BUFFER FROM-BP))))
    (GET-INTERVAL FROM-BP TO-BP IN-ORDER-P))
  (SETQ OUTPUT-LINE-NODE (LINE-NODE (BP-LINE TO-BP)))
  (SETQ INTERVAL (CREATE-INTERVAL FROM-BP TO-BP T)
	LINE (BP-LINE FROM-BP)
	INDEX (BP-INDEX FROM-BP)
	LAST-LINE (BP-LINE TO-BP)
	LAST-INDEX (BP-INDEX TO-BP)
	STOP-INDEX (IF (EQ (BP-LINE FROM-BP) (BP-LINE TO-BP))
		       (BP-INDEX TO-BP)
		       (LINE-LENGTH (BP-LINE FROM-BP)))
	RETURN-DIAGRAMS-AS-LINES NIL
	CURRENT-CHARACTER-STYLE SI:*NULL-STYLE*))


;;;+++ This version doesn't work for nested uses of with-character-style.
;;; The previous version that called the continuation on a string stream didn't work if
;;; the continuation sent messages specific to STREAM-VAR.
;;; For example, Show Processes :Output Destination Buffer Foo.
(DEFMETHOD (:WITH-CHARACTER-STYLE INTERVAL-STREAM)
	   (STYLE CONTINUATION STREAM-VAR BIND-LINE-HEIGHT)
  (IGNORE BIND-LINE-HEIGHT)
  (LETF ((CURRENT-CHARACTER-STYLE
	   (SI:MERGE-CHARACTER-STYLES STYLE CURRENT-CHARACTER-STYLE)))
    (FUNCALL CONTINUATION STREAM-VAR)))

(DEFMETHOD (:CLOSE INTERVAL-STREAM) (&OPTIONAL MODE)
  MODE
  (SETQ LINE :CLOSED))

(DEFMETHOD (:LISTEN INTERVAL-STREAM) () T)

(DEFUN-IN-FLAVOR (NEXT-LINE INTERVAL-STREAM) ()
  (IF (EQ LINE LAST-LINE)
      ;; Asked to advance past the last line.
      (SETQ INDEX NIL)
    ;; Asked to advance past any other line.
    (SETQ LINE (LINE-NEXT-IN-BUFFER LINE :BUFFER (OR BUFFER INTERVAL)))
    (IF (NULL LINE)
	(SETQ INDEX NIL)
      (SETQ INDEX 0)
      (SETQ STOP-INDEX (IF (EQ LINE LAST-LINE)
			   LAST-INDEX
			 (LINE-LENGTH LINE))))))

(DEFMETHOD (:TYI INTERVAL-STREAM) (&OPTIONAL EOF)
  (COND ((NULL INDEX)
	 ;; Already past the end of the interval.
	 (WHEN EOF
	   (ERROR 'SYS:END-OF-FILE :STREAM SELF :FORMAT-STRING EOF))
	 NIL)
	((< INDEX STOP-INDEX)
	 ;; In the middle of a line.
	 (LET ((CHAR-READ (AREF LINE INDEX)))
	   (INCF INDEX)
	   CHAR-READ))
	(T
	 ;; At the end of a line or the interval.
	 (LET ((CHAR-READ (UNLESS (EQ LINE LAST-LINE) #\Return)))
	   (NEXT-LINE)
	   (WHEN (AND (NULL INDEX) EOF)
	     (ERROR 'SYS:END-OF-FILE :STREAM SELF :FORMAT-STRING EOF))
	   CHAR-READ))))

(DEFMETHOD (:UNTYI INTERVAL-STREAM) (CH)
  (OR (EQL CH (COND ((NULL INDEX)
		     NIL)
		    ((ZEROP INDEX)
		     (SETQ LINE (OR (LINE-PREVIOUS-IN-BUFFER LINE :BUFFER (OR BUFFER INTERVAL))
				    (FERROR "Attempt to :UNTYI past the beginning"))
			   STOP-INDEX (LINE-LENGTH LINE)
			   INDEX STOP-INDEX)
		     #\CR)
		    (T (DECF INDEX)
		       (LET ((CH1 (AREF LINE INDEX)))
			 CH1))))
      (FERROR "Attempt to :UNTYI something other than last :TYI'ed")))

;;; Informs STREAM-COPY-UNITL-EOF that it should use :LINE-IN/:LINE-OUT to copy from an
;;; interval stream rather than :STRING-LINE-IN/:STRING-OUT.
(DEFMETHOD (:LINE-IN-MORE-EFFICIENT-THAN-STRING-LINE-IN-P INTERVAL-STREAM) ()
  T)

(DEFMETHOD (:CAN-ACCEPT-DIAGRAMS-AS-LINES INTERVAL-STREAM) () T)

(DEFCONST *INTERVAL-STREAM-LINE-IN-NULL-LINE* "")	;to avoid consing unnecessarily

(DEFMETHOD (:LINE-IN INTERVAL-STREAM) (&OPTIONAL SIZE EOF)
  (DECLARE (VALUES LINE EOF-P))
  (LET ((EOF-P (EQ LINE LAST-LINE)))
    (COND ((AND (NULL SIZE)
		(EQL INDEX 0)
		(OR (= STOP-INDEX (LINE-LENGTH LINE))
		    (AND EOF-P (ZEROP STOP-INDEX))))
	   ;; Caller wants to use the original line whenever possible --
	   ;;    If the current line is also the last line but we aren't actually taking
	   ;;    any text from the last line (i.e., STOP-INDEX is zero), we'll return a
	   ;;    constant null string.  This special check avoids unecessarily consing null
	   ;;    strings when saving messages in Zmail as the headers interval of a message
	   ;;    always ends at the beginning of the first line of the message body.
	   (LET ((LINE-READ (IF (= STOP-INDEX (LINE-LENGTH LINE))
				(OR (AND RETURN-DIAGRAMS-AS-LINES (LINE-DIAGRAM LINE))
				    LINE)
			      *INTERVAL-STREAM-LINE-IN-NULL-LINE*)))
	     (NEXT-LINE)
	     (VALUES LINE-READ EOF-P)))
	  ((NULL INDEX)
	   ;; Already past the end of the interval.
	   (WHEN EOF
	     (ERROR 'SYS:END-OF-FILE :STREAM SELF :FORMAT-STRING EOF))
	   (VALUES (IF (NULL SIZE) *INTERVAL-STREAM-LINE-IN-NULL-LINE* "") T))
	  (T
	   ;; Caller wants a copy or we are returning only part of this line.
	   (LET* ((LENGTH (- STOP-INDEX INDEX))
		  (LINE-READ (MAKE-ARRAY LENGTH :TYPE (ARRAY-TYPE LINE)
						:LEADER-LENGTH (IF (NUMBERP SIZE) SIZE))))
	     (COPY-ARRAY-PORTION LINE INDEX STOP-INDEX LINE-READ 0 LENGTH)
	     (WHEN (NUMBERP SIZE)
	       (SETF (FILL-POINTER LINE-READ) LENGTH))
	     (NEXT-LINE)
	     (VALUES LINE-READ EOF-P))))))

;;; Combine benefits of :line-in and :string-in.
;;; Get a line into an array passed in as an argument, and avoid consing.
(DEFMETHOD (:STRING-LINE-IN INTERVAL-STREAM) (EOF LINE-ARG &OPTIONAL (START 0) END)
  (DECLARE (VALUES LENGTH-SO-FAR EOF-P MORE-ON-LINE-P))
  ;; Default the END argument in the usual fashion
  ;; Use length rather than active-length, of course, since we're storing into the string
  (WHEN (NULL END)
    (SETQ END (ARRAY-LENGTH LINE-ARG)))
  (LET ((LEADER-P (ARRAY-HAS-LEADER-P LINE-ARG))
	(ARG-LENGTH (- END START)))
    (COND ((NULL INDEX)
	   ;; End of file.
	   (WHEN EOF
	     (ERROR 'SYS:END-OF-FILE :STREAM SELF :FORMAT-STRING EOF))
	   (VALUES 0 T NIL))
	  (T
	   ;; Copy the line
	   (LET* ((LENGTH (- STOP-INDEX INDEX))
		  (ACTUAL-LENGTH (MIN LENGTH ARG-LENGTH))
		  (LENGTH-SO-FAR (+ START ACTUAL-LENGTH))
		  (EOF-P (AND (EQ LINE LAST-LINE) (= LENGTH ACTUAL-LENGTH))))
	     (COPY-ARRAY-PORTION LINE INDEX (+ INDEX ACTUAL-LENGTH)
				 LINE-ARG START LENGTH-SO-FAR)
	     (IF LEADER-P
		 (SETF (FILL-POINTER LINE-ARG) LENGTH-SO-FAR))
	     (INCF INDEX ACTUAL-LENGTH)
	     (COND (( INDEX STOP-INDEX)
		    (NEXT-LINE)
		    (VALUES LENGTH-SO-FAR EOF-P NIL))
		   (T
		    (VALUES LENGTH-SO-FAR EOF-P T))))))))

(DEFMETHOD (:TYO INTERVAL-STREAM) (CH)
  (LET* ((*INTERVAL* OUTPUT-LINE-NODE)
	 (*ENABLE-CHANGE-RECORDING* NIL)
	 (BP (INSERT (CREATE-BP LINE INDEX)
		     (SI:MAKE-MERGED-CHAR CH CURRENT-CHARACTER-STYLE))))
    (SETQ LINE (BP-LINE BP) INDEX (BP-INDEX BP))))

(DEFMETHOD (:LINE-OUT INTERVAL-STREAM) (STRING &OPTIONAL (START 0) END)
  (LET ((*INTERVAL* OUTPUT-LINE-NODE)
	(*ENABLE-CHANGE-RECORDING* NIL))
    (WHEN (INSTANCEP STRING)
      (LET ((LINE (MAKE-LINE :MAKE-ARRAY (:AREA *LINE-AREA* :TYPE 'ART-STRING)
			     LINE-TICK *TICK* LINE-LENGTH 0)))
	(SETF (LINE-DIAGRAM LINE) STRING)
	(SETQ STRING LINE)))
    (SETQ STRING (SI:MERGE-STRING-CHARACTER-STYLE CURRENT-CHARACTER-STYLE STRING START END))
    (COND ((AND (ZEROP INDEX)
		(EQL (ARRAY-LEADER-LENGTH STRING) LINE-LEADER-SIZE)
		(NULL (LINE-NODE STRING))	;avoid sharing lines between buffers!
		)
	   (MUNG-BP-INTERVAL (CREATE-BP LINE INDEX))
	   (INSERT-LINE-WITH-LEADER STRING LINE))	;Optimize case for file readin
	  ((ZEROP INDEX)			;Optimize case where it's not already a line
	   (LET ((NEW-LINE (CREATE-LINE (IF (STRING-FAT-P STRING) 'ART-FAT-STRING 'ART-STRING)
					(ARRAY-ACTIVE-LENGTH STRING)
					OUTPUT-LINE-NODE)))
	     (COPY-ARRAY-CONTENTS STRING NEW-LINE)
	     (MUNG-BP-INTERVAL (CREATE-BP LINE INDEX))
	     (INSERT-LINE-WITH-LEADER NEW-LINE LINE)))
	  (T
	   (LET ((BP (INSERT (INSERT (CREATE-BP LINE INDEX) STRING)
			     #\CR)))
	     (SETQ LINE (BP-LINE BP) INDEX (BP-INDEX BP))))))
  STRING)

(DEFMETHOD (:STRING-OUT INTERVAL-STREAM) (STRING &OPTIONAL (START 0) END)
  (LET* ((*INTERVAL* OUTPUT-LINE-NODE)
	 (*ENABLE-CHANGE-RECORDING* NIL)
	 (BP (INSERT (CREATE-BP LINE INDEX)
		     (SI:MERGE-STRING-CHARACTER-STYLE CURRENT-CHARACTER-STYLE
						      STRING START END))))
    (SETQ LINE (BP-LINE BP) INDEX (BP-INDEX BP))))

;;; Used when reader has read the ( and is accumulating the list, record the start of it.
(DEFMETHOD (:READ-BP-BEFORE INTERVAL-STREAM) ()
  (DBP (SEND SELF ':READ-BP)))

;; A temporary BP
;; But BUFFER-MATTERS true => include the buffer in it (doesn't work if already passed end)
(DEFMETHOD (:READ-BP INTERVAL-STREAM) (&OPTIONAL BUFFER-MATTERS)
  (COND ((NULL INDEX) (COPY-BP (INTERVAL-LAST-BP INTERVAL)))
	((AND BUFFER BUFFER-MATTERS) ; buffer may be nil, in which case it cannot matter.
	 (MAKE-BP BP-LINE LINE BP-INDEX INDEX
		  BP-STATUS NIL BP-BUFFER-INTERNAL BUFFER))
	(T (CREATE-BP LINE INDEX))))

(DEFMETHOD (:UNTYO-MARK INTERVAL-STREAM) ()
  (IF (NULL INDEX) (INTERVAL-LAST-BP INTERVAL)
      (CREATE-BP LINE INDEX)))

(DEFMETHOD (:UNTYO INTERVAL-STREAM) (MARK)
  (DELETE-INTERVAL MARK (CREATE-BP LINE INDEX) T)
  (SETQ LINE (BP-LINE MARK) INDEX (BP-INDEX MARK)))

;;; --- this needs to change INTERVAL, no?
(DEFMETHOD (:SET-BP INTERVAL-STREAM) (BP)
  (SETQ OUTPUT-LINE-NODE (BP-NODE BP))
  (SETQ LINE (BP-LINE BP) INDEX (BP-INDEX BP))
  (LET ((LAST-BP (INTERVAL-LAST-BP INTERVAL)))	;Take account of inserted changes
    (SETQ LAST-LINE (BP-LINE LAST-BP)
	  LAST-INDEX (BP-INDEX LAST-BP)))
  (SETQ STOP-INDEX (IF (EQ LINE LAST-LINE)
		       LAST-INDEX
		       (LINE-LENGTH LINE))))

(DEFMETHOD (:SET-INTERVAL INTERVAL-STREAM) (START-BP &OPTIONAL END-BP IN-ORDER-P)
  "Don't use this for output unless the BP's are the same."
  (GET-INTERVAL START-BP END-BP IN-ORDER-P)
  (SETF (INTERVAL-FIRST-BP INTERVAL) START-BP)
  (SETF (INTERVAL-LAST-BP INTERVAL) END-BP)
  (SEND SELF ':SET-BP START-BP))

(DEFMETHOD (:DELETE-TEXT INTERVAL-STREAM) ()
  (DELETE-INTERVAL INTERVAL))

(DEFMETHOD (:FRESH-LINE INTERVAL-STREAM) ()
  (UNLESS (ZEROP INDEX)
    (SEND SELF ':TYO #\CR)
    T))

(DEFMETHOD (:READ-LOCATION INTERVAL-STREAM) ()
  (SEND SELF :READ-BP))

(DEFMETHOD (:READ-LOCATION-BEFORE INTERVAL-STREAM) ()
  (SEND SELF :READ-BP-BEFORE))

(DEFMETHOD (:SET-LOCATION INTERVAL-STREAM) (LOCATION)
  (SEND SELF :SET-BP LOCATION))

(DEFMETHOD (:REPLACE-INPUT-SINCE INTERVAL-STREAM) (LOCATION STRING &OPTIONAL (START 0) END
									     IGNORE)
  (LET ((*INTERVAL* OUTPUT-LINE-NODE)
	(*ENABLE-CHANGE-RECORDING* NIL))
    (WITH-BP (BP (SEND SELF :READ-BP) :MOVES)
      (DELETE-INTERVAL LOCATION BP T)
      (INSERT BP STRING START END)
      (SETQ LINE (BP-LINE BP) INDEX (BP-INDEX BP)))
    (LET ((BP (INTERVAL-LAST-BP INTERVAL)))
      (SETQ LAST-LINE (BP-LINE BP)
	    LAST-INDEX (BP-INDEX BP)))
    (SETQ STOP-INDEX (IF (EQ LINE LAST-LINE)
			 LAST-INDEX
			 (LINE-LENGTH LINE)))))

(DEFMETHOD (:SET-POINTER INTERVAL-STREAM) (POINTER)
  (OR (ZEROP POINTER) (FERROR NIL "Attempt to set pointer other than to beginning."))
  (LET ((BP (INTERVAL-FIRST-BP INTERVAL)))
    (SETQ LINE (BP-LINE BP)
	  INDEX (BP-INDEX BP))
    (SETQ STOP-INDEX (IF (EQ LINE LAST-LINE)
			 LAST-INDEX
			 (LINE-LENGTH LINE)))))

(DEFMETHOD (SI:CURSORPOS-UNIT-SUPPORTED-P INTERVAL-STREAM) (UNIT)
  (EQ UNIT ':CHARACTER))

(DEFMETHOD (:READ-CURSORPOS INTERVAL-STREAM) (&OPTIONAL (UNIT ':CHARACTER))
  (OR (EQ UNIT ':CHARACTER) (FERROR NIL "~S unknown cursor-position unit" UNIT))
  (DO ((I 0 (1+ I))
       (X 0))
      (( I INDEX) (RETURN (VALUES X 0)))	;Y position always zero
    (SELECTOR (AREF LINE I) CHAR-EQUAL
      (#\BS (SETQ X (MAX (1- X) 0)))
      (#\TAB (SETQ X (* (1+ (// X 8)) 8)))
      (OTHERWISE (SETQ X (1+ X))))))

;; This is a bit fraudulent, for FORMAT ~T.  Ignores Y.
;; Can't use the regular indent stuff since we don't have a window.
(DEFMETHOD (:SET-CURSORPOS INTERVAL-STREAM) (X IGNORE &OPTIONAL (UNIT ':CHARACTER))
  (OR (EQ UNIT ':CHARACTER) (FERROR NIL "~S unknown cursor-position unit" UNIT))
  (DO ((FROM (SEND SELF ':READ-CURSORPOS ':CHARACTER) (1+ FROM))
       (TO X))
      (( FROM TO))
    (SEND SELF ':TYO #\SP)))

(DEFMETHOD (:INCREMENT-CURSORPOS INTERVAL-STREAM) (N &REST IGNORE)
  (LET ((BP (CREATE-BP LINE INDEX))
	(*ENABLE-CHANGE-RECORDING* NIL))
    (DOTIMES (IGNORE N) (INSERT-MOVING BP #\SP))
    (SETQ LINE (BP-LINE BP) INDEX (BP-INDEX BP))))

;To give DW::FORMAT-OUTPUT-MACRO-CONVERT-POSITION a chance of working
(DEFMETHOD (:CHAR-WIDTH INTERVAL-STREAM) () 1)

;To give DW::FORMAT-OUTPUT-MACRO-CONVERT-POSITION a chance of working
(DEFMETHOD (:LINE-HEIGHT INTERVAL-STREAM) () 1)

(DEFMETHOD (:CLEAR-WINDOW INTERVAL-STREAM) (&REST IGNORE) NIL)

;;These are for the compiler (also FILE-READ-PROPERTY-LIST)
(DEFMETHOD (:PATHNAME INTERVAL-STREAM) ()
  (FUNCALL (BP-TOP-LEVEL-NODE (IF INDEX
				  (CREATE-BP LINE INDEX)
				  (CREATE-BP LAST-LINE LAST-INDEX)))
	   ':SEND-IF-HANDLES ':PATHNAME))

;; This is a separate message so that simulated BP of *LINE*,*INDEX* will be kept up to date
(DEFMETHOD (:DELETE-INTERVAL INTERVAL-STREAM) (START-BP &OPTIONAL END-BP IN-ORDER-P)
  (LET ((*ENABLE-CHANGE-RECORDING* NIL))
    (WITH-BP (BP (CREATE-BP LINE INDEX) ':NORMAL)
      (DELETE-INTERVAL START-BP END-BP IN-ORDER-P)
      (SETQ LINE (BP-LINE BP)
	    INDEX (BP-INDEX BP)))))

(DEFMETHOD (:INSERT-AT-BP INTERVAL-STREAM) (BP STRING)
  (LET ((POINT (SEND SELF :READ-BP)))
    (WITH-BP (SAVE-POINT POINT :MOVES)
      (INSERT BP STRING)
      (UNLESS (BP-= POINT SAVE-POINT)
	(SEND SELF :SET-LOCATION SAVE-POINT))))
  (LET ((BP (INTERVAL-LAST-BP INTERVAL)))
    (SETQ LAST-LINE (BP-LINE BP)
	  LAST-INDEX (BP-INDEX BP)))
  (SETQ STOP-INDEX (IF (EQ LINE LAST-LINE)
		       LAST-INDEX
		       (LINE-LENGTH LINE))))

(DEFMETHOD (:CASE-REPLACE-SINCE INTERVAL-STREAM)
	   (STRING START-LOCATION &OPTIONAL END-LOCATION)
  (LET ((POINT (SEND SELF :READ-BP)))
    (WITH-BP (SAVE-POINT POINT :MOVES)
      (CASE-REPLACE START-LOCATION (OR END-LOCATION POINT) STRING)
      (UNLESS (BP-= POINT SAVE-POINT)
	(SEND SELF :SET-LOCATION SAVE-POINT))))
  (LET ((BP (INTERVAL-LAST-BP INTERVAL)))
    (SETQ LAST-LINE (BP-LINE BP)
	  LAST-INDEX (BP-INDEX BP)))
  (SETQ STOP-INDEX (IF (EQ LINE LAST-LINE)
		       LAST-INDEX
		       (LINE-LENGTH LINE))))

(DEFMETHOD (:TEXT-DELETED INTERVAL-STREAM) () NIL)

;; These are for the compiler warnings stuff.
(DEFMETHOD (:WHOLE-FILE-P INTERVAL-STREAM) ()
  (LET ((INT (BP-TOP-LEVEL-NODE (CREATE-BP LINE INDEX))))
    (AND (SEND INT ':SEND-IF-HANDLES ':PATHNAME)	;Must be both a "file" and "whole".
	 (BP-= (INTERVAL-FIRST-BP INTERVAL) (INTERVAL-FIRST-BP INT))
	 (BP-= (INTERVAL-LAST-BP INTERVAL) (INTERVAL-LAST-BP INT)))))

(DEFMETHOD (:BEGIN-NODE INTERVAL-STREAM) (&OPTIONAL JOKE-TYPE JOKE-ARG
						    NODE-TYPE
						    &REST TYPE-ARGS
						    &KEY
						    &ALLOW-OTHER-KEYS)
  (DECLARE (ARGLIST JOKE-TYPE-NIL-RECOMMENDED JOKE-ARG-NIL-RECOMMENDED
		    NODE-TYPE &REST INIT-ARGS-FOR-NODE))
  (LET* ((SUPERIOR (IF NODE-LEVEL (CAR NODE-LEVEL)
		       (BP-TOP-LEVEL-NODE (CREATE-BP LINE INDEX))))
	 (NODE (IF JOKE-TYPE
		   (MAKE-INSTANCE (CAR JOKE-TYPE) (CADR JOKE-TYPE) JOKE-ARG
				  :SUPERIOR SUPERIOR
				  :FIRST-BP (CREATE-BP LINE INDEX ':NORMAL)
				  :LAST-BP (CREATE-BP LINE INDEX ':MOVES))
		   (CL:APPLY #'MAKE-INSTANCE NODE-TYPE
			     :SUPERIOR SUPERIOR
			     :FIRST-BP (CREATE-BP LINE INDEX ':NORMAL)
			     :LAST-BP (CREATE-BP LINE INDEX ':MOVES)
			     TYPE-ARGS))))
    (SETF (LINE-NODE LINE) NODE)
    (PUSH NODE NODE-LEVEL)))

(DEFMETHOD (:END-NODE INTERVAL-STREAM) (&OPTIONAL IGNORE IGNORE)
  (OR NODE-LEVEL (FERROR NIL "Attempt to :END-NODE without doing :BEGIN-NODE first."))
  (LET* ((NODE (POP NODE-LEVEL))
	 (SUPERIOR (IF NODE-LEVEL (CAR NODE-LEVEL)
		       (BP-TOP-LEVEL-NODE (CREATE-BP LINE INDEX))))
	 (INFS (NODE-INFERIORS SUPERIOR))
	 (PREV (CAR (LAST INFS))))
    (SETF (NODE-PREVIOUS NODE) PREV)
    (COND (PREV
	   (SETF (NODE-NEXT PREV) NODE)
	   (MOVE-BP (INTERVAL-LAST-BP PREV) (INTERVAL-FIRST-BP NODE))))
    (SETF (NODE-INFERIORS SUPERIOR) (NCONC INFS (NCONS NODE)))
    (SETF (LINE-NODE LINE) SUPERIOR)))
 
;; Cause redisplay to happen if the interval is displayed in an active window.
(DEFMETHOD (:FORCE-REDISPLAY INTERVAL-STREAM) ()
  (DOLIST (COMMAND-LOOP *ZMACS-COMMAND-LOOPS*)
    (TV:IO-BUFFER-PUT (SEND COMMAND-LOOP :IO-BUFFER)
		      `(MUST-REDISPLAY-INTERVAL ,(BP-TOP-LEVEL-NODE (SEND SELF :READ-BP))
						,DIS-TEXT))))

(DEFMETHOD (:ITEM INTERVAL-STREAM) (IGNORE THING &OPTIONAL FORMAT &REST FORMAT-ARGS)
  (IF FORMAT
      (LEXPR-FUNCALL #'FORMAT SELF FORMAT FORMAT-ARGS)
      (PRINC THING SELF)))


1;;; Interval streams which obey the buffered input protocol.

0(DEFCONST *INTERVAL-STREAM-RETURN-BUFFER* (CL:MAKE-STRING 1 :INITIAL-ELEMENT #\Return))

(DEFCONST *INTERVAL-STREAM-DIAGRAM-BUFFER* "<Diagram Line>")

(DEFFLAVOR BUFFERED-INTERVAL-STREAM
	((GIVE-OUT-RETURN-BUFFER NIL)
	 (JUST-GAVE-OUT-DIAGRAM NIL))
	(SI:BUFFERED-INPUT-CHARACTER-STREAM INTERVAL-STREAM))

(DEFMETHOD (:NEXT-INPUT-BUFFER BUFFERED-INTERVAL-STREAM) (&OPTIONAL NO-HANG-P)
  (DECLARE (IGNORE NO-HANG-P)
	   (VALUES BUFFER START END EOF-P))
  (SETF JUST-GAVE-OUT-DIAGRAM NIL)
  (COND (GIVE-OUT-RETURN-BUFFER
	 (VALUES *INTERVAL-STREAM-RETURN-BUFFER* 0 1 NIL))
	((NULL INDEX)
	 (VALUES NIL NIL NIL T))
	((NULL (LINE-DIAGRAM LINE))
	 (VALUES LINE INDEX STOP-INDEX NIL))
	(RETURN-DIAGRAMS-AS-LINES
	 (SETF JUST-GAVE-OUT-DIAGRAM T)
	 (VALUES (LINE-DIAGRAM LINE) 0 0 NIL))
	(T
	 (VALUES *INTERVAL-STREAM-DIAGRAM-BUFFER*
		 0 (STRING-LENGTH *INTERVAL-STREAM-DIAGRAM-BUFFER*) NIL))))

(DEFMETHOD (:DISCARD-INPUT-BUFFER BUFFERED-INTERVAL-STREAM) (BUFFER)
  (DECLARE (IGNORE BUFFER))
  (COND (GIVE-OUT-RETURN-BUFFER
	 (NEXT-LINE)
	 (SETF GIVE-OUT-RETURN-BUFFER NIL))
	(T
	 (SETF GIVE-OUT-RETURN-BUFFER T))))

(DEFWHOPPER (:TYI BUFFERED-INTERVAL-STREAM) (&OPTIONAL EOF)
  (WHEN (NULL SI:STREAM-INPUT-BUFFER)
    1;; Be sure that we're properly initialized.
0    (MULTIPLE-VALUE (SI:STREAM-INPUT-BUFFER SI:STREAM-INPUT-INDEX SI:STREAM-INPUT-LIMIT)
      (SEND SELF :NEXT-INPUT-BUFFER NIL)))
  (IF (AND (INSTANCEP SI:STREAM-INPUT-BUFFER) JUST-GAVE-OUT-DIAGRAM)
      (PROG1 SI:STREAM-INPUT-BUFFER
	     (SETF JUST-GAVE-OUT-DIAGRAM NIL))
      (CONTINUE-WHOPPER EOF)))

(DEFWHOPPER (:TYI-NO-HANG BUFFERED-INTERVAL-STREAM) (&OPTIONAL EOF)
  (WHEN (NULL SI:STREAM-INPUT-BUFFER)
    1;; Be sure that we're properly initialized.
0    (MULTIPLE-VALUE (SI:STREAM-INPUT-BUFFER SI:STREAM-INPUT-INDEX SI:STREAM-INPUT-LIMIT)
      (SEND SELF :NEXT-INPUT-BUFFER NIL)))
  (IF (AND (INSTANCEP SI:STREAM-INPUT-BUFFER) JUST-GAVE-OUT-DIAGRAM)
      (PROG1 SI:STREAM-INPUT-BUFFER
	     (SETF JUST-GAVE-OUT-DIAGRAM NIL))
      (CONTINUE-WHOPPER EOF)))

(DEFWHOPPER (:TYIPEEK BUFFERED-INTERVAL-STREAM) (&OPTIONAL EOF)
  (WHEN (NULL SI:STREAM-INPUT-BUFFER)
    1;; Be sure that we're properly initialized.
0    (MULTIPLE-VALUE (SI:STREAM-INPUT-BUFFER SI:STREAM-INPUT-INDEX SI:STREAM-INPUT-LIMIT)
      (SEND SELF :NEXT-INPUT-BUFFER NIL)))
  (IF (AND (INSTANCEP SI:STREAM-INPUT-BUFFER) JUST-GAVE-OUT-DIAGRAM)
      SI:STREAM-INPUT-BUFFER
      (CONTINUE-WHOPPER EOF)))

(DEFWHOPPER (:UNTYI BUFFERED-INTERVAL-STREAM) (CH)
  (IF (INSTANCEP SI:STREAM-INPUT-BUFFER)
      (IF JUST-GAVE-OUT-DIAGRAM
	  (FERROR "Attempt to :UNTYI something different than last :TYI'ed.")
	  (SETF JUST-GAVE-OUT-DIAGRAM T))
      (CONTINUE-WHOPPER CH)))

(DEFWHOPPER (:LINE-IN BUFFERED-INTERVAL-STREAM) (&OPTIONAL LEADER-SIZE)
  (WHEN (NULL SI:STREAM-INPUT-BUFFER)
    1;; Be sure that we're properly initialized.
0    (MULTIPLE-VALUE (SI:STREAM-INPUT-BUFFER SI:STREAM-INPUT-INDEX SI:STREAM-INPUT-LIMIT)
      (SEND SELF :NEXT-INPUT-BUFFER NIL)))
  (IF (AND SI:STREAM-INPUT-BUFFER
1	   ;; Caller wants the actual line whenever possible ...
0	   (NULL LEADER-SIZE)
	   (OR 1;; ... and we are about to hand him a diagram ...
0	       (AND (INSTANCEP SI:STREAM-INPUT-BUFFER) JUST-GAVE-OUT-DIAGRAM)
1	       ;; ... or we are about to hand him a complete line or a null string --
	       ;;        The check for handing back a null string when the interval is
	       ;;        exhausted allows us to return a constant null string to avoid
	       ;;        needless 2cons1ing during Zmail message saving.
0	       (AND (ARRAY-HAS-LEADER-P SI:STREAM-INPUT-BUFFER)
		    (EQL SI:STREAM-INPUT-INDEX 0)
		    (OR (= SI:STREAM-INPUT-LIMIT (LINE-LENGTH SI:STREAM-INPUT-BUFFER))
			(AND (EQ SI:STREAM-INPUT-BUFFER LAST-LINE) (ZEROP STOP-INDEX))))))
      (LET ((VALUE (COND ((INSTANCEP SI:STREAM-INPUT-BUFFER)
			  (SETF JUST-GAVE-OUT-DIAGRAM NIL)
			  SI:STREAM-INPUT-BUFFER)
			 ((= SI:STREAM-INPUT-LIMIT (LINE-LENGTH SI:STREAM-INPUT-BUFFER))
			  SI:STREAM-INPUT-BUFFER)
			 (T
			  *INTERVAL-STREAM-LINE-IN-NULL-LINE*)))
	    AT-EOF)
	1;; Move on to the 2*interval-stream-return-buffer*1 ...
	;;    (We can't use 2:setup-next-input-buffer1 because it will ignore diagram lines.)
0	(SEND SELF :DISCARD-INPUT-BUFFER NIL)
	1;; ... and then move on to the next line (if any).
0	(SEND SELF :DISCARD-INPUT-BUFFER NIL)
	(MULTIPLE-VALUE (SI:STREAM-INPUT-BUFFER SI:STREAM-INPUT-INDEX SI:STREAM-INPUT-LIMIT
			 AT-EOF)
	  (SEND SELF :NEXT-INPUT-BUFFER NIL))
	1;; Return the current line.
0	(VALUES VALUE AT-EOF))
1      ;; Caller always wants a copy or we've decided that we have to make a copy.
0      (CONTINUE-WHOPPER LEADER-SIZE)))

(DEFWHOPPER (:STRING-LINE-IN BUFFERED-INTERVAL-STREAM) (EOF BUFFER &OPTIONAL (START 0) END)
  (WHEN (NULL SI:STREAM-INPUT-BUFFER)
    1;; Be sure that we're properly initialized.
0    (MULTIPLE-VALUE (SI:STREAM-INPUT-BUFFER SI:STREAM-INPUT-INDEX SI:STREAM-INPUT-LIMIT)
      (SEND SELF :NEXT-INPUT-BUFFER NIL)))
  (IF (AND (INSTANCEP SI:STREAM-INPUT-BUFFER) JUST-GAVE-OUT-DIAGRAM)
      1;; Return the diagram as the fourth value ...
0      (LET ((DIAGRAM SI:STREAM-INPUT-BUFFER)
	    AT-EOF)
	(SETF JUST-GAVE-OUT-DIAGRAM NIL)
	1;; Move on to the 2*interval-stream-return-buffer*1 ...
	;;    (We can't use 2:setup-next-input-buffer1 because it will ignore diagram lines.)
0	(SEND SELF :DISCARD-INPUT-BUFFER NIL)
	1;; ... and then move on to the next line (if any).
0	(SEND SELF :DISCARD-INPUT-BUFFER NIL)
	(MULTIPLE-VALUE (SI:STREAM-INPUT-BUFFER SI:STREAM-INPUT-INDEX SI:STREAM-INPUT-LIMIT
			 AT-EOF)
	  (SEND SELF :NEXT-INPUT-BUFFER NIL))
	(VALUES 0 AT-EOF NIL DIAGRAM))
      (MULTIPLE-VALUE-BIND (AMOUNT AT-EOF MORE-ON-LINE)
	  (CONTINUE-WHOPPER EOF BUFFER START END)
	1;; Need to advance past the 2*interval-stream-return-buffer*1 to keep in sync.
0	(WHEN (EQ SI:STREAM-INPUT-BUFFER *INTERVAL-STREAM-RETURN-BUFFER*)
	  (SEND SELF :DISCARD-INPUT-BUFFER NIL)
	  (MULTIPLE-VALUE (SI:STREAM-INPUT-BUFFER SI:STREAM-INPUT-INDEX SI:STREAM-INPUT-LIMIT
			   AT-EOF)
	    (SEND SELF :NEXT-INPUT-BUFFER NIL)))
	(VALUES AMOUNT AT-EOF MORE-ON-LINE))))


;;; Return a stream which inputs from the terminal and outputs to the buffer
(DEFUN MAKE-INTERVAL-TYPEOUT-STREAM ()
  (LET-CLOSED ((*INTERVAL-STREAM* (OPEN-INTERVAL-STREAM
				    (POINT) (POINT) T
				    :FLAVOR 'PRESENTATION-RECORDING-INTERVAL-STREAM))
	       (*TYPEOUT-WINDOW* *TYPEOUT-WINDOW*))
    'INTERVAL-TYPEOUT-STREAM-IO))

(LOCAL-DECLARE ((SPECIAL *INTERVAL-STREAM* *TYPEOUT-WINDOW*))	;duplicated in next definition
(DEFUN INTERVAL-TYPEOUT-STREAM-IO (OP &REST ARGS)
  (SELECTQ OP
    ((#||:ITEM :ITEM-LIST||#
      :READ-CURSORPOS :SET-CURSORPOS :REAL-SET-CURSORPOS)
     (LEXPR-FUNCALL #'INTERVAL-TYPEOUT-STREAM-ITEM-IO OP ARGS))
    ((:TYO :LINE-OUT :STRING-OUT :UNTYO-MARK :READ-BP :UNTYO :SET-BP
      :OUTPUT-AS-PRESENTATION :OUTPUT-AS-PRESENTATION-1
      :DELETE-TEXT :FRESH-LINE :SET-POINTER :WITH-CHARACTER-STYLE
      :CLEAR-SCREEN :INCREMENT-CURSORPOS :PRINT :GPRINT)
     (LEXPR-SEND *INTERVAL-STREAM* OP ARGS))
    (:SEND-IF-HANDLES
     (WHEN (INTERVAL-TYPEOUT-STREAM-IO :OPERATION-HANDLED-P (FIRST ARGS))
       (LEXPR-FUNCALL #'INTERVAL-TYPEOUT-STREAM-IO ARGS)))
    (OTHERWISE (LEXPR-SEND *TYPEOUT-WINDOW* OP ARGS))))
)  ;End of LOCAL-DECLARE

(LOCAL-DECLARE ((SPECIAL *INTERVAL-STREAM* *TYPEOUT-WINDOW*))	;more of the same
(DEFSELECT INTERVAL-TYPEOUT-STREAM-ITEM-IO
  (:READ-CURSORPOS (&OPTIONAL (UNITS ':PIXEL))
   (LET ((CHAR-POS (FUNCALL *INTERVAL-STREAM* ':READ-CURSORPOS ':CHARACTER)))
     (VALUES (IF (EQ UNITS ':CHARACTER)
		 CHAR-POS
		 (* (TV:SHEET-CHAR-WIDTH (WINDOW-SHEET *WINDOW*)) CHAR-POS))
	     ;; See comment in the interval stream
	     0)))
  (:SET-CURSORPOS (X Y &OPTIONAL (UNITS ':PIXEL))
   (LET ((CHAR-WID (TV:SHEET-CHAR-WIDTH (WINDOW-SHEET *WINDOW*))))
     (AND (EQ UNITS ':PIXEL) (SETQ X (// (+ X (1- CHAR-WID)) CHAR-WID)))
     (FUNCALL *INTERVAL-STREAM* ':SET-CURSORPOS X Y ':CHARACTER)))
  (:REAL-SET-CURSORPOS () NIL)			;'Fraid not.
  #||
  (:ITEM (IGNORE ITEM &REST FORMAT-ARGS)
    (IF FORMAT-ARGS
	(LEXPR-FUNCALL #'FORMAT 'INTERVAL-TYPEOUT-STREAM-IO FORMAT-ARGS)
	(PRINC ITEM 'INTERVAL-TYPEOUT-STREAM-IO)))
  (:ITEM-LIST (TYPE LIST &AUX (MAXL 0) N (SHEET (WINDOW-SHEET *WINDOW*)))
    (INTERVAL-TYPEOUT-STREAM-IO ':FRESH-LINE)
    (COND (LIST					;Do nothing if empty list
	   ;; Compute the maximum width of any item, in dots (MAXL).
	   (DOLIST (ITEM LIST)
	     (LET ((STRING (STRING (IF (LISTP ITEM) (CAR ITEM) ITEM))))
	       (SETQ MAXL (MAX (FUNCALL SHEET ':STRING-LENGTH STRING) MAXL))))
	   ;; How many items go on each line (except the last)?
	   (SETQ N (MAX (MIN (// *FILL-COLUMN*
				 (+ MAXL (FONT-CHAR-WIDTH (TV:SHEET-CURRENT-FONT SHEET))))
			     (LENGTH LIST))
			1))
	   ;; Now print the items and store the data in the table.
	   ;; Move to a new line when we exhaust a line, and at the end.
	   ;; I counts from 1 thru N on each line.
	   (DO ((I 1 (1+ I))
		(LIST LIST (CDR LIST))
		(WIDTH-PER (// *FILL-COLUMN* N)))
	       ((NULL LIST))
	     ;; Actually make this item.
	     (IF (LISTP (CAR LIST))
		 (INTERVAL-TYPEOUT-STREAM-ITEM-IO ':ITEM TYPE (CDAR LIST) "~A" (CAAR LIST))
		 (INTERVAL-TYPEOUT-STREAM-ITEM-IO ':ITEM TYPE (CAR LIST)))
	     ;; Space out for next item, or move to new line.
	     (IF (AND ( I N) (CDR LIST))
		 ;; Not end of line, space out for next item.
		 (MULTIPLE-VALUE-BIND (X Y)
		     (INTERVAL-TYPEOUT-STREAM-IO ':READ-CURSORPOS)
		   (INTERVAL-TYPEOUT-STREAM-IO ':SET-CURSORPOS
					       (* WIDTH-PER
						  (// (+ (1- WIDTH-PER) X)
						      WIDTH-PER))
					Y))
		 ;; End of line.
		 (INTERVAL-TYPEOUT-STREAM-IO ':TYO #\CR)
		 (SETQ I 0))))))
  ||#)
)  ;End of LOCAL-DECLARE

(DEFUN GRIND-INTO-BP (BP SEXP)
  (LET ((LISP:*PRINT-ESCAPE* T)
	(LISP:*READTABLE* (SI:READTABLE-FOR-SYNTAX (SEND *INTERVAL* :GET :SYNTAX))))
    (CL:PPRINT SEXP (OPEN-INTERVAL-STREAM BP BP T))))


;;; Is the text immediately following BP the same as the contents of STRING?
;;; If string contains newlines, this doesn't work.
(DEFUN LOOKING-AT (BP STRING)
  (LET ((CP (BP-INDEX BP))
	(SLEN (STRING-LENGTH STRING)))
    (STRING-EQUAL (BP-LINE BP) STRING CP 0 (+ CP SLEN))))

;;; Is the text immediately before BP the same as the contents of STRING?
;;; If string contains newlines, this doesn't work.
(DEFUN LOOKING-AT-BACKWARD (BP STRING)
  (LET ((CP (BP-INDEX BP))
	(SLEN (STRING-LENGTH STRING)))
    (AND ( CP SLEN)
	 (STRING-EQUAL (BP-LINE BP) STRING (- CP SLEN) 0 CP))))

(DEFUN BP-LOOKING-AT-LIST (BP LIST)
  (DO ((LIST LIST (CDR LIST))
       (BP-CH (BP-CHAR BP))
       (CH))
      ((NULL LIST) NIL)
    (AND (IF (CHARACTERP (SETQ CH (CAR LIST)))
	     (CHAR-EQUAL BP-CH CH)
	     (LET ((LEN (STRING-LENGTH CH))
		   (INDEX (BP-INDEX BP)))
	       (STRING-EQUAL (BP-LINE BP) CH INDEX 0 (+ INDEX LEN) LEN)))
	 (RETURN CH))))

;;; Interval sorting
(DEFUN SORT-LINES-INTERVAL (LESSP-FN FROM-BP &OPTIONAL TO-BP IN-ORDER-P)
  "Given a lessp predicate and an interval, sort the lines in that interval.
The argument BP's are assumed to point at the beginning of their lines.
BP's to the ends of the interval remain at the ends of the interval, BP's
inside the interval move with their lines."
  (DECLARE (SYS:DOWNWARD-FUNARG LESSP-FN))
  (ASSURE-SINGLE-SECTION-INTERVAL
    FROM-BP TO-BP IN-ORDER-P "You cannot sort across section boundaries.")
  (MUNG-BP-INTERVAL FROM-BP)
  (WITH-UNDO-SAVE ("sort" FROM-BP TO-BP T)
    (LET ((PRECEDING-LINE (LINE-PREVIOUS (BP-LINE FROM-BP)))
	  (FOLLOWING-LINE (BP-LINE TO-BP))
	  (PRECEDING-BPS (DO ((L (LINE-BP-LIST (BP-LINE FROM-BP)) (CDR L))
			      (R NIL))
			     ((NULL L) R)
			   (AND (ZEROP (BP-INDEX (CAR L)))
				(EQ (BP-STATUS (CAR L)) ':NORMAL)
				(PUSH (CAR L) R))))
	  (N-LINES (1- (COUNT-LINES FROM-BP TO-BP T)))
	  LINE-ARRAY FIRST-LINE)
      (SETQ LINE-ARRAY (MAKE-ARRAY N-LINES))
      (DO ((I 0 (1+ I))
	   (L (BP-LINE FROM-BP) (LINE-NEXT L)))
	  ((OR (EQ L FOLLOWING-LINE) (NULL L))
	   (SETQ FOLLOWING-LINE L))
	(ASET L LINE-ARRAY I))
      (SORT LINE-ARRAY LESSP-FN)
      (DO ((PREC PRECEDING-LINE LINE)
	   (I 0 (1+ I))
	   (LINE))
	  ((= I N-LINES)
	   (COND ((NOT (NULL LINE))
		  (SETF (LINE-NEXT LINE) FOLLOWING-LINE)
		  (WHEN FOLLOWING-LINE
		    (SETF (LINE-PREVIOUS FOLLOWING-LINE) LINE)))))
	(SETQ LINE (AREF LINE-ARRAY I))
	(AND PREC (SETF (LINE-NEXT PREC) LINE))
	(SETF (LINE-PREVIOUS LINE) PREC))
      (SETQ FIRST-LINE (AND (PLUSP N-LINES) (AREF LINE-ARRAY 0)))
      (RETURN-ARRAY (PROG1 LINE-ARRAY (SETQ LINE-ARRAY NIL)))
      (DOLIST (BP PRECEDING-BPS)
	(MOVE-BP BP FIRST-LINE 0)))))

(DEFUN SORT-INTERVAL-ARRAY (ARRAY LESSP-FN FROM-BP &OPTIONAL TO-BP IN-ORDER-P)
  (ASSURE-SINGLE-SECTION-INTERVAL
    FROM-BP TO-BP IN-ORDER-P "You cannot sort across section boundaries.")
  (SORT ARRAY LESSP-FN)
  (LET ((NEW-INTERVAL (CREATE-INTERVAL)))
    (DO ((END-BP (INTERVAL-LAST-BP NEW-INTERVAL))
	 (I 0 (1+ I))
	 (LEN (ARRAY-ACTIVE-LENGTH ARRAY)))
	(( I LEN))
      (INSERT-INTERVAL END-BP (AREF ARRAY I)))
    (WITH-UNDO-SAVE ("sort" FROM-BP TO-BP T)
      (DELETE-INTERVAL FROM-BP TO-BP T)
      (INSERT-INTERVAL FROM-BP NEW-INTERVAL))))

(DEFUN INTERVAL-LESSP (INTERVAL-1-FROM-BP INTERVAL-1-TO-BP INTERVAL-1-IN-ORDER-P
		       INTERVAL-2-FROM-BP INTERVAL-2-TO-BP INTERVAL-2-IN-ORDER-P
		       &OPTIONAL CASE-MATTERS)
  (MINUSP (INTERVAL-COMPARE INTERVAL-1-FROM-BP INTERVAL-1-TO-BP INTERVAL-1-IN-ORDER-P
			    INTERVAL-2-FROM-BP INTERVAL-2-TO-BP INTERVAL-2-IN-ORDER-P
			    CASE-MATTERS)))

(DEFUN INTERVAL-EQUAL (INTERVAL-1-FROM-BP INTERVAL-1-TO-BP INTERVAL-1-IN-ORDER-P
		       INTERVAL-2-FROM-BP INTERVAL-2-TO-BP INTERVAL-2-IN-ORDER-P
		       &OPTIONAL CASE-MATTERS)
  (ZEROP (INTERVAL-COMPARE INTERVAL-1-FROM-BP INTERVAL-1-TO-BP INTERVAL-1-IN-ORDER-P
			   INTERVAL-2-FROM-BP INTERVAL-2-TO-BP INTERVAL-2-IN-ORDER-P
			   CASE-MATTERS)))

(DEFUN INTERVAL-COMPARE (INTERVAL-1-FROM-BP INTERVAL-1-TO-BP INTERVAL-1-IN-ORDER-P
			 INTERVAL-2-FROM-BP INTERVAL-2-TO-BP INTERVAL-2-IN-ORDER-P
			 &OPTIONAL CASE-MATTERS)
  (GET-INTERVAL INTERVAL-1-FROM-BP INTERVAL-1-TO-BP INTERVAL-1-IN-ORDER-P)
  (GET-INTERVAL INTERVAL-2-FROM-BP INTERVAL-2-TO-BP INTERVAL-2-IN-ORDER-P)
  (LET* ((LINE-1 (BP-LINE INTERVAL-1-FROM-BP))
	 (LINE-2 (BP-LINE INTERVAL-2-FROM-BP))
	 (INDEX-1 (BP-INDEX INTERVAL-1-FROM-BP))
	 (INDEX-2 (BP-INDEX INTERVAL-2-FROM-BP))
	 (END-LINE-1 (BP-LINE INTERVAL-1-TO-BP))
	 (END-LINE-2 (BP-LINE INTERVAL-2-TO-BP))
	 (END-INDEX-1 (BP-INDEX INTERVAL-1-TO-BP))
	 (END-INDEX-2 (BP-INDEX INTERVAL-2-TO-BP))
	 (LEN-1 (IF (EQ LINE-1 END-LINE-1) END-INDEX-1 (LINE-LENGTH LINE-1)))
	 (LEN-2 (IF (EQ LINE-2 END-LINE-2) END-INDEX-2 (LINE-LENGTH LINE-2)))
	 (OVERALL-INDEX 1))
    (LOOP DOING
      ;; If the second interval is exhausted, then they are equal or the second one is less.
      (AND (EQ LINE-2 END-LINE-2) (= INDEX-2 END-INDEX-2)
	   (RETURN (IF (AND (EQ LINE-1 END-LINE-1) (= INDEX-1 END-INDEX-1))
		       0
		       OVERALL-INDEX)))
      ;; If the first interval is exhausted, it is less.
      (AND (EQ LINE-1 END-LINE-1) (= INDEX-1 END-INDEX-1)
	   (RETURN (- OVERALL-INDEX)))
      ;; If either interval is at the end of a line, its next character is a CR.
      (IF (= INDEX-1 LEN-1)
	  (IF (= INDEX-2 LEN-2)
	      ;; CR equals CR, go on
	      (SETQ OVERALL-INDEX (1+ OVERALL-INDEX)
		    LINE-1 (LINE-NEXT-IN-BUFFER LINE-1)
		    LEN-1 (IF (EQ LINE-1 END-LINE-1) END-INDEX-1 (LINE-LENGTH LINE-1))
		    INDEX-1 0
		    LINE-2 (LINE-NEXT-IN-BUFFER LINE-2)
		    LEN-2 (IF (EQ LINE-2 END-LINE-2) END-INDEX-2 (LINE-LENGTH LINE-2))
		    INDEX-2 0)
	      ;; First is at end of line, second is not; can't be equal
	      (RETURN (* (CHAR-COMPARE #\CR (AREF LINE-2 INDEX-2)) OVERALL-INDEX)))
	  (IF (= INDEX-2 LEN-2)
	      ;; Second is at end of line, first is not; can't be equal
	      (RETURN (* (CHAR-COMPARE (AREF LINE-1 INDEX-1) #\CR) OVERALL-INDEX))
	      ;; Neither is at end of line, we have some strings to compare
	      (LET* ((N (MIN (- LEN-1 INDEX-1) (- LEN-2 INDEX-2)))
		     (R (IF CASE-MATTERS
			    (SYS:%STRING-EXACT-COMPARE LINE-1 INDEX-1 LINE-2 INDEX-2 N)
			    (SYS:%STRING-COMPARE LINE-1 INDEX-1 LINE-2 INDEX-2 N))))
		(IF (ZEROP R)
		    ;; Still equal so far
		    (SETQ OVERALL-INDEX (+ OVERALL-INDEX N)
			  INDEX-1 (+ INDEX-1 N)
			  INDEX-2 (+ INDEX-2 N))
		    (RETURN (* (SIGNUM R) (+ OVERALL-INDEX (ABS R) -1))))))))))

(DEFUN CHAR-COMPARE (CH-1 CH-2 &OPTIONAL CASE-MATTERS)
  (IF CASE-MATTERS
      (COND ((CHAR< CH-1 CH-2) -1)
	    ((CHAR= CH-1 CH-2) 0)
	    (T 1))
      (COND ((CHAR-LESSP CH-1 CH-2) -1)
	    ((CHAR-EQUAL CH-1 CH-2) 0)
	    (T 1))))

(DEFFLAVOR INTERVAL-WITH-SORT-INTERVAL
	(SORT-FIRST-BP
	 SORT-LAST-BP)
	(INTERVAL)
  :SETTABLE-INSTANCE-VARIABLES
  :WRITABLE-INSTANCE-VARIABLES)

(DEFUN INTERVAL-WITH-SORT-INTERVAL-LESSP (INT1 INT2)
  (INTERVAL-LESSP (INTERVAL-WITH-SORT-INTERVAL-SORT-FIRST-BP INT1)
		  (INTERVAL-WITH-SORT-INTERVAL-SORT-LAST-BP INT1)
		  T
		  (INTERVAL-WITH-SORT-INTERVAL-SORT-FIRST-BP INT2)
		  (INTERVAL-WITH-SORT-INTERVAL-SORT-LAST-BP INT2)
		  T))

(DEFUN SORT-INTERVAL-FUNCTIONS (MOVE-TO-KEY-FN MOVE-OVER-KEY-FN MOVE-TO-NEXT-FN LESSP-FN
				FROM-BP &OPTIONAL TO-BP IN-ORDER-P)
  (GET-INTERVAL FROM-BP TO-BP IN-ORDER-P)
  (LET ((ARRAY (MAKE-ARRAY 400. ':FILL-POINTER 0)))
    (DO ((*INTERVAL* (CREATE-INTERVAL (COPY-BP FROM-BP ':NORMAL) (COPY-BP TO-BP ':MOVES)))
	 (START-BP FROM-BP END-BP)
	 (KEY-START-BP) (KEY-END-BP) (END-BP))
	((BP-= START-BP TO-BP))
      (SETQ KEY-START-BP (FUNCALL MOVE-TO-KEY-FN START-BP)
	    KEY-END-BP (FUNCALL MOVE-OVER-KEY-FN KEY-START-BP)
	    END-BP (FUNCALL MOVE-TO-NEXT-FN KEY-END-BP))
      (ARRAY-PUSH-EXTEND
	ARRAY (MAKE-INSTANCE 'INTERVAL-WITH-SORT-INTERVAL
			     ':FIRST-BP START-BP
			     ':LAST-BP END-BP
			     ':SORT-FIRST-BP KEY-START-BP
			     ':SORT-LAST-BP KEY-END-BP)))
    (SORT-INTERVAL-ARRAY ARRAY LESSP-FN FROM-BP TO-BP T)))

(DEFFLAVOR INTERVAL-WITH-SORT-KEY
	(SORT-KEY)
	(INTERVAL)
  :WRITABLE-INSTANCE-VARIABLES
  :SETTABLE-INSTANCE-VARIABLES
  )

(DEFUN SORT-INTERVAL-FUNCTIONS-WITH-KEY (MOVE-TO-KEY-FN GET-KEY-FN MOVE-TO-NEXT-FN LESSP-FN
				FROM-BP &OPTIONAL TO-BP IN-ORDER-P)
  (GET-INTERVAL FROM-BP TO-BP IN-ORDER-P)
  (LET ((ARRAY (MAKE-ARRAY 20. ':FILL-POINTER 0)))
    (DO ((*INTERVAL* (CREATE-INTERVAL (COPY-BP FROM-BP ':NORMAL) (COPY-BP TO-BP ':MOVES)))
	 (START-BP FROM-BP END-BP)
	 (KEY-START-BP) (KEY-END-BP) (KEY) (END-BP))
	((BP-= START-BP TO-BP))
      (SETQ KEY-START-BP (FUNCALL MOVE-TO-KEY-FN START-BP))
      (MULTIPLE-VALUE (KEY-END-BP KEY)
	(FUNCALL GET-KEY-FN KEY-START-BP))
      (SETQ END-BP (FUNCALL MOVE-TO-NEXT-FN KEY-END-BP))
      (ARRAY-PUSH ARRAY (MAKE-INSTANCE 'INTERVAL-WITH-SORT-KEY
				       ':FIRST-BP START-BP
				       ':LAST-BP END-BP
				       ':SORT-KEY KEY)))
    (SORT-INTERVAL-ARRAY ARRAY LESSP-FN FROM-BP TO-BP T)))


;;;--- :SELECTOR argument was accepted in 7.1, and compiled in by the MAP-OVER-HARD-SECTIONS
;;;--- macro, so it can't be removed until 8.0, to preserve binary file compatibility.
(DEFGENERIC MAP-OVER-SECTIONS-IN-INTERVAL (TOP-LEVEL-NODE START-BP END-BP CONTINUATION
					   &KEY SELECTOR)
  (:METHOD (NODE)
   (IGNORE SELECTOR)
   (FUNCALL CONTINUATION START-BP END-BP)))

;;;--- :SELECTOR argument was accepted in 7.1, and compiled in by the DEFINITION-REGION-LINES
;;;--- macro, so it can't be removed until 8.0, to preserve binary file compatibility.
(DEFGENERIC MAP-OVER-LINES-IN-INTERVAL (TOP-LEVEL-NODE START-LINE END-LINE CONTINUATION
					&KEY SELECTOR)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION))
  (:METHOD (NODE)
   (IGNORE SELECTOR)
   (FUNCALL CONTINUATION START-LINE END-LINE)))

(DEFUN TYPEOUT-YES-OR-NO-P (&REST FORMAT-ARGS)
  (LET ((QUERY-IO *TYPEOUT-WINDOW*))
    (LEXPR-FUNCALL #'FQUERY '#,`(:SELECT T
				 :TYPE :READLINE
				 :CHOICES ,FORMAT:YES-OR-NO-P-CHOICES)
		   FORMAT-ARGS)))
