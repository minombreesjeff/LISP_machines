;;; -*- Syntax: Zetalisp; Mode: LISP; Package: ZWEI; Base: 8 -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

#|
A new try at editor support facility for patches.  JW, 3/84
This is based on the patch facility in >sys>sys2>pated.lisp.72.
Motivation comes from limitations in current patch facility:
1. Has Lisp wired into its soul.  (but Sage needs to patch the 
documentation database.)
2. Lets you patch only one system at a time.  (Would like to patch e.g.
FORTRAN and Lisp simultaneously, or System and Zmail).
3. Insufficient support for collecting patch comments.
4. Insufficient support for revising documentation or notifying writers
of important changes.

Approach:  Provide new internal representation of state of patching.
*active-patch-states* holds a list of patch states where the
patch state is a structure containing:

system: system flavor or :private
system-name: string for communicating with users (taken out of make-system-info)
description: e.g. System 247.988, Private, in foo.lisp >q:>jwalker>
major version: or 0 when private
minor version: or 0 when private
author: string (current user-id usually)
buffer: pointer to patch buffer
mode: major mode for the SOURCE files for the system
reason-interval: Where the patch comments live within the patch buffer
state: one of {:initial :in-progress :aborted :finished}
make-system-info: ((name major-version system-status ((patch descriptions)))...)
finish-actions: messages to send to the mode when the patch gets finished

There is now a "current patch".  When you do any of the commands that
add patches, they add to the current patch.  There is a command to
select a different patch as current.  If there are any patches in
progress, one of them is current (i.e. current patch is nil only when no
patches are in progress).

Thus you can patch several different systems at once or several
different minor versions of the same system.  I have not yet decided
whether it is safe to permit patches to different major versions of the
same system.  Probably the answer is "it depends".

This is generic.  It defines some new major mode messages to support the
notion of patching for modes other than Lisp.  Each patchable major mode
knows the major mode of its patch file (not necessarily the same as the
major mode itself).
|#

(DEFVAR *ACTIVE-PATCH-STATES* ())
(DEFVAR *INACTIVE-PATCH-STATES* ())
;;; *CURRENT-PATCH* now defined in DEFS.
(DEFVAR *COLLECT-INDIVIDUAL-PATCH-COMMENTS* T)
(DEFVAR *SEND-MAIL-ABOUT-PATCH* :ASK)		;T, NIL, or :ASK

(DEFUN PRIVATE-PATCH-DESCRIPTION ()
  `("Private" 0 :EXPERIMENTAL ((0 "Private patch" ,USER-ID))))

(DEFFLAVOR PATCH-STATE 
	(SYSTEM
	 SYSTEM-NAME
	 DESCRIPTION
	 MAJOR-VERSION
	 MINOR-VERSION
	 AUTHOR
	 REVIEWER
	 BUFFER
	 MODE
	 REASON-INTERVAL
	 STATE
	 MAKE-SYSTEM-INFO
	 FINISH-ACTIONS
	 SPLIT-WINDOW-BUFFER
	 SPLIT-WINDOW-PRIOR-WINDOW-STATE
	 (FINISH-OPTIONS NIL)
	 (NOTE NIL))
	()
  (:INITABLE-INSTANCE-VARIABLES)
  (:READABLE-INSTANCE-VARIABLES)
  (:WRITABLE-INSTANCE-VARIABLES))

(DEFMETHOD (:PRINT-SELF PATCH-STATE) (STREAM IGNORE SLASHIFY)
  (IGNORE SLASHIFY)
  (SI:PRINTING-RANDOM-OBJECT (SELF STREAM :TYPEP)
    (FORMAT STREAM "~A ~D.~D" SYSTEM MAJOR-VERSION MINOR-VERSION)))

(DEFFLAVOR PRIVATE-PATCH-STATE (FOR-SYSTEM-NAME) (PATCH-STATE)
  (:WRITABLE-INSTANCE-VARIABLES)
  (:INITABLE-INSTANCE-VARIABLES))

(DEFMETHOD (:PRINT-SELF PRIVATE-PATCH-STATE) (STREAM IGNORE SLASHIFY)
  (IGNORE SLASHIFY)
  (SI:PRINTING-RANDOM-OBJECT (SELF STREAM :TYPEP)
    (FORMAT STREAM "~A" (WHEN BUFFER (SEND BUFFER :PATHNAME)))))

(DEFSUBST MAKE-PATCH-STATE (&KEY SYSTEM SYSTEM-NAME DESCRIPTION MAJOR-VERSION MINOR-VERSION
				 PRIVATE-FOR-SYSTEM-NAME
				 AUTHOR REVIEWER BUFFER MODE REASON-INTERVAL
				 STATE MAKE-SYSTEM-INFO FINISH-ACTIONS
				 SPLIT-WINDOW-BUFFER SPLIT-WINDOW-PRIOR-WINDOW-STATE)
  (LET ((PS
	  (MAKE-INSTANCE (IF (STRING-EQUAL SYSTEM-NAME "Private") 'PRIVATE-PATCH-STATE
			     'PATCH-STATE)
			 :SYSTEM SYSTEM
			 :SYSTEM-NAME SYSTEM-NAME
			 :DESCRIPTION DESCRIPTION
			 :MAJOR-VERSION MAJOR-VERSION
			 :MINOR-VERSION MINOR-VERSION
			 :AUTHOR AUTHOR
			 :REVIEWER REVIEWER
			 :BUFFER BUFFER
			 :MODE MODE
			 :REASON-INTERVAL REASON-INTERVAL
			 :STATE STATE
			 :MAKE-SYSTEM-INFO MAKE-SYSTEM-INFO
			 :FINISH-ACTIONS FINISH-ACTIONS
			 :SPLIT-WINDOW-BUFFER SPLIT-WINDOW-BUFFER
			 :SPLIT-WINDOW-PRIOR-WINDOW-STATE SPLIT-WINDOW-PRIOR-WINDOW-STATE)))
    (WHEN (STRING-EQUAL SYSTEM-NAME "Private")
      (SETF (PRIVATE-PATCH-STATE-FOR-SYSTEM-NAME PS) PRIVATE-FOR-SYSTEM-NAME))
    PS))

(DEFUN PRIVATE-PATCH-P (SYSTEM)
  (EQ (CANONICALIZE-SYSTEM-ARG SYSTEM) :PRIVATE))

(DEFUN CANONICALIZE-SYSTEM-ARG (SYSTEM)
  (CL:TYPECASE SYSTEM
    (CL:STRING (IF (STRING-EQUAL SYSTEM "Private")
		   :PRIVATE
		 (SCT:FIND-SYSTEM-NAMED SYSTEM NIL T)))
    (SCT:SYSTEM SYSTEM)
    (CL:SYMBOL (IF (EQ SYSTEM :PRIVATE)
		   :PRIVATE
		 (FERROR "Not able to look for ~S as a system" SYSTEM)))
    (CL:LIST (LET ((SYS (SCT:PATCH-NAME SYSTEM)))	;assumed in sct:patch-system format
	       (IF (STRING-EQUAL SYS "Private")
		   :PRIVATE
		 (SCT:FIND-SYSTEM-NAMED SYS NIL T))))
    (PATCH-STATE (PATCH-STATE-SYSTEM SYSTEM))	;assumed to be in patch-state format
    (OTHERWISE (FERROR "Unable to extract system information from ~S" SYSTEM))))

;;;Returns the patch state for a particular system if a patch is in progress for that
;;;system.  Otherwise nil.
;;;system arg can be in any format, it canonicalizes the arg.
;;;It checks the minor version number only when the minor arg is supplied.
(DEFUN PATCH-IN-PROGRESS-P (SYSTEM &OPTIONAL MINOR)
  (SETQ SYSTEM (CANONICALIZE-SYSTEM-ARG SYSTEM))	;canonicalize args.  Survive almost anything.
  (LOOP FOR CANDIDATE IN *ACTIVE-PATCH-STATES*
	WHEN (AND (EQ (PATCH-STATE-SYSTEM CANDIDATE) SYSTEM)
		  (IF MINOR (= (PATCH-STATE-MINOR-VERSION CANDIDATE) MINOR) T))
	RETURN CANDIDATE))

;;;Make the argument the current patch or choose a new one that is not the current one.
;;;returns the new current patch or NIL when the only active patch left would be
;;; the current one.  This function is called during completing a patch and, with no
;;; arg, takes care of shutting down the current patch.
;;;Thus the meaning is quite different, depending on whether there is an arg.
(DEFUN NEW-CURRENT-PATCH (&OPTIONAL NEW)
  (COND (NEW					;arg specified?  Just make it current
	 (UNLESS (AND NEW (PATCH-IN-PROGRESS-P NEW))	;yes, be sure it is patch in progress
	   (BARF "~S is not a patch in progress.  Can't make it the current patch." NEW))
	 (SETQ *CURRENT-PATCH* NEW))
	(T					;no arg, find a candidate for current
	 (SETQ NEW (LOOP FOR P IN *ACTIVE-PATCH-STATES*	;NIL if current one
			 WHEN (NEQ P *CURRENT-PATCH*)	;is only one left
			 RETURN P))
	 (WITHOUT-INTERRUPTS
	   (SETQ *ACTIVE-PATCH-STATES* (DELQ *CURRENT-PATCH* *ACTIVE-PATCH-STATES*))
	   (PUSH *CURRENT-PATCH* *INACTIVE-PATCH-STATES*))
	 (SETQ *CURRENT-PATCH* NEW))))

;;;Finds the system that the buffer would normally be associated with.
(DEFUN SYSTEM-FOR-BUFFER (BUFFER)
  (DECLARE (VALUES SYSTEM VERSION))
  (AND (ZMACS-BUFFER-P BUFFER)
       (FILE-BUFFER-P BUFFER)
       (SCT:PATCHABLE-SYSTEM-FROM-PATHNAME
	 (SEND (SEND BUFFER :PATHNAME) :GENERIC-PATHNAME))))

(DEFUN SUBSYSTEM-FOR-BUFFER (BUFFER)
  (OR (SEND BUFFER :GET 'SCT:SYSTEM)
      (LET ((PATHNAME (SEND BUFFER :SEND-IF-HANDLES :PATHNAME)))
	(WHEN PATHNAME
	  (LET ((GENERIC-PATHNAME (SEND PATHNAME :GENERIC-PATHNAME)))
	    ;; This file defines a system, use it
	    (SEND GENERIC-PATHNAME :GET 'SCT:SYSTEM))))))

;;; Try to find a logical pathname for the current buffer, which may have been
;;; read in via a physical or a logical pathname.
;;; Returns NIL if no logical pathname found.
;;;
;;; If OTHER-BUFFER is specified, and it has a logical pathname, then return NIL
;;; if this one doesn't have a logical pathname.  This is used by patch files,
;;; to ensure that if the patch files are being stored on a logical host then no
;;; physical pathnames leak into the patch file, which would cause trouble later
;;; when the patches are distributed to other sites.
;;;
;;; The strategy is to to find a relevant logical pathname, either from the SCT system's
;;; default-pathname or from the patch file, and then use :BACK-TRANSLATED-PATHNAME.
;;; This works best if a system keeps its patch files and all its source files on the
;;; same logical host, however that is not an absolute requirement.
;;;
;;; We have to look at the FS:BACK-TRANSLATION-ALIST to get the logical pathname of
;;; a patch file, since the buffer's :PATHNAME is a physical pathname.  The
;;; FS:BACK-TRANSLATION-ALIST property is put on by FS:CHECK-TRANSLATION, but
;;; only when FS:*CHECK-FOR-MULTIPLE-TRANSLATIONS* is true (the default state).
;;; If someone sets FS:*CHECK-FOR-MULTIPLE-TRANSLATIONS* to NIL, the
;;; OTHER-BUFFER error check will be turned off.
;;; We look at FS:BACK-TRANSLATION-ALIST first for the source file too, but that
;;; is not strictly necessary, and the property is not always present since the
;;; logical pathname may never have been translated at this site.
(DEFUN BUFFER-LOGICAL-PATHNAME (BUFFER &OPTIONAL OTHER-BUFFER)
  (UNLESS (AND (ZMACS-BUFFER-P BUFFER) (FILE-BUFFER-P BUFFER))
    (RETURN-FROM BUFFER-LOGICAL-PATHNAME NIL))
  (LET ((BUFFER-PATHNAME (SEND BUFFER :PATHNAME)))
    (LOOP FOR (NIL . LOGICAL-PATHNAMES)
	      IN (SEND BUFFER-PATHNAME :GET 'FS:BACK-TRANSLATION-ALIST) DO
      (LOOP FOR LOGICAL-PATHNAME IN LOGICAL-PATHNAMES DO
	(WHEN (EQ (SEND LOGICAL-PATHNAME :TRANSLATED-PATHNAME) BUFFER-PATHNAME)
	  (RETURN-FROM BUFFER-LOGICAL-PATHNAME LOGICAL-PATHNAME))))
    (LET* ((SYSTEM
	     (SCT:PATCHABLE-SYSTEM-FROM-PATHNAME
	       (SEND BUFFER-PATHNAME :GENERIC-PATHNAME)))
	   (DEFAULT-LOGICAL-PATHNAME
	     ;; Get a logical pathname which we can use to back-translate physical
	     ;; pathnames.  Prefer the system's default-pathname to the journal
	     ;; directory, since journal files might be on different host from the
	     ;; source files.
	     (AND SYSTEM (OR (SCT:SYSTEM-DEFAULT-PATHNAME SYSTEM)
			     (SCT:SYSTEM-JOURNAL-DIRECTORY SYSTEM)))))
      (WHEN DEFAULT-LOGICAL-PATHNAME
	(LET ((LOGICAL-PATHNAME (SEND DEFAULT-LOGICAL-PATHNAME
				      :BACK-TRANSLATED-PATHNAME BUFFER-PATHNAME)))
	  (WHEN (AND (TYPEP LOGICAL-PATHNAME 'FS:LOGICAL-PATHNAME)
		     (EQ (SEND LOGICAL-PATHNAME :TRANSLATED-PATHNAME) BUFFER-PATHNAME))
	    (RETURN-FROM BUFFER-LOGICAL-PATHNAME LOGICAL-PATHNAME)))
	;; OK, we do it the hard way.
	;; This really should avoid patchable components, but there is no
	;; :include-components :subsystems-only.
	(LET ((ALL-FILES (SCT:GET-ALL-SYSTEM-INPUT-FILES SYSTEM :INCLUDE-COMPONENTS T))
	      ;; These are non-VC pathanmes since we gave no VC branch
	      (FLAT-PATHNAME (SEND BUFFER-PATHNAME :NEW-PATHNAME
				   :VC-BRANCH NIL :VC-VERSION NIL)))
	  (LOOP FOR FILE IN ALL-FILES
		AS T-PATHNAME = (AND (CL:PATHNAMEP FILE)
				     (SEND FILE :TRANSLATED-PATHNAME))
		WHEN (AND T-PATHNAME (EQ T-PATHNAME FLAT-PATHNAME))
		  DO (RETURN-FROM BUFFER-LOGICAL-PATHNAME
		       (SEND FILE :NEW-PATHNAME
			     :VC-BRANCH (FS:PATHNAME-VC-BRANCH BUFFER-PATHNAME)
			     :VC-VERSION (FS:PATHNAME-VC-VERSION BUFFER-PATHNAME)))))))
    (LET ((MUST-BE-LOGICAL (AND OTHER-BUFFER (BUFFER-LOGICAL-PATHNAME OTHER-BUFFER))))
      (WHEN MUST-BE-LOGICAL
	(LET ((LOGICAL-PATHNAME
		(SEND MUST-BE-LOGICAL :BACK-TRANSLATED-PATHNAME BUFFER-PATHNAME)))
	  (WHEN (AND (TYPEP LOGICAL-PATHNAME 'FS:LOGICAL-PATHNAME)
		     (EQ (SEND LOGICAL-PATHNAME :TRANSLATED-PATHNAME) BUFFER-PATHNAME))
	    (RETURN-FROM BUFFER-LOGICAL-PATHNAME LOGICAL-PATHNAME)))
	;; Cannot find a logical pathname on logical host (FS:PATHNAME-HOST MUST-BE-LOGICAL)
	;; If you wanted to debug why no logical pathname was found, you could
	;; signal an error here.  Normally we just return NIL.
	NIL))))

;;; What version would this be if saved out?
(DEFUN BUFFER-LOGICAL-TRUENAME (BUFFER &OPTIONAL OTHER-BUFFER)
  (LET* ((PATHNAME (BUFFER-LOGICAL-PATHNAME BUFFER OTHER-BUFFER))
	 (FILE-INFO (SEND-IF-HANDLES BUFFER :FILE-INFO))
	 (VC-P (AND (LISTP FILE-INFO) (CL:PATHNAMEP (CAR FILE-INFO))
		    (SEND (CAR FILE-INFO) :VC-VERSION)))
	 (VERSION (AND FILE-INFO
		       (IF (EQ FILE-INFO ':NEVER-READ) 0	;+1 later
			   (AND (LISTP FILE-INFO)
				(CL:PATHNAMEP (CAR FILE-INFO))
				(OR (SEND (CAR FILE-INFO) :VC-VERSION)
				    (SEND (CAR FILE-INFO) :VERSION)))))))
    (WHEN (AND PATHNAME (NUMBERP VERSION))
      (SETQ PATHNAME (SEND PATHNAME
			   (IF VC-P :NEW-VC-VERSION :NEW-VERSION)
			   (IF (SEND BUFFER :MODIFIED-P) (1+ VERSION) VERSION))))
    PATHNAME))

;; This is no longer called
(DEFUN TRANSLATE-SYSTEM-LOGICAL-PATHNAMES (SYSTEM)
  (UNLESS (SCT:SYSTEM-PATHNAMES-TRANSLATED SYSTEM)
    (LET ((PATHNAMES (SCT:GET-ALL-SYSTEM-INPUT-FILES SYSTEM :INCLUDE-COMPONENTS T))
	  (FS:*PATHNAME-INHIBIT-EXPENSIVE-TRANSLATION* T))
      (TV:DOLIST-NOTING-PROGRESS (PATHNAME PATHNAMES (FORMAT () "Translate pathnames for ~a"
						       (SCT:SYSTEM-PRETTY-NAME SYSTEM)))
	(CATCH 'FS:EXPENSIVE-TRANSLATION (SEND PATHNAME :TRANSLATED-PATHNAME))))
    ;; We've translated all the logical pathnames once, let's not
    ;; ever do it again (unless the system is defined again)
    (SETF (SCT:SYSTEM-PATHNAMES-TRANSLATED SYSTEM) T)))

(DEFUN DEFAULT-SYSTEM-TO-PATCH (FOR-BUFFER &OPTIONAL CONSIDER-PRIVATE-PATCH-P)
  (DECLARE (VALUES SYSTEM VERSION))
  (MULTIPLE-VALUE-BIND (DEFAULT-SYSTEM-TO-PATCH DEFAULT-VERSION-TO-PATCH)
      (SYSTEM-FOR-BUFFER FOR-BUFFER)
    (WHEN DEFAULT-SYSTEM-TO-PATCH		;don't offer as default unless valid to patch
      (LET ((SITES (SCT:SYSTEM-MAINTAINING-SITES DEFAULT-SYSTEM-TO-PATCH)))
	(WHEN (AND SITES			;list of site keywords (:SCRC)
		   (NOT (MEMQ (SEND NET:*LOCAL-SITE* :NAME) SITES)))
	  (SETQ DEFAULT-SYSTEM-TO-PATCH NIL
		DEFAULT-VERSION-TO-PATCH NIL))))
    (WHEN (AND (NOT DEFAULT-SYSTEM-TO-PATCH)
	       CONSIDER-PRIVATE-PATCH-P
	       FOR-BUFFER
	       (WITH-BP (BP (FORWARD-LINE (INTERVAL-FIRST-BP FOR-BUFFER)))
		 (AND BP
		      (LET ((STRING ";;; Patch file for Private"))
			(STRING-EQUAL (BP-LINE BP) STRING 0 0 (STRING-LENGTH STRING))))))
      (SETQ DEFAULT-SYSTEM-TO-PATCH :PRIVATE
	    DEFAULT-VERSION-TO-PATCH NIL))
    (UNLESS DEFAULT-SYSTEM-TO-PATCH		;but offer site-specific system as default
      (WHEN (AND SI:*SITE-SYSTEM*		;(string) if no other
		 (SCT:GET-PATCHABLE-SYSTEM-NAMED SI:*SITE-SYSTEM* NIL))
	(SETQ DEFAULT-SYSTEM-TO-PATCH (SCT:FIND-SYSTEM-NAMED SI:*SITE-SYSTEM* NIL)
	      DEFAULT-VERSION-TO-PATCH NIL)))
    (VALUES DEFAULT-SYSTEM-TO-PATCH DEFAULT-VERSION-TO-PATCH)))

;;;Collects indication from user of what system to patch.  Returns a make-system-info format.
;;;Second returned value indicates whether a patch is already in progress for system.
;;;This function is ONLY for collecting user's desire.  No other processing or editorializing.
;;;NOTE: this does NOT return a System, it returns a system patch directory!
(DEFUN SYSTEM-TO-PATCH (&OPTIONAL PROMPT-STRING FOR-BUFFER CONSIDER-PRIVATE-PATCH-P)
  (DECLARE (VALUES SYSTEM PATCH-IN-PROGRESS-P VERSION))
  (SETQ PROMPT-STRING (OR PROMPT-STRING "System to patch"))	;get defaults fixed up
  (SETQ FOR-BUFFER (OR FOR-BUFFER *INTERVAL*))
  (MULTIPLE-VALUE-BIND (DEFAULT-SYSTEM DEFAULT-VERSION)
      (DEFAULT-SYSTEM-TO-PATCH FOR-BUFFER CONSIDER-PRIVATE-PATCH-P)
    (LET ((SYSTEM (TYPEIN-LINE-ACCEPT `((SCL:TOKEN-OR-TYPE (:PRIVATE)
							   ((SCT:SYSTEM :PATCHABLE-ONLY T))))
				      :DEFAULT DEFAULT-SYSTEM
				      :PROMPT PROMPT-STRING)))
      (LET ((PATCHES
	      (IF (EQ SYSTEM :PRIVATE)
		  (PRIVATE-PATCH-DESCRIPTION)
		  (SCT:GET-PATCHABLE-SYSTEM-NAMED SYSTEM T))))
	(VALUES PATCHES
		(PATCH-IN-PROGRESS-P PATCHES)
		(IF (AND DEFAULT-SYSTEM
			 (TYPEP DEFAULT-SYSTEM 'SCT:SYSTEM)
			 (STRING-EQUAL (SCT:PATCH-NAME PATCHES)
				       (SCT:SYSTEM-NAME DEFAULT-SYSTEM)))
		    DEFAULT-VERSION NIL))))))

;;;Returns if OK to go ahead.  Barfs or dies otherwise.
;;;Returns the patch-state if patch is in progress; NIL if no patch in progress but OK.
(DEFUN VALIDATE-REQUEST-FOR-SYSTEM (SYSTEM MINOR-VERSION EXISTS-OK)
  (LET ((PATCH-STATE (PATCH-IN-PROGRESS-P SYSTEM MINOR-VERSION))
	(SITES (UNLESS (EQ SYSTEM :PRIVATE) (SCT:SYSTEM-MAINTAINING-SITES SYSTEM)))
	(QUERY-IO *TYPEOUT-WINDOW*))
    (WHEN (AND (NOT EXISTS-OK) PATCH-STATE)	;patch invalidly in progress
      (FORMAT QUERY-IO "~&Warning:  A patch for ~A is already in progress.~@
Please specify what to do with that patch.~2%"
	      (PATCH-STATE-SYSTEM-NAME PATCH-STATE))
      (SELECTQ					;ask user what to do
	;;First two choices of questionable utility but could be needed for confused user
	(DW:WITH-ACCEPT-HELP
	    (((:TOP-LEVEL-HELP :OVERRIDE)
	      "You are being asked for an action to take with respect to the existing patch:
   Abort that patch and start a new one.
   Finish that patch and start a new one.
   Proceed with a second patch for this system.
   Use the existing buffer; this is not a new patch."))
	  (SCL:ACCEPT '((CL:MEMBER :ABORT :FINISH :PROCEED :USE))))
	(:ABORT					;abort patch
	 (ABORT-PATCH PATCH-STATE)
	 (SETQ PATCH-STATE NIL))
	(:FINISH				;finish patch
	 (UNLESS (FINISH-PATCH-INTERNAL PATCH-STATE) (SETQ PATCH-STATE NIL)))
	(:PROCEED
	 (SETQ PATCH-STATE NIL))		;don't use existing patch
	(:USE ())				;use the buffer as is
	(OTHERWISE (BARF "Ambiguous situation.  Not continuing with patching.")))
      )
    (UNLESS PATCH-STATE
      (AND SITES (NOT (PRIVATE-PATCH-P SYSTEM))
	   (NOT (MEMQ (SEND NET:*LOCAL-SITE* :NAME) SITES))
	   (NOT (YES-OR-NO-P
		  (FORMAT NIL
		    "System ~A is not normally maintained at this site.
Patching it here may result in version skews and make it difficult for your site
to receive subsequent software updates.  Are you sure you want to patch it? "
		    (SCT:SYSTEM-NAME SYSTEM))))
	   (ABORT-CURRENT-COMMAND)))
    (SEND *TYPEOUT-WINDOW* :MAKE-COMPLETE)
    PATCH-STATE))

(DEFVAR *PACKAGE-SYNTAX-ALIST* `((,SI:PKG-SYSTEM-PACKAGE :ZETALISP)
				 (,SI:*LISP-PACKAGE* :COMMON-LISP)
				 (,SI:*SCL-PACKAGE* :COMMON-LISP)))

;;;Finds or creates a patch buffer appropriate for the system to be patched (make-system-info
;;;format for system-to-patch arg)
;;;Manages the contents of *current-patch*.
;;;Returns the patch state structure and an indication of whether the buffer is presumed
;;;to be new (just an inference though; if patch state was in-progress, then buffer exists)
;;;
;;; NOTE: This only accepts PATCH-MAJOR and related list structures as SYSTEM-TO-PATCH,
;;; in spite of the fact that it calls CANONICALIZE-SYSTEM-ARG.
;;;
(DEFUN MAKE-PATCH-CURRENT (SYSTEM-TO-PATCH
			   &KEY EXISTS-OK RESUME MINOR-VERSION FOR-REVOCATION-P
				FOR-SYSTEM PATHNAME PRIVATE-PATCH-NOTE)
  (LET* ((SYSTEM (CANONICALIZE-SYSTEM-ARG SYSTEM-TO-PATCH))	;#<SYSTEM...> format
	 (PRIVATE (PRIVATE-PATCH-P SYSTEM-TO-PATCH))
	 (PATCH-STATE (VALIDATE-REQUEST-FOR-SYSTEM SYSTEM MINOR-VERSION EXISTS-OK))
	 (ALREADY-EXISTS PATCH-STATE)
	 (SYSTEM-NAME (SCT:PATCH-NAME SYSTEM-TO-PATCH))
	 (PATCH-MODE (SEND (SEND *INTERVAL* :MAJOR-MODE) :PATCH-MAJOR-MODE))
	 (FOR-SYSTEM-NAME (WHEN (AND PRIVATE FOR-SYSTEM)
			    (SCT:SYSTEM-NAME (CANONICALIZE-SYSTEM-ARG FOR-SYSTEM))))
	 MAJOR BUFFER AUTHOR REVIEWER)
    (UNLESS (OR PRIVATE ALREADY-EXISTS)
      (WHEN (MEMQ (SCT:PATCH-STATUS SYSTEM-TO-PATCH) '(:BROKEN :OBSOLETE))
	(UNLESS (FQUERY FORMAT:YES-OR-NO-P-OPTIONS
			"The system ~A has been marked ~A.~%  Do you really want to patch it? "
			SYSTEM (SCT:PATCH-STATUS SYSTEM-TO-PATCH))
	  (BARF "Patch not started."))))
    (UNLESS PATCH-STATE				;no patch in progress, set up new patch state
      (SETQ AUTHOR (NON-DAEMON-USER-ID))	;we are always the author, even when resuming
      (SETQ REVIEWER (UNLESS (OR FOR-REVOCATION-P RESUME)
		       (PROMPT-FOR-REVIEWER SYSTEM)))
      (SETQ MAJOR (SCT:PATCH-VERSION SYSTEM-TO-PATCH))
      (SETQ MINOR-VERSION
	    (OR MINOR-VERSION
		(COND ((AND RESUME (NOT PRIVATE))	;resume always specifies minor
		       (TYPEIN-LINE-ACCEPT '((CL:INTEGER 1 *))
					   :PROMPT
					   "Minor version number of patch to resume"))
		      (PRIVATE 0)
		      (T (OR (SCT:RESERVE-PATCH SYSTEM-TO-PATCH AUTHOR REVIEWER)
			     (ABORT-CURRENT-COMMAND))))))
      (WHEN RESUME
	(MULTIPLE-VALUE (NIL REVIEWER)		;pick up old reviewer when resuming
	  (VALIDATE-RESUMING-PATCH SYSTEM-TO-PATCH MINOR-VERSION FOR-REVOCATION-P)))
      ;; Set up a buffer containing the initial contents of the patch file.
      (MULTIPLE-VALUE (NIL BUFFER)
	(LET ((*REVERT-FILE-NOT-FOUND-IS-AN-ERROR* NIL))
	  (FIND-FILE
	    (LET ((TYPE (CANONICAL-TYPE-FROM-MAJOR-MODE PATCH-MODE)))
	      (IF PRIVATE
		  (IF PATHNAME
		      (SEND PATHNAME :NEW-TYPE TYPE)
		      (ACCEPT-DEFAULTED-PATHNAME "Patch file" (PATHNAME-DEFAULTS)
						 :SPECIAL-TYPE TYPE :DIRECTION :WRITE))
		  (SCT:PATCH-SYSTEM-PATHNAME SYSTEM-NAME :PATCH-FILE
					     MAJOR MINOR-VERSION TYPE)))
	    NIL (WHEN PRIVATE :QUERY))))	;don't select; ask to create missing directory
      (UNLESS (OR RESUME (BP-= (INTERVAL-FIRST-BP BUFFER) (INTERVAL-LAST-BP BUFFER)))
	(FORMAT
	  *TYPEOUT-WINDOW*
	  "~&The patch file already exists.  It would be a good idea to select the~@
	   buffer ~A~@
	   and make sure that it doesn't contain anything that you don't want ~
           in the patch file.~%" BUFFER))
      ;; Initialize all the patch data structure,
      (SETQ PATCH-STATE (MAKE-PATCH-STATE
			  :SYSTEM SYSTEM
			  :SYSTEM-NAME SYSTEM-NAME
			  :DESCRIPTION (FORMAT NIL "~A~@[ ~D.~]~@[~D~]~@[, in ~A~]"
					 SYSTEM-NAME
					 (UNLESS PRIVATE MAJOR)
					 (UNLESS PRIVATE MINOR-VERSION)
					 (AND BUFFER (SEND BUFFER :NAME)))
			  :MAJOR-VERSION MAJOR
			  :MINOR-VERSION MINOR-VERSION
			  :AUTHOR AUTHOR
			  :REVIEWER REVIEWER
			  :BUFFER BUFFER 
			  :MODE PATCH-MODE
			  :REASON-INTERVAL NIL
			  :STATE :INITIAL
			  :MAKE-SYSTEM-INFO SYSTEM-TO-PATCH	;change this name later
			  :FINISH-ACTIONS NIL
			  :SPLIT-WINDOW-BUFFER NIL
			  :SPLIT-WINDOW-PRIOR-WINDOW-STATE NIL
			  :PRIVATE-FOR-SYSTEM-NAME FOR-SYSTEM-NAME))
      (UNLESS RESUME				;don't mung package if resuming patch
	(LET ((PKG (IF PRIVATE
		       SI:*USER-PACKAGE*
		     (SCT:SYSTEM-DEFAULT-PACKAGE SYSTEM))))
	  (UNLESS (AND PKG (SETQ PKG (PKG-FIND-PACKAGE PKG :FIND)))
	    (SETQ PKG SI:*USER-PACKAGE*))	;default package is CL-USER
	  (LET* ((GENERIC-PATHNAME (SEND (SEND BUFFER :PATHNAME) :GENERIC-PATHNAME))
		 ;; The syntax for the patch-file should be based on what
		 ;; package (SCL or ZL) it inherits from.  The :SYNTAX attribute
		 ;; in the generic-pathname is worthless here...
		 (USE-PKGS (CDR (SI:PKG-SELF-AND-USE-LIST PKG)))
		 (SYNTAX (OR (LOOP FOR P IN USE-PKGS DOING
			       (LET ((PKG-AND-SYNTAX (ASSQ P *PACKAGE-SYNTAX-ALIST*)))
				 (WHEN PKG-AND-SYNTAX
				   (RETURN (SECOND PKG-AND-SYNTAX)))))
			     :COMMON-LISP)))
	    (SEND BUFFER :PUTPROP SYNTAX :SYNTAX)
	    (SEND GENERIC-PATHNAME :PUTPROP SYNTAX :SYNTAX)
	    (SEND BUFFER :PUTPROP T :PATCH-FILE)
	    (SEND GENERIC-PATHNAME :PUTPROP T :PATCH-FILE)
	    (SEND GENERIC-PATHNAME :PUTPROP
		  (INTERN (COMPILER:PACKAGE-NAME-FOR-SYNTAX PKG SYNTAX)
			  SI:PKG-KEYWORD-PACKAGE)
		  :PACKAGE)
	    (SEND BUFFER :PUTPROP PKG :PACKAGE))))
      (LET* ((*INTERVAL* BUFFER)		;gack!! keeps internal fcns from blowing out
	     (STREAM				;Implicit argument to SEARCH
	       (OPEN-INTERVAL-STREAM (OR (SEARCH (INTERVAL-FIRST-BP BUFFER)
						 #.(STRING-APPEND #\CR #\CR)	;not guilty
						 NIL)
					 (INTERVAL-FIRST-BP BUFFER))
				     (INTERVAL-LAST-BP BUFFER)
				     T)))
	(FORMAT STREAM "~A~%" (SEND PATCH-MODE :PATCH-RESPONSIBILITY-COMMENT PATCH-STATE))
	(UNLESS RESUME
	  (FORMAT STREAM "~{~&~A~2%~}" (DEFAULT-IN-PACKAGE-FORMS
					 (PATCH-STATE-SYSTEM PATCH-STATE))))
	(WHEN (AND PRIVATE
		   ;; --- this needs a regular expression or LBE search to
		   ;; --- deal with packages and comments.  It will do for now. --BIM
		   (NULL (SEARCH (INTERVAL-FIRST-BP BUFFER) "(NOTE-PRIVATE-PATCH "))
		   (NULL (SEARCH (INTERVAL-FIRST-BP BUFFER) "(SCT:NOTE-PRIVATE-PATCH ")))
	  (LET ((PRIVATE-PATCH-NOTE
		  (OR PRIVATE-PATCH-NOTE	;keep old note if possible
		      (IF RESUME
			  NIL
			(SI:STRING-TRIM-WHITESPACE
			  (TYPEIN-LINE-ACCEPT
			    `((CL:STRING)
			      :DESCRIPTION "a short descriptive tag for the private patch")
			    :DEFAULT (FORMAT NIL "~@(~A~)"
					     (CL:SUBSTITUTE #\SPACE #\-
							    (SEND (SEND *INTERVAL* :PATHNAME)
								  :NAME)))
			    :PROMPT "Private patch note"))))))
	    (WHEN (AND PRIVATE-PATCH-NOTE (PLUSP (STRING-LENGTH PRIVATE-PATCH-NOTE)))
	      (SETF (PATCH-STATE-NOTE PATCH-STATE) PRIVATE-PATCH-NOTE)
	      (LET ((READTABLE (SI:READTABLE-FOR-SYNTAX (SEND BUFFER :GET :SYNTAX))))
		;; Bind READTABLE to get the quoting character correct
		(FORMAT STREAM "~@[~A~%~](SCT:NOTE-PRIVATE-PATCH ~S)~2%"
			(SCT-FEATURES-PREPROCESSOR-FORM (PATCH-STATE-SYSTEM PATCH-STATE))
			PRIVATE-PATCH-NOTE)))))
	;; Ensure that this is a patch file, even when doing a Resume Patch on
	;; a file which was not initially a patch file.  Also, preserve the
	;; package for Resume Patch
	(LET ((*SET-ATTRIBUTE-UPDATES-LIST* T)
	      (PKG (SEND *INTERVAL* :GET :PACKAGE)))
	  (WHEN RESUME
	    (SEND *INTERVAL* :PUTPROP PKG :PACKAGE)
	    (SET-ATTRIBUTE-INTERNAL :PACKAGE "Package" (FORMAT NIL "~A" PKG) PKG))
	  (SEND *INTERVAL* :PUTPROP T :PATCH-FILE)
	  (SET-ATTRIBUTE-INTERNAL :PATCH-FILE "Patch-File" "Yes" T))
	(UPDATE-ATTRIBUTE-LIST-INTERNAL BUFFER T)
	(SETF (PATCH-STATE-REASON-INTERVAL PATCH-STATE)	;wait until the right initial contents
	      (SEND PATCH-MODE :PATCH-REASON-INTERVAL BUFFER)))	;in case empty
      (WITHOUT-INTERRUPTS
	(PUSH PATCH-STATE *ACTIVE-PATCH-STATES*)))	;last possible moment, to avoid out-of-synch
    (SETF (PATCH-STATE-SPLIT-WINDOW-BUFFER PATCH-STATE) NIL)
    (SETF (PATCH-STATE-SPLIT-WINDOW-PRIOR-WINDOW-STATE PATCH-STATE) NIL)
    (NEW-CURRENT-PATCH PATCH-STATE)
    (VALUES PATCH-STATE				;full structure showing state
	    ALREADY-EXISTS))) 

(DEFUN PROMPT-FOR-REVIEWER (SYSTEM)
  (WHEN (AND (NEQ SYSTEM :PRIVATE)
	     (SCT:SYSTEM-PATCHES-REVIEWED SYSTEM))
    (LET ((REVIEWER (SI:STRING-TRIM-WHITESPACE
		      (TYPEIN-LINE-ACCEPT
			`((CL:STRING)
			  :DESCRIPTION "persons(s) designated to review this patch")
			:DEFAULT NIL
			:PROMPT "Reviewer"))))
      (IF (STRING-EQUAL REVIEWER "") NIL REVIEWER))))

(DEFUN VALIDATE-RESUMING-PATCH (SYSTEM-TO-PATCH MINOR &OPTIONAL FOR-REVOCATION-P)
  (DECLARE (VALUES OLD-AUTHOR OLD-REVIEWER))
  (UNLESS (PRIVATE-PATCH-P SYSTEM-TO-PATCH)	;OK to "resume" private patch, just nothing
    (LET ((SCT:PATCH-SYSTEM SYSTEM-TO-PATCH))
      (SCT:GUARDING-PATCH-DIRECTORY-MODIFICATION
	(LET* ((PATCHES (SCT:PATCH-DIR-VERSION-LIST SCT:.PATCH-DIR.))
	       (THIS-PATCH (ASSOC MINOR PATCHES)))
	  (WHEN (PATCH-IN-PROGRESS-P SYSTEM-TO-PATCH MINOR)
	    (BARF
	      "You are already patching ~A ~D.~D.  Just select that as the current patch"
	      (SCT:PATCH-NAME SYSTEM-TO-PATCH)
	      (SCT:PATCH-VERSION SYSTEM-TO-PATCH) MINOR))
	  (WHEN (NULL THIS-PATCH)
	    (BARF "Patch ~D.~D to ~A has not been started"
		  (SCT:PATCH-VERSION SYSTEM-TO-PATCH) MINOR
		  (SCT:PATCH-NAME SYSTEM-TO-PATCH)))
	  (WHEN (SCT:VERSION-EXPLANATION THIS-PATCH)
	    (WHEN FOR-REVOCATION-P
	      ;;---needs an abort-key catch
	      (FORMAT T "~& D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")Patch comment for0 ~A ~D.~D:~2%~A"
		      (SCT:PATCH-NAME SYSTEM-TO-PATCH) (SCT:PATCH-VERSION SYSTEM-TO-PATCH)
		      MINOR (SCT:VERSION-EXPLANATION THIS-PATCH)))
	    (UNLESS
	      (FQUERY
		FORMAT:YES-OR-NO-P-OPTIONS
		"Patch ~D.~D to ~A has already been finished.  Are you sure you want to~@
		 ~:[change~;revoke~] it, and do you take responsibility to destroy ~
                 all~:*~:[ old~] copies? "
		(SCT:PATCH-VERSION SYSTEM-TO-PATCH) MINOR
		(SCT:PATCH-NAME SYSTEM-TO-PATCH) FOR-REVOCATION-P)
	      (BARF)))
	  (UNLESS (STRING-EQUAL (SCT:VERSION-AUTHOR THIS-PATCH) USER-ID)
	    (UNLESS
	      (FQUERY
		FORMAT:YES-OR-NO-P-OPTIONS
		"Patch ~D.~D to ~A was made by ~A; are you sure you want to ~
                 ~:[resume~;revoke~] it? "
		(SCT:PATCH-VERSION SYSTEM-TO-PATCH) MINOR (SCT:PATCH-NAME SYSTEM-TO-PATCH)
		(SCT:VERSION-AUTHOR THIS-PATCH) FOR-REVOCATION-P)
	      (BARF)))
	  (LET ((OLD-AUTHOR (SCT:VERSION-AUTHOR THIS-PATCH))
		(OLD-REVIEWER (SCT:VERSION-REVIEWER THIS-PATCH)))
	    (SCT:ALTER-PATCH-VERSION THIS-PATCH SCT:EXPLANATION NIL SCT:AUTHOR USER-ID)
	    (VALUES OLD-AUTHOR OLD-REVIEWER)))))))

(DEFCOM COM-EDIT-SYSTEM-FILES
	"Read all the files of a system into buffers.
With a numeric argument, reads the files of the component system, too." ()
  (LET* ((SYSTEM-SPEC (TYPEIN-LINE-ACCEPT
			'((SCL:TYPE-OR-STRING ((OR SCT:SUBSYSTEM SCT:SYSTEM))))
			:DEFAULT (SUBSYSTEM-FOR-BUFFER *INTERVAL*)
			:PROMPT "Read all files in system (or subsystem)"))
	 (SYSTEM (SCT:FIND-SYSTEM-NAMED SYSTEM-SPEC NIL NIL))
	 (SYSTEM-NAME (WHEN SYSTEM (SCT:SYSTEM-NAME SYSTEM))))
    (WHEN (NULL SYSTEM)
      (BARF "There is no such system as ~A" SYSTEM-SPEC))
    (LOOP WITH BOGUS-FILE-TYPES = (SCT:DESTINATION-FILE-TYPES-FOR-DISTRIBUTION)
	  FOR PATH IN (SCT:GET-ALL-SYSTEM-INPUT-FILES SYSTEM-NAME
						     :INCLUDE-COMPONENTS *NUMERIC-ARG-P*)
	  DO (WHEN (NULL (SEND PATH :CANONICAL-TYPE))
	       (SETQ PATH (SEND PATH :NEW-TYPE
				(OR (SECOND (ASSQ (SCT:SYSTEM-DEFAULT-MODULE-TYPE SYSTEM)
						  SCT:*MODULE-TYPE-FILE-TYPE-ALIST*))
				    :LISP))))
	     (WHEN (FILE-READABLE-BY-ZMACS PATH BOGUS-FILE-TYPES)
	       (FIND-FILE PATH NIL))))
  DIS-NONE)

(DEFUN FILE-READABLE-BY-ZMACS (PATHNAME &OPTIONAL BOGUS-FILE-TYPES)
  (WHEN (NULL BOGUS-FILE-TYPES)
    (SETQ BOGUS-FILE-TYPES (SCT:DESTINATION-FILE-TYPES-FOR-DISTRIBUTION)))
  (LET ((TYPE (SEND PATHNAME :CANONICAL-TYPE)))
    ;; Try hard not to edit binary files in general, but make an exception for
    ;; file types with an associated Mode, which are therefore specially known
    ;; about, like .SAB files, which is known by the Writer Tools editor mode.
    (OR (NOT (NULL (ASSQ TYPE FS:*FILE-TYPE-MODE-ALIST*)))
	(NOT (OR (GET TYPE :BINARY-FILE-BYTE-SIZE)
		 (SCT:DESTINATION-FILE-P PATHNAME BOGUS-FILE-TYPES))))))

(DEFUN SYSTEM-MAJOR-MINOR-TO-PATCH (&OPTIONAL PROMPT-STRING FOR-BUFFER)
  (SETQ PROMPT-STRING (OR PROMPT-STRING "System or system-major-minor to patch"))
  (SETQ FOR-BUFFER (OR FOR-BUFFER *INTERVAL*))
  (LET ((DEFAULT-SYSTEM (DEFAULT-SYSTEM-TO-PATCH FOR-BUFFER)))
    (TYPEIN-LINE-ACCEPT
      `((SCL:TOKEN-OR-TYPE
	  (:PRIVATE)
	  ((SYSTEM-WITH-MAJOR-AND-MINOR-VERSION) :ALLOW-SYSTEM-ONLY T)))
      :DEFAULT (AND DEFAULT-SYSTEM (LIST DEFAULT-SYSTEM))
      :PROMPT PROMPT-STRING)))

(DEFCOM COM-EDIT-PATCH-FILE
	"Edit a patch file for the current version of some system.
Numeric arg asks for major version" ()
  (LET* ((SYSTEM-MAJOR-MINOR (SYSTEM-MAJOR-MINOR-TO-PATCH
			       "System or system major.minor for which to edit patch file"))
	 (SYSTEM (IF (LISTP SYSTEM-MAJOR-MINOR) (FIRST SYSTEM-MAJOR-MINOR) SYSTEM-MAJOR-MINOR))
	 (MAJOR (WHEN (LISTP SYSTEM-MAJOR-MINOR) (SECOND SYSTEM-MAJOR-MINOR)))
	 (MINOR (WHEN (LISTP SYSTEM-MAJOR-MINOR) (THIRD SYSTEM-MAJOR-MINOR)))
	 (PATCHABLE-SYSTEM (SCT:GET-PATCHABLE-SYSTEM-NAMED SYSTEM))
	 (PRIVATE-P (PRIVATE-PATCH-P SYSTEM))
	 (MAJOR-VERSION (UNLESS PRIVATE-P
			  (IF MAJOR MAJOR
			    (IF *NUMERIC-ARG-P*
				(TYPEIN-LINE-ACCEPT '((CL:INTEGER 1 *))
						    :PROMPT "Major version number for system"
						    :DEFAULT (SCT:GET-SYSTEM-VERSION SYSTEM))
			      (SCT:PATCH-VERSION PATCHABLE-SYSTEM)))))
	 (MINOR-VERSION (UNLESS PRIVATE-P
			  (IF MINOR MINOR
			    (TYPEIN-LINE-ACCEPT '((CL:INTEGER 1 *))
						:PROMPT "Minor version number for system"
						:DEFAULT (MULTIPLE-VALUE-BIND (NIL MINOR)
							     (SCT:GET-SYSTEM-VERSION SYSTEM)
							   MINOR)))))
	 (PATCH-FILE (WHEN PRIVATE-P
		       (ACCEPT-DEFAULTED-PATHNAME "Patch file" (PATHNAME-DEFAULTS)
						  :SPECIAL-TYPE
						  (CANONICAL-TYPE-FROM-MAJOR-MODE
						    (SEND (SEND *INTERVAL* :MAJOR-MODE)
							  :PATCH-MAJOR-MODE))
						  :DIRECTION :WRITE))))
    (FIND-FILE (IF PRIVATE-P
		   PATCH-FILE
		 (SCT:PATCH-SYSTEM-PATHNAME SYSTEM :PATCH-FILE
					    MAJOR-VERSION MINOR-VERSION :LISP)))
    DIS-TEXT))

(DEFCOM COM-START-PATCH
	"Starts a new patch, asking the user for the system to patch.
Reserves a new minor version number and creates a buffer whose pathname is the source
file name for the patch creating that version number.  This can start a private patch." ()
  (LET ((SYSTEM (SYSTEM-TO-PATCH)))
    (START-PATCH-INTERNAL SYSTEM))
  DIS-NONE)

(DEFCOM COM-START-PRIVATE-PATCH
	"Starts a new patch, one that is not part of any defined system.
Prompts for a file name.  Creates a buffer for that file.

With a numeric argument, prompts for a system to declare as being associated with
this patch-file, only for the purpose of doing appropriate-system checking when 
adding a patch from a source buffer.

m-X Add Patch can be used to add pieces of code to the file, and m-X Finish Patch
writes out the file, but there is any minor version number of anything.
This is for testing patches." ()
  (LET ((SYSTEM (WHEN *NUMERIC-ARG-P*
		  (CANONICALIZE-SYSTEM-ARG
		    (SYSTEM-TO-PATCH "System to associate with this private patch file")))))
    (MULTIPLE-VALUE-BIND (PATCH-INFO EXISTS)
	(MAKE-PATCH-CURRENT (PRIVATE-PATCH-DESCRIPTION) :FOR-SYSTEM SYSTEM)
      (TYPEIN-LINE "~:[Starting new~;Continuing~] private patch file ~A"
		   EXISTS
		   (SEND (PATCH-STATE-BUFFER PATCH-INFO) ':PATHNAME))))
  DIS-TEXT)					;Patch file might be in current buffer

(DEFUN SELECT-PRIVATE-PATCH ()
  (LET ((ACTIVE-PRIVATE-PATCHES
	  (LOOP FOR PS IN *ACTIVE-PATCH-STATES*
		AS BUFFER = (PATCH-STATE-BUFFER PS)
		WHEN (AND BUFFER (PRIVATE-PATCH-P PS))
		  COLLECT (LIST (FORMAT NIL "~A" (SEND BUFFER :PATHNAME)) PS))))
    (UNLESS ACTIVE-PRIVATE-PATCHES
      (BARF "There are no private patches open."))
    (TYPEIN-LINE-ACCEPT `((DW:MENU-CHOOSE :ALIST ,ACTIVE-PRIVATE-PATCHES)
			  :DESCRIPTION "private patch")
			:PROMPT "Private patch"
			:DEFAULT (WHEN (PRIVATE-PATCH-P *CURRENT-PATCH*) *CURRENT-PATCH*))))

(DEFCOM COM-DECLARE-SYSTEM-FOR-PRIVATE-PATCH
	"Designates a system that is associated with a private patch-file.
The designation is only for the purpose of doing appropriate-system checking
when adding a patch from a source buffer." ()
  (LET ((PS (SELECT-PRIVATE-PATCH)))
    (UNLESS PS (BARF "No patch-file specified."))
    (LET ((SYSTEM (SYSTEM-TO-PATCH "System to associate with this private patch file")))
      (SETF (PRIVATE-PATCH-STATE-FOR-SYSTEM-NAME PS)
	    (SCT:SYSTEM-NAME (CANONICALIZE-SYSTEM-ARG SYSTEM)))))
  DIS-NONE)

;;--- This should reparse the system depedencies (SCT:REQUIRE-PATCH-LEVEL-FOR-PATCH)
(DEFCOM COM-RESUME-PATCH
	"Reads a previously created and saved patch file into a patch buffer.
It assumes that you have saved the patch file without finishing or aborting
the patch.  It resumes working on it." ()
  (MULTIPLE-VALUE-BIND (SYSTEM NIL DEFAULT-VERSION)
      (SYSTEM-TO-PATCH "System to resume patching" NIL T)
    (LET* ((VERSION (UNLESS (PRIVATE-PATCH-P SYSTEM)
		      (TYPEIN-LINE-ACCEPT
			'((CL:INTEGER 1 *))
			:DEFAULT DEFAULT-VERSION
			:PROMPT "Minor version number of patch to resume")))
	   (PATCH-INFO (MAKE-PATCH-CURRENT SYSTEM :RESUME T :MINOR-VERSION VERSION)))
      (MUST-REDISPLAY-OTHER-WINDOWS (PATCH-STATE-BUFFER PATCH-INFO) NIL DIS-TEXT)))
  DIS-NONE)

;;;;See alternate proposal following.
;(defcom COM-SELECT-PATCH
;	"Selects a different patch as the current patch.
;If the system you request is not actively being patched, it queries about
;whether to start patching that system." ()
;  (let ((patch (system-to-patch "Select system as current patch")))
;    (if (patch-in-progress-p patch)
;	(new-current-patch patch)
;	(when (yes-or-no-p (format nil "No patch in progress for ~A.  Start one? "
;				(si:patch-name patch)))
;	  (start-patch-internal patch))))
;  dis-none)

;;;Moon suggests using a menu.  Limitation over the other scheme is that this can select
;;;only from patches in progress and can't be used to start a new patch.  Maybe this is
;;;a good limitation.  Doing it this way makes it easy to have several patches in progress
;;;to same system without complicated prompting for version numbers.
(DEFCOM COM-SELECT-PATCH
	"Selects a different patch as the current patch, showing menu of active patches." ()
  (LET ((PATCH (FIND-APPROPRIATE-PATCH-FOR-BUFFER
		 *INTERVAL*
		 :ALWAYS-DISPLAY-MENU T
		 :SHOW-ALL-PATCHES T)))
    (WHEN PATCH
      (TYPEIN-LINE "Current system to patch is now ~A"
		   (PATCH-STATE-DESCRIPTION *CURRENT-PATCH*))))
  DIS-NONE)

(DEFUN PATCH-ALIST (&OPTIONAL (PATCH-STATES *ACTIVE-PATCH-STATES*)
		    &KEY HIGHLIGHT-PATCHES-FOR-BUFFER HIGHLIGHT-CURRENT)
  (LOOP FOR STATE IN PATCH-STATES
	AS STRING =
	   (FORMAT NIL "~A~:[~; *~]~:[~; 1(current)0~]"
	     (NAME STATE)
	     (AND HIGHLIGHT-PATCHES-FOR-BUFFER 
		  (CHECK-APPROPRIATE-SYSTEM
		    HIGHLIGHT-PATCHES-FOR-BUFFER :PATCH-STATE STATE :PRINT-WARNING NIL))
	     (AND HIGHLIGHT-CURRENT (EQ STATE *CURRENT-PATCH*)))
	COLLECT `(,STRING ,STATE)))

(DEFMETHOD (NAME PATCH-STATE) ()
  (IF (PRIVATE-PATCH-P SELF)
      (SEND (PATCH-STATE-BUFFER SELF) :NAME)
      (FORMAT NIL "~A ~D.~D"
	(PATCH-STATE-SYSTEM-NAME SELF)
	(PATCH-STATE-MAJOR-VERSION SELF)
	(PATCH-STATE-MINOR-VERSION SELF))))

(DEFUN START-PATCH-INTERNAL (SYSTEM)
  (MULTIPLE-VALUE-BIND (NIL EXISTS-P)
      (MAKE-PATCH-CURRENT SYSTEM)
    (IF (PRIVATE-PATCH-P SYSTEM)
	(TYPEIN-LINE "~:[Starting new~;Continuing with~] private patch buffer ~A"
		     EXISTS-P
		     (SEND (PATCH-STATE-BUFFER *CURRENT-PATCH*) :NAME))
	(TYPEIN-LINE "~:[Starting new~;Continuing with~] patch file for version ~D.~D of ~A"
		     EXISTS-P
		     (PATCH-STATE-MAJOR-VERSION *CURRENT-PATCH*)
		     (PATCH-STATE-MINOR-VERSION *CURRENT-PATCH*)
		     (PATCH-STATE-SYSTEM-NAME *CURRENT-PATCH*)))))

(DEFCOM COM-ADD-PATCH
	"Adds the current definition or the region (if any) to the current patch buffer.
If there is no current patch, it prompts for the system to patch. Then it reserves a new
version number and creates a buffer whose pathname is the source file name for the
patch creating that version number.  If there is a region, it appends it to the end of the
patch buffer; otherwise it appends the current definition to the end of the patch buffer." ()
  (LET (BP1 BP2 DEFINITION-NAME)
    (UNLESS (FIND-APPROPRIATE-PATCH-FOR-BUFFER *INTERVAL* :NO-MENU-IF-NO-APPROPRIATE NIL)
      (BARF))
    ;; This COND is almost the same as DEFINITION-REGION, except it is more conservative,
    ;; i.e., it does the CHECK-INTERVAL-SECTIONS and also includes leading comments
    (COND ((WINDOW-REGION-P)
	   (SETQ BP1 (MARK) BP2 (POINT))
	   (WHEN (BP-< BP2 BP1) (SWAPF BP1 BP2))
	   (SETQ DEFINITION-NAME "the region"))
	  ((WINDOW-MARK-P *WINDOW*)
	   (BARF "The region is empty."))
	  (T
	   1;; BP-TOP-LEVEL-NODE makes VC faster.
0	   (CHECK-INTERVAL-SECTIONS (BP-TOP-LEVEL-NODE (POINT)))
	   (MULTIPLE-VALUE-BIND (INTERVAL NAME ERROR-P)
	       (SEND (SEND *INTERVAL* :MAJOR-MODE) ':DEFINITION-INTERVAL (POINT)
		     T				;include leading comments
		     ;;--- Maybe (SEND (PATCH-STATE-BUFFER *CURRENT-PATCH*) :GET :PACKAGE)
		     SI:PKG-USER-PACKAGE)	;include package name
	     (IF ERROR-P (BARF ERROR-P))
	     (SETQ BP1 (INTERVAL-FIRST-BP INTERVAL)
		   BP2 (INTERVAL-LAST-BP INTERVAL)
		   DEFINITION-NAME NAME))))
    (ADD-PATCH-INTERVAL BP1 BP2 T DEFINITION-NAME *INTERVAL* NIL)) ; suppress warnings,
						; since we used
						; FIND-APPROPRIATE-PATCH-FOR-BUFFER
  DIS-MARK-GOES)


(DEFVAR *ADD-PATCH-UNDEFINE-FUNCTION-QUERIES* T)

(DEFCOM COM-ADD-PATCH-UNDEFINE-FUNCTION
	"Given a function spec, adds a an FUNDEFINE form for it to the 
current patch. It prompts for a function name from the minibuffer.  Name completion is
available for definitions in files that have already been loaded into buffers." (KM)
  (OR *CURRENT-PATCH*
      (MAKE-PATCH-CURRENT (SYSTEM-TO-PATCH)))
  (TYPEIN-LINE  "")
  (LET ((FSPECS (READ-FUNCTION-SPECS-TO-EDIT
		  :PROMPT-STRING "Undefine"
		  :PACKAGE-LOOKALIKE NIL))
	(DUMMY-I (MAKE-INTERVAL 'INTERVAL :INITIAL-LINE T)))
    (LOOP FOR FSPEC IN FSPECS			
	  WHEN (OR (AND (NOT *ADD-PATCH-UNDEFINE-FUNCTION-QUERIES*)
			(= (LENGTH FSPECS) 1))
		   (Y-OR-N-P (FORMAT NIL "Undefine ~S? " FSPEC)))
	    DO
	      (DELETE-INTERVAL DUMMY-I)
	      (INSERT (INTERVAL-LAST-BP DUMMY-I)
		      (FSPEC-TO-UNDEFINE-STRING FSPEC))
	      (ADD-PATCH-INTERVAL DUMMY-I NIL NIL
				  (FORMAT NIL "Undefine ~S" FSPEC)
				  *INTERVAL*)))
  DIS-NONE)

(DEFCOM COM-ADD-PATCH-CLEANUP-FLAVOR
	"Patch FUNDEFINE forms for flavor methods that no longer have source in editor buffers.

Insert FUNDEFINE forms in the current patch for any methods of the given flavor that
no longer have source in editor buffers.  You are prompted for the name of a flavor
to clean up.  You will be offered a chance to undefine in the patch (that is, kill)
each method that is still defined in the Lisp world, but that no longer has a source
in the file or editor buffer containing the file from which the method was defined." (KM)
  (OR *CURRENT-PATCH*
      (MAKE-PATCH-CURRENT (SYSTEM-TO-PATCH)))
  (TYPEIN-LINE  "")
  (LET* ((FLAVOR
	   (READ-FLAVOR-NAME
	     "Flavor whose methods are to be cleaned up"
	     "Type the name of a flavor whose methods you have been editing.  You will
be offered a chance to undefine (that is, kill) each method that is still defined
in the Lisp world, but that no longer has a source in the file or editor buffer containing
the file from which the method was defined."))
	 (FOUND NIL)
	 (PATCHED NIL)
	 (DUMMY-I (MAKE-INTERVAL 'NODE :INITIAL-LINE T))
	 (DEFINITION-NAME (FORMAT NIL "Cleanup flavor ~S" FLAVOR)))
    (WITH-OPEN-STREAM (IS (OPEN-INTERVAL-STREAM DUMMY-I))
      (CLEANUP-FLAVOR-MAP-OVER-FUNCTION-SPECS
	FLAVOR
	#'(LAMBDA (FUNCTION-SPEC FILE)
	    (UNLESS FOUND
	      (SETQ FOUND T))
	    (WHEN (TYPEIN-LINE-Y-OR-N-P (IF FILE "~S has no source in ~A~%Undefine it? "
					    "~S was not defined by a file.~%Undefine it? ")
					FUNCTION-SPEC FILE)
	      (UNLESS PATCHED
		(SETQ PATCHED T))
	      (FORMAT IS (IF FILE "~&~A ;From file /"~A/"~%" "~&~A ;Not from any file~%")
		(FSPEC-TO-UNDEFINE-STRING FUNCTION-SPEC)
		FILE)))))
    (IF PATCHED
	(ADD-PATCH-INTERVAL DUMMY-I NIL NIL DEFINITION-NAME *INTERVAL* NIL)
	(TYPEIN-LINE "No /"orphan/" methods for flavor ~S were ~
                      ~:[found~;patched to be undefined~]." FLAVOR FOUND)))
  DIS-NONE)

(DEFUN FSPEC-TO-UNDEFINE-STRING (FSPEC)
  (CL:WITH-OUTPUT-TO-STRING (S)
    (LET ((CL:*PACKAGE* (SEND *INTERVAL* :GET :PACKAGE)))
      (CL:WRITE `(FUNDEFINE ',FSPEC) :STREAM S :ESCAPE T :RADIX T :CIRCLE NIL :PRETTY T
		:LENGTH NIL :LENGTH NIL :GENSYM T :ARRAY T :READABLY T
		:ARRAY-LENGTH NIL :STRING-LENGTH NIL :BIT-VECTOR-LENGTH NIL
		:STRUCTURE-CONTENTS T
		:CASE (IF (SEND *INTERVAL* :GET :LOWERCASE) :DOWNCASE :UPCASE)
		:BASE (SEND *INTERVAL* :GET :BASE)))))

(DEFCOM COM-FINISH-PATCH
	"Finishes the current patch. 
This assumes that the existing binary code file has been tested, and it
installs it as a permanent patch file." ()
  (UNLESS *CURRENT-PATCH*
    (BARF "No patch in progress."))
  (FINISH-PATCH-INTERNAL *CURRENT-PATCH*)
  DIS-NONE)

(DEFCOM COM-ABORT-PATCH "Aborts the current patch.
If you have started to make a patch, with the Add Patch command, and
then decide that you don't really want to make the patch after all,
use this command instead of Finish Patch.  It undoes the effects of
the Add Patch command.  In particular, it un-reserves the minor
version number in the patch directory, offers to delete associated files,
and offers to kill the patch buffer." ()
  (ABORT-PATCH *CURRENT-PATCH*)
  DIS-NONE)

(DEFCOM COM-REVOKE-PATCH
	"Revokes a previously finished patch by combining Resume Patch and Abort Patch.
It reads the patch you designate, with all the appropriate cautionary queries.
Then it aborts the patch:  it un-reserves the minor version number in the patch
directory, offers to delete associated files, and offers to kill the (just created)
patch buffer.  Use this command to remove a finished patch that you just want
to eliminate, rather than resuming it and fixing it." ()
  (MULTIPLE-VALUE-BIND (SYSTEM NIL DEFAULT-VERSION)
      (SYSTEM-TO-PATCH "System for which to revoke a patch" NIL T)
    (LET* ((VERSION (UNLESS (PRIVATE-PATCH-P SYSTEM)
		      (TYPEIN-LINE-ACCEPT
			'((CL:INTEGER 1 *))
			:DEFAULT DEFAULT-VERSION
			:PROMPT "Minor version number of patch to revoke")))
	   (PATCH-INFO (MAKE-PATCH-CURRENT SYSTEM :RESUME T :MINOR-VERSION VERSION
					   :FOR-REVOCATION-P T)))
      (MUST-REDISPLAY-OTHER-WINDOWS (PATCH-STATE-BUFFER PATCH-INFO) NIL DIS-TEXT)
      (ABORT-PATCH *CURRENT-PATCH*)))
  DIS-NONE)

(DEFCOM COM-SET-PATCH-AUTHOR "Set the author of the current patch.
Prompts for a user name and records that as the person who made the patch." ()
  (UNLESS *CURRENT-PATCH*
    (BARF "No patch in progress."))
  (LET ((AUTHOR (IF (EQ (PATCH-STATE-SYSTEM *CURRENT-PATCH*) :PRIVATE)
		    (TYPEIN-LINE-READLINE
		      "Author of private patch ~A is: [default ~A]"
		      (SEND (PATCH-STATE-BUFFER *CURRENT-PATCH*) :PATHNAME)
		      (PATCH-STATE-AUTHOR *CURRENT-PATCH*))	      
		  (TYPEIN-LINE-READLINE
		    "Author of patch ~A ~D.~D is: [default ~A]"
		    (PATCH-STATE-SYSTEM-NAME *CURRENT-PATCH*)
		    (PATCH-STATE-MAJOR-VERSION *CURRENT-PATCH*)
		    (PATCH-STATE-MINOR-VERSION *CURRENT-PATCH*)
		    (PATCH-STATE-AUTHOR *CURRENT-PATCH*)))))
    (UNLESS (STRING-EQUAL AUTHOR "")
      (SETF (PATCH-STATE-AUTHOR *CURRENT-PATCH*) AUTHOR))
    DIS-NONE))

(DEFCOM COM-SET-PATCH-REVIEWER "Set the reviewer of the current patch.
Prompts for a user name and records that as the person who reviewed the patch." ()
  (UNLESS *CURRENT-PATCH*
    (BARF "No patch in progress."))
  (LET ((REVIEWER (IF (EQ (PATCH-STATE-SYSTEM *CURRENT-PATCH*) :PRIVATE)
		      (TYPEIN-LINE-READLINE
			"Reviewer of private patch ~A is: [default ~A]"
			(SEND (PATCH-STATE-BUFFER *CURRENT-PATCH*) :PATHNAME)
			(PATCH-STATE-REVIEWER *CURRENT-PATCH*))	      
		    (TYPEIN-LINE-READLINE
		      "Reviewer of patch ~A ~D.~D is: [default ~A]"
		      (PATCH-STATE-SYSTEM-NAME *CURRENT-PATCH*)
		      (PATCH-STATE-MAJOR-VERSION *CURRENT-PATCH*)
		      (PATCH-STATE-MINOR-VERSION *CURRENT-PATCH*)
		      (PATCH-STATE-REVIEWER *CURRENT-PATCH*)))))
    (UNLESS (STRING-EQUAL REVIEWER "")
      (SETF (PATCH-STATE-REVIEWER *CURRENT-PATCH*) REVIEWER))
    DIS-NONE))

;;;The major mode thing here is preserving the original feature that looked only at
;;;lisp mode buffers.  If we ever get a way of specifying a "current selected set of
;;;buffers", this should use it.
(DEFCOM COM-ADD-PATCH-CHANGED-DEFINITIONS
	"Adds all changed definitions in buffers with the current major mode to the current patch.
It queries about each changed definition before adding it the patch.
It takes the major mode of the current buffer and adds patches only for buffers
with the same major mode." ()
  ;; depend on ADD-PATCH-BUFFER-CHANGED-DEFINITIONS to choose a patch.
  (LET ((CHOOSE-A-MODE (SEND (SEND *INTERVAL* ':GET ':MAJOR-MODE) ':MAJOR-MODE-KEYWORD)))
    (DOLIST (BUFFER *ZMACS-BUFFER-LIST*)
      (AND (EQ (SEND (SEND BUFFER ':GET ':MAJOR-MODE) ':MAJOR-MODE-KEYWORD)
	       CHOOSE-A-MODE)
	   (NOT (SEND BUFFER ':GET ':PATCH-FILE))
	   (ADD-PATCH-BUFFER-CHANGED-DEFINITIONS BUFFER T))))
  (TYPEIN-LINE "Done.")
  DIS-NONE)

(DEFCOM COM-ADD-PATCH-CHANGED-DEFINITIONS-OF-BUFFER
	"Adds all changed definitions in the current buffer to the current patch.
It queries about each changed definition before adding it the patch.
This will only ask about sections that have been patched since the buffer
was WRITTEN, not READ." ()
  ;; This next call will find an appropriate patch for itself.
  (ADD-PATCH-BUFFER-CHANGED-DEFINITIONS *INTERVAL* NIL)
  DIS-NONE)

(DEFCOM COM-ADD-PATCH-CHANGED-DEFINITIONS-OF-TAG-TABLE
	"Add any definitions that have changed in any of the buffers
in the current Tags Table to the current patch.  This will only ask about
sections that have been patched since the buffer was WRITTEN, not READ." ()
  (LET ((T-BUFFER (SELECT-TAG-TABLE NIL)))
    (SEND T-BUFFER :RESTART)
    (LOOP AS BUFFER = (SEND T-BUFFER :NEXT-FILE NIL NIL)
	  DO
      (WHEN (AND (SEND (SEND BUFFER :GET :MAJOR-MODE) :COMPILATION-SUPPORTED)
		 (NOT (SEND BUFFER :GET :PATCH-FILE)))
	(ADD-PATCH-BUFFER-CHANGED-DEFINITIONS BUFFER NIL)))))

(DEFCOM COM-SHOW-PATCHES
	"Displays the state of any patches started in this session." ()
  (IF (> (LENGTH *ACTIVE-PATCH-STATES*) 0)
      (PROGN
	(FORMAT T "~&Active patches:")
	(VIEW-PATCHES-INTERNAL *ACTIVE-PATCH-STATES*))
      (FORMAT T "~&No active patches."))
  (WHEN (NULL *NUMERIC-ARG-P*)
    (IF (> (LENGTH *INACTIVE-PATCH-STATES*) 0)
	(PROGN
	  (FORMAT T "~%Inactive patches:")
	  (VIEW-PATCHES-INTERNAL *INACTIVE-PATCH-STATES*))
	(FORMAT T "~&No inactive patches.")))
  DIS-NONE)

(DEFCOM COM-RECOMPILE-PATCH
	"Recompile an existing patch file." ()
  (MULTIPLE-VALUE-BIND (SYSTEM NIL DEFAULT-VERSION)
      (SYSTEM-TO-PATCH "System of patch to recompile" NIL T)
    (LET ((SCT:*COMPILING-FOR-REQUIRE-PATCH-LEVEL* T))
      (CATCH 'SCT:SKIP-CURRENT-SYSTEM
	(IF (PRIVATE-PATCH-P SYSTEM)
	    ;; if Private, just prompt for pathname and compile it.
	    (COM-COMPILE-FILE)
	  (LET ((VERSION (TYPEIN-LINE-ACCEPT
			   '((CL:INTEGER 1 *))
			   :DEFAULT DEFAULT-VERSION
			   :PROMPT "Minor version number of patch to recompile")))
	    (WHEN (FQUERY FORMAT:YES-OR-NO-P-OPTIONS
			  "Recompiling a patch may leave existing world loads with an ~
                 inconsistent version of the patch.~@
                 Are you sure you want to do this? ")
	      (LET* ((PATHNAME (SCT:PATCH-SYSTEM-PATHNAME (SCT:PATCH-NAME SYSTEM)
							  :PATCH-FILE
							  (SCT:PATCH-VERSION SYSTEM)
							  VERSION :LISP))
		     (BUFFER (FIND-BUFFER-NAMED
			       (FS:MERGE-PATHNAMES PATHNAME *PATHNAME-DEFAULTS*))))
		(WHEN (AND BUFFER (SEND BUFFER :MODIFIED-P))
		  (UNLESS (SAVE-BUFFER-IF-NECESSARY BUFFER)	;NIL if problems saving
		    (BARF "Not recompiling the patch now."))))
	      (LET* ((MACHINE-TYPE
		       (IF *NUMERIC-ARG-P*
			   (TYPEIN-LINE-ACCEPT `(CL:MEMBER ,@SCT:*ALL-MACHINE-TYPES*)
					       :DEFAULT SCT:*LOCAL-MACHINE-TYPE*
					       :PROMPT "Machine type")
			   SCT:*LOCAL-MACHINE-TYPE*))
		     (ENVIRONMENT (OR (SCT:FIND-ENVIRONMENT MACHINE-TYPE)
				      (SCT:FIND-ENVIRONMENT-NAMED 'SCT:LISP-WORLD))))
		(SCT:COMPILE-PATCH ENVIRONMENT SYSTEM VERSION))))))))
  DIS-NONE)

(DEFCOM COM-RELOAD-PATCH "Reload an existing patch file." ()
  (MULTIPLE-VALUE-BIND (SYSTEM NIL DEFAULT-VERSION)
      (SYSTEM-TO-PATCH "System of patch to reload" NIL T)
    (IF (PRIVATE-PATCH-P SYSTEM)
	;; if Private, just prompt for pathname and load it.
	(COM-LOAD-FILE)
      (LET ((VERSION (TYPEIN-LINE-ACCEPT
		       '((CL:INTEGER 1 *))
		       :DEFAULT DEFAULT-VERSION
		       :PROMPT "Minor version number of patch to reload")))
	(LET* ((MACHINE-TYPE
		 (IF *NUMERIC-ARG-P*
		     (TYPEIN-LINE-ACCEPT `(CL:MEMBER ,@SCT:*ALL-MACHINE-TYPES*)
					 :DEFAULT SCT:*LOCAL-MACHINE-TYPE*
					 :PROMPT "Machine type")
		     SCT:*LOCAL-MACHINE-TYPE*))
	       (ENVIRONMENT (SCT:FIND-ENVIRONMENT MACHINE-TYPE)))
	  (SCT:LOAD-PATCH ENVIRONMENT SYSTEM VERSION NIL)))))
  DIS-NONE)

(DEFUN VIEW-PATCHES-INTERNAL (LIST)
  (LOOP FOR PATCH IN LIST
	FOR BUFFER = (PATCH-STATE-BUFFER PATCH)
	AS DESC = (PATCH-STATE-DESCRIPTION PATCH)
	DO
    (LET ((DESC-COMMA (STRING-SEARCH-CHAR #\, DESC)))
      (WHEN DESC-COMMA (SETQ DESC (SUBSTRING DESC 0 DESC-COMMA))))
    (FORMAT T "~&~A: ~A, in ~\presentation\~@[, declared system ~A~]~:[~; (current patch)~]"
      (PATCH-STATE-STATE PATCH) DESC BUFFER
      (AND (PRIVATE-PATCH-P PATCH) (PRIVATE-PATCH-STATE-FOR-SYSTEM-NAME PATCH))
      (EQ *CURRENT-PATCH* PATCH))))

(DEFUN TICK-AS-PATCHED (NODE)
  (WHEN NODE
    (PUTPROP (LOCF (SECTION-NODE-PLIST NODE))
	     (NODE-TICK NODE)
	     'PATCH-TICK)))

(DEFUN ADD-PATCH-BUFFER-CHANGED-DEFINITIONS (BUFFER FILE-QUERY
					     &AUX
					     (CHECKED-SYSTEM NIL)
					     (SELECTIVE T) READ-TICK PATCH-TICK)
  (CHECK-INTERVAL-SECTIONS BUFFER)
  (WITH-INTERVAL-READ-LOCKED (BUFFER)
    (WHEN (SETQ READ-TICK (OR (SEND BUFFER :SEND-IF-HANDLES :SAVE-TICK)
			      (SEND BUFFER :SEND-IF-HANDLES :READ-TICK)))
      (DOLIST (SECTION (BUFFER-SECTIONS BUFFER))
	(AND (TYPEP SECTION 'SECTION-NODE)
	     (> (NODE-TICK SECTION) READ-TICK)
	     (OR (NOT (SETQ PATCH-TICK (GET (LOCF (SECTION-NODE-PLIST SECTION)) 'PATCH-TICK)))
		 (> (NODE-TICK SECTION) PATCH-TICK))
	     (NOT (NULL (SECTION-NODE-DEFINITION-LINE SECTION)))
	     (LET ((NAME (LET ((PACKAGE SI:PKG-USER-PACKAGE))
			   (SEND SECTION :DEFINITION-NAME))))
	       (WHEN FILE-QUERY			;maybe check file OK at first defn in file
		 (OR (FQUERY () "Add patches from ~A? "
		       (OR (SEND BUFFER :SEND-IF-HANDLES :PATHNAME)
			   (SEND BUFFER :NAME)))
		     (RETURN NIL))		;Returns from whole function
		 (SETQ FILE-QUERY NIL))		;turn off query for further defs in this file
	       (UNLESS CHECKED-SYSTEM
		 (UNLESS (FIND-APPROPRIATE-PATCH-FOR-BUFFER BUFFER)
		   (RETURN NIL))
		 (SETQ CHECKED-SYSTEM T))
	       (WHEN (OR (NOT SELECTIVE)	;hardwired to force querying initially
			 (PROGN
			   (MAKE-BUFFER-CURRENT BUFFER)
			   (MOVE-POINT (SECTION-NODE-DEFINITION-LINE SECTION) 0)
			   (MUST-REDISPLAY *WINDOW* DIS-BPS)
			   (RECENTER-WINDOW *WINDOW* :START (INTERVAL-FIRST-BP SECTION))
			   (REDISPLAY *WINDOW* :POINT NIL NIL T)
			   (LET ((CHOICE (FQUERY
					   '(:CHOICES (((T "Yes.") #\Y #\SP)
						       ((NIL "No.") #\N #\RUBOUT)
						       ((:PROCEED "Proceed.") #\P)
						       ((:IGNORE "Ignore.") #\I))
					     :HELP-FUNCTION
					     ADD-PATCH-BUFFER-CHANGED-DEFINITIONS-HELP)
					     ;; !!! Should make "Private Patch" be in italics, really. --- Foner 24-Jun-88.
					     "Patch ~A~:[~*~;~% into Private Patch ~A~]? "
					   NAME
					   (PRIVATE-PATCH-P *CURRENT-PATCH*)
					   (NAME *CURRENT-PATCH*))))
			     (SETQ SELECTIVE (NEQ CHOICE :PROCEED))	;maybe turn off query
			     (WHEN (EQ CHOICE :IGNORE)
			       (TICK-AS-PATCHED SECTION)
			       (SETQ CHOICE NIL))
			     CHOICE)))
		 (ADD-PATCH-INTERVAL SECTION NIL T NAME BUFFER NIL))))))))

(DEFUN ADD-PATCH-BUFFER-CHANGED-DEFINITIONS-HELP (STREAM &REST IGNORE)
  (FORMAT STREAM "~&Type Y to patch it, N to skip patching it, ~
		  P to patch it and the rest without asking,~@
                  or I to ignore it now and afterwards.~%"))

;;;Give it the interval that you want to patch from the originating buffer.
(DEFUN ADD-PATCH-INTERVAL (BP1 BP2 IN-ORDER-P DEFINITION-NAME BUFFER
			   &OPTIONAL (WARN T) (INITIAL-COMMENT NIL))
  (WITH-INTERVAL-READ-LOCKED (BP1 BP2 IN-ORDER-P)
    (LET* ((PATCH-BUFFER (PATCH-STATE-BUFFER *CURRENT-PATCH*))
	   (NEW-PATCH-BUFFER-P (EQ (PATCH-STATE-STATE *CURRENT-PATCH*) :INITIAL))
	   (PROCEED-P T))
      (SETQ PROCEED-P
	    (OR (NOT WARN)
		(OR (CHECK-APPROPRIATE-SYSTEM BUFFER)	;warn if system not appropriate
		    (YES-OR-NO-P " Add this interval to the patch file anyway? "))))
      (WHEN PROCEED-P
	(WHEN *COLLECT-INDIVIDUAL-PATCH-COMMENTS*
	  (ADD-PATCH-COMMENT *CURRENT-PATCH* DEFINITION-NAME INITIAL-COMMENT))
	(IF (PRIVATE-PATCH-P *CURRENT-PATCH*)
	    (TYPEIN-LINE "Adding ~A to private patch file ~A~:[~; (New patch buffer.)~]"
			 DEFINITION-NAME (SEND PATCH-BUFFER ':PATHNAME)
			 NEW-PATCH-BUFFER-P)
	  (TYPEIN-LINE "Adding ~A to patch file for version ~D.~D of ~A~
                      ~:[~; (New patch buffer.)~]"
		       DEFINITION-NAME (PATCH-STATE-MAJOR-VERSION *CURRENT-PATCH*)
		       (PATCH-STATE-MINOR-VERSION *CURRENT-PATCH*)
		       (PATCH-STATE-SYSTEM-NAME *CURRENT-PATCH*) NEW-PATCH-BUFFER-P))
	(SEND (SEND BUFFER ':GET ':MAJOR-MODE)
	      :ADD-PATCH-INTERVAL BP1 BP2 IN-ORDER-P BUFFER PATCH-BUFFER)
	(WHEN NEW-PATCH-BUFFER-P
	  (SETF (PATCH-STATE-STATE *CURRENT-PATCH*) :IN-PROGRESS))))))

;;; Add a form to the current patch, assuming it's for a language that uses forms
;;; its patch files.
(DEFUN ADD-PATCH-FORM (FORM INITIAL-COMMENT BUFFER &OPTIONAL (WARN T))
  (LET ((INTERVAL (CREATE-INTERVAL)))
    (CL:WRITE FORM :STREAM (OPEN-INTERVAL-STREAM INTERVAL) :PRETTY ':CODE :READABLY T)
    (ADD-PATCH-INTERVAL INTERVAL NIL NIL "removal form" BUFFER WARN INITIAL-COMMENT)))

;;;Adds some literal text to the current patch buffer.
;;;This doesn't do anything about the "computation environment", like the
;;;compiler-let stuff.  That is up to the caller to supply, if it is needed.
(DEFUN ADD-PATCH-LITERAL (PARENT-BUFFER STRING)
  (OR *CURRENT-PATCH* (MAKE-PATCH-CURRENT (SYSTEM-TO-PATCH)))
  (WHEN *COLLECT-INDIVIDUAL-PATCH-COMMENTS*
    (ADD-PATCH-COMMENT *CURRENT-PATCH* NIL NIL))
  (SEND (SEND PARENT-BUFFER :GET :MAJOR-MODE)
    :ADD-PATCH-LITERAL (CREATE-INTERVAL STRING) NIL T
    PARENT-BUFFER (PATCH-STATE-BUFFER *CURRENT-PATCH*)))

(DEFMETHOD (:ADD-PATCH-LITERAL MAJOR-MODE) (BP1 BP2 IN-ORDER-P FROM-BUFFER TO-BUFFER)
  (SEND (MAJOR-MODE-FROM-KEYWORD *DEFAULT-LANGUAGE-MODE*)
	:ADD-PATCH-LITERAL BP1 BP2 IN-ORDER-P FROM-BUFFER TO-BUFFER))

(DEFMETHOD (:ADD-PATCH-LITERAL LISP-SYNTAX-MIXIN) (BP1 BP2 IN-ORDER-P FROM-BUFFER TO-BUFFER)
  (GET-INTERVAL BP1 BP2 IN-ORDER-P)
  (LET ((BP (INTERVAL-LAST-BP TO-BUFFER)))
    (INSERT BP (FORMAT NIL "~%;;Literal text added while editing ~A~@[~A~]~%"
		 (NAMED-BUFFER-NAME FROM-BUFFER) (SEND FROM-BUFFER :VERSION-STRING)))
    (INSERT-INTERVAL BP BP1 BP2 T)
    (INSERT BP (FORMAT NIL "~%"))))

(DEFUN ABORT-PATCH (STATE)
  (UNLESS STATE				;would happen only for *current-patch*
    (BARF "Patch not in progress, cannot abort it."))
  (UNLESS (EQ (PATCH-STATE-SYSTEM STATE) :PRIVATE) 
    (LET ((ERROR-MESSAGE (SCT:ABORT-PATCH (PATCH-STATE-MAKE-SYSTEM-INFO STATE)
					  (PATCH-STATE-MINOR-VERSION STATE))))
      (WHEN ERROR-MESSAGE (BARF ERROR-MESSAGE))))
  (LET* ((BUFFER (PATCH-STATE-BUFFER STATE))
	 (PATHNAME (AND BUFFER (SEND (SEND BUFFER ':PATHNAME)
				     :NEW-PATHNAME :TYPE :WILD :VERSION :WILD))))
    (WHEN PATHNAME
      (CONDITION-CASE (FILES)
	   (CDR (FS:DIRECTORY-LIST PATHNAME ':FAST ':SORTED))
	 (FS:FILE-OPERATION-FAILURE)
	 (:NO-ERROR
	   (WHEN FILES
	     (FORMAT T "~&Deleting the following ~D file~:P:~%~%" (LENGTH FILES))
	     (LOOP FOR (FILE) IN FILES
		   DO (PRINC FILE) (TERPRI))
	     (WHEN (FQUERY NIL "Delete the above ~D file~:P? " (LENGTH FILES))
	       (LOOP FOR (FILE) IN FILES
		     DO (CONDITION-CASE (ERR)
			     (DELETEF FILE)
			   (FS:FILE-OPERATION-FAILURE
			     (FORMAT ERROR-OUTPUT "~&Cannot delete ~A: ~A"
			       FILE ERR)))))))))
    (WHEN (AND BUFFER (FQUERY NIL "Kill buffer ~A? " (SEND BUFFER :NAME))
	       (KILL-BUFFER BUFFER T)
	       (SETF (PATCH-STATE-BUFFER STATE) NIL))))
  (WITHOUT-INTERRUPTS
    (SETF (PATCH-STATE-STATE STATE) :ABORTED)	;---without-interrupts recommended?
    (WHEN (EQ STATE *CURRENT-PATCH*)		;current patch being aborted, pick new current
      (IF (NEW-CURRENT-PATCH)			;something left to pick?
	  (TYPEIN-LINE "Current system to patch is now ~A"
		       (PATCH-STATE-DESCRIPTION *CURRENT-PATCH*))
	(TYPEIN-LINE "No more patches in progress")))))

;;; a needed presentation type to gather triples of (SYSTEM MAJOR MINOR)
;;; original design courtesy of D. Doughty
(SCL:DEFINE-PRESENTATION-TYPE SYSTEM-WITH-MAJOR-AND-MINOR-VERSION
      (() &KEY CURRENT-SYSTEM ALREADY-KNOWN-SYSTEMS ALLOW-SYSTEM-ONLY)
   :HISTORY T
   :DESCRIPTION "system major minor"
   :PARSER ((STREAM)
	    (BLOCK RESULT
	      (DW:WITH-ACCEPT-BLIP-CHARS ('(#\SP))
		(DW:WITH-ACCEPT-HELP (((:TOP-LEVEL-HELP :OVERRIDE)
  "You are being asked to enter a system followed by major and minor version numbers for it."))
		  (LET ((SYSTEM (SCL:ACCEPT '((SCT:SYSTEM :PATCHABLE-ONLY T)) :STREAM STREAM
					    :PROMPT NIL)))
		    (LET ((DELIMITER (DW:READ-CHAR-FOR-ACCEPT STREAM)))
		      (UNLESS (DW:COMPARE-CHAR-FOR-ACCEPT DELIMITER #\SP)
			(IF ALLOW-SYSTEM-ONLY
			    (RETURN-FROM RESULT SYSTEM)
			  (ZL:PARSE-FERROR "You must supply a major and minor version."))))
		    (WHEN (EQL SYSTEM CURRENT-SYSTEM)
		      (ZL:PARSE-FERROR "A system can't depend on itself."))
		    (LOOP FOR SYS IN ALREADY-KNOWN-SYSTEMS
			  WHEN (EQL SYSTEM SYS)
			    DO (ZL:PARSE-FERROR
				 "There is already a specification for ~A." SYS))
		    (MULTIPLE-VALUE-BIND (MAJOR MINOR)
			(SCT:GET-SYSTEM-VERSION SYSTEM)
		      (DW:WITH-ACCEPT-BLIP-CHARS ('(#\SP #\.))
			(DW:WITH-ACCEPT-HELP ((:SUBHELP
						(LAMBDA (STREAM IGNORED)
						  (FORMAT STREAM
                  "You are currently being asked to enter a major version for ~A." SYSTEM))))
			  (SETQ MAJOR
				(SCL:ACCEPT '((CL:INTEGER 1)) :DEFAULT MAJOR
					    :STREAM STREAM :PROMPT NIL))))
		      (LET ((DELIMITER (DW:READ-CHAR-FOR-ACCEPT STREAM)))
			(UNLESS (OR (DW:COMPARE-CHAR-FOR-ACCEPT DELIMITER #\SP)
				    (DW:COMPARE-CHAR-FOR-ACCEPT DELIMITER #\.))
			  (ZL:PARSE-FERROR "You must supply a minor version.")))
		      (DW:WITH-ACCEPT-HELP ((:SUBHELP
					      (LAMBDA (STREAM IGNORED)
						(FORMAT STREAM
          "You are currently being asked to enter a minor version for ~A ~D." SYSTEM MAJOR))))
			(SETQ MINOR
			      (SCL:ACCEPT `((CL:INTEGER 0)) :DEFAULT MINOR
					  :STREAM STREAM :PROMPT NIL)))
		      (LET ((FINAL-DELIMITER (DW:READ-CHAR-FOR-ACCEPT STREAM)))
			(UNLESS (DW:COMPARE-CHAR-FOR-ACCEPT FINAL-DELIMITER #\SP)
			  (DW:UNREAD-CHAR-FOR-ACCEPT FINAL-DELIMITER STREAM)))
		      (LIST SYSTEM MAJOR MINOR)))))))
   :PRINTER ((SET STREAM)
	     (DESTRUCTURING-BIND (SYSTEM MAJOR MINOR) SET
	       (SCL:PRESENT SYSTEM 'SCT:SYSTEM :STREAM STREAM)
	       (WHEN MAJOR
		 (SCL:WRITE-CHAR #\SPACE STREAM)
		 (SCL:PRESENT MAJOR 'CL:INTEGER :STREAM STREAM)
		 (WHEN MINOR
		   (SCL:WRITE-CHAR #\. STREAM)
		   (SCL:PRESENT MINOR 'CL:INTEGER :STREAM STREAM))))))

;;; In turn, this function is used under dw:accepting values
(DEFUN READ-SYSTEM-DEPENDENCIES (ITEM-LIST SYSTEM)
  (LET ((CACHE (CL:MAKE-ARRAY (LENGTH ITEM-LIST)
			      :FILL-POINTER T
			      :INITIAL-CONTENTS ITEM-LIST))
	(PRESENTATION-TYPE `((SYSTEM-WITH-MAJOR-AND-MINOR-VERSION)
			     :CURRENT-SYSTEM ,SYSTEM
			     :ALREADY-KNOWN-SYSTEMS ,(LOOP FOR (SYSTEM) IN ITEM-LIST
							   COLLECT SYSTEM))))
    ;; read each existing row or column, plus one new one
    (LOOP FOR COUNT BELOW (CL:LENGTH CACHE)
	  FOR ITEM = (CL:ELT CACHE COUNT)
	  FINALLY (LET ((LAST (SCL:ACCEPT PRESENTATION-TYPE
					  :PROMPT (FORMAT NIL "      System ~D" (1+ COUNT))
					  :QUERY-IDENTIFIER COUNT
					  :DEFAULT NIL)))
		    (WHEN LAST
		      (CL:VECTOR-PUSH-EXTEND LAST CACHE)))
	  DO
      (LET* ((PRESENTATION-TYPE `((SYSTEM-WITH-MAJOR-AND-MINOR-VERSION)
				  :CURRENT-SYSTEM ,SYSTEM
				  :ALREADY-KNOWN-SYSTEMS ,(LOOP FOR (SYS) BEING THE
								    ARRAY-ELEMENTS OF CACHE
								UNLESS (EQL SYS (FIRST ITEM)) 
								  COLLECT SYS)))
	     (NEW-ITEM (SCL:ACCEPT PRESENTATION-TYPE
				  :PROMPT (FORMAT NIL "      System ~D" (1+ COUNT))
				  :QUERY-IDENTIFIER COUNT
				  :DEFAULT ITEM)))
	(CL:SETF (CL:ELT CACHE COUNT)
		 NEW-ITEM)))
    (CL:COERCE CACHE 'LIST)))

(DEFFLAVOR PATCH-COMMENT-EDITOR-MIXIN () ())

(DEFMETHOD (:EDIT PATCH-COMMENT-EDITOR-MIXIN :BEFORE) ()
  (SEND (MODE-OF-FLAVOR 'TEXT-MODE) :COMMAND-EXECUTE))

(DEFMETHOD (:DEACTIVATE PATCH-COMMENT-EDITOR-MIXIN :BEFORE) ()
  (SEND SELF :DEEXPOSE))

(DEFFLAVOR PATCH-COMMENT-EDITOR-WINDOW ()
	   (PATCH-COMMENT-EDITOR-MIXIN STANDALONE-EDITOR-WINDOW))

;;; When set up this way, the patch comment editor window is a brother of the Zmacs
;;; frame, not an offspring.  This is the only way yet discovered to avoid bad zwei
;;; window-selection confusion when the typeout window has been used in the patch
;;; comment editor window; MMcM endorses this approach for now.  A search is still
;;; in progress for a way to do this, putting it all in the Zmacs heirarchy.
(TV:DEFWINDOW-RESOURCE EDIT-PATCH-COMMENT-WINDOW ()
  :MAKE-WINDOW (PATCH-COMMENT-EDITOR-WINDOW :LABEL "Edit Patch Comment"
					    :*COMTAB* *PATCH-COMMENT-COMTAB*)
  :INITIAL-COPIES 0				;Initial copy can't be made before Zmacs!
  :REUSABLE-WHEN :DEACTIVATED)

(DEFUN EDIT-PATCH-COMMENT-IMMEDIATELY (STRING)
  ;; this kludge is necessary because it is too problematic to make the patch-comment
  ;; window an offspring of *zmacs-main-frame*, so it is a sibling.  We maintain the
  ;; appearance of offspringness by checking that it continues to line up with the
  ;; Zmacs frame; if not, we trash the existing window and cons another one.
  (LET ((FRAME (WINDOW-FRAME *WINDOW*)))
    (USING-RESOURCE (WINDOW EDIT-PATCH-COMMENT-WINDOW (SEND FRAME :SUPERIOR))
      (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
	  (SEND FRAME :EDGES)
	(SEND WINDOW :SET-EDGES LEFT TOP RIGHT (+ TOP (TRUNCATE (* 0.75 (- BOTTOM TOP))))))
      ;; Shadow the Zmacs frame so that the Select key will find it, etc.
      (TV:WITH-WINDOW-SHADOWED-FOR-SELECTION (FRAME WINDOW :RESELECT T)
	(LET ((STRING (CATCH 'ABORT-STANDALONE-EDIT
			(EDSTRING STRING WINDOW))))
	  STRING)))))


(DEFVAR *SYSTEM-CHANGES-DESTINATION* NIL)	;needed here for client.

(DEFVAR *FINISH-PATCH-SAVE-SOURCES-DEFAULT* NIL
  "Values are T or Nil; Whether or not to preselect Yes or No for 1Save sources for this patch
0   in the Finish Patch options dialogue.")
(DEFUN GATHER-FINISH-PATCH-OPTIONS (STATE REASON-STRING)
  (LET* ((REASON-P (PLUSP (STRING-LENGTH REASON-STRING)))
	 (NEW-REASON-P NIL)
	 (SYSTEM (IF (EQ (PATCH-STATE-SYSTEM STATE) :PRIVATE)
		     NIL (PATCH-STATE-SYSTEM STATE)))
	 (SYSTEM-DEPENDENCIES (CL:GETF (PATCH-STATE-FINISH-OPTIONS STATE)
				       :SYSTEM-DEPENDENCIES))
	 (GATHER-SYSTEM-DEPENDENCIES (NOT (NULL SYSTEM-DEPENDENCIES)))
	 (SEND-MAIL (EQL *SEND-MAIL-ABOUT-PATCH* T))
	 (MAIL-ADDRESSED-TO
	   (LET ((SYSTEM-DESTINATION
		   (IF SYSTEM
		       (AND (STRINGP (SCT:SYSTEM-PATCHES-REVIEWED SYSTEM))
			    (SCT:SYSTEM-PATCHES-REVIEWED SYSTEM))
		     ;; if there's a reviewer, should be default recip. for Private
		     (PATCH-STATE-REVIEWER STATE))))
	     (OR SYSTEM-DESTINATION
		 (WHEN SYSTEM
		   (OR *SYSTEM-CHANGES-DESTINATION*
		       *DOC-CHANGES-DESTINATION*)))))
	 (AUTHOR (PATCH-STATE-AUTHOR STATE))
	 (REVIEWER (PATCH-STATE-REVIEWER STATE))
	 (SOURCE-BUFFERS-TO-SAVE (PATCH-SOURCE-BUFFERS-TO-SAVE STATE))
	 (SAVE-SOURCES *FINISH-PATCH-SAVE-SOURCES-DEFAULT*)
	 (EDIT-COMMENT (NOT REASON-P))
	 (QUERY-IO *TYPEOUT-WINDOW*)
	 (SAVED-MORE-P)
	 (TITLE-LINE
	   (FORMAT NIL "1Select options for Finish Patch for 0~A1:0"
		   (IF (NULL SYSTEM)
		       (FORMAT NIL "1Private patch 0~A"
			       (SEND (SEND (PATCH-STATE-BUFFER STATE) :PATHNAME)
				     :NEW-VERSION NIL))
		     (FORMAT NIL "~A 1patch0 ~D.~D" SYSTEM (PATCH-STATE-MAJOR-VERSION STATE)
			     (PATCH-STATE-MINOR-VERSION STATE))))))
    (CL:FRESH-LINE)				; needed to open the typeout window
    (FLET ((FIXED-LINE (STRING)
	     (DW:WITH-REDISPLAYABLE-OUTPUT (:UNIQUE-ID STRING
					    :CACHE-VALUE STRING
					    :STREAM QUERY-IO)
	       (CL:WRITE-LINE STRING QUERY-IO))))
      (UNWIND-PROTECT
	  (PROGN
	    (SETQ SAVED-MORE-P (SEND CL:*STANDARD-OUTPUT* :MORE-P))
	    (SEND CL:*STANDARD-OUTPUT* :SET-MORE-P NIL)
	    (DW:ACCEPTING-VALUES (T :RESYNCHRONIZE-EVERY-PASS T)
	      (DW:WITH-REDISPLAYABLE-OUTPUT (:STREAM QUERY-IO
					     :UNIQUE-ID 'BAR
					     :CACHE-VALUE REASON-STRING
					     :CACHE-TEST #'STRING=)
		(IF REASON-P (PROGN (FIXED-LINE
				      (IF NEW-REASON-P 1" Changed patch comment:0" 
					" 1Patch comment:0"))
				    (FIXED-LINE "")
				    (FIXED-LINE REASON-STRING))
		  (FIXED-LINE "  1<No comment>0"))
		(FIXED-LINE ""))
	      (DW:WITH-REDISPLAYABLE-OUTPUT (:STREAM QUERY-IO :UNIQUE-ID 'FOO
						     :CACHE-VALUE 'FOO)
		(MULTIPLE-VALUE-BIND (X Y) (SEND QUERY-IO :READ-CURSORPOS)
		  (LET ((W (SEND QUERY-IO :INSIDE-WIDTH)))
		    (WHEN (AND X Y W)
		      (LET ((OFFSET (TRUNCATE (* 0.02 (- W X)))))
			(GRAPHICS:DRAW-RECTANGLE (+ X OFFSET) Y (- W (* 2 OFFSET)) (+ Y 2)
						 :STREAM QUERY-IO))
		      (SEND QUERY-IO :SET-CURSORPOS X (+ Y 2))))))
	      (FIXED-LINE "")
	      (FIXED-LINE TITLE-LINE)
	      (FIXED-LINE "  1Immediate actions (as soon as  is given):0")
	      (DW:ACCEPT-VALUES-COMMAND-BUTTON
		() (CL:WRITE-LINE "    Click here to(2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB") edit the patch comment now0")
		(SETQ REASON-STRING
		      (OR (EDIT-PATCH-COMMENT-IMMEDIATELY REASON-STRING) REASON-STRING))
		(TV:PROCESS-TYPEAHEAD (SEND *TYPEOUT-WINDOW* :IO-BUFFER)
				      #'(LAMBDA (CH)	; crock, ugh.
					  (IF (AND (LISTP CH)
						   (MEMQ (CAR CH)
							 '(CONFIGURATION-CHANGED
							   REDISPLAY SELECT-WINDOW)))
					      NIL CH)))
		(SETQ REASON-P (PLUSP (STRING-LENGTH REASON-STRING)))
		(SETQ NEW-REASON-P T))
	      (SETQ AUTHOR (DW:ACCEPT 'SCL:STRING
				      :PROMPT "    Patch author"
				      :DEFAULT AUTHOR))
	      (SETQ REVIEWER (DW:ACCEPT '((SCL:NULL-OR-TYPE SCL:STRING))
					:PROMPT "    Patch reviewer"
					:DEFAULT REVIEWER
					:PROVIDE-DEFAULT T))
	      (SETQ GATHER-SYSTEM-DEPENDENCIES
		    (DW:ACCEPT 'SCL:BOOLEAN
			       :PROMPT
		     "    Require some system patch levels in order to load this patch"
			       :DEFAULT GATHER-SYSTEM-DEPENDENCIES))
	      (SETQ SYSTEM-DEPENDENCIES
		    (IF GATHER-SYSTEM-DEPENDENCIES
			(READ-SYSTEM-DEPENDENCIES SYSTEM-DEPENDENCIES SYSTEM)
		      NIL))
	      (FIXED-LINE "  1Actions while compiling and finishing the patch:0")
	      (SETQ EDIT-COMMENT (DW:ACCEPT 'SCL:BOOLEAN
					    :PROMPT "    Edit the patch comment"
					    :DEFAULT EDIT-COMMENT))
	      (SETQ SEND-MAIL (DW:ACCEPT 'SCL:BOOLEAN
					 :PROMPT "    Send mail about the patch"
					 :DEFAULT SEND-MAIL))
	      (WHEN SEND-MAIL
		(SETQ MAIL-ADDRESSED-TO (DW:ACCEPT 'SCL:STRING
						   :PROMPT "      Send mail to"
						   :DEFAULT MAIL-ADDRESSED-TO)))
	      (WHEN SOURCE-BUFFERS-TO-SAVE
		(DW:WITH-REDISPLAYABLE-OUTPUT (:UNIQUE-ID 'BUFFERS
					       :CACHE-VALUE SOURCE-BUFFERS-TO-SAVE)
		  (FORMAT T "~4X1Unsaved source buffers for this patch:0~%~6X")
		  ;; count on formatted output to use the current cursorpos
		  (SCL:WITH-CHARACTER-STYLE ('(NIL :ITALIC NIL))
		    (SCL:FORMAT-ITEM-LIST SOURCE-BUFFERS-TO-SAVE
					  :PRINTER #'PRINC :FRESH-LINE NIL)))
		(SETQ SAVE-SOURCES
		      (DW:ACCEPT 'SCL:BOOLEAN
				 :PROMPT "      Save source buffers for this patch"
				 :DEFAULT SAVE-SOURCES)))))
	(SEND CL:*STANDARD-OUTPUT* :SET-MORE-P SAVED-MORE-P)
	(WHEN NEW-REASON-P
	  (SETF (PATCH-STATE-REASON-INTERVAL STATE)      
		(SEND (PATCH-STATE-MODE STATE)	; (determines if anything changed)
		      :PATCH-REASON (PATCH-STATE-BUFFER STATE)
		      (PATCH-STATE-REASON-INTERVAL STATE) (CREATE-INTERVAL REASON-STRING))))))
    (LIST :EDIT-COMMENT EDIT-COMMENT
	  :SEND-MAIL SEND-MAIL
	  :MAIL-ADDRESSED-TO MAIL-ADDRESSED-TO
	  :AUTHOR AUTHOR
	  :REVIEWER REVIEWER
	  :SAVE-SOURCES (AND SAVE-SOURCES SOURCE-BUFFERS-TO-SAVE)
	  :SYSTEM-DEPENDENCIES SYSTEM-DEPENDENCIES)))

(DEFVAR *PSSF-STRINGS* (LIST
			 (STRING-APPEND #\Return
				       "(SYSTEM-INTERNALS:PATCH-SECTION-SOURCE-FILE")
			 (STRING-APPEND #\Return
					"(ZL:::SYSTEM-INTERNALS:PATCH-SECTION-SOURCE-FILE")
			 (STRING-APPEND #\Return
					"(SCT:PATCH-SECTION-SOURCE-FILE")
			 (STRING-APPEND #\Return
					"(ZL:::SCT:PATCH-SECTION-SOURCE-FILE")))

(DEFUN PATCH-BUFFER-SOURCE-FILES (BUFFER)
  (DECLARE (VALUES PATHNAMES TRUENAMES))
  (LOOP WITH LAST-BP = (INTERVAL-LAST-BP BUFFER)
	FOR START-BP FIRST (INTERVAL-FIRST-BP BUFFER) THEN BP
	FOR BP = (LOOP WITH THE-BP
		       FOR PSSF-STRING IN *PSSF-STRINGS*
		       FOR A-BP = (SEARCH START-BP PSSF-STRING NIL NIL NIL LAST-BP)
		       IF (NULL THE-BP)
			 DO (SETF THE-BP A-BP)
		       ELSE IF (AND A-BP (BP-< A-BP THE-BP))
			 DO (SETF THE-BP A-BP)
		       FINALLY
			 (RETURN THE-BP))
	WHILE BP
	;; This is the version of the file which will get written when the
	;; user finally does a c-X c-S
	AS INCREMENTED-PATHNAME =
	   (SCL:WITH-STANDARD-IO-ENVIRONMENT
	     (LET* ((READTABLE (SI:READTABLE-FOR-SYNTAX (SEND BUFFER :GET :SYNTAX)))
		    (NBP (CREATE-BP (BP-LINE BP) 0))
		    (EXPR (WITH-INTERVAL-STREAM (S NBP LAST-BP T) (CL:READ S :END))))
	       (WHEN (AND (LISTP EXPR) (MEMQ (FIRST EXPR) '(SI:PATCH-SECTION-SOURCE-FILE
							    SCT:PATCH-SECTION-SOURCE-FILE))
			  (STRINGP (SECOND EXPR)))
		 (SECOND EXPR))))
	AS PATHNAME = (AND INCREMENTED-PATHNAME
			   (SEND (FS:MERGE-PATHNAMES INCREMENTED-PATHNAME *PATHNAME-DEFAULTS*)
				 :NEW-PATHNAME :VERSION :NEWEST :VC-VERSION NIL))
	WHEN (AND PATHNAME
		  (FS:PATHNAME-VC-P PATHNAME)
		  (NULL (SEND PATHNAME :VC-VERSION)))
	  DO (SETQ PATHNAME (SEND PATHNAME :NEW-VC-VERSION :NEWEST))
	;; Can't just send a :TRUENAME message to the pathname, because the new
	;; file might not be saved out yet
        AS TRUENAME = (AND INCREMENTED-PATHNAME
			   (FS:MERGE-PATHNAMES INCREMENTED-PATHNAME *PATHNAME-DEFAULTS*))
	WHEN PATHNAME
	  COLLECT PATHNAME INTO PATHNAMES
	WHEN TRUENAME
	  COLLECT TRUENAME INTO TRUENAMES
	FINALLY (RETURN (VALUES (CL:DELETE-DUPLICATES PATHNAMES)
				(CL:DELETE-DUPLICATES TRUENAMES)))))

(DEFUN PATCH-SOURCE-BUFFERS-TO-SAVE (STATE)
  (DECLARE (VALUES PATHNAMES TRUENAMES))
  (MULTIPLE-VALUE-BIND (PATHNAMES TRUENAMES)
      (PATCH-BUFFER-SOURCE-FILES (PATCH-STATE-BUFFER STATE))
    (VALUES (LOOP FOR PATHNAME IN PATHNAMES
		  AS PATH = (FS:MERGE-PATHNAMES PATHNAME *PATHNAME-DEFAULTS*)
		  AS BUFFER = (FIND-BUFFER-NAMED PATH)
		  WHEN (AND BUFFER (SEND BUFFER :MODIFIED-P :FOR-SAVING))
		    COLLECT BUFFER)
	    TRUENAMES)))

(DEFUN SAVE-SOURCES-FOR-PATCH (BUFFER-LIST)
  (LOOP FOR BUFFER IN BUFFER-LIST
	DO (SAVE-BUFFER BUFFER)))

(DEFUN INSERT-PATCH-LEVEL-DEPENDENCIES (PATCH-STATE DEPENDENCY-LIST)
  (MULTIPLE-VALUE-BIND (START-BP REMOVED-P)
      ;; Start off by removing the old forms
      (INCLUDED-PROLOGUE-START-BP
	(PATCH-STATE-BUFFER PATCH-STATE)
	'SCT:REQUIRE-PATCH-LEVEL-FOR-PATCH)
    (WHEN DEPENDENCY-LIST
      (LET ((FORM (FORMAT NIL "~@[~A~%~]~
			       (EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL)~@
			       ~2T(SCT:REQUIRE-PATCH-LEVEL-FOR-PATCH ~:{'(~A ~D. ~D.)~:^ ~}))~
			       ~A"
		    (SCT-FEATURES-PREPROCESSOR-FORM (PATCH-STATE-SYSTEM PATCH-STATE))
		    (LOOP FOR (SYS MAJ MIN) IN DEPENDENCY-LIST
			  COLLECT (LIST (SCT:SYSTEM-NAME SYS) MAJ MIN))
		    (IF REMOVED-P "" (FORMAT NIL "~3%")))))
	(INSERT START-BP FORM)))))

(DEFUN INSERT-INCLUDED-SOURCE-FILES-SECTION (PATCH-STATE SOURCE-FILES)
  (MULTIPLE-VALUE-BIND (START-BP REMOVED-P)
      ;; Start off by removing the old forms
      (INCLUDED-PROLOGUE-START-BP
	(PATCH-STATE-BUFFER PATCH-STATE)
	'SYSTEM-INTERNALS:FILES-PATCHED-IN-THIS-PATCH-FILE
	'SCT:FILES-PATCHED-IN-THIS-PATCH-FILE)
    (WHEN SOURCE-FILES
      (LET ((FORM (FORMAT NIL "~@[~A~%~]~
			       (SCT:FILES-PATCHED-IN-THIS-PATCH-FILE ~
			       ~{~%  /"~A/"~})~A"
			  (SCT-FEATURES-PREPROCESSOR-FORM (PATCH-STATE-SYSTEM PATCH-STATE))
			  SOURCE-FILES
			  (IF REMOVED-P "" (FORMAT NIL "~3%")))))
	(INSERT START-BP FORM)))))

(DEFUN INCLUDED-PROLOGUE-START-BP (BUFFER &REST FORMS-TO-REMOVE)
  (DECLARE (VALUES BP REMOVED-P))
  (LET* ((POTENTIAL-FIRST-FORM-BP
	   (LOOP FOR LINE FIRST (BP-LINE (INTERVAL-FIRST-BP BUFFER))
			  THEN (LINE-NEXT LINE)
		 WHILE (AND LINE
			    (NOT (AND (PLUSP (LINE-LENGTH LINE))
				      (CHAR= #/( (AREF LINE 0)))))
		 FINALLY (RETURN (AND LINE (CREATE-BP LINE 0)))))
	 (FIRST-FORM-BP
	   (IF (NULL POTENTIAL-FIRST-FORM-BP)
	       (INTERVAL-LAST-BP BUFFER)
	     (LOOP FOR LINE FIRST (BP-LINE POTENTIAL-FIRST-FORM-BP)
			    THEN (LINE-PREVIOUS LINE)
		   WHILE (AND LINE (NOT (ZEROP (LINE-LENGTH LINE))))
		   FINALLY (RETURN (AND LINE (CREATE-BP (LINE-NEXT LINE) 0))))))
	 (REMOVED-P NIL))
    (WHEN (AND FORMS-TO-REMOVE (NEQ FIRST-FORM-BP (INTERVAL-LAST-BP BUFFER)))
      ;; This will only remove forms up until the first patch section
      (LOOP NAMED REMOVE-FORMS
	    FOR DEFINITION = FIRST-FORM-BP THEN NEXT-DEFINITION
	    AS NEXT-DEFINITION = (FORWARD-DEFINITION (FORWARD-DEFINITION DEFINITION 2 T BUFFER)
						     -1 T BUFFER)
	    UNTIL (OR (NULL DEFINITION) (BP-= DEFINITION NEXT-DEFINITION))
	    AS CAR-FORM = (LET* ((SBP (FORWARD-CHAR DEFINITION))
				 (EBP (FORWARD-ATOM SBP)))
			    (WITH-INTERVAL-STREAM (S SBP EBP)
			      (SCL:WITH-STANDARD-IO-ENVIRONMENT
				(LET ((READTABLE (SI:READTABLE-FOR-SYNTAX
						   (SEND BUFFER :GET :SYNTAX))))
				  (CL:READ S NIL :END)))))
	    DO (WHEN (EQ CAR-FORM 'EVAL-WHEN)	; EVAL-WHEN special case: look at enclosed form
		 (LET* ((VBP (FORWARD-CHAR DEFINITION))
			(END-FORM (FORWARD-SEXP VBP 3 T 0 (INTERVAL-LAST-BP BUFFER))))
		   (UNLESS (BP-= END-FORM (INTERVAL-LAST-BP BUFFER))
		     (LET* ((FORM (FORWARD-SEXP END-FORM -1 T))
			    (SBP (FORWARD-CHAR FORM))
			    (EBP (FORWARD-ATOM SBP)))
		       (SETQ CAR-FORM (WITH-INTERVAL-STREAM (S SBP EBP)
					(CL:READ S NIL :END)))))))
	       (WHEN (MEMQ CAR-FORM '(:END
				      SI:BEGIN-PATCH-SECTION
				      SI:PATCH-SECTION-SOURCE-FILE
				      SI:PATCH-SECTION-ATTRIBUTES
				      SCT:BEGIN-PATCH-SECTION
				      SCT:PATCH-SECTION-SOURCE-FILE
				      SCT:PATCH-SECTION-ATTRIBUTES))
		 (RETURN-FROM REMOVE-FORMS NIL))
	       (WHEN (MEMQ CAR-FORM FORMS-TO-REMOVE)
		 ;; Remove a single conditional (#+/#-) in addition to the form which 
		 ;; we've been asked to remove as we may have added it when we first
		 ;; inserted the form.
		 (LET* ((PRIOR-BP (FORWARD-LINE DEFINITION -1))
			(START-BP (IF (AND PRIOR-BP
					   (CHAR-EQUAL #\# (BP-CHAR PRIOR-BP)))
				      PRIOR-BP
				      DEFINITION))
			(END-BP (FORWARD-SEXP DEFINITION)))
		   (SETQ FIRST-FORM-BP START-BP
			 REMOVED-P T)
		   (KILL-INTERVAL START-BP END-BP T T)))))
    (VALUES FIRST-FORM-BP REMOVED-P)))

;;;All the actions involved with finishing a patch.  Returns NIL if everything OK;
;;;returns T or something if a problem was encountered and patch couldn't be finished
(DEFUN FINISH-PATCH-INTERNAL (PATCH-STATE)
  (LET* ((EXISTING-REASON (PATCH-STATE-REASON-INTERVAL PATCH-STATE))
	 (REASON-STRING (UNCOMMENTED-STRING-FROM-INTERVAL EXISTING-REASON))
	 (REASON-P (PLUSP (STRING-LENGTH REASON-STRING)))
	 (FINISH-NOW T))
    (WHEN (PATCH-STATE-SPLIT-WINDOW-BUFFER PATCH-STATE)
      (PATCH-EDIT-IN-PROGRESS-BARF PATCH-STATE))
    (LET ((FINISH-PATCH-OPTIONS (GATHER-FINISH-PATCH-OPTIONS PATCH-STATE REASON-STRING)))
      (FLET ((FP-OPTION (KEYWORD) (CL:GETF FINISH-PATCH-OPTIONS KEYWORD)))
	(LET ((AUTHOR (FP-OPTION :AUTHOR)))
	  (WHEN (AND (STRINGP AUTHOR) (NOT (STRING-EQUAL AUTHOR "")))
	    (SETF (PATCH-STATE-AUTHOR PATCH-STATE) AUTHOR)))
	(SETF (PATCH-STATE-REVIEWER PATCH-STATE) (FP-OPTION :REVIEWER))
	(INSERT-PATCH-LEVEL-DEPENDENCIES PATCH-STATE (FP-OPTION :SYSTEM-DEPENDENCIES))
	(MULTIPLE-VALUE-BIND (NIL SOURCE-FILES)
	    (PATCH-SOURCE-BUFFERS-TO-SAVE PATCH-STATE)
	  (INSERT-INCLUDED-SOURCE-FILES-SECTION PATCH-STATE SOURCE-FILES))
	(SETF (PATCH-STATE-FINISH-OPTIONS PATCH-STATE) FINISH-PATCH-OPTIONS)
	(SETQ EXISTING-REASON (PATCH-STATE-REASON-INTERVAL PATCH-STATE)) ;may have changed
	(SETQ REASON-STRING (UNCOMMENTED-STRING-FROM-INTERVAL EXISTING-REASON))
	(WHEN (FP-OPTION :EDIT-COMMENT)
	  (EDIT-PATCH-DESCRIPTION-IN-SPLIT-WINDOW
	    REASON-STRING
	    (IF REASON-P "Revise comments (end with End)"
	      "Description of changes: (end with End)")
	    PATCH-STATE T)
	  (SETQ FINISH-NOW NIL))))
    (WHEN FINISH-NOW
      (CONTINUE-FINISH-PATCH-INTERNAL PATCH-STATE))))

;;; Called either by FINISH-PATCH-INTERNAL in minibuffer mode, or
;;; by COM-EXIT-PATCH-DESCRIPTION-EDIT in patch-description-window mode
(DEFUN CONTINUE-FINISH-PATCH-INTERNAL (PATCH-STATE)
  (LET* ((BUFFER (PATCH-STATE-BUFFER PATCH-STATE))
	 (PUNT-PATCH NIL))
    (LOOP FOR MESSAGE IN (PATCH-STATE-FINISH-ACTIONS PATCH-STATE)	;note: can happen
	  DO (SEND (PATCH-STATE-MODE PATCH-STATE) MESSAGE BUFFER))	;more than once
    (SETF (PATCH-STATE-SPLIT-WINDOW-BUFFER PATCH-STATE) NIL)	        ;done editing, now
    (COND ((CONSUMMATE-PATCH PATCH-STATE)	;used to take out reason, no reason to do that
	   (SETQ PUNT-PATCH T)
	   (TYPEIN-LINE "Patch not finished."))
	  (T (IF (CL:GETF (PATCH-STATE-FINISH-OPTIONS PATCH-STATE) :SAVE-SOURCES)
		 (SAVE-SOURCES-FOR-PATCH
		   (CL:GETF (PATCH-STATE-FINISH-OPTIONS PATCH-STATE) :SAVE-SOURCES))
	       (WHEN (PATCH-SOURCE-BUFFERS-TO-SAVE PATCH-STATE)
		 (TYPEIN-LINE "Don't forget to save your files!")))))
    ;;Following was supplied by MMcM to get around fact that selection blips (due to using 
    ;;fquery, in the prompts) keep the redisplay from happening so typeout stays.
    (LET ((TEM (SEND STANDARD-INPUT :TYI-NO-HANG)))
      (UNLESS (OR (NULL TEM)
		  (AND (LISTP TEM) (EQ (FIRST TEM) 'SELECT-WINDOW)))
	(SEND STANDARD-INPUT :UNTYI TEM)))
    (UNLESS PUNT-PATCH
      (SEND STANDARD-OUTPUT :MAKE-COMPLETE))	;avoid having the patch comment hanging around
    PUNT-PATCH))

;;; Provide a way to edit the patch comment in a window without finishing the patch
(DEFCOM COM-EDIT-PATCH-COMMENT "Edit the description comment for the current patch.

With a numeric argument, continue to edit the existing contents of the
patch-description editing buffer.  (This is useful in case you aborted a
patch-comment edit by mistake.)" ()
  (UNLESS *CURRENT-PATCH*
    (BARF "No patch in progress."))
  (WHEN (PATCH-STATE-SPLIT-WINDOW-BUFFER *CURRENT-PATCH*)
    (PATCH-EDIT-IN-PROGRESS-BARF *CURRENT-PATCH*))
  (LET* ((BUFFER (PATCH-STATE-BUFFER *CURRENT-PATCH*))
	 (EXISTING-REASON (PATCH-STATE-REASON-INTERVAL *CURRENT-PATCH*))
	 (REASON-STRING (IF *NUMERIC-ARG-P* :USE-EXISTING
			  (UNCOMMENTED-STRING-FROM-INTERVAL EXISTING-REASON)))
	 (INFO-STRING (COND ((NOT (STRINGP REASON-STRING)) "Continue revising comments")
			    ((PLUSP (STRING-LENGTH REASON-STRING)) "Revise comments")
			    (T "Description of changes"))))
    (EDIT-PATCH-DESCRIPTION-IN-SPLIT-WINDOW
      REASON-STRING
      (IF (PRIVATE-PATCH-P *CURRENT-PATCH*)
	  (FORMAT NIL "~A for private patch file ~A (end with End)"
		  INFO-STRING (SEND BUFFER ':PATHNAME))
	(FORMAT NIL "~A for patch file for version ~D.~D of ~A (end with End)"
		INFO-STRING (PATCH-STATE-MAJOR-VERSION *CURRENT-PATCH*)
		(PATCH-STATE-MINOR-VERSION *CURRENT-PATCH*)
		(PATCH-STATE-SYSTEM-NAME *CURRENT-PATCH*)))
      *CURRENT-PATCH* NIL))
  DIS-ALL)

(DEFUN PATCH-EDIT-IN-PROGRESS-BARF (PATCH-STATE)
  (BARF "There is already a patch-comment edit in progress for the patch in the buffer~@
         ~2T~A.~@
         Please~:[ select ~A and~] finish or abort the edit."
	(PATCH-STATE-BUFFER PATCH-STATE)
	(EQL *INTERVAL* (PATCH-STATE-SPLIT-WINDOW-BUFFER PATCH-STATE))
	(PATCH-STATE-SPLIT-WINDOW-BUFFER PATCH-STATE)))

;;; Make a mixin for a patch-description special purpose buffer
(DEFFLAVOR PATCH-DESCRIPTION-EDITING-MIXIN
	((INITIAL-BODY NIL)
	 (PATCH-STATE NIL)
	 (FINISHING-PATCH-P NIL))
	()
  :SETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:REVERT PATCH-DESCRIPTION-EDITING-MIXIN) ()
  (SETQ *STYLE* 0
	*STYLE-NAME* NIL)
  (UNLESS (EQL INITIAL-BODY :USE-EXISTING)
    (DELETE-INTERVAL SELF)
    (INSERT (SEND SELF :POINT) INITIAL-BODY)))

;;; The :EXIT-SPECIAL-BUFFER method flushes the point PDL which tries to turn the patch
;;; description buffer into a read-only buffer.  If we allow this to happen, we won't be
;;; able to patch comments any longer.
(DEFMETHOD (:SET-READ-ONLY PATCH-DESCRIPTION-EDITING-MIXIN) ()
  NIL)

(DEFMETHOD (:BUFFER-INIT-OPTIONS PATCH-DESCRIPTION-EDITING-MIXIN) ()
  '(:SET-INITIAL-BODY :SET-PATCH-STATE :SET-FINISHING-PATCH-P))

;;; Define the patch-description special purpose buffer type
(DEFINE-SPECIAL-BUFFER-TYPE PATCH-DESCRIPTION-EDITING-BUFFER
			    ()
			    (PATCH-DESCRIPTION-EDITING-MIXIN
			     DESCRIPTION-ENCACHING-SPECIAL-PURPOSE-BUFFER
			     SPECIAL-PURPOSE-BUFFER-WITH-TICK)
			    :PATCH-DESCRIPTION "Patch-Description"
  (:BUFFER-INIT-OPTIONS :SET-INITIAL-BODY :SET-PATCH-STATE :SET-FINISHING-PATCH-P))

;;; The corresponding minor mode for editing patch descriptions (Text is major mode)
(DEFMINOR COM-PATCH-DESCRIPTION-MODE PATCH-DESCRIPTION-MODE "Patch Description" 1
	  "Setup for editing patch-file description" ()
  (SET-COMTAB *MODE-COMTAB* '(#\C-ALTMODE COM-EXIT-PATCH-DESCRIPTION-EDIT
			      #\END COM-EXIT-PATCH-DESCRIPTION-EDIT
			      #\ABORT COM-ABORT-PATCH-DESCRIPTION-EDIT
			      #\C-Z COM-ABORT-PATCH-DESCRIPTION-EDIT
			      #\C-] COM-ABORT-PATCH-DESCRIPTION-EDIT))
  ;; This FORMAT is here to dynamically figure out how to type the character
  (SETQ *MODE-LINE-LIST*
	`(,@*MODE-LINE-LIST* ,(FORMAT NIL "     ~:@C finishes edit, ~:@C aborts"
				      #\END #\ABORT))))

(DEFCOM COM-EXIT-PATCH-DESCRIPTION-EDIT 
	"Ends the edit of the patch description comment, and continues finishing the patch."
	()
  (UNLESS (SEND *INTERVAL* :PATCH-STATE)
    (BARF "There is no patch description edit active for this patch-description buffer."))
  (LET* ((PATCH-STATE (SEND *INTERVAL* :PATCH-STATE))
	 (EXISTING-REASON (PATCH-STATE-REASON-INTERVAL PATCH-STATE))
	 (FINISHING-PATCH-P (SEND *INTERVAL* :FINISHING-PATCH-P)))
    (SEND (PATCH-STATE-MODE PATCH-STATE)	; (determines if anything changed)
	  :PATCH-REASON (PATCH-STATE-BUFFER PATCH-STATE)
	  EXISTING-REASON *INTERVAL*)
    (SEND *INTERVAL* :SET-PATCH-STATE NIL)
    (SEND *CURRENT-COMMAND-LOOP* :EXIT-SPECIAL-BUFFER T)
    (IF FINISHING-PATCH-P
	(CONTINUE-FINISH-PATCH-INTERNAL PATCH-STATE)
      (RESTORE-PRE-PATCH-COMMENT-WINDOW-CONFIGURATION PATCH-STATE)))
  DIS-ALL)

;;--- Perhaps this should not use the kill-ring, but should just mention that
;;--- the *Patch-Description-1n0* buffer has the aborted patch comment.
(DEFCOM COM-ABORT-PATCH-DESCRIPTION-EDIT 
	"Aborts the edit of the patch description comment, and abondons finishing the patch."
	()
  (LET ((PATCH-STATE (SEND *INTERVAL* :PATCH-STATE)))
    (UNLESS PATCH-STATE
      (BARF "There is no patch description edit active for this patch-description buffer."))
    (LET ((*LAST-COMMAND-TYPE* NIL))		; prevent it from merging with the last kill
      (KILL-RING-SAVE-INTERVAL (INTERVAL-FIRST-BP *INTERVAL*) (INTERVAL-LAST-BP *INTERVAL*) T))
    (TYPEIN-LINE "Aborting edit of patch comment; ~
                  continue the edit with c-U m-X Edit Patch Comment.~@
                  The edited comment has also been saved on the kill ring.")
    (SEND *INTERVAL* :SET-PATCH-STATE NIL)
    (SEND *CURRENT-COMMAND-LOOP* :EXIT-SPECIAL-BUFFER T)
    (RESTORE-PRE-PATCH-COMMENT-WINDOW-CONFIGURATION PATCH-STATE))
  DIS-ALL)

(DEFVAR *PATCH-DESCRIPTION-WINDOW-SIZE* 0.65	;a fixnum of lines, or a fraction 0 < f < 1
  "An integer number of lines or a proportioning fraction, 0 < frac < 1")
;;; Split the screen with the patch-description buffer on the top, and selected.
(DEFUN EDIT-PATCH-DESCRIPTION-IN-SPLIT-WINDOW (INITIAL-CONTENTS TYPEIN-LINE-INFO PATCH-STATE
					       FINISHING-PATCH-P)
  (LET ((PATCH-COMMENT-BUFFER
	  (SEND *CURRENT-COMMAND-LOOP* :FIND-SPECIAL-BUFFER
		:PATCH-DESCRIPTION T :SET-INITIAL-BODY INITIAL-CONTENTS
		:SET-PATCH-STATE PATCH-STATE :SET-FINISHING-PATCH-P FINISHING-PATCH-P))
	(P-D-WINDOW-SIZE
	  (LET ((WINDOW-LINES
		  (MULTIPLE-VALUE-BIND (NIL TOP NIL BOTTOM)
		      (SEND (WINDOW-FRAME *WINDOW*) :INSIDE-EDGES-WITHOUT-MODE-LINE-WINDOW)
		    (TRUNCATE (- BOTTOM TOP)
			      (TV:SHEET-LINE-HEIGHT (WINDOW-SHEET *WINDOW*))))))	
	    (TRUNCATE
	      (MIN (- WINDOW-LINES 5)
		   (MAX 5 (IF ( 1 *PATCH-DESCRIPTION-WINDOW-SIZE*)
			      *PATCH-DESCRIPTION-WINDOW-SIZE*
			    (* *PATCH-DESCRIPTION-WINDOW-SIZE* WINDOW-LINES))))))))
    (SETF (PATCH-STATE-SPLIT-WINDOW-PRIOR-WINDOW-STATE PATCH-STATE)
	  (ZMACS-WINDOW-STATE))
    (MULTIPLE-VALUE-BIND (TOP-WINDOW BOTTOM-WINDOW)
	(FUNCALL (WINDOW-FRAME *WINDOW*) ':TWO-EDITOR-WINDOWS)
      (AND (EQ TOP-WINDOW *WINDOW*)
	   (PSETQ TOP-WINDOW BOTTOM-WINDOW BOTTOM-WINDOW TOP-WINDOW))
      (SETQ BOTTOM-WINDOW
	    (SEND (FIRST (FIRST (PATCH-STATE-SPLIT-WINDOW-PRIOR-WINDOW-STATE PATCH-STATE)))
		  :ZWEI-WINDOW))
      (SPLIT-SCREEN-BETWEEN-TWO-WINDOWS TOP-WINDOW BOTTOM-WINDOW P-D-WINDOW-SIZE)
      (SET-WINDOW-BUFFER TOP-WINDOW PATCH-COMMENT-BUFFER)
      (SETF (PATCH-STATE-SPLIT-WINDOW-BUFFER PATCH-STATE) PATCH-COMMENT-BUFFER)
      (RECENTER-WINDOW TOP-WINDOW ':START (WINDOW-START-BP TOP-WINDOW))
      (MOVE-BP (WINDOW-POINT TOP-WINDOW) (WINDOW-START-BP TOP-WINDOW))
      (SEND *ZMACS-COMMAND-LOOP* ':MAKE-WINDOW-CURRENT TOP-WINDOW)
      (LET ((*SET-ATTRIBUTE-UPDATES-LIST* NIL))
	(TURN-OFF-MODE (MODE-OF-FLAVOR 'FUNDAMENTAL-MODE))	;---crock to fix mode-sw bug
	(COM-TEXT-MODE))
      (TURN-ON-MODE 'PATCH-DESCRIPTION-MODE)
      (REDISPLAY BOTTOM-WINDOW)
      ;; Since the patch comment was displayed, there is typeout in the typeout
      ;; window.  There is also a (REDISPLAY) blip in the typeahead which will suppress the
      ;; kind of redisplay that gets rid of the typeout window if we don't flush it.  This
      ;; is a total crock to make up for the lack of a coherent selection theory, rooted in
      ;; the absence of an activity system.
      (FUNCALL *TYPEOUT-WINDOW* ':MAKE-COMPLETE)
      (TYPEIN-LINE-DURABLE TYPEIN-LINE-INFO)
      (TV:PROCESS-TYPEAHEAD (SEND *ZMACS-COMMAND-LOOP* :IO-BUFFER)
			    #'(LAMBDA (CH)
				(IF (AND (LISTP CH)
					 (MEMQ (CAR CH)
					       '(CONFIGURATION-CHANGED REDISPLAY
								       SELECT-WINDOW)))
				    NIL CH)))
      NIL)))

(DEFUN RESTORE-PRE-PATCH-COMMENT-WINDOW-CONFIGURATION (PATCH-STATE)
  (WHEN (PATCH-STATE-SPLIT-WINDOW-PRIOR-WINDOW-STATE PATCH-STATE)
    (RESTORE-ZMACS-WINDOW-STATE (PATCH-STATE-SPLIT-WINDOW-PRIOR-WINDOW-STATE PATCH-STATE))
    (SETF (PATCH-STATE-SPLIT-WINDOW-BUFFER PATCH-STATE) NIL)
    (SETF (PATCH-STATE-SPLIT-WINDOW-PRIOR-WINDOW-STATE PATCH-STATE) NIL)))

;;; Protocol for saving and restoring the multi-window configuration of Zmacs,
;;; for use around operatiosn like split-window patch-description editing, which
;;; change the window configuration.  We store the specs of an arbitrary
;;; multi-window setup:  '((<window> <left> <top> <right> <bottom> <buffer>) ...),
;;; where the first spec in the list is for the selected window.  The saved
;;; edge coordinates are normalized re frame inside-size, to protect against
;;; unwise resizing of the frame.
(DEFUN ZMACS-WINDOW-STATE ()
  (LET* ((FRAME (WINDOW-FRAME *WINDOW*))
	 (DESC-LIST
	   (MULTIPLE-VALUE-BIND (FRAME-LEFT FRAME-TOP FRAME-RIGHT FRAME-BOTTOM)
	       (SEND FRAME :INSIDE-EDGES-WITHOUT-MODE-LINE-WINDOW)
	     (LOOP WITH MODE-LINE-WINDOW = (SEND FRAME :MODE-LINE-WINDOW)
		   AND FRAME-HEIGHT = (1+ (- FRAME-BOTTOM FRAME-TOP))
		   AND FRAME-WIDTH = (1+ (- FRAME-RIGHT FRAME-LEFT))
		   FOR W IN (SEND FRAME :EXPOSED-INFERIORS)
		   UNLESS (EQ W MODE-LINE-WINDOW)
		     COLLECT (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
				 (SEND W :EDGES)
			       (LIST W (CL:// LEFT FRAME-WIDTH) (CL:// TOP FRAME-HEIGHT)
				     (CL:// RIGHT FRAME-WIDTH) (CL:// BOTTOM FRAME-HEIGHT)
				     (WINDOW-INTERVAL (SEND W :ZWEI-WINDOW)))))))
	 (N (LOOP FOR (W) IN (CDR DESC-LIST)
		  FOR I UPFROM 1
		  WHEN (EQ *WINDOW* (SEND W :ZWEI-WINDOW))
		    DO (RETURN I)
		  FINALLY (RETURN NIL))))
    (UNLESS (NULL N)
      (SWAPF (NTH N DESC-LIST) (FIRST DESC-LIST)))
    DESC-LIST))

(DEFUN RESTORE-ZMACS-WINDOW-STATE (SAVED-STATE)
  (COND
    ((EQL (LENGTH SAVED-STATE) 1)		; one window
     (TV:DELAYING-SCREEN-MANAGEMENT
       (DESTRUCTURING-BIND (W ZW NIL NIL NIL BUF) (FIRST SAVED-STATE)
	 (SETQ ZW (SEND W :ZWEI-WINDOW))
	 (SEND W :DEEXPOSE)
	 (SET-WINDOW-BUFFER ZW BUF)
	 (SEND W :SELECT-RELATIVE)
	 (MAKE-WINDOW-CURRENT ZW)
	 (MAKE-BUFFER-CURRENT BUF)
	 (MAKE-WINDOW-FULL-SCREEN ZW))))
     (T						; two or more windows
       (LET ((FRAME (WINDOW-FRAME (SEND (FIRST (FIRST SAVED-STATE)) :ZWEI-WINDOW))))
	 (TV:DELAYING-SCREEN-MANAGEMENT
	 (MULTIPLE-VALUE-BIND (FRAME-LEFT FRAME-TOP FRAME-RIGHT FRAME-BOTTOM)
	     (SEND FRAME :INSIDE-EDGES-WITHOUT-MODE-LINE-WINDOW)
	   (LOOP WITH FRAME-HEIGHT = (1+ (- FRAME-BOTTOM FRAME-TOP))
		 AND FRAME-WIDTH = (1+ (- FRAME-RIGHT FRAME-LEFT))
		 FOR (W LEFT TOP RIGHT BOTTOM BUF) IN SAVED-STATE
		 AS ZW = (SEND W :ZWEI-WINDOW)
		 AS FIRST FIRST T THEN NIL
		 DO (SEND W :DEEXPOSE)
		    (SEND W :SET-EDGES
			  (CEILING (* FRAME-WIDTH LEFT)) (CEILING (* FRAME-HEIGHT TOP))
			  (FLOOR (* FRAME-WIDTH RIGHT)) (FLOOR (* FRAME-HEIGHT BOTTOM)))
		    (SEND W :EXPOSE NIL :CLEAN)
		    (SET-WINDOW-BUFFER ZW BUF)
		 WHEN FIRST
		   DO (SEND W :SELECT-RELATIVE)
		      (MAKE-WINDOW-CURRENT ZW)
		      (MAKE-BUFFER-CURRENT BUF))))))))

(DEFCOM COM-ADD-PATCH-COMMENT
	"Add a comment to the current patch" ()
  (UNLESS *CURRENT-PATCH*
    (BARF "No patch in progress."))
  (ADD-PATCH-COMMENT *CURRENT-PATCH* NIL NIL)
  DIS-NONE)

;;;Returns non-nil if user got warnings and wants to punt the patch.  Otherwise
;;;it cleans up properly and returns NIL.
(DEFUN CONSUMMATE-PATCH (STATE &OPTIONAL (WARNINGS-STREAM *TYPEOUT-WINDOW*))
  (DECLARE (SPECIAL *ZMAIL-WINDOW*))
  (UNLESS STATE					;would happen only for *current-patch*
    (BARF "Patch not in progress, cannot finish it."))
  (LET (SEND-MAIL-ABOUT-PATCH
	PUNT)
    (UNWIND-PROTECT
	(SETQ SEND-MAIL-ABOUT-PATCH
	      (COND ((NOT (VARIABLE-BOUNDP *ZMAIL-WINDOW*)) NIL)
		    (T (CL:GETF (PATCH-STATE-FINISH-OPTIONS STATE) :SEND-MAIL)))
	      PUNT
	      (PROGN
		(LET ((BUFFER (PATCH-STATE-BUFFER STATE)))
		  (WHEN (SEND BUFFER :MODIFIED-P)
		    (UNLESS (SAVE-BUFFER-IF-NECESSARY BUFFER)	;NIL if problems saving
		      (RESTORE-PRE-PATCH-COMMENT-WINDOW-CONFIGURATION STATE)
		      (BARF "Not finishing the patch now.")))
		  (MUST-REDISPLAY-OTHER-WINDOWS BUFFER NIL DIS-TEXT))
		(LET ((SCT:*COMPILING-FOR-REQUIRE-PATCH-LEVEL* T)
		      (SCT:*IGNORE-REQUIRED-LEVEL-FOR-COMPILE* NIL)
		      (SCT:*IGNORE-REQUIRED-LEVEL-FOR-SYSTEMS* '()))
		  (LOOP NAMED CONSUMMATE DO
		    (CATCH 'SCT:SKIP-CURRENT-SYSTEM
		      (RETURN-FROM CONSUMMATE
			(IF (EQ (PATCH-STATE-SYSTEM STATE) :PRIVATE)
			    (CONSUMMATE-PRIVATE-PATCH STATE WARNINGS-STREAM)
			  (CONDITION-BIND
			    ((SCT:PATCHES-NOT-LOADED-FOR-SYSTEM
			       #'(LAMBDA (C)
				   (WHEN (DBG:PROCEED-TYPE-P C :NO-ACTION)
				     (LET ((SYS (SCT:PATCHES-NOT-LOADED-FOR-SYSTEM-SYSTEM C))
					   (MAJ (SCT:PATCHES-NOT-LOADED-FOR-SYSTEM-MAJOR C)))
				       (WHEN (SCT:QUERY-ABOUT-UNLOADED-PATCHES-FOR-SYSTEM
					       SYS MAJ)
					 (PUSH SYS SCT:*IGNORE-REQUIRED-LEVEL-FOR-SYSTEMS*)
					 (DBG:PROCEED C :NO-ACTION)))))))
			    (SCT:CONSUMMATE-PATCH
			      (PATCH-STATE-MAKE-SYSTEM-INFO STATE)
			      (PATCH-STATE-MINOR-VERSION STATE)
			      (UNCOMMENTED-STRING-FROM-INTERVAL
				(PATCH-STATE-REASON-INTERVAL STATE))
			      (PATCH-STATE-AUTHOR STATE)
			      (PATCH-STATE-REVIEWER STATE)
			      WARNINGS-STREAM)))))
		    (DBG:WITH-EXTRA-DEBUGGER-MENU-CONDITIONS (CLI::DEFAULT-ERROR)
		      (CL:CERROR "Ignore the required patch level and compile anyway"
				 "Your environment is not up to the patch level required ~
                                  in this patch file."))
		    (SETQ SCT:*IGNORE-REQUIRED-LEVEL-FOR-COMPILE* T)))))
      (RESTORE-PRE-PATCH-COMMENT-WINDOW-CONFIGURATION STATE))
    (UNLESS PUNT				;give up as result of bad compilation
      (UNWIND-PROTECT				;be alert to aborting out of mail
	  (WHEN SEND-MAIL-ABOUT-PATCH (PATCH-MAIL STATE))
	(WITHOUT-INTERRUPTS			;clean up states to reflect being done
	  (SETF (PATCH-STATE-STATE STATE) :FINISHED)
	  (WHEN (EQ STATE *CURRENT-PATCH*)	;current patch finished, pick new one
	    (IF (NEW-CURRENT-PATCH)
		(TYPEIN-LINE-DURABLE "Current system to patch is now ~A"
				     (PATCH-STATE-DESCRIPTION *CURRENT-PATCH*))
	      (TYPEIN-LINE-DURABLE "No more patches in progress"))))))
    PUNT))

;;;Internal function called by consummate-patch
;;;---Still need to figure out how to do generic compiling ticks.
(DEFUN CONSUMMATE-PRIVATE-PATCH (STATE &OPTIONAL WARNINGS-STREAM)
  (LET ((PATHNAME (SEND (PATCH-STATE-BUFFER STATE) ':PATHNAME))
	(TICK COMPILER:NEW-COMPILER-WARNINGS-TICK)
	(COMPILE-FUNCTION (SEND (PATCH-STATE-MODE STATE) :COMPILE-TO-FILE-FUNCTION)))
    (COND (COMPILE-FUNCTION
	   (FUNCALL COMPILE-FUNCTION PATHNAME)
	   (AND ( TICK COMPILER:NEW-COMPILER-WARNINGS-TICK)	;---needs to be generic
		(LET ((QUERY-IO WARNINGS-STREAM))
		  (NOT (YES-OR-NO-P "Do you still want to finish the patch? ")))))
	  (T (TYPEIN-LINE "No compiler function so no binary file being produced.")))))

(DEFVAR *P-M-F-START* #.(FORMAT NIL "2General purpose of patch:0~2%"))
(DEFVAR *PATCH-MAIL-FRAMEWORK*
	2"Patch file:0 ~A

2Technical reviewer:0 ~A

2General purpose of patch:



General method of approach:



System areas0 2affected:



Risks and additional areas affected if something goes wrong:



Incompatible changes to user interface or calling sequence:
0  1[Does the patch maintain binary-file0 1compatibility0 1if
0  1needed?0  1Remember that a previously working0 1binary0 1file
0  1must load0 1without errors and work without change in a
0  1newer0 1minor0 1release.]



2Does this patch fix any bug(s) that exist
0 2in the current0 2Released version of the software?:

Documentation impact:



Text of patch comment:

0~A

2Method and0 2result of testing:


0")

(DEFVAR *PATCH-MAIL-FRAMEWORK-EXAMPLE*
	"                1[Filled-in example of patch mail]
0To: System-Changes
Subject: Modernizing and extending editor mail
File-References: SCRC|Y:>dodds>pending>patch-reviewer-stuff.lisp
--Text follows this line--

2Patch file:0 Q:>rel-7>sys>patch>system-350>system-350-52.lisp

2Technical reviewer:0 Moon and others

2General purpose of patch:

0 Editor mail has been an inflexible mess.  Various functions have had
 endless optional args added at various times, to kludge new features.
 And it still wasn't possible to provide initial contents for any headers
 except To: and Subject:.

2General method of approach:

0 As noted above in patch comment: reimplement using keyword arglists, and
 add a means to specify INITIAL-OTHER-HEADERS.

2System areas0 2affected:

0 All uses of editor mail.

2Risks and additional areas affected if something goes wrong:

0 There may be layered products or user software that use some of the changed
 undocumented interfaces, such as ZWEI:COM-MAIL-INTERNAL.  They will be broken
 by this, and will have to be converted.

2Incompatible changes to user interface or calling sequence:
0  1[Does the patch maintain binary-file0 1compatibility0 1if
0  1needed?0  1Remember that a previously working0 1binary0 1file
0  1must load0 1without errors and work without change in a
0  1newer0 1minor0 1release.]

0 None to anything documented or /"top level/" enough to be appropriate for
 customer code.

2Does this patch fix any bug(s) that exist
0 2in the current0 2Released version of the software?:0  Yes.

2Documentation impact:

0 None; the revamped functions are all undocumented.

2Text of patch comment:

0  *** Editor mail support for including arbitrary initial headers in an editor
      mail draft.  Still needs some interface for furnishing personal canned headers, etc.
 Function ZWEI:COM-MAIL-INTERNAL:  Reimplement the interface, so that all
  ...
 Function ZWEI:PATCH-MAIL:  Another caller of COM-MAIL-INTERNAL.

2Method and0 2result of testing:

0 Extensively tested by running all clients of the editor mail substrate:
  ...
 and has been in use by all in-house users for two months.
1               0  1[End of filled-in example.]
0")

#||
(DEFVAR *S-P-M-F-START* #.(FORMAT NIL "2General purpose of patch:0~2%"))
(DEFVAR *SIMPLE-PATCH-MAIL-FRAMEWORK*
	2"Patch file:0 ~A

2General purpose of patch:



General method of approach:



Incompatible changes to behavior and interfaces:



Documentation impact:



Text of patch comment:

0~A
")
||#

(DEFCOM COM-SHOW-PATCH-MAIL-EXAMPLE
	"Display a filled-in example of the patch mail outline." ()
  (FORMAT T *PATCH-MAIL-FRAMEWORK-EXAMPLE*)
  DIS-NONE)

(DEFUN PATCH-MAIL (STATE)
  (LET* ((SYSTEM (IF (EQ (PATCH-STATE-SYSTEM STATE) :PRIVATE)
		     NIL (PATCH-STATE-SYSTEM STATE)))
	 (SYSTEM-DESTINATION (IF SYSTEM
				 (AND (STRINGP (SCT:SYSTEM-PATCHES-REVIEWED SYSTEM))
				      (SCT:SYSTEM-PATCHES-REVIEWED SYSTEM))
			       ;; if there's a reviewer, should be default recip. for Private
			       (PATCH-STATE-REVIEWER STATE)))
	 (DESTINATION-DEFAULT (OR SYSTEM-DESTINATION
				  (WHEN SYSTEM
				    (OR *SYSTEM-CHANGES-DESTINATION*
					*DOC-CHANGES-DESTINATION*))))
	 (DESTINATION (OR (CL:GETF (PATCH-STATE-FINISH-OPTIONS STATE)
				   :MAIL-ADDRESSED-TO)
			  (TYPEIN-LINE-ACCEPT 'SCL:STRING
					      :DEFAULT DESTINATION-DEFAULT
					      :PROMPT "Report changes to"))))
    (OR (STRING-SEARCH-NOT-SET '(#\SPACE #\TAB) DESTINATION)
	(SETQ DESTINATION DESTINATION-DEFAULT))
    (OR (NETI:ALL-MAIL-ADDRESSES-FORWARD-AT-SITE NET:*LOCAL-SITE*)
	(AND DESTINATION
	     (SETQ DESTINATION (STRING-APPEND DESTINATION #/@ *HOST-FOR-BUG-REPORTS*))))
    (PATCH-MAIL-INTERNAL STATE DESTINATION)))

;;; Hook for Patch-review-like function, should eventually call into COM-MAIL-INTERNAL;
;;; called with args (TO-ADDRESS FILE-LIST REVIEWER PATCH-STATE); should return
;;; NIL if it decides not to do the mail-creation, non-NIL if it does.
(DEFVAR *PATCH-MAIL-ALTERNATIVE-FUNCTION* NIL
  "Hook for a different patch mail formatter/template mediator, such as Patch-Review mail.")

(DEFVAR *REVIEWER-TOKEN-SEPARATORS* '(#\SPACE #/. #/, #/? #/!))

(DEFUN TOKENIZE-REVIEWER-NAMELIST (STRING)
  (MACROLET ((ADD-WORD (WVAR SVAR)
	       `(WHEN ,WVAR
		  (PUSH (CL:COERCE (NREVERSE ,WVAR) 'STRING) ,SVAR)
		  (SETQ ,WVAR NIL))))
    (LET ((WORD '()) (SENTENCE '()))
      (DOTIMES (I (STRING-LENGTH STRING))
	(LET ((CHAR (AREF STRING I)))
	  (IF (CL:MEMBER CHAR *REVIEWER-TOKEN-SEPARATORS* :TEST #'CL:CHAR-EQUAL)
	      (ADD-WORD WORD SENTENCE)
	      (PUSH CHAR WORD))))
      (ADD-WORD WORD SENTENCE)
      (NREVERSE SENTENCE))))

(DEFVAR *REVIEWER-NOISE-WORDS* '("PLEASE" "PERHAPS" "MAYBE" "ETC" "OR" "AND" "ALSO"))

(DEFUN BUILD-REVIEWER-NAMELIST (STRING)
  (LET ((NAMES
	  (CL:REMOVE-IF #'(LAMBDA (WORD)
			    (CL:MEMBER WORD *REVIEWER-NOISE-WORDS*
				       :TEST #'STRING-EQUAL))
			(TOKENIZE-REVIEWER-NAMELIST STRING))))
    (LOOP FOR NAME IN NAMES
	  COLLECT `(:NAME ,NAME))))

#|| ;e.g.,

(ZWEI:BUILD-REVIEWER-NAMELIST "kmp, cstacy")
(ZWEI:BUILD-REVIEWER-NAMELIST "dodds and kmp")
(ZWEI:BUILD-REVIEWER-NAMELIST "moon, please.  or maybe dodds?")
(ZWEI:BUILD-REVIEWER-NAMELIST "hornig and swm. also ellen!")

||#

(DEFUN PATCH-MAIL-INTERNAL (STATE DESTINATION)
  (LET* ((PATH (SEND (PATCH-STATE-BUFFER STATE) :PATHNAME))
	 (REVIEWER (PATCH-STATE-REVIEWER STATE)))
    (SEND *TYPEIN-WINDOW* ':TYPEOUT-STAYS)
    (UNLESS (AND (FUNCTIONP *PATCH-MAIL-ALTERNATIVE-FUNCTION*)
		 (FUNCALL *PATCH-MAIL-ALTERNATIVE-FUNCTION*
			  DESTINATION (LIST PATH) REVIEWER STATE))
      (LET* ((REASON (UNCOMMENTED-STRING-FROM-INTERVAL (PATCH-STATE-REASON-INTERVAL STATE)))
	     (INITIAL-BODY (FORMAT NIL *PATCH-MAIL-FRAMEWORK* PATH
				   (OR REVIEWER "None") REASON))
	     (START-STRING *P-M-F-START*)
	     (INITIAL-INDEX (+ (STRING-SEARCH START-STRING INITIAL-BODY)
			       (STRING-LENGTH START-STRING)))
	     (INITIAL-OTHER-HEADERS (LIST (CONS :FILE-REFERENCES (LIST PATH)))))
	(WHEN REVIEWER
	  (SETQ INITIAL-OTHER-HEADERS
 		(NCONC (LIST (CONS :CC (BUILD-REVIEWER-NAMELIST REVIEWER))) INITIAL-OTHER-HEADERS)))
	;; we need a more modular way of doing this, looking up the help
	;; command with (MULTIPLE-VALUE-BIND (NIL HELP-CHAR)
	;;                  (KEY-FOR-COMMAND 'COM-SHOW-PATCH-MAIL-EXAMPLE)...)
	;; after the mail buffer is current.  This probably requires a
	;; :INITIALIZATION-FUNCTION arg for COM-MAIL-INTERNAL, and the
	;; required stuff underneath that.
	(TYPEIN-LINE
	  (FORMAT NIL "Fill in the sections of the outline; ~C shows an example." #\M-HELP))
	(COM-MAIL-INTERNAL T :INITIAL-TO DESTINATION
			   :SETUP-SUBJECT T
			   :INITIAL-SUBJECT (PATCH-STATE-NOTE STATE)
			   :INITIAL-BODY INITIAL-BODY
			   :INITIAL-INDEX INITIAL-INDEX
			   :INITIAL-OTHER-HEADERS INITIAL-OTHER-HEADERS)))))

(DEFUN CHECK-APPROPRIATE-SYSTEM (BUFFER &KEY (PATCH-STATE *CURRENT-PATCH*)
				 (PRINT-WARNING T))
  (LET* ((CURRENT (PATCH-STATE-SYSTEM PATCH-STATE))
	 (PRIVATE (PRIVATE-PATCH-P CURRENT))
	 (OFFICIAL-SYSTEM (SYSTEM-FOR-BUFFER BUFFER))
	 (OFFICIAL-SYSTEM-NAME (AND OFFICIAL-SYSTEM (SCT:SYSTEM-NAME OFFICIAL-SYSTEM))))
    (WHEN (AND PRIVATE (PRIVATE-PATCH-STATE-FOR-SYSTEM-NAME PATCH-STATE))
      (SETQ CURRENT (SCT:FIND-SYSTEM-NAMED
		      (PRIVATE-PATCH-STATE-FOR-SYSTEM-NAME PATCH-STATE))))
    ;; Return T if system is appropriate; print warning and return NIL if not
    (IF (AND OFFICIAL-SYSTEM
	     (NOT (PRIVATE-PATCH-P CURRENT))
	     (NEQ (SCT:SYSTEM-NAME CURRENT)
		  (SCT:SYSTEM-NAME OFFICIAL-SYSTEM)))
	(PROGN
	  (WHEN PRINT-WARNING
	    (TYPEIN-LINE "Warning: ~A usually belongs to ~A;~@
                          ~2Tyou are patching ~:[in a patch-file declared for ~]~A."
			 (OR (SEND BUFFER ':SEND-IF-HANDLES ':PATHNAME)
			     (SEND BUFFER ':NAME))
			 OFFICIAL-SYSTEM-NAME (NOT PRIVATE) (SCT:SYSTEM-SHORT-NAME CURRENT)))
	  NIL)
	T)))

(DEFVAR *SUPPRESS-PATCH-MENU-IF-NO-APPROPRIATE-PATCHES* T
  "NIL allows the menu to go off if there are any patches going at all.")

(DEFUN FIND-APPROPRIATE-PATCH-FOR-BUFFER (BUFFER
					  &KEY
					  (NO-MENU-IF-NO-APPROPRIATE
					    *SUPPRESS-PATCH-MENU-IF-NO-APPROPRIATE-PATCHES*)
					  ALWAYS-DISPLAY-MENU
					  SHOW-ALL-PATCHES)
  (IF (AND *CURRENT-PATCH*
	   (NOT ALWAYS-DISPLAY-MENU)
	   (CHECK-APPROPRIATE-SYSTEM BUFFER)) *CURRENT-PATCH*
    (IF (AND (NOT ALWAYS-DISPLAY-MENU)
	     (OR (NULL *ACTIVE-PATCH-STATES*)
		 (AND NO-MENU-IF-NO-APPROPRIATE
		      (NOT (CL:FIND-IF #'(LAMBDA (PS)
					   (CHECK-APPROPRIATE-SYSTEM BUFFER
								     :PATCH-STATE PS
								     :PRINT-WARNING NIL))
				       *ACTIVE-PATCH-STATES*)))))
	(PROGN
	  (MAKE-PATCH-CURRENT (SYSTEM-TO-PATCH NIL BUFFER))
	  *CURRENT-PATCH*)
      (LET ((BETTER-PATCH
	      (LOOP FOR PS IN *ACTIVE-PATCH-STATES*
		    WHEN
		      (OR (EQ PS *CURRENT-PATCH*)
			  SHOW-ALL-PATCHES
			  (CHECK-APPROPRIATE-SYSTEM
			    BUFFER :PATCH-STATE PS :PRINT-WARNING NIL))
		      COLLECT PS))
	    (ADDITIONAL-SELECTIONS)
	    (DEFAULT-SYSTEM (DEFAULT-SYSTEM-TO-PATCH BUFFER)))
	(PUSH `("1Abort0" NIL) ADDITIONAL-SELECTIONS)
	(WHEN DEFAULT-SYSTEM
	  (PUSH `(,(FORMAT NIL "1New Patch0 1for system 0~A" (SCT:SYSTEM-NAME DEFAULT-SYSTEM))
		  :NEW)
		ADDITIONAL-SELECTIONS))
	(SETQ BETTER-PATCH
	      (TV:MENU-CHOOSE
		(APPEND (SORTCAR
			  (PATCH-ALIST BETTER-PATCH
				       :HIGHLIGHT-CURRENT T
				       :HIGHLIGHT-PATCHES-FOR-BUFFER BUFFER)
			  #'STRING-LESSP)
			ADDITIONAL-SELECTIONS)
		"1Choose a patch buffer0 1(* -> appropriate)0"
		'(:MOUSE)
		(CAR BETTER-PATCH)))
	;; BETTER-PATCH can never be :NEW when DEFAULT-SYSTEM is NIL
	(WHEN (EQ BETTER-PATCH :NEW)
	  (START-PATCH-INTERNAL
	    (SCT:FIND-PATCH-SYSTEM-IN-PATCH-LIST (SCT:SYSTEM-NAME DEFAULT-SYSTEM)
						 (SCT:PATCH-SYSTEMS-LIST)))
	  (SETQ BETTER-PATCH *CURRENT-PATCH*))
	(WHEN (AND BETTER-PATCH (NEQ BETTER-PATCH *CURRENT-PATCH*))
	  (NEW-CURRENT-PATCH BETTER-PATCH))
	BETTER-PATCH))))

(DEFUN ADD-PATCH-COMMENT (PATCH-INFO DEFINITION-NAME INITIAL-CONTENTS)
  (WHEN (AND (NOT INITIAL-CONTENTS)
	     DEFINITION-NAME
	     (NOT (STRING-SEARCH "the region" DEFINITION-NAME)))
    (SETQ INITIAL-CONTENTS (FORMAT NIL "~A:  " DEFINITION-NAME)))
  (MULTIPLE-VALUE-BIND (NIL NIL DESCRIPTION)
      (EDIT-IN-MINI-BUFFER *MINI-BUFFER-MULTI-LINE-COMTAB*
			   INITIAL-CONTENTS
			   (AND INITIAL-CONTENTS (STRING-LENGTH INITIAL-CONTENTS))
			   (LIST (FORMAT NIL "Comment~@[ about ~A~] (end with END)"
				   DEFINITION-NAME)))
    (UNLESS (EQUAL INITIAL-CONTENTS (STRING-INTERVAL (INTERVAL-FIRST-BP DESCRIPTION)
						     (INTERVAL-LAST-BP DESCRIPTION)))
      (SETF (PATCH-STATE-REASON-INTERVAL PATCH-INFO)
	    (SEND (PATCH-STATE-MODE *CURRENT-PATCH*)
		  ':PATCH-REASON (PATCH-STATE-BUFFER PATCH-INFO)
		  (PATCH-STATE-REASON-INTERVAL PATCH-INFO) DESCRIPTION T)))))

(DEFUN UNCOMMENTED-STRING-FROM-INTERVAL (BP1 &OPTIONAL BP2 IN-ORDER-P)
  (LET ((MODE (PATCH-STATE-MODE *CURRENT-PATCH*)))
    (UNCOMMENTED-STRING-FROM-INTERVAL-1 MODE BP1 BP2 IN-ORDER-P)))

;; In generic way, remove comments and "Reason:  " and copy interval into a string
;; so it can be used as initial contents for minibuffer.
(DEFUN UNCOMMENTED-STRING-FROM-INTERVAL-1 (MODE BP1 &OPTIONAL BP2 IN-ORDER-P)
  (GET-INTERVAL BP1 BP2 IN-ORDER-P)
  (LET* ((STRING (MAKE-ARRAY ;;	cheaper to count than to structure-forward
			     (INTERVAL-SIZE BP1 BP2 IN-ORDER-P)
			     :TYPE (IF (INTERVAL-FAT-P BP1 BP2 IN-ORDER-P)
				       'ART-FAT-STRING
				     'ART-STRING)
			     :LEADER-LIST '(0)))
	 (REASON-LENGTH (STRING-LENGTH (SEND MODE :REASON-FLAG)))
	 (COMMENT-BEGIN (SEND MODE ':ATTRIBUTE-COMMENT-START))
	 (BEGIN-COUNT (STRING-LENGTH COMMENT-BEGIN))
	 (COMMENT-END (OR (SEND MODE :ATTRIBUTE-COMMENT-END) ""))
	 (END-COUNT (STRING-LENGTH COMMENT-END))
	 (START (BEG-LINE BP1)))		;ensure at beginning of first line
    (LOOP WHILE (BP-< START BP2)
	  FOR LINE = (BP-LINE START)		;text of the current line
	  FOR LINE-LENGTH = (STRING-LENGTH LINE)
	  FOR FIRST-LINE = T THEN NIL
	  FOR NEXT-LINE = (FORWARD-LINE START 1 T)
	  WHEN (AND (%STRING-EQUAL LINE 0 COMMENT-BEGIN 0 BEGIN-COUNT)	;comment there probly
		    ( LINE-LENGTH (+ BEGIN-COUNT END-COUNT)))	;enough to delete
	  DO (STRING-NCONC-PORTION
	       STRING
	       LINE (IF FIRST-LINE (+ BEGIN-COUNT REASON-LENGTH) BEGIN-COUNT)
	       (- LINE-LENGTH END-COUNT)
	       (IF (BP-< NEXT-LINE BP2) #\RETURN "") 0 NIL)	;ensure no trailing CR
	  DO (SETQ START NEXT-LINE))
    STRING))

;;;This gives the size of the interval in characters (line ends are not characters
;;;remember) and lines (in case you are trying to make a string from munging the
;;;interval and need to estimate the size).
(DEFUN INTERVAL-SIZE (BP1 &OPTIONAL BP2 IN-ORDER-P)
  (GET-INTERVAL BP1 BP2 IN-ORDER-P)
  (INTERVAL-LINES (BP1 BP2) (LINE LAST-LINE)
    (IF (EQ LINE LAST-LINE)			;special case for one-line or empty interval
	(LET ((SIZE (- (BP-INDEX BP2) (BP-INDEX BP1))))
	  (VALUES SIZE (IF (ZEROP SIZE) 0 1)))
	(LOOP SUMMING (STRING-LENGTH LINE) INTO CHAR-COUNT
	      COUNT LINE INTO LINE-COUNT
	      UNTIL (EQ LINE LAST-LINE)
	      DO (SETQ LINE (LINE-NEXT-IN-BUFFER LINE))
	      FINALLY
	      (RETURN (VALUES CHAR-COUNT LINE-COUNT))))))

;;;Requirements:  Has to say what system is being patched, who did it, when,
;;;and what system they were running at the time.
(DEFMETHOD (:PATCH-RESPONSIBILITY-COMMENT MAJOR-MODE) (STATE)
  (LET* ((START-COMMENT (SEND SELF ':ATTRIBUTE-COMMENT-START))
	 (RAW-END-COMMENT (SEND SELF :ATTRIBUTE-COMMENT-END))
	 (END-COMMENT (OR RAW-END-COMMENT ""))
	 (VERSION-INFO (SCT:FORMATTED-SYSTEM-VERSION-INFO START-COMMENT END-COMMENT)))
    (FORMAT NIL "~APatch file for ~A version ~D.~D~A~
	         ~%~AWritten by ~A, ~\DATIME\~A~
		 ~%~Awhile running on ~A from ~:[band ~C~;~A~]~A~
		 ~%~Awith ~A.~A~2%"
      START-COMMENT (PATCH-STATE-SYSTEM-NAME STATE) (PATCH-STATE-MAJOR-VERSION STATE)
      (PATCH-STATE-MINOR-VERSION STATE) END-COMMENT
      START-COMMENT (PATCH-STATE-AUTHOR STATE) END-COMMENT	;the real-user author
      START-COMMENT SI:LOCAL-PRETTY-HOST-NAME T
      (SI:LOADED-BAND-NAME)
      END-COMMENT START-COMMENT
      ;; Because FORMATTED-SYSTEM-VERSION-INFO includes ";;;"
      (NSUBSTRING VERSION-INFO 4) END-COMMENT)))

;;;What I want from here is an empty interval whose bps will move around right
;;;as reasons get added to the buffer.
(DEFMETHOD (:PATCH-REASON-INTERVAL MAJOR-MODE) (BUFFER)
  (LET ((END (SEARCH (INTERVAL-FIRST-BP BUFFER) "written by" NIL T)))
    (CREATE-INTERVAL
      (COPY-BP (FORWARD-LINE (INTERVAL-FIRST-BP BUFFER) 2 T) :NORMAL)
      (COPY-BP (OR (WHEN END (BEG-LINE END))
		   (FORWARD-LINE (INTERVAL-FIRST-BP BUFFER) 2 T)) :MOVES))))

;;;The string to put in at the beginning of the reason.  Who knows why.  Maybe some
;;;code depends on it for locating the patch comments in the buffer.
(DEFMETHOD (:REASON-FLAG MAJOR-MODE) ()
  "Reason: ")

;;;This takes an interval and a place to put it.  Then diddles each of the lines as
;;;necessary to make it look like a comment for this major mode and puts them into
;;;buffer at bp (as new lines in the new interval).
;;;Sometimes you replace an existing reason, sometimes you add a new comment to it.
(DEFMETHOD (:PATCH-REASON MAJOR-MODE) (BUFFER OLD-INTERVAL REASON-INTERVAL &OPTIONAL APPEND-P)
  (LET ((*INTERVAL* BUFFER))			;otherwise internal fcns screw you
    (UNLESS (BP-= (INTERVAL-FIRST-BP REASON-INTERVAL) (INTERVAL-LAST-BP REASON-INTERVAL))
      (LET* ((START-COMMENT (SEND SELF ':ATTRIBUTE-COMMENT-START))
	     (RAW-END-COMMENT (SEND SELF :ATTRIBUTE-COMMENT-END))
	     (END-COMMENT (OR RAW-END-COMMENT ""))
	     (REASON-FLAG (SEND (SEND BUFFER :GET :MAJOR-MODE) :REASON-FLAG))
	     (START-BP (INTERVAL-FIRST-BP OLD-INTERVAL))
	     (AT-BP (INTERVAL-LAST-BP OLD-INTERVAL))
	     (OLD-REASON (SEARCH AT-BP REASON-FLAG T NIL NIL)))	;look backwards
	(IF APPEND-P
	    (SETQ START-BP (COPY-BP AT-BP :NORMAL))	;for inserting at end of reason
	    (DELETE-INTERVAL OLD-INTERVAL))	;take out old reason altogether
	(INSERT-INTERVAL AT-BP REASON-INTERVAL)
	(UNLESS (= (BP-INDEX AT-BP) 0)		;make sure the new interval has new line
	  (INSERT AT-BP #\RETURN))
	(LOOP FOR STRING = (IF (OR (NOT APPEND-P) (NOT OLD-REASON))
			       (STRING-APPEND START-COMMENT REASON-FLAG) START-COMMENT)
	                    THEN START-COMMENT
	      WHILE (BP-< START-BP AT-BP)
	      DO				;now make interval look like comments
	      (INSERT START-BP STRING)
	      (INSERT (END-LINE START-BP) END-COMMENT)
	      (SETQ START-BP (FORWARD-LINE START-BP)))))
;    (format t "~%Buffer: ~A, Interval: ~S -- ~S" (send buffer :name)
;	    (interval-first-bp old-interval) (interval-last-bp old-interval))
    OLD-INTERVAL))				;returns interval for patch-state

;;;For example, consider a buffer in fundamental mode that someone is trying to create
;;;a patch buffer from.  Should be allowed.
(DEFMETHOD (:ADD-PATCH-INTERVAL MAJOR-MODE) (BP1 BP2 IN-ORDER-P FROM-BUFFER TO-BUFFER)
  (SEND (MAJOR-MODE-FROM-KEYWORD *DEFAULT-LANGUAGE-MODE*)	;use generic default
	:ADD-PATCH-INTERVAL BP1 BP2 IN-ORDER-P FROM-BUFFER TO-BUFFER))

;;;This method can add methods to the finish-actions slot of the patch structure;
;;;those methods will get invoked when the patch is being finished by Finish Patch.
(DEFMETHOD (:ADD-PATCH-INTERVAL LISP-SYNTAX-MIXIN) (BP1 BP2 IN-ORDER-P FROM-BUFFER TO-BUFFER)
  (INSERT-PATCH-SECTION-PROLOGUE FROM-BUFFER TO-BUFFER)
  (GET-INTERVAL BP1 BP2 IN-ORDER-P)
  (LET* ((NEXT-BP (FORWARD-SEXP BP1 1 NIL 0 BP2 T T))
	 (JUST-ONE-EXPRESSION-P (AND NEXT-BP
				     (OR (BP-= NEXT-BP BP2)
					 (NOT (FORWARD-SEXP NEXT-BP 1 NIL 0 BP2 T T)))))
	 (BP (INTERVAL-LAST-BP TO-BUFFER)))
    (UNLESS JUST-ONE-EXPRESSION-P
      (INSERT BP (FORMAT NIL "(PROGN~%")))
    (INSERT-INTERVAL BP BP1 BP2 T)
    (UNLESS JUST-ONE-EXPRESSION-P
      (INSERT BP (FORMAT NIL "~%)")))
    (INSERT BP #\CR))
  ;; If region being patched lies entirely within one section, record that section as patched
  (LET ((NODE (AND (EQ (BP-NODE BP1) (BP-NODE (FORWARD-CHAR BP2 -1 T)))	;---Lispy soul
		   (TYPEP (BP-NODE BP1) 'SECTION-NODE)
		   (BP-NODE BP1))))
    (AND NODE (PUTPROP (LOCF (SECTION-NODE-PLIST NODE)) (NODE-TICK NODE) 'PATCH-TICK))))

(DEFMETHOD (:PATCH-MAJOR-MODE MAJOR-MODE) ()
  (MAJOR-MODE-FROM-KEYWORD *DEFAULT-LANGUAGE-MODE*))	;generic default

(DEFVAR *PSA-STRINGS* (LIST
			(STRING-APPEND #\Return
				       "(SYSTEM-INTERNALS:PATCH-SECTION-ATTRIBUTES")
			(STRING-APPEND #\Return
				       "(ZL:::SYSTEM-INTERNALS:PATCH-SECTION-ATTRIBUTES")
			(STRING-APPEND #\Return
				       "(SCT:PATCH-SECTION-ATTRIBUTES")
			(STRING-APPEND #\Return
				       "(ZL:::SCT:PATCH-SECTION-ATTRIBUTES")))

(DEFUN FIND-LAST-PATCH-SECTION-ATTRIBUTES (BUFFER)
  (LET* ((LAST-BP (INTERVAL-LAST-BP BUFFER))
	 (BP (LOOP WITH THE-BP
		   FOR PSA-STRING IN *PSA-STRINGS*
		   FOR A-BP = (SEARCH LAST-BP PSA-STRING T)
		   IF (NULL THE-BP)
		     DO (SETF THE-BP A-BP)
		   ELSE IF (AND A-BP (BP-< A-BP THE-BP))
		     DO (SETF THE-BP A-BP)
		   FINALLY
		     (RETURN THE-BP))))
    (IF (NULL BP)
	(SEND BUFFER :PROPERTY-LIST)
	(SCL:WITH-STANDARD-IO-ENVIRONMENT
	  (LET* ((READTABLE (SI:READTABLE-FOR-SYNTAX (SEND BUFFER :GET :SYNTAX)))
		 (NBP (CREATE-BP (LINE-NEXT (BP-LINE BP)) 0))
		 (EXPR (WITH-INTERVAL-STREAM (S NBP LAST-BP T) (CL:READ S :END))))
	    (IF (AND (LISTP EXPR) (MEMQ (FIRST EXPR) '(SI:PATCH-SECTION-ATTRIBUTES
						       SCT:PATCH-SECTION-ATTRIBUTES))
		     (STRINGP (SECOND EXPR)))
		(FS:PARSE-ATTRIBUTE-LIST (SECOND EXPR))
		(SEND BUFFER :PROPERTY-LIST)))))))

(DEFUN INSERT-PATCH-SECTION-PROLOGUE (FROM-BUFFER TO-BUFFER)
  (SCL:WITH-STANDARD-IO-ENVIRONMENT
    (LET ((BP (INTERVAL-LAST-BP TO-BUFFER))
	  (SCT-FORM (SCT-FEATURES-PREPROCESSOR-FORM (PATCH-STATE-SYSTEM *CURRENT-PATCH*))))
      ;; Put into the patch buffer, making sure the right package and base will be used.
      ;; The only syntactic assumptions made are that parentheses, letters, hyphens, and 
      ;; semicolon have their normal syntax.  The semicolon is only to make the patch files
      ;; a little more readable.  That's enough to make it possible to switch to standard
      ;; syntax to read the rest.  Of course this assumes COMPILER:*READ-THEN-PROCESS-FLAG*
      ;; is not turned on.
      (INSERT BP (FORMAT NIL "~%;========================~@
			      ~@[~A~%~](SCT:BEGIN-PATCH-SECTION)"
			 SCT-FORM))
      (LET* ((PATHNAME (BUFFER-LOGICAL-TRUENAME FROM-BUFFER TO-BUFFER))
	     (READTABLE (SI:READTABLE-FOR-SYNTAX (SEND TO-BUFFER :GET :SYNTAX)))
	     (ATTRIBUTES-FORM
	       (MACHINE-TYPES-PREPROCESSOR-FORM (PATCH-STATE-SYSTEM *CURRENT-PATCH*)
						PATHNAME
						T))
	     (MT-FORMS (MACHINE-TYPES-PREPROCESSOR-FORM (PATCH-STATE-SYSTEM *CURRENT-PATCH*)
							PATHNAME
							NIL))
	     (IP-FORMS (IN-PACKAGE-FORMS (PATCH-STATE-SYSTEM *CURRENT-PATCH*) PATHNAME
					 (SEND FROM-BUFFER :GET :PACKAGE)
					 (SEND FROM-BUFFER :GET :SYNTAX))))
	(INSERT BP (IF PATHNAME
		       (FORMAT NIL "~%~@[~A~%~](SCT:PATCH-SECTION-SOURCE-FILE ~S)"
			       SCT-FORM (STRING PATHNAME))
		       (FORMAT NIL "~%; From buffer ~A~@[~A~]"
			       (NAMED-BUFFER-NAME FROM-BUFFER)
			       (SEND FROM-BUFFER ':VERSION-STRING))))
	(INSERT BP
		(FORMAT NIL "~%~@[~A~%~](SCT:PATCH-SECTION-ATTRIBUTES~%  ~S)~2%"
			ATTRIBUTES-FORM (BUFFER-ATTRIBUTE-STRING FROM-BUFFER)))
	(INSERT BP
		(FORMAT NIL "~@[~{~A~%~}~%~]~@[~A~%~]" IP-FORMS MT-FORMS))))))

(DEFUN BUFFER-ATTRIBUTE-STRING (BUFFER)
  (LET ((*INTERVAL* BUFFER))
    (LINEMAP-INTERVAL (BUFFER "")
      (UNLESS (LINE-BLANK-P LINE)		;Attribute list starts on first non-blank line
	;; Narrow down to the stuff between the -*-'s
	(LET ((START (STRING-SEARCH "-*-" LINE *FIRST-INDEX* *LAST-INDEX*)))
	  (UNLESS START
	    (RETURN-FROM *LINEMAP* ""))
	  (LET ((END (STRING-SEARCH "-*-" LINE (+ START 3) *LAST-INDEX*)))
	    (UNLESS END
	      (RETURN-FROM *LINEMAP* ""))
	    (RETURN-FROM *LINEMAP*
	      (SUBSTRING LINE START (+ END 3)))))))))

(DEFUN ALL-MACHINE-TYPES-SUPPORT-SCT-FORMS-P ()
  (LOOP FOR MACHINE-TYPE IN SCT:*ALL-MACHINE-TYPES*
	ALWAYS (SCT:MACHINE-TYPE-SUPPORTS-SCT-FORMS-P (SCT:FIND-ENVIRONMENT MACHINE-TYPE)
						      MACHINE-TYPE)))

(DEFUN SIMPLIFY-AND-FORMAT-PREPROCESSOR-ATOMS (ATOMS)
  (WHEN ATOMS
    (LOOP FOR MACHINE-TYPE IN SCT:*ALL-MACHINE-TYPES*
	  FOR ENVIRONMENT = (SCT:FIND-ENVIRONMENT MACHINE-TYPE)
	  DO
      (SETF ATOMS (SCT:MACHINE-TYPE-SIMPLIFY-PREPROCESSOR-ATOMS ENVIRONMENT
								MACHINE-TYPE ATOMS)))
    (IF (= (LENGTH ATOMS) 1)
	(FORMAT NIL "#+~A" (FIRST ATOMS))
	(FORMAT NIL "#+(OR~{ ~A~})" ATOMS))))

(DEFUN SCT-FEATURES-PREPROCESSOR-FORM (SYSTEM)
  (DECLARE (IGNORE SYSTEM))
  (UNLESS (ALL-MACHINE-TYPES-SUPPORT-SCT-FORMS-P)
    (LOOP FOR MACHINE-TYPE IN SCT:*ALL-MACHINE-TYPES*
	  FOR ENVIRONMENT = (SCT:FIND-ENVIRONMENT MACHINE-TYPE)
	  WHEN (SCT:MACHINE-TYPE-SUPPORTS-SCT-FORMS-P ENVIRONMENT MACHINE-TYPE)
	    COLLECT (SCT:MACHINE-TYPE-PREPROCESSOR-ATOM ENVIRONMENT MACHINE-TYPE) INTO ATOMS
	  FINALLY
	    (RETURN (SIMPLIFY-AND-FORMAT-PREPROCESSOR-ATOMS ATOMS)))))

;;; Can't use SCT:MODULE-FROM-PATHNAME directly as it doesn't handle the case of a file
;;; living in multiple modules of a single system.  The Minima-Kernel system contains
;;; numerous files in multiple subsystems.
(DEFUN MACHINE-TYPES-FROM-PATHNAME (PATHNAME SYSTEM)
  (COND ((NULL PATHNAME)
	 (IF (AND SYSTEM (NOT (EQL SYSTEM :PRIVATE)))
	     (SCT:SYSTEM-MACHINE-TYPES SYSTEM)
	     :ALL))
	((OR (AND (EQL SYSTEM :PRIVATE)
		  ;; Assume private patches will eventually be patched into the proper system.
		  (SETF SYSTEM (SCT:PATCHABLE-SYSTEM-FROM-PATHNAME PATHNAME)))
	     SYSTEM)
	 (LET ((PATHNAME (SEND PATHNAME :GENERIC-PATHNAME))
	       (MACHINE-TYPES NIL))
	   (LABELS ((FIND-PATHNAME-TYPES (SYSTEM)
		      (LOOP FOR MODULE IN (SCT:SYSTEM-MODULES SYSTEM) DOING
			(IF (TYPEP MODULE 'SCT:SYSTEM-MODULE)
			    (LOOP FOR (COMPONENT-NAME) IN (SCT:MODULE-INPUTS MODULE)
				  AS COMPONENT = (SCT:FIND-SYSTEM-NAMED COMPONENT-NAME NIL T)
				  DOING
			      (WHEN (TYPEP COMPONENT 'SCT:SUBSYSTEM)
				(FIND-PATHNAME-TYPES COMPONENT)))
			  (LOOP FOR (INPUT OUTPUT) IN (SCT:MODULE-INPUTS MODULE)
				DOING
			    (LET ((IGENERIC (SEND INPUT :GENERIC-PATHNAME))
				  (OGENERIC (AND OUTPUT (SEND OUTPUT :GENERIC-PATHNAME))))
			      (WHEN (OR (EQL IGENERIC PATHNAME)
					(EQL OGENERIC PATHNAME))
				(LET ((TYPES (SCT:MODULE-MACHINE-TYPES MODULE)))
				  (IF (EQ TYPES :ALL)
				      (RETURN-FROM MACHINE-TYPES-FROM-PATHNAME :ALL)
				    (DOLIST (TYPE TYPES)
				      (CL:PUSHNEW TYPE MACHINE-TYPES)))))))))))
	     (FIND-PATHNAME-TYPES (SCT:SUBSYSTEM-PARENT-SYSTEM SYSTEM)))
	   (OR MACHINE-TYPES :ALL)))
	(T
	 :ALL)))

(DEFUN MACHINE-TYPES-PREPROCESSOR-FORM (SYSTEM PATHNAME FOR-SCT-FORM-P)
  (LET ((MACHINE-TYPES (MACHINE-TYPES-FROM-PATHNAME PATHNAME SYSTEM)))
    (UNLESS (AND (EQ MACHINE-TYPES :ALL)
		 (OR (NOT FOR-SCT-FORM-P)
		     (ALL-MACHINE-TYPES-SUPPORT-SCT-FORMS-P)))
      (LOOP FOR MACHINE-TYPE IN (IF (EQ MACHINE-TYPES :ALL)
				    SCT:*ALL-MACHINE-TYPES*
				    MACHINE-TYPES)
	    FOR ENVIRONMENT = (SCT:FIND-ENVIRONMENT MACHINE-TYPE)
	    WHEN (OR (NOT FOR-SCT-FORM-P)
		     (SCT:MACHINE-TYPE-SUPPORTS-SCT-FORMS-P ENVIRONMENT MACHINE-TYPE))
	      COLLECT (SCT:MACHINE-TYPE-PREPROCESSOR-ATOM ENVIRONMENT MACHINE-TYPE) INTO ATOMS
	    FINALLY
	      (RETURN (IF (AND (NULL ATOMS) FOR-SCT-FORM-P)
			  (SCT-FEATURES-PREPROCESSOR-FORM SYSTEM)
			  (SIMPLIFY-AND-FORMAT-PREPROCESSOR-ATOMS ATOMS)))))))

(DEFUN SIMPLIFY-AND-FORMAT-IN-PACKAGES-AND-PREPROCESSOR-ATOMS (FORMS ATOMS)
  (WHEN FORMS
    (LOOP FOR FORMS ON FORMS
	  FOR ATOMS ON ATOMS
	  FOR FORM = (FIRST FORMS)
	  WHEN FORM
	    DO (LOOP FOR OTHER-FORMS ON (REST1 FORMS)
		     FOR OTHER-ATOMS ON (REST1 ATOMS)
		     WHEN (STRING-EQUAL FORM (FIRST OTHER-FORMS))
		       COLLECT (FIRST OTHER-ATOMS) INTO EXTRA-ATOMS
		       AND DO (SETF (FIRST OTHER-FORMS) NIL)
			      (SETF (FIRST OTHER-ATOMS) NIL)
		     FINALLY
		       (SETF (FIRST ATOMS) (APPEND (LIST (FIRST ATOMS)) EXTRA-ATOMS))))
    (LOOP FOR FORM IN FORMS
	  FOR ATOM IN ATOMS
	  WHEN FORM
	    COLLECT
	      (FORMAT NIL "~A ~A" (SIMPLIFY-AND-FORMAT-PREPROCESSOR-ATOMS ATOM) FORM))))

(DEFUN DEFAULT-IN-PACKAGE-FORMS (SYSTEM)
  (DECLARE (IGNORE SYSTEM))
  (LOOP FOR MACHINE-TYPE IN SCT:*ALL-MACHINE-TYPES*
	FOR ENVIRONMENT = (SCT:FIND-ENVIRONMENT MACHINE-TYPE)
	FOR FORM = (SCT:DEFAULT-IN-PACKAGE-FORM ENVIRONMENT MACHINE-TYPE)
	WHEN FORM
	  COLLECT IT INTO FORMS
	  AND COLLECT (SCT:MACHINE-TYPE-PREPROCESSOR-ATOM ENVIRONMENT MACHINE-TYPE) INTO ATOMS
	FINALLY
	  (RETURN (SIMPLIFY-AND-FORMAT-IN-PACKAGES-AND-PREPROCESSOR-ATOMS FORMS ATOMS))))

(DEFUN IN-PACKAGE-FORMS (SYSTEM PATHNAME PACKAGE SYNTAX)
  (LET ((MACHINE-TYPES (MACHINE-TYPES-FROM-PATHNAME PATHNAME SYSTEM)))
    (LOOP FOR MACHINE-TYPE IN (IF (EQ MACHINE-TYPES :ALL)
				  SCT:*ALL-MACHINE-TYPES*
				  MACHINE-TYPES)
	  FOR ENVIRONMENT = (SCT:FIND-ENVIRONMENT MACHINE-TYPE)
	  FOR FORM = (SCT:IN-PACKAGE-FORM ENVIRONMENT MACHINE-TYPE PACKAGE SYNTAX)
	      WHEN FORM
		COLLECT IT INTO FORMS
		AND COLLECT (SCT:MACHINE-TYPE-PREPROCESSOR-ATOM ENVIRONMENT MACHINE-TYPE)
		      INTO ATOMS
	  FINALLY
	    (RETURN (SIMPLIFY-AND-FORMAT-IN-PACKAGES-AND-PREPROCESSOR-ATOMS FORMS ATOMS)))))

(COMPILE-FLAVOR-METHODS PATCH-STATE PRIVATE-PATCH-STATE)

