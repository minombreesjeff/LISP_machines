;;; Functions that deal with indentation -*- Base: 8;Mode: LISP;Package: ZWEI-*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;; Returns the number of PIXELs needed to produce the amount of indentation
;;    this line has.
(DEFUN LINE-INDENTATION (LINE &OPTIONAL (SHEET (WINDOW-SHEET *WINDOW*)))
  (STRING-WIDTH LINE
		0
		(BP-INDEX (FORWARD-OVER *BLANKS* (CREATE-BP LINE 0)))
		SHEET))

;; Returns the number of PIXELs needed to produce the amount of indentation
;;   to reach this BP, starting at the beginning of its line.
(DEFUN BP-INDENTATION (BP &OPTIONAL (SHEET (WINDOW-SHEET *WINDOW*)))
  (FUNCALL SHEET ':COMPUTE-MOTION (BP-LINE BP) 0 (BP-INDEX BP) 0 0))

;; Like above, but ignores continuation lines
(DEFUN BP-VIRTUAL-INDENTATION (BP &OPTIONAL (SHEET (WINDOW-SHEET *WINDOW*)))
  (FUNCALL SHEET ':STRING-LENGTH (BP-LINE BP) 0 (BP-INDEX BP)))

;; Adds whitespace characters at BP until BP is at the GOAL indentation.
;; This never removes whitespace, it only adds it.
;; Returns a BP to the end of what it inserted, also moves BP there.
(DEFUN INDENT-TO (BP GOAL &OPTIONAL (SHEET (WINDOW-SHEET *WINDOW*)))
  (INDENT-SUBR BP BP GOAL SHEET))

;; Changes the whitespace before BP until BP is at the GOAL indentation.
;; This can add or remove whitespace.
;; Returns a BP to the end of what it inserted, also moves BP there.
(DEFUN INDENT-AT (BP GOAL &OPTIONAL (SHEET (WINDOW-SHEET *WINDOW*)))
  (INDENT-SUBR (BACKWARD-OVER *BLANKS* BP) BP GOAL SHEET))

;; Internal subroutine of INDENT-TO, INDENT-AT, and INDENT-LINE.
;; BP1 and BP2 enclose whitespace that can be deleted.  They must be in order.
;; The indentation of the character after BP2 is set  INDENTATION.
;; Returns a BP to the end of what it inserted, also moves BP2 there.
;; This is the only function which knows to use spaces and tabs to perform
;; indentation!!!  Nobody else should know that.
(DEFUN INDENT-SUBR (BP1 BP2 INDENTATION SHEET)
  (LET ((DELETE (NOT (BP-= BP1 BP2)))
	(CURRENT-INDENTATION (BP-VIRTUAL-INDENTATION BP2 SHEET)))
    ;; Return early if the line does not need to be changed
    (IF (OR (= CURRENT-INDENTATION INDENTATION)
	    (AND (> CURRENT-INDENTATION INDENTATION) (NOT DELETE)))
	(COPY-BP BP2)
	(LET* ((LINE (BP-LINE BP1))
	       (BEFORE-INDEX (BP-INDEX BP1))
	       (AFTER-INDEX (BP-INDEX BP2))
	       (BP-POSITIONS NIL)
	       (SPACE-CHAR (LINE-INDENTATION-SPACE-CHAR LINE))
	       (SW (SEND SHEET :CHARACTER-WIDTH SPACE-CHAR))
	       (TAB-CHAR (MAKE-CHARACTER #\TAB :STYLE (SI:CHAR-STYLE SPACE-CHAR)))	       
	       (TW (SEND SHEET :CHARACTER-WIDTH TAB-CHAR NIL (TV:SHEET-INSIDE-LEFT SHEET)))
	       (M 0) (N 0)
	       BUFFER CURRENT)
	  (WHEN DELETE
	    (SETQ CURRENT-INDENTATION (BP-VIRTUAL-INDENTATION BP1 SHEET)))
	  ;; Will insert M tabs and N spaces
	  (WHEN (< CURRENT-INDENTATION INDENTATION)
	    (WHEN *INDENT-WITH-TABS*
	      (SETQ M (// INDENTATION TW)
		    N (* TW M)))		;Position of rightmost tab
	    (IF (> CURRENT-INDENTATION N)	;Past there, no tabs can be used, so
		(SETQ N (// (- INDENTATION CURRENT-INDENTATION) SW) M 0)  ; use all spaces
		(SETQ M (- M (// CURRENT-INDENTATION TW))	; else tabs and spaces
		      N (// (- INDENTATION N) SW))))
	  ;; Record positions of any BPs that lie in the whitespace
	  (DOLIST (BP (LINE-BP-LIST LINE))
	    (UNLESS (AND *SPARSE-CHANGE-ARRAY*
			 (OR (EQ BP *SPARSE-CHANGE-FIRST-BP*)
			     (EQ BP *SPARSE-CHANGE-LAST-BP*)))
	      (UNLESS (EQ BP BP2)
		(LET ((INDEX (BP-INDEX BP)))
		  (WHEN (OR (AND ( BEFORE-INDEX INDEX) (< INDEX AFTER-INDEX))
			    (AND (= INDEX AFTER-INDEX)
				 (EQ (BP-STATUS BP) ':NORMAL)))
		    (PUSH (CONS BP (BP-INDENTATION BP SHEET)) BP-POSITIONS))))))
	  ;; Record the change so it can be undone
	  (COND ((AND *ENABLE-CHANGE-RECORDING* *RECORD-SMALL-CHANGES*
		      (SETQ BUFFER (BP-CHANGE-RECORDING-BUFFER BP1))
		      (SETQ CURRENT (AND (BUFFER-CHANGE-ACCUMULATION-N-LINES BUFFER)
					 (FIRST (BUFFER-CHANGE-HISTORY BUFFER))))
		      (BP-IN-RANGE BP1 (CHANGE-RECORD-FIRST-BP CURRENT)
				       (CHANGE-RECORD-LAST-BP CURRENT))
		      ;; Overlaps with or appends to the preceding change, try to merge
		      (ACCUMULATE-CHANGE CURRENT BP1 BP2 'CHANGE BUFFER)))
		(*SPARSE-CHANGE-ARRAY*		;Caller did a WITH-UNDO-SAVE-SPARSE
		 (RECORD-SPARSE-CHANGE BP1 BP2 (+ M N)))
		(*ENABLE-CHANGE-RECORDING*
		 (WITH-UNDO-SAVE-SPARSE ("Indent" BP1)
		   (RECORD-SPARSE-CHANGE BP1 BP2 (+ M N)))))
	  ;; Done with preparations, actually change the text
	  (LET ((*ENABLE-CHANGE-RECORDING* NIL))
	    (WHEN DELETE
	      (DELETE-INTERVAL BP1 BP2 T)
	      (MOVE-BP BP2 BP1))
	    (IF ( CURRENT-INDENTATION INDENTATION) 
		;; We are already past the goal.  Don't do anything.
		(SETQ BP2 (COPY-BP BP2))
		;; Insert M tabs and N spaces
		(STACK-LET ((SPACES (MAKE-ARRAY (+ M N) :TYPE (IF (CHAR-FAT-P SPACE-CHAR)
								  ART-FAT-STRING
								  ART-STRING))))
		  (LOOP FOR I FROM 0 BELOW M DO
		    (SETF (AREF SPACES I) TAB-CHAR))
		  (LOOP REPEAT N FOR I FROM M DO
		    (SETF (AREF SPACES I) SPACE-CHAR))
		  (SETQ BP2 (INSERT-MOVING BP2 SPACES)))))
	  ;; Restore saved BP positions
	  (SETQ AFTER-INDEX (BP-INDEX BP2))
	  (LOOP FOR (BP . INDENTATION) IN BP-POSITIONS
		AS INDEX = (INDENTATION-INDEX LINE INDENTATION SHEET) DO
	    (WHEN INDEX
	      (SETF (BP-INDEX BP) (MIN INDEX AFTER-INDEX))))
	  ;; Return BP pointing after what we inserted
	  BP2))))

;;; Returns the style of space to be used for indentation in this line
(DEFUN LINE-INDENTATION-SPACE-CHAR (LINE &OPTIONAL (START 0) END)
  (UNLESS END (SETQ END (LINE-LENGTH LINE)))
  (IF (= START END) #\SPACE
      (LET ((LINE LINE))
	(DECLARE (SYS:ARRAY-REGISTER LINE))
	(LOOP WITH INITIAL-STYLE = (SI:CHAR-STYLE-INDEX (AREF LINE START))
	      FOR I FROM (1+ START) BELOW END
	      UNLESS (= (SI:CHAR-STYLE-INDEX (AREF LINE I)) INITIAL-STYLE)
		;; No consistent style, so use the null style
		RETURN #\SPACE
	      FINALLY
		;; Whole line is in one style (e.g. tiny), use that style
		;; Only use that style if it's fixed-width.
		(IF (ZEROP INITIAL-STYLE)
		    ;; This is in NIL.NIL.NIL, whatever that means for the buffer.  Use a fixed-width space.
		    (RETURN #\SPACE)
		    ;; Some non-NIL style.
		    (LET ((STYLE (SI:INDEX-CHARACTER-STYLE INITIAL-STYLE)))	; Really a style-index, not a style.
		      (WHEN (SI:CHARACTER-STYLE-RELATIVE-P STYLE)
			;; Uh oh.  This is something like [NIL.NIL.SMALLER].  Find the buffer's
			;; default character style, using [FIX.ROMAN.NORMAL] if it's [NIL.NIL.NIL],
			;; and merge against that so you can get a real font.
			(LET ((DCS (SEND *INTERVAL* :GET :DEFAULT-CHARACTER-STYLE)))
			  (UNLESS DCS		; If the buffer doesn't have a default character style, use the standard default.
			    (SETF DCS SI:*STANDARD-DEFAULT-CHARACTER-STYLE*))	; [FIX.ROMAN.NORMAL] when I looked at this.
			  (SETF STYLE (SI:MERGE-CHARACTER-STYLES STYLE DCS))))
		      (let ((FONT (SI:GET-FONT SI:*B&W-SCREEN* SI:*STANDARD-CHARACTER-SET* STYLE)))
			(IF (FONT-CHAR-WIDTH-TABLE FONT)
			    ;; This is a variable-width font, so return a fixed-width space.  Line height be damned.
			    (RETURN #\SPACE)
			    ;; This is a fixed-width font, so return its own space.
			    (LET ((CHAR #\SPACE))
			      (SETF (SI:CHAR-STYLE-INDEX CHAR) INITIAL-STYLE)
			      (RETURN CHAR))))))))))

;;; Version of this that works better if you like your indentation really even.
;;; Punted for now.  --- Foner 12-Oct-89.
; (DEFUN LINE-INDENTATION-SPACE-CHAR (IGNORE &REST IGNORE)
;   (LET ((DCS (SEND *INTERVAL* :GET :DEFAULT-CHARACTER-STYLE)))	; I think this *can't* be a relative style.
;     (IF DCS					; Use the default, if non-NIL.
; 	(LET ((CHAR #\SPACE))
; 	  (SETF (SI:CHAR-STYLE-INDEX CHAR) DCS)
; 	  CHAR)
; 	#\SPACE)))				; Default was NIL or unspecified:  Use a styleless space.

;; Given a font, return the width of SPACE in that font.
(DEFUN FONT-SPACE-WIDTH (&OPTIONAL (FONT (CURRENT-FONT *WINDOW*)))
  (LET ((CHAR-WIDTH-TABLE (FONT-CHAR-WIDTH-TABLE FONT)))
    (IF CHAR-WIDTH-TABLE
	(AREF CHAR-WIDTH-TABLE (CHAR-CODE #\SP))
	(FONT-CHAR-WIDTH FONT))))

;; Causes the indentation at the front of BP's line to be INDENTATION pixels wide.
;; Returns a BP to the end of what it inserted.
;; Preserves the indentations of bps pointing within the indentation, if possible.
;; If the indentation is already as desired, the line is not changed.
;; By specifying BP1, the indentation after a certain point can be acted on.
;; In that case, BP is ignored.
(DEFUN INDENT-LINE (BP INDENTATION &OPTIONAL (SHEET (WINDOW-SHEET *WINDOW*))
					     (BP1 (CREATE-BP (BP-LINE BP) 0)))
  (INDENT-SUBR BP1 (FORWARD-OVER *BLANKS* BP1) INDENTATION SHEET))

;; If the point is within this line's indentation, move it past that
;; indentation.
(DEFUN INDENT-BP-ADJUSTMENT (BP)
  (LET ((BP1 (FORWARD-OVER *BLANKS* (CREATE-BP (BP-LINE BP) 0))))
    (COND ((AND (< (BP-INDEX (POINT))
		   (BP-INDEX BP1)))
	   (MOVE-BP BP BP1)))))

;; Returns the char pos in LINE which would be at position XPOS.
;; If XPOS is greater than the length of the string, return NIL.
;; It the answer is between N and N+1, returns N if ROUND-DOWN-P, else N+1.
(DEFUN INDENTATION-INDEX (LINE XPOS &OPTIONAL SHEET LENGTH ROUND-DOWN-P)
  (OR SHEET (SETQ SHEET (WINDOW-SHEET *WINDOW*)))
  (AND (NULL LENGTH)
       (EQ LINE (BP-LINE (INTERVAL-LAST-BP *INTERVAL*)))
       (SETQ LENGTH (BP-INDEX (INTERVAL-LAST-BP *INTERVAL*))))
  (MULTIPLE-VALUE-BIND (X NIL INDEX)
      (FUNCALL SHEET ':COMPUTE-MOTION LINE 0 LENGTH 0 0 NIL XPOS 0)
    (AND INDEX ROUND-DOWN-P ( X XPOS)
	 (SETQ INDEX (1- INDEX)))
    INDEX))

(DEFCOM COM-TAB-HACKING-DELETE-FORWARD "Delete characters forward, changing tabs into spaces.
A numeric argument (n) kills n characters forward, placing them
on the kill history." ()
  (DELETE-CHARS-CONVERTING-TABS (POINT) *NUMERIC-ARG*))

(DEFCOM COM-TAB-HACKING-RUBOUT "Rub out a character, changing tabs to spaces.
So tabs rub out as if they had been spaces all along.  A numeric argument (n)
kills n characters backward, placing them on the kill history." ()
  (DELETE-CHARS-CONVERTING-TABS (POINT) (- *NUMERIC-ARG*)))

(DEFUN DELETE-CHARS-CONVERTING-TABS (POINT COUNT &AUX (BP (COPY-BP POINT)))
  (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK POINT))
    ;; Scan across what we will delete, converting tabs to spaces.
    ;; BP gets set to the other end of the range to be deleted.
    (COND ((> COUNT 0)
	   (LET ((BLANKS *BLANKS*))
	     (DOTIMES (IGNORE COUNT)
	       (AND (BP-= BP (INTERVAL-LAST-BP *INTERVAL*))
		    (RETURN (BEEP)))
	       ;; When moving forward, whenever we find a blank we must
	       ;; convert all tabs within the blanks that follow.
	       (AND (MEM #'CHAR-EQUAL (BP-CHAR BP) BLANKS)
		    (LET ((BP1 (COPY-BP BP)))
		      (DO ()
			  ((OR (BP-= BP1 (INTERVAL-LAST-BP *INTERVAL*))
			       (NOT (MEM #'CHAR-EQUAL (BP-CHAR BP1) BLANKS))))
			(COND ((CHAR-EQUAL (BP-CHAR BP1) #\TAB)
			       (TAB-CONVERT BP1 (FORWARD-CHAR BP1 1)))
			      (T (IBP BP1))))))
	       (IBP BP))))
	  (T
	   (DOTIMES (IGNORE (- COUNT))
	     (AND (BP-= BP (INTERVAL-FIRST-BP *INTERVAL*))
		  (RETURN (BEEP)))
	     (AND (CHAR-EQUAL (BP-CHAR-BEFORE BP) #\TAB)
		  (TAB-CONVERT (FORWARD-CHAR BP -1) BP))
	     (DBP BP))))
    (COND ((EQ (BP-LINE POINT) (BP-LINE BP))
	   ;;--- Changed to not copy (BP-LINE POINT) before munging the line,
	   ;;--- for copy-on-write
	   (MUNG-LINE (BP-LINE BP))		;there must be a more modular way!
	   (MUST-REDISPLAY *WINDOW* DIS-LINE (BP-LINE POINT)
			   (MIN (BP-INDEX POINT) (BP-INDEX BP))))
	  (T (MUST-REDISPLAY *WINDOW* DIS-TEXT)))
    (FUNCALL (IF *NUMERIC-ARG-P* #'KILL-INTERVAL #'DELETE-INTERVAL) POINT BP))
  DIS-NONE)

;; Convert a tab to spaces.
;; We take a bp to before the tab and a bp to after, since that is easiest.
;; If they are not temporary bps, you can lose!
;; The character style of the tab is copied as the character style of the spaces.
(DEFUN TAB-CONVERT (BP-BEFORE BP-AFTER)
  (LET* ((INDENT-BEFORE (BP-VIRTUAL-INDENTATION BP-BEFORE))
	 (INDENT-AFTER (BP-VIRTUAL-INDENTATION BP-AFTER))
	 (STYLE (SI:CHAR-STYLE (BP-CHAR BP-BEFORE)))
	 (SPACE (MAKE-CHARACTER #\SPACE :STYLE STYLE))
	 (NSPACES (SYS:CEILING (- INDENT-AFTER INDENT-BEFORE)
			       (FONT-SPACE-WIDTH (CURRENT-FONT *WINDOW*
							       (SI:CHAR-STYLE-INDEX SPACE))))))
    (MUNG-BP-LINE-AND-INTERVAL BP-BEFORE)
    (PREPARE-TO-CHANGE BP-BEFORE BP-AFTER)
    (LET ((*ENABLE-CHANGE-RECORDING* NIL))
      (ASET SPACE (BP-LINE BP-BEFORE) (BP-INDEX BP-BEFORE))
      (INSERT-CHARS BP-BEFORE SPACE (1- NSPACES)))
    (MOVE-BP BP-AFTER (BP-LINE BP-BEFORE) (+ (BP-INDEX BP-AFTER) NSPACES -1))
    BP-AFTER))

(DEFCOM COM-UNTABIFY
	"Replace all tab characters in the buffer with the equivalent number of spaces.
With a region marked, only untabify the region." ()
  (WITH-BOUNDED-INTERVAL (REGION-P)
    (WITH-INTERVAL-WRITE-LOCKED (*INTERVAL*)
      (WITH-UNDO-SAVE ("Untabify" *INTERVAL*)
	(LOOP WITH BP = (INTERVAL-FIRST-BP *INTERVAL*)
	      WHILE (SETQ BP (SEARCH BP #\TAB))
	      DO (TAB-CONVERT (FORWARD-CHAR BP -1) BP)))))
  DIS-TEXT)

(DEFCOM COM-TABIFY
	"Replace as many space characters in the buffer as possible with equivalent tabs.
With a region marked, only tabify the region." ()
  (WITH-BOUNDED-INTERVAL (REGION-P)
    (WITH-INTERVAL-WRITE-LOCKED (*INTERVAL*)
      (WITH-UNDO-SAVE ("Tabify" *INTERVAL*)
	(DO ((BP (INTERVAL-FIRST-BP *INTERVAL*) (BEG-LINE BP 1))
	     (MINIMUM (TV:SHEET-TAB-WIDTH (WINDOW-SHEET *WINDOW*)))
	     INDENTATION)
	    ((NULL BP))
	  (SETQ INDENTATION (LINE-INDENTATION (BP-LINE BP)))
	  (COND (( INDENTATION MINIMUM)
		 (DELETE-INTERVAL BP (FORWARD-OVER *WHITESPACE-CHARS* BP))
		 (INDENT-LINE BP INDENTATION)))))))
  DIS-TEXT)

(DEFCOM COM-INDENT-FOR-LISP-COMMENTS-SPECIAL 
	"Like LISP tab, except in comments, where is it self inserting." ()
  (LET ((POINT (POINT))
	IN-COMMENT)
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK POINT))
      (MULTIPLE-VALUE (NIL NIL IN-COMMENT)
	(LISP-BP-SYNTACTIC-CONTEXT POINT))
      (IF IN-COMMENT	;(AND IN-COMMENT (ZEROP (FIND-COMMENT-START (BP-LINE POINT))))
	  (COM-INSERT-TAB)
	(COM-INDENT-FOR-LISP)))))

(DEFCOM COM-INDENT-FOR-LISP "Indent this line to make ground LISP code.
Numeric argument is number of lines to indent." ()
  (LET ((PT (POINT))
	END)
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK PT))
      (SETQ END (OR (BEG-LINE PT *NUMERIC-ARG*)
		    (INTERVAL-LAST-BP *INTERVAL*)))
      (SETQ END (INDENT-INTERVAL-FOR-LISP (BEG-LINE PT) END NIL NIL *NUMERIC-ARG-P*))
      (IF (= *NUMERIC-ARG* 1)
	  (INDENT-BP-ADJUSTMENT PT)
	  (MOVE-POINT END))))
  DIS-TEXT)

;; Changed to "do the right thing" with respect to *comment-end*, according to SCRC poll.
(DEFCOM COM-INDENT-NEW-LINE
	"Starts a new line, indenting the new line as appropriate for the major mode.
For modes in which comments have explicit end strings, you can use this command
before the end of the comment and the comment end does not move to the new line." ()
  (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
    (WHEN (FIND-COMMENT-START (BP-LINE (POINT)))	;only when there is a comment on this line
      (LET ((CANDIDATE (STRING-TRIM '(#\SPACE #\TAB)	;survive some random spaces
				    (SUBSTRING (BP-LINE (POINT)) (BP-INDEX (POINT))))))
	(IF (AND (> (STRING-LENGTH *COMMENT-END*) 0)	;only when nontrivial comment ender
		 (STRING-EQUAL CANDIDATE *COMMENT-END*));does remainder of line match?
	    (MOVE-POINT (END-LINE (POINT))))))		;so fool it by moving point to end
    (MOVE-POINT (DELETE-BACKWARD-OVER *BLANKS* (POINT)))
    (LET ((*LAST-COMMAND-TYPE* 'INDENT-NEW-LINE)
	  *CURRENT-COMMAND-TYPE*)		;Don't be fooled
      (MAX (IF *INDENT-NEW-LINE-NEW-LINE-FUNCTION*
	       (FUNCALL *INDENT-NEW-LINE-NEW-LINE-FUNCTION*)
	     (KEY-EXECUTE #\CR *NUMERIC-ARG-P* *NUMERIC-ARG*))
	   (IF *INDENT-NEW-LINE-INDENT-FUNCTION*
	       (LET ((*NUMERIC-ARG-P*) (*NUMERIC-ARG* 1))
		 (FUNCALL *INDENT-NEW-LINE-INDENT-FUNCTION*))
	     (KEY-EXECUTE #\TAB))))))

(DEFCOM COM-INDENT-SEXP
	"Indents the following Lisp object representation." ()
  (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
    (LET ((BP2 (OR (FORWARD-SEXP (POINT)) (BARF)))
	  (BP1 (BEG-LINE (POINT) 1 T)))
      (WHEN (BP-< BP1 BP2)
	(INDENT-INTERVAL-FOR-LISP BP1 BP2 T))))
  DIS-TEXT)

(DEFCOM COM-INDENT-NEW-LINE-AT-PREVIOUS-SEXP
	"Inserts a CRLF and the proper indentation at the Lisp object before point." ()
  (LET* ((POINT (POINT))
	 (BP (OR (FORWARD-SEXP POINT (- *NUMERIC-ARG*)) (BARF))))
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK POINT))
      (WITH-BP (OLD-POINT POINT ':NORMAL)
	(MOVE-POINT BP)
	(UNWIND-PROTECT
	    (COM-INDENT-NEW-LINE)
	  (MOVE-POINT OLD-POINT))))))


;;; Text grinding functions

(DEFUN FILL-INTERVAL (START-BP &OPTIONAL END-BP IN-ORDER-P &KEY ADJUST NO-EXTRA-SPACES)
  (ASSURE-SINGLE-SECTION-INTERVAL START-BP END-BP IN-ORDER-P)
  (SETQ START-BP (BEG-LINE START-BP))	;ensure at beginning of first line
  (WITH-INTERVAL-WRITE-LOCKED (START-BP END-BP T)
    (LET* ((START-LINE (BP-LINE START-BP))
	   (END-LINE (LET ((LINE (BP-LINE END-BP)))
		       (IF (OR (LINE-BLANK-P LINE T)
			       (EQ LINE (BP-LINE (INTERVAL-LAST-BP *INTERVAL*))))
			   (LINE-NEXT LINE)
			   LINE)))
	   ;; Copy some parameters into local variables for speed and convenience
	   (PREFIX *FILL-PREFIX*)
	   (PREFLEN (STRING-LENGTH PREFIX))
	   (FILLCOL (- *FILL-COLUMN* (STRING-WIDTH PREFIX)))
	   (PREFIX-MISSING NIL)
	   (PREFIX-ADDED NIL)
	   (BLANKS *BLANKS*)
	   (SENTENCE-ENDING *FILL-EXTRA-SPACE-LIST*)
	   (SENTENCE-ENCLOSING "/"')]")
	   (SHEET (WINDOW-SHEET *WINDOW*))
	   (BP1 (CREATE-BP START-LINE 0))	;Somebody is anxious about consing
	   (BP2 (CREATE-BP START-LINE 0))	;..
	   (INSIDE NIL)				;T when inside a paragraph
	   TEM)
      (WITH-UNDO-SAVE-SPARSE ("fill" START-BP)
	(LOOP ;; Iterate from START-LINE up to but not including END-LINE
	      ;; Local variables for line-breaking and filling
	      WITH OLINE = NIL			;First line not output yet
	      WITH BREAK-INDEX = NIL		;First character in LINE D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")not0 to output
	      WITH X-POS = 0			;Amount of text accepted so far, in pixels
	      WITH START WITH OSTART		;Indices for fill-prefix skipping
	      WITH CHAR-POS WITH INDENT-POS	;Indices for line scanning
	      WITH NEW-X-POS			;Pixel count for line scanning
	      WITH LINE-LENGTH			;(LINE-LENGTH LINE) sometimes
	      WITH PREV-LINE = NIL		;(LINE-PREVIOUS LINE), except LINE can be NIL
	      WITH LINE = START-LINE DO		;Loop until (EQ LINE END-LINE)
	  ;; See if we're ready to output a line, which can be for any of three reasons:
	  (COND ((OR BREAK-INDEX		;We found the next place to put a newline
		     (EQ LINE END-LINE)		;We're done but have to finish the last line
		     (NULL LINE)		;.. (when fell off end of section)
		     (BP-AT-PARAGRAPH-DELIMITER	;We've reached a paragraph break
		       (MOVE-BP BP1 LINE
				(SETQ START (COND ((%STRING-EQUAL LINE 0 PREFIX 0 PREFLEN)
						   PREFLEN)
						  (T
						   (WHEN INSIDE
						     (SETQ PREFIX-MISSING T))
						   0))))))
		 ;; Figure out whether and where to break the line
		 (COND (BREAK-INDEX)			;Already decided
		       ((EQ OLINE LINE)			;Empty paragraph
			(SETQ OLINE NIL INSIDE NIL))
		       (OLINE (SETQ LINE PREV-LINE	;Break just before the current line
				    BREAK-INDEX (LINE-LENGTH LINE))))
		 (WHEN OLINE
		   ;; Make sure the line starts with a fill prefix, unless first in paragraph
		   ;; which could start with a "bullet"
		   (WHEN (AND INSIDE (ZEROP OSTART) (PLUSP PREFLEN))
		     (MOVE-BP BP1 OLINE 0)
		     (MOVE-BP BP2 OLINE (OR (STRING-SEARCH-NOT-SET BLANKS OLINE 0)
					    (LINE-LENGTH OLINE)))
		     (RECORD-SPARSE-CHANGE BP1 BP2 PREFLEN)
		     (LET ((*ENABLE-CHANGE-RECORDING* NIL))
		       (DELETE-INTERVAL BP1 BP2 T)
		       (INSERT-MOVING BP1 PREFIX))
		     (SETQ OSTART PREFLEN)
		     (SETQ PREFIX-ADDED T))
		   (SETQ INSIDE T)		;INSIDE until next paragraph delimiter
		   ;; Close up the output line from OLINE(0) to LINE(BREAK-INDEX)
		   ;; This LOOP is per-line, I starts after any initial indentation
		   (LOOP WITH I = (OR (STRING-SEARCH-NOT-SET BLANKS OLINE OSTART) OSTART)
			 AS LAST = (EQ OLINE LINE)
			 AS NN = (IF LAST BREAK-INDEX (LINE-LENGTH OLINE))
			 AS N = (IF NO-EXTRA-SPACES NN
				    (1+ (OR (STRING-REVERSE-SEARCH-NOT-SET BLANKS OLINE NN I)
					    (1- I)))) DO
		     (UNLESS NO-EXTRA-SPACES
		       ;; Remove excess spaces, except at ends of sentences.
		       (LOOP WHILE (< I N)
			     AS J = (STRING-SEARCH-SET BLANKS OLINE I N) UNTIL (NULL J)
			     AS K = (STRING-REVERSE-SEARCH-NOT-SET SENTENCE-ENCLOSING
								   OLINE J I)
			     AS M = (OR (STRING-SEARCH-NOT-SET BLANKS OLINE J N) N) DO
			 (UNLESS (AND K (MEM #'CHAR-EQUAL (AREF OLINE K) SENTENCE-ENDING))
			   ;; Whitespace from J+1 to M gets deleted, leaving one space
			   (WHEN (> M (1+ J))
			     (DECF N (- M J 1))
			     (WHEN LAST (DECF BREAK-INDEX (- M J 1)))
			     (MOVE-BP BP1 OLINE J)
			     (MOVE-BP BP2 OLINE M)
			     (RECORD-SPARSE-CHANGE BP1 BP2 1)
			     (SETQ M (1+ J))
			     (MOVE-BP BP1 OLINE M)
			     (LET ((*ENABLE-CHANGE-RECORDING* NIL))
			       (DELETE-INTERVAL BP1 BP2 T))))
			 (SETQ I M)))
		     ;; If LAST is false, we are at the end of an input line but not at the
		     ;; end of an output line.  If LAST is true, we are at the end of an
		     ;; output line, but not necessarily at the end of an input line.
		     (MOVE-BP BP1 OLINE N)
		     ;; Set BP2 to remove excess spaces at the end of an output line, or
		     ;; to remove the carriage return and any following fill-prefix at the
		     ;; end of an input line.
		     (IF LAST (MOVE-BP BP2 OLINE BREAK-INDEX)	;after excess spaces
			 (LET ((NEXT (LINE-NEXT OLINE)))	;after carriage return
			   (WHEN (EQ NEXT LINE)
			     (SETQ LINE OLINE))
			   (MOVE-BP BP2 NEXT 0)
			   (WHEN (PLUSP PREFLEN)
			     (COND ((%STRING-EQUAL NEXT 0 PREFIX 0 PREFLEN)
				    (MOVE-BP BP2 NEXT PREFLEN)
				    (WHEN (EQ LINE OLINE)
				      (DECF BREAK-INDEX PREFLEN)))
				   (T
				    (SETQ PREFIX-MISSING T)
				    (MOVE-BP BP2 NEXT
					     (OR (STRING-SEARCH-NOT-SET BLANKS NEXT 0)
						 (LINE-LENGTH NEXT)))
				    (WHEN (EQ LINE OLINE)
				      (DECF BREAK-INDEX (BP-INDEX BP2))))))))
		     ;; Put two spaces at the end of a sentence that ends at the end of
		     ;; an input line, but in the middle of an output line.  Put one space
		     ;; if the end of the input line is not the end of a sentence.
		     ;; Put carriage return and fill-prefix at end of an output line.
		     (LET ((NEW-LENGTH
			     (IF (NOT LAST)
				 (LOOP FOR CH BEING EACH ARRAY-ELEMENT OF OLINE
					   DOWNFROM (1- N) TO 0
				       WHILE (STRING-SEARCH-CHAR CH SENTENCE-ENCLOSING)
				       FINALLY 
					 (RETURN (IF (MEM #'CHAR-EQUAL CH SENTENCE-ENDING)
						     2 1)))
				 (IF (= BREAK-INDEX (LINE-LENGTH OLINE))
				     0		;Output line already ends
				     (1+ PREFLEN)))))
		       (RECORD-SPARSE-CHANGE BP1 BP2 NEW-LENGTH)
		       (LET ((*ENABLE-CHANGE-RECORDING* NIL))
			 (DELETE-INTERVAL BP1 BP2 T)
			 (WHEN LAST
			   ;; Line has been closed up
			   (UNLESS (ZEROP NEW-LENGTH)
			     ;; Insert a Return and a fill-prefix to break the line
			     (INSERT-MOVING BP1 #\RETURN)
			     (INSERT-MOVING BP1 PREFIX)
			     (SETQ START PREFLEN)
			     (SETQ PREFIX-ADDED T))
			   (RETURN))
			 (LOOP REPEAT NEW-LENGTH
			       WITH STYLE = (SI:CHAR-STYLE-INDEX (BP-CHAR-BEFORE BP1)) DO
			   (INSERT-MOVING BP1 (IN-CURRENT-STYLE #\SPACE STYLE)))
			 (SETQ I (BP-INDEX BP1))
			 (WHEN (EQ LINE OLINE)
			   (INCF BREAK-INDEX I))))))
		 ;; Done with LINE, ready to work on next line
		 (SETQ X-POS 0 BREAK-INDEX NIL PREV-LINE LINE
		       LINE (LINE-NEXT LINE)
		       OLINE NIL OSTART NIL)	;No paragraph started yet
		 (WHEN (OR (EQ LINE END-LINE) (NULL LINE))
		   (RETURN NIL)))
		((LINE-BLANK-P LINE T START)
		 ;; Blank lines and diagrams not only delimit paragraphs, but don't get filled
		 (SETQ OLINE NIL INSIDE NIL PREV-LINE LINE LINE (LINE-NEXT LINE)))
		(T
		 (UNLESS OLINE
		   ;; This is the beginning of a paragraph
		   (SETQ OLINE LINE OSTART START))
		 ;; Decide how much of this line can be accumulated into the output line
		 (SETQ CHAR-POS START
		       INDENT-POS (OR (STRING-SEARCH-NOT-SET BLANKS LINE START) CHAR-POS)
		       LINE-LENGTH (LINE-LENGTH LINE))
		 (LOOP NAMED FILL DOING
		   (MULTIPLE-VALUE (NEW-X-POS NIL NIL BREAK-INDEX)
		     (LINE-DISPLAYED-SIZE SHEET LINE CHAR-POS LINE-LENGTH X-POS FILLCOL))
		   ;; BREAK-INDEX is a first estimate of how much of the line will fit, but
		   ;; adjust for space canonicalization within the line, which removes
		   ;; excess spaces except at ends of sentences and beginnings of lines.
		   (WHEN NO-EXTRA-SPACES
		     (RETURN-FROM FILL))
		   (LOOP FOR I = (MAX CHAR-POS INDENT-POS) THEN M WHILE (< I BREAK-INDEX)
			 AS J = (STRING-SEARCH-SET BLANKS LINE I BREAK-INDEX) UNTIL (NULL J)
			 AS K = (STRING-REVERSE-SEARCH-NOT-SET SENTENCE-ENCLOSING LINE J I)
			 AS M = (OR (STRING-SEARCH-NOT-SET BLANKS LINE J BREAK-INDEX)
				    BREAK-INDEX)
			 UNLESS (AND K (MEM #'CHAR-EQUAL (AREF LINE K) SENTENCE-ENDING))
			   SUM (- M J 1) INTO EXTRA-SPACES
			 FINALLY
			   (IF (ZEROP EXTRA-SPACES)
			       (RETURN-FROM FILL)
			       ;; There may be room for more on this line, so try again
			       (SETQ X-POS (- NEW-X-POS (* EXTRA-SPACES (FONT-SPACE-WIDTH)))
				     CHAR-POS BREAK-INDEX))))
		 (IF (< BREAK-INDEX LINE-LENGTH)
		     ;; Line does not all fit, so find the last space within the part of
		     ;; the line that fits, and break it after the last space after that.
		     (SETQ BREAK-INDEX
			   (COND ((SETQ TEM (STRING-REVERSE-SEARCH-SET BLANKS LINE
								(1+ BREAK-INDEX) START))
				  ;; Break after the last space in that sequence of spaces.
				  (OR (STRING-SEARCH-NOT-SET BLANKS LINE TEM)
				      LINE-LENGTH))
				 ((EQ LINE OLINE)
				  ;; Break after a word that is too long to fit even by itself
				  (OR (STRING-SEARCH-NOT-SET BLANKS LINE
					(OR (STRING-SEARCH-SET BLANKS LINE BREAK-INDEX)
					    LINE-LENGTH))
				      LINE-LENGTH))
				 (T
				  ;; Break before a word that is too long to fit even by itself
				  (SETQ LINE PREV-LINE)
				  (LINE-LENGTH LINE))))
		     ;; Whole line fits, advance to the next line
		     ;; and allow for space(s) between this line and the next
		     (LOOP FOR CH BEING EACH ARRAY-ELEMENT OF LINE
			       DOWNFROM (1- LINE-LENGTH) TO 0
			   WITH SPACE-CHAR = NIL
			   DO (UNLESS (OR SPACE-CHAR (MEM #'CHAR-EQUAL CH BLANKS))
				(SETQ SPACE-CHAR (MAKE-CHARACTER #\SPACE
								 :STYLE (SI:CHAR-STYLE CH))))
			   WHILE (OR (STRING-SEARCH-CHAR CH SENTENCE-ENCLOSING)
				     (MEM #'CHAR-EQUAL CH BLANKS))
			   FINALLY 
			     (INCF NEW-X-POS (* (IF (MEM #'CHAR-EQUAL CH SENTENCE-ENDING) 2 1)
						(SEND SHEET :CHARACTER-WIDTH (OR SPACE-CHAR
										 #\SPACE)))))
		     (SETQ BREAK-INDEX NIL X-POS NEW-X-POS
			   PREV-LINE LINE LINE (LINE-NEXT LINE)))))))
      ;; Adjusting is a separate pass and separately undoable because that makes it
      ;; a lot easier to record the changes in sequential order
      (WHEN ADJUST
	(WITH-UNDO-SAVE-SPARSE ("adjust" START-BP)
	  ;; Iterate from START-LINE up to but not including END-LINE
	  (LOOP FOR THIS-LINE = START-LINE THEN (LINE-NEXT THIS-LINE)
		UNTIL (EQ THIS-LINE END-LINE)
		AS LINE = OLINE			;Previous line, or NIL if not to be adjusted
		AS START = OSTART		;Index of end of fill-prefix on that line
		AS OLINE = THIS-LINE		;Next value of LINE
		AS OSTART = (IF (%STRING-EQUAL OLINE 0 PREFIX 0 PREFLEN) PREFLEN 0)
		WITH SHEET = (WINDOW-SHEET *WINDOW*) DO
	    (COND ((OR (BP-AT-PARAGRAPH-DELIMITER (MOVE-BP BP1 OLINE OSTART))
		       (LINE-BLANK-P OLINE T OSTART))
		   (SETQ OLINE NIL))		;No need to adjust this line, nor previous
		  (LINE				;Adjust all but the last line of each paragraph
		   ;; Count the number of blank places in the line.
		   ;; Count adjacent blank characters only once.
		   (LET* ((LINE-LENGTH (LINE-LENGTH LINE))
			  (NBLANKS (LOOP FOR FIRST = T THEN NIL
					 FOR OCP = (1- START) THEN CP
					 FOR CP = (STRING-SEARCH-CHAR #\SPACE LINE
								      (1+ OCP) LINE-LENGTH)
					 WHILE CP
					 COUNTING (OR ( OCP (1- CP)) FIRST)))
			  (SPACE-CHAR (LINE-INDENTATION-SPACE-CHAR LINE START LINE-LENGTH))
			  (SW (SEND SHEET :CHARACTER-WIDTH SPACE-CHAR))
			  (NEEDED (// (- FILLCOL (STRING-WIDTH LINE START LINE-LENGTH SHEET))
				      SW))
			  (AVG (IF (ZEROP NBLANKS) 0 (// NEEDED NBLANKS)))
			  (EXTRA (IF (ZEROP NBLANKS) 0 (\ NEEDED NBLANKS)))
			  (EXPER (IF (ZEROP EXTRA) 0 (CEILING NBLANKS EXTRA))))
		     (DO ((N NBLANKS (1- N))
			  (EXP EXPER (1- EXP))
			  (I AVG AVG))
			 ((= N 0))
		       (UNLESS (SETQ START (STRING-SEARCH-CHAR #\SPACE LINE START))
			 (ERROR "Not enough spaces to adjust with in ~S" LINE))
		       (AND (> EXTRA 0) (= EXP 1)
			    (SETQ I (1+ I)
				  EXTRA (1- EXTRA)
				  EXP EXPER))
		       (MOVE-BP BP1 LINE START)
		       (RECORD-SPARSE-CHANGE BP1 BP1 I)
		       (LET ((*ENABLE-CHANGE-RECORDING* NIL))
			 (INSERT-CHARS BP1 SPACE-CHAR I))
		       (SETQ START (OR (STRING-SEARCH-NOT-CHAR #\SPACE LINE START)
				       (LINE-LENGTH LINE))))))))))

      ;; Report any fill-prefix that was added and wasn't there before.
      (WHEN (AND PREFIX-ADDED PREFIX-MISSING (PLUSP PREFLEN))
	(TYPEIN-LINE "Fill prefix for this buffer = /"~A/"" PREFIX)
	(WHEN (SETQ PREFIX (KEY-FOR-COMMAND 'COM-SET-FILL-PREFIX))
	  (TYPEIN-LINE-MORE "~%The ~A command sets the fill prefix." PREFIX))))))

;; Common indenter for Tab, C-M-Q, and friends
(DEFUN INDENT-INTERVAL-FOR-LISP (BP1 &OPTIONAL BP2 IN-ORDER-P START-BP (COMMENTS-P T))
  (ASSURE-SINGLE-SECTION-INTERVAL BP1 BP2 IN-ORDER-P)
  (OR START-BP (SETQ START-BP (FORWARD-DEFINITION BP1 -1 T)))
  (LISP-PARSE-FROM-DEFINITION (BP-LINE BP2) START-BP)
  (INTERVAL-LINES (BP1 BP2) (START-LINE STOP-LINE)
    ;; Kludge around bug in INTERVAL-LINES at end of buffer
    (WHEN (EQ START-LINE STOP-LINE)
      ;; Kludge around another bug in INTERVAL-LINES when both bp's are in the
      ;; middle of the last line in the buffer
      (WHEN (NULL START-LINE)
	(RETURN-FROM INDENT-INTERVAL-FOR-LISP BP2))
      (SETQ STOP-LINE (LINE-NEXT-IN-BUFFER STOP-LINE)))
    (WITH-UNDO-SAVE-SPARSE ("Lisp indent" (CREATE-BP START-LINE 0))
      (DO ((LINE START-LINE (LINE-NEXT-IN-BUFFER LINE))
	   (*LISP-PARSE-PREPARSED-FLAG* T)
	   (BLANKS *BLANKS*)
	   (BP)
	   (INDENTATION)
	   (IN-STRING))
	  ((EQ LINE STOP-LINE) BP2)
	(SETQ BP (CREATE-BP LINE 0))
	(COND ((AND COMMENTS-P
		    (LET ((START (FIND-COMMENT-START LINE)))
		      (NOT (STRING-SEARCH-NOT-SET BLANKS LINE 0 START))))
	       ;; There is nothing on this line but a comment.  Don't indent the same text
	       ;; twice, which would be a waste and would blow out in RECORD-SPARSE-CHANGE
	       (SETQ INDENTATION NIL))
	      (T
	       (MULTIPLE-VALUE (INDENTATION IN-STRING)
		 (INDENT-FOR-LISP BP START-BP))))
	(COND ((NOT IN-STRING)			;Dont touch lines inside a string
	       (AND INDENTATION (INDENT-LINE BP INDENTATION))
	       (AND COMMENTS-P (INDENT-FOR-COMMENT BP))))
	(OR (EQ (LINE-NEXT-IN-BUFFER LINE) STOP-LINE)
	    (LISP-PARSE-LINE-MEMOIZED LINE IN-STRING))))))

(DEFUN SYMBOL-AT-PAREN (BP)
  (LET ((BP2 (FORWARD-CHAR BP)))
    (WHEN BP2
      (LET* ((I (BP-INDEX BP2))
	     (SYM (DO ((J I (1+ J))
		       (LINE (BP-LINE BP2))
		       (LENGTH (LINE-LENGTH (BP-LINE BP2))))
		      ((OR ( J LENGTH)
			   (LET ((SYNTAX (LIST-SYNTAX (AREF LINE J))))
			     (NOT (OR (= SYNTAX LIST-ALPHABETIC)
				      (= SYNTAX LIST-COLON)))))
		       (AND ( I J)
			    (CONDITION-CASE ()
				 (LET ((SI:*SUPPRESS-READ-EVAL* T))
				   (READ-FROM-STRING (NSUBSTRING LINE I J)))
			       (SYS:READ-ERROR NIL)))))))
	;; Beware of funny read syntax, numbers, etc.
	(AND (SYMBOLP SYM) SYM)))))

(DEFVAR *DEFINITION-LIST-FUNCTIONS*
	'(LISP:FLET FUTURE-COMMON-LISP:FLET
	   LISP:LABELS FUTURE-COMMON-LISP:LABELS
	   LISP:MACROLET FUTURE-COMMON-LISP:MACROLET
	   CLOS:GENERIC-FLET CLOS:GENERIC-LABELS))
(DEFCONST *DEFINITION-LIST-INDENTATION-RULES* '(0 2 1 1))
(DEFCONST *FLET-SEARCH-DISABLE* NIL)
(DEFCONST *FLET-SEARCH-STOP-AT-FUNCTION* T)		;Plummer heuristic

#|
;;; Useful tool for revising *DEFINITION-LIST-FUNCTIONS* after symbol splits and
;;; things like that.  Compile this, run it, decide which of the symbols it returns
;;; you want in *DEFIUNITION-LIST-FUNCTIONS* and put them there.
(defun find-definition-list-symbols ()
  (let ((d-l-s nil))
    (future-common-lisp:with-package-iterator (next si:*all-packages* :external)
      (loop
	(multiple-value-bind (more-p symbol how package)
	    (next)
	  package how
	  (unless more-p (return))
	  (let ((name (symbol-name symbol)))
	    (when (or (string= name "MACROLET")
		      (string= name "FLET")
		      (string= name "LABELS"))
	      (setq d-l-s (adjoin symbol d-l-s)))))))
    (sort d-l-s #'string< :key #'symbol-name)))
|#

(DEFUN LISP-INDENT-FLET-P (LASTPAREN BP1)
  (LET ((BACK1 (FORWARD-SEXP LASTPAREN -1 NIL 1 BP1 NIL)))
    (WHEN (AND BACK1				;gotta be "((" at one level up for FLET &c.
	       (LET ((FBP (FORWARD-OVER *WHITESPACE-CHARS* BACK1) ))
		 (= (LIST-SYNTAX (BP-CHAR FBP))
		    LIST-OPEN)))
      (LET ((BACK2 (FORWARD-SEXP BACK1 -1 NIL 1 BP1 NIL)))
	(WHEN BACK2
	  (AND (MEMQ (SYMBOL-AT-PAREN BACK2) *DEFINITION-LIST-FUNCTIONS*)
	       ;; This must be in the first sublist of the FLET/&c.
	       (LET ((BACK1.5 (FORWARD-SEXP BACK1 -1 NIL 0 BP1)))
		 (AND BACK1.5 (BP-= (FORWARD-CHAR BACK2 1) BACK1.5 )))))))))

;; This returns the amount of indentation that you want.
;; *LISP-INDENT-OFFSET* is the amount to offset if there isnt a complete sexp on another line
;; *LISP-DEFUN-INDENTATION* is the amount to indent for top-level forms
;; *LISP-INDENTATION-OFFSET-HASH-TABLE* is a table of the form FUNCTION  OFFSET-LIST
;;					or possibly NIL.
;; OFFSET-LIST is a list specifying (number-of-sexps-to-skip amount-to-change-indentation ...)
;; or if OFFSET-LIST is a symbol or function, it is funcall'ed and can return
;; the indentation, an offset, or a bp whose indentation to use
;; *LISP-INDENTATION-OFFSET-HASH-TABLE* is added to by the DEFMACRO &BODY construct.
(defun indent-for-lisp (bp &optional start-definition-bp
			   &aux bp1 bp2 indentation offset sym
			   tem space-width nsexps lastparen lastsexp in-string
			   flet-p)
  (prog ((blanks *blanks*))
    (setq bp (create-bp (bp-line bp) 0)
	  bp1 (or start-definition-bp
		  (setq start-definition-bp (forward-definition bp -1 t))))
    (setq in-string (lisp-parse-from-definition (bp-line bp) bp1))
    (and in-string (return (values 0 in-string)))
    ;; Get BP to last unterminated paren (up one level).  Sixth argument of NIL makes
    ;; sure we get an open paren and not a single-quote (forward or backward).
    (setq lastparen (forward-sexp bp -1 nil 1 bp1 nil))
    ;; Get BP to start of last complete sexp, or NIL if none at this level.
    (setq lastsexp (forward-sexp bp -1 nil 0 bp1))
    (and lastparen lastsexp (bp-= lastsexp lastparen) (setq lastsexp nil))
    (setq offset 0
	  space-width (font-space-width))
    (when lastparen		     ;Try to find the indentation for the current function
      (setq sym (setq sym (symbol-at-paren lastparen)))
      (when (not *flet-search-disable*)
	;; This magic asks, "Is the list containing the list containing this list
	;; FLET, MACROLET, or LABELS?", in which case special rules are to be used
	;; for the indentation of this list.
	(cond ((null sym))
	      ((and *flet-search-stop-at-function* (fdefinedp sym)))	;not flet, etc.
	      (t (setq flet-p (lisp-indent-flet-p lastparen bp1))))))
    (and sym
	 (setq tem
	       (if flet-p
		   *definition-list-indentation-rules*
		 (multiple-value-bind (value found)
		     (GET-INDENTATION SYM)
		   (COND (FOUND VALUE)
			 ((AND (KEYWORDP SYM)
			       (EQ (BP-LINE LASTPAREN)
				   (BP-LINE (FORWARD-ATOM LASTPAREN 2))))
			  '(1 0))
			 ((STRING-EQUAL SYM "DEF" 0 0 3 3)
			  *LISP-DEFUN-INDENTATION*)))))
	 ;; This function on the alist => value is either
	 ;; an indentation list or a function to call.
	 (COND ((LISTP TEM)         ;Indentation list, see how do handle this depth
		;; How many sexps at this level precede point?  Set NSEXPS.
		;; But, first, let's see how many are interesting (that's (1- MAX-I) ).
		;; Don't keep counting NSEXPS when it's already larger than is interesting.
		(DO ((BP3 (FORWARD-CHAR LASTPAREN 1) (FORWARD-SEXP BP3 1 NIL 0 BP))
		     (MAX-I (1+ (CAR (NLEFT 2 TEM))))
		     (I 0 (1+ I)))
		    ((NULL BP3) (SETQ NSEXPS (- I 2)))
		  (AND (> I MAX-I) (RETURN NIL)))
		;; Now see what the indentation lists says about that many sexps.
		(AND NSEXPS
		     (DO ((L TEM (CDDR L))
			  (I 0))
			 ((OR (NULL L) (> I NSEXPS)))
		       (AND (= (SETQ I (CAR L)) NSEXPS)
			    (SETQ OFFSET (CADR L) LASTSEXP NIL)))))
	       (T
		(MULTIPLE-VALUE (BP2 INDENTATION OFFSET)
		  (FUNCALL TEM BP1 BP LASTPAREN LASTSEXP SPACE-WIDTH SYM)))))
    (SETQ BP1 (DO () (NIL)
		(COND ((NULL LASTPAREN)		;If already balanced, nothing to do
		       (RETURN BP))
		      (BP2			;Specified what to indent to
		       (RETURN BP2))
		      (INDENTATION)		;Specified how far to indent
		      ;; If there is no complete sexp at this paren depth, line up just after
		      ;; the leftparen.
		      ((OR (NULL LASTSEXP) (BP-< LASTSEXP LASTPAREN))
		       (RETURN (FORWARD-CHAR LASTPAREN)))
		      (T
		       (SETQ BP1 (CREATE-BP (BP-LINE LASTSEXP) 0))
		       ;; If complete sexp is on different line than the unmatched leftparen,
		       ;; line up with start of sexp's line.
		       (COND ((OR (NULL LASTPAREN) (BP-< LASTPAREN BP1))
			      (SETQ BP1 (FORWARD-OVER BLANKS BP1))
			      ;; OK only if the first on the line or at that level.
			      (AND (OR (BP-= BP1 LASTSEXP)
				       (FORWARD-SEXP LASTSEXP -1 NIL 0 BP1))
				   (RETURN BP1))
			      (SETQ BP1 LASTPAREN
				    LASTPAREN (FORWARD-SEXP LASTSEXP -1 NIL 1 LASTPAREN NIL)
				    LASTSEXP (FORWARD-SEXP LASTSEXP -1 NIL 0 LASTPAREN)))
			     ;; Otherwise, maybe user specified how to handle this case
			     (*LISP-INDENT-OFFSET*
			      (SETQ OFFSET (+ *LISP-INDENT-OFFSET* OFFSET))
			      (RETURN (FORWARD-CHAR LASTPAREN)))
			     ;; If only one element in list so far, line up under left-paren
			     ;; also if the CAR doesnt look like the name of a function
			     ((INDENT-NOT-FUNCTION-P LASTPAREN
						     (SETQ BP2 (FORWARD-CHAR LASTPAREN))
						     START-DEFINITION-BP)
			      (RETURN BP2))
			     ((BP-< LASTSEXP (SETQ BP1 (FORWARD-SEXP BP2 1 T)))
			      (SETQ OFFSET (LONE-FUNCTION-OFFSET LASTPAREN START-DEFINITION-BP))
			      (RETURN BP2))
			     ;; Otherwise line up with start of the
			     ;; second element of that list
			     (T
			      (RETURN (SKIP-OVER-BLANK-LINES-AND-COMMENTS
					(SKIP-OVER-BLANK-LINES-AND-COMMENTS BP1)))))))))
    (OR INDENTATION (SETQ INDENTATION (+ (* OFFSET SPACE-WIDTH) (BP-INDENTATION BP1))))
    (RETURN (VALUES INDENTATION IN-STRING))))

(DEFVAR *NOT-LONE-FUNCTION-SUPERIORS* '(COND SELECT SELECTQ DEFFLAVOR))
(DEFUN LONE-FUNCTION-OFFSET (BP START-DEFINITION-BP &AUX SUPBP LINE IDX)
  (IF (AND (NOT (BEG-LINE-P BP))
	   (SETQ SUPBP (FORWARD-SEXP BP -1 NIL 1 START-DEFINITION-BP NIL))
	   (EQ (SETQ IDX (BP-INDEX (IBP SUPBP)) LINE (BP-LINE SUPBP))
	       (BP-LINE (SETQ SUPBP (FORWARD-SEXP SUPBP))))
	   (MEMQ (INTERN-SOFT (STRING-UPCASE (NSUBSTRING LINE IDX (BP-INDEX SUPBP))))
		 *NOT-LONE-FUNCTION-SUPERIORS*))
      0
      *LISP-INDENT-LONE-FUNCTION-OFFSET*))

(DEFVAR *INDENT-NOT-FUNCTION-SUPERIORS* '(LET LET* LET-GLOBALLY LAMBDA
					      FUTURE-COMMON-LISP:LAMBDA PROG PROG*
					  MULTIPLE-VALUE MULTIPLE-VALUE-BIND
					  (DEFUN 2) (DEFMACRO 2) (DEFFLAVOR 3)))

(DEFUN INDENT-NOT-FUNCTION-P (BP BP2 LIMIT-BP &AUX SUPBP LINE IDX TEM)
  (OR (AND ( (LIST-SYNTAX (SETQ TEM (BP-CHAR BP2))) LIST-ALPHABETIC)
	   (NOT (MEM #'CHAR-EQUAL TEM '(#// #/| #/:))))		;These are really atoms
      (AND (NOT (BEG-LINE-P BP))
	   (SETQ SUPBP (FORWARD-SEXP BP -1 NIL 1 LIMIT-BP NIL))
	   (EQ (SETQ IDX (BP-INDEX (IBP SUPBP)) LINE (BP-LINE SUPBP))
	       (BP-LINE (SETQ SUPBP (FORWARD-SEXP SUPBP))))
	   (SETQ TEM (DO ((SYM (INTERN-SOFT (STRING-UPCASE (NSUBSTRING LINE IDX
								       (BP-INDEX SUPBP)))))
			  (L *INDENT-NOT-FUNCTION-SUPERIORS* (CDR L)))
			 ((NULL L) NIL)
		       (AND (EQ SYM (IF (ATOM (CAR L)) (CAR L) (CAAR L)))
			    (RETURN (CAR L)))))
	   (BP-= BP (FORWARD-OVER *WHITESPACE-CHARS* (IF (ATOM TEM) SUPBP
							 (FORWARD-SEXP SUPBP
								       (1- (CADR TEM))
								       T)))))))

;; This is the default indenter for PROGs; tags and forms must be handled separately.
(DEFVAR *PROG-TAG-INDENT-OFFSET* -3)
(DEFVAR *PROG-FORM-INDENT-OFFSET* 0)

(DEFUN INDENT-PROG (IGNORE BP LASTPAREN &REST IGNORE)
  (INDENT-PROG-OR-TAGBODY 'PROG BP LASTPAREN))

(DEFUN INDENT-TAGBODY (IGNORE BP LASTPAREN &REST IGNORE)
  (INDENT-PROG-OR-TAGBODY 'TAGBODY BP LASTPAREN))

(DEFUN INDENT-%BLOCK-READ-TEST-TAGBODY (IGNORE BP LASTPAREN &REST IGNORE)
  (LET ((*PROG-TAG-INDENT-OFFSET* -24.)
	(*PROG-FORM-INDENT-OFFSET* -20.))
    (INDENT-PROG-OR-TAGBODY 'PROG BP LASTPAREN)))

;; Put this here rather than in an Ivory-dependent file so that indentation works
;; on 3600s.
(DEFINDENTATION (SI:%BLOCK-READ-TEST-TAGBODY . INDENT-%BLOCK-READ-TEST-TAGBODY))

(DEFUN INDENT-PROG-OR-TAGBODY (WHAT BP LASTPAREN)
  (LET ((BEG (BP-LINE BP))
	BP1
	(OFFSET 0))
    (LET* ((ATOM-P (EQ (LINE-TYPE BEG) ':ATOM))
	   (NFORMS (SELECTQ WHAT
		     (PROG 3)
		     (TAGBODY 2)))
	   (BP2 (FORWARD-SEXP
		  (FORWARD-SEXP (FORWARD-CHAR LASTPAREN) NFORMS T 0 BP)
		  -1))
	   (FLAG)
	   (BLANKS *BLANKS*)
	   (WHITESPACE-CHARS *WHITESPACE-CHARS*))
      (AND BP2
	   (DO ((LINE))
	       (NIL)
	     (DO () (NIL)
	       (SETQ BP2 (FORWARD-OVER WHITESPACE-CHARS BP2))
	       (WHEN ( (LIST-SYNTAX (BP-CHAR BP2)) LIST-COMMENT)
		 (RETURN NIL))
	       ;; Move over any comments
	       (SETQ BP2 (FORWARD-LINE BP2 1 NIL)))
	     (OR (BP-< BP2 BP) (RETURN NIL))
	     (AND (BEG-LINE-P (BACKWARD-OVER BLANKS BP2))
		  (NEQ (SETQ LINE (BP-LINE BP2)) BEG)
		  (IF (EQ (EQ (LINE-TYPE LINE) ':ATOM) ATOM-P)
		      (SETQ BP1 BP2)
		    (SETQ FLAG T)))		;Remember if must reverse offset
	     (OR (SETQ BP2 (FORWARD-SEXP BP2 1 NIL 0 BP))
		 (RETURN NIL))))
      (COND ((NULL BP1)
	     (SETQ OFFSET (IF ATOM-P *PROG-TAG-INDENT-OFFSET*
				     *PROG-FORM-INDENT-OFFSET*))
	     (AND FLAG
		  (SETQ OFFSET (- OFFSET (IF ATOM-P *PROG-FORM-INDENT-OFFSET*
						    *PROG-TAG-INDENT-OFFSET*)))))))
    (VALUES BP1 NIL OFFSET)))
;; The rule is that the qualifiers and arglist indent under the function name,
;; while the stuff after the arglist just indents by 2
(defun indent-for-clos-defmethod (start-definition-bp start-line-bp lastparen lastsexp
				  space-width sym)
  (declare (ignore start-definition-bp lastsexp space-width sym))
  (let ((function-name-bp nil)
	(bp (forward-char lastparen 1)))
    ;; lastparen is the start of the defmethod form
    ;; start-line-bp is the start of the current line
    ;; function-name-bp is the start of the generic function name
    ;; bp moves over the subforms of the defmethod form
    (loop for n from 1 do
      (setq bp (forward-sexp bp 1 nil 0 start-line-bp))
      (when (null bp)				;no more sexps before the current line
	(return (if function-name-bp
		    (values function-name-bp nil 0)	;indent under the function name
		    (values lastparen nil 4))))		;indent 4 if no subforms at all
      (cond ((= n 2)
	     ;; bp points after the function-name
	     (setq function-name-bp (forward-sexp bp -1)))
	    ((and (> n 2) (= (list-syntax (bp-char-before bp)) list-close))
	     ;; bp points after the lambda-list (if it wasn't in parentheses,
	     ;; it would be a a qualifier).  Since we're after the lambda-list,
	     ;; indent as a body.
	     (return (values lastparen nil 2)))))))

#| To allow lisp code in comment |
;; This is an indentor for LOOP that works pretty well, but doesn't
;; always do the right thing because "the right thing" may depend on
;; forms after the line you are trying to indent.  Examples of this:
    (loop for a being the array-elements of b
	      ;; comment
	  do (frob a))
;; happens because you might instead be doing this
    (loop for a being the array-elements of b
	      ;; comment
	      using (sequence b) (index i)
	  do (frob a))
;; It also second guess on a few things, but gets them right after you
;; type a token on a line and hit TAB.  For example,
    (loop when x
	    do (y)    ;comment
	       (z))
;; which is correct, and this is how the indentation initially reads.
;; If (z) had been DO, it would have put the DO where the (z) is, but
;; hitting tab would reindent it correctly:
    (loop when x
	    do (y)    ;comment
	  do (z))
;; The converse can come up, for example
    (loop with x      ;comment
	  do (z))
;; if the DO been =, it would have been indented incorrectly until tab
;; was hit, resulting in
    (loop with x
	    = (z))
| End of comment |#

(defvar *inhibit-fancy-loop-indentation* nil)
(defun indent-loop (ignore bp loop-paren &rest ignore)
  (declare (values bp indentation offset))
  (if *inhibit-fancy-loop-indentation*
      (values nil nil 0)
    (loop with whitespace-chars = *whitespace-chars*
	  with line-type = (line-type (bp-line bp))
	  with start-bp = (forward-over whitespace-chars (forward-word loop-paren))
	  with keyword-bp = start-bp
	  with (conditional-bp body-bp)
	  with offset = 0
	  with and-bp = start-bp and and-offset = 0 and and-gobble = nil
	  with gobble
	  with bp-now = start-bp
	  initially
	    ;; Quick check for CL:LOOP, which simply takes a body
	    (when (or (char-equal (bp-char start-bp) #/()
		      (char-equal (bp-char start-bp) #/;))
	      (return-from indent-loop (values nil nil 0)))
	    ;; OK, go all out
	    (let* ((line-type-atom (eq line-type :atom))
		   (beg-word (forward-over whitespace-chars (create-bp (bp-line bp) 0)))
		   (end-word (forward-atom beg-word))
		   (word (if end-word (string-interval beg-word end-word) "")))
	      (cond
		;; Handle comments later
		((eq line-type :comment)
		 (si:loop-finish))
		;; Indent "statements" at the level of the end of "LOOP"
		((and line-type-atom
		      (mem #'string-equal (setq gobble word)
			   '("WITH" "FOR" "AS" "REPEAT"
			     "INITIALLY" "FINALLY"
			     "WHILE" "UNTIL")))
		 (si:loop-finish))
		;; These get indented to fall under the "UPFROM" (or whatever)
		((and line-type-atom
		      (mem #'string-equal word
			   '("THEN" "BELOW" "ABOVE" "BY" "TO"
			     "USING" "WITH-KEY" "WITH-INDEX")))
		 (loop for for-bp = bp then (forward-atom for-bp -1)
		       as end-word = (forward-atom for-bp)
		       until (mem #'string-equal
				  (string-interval for-bp end-word)
				  '("FOR" "AS"))
		       finally
			 (let* ((bp1 (forward-atom end-word))
				(bp2 (forward-atom bp1))
				(bp3 (forward-atom bp2))
				(bp (cond
				      ((eq (bp-line for-bp) (bp-line bp3)) bp1)
				      ((eq (bp-line for-bp) (bp-line bp2)) end-word)
				      ((eq (bp-line for-bp) (bp-line bp1)) end-word)
				      (t (forward-char for-bp -1)))))
			   (setq offset (1+ (- (bp-index bp) (bp-index for-bp))))))
		 (si:loop-finish))
		;; Just skip "AND"
		((and line-type-atom
		      (string-equal gobble "AND")))
		;; Implicit progn at the beginning of a line
		((let ((back-sexp (forward-sexp bp -1)))
		   (when (and back-sexp (char-equal (bp-char back-sexp) #/())
		     (let ((back2 (forward-sexp back-sexp -1)))
		       (when (and back-sexp
				  (or (char-equal (bp-char back2) #/()
				      (mem #'string-equal
					   (string-interval back2 (forward-atom back2))
					   '("DO" "DOING"
					     "INITIALLY" "FINALLY" "USING"))))
			 (setq keyword-bp nil
			       body-bp	  back-sexp
			       offset	  0)
			 t))))
		 (si:loop-finish))))
	  while (bp-< bp-now bp)
	  as bp-after-word = (forward-atom bp-now)
	  as key = (string-interval bp-now bp-after-word)
	  as bp-after-space =
	     (let ((bp (forward-over whitespace-chars bp-after-word)))
	       (if (char-equal (bp-char bp) #/;)	;don't indent out to comment field
		   (forward-over whitespace-chars (forward-line bp 1 t))
		 bp))
	  as same-line = (eq (bp-line bp-after-word) (bp-line bp-after-space))
	  do (multiple-value (keyword-bp conditional-bp body-bp offset gobble)
	       (cond ((mem #'string-equal key '("WHEN" "IF" "UNLESS"))
		      (setq and-bp bp-now and-offset 2 and-gobble nil)
		      (values nil bp-now nil +2 t))
		     ((string-equal key "ELSE")
		      (multiple-value (and-bp and-offset and-gobble)
			(if same-line
			    (values bp-after-space 0 nil)
			  (values bp-now 2 nil)))
		      (values nil bp-now nil +2 nil))
		     ((mem #'string-equal key '("DO" "DOING"))
		      (cond (conditional-bp
			     (values nil nil bp-now +2 t))
			    (same-line
			     (values nil nil bp-after-space 0 t))
			    (t (values nil nil loop-paren 2 t))))
		     ((mem #'string-equal key '("INITIALLY" "FINALLY" "RETURN"))
		      (if same-line
			  (values nil nil bp-after-space 0 t)
			(values nil nil bp-now 2 t)))
		     ((mem #'string-equal key '("FOR" "AS"))
		      (setq and-bp bp-now and-offset 0 and-gobble t)
		      (values bp-after-space nil nil 0 t))
		     ((mem #'string-equal key '("WITH"))
		      (setq and-bp bp-now and-offset 0 and-gobble t)
		      (values bp-now nil nil 2 t))
		     ((loop-keyword-p key)
		      (values bp-now nil nil 2 t))
		     ((mem #'string-equal key '("AND"))
		      (values keyword-bp conditional-bp body-bp offset
			      and-gobble))
		     (t (values keyword-bp conditional-bp body-bp offset
				(loop-aux-keyword-p key)))))
	     (when gobble (setq bp-now bp-after-space))
	     ;; Skip over the form and get to next candidate
	     (setq bp-now (or (forward-sexp bp-now) bp-now)
		   bp-now (or (skip-over-blank-lines-and-comments bp-now t) bp-now)
		   bp-now (forward-over whitespace-chars bp-now))
	  finally
	    (return 
	      (selectq line-type
		(:blank
		 (if (or conditional-bp body-bp)
		     (values (or conditional-bp body-bp) nil offset)
		   (values start-bp nil 0)))	       
		(:atom
		 (cond (conditional-bp (values conditional-bp nil offset))
		       ((loop-keyword-p
			  (setq key (let* ((beg-word (forward-over
						       whitespace-chars
						       (create-bp (bp-line bp) 0)))
					   (end-word (forward-atom beg-word)))
				      (string-interval beg-word end-word))))
			(values start-bp nil 0))
		       ((string-equal key "AND") (values and-bp nil and-offset))
		       (T (values (or keyword-bp start-bp) nil offset))))
		(:comment
		 (loop for bp1 = (create-bp (bp-line bp) 0) then (forward-sexp bp1 -1)
		       as bp2 = (forward-atom bp1)
		       until (null bp2)
		       as word = (string-interval bp1 bp2)
		       until (or (bp-< bp1 start-bp)
				 (mem #'string-equal word
				      '("FOR" "AS" "WITH" "REPEAT"
					"WHILE" "UNTIL"
					"DO" "DOING"
					"INITIALLY" "FINALLY" "RETURN"
					"IF" "WHEN" "UNLESS" "ELSE")))
		       finally
			 (cond ((bp-< bp1 start-bp)
				(return (values start-bp nil 0)))
			       ((mem #'string-equal word '("DO" "DOING"))
				(cond ((eq (bp-line bp2) (bp-line (forward-atom bp2)))
				       (return (values bp1 nil (1+ (string-length word)))))
				      (t (return (values start-bp nil -4)))))
			       ((mem #'string-equal word '("INITIALLY" "FINALLY" "RETURN"
							   "IF" "WHEN" "UNLESS" "ELSE"))
				(return (values bp1 nil 2)))
			       (t
				(return (values start-bp nil 0))))))
		(otherwise
		  (values (or conditional-bp body-bp
			      keyword-bp start-bp)
			  nil offset)))))))

(defun loop-keyword-p (string)
  (or (loop for (key) in si:loop-iteration-keyword-alist
	    thereis (string-equal key string))
      (loop for (key) in si:loop-keyword-alist
	    thereis (string-equal key string))
      (mem #'string-equal string '("ELSE"))))

(defun loop-aux-keyword-p (string)
  (or (loop for (key) in si:loop-for-keyword-alist
	    thereis (string-equal key string))
      (mem #'string-equal string
	   '("INTO" "OF" "USING" "WITH-KEY" "WITH-INDEX"))))
