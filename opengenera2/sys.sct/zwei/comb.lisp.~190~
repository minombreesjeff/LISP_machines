;;; -*- Syntax: Zetalisp; Mode: LISP; Package: ZWEI; Base: 8 -*-
;;; Zwei commands, see ZWEI;COMA for comments

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(DEFCOM COM-MARK-PAGE
	"Marks a page as the region, with point at top of page, mark at end.
A page is defined by the editor variable Page Delimiter List.
A numeric arg specifies which page to mark:
  0  current page
  1  next page
 -1  previous page
  n  nth page from the current one" (SM)
  (MULTIPLE-VALUE-BIND (BP1 BP2)
      (MARK-PAGE-INTERNAL (POINT) (IF *NUMERIC-ARG-P* *NUMERIC-ARG* 0))
    (MOVE-POINT BP1)
    (MOVE-MARK BP2))
  DIS-BPS)


;;; For COM-MARK-PAGE and COM-SET-BOUNDS-PAGE (latter not yet written).
(DEFUN MARK-PAGE-INTERNAL (BP ARG)
  (COND ((AND (ZEROP ARG)			;if now right after page delim
	      (PLUSP (LINE-LENGTH (BP-LINE BP)))
	      (LOOP FOR CHAR IN *PAGE-DELIMITER-LIST*
		    THEREIS (CHAR-EQUAL CHAR (AREF (BP-LINE BP) 0)))))
						;then don't move point before looking
	(( ARG 0)
	 (DOTIMES (IGNORE (1+ (MINUS ARG)))
	   (SETQ BP (FORWARD-PAGE BP -1 T))))	;move point back enough times
	(T
	 (DOTIMES (IGNORE ARG)
	   (SETQ BP (FORWARD-PAGE BP 1 T)))))	;move point forward enough times
  (VALUES BP (FORWARD-PAGE BP)))		;find the end of the page with point at top

(DEFCOM COM-FORWARD-OVER-MATCHING-DELIMITERS "Move over matching delimiters" (KM)
  (LET ((POINT (POINT))
	(CLOSE) (OPEN))
    (DO ((L *MATCHING-DELIMITER-LIST* (CDR L))
	 (CH *LAST-COMMAND-CHAR*))
	((NULL L))
      (COND ((CHAR-EQUAL CH (CADAR L))
	     (SETQ CLOSE CH
		   OPEN (CAAR L))
	     (RETURN))))
    (MOVE-POINT (OR (FORWARD-OVER-MATCHING-DELIMITERS POINT *NUMERIC-ARG* NIL 0 OPEN CLOSE)
		    (BARF))))
  DIS-BPS)


(DEFCOM COM-BACKWARD-OVER-MATCHING-DELIMITERS "Move over matching delimiters" (KM)
  (LET ((POINT (POINT))
	(CLOSE) (OPEN))
    (DO ((L *MATCHING-DELIMITER-LIST* (CDR L))
	 (CH *LAST-COMMAND-CHAR*))
	((NULL L))
      (COND ((CHAR-EQUAL CH (CAAR L))
	     (SETQ OPEN CH
		   CLOSE (CADAR L))
	     (RETURN))))
    (MOVE-POINT (OR (FORWARD-OVER-MATCHING-DELIMITERS POINT (- *NUMERIC-ARG*)
						      NIL 0 OPEN CLOSE)
		    (BARF))))
  DIS-BPS)


(DEFCOM COM-MAKE-/(/) "Inserts matching parentheses, leaving point between them.
With a numeric argument, it encloses the next n Lisp forms in a pair of 
parentheses.  When the number of forms requested cannot be satisfied, it
beeps and does nothing.
When the command is bound to a key whose printing equivalent is one of the
delimiters in ZWEI:*MATCHING-DELIMITER-LIST*, the corresponding delimiter 
pair is inserted, instead of ().  For example, if bound to m-[, then when
m-[ is typed, a pair of square brackets is inserted, leaving point between
them.  With a numeric argument, the next n Lisp forms would be enclosed in
the [] pair.
With point on the open parenthesis of a defun, an argument of 1 would mean
to enclose the whole defun within a new set of parentheses.  Any argument
larger than 1 would have no effect.
In text mode, a word or a phrase within parentheses is treated as a Lisp
object.  " ()
  (LET ((OPEN #/()
	(CLOSE #/))
	(MOVER 'FORWARD-SEXP)
	(POINT (POINT)))
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK POINT))
      (DO ((CH (CODE-CHAR (CHAR-CODE *LAST-COMMAND-CHAR*)))
	   (L *MATCHING-DELIMITER-LIST* (CDR L)))
	  ((NULL L))
	(COND ((OR (CHAR-EQUAL CH (CAAR L)) (CHAR-EQUAL CH (CADAR L)))
	       (SETQ OPEN (CAAR L) CLOSE (CADAR L) MOVER (CADDAR L))
	       (RETURN T))))
      (LET ((BP (IF *NUMERIC-ARG-P*
		    (OR (IF (EQ MOVER 'FORWARD-SEXP)
			    (FORWARD-SEXP POINT *NUMERIC-ARG* NIL 0 NIL T T)	;No UP
			  (FUNCALL MOVER POINT *NUMERIC-ARG*))
			(BARF))
		  POINT)))
	(AND (MINUSP *NUMERIC-ARG*) (PSETQ BP POINT POINT BP))
	;; We're about to insert on the right side of the BP's we
	;; pass to D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")fixup-whitespace0.  Therefore, we give 1find-fixup-whitespace
0	;; a 1:force-left0 1t0, so it won't look for being on the beginning of the line.
	(MULTIPLE-VALUE-BIND (BP1 NIL)
	    (FIND-FIXUP-WHITESPACE POINT :FORCE-LEFT T)
	  (MULTIPLE-VALUE-BIND (NIL BP2)
	      (FIND-FIXUP-WHITESPACE BP :FORCE-LEFT T)
	    (WITH-UNDO-SAVE ("Insert ()" (OR BP1 POINT) (OR BP2 BP) T)
	      (WITH-BP (OBP BP ':NORMAL)
		(WITH-BP (OPT POINT ':NORMAL)
		  (INSERT-MOVING OBP (IN-CURRENT-STYLE CLOSE))
		  (INSERT-MOVING POINT (IN-CURRENT-STYLE OPEN))
		  (FIXUP-WHITESPACE OPT NIL))
		(FIXUP-WHITESPACE OBP NIL))))))
	DIS-TEXT)))

(DEFCOM COM-MAKE-/(/)-BACKWARD
	"Inserts matching parentheses backwards, leaving point between them.
With a numeric argument, it encloses the previous n Lisp forms in parentheses.
When the number of forms requested cannot be satisfied, it beeps and does
nothing.  With point on the close parenthesis of a defun, an argument of 1
would mean to enclose the whole defun within a new set of parentheses.  Any
argument larger than 1 would have no effect.  In text mode, a word or a phrase
within parentheses is treated as a Lisp object.  " ()
  (SETQ *NUMERIC-ARG* (MINUS *NUMERIC-ARG*)
	*NUMERIC-ARG-P* T)
  (COM-MAKE-/(/)))				;commands are symmetric

(DEFCOM COM-DELETE-/(/)
	"Deletes the innermost pair of parens or quotation marks enclosing point.
With a numeric argument, it removes the nth innermost pair.  When the number
requested cannot be satisifed, it beeps and does nothing.  " ()
  (LET ((POINT (POINT)))
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK POINT))
      (LET ((BP1 (OR (FORWARD-UP-LIST-OR-STRING POINT *NUMERIC-ARG*) (BARF)))
	    (BP2 (OR (FORWARD-UP-LIST-OR-STRING POINT (- *NUMERIC-ARG*) NIL NIL) (BARF))))
	(DELETE-INTERVAL (FORWARD-CHAR BP1 -1) BP1)
	(DELETE-INTERVAL BP2 (FORWARD-CHAR BP2 1))
	DIS-TEXT))))

(DEFCOM COM-MOVE-OVER-/) "Moves past the next close paren, then does Indent New Line.
It removes any whitespace between point and the close paren before moving over it.
It accepts a numeric argument; however, it ignores numeric arguments that are
less than 1 (all negative or zero numeric arguments are the same as no numeric
argument.)  If the numeric argument N is >1, then after finding the close
parenthesis and deleting preceding whitespace, it moves past N-1 additional
close parentheses before doing what the Line key does.  " ()
  (LET ((POINT (POINT)) (CHAR NIL))
    (DO ((CH *LAST-COMMAND-CHAR*)
	 (L *MATCHING-DELIMITER-LIST* (CDR L)))
	((NULL L))
      (COND ((CHAR-EQUAL CH (CADAR L))
	     (OR (= (LIST-SYNTAX CH) LIST-CLOSE)
		 (SETQ CHAR CH))
	     (RETURN T))))
    (LET ((BP (OR (IF CHAR (SEARCH (POINT) CHAR) (FORWARD-LIST POINT 1 NIL 1)) (BARF))))
      (MOVE-POINT BP)
      (LET* ((BP1 (FORWARD-CHAR BP -1))
	     (BP2 (BACKWARD-OVER *WHITESPACE-CHARS* BP1)))
	;; Flush whitespace before this point,
	;; unless that would move us to the end of a comment.
	(OR (MULTIPLE-VALUE-BIND (NIL NIL X) (LISP-BP-SYNTACTIC-CONTEXT BP2) X)
	    (DELETE-INTERVAL BP2 BP1 T)))
      (LET ((ARG (1- *NUMERIC-ARG*)))
	(AND (> ARG 0)
	     (MOVE-POINT (OR (IF CHAR (SEARCH (POINT) CHAR ARG)
				 (FORWARD-LIST POINT ARG NIL 1))
			     (BARF)))))))
  (LET ((*NUMERIC-ARG* 1)
	(*NUMERIC-ARG-P* NIL))
    (COM-INSERT-CRS)
    (COM-INDENT-FOR-LISP))
  DIS-TEXT)

(DEFCOM COM-GROW-LIST-FORWARD
	"Move the closing delimiter of the current list forward over one or more sexps.
With negative arg, shrink list by moving closing delimiter backwards.
Marks the end of the resulting list for visibility.
Always leaves point where the same command with a negative arg will undo it." (#||RM||#)
  (LET ((OLD-END (OR (FORWARD-LIST (POINT) 1 NIL 1) (BARF)))
	(POINT (POINT))
	OLD-END-1)
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK POINT))
      (SETQ OLD-END-1 (FORWARD-CHAR OLD-END -1))
      (LET ((NEW-END (OR (FORWARD-SEXP (IF (MINUSP *NUMERIC-ARG*) OLD-END-1 OLD-END)
				       *NUMERIC-ARG* NIL 0 NIL T T)
			 (BARF))))
	(AND (MINUSP *NUMERIC-ARG*)
	     (SETQ NEW-END (BACKWARD-OVER *WHITESPACE-CHARS* NEW-END)))
	(LET ((CHAR (BP-CHAR-BEFORE OLD-END)))
	  (WITH-BP (BP NEW-END ':NORMAL)
	    (DELETE-INTERVAL OLD-END-1 OLD-END T)
	    (INSERT BP CHAR)
	    (COND ((BP-< NEW-END POINT)
		   (MOVE-POINT NEW-END))
		  (T
		   (MOVE-MARK (FORWARD-CHAR BP 1 T))
		   (SETF (WINDOW-MARK-P *WINDOW*) T)
		   (SETQ *MARK-STAYS* T))))))))
  DIS-TEXT)

(DEFCOM COM-GROW-LIST-BACKWARD
	"Move the opening delimiter of the current list backward over one or more sexps.
With negative arg, shrink list by moving opening delimiter forwards.
Marks the beginning of the resulting list for visibility.
Always leaves point where the same command with a negative arg will undo it." (#||RM||#)
  (LET ((OLD-BEGIN (OR (FORWARD-LIST (POINT) -1 NIL 1) (BARF)))
	(POINT (POINT))
	OLD-BEGIN+1)
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK POINT))
      (SETQ OLD-BEGIN+1 (FORWARD-CHAR OLD-BEGIN 1))
      (LET ((NEW-BEGIN (OR (FORWARD-SEXP (IF (MINUSP *NUMERIC-ARG*) OLD-BEGIN+1 OLD-BEGIN)
					 (- *NUMERIC-ARG*) NIL 0 NIL NIL T)
			   (BARF))))
	(AND (MINUSP *NUMERIC-ARG*)
	     (SETQ NEW-BEGIN (FORWARD-OVER *WHITESPACE-CHARS* NEW-BEGIN)))
	(LET ((CHAR (BP-CHAR OLD-BEGIN)))
	  (WITH-BP (BP NEW-BEGIN ':MOVES)
	    (DELETE-INTERVAL OLD-BEGIN OLD-BEGIN+1 T)
	    (INSERT BP CHAR)
	    (COND ((BP-< POINT NEW-BEGIN)
		   (MOVE-POINT BP))
		  (T
		   (MOVE-MARK (FORWARD-CHAR BP -1 T))
		   (SETF (WINDOW-MARK-P *WINDOW*) T)
		   (SETQ *MARK-STAYS* T))))))))
  DIS-TEXT)

(DEFCOM COM-KILL-BACKWARD-UP-LIST "Delete the list that contains the sexp after point,
but leave that sexp itself." ()
  (LET ((POINT (POINT))
	BP1 BP2 BP3)
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK POINT))
      (OR (AND (SETQ BP1 (FORWARD-SEXP POINT -1 NIL 1 NIL NIL))
	       (SETQ BP2 (FORWARD-SEXP POINT *NUMERIC-ARG* NIL 0 NIL NIL T))
	       (SETQ BP3 (FORWARD-SEXP BP1 1)))
	  (BARF))
      (AND *KILL-INTERVAL-SMARTS*
	   (MEM #'CHAR-EQUAL (BP-CHAR-BEFORE BP1) *BLANKS*)
	   (MOVE-POINT (FORWARD-OVER *BLANKS* POINT)))
      (WITH-UNDO-SAVE ("kill enclosing list" BP1 BP3 T)
	(DELETE-INTERVAL BP2 BP3 T)
	(DELETE-INTERVAL BP1 POINT T))))
  DIS-TEXT)

(DEFCOM COM-CLOSE-DEFINITION
	"Inserts enough close parens to end the current definition." ()
  (LET ((PT (END-LINE (POINT))))
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK PT))
      (MULTIPLE-VALUE-BIND (IN-STRING SLASHIFIED IN-COMMENT)
	  (LISP-BP-SYNTACTIC-CONTEXT PT)
	(COND (SLASHIFIED
	       (BARF "After a slash"))
	      (IN-STRING
	       (INSERT-MOVING PT #/"))
	      (IN-COMMENT
	       (INSERT-MOVING PT #\CR))))
      (LET ((LINE (BP-LINE PT)))
	(LISP-PARSE-FROM-DEFINITION (OR (LINE-NEXT-IN-BUFFER LINE) LINE))
	(LET ((N (GET (LOCF (LINE-CONTENTS-PLIST LINE)) 'LISP-PARSE-LINE)))
	  (OR (NUMBERP N) (BARF "Not inside a list"))
	  (DOTIMES (IGNORE (- N -1))
	    (INSERT-MOVING PT #/)))))
      (MOVE-POINT PT)))
  DIS-TEXT)

(DEFCOM COM-FORMAT-CODE "Grind the sexp after the pointer.
WARNING: This calls the Lisp grinder, and will delete comments!
The command is undoable." ()
  (LET ((STREAM (REST-OF-INTERVAL-STREAM (POINT)))
	(EOF '())
	(POINT (POINT)))
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK POINT))
      (LET ((SEXP (READ STREAM EOF)))
	(AND (EQ SEXP EOF) (BARF "Missing close parentheses"))
	(WITH-UNDO-SAVE ("grind" POINT (FUNCALL STREAM ':READ-BP) T)
	  (GRIND-INTO-BP (DELETE-INTERVAL POINT (FUNCALL STREAM ':READ-BP)) SEXP)))))
  DIS-TEXT)

(DEFCOM COM-FORWARD-PARAGRAPH "Move to start of next paragraph.
Paragraphs are delimited by blank lines or by lines which start with
a delimiter in *PARAGRAPH-DELIMITER-LIST* or in *PAGE-DELIMITER-LIST*.
If there is a fill prefix, any line that does not start with it starts
a paragraph.
Lines which start with a character in *TEXT-JUSTIFIER-ESCAPE-LIST*, if that
character is also in *PARAGRAPH-DELIMITER-LIST*, count as blank lines in
that they separate paragraphs and are not part of them." (KM)
  (MOVE-POINT (FORWARD-PARAGRAPH (POINT) *NUMERIC-ARG* T))
  DIS-BPS)

(DEFCOM COM-BACKWARD-PARAGRAPH "Move to start of this (or last) paragraph.
See Forward Paragraph for the definition of a paragraph." (KM)
  (MOVE-POINT (FORWARD-PARAGRAPH (POINT) (- *NUMERIC-ARG*) T))
  DIS-BPS)

(DEFCOM COM-MARK-PARAGRAPH "Set point and mark around current paragraph.
See Forward Paragraph for the definition of a paragraph." (SM)
  (LET ((INT (PARAGRAPH-INTERVAL (POINT) *NUMERIC-ARG*)))
    (MOVE-POINT (INTERVAL-FIRST-BP INT))
    (MOVE-MARK (INTERVAL-LAST-BP INT)))
  DIS-BPS)

(DEFCOM COM-FORWARD-SENTENCE "Move to end of this sentence.
A sentence is ended by a ., ? or ! followed by
two spaces or a CRLF (with optional space), with
any number of /"closing characters/" /", ', ) and ] between.
A sentence also starts after a blank line." (KM)
  (MOVE-POINT (FORWARD-SENTENCE (POINT) *NUMERIC-ARG* T))
  DIS-BPS)

(DEFCOM COM-BACKWARD-SENTENCE "Move to beginning of sentence.
A sentence is ended by a ., ? or ! followed by
two spaces or a CRLF (with optional space), with
any number of /"closing characters/" /", ', ) and ] between.
A sentence also starts after a blank line." (KM)
  (MOVE-POINT (FORWARD-SENTENCE (POINT) (- *NUMERIC-ARG*) T))
  DIS-BPS)

(DEFCOM COM-KILL-SENTENCE "Kill one or more sentences forward.
A sentence is ended by a ., ? or ! followed by
two spaces or a CRLF (with optional space), with
any number of /"closing characters/" /", ', ) and ] between.
A sentence also starts after a blank line." ()
  (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
    (KILL-INTERVAL-ARG (POINT)
		       (FORWARD-SENTENCE (POINT) *NUMERIC-ARG* T)
		       *NUMERIC-ARG*))
  (SETQ *CURRENT-COMMAND-TYPE* 'KILL)
  DIS-TEXT)

(DEFCOM COM-BACKWARD-KILL-SENTENCE "Kill one or more sentences backward.
A sentence is ended by a ., ? or ! followed by
two spaces or a CRLF (with optional space), with
any number of /"closing characters/" /", ', ) and ] between.
A sentence also starts after a blank line." ()
  (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
    (KILL-INTERVAL-ARG (POINT)
		       (FORWARD-SENTENCE (POINT) (- *NUMERIC-ARG*) T)
		       (- *NUMERIC-ARG*)))
  (SETQ *CURRENT-COMMAND-TYPE* 'KILL)
  DIS-TEXT)

;;; The standard c-G command.
(DEFCOM COM-BEEP
"Beep, and if not given a numeric arg turn off the region.
Does not beep if it turns off the region or deexposes the typeout window." ()
  (WHEN (OR (NOT (WINDOW-MARK-P *WINDOW*))
	    (AND *NUMERIC-ARG-P* (WINDOW-MARK-P *WINDOW*)))
    (UNLESS (ZWEI:WINDOW-COVERED-BY-TYPEOUT-P *window*)
      ;; If there is nothing else to do, punt the current macro
      (WHEN (MEMQ ':MACRO-ERROR (FUNCALL STANDARD-INPUT ':WHICH-OPERATIONS))
	(FUNCALL STANDARD-INPUT ':MACRO-ERROR))
      (BEEP)))
  (AND *NUMERIC-ARG-P*
       (SETQ *MARK-STAYS* T))
  DIS-NONE)

;;; The standard c-X c-G command.
(DEFCOM COM-PREFIX-BEEP "Beep and don't do anything else." (KM)
  (AND (MEMQ ':MACRO-ERROR (FUNCALL STANDARD-INPUT ':WHICH-OPERATIONS))
       (FUNCALL STANDARD-INPUT ':MACRO-ERROR))
  (BEEP)
  DIS-NONE)

;;; The standard c-X abort command.
(DEFCOM COM-PREFIX-ABORT "Abort typing this prefix command." (KM)
  (AND (MEMQ ':MACRO-ERROR (FUNCALL STANDARD-INPUT ':WHICH-OPERATIONS))
       (FUNCALL STANDARD-INPUT ':MACRO-ERROR))
  DIS-NONE)

(DEFCOM COM-INDENT-FOR-COMMENT "Move to or create comment.
Finds start of existing comments or creates one at end of current line.
With numeric argument, re-aligns existing comments for n lines, but does
not create any.
Note that unlike EMACS, all units are raster pixels, not character counts!
*COMMENT-COLUMN* is the minimum column for aligning comments.
*COMMENT-START* is the string used to recognize existing comments.
*COMMENT-BEGIN* is the string used to start new comments.
*COMMENT-ROUND-FUNCTION* is the function used to compute the column for comments past the
comment column.
*ENTER-COMMENT-HOOK* is a hook function symbol run to allow style adjustments and
the like." ()
  (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
    (MOVE-POINT (INDENT-FOR-COMMENT (POINT) *NUMERIC-ARG*
				    (NOT *NUMERIC-ARG-P*) *NUMERIC-ARG-P*)))
  DIS-TEXT)

(DEFUN INDENT-FOR-COMMENT (BP &OPTIONAL (TIMES 1) CREATE-P MOVE-TO-NEXT-P BEG-LINE-NOT-SPECIAL
			   &AUX (UP-P 1))
  (SETQ BP (COPY-BP BP ':MOVES))
  (AND (MINUSP TIMES)
       (SETQ UP-P -1 TIMES (MINUS TIMES)))
  (RECORD-ACCUMULATED-CHANGES-BP BP)
  (DO ((I 0 (1+ I))
       (LINE)
       (LEN)
       (CH)
       (START-START-INDEX)			;Index in line of start of existing comment starter.
       (START-END-INDEX))			;Index in line of end of ...
      (( I TIMES))
    (SETQ LINE (BP-LINE BP)
	  LEN (LINE-LENGTH LINE))
    (MULTIPLE-VALUE (START-START-INDEX START-END-INDEX)
      (FIND-COMMENT-START LINE))
    (COND (START-START-INDEX
	   ;; A comment already exists.  Move BP to it.
	   (MOVE-BP BP LINE START-START-INDEX)
	   ;; Distinguish between ";", ";;" and ";;;" type comments.
	   (COND ((AND (ZEROP START-START-INDEX)	;At the beginning of the line stays
		       (NOT BEG-LINE-NOT-SPECIAL)))
		 ((AND (> LEN (1+ START-START-INDEX))
		       (CHAR-EQUAL (AREF LINE (1+ START-START-INDEX))
				   (SETQ CH (AREF LINE START-START-INDEX))))
		  (COND ((OR ( LEN (+ START-START-INDEX 2))	; ";;;" doesn't move
			     (NOT (CHAR-EQUAL CH (AREF LINE (+ START-START-INDEX 2)))))
			 ;; It is a double semicolon, indent as code.
			 (INDENT-LINE BP (INDENT-FOR-LISP BP)))))
		 (T
		  (INDENT-TO-COMMENT-COLUMN BP)))
	   ;; Now that indentation is adjusted, move over the comment starter.
	   (MOVE-BP BP (FORWARD-CHAR BP (- START-END-INDEX START-START-INDEX))))
	  (CREATE-P
	   ;; No existing comment, and no numeric arg, means make a comment.
	   (MOVE-BP BP LINE LEN)		;Move to end of line
	   (MUNG-BP-INTERVAL BP)
	   (LET ((BP2 (BACKWARD-OVER *BLANKS* BP)))
	     (IF (BP-= BP2 BP)
		 (PREPARE-TO-INSERT BP NIL)	;Ensure recording as one long insertion
		 (PREPARE-TO-CHANGE BP2 BP)))	; or as edit of stray space to the comment
	   (INDENT-TO-COMMENT-COLUMN BP)
	   (LET ((POS (COPY-BP BP)))
	     ;;this is probably overly kludgy but does the right thing.
	     (DOLIST (HOOK *EXIT-COMMENT-HOOK*)
	       (FUNCALL HOOK))
	     (INSERT POS (IN-CURRENT-STYLE *COMMENT-END*))
	     (MOVE-BP BP POS)
	     (DOLIST (HOOK *ENTER-COMMENT-HOOK*)
	       (FUNCALL HOOK))
	     (INSERT BP (IN-CURRENT-STYLE *COMMENT-BEGIN*)))))
    (AND MOVE-TO-NEXT-P				; Move to next line
	 (MOVE-BP BP (OR (BEG-LINE BP UP-P) (RETURN NIL)))))
  BP) 

;; Internal function of above.
(DEFUN INDENT-TO-COMMENT-COLUMN (BP)
  (LET ((HERE (BP-VIRTUAL-INDENTATION (BACKWARD-OVER *BLANKS* BP)))
	(GOAL *COMMENT-COLUMN*))
    (COND (( HERE GOAL)
	   (SETQ GOAL (FUNCALL *COMMENT-ROUND-FUNCTION* HERE))))
    (INDENT-AT BP GOAL)))

;;; This is the default value of *COMMENT-ROUND-FUNCTION*, the function used
;;; to figure out how to round up the position of comments in an attempt to
;;; make the comments line up nicely.
(DEFUN ROUND-FOR-COMMENT (IND)
  (LET ((SPACE-WIDTH (FONT-SPACE-WIDTH)))
    (LET ((X (* 8 SPACE-WIDTH)))
      (+ *COMMENT-COLUMN* (* (+ (// (- IND *COMMENT-COLUMN*) X) 1) X)))))

;; Return the index in LINE of the start of the comment, or NIL if no comment.
;; The second value is the index of the end of the comment-starter.
;; BEGIN-ALSO means if there is no *COMMENT-START*, find *COMMENT-BEGIN*;
;; this is for C-M-; to work right in text mode.
(DEFUN FIND-COMMENT-START (LINE &OPTIONAL BEGIN-ALSO)
  (SEND (OR (SEND *INTERVAL* :MAJOR-MODE) (MAJOR-MODE-FROM-KEYWORD :FUNDAMENTAL))
	':FIND-COMMENT-START LINE BEGIN-ALSO))

;; Answers the question "Is there a comment in LINE starting at INDEX?"
(DEFUN COMMENT-STARTS-AT-INDEX-P (LINE INDEX)
  (SEND (OR (SEND *INTERVAL* :MAJOR-MODE) (MAJOR-MODE-FROM-KEYWORD :FUNDAMENTAL))
	:COMMENT-STARTS-AT-INDEX-P LINE INDEX))

(DEFCOM COM-COMMENT-OUT-REGION
	"Comments out each of the lines in the region (or definition).
When the region ends at the beginning of a line, it does not comment out
that line.  If any part of the line is part of the region, then it does
comment out that line.

A numeric argument inverts the meaning of the command, taking the
comment indicators away from any commented-out lines in the region.
When any part of the line is part of the region, it removes commenting
from around that line.  This assumes that any comment starting in column
1 is fair game.  It stops when it encounters a line that does not begin
the way a comment would, even if more lines that have been commented out
remain in the region.  It does keep the remainder of the region in this
case, so that you can resume." ()
  (LET ((BEGIN-COUNT (STRING-LENGTH *COMMENT-BEGIN*))
	(END-COUNT (STRING-LENGTH *COMMENT-END*)))
    (IF *NUMERIC-ARG-P*
	;; With a numeric arg, remove comment flags
	;; DEFINITION-REGION is useless here, since the definition is commented out!
	(REGION (START END :EMPTY-OK NIL)
	  (SETQ START (BEG-LINE START))		;ensure at beginning of first line
	  (WITH-INTERVAL-WRITE-LOCKED (START END T)
	    (WITH-UNDO-SAVE-SPARSE ("un comment out" START)
	      (LOOP WHILE START WITH LINE-END WITH BP
		    FOR LINE = (BP-LINE START)	;text of the current line
		    FOR LINE-COUNT = (STRING-LENGTH LINE)
		    WHILE (AND (BP-< START END)
			       (%STRING-EQUAL LINE 0 *COMMENT-BEGIN* 0 BEGIN-COUNT)
			       (%STRING-EQUAL LINE (- LINE-COUNT END-COUNT)  ;stop on a
					      *COMMENT-END* 0 END-COUNT)     ;non-comment line
			       ( LINE-COUNT (+ BEGIN-COUNT END-COUNT)))     ;enough to delete
		    DO
		(RECORD-SPARSE-CHANGE START (SETQ BP (FORWARD-CHAR START BEGIN-COUNT)) 0)
		(LET ((*ENABLE-CHANGE-RECORDING* NIL))
		  (DELETE-INTERVAL START BP T))		;using cannon against a flea
		(SETQ LINE-END (END-LINE START))
		(RECORD-SPARSE-CHANGE (SETQ BP (FORWARD-CHAR LINE-END (- END-COUNT) NIL))
				      LINE-END 0)
		(LET ((*ENABLE-CHANGE-RECORDING* NIL))
		  (DELETE-INTERVAL BP LINE-END T))
		(SETQ START (FORWARD-LINE START))
		    FINALLY
		      (IF (OR (NULL START) (BP-< START END))	;if it stopped prematurely
			  (PROGN (MOVE-MARK END)		;retain the rest of region
				 (WHEN START			;so user can reissue
				   (MOVE-POINT (FORWARD-LINE START 1 T)))
				 (SETQ *MARK-STAYS* T))
			  (SETF (WINDOW-MARK-P *WINDOW*) NIL))))))
	;; Without a numeric arg, add comment flags
	(DEFINITION-REGION (START END)
	  (SETQ START (BEG-LINE START))		;ensure at beginning of first line
	  (WITH-INTERVAL-WRITE-LOCKED (START END T)
	    (WITH-UNDO-SAVE-SPARSE ("comment out" START)
	      (LOOP WITH COMMENT-BEGIN = (IN-CURRENT-STYLE *COMMENT-BEGIN*)
		    WITH COMMENT-END = (IN-CURRENT-STYLE *COMMENT-END*)
		    WHILE (AND START (BP-< START END))
		    AS BP1 = (BEG-LINE START)
		    DO (RECORD-SPARSE-CHANGE BP1 BP1 BEGIN-COUNT)
		       (LET ((*ENABLE-CHANGE-RECORDING* NIL))
			 (INSERT BP1 COMMENT-BEGIN))
		    AS BP2 = (END-LINE START)
		    DO (RECORD-SPARSE-CHANGE BP2 BP2 END-COUNT)
		       (LET ((*ENABLE-CHANGE-RECORDING* NIL))
			 (INSERT BP2 COMMENT-END))
		       (SETQ START (FORWARD-LINE START))))))))
  DIS-TEXT)

(DEFCOM COM-KILL-COMMENT
	"Kills any comments in the region or on the current line if no region exists.

Normally, the command kills any comment on the current line.
If a region exists, the command kills all comments in lines whose
beginnings are in the region.  If no other undoable commands have
intervened, you can retrieve the comments with m-X Undo."
 ()
  (IF (WINDOW-REGION-P)
      (REGION (BP1 BP2)
	(WITH-INTERVAL-WRITE-LOCKED (BP1 BP2 T)
	  (WITH-UNDO-SAVE ("kill comments" BP1 BP2 T)
	    (REGION-LINES (START-LINE STOP-LINE)
	      (DO ((LINE START-LINE (LINE-NEXT-IN-BUFFER LINE)))
		  ((EQ LINE STOP-LINE))
		(KILL-COMMENT LINE))))))
      (LET ((LEN (LINE-LENGTH (BP-LINE (POINT)))))
	(WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
	  (KILL-COMMENT (BP-LINE (POINT)))
	  (OR (= LEN (LINE-LENGTH (BP-LINE (POINT))))
	      (MOVE-POINT (END-LINE (POINT)))))))
  DIS-TEXT)

;; Kill the comment on the line with BP.
(DEFUN KILL-COMMENT (LINE &AUX START-INDEX)
  (AND (SETQ START-INDEX (FIND-COMMENT-START LINE T))
       (LET ((BP (CREATE-BP LINE START-INDEX)))
	 ;;Don't let it join to a preceding kill; this can't ever be correct
	 (SETQ *LAST-COMMAND-TYPE* 'MOVE)
	 (KILL-INTERVAL (BACKWARD-OVER *BLANKS* BP) (END-LINE BP) T NIL)))
  (SETQ *CURRENT-COMMAND-TYPE* 'KILL))


(DEFCOM COM-DOWN-COMMENT-LINE "Move to the comment position in the next line.
Equivalent to COM-DOWN-REAL-LINE followed by COM-INDENT-FOR-COMMENT, except
that any blank comment on the current line is deleted first." ()
  (SCL:STACK-LET*
    ((LINE (BP-LINE (POINT)))
     (START1 (CL:LENGTH *COMMENT-BEGIN*))
     (LEN (+ START1 (CL:LENGTH *COMMENT-END*)))
     (EMPTY-COMMENT-STRING (MAKE-ARRAY LEN :TYPE 'ART-STRING)))
    (CL:REPLACE EMPTY-COMMENT-STRING *COMMENT-BEGIN*)
    (CL:REPLACE EMPTY-COMMENT-STRING *COMMENT-END* :START1 START1)
    (AND ( (LINE-LENGTH LINE) LEN)
	 ;; Delete any empty comment on this line
	 (STRING-EQUAL EMPTY-COMMENT-STRING LINE 0 (- (LINE-LENGTH LINE) LEN))
	 (LET ((BP1 (END-LINE (POINT))))
	   (LET ((BP2 (BACKWARD-OVER *BLANKS* (FORWARD-CHAR BP1 (MINUS LEN)))))
	     (DELETE-INTERVAL BP2 BP1 T)))))
  (COM-DOWN-REAL-LINE)
  (LET ((*NUMERIC-ARG-P* NIL) (*NUMERIC-ARG* 1))
    (COM-INDENT-FOR-COMMENT)))

(DEFCOM COM-UP-COMMENT-LINE "Move to comment position in the previous line.
Equivalent to COM-UP-REAL-LINE followed by COM-INDENT-FOR-COMMENT, except
that any blank comment on the current line is deleted first." ()
  (LET ((*NUMERIC-ARG* (MINUS *NUMERIC-ARG*)))
    (COM-DOWN-COMMENT-LINE)))

(DEFCOM COM-INDENT-COMMENT-RELATIVE "Align new comment with previous one.
Sets *COMMENT-COLUMN* to position of previous comment then does COM-INDENT-FOR-COMMENT." ()
  (LET (START-INDEX BP)
    ;; Find a line, before our starting one, which has a comment on it.
    (DO ((LINE (LINE-PREVIOUS-IN-BUFFER (BP-LINE (POINT))) (LINE-PREVIOUS-IN-BUFFER LINE)))
	((NULL LINE) (BARF))
      (SETQ START-INDEX (FIND-COMMENT-START LINE T))
      (AND START-INDEX (RETURN (SETQ BP (CREATE-BP LINE START-INDEX)))))
    (SET-VARIABLE-VALUE '*COMMENT-COLUMN* (BP-INDENTATION BP) ':BUFFER)
    (COM-INDENT-FOR-COMMENT)))

(DEFCOM COM-SET-COMMENT-COLUMN "Set *COMMENT-COLUMN* to the current horizontal position.
With an argument, sets it to position of previous comment then aligns or creates a comment
on the current line." ()
  (COND (*NUMERIC-ARG-P*
	 (LET ((*NUMERIC-ARG-P* NIL)
	       (*NUMERIC-ARG* 1))
	   (COM-INDENT-COMMENT-RELATIVE)))
	(T (LET ((COL (BP-INDENTATION (POINT))))
	     (SET-VARIABLE-VALUE '*COMMENT-COLUMN* COL ':ASK)
	     (REPORT-COLUMN-SETTING "Comment column" COL))
	   DIS-NONE)))

(DEFUN REPORT-COLUMN-SETTING (NAME NPIXELS)
  (COND ((NUMBERP NPIXELS)
	 (TYPEIN-LINE "~A = ~D pixels" NAME NPIXELS)
	 (LET ((FONT (CURRENT-FONT *WINDOW*)))
	   (IF (NULL (FONT-CHAR-WIDTH-TABLE FONT))
	       (TYPEIN-LINE-MORE " (~D characters)" (// NPIXELS (FONT-CHAR-WIDTH FONT))))))
	(T (TYPEIN-LINE "~A disabled" NAME)))
  NPIXELS)

(DEFCOM COM-INDENT-NEW-COMMENT-LINE "Insert newline, then start new comment.
If done when not in a comment, acts like COM-INDENT-NEW-LINE.  Otherwise,
the comment is ended." ()
  (LET ((PT (POINT))
	START END)
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK PT))
      (DELETE-BACKWARD-OVER *BLANKS* PT)
      (MULTIPLE-VALUE (START END)
	(FIND-COMMENT-START (BP-LINE PT)))
      (COND ((OR (NOT START) (< (BP-INDEX PT) START))
	     (MUST-REDISPLAY *WINDOW* (KEY-EXECUTE #\CR))
	     (COND ((PLUSP (STRING-LENGTH *FILL-PREFIX*))
		    (INSERT-MOVING-POINT *FILL-PREFIX*)
		    DIS-TEXT)
		   (*SPACE-INDENT-FLAG*
		    (KEY-EXECUTE #\TAB))
		   (T
		    (DELETE-OVER *BLANKS* (POINT))
		    DIS-TEXT)))
	    (T
	     (INSERT-MOVING PT *COMMENT-END*)
	     (INSERT PT (SUBSTRING (BP-LINE PT) START END))
	     (MUST-REDISPLAY *WINDOW* (KEY-EXECUTE #\CR))
	     (MOVE-POINT (INDENT-FOR-COMMENT PT 1 NIL NIL T))
	     DIS-TEXT)))))

(DEFCOM COM-END-COMMENT "Terminate comment on this line and move to the next.
Terminates the comment if there is one on this line and moves to the next line
down.  Primarily useful when a comment terminator exists (TECO or MACSYMA mode)." ()
  (LET ((PT (POINT)))
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK PT))
      (COND ((FIND-COMMENT-START (BP-LINE PT))
	     ;; This line has a comment on it.
	     (INSERT (END-LINE PT) *COMMENT-END*)
	     ;; Make sure interval ends in a newline.
	     (UNLESS (CHAR-EQUAL (BP-CHAR (INTERVAL-LAST-BP *INTERVAL*)) #\CR)
	       (INSERT (INTERVAL-LAST-BP *INTERVAL*) #\CR))
	     (MOVE-POINT (LINE-NEXT-IN-BUFFER (BP-LINE PT)) 0)
	     DIS-TEXT)
	    (T DIS-NONE)))))

(DEFCOM COM-SET-FILL-COLUMN 
	"Set the fill column (right margin) from the cursor's current position.
With an argument, if it is less than 200., set fill column to that many characters;
otherwise set it to that many pixels." (KM)
  (LET ((COL (COND (*NUMERIC-ARG-P*
		    (COND ((< *NUMERIC-ARG* 200.)
			   (* *NUMERIC-ARG* (FONT-SPACE-WIDTH)))
			  (T *NUMERIC-ARG*)))
		   (T (BP-INDENTATION (POINT))))))
    (SET-VARIABLE-VALUE '*FILL-COLUMN* COL ':ASK)
    (REPORT-COLUMN-SETTING "Fill column" COL))
  DIS-NONE)

(DEFVAR *FILL-DIFFERENTLY-ADJUST-P* NIL)

(DEFCOM COM-FILL-PARAGRAPH "Fill (or adjust) this (or next) paragraph.
Point stays the same.
A positive numeric argument means to adjust rather than fill." ()
  (LET ((INT (PARAGRAPH-INTERVAL (POINT)))
	(ADJUST-P (AND *NUMERIC-ARG-P* (PLUSP *NUMERIC-ARG*))))
    (FILL-INTERVAL INT NIL T :ADJUST ADJUST-P)
    (SETQ *FILL-DIFFERENTLY-ADJUST-P* ADJUST-P)
    (SETQ *CURRENT-COMMAND-TYPE* 'FILL-TEXT))
  DIS-TEXT)

(DEFCOM COM-FILL-REGION "Fill (or adjust) the region.
A positive numeric argument means to adjust rather than fill." ()
  (LET ((ADJUST-P (AND *NUMERIC-ARG-P* (PLUSP *NUMERIC-ARG*))))
    (REGION (BP1 BP2)
      (FILL-INTERVAL BP1 BP2 T :ADJUST ADJUST-P))
    (SETQ *FILL-DIFFERENTLY-ADJUST-P* ADJUST-P)
    (SETQ *CURRENT-COMMAND-TYPE* 'FILL-TEXT))
  DIS-TEXT)

(DEFVAR *FILL-DIFFERENTLY-FILL-COLUMN* 0)
(DEFCOM COM-FILL-DIFFERENTLY "Fill (or adjust) this (or next) paragraph differently.
Filling or adjustment is done to match the last adjacent Fill Paragraph
or Fill Region command.
The fill column is incremented by one character width each time
the command is executed.
With a numeric argument, the fill column is incremented by the value of
that argument (which can be negative)." ()
  (UNLESS (EQ *LAST-COMMAND-TYPE* 'FILL-DIFFERENTLY)
    (SETQ *FILL-DIFFERENTLY-FILL-COLUMN* *FILL-COLUMN*))
  (UNLESS (MEMQ *LAST-COMMAND-TYPE* '(FILL-DIFFERENTLY FILL-TEXT))
    (SETQ *FILL-DIFFERENTLY-ADJUST-P* NIL))
  (WHEN *NUMERIC-ARG-P*
    (INCF *FILL-DIFFERENTLY-FILL-COLUMN* (* (1- *NUMERIC-ARG*) (FONT-SPACE-WIDTH))))
  (SETQ *CURRENT-COMMAND-TYPE* 'FILL-DIFFERENTLY)
  (LET-BUFFER-VARIABLE (*FILL-COLUMN* *FILL-DIFFERENTLY-FILL-COLUMN*)
    (LET ((INT (PARAGRAPH-INTERVAL (POINT))))
      (FILL-INTERVAL INT NIL T :ADJUST *FILL-DIFFERENTLY-ADJUST-P*)))
  (INCF *FILL-DIFFERENTLY-FILL-COLUMN* (FONT-SPACE-WIDTH))
  DIS-TEXT)

;;; We need this for Lisp Mode (and any other language mode that cares to adopt
;;; it) to continue to furnish c-sh-Q functionality, while protecting those who
;;; spazz and type c-sh-Q when they mean c-m-Q!
(DEFCOM COM-FILL-LONG-COMMENT-DIFFERENTLY "Fill this comment differently.
The fill column is incremented by one character width each time
the command is executed.
With a numeric argument, the fill column is incremented by the value of
that argument (which can be negative)." ()
  (UNLESS (EQ *LAST-COMMAND-TYPE* 'FILL-DIFFERENTLY)
    (SETQ *FILL-DIFFERENTLY-FILL-COLUMN* *FILL-COLUMN*))
  (WHEN *NUMERIC-ARG-P*
    (INCF *FILL-DIFFERENTLY-FILL-COLUMN* (* (1- *NUMERIC-ARG*) (FONT-SPACE-WIDTH))))
  (SETQ *CURRENT-COMMAND-TYPE* 'FILL-DIFFERENTLY)
  (LET-BUFFER-VARIABLE (*FILL-COLUMN* *FILL-DIFFERENTLY-FILL-COLUMN*)
    (COM-FILL-LONG-COMMENT))
  (INCF *FILL-DIFFERENTLY-FILL-COLUMN* (FONT-SPACE-WIDTH))
  DIS-TEXT)

(DEFCOM COM-SET-FILL-PREFIX "Define Fill Prefix from the current line.
All of the current line up to point becomes the Fill Prefix.  Fill Region
assumes that each non-blank line starts with the prefix (which is
ignored for filling purposes).  To stop using a Fill Prefix, do
a Set Fill Prefix at the beginning of a line." () 
  (SET-VARIABLE-VALUE '*FILL-PREFIX* (SUBSTRING (BP-LINE (POINT)) 0 (BP-INDEX (POINT))) ':BUFFER)
  (TYPEIN-LINE "Fill prefix for this buffer = /"~A/"" *FILL-PREFIX*)
  DIS-NONE)

(DEFCOM COM-FILL-LONG-COMMENT "Fill this comment.
Comment must begin at the start of the line" ()
  (IF (WINDOW-MARK-P *WINDOW*)
      (REGION (START-BP END-BP :ENFORCE-SINGLE-SECTION T)
	(SETQ START-BP (BEG-LINE START-BP))	;ensure at beginning of first line
	(WITH-UNDO-SAVE-SPARSE ("fill" START-BP)
	  (UNLESS (INTERVAL-LINES (START-BP END-BP) (START-LINE END-LINE)
		    (LOOP AS LINE = START-LINE THEN (LINE-NEXT-IN-BUFFER LINE)
			  UNTIL (EQ LINE END-LINE)
			  ALWAYS (MEMQ (LINE-TYPE LINE) '(:COMMENT :BLANK))))
	    (BARF "Not all lines in the region are comments."))
	  (LOOP WITH REGION-START-LINE = NIL
		AS LINE = (BP-LINE START-BP) THEN (IF (EQ LINE END-LINE)
						      'END
						    (LINE-NEXT-IN-BUFFER LINE))
		WITH END-LINE = (BP-LINE END-BP)
		DO (IF (AND (NEQ LINE 'END) (NON-BLANK-COMMENT-LINE-P LINE))
		       (WHEN (NULL REGION-START-LINE)
			 (SETQ REGION-START-LINE LINE))
		     (WHEN REGION-START-LINE
		       (FILL-LONG-COMMENT-INTERNAL (BEG-OF-LINE REGION-START-LINE)
						   (IF (EQ LINE 'END)
						       END-BP (BEG-OF-LINE LINE))
						   T)
		       (SETQ REGION-START-LINE NIL)))
		UNTIL (EQ LINE 'END))))
    (UNLESS (EQ (LINE-TYPE (BP-LINE (POINT))) ':COMMENT)
      (BARF "No comment starting at beginning of line"))
    (LET ((START-BP (LOOP AS PREV = (BEG-LINE (POINT)) THEN BP
			  AS BP = (BEG-LINE PREV -1)
			  WHEN (OR (NULL BP)
				   (NOT (NON-BLANK-COMMENT-LINE-P (BP-LINE BP))))
			    RETURN PREV))
	  (END-BP (LOOP AS BP = (BEG-LINE (POINT) 1) THEN (BEG-LINE BP 1)
			WHEN (NULL BP) RETURN (INTERVAL-LAST-BP *INTERVAL*)
			WHEN (NOT (NON-BLANK-COMMENT-LINE-P (BP-LINE BP)))
			  RETURN BP)))
	(WITH-UNDO-SAVE-SPARSE ("fill" START-BP)
	  (FILL-LONG-COMMENT-INTERNAL START-BP END-BP T))))
  DIS-TEXT)

;;; This identifies a line that is all comment, and not blank.  It will return NIL on a line
;;; of code with a comment, and on a line that is nothing but a comment containing whitespace.
(DEFUN NON-BLANK-COMMENT-LINE-P (LINE)
  (LET ((BLANKS *BLANKS*))
    (MULTIPLE-VALUE-BIND (START END)
	(FIND-COMMENT-START LINE)
      (AND START
	   (LOOP FOR INDEX FROM 0 BELOW START
		 ALWAYS (MEMQ (AREF LINE INDEX) BLANKS))
	   (LOOP FOR INDEX FROM END BELOW (LINE-LENGTH LINE)
		 THEREIS (NOT (MEMQ (AREF LINE INDEX) BLANKS)))))))

(DEFUN FILL-LONG-COMMENT-INTERNAL (START-BP END-BP IN-ORDER-P)
  (GET-INTERVAL START-BP END-BP IN-ORDER-P)
  (LET* ((LAST-FILL-LINE-IS-LAST-BP-LINE-P
	   (AND END-BP
		(NOT (LINE-BLANK-P (BP-LINE END-BP) T))
		(EQ (BP-LINE END-BP)
		    (BP-LINE (INTERVAL-LAST-BP *INTERVAL*)))))
	 (MINEND (LOOP WITH END-LINE = (BP-LINE END-BP)
		       AS LINE = (BP-LINE START-BP) THEN (LINE-NEXT-IN-BUFFER LINE)
		       ;; Make sure to include the last non-empty line in the
		       ;; interval, even when it contains the end of the interval
		       ;; (i.e., there is no newline at its end)
		       UNTIL (OR (NULL LINE)
				 (AND (NULL LAST-FILL-LINE-IS-LAST-BP-LINE-P)
				      (EQ LINE END-LINE)))
		       MINIMIZE (MULTIPLE-VALUE-BIND (NIL END)
				    (FIND-COMMENT-START LINE)
				  (IF (NULL END)
				      (RETURN MINEND)
				    END)) INTO MINEND
		       FINALLY (RETURN MINEND))))
    (LET-BUFFER-VARIABLE (*FILL-PREFIX* (SUBSTRING (BP-LINE START-BP) 0 MINEND))
      (FILL-INTERVAL START-BP END-BP T)))
  DIS-TEXT)

(DEFCOM COM-DELETE-HORIZONTAL-SPACE "Delete any spaces or tabs around point.
If given a numeric argument, that many spaces are then inserted." ()
  (WHEN (MINUSP *NUMERIC-ARG*) (BARF "The number of spaces to retain must be non-negative."))
  (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
    (DELETE-AROUND *BLANKS* (POINT))
    (AND *NUMERIC-ARG-P* (MOVE-POINT (INSERT-CHARS (POINT) #\SP *NUMERIC-ARG*))))
  DIS-TEXT)

(DEFUN BACK-TO-INDENTATION (&OPTIONAL (FROM-BP (POINT)))
  (LET ((BP (BEG-LINE FROM-BP)))
    (AND (LOOKING-AT BP *FILL-PREFIX*)
	 (SETQ BP (FORWARD-CHAR BP (STRING-LENGTH *FILL-PREFIX*))))
    (MOVE-BP FROM-BP (FORWARD-OVER *BLANKS* BP))))

(DEFCOM COM-BACK-TO-INDENTATION "Move to start of current line and past any blanks." (KM)
  (BACK-TO-INDENTATION)
  DIS-BPS)

(DEFCOM COM-END-OF-CODE-LINE
	"Goes to the end of the last /"real/" character on the line.
This provides a way to get positioned on a line so you can add to or modify
the code, not the comment.  A numeric argument specifies how many lines to move.  " ()
  (LET* ((THE-LINE (BP-LINE (FORWARD-LINE (POINT)      ; Find the line wanted.
					  (IF *NUMERIC-ARG-P* *NUMERIC-ARG* 0))))
	 (INDEX (FIND-COMMENT-START THE-LINE T)))      ; Index for comment.
    (COND ((NULL INDEX)				; No comment on line.
	   (MOVE-POINT (END-LINE (CREATE-BP THE-LINE 0))))        ; So just go to end.
	  (T
	   (MOVE-POINT (BACKWARD-OVER *BLANKS* (CREATE-BP THE-LINE INDEX))))))
  DIS-BPS)

(DEFCOM COM-UPPERCASE-REGION "Uppercase the region (or definition)." ()
  (DEFINITION-REGION (BP1 BP2)
    (WITH-UNDO-SAVE ("upcase" BP1 BP2 T)
      (UPCASE-INTERVAL BP1 BP2 T)))
  DIS-TEXT)

(DEFCOM COM-LOWERCASE-REGION "Lowercase the region (or definition)." ()
  (DEFINITION-REGION (BP1 BP2)
    (WITH-UNDO-SAVE ("downcase" BP1 BP2 T)
      (DOWNCASE-INTERVAL BP1 BP2 T)))
  DIS-TEXT)

(DEFCOM COM-UPPERCASE-WORD "Uppercase one or more words forward." ()
  (LET ((TEM (FORWARD-WORD (POINT) *NUMERIC-ARG*)))
    (OR TEM (BARF))
    (UPCASE-INTERVAL (POINT) TEM)
    (AND (PLUSP *NUMERIC-ARG*)
         (MOVE-POINT TEM)))
  DIS-TEXT)

(DEFCOM COM-LOWERCASE-WORD "Lowercase one or more words forward." ()
  (LET ((TEM (FORWARD-WORD (POINT) *NUMERIC-ARG*)))
    (OR TEM (BARF))
    (DOWNCASE-INTERVAL (POINT) TEM)
    (AND (PLUSP *NUMERIC-ARG*)
         (MOVE-POINT TEM)))
  DIS-TEXT)

(DEFCOM COM-UPPERCASE-INITIAL "Put next word in lowercase, but capitalize initial.
With an argument, capitalizes that many words." ()
  (LET ((BP1 (COPY-BP (POINT))) (ARG *NUMERIC-ARG*))
    ;; Compute end bp even if going forward, so as to barf before trashing the buffer
    (LET ((BP (OR (FORWARD-WORD BP1 ARG) (BARF))))
      (AND (MINUSP ARG)
	   (SETQ BP1 BP
		 ARG (MINUS ARG))))
    (DO ((I 0 (1+ I))
	 (BP))
	(( I ARG))
      (OR (SETQ BP (FORWARD-TO-WORD BP1)) (BARF))
      (OR (SETQ BP1 (FORWARD-WORD BP)) (BARF))
      (DO ((CH)) (NIL)
	(SETQ CH (BP-CHAR BP))
	(AND (OR (BP-= BP BP1)
		 (ALPHA-CHAR-P CH))
	     (RETURN))
	(IBP BP))
      (DOWNCASE-INTERVAL BP BP1)
      (UPCASE-CHAR BP))    
    (AND (PLUSP *NUMERIC-ARG*) (MOVE-POINT BP1)))
  DIS-TEXT)

(DEFCOM COM-UPPERCASE-CODE-IN-REGION
 "Converts code (not strings or comments) to upper case in the region or current definition.
It has the same effect as retyping the region or current definition in Electric Shift
Lock Mode would have." ()
  (DEFINITION-REGION (BP1 BP2)
    (WITH-UNDO-SAVE ("Uppercase Code In Region" BP1 BP2 T)
      (UPPERCASE-CODE-IN-INTERVAL BP1 BP2 T)))
  DIS-TEXT)
  
(DEFCOM COM-LOWERCASE-CODE-IN-REGION
"Converts code (not strings or comments) to lower case in the region or current definition.
It has the same effect as retyping the region or current definition without Electric
Shift Lock Mode would have." ()
  (DEFINITION-REGION (BP1 BP2)
    (WITH-UNDO-SAVE ("Lowercase Code In Region" BP1 BP2 T)
      (LOWERCASE-CODE-IN-INTERVAL BP1 BP2 T)))
  DIS-TEXT)

(DEFCOM COM-UPPERCASE-CODE-IN-BUFFER
"Converts code (not strings or comments) to upper case, in a specified buffer.
It has the same result as retyping the buffer in Electric Shift Lock Mode.
Without a numeric argument, it converts the current buffer without prompting.
With an argument, it prompts for a buffer name in the minibuffer." ()
  (LET* ((BUFFER (READ-BUFFER-NAME-OR-DEFAULT-WITHOUT-ARG
		   "Buffer in which to uppercase code"
		   *INTERVAL*))
	 (FIRST-BP (INTERVAL-FIRST-BP BUFFER))
	 (LAST-BP (INTERVAL-LAST-BP BUFFER)))
    (WITH-UNDO-SAVE ("Uppercase Code In Buffer" FIRST-BP LAST-BP T)	 
      (UPPERCASE-CODE-IN-INTERVAL FIRST-BP LAST-BP T)
      DIS-TEXT)))

(DEFCOM COM-LOWERCASE-CODE-IN-BUFFER
"Converts code (not strings or comments) to lower case, for the specified buffer.
It has the same result as retyping the buffer without Electric Shift Lock Mode.
Without a numeric argument, it converts the current buffer without prompting.
With an argument, it prompts for a buffer name in the minibuffer." ()
  (LET* ((BUFFER (READ-BUFFER-NAME-OR-DEFAULT-WITHOUT-ARG
		   "Buffer in which to lowercase code"
		   *INTERVAL*))
	 (FIRST-BP (INTERVAL-FIRST-BP BUFFER))
	 (LAST-BP (INTERVAL-LAST-BP BUFFER)))
    (WITH-UNDO-SAVE ("Lowercase Code In Buffer" FIRST-BP LAST-BP T)
      (LOWERCASE-CODE-IN-INTERVAL FIRST-BP LAST-BP T)
      DIS-TEXT)))

(DEFUN UPPERCASE-CODE-IN-INTERVAL (BP1 &OPTIONAL BP2 IN-ORDER-P)
  (CASIFY-CODE-IN-INTERVAL BP1 BP2 IN-ORDER-P 'CHAR-UPCASE))

(DEFUN LOWERCASE-CODE-IN-INTERVAL (BP1 &OPTIONAL BP2 IN-ORDER-P)
  (CASIFY-CODE-IN-INTERVAL BP1 BP2 IN-ORDER-P 'CHAR-DOWNCASE))

(DEFUN CASIFY-CODE-IN-INTERVAL (BP1 BP2 IN-ORDER-P CASIFY-FN)
  (GET-INTERVAL BP1 BP2 IN-ORDER-P)
  (WITH-INTERVAL-WRITE-LOCKED (BP1 BP2 T)
    (MUNG-BP-INTERVAL BP1)
    (LET ((STATE ':UNSURE) (TEMP-BP (CREATE-BP (BP-LINE BP1) 0 NIL)))
      (CHARMAP-MUNGING-LINES (BP1 BP2 NIL)
	;; If we are confused, use the slow way of figuring out where
	;; we are before we go on to decide if we need to case anything.
	(WHEN (EQ STATE ':UNSURE)
	  (MOVE-BP TEMP-BP (CHARMAP-LINE) (CHARMAP-INDEX))
	  (MULTIPLE-VALUE-BIND (STRING SLASH COMMENT)
	      (LISP-BP-SYNTACTIC-CONTEXT TEMP-BP)
	    (SETQ STATE 
		  (COND (STRING ':STRING)
			(COMMENT (CHARMAP-END-OF-LINE) ':UNSURE)
			(SLASH (CHARMAP-INCREMENT) ':UNSURE)
			(T ':CODE)))))
	;; Now state cannot be :unsure, go on to decide if we need to
	;; case anything, and how far ahead we can skip.      
	(LET* ((BEFORE (CHARMAP-CHAR))
	       (BEFORE-SYNTAX (LIST-SYNTAX BEFORE)))
	  (COND ((EQL BEFORE-SYNTAX LIST-SLASH)
		 (CHARMAP-INCREMENT))
		((AND (EQL BEFORE-SYNTAX LIST-COMMENT)
		      (NEQ STATE :STRING))
		 (CHARMAP-END-OF-LINE)
		 (SETQ STATE ':UNSURE))
		((CL:MEMBER BEFORE-SYNTAX '(#.LIST-DOUBLE-QUOTE #.LIST-VERTICAL-BAR))
		 (SETQ STATE ':UNSURE))
		((AND (EQ STATE ':STRING)
		      (EQL BEFORE-SYNTAX LIST-ALPHABETIC)))
		((AND (EQ STATE ':CODE)
		      (EQL BEFORE-SYNTAX LIST-ALPHABETIC))
		 (LET ((AFTER (FUNCALL CASIFY-FN BEFORE)))
		   (UNLESS (CHAR= BEFORE AFTER)
		     (CHARMAP-SET-CHAR AFTER))))
		(T
		 ;; Doesn't seem like you can get here,
		 ;; but better to be on safe side.
		 (SETQ STATE ':UNSURE))))))))

(DEFCOM COM-DELETE-BLANK-LINES "Delete any blank lines around the end of the current line." ()
  (LET ((FIRST-LINE (BP-LINE (INTERVAL-FIRST-BP *INTERVAL*)))
	(LAST-LINE (BP-LINE (INTERVAL-LAST-BP *INTERVAL*)))
	(LINE (BP-LINE (POINT)))
	(TEM))
    (COND ((LINE-BLANK-P LINE)
	   (SETQ TEM LINE)
	   (DO ((L TEM))			;Move backward over blank lines.
	       ((EQ L FIRST-LINE))
	     (SETQ L (LINE-PREVIOUS-IN-BUFFER L))
	     (OR (LINE-BLANK-P L) (RETURN NIL))
	     (SETQ TEM L))
	   (MOVE-POINT TEM 0)
	   (DO ((L LINE))			;Move forward over more blank lines.
	       ((EQ L LAST-LINE))
	     (SETQ L (LINE-NEXT-IN-BUFFER L))
	     (OR (LINE-BLANK-P L) (RETURN NIL))
	     (SETQ LINE L))
	   (AND (EQ LINE TEM) (NEQ LINE LAST-LINE) (SETQ LINE (LINE-NEXT-IN-BUFFER LINE)))
	   (DELETE-INTERVAL (POINT) (BEG-OF-LINE LINE)))
	  (T
	   (SETQ TEM (BACKWARD-OVER *BLANKS* (END-OF-LINE LINE)))
	   (DO ((L LINE))
	       ((EQ L LAST-LINE))
	     (SETQ L (LINE-NEXT-IN-BUFFER L))
	     (OR (LINE-BLANK-P L) (RETURN NIL))
	     (SETQ LINE L))
	   (DELETE-INTERVAL TEM (END-OF-LINE LINE)))))
  DIS-TEXT)

(DEFCOM COM-INDENT-RIGIDLY "Shift text in the region sideways as a unit.
All lines in the region have their indentation increased by the numeric
argument of this command (the argument may be negative).  The argument
is a number of SPACE characters in the default character style." ()
  (AND (EQ *LAST-COMMAND-TYPE* 'REGION)
       (SETF (WINDOW-MARK-P *WINDOW*) T))
  (REGION-LINES (START-LINE STOP-LINE
		 :REGION-LINES-BP1 START-BP
		 :REGION-LINES-BP2 END-BP)
    (WITH-INTERVAL-WRITE-LOCKED (START-BP END-BP T)
      (WITH-UNDO-SAVE-SPARSE ("Indent" START-BP)
	(DO ((LINE START-LINE (LINE-NEXT-IN-BUFFER LINE))
	     (DELTA (* *NUMERIC-ARG* (FONT-SPACE-WIDTH))))
	    ((EQ LINE STOP-LINE))
	  (INDENT-LINE (CREATE-BP LINE 0) (MAX 0 (+ DELTA (LINE-INDENTATION LINE))))))))
  (SETQ *CURRENT-COMMAND-TYPE* 'REGION)
  DIS-TEXT)

(DEFCOM COM-INDENT-REGION "Indent each line in the region (or definition).
With no argument, it calls the current TAB command to indent.
With an argument, makes the indentation of each line be as wide as that
many SPACEs in the current character style." ()
  (LET ((COMMAND (COMMAND-LOOKUP #\TAB *COMTAB*)))
    (IF (AND (EQ COMMAND 'COM-INDENT-FOR-LISP) (NOT *NUMERIC-ARG-P*))
	(DEFINITION-REGION (BP1 BP2)
	  (WITH-INTERVAL-WRITE-LOCKED (BP1 BP2 T)
	    (INDENT-INTERVAL-FOR-LISP BP1 BP2 T)))	;Efficiency hack
      (DEFINITION-REGION-LINES (START-LINE STOP-LINE
				:REGION-LINES-BP1 START-BP
				:REGION-LINES-BP2 END-BP)
	(WITH-INTERVAL-WRITE-LOCKED (START-BP END-BP T)
	  (WITH-UNDO-SAVE-SPARSE ("Indent" START-BP)
	    (DO ((LINE START-LINE (LINE-NEXT-IN-BUFFER LINE))
		 (WIDTH (* *NUMERIC-ARG* (FONT-SPACE-WIDTH)))
		 (POINT (POINT))
		 (OLD-POINT (COPY-BP (POINT))))
		((EQ LINE STOP-LINE)
		 (MOVE-POINT OLD-POINT))
	      (MOVE-POINT LINE 0)
	      (IF *NUMERIC-ARG-P*
		  (INDENT-LINE POINT WIDTH)
		(FUNCALL COMMAND))))))))
  DIS-TEXT)

(DEFCOM COM-STUPID-TAB
	"Insert spaces in the current character style, to the next even multiple of 8." ()
  (LET ((PT (POINT))
	(FONT (CURRENT-FONT *WINDOW*)))
    (LET ((FONT-SPACE-WIDTH (FONT-SPACE-WIDTH FONT)))
      (LET ((POS (BP-INDENTATION PT))
	    (X (* 10 FONT-SPACE-WIDTH))
	    (SPACE (IN-CURRENT-STYLE #\SP)))
	(DO L (// (- (* X (1+ (// POS X))) POS) FONT-SPACE-WIDTH) (1- L) ( L 0)
	    (INSERT-MOVING PT SPACE)))))
  DIS-TEXT)

(DEFCOM COM-INSERT-TAB "Insert a Tab in the buffer at point." ()
  (DOTIMES (IGNORE *NUMERIC-ARG*) (INSERT-MOVING-POINT #\TAB))
  DIS-TEXT)

(DEFCOM COM-INSERT-FF "Insert a Page character in the buffer at point." ()
  (DOTIMES (IGNORE *NUMERIC-ARG*) (INSERT-MOVING-POINT #\PAGE))
  DIS-TEXT)

(DEFCOM COM-RIGHT-ADJUST-LINE "Adjust the current line to the right margin.
Non-zero argument means adjust from point to the end of the line." ()
  (COND ((NOT *NUMERIC-ARG-P*)
	 (MOVE-POINT (FORWARD-OVER *BLANKS* (BEG-LINE (POINT))))))
  (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
    (LET ((LINE (BP-LINE (POINT))))
      (LET ((SWID (STRING-WIDTH LINE
				(BP-INDEX (POINT))
				(BP-INDEX (BACKWARD-OVER *BLANKS* (END-LINE (POINT))))))
	    (RPOS (OR *FILL-COLUMN* (TV:SHEET-INSIDE-WIDTH (WINDOW-SHEET *WINDOW*)))))
	(MOVE-POINT (INDENT-AT (POINT) (- RPOS SWID))))))
  DIS-TEXT)

(DEFCOM COM-CENTER-LINE "Center this line's text within the line.
With a region, centers the lines in the region and moves past.
With an argument, centers that many lines and moves past." ()
  (COND ((WINDOW-REGION-P)
	 (REGION (BP1 BP2 :ENFORCE-SINGLE-SECTION T)
	   (SETQ *NUMERIC-ARG* (COUNT-LINES BP1 BP2))
	   (WHEN (ZEROP (BP-INDEX BP2))
	     (SETQ *NUMERIC-ARG* (1- *NUMERIC-ARG*))))
	 (SETQ *NUMERIC-ARG-P* T)
	 (WHEN (BP-< (MARK) (POINT))
	   (SWAP-BPS (POINT) (MARK))))
	((MINUSP *NUMERIC-ARG*)
	 (MOVE-POINT (OR (BEG-LINE (POINT) *NUMERIC-ARG*) (BARF)))
	 (SETQ *NUMERIC-ARG* (MINUS *NUMERIC-ARG*))))
  (LET ((SHEET (WINDOW-SHEET *WINDOW*))
	(BLANKS *BLANKS*))
    (DO ((I 0 (1+ I))
	 (LINE (BP-LINE (POINT)) (LINE-NEXT-IN-BUFFER LINE))
	 (LIMIT-LINE (BP-LINE (INTERVAL-LAST-BP *INTERVAL*)))
	 (BP)
	 (TEM))
	(( I *NUMERIC-ARG*)
	 (AND *NUMERIC-ARG-P* (MOVE-POINT LINE 0)))
      (SETQ BP (FORWARD-OVER BLANKS (BEG-OF-LINE LINE)))
      (SETQ TEM (BP-INDEX BP))
      (SETQ BP (BACKWARD-OVER BLANKS (END-LINE BP)))
      (SETQ TEM (STRING-WIDTH LINE TEM (BP-INDEX BP) SHEET))
      (AND (> TEM *FILL-COLUMN*)
	   (BARF "The text of the line is too long."))
      (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK BP))
	(INDENT-LINE BP (// (- *FILL-COLUMN* TEM) 2)))
      (COND ((EQ LINE LIMIT-LINE)
	     (AND *NUMERIC-ARG-P*
		  (MOVE-POINT (END-LINE BP)))
	     (RETURN NIL)))))
  DIS-TEXT)

(DEFCOM COM-INDENT-NESTED "Indent line for specified nesting level.
With no argument (or argument 1) indents the line at the same nesting
level as the last nonblank line (ie, directly under it).
A larger argument means that this line is that many levels
closer to the surface, and should indent under the last line
above it whose level is the same.  The previous lines are scanned
under the assumption that any line less indented than its successors
is one level higher than they.
However, unindented lines and comment lines are ignored.
If the cursor is not at the beginning of a line, the whole line
is indented, but the cursor stays fixed with respect to the text." ()
  (LET ((PT (POINT))
	(IND-SEEN 7777777)
	(BLANKS *BLANKS*))
    (DO-NAMED LUPO
	((J 0 (1+ J))
	 (LINE (BP-LINE PT))
	 (LIMIT-LINE (BP-LINE (INTERVAL-FIRST-BP *INTERVAL*))))
	(( J *NUMERIC-ARG*))
      (DO ((BP)
	   (IND))
	  ((EQ LINE LIMIT-LINE)
	   (SETQ IND-SEEN 0)
	   (RETURN-FROM LUPO))
	(SETQ LINE (LINE-PREVIOUS-IN-BUFFER LINE))
	(COND ((NOT (LINE-BLANK-P LINE))
	       ;; We have found a non-blank line.
	       (SETQ BP (FORWARD-OVER BLANKS (BEG-OF-LINE LINE)))
	       ;; BP is now just past lines's indentation.
	       (COND ((NOT (OR (AND *COMMENT-START*
				    ;;Lines starting with a comment don't count.
				    (LOOKING-AT BP *COMMENT-START*))
			       ;; Line is unindented, doesn't count.
			       (ZEROP (SETQ IND (LINE-INDENTATION LINE)))
			       ;; Is this less indented than anything we have seen yet?
			       ( IND IND-SEEN)))
		      (SETQ IND-SEEN IND)
                      (RETURN NIL)))))))
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK PT))
      ;; Now IND-SEEN is the place to which to indent.
      (INDENT-LINE PT IND-SEEN)
      (INDENT-BP-ADJUSTMENT PT)))
  DIS-TEXT)

(DEFVAR *STRING-UNDER*)
(DEFCOM COM-INDENT-UNDER "Indent to align under STRING (read from tty).
Searches back, line by line, forward in each line, for a string
that matches the one read and that is more to the right than the
caller's cursor already is.  Indents to align with string found,
removing any previous indentation around point first." ()
  (LET ((ORIGINAL-IND (BP-INDENTATION (POINT)))
	(STRING (TYPEIN-LINE-READLINE "String to align with:"))
	(PT (POINT))
	(STRING-LEN 0)
	(LINE NIL)				;The line we finally found.
	(INDENTATION NIL))			;Its indentation.
    (SETQ STRING-LEN (STRING-LENGTH STRING)
	  LINE (BP-LINE PT))
    (COND ((PLUSP STRING-LEN)
	   (SETQ *STRING-UNDER* STRING))
	  (T (SETQ STRING *STRING-UNDER*)))
    
    (DO-NAMED LUPO
	((LIMIT-LINE (BP-LINE (INTERVAL-FIRST-BP *INTERVAL*)))
	 (BP (COPY-BP PT)))
	((EQ LINE LIMIT-LINE)
	 (BARF "String not found."))
      (SETQ LINE (LINE-PREVIOUS-IN-BUFFER LINE))
      (SETF (BP-LINE BP) LINE)
      (DO ((INDEX 0))
	  ((NULL (SETQ INDEX (STRING-SEARCH STRING LINE (+ STRING-LEN INDEX)))))
	(SETF (BP-INDEX BP) INDEX)
	(AND (> (SETQ INDENTATION (BP-INDENTATION BP))
		ORIGINAL-IND)
	     (RETURN-FROM LUPO))))
    (OR (FIND-BP-IN-WINDOW *WINDOW* LINE 0)
	(FUNCALL *TYPEIN-WINDOW* ':LINE-OUT LINE))
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK PT))
      (INDENT-TO PT INDENTATION)))
  DIS-TEXT)

(DEFCOM COM-INDENT-RELATIVE "Indent Relative to the previous line.
With non-null argument, does Tab-to-Tab-Stop.  Otherwise,
Add whitespace characters until underneath an indentation point
in the previous non-null line.  Successive calls find successive
indentation points.  An indentation point is the end
of a sequence of spaces and tabs.  The end of the line counts;
after that, we cycle back to the first suitable indentation.
If there is no suitable indentation point, Tab-to-Tab-Stop
is done." ()
  (LET ((PT (POINT)) IND)
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK PT))
      (IF (OR *NUMERIC-ARG-P*
	      (NULL (SETQ IND (INDENT-RELATIVE PT))))
	  (COM-TAB-TO-TAB-STOP)
	(DELETE-AROUND *BLANKS* PT)
	(MOVE-POINT (INDENT-TO PT IND))
	DIS-TEXT))))

(DEFUN INDENT-RELATIVE (BP &OPTIONAL (RESTART-OK T) INDENT-TO-WORDS &AUX START DEST BP1 L)
  (SETQ BP1 (BACKWARD-OVER *BLANKS* BP)
	BP (FORWARD-OVER *BLANKS* BP)
	L (DO ((L (BP-LINE BP))
	       (FIRST (BP-LINE (INTERVAL-FIRST-BP *INTERVAL*))))
	      ((EQ L FIRST) NIL)
	    (SETQ L (LINE-PREVIOUS-IN-BUFFER L))
	    (OR (ZEROP (LINE-LENGTH L))
		(RETURN L))))
  (COND ((NULL L) NIL)
	;; L is the previous non-blank line.
	;; BP1 is at the beginning of the current line whitespace.
	((OR (AND (SETQ START (INDENTATION-INDEX L (BP-INDENTATION BP) NIL NIL T))
		  (< START (LINE-LENGTH L)))
	     (AND RESTART-OK
		  (SETQ START (INDENTATION-INDEX L (BP-INDENTATION BP1) NIL NIL T))))
	 (SETQ DEST (IF (AND INDENT-TO-WORDS (ZEROP START)) START
			(STRING-SEARCH-SET *BLANKS* L START)))
	 (MOVE-BP BP1 L (OR DEST (LINE-LENGTH L)))
	 (SETQ BP1 (IF INDENT-TO-WORDS
		       (LET ((BP2 (FORWARD-TO-WORD BP1))
			     (BP3 (END-LINE BP1)))
			 (IF (OR (NULL BP2) (BP-< BP3 BP2))
			     BP3 BP2))
		       (FORWARD-OVER *BLANKS* BP1)))
	 (BP-INDENTATION BP1))))

(DEFCOM COM-STACK-LIST-VERTICALLY "Indent the list after point, first insertings crlfs" ()
  (LET ((PT (POINT)))
    (WITH-BP (END (BACKWARD-OVER '(#/) #\SP #\TAB #\CR) (OR (FORWARD-SEXP PT) (BARF)))
		  ':MOVES)
      (DO ((BP (FORWARD-SEXP (FORWARD-LIST PT 1 NIL -1 T)
			     (IF *NUMERIC-ARG-P* 1 2))
	       (FORWARD-SEXP BP)))
	  ((NOT (BP-< BP END)))
	(INSERT-MOVING BP #\CR))
      (INDENT-INTERVAL-FOR-LISP PT END T)))
  DIS-TEXT)

(DEFCOM COM-MULTIPLE-TRY-LISP-TAB "Indent line differently if called more than once" ()
  (IF *NUMERIC-ARG-P* (COM-INDENT-FOR-LISP) (COM-INDENT-DIFFERENTLY)))

(DEFVAR *INDENT-DIFFERENTLY-REPETITION-LEVEL* 0)
(DEFVAR *INDENT-DIFFERENTLY-POSSIBLE-INDENTATIONS* NIL)
(DEFCOM COM-INDENT-DIFFERENTLY "Try to indent this line differently
If called repeatedly, makes multiple attempts." ()
  (LET ((POINT (POINT)) IND)
    (SETQ POINT (FORWARD-OVER *BLANKS* (BEG-LINE POINT)))
    (OR (EQ *LAST-COMMAND-TYPE* 'INDENT-DIFFERENTLY)
	(SETQ *INDENT-DIFFERENTLY-REPETITION-LEVEL* 0
	      *INDENT-DIFFERENTLY-POSSIBLE-INDENTATIONS* (LIST (BP-INDENTATION POINT))))
    (SETQ *CURRENT-COMMAND-TYPE* 'INDENT-DIFFERENTLY)
    (DO ((BP (BEG-LINE POINT))
	 (TIMES *NUMERIC-ARG*))
	(NIL)
      (SETQ *INDENT-DIFFERENTLY-REPETITION-LEVEL* (1+ *INDENT-DIFFERENTLY-REPETITION-LEVEL*))
      (SETQ IND (COND ((> *INDENT-DIFFERENTLY-REPETITION-LEVEL* 1000)
		       (NTH (- *INDENT-DIFFERENTLY-REPETITION-LEVEL* 1001)
			    *INDENT-DIFFERENTLY-POSSIBLE-INDENTATIONS*))
		      ((> *INDENT-DIFFERENTLY-REPETITION-LEVEL* 4)
		       (SETQ IND NIL)
		       (IF (> *INDENT-DIFFERENTLY-REPETITION-LEVEL* 400)
			   (LET ((OIND (CAR *INDENT-DIFFERENTLY-POSSIBLE-INDENTATIONS*))
				 (LINE (BP-LINE BP)))
			     (INDENT-LINE BP OIND)
			     (MOVE-BP BP LINE (INDENTATION-INDEX LINE OIND)))
			   (OR (> *INDENT-DIFFERENTLY-REPETITION-LEVEL* 100)
			       (SETQ *INDENT-DIFFERENTLY-REPETITION-LEVEL* 101))
			   (LET ((BP1 (FORWARD-SEXP POINT
						    (- 100
						       *INDENT-DIFFERENTLY-REPETITION-LEVEL*)
						    NIL 0 NIL T T)))
			     (IF BP1
				 (SETQ IND (BP-INDENTATION
					     (IF (EQ (BP-LINE BP1) (BP-LINE POINT))
						 POINT BP1)))
				 (SETQ *INDENT-DIFFERENTLY-REPETITION-LEVEL* 400))))
		       (OR IND
			   (ATOM-WORD-SYNTAX-BIND
			     (INDENT-RELATIVE BP NIL T))))
		      ((> *INDENT-DIFFERENTLY-REPETITION-LEVEL* 3)
		       (LET-BUFFER-VARIABLE (*LISP-INDENT-OFFSET* 1)
			 (INDENT-FOR-LISP BP)))
		      ((> *INDENT-DIFFERENTLY-REPETITION-LEVEL* 2)
		       (LET-BUFFER-VARIABLE (*LISP-INDENT-OFFSET* 0)
			 (INDENT-FOR-LISP BP)))
		      ((> *INDENT-DIFFERENTLY-REPETITION-LEVEL* 1)
		       (LET-BUFFER-VARIABLE (*LISP-INDENTATION-OFFSET-HASH-TABLE* NIL)
			 (LET-BUFFER-VARIABLE (*LISP-DEFUN-INDENTATION* NIL)
			   (INDENT-FOR-LISP BP))))
		      (T
		       (INDENT-FOR-LISP BP))))
      (COND ((NULL IND)
	     (SETQ *INDENT-DIFFERENTLY-REPETITION-LEVEL* 1000)
	     (SETQ *INDENT-DIFFERENTLY-POSSIBLE-INDENTATIONS*
		   (SI:ELIMINATE-DUPLICATES *INDENT-DIFFERENTLY-POSSIBLE-INDENTATIONS*))
	     (SETQ *INDENT-DIFFERENTLY-POSSIBLE-INDENTATIONS*
		   (SORT *INDENT-DIFFERENTLY-POSSIBLE-INDENTATIONS* #'LESSP)))
	    ((> *INDENT-DIFFERENTLY-REPETITION-LEVEL* 1000)
	     (RETURN T))
	    ((NOT (MEMQ IND (PROG1 *INDENT-DIFFERENTLY-POSSIBLE-INDENTATIONS*
				   (PUSH IND *INDENT-DIFFERENTLY-POSSIBLE-INDENTATIONS*))))
	     (OR (PLUSP (SETQ TIMES (1- TIMES))) (RETURN T)))))
    (INDENT-LINE POINT IND)
    (INDENT-BP-ADJUSTMENT (POINT)))
  DIS-TEXT)
