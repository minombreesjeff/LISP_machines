;;; -*- Syntax: Zetalisp; Mode: LISP; Package: ZWEI; Base: 8-*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This file contains support for support buffers in ZMACS.

(DEFMETHOD (:SPECIAL-PURPOSE-P SPECIAL-PURPOSE-BUFFER) () T)

;;; The default is to reuse the same buffer.  Normally, there is just
;;; one of a particular flavor.
(DEFMETHOD (:REUSABLE SPECIAL-PURPOSE-BUFFER) (IGNORE) T)

(DEFMETHOD (:DESCRIPTION SPECIAL-PURPOSE-BUFFER) ()
  (FORMAT NIL "[~D line~:P]" (COUNT-LINES-BUFFER SELF)))

(DEFMETHOD (:SPECIAL-PURPOSE-P BUFFER) () NIL)

(DEFMETHOD (:INIT-OPTIONS BUFFER) () NIL)

(DEFMETHOD (:INIT-OPTIONS SPECIAL-PURPOSE-BUFFER) (OPTIONS)
  (LOOP FOR (KEY VAL) ON OPTIONS BY #'CDDR
	WITH LEGAL-OPTIONS = (SEND SELF ':BUFFER-INIT-OPTIONS)
	WHEN (MEMQ KEY LEGAL-OPTIONS)
	  DO (SEND SELF KEY VAL)))

(DEFMETHOD (:MODIFIED-P SPECIAL-PURPOSE-BUFFER) (&OPTIONAL TYPE)
  (COND ((EQ TICK ':READ-ONLY)
	 (VALUES NIL ':READ-ONLY))
	((EQ TYPE ':EXPLICIT-SAVING)
	 T)
	(T
	 (VALUES NIL ':SPECIAL))))

(DEFMETHOD (:GENERATE-NAME BUFFER) (IGNORE) NAME)	;default is to use name created for it

(DEFMETHOD (:KILL SPECIAL-PURPOSE-BUFFER :BEFORE) (&OPTIONAL NO-SAVE-P)
  NO-SAVE-P
  (SETQ *ZMACS-POSSIBILITIES-BUFFERS* (DELQ SELF *ZMACS-POSSIBILITIES-BUFFERS*)))

(DEFVAR *SPECIAL-BUFFER-FLAVOR-ALIST* NIL)

(DEFMACRO DEFINE-SPECIAL-BUFFER-TYPE (FLAVOR-NAME I-VS FLS TYPE NAME &BODY OPTIONS)
  (DECLARE (ZWEI:INDENTATION 1 7 5 1))
  (LET ((BUFFER-INIT-OPTIONS (CAR (MEM #'(LAMBDA (ITEM OPT)
					   (AND (LISTP OPT)
						(EQ ITEM (CAR OPT))))
				       ':BUFFER-INIT-OPTIONS
				       OPTIONS))))
    (IF BUFFER-INIT-OPTIONS (SETQ OPTIONS (REMOVE BUFFER-INIT-OPTIONS OPTIONS)))
    `(PROGN
       (RECORD-SOURCE-FILE-NAME ',TYPE 'DEFINE-SPECIAL-BUFFER-TYPE)
       (DEFFLAVOR ,FLAVOR-NAME ,I-VS ,FLS
	 ;--- SYS:FUNCTION-PARENT when that's supported
	 (:METHOD-COMBINATION :BUFFER-INIT-OPTIONS :APPEND)
	 ,@OPTIONS)
       (DEFMETHOD (:SPECIAL-PURPOSE-P ,FLAVOR-NAME) ()
	 (DECLARE (SYS:FUNCTION-PARENT ,TYPE DEFINE-SPECIAL-BUFFER-TYPE))
	 ',TYPE)
       (DEFMETHOD (:BUFFER-INIT-OPTIONS ,FLAVOR-NAME) ()
	 (DECLARE (SYS:FUNCTION-PARENT ,TYPE DEFINE-SPECIAL-BUFFER-TYPE))
	 ',(CDR BUFFER-INIT-OPTIONS))
       (PUSH `(,',TYPE ,',FLAVOR-NAME ,',NAME) *SPECIAL-BUFFER-FLAVOR-ALIST*))))

(DEFMETHOD (:SELECT-SPECIAL-BUFFER ZMACS-EDITOR) (TYPE NEW-P &REST SETS)
  (MAKE-BUFFER-CURRENT (LEXPR-SEND SELF ':FIND-SPECIAL-BUFFER TYPE NEW-P SETS)))

(DEFMETHOD (:FIND-SPECIAL-BUFFER ZMACS-EDITOR) (TYPE NEW-P &REST SETS &AUX BUFFER)
  (LET ((ELEM (ASSQ TYPE *SPECIAL-BUFFER-FLAVOR-ALIST*)))
    (UNLESS ELEM (DEBUGGING-BARF "Attempt to find a special purpose buffer of undefined type ~S. Please report this ZMACS bug." TYPE))
    (SETQ BUFFER (LOOP FOR BUFFER IN (CDR (ASSQ TYPE *ZMACS-BUFFER-ALIST*))
		       WITH PROSPECT = NIL
		       WHEN (EQ (FUNCALL BUFFER ':SPECIAL-PURPOSE-P) TYPE)
			 DO (SETQ PROSPECT BUFFER)
			    (AND (EQ NEW-P (SEND BUFFER ':REUSABLE SETS))
				 (RETURN BUFFER))
		       FINALLY (WHEN (COND (NEW-P T)
					   ((NULL PROSPECT)
					    (SETQ NEW-P T)
					    T))
				 (SETQ PROSPECT
				       (MAKE-BUFFER
					 (SECOND ELEM)
					 ':NAME (LOOP FOR I FROM 1
						      WITH NAME = (THIRD ELEM)
						      AS BUFNAM = (FORMAT NIL "*~A-~D*"
									  NAME I)
						      UNLESS (FIND-BUFFER-NAMED BUFNAM)
							RETURN (LET ((DEFAULT-CONS-AREA
								       *ZMACS-BUFFER-AREA*))
								 (STRING-APPEND BUFNAM)))
					 ':ACTIVATE-P NIL
					 ':MAJOR-MODE ':FUNDAMENTAL
					 ;; ':PACKAGE PACKAGE	;remove this provisionally
					 )))
			       (SEND PROSPECT :SET-NAME (SEND PROSPECT :GENERATE-NAME SETS))
			       (RETURN PROSPECT)))
    (SEND BUFFER ':INIT-OPTIONS SETS)
    (AND NEW-P (FUNCALL BUFFER ':REVERT))
    (SEND BUFFER ':ACTIVATE)
    BUFFER))

(DEFMETHOD (:EXIT-SPECIAL-BUFFER ZMACS-EDITOR) (&OPTIONAL UPDATE-P
							  (SPECIAL-BUFFER *INTERVAL*)
							  (SELECT-ANOTHER-BUFFER T))
  (AND UPDATE-P (SEND SPECIAL-BUFFER ':SET-NOT-MODIFIED))
  (AND SELECT-ANOTHER-BUFFER (EQ SPECIAL-BUFFER *INTERVAL*)
       (MAKE-BUFFER-CURRENT (OR (CADR (WINDOW-BUFFER-HISTORY *WINDOW*)) *INTERVAL*)))
  (WHEN (EQ SELECT-ANOTHER-BUFFER :KILL)
    (KILL-BUFFER SPECIAL-BUFFER T))
  (ALTER-WINDOW *WINDOW*
		BUFFER-HISTORY     
		(DELQ SPECIAL-BUFFER (WINDOW-BUFFER-HISTORY *WINDOW*) 1))
  (POINT-PDL-PURGE SPECIAL-BUFFER)
  DIS-TEXT)


(DEFFLAVOR SPECIAL-PURPOSE-BUFFER-WITH-TICK ((REUSE-TICK 0)) (SPECIAL-PURPOSE-BUFFER))

(DEFMETHOD (:REVERT SPECIAL-PURPOSE-BUFFER-WITH-TICK :AFTER) ()
  (SETQ REUSE-TICK (TICK)))

(DEFMETHOD (:SET-NOT-MODIFIED SPECIAL-PURPOSE-BUFFER-WITH-TICK) (&OPTIONAL UNDO-P)
  (IGNORE UNDO-P)
  (SETQ REUSE-TICK (TICK)))

(DEFMETHOD (:MODIFIED-P SPECIAL-PURPOSE-BUFFER-WITH-TICK) (&OPTIONAL TYPE)
  (COND ((EQ TICK ':READ-ONLY)
	 (VALUES NIL ':READ-ONLY))
	((MEMQ TYPE '(:FOR-SAVING :FOR-KILLING))
	 (VALUES NIL ':SPECIAL))
	((> TICK REUSE-TICK)
	 T)
	(T
	 NIL)))

;;; Can be reused if not modified or current.
(DEFMETHOD (:REUSABLE SPECIAL-PURPOSE-BUFFER-WITH-TICK) (IGNORE)
  (AND (NEQ SELF *INTERVAL*)
       (NOT (SEND SELF ':MODIFIED-P ':FOR-CLEANING))))

(DEFFLAVOR DESCRIPTION-ENCACHING-SPECIAL-PURPOSE-BUFFER
	((LAST-DESCRIPTION-TICK 0)
	 LAST-DESCRIPTION)
	()
  (:REQUIRED-FLAVORS SPECIAL-PURPOSE-BUFFER))

(DEFWHOPPER (:DESCRIPTION DESCRIPTION-ENCACHING-SPECIAL-PURPOSE-BUFFER) ()
  (UNLESS (EQL LAST-DESCRIPTION-TICK TICK)
    (SETQ LAST-DESCRIPTION (CONTINUE-WHOPPER)
	  LAST-DESCRIPTION-TICK TICK))
  LAST-DESCRIPTION)



;;; Special buffers with a piece of information in each node, which are usually
;;; read-only.
(DEFFLAVOR SUBNODE-SPECIAL-PURPOSE-BUFFER (INTERVAL-STREAM) (SPECIAL-PURPOSE-BUFFER)
  (:REQUIRED-METHODS :HEADER-DESCRIPTION))

(DEFMETHOD (:INIT SUBNODE-SPECIAL-PURPOSE-BUFFER :AFTER) (IGNORE)
  (SETQ INTERVAL-STREAM (OPEN-INTERVAL-STREAM LAST-BP)))

(DEFUN DELETE-INTERVAL-AND-FLUSH-INFERIORS (NODE)
  (DELETE-INTERVAL-AND-FLUSH-INFERIORS-1 NODE)
  (DELETE-INTERVAL NODE))

(DEFUN DELETE-INTERVAL-AND-FLUSH-INFERIORS-1 (NODE)
  (DOLIST (INFERIOR (NODE-INFERIORS NODE))
    (DELETE-INTERVAL-AND-FLUSH-INFERIORS-1 INFERIOR)
    (FLUSH-BP (INTERVAL-FIRST-BP INFERIOR))
    (FLUSH-BP (INTERVAL-LAST-BP INFERIOR)))
  (SETF (NODE-INFERIORS NODE) NIL))

(DEFMETHOD (:REVERT SUBNODE-SPECIAL-PURPOSE-BUFFER :BEFORE) ()
  (DELETE-INTERVAL-AND-FLUSH-INFERIORS SELF)
  (LET ((NODE (CREATE-INTERVAL)))
    (SEND INTERVAL-STREAM ':SET-BP (INTERVAL-LAST-BP NODE))
    (SEND SELF ':HEADER-DESCRIPTION INTERVAL-STREAM)
    (SETQ INFERIORS (NCONS NODE))
    (SETF (NODE-SUPERIOR NODE) SELF)
    (MOVE-BP FIRST-BP (INTERVAL-FIRST-BP NODE))
    (LET ((LAST-LINE (BP-LINE (INTERVAL-LAST-BP NODE)))
	  (FIRST-LINE (BP-LINE LAST-BP)))
      (SETF (LINE-NEXT LAST-LINE) FIRST-LINE)
      (SETF (LINE-PREVIOUS FIRST-LINE) LAST-LINE))
    (MOVE-BP (INTERVAL-LAST-BP NODE) LAST-BP)
;   (SETF (NODE-TICK NODE) ':READ-ONLY)
    ))

(DEFMETHOD (:REVERT SUBNODE-SPECIAL-PURPOSE-BUFFER :AFTER) ()
  (AND (NULL (CDR INFERIORS))
       (MOVE-BP (INTERVAL-LAST-BP (CAR INFERIORS)) LAST-BP))
  (SEND SELF ':RESTART))

(DEFMETHOD (:RESTART SUBNODE-SPECIAL-PURPOSE-BUFFER) ()
  (MOVE-BP (SEND SELF :POINT) (INTERVAL-LAST-BP (CAR INFERIORS)))
  (MOVE-BP SAVED-WINDOW-START-BP FIRST-BP))

(DEFMETHOD (:ADD-NODE SUBNODE-SPECIAL-PURPOSE-BUFFER) (FLAVOR &REST OPTIONS)
  (LET ((NODE (LEXPR-FUNCALL #'MAKE-INSTANCE FLAVOR OPTIONS)))
    (CREATE-INTERVAL NIL NIL NODE)
    (SEND INTERVAL-STREAM ':SET-BP (INTERVAL-LAST-BP NODE))
    (SEND NODE ':DESCRIPTION INTERVAL-STREAM)
    (LET* ((INFS (LAST INFERIORS))
	   (INF (CAR INFS)))
      (SETF (NODE-NEXT INF) NODE)
      (SETF (NODE-PREVIOUS NODE) INF)
      (RPLACD INFS (NCONS NODE))
      (SETF (NODE-SUPERIOR NODE) SELF)
      (LET ((NODE-FIRST-LINE (BP-LINE (INTERVAL-FIRST-BP NODE)))
	    (NODE-LAST-LINE (BP-LINE (INTERVAL-LAST-BP NODE)))
	    (LAST-LINE (BP-LINE LAST-BP)))
	(SETF (LINE-NEXT (LINE-PREVIOUS LAST-LINE)) NODE-FIRST-LINE)
	(SETF (LINE-PREVIOUS NODE-FIRST-LINE) (LINE-PREVIOUS LAST-LINE))
	(SETF (LINE-NEXT NODE-LAST-LINE) LAST-LINE)
	(SETF (LINE-PREVIOUS LAST-LINE) NODE-LAST-LINE))
      (MOVE-BP (INTERVAL-LAST-BP NODE) LAST-BP)
      (MOVE-BP (INTERVAL-LAST-BP INF) (INTERVAL-FIRST-BP NODE)))
;   (SETF (NODE-TICK NODE) ':READ-ONLY)
    NODE))

(DEFMETHOD (:DELETE-NODE SUBNODE-SPECIAL-PURPOSE-BUFFER) (NODE)
  (DELETE-INTERVAL NODE)
  (SETQ INFERIORS (DELQ NODE INFERIORS))
  (LET ((PREV (NODE-PREVIOUS NODE))
	(NXT (NODE-NEXT NODE)))
    (AND PREV (SETF (NODE-NEXT PREV) NXT))
    (AND NXT (SETF (NODE-PREVIOUS NXT) PREV))))

;;; Splice in a new node just before where we are
;;; AT-NODE may be a node, :POINT, or NIL (meaning the end)
;;; If POINT is on the old node, it moves to the new one
(DEFMETHOD (:ADD-NODE-BEFORE-NODE SUBNODE-SPECIAL-PURPOSE-BUFFER) (AT-NODE FLAVOR
								   &REST OPTIONS &AUX NODE)
  (LET* ((POINT (SEND SELF ':POINT))
	 (POINT-P (OR (EQ AT-NODE ':POINT)
		      (BP-= POINT (IF AT-NODE (INTERVAL-FIRST-BP AT-NODE)
					      (INTERVAL-LAST-BP SELF)))))
	 (INF (IF (EQ AT-NODE ':POINT) (BP-NODE POINT) AT-NODE))
	 (INFS (AND INF (LOOP FOR L ON INFERIORS
			      WHEN (EQ (CADR L) INF) RETURN L)))
	 (PREV (AND INF (NODE-PREVIOUS INF))))
    (COND (INFS
	   (SETQ NODE (LEXPR-FUNCALL #'MAKE-INSTANCE FLAVOR OPTIONS))
	   (CREATE-INTERVAL NIL NIL NODE)
	   (AND PREV (SETF (NODE-NEXT PREV) NODE))
	   (SETF (NODE-PREVIOUS NODE) PREV)
	   (SETF (NODE-NEXT NODE) INF)
	   (SETF (NODE-PREVIOUS INF) NODE)
	   (PUSH NODE (CDR INFS))
	   (SETF (NODE-SUPERIOR NODE) SELF)
	   (LET* ((NODE-LINE (BP-LINE (INTERVAL-FIRST-BP NODE)))
		  (NEXT-LINE (BP-LINE (INTERVAL-FIRST-BP INF)))
		  (PREVIOUS-LINE (LINE-PREVIOUS NEXT-LINE)))
	     (SETF (LINE-NEXT PREVIOUS-LINE) NODE-LINE)
	     (SETF (LINE-PREVIOUS NODE-LINE) PREVIOUS-LINE)
	     (SETF (LINE-NEXT NODE-LINE) NEXT-LINE)
	     (SETF (LINE-PREVIOUS NEXT-LINE) NODE-LINE))
	   (SEND INTERVAL-STREAM ':SET-BP (INTERVAL-LAST-BP NODE))
	   (SEND NODE ':DESCRIPTION INTERVAL-STREAM)
	   (MOVE-BP (INTERVAL-LAST-BP NODE) (INTERVAL-FIRST-BP INF))
	   (MOVE-BP (INTERVAL-LAST-BP PREV) (INTERVAL-FIRST-BP NODE))
	   ;(SETF (NODE-TICK NODE) ':READ-ONLY)
	   )
	  (T					;Goes at end
	   (SETQ NODE (LEXPR-SEND SELF ':ADD-NODE FLAVOR OPTIONS))))
    (AND POINT-P (MOVE-BP POINT (BP-LINE (INTERVAL-FIRST-BP NODE)) 0))
    NODE))

(DEFMETHOD (:NEXT-NODE SUBNODE-SPECIAL-PURPOSE-BUFFER)
	   (&OPTIONAL (PEEK-P (SEND SELF ':NEXT-NODE-PEEK-P)))
  (DO* ((POINT (SEND SELF ':POINT))
	(BP POINT))
       (NIL)
    (IF (BP-= BP LAST-BP) (RETURN NIL)
	(LET ((NODE (BP-NODE BP)))
	  (SETQ BP (INTERVAL-LAST-BP NODE))
	  (WHEN (SEND NODE ':OPERATION-HANDLED-P ':SELECT-POSSIBILITY)
	    (OR PEEK-P (MOVE-BP POINT BP))
	    (RETURN NODE))))))

(DEFMETHOD (:NEXT-NODE-PEEK-P SUBNODE-SPECIAL-PURPOSE-BUFFER) () NIL)

(DEFFLAVOR HEADER-DESCRIPTION-1-SUBNODE-SPECIAL-PURPOSE-BUFFER-MIXIN () ()
  (:REQUIRED-FLAVORS SUBNODE-SPECIAL-PURPOSE-BUFFER)
  (:REQUIRED-METHODS :HEADER-DESCRIPTION-1 :LIST-SUBNODES))

(DEFMETHOD (:HEADER-DESCRIPTION HEADER-DESCRIPTION-1-SUBNODE-SPECIAL-PURPOSE-BUFFER-MIXIN)
	   (STREAM)
  (SEND SELF ':HEADER-DESCRIPTION-1 STREAM 2)
  (SEND SELF ':ADDITIONAL-HEADER-DESCRIPTION STREAM)
  (PRINC ":" STREAM))

(DEFMETHOD (:ADDITIONAL-HEADER-DESCRIPTION HEADER-DESCRIPTION-1-SUBNODE-SPECIAL-PURPOSE-BUFFER-MIXIN :DEFAULT) (STREAM)
  STREAM) ;ignored

(DEFMETHOD (:DOCUMENT HEADER-DESCRIPTION-1-SUBNODE-SPECIAL-PURPOSE-BUFFER-MIXIN) (IGNORE)
  (PRINC "Edit next ")
  (SEND SELF ':HEADER-DESCRIPTION-1 STANDARD-OUTPUT 1)
  (PRINC "."))

(DEFMETHOD (:LIST-POSSIBILITIES HEADER-DESCRIPTION-1-SUBNODE-SPECIAL-PURPOSE-BUFFER-MIXIN)
	   (REMAINING-P)
  (LET ((FIRST-NODE (IF REMAINING-P (SEND SELF ':NEXT-NODE T) (CADR INFERIORS))))
    (FUNCALL STANDARD-OUTPUT ':FRESH-LINE)
    (COND ((NULL FIRST-NODE)
	   (PRINC (IF (AND REMAINING-P (CDR INFERIORS)) "No more " "No "))
	   (SEND SELF ':HEADER-DESCRIPTION-1 *TYPEOUT-WINDOW* 2))
	  (T
	   (AND REMAINING-P
		(NEQ FIRST-NODE (CADR INFERIORS))
		(PRINC "Remaining "))
	   (SEND SELF ':HEADER-DESCRIPTION-1 *TYPEOUT-WINDOW*
		 (IF (NOT (NULL (NODE-NEXT FIRST-NODE))) 2 1))
	   (SEND SELF ':ADDITIONAL-HEADER-DESCRIPTION *TYPEOUT-WINDOW*)
	   (SEND *TYPEOUT-WINDOW* ':FRESH-LINE)
	   (SEND SELF ':LIST-SUBNODES FIRST-NODE)))))

(DEFFLAVOR POSSIBILITY-SUBNODE () (NODE)
  (:REQUIRED-METHODS :SELECT-POSSIBILITY :DESCRIPTION))

(DEFFLAVOR POSSIBILITIES-SPECIAL-PURPOSE-BUFFER-MIXIN () ()
  (:REQUIRED-FLAVORS SPECIAL-PURPOSE-BUFFER)
  (:REQUIRED-METHODS :DOCUMENT :LIST-POSSIBILITIES :NEXT-NODE :HEADER-DESCRIPTION))

(DEFMETHOD (:POPPING-POSSIBILITY POSSIBILITIES-SPECIAL-PURPOSE-BUFFER-MIXIN) ()
  )

;;; Possibilities that aren't easily regenerated should stay around; this is
;;; the default for possibilities.
(DEFMETHOD (:REUSABLE POSSIBILITIES-SPECIAL-PURPOSE-BUFFER-MIXIN) (IGNORE)
  NIL)

(DEFFLAVOR POSSIBILITIES-SPECIAL-PURPOSE-BUFFER ()
	   (POSSIBILITIES-SPECIAL-PURPOSE-BUFFER-MIXIN SUBNODE-SPECIAL-PURPOSE-BUFFER))

(DEFFLAVOR REUSABLE-POSSIBILITIES-SPECIAL-PURPOSE-BUFFER-MIXIN
	() (POSSIBILITIES-SPECIAL-PURPOSE-BUFFER-MIXIN))

;;; Possibilities buffers that are easily regenerated and should go away when they are
;;; not in use any more.
(DEFMETHOD (:REUSABLE REUSABLE-POSSIBILITIES-SPECIAL-PURPOSE-BUFFER-MIXIN) (IGNORE)
  (NOT (MEMQ SELF *ZMACS-POSSIBILITIES-BUFFERS*)))


(DEFCOM COM-NEXT-POSSIBILITY DOCUMENT-NEXT-POSSIBILITY ()
  (WHEN (AND (NOT *NUMERIC-ARG-P*)
	     (LISTP *LAST-COMMAND-TYPE*)
	     (EQ (FIRST *LAST-COMMAND-TYPE*) 'FAST-LIST-CALLERS))
    (EDIT-FUNCTION-LIST (SECOND *LAST-COMMAND-TYPE*))
    (RETURN-FROM COM-NEXT-POSSIBILITY DIS-ALL))
  (WHEN (AND (TYPEP *INTERVAL* 'POSSIBILITIES-SPECIAL-PURPOSE-BUFFER-MIXIN)
	     (NEQ *INTERVAL* (CAR *ZMACS-POSSIBILITIES-BUFFERS*)))
    (SETQ *ZMACS-POSSIBILITIES-BUFFERS* (CONS *INTERVAL*
					      (REMQ *INTERVAL*
						    *ZMACS-POSSIBILITIES-BUFFERS*)))
    (PUSH-POP-POSSIBILITIES-BUFFER-1))
  (NEXT-POSSIBILITY (COND ((NULL *NUMERIC-ARG-P*) ':START-EDITING)
			  ((MINUSP *NUMERIC-ARG*) ':POP-POSSIBILITIES-BUFFER)
			  ((ZEROP *NUMERIC-ARG*) ':SELECT-POSSIBILITIES-BUFFER)
			  (T ':LIST-REMAINING-POSSIBILITIES))))

(DEFUN NEXT-POSSIBILITY (ACTION)
  (AND (NULL *ZMACS-POSSIBILITIES-BUFFERS*)
       (BARF "No more sets of possibilities."))
  (LET ((BUFFER (CAR *ZMACS-POSSIBILITIES-BUFFERS*)))
    (SELECTQ ACTION
      (:START-EDITING
       (LET ((NODE (SEND BUFFER ':NEXT-NODE)))
	 (IF (NOT (NULL NODE))
	     (SEND NODE ':SELECT-POSSIBILITY)
	     (BEEP)
	     (TYPEIN-LINE "No more ")
	     (SEND BUFFER ':HEADER-DESCRIPTION *TYPEIN-WINDOW*)
	     (POP-POSSIBILITIES-BUFFER))))
      (:POP-POSSIBILITIES-BUFFER
       (TYPEIN-LINE "Popping off ")
       (LET ((STANDARD-OUTPUT *TYPEIN-WINDOW*))
	 (SEND BUFFER ':DOCUMENT ':SHORT))
       (POP-POSSIBILITIES-BUFFER))
      (:SELECT-POSSIBILITIES-BUFFER
       (MAKE-BUFFER-CURRENT BUFFER)
       DIS-NONE)
      ((:LIST-POSSIBILITIES :LIST-REMAINING-POSSIBILITIES)
       (SEND BUFFER ':LIST-POSSIBILITIES (EQ ACTION ':LIST-REMAINING-POSSIBILITIES))
       DIS-NONE)
      (OTHERWISE
       (FERROR NIL "~S is not a known action" ACTION)))))

(DEFUN PUSH-POSSIBILITIES-BUFFER (ACTION TYPE &REST SET-OPTIONS)
  (LET ((BUFFER (LEXPR-SEND *CURRENT-COMMAND-LOOP* ':FIND-SPECIAL-BUFFER TYPE T SET-OPTIONS)))
    (COND ((OR (NOT (NULL (SEND BUFFER ':NEXT-NODE T)))
	       (NOT (MEMQ ACTION '(:START-EDITING :LIST-POSSIBILITIES))))
	   (PUSH BUFFER *ZMACS-POSSIBILITIES-BUFFERS*)
	   (PUSH-POP-POSSIBILITIES-BUFFER-1)
	   (AND ACTION (NEXT-POSSIBILITY ACTION)))
	  ((EQ ACTION ':START-EDITING)
	   (TYPEIN-LINE "There are no ")
	   (SEND BUFFER ':HEADER-DESCRIPTION *TYPEIN-WINDOW*)
	   DIS-NONE)
	  (T
	   (SEND BUFFER ':LIST-POSSIBILITIES (EQ ACTION ':LIST-REMAINING-POSSIBILITIES))
	   DIS-NONE))))

(DEFUN POP-POSSIBILITIES-BUFFER ()
  (SEND (CAR *ZMACS-POSSIBILITIES-BUFFERS*) ':POPPING-POSSIBILITY)
  (POP *ZMACS-POSSIBILITIES-BUFFERS*)
  (IF (NULL *ZMACS-POSSIBILITIES-BUFFERS*)
      (TYPEIN-LINE "Now no more sets of possibilities.")
      (PUSH-POP-POSSIBILITIES-BUFFER-1))
  DIS-NONE)

(DEFUN PUSH-POP-POSSIBILITIES-BUFFER-1 ()
  (TYPEIN-LINE "~A is now " (KEY-FOR-COMMAND 'COM-NEXT-POSSIBILITY))
  (LET ((STANDARD-OUTPUT *TYPEIN-WINDOW*))
    (SEND (CAR *ZMACS-POSSIBILITIES-BUFFERS*) ':DOCUMENT ':SHORT)))

(DEFUN DOCUMENT-NEXT-POSSIBILITY (COMMAND CHAR OP)
  (SELECTQ OP
    (:FULL  (FORMAT T "~&Select the next possibility for the current set of possibilities.~%")
	    (IF (NULL *ZMACS-POSSIBILITIES-BUFFERS*)
		(FORMAT T "There are currently no sets of possibilities.~%")
		(SEND (CAR *ZMACS-POSSIBILITIES-BUFFERS*) ':DOCUMENT ':FULL))
	    (FORMAT T "~&With a negative argument, pops off a set of possibilities.
With an explicit positive argument, lists remaining possibilities in the current set.
With an argument of zero, selects the current buffer of possibilities."))
    (:SHORT (IF (NULL *ZMACS-POSSIBILITIES-BUFFERS*)
		(FORMAT T "There are currently no sets of possibilities.~%")
		(SEND (CAR *ZMACS-POSSIBILITIES-BUFFERS*) ':DOCUMENT ':SHORT)))
    (:NAME  (GET COMMAND 'COMMAND-NAME))
    (OTHERWISE (FERROR NIL "Unknown operation ~A; ~S ~S" OP COMMAND CHAR))))



(DEFCOM COM-LIST-POSSIBILITIES "List the current stack of possibilities buffers" ()
  (IF (NULL *ZMACS-POSSIBILITIES-BUFFERS*)
      (TYPEIN-LINE "There are currently no sets of possibilities.")
    (LET* ((BUFFERS-AND-DESCRIPTIONS (LOOP FOR BUFFER IN *ZMACS-POSSIBILITIES-BUFFERS*
					   COLLECT (LIST BUFFER (SEND BUFFER ':DESCRIPTION))))
	   (MAXL (1+ (MAX (LOOP FOR (NIL DESC) IN BUFFERS-AND-DESCRIPTIONS
				MAXIMIZE (STRING-LENGTH DESC))
			  (STRING-LENGTH "Possibility set")))))
      (FORMAT T "~&~A~VTBuffer~%" "Possibility set" MAXL)
      (LOOP FOR (BUFFER DESC) IN BUFFERS-AND-DESCRIPTIONS
	    DO (FORMAT T "~&~A~VT" DESC MAXL)
	       (SCL:PRESENT BUFFER))
      (FORMAT T "~&Done.~%")))
  DIS-NONE)


(DEFFLAVOR SECTION-SUBNODE
	(SECTION BUFFER)
	(POSSIBILITY-SUBNODE)
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:SELECT-POSSIBILITY SECTION-SUBNODE) ()
  (WHEN (WHEN (MEMQ BUFFER *ZMACS-BUFFER-LIST*)
	  (CHECK-INTERVAL-SECTIONS
	    (IF (OR (BP-= (INTERVAL-FIRST-BP SECTION) (INTERVAL-LAST-BP SECTION))
		    (EQ (LINE-TICK (SECTION-NODE-DEFINITION-LINE SECTION)) 'DELETED))
		BUFFER
		SECTION))
	  (MEMQ SECTION (BUFFER-SECTIONS BUFFER)))
    (SEND *ZMACS-COMMAND-LOOP* ':SET-INTERVAL BUFFER)
    (LET ((BP (CREATE-BP (SECTION-NODE-DEFINITION-OR-FIRST-LINE SECTION) 0)))
      (RECENTER-WINDOW *WINDOW* ':START (BACKWARD-OVER-COMMENT-LINES BP NIL))
      (MOVE-POINT BP)))
  DIS-TEXT)

(DEFMETHOD (:DESCRIPTION SECTION-SUBNODE) (STREAM)
  (PRINC (SEND SECTION ':DEFINITION-NAME) STREAM))

(DEFFLAVOR SECTION-SUBNODE-SPECIAL-PURPOSE-BUFFER () ()
  (:REQUIRED-FLAVORS SUBNODE-SPECIAL-PURPOSE-BUFFER))

(DEFMETHOD (:LIST-SUBNODES SECTION-SUBNODE-SPECIAL-PURPOSE-BUFFER) (FIRST-NODE)
  (SCL:FORMAT-ITEM-LIST (LOOP FOR NODE FIRST FIRST-NODE THEN (NODE-NEXT NODE)
			      WHILE NODE
			      COLLECT (LET ((BUFFER (SEND NODE :BUFFER))
					    (SECTION (SEND NODE :SECTION)))
					(LIST SECTION BUFFER)))
			:PRESENTATION-TYPE 'SECTION))


;;; Buffers just used to hold random typeout

(DEFUN MAKE-TYPEOUT-BUFFER-STREAM (TYPE &REST SETS)
  (LET ((BUFFER (LEXPR-SEND *CURRENT-COMMAND-LOOP* ':FIND-SPECIAL-BUFFER TYPE T SETS)))
    (MAKE-BROADCAST-STREAM *TYPEOUT-WINDOW* (OPEN-INTERVAL-STREAM BUFFER))))
