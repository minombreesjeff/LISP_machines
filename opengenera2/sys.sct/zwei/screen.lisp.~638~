;;; -*- Syntax: Zetalisp; Mode: Lisp; Package: ZWEI; Base: 8 -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This file contains the interface between the editor and the screen system.
;;; A ZWEI-window is the editor's data structure.  A window-sheet is the screen
;;; system's active data structure.

;;; Most of the functions in this file do not run in the regular editor
;;; environment and may not use the editor global variables.  The sheet
;;; methods are only allowed to touch the "wrapper" of a window: the outline,
;;; the label, and the blinkers.  Any operation involving the window per se
;;; or other editor data structures is done by sending a request to the
;;; editor process that owns the window.  A request is a "character" in
;;; the input stream which is actually a list.  There is a slight exception
;;; to this in changing the edges of a window, the ZWEI-window data-structure is
;;; altered immediately.

;;; The following are the requests to the editor process.  Note that if these
;;; are seen by other than the command-loop, some should be ignored and some should
;;; be executed anyway.
;;; (REDISPLAY) - wakes up the editor process so that it will do a redisplay.
;;;	The degree is not passed in this request, but stored directly into the
;;;	window, so that if the editor does a redisplay on its own before processing
;;;	the request the right things will happen.  If the window system tells the window
;;;	to redisplay with DIS-ALL, we want to make sure the window knows it is munged
;;;	if the editor displays on it, and we want to avoid redisplaying twice.
;;; (SELECT-WINDOW window) - causes Zmacs to select this window as the current window.
;;;	This is used to reflect window-selection by mouse to the editor, mainly
;;;	for the case of one editor that knows about more than one window.
;;; (SCROLL window line-number) - put line-number line of the buffer at the top of the window.
;;;	The argument is not guaranteed to be in range.
;;;	This does not deal in continuation lines.
;;; (MOUSE window mouse-char window-relative-X window-relative-Y) - mouse command.

;;; Functions called by the Editor

;;; Called when a window is selected by editor command, to inform the
;;; sheet.  Note that this must NOT send a SELECT-WINDOW request back to
;;; the editor!  (Consider interaction with macros, type-ahead)
(DEFUN SELECT-WINDOW (ZWEI-WINDOW &AUX SHEET)
  (SETQ SHEET (WINDOW-SHEET ZWEI-WINDOW))
  (COND ((EQ ZWEI-WINDOW *MINI-BUFFER-WINDOW*)
	 (OR (MEMQ ZWEI-WINDOW *WINDOW-LIST*)
	     (PUSH ZWEI-WINDOW *WINDOW-LIST*))))
  (UNLESS (TV:SHEET-SELECTED-P SHEET)
    ;; Only do a real :SELECT if selected window is anywhere in our hierarchy
    ;; or there is no selected-window but our frame is exposed.
    (LET ((*EDITOR-ALREADY-KNOWS* T))
      (SEND SHEET :SELECT-RELATIVE)))
  ;(COMTAB-MOUSE-PROMPT *COMTAB* (WINDOW-WHO-LINE-DOCUMENTATION-STRING ZWEI-WINDOW))
  )


;;; Called when the label of the window might have changed
(DEFUN CHANGE-WINDOW-LABEL (ZWEI-WINDOW)
  (SEND (WINDOW-SHEET ZWEI-WINDOW) :CHANGE-LABEL
	(BUFFER-NAME-FOR-DISPLAY (WINDOW-INTERVAL ZWEI-WINDOW))))

;;; Call before redisplaying a window.
;;; This deactivates the window's typeout stream.
(DEFUN PREPARE-WINDOW-FOR-REDISPLAY (ZWEI-WINDOW)
  (LET ((SHEET (WINDOW-SHEET ZWEI-WINDOW))
	(*EDITOR-ALREADY-KNOWS* T))
    (UNLESS (TV:SHEET-EXPOSED-P SHEET)
      (SEND SHEET :EXPOSE))
    (LET ((TYPEOUT-WINDOW (TV:ESSENTIAL-WINDOW-WITH-TYPEOUT-MIXIN-TYPEOUT-WINDOW SHEET)))
      (WHEN (AND TYPEOUT-WINDOW (TV:BASIC-TYPEOUT-WINDOW-BOTTOM-REACHED TYPEOUT-WINDOW))
	;; See (:DRAW-BOTTOM-LINE TV:ESSENTIAL-WINDOW-WITH-TYPEOUT-MIXIN), which is trying to
	;; do us a favor by clearing integral multiples of line-height, which is really only
	;; correct for fixed height lines.
	(LET ((BOTTOM-REACHED (LET ((Y (+ (SEND TYPEOUT-WINDOW :BOTTOM-REACHED)
					  (SEND TYPEOUT-WINDOW :Y-OFFSET))))
				(TV:ROUND-UP (+ Y TV:*TYPEOUT-LINE-HEIGHT* 1)
					     (TV:SHEET-LINE-HEIGHT SHEET))))
	      (N-PLINES (WINDOW-N-PLINES ZWEI-WINDOW)))
	  (SEND TYPEOUT-WINDOW :DEACTIVATE)
	  (SETF (WINDOW-REDISPLAY-DEGREE ZWEI-WINDOW)
		(MAX DIS-TEXT (WINDOW-REDISPLAY-DEGREE ZWEI-WINDOW)))
	  (LET ((N-PLINES-CLOBBERED (LOOP FOR PLINE BELOW N-PLINES
					  WHILE (> BOTTOM-REACHED (PLINE-Y ZWEI-WINDOW PLINE))
					  FINALLY (RETURN PLINE))))
	    ;; Force redisplay of the lines that were used for typeout.
	    (DOTIMES (I N-PLINES-CLOBBERED)
	      (SETF (PLINE-TICK ZWEI-WINDOW I) -1)
	      (SETF (PLINE-MARKING-LEFT ZWEI-WINDOW I) NIL))
	    ;; Erase anything that redisplay won't handle.  Isn't always 1- N-PLINES-CLOBBERED
	    ;; so as to properly clear a partial pline that's clobbered.
	    (LET ((CLOBBERED-PLINE-Y (IF (> N-PLINES 0)
					 (PLINE-Y ZWEI-WINDOW (MIN N-PLINES-CLOBBERED
								   (1- N-PLINES)))
					 0)))
	      (WHEN (> BOTTOM-REACHED CLOBBERED-PLINE-Y)
		(SEND SHEET :DRAW-RECTANGLE
		      (TV:SHEET-INSIDE-WIDTH SHEET) (- BOTTOM-REACHED CLOBBERED-PLINE-Y)
		      0 CLOBBERED-PLINE-Y :ERASE)))))))
    ;; This is pretty cheap, since it doesn't do anything unless it needs to.
    (SEND SHEET :UPDATE-LABEL)))

;;; This is called to see if the window should not be redisplayed, because it
;;; is de-exposed, or because it is covered by typeout and not selected (this
;;; allows you to continue to look at typeout while typing in the mini-buffer.)
;;; If the window is going to be exposed and selected when it is redisplayed,
;;; then it is done here.
(DEFUN WINDOW-READY-P (ZWEI-WINDOW &OPTIONAL (CURRENT-WINDOW-SPECIAL T) &AUX SHEET)
  (SETQ SHEET (WINDOW-SHEET ZWEI-WINDOW))
  (AND (NOT (TV:SHEET-OUTPUT-HELD-P SHEET))
       (OR (AND CURRENT-WINDOW-SPECIAL (EQ ZWEI-WINDOW *WINDOW*))
	   (LET ((TYPEOUT-WINDOW (SEND SHEET :TYPEOUT-WINDOW)))
	     (OR (NULL TYPEOUT-WINDOW)
		 (NOT (SEND TYPEOUT-WINDOW :BOTTOM-REACHED)))))))

;;; Find out if the window is on the screen in any way, even if covered by typeout
(DEFUN WINDOW-EXPOSED-P (ZWEI-WINDOW)
  (NOT (DO SHEET (WINDOW-SHEET ZWEI-WINDOW) (TV:SHEET-SUPERIOR SHEET) (NULL SHEET)
	   (OR (TV:SHEET-EXPOSED-P SHEET) (RETURN T)))))

;;; Find out if this window is covered by typeout, regardless of whether it
;;; is exposed, regardless of what *TYPEOUT-WINDOW* is doing, and regardless
;;; of whether the typeout will go away on the next redisplay.
(DEFUN WINDOW-COVERED-BY-TYPEOUT-P (ZWEI-WINDOW)
  (LET ((TYPEOUT-WINDOW (WINDOW-TYPEOUT-WINDOW ZWEI-WINDOW)))
    (AND TYPEOUT-WINDOW (SEND TYPEOUT-WINDOW :BOTTOM-REACHED))))

;;; Return the typeout stream associated with the given window
(DEFUN WINDOW-TYPEOUT-WINDOW (ZWEI-WINDOW)
  (SEND (WINDOW-SHEET ZWEI-WINDOW) :TYPEOUT-WINDOW))

(DEFUN TYPEOUT-WINDOW-INCOMPLETE-P (TYPEOUT-WINDOW)
  (SEND TYPEOUT-WINDOW :INCOMPLETE-P))

(DEFUN WINDOW-IO-BUFFER (ZWEI-WINDOW)
  (FUNCALL (WINDOW-SHEET ZWEI-WINDOW) ':IO-BUFFER))

#||
;;; This returns the string which can be clobbered to the new documentation
;;; when the mouse command-table changes.
(DEFUN WINDOW-WHO-LINE-DOCUMENTATION-STRING (ZWEI-WINDOW)
  (FUNCALL (WINDOW-SHEET ZWEI-WINDOW) ':MOUSE-DOCUMENTATION-STRING))
||#

(DEFUN DISAPPEAR-MINI-BUFFER-WINDOW ()
  ;; Bring the typein window back, and hence get rid of the mini-buffer
  (TV:BLINKER-SET-VISIBILITY (WINDOW-POINT-BLINKER *MINI-BUFFER-WINDOW*) NIL)
  (DO L (WINDOW-SPECIAL-BLINKER-LIST *MINI-BUFFER-WINDOW*) (CDR L) (NULL L)
    (TV:BLINKER-SET-VISIBILITY (CDAR L) NIL))
  (FUNCALL *TYPEIN-WINDOW* ':EXPOSE)
  (FUNCALL (WINDOW-SHEET *MINI-BUFFER-WINDOW*) ':DEACTIVATE)
  (FUNCALL *MODE-LINE-WINDOW* ':DONE-WITH-MODE-LINE-WINDOW))

(DEFUN FLUSH-PROCESS-WINDOWS (PROCESS)
  (TV:MAP-OVER-SHEETS #'(LAMBDA (W)
			  (AND (GET-HANDLER-FOR W ':PROCESS)
			       (EQ (FUNCALL W ':PROCESS) PROCESS)
			       (FUNCALL W ':DEACTIVATE)))))

(DEFUN TYPEOUT-BEEP-YES-OR-NO-P (&REST FORMAT-ARGS)
  (LET ((QUERY-IO *TYPEOUT-WINDOW*))
    (LEXPR-FUNCALL #'FQUERY '#,`(:SELECT T
				 :BEEP T
				 :TYPE :READLINE
				 :CHOICES ,FORMAT:YES-OR-NO-P-CHOICES)
		   FORMAT-ARGS)))

(DEFVAR *ZMACS-SHOULD-BURY-ON-EXIT* T)

(DEFMETHOD (:EXIT ZMACS-TOP-LEVEL-EDITOR) ()
  ;; Go back to the window in which (ZED) was last done.
  (LET ((WINDOW (IF (AND *ZMACS-CALLER-WINDOW*
			 (NEQ (SEND *ZMACS-CALLER-WINDOW* ':STATUS) ':DEACTIVATED))
		    *ZMACS-CALLER-WINDOW*
		    (TV:FIND-WINDOW-OF-FLAVOR 'TV:LISTENER-MIXIN))))
    (AND WINDOW (FUNCALL WINDOW ':SELECT NIL)))
  (AND *ZMACS-SHOULD-BURY-ON-EXIT*
       (FUNCALL (WINDOW-FRAME *WINDOW*) ':BURY))
  ;; Replacing (SI:PROCESS-WAIT-FOREVER) with (TV:AWAIT-WINDOW-EXPOSURE)
  ;; looks atractive but it won't work, because TERMINAL-IO
  ;; isn't bound to the right thing here.
  ;; (SI:PROCESS-WAIT-FOREVER)
  )

(DEFUN FLUSH-PROCESS (PROCESS)
  (FUNCALL PROCESS ':FLUSH))

(DEFUN RESET-PROCESS (PROCESS)
  (FUNCALL PROCESS ':RESET))

(DEFUN NOTIFY-SCROLL-BAR (ZWEI-WINDOW)
  (FUNCALL (WINDOW-SHEET ZWEI-WINDOW) ':NEW-SCROLL-POSITION))

;;; If text has changed, make sure the mouse blinker knows about it
(DEFUN MOUSE-RETHINK (ZWEI-WINDOW)
  (LET* ((SHEET (WINDOW-SHEET ZWEI-WINDOW))
	 (MOUSE (TV:SHEET-MOUSE SHEET)))
    (WHEN (EQ SHEET (TV:MOUSE-WINDOW MOUSE))
      (TV:MOUSE-WAKEUP MOUSE))))

(DEFUN GET-WINDOW-EDGES (ZWEI-WINDOW)
  (FUNCALL (WINDOW-SHEET ZWEI-WINDOW) ':EDGES))

(DEFUN DEACTIVATE-WINDOW (ZWEI-WINDOW)
  (FUNCALL (WINDOW-SHEET ZWEI-WINDOW) ':DEACTIVATE))

(DEFUN WINDOW-BACKSPACE-OVERPRINTING-FLAG (ZWEI-WINDOW)
  (ZEROP (TV:SHEET-BACKSPACE-NOT-OVERPRINTING-FLAG (WINDOW-SHEET ZWEI-WINDOW))))

(DEFUN REDEFINE-WINDOW-BACKSPACE-FLAG (ZWEI-WINDOW BACKSPACE-OVERPRINTING-FLAG)
  (LET* ((SHEET (WINDOW-SHEET ZWEI-WINDOW))
	 (OLD (TV:SHEET-BACKSPACE-NOT-OVERPRINTING-FLAG SHEET))
	 (NEW (IF BACKSPACE-OVERPRINTING-FLAG 0 1)))
    (COND (( OLD NEW)
	   (SETF (TV:SHEET-BACKSPACE-NOT-OVERPRINTING-FLAG (WINDOW-SHEET ZWEI-WINDOW)) NEW)
	   (MUNG-LINES-WITH-CHAR #\BS ZWEI-WINDOW)))))

(DEFUN WINDOW-TAB-NCHARS (ZWEI-WINDOW)
  (TV:SHEET-TAB-NCHARS (WINDOW-SHEET ZWEI-WINDOW)))

(DEFUN REDEFINE-WINDOW-TAB-NCHARS (ZWEI-WINDOW TAB-NCHARS)
  (LET* ((SHEET (WINDOW-SHEET ZWEI-WINDOW))
	 (OLD (TV:SHEET-TAB-NCHARS SHEET)))
    (COND (( OLD TAB-NCHARS)
	   (SETF (TV:SHEET-TAB-NCHARS (WINDOW-SHEET ZWEI-WINDOW)) TAB-NCHARS)
	   (MUNG-LINES-WITH-CHAR #\TAB ZWEI-WINDOW)))))

(DEFUN MUNG-LINES-WITH-CHAR (CH ZWEI-WINDOW)
  (DO ((I 0 (1+ I))
       (NPLINES (WINDOW-N-PLINES ZWEI-WINDOW))
       (LINE)
       (FLAG NIL))
      (( I NPLINES)
       (AND FLAG (SETF (WINDOW-REDISPLAY-DEGREE ZWEI-WINDOW)
		       (MAX (WINDOW-REDISPLAY-DEGREE ZWEI-WINDOW) DIS-TEXT))))
    (COND ((AND (SETQ LINE (PLINE-LINE ZWEI-WINDOW I))
		(STRING-SEARCH-CHAR CH LINE (PLINE-FROM-INDEX ZWEI-WINDOW I)
				    (MIN (LINE-LENGTH LINE)
					 (PLINE-TO-INDEX ZWEI-WINDOW I))))
	   (SETF (PLINE-TICK ZWEI-WINDOW I) 0)
	   (SETQ FLAG T)))))

(DEFSUBST WINDOW-VSP (ZWEI-WINDOW)
  (SEND (WINDOW-SHEET ZWEI-WINDOW) :VSP))

(DEFUN SET-WINDOW-VSP (ZWEI-WINDOW NEW-VSP)
  (SETF (WINDOW-VSP ZWEI-WINDOW) NEW-VSP))

;;; Two window stuff, takes two windows (structures, not sheets)
;;; and makes them share the area originally occupied by the first of the two.
;;; Returns the edges of the area which they now share.
(DEFUN TWO-WINDOWS (ZWEI-WINDOW-1 ZWEI-WINDOW-2)
  (REDISPLAY ZWEI-WINDOW-1 :NONE)
  (LET ((W1 (WINDOW-SHEET ZWEI-WINDOW-1))
	(W2 (WINDOW-SHEET ZWEI-WINDOW-2))
	(FRAME (WINDOW-FRAME ZWEI-WINDOW-1)))
    (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
	(SEND W1 :EDGES)
      (TV:DELAYING-SCREEN-MANAGEMENT
	(SEND W1 :DEEXPOSE)
	(SEND W2 :DEEXPOSE)
	(LET ((HEIGHT (// (- BOTTOM TOP) 2)))
	  (SEND W1 :SET-EDGES LEFT TOP RIGHT (+ TOP HEIGHT))
	  (SEND W2 :SET-EDGES LEFT (+ TOP HEIGHT) RIGHT BOTTOM))
	(SEND W1 :EXPOSE)	;Make sure they are both there
	(SEND W2 :EXPOSE)))
    (SEND FRAME :UPDATE-LABELS)))

;;; Grow a window, shrinking the other one
(DEFUN GROW-WINDOW (ZWEI-WINDOW-1 ZWEI-WINDOW-2 NLINES)
  (LET ((W1 (WINDOW-SHEET ZWEI-WINDOW-1))
	(W2 (WINDOW-SHEET ZWEI-WINDOW-2)))
    (LET ((HEIGHT (* NLINES (TV:SHEET-LINE-HEIGHT W1)))
	  LEFT TOP RIGHT BOTTOM BOTTOM1 TOP2)
      (MULTIPLE-VALUE (LEFT TOP RIGHT BOTTOM1)
	  (FUNCALL W1 ':EDGES))
      (MULTIPLE-VALUE (NIL TOP2 NIL BOTTOM)
	(FUNCALL W2 ':EDGES))
      (SETQ BOTTOM1 (+ BOTTOM1 HEIGHT))
      (SETQ TOP2 (+ TOP2 HEIGHT))
      (AND (OR (< BOTTOM1 TOP) (> BOTTOM1 BOTTOM)
	       (< TOP2 TOP) (> TOP2 BOTTOM))
	   (BARF))
      (COND ((> HEIGHT 0)
	     (FUNCALL W2 ':SET-EDGES LEFT TOP2 RIGHT BOTTOM)
	     (FUNCALL W1 ':SET-EDGES LEFT TOP RIGHT BOTTOM1))
	    (T
	     (FUNCALL W1 ':SET-EDGES LEFT TOP RIGHT BOTTOM1)
	     (FUNCALL W2 ':SET-EDGES LEFT TOP2 RIGHT BOTTOM))))))

;;; This puts the specified number of lines in the top window
(DEFUN SPLIT-SCREEN-BETWEEN-TWO-WINDOWS (TOP-ZWEI-WINDOW BOTTOM-ZWEI-WINDOW NLINES)
  (LET ((W1 (WINDOW-SHEET TOP-ZWEI-WINDOW))
	(W2 (WINDOW-SHEET BOTTOM-ZWEI-WINDOW))
	(FRAME (WINDOW-FRAME TOP-ZWEI-WINDOW)))
    (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM MIDDLE)
	(FUNCALL FRAME ':INSIDE-EDGES-WITHOUT-MODE-LINE-WINDOW)
      (SETQ MIDDLE (+ TOP (* NLINES (TV:SHEET-LINE-HEIGHT W1))
		      (TV:SHEET-TOP-MARGIN-SIZE W1) (TV:SHEET-BOTTOM-MARGIN-SIZE W1)))
      (UNLESS (AND (TV:SHEET-EXPOSED-P W1)
	       (TV:SHEET-EXPOSED-P W2)
	       (MULTIPLE-VALUE-BIND (LF TP RT BT)
		   (FUNCALL W1 ':EDGES)
		 (AND (= LF LEFT) (= TP TOP) (= RT RIGHT) (= BT MIDDLE)))
	       (MULTIPLE-VALUE-BIND (LF TP RT BT)
		   (FUNCALL W2 ':EDGES)
		 (AND (= LF LEFT) (= TP MIDDLE) (= RT RIGHT) (= BT BOTTOM))))
	  (LET ((SELECT-1-P (TV:SHEET-SELECTED-P W1))
		(SELECT-2-P (TV:SHEET-SELECTED-P W2)))
	    (TV:DELAYING-SCREEN-MANAGEMENT
	      (FUNCALL W1 ':DEEXPOSE)
	      (FUNCALL W2 ':DEEXPOSE)
	      (FUNCALL W1 ':SET-EDGES LEFT TOP RIGHT MIDDLE)
	      (FUNCALL W2 ':SET-EDGES LEFT MIDDLE RIGHT BOTTOM)
	      (FUNCALL W1 (IF SELECT-1-P ':SELECT ':EXPOSE))
	      (FUNCALL W2 (IF SELECT-2-P ':SELECT ':EXPOSE)))
	    (FUNCALL FRAME ':UPDATE-LABELS))))))

(DEFUN MAKE-WINDOW-FULL-SCREEN (ZWEI-WINDOW &AUX FRAME LEFT TOP RIGHT BOTTOM)
  (SETQ FRAME (WINDOW-FRAME ZWEI-WINDOW))
  (MULTIPLE-VALUE (LEFT TOP RIGHT BOTTOM)
    (FUNCALL FRAME ':INSIDE-EDGES-WITHOUT-MODE-LINE-WINDOW))
  (FUNCALL (WINDOW-SHEET ZWEI-WINDOW) ':SET-EDGES LEFT TOP RIGHT BOTTOM)
  (FUNCALL FRAME ':UPDATE-LABELS))

(DEFFLAVOR MENU-COMMAND-MENU-MIXIN () ()
  (:REQUIRED-FLAVORS TV:BASIC-MENU))

(DEFMETHOD (:WHO-LINE-DOCUMENTATION-STRING MENU-COMMAND-MENU-MIXIN) ()
  (AND (VARIABLE-BOUNDP TV:CURRENT-ITEM)
       (OR (GET (CDR TV:CURRENT-ITEM) ':WHO-LINE-DOCUMENTATION)
	   (GET (CDR TV:CURRENT-ITEM) 'DOCUMENTATION))))

(DEFFLAVOR MENU-COMMAND-MOMENTARY-MENU () (MENU-COMMAND-MENU-MIXIN TV:MOMENTARY-MENU))

;;; Menu stuff
;;; Return a command that does a pop-up menu from the given command-list
;;; We actually make a menu rather than calling TV:MENU-CHOOSE to provide faster
;;; pop up and remembering of the last-selected item in that menu (per screen).

;;; This is the one resource for all of these menus; the item-list parameter
;;; is used to distinguish among them.
(TV:DEFWINDOW-RESOURCE MENU-COMMAND-MENU (ITEM-LIST)
	:MAKE-WINDOW (MENU-COMMAND-MOMENTARY-MENU :ITEM-LIST ITEM-LIST
						  :LABEL '(:STRING "Choose a command:"
							   :STYLE (:JESS :ROMAN :NORMAL))
						  :SAVE-BITS ':DELAYED)
	:INITIAL-COPIES 0
	:REUSABLE-WHEN :DEACTIVATED)

(DEFUN MAKE-MENU-COMMAND (COMMAND-LIST &OPTIONAL CHOOSE-COMMAND-FUNCTION)
  (DECLARE (SYS:DOWNWARD-FUNARG CHOOSE-COMMAND-FUNCTION))
  (LET ((ITEM-LIST (MAKE-MOUSE-COMMAND-ALIST COMMAND-LIST)))
    #'(LAMBDA ()
	(LET ((COMMAND (IF CHOOSE-COMMAND-FUNCTION
			   (FUNCALL CHOOSE-COMMAND-FUNCTION ITEM-LIST)
			 (USING-RESOURCE (MENU MENU-COMMAND-MENU ITEM-LIST)
			   (SEND MENU :CHOOSE)))))
	  (IF COMMAND (FUNCALL COMMAND)
	    (SETQ *MARK-STAYS* T)
	    DIS-NONE)))))

(DEFUN MENU-COMMAND-P (X)
  (AND (SYS:LEXICAL-CLOSURE-P X)
       (EQUAL (SYS:FUNCTION-NAME (CLOSURE-FUNCTION X)) '(:INTERNAL MAKE-MENU-COMMAND 0))))

(DEFUN GET-MENU-COMMAND-COMMANDS (X)
  (CADAR (%MAKE-POINTER DTP-LIST X)))

;;; The window-sheet definitions

;;; If a debugger frame takes more than one screenful to display itself
;;; before reading a command character, an unread character will flush
;;; that more and try right away to display the same thing.  Detect when
;;; a character we just unread has not been read since, using
;;; LAST-TYPEOUT-WINDOW-MORE-TYI-UNTYI.
(DEFFLAVOR EDITOR-TYPEOUT-WINDOW-MIXIN
	((LAST-TYPEOUT-WINDOW-MORE-TYI-UNTYI NIL))
	()
  (:REQUIRED-FLAVORS TV:BASIC-TYPEOUT-WINDOW TV:SHEET))

(DEFMETHOD (:INPUT-WAIT EDITOR-TYPEOUT-WINDOW-MIXIN :BEFORE) (&REST IGNORE)
  (SETQ LAST-TYPEOUT-WINDOW-MORE-TYI-UNTYI NIL))

(DEFFLAVOR EDITOR-TYPEOUT-WINDOW () (EDITOR-TYPEOUT-WINDOW-MIXIN DW::DYNAMIC-TYPEOUT-WINDOW))


(DEFMETHOD (:MORE-TYI EDITOR-TYPEOUT-WINDOW-MIXIN) ()
  (LOOP AS CHARACTER = (IF (OR *INSIDE-BREAK* (> DBG:*DEBUGGER-LEVEL* 0))
			   (SYS:READ-CHARACTER SELF :NOTIFICATION NIL :PRESENTATION-CONTEXT T)
			   (LET ((STANDARD-INPUT SELF))
			     (EDITOR-INPUT :ANY-TYI 'COMMAND :ABORT T :SUSPEND T))) DO
    (UNLESS (NULL (DW::INTERCEPT-SCROLL-KEY SELF CHARACTER))
      (WHEN (OR (CHARACTERP CHARACTER)
		(AND (LISTP CHARACTER)
		     (LET ((CA (CAR CHARACTER)))
		       (OR (GET CA 'SI:BLIP-HANDLER)
			   (EQ (SI:INPUT-EDITOR-OPTION :BLIP-HANDLER) CA)
			   (MEMQ CA '(:TYPEOUT-EXECUTE SI:INPUT-EDITOR
				      PRESENTATION-COMMAND))))))
	(RETURN CHARACTER)))))


(DEFWHOPPER (:SET-DEEXPOSED-TYPEIN-ACTION EDITOR-TYPEOUT-WINDOW) (VALUE)
  ;; Don't let the user screw up deexposed-typein-action
  (IF (NEQ VALUE :NORMAL)
      (BEEP)
    (CONTINUE-WHOPPER VALUE)))

(DEFWHOPPER (:SET-DEEXPOSED-TYPEOUT-ACTION EDITOR-TYPEOUT-WINDOW) (VALUE)
  ;; Ditto for deexposed-typeout-action
  (IF (NOT (EQUAL VALUE '(:EXPOSE-FOR-TYPEOUT)))
      (BEEP)
    (CONTINUE-WHOPPER VALUE)))

;; We handle characters and blips in the following way:
;; If we see a space or scroll, continue doing output.
;; If we see a character or a blip, flush the output and do an :untyi unless
;;   it's a return or a rubout, so it will be executed as a command.
;;   Then abort the process, returning to editor command loop, a break
;;   loop, or the debugger, whichever we are now in.  Use SI:PROCESS-ABORT
;;   rather than throwing, so the user will be queried if the current
;;   computation is not abortable (it's okay to do output when not abortable).
(DEFWHOPPER (:MORE-EXCEPTION EDITOR-TYPEOUT-WINDOW-MIXIN) ()
  (WHEN (NOT (ZEROP (TV:SHEET-MORE-FLAG)))
    (WHEN (AND LAST-TYPEOUT-WINDOW-MORE-TYI-UNTYI
	       (OR *INSIDE-BREAK* (> DBG:*DEBUGGER-LEVEL* 0)))
      ;; Get rid of untyi'ed from last more break, need a real character now.
      (SEND SELF :ANY-TYI-NO-HANG))
    (LET ((CH (LET-IF (AND (OR *INSIDE-BREAK* (> DBG:*DEBUGGER-LEVEL* 0)))
		      ((DW:*PRESENTATION-INPUT-CONTEXT*
			 DW::*PRESENTATION-MORE-BREAK-INPUT-CONTEXT*))
		(CONTINUE-WHOPPER))))
      (WHEN (COND ((NOT (CHARACTERP CH))
		   (SETQ *YANKED-MINI-BUFFER-COMMAND* CH)
		   T)
		  ((MEM #'CHAR-EQUAL CH '(#\SCROLL #\SPACE))
		   NIL)
		  (T
		   (UNLESS (MEM #'CHAR-EQUAL CH '(#\RUBOUT #\CR))
		     (LET ((RUBOUT-HANDLER :TYI))
		       (FUNCALL STANDARD-INPUT ':UNTYI CH)))
		   (SETQ LAST-TYPEOUT-WINDOW-MORE-TYI-UNTYI T)
		   T))
	(LET ((EPF (TV:SHEET-END-PAGE-FLAG)))
	  (SETF (TV:SHEET-END-PAGE-FLAG) 0)
	  (SEND SELF ':STRING-OUT "**FLUSHED**")
	  (SETF (TV:SHEET-END-PAGE-FLAG) EPF))
	(WHEN (VARIABLE-BOUNDP *CURRENT-COMMAND*)
	  ;; Return to innermost command level, normally ZWEI-COMMAND-LOOP, but
	  ;; possibly BREAK or Debugger command level.
	  (LET ((QUERY-IO SELF))
	    (SI:PROCESS-ABORT *CURRENT-PROCESS*)))))))

(DEFFLAVOR ZWEI-MACRO-MIXIN () ())

(DEFMETHOD (:MACRO-TERMINATE ZWEI-MACRO-MIXIN) ()
  (LET ((PT (POINT)))
    (OR (BP-= PT (INTERVAL-FIRST-BP *INTERVAL*))
	(BP-= PT (INTERVAL-LAST-BP *INTERVAL*)))))

(DEFMETHOD (:SET-MACRO-LEVEL ZWEI-MACRO-MIXIN) (LEVEL)
  (SETQ *MACRO-LEVEL* LEVEL)
  (REDISPLAY-MODE-LINE))

(DEFMETHOD (:READ-MACRO-LINE ZWEI-MACRO-MIXIN) (PROMPT
						&AUX (*CURRENT-COMMAND* 'READ-MACRO-LINE))
  (TYPEIN-LINE-READLINE PROMPT))

(DEFFLAVOR ZWEI
       (ZWEI-WINDOW			;The corresponding editor data structure
	(DELAYED-SELECT-PENDING NIL)	;T means this window wants to be exposed and
					;selected, but is waiting until typeahead
					;has been absorbed before popping up.
	(MOUSE-DOCUMENTATION-STRING (MAKE-ARRAY 100. ':TYPE 'ART-STRING
						     ':FILL-POINTER 0))
	(FONT-CACHE (SI:MAKE-CHARACTER-STYLE-FONT-CACHE)))
       ;; TV:WINDOW but with margin- and dynamic-mouse-mixins instead of borders and label
       (DW:MARGIN-MIXIN DW::DYNAMIC-MOUSE-MIXIN TV:MARGINLESS-WINDOW)
  (:INITABLE-INSTANCE-VARIABLES ZWEI-WINDOW)
  (:GETTABLE-INSTANCE-VARIABLES ZWEI-WINDOW MOUSE-DOCUMENTATION-STRING FONT-CACHE)
  (:DEFAULT-INIT-PLIST :MORE-P NIL
		       :SAVE-BITS NIL
		       :RIGHT-MARGIN-CHARACTER-FLAG 1
		       :BACKSPACE-NOT-OVERPRINTING-FLAG 1
		       :MINIMUM-WIDTH 40 :MINIMUM-HEIGHT 40) ;for creation with mouse
  (:DOCUMENTATION :MIXIN "Editor windows"))

(DEFMETHOD (:START-DELAYED-SELECT ZWEI) ()
  (SETQ DELAYED-SELECT-PENDING T))

(DEFMETHOD (:FLUSH-DELAYED-SELECT ZWEI) ()
  (SETQ DELAYED-SELECT-PENDING NIL))

(DEFMETHOD (:FINISH-DELAYED-SELECT ZWEI) ()
  (WHEN DELAYED-SELECT-PENDING
    (SELECT-WINDOW ZWEI-WINDOW)
    (WHEN TV:EXPOSED-P				;We have appeared now
      (SETQ DELAYED-SELECT-PENDING NIL))))

(DEFMETHOD (:CHANGE-LABEL ZWEI) (NEW-LABEL)
  (FUNCALL-SELF ':DELAYED-SET-LABEL NEW-LABEL))

(DEFWHOPPER (:SET-MORE-P ZWEI) (MORE-P)
  ;; Don't let the user turn on more processing, it breaks redisplay
  (IF MORE-P
      (BEEP)
    (CONTINUE-WHOPPER MORE-P)))

(DEFWHOPPER (:SET-DEEXPOSED-TYPEIN-ACTION ZWEI) (VALUE)
  ;; Ditto for deexposed-typein-action
  (IF (NEQ VALUE :NORMAL)
      (BEEP)
    (CONTINUE-WHOPPER VALUE)))

;;; This restriction isn't needed.  It appears to work to allow deexposed output
;;; on the break window, via <function> 5 T.  Provisionally removed.
;(DEFWHOPPER (:SET-DEEXPOSED-TYPEOUT-ACTION ZWEI) (VALUE)
;  ;; Ditto for deexposed-typeout-action
;  (IF (NEQ VALUE :NORMAL)
;      (BEEP)
;    (CONTINUE-WHOPPER VALUE)))

;Don't scribble over the window
(DEFMETHOD (:RESTORE-INPUT-BUFFER ZWEI) (BUFFER &OPTIONAL (REFRESH T))
   (IGNORE BUFFER REFRESH))

#||
(DEFMETHOD (:WHO-LINE-DOCUMENTATION-STRING ZWEI) ()
  (OR *GLOBAL-MOUSE-CHAR-BLINKER-DOCUMENTATION-STRING*
      MOUSE-DOCUMENTATION-STRING))
||#

(DEFFLAVOR ZWEI-WITH-TYPEOUT ()
	   (TV:WINDOW-WITH-TYPEOUT-MIXIN ZWEI)
  (:DOCUMENTATION :COMBINATION "An editor window with a typeout window too"))

(DEFFLAVOR ZWEI-WINDOW ()
       (ZWEI-WITH-TYPEOUT TV:MOUSE-EXIT-TARGET-MIXIN)
  (:DOCUMENTATION :COMBINATION "A non-ZMACS editor window"))

(DEFFLAVOR ZMACS-WINDOW
	()
	(TV:PROCESS-MIXIN ZWEI-WINDOW ZWEI-MACRO-MIXIN)
  (:DEFAULT-INIT-PLIST
   :MARGIN-COMPONENTS 'DW:((MARGIN-RAGGED-BORDERS :THICKNESS 1)
			   (MARGIN-WHITE-BORDERS )
			   (MARGIN-SCROLL-BAR :VISIBILITY :IF-REQUESTED)))
  (:DOCUMENTATION :MIXIN "A window associated with the ZMACS editor"))

(DEFMETHOD (:INIT ZWEI-WITH-TYPEOUT :AFTER) (IGNORE)
  (OR TV:TYPEOUT-WINDOW
      (SETQ TV:TYPEOUT-WINDOW
	    (TV:MAKE-WINDOW 'EDITOR-TYPEOUT-WINDOW
			    ;':ITEM-TYPE-ALIST (GET INIT-PLIST ':ITEM-TYPE-ALIST)
			    ':IO-BUFFER TV:IO-BUFFER
			    ':SUPERIOR SELF))))

(DEFMETHOD (:NAME-FOR-SELECTION ZMACS-WINDOW) ()
;  (AND (WINDOW-INTERVAL ZWEI-WINDOW)	;Can be NIL if has never been used
;       (FORMAT NIL "Edit: ~A" (FUNCALL (WINDOW-INTERVAL ZWEI-WINDOW) ':NAME)))
  NIL)

(DEFMETHOD (:SCREEN-MANAGE ZWEI-WITH-TYPEOUT) (&REST IGNORE))

(DEFMETHOD (:TURN-OFF-BLINKERS-FOR-TYPEOUT ZWEI-WITH-TYPEOUT) ()
  (TV:BLINKER-SET-VISIBILITY DW::HIGHLIGHTING-BLINKER NIL)
  (TV:MOUSE-STANDARD-BLINKER SELF))

(DEFMETHOD (:TURN-ON-BLINKERS-FOR-TYPEOUT ZWEI-WITH-TYPEOUT) ()
  (MULTIPLE-VALUE-BIND (CHAR NIL X-OFF Y-OFF)
      (DW::MOUSE-STANDARD-BLINKER-CHARACTERS)
    (TV:MOUSE-SET-BLINKER-DEFINITION-INTERNAL (TV:SHEET-MOUSE SELF)
					      :CHARACTER X-OFF Y-OFF :ON :SET-CHARACTER CHAR)))

(DEFCONST *ZWEI-MARGIN-COMPONENTS* 'DW:((MARGIN-BORDERS) (MARGIN-WHITE-BORDERS)))

;This is for the various mini-buffers, so that you cannot select it with the mouse
(DEFFLAVOR ZWEI-WITH-TYPEOUT-UNSELECTABLE ()
	   (TV:SELECT-RELATIVE-MIXIN		; [has to do with :SELECT, not the mouse]
	    TV:DONT-SELECT-WITH-MOUSE-MIXIN ZWEI-WITH-TYPEOUT)
  (:DOCUMENTATION :COMBINATION)
  (:DEFAULT-INIT-PLIST :MARGIN-COMPONENTS *ZWEI-MARGIN-COMPONENTS*))

(DEFFLAVOR ZWEI-MINI-BUFFER ()
	(TV:SELECT-RELATIVE-MIXIN TV:DONT-SELECT-WITH-MOUSE-MIXIN ZWEI)
  (:DEFAULT-INIT-PLIST :MARGIN-COMPONENTS *ZWEI-MARGIN-COMPONENTS*))

(DEFMETHOD (:TYPEOUT-WINDOW ZWEI-MINI-BUFFER) () NIL)
(DEFMETHOD (TV:ESSENTIAL-WINDOW-WITH-TYPEOUT-MIXIN-TYPEOUT-WINDOW ZWEI-MINI-BUFFER) () NIL)

;;; This is the top-level function for *ZMACS-WINDOW-PROCESS*.
(DEFUN ZMACS-WINDOW-TOP-LEVEL (FRAME)
  (LOOP DOING
    (SI:WITH-COMMAND-LOOP-VARIABLE-BINDINGS
      (LET ((COMMAND-LOOP (SEND FRAME :COMMAND-LOOP)))
	(MULTIPLE-VALUE-BIND (NIL STREAM)
	    (SEND COMMAND-LOOP :TERMINAL-STREAMS)
	  (SEND STREAM :MACRO-ERROR))		;Halt runaway keyboard macro
	(WHEN (TYPEP TV:SELECTED-WINDOW 'EDITOR-TYPEOUT-WINDOW)
	  (SEND TV:SELECTED-WINDOW :MAKE-COMPLETE))
	(SEND COMMAND-LOOP :EDIT)
	(SEND COMMAND-LOOP :EXIT)))))

(DEFMACRO COMMAND-BUFFER-PUSH (THING)
  `(TV:IO-BUFFER-PUT TV:IO-BUFFER ,THING))

;;; This kludge is for tv:exit-target-window's flashy scrolling to synchronize with this
;;; application.  Please do this right sometime!
(DEFMETHOD (:IO-BUFFER-EMPTY-P ZWEI) ()
  (TV:IO-BUFFER-EMPTY-P TV:IO-BUFFER))

(DEFMETHOD (:INIT ZMACS-WINDOW :BEFORE) (IGNORE)
  (LET ((COMMAND-LOOP (IF (OPERATION-HANDLED-P TV:SUPERIOR :COMMAND-LOOP)
			  (SEND TV:SUPERIOR :COMMAND-LOOP)
			*ZMACS-COMMAND-LOOP*)))
    (WHEN COMMAND-LOOP
      (SETQ TV:IO-BUFFER (SEND COMMAND-LOOP :IO-BUFFER)))))

;;; When a new zwei-window-class instance is made, this is called to initialize it.
(DEFMETHOD (:INIT ZWEI :AFTER) (IGNORE)
  ;; If we weren't pre-supplied with a ZWEI data structure, make one.
  ;; Tell it about us so it doesn't make a new sheet itself.
  (OR (AND (VARIABLE-BOUNDP ZWEI-WINDOW) ZWEI-WINDOW)
      (SETQ ZWEI-WINDOW (CREATE-WINDOW SELF)))
  ;; ZWEI windows use NE-Arrow, others generally use NW-Arrow
  (SETQ DW::MOUSE-BLINKER-CHARACTER #\MOUSE:NE-ARROW))

;;; This function tells the editor to redisplay
(DEFUN-IN-FLAVOR (TELL-EDITOR-TO-REDISPLAY ZWEI) (DEGREE)
  (SETF (WINDOW-REDISPLAY-DEGREE ZWEI-WINDOW)
	(MAX (WINDOW-REDISPLAY-DEGREE ZWEI-WINDOW) DEGREE))
  (COMMAND-BUFFER-PUSH '(REDISPLAY)))

;;; This makes the redisplay mechanism forget everything it knows.
(DEFMETHOD (:REFRESH ZWEI :AFTER) (&OPTIONAL TYPE)
  (AND (OR (NOT TV:RESTORED-BITS-P) (EQ TYPE ':SIZE-CHANGED))
       (TELL-EDITOR-TO-REDISPLAY DIS-ALL)))

;;; Redisplay any plines that intersect the rectangle
(DEFMETHOD (TV:REFRESH-RECTANGLE ZWEI) (LEFT TOP RIGHT BOTTOM)
  (IGNORE RIGHT)
  (LOOP WITH WINDOW = ZWEI-WINDOW
	FOR I FROM 0 BELOW (WINDOW-N-PLINES WINDOW) DO
    (WHEN (AND (< (PLINE-Y WINDOW I) BOTTOM)
	       (< TOP (+ (PLINE-Y WINDOW I) (PLINE-HEIGHT WINDOW I)))
	       (< LEFT (+ (TV:SHEET-INSIDE-LEFT) (PLINE-TEXT-WIDTH WINDOW I))))
      (SETF (PLINE-TICK WINDOW I) -1)))
  (TELL-EDITOR-TO-REDISPLAY DIS-TEXT)
  (TV:REFRESH-MARGINS-RECTANGLE SELF LEFT TOP RIGHT BOTTOM))

(DEFMETHOD (:SELECT ZWEI :AFTER) (&OPTIONAL IGNORE)
  (OR (MEMQ (TV:BLINKER-VISIBILITY (WINDOW-POINT-BLINKER ZWEI-WINDOW)) '(:BLINK :ON))
      (SETF (WINDOW-REDISPLAY-DEGREE ZWEI-WINDOW)	;Make sure the blinkers are correct
	    (MAX (WINDOW-REDISPLAY-DEGREE ZWEI-WINDOW) DIS-BPS)))
  (OR *EDITOR-ALREADY-KNOWS*
      (COMMAND-BUFFER-PUSH `(SELECT-WINDOW ,ZWEI-WINDOW))))

;;; If the window has changed completely, don't bring back any bits
(DEFWHOPPER (:EXPOSE ZWEI) (&OPTIONAL TURN-ON-BLINKERS BITS-ACTION &REST POSITION)
  (IF ( (WINDOW-REDISPLAY-DEGREE ZWEI-WINDOW) DIS-ALL)
      (LEXPR-CONTINUE-WHOPPER TURN-ON-BLINKERS
			      (IF (EQ BITS-ACTION ':NOOP) BITS-ACTION ':CLEAN)
			      POSITION)
      (LEXPR-CONTINUE-WHOPPER TURN-ON-BLINKERS BITS-ACTION POSITION)))

(DEFMETHOD (:EXPOSE ZMACS-WINDOW :BEFORE) (&REST IGNORE)
  (WHEN (NOT TV:EXPOSED-P)
    (WHEN (NULL (WINDOW-INTERVAL ZWEI-WINDOW))
      (SET-WINDOW-INTERVAL ZWEI-WINDOW (GET-BUFFER-FOR-WINDOW)))
    (LET ((COMMAND-LOOP (OR (SEND-IF-HANDLES TV:SUPERIOR :COMMAND-LOOP)
			    *ZMACS-COMMAND-LOOP*)))
      (SEND COMMAND-LOOP :ADD-WINDOW ZWEI-WINDOW))))

;;; Find a good Zmacs buffer for a newly-created window.  This happens,
;;; for example, when you do c-X 2 for the first time, or create a new
;;; window using the mouse.  Instead of creating a BUFFER-n, try to
;;; select some other useful buffer if possible.  Because this gets called
;;; from the :EXPOSE method, it attempts to be super-paranoid; in particular,
;;; it should be resilient even if editor initialization is not complete!
(DEFUN GET-BUFFER-FOR-WINDOW ()
  (OR (AND (VARIABLE-BOUNDP *ZMACS-BUFFER-HISTORY*)
	   (LISTP *ZMACS-BUFFER-HISTORY*)
	   (VARIABLE-BOUNDP *INTERVAL*)
	   *INTERVAL*
	   (TYPEP *INTERVAL* 'BUFFER)
	   (DOLIST (BUF *ZMACS-BUFFER-HISTORY*)
	     (OR (EQ BUF *INTERVAL*)
		 (RETURN BUF))))
      (MAKE-BUFFER 'NON-FILE-BUFFER ':AUTOMATIC T)))

(DEFMETHOD (:EXPOSE ZMACS-WINDOW :AFTER) (&REST IGNORE)
  (COMMAND-BUFFER-PUSH '(CONFIGURATION-CHANGED)))

(DEFMETHOD (:VERIFY-NEW-EDGES ZWEI) (NEW-LEFT NEW-TOP NEW-WIDTH NEW-HEIGHT)
  NEW-LEFT NEW-TOP NEW-WIDTH
  (AND (< (- NEW-HEIGHT TV:TOP-MARGIN-SIZE TV:BOTTOM-MARGIN-SIZE)
	  TV:LINE-HEIGHT)
       "Zero line editor windows do not work"))

(DEFUN-IN-FLAVOR (ZWEI-INSIDE-CHANGED ZWEI) ()
  ;;+++ Does this need to do anything any more?
  )

(DEFMETHOD (:CHANGE-OF-SIZE-OR-MARGINS ZWEI :AFTER) (&REST IGNORE)
  (ZWEI-INSIDE-CHANGED))

(DEFMETHOD (:SET-FONT-MAP ZWEI :AFTER) (IGNORE)
  (ZWEI-INSIDE-CHANGED))

(DEFMETHOD (:SET-VSP ZWEI :AFTER) (IGNORE)
  (ZWEI-INSIDE-CHANGED))

(DEFMETHOD (:SET-DEFAULT-STYLE ZWEI :AFTER) (IGNORE)
  (ZWEI-INSIDE-CHANGED))

;;;Get a handle on the text in the window
(DEFMETHOD (:INTERVAL-STRING ZWEI) ()
  (STRING-INTERVAL (WINDOW-INTERVAL ZWEI-WINDOW)))

(DEFMETHOD (:INTERVAL-STREAM ZWEI) ()
  (OPEN-INTERVAL-STREAM (WINDOW-INTERVAL ZWEI-WINDOW)))

(DEFMETHOD (:SET-INTERVAL-STRING ZWEI) (STRING &AUX (INTERVAL (WINDOW-INTERVAL ZWEI-WINDOW)))
  (LET ((*ENABLE-CHANGE-RECORDING* NIL))		;This is a variety of reverting
    (DELETE-INTERVAL INTERVAL)
    (INSERT (INTERVAL-LAST-BP INTERVAL) STRING)
    (TELL-EDITOR-TO-REDISPLAY DIS-ALL)))

(DEFMETHOD (:ADD-TO-INTERVAL-STRING ZWEI) (STRING
					   &AUX (INTERVAL (WINDOW-INTERVAL ZWEI-WINDOW)))
  (INSERT (INTERVAL-LAST-BP INTERVAL) STRING)
  (TELL-EDITOR-TO-REDISPLAY DIS-TEXT))

(DEFMETHOD (:ADD-STRING-AT-POINT ZWEI) (STRING)
  (INSERT-MOVING (WINDOW-POINT ZWEI-WINDOW) STRING)
  (TELL-EDITOR-TO-REDISPLAY DIS-TEXT))

;;; Obsolete Mouse screen primitives

#||
;;; Called when the mouse enters a ZWEI window.  Change the shape of the blinker,
;;; then call the standard mouse tracker, telling it we have a scroll bar.
(DEFMETHOD (:HANDLE-MOUSE ZWEI) ()
  (LET-GLOBALLY ((*MOUSE-P* T))
    (TV:MOUSE-SET-BLINKER-DEFINITION ':CHARACTER *MOUSE-X-OFFSET* *MOUSE-Y-OFFSET* ':ON
				     ':SET-CHARACTER *MOUSE-FONT-CHAR*)
    (TV:MOUSE-DEFAULT-HANDLER SELF (SEND SELF ':SCROLL-BAR-P))
    (TV:BLINKER-SET-VISIBILITY *MOUSE-BLINKER* NIL)
    (WHEN *GLOBAL-MOUSE-CHAR-BLINKER-HANDLER*
      (TV:BLINKER-SET-VISIBILITY *GLOBAL-MOUSE-CHAR-BLINKER* NIL))))

(DEFMETHOD (ZWEI :SCROLL-BAR-P) () T)

;;; This exists for the benefit of overlapping line handling.
(DEFMETHOD (:SCROLL-ONE-SCREENFUL ZWEI) (BACKWARD-P &OPTIONAL IGNORE)
  (COMMAND-BUFFER-PUSH `(SCROLL ,ZWEI-WINDOW ,(IF BACKWARD-P -1 +1) :SCREEN)))

;; Handle a movement of the mouse within an editor window.
;; Update the blinker which flashes the character being pointed at.
(DEFMETHOD (:MOUSE-MOVES ZWEI) (NEW-X NEW-Y &AUX CHAR CHAR-X CHAR-Y LINE INDEX WIDTH)
  NEW-X NEW-Y
  (TV:MOUSE-SET-BLINKER-CURSORPOS)
  (AND (OR (EDITOR-WINDOW-SELECTED-P SELF) *MOUSE-CLICK-ALWAYS-SELECTS*)
       ( NEW-X (TV:SHEET-INSIDE-LEFT)) (< NEW-X (TV:SHEET-INSIDE-RIGHT))
       (MULTIPLE-VALUE (CHAR CHAR-X CHAR-Y LINE INDEX WIDTH)
	 (MOUSE-CHAR ZWEI-WINDOW)))
  (WHEN CHAR
    ;;There is a timing problem if the editor's process can disable the global blinker
    ;;handler while we are inside it, it will turn on the blinker after the editor has
    ;;just turned it off.
    (WITHOUT-INTERRUPTS
      (WHEN *GLOBAL-MOUSE-CHAR-BLINKER-HANDLER*
	(FUNCALL *GLOBAL-MOUSE-CHAR-BLINKER-HANDLER*
		 *GLOBAL-MOUSE-CHAR-BLINKER* ZWEI-WINDOW
		 CHAR CHAR-X CHAR-Y LINE INDEX)
	(SETQ CHAR NIL))))			;Only have one blinker
  (COND (CHAR
	 (TV:BLINKER-SET-SHEET *MOUSE-BLINKER* SELF)
	 (LET ((FONT (TV:SHEET-GET-CHAR-FONT CHAR))
	       (CH (CHAR-CODE CHAR)))
	   (COND ((TYPEP *MOUSE-BLINKER* 'TV:CHARACTER-BLINKER)
		  (LET ((LKT (AND FONT (FONT-LEFT-KERN-TABLE FONT))))
		    (AND LKT ( CH (ARRAY-ACTIVE-LENGTH LKT))
			 (SETQ CHAR-X (- CHAR-X (AREF LKT CH)))))
		  (SHEET-SET-BLINKER-CURSORPOS SELF *MOUSE-BLINKER* CHAR-X CHAR-Y)
		  (TV:BLINKER-SET-CHARACTER *MOUSE-BLINKER*
					    ;; Non printing characters get blinking underscore
					    (IF (GRAPHIC-CHAR-P CHAR) CH #/_))
		  (TV:BLINKER-SET-VISIBILITY *MOUSE-BLINKER* ':BLINK))
		 ((OR (CHAR-NOT-EQUAL CHAR #\CR)
		      (AND (< NEW-X (+ (TV:SHEET-INSIDE-LEFT) CHAR-X
				       (SETQ WIDTH TV:CHAR-WIDTH)))
			   (< NEW-Y (+ (TV:SHEET-INSIDE-TOP) CHAR-Y TV:LINE-HEIGHT))))
		  (SHEET-SET-BLINKER-CURSORPOS SELF *MOUSE-BLINKER* CHAR-X CHAR-Y)
		  (TV:BLINKER-SET-SIZE
		    *MOUSE-BLINKER* WIDTH (IF FONT
					      (FONT-BLINKER-HEIGHT FONT)
					      (- (FONT-BLINKER-HEIGHT TV:CURRENT-FONT) (TV:SHEET-GET-TOP-OF-FONT FONT))))
		  (TV:BLINKER-SET-VISIBILITY *MOUSE-BLINKER* T))
		 (T
		  (TV:BLINKER-SET-VISIBILITY *MOUSE-BLINKER* NIL)))))
	(T
	 (TV:BLINKER-SET-SHEET *MOUSE-BLINKER* SELF)
	 (TV:BLINKER-SET-VISIBILITY *MOUSE-BLINKER* NIL))))

(DEFUN SHEET-SET-BLINKER-CURSORPOS (SHEET BLINKER X Y)
  (MULTIPLE-VALUE-BIND (XOFF YOFF)
      (TV:SHEET-CALCULATE-OFFSETS SHEET (TV:BLINKER-SHEET BLINKER))
    (TV:BLINKER-SET-CURSORPOS BLINKER (+ X XOFF) (+ Y YOFF))))


(DEFMETHOD (:MOUSE-CLICK ZWEI) (BUTTON X Y &AUX HANDLED-P)
  (COND ((AND (NOT (EDITOR-WINDOW-SELECTED-P SELF))
	      (OR (CHAR-MOUSE-EQUAL BUTTON #\MOUSE-1-1)
		  *MOUSE-CLICK-ALWAYS-SELECTS*))
	 (PROCESS-RUN-FUNCTION "Select" SELF ':SELECT)
	 (SETQ HANDLED-P T)))
  (COND ((OR *MOUSE-CLICK-ALWAYS-SELECTS*
	     (NOT HANDLED-P))
	 (COMMAND-BUFFER-PUSH `(:MOUSE ,ZWEI-WINDOW ,BUTTON ,X ,Y))))
  T)

(DEFUN EDITOR-WINDOW-SELECTED-P (SHEET)
  (LET* ((SW TV:SELECTED-WINDOW)
	 (ACTIVITY (SEND SHEET :ALIAS-FOR-SELECTED-WINDOWS))
	 (PANE (SEND ACTIVITY :SELECTED-PANE)))
    (AND SW
	 D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; the selected window's "activity" must be the "activity" that owns SHEET.
0	 (EQ ACTIVITY (SEND SW :ALIAS-FOR-SELECTED-WINDOWS))
	 (OR
	   1;; If the selected pane is EQ to sheet, then the sheet sure is selected.
0	   1;; If the selected pane is an inferior of the sheet, that counts too.
0	   1;; The only known case of this is the typeout window.  The redisplay
0	   1;; will reselect the sheet whose typeout window covers it when it gets
0	   1;; the blip (or anything else), so it is "selected" from the point of view
0	   1;; of our callers, :mouse-click and :mouse-moves.
0	   (TV:SHEET-ME-OR-MY-KID-P PANE SHEET)
	   1;; The other possibility is that the mode line window is under the mouse.
0	   1;; when you are in the minibuffer you are stuck there, wherever you mouse.
0	   1;; So this claims that all of the editor windows are "selected" if the
0           1;; mode line window is the selected pane.  When redisplay gets a mouse-l-1
0	   1;; for some other window while the mode line window is up, it complains
0	   1;; or throws it away but does not deselect it.   However, note the following:
0	   ;;--- I don't know exactly why this clause is here, but it duplicates what
	   ;;--- the old code did (with fewer bugs).  There are several effects on the
	   ;;--- mouse caused by this; I expect the desired one is to prevent using
	   ;;--- click-left to select away from the minibuffer.  --Moon 11/1/85
	   
	   (TV:SHEET-ME-OR-MY-KID-P		;Something down in echo area is selected
	     PANE (SEND ACTIVITY :MODE-LINE-WINDOW))))))

(DEFWRAPPER (:MOUSE-CLICK ZMACS-WINDOW) ((BUTTON X Y) . BODY)
  `(PROG1 (PROGN . ,BODY)
	  (IGNORE X Y)
	  (AND (NOT (SI:CHAR-MOUSE-EQUAL BUTTON #\MOUSE-3-2))
	       (SYMEVAL-IN-STACK-GROUP '*INSIDE-BREAK* (PROCESS-STACK-GROUP TV:PROCESS))
	       (FUNCALL TV:PROCESS ':RESET))))

||#



;;; Dynamic window interface

(DEFMETHOD (:DISPLAYED-PRESENTATION-AT-POSITION ZWEI) (X Y &OPTIONAL FORCE-P)
  (WHEN (OR FORCE-P
	    (= (WINDOW-REDISPLAY-DEGREE ZWEI-WINDOW) DIS-NONE))	;Don't touch when in transit
    (MULTIPLE-VALUE-BIND (CHAR CH-X CH-Y LINE CHAR-POS CHAR-WIDTH DIAGRAM)
	(MOUSE-CHAR ZWEI-WINDOW NIL X Y)
      (IF DIAGRAM
	  (SEND DIAGRAM :DISPLAYED-PRESENTATION-AT-POSITION LINE X Y CH-X CH-Y SELF)
	  (WHEN (AND CHAR ( CH-X X (+ CH-X (OR CHAR-WIDTH TV:CHAR-WIDTH))))
	    (LET ((RAW-PRESENTATION-NODE (BP-RAW-PRESENTATION-NODE
					   (CREATE-BP LINE CHAR-POS))))
	      (WHEN RAW-PRESENTATION-NODE
		(CLEAR-PRESENTATION-SUPERIOR RAW-PRESENTATION-NODE)
		RAW-PRESENTATION-NODE)))))))

(DEFMETHOD (:MARKED-TEXT ZWEI) (&KEY RETURN-AS-STRING UNMARK DELETE)
  (WHEN (WINDOW-REGION-P ZWEI-WINDOW)
    (LET ((VALUE (IF RETURN-AS-STRING
		     (STRING-INTERVAL (WINDOW-POINT ZWEI-WINDOW) (WINDOW-MARK ZWEI-WINDOW))
		     T)))
      (LET-IF (NOT (VARIABLE-BOUNDP *WINDOW-LIST*))
	      ((*WINDOW-LIST* `(,ZWEI-WINDOW)))
	(COND (DELETE
	       (LET ((*INTERVAL* (WINDOW-INTERVAL ZWEI-WINDOW)))
		 (DELETE-INTERVAL (WINDOW-POINT ZWEI-WINDOW) (WINDOW-MARK ZWEI-WINDOW)))
	       (TELL-EDITOR-TO-REDISPLAY DIS-TEXT))
	      (UNMARK
	       (SETF (WINDOW-MARK-P ZWEI-WINDOW) NIL)
	       (TELL-EDITOR-TO-REDISPLAY DIS-MARK-GOES))))
      VALUE)))

;;; Scrolling

;;; When creating a Zwei window, we'll invoke this method before the interval is setup.
(DEFMETHOD (:Y-SCROLL-POSITION ZWEI) ()
  (DECLARE (VALUES TOP-LINE-NUMBER LINES-VISIBLE FIRST-LINE TOTAL-LINES))
  (IF (NULL (WINDOW-INTERVAL ZWEI-WINDOW))
      (VALUES 0 (WINDOW-N-PLINES ZWEI-WINDOW) 0 (WINDOW-N-PLINES ZWEI-WINDOW))
      ;; DW::*ASKING-WINDOW-FOR-SCROLL-POSITION* is a flag used by the scroll bar code
      ;; to decide when it is safe to reset a process that is computing :Y-SCROLL-POSITION.
      ;; Future modifiers of this function should remember to keep the code inside this
      ;; binding free of uninterruptible operations.
      ;;See dw::(flavor:method mouse-margin-component-mouse-leaves margin-scroll-bar)
      (LET* ((DW::*ASKING-WINDOW-FOR-SCROLL-POSITION* T)
	     (INTERVAL (WINDOW-INTERVAL ZWEI-WINDOW))
	     (TOP-BP (WINDOW-START-BP ZWEI-WINDOW))
	     (TOP-LINE-NUMBER (1- (COUNT-LINES (INTERVAL-FIRST-BP INTERVAL)
					       TOP-BP T INTERVAL)))
	     (TOTAL-LINES (+ TOP-LINE-NUMBER (COUNT-LINES TOP-BP (INTERVAL-LAST-BP INTERVAL) T
							  INTERVAL)))
	     (LINES-VISIBLE (WINDOW-N-PLINES ZWEI-WINDOW)))
	(WHEN (AND (WINDOW-LAST-BP-DISPLAYED-P ZWEI-WINDOW)
		   (PLUSP LINES-VISIBLE))
	  ;; This message really wants to know how many lines could be displayed.
	  ;; Of course, that depends on how high they are.  And we cannot know the
	  ;; pixel height of the whole buffer.  So, scale up the current line count
	  ;; by the ratio of the whole window to the used portion.
	  (SETQ LINES-VISIBLE (FLOOR (* (SEND SELF :INSIDE-HEIGHT) LINES-VISIBLE)
				     (+ (PLINE-Y ZWEI-WINDOW (1- LINES-VISIBLE))
					(PLINE-HEIGHT ZWEI-WINDOW (1- LINES-VISIBLE))
					TV:VSP))))
	(VALUES TOP-LINE-NUMBER LINES-VISIBLE 0 TOTAL-LINES))))

(DEFMETHOD (:Y-SCROLL-TO ZWEI) (POS TYPE)
  (FLET ((CMD (POS TYPE)
	   (COMMAND-BUFFER-PUSH `(SCROLL ,ZWEI-WINDOW ,POS ,TYPE))))
    (IF (MEMQ TYPE '(:RELATIVE-JUMP :RELATIVE))
	(UNLESS (ZEROP POS)
	  (CMD POS :RELATIVE))
	(CMD POS TYPE))))

;;; When creating a Zwei window, we'll invoke this method before the interval is setup.
(DEFMETHOD (:SCROLL-MORE-ABOVE ZWEI) ()
  (AND (WINDOW-INTERVAL ZWEI-WINDOW)
       (NOT (BP-= (WINDOW-START-BP ZWEI-WINDOW)
		  (INTERVAL-FIRST-BP (WINDOW-INTERVAL ZWEI-WINDOW))))))

;;; Valid only if redisplay up to date
(DEFMETHOD (:SCROLL-MORE-BELOW ZWEI) ()
  (AND (WINDOW-INTERVAL ZWEI-WINDOW)		;Can't be more if there's no interval yet.
       (NOT (WINDOW-LAST-BP-DISPLAYED-P ZWEI-WINDOW))))

(DEFMETHOD (:RAGGED-BORDERS-P ZWEI) ()
  (VALUES ()
	  (NOT (NULL (SEND SELF :SCROLL-MORE-ABOVE)))
	  ()
	  (NOT (NULL (SEND SELF :SCROLL-MORE-BELOW)))))

;; Here so LINE-DISPLAYED-SIZE and DISPLAY-LINE can share it
(DEFMACRO DEFAULT-TAB-FUNCTION-INTERNAL ()
  `#'(LAMBDA (SHEET IGNORE IGNORE X &OPTIONAL Y)
       (DECLARE (SYS:DOWNWARD-FUNCTION))
       (DECLARE (IGNORE Y))
       (UNLESS TAB-WIDTH
	 (SETQ TAB-WIDTH (TV:SHEET-TAB-WIDTH SHEET)))
       (+ X (- TAB-WIDTH (\ (- X LINE-MARGIN-LEFT) TAB-WIDTH)))))

;;; Generic function, sort of.
(DEFUN LINE-DISPLAYED-SIZE (SHEET LINE &OPTIONAL (START-INDEX 0) END-INDEX (START-X 0)
			    RIGHT-LIMIT)
  (DECLARE (VALUES FINAL-X HEIGHT BASELINE END-INDEX))
  (UNLESS END-INDEX
    (SETQ END-INDEX (LINE-LENGTH LINE)))
  (MULTIPLE-VALUE-BIND (DIAGRAM LINE-MARGIN TAB-FUNCTION CHARACTER-STYLE-FUNCTION)
      (LINE-SPECIAL-REDISPLAY-PROPERTIES LINE)
    (WITH-CHARACTER-STYLE-FROM-FUNCTION (CHARACTER-STYLE-FUNCTION LINE SHEET)
      (WHEN DIAGRAM
	(LET ((HEIGHT (SEND DIAGRAM :EDITOR-HEIGHT SHEET LINE)))
	  (DECF HEIGHT (SEND SHEET :VSP))
	  (RETURN-FROM LINE-DISPLAYED-SIZE
	    (VALUES (TV:SHEET-INSIDE-RIGHT SHEET) HEIGHT HEIGHT END-INDEX))))
      (LET ((LINE-MARGIN-LEFT 0))
	(WHEN LINE-MARGIN
	  (MULTIPLE-VALUE-BIND (LEFT NIL RIGHT)
	      (LINE-MARGIN-SIZE LINE-MARGIN SHEET LINE)
	    (WHEN (ZEROP START-X)
	      (SETQ START-X LEFT))
	    (SETQ RIGHT-LIMIT (- (OR RIGHT-LIMIT (- (TV:SHEET-INSIDE-WIDTH SHEET) 4))
				 RIGHT))
	    (SETQ LINE-MARGIN-LEFT LEFT)))
	(LET ((TAB-WIDTH NIL))
	  (WHEN (NULL TAB-FUNCTION)
	    (SETQ TAB-FUNCTION (DEFAULT-TAB-FUNCTION-INTERNAL)))
	  (SEND SHEET :LINE-DISPLAYED-SIZE-INTERNAL LINE START-INDEX END-INDEX START-X
		(SEND SHEET :FONT-CACHE) RIGHT-LIMIT TAB-FUNCTION))))))

;;; Like EDITOR-LINE-OUT 
;;; VSP is an argument to allow for different per-line VSP's in the future.
(DEFUN DISPLAY-LINE (SHEET LINE START-INDEX END-INDEX X Y WIDTH HEIGHT BASELINE VSP)
  (LET ((RIGHT-LIMIT NIL)
	(TAB-WIDTH NIL))
    (MULTIPLE-VALUE-BIND (DIAGRAM LINE-MARGIN TAB-FUNCTION CHARACTER-STYLE-FUNCTION)
	(LINE-SPECIAL-REDISPLAY-PROPERTIES LINE)
      (WITH-CHARACTER-STYLE-FROM-FUNCTION (CHARACTER-STYLE-FUNCTION LINE SHEET)
	(LET ((LINE-MARGIN-LEFT 0))
	  (WHEN LINE-MARGIN
	    (MULTIPLE-VALUE-BIND (LEFT NIL RIGHT)
		(LINE-MARGIN-SIZE LINE-MARGIN SHEET LINE)
	      (SETQ RIGHT-LIMIT (- (TV:SHEET-INSIDE-WIDTH SHEET) RIGHT))
	      (WHEN (ZEROP X)
		(SEND SHEET :DRAW-RECTANGLE LEFT (+ HEIGHT VSP) X Y :ERASE)
		(SEND SHEET :DRAW-RECTANGLE RIGHT (+ HEIGHT VSP) RIGHT-LIMIT Y :ERASE)
		(LINE-MARGIN-DRAW LINE-MARGIN SHEET LINE X Y WIDTH HEIGHT BASELINE VSP)
		(SETQ X LEFT))
	      (SETQ LINE-MARGIN-LEFT LEFT)))
	  (WHEN DIAGRAM
	    (SEND SHEET :DRAW-RECTANGLE WIDTH (+ HEIGHT VSP) X Y :ERASE)
	    (SEND DIAGRAM :EDITOR-DRAW LINE SHEET X Y)
	    (RETURN-FROM DISPLAY-LINE DIAGRAM))
	  (WHEN (NULL TAB-FUNCTION)
	    (SETQ TAB-FUNCTION (DEFAULT-TAB-FUNCTION-INTERNAL)))
	  (SEND SHEET :DISPLAY-LINE-INTERNAL LINE START-INDEX END-INDEX X Y WIDTH HEIGHT
		BASELINE VSP (SEND SHEET :FONT-CACHE) RIGHT-LIMIT TAB-FUNCTION))))))


;;; The mini buffer and stuff like that

;;;These windows pop up like a temporary window if typed on while deexposed
(DEFFLAVOR DEEXPOSED-TEMPORARY-WINDOW ((DEEXPOSED-TEMPORARY-BIT-ARRAY T)) ()
  (:REQUIRED-FLAVORS TV:ESSENTIAL-WINDOW))

(DEFMETHOD (:CHANGE-OF-SIZE-OR-MARGINS DEEXPOSED-TEMPORARY-WINDOW :AFTER) (&REST IGNORE)
  (WHEN (ARRAYP DEEXPOSED-TEMPORARY-BIT-ARRAY)
    (SETQ DEEXPOSED-TEMPORARY-BIT-ARRAY
	  (MULTIPLE-VALUE-BIND (OWIDTH OHEIGHT)
	      (DECODE-RASTER-ARRAY DEEXPOSED-TEMPORARY-BIT-ARRAY)
	    (TV:GROW-BIT-ARRAY DEEXPOSED-TEMPORARY-BIT-ARRAY TV:WIDTH TV:HEIGHT TV:WIDTH
			       OWIDTH OHEIGHT
			       NIL)))))

(DEFMETHOD (:TEMPORARY-EXPOSE DEEXPOSED-TEMPORARY-WINDOW) (&REST IGNORE)
  (UNLESS TV:EXPOSED-P
    (IF (TV:SHEET-EXPOSED-P TV:SUPERIOR)
	(SETQ TV:TEMPORARY-BIT-ARRAY DEEXPOSED-TEMPORARY-BIT-ARRAY)
	(SEND TV:SUPERIOR :TEMPORARY-EXPOSE))
    (SEND SELF :EXPOSE)))

(DEFMETHOD (:TEMPORARY-DEEXPOSE DEEXPOSED-TEMPORARY-WINDOW) ()
  (SEND SELF :DEEXPOSE)
  (SETQ DEEXPOSED-TEMPORARY-BIT-ARRAY TV:TEMPORARY-BIT-ARRAY
	TV:TEMPORARY-BIT-ARRAY NIL))

;; Communication between MODE-LINE-SUPERIOR-MIXIN and FIXED-HEIGHT-WINDOW-MIXIN
(DEFVAR-RESETTABLE *PERMIT-SHEET-SIZE-CHANGES* NIL)

(DEFFLAVOR FIXED-HEIGHT-WINDOW-MIXIN () ()
  (:REQUIRED-FLAVORS TV:ESSENTIAL-SET-EDGES TV:ESSENTIAL-WINDOW)
  (:DOCUMENTATION :MIXIN "Does not allow changing the height of the window after init"))

(DEFMETHOD (:VERIFY-NEW-EDGES FIXED-HEIGHT-WINDOW-MIXIN)
	   (NEW-LEFT NEW-TOP NEW-WIDTH NEW-HEIGHT)
  (IGNORE NEW-LEFT NEW-TOP NEW-WIDTH)
  (COND ((= NEW-HEIGHT TV:HEIGHT) NIL)
	(*PERMIT-SHEET-SIZE-CHANGES* NIL)	;:SET-LINE-HEIGHT-FROM-STYLES
	(T "Attempt to change height")))

(DEFMETHOD (:CHANGE-OF-SIZE-OR-MARGINS FIXED-HEIGHT-WINDOW-MIXIN :AFTER) (&REST IGNORE)
  (DOLIST (INFERIOR TV:INFERIORS)
    (FUNCALL INFERIOR ':SET-SIZE (TV:SHEET-INSIDE-WIDTH) (TV:SHEET-HEIGHT INFERIOR))))

(DEFFLAVOR DONT-SCREEN-MANAGE-MIXIN () ()
  (:REQUIRED-FLAVORS TV:ESSENTIAL-WINDOW)
  (:DOCUMENTATION :MIXIN "Don't do screen management on itself"))

(DEFMETHOD (:SCREEN-MANAGE DONT-SCREEN-MANAGE-MIXIN) (&REST IGNORE) NIL)

(DEFFLAVOR ECHO-AREA-WINDOW () (TV:DONT-SELECT-WITH-MOUSE-MIXIN
				DEEXPOSED-TEMPORARY-WINDOW DONT-SCREEN-MANAGE-MIXIN
				TV:STREAM-MIXIN TV:SELECT-MIXIN
				FIXED-HEIGHT-WINDOW-MIXIN TV:MINIMUM-WINDOW)
  (:DEFAULT-INIT-PLIST :MORE-P NIL))

;; This is used to make a *TYPEIN-WINDOW*; it will acquire a blinker if anyone tries to read
;; input from it.  This window can be the value of QUERY-IO.

(DEFFLAVOR ECHO-AREA-QUERY-WINDOW () (ECHO-AREA-WINDOW))

(DEFMACRO ECHO-AREA-QUERY-WINDOW-BLINKER-OFF ()
  `(AND (EQ (TV:BLINKER-VISIBILITY (CAR TV:BLINKER-LIST)) ':OFF)
	;; Next line is because selection doesn't work right yet.
	(TV:SHEET-ME-OR-MY-KID-P (TV:SHEET-SELECTED-WINDOW SELF)
				 (TV:SHEET-SUPERIOR TV:SUPERIOR))))

;; Don't select the window if input is already available.

(DEFWHOPPER (:INPUT-WAIT ECHO-AREA-QUERY-WINDOW) (&REST ARGS)
  (IF (AND (ECHO-AREA-QUERY-WINDOW-BLINKER-OFF)
	   (NOT (SEND SELF :LISTEN)))
      (LET ((*EDITOR-ALREADY-KNOWS* T))
	(TV:WINDOW-CALL-RELATIVE (SELF :DESELECT NIL)
	  (LEXPR-CONTINUE-WHOPPER ARGS)))
      (LEXPR-CONTINUE-WHOPPER ARGS)))

;; Sending :LISTEN here is unsafe, since it will err if the blinker is turned off and we are
;; inside the input editor.  This should be fixed either by having the input editor
;; encapsulate the raw stream, or by having different messages for raw input and edited input.
;; For now, just check for being inside the input editor and skip it -- if editor is selected
;; away and then back, can get into bad state even though :INPUT-EDITOR whopper already
;; checked.

(DEFWHOPPER (:ANY-TYI ECHO-AREA-QUERY-WINDOW) (&REST ARGS)
  (IF (AND (ECHO-AREA-QUERY-WINDOW-BLINKER-OFF)
	   (NEQ RUBOUT-HANDLER ':READ)
	   (NOT (SEND SELF :LISTEN)))
      (TV:WINDOW-CALL-RELATIVE (SELF :DESELECT NIL)
	(LEXPR-CONTINUE-WHOPPER ARGS))
      (LEXPR-CONTINUE-WHOPPER ARGS)))

;; Select the window here, also, rather than selecting and deselecting each time :ANY-TYI is
;; sent.  We can't check for :LISTEN here, since there might be typeahead, and then :ANY-TYI
;; would try sending :LISTEN while inside the input editor.

(DEFWHOPPER (:INPUT-EDITOR ECHO-AREA-QUERY-WINDOW) (&REST ARGS)
  (IF (ECHO-AREA-QUERY-WINDOW-BLINKER-OFF)
      (TV:WINDOW-CALL-RELATIVE (SELF :DESELECT NIL)
	(LEXPR-CONTINUE-WHOPPER ARGS))
      (LEXPR-CONTINUE-WHOPPER ARGS)))

;;; This is the flavor used to make a *TYPEIN-WINDOW*.
(DEFFLAVOR TYPEIN-WINDOW
	((TYPEIN-STATUS ':CLEAR))		;:CLEAR, :IN-USE, :USED
	(TV:SELECT-RELATIVE-MIXIN ECHO-AREA-QUERY-WINDOW)
  (:SETTABLE-INSTANCE-VARIABLES TYPEIN-STATUS)
  (:WRITABLE-INSTANCE-VARIABLES TYPEIN-STATUS))

(DEFMETHOD (:REFRESH TYPEIN-WINDOW :AFTER) (&REST IGNORE)
  (COND ((NOT TV:RESTORED-BITS-P)
	 (FUNCALL-SELF ':HOME-CURSOR)
	 (SETQ TYPEIN-STATUS ':CLEAR))))

(DEFMETHOD (:CLEAR-WINDOW TYPEIN-WINDOW :AFTER) (&OPTIONAL IGNORE)
  (SETQ TYPEIN-STATUS ':CLEAR))

(DEFMETHOD (:COMMAND-LOOP-REDISPLAY TYPEIN-WINDOW) ()
  (SELECTQ TYPEIN-STATUS
    (:IN-USE
     (SETQ TYPEIN-STATUS ':USED))
    (:IN-USE-STAYS
     (SETQ TYPEIN-STATUS ':USED-STAYS))
    (:USED
     (IF TV:EXPOSED-P
	 (FUNCALL-SELF ':CLEAR-WINDOW)
	 (SETQ TYPEIN-STATUS ':CLEAR))
     (SEND TV:SUPERIOR :DONE-WITH-MODE-LINE-WINDOW))))
  
(DEFMETHOD (:PREPARE-FOR-TYPEOUT TYPEIN-WINDOW) ()
  (LET* ((MINI-BUFFER-SHEET (WINDOW-SHEET (SEND TV:SUPERIOR ':MINI-BUFFER-WINDOW)))
	 (SEARCH-MINI-BUFFER-SHEET (WINDOW-SHEET
				     (SEND TV:SUPERIOR ':SEARCH-MINI-BUFFER-WINDOW)))
	 (MINI-BUFFER-IN-USE (TV:SHEET-EXPOSED-P MINI-BUFFER-SHEET))
	 (SEARCH-MINI-BUFFER-IN-USE (TV:SHEET-EXPOSED-P SEARCH-MINI-BUFFER-SHEET)))
    (SEND SELF ':EXPOSE)
    (WHEN MINI-BUFFER-IN-USE
      (SEND MINI-BUFFER-SHEET ':START-DELAYED-SELECT))
    (WHEN SEARCH-MINI-BUFFER-IN-USE
      (SEND SEARCH-MINI-BUFFER-SHEET ':START-DELAYED-SELECT)))
  (IF (MEMQ TYPEIN-STATUS '(:IN-USE :IN-USE-STAYS))
      NIL					;Do a :FRESH-LINE
      (UNLESS (EQ TYPEIN-STATUS ':CLEAR)
	(SEND SELF ':CLEAR-WINDOW))
      (SETQ TYPEIN-STATUS ':IN-USE)
      T))

(DEFMETHOD (:PREPARE-FOR-MORE-TYPEOUT TYPEIN-WINDOW) ()
  (OR (MEMQ TYPEIN-STATUS '(:IN-USE :IN-USE-STAYS))
      (SETQ TYPEIN-STATUS ':IN-USE)))

(DEFMETHOD (:TYPEOUT-STAYS TYPEIN-WINDOW) ()
  (AND (EQ TYPEIN-STATUS ':IN-USE) (SETQ TYPEIN-STATUS ':IN-USE-STAYS)))

(DEFMACRO MAKE-INCOMPLETE (&REST IGNORE)
  `(AND (MEMQ TYPEIN-STATUS '(:CLEAR :USED)) (SETQ TYPEIN-STATUS ':IN-USE)))

(DEFMETHOD (:TYO TYPEIN-WINDOW :BEFORE) (&REST IGNORE)
  (MAKE-INCOMPLETE))

(DEFMETHOD (:STRING-OUT TYPEIN-WINDOW :BEFORE) (&REST IGNORE)
  (MAKE-INCOMPLETE))

(DEFMETHOD (:LINE-OUT TYPEIN-WINDOW :BEFORE) (&REST IGNORE)
  (MAKE-INCOMPLETE))

(DEFMETHOD (:FRESH-LINE TYPEIN-WINDOW :BEFORE) (&REST IGNORE)
  (MAKE-INCOMPLETE))

;;; This improves interaction with FQUERY
(DEFMETHOD (:MAKE-COMPLETE TYPEIN-WINDOW) ()
  (AND (EQ TYPEIN-STATUS ':IN-USE) (SETQ TYPEIN-STATUS ':USED)))

(DEFMETHOD (:MOUSE-MOTION-PENDING TYPEIN-WINDOW) () NIL)

(DEFMETHOD (:PRESENTATION-INPUT-BLIP-HANDLER TYPEIN-WINDOW) (BLIP)
  (SELECTQ (FIRST BLIP)
    (:MOUSE-CLICK
     (DW::DYNAMIC-WINDOW-PRESENTATION-INPUT-BLIP-HANDLER BLIP))))

;;; This knows how to display the editor's mode line properly
(DEFFLAVOR MODE-LINE-WINDOW-MIXIN ((PREVIOUS-MODE-LINE NIL)) ()
  (:REQUIRED-FLAVORS TV:ESSENTIAL-WINDOW)
  (:REQUIRED-INSTANCE-VARIABLES TV:IO-BUFFER)
  (:DEFAULT-INIT-PLIST :TRUNCATE-LINE-OUT-FLAG 1
		       :CR-NOT-NEWLINE-FLAG 1))

(DEFMETHOD (:REFRESH MODE-LINE-WINDOW-MIXIN :AFTER) (&REST IGNORE)
  (OR TV:RESTORED-BITS-P (SETQ PREVIOUS-MODE-LINE NIL)))

(DEFMETHOD (TV:REFRESH-RECTANGLE MODE-LINE-WINDOW-MIXIN) (LEFT TOP RIGHT BOTTOM)
  ;; Force redisplay of mode line
  (SETQ PREVIOUS-MODE-LINE NIL)
  (COMMAND-BUFFER-PUSH '(REDISPLAY))
  (TV:REFRESH-MARGINS-RECTANGLE SELF LEFT TOP RIGHT BOTTOM))

(DEFMETHOD (:CLOBBER MODE-LINE-WINDOW-MIXIN) ()
  (SETQ PREVIOUS-MODE-LINE NIL))

;;; Update the mode line if necessary, FORCE says really do it
;;; MODE-LINE-LIST is a list of things to be displayed, whose elements can be:
;;;  a constant string
;;;  a symbol, which is evaluated to either a string or NIL, and printed in the former case
;;;  a list, the CAR of which should be an atom, which is evaluated and the rest of the
;;;    list handled as strings or symbols as above if it is non-NIL (up to any :ELSE), or
;;;    if NIL, anything after a :ELSE in the list.
;;;  eg ("FOOMACS" "(" MODE-NAME ")" (BUFFER-NAMED-P BUFFER-NAME :ELSE "(Null buffer)")
;;;      (FILE-NAME-P FILE-NAME))
;;;  a list starting with the symbol :RIGHT-FLUSH is special:
;;;    the cadr of the list is a string to be displayed flush against the right margin.
;;; As a special hack, if MODE-LINE-LIST is NIL, then the mode line is not changed,
;;;  this is appropriate for things that want to typeout on the prompt-line and then
;;;  invoke the mini-buffer.
;;; PREVIOUS-MODE-LINE is a list of strings that make up the line, since nothing we do
;;;  generates new guys for this, EQness is used to determine if the mode-line has changed
(DEFMETHOD (:REDISPLAY MODE-LINE-WINDOW-MIXIN) (MODE-LINE-LIST &OPTIONAL FORCE)
  (AND FORCE					;If we are going to type things out
       MODE-LINE-LIST				;unless suppressed
       (SETQ PREVIOUS-MODE-LINE NIL))
  (DO ((MODES MODE-LINE-LIST)
       (PREV PREVIOUS-MODE-LINE)
       (L)
       (THING))
      (NIL)
      (COND (L					;Still more to go on a list
	     (POP L THING)
	     (AND (EQ THING ':ELSE)
		  (SETQ L NIL THING NIL)))
	    ((NULL MODES)			;All done with MODE-LINE-LIST
	     (AND PREV (NOT FORCE) (FUNCALL-SELF ':REDISPLAY MODE-LINE-LIST T))
	     (RETURN NIL))
	    (T					;Get next object from MODE-LINE-LIST
	     (POP MODES THING)
	     (COND ((SYMBOLP THING)
		    (SETQ THING (SYMEVAL THING))
		    (AND (LISTP THING)		;If value is a list, dont check CAR
			 (SETQ L THING THING NIL)))
		   ((AND (LISTP THING)		;It's a list,
			 (NEQ (CAR THING) ':RIGHT-FLUSH))
		    (SETQ L THING)
		    (POP L THING)
		    (COND ((NULL (SYMEVAL THING))
			   (DO ()		;Failing conditional, look for :ELSE
			       ((NULL L))
			     (POP L THING)
			     (AND (EQ THING ':ELSE)
				  (RETURN NIL)))))
		    (SETQ THING NIL))		;And get stuff next pass
		   ((INSTANCEP THING)
		    (SETQ THING (SEND THING ':MODE-LINE-NAME))))))
      (COND ((SYMBOLP THING)
	     ;; Check for unbound symbols; if this bombs out and you abort,
	     ;; redisplay just makes it happen again, which is a pain; and this
	     ;; problem can arise easily if a user makes a mistake in an init file.
	     (SETQ THING (IF (BOUNDP THING) (SYMEVAL THING) "<<Error>>")))
	    ((INSTANCEP THING)
	     (SETQ THING (SEND THING ':MODE-LINE-NAME)))
	    ((AND (LISTP THING)
		  (EQ (CAR THING) :RIGHT-FLUSH)
		  (SYMBOLP (CADR THING)))
	     (LET ((STR (IF (BOUNDP (CADR THING)) (SYMEVAL (CADR THING)) "<<Error>>")))
	       (SETQ THING (AND STR (LIST (CAR THING) STR))))))
      (COND ((NULL THING))
	    ;;THING is now the next string to be put into the mode line
	    (FORCE				;Put it in if consing new one
	     (PUSH THING PREVIOUS-MODE-LINE))
	    ((AND PREV (EQ THING (POP PREV))))	;Still matching?
	    (T					;Different thing,
	     (FUNCALL-SELF ':REDISPLAY MODE-LINE-LIST T)	;do it right this time!
	     (RETURN NIL))))
  (COND (FORCE
	 (SETQ PREVIOUS-MODE-LINE (NREVERSE PREVIOUS-MODE-LINE))
	 (COND (TV:EXPOSED-P
		(FUNCALL-SELF ':HOME-CURSOR)
		(FUNCALL-SELF ':CLEAR-REST-OF-LINE)
		(CATCH 'MODE-LINE-OVERFLOW
		  (DOLIST (STR PREVIOUS-MODE-LINE)
		    (COND ((TYPEP STR '16B-STRING)
			   ;; Kludge for extended search strings
			   (FUNCALL '16B-STRING-NAMED-STRUCTURE-INVOKE
				    :PRINT-SELF STR SELF))
			  ((STRINGP STR)
			   (SEND SELF ':STRING-OUT STR)))))
		(DOLIST (ELT PREVIOUS-MODE-LINE)
		  (AND (LISTP ELT)
		       (LET* ((STR (CADR ELT))
			      (LEN (FUNCALL-SELF ':STRING-LENGTH STR)))
			 (FUNCALL-SELF ':SET-CURSORPOS
				       (- (TV:SHEET-INSIDE-WIDTH) LEN)
				       0)
			 (FUNCALL-SELF ':CLEAR-REST-OF-LINE)
			 (CATCH 'MODE-LINE-OVERFLOW
			   (FUNCALL-SELF ':STRING-OUT STR))
			 (RETURN NIL)))))))))

(DEFMETHOD (:END-OF-LINE-EXCEPTION MODE-LINE-WINDOW-MIXIN :BEFORE) ()
  (OR (ZEROP (TV:SHEET-TRUNCATE-LINE-OUT-FLAG))
      (THROW 'MODE-LINE-OVERFLOW T)))

(DEFMETHOD (:DONE-WITH-MODE-LINE-WINDOW MODE-LINE-WINDOW-MIXIN) ())

(DEFFLAVOR ZMACS-MODE-LINE-WINDOW-MIXIN () (MODE-LINE-WINDOW-MIXIN))

(DEFVAR *READ-ONLY-MODE-LINE-STRING* " (RO)")
(DEFVAR *MODIFIED-MODE-LINE-STRING* " *")
(DEFVAR *BUFFER-MODIFIED-P*)

(DEFWRAPPER (:REDISPLAY ZMACS-MODE-LINE-WINDOW-MIXIN) (IGNORE . BODY)
  `(LET ((*BUFFER-MODIFIED-P* NIL)
	 (*ZMACS-BUFFER-NAME* NIL)
	 (*ZMACS-BUFFER-VERSION-STRING* NIL))
     ,@BODY))

(DEFMETHOD (:REDISPLAY ZMACS-MODE-LINE-WINDOW-MIXIN :BEFORE) (&REST IGNORE)
  (SETQ *ZMACS-BUFFER-NAME* (SEND-IF-HANDLES *INTERVAL* :NAME)
	*ZMACS-BUFFER-VERSION-STRING* (SEND-IF-HANDLES *INTERVAL* :VERSION-STRING))
  (MULTIPLE-VALUE-BIND (MODIFIED-P SPECIAL-STATUS)
	(SEND-IF-HANDLES *INTERVAL* :MODIFIED-P :FOR-WHO-LINE)
    (SETQ *BUFFER-MODIFIED-P* (COND ((EQ SPECIAL-STATUS ':READ-ONLY)
				     *READ-ONLY-MODE-LINE-STRING*)
				    (MODIFIED-P
				     *MODIFIED-MODE-LINE-STRING*)
				    (T NIL)))))

(DEFFLAVOR MODE-LINE-SUPERIOR-MIXIN
	(TYPEIN-WINDOW MINI-BUFFER-WINDOW SEARCH-MINI-BUFFER-WINDOW)
		;;yes, these are really instance variables, not component flavors
	(TV:SELECT-RELATIVE-MIXIN)
  (:REQUIRED-FLAVORS TV:STREAM-MIXIN TV:MINIMUM-WINDOW)
  (:INIT-KEYWORDS :NUMBER-OF-MINI-BUFFER-LINES)
  (:GETTABLE-INSTANCE-VARIABLES TYPEIN-WINDOW)
  (:DEFAULT-INIT-PLIST :BLINKER-DESELECTED-VISIBILITY ':OFF
		       :DEEXPOSED-TYPEOUT-ACTION '(:TEMPORARY-EXPOSE)))

(DEFFLAVOR MODE-LINE-WINDOW ()
	   (MODE-LINE-SUPERIOR-MIXIN TV:BORDERS-MIXIN
	    MODE-LINE-WINDOW-MIXIN ECHO-AREA-WINDOW)
  (:DEFAULT-INIT-PLIST :BORDER-MARGIN-WIDTH 0))

(DEFFLAVOR ZMACS-MODE-LINE-WINDOW ()
	   (MODE-LINE-SUPERIOR-MIXIN TV:BORDERS-MIXIN
	    ZMACS-MODE-LINE-WINDOW-MIXIN ECHO-AREA-WINDOW))

(DEFMETHOD (:MINI-BUFFER-WINDOW MODE-LINE-SUPERIOR-MIXIN) ()
  (FUNCALL MINI-BUFFER-WINDOW ':ZWEI-WINDOW))

(DEFMETHOD (:SEARCH-MINI-BUFFER-WINDOW MODE-LINE-SUPERIOR-MIXIN) ()
  (FUNCALL SEARCH-MINI-BUFFER-WINDOW ':ZWEI-WINDOW))

(DEFMETHOD (:INIT MODE-LINE-SUPERIOR-MIXIN :BEFORE) (INIT-PLIST)
  (LET ((N-LINES (GET INIT-PLIST :NUMBER-OF-MINI-BUFFER-LINES)))
    (WHEN N-LINES
      (SETQ TV:HEIGHT (+ 12.
			 (* (1+ N-LINES) TV:(SHEET-LINE-HEIGHT (SHEET-GET-SCREEN SUPERIOR)))))
      )))

(DEFMETHOD (:INIT MODE-LINE-SUPERIOR-MIXIN :AFTER) (IGNORE)
  (SETQ TYPEIN-WINDOW (TV:MAKE-WINDOW (SEND SELF :TYPEIN-WINDOW-FLAVOR)
				      ':TOP TV:(+ (SHEET-INSIDE-TOP) LINE-HEIGHT)
				      ':IO-BUFFER TV:IO-BUFFER ':SUPERIOR SELF
				      ':MORE-P NIL ':ACTIVATE-P T
				      ':BLINKER-DESELECTED-VISIBILITY ':OFF)
	MINI-BUFFER-WINDOW (TV:MAKE-WINDOW 'ZWEI-MINI-BUFFER
					   ':TOP TV:(+ (SHEET-INSIDE-TOP) LINE-HEIGHT)
					   ':IO-BUFFER TV:IO-BUFFER ':SUPERIOR SELF
					   ':LABEL NIL ':SAVE-BITS NIL ':ACTIVATE-P T)
	SEARCH-MINI-BUFFER-WINDOW (TV:MAKE-WINDOW 'ZWEI-MINI-BUFFER
						  ':TOP TV:(+ (SHEET-INSIDE-TOP) LINE-HEIGHT)
						  ':IO-BUFFER TV:IO-BUFFER ':SUPERIOR SELF
						  ':LABEL NIL ':SAVE-BITS NIL ':ACTIVATE-P T))
  (SET-WINDOW-INTERVAL (FUNCALL MINI-BUFFER-WINDOW ':ZWEI-WINDOW) (CREATE-INTERVAL))
  (SET-WINDOW-INTERVAL (FUNCALL SEARCH-MINI-BUFFER-WINDOW ':ZWEI-WINDOW)
		       (CREATE-INTERVAL-WITH-LINE (CREATE-LINE 'ART-FAT-STRING 50. NIL))))

(DEFMETHOD (:TYPEIN-WINDOW-FLAVOR MODE-LINE-SUPERIOR-MIXIN) () 'TYPEIN-WINDOW)

(DEFMETHOD (:EXPOSE MODE-LINE-SUPERIOR-MIXIN :AFTER) (&REST IGNORE)
  (WHEN (NULL TV:EXPOSED-INFERIORS)
    ;; make sure the typein window is exposed, too, to allow FORMAT output to it
    (SEND TYPEIN-WINDOW ':EXPOSE)))

(DEFMETHOD (:SET-IO-BUFFER MODE-LINE-SUPERIOR-MIXIN) (NEW-IO-BUFFER)
  (SETQ TV:IO-BUFFER NEW-IO-BUFFER)
  (SEND TYPEIN-WINDOW :SET-IO-BUFFER TV:IO-BUFFER)
  (SEND MINI-BUFFER-WINDOW :SET-IO-BUFFER TV:IO-BUFFER)
  (SEND SEARCH-MINI-BUFFER-WINDOW :SET-IO-BUFFER TV:IO-BUFFER))

(DEFMETHOD (:CHANGE-OF-SIZE-OR-MARGINS MODE-LINE-SUPERIOR-MIXIN :AFTER) (&REST IGNORE)
  (LET ((LEFT (TV:SHEET-INSIDE-LEFT))
	(TOP (+ (TV:SHEET-INSIDE-TOP) TV:LINE-HEIGHT))
	(RIGHT (TV:SHEET-INSIDE-RIGHT))
	(BOTTOM (TV:SHEET-INSIDE-BOTTOM)))
    (FUNCALL TYPEIN-WINDOW ':SET-EDGES LEFT TOP RIGHT BOTTOM)
    (FUNCALL MINI-BUFFER-WINDOW ':SET-EDGES LEFT TOP RIGHT BOTTOM)
    (FUNCALL SEARCH-MINI-BUFFER-WINDOW ':SET-EDGES LEFT TOP RIGHT BOTTOM)))

(DEFWHOPPER (:SET-LINE-HEIGHT-FROM-STYLES MODE-LINE-SUPERIOR-MIXIN) (&REST STYLES)
  (IF (VARIABLE-BOUNDP TYPEIN-WINDOW)
      ;; This is reinitialization
      (LET ((N-LINES (1- (FLOOR (- TV:HEIGHT 12.) TV:LINE-HEIGHT))))
	(LEXPR-CONTINUE-WHOPPER STYLES)
	(LET ((*PERMIT-SHEET-SIZE-CHANGES* T))
	  (SEND SELF :DEEXPOSE)		;If making taller, may go outside superior temporarily
	  (SEND SELF :SET-SIZE TV:WIDTH (+ 12. (* (1+ N-LINES) TV:LINE-HEIGHT)))))
      ;; This is initialization
      (LEXPR-CONTINUE-WHOPPER STYLES)))

(DEFVAR *GLOBAL-MODE-LINE-WINDOW*)

(DEFMETHOD (:MODE-LINE-WINDOW ZWEI) ()
  *GLOBAL-MODE-LINE-WINDOW*)

(DEFUN WINDOW-MODE-LINE-WINDOWS (ZWEI-WINDOW &AUX MODE-LINE-WINDOW)
  (DECLARE (VALUES MODE-LINE-WINDOW TYPEIN-WINDOW MINI-BUFFER-WINDOW))
  (SETQ MODE-LINE-WINDOW (FUNCALL (WINDOW-SHEET ZWEI-WINDOW) ':MODE-LINE-WINDOW))
  (VALUES MODE-LINE-WINDOW
	  (FUNCALL MODE-LINE-WINDOW ':TYPEIN-WINDOW)
	  (FUNCALL MODE-LINE-WINDOW ':MINI-BUFFER-WINDOW)))

(DEFUN INITIALIZE-MINI-BUFFER-WINDOW (&OPTIONAL (NLINES 3) (SUPERIOR TV:DEFAULT-SCREEN)
						(MODE-LINE-FLAVOR 'ZMACS-MODE-LINE-WINDOW)
						IO-BUFFER
				      &REST OPTIONS)
  (SETQ *GLOBAL-MODE-LINE-WINDOW*
	(LEXPR-FUNCALL #'TV:MAKE-WINDOW MODE-LINE-FLAVOR 
		       ':NUMBER-OF-MINI-BUFFER-LINES NLINES
		       ':SUPERIOR SUPERIOR ':IO-BUFFER IO-BUFFER
		       OPTIONS)))

(DEFMETHOD (:EDIT TOP-LEVEL-EDITOR :BEFORE) (&REST IGNORE)
  (FUNCALL *MODE-LINE-WINDOW* ':SET-IO-BUFFER TV:IO-BUFFER)
  (TURN-ON-USER-MODES))

(DEFVAR SYN-TYPEIN-WINDOW-IO (MAKE-SYN-STREAM '*TYPEIN-WINDOW*))

;;; This ensures that streams are bound to the right thing inside the :EDIT method
;;; Some of these may be instance variables, in which case an extra binding is
;;; generated, but that is ok.
;;; Should return TERMINAL-IO, STANDARD-INPUT, STANDARD-OUTPUT, and QUERY-IO
(DEFMETHOD (:TERMINAL-STREAMS TOP-LEVEL-EDITOR :DEFAULT) ()
  (VALUES *TYPEOUT-WINDOW* SI:SYN-TERMINAL-IO SI:SYN-TERMINAL-IO SYN-TYPEIN-WINDOW-IO))

(DEFWRAPPER (:EDIT TOP-LEVEL-EDITOR) (IGNORE . BODY)
  `(MULTIPLE-VALUE-BIND (TERMINAL-IO STANDARD-INPUT STANDARD-OUTPUT QUERY-IO)
       (SEND SELF :TERMINAL-STREAMS)
     (DECLARE (SPECIAL STANDARD-INPUT))		;Might be declared instance-variable
     (CONDITION-BIND ((FS:LOGIN-REQUIRED 'SELECT-QUERY-IO-WHEN-GETTING-USER-ID))
       . ,BODY)))

;; A bit of a kludge
(DEFUN SELECT-QUERY-IO-WHEN-GETTING-USER-ID (CONDITION)
  (AND (SEND CONDITION :PROCEED-TYPE-P ':PASSWORD)
       ;; If we aren't going to prompt for the user and we already know the password or
       ;; don't need a password, then we don't need to select anything after all.
       (NOT (AND (NOT (SEND CONDITION :NEED-NEW-USER))
		 (OR (NOT (SEND CONDITION :NEED-PASSWORD))
		     (SEND (SEND CONDITION :ACCESS-PATH) :NO-PASSWORDS))))
       (TV:WINDOW-CALL-RELATIVE (QUERY-IO)
	 (SEND CONDITION :PROCEED ':PASSWORD))))

;;; DEFFLAVOR for OWN-STANDARD-INPUT-EDITOR-MIXIN moved to DEFS.

(DEFMETHOD (:TERMINAL-STREAMS OWN-STANDARD-INPUT-EDITOR-MIXIN) ()
  (VALUES *TYPEOUT-WINDOW* STANDARD-INPUT SI:SYN-TERMINAL-IO SYN-TYPEIN-WINDOW-IO))

(DEFMETHOD (:EDIT-WITH-STANDARD-INPUT-AND-COMTAB OWN-STANDARD-INPUT-EDITOR-MIXIN)
	   (NEW-STANDARD-INPUT &OPTIONAL (NEW-COMTAB *COMTAB*))
  (LET*-INSTANCE-VARIABLES ((STANDARD-INPUT NEW-STANDARD-INPUT)
			    (*COMTAB* NEW-COMTAB))
    (SEND SELF ':EDIT)))

(DEFFLAVOR ZWEI-WITH-POP-UP-MINI-BUFFER-MIXIN () ()
  (:REQUIRED-FLAVORS ZWEI))

(DEFMETHOD (:FINISH-DELAYED-SELECT ZWEI-WITH-POP-UP-MINI-BUFFER-MIXIN :BEFORE)
	   (&AUX (SHEET (WINDOW-SHEET *WINDOW*)))
  (AND (LISTP (TV:SHEET-LOCK SHEET)) (MEMQ *MODE-LINE-WINDOW* (TV:SHEET-LOCK SHEET))
       (TV:WINDOW-CALL-RELATIVE (*MODE-LINE-WINDOW* :TEMPORARY-DEEXPOSE)
	 (PROMPT-LINE "Type any char to flush: ")
	 (LET ((CH (FUNCALL *MODE-LINE-WINDOW* ':ANY-TYI)))
	   (COND ((NOT (CHAR-EQUAL CH #\SP))
		  (FUNCALL STANDARD-INPUT ':UNTYI CH)))))))

(DEFFLAVOR EDITOR-WITH-POP-UP-MINI-BUFFER-MIXIN (*GLOBAL-MODE-LINE-WINDOW*) ()
  (:REQUIRED-FLAVORS TOP-LEVEL-EDITOR)
  (:INIT-KEYWORDS :MODE-LINE-WINDOW)
  :SPECIAL-INSTANCE-VARIABLES
  (:SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS :EDIT))

(DEFMETHOD (:INIT EDITOR-WITH-POP-UP-MINI-BUFFER-MIXIN :AFTER) (PLIST)
  (OR (SETQ *GLOBAL-MODE-LINE-WINDOW* (GET PLIST ':MODE-LINE-WINDOW))
      (LET ((SHEET (IF (VARIABLE-BOUNDP *WINDOW*) (WINDOW-SHEET *WINDOW*) SELF)))
	(FLAVOR::WITH-SPECIALS-BOUND-TO-INSTANCE-VARIABLES (*GLOBAL-MODE-LINE-WINDOW*)
	  (INITIALIZE-MINI-BUFFER-WINDOW
	    3
	    (TV:SHEET-SUPERIOR SHEET)
	    'POP-UP-MODE-LINE-WINDOW
	    TV:IO-BUFFER
	    :ACTIVITY SELF))
	(SETQ *MODE-LINE-WINDOW* *GLOBAL-MODE-LINE-WINDOW*
	      *TYPEIN-WINDOW* (FUNCALL *GLOBAL-MODE-LINE-WINDOW* ':TYPEIN-WINDOW)
	      *MINI-BUFFER-WINDOW* (FUNCALL *GLOBAL-MODE-LINE-WINDOW* ':MINI-BUFFER-WINDOW))
	(SETF (TV:SHEET-DEEXPOSED-TYPEOUT-ACTION *TYPEIN-WINDOW*) '(:TEMPORARY-EXPOSE))
	(SETF (TV:SHEET-DEEXPOSED-TYPEOUT-ACTION *MODE-LINE-WINDOW*) '(:TEMPORARY-EXPOSE)))))

(DEFFLAVOR EDITOR-WINDOW-WITH-POP-UP-MINI-BUFFER-MIXIN ((MODE-LINE-WINDOW-SELECTED NIL))
	   (TOP-LEVEL-EDITOR
	    EDITOR-WITH-POP-UP-MINI-BUFFER-MIXIN
	    ZWEI-WITH-POP-UP-MINI-BUFFER-MIXIN)
  ;; EDITOR-WITH-POP-UP-MINI-BUFFER-MIXIN must be less specific than TOP-LEVEL-EDITOR
  ;; so that ewpumbm's :AFTER :INIT method will run first and create the
  ;; *GLOBAL-MODE-LINE-WINDOW* before tle's :AFTER :INIT method references it.
  ;; BASIC-EDITOR-WINDOW is listed to avoid completely rearranging the components
  ;; as an unwanted side-effect of putting TOP-LEVEL-EDITOR before the mixins.
  (:COMPONENT-ORDER (TOP-LEVEL-EDITOR EDITOR-WITH-POP-UP-MINI-BUFFER-MIXIN
		     BASIC-EDITOR-WINDOW))
  (:SETTABLE-INSTANCE-VARIABLES MODE-LINE-WINDOW-SELECTED))

;; Kludge to compensate for the fact that the current excuse for an activity system
;; likes all the windows in an activity to be arranged in a hierarchy.
(DEFMETHOD (:SELECT EDITOR-WINDOW-WITH-POP-UP-MINI-BUFFER-MIXIN :AFTER) (&OPTIONAL IGNORE)
  (WHEN MODE-LINE-WINDOW-SELECTED
    (SEND MODE-LINE-WINDOW-SELECTED :SELECT NIL)))

;; More of the same kludge
(DEFMETHOD (:SELECT-RELATIVE EDITOR-WINDOW-WITH-POP-UP-MINI-BUFFER-MIXIN :BEFORE) ()
  (SETQ MODE-LINE-WINDOW-SELECTED NIL))

;;; Put the minibuffer just below the editor window if there is room in the superior,
;;; otherwise put it at the bottom of the editor window, overlying it.
(DEFUN-IN-FLAVOR (EDITOR-WINDOW-WITH-POP-UP-MINI-BUFFER-MIXIN-POSITION-MODE-LINE-WINDOW
		  EDITOR-WINDOW-WITH-POP-UP-MINI-BUFFER-MIXIN)
		 ()
  (LET* ((BOTTOM (+ TV:Y-OFFSET TV:HEIGHT))
	 (HEIGHT (TV:SHEET-HEIGHT *GLOBAL-MODE-LINE-WINDOW*))
	 (SUPERIOR (TV:SHEET-SUPERIOR *GLOBAL-MODE-LINE-WINDOW*))
	 (DESIRED-TOP (IF ( (+ BOTTOM HEIGHT) (TV:SHEET-INSIDE-BOTTOM SUPERIOR))
			  BOTTOM
			  (- BOTTOM HEIGHT)))
	 (TOP (MAX DESIRED-TOP (TV:SHEET-INSIDE-TOP SUPERIOR))))
    (SEND *GLOBAL-MODE-LINE-WINDOW* :SET-EDGES
	  TV:X-OFFSET TOP (+ TV:X-OFFSET TV:WIDTH) (+ TOP HEIGHT))))

(DEFMETHOD (:INIT EDITOR-WINDOW-WITH-POP-UP-MINI-BUFFER-MIXIN :AFTER) (IGNORE)
  (EDITOR-WINDOW-WITH-POP-UP-MINI-BUFFER-MIXIN-POSITION-MODE-LINE-WINDOW))

(DEFMETHOD (:SET-EDGES EDITOR-WINDOW-WITH-POP-UP-MINI-BUFFER-MIXIN :AFTER) (&REST IGNORE)
  (EDITOR-WINDOW-WITH-POP-UP-MINI-BUFFER-MIXIN-POSITION-MODE-LINE-WINDOW))

(DEFFLAVOR POP-UP-MODE-LINE-WINDOW (ACTIVITY) (MODE-LINE-WINDOW)
  (:INITABLE-INSTANCE-VARIABLES ACTIVITY))

(DEFMETHOD (:DONE-WITH-MODE-LINE-WINDOW POP-UP-MODE-LINE-WINDOW) ()
  (SEND ACTIVITY :SET-MODE-LINE-WINDOW-SELECTED NIL)
  (SEND SELF :TEMPORARY-DEEXPOSE)
  (SEND SELF :DEACTIVATE))

(DEFMETHOD (:ALIAS-FOR-SELECTED-WINDOWS POP-UP-MODE-LINE-WINDOW) ()
  (SEND ACTIVITY :ALIAS-FOR-SELECTED-WINDOWS))

(DEFMETHOD (:INFERIOR-SELECT POP-UP-MODE-LINE-WINDOW) (PANE)
  (SEND ACTIVITY :SET-MODE-LINE-WINDOW-SELECTED PANE))

(DEFFLAVOR BASIC-EDITOR-WINDOW () (ZWEI-WINDOW))

(DEFMETHOD (:INIT BASIC-EDITOR-WINDOW :AFTER) (IGNORE)
  (SETQ *WINDOW* ZWEI-WINDOW
	*INTERVAL* (CREATE-INTERVAL NIL NIL 'TOP-LEVEL-NODE))
  (SET-WINDOW-INTERVAL *WINDOW* *INTERVAL*)  
  (PUSH *WINDOW* *WINDOW-LIST*))

(DEFFLAVOR EDITOR-WINDOW () (TOP-LEVEL-EDITOR BASIC-EDITOR-WINDOW ZWEI-WINDOW))

(DEFMETHOD (:EDIT-STRING EDITOR-WINDOW) (STRING)
  (EDSTRING STRING SELF))

;;; Shouldn't this be using a resource?
(DEFUN EDSTRING (STRING &OPTIONAL WINDOW-OR-LIST-OR-LEFT TOP RIGHT BOTTOM COMTAB
			&AUX FLA SUP OPTS)
  (COND ((NOT (TYPEP WINDOW-OR-LIST-OR-LEFT 'TV:SHEET))
	 (SETQ FLA (COND ((SYMBOLP WINDOW-OR-LIST-OR-LEFT) WINDOW-OR-LIST-OR-LEFT)
			 ((LISTP WINDOW-OR-LIST-OR-LEFT)
			  (SETQ SUP (GET WINDOW-OR-LIST-OR-LEFT ':SUPERIOR)
				OPTS (CDR WINDOW-OR-LIST-OR-LEFT))
			  (CAR WINDOW-OR-LIST-OR-LEFT))))
	 (OR FLA (SETQ FLA 'STANDALONE-EDITOR-WINDOW))
	 (OR SUP (SETQ SUP TV:DEFAULT-SCREEN))
	 (MULTIPLE-VALUE-BIND (SL ST SR SB) (SEND SUP :INSIDE-EDGES)
	   (OR (NUMBERP WINDOW-OR-LIST-OR-LEFT) (SETQ WINDOW-OR-LIST-OR-LEFT SL))
	   (OR TOP (SETQ TOP ST))
	   (OR RIGHT (SETQ RIGHT SR))
	   (OR BOTTOM (SETQ BOTTOM (MIN (+ TOP (* 4 (TV:SHEET-LINE-HEIGHT SUP))) SB))))
	 (OR COMTAB (SETQ COMTAB *STANDALONE-COMTAB*))
	 (SETQ WINDOW-OR-LIST-OR-LEFT (LEXPR-FUNCALL #'TV:MAKE-WINDOW FLA
						     ':SUPERIOR SUP
						     ':LEFT WINDOW-OR-LIST-OR-LEFT ':TOP TOP
						     ':RIGHT RIGHT ':BOTTOM BOTTOM ':LABEL NIL
						     ':*COMTAB* COMTAB
						     OPTS))))
  (FUNCALL WINDOW-OR-LIST-OR-LEFT ':SET-INTERVAL-STRING STRING)
  (TV:WINDOW-CALL (WINDOW-OR-LIST-OR-LEFT :DEACTIVATE)
    (FUNCALL WINDOW-OR-LIST-OR-LEFT ':EDIT))
  (VALUES (FUNCALL WINDOW-OR-LIST-OR-LEFT ':INTERVAL-STRING) WINDOW-OR-LIST-OR-LEFT))

;;; This flavor is useful for the COMPLETING-READ function
(DEFFLAVOR ZWEI-WINDOW-WITH-TOP-OUTSIDE-LABEL () (TV:TOP-LABEL-MIXIN ZWEI-WINDOW)
  (:DOCUMENTATION :COMBINATION))

;;; This is useful for standalone small editing tasks
(DEFFLAVOR STANDALONE-EDITOR-WINDOW
	((*COMTAB* *STANDALONE-COMTAB*))
	(EDITOR-WINDOW-WITH-POP-UP-MINI-BUFFER-MIXIN EDITOR-WINDOW)
  (:SPECIAL-INSTANCE-VARIABLES *COMTAB*)
  (:SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS :EDIT))

(DEFFLAVOR STANDALONE-EDITOR-PANE () (TV:PANE-MIXIN STANDALONE-EDITOR-WINDOW))

(DEFFLAVOR TEMPORARY-MODE-LINE-WINDOW
	((BACKGROUND-TYPEOUT-WINDOW NIL)
	 BACKGROUND-TYPEOUT-STREAM)
	(MODE-LINE-SUPERIOR-MIXIN MODE-LINE-WINDOW-MIXIN
	 TV:DONT-SELECT-WITH-MOUSE-MIXIN
	 TV:TEMPORARY-WINDOW-MIXIN DONT-SCREEN-MANAGE-MIXIN
	 TV:STREAM-MIXIN TV:SELECT-MIXIN
	 FIXED-HEIGHT-WINDOW-MIXIN TV:MINIMUM-WINDOW)
  (:SETTABLE-INSTANCE-VARIABLES BACKGROUND-TYPEOUT-WINDOW)
  (:GETTABLE-INSTANCE-VARIABLES BACKGROUND-TYPEOUT-STREAM))

(DEFMETHOD (:INIT TEMPORARY-MODE-LINE-WINDOW :AFTER) (IGNORE)
  (SETQ BACKGROUND-TYPEOUT-STREAM (LET-CLOSED ((*GLOBAL-MODE-LINE-WINDOW* SELF))
				    'BACKGROUND-TYPEOUT-STREAM)))

(CL:DEFPARAMETER *MINIMUM-WIDTH-FOR-TEMPORARY-MINI-BUFFER* 500.)

1;;; Perhaps this should go someplace else???
0(DEFMETHOD (:MOVE-NEAR-WINDOW TEMPORARY-MODE-LINE-WINDOW) (WINDOW &OPTIONAL (EXPOSE-P T))
  (SEND SELF :SET-SUPERIOR (TV:SHEET-SUPERIOR WINDOW))
  (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM)
      (SEND WINDOW :EDGES)
    1;; If it won't fit below try putting it above.
0    (WHEN (> (+ BOTTOM TV:HEIGHT) TV:(SHEET-INSIDE-BOTTOM SUPERIOR))
      (SETQ BOTTOM (MAX (- TOP TV:HEIGHT) TV:(SHEET-INSIDE-TOP SUPERIOR))))
    1;; Enforce a reasonable minimum width.
0    (WHEN (< (- RIGHT LEFT) *MINIMUM-WIDTH-FOR-TEMPORARY-MINI-BUFFER*)
      (LET* ((MIDDLE (+ LEFT (// (- RIGHT LEFT) 2)))
	     (NEW-LEFT (- MIDDLE (// *MINIMUM-WIDTH-FOR-TEMPORARY-MINI-BUFFER* 2)))
	     (NEW-RIGHT (+ MIDDLE (// *MINIMUM-WIDTH-FOR-TEMPORARY-MINI-BUFFER* 2))))
	(SETQ LEFT (MAX NEW-LEFT TV:(SHEET-INSIDE-LEFT SUPERIOR))
	      RIGHT (MIN NEW-RIGHT TV:(SHEET-INSIDE-RIGHT SUPERIOR)))))
    1;; Put it there.
0    (SEND SELF :SET-EDGES LEFT BOTTOM RIGHT (+ BOTTOM TV:HEIGHT))
    (WHEN EXPOSE-P
      (SEND SELF :EXPOSE))))

(DEFMETHOD (:REDISPLAY TEMPORARY-MODE-LINE-WINDOW :AFTER) (IGNORE &OPTIONAL FORCE)
  (AND FORCE (NOT TV:EXPOSED-P)
       (LET ((LEN (LOOP FOR STR IN PREVIOUS-MODE-LINE
			WHEN (LISTP STR) DO (SETQ STR (SECOND STR))
			SUM (FUNCALL-SELF ':STRING-LENGTH STR))))
	 (AND (> LEN (TV:SHEET-INSIDE-WIDTH))
	      (FUNCALL-SELF ':SET-SIZE
			    (MIN (+ TV:LEFT-MARGIN-SIZE LEN TV:RIGHT-MARGIN-SIZE)
				 (TV:SHEET-INSIDE-WIDTH TV:SUPERIOR))
			    TV:HEIGHT))
	 (AND (> (+ TV:X-OFFSET TV:WIDTH) (TV:SHEET-INSIDE-RIGHT TV:SUPERIOR))
	      (FUNCALL-SELF ':SET-POSITION (- (TV:SHEET-INSIDE-RIGHT TV:SUPERIOR) TV:WIDTH)
			    TV:Y-OFFSET)))))

(DEFMETHOD (:MOUSE-MOTION-PENDING TEMPORARY-MODE-LINE-WINDOW) ()
  (SEND MINI-BUFFER-WINDOW :MOUSE-MOTION-PENDING))

(DEFMETHOD (:PRESENTATION-INPUT-BLIP-HANDLER TEMPORARY-MODE-LINE-WINDOW) (&REST ARGS)  
  (LEXPR-SEND MINI-BUFFER-WINDOW :PRESENTATION-INPUT-BLIP-HANDLER ARGS))

(DEFMETHOD (:DEACTIVATE TEMPORARY-MODE-LINE-WINDOW :AFTER) ()
  (COND (BACKGROUND-TYPEOUT-WINDOW
	 (FUNCALL BACKGROUND-TYPEOUT-WINDOW ':DEACTIVATE)
	 (SETQ BACKGROUND-TYPEOUT-WINDOW BACKGROUND-TYPEOUT-STREAM))))

(DEFFLAVOR TEMPORARY-MODE-LINE-WINDOW-WITH-BORDERS ()
	   (TV:BORDERS-MIXIN TEMPORARY-MODE-LINE-WINDOW))

(DEFFLAVOR EDITOR-FOR-TEMPORARY-MINI-BUFFER
	(*GLOBAL-MODE-LINE-WINDOW*
	 ;; Things that EDIT-IN-MINI-BUFFER expects to have been set by :EDIT method
	 (*NUMERIC-ARG* NIL) (*NUMERIC-ARG-P* 1) (*LAST-COMMAND-CHAR* NIL))
	(TOP-LEVEL-EDITOR)
  :SPECIAL-INSTANCE-VARIABLES
  (:SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS :EDIT :CALL-MINI-BUFFER-NEAR-WINDOW)
  (:INITABLE-INSTANCE-VARIABLES *GLOBAL-MODE-LINE-WINDOW*))

(DEFRESOURCE EDITOR-FOR-TEMPORARY-MINI-BUFFER-RESOURCE
	     (&OPTIONAL (SCREEN (TV:CONSOLE-DEFAULT-SUPERIOR)))
  :CONSTRUCTOR (MAKE-EDITOR-FOR-TEMPORARY-MINI-BUFFER)
  :MATCHER (EDITOR-FOR-TEMPORARY-MINI-BUFFER-IS-FOR-THIS-SCREEN-P OBJECT SCREEN)
  :INITIAL-COPIES 0)	;Due to bootstrapping

(DEFUN MAKE-EDITOR-FOR-TEMPORARY-MINI-BUFFER (&OPTIONAL
					      (SUPERIOR(2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB") 0(TV:CONSOLE-DEFAULT-SUPERIOR))
							IO-BUFFER
					      &AUX *GLOBAL-MODE-LINE-WINDOW*)
  (INITIALIZE-MINI-BUFFER-WINDOW 1 SUPERIOR
				 'TEMPORARY-MODE-LINE-WINDOW-WITH-BORDERS
				 IO-BUFFER)
  (MAKE-COMMAND-LOOP *STANDARD-COMTAB*
		     (FUNCALL *GLOBAL-MODE-LINE-WINDOW* ':MINI-BUFFER-WINDOW)
		     'EDITOR-FOR-TEMPORARY-MINI-BUFFER
		     ':*GLOBAL-MODE-LINE-WINDOW* *GLOBAL-MODE-LINE-WINDOW*))

(DEFUN EDITOR-FOR-TEMPORARY-MINI-BUFFER-IS-FOR-THIS-SCREEN-P (EDITOR SCREEN)
  (EQ (SCL:SYMBOL-VALUE-IN-INSTANCE EDITOR '*GLOBAL-MODE-LINE-WINDOW*)
      SCREEN))

(DEFMETHOD (:INIT EDITOR-FOR-TEMPORARY-MINI-BUFFER :AFTER) (IGNORE)
  (FUNCALL *GLOBAL-MODE-LINE-WINDOW* ':SET-IO-BUFFER TV:IO-BUFFER)
  (PUSH (FUNCALL *GLOBAL-MODE-LINE-WINDOW* ':MINI-BUFFER-WINDOW) *WINDOW-LIST*)
  (SETF (TV:SHEET-DEEXPOSED-TYPEOUT-ACTION *GLOBAL-MODE-LINE-WINDOW*) ':EXPOSE))

(DEFMETHOD (:TERMINAL-STREAMS EDITOR-FOR-TEMPORARY-MINI-BUFFER) ()
  (VALUES (FUNCALL *GLOBAL-MODE-LINE-WINDOW* ':BACKGROUND-TYPEOUT-STREAM)
	  *GLOBAL-MODE-LINE-WINDOW*
	  SI:SYN-TERMINAL-IO SYN-TYPEIN-WINDOW-IO))

(DEFMETHOD (:CALL-MINI-BUFFER-NEAR-WINDOW EDITOR-FOR-TEMPORARY-MINI-BUFFER) (WINDOW FUNCTION
									     &REST ARGS)
  (LET ((*CURRENT-COMMAND-LOOP* SELF))
    (LET*-INSTANCE-VARIABLES ((*TYPEOUT-WINDOW* SI:SYN-TERMINAL-IO))
      (IF (NEQ WINDOW :MOUSE)
	  (SEND *GLOBAL-MODE-LINE-WINDOW* :MOVE-NEAR-WINDOW WINDOW NIL)
	1;; Expose it near the mouse with the minimum acceptable size.
0	(SEND *GLOBAL-MODE-LINE-WINDOW* :SET-SIZE *MINIMUM-WIDTH-FOR-TEMPORARY-MINI-BUFFER*
						  (TV:SHEET-HEIGHT *GLOBAL-MODE-LINE-WINDOW*))
	(TV:SET-WINDOW-ON-USABLE-SCREEN *GLOBAL-MODE-LINE-WINDOW*
					(TV:MOUSE-SHEET
					  (TV:SHEET-MOUSE *GLOBAL-MODE-LINE-WINDOW*))
					NIL 
					:FORCE-MOVE T)
	(TV:EXPOSE-WINDOW-NEAR *GLOBAL-MODE-LINE-WINDOW* '(:MOUSE) NIL NIL))
      (LET ((TERMINAL-IO TERMINAL-IO))		1;Flushing background window will 2setq1 this.
0	1;; Now what we have to do depends on whether or not our window is its
	;; own activity or part of the Zmail activity.
0	(IF (EQ (SEND *GLOBAL-MODE-LINE-WINDOW* :ALIAS-FOR-SELECTED-WINDOWS)
		*GLOBAL-MODE-LINE-WINDOW*)
	    1;; This cannot be 2tv:window-call1 because during the cleanup handler there
	    ;; is no selected-window because the minibuffer has been deexposed already.
	    ;; Use 2tv:window-mouse-call1, which just sends 2:select1 and doesn't try any
	    ;; fancy games with trying to simulate an activity system.  The right solution
	    ;; in the long term is for this 2temporary-mode-line-window-with-borders1 to
	    ;; get added temporarily to the activity of the program that called it,
	    ;; so no cross-activity selection is involved in this operation at all.      
0	    (TV:WINDOW-MOUSE-CALL (*GLOBAL-MODE-LINE-WINDOW* :DEACTIVATE)
	      (MULTIPLE-VALUE-BIND (TERMINAL-IO STANDARD-INPUT)
		  (SEND SELF :TERMINAL-STREAMS)
		(CATCH 'TOP-LEVEL
		  (APPLY FUNCTION ARGS))))
	  1;; Normal case where this pop-up window is part of another activity -- 
0	  1;;    Theoretically, we should use 2tv:window-call-relative1 but relative selection
0	  1;;    is broken enough that the superior of the called window isn't always correct.
0	  1;;    This bug results in a incomplete (i.e., wedged) selection of the pop-up mini
0	  1;;    buffer when you click on 2Other1 as the printer in Zmail's printer options CVV.
0	  (TV:WINDOW-CALL (*GLOBAL-MODE-LINE-WINDOW* :DEACTIVATE)
	    (MULTIPLE-VALUE-BIND (TERMINAL-IO STANDARD-INPUT)
		(SEND SELF :TERMINAL-STREAMS)
	      (CATCH 'TOP-LEVEL
		(APPLY FUNCTION ARGS)))))))))

(DEFUN TYPEIN-LINE-READLINE-NEAR-WINDOW (WINDOW CTL-STRING &REST ARGS)
  (USING-RESOURCE (EDITOR EDITOR-FOR-TEMPORARY-MINI-BUFFER-RESOURCE)
    (LEXPR-FUNCALL EDITOR ':CALL-MINI-BUFFER-NEAR-WINDOW WINDOW
		   #'TYPEIN-LINE-READLINE CTL-STRING ARGS)))

(DEFUN READ-DEFAULTED-PATHNAME-NEAR-WINDOW (WINDOW PROMPT
					    &OPTIONAL (DEFAULTS (PATHNAME-DEFAULTS))
						      SPECIAL-TYPE)
  (LET ((SPECIAL-VERSION (WHEN (TYPEP DEFAULTS 'FS:PATHNAME) (SEND DEFAULTS :VERSION))))
    (USING-RESOURCE (EDITOR EDITOR-FOR-TEMPORARY-MINI-BUFFER-RESOURCE)
      (FUNCALL EDITOR ':CALL-MINI-BUFFER-NEAR-WINDOW WINDOW
	       #'ACCEPT-DEFAULTED-PATHNAME
	       PROMPT DEFAULTS :SPECIAL-TYPE SPECIAL-TYPE :SPECIAL-VERSION SPECIAL-VERSION))))

(DEFUN READ-BUFFER-NAME-NEAR-WINDOW (WINDOW PROMPT DEFAULT &OPTIONAL IMPOSSIBLE-IS-OK-P)
  (USING-RESOURCE (EDITOR EDITOR-FOR-TEMPORARY-MINI-BUFFER-RESOURCE)
    (FUNCALL EDITOR ':CALL-MINI-BUFFER-NEAR-WINDOW WINDOW
	     #'READ-BUFFER-NAME PROMPT DEFAULT IMPOSSIBLE-IS-OK-P)))

(DEFVAR *BACKGROUND-TYPEOUT-WHICH-OPERATIONS*)

(DEFUN BACKGROUND-TYPEOUT-STREAM (OP &REST ARGS)
  (SELECTQ OP
    ((:WHICH-OPERATIONS :OPERATION-HANDLED-P :SEND-IF-HANDLES)
     ;; Get the which-operations once, but after the flavor has been compiled
     (OR (VARIABLE-BOUNDP *BACKGROUND-TYPEOUT-WHICH-OPERATIONS*)
	 (USING-RESOURCE (WINDOW BACKGROUND-TYPEOUT-WINDOWS
				 TV:(MOUSE-DEFAULT-SUPERIOR
				      1;; Can't use default of 2terminal-io1 as we're 2terminal-io1!
0				      SELECTED-WINDOW))
	   (LET ((WO (SEND WINDOW :WHICH-OPERATIONS)))
	     (SETQ *BACKGROUND-TYPEOUT-WHICH-OPERATIONS*
		   (IF (MEMQ :BEEP WO) WO (CONS :BEEP WO))))))
     (SELECTQ OP
       (:WHICH-OPERATIONS *BACKGROUND-TYPEOUT-WHICH-OPERATIONS*)
       (:OPERATION-HANDLED-P (MEMQ (CAR ARGS) *BACKGROUND-TYPEOUT-WHICH-OPERATIONS*))
       (:SEND-IF-HANDLES
	(WHEN (MEMQ (FIRST ARGS) *BACKGROUND-TYPEOUT-WHICH-OPERATIONS*)
	  (CL:APPLY #'BACKGROUND-TYPEOUT-STREAM ARGS)))))
    (:BEEP
     (LEXPR-SEND (SEND *GLOBAL-MODE-LINE-WINDOW* :SCREEN) :BEEP ARGS))
    ((:INCOMPLETE-P :BOTTOM-REACHED :MAKE-COMPLETE :DEACTIVATE) NIL)
    (:SCREEN (SEND *GLOBAL-MODE-LINE-WINDOW* :SCREEN))
    (OTHERWISE
     (SETQ TERMINAL-IO (ALLOCATE-RESOURCE 'BACKGROUND-TYPEOUT-WINDOWS
					  (TV:SHEET-SUPERIOR *GLOBAL-MODE-LINE-WINDOW*)))
     (SEND *GLOBAL-MODE-LINE-WINDOW* :SET-BACKGROUND-TYPEOUT-WINDOW TERMINAL-IO)
     (TV:SHEET-FORCE-ACCESS (TERMINAL-IO :NO-PREPARE)
       (SEND TERMINAL-IO :SET-LABEL (STRING-APPEND (SEND *GLOBAL-MODE-LINE-WINDOW* :NAME)
						    " Background Typeout Window"))
       (SEND TERMINAL-IO :SET-PROCESS CURRENT-PROCESS)
       (SEND TERMINAL-IO :SET-IO-BUFFER (SEND *GLOBAL-MODE-LINE-WINDOW* :IO-BUFFER))
       (SEND TERMINAL-IO :CLEAR-HISTORY))
     (LET ((OLD-SEL TV:(SHEET-SELECTED-WINDOW TERMINAL-IO)))
       ;; Put the background typeout window next to the minibuffer,
       ;; but don't expose it yet (see kludge below)
       (MULTIPLE-VALUE-BIND (LEFT TOP RIGHT BOTTOM) (SEND *GLOBAL-MODE-LINE-WINDOW* :EDGES)
	 (TV:MOVE-WINDOW-NEAR-RECTANGLE TERMINAL-IO LEFT TOP RIGHT BOTTOM NIL NIL))
       ;; Kludge for Zmail, where we could be called from a temporary menu that
       ;; is a brother of ours, hence a window that needs to be deexposed in
       ;; order to expose TERMINAL-IO could be temp-locked.  Probably the right
       ;; way to fix this is to make the background-typeout-window be a temporary
       ;; window, but that may have its own unfortunate side-effects.
       (DOLIST (W (TV:SHEET-EXPOSED-INFERIORS (TV:SHEET-SUPERIOR TERMINAL-IO)))
	 (WHEN (TV:SHEET-OVERLAPS-SHEET-P TERMINAL-IO W)
	   (TV:SHEET-FREE-TEMPORARY-LOCKS W)))
       (SEND TERMINAL-IO :EXPOSE)
       ;; Now, if the minibuffer got de-exposed by all this, bring it back.
       ;; Try to put it back where it was, but if that overlaps the typeout window
       ;; put it below the typeout window so both can be exposed at the same time.
       ;; Do an immediate redisplay so it doesn't look stupid if we get a **more**
       ;; break while typing out on the background typeout window.
       (UNLESS (TV:SHEET-EXPOSED-P *GLOBAL-MODE-LINE-WINDOW*)
	 (WHEN (TV:SHEET-OVERLAPS-SHEET-P *GLOBAL-MODE-LINE-WINDOW* TERMINAL-IO)
	   (SEND *GLOBAL-MODE-LINE-WINDOW* :MOVE-NEAR-WINDOW TERMINAL-IO NIL))
	 (SEND *GLOBAL-MODE-LINE-WINDOW* :EXPOSE)
	 (SEND *GLOBAL-MODE-LINE-WINDOW* :REDISPLAY *MODE-LINE-LIST*))
       ;; Restore the selected window, disturbed by all this exposing and deexposing.
       (AND OLD-SEL (SEND OLD-SEL :SELECT NIL)))
     (SETQ *TYPEOUT-WINDOW* TERMINAL-IO)
     (LEXPR-SEND TERMINAL-IO OP ARGS))))

(DEFFLAVOR BACKGROUND-TYPEOUT-WINDOW () (DW:DYNAMIC-WINDOW))

(DEFMETHOD (:INCOMPLETE-P BACKGROUND-TYPEOUT-WINDOW) () NIL)

(DEFMETHOD (:MAKE-COMPLETE BACKGROUND-TYPEOUT-WINDOW) () NIL)

(TV:DEFWINDOW-RESOURCE BACKGROUND-TYPEOUT-WINDOWS ()
	:MAKE-WINDOW (BACKGROUND-TYPEOUT-WINDOW
			 :HEIGHT (// TV:(SHEET-HEIGHT DEFAULT-SCREEN) 3)
			 :SAVE-BITS T)		;So PREPARE-SHEET doesn't nop its body!
	:REUSABLE-WHEN :DEACTIVATED
	:INITIAL-COPIES 0)
  
(TV:DEFWINDOW-RESOURCE SPLIT-SCREEN-MENU ()
	:MAKE-WINDOW (TV:POP-UP-MENU :NAME "Split Screen" :LABEL "Split screen buffer:"
				     :COLUMNS 2
				     :CENTERED-COLUMNS NIL)
	:REUSABLE-WHEN :DEEXPOSED
	:INITIAL-COPIES 0)

(DEFCONST *SPLIT-SCREEN-AMONG-BUFFERS-FIXED-ITEMS*
     '(("New buffer" :VALUE "New buffer"
	:DOCUMENTATION "Create a new, empty buffer.  Prompt for its name.")
       ("Find file" :VALUE "Find file" 
	:DOCUMENTATION "Do a Find File command and put the resulting buffer in a window.")
       ("Undo" :VALUE "Undo"
	:STYLE (:SWISS :BOLD :NORMAL)
	:DOCUMENTATION "Undo last selection.")
       ("Do It" :VALUE "Do It"
	:STYLE (:SWISS :BOLD :NORMAL)
	:DOCUMENTATION "Complete the selection and set up the windows as specified.")
       ("Abort" :VALUE "Abort"
	:STYLE (:SWISS :BOLD :NORMAL)
	:DOCUMENTATION "Abort the Split Screen command.")))

(DEFUN SPLIT-SCREEN-AMONG-BUFFERS-MENU-ITEM-LIST ()
  (LOOP WITH RESULT = ()
	AND NULL-ITEM = '("" :NO-SELECT T)
	AND N
	WITH STUFF = (LET ((BUF-LIST (SORTCAR (LOOP FOR BUFFER IN *ZMACS-BUFFER-LIST*
						    COLLECT (CONS (SEND BUFFER :NAME) BUFFER))
					      #'STRING-LESSP)))
		       (SETQ N (LENGTH BUF-LIST))
		       (WHEN (ODDP N)
			 (SETQ BUF-LIST (NCONC BUF-LIST (NCONS NULL-ITEM)))
			 (INCF N))
		       BUF-LIST)
	FOR FIRST IN STUFF
	FOR SECOND IN (NTHCDR (// N 2) STUFF)
	DO (PUSH FIRST RESULT)
	   (PUSH SECOND RESULT)
	FINALLY (DOTIMES (IGNORE 2)
		  (PUSH NULL-ITEM RESULT))
		(RETURN (NRECONC RESULT *SPLIT-SCREEN-AMONG-BUFFERS-FIXED-ITEMS*))))

(DEFUN SPLIT-SCREEN-AMONG-BUFFERS-VIA-MENUS (FRAME)
  (USING-RESOURCE (MENU SPLIT-SCREEN-MENU)
    (SEND MENU ':SET-ITEM-LIST (SPLIT-SCREEN-AMONG-BUFFERS-MENU-ITEM-LIST))
    (LET* ((ENOUGH-ROOM-FOR-LAYOUT 100.)	;See (:MOVE-NEAR-WINDOW DISPLAY-LAYOUT-WINDOW)
	   (SUPERIOR-HEIGHT (SEND (SEND MENU :SUPERIOR) :INSIDE-HEIGHT))
	   (NEAR-MODE '(:MOUSE))
	   (HALF-SUPERIOR-HEIGHT (FLOOR SUPERIOR-HEIGHT 2)))
      (WHEN (> (+ (SEND MENU :HEIGHT) ENOUGH-ROOM-FOR-LAYOUT) SUPERIOR-HEIGHT)
	(SEND MENU :SET-SIZE (SEND MENU :WIDTH) (- SUPERIOR-HEIGHT ENOUGH-ROOM-FOR-LAYOUT)))
      (WHEN (> (+ (SEND MENU :HEIGHT) (* 2 ENOUGH-ROOM-FOR-LAYOUT)) SUPERIOR-HEIGHT)
	(MULTIPLE-VALUE-BIND (X-OFF Y-OFF MOUSE)
	    (TV:SHEET-MOUSE-OFFSETS (TV:SHEET-SUPERIOR MENU) NIL)
	  (MULTIPLE-VALUE-BIND (MOUSE-X MOUSE-Y)
	      (VALUES (- (SYS:MOUSE-X MOUSE) X-OFF) (- (SYS:MOUSE-Y MOUSE) Y-OFF))
	    (IF ( MOUSE-Y HALF-SUPERIOR-HEIGHT)
		(SETQ MOUSE-Y (MIN MOUSE-Y (- HALF-SUPERIOR-HEIGHT ENOUGH-ROOM-FOR-LAYOUT)))
	      (SETQ MOUSE-Y (MAX MOUSE-Y (+ HALF-SUPERIOR-HEIGHT ENOUGH-ROOM-FOR-LAYOUT))))
	    (SETQ NEAR-MODE `(:POINT ,(+ MOUSE-X X-OFF) ,(+ MOUSE-Y Y-OFF))))))
      (TV:EXPOSE-WINDOW-NEAR MENU NEAR-MODE))
    (USING-RESOURCE (LAYWIN TV:SPLIT-SCREEN-LAYOUT-WINDOW)
      (SEND LAYWIN ':CLEAR-FROBS)
      (UNWIND-PROTECT
	  (DO ((BUFFER-LIST NIL)
	       (N-WINDOWS 0)
	       (RES))
	      (NIL)
	    (AND (= N-WINDOWS 1)
		 (SEND LAYWIN ':MOVE-NEAR-WINDOW MENU
		       (MULTIPLE-VALUE-BIND (WIDTH HEIGHT)
			   (SEND FRAME ':INSIDE-SIZE)
			 (CONS WIDTH HEIGHT))))
	    (SETQ RES (SEND MENU ':CHOOSE))
	    (AND (EQUAL RES "New buffer")
		 (SETQ RES (READ-BUFFER-NAME-NEAR-WINDOW MENU "New buffer" NIL T)))
	    (COND ((SYMBOLP RES))
		  ((NOT (STRINGP RES))
		   (PUSH RES BUFFER-LIST)
		   (SEND LAYWIN ':ADD-FROB (SEND RES ':NAME))
		   (SETQ N-WINDOWS (1+ N-WINDOWS)))
		  ((STRING-EQUAL RES "Abort")
		   (RETURN NIL))
		  ((STRING-EQUAL RES "Find file")
		   (SETQ RES (READ-DEFAULTED-PATHNAME-NEAR-WINDOW MENU "Find file"))
		   (COND ((TYPEP RES 'FS:PATHNAME)
			  (PUSH RES BUFFER-LIST)
			  (SEND LAYWIN ':ADD-FROB (SEND RES ':STRING-FOR-EDITOR))
			  (SETQ N-WINDOWS (1+ N-WINDOWS)))))
		  ((STRING-EQUAL RES "Undo")
		   (COND ((PLUSP N-WINDOWS)
			  (SETQ N-WINDOWS (1- N-WINDOWS)
				BUFFER-LIST (CDR BUFFER-LIST))
			  (SEND LAYWIN ':REMOVE-LAST-FROB))))
		  (T (RETURN (NREVERSE BUFFER-LIST)))))
	(TV:DELAYING-SCREEN-MANAGEMENT
	  (SEND LAYWIN ':DEACTIVATE)
	  (SEND MENU ':DEACTIVATE))))))

(DEFUN SPLIT-SCREEN-AMONG-BUFFERS-DO-IT (FRAME BUFFER-LIST &AUX N-COLUMNS N-ROWS WIDTH HEIGHT
					       FRAME-LEFT FRAME-TOP FRAME-RIGHT FRAME-BOTTOM
					       WINDOW-LIST)
  (LET ((N-WINDOWS (LENGTH BUFFER-LIST)))
    (IF (< N-WINDOWS 4)
	(SETQ N-COLUMNS 1 N-ROWS N-WINDOWS)
	(SETQ N-COLUMNS 2 N-ROWS (// (1+ N-WINDOWS) 2))))
  (MULTIPLE-VALUE (FRAME-LEFT FRAME-TOP FRAME-RIGHT FRAME-BOTTOM)
    (SEND FRAME :INSIDE-EDGES-WITHOUT-MODE-LINE-WINDOW))
  (SETQ WIDTH (// (- FRAME-RIGHT FRAME-LEFT) N-COLUMNS)
	HEIGHT (// (- FRAME-BOTTOM FRAME-TOP) N-ROWS))
  (SETQ WINDOW-LIST (SEND FRAME :N-EDITOR-WINDOWS (LENGTH BUFFER-LIST)))
  (TV:DELAYING-SCREEN-MANAGEMENT
    (DO ((BL BUFFER-LIST (CDR BL))
	 (WL WINDOW-LIST (CDR WL))
	 (I 0 (1+ I))
	 (LEFT) (RIGHT) (TOP) (BOTTOM) (WINDOW))
	((NULL BL))
      (SETQ LEFT (+ FRAME-LEFT (* (\ I N-COLUMNS) WIDTH))
	    RIGHT (+ LEFT WIDTH)
	    TOP (+ FRAME-TOP (* (// I N-COLUMNS) HEIGHT))
	    BOTTOM (+ TOP HEIGHT))
      ;; The bottom-most window is taller, and wider if there are an odd number of them.
      (WHEN (= (// I N-COLUMNS) (1- N-ROWS))
	(SETQ BOTTOM FRAME-BOTTOM)
	(WHEN (NULL (CDR BL))
	  (SETQ RIGHT FRAME-RIGHT)))
      (SETQ WINDOW (WINDOW-SHEET (CAR WL)))
      (SEND WINDOW :SET-EDGES LEFT TOP RIGHT BOTTOM)
      (SEND WINDOW :EXPOSE NIL :CLEAN)
      (AND (ZEROP I) (SEND WINDOW :SELECT-RELATIVE))))
  (SEND FRAME :UPDATE-LABELS)
  WINDOW-LIST)

(DEFUN WINDOW-FRAME (ZWEI-WINDOW)
  (TV:SHEET-SUPERIOR (WINDOW-SHEET ZWEI-WINDOW)))

;;; The DEFFLAVOR for ZWEI-FRAME moved to DEFS.

(DEFMETHOD (:INIT ZWEI-FRAME :AFTER) (INIT-PLIST)
  (AND (SYMBOLP MODE-LINE-WINDOW)
       (LET (*GLOBAL-MODE-LINE-WINDOW*)
	 (INITIALIZE-MINI-BUFFER-WINDOW (GET INIT-PLIST ':NUMBER-OF-MINI-BUFFER-LINES)
					SELF MODE-LINE-WINDOW TV:IO-BUFFER
					':BOTTOM (TV:SHEET-INSIDE-BOTTOM)
					':EXPOSE-P T)
	 (SETQ MODE-LINE-WINDOW *GLOBAL-MODE-LINE-WINDOW*
	       TV:IO-BUFFER (FUNCALL MODE-LINE-WINDOW ':IO-BUFFER))
	 (FUNCALL (FUNCALL MODE-LINE-WINDOW ':TYPEIN-WINDOW) ':EXPOSE))))

(DEFMETHOD (:CREATE-WINDOW ZWEI-FRAME) (TYPE &REST OPTIONS)
  (LET ((ZWEI-WINDOW (LEXPR-FUNCALL #'CREATE-WINDOW TYPE
				    ':SUPERIOR SELF
				    ':BOTTOM (TV:SHEET-Y-OFFSET MODE-LINE-WINDOW)
				    ':IO-BUFFER TV:IO-BUFFER
				    OPTIONS)))
    (WHEN (NULL TV:SELECTED-PANE)
      (SETQ TV:SELECTED-PANE (WINDOW-SHEET ZWEI-WINDOW)))
    ZWEI-WINDOW))

(DEFMETHOD (:EDITOR-WINDOW ZWEI-FRAME) ()
  (DO ((L TV:INFERIORS (CDR L)))
      ((NULL L) (FERROR NIL "No inferiors"))
    (OR (EQ (CAR L) MODE-LINE-WINDOW)
	(RETURN (FUNCALL (CAR L) ':ZWEI-WINDOW)))))

(DEFMETHOD (:INSIDE-EDGES-WITHOUT-MODE-LINE-WINDOW ZWEI-FRAME) (&OPTIONAL USE-OLD-HEIGHT)
  (VALUES (TV:SHEET-INSIDE-LEFT) (TV:SHEET-INSIDE-TOP) (TV:SHEET-INSIDE-RIGHT)
	  (IF USE-OLD-HEIGHT
	      (TV:SHEET-Y-OFFSET MODE-LINE-WINDOW)
	      (- (TV:SHEET-INSIDE-BOTTOM) (TV:SHEET-HEIGHT MODE-LINE-WINDOW)))))

(DEFWRAPPER (:CHANGE-OF-SIZE-OR-MARGINS ZWEI-FRAME) (IGNORE . BODY)
  `(LET ((OLD-EXPOSED-INFERIORS (COPYLIST TV:EXPOSED-INFERIORS)))
     (DECLARE (SPECIAL OLD-EXPOSED-INFERIORS))
     (MULTIPLE-VALUE-BIND (OLD-INSIDE-LEFT OLD-INSIDE-TOP
			   OLD-INSIDE-RIGHT OLD-INSIDE-BOTTOM)
	 (SEND SELF ':INSIDE-EDGES-WITHOUT-MODE-LINE-WINDOW T)
       (DECLARE (SPECIAL OLD-INSIDE-LEFT OLD-INSIDE-TOP
			 OLD-INSIDE-RIGHT OLD-INSIDE-BOTTOM))
       ,@BODY)))

(DEFMETHOD (:CHANGE-OF-SIZE-OR-MARGINS ZWEI-FRAME :AFTER)
	   (&REST IGNORE &AUX OLD-INSIDE-WIDTH OLD-INSIDE-HEIGHT
			      NEW-INSIDE-LEFT NEW-INSIDE-TOP
			      NEW-INSIDE-RIGHT NEW-INSIDE-BOTTOM
			      NEW-INSIDE-WIDTH NEW-INSIDE-HEIGHT)
  (DECLARE (SPECIAL OLD-EXPOSED-INFERIORS
		    OLD-INSIDE-LEFT OLD-INSIDE-TOP
		    OLD-INSIDE-RIGHT OLD-INSIDE-BOTTOM))
  (SETQ OLD-INSIDE-WIDTH (- OLD-INSIDE-RIGHT OLD-INSIDE-LEFT)
	OLD-INSIDE-HEIGHT (- OLD-INSIDE-BOTTOM OLD-INSIDE-TOP))
  (MULTIPLE-VALUE (NEW-INSIDE-LEFT NEW-INSIDE-TOP NEW-INSIDE-RIGHT NEW-INSIDE-BOTTOM)
    (FUNCALL-SELF ':INSIDE-EDGES-WITHOUT-MODE-LINE-WINDOW))
  (SETQ NEW-INSIDE-WIDTH (- NEW-INSIDE-RIGHT NEW-INSIDE-LEFT)
	NEW-INSIDE-HEIGHT (- NEW-INSIDE-BOTTOM NEW-INSIDE-TOP))
  (TV:WITH-SHEET-DEEXPOSED (SELF)
    (DO ((WL (COPYLIST TV:INFERIORS) (CDR WL))
	 (WINDOW)
	 (OLD-LEFT) (OLD-TOP) (OLD-RIGHT) (OLD-BOTTOM)
	 (NEW-LEFT) (NEW-TOP) (NEW-RIGHT) (NEW-BOTTOM))
	((NULL WL))
      (SETQ WINDOW (CAR WL))
      (MULTIPLE-VALUE (OLD-LEFT OLD-TOP OLD-RIGHT OLD-BOTTOM)
	(FUNCALL WINDOW ':EDGES))
      (IF (EQ WINDOW MODE-LINE-WINDOW)
	  (SETQ NEW-LEFT NEW-INSIDE-LEFT
		NEW-TOP NEW-INSIDE-BOTTOM
		NEW-RIGHT NEW-INSIDE-RIGHT
		NEW-BOTTOM (+ NEW-INSIDE-BOTTOM (- OLD-BOTTOM OLD-TOP)))
	  (SETQ NEW-LEFT (IF (= OLD-LEFT OLD-INSIDE-LEFT) NEW-INSIDE-LEFT
			     (// (* OLD-LEFT NEW-INSIDE-WIDTH) OLD-INSIDE-WIDTH))
		NEW-TOP (IF (= OLD-TOP OLD-INSIDE-TOP) NEW-INSIDE-TOP
			    (// (* OLD-TOP NEW-INSIDE-HEIGHT) OLD-INSIDE-HEIGHT))
		NEW-RIGHT (IF (= OLD-RIGHT OLD-INSIDE-RIGHT) NEW-INSIDE-RIGHT
			      (// (* OLD-RIGHT NEW-INSIDE-WIDTH) OLD-INSIDE-WIDTH))
		NEW-BOTTOM (IF (= OLD-BOTTOM OLD-INSIDE-BOTTOM) NEW-INSIDE-BOTTOM
			       (// (* OLD-BOTTOM NEW-INSIDE-HEIGHT) OLD-INSIDE-HEIGHT))))
      (FUNCALL WINDOW ':SET-EDGES NEW-LEFT NEW-TOP NEW-RIGHT NEW-BOTTOM)
      (AND (OR (MEMQ WINDOW OLD-EXPOSED-INFERIORS)
	       ;; see (:SET-LINE-HEIGHT-FROM-STYLES MODE-LINE-SUPERIOR-MIXIN)
	       (EQ WINDOW MODE-LINE-WINDOW))
	   (FUNCALL WINDOW ':EXPOSE)))))

(DEFFLAVOR ZWEI-PANE () (TV:PANE-MIXIN ZWEI))

(DEFMETHOD (:MODE-LINE-WINDOW ZWEI-PANE) ()
  (FUNCALL TV:SUPERIOR ':MODE-LINE-WINDOW))

(DEFFLAVOR ZWEI-WINDOW-PANE () (ZWEI-PANE ZWEI-WINDOW)
  (:DEFAULT-INIT-PLIST :SAVE-BITS NIL
		       :MARGIN-COMPONENTS 'DW:((MARGIN-RAGGED-BORDERS :THICKNESS 1)
					       (MARGIN-WHITE-BORDERS )
					       (MARGIN-SCROLL-BAR
						 :VISIBILITY :IF-REQUESTED
						 :HISTORY-NOUN "buffer"))))

;;; Can grow new panes at will
;;; The DEFFLAVOR for NEW-PANES-ZWEI-FRAME moved to DEFS.

(DEFMETHOD (:TWO-EDITOR-WINDOWS NEW-PANES-ZWEI-FRAME) (&OPTIONAL PREF &AUX WS)
  ;; Sort the available windows so that we can get two contiguous windows,
  ;; i.e. one on top of the other.
  (SETQ WS (SORT (COPYLIST TV:INFERIORS)
		 #'(LAMBDA (W-1 W-2)
		     (COND ((NOT (TV:SHEET-EXPOSED-P W-2)) T)
			   ((NOT (TV:SHEET-EXPOSED-P W-1)) NIL)
			   ((= (TV:SHEET-X-OFFSET W-1) (TV:SHEET-X-OFFSET W-2))
			    (< (TV:SHEET-Y-OFFSET W-1) (TV:SHEET-Y-OFFSET W-2)))
			   (T
			    (< (TV:SHEET-X-OFFSET W-1) (TV:SHEET-X-OFFSET W-2)))))))
  (WHEN PREF
    ;; Make WS start with the first window whose X position is the same as the
    ;; preferred window.  This could be above or below the preferred window.
    ;; But do this only if there is at least one such window besides the preferred one.
    (LOOP FOR L ON WS WITH LL = NIL
	  AS W = (CAR L)
	  DO (WHEN (AND (TV:SHEET-EXPOSED-P W)
			(NEQ W MODE-LINE-WINDOW)
			(= (TV:SHEET-X-OFFSET W) (TV:SHEET-X-OFFSET PREF)))
	       (UNLESS LL
		 (SETQ LL L))
	       (UNLESS (EQ W PREF)
		 (RETURN (SETQ WS LL))))))
  (DO ((L WS (CDR L))
       (WINDOW)
       (TOP-WINDOW) (BOTTOM-WINDOW))
      ((NULL L)
       (VALUES (SEND TOP-WINDOW ':ZWEI-WINDOW)
	       (SEND SELF ':CREATE-NEW-PANE)))
    (COND ((EQ (SETQ WINDOW (CAR L)) MODE-LINE-WINDOW))
	  ((NULL TOP-WINDOW)
	   (SETQ TOP-WINDOW WINDOW))
	  (T
	   (SETQ BOTTOM-WINDOW WINDOW)
	   (AND (TV:SHEET-EXPOSED-P BOTTOM-WINDOW)
		(< (TV:SHEET-Y-OFFSET BOTTOM-WINDOW) (TV:SHEET-Y-OFFSET TOP-WINDOW))
		(PSETQ TOP-WINDOW BOTTOM-WINDOW BOTTOM-WINDOW TOP-WINDOW))
	   (RETURN (VALUES (SEND TOP-WINDOW ':ZWEI-WINDOW)
			   (SEND BOTTOM-WINDOW ':ZWEI-WINDOW)))))))

;; Return N editor windows.
(DEFMETHOD (:N-EDITOR-WINDOWS NEW-PANES-ZWEI-FRAME) (N)
  (LET ((LIST NIL)
	(I 0))
    (LOOP FOR W IN TV:INFERIORS
	  UNTIL ( I N)
	  DO (UNLESS (EQ W MODE-LINE-WINDOW)
	       (PUSH (SEND W :ZWEI-WINDOW) LIST)
	       (INCF I)))
    (DOTIMES (IGNORE (- N I))
      (PUSH (SEND SELF :CREATE-NEW-PANE) LIST))
    LIST))

;; Return N editor windows, none of which are currently exposed.
(DEFMETHOD (:N-FREE-EDITOR-WINDOWS NEW-PANES-ZWEI-FRAME) (N)
  (LET ((LIST NIL)
	(I 0))
    (LOOP FOR W IN TV:INFERIORS
	  UNTIL ( I N)
	  DO (UNLESS (OR (EQ W MODE-LINE-WINDOW) (SEND W :EXPOSED-P))
	       (PUSH (SEND W :ZWEI-WINDOW) LIST)
	       (INCF I)))
    (DOTIMES (IGNORE (- N I))
      (PUSH (SEND SELF :CREATE-NEW-PANE) LIST))
    LIST))   
   


(DEFFLAVOR ZMACS-WINDOW-PANE () (ZWEI-PANE ZMACS-WINDOW))

(DEFMETHOD (:CHANGE-LABEL ZMACS-WINDOW-PANE) (NEW-LABEL)
  (FUNCALL TV:SUPERIOR ':CHANGE-PANE-LABEL SELF NEW-LABEL))

(DEFMETHOD (:EXPOSE ZMACS-WINDOW-PANE :AFTER) (&REST IGNORE)
  (SEND TV:SUPERIOR ':UPDATE-LABELS))

;;; the DEFFLAVOR for ZMACS-FRAME has been moved to DEFS, along with the
;;; associated defvar and SETF method.

(DEFVAR *ZMACS-PROCESSES-COUNTER* NIL)
(DEFMETHOD (:INIT ZMACS-FRAME :BEFORE) (IGNORE)
  (IF (AND *ZMACS-WINDOW-PROCESS*
	   *ENFORCE-SINGLE-ZMACS-PROCESS*)
      (SETQ TV:PROCESS *ZMACS-WINDOW-PROCESS*
	    TV:IO-BUFFER (SEND *ZMACS-COMMAND-LOOP* :IO-BUFFER))
    (UNLESS TV:PROCESS
      ;; Only make a new process if the caller has not done it himself.
      ;; Some things, like Writer Tools, want their own process.
      (LET ((PROCESS-NAME (IF *ZMACS-PROCESSES-COUNTER*
			      (FORMAT NIL "Zmacs Windows ~D"
				(WITHOUT-INTERRUPTS
				  (INCF *ZMACS-PROCESSES-COUNTER*)))
			    (SETQ *ZMACS-PROCESSES-COUNTER* 1)
			    "Zmacs Windows")))
	;; There is a timing window between this and the time at which the
	;; :AFTER method gets run, during which the COMMAND-LOOP i.v. has not
	;; been set, which is why we start with arrest reasons.
	(SETQ TV:PROCESS (MAKE-PROCESS PROCESS-NAME
				       :INITIAL-FORM `(ZMACS-WINDOW-TOP-LEVEL ,SELF)
				       :SPECIAL-PDL-SIZE 10000.
				       :ARREST-REASONS '(INITIALIZING-ZMACS)))))))
 
(DEFMETHOD (:INIT ZMACS-FRAME :AFTER) (IGNORE)
  (SEND SELF :CREATE-NEW-PANE ':ACTIVATE-P T ':LABEL NIL)
  (IF (AND *ZMACS-COMMAND-LOOP*
	   *ENFORCE-SINGLE-ZMACS-PROCESS*)
      (SETQ COMMAND-LOOP *ZMACS-COMMAND-LOOP*)
    (LET* ((WINDOW (SEND SELF :EDITOR-WINDOW))
	   (INTERVAL (GET-BUFFER-FOR-WINDOW))
	   (STREAM (MAKE-MACRO-STREAM (MAKE-RECORDING-STREAM (WINDOW-SHEET WINDOW) 100.))))
      (ALTER-WINDOW WINDOW BUFFER-HISTORY (LIST INTERVAL))
      (SET-WINDOW-INTERVAL WINDOW INTERVAL)
      #+IGNORE ; You can't do that here, you're not even in the right process yet.
      (LET ((*INTERVAL* NIL))
	(SEND INTERVAL :MAKE-CURRENT))
      (SETQ COMMAND-LOOP (MAKE-COMMAND-LOOP *ZMACS-COMTAB* WINDOW
					    'ZMACS-TOP-LEVEL-EDITOR
					    :PROCESS TV:PROCESS
					    :STANDARD-INPUT STREAM))
      ;; The first Zmacs should always remain the first Zmacs
      (WITHOUT-INTERRUPTS
	(SETQ *ZMACS-COMMAND-LOOPS* (NCONC *ZMACS-COMMAND-LOOPS* (LIST COMMAND-LOOP))))
      (SEND TV:PROCESS :REVOKE-ARREST-REASON 'INITIALIZING-ZMACS))))

(DEFMETHOD (:KILL ZMACS-FRAME :AFTER) ()
  (WITHOUT-INTERRUPTS
    (SETQ *ZMACS-COMMAND-LOOPS* (DELQ COMMAND-LOOP *ZMACS-COMMAND-LOOPS*))))

(DEFMETHOD (:CREATE-NEW-PANE ZMACS-FRAME) (&REST OPTIONS)
  (LEXPR-SEND SELF :CREATE-WINDOW 'ZMACS-WINDOW-PANE :PROCESS TV:PROCESS OPTIONS))

(DEFMETHOD (:FORCE-KBD-INPUT ZMACS-FRAME) (THING &OPTIONAL NO-HANG-P WHOSTATE)
  (TV:IO-BUFFER-PUT TV:IO-BUFFER THING NO-HANG-P WHOSTATE))

(DEFUN-IN-FLAVOR (SET-LABEL-NAME-P ZMACS-FRAME) (PANE)
  (OR (CL:MEMBER *ALWAYS-LABEL-ZMACS-WINDOWS* '(T :ALWAYS))
      ( (LENGTH TV:EXPOSED-INFERIORS) 3)
      (AND (EQL *ALWAYS-LABEL-ZMACS-WINDOWS* :VC-BUFFERS-ONLY)
	   (TYPEP (WINDOW-INTERVAL (SEND PANE :ZWEI-WINDOW)) 'VC-FILE-BUFFER))))

(DEFMETHOD (:CHANGE-PANE-LABEL ZMACS-FRAME) (PANE NEW-LABEL)
  (WHEN (SET-LABEL-NAME-P PANE)
    (SEND PANE :DELAYED-SET-LABEL
	  `(:STRING ,NEW-LABEL
	    :STYLE ,(SI:MERGE-CHARACTER-STYLES 
		      PANE-LABEL-CHARACTER-STYLE
		      TV:*DEFAULT-STYLE*)))))

(DEFMETHOD (:UPDATE-LABELS ZMACS-FRAME) ()
  (DOLIST (W TV:EXPOSED-INFERIORS)
    (UNLESS (EQ W MODE-LINE-WINDOW)
      (IF (SET-LABEL-NAME-P W)
	  (SEND W :DELAYED-SET-LABEL
		`(:STRING
		   ,(BUFFER-NAME-FOR-DISPLAY
		      (WINDOW-INTERVAL (SEND W :ZWEI-WINDOW)))
		   :STYLE
		   ,(SI:MERGE-CHARACTER-STYLES 
		      PANE-LABEL-CHARACTER-STYLE
		      TV:*DEFAULT-STYLE*)))
	  (SEND W :DELAYED-SET-LABEL NIL)))))

(DEFMETHOD (:PANE-TYPES-ALIST ZMACS-FRAME) ()
  '(("Edit" . ZMACS-WINDOW-PANE)))

(DEFMETHOD (:CREATE-BUG-MAIL-FRAME-DRAFT ZMACS-FRAME) (INTERVAL)
  (LET* ((BUFFER (SEND INTERVAL :GET :ZMACS-BUFFER))
	 (PLIST (SEND INTERVAL :PLIST))
	 (CONTENTS (STRING-INTERVAL INTERVAL))
	 (BUG-REPORT (SEND INTERVAL :BUG-REPORT)))
    (WHEN BUFFER (SETQ BUFFER (LET ((BUF (FIND-BUFFER-NAMED (SEND BUFFER :NAME))))
				(WHEN (AND BUF (TYPEP BUF 'BUG-MAIL-FRAME-MAIL-BUFFER))
				  BUF))))
    (IF (NULL BUFFER)
	(PROG1 (SETQ BUFFER (SEND COMMAND-LOOP :FIND-SPECIAL-BUFFER
				  :BUG-MAIL-FRAME-MAIL T
				  :SET-INITIAL-CONTENTS CONTENTS
				  :SET-BUG-REPORT BUG-REPORT
				  :SET-PROPERTY-LIST PLIST))
	       (SETF (BUFFER-SAVED-MODE-LIST BUFFER) `((,(MODE-OF-FLAVOR 'MAIL-MODE)))))
      (SETF (SEND BUFFER :BUG-REPORT) BUG-REPORT)
      (SETF (SEND BUFFER :INITIAL-CONTENTS) CONTENTS)
      (SETF (SEND BUFFER :PROPERTY-LIST) PLIST)
      (SEND BUFFER :REVERT))
    ;; make absolutely sure that the buffer has a package
    (UNLESS (SEND BUFFER :GET :PACKAGE)
      (SEND BUFFER :PUTPROP
	    (OR (VARIABLE-VALUE '*DEFAULT-PACKAGE*) SI:*USER-PACKAGE*) :PACKAGE))
    BUFFER))

;;; Add it to the system Create menu
(TV:ADD-TO-SYSTEM-MENU-CREATE-MENU
  "Edit" 'ZMACS-FRAME "An editor, sharing buffers with other editors." "Lisp")


(DEFFLAVOR STANDALONE-ZWEI-WINDOW-PANE () (ZWEI-WINDOW-PANE))

(DEFMETHOD (:SIZE-DELTAS-FOR-STRING STANDALONE-ZWEI-WINDOW-PANE) (STRING)
  (VALUES (- TV:WIDTH (+ (TV:DECODE-CHARACTER-WIDTH-SPEC STRING) TV:CHAR-WIDTH))
	  (- TV:HEIGHT (TV:DECODE-CHARACTER-HEIGHT-SPEC STRING))))

(DEFFLAVOR BASIC-STANDALONE-EDITOR-FRAME
	((*COMTAB* *STANDALONE-COMTAB*)
	 *MODE-LINE-LIST*)
	()
  (:REQUIRED-FLAVORS ZWEI-FRAME TOP-LEVEL-EDITOR)
  (:SETTABLE-INSTANCE-VARIABLES *MODE-LINE-LIST*)
  (:DEFAULT-INIT-PLIST :NUMBER-OF-MINI-BUFFER-LINES 1)
  :SPECIAL-INSTANCE-VARIABLES
  (:SPECIAL-INSTANCE-VARIABLE-BINDING-METHODS :EDIT :TYPEIN-LINE))

(DEFUN-IN-FLAVOR (PASS-ON-TO-SELECTED-PANE BASIC-STANDALONE-EDITOR-FRAME) (MESSAGE ARGS)
  (LEXPR-SEND TV:SELECTED-PANE MESSAGE ARGS))

(DEFMETHOD (:INTERVAL-STRING BASIC-STANDALONE-EDITOR-FRAME) (&REST ARGS)
  (PASS-ON-TO-SELECTED-PANE :INTERVAL-STRING ARGS))

(DEFMETHOD (:SET-INTERVAL-STRING BASIC-STANDALONE-EDITOR-FRAME) (&REST ARGS)
  (PASS-ON-TO-SELECTED-PANE :SET-INTERVAL-STRING ARGS))

(DEFMETHOD (:ADD-STRING-AT-POINT BASIC-STANDALONE-EDITOR-FRAME) (&REST ARGS)
  (PASS-ON-TO-SELECTED-PANE :ADD-STRING-AT-POINT ARGS))

(DEFMETHOD (:INIT BASIC-STANDALONE-EDITOR-FRAME :AFTER) (IGNORE)
  (SETQ *WINDOW* (SEND SELF :CREATE-WINDOW 'STANDALONE-ZWEI-WINDOW-PANE
			    :ACTIVATE-P T :LABEL NIL)
	TV:SELECTED-PANE (WINDOW-SHEET *WINDOW*))
  (SET-WINDOW-INTERVAL *WINDOW* (CREATE-INTERVAL NIL NIL 'TOP-LEVEL-NODE)))

(DEFMETHOD (:SET-SIZE-FROM-STRING BASIC-STANDALONE-EDITOR-FRAME)
	   (STRING &OPTIONAL MIN-WIDTH MIN-HEIGHT MAX-WIDTH MAX-HEIGHT
		   &AUX DWT DHT MODE-LINE-HEIGHT)
  (MULTIPLE-VALUE (DWT DHT)
    (SEND TV:SUPERIOR :INSIDE-SIZE))
  (SETQ MAX-WIDTH (OR MAX-WIDTH DWT)
	MAX-HEIGHT (OR MAX-HEIGHT DHT))
  (MULTIPLE-VALUE (DWT DHT)
    (SEND TV:SELECTED-PANE :SIZE-DELTAS-FOR-STRING STRING))
  (SETQ DWT (- TV:WIDTH DWT)
	DHT (- TV:HEIGHT DHT))
  (AND MIN-WIDTH (SETQ DWT (MAX MIN-WIDTH DWT)))
  (AND MIN-HEIGHT (SETQ DHT (MAX MIN-HEIGHT DHT)))
  (MULTIPLE-VALUE (NIL MODE-LINE-HEIGHT)
    (SEND *MODE-LINE-WINDOW* :SIZE))
  (SETQ DHT (+ DHT MODE-LINE-HEIGHT))
  (SETQ DWT (MIN DWT MAX-WIDTH)
	DHT (MIN DHT MAX-HEIGHT))
  (SEND SELF :SET-SIZE DWT DHT)
  (SEND TV:SELECTED-PANE :SET-SIZE (- DWT TV:LEFT-MARGIN-SIZE TV:RIGHT-MARGIN-SIZE)
	(- DHT TV:BOTTOM-MARGIN-SIZE TV:TOP-MARGIN-SIZE MODE-LINE-HEIGHT)))

(DEFMETHOD (:TYPEIN-LINE BASIC-STANDALONE-EDITOR-FRAME) (STRING &REST ARGS)
  (LEXPR-FUNCALL #'TYPEIN-LINE STRING ARGS)
  (SEND *TYPEIN-WINDOW* :TYPEOUT-STAYS))

(DEFFLAVOR STANDALONE-EDITOR-FRAME ()
	   (TOP-LEVEL-EDITOR BASIC-STANDALONE-EDITOR-FRAME ZWEI-FRAME))

(DEFMETHOD (:INIT STANDALONE-EDITOR-FRAME :AFTER) (IGNORE)
  (SET-COMTAB *MODE-COMTAB* '(#\ABORT COM-STANDALONE-ABORT)))

(DEFFLAVOR POP-UP-STANDALONE-EDITOR-FRAME ()
	   (TV:TEMPORARY-WINDOW-MIXIN STANDALONE-EDITOR-FRAME TV:ESSENTIAL-MOUSE)
  (:DEFAULT-INIT-PLIST :BORDER-MARGIN-WIDTH 0))

(TV:DEFWINDOW-RESOURCE POP-UP-STANDALONE-EDITOR-FRAME ()
  :MAKE-WINDOW (POP-UP-STANDALONE-EDITOR-FRAME)
  :REUSABLE-WHEN :DEACTIVATED
  :INITIAL-COPIES 0)

(DEFCOM COM-STANDALONE-ABORT "Abort this editing" ()
  (*THROW 'ABORT-STANDALONE-EDIT NIL))

(DEFUN POP-UP-EDSTRING (STRING &OPTIONAL (NEAR-MODE '(:MOUSE)) MODE-LINE-LIST
			MIN-WIDTH MIN-HEIGHT INITIAL-MESSAGE)
  (USING-RESOURCE (WINDOW POP-UP-STANDALONE-EDITOR-FRAME)
    (SEND WINDOW :SET-SIZE-FROM-STRING STRING MIN-WIDTH MIN-HEIGHT)
    (SEND WINDOW :SET-INTERVAL-STRING STRING)
    (WHEN MODE-LINE-LIST
      (SEND WINDOW :SET-*MODE-LINE-LIST* MODE-LINE-LIST))
    (TV:EXPOSE-WINDOW-NEAR WINDOW NEAR-MODE)
    (WHEN INITIAL-MESSAGE
      (SEND WINDOW :TYPEIN-LINE INITIAL-MESSAGE))
    (TV:WINDOW-CALL (WINDOW :DEACTIVATE)
      (TV:WINDOW-CALL-RELATIVE (WINDOW)
	(*CATCH 'ABORT-STANDALONE-EDIT
	  (SEND WINDOW :EDIT)
	  (SEND WINDOW :INTERVAL-STRING))))))
