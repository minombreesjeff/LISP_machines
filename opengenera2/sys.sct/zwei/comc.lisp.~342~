;;; Zwei compiler commands -*- Syntax: Zetalisp; Base: 8;Mode: LISP; Package: ZWEI-*-
;;;  see ZWEI;COMA for comments 

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(DEFCOM COM-EVALUATE-MINIBUFFER "Evaluates forms from the minibuffer.
You enter Lisp forms in the minibuffer, which are evaluated when you press
END.  The result of the evaluation appears in the echo area if it is short or
as a typeout window.  " (KM)
  (EVALUATE-MINI-BUFFER))

(DEFUN PARSE-SEQUENCE-UNTIL-END (STREAM TYPE)
  (ZCOLLECTING-INTO (VALUES TYPES)
    (LOOP NAMED TOP
	  FOR PROVIDE-DEFAULT = T THEN NIL
	  DOING
      (MULTIPLE-VALUE-BIND (VAL TYP)
	  (SCL:ACCEPT TYPE :STREAM STREAM :PROMPT NIL
			   :PROVIDE-DEFAULT PROVIDE-DEFAULT :DISPLAY-DEFAULT NIL)
	(ZCOLLECT VALUES VAL)
	(ZCOLLECT TYPES TYP))
      (LOOP DO
	(DW:WITH-PRESENTATION-INPUT-CONTEXT (TYPE :STREAM STREAM) (BLIP)
	     (LET ((CH (DW:PEEK-CHAR-FOR-ACCEPT STREAM)))
	       (IF (NOT (CL:MEMBER CH SI:*WHITESPACE* :TEST #'DW:COMPARE-CHAR-FOR-ACCEPT))
		   (DW::PRESENTATION-REPLACE-INPUT STREAM
						   (SEND STREAM :READ-LOCATION)
						   "
" :DONT-QUOTE T)
		   (DW:READ-CHAR-FOR-ACCEPT STREAM)
		   (SETQ CH NIL))
	       (WHEN (NULL CH)
		 (SETQ CH (DW:PEEK-CHAR-FOR-ACCEPT STREAM T)))
	       (IF (DW:COMPARE-CHAR-FOR-ACCEPT CH #\End)
		   (RETURN-FROM TOP)
		   (RETURN)))
	   (T
	    (DW:ECHO-PRESENTATION-BLIP STREAM BLIP)
	    (DW::PRESENTATION-REPLACE-INPUT STREAM
					    (SEND STREAM :READ-LOCATION)
					    "
" :DONT-QUOTE T)
	    (ZCOLLECT VALUES (DW:PRESENTATION-BLIP-OBJECT BLIP))
	    (ZCOLLECT TYPES (DW:PRESENTATION-BLIP-PRESENTATION-TYPE BLIP))))))
    (VALUES VALUES TYPES)))

(SCL:DEFINE-PRESENTATION-TYPE FORMS-UNTIL-END ()
   :ABBREVIATION-FOR '((CL:SEQUENCE SYS:FORM))
   :HISTORY T

   :PARSER ((STREAM)
	    (PARSE-SEQUENCE-UNTIL-END STREAM 'SYS:FORM))
   :PRINTER ((FORMS STREAM)
	     (DOLIST (FORM FORMS)
	       (SCL:PRESENT FORM 'SYS:FORM :STREAM STREAM))))

(DEFUN EVALUATE-MINI-BUFFER (&OPTIONAL INITIAL-CONTENTS INITIAL-CHAR-POS)
  (DOLIST (FORM (TYPEIN-LINE-ACCEPT 'FORMS-UNTIL-END :PROMPT "Forms to evaluate"
				    :INITIAL-INPUT INITIAL-CONTENTS
				    :INITIAL-POSITION INITIAL-CHAR-POS))
    (TYPEIN-LINE-EVAL-FORM FORM))
  ;; DIS-TEXT in case user manually alters the buffer with Lisp code
  DIS-TEXT)

(DEFUN TYPEIN-LINE-EVAL-FORM (FORM)
  (DO ((VALS (LET ((STANDARD-OUTPUT *TYPEOUT-WINDOW*)
		   (STANDARD-INPUT *TYPEOUT-WINDOW*))
	       (MULTIPLE-VALUE-LIST (EVAL FORM)))
	     (CDR VALS))
       (FLAG T NIL))
      ((NULL VALS))
    (FUNCALL (IF FLAG #'TYPEIN-LINE #'TYPEIN-LINE-MORE)
	     "~:[, ~]~S" FLAG (CAR VALS))))

;; Actually, SYS:FORM is a special case of this.  Fix that up someday.
(scl:define-presentation-type sys:code-fragment ()
  :expander `sys:form
  :description "a code fragment")

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR TYPEIN-LINE-EVALUATE-FORM
   (SYS:CODE-FRAGMENT "Evaluate"
    *STANDARD-COMTAB*
    :TESTER ((CODE &REST IGNORE)
	     (TYPECASE CODE
	       (:SYMBOL
		 (BOUNDP CODE))
	       (:LIST
		 (AND
		   (SYS:VALIDATE-FUNCTION-SPEC
		     (FIRST CODE))
		   (FDEFINEDP (FIRST CODE))))))
    :GESTURE :EVALUATE-FORM)
   (CODE-FRAGMENT)
  `(TYPEIN-LINE-EVAL-FORM ,CODE-FRAGMENT))

(DEFCOM COM-EVALUATE-INTO-BUFFER
	"Evaluates Lisp forms and inserts the results into the buffer.
If there is a region, the forms come from that region.
Otherwise you enter them in the minibuffer.
The result of each evaluation appears in the buffer before point.
With a numeric argument, it also inserts any typeout that occurs during the
evaluation into the buffer.  " ()
  (MULTIPLE-VALUE-BIND (FORMS BPS)
      (IF (WINDOW-REGION-P)
	  (LET ((STREAM (REGION-BPS (BP1 BP2) (OPEN-INTERVAL-STREAM BP1 BP2 T))))
	    (LOOP AS FORM = (CONDITION-CASE (ERROR)
				 (READ STREAM)
			       (SYS:READ-ERROR
				 (WHEN (AND (TYPEP ERROR 'SYS:END-OF-FILE)
					    (NOT (OR (TYPEP ERROR
							    'SYS:READ-LIST-END-OF-FILE)
						     (TYPEP ERROR
							    'SYS:READ-STRING-END-OF-FILE))))
				   (SI:LOOP-FINISH))
				 (BARF "~A" ERROR)))
		  COLLECT FORM INTO FORMS
		  COLLECT (SEND STREAM :READ-BP) INTO BPS
		  FINALLY (RETURN (VALUES FORMS BPS))))
	  (VALUES (TYPEIN-LINE-ACCEPT 'FORMS-UNTIL-END
				      :PROMPT "Lisp form(s) to evaluate")))
    (LET ((OUTPUT-STREAM (OPEN-INTERVAL-STREAM (POINT) (POINT) T
					       :FLAVOR
					       'PRESENTATION-RECORDING-INTERVAL-STREAM))
	  (OLD-POINT (COPY-BP (POINT) :NORMAL)))
      (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
	(WITH-CUSTOM-UNDO-SAVE (OLD-POINT OLD-POINT
				(MAKE-INSERT-RECORD OLD-POINT (COPY-BP OLD-POINT ':MOVES)))
	  (SCL:WITH-CHARACTER-STYLE ((SI:INDEX-CHARACTER-STYLE *STYLE*) OUTPUT-STREAM)
	    (POINT-PDL-PUSH (POINT) *WINDOW*)
	    (LOOP WITH FRESH-LINE-P = (OR *NUMERIC-ARG-P* BPS)
		  FOR FORM IN FORMS
		  AS BPS = BPS THEN (CDR BPS)
		  AS BP = (FIRST BPS)
		  WHEN BP DO (SEND OUTPUT-STREAM :SET-BP BP)
		  DO (DOLIST (RESULT (LET-IF *NUMERIC-ARG-P*
					     ((STANDARD-OUTPUT OUTPUT-STREAM))
				       (MULTIPLE-VALUE-LIST (EVAL FORM))))
		       (IF FRESH-LINE-P
			   (SEND OUTPUT-STREAM :FRESH-LINE)
			 (SETQ FRESH-LINE-P T))
		       (LET ((STANDARD-OUTPUT OUTPUT-STREAM))
			 (FUNCALL (OR PRIN1 #'PRIN1) RESULT)))
		     (MOVE-POINT (FUNCALL OUTPUT-STREAM :READ-BP)))))
	(CLOSE OUTPUT-STREAM))))
  DIS-TEXT)
 
(DEFCOM COM-EVALUATE-AND-REPLACE-INTO-BUFFER
	"Evaluates the next Lisp form and replaces the result into the buffer.
With a numeric argument, puts typeout from the form into the buffer also, and doesn't
delete the original form." (KM PUSH)
  (LET* ((POINT (POINT)) (MARK (MARK))
	 (STREAM (REST-OF-INTERVAL-STREAM POINT))
	 (STRING (AND *NUMERIC-ARG-P* (MAKE-ARRAY 100. :TYPE 'ART-STRING :FILL-POINTER 0)))
	 (FORM (BARF-ON-ERRORS (SYS:READ-ERROR)
		 (READ STREAM))))
    (SETQ FORM (IF STRING
		   (CL:WITH-OUTPUT-TO-STRING (STANDARD-OUTPUT STRING)
		     (EVAL FORM))
		   (EVAL FORM)))
    (MOVE-MARK (SEND STREAM ':READ-BP))
    (WITH-UNDO-SAVE-SIMPLE (POINT MARK T)
      (SEND STREAM ':SET-BP (IF STRING (INSERT MARK STRING) MARK))
      (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
	(SCL:WITH-CHARACTER-STYLE ((SI:INDEX-CHARACTER-STYLE *STYLE*) STREAM)
	  (PRIN1 FORM STREAM)))
      (WITH-BP (END (SEND STREAM ':READ-BP) ':NORMAL)
	(UNLESS *NUMERIC-ARG-P*
	  (DELETE-INTERVAL POINT MARK T))
	(MOVE-POINT END))
      (CLOSE STREAM)
      DIS-TEXT)))

(DEFCOM COM-COMPILE-REGION
	"Compiles the region, or if no region is defined, the current definition.
Includes source locators iff COMPILER:*INHIBIT-USING-SOURCE-LOCATORS* is NIL." ()
  (LET ((QUERY-IO *TYPEOUT-WINDOW*))
    (COMPILE-DEFINITION-INTERNAL T "Compiling" "compiled."))
  DIS-NONE)

(DEFCOM COM-COMPILE-REGION-TOGGLING-LOCATORS
	"Compiles the region, or if no region is defined, the current definition.
Toggles the state of COMPILER:*INHIBIT-USING-SOURCE-LOCATORS*." ()
  (LET ((COMPILER:*INHIBIT-USING-SOURCE-LOCATORS*
	  (NOT COMPILER:*INHIBIT-USING-SOURCE-LOCATORS*))
	(QUERY-IO *TYPEOUT-WINDOW*))
    (COMPILE-DEFINITION-INTERNAL T "Compiling" "compiled."))
  DIS-NONE)

(DEFCOM COM-EVALUATE-REGION
	"Evaluates the region, or if no region is defined, the current definition.
It shows the result in the echo area.  " ()
  (LET ((QUERY-IO *TYPEOUT-WINDOW*))
    (COMPILE-DEFINITION-INTERNAL  (GET-BUFFER-EVALUATOR *INTERVAL*)
				  "Evaluating"
				  "evaluated."
				  ':PROMPT))
  DIS-NONE)

(DEFCOM COM-EVALUATE-REGION-VERBOSE
	"Evaluates the region, or if no region is defined, the current definition.
It shows the result in a typeout window." ()
  (LET ((QUERY-IO *TYPEOUT-WINDOW*))
    (COMPILE-DEFINITION-INTERNAL  (GET-BUFFER-EVALUATOR *INTERVAL*)
				  "Evaluating"
				  "evaluated."
				  T))
  DIS-NONE)

(DEFCOM COM-EVALUATE-REGION-HACK
	"Evaluates the region, turning DEFVAR into SETQ.
If no region is defined, it evaluates the current definition.  It ensures that
any initializations are performed for variables appearing in DEFVAR forms.  It
shows the result in the echo area.  " ()
  (COMPILE-DEFINITION-INTERNAL  (GET-BUFFER-EVALUATOR *INTERVAL*)
			   "Evaluating"
			   "evaluated."
			   ':PROMPT T)
  DIS-NONE)

(DEFUN COMPILE-DEFINITION-INTERNAL (COMPILE-P MODE-NAME ECHO-NAME
				    &OPTIONAL USE-TYPEOUT DEFVAR-HACK
					      SPECIAL-COMPILER-FUNCTION)
  (DEFINITION-REGION-BPS (BP1 BP2 DEFINITION-NAME DEFVAR-HACK-1)
    (WITH-INTERVAL-READ-LOCKED (BP1 BP2 T)
      (WHEN (AND (NULL COMPILER:*INHIBIT-USING-SOURCE-LOCATORS*)
		 (LET* ((NODE (BP-NODE BP1))
			(COMPILE-TICK (SEND-IF-HANDLES NODE :COMPILE-TICK)))
		   (AND COMPILE-TICK (> (SEND NODE :TICK) COMPILE-TICK))))
	;;--- In lieu of the LBE, clear out all of the presentation-nodes for
	;;--- this interval if it has been modified since we last compiled it
	(CLEAR-ALL-INTERVAL-PRESENTATION-NODES BP1 BP2 T))
      (COMPILE-PRINT-INTERVAL BP1 BP2 T COMPILE-P
			      DEFINITION-NAME MODE-NAME ECHO-NAME USE-TYPEOUT
			      (OR DEFVAR-HACK DEFVAR-HACK-1)
			      SPECIAL-COMPILER-FUNCTION))))

(DEFUN GET-DEFINITION-NAME (BP &OPTIONAL PKG)
  (MULTIPLE-VALUE-BIND (FSPEC TYPE NIL ERROR-P)
      (GET-DEFINITION-FUNCTION-SPEC BP)
    (IF (OR ERROR-P
	    (IF (SYMBOLP FSPEC)			;Try to prevent typing garbage
		(EQ (SYMBOL-PACKAGE FSPEC) *UTILITY-PACKAGE*)
	      (NULL (GET TYPE 'SI:DEFINITION-TYPE-NAME))))
	"Definition"
      (LET-IF PKG ((PACKAGE PKG))
	(SECTION-DEFINITION-NAME FSPEC TYPE)))))

(DEFMETHOD (:DEFINITION-NAME FUNCTION-SPEC-OBJECT) ()
  (IF (EQ DEFINITION-TYPE 'HEADER)
      "Buffer header"
      (SECTION-DEFINITION-NAME FUNCTION-SPEC DEFINITION-TYPE)))

(DEFUN SECTION-DEFINITION-NAME (FSPEC TYPE)
  (LET ((CL:*PRINT-PRETTY* NIL))		;No carriage returns in the ~S
    (FORMAT NIL "~@[~A ~]~:[~S~;~A~]"
	    (SI:DEFINITION-TYPE-NAME TYPE)
	    (AND (SYMBOLP FSPEC)
		 (EQ (SYMBOL-PACKAGE FSPEC) *UTILITY-PACKAGE*))
	    FSPEC)))

;;--- All callers provide *INTERVAL* bound to the buffer [I didn't change that!]
(DEFUN COMPILE-PRINT-INTERVAL (BP1 BP2 IN-ORDER-P COMPILE-P
			       DEFINITION-NAME MODE-NAME ECHO-NAME
			       &OPTIONAL USE-TYPEOUT DEFVAR-HACK
					 SPECIAL-COMPILER-FUNCTION
			       &AUX FORMAT-FUNCTION)
  ;; If a node was passed in, remember that fact.
  ;; If two BPs were passed in, sort them.
  (WHEN BP2
    (GET-INTERVAL BP1 BP2 IN-ORDER-P)
    (SETQ IN-ORDER-P T))
  ;; Any kind of compile or evaluate ends a set of small changes
  (RECORD-ACCUMULATED-CHANGES-BP (IF BP2 BP1 (INTERVAL-FIRST-BP BP1)))
  (COND ((EQ USE-TYPEOUT ':TYPEOUT)
	 (FORMAT *TYPEOUT-WINDOW* "~&~A " MODE-NAME)
	 (IF (TYPEP BP1 'SECTION-NODE)
	     (DW:WITH-OUTPUT-AS-PRESENTATION (:STREAM *TYPEOUT-WINDOW*
					      :OBJECT (LIST BP1 *INTERVAL*) 
					      :TYPE 'SECTION)
	       (FORMAT *TYPEOUT-WINDOW* "~A" DEFINITION-NAME))
	     (FORMAT *TYPEOUT-WINDOW* "~A" DEFINITION-NAME)))
	(T
	 (SETQ FORMAT-FUNCTION (SELECTQ USE-TYPEOUT
				 (:PROMPT #'PROMPT-LINE)
				 (OTHERWISE #'TYPEIN-LINE)))
	 (FUNCALL FORMAT-FUNCTION "~&~A ~A" MODE-NAME DEFINITION-NAME)))
  (COMPILE-INTERVAL COMPILE-P (EQ USE-TYPEOUT T) DEFVAR-HACK BP1 BP2 IN-ORDER-P
		    SPECIAL-COMPILER-FUNCTION
		    (IF *NUMERIC-ARG-P* T))  ;do read followed by processing.
  (LET* ((POINT (IF BP2 BP1 (INTERVAL-FIRST-BP BP1)))	;misnomer...
	 (INTERVAL (SEND (SEND (BP-NODE POINT) :MAJOR-MODE)
			 ':DEFAULT-DEFINITION-REGION POINT T))
	 (IBP1 (AND INTERVAL (INTERVAL-FIRST-BP INTERVAL)))
	 (IBP2 (AND INTERVAL (INTERVAL-LAST-BP INTERVAL))))
    (WHEN (OR (NULL INTERVAL)
	      ;; Be very conservative...
	      (NULL IBP1) (NULL IBP2) (NULL BP1) (NULL BP2)
	      (NOT (AND (BP-< BP2 IBP2)
			(BP-< IBP1 BP1) (NOT (BP-= BP1 IBP1)))))
      ;; If the user marked a region which is fully contained in the current definition,
      ;; then don't update the compile-tick.  This lets a person modify a piece of code,
      ;; mark an expression inside that function, c-sh-E the marked expression, and
      ;; then expect Compile Changed Definitions to still work.
      (UPDATE-INTERVAL-COMPILE-TICK BP1 BP2 IN-ORDER-P)))
  (WHEN FORMAT-FUNCTION				;Unless it stays
    (FUNCALL FORMAT-FUNCTION "~&~A ~A" DEFINITION-NAME ECHO-NAME)))

;;; Attribute coming from -*- Eval: Foo -*-, apparently.
(DEFUN GET-BUFFER-EVALUATOR (BUFFER)
  (SEND BUFFER ':SEND-IF-HANDLES ':GET ':EVALUATOR))

(DEFCOM COM-EVALUATE-BUFFER "Evaluates the entire buffer.
With a numeric arg, it compiles from point to the end of the buffer.  " ()
  (COMPILE-BUFFER (GET-BUFFER-EVALUATOR *INTERVAL*) "Evaluating" "evaluated."))

(DEFCOM COM-COMPILE-BUFFER "Compiles the entire buffer.
With a numeric arg, it compiles from point to the end of the buffer.  " ()
  (COMPILE-BUFFER T "Compiling" "compiled."))

(DEFUN COMPILE-BUFFER (COMPILE-P MODE-NAME ECHO-NAME
		       &OPTIONAL SPECIAL-COMPILER-FUNCTION
		       &AUX BP1 BP2 NAME)
  (IF *NUMERIC-ARG-P*
      (SETQ BP1 (POINT)
	    BP2 (INTERVAL-LAST-BP *INTERVAL*) NAME "Rest of buffer")
    (SETQ BP1 *INTERVAL* NAME "Buffer"))
  (SI:INHIBIT-LENGTHY-BACKGROUND-UPDATES
    (WITH-INTERVAL-READ-LOCKED (BP1 BP2 T)
      (COMPILE-PRINT-INTERVAL BP1 BP2 T COMPILE-P NAME MODE-NAME ECHO-NAME
			      NIL		;USE-TYPEOUT
			      NIL		;DEFVAR-HACK
			      SPECIAL-COMPILER-FUNCTION)))
  DIS-NONE)

;;; COMPILE-P is T to call the compiler, in which case COMPILE-PROCESSING-MODE will
;;; be the compiler used.  Otherwise, COMPILE-P is NIL (meaning EVAL-PRINT) or a
;;; function.  That function is called on the forms read.  Note that in this case
;;; the forms are not sent through the compiler at all, so that a -*-Eval-*- property
;;; will not be screwed by calling the regular macroexpander.
(DEFUN COMPILE-INTERVAL (COMPILE-P *USE-TYPEOUT* SI:*REDO-DEFVARS-P*
			 BP1 &OPTIONAL BP2 IN-ORDER-P
			 SPECIAL-COMPILER-FUNCTION
			 (COMPILER:*READ-THEN-PROCESS-FLAG* COMPILER:*READ-THEN-PROCESS-FLAG*)
			 &AUX (STANDARD-OUTPUT *TYPEOUT-WINDOW*)
			 (STANDARD-INPUT *TYPEOUT-WINDOW*))
  (DECLARE (SPECIAL *USE-TYPEOUT*))
  (GET-INTERVAL BP1 BP2 IN-ORDER-P)
  (CHECK-INTERVAL-SECTIONS BP1 BP2 T)
  (LET* ((BUFFER (BP-BUFFER BP1))
	 (GENERIC-PATHNAME (LET ((PATHNAME (AND (FILE-BUFFER-P BUFFER)
						(SEND BUFFER :PATHNAME))))
			     (AND PATHNAME (SEND PATHNAME ':GENERIC-PATHNAME))))
	 (MAJOR-MODE (SEND BUFFER ':MAJOR-MODE))
	 (COMPILER-FUNCTION (OR SPECIAL-COMPILER-FUNCTION
				(SEND MAJOR-MODE ':COMPILER-FUNCTION)))
	 (ADDITIONAL-BINDINGS (LOOP WITH LIST = (SEND MAJOR-MODE ':ADDITIONAL-ATTRIBUTES)
				    FOR (INDICATOR VALUE)
					ON (SEND BUFFER ':SEND-IF-HANDLES ':PLIST) BY 'CDDR
				    WHEN (ASSQ INDICATOR LIST)
				      COLLECT INDICATOR AND COLLECT VALUE)))
    (COMPILE-INTERVAL-1 MAJOR-MODE COMPILE-P BUFFER GENERIC-PATHNAME COMPILER-FUNCTION
			ADDITIONAL-BINDINGS BP1 BP2 T)))

;;; Invoked by COMPILE-INTERVAL-1 method of a major mode to do the standard compilation thing.
(DEFUN DEFAULT-COMPILE-INTERVAL-1 (MAJOR-MODE COMPILE-P BUFFER GENERIC-PATHNAME
				   COMPILER-FUNCTION ADDITIONAL-BINDINGS
				   BP1 &OPTIONAL BP2 IN-ORDER-P)
  (DECLARE (IGNORE BUFFER IN-ORDER-P))
  (LET ((STREAM (OPEN-INTERVAL-STREAM BP1 BP2 T)))
    (MOVE-POINT-ON-READ-ERROR (STREAM)
      (IF (EQ COMPILE-P T)
	  (IF (SEND MAJOR-MODE ':COMPILATION-SUPPORTED)
	      ;; Any properties from the buffer for package and base should override
	      ;; those in the generic pathname.  COMPILE-FROM-STREAM does the bindings
	      (LET ((INHIBIT-FDEFINE-WARNINGS INHIBIT-FDEFINE-WARNINGS))
		(COMPILER:COMPILE-FROM-STREAM STREAM
					      GENERIC-PATHNAME
					      COMPILER-FUNCTION ADDITIONAL-BINDINGS))
	      ;; Otherwise, compilation is not supported, so give an error
	      (BARF "The major mode ~A does not support compilation"
		    (SEND MAJOR-MODE ':MAJOR-MODE-KEYWORD)))
	  ;; Else evaluation, if supported
	  (IF (SEND MAJOR-MODE ':EVALUATION-SUPPORTED)
	      ;; Bind all the variables required by the attribute list.
	      (MULTIPLE-VALUE-BIND (FVARS FVALS)
		  (FS:FILE-ATTRIBUTE-BINDINGS
		    GENERIC-PATHNAME :ADDITIONAL-ATTRIBUTES ADDITIONAL-BINDINGS)
		(STANDARD-VALUE-PROGV FVARS FVALS
		  (LET ((SYS:FDEFINE-FILE-PATHNAME GENERIC-PATHNAME)
			(SI:PATCH-SOURCE-FILE-PATHNAME NIL)
			(COMPILER:*COMPILE-FUNCTION* COMPILER-FUNCTION)
			(INHIBIT-FDEFINE-WARNINGS INHIBIT-FDEFINE-WARNINGS))
		    (COMPILER:PROCESS-FORMS-FROM-STREAM
		      STREAM
		      (OR COMPILE-P
			  (SEND MAJOR-MODE ':EVAL-PRINT-FUNCTION))))))
	      ;; Otherwise, evaluation is not supported, so give an error
	      (BARF "The major mode ~A does not support evaluation"
		    (SEND MAJOR-MODE ':MAJOR-MODE-KEYWORD)))))
    (CLOSE STREAM)))



(DEFUN EVAL-PRINT (OBJECT)
  (DECLARE (SPECIAL *USE-TYPEOUT*))
  (LET ((LIST (MULTIPLE-VALUE-LIST (EVAL OBJECT))))
    (DOLIST (VAL LIST)
      (IF *USE-TYPEOUT* (PRINT VAL)
	  (LET ((PRINLENGTH 5) (PRINLEVEL 2))
	    (TYPEIN-LINE "~S" VAL))))
    (VALUES (CAR LIST) OBJECT)))


(DEFUN MACRO-EXPAND-COMMAND (&REST OPTIONS)
  (LET ((SI:**BACKQUOTE-COUNT** 999999.))
    (WITH-UNDO-SAVE-IF *NUMERIC-ARG-P*
		       ("Insert macroexpanded form"
			(COPY-BP (POINT) :NORMAL) (FORWARD-SEXP (POINT) 1 T) T)
      (LET ((INTERVAL-STREAM (REST-OF-INTERVAL-STREAM (POINT))))
	(MOVE-POINT-ON-READ-ERROR (INTERVAL-STREAM)
	  (LET ((EXPANDED-FORM (LET ((FORM (READ INTERVAL-STREAM)))
				 (MACRO-EXPAND-COMMAND-CHECK-ENCAPSULATIONS
				   #'(LAMBDA (ENV)
				       (DECLARE (SYS:DOWNWARD-FUNCTION))
				       (LEXPR-FUNCALL #'SI:MEXP-EXPAND-FORM FORM ENV OPTIONS))
				   (POINT)))))
	    (LET-IF (SEND *INTERVAL* :GET :LOWERCASE) ((CL:*PRINT-CASE* :DOWNCASE))
	      (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
		(SCL:WITH-CHARACTER-STYLE ((SI:INDEX-CHARACTER-STYLE *STYLE*) INTERVAL-STREAM)
		  (LET ((STREAM (IF *NUMERIC-ARG-P* INTERVAL-STREAM STANDARD-OUTPUT)))
		    (CL:FRESH-LINE STREAM)
		    (LET ((CL:*PRINT-PRETTY* T))
		      (SCL:PRESENT EXPANDED-FORM 'SYS:FORM :STREAM STREAM))))))))
	(CLOSE INTERVAL-STREAM)
	(IF *NUMERIC-ARG-P* DIS-TEXT DIS-NONE)))))

(DEFVARIABLE *MACRO-EXPAND-COMMAND-CHECK-ENCAPSULATIONS* T
  ((SCL:ALIST-MEMBER :ALIST (("Yes" . T) ("No" . NIL) ("Query" . :QUERY)))
   :DESCRIPTION "a disposition")
   "Whether commands like Macro Expand Expression should search the
apparent lexical environment for containing MACROLET or COMPILER-LET
forms that might affect macro expansion.

Possible values for this variable are:

  D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")Yes0       Check the apparent lexical environment and automatically use any
	    local definitions found when doing macro expansion.

  1No0        Do not use (or even bother to check) the apparent lexical environment
	    when doing macro expansion.

  1Query0     Check the apparent lexical environment, but query before using any
	    non-null environment that results.")

(DEFVAR *MACRO-EXPAND-COMMAND-ENCAPSULATIONS*
	;; Moon made the following suggestions. I didn't have time to think
	;; them through fully enough to act on, but they sounded plausible and
	;; I wanted to log them.
	;;  - This list might also want to include CLOS:WITH-SLOTS and
	;;    CLOS:WITH-ACCESSORS.
	;;  - DEFMETHOD, DEFWHOPPER, DEFWHOPPER-SUBST, DEFUN-IN-FLAVOR,
	;;    and DEFSUBST-IN-FLAVOR all do expansion of DEFMACRO-IN-FLAVOR,
	;;    so those forms might want to be treated specially as well.
	;;    It won't work to just put them directly on this list--
	;;    some generalization of this list might be needed.
	;;  -kmp 12-Jan-90
	'(CL:MACROLET FUTURE-COMMON-LISP:MACROLET
	   FUTURE-COMMON-LISP:SYMBOL-MACROLET
	   CL:COMPILER-LET))

;; This is isn't really intended to accomodate things with differing semantics.
;; It's just so that adding lookalike symbols from other packages isn't a pain.
(DEFMACRO MACRO-EXPAND-COMMAND-HELPER (FUNCTION &ENVIRONMENT ENV)
  `',(FUNCALL FUNCTION ENV))

(DEFUN MACRO-EXPAND-COMMAND-CHECK-ENCAPSULATIONS (FUNCTION AT-BP)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (WHEN *MACRO-EXPAND-COMMAND-CHECK-ENCAPSULATIONS*
    (LET ((THINGS-SEEN '())
	  (FORM `(MACRO-EXPAND-COMMAND-HELPER ,FUNCTION)))
	(IGNORE-ERRORS
	  (LET* ((LOWER-BOUND (OR (FORWARD-DEFINITION AT-BP -1 NIL *INTERVAL*)
				  (INTERVAL-FIRST-BP *INTERVAL*)))
		 (UPPER-BOUND (OR (FORWARD-DEFINITION LOWER-BOUND 1 T *INTERVAL*)
				  (INTERVAL-LAST-BP *INTERVAL*))))
	    (WITH-INTERVAL-READ-LOCKED (LOWER-BOUND UPPER-BOUND T)
	      ;; Attempt to bound the interval to just the function, but use
	      ;; the entirety of *INTERVAL* if that won't work
	      (WITH-BOUNDED-INTERVAL (REGION-P LOWER-BOUND UPPER-BOUND)
		(LOOP FOR BP = AT-BP THEN (FORWARD-UP-LIST-OR-STRING BP -1)
		      DOING
		  (WHEN BP
		    (LET ((SYMBOL (SYMBOL-AT-PAREN BP)))
		      (WHEN (MEMQ SYMBOL *MACRO-EXPAND-COMMAND-ENCAPSULATIONS*)
			(LET ((DEFS (READ (REST-OF-INTERVAL-STREAM
					    (FORWARD-SEXP (FORWARD-CHAR BP))))))
			  (WHEN (LOOP FOR (NAME ARGS . BODY) IN DEFS
				      ALWAYS (AND (SYMBOLP NAME)
						  (CL:LISTP ARGS))
				      DO (IGNORE BODY))
			    (SETQ FORM `(,SYMBOL ,DEFS ,FORM))
			    (WHEN (EQ *MACRO-EXPAND-COMMAND-CHECK-ENCAPSULATIONS* :QUERY)
			      (SETQ THINGS-SEEN
				    (APPEND (LOOP FOR (NAME) IN DEFS COLLECT NAME)
					    THINGS-SEEN))))))))
		      UNTIL (OR (NULL BP) (BP-= BP LOWER-BOUND))))))
	  (WHEN (AND (NEQ (CAR FORM) 'MACRO-EXPAND-COMMAND-HELPER)
		     (OR (NEQ *MACRO-EXPAND-COMMAND-CHECK-ENCAPSULATIONS* :QUERY)
			 (CL:Y-OR-N-P "Use apparent local definition~P of ~{~S~^, ~}? "
				      (LENGTH THINGS-SEEN) THINGS-SEEN)))
	    (RETURN-FROM MACRO-EXPAND-COMMAND-CHECK-ENCAPSULATIONS
	      (EVAL FORM))))))
  ;; We get here if an error occurred above, or if there were no encapsulations.
  (FUNCALL FUNCTION NIL))

(DEFCOM COM-MACRO-EXPAND-EXPRESSION "Macro-expands the Lisp expression following Point.
Reads the Lisp expression following point, and expand the form itself but not
any of the subforms within it.  Types out the result on the typeout window.
With a numeric argument, pretty-prints the result back into the buffer immediately
after the expression." ()
  (MACRO-EXPAND-COMMAND :REPEAT T))

(DEFCOM COM-MACRO-EXPAND-EXPRESSION-ALL "Macro-expands the Lisp expression following Point.
Reads the Lisp expression following point, and expand all macros within it at all
levels.  Types out the result on the typeout window.  With a numeric argument,
pretty-prints the result back into the buffer immediately after the expression." ()
  (MACRO-EXPAND-COMMAND :ALL-LEVELS T))

(DEFCOM COM-COMPILER-OPTIMIZE-TOP-LEVEL-FORM "Macro-expands the Lisp expression following Point.
Reads the Lisp expression following point, and expand all macros within it at all
levels.  Types out the result on the typeout window.  With a numeric argument,
pretty-prints the result back into the buffer immediately after the expression." ()
  (MACRO-EXPAND-COMMAND :COMPILE T :DO-COMPILE-ONLY-OPTIMIZERS T))

(DEFCOM COM-SHOW-EFFECT-OF-DEFINITION
  "Show what the effect of evaluating the current definition, or the region, would be.
For certain types of definitions, if it is already defined this command shows
what the effect of killing the definition would be." ()
  (SHOW-EFFECT-OF-DEFINITION (SEND *INTERVAL* :MAJOR-MODE))	;language-dependent command
  DIS-NONE)



;;;---Temporarily put here to satisfy a caller.  Fix later.  ZOPEN
;;;---probably belongs before the general commands.

;; Analogous to WITH-OPEN-FILE, takes keywords like OPEN-EDITOR-STREAM

(DEFMACRO WITH-EDITOR-STREAM ((STREAM &REST KEYWORD-OPTIONS
				      &KEY
				      INTERVAL-STREAM-FLAVOR
				      NO-REDISPLAY
				      SET-POINT
				      &ALLOW-OTHER-KEYS)
			      &BODY BODY)
  (DECLARE (ARGLIST (STREAM &KEY (CREATE-P :WARN) (START :END) (DEFAULTS NIL)
			    (LOAD-P NIL) (KILL NIL) (END NIL) (ORDERED-P NIL)
			    (BUFFER-NAME NIL) (INTERVAL NIL) (WINDOW NIL) (PATHNAME NIL)
			    (BUFFER-MAJOR-MODE NIL) NO-REDISPLAY SET-POINT
			    INTERVAL-STREAM-FLAVOR) &BODY BODY))
  (LET ((START-BP (SYS:GENSYMBOL "WITH-EDITOR-STREAM-START-BP"))
	(END-BP (SYS:GENSYMBOL "WITH-EDITOR-STREAM-END-BP")))
    `(MULTIPLE-VALUE-BIND (,START-BP ,END-BP)
	 (SETUP-OPEN-EDITOR-STREAM ,@KEYWORD-OPTIONS)
       (USING-RESOURCE (,STREAM INTERVAL-STREAMS ,START-BP ,END-BP 'T
			,@(WHEN INTERVAL-STREAM-FLAVOR `((:FLAVOR ,INTERVAL-STREAM-FLAVOR))))
	 (SEND ,STREAM :SET-BP ,START-BP)
	 (MULTIPLE-VALUE-PROG1
	   (PROGN . ,BODY)
	   (WHEN ,SET-POINT
	     (LOOP FOR NODE FIRST (LINE-NODE (BP-LINE (SEND ,STREAM :READ-BP)))
			    THEN (NODE-SUPERIOR NODE)
		   WHILE (NODE-SUPERIOR NODE)
		   FINALLY
		     (WHEN (AND (VARIABLE-BOUNDP *WINDOW*)
				(EQ NODE (WINDOW-INTERVAL *WINDOW*)))
		       (MOVE-POINT (SEND ,STREAM :READ-BP)))
		     (MOVE-BP (SEND NODE :SAVED-POINT) (SEND ,STREAM :READ-BP))))
	   (UNLESS ,NO-REDISPLAY (SEND ,STREAM ':FORCE-REDISPLAY)))))))

;;; Utility to expand one piece of a DEFSYSTEM short form

(defconst *defsystem-symbols* '(sct:defsystem sct:defsubsystem))
(defconst *sct-module-identifiers* '(:serial :serial-definitions :parallel
				     :module-group))

(defcom com-expand-defsystem-short-form
	"With the cursor sitting inside of a short form of a DEFSYSTEM, expand the short
form into a long form, commenting out the original short form and grinding the
resulting long form into the buffer after it." (km)
  (let ((interval (definition-interval (point))))
    (unless interval
      (barf "The DEFSYSTEM form is ill-formed"))
    (check-interval-sections interval)
    (let ((node (bp-node (point))))
      (unless (memq (send node :definition-type) *defsystem-symbols*)
	(barf "Point is not inside of a DEFSYSTEM form"))
      (loop with defsys = (with-editor-stream (s :start (interval-first-bp interval)
						 :end (interval-last-bp interval))
			    (condition-case ()
				 (read s)
			       (error (barf "The DEFSYSTEM form is ill-formed"))))
	    with names = (loop for phrase in (cdddr defsys)
			       when (and (memq (car phrase) '(:module :module-group))
					 (cadr phrase))
				 collect (cadr phrase))
	    with first-bp = nil
	    with first-phrase = nil
	    with current-bp = (point)
	    as upper-bp = (forward-up-list-or-string current-bp -1)
	    as phrase = (when (char-equal (bp-char current-bp) #/()
			  (condition-case ()
			       (read-from-string (bp-line current-bp) nil
						 (+ 1 (bp-index current-bp)))
			     (error nil)))
	    as current-phrase = (when (memq phrase *sct-module-identifiers*)
				  phrase)
	    until (memq phrase *defsystem-symbols*)
	    do (unless current-bp
		 ;; We passed from point to the top level without seeing the DEFSYSTEM.
		 ;;--- Should think of a better way to state the error
		 (barf "The DEFSYSTEM form is ill-formed"))
	       (when current-phrase
		 (setq first-bp current-bp))
	       (setq first-phrase current-phrase)
	       (setq current-bp upper-bp)
	    finally
	      (unless first-phrase
		(barf "Point is not inside a short form phrase, beginning with :SERIAL, ~
		       :SERIAL-DEFINITIONS, :PARALLEL, or :MODULE-GROUP"))
	      (let* ((last-bp-in-form (forward-sexp first-bp 1))
		     (form (with-editor-stream (s :start first-bp
						  :end last-bp-in-form)
			     (condition-case ()
				  (read s nil)
				(error nil)))))
		(unless (and form (listp form)
			     (memq (car form) *sct-module-identifiers*))
		  (barf "The short form phrase is ill-formed"))
		(with-undo-save ("Expand DEFSYSTEM short form"
				 (interval-first-bp interval) (interval-last-bp interval) t)
		  (let* ((start-of-keyword (+ 2 (bp-index first-bp)))
			 (line (bp-line first-bp))
			 (array-bound (fill-pointer line))
			 (lowercase (and (> array-bound start-of-keyword)
					 (lower-case-p (aref line start-of-keyword))))
			 (si:*princase* (if lowercase :downcase :upcase)))
		    (let sct:((*named-modules* nil)
			      (*module-count* 0)
			      (*module-creation-options* nil)
			      (*new-modules* nil))
		      (multiple-value-bind (expansion changes)
			  (condition-case (e)
			       (sct:expand-short-form (cdddr defsys) form)
			     (error (barf "Error in expansion of short form: ~A"
					  (with-output-to-string (s)
					    (send e :report s)))))
			;; Add the dependencies that derive from the expansion
			(loop for phrase in (cdddr defsys)
			      ;; Initially, bp is at the end of the first top-level thing,
			      ;; then at the end of each subsequent top-level thing
			      for first-bp = (forward-sexp
					       (forward-char (interval-first-bp interval))
					       4)
					   then (forward-sexp first-bp 1)
			      as name = (when (memq (car phrase) '(:module :module-group))
					  (cadr phrase))
			      as name-changes = (assq name changes)
			      do (when name-changes
				   (let ((end-bp (forward-char first-bp -1)))
				     (with-editor-stream (s :start end-bp)
				       (let ((start (send s :read-bp)))
					 (loop for change in (cdr name-changes)
					       do (format s "~%~S" change)
					       finally
						 (let ((end (send s :read-bp)))
						   (indent-interval-for-lisp start end t))))))))
			;; Grind the form into the buffer, then indent it properly
			(with-editor-stream (s :start (forward-sexp first-bp 1))
			  (format s "~%")
			  (let ((start (send s :read-bp))
				(indentation (bp-index first-bp)))
			    indentation
			    (with-node-write-locked ((bp-node-to-lock first-bp))
			      (scl:with-character-style ((si:index-character-style *style*) s)
				(loop for phrase in expansion
				      ;;--- Maximum width s/b (max 10. (- 80. indentation))
				      do (unless (memq (cadr phrase) names)
					   (cl:pprint phrase s)))
				(let ((end (send s :read-bp)))
				  (indent-interval-for-lisp start end t))))))
			;; Now comment out the first form
			(unless (eq first-phrase :module-group)
			  (let ((start first-bp)
				(end last-bp-in-form))
			    (loop with comment-begin = (in-current-style *comment-begin*)
				  with comment-end = (in-current-style *comment-end*)
				  while (bp-< start end)
				  do (insert (beg-line start) comment-begin)
				     (insert (end-line start) comment-end)
				     (setq start (forward-line start)))))))))))))
  dis-text)

(COMMENT  ;; The new source locators completely subsume these

;Given a function (a symbol!), return the correspondence between
;its sublists and symbols and positions in the buffer which holds the text for it.
;Should handle functions which are not symbols.
;; The caller should set up a catch for TRANSFER-CORRESPONDENCE-LOSSAGE
;; in case the function text and expr definition don't actually match.
(DEFUN FUNCTION-CORRESPONDENCE (FUNCTION-SPEC &OPTIONAL DEFINITION-TYPES)
  (SEND *ZMACS-COMMAND-LOOP* ':SETUP-FUNCTION-SPECS-TO-EDIT
	(LIST FUNCTION-SPEC) DEFINITION-TYPES NIL)
  (MULTIPLE-VALUE-BIND (BP BUFFER)
      (SEND *ZMACS-DEFINITIONS-BUFFER* ':NEXT-DEFINITION)
    (LET* ((LINE (CAR BP))
	   (INT (DEFINITION-INTERVAL (CREATE-BP LINE 0) 1 NIL NIL))
	   (DEFINITION (SI:UNDIGEST (FDEFINITION
				      (SI:UNENCAPSULATE-FUNCTION-SPEC FUNCTION-SPEC))))
	   NEWSEXP TEM
	   (CORRESPONDENCE (SI:FUNCTION-SPEC-GET FUNCTION-SPEC 'ZMACS-CORRESPONDENCE)))
      (COND ((OR (NULL CORRESPONDENCE)
		 (NEQ (CAR CORRESPONDENCE) DEFINITION)
		 (> (INTERVAL-REAL-TICK INT) (CADDR CORRESPONDENCE)))
	     ;; Read in the text.  Get a new sexp for the function,
	     ;; together with a correspondence between it and the text.
	     (MULTIPLE-VALUE (NEWSEXP CORRESPONDENCE)
	       (ESTABLISH-CORRESPONDENCE DEFINITION BUFFER INT))
	     (SETQ TEM (MEMQ NEWSEXP CORRESPONDENCE))
	     (AND TEM (RPLACA TEM DEFINITION))
	     (SETQ NEWSEXP (CDDR NEWSEXP));Flush DEFUN or DEFMETHOD, and fn name.
	     (SELECTQ (CAR DEFINITION)	  ;Flush LAMBDA, or NAMED-LAMBDA and name.
	       (LAMBDA (SETQ DEFINITION (CDR DEFINITION)))
	       (NAMED-LAMBDA (SETQ DEFINITION (CDDR DEFINITION))))
	     ;; Now the new sexp should look like the definition.
	     ;; Move the correspondence to the definition.
	     (TRANSFER-CORRESPONDENCE FUNCTION-SPEC CORRESPONDENCE NEWSEXP DEFINITION)
	     (SI:FUNCTION-SPEC-PUTPROP FUNCTION-SPEC CORRESPONDENCE 'ZMACS-CORRESPONDENCE)))
      CORRESPONDENCE)))

(DEFUN ESTABLISH-CORRESPONDENCE (DEFINITION BUFFER BP1 &OPTIONAL BP2 IN-ORDER-P)
  (GET-INTERVAL BP1 BP2 IN-ORDER-P)
  (LET ((STREAM (OPEN-INTERVAL-STREAM BP1 BP2 T))
	(SI:XR-CORRESPONDENCE-FLAG T)
	SI:XR-CORRESPONDENCE)
    (VALUES (READ STREAM)
	    `(,DEFINITION ,BUFFER ,(NODE-TICK BUFFER)
	      ,BP1 ,BP2 . ,SI:XR-CORRESPONDENCE))))

;; Given a correspondence from the sexp TEMPDEF, matches up TEMPDEF
;; and REALDEF and clobbers the correspondence to be from REALDEF instead.
;; FUNCTION is just for error messages.  
;; We throw to TRANSFER-CORRESPONDENCE-LOSSAGE if the two sexps don't match.
(DEFUN TRANSFER-CORRESPONDENCE (FUNCTION CORRESPONDENCE TEMPDEF REALDEF)
  (LET ((TEM (MEMQ TEMPDEF CORRESPONDENCE)))
    (AND TEM (RPLACA TEM REALDEF)))
  ;; In the real definition, some displacing macros may have gone off.
  (AND (EQ (CAR REALDEF) 'SI:DISPLACED)
       (SETQ REALDEF (CADR REALDEF)))
  (OR (= (LENGTH TEMPDEF) (LENGTH REALDEF))
      (*THROW 'TRANSFER-CORRESPONDENCE-LOSSAGE NIL))
  (DO ((TD TEMPDEF (CDR TD))
       (RD REALDEF (CDR RD)))
      ((NULL TD))
    (AND (COND ((ATOM (CAR TD)) (NEQ (CAR TD) (CAR RD)))
	       (T (ATOM (CAR RD))))
	 (*THROW 'TRANSFER-CORRESPONDENCE-LOSSAGE NIL))
    (OR (ATOM (CAR TD))
	(TRANSFER-CORRESPONDENCE FUNCTION CORRESPONDENCE (CAR TD) (CAR RD)))))

) ;comment


;When's the latest any line between BP1 and BP2 was modified?
(DEFUN INTERVAL-REAL-TICK (BP1 &OPTIONAL BP2 IN-ORDER-P)
  (GET-INTERVAL BP1 BP2 IN-ORDER-P)
  (DO ((LINE (BP-LINE BP1) (LINE-NEXT-IN-BUFFER LINE))
       (END-LINE (BP-LINE BP2))
       (MAX-TICK 0))
      (NIL)
    (SETQ MAX-TICK (MAX MAX-TICK (LINE-TICK LINE)))
    (AND (EQ LINE END-LINE)
	 (RETURN MAX-TICK))))

;;; These functions know about zmacs buffers and nodes
(DEFUN UPDATE-INTERVAL-COMPILE-TICK (BP1 &OPTIONAL BP2 IN-ORDER-P)
  (TICK)
  (COND ((AND (NULL BP2)
	      (TYPEP BP1 'SECTION-NODE))
	 ;; A node was passed in, so just update its tick directly
	 ;; If the node is empty, BP-NODE of INTERVAL-FIRST-BP is not the identity function
	 (SETF (SECTION-NODE-COMPILE-TICK BP1) *TICK*))
	(T
	 ;; Two BPs were passed in, update all nodes that intersect the specified interval
	 (GET-INTERVAL BP1 BP2 IN-ORDER-P)
	 (UNLESS (BP-= BP1 BP2)			;Don't get tricked by an empty interval
	   (LOOP WITH NODE = (BP-NODE BP1)
		 DO (WHEN (TYPEP NODE 'SECTION-NODE)
		      (SETF (SECTION-NODE-COMPILE-TICK NODE) *TICK*))
		    (SETQ NODE (NODE-NEXT NODE))
		 UNTIL (OR (NULL NODE)
			   (NOT (BP-< (INTERVAL-FIRST-BP NODE) BP2))))))))
			;Note that BP-< must not be done on the first node, since
			;it is both known to be true and potentially very slow
			;if the node is the whole buffer (an unsectioned buffer)

(DEFCOM COM-COMPILE-CHANGED-DEFINITIONS-OF-BUFFER
	"Compiles any definitions in the current buffer that have been changed.
With a numeric argument, it prompts individually about whether to
compile particular changed definitions.  " ()
  (COMPILER:COMPILER-WARNINGS-CONTEXT-BIND
    (SEND (SEND *INTERVAL* ':GET ':MAJOR-MODE)
	  ':COMPILE-BUFFER-CHANGED-DEFINITIONS *INTERVAL* *NUMERIC-ARG-P*))
  (FORMAT T "~&Done.~%")
  DIS-NONE)

(DEFCOM COM-COMPILE-CHANGED-DEFINITIONS
	"Compiles any definitions that have changed in any of the current buffers.
With a numeric argument, it prompts individually about whether to compile
particular changed definitions.  " ()
  (COMPILER:COMPILER-WARNINGS-CONTEXT-BIND
    (DOLIST (BUFFER *ZMACS-BUFFER-LIST*)
      (AND (SEND (SEND BUFFER ':GET ':MAJOR-MODE) ':COMPILATION-SUPPORTED)
	   (NOT (SEND BUFFER ':GET ':PATCH-FILE))
	   (SEND (SEND BUFFER ':GET ':MAJOR-MODE)
		 ':COMPILE-BUFFER-CHANGED-DEFINITIONS BUFFER *NUMERIC-ARG-P*))))
  (FORMAT T "~&Done.~%")
  DIS-NONE)

(DEFCOM COM-COMPILE-CHANGED-DEFINITIONS-OF-TAG-TABLE
	"Compiles any definitions that have changed in any of the buffers
in the current Tags Table. With a numeric argument, it prompts individually about whether
to compile particular changed definitions." ()
  (COMPILER:COMPILER-WARNINGS-CONTEXT-BIND
    (LET ((T-BUFFER (SELECT-TAG-TABLE NIL)))
      (SEND T-BUFFER :RESTART)
      (LOOP AS BUFFER = (SEND T-BUFFER :NEXT-FILE NIL NIL T)
	    DO
	(WHEN (AND (SEND (SEND BUFFER :GET ':MAJOR-MODE) :COMPILATION-SUPPORTED)
		   (NOT (SEND BUFFER :GET ':PATCH-FILE)))
	  (SEND (SEND BUFFER :GET ':MAJOR-MODE)
		':COMPILE-BUFFER-CHANGED-DEFINITIONS BUFFER *NUMERIC-ARG-P*))))))

(DEFCOM COM-EVALUATE-CHANGED-DEFINITIONS-OF-BUFFER
	"Evaluates any definitions in the current buffer that have been changed.
With a numeric argument, it prompts individually about whether to evaluate
particular changed definitions.  " ()
  (SEND (SEND *INTERVAL* ':GET ':MAJOR-MODE)
	':COMPILE-BUFFER-CHANGED-DEFINITIONS *INTERVAL* *NUMERIC-ARG-P* NIL
	'("Evaluate" "Evaluating" "evaluated."))
  (FORMAT T "~&Done.~%")
  DIS-NONE)

(DEFCOM COM-EVALUATE-CHANGED-DEFINITIONS
	"Evaluates any definitions that have changed in any of the current buffers.
With a numeric argument, it prompts individually about whether to evaluate
particular changed definitions.  " ()
  (DOLIST (BUFFER *ZMACS-BUFFER-LIST*)
    (AND (SEND (SEND BUFFER ':GET ':MAJOR-MODE) ':EVALUATION-SUPPORTED)
	 (NOT (SEND BUFFER ':GET ':PATCH-FILE))
	 (SEND (SEND BUFFER ':GET ':MAJOR-MODE)
	       ':COMPILE-BUFFER-CHANGED-DEFINITIONS BUFFER *NUMERIC-ARG-P*
	       NIL '("Evaluate" "Evaluating" "evaluated.") )))
  (FORMAT T "~&Done.~%")
  DIS-NONE)

(DEFVAR *CHANGED-DEFINITIONS-REDO-DEFVARS* T)

(DEFMETHOD (:COMPILE-BUFFER-CHANGED-DEFINITIONS MAJOR-MODE :DEFAULT)
	   (*INTERVAL* ASK-P &OPTIONAL (COMPILE-P T)
		       (NAMES '("Compile" "Compiling" "compiled."))
		       &AUX (QUERY-IO *TYPEOUT-WINDOW*))
  (CHECK-INTERVAL-SECTIONS *INTERVAL*)
  (DOLIST (SECTION (BUFFER-SECTIONS *INTERVAL*))
    (AND (TYPEP SECTION 'SECTION-NODE)
	 (NEQ (SEND SECTION ':DEFINITION-TYPE) 'ZWEI:HEADER)
	 (> (NODE-TICK SECTION) (SECTION-NODE-COMPILE-TICK SECTION))
	 (LET ((NAME (SEND SECTION ':DEFINITION-NAME)))
	   (AND (OR (NOT ASK-P)
		    (FQUERY '(:SELECT T) "~A ~A? " (FIRST NAMES) NAME))
		(COMPILE-PRINT-INTERVAL SECTION NIL T COMPILE-P NAME
					(SECOND NAMES) (THIRD NAMES)
					':TYPEOUT *CHANGED-DEFINITIONS-REDO-DEFVARS*))))))

(COMMENT	;Not needed any more I think
(DEFUN GET-SECTION-NODE-NAME (SECTION-NODE &AUX DEFINITION-LINE)
  (IF (SETQ DEFINITION-LINE (SECTION-NODE-DEFINITION-LINE SECTION-NODE))
      (GET-DEFINITION-FUNCTION-SPEC (CREATE-BP DEFINITION-LINE 0))
      (SECTION-NODE-FUNCTION-SPEC SECTION-NODE)))
)

(DEFCOM COM-LIST-CHANGED-DEFINITIONS 
	"Displays a list of any definitions that have been edited in any buffer.  
Use c-. (Next Possibility) to start editing the definitions in the list.
Arg = 1 means list definitions changed since the file was last saved (this is the default).
Arg = 2 means list definitions changed since the file was last read.
Arg = 3 means list definitions changed since the definition was last compiled." ()
  (EDIT-CHANGED-DEFINITIONS-INTERNAL NIL :LIST-POSSIBILITIES))

(DEFCOM COM-EDIT-CHANGED-DEFINITIONS
	"Determines which definitions in any buffer have changed and selects first one.
It makes an internal list of all the definitions that have changed in the
current session and selects the first one on the list.  Use c-. (Next Possibility)
to move to a subsequent definition.
Arg = 1 means edit definitions changed since the file was last saved (this is the default).
Arg = 2 means edit definitions changed since the file was last read.
Arg = 3 means edit definitions changed since the definition was last compiled." ()
  (EDIT-CHANGED-DEFINITIONS-INTERNAL NIL :START-EDITING))

(DEFCOM COM-LIST-CHANGED-DEFINITIONS-OF-BUFFER
	"Displays the names of definitions in the buffer that have changed.
It makes an internal list of the definitions changed since the buffer was read
in and offers to let you edit them.  Use c-. (Next Possibility) to move to
subsequent definitions.
Arg = 1 means list definitions changed since the file was last saved (this is the default).
Arg = 2 means list definitions changed since the file was last read.
Arg = 3 means list definitions changed since the definition was last compiled." ()
  (EDIT-CHANGED-DEFINITIONS-INTERNAL T :LIST-POSSIBILITIES))

(DEFCOM COM-EDIT-CHANGED-DEFINITIONS-OF-BUFFER
	"Determines which definitions in the buffer have changed and selects first one.
It makes an internal list of all the definitions that have changed since the
buffer was read in and selects the first one on the list.  Use c-. (Next
Possibility) to move to subsequent definitions.
Arg = 1 means edit definitions changed since the file was last saved (this is the default).
Arg = 2 means edit definitions changed since the file was last read.
Arg = 3 means edit definitions changed since the definition was last compiled." ()
  (EDIT-CHANGED-DEFINITIONS-INTERNAL T :START-EDITING))

(DEFUN EDIT-CHANGED-DEFINITIONS-INTERNAL (ONE-BUFFER-P ACTION)
  (PUSH-POSSIBILITIES-BUFFER ACTION :MODIFIED-SECTIONS
			     :SET-SINGLE-BUFFER (AND ONE-BUFFER-P *INTERVAL*)
			     :SET-CRITERION (SELECTQ *NUMERIC-ARG*
					       (1 :SAVE)
					       (2 :READ)
					       (3 :COMPILE)
					       (OTHERWISE :SAVE))))

(DEFCOM COM-LIST-DUPLICATE-DEFINITIONS
	"List the duplicate definitions in this buffer.
Useful for verifying a patch file." ()
  (PUSH-POSSIBILITIES-BUFFER ':LIST-POSSIBILITIES ':DUPLICATE-SECTIONS
			     ':SET-BUFFER *INTERVAL*))

(DEFCOM COM-COMPILE-DEFINITIONS-OF-BUFFER-CONTAINING-STRING
	"Compiles any definitions in the current buffer that contain a given search string.
With a numeric argument, it prompts individually about whether to
compile particular definitions with the string.  " ()
  (COMPILER:COMPILER-WARNINGS-CONTEXT-BIND
    (COMPILE-DEFINITIONS-CONTAINING-STRING *INTERVAL* *NUMERIC-ARG-P*))
  (FORMAT T "~&Done.~%")
  DIS-NONE)

(DEFUN COMPILE-DEFINITIONS-CONTAINING-STRING (*INTERVAL* ASK-P
					      &OPTIONAL (COMPILE-P T)
					      (NAMES '("Compile" "Compiling" "compiled."))
					      &AUX (QUERY-IO *TYPEOUT-WINDOW*))
  (CHECK-INTERVAL-SECTIONS *INTERVAL*)
  (MULTIPLE-VALUE-BIND (FUNCTION KEY)
      (GET-EXTENDED-STRING-SEARCH-STRINGS NIL "Compile definitions containing:"
					  *SEARCH-MINI-BUFFER-COMTAB*)
    (DOLIST (SECTION (BUFFER-SECTIONS *INTERVAL*))
      (WHEN (AND (TYPEP SECTION 'SECTION-NODE)
		 (NEQ (SEND SECTION :DEFINITION-TYPE) 'HEADER)
		 (FUNCALL FUNCTION (INTERVAL-FIRST-BP SECTION) KEY NIL
			  NIL NIL (INTERVAL-LAST-BP SECTION)))
	(LET ((NAME (SEND SECTION ':DEFINITION-NAME)))
	  (AND (OR (NOT ASK-P)
		   (FQUERY '(:SELECT T) "~A ~A? " (FIRST NAMES) NAME))
	       (COMPILE-PRINT-INTERVAL SECTION NIL T COMPILE-P NAME
				       (SECOND NAMES) (THIRD NAMES) ':TYPEOUT T)))))))

(DEFCOM COM-COMPILE-FILE
	"Compiles a file, offering to save first if it is the current buffer.
It prompts for a file name in the minibuffer, using the file associated
with the current buffer as the default.  It offers to save the file if
the buffer has been modified.
With a numeric argument, it prompts for the name of the compiled file as well." ()
  (MULTIPLE-VALUE-BIND (PATH MAJOR-MODE)
      (READ-MAJOR-MODE-DEFAULTED-PATHNAME "Compile File" (DEFAULT-PATHNAME)
					  :SPECIAL-VERSION :NEWEST)
    (WHEN (SEND PATH :WILD-P) (BARF "Wildcard pathnames not allowed."))
    (LET* ((OUT-PATH (AND *NUMERIC-ARG-P*
			  (ACCEPT-DEFAULTED-PATHNAME
			    (FORMAT NIL "Compile ~A into file" PATH) PATH
			    :SPECIAL-TYPE (SEND MAJOR-MODE :DEFAULT-COMPILER-OBJECT-FILE-TYPE)
			    :SPECIAL-VERSION :NEWEST :DIRECTION :WRITE)))
	   (BUFFER (FIND-BUFFER-NAMED PATH)))
      (PROG ()
	    (WHEN (AND BUFFER
		       (SEND BUFFER ':MODIFIED-P)
		       (FQUERY '(:SELECT T) "Save buffer ~A first? " (SEND BUFFER ':NAME)))
	      (OR (SAVE-BUFFER BUFFER)
		  (RETURN)))			;Saving failed, so quit early
	    (TYPEIN-LINE "Compiling ~A~@[ into ~A~] ... " PATH OUT-PATH)
	    (SI:INHIBIT-LENGTHY-BACKGROUND-UPDATES
	      (FUNCALL (SEND MAJOR-MODE ':COMPILE-TO-FILE-FUNCTION)
		       PATH OUT-PATH))
	    (TYPEIN-LINE-MORE "Done."))))
  DIS-NONE)

(DEFCOM COM-LOAD-FILE "Loads a file, possibly saving and compiling it first.
It prompts for a file name, taking the default from the current buffer.  " ()
  (LET* ((DEFAULT (DEFAULT-PATHNAME))
	 (PATHNAME (READ-UNDEFAULTED-PATHNAME "Load File" DEFAULT))
	 (PATH (OR (WHEN (SEND PATHNAME :WILD-P)
		     (BARF "Wildcard pathnames not allowed."))
		   (SEND (FS:MERGE-PATHNAMES PATHNAME DEFAULT NIL) :NEW-PATHNAME
			 :TYPE (SEND PATHNAME :TYPE)
			 :VERSION (SEND PATHNAME :VERSION))))
	 (MAJOR-MODE (FIND-DEFAULT-MAJOR-MODE-FROM-BUFFER ':LOAD))
	 (SOURCE (FS:MERGE-PATHNAMES PATH (SEND DEFAULT ':NEW-PATHNAME
						':TYPE
						(SEND MAJOR-MODE ':DEFAULT-SOURCE-FILE-TYPE)
						':VERSION ':NEWEST)))
	 (BUFFER (FIND-BUFFER-NAMED SOURCE))
	 (SAVE-BUFFER NIL)
	 (SAVING-FAILED NIL)
	 (COMPILE-FILE NIL)
	 (TEM NIL)
	 (TEM1 NIL)
	 (TICK COMPILER:NEW-COMPILER-WARNINGS-TICK))
    (AND BUFFER
	 (SEND BUFFER ':MODIFIED-P)
	 (FQUERY '(:SELECT T) "Save buffer ~A ? " (NAMED-BUFFER-NAME BUFFER))
	 (SETQ SAVE-BUFFER T))
    (COND (SAVE-BUFFER
	   (SETQ COMPILE-FILE (FQUERY '(:SELECT T) "After saving it, compile it? ")))
	  ((AND (LET ((TYPE (SEND PATH ':CANONICAL-TYPE)))
		  (OR (NULL TYPE)
		      (EQUAL TYPE (SEND MAJOR-MODE ':DEFAULT-COMPILER-OBJECT-FILE-TYPE))))
		(MULTIPLE-VALUE (TEM TEM1) (RECOMPILE-SOURCE-P PATH MAJOR-MODE)))
	   (SETQ SOURCE TEM
		 COMPILE-FILE (FQUERY '(:SELECT T)
				      (IF TEM1 "Compile ~A first? "
					  "~A has not been compiled before; compile it? ")
				      SOURCE))))
    (WHEN SAVE-BUFFER
      (OR (SAVE-BUFFER BUFFER)
	  (SETQ SAVING-FAILED T COMPILE-FILE NIL)))
    (SI:INHIBIT-LENGTHY-BACKGROUND-UPDATES
      (WHEN COMPILE-FILE
	(TYPEIN-LINE "Compiling ~A" SOURCE)
	(SETQ PATH (FUNCALL (SEND MAJOR-MODE ':COMPILE-TO-FILE-FUNCTION) SOURCE)))
      (WHEN (IF (OR SAVING-FAILED
		    ( TICK COMPILER:NEW-COMPILER-WARNINGS-TICK))	;There were warnings.
		(LET ((QUERY-IO *TYPEOUT-WINDOW*))
		  (FQUERY NIL "Do you still want to load ~A ? " PATH))
	      T)
	;; Send the "Loading foo" message to the typein window.
	;; This isn't exactly right.
	(LET ((STANDARD-OUTPUT *TYPEIN-WINDOW*))
	  (FUNCALL (SEND MAJOR-MODE ':LOAD-FILE-FUNCTION) PATH)
	  (TYPEIN-LINE "Done.")))))
  DIS-NONE)

;;; SOURCE is NIL if no compilation is required
;;; OBJECT is NIL if it has not been compiled before
(DEFUN RECOMPILE-SOURCE-P (FILE MAJOR-MODE)
  (DECLARE (VALUES SOURCE OBJECT))
  (LET* ((SOURCE (SEND FILE ':NEW-PATHNAME
		       ':CANONICAL-TYPE (SEND MAJOR-MODE ':DEFAULT-SOURCE-FILE-TYPE)
		       ':VERSION ':NEWEST))
	 (OBJECT (SEND FILE ':NEW-PATHNAME
		       ':CANONICAL-TYPE (SEND MAJOR-MODE ':DEFAULT-COMPILER-OBJECT-FILE-TYPE)
		       ':VERSION ':NEWEST))
	 (PLISTS (FS:MULTIPLE-FILE-PLISTS (LIST SOURCE OBJECT)))
	 (SOURCE-PLIST (ASSQ SOURCE PLISTS))
	 (OBJECT-PLIST (ASSQ OBJECT PLISTS)))
    (VALUES (AND (GET SOURCE-PLIST ':CREATION-DATE)
		 (OR (NULL (GET OBJECT-PLIST ':CREATION-DATE))
		     (> (GET SOURCE-PLIST ':CREATION-DATE)
			(GET OBJECT-PLIST ':CREATION-DATE)))
		 SOURCE)
	    (AND (GET OBJECT-PLIST ':CREATION-DATE)
		 OBJECT))))
