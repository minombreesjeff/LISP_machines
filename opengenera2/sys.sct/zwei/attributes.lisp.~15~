;;; -*- Mode: LISP; Syntax: Zetalisp; Package: ZWEI; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Attribute list stuff.

;; If something is equal to its default, don't write it into the attribute list
;; If it is in the attribute list, then splice it out
;; BASE and SYNTAX had better not appear in this list, since they affect the
;; reading of the file!

;; I would have moved this to defs, except that it is likely to disappear
;; soon. --BIM.

(DEFVAR *KNOWN-ATTRIBUTES-TO-SPLICE-OUT*
	'((:VSP . 2) (:TAB-WIDTH . 8)))

;;; Set the attributes of the generic pathname from the attributes
;;; associated with the buffer.  Used by Update Attribute List and c-X c-W.
(DEFUN SET-PATHNAME-ATTRIBUTES-FROM-BUFFER (G-P BUFFER)
  ;; Wipe all knowledge of attributes, so that absense of an attribute
  ;; is property reflected.  Can't set plist to NIL because other things
  ;; besides attribute-list attributes live there too.
  (DOLIST (PROP *MODE-LINE-PROPERTIES*)
    (SEND G-P ':REMPROP PROP))
  (SEND G-P ':PUTPROP (INTERN (PKG-NAME (SEND BUFFER ':GET ':PACKAGE)) SI:PKG-KEYWORD-PACKAGE)
	':PACKAGE)
  (SEND G-P ':PUTPROP (GET-MAJOR-MODE-ATTRIBUTE-FOR-PATHNAME (SEND BUFFER ':GET ':MAJOR-MODE))
	':MODE)
  ;; Ensure both buffer and generic pathname have correct Base and Syntax
  (MULTIPLE-VALUE-BIND (BSE SYNTAX)
      ;; allow FS:CANONICALIZE-BASE-AND-SYNTAX to use the current bindings
      ;; in the very unlikely case that the buffer lacks :BASE and :SYNTAX properties
      ;; since there in no way to tell at this point if the buffer had an attribute list
      ;; at all.
      (FS:CANONICALIZE-BASE-AND-SYNTAX (SEND BUFFER :GET :BASE)
				       (SEND BUFFER :GET :SYNTAX)
				       (SEND (SEND BUFFER ':GET ':MAJOR-MODE)
					     ':ADDITIONAL-ATTRIBUTES))
    (SEND BUFFER :PUTPROP BSE :BASE)
    (SEND BUFFER :PUTPROP SYNTAX :SYNTAX)
    (SEND G-P :PUTPROP BSE :BASE)
    (SEND G-P :PUTPROP SYNTAX :SYNTAX))
  (LET ((TW (SEND BUFFER ':GET ':TAB-WIDTH)))
    (IF (NOT (EQUAL TW (CDR (ASSQ ':TAB-WIDTH *KNOWN-ATTRIBUTES-TO-SPLICE-OUT*))))
	(SEND G-P ':PUTPROP TW ':TAB-WIDTH)))
  (LET ((V (SEND BUFFER ':GET ':VSP)))
    (IF (NOT (EQUAL V  (CDR (ASSQ ':VSP *KNOWN-ATTRIBUTES-TO-SPLICE-OUT*))))
	(SEND G-P ':PUTPROP V ':VSP)))
  ;; Copy the remaining attributes from the buffer to the generic pathname
  ;; (I think this used to be backwards!  --SWM)
  (DOLIST (ATTRIBUTE *ATTRIBUTES-REMEMBERED-IN-BUFFER*)
    (LET ((VAL (SEND BUFFER ':GET ATTRIBUTE)))
      (IF (NOT (NULL VAL))
	  (SEND G-P ':PUTPROP VAL ATTRIBUTE)))))

;;; Given a buffer, set the current state of all things described by attributes,
;;; based on the buffer's properties: set PACKAGE,
;;; set the major mode, change the window's font list, tab-width and backspace flags.
(DEFUN SET-ATTRIBUTE-STATE-FROM-BUFFER (BUFFER)
  (LET ((MAJOR-MODE (SEND BUFFER ':GET ':MAJOR-MODE)))
    (SET-EVALUATION-CONTEXT BUFFER)
    (SET-MAJOR-MODE MAJOR-MODE)
    (REDEFINE-WINDOW-BACKSPACE-FLAG *WINDOW* (SEND BUFFER ':GET ':BACKSPACE))
    (REDEFINE-WINDOW-TAB-NCHARS *WINDOW* (OR (SEND BUFFER ':GET ':TAB-WIDTH) 8))
    (SET-WINDOW-VSP *WINDOW* (OR (SEND BUFFER ':GET ':VSP) 2))
    (SEND ZWEI:(WINDOW-SHEET *WINDOW*) :SET-DEFAULT-CHARACTER-STYLE
	  ;; Set the default style to any user set attribute of the buffer
	  (OR (SEND BUFFER :GET :DEFAULT-CHARACTER-STYLE)
	      ;; Otherwise use the major-mode default-style.
	      (SEND MAJOR-MODE :DEFAULT-CHARACTER-STYLE)))
    ;; Kludgey, but this is the best we can do given the way hooks work.
    (IF (EQ (SEND MAJOR-MODE ':MODE-HOOK-VALUE) 'ELECTRIC-SHIFT-LOCK-IF-APPROPRIATE)
	(IF (SEND BUFFER ':GET ':LOWERCASE)
	    (TURN-OFF-MODE 'ELECTRIC-SHIFT-LOCK-MODE)
	    (TURN-ON-MODE 'ELECTRIC-SHIFT-LOCK-MODE)))
    (IF (EQ (SEND MAJOR-MODE ':MODE-HOOK-VALUE) 'ELECTRIC-FONT-LOCK-IF-APPROPRIATE)
	(IF (SEND BUFFER ':GET ':DEFAULT-CHARACTER-STYLE)
	    (TURN-ON-MODE 'ELECTRIC-FONT-LOCK-MODE)
	    (TURN-OFF-MODE 'ELECTRIC-FONT-LOCK-MODE)))
    (IF (EQ (SEND MAJOR-MODE ':MODE-HOOK-VALUE) 'AUTO-FILL-IF-APPROPRIATE)
	(IF (SEND BUFFER ':GET ':NOFILL)
	    (TURN-OFF-MODE 'AUTO-FILL-MODE)
	    (TURN-ON-MODE 'AUTO-FILL-MODE)))))

(DEFCOM COM-REPARSE-ATTRIBUTE-LIST "Reparses the attribute list (-*- line) of the buffer.
It finds the attribute list for the buffer and processes it to set up the
environment that the line specifies.  It changes the major mode, package,
base, and so on, as necessary.  When you edit the attribute list, you should
then use this command to make the changes take effect in Zmacs.  The changes
take effect both for the editor buffer and for the file that the buffer is editing." ()
  (LET ((OLD-VSP (SEND *INTERVAL* :GET :VSP))
	(OLD-DEFAULT-CHARACTER-STYLE (SEND *INTERVAL* :GET :DEFAULT-CHARACTER-STYLE)))
    (REPARSE-ATTRIBUTE-LIST-INTERNAL *INTERVAL* (OPEN-INTERVAL-STREAM *INTERVAL* NIL T))
    (SET-ATTRIBUTE-STATE-FROM-BUFFER *INTERVAL*)
    ;; This renders the presentation-nodes worthless
    (CLEAR-ALL-INTERVAL-PRESENTATION-NODES *INTERVAL*)
    (INVALIDATE-BUFFER-SECTIONIZATION *INTERVAL*)
    (IF (AND (EQL OLD-VSP (SEND *INTERVAL* :GET :VSP))
	     (EQUAL OLD-DEFAULT-CHARACTER-STYLE
		    (SEND *INTERVAL* :GET :DEFAULT-CHARACTER-STYLE)))
	DIS-NONE
      ;; If we change the VSP, we really do have to use DIS-ALL.
      DIS-ALL)))

;;; This variable is a hook for a user feature.  It is an alist of mode-names
;;; to mode-names, expressed as keyword symbols.  If Emacs supports Scribe
;;; mode, but Zmacs doesn't, and you want Zmacs to use Text mode, then
;;; you push (:SCRIBE . :TEXT) onto this list.
(DEFVAR *MAJOR-MODE-TRANSLATIONS* NIL)

;;; Given a buffer and an open input stream, read the attribute list from
;;; the stream.  Parse it, and set the corresponding attributes for the
;;; buffer.  In addition, if the buffer has an associated generic pathname,
;;; set the property list of the generic pathname accordingly.
;;--- Clean up the caching of attributes on both the generic pathname and
;;--- the buffer -- simply store the stuff on the pathname (without version?),
;;--- or, if it's a non-file buffer, on the buffer's plist.  --SWM

(DEFGENERIC REPARSE-ATTRIBUTE-LIST-INTERNAL (BUFFER STREAM))

(DEFVAR *ADDITIONAL-ATTRIBUTES-TO-BE-SAVED-ON-THE-GENERIC-PATHNAME* NIL
  "A list of keywords which are the additional modes to be saved on the
   generic pathname for a particular buffer.  This is used by
   (FLAVOR:METHOD REPARSE-ATTRIBUTE-LIST-INTERNAL NAMED-BUFFER-WITH-SECTIONS).
   The idea is to allow disparate pieces of code to PUSHNEW additional
   attributes onto this list, without having to patch the above routine
   multiple times or to keep track of all the new modes.
   .
   For a given keyword :FOO, we'll do 
      (SEND SELF :PUTPROP (SEND G-P :GET :FOO) :FOO)
   in the context of the above routine to copy the attribute.")

(DEFMETHOD (REPARSE-ATTRIBUTE-LIST-INTERNAL NAMED-BUFFER-WITH-SECTIONS) (STREAM)
  (LET ((G-P (IF (AND (ZMACS-BUFFER-P SELF)	;adequate flavorization, but not great
		      (FILE-BUFFER-P SELF))
		 (SEND (SEND SELF ':PATHNAME) ':GENERIC-PATHNAME)
		 (FS:MAKE-DUMMY-PATHNAME "Temp"))))
    ;; Wipe all knowledge of attributes, so that absense of an attribute
    ;; is property reflected.  Can't set plist to NIL because other things
    ;; besides attribute-list attributes live there too.
    ;; Don't wipe out a :PACKAGE property that came from loading the file.
    (DOLIST (PROP *MODE-LINE-PROPERTIES*)
      (OR (EQ PROP ':PACKAGE)
	  (SEND G-P ':REMPROP PROP)))
    ;; Read the attributes onto the generic pathname.
    ;; Warnings about incorrect attributes should go to the typein window.
    (LET ((ERROR-OUTPUT *TYPEIN-WINDOW*))
      (FS:READ-ATTRIBUTE-LIST G-P STREAM))
    ;; Now, convert the attributes of the generic pathname into properties
    ;; for the buffer.
    (LET (N)
      (MULTIPLE-VALUE-BIND (VARS VALS)
	  (CONDITION-BIND ((SYS:PACKAGE-NOT-FOUND
			     #'(LAMBDA (ERROR)
				 (PACKAGE-HANDLER ERROR
						  (SI:LISP-SYNTAX-FROM-KEYWORD
						    (OR
						      (SEND G-P :GET ':SYNTAX)
						      :ZETALISP))
						  SELF)))
			  (SI:LISP-SYNTAX-NOT-FOUND
			     #'SI:QUERY-HANDLE-SYNTAX-NOT-FOUND))
	    (FS:FILE-ATTRIBUTE-BINDINGS G-P))
	(SEND SELF ':PUTPROP (IF (SETQ N (FIND-POSITION-IN-LIST 'PACKAGE VARS))
				 (NTH N VALS)
				 PACKAGE) ':PACKAGE)
	(SEND SELF ':PUTPROP (IF (SETQ N (FIND-POSITION-IN-LIST 'IBASE VARS))
				 (NTH N VALS)
				 IBASE) ':BASE)))
    ;; If a mode is specified, use it.  Otherwise, leave the buffer alone and put back
    ;; the mode property on the generic pathname.
    (LET ((MODE (SEND G-P ':GET ':MODE)))
      (IF MODE
	  (LET ((INCOMING-MAJOR-MODE (SEND SELF :MAJOR-MODE))
		(MAJOR-MODE (GET-MAJOR-MODE-ATTRIBUTE-FOR-BUFFER
			      (OR (CDR (ASSQ MODE *MAJOR-MODE-TRANSLATIONS*))
				  MODE))))
	    (WHEN MAJOR-MODE
	      (WHEN (AND (VARIABLE-BOUNDP *WINDOW*)	;VC can call from outside Zmacs
			 (EQ SELF (WINDOW-INTERVAL *WINDOW*)))	;When current buffer
		(WHEN INCOMING-MAJOR-MODE
		  (IF (NEQ INCOMING-MAJOR-MODE MAJOR-MODE)
		      ;; When the major mode is changed, we had better turn off the old mode
		      ;; prior to removing all traces of it in the buffer plist.
		      ;;			-- SOTKO 9-23-87 
		      (TURN-OFF-MODE INCOMING-MAJOR-MODE)
		      ;; TURN-OFF-MODE will do this DELQ in the other clause of the IF
		      (SETQ *MODE-NAME-LIST* (DELQ INCOMING-MAJOR-MODE *MODE-NAME-LIST*)))))
	      (SEND SELF ':PUTPROP MAJOR-MODE ':MAJOR-MODE)))
	  (LET ((MAJOR-MODE (SEND SELF ':GET ':MAJOR-MODE)))
	    (SEND G-P ':PUTPROP (GET-MAJOR-MODE-ATTRIBUTE-FOR-PATHNAME MAJOR-MODE) ':MODE))))
    (LET* ((STYLE-LIST (SEND G-P ':GET ':DEFAULT-CHARACTER-STYLE))
	   (STYLE (CL:ETYPECASE STYLE-LIST
		    (NULL NIL)
		    (SI:CHARACTER-STYLE STYLE-LIST)
		    (LIST
		      (CHECK-DEFAULT-CHARACTER-STYLE STYLE-LIST)
		      (SI:PARSE-CHARACTER-STYLE STYLE-LIST)))))
      (SEND SELF ':PUTPROP
	    (OR STYLE (SEND (SEND SELF ':GET ':MAJOR-MODE)
			    ':DEFAULT-CHARACTER-STYLE))
	    ':DEFAULT-CHARACTER-STYLE))
    (SEND SELF ':PUTPROP (OR (SEND G-P ':GET ':TAB-WIDTH) 8) ':TAB-WIDTH)
    (SEND SELF ':PUTPROP (OR (SEND G-P ':GET ':VSP) 2) ':VSP)
    (LOOP FOR KEY IN *ADDITIONAL-ATTRIBUTES-TO-BE-SAVED-ON-THE-GENERIC-PATHNAME*
	  DO (SEND SELF :PUTPROP (SEND G-P :GET KEY) KEY))
    (DOLIST (ATTRIBUTE *ATTRIBUTES-REMEMBERED-IN-BUFFER*)
      (LET ((VAL (SEND G-P ':GET ATTRIBUTE))
	    (BUFFER-VAL (SEND SELF ':GET ATTRIBUTE)))
	(IF (NULL VAL)
	    (WHEN BUFFER-VAL
	      (SEND SELF ':REMPROP ATTRIBUTE))
	    (WHEN (OR (NULL BUFFER-VAL)
		      (NEQ VAL BUFFER-VAL))
	      (SEND SELF ':PUTPROP VAL ATTRIBUTE)))))))

;;; Convert the generic-pathname Mode attribute to the form suitable for
;;; a buffer's property list; i.e., convert :LISP to ZWEI:LISP-MODE.
(DEFUN GET-MAJOR-MODE-ATTRIBUTE-FOR-BUFFER (SYMBOL)
  (OR (AND SYMBOL (MAJOR-MODE-FROM-KEYWORD SYMBOL T))
      ;; Keep from blowing out
      (MAJOR-MODE-FROM-KEYWORD ':FUNDAMENTAL)))

;;; Convert to the form of the Mode attribute suitable for
;;; a buffer's property list into the generic-pathname form;
;;; i.e., convert #<ZWEI:LISP-MODE ...> to :LISP.
(DEFUN GET-MAJOR-MODE-ATTRIBUTE-FOR-PATHNAME (MODE)
  (SEND MODE ':MAJOR-MODE-KEYWORD))

(DEFCOM COM-UPDATE-ATTRIBUTE-LIST "Updates the attribute list (-*- line) of the buffer.
Creates or updates the attribute list of the file, using the current set of
parameters.  A new attribute list inherits the current Package, Mode, and
Backspace attributes.  It includes the Backspace, VSP, and Tab-width
attributes in the line only if they have values other than the defaults.
Other attributes in an existing mode line are not changed.  A numeric argument
causes default values to be spliced out of the attribute list altogether."
	()
  (UPDATE-ATTRIBUTE-LIST-INTERNAL *INTERVAL* *NUMERIC-ARG-P*)
  (SET-ATTRIBUTE-STATE-FROM-BUFFER *INTERVAL*)
  (SEND (SEND *INTERVAL* :MAJOR-MODE) :MUNG-LINE (BP-LINE (SEND *INTERVAL* :FIRST-BP)))
  DIS-TEXT)

;; Note that the :ADDITIONAL-ATTRIBUTES method on a major mode should not include
;; any of the things found in this list
(DEFVAR *KNOWN-ATTRIBUTES*
	'((:BACKSPACE "Backspace" :BOOLEAN)
	  (:LOWERCASE "Lowercase" :BOOLEAN)
	  (:DIAGRAM "Diagram" :BOOLEAN)
	  (:EVALUATOR "Eval" :EXPRESSION)
	  (:NOFILL "Nofill" :BOOLEAN)
	  (:PATCH-FILE "Patch-file" :BOOLEAN)
	  (:TAB-WIDTH "Tab-width" :NUMBER)
	  (:VSP "Vsp" :NUMBER)
	  (:DEFAULT-CHARACTER-STYLE "Default-character-style" :CHARACTER-STYLE)
	  (:FONT-ALIST "Fonts" :FONT-ALIST)
	  ))


(DEFMETHOD (MAJOR-MODE-FORMAT-ATTRIBUTE-LIST-INFO MAJOR-MODE :DEFAULT) (ATTRIBUTES)
  (LET ((ALIST NIL))
    (LOOP FOR (IND NAME TYPE) IN *KNOWN-ATTRIBUTES* DOING
      (LET ((VAL (CL:GETF ATTRIBUTES IND)))
	(AND VAL
	     (SETQ VAL (SELECTQ TYPE
			 (:BOOLEAN "T")
			 (:NUMBER (FORMAT NIL "~D" VAL))
			 (:CHARACTER-STYLE
			  (CL:ETYPECASE VAL
			    (SI:CHARACTER-STYLE (STRING-NAMING-CHARACTER-STYLE VAL))
			    (LIST (FORMAT NIL "~S" VAL))))
			 (OTHERWISE VAL)))
	     (PUSH (LIST NAME VAL) ALIST))))
    ;; These two type alists should really be the same format, I dunno which is better
    (LOOP FOR (INDICATOR NAME FORMAT) IN (SEND SELF ':ADDITIONAL-ATTRIBUTES)
	  AS VAL = (CL:GETF ATTRIBUTES INDICATOR)
	  WHEN (NULL VAL)
	    DO (SETQ VAL (SEND SELF ':GET-DEFAULT-ATTRIBUTE INDICATOR))
	  UNLESS (NULL VAL)
	    DO (WHEN (AND (EQ INDICATOR :PACKAGE)
			  (CL:PACKAGEP VAL))
		 (SETF VAL (CL:PACKAGE-NAME VAL)))
	       (PUSH (LIST NAME (IF FORMAT (FORMAT NIL FORMAT VAL) VAL)) ALIST))
    (PUSH `("Mode" ,(SEND SELF ':MODE-LINE-NAME)) ALIST)
    ALIST))

(DEFMETHOD (PACKAGE-BUFFER-ATTRIBUTES BUFFER) ()
  (LET ((BASIC-LIST (CL:COPY-TREE (SEND SELF :PLIST))))
    (LET ((GENERIC-PATHNAME			;kludge because the
						;(foo bar) is only kept there ...
	    (AND (FILE-BUFFER-P SELF)
		 (SEND (SEND SELF :PATHNAME) :GENERIC-PATHNAME))))
      (LET ((GENERIC-PATHNAME-PACKAGE-ATTRIBUTE
	      (AND GENERIC-PATHNAME (SEND GENERIC-PATHNAME :GET ':PACKAGE))))
	(WHEN GENERIC-PATHNAME-PACKAGE-ATTRIBUTE
	  (CL:SETF (CL:GETF BASIC-LIST :PACKAGE) GENERIC-PATHNAME-PACKAGE-ATTRIBUTE))))
    BASIC-LIST))

(DEFMETHOD (MAJOR-MODE-REMOVE-DEFAULT-ATTRIBUTES MAJOR-MODE :DEFAULT) (ATTRIBUTES)
  (LOOP FOR (IND VAL) ON ATTRIBUTES BY #'CDDR WITH RESULT = (CL:COPY-LIST ATTRIBUTES)
	AS DEFAULT = (CDR (CL:ASSOC IND *KNOWN-ATTRIBUTES-TO-SPLICE-OUT*))
	WHEN (AND DEFAULT (EQL DEFAULT VAL))
	  DO (CL:REMF RESULT IND) 
	FINALLY (RETURN RESULT)))

;;; Generate a new attribute list, or modify the existing one to be
;;; as it should, in BUFFER, getting the new values from the
;;; property list of the buffer.  Also set the property list of
;;; the generic pathname, if any, based on the property list of
;;; the buffer.
(DEFUN UPDATE-ATTRIBUTE-LIST-INTERNAL (BUFFER &OPTIONAL SPLICE-OUT-P)
  (LET* ((MAJOR-MODE (SEND BUFFER ':GET ':MAJOR-MODE))
	 (ALIST NIL)
	 (ONE-ATTRIBUTE-FOUND-P NIL)
	 (G-P (AND (ZMACS-BUFFER-P BUFFER)
		   (FILE-BUFFER-P BUFFER)
		   (SEND (SEND BUFFER ':PATHNAME) ':GENERIC-PATHNAME))))
    (SETQ ALIST (MAJOR-MODE-FORMAT-ATTRIBUTE-LIST-INFO
		  MAJOR-MODE
		  (PACKAGE-BUFFER-ATTRIBUTES BUFFER)))
    ;; Now ALIST is set up.  The first of every element is a string being the
    ;; name of a property, and the second is a Lisp object being the value.
    ;; The next step is to parse the existing text in the buffer.
    (MULTIPLE-VALUE-BIND (START-BP END-BP)
	(FIND-ATTRIBUTE-LIST BUFFER)
      (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK START-BP))
	(WITH-BP (THE-END-BP END-BP ':MOVES)
	  (DO ((IDX (BP-INDEX START-BP))	;Current scan point
	       (LINE (BP-LINE START-BP))	;String being scanned
	       (COLON)				;Location of colon
	       (SEMI)				;Location of semicolon
	       (END-IDX))			;End of line
	      (NIL)
	    (SETQ END-IDX (BP-INDEX THE-END-BP))	;Relocating BP might have changed.
	    (WHEN (NULL (SETQ COLON (STRING-SEARCH-CHAR #/: LINE IDX END-IDX)))
	      (RETURN))
	    (SETQ ONE-ATTRIBUTE-FOUND-P T)
	    (SETQ SEMI (STRING-SEARCH-CHAR #/; LINE COLON END-IDX))
	    ;; Now we have located one attribute.  SEMI may be NIL if this
	    ;; is the last one.
	    (LET ((ITEM (ASSOC (STRING-TRIM *BLANKS* (SUBSTRING LINE IDX COLON)) ALIST)))
	      (COND ((NOT (NULL ITEM))
		     (LET ((COLON-BP (CREATE-BP LINE (1+ COLON)))
			   (SEMI-BP (CREATE-BP LINE (OR SEMI END-IDX)))
			   (THING
			     (ASS #'STRING-EQUAL
				  (CAR ITEM) *KNOWN-ATTRIBUTES-TO-SPLICE-OUT*)))
		       (BLOCK NIL
			 (WHEN (AND THING SPLICE-OUT-P)
			   (WHEN (EQL (OR (SEND BUFFER :GET (CAR THING))
					  (SEND MAJOR-MODE
						:GET-DEFAULT-ATTRIBUTE (CAR THING)))
				      (CDR THING))
			     ;; If the buffer's value if equal to the default value,
			     ;; splice the indicator out of the mode line altogether
			     (DELETE-INTERVAL (CREATE-BP LINE IDX)
					      (CREATE-BP LINE (IF SEMI (1+ SEMI) END-IDX)))
			     (IF SEMI
				 (SETQ SEMI (- SEMI (- (IF SEMI (1+ SEMI) END-IDX) IDX))))
			     (RETURN)))
			 ;; This is a keyword that we recognize.  Replace its value.
			 (CASE-REPLACE COLON-BP SEMI-BP (STRING-DOWNCASE (CADR ITEM)) T)
			 (INSERT-MOVING COLON-BP #\SPACE)
			 (IF SEMI		;Location of SEMI may have changed
			     (SETQ SEMI (STRING-SEARCH-CHAR #/; LINE (BP-INDEX COLON-BP))))))
		     (SETQ ALIST (DELETE ITEM ALIST))))
	      (IF (NULL SEMI)
		  (RETURN)
		(SETQ IDX (+ SEMI 1))))))
	;; Anything left remaining on the ALIST are attributes that need to be
	;; added to the attribute list.
	(LOOP FOR ALIST
		  ON (LOOP FOR ELEM IN ALIST
			   AS THING = (ASS #'STRING-EQUAL
					   (CAR ELEM) *KNOWN-ATTRIBUTES-TO-SPLICE-OUT*)
			   ;; But don't insert any whose buffer value equals the default
			   UNLESS (AND THING
				       (EQL (OR (SEND BUFFER :GET (CAR THING))
						(SEND MAJOR-MODE :GET-DEFAULT-ATTRIBUTE
						      (CAR THING)))
					    (CDR THING)))
			     COLLECT ELEM)
	      AS ELEM = (CAR ALIST)
	      DO (INSERT-MOVING START-BP " ")
		 (INSERT-MOVING START-BP (FIRST ELEM))
		 (INSERT-MOVING START-BP ": ")
		 (INSERT-MOVING START-BP (SECOND ELEM))
		 (IF (OR (CDR ALIST) ONE-ATTRIBUTE-FOUND-P)
		     ;; If more to come, or some there already,
		     (INSERT-MOVING START-BP ";")))
	;;--- This will land on the inter-section diagram line.  Perhaps we should
	;;--- kludge further to fix that?
	(WHEN (EQ (BP-LINE (POINT)) (BP-LINE START-BP))
	  (LET ((NEXT-LINE (LINE-NEXT-IN-BUFFER (BP-LINE START-BP) :BUFFER BUFFER)))
	    (IF NEXT-LINE
		(MOVE-POINT (LINE-NEXT-IN-BUFFER (BP-LINE START-BP) :BUFFER BUFFER) 0)
	      (MOVE-POINT (END-OF-LINE (BP-LINE START-BP)))
	      (INSERT-MOVING-POINT #\RETURN))))))
    ;; We're done building the attribute list.  Now we have to set the
    ;; generic pathname plist, if any, from the buffer plist.
    (COND ((NOT (NULL G-P))
	   (SET-PATHNAME-ATTRIBUTES-FROM-BUFFER G-P BUFFER)))
    (REPARSE-ATTRIBUTE-LIST-INTERNAL BUFFER (OPEN-INTERVAL-STREAM BUFFER NIL T))
    ;; If the attribute list was previously empty, we have to do this again!  This is
    ;; because REPARSE-ATTRIBUTE-LIST-INTERNAL may have supplied some forced default
    ;; attribute values, as for :DEFAULT-CHARACTER-STYLE.  The line in the interval
    ;; has to be made consonant with the internal properties of the buffer.
    (UNLESS ONE-ATTRIBUTE-FOUND-P
      (UPDATE-ATTRIBUTE-LIST-INTERNAL BUFFER SPLICE-OUT-P))))

;;; Given a buffer, find the attribute list.  Returns two BPs, START-BP and END-BP.
;;; START-BP will point immediately after the opening -*-, and END-BP will point
;;; immediately before the closing -*-, and if that's preceeded by a space then
;;; it will point immediately before that space.
;;; Create an empty attribute list if there isn't one already, by default.
;;; But if CREATE-IF-NOT-FOUND is NIL and there isn't one already, return NIL.
(DEFUN FIND-ATTRIBUTE-LIST (BUFFER &OPTIONAL (CREATE-IF-NOT-FOUND T))
  (LET* ((LINE (BP-LINE (INTERVAL-FIRST-BP BUFFER)))
	 (IDX (STRING-SEARCH "-*-" LINE))
	 START-BP END-BP)
    (COND ((NOT (NULL IDX))
	   ;; There is already a mode line present.
	   (UNLESS (EQUAL 0 (FIND-COMMENT-START LINE))
	     ;; This is an attempt to see if the mode line exists but isn't commented out.
	     ;; This can happen if the major mode was changed after the first time
	     ;; Update Attribute List was used.  Hard to get this test right, since there
	     ;; can be semicolons inside the attribute list itself.
	     (LET ((COMMENT-START-STRING (SEND (SEND BUFFER ':GET ':MAJOR-MODE)
					 ':ATTRIBUTE-COMMENT-START))
		   (COMMENT-END-STRING (SEND (SEND BUFFER ':GET ':MAJOR-MODE)
					 ':ATTRIBUTE-COMMENT-END)))
	       (UNLESS (NULL COMMENT-START-STRING)
		 (INSERT (CREATE-BP LINE IDX) COMMENT-START-STRING))
	       (WHEN (AND COMMENT-END-STRING (PLUSP (STRING-LENGTH COMMENT-END-STRING)))
		 (INSERT (CREATE-BP LINE (LINE-LENGTH LINE)) COMMENT-END-STRING))))
	   (SETQ IDX (+ 3 (STRING-SEARCH "-*-" LINE)))
	   (SETQ START-BP (CREATE-BP LINE IDX))
	   (LET ((END (STRING-SEARCH "-*-" LINE IDX)))
	     (COND ((NULL END)
		    ;; No terminating -*- found.  Put one in.
		    (SETQ END-BP (CREATE-BP LINE (LINE-LENGTH LINE)))
		    (INSERT END-BP " -*-"))
		   (T
		    ;; Found, back over a space if present.
		    (IF (CHAR-EQUAL (AREF LINE (1- END)) #\SP) (SETQ END (1- END)))
		    (SETQ END-BP (CREATE-BP LINE END)))))
	   ;; If there is an old-style "attribute list" (-*-Lisp-*-), convert
	   ;; it into a real attribute list (-*- Mode: Lisp -*-).
	   (COND ((AND (NOT (STRING-SEARCH-CHAR #/: LINE
						(BP-INDEX START-BP) (BP-INDEX END-BP)))
		       (STRING-SEARCH-NOT-SET '(#\SP #\TAB) LINE
					      (BP-INDEX START-BP) (BP-INDEX END-BP)))
		  (INSERT START-BP " Mode: ")
		  (MOVE-BP END-BP LINE (+ (BP-INDEX END-BP) 7)))))
	  (CREATE-IF-NOT-FOUND
	   ;; There is no mode line at all yet.  Create one.  Try to make
	   ;; it a comment in the language being used.
	   (SETQ START-BP (COPY-BP (INTERVAL-FIRST-BP BUFFER)))
	   (LET ((COMMENT-STRING (SEND (SEND BUFFER ':GET ':MAJOR-MODE)
				       ':ATTRIBUTE-COMMENT-START)))
	     (UNLESS (NULL COMMENT-STRING)
	       (INSERT-MOVING START-BP COMMENT-STRING)))
	   (INSERT-MOVING START-BP "-*-")
	   (LET ((TEMP-BP (INSERT START-BP " -*-"))
		 (COMMENT-END-STRING (SEND (SEND BUFFER ':GET ':MAJOR-MODE)
					 ':ATTRIBUTE-COMMENT-END)))
	     (COND ((AND COMMENT-END-STRING (PLUSP (STRING-LENGTH COMMENT-END-STRING)))
		    (INSERT-MOVING TEMP-BP #\SP)
		    (INSERT-MOVING TEMP-BP COMMENT-END-STRING)))
	     (INSERT TEMP-BP #\RETURN))
	   (SETQ END-BP START-BP)))
    (VALUES START-BP END-BP)))

;;; Change just one element of the attribute list.  BUFFER should be a buffer.
;;; ATTRIBUTE-NAME and ATTRIBUTE-VALUE should be strings; also, ATTRIBUTE-VALUE
;;; may be NIL to remove an attribute from the line.
(DEFUN UPDATE-ONE-ATTRIBUTE (BUFFER ATTRIBUTE-NAME ATTRIBUTE-VALUE
			     &AUX ONE-ATTRIBUTE-FOUND-P)
  (MULTIPLE-VALUE-BIND (START-BP END-BP)
      (FIND-ATTRIBUTE-LIST BUFFER ATTRIBUTE-VALUE)
    (LABELS ((CORRECT-STYLE ()
	       ;; Returns the correct style for new attributes for the attribute line, by examining
	       ;; the first character of the line at START-BP, which is where the attribute line hangs out
	       ;; (I hope!---JRD sez the attribute line doesn't have to start at the first line in the buffer?!?)
	       (LET ((LINE (BP-LINE START-BP)))
		 (IF (ZEROP (STRING-LENGTH LINE))
		     SI:*NULL-STYLE*
		     (SI:CHAR-STYLE (AREF LINE 0)))))
	     (CHARACTER-IN-CORRECT-STYLE (CHARACTER)
	       ;; Returns CHARACTER in the style that CORRECT-STYLE recommends.
	       (LET ((STYLE-INDEX (SI:STYLE-INDEX (CORRECT-STYLE) T)))
		 (SETF (SI:CHAR-STYLE-INDEX CHARACTER) STYLE-INDEX)
		 CHARACTER)))
      (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK START-BP))
        (COND ((NULL START-BP)
	       ;; ATTRIBUTE-VALUE was NIL, and there isn't already an attribute list,
	       ;; so just don't do anything.
	       )
	      ((NOT
		 ;; Try to find attribute-name in the existing attribute list.  If found,
		 ;; replace the value and return T.  Else return NIL.
		 (WITH-BP (THE-END-BP END-BP ':MOVES)
		   (DO ((IDX (BP-INDEX START-BP))	;Current scan point
			(LINE (BP-LINE START-BP))	;Line being scanned
			(COLON)			;Location of colon
			(SEMI)			;Location of semicolon
			(END-IDX))		;End of line
		       (NIL)
		     (SETQ END-IDX (BP-INDEX THE-END-BP))	;Relocating BP might have changed.
		     (WHEN (NULL (SETQ COLON (STRING-SEARCH-CHAR #/: LINE IDX END-IDX)))
		       (RETURN NIL))
		     (SETQ ONE-ATTRIBUTE-FOUND-P T)
		     (SETQ SEMI (STRING-SEARCH-CHAR #/; LINE COLON END-IDX))
		     ;; Now we have located one attribute.  SEMI may be NIL if this
		     ;; is the last one.
; 		     (dbg)
		     (LET ((NAME (STRING-TRIM *BLANKS* (SUBSTRING LINE IDX COLON))))
		       (COND ((STRING-EQUAL NAME ATTRIBUTE-NAME)
			      ;; This is the one we're looking for.  Replace its value.
			      (LET ((COLON-BP (CREATE-BP LINE (1+ COLON)))
				    (SEMI-BP (CREATE-BP LINE (OR SEMI END-IDX))))
				(COND ((NULL ATTRIBUTE-VALUE)
				       ;; Delete the whole entry.
				       (DELETE-INTERVAL
					 (CREATE-BP LINE IDX)
					 (IF SEMI	; Delete the semicolon itself, too, if any.
					     (FORWARD-CHAR SEMI-BP)
					     SEMI-BP)
					 T))
				      (T
				       ;; Put in the new value.
				       (CASE-REPLACE COLON-BP
						     SEMI-BP
						     (SI:CHANGE-STRING-CHARACTER-STYLE
						       (STRING-DOWNCASE ATTRIBUTE-VALUE)
						       (CORRECT-STYLE))
						     T)
				       (INSERT-MOVING COLON-BP (CHARACTER-IN-CORRECT-STYLE #/SPACE))))
				;; don't leave POINT on the attribute line; this is almost never
				;; useful, and a big loss for creating new attribute lines.
				(WHEN (EQ (BP-LINE (POINT)) (BP-LINE START-BP))
				  (LET ((NEXT-LINE (LINE-NEXT-IN-BUFFER (BP-LINE START-BP))))
				    (IF NEXT-LINE
					(MOVE-POINT NEXT-LINE 0)
					(MOVE-POINT (END-LINE (POINT)))
					(INSERT-MOVING-POINT #\RETURN))))
				(RETURN T)))
			     ((NOT (NULL SEMI))
			      ;; We don't recognize this one.  Space over it if there are more.
			      (SETQ IDX (+ SEMI 1)))))
		     (WHEN (NULL SEMI) (RETURN NIL)))))
	       ;; Could not find it, add to the end of the attribute list.
	       (COND ((NOT (NULL ATTRIBUTE-VALUE))
		      ;; If there is a trailing semicolon, back up to before it.
		      (LET* ((LINE (BP-LINE END-BP))
			     (IDX (STRING-REVERSE-SEARCH-NOT-SET
				    '(#\SP #\TAB) LINE (BP-INDEX END-BP))))
			(WHEN (CHAR-EQUAL (AREF LINE IDX) #/;)
			  (MOVE-BP END-BP LINE IDX)))
		      (IF ONE-ATTRIBUTE-FOUND-P
			  ;; If some there already,
			  (INSERT-MOVING END-BP (CHARACTER-IN-CORRECT-STYLE #/;)))
		      (INSERT-MOVING END-BP (CHARACTER-IN-CORRECT-STYLE #/SPACE))
		      (INSERT-MOVING END-BP (SI:CHANGE-STRING-CHARACTER-STYLE ATTRIBUTE-NAME (CORRECT-STYLE)))
		      (INSERT-MOVING END-BP (CHARACTER-IN-CORRECT-STYLE #/:))
		      (INSERT-MOVING END-BP (CHARACTER-IN-CORRECT-STYLE #/SPACE))
		      (INSERT-MOVING END-BP (SI:CHANGE-STRING-CHARACTER-STYLE ATTRIBUTE-VALUE (CORRECT-STYLE)))))
	       (WHEN (EQ (BP-LINE (POINT)) (BP-LINE START-BP))
		 (MOVE-POINT (LINE-NEXT-IN-BUFFER (BP-LINE START-BP)) 0))))))))

(DEFVAR *ATTRIBUTES-WHICH-INVALIDATE-PRESENTATION-NODES*
	'(:PACKAGE :SYNTAX :BASE))

;;; All of the attribute-setting commands such as Set Package and Set Base
;;; should call this function, passing the attribute name as a keyword symbol
;;; and as a string, and the attribute value both in its string form and as it
;;; appears in generic pathnames.
(DEFUN SET-ATTRIBUTE-INTERNAL (ATTRIBUTE-NAME ATTRIBUTE-PRETTY-NAME
			       ATTRIBUTE-VALUE-STRING ATTRIBUTE-VALUE-LIST)
  (LET* ((BUFFER (CURRENT-ZMACS-BUFFER))
	 (FILE-P (AND BUFFER (FILE-BUFFER-P BUFFER)))
	 (DO-IT-P *SET-ATTRIBUTE-UPDATES-LIST*))
    ;; This variables controls the default.  It can be T, NIL, or :ASK.  :ASK is default.
    (UNLESS (MEMQ DO-IT-P '(T NIL))
      ;; If it is :ASK, or got set to some garbage.
      (SETQ DO-IT-P (FQUERY '(:SELECT T)
			"Set it for the ~:[file and ~]attribute list, too? (Say /"Y/" if not sure) "
			(NOT FILE-P))))
    (WHEN DO-IT-P
      (WHEN FILE-P
	(SEND (SEND (SEND *INTERVAL* ':PATHNAME) ':GENERIC-PATHNAME)
	      ':PUTPROP ATTRIBUTE-VALUE-LIST ATTRIBUTE-NAME))
      (UPDATE-ONE-ATTRIBUTE *INTERVAL* ATTRIBUTE-PRETTY-NAME ATTRIBUTE-VALUE-STRING))
    ;; When one of these changes, the presentation-nodes are rendered worthless
    (WHEN (MEMQ ATTRIBUTE-NAME *ATTRIBUTES-WHICH-INVALIDATE-PRESENTATION-NODES*)
      (CLEAR-ALL-INTERVAL-PRESENTATION-NODES *INTERVAL*))))

;;;--- This needs to prefer values on the property list to the G-P, so long as the
;;;--- set commands only hack the plist.
;; Contains a copy of code from WITH-EVALUATION-CONTEXT-FOR-BUFFER
(DEFUN SET-EVALUATION-CONTEXT (BUFFER)
  (LET* ((FILE-P (AND (ZMACS-BUFFER-P BUFFER) (SEND BUFFER :EDITING-FILE-P)))
	 (GENERIC-PATHNAME (AND FILE-P
				(SEND (SEND BUFFER :PATHNAME) :GENERIC-PATHNAME)))
	 (MAJOR-MODE (SEND BUFFER :MAJOR-MODE))
	 (ADDITIONAL-BINDINGS (LOOP WITH LIST = (OR (SEND MAJOR-MODE :ADDITIONAL-ATTRIBUTES)
						    ;; Package is special cased here, because
						    ;; switching to a non-file buffer in
						    ;; fundamental mode still honours
						    ;; *DEFAULT-PACKAGE*.
						    '((:PACKAGE)))
				    FOR (INDICATOR VALUE)
					ON (SEND-IF-HANDLES BUFFER :PLIST) BY 'CDDR
				    WHEN (ASSQ INDICATOR LIST)
				      COLLECT INDICATOR AND COLLECT VALUE)))
    ;; Bind all the variables required by the attribute list.
    (MULTIPLE-VALUE-BIND (FVARS FVALS)
	(LET* ((STANDARD-OUTPUT #'SI:NULL-STREAM)
	       (ERROR-OUTPUT STANDARD-OUTPUT))
	  (FS:FILE-ATTRIBUTE-BINDINGS GENERIC-PATHNAME
				      :ADDITIONAL-ATTRIBUTES ADDITIONAL-BINDINGS))
      ;;--- Yuck, too bad plists don't know about NIL properties
      (UNLESS (MEMQ 'FS:THIS-IS-A-PATCH-FILE FVARS)
	(PUSH 'FS:THIS-IS-A-PATCH-FILE FVARS)
	(PUSH NIL FVALS))
      ;; Set up some canonical defaults
      (UNLESS (MEMQ 'BASE FVARS)
	(SET-ONE-CONTEXT-VARIABLE 'BASE (SYMEVAL-GLOBALLY 'BASE)))
      (UNLESS (MEMQ 'IBASE FVARS)
	(SET-ONE-CONTEXT-VARIABLE 'IBASE (SYMEVAL-GLOBALLY 'IBASE)))
      (UNLESS (MEMQ 'READTABLE FVARS)
	(SET-ONE-CONTEXT-VARIABLE 'READTABLE (SYMEVAL-GLOBALLY 'READTABLE)))
      (UNLESS (MEMQ 'PACKAGE FVARS)
	(SET-ONE-CONTEXT-VARIABLE 'PACKAGE (SYMEVAL-GLOBALLY 'PACKAGE)))
      (LOOP FOR VAR IN FVARS
	    FOR VAL IN FVALS
	    DO (SET-ONE-CONTEXT-VARIABLE VAR VAL)))))

;; For compatibility with releases before 7.2
(DEFMACRO WITH-EVALUATION-CONTEXT (&BODY BODY)
  `(WITH-EVALUATION-CONTEXT-FOR-BUFFER (*INTERVAL*) ,@BODY))

;; Useful when BUFFER does not have the same context as the current buffer.
;; Not needed when BUFFER is *INTERVAL* and that has been made the current buffer.
;; Contains a copy of code from SET-EVALUATION-CONTEXT
(DEFMACRO WITH-EVALUATION-CONTEXT-FOR-BUFFER ((BUFFER) &BODY BODY)
  `(LET* ((FILE-P (AND (ZMACS-BUFFER-P ,BUFFER) (SEND ,BUFFER :EDITING-FILE-P)))
	  (GENERIC-PATHNAME (AND FILE-P
				 (SEND (SEND ,BUFFER :PATHNAME) :GENERIC-PATHNAME)))
	  (MAJOR-MODE (SEND ,BUFFER :MAJOR-MODE))
	  (ADDITIONAL-BINDINGS (LOOP WITH LIST = (OR (SEND MAJOR-MODE :ADDITIONAL-ATTRIBUTES)
						     ;; Package is special cased here, because
						     ;; switching to a non-file buffer in
						     ;; fundamental mode still honours
						     ;; *DEFAULT-PACKAGE*.
						     '((:PACKAGE)))
				     FOR (INDICATOR VALUE)
					 ON (SEND-IF-HANDLES ,BUFFER :PLIST) BY 'CDDR
				     WHEN (ASSQ INDICATOR LIST)
				       COLLECT INDICATOR AND COLLECT VALUE)))
     ;; Bind all the variables required by the attribute list.
     (MULTIPLE-VALUE-BIND (FVARS FVALS)
	 (LET* ((STANDARD-OUTPUT #'SI:NULL-STREAM)
		(ERROR-OUTPUT STANDARD-OUTPUT))
	   (FS:FILE-ATTRIBUTE-BINDINGS GENERIC-PATHNAME
				       :ADDITIONAL-ATTRIBUTES ADDITIONAL-BINDINGS))
       (STANDARD-VALUE-PROGV FVARS FVALS
	 ,@BODY))))

;; (:METHOD EDITOR :EDIT) has bindings for all contextual variables as well
;; as for SI:*INTERACTIVE-BINDINGS*
(DEFUN SET-ONE-CONTEXT-VARIABLE (VARIABLE NEW-VALUE)
  (LET ((VALIDATION-FUNCTION (GET VARIABLE 'SI:VALIDATION-FUNCTION))
	(OLD-VALUE (ASSQ VARIABLE SI:*INTERACTIVE-BINDINGS*)))
    (LET ((NEW-OK (OR (NULL VALIDATION-FUNCTION)
		      (FUNCALL VALIDATION-FUNCTION NEW-VALUE))))
      (IF NEW-OK
	  (IF OLD-VALUE
	      (RPLACD OLD-VALUE (NCONS NEW-VALUE))
	    (PUSH `(,VARIABLE ,NEW-VALUE) SI:*INTERACTIVE-BINDINGS*))
	(TYPEIN-LINE "Warning: ~A failed the validation function for ~A;~@
		      the standard value for ~A will not be changed."
		     NEW-VALUE VARIABLE VARIABLE)))
    (SET VARIABLE NEW-VALUE)))

(DEFCOM COM-SET-PACKAGE "Changes the package associated with the buffer.
Prompts for a new package.  It offers to create the package if necessary.
Forms that are read from the buffer are read in that package.  It offers
to set the package for the generic pathname attribute list and updates
the attribute line in the buffer when you answer /"Yes/".  The system is
informed that the file belongs to the specified package.  If you are not
sure what to answer, say /"Yes/".  The variable
ZWEI:*SET-ATTRIBUTE-UPDATES-LIST* controls this query.  Its default
value is :ASK.  Setting the variable to T means Yes; NIL means No.
" ()
  (LET* ((PACKAGE-NAME
	   (READ-PACKAGE-FROM-MINI-BUFFER
	     "Set package" PACKAGE 'RETURN))	;recognize on return, else impossible OK
	 (SYNTAX (SEND *INTERVAL* :GET :SYNTAX))
	 (NEW-PACKAGE (NULL (FS:FIND-PACKAGE-FOR-SYNTAX PACKAGE-NAME SYNTAX ':FIND))))
    (SET-ONE-CONTEXT-VARIABLE 'PACKAGE		;query to create now
			      (CONDITION-CASE ()
				   (FS:FIND-PACKAGE-FOR-SYNTAX PACKAGE-NAME SYNTAX :ASK)
				 (SYS:PACKAGE-NOT-FOUND (BARF "Package not set."))))
    (SETQ PACKAGE-NAME (SYS:PACKAGE-NAME-FOR-SYNTAX PACKAGE SYNTAX))
    (SEND *INTERVAL* ':PUTPROP PACKAGE ':PACKAGE)
    (WHEN (TYPEP *INTERVAL* 'BUFFER)
      (LET ((ATTRIBUTE-STRING PACKAGE-NAME)
	    (ATTRIBUTE-VALUE (INTERN PACKAGE-NAME SI:PKG-KEYWORD-PACKAGE)))
	(WHEN NEW-PACKAGE
	  (SETQ ATTRIBUTE-STRING (STRING-APPEND "(" ATTRIBUTE-STRING ")")
		ATTRIBUTE-VALUE (LIST ATTRIBUTE-VALUE)))
	(SET-ATTRIBUTE-INTERNAL ':PACKAGE "Package" ATTRIBUTE-STRING ATTRIBUTE-VALUE)
	(INVALIDATE-BUFFER-SECTIONIZATION *INTERVAL*))))
  DIS-TEXT)

(DEFCOM COM-SET-BASE "Changes the base associated with the buffer.
Prompts for a new base.  It requires a valid numeric IBASE value.
Forms that are read from the buffer are read in that base.  It offers
to set the base for the generic pathname attribute list and updates
the attribute line in the buffer when you answer /"Yes/".  The system is
informed that the file uses the specified base.  If you are not
sure what to answer, say /"Yes/".  The variable
ZWEI:*SET-ATTRIBUTE-UPDATES-LIST* controls this query.  Its default
value is :ASK.  Setting the variable to T means Yes; NIL means No.
" ()
  (LET ((NEW-BASE (TYPEIN-LINE-ACCEPT '((CL:INTEGER 2 32))
				      :PROMPT "Set base" :DEFAULT 10.)))
    (SEND *INTERVAL* :PUTPROP NEW-BASE :BASE)
    (SET-ATTRIBUTE-INTERNAL :BASE "Base" (FORMAT NIL "~D" NEW-BASE) NEW-BASE)
    (SET-ONE-CONTEXT-VARIABLE 'BASE NEW-BASE)
    (SET-ONE-CONTEXT-VARIABLE 'IBASE NEW-BASE))
  DIS-TEXT)

(DEFCOM COM-SET-BACKSPACE "Changes whether backspaces overprint.
Asks whether backspaces should overprint, and requests a Y-or-N
answer.  If you say Y, backspaces will cause characters to
overstrike.  If you say N, backspaces will display as a little
lozenge saying /"overstrike/" (this is the default behavior).  It offers
to set the Backspace attribute for the generic pathname attribute list and updates
the attribute line in the buffer when you answer /"Yes/".  The system is
informed that the file has that Backspace attribute.  If you are not
sure what to answer, say /"Yes/".  The variable
ZWEI:*SET-ATTRIBUTE-UPDATES-LIST* controls this query.  Its default
value is :ASK.  Setting the variable to T means Yes; NIL means No.
" ()
  (LET ((BACKSPACE
	  (FQUERY `(:SELECT T
		    :CHOICES ,FORMAT:Y-OR-N-P-CHOICES)
		  "Should backspaces cause overprinting? ")))
    (SEND *INTERVAL* ':PUTPROP BACKSPACE ':BACKSPACE)
    (REDEFINE-WINDOW-BACKSPACE-FLAG *WINDOW* BACKSPACE)
    (SET-ATTRIBUTE-INTERNAL ':BACKSPACE "Backspace" (IF BACKSPACE "Yes" NIL) BACKSPACE))
  DIS-TEXT)

(DEFCOM COM-SET-TAB-WIDTH "Sets the number of space characters displayed for a tab.
The new value applies to existing tabs in the buffer, as well as to new ones
being typed.  The tab width is a property of the buffer and does not apply to
other buffers.  The default tab width is 8 characters.  It prompts for a new
width; you must type in a number.  It offers
to set the Tab Width attribute for the generic pathname attribute list and updates
the attribute line in the buffer when you answer /"Yes/".  The system is
informed that the file has that Tab Width.  If you are not
sure what to answer, say /"Yes/".  The variable
ZWEI:*SET-ATTRIBUTE-UPDATES-LIST* controls this query.  Its default
value is :ASK.  Setting the variable to T means Yes; NIL means No.
" (KM)
  (LET ((NEW-TAB-WIDTH (TYPEIN-LINE-ACCEPT '((CL:INTEGER (0)))
					   :PROMPT "Set tab width"
					   :DEFAULT 8)))
    (SEND *INTERVAL* :PUTPROP NEW-TAB-WIDTH :TAB-WIDTH)
    (SET-ATTRIBUTE-INTERNAL :TAB-WIDTH "Tab-Width"
			    (IF (EQL NEW-TAB-WIDTH 8) NIL (FORMAT NIL "~D" NEW-TAB-WIDTH))
			    (IF (EQL NEW-TAB-WIDTH 8) NIL NEW-TAB-WIDTH))
    (REDEFINE-WINDOW-TAB-NCHARS *WINDOW* NEW-TAB-WIDTH))
  DIS-TEXT)

(DEFCOM COM-SET-VSP "Sets the vertical spacing of the lines of the window.
This is the number of pixels (scan lines) separating each textual line from
the next within a window. The VSP is a property of the buffer and does not apply to
other buffers.  The default VSP is 2 pixels.  It prompts for a new
VSP; you must type in a non-negative number.  It offers
to set the VSP attribute for the generic pathname attribute list and updates
the attribute line in the buffer when you answer /"Yes/".  The system is
informed that the file has that Tab Width.  If you are not
sure what to answer, say /"Yes/".  The variable
ZWEI:*SET-ATTRIBUTE-UPDATES-LIST* controls this query.  Its default
value is :ASK.  Setting the variable to T means Yes; NIL means No.
" (KM)
  (LET ((NEW-VSP (TYPEIN-LINE-ACCEPT '((CL:INTEGER 0))
				     :PROMPT "Set VSP (vertical spacing)"
				     :DEFAULT 2)))
    (SEND *INTERVAL* :PUTPROP NEW-VSP :VSP)
    (SET-ATTRIBUTE-INTERNAL :VSP "Vsp"
			    (IF (EQL NEW-VSP 2) NIL (FORMAT NIL "~D" NEW-VSP))
			    (IF (EQL NEW-VSP 2) NIL NEW-VSP))
    (SET-WINDOW-VSP *WINDOW* NEW-VSP))
  DIS-ALL)

(DEFCOM COM-SET-LOWERCASE "Changes whether the buffer is in lower case.
Asks whether Lisp-style program text in the buffer should be in lower
case by default, and requests a Y-or-N answer.  If you say Y, it will be
in lower case by default.  If you say N, it will be in upper case by
default.  This mainly matters if you use
ELECTRIC-SHIFT-LOCK-IF-APPROPRIATE and the buffer is in LISP mode.  It
offers to set the Lowercase attribute for the generic pathname attribute
list and updates the attribute line in the buffer when you answer
/"Yes/".  The system is informed that the file has that Lowercase
attribute.  If you are not sure what to answer, say /"Yes/".  The
variable ZWEI:*SET-ATTRIBUTE-UPDATES-LIST* controls this query.  Its
default value is :ASK.  Setting the variable to T means Yes; NIL means
No.
" ()
  (LET ((LOWERCASE
	  (FQUERY `(:SELECT T
		    :CHOICES ,FORMAT:Y-OR-N-P-CHOICES)
		  "Should Lisp-style code be in lower case? ")))
    (SEND *INTERVAL* ':PUTPROP LOWERCASE ':LOWERCASE)
    (IF (OR (EQ (SEND (SEND *INTERVAL* :MAJOR-MODE) ':MODE-HOOK-VALUE)
		'ELECTRIC-SHIFT-LOCK-IF-APPROPRIATE)
	    (AND (LISTP (SEND (SEND *INTERVAL* :MAJOR-MODE) ':MODE-HOOK-VALUE))
		 (CL:MEMBER 'ELECTRIC-SHIFT-LOCK-IF-APPROPRIATE
			    (SEND (SEND *INTERVAL* :MAJOR-MODE) ':MODE-HOOK-VALUE)
			    :KEY #'SYS:FUNCTION-NAME)))
	(IF LOWERCASE
	    (TURN-OFF-MODE 'ELECTRIC-SHIFT-LOCK-MODE)
	    (TURN-ON-MODE 'ELECTRIC-SHIFT-LOCK-MODE)))
    (SET-ATTRIBUTE-INTERNAL ':LOWERCASE "Lowercase" (IF LOWERCASE "Yes" NIL) LOWERCASE))
  DIS-TEXT)

(DEFCOM COM-SET-NOFILL "Changes whether the buffer text should not be filled.
Asks whether text in the buffer should not be filled by default, and
requests a Y-or-N answer.  If you say Y, text will not be filled.  If
you say N, it will be filled.  This only matters if you use
AUTO-FILL-IF-APPROPRIATE and the buffer is in TEXT mode.  It offers to
set the Nofill attribute for the generic pathname attribute list and
updates the attribute line in the buffer when you answer /"Yes/".  The
system is informed that the file has that Nofill attribute.  If you
are not sure what to answer, say /"Yes/".  The variable
ZWEI:*SET-ATTRIBUTE-UPDATES-LIST* controls this query.  Its default
value is :ASK.  Setting the variable to T means Yes; NIL means No.
" ()
  (LET ((NOFILL
	  (FQUERY `(:SELECT T
		    :CHOICES ,FORMAT:Y-OR-N-P-CHOICES)
		  "Should auto-fill mode be disabled for this file? ")))
    (SEND *INTERVAL* ':PUTPROP NOFILL ':NOFILL)
    (IF (EQ (SEND (SEND *INTERVAL* :MAJOR-MODE) ':MODE-HOOK-VALUE)
	    'AUTO-FILL-IF-APPROPRIATE)
	(IF NOFILL
	    (TURN-OFF-MODE 'AUTO-FILL-MODE)
	    (TURN-ON-MODE 'AUTO-FILL-MODE)))
    (SET-ATTRIBUTE-INTERNAL ':NOFILL "Nofill" (IF NOFILL "Yes" NIL) NOFILL))
  DIS-TEXT)

(DEFCOM COM-SET-PATCH-FILE "Changes whether the buffer is a patch file.
Asks whether the buffer should be considered a patch file,
requests a Y-or-N answer.  If you say Y, the buffer will be a patch file.  If
you say N, it won't.  This only matters when the file is loaded.
It offers to
set the Patch-File attribute for the generic pathname attribute list and
updates the attribute line in the buffer when you answer /"Yes/".  The
system is informed that the file has that Patch-File attribute.  If you
are not sure what to answer, say /"Yes/".  The variable
ZWEI:*SET-ATTRIBUTE-UPDATES-LIST* controls this query.  Its default
value is :ASK.  Setting the variable to T means Yes; NIL means No.
" ()
  (LET ((PATCH-FILE
	  (FQUERY `(:SELECT T
		    :CHOICES ,FORMAT:Y-OR-N-P-CHOICES)
		  "Should the buffer be considered a patch file? ")))
    (SEND *INTERVAL* ':PUTPROP PATCH-FILE ':PATCH-FILE)
    (SET-ATTRIBUTE-INTERNAL ':PATCH-FILE "Patch-File" (IF PATCH-FILE "Yes" NIL) PATCH-FILE)
    (SET-ONE-CONTEXT-VARIABLE 'FS:THIS-IS-A-PATCH-FILE PATCH-FILE))
  DIS-TEXT)


(DEFUN STRING-NAMING-CHARACTER-STYLE (STYLE)
  (LET ((CL:*PACKAGE* NIL))
    (FORMAT NIL "~S" (SI:UNPARSE-CHARACTER-STYLE STYLE))))


(DEFCOM COM-SET-DEFAULT-CHARACTER-STYLE 
	"Changes the default character style associated with the buffer.
Prompts for a new character style.  It requires a fully enumerated character 
style value.  It offers to set the default character style for the generic 
pathname attribute list and updates the attribute line in the buffer when 
you answer /"Yes/".  The system is informed that the file uses the specified 
default character style.  If you are not sure what to answer, say /"Yes/".  
The variable ZWEI:*SET-ATTRIBUTE-UPDATES-LIST* controls this query.  Its 
default value is :ASK.  Setting the variable to T means Yes; NIL means No." ()
  (LET* ((DEFAULT (SEND (SEND *INTERVAL* :GET :MAJOR-MODE) :DEFAULT-CHARACTER-STYLE))
	 (NEW (TYPEIN-LINE-ACCEPT `((SCL:CHARACTER-STYLE-FOR-DEVICE
				      :DEVICE ,SI:*B&W-SCREEN*
				      :ALLOW-RELATIVE NIL))
				  :DEFAULT DEFAULT)))
    (SEND *INTERVAL* :PUTPROP NEW :DEFAULT-CHARACTER-STYLE)
    (SET-ATTRIBUTE-INTERNAL ':DEFAULT-CHARACTER-STYLE
			    "Default-character-style"
			    (STRING-NAMING-CHARACTER-STYLE NEW)
			    NEW)
    (SEND (WINDOW-SHEET *WINDOW*) :SET-DEFAULT-CHARACTER-STYLE NEW))
  DIS-ALL)

(DEFUN CHECK-DEFAULT-CHARACTER-STYLE (STYLE-LIST)
  (COND
    (( (LENGTH STYLE-LIST) 3)
     (BARF "~S is not a valid character style (its length is not 3: ~A)."
	   STYLE-LIST STYLE-LIST))
    (T
     (LOOP FOR ITEM IN STYLE-LIST
	   WHEN (NULL ITEM)
	     DO
	       (LET* ((MERGED-STYLE
		       (SI:MERGE-CHARACTER-STYLES (SI:PARSE-CHARACTER-STYLE STYLE-LIST)
		      			  (SEND *INTERVAL* ':GET ':DEFAULT-CHARACTER-STYLE)))
		      (MERGED-STYLE-STRING (STRING-NAMING-CHARACTER-STYLE MERGED-STYLE)))
		 (IF (YES-OR-NO-P
		       (FORMAT NIL
			       "~S is not a valid fully enumerated character style.~
 			        ~% Do you wish to use ~S instead? "
			       STYLE-LIST MERGED-STYLE-STRING))
		     (RETURN (VALUES MERGED-STYLE MERGED-STYLE-STRING))
		     (BARF "Default character style remains unchanged.")))))))
