;;; -*- Syntax: Zetalisp; Mode: LISP; Package: ZWEI; Base: 8 -*-
;;; Command dispatch table functions for ZWEI.
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; The functions in this file implement COMTABs.
;;; This file also contains the basic editor command loop.

;;; A COMTAB is a command table.  It conceptually is indexed by possible user "keystrokes"
;;; (a keystroke may also be a mouse push or anything else like that), and contains
;;; a COMMAND for each one.  A COMMAND may be any of:
;;;   NIL    -- The keystroke is unassigned.  If there is a COMTAB-INDIRECT-TO,
;;;             look in that COMTAB.
;;;   :UNDEFINED -- The keystroke is REALLY unassigned, regardless of indirecting.
;;;   A list -- The command is a synonym, pointing at some other slot in the COMTAB.
;;;             the list should have two elements, the control-meta and the char parts
;;;             of a keystroke on the keyboard.
;;;   Some other symbol -- A command as defined by DEFCOM, q.v.
(DEFSTRUCT (COMTAB :NAMED :CONC-NAME)
  NAME					;The name of this comtab
  KEYBOARD-ARRAY			;Commands gotten by typing on the keyboard.
  MOUSE-ARRAY				;Commands gotten by pushing mouse buttons.
  EXTENDED-COMMANDS			;Alist of long-named commands.
  INDIRECT-TO				;A COMTAB to try when you find NIL in this COMTAB.
  MOUSE-DOCUMENTATION-CACHE		;A string
  OTHER-CHARACTER-SET-KEYBOARD-ARRAYS	;Commands gotten by typing in another charset somehow
  )

(DEFSELECT ((COMTAB NAMED-STRUCTURE-INVOKE))
  (:PRINT-SELF (COMTAB STREAM &REST IGNORE)
   (SI:PRINTING-RANDOM-OBJECT (COMTAB STREAM :TYPEP)
     (PRINC (COMTAB-NAME COMTAB) STREAM)))
  ;;--- For compatibility with old ones while patching this.
  (:DESCRIBE (COMTAB)
   (FORMAT T "~%~S is a ~S.~%" COMTAB 'COMTAB)
   (LABELS ((DESCRIBE-SLOT-INTERNAL (VALUE SLOT-NAME)
	      (SCL:PRESENT VALUE `((DBG:NAMED-LOCATIVE-SLOT)
				   :STRUCTURE ,COMTAB
				   :SYMBOL ,SLOT-NAME
				   :INDENTATION 30))
	      (TERPRI)))
     (MACROLET ((DESCRIBE-SLOT (SLOT)
		  `(DESCRIBE-SLOT-INTERNAL (LOCF (,(INTERN (STRING-APPEND "COMTAB-"
									  (STRING SLOT))
							   "ZWEI")
						  COMTAB))
					   ',SLOT))
		(DESCRIBE-SLOTS (&REST SLOTS)
		  `(PROGN ,@(LOOP FOR SLOT IN SLOTS
				  COLLECT `(DESCRIBE-SLOT ,SLOT)))))
       (DESCRIBE-SLOTS NAME KEYBOARD-ARRAY MOUSE-ARRAY EXTENDED-COMMANDS INDIRECT-TO
		       MOUSE-DOCUMENTATION-CACHE)
       (IF (> (ARRAY-LENGTH COMTAB) 7)
	   (DESCRIBE-SLOT OTHER-CHARACTER-SET-KEYBOARD-ARRAYS)
	 (FORMAT T "~%This is an old-style COMTAB that does not have~@
		    an OTHER-CHARACTER-SET-KEYBOARD-ARRAYS.~2%"))))))

;;; Given a COMTAB and a character like those from the command stream,
;;; return the corresponding command.  If the third arg is non-NIL,
;;; do not chase down when you find a list in the COMTAB.
(DEFUN COMMAND-LOOKUP (CHAR COMTAB &OPTIONAL NO-INDIRECTION-P)
  (DO ((CTB COMTAB) (CH CHAR)
       (KEYBOARD-ARRAY) (COMMAND))
      (NIL)
    (SETQ KEYBOARD-ARRAY (COMTAB-KEYBOARD-ARRAY CTB)
	  COMMAND
	    (COND ((NOT (ARRAYP KEYBOARD-ARRAY))
		   (CDR (ASSQ CH KEYBOARD-ARRAY)))
		  ((MOUSE-CHAR-P CH)
		   (AREF (COMTAB-MOUSE-ARRAY CTB)
			 (CHAR-MOUSE-BUTTON CH)
			 (CHAR-MOUSE-BITS CH)))
		  ((< (CHAR-CODE CH) (ARRAY-DIMENSION-N 1 KEYBOARD-ARRAY))
		   (AREF KEYBOARD-ARRAY
			 (CHAR-CODE CH)
			 (CHAR-BITS CH)))
		  ((> (ARRAY-LENGTH CTB) 7)	;--- New comtab
		   (MULTIPLE-VALUE-BIND (CHAR-SET CHAR-INDEX)
		       (SI:CHAR-CHAR-SET-AND-INDEX CH)
		     (LET ((OTHER-ARRAYS (COMTAB-OTHER-CHARACTER-SET-KEYBOARD-ARRAYS CTB)))
		       (DESTRUCTURING-BIND (NIL KEYBOARD-ARRAY &OPTIONAL DEFAULT-COMMAND)
					   (ASSOC CHAR-SET OTHER-ARRAYS)
			 (OR (CL:TYPECASE KEYBOARD-ARRAY
			       (CL:ARRAY (AREF KEYBOARD-ARRAY CHAR-INDEX (CHAR-BITS CH)))
			       (SYMBOL KEYBOARD-ARRAY)
			       (OTHERWISE (CDR (ASSQ CH KEYBOARD-ARRAY))))
			     ;;--- We only implement default commands when using an array in
			     ;;--- KEYBOARD-ARRAY, sigh.  Do this better sometime.
			     DEFAULT-COMMAND)))))))
    (IF (OR (NOT (LISTP COMMAND)) NO-INDIRECTION-P)
	(AND (OR COMMAND (NULL (SETQ CTB (COMTAB-INDIRECT-TO CTB))))
	     (RETURN COMMAND))
	(SETQ CTB COMTAB
	      CH (MAKE-CHAR (SECOND COMMAND) (FIRST COMMAND))))))

;;; Store COMMAND in the slot of COMTAB denoted by CHAR.
(DEFUN COMMAND-STORE (COMMAND CHAR COMTAB &AUX KEYBOARD-ARRAY)
  (SETQ KEYBOARD-ARRAY (COMTAB-KEYBOARD-ARRAY COMTAB))
  (COND ((NOT (ARRAYP KEYBOARD-ARRAY))
	 (LET ((ELEMENT (ASSQ CHAR KEYBOARD-ARRAY)))
	   (IF ELEMENT (RPLACD ELEMENT COMMAND)
	       (PUSH (CONS CHAR COMMAND) (COMTAB-KEYBOARD-ARRAY COMTAB)))))
	((MOUSE-CHAR-P CHAR)
	 (FLET ((GESTURE-NAME-FOR-MOUSE-CHAR (CHAR)
		  (INTERN
		    (LET* ((CHAR-NAME (FORMAT NIL "~:C" CHAR))
			   (BREAK-LOC (STRING-SEARCH "-mouse" CHAR-NAME)))
		      (STRING-UPCASE
			(STRING-APPEND
			  (SUBSTRING CHAR-NAME 0 BREAK-LOC)
			  (SUBSTRING CHAR-NAME (+ BREAK-LOC 6)))))
		    PKG-KEYWORD-PACKAGE)))
	   (UNLESS (DW:MOUSE-CHAR-GESTURES CHAR)
	     (SETF (DW:MOUSE-CHAR-FOR-GESTURE (GESTURE-NAME-FOR-MOUSE-CHAR CHAR)) CHAR)))
	 (ASET COMMAND
	       (COMTAB-MOUSE-ARRAY COMTAB)
	       (CHAR-MOUSE-BUTTON CHAR)
	       (CHAR-MOUSE-BITS CHAR)))
	((AND (CHARACTERP CHAR) (< (CHAR-CODE CHAR) (ARRAY-DIMENSION-N 1 KEYBOARD-ARRAY)))
	 (ASET COMMAND
	       KEYBOARD-ARRAY
	       (CHAR-CODE CHAR)
	       (CHAR-BITS CHAR)))
	(T (UNLESS (> (ARRAY-LENGTH COMTAB) 7)	;--- new comtab
	     (LET ((NEW (MAKE-COMTAB)))
	       (CL:REPLACE NEW COMTAB)
	       (STRUCTURE-FORWARD COMTAB NEW)
	       (SETQ COMTAB NEW)))
	   (CL:TYPECASE CHAR
	     (SI:BASIC-CHARACTER-SET
	       (LET ((BUCKET (ASSQ CHAR (COMTAB-OTHER-CHARACTER-SET-KEYBOARD-ARRAYS COMTAB))))
		 (UNLESS BUCKET
		   (SETQ BUCKET (LIST CHAR NIL COMMAND))
		   (PUSH BUCKET (COMTAB-OTHER-CHARACTER-SET-KEYBOARD-ARRAYS COMTAB)))
		 (SETF (THIRD BUCKET) COMMAND)))
	     (OTHERWISE
	       (MULTIPLE-VALUE-BIND (CHAR-SET INDEX)
		   (SI:CHAR-CHAR-SET-AND-INDEX CHAR)
		 (LET ((BUCKET (ASSQ CHAR-SET
				     (COMTAB-OTHER-CHARACTER-SET-KEYBOARD-ARRAYS COMTAB))))
		   (UNLESS BUCKET
		     (SETQ BUCKET (LIST CHAR-SET BUCKET NIL))
		     (PUSH BUCKET (COMTAB-OTHER-CHARACTER-SET-KEYBOARD-ARRAYS COMTAB)))
		   (DESTRUCTURING-BIND (NIL KEYBOARD-ARRAY DEFAULT-COMMAND)
				       BUCKET
		     (IGNORE DEFAULT-COMMAND)
		     (CL:TYPECASE KEYBOARD-ARRAY
		       (CL:ARRAY (SETF (AREF KEYBOARD-ARRAY INDEX (CHAR-BITS CHAR)) COMMAND))
		       (OTHERWISE
			 (LET ((INNER-BUCKET (ASSQ CHAR KEYBOARD-ARRAY)))
			   (UNLESS INNER-BUCKET
			     (SETF INNER-BUCKET (CONS CHAR COMMAND))
			     (PUSH INNER-BUCKET (SECOND BUCKET)))
			   (SETF (CDR INNER-BUCKET) COMMAND)))))))))))
  (SETF (COMTAB-MOUSE-DOCUMENTATION-CACHE COMTAB) NIL))

(DEFVAR *COMMAND-TO-EXECUTE*)		 ; bound by COMMAND-EXECUTE, so that before hooks
					 ; can modify it

;;; Execute the result of calling COMMAND-LOOKUP (without the third argument).
;;; This should be given the CHAR as well as the COMMAND, for error message reporting.
;;; The third arg is also for error reporting, and is used if this COMTAB was gotten
;;; from a prefix command.  The elements of the hook-list are applied
;;; to the char before the comand is run, AFTER the error checks are made.
;; *COMMAND-TO-EXECUTE* is bound to the current command, so that a before hook
;;; can alter it.
(DEFUN COMMAND-EXECUTE (COMMAND CHAR &OPTIONAL PREFIX-CHAR HOOK-LIST)
  (LET ((*COMMAND-TO-EXECUTE* COMMAND))
    (COND ((MEMQ COMMAND '(NIL :UNDEFINED))
	   (FUNCALL STANDARD-INPUT ':CLEAR-INPUT)	;More randomness may follow
	   (BARF "~:[~:@C ~;~*~]~:@C is not a defined key.~:[  (Do Dah, Do Dah)~]"
		 (NOT PREFIX-CHAR) PREFIX-CHAR CHAR (NOT (CHAR= CHAR #/m-))))
	  ((AND (SYMBOLP COMMAND)
		(NOT (FBOUNDP COMMAND)))
	   (BARF "~S is not implemented." COMMAND)))
    (SI:WITH-PROCESS-NON-INTERACTIVE-PRIORITY ()
      (DOLIST (HOOK HOOK-LIST)
	(FUNCALL HOOK CHAR))
      (CATCH 'RETURN-FROM-ZWEI-COMMAND
	(FUNCALL *COMMAND-TO-EXECUTE*)))))

(DEFUN FORCE-RETURN-FROM-ZWEI-COMMAND (REDISPLAY-DEGREE)
  (THROW 'RETURN-FROM-ZWEI-COMMAND REDISPLAY-DEGREE))

;;; Push a hook onto the COMMAND-HOOK with the right priority, returning the undo form
(DEFUN COMMAND-HOOK (HOOK HOOK-SYMBOL)
  (LET ((PRI (GET HOOK 'COMMAND-HOOK-PRIORITY)))
    (OR PRI (FERROR NIL "~S is not a valid command hook." HOOK))
    (DO ((L (SYMEVAL HOOK-SYMBOL) (CDR L))
	 (PREV NIL L))
	((OR (NULL L)
	     (> (GET (CAR L) 'COMMAND-HOOK-PRIORITY) PRI))
	 (LET ((X (CONS HOOK L)))
	   (COND (PREV (RPLACD PREV X))
		 (T (SET HOOK-SYMBOL X)))))))
  `(SETQ ,HOOK-SYMBOL (DELQ ',HOOK ,HOOK-SYMBOL)))

(DEFVAR *ALL-THE-COMTABS* ())			;All non-temporary comtabs created

;;; Create a new, empty COMTAB.
(DEFUN CREATE-COMTAB (NAME &OPTIONAL (TEMPORARY-P NIL))
  (LET ((NEW-COMTAB (MAKE-COMTAB NAME (OR NAME "Unnamed")
				 KEYBOARD-ARRAY (MAKE-ARRAY '(300 16.))
				 MOUSE-ARRAY (MAKE-ARRAY '(3 32.)))))
    (UNLESS TEMPORARY-P (PUSH NEW-COMTAB *ALL-THE-COMTABS*))
    NEW-COMTAB))


;;; Create a comtab for just storing mode changes in
(DEFUN CREATE-SPARSE-COMTAB (NAME &OPTIONAL (TEMPORARY-P NIL))
  (LET ((NEW-COMTAB (MAKE-COMTAB NAME (OR NAME "Unnamed")
				 KEYBOARD-ARRAY NIL)))
    (UNLESS TEMPORARY-P (PUSH NEW-COMTAB *ALL-THE-COMTABS*))
    NEW-COMTAB))

;;; Copy a COMTAB.  Copies the arrays, and the list structure of the extended command alist.
;;; NOTE: this function doesn't make the comtab occupy fewer pages, since the array part
;;; and the alist part can't be on the same page anyway, and the alist part is all on one
;;; page since it was consed up all at once.  Furthermore the new copy is not EQ to the
;;; old copy, which screws up comtab indirection.
(DEFUN COPY-COMTAB (OLD-COMTAB)
  (LET ((NEW-COMTAB (CREATE-COMTAB (COMTAB-NAME OLD-COMTAB))))
    (LET ((OKBD (COMTAB-KEYBOARD-ARRAY OLD-COMTAB))
	  (OMSE (COMTAB-MOUSE-ARRAY OLD-COMTAB))
	  (NKBD (COMTAB-KEYBOARD-ARRAY NEW-COMTAB))
	  (NMSE (COMTAB-MOUSE-ARRAY NEW-COMTAB)))
       (DOTIMES (I (ARRAY-DIMENSION-N 1 OKBD))
	 (DOTIMES (J (ARRAY-DIMENSION-N 2 OKBD))
	   (ASET (AREF OKBD I J) NKBD I J)))
       (DOTIMES (I (ARRAY-DIMENSION-N 1 OMSE))
	 (DOTIMES (J (ARRAY-DIMENSION-N 2 OMSE))
	   (ASET (AREF OMSE I J) NMSE I J))))
    (SETF (COMTAB-INDIRECT-TO NEW-COMTAB) (COMTAB-INDIRECT-TO OLD-COMTAB))
    (SETF (COMTAB-EXTENDED-COMMANDS NEW-COMTAB)
	  (AND (COMTAB-EXTENDED-COMMANDS OLD-COMTAB)
	       (LET ((COPY (SI:MAKE-AARRAY
			     (ARRAY-LENGTH (COMTAB-EXTENDED-COMMANDS OLD-COMTAB)))))
		 (COPY-ARRAY-CONTENTS-AND-LEADER (COMTAB-EXTENDED-COMMANDS OLD-COMTAB)
						 COPY)
		 COPY)))
    NEW-COMTAB))

;;; The first argument is a COMTAB to modify; if it is NIL, a new COMTAB is created.
;;; The second argument is a list of specifications.  The elements are considered in
;;; pairs.  The first of a pair is a char name (see COMMAND-CHAR-FROM-NAME below).
;;; The second is indicates the command to store in the slot denoted by that char,
;;; and the second is the command to store.
;;; The first element may be a list, in which case iteration is requested;
;;; it should be a two-list of a command name and an iteration count.
;;; The specified character and that many contiguous slots after it are specified.
;;; The second is then either a symbol to be stored in all of the slots,
;;; or a function to be applied to the char whose slot is under consideration,
;;; in which case what it returns is stored.
;;; The third argument is a list of new entries to be appended to the comtab's
;;; extended command alist.
;;; If a new COMTAB is created, all entries for lower-case keyboard characters
;;; are set to indirect through the corresponding upper-case characters.
(DEFUN SET-COMTAB (COMTAB SPECS &OPTIONAL EXTENDED-COMMANDS)
  (COND ((OR (NULL COMTAB) (STRINGP COMTAB))
	 (SETQ COMTAB (CREATE-COMTAB COMTAB))
	 (SET-COMTAB-UPPERCASE-INDIRECTION COMTAB)))
  (DO L SPECS (CDDR L) (NULL L)
    (COND ((LISTP (CAR L))
	   (DO ((CHAR (CHAR-CODE (COMMAND-CHAR-FROM-NAME (CAAR L))) (1+ CHAR))
		(BITS (CHAR-BITS (COMMAND-CHAR-FROM-NAME (CAAR L))))
		(I 0 (1+ I))
		(TO (CADAR L))
		(COMMAND (CADR L)))
	       (( I TO))
	     (COMMAND-STORE (IF (SYMBOLP COMMAND)
				COMMAND
				(FUNCALL COMMAND (CODE-CHAR CHAR)))
			    (CODE-CHAR CHAR BITS)
			    COMTAB)))
	(T (COMMAND-STORE (CADR L) (COMMAND-CHAR-FROM-NAME (CAR L)) COMTAB))))
  (WHEN EXTENDED-COMMANDS
    (LET ((AARRAY (COMTAB-EXTENDED-COMMANDS COMTAB)))
      (UNLESS AARRAY
	(SETQ AARRAY (SI:MAKE-AARRAY (LENGTH EXTENDED-COMMANDS)
				     :NAME (LET ((NAME (COMTAB-NAME COMTAB)))
					     (WHEN (AND NAME (NOT (CL:EQUAL NAME "Unnamed")))
					       (FORMAT NIL "extended commands for ~A comtab"
						       NAME)))))
	(SETF (COMTAB-EXTENDED-COMMANDS COMTAB) AARRAY))
      (LOOP FOR COMMAND IN EXTENDED-COMMANDS DO
	(MULTIPLE-VALUE-BIND (STRING COMMAND-SYMBOL)
	    (IF (LISTP COMMAND)
		(VALUES (CAR COMMAND) (CDR COMMAND))
	      (LET ((NAME (GET COMMAND 'COMMAND-NAME))) ;Support obsolete syntax indefinitely
		(WHEN (NULL NAME)
		  ;; Don't FSIGNAL, which would inappropriately
		  ;; require manual intervention while loading.
		  (SCL:WARN "~S is not a defined command.  It will be omitted from the alist."
			    COMMAND))
		(VALUES NAME COMMAND)))
	  (WHEN STRING
	    (SI:AARRAY-INSERT AARRAY STRING COMMAND-SYMBOL T))))
;     (SI:SORT-AARRAY AARRAY)
      ))
  COMTAB)

;;; Make lower-case characters in this COMTAB all indirect to the
;;; corresponding upper-case characters.
;;; Do this only for non-control characters
(DEFUN SET-COMTAB-UPPERCASE-INDIRECTION (COMTAB)
  (LET ((ARRAY (COMTAB-KEYBOARD-ARRAY COMTAB)))
    (LOOP FOR CHAR FROM (CHAR-CODE #/a) TO (CHAR-CODE #/z)
	  DO (ASET (LIST 0 (CHAR-UPCASE (CODE-CHAR CHAR))) ARRAY CHAR 0))))

;;; Simulate the effect of the Teco 7-bit character set
;;; But only store over undefined commands
(DEFUN SET-COMTAB-CONTROL-INDIRECTION (COMTAB)
  (LET ((ARRAY (COMTAB-KEYBOARD-ARRAY COMTAB)))
    ;;Indirect things like Tab to things like control-I
    (DOLIST (CHAR '(#\CR #\LF #\TAB #\BS #\FF))
      (WHEN (NULL (AREF ARRAY (CHAR-CODE CHAR) 0))
	(ASET (LIST 1 (CODE-CHAR (+ (ASCII-CODE CHAR) #o100))) ARRAY (CHAR-CODE CHAR) 0)))
    ;;Indirect all meta things through the corresponding non-meta thing
    (DO I 2 (1+ I) (= I 4)
      (DOTIMES (CHAR (ARRAY-DIMENSION-N 1 ARRAY))
	(AND (NULL (AREF ARRAY CHAR I))
	     (ASET (LIST (- I 2) (CODE-CHAR CHAR)) ARRAY CHAR I))))
    ;;Indirect controls other than atsign through underscore to non-controls
    (DOTIMES (CHAR (ARRAY-DIMENSION-N 1 ARRAY))
      (AND (NOT (AND ( CHAR (CHAR-CODE #/@)) ( CHAR (CHAR-CODE #/_))))
	   (NULL (AREF ARRAY CHAR 1))
	   (ASET (LIST 0 (CODE-CHAR CHAR)) ARRAY CHAR 1)))))

;;; Take a SET-COMTAB form, and make a second form that will undo what the first does.
;;; And let's get these redundant functions together.
(DEFUN MAKE-SET-COMTAB-UNDO-LIST (FORM)
  (FUNCALL (GET 'SET-COMTAB :UNDO-FUNCTION) FORM))

(DEFMACRO SET-COMTAB-RETURN-UNDO (&REST FORM)
  (PUSH 'SET-COMTAB FORM)
  `(LET ((UNDO (MAKE-SET-COMTAB-UNDO-LIST ',FORM)))
     ,FORM
     UNDO))

;;; SET-COMTAB undo function
(DEFUN (:PROPERTY SET-COMTAB :UNDO-FUNCTION) (FORM)
  (LET ((COMTAB (EVAL (SECOND FORM))))
    (IF (NULL COMTAB)
	(PROGN (FORMAT T "A (SET-COMTAB NIL ...) form cannot be undone.")
	       '(IGNORE))
	(LOOP FOR (CHAR-NAME FUNCTION) ON (EVAL (THIRD FORM)) BY 'CDDR
	      APPEND (COND ((NLISTP CHAR-NAME)
			    (LIST CHAR-NAME
				  (COMMAND-LOOKUP (COMMAND-CHAR-FROM-NAME CHAR-NAME) COMTAB)))
			   ((SYMBOLP FUNCTION)	;Simple command
			    (LOOP WITH (START COUNT) = CHAR-NAME
				  REPEAT COUNT
				  FOR CHAR FIRST (COMMAND-CHAR-FROM-NAME START)
					   THEN (CHAR-SUCCESSOR CHAR)
				  APPEND (LIST CHAR
					       (COMMAND-LOOKUP
						 (COMMAND-CHAR-FROM-NAME CHAR)
						 COMTAB))))
			   (T
			    (FERROR NIL
			      "A SET-COMTAB with an iteration function cannot be undone.")))
	         INTO UN-SPECS
	      FINALLY
	         (RETURN `(PROGN (REMOVE-EXTENDED-COMMANDS
				   ',(EVAL (FOURTH FORM))
				   ',COMTAB)
				 (SET-COMTAB ',COMTAB ',UN-SPECS)))))))

(DEFUN MAJOR-MODE-SET-COMTAB (MODE-KEYWORD SPECS)
  (PUSH `(SET-COMTAB *MODE-COMTAB* ',SPECS)
	(SEND (MAJOR-MODE-FROM-KEYWORD MODE-KEYWORD) ':USER-MODE-FORMS)))

(DEFUN (MAJOR-MODE-SET-COMTAB :UNDO-FUNCTION) (FORM)
  (LET ((MODE-KEYWORD (EVAL (SECOND FORM))))
    `(SEND (MAJOR-MODE-FROM-KEYWORD ',MODE-KEYWORD)
	   ':SET-USER-MODE-FORMS
	   ',(SEND (MAJOR-MODE-FROM-KEYWORD MODE-KEYWORD) ':USER-MODE-FORMS))))

(DEFUN REMOVE-EXTENDED-COMMANDS (COMMAND-LIST COMTAB)
  (LET ((AARRAY (COMTAB-EXTENDED-COMMANDS COMTAB)))
    (WHEN AARRAY
      (LOOP FOR (STRING . COMMAND) IN COMMAND-LIST DO
	(SI:AARRAY-DELETE AARRAY STRING COMMAND T)))))

;;; Set the indirection of OF to TO.
(DEFUN SET-COMTAB-INDIRECTION (OF TO)
  (SETF (COMTAB-INDIRECT-TO OF) TO))

;;; This takes a string specification of a command char (the numeric code for
;;; a keystroke), and returns the command char.  Specifications may look like:
;;;   "A", "B", "V", "", etc., referring to keyboard characters.
;;;   "MOUSE-n-m", where n and m are numbers relating which button and how many clicks.
;;; Note: this function is semi-obselete, since the reader allows specification of all
;;; characters.
(DEFUN COMMAND-CHAR-FROM-NAME (NAME)
  (COND ((NUMBERP NAME) (CODE-CHAR NAME))
	((MOUSE-CHAR-P NAME) NAME)
	((CHARACTERP NAME) NAME)
	(T (LET ((I (STRING-MATCH "MOUSE" NAME)))
	     (COND ((NULL I)
		    ;; The name does not start with MOUSE.
		    (LET ((CHAR1 (AREF NAME 0)))
		      (LET ((X (ASSQ CHAR1 '((#/ . 0) (#/ . 1) (#/ . 2) (#/ . 3)))))
			(COND ((NULL X) CHAR1)
			      (T (MAKE-CHAR (AREF NAME 1) (CDR X)))))))
		   (T
		    (MULTIPLE-VALUE-BIND (BUTTON J)
			(PARSE-NUMBER NAME (1+ I))
		      (LET ((N-CLICKS (PARSE-NUMBER NAME (1+ J))))
			(COND ((OR (GREATERP 1 BUTTON 3)
				   (GREATERP 1 N-CLICKS 2))
			       (FERROR NIL "Invalid mouse specification ~A" NAME))
			      (T
			       (MAKE-MOUSE-CHAR (1- BUTTON) (* 20 (1- N-CLICKS)))))))))))))

(DEFUN KEY-EXECUTE (KEY &OPTIONAL (*NUMERIC-ARG-P* NIL) (*NUMERIC-ARG* 1))
  (PROCESS-COMMAND-CHAR KEY)
  DIS-NONE)

;; This is the Meta-X command.
;; Note that numeric arg is transmitted via dynamic scoping etc.
(DEFCOM COM-EXTENDED-COMMAND "" ()
  (LET ((ANS (GET-EXTENDED-COMMAND (FORMAT NIL "Extended command:~:[  (Arg = ~A)~]"
					    (NOT *NUMERIC-ARG-P*)
					    (FORMAT-ARGUMENT *NUMERIC-ARG-P* *NUMERIC-ARG*))
				   *COMTAB*)))
    (LET ((*CURRENT-COMMAND* ANS))
      (FUNCALL *CURRENT-COMMAND*))))

(DEFUN FORMAT-ARGUMENT (ARG-P ARG)
  (SELECTQ ARG-P
    (NIL "")
    (:SIGN (IF (MINUSP ARG) "-" "+"))
    (:DIGITS (FORMAT NIL "~D" ARG))
    (:CONTROL-U
     (FORMAT NIL "C-U (~D)" ARG))
    (:INFINITY (IF (MINUSP ARG) "-" ""))))

(DEFPROP COM-EXTENDED-COMMAND DOCUMENT-EXTENDED-COMMAND DOCUMENTATION-FUNCTION)
(DEFUN DOCUMENT-EXTENDED-COMMAND (COMMAND CHAR OP)
  (SELECTQ OP
    ((:NAME) "a prefix for extended commands")
    ((:FULL :SHORT)
     (FORMAT T "Completing reads and executes a command from the mini buffer.~%")
     (WHEN (EQ OP ':FULL)
       (SETQ COMMAND (GET-EXTENDED-COMMAND "Type a command to document:" *COMTAB*))
       (FORMAT T "~%~:C " CHAR)
       (SCL:PRESENT COMMAND 'EXTENDED-COMMAND-NAME)
       (FORMAT T " is ")
       (SCL:PRESENT COMMAND 'EXTENDED-COMMAND-NAME)
       (FORMAT T ", implemented by ")
       (SCL:PRESENT COMMAND 'SYS:FUNCTION-SPEC)
       (SI:WITH-INDENTATION (STANDARD-OUTPUT 3)
	 (FORMAT T ":~%")
	 (PRINT-DOC OP COMMAND CHAR))))))

(DEFUN GET-EXTENDED-COMMAND (PROMPT COMTAB)
  (TYPEIN-LINE-ACCEPT `((EXTENDED-COMMAND-NAME :COMTAB ,COMTAB))
		      :PROVIDE-DEFAULT NIL :PROMPT PROMPT :PROMPT-MODE :RAW))

(SCL:DEFINE-PRESENTATION-TYPE EXTENDED-COMMAND-NAME ((&KEY COMTAB (ALIST *COMMAND-ALIST*)))
  :HISTORY NIL
  :PARSER ((STREAM &KEY ORIGINAL-TYPE)
	   (LET ((DELIMITERS '(#\Space)))
	     (DW::WITH-COMMAND-TOKEN-COMPLETION-CACHES (STRING-CACHE COMPLETION-BOUNDS-TABLE)
	       (VALUES
		 (DW:COMPLETE-INPUT STREAM
		   (IF COMTAB
		       (LAMBDA (STRING ACTION)
			 (DECLARE (SYS:DOWNWARD-FUNCTION))
			 (COMTAB-EXTENDED-COMMAND-NAME-COMPLETER
			   STRING-CACHE COMPLETION-BOUNDS-TABLE DELIMITERS
			   STRING COMTAB ACTION))
		       (LAMBDA (STRING ACTION)
			 (DECLARE (SYS:DOWNWARD-FUNCTION))
			 (DW:SUGGESTION-COMPLETER
			   (STRING :ACTION ACTION
				   :DELIMITERS DELIMITERS)
			   (CL:MAP ()
				   (LAMBDA (ELEM)
				     (DW:SUGGEST (CAR ELEM) (CDR ELEM)))
				   ALIST))))
		   :ALLOW-ANY-INPUT NIL
		   :TYPE ORIGINAL-TYPE
		   :DOCUMENTER (LAMBDA (COMMAND STANDARD-OUTPUT)
				 (PRINT-DOC ':FULL COMMAND))
		   :DOCUMENT :IF-UNIQUE
		   :HELP-OFFERS-POSSIBILITIES ':WITHIN-TOKEN
		   :PARTIAL-COMPLETERS DELIMITERS)))))
  :PRINTER ((COMMAND-NAME STREAM)
	    (CL:WRITE-STRING
	      (OR (IF COMTAB
		      (EXTENDED-COMMAND-NAME COMMAND-NAME COMTAB)
		      (CAR (CL:RASSOC COMMAND-NAME ALIST)))
		  (GET COMMAND-NAME 'COMMAND-NAME))
	      STREAM))
  :DESCRIBER ((STREAM)
	      (IF (AND COMTAB (NOT (STRING= (COMTAB-NAME COMTAB) "Unnamed")))
		  (FORMAT STREAM "an extended command for ~A" (COMTAB-NAME COMTAB))
		  (CL:WRITE-STRING "an extended command" STREAM))))

(DEFUN COMTAB-EXTENDED-COMMAND-NAME-COMPLETER (STRING-CACHE COMPLETION-BOUNDS-TABLE DELIMITERS
					       STRING COMTAB ACTION)
  (DW::COMMAND-TOKEN-SUGGESTION-COMPLETER (STRING-CACHE COMPLETION-BOUNDS-TABLE
					   DELIMITERS STRING ACTION)
    (DO ((COMTAB COMTAB (COMTAB-INDIRECT-TO COMTAB)))
	((NULL COMTAB))
      (LET ((AARRAY (COMTAB-EXTENDED-COMMANDS COMTAB)))
	(WHEN AARRAY
	  (DW::MAKE-SUGGESTIONS AARRAY))))))

(DEFUN MAP-OVER-COMTAB-EXTENDED-COMMANDS (COMTAB FUNCTION)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (DO ((COMTAB COMTAB (COMTAB-INDIRECT-TO COMTAB)))
      ((NULL COMTAB))
    (LET ((AARRAY (COMTAB-EXTENDED-COMMANDS COMTAB)))
      (WHEN AARRAY
	(LOOP FOR ITEM BEING THE ARRAY-ELEMENTS OF AARRAY
	      DO (FUNCALL FUNCTION ITEM))))))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR EXTENDED-COMMAND-NAME
  (EXTENDED-COMMAND-NAME "" *COMTAB*
			 :GESTURE :SELECT
			 :DOCUMENTATION ((COMMAND-NAME)
					 (FORMAT NIL "~A~@[: ~A~]"
						 (GET COMMAND-NAME 'COMMAND-NAME)
						 (GET COMMAND-NAME 'DOCUMENTATION)))
			 :TESTER ((COMMAND-NAME &REST IGNORE)
				  (BLOCK FOUND
				    (MAP-OVER-COMTAB-EXTENDED-COMMANDS
				      *COMTAB*
				      #'(LAMBDA (ELEM)
					  (WHEN (EQ COMMAND-NAME (CDR ELEM))
					    (RETURN-FROM FOUND T))))
				    NIL)))

  (COMMAND-NAME)
  `(,COMMAND-NAME))

(DEFUN READ-EXTENDED-COMMAND-NAME (ALIST PROMPT &OPTIONAL INITIAL-COMPLETE)
  (TYPEIN-LINE-ACCEPT `((EXTENDED-COMMAND-NAME :ALIST ,ALIST))
		      :PROVIDE-DEFAULT NIL :PROMPT PROMPT :PROMPT-MODE :RAW
		      :INITIAL-COMPLETE INITIAL-COMPLETE))

;;; Doesn't get called; what to do?
(DEFUN EXTENDED-COMMAND-COMPLETING-DOCUMENTER (X)
  (LET ((STANDARD-OUTPUT *TYPEOUT-WINDOW*))
    (PRINT-DOC ':FULL (CDR X))))

(DEFCOM COM-ANY-EXTENDED-COMMAND "Execute any loaded zwei command, even if not assigned" ()
  (WHEN (EQ (CAAR *MINI-BUFFER-COMMAND-IN-PROGRESS*) 'COM-EXTENDED-COMMAND)
    ;; This turns M-X into C-M-X
    (RE-EXECUTE-MINI-BUFFER-COMMAND
	`((COM-ANY-EXTENDED-COMMAND ,*NUMERIC-ARG-P* ,*NUMERIC-ARG*)
	  ,(STRING-APPEND (BP-LINE (POINT))))))	;Start with what was typed already
  (LET ((ANS (GET-ANY-EXTENDED-COMMAND
		 (FORMAT NIL "Command:~:[  (Arg = ~A)~]"
			 (NOT *NUMERIC-ARG-P*)
			 (FORMAT-ARGUMENT *NUMERIC-ARG-P* *NUMERIC-ARG*)))))
    (LET ((*CURRENT-COMMAND* ANS))
      (FUNCALL *CURRENT-COMMAND*))))

(DEFUN GET-ANY-EXTENDED-COMMAND (PROMPT &OPTIONAL INITIAL-COMPLETE)
  (READ-EXTENDED-COMMAND-NAME *COMMAND-ALIST* PROMPT INITIAL-COMPLETE))

(DEFUN MAKE-EXTENDED-COMMAND (THE-COMTAB)
  (LET-CLOSED ((COMTAB THE-COMTAB))
    'MAKE-EXTENDED-COMMAND-INTERNAL))

(DEFUN MAKE-EXTENDED-COMMAND-INTERNAL (&AUX (PREFIX-CHAR *LAST-COMMAND-CHAR*))
  (DECLARE (SPECIAL COMTAB))
  (WHEN *ARGUMENT-PROMPT-DELAY*
    (WAIT-FOR-POSSIBLE-TYPEAHEAD *ARGUMENT-PROMPT-DELAY*))
  (LET ((CHAR (EDITOR-INPUT :NO-HANG T :MOUSE :RETURN)))
    (COND ((NULL CHAR)				;Have to wait for it, so prompt
	   (PROMPT-LINE "~:[~*~;~A ~]~:@C: "
			*NUMERIC-ARG-P* (FORMAT-ARGUMENT *NUMERIC-ARG-P* *NUMERIC-ARG*)
			PREFIX-CHAR)
	   (SETQ CHAR (PROMPT-LINE-ACTIVATE
			(EDITOR-INPUT :MOUSE :RETURN)))
	   (WHEN (MOUSE-CHAR-P CHAR) (BARF))	;don't check mouse chars, please
	   (WHEN (ZEROP (CHAR-BITS CHAR))
	     (SETQ CHAR (CHAR-UPCASE CHAR)))
	   (PROMPT-LINE-MORE "~:@C" CHAR)
	   (FUNCALL *MODE-LINE-WINDOW* ':DONE-WITH-MODE-LINE-WINDOW)))
    (WHEN (MOUSE-CHAR-P CHAR) (BARF))
    (SETQ *LAST-COMMAND-CHAR* CHAR))
  (SETQ *CURRENT-COMMAND* (COMMAND-LOOKUP *LAST-COMMAND-CHAR* COMTAB))
  (COMMAND-EXECUTE *CURRENT-COMMAND* *LAST-COMMAND-CHAR* PREFIX-CHAR))

(DEFUN GET-PREFIX-COMMAND-COMTAB (X)
  (SYMEVAL-IN-CLOSURE X 'COMTAB))

(DEFUN PREFIX-COMMAND-P (X &AUX TEM)
  (AND (CLOSUREP X)
       (SETQ TEM (CADR (%MAKE-POINTER DTP-LIST X)))
       (EQ (%FIND-STRUCTURE-HEADER TEM) 'COMTAB)))

(DEFUN MACRO-COMMAND-P (X &AUX TEM)
  (AND (CLOSUREP X)
       (SETQ TEM (CADR (%MAKE-POINTER DTP-LIST X)))
       (EQ (%FIND-STRUCTURE-HEADER TEM) 'SYMBOL)))

(DEFUN MAKE-MACRO-COMMAND (THE-SYMBOL &OPTIONAL MOUSE-P)
  (UNLESS (OR (GET THE-SYMBOL 'DOCUMENTATION)
	      (GET THE-SYMBOL 'DOCUMENTATION-FUNCTION))
    (PUTPROP THE-SYMBOL (FORMAT NIL "Keyboard macro ~S" THE-SYMBOL) 'DOCUMENTATION))
  (LET-CLOSED ((SYMBOL THE-SYMBOL)
               (MOVE-TO-MOUSE-P MOUSE-P)
               (PREVIOUS-COMMAND NIL))
    #'(LAMBDA ()
        (LET ((MAC (GET SYMBOL 'MACRO-STREAM-MACRO)))
          (OR MAC (BARF "The macro ~A is not defined." SYMBOL))
          (OR (MEMQ ':MACRO-EXECUTE (FUNCALL STANDARD-INPUT ':WHICH-OPERATIONS))
              (BARF "The input stream does not support macros."))
          (AND MOVE-TO-MOUSE-P
               (MOVE-POINT (MOUSE-BP *WINDOW* *MOUSE-X* *MOUSE-Y*)))
          (FUNCALL STANDARD-INPUT ':MACRO-EXECUTE MAC
                   (AND *NUMERIC-ARG-P* *NUMERIC-ARG*) T)
          DIS-NONE))))

(DEFUN MOUSE-MACRO-COMMAND-LAST-COMMAND (COMMAND)
  (OR (MACRO-COMMAND-P COMMAND)
      (BARF "That command is not a keyboard macro"))
  (SYMEVAL-IN-CLOSURE COMMAND 'PREVIOUS-COMMAND))

(DEFUN SET-MOUSE-MACRO-COMMAND-LAST-COMMAND (COMMAND OLD-VALUE)
  (OR (MACRO-COMMAND-P COMMAND)
      (BARF "That command is not a keyboard macro"))
  (SET-IN-CLOSURE COMMAND 'PREVIOUS-COMMAND OLD-VALUE))

(DEFMACRO KEY-FOR-COMMAND-CHECK (THIS-COMMAND THIS-CHAR CTB)
  `(LET ((THIS-COMMAND ,THIS-COMMAND))
     (COND ((NULL THIS-COMMAND))		;speed bum, makes it about 40% faster
	   ((AND (EQ THIS-COMMAND COMMAND)
		 (EQ (COMMAND-LOOKUP ,THIS-CHAR ORIGINAL-COMTAB) COMMAND))
	    (RETURN-FROM TOP (VALUES (FORMAT NIL "~@:C" ,THIS-CHAR)
				     ,THIS-CHAR ,CTB)))
	   ((AND (EQ THIS-COMMAND 'COM-DOCUMENTATION)
		 (SETQ TEM (RASSQ COMMAND *COM-DOCUMENTATION-ALIST*))
		 (EQ (COMMAND-LOOKUP ,THIS-CHAR ORIGINAL-COMTAB) THIS-COMMAND))
	    (RETURN-FROM TOP (VALUES (FORMAT NIL "~:@C ~:@C" ,THIS-CHAR (CAR TEM))
				     ,THIS-CHAR ,CTB)))
	   ((AND (TYPEP THIS-COMMAND ':CLOSURE)
		 (PREFIX-COMMAND-P THIS-COMMAND)
		 (SETQ TEM (KEY-FOR-COMMAND COMMAND (GET-PREFIX-COMMAND-COMTAB THIS-COMMAND)))
		 (EQ (COMMAND-LOOKUP ,THIS-CHAR ORIGINAL-COMTAB) THIS-COMMAND))
	    (RETURN-FROM TOP (VALUES (FORMAT NIL "~:@C ~A" ,THIS-CHAR TEM)
				     ,THIS-CHAR ,CTB))))))

(DEFUN KEY-FOR-COMMAND (COMMAND &OPTIONAL (COMTAB *COMTAB*) (START-CHAR (CODE-CHAR 0))
			                  (ORIGINAL-COMTAB COMTAB))
 (DECLARE (VALUES STRING CHARACTER FOUND-COMTAB))
 (LOOP NAMED TOP WITH TEM
       AS CTB = COMTAB THEN (COMTAB-INDIRECT-TO CTB)
       WHILE CTB
       AS STARTING-CHAR FIRST START-CHAR THEN (CODE-CHAR 0)
       AS MOUSE-START-CHAR = (MOUSE-CHAR-P STARTING-CHAR)
       AS KEYBOARD-ARRAY = (COMTAB-KEYBOARD-ARRAY CTB)
       WHEN (NOT (ARRAYP KEYBOARD-ARRAY))
       DO (DOLIST (ELT KEYBOARD-ARRAY)
	    (AND (OR (AND (CHARACTERP (CAR ELT))
			  (NOT MOUSE-START-CHAR)
			  (CHAR STARTING-CHAR (CAR ELT)))
		     (AND (MOUSE-CHAR-P (CAR ELT))
			  (OR (NOT MOUSE-START-CHAR)
			      (SI:CHAR-MOUSE- STARTING-CHAR (CAR ELT))))) ;need to be global?
		 (KEY-FOR-COMMAND-CHECK (CDR ELT) (CAR ELT) CTB)))
       ELSE WHEN (NOT MOUSE-START-CHAR)
	      DO
		;; Row major and column major have slightly different
		;; semantics because of how they reset indices.  That's
		;; actually OK, since STARTING-CHAR is a piece of
		;; coroutine state
		(LOOP WITH MAX-CH = (ARRAY-DIMENSION-N 1 KEYBOARD-ARRAY)
		      WITH MAX-BT = (ARRAY-DIMENSION-N 2 KEYBOARD-ARRAY)
		      FOR CH UPFROM (CHAR-CODE STARTING-CHAR) BELOW MAX-CH
		      FOR START-BITS = (CHAR-BITS STARTING-CHAR) THEN 0
		      DO (LOOP WITH PTR = (LOCF (AREF KEYBOARD-ARRAY CH 0))
			       FOR BITS UPFROM START-BITS BELOW MAX-BT
			       DO (KEY-FOR-COMMAND-CHECK (%P-CONTENTS-OFFSET PTR BITS)
							 (CODE-CHAR CH BITS)
							 CTB)))
       AS MOUSE-ARRAY = (COMTAB-MOUSE-ARRAY CTB)
       WHEN MOUSE-ARRAY
	 DO
	   (LOOP WITH MAX-CH = (ARRAY-DIMENSION-N 1 MOUSE-ARRAY)
		 WITH MAX-BT = (ARRAY-DIMENSION-N 2 MOUSE-ARRAY)
		 FOR CH UPFROM (IF MOUSE-START-CHAR
				   (CHAR-MOUSE-BUTTON STARTING-CHAR)
				   0)
			BELOW MAX-CH
		 FOR START-BITS = (IF MOUSE-START-CHAR
				      (CHAR-MOUSE-BITS STARTING-CHAR)
				      0)
				THEN 0
		 DO (LOOP WITH PTR = (LOCF (AREF MOUSE-ARRAY CH 0))
			  FOR BITS UPFROM START-BITS BELOW MAX-BT
			  DO (KEY-FOR-COMMAND-CHECK
			       (%P-CONTENTS-OFFSET PTR BITS)
			       (MAKE-MOUSE-CHAR CH BITS)
			       CTB)))))

(DEFMACRO COMMAND-AVAILABLE-CHECK (THIS-COMMAND THIS-CHAR)
  `(LET ((THIS-COMMAND ,THIS-COMMAND))
     (AND (OR (EQ THIS-COMMAND COMMAND)
	      (AND (EQ THIS-COMMAND 'COM-DOCUMENTATION)
		   (RASSQ COMMAND *COM-DOCUMENTATION-ALIST*))
	      (AND (TYPEP THIS-COMMAND ':CLOSURE)
		   (PREFIX-COMMAND-P THIS-COMMAND)
		   (KEY-FOR-COMMAND COMMAND (GET-PREFIX-COMMAND-COMTAB THIS-COMMAND))))
	  (EQ (COMMAND-LOOKUP ,THIS-CHAR COMTAB) THIS-COMMAND))))

(DEFUN COMMAND-AVAILABLE (COMMAND &OPTIONAL (COMTAB *COMTAB*))
  (LOOP AS CTB = COMTAB THEN (COMTAB-INDIRECT-TO CTB)
	WHILE CTB
	AS KEYBOARD-ARRAY = (COMTAB-KEYBOARD-ARRAY CTB)
	THEREIS (IF (NOT (ARRAYP KEYBOARD-ARRAY))
		    (LOOP FOR ELT IN KEYBOARD-ARRAY
			  THEREIS (COMMAND-AVAILABLE-CHECK (CDR ELT) (CAR ELT)))
		    (LOOP WITH MAX-CH = (ARRAY-DIMENSION-N 1 KEYBOARD-ARRAY)
			  WITH MAX-BT = (ARRAY-DIMENSION-N 2 KEYBOARD-ARRAY)
			  FOR CH BELOW MAX-CH
			  THEREIS (LOOP WITH PTR = (LOCF (AREF KEYBOARD-ARRAY CH 0))
					FOR BITS BELOW MAX-BT
					THEREIS (COMMAND-AVAILABLE-CHECK
						  (%P-CONTENTS-OFFSET PTR BITS)
						  (CODE-CHAR CH BITS)))))
	THEREIS (CL:FIND COMMAND (COMTAB-EXTENDED-COMMANDS CTB) :KEY #'CDR)
	AS MOUSE-ARRAY = (COMTAB-MOUSE-ARRAY CTB)
	WHEN MOUSE-ARRAY
	 THEREIS
	   (LOOP WITH MAX-CH = (ARRAY-DIMENSION-N 1 MOUSE-ARRAY)
		 WITH MAX-BT = (ARRAY-DIMENSION-N 2 MOUSE-ARRAY)
		 FOR CH BELOW MAX-CH
		 THEREIS (LOOP WITH PTR = (LOCF (AREF MOUSE-ARRAY CH 0))
			       FOR BITS BELOW MAX-BT
			       THEREIS (COMMAND-AVAILABLE-CHECK
					 (%P-CONTENTS-OFFSET PTR BITS)
					 (MAKE-MOUSE-CHAR CH BITS))))))

;;; Given a character, return what character that would get a command from
(DEFUN COMTAB-CHAR-INDIRECTION (CHAR &OPTIONAL (COMTAB *COMTAB*))
  (DO ((CH CHAR (MAKE-CHAR (SECOND NCH) (FIRST NCH)))
       (NCH))
      ((NLISTP (SETQ NCH (COMMAND-LOOKUP CH COMTAB T)))
       CH)))

;;; The command loop.

;;; This is the fundamental ZWEI command loop.  It takes a COMTAB and a window,
;;; and lets the user edit the window using the COMTAB.  It finds the interval
;;; to edit by looking in the window.  This binds all of the standard per-invocation
;;; globals, except PACKAGE, which the caller must bind.

(DEFRESOURCE COMMAND-LOOPS (COMTAB WINDOW TYPE)
  :CONSTRUCTOR (MAKE-COMMAND-LOOP COMTAB WINDOW TYPE)
  )

(DEFUN COMMAND-LOOP (COMTAB WINDOW &OPTIONAL (TYPE 'EDITOR) DESCRIPTION (COMMAND T))
  (USING-RESOURCE (INSTANCE COMMAND-LOOPS COMTAB WINDOW (OR TYPE 'EDITOR))
    (SEND INSTANCE ':EDIT (SEND INSTANCE ':TOP-LEVEL-P) DESCRIPTION COMMAND)))

(DEFUN MAKE-COMMAND-LOOP (COMTAB WINDOW &OPTIONAL (TYPE 'EDITOR) &REST OPTIONS)
  (LEXPR-FUNCALL #'MAKE-INSTANCE TYPE :*COMTAB* COMTAB :*WINDOW* WINDOW OPTIONS))

(DEFMETHOD (:INIT EDITOR :AFTER) (IGNORE)
  (SETQ *INTERVAL* (WINDOW-INTERVAL *WINDOW*)))

(DEFVAR *EDITORS-WHOSE-MODES-TO-RESET* NIL)
(DEFUN RESET-ALL-EDITOR-MODES ()
  (DOLIST (EDITOR *EDITORS-WHOSE-MODES-TO-RESET*)
    (SET-IN-INSTANCE EDITOR '*USER-MODES-SET* NIL)))

(ADD-INITIALIZATION "RESET-ALL-EDITOR-MODES"
                    '(RESET-ALL-EDITOR-MODES)
                    '(LOGOUT))

(DEFMETHOD (:INIT TOP-LEVEL-EDITOR :AFTER) (IGNORE)
  (SETQ *MODE-COMTAB* (CREATE-SPARSE-COMTAB NIL))
  (SET-COMTAB-INDIRECTION *MODE-COMTAB* *COMTAB*)
  (SETQ *COMTAB* *MODE-COMTAB*)
  (SETQ *MODE-CONTROL-X-COMTAB* (CREATE-SPARSE-COMTAB NIL))
  (SET-COMTAB-INDIRECTION *MODE-CONTROL-X-COMTAB* *STANDARD-CONTROL-X-COMTAB*)
  (SET-COMTAB *COMTAB*
	      (LIST #\c-X (MAKE-EXTENDED-COMMAND *MODE-CONTROL-X-COMTAB*)))
  (SETQ *MODE-WORD-SYNTAX-TABLE* (COPY-SYNTAX-TABLE *WORD-SYNTAX-TABLE*)
	*MODE-LIST-SYNTAX-TABLE* (COPY-SYNTAX-TABLE *LIST-SYNTAX-TABLE*))
  (PUSH SELF *EDITORS-WHOSE-MODES-TO-RESET*)
 ;(COMTAB-MOUSE-PROMPT *COMTAB* (WINDOW-WHO-LINE-DOCUMENTATION-STRING *WINDOW*))
  (PUSH* *WINDOW* *WINDOW-LIST*)
  (SETQ TV:IO-BUFFER (WINDOW-IO-BUFFER *WINDOW*))
  (SETQ *TYPEOUT-WINDOW* (WINDOW-TYPEOUT-WINDOW *WINDOW*))
  (MULTIPLE-VALUE (*MODE-LINE-WINDOW* *TYPEIN-WINDOW* *MINI-BUFFER-WINDOW*)
    (WINDOW-MODE-LINE-WINDOWS *WINDOW*))
  ;; Recompute which package READs should be done in, and set up the major mode.
  ;; Note: for editor-for-temporary-mini-buffer, the interval is just a node.
  (LET ((PKG (SEND *INTERVAL* ':SEND-IF-HANDLES ':GET ':PACKAGE))
	(MODE (OR (SEND *INTERVAL* :SEND-IF-HANDLES :GET :MAJOR-MODE) *MAJOR-MODE*)))
    (COND (PKG
	   (PKG-GOTO PKG)
	   (TURN-ON-MODE MODE)))))

;;; Permit this editor and associated windows, etc. to be garbage-collected
(DEFMETHOD (:KILL TOP-LEVEL-EDITOR :AFTER) ()
  (SETQ *EDITORS-WHOSE-MODES-TO-RESET* (DELQ SELF *EDITORS-WHOSE-MODES-TO-RESET*)))

(DEFCONST *CONTEXTUAL-VARIABLES*
	  '(BASE IBASE PACKAGE READTABLE FS:THIS-IS-A-PATCH-FILE))

;;; This is the function that does the actual work
(DEFVAR *YANKED-MINI-BUFFER-COMMAND* NIL)

(DEFMETHOD (BEFORE-COMMAND-LOOP EDITOR) (TOP-LEVEL-P DESCRIPTION)
  (IGNORE DESCRIPTION)
  ;; Now set the contextual variables for the current buffer (if there is one),
  ;; since a c-m-Abort will flush them all
  (WHEN (AND *INTERVAL* TOP-LEVEL-P)
    (SET-EVALUATION-CONTEXT *INTERVAL*)))

(DEFMETHOD (:EDIT EDITOR) (&OPTIONAL (TOP-LEVEL-P (SEND SELF ':TOP-LEVEL-P)) DESCRIPTION
				     (COMMAND T))
  (LET* ((*CURRENT-COMMAND-LOOP* SELF)
	 (VARS (IF TOP-LEVEL-P *CONTEXTUAL-VARIABLES* NIL))
	 (VALS (LOOP FOR VAR IN VARS
		     COLLECT (SYMEVAL VAR))))
    ;; The editor needs to keep bindings for all of the contextual variables so that
    ;; we can (1) run in the right context all the time, and (2) SETQ their values
    ;; gracefully with the standard-values mechanism.  Yuck.
    (LET-IF TOP-LEVEL-P
	    ((SI:*INTERACTIVE-BINDINGS*
	       (LOOP FOR BINDING IN SI:*INTERACTIVE-BINDINGS*
		     COLLECT (COPYLIST BINDING)))
	     ;; Make sure these are not shared between multiple processes
	     (*YANKED-MINI-BUFFER-COMMAND* NIL))
      (PROGV VARS VALS
	;; No need to bind *INTERVAL*, it's a special instance-variable
	(SETQ *INTERVAL* (WINDOW-INTERVAL *WINDOW*))
	(BEFORE-COMMAND-LOOP SELF TOP-LEVEL-P DESCRIPTION)
	(TV:PROCESS-TYPEAHEAD
	  (SEND STANDARD-INPUT :IO-BUFFER)
	  #'(LAMBDA (CH)
	      (COND ((NLISTP CH) CH)
		    ((EQ (CAR CH) 'SELECT-WINDOW)
		     (APPLY #'PROCESS-SPECIAL-COMMAND CH) NIL)
		    ((MEMQ (CAR CH) '(CONFIGURATION-CHANGED REDISPLAY
				      . DW::(WINDOW-WAKEUP-SELECT WINDOW-WAKEUP-EXPOSE
					     WINDOW-WAKEUP-REFRESH WINDOW-WAKEUP-REDISPLAY
					     WINDOW-WAKEUP-VIEWPORT-POSITION-CHANGED)))
		     NIL)
		    (T CH))))
	(SETQ *CURRENT-COMMAND-TYPE* 'FIRST)
	(UNWIND-PROTECT
	    (PROGN
	      (SEND (WINDOW-SHEET *WINDOW*)	;Don't expose yet, but on first redisplay
		    ':START-DELAYED-SELECT)
	      (REDISPLAY-MODE-LINE)		;Do this once since may change size
	     ;(COMTAB-MOUSE-PROMPT *COMTAB* (WINDOW-WHO-LINE-DOCUMENTATION-STRING *WINDOW*))
	      (CATCH 'RETURN-FROM-COMMAND-LOOP
		(CATCH (IF TOP-LEVEL-P 'EXIT-TOP-LEVEL 'EXIT-CONTROL-R)
		  (DO () (NIL)
		    (CATCH-ERROR-RESTART
		      ((ERROR SYS:ABORT) (COND (DESCRIPTION)
					       (TOP-LEVEL-P "Editor Top Level")
					       (T "Editor Command Level")))
		      (DO () (NIL)
			(CATCH-ZWEI-COMMAND-LOOP
			  (CATCH (IF TOP-LEVEL-P 'TOP-LEVEL 'DUMMY-TAG)
			    (PROG (CH)
			       COMMAND-LOOP
				  (SETQ *LAST-COMMAND-TYPE* *CURRENT-COMMAND-TYPE*
					*CURRENT-COMMAND-TYPE* NIL
					*NUMERIC-ARG* 1
					*NUMERIC-ARG-P* NIL
					*NUMERIC-ARG-N-DIGITS* 0
					*MARK-STAYS* NIL
					*MINI-BUFFER-COMMAND* NIL)
				  (REDISPLAY-ALL-WINDOWS)
				  (SEND *TYPEIN-WINDOW* ':COMMAND-LOOP-REDISPLAY)
				  (SETQ *CENTERING-FRACTION* *CENTER-FRACTION*)
			       UNREAL-COMMAND
				  (SETQ CH (OR (EDITOR-INPUT :ANY-TYI (IF COMMAND 'COMMAND
									  'PRESENTATION)
							     :NOTIFICATION T)))
			       UNREAL-COMMAND-TYPEAHEAD
				  (COND
				    ((NULL CH) (RETURN NIL))	;If EOF, return
				    ((LISTP CH)	;Handle mouse, etc
				     (SETQ *LAST-COMMAND-CHAR* CH)
				     (COND ((NOT (APPLY #'PROCESS-SPECIAL-COMMAND CH))
					    ;; This kind of blip doesn't affect the typeout
					    ;; window at all hence NIL as the SELECT-P arg
					    ;; to REDISPLAY-ALL-WINDOWS
					    (REDISPLAY-ALL-WINDOWS NIL NIL)
					    (GO UNREAL-COMMAND))
					   (T
					    ;; This kind of blip removes typeout
					    ;; Treat it the same as a normal editing command
					    )))
				    ((AND (EQL CH #\SP)
					  (WINDOW-COVERED-BY-TYPEOUT-P *WINDOW*))
				     ;; Space typed when there is typeout is a command to flush
				     ;; the typeout rather than to insert a space.
				     ;; Usually CHECK-FOR-TYPEOUT-WINDOW-TYPEOUT catches this,
				     ;; but not if a blip occurs first.
				     (SEND *TYPEOUT-WINDOW* ':MAKE-COMPLETE))
				    ((AND (CHARACTERP CH)	;Keyboard or mouse character
					  (EQ ':ARGUMENT (PROCESS-COMMAND-CHAR CH)))
				     (SETQ *NUMERIC-ARG-N-DIGITS* (1+ *NUMERIC-ARG-N-DIGITS*))
				     ;; Maybe read more characters without prompting
				     (IF (SETQ CH (READ-ARGUMENT-TYPEAHEAD-CHARACTER))
					 (GO UNREAL-COMMAND-TYPEAHEAD))
				     ;; Character not typed quickly, display argument prompting
				     (TYPEIN-LINE "Arg: ~A"
						  (FORMAT-ARGUMENT *NUMERIC-ARG-P* *NUMERIC-ARG*))
				     (SEND *TYPEIN-WINDOW* ':MAKE-COMPLETE)
				     (REDISPLAY-ALL-WINDOWS NIL NIL)
				     (GO UNREAL-COMMAND)))
				  ;; This is executed after every real command, but not after
				  ;; mouse signals and keystrokes that just set the arguments
				  ;; for following commands.
				  ;; If there is typeout (window-typeout-stream style) that the
				  ;; user hasn't finished reading, wait for a character, and if
				  ;; it's space, ignore it and redisplay.
				  (CHECK-FOR-TYPEOUT-WINDOW-TYPEOUT
						:ANY-TYI (IF COMMAND 'COMMAND 'PRESENTATION))
				  (GO COMMAND-LOOP))))
			;; This is executed after a throw to command level.
			;; The typeout window is supposed to disappear after the next redisplay.
			;; Note that if we just flushed a **more** because of a blip, the next
			;; redisplay may not occur for quite some time.
			(SEND *TYPEOUT-WINDOW* ':MAKE-COMPLETE)))
		    ;; If we Z from BREAK or an error, or hit control-Abort, make
		    ;; the typeout go away and halt any runaway keyboard macro
		    (SEND *TYPEOUT-WINDOW* ':MAKE-COMPLETE)
		    (SEND-IF-HANDLES STANDARD-INPUT ':MACRO-ERROR)))))
	  ;; Make sure typeout window is dismissed before burying Zmacs
	  (SEND *TYPEOUT-WINDOW* ':MAKE-COMPLETE)
	  (REDISPLAY-ALL-WINDOWS NIL NIL)
	  (SEND (WINDOW-SHEET *WINDOW*) ':FLUSH-DELAYED-SELECT))))))

(DEFWHOPPER (:EDIT EDITOR) (&REST ARGUMENTS)
  (SI:WITH-PROCESS-INTERACTIVE-PRIORITY ()
    (LEXPR-CONTINUE-WHOPPER ARGUMENTS)))
				    
(DEFMETHOD (:TOP-LEVEL-P EDITOR) () NIL)
(DEFMETHOD (:TOP-LEVEL-P TOP-LEVEL-EDITOR) () T)
(DEFMETHOD (:EXPOSE-MODE-LINE-WINDOW EDITOR) (&OPTIONAL IGNORE))

(DEFMETHOD (:POINT-BLINKER-VISIBILITY EDITOR) (WINDOW)
  (IF (TV:SHEET-SELECTED-P (WINDOW-SHEET WINDOW))
      :BLINK
      (TV:BLINKER-DESELECTED-VISIBILITY (WINDOW-POINT-BLINKER WINDOW))))

;;; We just do our own.  Zmacs does it for other Zmacses.
(DEFMETHOD (POINT-PDL-PURGE-INTERNAL EDITOR) (BUFFER)
  (POINT-PDL-PURGE-ONE-BUFFER SELF BUFFER))

;;; We rely on the top-level editor having bound D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")*window-list*0 for us.
;;; That is, we inherit it dynamically from our top-level editor.
(DEFMETHOD (POINT-PDL-PURGE-ONE-BUFFER EDITOR) (BUFFER)
  (DOLIST (WINDOW *WINDOW-LIST*)
    (SETF (WINDOW-POINT-PDL WINDOW)
	  (DEL #'(LAMBDA (BUF POINT) (EQ BUF (BP-BUFFER (FIRST POINT))))
	       BUFFER
	       (WINDOW-POINT-PDL WINDOW)))))

;;; We use our the 1*window-list*0 instance variable directly.
;;; That is, it is (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")not0 inherited dynamically from the top-level editor, because
;;; this 2is0 the top-level editor.
(DEFMETHOD (POINT-PDL-PURGE-ONE-BUFFER TOP-LEVEL-EDITOR) (BUFFER)
  (DOLIST (WINDOW *WINDOW-LIST*)
    (SETF (WINDOW-POINT-PDL WINDOW)
	  (DEL #'(LAMBDA (BUF POINT) (EQ BUF (BP-BUFFER (FIRST POINT))))
	       BUFFER
	       (WINDOW-POINT-PDL WINDOW)))))

;Wait a little while for an argument character to be typed, then return it
;Return NIL if no character is typed or feature turned off, caller should prompt then read
; If the arg says there is a presentation context, adjust the :ANY-TYI arg to EDITOR-INPUT.
(DEFUN READ-ARGUMENT-TYPEAHEAD-CHARACTER (&OPTIONAL PRESENTATION-P)
  (LET ((ANY-TYI (IF PRESENTATION-P 'PRESENTATION 'T)))
    (COND ((NOT (FUNCALL *TYPEIN-WINDOW* ':EXPOSED-P))
	   ;; If typein window is not exposed, don't prompt (which would pop it up)
	   (EDITOR-INPUT :ANY-TYI ANY-TYI))
	  (*ARGUMENT-PROMPT-DELAY*
	   ;; User wants feature of suppressing prompt if typeahead
	   (WAIT-FOR-POSSIBLE-TYPEAHEAD *ARGUMENT-PROMPT-DELAY*)
	   (EDITOR-INPUT :ANY-TYI ANY-TYI :NO-HANG T)))))

;Read a character, maybe prompting with the given arguments and maybe not
;Abort and Suspend are disabled
; If the arg says there is a presentation context, adjust the :ANY-TYI arg to EDITOR-INPUT.
; Second return value says whether the prompt was printed or not (due to typeahead).
(DEFUN READ-ARGUMENT-CHARACTER-WITH-POSSIBLE-PROMPT-AND-PRESENTATION-CONTEXT
       (PRESENTATION-P FORMAT-STRING &REST FORMAT-ARGS &AUX CH)
  (DECLARE (VALUES CHARACTER PROMPT-PRINTED-P))
  (COND ((CHARACTERP (SETQ CH (READ-ARGUMENT-TYPEAHEAD-CHARACTER PRESENTATION-P)))
	 (VALUES CH NIL))
	(T
	 (LEXPR-FUNCALL #'TYPEIN-LINE FORMAT-STRING FORMAT-ARGS)
	 (VALUES
	   (TYPEIN-LINE-ACTIVATE (EDITOR-INPUT :ANY-TYI (AND PRESENTATION-P 'PRESENTATION)))
	   T))))

;Read a character, maybe prompting with the given arguments and maybe not
;Abort and Suspend are disabled
(DEFUN READ-ARGUMENT-CHARACTER-WITH-POSSIBLE-PROMPT (FORMAT-STRING &REST FORMAT-ARGS &AUX CH)
  (COND ((CHARACTERP (SETQ CH (READ-ARGUMENT-TYPEAHEAD-CHARACTER))) CH)
	(T (LEXPR-FUNCALL #'TYPEIN-LINE FORMAT-STRING FORMAT-ARGS)
	   (TYPEIN-LINE-ACTIVATE (EDITOR-INPUT)))))

(DEFUN WAIT-FOR-POSSIBLE-TYPEAHEAD (INTERVAL)
  (SEND STANDARD-INPUT ':INPUT-WAIT "Typeahead" #'TIME-ELAPSED-P INTERVAL (TIME)))

;;; Handle a normal command character, either a keyboard or mouse
(DEFUN PROCESS-COMMAND-CHAR (CH &AUX VALUE LINE INDEX)
  (SETQ *LAST-COMMAND-CHAR* CH)
  ;; Remove temporary highlighting established by previous command
  (DOLIST (WINDOW *WINDOW-LIST*)
    (WHEN (LISTP (WINDOW-MARK-P WINDOW))
      (SETF (WINDOW-MARK-P WINDOW) NIL)
      (MUST-REDISPLAY WINDOW DIS-MARK-GOES)))
  ;; Look up the command in the table.
  (LET ((*CURRENT-COMMAND* (COMMAND-LOOKUP *LAST-COMMAND-CHAR* *COMTAB*))
	(*ORIGINAL-COMMAND-LINE* (BP-LINE (POINT))))
    ;; Execute the command.
    (MULTIPLE-VALUE (VALUE LINE INDEX)
      (COMMAND-EXECUTE *CURRENT-COMMAND* *LAST-COMMAND-CHAR* NIL *COMMAND-HOOK*))
    ;; This command is creating the argument to a subsequent command.
    (COND ((EQ VALUE ':ARGUMENT)
	   VALUE)
	  ((NOT (AND (NUMBERP VALUE)
		     ( DIS-NONE VALUE DIS-ALL)))
	   (FERROR "The value returned from ~S, ~S, is not a valid designator of~@
		    redisplay degree." *CURRENT-COMMAND* VALUE))
	  (T
	   ;; If the mark is not being preserved, make it go away.
	   (COND ((AND (NOT *MARK-STAYS*) (WINDOW-MARK-P *WINDOW*))
		  (SETF (WINDOW-MARK-P *WINDOW*) NIL)
		  (MUST-REDISPLAY *WINDOW* DIS-MARK-GOES)))
	   ;; Report the returned value of the command to the window.
	   (MUST-REDISPLAY *WINDOW* VALUE LINE INDEX)
	   ;; Call the post-command hooks
	   (DOLIST (HOOK *POST-COMMAND-HOOK*) (FUNCALL HOOK *LAST-COMMAND-CHAR*))))))

;;; This handles special commands from the window system
;;; returns non-NIL if the typeout window should be flushed like normal commands.
(DEFSELECT (PROCESS-SPECIAL-COMMAND UNKNOWN-SPECIAL-COMMAND)
  (REDISPLAY ()
    ;The window is presumably on our list of windows and will get redisplayed
    ;in the normal course of events when buffered input had been processed.
    NIL)
  (MUST-REDISPLAY (&REST ARGS)
    (APPLY #'MUST-REDISPLAY ARGS)
    NIL)
  (MUST-REDISPLAY-INTERVAL (INTERVAL &REST ARGS)
    (LEXPR-FUNCALL #'MUST-REDISPLAY-OTHER-WINDOWS INTERVAL NIL ARGS)
    NIL)
  (SELECT-WINDOW (WINDOW)
    (PROG1 (NEQ WINDOW *WINDOW*)
	   (MAKE-WINDOW-CURRENT WINDOW)))
  (CONFIGURATION-CHANGED ()
   (AND (NOT (WINDOW-EXPOSED-P *WINDOW*))
	(DOLIST (W *WINDOW-LIST*)
	  (AND (WINDOW-EXPOSED-P W)
	       (MAKE-WINDOW-CURRENT W NIL))))
   NIL)
  (SCROLL (WINDOW NLINES TYPE)
    (PROCESS-SCROLL-COMMAND WINDOW NLINES TYPE)
    T)
  (:MOUSE-BUTTON (CH WINDOW X Y)
    (IF (OR (EQ WINDOW *TYPEIN-WINDOW*) (EQ WINDOW *MODE-LINE-WINDOW*))
	2;; Clicking in the typein or mode line window0 2should just beep --
0	2;;    However, by the time we get this blip, the typein window has already been
0	2;;    "selected" by the window system.  Thus, we must reselect the current window
0	2;;    to shut off the typein window's cursor and restart the current window's cursor.
0	(PROGN
	  (BEEP)
	  (SELECT-WINDOW *WINDOW*))
      (UNKNOWN-SPECIAL-COMMAND :MOUSE-BUTTON CH WINDOW X Y))
    NIL)
  #||  ;Mouse blips handled by dynamic windows
  (:MOUSE (WINDOW CH *MOUSE-X* *MOUSE-Y*)
    (DECF *MOUSE-X* (TV:SHEET-INSIDE-LEFT (WINDOW-SHEET WINDOW)))
    (DECF *MOUSE-Y* (TV:SHEET-INSIDE-TOP (WINDOW-SHEET WINDOW)))
    (SEND-IF-HANDLES STANDARD-INPUT ':RECORD CH)
    (LET ((*NON-MOUSE-*WINDOW** *WINDOW*))	;Let hairy mouse commands know where we were
      (IF (AND (NEQ WINDOW *WINDOW*)
	       (NOT (CHAR-MOUSE-EQUAL CH #\MOUSE-R)))	;Given in another window,
	  (LET ((*COMTAB* (IF (EQ *WINDOW* *MINI-BUFFER-WINDOW*) *STANDARD-COMTAB* *COMTAB*))
		(*LAST-COMMAND-TYPE* NIL)	;dont confuse mouse mark thing, and
		*CURRENT-COMMAND-TYPE*
		(*WINDOW* WINDOW)
		(*INTERVAL* (WINDOW-INTERVAL WINDOW)))	;temporarily act there (mini-buffer)
	    (PROCESS-COMMAND-CHAR CH))
	  (PROCESS-COMMAND-CHAR CH)))
    T)
  ||#
  ((:TYPEOUT-EXECUTE :EXECUTE) (FUNCTION &REST ARGS)
   (SI:WITH-PROCESS-NON-INTERACTIVE-PRIORITY ()
     (NOT (APPLY FUNCTION ARGS))))
  (PRESENTATION-COMMAND (VALUE NAME)
   (WHEN (SEND *TYPEIN-WINDOW* :EXPOSED-P)
     (TYPEIN-LINE "")
     (SCL:WITH-CHARACTER-FACE (:ITALIC *TYPEIN-WINDOW*)
       (OUTPUT-PRESENTATION-COMMAND-NAME NAME *TYPEIN-WINDOW*)))
   (SI:WITH-PROCESS-NON-INTERACTIVE-PRIORITY ()
     (NOT (APPLY (FIRST VALUE) (REST1 VALUE)))))
  (SI:INPUT-EDITOR (IGNORE STRING)
   (LET-BUFFER-VARIABLE (*KILL-INTERVAL-SMARTS* T)
     (SETQ *CURRENT-COMMAND-TYPE* 'YANK)
     (YANK-TEXT STRING NIL)
     (MUST-REDISPLAY *WINDOW* DIS-TEXT)
     T))
  (:EXECUTE-AS-COMMAND (FUNCTION &REST ARGS)
   (LET (*CURRENT-COMMAND*)
     (MULTIPLE-VALUE-BIND (VALUE LINE INDEX)
	 (SI:WITH-PROCESS-NON-INTERACTIVE-PRIORITY ()
	   (APPLY FUNCTION ARGS))
       (MUST-REDISPLAY *WINDOW* VALUE LINE INDEX)
       T)))
  (DW::(WINDOW-WAKEUP-SELECT WINDOW-WAKEUP-EXPOSE
	WINDOW-WAKEUP-REFRESH WINDOW-WAKEUP-REDISPLAY
	WINDOW-WAKEUP-VIEWPORT-POSITION-CHANGED)
    (&REST IGNORE)
   NIL))

(DEFUN PROCESS-SCROLL-COMMAND (WINDOW NLINES TYPE)
  (SELECTQ TYPE
    (:ABSOLUTE
     (RECENTER-WINDOW WINDOW :START (LET ((*INTERVAL* (WINDOW-INTERVAL WINDOW)))
				      (FORWARD-LINE (INTERVAL-FIRST-BP *INTERVAL*)
						    NLINES T))))
    (:SCREEN
     (RECENTER-WINDOW-RELATIVE WINDOW NLINES :SCREEN))
    (OTHERWISE
     (RECENTER-WINDOW-RELATIVE WINDOW NLINES))))

(DEFFLAVOR UNKNOWN-SPECIAL-COMMAND (COMMAND-TYPE REST) (BARF)
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:REPORT UNKNOWN-SPECIAL-COMMAND) (STREAM)
  (UNLESS (EQ COMMAND-TYPE ':MOUSE-BUTTON)		;Vanilla blip, just beep
    (FORMAT STREAM "~S is not a valid special editor command keyword;~
the rest of the command was ~S" COMMAND-TYPE REST)))

;; BLIP-COMMAND-HANDLER is a hook for Japanese blips.

(DEFUN UNKNOWN-SPECIAL-COMMAND (COMMAND-TYPE &REST REST)
  (LET ((COMMAND (GET COMMAND-TYPE 'BLIP-COMMAND-HANDLER)))
    (IF COMMAND
	(LEXPR-FUNCALL COMMAND COMMAND-TYPE REST)
	(ERROR 'UNKNOWN-SPECIAL-COMMAND ':COMMAND-TYPE COMMAND-TYPE ':REST (COPYLIST REST)))))

(SCL:DEFINE-PRESENTATION-TYPE PRESENTATION-COMMAND ((&KEY COMTAB))
   :EXPANDER T
   :PRINTER ((COMMAND STREAM)
	     (OUTPUT-PRESENTATION-COMMAND-NAME (THIRD COMMAND) STREAM))
   )

(DEFUN PRESENTATION-COMMAND-COMTAB-P (CONTEXT DESIRED-COMTAB)
  (WHEN (BOUNDP '*COMTAB*)
    (DO ((COMTAB (LET ((TYPE (DW::PRESENTATION-INPUT-CONTEXT-PRESENTATION-TYPE CONTEXT)))
		   (IF (ATOM TYPE)		;NIL is an atom, too!
		       *COMTAB*
		     (CL:GETF (CDR TYPE) :COMTAB *COMTAB*)))
		 (COMTAB-INDIRECT-TO COMTAB)))
	((NULL COMTAB) NIL)
      (WHEN (EQ COMTAB DESIRED-COMTAB)
	(RETURN T)))))

(DEFUN PRESENTATION-COMMAND-NAME (PREFIX OBJECT TYPE MENU-PRESENTATION)
  (IF MENU-PRESENTATION
      (LIST PREFIX OBJECT TYPE MENU-PRESENTATION)
      (LIST PREFIX OBJECT TYPE)))

(DEFUN OUTPUT-PRESENTATION-COMMAND-NAME (LIST STREAM)
  (IF (STRINGP LIST)
      (CL:WRITE-STRING LIST STREAM)
      (DESTRUCTURING-BIND (PREFIX OBJECT TYPE &OPTIONAL MENU-PRESENTATION)
	 LIST
	(IF (AND MENU-PRESENTATION
		 (EQ OBJECT (DW::PRESENTATION-OBJECT MENU-PRESENTATION)))
	    (DW::WRITE-ABBREVIATED-COMMAND-NAME-FOR-MENU-DOCUMENTATION PREFIX
								       MENU-PRESENTATION
								       STREAM)
	    (CL:WRITE-STRING PREFIX STREAM)
	    (UNLESS (MEMQ TYPE '(BP NIL DW::NO-TYPE))
	      (TYO #\Space STREAM)
	      (DW::PRESENT-FOR-DOCUMENTATION OBJECT TYPE STREAM MENU-PRESENTATION))))))

;; This is a prototype of the user process side of the new interaction system.  The mouse
;; process should be changed to only make the scroll bar visible if :SCROLL T is specified.
;; :MOUSE :RETURN means that two values should be returned.  We could also change the whostate
;; to reflect what type of input is being accepted.  :MOUSE blips are generated by the Zwei
;; :MOUSE-CLICK method.  :MOUSE-BUTTON blips are what the window system generates.
(DEFUN EDITOR-INPUT (&KEY (NO-HANG NIL)		; NIL or T
			  (ANY-TYI NIL)		; NIL, T, REDISPLAY, COMMAND, or PRESENTATION
			  (SCROLL NIL)		; NIL or T
			  (EOF NIL)		; NIL or T
			  (NOTIFICATION NIL)	; NIL, T, or :RETURN
			  (MOUSE NIL)		; NIL, T, or :RETURN
			  (WHOSTATE NIL)	; NIL or string
			  (INPUT-WAIT NIL)	; NIL or list of function and arguments
			  (ABORT NIL)
			  (SUSPEND NIL)
			  )
  (WHEN *YANKED-MINI-BUFFER-COMMAND*
    (RETURN-FROM EDITOR-INPUT
      (PROG1 *YANKED-MINI-BUFFER-COMMAND*
	     (SETQ *YANKED-MINI-BUFFER-COMMAND* NIL))))
  ;; Bypass normal processing if there is typeahead.
  (LET ((CHAR (LET ((SYS:KBD-INTERCEPTED-CHARACTERS
		      (AND ABORT SYS:KBD-STANDARD-ABORT-CHARACTERS)))
		(SEND STANDARD-INPUT :ANY-TYI-NO-HANG))))
    (WHEN CHAR
      (WHEN (CHARACTERP CHAR)
	(UNLESS (AND SUSPEND (MEMQ CHAR SYS:KBD-STANDARD-SUSPEND-CHARACTERS))
	  (RETURN-FROM EDITOR-INPUT
	    (IF (EQ MOUSE :RETURN) (VALUES CHAR CHAR) CHAR))))
      ;; If it's a blip or something, it may need special processing, which may require
      ;; the full context.
      (SEND STANDARD-INPUT :UNTYI CHAR)))
  (FLET ((DO-IT ()
	   (LOOP DOING
	     (LET ((CHAR (SYS:READ-CHARACTER STANDARD-INPUT
					     :ANY-TYI T
					     :PRESENTATION-CONTEXT
						(AND (MEMQ ANY-TYI '(COMMAND PRESENTATION))
						     T)
					     :FRESH-LINE NIL
					     :REFRESH NIL
					     :SUSPEND SUSPEND
					     :ABORT ABORT
					     
					     :NO-HANG NO-HANG
					     :EOF EOF
					     :NOTIFICATION NOTIFICATION
					     :WHOSTATE WHOSTATE
					     :INPUT-WAIT INPUT-WAIT
					     :INPUT-WAIT-HANDLER
					     (AND INPUT-WAIT
						  (LAMBDA ()
						    (DECLARE (SYS:DOWNWARD-FUNCTION))
						    (AND (FUNCALL INPUT-WAIT)
							 (RETURN-FROM EDITOR-INPUT T)))))))
	       (COND ((CHARACTERP CHAR)
		      (IF (EQ MOUSE :RETURN)
			  (RETURN (VALUES CHAR CHAR))
			(RETURN CHAR)))
		     ((NULL CHAR)
		      (WHEN (OR EOF NO-HANG)
			(RETURN CHAR)))
		     ((ATOM CHAR)
		      (IF ANY-TYI (IF (EQ MOUSE :RETURN)
				      (RETURN (VALUES CHAR CHAR))
				    (RETURN CHAR))))
		     ((AND SCROLL (EQ (CAR CHAR) 'SCROLL))
		      (APPLY #'PROCESS-SPECIAL-COMMAND CHAR)
		      (REDISPLAY *WINDOW* :POINT))
		     ((AND MOUSE (MEMQ (FIRST CHAR) '(#||:MOUSE||# :MOUSE-CLICK)))
		      (IF (EQ MOUSE :RETURN)
			  (RETURN (VALUES (IF (EQ (FIRST CHAR) :MOUSE)
					      (THIRD CHAR) (SECOND CHAR))
					  CHAR))
			(APPLY #'PROCESS-SPECIAL-COMMAND CHAR)))
		     ((AND (EQ (CAR CHAR) 'REDISPLAY) (EQ ANY-TYI 'REDISPLAY))
		      (APPLY #'PROCESS-SPECIAL-COMMAND CHAR))
		     (ANY-TYI
		      (IF (EQ MOUSE :RETURN)
			  (RETURN (VALUES CHAR CHAR))
			(RETURN CHAR))))))))
    (IF (EQ ANY-TYI 'COMMAND)
	(DW:WITH-PRESENTATION-INPUT-CONTEXT
	   ('((OR PRESENTATION-COMMAND SI:INPUT-EDITOR)) :STREAM STANDARD-INPUT)
	   (BLIP)
	     (BARF-ON-ERRORS (DW:DEAD-BLIP)
	       (DO-IT))
	   (PRESENTATION-COMMAND
	     (DW:PRESENTATION-BLIP-OBJECT BLIP))
	   (SI:INPUT-EDITOR
	     BLIP))
	(DO-IT))))

(DEFUN CHECK-FOR-TYPEOUT-WINDOW-TYPEOUT (&KEY (ANY-TYI 'COMMAND) (NOTIFICATION T))
  (WHEN (TYPEOUT-WINDOW-INCOMPLETE-P *TYPEOUT-WINDOW*)
    (SEND *TYPEOUT-WINDOW* ':MAKE-COMPLETE)
    (LOOP FOR CHAR = (EDITOR-INPUT :ANY-TYI ANY-TYI :NOTIFICATION NOTIFICATION)
	  WHILE (AND (LISTP CHAR)
		     ;; Ignore requests to select current window
		     (OR (AND (EQ (FIRST CHAR) 'SELECT-WINDOW)
			      (OR (EQ (SECOND CHAR) *WINDOW*)
				  (EQ (SECOND CHAR) *MINI-BUFFER-WINDOW*)))
			 (AND (DW:PRESENTATION-BLIP-P CHAR)
			      (DW:PRESENTATION-BLIP-TYPEP CHAR 'DW::WINDOW-WAKEUP))))
	  FINALLY (OR (EQL CHAR #\SP)
		      ;; If it's not a space, unread it.  Don't unread through the stream,
		      ;; since it may not have really come from there.
		      ;; That will prevent redisplay.
		      (SETQ *YANKED-MINI-BUFFER-COMMAND* CHAR)))))

;;; Recursive edit on the same buffer
(DEFUN CONTROL-R (&KEY (MODE-LINE-LIST NIL MODE-LINE-LIST-P)
		       (IF-ERROR ':RETRY)  ;Better default than NIL (which it was 1987-1989)
		       (IF-ABORT NIL)
		       (COMTAB NIL))
  (CL:CHECK-TYPE IF-ERROR (CL:MEMBER NIL T :ABORT :THROW :RETRY))
  (CL:CHECK-TYPE IF-ABORT (CL:MEMBER NIL T :ABORT :THROW))
  (RECORD-ACCUMULATED-CHANGES-BP (POINT))
  (LET ((COMTAB (OR COMTAB *COMTAB*)) MY-COMTAB FINISH-STRING ERROR)
    (COND ((NOT IF-ABORT)
	   ;; The `old way' ... Abort and End mean the same.
	   (SETQ MY-COMTAB *CONTROL-R-COMTAB*)
	   (SETQ FINISH-STRING "   (End or Abort finishes)]"))
	  (T
	   ;; The `new way' ... Allow Abort and End to be distinguished.
	   (SETQ MY-COMTAB *RECURSIVE-EDIT-COMTAB*)
	   (SETQ FINISH-STRING "   (End finishes, Abort aborts)]")))
    (COND ((NEQ COMTAB MY-COMTAB)
	   (SET-COMTAB-INDIRECTION MY-COMTAB COMTAB)
	   (SETQ COMTAB MY-COMTAB)))
    (LET ((*MODE-LINE-LIST*
	    (IF MODE-LINE-LIST-P
		MODE-LINE-LIST
		`("[Recursive edit under: " ,@*MODE-LINE-LIST*
		  ,FINISH-STRING))))
      (TAGBODY
	RETRY
	   (BLOCK CONDITION-CASE
	     (CONDITION-BIND ((ERROR (LAMBDA (CONDITION)
				       (UNLESS (TYPEP CONDITION 'BARF)
					 (SETQ ERROR CONDITION)
					 (RETURN-FROM CONDITION-CASE)))))
	       (FLET ((DO-IT ()
			(UNWIND-PROTECT
			    (COMMAND-LOOP COMTAB *WINDOW* 'EDITOR)
			  (RECORD-ACCUMULATED-CHANGES-BP (POINT)))))
		 (COND (IF-ABORT
			(CATCH 'TOP-LEVEL
			  (DO-IT)
			  (RETURN-FROM CONTROL-R NIL))
			;; Get here if the edit level is aborted
			(CL:ECASE IF-ABORT
			  ((T)      (RETURN-FROM CONTROL-R NIL))
			  ((:THROW) (THROW 'TOP-LEVEL T))
			  ((:ABORT) (SIGNAL 'SYS:ABORT))))
		       (T
			(RETURN-FROM CONTROL-R
			  (DO-IT)))))))
	   ;; Get here if an error occurs, other than ZWEI:BARF which just returns
	   ;; to the inner command loop.
	   (BEEP)
	   (TYPEIN-LINE "Error in recursive edit:~%~A" ERROR)
	   (CL:ECASE IF-ERROR
	     ((NIL T)
	      (TYPEIN-LINE-MORE "; aborting recursive edit level.")
	      (RETURN-FROM CONTROL-R IF-ERROR))
	     ((:ABORT)
	      (TYPEIN-LINE-MORE "; aborting.")
	      (SIGNAL 'SYS:ABORT))
	     ((:THROW)
	      (TYPEIN-LINE-MORE "; aborting.")
	      (THROW 'TOP-LEVEL T))
	     ((:RETRY)
	      (GO RETRY)))))))

;;; Recursive edit with a temporary window on the given interval
(DEFUN RECURSIVE-EDIT (INTERVAL MODE &OPTIONAL POINT
				     &AUX (WINDOW (CREATE-OVERLYING-WINDOW *WINDOW*))
				     (SHEET (WINDOW-SHEET WINDOW)))
  (SET-WINDOW-INTERVAL WINDOW INTERVAL)
  (AND POINT (MOVE-BP (WINDOW-POINT WINDOW) POINT))
  (LET ((*EDITOR-ALREADY-KNOWS* T))
    (TV:WINDOW-CALL (SHEET :DEACTIVATE)
      (LET ((*MODE-LINE-LIST* `("[" ,MODE "   (End finishes, Abort aborts)]")))
	(COMMAND-LOOP *RECURSIVE-EDIT-COMTAB* WINDOW 'EDITOR)))))

;;; This is in DEFS to avoid compiler warnings elsewhere.
;(DEFFLAVOR BARF () (ERROR))

(DEFMETHOD (:REPORT BARF) (IGNORE))

(DEFFLAVOR FORMAT-BARF () (FERROR BARF))
(DEFFLAVOR FORMAT-DEBUGGING-BARF () (FERROR DEBUGGING-BARF))

;;; Reports an error.  Takes a FORMAT control string and args.  If the string
;;; is not given, no message is reported.
;;; Such errors can be intercepted with a CONDITION-BIND of BARF.
(DEFPROP BARF T :ERROR-REPORTER)
(DEFUN BARF (&OPTIONAL CTL-STRING &REST ARGS)
  (ERROR (COND ((TYPEP CTL-STRING 'BARF) CTL-STRING)
	       ((NULL CTL-STRING) 'BARF)
	       ((TYPEP CTL-STRING 'CONDITION)
		(MAKE-CONDITION 'FORMAT-BARF ':FORMAT-STRING "~A"
					     ':FORMAT-ARGS (LIST CTL-STRING)))
	       (T
		(MAKE-CONDITION 'FORMAT-BARF ':FORMAT-STRING CTL-STRING
					     ':FORMAT-ARGS (COPYLIST ARGS))))))


(DEFPROP DEBUGGING-BARF T :ERROR-REPORTER)
(DEFUN DEBUGGING-BARF (&OPTIONAL CTL-STRING &REST ARGS)
  (ERROR (COND ((TYPEP CTL-STRING 'BARF) CTL-STRING)
	       ((NULL CTL-STRING) 'DEBUGGING-BARF)
	       ((TYPEP CTL-STRING 'CONDITION)
		(MAKE-CONDITION 'FORMAT-DEBUGGING-BARF ':FORMAT-STRING "~A"
				':FORMAT-ARGS (LIST CTL-STRING)))
	       (T
		(MAKE-CONDITION 'FORMAT-DEBUGGING-BARF ':FORMAT-STRING CTL-STRING
				':FORMAT-ARGS (COPYLIST ARGS))))))

;;; This is the CONDITION-BIND function at the top of every command loop
;;; which handles BARFs.  See CATCH-ZWEI-COMMAND-LOOP.
(DEFUN COMMAND-LOOP-HANDLE-BARF (CONDITION)
  (COND (*MINI-BUFFER-COMMAND-IN-PROGRESS*
	 (SI:WITH-STACK-ARRAY (TEXT-STRING 256. :TYPE 'ART-STRING :FILL-POINTER 0)
	   (WITH-OUTPUT-TO-STRING (TEXT-STREAM TEXT-STRING)
	     (SEND CONDITION :REPORT TEXT-STREAM)
	     (WHEN (SEND STANDARD-INPUT :SEND-IF-HANDLES :MACRO-ERROR)
	       (FORMAT TEXT-STREAM "~&Keyboard macro playback terminated by error."))
	     (SEND *TYPEOUT-WINDOW* :BEEP)
	     ;; No ugly blank lines in the typeout window
	     (WHEN (NOT (ZEROP (STRING-LENGTH TEXT-STRING)))
	       (FORMAT *TYPEOUT-WINDOW* "~&~A" TEXT-STRING)
	       (SEND *TYPEOUT-WINDOW* :MAKE-COMPLETE)))))
	(T
	 (TYPEIN-LINE "")
	 (SEND *TYPEIN-WINDOW* ':BEEP)
	 (SEND CONDITION ':REPORT *TYPEIN-WINDOW*)
	 (WHEN (SEND STANDARD-INPUT :SEND-IF-HANDLES :MACRO-ERROR)
	   (TYPEIN-LINE-MORE "~&Keyboard macro playback terminated by error."))))
  (MUST-REDISPLAY *WINDOW* DIS-TEXT)		;May have altered the text before erring
  (THROW 'ZWEI-COMMAND-LOOP CONDITION))

(DEFUN ABORT-CURRENT-COMMAND ()
  (THROW 'ZWEI-COMMAND-LOOP T))

;;; The actual command tables used by the implemented ZWEI subsystems.

(DEFUN INITIALIZE-STANDARD-COMTABS ()
  (SETQ *STANDARD-COMTAB*
         (SET-COMTAB "Zwei"
	  '((0 200) COM-STANDARD
	    #\BS COM-STANDARD
	    (301 310) COM-STANDARD
	    (312 317) COM-STANDARD
	    #\Keyboard:Cut COM-CONSOLE-CUT
	    #\Keyboard:Copy COM-CONSOLE-COPY
	    #\Keyboard:Paste COM-CONSOLE-PASTE
	    #\M-Keyboard:Paste COM-CONSOLE-PASTE-POP
	    #\c-F COM-FORWARD
	    #\Keyboard:Right COM-FORWARD
	    #\c-B COM-BACKWARD
	    #\Keyboard:Left COM-BACKWARD
	    #\c-N COM-DOWN-REAL-LINE
	    #\Keyboard:Down COM-DOWN-REAL-LINE
	    #\c-P COM-UP-REAL-LINE
	    #\Keyboard:Up COM-UP-REAL-LINE
	    #\c-V COM-NEXT-SCREEN
	    #\Scroll COM-NEXT-SCREEN
	    #\m-Scroll COM-PREVIOUS-SCREEN
	    #\m-V COM-PREVIOUS-SCREEN
	    #\c-m-V COM-SCROLL-OTHER-WINDOW
	    #\c-m-sh-V COM-SCROLL-OTHER-WINDOW-BACKWARD
	    #\c-Scroll COM-SCROLL-TYPEOUT-WINDOW
	    #\c-m-Scroll COM-SCROLL-BACK-TYPEOUT-WINDOW
	    #\Keyboard:Back-Scroll COM-PREVIOUS-SCREEN
	    #\C-Keyboard:Back-Scroll COM-SCROLL-BACK-TYPEOUT-WINDOW
	    #\c-A COM-BEGINNING-OF-LINE
	    #\M-Keyboard:Left COM-BEGINNING-OF-LINE
	    #\c-E COM-END-OF-LINE
	    #\M-Keyboard:Right COM-END-OF-LINE
	    #\m-R COM-MOVE-TO-SCREEN-EDGE
	    #\m-< COM-GOTO-BEGINNING
	    #\M-Keyboard:Up COM-GOTO-BEGINNING
	    #\Keyboard:Home COM-GOTO-BEGINNING
	    #\m-> COM-GOTO-END
	    #\M-Keyboard:Down COM-GOTO-END
	    #\c-< COM-MARK-BEGINNING
	    #\c-> COM-MARK-END
	    #\c-SP COM-SET-POP-MARK
	    #\c-@ COM-SET-POP-MARK
	    #\m-SP COM-PUSH-POP-POINT-EXPLICIT
	    #\c-m-SP COM-MOVE-TO-PREVIOUS-POINT
	    #\CR COM-INSERT-CRS
	    #\c-O COM-MAKE-ROOM
	    #\c-m-O COM-SPLIT-LINE
	    #\m-O COM-THIS-INDENTATION
	    #\m-^ COM-DELETE-INDENTATION
	    #\c-m-^ COM-DELETE-INDENTATION
	    #\c-D COM-DELETE-FORWARD
	    #\RUBOUT COM-RUBOUT
	    #\c-RUBOUT COM-TAB-HACKING-RUBOUT
	    #\c-K COM-KILL-LINE
	    #\CLEAR COM-CLEAR
	    #\BREAK COM-BREAK
	    #\m-BREAK COM-DEBUGGER-BREAK
	    #\m-W COM-SAVE-REGION
	    #\c-W COM-KILL-REGION
	    #\c-m-W COM-APPEND-NEXT-KILL
	    #\c-Y COM-YANK
	    #\m-Y COM-YANK-POP
	    #\C-SH-F COM-QUICK-SHOW-FLAVOR-INIT-KEYWORDS-AND-DOCUMENTATION
	    #\c-sh-R COM-QUICK-REDO
	    #\Keyboard:Redo COM-QUICK-REDO
	    #\c-sh-U COM-QUICK-UNDO
	    #\Keyboard:Undo COM-QUICK-UNDO
	    #\c-sh-Y COM-YANK-MATCHING
	    #\m-sh-R COM-QUICK-REDO-IN-REGION
	    #\m-sh-U COM-QUICK-UNDO-IN-REGION
	    #\m-sh-Y COM-YANK-POP-MATCHING
	    #\c-L COM-RECENTER-WINDOW
;	    #\REFRESH COM-RECENTER-WINDOW
	    #\REFRESH COM-COMPLETE-REDISPLAY
	    #\PAGE COM-STANDARD
	    #\Complete COM-COMPLETE-DEFINITION-NAME
	    #\c-? COM-LIST-DEFINITION-NAMES
	    #\c-m-! COM-COMPLETE-REDISPLAY
	    #\c-U COM-QUADRUPLE-NUMERIC-ARG
	    #\c-- COM-NEGATE-NUMERIC-ARG
	    #\m-- COM-NEGATE-NUMERIC-ARG
	    #\c-m-- COM-NEGATE-NUMERIC-ARG
	    #\s-- COM-NEGATE-NUMERIC-ARG
	    #\c-s-- COM-NEGATE-NUMERIC-ARG
	    #\m-s-- COM-NEGATE-NUMERIC-ARG
	    #\c-m-s-- COM-NEGATE-NUMERIC-ARG
	    #\h-- COM-NEGATE-NUMERIC-ARG
	    #\c-h-- COM-NEGATE-NUMERIC-ARG
	    #\m-h-- COM-NEGATE-NUMERIC-ARG
	    #\c-m-h-- COM-NEGATE-NUMERIC-ARG
	    #\s-h-- COM-NEGATE-NUMERIC-ARG
	    #\c-s-h-- COM-NEGATE-NUMERIC-ARG
	    #\m-s-h-- COM-NEGATE-NUMERIC-ARG
	    #\c-m-s-h-- COM-NEGATE-NUMERIC-ARG
	    (#\c-0 10.)		COM-NUMBERS
	    (#\m-0 10.)		COM-NUMBERS
	    (#\c-m-0 10.)	COM-NUMBERS
	    (#\s-0 10.)		COM-NUMBERS
	    (#\c-s-0 10.)	COM-NUMBERS
	    (#\m-s-0 10.)	COM-NUMBERS
	    (#\c-m-s-0 10.)	COM-NUMBERS
	    (#\h-0 10.)		COM-NUMBERS
	    (#\c-h-0 10.)	COM-NUMBERS
	    (#\m-h-0 10.)	COM-NUMBERS
	    (#\c-m-h-0 10.)	COM-NUMBERS
	    (#\s-h-0 10.)	COM-NUMBERS
	    (#\c-s-h-0 10.)	COM-NUMBERS
	    (#\m-s-h-0 10.)	COM-NUMBERS
	    (#\c-m-s-h-0 10.)	COM-NUMBERS
	    #\c-T COM-EXCHANGE-CHARACTERS
	    #\m-T COM-EXCHANGE-WORDS
	    #\c-m-T COM-EXCHANGE-SEXPS
	    #\m-F COM-FORWARD-WORD
	    #\m-B COM-BACKWARD-WORD
	    #\m-K COM-KILL-SENTENCE
	    #\m-D COM-KILL-WORD
	    #\m-RUBOUT COM-BACKWARD-KILL-WORD
	    #\m-@ COM-MARK-WORD
	    #\c-m-F COM-FORWARD-SEXP
	    #\c-m-N COM-FORWARD-LIST
	    #\c-m-B COM-BACKWARD-SEXP
	    #\c-m-P COM-BACKWARD-LIST
	    #\c-m-K COM-KILL-SEXP
	    #\c-m-RUBOUT COM-BACKWARD-KILL-SEXP
	    #\c-m-@ COM-MARK-SEXP
	    #\c-m-/) COM-FORWARD-UP-LIST
	    #\c-m-/( COM-BACKWARD-UP-LIST
	    #\c-m-U COM-BACKWARD-UP-LIST
	    #\c-m-[ COM-BEGINNING-OF-DEFINITION
	    #\c-m-] COM-END-OF-DEFINITION
	    #\c-m-A COM-BEGINNING-OF-DEFINITION
	    #\c-m-E COM-END-OF-DEFINITION
	    #\c-m-D COM-DOWN-LIST
	    #\m-/( COM-MAKE-/(/)
	    #\m-/) COM-MOVE-OVER-/)
;	    #\c-m-G COM-FORMAT-CODE
	    #\m-] COM-FORWARD-PARAGRAPH
	    #\m-[ COM-BACKWARD-PARAGRAPH
	    #\m-H COM-MARK-PARAGRAPH
	    #\m-E COM-FORWARD-SENTENCE
	    #\m-A COM-BACKWARD-SENTENCE
	    #\c-G COM-BEEP
	    #\TAB COM-INSERT-TAB
	    #\c-m-TAB COM-INDENT-FOR-LISP
	    #\c-TAB COM-INDENT-DIFFERENTLY
	    #\LF COM-INDENT-NEW-LINE
	    #\c-m-Q COM-INDENT-SEXP
;; these are a trememdous pain in the butt outside zmacs.
;	    #\c-/; COM-INDENT-FOR-COMMENT
;	    #\m-/; COM-INDENT-FOR-COMMENT
;	    #\c-m-/; COM-KILL-COMMENT
;	    #\m-N COM-DOWN-COMMENT-LINE
	    #\C-SH-P COM-SHOW-PRESENTATION-ARGLIST
	    #\m-P COM-UP-COMMENT-LINE
	    #\m-Q COM-FILL-PARAGRAPH
	    #\m-sh-Q COM-FILL-DIFFERENTLY
	    #\c-m-sh-R COM-SHOW-RESOURCE-ARGLIST	;should this be here at all?
	    #\m-G COM-FILL-REGION
	    #\m-\ COM-DELETE-HORIZONTAL-SPACE
	    #\m-/| COM-JUST-ONE-SPACE
	    #\m-CR COM-BACK-TO-INDENTATION
	    #\m-M COM-BACK-TO-INDENTATION
	    #\c-m-CR COM-BACK-TO-INDENTATION
	    #\c-m-M COM-BACK-TO-INDENTATION
	    #\C-Return COM-END-OF-CODE-LINE
	    #\m-U COM-UPPERCASE-WORD
	    #\m-L COM-LOWERCASE-WORD
	    #\m-C COM-UPPERCASE-INITIAL
	    #\c-m-\ COM-INDENT-REGION
	    #\m-PAGE COM-INSERT-FF
	    #\m-REFRESH COM-INSERT-FF
	    #\m-I COM-INDENT-RELATIVE
	    #\m-TAB COM-INSERT-TAB
	    #\m-S COM-CENTER-LINE
	    #\m-= COM-COUNT-LINES-REGION
	    #\c-= COM-FAST-WHERE-AM-I
	    #\c-S COM-INCREMENTAL-SEARCH
	    #\Keyboard:Find COM-INCREMENTAL-SEARCH
	    #\c-R COM-REVERSE-INCREMENTAL-SEARCH
	    #\M-Keyboard:Find COM-REVERSE-INCREMENTAL-SEARCH
	    #\m-ALTMODE COM-EVALUATE-MINIBUFFER
	    #\c-sh-C COM-COMPILE-REGION
	    #\c-m-sh-C COM-COMPILE-REGION-TOGGLING-LOCATORS
	    #\c-shift-E COM-EVALUATE-REGION
	    #\c-m-shift-E COM-EVALUATE-REGION-VERBOSE
	    #\c-shift-M COM-MACRO-EXPAND-EXPRESSION
	    #\m-shift-M COM-MACRO-EXPAND-EXPRESSION-ALL
;	    #\c-? COM-SELF-DOCUMENT
	    #\m-? COM-SELF-DOCUMENT
	    #\c-m-? COM-DOCUMENTATION
	    #\HELP COM-DOCUMENTATION
	    #\c-HELP COM-DOCUMENTATION
	    #\c-Q COM-VARIOUS-QUANTITIES
	    #\m-X COM-EXTENDED-COMMAND
	    #\c-m-X COM-ANY-EXTENDED-COMMAND
	    #\c-m-Y COM-REPEAT-LAST-MINI-BUFFER-COMMAND
	    #\c-m-sh-Y COM-REPEAT-LAST-MATCHING-MINI-BUFFER-COMMAND
	    #\c-< COM-MARK-BEGINNING
	    #\c-> COM-MARK-END
	    #\m-LF COM-INDENT-NEW-COMMENT-LINE
	    #\c-% COM-REPLACE-STRING
	    #\m-% COM-QUERY-REPLACE
	    #\c-m-H COM-MARK-DEFINITION
	    #\c-m-R COM-REPOSITION-WINDOW
	    #\m-/' COM-UPCASE-DIGIT
	    #\c-shift-S COM-FIND-PATTERN
	    #\c-Z COM-QUIT
;	    #\END COM-QUIT
	    #\ABORT COM-ABORT-AT-TOP-LEVEL
	    #\c-shift-A COM-QUICK-ARGLIST
	    #\c-shift-D COM-LONG-DOCUMENTATION
	    #\c-shift-V COM-DESCRIBE-VARIABLE-AT-POINT
	    #\c-shift-A COM-QUICK-ARGLIST
	    ;; replaced by COM-SHOW-DOCUMENTATION, inserted later by Sage
;	    #\m-shift-D COM-BRIEF-DOCUMENTATION
	    #\c-shift-f  COM-QUICK-SHOW-FLAVOR-INIT-KEYWORDS-AND-DOCUMENTATION
	    #\c-J COM-CHANGE-STYLE-CHAR
	    #\m-J COM-CHANGE-STYLE-WORD
	    #\c-m-J COM-CHANGE-TYPEIN-STYLE
	    #\c-shift-J COM-SHOW-CHARACTER
	    #\m-# COM-TEXT-JUSTIFIER-CHANGE-FONT-WORD
	    #\m-_ COM-TEXT-JUSTIFIER-UNDERLINE-WORD
	    #\c-m-# COM-GOTO-CHARACTER
;	    #\Mouse-L COM-MOUSE-MARK-REGION
	    #\Mouse-L-2 COM-MOUSE-MOVE-REGION
;	    #\Mouse-M COM-MOUSE-MARK-THING
;	    #\c-Mouse-M COM-COPY-MOUSE
	    #\Mouse-M-2 COM-MOUSE-KILL-YANK
;	    #\c-m-Mouse-L COM-MOUSE-SET-BREAKPOINT
;	    #\c-m-Mouse-M COM-MOUSE-CLEAR-BREAKPOINT
	    )
	  (MAKE-COMMAND-ALIST
	   '(;; COM*:
	     COM-SET-PACKAGE COM-DESCRIBE-FUNCTION COM-SET-BASE COM-SET-LOWERCASE
	     COM-INSTALL-COMMAND COM-SET-KEY COM-ARGLIST COM-KEEP-LINES COM-FLUSH-LINES
	     COM-HOW-MANY COM-COUNT-LINES COM-COUNT-WORDS COM-COUNT-PARAGRAPHS
	     COM-COUNT-PAGES COM-COUNT-CHARS COM-QUERY-REPLACE COM-REPLACE-STRING
	     COM-OCCUR COM-LIST-MATCHING-LINES COM-WHERE-IS-SYMBOL
	     COM-COMPILE-REGION COM-COMPILE-BUFFER COM-EVALUATE-REGION COM-EVALUATE-BUFFER
	     COM-EVALUATE-REGION-HACK COM-EVALUATE-AND-REPLACE-INTO-BUFFER
	     COM-SHOW-REGISTER COM-LIST-REGISTERS COM-KILL-REGISTER
	     COM-LIST-VARIABLES COM-VARIABLE-APROPOS COM-DESCRIBE-VARIABLE COM-SET-VARIABLE
	     COM-GRIND-DEFINITION COM-GRIND-EXPRESSION COM-EVALUATE-INTO-BUFFER
	     COM-TRACE COM-UNTRACE
	     COM-ATOM-QUERY-REPLACE COM-FORMAT-CODE COM-MULTIPLE-QUERY-REPLACE
	     COM-QUERY-EXCHANGE
	     COM-QUERY-REPLACE-LAST-KILL COM-QUERY-REPLACE-LET-BINDING
	     COM-COUNT-OCCURRENCES
	     COM-FIND-UNBALANCED-PARENTHESES COM-MACRO-EXPAND-EXPRESSION
	     COM-MACRO-EXPAND-EXPRESSION-ALL
	     COM-COMPILER-OPTIMIZE-TOP-LEVEL-FORM COM-SHOW-EFFECT-OF-DEFINITION
	     COM-FILL-LONG-COMMENT
	     COM-SORT-LINES COM-SORT-PARAGRAPHS
	     COM-EXECUTE-COMMAND-INTO-BUFFER COM-INSERT-DATE COM-INSERT-CRASH-DATA
	     COM-DISASSEMBLE
;	     COM-PARSE-COMMAND-LINE
	     COM-REVERSE-LINES COM-INSERT-BUG-HERALD
	     ;; DOC:
	     COM-LIST-COMMANDS COM-APROPOS COM-WHERE-IS COM-DESCRIBE-COMMAND
	     ;; FILES:
	     COM-INSERT-FILE COM-WRITE-REGION COM-APPEND-TO-FILE COM-PREPEND-TO-FILE
	     COM-SHOW-FILE COM-LIST-FILES
	     COM-RENAME-FILE COM-DELETE-FILE COM-UNDELETE-FILE
	     COM-COPY-FILE COM-CREATE-LINK COM-CREATE-DIRECTORY
	     COM-ENABLE-HOST-CAPABILITIES COM-DISABLE-HOST-CAPABILITIES
	     ;; COM-HARDCOPY-FILE COM-HARDCOPY-REGION COM-SHOW-HARDCOPY-STATUS
	     ;; DIRS:
	     COM-LIST-ALL-DIRECTORY-NAMES COM-SHOW-DIRECTORY
	     COM-EXPUNGE-DIRECTORY COM-SHOW-LOGIN-DIRECTORY
	     ;; MODES:
	     COM-LISP-MODE COM-TEXT-MODE COM-FUNDAMENTAL-MODE COM-BOLIO-MODE
	     COM-ATOM-WORD-MODE COM-EMACS-MODE COM-OVERWRITE-MODE COM-SCRIBE-MODE
	     COM-TECO-MODE COM-MACSYMA-MODE COM-AUTO-FILL-MODE COM-WORD-ABBREV-MODE
	     COM-INSERT-WORD-ABBREVS COM-KILL-ALL-WORD-ABBREVS COM-LIST-WORD-ABBREVS
	     COM-DEFINE-WORD-ABBREVS COM-EDIT-WORD-ABBREVS COM-LIST-SOME-WORD-ABBREVS
	     COM-WRITE-WORD-ABBREV-FILE COM-READ-WORD-ABBREV-FILE COM-MAKE-WORD-ABBREV
	     COM-MIDAS-MODE
	     COM-ELECTRIC-SHIFT-LOCK-MODE
	     COM-ELECTRIC-CHARACTER-STYLE-LOCK-MODE
	     COM-UPPERCASE-CODE-IN-REGION COM-LOWERCASE-CODE-IN-REGION
             ;; FONT, KBDMAC, DIRED, INDENT
	     COM-SET-VSP COM-CHANGE-ONE-STYLE-REGION
	     COM-INSTALL-MACRO COM-INSTALL-MOUSE-MACRO COM-DEINSTALL-MACRO
	     COM-SHOW-KEYBOARD-MACRO COM-NAME-LAST-KBD-MACRO COM-TABIFY COM-UNTABIFY
	     COM-FIND-CHARACTER-IN-STYLE COM-SHOW-CHARACTER-STYLES
	     ;; FLAVOR
	     COM-SHOW-FLAVOR-COMPONENTS COM-SHOW-FLAVOR-INSTANCE-VARIABLES
	     COM-SHOW-FLAVOR-METHODS COM-SHOW-FLAVOR-INITIALIZATIONS
	     COM-SHOW-FLAVOR-FUNCTIONS COM-SHOW-FLAVOR-OPERATIONS
	     COM-SHOW-FLAVOR-DEPENDENTS COM-SHOW-FLAVOR-DIFFERENCES
	     COM-SHOW-GENERIC-FUNCTION COM-SHOW-FLAVOR-HANDLER
	     ;; UNDO
	     COM-UNDO COM-REDO COM-DISCARD-CHANGE-HISTORY
	     2;;; DW
0	     COM-SHOW-PRESENTATION-TYPE
2	     ;; CLOS
0	     COM-SHOW-CLASS-SUPERCLASSES COM-SHOW-CLASS-SUBCLASSES
	     COM-SHOW-CLASS-INITARGS COM-SHOW-CLASS-SLOTS
	     COM-SHOW-CLASS-METHODS
	     COM-SHOW-CLASS-GENERIC-FUNCTIONS
	     COM-SHOW-CLOS-GENERIC-FUNCTION
	     COM-SHOW-EFFECTIVE-METHOD
	     ))))
  (SETQ *STANDARD-CONTROL-X-COMTAB*
	(SET-COMTAB "Zwei Control-X"
		    '(#\c-G COM-PREFIX-BEEP
		      #\c-D COM-DISPLAY-DIRECTORY
		      #\c-N COM-SET-GOAL-COLUMN
		      #\c-P COM-MARK-PAGE
		      #\c-X COM-SWAP-POINT-AND-MARK
		      #/G COM-OPEN-GET-REGISTER
		      #/X COM-PUT-REGISTER
		      #/L COM-COUNT-LINES-PAGE
		      #\RUBOUT COM-BACKWARD-KILL-SENTENCE
		      #/; COM-SET-COMMENT-COLUMN
		      #\c-/; COM-COMMENT-OUT-REGION
		      #/. COM-SET-FILL-PREFIX
		      #/F COM-SET-FILL-COLUMN
		      #\c-U COM-UPPERCASE-REGION
		      #\c-L COM-LOWERCASE-REGION
		      #\c-O COM-DELETE-BLANK-LINES
		      #\c-I COM-INDENT-RIGIDLY
		      #/= COM-WHERE-AM-I
		      #/[ COM-PREVIOUS-PAGE
		      #/] COM-NEXT-PAGE
		      #/H COM-MARK-WHOLE
		      #\c-C COM-QUIT
		      #\c-J COM-CHANGE-STYLE-REGION
		      #/( COM-START-KBD-MACRO
		      #/) COM-END-KBD-MACRO
		      #/E COM-CALL-LAST-KBD-MACRO
		      #/Q COM-KBD-MACRO-QUERY
		      #\ALTMODE COM-REPEAT-LAST-MINI-BUFFER-COMMAND
		      #\c-T COM-EXCHANGE-LINES
		      #/S COM-SAVE-POSITION
		      #/J COM-JUMP-TO-SAVED-POSITION
		      #/T COM-EXCHANGE-REGIONS
		      #/I COM-INSERT-FILE
		      #/# COM-TEXT-JUSTIFIER-CHANGE-FONT-REGION
		      #/_ COM-TEXT-JUSTIFIER-UNDERLINE-REGION
		      #\c-m-SP COM-MOVE-TO-DEFAULT-PREVIOUS-POINT
		      #\HELP COM-DOCUMENT-CONTAINING-PREFIX-COMMAND
		      #\ABORT COM-PREFIX-ABORT
		      #\W COM-WRITE-BUFFER
		      #\C-Space COM-CANONICALIZE-WHITESPACE
		      )))
  (SET-COMTAB-CONTROL-INDIRECTION *STANDARD-CONTROL-X-COMTAB*)
  (SET-COMTAB *STANDARD-COMTAB*
              (LIST #\c-X (MAKE-EXTENDED-COMMAND *STANDARD-CONTROL-X-COMTAB*)))
  #||
  (SETQ *COMPLETING-READER-COMTAB*
	(SET-COMTAB "Completing Reader"
		    '(#\COMPLETE COM-COMPLETE
		      #\ALTMODE COM-COMPLETE
		      #\SP COM-SELF-INSERT-AND-COMPLETE
		      #/) COM-SELF-INSERT-AND-COMPLETE
		      #\c-? COM-LIST-COMPLETIONS
		      #\c-Q COM-QUOTED-INSERT
		      #\HELP COM-DOCUMENT-COMPLETING-READ
		      #\c-// COM-COMPLETION-APROPOS
		      #\CR COM-COMPLETE-AND-EXIT
		      #\c-G COM-MINI-BUFFER-BEEP
		      #\ABORT COM-RECURSIVE-EDIT-ABORT
		      #\END COM-COMPLETE-AND-EXIT-IF-UNIQUE
		      #\MOUSE-1-1 COM-MOUSE-END-OF-MINI-BUFFER
		      #\MOUSE-3-1 COM-MOUSE-LIST-COMPLETIONS
		      #\m-Y COM-MINI-BUFFER-OR-YANK-POP
		      #\c-m-Y COM-YANK-IN-CONTEXT
		      #\c-Z :UNDEFINED
		      #\m-Z :UNDEFINED
		      #\c-m-Z :UNDEFINED)))
  (SET-COMTAB-INDIRECTION *COMPLETING-READER-COMTAB* *STANDARD-COMTAB*)
  (SETQ *SELECT-BUFFER-COMTAB*
	(SET-COMTAB "Select Buffer" '(#\c-CR COM-CREATE-NEW-BUFFER-FROM-MINIBUFFER)))
  (SET-COMTAB-INDIRECTION *SELECT-BUFFER-COMTAB* *COMPLETING-READER-COMTAB*)
  ||#
  (SETQ *CONTROL-R-COMTAB*
	(SET-COMTAB "Control-R"
		    '(#\c-ALTMODE COM-EXIT-CONTROL-R
		      #\END COM-EXIT-CONTROL-R
		      #\ABORT COM-EXIT-CONTROL-R
		      #\c-Z :UNDEFINED
		      )))
  (SET-COMTAB-INDIRECTION *CONTROL-R-COMTAB* *STANDARD-COMTAB*)
  (SETQ *RECURSIVE-EDIT-COMTAB*
	(SET-COMTAB "Recursive Edit"
		    '(#\c-ALTMODE COM-EXIT-CONTROL-R
		      #\END COM-EXIT-CONTROL-R
		      #\c-G COM-RECURSIVE-EDIT-BEEP
		      #\ABORT COM-RECURSIVE-EDIT-ABORT
		      #\c-Z :UNDEFINED
		      )))
  (SET-COMTAB-INDIRECTION *RECURSIVE-EDIT-COMTAB* *STANDARD-COMTAB*)
  (SETQ *STANDALONE-COMTAB*
	(SET-COMTAB "Standalone"
		    '(#\END COM-QUIT
		      #\c-ALTMODE COM-QUIT)))
  (SET-COMTAB-INDIRECTION *STANDALONE-COMTAB* *STANDARD-COMTAB*)
  (SETQ *MINI-IE-COMTAB* (SET-COMTAB "Mini buffer IE"
				     '(#\c-Q COM-QUOTED-INSERT
				       #\c-G COM-MINI-BUFFER-BEEP
				       #\ABORT COM-RECURSIVE-EDIT-ABORT
				       #\m-Y COM-MINI-BUFFER-OR-YANK-POP
				       #\c-m-Y COM-YANK-IN-CONTEXT
				       #\m-sh-Y COM-MINI-BUFFER-OR-YANK-POP-MATCHING
				       #\c-m-sh-Y COM-YANK-MATCHING-IN-CONTEXT

				       #\c-Z :UNDEFINED
				       #\m-Z :UNDEFINED
				       #\c-m-Z :UNDEFINED
				       
				       #\Complete COM-MINI-IE-SPECIAL-CHARACTER
				       #\Super-Complete COM-MINI-IE-SPECIAL-CHARACTER
				       #\c-? COM-MINI-IE-SPECIAL-CHARACTER
				       #\c-// COM-MINI-IE-SPECIAL-CHARACTER
				       #\END COM-MINI-IE-SPECIAL-CHARACTER
				       #\C-CR COM-MINI-IE-SPECIAL-CHARACTER
				       #\M-/; :UNDEFINED
				       #\HELP COM-MINI-IE-HELP
				       
				       #\CR COM-MINI-IE-SPECIAL-CHARACTER-OR-INSERT-RETURN
				       )))
  (SET-COMTAB-INDIRECTION *MINI-IE-COMTAB* *STANDARD-COMTAB*)
  )

;;; This takes a list of commands (symbols, or, for custom command names, instances of
;;; '(name . symbol)), and returns an alist associating their names with the commands.
;;; The ordering is preserved.
(DEFUN MAKE-COMMAND-ALIST (COMMAND-LIST &AUX (ALIST NIL))
  (DOLIST (COM COMMAND-LIST)
    (LET ((NAME (GET (IF (LISTP COM) (CDR COM) COM) 'COMMAND-NAME)))
      (COND ((NULL NAME)
	     ;; This used to be FSIGNAL, which would inappropriately
	     ;; require manual intervention while loading.
	     (SCL:WARN "~S is not a defined command.  It will be omitted from the alist." COM))
	    (T (PUSH (IF (LISTP COM) COM (CONS NAME COM)) ALIST)))))
  (NREVERSE ALIST))

(DEFUN MAKE-MOUSE-COMMAND-ALIST (COMMAND-LIST)
  (LOOP FOR COM IN COMMAND-LIST
	AS NAME = (GET (IF (LISTP COM) (CDR COM) COM) 'COMMAND-NAME)
	WHEN (NULL NAME)
	DO (FSIGNAL "~S is not a defined command, it will be omitted from the alist" COM)
	ELSE DO (WHEN (STRING-EQUAL NAME "Mouse " 0 0 6 6)
		  (SETQ NAME (SUBSTRING NAME 6)))
	AND COLLECT (IF (LISTP COM) COM (CONS NAME COM))))

(DEFUN TYPEOUT-MENU-CHOOSE (ALIST PROMPT &OPTIONAL (DESCRIPTION "choice"))
  (TYPEIN-LINE-ACCEPT `((DW:MENU-CHOOSE :ALIST ,ALIST) :DESCRIPTION ,DESCRIPTION)
		      :PROMPT PROMPT :INITIALLY-DISPLAY-POSSIBILITIES T))

(DEFUN PICK-COMTAB-OR-INDIRECT (COMTAB PROMPT)
  (LET* ((COMTAB-LIST (LOOP FOR CT FIRST COMTAB THEN (COMTAB-INDIRECT-TO CT)
				      WHILE CT COLLECT (CONS (DEDUCE-COMTAB-NAME CT) CT)))
	 (CHOICE (IF ( (LENGTH COMTAB-LIST) 1)
		     (CDAR COMTAB-LIST)
		   (TYPEOUT-MENU-CHOOSE COMTAB-LIST PROMPT "a command table"))))
    (IF (NULL CHOICE) (ABORT-CURRENT-COMMAND) CHOICE)))

(DEFUN DEDUCE-COMTAB-NAME (COMTAB)
  (IF (AND (EQUAL (COMTAB-NAME COMTAB) "Unnamed")
	   (EQ COMTAB *MODE-COMTAB*))
      "Just this editor"
      (COMTAB-NAME COMTAB)))

;;; Mouse prompting stuff

#||
;;; Temporary combination of old and new style usage.
(DEFUN COMTAB-MOUSE-DOCUMENTATION (COMTAB)
  (OR (COMTAB-MOUSE-DOCUMENTATION-CACHE COMTAB)
      (LET ((STRING (MAKE-EMPTY-STRING 95.)))
	(COMTAB-MOUSE-PROMPT COMTAB STRING)
	(SETF (COMTAB-MOUSE-DOCUMENTATION-CACHE COMTAB) STRING)
	STRING)))

(DEFUN COMTAB-MOUSE-PROMPT (COMTAB STRING &AUX (INHIBIT-SCHEDULING-FLAG T))
  (STORE-ARRAY-LEADER 0 STRING 0)
  (DO ((BUTTON 0 (1+ BUTTON))
       (NAMES '(#/L #/M #/R) (CDR NAMES))
       (FIRST-P T))
      (( BUTTON 3)
       (OR FIRST-P (ARRAY-PUSH-EXTEND STRING #/.)))
    (DO ((BITS 0 (1+ BITS))
	 (COMMAND) (PROMPT))
	(( BITS 40))
      (LET ((CHAR (MAKE-MOUSE-CHAR BUTTON BITS)))
	(COND ((OR (AND (SETQ COMMAND (COMMAND-LOOKUP CHAR COMTAB))
			(OR (SETQ PROMPT (GET COMMAND ':MOUSE-SHORT-DOCUMENTATION))
			    (AND (MENU-COMMAND-P COMMAND)
				 (SETQ PROMPT "Menu"))))
		   (AND (CHAR-MOUSE-EQUAL CHAR #\Mouse-R-2)
			(SETQ PROMPT "System menu")))
	       (IF FIRST-P
		   (SETQ FIRST-P NIL)
		   (APPEND-TO-ARRAY STRING ", "))
	       (WHEN (> BITS 0)
		 (WITH-OUTPUT-TO-STRING (STREAM STRING)
		   (FORMAT:FORMAT-CHARACTER-BITS STREAM BITS NIL (BIT-TEST 20 BITS))))
	       (ARRAY-PUSH-EXTEND STRING (CAR NAMES))
	       (ARRAY-PUSH-EXTEND STRING #/:)
	       (APPEND-TO-ARRAY STRING PROMPT))))))
  STRING)
||#

;;; This makes WINDOW edit INTERVAL.
(DEFMETHOD (:SET-WINDOW-INTERVAL EDITOR) (WINDOW INTERVAL)
  (SET-WINDOW-INTERVAL WINDOW INTERVAL))

(DEFUN SET-WINDOW-INTERVAL (WINDOW INTERVAL)
  (SETF (WINDOW-INTERVAL WINDOW) INTERVAL)
  (LET ((FIRST-BP (INTERVAL-FIRST-BP INTERVAL)))
    (SETF (WINDOW-POINT WINDOW) (COPY-BP FIRST-BP ':NORMAL INTERVAL))
    (SETF (WINDOW-MARK WINDOW) (COPY-BP FIRST-BP ':NORMAL INTERVAL))
    (SETF (WINDOW-START-BP WINDOW) (COPY-BP FIRST-BP ':NORMAL INTERVAL))))

;;; This changes the current window, as called by the mouse
(DEFUN MAKE-WINDOW-CURRENT (WINDOW &OPTIONAL (SELECT-P T))
  (SEND *CURRENT-COMMAND-LOOP* ':MAKE-WINDOW-CURRENT WINDOW SELECT-P))

(DEFMETHOD (:MAKE-WINDOW-CURRENT EDITOR) (WINDOW &OPTIONAL (SELECT-P T) &AUX INTERVAL)
  (SETQ *WINDOW-LIST* (CONS WINDOW (DELQ WINDOW *WINDOW-LIST*)))
  (WHEN (AND (NEQ WINDOW *WINDOW*) (NEQ *WINDOW* *MINI-BUFFER-WINDOW*)
	     (OR (NEQ WINDOW *MINI-BUFFER-WINDOW*) *MINI-BUFFER-COMMAND-IN-PROGRESS*))
    (SETQ *WINDOW* WINDOW
	  INTERVAL (WINDOW-INTERVAL WINDOW))
    (SEND SELF ':SET-INTERVAL INTERVAL)
    (SETQ *TYPEOUT-WINDOW* (WINDOW-TYPEOUT-WINDOW WINDOW)
	  TERMINAL-IO *TYPEOUT-WINDOW*)
    (MULTIPLE-VALUE (*MODE-LINE-WINDOW* *TYPEIN-WINDOW* *MINI-BUFFER-WINDOW*)
      (WINDOW-MODE-LINE-WINDOWS WINDOW))
    (WHEN (EQ STANDARD-INPUT *ZMACS-STREAM*)
      (SEND STANDARD-INPUT :SET-STREAM (WINDOW-SHEET WINDOW)))
    (AND SELECT-P (SELECT-WINDOW WINDOW))))

;;; This is here so that ZMACS can redefine it
(DEFMETHOD (:SET-INTERVAL EDITOR) (INTERVAL)
  (OR (EQ (WINDOW-INTERVAL *WINDOW*) INTERVAL)
      (SET-WINDOW-INTERVAL *WINDOW* INTERVAL))
  (SETQ *INTERVAL* INTERVAL))

;;; Syntax table stuff.

(DEFUN COPY-SYNTAX-TABLE (SYNTAX-TABLE)
  (LET ((NEW-TABLE (MAKE-ARRAY 400)))
    (LOOP FOR I UPFROM 0 BELOW 400
	  DO (SETF (AREF NEW-TABLE I) (AREF SYNTAX-TABLE I)))
    NEW-TABLE))

(DEFUN CHAR-SYNTAX (CHAR SYNTAX-TABLE)
  (IF (ZEROP (CHAR-BITS CHAR))
      (LET ((CODE (CHAR-CODE CHAR)))
	(IF (< CODE (ARRAY-LENGTH SYNTAX-TABLE))
	    (AREF SYNTAX-TABLE CODE)
	    (MULTIPLE-VALUE-BIND (CHARACTER-SET CHARACTER-INDEX)
		(SI:CHAR-CHAR-SET-AND-INDEX CHAR)
	      (SI:CHARACTER-SET-CHAR-SYNTAX CHARACTER-SET CHARACTER-INDEX SYNTAX-TABLE))))
      WORD-DELIMITER))

(DEFMETHOD (SI:CHARACTER-SET-CHAR-SYNTAX SI:STANDARD-CHARACTER-SET) (INDEX SYNTAX-TABLE)
  (IF (< INDEX (ARRAY-LENGTH SYNTAX-TABLE))
      (AREF SYNTAX-TABLE INDEX)
      ;; If it's past the end of the syntax table, assume it's like a letter.
      (AREF SYNTAX-TABLE (CHAR-CODE #/A))))

(DEFMETHOD (SI:CHARACTER-SET-CHAR-SYNTAX SI:BASIC-CHARACTER-SET :DEFAULT) (IGNORE IGNORE)
  WORD-DELIMITER)

;; All characters are word delimiters
(DEFMETHOD (SI:CHARACTER-SET-CHAR-SYNTAX SI:CHARACTER-SET-ALL-DELIMITERS-MIXIN)
	   (INDEX SYNTAX-TABLE)
  (IGNORE INDEX SYNTAX-TABLE)
  WORD-DELIMITER)

(DEFUN SET-CHAR-SYNTAX (SYNTAX SYNTAX-TABLE CHAR)
  (ASET SYNTAX SYNTAX-TABLE (CHAR-CODE CHAR)))

#+IGNORE ( ;; flush sparse syntax tables
(3 0 (NIL 0) (NIL NIL :SMALL) "TVFONT")(DEFUN CHAR-SYNTAX (CHAR SYNTAX-TABLE)
  (SETQ CHAR (CHAR-CODE CHAR))
  (COND ((ARRAYP SYNTAX-TABLE)
	 (IF ( CHAR (ARRAY-LENGTH SYNTAX-TABLE))
	     (AREF SYNTAX-TABLE (CHAR-CODE #/A))
	     (AREF SYNTAX-TABLE CHAR)))
	((CDR (ASSQ CHAR (CDR SYNTAX-TABLE))))
	((CHAR-SYNTAX CHAR (CAR SYNTAX-TABLE)))))

(DEFUN SET-CHAR-SYNTAX (SYNTAX SYNTAX-TABLE CHAR &AUX TEM)
  (COND ((ARRAYP SYNTAX-TABLE)
	 (ASET SYNTAX SYNTAX-TABLE (CHAR-CODE CHAR)))
	((SETQ TEM (ASSQ CHAR (CDR SYNTAX-TABLE)))
	 (RPLACD TEM SYNTAX))
	(T
	 (PUSH (CONS CHAR SYNTAX) (CDR SYNTAX-TABLE)))))

(DEFUN MAKE-SPARSE-SYNTAX-TABLE (INDIRECT-TO)
  (NCONS INDIRECT-TO))
0) ;; end of #+IGNORE

(DEFUN MAKE-SYNTAX-TABLE (SPECS)
  (DO ((SPECS SPECS (CDR SPECS))
       (SPEC)
       (I 0)
       (TABLE (MAKE-ARRAY 400)))
      ((NULL SPECS)
       (IF (NOT (= I 400))
	   (FERROR NIL "Wrong number (~S) of elements in the specs" I))
       TABLE)
    (SETQ SPEC (CAR SPECS))
    (COND ((SYMBOLP SPEC)
	   (ASET (SYMEVAL SPEC) TABLE I)
	   (SETQ I (1+ I)))
	  (T (DO ((J 0 (1+ J))
		  (VALUE (SYMEVAL (SECOND SPEC)))
		  (LIMIT (FIRST SPEC)))
		 (( J LIMIT))
	       (ASET VALUE TABLE I)
	       (SETQ I (1+ I)))))))

(DEFUN INITIALIZE-SYNTAX-TABLES ()
  (SETQ *WORD-SYNTAX-TABLE* (MAKE-SYNTAX-TABLE
			      '((40 WORD-ALPHABETIC)
				WORD-DELIMITER		;040 space
				WORD-DELIMITER		;041 !
				WORD-DELIMITER		;042 "
				WORD-DELIMITER		;043 #
				WORD-DELIMITER		;044 $
				WORD-DELIMITER		;045 %
				WORD-DELIMITER		;046 &
				WORD-DELIMITER		;047 '
				WORD-DELIMITER		;050 (
				WORD-DELIMITER		;051 )
				WORD-DELIMITER		;052 *
				WORD-DELIMITER		;053 +
				WORD-DELIMITER		;054 ,
				WORD-DELIMITER		;055 -
				WORD-DELIMITER		;056 .
				WORD-DELIMITER		;057 /
				(10. WORD-ALPHABETIC)	;Digits
				WORD-DELIMITER		;072 :
				WORD-DELIMITER		;073 ;
				WORD-DELIMITER		;074 <
				WORD-DELIMITER		;075 =
				WORD-DELIMITER		;076 >
				WORD-DELIMITER		;077 ?
				WORD-DELIMITER		;100 @
				(26. WORD-ALPHABETIC)	;Uppercase letters
				WORD-DELIMITER		;133 [
				WORD-DELIMITER		;134 \
				WORD-DELIMITER		;135 ]
				WORD-DELIMITER		;136 ^
				WORD-DELIMITER		;137 _
				WORD-DELIMITER		;140 `
				(26. WORD-ALPHABETIC)	;Lowercase letters
				(205 WORD-DELIMITER)))
	*LIST-SYNTAX-TABLE* (MAKE-SYNTAX-TABLE
			      '((40 LIST-ALPHABETIC)
				LIST-DELIMITER		;040 space
				LIST-ALPHABETIC		;041 !
				LIST-DOUBLE-QUOTE	;042 "
				LIST-SINGLE-QUOTE	;043 #
				LIST-ALPHABETIC		;044 $
				LIST-ALPHABETIC		;045 %
				LIST-ALPHABETIC		;046 &
				LIST-SINGLE-QUOTE	;047 '
				LIST-OPEN		;050 (
				LIST-CLOSE		;051 )
				LIST-ALPHABETIC		;052 *
				LIST-ALPHABETIC		;053 +
				LIST-SINGLE-QUOTE	;054 ,
				LIST-ALPHABETIC		;055 -
				LIST-ALPHABETIC		;056 .
				LIST-SLASH		;057 /
				(10. LIST-ALPHABETIC)	;Digits
				LIST-COLON		;072 :
				LIST-COMMENT		;073 ;
				LIST-ALPHABETIC		;074 <
				LIST-ALPHABETIC		;075 =
				LIST-ALPHABETIC		;076 >
				LIST-ALPHABETIC		;077 ?
				LIST-SINGLE-QUOTE	;100 @
				(26. LIST-ALPHABETIC)	;Uppercase letters
				LIST-ALPHABETIC		;133 [
				LIST-ALPHABETIC		;134 \
				LIST-ALPHABETIC		;135 ]
				LIST-ALPHABETIC		;136 ^
				LIST-ALPHABETIC		;137 _
				LIST-SINGLE-QUOTE	;140 `
				(26. LIST-ALPHABETIC)	;Lowercase letters
				LIST-ALPHABETIC		;173 {
				LIST-VERTICAL-BAR	;174 |
				LIST-ALPHABETIC		;175 }
				LIST-ALPHABETIC		;176 ~
				LIST-ALPHABETIC		;177 
				
				LIST-ALPHABETIC		;200 null
				LIST-DELIMITER		;201 break
				LIST-DELIMITER		;202 clear
				LIST-DELIMITER		;203 call
				LIST-DELIMITER		;204 escape
				LIST-DELIMITER		;205 backnext
				LIST-DELIMITER		;206 help
				LIST-DELIMITER		;207 rubout
				LIST-ALPHABETIC		;210 bs
				LIST-DELIMITER		;211 tab
				LIST-DELIMITER		;212 line
				LIST-DELIMITER		;213 refresh
				LIST-DELIMITER		;214 page
				LIST-DELIMITER		;215 return
				(162 LIST-ALPHABETIC)))
	*ATOM-WORD-SYNTAX-TABLE* (MAKE-SYNTAX-TABLE
				   '((40 LIST-ALPHABETIC)
				     WORD-DELIMITER	;040 space
				     WORD-ALPHABETIC	;041 !
				     WORD-ALPHABETIC	;042 "
				     WORD-ALPHABETIC	;043 #
				     WORD-ALPHABETIC	;044 $
				     WORD-ALPHABETIC	;045 %
				     WORD-ALPHABETIC	;046 &
				     WORD-DELIMITER	;047 '
				     WORD-DELIMITER	;050 (
				     WORD-DELIMITER	;051 )
				     WORD-ALPHABETIC	;052 *
				     WORD-ALPHABETIC	;053 +
				     WORD-DELIMITER	;054 ,
				     WORD-ALPHABETIC	;055 -
				     WORD-ALPHABETIC	;056 .
				     WORD-ALPHABETIC	;057 /
				     (10. WORD-ALPHABETIC) ;Digits
				     WORD-ALPHABETIC	;072 :
				     WORD-DELIMITER	;073 ;
				     WORD-ALPHABETIC	;074 <
				     WORD-ALPHABETIC	;075 =
				     WORD-ALPHABETIC	;076 >
				     WORD-ALPHABETIC	;077 ?
				     WORD-DELIMITER	;100 @
				     (26. WORD-ALPHABETIC) ;Uppercase letters
				     WORD-ALPHABETIC	;133 [
				     WORD-ALPHABETIC	;134 \
				     WORD-ALPHABETIC	;135 ]
				     WORD-ALPHABETIC	;136 ^
				     WORD-ALPHABETIC	;137 _
				     WORD-DELIMITER	;140 `
				     (31. WORD-ALPHABETIC) ;Lowercase letters
				     (200 WORD-DELIMITER))))
  (SETQ *CL-LIST-SYNTAX-TABLE* (COPY-SYNTAX-TABLE *LIST-SYNTAX-TABLE*))
  (SET-CHAR-SYNTAX LIST-SLASH *CL-LIST-SYNTAX-TABLE* #/\ )
  (SET-CHAR-SYNTAX LIST-ALPHABETIC *CL-LIST-SYNTAX-TABLE* #// )
  (SETQ *PNAME-WORD-SYNTAX-TABLE* (COPY-SYNTAX-TABLE *ATOM-WORD-SYNTAX-TABLE*))
  2;; all the pathname delimiters we know about.
0  (SET-CHAR-SYNTAX WORD-DELIMITER *PNAME-WORD-SYNTAX-TABLE* #/:)
  (SET-CHAR-SYNTAX WORD-DELIMITER *PNAME-WORD-SYNTAX-TABLE* #/)
  (SET-CHAR-SYNTAX WORD-DELIMITER *PNAME-WORD-SYNTAX-TABLE* #/.)
  (SET-CHAR-SYNTAX WORD-DELIMITER *PNAME-WORD-SYNTAX-TABLE* #/>)
  (SET-CHAR-SYNTAX WORD-DELIMITER *PNAME-WORD-SYNTAX-TABLE* #/;)
  (SET-CHAR-SYNTAX WORD-DELIMITER *PNAME-WORD-SYNTAX-TABLE* #/-)
  (SET-CHAR-SYNTAX WORD-DELIMITER *PNAME-WORD-SYNTAX-TABLE* #/|)
  (SET-CHAR-SYNTAX WORD-DELIMITER *PNAME-WORD-SYNTAX-TABLE* #//)
  (SET-CHAR-SYNTAX WORD-DELIMITER *PNAME-WORD-SYNTAX-TABLE* #/>)
  (SET-CHAR-SYNTAX WORD-DELIMITER *PNAME-WORD-SYNTAX-TABLE* #/])
  (SET-CHAR-SYNTAX WORD-DELIMITER *PNAME-WORD-SYNTAX-TABLE* #/[)
  (SET-CHAR-SYNTAX WORD-DELIMITER *PNAME-WORD-SYNTAX-TABLE* #/@)
  (SETQ *C-WORD-SYNTAX-TABLE* (COPY-SYNTAX-TABLE *WORD-SYNTAX-TABLE*))
  (SET-CHAR-SYNTAX WORD-ALPHABETIC *C-WORD-SYNTAX-TABLE* #/$ )
  (SET-CHAR-SYNTAX WORD-ALPHABETIC *C-WORD-SYNTAX-TABLE* #/% )
  (SET-CHAR-SYNTAX WORD-ALPHABETIC *C-WORD-SYNTAX-TABLE* #/_ ))


;;; Initialization stuff

;;; This initializes all ZWEI globals.  This hacks the ones common to all
;;; ZWEI, but not the ZMACS ones.  It first sets some unusual things, then
;;; initializes the ZWEI variables (the ones defined with DEFVAR in the MACROS file),
;;; then sets up the incremental search command (which has some magic globals).
;;; Finally it sets up the comtabs and syntax tables, and the minibuffer window.
(DEFUN INITIALIZE-ZWEI-GLOBALS ()
  (SETQ *UTILITY-PACKAGE* (SI:PKG-CREATE-PACKAGE "ZWEI Utility Package" NIL))
  (DOLIST (VAR *GLOBAL-INITIALIZATION-LIST*)	;Reset other variables defined by DEFGLOBAL
    (SET (CAR VAR) (EVAL (CDR VAR))))
  (SETQ-ZWEI-VARIABLES)
  (INITIALIZE-WORD-ABBREV-TABLE)
  ;(INITIALIZE-INCREMENTAL-SEARCH-GLOBALS)	;Done by Incremental Search
  (INITIALIZE-STANDARD-COMTABS)
  (INITIALIZE-SYNTAX-TABLES)
  (INITIALIZE-MINI-BUFFER)
  (INITIALIZE-TAB-STOP-BUFFER)
  (SETQ *PATHNAME-DEFAULTS* (FS:MAKE-PATHNAME-DEFAULTS)
	*AUX-PATHNAME-DEFAULTS* (FS:MAKE-PATHNAME-DEFAULTS))
  )

(DEFVAR *MINI-BUFFER-MULTI-LINE-COMTAB*)
(DEFVAR *MINI-BUFFER-COMTAB*)
(DEFVAR *MINI-BUFFER-REPEATED-COMMAND*)
(DEFVAR *FQUERY-MINI-BUFFER-COMTAB*)

(DEFUN INITIALIZE-MINI-BUFFER ()
  (SETQ *MINI-BUFFER-REPEATED-COMMAND* NIL)
  (SETQ *MINI-BUFFER-MULTI-LINE-COMTAB*
	(SET-COMTAB "Mini Buffer Multi Line"
		    '(#\HELP COM-DOCUMENT-CONTAINING-COMMAND
		      #\c-CR COM-END-OF-MINI-BUFFER
		      #\END COM-END-OF-MINI-BUFFER
		      #\c-G COM-MINI-BUFFER-BEEP
		      #\ABORT COM-RECURSIVE-EDIT-ABORT
		      #\c-Z :UNDEFINED
		      #\m-Z :UNDEFINED
		      #\c-m-Z :UNDEFINED
		      #\m-Y COM-MINI-BUFFER-OR-YANK-POP
		      #\c-m-Y COM-YANK-IN-CONTEXT
		      #\m-sh-Y COM-MINI-BUFFER-OR-YANK-POP-MATCHING
		      #\c-m-sh-Y COM-YANK-MATCHING-IN-CONTEXT
		      #\M-/; :UNDEFINED
		      )))
  (SET-COMTAB-INDIRECTION *MINI-BUFFER-MULTI-LINE-COMTAB* *STANDARD-COMTAB*)
  (SETQ *MINI-BUFFER-COMTAB* (SET-COMTAB "Mini Buffer" '(#\CR COM-END-OF-MINI-BUFFER
							 #\M-/; :UNDEFINED)))
  (SET-COMTAB-INDIRECTION *MINI-BUFFER-COMTAB* *MINI-BUFFER-MULTI-LINE-COMTAB*)
  (SETQ *PATHNAME-READING-COMTAB*
	(SET-COMTAB "Pathname Reading"
		    '(#\COMPLETE COM-PATHNAME-COMPLETE
		      #\ALTMODE COM-PATHNAME-COMPLETE
;		      #\c-? COM-PATHNAME-LIST-COMPLETIONS
		      #\c-Q COM-QUOTED-INSERT
		      #\END COM-PATHNAME-COMPLETE-AND-EXIT-IF-UNIQUE
		      #\HELP COM-DOCUMENT-PATHNAME-READ)))
  (SET-COMTAB-INDIRECTION *PATHNAME-READING-COMTAB* *MINI-BUFFER-COMTAB*)
  (SETQ *FQUERY-MINI-BUFFER-COMTAB*
	(SET-COMTAB "Fquery" '(#\HELP COM-FQUERY-MINI-BUFFER-DOCUMENT)))
  (SET-COMTAB-INDIRECTION *FQUERY-MINI-BUFFER-COMTAB* *MINI-BUFFER-COMTAB*))


;;; Compact all of the various Zwei command tables into fewer pages

(DEFCONST ZWEI-COMMAND-AREA (MAKE-AREA :NAME 'ZWEI-COMMAND-AREA
				       :GC :STATIC
				       :REGION-SIZE 25000.
				       :SWAP-RECOMMENDATIONS 1))

;;; COMTABs and command ALISTs that should be compressed at full GC time --
;;;    Zmail adds its own COMTABs and ALISTs when it is loaded.
(DEFVAR *ZWEI-COMTABS-FOR-COMPRESSION*
  '(*ZMACS-COMTAB*
    *STANDARD-COMTAB*))

(DEFVAR *ZWEI-COMMAND-ALISTS-FOR-COMPRESSION*
  '(*COMMAND-ALIST*))

(DEFVAR *COMTAB-ARRAY-TO-ALIST-THRESHOLD* 40.)

;;; If there aren't too many entries in the keyboard array, turn it into an alist.
(DEFUN MAYBE-MAKE-SPARSE-COMTAB (COMTAB)
  (WHEN (ARRAYP (COMTAB-KEYBOARD-ARRAY COMTAB))
    (FLET ((COUNT-ENTRIES (ARRAY)
	     (LET ((FILLED-ENTRIES 0))
	       (DOTIMES (I (CL:ARRAY-DIMENSION ARRAY 0))
		 (DOTIMES (J (CL:ARRAY-DIMENSION ARRAY 1))
		   (WHEN (AREF ARRAY I J)
		     (INCF FILLED-ENTRIES))))
	       FILLED-ENTRIES))
	   (CONVERT-TO-ALIST (ARRAY MOUSE-ARRAY-P)
	     (LET ((ENTRIES NIL))
	       (DOTIMES (CH (CL:ARRAY-DIMENSION ARRAY 0))
		 (DOTIMES (BITS (CL:ARRAY-DIMENSION ARRAY 1))
		   (WHEN (AREF ARRAY CH BITS)
		     (IF MOUSE-ARRAY-P
			 (PUSH (CONS (MAKE-MOUSE-CHAR CH BITS) (AREF ARRAY CH BITS)) ENTRIES)
			 (PUSH (CONS (CODE-CHAR CH BITS) (AREF ARRAY CH BITS)) ENTRIES)))))
	       ENTRIES)))
      (WHEN (< (+ (COUNT-ENTRIES (COMTAB-KEYBOARD-ARRAY COMTAB))
		  (COUNT-ENTRIES (COMTAB-MOUSE-ARRAY COMTAB)))
	       *COMTAB-ARRAY-TO-ALIST-THRESHOLD*)
	(SETF (COMTAB-KEYBOARD-ARRAY COMTAB) (COPYLIST (APPEND (CONVERT-TO-ALIST
								 (COMTAB-KEYBOARD-ARRAY COMTAB)
								 NIL)
							       (CONVERT-TO-ALIST
								 (COMTAB-MOUSE-ARRAY COMTAB)
								 T))))
	(SETF (COMTAB-MOUSE-ARRAY COMTAB) NIL)))))

(SI:DEFINE-GC-OPTIMIZATION COMPRESS-ZWEI-COMMAND-TABLES :LAYERED-SYSTEM-RELEASE
  (:DOCUMENTATION "Compress and localize editor command tables")
  (:BEFORE-FLIP (INCREMENTAL-P)
   (UNLESS INCREMENTAL-P
     (SI:USING-SYSTEM-TEMPORARY-AREA
       (LET ((NAME-HASH-TABLE (SCL:MAKE-HASH-TABLE :TEST 'CL:EQUAL :SIZE 1500.
						  :AREA SI:SYSTEM-TEMPORARY-AREA))
	    (CONS-HASH-TABLE (SCL:MAKE-HASH-TABLE :TEST 'CL:EQUAL :SIZE 1500.
						  :AREA SI:SYSTEM-TEMPORARY-AREA)))
	;; Initialize the hash-tables which we'll use to drive data-sharing
	(CL:CLRHASH NAME-HASH-TABLE)
	(CL:CLRHASH CONS-HASH-TABLE)
	(LABELS ((INTERN-THING (THING TABLE COPIER &OPTIONAL (AREA ZWEI-COMMAND-AREA))
		   (DECLARE (SYS:DOWNWARD-FUNARG COPIER))
		   ;; Intern a thing into a table, using COPIER to copy it
		   (MULTIPLE-VALUE-BIND (INTERNED-THING FOUND)
		       (CL:GETHASH THING TABLE)
		     (LET* ((INTERNED-OK
			      (AND FOUND
				   ;; It's no good if it's in the wrong place
				   (= (SYS:%AREA-NUMBER INTERNED-THING) AREA)))
			    (NEW-THING (IF INTERNED-OK 
					   INTERNED-THING
					 ;; Copy it into the correct place, if need be
					 (IF (= (SYS:%AREA-NUMBER THING) AREA)
					     THING
					   (FUNCALL COPIER THING AREA)))))
		       (WHEN (NOT INTERNED-OK)
			 ;; If this thing isn't interned, or the interned thing is
			 ;; in the wrong place, then intern it
			 (SETF (CL:GETHASH NEW-THING TABLE) NEW-THING))
		       NEW-THING)))
		 (INTERN-COMMAND-NAME (NAME)
		   (INTERN-THING NAME NAME-HASH-TABLE
				 #'(LAMBDA (NAME AREA)
				     (SUBSTRING NAME 0 NIL AREA))))
		 (INTERN-AARRAY-ITEM (ITEM)
		   (INTERN-THING ITEM CONS-HASH-TABLE
				 #'(LAMBDA (ITEM AREA)
				     (DESTRUCTURING-BIND (NAME . COMMAND) ITEM
				       (CONS-IN-AREA (INTERN-COMMAND-NAME NAME) COMMAND
						     AREA))))))
	  ;; First, localize all of the command alists (and set up the hash-tables, too)
	  (LABELS ((LOCALIZE-ALIST-INTERNAL (ALIST)
		     ;; Make sure the top level of the list is not scattered all over memory
		     (SETQ ALIST (SYS:LOCALIZE-LIST ALIST PERMANENT-STORAGE-AREA)) 
		     ;; Make sure the conses and the strings are in the right area
		     (LOOP FOR L ON ALIST
			   DOING (SETF (CAR L) (INTERN-AARRAY-ITEM (CAR L))))
		     ALIST)
		   (LOCALIZE-ALIST (ALIST)
		     (SET ALIST (LOCALIZE-ALIST-INTERNAL
				  ;; This might help a little since we might be
				  ;; using sorted completion aarrays
				  (SORTCAR (SYMEVAL ALIST) #'STRING-LESSP)))))
	      (DOLIST (ALIST *ZWEI-COMMAND-ALISTS-FOR-COMPRESSION*)
		(LOCALIZE-ALIST ALIST)))
	  ;; Compress the extended-command aarrays, sharing data with the alists
	  (FLET ((COMPRESS-COMTAB (COMTAB)
		   (CL:ETYPECASE (COMTAB-EXTENDED-COMMANDS COMTAB)
		     (CL:NULL )
		     (CL:ARRAY
		       (LET ((AARRAY (COMTAB-EXTENDED-COMMANDS COMTAB)))
			 (SI:SORT-AARRAY AARRAY)
			 (LOOP FOR I BELOW (FILL-POINTER AARRAY)
			       DOING (SETF (AREF AARRAY I)
					   (INTERN-AARRAY-ITEM (AREF AARRAY I))))))
		     (CL:LIST
		       (LOOP FOR L = (COMTAB-EXTENDED-COMMANDS COMTAB) THEN (CDR L)
			     UNTIL (ATOM L)	;Watch out for indirection locative at end
			     DOING (SETF (CAR L)
					 (INTERN-AARRAY-ITEM (CAR L))))))))
	    (DOLIST (COMTAB *ZWEI-COMTABS-FOR-COMPRESSION*)
	      (COMPRESS-COMTAB (SYMEVAL COMTAB))))
	  ;; Go through all the known commands and make their COMMAND-NAME property
	  ;; share with the strings we created above
	  (FLET ((SHARE-COMMAND-NAMES (ALIST)
		   (LOOP FOR (NAME . COMMAND) IN ALIST
			 DOING (IGNORE NAME)
			       (SETF (GET COMMAND 'COMMAND-NAME)
				     (INTERN-COMMAND-NAME (GET COMMAND 'COMMAND-NAME))))))
	    (DOLIST (ALIST *ZWEI-COMMAND-ALISTS-FOR-COMPRESSION*)
	      (SHARE-COMMAND-NAMES (SYMEVAL ALIST))))))))
   (DOLIST (COMTAB *ALL-THE-COMTABS*)
     (WHEN (SI:REORDERABLE COMTAB)
       (MAYBE-MAKE-SPARSE-COMTAB COMTAB)))))

