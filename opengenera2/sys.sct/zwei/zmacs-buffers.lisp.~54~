;;; -*- Mode: LISP; Syntax: Zetalisp; Package: ZWEI; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Make a new buffer of flavor FLAVOR
(DEFUN MAKE-BUFFER (FLAVOR &REST OPTIONS)
  (LET* ((DEFAULT-CONS-AREA *ZMACS-BUFFER-AREA*)	;Buffer, boundary bp's, bp lists here
	 (*BP-AREA* *ZMACS-BUFFER-AREA*)	;These, too.
	 (BUFFER (LEXPR-FUNCALL #'MAKE-INSTANCE FLAVOR OPTIONS))
	 (MAJOR-MODE (SEND BUFFER ':MAJOR-MODE)))
    (WHEN MAJOR-MODE
      (SEND MAJOR-MODE ':BUFFER-CREATED BUFFER))
    BUFFER))

(DEFMETHOD (:BUFFER-CREATED MAJOR-MODE :DEFAULT) (BUFFER) BUFFER)

(DEFMETHOD (:INIT BUFFER :BEFORE) (IGNORE)
  (LET ((LINE (CREATE-LINE 'ART-STRING 0 SELF)))
    (SETQ FIRST-BP (CREATE-BP LINE 0 ':NORMAL SELF))
    (SETQ LAST-BP (CREATE-BP LINE 0 ':MOVES SELF))
    (SETQ SAVED-POINT (CREATE-BP LINE 0 ':NORMAL SELF))
    (SETQ SAVED-MARK (CREATE-BP LINE 0 ':NORMAL SELF))
    (SETQ SAVED-WINDOW-START-BP (CREATE-BP LINE 0 ':NORMAL SELF))))

(DEFMETHOD (:INIT BUFFER :AFTER) (PLIST)
  (AND (GET PLIST ':ACTIVATE-P)
       (SEND SELF ':ACTIVATE)))

(DEFMETHOD (:ACTIVATE BUFFER) ()
  (LET ((DEFAULT-CONS-AREA *ZMACS-BUFFER-AREA*))
    (WITHOUT-INTERRUPTS
      (UNLESS (MEMQ SELF *ZMACS-BUFFER-LIST*)
	(PUSH SELF *ZMACS-BUFFER-LIST*)
	(ADD-TO-BUFFER-NAME-TABLE SELF)
	(LET ((KEY (ZMACS-BUFFER-ALIST-KEY SELF)))
	  (WHEN KEY
	    (LET ((ELEM (ASSQ KEY *ZMACS-BUFFER-ALIST*)))
	      (IF ELEM
		  (CL:PUSHNEW SELF (CDR ELEM) :LOCALIZE T)
		  (CL:PUSH (CONS KEY (LIST SELF)) *ZMACS-BUFFER-ALIST* :LOCALIZE 2)))))
	(LET ((INHIBIT-SCHEDULING-FLAG NIL))
	  (SETQ FLAVOR:PROPERTY-LIST (COPYLIST FLAVOR:PROPERTY-LIST)))))))

(DEFUN GENERATE-BUFFER-NAME ()
  (LOOP AS COUNTER = (WITHOUT-INTERRUPTS (INCF *ZMACS-BUFFER-COUNTER*))
	DO (LET ((NAME (LET ((DEFAULT-CONS-AREA *ZMACS-BUFFER-AREA*))
			 (FORMAT NIL "*Buffer-~D*" COUNTER))))
	     (UNLESS (GETHASH NAME *ZMACS-BUFFER-NAME-TABLE*)
	       (RETURN NAME)))))

(DEFMETHOD (:INIT FILE-BUFFER :BEFORE) (IGNORE)
  (SETQ PATHNAME (SEND PATHNAME ':TRANSLATED-PATHNAME)
	NAME (SEND PATHNAME ':STRING-FOR-EDITOR)))

;; This is the default method.  NIL means no entry in *ZMACS-BUFFER-ALIST*,
;; otherwise this is the key.
(DEFMETHOD (ZMACS-BUFFER-ALIST-KEY BUFFER) ()
  (SEND SELF :SPECIAL-PURPOSE-P))

;;; This should be called in a CONDITION-BIND handler, when a package specified 
;;; in a file's attribute list does not exist.  Query the user.

(DEFUN PACKAGE-HANDLER (ERROR SYNTAX BUFFER)
  (LET ((MAJOR-MODE (OR (SEND BUFFER :MAJOR-MODE)
			(MAJOR-MODE-FROM-KEYWORD *DEFAULT-MAJOR-MODE*)))
	(NAME (STRING (SEND ERROR ':NAME))))
    (WHEN (AND SYNTAX (SYMBOLP SYNTAX))
      (SETQ SYNTAX (SI:LISP-SYNTAX-FROM-KEYWORD :ZETALISP)))
    (UNLESS SYNTAX (SETQ SYNTAX (SI:LISP-SYNTAX-FROM-KEYWORD :ZETALISP)))
    ;; hang the syntax off the buffer now so that
    ;; MAJOR-MODE-DEFAULT-PACKAGE-USE-LIST-FOR-BUFFER can find it there.
    (SEND BUFFER :PUTPROP (SI:LISP-SYNTAX-NAME-SYMBOL SYNTAX) ':SYNTAX)
    (SELECTQ
      (FQUERY '(:BEEP T
		:CLEAR-INPUT T
		:CHOICES (((:CREATE "Create it")
			   #/C)
			  ((:TRY-AGAIN "Try again")
			   #/T)
			  ((:USE-ANOTHER "Use some other package")
			   #/U)))
	      "The file's attribute list refers to package ~A, which does not exist.~@
	Create it with :USE ~{~S~^, ~}, Try again, or Use another package? "
	      NAME
	      (MAJOR-MODE-DEFAULT-PACKAGE-USE-LIST-FOR-BUFFER MAJOR-MODE BUFFER))
      (:CREATE
       (SYS:PROCEED
	 ERROR
	 ':CREATE-PACKAGE
	 :USE-LIST (MAJOR-MODE-DEFAULT-PACKAGE-USE-LIST-FOR-BUFFER
		     MAJOR-MODE BUFFER)))
      (:TRY-AGAIN
       (SEND ERROR ':PROCEED ':NO-ACTION))
      (:USE-ANOTHER
       (LET ((NEW-PACKAGE
	       (SCL:ACCEPT
		 'CL:PACKAGE
		 :DEFAULT (OR (PKG-FIND-PACKAGE
				(OR (MAJOR-MODE-DEFAULT-PACKAGE MAJOR-MODE)
				    (IF (BOUNDP '*DEFAULT-PACKAGE*)
					(SYMEVAL '*DEFAULT-PACKAGE*)
				      (GET '*DEFAULT-PACKAGE* 'VARIABLE-INIT)))
				:FIND
				(CAR		;the first is the most global 
						;package, so it should work for
						;relative-to, no?
				  (MAJOR-MODE-DEFAULT-PACKAGE-USE-LIST-FOR-BUFFER
				    MAJOR-MODE BUFFER)))
			      CL:*PACKAGE*))))
	 ;; supplying a real package instead of a name allows us to
	 ;; use major-mode flavorization to pick the default.
	 ;; It is a better user interface to accept a package than to
	 ;; accept a name and then blow up again is the name is not that
	 ;; of an existing package.
	 ;; This does not support the idea of:
	 ;; -- buffer calls for A, nonexistent
	 ;; -- user uses :USE-ANOTHER to create a nonexistent package B
	 ;; -- and use that instead.  That is lunatic.
	 (SYS:PROCEED ERROR ':NEW-NAME NEW-PACKAGE)	;a package is a legitimate
						;package name.
	 ))
      ))) 

(DEFMETHOD (MAKE-INSTANCE FILE-BUFFER-MIXIN :AFTER) (&REST IGNORE)
  (WHEN PATHNAME (FILE-BUFFER-GET-ATTRIBUTES-FROM-PATHNAME SELF)))

(DEFMETHOD (FILE-BUFFER-GET-ATTRIBUTES-FROM-PATHNAME FILE-BUFFER-MIXIN) ()
  (LET ((INITIAL-MODE (MAJOR-MODE-KEYWORD-FROM-PATHNAME PATHNAME))
	(GENERIC-PATHNAME (SEND PATHNAME ':GENERIC-PATHNAME)))
    (SEND GENERIC-PATHNAME ':PUTPROP INITIAL-MODE ':MODE)
    (SEND SELF ':PUTPROP (GET-MAJOR-MODE-ATTRIBUTE-FOR-BUFFER INITIAL-MODE) ':MAJOR-MODE)
    (LET* ((SYNTAX (SI:LISP-SYNTAX-FROM-KEYWORD
		     (OR (SEND GENERIC-PATHNAME :GET ':SYNTAX)
			 :ZETALISP)))
	   (PKG
	     (CONDITION-BIND ((SYS:PACKAGE-NOT-FOUND
				#'(LAMBDA (ERROR)
				    (PACKAGE-HANDLER ERROR SYNTAX SELF)))
			      (SI:LISP-SYNTAX-NOT-FOUND
				#'SI:QUERY-HANDLE-SYNTAX-NOT-FOUND))
	       (FS:FIND-PACKAGE-FOR-SYNTAX (OR (SEND GENERIC-PATHNAME ':GET ':PACKAGE)
					       (MAJOR-MODE-DEFAULT-PACKAGE
						 (SEND SELF :MAJOR-MODE))
					       (IF (BOUNDP '*DEFAULT-PACKAGE*)
						   (SYMEVAL '*DEFAULT-PACKAGE*)
						 (GET '*DEFAULT-PACKAGE* 'VARIABLE-INIT))
					       PACKAGE) 
					   (AND SYNTAX (SI:LISP-SYNTAX-NAME-SYMBOL SYNTAX))))))
      (SEND GENERIC-PATHNAME ':PUTPROP (INTERN (PKG-NAME PKG) SI:PKG-KEYWORD-PACKAGE)
	    ':PACKAGE)
      (SEND SELF ':PUTPROP PKG ':PACKAGE))))


(DEFMETHOD (:INIT NON-FILE-BUFFER :BEFORE) (PLIST)
  (LET ((MAJOR-MODE (GET-MAJOR-MODE-ATTRIBUTE-FOR-BUFFER
		      (OR (GET PLIST ':MAJOR-MODE) *DEFAULT-MAJOR-MODE*))))
    (SEND SELF ':PUTPROP MAJOR-MODE ':MAJOR-MODE)
    (SEND SELF ':PUTPROP (OR (GET PLIST ':PACKAGE)
			     (MAJOR-MODE-DEFAULT-PACKAGE MAJOR-MODE)
			     (IF (BOUNDP '*DEFAULT-PACKAGE*)
				 (SYMEVAL '*DEFAULT-PACKAGE*)
			       (GET '*DEFAULT-PACKAGE* 'VARIABLE-INIT))
			     PACKAGE)
	  ':PACKAGE)))

;;; Perhaps should re-arrange mixins so that these two aren't the same.
(DEFMETHOD (:INIT SPECIAL-PURPOSE-BUFFER :BEFORE) (PLIST)
  (LET ((MAJOR-MODE (GET-MAJOR-MODE-ATTRIBUTE-FOR-BUFFER
			 (OR (GET PLIST ':MAJOR-MODE) *DEFAULT-MAJOR-MODE*))))
    (SEND SELF ':PUTPROP MAJOR-MODE ':MAJOR-MODE)
    (SEND SELF ':PUTPROP (OR (GET PLIST ':PACKAGE)
			     (MAJOR-MODE-DEFAULT-PACKAGE MAJOR-MODE)
			     (IF (BOUNDP '*DEFAULT-PACKAGE*)
				 (SYMEVAL '*DEFAULT-PACKAGE*)
			       (GET '*DEFAULT-PACKAGE* 'VARIABLE-INIT))
			     PACKAGE)
	  ':PACKAGE)))

(DEFMETHOD (:SET-NAME BUFFER :BEFORE) (NEW-NAME)
  (WHEN (EQ (GETHASH NAME *ZMACS-BUFFER-NAME-TABLE*) SELF)
    (REMHASH NAME *ZMACS-BUFFER-NAME-TABLE*)
    ;; If it wasn't in the table under the old name, don't put it in under the new name
    ;; because the buffer can be assumed not to have been activated yet
    (SETF (GETHASH NEW-NAME *ZMACS-BUFFER-NAME-TABLE*) SELF)))

(DEFMETHOD (:SET-NAME BUFFER :AFTER) (IGNORE)
  (DOLIST (WINDOW *WINDOW-LIST*)
    (AND (EQ (WINDOW-INTERVAL WINDOW) SELF)
	 (CHANGE-WINDOW-LABEL WINDOW))))

;; A crock for the sake of :ITEM typeout menu hackery.
(DEFMETHOD (:STRING-FOR-PRINTING BUFFER) ()
  (SEND SELF ':NAME))

(DEFMETHOD (:SET-PATHNAME FILE-BUFFER-MIXIN) (NEW-PATHNAME)
  (WHEN (VARIABLE-BOUNDP PATHNAME)
    (WHEN (EQ (GETHASH PATHNAME *ZMACS-BUFFER-NAME-TABLE*) SELF)
      (REMHASH PATHNAME *ZMACS-BUFFER-NAME-TABLE*)))
  (COND ((NULL NEW-PATHNAME)
	 (SETF PATHNAME NIL)
	 (SEND SELF :SET-NAME NIL))
	(T
	 (SETQ PATHNAME (SEND NEW-PATHNAME ':TRANSLATED-PATHNAME))
	 (SEND SELF ':SET-NAME (SEND PATHNAME ':STRING-FOR-EDITOR))
	 (WHEN (ZMACS-BUFFER-P SELF)
	   (SETF (GETHASH PATHNAME *ZMACS-BUFFER-NAME-TABLE*) SELF))))
  (SETQ FILE-INFO NIL VERSION-STRING NIL))

;;; For EMACS compatible commands that change the flavor
;;; :SET-PATHNAME-FOR-WRITE, :MAKE-NON-FILE
(DEFMETHOD (:MAKE-NON-FILE BUFFER) ()
  (TRANSFORM-BUFFER SELF 'NON-FILE-BUFFER :NAME NAME))

(DEFMETHOD (:SET-PATHNAME-FOR-WRITE BUFFER) (PATHNAME)
  (TRANSFORM-BUFFER SELF 'FILE-BUFFER :PATHNAME PATHNAME :READ-TICK TICK))

(DEFGENERIC TRANSFORM-BUFFER (BUFFER NEW-FLAVOR &REST OPTIONS
						&KEY NAME PATHNAME READ-TICK)
  (DECLARE (ARGLIST BUFFER NEW-FLAVOR &KEY NAME PATHNAME READ-TICK))
  (:METHOD-ARGLIST &KEY NAME PATHNAME READ-TICK)
  (:METHOD-COMBINATION :TWO-PASS)
  (:FUNCTION
    (IGNORE READ-TICK)
    ;; Check for name duplication.  This is an unmodular kludge, but we have to barf
    ;; before changing anything about the buffer, or the buffer will be destroyed.
    (LET* ((NEW-NAME (OR NAME (SEND (SEND PATHNAME :TRANSLATED-PATHNAME) :STRING-FOR-EDITOR)))
	   (OTHER-BUFFER (GETHASH NEW-NAME *ZMACS-BUFFER-NAME-TABLE*)))
      (WHEN (AND OTHER-BUFFER (NEQ OTHER-BUFFER BUFFER))
	(BARF "There is already another buffer named ~A." NEW-NAME)))
    ;; Keeping the buffer instance EQ, change its flavor and reinitialize it
    (REMOVE-FROM-BUFFER-NAME-TABLE BUFFER)
    (CHANGE-INSTANCE-FLAVOR BUFFER NEW-FLAVOR)
    (LEXPR-FUNCALL (FLAVOR:GENERIC TRANSFORM-BUFFER) BUFFER OPTIONS)
    (ADD-TO-BUFFER-NAME-TABLE BUFFER)
    BUFFER))

(DEFMETHOD (TRANSFORM-BUFFER NON-FILE-BUFFER) (&KEY ((:NAME NEW-NAME)) &ALLOW-OTHER-KEYS)
  (SEND SELF :SET-NAME NEW-NAME))

(DEFMETHOD (TRANSFORM-BUFFER FILE-BUFFER) (&KEY ((:PATHNAME NEW-PATHNAME))
						((:READ-TICK NEW-READ-TICK))
					   &ALLOW-OTHER-KEYS)
  (SETQ READ-TICK NEW-READ-TICK
	PATHNAME (SEND NEW-PATHNAME :TRANSLATED-PATHNAME))
  (SEND SELF :SET-NAME (SEND PATHNAME :STRING-FOR-EDITOR)))

(DEFMETHOD (TRANSFORM-BUFFER FILE-BUFFER-MIXIN :AFTER) (&REST IGNORE)
  (SEND SELF :SET-FILE-INFO NIL)
  (SET-PATHNAME-ATTRIBUTES-FROM-BUFFER (SEND PATHNAME :GENERIC-PATHNAME) SELF))

(DEFMETHOD (:POINT BUFFER) ()
  (COND ((AND (VARIABLE-BOUNDP *WINDOW*)
	      (TYPEP *WINDOW* 'WINDOW)
	      (EQ SELF (WINDOW-INTERVAL *WINDOW*)))
	 (POINT))
	((AND (VARIABLE-BOUNDP *WINDOW-LIST*)
	      (LISTP *WINDOW-LIST*)
	      (LOOP FOR WINDOW IN *WINDOW-LIST*
		    WHEN (EQ (WINDOW-INTERVAL WINDOW) SELF)
		    RETURN (VALUES (WINDOW-POINT WINDOW) T))))
	(T SAVED-POINT)))

;;; This updates the who line variables.
(DEFMETHOD (:MAKE-CURRENT BUFFER) ()
  (SETQ *INTERVAL* SELF))

(DEFMETHOD (:MAKE-CURRENT BUFFER :AFTER) ()
  (SET-EVALUATION-CONTEXT SELF))

(DEFMETHOD (:VERSION-STRING BUFFER) () NIL)

(DEFMETHOD (:REVERT BUFFER) ()
  (BARF "This buffer is not associated with a file."))

;;; Insertions into a buffer (normal or support) while reverting it are never undoable.
(DEFWRAPPER (:REVERT BUFFER) (() . BODY)
  `(LET ((*ENABLE-CHANGE-RECORDING* NIL))
     (DISCARD-CHANGE-HISTORY SELF)
     . ,BODY))

(DEFUN SET-MAJOR-MODE (MODE)
  (TURN-OFF-MODE (SEND *INTERVAL* :MAJOR-MODE))
  (DOLIST (MODE *UNSTICKY-MINOR-MODES*)
    (TURN-OFF-MODE MODE))
  (TURN-ON-MODE MODE))

(DEFUN CURRENT-NAMED-BUFFER ()
  (AND (VARIABLE-BOUNDP *INTERVAL*) *INTERVAL*
       (INTERVAL-BUFFER *INTERVAL*)))

(DEFUN CURRENT-ZMACS-BUFFER ()
  (LET ((C-N-B (CURRENT-NAMED-BUFFER)))
    (WHEN (AND C-N-B (ZMACS-BUFFER-P C-N-B))
      C-N-B)))

(DEFGENERIC MAP-BUFFER-NAMES (BUFFER FUNARG)	;Apply FUNARG to each name (string or pathname)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNARG)))

(DEFMETHOD (MAP-BUFFER-NAMES NAMED-BUFFER) (FUNARG)
  (FUNCALL FUNARG NAME))

;;; Files are registered under both names
;;; This is not a :AFTER method because VC needs to override it
(DEFMETHOD (MAP-BUFFER-NAMES FILE-BUFFER-MIXIN) (FUNARG)
  (FUNCALL FUNARG NAME)
  (WHEN PATHNAME
    (FUNCALL FUNARG PATHNAME)))

(DEFUN ADD-TO-BUFFER-NAME-TABLE (BUFFER)
  (MAP-BUFFER-NAMES BUFFER (LAMBDA (NAME)
			     (SETF (GETHASH NAME *ZMACS-BUFFER-NAME-TABLE*) BUFFER))))

(DEFUN REMOVE-FROM-BUFFER-NAME-TABLE (BUFFER)
  (MAP-BUFFER-NAMES BUFFER (LAMBDA (NAME)
			     (WHEN (EQ (GETHASH NAME *ZMACS-BUFFER-NAME-TABLE*) BUFFER)
			       (REMHASH NAME *ZMACS-BUFFER-NAME-TABLE*)))))

(DEFMETHOD (:EDITING-FILE-P BUFFER) () NIL)

(DEFMETHOD (:EDITING-FILE-P FILE-BUFFER-MIXIN) ()
  (IF (ATOM FILE-INFO) ':NEW-FILE T))		;ATOM is NIL or :NEVER-READ

;;; Search for a buffer with the given name.  Return the buffer, or NIL if not found.
;;; If CREATE-P is specified, the buffer will be created if it does not already exist.
(DEFUN FIND-BUFFER-NAMED (NAME &OPTIONAL CREATE-P CREATE-OPTIONS)
  (IF (TYPEP NAME 'BUFFER)
      NAME
    (WHEN (TYPEP NAME 'FS:LOGICAL-PATHNAME)
      (SETQ NAME (SEND NAME ':TRANSLATED-PATHNAME)))
    (OR (GETHASH NAME *ZMACS-BUFFER-NAME-TABLE*)
	(AND CREATE-P
	     (CL:APPLY #'MAKE-BUFFER 'NON-FILE-BUFFER ':NAME (STRING NAME) CREATE-OPTIONS)))))

(DEFUN FIND-BUFFER-FROM-PATHNAME (PATHNAME)
  (FIND-BUFFER-NAMED (FS:MERGE-PATHNAMES PATHNAME *PATHNAME-DEFAULTS*)))

;;; This prevents you from being permanently shafted if you somehow select the
;;; mini-buffer as the current buffer.  The (ED) function sends this message.
(DEFMETHOD (:MINI-BUFFER-ACCIDENTALLY-SELECTED-KLUDGE ZMACS-TOP-LEVEL-EDITOR) ()
  (OR (TYPEP *INTERVAL* 'BUFFER)
      (SEND SELF ':SET-INTERVAL (MAKE-BUFFER 'NON-FILE-BUFFER ':NAME
					     "MINI-BUFFER-ACCIDENTALLY-SELECTED-KLUDGE"))))

;;; Make BUFFER be the currently selected buffer.
(DEFMETHOD (:SET-INTERVAL ZMACS-EDITOR) (INTERVAL)
  (IF (TYPEP INTERVAL 'BUFFER)
      (MAKE-BUFFER-CURRENT INTERVAL)
      (SETQ *INTERVAL* INTERVAL)))

;(TV:ADD-TYPEOUT-ITEM-TYPE *TYPEOUT-COMMAND-ALIST* ZMACS-BUFFER "Select"
;			  TYPEOUT-MAKE-BUFFER-CURRENT T "Select this buffer.")

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR MAKE-BUFFER-CURRENT
						  (BUFFER "Select buffer" *ZMACS-COMTAB*
							  :GESTURE :SELECT)
						  (BUFFER)
  `(TYPEOUT-MAKE-BUFFER-CURRENT ,BUFFER))

(DEFVAR *READ-BUFFER-KLUDGE* NIL)

(DEFUN TYPEOUT-MAKE-BUFFER-CURRENT (BUFFER)
  (COND ((NOT (MEMQ BUFFER *ZMACS-BUFFER-LIST*))
	 (BARF "That buffer has been killed, you may not select it."))
	((NEQ *INTERVAL* (WINDOW-INTERVAL *MINI-BUFFER-WINDOW*))
	 (MAKE-BUFFER-CURRENT BUFFER))
	(*READ-BUFFER-KLUDGE*
	 (THROW '*READ-BUFFER-KLUDGE* BUFFER))
	(T
	 (SEND STANDARD-INPUT ':UNTYI *LAST-COMMAND-CHAR*)
	 (THROW 'TOP-LEVEL NIL))))

(DEFUN MAKE-BUFFER-CURRENT (BUFFER)
  (CHECK-ARG-TYPE BUFFER BUFFER)
  ;; What we really want here is to insure that *interval* is not bound.
  (WHEN (EQ *WINDOW* *MINI-BUFFER-WINDOW*)
    (DEBUGGING-BARF "Mini-Buffer selected at MAKE-BUFFER-CURRENT time. Please report this ZMACS bug."))
  (LET ((OLD-BUFFER *INTERVAL*))
    (UNLESS (TYPEP OLD-BUFFER 'BUFFER)
      (DEBUGGING-BARF "Previous buffer is not a buffer at MAKE-BUFFER-CURRENT time. Please report this ZMACS bug."))
    ;; Save away the major and minor modes, and turn them off.
    (SETF (BUFFER-SAVED-MODE-LIST OLD-BUFFER) *MODE-LIST*)
    (UN-SET-MODES)
    ;;give the buffer a chance to clean itself up.
    (BUFFER-NO-LONGER-CURRENT OLD-BUFFER)
    (LET ((DEFAULT-CONS-AREA *ZMACS-BUFFER-AREA*))
      ;; Update *ZMACS-BUFFER-HISTORY*, for C-X C-B
      (UPDATE-BUFFER-HISTORY OLD-BUFFER BUFFER)
      ;; Update the per-window history, for independent window defaults for c-X B, c-m-L
      (UPDATE-WINDOW-BUFFER-HISTORY *WINDOW* BUFFER)))
  ;; Point the window at this interval, and make it the default interval.
  (SEND *CURRENT-COMMAND-LOOP* ':SET-WINDOW-INTERVAL *WINDOW* BUFFER)
  (SEND BUFFER ':MAKE-CURRENT)
  (SEND (WINDOW-FRAME *WINDOW*) :UPDATE-LABELS)	;make sure these are accurate.
  ;; Restore the old major and minor modes.
  (SET-MODES (BUFFER-SAVED-MODE-LIST *INTERVAL*) (SEND BUFFER ':GET ':MAJOR-MODE))
  NIL)

;;; This updates *ZMACS-BUFFER-HISTORY*, which is not the thing used when you type
;;; "c-X B RETURN" to go to the previous buffer.  It used to be but that is now handled
;;; by update-window-buffer-history, which keeps that info in a field of the zmacs WINDOW
;;; structure, to allow per-window defaulting for previous buffer.  Many other things, like
;;; List Buffers wanted to have a global list, so it continues to be maintained.
;;; It is a bit better
;;; then the one in EMACS, in that if you kill buffers, it will remember
;;; two buffers ago, etc.  It is called by MAKE-BUFFER-CURRENT.
(DEFUN UPDATE-BUFFER-HISTORY (OLD-BUFFER NEW-BUFFER)
  (LET ((ZMACS-BUFFER-HISTORY *ZMACS-BUFFER-HISTORY*))
    (AND (NEQ OLD-BUFFER NEW-BUFFER) (NEQ NEW-BUFFER (CAR ZMACS-BUFFER-HISTORY))
	 (WITHOUT-INTERRUPTS
	   (SETQ *ZMACS-BUFFER-HISTORY* (FS:PULL NEW-BUFFER ZMACS-BUFFER-HISTORY))))))

;;; Each zmacs window has a history of the buffers that have been displayed in it, called
;;; zmacs-window-buffer-history, which is just like *zmacs-buffer-history* but keeps the
;;; list for each physical window rather than globally.  Called by MAKE-BUFFER-CURRENT.
(DEFUN UPDATE-WINDOW-BUFFER-HISTORY (WINDOW NEW-BUFFER)
  (LET ((HLIST (WINDOW-BUFFER-HISTORY WINDOW)))
    (UNLESS (EQ NEW-BUFFER (CAR HLIST))		;if new-buffer not at top now
      (ALTER-WINDOW WINDOW BUFFER-HISTORY
		    (FS:PULL NEW-BUFFER HLIST)))))

;;;this is for com-select-previous-buffer and friends; make them act on a per-window
;;;basis instead of globally with *zmacs-buffer-history*
(DEFUN ROTATE-BUFFER-HISTORY (N)
  (LET ((HLIST (WINDOW-BUFFER-HISTORY *WINDOW*)))
    (WHEN (> N (LENGTH HLIST)) (BARF))
    (SETQ HLIST (ROTATE-TOP-OF-LIST HLIST N))
    (ALTER-WINDOW *WINDOW* BUFFER-HISTORY HLIST) ;should be a no-op
    (MAKE-BUFFER-CURRENT (CAR HLIST)))
  DIS-TEXT)

;;; Associate BUFFER with WINDOW.
(DEFMETHOD (:SET-WINDOW-INTERVAL ZMACS-EDITOR) (WINDOW INTERVAL)
  (IF (TYPEP INTERVAL 'BUFFER)
      (SET-WINDOW-BUFFER WINDOW INTERVAL)
      (SET-WINDOW-INTERVAL WINDOW INTERVAL)))

(DEFUN SET-WINDOW-BUFFER (WINDOW BUFFER)
  (UNLESS (EQ (WINDOW-INTERVAL WINDOW) BUFFER)
    (IF (NULL (WINDOW-INTERVAL WINDOW))
	(SET-WINDOW-INTERVAL WINDOW BUFFER)
      (MOVE-BP (BUFFER-SAVED-POINT (WINDOW-INTERVAL WINDOW)) (WINDOW-POINT WINDOW))
      (MOVE-BP (BUFFER-SAVED-MARK (WINDOW-INTERVAL WINDOW)) (WINDOW-MARK WINDOW))
      (MOVE-BP (BUFFER-SAVED-WINDOW-START-BP (WINDOW-INTERVAL WINDOW))
	       (WINDOW-START-BP WINDOW))
      (SETF (WINDOW-INTERVAL WINDOW) BUFFER)
      (MOVE-BP-TO-BP-AND-BUFFER (WINDOW-POINT WINDOW) (BUFFER-SAVED-POINT BUFFER))
      (MOVE-BP-TO-BP-AND-BUFFER (WINDOW-MARK WINDOW) (BUFFER-SAVED-MARK BUFFER))
      (MOVE-BP-TO-BP-AND-BUFFER (WINDOW-START-BP WINDOW)
				(BUFFER-SAVED-WINDOW-START-BP BUFFER)))
    (SEND (WINDOW-SHEET WINDOW) :SET-DEFAULT-CHARACTER-STYLE
	  ;; Set the default style to any user set attribute of the buffer
	  (OR (SEND BUFFER :GET :DEFAULT-CHARACTER-STYLE)
	      ;; otherwise use the major-mode default-character-style.
	      (SEND (SEND BUFFER :GET :MAJOR-MODE) :DEFAULT-CHARACTER-STYLE))))
  (REDEFINE-WINDOW-BACKSPACE-FLAG WINDOW (SEND BUFFER ':GET ':BACKSPACE))
  (REDEFINE-WINDOW-TAB-NCHARS WINDOW (OR (SEND BUFFER ':GET ':TAB-WIDTH)
					 8))
  (SET-WINDOW-VSP WINDOW (OR (SEND BUFFER ':GET ':VSP) 2))
  (MUST-REDISPLAY WINDOW DIS-TEXT)
  (CHANGE-WINDOW-LABEL WINDOW)
  (WHEN (EQ WINDOW *WINDOW*)
    (SETQ *STYLE* (IF (BUFFER-TYPEIN-CHARACTER-STYLE BUFFER) (SI:STYLE-INDEX (BUFFER-TYPEIN-CHARACTER-STYLE BUFFER) T) 0))
    (UPDATE-STYLE-NAME)))

;; Valid second values from this message are:
;;  :READ-ONLY   Read-only buffer; takes precendence over the rest.
;;  :NO-FILE     Non-file buffer with stuff in it.
;;  :EMPTY       Non-file buffer without anything in it.
;;  :NEW-FILE    File buffer but never read or written.
;;  :SPECIAL     Special-purpose buffer.

(DEFMETHOD (:MODIFIED-P BUFFER) (&OPTIONAL TYPE)
  (COND ((EQ TICK ':READ-ONLY)
	 (VALUES NIL ':READ-ONLY))
	((EQ TYPE ':EXPLICIT-SAVING)
	 T)
	(T
	 (VALUES NIL (IF (BP-= FIRST-BP LAST-BP) ':EMPTY ':NO-FILE)))))

(DEFMETHOD (:MODIFIED-P FILE-BUFFER-MIXIN) (&OPTIONAL (TYPE ':FOR-SAVING))
  (COND ((EQ TICK ':READ-ONLY)
	 (VALUES NIL ':READ-ONLY))
	((ATOM (send self :file-info))			;ATOM is NIL or :NEVER-READ
	 (VALUES (OR (NEQ TYPE ':FOR-KILLING)
		     (NOT (BP-= FIRST-BP LAST-BP)))
		 ':NEW-FILE))
	((> TICK SAVE-TICK)
	 T)
	(T
	 NIL)))

(DEFMETHOD (:DEFAULT-PATHNAME FILE-BUFFER-MIXIN) () PATHNAME)

(DEFUN MAKE-FILE-BUFFER-STREAM (PATHNAME &OPTIONAL (CONCATENATE-P T)
					 &AUX BUFFER ISTREAM)
  (SETQ PATHNAME (FS:MERGE-PATHNAMES PATHNAME *PATHNAME-DEFAULTS*))
  (COND ((SETQ BUFFER (FIND-BUFFER-NAMED PATHNAME))
	 (OR CONCATENATE-P (DELETE-INTERVAL BUFFER)))
	(T
	 (SETQ BUFFER (MAKE-BUFFER 'FILE-BUFFER ':PATHNAME PATHNAME))
	 ;;if we don't want to :REVERT, at least we have to do this
	 (SEND BUFFER :SET-TICKS-FOR-FILE-BUFFER-STREAM (TICK))))
  (SETQ ISTREAM (OPEN-INTERVAL-STREAM BUFFER))
  (SEND ISTREAM ':SET-BP (IF (EQ CONCATENATE-P ':POINT) (BUFFER-SAVED-POINT BUFFER)
			     (INTERVAL-LAST-BP BUFFER)))
  ISTREAM)


(DEFMETHOD (:READ-ONLY BUFFER) () (EQ TICK ':READ-ONLY))

(DEFMETHOD (:SET-READ-ONLY BUFFER) ()
  (DECLARE (VALUES OLD-TICK))
  (PROG1 TICK (SETQ TICK ':READ-ONLY)))

(DEFMETHOD (:SET-READ-WRITE BUFFER) (&OPTIONAL TICK-TO-RESTORE)
  (SETQ TICK (OR TICK-TO-RESTORE (TICK))))

(DEFCOM COM-SET-READ-ONLY "With a numeric argument, sets the current buffer to be read-only.
Without a numeric argument, toggles the state of the read-only flag" (KM)
  (UNLESS (OPERATION-HANDLED-P *INTERVAL* :SET-READ-ONLY)
    (BARF "Cannot change read-only status of ~A" *INTERVAL*))
  (LET ((CURRENT-READ-ONLY (SEND *INTERVAL* :READ-ONLY)))
    (COND (*NUMERIC-ARG-P*
	   (WHEN (NOT CURRENT-READ-ONLY)
	     (SEND *INTERVAL*
		   :PUTPROP (SEND *INTERVAL* :SET-READ-ONLY) :SAVED-READ-WRITE-TICK))
	   (TYPEIN-LINE "Buffer ~A set to Read-Only" (SEND *INTERVAL* :NAME)))
	  (T
	   (IF CURRENT-READ-ONLY
	       (SEND *INTERVAL* :SET-READ-WRITE
		     (SEND *INTERVAL* :GET :SAVED-READ-WRITE-TICK))
	     (SEND *INTERVAL*
		   :PUTPROP (SEND *INTERVAL* :SET-READ-ONLY) :SAVED-READ-WRITE-TICK))
	   (TYPEIN-LINE "Buffer ~A set to ~:[Read-Only~;Read//Write~]"
			(SEND *INTERVAL* :NAME) CURRENT-READ-ONLY))))
  DIS-NONE)

(DEFCOM COM-RELEASE-LOCKS
	"Release all of the node locks in the current buffer.
With a numeric argument, releases all of the node locks in all of the buffers." ()
  (COND (*NUMERIC-ARG-P*
	 (LOOP FOR BUFFER IN *ZMACS-BUFFER-LIST*
	       DO (FORCIBLY-UNLOCK-NODE-LOCKS-IN-BUFFER BUFFER))
	 (TYPEIN-LINE "All nodes in all buffers are now unlocked"))
	(T
	 (FORCIBLY-UNLOCK-NODE-LOCKS-IN-BUFFER *INTERVAL*)
	 (TYPEIN-LINE "All nodes in buffer ~A are now unlocked" (SEND *INTERVAL* :NAME))))
  DIS-NONE)

(DEFCOM COM-SELECT-BUFFER "Selects the specified buffer.
It reads the name of the buffer to select from the minibuffer, with
completion.  To create a new buffer, use the command with a numeric argument.  " ()
  (COND ((NULL *NUMERIC-ARG-P*)
	 (SELECT-BUFFER "Select buffer"))
	(T
	 (LET ((NAME (TYPEIN-LINE-HISTORY-READLINE *BUFFER-HISTORY* *INTERVAL* NIL
						   "Create buffer named:")))
	   (SETQ NAME (STRING-TRIM *BLANKS* NAME))
	   (WHEN (FIND-BUFFER-NAMED NAME)
	     (BARF "There is already another buffer named ~A" NAME))
	   (WHEN (EQUAL NAME "")
	     (SETQ NAME (GENERATE-BUFFER-NAME)))
	   (MAKE-BUFFER-CURRENT (MAKE-BUFFER 'NON-FILE-BUFFER ':NAME NAME))
	   DIS-TEXT))))

;; For those who want obvious commands like Hardcopy Buffer to be dwimmed by
;; default to the default buffer (which just about has to be the current one).
;; For those who don't, set this variable to NIL.
(DEFVAR *DEFAULT-BUFFER-NAME-UNLESS-NUMERIC-ARG* T)

(DEFUN SELECT-BUFFER (PROMPT &OPTIONAL DONT-PROMPT)
  (LET ((*DEFAULT-BUFFER-NAME-UNLESS-NUMERIC-ARG* DONT-PROMPT))
    (MAKE-BUFFER-CURRENT (READ-BUFFER-NAME-OR-DEFAULT-WITHOUT-ARG PROMPT ':OTHER)))
  DIS-TEXT)

;This should include all of the delimiters used by common file systems
(DEFVAR *BUFFER-NAME-COMPLETING-DELIMS* '(#\SP #/- #/. #/; #/: #/< #/> #/[ #/] #//))

(SCL:DEFINE-PRESENTATION-TYPE BUFFER (() &KEY (CREATE-P :IF-FORCED))
   :NO-DEFTYPE T
   :HISTORY (() *BUFFER-HISTORY*)

   :PARSER ((STREAM &KEY INITIALLY-DISPLAY-POSSIBILITIES)
	    (MULTIPLE-VALUE-BIND (BUFFER SUCCESS NAME)
		(DW:COMPLETING-FROM-SUGGESTIONS
		    (STREAM
		      :DELIMITERS *BUFFER-NAME-COMPLETING-DELIMS*
		      :ALLOW-ANY-INPUT (EQ CREATE-P 'T)
		      :ENABLE-FORCED-RETURN (EQ CREATE-P :IF-FORCED)
		      :TYPE 'BUFFER
		      :INITIALLY-DISPLAY-POSSIBILITIES
		      INITIALLY-DISPLAY-POSSIBILITIES)
		  (MAPHASH (LAMBDA (NAME BUFFER)
			     (WHEN (STRINGP NAME)	;skip pathnames
			       (DW:SUGGEST NAME BUFFER)))
			   *ZMACS-BUFFER-NAME-TABLE*))
	      (IF SUCCESS BUFFER (FIND-BUFFER-NAMED NAME T))))

   :DESCRIPTION "an editor buffer")

;; Find a buffer, by asking the user the name.  If the buffer is not found,
;; action depends on IMPOSSIBLE-IS-OK-P.  If IMPOSSIBLE-IS-OK-P is NIL, the
;; user gets reminded about c-CR and can try again.  Otherwise the buffer is created.
;; If the user types a null string, DEFAULT is returned.
(DEFUN READ-BUFFER-NAME (PROMPT DEFAULT &OPTIONAL IMPOSSIBLE-IS-OK-P)
  (TYPEIN-LINE-ACCEPT `((BUFFER) :CREATE-P ,(OR IMPOSSIBLE-IS-OK-P :IF-FORCED))
		      ;;+++ I think the history system is supposed to do this.
		      ;; Defaults still need work in the presentation system.
		      :DEFAULT (FIND-BUFFER-NAMED
				 (SEND *BUFFER-HISTORY* :CANONICALIZE-DEFAULT DEFAULT))
		      :PROMPT PROMPT))

;; For commands that should furnish a dwim of defaulting immediately without
;; prompting unless a numeric arg is given (if the option is set), e.g., Kill Buffer.
(DEFUN READ-BUFFER-NAME-OR-DEFAULT-WITHOUT-ARG (PROMPT DEFAULT &OPTIONAL IMPOSSIBLE-IS-OK-P)
  (IF (AND *DEFAULT-BUFFER-NAME-UNLESS-NUMERIC-ARG*
	   (NULL *NUMERIC-ARG-P*))
      (FIND-BUFFER-NAMED (SEND *BUFFER-HISTORY* :CANONICALIZE-DEFAULT DEFAULT))
    (READ-BUFFER-NAME PROMPT DEFAULT IMPOSSIBLE-IS-OK-P)))

(DEFCOM COM-CREATE-NEW-BUFFER-FROM-MINIBUFFER "Create the buffer." ()
  (LET ((NAME (STRING-INTERVAL *INTERVAL*)))
    (IF (FIND-BUFFER-NAMED NAME)
	(BARF "There is already a buffer named /"~A/"" NAME))
    (THROW 'RETURN-FROM-COMMAND-LOOP 
	    (CONS NIL (MAKE-BUFFER 'NON-FILE-BUFFER ':NAME NAME)))))

(DEFCOM COM-SELECT-PREVIOUS-BUFFER "Selects a previously selected buffer.
With a numeric argument, it selects the nth previous buffer.  The default
argument is 2.  When the argument is 1, it rotates the entire buffer history.
A negative argument means to rotate the other way.
An argument of zero displays the buffer history." ()
  (COND ((ZEROP *NUMERIC-ARG*)
	 (DISPLAY-HISTORY-MENU *TYPEOUT-WINDOW* *BUFFER-HISTORY* *HISTORY-MENU-LENGTH* NIL T)
	 DIS-NONE)
	(T (ROTATE-BUFFER-HISTORY (IF (MEMQ *NUMERIC-ARG-P* '(:SIGN NIL))
				      (* 2 *NUMERIC-ARG*) *NUMERIC-ARG*)))))

(DEFVAR *DEFAULT-PREVIOUS-BUFFER-ARG* 3)
(DEFCOM COM-SELECT-DEFAULT-PREVIOUS-BUFFER "Rotates the stack of previously selected buffers.
A numeric argument specifies the number of entries to rotate and sets the new
default." ()
  (COND ((ZEROP *NUMERIC-ARG*)
	 (DISPLAY-HISTORY-MENU *TYPEOUT-WINDOW* *BUFFER-HISTORY* *HISTORY-MENU-LENGTH* NIL T)
	 DIS-NONE)
	(T
	 (OR (MEMQ *NUMERIC-ARG-P* '(:SIGN NIL))
	     (SETQ *DEFAULT-PREVIOUS-BUFFER-ARG* *NUMERIC-ARG*))
	 (ROTATE-BUFFER-HISTORY (IF (EQ *NUMERIC-ARG-P* ':SIGN)
				    (* *NUMERIC-ARG* *DEFAULT-PREVIOUS-BUFFER-ARG*)
				    *DEFAULT-PREVIOUS-BUFFER-ARG*)))))

(COMPILER:FUNCTION-DEFINED 'VC-FILE-BUFFER-DISCONNECTED-P)
;Value is T normally, or NIL if saving was aborted, e.g. by misbalanced parentheses
(DEFUN SAVE-BUFFER (BUFFER)
  (LET (PATHNAME
	(SAVED NIL))
    (COND ((AND (VC-FILE-BUFFER-P BUFFER) (VC-FILE-BUFFER-DISCONNECTED-P BUFFER))
	   (BARF "Disconnected buffers cannot be saved.  
Use (m-x) Set Buffer Disposition to change the buffer disposition."))
	  ((NOT (SEND BUFFER :EDITING-FILE-P))
	   (SETQ PATHNAME (IF *WINDOW* (ACCEPT-DEFAULTED-PATHNAME
					 (FORMAT NIL "Save ~A on file"
						 (SEND BUFFER :NAME))
					 (LET ((*INTERVAL* BUFFER))
					   (PATHNAME-DEFAULTS))
					 :SPECIAL-VERSION NIL :DIRECTION :WRITE)
			    (FORMAT QUERY-IO "~&Save file to (Default ~A): "
				    (DEFAULT-PATHNAME *PATHNAME-DEFAULTS*))
			    (MAKE-DEFAULTED-PATHNAME (READLINE) (PATHNAME-DEFAULTS))))
	   (SETQ BUFFER (SEND BUFFER :SET-PATHNAME-FOR-WRITE PATHNAME)))
	  (T
	   (SETQ PATHNAME (SEND BUFFER :PATHNAME))))
    (AND (LET ((FILE-INFO (SEND BUFFER :FILE-INFO))
	       (FILE-FILE-INFO (CONDITION-CASE (ERROR)
				    (WITH-ZWEI-WRITE-CREATE-DIRECTORIES (:QUERY)
				      (LET ((PROBE (OPEN PATHNAME
							 :DIRECTION NIL :CHARACTERS T
							 :IF-DOES-NOT-EXIST :ERROR)))
					(SEND PROBE :INFO)))
				  (FS:FILE-NOT-FOUND NIL)
				  (FS:FILE-OPERATION-FAILURE
				    (BARF "Error probing ~A:  ~A" PATHNAME ERROR)))))
	   ;; we have to find out FILE-INFO and FILE-FILE-INFO in any event.  If
	   ;; FILE-INFO is NIL or :NEVER-READ, and FILE-FILE-INFO is non-null,
	   ;; then fquery about that.  If FILE-INFO is not equal to FILE-FILE-INFO,
	   ;; then fqueury about that (the date has changed).
	   (LET ((QUERY-IO *TYPEOUT-WINDOW*))
	     (COND ((OR (EQUAL FILE-INFO FILE-FILE-INFO)
			(NULL FILE-FILE-INFO))
		    ;; everything is cool.  This includes when FILE-INFO is NIL
		    ;; and FILE-FILE-INFO is NIL.
		    T)
		   ;; otherwise something is wrong
		   ((ATOM FILE-INFO)		; :NEVER-READ or NIL
		    ;; We know that FILE-FILE-INFO is non-null, so we are writing to
		    ;; a file we never read into this buffer.
		    (FQUERY '#,`(:SELECT T
				 :BEEP T
				 :TYPE :READLINE
				 :CHOICES ,FORMAT:YES-OR-NO-P-CHOICES)
			    "You have not read file ~A into this buffer,~@
			     but now you are about to write over it.~@
			     The file is now ~A.~@
			     Save over it anyway?"
			    PATHNAME
			    (DESCRIBE-FILE-INFO FILE-FILE-INFO)))
		   (T
		    ;; We know that both FILE-INFO and FILE-FILE-INFO are legitimate,
		    ;; but they are different, presumably in the write date.
		    (FQUERY '#,`(:SELECT T
				 :BEEP T
				 :TYPE :READLINE
				 :CHOICES ,FORMAT:YES-OR-NO-P-CHOICES)
			    "When you last read or wrote ~A~@
			     it was ~A,~@
			     but now it is ~A.~@
			     Save it anyway? "
			    PATHNAME (DESCRIBE-FILE-INFO FILE-INFO)
			    (IF FILE-FILE-INFO
				(DESCRIBE-FILE-INFO FILE-FILE-INFO)
			      "deleted"))))))
	 (CATCH 'SAVE-BUFFER
	   (SEND BUFFER :SAVE)
	   (SETQ SAVED T)))
    SAVED))

(DEFUN ZWEI-WRITE-DNF-HANDLER (ERROR)
  (LET ((PATHNAME (SEND ERROR :PATHNAME)))
    (DECLARE (SPECIAL *ZWEI-WRITE-DNF-SWITCH*))
    (LET ((ACTION (CL:CASE *ZWEI-WRITE-DNF-SWITCH*
		    ((T) :CREATE)
		    (:QUERY
		      (BEEP)
		      (LET ((QUERY-IO *TYPEOUT-WINDOW*))
			(FORMAT QUERY-IO "~&~A~%" ERROR)
			(DW:WITH-ACCEPT-HELP
			    (((:TOP-LEVEL-HELP :OVERRIDE)
			      (FORMAT NIL
				 "You are being asked what to do about the missing directory:
   Create the directory ~A:~A and all missing inferiors.
   Abort this command."	      ;add "Prompt for a new pathname" when we figure out how
				 (SEND (SEND PATHNAME ':HOST) ':NAME-AS-FILE-COMPUTER)
				 (SEND PATHNAME ':STRING-FOR-DIRECTORY))))
			  (SCL:ACCEPT '((CL:MEMBER :CREATE :ABORT #+++IGNORE :PROMPT))
				      :PROMPT
				      "  Create the directory, or Abort this command"))))
		    (T *ZWEI-WRITE-DNF-SWITCH*))))
      (CL:CASE ACTION
	(:CREATE (WHEN (FS:CREATE-DIRECTORIES-RECURSIVELY PATHNAME)
		   (THROW 'ZWEI-WRITE-TARGET-RETRY NIL)))
	(:ABORT (ABORT-CURRENT-COMMAND))))
    NIL))

(DEFSUBST INHIBITING-SAVING-STYLES-P (interval)
  (SEND-IF-HANDLES				; Echo area doesn't handle this message.
    INTERVAL :GET :INHIBIT-SAVING-CHARACTER-STYLES))

(DEFMETHOD (:SAVE FILE-BUFFER-MIXIN) ()
  (LET ((USER (NON-DAEMON-USER-ID)))
    (ERROR-RESTART ((ERROR) "Retry saving ~A into ~A" NAME PATHNAME)
      (WITH-ZWEI-WRITE-CREATE-DIRECTORIES (:QUERY)
	(WITH-OPEN-FILE (STREAM PATHNAME :DIRECTION :OUTPUT)
	  (LET ((CHECK-PARENS (AND *CHECK-UNBALANCED-PARENTHESES-WHEN-SAVING*
				   (SEND (SEND SELF :GET :MAJOR-MODE)
					 :CHECK-PARENS-WHEN-SAVING))))
	    (MULTIPLE-VALUE-BIND (PARSING-VARS PARSING-VALS)
		;; If checking parens, do so in correct syntax.
		(AND CHECK-PARENS (SEND (SEND SELF :GET :MAJOR-MODE) :PARSING-BINDINGS SELF))
	      (SEND SELF :SAVE-CHECKING-FOR-SAVING-CHARACTER-STYLES-INHIBITION STREAM)
	      (PROGV PARSING-VARS PARSING-VALS
		(STREAM-OUT-INTERVAL STREAM FIRST-BP LAST-BP T
				     NIL
				     CHECK-PARENS))))
	  (UNLESS (STRING-EQUAL USER USER-ID)
	    (CONDITION-CASE (ERROR)
		 (SEND STREAM :CHANGE-PROPERTIES () :AUTHOR USER)
	       (FS:FILE-ERROR (TYPEIN-LINE "Warning: ~A~%" ERROR))))
	  (CLOSE STREAM)
	  (SEND SELF :SET-FILE-INFO (SEND STREAM :INFO))
	  (WHEN *DISCARD-CHANGE-RECORD-AFTER-SAVING*
	    (DISCARD-CHANGE-HISTORY SELF))
	  (SETQ SAVE-TICK (TICK))
	  (TYPEIN-LINE "Written: ~A" (SEND STREAM :TRUENAME)))))))

(DEFMETHOD (:SAVE-CHECKING-FOR-SAVING-CHARACTER-STYLES-INHIBITION FILE-BUFFER-MIXIN) (STREAM)
  ;; Checks to see if the current interval is inhibiting the saving of character style information.
  ;; If it is, arranges to ignore any FONTS: attribute that may be around from Release 6, and also
  ;; converts the entire interval to the [NIL.NIL.NIL] style.  If the interval is not inhibiting the
  ;; saving of character style information (i.e., normal behavior except for files going to non-lispm
  ;; hosts), just does the normal actions.
  ;;
  ;; The :CLEAR-CHARACTER-TYPES and FS:READ-ATTRIBUTE-LIST are executed once always, rather
  ;; than inside the loop, because we need the side-effects and the information in either case.
  (SEND STREAM :CLEAR-CHARACTER-TYPES)		; Flush (NIL NIL NIL).
  (LET ((ATTRIBUTES (FS:READ-ATTRIBUTE-LIST NIL (OPEN-INTERVAL-STREAM SELF))))
    (IF (INHIBITING-SAVING-STYLES-P SELF)
	(SEND SELF :SAVE-PRESTRIP-CHARACTER-STYLES ATTRIBUTES)	; Strip out character styles.
	(SEND SELF :SAVE-RELEASE-6-COMPATIBILITY-KLUGE STREAM ATTRIBUTES))))

(DEFMETHOD (:SAVE-PRESTRIP-CHARACTER-STYLES FILE-BUFFER-MIXIN) (ATTRIBUTES)
  ;; Checks to see if the interval has any non-[NIL.NIL.NIL] character styles, and strips
  ;; them if so.  It would be more efficient to write a subsidiary routine that stopped at
  ;; the first non-[NIL.NIL.NIL] style, but it's a fair amount of work.
  ;;
  ;; This routine also removes any FONTS: attribute that may be in the attributes line.
  ;; This is, alas, necessary even if we ourselves haven't outputted the style preamble,
  ;; because (FLAVOR:METHOD FILE-ACCESS-PATH-OPEN FS:FONT-ENCAPSULATING-ACCESS-PATH-MIXIN)
  ;; looks for its existence and makes an instance of SI:INDIRECT-ESCAPE-OUTPUT-STREAM
  ;; with a :CHECK-FOR-FONTS-LINE init-keyword of T if so---which is bad news, because
  ;; the various other dumping stuff will then write the preamble if the FONTS: line is there.
  ;; The modularity of having the access-path check for a buffer interval's pseudo-minor-mode
  ;; is terrible, as is simply removing this check (since that would break things that used a FONTS:
  ;; attribute and we're inhibiting styles), so we'll have to deal with it here.  Yuck.  The only other
  ;; way to do this is something like (SYS:EVAL-IN-INSTANCE STREAM '(SETF FONTS-CHECKING-STREAM NIL)),
  ;; executed *after* (MAKE-INSTANCE SI:ESCAPE-DUMPING-STREAM-MIXIN :AFTER) runs, which is bad too.
  ;;
  ;; This routine tells ZMACS directly that the window must be redisplayed, rather than
  ;; passing some DIS-code upwards.  While this is not a great way to do things, passing
  ;; the redisplay condition upwards would involve modifying at least two (and maybe more)
  ;; otherwise uninvolved routines.  And hey, lots of other ZMACS routines do this too, so there.
  (WHEN (CL:GETF ATTRIBUTES :FONTS)		; Ask first, so we know whether to redisplay.
    (UPDATE-ONE-ATTRIBUTE SELF "Fonts" NIL)	; Kill the Fonts: attribute.
      (MUST-REDISPLAY *WINDOW* DIS-TEXT))	; If we've changed the FONTS: attribute, anything else might have changed.
  (LET* ((STYLES (COLLECT-CHARACTER-STYLES-IN-INTERVAL SELF))
	 (NON-NIL-P
	   (LOOP FOR (STYLE FROM-BP TO-BP) IN STYLES	; (STYLE IGNORE IGNORE) generates compilation warnings.
		 DO (IGNORE FROM-BP TO-BP)
		 THEREIS (OR (NEQ (SI:CS-FAMILY STYLE) NIL)
			     (NEQ (SI:CS-FACE STYLE) NIL)
			     (NEQ (SI:CS-SIZE STYLE) NIL)))))
    (WHEN NON-NIL-P
      (CHANGE-STYLE-INTERVAL SELF NIL NIL 0)	; Assuming that [NIL.NIL.NIL] always has style index of 0.
      (MUST-REDISPLAY *WINDOW* DIS-TEXT))))

(DEFMETHOD (:SAVE-RELEASE-6-COMPATIBILITY-KLUGE FILE-BUFFER-MIXIN) (STREAM ATTRIBUTES)
  ;; Release-6 compatability kluge.  This used to be inside (:SAVE FILE-BUFFER-MIXIN).
  (LOOP	;; Actually parse attributes, don't use preparsed ones, which may be
	;; outdated.  Otherwise, illegal file can result.
	FOR FONT IN (LET ((FONTS (CL:GETF ATTRIBUTES :FONTS)))
		      (AND FONTS (IF (ATOM FONTS) (LIST FONTS) FONTS)))
	FOR INDEX FROM 0
	DO (CONDITION-CASE (.ERROR.)
		(MULTIPLE-VALUE-BIND (STYLE CHARACTER-SET)
		    (SI:BACKTRANSLATE-FONT (STRING FONT) SI:*B&W-SCREEN*)
		  (SEND STREAM :PRESET-CHARACTER-TYPE
			:INDEX INDEX
			:CHARACTER-SET CHARACTER-SET
			:STYLE (SI:CANONICALIZE-CHARACTER-STYLE STYLE)))
	      (ERROR (TYPEIN-LINE "Cannot understand font attribute ~A:  ~~A~"
				  FONT .ERROR.)))
	FINALLY
	  ;; Now make them all appear explicitly, so we aren't dependent forever
	  ;; on backtranslating the fonts in the attribute list.
	  (SEND STREAM :WRITE-ALL-CHARACTER-TYPES)))

(DEFMETHOD (:SET-TICKS-FOR-FILE-BUFFER-STREAM FILE-BUFFER-MIXIN) (NEW-TICK)
  (SETQ READ-TICK NEW-TICK)
  (SETQ SAVE-TICK NEW-TICK))

(DEFMETHOD (:SET-FILE-INFO FILE-BUFFER-MIXIN) (INFO)
  (SETQ FILE-INFO INFO)
  (SEND SELF :UPDATE-VERSION-STRING)
  INFO)

(DEFMETHOD (:UPDATE-VERSION-STRING FILE-BUFFER-MIXIN) ()
  (SETQ VERSION-STRING (AND (LISTP FILE-INFO)
			    (TYPEP (CAR FILE-INFO) 'FS:PATHNAME)
			    (NOT (NUMBERP (SEND PATHNAME :VERSION)))
			    (LET ((VERSION (SEND (CAR FILE-INFO) :VERSION)))
			      (AND (NUMBERP VERSION) (FORMAT NIL " (~D)" VERSION))))))

(DEFMETHOD (:UPDATE-VERSION-STRING FILE-BUFFER-MIXIN :AFTER) ()
  (LOOP FOR COMMAND-LOOP IN *ZMACS-COMMAND-LOOPS*
	AS ZWF = (WINDOW-FRAME (SYMEVAL-IN-INSTANCE COMMAND-LOOP '*WINDOW*))
	DO (SEND ZWF :UPDATE-LABELS)))


;; The following methods extend the protocol for :revert compatably.
(DEFMETHOD (:REVERT-WITH-STREAM-P FILE-BUFFER-MIXIN) () T)
(DEFMETHOD (:REVERT-WITH-STREAM-P BUFFER :DEFAULT) () NIL)

;; Read a file into a buffer, or read back in the file that was in the buffer.
;; Note that this may close the stream, so the caller with a stream has to take that
;; into account.

(DEFMETHOD (:REVERT FILE-BUFFER-MIXIN) ()
  (WHEN (AND (SEND SELF :READ-ONLY)
	     (OPERATION-HANDLED-P SELF :SET-READ-WRITE))
    (TYPEIN-LINE "Buffer ~A set to Read//Write for reverting."
		 (SEND SELF :NAME))
    (SEND SELF :SET-READ-WRITE (SEND SELF :GET :SAVED-READ-WRITE-TICK)))
  (SEND SELF :REVERT-INTERNAL NIL))

(DEFMETHOD (:REVERT-WITH-STREAM FILE-BUFFER-MIXIN) (STREAM)
  (SEND SELF :REVERT-INTERNAL STREAM))

;;; This is an internal function of (FILE-BUFFER-MIXIN :REVERT).
(DEFUN-IN-FLAVOR (REVERT-FROM-STREAM FILE-BUFFER-MIXIN) (STREAM)
  (LET ((TRUENAME (SEND STREAM ':TRUENAME)))
    (TYPEIN-LINE "Reading ~A " TRUENAME)
    (LET ((THIS-VERSION (SEND TRUENAME ':VERSION))
	  (LOADED-TRUENAME (FILE-LOADED-TRUENAME TRUENAME))
	  LOADED-VERSION)
      (AND LOADED-TRUENAME
	   (NUMBERP THIS-VERSION)
	   (NUMBERP (SETQ LOADED-VERSION (SEND LOADED-TRUENAME ':VERSION)))
	   ( LOADED-VERSION THIS-VERSION)
	   (TYPEIN-LINE-MORE " (loaded version is ~D) " LOADED-VERSION))))
  (TYPEIN-LINE-MORE "...")
  ;; "Reparse" wants to leave alone things that are not in the attribute list.
  ;; So before calling it, bind PACKAGE, in case there's no Package attribute.
  ;; If there's no Ibase, just get that from the global default IBASE.
  (LET* ((MAJOR-MODE (SEND SELF :MAJOR-MODE))
	 ;; major-mode-default-package (or *default-package*) are not packages,
	 ;; they are package names.  However, we cannot translate the name
	 ;; to a package reliably without the syntax attribute to use to
	 ;; disambiguate CL-USER and ZL-USER (and PASCAL-USER?) and friends.
	 ;; Punt, and just bind PACKAGE to itself if we encounter one of these cases.
	 (PACKAGE (OR (PKG-FIND-PACKAGE
			(OR (MAJOR-MODE-DEFAULT-PACKAGE MAJOR-MODE)
			    (IF (BOUNDP '*DEFAULT-PACKAGE*)
				(SYMEVAL '*DEFAULT-PACKAGE*)
				(GET '*DEFAULT-PACKAGE* 'VARIABLE-INIT)))
			:FIND)
		      PACKAGE)))
    (REPARSE-ATTRIBUTE-LIST-INTERNAL SELF STREAM))
  (WHEN *ZMACS-FORCE-FUNDAMENTAL-MODE*		;special trick for Find File In Fund Mode
    (SEND SELF ':PUTPROP (MAJOR-MODE-FROM-KEYWORD ':FUNDAMENTAL) ':MAJOR-MODE))
  (WHEN (AND (VARIABLE-BOUNDP *INTERVAL*) (EQ SELF *INTERVAL*))
    (SET-ATTRIBUTE-STATE-FROM-BUFFER SELF))
  (PRESERVE-BUFFER-POINT (SELF)
    (LET ((*ENABLE-CHANGE-RECORDING* NIL))
      (DELETE-INTERVAL SELF)
      (SETQ READ-TICK (TICK))			;For SECTIONIZE-BUFFER
      (SETQ SAVE-TICK *TICK*)
      (SECTIONIZE-BUFFER SELF STREAM)
      (SEND SELF ':SET-FILE-INFO (SEND STREAM ':INFO))))
  (LET* ((NCHARS (SEND STREAM ':READ-POINTER))
	 (NK (// (+ NCHARS 500.) 1000.)))
    (TYPEIN-LINE-MORE " ~:[~DK~*~;~*~D~] character~P"
		      (ZEROP NK) NK NCHARS NCHARS)))

(DEFMETHOD (:REVERT-INTERNAL FILE-BUFFER-MIXIN) (STREAM)
  (WITH-BUFFER-PROTECTED SELF
    (CONDITION-CASE (.ERROR.)
	 (CONDITION-BIND ((SI:BINARY-FILE-READ-AS-CHARACTER-FILE-ERROR
			    #'SI:BINARY-FILE-READ-AS-CHARACTER-FILE-ERROR-QUERY-HANDLER)
			  (SI:ESCAPE-LOADING-STREAM-DECODING-ERROR
			    #'SI:ESCAPE-LOADING-STREAM-DECODING-ERROR-QUERY-HANDLER))
	   (ERROR-RESTART ((ERROR) "Retry reading of ~A from ~A" NAME PATHNAME)
	     (IF STREAM
		 (BLOCK USE-CALLERS-STREAM
		   (WITH-STACK-LIST* (SI:*RETRY-WITHOUT-ESCAPE-PROCESSING*
				       `(,STREAM . RETRY-AS-STRING-CHAR)
				       SI:*RETRY-WITHOUT-ESCAPE-PROCESSING*)
		     (CATCH 'RETRY-AS-STRING-CHAR
		       (SEND STREAM :SET-POINTER 0)
		       (REVERT-FROM-STREAM STREAM)
		       (RETURN-FROM USE-CALLERS-STREAM (VALUES))))
		   D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; User asked that we reread a file without  decoding --
0		   1;;     Our caller will close the original stream; we must be certain
0		   1;;     to close the new stream that we'll open in just a second.
0		   (DELETE-INTERVAL SELF)
		   (WITH-OPEN-FILE (STREAM PATHNAME :DIRECTION :INPUT
					   :ELEMENT-TYPE 'CL:STRING-CHAR)
		     (REVERT-FROM-STREAM STREAM)))
	       1;; No stream supplied.
0	       (SI:WITH-OPEN-CHARACTER-FILE (STREAM PATHNAME :DIRECTION :INPUT)
		 (UNWIND-PROTECT-CASE ()
		     (REVERT-FROM-STREAM STREAM)
		   (:ABORT
		     (DELETE-INTERVAL SELF)))))))
       (FS:FILE-NOT-FOUND
	 (IF *REVERT-FILE-NOT-FOUND-IS-AN-ERROR*
	     (IF (STRINGP *REVERT-FILE-NOT-FOUND-IS-AN-ERROR*)
		 (BARF "~A~%~3T~~A~" *REVERT-FILE-NOT-FOUND-IS-AN-ERROR* .ERROR.)
	       (BARF "Error: ~A" .ERROR.)))
	 (TYPEIN-LINE "(New File)")
	 (DELETE-INTERVAL SELF)
	 (SEND SELF :SET-FILE-INFO ':NEVER-READ)
	 (LET ((GENERIC-PATHNAME (SEND PATHNAME :GENERIC-PATHNAME)))
	   1;; Forget everything from previous loading of this file.
0	   (SEND GENERIC-PATHNAME :SET-PROPERTY-LIST NIL)
	   (LET ((ERROR-OUTPUT #'SI:NULL-STREAM)
		 1;; Ignore global state.
0		 (IBASE 10.)
		 (READTABLE SI:*COMMON-LISP-READTABLE*))
	     (FS:FILE-ATTRIBUTE-BINDINGS GENERIC-PATHNAME))
	   (DOLIST (ATTR '(:BASE :SYNTAX))
	     (LET ((VAL (SEND GENERIC-PATHNAME :GET ATTR)))
	       (WHEN VAL
		 (SEND SELF :PUTPROP VAL ATTR))))))
       (FS:FILE-OPERATION-FAILURE
	 (BARF "Error: ~A" .ERROR.))
       (SI:BINARY-FILE-READ-AS-CHARACTER-FILE-ERROR
	 (ABORT-CURRENT-COMMAND)))
    (SETQ READ-TICK (TICK))
    (SETQ SAVE-TICK *TICK*)))

(DEFMETHOD (WITH-BUFFER-PROTECTED-INTERNAL FILE-BUFFER-MIXIN) (CONTINUATION)
  (LET* ((OLD-BUFFER (BUFFER-SECTIONS SELF))
	 (SAVED-INTERVAL (IF OLD-BUFFER (COPY-INTERVAL SELF)))
	 (SAVED-INFO (IF OLD-BUFFER (SEND SELF :FILE-INFO))))
     (UNWIND-PROTECT-CASE ()
	 (FUNCALL CONTINUATION)
       (:ABORT
	 (WHEN OLD-BUFFER
	   ;; Restore the state of the buffer
	   (DELETE-INTERVAL SELF)
	   (INSERT-INTERVAL (INTERVAL-LAST-BP SELF) SAVED-INTERVAL)
	   (REPARSE-ATTRIBUTE-LIST-INTERNAL SELF (OPEN-INTERVAL-STREAM SELF))
	   (WHEN (EQ SELF *INTERVAL*)
	     (SET-ATTRIBUTE-STATE-FROM-BUFFER SELF))
	   (SECTIONIZE-BUFFER SELF)
	   (SEND SELF :SET-FILE-INFO SAVED-INFO)
	   (TYPEIN-LINE "The original state of ~A has been restored"
			(SEND SELF :NAME)))))))

;(TV:ADD-TYPEOUT-ITEM-TYPE *TYPEOUT-COMMAND-ALIST* ZMACS-BUFFER "Not Modified" SET-NOT-MODIFIED
;			  NIL "Mark this buffer as not having been modified.")

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR SET-NOT-MODIFIED
						  (BUFFER "Not Modified" *ZMACS-COMTAB*)
						  (BUFFER)
  `(SET-NOT-MODIFIED ,BUFFER))

(DEFMETHOD (:SET-NOT-MODIFIED BUFFER) (&OPTIONAL UNDO-P)
  (UNLESS UNDO-P
    (BARF "This buffer is not associated with a file.")))

(DEFMETHOD (:SET-NOT-MODIFIED FILE-BUFFER-MIXIN) (&OPTIONAL UNDO-P)
  (IGNORE UNDO-P)
  (SETQ SAVE-TICK (TICK))
; (SETQ READ-TICK *TICK*)
; (DOLIST (SECTION INFERIORS)
;   (AND (TYPEP SECTION 'SECTION-NODE)
; (SETF (SECTION-NODE-COMPILE-TICK SECTION) *TICK*)))
  )

(DEFUN SET-NOT-MODIFIED (INTERVAL &OPTIONAL SILENT)
  (SEND INTERVAL ':SET-NOT-MODIFIED)
  (OR SILENT (TYPEIN-LINE "Not modified"))
  DIS-NONE)

(DEFCOM COM-NOT-MODIFIED "Marks this buffer as not modified by removing the modified flag.
Use this when a buffer was modified by mistake so that you don't become
confused and save unwanted changes.  " ()
  (SET-NOT-MODIFIED *INTERVAL*))

(DEFMETHOD (:MUNG FILE-BUFFER-MIXIN :BEFORE) (IGNORE)
  (WHEN (OR *ENABLE-CHANGE-RECORDING* *SPARSE-CHANGE-ARRAY*)
    (UNLESS (EQ TICK ':READ-ONLY)
      (UNLESS (EQ CHANGE-HISTORY ':DISABLED)
	(UNLESS (ATOM (SEND SELF :FILE-INFO))	;ATOM is NIL or :NEVER-READ
	  (WHEN ( SAVE-TICK TICK)
	    ;; This buffer is unmodified and is about to become modified
	    (PUSH (MAKE-MUNG-NODE-RECORD SELF TICK) CHANGE-HISTORY)))))))

;; If all changes since the file was read or written are undone, the file isn't modified
(DEFMETHOD (NOTE-UNDONE-CHANGES FILE-BUFFER-MIXIN) (RESTORED-TICK)
  (WHEN ( SAVE-TICK RESTORED-TICK)
    (SEND SELF :SET-NOT-MODIFIED T)))

(DEFMETHOD (:MUNG SECTION-NODE :BEFORE) (IGNORE)
  (WHEN (OR *ENABLE-CHANGE-RECORDING* *SPARSE-CHANGE-ARRAY*)
    (WHEN (OR ( COMPILE-TICK TICK)
	      ( SECTIONIZATION-TICK TICK)
	      ( (CL:GETF PLIST 'PATCH-TICK 0) TICK))
      (LET ((BUFFER (BP-CHANGE-RECORDING-BUFFER FIRST-BP)))
	(WHEN BUFFER
	  (RECORD-ACCUMULATED-CHANGES BUFFER)
	  (PUSH (MAKE-MUNG-NODE-RECORD SELF TICK) (BUFFER-CHANGE-HISTORY BUFFER)))))))

;;; If this section node hasn't been lost from the sectionization, we can note
;;; that it doesn't have changes that need to be compiled, sectionized, or patched.
;;; But first, note that its text may not have been modified.
(DEFMETHOD (NOTE-UNDONE-CHANGES SECTION-NODE) (RESTORED-TICK)
  (LET* ((BUFFER (INTERVAL-BUFFER SELF))
	 (READ-TICK (SEND-IF-HANDLES BUFFER :READ-TICK))
	 (SAVE-TICK (SEND-IF-HANDLES BUFFER :SAVE-TICK)))
    (COND ((AND READ-TICK ( READ-TICK RESTORED-TICK))
	   (SETQ TICK READ-TICK))
	  ((AND SAVE-TICK ( SAVE-TICK RESTORED-TICK))
	   (SETQ TICK SAVE-TICK))))
  (WHEN ( COMPILE-TICK RESTORED-TICK)
    (SETQ COMPILE-TICK TICK))
  (WHEN ( SECTIONIZATION-TICK RESTORED-TICK)
    (SETQ SECTIONIZATION-TICK TICK))
  (WHEN ( (CL:GETF PLIST 'PATCH-TICK 0) RESTORED-TICK)
    (SETF (CL:GETF PLIST 'PATCH-TICK) TICK)))

(DEFMETHOD (:DESCRIPTION BUFFER) ()
  "")

(DEFMETHOD (:DESCRIPTION FILE-BUFFER) ()
  (OR VERSION-STRING ""))

(DEFMETHOD (:DESCRIPTION NON-FILE-BUFFER) ()
  (FORMAT NIL "[~D line~:P]" (COUNT-LINES-BUFFER SELF)))


(DEFCOM COM-KILL-BUFFER "Kills a specified buffer.
It prompts in the minibuffer for the name of the buffer to kill.
If the current buffer is being killed, it also prompts for
the name of the buffer to be selected afterwards, where the default
is the previous buffer." ()
  (LET ((BUFFER (READ-BUFFER-NAME "Buffer to kill" *INTERVAL*)))
    (KILL-BUFFER BUFFER))
  DIS-NONE)

(DEFCOM COM-KILL-SOME-BUFFERS "Cleans up buffers, querying about killing each one.
For each buffer, it asks whether to kill it and, for each one to be killed,
offers to write out changes.  With a numeric argument, it asks only about
buffers whose name contain a given string." ()
  (LET (APROPOS
	BUFFERS-TO-KILL
	(ABORTED-P T))
    (WHEN *NUMERIC-ARG-P*
      (SETQ APROPOS (TYPEIN-LINE-READLINE "Kill buffers matching substring:")))
    (UNWIND-PROTECT
	(SETQ BUFFERS-TO-KILL
	      (LOOP WITH QUERY-IO = *TYPEOUT-WINDOW*
		    FOR BUFFER IN *ZMACS-BUFFER-LIST*
		    WHEN (AND (OR (NULL APROPOS) (STRING-SEARCH APROPOS (SEND BUFFER :NAME)))
			      (FQUERY '(:SELECT T) "Buffer ~A ~A, kill it? "
				      (SEND BUFFER ':NAME)
				      (MULTIPLE-VALUE-BIND (MODIFIED-P SPECIAL-STATUS)
					  (SEND BUFFER ':MODIFIED-P ':FOR-CLEANING)
					(COND ((EQ SPECIAL-STATUS ':EMPTY)
					       "is empty")
					      ((EQ SPECIAL-STATUS ':NO-FILE)
					       "has no file associated with it")
					      ((EQ SPECIAL-STATUS ':NEW-FILE)
					       "is a new file")
					      ((EQ SPECIAL-STATUS ':SPECIAL)
					       "is a special-purpose buffer")
					      (MODIFIED-P
					       "has been edited")
					      (T "is unmodified")))))
		      COLLECT BUFFER)
	      ABORTED-P NIL)
      (IF ABORTED-P
	  (TYPEIN-LINE "No buffers killed.")
	(LOOP WITH THIS-BUFFER
	      FOR BUFFER IN BUFFERS-TO-KILL
	      IF (EQ BUFFER *INTERVAL*)
		DO (SETQ THIS-BUFFER BUFFER)
	      ELSE
		DO (KILL-BUFFER BUFFER)
	      FINALLY (WHEN THIS-BUFFER
			(BEEP)
			(KILL-BUFFER THIS-BUFFER)))
	(FORMAT T "~& ~:[No~*~;~D~] buffer~:P killed.~%"
		(PLUSP (LENGTH BUFFERS-TO-KILL)) (LENGTH BUFFERS-TO-KILL)))))
  DIS-NONE)

;(TV:ADD-TYPEOUT-ITEM-TYPE *TYPEOUT-COMMAND-ALIST* ZMACS-BUFFER "Kill" KILL-BUFFER NIL
;			  "Kill this buffer.")

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR KILL-BUFFER
						  (BUFFER "Kill buffer" *ZMACS-COMTAB*)
						  (BUFFER)
  `(KILL-BUFFER ,BUFFER))

(DEFUN KILL-BUFFER (BUFFER &OPTIONAL NO-SAVE-P)
  (SEND BUFFER ':KILL NO-SAVE-P)
  T)

(DEFMETHOD (:KILL BUFFER) (&OPTIONAL NO-SAVE-P)
  (KILL-BUFFER-INTERNAL SELF NO-SAVE-P))

;; This variable is for losers like DLA who can't stand always being prompted for the
;; obvious new buffers when killing them.
(DEFVAR *KILL-BUFFER-PROMPTS-FOR-NEW-BUFFER* T)

(DEFUN KILL-BUFFER-INTERNAL (BUFFER NO-SAVE-P)
  (DECLARE (VALUES T-IF-KILL-REALLY-HAPPENED))
  (BLOCK KILL-BUFFER
    ;; If the buffer is associated with a file and contains changes, offer to write it out.
    (WHEN (AND (SEND BUFFER ':MODIFIED-P ':FOR-KILLING)
	       (NOT NO-SAVE-P)
	       (FQUERY '#,`(:SELECT T
			    :BEEP T
			    :TYPE :READLINE
			    :CHOICES ,FORMAT:YES-OR-NO-P-CHOICES)
		       "Buffer ~A has been modified, save it first? "
		       (SEND BUFFER ':NAME)))
      (OR (SAVE-BUFFER BUFFER)
	  (RETURN-FROM KILL-BUFFER NIL)))	;Saving failed, so return early
    ;; If buffer is current, select something else before killing.
    (DO () ((NEQ BUFFER *INTERVAL*))
      (WHEN (< (LENGTH *ZMACS-BUFFER-LIST*) 2)
	(BARF "~A is the last buffer;~@
               you can't kill it until you create another buffer."
	      BUFFER))
      (MUST-REDISPLAY
	*WINDOW* (SELECT-BUFFER "Killing the current buffer, select which other buffer?"
				(NOT *KILL-BUFFER-PROMPTS-FOR-NEW-BUFFER*))))
    ;; Anybody who refers to this buffer should be redirected.
    (WITHOUT-INTERRUPTS
      (SETQ *ZMACS-BUFFER-HISTORY*		;per-window history done later
	    (DELQ BUFFER *ZMACS-BUFFER-HISTORY*))
      (REMOVE-FROM-BUFFER-NAME-TABLE BUFFER)
      (SETQ *ZMACS-BUFFER-LIST* (DELQ BUFFER *ZMACS-BUFFER-LIST*))	;should be global
      (LET ((KEY (ZMACS-BUFFER-ALIST-KEY BUFFER)))
	(WHEN KEY
	  (LET ((ELEM (ASSQ KEY *ZMACS-BUFFER-ALIST*)))
	    (WHEN ELEM
	      (SETF (CDR ELEM) (DELQ BUFFER (CDR ELEM) 1)))))))
    (FLUSH-ZMACS-BUFFERS-PROPERTIES-FOR-BUFFER BUFFER)
    (POINT-PDL-PURGE BUFFER)
    (DOLIST (REG *REG-LIST*)
      (LET ((BP (FIRST (GET REG 'POINT))))
	(AND BP (EQ (BP-BUFFER BP) BUFFER)
	     (SI:NREMPROP REG 'POINT))))
    (WITHOUT-INTERRUPTS
      ;; Make up for lack of interlocking on global structures.
      ;; Maybe someday, someone will finish the interlocking.
      (LOOP FOR EDITOR IN *ZMACS-COMMAND-LOOPS*
	    DO (FLUSH-WINDOW-BUFFER-HISTORIES EDITOR BUFFER)))
    ;; Inform all support buffers (there are several flavors that care)
    (LOOP FOR (KEY . BUFFERS) IN *ZMACS-BUFFER-ALIST* DO
      (WHEN (SYMBOLP KEY)
	(DOLIST (SUPPORT-BUFFER BUFFERS)
	  (SEND-IF-HANDLES SUPPORT-BUFFER :BUFFER-KILLED BUFFER))))
    T))

;;; This has to be on (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")top-level-editor0, not 2zmacs-editor0, because we want to use
;;; the instance variable 2*window-list*0, not inherit it from the dynamically active
;;; top-level editor.  Ditto for 2*interval*
0(DEFMETHOD (FLUSH-WINDOW-BUFFER-HISTORIES TOP-LEVEL-EDITOR) (BUFFER)
  ;; Any other windows lying around should not have pointers to this window.
  ;; This buffer could have been in lots of other windows history lists, so check
  ;; all windows, not just the current one.
  (DOLIST (WDW *WINDOW-LIST*)		;look at each of the extant windows
    (LET ((HLIST (WINDOW-BUFFER-HISTORY WDW)))	;get its buffer history
      (WHEN (MEMQ BUFFER HLIST)			;is buffer being killed on history?
	(ALTER-WINDOW WDW			;take the killed buffer out of the history
		      BUFFER-HISTORY
		      (DELQ BUFFER HLIST 1))
	(WHEN (EQ (WINDOW-INTERVAL WDW) BUFFER)	;did window "show" killed buffer?
	  (UNLESS (WINDOW-BUFFER-HISTORY WDW)	;and is something on history?
	    (ALTER-WINDOW WDW			;oops! put normal defaults onto history then
			  BUFFER-HISTORY
			  *ZMACS-BUFFER-HISTORY*))
	  (WITH-SPECIALS SELF			;So we get the right 2*style*
0	    (SET-WINDOW-BUFFER WDW		;now, choose something else reasonable
			       (CAR (WINDOW-BUFFER-HISTORY WDW)))))))))

(DEFMETHOD (FLUSH-WINDOW-BUFFER-HISTORIES ZMACS-EDITOR :AFTER) (BUFFER)
  (WHEN (EQ BUFFER *INTERVAL*)
    (WITH-SPECIALS SELF
      ;; We've already fixed up the window, now fix up everything else.
      (MAKE-BUFFER-CURRENT (WINDOW-INTERVAL *WINDOW*)))))


(DEFWHOPPER (FLUSH-WINDOW-BUFFER-HISTORIES EDITOR) (BUFFER)
  (WITHOUT-INTERRUPTS				;Make up for lack of interlocking on a buffer.
    (CONTINUE-WHOPPER BUFFER)))

(DEFCOM	COM-APPEND-TO-BUFFER
	"Copies the region (or definition) to a buffer, appending by default.
It prompts for the name of a destination buffer using the minibuffer.  The
buffer is created if it does not already exist.  It normally appends to the
buffer, leaving point after the insertion.  With a numeric argument, it
prepends the region to the buffer, leaving point before the insertion.  The
buffer is modified but not selected.  " ()
  (DEFINITION-REGION-BPS (BP1 BP2 DEFINITION-NAME)
    (LET ((POINT) (MARK)
	  (BUFFER (READ-BUFFER-NAME
		    (FORMAT NIL "~A ~A to buffer"
		      (IF *NUMERIC-ARG-P* "Prepend" "Append") DEFINITION-NAME)
		    NIL T)))
      (COND ((EQ BUFFER *INTERVAL*)
	     (BARF "That is the current buffer.")))
      ;; Try to find a window pointing to this buffer and use its point and mark
      (DO ((WL *WINDOW-LIST* (CDR WL))
	   (W))
	  ((NULL WL)
	   (SETQ POINT (BUFFER-SAVED-POINT BUFFER)
		 MARK (BUFFER-SAVED-MARK BUFFER)))
	(COND ((EQ (WINDOW-INTERVAL (SETQ W (CAR WL))) BUFFER)
	       (SETQ POINT (WINDOW-POINT W) MARK (WINDOW-MARK W))
	       (RETURN NIL)))) 
      ;; this is innefficient, but at least works.
      (LET ((SOURCE (OPEN-INTERVAL-STREAM BP1 BP2 T))
	    (DESTINATION (OPEN-INTERVAL-STREAM POINT)))
	(STREAM-COPY-UNTIL-EOF SOURCE DESTINATION)
	(MOVE-BP MARK (SEND DESTINATION :READ-BP)))
      (OR *NUMERIC-ARG-P* (SWAP-BPS MARK POINT))
      (MUST-REDISPLAY-OTHER-WINDOWS BUFFER *WINDOW* DIS-TEXT)))
  DIS-NONE)

;;; --- what to do about this in version control?
(DEFCOM COM-INSERT-BUFFER "Inserts the specified buffer at point.
It prompts in the minibuffer for the name of the buffer to insert; the
default is the most recent buffer.
It leaves point after the insertion by default.
With a numeric argument, it leaves point before the insertion.  " ()
  (LET ((BUFFER (READ-BUFFER-NAME "Insert buffer" :OTHER)))
    (WHEN (EQ BUFFER *INTERVAL*)
      (BARF "Can't insert a buffer into itself."))
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
      (WITH-INTERVAL-READ-LOCKED (BUFFER)
	(MOVE-MARK (INSERT-INTERVAL (POINT) BUFFER))))
    (OR *NUMERIC-ARG-P* (SWAP-POINT-AND-MARK)))
  DIS-TEXT)

(DEFCOM COM-SET-DEFAULT-FILE-NAME "Changes the default filename for most file commands." ()
  (ACCEPT-DEFAULTED-PATHNAME "Set default file name" (PATHNAME-DEFAULTS))
  DIS-NONE)

(DEFCOM COM-SET-VISITED-FILE-NAME "Changes the file associated with this buffer.
You can use this to /"rename/" a file.  Remember to save the file.  " ()
  (LET ((PATHNAME (ACCEPT-DEFAULTED-PATHNAME "Set visited file name" (PATHNAME-DEFAULTS))))
    (WHEN (FIND-BUFFER-FROM-PATHNAME PATHNAME)
      (BARF "There is already a buffer with pathname ~A" PATHNAME))
    (SEND *INTERVAL* ':SET-PATHNAME-FOR-WRITE PATHNAME))
  DIS-NONE)

(DEFCOM COM-RENAME-BUFFER "Renames the current buffer.  
Changes the name of the current buffer.  Prompts for a new name in the minibuffer." ()
  (LET ((STRING (TYPEIN-LINE-HISTORY-READLINE NIL (NAMED-BUFFER-NAME *INTERVAL*) ':ERROR
						  "Rename buffer to:")))
    (CHECK-RENAME-BUFFER *INTERVAL* STRING)
    (WHEN (SEND *INTERVAL* :EDITING-FILE-P)
      (SEND *INTERVAL* ':MAKE-NON-FILE))
    (SEND *INTERVAL* ':SET-NAME STRING))
  DIS-NONE)

(DEFUN CHECK-RENAME-BUFFER (BUFFER NEW-NAME)
  (AND (NOT (STRING-EQUAL NEW-NAME (NAMED-BUFFER-NAME BUFFER)))	    ;Allow "foo" -> "FOO"
       (FIND-BUFFER-NAMED NEW-NAME)
       (BARF "There is already another buffer named ~A" NEW-NAME)))



;;; if the buffer has a name, of course use it for defaulting;
;;; if it has no name, get the default from the major mode
(DEFUN FIND-BUFFER-TYPE-FOR-DEFAULTING ()
  (LET (PATH)
    (IF (SETQ PATH (SEND *INTERVAL* ':SEND-IF-HANDLES ':DEFAULT-PATHNAME))
	(SEND PATH ':CANONICAL-TYPE)
        (CANONICAL-TYPE-FROM-MAJOR-MODE (SEND *INTERVAL* ':GET ':MAJOR-MODE)))))

;;; purpose is one of :compile, :load, :evaluate
(DEFUN FIND-DEFAULT-MAJOR-MODE-FROM-BUFFER (PURPOSE)
  (LET* ((MAJOR-MODE (SEND *INTERVAL* ':GET ':MAJOR-MODE))
	 (PURPOSE-SATISFIED
	   (SELECTQ PURPOSE
	     ((:COMPILE :LOAD) (SEND MAJOR-MODE ':COMPILATION-SUPPORTED))
	     (:EVALUATE (SEND MAJOR-MODE ':EVALUATION-SUPPORTED)))))
    (IF PURPOSE-SATISFIED
	MAJOR-MODE
        (MAJOR-MODE-FROM-KEYWORD *DEFAULT-MAJOR-MODE*))))

(DEFUN READ-MAJOR-MODE-DEFAULTED-PATHNAME (PROMPT DEFAULTS &REST OPTIONAL-ARGS)
  (LET* ((DEFAULT-TYPE (FIND-BUFFER-TYPE-FOR-DEFAULTING))
	 (PATH (LEXPR-FUNCALL 'ACCEPT-DEFAULTED-PATHNAME PROMPT DEFAULTS
			      :SPECIAL-TYPE DEFAULT-TYPE
			      OPTIONAL-ARGS)))
    (VALUES PATH (MAJOR-MODE-FROM-PATHNAME PATH))))


(DEFCOM COM-SHOW-BUFFER  "Shows the contents of a specified buffer on the typeout window.
It prompts for a buffer name using the minibuffer, offering the most
recently seen buffer as the default.  You can page through the buffer as
through most typeout window displays or you can select the buffer after
looking at part of it:

  SPACE   Pages, or (at end) clears the display and returns to the selected buffer.
  RETURN  Selects the buffer being displayed." ()
  (LET ((BUFFER (READ-BUFFER-NAME "Show buffer" (SECOND (WINDOW-BUFFER-HISTORY *WINDOW*))))
	BP CH)
    (PROMPT-LINE "Showing buffer ~A" (NAMED-BUFFER-NAME BUFFER))
    (MULTIPLE-VALUE (BP CH)
      (VIEW-BUFFER BUFFER))
    (COND ((EQL CH #\CR)
	   (SEND STANDARD-INPUT ':TYI)
	   (OR (EQ BUFFER *INTERVAL*) (MAKE-BUFFER-CURRENT BUFFER))
	   (MOVE-POINT BP)
	   DIS-TEXT)
	  (T
	   DIS-NONE))))

(DEFUN VIEW-BUFFER (BUFFER)
  (VIEW-STREAM (OPEN-INTERVAL-STREAM BUFFER)))

(DEFCOM COM-PRINT-MODIFICATIONS
	"Displays the lines in the current buffer that have changed since file was last read.
The lines are mouse-sensitive, allowing you to move to the location of a change.  
With an argument, lists since the last save instead." ()
  (DO ((LINE (BP-LINE (INTERVAL-FIRST-BP *INTERVAL*))
	     (LINE-NEXT-IN-BUFFER LINE :IGNORE-VC-DIAGRAM-LINES T))
       (LAST-LINE (BP-LINE (INTERVAL-LAST-BP *INTERVAL*)))
       (BUFFER-TICK (SEND *INTERVAL* (IF *NUMERIC-ARG-P* ':SAVE-TICK ':READ-TICK)))
       (CONTIG-P T)
       (DEFINITION-LINE NIL))
      ((NULL LINE))
    (AND (PLUSP (LINE-LENGTH LINE))
	 (SEND (SEND *INTERVAL* :MAJOR-MODE) ':QUICK-DEFINITION-LINE-P LINE)
	 (SETQ DEFINITION-LINE LINE))
    (IF ( (LINE-TICK LINE) BUFFER-TICK)	;Old line?
	(SETQ CONTIG-P NIL)			;Yes, remember to type ... next time
	(OR CONTIG-P (SEND *TYPEOUT-WINDOW* ':LINE-OUT "..."))
	(SETQ CONTIG-P T)
	(COND (DEFINITION-LINE
	       (AND (NEQ DEFINITION-LINE LINE)
		    (SEND *TYPEOUT-WINDOW* ':LINE-OUT DEFINITION-LINE))
	       (SETQ DEFINITION-LINE NIL)))
	(PRESENT-LINE LINE *TYPEOUT-WINDOW*))
    (WHEN (EQ LINE LAST-LINE)
      (RETURN)))
  (SEND *TYPEOUT-WINDOW* ':LINE-OUT "Done.")
  DIS-NONE)

(DEFUN PRESENT-LINE (BP STREAM)
  (UNLESS (LISTP BP)		;Allow argument to be a line
    (SETQ BP (CREATE-BP BP 0)))
  (DW:WITH-OUTPUT-AS-PRESENTATION (:STREAM STREAM
				   :OBJECT BP
				   :TYPE 'BP)
    ;;--- Maybe someday this will handle diagrams by making them draw themselves,
    ;;--- and will make sure that blank lines don't lose their sensitivity through
    ;;--- having a box of zero width.  But if you do that, maybe sure you don't
    ;;--- break Source Compare Merge, which sends each line through here.  Also,
    ;;--- watch out for dynamic-window bugs when drawing the diagrams.
    (SEND STREAM :LINE-OUT (BP-LINE BP))))
