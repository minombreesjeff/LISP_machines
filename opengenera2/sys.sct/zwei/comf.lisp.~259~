;;; Zwei commands, see ZWEI;COMA for comments -*- Syntax: Zetalisp; Base: 8;Mode: LISP; Package: ZWEI-*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(DEFCOM COM-FROB-LISP-CONDITIONAL
"Change CONDs to ANDs, ORs, IFs, WHENs, or UNLESS's, and vice versa.
The innermost conditional expression enclosing Point is changed. 

When changing to COND, point is left in such a place that LINE will add another
clause to this condition, and M-) will add another condition.
When changing AND or OR to COND an argument specifies the number of
clauses that are left in the consequent; the default is 1, i.e. all
clauses but the last are assumed to be for value, and to belong in the
antecedent.

When changing from COND, a numeric argument forces WHEN or UNLESS to
be used even in cases where AND or OR would do.

Note that the exact semantics of the code are not always preserved; for
example when using OR and depending on the value of the code as well as
the effect.

You may use m-X Undo to put the expression back the way it was." ()
  (ATOM-WORD-SYNTAX-BIND
    (LET ((POINT (POINT))
	  (FIXBP1 NIL) FIXBP2)
     (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
       (UNWIND-PROTECT
	   (LET (COND-BP COND-TYPE UPCASE-P BP START-BP END-BP DEPTH)
	     (MULTIPLE-VALUE (COND-BP COND-TYPE)		;Locate word that starts form
	       (FIND-CONTAINING-ATOM POINT '(COND AND OR IF WHEN UNLESS)))
	     (OR COND-BP (BARF "Point is not inside a COND, AND, OR, IF, WHEN, or UNLESS"))
	     (SETQ UPCASE-P (UPPER-CASE-P (BP-CHAR COND-BP)))	;Remember if have to lowercase
	     (SETQ START-BP (FORWARD-LIST COND-BP -1 NIL 1))	;Open paren that starts exp
	     (LET ((START-DEFINITION-BP (FORWARD-DEFINITION POINT -1 T))
		   (END-DEFINITION-BP (FORWARD-DEFINITION POINT 1 T)))
	       ;; Parse it all once, then don't even bother checking.
	       (LISP-PARSE-FROM-DEFINITION (BP-LINE END-DEFINITION-BP) START-DEFINITION-BP)
	       ;; Count how many levels down the next defun is from the start of this one.
	       (LET ((*LISP-PARSE-PREPARSED-FLAG* T))
		 (DO ((I -1 (1+ I))
		      (BP3 END-DEFINITION-BP (FORWARD-SEXP BP3 -1 NIL 1 START-DEFINITION-BP)))
		     ((NULL BP3) (SETQ DEPTH I))))
	       ;; Insert that many ")"'s at the putative end, so everything is balanced.
	       ;; These ")"'s lie between FIXBP1 and FIXBP2.  We use that to delete them later.
	       (COND ((> DEPTH 0)
		      (LET ((BP (LIKELY-UNBALANCED-POINT START-BP END-DEFINITION-BP)))
			(SETQ FIXBP1 (COPY-BP BP ':NORMAL)
			      FIXBP2 (COPY-BP BP ':MOVES)))
		      (SETQ END-BP FIXBP1))
		     (T
		      (SETQ END-BP (FORWARD-LIST START-BP)))))
	     (WITH-UNDO-SAVE ("Frob Lisp Conditional" START-BP END-BP T)
	       (WHEN FIXBP1
		 (INSERT FIXBP2 #\CR)
		 (DOTIMES (IGNORE DEPTH) (INSERT FIXBP2 #/)))
		 (INSERT FIXBP2 #\CR))
	       (COND ((EQ COND-TYPE 'COND)	;Changing COND to AND, OR, IF, WHEN, or UNLESS
		      (LET ((N (COUNT-LIST-ELEMENTS START-BP)))
			(AND (NULL N) (BARF "Parentheses don't balance"))
			(AND (> N 3) (BARF "Too many clauses to make an IF"))
			(WHEN (= N 3)		;With two clauses, it's probably an IF
			  (LET ((BP1 (FORWARD-SEXP COND-BP 2)) BP2 BP3)
			    (SETQ BP2 (FORWARD-LIST BP1 1 NIL -1 T)
				  BP3 (AND BP2 (FORWARD-WORD BP2)))
			    (OR BP3 (BARF "Missing parentheses"))
			    (OR (AND (EQ (BP-LINE BP2) (BP-LINE BP3))
				     (STRING-EQUAL (BP-LINE BP2) "T" (BP-INDEX BP2) 0
						   (BP-INDEX BP3)))
				(BARF "Too many clauses to make an IF"))
			    (SETQ BP1 (FORWARD-CHAR (BACKWARD-OVER '(#\CR #\TAB #\SP) BP1) -1))
			    (SETQ N (COUNT-LIST-ELEMENTS (FORWARD-SEXP COND-BP)))
			    (SETQ COND-TYPE	;Depends on number of "then" forms
				  (SELECTQ N	;which is 1- N since N includes predicate
				    (2 'IF)
				    (1 'OR)
				    (OTHERWISE (BARF "Too many /"then/" forms to make an IF ~
						       without using PROGN"))))
			    (DELETE-INTERVAL BP1 BP3 T)	;Delete ") (T"
			    (WHEN (EQ COND-TYPE 'IF)	;Always put ELSE on a separate line
			      (WHEN (EQ (BP-LINE BP1)
					(BP-LINE (FORWARD-LIST BP1 1 NIL -1 T)))
				(INSERT BP1 #\CR))))))
		      (DELETE-INTERVAL COND-BP (FORWARD-WORD COND-BP) T)
		      (SETQ BP (FORWARD-OVER *BLANKS* COND-BP))
		      (LET ((BP1 (FORWARD-LIST BP)))	;Remove a level of parens
			(DELETE-INTERVAL (FORWARD-CHAR BP1 -1) BP1 T))
		      (DELETE-INTERVAL BP (FORWARD-CHAR BP) T)
		      (WHEN (EQ COND-TYPE 'COND)	;Still not determined
			(SETQ COND-TYPE 'AND)
			;; Check for (COND ((NOT ...)))
			(LET ((BP1 (FORWARD-LIST COND-BP 1 NIL -1 T)))
			  (WHEN BP1
			    (LET ((BP2 (FORWARD-WORD COND-BP 1 T)))
			      (LET ((WORD (STRING-INTERVAL BP1 BP2)))
				(WHEN (OR (STRING-EQUAL WORD "NULL") (STRING-EQUAL WORD "NOT"))
				  (SETQ BP1 (FORWARD-LIST BP1 -1 NIL 1))
				  (LET ((BP3 (FORWARD-LIST BP1)))
				    (DELETE-INTERVAL (FORWARD-CHAR BP3 -1) BP3 T))
				  (DELETE-INTERVAL BP1 (FORWARD-OVER *BLANKS* BP2) T)
				  (SETQ COND-TYPE 'OR)))))))
		      (UNLESS (EQ COND-TYPE 'IF)
			(COND ((OR *NUMERIC-ARG-P*
				   (> (COUNT-LIST-ELEMENTS START-BP) 2))
			       ;; If there is more than one clause in the consequent, or if
			       ;; user said to, use WHEN or UNLESS rather than AND or OR.
			       (SETQ COND-TYPE (IF (EQ COND-TYPE 'AND) 'WHEN 'UNLESS)))
			      ((CHAR-EQUAL (BP-CHAR BP) #/()
			       (LET* ((BP2 (FORWARD-WORD BP))
				      (BP3 (FORWARD-WORD BP2 -1)))
				 (WHEN (STRING-EQUAL (BP-LINE BP3) COND-TYPE (BP-INDEX BP3) 0
						     (BP-INDEX BP2))
				   ;; Fix (AND (AND A B C) D)
				   (SETQ BP3 (FORWARD-LIST BP))
				   (DELETE-INTERVAL (FORWARD-CHAR BP3 -1) BP3 T)
				   (DELETE-INTERVAL BP (FORWARD-OVER *BLANKS* BP2) T))))))
		      (INSERT COND-BP COND-TYPE))
		     (T				;Changing to COND
		      (LET ((BP1 (FORWARD-LIST (FORWARD-LIST START-BP) -1 NIL -1 T)))
			(INSERT BP1 #/))	;BP1 is just before the closing parenthesis
			(DO ((N -1 (1+ N))
			     (BP2 BP1 (FORWARD-SEXP BP2 -1))
			     (ARG (- 1 *NUMERIC-ARG*)))
			    ((BP-= BP2 COND-BP)	;N is the number of subforms
			     (COND ((OR (MEMQ COND-TYPE '(IF WHEN UNLESS))
					(MINUSP (+ ARG N -3)))
				    ;; Only one form in the antecedent
				    (DELETE-INTERVAL COND-BP (FORWARD-WORD COND-BP) T)
				    (SETQ BP (FORWARD-OVER *WHITESPACE-CHARS*
							   (INSERT COND-BP "COND")))
				    (INSERT-MOVING BP #/()
				    (COND ((AND (EQ COND-TYPE 'IF) (> N 2))
					   (SETQ BP (FORWARD-SEXP BP 2))
					   (INSERT-MOVING BP (IF UPCASE-P ")
 (T" ")
 (t")))))
			      (T			;More than one form in the antecedent
			       (SETQ BP (INSERT COND-BP "COND (("))
			       (LET ((BP1 (IF (PLUSP ARG) (FORWARD-LIST BP 1 NIL 1)
					      (FORWARD-SEXP BP (+ ARG N)))))
				 (INSERT BP1 #/)))
			       ;; Put BP at left paren that starts antecedent
			       (SETQ BP (FORWARD-CHAR BP -1))))
			(WHEN (MEMQ COND-TYPE '(OR UNLESS))
			  ;; Reverse sense of predicate
			  (INSERT (FORWARD-SEXP BP) #/))
			  (INSERT-MOVING BP (IF UPCASE-P "(NOT " "(not "))))))))
	  (OR UPCASE-P (DOWNCASE-INTERVAL COND-BP (FORWARD-WORD COND-BP) T))
	  (INDENT-INTERVAL-FOR-LISP START-BP (FORWARD-LIST START-BP) T)	;Regrind changed stuff
	  (MOVE-POINT (FORWARD-LIST (FORWARD-LIST START-BP) -1 NIL -1 T))))
      (WHEN FIXBP1
	(DELETE-INTERVAL FIXBP1 FIXBP2 T)
	(FLUSH-BP FIXBP1)
	(FLUSH-BP FIXBP2))))))
  DIS-TEXT)

;;; Find the containing member of set
(DEFUN FIND-CONTAINING-ATOM (BP SET)
  (DO ((BP BP)
       (BP1) (BP2) (TEM))
      (NIL)
    (OR (SETQ BP (FORWARD-LIST BP -1 NIL 1))
	(RETURN NIL))
    (SETQ BP1 (FORWARD-LIST BP 1 NIL -1 T)
	  BP2 (FORWARD-ATOM BP1))
    (AND (SETQ TEM (MEM #'STRING-EQUAL (STRING-INTERVAL BP1 BP2 T) SET))
	 (RETURN (VALUES BP1 (CAR TEM))))))

(DEFUN COUNT-LIST-ELEMENTS (BP &AUX END-BP)
  (SETQ END-BP (FORWARD-SEXP BP))
  (DO ((BP (FORWARD-LIST BP 1 NIL -1 T) (FORWARD-SEXP BP))
       (I -1 (1+ I)))
      (NIL)
    (AND (NULL BP) (RETURN NIL))
    (AND (BP-= BP END-BP) (RETURN I))))

;;; This tries to find someplace that looks like it probably doesn't have enough parens
;;; It takes the first place that has a lesser indentation level than the given BP.
(DEFUN LIKELY-UNBALANCED-POINT (BP LIMIT-BP)
  (LOOP WITH LINE = (BP-LINE BP)
	AND IND = (BP-INDENTATION BP)
	AND LIMIT-LINE = (BP-LINE LIMIT-BP)
	WITH OLINE = LINE
	UNTIL (EQ LINE LIMIT-LINE)
	DO (SETQ LINE (LINE-NEXT-IN-BUFFER LINE))
	WHEN (NOT (MEMQ (LINE-TYPE LINE) '(:COMMENT :BLANK)))
	DO (AND ( (LINE-INDENTATION LINE) IND)
		(RETURN (END-OF-LINE OLINE)))
	   (SETQ OLINE LINE)
	FINALLY (RETURN LIMIT-BP)))

(DEFCOM COM-FROB-DO "Interchange old and new style DO's" ()
  (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
    (ATOM-WORD-SYNTAX-BIND
     (LET (DO-BP DO-TYPE
	  BP BP1 BP2 BP3)
      (MULTIPLE-VALUE (DO-BP DO-TYPE)
	(FIND-CONTAINING-ATOM (POINT) '(DO DOTIMES DOLIST)))
      (OR DO-BP (BARF))
      (SETQ BP (FORWARD-OVER *WHITESPACE-CHARS* (FORWARD-WORD DO-BP)))
      (COND ((AND (EQ DO-TYPE 'DO)
		  (= (LIST-SYNTAX (BP-CHAR BP)) LIST-OPEN))	;New style
	     (OR (= (COUNT-LIST-ELEMENTS BP) 1)
		 (BARF "Too many DO variables"))
	     (OR (SETQ BP1 (FORWARD-SEXP BP)) (BARF))
	     (OR (= (COUNT-LIST-ELEMENTS BP1) 1)
		 (BARF "Cannot have ending form"))
	     (OR (SETQ BP2 (FORWARD-SEXP BP1)) (BARF))
	     (SETQ BP3 (FORWARD-SEXP BP2 -1))
	     (WITH-UNDO-SAVE ("conversion to old-style DO" DO-BP BP2 T)
	       (DELETE-INTERVAL (FORWARD-LIST BP2 -1 NIL -1 T) BP2 T)
	       (MOVE-POINT (DELETE-INTERVAL (FORWARD-LIST BP1 -1 NIL -2 T)
					    (FORWARD-LIST BP3 1 NIL -1 T) T))
	       (INSERT-MOVING-POINT #\SP)
	       (DELETE-INTERVAL BP (FORWARD-LIST BP 1 NIL -2 T) T)))
	    (T					;Old style or special
	     (WITH-UNDO-SAVE ("conversion to new-style DO"
			      DO-BP (OR (FORWARD-SEXP BP (IF (EQ DO-TYPE 'DO) 4 1))
					(BARF "Parentheses don't balance"))
			      T)
	       (COND ((NEQ DO-TYPE 'DO)
		      (OR (SETQ BP1 (FORWARD-LIST BP 1 NIL -1 T)) (BARF))
		      (SETQ BP2 (FORWARD-SEXP BP1))
		      (LET ((VARNAME (STRING-INTERVAL BP1 BP2 T)))
			(DELETE-INTERVAL BP BP1 T)
			(COND ((EQ DO-TYPE 'DOTIMES)
			       (SETQ BP2 (FORWARD-SEXP BP))
			       (INSERT-MOVING BP2 (IN-CURRENT-STYLE " 0 (1+ "))
			       (INSERT-MOVING BP2 VARNAME)
			       (INSERT-MOVING BP2 (IN-CURRENT-STYLE ") ( ")))
			      ((EQ DO-TYPE 'DOLIST)
			       (SETQ BP2 (FORWARD-SEXP BP 2))
			       (INSERT-MOVING BP2 (IN-CURRENT-STYLE " (CDR "))
			       (INSERT-MOVING BP2 VARNAME)
			       (INSERT-MOVING BP2 (IN-CURRENT-STYLE ") (NULL "))))
			(INSERT-MOVING BP2 VARNAME))
		      (DELETE-INTERVAL DO-BP (FORWARD-WORD DO-BP) T)
		      (SETQ BP (FORWARD-OVER *WHITESPACE-CHARS*
					     (INSERT DO-BP (IN-CURRENT-STYLE "DO"))))))
	       (OR (SETQ BP1 (FORWARD-SEXP BP 3)) (BARF))
	       (DELETE-AROUND *WHITESPACE-CHARS* BP1)
	       (MOVE-POINT (INSERT-MOVING BP1 (IN-CURRENT-STYLE #/))))
	       (INSERT-MOVING BP1 (IN-CURRENT-STYLE ")
     ("))
	       (INSERT BP (IN-CURRENT-STYLE "(("))
	       (INSERT (FORWARD-SEXP BP1) (IN-CURRENT-STYLE #/)))
	       (INDENT-INTERVAL-FOR-LISP BP BP1 T)))))))
  DIS-TEXT)

(DEFCOM COM-QUERY-REPLACE-LET-BINDING "Replace variable of LET with its value.
Point must be after or within the binding to be modified." ()
  (ATOM-WORD-SYNTAX-BIND
    (LET ((LET-BP) (BINDING-BP) (BP1) (BP2) (FROM) (TO))
      (OR (SETQ LET-BP (FIND-CONTAINING-ATOM (POINT) '(LET))) (BARF))
      (DO ((BP (FORWARD-LIST LET-BP 1 NIL -1 T) NBP)
	   (NBP))
	  (NIL)
	(OR (SETQ NBP (FORWARD-SEXP BP 1 NIL 0 NIL NIL T)) (BARF))
	(OR (BP-< NBP (POINT)) (RETURN (SETQ BINDING-BP BP))))
      (SETQ BP1 (FORWARD-LIST BINDING-BP 1 NIL -1 T)
	    BP2 (FORWARD-SEXP BP1)
	    FROM (STRING-INTERVAL BP1 BP2 T))
      (SETQ BP1 (FORWARD-OVER *WHITESPACE-CHARS* BP2)
	    BP2 (FORWARD-SEXP BP1)
	    TO (STRING-INTERVAL BP1 BP2 T))
      (SETQ BP1 (FORWARD-SEXP LET-BP 2)
	    BP2 (FORWARD-SEXP BP1 1 NIL 1))
      (OR *NUMERIC-ARG-P* (PSETQ FROM TO TO FROM))
      (LET ((*INTERVAL* (CREATE-INTERVAL BP1 BP2 T)))
	(QUERY-REPLACE FROM TO T)
	(TYPEIN-LINE "Query replace done.")
	DIS-TEXT))))

(DEFCOM COM-QUERY-REPLACE-LAST-KILL "Replace top of kill ring with region." ()
  (REGION (START END :EMPTY-OK T :ENFORCE-SINGLE-SECTION T)
    (LET ((OLD (STRING-INTERVAL (SEND *KILL-HISTORY* ':ELEMENT 0)))
	  (NEW (STRING-INTERVAL START END T)))
      (WHEN *KILL-INTERVAL-SMARTS*
	(SETQ OLD (STRING-TRIM *BLANKS* OLD)
	      NEW (STRING-TRIM *BLANKS* NEW)))
      (SETF (WINDOW-MARK-P *WINDOW*) NIL)	;Flush highlighting before moving point
      (QUERY-REPLACE OLD NEW)
      (TYPEIN-LINE "Query replace done.")
      DIS-TEXT)))

(DEFCOM COM-JUST-ONE-SPACE "Replace all whitespace around the point with one space.
With a numeric argument, replace it with that number of spaces." ()
  (WHEN (MINUSP *NUMERIC-ARG*) (BARF "The number of spaces to retain must be non-negative."))
  (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
    (DELETE-AROUND *BLANKS* (POINT))
    (DOTIMES (IGNORE *NUMERIC-ARG*)
      (INSERT-MOVING-POINT #\SP)))
  DIS-TEXT)

(DEFCOM COM-CANONICALIZE-WHITESPACE "Try to fixup wrong spacing heuristically.
If given an argument, or called just after a yank type command, operates
at the mark, else at point." ()
  (LET ((BP (IF (OR *NUMERIC-ARG-P* (EQ *LAST-COMMAND-TYPE* 'YANK)) (MARK) (POINT)))
	BP1 CH1 CH2 SYN1 SYN2)
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK BP))
      (SETQ BP (BACKWARD-OVER *BLANKS* BP)
	    BP1 (FORWARD-OVER *BLANKS* BP)
	    CH1 (BP-CHAR (OR (FORWARD-CHAR BP -1) (BARF)))
	    CH2 (BP-CHAR BP1)
	    SYN1 (LIST-SYNTAX CH1)
	    SYN2 (LIST-SYNTAX CH2))
      (COND ((OR (CHAR-EQUAL CH2 #\CR)		;If at the end of the line,
		 (MULTIPLE-VALUE-BIND (STRING SLASH COMMENT)
		     (LISP-BP-SYNTACTIC-CONTEXT BP)
		   (OR STRING SLASH COMMENT))))	;or any funny syntax, leave it alone
	    ((NOT (CHAR-EQUAL CH1 #\CR))	;If not at beginning of line,
	     (DELETE-INTERVAL BP BP1 T)		;flush whitespace, and
	     (AND ( SYN1 LIST-OPEN) ( SYN1 LIST-SINGLE-QUOTE)
		  ( SYN2 LIST-CLOSE)
		  (INSERT BP (IN-CURRENT-STYLE #\SP))))	;leave zero or one space in its place
	    ((CHAR-NOT-EQUAL CH2 #/()		;If not start of defun
	     (INDENT-INTERVAL-FOR-LISP BP (BEG-LINE BP 1 T) T NIL T))	;run tab
	    ((DO ((LINE (LINE-PREVIOUS (BP-LINE BP)) (LINE-PREVIOUS LINE))
		  (OLINE (BP-LINE BP) LINE)	;Flush blank lines, and
		  (TYPE))			;unless previous non-blank is a comment
		 (NIL)
	       (SETQ TYPE (AND LINE (LINE-TYPE LINE)))
	       (COND ((NEQ TYPE ':BLANK)
		      (DELETE-INTERVAL (CREATE-BP OLINE 0) BP T)
		      (RETURN (NEQ TYPE ':COMMENT)))))
	     (INSERT BP #\CR)))))		;leave just one in their place
  DIS-TEXT)

(DEFCOM COM-FIND-UNBALANCED-PARENTHESES "Finds parenthesis mismatch error in buffer.
Reads through all of the current buffer and try to find places in which the
parentheses do not balance.  Positions point to possible trouble-spots, printing
out a message that says what the trouble appears to be.  This command only finds
one such error; if you suspect more errors, run it again." ()
  (FIND-UNBALANCED-PARENTHESES *INTERVAL*)
  DIS-BPS)

(DEFMETHOD (FIND-UNBALANCED-PARENTHESES ZWEI:TOP-LEVEL-NODE) (&REST IGNORE)
  (LET ((BEG-BP (INTERVAL-FIRST-BP *INTERVAL*))
	(END-BP (INTERVAL-LAST-BP *INTERVAL*))
	(POINT (POINT)))
    (MULTIPLE-VALUE-BIND (BP LEVEL STATE)
	(FORWARD-SEXP BEG-BP 1 NIL 1)
      (COND ((EQ STATE 'STRING)			;Buffer ends inside a string
	     (POINT-PDL-PUSH POINT *WINDOW*)
	     (MOVE-POINT (OR (FORWARD-UP-STRING END-BP -1) END-BP))
	     (TYPEIN-LINE "Probably no closing quote for this string."))
	    ((AND (NULL BP) (= LEVEL 1))	;Normal expected end
	     (TYPEIN-LINE "All parentheses appear balanced."))
	    ((NULL BP)				;Too many left parentheses
	     (OR (SETQ BP (FORWARD-SEXP END-BP -1 NIL 1))
		 (BARF "Cannot find unbalanced parenthesis"))
	     (POINT-PDL-PUSH POINT *WINDOW*)
	     (MOVE-POINT BP)
	     (TYPEIN-LINE "Probably no right-parenthesis for this left-parenthesis."))
	    (T					;Stopped at right parenthesis 
	     (POINT-PDL-PUSH POINT *WINDOW*)
	     (MOVE-POINT BP)
	     (TYPEIN-LINE "Probably an extra right-parenthesis here."))))))

(DEFCOM COM-DECLARE-SPECIAL "Add the nth previous word to the last special declaration" ()
  (ATOM-WORD-SYNTAX-BIND
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
      (LET (WORD)
	(LET ((BP1 (FORWARD-WORD (POINT) (- *NUMERIC-ARG*)))
	      BP2)
	  (OR BP1 (BARF))
	  (SETQ BP2 (FORWARD-WORD BP1 1))
	  (OR BP2 (BARF))
	  (SETQ WORD (STRING-INTERVAL BP1 BP2 T)))
	(LET ((BP (DO-NAMED DECLARES
			    ((LINE (BP-LINE (POINT)) (LINE-PREVIOUS-IN-BUFFER LINE))
			     (LIMIT-LINE (BP-LINE (INTERVAL-FIRST-BP *INTERVAL*))))
			    (NIL)
		    (AND (STRING-EQUAL "(DECLARE " LINE 0 0 9 9)
			 ;;Found a (DECLARE ...), look for SPECIAL in the CARs of the elements
			 (DO ((BP1 (CREATE-BP LINE 9) (FORWARD-SEXP BP1))
			      (BP2)
			      (BP3))
			     ((NULL BP1))
			   (OR (SETQ BP2 (FORWARD-LIST BP1 1 NIL 1 T))
			       (RETURN NIL))
			   (OR (SETQ BP3 (FORWARD-WORD BP2)) (RETURN NIL))
			   (AND (EQ (BP-LINE BP2) (BP-LINE BP3))
				(STRING-EQUAL "SPECIAL" (BP-LINE BP2) 0 (BP-INDEX BP2) 7
					      (BP-INDEX BP3))
				(SETQ BP2 (FORWARD-LIST BP1))	;Found one
				(RETURN-FROM DECLARES (FORWARD-CHAR BP2 -1)))))
		    ;;If there isnt a special declaration, make one at the start of the file
		    (AND (EQ LINE LIMIT-LINE)
			 (RETURN (FORWARD-CHAR (INSERT
						 (SKIP-OVER-BLANK-LINES-AND-COMMENTS
						   (INTERVAL-FIRST-BP *INTERVAL*) T)
						 "(DECLARE (SPECIAL))

")
					       -3))))))
	  ;;Now put it in and try not to overflow the line
	  (WITH-BP (PT (POINT) ':MOVES)		;Preserve point
	    (MOVE-POINT BP)
	    (INSERT-MOVING-POINT (STRING-APPEND #\SP WORD))
	    (AUTO-FILL-HOOK #\SP)
	    (COND ((END-LINE-P (POINT))
		   (MOVE-POINT (END-LINE (POINT) 1))
		   (INSERT (DELETE-BACKWARD-OVER *BLANKS* (POINT)) #\CR)
		   (COM-INDENT-FOR-LISP)))
	    (MOVE-POINT PT))))))
  DIS-TEXT)

;;; Pattern finding command
(DEFVAR *LAST-PATTERN* NIL)
(DEFVAR *LAST-PATTERN-BP* NIL)
(DEFVAR *LAST-PATTERN-RESTART-LIST* NIL)

(DEFCOM COM-FIND-PATTERN "Move to next occurrence of the given pattern.
The pattern must be a list, ** matches any one thing, ... any number of things.
A numeric argument repeats the last search." ()
  (LET (FORM RESTART BP)
    (COND (*NUMERIC-ARG-P*
	   (SETQ FORM (OR *LAST-PATTERN* (BARF "No previous pattern")))
	   (TYPEIN-LINE "Finding ~S" FORM)
	   (AND (BP-= (POINT) *LAST-PATTERN-BP*) (SETQ RESTART *LAST-PATTERN-RESTART-LIST*)))
	  (T
	   (SETQ FORM (TYPEIN-LINE-ACCEPT 'SYS:EXPRESSION
					   :DEFAULT *LAST-PATTERN*
					   :PROMPT "Pattern to search for"))
	   (SETQ FORM (SUBLIS (LIST (CONS (INTERN "...") ':...)
				    (CONS (INTERN "**") ':**))
			      FORM))))
    (MULTIPLE-VALUE (BP RESTART) (FIND-PATTERN (POINT) FORM RESTART))
    (OR BP (BARF "Not found"))
    (MAYBE-PUSH-POINT BP)
    (MOVE-POINT BP)
    (SETQ *LAST-PATTERN* FORM *LAST-PATTERN-BP* BP *LAST-PATTERN-RESTART-LIST* RESTART))
  DIS-BPS)

;;; Attempt to find an instance of THING after BP, return a new BP if successful
(DEFUN FIND-PATTERN (BP PATTERN &OPTIONAL RESTART-LIST)
  (DO-NAMED FIND-PATTERN
	    ((BP1 (FORWARD-DEFINITION BP -1 T) (FORWARD-DEFINITION BP2))
	     (BP2)
	     (STREAM (OPEN-INTERVAL-STREAM *INTERVAL*))
	     (FORM)
	     (SI:XR-MAINTAIN-CORRESPONDENCE T)
	     (SI:XR-CORRESPONDENCES NIL NIL)
	     (SI:READ-PRESERVE-DELIMITERS NIL)
	     (RESTART-LIST RESTART-LIST NIL)
	     (PLIST)
	     (TEM))
	    ((NULL BP1) NIL)
    (SETQ PLIST (LOCF (LINE-CONTENTS-PLIST (BP-LINE BP1))))
    (SETQ BP2 (FORWARD-SEXP BP1))		;Find the end of this defun
    ;; Now get the form and correspondence for this defun, using previous if there
    (COND (BP2
	   (COND ((AND (SETQ TEM (GET PLIST 'CORRESPONDENCE))
		       (COND ((> (SECOND TEM) (INTERVAL-REAL-TICK BP1 BP2 T))
			      (SETQ FORM (FIRST TEM) SI:XR-CORRESPONDENCES (THIRD TEM))
			      T)
			     (T
			      (SI:NREMPROP PLIST 'CORRESPONDENCE)
			      NIL))))
		 (T
		  (SEND STREAM :SET-BP BP1)
		  (SETQ FORM (LET ((SI:*SUPPRESS-READ-EVAL* T))
			       (READ STREAM)))
		  (PUTPROP PLIST (LIST FORM (TICK) SI:XR-CORRESPONDENCES) 'CORRESPONDENCE)))
	   (AND RESTART-LIST (SETQ FORM (CAR RESTART-LIST) RESTART-LIST (CDR RESTART-LIST)))
	   (DO ((FORM FORM (CAR RESTART-LIST))
		(RESTART-LIST RESTART-LIST (CDR RESTART-LIST))
		(FOUND))
	       (NIL)
	     (MULTIPLE-VALUE (FOUND RESTART-LIST)
	       (FIND PATTERN FORM RESTART-LIST))
	     (UNLESS FOUND (RETURN NIL))
	     (LET ((BP3 BP1))
	       ;;--- Doesn't leave POINT in the right place for a lone atom
	       (WHEN (OR (ATOM FOUND)
			 (AND (SETQ BP3 (COMPILER:FIND-FORM-IN-CORRESPONDENCES
					  FOUND SI:XR-CORRESPONDENCES NIL))
			      (BP-< BP BP3)))
		 (RETURN-FROM FIND-PATTERN (VALUES BP3 RESTART-LIST))))))
	  (T					;Look forward for next defun
	   (SETQ BP2 BP1)))))

;;; Attempt to find an instance of THING in LIST
(DEFUN FIND (THING LIST &OPTIONAL RESTART-LIST &AUX VAL)
  (COND	((AND RESTART-LIST (MULTIPLE-VALUE (VAL RESTART-LIST)
			     (FIND THING (CAR RESTART-LIST) (CDR RESTART-LIST))))
	 (PUSH LIST RESTART-LIST))
	((MATCH THING LIST) (SETQ VAL LIST RESTART-LIST NIL))
	((ATOM LIST) (SETQ VAL NIL RESTART-LIST NIL))
	(T
	 (DO ((LIST LIST (CDR LIST)))
	     ((ATOM LIST) (SETQ VAL NIL RESTART-LIST NIL))
	   (MULTIPLE-VALUE (VAL RESTART-LIST) (FIND THING (CAR LIST)))
	   (COND (VAL
		  (PUSH (CDR LIST) RESTART-LIST)
		  (RETURN NIL))))))
  (VALUES VAL RESTART-LIST))

;;; Simple minded pattern matcher
;;; ** matches an arbitrary frob, ... an arbitrary number (possibly 0) of frobs
(DEFUN MATCH (A B)
  (DO ((A A (CDR A))
       (B B (CDR B))
       (VAL))
      (NIL)
    (COND ((EQ A B) (RETURN-FROM MATCH T))
	  ((EQ A ':...) (RETURN-FROM MATCH 'CDR))
	  ((EQ A ':**) (RETURN-FROM MATCH T))
	  ((AND (LISTP A) (EQ (CAR A) ':**MATCH-OR**))
	   (LOOP FOR POSSIBILITY IN (CDR A)
		 WHEN (MATCH POSSIBILITY B) DO (RETURN-FROM MATCH T)
		 FINALLY (RETURN-FROM MATCH NIL)))	   
	  ;; The datatype test below fails for DTP-NIL versus DTP-LIST.
	  ;; However, a :... as the last item in a pattern will result in
	  ;; just that. --- (note that :... more than once in a row will fail.)
	  ((AND (EQUAL A `(:...)) (NULL B))
	   (RETURN-FROM MATCH T))
	  ((NOT (= (%DATA-TYPE A) (%DATA-TYPE B))) (RETURN NIL))
	  ((NUMBERP A) (RETURN (= A B)))
	  ((ARRAYP A) (RETURN (AND (STRINGP A) (STRINGP B) (STRING-EQUAL A B))))
	  ((NLISTP A) (RETURN NIL))
	  ((NOT (SETQ VAL (MATCH (CAR A) (CAR B)))) (RETURN NIL))
	  ((NEQ VAL T) (RETURN-FROM MATCH (OR (NULL (SETQ A (CDR A)))
					      (DO B B (CDR B) (NULL B)
						  (AND (MATCH A B) (RETURN T)))))))))

(DEFCOM COM-EXECUTE-COMMAND-INTO-BUFFER "Direct typeout from a command into the buffer.
Prompts you for a command, either a key or an extended command.  Any typeout
produced by the command is inserted into the buffer at POINT, rather than being
displayed on the typeout window.  m-X Macro Expand Expression All is a good example
of a command whose output can usefully be saved in this manner." ()
  (LET* ((*TYPEOUT-WINDOW* (MAKE-INTERVAL-TYPEOUT-STREAM))
	 (STANDARD-OUTPUT *TYPEOUT-WINDOW*)
	 (OLD-POINT (COPY-BP (POINT) :NORMAL)))
    (PROMPT-LINE "Key: ")
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
      (WITH-CUSTOM-UNDO-SAVE (OLD-POINT OLD-POINT
			      (MAKE-INSERT-RECORD OLD-POINT (COPY-BP OLD-POINT ':MOVES)))
	(PROCESS-COMMAND-CHAR (PROMPT-LINE-ACTIVATE (FUNCALL STANDARD-INPUT ':TYI)))
	(MOVE-MARK (POINT))
	(MOVE-POINT (FUNCALL *TYPEOUT-WINDOW* ':READ-BP))
	(SETQ *CURRENT-COMMAND-TYPE* 'YANK))))
  DIS-TEXT)

(DEFCOM COM-INSERT-DATE "Print the curent date into the buffer.
Calls TIME:PRINT-CURRENT-TIME, or if given an argument TIME:PRINT-CURRENT-DATE" ()
  (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
    (LET ((STREAM (OPEN-INTERVAL-STREAM (POINT)))
	  (OLD-POINT (COPY-BP (POINT) :NORMAL)))
      (WITH-CUSTOM-UNDO-SAVE (OLD-POINT OLD-POINT
			      (MAKE-INSERT-RECORD OLD-POINT (COPY-BP OLD-POINT ':MOVES)))
	(SCL:WITH-CHARACTER-STYLE ((SI:INDEX-CHARACTER-STYLE *STYLE*) STREAM)
	  (FUNCALL (IF *NUMERIC-ARG-P* #'TIME:PRINT-CURRENT-DATE #'TIME:PRINT-CURRENT-TIME)
		   STREAM)
	  (MOVE-MARK (POINT))
	  (MOVE-POINT (SEND STREAM ':READ-BP))))
      (CLOSE STREAM)))
  DIS-TEXT)

(DEFCOM COM-INSERT-CRASH-DATA "Insert the crash data obtained by the FEP.
With an argument, interpret it in the current world." ()
  (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
    (LET ((STREAM (REST-OF-INTERVAL-STREAM (POINT)))
	  (OLD-POINT (COPY-BP (POINT) :NORMAL)))
      (WITH-CUSTOM-UNDO-SAVE (OLD-POINT OLD-POINT
			      (MAKE-INSERT-RECORD OLD-POINT (COPY-BP OLD-POINT ':MOVES)))
	(SCL:WITH-CHARACTER-STYLE ((SI:INDEX-CHARACTER-STYLE *STYLE*) STREAM)
	  (SI:SHOW-CRASH-DATA STREAM *NUMERIC-ARG-P*)))
      (CLOSE STREAM)))
  DIS-TEXT)

(DEFCOM COM-COUNT-LINES-REGION
	"Print the number of lines in the region (or definition) in the echo area." ()
  (LET ((COUNT 0)
	(WAS-FUNCTION-P NIL))
    (DEFINITION-REGION (BP1 BP2 NAME FUNCTION-P)
      (IF FUNCTION-P
	  (TYPEIN-LINE "~D line~:P in ~A.  "
		       (SETQ WAS-FUNCTION-P (1- (COUNT-LINES BP1 BP2 T))) NAME)
	  (INCF COUNT (1- (COUNT-LINES BP1 BP2 T)))))
    (UNLESS WAS-FUNCTION-P
      (TYPEIN-LINE "~D line~:P in the region." COUNT)))
  DIS-NONE)

(DEFCOM COM-WHERE-AM-I "Print various things about where the point is.
Print the X and Y positions, the attributes of the following character,
the current line number and its percentage of the total file size.
If there is a region, the number of lines in it is printed.
Fast Where Am I prints a subset of this information faster." (KM)
  (REDISPLAY *WINDOW* ':POINT NIL NIL T)
  (LET ((POINT (POINT))
	(FIRST-BP (INTERVAL-FIRST-BP *INTERVAL*))
	(LAST-BP (INTERVAL-LAST-BP *INTERVAL*)))
    (LET ((POINT-LINES (1- (COUNT-LINES FIRST-BP POINT)))
	  (INTERVAL-LINES (1- (COUNT-LINES FIRST-BP LAST-BP)))
	  (AT-END-P (BP-= (INTERVAL-LAST-BP *INTERVAL*) POINT))
	  (BP-IND (BP-INDENTATION POINT))
	  (SW (FONT-SPACE-WIDTH)))
      (TYPEIN-LINE "X=[~D. chars|~D. pixels|~:[~S~;~D.~] columns] Y=~D. Line=~D.(~D%)"
		   (BP-INDEX POINT)
		   BP-IND
		   (ZEROP (\ BP-IND SW))
		   (IF (ZEROP (\ BP-IND SW))
		       (// BP-IND SW)
		       (// (FLOAT BP-IND) SW))
		   (FIND-BP-IN-WINDOW *WINDOW* POINT)
		   POINT-LINES
		   (IF (ZEROP INTERVAL-LINES)
		       0
		       (// (* 100. POINT-LINES) INTERVAL-LINES)))
      (UNLESS AT-END-P
	(TYPEIN-LINE-MORE " Char=")
	(DESCRIBE-CHARACTER (BP-CHAR POINT) *TYPEIN-WINDOW*))))
  (AND (WINDOW-MARK-P *WINDOW*)
       (LET ((COUNT 0))
	 (REGION (BP1 BP2 :EMPTY-OK T)
	   (INCF COUNT (1- (COUNT-LINES BP1 BP2 T))))
	 (TYPEIN-LINE-MORE ", Region has ~D line~:P. " COUNT)))
  DIS-NONE)

(DEFCOM COM-FAST-WHERE-AM-I "Quickly print various things about where the point is.
Print the X and Y positions, and the attributes of the following character.
If there is a region, the number of lines in it is printed.
Where Am I prints the same things and more." (KM)
  (REDISPLAY *WINDOW* ':POINT NIL NIL T)
  (LET ((POINT (POINT)))
    (LET ((AT-END-P (BP-= (INTERVAL-LAST-BP *INTERVAL*) POINT))
	  (BP-IND (BP-INDENTATION POINT))
	  (SW (FONT-SPACE-WIDTH)))
      (TYPEIN-LINE "X=[~D. chars|~D. pixels|~:[~S~;~D.~] columns] Y=~D."
		   (BP-INDEX POINT)
		   BP-IND
		   (ZEROP (\ BP-IND SW))
		   (IF (ZEROP (\ BP-IND SW))
		       (// BP-IND SW)
		       (// (FLOAT BP-IND) SW))
		   (FIND-BP-IN-WINDOW *WINDOW* POINT))
      (UNLESS AT-END-P
	(TYPEIN-LINE-MORE " Char=")
	(DESCRIBE-CHARACTER (BP-CHAR POINT) *TYPEIN-WINDOW*))))
  (AND (WINDOW-MARK-P *WINDOW*)
       (LET ((COUNT 0))
	 (REGION (BP1 BP2 :EMPTY-OK T)
	   (INCF COUNT (1- (COUNT-LINES BP1 BP2 T))))
	 (TYPEIN-LINE-MORE ", Region has ~D line~:P. " COUNT)))
  DIS-NONE)

(DEFUN DESCRIBE-CHARACTER (CHAR STREAM)
  (FORMAT STREAM "~:C~:[~%~] (code=#o~O"
	  CHAR
	  (> (- (SEND STREAM :SIZE-IN-CHARACTERS) (SEND STREAM :READ-CURSORPOS :CHARACTER))
	     25.)
	  (CHAR-CODE CHAR))
  (CONDITION-CASE (CHAR-SET INDEX)
      (SI:CHAR-CHAR-SET-AND-INDEX CHAR)
    (ERROR NIL)
    (:NO-ERROR
      (LET ((CHAR-SET (SEND CHAR-SET :NAME))
	    (STYLE (CONDITION-CASE () (SI:CHAR-STYLE CHAR)
		     (ERROR NIL))))
	(WHEN CHAR-SET
	  (FORMAT STREAM ", index ~D in ~A char-set" INDEX CHAR-SET))
	(WHEN STYLE
	  (FORMAT STREAM ", style=~A" STYLE)))))
  (UNLESS (ZEROP (CHAR-BITS CHAR))
    (FORMAT STREAM ", bits=#b~B" (CHAR-BITS CHAR)))
  (FORMAT STREAM ")"))

(DEFCOM COM-ARGLIST "Print the argument list of the specified function.
Reads the name of the function from the mini-buffer (the top of the kill
ring has the /"current/" function from the buffer) and prints the arglist
in the echo area." ()
  (LET ((FUNCTION (READ-FUNCTION-SPEC "Arglist" (RELEVANT-FUNCTION-NAME (POINT)))))
    (CONDITION-CASE ()
	 (PRINT-ARGLIST FUNCTION)
       (SYS:UNDEFINED-FUNCTION
	 ;; Just in case...
	 (BARF "~S is not a defined function" FUNCTION))))
  DIS-NONE)

;(TV:ADD-TYPEOUT-ITEM-TYPE *TYPEOUT-COMMAND-ALIST* FUNCTION-NAME "Arglist"
;			  TYPEOUT-MENU-ARGLIST NIL
;			  "Print arglist for this function.")

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR TYPEOUT-MENU-ARGLIST
						  (((SYS:FUNCTION-SPEC :DEFINED-P T))
						    "Arglist" *STANDARD-COMTAB*)
						  (FUNCTION-SPEC)
  `(TYPEOUT-MENU-ARGLIST ,FUNCTION-SPEC))

(DEFUN TYPEOUT-MENU-ARGLIST (FUNCTION)
  (PRINT-ARGLIST FUNCTION)
  T) 

(DEFCOM COM-QUICK-ARGLIST
	"Displays the argument list for the current function.
With a numeric argument, it reads the function name from the minibuffer.  " ()
  (QUICK-ARGLIST)
  DIS-NONE)

(DEFUN MAKE-INSTANCE-FUNCTION-FLAVOR-INIT-KEYWORDS (FUNCTION-NAME BP)
  (DECLARE (VALUES FLAVOR-NAME INIT-KEYWORDS REQUIRED-KEYWORDS ALLOW-OTHER-KEYS))
  (LET ((MK-I (SI:FUNCTION-SPEC-GET FUNCTION-NAME 'FLAVOR::MAKE-INSTANCE-FUNCTION-INFO)))
    (WHEN MK-I
      (LET* ((BP1 (FORWARD-SEXP BP (CL:GETF MK-I :FLAVOR-NAME-OFFSET)))
	     (BP2 (AND BP1 (FORWARD-SEXP BP1))))
	(WHEN (AND BP1 BP2)
	  (LET ((FLAVOR-NAME
		  (CATCH-ERROR
		    (LET ((SI:*SUPPRESS-READ-EVAL* T))
		      (CL:READ-FROM-STRING (STRING-INTERVAL BP1 BP2 T) NIL NIL))
		    NIL)))
	    (SETQ FLAVOR-NAME
		  (IF (CL:GETF MK-I :FLAVOR-NAME-QUOTED)
		      (AND (LISTP FLAVOR-NAME)
			   (= (LENGTH FLAVOR-NAME) 2)
			   (EQ (CAR FLAVOR-NAME) 'QUOTE)
			   (CADR FLAVOR-NAME))
		      (AND (SYMBOLP FLAVOR-NAME) FLAVOR-NAME)))
	    (WHEN FLAVOR-NAME
	      (MULTIPLE-VALUE-BIND
		(FLAVOR-DEFINED-P INITABLE-IVS OTHER-ALLOWED-KEYWORDS
		 REQUIRED-KEYWORDS ALLOW-OTHER-KEYS)
		  (FLAVOR::CHECK-INIT-KEYWORDS-INTERNAL FLAVOR-NAME NIL :ENVIRONMENT NIL)
		(WHEN FLAVOR-DEFINED-P
		  (VALUES FLAVOR-NAME
			  (APPEND
			    (LOOP FOR (KEYWORD) IN INITABLE-IVS
				  COLLECT KEYWORD)
			    OTHER-ALLOWED-KEYWORDS)
			  REQUIRED-KEYWORDS ALLOW-OTHER-KEYS))))))))))

(DEFUN PRINT-RESOURCE-ARGLIST-IF-RELEVANT (FUNCTION BP STREAM)
  (SELECTQ FUNCTION
    (ALLOCATE-RESOURCE)
    (USING-RESOURCE
     (UNLESS (SETQ BP (FORWARD-SEXP BP 1 NIL -1))
       (RETURN-FROM PRINT-RESOURCE-ARGLIST-IF-RELEVANT NIL)))
    (OTHERWISE (RETURN-FROM PRINT-RESOURCE-ARGLIST-IF-RELEVANT NIL)))
  (WHEN (SETQ BP (FORWARD-SEXP BP))			;After the resource name
    (LET ((BP1 (FORWARD-SEXP BP -1 NIL 0 NIL NIL)))	;Before the resource name
      (WHEN (AND BP1
		 (OR (EQ FUNCTION 'USING-RESOURCE)
		     (CHAR-EQUAL (BP-CHAR-BEFORE BP1) #\')))
	(CATCH-ERROR
	  (LET* ((RESOURCE-NAME (LET ((SI:*SUPPRESS-READ-EVAL* T))
				  (CL:READ-FROM-STRING (STRING-INTERVAL BP1 BP T) NIL NIL)))
		 (RESOURCE (AND (SYMBOLP RESOURCE-NAME)
				(GET RESOURCE-NAME 'DEFRESOURCE))))
	    (WHEN RESOURCE
	      (LET ((ARGLIST (SI:RESOURCE-ARGLIST RESOURCE)))
		(SETQ ARGLIST
		      (SELECTQ FUNCTION
			(ALLOCATE-RESOURCE `(RESOURCE-NAME ,@ARGLIST))
			(USING-RESOURCE `((VARIABLE RESOURCE-NAME ,@ARGLIST) . BODY))))
		(WHEN (AND (VARIABLE-BOUNDP *TYPEIN-WINDOW*)
			   (EQ STREAM *TYPEIN-WINDOW*))
		  (TYPEIN-LINE-DURABLE ""))
		(PRINT-FILLED-ARGLIST STREAM FUNCTION ARGLIST NIL NIL
				      `((RESOURCE-NAME ',RESOURCE-NAME)))
		(SEND-IF-HANDLES STREAM :TYPEOUT-STAYS)
		T)))
	  NIL)))))

(DEFUN QUICK-ARGLIST (&OPTIONAL (STREAM *TYPEIN-WINDOW*))
  (FLET ((ARGLIST-FINDER-FROM-BP (THE-BP)
	   (LET* ((DELIMITER-BP (AND THE-BP (FORWARD-CHAR THE-BP -1 T)))
		  (LEADING-DELIMITER (AND DELIMITER-BP (BP-CHAR DELIMITER-BP)))
		  (KEYWORD (SEND (SEND *INTERVAL* :MAJOR-MODE) :MAJOR-MODE-KEYWORD)))
	     (SI:FIND-ARGLIST-FINDER LEADING-DELIMITER KEYWORD))))
    (IF *NUMERIC-ARG-P*
	(MULTIPLE-VALUE-BIND (FUNCTION-NAME BP)
	    (RELEVANT-FUNCTION-NAME (POINT))
	  (LET ((FUNCTION-NAME (READ-FUNCTION-SPEC "Arglist" FUNCTION-NAME)))
	    ;;--- Possibly the wrong arglist finder, but what the heck
	    (PRINT-ARGLIST FUNCTION-NAME STREAM (ARGLIST-FINDER-FROM-BP BP))))
      (MULTIPLE-VALUE-BIND (FUNCTION MESSAGE-P BP STRIP-ARGUMENTS)
	  (RELEVANT-FUNCTION-OR-MESSAGE-NAME (POINT) NIL NIL)
	(WHEN MESSAGE-P
	  (SETQ FUNCTION (OR (FLAVOR:FIND-GENERIC-FUNCTION FUNCTION NIL)
			     (BARF "Cannot find any methods for the message ~S" FUNCTION))))
	(WHEN (NULL FUNCTION)		;Looked hard but couldn't find a defined function
	  (BARF "No such function"))
	(WHEN (NOT MESSAGE-P)
	  (LET ((ARGS-BP (FORWARD-SEXP BP)))
	    (MULTIPLE-VALUE-BIND
	      (FLAVOR-NAME INIT-KEYWORDS REQUIRED-INIT-KEYWORDS ALLOW-OTHER-KEYS)
		(MAKE-INSTANCE-FUNCTION-FLAVOR-INIT-KEYWORDS FUNCTION ARGS-BP)
	      (WHEN FLAVOR-NAME
		(PRINT-SYNTHESIZED-MAKE-INSTANCE-ARGLIST
		  FUNCTION FLAVOR-NAME INIT-KEYWORDS REQUIRED-INIT-KEYWORDS ALLOW-OTHER-KEYS
		  STREAM)
		(RETURN-FROM QUICK-ARGLIST NIL)))
	    (WHEN (PRINT-RESOURCE-ARGLIST-IF-RELEVANT FUNCTION ARGS-BP STREAM)
	      (RETURN-FROM QUICK-ARGLIST NIL))))
	(LET ((ARGLIST-FINDER (ARGLIST-FINDER-FROM-BP BP)))
	  (CONDITION-CASE ()
	       (IF STRIP-ARGUMENTS
		   (PRINT-ARGLIST FUNCTION STREAM ARGLIST-FINDER STRIP-ARGUMENTS)
		   (PRINT-ARGLIST FUNCTION STREAM ARGLIST-FINDER))
	     (SYS:UNDEFINED-FUNCTION
	       ;; If undefined, back off to DEFUN (or whatever) if possible.
	       ;; First check for internal functions (this should really be
	       ;; first for shadowing purposes, but it's so slow...)
	       (WHEN ARGLIST-FINDER
		 (BARF "~S is not defined" FUNCTION))
	       (UNLESS (QUICK-ARGLIST-OF-INTERNAL-FUNCTION FUNCTION (POINT) STREAM)
		 ;; Try backing off to an enclosing function call
		 (MULTIPLE-VALUE (FUNCTION BP)
		   (RELEVANT-FUNCTION-NAME (POINT) NIL T NIL))
		 (WHEN (NULL FUNCTION)
		   (BARF "No such function"))
		 (LET ((ARGS-BP (FORWARD-SEXP BP)))
		   (WHEN (PRINT-RESOURCE-ARGLIST-IF-RELEVANT FUNCTION ARGS-BP STREAM)
		     (RETURN-FROM QUICK-ARGLIST NIL)))
		 (CONDITION-CASE ()
		      (PRINT-ARGLIST FUNCTION STREAM)
		    ;; Should this do package dwim?
		    (SYS:UNDEFINED-FUNCTION
		      (BARF "~S is not a defined function" FUNCTION)))))))))))

(DEFVAR *HEURISTICATE-INTERNAL-FUNCTION-ARGLISTS* T)
(DEFUN QUICK-ARGLIST-OF-INTERNAL-FUNCTION (FUNCTION AT-BP &OPTIONAL (STREAM *TYPEIN-WINDOW*))
  (WHEN (NULL *HEURISTICATE-INTERNAL-FUNCTION-ARGLISTS*)
    (RETURN-FROM QUICK-ARGLIST-OF-INTERNAL-FUNCTION NIL))
  (LET* ((LOWER-BOUND (OR (FORWARD-DEFINITION AT-BP -1 NIL *INTERVAL*)
			  (INTERVAL-FIRST-BP *INTERVAL*)))
	 (UPPER-BOUND (OR (FORWARD-DEFINITION LOWER-BOUND 1 T *INTERVAL*)
			  (INTERVAL-LAST-BP *INTERVAL*)))
	 (WHITESPACE-CHARS *WHITESPACE-CHARS*))
    (WITH-INTERVAL-READ-LOCKED (LOWER-BOUND UPPER-BOUND T)
      ;; Attempt to bound the interval to just the function, but use
      ;; the entirety of *INTERVAL* if that won't work
      (WITH-BOUNDED-INTERVAL (REGION-P LOWER-BOUND UPPER-BOUND)
	(LOOP FOR BP = AT-BP THEN (FORWARD-UP-LIST-OR-STRING BP -1)
	      DOING
	  (IF (OR (NULL BP)
		  ;; FORWARD-UP-LIST-OR-STRING might quit here
		  (BP-= BP LOWER-BOUND))
	      (RETURN-FROM QUICK-ARGLIST-OF-INTERNAL-FUNCTION NIL)
	    (LET ((SYMBOL (SYMBOL-AT-PAREN BP)))
	      (WHEN (MEMQ SYMBOL *DEFINITION-LIST-FUNCTIONS*)
		(LET ((FIRST-FBP (FORWARD-UP-LIST-OR-STRING (FORWARD-ATOM BP 2) -1)))
		  ;;--- This could probably use better error checking
		  (LOOP FOR FBP = FIRST-FBP THEN (FORWARD-SEXP (FORWARD-SEXP FBP 2) -1)
			AS FSYM = (WHEN FBP (SYMBOL-AT-PAREN FBP))
			UNTIL (OR (NULL FSYM) (NULL FBP)
				  ;; Moving backward an expression might quit here
				  (BP-= FBP LOWER-BOUND))
			DOING
		    (WHEN (EQ FUNCTION FSYM)
		      (LET* ((ARGL-BP (FORWARD-OVER WHITESPACE-CHARS (FORWARD-ATOM FBP)))
			     (ARGL-STREAM (INTERVAL-STREAM ARGL-BP (FORWARD-SEXP ARGL-BP) T))
			     (ARGLIST (LET ((SI:*SUPPRESS-READ-EVAL* T))
					(CONDITION-CASE ()
					     (READ ARGL-STREAM)
					   (SYS:READ-ERROR
					     (RETURN-FROM QUICK-ARGLIST-OF-INTERNAL-FUNCTION NIL))))))
			;; We'll assume that internal functions have short arglists
			(IGNORE STREAM)
			(TYPEIN-LINE-DURABLE "")
			(PRINT-FILLED-ARGLIST *TYPEIN-WINDOW* FUNCTION ARGLIST NIL
					      (IF (MEMQ SYMBOL '(MACROLET
								 FUTURE-COMMON-LISP:MACROLET))
						  "internal macro" "internal function"))
			(SEND-IF-HANDLES *TYPEIN-WINDOW* :TYPEOUT-STAYS))
		      (RETURN-FROM QUICK-ARGLIST-OF-INTERNAL-FUNCTION T))))))))))))

(DEFUN PRINT-SYNTHESIZED-MAKE-INSTANCE-ARGLIST
       (FUNCTION FLAVOR-NAME INIT-KEYWORDS REQUIRED-INIT-KEYWORDS ALLOW-OTHER-KEYS STREAM)
  (MULTIPLE-VALUE-BIND (ARGLIST RETURNS TYPE)
      (CONDITION-CASE ()
	   (ARGLIST FUNCTION)
	 (SYS:UNDEFINED-FUNCTION NIL))
    ;; our goal is to replace the init options in the arg list with the 
    ;; information we have, if we can.
    (IGNORE RETURNS TYPE)
    (WHEN (NULL ARGLIST) ;; function defined, but null arglist!?
      (BARF "Function ~S has MAKE-INSTANCE info, but no arglist." FUNCTION))
    (LET* ((MK-I (SI:FUNCTION-SPEC-GET FUNCTION 'FLAVOR::MAKE-INSTANCE-FUNCTION-INFO))
	   (INIT-PLIST-OFFSET (CL:GETF MK-I :INIT-PLIST-OFFSET))
	   (OPTIONAL-KEYWORDS (CL:SET-DIFFERENCE INIT-KEYWORDS REQUIRED-INIT-KEYWORDS)))
      (CL:SETF (NTHCDR (1+ INIT-PLIST-OFFSET) ARGLIST) NIL)
      (FLET ((PRINT-IT (STREAM)
	       (LET ((CL:*PRINT-PRETTY* :DATA))
		 (SCL:FILLING-OUTPUT (STREAM)
		   (FORMAT STREAM
			   "~S (~S)~@[ required: ~S~]~@[ optional: ~S~]~:[~*~;&ALLOW-OTHER-KEYS~]"
			   FUNCTION
			   FLAVOR-NAME
			   REQUIRED-INIT-KEYWORDS
			   OPTIONAL-KEYWORDS
			   ALLOW-OTHER-KEYS)))))
	(IF (AND (VARIABLE-BOUNDP *TYPEIN-WINDOW*)
		 (EQ STREAM *TYPEIN-WINDOW*))
	    (MULTIPLE-VALUE-BIND (WIDTH HEIGHT IGNORE IGNORE)
		(DW::CONTINUATION-OUTPUT-SIZE #'PRINT-IT *TYPEIN-WINDOW*)
	      (IF (AND ( WIDTH (SEND *TYPEIN-WINDOW* :INSIDE-WIDTH))
		       ( HEIGHT (SEND *TYPEIN-WINDOW* :INSIDE-HEIGHT)))
		  (PROGN
		    (TYPEIN-LINE-DURABLE "")
		    (PRINT-IT *TYPEIN-WINDOW*)
		    (SEND-IF-HANDLES *TYPEIN-WINDOW* :TYPEOUT-STAYS))
		  (PRINT-IT *TYPEOUT-WINDOW*)
		  (SEND-IF-HANDLES *TYPEOUT-WINDOW* :TYPEOUT-STAYS)))
	    (PRINT-IT STREAM)))))) 

;;; Note that FUNCTION is in fact a full function spec, and thus may be a list.
;;; It can also be a function object, such as a generic function.
(DEFUN PRINT-ARGLIST (FUNCTION
		      &OPTIONAL (STREAM *TYPEIN-WINDOW*)
				ARGLIST-FINDER
				(STRIP-ARGUMENTS 
				  (COND ((ATOM FUNCTION)
					 NIL)
					((EQ (CAR FUNCTION) 'DEFUN-IN-FLAVOR)
					 2)
					((MEMQ (CAR FUNCTION) FLAVOR:*FDEFINABLE-METHOD-TYPES*)
					 #+3600 3 #+IMACH 2))
				  STRIP-ARGUMENTS-P))
  (LET ((CL:*PRINT-PRETTY* :DATA))
    (MULTIPLE-VALUE-BIND (ARGLIST RETURNS TYPE ARGLIST-TYPES VALUE-TYPES)
	(ARGLIST FUNCTION NIL ARGLIST-FINDER)
      (WHEN (AND (EQ TYPE 'CLOS:GENERIC-FUNCTION)
		 (MEMQ '&KEY ARGLIST)
		 (NOT (MEMQ '&ALLOW-OTHER-KEYS ARGLIST)))
	(LET ((FUNCTION (FDEFINITION (SI:UNENCAPSULATE-FUNCTION-SPEC FUNCTION))))
	  (WHEN (CLOS-INTERNALS::GENERIC-FUNCTION-P FUNCTION)
	    ;; Assuming we want the caller's point of view, add keywords
	    ;; that are accepted by all methods for this generic function.
	    ;; Most commonly, there will be just one method.
	    (LET ((ADDITIONAL-KEYWORDS NIL) (VALID NIL))
	      (MULTIPLE-VALUE-BIND (NIL NIL NIL NIL GENERIC-FUNCTION-KEYWORDS)
		  (CLOS-INTERNALS::LAMBDA-LIST-COMPONENTS ARGLIST)
		(DOLIST (METHOD (CLOS:GENERIC-FUNCTION-METHODS FUNCTION))
		  (MULTIPLE-VALUE-BIND (NIL NIL NIL KEYWORDSP KEYWORDS)
		      (CLOS-INTERNALS::LAMBDA-LIST-COMPONENTS
			(CLOS:METHOD-LAMBDA-LIST METHOD))
		    (WHEN KEYWORDSP
		      (SETQ ADDITIONAL-KEYWORDS
			    (IF VALID
				(INTERSECTION KEYWORDS ADDITIONAL-KEYWORDS)
				(CL:SET-DIFFERENCE KEYWORDS GENERIC-FUNCTION-KEYWORDS)))
		      (SETQ VALID T))))
		(WHEN VALID
		  (SETQ ARGLIST (APPEND ARGLIST (MAPCAR #'(LAMBDA (SYMBOL)
							    (INTERN (STRING SYMBOL)))
							ADDITIONAL-KEYWORDS)))))))))
      (WHEN (AND (LISTP FUNCTION)
		 (EQ (CAR FUNCTION) 'DEFUN-IN-FLAVOR)
		 (EQ TYPE 'SCL:MACRO)
		 (NULL STRIP-ARGUMENTS-P))
	;; DEFMACRO-IN-FLAVOR doesn't need anything stripped
	(SETQ STRIP-ARGUMENTS NIL))
      (WHEN STRIP-ARGUMENTS
	(SETQ ARGLIST (LT:REMOVE-ARGUMENTS-FROM-LAMBDA-LIST STRIP-ARGUMENTS ARGLIST)))
      (IF (AND (VARIABLE-BOUNDP *TYPEIN-WINDOW*)
	       (EQ STREAM *TYPEIN-WINDOW*))
	  (MULTIPLE-VALUE-BIND (WIDTH HEIGHT IGNORE IGNORE)
	      (DW::CONTINUATION-OUTPUT-SIZE
		#'(LAMBDA (STREAM)
		    (PRINT-FILLED-ARGLIST STREAM FUNCTION ARGLIST RETURNS TYPE
					  ARGLIST-TYPES VALUE-TYPES))
		*TYPEIN-WINDOW*)
	    (IF (AND ( WIDTH (SEND *TYPEIN-WINDOW* :INSIDE-WIDTH))
		     ( HEIGHT (SEND *TYPEIN-WINDOW* :INSIDE-HEIGHT)))
		(PROGN
		  (TYPEIN-LINE-DURABLE "")
		  (PRINT-FILLED-ARGLIST *TYPEIN-WINDOW* FUNCTION ARGLIST RETURNS TYPE
					ARGLIST-TYPES VALUE-TYPES)
		  (SEND-IF-HANDLES *TYPEIN-WINDOW* :TYPEOUT-STAYS))
	      (PRINT-FILLED-ARGLIST *TYPEOUT-WINDOW* FUNCTION ARGLIST RETURNS TYPE
				    ARGLIST-TYPES VALUE-TYPES)
	      (SEND-IF-HANDLES *TYPEOUT-WINDOW* :TYPEOUT-STAYS)))
	(PRINT-FILLED-ARGLIST STREAM FUNCTION ARGLIST RETURNS TYPE
			      ARGLIST-TYPES VALUE-TYPES)))))

(DEFUN PRINT-FILLED-ARGLIST (STREAM FUNCTION ARGLIST RETURNS TYPE
			     &OPTIONAL ARGLIST-TYPES VALUE-TYPES)
  (SCL:FILLING-OUTPUT (STREAM)
    (PRIN1 (SYS:FUNCTION-NAME FUNCTION) STREAM)
    (COND ((EQ TYPE 'SI:MESSAGE)
	   (FORMAT STREAM " (message to ~S)" (FIRST (SYS:GENERIC-FUNCTION-ARGLIST FUNCTION))))
	  ((NOT (NULL TYPE))
	   (FORMAT STREAM " (~@)" TYPE)))
    (FORMAT STREAM ": ")
    (IF (OR (LISTP ARGLIST) (NULL ARGLIST))
	(PRINT-ARGLIST-INTERNAL ARGLIST STREAM ARGLIST-TYPES)
	(PRINC "??" STREAM))
    (WHEN RETURNS
      (WHEN (> (+ (SEND STREAM :READ-CURSORPOS :CHARACTER)
		  (FLATSIZE (APPLY 'APPEND
				   (MAPCAR #'(LAMBDA (V)
					       (CONS V (CDR (ASSOC V VALUE-TYPES))))
					   RETURNS))))
	       (SEND STREAM :SIZE-IN-CHARACTERS))
	(TERPRI STREAM))
      (FORMAT STREAM "  ")
      ;; OK so I'm using print-lambda-list to print the values too.
      (PRINT-ARGLIST-INTERNAL RETURNS STREAM VALUE-TYPES))
    (WHEN (OR (SYMBOLP FUNCTION) (LISTP FUNCTION))
      (LET ((INLINE (SI:FUNCTION-SPEC-GET FUNCTION 'SCL:INLINE))
	    (FTYPE  (SI:FUNCTION-SPEC-GET FUNCTION 'SCL:FTYPE))
	    (FUNCTION (SI:FUNCTION-SPEC-GET FUNCTION 'SCL:FUNCTION)))
	(WHEN (EQ INLINE 'SCL:INLINE) (PRINC " (inline)" STREAM))
	(WHEN (EQ INLINE 'SCL:NOTINLINE) (PRINC " (notinline)" STREAM))
	(WHEN FTYPE (FORMAT STREAM " FTYPE: ~A" FTYPE))
	(WHEN FUNCTION (FORMAT STREAM " FUNCTION: ~A" FUNCTION))))))

(DEFUN PRINT-ARGLIST-INTERNAL (LIST STREAM &optional ARGLIST-TYPES)
  (LT:PRINT-LAMBDA-LIST LIST STREAM :BRIEF T :ERROR-P NIL :TYPES ARGLIST-TYPES))



(DEFCOM COM-BRIEF-DOCUMENTATION
	"Displays brief documentation for the specified Lisp function.
By default, it displays documentation for the current function.  With a
numeric argument, it prompts for a function name, which you can either
type in or select with the mouse.  It displays the first line from the
summary paragraph in the echo area.  " ()
  (LET ((DEF (RELEVANT-FUNCTION-NAME (POINT))))
    (TYPEOUT-DOCUMENTATION (IF *NUMERIC-ARG-P*
			       (READ-FUNCTION-SPEC "Brief Document" DEF) (OR DEF (BARF)))
			   NIL))
  DIS-NONE)

(DEFCOM COM-LONG-DOCUMENTATION
	"Displays the summary documentation for the specified function.
It prompts for a function name, which you can either type in or select with
the mouse.  The default is the current function.  " ()
  (TYPEOUT-LONG-DOCUMENTATION (READ-FUNCTION-SPEC "Document"
						  (RELEVANT-FUNCTION-NAME (POINT))))
  DIS-NONE)

(DEFUN TYPEOUT-LONG-DOCUMENTATION (NAME)
  (TYPEOUT-DOCUMENTATION NAME T))

(COMPILER:FUNCTION-DEFINED 'SAGE:FIND-RECORD-GROUP-FOR-TOPIC-AND-TYPE)	;forward ref: NSage.
(DEFUN TYPEOUT-DOCUMENTATION (NAME LONG-FORM)
  (LET ((DOC (DOCUMENTATION NAME)))
    (COND ((NULL DOC)
	   (TYPEIN-LINE-DURABLE "~S has no explicit documentation." NAME)
	   (WHEN (AND (VARIABLE-BOUNDP #'SAGE:FIND-RECORD-GROUP-FOR-TOPIC-AND-TYPE)
		      (SAGE:FIND-RECORD-GROUP-FOR-TOPIC-AND-TYPE NAME NIL))
	     (TYPEIN-LINE-DURABLE
	       "You may use the D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")Document Examiner0 for detailed documentation.")))
	  (T (WHEN LONG-FORM (PRINT-ARGLIST NAME))
	     (TYPEIN-LINE-DURABLE "~S: ~A" NAME
				  (NSUBSTRING DOC 0 (STRING-SEARCH-CHAR #\CR DOC)))
	     (WHEN LONG-FORM (FORMAT T "~%~A" DOC))))))

;;; This should be kept consistent with DESCRIBE-VARIABLE-INTERNAL
(DEFVAR *PROPERTIES-THAT-MAKE-VARIABLES-INTERESTING*
	'(SPECIAL				;Declared as a special variable or constant
	  DEFCONSTANT				;Declared with DEFCONSTANT
	  :SYSTEM-CONSTANT			;Declared in SYSDEF
	  SYS:SYMBOL-MACRO			;Put on by DEFINE-SYMBOL-MACRO
	  :DOCUMENTATION			;Documentation string from DEFVAR
	  SI:INITIALIZATION-LIST		;Put on by ADD-INITIALIZATION
	  ))

(DEFCOM COM-DESCRIBE-VARIABLE-AT-POINT
	"Displays information in the echo area about the current Lisp variable.
The information printed is whether it is declared special, whether it has a
value, and whether it has documentation put on by DEFVAR.  When nothing is
available, it checks for lookalike symbols in other packages.  " ()
  (LET* ((BP1 (FORWARD-ATOM (FORWARD-CHAR (POINT) 1 T) -1 T))
	 (BP2 (FORWARD-ATOM BP1))
	 VAR)
    (IF (NULL BP2) (BARF))
    (CONDITION-CASE (ERROR)
	 (WITH-INPUT-FROM-STRING (S (BP-LINE BP1) (BP-INDEX BP1) (BP-INDEX BP2))
	   (SETQ VAR (READ S)))
       (SYS:READ-ERROR (BARF)))
    (OR (SYMBOLP VAR) (BARF))
    (TYPEIN-LINE "")				;Clear the echo area
    (COND ((NOT (DESCRIBE-VARIABLE-INTERNAL VAR :SHOW-LONG *NUMERIC-ARG-P*))
	   (TYPEIN-LINE "~S is not a declared variable." VAR)
	   (WHEN *ENABLE-PACKAGE-DWIM*
	     (MAPC #'(LAMBDA (V) (DESCRIBE-VARIABLE-INTERNAL V :SHOW-LONG *NUMERIC-ARG-P*))
		   (PACKAGE-LOOKALIKE-SYMBOLS
		     VAR SI:PKG-GLOBAL-PACKAGE
		     *PROPERTIES-THAT-MAKE-VARIABLES-INTERESTING*)))))
    (SEND *TYPEIN-WINDOW* ':TYPEOUT-STAYS)
    DIS-NONE))

;;; --- the use of continuation-output could be rationalized here
;;; --- to include the entire output.
(DEFUN PRINT-VALUE-IN-TYPEIN-OR-TYPEOUT (VALUE SHOW-LONG-IN-TYPEOUT)
  (FLET ((PRINT-IT (STREAM)
	   (FORMAT STREAM "~&Its value is currently: ")
	   (GPRINT:PRINT-OBJECT VALUE :DATA STREAM)))
    (MULTIPLE-VALUE-BIND (WIDTH HEIGHT IGNORE IGNORE)
	(DW::CONTINUATION-OUTPUT-SIZE
	  #'PRINT-IT *TYPEIN-WINDOW*)
      (IF (AND ( WIDTH (SEND *TYPEIN-WINDOW* :INSIDE-WIDTH))
	       ( HEIGHT (* 2 (SEND *TYPEIN-WINDOW* :LINE-HEIGHT))))
	  (PRINT-IT *TYPEIN-WINDOW*)
	  (IF SHOW-LONG-IN-TYPEOUT
	      (PRINT-IT *TYPEOUT-WINDOW*)
	      (TYPEIN-LINE
		"~&Its value is too long to fit here."))))))

(DEFUN DESCRIBE-VARIABLE-INTERNAL (VAR &KEY SHOW-LONG &AUX RESULT
				   (DOC (GET VAR ':DOCUMENTATION)))
  ;;(DECLARE (SPECIAL SAGE:*SAGE-COMPLETION-AARRAY*))
  (WHEN (LISTP DOC)
    (SETQ DOC (SECOND DOC)))			;we have already described it.
  (SETQ RESULT					;T if anything was output
	(MULTIPLE-VALUE-BIND (SYMBOL-MACRO-P SYMBOL-MACRO-EXPANSION)
	    (LT:SYMBOL-MACRO-P VAR)
	  (COND (SYMBOL-MACRO-P
		 (TYPEIN-LINE-MORE "~&~S is a symbol macro.~%" VAR)
		 (CATCH-ERROR
		   (PRINT-VALUE-IN-TYPEIN-OR-TYPEOUT
		     (EVAL SYMBOL-MACRO-EXPANSION) SHOW-LONG)
		   NIL)
		 T)
		(T
		 (LET ((SPECIAL (LT:GLOBAL-SPECIAL-VARIABLE-P VAR))
		       (DEFCONSTANT (LT:NAMED-CONSTANT-P VAR))
		       (BOUND (BOUNDP VAR)))
		   (COND ((OR BOUND SPECIAL DEFCONSTANT)
			  (TYPEIN-LINE-MORE "~&~S has ~:[no~;a~] value" VAR BOUND)
			  (WHEN SPECIAL
			    (TYPEIN-LINE-MORE " and is declared special"))
			  (WHEN DEFCONSTANT
			    (TYPEIN-LINE-MORE "~% and is open-coded in compiled code")
			    (WHEN (GET VAR ':SYSTEM-CONSTANT)
			      (TYPEIN-LINE-MORE " because it is a system constant")))
			  (WHEN (AND (NOT SPECIAL) (NOT DEFCONSTANT)
				     (GET VAR 'SI:INITIALIZATION-LIST))
			    (TYPEIN-LINE-MORE " and is used as an initialization list"))
			  (TYPEIN-LINE-MORE ".")
			  (WHEN BOUND 
			    (LET ((VAL (SYMEVAL VAR))	;in case VAR is one of the following
				  (CL:*PRINT-LEVEL* (IF SHOW-LONG NIL 3))
				  (CL:*PRINT-LENGTH* (IF SHOW-LONG NIL 3))
				  (CL:*PRINT-ARRAY* T)
				  (CL:*PRINT-RADIX* T)
				  (CL:*PRINT-CIRCLE* NIL))
			      (PRINT-VALUE-IN-TYPEIN-OR-TYPEOUT VAL SHOW-LONG)))
			  T)))))))
  (COND (DOC
;--- Printing the first line of the documentation string in the typein window just
;--- causes confusion, and tends to wipe out the above typeout, so skip it. (Moon 3/28/86)
;	 (TYPEIN-LINE "~:[~S:~; ~*~] ~A" RESULT VAR
;		      (NSUBSTRING DOC 0 (STRING-SEARCH-CHAR #\CR DOC)))
	 (FORMAT T "~&Documentation string in the definition of ~S:~%~A" VAR DOC)
	 T)
	(t ;;(NOT (VARIABLE-BOUNDP SAGE:*SAGE-COMPLETION-AARRAY*))
	 ;; Don't lose our lunch in a sageless world.
	 RESULT)
	#||
	(T
	 (LET ((TOPICS (CDR (SI:AARRAY-LOOKUP
			      (LET ((PACKAGE PKG-GLOBAL-PACKAGE))
				(FORMAT NIL "~S" VAR))
			      SAGE:*SAGE-COMPLETION-AARRAY*))))
	   (COND ((LOOP FOR TOPIC IN TOPICS
			THEREIS (SAGE:GET-SAGE-PROPERTY TOPIC :SAGE-VARIABLE-RECORD
							'SAGE:LOCATION))
		  (IF RESULT
		      ;; Already printed something, so keep this down to one line so
		      ;; it doesn't wrap around and clobber the previous output
		      (TYPEIN-LINE "You can ~@[type ~A, or ~]use the Document Examiner~
					~:*~@[,~] to look up its documentation."
				   (AND (VARIABLE-BOUNDP *COMTAB*)
					(KEY-FOR-COMMAND 'COM-SHOW-DOCUMENTATION)))
		      ;; Didn't print anything yet (is this possible?)
		      (TYPEIN-LINE "~:[~S~;It~*~] has no built-in documentation in ~
					its definition, but you can~@
					~T~@[type ~A, or ~]use the Document Examiner~
					~:*~@[,~] to look up its on-line documentation."
				   RESULT VAR
				   (AND (VARIABLE-BOUNDP *COMTAB*)
					(KEY-FOR-COMMAND 'COM-SHOW-DOCUMENTATION))))
		  T)
		 (T RESULT))))
	||#))

#||
(EVAL-WHEN (COMPILE)
  (COMPILER:FUNCTION-DEFINED 'SAGE:GET-SAGE-PROPERTY))
||#

;;; This should be kept consistent with *PROPERTIES-THAT-MAKE-VARIABLES-INTERESTING*


(DEFCOM COM-TRACE "Trace or untrace a function.
Reads the name of the function from the mini-buffer (the top of the kill
ring has the /"current/" function from the buffer) then pops up a menu
of trace options.  With an argument, omits menu step" ()
  (LET ((FCN (READ-FUNCTION-SPEC "Trace" (RELEVANT-FUNCTION-NAME (POINT)))))
    (IF (NOT *NUMERIC-ARG-P*)
	(TV:TRACE-VIA-MENUS FCN)
	(EVAL (IF (ATOM FCN) `(TRACE (,FCN)) `(TRACE (:FUNCTION ,FCN))))))
  DIS-NONE)

(DEFCOM COM-UNTRACE "Untrace a function.
With a numeric argument, untraces all traced functions." ()
  (IF *NUMERIC-ARG-P*
      (LET ((UNTRACEES (EVAL '(UNTRACE))))
	;;can't directly call UNTRACE because it is a special form.
	(LET ((N (LENGTH UNTRACEES)))
	  (TYPEIN-LINE "~d thing~p untraced." N N)))
      (LET ((FSPEC (READ-FUNCTION-SPEC "Untrace" (RELEVANT-FUNCTION-NAME (POINT)))))
	(LET ((UNTRACEE (EVAL (IF (ATOM FSPEC)
				  `(UNTRACE ,FSPEC)
				  `(UNTRACE :FUNCTION ,FSPEC)))))
	  ;;UNTRACE should tell us whether it actually had been traced.
	  (TYPEIN-LINE "~s untraced." UNTRACEE))))
  DIS-NONE)

#||
(DEFCOM COM-MOUSE-SET-BREAKPOINT
	"Set a breakpoint at the compiled instruction corresponding to the source
pointed at by the mouse." ()
  (SET-OR-CLEAR-BREAKPOINT T))

(DEFCOM COM-MOUSE-CLEAR-BREAKPOINT
	"Clear a breakpoint from the compiled instruction corresponding to the source
pointed at by the mouse." ()
  (SET-OR-CLEAR-BREAKPOINT NIL))

(DEFUN SET-OR-CLEAR-BREAKPOINT (SET-P)
  (MULTIPLE-VALUE-BIND (CHAR NIL NIL LINE CHAR-POS)
      (MOUSE-CHAR *WINDOW* NIL *MOUSE-X* *MOUSE-Y*)	;Figure out where mouse is
    (WHEN CHAR
      (LET-BUFFER-VARIABLE (*KILL-INTERVAL-SMARTS* T)
	(LET* ((BP (CREATE-BP LINE CHAR-POS))
	       (FUNCTION-NAME (GET-DEFINITION-FUNCTION-SPEC (FORWARD-DEFINITION BP -1))))
	  (IF FUNCTION-NAME
	      (LET ((PC (SI:FUNCTION-BP-PC BP FUNCTION-NAME))
		    (FUNCTION (SI:VALID-FUNCTION-DEFINITION FUNCTION-NAME)))
		(COND ((NULL PC)
		       (BARF "Couldn't find PC, ~S probably not compiled with locators"
			     FUNCTION-NAME))
		      ((NOT (EQ (TYPEP FUNCTION) :COMPILED-FUNCTION))
		       ;; I should hope that we never get here
		       (BARF "~S is not a compiled function" FUNCTION-NAME))
		      (T
		       (DBG:CLEAR-BREAKPOINT FUNCTION PC)
		       (WHEN SET-P
			 (DBG:SET-BREAKPOINT FUNCTION PC :BREAKPOINT))
		       (TYPEIN-LINE "Breakpoint ~:[cleared from~;set in~] ~S at PC ~O"
				    SET-P FUNCTION-NAME PC))))
	    (BARF "Couldn't find a function here"))))))
  DIS-NONE)
||#

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR SET-BREAKPOINT
  (SYS:CODE-FRAGMENT "Set breakpoint"
		     *ZMACS-COMTAB*
		     :GESTURE :SET-BREAKPOINT)
  (IGNORE &KEY PRESENTATION)
  (WHEN (TYPEP PRESENTATION 'PRESENTATION-NODE)
    (LET ((TRANSLATOR (SEND (SEND *INTERVAL* :MAJOR-MODE) :PRESENTATION-TO-PC-TRANSLATOR)))
      (WHEN TRANSLATOR
	(MULTIPLE-VALUE-BIND (FUNCTION PC)
	    (FUNCALL TRANSLATOR PRESENTATION)
	  (WHEN (AND FUNCTION PC)
	    `(DBG:COM-SET-BREAKPOINT-INTERNAL ,FUNCTION ,PC)))))) )

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR CLEAR-BREAKPOINT
  (SYS:CODE-FRAGMENT "Clear breakpoint" *ZMACS-COMTAB*
		     :GESTURE :CLEAR-BREAKPOINT)
  (IGNORE &KEY PRESENTATION)
  (WHEN (TYPEP PRESENTATION 'PRESENTATION-NODE)
    (LET ((TRANSLATOR (SEND (SEND *INTERVAL* :MAJOR-MODE) :PRESENTATION-TO-PC-TRANSLATOR)))
      (WHEN TRANSLATOR
	(MULTIPLE-VALUE-BIND (FUNCTION PC)
	    (FUNCALL TRANSLATOR PRESENTATION)
	  (WHEN (AND FUNCTION PC)
	    `(DBG:COM-CLEAR-BREAKPOINT-INTERNAL ,FUNCTION ,PC)))))))

(DEFCOM COM-WHERE-IS-SYMBOL "Show which packages contain the specified symbol." ()
  (WHERE-IS			;Use reader to parse slashes, strip case, strip style
    (TYPEIN-LINE-ACCEPT 'CL:SYMBOL-NAME :PROMPT "Where is symbol"))
  DIS-NONE)

(DEFCOM COM-COUNT-LINES-PAGE "Type number of lines on this page.
Also add, in parentheses, the number of lines on the page
before point, and the number of lines after point." ()
   (LET* ((POINT (POINT))
	  (PAGE-START (FORWARD-PAGE POINT -1 T))
	  (PAGE-END (FORWARD-PAGE PAGE-START 1 T)))
     (LET ((N1 (1- (COUNT-LINES PAGE-START POINT)))
	   (N2 (1- (COUNT-LINES POINT PAGE-END))))
       (TYPEIN-LINE "Page has ~D (~D + ~D) lines" (+ N1 N2) N1 N2)))
   DIS-NONE)

;(TV:ADD-TYPEOUT-ITEM-TYPE *TYPEOUT-COMMAND-ALIST* FUNCTION-NAME "Disassemble" DO-DISASSEMBLE
;			  NIL "Disassemble this function.")

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR DO-DISASSEMBLE
						  (((SYS:FUNCTION-SPEC :DEFINED-P T))
						    "Disassemble" *STANDARD-COMTAB*)
						  (FUNCTION-SPEC)
  `(DO-DISASSEMBLE ,FUNCTION-SPEC))

(DEFCOM COM-DISASSEMBLE "Disassemble the specified function." ()
  (DO-DISASSEMBLE (READ-FUNCTION-SPEC "Disassemble" (RELEVANT-FUNCTION-NAME (POINT))))
  DIS-NONE)

(DEFCOM COM-QUICK-DISASSEMBLE "Disassemble the function to the left of the cursor." ()
  (LET ((DEF (RELEVANT-FUNCTION-NAME (POINT))))
    (DO-DISASSEMBLE (IF *NUMERIC-ARG-P* (READ-FUNCTION-SPEC "Disassemble" DEF) DEF)))
  DIS-NONE)

(DEFUN DO-DISASSEMBLE (FUNCTION-SPEC)
  (ZWEI:BARF-ON-ERRORS (ERROR)			;FERRORs in DISASSEMBLE
    (FORMAT T "~&~S:" FUNCTION-SPEC)
    (DISASSEMBLE FUNCTION-SPEC)
    NIL))


(DEFCOM COM-DESCRIBE-FUNCTION
	"Given a function spec, displays its PROCLAIM'ed attributes and debugging info
in the typeout window.  "
	()
  (LET ((FSPECS (READ-FUNCTION-SPECS-TO-EDIT
		  :PROMPT-STRING "Describe definition"
		  :PACKAGE-LOOKALIKE NIL)))
    (LOOP FOR FSPEC IN FSPECS
	  WHEN (FDEFINEDP FSPEC)
	    DO
	      (FORMAT *TYPEOUT-WINDOW* "~&Function ~S" FSPEC)
	      (SCL:DESCRIBE-FUNCTION FSPEC :STREAM *TYPEOUT-WINDOW*)))
  DIS-NONE)


(DEFCOM COM-REMOVE-FUNCTION-PROCLAIMS
	"Given a function spec, removes any common lisp proclaims associated with it." ()
	(LET ((FSPECS (READ-FUNCTION-SPECS-TO-EDIT
			:PROMPT-STRING "Remove proclaims for function"
			:PACKAGE-LOOKALIKE NIL)))
	  (LOOP FOR FSPEC IN FSPECS
		WHEN (FDEFINEDP FSPEC)
		  DO
		    (FORMAT *TYPEOUT-WINDOW* "~&Function ~S" FSPEC)
		    (SCL:REMOVE-PROCLAIMS FSPEC)))
	DIS-NONE)

;;; Use this macro to format long queries on the typeout window, instead of crowding
;;; them into the typein area.
(DEFMACRO WITH-QUERIES-ON-TYPEOUT-WINDOW ((&OPTIONAL (TYPEIN-LINE-MSG
						       " [Please answer queries above.]")
						     (INDENTATION 2))
					  &BODY BODY)
  `(LET ((QUERY-IO *TYPEOUT-WINDOW*))
     (TYPEIN-LINE ,TYPEIN-LINE-MSG)
     (SI:WITH-INDENTATION (QUERY-IO ,INDENTATION)
       (UNWIND-PROTECT
	   (PROGN ,@BODY)
	 (SEND *TYPEIN-WINDOW* :CLEAR-WINDOW)))))

;;; This is partially language generic, but perhaps needs more work
(DEFCOM COM-KILL-DEFINITION
 "Remove a definition from the editor buffer, the current world, and//or world being patched.
This finds the definition containing the cursor and determines a form
that will remove it from the world.  By answering questions you can
evaluate that form, insert it into the buffer, include it in a patch
if a patch is actively being made, and//or remove the definition from
the editor buffer." ()
  ;; Find the name, type, and buffer region of the current definition
  (MULTIPLE-VALUE-BIND (NAME TYPE INTERVAL)
      (SEND (SEND *INTERVAL* :MAJOR-MODE) :DEFINITION-AROUND-BP (POINT))
    ;; Develop a form to remove it from the Lisp world
    (LET ((PRETTY-TYPE (OR (GET TYPE 'SI:DEFINITION-TYPE-NAME) TYPE))
	  (KILLED NIL))
      (MULTIPLE-VALUE-BIND (FORM)
	  (DEFINITION-UNDEFINING-FORM (SEND *INTERVAL* :MAJOR-MODE) TYPE NAME)
	(WHEN (NULL FORM)
	  (BARF "I don't know how to kill a ~A." PRETTY-TYPE))
	(WHEN (FQUERY () "Remove ~@ ~S from the current world? " PRETTY-TYPE NAME)
	  (EVAL FORM)
	  (SETQ KILLED T))
	(WHEN (AND *CURRENT-PATCH*
		   (FQUERY () "Make patch ~A ~D.~D remove ~@ ~S from the world? "
			   (PATCH-STATE-SYSTEM-NAME *CURRENT-PATCH*)
			   (PATCH-STATE-MAJOR-VERSION *CURRENT-PATCH*)
			   (PATCH-STATE-MINOR-VERSION *CURRENT-PATCH*)
			   PRETTY-TYPE NAME))
	  (ADD-PATCH-FORM FORM
			  (LET ((PACKAGE PKG-GLOBAL-PACKAGE)
				(CL:*PRINT-PRETTY* NIL))	;No carriage returns in the ~S
			    (FORMAT NIL "Remove ~@ ~S: " PRETTY-TYPE NAME))
			  *INTERVAL*))
	(WITH-INTERVAL-WRITE-LOCKED (INTERVAL)
	  (WHEN (FQUERY () "Remove ~@ ~S from the editor buffer? " PRETTY-TYPE NAME)
	    ;; Making just the buffer-edit undoable is a cruel joke, but better than nothing
	    ;;--- This command could really be undoable now that there is
	    ;;--- a new flavor-based undo system
	    (WITH-UNDO-SAVE ("Kill Definition" INTERVAL)
	      ;;--- Change this back to DELETE-INTERVAL when the undo system works well
	      ;;--- enough that users think of using it.
	      (KILL-INTERVAL INTERVAL NIL NIL T T T))
	    ;; Forget that the section existed
	    (CHECK-INTERVAL-SECTIONS (INTERVAL-FIRST-BP INTERVAL)
				     (INTERVAL-FIRST-BP INTERVAL)))
	  (WHEN (FQUERY () "Insert form to kill ~@ ~S into the editor buffer? "
		  PRETTY-TYPE NAME)
	    (WITH-OPEN-STREAM (S (OPEN-INTERVAL-STREAM (POINT) (POINT)))
	      (WITH-UNDO-SAVE ("Insert kill-definition form" (POINT) (POINT))
		(CL:FRESH-LINE S)
		(MOVE-POINT (SEND S :READ-BP))
		(CL:WRITE FORM :STREAM S :PRETTY ':CODE :READABLY T)
		(TERPRI S)))))
	(WHEN KILLED
	  (TYPEIN-LINE "~A ~S removed from the current world." PRETTY-TYPE NAME))
	DIS-TEXT))))

;;; Kill routines for specific Lisp definition types
;;;--- More should be added, especially DEFTYPE, DEFSETF, DEFLOCF

(DEFPROP DEFUN FUNDEFINE KILL-DEFINITION)

(DEFPROP DEFVAR LT:UNDEFINE-VARIABLE KILL-DEFINITION)

(DEFPROP DEFFLAVOR FLAVOR:REMOVE-FLAVOR KILL-DEFINITION)

(DEFPROP DEFSYSTEM SCT:UNDEFSYSTEM KILL-DEFINITION)

(DEFPROP DEFRESOURCE SI:UNDEFRESOURCE KILL-DEFINITION)

(DEFPROP DEFSUBST UN-DEFSUBST KILL-DEFINITION)

(DEFUN UN-DEFSUBST (NAME)
  (FUNDEFINE NAME)
  (REMPROP NAME 'SCL:INLINE))

(DEFPROP DEFINE-SYMBOL-MACRO KILL-SYMBOL-MACRO KILL-DEFINITION)

(DEFUN KILL-SYMBOL-MACRO (SYMBOL) (REMPROP SYMBOL 'SYS:SYMBOL-MACRO))


(DEFVAR *CONFIRM-UNDEFINITIONS* :MULTIPLE "controls whether the Undefine Function command
requires confirmation.  Values are NIL for no confirmation, :MULTIPLE for confirmation
only if the function spec read was ambiguous, and T for always.")

(DEFCOM COM-UNDEFINE-FUNCTION
	"Given a function spec, removes it from the environment.
It prompts for a function name from the minibuffer.  Name completion is
available for definitions in files that have already been loaded into buffers.
With a numeric argument, leaves the function spec with no definition.
Otherwise, the function spec is left with its previous definition, if any.
This command does not automatically look for functions specs in other packages.
The variable ZWEI:*CONFIRM-UNDEFINITIONS* controls whether this asks the user for 
confirmation." ()
  (TYPEIN-LINE  "")
  (LET ((FSPECS (READ-FUNCTION-SPECS-TO-EDIT
		  :PROMPT-STRING "Undefine"    
		  :PACKAGE-LOOKALIKE NIL)))
    (LOOP FOR FSPEC IN FSPECS			
	  WHEN (OR (NULL *CONFIRM-UNDEFINITIONS*)
		   (AND (EQ *CONFIRM-UNDEFINITIONS* :MULTIPLE)
			( (CL:LIST-LENGTH FSPECS) 1))
		   (TYPEIN-LINE-Y-OR-N-P "~:[UNDEFUN~;FUNDEFINE~] ~S" *NUMERIC-ARG-P* FSPEC))
	      DO (IF *NUMERIC-ARG-P* 
		     (FUNDEFINE FSPEC)
		     (UNDEFUN FSPEC))
		 (TYPEIN-LINE-MORE "~&~S" FSPEC)))
  DIS-NONE)


(DEFCOM COM-INSERT-UNDEFINE-FORMS
	"Given a function spec, adds a an FUNDEFINE form for it to the 
current buffer. It prompts for a function name from the minibuffer.  Name completion is
available for definitions in files that have already been loaded into buffers." ()
  (TYPEIN-LINE  "")
  (LET ((FSPECS (READ-FUNCTION-SPECS-TO-EDIT
		  :PROMPT-STRING "Undefine"
		  :PACKAGE-LOOKALIKE NIL)))
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
      (LOOP FOR FSPEC IN FSPECS			
	    DO
	(INSERT-MOVING (POINT)
		       (FSPEC-TO-UNDEFINE-STRING FSPEC)))))
  DIS-TEXT)
