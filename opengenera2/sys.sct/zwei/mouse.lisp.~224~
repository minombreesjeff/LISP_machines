;;; Mouse commands for ZWEI -*- Syntax: Zetalisp; Base: 8;Mode: LISP;Package: ZWEI-*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Note: some screen system primitives live in SCREEN

;;;; Dynamic mouse stuff

(DEFUN COMPATIBLE-COMTAB-LOOKUP-TESTER (IGNORE &KEY MOUSE-CHAR WINDOW &ALLOW-OTHER-KEYS)
  (AND (LET ((WINDOW (SEND-IF-HANDLES WINDOW :ZWEI-WINDOW)))
	 (AND WINDOW (MEMBER WINDOW *WINDOW-LIST*)))
       (AND MOUSE-CHAR
	    (COMMAND-LOOKUP MOUSE-CHAR *COMTAB*))))

(DEFUN COMPATIBLE-COMTAB-LOOKUP-TRANSLATOR (&KEY X Y WINDOW MOUSE-CHAR &ALLOW-OTHER-KEYS)
  (LET ((ZWEI-WINDOW (SEND WINDOW :ZWEI-WINDOW))
	(COMMAND (COMMAND-LOOKUP MOUSE-CHAR *COMTAB*)))
    `(PRESENTATION-COMMAND (COMPATIBLE-COMTAB-LOOKUP-PROCESSOR ,MOUSE-CHAR ,X ,Y ,ZWEI-WINDOW)
			   ,(COND ((MENU-COMMAND-P COMMAND) "Editor menu")
				  ((CLOSUREP COMMAND)	;keyboard macros...
				   (LET ((SYM (SYMEVAL-IN-CLOSURE COMMAND 'SYMBOL)))
				     (GET SYM 'DOCUMENTATION)))
				  ((GET COMMAND :MOUSE-SHORT-DOCUMENTATION))
				  ((GET COMMAND 'DOCUMENTATION))
				  (T (FORMAT NIL "~A" COMMAND))))))

(DEFUN COMPATIBLE-COMTAB-LOOKUP-PROCESSOR (MOUSE-CHAR X Y ZWEI-WINDOW)
  (LET ((*MOUSE-X* X)
	(*MOUSE-Y* Y))
    (SEND-IF-HANDLES STANDARD-INPUT :RECORD MOUSE-CHAR)
    (LET ((*NON-MOUSE-*WINDOW** *WINDOW*))	;Let hairy mouse commands know where we were
      (IF (AND (NEQ ZWEI-WINDOW *WINDOW*)
	       (NOT (CHAR-MOUSE-EQUAL MOUSE-CHAR #\MOUSE-R)))	;Given in another window,
	  (LET ((*COMTAB* (IF (EQ *WINDOW* *MINI-BUFFER-WINDOW*) *STANDARD-COMTAB* *COMTAB*))
		(*LAST-COMMAND-TYPE* NIL)	;dont confuse mouse mark thing, and
		*CURRENT-COMMAND-TYPE*
		(*WINDOW* ZWEI-WINDOW)
		(*INTERVAL* (WINDOW-INTERVAL ZWEI-WINDOW)))
	    (PROCESS-COMMAND-CHAR MOUSE-CHAR))	;Temporarily act there (mini-buffer)
	  (PROCESS-COMMAND-CHAR MOUSE-CHAR))))
    NIL)

(SCL:DEFINE-PRESENTATION-TRANSLATOR COMPATIBLE-COMTAB-LOOKUP
				    (BP PRESENTATION-COMMAND
				     :GESTURE T :BLANK-AREA T :MENU NIL
				     :TESTER COMPATIBLE-COMTAB-LOOKUP-TESTER)
				    (IGNORE &REST ARGS)
  (LEXPR-FUNCALL #'COMPATIBLE-COMTAB-LOOKUP-TRANSLATOR ARGS))

;;;; Out of date stuff that is still used

;;;Wait for the mouse to do something, return non-nil if released buttons or left window
;;;LAST-X, LAST-Y are relative to the inside of the window (like *MOUSE-X*, *MOUSE-Y*).
(DEFUN WAIT-FOR-MOUSE (LAST-X LAST-Y &OPTIONAL MAX-SPEED)
  (LET ((SHEET (WINDOW-SHEET *WINDOW*)))
    (MULTIPLE-VALUE-BIND (XOFF YOFF MOUSE)
	(TV:SHEET-MOUSE-OFFSETS SHEET)
      (PROCESS-WAIT "Mouse"
		    #'(LAMBDA (LX LY MS SH MOUSE)
			(OR (AND (OR ( (TV:MOUSE-X MOUSE) LX) ( (TV:MOUSE-Y MOUSE) LY))
				 (OR (NULL MS) ( (TV:MOUSE-SPEED MOUSE) MS)))
			    (ZEROP (TV:MOUSE-BUTTONS T MOUSE))
			    (NEQ (TV:MOUSE-WINDOW MOUSE) SH)))
		    (+ LAST-X (TV:SHEET-INSIDE-LEFT SHEET) XOFF)
		    (+ LAST-Y (TV:SHEET-INSIDE-TOP SHEET) YOFF)
		    MAX-SPEED SHEET MOUSE)
      (AND (NOT (ZEROP (TV:MOUSE-BUTTONS T MOUSE)))
	   (EQ SHEET (TV:MOUSE-WINDOW MOUSE))))))

(DEFUN MOUSE-POSITION (&OPTIONAL (WINDOW *WINDOW*))
  (LET ((SHEET (WINDOW-SHEET WINDOW)))
    (MULTIPLE-VALUE-BIND (X Y) (TV:SHEET-MOUSE-POSITION SHEET)
      (VALUES (- X (TV:SHEET-INSIDE-LEFT SHEET))
	      (- Y (TV:SHEET-INSIDE-TOP SHEET))))))

;;; Call MOUSE-CHAR so we can be sure that the BP points the thing that's blinking
;;; If X and Y are supplied, they are the coordinates to use, otherwise
;;; we use the coordinates of where the mouse is now.
(DEFUN MOUSE-BP (WINDOW &OPTIONAL X Y &AUX CHAR LINE CHAR-POS)
  (MULTIPLE-VALUE (CHAR X Y LINE CHAR-POS)
    (MOUSE-CHAR WINDOW T X Y))
  (COND ((NULL CHAR)      ;Couldn't anything, use end of buffer for want of anything better
         (COPY-BP (INTERVAL-LAST-BP (WINDOW-INTERVAL WINDOW))))
        (T
	 (CREATE-BP LINE CHAR-POS))))

;;; The mouse must be in the selected window's area of the screen
;;; Returns the character at which the mouse points, and the X and Y positions
;;; of that character relative to its sheet.  If the mouse is not at a character,
;;; returns NIL.
(DEFUN MOUSE-CHAR (WINDOW &OPTIONAL FIXUP-P X Y)
  (DECLARE (VALUES CHAR X Y LINE CHAR-POS CHAR-WIDTH DIAGRAM))
  (WHEN (NULL Y)
    (MULTIPLE-VALUE (X Y) (MOUSE-POSITION WINDOW)))
  (BLOCK DONE
    (LET ((SHEET (WINDOW-SHEET WINDOW))
	  (PLINE (LET* ((VSP (WINDOW-VSP WINDOW))
			(N-PLINES (WINDOW-N-PLINES WINDOW))
			(BELOW 0)
			(ABOVE N-PLINES))
		   (WHEN (ZEROP N-PLINES)
		     (RETURN-FROM DONE NIL))
		   (LOOP DOING
		     (LET* ((GUESS (// (+ BELOW ABOVE) 2))
			    (PLINE-Y (PLINE-Y WINDOW GUESS)))
		       (COND ((< Y PLINE-Y)
			      (WHEN (ZEROP GUESS)
				(UNLESS FIXUP-P
				  (RETURN-FROM DONE NIL))
				(RETURN 0))
			      (SETQ ABOVE GUESS))
			     (( Y (+ PLINE-Y (PLINE-HEIGHT WINDOW GUESS) VSP))
			      (WHEN ( GUESS (1- N-PLINES))
				(UNLESS FIXUP-P
				  (RETURN-FROM DONE NIL))
				(RETURN (1- N-PLINES)))
			      (SETQ BELOW GUESS))
			     (T
			      (RETURN GUESS))))))))
      (LET* ((LINE (PLINE-LINE WINDOW PLINE))
	     (START (PLINE-FROM-INDEX WINDOW PLINE))
	     (END (MIN (LINE-LENGTH LINE) (PLINE-TO-INDEX WINDOW PLINE)))
	     (Y (PLINE-Y WINDOW PLINE)))
	(MULTIPLE-VALUE-BIND (CHAR-X NIL NIL CHAR-POS)	;Find character to right of mouse
	    (LINE-DISPLAYED-SIZE SHEET LINE START END 0 (MAX 0 X))
	  (WHEN ( CHAR-POS (LINE-LENGTH LINE))		;Mouse is pointing at the CR.
	    (WHEN (ZEROP CHAR-POS)
	      (MULTIPLE-VALUE-BIND (DIAGRAM LINE-MARGIN)
		  (LINE-SPECIAL-REDISPLAY-PROPERTIES LINE)
		(WHEN DIAGRAM
		  (RETURN-FROM DONE (VALUES #\CR
					    (IF LINE-MARGIN
						(LINE-MARGIN-SIZE LINE-MARGIN SHEET LINE)
						0)
					    Y LINE 0 0 DIAGRAM)))))
	    (RETURN-FROM DONE
	      (VALUES #\CR CHAR-X Y LINE END)))
	  (LET* ((CHAR (AREF LINE CHAR-POS))
		 (CHAR-WIDTH (IF (CHAR-EQUAL CHAR #\TAB)
				 (LET ((CHAR+1-X (LINE-DISPLAYED-SIZE SHEET LINE
								      CHAR-POS (1+ CHAR-POS)
								      CHAR-X)))
				   (- CHAR+1-X CHAR-X))
				 (SEND SHEET :CHARACTER-WIDTH CHAR))))
	      (VALUES CHAR
		      CHAR-X
		      (+ Y (- (PLINE-BASELINE WINDOW PLINE)
			      (LET ((FONT (TV:SHEET-GET-CHAR-FONT CHAR NIL SHEET)))
				(IF FONT (FONT-BASELINE FONT)
				    (TV:SHEET-LOZENGE-BASELINE SHEET)))))
		      LINE CHAR-POS CHAR-WIDTH)))))))

;;;; Obsolete stuff, left for reference

#||
;;; Called by the editor to initialize the mouse
(DEFUN INITIALIZE-MOUSE (&AUX (INHIBIT-SCHEDULING-FLAG T))
  (AND (VARIABLE-BOUNDP *MOUSE-CHAR-BLINKER*)
       (TV:OPEN-BLINKER *MOUSE-CHAR-BLINKER*))
  (SETQ *MOUSE-P* NIL
	*MOUSE-CHAR-BLINKER* (TV:MAKE-BLINKER TV:MOUSE-SHEET 'TV:CHARACTER-BLINKER
					      ':VISIBILITY NIL
					      ':HALF-PERIOD 4
					      ':CHAR #/?)
	*MOUSE-BOX-BLINKER* (TV:MAKE-BLINKER TV:MOUSE-SHEET 'TV:HOLLOW-RECTANGULAR-BLINKER
					     ':VISIBILITY NIL)
	*MOUSE-BLINKER* *MOUSE-BOX-BLINKER*
	*GLOBAL-MOUSE-CHAR-BLINKER* (TV:MAKE-BLINKER TV:MOUSE-SHEET
						     'TV:HOLLOW-RECTANGULAR-BLINKER
						     ':VISIBILITY NIL
						     ':HALF-PERIOD 4)
	*GLOBAL-MOUSE-CHAR-BLINKER-HANDLER* NIL
	*GLOBAL-ATOM-UNDER-MOUSE-HANDLER* NIL
	*GLOBAL-MOUSE-CHAR-BLINKER-DOCUMENTATION-STRING* NIL
	*GLOBAL-MOUSE-CHAR-BLINKER-AARRAY* NIL
	*GLOBAL-MOUSE-CHAR-BLINKER-IMPOSSIBLE-IS-OK-P* T
	*GLOBAL-MOUSE-CHAR-BLINKER-MUST-BE-FUNCTION* NIL))

;;; This returns the name of a function, either from the buffer with the mouse, or the
;;; mini-buffer.  MUST-BE-FUNCTION can also be 'LAMBDA-OK to make this function accept
;;; lambda expressions; this is used in e.g. the DIRED "A" (apply) command.
(DEFUN READ-FUNCTION-SPEC (PROMPT &OPTIONAL DEFAULT (MUST-BE-FUNCTION T)
					    HELP (BLANK-LINE-DEFAULTS T))
  (BLOCK READ-FUNCTION-SPEC
    (MULTIPLE-VALUE-BIND (STRING FSPECS)
	(READ-FUNCTION-SPEC-STRING PROMPT DEFAULT *ZMACS-COMPLETION-AARRAY* T
				   MUST-BE-FUNCTION HELP BLANK-LINE-DEFAULTS)
      ;; Kludge to detect typein of lambda expression
      (WHEN (EQ MUST-BE-FUNCTION 'LAMBDA-OK)
	(BARF-ON-ERRORS (SYS:READ-ERROR)
	  (LET ((X (READ-FROM-STRING STRING)))
	    (AND (LISTP X) (EQ (CAR X) 'FUNCTION)
		 (SETQ X (CADR X)))
	    (AND (LISTP X) (EQ (CAR X) 'LAMBDA)
		 (RETURN-FROM READ-FUNCTION-SPEC X)))))
      ;; If completion was used, first weed out things that aren't defined.
      (COND (MUST-BE-FUNCTION
	     (SETQ FSPECS (LOOP FOR FSPEC IN FSPECS
				WHEN (SI:VALID-FUNCTION-DEFINITION FSPEC)
				COLLECT FSPEC))
	     (AND (NULL FSPECS)
		  (MULTIPLE-VALUE-BIND (FSPEC ERROR-P)
		      (SYMBOL-FROM-STRING STRING NIL T)
		    (COND ((AND (NOT ERROR-P)
				(SI:VALID-FUNCTION-DEFINITION FSPEC))
			   (SETQ FSPECS (NCONS FSPEC)))
			  (ERROR-P
			   (IF (EQ ERROR-P T)
			       (BARF "Can't make a function spec out of ~S" STRING)
			       (BARF "~A" ERROR-P)))
			  (T
			   (BARF "~S is not defined" FSPEC)))))))
      (COND ((AND (NOT BLANK-LINE-DEFAULTS) (EQUAL STRING ""))
	     STRING)
	    ((NULL FSPECS)	;If there are no completions left, get from the string
	     (MULTIPLE-VALUE-BIND (FSPEC ERROR-P)
		 (SYMBOL-FROM-STRING STRING NIL T)
	       (COND ((NOT ERROR-P) FSPEC)
		     ((EQ ERROR-P T) (BARF "Can't make a function spec out of ~S" STRING))
		     (T (BARF "~A" ERROR-P)))))
	    ((NULL (CDR FSPECS))	;If there is only one completion, use it
	     (CAR FSPECS))
	    (T			;Else try to match the one in the current package, etc.
	     (LOOP WITH FROM-READING = (SYMBOL-FROM-STRING STRING)
		   FOR FSPEC IN FSPECS
		   WHEN (EQUAL FROM-READING FSPEC) RETURN FSPEC
		   FINALLY (RETURN (CAR FSPECS))))))))

;;; Read the name of a function, either from the buffer with the mouse, or the mini-buffer.
;;; More generally, this can read the name of a definition or any symbol.
;;; This returns a string and optionally a list of function specs, if completion was used,
;;; the mouse was used, or the default was taken.
;;; DEFAULT - a function spec
;;; AARRAY - NIL or a completion aarray to use.  The default is *ZMACS-COMPLETION-AARRAY*.
;;; IMPOSSIBLE-IS-OK-P - passed to TYPEIN-LINE-COMPLETING-READ.  The default is T.
;;;		Also allowed is :SOURCE-FILE-NAME, which is equivalent to T
;;;		for completion but prevents the mouse from highlighting things
;;;		that are neither functions nor completions nor recorded definitions.
;;; MUST-BE-FUNCTION - if non-NIL, accept only functions (not rigidly enforced, just 
;;;			controls mouse highlighting)
;;; HELP is passed to the completing reader.
;;; BLANK-LINE-DEFAULTS - T to special-case blank lines, NIL not to
(DEFUN READ-FUNCTION-SPEC-STRING (PROMPT &OPTIONAL DEFAULT
						   (AARRAY *ZMACS-COMPLETION-AARRAY*)
						   (IMPOSSIBLE-IS-OK-P T)
						   (MUST-BE-FUNCTION NIL)
						   HELP
						   (BLANK-LINE-DEFAULTS T)
					 &AUX TEM CH STR DEFAULT-STRING)
  (IF AARRAY (SORT-COMPLETION-AARRAY AARRAY)
      (SETQ IMPOSSIBLE-IS-OK-P T))
  (SETQ DEFAULT-STRING (AND DEFAULT (FORMAT NIL "~S" DEFAULT)))
  (FLET ((FIX-PACKAGE-AFTER-COMPLETION (ASSOC &OPTIONAL (STR (CAR ASSOC)))
	   ;; Extract the string and the possible completions from ASSOC.
	   ;; If we are completing to symbols, and the user typed a symbol in the
	   ;; current package, don't complete to one in some other package.
	   ;; Passing in an explicit STR argument is useful when what the user typed
	   ;; (or selected with the mouse) may not be the same as what was in the
	   ;; aarray, for instance it might have a package prefix.
	   (POP ASSOC)
	   (WHEN (CL:EVERY #'SYMBOLP ASSOC)
	     (CONDITION-CASE (SYM END-CHAR-POSITION)
		  (READ-FROM-STRING STR)
		(SYS:READ-ERROR )
		(:NO-ERROR
		  (COND ((NSYMBOLP SYM))
			((STRING-SEARCH-NOT-SET *WHITESPACE-CHARS* STR END-CHAR-POSITION))
			((EQ SYM (CAR ASSOC)))
			((MEMQ SYM (CDR ASSOC))
			 (SETQ ASSOC (CONS SYM (REMQ SYM ASSOC))))
			(IMPOSSIBLE-IS-OK-P
			 (SETQ ASSOC (CONS SYM ASSOC)))))))
	   (VALUES STR ASSOC)))
   ;; THROW to MINI-BUFFER-FULL-RUBOUT to try again.
   (DO-NAMED TOP () (NIL)
    (CATCH 'MINI-BUFFER-FULL-RUBOUT
     ;; Read one character from keyboard or click from the mouse
     (COND (*MINI-BUFFER-REPEATED-COMMAND*
	    (SETQ TEM 0 CH NIL))			;C-X Altmode, no opportunity for mouse
	   ((LOOP DOING (MULTIPLE-VALUE (TEM CH)
			  (EDITOR-INPUT :NO-HANG T :MOUSE :RETURN :ANY-TYI 'REDISPLAY))
		  ;; Keep looping if we have an errant selection blip;
		  ;; we need this kludge so that c-X 4 D work correctly
		  WHILE (AND (LISTP CH)
			     (EQ (CAR CH) 'SELECT-WINDOW))
		  FINALLY (RETURN TEM)))
	   (T
	    (WITH-STACK-LIST* (PROMPT1 T PROMPT " (Default: " DEFAULT-STRING ")"
				       (AND AARRAY '((:RIGHT-FLUSH " (Completion)"))))
	      (WITH-STACK-LIST* (PROMPT2 T PROMPT
					 (AND AARRAY '((:RIGHT-FLUSH " (Completion)"))))
		(LET ((*MODE-LINE-LIST* (IF DEFAULT PROMPT1 PROMPT2)))
		  (REDISPLAY-MODE-LINE))))	;Make correct for later
	    (DELETE-INTERVAL (WINDOW-INTERVAL *MINI-BUFFER-WINDOW*))
	    (MUST-REDISPLAY *MINI-BUFFER-WINDOW* DIS-ALL)
	    (SELECT-WINDOW *MINI-BUFFER-WINDOW*)
	    ;;KLUDGE, position blinker
	    (DO L (WINDOW-SPECIAL-BLINKER-LIST *MINI-BUFFER-WINDOW*) (CDR L) (NULL L)
		(TV:BLINKER-SET-VISIBILITY (CDAR L) NIL))
	    (LET ((BL (WINDOW-POINT-BLINKER *MINI-BUFFER-WINDOW*)))
	      (TV:BLINKER-SET-CURSORPOS BL 0 0)
	      (TV:BLINKER-SET-VISIBILITY BL ':BLINK))
	    (LET ((NORMAL-EXIT NIL))
	      (UNWIND-PROTECT
		(LET-GLOBALLY ((*GLOBAL-MOUSE-CHAR-BLINKER-HANDLER*
				 #'BLINK-FOR-READ-FUNCTION-NAME)
			       (*GLOBAL-ATOM-UNDER-MOUSE-HANDLER*
				 (OR (SEND *MAJOR-MODE* :SEND-IF-HANDLES :ATOM-UNDER-MOUSE)
				     #'ATOM-UNDER-MOUSE))
			       (*GLOBAL-MOUSE-CHAR-BLINKER-DOCUMENTATION-STRING*
				 "Click left on highlighted name to select it.")
			       (*GLOBAL-MOUSE-CHAR-BLINKER-AARRAY* AARRAY)
			       (*GLOBAL-MOUSE-CHAR-BLINKER-IMPOSSIBLE-IS-OK-P*
						 IMPOSSIBLE-IS-OK-P)
			       (*GLOBAL-MOUSE-CHAR-BLINKER-MUST-BE-FUNCTION* MUST-BE-FUNCTION)
			       (*MOUSE-FONT-CHAR* #\MOUSE:UP-ARROW)
			       (*MOUSE-X-OFFSET* 4)
			       (*MOUSE-Y-OFFSET* 0))
		  (SETQ TV:MOUSE-RECONSIDER T)
		  (MULTIPLE-VALUE (TEM CH)
		    (EDITOR-INPUT :SCROLL T :MOUSE :RETURN :ANY-TYI 'REDISPLAY))
		  (SETQ NORMAL-EXIT T))
		(TV:BLINKER-SET-VISIBILITY *GLOBAL-MOUSE-CHAR-BLINKER* NIL)
		(SETQ TV:MOUSE-RECONSIDER T)
		(UNLESS NORMAL-EXIT
		  (SELECT-WINDOW *WINDOW*)
		  (DISAPPEAR-MINI-BUFFER-WINDOW))))))
     ;; Now we know whether the user is going to use the keyboard or the mouse
     (COND ((AND (MOUSE-CHAR-P TEM)
		 (CHAR-MOUSE-EQUAL TEM #\MOUSE-1-1)
		 (MULTIPLE-VALUE-BIND (FCTN LINE START END FSTR)
		     (FUNCALL (OR (SEND *MAJOR-MODE* :SEND-IF-HANDLES :ATOM-UNDER-MOUSE)
				  #'ATOM-UNDER-MOUSE)
			      (CADR CH))
		   (WHEN (NOT (NULL START))
		     (COND ((NOT IMPOSSIBLE-IS-OK-P)
			    (SETQ TEM (STRING-IN-AARRAY-P FSTR AARRAY))
			    (WHEN TEM
			      ;; Use the actual string in the aarray to get proper case.
			      (MULTIPLE-VALUE (STR TEM)
				(FIX-PACKAGE-AFTER-COMPLETION TEM (SUBSTRING LINE START END)))
			      T))
			   (T
			    (SETQ TEM (AND AARRAY (STRING-IN-AARRAY-P FSTR AARRAY)))
			    (COND (TEM
				   ;; Use the actual string in the aarray to get proper case.
				   ;; Also useful when the string may be different from the
				   ;; function-name(s), as in foreign languages (e.g. Pascal).
				   (MULTIPLE-VALUE (STR TEM)
				     (FIX-PACKAGE-AFTER-COMPLETION
				       TEM (SUBSTRING LINE START END))))
				  (T
				   ;; Use the actual text that was highlighted by the mouse
				   ;; blinker.
				   ;; One thing this does is to preserve package prefixes.
				   (SETQ STR (SUBSTRING LINE START END))
				   (SETQ TEM (LIST FCTN))))
			    T)))))
	    (SELECT-WINDOW *WINDOW*)
	    (DISAPPEAR-MINI-BUFFER-WINDOW)	 
	    (OR *MINI-BUFFER-COMMAND*
		(SEND *MINI-BUFFER-HISTORY* ':PUSH (SETQ *MINI-BUFFER-COMMAND*
							 `((,*CURRENT-COMMAND*
							    ,*NUMERIC-ARG-P*
							    ,*NUMERIC-ARG*
							    ,*LAST-COMMAND-CHAR*)))))
	    (RPLACD (LAST *MINI-BUFFER-COMMAND*) (NCONS STR))
	    (SEND *DEFINITION-HISTORY* ':PUSH STR)
	    (RETURN-FROM TOP (VALUES STR TEM)))
	   (T
	    ;; Using the keyboard.  Cannot call COMPLETING-READ-FROM-MINI-BUFFER because
	    ;; we want to avoid converting the default to a string and back.
	    (WHEN CH
	      (FUNCALL STANDARD-INPUT ':UNTYI CH))
	    (LET ((NAME (LET ((*POST-COMMAND-HOOK* (CONS 'MINI-BUFFER-FULL-RUBOUT
							 *POST-COMMAND-HOOK*))
			      (*CONTEXT-HISTORY* *DEFINITION-HISTORY*))
			  (WITH-STACK-LIST (PROMPT1 T PROMPT " (Default: " DEFAULT-STRING ")")
			    (WITH-STACK-LIST (PROMPT2 T PROMPT)
			      (SEND *DEFINITION-HISTORY* ':FUNCALL-WITH-DEFAULT
				    DEFAULT-STRING #'COMPLETING-READ-FROM-MINI-BUFFER
				    (IF DEFAULT PROMPT1 PROMPT2)
				    AARRAY IMPOSSIBLE-IS-OK-P NIL HELP))))))
	      (COND ((EQUAL NAME "")
		     (COND (BLANK-LINE-DEFAULTS
			    (OR DEFAULT (BARF "There is no default."))
			    (RETURN-FROM TOP (VALUES DEFAULT-STRING (LIST DEFAULT))))
			   (T (RETURN-FROM TOP NAME))))
		    ((LISTP NAME)
		     (SEND *DEFINITION-HISTORY* ':PUSH (CAR NAME))
		     (RETURN-FROM TOP (FIX-PACKAGE-AFTER-COMPLETION NAME)))
		    (T
		     (SEND *DEFINITION-HISTORY* ':PUSH NAME)
		     (RETURN-FROM TOP NAME)))))))
    ;; Here if MINI-BUFFER-FULL-RUBOUT
    (NBUTLAST *MINI-BUFFER-COMMAND*))))

(DEFUN MINI-BUFFER-FULL-RUBOUT (IGNORE)
  (LET ((INT (WINDOW-INTERVAL *MINI-BUFFER-WINDOW*)))
    (AND (EQ *INTERVAL* INT)
	 (BP-= (INTERVAL-FIRST-BP INT)
	       (INTERVAL-LAST-BP INT))
	 (THROW 'MINI-BUFFER-FULL-RUBOUT T))))

;;; This finds the atom the mouse is pointing to
(DEFUN ATOM-UNDER-MOUSE (WINDOW &OPTIONAL CHAR X Y LINE INDEX &AUX SYMBOL END SYNTAX)
  (DECLARE (VALUES FUNCTION-SPEC LINE START-INDEX END-INDEX STRING))
  (UNLESS CHAR
    (MULTIPLE-VALUE (CHAR X Y LINE INDEX)
      (MOUSE-CHAR WINDOW)))
  (AND CHAR
       (CHAR-NOT-EQUAL CHAR #\CR)
       (LET* ((*INTERVAL* (WINDOW-INTERVAL WINDOW))
	      (*MAJOR-MODE* (OR (SEND-IF-HANDLES *INTERVAL* :GET ':MAJOR-MODE)
				(MAJOR-MODE-FROM-KEYWORD *DEFAULT-LANGUAGE-MODE*)))
	      (*MODE-LIST-SYNTAX-TABLE* (OR (SEND-IF-HANDLES *MAJOR-MODE* :LIST-SYNTAX-TABLE)
					    *LIST-SYNTAX-TABLE*))
	      (*MODE-WORD-SYNTAX-TABLE* (OR (SEND-IF-HANDLES *MAJOR-MODE* :WORD-SYNTAX-TABLE)
					    *ATOM-WORD-SYNTAX-TABLE*)))
	 ;; Slow version if pointing to a paren
	 (IF (OR (= (SETQ SYNTAX (LIST-SYNTAX CHAR)) LIST-OPEN)
		 (= SYNTAX LIST-CLOSE))
	     (LET* ((PACKAGE (OR (SEND-IF-HANDLES *INTERVAL* :GET ':PACKAGE)
				 PACKAGE))
		    (THIS-BP (CREATE-BP LINE (IF (= SYNTAX LIST-OPEN) INDEX
						 (1+ INDEX))))
		    (OTHER-BP (FORWARD-SEXP THIS-BP (IF (= SYNTAX LIST-OPEN) 1 -1)
					    NIL 0 (IF (= SYNTAX LIST-OPEN)
						      (END-OF-LINE LINE)
						      (BEG-OF-LINE LINE))
					    NIL T)))
	       (WHEN OTHER-BP
		 (WHEN (= SYNTAX LIST-CLOSE)
		   (SWAPF THIS-BP OTHER-BP))
		 (LET* ((START-IDX (BP-INDEX THIS-BP))
			(END-IDX (BP-INDEX OTHER-BP))
			(STRING (SUBSTRING LINE START-IDX END-IDX)))
		   (MULTIPLE-VALUE-BIND (FSPEC ERROR-P)
		       (SYMBOL-FROM-STRING STRING LINE NIL)
		     (UNLESS ERROR-P
		       (VALUES FSPEC LINE START-IDX END-IDX STRING))))))
	     ;; Fast version for atom case
	     (DO ((I INDEX (1- I)))
		 ((COND (( WORD-ALPHABETIC (WORD-SYNTAX (AREF LINE I)))
			 (INCF I)
			 T)
			((ZEROP I) T)
			(T NIL))
		  (AND ( I INDEX)
		       (CONDITION-CASE (ERR)
			   (LET ((PACKAGE (OR (SEND-IF-HANDLES *INTERVAL* :GET ':PACKAGE)
					      PACKAGE))
				 (READ-PRESERVE-DELIMITERS T))
			     (MULTIPLE-VALUE (SYMBOL END)
			       (READ-FROM-STRING LINE NIL I))
			     (SETQ END (MIN (ARRAY-ACTIVE-LENGTH LINE) END))
			     T)
			 (ERROR NIL))
		       (SYMBOLP SYMBOL)
		       (VALUES SYMBOL LINE I END (STRING SYMBOL)))))))))

;;; This blinks functions, or whatever, that you point to
;;; This maximum speed thing is a crock, since the mouse can be moving fast
;;; and at the same time have come to rest, such that another :MOUSE-MOVES
;;; message is not going to be sent.  I guess I'll just set the number very high.
;;; This was probably put in to make mouse tracking smoother, and hence is no
;;; longer needed.
(DEFVAR *BLINKING-FUNCTION-MAXIMUM-MOUSE-SPEED* 50.)

(DEFUN BLINK-FOR-READ-FUNCTION-NAME (BLINKER WINDOW CHAR X Y LINE INDEX
				     &AUX SHEET AARRAY IMPOSSIBLE-IS-OK-P MUST-BE-FUNCTION)
  (IF (> TV:MOUSE-SPEED *BLINKING-FUNCTION-MAXIMUM-MOUSE-SPEED*)
      (TV:BLINKER-SET-VISIBILITY BLINKER NIL)	;Moving too fast, forget it
      (MULTIPLE-VALUE-BIND (FSPEC NIL BEG END STRING)
	  (FUNCALL *GLOBAL-ATOM-UNDER-MOUSE-HANDLER*
		   WINDOW CHAR X Y LINE INDEX)
	(SETQ AARRAY *GLOBAL-MOUSE-CHAR-BLINKER-AARRAY*)
	(SETQ IMPOSSIBLE-IS-OK-P *GLOBAL-MOUSE-CHAR-BLINKER-IMPOSSIBLE-IS-OK-P*)
	(SETQ MUST-BE-FUNCTION *GLOBAL-MOUSE-CHAR-BLINKER-MUST-BE-FUNCTION*)
	(COND ((AND (NOT (NULL BEG))
		    (OR IMPOSSIBLE-IS-OK-P (STRING-IN-AARRAY-P STRING AARRAY))
		    (OR (NOT MUST-BE-FUNCTION) (FDEFINEDP FSPEC))
		    (OR (NEQ IMPOSSIBLE-IS-OK-P ':SOURCE-FILE-NAME)
			(FDEFINEDP FSPEC)
			(STRING-IN-AARRAY-P STRING AARRAY)
			(SI:FUNCTION-SPEC-GET FSPEC ':SOURCE-FILE-NAME)))
		(SETQ SHEET (WINDOW-SHEET WINDOW))
		(TV:BLINKER-SET-SHEET BLINKER SHEET)
		(SHEET-SET-BLINKER-CURSORPOS SHEET BLINKER
					     (- X (SEND SHEET ':STRING-LENGTH LINE BEG INDEX))
					     Y)
		(TV:BLINKER-SET-SIZE BLINKER
				     (SEND SHEET ':STRING-LENGTH LINE BEG END)
				     (FONT-CHAR-HEIGHT
				       (TV:SHEET-GET-CHAR-FONT CHAR NIL SHEET)))
		(TV:BLINKER-SET-VISIBILITY BLINKER T))
	       (T
		(TV:BLINKER-SET-VISIBILITY BLINKER NIL))))))
||#

(SCL:DEFINE-PRESENTATION-TRANSLATOR EDITOR-YANK
   (BP SI:INPUT-EDITOR
       :PRIORITY 1				;A little better than DW::YANK-WORD
       :BLANK-AREA T
       :GESTURE :YANK-WORD
       :DO-NOT-COMPOSE T
       :TESTER ((BP &KEY WINDOW)
		(OR BP
		    (OPERATION-HANDLED-P WINDOW :ZWEI-WINDOW)))
       :DOCUMENTATION
       ((BP &REST ARGS)
	(MULTIPLE-VALUE-BIND (BP1 BP2)
	    (LEXPR-FUNCALL #'EDITOR-YANK-INTERNAL BP ARGS)
	  (LET ((LINE (BP-LINE BP1)))
	    (LEXPR-FUNCALL
	      #'DW::YANK-WORD-DOCUMENTATION-INTERVAL
	      LINE (BP-INDEX BP1) (IF (EQ (BP-LINE BP2) LINE)
				      (BP-INDEX BP2)
				    (LINE-LENGTH LINE))
	      ARGS))))
       :MENU :MARKING-AND-YANKING)
   (BP &REST ARGS)
  (MULTIPLE-VALUE-BIND (BP1 BP2)
      (LEXPR-FUNCALL #'EDITOR-YANK-INTERNAL BP ARGS)
    (STRING-INTERVAL BP1 BP2)))

(DEFUN EDITOR-YANK-INTERNAL (BP &KEY WINDOW X Y &ALLOW-OTHER-KEYS)
  (WHEN (NULL BP)
    (SETQ BP (MOUSE-BP (SEND WINDOW :ZWEI-WINDOW) X Y)))
  (LET ((*INTERVAL* (BP-TOP-LEVEL-NODE BP)))
    (LET-BUFFER-VARIABLE (*KILL-INTERVAL-SMARTS* T)
      (LET ((BP1 (COPY-BP BP))
	    (BP2 (COPY-BP BP)))
	(LET-IF (NOT (VARIABLE-BOUNDP *MODE-LIST-SYNTAX-TABLE*))
		((*MODE-LIST-SYNTAX-TABLE* *LIST-SYNTAX-TABLE*))
	  ;; Do what mouse-Middle, clicked on the buffer we are now
	  ;; pointing at, would do, but in Lisp Mode.
	  ;;
	  (LISP-MARK-THING BP1 BP2 (BP-CHAR BP) (BP-LINE BP) (BP-INDEX BP))
	  (GET-INTERVAL BP1 BP2 NIL)
	  (VALUES BP1 BP2))))))

;;; There are 13 possible cases.  Rules are:
;;;  Never allow click outside of this editor window set.
;;;  Always allow click in the selected window.
;;;  Never allow click when the mini-buffer is selected, so that
;;;   the sensitivity of the whole function spec takes precedence.
;;;  *MOUSE-CLICK-ALWAYS-SELECTS* makes all clicks automatically select too.
;;;  Clicks other than left work temporarily.
(DEFUN DISABLE-FOR-OTHER-WINDOW-TESTER (WINDOW SELECT-P)
  (COND ((EQ WINDOW *WINDOW*) T)
	((EQ *WINDOW* *MINI-BUFFER-WINDOW*) NIL)
	((NOT (MEMBER WINDOW *WINDOW-LIST*)) NIL)
	(*MOUSE-CLICK-ALWAYS-SELECTS* T)
	(SELECT-P NIL)
	(T T)))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR MOVE-POINT
			     (BP "Move point" *STANDARD-COMTAB*
			      :GESTURE :SELECT :MENU NIL
			      :TESTER ((BP &KEY WINDOW)
				       (WHEN WINDOW
					 (LET ((ZWEI-WINDOW (SEND-IF-HANDLES WINDOW
									     :ZWEI-WINDOW)))
					   (OR (NULL ZWEI-WINDOW)
					       (AND (DISABLE-FOR-OTHER-WINDOW-TESTER
						      ZWEI-WINDOW T)
						    (NODE-IN-BUFFER-P
						      (BP-NODE BP)
						      (WINDOW-INTERVAL ZWEI-WINDOW))))))))
			     (BP &KEY X Y WINDOW)
  (LET ((WINDOW (SEND-IF-HANDLES WINDOW :ZWEI-WINDOW)))
    (IF WINDOW
	`(MOVE-POINT-AND-MAYBE-HOLD ,BP ,X ,Y ,WINDOW)
	`(MOVE-POINT ,BP))))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR MOVE-POINT-1
			     (BP "Move point" *STANDARD-COMTAB*
			      :GESTURE :HOLD-AND-MARK-REGION :MENU NIL
			      :TESTER ((BP &KEY WINDOW)
				       (WHEN WINDOW
					 (LET ((ZWEI-WINDOW (SEND-IF-HANDLES WINDOW
									     :ZWEI-WINDOW)))
					   (OR (NULL ZWEI-WINDOW)
					       (AND (DISABLE-FOR-OTHER-WINDOW-TESTER
						      ZWEI-WINDOW T)
						    (NODE-IN-BUFFER-P
						      (BP-NODE BP)
						      (WINDOW-INTERVAL ZWEI-WINDOW))))))))
			     (BP &KEY X Y WINDOW)
  (LET ((WINDOW (SEND-IF-HANDLES WINDOW :ZWEI-WINDOW)))
    (IF WINDOW
	`(MOVE-POINT-AND-MAYBE-HOLD ,BP ,X ,Y ,WINDOW)
	`(MOVE-POINT ,BP))))

(DEFUN MOVE-POINT-AND-MAYBE-HOLD (BP LAST-X LAST-Y WINDOW)
  (WHEN (AND *MOUSE-CLICK-ALWAYS-SELECTS* (NEQ WINDOW *WINDOW*))
    (MAKE-WINDOW-CURRENT WINDOW))
  (LET ((POINT (WINDOW-POINT WINDOW))
	(MARK (WINDOW-MARK WINDOW)))
    (MOVE-WINDOW-MARK WINDOW BP)
    (SETF (WINDOW-MARK-P WINDOW) T)
    (LOOP DOING
      (MOVE-WINDOW-POINT WINDOW BP)
      (MUST-REDISPLAY WINDOW DIS-BPS)
      (REDISPLAY WINDOW :POINT)
      (UNLESS (WAIT-FOR-MOUSE LAST-X LAST-Y)
	(RETURN NIL))
      (MULTIPLE-VALUE (LAST-X LAST-Y)
	(MOUSE-POSITION))
      (SETQ BP (MOUSE-BP WINDOW LAST-X LAST-Y)))
    (WHEN (BP-= POINT MARK)
      (SETF (WINDOW-MARK-P WINDOW) NIL)))
  ;; Return NIL in case called from PROCESS-SPECIAL-COMMAND
  NIL)

;;; Clicking outside of real text
(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR MOVE-TO-END-OF-NEARBY-LINE
			     (DW:NO-TYPE
			       "Move to end of this line" *STANDARD-COMTAB*
			       :GESTURE :SELECT :MENU NIL
			       :TESTER ((IGNORE &KEY WINDOW)
					(LET ((ZWEI-WINDOW (SEND-IF-HANDLES WINDOW
									    :ZWEI-WINDOW)))
					  (WHEN ZWEI-WINDOW
					    (DISABLE-FOR-OTHER-WINDOW-TESTER
					      ZWEI-WINDOW T)))))
			     (IGNORE &KEY X Y WINDOW)
  (LET ((ZWEI-WINDOW (SEND-IF-HANDLES WINDOW :ZWEI-WINDOW)))
    `(MOVE-TO-END-OF-NEARBY-LINE ,ZWEI-WINDOW ,X ,Y)))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR MOVE-TO-END-OF-NEARBY-LINE-1
			     (DW:NO-TYPE
			       "Move to end of this line" *STANDARD-COMTAB*
			       :GESTURE :HOLD-AND-MARK-REGION :MENU NIL
			       :TESTER ((IGNORE &KEY WINDOW)
					(LET ((ZWEI-WINDOW (SEND-IF-HANDLES WINDOW
									    :ZWEI-WINDOW)))
					  (WHEN ZWEI-WINDOW
					    (DISABLE-FOR-OTHER-WINDOW-TESTER
					      ZWEI-WINDOW T)))))
			     (IGNORE &KEY X Y WINDOW)
  (LET ((ZWEI-WINDOW (SEND-IF-HANDLES WINDOW :ZWEI-WINDOW)))
    `(MOVE-TO-END-OF-NEARBY-LINE ,ZWEI-WINDOW ,X ,Y)))

(DEFUN MOVE-TO-END-OF-NEARBY-LINE (WINDOW X Y)
  (LET ((BP (MOUSE-BP WINDOW X Y)))
    (UNLESS (NODE-IN-BUFFER-P (BP-NODE BP) (WINDOW-INTERVAL WINDOW))
      (REDISPLAY WINDOW :POINT NIL NIL T)
      (SETQ BP (MOUSE-BP WINDOW X Y)))
    (MOVE-POINT-AND-MAYBE-HOLD BP X Y WINDOW)))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR MARK-THING
			     (BP
			      (IF (OR (NULL BP) (END-LINE-P BP)) "Mark line" "Mark word")
			      *STANDARD-COMTAB*
			      :BLANK-AREA T
			      :TESTER ((IGNORE &KEY WINDOW)
				       (LET ((ZWEI-WINDOW (SEND-IF-HANDLES WINDOW
									   :ZWEI-WINDOW)))
					 (AND ZWEI-WINDOW
					      (DISABLE-FOR-OTHER-WINDOW-TESTER
						ZWEI-WINDOW NIL))))
			      :GESTURE :MIDDLE	;Not :MARK-WORD for now.
			      :MENU :MARKING-AND-YANKING)
			     (BP &KEY X Y WINDOW)
  `(MOUSE-MARK-THING ,BP ,X ,Y ,(SEND WINDOW :ZWEI-WINDOW)))

(DEFUN MOUSE-MARK-THING (BP LAST-X LAST-Y WINDOW)
  (LET ((LAST-LINE NIL)
	(LAST-CHAR-POS NIL))
    (LOOP DOING
      (MULTIPLE-VALUE-BIND (CHAR NIL NIL LINE CHAR-POS)
	  (IF (AND LAST-X LAST-Y)
	      (MOUSE-CHAR WINDOW NIL LAST-X LAST-Y)
	      (VALUES (BP-CHAR BP) NIL NIL (BP-LINE BP) (BP-INDEX BP)))
	(WHEN (AND CHAR (OR (NEQ LINE LAST-LINE) ( CHAR-POS LAST-CHAR-POS)))
	  (MOVE-WINDOW-POINT WINDOW LINE CHAR-POS)
	  (WITH-BP (POINT (WINDOW-POINT WINDOW))
	    (WITH-BP (MARK (WINDOW-MARK WINDOW))
	      (SEND (SEND *INTERVAL* :MAJOR-MODE)
		    :Mouse-MARK-THING POINT MARK CHAR LINE CHAR-POS)
	      (MOVE-WINDOW-POINT WINDOW POINT)
	      (MOVE-WINDOW-MARK WINDOW MARK)))
	  (SETF (WINDOW-MARK-P WINDOW) T)
	  (MUST-REDISPLAY WINDOW DIS-BPS)
	  (REDISPLAY WINDOW :POINT)
	  (SETQ LAST-LINE LINE LAST-CHAR-POS CHAR-POS)))
      (UNLESS (AND LAST-X LAST-Y (WAIT-FOR-MOUSE LAST-X LAST-Y))
	(RETURN NIL))
      (MULTIPLE-VALUE (LAST-X LAST-Y)
	(MOUSE-POSITION)))))

(DEFUN SWITCH-WINDOWS-TESTER (IGNORE &KEY WINDOW &ALLOW-OTHER-KEYS)
  (LET ((ZWEI-WINDOW (SEND-IF-HANDLES WINDOW :ZWEI-WINDOW)))
    (AND ZWEI-WINDOW
	 (NEQ *WINDOW* ZWEI-WINDOW)
	 (MEMBER ZWEI-WINDOW *WINDOW-LIST*)
	 (NEQ *WINDOW* *MINI-BUFFER-WINDOW*)
	 (NOT *MOUSE-CLICK-ALWAYS-SELECTS*))))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR SWITCH-WINDOWS
			     (BP "Select this window" *STANDARD-COMTAB*
			      :TESTER SWITCH-WINDOWS-TESTER
			      :BLANK-AREA T
			      :GESTURE :SELECT)
			     (IGNORE &KEY WINDOW)
  `(MAKE-WINDOW-CURRENT ,(SEND WINDOW :ZWEI-WINDOW)))

(DEFUN MOUSE-SELECT-BP (&KEY (WINDOW *WINDOW*)
			(DOCUMENTATION "L: select this position.")
			(MOUSE-ICON #\MOUSE:DOWN-ARROW)
			(WHOSTATE "Select position")
			)
  (WITH-THIS-PROCESS-MOUSE-FONT-CHAR (MOUSE-ICON)
    (LET* ((SHEET (WINDOW-SHEET WINDOW))
	   (MOUSE (TV:SHEET-MOUSE SHEET)))
      (UNWIND-PROTECT
	  (PROGN
	    (SETF (TV:MOUSE-RECONSIDER MOUSE) T)
	    (DW::TRACKING-MOUSE (SHEET :WHOSTATE WHOSTATE)
	      (:PRESENTATION (PRESENTATION)
	       (SEND SHEET :SET-HIGHLIGHTED-PRESENTATION PRESENTATION
		     (AND PRESENTATION
			  (DW:PRESENTATION-SUBTYPEP (DW:PRESENTATION-TYPE PRESENTATION) 'BP)
			  DOCUMENTATION)))
	      (:PRESENTATION-CLICK (CLICK PRESENTATION)
	       (RETURN
		 (WHEN (AND (ZL:CHAR-MOUSE-EQUAL CLICK #\Mouse-Left)
			    PRESENTATION
			    (DW:PRESENTATION-SUBTYPEP (DW:PRESENTATION-TYPE PRESENTATION) 'BP))
		   (DW::PRESENTATION-OBJECT PRESENTATION))))))
	(SETF (TV:MOUSE-RECONSIDER MOUSE) T)))))

;;;; Semi-obsolete mouse commands.

;;; Didn't bother to write replacements for these, because they aren't
;;; so mouse specific, really.

(DEFPROP COM-MOUSE-MOVE-REGION "Move to point" :MOUSE-SHORT-DOCUMENTATION)
(DEFCOM COM-MOUSE-MOVE-REGION "Select window, or adjust the region.
If there is a region, jump the mouse to point or mark (whichever
is closer), and move it with the mouse as long as the button is
held down.  If there is no region, select the window without
affecting point (or mark)." (KM)
  (LET ((SHEET (WINDOW-SHEET *WINDOW*))
	PX PY MX MY MOVE-POINT BP1 LAST-X LAST-Y)
    (MULTIPLE-VALUE (MX MY)
        (FIND-BP-IN-WINDOW-COORDS (MARK) *WINDOW*))
    (MULTIPLE-VALUE (PX PY)
        (FIND-BP-IN-WINDOW-COORDS (POINT) *WINDOW*))
    (AND (NULL PX) (BARF))
    (MULTIPLE-VALUE (LAST-X LAST-Y) (MOUSE-POSITION))
    (SETQ MOVE-POINT (COND ((NOT (AND (WINDOW-MARK-P *WINDOW*) MX)) T)
			   ((< (+ (^ (- LAST-X PX) 2) (^ (- LAST-Y PY) 2))
			       (+ (^ (- LAST-X MX) 2) (^ (- LAST-Y MY) 2)))
			    T)
			   (T
			    (SETQ PX MX PY MY)
			    NIL)))
    (FUNCALL SHEET ':SET-MOUSE-CURSORPOS
		   (+ PX (// (TV:SHEET-CHAR-WIDTH SHEET) 2))
		   (+ PY (// (* 3 (TV:SHEET-LINE-HEIGHT SHEET)) 4)))
    (DO ()
        (NIL)
      (OR (WAIT-FOR-MOUSE LAST-X LAST-Y) (RETURN NIL))
      (MULTIPLE-VALUE (LAST-X LAST-Y) (MOUSE-POSITION))
      (SETQ BP1 (MOUSE-BP *WINDOW* LAST-X LAST-Y))
      (IF MOVE-POINT
	  (MOVE-POINT BP1)
	  (MOVE-MARK BP1))
      (MUST-REDISPLAY *WINDOW* DIS-BPS)
      (REDISPLAY *WINDOW* ':POINT)))
  (INSURE-REGION-REACHABLE ':TEXT)
  DIS-NONE)

(DEFUN LISP-MARK-THING (POINT MARK CHAR LINE CHAR-POS)
  (ATOM-WORD-SYNTAX-BIND
    (SELECT (LIST-SYNTAX CHAR)
      ((LIST-OPEN LIST-SINGLE-QUOTE)
       (MOVE-BP MARK (FORWARD-SEXP POINT 1 T)))
      (LIST-CLOSE
       (MOVE-BP POINT (FORWARD-CHAR POINT 1))
       (MOVE-BP MARK (FORWARD-SEXP POINT -1 T 0 NIL NIL) ))
      ((LIST-DOUBLE-QUOTE LIST-VERTICAL-BAR)
       (COND ((LISP-BP-SYNTACTIC-CONTEXT POINT)
	      (MOVE-BP POINT (FORWARD-CHAR POINT 1 T))
	      (MOVE-BP MARK (FORWARD-SEXP POINT -1 T)))
	     (T
	      (MOVE-BP MARK (FORWARD-SEXP POINT 1 T)))))
      (LIST-COMMENT
       (MOVE-BP POINT (BACKWARD-OVER *BLANKS* POINT))
       (MOVE-BP MARK LINE (LINE-LENGTH LINE)))
      (OTHERWISE
       (DEFAULT-MARK-THING POINT MARK CHAR LINE CHAR-POS)))))

(DEFUN TEXT-MARK-THING (POINT MARK CHAR LINE CHAR-POS)
  (COND ((MEM #'CHAR-EQUAL CHAR '(#/. #/? #/!))
         (MOVE-BP POINT (FORWARD-CHAR POINT 1))
         (MOVE-BP MARK (FORWARD-SENTENCE POINT -1 T)))
        ((MEM #'CHAR-EQUAL CHAR '(#/: #/; #/,))
         (MOVE-BP MARK (FORWARD-OVER *BLANKS*
				     (FORWARD-CHAR
				       (SEARCH-SET POINT
						   (IF (CHAR-EQUAL CHAR #/,)
						       '(#/. #/? #/! #/: #/; #/,)
						     '(#/, #/? #/! #/: #/;))
						   T T)
				       1 T)))
         (MOVE-BP POINT (FORWARD-CHAR POINT 1)))
        ((AND (CHAR-EQUAL CHAR #\CR) (ZEROP CHAR-POS))
	 (LET ((INT (PARAGRAPH-INTERVAL (CREATE-BP LINE CHAR-POS))))
	   (MOVE-BP POINT (INTERVAL-FIRST-BP INT))
	   (MOVE-BP MARK (INTERVAL-LAST-BP INT))))
	(T
         (DEFAULT-MARK-THING POINT MARK CHAR LINE CHAR-POS))))

(DEFUN DEFAULT-MARK-THING (POINT MARK CHAR LINE CHAR-POS &AUX TEM)
  (COND ((CHAR-EQUAL CHAR #\PAGE)
         (MOVE-BP MARK (FORWARD-PAGE POINT -1 T)))
        ((MEM #'CHAR-EQUAL CHAR '(#\SP #\TAB))
         (COND ((STRING-REVERSE-SEARCH-NOT-SET *BLANKS* LINE CHAR-POS)
                (MOVE-BP MARK (FORWARD-WORD POINT 1 T)))
               (T
                (MOVE-BP POINT LINE 0)
                (MOVE-BP MARK LINE (LINE-LENGTH LINE)))))
        ((CHAR-EQUAL CHAR #\CR)
         (MOVE-BP MARK LINE 0))
        ((SETQ TEM (ASS #'CHAR-EQUAL
			CHAR '((#/( . #/)) (#/[ . #/]) (#/< . #/>) (#/{ . #/}))))
	 (SETQ TEM (CDR TEM))
	 (MOVE-BP MARK
		  (LET ((LEVEL 0))
		    (CHARMAP (POINT (INTERVAL-LAST-BP *INTERVAL*) (CHARMAP-BP-BEFORE))
		      (LET ((CH (CHARMAP-CHAR)))
			(COND ((CHAR-EQUAL CH CHAR) (INCF LEVEL))
			      ((CHAR-EQUAL CH TEM)
			       (UNLESS (PLUSP (DECF LEVEL))
				 (CHARMAP-RETURN (CHARMAP-BP-AFTER))))))))))
        ((SETQ TEM (RASS #'CHAR-EQUAL
			 CHAR '((#/( . #/)) (#/[ . #/]) (#/< . #/>) (#/{ . #/}))))
         (SETQ TEM (CAR TEM))
	 (MOVE-BP POINT (FORWARD-CHAR POINT 1 T))
         (MOVE-BP MARK
		  (LET ((LEVEL 0))
		    (RCHARMAP (POINT (INTERVAL-FIRST-BP *INTERVAL*) (RCHARMAP-BP-AFTER))
		      (LET ((CH (RCHARMAP-CHAR)))
			(COND ((CHAR-EQUAL CH CHAR) (INCF LEVEL))
			      ((CHAR-EQUAL CH TEM)
			       (UNLESS (PLUSP (DECF LEVEL))
				 (RCHARMAP-RETURN (RCHARMAP-BP-BEFORE))))))))))
        (T
         (MOVE-BP MARK (FORWARD-WORD POINT 1 T))
         (MOVE-BP POINT (FORWARD-WORD MARK -1 T))
         ;; Now try to attach the right whitespace to the word
	 (OR *KILL-INTERVAL-SMARTS*
	     (LET ((BP (FORWARD-OVER *BLANKS* MARK)))
	       (COND ((NOT (BP-= BP MARK))
		      (MOVE-BP MARK BP))
		     (T
		      (SETQ BP (BACKWARD-OVER *BLANKS* POINT))
		      (OR (ZEROP (BP-INDEX BP)) (MOVE-BP POINT BP))))))))) 

(DEFPROP COM-MOUSE-KILL-YANK "Save//Kill//Yank" :MOUSE-SHORT-DOCUMENTATION)
(DEFCOM COM-MOUSE-KILL-YANK "Kill region, unkill, or unkill pop.
If there is a region, save it; if it was saved last time, kill it;
else if the last command was an unkill, do unkill-pop, else unkill." ()
  (COND ((EQ *LAST-COMMAND-TYPE* 'SAVE)
	 (WITH-INTERVAL-WRITE-LOCKED ((POINT) (MARK))
	   (KILL-INTERVAL (POINT) (MARK) NIL T NIL NIL))
         DIS-TEXT)
        ((WINDOW-MARK-P *WINDOW*)
         (SETQ *CURRENT-COMMAND-TYPE* 'SAVE)
         (COM-SAVE-REGION))
	((EQ *LAST-COMMAND-TYPE* 'YANK)
	 (COM-YANK-POP))
	(T
	 (COM-YANK))))
     
;;--- This could use some interval locking
(DEFCOM COM-MOUSE-INDENT-RIGIDLY "Track indentation with the mouse.
If there is a region, moves the whole region, else the current line.  Continues until the
mouse is released." (KM)
  (LET* ((POINT (POINT))
	 (START-LINE)
	 (END-LINE)
	 (SHEET (WINDOW-SHEET *WINDOW*))
	 (MOUSE (TV:SHEET-MOUSE SHEET)))
    (IF (WINDOW-MARK-P *WINDOW*)		;If there is a region, use it
	(REGION (BP1 BP2 :ENFORCE-SINGLE-SECTION T)
	  (SETQ START-LINE (BP-LINE BP1)
		END-LINE (BP-LINE BP2))
	  (UNLESS (ZEROP (BP-INDEX BP2))
	    (SETQ END-LINE (LINE-NEXT-IN-BUFFER END-LINE))))
	(SETQ START-LINE (BP-LINE POINT)
	      END-LINE (LINE-NEXT-IN-BUFFER START-LINE)))
    (MULTIPLE-VALUE-BIND (X Y)
	(FIND-BP-IN-WINDOW-COORDS (FORWARD-OVER *BLANKS* (BEG-OF-LINE START-LINE)) *WINDOW*)
      (SEND SHEET ':SET-MOUSE-CURSORPOS (OR X 0) (OR Y 0)))
    (PROCESS-WAIT "Mouse" #'(LAMBDA () (OR (ZEROP (TV:MOUSE-LAST-BUTTONS MOUSE))
					   (NEQ SHEET (TV:MOUSE-WINDOW MOUSE)))))
    (DO ((LAST-X)
	 (LAST-Y)
	 (BP (COPY-BP POINT))
	 (DELTA))
	(NIL)
      (MULTIPLE-VALUE (LAST-X LAST-Y) (MOUSE-POSITION))
      (SETQ DELTA (LINE-INDENTATION START-LINE SHEET))
      (MOVE-BP BP START-LINE 0)
      (INDENT-LINE BP (MAX 0 LAST-X) SHEET)
      (SETQ DELTA (- (LINE-INDENTATION START-LINE SHEET) DELTA))
      (OR (= DELTA 0)
	  (DO ((LINE START-LINE (LINE-NEXT-IN-BUFFER LINE)))
	      ((EQ LINE END-LINE))
	    (AND (NEQ LINE START-LINE)
		 (INDENT-LINE (MOVE-BP BP LINE 0)
			      (MAX 0 (+ DELTA (LINE-INDENTATION LINE SHEET))) SHEET))))
      (MUST-REDISPLAY *WINDOW* DIS-TEXT)
      (REDISPLAY *WINDOW* ':POINT)
      (OR (WAIT-FOR-MOUSE LAST-X LAST-Y 5) (RETURN NIL))))
  (INSURE-REGION-REACHABLE ':TEXT)
  DIS-TEXT)

(DEFCOM COM-MOUSE-INDENT-UNDER "Indent the current line as selected by the mouse." (KM)
  (LET ((BP (MOUSE-SELECT-BP :DOCUMENTATION
			     "Left: Indent current line to position of character under the mouse."
			     :WHOSTATE "Indent under")))
    (WHEN BP
      (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
	(INDENT-LINE (POINT) (BP-INDENTATION (MOUSE-BP *WINDOW*)))
	(INDENT-BP-ADJUSTMENT (POINT)))
      DIS-TEXT)))

;;;; Obsolete mouse commands

#||
;;; Single click on the left button.
(DEFPROP COM-MOUSE-MARK-REGION "Move point" :MOUSE-SHORT-DOCUMENTATION)
(DEFCOM COM-MOUSE-MARK-REGION "Jump point and mark to where the mouse is.
Then as the mouse is moved with the button held down point follows the mouse." (KM)
  (REDISPLAY *WINDOW* ':NONE NIL NIL T)		;Force to completion so we don't jump to a
						;line that is not part of the current buffer.
  (LET ((POINT (POINT))
	(MARK (MARK))
	(OLD-REGION-P (WINDOW-MARK-P *WINDOW*))
	(BP (MOUSE-BP *WINDOW* *MOUSE-X* *MOUSE-Y*)))
    (MOVE-MARK BP)
    (SETF (WINDOW-MARK-P *WINDOW*) T)
    (DO ((LAST-X *MOUSE-X*)
	 (LAST-Y *MOUSE-Y*))
	(NIL)
      (MOVE-POINT BP)
      (MUST-REDISPLAY *WINDOW* DIS-BPS)
      (REDISPLAY *WINDOW* ':POINT)
      (OR (WAIT-FOR-MOUSE LAST-X LAST-Y) (RETURN NIL))
      (MULTIPLE-VALUE (LAST-X LAST-Y) (MOUSE-POSITION))
      (SETQ BP (MOUSE-BP *WINDOW* LAST-X LAST-Y)))
    (WHEN (BP-= POINT MARK)
      (SETF (WINDOW-MARK-P *WINDOW*) OLD-REGION-P)))
  (INSURE-REGION-REACHABLE ':TEXT)
  DIS-NONE)

(DEFPROP COM-MOUSE-MARK-THING "Mark thing" :MOUSE-SHORT-DOCUMENTATION)

(DEFCOM COM-MOUSE-MARK-THING "Mark the thing you are pointing at." (SM)
  (DO ((POINT (POINT))
       (MARK (MARK))
       (LAST-X *MOUSE-X*)
       (LAST-Y *MOUSE-Y*)
       (X) (Y) (CHAR) (LINE) (CHAR-POS) (OL) (OCP))
      (NIL)
    (MULTIPLE-VALUE (CHAR X Y LINE CHAR-POS)
	(MOUSE-CHAR *WINDOW* NIL LAST-X LAST-Y))	;Figure out where mouse is
    (COND ((AND CHAR (OR (NEQ LINE OL) ( CHAR-POS OCP)))
	   (SETQ OL LINE OCP CHAR-POS)
	   (MOVE-POINT LINE CHAR-POS)
	   (SEND (SEND *INTERVAL* :MAJOR-MODE)
		 ':MOUSE-MARK-THING POINT MARK CHAR LINE CHAR-POS)
	   (MUST-REDISPLAY *WINDOW* DIS-BPS)
	   (REDISPLAY *WINDOW* ':POINT)))
    (OR (WAIT-FOR-MOUSE LAST-X LAST-Y) (RETURN NIL))
    (MULTIPLE-VALUE (LAST-X LAST-Y) (MOUSE-POSITION)))
  (INSURE-REGION-REACHABLE ':TEXT)
  DIS-NONE)

(DEFCOM COM-MOUSE-END-OF-MINI-BUFFER "Finish up the mini-buffer command" ()
  (COND ((NEQ *WINDOW* *MINI-BUFFER-WINDOW*)
	 (COMMAND-EXECUTE (COMMAND-LOOKUP #\MOUSE-1-2 *STANDARD-COMTAB*) #\MOUSE-1-2))
	(T
	 (KEY-EXECUTE #\c-CR))))

;;; This is on mouse-right in the completing-reader, give a menu of the possibilities
(DEFCOM COM-MOUSE-LIST-COMPLETIONS "Give a menu of possible completions" ()
  (MULTIPLE-VALUE-BIND (NIL POSS)
      (COMPLETE-STRING (BP-LINE (POINT)) *COMPLETING-ALIST* *COMPLETING-DELIMS*)
    (OR POSS (BARF))
    (LOOP FOR POS ON POSS
	  DO (SETF (CAR POS) `(,(CAAR POS) :VALUE ,(CAR POS))))
    (SETQ POSS (SORTCAR POSS #'STRING-LESSP))
    (LET ((CHOICE (LET ((TV:*ORDER-MENU-COLUMNWISE* T))
		    (TV:MENU-CHOOSE POSS))))
      (IF CHOICE
	  (THROW 'RETURN-FROM-COMMAND-LOOP CHOICE)
	  DIS-NONE))))

(DEFPROP COM-COPY-MOUSE "Copy thing" :MOUSE-SHORT-DOCUMENTATION)
(DEFCOM COM-COPY-MOUSE
	"Move to current point whatever mouse click middle would get.  Lisp objects preferred."
	()
  (MULTIPLE-VALUE-BIND (CHAR NIL NIL LINE CHAR-POS)
      (MOUSE-CHAR *WINDOW* NIL *MOUSE-X* *MOUSE-Y*)	;Figure out where mouse is
    (WHEN CHAR
      (LET-BUFFER-VARIABLE (*KILL-INTERVAL-SMARTS* T)	;*window* etc are where mouse clicked
	(LET ((BP1 (CREATE-BP LINE CHAR-POS))
	      (BP2 (CREATE-BP LINE CHAR-POS)))
	  ;; Do what mouse-Middle, clicked on the buffer we are now
	  ;; pointing at, would do, but in Lisp Mode.
	  (LISP-MARK-THING BP1 BP2 CHAR LINE CHAR-POS)
	  ;; Yank that region
	  (SETQ *CURRENT-COMMAND-TYPE* 'YANK)
	  (LET* ((*WINDOW* *NON-MOUSE-*WINDOW**)
		 (*INTERVAL* (WINDOW-INTERVAL *WINDOW*)))
	    (LET-BUFFER-VARIABLE (*KILL-INTERVAL-SMARTS* T)	;...and where you were looking
	      (YANK-TEXT (STRING-INTERVAL BP1 BP2) NIL)
	      (MUST-REDISPLAY *WINDOW* DIS-TEXT)
	      (REDISPLAY *WINDOW* ':POINT)))))))
  DIS-NONE)
||#
