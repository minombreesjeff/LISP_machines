;;; -*- Syntax: Zetalisp; Base: 8; Mode: LISP; Package: ZWEI -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This file contains utility functions for manipulating files, and various
;;; commands to do I/O to intervals.  It does not know about buffers and such,
;;; just intervals.

;;; Get a pathname from the user, return as a pathname actor.
(DEFVAR *READING-PATHNAME-DEFAULTS*)
(DEFVAR *READING-PATHNAME-SPECIAL-TYPE*)
(DEFVAR *READING-PATHNAME-SPECIAL-VERSION*)
(DEFVAR *READING-PATHNAME-DIRECTION*)

; This is the old READ-DEFAULTED-PATHNAME.  Converted to use of a modern arglist,
; and replaced with a differently named function, ACCEPT-DEFAULTED-PATHNAME,
; because of compatibility considerations: we don't want to break user code that
; may use this Zwei internal.  Callers in system converted 4/22/87 12:53 by Dodds.
(COMPILER:MAKE-OBSOLETE READ-DEFAULTED-PATHNAME "Use ZWEI:ACCEPT-DEFAULTED-PATHNAME instead.")
(DEFUN READ-DEFAULTED-PATHNAME (PROMPT DEFAULTS
				&OPTIONAL SPECIAL-TYPE
					  (SPECIAL-VERSION :NEWEST)
					  (DIRECTION :READ)
					  (MERGE-IN-SPECIAL-VERSION T))
  (ACCEPT-DEFAULTED-PATHNAME PROMPT DEFAULTS
			     :SPECIAL-TYPE SPECIAL-TYPE
			     :SPECIAL-VERSION SPECIAL-VERSION
			     :DIRECTION DIRECTION
			     :MERGE-IN-SPECIAL-VERSION MERGE-IN-SPECIAL-VERSION))

;;; This does the work of reading a defaulted pathname.  In a limited set of
;;; cases, it is desired, for UI reasons, to save the user's typein (intensional
;;; spec) in the pathname history, rather than the result of merging the typein
;;; with the default (extensional spec).  In these cases, the :DONT-MERGE-DEFAULT
;;; argument is given a value of T, and the underlying ACCEPT will return the
;;; default-merged pathname, but save only the typein in the pathname history.
(DEFUN ACCEPT-DEFAULTED-PATHNAME (PROMPT DEFAULTS
				  &KEY SPECIAL-TYPE
				       (SPECIAL-VERSION :NEWEST)
				       (DIRECTION :READ)
				       (MERGE-IN-SPECIAL-VERSION T)
				       (DONT-MERGE-DEFAULT NIL))
  (LET ((SPECIAL-VERSION SPECIAL-VERSION)
	(DEFAULT (FS:DEFAULT-PATHNAME DEFAULTS NIL SPECIAL-TYPE SPECIAL-VERSION)))
    ;; MERGE-IN-SPECIAL-VERSION is for the case of wanting the default to have :OLDEST, but
    ;; not having pathnames typed in keeping to this.
    (WHEN (NOT MERGE-IN-SPECIAL-VERSION)
      (SETQ SPECIAL-VERSION NIL))		;Don't complete from this
    (LET ((*MODE-WORD-SYNTAX-TABLE* *PNAME-WORD-SYNTAX-TABLE*))
      (TYPEIN-LINE-ACCEPT `((FS:PATHNAME)
			    ,@(WHEN SPECIAL-TYPE
				`(:DEFAULT-TYPE ,SPECIAL-TYPE))
			    ,@(WHEN SPECIAL-VERSION
				`(:DEFAULT-VERSION ,SPECIAL-VERSION))
			    :DIRECTION ,DIRECTION
			    :DONT-MERGE-DEFAULT ,DONT-MERGE-DEFAULT)
			  :DEFAULT DEFAULT
			  :PROMPT PROMPT))))

;;; This function is no longer called by any function in the standard Symbolics systems,
;;; but it is left for compatibility with customer code that may have used it.
(DEFUN READ-DEFAULTED-AUX-PATHNAME (PROMPT &OPTIONAL SPECIAL-TYPE SPECIAL-VERSION
						     (DIRECTION ':READ))
  (ACCEPT-DEFAULTED-PATHNAME PROMPT *AUX-PATHNAME-DEFAULTS*
			     :SPECIAL-TYPE SPECIAL-TYPE :SPECIAL-VERSION SPECIAL-VERSION
			     :DIRECTION DIRECTION))

(DEFUN MAKE-DEFAULTED-PATHNAME (STRING DEFAULTS &OPTIONAL SPECIAL-TYPE
							  (SPECIAL-VERSION :NEWEST)
							  (MERGE-IN-SPECIAL-VERSION T))
  ;; STRING is what the user typed.  Remember it for next time if non-null.
  (BARF-ON-ERRORS (FS:PARSE-PATHNAME-ERROR FS:INVALID-PATHNAME-COMPONENT)
    (COND ((ZEROP (STRING-LENGTH STRING))	;He didn't type anything, use the default.
	   (FS:DEFAULT-PATHNAME DEFAULTS NIL SPECIAL-TYPE SPECIAL-VERSION))
	  (T
	   (SEND *PATHNAME-HISTORY* ':PUSH STRING)
	   (AND (NOT MERGE-IN-SPECIAL-VERSION)	;Was only for nullstring case
		(SETQ SPECIAL-VERSION NIL))
	   (FS:MERGE-PATHNAMES-AND-SET-DEFAULTS
	     (FS:MERGE-PATHNAMES STRING (FS:DEFAULT-PATHNAME DEFAULTS NIL SPECIAL-TYPE)
				 SPECIAL-VERSION)
	     DEFAULTS
	     (OR SPECIAL-VERSION ':NEWEST))))))

(DEFUN READ-UNDEFAULTED-PATHNAME (PROMPT DEFAULTS
				  &OPTIONAL SPECIAL-TYPE SPECIAL-VERSION (DIRECTION :READ))
  (LET ((SPECIAL-VERSION SPECIAL-VERSION)
	(DEFAULT (FS:DEFAULT-PATHNAME DEFAULTS NIL SPECIAL-TYPE SPECIAL-VERSION)))
    (LET ((*MODE-WORD-SYNTAX-TABLE* *PNAME-WORD-SYNTAX-TABLE*))
      (TYPEIN-LINE-ACCEPT `((FS:PATHNAME)
			    :DEFAULT-TYPE ,SPECIAL-TYPE
			    :DEFAULT-VERSION ,SPECIAL-VERSION
			    :DIRECTION ,DIRECTION)
			  :DEFAULT DEFAULT
			  :PROMPT PROMPT))))

;; Read with no name defaulting at all.  However, still need a defaults argument
;; in order to get the host when, for example, the user types "", and also
;; to make completion and c-m-Y work.
(DEFUN READ-RAW-PATHNAME (PROMPT DEFAULTS
			  &OPTIONAL (DIRECTION :READ))
  (LET ((*MODE-WORD-SYNTAX-TABLE* *PNAME-WORD-SYNTAX-TABLE*))
    (FS:MERGE-PATHNAMES
      (TYPEIN-LINE-ACCEPT `((FS:PATHNAME)
			    :DIRECTION ,DIRECTION
			    :DONT-MERGE-DEFAULT T)
			  :DEFAULT (SEND DEFAULTS :NEW-PATHNAME
						  :NAME NIL
						  :TYPE NIL
						  :VERSION NIL
						  :VC-BRANCH NIL
						  :VC-VERSION NIL)
			  :PROMPT PROMPT)
      DEFAULTS)))

;;; Canonicalize pathname for use as buffer name, etc.
(DEFUN EDITOR-FILE-NAME (FILE-NAME)
  (AND (STRINGP FILE-NAME)
       (SETQ FILE-NAME (FS:MERGE-PATHNAMES FILE-NAME *PATHNAME-DEFAULTS*)))
  (SETQ FILE-NAME (FUNCALL FILE-NAME ':TRANSLATED-PATHNAME))
  (VALUES FILE-NAME (FUNCALL FILE-NAME ':STRING-FOR-EDITOR)))

;;; Special commands in the pathname minibuffer
(DEFCOM COM-PATHNAME-COMPLETE "Tries to supply a pathname from a partial pathname string.
Beeps when it cannot supply a complete pathname." ()
  (LET ((TEM (PATHNAME-COMPLETE)))
    (AND (NULL TEM) (BEEP)))
  DIS-TEXT)

(DEFCOM COM-PATHNAME-COMPLETE-AND-EXIT-IF-UNIQUE
	"Tries to supply a pathname from a partial pathname string.
Beeps if it cannot supply a complete pathname.  
Redisplays the appropriate window if the pathname corresponds to an
  existing window.  
Exits the minibuffer upon completing the pathname." ()
  (LET ((TEM (PATHNAME-COMPLETE)))
    (COND ((NULL TEM)
	   (BEEP))
	  ((EQ TEM ':OLD)
	   (COND ((WINDOW-READY-P *WINDOW*)
		  (MUST-REDISPLAY *WINDOW* DIS-TEXT)
		  (REDISPLAY *WINDOW* ':NONE)))
	   (THROW 'RETURN-FROM-COMMAND-LOOP T))))
  DIS-TEXT)

(DEFUN PATHNAME-COMPLETE (&AUX STRING VALUE)
  (SETQ STRING (STRING-APPEND (BP-LINE (POINT))))
  (MULTIPLE-VALUE (STRING VALUE)
    (FS:COMPLETE-PATHNAME
      *READING-PATHNAME-DEFAULTS* STRING *READING-PATHNAME-SPECIAL-TYPE*
      *READING-PATHNAME-SPECIAL-VERSION* *READING-PATHNAME-DIRECTION*))
  (DELETE-INTERVAL *INTERVAL*)
  (INSERT-MOVING-POINT STRING)
  VALUE)

;COM-PATHNAME-LIST-COMPLETIONS someday

(DEFCOM COM-DOCUMENT-PATHNAME-READ "Instructs the user how to use pathname completion.
Describes the completion keys that perform command completion
in the minibuffer." ()
  (FORMAT T "~&You are typing a pathname~%")
  (FORMAT T
"You are typing to a minibuffer.  In the minibuffer, the following keys 
perform pathname completion:~%
KEY            RESULT~%
~A~15TCompletes the pathname and inserts it into the minibuffer.
End            Attempts to complete the pathname and exits the minibuffer
                 if it succeeds. 
Return         Exits the minibuffer without completing the pathname.
"  "Complete")
  (AND *MINI-BUFFER-COMMAND-IN-PROGRESS*
       (COM-DOCUMENT-CONTAINING-COMMAND))
  DIS-NONE)

;;; Various file-related commands on INTERVALs.

(DEFCOM COM-INSERT-FILE "Inserts the contents of a file into the buffer at point.
Prompts from the minibuffer for the name of a file, and inserts the
contents of that file.
Leaves point at the beginning of the inserted contents and mark at the
end.
With a numeric argument, leaves mark at the beginning of the inserted
contents and point at the end." ()
  (POINT-PDL-PUSH (POINT) *WINDOW* NIL NIL)
  (MOVE-MARK (POINT))
  (SETQ *CURRENT-COMMAND-TYPE* 'YANK)
  (LET ((PATHNAME (ACCEPT-DEFAULTED-PATHNAME "Insert file" (PATHNAME-DEFAULTS))))
    (CONDITION-CASE (.ERROR.)
	 (CONDITION-BIND ((SI:BINARY-FILE-READ-AS-CHARACTER-FILE-ERROR
			    #'SI:BINARY-FILE-READ-AS-CHARACTER-FILE-ERROR-QUERY-HANDLER)
			  (SI:ESCAPE-LOADING-STREAM-DECODING-ERROR
			    #'SI:ESCAPE-LOADING-STREAM-DECODING-ERROR-QUERY-HANDLER))
	   (SI:WITH-OPEN-CHARACTER-FILE (FILE-STREAM PATHNAME :DIRECTION :INPUT)
	     (LET ((INTERVAL-STREAM (OPEN-INTERVAL-STREAM (POINT) (POINT) T))
		   (OLD-POINT (COPY-BP (POINT) :NORMAL)))
	       (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK OLD-POINT))
		 (WITH-CUSTOM-UNDO-SAVE (OLD-POINT OLD-POINT
					 (MAKE-INSERT-RECORD OLD-POINT
							     (COPY-BP OLD-POINT ':MOVES)))
		   (UNWIND-PROTECT-CASE ()
		       (BLOCK INSERT
			 (STREAM-COPY-UNTIL-EOF FILE-STREAM INTERVAL-STREAM LINE-LEADER-SIZE)
			 (LOOP WITH END-BP = (SEND INTERVAL-STREAM :READ-BP)
			       WITH END-LINE = (BP-LINE END-BP)
			       FOR LINE = (BP-LINE OLD-POINT) THEN (LINE-NEXT LINE)
			       DO (SETQ LINE (MUNG-LINE LINE))
			       UNTIL (EQ LINE END-LINE)
			       FINALLY (MOVE-POINT END-BP))
			 (MAYBE-DISPLAY-DIRECTORY :READ PATHNAME))
		     (:ABORT
		       (DELETE-INTERVAL OLD-POINT (SEND INTERVAL-STREAM :READ-BP) T))))))))
       (FS:FILE-OPERATION-FAILURE
	 (BARF "~A" .ERROR.))
       (SI:BINARY-FILE-READ-AS-CHARACTER-FILE-ERROR
	 (ABORT-CURRENT-COMMAND))))
  (UNLESS *NUMERIC-ARG-P* (SWAP-POINT-AND-MARK))
  DIS-TEXT)

;;; --- needs more work for version control.
(DEFCOM COM-WRITE-REGION "Writes the current region (or definition) to a file.
Prompts from the minibuffer for the name of a file and writes the 
region to that file.  Creates a new file if the specified file does 
not exist already." ()
  (DEFINITION-REGION (BP1 BP2 NAME NIL T)
    (WRITE-INTERVAL NAME BP1 BP2 T)))

(DEFUN WRITE-INTERVAL (PROMPT FROM-BP &OPTIONAL TO-BP IN-ORDER-P
		       HACK-FONTS WARN-IF-PARENTHESES-UNBALANCED PATHNAME)
  (IGNORE HACK-FONTS)
  (WRITE-INTERVAL-1 FROM-BP TO-BP IN-ORDER-P
		    :PROMPT PROMPT
		    :WARN-IF-PARENTHESES-UNBALANCED WARN-IF-PARENTHESES-UNBALANCED
		    :PATHNAME PATHNAME))

(DEFUN WRITE-INTERVAL-1 (FROM-BP TO-BP IN-ORDER-P
			 &KEY PROMPT WARN-IF-PARENTHESES-UNBALANCED PATHNAME)
  (WITH-INTERVAL-READ-LOCKED (FROM-BP TO-BP IN-ORDER-P)
    (LET ((PATHNAME (OR PATHNAME
			(ACCEPT-DEFAULTED-PATHNAME
			  (FORMAT NIL "Write ~A to" PROMPT) (PATHNAME-DEFAULTS)
			  :SPECIAL-VERSION NIL :DIRECTION :WRITE))))
      (LET* ((CANONICAL-TYPE (SEND PATHNAME :CANONICAL-TYPE))
	     (BYTE-SIZE (AND (SYMBOLP CANONICAL-TYPE)
			     (GET CANONICAL-TYPE :BINARY-FILE-BYTE-SIZE))))
	(WHEN BYTE-SIZE
	  (UNLESS (FQUERY
		    (LIST* :BEEP T FORMAT:YES-OR-NO-P-OPTIONS)
		    "This command will write ~a as a character file,~@
		     but the system thinks it should be a binary file, ~
		     and will probably get confused.~@
		     Write it anyway? "
		    PATHNAME)
	    (BARF))))
      (WITH-OPEN-FILE (STREAM PATHNAME :DIRECTION :OUTPUT
			      :ELEMENT-TYPE (IF (INTERVAL-FAT-P FROM-BP TO-BP IN-ORDER-P)
						'CL:CHARACTER
					      'CL:STRING-CHAR))
	(STREAM-OUT-INTERVAL STREAM FROM-BP TO-BP IN-ORDER-P
			     NIL WARN-IF-PARENTHESES-UNBALANCED)
	(CLOSE STREAM)
	(TYPEIN-LINE "Written: ~A" (SEND STREAM :TRUENAME)))))
  DIS-NONE)

(DEFCOM COM-WRITE-BUFFER "Writes the current buffer being edited to a file.
Prompts from the minibuffer for the name of a file and writes the
current buffer, even if it is not a file buffer, to that file.  Creates
a new file if the specified file does not exist already." ()
  (WRITE-INTERVAL "buffer" *INTERVAL*))

(DEFCOM COM-APPEND-TO-FILE "Appends the current region (or definition) to the end of a file.
Prompts from the minibuffer for the name of a file and appends the
region to that file.  Creates a new file if the specified file does not
exist already." ()
  (DEFINITION-REGION-BPS (BP1 BP2 NAME)
    (LET ((PATHNAME (ACCEPT-DEFAULTED-PATHNAME
		      (FORMAT NIL "Append ~A to end of file" NAME) (PATHNAME-DEFAULTS)))
	  ISTREAM)
      (WITH-OPEN-FILE (OSTREAM PATHNAME ':DIRECTION ':OUTPUT)
	(UNWIND-PROTECT
	  (CONDITION-CASE (.ERROR.)
	      (SETQ ISTREAM (OPEN PATHNAME))
	    (FS:FILE-NOT-FOUND (TYPEIN-LINE "(New File)"))
	    (FS:FILE-OPERATION-FAILURE (BARF "Error: ~A" .ERROR.))
	    (:NO-ERROR (STREAM-COPY-UNTIL-EOF ISTREAM OSTREAM)))
	  (AND ISTREAM (CLOSE ISTREAM)))
	(STREAM-OUT-INTERVAL OSTREAM BP1 BP2 T))
      (MAYBE-DISPLAY-DIRECTORY ':READ PATHNAME)))
  DIS-NONE)

;;;--- This needs work.  If neither the file or the interval is fat,
;;;--- we don't need to output in fat mode.
(DEFCOM COM-PREPEND-TO-FILE "Prepends the current region (or definition) to a file.
Prompts from the minibuffer for the name of a file and prepends the
region to that file.  Creates a new file if the specified file does not
exist already." ()
  (LET ((PATHNAME (ACCEPT-DEFAULTED-PATHNAME
		    (FORMAT NIL "Prepend region to file") (PATHNAME-DEFAULTS))))
    (WITH-OPEN-FILE (ISTREAM PATHNAME ':ERROR NIL)
      (TYPECASE ISTREAM
	(FS:FILE-NOT-FOUND (TYPEIN-LINE "(New File)") (SETQ ISTREAM NIL))
	(FS:FILE-OPERATION-FAILURE (BARF "Error: ~A" ISTREAM)))
      (WITH-OPEN-FILE (OSTREAM PATHNAME ':DIRECTION ':OUTPUT)
	(DEFINITION-REGION-BPS (BP1 BP2)
	  (STREAM-OUT-INTERVAL OSTREAM BP1 BP2 T))
	(AND ISTREAM (STREAM-COPY-UNTIL-EOF ISTREAM OSTREAM))))
    (MAYBE-DISPLAY-DIRECTORY ':READ PATHNAME))
  DIS-NONE)

(DEFCOM COM-SHOW-FILE "Allows the user to look at the contents of a file.
Prompts from the minibuffer for the name of a file and creates a
typeout window in which the user looks at the contents of the specified
file.  
Beeps and types a message in the minibuffer if the specified file
does not exist." ()
  (LET ((PATHNAME (ACCEPT-DEFAULTED-PATHNAME "Show file" (PATHNAME-DEFAULTS)
					     :SPECIAL-VERSION NIL)))
    (VIEW-FILE PATHNAME))
  DIS-NONE)

;;; Show the file in the "display window".
;;; The caller should set up a reasonable prompt.
(COMMENT
  (DEFUN VIEW-FILE (FILENAME &OPTIONAL (OUTPUT-STREAM STANDARD-OUTPUT))
    (FUNCALL OUTPUT-STREAM ':HOME-CURSOR)
    (FUNCALL OUTPUT-STREAM ':CLEAR-EOL)
    (WITH-OPEN-FILE (STREAM FILENAME '(:READ))
      (STREAM-COPY-UNTIL-EOF STREAM OUTPUT-STREAM))
    (FUNCALL OUTPUT-STREAM ':CLEAR-EOF))
);COMMENT

(DEFUN VIEW-FILE (PATHNAME &OPTIONAL DELETED-P (ELEMENT-TYPE :DEFAULT))
  (CONDITION-CASE (.ERROR.)
       (CONDITION-BIND ((SI:BINARY-FILE-READ-AS-CHARACTER-FILE-ERROR
			  #'SI:BINARY-FILE-READ-AS-CHARACTER-FILE-ERROR-QUERY-HANDLER)
			(SI:ESCAPE-LOADING-STREAM-DECODING-ERROR
			  #'SI:ESCAPE-LOADING-STREAM-DECODING-ERROR-QUERY-HANDLER))
	 (SI:WITH-OPEN-CHARACTER-FILE (STREAM PATHNAME :PRESERVE-DATES T :DELETED DELETED-P
						       :ELEMENT-TYPE ELEMENT-TYPE)
	   (PROMPT-LINE "Showing ~A" (SEND STREAM :TRUENAME))
	   (FS:VIEWF-STREAM PATHNAME STREAM STANDARD-OUTPUT)))
     (FS:FILE-OPERATION-FAILURE
       (BARF "~A" .ERROR.))
     (SI:BINARY-FILE-READ-AS-CHARACTER-FILE-ERROR
       (ABORT-CURRENT-COMMAND))))

;;; Now just a stub.
(DEFUN VIEW-STREAM (STREAM &OPTIONAL (WINDOW STANDARD-OUTPUT))
  (STREAM-COPY-UNTIL-EOF STREAM WINDOW))

(DEFCOM COM-ENABLE-HOST-CAPABILITIES
	"Enables any file system capabilities for a specified host.
Prompts from the minibuffer for the name of a host and and enables any
file system capabilities of that host.  
With a numeric argument, prompts from the minibuffer for  a list of
specific capabilities to enable." ()
  (ENABLE-DISABLE-HOST-CAPABILITIES #'FS:ENABLE-CAPABILITIES "enable")
  DIS-NONE)

(DEFCOM COM-DISABLE-HOST-CAPABILITIES
	"Disables any file system capabilities for a specified host.
Prompts from the minibuffer for the name of a host and disables any
file system capabilities of that host.  
With a numeric argument, prompts for a list of capabilities to disable." ()
  (ENABLE-DISABLE-HOST-CAPABILITIES #'FS:DISABLE-CAPABILITIES "disable")
  DIS-NONE)

(DEFUN ENABLE-DISABLE-HOST-CAPABILITIES (FUNCTION PROMPT)
  (LET* ((DEFAULT-HOST (SEND (FS:DEFAULT-PATHNAME (PATHNAME-DEFAULTS)) ':HOST))
	 (HOST (TYPEIN-LINE-READLINE "Host to ~A capabilities on: (default = ~A)"
				     PROMPT DEFAULT-HOST)))
    (SETQ HOST (STRING-TRIM *BLANKS* HOST))
    (IF (EQUAL HOST "")
	(SETQ HOST DEFAULT-HOST))
    (CONDITION-CASE (.ERROR.)
	(SETQ HOST (NET:PARSE-HOST HOST))
      (NET:UNKNOWN-HOST-NAME
	(BARF "~A" .ERROR.)))
    (LET* ((DEFAULT-CAPABILITIES (SEND HOST ':DEFAULT-ENABLE-CAPABILITIES))
	   (CAPABILITIES (IF *NUMERIC-ARG-P*
			     (TYPEIN-LINE-READLINE "Capabilities to ~A on ~A:~:[~; ~A~]"
						   PROMPT HOST
						   DEFAULT-CAPABILITIES
						   `("Default =" . ,DEFAULT-CAPABILITIES)))))
      (SETQ CAPABILITIES (AND CAPABILITIES
			      (OR (LET ((SI:*SUPPRESS-READ-EVAL* T))
				    (READ-FROM-STRING (STRING-APPEND "(" CAPABILITIES ")")))
				  DEFAULT-CAPABILITIES)))
      (SETQ CAPABILITIES (MAPCAR #'STRING CAPABILITIES))
      (CONDITION-CASE (.ERROR.)
	  (LOOP FOR (CAP . ON) IN (LEXPR-FUNCALL FUNCTION HOST CAPABILITIES)
		DO (TYPEIN-LINE "~&~A capability on ~A is ~:[disabled~;enabled~].~%"
			   CAP HOST ON))
	(FS:FILE-ERROR
	  (BARF "~A responded: ~A" HOST .ERROR.))))))

(DEFCOM COM-DELETE-FILE "Deletes a specified file.  
Prompts from the minibuffer for the name of a file to delete. 
Requests confirmation before deleting any files.
Types a message in the minibuffer if the specified file does not
exist.
Use wild-card pathnames to specify groups of files for deletion." ()
  (LET ((PATHNAME (ACCEPT-DEFAULTED-PATHNAME "Delete file" (PATHNAME-DEFAULTS)
					     :SPECIAL-VERSION NIL)))
    (COND ((SEND PATHNAME ':WILD-P)
	   (CONDITION-CASE (ERR-OR-FILES)
	       (CDR (FS:DIRECTORY-LIST PATHNAME ':FAST ':SORTED))
	     (FS:FILE-OPERATION-FAILURE (BARF "Error: ~A" ERR-OR-FILES))
	     (:NO-ERROR
	      (OR ERR-OR-FILES (BARF "Error: ~A matches no files." PATHNAME))
	      (FORMAT T "~&Deleting the following ~D file~:P:~%~%" (LENGTH ERR-OR-FILES))
	      (LOOP FOR (FILE) IN ERR-OR-FILES
		    DO (PRINC FILE) (TERPRI))
	      (IF (FQUERY NIL "Delete the above ~D file~:P? " (LENGTH ERR-OR-FILES))
		  (LOOP FOR (FILE) IN ERR-OR-FILES
 			DO (CONDITION-CASE (ERR)
			       (DELETEF FILE)
			     (FS:FILE-OPERATION-FAILURE
			       (FORMAT ERROR-OUTPUT "~&Cannot delete ~A: ~A" FILE ERR)))))))
	   DIS-TEXT)
	  (T
	   (LET* ((NO-SUCH-FILE NIL)
		  (TRUENAME (OR (FS:LINK-OPAQUE-TRUENAME PATHNAME NIL)
				(PROGN (SETQ NO-SUCH-FILE T)
				       PATHNAME))))
	     (AND (OR NO-SUCH-FILE
		      (FQUERY NIL "Delete ~A? " TRUENAME))
		  (CONDITION-CASE (ERR)
		      (DELETEF TRUENAME)
		    (FS:FILE-OPERATION-FAILURE
		      (TYPEIN-LINE "Cannot delete ~A: ~A" TRUENAME ERR))
		    (:NO-ERROR (TYPEIN-LINE "~A deleted." TRUENAME)))))
	   DIS-NONE))))

(DEFCOM COM-UNDELETE-FILE "Undeletes a deleted file.
Prompts from the minibuffer for the name of a file to replace undelete.
Requests confirmation before undeleting any file.
Types a message in the minibuffer if the specified file does not
exist." ()
  (LET* ((PATHNAME (ACCEPT-DEFAULTED-PATHNAME "Undelete file" (PATHNAME-DEFAULTS)
					      :SPECIAL-VERSION NIL
					      :DIRECTION :DELETED))
	 (TRUENAME (OPEN PATHNAME ':DIRECTION NIL ':DELETED T ':ERROR NIL)))
    (IF (ERRORP TRUENAME)
	(SETQ TRUENAME PATHNAME)
	(SETQ TRUENAME (SEND TRUENAME ':TRUENAME)))
    (AND (FQUERY NIL "Undelete ~A? " TRUENAME)
	 (LET ((ERROR (UNDELETEF TRUENAME NIL)))
	   (IF (ERRORP ERROR)
	       (TYPEIN-LINE "Cannot undelete ~A: ~A" TRUENAME ERROR)
	       (TYPEIN-LINE "~A undeleted." TRUENAME)))))
  DIS-NONE)

(DEFCOM COM-RENAME-FILE "Renames one or many specified files.
Prompts from the minibuffer for the name of a file to rename.
Prompts for the new name of the specified file.
Types a message in the minibuffer if the specified file does
not exist or cannot be renamed.
Use wild-card pathnames to specify groups of files for renaming." ()
  (LET* ((FROM (ACCEPT-DEFAULTED-PATHNAME "Rename file" (PATHNAME-DEFAULTS)
					  :SPECIAL-VERSION NIL))
	 (TO (READ-RAW-PATHNAME `("Rename file ~A to" ,FROM) FROM ':WRITE)))
    (COND ((SEND FROM ':WILD-P)
	   (CONDITION-CASE (ERR-OR-FILES)
	       ;;Sort the list so that .newest remains .newest 
	       (CDR (FS:DIRECTORY-LINK-OPAQUE-DIRLIST FROM ':FAST ':SORTED))
	     (FS:FILE-OPERATION-FAILURE (BARF "Error: ~~A~" ERR-OR-FILES))
	     (:NO-ERROR
	      (OR ERR-OR-FILES (BARF "Error: ~A matches no files." FROM))
	      (LOOP WITH MERGED-TO = (FS:MERGE-PATHNAMES TO FROM ':WILD)
		    FOR (FILE) IN ERR-OR-FILES
		    AS TRANSLATION = (SEND FROM ':TRANSLATE-WILD-PATHNAME MERGED-TO FILE)
		    DO (CONDITION-CASE (ERR)
			   (RENAME-FILE-INTERNAL FILE TRANSLATION #'TYPEOUT-LINE)
			 (FS:FILE-OPERATION-FAILURE
			   (TYPEIN-LINE "Cannot rename ~A to ~A:~%  ~~A~"
					FILE TRANSLATION ERR))))
	      DIS-TEXT)))
	  (T
	   (CONDITION-CASE (ERR)
	       (RENAME-FILE-INTERNAL FROM TO #'TYPEIN-LINE)
	     (FS:FILE-OPERATION-FAILURE
	       (BARF "Cannot rename ~A to ~A:~%  ~~A~" FROM TO ERR)))
	   DIS-NONE))))

(DEFUN RENAME-FILE-INTERNAL (FROM TO PRINTER)
  (MULTIPLE-VALUE-BIND (TO REAL-FROM REAL-TO)
      (RENAMEF FROM TO)
    (FUNCALL PRINTER "~A renamed to ~A" REAL-FROM REAL-TO)
    (LET* ((BUFFER-TO TO)
	   (BUFFER (OR (FIND-BUFFER-NAMED FROM)
		       (WHEN (FIXP (SEND FROM :VERSION))
			 (LET ((MAYBE (FIND-BUFFER-NAMED (SEND FROM :NEW-VERSION ':NEWEST))))
			   (WHEN (AND MAYBE (NOT (ATOM (SEND MAYBE :FILE-INFO)))
				      (EQ (FIRST (SEND MAYBE :FILE-INFO)) FROM))
			     (SETQ BUFFER-TO (SEND BUFFER-TO :NEW-VERSION ':NEWEST))
			     MAYBE))))))
      (WHEN BUFFER
	(COND ((FQUERY () "Rename buffer ~A as well? " (SEND BUFFER ':NAME))
	       (LET ((OLD-INFO (SEND BUFFER :FILE-INFO)))
		 (WHEN (EQ (SEND (SEND BUFFER :PATHNAME) :VERSION) ':NEWEST)
		   (SETQ BUFFER-TO (SEND BUFFER-TO :NEW-VERSION ':NEWEST)))
		 (SEND BUFFER :SET-PATHNAME-FOR-WRITE BUFFER-TO)
		 (UNLESS (ATOM OLD-INFO)			;ATOM is NIL or :NEVER-READ
		   (SETF (CAR OLD-INFO) REAL-TO)
		   (SEND BUFFER :SET-FILE-INFO OLD-INFO)))
	       (TYPEIN-LINE "Buffer renamed to ~A" (SEND BUFFER :NAME)))
	      (T (TYPEIN-LINE "Buffer not renamed")))))
    (VALUES TO REAL-FROM REAL-TO)))

(DEFUN TYPEOUT-LINE (&REST FORMAT-ARGS)
  (SEND STANDARD-OUTPUT ':FRESH-LINE)
  (LEXPR-FUNCALL #'FORMAT T FORMAT-ARGS))


(DEFUN READ-TWO-DEFAULTED-PATHNAMES (PROMPT DEFAULTS &AUX FROM TO)
  (SETQ FROM (ACCEPT-DEFAULTED-PATHNAME (FORMAT NIL "~A file" PROMPT) DEFAULTS)
	TO (ACCEPT-DEFAULTED-PATHNAME (FORMAT NIL "~A ~A to" PROMPT FROM) FROM
				      :SPECIAL-VERSION NIL :DIRECTION :WRITE))
  (VALUES FROM TO))


(DEFCOM COM-COPY-TEXT-FILE "Copies a text file to a specified file.
Prompts from the minibuffer for the name of a text file to copy.
Prompts for the name of a file to which to copy the text file.
Types a message in the minibuffer if the specified file does not
exist or cannot be copied." ()
  (LET ((*NUMERIC-ARG* 2)
	(*NUMERIC-ARG-P* T))
    (COM-COPY-FILE)))

(DEFCOM COM-COPY-BINARY-FILE "Copies a 16-bit binary file to a specified file.
Prompts from the minibuffer for the name of a binary file to copy.
Prompts for the name of a file to which to copy the binary file.
Types a message in the minibuffer if the specified file does not
exist or cannot be copied." ()
  (LET ((*NUMERIC-ARG* 1)
	(*NUMERIC-ARG-P* T))
    (COM-COPY-FILE)))

(DEFCOM COM-COPY-FILE "Copies any type of file to a specified file.
Prompts from the minibuffer for the name of a file to copy.
Prompts for the name of file to which to copy the specified
file.
The numeric argument controls copying of attributes.  With no
numeric argument, creation date and author are copied, and the
mode (binary or character) of copy is determined by the file being copied.
To force mode, or suppress author or creation date copying, 
supply a numeric argument created by adding the values corresponding
to the descriptions below:

1    Force copy in 16-bit binary mode.
2    Force copy in character (text) mode.
4    Suppress copy of author.
8    Suppress copy of creation date.

Use wild-card pathnames to specify groups of files for copying.
For example:
F:>program>mine>*.*	Copies all the files in subdirectory >mine>." ()

  (LET ((NUMERIC-ARG *NUMERIC-ARG*))		;Bind so command history saves original value
    (IF (NOT ( 1 NUMERIC-ARG 15.))
	(BARF "Invalid numeric argument for file copy: ~D.  Valid range is 1 to 15."
	      NUMERIC-ARG))
    (OR *NUMERIC-ARG-P* (SETQ NUMERIC-ARG 0))
    (IF (AND (BIT-TEST 1 NUMERIC-ARG)
	     (BIT-TEST 2 NUMERIC-ARG))
	(BARF "Character and binary copy specified simultaneously."))   
    (LET* ((CHAR (COND ((BIT-TEST 1 NUMERIC-ARG) NIL)
		       ((BIT-TEST 2 NUMERIC-ARG) T)
		       (T ':DEFAULT)))
	   (AUTH (NOT (BIT-TEST 4 NUMERIC-ARG)))
	   (COPY-CREATION-DATE (NOT (BIT-TEST 8. NUMERIC-ARG)))
	   (FROM-PATHNAME (ACCEPT-DEFAULTED-PATHNAME
			    (COND ((EQ CHAR ':DEFAULT) "Copy file")
				  (CHAR "Copy Text File")
				  (T "Copy Binary File"))
			    (PATHNAME-DEFAULTS)
			    :SPECIAL-VERSION NIL))
	   (TO-PATHNAME (READ-RAW-PATHNAME
			      (FORMAT NIL "Copy file ~A to" FROM-PATHNAME)
			      FROM-PATHNAME
			      ':WRITE)))
      (COND ((SEND FROM-PATHNAME ':WILD-P)
	     (COND 
	       ((LET ((FILES (CONDITION-CASE (ERR)
				 (CDR (FS:DIRECTORY-LINK-OPAQUE-DIRLIST
					FROM-PATHNAME ':SORTED))	;need slow..
			       (FS:FILE-OPERATION-FAILURE (BARF "Error: ~~A~" ERR)))))
		  (AND FILES
		       (LOOP WITH MERGED-TO = (FS:MERGE-PATHNAMES TO-PATHNAME FROM-PATHNAME
								  ':WILD)
			     FOR PLIST IN FILES
			     FOR (FILE) = PLIST
			     IF (GET PLIST ':DIRECTORY) DO NIL
			     ELSE IF (GET PLIST ':LINK-TO) DO NIL	;This involves hair
						  ;and design
			     ELSE DO
			     (CONDITION-CASE (ERR)
				 (COPYF FILE
					(SEND FROM-PATHNAME ':TRANSLATE-WILD-PATHNAME
					      MERGED-TO FILE)
					':CHARACTERS CHAR
					':COPY-CREATION-DATE COPY-CREATION-DATE
					':COPY-AUTHOR AUTH
					':REPORT-STREAM STANDARD-OUTPUT)
			       (FS:FILE-OPERATION-FAILURE
				 (FORMAT ERROR-OUTPUT "~&Could not copy ~A:~%  ~~A~"
					 FILE ERR)))
			     FINALLY (RETURN T))))
		DIS-TEXT)
	       (T (TYPEIN-LINE "~A matches no files.  None copied." FROM-PATHNAME)
		  DIS-NONE)))
	    (T (CONDITION-CASE (ERR)
		   (COPYF FROM-PATHNAME TO-PATHNAME ':CHARACTERS CHAR
			  ':COPY-CREATION-DATE COPY-CREATION-DATE 
			  ':COPY-AUTHOR AUTH
			  ':REPORT-STREAM *TYPEIN-WINDOW*)
		 (FS:FILE-OPERATION-FAILURE   (BARF "Error: ~~A~" ERR)))
	       DIS-NONE)))))

(DEFCOM COM-CREATE-LINK "Creates a link between two files.
Prompts from the minibuffer for the names of two files to link
together.
Types a message to the minibuffer if the creation of a link is not
possible." ()
  (LET* ((FIRST (ACCEPT-DEFAULTED-PATHNAME
		  "Pathname of the link to be created" *PATHNAME-DEFAULTS*))
	 (SECOND (ACCEPT-DEFAULTED-PATHNAME
		   (FORMAT NIL "Target pathname for link ~A" FIRST) FIRST
		   :SPECIAL-VERSION NIL :DIRECTION :WRITE)))
    (CONDITION-CASE (.ERROR.)
	(SEND FIRST ':CREATE-LINK SECOND)
      (FS:FILE-OPERATION-FAILURE
	(BARF "Cannot create link: ~A" .ERROR.)))
    (TYPEIN-LINE "~A linked to ~A"  FIRST SECOND))
  DIS-NONE)

(DEFCOM COM-CREATE-DIRECTORY "Creates a directory or subdirectory.
Prompts from the minibuffer for the name of a directory or subdirectory
to create and creates that directory.  Types a message if it cannot
create a directory." ()
  (LET ((DIR (READ-DIRECTORY-NAME "Create directory:"
				  (DEFAULT-PATHNAME *PATHNAME-DEFAULTS*)
				  NIL)))
    (CONDITION-CASE (.ERROR.)
	(SEND DIR ':CREATE-DIRECTORY)
      (FS:FILE-OPERATION-FAILURE (BARF "Cannot create directory:  ~A" .ERROR.)))
    (TYPEIN-LINE "Directory ~A created."
		 (SEND DIR ':NEW-PATHNAME ':NAME NIL ':TYPE NIL ':VERSION NIL)))
  DIS-NONE)


;;; Directory Listing stuff.

;;; With argument of one, just list the one file, for brain-compatibility
;;; with c-X D (dired).
(DEFCOM COM-DISPLAY-DIRECTORY
	"Displays the directory of the file in the current Zmacs buffer.
With a numeric argument, prompts for the name of a directory to list and
lists that directory." ()
  (FUNCALL *DIRECTORY-LISTER*
	   (READ-DEFAULTED-WILD-PATHNAME "Display Directory"
					 (DEFAULT-PATHNAME)
					 (= *NUMERIC-ARG* 1)))
  DIS-NONE)

(DEFUN READ-DEFAULTED-WILD-PATHNAME (PROMPT &OPTIONAL (DEFAULT (DEFAULT-PATHNAME))
				     DONT-READ-P)
  (SETQ DEFAULT (FUNCALL DEFAULT ':NEW-PATHNAME ':TYPE ':WILD ':VERSION ':WILD))
  (OR DONT-READ-P
      (SETQ DEFAULT (ACCEPT-DEFAULTED-PATHNAME PROMPT DEFAULT
					       :SPECIAL-TYPE :WILD :SPECIAL-VERSION :WILD)))
  DEFAULT)

(DEFUN MAYBE-DISPLAY-DIRECTORY (TYPE &OPTIONAL (PATHNAME (DEFAULT-PATHNAME)))
  (COND ((OR (AND (EQ TYPE ':READ) (MEMQ *AUTO-DIRECTORY-DISPLAY* '(:READ T)))
	     (AND (EQ TYPE ':WRITE) (MEMQ *AUTO-DIRECTORY-DISPLAY* '(:WRITE T))))
	 (FUNCALL *DIRECTORY-LISTER* (FUNCALL PATHNAME ':NEW-PATHNAME ':TYPE ':WILD
								      ':VERSION ':WILD)))))

;;; This is the default directory listing routine
(DEFUN DEFAULT-DIRECTORY-LISTER (PATHNAME)
  (SEND *CURRENT-COMMAND-LOOP* ':DIRECTORY-LISTER PATHNAME))


;;; This is here so that for Zmacs, it looks the same, but saves the information in a
;;; Dired buffer.
;;;Note: Since this is stream oriented, the usage summary comes out at the end rather
;;;than being inserted at the beginning after the fact.
(DEFMETHOD (:DIRECTORY-LISTER EDITOR) (PATHNAME)
  (CL:FRESH-LINE)
  (MULTIPLE-VALUE-BIND (TOTAL-BLOCKS DELETED-BLOCKS)
      (LIST-DIRECTORY-INTERNAL PATHNAME (FS:DIRECTORY-LIST PATHNAME ':SORTED)
			       #'SI:PRESENT-DIRECTORY-ELEMENT)
    (FORMAT T "~:D block~:P in the files listed~
                ~:[~;, including ~D deleted block~:P~]~%Done~%"
	    TOTAL-BLOCKS (> DELETED-BLOCKS 0) DELETED-BLOCKS)))



;; This condition exists so READ-DIRECTORY-NAME can present an error with reasonable
;; proceed types and description to the user when there is an unexpected error when
;; testing a pathname by doing an OPEN on it.
(DEFFLAVOR READ-DIRECTORY-ERROR
	(PATHNAME ERROR)
	(ERROR)
  :INITABLE-INSTANCE-VARIABLES
  :READABLE-INSTANCE-VARIABLES)

(DEFMETHOD (DBG:REPORT READ-DIRECTORY-ERROR) (STREAM)
  (FORMAT STREAM "An unexpected error occurred while testing whether~@
                  ~2T~~A is a directory pathname:~%~A~" PATHNAME ERROR))

(DEFMETHOD (SYS:PROCEED READ-DIRECTORY-ERROR :ASSUME-IS-DIRECTORY) ()
  (VALUES :ASSUME-IS-DIRECTORY))

(DEFMETHOD (DBG:DOCUMENT-PROCEED-TYPE READ-DIRECTORY-ERROR :ASSUME-IS-DIRECTORY)
	   (STREAM)
  (FORMAT STREAM "Proceed, assuming that ~A is the pathname of a directory" PATHNAME))

(DEFMETHOD (SYS:PROCEED READ-DIRECTORY-ERROR :ASSUME-IS-FILE) ()
  (VALUES :ASSUME-IS-FILE))

(DEFMETHOD (DBG:DOCUMENT-PROCEED-TYPE READ-DIRECTORY-ERROR :ASSUME-IS-FILE) (STREAM)
  (FORMAT STREAM "Proceed, assuming that ~A is the pathname of a file" PATHNAME))

(DEFMETHOD (SYS:PROCEED READ-DIRECTORY-ERROR :RETRY-TEST) ()
  (VALUES :RETRY-TEST))

(DEFMETHOD (DBG:DOCUMENT-PROCEED-TYPE READ-DIRECTORY-ERROR :RETRY-TEST) (STREAM)
  (FORMAT STREAM "Retry testing whether the pathname ~A is a file or a directory" PATHNAME))

(COMPILE-FLAVOR-METHODS READ-DIRECTORY-ERROR)

(DEFUN READ-DIRECTORY-NAME (PROMPT DEFAULT &OPTIONAL (WILDP T))
  ;; If the default is the name of a directory, then use that directory
  ;; as the default
  (SETQ DEFAULT
	(IF (AND (OR (STRING-EQUAL (SEND DEFAULT :TYPE) "DIRECTORY")
		     (STRING-EQUAL (SEND DEFAULT :TYPE) "DIR"))
		 (OR (SEND DEFAULT :WILD-P)
		     (LOOP NAMED OPEN-TEST DOING
		       (CONDITION-CASE (ERROR)
			    (CLOSE (OPEN DEFAULT))
			  (ERROR
			    (CL:TYPECASE ERROR
			      ((OR FS:INVALID-OPERATION-FOR-DIRECTORY FS:FILE-NOT-FOUND)
			       (RETURN-FROM OPEN-TEST T))
			      (OTHERWISE
				(DBG:WITH-EXTRA-DEBUGGER-MENU-CONDITIONS
				  (READ-DIRECTORY-ERROR)
				  (SIGNAL-PROCEED-CASE (() 'READ-DIRECTORY-ERROR
							:PATHNAME DEFAULT
							:ERROR ERROR)
				    (:ASSUME-IS-DIRECTORY (RETURN-FROM OPEN-TEST T))
				    (:ASSUME-IS-FILE (RETURN-FROM OPEN-TEST NIL))
				    (:RETRY-TEST NIL))))))
			  (:NO-ERROR (RETURN-FROM OPEN-TEST NIL))))))
	    (SEND (SEND DEFAULT :PATHNAME-AS-DIRECTORY) :NEW-PATHNAME :NAME :WILD)
	    (SEND DEFAULT :NEW-PATHNAME :NAME :WILD)))
  (LET ((SPECIAL-TYPE :WILD) (SPECIAL-VERSION :WILD))
    (SELECTQ WILDP
      (NIL (SETQ SPECIAL-TYPE NIL SPECIAL-VERSION NIL))
      (:ALL-BUT-VERSION (SETQ SPECIAL-TYPE :WILD SPECIAL-VERSION NIL)))
    (LET ((DIRECTORY-NAME (ACCEPT-DEFAULTED-PATHNAME PROMPT DEFAULT
						     :SPECIAL-TYPE SPECIAL-TYPE
						     :SPECIAL-VERSION SPECIAL-VERSION
						     :DIRECTION :READ)))
      DIRECTORY-NAME)))

(DEFCOM COM-LIST-FILES "Displays a list of files in a directory.
Prompts from the minibuffer for the name of a directory and lists the
files in that directory.
Displays the names of file only." ()
  (LET ((PATHNAME (READ-DIRECTORY-NAME "List Files:" (DEFAULT-PATHNAME))))
    (FORMAT T "~&~A~%" PATHNAME)
    (LET ((LIST (FS:DIRECTORY-LIST PATHNAME ':FAST ':SORTED)))
      (SETQ LIST (MAPCAR #'CAR (DELQ (ASSQ NIL LIST) LIST)))
      (SCL:FORMAT-ITEM-LIST LIST :PRINTER (LAMBDA (PATHNAME STREAM)
					    ;; Wrong presentation type for directories, but
					    ;; using :FAST means we cannot know which files
					    ;; are directories.
					    (SCL:PRESENT PATHNAME
							 `((,(CL:TYPE-OF PATHNAME))
							   :FORMAT :DIRED)
							 :STREAM STREAM)))))
  DIS-NONE)

(DEFUN VIEW-DIRECTORY (VIEWED-DIRECTORY)
  (SEND *CURRENT-COMMAND-LOOP* :DIRECTORY-LISTER VIEWED-DIRECTORY)
  DIS-NONE)

(DEFMETHOD (:VIEW-DIRECTORY EDITOR) (VIEWED-DIRECTORY &AUX STREAM)
  (BARF-ON-ERRORS (FS:FILE-OPERATION-FAILURE)
    (SETQ STREAM (DIRECTORY-INPUT-STREAM VIEWED-DIRECTORY)))
  (PROMPT-LINE "Showing directory ~A" VIEWED-DIRECTORY)
  (VIEW-STREAM STREAM))

;;; This gives an input stream which lists the directory.
;;; Knows about :LINE-IN only.
(DEFUN DIRECTORY-INPUT-STREAM (DIRECTORY)
  (LET-CLOSED ((*DIRECTORY-LIST* (FS:DIRECTORY-LIST DIRECTORY ':SORTED)))
    #'DIRECTORY-INPUT-STREAM-IO))

(LOCAL-DECLARE ((SPECIAL *DIRECTORY-LIST*))
(DEFSELECT DIRECTORY-INPUT-STREAM-IO
  (:LINE-IN (&OPTIONAL (LINE-LEADER-SIZE LINE-LEADER-SIZE))
   (IF *DIRECTORY-LIST*
       (VALUES					;First value is a string
	       (FUNCALL *DIRECTORY-SINGLE-FILE-LISTER* (POP *DIRECTORY-LIST*) NIL)
						;Second return value is whether at end
	       (NULL *DIRECTORY-LIST*))
       (VALUES NIL T)))) )

;;; Obsolete ITS only functions
#||
(DEFCOM COM-OLD-LIST-FILES "Displays a list of the files in a directory.
Prompts from the minibuffer for the name of a directory to list and
lists the files in that directory with the following information:
 Device from which files are listed
 Directory name
 Number of free blocks on the device
 Number of blocks taken up by the directory
 These symbols preceding the filename:
	: indicates the file is a link
	! indicates the file has not been backed up on tape yet
	* indicates the file has been deleted but is not yet
	      closed or otherwise locked.
  (blank) indicates the file is in its normal state" ()
  (LET ((PATHNAME (READ-DIRECTORY-NAME "List Directory:" (DEFAULT-PATHNAME)))
	(LINE NIL) (X NIL) (Y NIL) (X1 NIL) (Y1 NIL) (TEM1 NIL)
	(FREE-ARRAY (MAKE-ARRAY 10)) (USED-ARRAY (MAKE-ARRAY 10)))
    (WITH-OPEN-FILE (STREAM (FUNCALL PATHNAME ':DEFAULT-NAMESTRING ".FILE. (DIR)") '(READ))
      (SETQ LINE (FUNCALL STREAM ':LINE-IN))
      (SETQ LINE (FUNCALL STREAM ':LINE-IN))
      (DIRECTORY-FREE-SPACE LINE FREE-ARRAY)
      (FORMAT T "~6A ~6A  " (FUNCALL PATHNAME ':DEVICE) (FUNCALL PATHNAME ':DIRECTORY))
      (FORMAT-DISK-BLOCKS-ARRAY STANDARD-OUTPUT "Free: " FREE-ARRAY)
      (FORMAT T ", Used: ")			;Filled in later
      (MULTIPLE-VALUE (X Y) (FUNCALL STANDARD-OUTPUT ':READ-CURSORPOS ':PIXEL))
      ;; Make any pack that exists show up in the "used" display even if used=0
      (DOTIMES (IDX 10)
	(AND (AREF FREE-ARRAY IDX)
	     (ASET 0 USED-ARRAY IDX)))
      (DO ((I 0 (\ (1+ I) 5)))
	  (NIL)
	(AND (ZEROP I) (TERPRI))
	(SETQ LINE (FUNCALL STREAM ':LINE-IN))
	(COND ((OR (NULL LINE)
		   (ZEROP (ARRAY-ACTIVE-LENGTH LINE))
		   (CHAR-EQUAL (AREF LINE 0) #\FF))
	       (RETURN NIL)))
	(FUNCALL STANDARD-OUTPUT ':TYO
		 (COND ((CHAR-EQUAL #/* (AREF LINE 0))
			#/*)
		       ((CHAR-EQUAL #/L (AREF LINE 2))
			#/:)
		       (T (LET ((USED)
				(PACK (PARSE-NUMBER LINE 2)))
			    (MULTIPLE-VALUE (USED TEM1) (PARSE-NUMBER LINE 20.))
			    (LET ((IDX (IF (OR (< PACK 10.) (> PACK 16.)) 0
					   (- PACK 9.))))
			      (ASET (+ (OR (AREF USED-ARRAY IDX) 0) USED)
				    USED-ARRAY IDX)))
			  (COND ((CHAR-EQUAL #/! (AREF LINE (1+ TEM1)))
				 #/!)
				(T #\SP)))))
	(FUNCALL STANDARD-OUTPUT ':STRING-OUT (NSUBSTRING LINE 6 19.))
	(FUNCALL STANDARD-OUTPUT ':STRING-OUT "  "))
      (FUNCALL STANDARD-OUTPUT ':FRESH-LINE)
      (MULTIPLE-VALUE (X1 Y1) (FUNCALL STANDARD-OUTPUT ':READ-CURSORPOS ':PIXEL))
      (FUNCALL STANDARD-OUTPUT ':SET-CURSORPOS X Y ':PIXEL)
      (FORMAT-DISK-BLOCKS-ARRAY STANDARD-OUTPUT "" USED-ARRAY)
      (FUNCALL STANDARD-OUTPUT ':SET-CURSORPOS X1 Y1 ':PIXEL)))
  DIS-NONE)

(DEFUN SUBSET-DIRECTORY-LISTING (PATHNAME)
  (LET ((FN1 (FUNCALL PATHNAME ':NAME))
	(FN2 (FUNCALL PATHNAME ':FN2)))
    (FORMAT T "~&~A~%" PATHNAME)
    (LET ((LINE NIL)
	  (FREE-ARRAY (MAKE-ARRAY 10))
	  (USED-ARRAY (MAKE-ARRAY 10)))
      (WITH-OPEN-FILE (STREAM (FUNCALL PATHNAME ':NEW-STRUCTURED-NAME '(".FILE." "(DIR)"))
			      '(READ))
	;; First find out how much space is free.
	(SETQ LINE (FUNCALL STREAM ':LINE-IN))
	(SETQ LINE (FUNCALL STREAM ':LINE-IN))
	(DIRECTORY-FREE-SPACE LINE FREE-ARRAY)
	;; Make any pack that exists show up in the "used" display even if used=0
	(DOTIMES (IDX 10)
	  (AND (AREF FREE-ARRAY IDX)
	       (ASET 0 USED-ARRAY IDX)))
	;; Next, go through lines of dir, counting USED and printing some lines.
	(DO ((KEY (STRING-APPEND " "
				 (IF (STRING-EQUAL FN1 "TS") FN2 FN1)
				 " "))
	     (LINE) (EOF))
	    (NIL)
	  (MULTIPLE-VALUE (LINE EOF)
	    (FUNCALL STREAM ':LINE-IN))
	  (AND (OR EOF (ZEROP (STRING-LENGTH LINE))) (RETURN NIL))
	  (AND (STRING-SEARCH KEY LINE)
	       (FUNCALL STANDARD-OUTPUT ':LINE-OUT LINE))
	  (OR (CHAR-EQUAL (AREF LINE 2) #/L)
	      (LET ((USED (PARSE-NUMBER LINE 20.))
		    (PACK (PARSE-NUMBER LINE 2)))
		(LET ((IDX (IF (OR (< PACK 10.) (> PACK 16.)) 0
			       (- PACK 9.))))
		  (ASET (+ (OR (AREF USED-ARRAY IDX) 0) USED) USED-ARRAY IDX)))))
	(FORMAT-DISK-BLOCKS-ARRAY T "Free: " FREE-ARRAY)
	(FORMAT-DISK-BLOCKS-ARRAY T ", Used: " USED-ARRAY)))))

;Element 0 of FREE-ARRAY is for packs other than 10.-16.
(DEFUN DIRECTORY-FREE-SPACE (LINE FREE-ARRAY)
  (DO ((I (STRING-SEARCH-CHAR #/# LINE)
	  (STRING-SEARCH-CHAR #/# LINE I))
       (NUM) (IDX) (BLKS))
      ((NULL I))
    (MULTIPLE-VALUE (NUM I)
      (PARSE-NUMBER LINE (1+ I)))
    (MULTIPLE-VALUE (BLKS I)
      (PARSE-NUMBER LINE (1+ I)))
    (SETQ IDX (IF (OR (< NUM 10.) (> NUM 16.)) 0
		  (- NUM 9.)))
    (ASET (+ (OR (AREF FREE-ARRAY IDX) 0) BLKS) FREE-ARRAY IDX)))

(DEFUN FORMAT-DISK-BLOCKS-ARRAY (STREAM TITLE ARRAY)
  (FORMAT STREAM TITLE)
  (DO ((IDX 0 (1+ IDX))
       (LIM (ARRAY-LENGTH ARRAY))
       (FIRSTP T)
       (BLKS))
      ((= IDX LIM))
    (COND ((SETQ BLKS (AREF ARRAY IDX))
	   (FORMAT STREAM "~:[+~]~D" FIRSTP BLKS)
	   (SETQ FIRSTP NIL)))))

(DEFUN ROTATED-DIRECTORY-LISTING (PATHNAME)
  (CATCH 'ABORT
     (LET ((DEV (FUNCALL PATHNAME ':DEVICE))
           (DIR (FUNCALL PATHNAME ':DIRECTORY))
           (FN1 (FUNCALL PATHNAME ':NAME))
           (FN NIL))
       (SETQ FN (FUNCALL PATHNAME ':NEW-STRUCTURED-NAME '(".FILE." "(DIR)")))
       (PROMPT-LINE "Directory Listing")
       (FORMAT T "~&~A  ~A    --   ~A~%" DEV DIR PATHNAME)
       (LET ((LINE NIL) (X 0) (Y 0))
	 (WITH-OPEN-FILE (STREAM FN '(IN))
	   (SETQ LINE (FUNCALL STREAM ':LINE-IN))
	   (FORMAT T "~A~%" (FUNCALL STREAM ':LINE-IN))
	   (DO ((LINE (SETQ LINE (FUNCALL STREAM ':LINE-IN))
		      (SETQ LINE (FUNCALL STREAM ':LINE-IN)))
		(LFN1 (STRING-LENGTH FN1))
		(LFN16 (+ (STRING-LENGTH FN1) 6))
		)
	       ((NULL LINE)
		(FORMAT T "There is no file named ~A in the directory.~%" FN1))
	     (COND ((STRING-EQUAL LINE FN1 6 0 LFN16 LFN1)
		    ;; Found one.
		    (LET ((FIRST LINE))
		      (SETQ LINE (DO ((LINE LINE (FUNCALL STREAM ':LINE-IN)))
				     ((OR (CHAR-EQUAL (AREF LINE 0) #\FF)
					  (NOT (STRING-EQUAL LINE FN1 6 0 LFN16 LFN1)))
				      LINE)
				   (FORMAT T "~A~%" LINE)))
		      (FORMAT T "==MORE==")
		      (OR (CHAR-EQUAL (FUNCALL STANDARD-INPUT ':TYI) #\SP)
			  (THROW 'ABORT NIL))
		      (MULTIPLE-VALUE (X Y)
			(FUNCALL STANDARD-OUTPUT ':READ-CURSORPOS))
		      (FUNCALL STANDARD-OUTPUT ':SET-CURSORPOS 0 Y)
		      (FUNCALL STANDARD-OUTPUT ':CLEAR-EOL)
		      (DO ((LINE LINE (FUNCALL STREAM ':LINE-IN)))
			  ((EQUAL LINE FIRST))
			(COND ((ZEROP (STRING-LENGTH LINE))
			       (FORMAT T "------------------------------------------------~%")
			       (CLOSE STREAM)
			       (SETQ STREAM (OPEN FN '(IN)))
			       (FUNCALL STREAM ':LINE-IN)
			       (FUNCALL STREAM ':LINE-IN)
			       (SETQ LINE (FUNCALL STREAM ':LINE-IN))))
			(FORMAT T "~A~%" LINE)))
		    (RETURN NIL)))))))))
||#

;(TV:ADD-TYPEOUT-ITEM-TYPE *TYPEOUT-COMMAND-ALIST* DIRECTORY "Edit" DIRECTORY-EDIT-1
;			  T "Run DIRED on this directory.")

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR EDIT-DIRECTORY
  (FS:WILDCARD-PATHNAME "Edit directory" *ZMACS-COMTAB*
			:GESTURE :SELECT)
  (DIRECTORY)
  `(DIRECTORY-EDIT-1 ,DIRECTORY))

(DEFUN DIRECTORY-EDIT-1 (DIRECTORY)
  (DIRECTORY-EDIT DIRECTORY)
  NIL)

;(TV:ADD-TYPEOUT-ITEM-TYPE *TYPEOUT-COMMAND-ALIST* DIRECTORY "Show" VIEW-DIRECTORY
;			  NIL "Show this directory")

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR VIEW-DIRECTORY
  (FS:WILDCARD-PATHNAME "Show directory" *ZMACS-COMTAB*)
  (DIRECTORY)
  `(VIEW-DIRECTORY ,DIRECTORY))

;(TV:ADD-TYPEOUT-ITEM-TYPE *TYPEOUT-COMMAND-ALIST* DIRECTORY-FILE "Edit"
;			  DIRECTORY-EDIT-FILE-1
;			  T "Run DIRED on this directory.")

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR EDIT-DIRECTORY-FILE
  (FS:DIRECTORY-PATHNAME "Edit directory" *ZMACS-COMTAB* :GESTURE :SELECT)
  (DIRECTORY-FILE)
  `(DIRECTORY-EDIT-FILE-1 ,DIRECTORY-FILE))

(DEFUN DIRECTORY-EDIT-FILE-1 (DIRECTORY-FILE)
  (DIRECTORY-EDIT (SEND (SEND DIRECTORY-FILE :PATHNAME-AS-DIRECTORY)
			:NEW-PATHNAME :NAME :WILD :TYPE :WILD :VERSION :WILD))
  NIL)

(DEFCOM COM-LIST-ALL-DIRECTORY-NAMES "Lists the names of all directories on a disk.
Prompts from the minibuffer for the name of the disk directory or device
directory to list and lists that directory." ()
  (LET* ((DEFAULT (SEND (DEFAULT-PATHNAME) ':NEW-PATHNAME
			':DIRECTORY ':WILD ':NAME ':WILD
			':TYPE ':WILD ':VERSION ':WILD))
	 (PATHNAME (ACCEPT-DEFAULTED-PATHNAME "List directories" DEFAULT))
	 (DIRS (BARF-ON-ERRORS (FS:FILE-ERROR)
		 (FS:ALL-DIRECTORIES PATHNAME ':SORTED))))
    (SCL:FORMAT-ITEM-LIST (LOOP FOR (PATHNAME) IN DIRS
				COLLECT (SEND PATHNAME :NEW-PATHNAME :NAME :WILD
								     :TYPE :WILD
								     :VERSION :WILD))
			  :PRESENTATION-TYPE `((FS:WILDCARD-PATHNAME) :FORMAT :DIRECTORY)))
  DIS-NONE)

(DEFCOM COM-EXPUNGE-DIRECTORY "Expunges deleted files from a directory.
Prompts from the minibuffer for the name of a directory to expunge and
expunges that directory.  The name is allowed to contain wildcards.
Types a message indicating why it cannot
expunge a directory when it cannot do so.  
Displays the number of blocks
freed on the disk as a result of expunging the directory.

When multiple top-level directories are specified by using wildcards,
you can use a numeric argument to force a query about whether other 
users at your site should be notified prior to the expunge; 
if no numeric argument is provided in this case, 
the behavior is controlled by SI:*EXPUNGE-NOTIFICATION-DEFAULT*." ()
  (LET ((DIRECTORY (READ-DIRECTORY-NAME "Expunge directory" (DEFAULT-PATHNAME)))
        (SI:*EXPUNGE-NOTIFICATION-DEFAULT*
	  (IF *NUMERIC-ARG-P* :QUERY SI:*EXPUNGE-NOTIFICATION-DEFAULT*)))
    (WHEN (SI:QUERY-EXPUNGE-DELAY (LIST DIRECTORY))
      (EXPUNGE-DIRECTORY-INTERNAL DIRECTORY)))
  DIS-NONE)

;Common subroutine for all expunge commands
;Returns the number of blocks freed
(DEFUN EXPUNGE-DIRECTORY-INTERNAL (DIRECTORY &OPTIONAL (REPORT-STREAM *TYPEIN-WINDOW*))
  (SETQ DIRECTORY (SEND DIRECTORY :NEW-PATHNAME :NAME :WILD :TYPE :WILD :VERSION :WILD))
  (IF (SEND DIRECTORY ':DIRECTORY-WILD-P)
      (LOOP FOR (SUBDIR) IN (BARF-ON-ERRORS (FS:FILE-ERROR)
			      (FS:ALL-DIRECTORIES DIRECTORY ':SORTED))
	    SUM (EXPUNGE-DIRECTORY-INTERNAL SUBDIR REPORT-STREAM) INTO TOTAL
	    FINALLY
	      (WHEN (PLUSP TOTAL)
		(FORMAT REPORT-STREAM "~&~A: ~D total block~:P freed." DIRECTORY TOTAL))
	      (RETURN TOTAL))
      (CONDITION-CASE (RESULT)
	  (FS:EXPUNGE-DIRECTORY DIRECTORY)
	(FS:FILE-OPERATION-FAILURE
	  (DIRED-REPORT-ERROR "expunge" DIRECTORY RESULT)
	  0)
	(:NO-ERROR
	 (FORMAT REPORT-STREAM "~&~A: ~D block~:P freed.~%" DIRECTORY RESULT)
	 RESULT))))




;(TV:ADD-TYPEOUT-ITEM-TYPE *TYPEOUT-COMMAND-ALIST* BP "Move" MOVE-POINT T
;			  "Move to this line.")

;(TV:ADD-TYPEOUT-ITEM-TYPE *TYPEOUT-COMMAND-ALIST* FILE "Find" FIND-DEFAULTED-FILE T
;			  "Find file this file.")

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR FIND-FILE-1
    (FS:PATHNAME "Find file" *ZMACS-COMTAB*
     :GESTURE :SELECT)
    (FILE)
  `(FIND-DEFAULTED-FILE ,FILE))

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR FIND-FILE-2
    (FS:PATHNAME "Edit file" *ZMACS-COMTAB*
     :GESTURE :EDIT-DEFINITION)			;lousy gesture name
    (FILE)
  `(FIND-DEFAULTED-FILE ,FILE))

(DEFUN FIND-DEFAULTED-FILE (STRING &AUX PATHNAME VERSION TRUENAME)
  (SETQ PATHNAME (MAKE-DEFAULTED-PATHNAME (STRING STRING) (PATHNAME-DEFAULTS)))
  ;;It we get a specific file, see if that was the newest and if so, use that instead
  (AND (NOT (MEMQ (SETQ VERSION (FUNCALL PATHNAME ':VERSION)) '(:NEWEST :UNSPECIFIC)))
       (SETQ TRUENAME  (FUNCALL (FUNCALL PATHNAME ':NEW-VERSION ':NEWEST) ':TRUENAME))
       (EQL VERSION (FUNCALL TRUENAME ':VERSION))
       (SETQ PATHNAME (FUNCALL PATHNAME ':NEW-VERSION ':NEWEST)))
  (FIND-FILE PATHNAME))

(DEFUN FIND-MULTIPLE-DEFAULTED-FILES (NAME-LIST &AUX PATHNAME VERSION TRUENAME
				                     BUFFER-TO-SELECT)
  (LOOP FOR NAME IN NAME-LIST
	DO
    (SETQ PATHNAME (MAKE-DEFAULTED-PATHNAME (STRING NAME) (PATHNAME-DEFAULTS)))
    ;;It we get a specific file, see if that was the newest and if so, use that instead
    (AND (NOT (MEMQ (SETQ VERSION (FUNCALL PATHNAME ':VERSION)) '(:NEWEST :UNSPECIFIC)))
	 (SETQ TRUENAME  (FUNCALL (FUNCALL PATHNAME ':NEW-VERSION ':NEWEST) ':TRUENAME))
	 (EQL VERSION (FUNCALL TRUENAME ':VERSION))
	 (SETQ PATHNAME (FUNCALL PATHNAME ':NEW-VERSION ':NEWEST)))
    (MULTIPLE-VALUE-BIND (NIL BUF)
	(FIND-FILE PATHNAME NIL)		; don't select it yet, get them all first
      (UNLESS BUFFER-TO-SELECT (SETQ BUFFER-TO-SELECT BUF))))
  (MAKE-BUFFER-CURRENT BUFFER-TO-SELECT))

;(TV:ADD-TYPEOUT-ITEM-TYPE *TYPEOUT-COMMAND-ALIST* FILE "Load" LOAD-DEFAULTED-FILE NIL
;			  "LOAD this file.")

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR LOAD-FILE
			     (FS:PATHNAME "Load file" *ZMACS-COMTAB*) (FILE)
  `(LOAD-DEFAULTED-FILE ,FILE))

(DEFUN LOAD-DEFAULTED-FILE (STRING)
  (LOAD (MAKE-DEFAULTED-PATHNAME (STRING STRING) (PATHNAME-DEFAULTS))))

;(TV:ADD-TYPEOUT-ITEM-TYPE *TYPEOUT-COMMAND-ALIST* FILE "Show" VIEW-DEFAULTED-FILE NIL
;			  "SHOW this file.")

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR VIEW-FILE
						  (FS:PATHNAME "Show file" *ZMACS-COMTAB*)
						  (FILE)
  `(VIEW-DEFAULTED-FILE ,FILE))

(DEFUN VIEW-DEFAULTED-FILE (STRING)
  (VIEW-FILE (MAKE-DEFAULTED-PATHNAME (STRING STRING) (PATHNAME-DEFAULTS)))
  (SEND TERMINAL-IO :FORCE-KBD-INPUT #\SPACE))


;;; ZMACS commands and support for files



;;; This is a user option.  If this variable is not NIL, then attempts
;;; to Find a non-existent file will be treated
;;; as an error, instead of giving the "(New File)" message.
(DEFCONST *FIND-FILE-NOT-FOUND-IS-AN-ERROR* NIL)

;;; This is a synonym for COM-FIND-FILE and MUST STAY IN STEP WITH IT.
(DEFCOM COM-EDIT-FILE "Visits a file in its own buffer.  (Synonym for COM-FIND-FILE.)
It prompts for a filename from the minibuffer, offering a default based on the
previous file name read.  It creates a buffer with the same name as the name
and type of the file and then selects it.  For files already in a buffer, it
selects the buffer. For a filename specifying a file that doesn't exist, it
creates and selects a buffer, marking it as a new file.  " ()
  (COM-FIND-FILE))

(DEFCOM COM-FIND-FILE "Visits a file in its own buffer.
It prompts for a filename from the minibuffer, offering a default based on the
previous file name read.  It creates a buffer with the same name as the name
and type of the file and then selects it.  For files already in a buffer, it
selects the buffer. For a filename specifying a file that doesn't exist, it
creates and selects a buffer, marking it as a new file.  " ()
  (LET ((PATHNAME (ACCEPT-DEFAULTED-PATHNAME "Find file" (PATHNAME-DEFAULTS)
					     :SPECIAL-VERSION NIL)))
    (LET ((*REVERT-FILE-NOT-FOUND-IS-AN-ERROR*
	    (AND (NOT *NUMERIC-ARG-P*) *FIND-FILE-NOT-FOUND-IS-AN-ERROR*)))
      (FIND-FILE PATHNAME T :QUERY)))
  (MAYBE-DISPLAY-DIRECTORY ':READ)
  DIS-TEXT)

(DEFCOM COM-FIND-FILE-IN-READ-ONLY-MODE "Visits a file in its own buffer.
This is like Find File but sets the buffer read-only." ()
  (LET ((PATHNAME (ACCEPT-DEFAULTED-PATHNAME "Find file in Read-only mode"
					     (PATHNAME-DEFAULTS)
					     :SPECIAL-VERSION NIL)))
    (LET ((*REVERT-FILE-NOT-FOUND-IS-AN-ERROR*
	    (AND (NOT *NUMERIC-ARG-P*) *FIND-FILE-NOT-FOUND-IS-AN-ERROR*)))
      (MULTIPLE-VALUE-BIND (NIL BUFFER)
	  (FIND-FILE PATHNAME T :QUERY)
	(SEND BUFFER :PUTPROP (SEND BUFFER :TICK) :SAVED-READ-WRITE-TICK)
	(SEND BUFFER :SET-TICK :READ-ONLY)
	(TYPEIN-LINE "Buffer ~A set to Read-Only" (SEND BUFFER :NAME)))))
  (MAYBE-DISPLAY-DIRECTORY :READ)
  DIS-TEXT)

(DEFCOM COM-FIND-FILE-IN-FUNDAMENTAL-MODE "Visits a file in its own buffer.
This is like Find File but reads the file in in Fundamental mode no matter
what its attribute list says.  One use for this is to prevent the names
of definitions in the buffer from being understood by Meta-., which is
useful when you read in an old version of a file and don't want to get
it mixed up with the new version.
It prompts for a filename from the minibuffer, offering a default based on the
previous file name read.  It creates a buffer with the same name as the name
and type of the file and then selects it.  For files already in a buffer, it
selects the buffer. For a filename specifying a file that doesn't exist, it
creates and selects a buffer, marking it as a new file.  " ()
  (LET ((PATHNAME (ACCEPT-DEFAULTED-PATHNAME "Find file in Fundamental mode" (PATHNAME-DEFAULTS)
					     :SPECIAL-VERSION NIL)))
    (LET ((*ZMACS-FORCE-FUNDAMENTAL-MODE* T)
	  (*REVERT-FILE-NOT-FOUND-IS-AN-ERROR*
	    (AND (NOT *NUMERIC-ARG-P*) *FIND-FILE-NOT-FOUND-IS-AN-ERROR*)))
      (FIND-FILE PATHNAME T :QUERY)))
  (MAYBE-DISPLAY-DIRECTORY ':READ)
  DIS-TEXT)

;;; This should only be used when the user spazzes from a C-X C-F
(DEFCOM COM-VISIT-FILE "Visits a file using the current buffer.
Use this if you give the wrong filename in C-X C-F, if it fails or if for any
reason you didn't get the file you wanted.  You can also use it in a buffer
that does not have an associated file.  In that case, the file is read but not
associated with the buffer.  You can use this for reading in previous versions
of files.  " ()
  (AND (NOT (MEMQ (SEND *INTERVAL* ':EDITING-FILE-P) '(NIL :NEW-FILE)))
       (BARF "This buffer is already editing a real file"))
  (AND (SEND *INTERVAL* ':SPECIAL-PURPOSE-P)
       (BARF "This is a special purpose buffer"))
  (OR (BP-= (INTERVAL-FIRST-BP *INTERVAL*) (INTERVAL-LAST-BP *INTERVAL*))
      (BARF "This buffer is not empty"))
  (LET ((PATHNAME (ACCEPT-DEFAULTED-PATHNAME "Visit file" (PATHNAME-DEFAULTS)
					     :SPECIAL-VERSION NIL))
	OTHER-BUFFER)
    (AND (SEND *INTERVAL* ':EDITING-FILE-P)
	 (SETQ OTHER-BUFFER (FIND-BUFFER-NAMED PATHNAME))
	 (NEQ OTHER-BUFFER *INTERVAL*)
	 (BARF "~A is already being edited in another buffer" PATHNAME))
    (SEND *INTERVAL* ':SET-PATHNAME-FOR-WRITE PATHNAME)
    (SEND *INTERVAL* ':REVERT))
  (MAYBE-DISPLAY-DIRECTORY ':READ)
  DIS-TEXT)

;; This does the real work for C-X C-F.  Given a pathname, it finds or makes
;; a buffer for the file and selects it, unless SELECT-P is NIL
;;
;; Version Control Entertainment.  It would be really awful to go and make a 
;; FILE-BUFFER, start to :REVERT it, and then discover that it was version controlled.
;; So this reads the attribute list an extra time to discover if it is version 
;; controlled.

(DEFVAR *ZMACS-FORCE-IGNORE-VERSION-CONTROL* NIL
  "Set to T to allow reading in the internal representation of a version controlled file.")


(DEFUN FIND-FILE-WILD (PATHNAME)
  (LET ((DIRECTORY-LIST (BARF-ON-ERRORS (FS:FILE-OPERATION-FAILURE)
			  (FS:DIRECTORY-LIST PATHNAME ':FAST ':SORTED)))
	(NEWEST-CHECK (EQ (SEND PATHNAME ':VERSION) ':NEWEST))
	(BUFFER NIL))
    (LOOP FOR (PATHNAME) IN DIRECTORY-LIST
	  DO (UNLESS (NULL PATHNAME)
	       (WHEN (OR NEWEST-CHECK
			 (EQ PATHNAME (PROBEF (SEND PATHNAME ':NEW-VERSION ':NEWEST))))
		 (SETQ PATHNAME (SEND PATHNAME ':NEW-VERSION ':NEWEST)))
	       (MULTIPLE-VALUE-BIND (NIL BUF)
		   (FIND-FILE PATHNAME NIL)
		 (WHEN (NULL BUFFER)
		   (SETQ BUFFER BUF)))))
    (WHEN (NULL BUFFER)
      (BARF "No files match ~A." PATHNAME))
    (VALUES BUFFER T)))				;claim to be "new",
						;and thus suppress extra checking
						;that was already done recursively.

(DEFVAR *FIND-VC-FILE-FUNCTION* NIL)

(DEFUN FIND-VC-FILE (&KEY PATHNAME STREAM ENCACHED-FILE)
  (IF (CL:MEMBER ':VERSION-CONTROL CL:*FEATURES*)
      (FUNCALL *FIND-VC-FILE-FUNCTION* :PATHNAME PATHNAME :STREAM STREAM
				       :ENCACHED-FILE ENCACHED-FILE)
      ;; When examining the file to see if it has -*- Version-Control:T -*-
      ;; at the front, when Version Control is not in the world, open the file with a
      ;; flat pathname, not a VC pathname; otherwise OPEN signals an error.  The error
      ;; we are looking for is file-not-found, not wrong-arguments-to-OPEN.
      ;; Also if STREAM or ENCACHED-FILE argument is supplied, use a flat pathname
      ;; in the error message.
      (WHEN PATHNAME
	(SETQ PATHNAME (SEND PATHNAME :NEW-PATHNAME ':VC-BRANCH NIL ':VC-VERSION NIL)))
      (IF (OR STREAM
	      ENCACHED-FILE
	      (WITH-OPEN-FILE-CASE (STREAM PATHNAME)
		(ERROR NIL)
		(:NO-ERROR
		  (LET ((ATTRIBUTES (FS:READ-ATTRIBUTE-LIST NIL STREAM)))
		    (NOT (NULL (CL:GETF ATTRIBUTES :VERSION-CONTROL)))))))
	  (BARF "~A is a Version Controlled file, but Version Control is not loaded."
		PATHNAME)
	  NIL)))

(DEFVAR *FIND-ALREADY-ENCACHED-VC-FILE-FUNCTION* NIL)

;;; This is patched over by version control.
(DEFUN FIND-ALREADY-ENCACHED-VC-FILE (PATHNAME)
  (IF (CL:MEMBER ':VERSION-CONTROL CL:*FEATURES*)
      (FUNCALL *FIND-ALREADY-ENCACHED-VC-FILE-FUNCTION* PATHNAME)
      NIL))

;; This is filled in by Writer Tools
(DEFVAR *FIND-WT-FILE-FUNCTION* NIL)

(COMPILER:FUNCTION-DEFINED 'FS:VC-PATHNAME-FLAT-PATHNAME)	; Forward reference: VC
(DEFUN FIND-FILE-NEW-BUFFER (PATHNAME CREATE-MISSING-DIRECTORY-P)
  "Called when the pathname wasn't a buffer as determined by FIND-BUFFER-NAMED.
This either means that we don't have the file read in anyplace, or that its a pathname
of a VC file without VC information."
  ;; the first way out is that there may be a VC file already encached by this
  ;; pathname. this punts us to the vc department instantly.
  ;; This always returns "New" buffers, because the VC ones, even if old,
  ;; really don't want to have their file-info checked by the usual mechanism.
  (WHEN *ZMACS-FORCE-IGNORE-VERSION-CONTROL*
    (SETQ PATHNAME (FS:VC-PATHNAME-FLAT-PATHNAME PATHNAME)))
  (OR (AND (NOT *ZMACS-FORCE-IGNORE-VERSION-CONTROL*)
	   (FIND-ALREADY-ENCACHED-VC-FILE PATHNAME))
      (AND (FS:PATHNAME-VC-P PATHNAME)
	   (IF (AND (EQUAL (FS:PATHNAME-VC-BRANCH PATHNAME) "")
		    (EQUAL (FS:PATHNAME-VC-VERSION PATHNAME) ""))
	       (PROGN
		 (SETQ PATHNAME (SEND PATHNAME :NEW-PATHNAME
				      ':VC-BRANCH NIL ':VC-VERSION NIL))
		 NIL)
	       (OR (FIND-VC-FILE :PATHNAME PATHNAME)
		   D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; if this returns nil, it means that the file wasn't
0		   1;; a version controlled file after all.
0		   (PROGN
		     (TYPEIN-LINE "~A is not a Version Controlled file." PATHNAME)
		     (THROW 'FIND-FILE-RECURSIVE
		       (MULTIPLE-VALUE-BIND (NIL BUFFER)
			   (FIND-FILE (SEND PATHNAME :NEW-PATHNAME
					    ':VC-BRANCH NIL ':VC-VERSION NIL)
				      NIL)
			 BUFFER))))))
      (LET ((KLUDGE T))				;No SI:WITH-OPEN-CHARACTER-FILE-CASE
	(CONDITION-BIND ((SI:BINARY-FILE-READ-AS-CHARACTER-FILE-ERROR
			   #'SI:BINARY-FILE-READ-AS-CHARACTER-FILE-ERROR-QUERY-HANDLER)
			 (SI:ESCAPE-LOADING-STREAM-DECODING-ERROR
			   #'SI:ESCAPE-LOADING-STREAM-DECODING-ERROR-QUERY-HANDLER)
			 (FS:FILE-OPERATION-FAILURE
			   #'(LAMBDA (CONDITION)
			       (WHEN KLUDGE
				 (IF (TYPEP CONDITION 'FS:FILE-NOT-FOUND)
				     ;; It's not version controlled if its not there at all
				     ;; Just revert ending up with an empty buffer
				     (RETURN-FROM FIND-FILE-NEW-BUFFER
				       (LET ((BUFFER (MAKE-BUFFER 'FILE-BUFFER
								  :PATHNAME PATHNAME
								  :ACTIVATE-P NIL)))
					 (SEND BUFFER :REVERT)
					 BUFFER))
				   ;; and if we blow, we blow.
				   (BARF "Error: ~A" CONDITION))))))
	  (WITH-ZWEI-WRITE-CREATE-DIRECTORIES (CREATE-MISSING-DIRECTORY-P)
	    (OR (AND *FIND-WT-FILE-FUNCTION*
		     (FUNCALL *FIND-WT-FILE-FUNCTION* PATHNAME))
		(SI:WITH-OPEN-CHARACTER-FILE (FSTREAM PATHNAME :DIRECTION :INPUT)
		  ;; This opens in :CHARACTERS :DEFAULT, but saying so explicitly
		  ;; makes it blow out File got open, perhaps version controlled.
		  (SETQ KLUDGE NIL)		;Turn off condition handler
		  (IF (AND (NOT *ZMACS-FORCE-IGNORE-VERSION-CONTROL*)
			   (SEND FSTREAM :CHARACTERS)	; vc files are never binary
			   (LET ((ATTRIBUTES (FS:READ-ATTRIBUTE-LIST NIL FSTREAM)))
			     (CL:GETF ATTRIBUTES :VERSION-CONTROL)))
		      (FIND-VC-FILE :STREAM FSTREAM)
		    ;; not version controlled.  we are going to revert
		    ;; some ordinary buffer, but borrow the stream.
		    (LET ((BUFFER (MAKE-BUFFER 'FILE-BUFFER
					       :PATHNAME PATHNAME :ACTIVATE-P NIL)))
		      (IF (SEND BUFFER :REVERT-WITH-STREAM-P)
			  (SEND BUFFER :REVERT-WITH-STREAM FSTREAM)
			(SEND BUFFER :REVERT))
		      BUFFER)))))))))

(DEFVAR *REVERT-UNEDITED-BUFFERS-FOR-NEW-VERSIONS* :QUERY
  "Option controlling whether to revert new unedited buffers if a new version appears.
Supported values are :QUERY (default), :NEVER and :ALWAYS.")

(DEFUN FIND-FILE (PATHNAME &OPTIONAL (SELECT-P T) CREATE-MISSING-DIRECTORY-P)
  (DECLARE (VALUES NIL BUFFER))
  (CL:ASSERT (CL:MEMBER CREATE-MISSING-DIRECTORY-P '(T :QUERY NIL)) ()
	     "CREATE-MISSING-DIRECTORY-P must be either T, NIL, or :QUERY.")
  1;; this catch is used when something turns out not to be version-controlled
0  1;; and the guts of the business just want to call find-file on a flat pathname.
0  (MULTIPLE-VALUE-BIND (BUFFER)			1;nicer indentation than let.
0      (CATCH 'FIND-FILE-RECURSIVE
	(SETQ PATHNAME (FS:MERGE-PATHNAMES PATHNAME *PATHNAME-DEFAULTS*))
	(MULTIPLE-VALUE-BIND (BUFFER CHECK-FILE-INFO)	;T if we found a buffer containing
						;this already and need to check.
	    ;;what follows can't be a COND, because of the brain damage that
	    ;; cond ((foo)) ...) dosen't return multiple values from foo.
	    (IF (SEND PATHNAME ':WILD-P) (VALUES (FIND-FILE-WILD PATHNAME) NIL)
	      ;;--- this next line will find a Force Ignore Version
	      ;;Control buffer in lieu of reading the version
	      ;;controlled file.  This has to be fixed --- bim.
	      (LET ((EXISTING-BUFFER (FIND-BUFFER-NAMED PATHNAME)))
		(IF EXISTING-BUFFER
		    ;; check-file-info only if file exists in filesystem
		    (VALUES EXISTING-BUFFER
			    (NOT (SYMBOLP (SEND EXISTING-BUFFER :FILE-INFO))))
		  (VALUES (FIND-FILE-NEW-BUFFER PATHNAME CREATE-MISSING-DIRECTORY-P)
			  NIL))))
	  (WHEN CHECK-FILE-INFO
	    (WITH-OPEN-FILE-CASE
	      (.ERROR. PATHNAME :DIRECTION :PROBE :IF-DOES-NOT-EXIST :ERROR)
	      (SYS:CONNECTION-ERROR
		(TYPEIN-LINE
		  "Note: ~~A~: cannot check for new versions of ~A."
		  .ERROR. PATHNAME))
	      (FS:FILE-NOT-FOUND
		(LET ((INFO (SEND BUFFER ':FILE-INFO)))
		  (UNLESS (ATOM INFO)		;ATOM is NIL or :NEVER-READ
		    (TYPEIN-LINE "Note: ~A is now missing from the file system."
				 (DESCRIBE-FILE-INFO INFO)))))
	      (FS:FILE-OPERATION-FAILURE
		(BARF "Error: ~A" .ERROR.))
	      (:NO-ERROR
		(LET ((STREAM .ERROR.))
		  (MULTIPLE-VALUE-BIND (NEW-DESC OLD-DESC)
		      (STREAM-CHECK-FILE-INFO STREAM (SEND BUFFER ':FILE-INFO))
		    (WHEN NEW-DESC
		      (LET* ((OLD-DATE (CDR (SEND BUFFER :FILE-INFO)))
			     (NEW-DATE (CDR (SEND STREAM :INFO)))
			     (UNMODIFIED? (NOT (SEND BUFFER ':MODIFIED-P)))
			     (REVERT? (AND UNMODIFIED?
					   (EQ *REVERT-UNEDITED-BUFFERS-FOR-NEW-VERSIONS*
					       :ALWAYS)))
			     (QUERY? (AND UNMODIFIED?
					  (NOT (MEMQ *REVERT-UNEDITED-BUFFERS-FOR-NEW-VERSIONS*
						     '(:NEVER :ALWAYS))))))
			(FORMAT T "~&Since you last read or wrote ~A ~%  (~A),
~:[the newest copy in the filesystem has changed:~;someone has written a new version out:~]
  (~A).
The buffer has ~:[~;not ~]been edited~
~:[ in the meantime; be careful not to lose your work!~;.  ~]
~:[~:[~&The buffer contents will be left alone, instead of reading in the new file.
You can use m-X Revert Buffer to replace the buffer contents with the new file.~;~
The buffer contents will be replaced by the new file.~]~;~]~%"
				PATHNAME OLD-DESC (> NEW-DATE OLD-DATE) NEW-DESC
				UNMODIFIED? UNMODIFIED? QUERY? REVERT?)
			(WHEN
			  (AND UNMODIFIED?
			       (CASEQ *REVERT-UNEDITED-BUFFERS-FOR-NEW-VERSIONS*
				 (:NEVER NIL)
				 (:ALWAYS T)
				 (OTHERWISE	;this handles :QUERY (and everything else)
				   (REVERT-BUFFER-OK-P BUFFER))))
			  (SEND BUFFER ':REVERT)))))))))
	  (SEND BUFFER ':ACTIVATE)
	  BUFFER))
    1;; the recursive callers always pass select-p nil and leave the selecting to this.
0    (WHEN SELECT-P (MAKE-BUFFER-CURRENT BUFFER))
    (VALUES NIL BUFFER)))

(DEFUN GET-SOURCE-COMPARE-OPTIONS (&KEY (OWN-WINDOW T) (STREAM CL:*STANDARD-OUTPUT*))
  (MULTIPLE-VALUE-CALL #'LOGIOR
    (DW:ACCEPTING-VALUES (STREAM :OWN-WINDOW OWN-WINDOW
				 :LABEL "Select options for comparison.")
      (VALUES
	(IF (SCL:ACCEPT 'SCL:BOOLEAN
			:PROMPT "Ignore Case and Style"
			:DEFAULT NIL
			:STREAM STREAM)
	    2 0)
	(IF (SCL:ACCEPT 'SCL:BOOLEAN
			:PROMPT "Ignore Leading Whitespace"
			:DEFAULT NIL
			:STREAM STREAM)
	    4 0)))))

(DEFUN REVERT-BUFFER-OK-P (BUFFER)
  (BEEP)
  (CL:LOOP
    (LET ((RESPONSE (LET ((QUERY-IO *TYPEOUT-WINDOW*))
		      (FQUERY '(:SELECT T
				:TYPE :READLINE
				:CHOICES ((T "Yes")
					  (NIL "No")
					  (:COMPARE "Compare")))
			      "Replace the buffer contents with the new file? "))))
      (IF (EQ RESPONSE :COMPARE)
	  (CONDITIONS:WITH-SIMPLE-RESTART (CONDITIONS:ABORT
					    "Return to query about reverting buffer ~A."
					    BUFFER)
	    (COMPARE-BUFFER-TO-FILE BUFFER (GET-SOURCE-COMPARE-OPTIONS)))
	  (RETURN RESPONSE)))))


;;; Given a stream and an old file-info, check that the file has not changed.
;;; If it has, return two strings, one describing the new file and one the
;;; old file.
(DEFUN STREAM-CHECK-FILE-INFO (STREAM FILE-INFO &AUX FILE-FILE-INFO)
  (COND ((NULL FILE-INFO) NIL)
	((EQUAL FILE-INFO (SETQ FILE-FILE-INFO (SEND STREAM ':INFO))) NIL)
	(T
	 (VALUES (DESCRIBE-FILE-INFO FILE-FILE-INFO)
		 (DESCRIBE-FILE-INFO FILE-INFO)))))

(DEFUN DESCRIBE-FILE-INFO (FILE-INFO)
  (WHEN (ATOM FILE-INFO)			;NIL or :NEVER-READ
    (RETURN-FROM DESCRIBE-FILE-INFO "a newly-created buffer"))
  (LET* ((TRUENAME (CAR FILE-INFO))
	 (AUTHOR (CONDITION-CASE ()
		     (LET ((PROPS (SEND TRUENAME ':PROPERTIES)))
		       (AND (LISTP PROPS) (GET PROPS ':AUTHOR)))
		   (FS:FILE-NOT-FOUND NIL)))
	 (CREATION-DATE (CDR FILE-INFO)))
    (WITH-OUTPUT-TO-STRING (STREAM)
      (PRINC TRUENAME STREAM)
      (WHEN (OR AUTHOR CREATION-DATE)
	(STRING-OUT ", created " STREAM)
	(WHEN AUTHOR
	  (FORMAT STREAM "by ~A" AUTHOR)
	  (AND CREATION-DATE (STRING-OUT " at " STREAM)))
	(WHEN CREATION-DATE
	  (TIME:PRINT-UNIVERSAL-TIME CREATION-DATE STREAM))))))

;;; Terser version: <pathname> (<author>, <date>)
(DEFUN SHORT-DESCRIBE-FILE-INFO (FILE-INFO)
  (WHEN (ATOM FILE-INFO)			;NIL or :NEVER-READ
    (RETURN-FROM SHORT-DESCRIBE-FILE-INFO "a newly-created buffer"))
  (LET* ((TRUENAME (CAR FILE-INFO))
	 (AUTHOR (CONDITION-CASE ()
		     (LET ((PROPS (SEND TRUENAME ':PROPERTIES)))
		       (AND (LISTP PROPS) (GET PROPS ':AUTHOR)))
		   (FS:FILE-NOT-FOUND NIL)))
	 (CREATION-DATE (CDR FILE-INFO)))
    (WITH-OUTPUT-TO-STRING (STREAM)
      (PRINC TRUENAME STREAM)
      (WHEN (OR AUTHOR CREATION-DATE)
	(STRING-OUT " (" STREAM)
	(WHEN AUTHOR
	  (FORMAT STREAM "~A" AUTHOR)
	  (AND CREATION-DATE (STRING-OUT ", " STREAM)))
	(WHEN CREATION-DATE
	  (TIME:PRINT-UNIVERSAL-TIME CREATION-DATE STREAM))
	(STRING-OUT #/) STREAM)))))

(DEFCOM COM-WRITE-FILE "Writes out the buffer to the specified file.
It changes the associated file for the buffer from whatever it was before to
the specified file.  " ()
  (LET ((PATHNAME (ACCEPT-DEFAULTED-PATHNAME "Write File" (PATHNAME-DEFAULTS)
					     :SPECIAL-VERSION NIL :DIRECTION :WRITE)))
    (IF (EQ PATHNAME (SEND *INTERVAL* :SEND-IF-HANDLES :PATHNAME))
	;; In this important special case, the user has done a c-X c-W <return>
	;; in order to do, in effect, c-X c-S.  So we will treat it as such.
	(WHEN (SAVE-BUFFER *INTERVAL*)
	  (MAYBE-DISPLAY-DIRECTORY ':WRITE))
      ;; This :set-pathname-for-write must be done now in order for the
      ;; :SAVE to know where to write.  If the save doesn't complete, the
      ;; interval has the new pathname instead of whatever it had before.
      ;; This is a bit unfortunate, but that's the way it is for now.
      (SEND *INTERVAL* ':SET-PATHNAME-FOR-WRITE PATHNAME)
      (CATCH 'SAVE-BUFFER
	(SEND *INTERVAL* ':SAVE)
	(MAYBE-DISPLAY-DIRECTORY ':WRITE))))
  DIS-NONE)

(DEFCOM COM-SAVE-FILE "Writes out changes to current file.
It does not write the file if the buffer is unchanged from when the file was
visited or last saved.  It reads a file name from the minibuffer if the
current buffer does not have an associated file.  " ()
  (COND ((NOT (SEND *INTERVAL* ':MODIFIED-P ':EXPLICIT-SAVING))
	 (TYPEIN-LINE "(No changes need to be written.)")
	 DIS-NONE)
	(T
	 (IF (SAVE-BUFFER *INTERVAL*)
	     (MAYBE-DISPLAY-DIRECTORY ':WRITE))
	 DIS-NONE)))

;;; This is a synonym for COM-SAVE-ALL-FILES and MUST STAY IN STEP WITH IT.
(DEFCOM COM-SAVE-FILE-BUFFERS "Offers to write out any changed file buffers.
A numeric argument causes the query to be skipped." ()
  (COM-SAVE-ALL-FILES))

(DEFCOM COM-SAVE-ALL-FILES "Offers to write out any changed file buffers.
A numeric argument causes the query to be skipped." ()
  (SAVE-ALL-FILES-INTERNAL :QUERY-P (NOT *NUMERIC-ARG-P*))
  DIS-NONE)

(DEFUN SAVE-ALL-FILES-INTERNAL (&KEY (BUFFERS-TO-CONSIDER (SCL:COPY-LIST* *ZMACS-BUFFER-LIST*))
				     (QUERY-P T))
  (LET* ((QUERY-IO *TYPEOUT-WINDOW*)
	 (BUFFERS-TO-SAVE (SAVE-ALL-FILES-INTERNAL-QUERY
			    :BUFFERS-TO-CONSIDER BUFFERS-TO-CONSIDER
			    :QUERY-P QUERY-P)))
    (SAVE-ALL-FILES-INTERNAL-EXECUTE :BUFFERS-TO-SAVE BUFFERS-TO-SAVE :QUERY-P QUERY-P)))

(DEFUN SAVE-FILE-BUFFER-QUERY-HELP (STREAM)
  (FORMAT STREAM
	  "~% Press Y (or Space) if you want to queue this buffer for saving after all ~
           ~%   queries are finished.~
	   ~% Press N (or Rubout) if you do not want to do anything to this buffer.~
	   ~% ------ ~'iOther Options~ -----~
	   ~% Press C (or =) to compare this buffer immediately to its file on disk.~
	   ~% Press H (or ? or Help) to see this text again.~
	   ~% Press L to skip this query for now and come back to it later, ~
	   ~%   after asking about any other buffers.~
	   ~% Press O (or Escape) to queue this buffer for saving under another name.~
	   ~% Press R to queue this buffer to be reverted.~
	   ~% Press U (or ~~) to queue this buffer to be marked as not modified.~
	   ~% Press V to view this buffer's contents immediately.~
	   ~% Press ! to queue the rest for saving now, as if you'd pressed lots of Y's.~
	   ~% ------ ~'iNotes~ -----~
           ~% ~:[No final query for confirmation is currently necessary~*~;~
	       A final query for confirmation is necessary if you use ~Q~]~:[.~2*~;,~
	   ~% but setting the variable ~@\presentation\ can change that.~]"
	  *SAVE-FILE-BUFFERS-OPTIONS-TO-CONFIRM*
	  #'(LAMBDA ()
	      (SCL:FORMAT-TEXTUAL-LIST
		(SORT (MAPCAR #'(LAMBDA (X)
				  (CL:ECASE X
				    (:LATER      "L")
				    (:SAVE-OTHER "O")
				    (:REVERT     "R")
				    (:SAVE       "Y")
				    (:UNMODIFY   "U")))
			      *SAVE-FILE-BUFFERS-OPTIONS-TO-CONFIRM*)
		      #'STRING-LESSP)
		#'PRINC
		:CONJUNCTION "or"))
	  (VARIABLE-BOUNDP *CURRENT-COMMAND-LOOP*)
	  '*SAVE-FILE-BUFFERS-OPTIONS-TO-CONFIRM*
	  'VARIABLE))

(DEFUN SAVE-FILE-BUFFER-STATUS (BUFFER QUERY-P)
  (LET ((QUERY-IO *TYPEOUT-WINDOW*)
	(CONCORDIA "Symbolics Concordia"))
    (LOOP DO
      (LET ((STATUS (COND ((AND ;; Tolerate MARKUP-BUFFER being undefined here.
			        (IGNORE-ERRORS (TYPEP BUFFER 'MARKUP-BUFFER))
				;; Is it really true that this can't be saved from Zmacs??
				;; -kmp 24-Nov-90
				;; Yes, it's really true that you can't save Concordia
				;; markup buffers except inside the Concordia activity.
				;; There is a basic bug (re saving from elsewhere) that would
				;; require a lot of work to fix [...] -Dodds 26-Nov-90
				(OR (NOT (VARIABLE-BOUNDP DW:*PROGRAM*))
				    (NOT (EQ (DW:PROGRAM-NAME DW:*PROGRAM*)
					     'SAGE::CONCORDIA))))
			   (TYPEOUT-LINE "~&Buffer ~A is modified, but it is~@
                   a Concordia markup buffer, which can only be saved from within the~@
                   ~@\PRESENTATION\ activity.  If you want to save it, please select~@
                   that activity now, and save the buffer manually."
					 BUFFER CONCORDIA 'SI:ACTIVITY-NAME)
			   (WHEN QUERY-P
			     (LOOP UNTIL
				     (FQUERY `(:CHOICES (((NIL "Concordia.") #/W)
							 ((T   "Yes.") #/Y #\Space))
					       :HELP-FUNCTION
					       (LAMBDA (STREAM)
						 (FORMAT STREAM 
					   "~&Press W to select Concordia.~
   					    ~%Press Y (or Space) when ready to continue.~%")))
					     "Ready to continue? ")
				     DO (SI:COM-SELECT-ACTIVITY CONCORDIA)))
			   :NOOP)
			  (QUERY-P
			   (FQUERY `(:CHOICES (((:COMPARE  "Compare."       ) #/C #/=)
					       ((:HELP     "Help.")	      #/H #/?)
					       ((:LATER    "Later."         ) #/L)
					       ((:NOOP     "No."            ) #/N #\Rubout)
					       ((:SAVE-OTHER    "Other."         ) #/O #\Escape)
					       ((:REVERT   "Revert."        ) #/R)
					       ((:UNMODIFY "Unmodify."      ) #/U #/~ #\Meta-~)
					       ((:VIEW     "View."          ) #/V)
					       ((:SAVE     "Yes."           ) #/Y #\Space)
					       ((:SAVE-REST "Yes! Save the rest.")
									      #/!))
				     :LIST-CHOICES NIL
				     :HELP-FUNCTION (SAVE-FILE-BUFFER-QUERY-HELP))
				   "Save file ~\PRESENTATION\ ? (Y, N, or Help) " BUFFER))
			  (T :SAVE))))
	(CATCH-ERROR-RESTART ((SYS:ABORT SYS:ERROR)
			      "Query again about saving ~A." BUFFER)
	  (ZL:SELECTQ STATUS
	    ((:COMPARE)  (CONDITION-CASE (CONDITION)
			      (ZWEI:COMPARE-BUFFER-TO-FILE BUFFER 1)
			    (FS:FILE-ERROR
			      (FORMAT ERROR-OUTPUT "~&Error: ~~A~~%" CONDITION)))) ;and loop
	    ((:VIEW)     (COND ((BP-= (INTERVAL-FIRST-BP BUFFER)
				      (INTERVAL-LAST-BP BUFFER))
				(FORMAT T "~&Buffer ~A is empty.~%" BUFFER))
			       (T
				(FORMAT T "~&=====[ Viewing ~A (Press ~@:C to abort) ]=====~%"
					BUFFER #\Abort)
				(VIEW-BUFFER BUFFER)
				(FORMAT T "~&=====[ End of ~A ]=====~%" BUFFER)))) ;and loop
	    ((:SAVE-OTHER)
	     		 (RETURN (VALUES :SAVE-OTHER
					 (SCL:ACCEPT 'CL:PATHNAME
						     :DEFAULT (SEND BUFFER :PATHNAME)
						     :DISPLAY-DEFAULT NIL
						     :PROMPT
						     (FORMAT NIL "Write ~A to file" BUFFER)))))
	    #|| ;We decided not to provide an interface to this and just to let :SAVE-OTHER
	        ;suffice here.  But the code is retained just in case. -kmp 28-Nov-90
	    ((:RENAME)   (SEND BUFFER :SET-PATHNAME-FOR-WRITE ;and then loop
			       (SCL:ACCEPT 'CL:PATHNAME
					   :DEFAULT (SEND BUFFER :PATHNAME)
					   :DISPLAY-DEFAULT NIL
					   :PROMPT "New filename for buffer")))
	    ||#
	    ((:HELP)     (SAVE-FILE-BUFFER-QUERY-HELP STANDARD-OUTPUT))
	    (OTHERWISE   (RETURN STATUS))))))))

(DEFUN SAVE-ALL-FILES-INTERNAL-QUERY (&KEY (BUFFERS-TO-CONSIDER
					     (SCL:COPY-LIST* *ZMACS-BUFFER-LIST*))
				      	   (QUERY-P T))
  (LET ((CONFIRM-P NIL))
    (CL:LOOP
       (LET ((BUFFERS-TO-CONSIDER BUFFERS-TO-CONSIDER)
	     (BUFFERS-TO-SAVE '())
	     (N 1))
	 (LOOP WHILE BUFFERS-TO-CONSIDER DO
	   (LET ((BUFFER (POP BUFFERS-TO-CONSIDER)))
	     (COND ((NULL BUFFER)
		    ;; NIL is used as a special marker that says we've cycled through
		    ;; and are about to ask another round of questions.
		    (FORMAT T "~&End of ~:R pass.  ~
			         Going to re-ask the ~R deferred quer~@:P for a ~:R time...~%"
			    N (LENGTH BUFFERS-TO-CONSIDER) (INCF N)))
		   (T
		    (WHEN (SEND BUFFER :MODIFIED-P ':FOR-SAVING)
		      (MULTIPLE-VALUE-BIND (STATUS DATA)
			  (SAVE-FILE-BUFFER-STATUS BUFFER QUERY-P)
			(CL:ECASE STATUS
			  ((:REVERT :UNMODIFY)
			   (PUSH (LIST BUFFER STATUS) BUFFERS-TO-SAVE))
			  ((:SAVE :SAVE-REST)
			   (PUSH (LIST BUFFER :SAVE) BUFFERS-TO-SAVE)
			   (IF (EQ STATUS :SAVE-REST) (SETQ QUERY-P NIL)))
			  ((:SAVE-OTHER)
			   (PUSH (LIST BUFFER :SAVE-OTHER DATA) BUFFERS-TO-SAVE))
			  ((:LATER)
			   (SETQ BUFFERS-TO-CONSIDER
				 ;; APPEND, not NCONC so we don't side-effect the argument,
				 ;; which might get re-used if we have to start querying over.
				 (APPEND BUFFERS-TO-CONSIDER
					 (IF (MEMBER NIL BUFFERS-TO-CONSIDER)
					     (NCONS BUFFER)
					     (LIST* NIL BUFFER '())))))
			  ((:NOOP)))
			(WHEN (AND (NOT CONFIRM-P)
				   (MEMBER STATUS
					   ZWEI:*SAVE-FILE-BUFFERS-OPTIONS-TO-CONFIRM*))
			  (SETQ CONFIRM-P T))))))))
	 (SETQ BUFFERS-TO-SAVE (NREVERSE BUFFERS-TO-SAVE))
	 (IF CONFIRM-P
	     (LET ((REPLY
		     (FQUERY `(:CHOICES (((:YES   "Yes.")   #/Y #/Space)
					 ((:NO    "No.")    #/N #\Rubout)
					 ((:RETRY "Retry.") #/R))
			       :HELP-FUNCTION
			       (LAMBDA (STREAM)
				 (FORMAT
				   STREAM 
				   "~&Press Y (or Space) to perform these queued actions.~
   				    ~%Press N (or Rubout) to cancel these queued actions.~
				    ~%Press R to retry per-buffer querying.~%")))
			     "~:[No queued actions to perform.  ~;~
				 ~:(~\This-These\~) action~:P will be performed~
			           ~:[~; (in order)~]:~{~
	                       ~%  ~A~}~
	                       ~%~]OK? "
			     BUFFERS-TO-SAVE
			     (LENGTH BUFFERS-TO-SAVE)
			     (CDR BUFFERS-TO-SAVE)
			     (MAPCAR #'(LAMBDA (X)
					 (CL:ECASE (SECOND X)
					   ((:SAVE-OTHER)
					    (FORMAT NIL "Save ~A to ~A" (FIRST X) (THIRD X)))
					   ((:SAVE :UNMODIFY :REVERT)
					    (FORMAT NIL "~:(~A~) ~A" (SECOND X) (FIRST X)))))
				     BUFFERS-TO-SAVE))))
	       (CL:ECASE REPLY
		 ((:YES) (RETURN BUFFERS-TO-SAVE))
		 ((:NO)  (RETURN :CANCELLED))
		 ((:RETRY))))
	     (RETURN BUFFERS-TO-SAVE))))))

(DEFUN SAVE-ALL-FILES-INTERNAL-EXECUTE (&KEY (BUFFERS-TO-SAVE '())
					     (QUERY-P NIL)
					     (EXPLICIT T))
  (SAVE-INTERNAL-BUFFERS QUERY-P)
  (WHEN (NEQ BUFFERS-TO-SAVE :CANCELLED)
    (DOLIST (ENTRY BUFFERS-TO-SAVE)
      (LET ((BUFFER    (FIRST  ENTRY))
	    (OPERATION (SECOND ENTRY)))
	(CL:ECASE OPERATION
	  ((:SAVE)       (SAVE-BUFFER BUFFER))
	  ((:SAVE-OTHER) (WRITE-INTERVAL-1 BUFFER NIL NIL :PATHNAME (THIRD ENTRY)))
	  ((:UNMODIFY)   (SET-NOT-MODIFIED BUFFER T)
			 (FORMAT T "~&Buffer ~A is now marked not modified.~%" BUFFER))
	  ((:REVERT)     (REVERT-BUFFER BUFFER))))))
  (LET ((STATUS (COND ((EQ BUFFERS-TO-SAVE :CANCELLED) "Cancelled")
		      (BUFFERS-TO-SAVE "Done")
		      (T "Nothing to do"))))
    (WHEN (OR EXPLICIT BUFFERS-TO-SAVE)
      (IF QUERY-P 
	  (FORMAT T "~&~A.~%" STATUS)
	  (TYPEIN-LINE "~A." STATUS)))))

(DEFUN SAVE-INTERNAL-BUFFERS (ASK-P)
  (COM-SAVE-WORD-ABBREV-FILE-INTERNAL (AND ASK-P ':ASK)))

(DEFUN SAVE-BUFFER-IF-NECESSARY (BUFFER &OPTIONAL CONFIRM)
  (AND (SEND BUFFER ':MODIFIED-P)
       (OR (NOT CONFIRM)
	   (FQUERY '(:SELECT T) "Save file ~A ? " (SEND BUFFER ':NAME)))
       (SAVE-BUFFER BUFFER)))

;(TV:ADD-TYPEOUT-ITEM-TYPE *TYPEOUT-COMMAND-ALIST* ZMACS-BUFFER "Save" SAVE-BUFFER NIL
;			  "Save this buffer.")

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR SAVE-BUFFER
						  (BUFFER "Save buffer" *ZMACS-COMTAB*)
						  (BUFFER)
  `(SAVE-BUFFER ,BUFFER))

;;; This can be called from top-level to try to save a bombed ZMACS
;;; It should only be used from outside Zmacs, since it binds all the magic Zmacs globals
(DEFUN SAVE-ALL-FILES (&OPTIONAL (ASK T))
  (LET (;Most code is tolerant of *WINDOW* being unbound, but not of it being NIL. -kmp
        ;(*WINDOW* NIL)
	(*WINDOW-LIST* '())
	(*INTERVAL* NIL)
	(*TYPEOUT-WINDOW* STANDARD-OUTPUT)
	(*TYPEIN-WINDOW* STANDARD-OUTPUT))
    (SAVE-ALL-FILES-INTERNAL :QUERY-P ASK)))

(DEFUN SAVE-ALL-FILES-QUERY (&OPTIONAL (ASK T))
  (LET (;(*WINDOW* NIL)
	(*WINDOW-LIST* NIL)
	(*INTERVAL* NIL)
	(*TYPEOUT-WINDOW* STANDARD-OUTPUT)
	(*TYPEIN-WINDOW* STANDARD-OUTPUT)
	(*NUMERIC-ARG-P* NIL))
    (SAVE-ALL-FILES-INTERNAL-QUERY :QUERY-P ASK)))

(DEFUN SAVE-ALL-FILES-EXECUTE (BUFFERS-TO-SAVE ASK &OPTIONAL EXPLICIT)
  (LET (;(*WINDOW* NIL)
	(*WINDOW-LIST* NIL)
	(*INTERVAL* NIL)
	(*TYPEOUT-WINDOW* STANDARD-OUTPUT)
	(*TYPEIN-WINDOW* STANDARD-OUTPUT)
	(*NUMERIC-ARG-P* NIL))
    (ZWEI:SAVE-ALL-FILES-INTERNAL-EXECUTE :BUFFERS-TO-SAVE BUFFERS-TO-SAVE
					  :QUERY-P ASK :EXPLICIT EXPLICIT)))

(si:define-application-logout-initialization save-zmacs-buffers-logout-initialization
 ((save-buffers '((cl:member :yes :no :ask))
	       :default :ask
	       :documentation "Save modified buffers before logging out"
	       ))
  (unless (eq save-buffers :no)
    (zwei:save-all-files-execute
      (si:application-logout-separate-querying
	(zwei:save-all-files-query (eq save-buffers :ask)))
      (eq save-buffers :ask)
      nil)))

(DEFCOM COM-REFIND-FILE
	"Reverts the buffer (discarding changes) only if the file has changed on disk. 
It prompts for a buffer name in the minibuffer and reads the most recent
version of the file from disk." ()
  (LET ((BUFFER (READ-BUFFER-NAME "Buffer to revert if necessary" *INTERVAL*)))
    (SELECTQ (REVERT-BUFFER-P BUFFER)
      (NIL (TYPEIN-LINE "The buffer ~A does not need to be reverted." (SEND BUFFER :NAME)))
      (:REFUSED (BARF))
      (OTHERWISE (SEND BUFFER :REVERT))))
  DIS-TEXT)

(DEFCOM COM-REFIND-ALL-FILES
	"Revert all buffers whose associated files have changed on disk.
With a numeric argument, it tries to revert only those buffers
whose name contains a given string." ()
  (LET* ((APROPOS (IF *NUMERIC-ARG-P*
		      (TYPEIN-LINE-READLINE
			"Revert buffers matching substring, if necessary:")))
	 (BUFFERS-TO-REVERT
	   (LOOP WITH QUERY-IO = *TYPEOUT-WINDOW*
		 FOR BUFFER IN *ZMACS-BUFFER-LIST*
		 WHEN (OR (NULL APROPOS)
			  (STRING-SEARCH APROPOS (SEND BUFFER :NAME)))
		   COLLECT (REVERT-BUFFER-P BUFFER T))))
    (LOOP WITH GOT-ONE = NIL
	  FOR BUFFER IN BUFFERS-TO-REVERT
	  WHEN (AND BUFFER
		    (SETQ GOT-ONE T)
		    (NEQ BUFFER :REFUSED))
	    DO (FORMAT T "~&Reverting buffer ~A." (SEND BUFFER :NAME))
	       (SEND BUFFER :REVERT)
	  FINALLY
	    (UNLESS GOT-ONE
	      (TYPEIN-LINE "No file buffers have been modified ~
                            on disk since you read or wrote them."))))
  DIS-TEXT)


;; Returns the buffer itself if it should be reverted, :REFUSED if the user
;; explicitly refused, and NIL otherwise
(DEFUN REVERT-BUFFER-P (BUFFER &OPTIONAL (ASK-USER NIL))
  (WHEN (SEND BUFFER :EDITING-FILE-P)
    (LET* ((BUFFER-INFO (SEND BUFFER :FILE-INFO))
	   (PATHNAME (SEND BUFFER :PATHNAME))	;knows about :newest or explicit version
	   (DISK-FILE-INFO
	     (DBG:WITH-DEBUGGER-SPECIAL-COMMAND (ERROR "Don't revert buffer ~A" PATHNAME)
		 (RETURN-FROM REVERT-BUFFER-P :REFUSED)
	       (CONDITION-CASE (ERROR)
		    (WHEN PATHNAME
		      (LET ((STREAM (OPEN PATHNAME :IF-DOES-NOT-EXIST :ERROR
					  :DIRECTION NIL :CHARACTERS T)))
			(AND STREAM (SEND STREAM :INFO))))
		  (FS:FILE-NOT-FOUND
		    (FORMAT T "~&The file ~A no longer exists." PATHNAME)
		    NIL)
		  (FS:FILE-OPERATION-FAILURE
		    (FORMAT T "~&Trouble probing ~A, continuing with next buffer.~%  ~A"
		      PATHNAME ERROR)
		    NIL)))))
      (AND DISK-FILE-INFO BUFFER-INFO
	   (NOT (EQUAL DISK-FILE-INFO BUFFER-INFO))
	   (LET ((PATHNAME (SEND BUFFER :PATHNAME)))
	     (IF (SEND BUFFER :MODIFIED-P)
		 ;; ask this one in the typeout window.
		 (IF (LET ((QUERY-IO *TYPEOUT-WINDOW*))
		       (FORMAT QUERY-IO
			       "~&~%Buffer pathname: ~A~@
			        Last input from: ~A~@
		                Version on disk: ~A~%~@
		 The buffer has been modified; you will lose the changes if you revert now."
			       PATHNAME (SHORT-DESCRIBE-FILE-INFO BUFFER-INFO)
			       (SHORT-DESCRIBE-FILE-INFO DISK-FILE-INFO))
		       (FQUERY FORMAT:YES-OR-NO-P-OPTIONS
			       "Revert anyway? "
			       PATHNAME (SHORT-DESCRIBE-FILE-INFO BUFFER-INFO)
			       (SHORT-DESCRIBE-FILE-INFO DISK-FILE-INFO)))
		     BUFFER :REFUSED)
	       (IF ASK-USER
		   (IF (FQUERY NIL
			       "~&~A has changed on disk.  Revert it? "
			       PATHNAME)
		       BUFFER :REFUSED)
		 BUFFER)))))))

(DEFCOM COM-REVERT-BUFFER
	"Reverts contents of the buffer to those of file on disk, discarding changes.
It prompts for the name of the buffer in the minibuffer and reads the most
recent version of the file from disk." ()
  (REVERT-BUFFER (READ-BUFFER-NAME "Buffer to revert" *INTERVAL*)))


(DEFUN REVERT-BUFFER (BUFFER)
  (WITH-INTERVAL-WRITE-LOCKED (BUFFER)
    (SEND BUFFER :REVERT))
  (IF (EQ BUFFER *INTERVAL*)
      DIS-TEXT
    (LET ((WINDOW (DOLIST (WINDOW *WINDOW-LIST*)
		    (AND (EQ (WINDOW-INTERVAL WINDOW) BUFFER)
			 (RETURN WINDOW)))))
      (AND WINDOW (MUST-REDISPLAY WINDOW DIS-TEXT)))
    DIS-NONE))

;;; This is used by Converse, so must be able to run without Zmacs.
(DEFUN PATHNAME-DEFAULTS (&OPTIONAL
			  (DEFAULTS *PATHNAME-DEFAULTS*)
			  RELEVANT-INTERVAL)
  (UNLESS RELEVANT-INTERVAL (SETQ RELEVANT-INTERVAL *INTERVAL*))
  (FS:SET-DEFAULT-PATHNAME
    (COND ((SEND RELEVANT-INTERVAL :SEND-IF-HANDLES :DEFAULT-PATHNAME))
	  ((SEND RELEVANT-INTERVAL :OPERATION-HANDLED-P :NAME)
	   (LET* ((NAME (SEND RELEVANT-INTERVAL :NAME))
		  (DEFAULT (FS:DEFAULT-PATHNAME DEFAULTS))
		  (HOST (SEND DEFAULT :HOST))
		  (PARSED)
		  (DEFAULTED))
	     (CONDITION-CASE ()
		  (SETQ PARSED (FS:PARSE-PATHNAME NAME HOST)
			DEFAULTED T)
		(FS:PATHNAME-ERROR (SETQ PARSED DEFAULT)))
	     (WHEN (SEND PARSED :WILD-P)
	       (SETQ PARSED DEFAULT
		     DEFAULTED T))
	     (WHEN (OR DEFAULTED
		       (NULL (SEND PARSED :TYPE)))
	       (WHEN (SETQ DEFAULTED
			   (LET ((MAJOR-MODE (SEND RELEVANT-INTERVAL :GET :MAJOR-MODE)))
			     (AND MAJOR-MODE
				  (CANONICAL-TYPE-FROM-MAJOR-MODE MAJOR-MODE))))
		 (SETQ PARSED (SEND PARSED :NEW-DEFAULT-PATHNAME :TYPE DEFAULTED))))
	     (FS:MERGE-PATHNAMES PARSED DEFAULT)))
	  (T (FS:DEFAULT-PATHNAME DEFAULTS)))
    DEFAULTS)
  DEFAULTS)

(DEFUN DEFAULT-PATHNAME (&OPTIONAL (DEFAULTS *PATHNAME-DEFAULTS*))
  (FS:DEFAULT-PATHNAME (PATHNAME-DEFAULTS DEFAULTS)))

(DEFVAR *LAST-NON-DAEMON-USER-ID* NIL)

(ADD-INITIALIZATION "Reset non daemon user" '(SETQ *LAST-NON-DAEMON-USER-ID* NIL)
		    '(:LOGOUT))

(DEFUN NON-DAEMON-USER-ID ()
  (IF (NEQ (SEND SI:*USER* ':TYPE) ':DAEMON)
      USER-ID
    (LET ((ANS (IF (VARIABLE-BOUNDP *MINI-BUFFER-WINDOW*)	;prompt may happen in LL
		   (TYPEIN-LINE-READLINE "Who are you really?~@[ (default: ~A)~]"
					 *LAST-NON-DAEMON-USER-ID*)
		 (DW:ACCEPT '((CL:STRING))
			    :PROMPT "Who are you really?"
			    :DEFAULT *LAST-NON-DAEMON-USER-ID*))))
      (IF (STRING-EQUAL ANS "")
	  (OR *LAST-NON-DAEMON-USER-ID* USER-ID)
	(SETQ *LAST-NON-DAEMON-USER-ID* ANS)))))

(DEFUN FILE-LOADED-TRUENAME (PATHNAME)
  (OR (LET* ((GENERIC-PATHNAME (SEND PATHNAME ':GENERIC-PATHNAME))
	     (SOURCE-PATHNAME (SEND GENERIC-PATHNAME ':GET ':QFASL-SOURCE-FILE-UNIQUE-ID)))
	(WHEN (STRINGP SOURCE-PATHNAME)		;Old versions of the compiler
	  (SETQ SOURCE-PATHNAME (FS:MERGE-PATHNAMES SOURCE-PATHNAME PATHNAME)))
	(AND (NOT (NULL SOURCE-PATHNAME))
	     (LET ((TYPE-1 (SEND SOURCE-PATHNAME ':CANONICAL-TYPE))
		   (TYPE-2 (SEND PATHNAME ':CANONICAL-TYPE)))
	       (OR (EQUAL TYPE-1 TYPE-2)
		   (AND (MEMBER TYPE-1 FS:*KNOWN-TYPES*)
			(MEMBER TYPE-2 FS:*KNOWN-TYPES*))))
	     (IF (EQ (SEND GENERIC-PATHNAME ':HOST) (SEND SOURCE-PATHNAME ':HOST))
		 SOURCE-PATHNAME
		 (SEND GENERIC-PATHNAME ':NEW-DEFAULT-PATHNAME
		       ':CANONICAL-TYPE (SEND SOURCE-PATHNAME ':CANONICAL-TYPE)
		       ':VERSION (SEND SOURCE-PATHNAME ':VERSION)))))
      (LET* ((NEWEST-PATHNAME (SEND PATHNAME ':NEW-VERSION ':NEWEST))
	     (ID (SI:GET-FILE-LOADED-ID NEWEST-PATHNAME PACKAGE)))
	(AND ID (SEND (CAR ID) :TRANSLATED-PATHNAME)))))

