;;; -*- Syntax: Zetalisp; Mode: LISP; Package: ZWEI; Base: 8 -*-
;;; Macros for ZWEI.
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(DEFMACRO CHARMAP ((FROM-BP-FORM TO-BP-FORM &REST RETURN-FORMS) &BODY BODY)
  `(CHARMAP-PER-LINE (,FROM-BP-FORM ,TO-BP-FORM ,@RETURN-FORMS) (NIL) . ,BODY))

(DEFMACRO CHARMAP-MUNGING-LINES ((FROM-BP-FORM TO-BP-FORM &REST RETURN-FORMS) &BODY BODY)
  `(CHARMAP-PER-LINE (,FROM-BP-FORM ,TO-BP-FORM . ,RETURN-FORMS)
		     ((SETQ LINE (MUNG-LINE LINE)))
     . ,BODY))

(DEFMACRO CHARMAP-PER-LINE ((FROM-BP-FORM TO-BP-FORM &REST RETURN-FORMS)
			    LINE-FORMS &BODY BODY)
  `(LET ((*FROM-BP* ,FROM-BP-FORM)
         (*TO-BP* ,TO-BP-FORM))
     (DO-NAMED *CHARMAP*
        ((LINE (BP-LINE *FROM-BP*) (LINE-NEXT-IN-BUFFER LINE))
         (*FIRST-INDEX* (BP-INDEX *FROM-BP*) 0)
         (*LAST-LINE* (BP-LINE *TO-BP*))
	 (*THIS-IS-THE-LAST-LINE*))
        (NIL)
      (SETQ *THIS-IS-THE-LAST-LINE* (EQ LINE *LAST-LINE*))
      ,@LINE-FORMS
      (DO ((INDEX *FIRST-INDEX* (1+ INDEX))
           (*LAST-INDEX* (IF *THIS-IS-THE-LAST-LINE* (1- (BP-INDEX *TO-BP*))
			     (LINE-LENGTH LINE))))
          ((> INDEX *LAST-INDEX*)
           (IF *THIS-IS-THE-LAST-LINE*
               (RETURN-FROM *CHARMAP* (PROGN . ,RETURN-FORMS))))
	. ,BODY))))

(DEFMACRO LINEMAP ((FROM-BP-FORM TO-BP-FORM &REST RETURN-FORMS) &BODY BODY)
  `(LET ((*FROM-BP* ,FROM-BP-FORM)
         (*TO-BP* ,TO-BP-FORM))
     (DO-NAMED *LINEMAP*
	       ((LINE (BP-LINE *FROM-BP*) (LINE-NEXT-IN-BUFFER LINE))
		(*FIRST-INDEX* (BP-INDEX *FROM-BP*) 0)
		(*LAST-LINE* (BP-LINE *TO-BP*))
		(*THIS-IS-THE-LAST-LINE*)
		(*LAST-INDEX*))
	       (NIL)
       (PROGN *FIRST-INDEX* *LAST-INDEX*)	D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI"); These may or may not be referenced
0       (IF (SETQ *THIS-IS-THE-LAST-LINE* (EQ LINE *LAST-LINE*))
	   (SETQ *LAST-INDEX* (BP-INDEX *TO-BP*))
	   (SETQ *LAST-INDEX* (LINE-LENGTH LINE)))
       ,@BODY
       (WHEN *THIS-IS-THE-LAST-LINE*
	 (RETURN-FROM *LINEMAP* (PROGN . ,RETURN-FORMS))))))

(DEFMACRO LINEMAP-INTERVAL ((INTERVAL &REST RETURN-FORMS) &BODY BODY)
  `(LINEMAP ((INTERVAL-FIRST-BP ,INTERVAL)
	     (INTERVAL-LAST-BP ,INTERVAL)
	     ,@RETURN-FORMS)
     . ,BODY))

(DEFMACRO LINEMAP-LINE ()
  `LINE)

(DEFMACRO RLINEMAP ((FROM-BP-FORM TO-BP-FORM &REST RETURN-FORMS) &BODY BODY)
  `(LET ((*FROM-BP* ,FROM-BP-FORM)
         (*TO-BP* ,TO-BP-FORM))
     (DO*-NAMED *RLINEMAP*
        ((LINE (BP-LINE *FROM-BP*) (LINE-PREVIOUS-IN-BUFFER LINE))
	 (*FIRST-INDEX* 0)
         (*LAST-LINE* (BP-LINE *TO-BP*))
	 (*THIS-IS-THE-LAST-LINE*)
	 (*LAST-INDEX* (BP-INDEX *FROM-BP*) (LINE-LENGTH LINE)))
        (NIL)
      (IF (SETQ *THIS-IS-THE-LAST-LINE* (EQ LINE *LAST-LINE*))
	  (SETQ *FIRST-INDEX* (BP-INDEX *TO-BP*)))
      ,@BODY
      (WHEN *THIS-IS-THE-LAST-LINE*
	(RETURN-FROM *RLINEMAP* (PROGN . ,RETURN-FORMS))))))

;;; This is for things that take an interval as an argument, or two bps, maybe in order,
;;; it canonicalises them into two ordered bps
;;; Needed here for following function.
(DEFMACRO GET-INTERVAL (START-BP &OPTIONAL END-BP IN-ORDER-P)
  `(CL:MULTIPLE-VALUE-SETQ (,START-BP ,END-BP)
     (GET-INTERVAL-1 ,START-BP ,END-BP ,IN-ORDER-P)))

;;; Macro to map over lines in interval.
;;; More useful than map-over-lines-in-interval in that it actually does
;;; the work of iterating over the lines, calling the continuation on
;;; each one.  It also binds substring index variables.
(DEFMACRO DO-LINES-IN-INTERVAL ((INTERVAL LINE-VAR FIRST-INDEX-VAR LAST-INDEX-VAR) &BODY BODY)
  `(DO-LINES-IN-INTERVAL-1 ,INTERVAL
     (NAMED-LAMBDA DO-LINES-IN-INTERVAL (,LINE-VAR ,FIRST-INDEX-VAR ,LAST-INDEX-VAR)
       (DECLARE (SYS:DOWNWARD-FUNCTION))
       ,@BODY)))

(DEFUN DO-LINES-IN-INTERVAL-1 (INTERVAL CONTINUATION)
  (LET* ((FIRST-BP (INTERVAL-FIRST-BP INTERVAL))
	 (LAST-BP (INTERVAL-LAST-BP INTERVAL))
	 (FIRST-INDEX (BP-INDEX FIRST-BP))
	 (FIRST-LINE (BP-LINE FIRST-BP))
	 (LAST-INDEX (BP-INDEX LAST-BP))
	 (LAST-LINE (BP-LINE LAST-BP)))
    (LOOP FOR LINE = FIRST-LINE THEN (LINE-NEXT-IN-BUFFER LINE)
	  DO (FUNCALL CONTINUATION
		      LINE
		      (IF (EQ LINE FIRST-LINE) FIRST-INDEX 0)
		      (IF (EQ LINE LAST-LINE) LAST-INDEX (LINE-LENGTH LINE)))
	  UNTIL (EQ LINE LAST-LINE))))

;;; Macro to map over lines.
;;; More useful than map-over-lines-in-interval, in that it actually
;;; lets you specify the interval in the usual way, and lets you specify the
;;; buffer, etc. as well.
;;; In exchange, the syntax is a bit hairier.

(DEFMACRO DO-LINES (((LINE-VAR FIRST-INDEX-VAR LAST-INDEX-VAR)
		     (FIRST-BP &OPTIONAL LAST-BP IN-ORDER-P)
		     &REST OPTIONS &KEY BUFFER IGNORE-VC-DIAGRAM-LINES)
		    &BODY BODY)
  (IGNORE BUFFER IGNORE-VC-DIAGRAM-LINES)
  `(DO-LINES-1 ,FIRST-BP ,LAST-BP ,IN-ORDER-P
	       (NAMED-LAMBDA DO-LINES (,LINE-VAR ,FIRST-INDEX-VAR ,LAST-INDEX-VAR)
		 (DECLARE (SYS:DOWNWARD-FUNCTION))
		 ,@BODY)
	       ,@OPTIONS))

(DEFUN DO-LINES-1 (FIRST-BP LAST-BP IN-ORDER-P CONTINUATION &REST OPTIONS)
  (GET-INTERVAL FIRST-BP LAST-BP IN-ORDER-P)
  (LET ((FIRST-INDEX (BP-INDEX FIRST-BP))
	(FIRST-LINE (BP-LINE FIRST-BP))
	(LAST-INDEX (BP-INDEX LAST-BP))
	(LAST-LINE (BP-LINE LAST-BP)))
    (LOOP FOR LINE = FIRST-LINE THEN (CL:APPLY #'LINE-NEXT-IN-BUFFER LINE OPTIONS)
	  DO (FUNCALL CONTINUATION
		      LINE
		      (IF (EQ LINE FIRST-LINE) FIRST-INDEX 0)
		      (IF (EQ LINE LAST-LINE) LAST-INDEX (LINE-LENGTH LINE)))
	  UNTIL (EQ LINE LAST-LINE))))

(DEFMACRO CHARMAP-RETURN (&REST RETURN-FORMS)
  `(RETURN-FROM *CHARMAP* (PROGN . ,RETURN-FORMS)))

(DEFMACRO CHARMAP-CHAR ()
  '(COND ((AND (= INDEX *LAST-INDEX*)
	       (NOT *THIS-IS-THE-LAST-LINE*))
	  #\CR)
	 (T (AREF LINE INDEX))))

(DEFMACRO CHARMAP-SET-CHAR (CHAR)
  `(PROGN
    (MUNG-BP-INTERVAL *FROM-BP*)
    (SETQ LINE (MUNG-LINE LINE))
    (COND ((AND (= INDEX *LAST-INDEX*)
		(NOT *THIS-IS-THE-LAST-LINE*))
	   (INSERT (DELETE-INTERVAL (END-LINE LINE) (BEG-LINE LINE 1) T) ,CHAR))
	  (T
	   ;; This doesn't hack undo!
	   (ASET ,CHAR LINE INDEX)))))

(DEFMACRO CHARMAP-BP-BEFORE ()
  '(CREATE-BP LINE INDEX))

(DEFMACRO CHARMAP-BP-AFTER ()
  '(COND ((AND (= INDEX *LAST-INDEX*)
	       (NOT *THIS-IS-THE-LAST-LINE*))
	  (CREATE-BP (LINE-NEXT-IN-BUFFER LINE) 0))
	 (T
	  (CREATE-BP LINE (1+ INDEX)))))

(DEFMACRO CHARMAP-INCREMENT (&REST RETURN-FORMS)
  `(COND ((> (SETQ INDEX (1+ INDEX)) *LAST-INDEX*)
	  (COND (*THIS-IS-THE-LAST-LINE*
		 (RETURN-FROM *CHARMAP* (PROGN . ,RETURN-FORMS)))
		(T (SETQ INDEX 0
			 LINE (LINE-NEXT-IN-BUFFER LINE)
			 *THIS-IS-THE-LAST-LINE* (EQ LINE *LAST-LINE*)
			 *LAST-INDEX* (IF *THIS-IS-THE-LAST-LINE* (1- (BP-INDEX *TO-BP*))
					  (LINE-LENGTH LINE))))))))

(DEFMACRO CHARMAP-INCREMENT-LINE (&REST RETURN-FORMS)
  `(COND (*THIS-IS-THE-LAST-LINE*
	  (RETURN-FROM *CHARMAP* (PROGN . ,RETURN-FORMS)))
	 (T (SETQ INDEX 0
		  LINE (LINE-NEXT-IN-BUFFER LINE)
		  *THIS-IS-THE-LAST-LINE* (EQ LINE *LAST-LINE*)
		  *LAST-INDEX* (IF *THIS-IS-THE-LAST-LINE* (1- (BP-INDEX *TO-BP*))
				   (LINE-LENGTH LINE))))))

(DEFMACRO CHARMAP-END-OF-LINE ()
  `(SETQ INDEX *LAST-INDEX*))

(DEFMACRO CHARMAP-INDEX ()
  'INDEX)

(DEFMACRO CHARMAP-LINE ()
  'LINE)

(DEFMACRO RCHARMAP ((FROM-BP-FORM TO-BP-FORM &REST RETURN-FORMS) &BODY BODY)
  `(RCHARMAP-PER-LINE (,FROM-BP-FORM ,TO-BP-FORM . ,RETURN-FORMS) (NIL) . ,BODY))

(DEFMACRO RCHARMAP-PER-LINE ((FROM-BP-FORM TO-BP-FORM &REST RETURN-FORMS) LINE-FORMS &BODY BODY)
  `(LET ((*FROM-BP* ,FROM-BP-FORM)
         (*TO-BP* ,TO-BP-FORM))
     (DO-NAMED *RCHARMAP*
        ((LINE (BP-LINE *FROM-BP*) (LINE-PREVIOUS-IN-BUFFER LINE))
         (*FIRST-LINE-P* T NIL)
         (*LAST-LINE* (BP-LINE *TO-BP*))
         (*THIS-IS-THE-LAST-LINE*))
        (NIL)
      (WHEN (NULL LINE)				; fell off the LINE chain
	 (RETURN-FROM *RCHARMAP* (COPY-BP (INTERVAL-FIRST-BP *INTERVAL*))))
      (SETQ *THIS-IS-THE-LAST-LINE* (EQ LINE *LAST-LINE*))
      ,@LINE-FORMS
      ;; Note that index can take on the value of the length of a line, which means the CR
      (DO ((INDEX (IF *FIRST-LINE-P* (1- (BP-INDEX *FROM-BP*)) (LINE-LENGTH LINE))
                  (1- INDEX))
           (*LAST-INDEX* (IF *THIS-IS-THE-LAST-LINE*
                             (BP-INDEX *TO-BP*)
                             0)))
          ((< INDEX *LAST-INDEX*)
           (IF *THIS-IS-THE-LAST-LINE*
               (RETURN-FROM *RCHARMAP* (PROGN . ,RETURN-FORMS))))
        . ,BODY))))

(DEFMACRO RCHARMAP-RETURN (&REST RETURN-FORMS)
  `(RETURN-FROM *RCHARMAP* (PROGN . ,RETURN-FORMS)))

(DEFMACRO RCHARMAP-CHAR ()
  '(COND ((= INDEX (LINE-LENGTH LINE)) #\CR)
         (T (AREF LINE INDEX))))

(DEFMACRO RCHARMAP-CHAR-BEFORE ()
  '(IF (ZEROP INDEX) #\CR (AREF LINE (1- INDEX))))

(DEFMACRO RCHARMAP-SET-CHAR (CHAR)
  `(PROGN
    (MUNG-BP-INTERVAL *FROM-BP*)
    (SETQ LINE (MUNG-LINE LINE))
    (COND ((= INDEX (LINE-LENGTH LINE))
	   (INSERT (DELETE-INTERVAL (END-LINE LINE) (BEG-LINE LINE 1) T) ,CHAR))
	  (T
	   ;; This doesn't hack undo!
	   (ASET ,CHAR LINE INDEX)))))

(DEFMACRO RCHARMAP-BP-BEFORE ()
  '(CREATE-BP LINE INDEX))

(DEFMACRO RCHARMAP-BP-AFTER ()
  '(COND ((= INDEX (LINE-LENGTH LINE))
	  (CREATE-BP (LINE-NEXT-IN-BUFFER LINE) 0))
	 (T (CREATE-BP LINE (1+ INDEX)))))

(DEFMACRO RCHARMAP-DECREMENT (&REST RETURN-FORMS)
  `(COND ((< (SETQ INDEX (1- INDEX)) *LAST-INDEX*)
	  (COND (*THIS-IS-THE-LAST-LINE*
		 (RETURN-FROM *RCHARMAP* (PROGN . ,RETURN-FORMS)))
		(T (UNLESS (SETQ LINE (LINE-PREVIOUS-IN-BUFFER LINE))
		     ;; May fall off beginning of line chain
		     (RETURN-FROM *RCHARMAP*
		       (COPY-BP (INTERVAL-FIRST-BP *INTERVAL*))))
		   (SETQ *FIRST-LINE-P* NIL
			 INDEX (1- (LINE-LENGTH LINE))
			 *THIS-IS-THE-LAST-LINE* (EQ LINE *LAST-LINE*)
			 *LAST-INDEX* (IF *THIS-IS-THE-LAST-LINE* (BP-INDEX *TO-BP*) 0)))))))

(DEFMACRO RCHARMAP-LINE ()
  'LINE)

(DEFMACRO PUSH* (I R)
  `(OR (MEMQ ,I ,R) (PUSH ,I ,R)))

(DEFMACRO ORDER-BPS (BP1 BP2)
  `(COND ((BP-< ,BP2 ,BP1)
	  (PSETQ ,BP1 ,BP2 ,BP2 ,BP1))))

(DEFMACRO WORD-SYNTAX (CHAR)
  `(CHAR-SYNTAX ,CHAR *MODE-WORD-SYNTAX-TABLE*))

(DEFMACRO ATOM-WORD-SYNTAX (CHAR)
  `(CHAR-SYNTAX ,CHAR *ATOM-WORD-SYNTAX-TABLE*))

(DEFMACRO C-WORD-SYNTAX (CHAR)
  `(CHAR-SYNTAX ,CHAR *C-WORD-SYNTAX-TABLE*))

(DEFMACRO LIST-SYNTAX (CHAR)
  `(CHAR-SYNTAX ,CHAR *MODE-LIST-SYNTAX-TABLE*))

(DEFMACRO ATOM-WORD-SYNTAX-BIND (&BODY BODY)
  `(LET ((*MODE-WORD-SYNTAX-TABLE* *ATOM-WORD-SYNTAX-TABLE*))
     . ,BODY))

(DEFMACRO CHAR-SYNTAX* (CHAR SYNTAX-TABLE SYNTAX-TABLE-LENGTH)
  `(IF (ZEROP (CHAR-BITS ,CHAR))
       (LET ((CODE (CHAR-CODE ,CHAR)))
	 (IF (< CODE ,SYNTAX-TABLE-LENGTH)
	     (AREF ,SYNTAX-TABLE CODE)
	   (MULTIPLE-VALUE-BIND (CHARACTER-SET CHARACTER-INDEX)
	       (SI:CHAR-CHAR-SET-AND-INDEX ,CHAR)
	     (SI:CHARACTER-SET-CHAR-SYNTAX CHARACTER-SET CHARACTER-INDEX ,SYNTAX-TABLE))))
     WORD-DELIMITER))

(DEFMACRO PRESERVE-POINT (&BODY BODY)
  `(LET ((NLINES (1- (COUNT-LINES (INTERVAL-FIRST-BP *INTERVAL*) (POINT) T)))
	 (NCHARS (BP-INDEX (POINT))))
     (PROGN . ,BODY)
     (MOVE-POINT
	      (FORWARD-CHAR (FORWARD-LINE (INTERVAL-FIRST-BP *INTERVAL*)
					  NLINES T)
			    NCHARS T))))

;;--- This could try to save the point relative to the start of the current
;;--- section, and do section-relative positioning in the new buffer.  Failing
;;--- that, use the present scheme
(DEFMACRO PRESERVE-BUFFER-POINT ((BUFFER) &BODY BODY)
  `(LET ((BUFFER-P (ZMACS-BUFFER-P ,BUFFER))
	 SAVED-POINT NLINES NCHARS)
     (IF (NOT BUFFER-P)
	 (SETQ SAVED-POINT (POINT))
	 (SETQ SAVED-POINT (BUFFER-SAVED-POINT ,BUFFER))
	 (AND (VARIABLE-BOUNDP *INTERVAL*) 
	      (EQ ,BUFFER *INTERVAL*) (MOVE-BP SAVED-POINT (POINT))))
     (SETQ NLINES (COUNT-LINES (INTERVAL-FIRST-BP ,BUFFER) SAVED-POINT T)
	   NCHARS (BP-INDEX SAVED-POINT))
     (PROGN . ,BODY)
     (MOVE-BP SAVED-POINT
	      (LET ((*INTERVAL* ,BUFFER))	;Range check right
		(FORWARD-CHAR (FORWARD-LINE (INTERVAL-FIRST-BP ,BUFFER)
					    (1- NLINES) T)
			      NCHARS T)))
     ;; (WINDOW-INTERVAL *WINDOW*) determines if MOVE-POINT is the right idea,
     ;; not merely *INTERVAL*. Ycch.
     (WHEN (AND (VARIABLE-BOUNDP *WINDOW*) (EQ ,BUFFER (WINDOW-INTERVAL *WINDOW*))
		BUFFER-P)
       (MOVE-POINT SAVED-POINT))))

(DEFMACRO WITH-BUFFER-PROTECTED (BUFFER &BODY BODY)
  `(WITH-BUFFER-PROTECTED-INTERNAL ,BUFFER
     #'(LAMBDA () ,@BODY)))

(DEFMACRO MOVE-POINT-ON-READ-ERROR ((STREAM) &BODY BODY)
  `(CONDITION-CASE (.READ-ERROR.)
       (PROGN ,. BODY)
     (SYS:READ-ERROR
       (LET ((ELOC (SEND .READ-ERROR. :LOCATION))
	     (ESTREAM (SEND .READ-ERROR. :STREAM)))
	 (WHEN (AND ELOC (EQ ESTREAM ,STREAM))
	   (POINT-PDL-PUSH (POINT) *WINDOW*)
	   (MOVE-POINT ELOC))
	 (BARF "Read error: ~A" .READ-ERROR.)))))

(DEFMACRO DPRINT LIST
  (DO ((L LIST (CDR L))
       (RET NIL (CONS `(FORMAT T "~S = ~S; " ',(CAR L) ,(CAR L)) RET)))
      ((NULL L)
       `(PROGN (TERPRI) . ,(NREVERSE RET)))))

(DEFMACRO TYPEIN-LINE-ACTIVATE (&BODY BODY)
  `(LET ((*EDITOR-ALREADY-KNOWS* T))
     (TV:WINDOW-CALL-RELATIVE (*TYPEIN-WINDOW*)
       . ,BODY)))

(DEFMACRO PROMPT-LINE-ACTIVATE (&BODY BODY)
  `(LET ((*EDITOR-ALREADY-KNOWS* T))
     (TV:WINDOW-CALL-RELATIVE (*MODE-LINE-WINDOW*)
       . ,BODY)))

(DEFMACRO TEMPORARY-WINDOW-SELECT ((ZWEI-WINDOW) &BODY BODY)
  `(LET ((*EDITOR-ALREADY-KNOWS* T)
	 (.SHEET. (WINDOW-SHEET ,ZWEI-WINDOW)))
     (TV:WINDOW-CALL-RELATIVE (.SHEET. :DEACTIVATE)
       . ,BODY)))

(DEFMACRO LET*-INSTANCE-VARIABLES (BINDINGS &BODY BODY)
  `(LETF* ,BINDINGS ,@BODY))

(DEFMACRO LET*-INSTANCE-VARIABLES-IF (COND BINDINGS &BODY BODY)
  `(SYS:%WITH-BINDING-STACK-LEVEL
     (WHEN ,COND
       ,@(LOOP FOR (VAR VAL) IN BINDINGS
	       COLLECT `(SYS:%BIND-LOCATION (LOCF ,VAR) ,VAL)))
     ,@BODY))

(DEFMACRO LET*-INSTANCE-VARIABLES-IF-UNBOUND (BINDINGS &BODY BODY)
  `(SYS:%WITH-BINDING-STACK-LEVEL
     ,@(LOOP FOR (VAR VAL) IN BINDINGS
	     COLLECT `(UNLESS (VARIABLE-BOUNDP ,VAR)
			(SYS:%BIND-LOCATION (LOCF ,VAR) ,VAL)))
     ,@BODY))

;;; Macros used to make commands easy to write.
(DEFMACRO POINT ()
  '(WINDOW-POINT *WINDOW*))

(DEFMACRO MARK ()
  '(WINDOW-MARK *WINDOW*))

;;; Caller should GET-INTERVAL
;;; The variables START-BP and END-BP are bound in the body to the bounds
;;; of this particular hard section.
(DEFMACRO MAP-OVER-HARD-SECTIONS
	  ((START-BP END-BP &KEY
		     (BUFFER '*INTERVAL*))
	   &BODY BODY)
  `(MAP-OVER-SECTIONS-IN-INTERVAL
     (INTERVAL-HOME-BUFFER ,BUFFER)
     ,START-BP
     ,END-BP
     #'(NAMED-LAMBDA MAP-OVER-HARD-SECTIONS-CONTINUATION
		     (,START-BP ,END-BP)
		     (DECLARE (SYS:DOWNWARD-FUNCTION))
		     ,@BODY)))


;;; This macro is for code that is doing its own explicit 
;;; handling of hard section issues, and just needs the point and 
;;; mark as a bounding area.
(DEFMACRO REGION-BPS ((START-BP END-BP &KEY EMPTY-OK) &BODY BODY)
  `(WITH-REGION-BPS (,START-BP ,END-BP :EMPTY-OK ,EMPTY-OK)
     ,@BODY))

(DEFMACRO REGION ((BP1 BP2 
		   &KEY EMPTY-OK ENFORCE-SINGLE-SECTION)
		  &BODY BODY)
  `(WITH-REGION-BPS (,BP1 ,BP2 :EMPTY-OK ,EMPTY-OK)
     (REGION-1 ,BP1 ,BP2 ,ENFORCE-SINGLE-SECTION
	       (NAMED-LAMBDA REGION  (,BP1 ,BP2)
			     (DECLARE (SYS:DOWNWARD-FUNCTION))
			     (PROGN ,@BODY)))))


;;; This turns the body into a continuation that is called
;;; for each hard section in the region, if there is more than one.
(DEFMACRO REGION-LINES ((START-LINE STOP-LINE 
			 &KEY EMPTY-OK ENFORCE-SINGLE-SECTION
			      (REGION-LINES-BP1 '.REGION-LINES-BP1.)
			      (REGION-LINES-BP2 '.REGION-LINES-BP2.))
			&BODY BODY)
  `(WITH-REGION-BPS (,REGION-LINES-BP1 ,REGION-LINES-BP2 :EMPTY-OK ,EMPTY-OK)
     (REGION-LINES-1 ,REGION-LINES-BP1 ,REGION-LINES-BP2 ,ENFORCE-SINGLE-SECTION
		     (NAMED-LAMBDA REGION-LINES (,START-LINE ,STOP-LINE)
		       (DECLARE (SYS:DOWNWARD-FUNCTION))
		       (PROGN ,@BODY)))))


;; Assume that the definition will never span hard section boundaries
;;--- this arglist is too messed up to support adding IN-ORDER-P yet.
(DEFMACRO DEFINITION-REGION ((BP1 BP2
			      &OPTIONAL DEFINITION-NAME FUNCTION-P ENFORCE-SINGLE-SECTION)
			     &BODY BODY)
  (LET ((DUMMY-FUNCTION-P (OR FUNCTION-P (GENSYM))))
    `(MULTIPLE-VALUE-BIND (,BP1 ,BP2 ,DEFINITION-NAME ,DUMMY-FUNCTION-P)
	 (DEFINITION-REGION-INTERNAL)
       (FLET ((.DEFINITION-REGION-CONTINUATION. (,BP1 ,BP2
						 ,(OR DEFINITION-NAME 'IGNORE)
						 ,(OR FUNCTION-P 'IGNORE))
		(DECLARE (SYS:DOWNWARD-FUNCTION))
		,@BODY))
	 (IF ,DUMMY-FUNCTION-P
	     (.DEFINITION-REGION-CONTINUATION. ,BP1 ,BP2 ,DEFINITION-NAME T)
	   (REGION (,BP1 ,BP2 :EMPTY-OK NIL
			      :ENFORCE-SINGLE-SECTION ,ENFORCE-SINGLE-SECTION)
	     (.DEFINITION-REGION-CONTINUATION. ,BP1 ,BP2 "Region" NIL)))))))

;; Like REGION-BPS
(DEFMACRO DEFINITION-REGION-BPS ((BP1 BP2
				  &OPTIONAL DEFINITION-NAME FUNCTION-P)
				 &BODY BODY)
  (LET ((DUMMY-FUNCTION-P (OR FUNCTION-P (GENSYM))))
    `(MULTIPLE-VALUE-BIND (,BP1 ,BP2 ,DEFINITION-NAME ,DUMMY-FUNCTION-P)
	 (DEFINITION-REGION-INTERNAL)
       (FLET ((.DEFINITION-REGION-CONTINUATION. (,BP1 ,BP2
						 ,(OR DEFINITION-NAME 'IGNORE)
						 ,(OR FUNCTION-P 'IGNORE))
		(DECLARE (SYS:DOWNWARD-FUNCTION))
		,@BODY))
	 (IF ,DUMMY-FUNCTION-P
	     (.DEFINITION-REGION-CONTINUATION. ,BP1 ,BP2 ,DEFINITION-NAME T)
	   (REGION-BPS (,BP1 ,BP2 :EMPTY-OK NIL)
	     (.DEFINITION-REGION-CONTINUATION. ,BP1 ,BP2 "Region" NIL)))))))

(DEFUN DEFINITION-REGION-INTERNAL ()
  (DECLARE (VALUES BP1 BP2 DEFINITION-NAME FUNCTION-P))
  (LET (BP1 BP2 DEFINITION-NAME FUNCTION-P)
    (COND ((WINDOW-REGION-P)
	   ;; If there's a region, just let the DEFINITION-REGION macro handle it
	   ;; by calling REGION
	   NIL)
;This causes more confusion than it saves
;	  ((WINDOW-MARK-P *WINDOW*)
;	   (BARF "The region is empty."))
	  (T
	   ;; No region, ask the major mode for a default region
	   (MULTIPLE-VALUE-BIND (INTERVAL NAME)
	       (SEND (SEND *INTERVAL* :MAJOR-MODE) ':DEFAULT-DEFINITION-REGION (POINT) NIL T)
	     (SETQ BP1 (INTERVAL-FIRST-BP INTERVAL)
		   BP2 (INTERVAL-LAST-BP INTERVAL)
		   DEFINITION-NAME NAME
		   FUNCTION-P T))))
    (VALUES BP1 BP2 DEFINITION-NAME FUNCTION-P)))

(DEFMACRO DEFINITION-REGION-LINES ((START-LINE STOP-LINE
				    &KEY ENFORCE-SINGLE-SECTION
					 (REGION-LINES-BP1 '.REGION-LINES-BP1.)
					 (REGION-LINES-BP2 '.REGION-LINES-BP2.))
				   &BODY BODY)
  `(MULTIPLE-VALUE-BIND (,REGION-LINES-BP1 ,REGION-LINES-BP2)
       (DEFINITION-REGION-INTERNAL)
     (UNLESS ,REGION-LINES-BP1
       (SETQ ,REGION-LINES-BP1 (MARK)
	     ,REGION-LINES-BP2 (POINT))
       (WHEN (BP-< ,REGION-LINES-BP2 ,REGION-LINES-BP1)
	 (SWAPF ,REGION-LINES-BP1 ,REGION-LINES-BP2)))
     ,@(IF ENFORCE-SINGLE-SECTION
	   `((ASSURE-SINGLE-SECTION-INTERVAL ,REGION-LINES-BP1 ,REGION-LINES-BP2 T
					     "The region spans a hard section boundary.")
	     (INTERVAL-LINES (,REGION-LINES-BP1 ,REGION-LINES-BP2) (,START-LINE ,STOP-LINE)
	       ,@BODY))
	   `((INTERVAL-LINES (,REGION-LINES-BP1 ,REGION-LINES-BP2)
			     (,START-LINE ,STOP-LINE)
	       (MAP-OVER-LINES-IN-INTERVAL
		 (INTERVAL-HOME-BUFFER *INTERVAL*) 
		 ,START-LINE ,STOP-LINE 
		 #'(NAMED-LAMBDA REGION-LINES-CONTINUATION (,START-LINE ,STOP-LINE)
				 (DECLARE (SYS:DOWNWARD-FUNCTION))
				 ,@BODY)))))))

;; *INTERVAL* is assumed to be the buffer, if this is a vc buffer.
(DEFMACRO INTERVAL-LINES ((BP1 BP2)
			  (START-LINE STOP-LINE)
			  &BODY BODY)
  `(LET ((,START-LINE
	  (COND ((ZEROP (BP-INDEX ,BP1))
		 (BP-LINE ,BP1))
		(T (LINE-NEXT-IN-BUFFER (BP-LINE ,BP1)))))
	 (,STOP-LINE
	  (COND ((ZEROP (BP-INDEX ,BP2))
		 (BP-LINE ,BP2))
		(T (LINE-NEXT-IN-BUFFER (BP-LINE ,BP2))))))
     . ,BODY))

;; Execute BODY in a bounded region of the buffer
(DEFMACRO WITH-BOUNDED-INTERVAL ((REGION-P-VAR &OPTIONAL BP1 BP2) &BODY BODY)
  `(MULTIPLE-VALUE-BIND (*INTERVAL* ,REGION-P-VAR)
       (BOUNDED-INTERVAL-INTERNAL ,BP1 ,BP2)
     (UNWIND-PROTECT
	 (PROGN ,@BODY)
       (COND (,REGION-P-VAR
	      (FLUSH-BP (INTERVAL-FIRST-BP *INTERVAL*))
	      (FLUSH-BP (INTERVAL-LAST-BP *INTERVAL*)))))))

(DEFUN BOUNDED-INTERVAL-INTERNAL (&OPTIONAL BP1 BP2)
  (DECLARE (VALUES *INTERVAL* REGION-P))
  (COND ((AND BP1 BP2)
	 (VALUES (CREATE-INTERVAL (COPY-BP BP1) (COPY-BP BP2)
				  'TOP-LEVEL-NODE)
		 T))
	((WINDOW-REGION-P)
	 (LET ((POINT (POINT)) (MARK (MARK)))
	   (WHEN (BP-< MARK POINT) (SWAP-POINT-AND-MARK))
	   ;; removed (SETF (WINDOW-MARK-P *WINDOW*) NIL)
	   ;;         (MUST-REDISPLAY *WINDOW* DIS-MARK-GOES)
	   ;; so the region is preserved until the command goes to normal completion.
	   (VALUES (CREATE-INTERVAL (COPY-BP POINT ':NORMAL) (COPY-BP MARK ':MOVES)
				    'TOP-LEVEL-NODE)
		   T)))
	((WINDOW-MARK-P *WINDOW*)
	 (BARF "There is a region, but it is empty"))
	(T *INTERVAL*)))

(DEFMACRO WITH-BP ((VARIABLE BP &OPTIONAL (TYPE NIL NOT-TEMP-BP)) &BODY BODY)
  (IF NOT-TEMP-BP
      `(LET ((,VARIABLE (COPY-BP ,BP ,TYPE)))
	 (UNWIND-PROTECT
	     (PROGN ,@BODY)
	   (FLUSH-BP ,VARIABLE)))
      `(LET ((,VARIABLE (COPY-BP ,BP)))
	 (PROGN ,@BODY)))) 

(DEFMACRO BIND-MODE-LINE (LIST &BODY BODY)
  `(LET ((*MODE-LINE-LIST* ',LIST))
     . ,BODY))

;;; This like GET-INTERVAL, only it can adjust for section boundaries.
(DEFMACRO ASSURE-SINGLE-SECTION-INTERVAL (START-BP &OPTIONAL END-BP IN-ORDER-P MESSAGE)
  `(PROGN
     (GET-INTERVAL ,START-BP ,END-BP ,IN-ORDER-P)
     (CL:MULTIPLE-VALUE-SETQ
	(,START-BP ,END-BP)
	,(IF MESSAGE
	     `(ASSURE-SINGLE-SECTION-INTERVAL-1 ,START-BP ,END-BP ,MESSAGE)
	     `(ASSURE-SINGLE-SECTION-INTERVAL-1 ,START-BP ,END-BP)))))

(DEFMACRO WITH-REGION-BPS ((START-BP END-BP &KEY EMPTY-OK) &BODY BODY)
  `(WITH-REGION-BPS-1 ,EMPTY-OK
		      (NAMED-LAMBDA WITH-REGION-BPS (,START-BP ,END-BP)
				    (DECLARE (SYS:DOWNWARD-FUNCTION))
				    (PROGN ,@BODY))))

(DEFMACRO WITH-BUFFER-CURRENT (BUFFER &BODY FORMS)
  `(WITH-BUFFER-CURRENT-INTERNAL ,BUFFER #'(LAMBDA () ,@FORMS)))

(DEFUN WITH-BUFFER-CURRENT-INTERNAL (BUFFER CONTINUATION)
  (LET ((OLD-BUFFER *INTERVAL*))
    (UNWIND-PROTECT (PROGN (MAKE-BUFFER-CURRENT BUFFER)
			   (FUNCALL CONTINUATION))
      (MAKE-BUFFER-CURRENT OLD-BUFFER))))

;;; Bind off the read-only attribute of the specified interval temporarily.
(DEFMACRO WITH-READ-ONLY-SUPPRESSED ((INTERVAL) &BODY BODY &ENVIRONMENT ENV)
  (ONCE-ONLY (INTERVAL &ENVIRONMENT ENV)
    `(LET* ((.SAVED-TICK. (NODE-TICK ,INTERVAL))	;':READ-ONLY presumably
	    (.OLD-TICK. (SEND-IF-HANDLES ,INTERVAL :TICK-BEFORE-READ-ONLY)))
       (UNWIND-PROTECT
	 (PROGN
	   (WHEN .OLD-TICK.
	     (SETF (NODE-TICK ,INTERVAL) .OLD-TICK.))
	   . ,BODY)
	 (WHEN .OLD-TICK.
	   (SEND ,INTERVAL :UPDATE-TICK-BEFORE-READ-ONLY)
	   (SETF (NODE-TICK ,INTERVAL) .SAVED-TICK.))))))

(DEFMACRO WITH-UNDO-SAVE ((VERB BP1 . OPTIONALS) &BODY BODY)
  "Record changes made by BODY to the interval from BP1 to BP2.
VERB is a string naming the operation performed by BODY."
  (DECLARE (ARGLIST (VERB BP1 &OPTIONAL BP2 IN-ORDER-P) &BODY BODY))
  `(LET ((*ENABLE-CHANGE-RECORDING* (SAVE-INTERVAL-FOR-UNDO ,VERB ,BP1 . ,OPTIONALS)))
     . ,BODY))

(DEFMACRO WITH-UNDO-SAVE-IF (TEST (VERB BP1 . OPTIONALS) &BODY BODY)
  "Record changes made by BODY to the interval from BP1 to BP2, if TEST evaluates true.
VERB is a string naming the operation performed by BODY."
  (DECLARE (ARGLIST TEST (VERB BP1 &OPTIONAL BP2 IN-ORDER-P) &BODY BODY))
  ;; Note that LET-IF doesn't call SAVE-INTERVAL-FOR-UNDO if ,TEST is false.
  `(LET-IF ,TEST ((*ENABLE-CHANGE-RECORDING* (SAVE-INTERVAL-FOR-UNDO ,VERB ,BP1 . ,OPTIONALS)))
     . ,BODY))

(DEFMACRO WITH-UNDO-SAVE-SIMPLE ((BP1 . OPTIONALS) &BODY BODY)
  "Record changes made by BODY to the interval from BP1 to BP2.
This uses the same type of change record as the editing primitives, however
the changes made by the body are grouped into a single change, and not
merged with preceding or following changes."
  (DECLARE (ARGLIST (BP1 &OPTIONAL BP2 IN-ORDER-P) &BODY BODY))
  `(LET ((*ENABLE-CHANGE-RECORDING* (SAVE-INTERVAL-FOR-UNDO-SIMPLE ,BP1 . ,OPTIONALS)))
     . ,BODY))

(DEFMACRO WITH-CUSTOM-UNDO-SAVE ((FIRST-BP LAST-BP MAKE &KEY OLD-TEXT (TEST T)) &BODY BODY)
  "Record changes made by BODY to the interval from FIRST-BP to LAST-BP (must be in order).
MAKE is a form that makes a change-record; it can access the variables BP-POSITIONS,
LENGTH, WIDTH, and BUFFER.  If :OLD-TEXT is specified, it is a variable from which MAKE
can obtain a string or interval containing the old text.
If :TEST is specified, it is a form that disables change recording if the value is NIL."
  (WHEN OLD-TEXT
    (SETQ MAKE `(LET ((,OLD-TEXT (COPY-INTERVAL-INTO-STRING-OR-INTERVAL ,FIRST-BP ,LAST-BP
									LENGTH WIDTH
							     :AREA *CHANGE-RECORD-AREA*)))
		  ,MAKE)))
  `(LET-IF ,TEST ((*ENABLE-CHANGE-RECORDING*
		    (LET ((BUFFER (BP-CHANGE-RECORDING-BUFFER ,FIRST-BP)))
		      (WHEN (AND BUFFER *ENABLE-CHANGE-RECORDING*)
			;; Make a MUNG-NODE-RECORD if necessary
			(MUNG-NODES-IN-INTERVAL ,FIRST-BP ,LAST-BP T T)
			;; Now record the current contents of the interval
			(RECORD-ACCUMULATED-CHANGES BUFFER)
			(CL:PUSH (MULTIPLE-VALUE-BIND (LENGTH WIDTH BP-POSITIONS)
				     (PREPARE-TO-RECORD ,FIRST-BP ,LAST-BP)
				   (IGNORE LENGTH WIDTH   ;Not okay to ignore BP-POSITIONS
							  ;unless interval definitely empty
					   ,@(AND (EQ FIRST-BP LAST-BP) `(BP-POSITIONS)))
				   ,MAKE)
				 (BUFFER-CHANGE-HISTORY BUFFER)
				 :AREA *CHANGE-RECORD-AREA*))
		      NIL)))	;*ENABLE-CHANGE-RECORDING* is bound to this

     . ,BODY))

(DEFVAR-RESETTABLE *SPARSE-CHANGE-ARRAY* NIL)	;for WITH-UNDO-SAVE-SPARSE
(DEFVAR *SPARSE-CHANGE-BYTE-INDEX*)		;Position of last fixnum-of-bytes in array
(DEFVAR *SPARSE-CHANGE-BYTE-ROOM*)		;Number of bytes space in last fixnum in array
(DEFVAR *SPARSE-CHANGE-FIRST-BP*)		; first text entered in *SPARSE-CHANGE-ARRAY*
(DEFVAR *SPARSE-CHANGE-LAST-BP*)		; last text entered in *SPARSE-CHANGE-ARRAY*
(DEFVAR *SPARSE-CHANGE-BP-POSITIONS*)		;Save BP's that have been moved
(DEFVAR *SPARSE-CHANGE-N-LINES*)		;Position of -last-bp relative to first-bp
(DEFVAR *SPARSE-CHANGE-N-CHARS*)		;Position of -last-bp relative to first-bp

(DEFMACRO WITH-UNDO-SAVE-SPARSE ((VERB BP &REST OPTIONS) &BODY BODY)
  "Record sparse changes made by BODY starting at BP.
VERB is a string naming the operation performed by BODY.
OPTIONS allow specifying :FLAVOR, a flavor name, and init options for the change-record,
and allows :TEST <boolean> which if false disables recording.
This only works if all textual modifications made by BODY are made by special
subroutines such as INDENT-LINE and FILL-INTERVAL that call RECORD-SPARSE-CHANGE."
  (LET ((TEST (CL:GETF OPTIONS ':TEST T))
	(OPTIONS (SI:REM-KEYWORDS OPTIONS '(:TEST))))
    (WHEN OPTIONS
      (UNLESS (EQ (FIRST OPTIONS) ':FLAVOR)
	(CL:WARN "Options list ~S must begin with :FLAVOR or be empty." OPTIONS)))
    `(SYS:WITH-DATA-STACK
       (LET ((.FLAG. (AND ,TEST (NULL *SPARSE-CHANGE-ARRAY*))))
	 (LET-IF .FLAG.			;Allow these to be nested
		 ((*SPARSE-CHANGE-ARRAY* (AND *ENABLE-CHANGE-RECORDING*
					      (SYS:MAKE-STACK-ARRAY 100 :FILL-POINTER 0)))
		  (*SPARSE-CHANGE-BYTE-INDEX* 0)
		  (*SPARSE-CHANGE-BYTE-ROOM* 0)
		  (*SPARSE-CHANGE-FIRST-BP* (COPY-BP ,BP :NORMAL))
		  (*SPARSE-CHANGE-LAST-BP* (COPY-BP ,BP :MOVES))
		  (*SPARSE-CHANGE-BP-POSITIONS* NIL)
		  (*SPARSE-CHANGE-N-LINES* 0)
		  (*SPARSE-CHANGE-N-CHARS* 0))
	   (UNWIND-PROTECT (PROGN . ,BODY)
	     (WHEN .FLAG.
	       (FINISH-SPARSE-CHANGE-RECORD ,VERB ,@OPTIONS))))))))

;;; Barf if any of the conditions encountered are signalled inside body.
;;; The barf message is the error's :REPORT-STRING.
(DEFMACRO BARF-ON-ERRORS (ERROR-LIST &BODY BODY)
  (LET ((GENSYM (GENSYM)))
    `(CONDITION-CASE (,GENSYM)
	 (PROGN . ,BODY)
       (,ERROR-LIST (BARF "~A" ,GENSYM)))))

;;; Use this when you use to use *CATCH ZWEI-COMMAND-LOOP.
;;; BARF handling is an interactive handler, allow others before it.
(DEFMACRO CATCH-ZWEI-COMMAND-LOOP (&BODY BODY)
  `(*CATCH 'ZWEI-COMMAND-LOOP
     (CONDITION-BIND-DEFAULT ((BARF 'COMMAND-LOOP-HANDLE-BARF))
       . ,BODY)))

;;; Defines a command.  Form is:
;;; (DEFCOM COM-foo "Documentation." OPTIONS-LIST &REST BODY)
;;; Note: unlike EINE, there is no lambda-list.
;;; Options:	KM -- This command preserves MARK if it is set
;;;		      (the default is to remove it).
;;;		SM -- This command sets MARK.
;;;		NM -- This command removes MARK.
;;;		R  -- Recenter screen like c-N if moved off (positive arg means moving down)
;;;		-R -- Recenter screen like c-P if moved off (positive arg means moving up)
;;;		PUSH -- Point is pushed on the point-pdl before executing

(DEFPROP DEFCOM DEFUN DEFINITION-FUNCTION-SPEC-TYPE)

(DEFMACRO DEFCOM (FN DOC OPTIONS &BODY DEF)
  `(PROGN 'COMPILE
     (COMMAND-DEFINE ',FN ',DOC ',OPTIONS)
     (DEFUN ,FN ()
       ,@(PROCESS-COMMAND-OPTIONS OPTIONS)
       . ,DEF)))

(DEFVAR *COMMAND-ALIST* NIL)		;Associates command names with commands.

(DEFUN COMMAND-DEFINE (COMMAND DOC IGNORE)
  (COND ((STRINGP DOC)
	 (PUTPROP COMMAND DOC 'DOCUMENTATION))
	((OR (SYMBOLP DOC)
	     (AND (NOT (ATOM DOC))
		  (MEMQ (CAR DOC) '(FUNCTION LAMBDA))))
	 (PUTPROP COMMAND DOC 'DOCUMENTATION-FUNCTION))
	(T
	 (FERROR NIL "The command ~S has invalid self-documentation ~S" COMMAND DOC)))
  (LET ((NAME (SI:MAKE-COMMAND-NAME COMMAND)))
    (PUTPROP COMMAND NAME 'COMMAND-NAME)
    (LET ((CELL (ASSOC NAME *COMMAND-ALIST*)))
      (COND ((NOT CELL)
	     (PUSH (CONS NAME COMMAND) *COMMAND-ALIST*))
	    ((NOT (EQ (CDR CELL) COMMAND))
	     ;; This can happen if you first define FOO then change it to COM-FOO.
	     (WHEN (FQUERY NIL
			   "The ZWEI command ~A is being incompatibly redefined.~@
                            It used to be ~S, but is being defined as ~S.~@
                            Go ahead with this redefinition? "
			   NAME (CDR CELL) COMMAND)
		 (SETF (CDR CELL) COMMAND)))))))

(DEFUN UNDEFINE-COMMAND (COMMAND)
  (SI:NREMPROP COMMAND 'DOCUMENTATION)
  (SI:NREMPROP COMMAND 'DOCUMENTATION-FUNCTION)
  (LET ((NAME (GET COMMAND 'COMMAND-NAME)))
    (WHEN NAME
      (SETQ *COMMAND-ALIST* (CL:DELETE NAME *COMMAND-ALIST* :TEST #'STRING-EQUAL
				       :KEY #'CAR))))
  (SI:NREMPROP COMMAND 'COMMAND-NAME)
  COMMAND)

(DEFUN PROCESS-COMMAND-OPTIONS (OPTIONS)
  (LOOP FOR OPTION IN OPTIONS
	APPENDING (CDR (OR (CL:ASSOC OPTION
				     '((NM (SETF (WINDOW-MARK-P *WINDOW*) NIL))
				       (SM (SETF (WINDOW-MARK-P *WINDOW*) T)
					   (SETQ *MARK-STAYS* T))
				       (KM (SETQ *MARK-STAYS* T))
				       (R (SETQ *CENTERING-FRACTION*
						(IF (PLUSP *NUMERIC-ARG*)
						    *MIN-RESET-FRACTION*
						    *MAX-RESET-FRACTION*)))
				       (-R (SETQ *CENTERING-FRACTION*
						 (IF (PLUSP *NUMERIC-ARG*)
						     *MAX-RESET-FRACTION*
						     *MIN-RESET-FRACTION*)))
				       (PUSH (POINT-PDL-PUSH (POINT) *WINDOW*)))
				     :TEST #'STRING-EQUAL)
			   (ERROR "Unknown DEFCOM option ~S" OPTION)))))

;; Stub for compatibility...
;; We have to give up on this, and just import SI:MAKE-COMMAND-NAME into ZWEI, for
;; the purpose of binary compatibility with old compiled versions of ZWEI:DEFCOM-FOR-ZMAIL.
;;(DEFF MAKE-COMMAND-NAME 'SI:MAKE-COMMAND-NAME)
;;(COMPILER:MAKE-OBSOLETE MAKE-COMMAND-NAME "use SI:MAKE-COMMAND-NAME instead")


(DEFPROP DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR SCL:DEFINE-PRESENTATION-TRANSLATOR
	 DEFINITION-FUNCTION-SPEC-TYPE)

(DEFMACRO DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR
	  (NAME (TYPE ECHO-NAME COMTAB
		      &REST OPTIONS
		 &KEY GESTURE TESTER
		 &ALLOW-OTHER-KEYS)
	   (OBJECT . OTHER-ARGS)
	   &BODY BODY)
  (WHEN (EQ OBJECT 'IGNORE)
    (SETQ OBJECT '.OBJECT.))
  (LET ((COMPILER:DEFAULT-WARNING-FUNCTION NAME)
	(COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'SCL:DEFINE-PRESENTATION-TRANSLATOR))
  `(SCL:DEFINE-PRESENTATION-TRANSLATOR ,NAME
      (,TYPE PRESENTATION-COMMAND
       :TESTER ((,OBJECT &REST OPTIONS
		 &KEY INPUT-CONTEXT ,@(REST1 OTHER-ARGS)
		 &ALLOW-OTHER-KEYS)
		(IGNORE ,OBJECT . ,(REST1 OTHER-ARGS))
		(AND (PRESENTATION-COMMAND-COMTAB-P INPUT-CONTEXT ,COMTAB)
		     ,(IF TESTER
			  `(LEXPR-FUNCALL
			     #',(IF (SYMBOLP TESTER)
				    TESTER
				    `(LAMBDA
				       ,(DW::MAKE-ALLOW-ANY-OTHER-KEYS-ARGLIST
					  (CAR TESTER) :N-REQUIRED 1
					  :KEYS-PASSED '(:GESTURE :INPUT-CONTEXT :MOUSE-CHAR
							 :PRESENTATION :PRESENTATION-TYPE
							 :WINDOW))
				       ,@(CDR TESTER)))
			     ,OBJECT
			     OPTIONS)
			  `(PROGN
			     (IGNORE OPTIONS)
			     . ,BODY))))
       :GESTURE ,GESTURE			;Forces NIL if not spec.
       . ,(SI:REM-KEYWORDS OPTIONS '(:GESTURE :TESTER))
       )
      ,(DW::MAKE-ALLOW-ANY-OTHER-KEYS-ARGLIST
	 `(,OBJECT ,@OTHER-ARGS)
	 :ADDITIONAL-KEY `(PRESENTATION FOR-MENU-P)
	 :N-REQUIRED 1
	 :KEYS-PASSED '(:GESTURE :HANDLER :INPUT-CONTEXT :MOUSE-CHAR
			:ORIGINAL-PRESENTATION :PRESENTATION
			:WINDOW :X :Y :FOR-MENU-P))
     (LET ((VALUE (PROGN . ,BODY)))
       (WHEN VALUE
	 `(PRESENTATION-COMMAND ,VALUE
				,(PRESENTATION-COMMAND-NAME ,ECHO-NAME ,OBJECT ',TYPE
							    (AND FOR-MENU-P
								 PRESENTATION))))))))

(DEFMACRO WITH-INPUT-FROM-INTERVAL ((STREAM-VAR START-BP END-BP)
				    &BODY BODY)
  `(IF (EQ (BP-LINE ,START-BP) (BP-LINE ,END-BP))
       (CL:WITH-INPUT-FROM-STRING (,STREAM-VAR (BP-LINE ,START-BP)
				   :START (BP-INDEX ,START-BP)
				   :END (BP-INDEX ,END-BP))
	 ,@BODY)
       ;; This might be quicker as a resource.
       (USING-RESOURCE (,STREAM-VAR INTERVAL-STREAMS ,START-BP ,END-BP T)
	 ,@BODY)))

;;;

(DEFMACRO INSERT-MOVING-POINT (STRING)
  `(LET ((.POINT. (POINT)))
     (INSERT-MOVING .POINT. ,STRING)
     (MOVE-POINT .POINT.)))

(DEFMACRO WITH-THIS-PROCESS-MOUSE-FONT-CHAR ((CHAR) &BODY BODY)
  `(LET ((OLD-WINDOW-MOUSE-ALIST (MAKE-WINDOW-MOUSE-BLINKERS-ALIST *WINDOW-LIST*)))
     (UNWIND-PROTECT
	 (PROGN (SET-WINDOW-MOUSE-BLINKERS *WINDOW-LIST* ,CHAR)
		,@BODY)
       (RESTORE-WINDOW-MOUSE-BLINKERS OLD-WINDOW-MOUSE-ALIST))))

(DEFUN MAKE-WINDOW-MOUSE-BLINKERS-ALIST (&OPTIONAL (WINDOW-LIST *WINDOW-LIST*))
  (LOOP FOR WINDOW IN WINDOW-LIST
	AS SHEET = (WINDOW-SHEET WINDOW)
	AS CHAR = (SEND SHEET :MOUSE-BLINKER-CHARACTER)
	COLLECT (LIST WINDOW CHAR)))

(DEFUN SET-WINDOW-MOUSE-BLINKERS (WINDOW-LIST CHAR)
  (LOOP FOR WINDOW IN WINDOW-LIST
	AS SHEET = (WINDOW-SHEET WINDOW)
	DO (SEND SHEET :SET-MOUSE-BLINKER-CHARACTER CHAR)))

(DEFUN RESTORE-WINDOW-MOUSE-BLINKERS (WINDOW-MOUSE-BLINKERS-ALIST)
  (LOOP FOR (WINDOW CHAR) IN WINDOW-MOUSE-BLINKERS-ALIST
	AS SHEET = (WINDOW-SHEET WINDOW)
	DO (SEND SHEET :SET-MOUSE-BLINKER-CHARACTER CHAR)))

(DEFMACRO WITH-CHARACTER-STYLE-FROM-FUNCTION ((CHARACTER-STYLE-FUNCTION LINE STREAM)
					      &BODY BODY)
  `(WITH-CHARACTER-STYLE-FROM-FUNCTION-1 ,CHARACTER-STYLE-FUNCTION ,LINE ,STREAM
					 (SYS:NAMED-LAMBDA WITH-CHARACTER-STYLE-FROM-FUNCTION
							   (,STREAM)
					   ,@BODY)))


(DEFUN WITH-CHARACTER-STYLE-FROM-FUNCTION-1 (CHARACTER-STYLE-FUNCTION LINE STREAM CONTINUATION)
  (DECLARE (SYS:DOWNWARD-FUNARG CONTINUATION))
  (IF CHARACTER-STYLE-FUNCTION
      (LET ((STYLE (FUNCALL CHARACTER-STYLE-FUNCTION LINE STREAM)))
	(IF STYLE
	    (SCL:WITH-CHARACTER-STYLE (STYLE STREAM :BIND-LINE-HEIGHT T)
	      (FUNCALL CONTINUATION STREAM))
	    (FUNCALL CONTINUATION STREAM)))
      (FUNCALL CONTINUATION STREAM)))


;;; cribbed from COPYF.  For writing and saving functions.
;;; meaningful values for the arg of this macro and for *ZWEI-WRITE-DNF-SWITCH*:
;;;  T       Create missing directories without asking
;;;  :QUERY  Ask whether to create missing directories
;;;  NIL     Don't create missing directories, allowing error to propogate
;;;           to next outer handlers
(DEFMACRO WITH-ZWEI-WRITE-CREATE-DIRECTORIES ((CREATE-DIRECTORIES) &BODY BODY)
  `(LET ((*ZWEI-WRITE-DNF-SWITCH* ,CREATE-DIRECTORIES))
     (DECLARE (SPECIAL *ZWEI-WRITE-DNF-SWITCH*))
     (DO () (NIL)
       (CATCH 'ZWEI-WRITE-TARGET-RETRY
	 (RETURN
	   (CONDITION-BIND-IF ,CREATE-DIRECTORIES
			      ((FS:DIRECTORY-NOT-FOUND #'ZWEI-WRITE-DNF-HANDLER))
	     . ,BODY))))))


;;; Node and interval locking

(DEFMETHOD (DESCRIBE-NODE-LOCKS NODE) ()
  (FORMAT T "~&For the node ~S:" SELF)
  (IF WRITE-LOCK
      (FORMAT T "~%  The writer is ~A; " WRITE-LOCK)
    (FORMAT T "~%  There is no writer; "))
  (IF READ-LOCK
      (FORMAT T "the readers are ~A." READ-LOCK)
    (FORMAT T "there are no readers.")))

(DEFUN DESCRIBE-NODE-LOCKS-IN-BUFFER (BUFFER) 
  ;;--- I hope that marching through the sections will turn up all the locks
  (LOOP FOR NODE IN (BUFFER-SECTIONS BUFFER)
	AS PREVIOUS-LOCK-NODE = NIL THEN LOCK-NODE
	AS LOCK-NODE = (NODE-TO-LOCK BUFFER NODE)
	WHEN (AND LOCK-NODE
		  (NEQ LOCK-NODE PREVIOUS-LOCK-NODE)
		  (OR (NODE-READ-LOCK LOCK-NODE)
		      (NODE-WRITE-LOCK LOCK-NODE)))
	  DO (DESCRIBE-NODE-LOCKS LOCK-NODE)))


;; Emergency hammer
(DEFMETHOD (FORCIBLY-UNLOCK-NODE-LOCKS NODE) (&KEY (READ T) (WRITE T))
  (WHEN READ  (SETQ READ-LOCK  NIL))
  (WHEN WRITE (SETQ WRITE-LOCK NIL)))

;; Emergency sledgehammer
(DEFUN FORCIBLY-UNLOCK-NODE-LOCKS-IN-BUFFER (BUFFER &KEY (READ T) (WRITE T))
  ;;--- I hope that marching through the sections will turn up all the locks
  (LOOP FOR NODE IN (BUFFER-SECTIONS BUFFER)
	AS PREVIOUS-LOCK-NODE = NIL THEN LOCK-NODE
	AS LOCK-NODE = (NODE-TO-LOCK BUFFER NODE)
	WHEN (AND LOCK-NODE
		  (NEQ LOCK-NODE PREVIOUS-LOCK-NODE))
	  DO (FORCIBLY-UNLOCK-NODE-LOCKS LOCK-NODE :READ READ :WRITE WRITE)))


(DEFUN UNLOCK-ALL-SELECTED-BUFFER-LOCKS ()
  (LOOP FOR COMMAND-LOOP IN *ZMACS-COMMAND-LOOPS*
	AS INTERVAL = (SYMEVAL-IN-INSTANCE COMMAND-LOOP '*INTERVAL*)
	DO (FORCIBLY-UNLOCK-NODE-LOCKS-IN-BUFFER INTERVAL)))

(ADD-INITIALIZATION "Unlock all editor nodes"
   '(UNLOCK-ALL-SELECTED-BUFFER-LOCKS)
   '(:WARM))


;; A buffer gets to choose what node to lock when given a node
(DEFGENERIC NODE-TO-LOCK (BUFFER NODE)
  (DECLARE (VALUES NODE-TO-LOCK)))

;; For some major modes, we just lock the entire interval instead of locking
;; any particular node.  If a hierarchical locking strategy is ever employed,
;; this will not be necessary.  Returns NIL if the node itself should be locked,
;; or non-NIL if the entire buffer should be locked.
(DEFUN BUFFER-LOCK-ENTIRE-BUFFER (BUFFER)
  (LET ((MAJOR-MODE (SEND-IF-HANDLES BUFFER :MAJOR-MODE)))
    (AND MAJOR-MODE (LOCK-ENTIRE-BUFFER MAJOR-MODE))))

;; Most sorts of buffers simply lock the node which we have passed in.
;; If there are nested section-nodes, however, we lock the node whose
;; immediate superior is the buffer itself.  Note that, since buffers
;; have no superior, the node to lock for a buffer is the buffer itself.
;; Here SELF is a buffer object, not a particular node in the buffer.
;; NODE is the node in the buffer which we wish to lock.
;; This is the method which is run for all sorts of buffer, mini-buffers,
;; etc., since they are all build on NODE (instead of INTERVAL).
;;--- The major-mode should have more to say here, particularly for the
;;--- "foreign" languages.
(DEFMETHOD (NODE-TO-LOCK NODE) (NODE)
  (LOOP FOR NODE = NODE THEN NEXT-NODE
	AS NEXT-NODE = (NODE-SUPERIOR NODE)
	UNTIL (OR (NULL NEXT-NODE)
		  (TYPEP NEXT-NODE 'BUFFER))
	FINALLY
	  (RETURN (IF (AND NEXT-NODE (BUFFER-LOCK-ENTIRE-BUFFER NEXT-NODE))
		      NEXT-NODE			;NEXT-NODE is the buffer itself
		    NODE))))

;; A few rare things use intervals directly, but that's no reason for them
;; to explode.  Let their fingers do the locking.
(DEFMETHOD (NODE-TO-LOCK INTERVAL) (NODE)
  NODE
  NIL)
  
(DEFUN BP-NODE-TO-LOCK (BP)
  (LET ((BP-NODE (BP-NODE BP))
	(BP-BUFFER (BP-BUFFER BP)))
    (IF (NULL BP-BUFFER)
	BP-NODE
      (NODE-TO-LOCK BP-BUFFER BP-NODE))))


;; This takes about .00015 seconds to lock and then unlock a node for writing
(DEFMACRO WITH-NODE-WRITE-LOCKED ((NODE) &BODY BODY)
  ;; Using NODE only once is not simply an optimization, because it
  ;; can actually change out from underneath us!
  `(LET ((LOCK-NODE ,NODE)
	 LOCKED-P)
     (UNWIND-PROTECT
	 (PROGN
	   (SETQ LOCKED-P (LOCK-NODE-WRITE-LOCK LOCK-NODE))
	   ,@BODY)
       (UNLOCK-NODE-WRITE-LOCK LOCK-NODE LOCKED-P))))

(DEFMETHOD (LOCK-NODE-WRITE-LOCK NODE) ()
  (LET ((LOCK-CELL (LOCF WRITE-LOCK))
	(LOCK-VALUE CURRENT-PROCESS)
	(LOCKED-P NIL))
    (UNWIND-PROTECT-CASE ()
	(WHEN (OR (EQ (LOCATION-CONTENTS LOCK-CELL) LOCK-VALUE)
		  (PROGN
		    (SETQ LOCKED-P #/?)
		    (COMPILER:%ERROR-UNLESS
		      (SETQ LOCKED-P (STORE-CONDITIONAL LOCK-CELL NIL LOCK-VALUE))
		      (PROCESS-LOCK LOCK-CELL LOCK-VALUE "Node write lock"
				    (LOCF LOCKED-P))
		      T)))
	  ;; We've got the write lock, so now wait for all the readers to
	  ;; release their locks.  LOCK-NODE-READ-LOCK avoids deadlocks by
	  ;; checking for write locks before taking any read locks.
	  (WHEN (AND READ-LOCK (NEQ READ-LOCK CURRENT-PROCESS))
	    (PROCESS-WAIT "Node read unlock"
	      (LAMBDA (RL)
		(LET ((RL (LOCATION-CONTENTS RL)))
		  (OR (NULL RL) (EQ RL CURRENT-PROCESS))))
	      (LOCF READ-LOCK)))
	  LOCKED-P)
      (:ABORT
	(UNLOCK-NODE-WRITE-LOCK SELF LOCKED-P)
	(SETQ LOCKED-P NIL)))))

(DEFMETHOD (UNLOCK-NODE-WRITE-LOCK NODE) (LOCKED-P)
  ;; Release the write lock iff we were the first to grab the lock
  (WHEN LOCKED-P
    (LET ((LOCK-CELL (LOCF WRITE-LOCK))
	  (LOCK-VALUE CURRENT-PROCESS))
      (COND ((EQ LOCKED-P T)
	     (COMPILER:%ERROR-UNLESS
	         (STORE-CONDITIONAL LOCK-CELL LOCK-VALUE NIL)
	       (PROCESS-UNLOCK LOCK-CELL LOCK-VALUE)))
	    ((EQ (LOCATION-CONTENTS LOCK-CELL) LOCK-VALUE)
	     (SETF (LOCATION-CONTENTS LOCK-CELL) NIL))))))


;; This takes about .00019 seconds to lock and then unlock a node for reading
(DEFMACRO WITH-NODE-READ-LOCKED ((NODE) &BODY BODY)
  ;; Using NODE only once is not simply an optimization, because it
  ;; can actually change out from underneath us!
  `(LET ((LOCK-NODE ,NODE)
	 LOCKED-P)
     (UNWIND-PROTECT
	 (PROGN
	   (SETQ LOCKED-P (LOCK-NODE-READ-LOCK LOCK-NODE))
	   ,@BODY)
       (UNLOCK-NODE-READ-LOCK LOCK-NODE LOCKED-P))))

(DEFMETHOD (LOCK-NODE-READ-LOCK NODE) ()
  (LET ((LOCK-VALUE CURRENT-PROCESS)
	(LOCKED-P NIL))
    ;; First wait for any writer to release the lock.  LOCK-NODE-WRITE-LOCK
    ;; avoids deadlocks by taking the write-lock before waiting for all of
    ;; the read-locks to be released.
    (WITHOUT-INTERRUPTS
      (LOOP WHILE (AND WRITE-LOCK (NEQ WRITE-LOCK CURRENT-PROCESS)) DOING
	(PROCESS-WAIT "Node write unlock"
	  (LAMBDA (WL)
	    (LET ((WL (LOCATION-CONTENTS WL)))
	      (OR (NULL WL) (EQ WL CURRENT-PROCESS))))
	  (LOCF WRITE-LOCK)))
      ;; Claim that we are reading this node, consing as little as possible
      ;; Multiple readers mean there's no need to use PROCESS-LOCK to do this.
      (IF (NULL READ-LOCK)
	  (SETQ READ-LOCK LOCK-VALUE
		LOCKED-P  T)
	(IF (LISTP READ-LOCK)
	    (UNLESS (MEMQ LOCK-VALUE READ-LOCK)
	      (PUSH LOCK-VALUE READ-LOCK)
	      (SETQ LOCKED-P T))
	  (UNLESS (EQ READ-LOCK LOCK-VALUE)
	    (SETQ READ-LOCK (LIST LOCK-VALUE READ-LOCK)
		  LOCKED-P  T)))))
    LOCKED-P))

(DEFMETHOD (UNLOCK-NODE-READ-LOCK NODE) (LOCKED-P)
  ;; Remove ourselves from the list of readers
  (WHEN LOCKED-P
    (WITHOUT-INTERRUPTS
      (IF (LISTP READ-LOCK)
	  (LET ((LOCK-VALUE CURRENT-PROCESS))
	    (SETQ READ-LOCK (DELQ LOCK-VALUE READ-LOCK)))
	(SETQ READ-LOCK NIL)))))


;; Write-locking 325 nodes (e.g., LCONS.LISP) takes about .035 seconds and
;; conses about 870 words
(DEFMACRO WITH-INTERVAL-WRITE-LOCKED ((BP1 &OPTIONAL BP2 IN-ORDER-P) &BODY BODY)
  (DECLARE (ZWEI:INDENTATION 0 3 1 1))
  ;; No need to stack-allocate these, they're typically quite small
  `(LET* ((NODES (COLLECT-LOCK-NODES-IN-REGION ,BP1 ,BP2 ,IN-ORDER-P))
	  (N-NODES (LENGTH NODES))
	  (LOCKED-PS (MAKE-ARRAY N-NODES :TYPE 'ART-BOOLEAN)))
     (UNWIND-PROTECT
	 (PROGN
	   (LOOP FOR NODE IN NODES
		 FOR I UPFROM 0
		 AS LOCKED-P = (LOCK-NODE-WRITE-LOCK NODE)
		 DO (SETF (AREF LOCKED-PS I) LOCKED-P))
	   ,@BODY)
       ;; Unlock nodes in the reverse order
       (LOOP FOR NODE IN (NREVERSE NODES)
	     FOR I UPFROM 0
	     AS LOCKED-P = (AREF LOCKED-PS (- N-NODES I 1))
	     DO (UNLOCK-NODE-WRITE-LOCK NODE LOCKED-P)))))

;; Read-locking 325 nodes (e.g., LCONS.LISP) takes about .037 seconds and
;; conses about 870 words
(DEFMACRO WITH-INTERVAL-READ-LOCKED ((BP1 &OPTIONAL BP2 IN-ORDER-P) &BODY BODY)
  (DECLARE (ZWEI:INDENTATION 0 3 1 1))
  ;; No need to stack-allocate these, they're typically quite small
  `(LET* ((NODES (COLLECT-LOCK-NODES-IN-REGION ,BP1 ,BP2 ,IN-ORDER-P))
	  (N-NODES (LENGTH NODES))
	  (LOCKED-PS (MAKE-ARRAY N-NODES :TYPE 'ART-BOOLEAN)))
     (UNWIND-PROTECT
	 (PROGN
	   (LOOP FOR NODE IN NODES
		 FOR I UPFROM 0
		 AS LOCKED-P = (LOCK-NODE-READ-LOCK NODE)
		 DO (SETF (AREF LOCKED-PS I) LOCKED-P))
	   ,@BODY)
       (LOOP FOR NODE IN (NREVERSE NODES)
	     FOR I UPFROM 0
	     AS LOCKED-P = (AREF LOCKED-PS (- N-NODES I 1))
	     DO (UNLOCK-NODE-READ-LOCK NODE LOCKED-P)))))

;; This has an implicit assumptions which will cause nested nodes to not
;; work.  If you have buffers with nested nodes, the node-to-lock for the
;; inferior nodes should be the highest parent node (the one just below
;; the buffer itself).
(DEFUN COLLECT-LOCK-NODES-IN-REGION (START-BP &OPTIONAL END-BP IN-ORDER-P)
  (COND ((NULL START-BP)
	 ;; Source Compare can do this to us
	 NIL)
	((AND (NULL END-BP)
	      (OPERATION-HANDLED-P START-BP 'BUFFER-SECTIONS)
	      ;; Don't do this if the "buffer" is just a section
	      (NOT (TYPEP START-BP 'SECTION-NODE)))
	 (WHEN (BUFFER-LOCK-ENTIRE-BUFFER START-BP)
	   (RETURN-FROM COLLECT-LOCK-NODES-IN-REGION (LIST START-BP)))
	 ;; "Short cut" when we're collecting nodes for the entire interval.
	 ;; This should also handle VC buffers and buffer with nested sections
	 ;; correctly, but we pay a bit in speed.
	 ;;--- I hope that marching through the sections will turn up all the locks
	 (LOOP WITH BUFFER = START-BP
	       FOR NODE IN (BUFFER-SECTIONS BUFFER)
	       AS PREVIOUS-LOCK-NODE = NIL THEN LOCK-NODE
	       AS LOCK-NODE = (NODE-TO-LOCK BUFFER NODE)
	       WHEN (AND LOCK-NODE
			 (NEQ LOCK-NODE PREVIOUS-LOCK-NODE))
		 COLLECT LOCK-NODE))
	(T
	 (GET-INTERVAL START-BP END-BP IN-ORDER-P)
	 (LET ((START-LINE (BP-LINE START-BP))
	       (END-LINE (BP-LINE END-BP))
	       (BUFFER (BP-BUFFER START-BP)))
	   (WHEN (BUFFER-LOCK-ENTIRE-BUFFER BUFFER)
	     (RETURN-FROM COLLECT-LOCK-NODES-IN-REGION (LIST BUFFER)))
	   ;; We need to march over lines in the interval and get the node from
	   ;; each line, so that buffers with nested sections work correctly.
	   ;;--- This should really walk the nodes instead of the lines
	   ;;--- in order to get better performance.
	   (LOOP FOR LINE = START-LINE THEN (LINE-NEXT-IN-BUFFER LINE :BUFFER BUFFER)
		 AS PREVIOUS-LOCK-NODE = NIL THEN LOCK-NODE
		 AS LOCK-NODE = (AND LINE (NODE-TO-LOCK BUFFER (LINE-NODE LINE)))
		 WHEN (AND LOCK-NODE
			   (NEQ LOCK-NODE PREVIOUS-LOCK-NODE))
		   COLLECT LOCK-NODE
		 UNTIL (OR (NULL LINE)
			   (EQ LINE END-LINE)))))))


;;; A variable is a symbol, whose print name starts and ends with "*".
;;; The value of the variable is the value of the symbol.
;;; It has the following  properties:
;;; VARIABLE-NAME             The name, a string derived from the print-name of the symbol.
;;; VARIABLE-INIT             The initial value.
;;; VARIABLE-TYPE             One of the type symbols below.
;;; VARIABLE-DOCUMENTATION    A string documenting the variable.  The first line
;;;                             is the "short form.

;;; The value of *VARIABLE-ALIST* associates names of variables with their
;;; corresponding symbols.

;;; The following types are meaningful:
;;; :BOOLEAN    T or NIL.
;;; :KEYWORD    A symbol on the user package.
;;; :STRING     A string.
;;; :CHAR       A character as a fixnum.
;;; :CHAR-LIST  A list of characters as fixnums.
;;; :FIXNUM     A fixnum.
;;; :FIXNUM-OR-NIL     A fixnum or NIL.
;;; :SMALL-FRACTION A small flonum between 0.0s0 and 1.0s0, inclusively.
;;; :ANYTHING   Any Lisp object.

;;; Variables are defined by:
;;; (DEFVARIABLE <name> <init> <type> <documentation>)

(DEFPROP DEFVARIABLE DEFVAR DEFINITION-FUNCTION-SPEC-TYPE)

(DEFMACRO DEFVARIABLE (VAR INIT TYPE DOC &OPTIONAL SET-FN VALUE-TEST)
  `(PROGN
     (EVAL-WHEN (COMPILE)
       (SI:DEFINE-SYMBOL-MACRO-COMPILE ',VAR `(VARIABLE-VALUE ',',VAR)))
     (DEFINE-VARIABLE ',VAR ,INIT ',TYPE ,DOC ,SET-FN ,VALUE-TEST)
     (CL:PROCLAIM '(SPECIAL ,VAR))))

(DEFVAR *VARIABLE-ALIST* NIL :LOCALIZE T)	;Associates variable names with variables.

(DEFUN DEFINE-VARIABLE (VAR INIT TYPE DOC &OPTIONAL SET-FN VALUE-TEST)
  (CHECK-ARG TYPE (OR (DW:PRESENTATION-TYPE-P TYPE)
		      (MEMQ TYPE '(:BOOLEAN :KEYWORD :STRING :FIXNUM-OR-NIL :SMALL-FRACTION
				   :CHAR :CHAR-LIST :FIXNUM :CHARACTER-STYLE :ANYTHING)))
	     "a valid presentation type or ZWEI variable type")
  (LET ((NAME (SI:MAKE-COMMAND-NAME VAR)))
    (PUTPROP VAR NAME 'VARIABLE-NAME)
    (UNLESS (ASSOC NAME *VARIABLE-ALIST*)
      (PUSH (CONS NAME VAR) *VARIABLE-ALIST*)))
  (PUTPROP VAR INIT 'VARIABLE-INIT)
  (PUTPROP VAR TYPE 'VARIABLE-TYPE)
  (PUTPROP VAR DOC 'VARIABLE-DOCUMENTATION)
  (PUTPROP VAR SET-FN 'VARIABLE-SET-FUNCTION)
  (PUTPROP VAR VALUE-TEST 'VARIABLE-VALUE-TEST)
  (SI:DEFINE-SYMBOL-MACRO-LOAD VAR `(VARIABLE-VALUE ',VAR)))

(DEFMACRO DEFINE-LOCAL-VARIABLE (VAR &OPTIONAL (INIT NIL INIT-P))
  `(PROGN
     (SI:DEFINE-SYMBOL-MACRO ,VAR (VARIABLE-VALUE ',VAR))
     ,@(WHEN INIT-P
	 `((SETF (SYMEVAL ',VAR) ,INIT)))))

;;; This is obsolete, replaced by a CL:DEFSETF in sys:zwei;modes
;;;(DEFPROP VARIABLE-VALUE ((VARIABLE-VALUE VAR) . (SET-ZWEI-VARIABLE VAR SI:VAL)) SETF)
;;;

(DEFMACRO LET-BUFFER-VARIABLE ((VAR-NAME VALUE) &BODY BODY)
  `(MULTIPLE-VALUE-BIND (.VAL. .BOUND-P.)
       (SEND-IF-HANDLES *INTERVAL* ':VARIABLE-VALUE ',VAR-NAME)
     (UNWIND-PROTECT
	 (PROGN
	   (SEND-IF-HANDLES *INTERVAL* ':SET-VARIABLE-VALUE ',VAR-NAME ,VALUE)
	   . ,BODY)
       (IF .BOUND-P.
	   (SEND-IF-HANDLES *INTERVAL* ':SET-VARIABLE-VALUE ',VAR-NAME .VAL.)
	 (SEND-IF-HANDLES *INTERVAL* ':REMOVE-VARIABLE-VALUE ',VAR-NAME)))))

(DEFUN SETQ-ZWEI-VARIABLES ()
  (DO L *VARIABLE-ALIST* (CDR L) (NULL L)
    (LET ((V (CDAR L)))
      (SET V (GET V 'VARIABLE-INIT)))))

(SETQ *LISP-INDENTATION-OFFSET-HASH-TABLE*
      (NCONC *LISP-INDENTATION-OFFSET-HASH-TABLE*
	     '((LAMBDA 1 1) (SYS:NAMED-LAMBDA 2 1)
	       (*CATCH 1 1) (CATCH 1 1)
	       (LET 1 1) (LET* 1 1) (LET-IF 2 1) (LETF 1 1) (LETF* 1 1)
	       (LET-GLOBALLY 1 1) (LET*-GLOBALLY 1 1) (LET-GLOBALLY-IF 2 1)
	       (SYS:LETF-IF 2 1) (SYS:LETF*-IF 2 1)
	       (COMPILER-LET 1 1)
	       (FLET 1 1) (LABELS 1 1) (MACROLET 1 1)
	       #+++IGNORE (IF 2 1)
	       (DO 2 1) (DO-NAMED 3 1) (DO* 2 1) (DO*-NAMED 3 1)
	       (RETURN-FROM 1 1) (THROW 1 1)
	       (WHEN 1 1) (UNLESS 1 1)
	       (PROGV 2 1) (CL:PROGV 2 1) (PROGW 1 1) (BLOCK 1 1)
	       (PROG . INDENT-PROG) (PROG* . INDENT-PROG) (TAGBODY . INDENT-TAGBODY)
	       (LOOP . INDENT-LOOP)
	       (UNWIND-PROTECT 0 3 1 1)
	       (MULTIPLE-VALUE 1 1) (MULTIPLE-VALUE-BIND 1 3 2 1)
	       (WITH-STACK-LIST 1 1) (WITH-STACK-LIST* 1 1)
	       (CONDITION-CASE 1 3 2 1) (CONDITION-CASE-IF 2 3 3 1)
	       (CONDITION-CALL 1 3 2 1) (CONDITION-CALL-IF 2 3 3 1)
	       (DEFFLAVOR 1 7 3 1)
	       (DEFPROP . NIL) (:DEFAULT-INIT-PLIST . NIL)
	       (EVAL-WHEN 1 1) (PACKAGE-DECLARE 1 5 5 1) (DEFPACKAGE 1 1)
	       (PROCESS-RUN-FUNCTION 1 1)
	       (PROCESS-RUN-RESTARTABLE-FUNCTION 1 1)
	       (PROCESS-WAIT-WITH-TIMEOUT 0 3 2 1)
	       (PROCESS-WAIT 0 3 1 1)
	       )))

(DEFUN BOOTSTRAP-INDENTATION-HASH-TABLE ()
  (LET ((HASH (CL:MAKE-HASH-TABLE :SIZE (* 2 (LENGTH *LISP-INDENTATION-OFFSET-HASH-TABLE*)))))
    (LOOP FOR (FUNCTION . INDENTATION) IN *LISP-INDENTATION-OFFSET-HASH-TABLE*
	  UNLESS (MULTIPLE-VALUE-BIND (NIL FOUND)
		     (SEND HASH :GET-HASH FUNCTION)
		   FOUND)			;Shadowing should still work, I guess.
	    DO (SEND HASH :PUT-HASH FUNCTION (COPYLIST INDENTATION *ZMACS-BUFFER-AREA*)))
    (SETQ *LISP-INDENTATION-OFFSET-HASH-TABLE* HASH)))

(ADD-INITIALIZATION "BOOTSTRAP-INDENTATION-HASH-TABLE"
		    '(BOOTSTRAP-INDENTATION-HASH-TABLE)
		    NIL
		    '*EDITOR-INITIALIZATION-LIST*)

(DEFVARIABLE *FILL-COLUMN* 576. ((SCL:INTEGER 1))
   "Width in pixels used for filling text.")
(DEFVARIABLE *PARAGRAPH-DELIMITER-LIST* '(#\SP #\TAB) ((CL:SEQUENCE SCL:CHARACTER))
   "Characters considered to start a paragraph if at beginning of line.")
(DEFVARIABLE *PAGE-DELIMITER-LIST* '(#\FF) ((CL:SEQUENCE SCL:CHARACTER))
   "Characters which separate pages.")
(DEFVARIABLE *STICKY-MINOR-MODES* '(ATOM-WORD-MODE WORD-ABBREV-MODE EMACS-MODE)
  ((SCL:SEQUENCE SYS:SYMBOL))
  "Minor modes to carry from current buffer to new ones.")
(DEFVARIABLE *UNSTICKY-MINOR-MODES*
	     '(ELECTRIC-SHIFT-LOCK-MODE ELECTRIC-CHARACTER-STYLE-LOCK-MODE)
  ((SCL:SEQUENCE SYS:SYMBOL))
  "Minor modes that are turned off when the mode is changed explicitly")
(DEFVARIABLE *INITIAL-MINOR-MODES* NIL ((SCL:SEQUENCE SYS:SYMBOL))
   "Minor modes turned on in any major mode")
(DEFVARIABLE *DEFAULT-SAVE-MODE* :ASK ((CL:MEMBER NIL :ASK :ALWAYS))
   "Default save mode for new buffers (NIL, Ask, Always).")
(DEFVARIABLE *FIND-FILE-SAVE-MODE* :ASK ((CL:MEMBER NIL :ASK :ALWAYS))
   "Default save mode for new buffers create by Find File (NIL, Ask, Always).")
(DEFVARIABLE *DIRECTORY-LISTER* 'DEFAULT-DIRECTORY-LISTER SYS:EXPRESSION
   "Function used by Display Directory and auto directory display option.")
(DEFVARIABLE *AUTO-PUSH-POINT-OPTION* 12 ((SCL:NULL-OR-TYPE ((SCL:INTEGER 1))))
   "Searches push point if it moves more than this many lines.")
(DEFVARIABLE *AUTO-PUSH-POINT-NOTIFICATION* "Point pushed" STRING-FOR-VARIABLE
   "This is typed in the echo area when point is automatically pushed.")
(DEFVARIABLE *AUTO-DIRECTORY-DISPLAY* NIL ((CL:MEMBER NIL :READ :WRITE T))
   "Tells on which kind of file commands to display directory (NIL, Read, Write, T).")
(DEFVARIABLE *TAB-BLINKER-FLAG* T SCL:BOOLEAN
   "If a blinker is placed over a tab, make the blinker the width of a space.")
(DEFVARIABLE *FILL-PREFIX* "" STRING-FOR-VARIABLE
   "String to put before each line when filling.")
(DEFVARIABLE *FILL-EXTRA-SPACE-LIST* '(#/. #/! #/? #/:) ((SCL:SEQUENCE SCL:CHARACTER))
   "Characters which should be followed by two spaces in filling.")
(DEFVARIABLE *FLASH-MATCHING-PAREN* T SCL:BOOLEAN
   "When point is to the right of a close paren or at an open paren, flash the matching paren.")
(DEFVARIABLE *COMMENT-START* NIL STRING-FOR-VARIABLE
   "String that indicates the start of a comment.")
(DEFVARIABLE *COMMENT-BEGIN* ";" STRING-FOR-VARIABLE
   "String for beginning new comments.")
(DEFVARIABLE *COMMENT-END* "" STRING-FOR-VARIABLE
   "String for ending comments.")
(DEFVARIABLE *COMMENT-COLUMN* (* 48. 8) ((SCL:INTEGER 1))
   "Column (in pixels) in which to start new comments.")
(DEFVARIABLE *CASE-REPLACE-P* T SCL:BOOLEAN
   "Replacing commands try to preserve case.")
(DEFVARIABLE *STYLE-REPLACE-P* T SCL:BOOLEAN
   "Replacing commands try to preserve character-style.")
(DEFVARIABLE *PERMANENT-REAL-LINE-GOAL-XPOS* NIL ((SCL:NULL-OR-TYPE ((SCL:INTEGER 0))))
   "If non-NIL, goal for Up and Down Real Line commands.")
(DEFVARIABLE *SPACE-INDENT-FLAG* NIL SCL:BOOLEAN
   "If true, Auto Fill mode will indent new lines.")
(DEFVARIABLE *POINT-PDL-MAX* 10 ((SCL:INTEGER 1))
   "The maximum number of elements on the point PDL.
The point PDL is the push-down-list of saved places in the buffer
where the POINT has been.")
(DEFVARIABLE *KILL-RING-MAX* 10 ((SCL:INTEGER 1))
   "The maximum number of elements on the kill ring.
The kill ring is the ring buffer of pieces of text saved by command
that delete text and brought back by commands that yank text.")
(DEFVARIABLE *SEARCH-RING-MAX* 3 ((SCL:INTEGER 1))
   "The maximum number of elements on the search ring.
The search ring is the ring buffer of default search strings.")
(DEFVARIABLE *CENTER-FRACTION* 0.5s0 ((SCL:NUMBER 0 1))
   "Where to recenter the window.
This is how far down in the window the point should be placed when ZWEI
recenters POINT in the window, as a fraction from 0.0 to 1.0.")
(DEFVARIABLE *MIN-RESET-FRACTION* 0.8s0 ((SCL:NUMBER 0 1))
   "Where to recenter the window when you go off the bottom.
This is how far down in the window the point should be placed when ZWEI
moves the text in the window because you moved off the bottom.
It should be a fraction from 0.0 to 1.0.")
(DEFVARIABLE *MAX-RESET-FRACTION* 0.2s0 ((SCL:NUMBER 0 1))
   "Where to recenter the window when you go off the top.
This is how far down in the window the point should be placed when ZWEI
moves the text in the window because you moved off the top.
It should be a fraction from 0.0 to 1.0.")
(DEFVARIABLE *BLANKS* '(#\SPACE #\TAB) ((SCL:SEQUENCE SCL:CHARACTER))
   "List of characters that ZWEI thinks of as blanks.
The initial contents of this variable are the characters Space and Tab.")
(DEFVARIABLE *WHITESPACE-CHARS* '(#\SPACE #\TAB #\RETURN) ((SCL:SEQUENCE SCL:CHARACTER))
   "List of characters that ZWEI thinks of as whitespace.
The initial contents of this variable are the characters Space, Tab, and Return.")
(DEFVARIABLE *REGION-MARKING-MODE* :UNDERLINE ((CL:MEMBER :UNDERLINE :REVERSE-VIDEO))
   "How to mark the region.
This variable tells ZWEI how to denote the region between POINT and MARK,
either Underline or Reverse-Video.")
(DEFVARIABLE *REGION-RIGHT-MARGIN-MODE* NIL SCL:BOOLEAN
   "Should region marking extend to right margin, if region extends past the line?")
(DEFVARIABLE *DEFAULT-MAJOR-MODE* ':FUNDAMENTAL :KEYWORD
   "The major mode in which new buffers are placed by default.")
(DEFVARIABLE *DEFAULT-PACKAGE* (CL:FIND-PACKAGE "USER") ((SCL:NULL-OR-TYPE SCL:PACKAGE))
   "The package new buffers are initially in."
   #'(LAMBDA (IGNORE PKG)
       (SETF (CL:SYMBOL-VALUE 'ZWEI:*DEFAULT-PACKAGE*) PKG)
       (LET ((NEW-SYNTAX (SI:LISP-SYNTAX-FROM-PACKAGE (SYS:FIND-PACKAGE-FOR-SYNTAX PKG))))
	 (WHEN NEW-SYNTAX
	   (SETQ SI:*DEFAULT-LISP-SYNTAX* (SI:LISP-SYNTAX-NAME-SYMBOL NEW-SYNTAX))))
       PKG))
(DEFVARIABLE *LISP-INDENT-OFFSET* NIL ((SCL:NULL-OR-TYPE ((SCL:INTEGER 0))))
   "Same as QLisp Indent Offset in EMACS.  Good luck trying to use it. - DLW & MMcM")
(DEFVARIABLE *COMMENT-ROUND-FUNCTION* 'ROUND-FOR-COMMENT SYS:SYMBOL
   "Function used to round up column when comments cannot be aligned to comment column.")
(DEFVARIABLE *LISP-DEFUN-INDENTATION* '(2 1) ((SCL:SEQUENCE ((SCL:INTEGER 0))))
   "Amount to indent the second line of a defun.")
;;; definition of *LISP-INDENT-OFFSET-ALIST* moved to LISPFN, renamed 
;;; to *LISP-INDENTATION-OFFSET-ALIST*, *INITIAL-... removed.
;;; Renamed again to *LISP-INDENTATION-OFFSET-HASH-TABLE* 6/26/85
(DEFVARIABLE *LISP-INDENT-LONE-FUNCTION-OFFSET* 1 ((SCL:INTEGER 0))
   "Amount to offset indentation of car of list.")
(DEFVARIABLE *FILE-VERSIONS-KEPT* 2 ((SCL:INTEGER 1))
   "Number of non-superfluous versions of a file in Dired.")
(DEFVARIABLE *ALWAYS-OFFER-TO-EXPUNGE* NIL SCL:BOOLEAN
   "If false, only offer to expunge when exiting Dired if the file system is known to
support undeletion.")
(DEFVARIABLE *TEMP-FILE-TYPE-LIST* '(:UNBIN :OUTPUT)
	     ((SCL:SEQUENCE SCL:KEYWORD))
   "List of canonical file types to be automatically marked for deletion in Dired.")
(DEFVARIABLE *DIRED-KILL-BUFFER-ON-EXIT* NIL ((CL:MEMBER NIL T :ASK ))
  "Whether to kill the *Dired* buffer when exiting with /"Q/" (NIL, T, Ask)"
  #'SET)
(DEFVARIABLE *TEXT-JUSTIFIER-ESCAPE-LIST* '(#/. #/@ #/- #/\ #/')
  ((SCL:SEQUENCE SCL:CHARACTER))
   "List of characters that start text justifier commands when at the start of the line.")
(DEFVARIABLE *TEXT-JUSTIFIER-UNDERLINE-BEGIN* #/ SCL:CHARACTER
   "Character to start an underlining.")
(DEFVARIABLE *TEXT-JUSTIFIER-UNDERLINE-END* #/ SCL:CHARACTER
   "Character to end an underlining.")
(DEFVARIABLE *INDENT-WITH-TABS* T SCL:BOOLEAN
   "Indentation uses tab characters.")
(DEFVARIABLE *ELECTRIC-SHIFT-LOCK-XORS* T SCL:BOOLEAN
   "Shift key acts as xor of shift in electric shift-lock mode")
(DEFVARIABLE *KILL-INTERVAL-SMARTS* NIL SCL:BOOLEAN
   "Kill and yank commands try to optimize whitespace")

(DEFVARIABLE *ONE-WINDOW-DEFAULT* :CURRENT ((CL:MEMBER :TOP :BOTTOM :CURRENT :OTHER))
	     "Which window to expand to full size for One Window command.
Can be Top, Bottom, Current, or Other")

(DEFVARIABLE *MODE-LINE-PROPERTIES*
	     '(:MODE :BASE :IBASE :PACKAGE :LOWERCASE :FONTS :BACKSPACE :TAB-WIDTH :VSP
	       :DIAGRAM :EVALUATOR :NOFILL :PATCH-FILE :SYNTAX :DEFAULT-CHARACTER-STYLE)
	     ((SCL:SEQUENCE SCL:KEYWORD))
   "Known attributes in the -*- line")

(DEFVARIABLE *ATTRIBUTES-REMEMBERED-IN-BUFFER*
	     '(:LOWERCASE :BACKSPACE :DIAGRAM :EVALUATOR :NOFILL :PATCH-FILE :BASE
			  :SYNTAX :DEFAULT-CHARACTER-STYLE)
	     ((SCL:SEQUENCE SCL:KEYWORD))
   "Known attributes taken from the -*- line into the buffer plist.")

(DEFVARIABLE *ALPHABETIC-CASE-AFFECTS-SEARCH* NIL SCL:BOOLEAN
   "Search commands are case sensitive")

(DEFVARIABLE *ARGUMENT-PROMPT-DELAY* 20. ((SCL:NULL-OR-TYPE ((SCL:INTEGER 0))))
   "Time (in 60ths) with no input after typing an argument command before the prompt appears."
   )

(DEFVARIABLE *AUTO-FILL-ACTIVATION-CHARACTERS* '(#\SP #\CR #/. #/? #/!)
  ((SCL:SEQUENCE SCL:CHARACTER))
   "Characters which cause filling in auto fill mode")

(DEFVARIABLE *INDENT-NEW-LINE-NEW-LINE-FUNCTION* NIL SYS:SYMBOL
  "Function to go to a new line in COM-INDENT-NEW-LINE instead of indirecting through Return."
   )
(DEFVARIABLE *INDENT-NEW-LINE-INDENT-FUNCTION* NIL SYS:SYMBOL
  "Function to indent a new line in COM-INDENT-NEW-LINE instead of indirecting through Tab.")

(DEFVARIABLE *CHECK-UNBALANCED-PARENTHESES-WHEN-SAVING* T SCL:BOOLEAN
  "Check for unbalanced parentheses when saving LISP buffers.")

(DEFVARIABLE *HISTORY-MENU-LENGTH* 20. ((SCL:INTEGER 1))
  "Maximum number of history elements displayed when a numeric argument of 0 is used")

(DEFVARIABLE *HISTORY-YANK-WRAPAROUND* T SCL:BOOLEAN
  "Enable Yank commands to wrap around at end of history, rather than beeping")

(DEFVARIABLE *HISTORY-ROTATE-IF-NUMERIC-ARG* NIL SCL:BOOLEAN
  "If NIL, only Yank commands with no explicit numeric argument are rotated")

(DEFVARIABLE *GRIND-EXPRESSION-WIDTH* 90. ((SCL:INTEGER 1))
  "Number of characters per line in ground expressions.")

(DEFVARIABLE *ENABLE-PACKAGE-DWIM* T SCL:BOOLEAN
  "If NIL, don't search other packages when looking up definitions.")

(DEFVARIABLE *WINDOW-LABEL-CHARACTER-STYLE*
	     (SI:PARSE-CHARACTER-STYLE '(NIL NIL NIL)) SCL:CHARACTER-STYLE
  "Character style used for the label in the bottom line of each window."
  #'(LAMBDA (VAR VALUE)
      (SETQ *ZMACS-WINDOW-DEFAULT-PANE-LABEL-CHARACTER-STYLE*
	    (SI:PARSE-CHARACTER-STYLE VALUE))
      (SET VAR (SI:PARSE-CHARACTER-STYLE VALUE))
      (WHEN (VARIABLE-BOUNDP *ZMACS-MAIN-FRAME*)
	(CL:SETF (ZMACS-FRAME-PANE-LABEL-CHARACTER-STYLE *ZMACS-MAIN-FRAME*)
		 (SI:PARSE-CHARACTER-STYLE VALUE)))))

(DEFVARIABLE *WINDOW-LABEL-MODE* NIL ((CL:MEMBER NIL :VC-BUFFERS-ONLY :ALWAYS))
  "When to use a label in the window, in one-window mode (NIL, VC-Buffers-Only, Always)."
  #'(LAMBDA (VAR VALUE)
      (SETQ *ALWAYS-LABEL-ZMACS-WINDOWS* VALUE)
      (SET VAR VALUE)))

(DEFVARIABLE *RECORD-SMALL-CHANGES* T :BOOLEAN
  "Yes => record minor editing changes so they can be undone.")

(DEFVARIABLE *DISCARD-CHANGE-RECORD-AFTER-SAVING* T :BOOLEAN
  "Yes => when a buffer is saved, throw away records of changes, thus they can't be undone.")

(DEFVARIABLE *SIMPLE-CHANGE-CONTIGUITY-RANGE* 3 :FIXNUM
  "Maximum number of unchanged characters between sections of a simple change.
If more unchanged characters than this intervene between two changes,
they will be considered two independent changes by the undo command.
This only applies within a line.")

(DEFVARIABLE *SIMPLE-CHANGE-SIZE* 50. :FIXNUM
  "Simple changes containing more than this many characters are worth undoing separately.
Edits at the end of such a change are regarded as part of the same change, but
edits in the middle are taken to begin a new change.")

(DEFVARIABLE *INSERTION-AMENDMENT-SIZE* 10. :FIXNUM
  "Changes to up to this many newly-inserted characters aren't worth undoing separately.")

(DEFVARIABLE *INSERTION-BREAKUP-LINES* 4 :FIXNUM
  "Two insertions of at least this many lines, with a blank line between, are worth
undoing separately.")

(DEFVARIABLE *UNDO-EACH-REPLACE-SEPARATELY* NIL :BOOLEAN
  "If Yes, each change made by Query Replace or Replace String can be undone separately.
If No, all the changes are undone as a unit.")

(DEFVARIABLE *UNDO-SETS-REGION* T :BOOLEAN
  "If Yes, the Undo and Redo commands set a region to highlight what was undone.")

(DEFVARIABLE *YANK-IS-SEPARATELY-UNDOABLE* :MULTI-LINE
  ((SCL:ALIST-MEMBER :ALIST (("Yes" T) ("Multi-Line" :MULTI-LINE) ("No" NIL))))
  "If Yes, a yank is worth undoing separately from any edits before or after it.
If Multi-Line, this is true only when the yanked text is more than one line.
If No, a yank can be merged with edits before or after it, approximately
the same as if the yanked text had been typed in one character at a time.")

(DEFVARIABLE *UPDATE-TYPEIN-CHARACTER-STYLE-WHEN-MOVING* NIL
  ((SCL:ALIST-MEMBER :ALIST
     (("Disabled" :VALUE NIL
       :DOCUMENTATION "Don't change typein style")
      ("Before" :VALUE :BEFORE
       :DOCUMENTATION "Use the character before point when between two printing characters")
      ("After" :VALUE :AFTER
       :DOCUMENTATION "Use the character after point when between two printing characters")
      ("Heuristic" :VALUE :HEURISTIC
       :DOCUMENTATION "Use the character nearer previous position when between two printing characters"))))
  "If non-NIL, moving in the buffer maintains style according to existing text.")

(DEFVARIABLE *CHANGE-STYLE-MODE* :PROMPT-FOR-NAME
  ((SCL:ALIST-MEMBER :ALIST (("Quick" :QUICK) ("Prompt For Name" :PROMPT-FOR-NAME))))
  "In Prompt For Name mode, any command that changes the character style of
characters, like Change Style Word, prompts for a full character style in
the minibuffer.  In Quick mode, it accepts a one-character accelerator, with
escape provision for being prompted for a full character style."
  NIL
  #'(LAMBDA (VAL)
      (CL:MEMBER VAL '(:QUICK :PROMPT-FOR-NAME))))

(DEFVARIABLE *LINE-MOTION-EXTENDS-BUFFER* :FORWARD
  ((SCL:MEMBER :FORWARD :BACKWARD :ALWAYS :NEVER) :DESCRIPTION
   "a situation")
   "Whether the buffer should be extended when line motion tries to move beyond
the end of the buffer.

For example, this affects the commands Down Real Line, Down Comment Line,
and Down Indented Line, as well as their upward counterparts.

Possible values for this variable are:

  1Always0    An attempt to move to a point before the beginning of the buffer
            or after the end of the buffer will cause the buffer to be extended.

  1Forward0   An attempt to move to a point after the end of the buffer will
            cause the buffer to be extended, but an attempt to move to a point before
            the beginning of the buffer will cause an error.

 1 Backward0  An attempt to move to a point before the beginning of the buffer
            will cause the buffer to be extended, but an attempt to move to a point after
            the end of the buffer will cause an error.

  1Never0     An attempt to move to a point before the beginning of the buffer
            or after the end of the buffer will cause an error.")

(ZWEI:DEFVARIABLE ZWEI:*SAVE-FILE-BUFFERS-OPTIONS-TO-CONFIRM*
		  '(:UNMODIFY			;Because it loses information
		    :REVERT			;Ditto
		    :LATER)			;If order matters, tread lightly
  ;; Note that Other is not included here because it's hard to type by accident
  ;; since it already requires an auxiliary prompt for the filename to use, 
  ;; and Save is not included here because people are already used to that not 
  ;; prompting for further queries.
  ;;
  ;; SCL:TOKEN-OR-TYPE should work here, but its mouse-sensitivity doesn't work right,
  ;; causing a debugger blowout, so we cheat and use an equivalent form. -kmp 30-Nov-90
  ((OR ((SCL:SEQUENCE
	  (DW:ALIST-MEMBER
	    :ALIST (("Later"    . :LATER)
		    ("Revert"   . :REVERT)
		    ("Save"     . :SAVE)
		    ("Other"    . :SAVE-OTHER)
		    ("Unmodify" . :UNMODIFY))))
	:DESCRIPTION "a set of options")
       ((DW:ALIST-MEMBER :ALIST (("None" :VALUE ()))))))
  "A set of situations in the query for Save File Buffers which force a need 
for a final confirmation query of the action.")

