;;; -*- Mode: LISP; Syntax: ZetaLisp; Package: ZWEI; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Special purpose buffers for editing functions and symbols.

(DEFFLAVOR FUNCTION-SPEC-SUBNODE () (FUNCTION-SPEC-OBJECT POSSIBILITY-SUBNODE)
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:SELECT-POSSIBILITY FUNCTION-SPEC-SUBNODE) ()
  (EDIT-DEFINITION FUNCTION-SPEC (AND DEFINITION-TYPE (NCONS DEFINITION-TYPE)))
  DIS-TEXT)

(DEFMETHOD (:DESCRIPTION FUNCTION-SPEC-SUBNODE) (STREAM)
  (PRIN1 FUNCTION-SPEC STREAM))

(DEFMETHOD (PRESENT-YOUR-FUNCTION-SPEC FUNCTION-SPEC-SUBNODE) (STREAM)
  (PRESENT-AS-FUNCTION-SPEC FUNCTION-SPEC STREAM))

(DEFFLAVOR INSTANCE-VARIABLE-ACCESSOR-SUBNODE () (FUNCTION-SPEC-SUBNODE))

(DEFMETHOD (:SELECT-POSSIBILITY INSTANCE-VARIABLE-ACCESSOR-SUBNODE) ()
  (EDIT-INSTANCE-VARIABLE-ACCESSOR FUNCTION-SPEC))

(DEFUN EDIT-INSTANCE-VARIABLE-ACCESSOR (FUNCTION-SPEC)
  (LET ((TYPE    (FLAVOR:METHOD-TYPE FUNCTION-SPEC))
	(GENERIC (FLAVOR:METHOD-GENERIC FUNCTION-SPEC))
	(IV      (FLAVOR::ACCESSOR-INSTANCE-VARIABLE FUNCTION-SPEC))
	(FLAVOR  (FLAVOR:METHOD-FLAVOR FUNCTION-SPEC)))
    (TYPEIN-LINE "The ~A for ~S, ~S, is defined by the flavor ~S"
		 (OR (CADR (ASSOC TYPE '((FLAVOR:READ-INSTANCE-VARIABLE   "reader")
					 (FLAVOR:WRITE-INSTANCE-VARIABLE  "writer")
					 (FLAVOR:LOCATE-INSTANCE-VARIABLE "locator"))))
		     "accessor")
		 IV GENERIC FLAVOR))
  (EDIT-DEFINITION (FLAVOR:METHOD-FLAVOR FUNCTION-SPEC) '(DEFFLAVOR))
  DIS-TEXT)

;Accessor names are not really function specs
(DEFMETHOD (PRESENT-YOUR-FUNCTION-SPEC INSTANCE-VARIABLE-ACCESSOR-SUBNODE) (STREAM)
  (SCL:PRESENT FUNCTION-SPEC 'FLAVOR:INSTANCE-VARIABLE-ACCESSOR
	       :STREAM STREAM :ALLOW-SENSITIVE-INFERIORS NIL))

;;; DEFFLAVOR of FUNCTION-EDITING-SPECIAL-PURPOSE-BUFFER moved to SYS:ZWEI;FLAVOR

(DEFUN PRESENT-AS-FUNCTION-SPEC (FUNCTION-SPEC STREAM)
  (LET ((CL:*PRINT-PRETTY* NIL))
    (SCL:PRESENT FUNCTION-SPEC 'SYS:FUNCTION-SPEC
		 :STREAM STREAM :ALLOW-SENSITIVE-INFERIORS NIL)))

(DEFMETHOD (:LIST-SUBNODES FUNCTION-EDITING-SPECIAL-PURPOSE-BUFFER) (FIRST-NODE)
  (LET ((NODES (LOOP FOR NODE FIRST FIRST-NODE THEN (NODE-NEXT NODE)
		     WHILE NODE
		     COLLECT NODE)))
    #---IGNORE
    (LOOP FOR NODE IN NODES
	  DOING (FORMAT T "~&")
		(PRESENT-YOUR-FUNCTION-SPEC NODE CL:*STANDARD-OUTPUT*))
    #+++IGNORE
    (SCL:FORMAT-ITEM-LIST NODES :PRINTER #'PRESENT-YOUR-FUNCTION-SPEC)))

(DEFMETHOD (:SORT-REMAINING-FUNCTION-SPECS FUNCTION-EDITING-SPECIAL-PURPOSE-BUFFER) (LIST)
  (SORTCAR LIST #'STRING-LESSP))

;;; DEFFLAVOR of ORDERED-FUNCTION-EDITING-SPECIAL-PURPOSE-BUFFER moved to SYS:ZWEI;FLAVOR

(DEFMETHOD (:LIST-SUBNODES ORDERED-FUNCTION-EDITING-SPECIAL-PURPOSE-BUFFER) (FIRST-NODE)
  (LET ((NODES (LOOP FOR NODE FIRST FIRST-NODE THEN (NODE-NEXT NODE)
		     WHILE NODE
		     COLLECT NODE)))
    #---IGNORE
    (LOOP FOR NODE IN NODES
	  DOING (FORMAT T "~&")
		(PRESENT-YOUR-FUNCTION-SPEC NODE CL:*STANDARD-OUTPUT*))
    #+++IGNORE
    (SCL:FORMAT-ITEM-LIST NODES :PRINTER #'PRESENT-YOUR-FUNCTION-SPEC)))


(DEFINE-SPECIAL-BUFFER-TYPE RANDOM-FUNCTION-SPEC-EDITING-BUFFER
	(FUNCTION-SPECS (DEFINITION-TYPE NIL))
	(FUNCTION-EDITING-SPECIAL-PURPOSE-BUFFER)
	:RANDOM-FUNCTION-SPECS "Function-Specs-to-Edit"
  (:BUFFER-INIT-OPTIONS :SET-FUNCTION-SPECS :SET-DEFINITION-TYPE)
  :SETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:HEADER-DESCRIPTION-1 RANDOM-FUNCTION-SPEC-EDITING-BUFFER) (STREAM PLURAL-P)
  (FORMAT STREAM "Function~P to be edited" PLURAL-P))

(DEFMETHOD (:REVERT RANDOM-FUNCTION-SPEC-EDITING-BUFFER) ()
  (DOLIST (FSPEC FUNCTION-SPECS)
    (SEND SELF ':ADD-NODE 'FUNCTION-SPEC-SUBNODE ':FUNCTION-SPEC FSPEC
						 :DEFINITION-TYPE DEFINITION-TYPE)))


(DEFINE-SPECIAL-BUFFER-TYPE CALLERS-OF-FUNCTIONS-EDITING-BUFFER
	(FUNCTION-SPECS
	  (INTERSECT-FUNCTION-SPECS NIL)
	  (CALLED-HOW NIL)
	  (IN-PACKAGE NIL)
	  (IN-SYSTEM NIL))
	(FUNCTION-EDITING-SPECIAL-PURPOSE-BUFFER)
	:CALLERS-OF-FUNCTIONS "Callers"
  :SETTABLE-INSTANCE-VARIABLES
  (:BUFFER-INIT-OPTIONS :SET-FUNCTION-SPECS :SET-INTERSECT-FUNCTION-SPECS
			:SET-CALLED-HOW :SET-IN-PACKAGE :SET-IN-SYSTEM))

(DEFMETHOD (:DESCRIPTION CALLERS-OF-FUNCTIONS-EDITING-BUFFER) ()
  (WITH-OUTPUT-TO-STRING (STREAM)
    (IF INTERSECT-FUNCTION-SPECS
	(PRINT-LIST-WITH-AND STREAM FUNCTION-SPECS)
      (PRINT-LIST-WITH-OR STREAM FUNCTION-SPECS))))

(DEFMETHOD (:HEADER-DESCRIPTION-1 CALLERS-OF-FUNCTIONS-EDITING-BUFFER) (STREAM PLURAL-P)
  (FORMAT STREAM "Caller~P of " PLURAL-P)
  (IF INTERSECT-FUNCTION-SPECS
      (PRINT-LIST-WITH-AND STREAM FUNCTION-SPECS)
    (PRINT-LIST-WITH-OR STREAM FUNCTION-SPECS)))

(DEFMETHOD (:ADDITIONAL-HEADER-DESCRIPTION CALLERS-OF-FUNCTIONS-EDITING-BUFFER) (STREAM)
  (COND (IN-SYSTEM
	 (FORMAT STREAM " in system ~A" IN-SYSTEM))
	(IN-PACKAGE
	 (FORMAT STREAM " in package ~A" IN-PACKAGE))))

(DEFUN PRINT-LIST-WITH-OR (STREAM LIST)
  (SCL:FORMAT-TEXTUAL-LIST LIST #'PRIN1 :CONJUNCTION "or" :STREAM STREAM))

(DEFUN PRINT-LIST-WITH-AND (STREAM LIST)
  (SCL:FORMAT-TEXTUAL-LIST LIST #'PRIN1 :CONJUNCTION "and" :STREAM STREAM))

(DEFUN FLAVOR-METHOD-HAS-NO-SOURCE-CODE (FSPEC)
  (AND (LISTP FSPEC)
       (MEMQ (FLAVOR:METHOD-TYPE FSPEC) FLAVOR:*ALL-METHOD-TYPES*)
       (NOT (MEMQ (FLAVOR:METHOD-TYPE FSPEC) FLAVOR:*SOURCE-CODE-METHOD-TYPES*))))

(DEFMETHOD (:REVERT CALLERS-OF-FUNCTIONS-EDITING-BUFFER) ()
  (LET ((LIST (REVERT-CALLERS-OF-FUNCTIONS-EDITING-BUFFER
		FUNCTION-SPECS INTERSECT-FUNCTION-SPECS
		CALLED-HOW IN-PACKAGE IN-SYSTEM)))
    (LOOP FOR (FSPEC NIL NIL . CALLS)
	      IN (SORT LIST (LAMBDA (X Y)
			      (COND ((EQ (SECOND X) (SECOND Y))
				     ;; pathnames EQ, compare fspec
				     (ALPHALESSP (FIRST X) (FIRST Y)))
				    (T
				     ;; compare string version of pathname
				     (ALPHALESSP (THIRD X) (THIRD Y))))))
	  WHEN (OR (NULL INTERSECT-FUNCTION-SPECS)
		   (CL:SUBSETP FUNCTION-SPECS CALLS
			       :TEST #'(LAMBDA (FSPEC CALL-ITEM)
					 (EQL (SECOND CALL-ITEM) FSPEC))))
	    DO (SEND SELF :ADD-NODE (IF (FLAVOR-METHOD-HAS-NO-SOURCE-CODE FSPEC)
					'INSTANCE-VARIABLE-ACCESSOR-CALLER-SUBNODE
				      'CALLER-SUBNODE)
				    ':FUNCTION-SPEC FSPEC ':CALLS CALLS))))

(DEFCONST *CANONICALIZE-INTERNAL-FUNCTION-SPECS* NIL)

(COMPILER:FUNCTION-DEFINED 'SI:MAP-OVER-CALLERS)	; Forward reference: Utilities
(DEFUN REVERT-CALLERS-OF-FUNCTIONS-EDITING-BUFFER (FUNCTION-SPECS INTERSECT-FUNCTION-SPECS
						   CALLED-HOW IN-PACKAGE IN-SYSTEM)
  (LET ((CALLERS-LIST NIL)
	(NCALLERS 0))
    (TYPEIN-LINE "Searching for ~A of " (WHO-CALLS-MODE-DESCRIPTION))
    (IF INTERSECT-FUNCTION-SPECS
	(PRINT-LIST-WITH-AND *TYPEIN-WINDOW* FUNCTION-SPECS)
      (PRINT-LIST-WITH-OR *TYPEIN-WINDOW* FUNCTION-SPECS))
    ;; If you change these filtering functions, also change SI:COM-SHOW-CALLERS
    (LABELS ((THING-IN-PACKAGE (THING &OPTIONAL IGNORE)
	       (DECLARE (SYS:DOWNWARD-FUNCTION))
	       (COND ((SYMBOLP THING)
		      ;; If we have a symbol, just use its package
		      (EQ (SYMBOL-PACKAGE THING) IN-PACKAGE))
		     ((AND (LISTP THING)
			   (MEMQ (FIRST THING) FLAVOR::*FDEFINABLE-METHOD-TYPES*))
		      ;; If this is something flavorish, there are two case:
		      ;; (1) the thing in the function position is in the right
		      ;; package, or (2) the thing in the function position is
		      ;; a keyword and the flavor is in the right package
		      (LET* ((GENERIC (FLAVOR:METHOD-GENERIC THING))
			     (GENERIC-PACKAGE (WHEN (SYMBOLP GENERIC)
						(SYMBOL-PACKAGE GENERIC))))
			(IF (LISTP GENERIC)
			    ;; Watch out for CL:SETF methods
			    (THING-IN-PACKAGE GENERIC)
			  (OR (EQ GENERIC-PACKAGE IN-PACKAGE)
			      (AND (EQ GENERIC-PACKAGE PKG-KEYWORD-PACKAGE)
				   (EQ (SYMBOL-PACKAGE (FLAVOR:METHOD-FLAVOR THING))
				       IN-PACKAGE))))))
		     ((LISTP THING)
		      ;; If it's an internal function, etc., find the parent
		      (THING-IN-PACKAGE (SECOND THING)))
		     (T T)))
	     (THING-IN-SYSTEM (THING &OPTIONAL IGNORE)
	       (DECLARE (SYS:DOWNWARD-FUNCTION))
	       (LET* ((PATHNAME (GET-SOURCE-FILE-NAME-THAT-WORKS THING NIL T))
		      (SYSTEM (WHEN PATHNAME (SEND PATHNAME :GET 'SCT:SYSTEM))))
		 ;; Match if the specified system is EQ to the system we have our
		 ;; hands on, or if the specified system is not a subsystem, the
		 ;; current system is a subsystem, and the parent systems are EQ
		 (OR (EQ SYSTEM IN-SYSTEM)
		     (AND (NOT (TYPEP IN-SYSTEM 'SCT:SUBSYSTEM))
			  (TYPEP SYSTEM 'SCT:SUBSYSTEM)
			  (EQ IN-SYSTEM (SCT:SUBSYSTEM-PARENT-SYSTEM SYSTEM))))))
	     (GET-SOURCE-FILE-NAME-THAT-WORKS (FSPEC &OPTIONAL TYPE CHASE-PARENTS)
	       (WHEN (FLAVOR-METHOD-HAS-NO-SOURCE-CODE FSPEC)
		 (SETQ FSPEC (FLAVOR:METHOD-FLAVOR FSPEC)))	;Instance variable accessor
	       (SI:GET-SOURCE-FILE-NAME FSPEC TYPE CHASE-PARENTS)))
      (DOLIST (CALLEE FUNCTION-SPECS)
	(SI:MAP-OVER-CALLERS
	  CALLEE
	  (LAMBDA (CALLER HOW)
	    (LET ((ASSOC (ASSOC CALLER CALLERS-LIST)))
	      (WHEN (NULL ASSOC)
		(LET* ((SOURCE-FILE-NAME (GET-SOURCE-FILE-NAME-THAT-WORKS CALLER))
		       (SOURCE-FILE-NAME-STRING (STRING SOURCE-FILE-NAME)))
		  ;; cache this information instead of using
		  ;; editor-source-file-name-lessp, which is a lot slower.
		  (PUSH (SETQ ASSOC (LIST* CALLER
					   SOURCE-FILE-NAME SOURCE-FILE-NAME-STRING
					   NIL))	;the cdddr
			CALLERS-LIST))
		(INCF NCALLERS))
	      (PUSH (LIST HOW CALLEE) (CDDDR ASSOC))))
	  :CALLED-HOW CALLED-HOW
	  :ELIMINATE-DUPLICATES NIL
	  :FILTER (IF (NULL IN-SYSTEM)
		      (IF (NULL IN-PACKAGE) NIL #'THING-IN-PACKAGE)
		    #'THING-IN-SYSTEM))))
    (WHEN *CANONICALIZE-INTERNAL-FUNCTION-SPECS*
      (LABELS ((UNINTERNALIZE-FSPEC (FSPEC)
		 (IF (AND (LISTP FSPEC) (EQ (FIRST FSPEC) :INTERNAL))
		     (UNINTERNALIZE-FSPEC (SECOND FSPEC))
		   FSPEC)))
	(LOOP FOR CALLER IN CALLERS-LIST
	      AS FSPEC = (FIRST CALLER)
	      DOING
	  (WHEN (AND (LISTP FSPEC) (EQ (FIRST FSPEC) :INTERNAL))
	    (SETF (FIRST CALLER) (UNINTERNALIZE-FSPEC FSPEC)))))
      (SETQ CALLERS-LIST (SI:ELIMINATE-DUPLICATES
			   CALLERS-LIST (LAMBDA (X Y)
					  (EQUAL (FIRST X) (FIRST Y)))))
      (SETQ NCALLERS (LENGTH CALLERS-LIST)))
    (UNLESS (ZEROP NCALLERS)
      (TYPEIN-LINE "There ~:[is~;are~] ~D caller~:P of " ( NCALLERS 1) NCALLERS)
      (IF INTERSECT-FUNCTION-SPECS
	  (PRINT-LIST-WITH-AND *TYPEIN-WINDOW* FUNCTION-SPECS)
	(PRINT-LIST-WITH-OR *TYPEIN-WINDOW* FUNCTION-SPECS)))
    CALLERS-LIST))

(DEFFLAVOR CALLER-SUBNODE (CALLS) (FUNCTION-SPEC-SUBNODE)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:DESCRIPTION CALLER-SUBNODE) (STREAM)
  (DECLARE (SPECIAL SI:*WHO-CALLS-HOW-ALIST*))	; Forward reference: Utilities
  (PRESENT-YOUR-FUNCTION-SPEC SELF STREAM)
  (LOOP FOR CLS ON CALLS
	WITH COMMA-P = NIL
	WHEN COMMA-P DO (PRINC "," STREAM) (AND (NULL (CDR CLS)) (PRINC " and" STREAM))
	ELSE DO (SETQ COMMA-P T)
	DO (FORMAT STREAM (OR (CADR (ASSQ (CAAR CLS) SI:*WHO-CALLS-HOW-ALIST*))
			      " uses ~S in an unknown way")
		   (CADAR CLS)))
  (PRINC "." STREAM))

(DEFMETHOD (:SELECT-POSSIBILITY CALLER-SUBNODE :BEFORE) ()
  (TYPEIN-LINE "")
  (SEND SELF ':DESCRIPTION *TYPEIN-WINDOW*)
  (SEND *TYPEIN-WINDOW* ':TYPEOUT-STAYS))

(DEFFLAVOR INSTANCE-VARIABLE-ACCESSOR-CALLER-SUBNODE ()
	   (INSTANCE-VARIABLE-ACCESSOR-SUBNODE CALLER-SUBNODE))

(SCL:DEFINE-PRESENTATION-TYPE EDIT-FUNCTION-LIST ()
   :PRINTER ((OBJECT STREAM)
	     (FORMAT STREAM "(~D of them)" (LENGTH OBJECT)))
   :DESCRIPTION "Edit function list")

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR EDIT-FUNCTION-LIST
    (EDIT-FUNCTION-LIST "Edit definitions"
			*STANDARD-COMTAB*
			:GESTURE :SELECT)
    (POSSIBILITIES)
  `(EDIT-FUNCTION-LIST ,POSSIBILITIES))

(DEFUN EDIT-FUNCTION-LIST (FUNCTION-LIST)
  (PUSH-POSSIBILITIES-BUFFER :START-EDITING :RANDOM-FUNCTION-SPECS
			     :SET-FUNCTION-SPECS FUNCTION-LIST)
  (SEND TERMINAL-IO :MAKE-COMPLETE))

(DEFVAR *FAST-LIST-CALLERS* NIL)
(DEFUN FAST-LIST-CALLERS (FUNCTIONS INTERSECT-FUNCTIONS
			  CALLED-HOW IN-PACKAGE IN-SYSTEM)
  (LET* ((LIST (REVERT-CALLERS-OF-FUNCTIONS-EDITING-BUFFER
		FUNCTIONS INTERSECT-FUNCTIONS CALLED-HOW IN-PACKAGE IN-SYSTEM))
	 (CALLERS (LOOP FOR (FSPEC NIL NIL . CALLS)
			    IN (SORT LIST (LAMBDA (X Y)
					    (COND ((EQ (SECOND X) (SECOND Y))
						   ;; Pathnames EQ, compare fspec
						   (ALPHALESSP (FIRST X) (FIRST Y)))
						  (T
						   ;; Compare string version of pathname
						   (ALPHALESSP (THIRD X) (THIRD Y))))))
			WHEN (OR (NULL INTERSECT-FUNCTIONS)
				 (CL:SUBSETP FUNCTIONS CALLS
					     :TEST #'(LAMBDA (FSPEC CALL-ITEM)
						       (EQL (SECOND CALL-ITEM) FSPEC))))
			  COLLECT FSPEC)))
    (FLET ((PRINT-FUNCTIONS (STREAM)
	     (IF INTERSECT-FUNCTIONS
		 (PRINT-LIST-WITH-AND STREAM FUNCTIONS)
	       (PRINT-LIST-WITH-OR STREAM FUNCTIONS))))
      (LET* ((NCALLERS (LENGTH CALLERS))
	     (STREAM (IF (ZEROP NCALLERS) *TYPEOUT-WINDOW* *TYPEIN-WINDOW*)))
	(WHEN (ZEROP NCALLERS)
	  (FORMAT STREAM "~&No callers of ")
	  (PRINT-FUNCTIONS STREAM))
	(UNLESS (ZEROP NCALLERS)
	  (FORMAT T "~&Callers of ")
	  (PRINT-FUNCTIONS STANDARD-OUTPUT)
	  (COND (IN-SYSTEM
		 (FORMAT T " in system ~A" IN-SYSTEM))
		(IN-PACKAGE
		 (FORMAT T " in package ~A" IN-PACKAGE)))
	  #---IGNORE
	  (LOOP FOR CALLER IN CALLERS
		DOING (FORMAT T "~&")
		      (SCL:PRESENT CALLER 'SYS:FUNCTION-SPEC))
	  #+++IGNORE
	  (SCL:FORMAT-ITEM-LIST CALLERS :PRESENTATION-TYPE 'SYS:FUNCTION-SPEC)
	  (DW:WITH-OUTPUT-AS-PRESENTATION (:TYPE 'EDIT-FUNCTION-LIST
					   :OBJECT CALLERS)
	    (FORMAT T "~&Click here or type c-. to start editing them."))
	  (SETQ *CURRENT-COMMAND-TYPE* `(FAST-LIST-CALLERS ,CALLERS)))))
    DIS-NONE))


(DEFINE-SPECIAL-BUFFER-TYPE FUNCTION-APROPOS-EDITING-BUFFER
			    (SEARCH-FUNCTION SEARCH-KEY SEARCH-STRING
			     PACKAGE-TO-SEARCH NAME-OF-PACKAGE-TO-SEARCH)
			    (FUNCTION-EDITING-SPECIAL-PURPOSE-BUFFER)
			    :FUNCTION-APROPOS "Function-Apropos"
  :SETTABLE-INSTANCE-VARIABLES
  (:BUFFER-INIT-OPTIONS :SET-SEARCH-FUNCTION :SET-SEARCH-KEY :SET-SEARCH-STRING
			:SET-PACKAGE-TO-SEARCH :SET-NAME-OF-PACKAGE-TO-SEARCH))

(DEFMETHOD (:DESCRIPTION FUNCTION-APROPOS-EDITING-BUFFER) ()
  (FORMAT NIL "~S" SEARCH-STRING))

(DEFMETHOD (:HEADER-DESCRIPTION-1 FUNCTION-APROPOS-EDITING-BUFFER) (STREAM PLURAL-P)
  (FORMAT STREAM "Function~P matching ~A" PLURAL-P SEARCH-STRING))

(DEFMETHOD (:REVERT FUNCTION-APROPOS-EDITING-BUFFER) (&AUX LIST)
  (FLET ((FUNARG (SYM)
	   (AND (FUNCALL SEARCH-FUNCTION SEARCH-KEY (STRING SYM))
		(FBOUNDP SYM)
		(PUSH SYM LIST))))
    (IF (EQ PACKAGE-TO-SEARCH PKG-GLOBAL-PACKAGE)	;Kludge
	(MAPATOMS-ALL #'FUNARG)
	(MAPATOMS #'FUNARG PACKAGE-TO-SEARCH)))
  (DOLIST (FSPEC (SORT LIST #'EDITOR-SOURCE-FILE-NAME-LESSP))
    (SEND SELF ':ADD-NODE 'FUNCTION-SPEC-SUBNODE ':FUNCTION-SPEC FSPEC)))

(DEFINE-SPECIAL-BUFFER-TYPE MATCHING-SYMBOLS-EDITING-BUFFER
			    (PREDICATE PACKAGE-TO-SEARCH NAME-OF-PACKAGE-TO-SEARCH)
			    (FUNCTION-EDITING-SPECIAL-PURPOSE-BUFFER)
			    :MATCHING-SYMBOLS "Matching-Symbols"
  :SETTABLE-INSTANCE-VARIABLES
  (:BUFFER-INIT-OPTIONS :SET-PREDICATE :SET-PACKAGE-TO-SEARCH :SET-NAME-OF-PACKAGE-TO-SEARCH))

(DEFMETHOD (:DESCRIPTION MATCHING-SYMBOLS-EDITING-BUFFER) ()
  (WITH-OUTPUT-TO-STRING (STREAM)
    (LET ((PRINLENGTH 3) (PRINLEVEL 3))
      (PRIN1 (CADR (ASSQ ':INTERPRETED-DEFINITION (DEBUGGING-INFO PREDICATE))) STREAM))))

(DEFMETHOD (:HEADER-DESCRIPTION-1 MATCHING-SYMBOLS-EDITING-BUFFER) (STREAM PLURAL-P)
  (FORMAT STREAM "Function~P satisfying " PLURAL-P)
  (LET ((PRINLENGTH 3) (PRINLEVEL 3))
    (PRIN1 (CADR (ASSQ ':INTERPRETED-DEFINITION (DEBUGGING-INFO PREDICATE))) STREAM)))

(DEFMETHOD (:REVERT MATCHING-SYMBOLS-EDITING-BUFFER) (&AUX LIST)
  (FLET ((FUNARG (SYM)
	   (AND (FUNCALL PREDICATE SYM)
		(NOT (MEMQ SYM LIST))
		(PUSH SYM LIST))))
    (IF (EQ PACKAGE-TO-SEARCH PKG-GLOBAL-PACKAGE)	;Kludge
	(MAPATOMS-ALL #'FUNARG)
	(MAPATOMS #'FUNARG PACKAGE-TO-SEARCH)))
  (DOLIST (FSPEC (SORT LIST #'EDITOR-SOURCE-FILE-NAME-LESSP))
    (SEND SELF ':ADD-NODE 'FUNCTION-SPEC-SUBNODE ':FUNCTION-SPEC FSPEC)))



;;; This function should NOT be used by any commands except when the list of
;;; FUNCTIONS came directly from the user.  It is mainly for simple editing of
;;; a set of functions generated by user code.
(DEFUN SETUP-MULTIPLE-FUNCTIONS-TO-BE-EDITED (FUNCTIONS &OPTIONAL ACTION
								  (DEFINITION-TYPE 'DEFUN)
								  (SORT-P T))
  (SETQ FUNCTIONS (CL:COPY-LIST FUNCTIONS))
  (SETQ FUNCTIONS (DEL-IF #'(LAMBDA (X) (AND (LISTP X) (EQ (CAR X) ':PROPERTY)
					   (EQ (CADDR X) ':PREVIOUS-DEFINITION)))
			FUNCTIONS))
  (WHEN SORT-P
    (SETQ FUNCTIONS (SORT FUNCTIONS #'EDITOR-SOURCE-FILE-NAME-LESSP)))
  (PUSH-POSSIBILITIES-BUFFER ACTION ':RANDOM-FUNCTION-SPECS ':SET-FUNCTION-SPECS FUNCTIONS
			     :SET-DEFINITION-TYPE DEFINITION-TYPE))

(DEFUN EDITOR-SOURCE-FILE-NAME-LESSP (X Y)
  (LET ((XNAME (SI:GET-SOURCE-FILE-NAME X))
	(YNAME (SI:GET-SOURCE-FILE-NAME Y)))
    (AND (EQ XNAME YNAME) (SETQ XNAME X YNAME Y))
    (OR (SYMBOLP XNAME) (TYPEP XNAME 'FS:PATHNAME)
	(SETQ XNAME ""))
    (OR (SYMBOLP YNAME) (TYPEP YNAME 'FS:PATHNAME)
	(SETQ YNAME ""))
    (STRING-LESSP XNAME YNAME)))



;;; Edit/List callers

;;; Common documentation function for the many permutations of Callers commands
(DEFUN DOC-CALLERS-COMMAND (COMMAND IGNORE TYPE)
  (LET ((NAME (GET COMMAND 'COMMAND-NAME)))
    (SELECTQ TYPE
      (:NAME NAME)
      ((:FULL :SHORT)
       (LET ((ACTION (IF (STRING-SEARCH "list" NAME) :LIST :EDIT))
	     (COMBINATION (COND ((STRING-SEARCH "intersection" NAME) :INTERSECTION)
				((STRING-SEARCH "multiple" NAME) :MULTIPLE)	;keep in order
				(T NIL)))
	     (FILTER (COND ((STRING-SEARCH "package" NAME) :PACKAGE)
			   ((STRING-SEARCH "system" NAME) :SYSTEM)
			   (T NIL))))
	 (FORMAT STANDARD-OUTPUT
		 "~:[Prepares for editing~;Lists~] all functions ~
                  ~[in the specified package ~;in the specified system ~]~
                  that call ~[all of ~;any of ~]the specified function~:[~;s~]."
		 (EQL ACTION :LIST)
		 (CL:CASE FILTER (:PACKAGE 0) (:SYSTEM 1) (OTHERWISE 2))
		 (CL:CASE COMBINATION (:INTERSECTION 0) (:MULTIPLE 1) (OTHERWISE 2))
		 COMBINATION)
	 (WHEN (EQ TYPE ':FULL)
	   (FORMAT STANDARD-OUTPUT
		   "~%(See also the possibilities listed by D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")HELP A callers0.)~@
                    It reads a function name from the minibuffer, with completion.~@
                    ~:[~;It continues prompting for a function name until you end it ~
                    with just a carriage return.~%~]~
                    With a numeric argument, it next prompts for how the ~
                    function~:[ is~;s are~]~@
                    called (e.g., function, flavor, condition).~@
                    ~:[~;It then prompts for a ~[package~;system~] name, ~
                    defaulting to the current ~:*~[package~;system~].~]"
		   COMBINATION COMBINATION FILTER
		   (CL:CASE FILTER (:PACKAGE 0) (:SYSTEM 1) (OTHERWISE 2)))))))))

(DEFCOM COM-EDIT-CALLERS DOC-CALLERS-COMMAND ()
  (WHO-CALLS-INTERNAL "Edit" ':START-EDITING *NUMERIC-ARG-P*))

(DEFCOM COM-LIST-CALLERS DOC-CALLERS-COMMAND ()
  (WHO-CALLS-INTERNAL "List" ':LIST-POSSIBILITIES *NUMERIC-ARG-P*))

(DEFCOM COM-MULTIPLE-EDIT-CALLERS DOC-CALLERS-COMMAND ()
  (MULTIPLE-WHO-CALLS-INTERNAL "Edit" ':START-EDITING *NUMERIC-ARG-P*))

(DEFCOM COM-MULTIPLE-LIST-CALLERS DOC-CALLERS-COMMAND ()
  (MULTIPLE-WHO-CALLS-INTERNAL "List" ':LIST-POSSIBILITIES *NUMERIC-ARG-P*))

(DEFCOM COM-MULTIPLE-EDIT-CALLERS-INTERSECTION DOC-CALLERS-COMMAND ()
  (WHO-CALLS-ALL-OF-INTERNAL "Edit" ':START-EDITING *NUMERIC-ARG-P*))

(DEFCOM COM-MULTIPLE-LIST-CALLERS-INTERSECTION DOC-CALLERS-COMMAND ()
  (WHO-CALLS-ALL-OF-INTERNAL "List" ':LIST-POSSIBILITIES *NUMERIC-ARG-P*))

(DEFCOM COM-EDIT-CALLERS-IN-PACKAGE DOC-CALLERS-COMMAND ()
  (WHO-CALLS-INTERNAL "Edit" ':START-EDITING *NUMERIC-ARG-P* NIL :PACKAGE))

(DEFCOM COM-LIST-CALLERS-IN-PACKAGE DOC-CALLERS-COMMAND ()
  (WHO-CALLS-INTERNAL "List" ':LIST-POSSIBILITIES *NUMERIC-ARG-P* NIL :PACKAGE))

(DEFCOM COM-MULTIPLE-EDIT-CALLERS-IN-PACKAGE DOC-CALLERS-COMMAND ()
  (MULTIPLE-WHO-CALLS-INTERNAL "Edit" ':START-EDITING *NUMERIC-ARG-P* :PACKAGE))

(DEFCOM COM-MULTIPLE-LIST-CALLERS-IN-PACKAGE DOC-CALLERS-COMMAND ()
  (MULTIPLE-WHO-CALLS-INTERNAL "List" ':LIST-POSSIBILITIES *NUMERIC-ARG-P* :PACKAGE))

(DEFCOM COM-MULTIPLE-EDIT-CALLERS-INTERSECTION-IN-PACKAGE DOC-CALLERS-COMMAND ()
  (WHO-CALLS-ALL-OF-INTERNAL "Edit" ':START-EDITING *NUMERIC-ARG-P* :PACKAGE))

(DEFCOM COM-MULTIPLE-LIST-CALLERS-INTERSECTION-IN-PACKAGE DOC-CALLERS-COMMAND ()
  (WHO-CALLS-ALL-OF-INTERNAL "List" ':LIST-POSSIBILITIES *NUMERIC-ARG-P* :PACKAGE))

(DEFCOM COM-EDIT-CALLERS-IN-SYSTEM DOC-CALLERS-COMMAND ()
  (WHO-CALLS-INTERNAL "Edit" ':START-EDITING *NUMERIC-ARG-P* NIL :SYSTEM))

(DEFCOM COM-LIST-CALLERS-IN-SYSTEM DOC-CALLERS-COMMAND ()
  (WHO-CALLS-INTERNAL "List" ':LIST-POSSIBILITIES *NUMERIC-ARG-P* NIL :SYSTEM))

(DEFCOM COM-MULTIPLE-EDIT-CALLERS-IN-SYSTEM DOC-CALLERS-COMMAND ()
  (MULTIPLE-WHO-CALLS-INTERNAL "Edit" ':START-EDITING *NUMERIC-ARG-P* :SYSTEM))

(DEFCOM COM-MULTIPLE-LIST-CALLERS-IN-SYSTEM DOC-CALLERS-COMMAND ()
  (MULTIPLE-WHO-CALLS-INTERNAL "List" ':LIST-POSSIBILITIES *NUMERIC-ARG-P* :SYSTEM))

(DEFCOM COM-MULTIPLE-EDIT-CALLERS-INTERSECTION-IN-SYSTEM DOC-CALLERS-COMMAND ()
  (WHO-CALLS-ALL-OF-INTERNAL "Edit" ':START-EDITING *NUMERIC-ARG-P* :SYSTEM))

(DEFCOM COM-MULTIPLE-LIST-CALLERS-INTERSECTION-IN-SYSTEM DOC-CALLERS-COMMAND ()
  (WHO-CALLS-ALL-OF-INTERNAL "List" ':LIST-POSSIBILITIES *NUMERIC-ARG-P* :SYSTEM))

(DEFUN CHECK-WHO-CALLS-MODE ()
  (TAGBODY
    AGAIN
    (CL:ECASE SI:*WHO-CALLS-MODE*
      (:MAKING
	(TYPEIN-LINE "Some process is making the who-calls database.  Wait or c-Abort.")
	(PROCESS-WAIT "who-calls database"
	  (LAMBDA () (NEQ SI:*WHO-CALLS-MODE* :MAKING)))
	(GO AGAIN))
      ((:DISABLED :UNINITIALIZED)
	(BARF "who-calls database is disabled"))
      ((:ALL :NEW :EXPLICIT)))))

(DEFUN WHO-CALLS-MODE-DESCRIPTION ()
  (CL:ECASE SI:*WHO-CALLS-MODE*
    (:ALL "all callers")
    (:NEW "non-system callers")
    (:EXPLICIT "explicitly recorded callers")))

(DECLARE (SPECIAL SI:*WHO-CALLS-HOW-ALIST*))	; Forward reference: Utilities
(SCL:DEFINE-PRESENTATION-TYPE WHO-CALLS-HOW-CALLED ()
   :DESCRIPTION "a description of how a thing is called"
   :ABBREVIATION-FOR `((SCL:NULL-OR-TYPE
			 ((CL:MEMBER ,@(LOOP FOR (HOW) IN SI:*WHO-CALLS-HOW-ALIST*
					     WHEN HOW
					       COLLECT HOW))))))
   
(DEFUN GET-CALLED-HOW-FOR-WHO-CALLS ()
  (TYPEIN-LINE-ACCEPT 'WHO-CALLS-HOW-CALLED
		      :DEFAULT NIL
		      :PROMPT "Find callers which are called how"))

(DEFUN GET-PACKAGE-FOR-WHO-CALLS ()
  (TYPEIN-LINE-ACCEPT 'CL:PACKAGE
		      :DEFAULT PACKAGE
		      :PROMPT "Find callers which are in package"))

(DEFUN GET-SYSTEM-FOR-WHO-CALLS ()
  (TYPEIN-LINE-ACCEPT '((OR SCT:SUBSYSTEM SCT:SYSTEM))
		      :DEFAULT (SYSTEM-FOR-BUFFER *INTERVAL*)
		      :PROMPT "Find callers which are in system"))

(DEFUN WHO-CALLS-FILTER-DESCRIPTION (FILTER)
  (CL:CASE FILTER
    (:PACKAGE "in package")
    (:SYSTEM "in system")
    (OTHERWISE NIL))) 

(DEFUN WHO-CALLS-INTERNAL (PROMPT ACTION &OPTIONAL GET-HOW MUST-BE-DEFINED-FLAG FILTER)
  (CHECK-WHO-CALLS-MODE)
  (LET* ((FUNCTION (READ-FUNCTION-SPEC
		     (FORMAT NIL "~A ~A ~@[~A ~]of" PROMPT (WHO-CALLS-MODE-DESCRIPTION)
			     (WHO-CALLS-FILTER-DESCRIPTION FILTER))
		     (RELEVANT-FUNCTION-NAME (POINT) NIL NIL T T)
		     MUST-BE-DEFINED-FLAG)))
    (WHO-CALLS-INTERNAL-1 ACTION FUNCTION GET-HOW FILTER)))

;;; This entry point is for mouse-click-handlers that already know the function.
(DEFUN WHO-CALLS-INTERNAL-1 (ACTION FUNCTION &OPTIONAL GET-HOW FILTER)
  #+3600 (DECLARE (SPECIAL SI:*MICROCODED-FUNCTIONS-NOT-FOR-WHO-CALLS*))
  (FLET ((BY-THE-WAY (FUNCTION IS-A &OPTIONAL WHICH-ETC)
	   (TYPEIN-LINE
	     "By the way, ~S is a ~A~@[~A~]; there may be other /"callers/" of it."
	     FUNCTION IS-A WHICH-ETC)))
    (COND ((LET ((IS-A (OR (AND (SI:MACRO-FUNCTION FUNCTION) "macro")
			   (AND (LT:FUNCTION-INLINE-FORM-METHOD FUNCTION)
				"subst"))))
	     (WHEN IS-A
	       (BY-THE-WAY FUNCTION IS-A (IF (ASSQ 'COMPILER:DO-NOT-RECORD-MACROEXPANSIONS
						   (DEBUGGING-INFO FUNCTION))
					     " which is not recorded as a caller"))
	       T)))
	  ((SI:SPECIAL-FORM-P FUNCTION)
	   (BY-THE-WAY FUNCTION "special form"))
#+3600	  ((MEMQ FUNCTION SI:*MICROCODED-FUNCTIONS-NOT-FOR-WHO-CALLS*)
	   (BY-THE-WAY FUNCTION "microcoded function"
		       " which is not recorded as a caller"))
	  ((AND (SYMBOLP FUNCTION)
		(GET FUNCTION 'DEFCONSTANT)
		(GET FUNCTION 'COMPILER:DO-NOT-RECORD-OPEN-CODING))
	   (BY-THE-WAY FUNCTION "constant" " which is not recorded as a caller"))))
  (LET ((CALLED-HOW (WHEN GET-HOW
		      (GET-CALLED-HOW-FOR-WHO-CALLS)))
	;; Either IN-SYSTEM or IN-PACKAGE, but not both
	(IN-PACKAGE (WHEN (EQ FILTER :PACKAGE)
		      (GET-PACKAGE-FOR-WHO-CALLS)))
	(IN-SYSTEM (WHEN (EQ FILTER :SYSTEM)
		      (GET-SYSTEM-FOR-WHO-CALLS))))
    (IF (AND *FAST-LIST-CALLERS*
	     (EQ ACTION :LIST-POSSIBILITIES))
	(FAST-LIST-CALLERS
	  (NCONS FUNCTION) NIL CALLED-HOW IN-PACKAGE IN-SYSTEM)
      (PUSH-POSSIBILITIES-BUFFER ACTION ':CALLERS-OF-FUNCTIONS
				 ':SET-FUNCTION-SPECS (NCONS FUNCTION)
				 ':SET-CALLED-HOW CALLED-HOW
				 ':SET-IN-PACKAGE IN-PACKAGE
				 ':SET-IN-SYSTEM IN-SYSTEM))))

(DEFUN MULTIPLE-WHO-CALLS-INTERNAL (PROMPT ACTION &OPTIONAL GET-HOW FILTER)
  (CHECK-WHO-CALLS-MODE)
  (LOOP AS FUNCTION FIRST (TYPEIN-LINE-ACCEPT 'SYS:FUNCTION-SPEC
					      :PROMPT
					      (FORMAT NIL "~A ~A ~@[~A ~]of"
						      PROMPT (WHO-CALLS-MODE-DESCRIPTION)
						      (WHO-CALLS-FILTER-DESCRIPTION FILTER))
					      :DEFAULT
					      (RELEVANT-FUNCTION-NAME (POINT) NIL NIL T T))
		    THEN (TYPEIN-LINE-ACCEPT '((DW::TOKEN-OR-TYPE ("") SYS:FUNCTION-SPEC))
					     :DEFAULT "" :PROMPT-MODE :RAW
					     :PROMPT (FORMAT
						       NIL
					       "~A ~A ~@[~A ~]of (Return if no more callees)"
						       PROMPT
						       (WHO-CALLS-MODE-DESCRIPTION)
						       (WHO-CALLS-FILTER-DESCRIPTION FILTER)))
	WHEN (EQUAL FUNCTION "")
	  DO (LET ((CALLED-HOW (WHEN GET-HOW
				 (GET-CALLED-HOW-FOR-WHO-CALLS)))
		   ;; Either IN-SYSTEM or IN-PACKAGE, but not both
		   (IN-PACKAGE (WHEN (EQ FILTER :PACKAGE)
				 (GET-PACKAGE-FOR-WHO-CALLS)))
		   (IN-SYSTEM (WHEN (EQ FILTER :SYSTEM)
				(GET-SYSTEM-FOR-WHO-CALLS))))
	       (IF (AND *FAST-LIST-CALLERS*
			(EQ ACTION :LIST-POSSIBILITIES))
		   (RETURN (FAST-LIST-CALLERS
			     FUNCTIONS NIL CALLED-HOW IN-PACKAGE IN-SYSTEM))
		 (RETURN (PUSH-POSSIBILITIES-BUFFER ACTION ':CALLERS-OF-FUNCTIONS
						    ':SET-FUNCTION-SPECS FUNCTIONS
						    ':SET-CALLED-HOW CALLED-HOW
						    ':SET-IN-PACKAGE IN-PACKAGE
						    ':SET-IN-SYSTEM IN-SYSTEM))))
	UNLESS (MEMBER FUNCTION FUNCTIONS)
	  COLLECT FUNCTION INTO FUNCTIONS))

(DEFUN WHO-CALLS-ALL-OF-INTERNAL (PROMPT ACTION &OPTIONAL GET-HOW FILTER)
  (CHECK-WHO-CALLS-MODE)
  (LOOP AS FUNCTION FIRST (TYPEIN-LINE-ACCEPT 'SYS:FUNCTION-SPEC
					      :PROMPT
					      (FORMAT NIL "~A ~A ~@[~A ~]of"
						      PROMPT (WHO-CALLS-MODE-DESCRIPTION)
						      (WHO-CALLS-FILTER-DESCRIPTION FILTER))
					      :DEFAULT
					      (RELEVANT-FUNCTION-NAME (POINT) NIL NIL T T))
		    THEN (TYPEIN-LINE-ACCEPT '((DW::TOKEN-OR-TYPE ("") SYS:FUNCTION-SPEC))
					     :DEFAULT "" :PROMPT-MODE :RAW
					     :PROMPT (FORMAT
						       NIL
						"~A ~A ~@[~A ~]of (Return if no more callees)"
						       PROMPT
						       (WHO-CALLS-MODE-DESCRIPTION)
						       (WHO-CALLS-FILTER-DESCRIPTION FILTER)))
	WHEN (EQUAL FUNCTION "")
	  DO (LET ((CALLED-HOW (WHEN GET-HOW
				 (GET-CALLED-HOW-FOR-WHO-CALLS)))
		   ;; Either IN-SYSTEM or IN-PACKAGE, but not both
		   (IN-PACKAGE (WHEN (EQ FILTER :PACKAGE)
				 (GET-PACKAGE-FOR-WHO-CALLS)))
		   (IN-SYSTEM (WHEN (EQ FILTER :SYSTEM)
				(GET-SYSTEM-FOR-WHO-CALLS))))
	       (IF (AND *FAST-LIST-CALLERS*
			(EQ ACTION :LIST-POSSIBILITIES))
		   (RETURN (FAST-LIST-CALLERS
			     FUNCTIONS T CALLED-HOW IN-PACKAGE IN-SYSTEM))
		 (RETURN (PUSH-POSSIBILITIES-BUFFER ACTION ':CALLERS-OF-FUNCTIONS
						    ':SET-INTERSECT-FUNCTION-SPECS T
						    ':SET-FUNCTION-SPECS FUNCTIONS
						    ':SET-CALLED-HOW CALLED-HOW
						    ':SET-IN-PACKAGE IN-PACKAGE
						    ':SET-IN-SYSTEM IN-SYSTEM))))
	UNLESS (MEMBER FUNCTION FUNCTIONS)
	  COLLECT FUNCTION INTO FUNCTIONS))


;;; Get a package and the name of it to go in the prompt string,
;;; based on numeric argument.
(DEFUN GET-PACKAGE-TO-SEARCH ()
  (LET ((PKG (COND ((< *NUMERIC-ARG* 4) PACKAGE)
		   ((< *NUMERIC-ARG* 16.) PKG-GLOBAL-PACKAGE)
		   (T (READ-PACKAGE-FROM-MINI-BUFFER
			(FORMAT NIL "Package to search" PACKAGE) PACKAGE)))))
    (VALUES PKG (IF (= *NUMERIC-ARG* 4) "all packages" (FORMAT NIL "package ~A" PKG)))))

(DEFUN READ-PACKAGE-FROM-MINI-BUFFER (PROMPT DEFAULT &OPTIONAL IMPOSSIBLE-IS-OK)
  ;--- This used to check the syntax and only off completion when not in common lisp.
  (LET ((PKG (TYPEIN-LINE-ACCEPT (IF IMPOSSIBLE-IS-OK
				     `((DW::TYPE-OR-STRING CL:PACKAGE))
				     'CL:PACKAGE)
				 :PROMPT PROMPT :DEFAULT DEFAULT)))
    (IF (STRINGP PKG) 
	;; If IMPOSSIBLE-IS-OK and a string that is not the name of a package
	;; is typed, convert it to upper-case since Common Lisp says that case
	;; matters in package names.  If our caller creates a package, we want
	;; the package's name to be in upper case.
	(STRING-UPCASE PKG)
	PKG)))

(DEFCOM COM-FUNCTION-APROPOS
	"Lists the Lisp functions containing a string as a substring.
By default, it searches the current package.  You can control the package
being searched by giving the function an argument.  With c-U, it searches all
packages; with c-U c-U, it prompts for a package name.  " ()
  (MULTIPLE-VALUE-BIND (PKG PKG-NAME) (GET-PACKAGE-TO-SEARCH)
    (MULTIPLE-VALUE-BIND (FUNCTION KEY STR)
       (GET-EXTENDED-SEARCH-STRINGS
	 (FORMAT NIL "List functions in ~A containing substring:" PKG-NAME))
      (PUSH-POSSIBILITIES-BUFFER ':LIST-POSSIBILITIES ':FUNCTION-APROPOS
				 ':SET-SEARCH-FUNCTION FUNCTION
				 ':SET-SEARCH-KEY KEY
				 ':SET-SEARCH-STRING STR
				 ':SET-PACKAGE-TO-SEARCH PKG
				 ':SET-NAME-OF-PACKAGE-TO-SEARCH PKG-NAME)))
  DIS-NONE)

(DEFCOM COM-LIST-MATCHING-SYMBOLS
	"Lists the symbols that match a predicate.
It prompts for a predicate lambda expression.  By default, it searches the
current package.  You can control the package being searched by giving the
function an argument.  With c-U, it searches all packages; with c-U c-U, it
prompts for a package name.  " ()
  (MULTIPLE-VALUE-BIND (PKG PKG-NAME) (GET-PACKAGE-TO-SEARCH)
    (LET ((FUNCTION (TYPEIN-LINE-ACCEPT 'SYS:FORM
					:INITIAL-INPUT "(LAMBDA (SYMBOL) )"
					:INITIAL-POSITION 17.
					:PROVIDE-DEFAULT NIL
					:PROMPT (FORMAT NIL "List symbols in ~A satisfying"
							PKG-NAME)))
	  (SYMBOL (GENSYM)))
      (FSET SYMBOL FUNCTION)
      (COMPILE SYMBOL)
      (PUSH-POSSIBILITIES-BUFFER ':LIST-POSSIBILITIES ':MATCHING-SYMBOLS
				 ':SET-PACKAGE-TO-SEARCH PKG
				 ':SET-NAME-OF-PACKAGE-TO-SEARCH PKG-NAME
				 ':SET-PREDICATE SYMBOL)))
  DIS-NONE)

(DEFVAR *FUNCTION-SPECS-TO-HEURISTICATE*
	'(("(DEFMETHOD" 10. FLAVOR:METHOD)
	  ("(DEFWRAPPER" 11. FLAVOR:WRAPPER)
	  ("(DEFWHOPPER-SUBST" 17. FLAVOR:WRAPPER)
	  ("(DEFWHOPPER" 11. FLAVOR:NCWHOPPER)
	  ("(DEFUN-IN-FLAVOR" 16. FLAVOR:DEFUN-IN-FLAVOR)
	  ("(DEFSUBST-IN-FLAVOR" 19. FLAVOR:DEFUN-IN-FLAVOR)
	  ("(DEFMACRO-IN-FLAVOR" 19. FLAVOR:DEFUN-IN-FLAVOR)))

;;; Given a string, return a function-spec.  LINE is the line we got it from and used
;;; to disambiguate some cases of (FOO :BAR).
(DEFUN SYMBOL-FROM-STRING (STR &OPTIONAL LINE OK-TO-ASK SIGNAL-P &AUX SYM ERROR-P COUNT)
  (DECLARE (VALUES SYM ERROR-P))
  (COND ((ARRAYP STR)				;try read only if it is a string
	 (SETQ STR (SI:STRING-TRIM-WHITESPACE STR))
	 ;;Most callers of symbol-from-string are looking for an error object to be
	 ;;returned but Sage would rather have the error signalled, hence the conditional.
	 (CONDITION-CASE-IF (NOT SIGNAL-P) (ERROR)
	     (MULTIPLE-VALUE (SYM COUNT)
	       (LET ((SI:*SUPPRESS-READ-EVAL* T))
		 (READ-FROM-STRING STR)))
	   (SYS:READ-ERROR			;when signal-p, gets signalled instead
	     (SETQ ERROR-P ERROR)))		;of coming through here.
	 ;;Maybe no error from read-from-string; Be sure it read the whole string though
	 (WHEN (AND (NOT ERROR-P) (> (STRING-LENGTH STR) COUNT))	;when no read error
	   (LET ((ERROR-OBJECT (MAKE-CONDITION 'SYS:READ-PREMATURE-END-OF-SYMBOL
					       ':SHORT-SYMBOL SYM ':ORIGINAL-STRING STR)))
	     (IF SIGNAL-P
		 (SIGNAL ERROR-OBJECT)		;signal a "premature end" error
		 (SETQ ERROR-P ERROR-OBJECT)))))	;read fact of premature end
	(T (SETQ SYM STR)))
  (COND (ERROR-P
	 (VALUES NIL ERROR-P))
	((SYMBOLP SYM)
	 SYM)
	((AND (INSTANCEP SYM)
	      (SI:VALIDATE-FUNCTION-SPEC SYM))
	 SYM)
	((NLISTP SYM)
	 (VALUES NIL T))
	((OR (NOT (SYMBOLP (CAR SYM)))		;car of list must be a symbol [---may change]
	     (NOT (LOOP FOR LIST ON SYM		;list must not be dotted
			NEVER (ATOM LIST))))
	 (VALUES NIL T))
	(T
	 ;; Here SYM is a list.  Certain types of function specs have two ways to
	 ;; type them, with and without the leading type keyword.  What we do here is to
	 ;; recognize and standardize those cases.
	 ;;   The variables are:
	 ;;	TYPE - the type of function spec or non-function definition
	 ;;	SYM - the function spec or definition name
	 ;;	SPEC - the variant of SYM which appears in the source code
	 ;;	STR - the original string, the printed representation of the original SPEC
	 ;; :HANDLER doesn't appear in source files, but gets translated into
	 ;; an appropriate method's function spec here, by analyzing the combined method.
	 ;; :INTERNAL doesn't appear in source files, but might be given as the argument
	 ;; to M-X Disassemble.  The code here just tries not to destroy it.
	 (BLOCK DECIDE
	   (LET ((TYPE (CAR SYM))
		 (SPEC (CDR SYM)))
	     (WHEN (AND (SYMBOLP TYPE) (GET TYPE 'SYS:FUNCTION-SPEC-HANDLER))
	       ;; Function spec type is known, but package & method dwim may be needed
	       ;; to get the real SYM from the SYM that was specified.
	       (WHEN OK-TO-ASK
		 (SETQ SYM (OR (SELECTQ TYPE
				 ((FLAVOR:METHOD FLAVOR:WRAPPER FLAVOR:NCWHOPPER
						 CLOS:METHOD)
				  (UNLESS (METHOD-KNOWN-P SPEC TYPE)
				    (DWIM-METHOD-SPEC SPEC TYPE)))
				 ((:HANDLER)
				  (WHEN (AND (= (LENGTH SPEC) 2) (SYMBOLP (FIRST SPEC)))
				    (DWIM-METHOD-FROM-HANDLER SYM)))
				 ((:PROPERTY)
				  (WHEN (AND (= (LENGTH SPEC) 2) (CL:EVERY #'SYMBOLP SPEC))
				    (UNLESS (GET (FIRST SPEC) (SECOND SPEC))
				      (DWIM-PROPERTY-SPEC (FIRST SPEC) (SECOND SPEC))))))
			       SYM)))
	       (RETURN-FROM DECIDE))
	     ;; No function spec type was specified, try to guess one
	     (WHEN LINE
	       (LOOP FOR (NAME LENGTH TYPE) IN *FUNCTION-SPECS-TO-HEURISTICATE* DO
		 (WHEN (AND (%STRING-EQUAL LINE 0 NAME 0 LENGTH)
			    (OR (= (LINE-LENGTH LINE) LENGTH)
				( (LIST-SYNTAX (AREF LINE LENGTH)) LIST-ALPHABETIC)))
		   ;; Recognize function spec defined by special form
		   (SETQ SYM (CONS TYPE SYM))
		   (RETURN-FROM DECIDE)))
	       ;; Special form not recognized, guess that it's just a property
	       (SETQ SYM (CONS ':PROPERTY SYM))
	       (RETURN-FROM DECIDE))
	     ;; Neither type nor line specified, heuristicate method or property
	     (SETQ SYM (COND ((METHOD-KNOWN-P SYM NIL))
			     (T
			      (LET ((MAYBE-PROPERTY (AND (= (LENGTH SYM) 2)
							 (CL:EVERY #'SYMBOLP SYM))))
				(OR (AND MAYBE-PROPERTY (GET (FIRST SYM) (SECOND SYM))
					 (CONS ':PROPERTY SYM))
				    (IF OK-TO-ASK
					(OR (DWIM-METHOD-SPEC SYM NIL)
					    (AND MAYBE-PROPERTY
						 (DWIM-PROPERTY-SPEC (FIRST SYM)
								     (SECOND SYM))))
					;; Use undefined method hash table if string did not
					;; come from user.  May be file not yet compiled.
					(LET ((POSSIBLE-FLAVOR (SECOND SYM)))
					  (IF (CL:LISTP POSSIBLE-FLAVOR)
					      (CONS 'CLOS:METHOD SYM)
					      (AND (SYMBOLP POSSIBLE-FLAVOR)
						   (NOT (NULL POSSIBLE-FLAVOR))
						   (FLAVOR:FIND-FLAVOR POSSIBLE-FLAVOR NIL)
						   (CONS 'FLAVOR:METHOD SYM)))))
				    ;; Something we don't understand and can't turn into
				    ;; a valid function spec.  Make a bogus symbol to use as
				    ;; a property list to remember the location of this
				    ;; definition.
				    (IF OK-TO-ASK
					(BARF "Invalid function spec: ~S" SYM)
					(INTERN STR *UTILITY-PACKAGE*)))))))))
	 ;; End of block named DECIDE
	 ;; SYM is now our best guess at a valid function spec.
	 ;; If it will work to record information on that function spec,
	 ;; use it.  Otherwise, return an error.  Don't make a bogus symbol, for
	 ;; whatever reason, I'm just copying what the old code did.---
	 (IF (SYS:VALIDATE-FUNCTION-SPEC SYM) SYM (VALUES NIL T)))))

;--- Should be an interface exported by the flavor system?
;--- Modularity here is still in doubt
(DEFUN METHOD-KNOWN-P (SPEC TYPE)
  (IF TYPE
      (IF (EQ TYPE 'CLOS:METHOD)
	  (STACK-LET ((FUNCTION-SPEC `(,TYPE ,@SPEC)))
	    (AND (SYS:VALIDATE-FUNCTION-SPEC FUNCTION-SPEC)
		 (OR (AND (SYS:FDEFINEDP FUNCTION-SPEC)
			  (SYS:FUNCTION-NAME (FDEFINITION FUNCTION-SPEC)))
		     (WHEN (SI:FUNCTION-SPEC-PLIST FUNCTION-SPEC)
		       (CL:COPY-LIST FUNCTION-SPEC)))))
	  (STACK-LET ((FUNCTION-SPEC
			`(,TYPE
			  ,(FLAVOR::STANDARDIZE-GENERIC-FUNCTION-NAME (FIRST SPEC))
			  ,@(CDR SPEC))))
	    (AND (SYS:VALIDATE-FUNCTION-SPEC FUNCTION-SPEC)
		 (LET ((MH (FLAVOR::FIND-METHOD-HOLDER FUNCTION-SPEC)))
		   (AND MH (FLAVOR::METHOD-HOLDER-FUNCTION-SPEC MH))))))
      (OR (LOOP FOR TYPE IN FLAVOR:*SOURCE-CODE-METHOD-TYPES*
		THEREIS (METHOD-KNOWN-P SPEC TYPE))
	  (METHOD-KNOWN-P SPEC 'CLOS:METHOD))))

;--- Should definitely be an interface exported by flavor system
;--- The name of this function is extremely poor
(DEFUN FLAVOR-LOCAL-METHODS-FOR-GENERIC (FLAVOR GENERIC &KEY (ERROR-P T) (ENV NIL))
  (LET ((FL (FLAVOR:FIND-FLAVOR FLAVOR ERROR-P ENV)))
    (AND FL
	 (LOOP FOR MH IN (CDR (CL:ASSOC (FLAVOR::STANDARDIZE-GENERIC-FUNCTION-NAME GENERIC)
					(FLAVOR::FLAVOR-METHOD-TABLE FL)))
	       AS SPEC = (FLAVOR::METHOD-HOLDER-FUNCTION-SPEC MH)
	       WHEN (MEMQ (FLAVOR:METHOD-TYPE SPEC) FLAVOR:*SOURCE-CODE-METHOD-TYPES*)
		 COLLECT SPEC))))

;--- Should definitely be an interface exported by flavor system
;Returns the name of the handler, which might be a list or might be a symbol
(DEFUN GET-FLAVOR-HANDLER (FLAVOR GENERIC &KEY (ERROR-P T) (ENV NIL))
  (LET* ((FL (FLAVOR:FIND-FLAVOR FLAVOR ERROR-P ENV))
	 (GF (FLAVOR:FIND-GENERIC-FUNCTION GENERIC ERROR-P ENV))
	 (HANDLER (AND GF FL 
		       (WITHOUT-INTERRUPTS
			 (FLAVOR::HANDLER-TABLE-FUNCTION-AND-PARAMETER
			   FL
			   (SYS:GENERIC-FUNCTION-SELECTOR GF))))))
    (AND HANDLER (SYS:FUNCTION-NAME HANDLER))))

;--- Maybe should be optimized a bit more
;--- Maybe should be optimized a bit more
(DEFUN DWIM-METHOD-SPEC (SPEC TYPE)
  (UNLESS (OR (STACK-LET ((FUNCTION-SPEC (CONS 'FLAVOR:METHOD SPEC)))
		(SYS:VALIDATE-FUNCTION-SPEC FUNCTION-SPEC))
	      (STACK-LET ((FUNCTION-SPEC (CONS 'CLOS:METHOD SPEC)))
		(SYS:VALIDATE-FUNCTION-SPEC FUNCTION-SPEC)))
    (RETURN-FROM DWIM-METHOD-SPEC NIL))
  (LET ((GENERIC (FIRST SPEC))
	(FLAVOR (SECOND SPEC))
	(OPTIONS (CDDR SPEC))
	(GENERIC-FROM-MESSAGE NIL))
    (LABELS ((DWIM-CHECK-METHODS (GENERIC FLAVOR)
	       (OR ;; Does method of desired type exist on this flavor, either defined
		   ;; or only mentioned, e.g. by putprop of a zmacs-buffers property?
		   (STACK-LET ((SPEC `(,GENERIC ,FLAVOR ,@OPTIONS)))
		     (LET ((METHOD (METHOD-KNOWN-P SPEC TYPE)))
		       (AND METHOD 
			    (DOES-HE-MEAN-FLAVOR METHOD)
			    METHOD)))
		   ;; Does method of some other type exist?
		   (DOLIST (METHOD (FLAVOR-LOCAL-METHODS-FOR-GENERIC FLAVOR GENERIC
								     :ERROR-P NIL))
		     (WHEN (AND (OR (NULL TYPE) (EQ (FLAVOR:METHOD-TYPE METHOD) TYPE))
				(NOT (EQUAL (FLAVOR:METHOD-OPTIONS METHOD) OPTIONS))
				(DOES-HE-MEAN-FLAVOR METHOD))
		       (RETURN METHOD)))
		   ;; What about a combined method or an inherited method?
		   (LET ((HANDLER (GET-FLAVOR-HANDLER FLAVOR GENERIC :ERROR-P NIL)))
		     (IF (ATOM HANDLER)
			 (LET ((FLAVORS-SEEN '()))
			   (OR (WHEN (MEMBER HANDLER '(FLAVOR:READ-INSTANCE-VARIABLE
						       FLAVOR:WRITE-INSTANCE-VARIABLE
						       FLAVOR:LOCATE-INSTANCE-VARIABLE))
				 (BLOCK FOUND
				   (FLAVOR::MAP-OVER-INSTANCE-VARIABLES
				     #'(LAMBDA (VAR IGNORE DATUM FLAVOR)
					 (WHEN (AND (EQ DATUM GENERIC)
						    (NOT (MEMBER FLAVOR FLAVORS-SEEN)))
					   (PUSH FLAVOR FLAVORS-SEEN)
					   (WHEN (FQUERY '(:SELECT T)
							 "Do you mean instance variable ~S of flavor ~S? "
							 VAR FLAVOR)
					     (RETURN-FROM FOUND FLAVOR))))
				     FLAVOR)))
			       (AND HANDLER
				    (FQUERY '(:SELECT T) "Do you mean ~S? " HANDLER)
				    HANDLER)))
			 (AND (OR (MEMQ (FLAVOR:METHOD-TYPE HANDLER)
					'FLAVOR:(COMBINED SHARED-COMBINED))
				  (NEQ (FLAVOR:METHOD-FLAVOR HANDLER) FLAVOR))
			      (DOES-HE-MEAN-FLAVOR HANDLER)
			      (SELECTQ (FLAVOR:METHOD-TYPE HANDLER)
				(FLAVOR:COMBINED
				  (DOLIST (METHOD (GET-COMPONENT-METHODS-OF-COMBINED-METHOD
						    HANDLER))
				    (WHEN (MEMQ (FLAVOR:METHOD-TYPE METHOD)
						FLAVOR:*SOURCE-CODE-METHOD-TYPES*)
				      (WHEN (FQUERY '(:SELECT T) "Do you mean ~S? " METHOD)
					(RETURN METHOD)))))
				(FLAVOR:SHARED-COMBINED
				  (MULTIPLE-VALUE-BIND (NIL METHODS)
				      (FLAVOR:COMPOSE-HANDLER GENERIC FLAVOR)
				    (DOLIST (METHOD METHODS)
				      (WHEN (MEMQ (FLAVOR:METHOD-TYPE METHOD)
						  FLAVOR:*SOURCE-CODE-METHOD-TYPES*)
					(WHEN (FQUERY '(:SELECT T) "Do you mean ~S? " METHOD)
					  (RETURN METHOD))))))
				(OTHERWISE HANDLER)))))))
	     )
      ;; Try the specified generic and flavor names first
      (OR (IF (CL:LISTP FLAVOR)
	      (DWIM-CHECK-CLOS-METHODS GENERIC FLAVOR OPTIONS)
	      (DWIM-CHECK-METHODS GENERIC FLAVOR))
	  ;; Try mapping method name to generic name
	  (WHEN (SYMBOLP GENERIC)
	    (IF (CL:LISTP FLAVOR)
		(WHEN (SETQ GENERIC-FROM-MESSAGE
			    (GET GENERIC 'CLOS-INTERNALS::SELECTOR-GENERIC-FUNCTION))
		  (DWIM-CHECK-CLOS-METHODS
		    (CLOS:GENERIC-FUNCTION-NAME GENERIC-FROM-MESSAGE)
		    FLAVOR(2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB") options0))
		(WHEN (SETQ GENERIC-FROM-MESSAGE (GET GENERIC 'FLAVOR::COMPATIBLE-GENERIC))
		  (DWIM-CHECK-METHODS GENERIC-FROM-MESSAGE FLAVOR))))
	  ;; That didn't work, try package dwim on both the generic name and the flavor name
	  (WHEN *ENABLE-PACKAGE-DWIM*
	    (IF (CL:LISTP FLAVOR)
		(LET ((CANDIDATE-GENERICS (LOOKALIKE-CLOS-GENERIC-FUNCTION-NAMES GENERIC))
		      (CANDIDATE-SPECIALIZERS))
		  (DOLIST (SPECIALIZER FLAVOR)
		    (PUSH (IF (SYMBOLP SPECIALIZER)
			      (LOOKALIKE-CLOS-CLASS-NAMES SPECIALIZER)
			      (LIST SPECIALIZER))
			  CANDIDATE-SPECIALIZERS))
		  (DOLIST (G CANDIDATE-GENERICS)
		    (LET ((RESULT
			    (LABELS ((MAP-OVER-SPECIALIZERS (SPECIALIZERS &REST SPEC)
				       (IF SPECIALIZERS
					   (DOLIST (SPECIALIZER (CAR SPECIALIZERS))
					     (LET ((RESULT 
						     (CL:APPLY #'MAP-OVER-SPECIALIZERS
							       (CDR SPECIALIZERS)
							       SPECIALIZER
							       SPEC)))
					       (WHEN RESULT
						 (RETURN-FROM MAP-OVER-SPECIALIZERS RESULT))))
					   (UNLESS (AND (OR (EQ G GENERIC)
							    (EQ G GENERIC-FROM-MESSAGE))
							(CL:EQUAL SPEC FLAVOR))
					     (DWIM-CHECK-CLOS-METHODS G SPEC OPTIONS)))))
			      (MAP-OVER-SPECIALIZERS CANDIDATE-SPECIALIZERS))))
		      (WHEN RESULT (RETURN RESULT)))))
		(LET ((CANDIDATE-GENERICS (LOOKALIKE-GENERIC-FUNCTION-NAMES GENERIC))
		      (CANDIDATE-FLAVORS (LOOKALIKE-FLAVOR-NAMES FLAVOR)))
		  (LOOP FOR G IN CANDIDATE-GENERICS
			THEREIS (LOOP FOR F IN CANDIDATE-FLAVORS
				      UNLESS (AND (EQ F FLAVOR)
						  (OR (EQ G GENERIC)
						      (EQ G GENERIC-FROM-MESSAGE)))
					THEREIS (DWIM-CHECK-METHODS G F))))))))))

(DEFUN DWIM-CHECK-CLOS-METHODS (GENERIC SPECIALIZERS QUALIFIERS)
  (LET ((CONSIDERED-METHODS NIL))
    (MACROLET ((DO-YOU-MEAN (METHOD-SPEC)
		 `(LET ((M ,METHOD-SPEC))
		    (WHEN (AND M (FQUERY '(:SELECT T) "Do you mean ~s " M))
		      (RETURN-FROM DWIM-CHECK-CLOS-METHODS M)))))
      (LABELS ((CHECK-METHODS (METHODS SPECIALIZERS)
		 (DOLIST (METHOD METHODS)
		   (WHEN (METHOD-SATISFIES-SPECIALIZERS-P METHOD SPECIALIZERS)
		     (UNLESS (MEMBER METHOD CONSIDERED-METHODS)
		       (PUSH METHOD CONSIDERED-METHODS)
		       (DO-YOU-MEAN (CLOS-INTERNALS:FUNCTION-SPEC-OBJECT METHOD))))))
	       (METHOD-SATISFIES-SPECIALIZERS-P (METHOD SPECIALIZERS)
		 (DO* ((MSPECS (CLOS:METHOD-SPECIALIZERS METHOD) (CDR MSPECS))
		       (SPECS SPECIALIZERS (CDR SPECS))
		       (MSPEC (CAR MSPECS) (CAR MSPECS))
		       (SPEC (CAR SPECS) (CAR SPECS)))
		      ((OR (NULL SPECS) (NULL MSPECS))	; make sure lists are 
		       (AND (NULL SPECS) (NULL MSPECS)))	; same length.
		   (UNLESS (CL:SUBTYPEP SPEC MSPEC)
		     (RETURN NIL))))
	       (LOOKALIKE-SPECIALIZERS-LISTS (SPECIALIZERS)
		 (APPLY #'CLI::CARTESIAN-PRODUCT
			(MAPCAR #'(LAMBDA (SPECS)
				    (MAPCAR #'CLOS-INTERNALS::SPECIALIZER-NAME-TO-SPECIALIZER
					    SPECS))
				(MAPCAR #'LOOKALIKE-SPECIALIZERS SPECIALIZERS))
			))
	       (LOOKALIKE-SPECIALIZERS (SPEC)
		 ;; given a method specializer name, return a list of lookalikes
		 (IF (CLOS-INTERNALS::EQL-METHOD-SPECIALIZER-P SPEC)
		     (LIST SPEC)
		     (ZWEI:LOOKALIKE-CLOS-CLASS-NAMES SPEC)))
	       (TRY-GENERIC-FUNCTION (NAME)
		 (WHEN (AND (SI:VALIDATE-FUNCTION-SPEC NAME)
			    (FDEFINEDP NAME))
		   (LET ((GF (FDEFINITION (SI:UNENCAPSULATE-FUNCTION-SPEC NAME))))
		     (WHEN (CLOS-INTERNALS::GENERIC-FUNCTION-P GF)
		       (LET ((METHODS (CLOS:GENERIC-FUNCTION-METHODS GF)))
			 (DOLIST (SPECIALIZERS (LOOKALIKE-SPECIALIZERS-LISTS SPECIALIZERS))
			   (CHECK-METHODS METHODS SPECIALIZERS)))))))
	       )
	;; look for generic functions with names matching GENERIC.
	(MAP-PROSPECTIVE-GENERICS GENERIC #'TRY-GENERIC-FUNCTION)
	(DO-YOU-MEAN `(CLOS:METHOD ,GENERIC ,SPECIALIZERS ,@QUALIFIERS))
	))))

(DEFUN MAP-PROSPECTIVE-GENERICS (GENERIC-FUNCTION-SPEC FUNCTION &OPTIONAL TOP-PACKAGE)
  (IF (SYMBOLP GENERIC-FUNCTION-SPEC)
      (DBG:MAP-OVER-LOOKALIKE-SYMBOLS
	(CL:SYMBOL-NAME GENERIC-FUNCTION-SPEC) TOP-PACKAGE FUNCTION)
      (LET ((FOOFS NIL))
	(DBG:MAP-OVER-LOOKALIKE-SYMBOLS
	  (CL:SYMBOL-NAME (FIRST GENERIC-FUNCTION-SPEC)) NIL
	  #'(LAMBDA (FOOF) (CL:PUSHNEW FOOF FOOFS)))
	(DBG:MAP-OVER-LOOKALIKE-SYMBOLS
	  (CL:SYMBOL-NAME (SECOND GENERIC-FUNCTION-SPEC)) TOP-PACKAGE
	  #'(LAMBDA (NAME)
	      (DOLIST (FOOF FOOFS)
		(FUNCALL FUNCTION `(,FOOF ,NAME))))))))


(DEFUN LOOKALIKE-GENERIC-FUNCTION-NAMES (GENERIC &OPTIONAL ALL)
  (OR (IF (SYMBOLP GENERIC)
	  (MAPCAR #'(LAMBDA (G) (OR (GET G 'FLAVOR::COMPATIBLE-GENERIC) G))
		  (PACKAGE-LOOKALIKE-SYMBOLS GENERIC NIL
					     (OR ALL '(FLAVOR:GENERIC
						       FLAVOR::COMPATIBLE-GENERIC))))
	  (MAPCAR #'(LAMBDA (G) (LIST (FIRST GENERIC) G))
		  (LOOKALIKE-GENERIC-FUNCTION-NAMES (SECOND GENERIC) ALL)))
      (AND (NOT ALL)
	   (LOOKALIKE-GENERIC-FUNCTION-NAMES GENERIC T))))

(DEFUN LOOKALIKE-CLOS-GENERIC-FUNCTION-NAMES (FSPEC &OPTIONAL TOP-PACKAGE)
  (LET ((GENERICS NIL))
    (MAP-PROSPECTIVE-GENERICS
      FSPEC
      #'(LAMBDA (GENERIC-FSPEC)
	  (WHEN (AND (SI:VALIDATE-FUNCTION-SPEC FSPEC)
		     (FDEFINEDP FSPEC))
	    (WHEN (CLOS-INTERNALS::GENERIC-FUNCTION-P
		    (FDEFINITION (SI:UNENCAPSULATE-FUNCTION-SPEC FSPEC)))
	      (CL:PUSHNEW GENERIC-FSPEC GENERICS :TEST #'EQUAL))))
      TOP-PACKAGE)
    GENERICS))

(DEFUN LOOKALIKE-FLAVOR-NAMES (FLAVOR)
  (PACKAGE-LOOKALIKE-SYMBOLS FLAVOR NIL '(FLAVOR:FLAVOR)))

;;; --- old version, to be removed when we're sure it's superseded by the above.  Dodds, 6Sep90
;;(DEFUN LOOKALIKE-CLOS-GENERIC-FUNCTION-NAMES (PNAME &OPTIONAL TOP-PACKAGE)
;;  (SI:POOR-MAN/'S-WITH-COLLECTION (ANSWER)
;;    (DBG:MAP-OVER-LOOKALIKE-SYMBOLS PNAME TOP-PACKAGE
;;       #'(LAMBDA (SYMBOL)
;;	   (WHEN (AND (FBOUNDP SYMBOL)
;;		      (CL:TYPEP (FDEFINITION SYMBOL) 'CLOS:GENERIC-FUNCTION))
;;	     (WHEN (NOT (MEMQ SYMBOL ANSWER))
;;	       (COLLECT-ANSWER SYMBOL)))
;;	   (STACK-LET ((SETF `(FUTURE-COMMON-LISP:SETF ,SYMBOL)))
;;	     (WHEN (AND (FDEFINEDP SETF)
;;			(CL:TYPEP (FDEFINITION SETF) 'CLOS:GENERIC-FUNCTION))
;;	       (WHEN (NOT (CL:MEMBER SETF ANSWER :TEST #'CL:EQUAL))
;;		 (COLLECT-ANSWER (COPYLIST SETF)))))
;;	   (STACK-LET ((LOCF `(LOCF ,SYMBOL)))
;;	     (WHEN (AND (FDEFINEDP LOCF)
;;			(CL:TYPEP (FDEFINITION LOCF) 'CLOS:GENERIC-FUNCTION))
;;	       (WHEN (NOT (CL:MEMBER LOCF ANSWER :TEST #'CL:EQUAL))
;;		 (COLLECT-ANSWER (COPYLIST LOCF)))))))
;;    ANSWER))

(DEFUN LOOKALIKE-CLOS-CLASS-NAMES (PNAME &OPTIONAL TOP-PACKAGE)
  (SI:POOR-MAN/'S-WITH-COLLECTION (ANSWER)
    (DBG:MAP-OVER-LOOKALIKE-SYMBOLS PNAME TOP-PACKAGE
       #'(LAMBDA (SYMBOL)
	   (WHEN (AND (CLOS:FIND-CLASS SYMBOL NIL)
		      (NOT (MEMQ SYMBOL ANSWER)))
	     (COLLECT-ANSWER SYMBOL))))
    ANSWER))

;--- Should be interface exported by flavor system
(DEFUN GET-COMPONENT-METHODS-OF-COMBINED-METHOD (METHOD)
  (THIRD (ASSQ 'FLAVOR::COMBINED-METHOD-DERIVATION (DEBUGGING-INFO METHOD))))

(DEFUN GET-COMPONENT-METHODS-OF-SHARED-COMBINED-METHOD (EXTRA-ARG)
  (LOOP FOR METHOD BEING THE ARRAY-ELEMENTS OF EXTRA-ARG FROM 0 BY 2
	COLLECT (SYS:FUNCTION-NAME METHOD)))

(DEFUN DOES-HE-MEAN-FLAVOR (METHOD)
  (SELECTQ (FLAVOR:METHOD-TYPE METHOD)
    (FLAVOR:COMBINED
      (FQUERY '(:SELECT T)
	      "Do you mean some method combined into ~S's ~S handler? "
	      (FLAVOR:METHOD-FLAVOR METHOD) (FLAVOR:METHOD-GENERIC METHOD)))
    (FLAVOR:SHARED-COMBINED
      (FQUERY '(:SELECT T)
	      "Do you mean some method called by this shared-combined method? "))
    (OTHERWISE
      (FQUERY '(:SELECT T) "Do you mean ~S? " METHOD))))

(DEFUN DWIM-METHOD-FROM-HANDLER (FUNCTION-SPEC)
  (LET ((GENERIC (SECOND FUNCTION-SPEC))
	(FLAVOR (THIRD FUNCTION-SPEC))
	GENERIC-FROM-MESSAGE)
    (FLET ((FLAVOR-HANDLER-EXISTS (FLAVOR GENERIC &AUX FL)
	     (AND (SYMBOLP FLAVOR)
		  (SETQ FL (FLAVOR:FIND-FLAVOR FLAVOR NIL))
		  (FLAVOR::FLAVOR-METHODS-COMPOSED FL)
		  (GET-FLAVOR-HANDLER-FOR FLAVOR GENERIC))))
      ;; DWIM the handler specified into one that really exists 
      ;; Try the specified generic and flavor names first
      (OR (FLAVOR-HANDLER-EXISTS FLAVOR GENERIC)
	  ;; Try mapping method name to generic name
	  (AND (SYMBOLP GENERIC)
	       (SETQ GENERIC-FROM-MESSAGE (GET GENERIC 'FLAVOR::COMPATIBLE-GENERIC))
	       (FLAVOR-HANDLER-EXISTS FLAVOR GENERIC-FROM-MESSAGE)
	       (SETQ GENERIC GENERIC-FROM-MESSAGE
		     FUNCTION-SPEC `(:HANDLER ,GENERIC ,FLAVOR)))
	  ;; That didn't work, try package dwim on both the generic name and the flavor name
	  (WHEN *ENABLE-PACKAGE-DWIM*
	    (BLOCK DWIM
	      (LET ((CANDIDATE-GENERICS (LOOKALIKE-GENERIC-FUNCTION-NAMES GENERIC))
		    (CANDIDATE-FLAVORS (LOOKALIKE-FLAVOR-NAMES FLAVOR)))
		(DOLIST (G CANDIDATE-GENERICS)
		  (DOLIST (F CANDIDATE-FLAVORS)
		    (WHEN (AND (FLAVOR-HANDLER-EXISTS F G)
			       (FQUERY '(:SELECT T) "Do you mean (:HANDLER ~S ~S)? " G F))
		      (SETQ FUNCTION-SPEC `(:HANDLER ,G ,F)
			    FLAVOR F
			    GENERIC G)
		      (RETURN-FROM DWIM FUNCTION-SPEC)))))))
	  ;; Nothing worked, let caller do the barfing
	  (RETURN-FROM DWIM-METHOD-FROM-HANDLER FUNCTION-SPEC))
      ;; Convert :HANDLER spec into something we can edit (a method)
      (LET ((HANDLER (GET-FLAVOR-HANDLER FLAVOR GENERIC)))
	(COND ((ATOM HANDLER) HANDLER)
	      ((EQ (FLAVOR:METHOD-TYPE HANDLER) 'FLAVOR:SHARED-COMBINED)
	       (MULTIPLE-VALUE-BIND (NIL METHODS)
		   (FLAVOR:COMPOSE-HANDLER GENERIC FLAVOR)
		 (IF (CDR METHODS)
		     (DOLIST (METHOD METHODS)
		       (WHEN (FQUERY '(:SELECT T) "Do you mean ~S? " METHOD)
			 (RETURN METHOD)))
		     (CAR METHODS))))
	      ((NEQ (FLAVOR:METHOD-TYPE HANDLER) 'FLAVOR:COMBINED) HANDLER)
	      ((LET ((METHODS (GET-COMPONENT-METHODS-OF-COMBINED-METHOD HANDLER)))
		 (IF (CDR METHODS)
		     (DOLIST (METHOD METHODS)
		       (WHEN (FQUERY '(:SELECT T) "Do you mean ~S? " METHOD)
			 (RETURN METHOD)))
		     (CAR METHODS))))
	      (T FUNCTION-SPEC))))))		;Return argument if user answers no

(DEFUN DWIM-PROPERTY-SPEC (SYMBOL INDICATOR)
  (OR (DWIM-CHECK-PROPERTIES SYMBOL INDICATOR)
      (WHEN *ENABLE-PACKAGE-DWIM*
	(LOOP FOR SYM IN (PACKAGE-LOOKALIKE-SYMBOLS SYMBOL NIL T)
	      UNLESS (EQ SYM SYMBOL)
		THEREIS (DWIM-CHECK-PROPERTIES SYM INDICATOR)))))

(DEFUN DWIM-CHECK-PROPERTIES (SYMBOL INDICATOR)
  (OR (AND (GET SYMBOL INDICATOR)
	   (FQUERY '(:SELECT T) "Do you mean (:PROPERTY ~S ~S)? " SYMBOL INDICATOR)
	   `(:PROPERTY ,SYMBOL ,INDICATOR))
      (LOOP FOR IND IN (PLIST SYMBOL) BY 'CDDR DO
	(UNLESS (EQ IND INDICATOR)
	  (WHEN (STRING= IND INDICATOR)
	    (WHEN (FQUERY '(:SELECT T) "Do you mean (:PROPERTY ~S ~S)? " SYMBOL IND)
	      (RETURN `(:PROPERTY ,SYMBOL ,IND))))))))


;;; Funny completion stuff

(DEFCOM COM-COMPLETE-DEFINITION-NAME
	"Attempt to complete the definition-name of the symbol under point" ()
  (MULTIPLE-VALUE-BIND (COMPLETE-STRING NIL COMPLETED-P BP1 BP2)
      (COMPLETE-DEFINITION-NAME-INTERNAL)
    (UNLESS COMPLETED-P
      (BARF))
    (DELETE-INTERVAL BP1 BP2 T)
    (MOVE-POINT (INSERT (POINT) COMPLETE-STRING)))
  DIS-TEXT)

(DEFCOM COM-LIST-DEFINITION-NAMES
	"List the completions matching the definition-name of the symbol under point" ()
  (MULTIPLE-VALUE-BIND (NIL POSSIBILITIES NIL)
      (COMPLETE-DEFINITION-NAME-INTERNAL)
    (AND (OR ( (LENGTH POSSIBILITIES)
		DW::*DEFAULT-DISPLAY-POSSIBILITIES-QUERY-CUTOFF-LENGTH*)
	     (CL:Y-OR-N-P "There are ~D possibilities.  Do you want to see them all? "))
	 (FLET ((SHOW (SPEC)
		  (CL:FRESH-LINE)
		  (SCL:PRESENT SPEC 'SYS:FUNCTION-SPEC)))
	   (LOOP FOR (NIL . SPECS) IN POSSIBILITIES DOING
	     (IF (LISTP SPECS)
		 (LOOP FOR SPEC IN SPECS DOING (SHOW SPEC))
	     (SHOW SPECS))))))
  DIS-NONE)

(DEFUN COMPLETE-DEFINITION-NAME-INTERNAL ()
  (DECLARE (VALUES COMPLETE-STRING POSSIBILITIES COMPLETED-P START-BP END-BP))
  (LET* ((BP1 (FORWARD-ATOM (FORWARD-CHAR (POINT) 1 T) -1 T))
	 (BP2 (FORWARD-ATOM BP1)))
    (WHEN BP2
      (MULTIPLE-VALUE-BIND (COMPLETE-STRING POSSIBILITIES COMPLETED-P)
	  (SI:COMPLETE-STRING (STRING-INTERVAL BP1 BP2)
			      SI:*READ-FORM-COMPLETION-ALIST*
			      SI:*READ-FORM-COMPLETION-DELIMITERS*)
	(VALUES COMPLETE-STRING POSSIBILITIES COMPLETED-P BP1 BP2)))))
