;;; -*- Mode: LISP; Syntax: Zetalisp; Package: Zwei; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; The special purpose buffer used for Edit Definition (m-.)


(DEFFLAVOR DEFINITION-SUBNODE (FUNCTION-SPEC DEFINITION-TYPE) (NODE)
  :INITABLE-INSTANCE-VARIABLES
  :GETTABLE-INSTANCE-VARIABLES
  (:REQUIRED-METHODS :DEFINITION-LOCATION))

(SCL:DEFINE-PRESENTATION-TYPE DEFINITION-SUBNODE ()
   :NO-DEFTYPE T
   :PRINTER ((NODE STREAM)
	     (LET ((DW::*ABBREVIATE-FUNCTION-SPECS* T))
	       (SEND NODE :DESCRIPTION STREAM))))


(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR LOCATE-DEFINITION
  (DEFINITION-SUBNODE
    "Locate Definition"
    *ZMACS-COMTAB*
    :GESTURE :SELECT
    :TESTER ((NODE) (IGNORE NODE) *ZMACS-DEFINITIONS-BUFFER*))
  (NODE)
  `(SEND ,*ZMACS-DEFINITIONS-BUFFER* :LOCATE-DEFINITION ,NODE))

(DEFMETHOD (:DESCRIPTION DEFINITION-SUBNODE) (STREAM)
  (LET ((PACKAGE PKG-GLOBAL-PACKAGE))
    (PRINC (SECTION-DEFINITION-NAME FUNCTION-SPEC DEFINITION-TYPE) STREAM)))

(DEFMETHOD (:DEFINITION-P DEFINITION-SUBNODE) () T)

;This method needs to be present so that :NEXT-NODE will find this subnode
(DEFMETHOD (:SELECT-POSSIBILITY DEFINITION-SUBNODE) ()
  (FERROR "This is a subnode of the wrong kind of buffer--please report to BUG-ZWEI"))

(DEFFLAVOR INFORMATION-DEFINITION-SUBNODE-MIXIN () ()
  (:REQUIRED-FLAVORS DEFINITION-SUBNODE))

(DEFMETHOD (:DEFINITION-LOCATION INFORMATION-DEFINITION-SUBNODE-MIXIN :BEFORE) ()
  (TYPEIN-LINE "")
  (SEND SELF ':DESCRIPTION *TYPEIN-WINDOW*))

(DEFMETHOD (:DEFINITION-LOCATION INFORMATION-DEFINITION-SUBNODE-MIXIN) ()
  NIL)

(DEFMETHOD (:DEFINITION-P INFORMATION-DEFINITION-SUBNODE-MIXIN) () NIL)

(DEFINE-SPECIAL-BUFFER-TYPE DEFINITIONS-EDITING-BUFFER
			    (FUNCTION-SPECS ALLOWED-DEFINITION-TYPES
			     LOOKALIKES-ALLOWED EDIT-INSTALLED-DEFINITION-P
			     ;; Definitions editing buffers are per command-loop
			     (COMMAND-LOOP NIL))
			    (HEADER-DESCRIPTION-1-SUBNODE-SPECIAL-PURPOSE-BUFFER-MIXIN
			      SUBNODE-SPECIAL-PURPOSE-BUFFER)
			    :DEFINITIONS "Definitions"
  :SETTABLE-INSTANCE-VARIABLES
  (:GETTABLE-INSTANCE-VARIABLES LOOKALIKES-ALLOWED)
  (:BUFFER-INIT-OPTIONS :SET-FUNCTION-SPECS :SET-ALLOWED-DEFINITION-TYPES
			:SET-LOOKALIKES-ALLOWED :SET-EDIT-INSTALLED-DEFINITION-P
			:SET-COMMAND-LOOP))

;;; Keep using the same buffer for m-. for each Zmacs command-loop
(DEFMETHOD (:REUSABLE DEFINITIONS-EDITING-BUFFER) (IGNORE)
  (EQ COMMAND-LOOP *CURRENT-COMMAND-LOOP*))

(DEFMETHOD (:KILL DEFINITIONS-EDITING-BUFFER :BEFORE) (&OPTIONAL NO-SAVE-P)
  NO-SAVE-P
  (WHEN (EQ SELF *ZMACS-DEFINITIONS-BUFFER*)
    (SETQ *ZMACS-DEFINITIONS-BUFFER* NIL)))

(DEFMETHOD (:HEADER-DESCRIPTION-1 DEFINITIONS-EDITING-BUFFER) (STREAM PLURAL-P)
  (FORMAT STREAM "definition~P of " PLURAL-P)
  (SCL:FORMAT-TEXTUAL-LIST
    FUNCTION-SPECS
    #'(LAMBDA (FS STREAM)
	(SCL:PRESENT FS '((SYS:FUNCTION-SPEC) :ABBREVIATE-P T) :STREAM STREAM))
    :IF-TWO " and "
    :FINALLY " and "))

(DEFMETHOD (:LIST-SUBNODES DEFINITIONS-EDITING-BUFFER) (FIRST-NODE)
  (SCL:FORMATTING-ITEM-LIST (*TYPEOUT-WINDOW*)
    (LOOP FOR NODE FIRST FIRST-NODE THEN (NODE-NEXT NODE)
	  WHILE NODE
	  DO
      (SCL:FORMATTING-CELL (*TYPEOUT-WINDOW*)
	(SCL:PRESENT NODE 'DEFINITION-SUBNODE :STREAM *TYPEOUT-WINDOW*
		     :ALLOW-SENSITIVE-INFERIORS NIL :SINGLE-BOX T)))))

(DEFMETHOD (:DESCRIPTION DEFINITIONS-EDITING-BUFFER) ()
  (FORMAT NIL "~A" (CAR FUNCTION-SPECS)))

(DEFMETHOD (:HEADER-DESCRIPTION DEFINITIONS-EDITING-BUFFER) (STREAM)
  (FORMAT STREAM "Definitions of ~A:" (CAR FUNCTION-SPECS)))

(DEFMETHOD (:REVERT DEFINITIONS-EDITING-BUFFER) ()
  (DOLIST (FSPEC FUNCTION-SPECS)
    (SEND SELF ':ADD-NODES-FOR-FUNCTION-SPEC FSPEC ALLOWED-DEFINITION-TYPES)))


(DEFCONST *PREFERRED-DEFINITION-TYPES* '(DEFUN DEFVAR DEFFLAVOR DEFSTRUCT))

(DEFUN DEFINITION-TYPE-PRIORITY-LESSP (TYPE1 TYPE2)
  (UNLESS (EQ TYPE1 TYPE2)
    (DOLIST (TYPE *PREFERRED-DEFINITION-TYPES*)
      (WHEN (EQ TYPE TYPE1)
	(RETURN T))
      (WHEN (EQ TYPE TYPE2)
	(RETURN NIL)))))

(DEFUN-IN-FLAVOR (COLLECT-SOURCE-FILE-INFO DEFINITIONS-EDITING-BUFFER)
		 (FUNCTION-SPEC ALLOWED-TYPES ALL-SOURCE-FILE-NAMES)
  (LET ((PARENTS NIL)
	(FILE-DEFINITIONS NIL))
    (LOOP FOR (TYPE . PATHNAMES) IN ALL-SOURCE-FILE-NAMES
	  WITH VALID-FSPEC = (SYS:VALIDATE-FUNCTION-SPEC FUNCTION-SPEC)
	  WHEN (and (OR (NULL ALLOWED-TYPES) (MEMQ TYPE ALLOWED-TYPES))
		    (OR (NOT VALID-FSPEC)
			(MULTIPLE-VALUE-BIND (PF PD)
			    (SYS:FUNCTION-PARENT FUNCTION-SPEC TYPE)
			  ;;defer parent processing for later.
			  (COND (PF (PUSH (LIST PD PF TYPE) PARENTS) NIL)
				(T)))))
	    NCONC
	      (LOOP FOR PATHNAME IN PATHNAMES
		    WHEN (NOT (SEND PATHNAME ':GET ':PATCH-FILE))
		      COLLECT 
			(LET* ((LOGICAL-GENERIC-PATHNAME 
				 (IF EDIT-INSTALLED-DEFINITION-P
				     (OR
				       (SI:GET-INSTALLED-SOURCE-FILE-NAME FUNCTION-SPEC TYPE)
				       (BARF "Can't find the installed definition for ~A."
					     (FUNCTION-SPEC-NAME FUNCTION-SPEC TYPE)))
				   PATHNAME))
			       (LOADED-NAME (FILE-LOADED-TRUENAME LOGICAL-GENERIC-PATHNAME))
			       (PATHNAME
				 (OR LOADED-NAME
				     (NEWEST-TYPED-PATHNAME
				       (SEND LOGICAL-GENERIC-PATHNAME :TRANSLATED-PATHNAME)))))
			  (LIST TYPE
				(SEND PATHNAME
				      :NEW-PATHNAME
				      :VERSION (IF EDIT-INSTALLED-DEFINITION-P
						   (SEND PATHNAME :VERSION)
						 :NEWEST)
				      :VC-VERSION (IF EDIT-INSTALLED-DEFINITION-P
						      (SEND PATHNAME :VC-VERSION)
						    (AND (SEND PATHNAME :VC-VERSION)
							 :NEWEST)))))
			INTO REAL-PATHNAMES
		    ELSE WHEN (NULL REAL-PATHNAMES)
			   COLLECT PATHNAME INTO INTERMEDIATE-PATCHES
		    FINALLY (WHEN INTERMEDIATE-PATCHES
			      (SEND SELF ':ADD-NODE
				    'PATCH-FILE-INFORMATION-DEFINITION-SUBNODE
				    ':FUNCTION-SPEC FUNCTION-SPEC ':DEFINITION-TYPE TYPE
				    ':PATHNAMES INTERMEDIATE-PATCHES
				    ':REAL-TOO (NOT (NULL REAL-PATHNAMES))))
			    (RETURN (APPEND REAL-PATHNAMES
					    (AND INTERMEDIATE-PATCHES
						 (NOT (FIND-BUFFER-NAMED
							(CAR INTERMEDIATE-PATCHES)))
						 `((,TYPE
						    ,(NEWEST-TYPED-PATHNAME
						       (CAR INTERMEDIATE-PATCHES))))))))
	      INTO DEFS
	  FINALLY
	    (SETQ FILE-DEFINITIONS DEFS))
    (VALUES FILE-DEFINITIONS PARENTS)))

(DEFWHOPPER (:ADD-NODES-FOR-FUNCTION-SPEC DEFINITIONS-EDITING-BUFFER)
	    (FUNCTION-SPEC ALLOWED-TYPES &OPTIONAL TRAIL)
  (CONTINUE-WHOPPER (IF (LISP:TYPEP FUNCTION-SPEC 'CLOS:METHOD)
			(CLOS-INTERNALS:FUNCTION-SPEC-OBJECT FUNCTION-SPEC)
			FUNCTION-SPEC)
		    ALLOWED-TYPES TRAIL))

(DEFMETHOD (:ADD-NODES-FOR-FUNCTION-SPEC DEFINITIONS-EDITING-BUFFER)
	   (FUNCTION-SPEC ALLOWED-TYPES &OPTIONAL TRAIL
			  &AUX
			  (PARENTS NIL) FILE-DEFINITIONS TYPES-DONE DEF
			  (BUFFERS-DONE NIL))
  (FLET ((ADD-NODE-RECURSIVELY (NEW-FSPEC NEW-TYPES)
	   ;; Add another node, but not if a higher stack level is already adding it
	   (STACK-LET ((TRAIL `((,FUNCTION-SPEC ,ALLOWED-TYPES) ,@TRAIL)))
	     (UNLESS (LOOP FOR (FSPEC TYPES) IN TRAIL
			   THEREIS (AND (EQUAL FSPEC NEW-FSPEC)
					(OR (NULL TYPES)
					    (LOOP FOR TYPE IN TYPES
						  THEREIS (MEMQ TYPE NEW-TYPES)))))
	       (SEND SELF :ADD-NODES-FOR-FUNCTION-SPEC NEW-FSPEC NEW-TYPES TRAIL)))))
    (LET ((ALL-SOURCE-FILE-NAMES (SI:GET-ALL-SOURCE-FILE-NAMES FUNCTION-SPEC)))
      (IF ALL-SOURCE-FILE-NAMES
	  (CL:MULTIPLE-VALUE-SETQ (FILE-DEFINITIONS PARENTS)
	    (COLLECT-SOURCE-FILE-INFO FUNCTION-SPEC ALLOWED-TYPES ALL-SOURCE-FILE-NAMES))
	  ;; No source-file-name.  So we have to collect parents the hard way.
	  ;; The question is, how can we possibly figure out what definition types
	  ;; to use in checking for parents?
	  ;; For now, we can't.  We use DEFUN, and assume that everyone else records source
	  ;; file names on the children as well as the parents.
	  (FLET ((PUSH-PARENT (DTYPE)
		   (MULTIPLE-VALUE-BIND (PFSPEC PDTYPE)
		       (SYS:FUNCTION-PARENT FUNCTION-SPEC DTYPE)
		     (WHEN PFSPEC
		       (PUSH (LIST PDTYPE PFSPEC DTYPE) PARENTS)))))
	    (IF (NULL ALLOWED-TYPES)
		(PUSH-PARENT 'DEFUN)
		(LOOP FOR TYPE IN ALLOWED-TYPES DO (PUSH-PARENT TYPE))))))
    ;; Verify that all the sections we know about are still there.  The buffer
    ;; could have been edited to remove them, or file read-in could have been aborted.
    (LET ((L (SI:FUNCTION-SPEC-GET FUNCTION-SPEC 'ZMACS-BUFFERS)))
      (LOOP FOR ELEM IN L
	    AS SECTION = (CADR ELEM)
	    AS BUFFER = (INTERVAL-HOME-BUFFER SECTION)
	    DO
	(UNLESS
	  (AND (MEMQ BUFFER *ZMACS-BUFFER-LIST*)	;buffer has to be OK.
	       (PROGN
						;and after checking out the status,
		 (CHECK-INTERVAL-SECTIONS
		   (IF (OR (BP-= (INTERVAL-FIRST-BP SECTION) (INTERVAL-LAST-BP SECTION))
			   (EQ (LINE-TICK (SECTION-NODE-DEFINITION-OR-FIRST-LINE SECTION))
			       'DELETED))
		       BUFFER
		       SECTION))
		 (MEMQ SECTION (BUFFER-SECTIONS BUFFER))))	;node has to be in it.
	  (SETF (SI:FUNCTION-SPEC-GET FUNCTION-SPEC 'ZMACS-BUFFERS) (DELQ ELEM L)))))
    (LET ((DEFINITION-TYPE-SECTION-NODE-ALIST
	    (LOOP FOR (TYPE SECTION) IN
		      (SI:FUNCTION-SPEC-GET FUNCTION-SPEC 'ZMACS-BUFFERS)
		  AS BUFFER = (INTERVAL-HOME-BUFFER SECTION *INTERVAL*)
		  DO (CL:PUSHNEW BUFFER BUFFERS-DONE)
		  COLLECT `(,TYPE ,SECTION ,BUFFER))))
      (SETQ DEFINITION-TYPE-SECTION-NODE-ALIST
	    ;; Definitions in the current buffer get precedence.
	    (CL:STABLE-SORT DEFINITION-TYPE-SECTION-NODE-ALIST
			    #'(LAMBDA (E1 E2)
				(DECLARE (SYS:DOWNWARD-FUNCTION))
				(OR (AND (EQ (THIRD E1) *INTERVAL*)
					 (NEQ (THIRD E2) *INTERVAL*))
				    (DEFINITION-TYPE-PRIORITY-LESSP (FIRST E1) (FIRST E2))))))
      (LOOP FOR (TYPE SECTION BUFFER) IN DEFINITION-TYPE-SECTION-NODE-ALIST
	    ;; A type matches if either the list is NIL,
	    ;; or it is in the list.
	    WHEN (OR (NULL ALLOWED-TYPES) (MEMQ TYPE ALLOWED-TYPES))
	      DO (CL:PUSHNEW TYPE TYPES-DONE)
		 (SEND SELF ':ADD-NODE 'SECTION-DEFINITION-SUBNODE
		       ':FUNCTION-SPEC FUNCTION-SPEC ':DEFINITION-TYPE TYPE
		       ':SECTION SECTION
		       ':BUFFER BUFFER))
      ;; Now if we were in still search of a particular type and there are definitions whose
      ;; type we do not understand, collect them too; they might be the right one.
      (WHEN (AND (NOT (NULL ALLOWED-TYPES))
		 (NOT (LOOP FOR TYPE IN ALLOWED-TYPES ALWAYS (MEMQ TYPE TYPES-DONE))))
	(LOOP FOR (TYPE SECTION BUFFER) IN DEFINITION-TYPE-SECTION-NODE-ALIST
	      WHEN (NULL (GET TYPE 'SI:DEFINITION-TYPE-NAME))
		DO (CL:PUSHNEW TYPE TYPES-DONE)
		   (WHEN (OR (NULL ALLOWED-TYPES) (MEMQ TYPE ALLOWED-TYPES))
		     (SEND SELF ':ADD-NODE 'SECTION-DEFINITION-SUBNODE
			   ':FUNCTION-SPEC FUNCTION-SPEC ':DEFINITION-TYPE TYPE
			   ':SECTION SECTION
			   ':BUFFER BUFFER))))
      ;; After the specific entries for already-known definitions, add entries to
      ;; obtain new definitions from files or by resectionizing
      ;;--- This structure will prefer an uninteresting definition type in a buffer
      ;;--- to an interesting one in a file. Is this right?  NO!!!
      (LOOP FOR (TYPE PATHNAME) IN
		(CL:STABLE-SORT (CL:REMOVE-DUPLICATES FILE-DEFINITIONS :TEST #'EQUAL)
				#'DEFINITION-TYPE-PRIORITY-LESSP
				:KEY #'FIRST)
	    AS BUFFER = (FIND-BUFFER-NAMED PATHNAME)
	    WHEN (NULL BUFFER)
	      DO (CL:PUSHNEW TYPE TYPES-DONE)
		 (WHEN (OR (NULL ALLOWED-TYPES) (MEMQ TYPE ALLOWED-TYPES))
		   (SEND SELF ':ADD-NODE 'FILE-DEFINITION-SUBNODE
			 ':FUNCTION-SPEC FUNCTION-SPEC ':DEFINITION-TYPE TYPE
			 ':PATHNAME PATHNAME))
	    ELSE UNLESS (MEMQ BUFFER BUFFERS-DONE)
		   DO (CL:PUSHNEW TYPE TYPES-DONE)
		      (WHEN (OR (NULL ALLOWED-TYPES) (MEMQ TYPE ALLOWED-TYPES))
			(SEND SELF ':ADD-NODE 'BUFFER-DEFINITION-SUBNODE
			      ':FUNCTION-SPEC FUNCTION-SPEC ':DEFINITION-TYPE TYPE
			      ':BUFFER BUFFER)))
      (WHEN PARENTS
	(LOOP FOR (PTYPE PFSPEC TYPE) IN
		  (CL:STABLE-SORT PARENTS
				  #'DEFINITION-TYPE-PRIORITY-LESSP
				  :KEY #'THIRD)
	      DO (SEND SELF ':ADD-NODE 'PARENT-INFORMATION-DEFINITION-SUBNODE
		       ':FUNCTION-SPEC FUNCTION-SPEC ':DEFINITION-TYPE TYPE
		       ':PARENT PFSPEC ':PARENT-TYPE PTYPE)
		 (ADD-NODE-RECURSIVELY PFSPEC (LIST PTYPE))))
      ;; If we're looking for a function, there are other ways to find it
      (WHEN (OR (NULL ALLOWED-TYPES) (MEMQ 'DEFUN ALLOWED-TYPES))
	(WHEN (NULL PARENTS)
	  (COND ((NOT (FDEFINEDP FUNCTION-SPEC)))
		((SYMBOLP (SETQ DEF (FDEFINITION FUNCTION-SPEC)))
		 (SEND SELF ':ADD-NODE 'INDIRECT-INFORMATION-DEFINITION-SUBNODE
		       ':FUNCTION-SPEC FUNCTION-SPEC ':DEFINITION-TYPE 'DEFUN ':SYMBOL DEF)
		 (ADD-NODE-RECURSIVELY DEF '(DEFUN)))
		((AND (OR (AND (LISTP DEF)	;(ZL:LISTP NIL) ==> NIL
			       (LISTP (OR (SI:MACRO-FUNCTION DEF)
					  (SI:SPECIAL-FORM-P DEF))))
			  ;; It's an interpreted function, or it's a macro or special form
			  ;; whose underlying function is interpreted.
			  (SI:DEBUGGING-INFO-USER-ENTRY DEF ':INTERPRETED-DEFINITION))
		      (NOT (MEMQ 'DEFUN TYPES-DONE)))
		 (SEND SELF ':ADD-NODE 'INTERPRETED-DEFINITION-SUBNODE
		       ':FUNCTION-SPEC FUNCTION-SPEC ':DEFINITION-TYPE 'DEFUN))))
	;; If it's a generic function, the methods are interesting, too, but only if
	;; we didn't get here via function-parent.
	;; It could either be a Flavors generic function or a CLOS generic function.
	(WHEN (NULL TRAIL)
	  (IF (AND (CL:TYPEP FUNCTION-SPEC 'SYS:GENERIC-FUNCTION-NAME)
		   (FLAVOR:FIND-GENERIC-FUNCTION FUNCTION-SPEC NIL))
	      (LET ((METHODS (GENERIC-FUNCTION-METHODS FUNCTION-SPEC)))
		(UNLESS (NULL METHODS)
		  (SEND SELF :ADD-NODE 'METHOD-INFORMATION-DEFINITION-SUBNODE
			:FUNCTION-SPEC FUNCTION-SPEC
			:DEFINITION-TYPE 'DEFUN
			:METHODS METHODS)
		  (DOLIST (METHOD METHODS)
		    (ADD-NODE-RECURSIVELY METHOD '(DEFUN)))))
	      (WHEN (CL:TYPEP FUNCTION-SPEC '(CLOS:GENERIC-FUNCTION-NAME :DEFINED T))
		(LET ((METHODS (CLOS:GENERIC-FUNCTION-METHODS
				 (FDEFINITION
				   (SI:UNENCAPSULATE-FUNCTION-SPEC FUNCTION-SPEC)))))
		  (UNLESS (NULL METHODS)
		    (SEND SELF :ADD-NODE 'CLOS-METHOD-INFORMATION-DEFINITION-SUBNODE
			  :FUNCTION-SPEC FUNCTION-SPEC
			  :DEFINITION-TYPE 'DEFUN
			  :METHODS METHODS)
		    (DOLIST (METHOD METHODS)
		      (ADD-NODE-RECURSIVELY
			(CLOS-INTERNALS:FUNCTION-SPEC-OBJECT METHOD)
			'(DEFUN))))))))
	))))


(DEFFLAVOR SECTION-DEFINITION-SUBNODE (SECTION BUFFER) (DEFINITION-SUBNODE)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:DESCRIPTION SECTION-DEFINITION-SUBNODE :AFTER) (STREAM)
  (FORMAT STREAM " in buffer ~A." (SEND BUFFER :NAME)))

;;; In spite of its name, this just makes sure that inferiors and superiors are consistent
(DEFUN NODE-PART-OF-BUFFER (NODE)
  (LOOP WITH CURR-NODE = NODE
	WITH TOP-NODE = (NODE-TOP-LEVEL-NODE NODE)
	UNTIL (EQ CURR-NODE TOP-NODE)
	AS SUPERIOR = (SEND CURR-NODE ':SUPERIOR)
	AS SUPERIORS-INFS = (SEND SUPERIOR ':INFERIORS)
	ALWAYS (AND (MEMQ CURR-NODE SUPERIORS-INFS)
		    (SETQ CURR-NODE SUPERIOR))))

(DEFMETHOD (:DEFINITION-LOCATION SECTION-DEFINITION-SUBNODE) ()
  ;; Make sure section is still valid.
  (CHECK-INTERVAL-SECTIONS (IF (BP-= (INTERVAL-FIRST-BP SECTION)
				     (INTERVAL-LAST-BP SECTION))
			       (NODE-SUPERIOR SECTION)
			       SECTION))
  (IF (NODE-PART-OF-BUFFER SECTION)
      (VALUES (CREATE-BP (SECTION-NODE-DEFINITION-OR-FIRST-LINE SECTION) 0)
	      BUFFER)
      (SEND SUPERIOR ':ADD-NODE-BEFORE-NODE SELF 'BUFFER-DEFINITION-SUBNODE
	    ':FUNCTION-SPEC FUNCTION-SPEC ':DEFINITION-TYPE DEFINITION-TYPE
	    ':BUFFER BUFFER)
      (SEND SUPERIOR ':DELETE-NODE SELF)
      NIL))

(DEFFLAVOR FILE-DEFINITION-SUBNODE (PATHNAME) (DEFINITION-SUBNODE)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:DESCRIPTION FILE-DEFINITION-SUBNODE :AFTER) (STREAM)
  (FORMAT STREAM " in file ~A." PATHNAME))

(DEFMETHOD (:DEFINITION-LOCATION FILE-DEFINITION-SUBNODE) ()
  (LET ((*REVERT-FILE-NOT-FOUND-IS-AN-ERROR*
	  (FORMAT NIL "The source for ~A is not available:" FUNCTION-SPEC)))
    (MULTIPLE-VALUE-BIND (NIL BUFFER)
	(FIND-FILE PATHNAME NIL)
      ;; In case the file was not just read in, and was edited since it was
      ;; last sectionized, do what the user obviously must mean.
      (UNLESS (NULL BUFFER)
	(CHECK-INTERVAL-SECTIONS BUFFER))
      (VALUES NIL BUFFER))))

(DEFFLAVOR BUFFER-DEFINITION-SUBNODE (BUFFER) (DEFINITION-SUBNODE)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:DESCRIPTION BUFFER-DEFINITION-SUBNODE :AFTER) (STREAM)
  (FORMAT STREAM " somewhere in buffer ~A." (SEND BUFFER ':NAME)))

(DEFMETHOD (:DEFINITION-LOCATION BUFFER-DEFINITION-SUBNODE) (&AUX SNAME)
  (SETQ SNAME (SECTION-DEFINITION-NAME FUNCTION-SPEC DEFINITION-TYPE))
  ;; If sectionizing might change something, try it.  But otherwise don't
  ;; waste the time, and don't allow it to rearrange the order of definition
  ;; subnodes so that this subnode keeps getting tried over and over.
  (UNLESS (BUFFER-SECTIONIZATION-VALID BUFFER)
    (WHEN (TYPEIN-LINE-Y-OR-N-P "Sectionize buffer ~A in order to find ~A? "
				(SEND BUFFER :NAME) SNAME)
      (SECTIONIZE-BUFFER BUFFER)))
  ;; If we are still present after the sectionization, then it must have failed,
  ;; so try our best
  (WHEN (NODE-PART-OF-BUFFER SELF)
    (TYPEIN-LINE "Can't find ~A in ~A; trying textual search."
		 SNAME (SEND BUFFER ':NAME))
    (VALUES (LET ((*INTERVAL* BUFFER))		;The primitives depend on this!
	      (DEFINITION-LIKELY-POSITION BUFFER NIL T FUNCTION-SPEC))
	    BUFFER)))

(DEFFLAVOR PATCH-FILE-INFORMATION-DEFINITION-SUBNODE (PATHNAMES REAL-TOO)
	   (INFORMATION-DEFINITION-SUBNODE-MIXIN DEFINITION-SUBNODE)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:DESCRIPTION PATCH-FILE-INFORMATION-DEFINITION-SUBNODE :AFTER) (STREAM)
  (FORMAT STREAM " ~:[defined only~;also defined~] by patch file~P "
	  REAL-TOO (LENGTH PATHNAMES))
  (FORMAT:PRINT-LIST STREAM "~A" PATHNAMES)
  (PRINC "." STREAM))

(DEFFLAVOR PARENT-INFORMATION-DEFINITION-SUBNODE (PARENT PARENT-TYPE)
	   (INFORMATION-DEFINITION-SUBNODE-MIXIN DEFINITION-SUBNODE)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:DESCRIPTION PARENT-INFORMATION-DEFINITION-SUBNODE :AFTER) (STREAM)
  (LET ((PACKAGE PKG-GLOBAL-PACKAGE))
    (FORMAT STREAM " is inside of the definition of ~A."
	    (SECTION-DEFINITION-NAME PARENT PARENT-TYPE))))

(DEFFLAVOR INDIRECT-INFORMATION-DEFINITION-SUBNODE (SYMBOL)
	   (INFORMATION-DEFINITION-SUBNODE-MIXIN DEFINITION-SUBNODE)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:DESCRIPTION INDIRECT-INFORMATION-DEFINITION-SUBNODE :AFTER) (STREAM)
  (LET ((PACKAGE PKG-GLOBAL-PACKAGE))
    (FORMAT STREAM " is currently defined as '~S." SYMBOL)))

(DEFFLAVOR METHOD-INFORMATION-DEFINITION-SUBNODE (METHODS)
	   (INFORMATION-DEFINITION-SUBNODE-MIXIN DEFINITION-SUBNODE)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:DESCRIPTION METHOD-INFORMATION-DEFINITION-SUBNODE) (STREAM)
  (LET ((PACKAGE PKG-GLOBAL-PACKAGE)
	(CL:*PRINT-PRETTY* NIL))		;No carriage returns in the ~S
    (FORMAT STREAM "~S is a Flavors ~:[generic function~;message~] with ~:D method~:P."
	    FUNCTION-SPEC (MESSAGE-P FUNCTION-SPEC) (LENGTH METHODS))))

(DEFFLAVOR CLOS-METHOD-INFORMATION-DEFINITION-SUBNODE (METHODS)
	   (INFORMATION-DEFINITION-SUBNODE-MIXIN DEFINITION-SUBNODE)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:DESCRIPTION CLOS-METHOD-INFORMATION-DEFINITION-SUBNODE) (STREAM)
  (LET ((PACKAGE PKG-GLOBAL-PACKAGE)
	(CL:*PRINT-PRETTY* NIL))				;No carriage returns in the ~S
    (FORMAT STREAM "~S is a CLOS generic function with ~:D method~:P."
	    FUNCTION-SPEC (LENGTH METHODS))))

(DEFFLAVOR BARFING-DEFINITION-SUBNODE-MIXIN () (INFORMATION-DEFINITION-SUBNODE-MIXIN))

(DEFMETHOD (:DEFINITION-LOCATION BARFING-DEFINITION-SUBNODE-MIXIN) ()
  (BARF))

(DEFFLAVOR INTERPRETED-DEFINITION-SUBNODE ()
	   (INFORMATION-DEFINITION-SUBNODE-MIXIN DEFINITION-SUBNODE))

(DEFMETHOD (:DESCRIPTION INTERPRETED-DEFINITION-SUBNODE :AFTER) (STREAM)
   (FORMAT STREAM " was apparently defined in the interpreter."))

(DEFMETHOD (:DEFINITION-LOCATION INTERPRETED-DEFINITION-SUBNODE) ()
  (AND (FQUERY NIL "Grind the definition of ~S into a new buffer? " FUNCTION-SPEC)
       (LET ((BUFFER (MAKE-BUFFER 'NON-FILE-BUFFER ':NAME (FORMAT NIL "~A" FUNCTION-SPEC))))
	 (SEND BUFFER ':PUTPROP (MODE-OF-FLAVOR 'LISP-MODE) ':MAJOR-MODE)
	 (LET ((PACKAGE (SEND BUFFER ':GET ':PACKAGE))
	       (LAST-BP (INTERVAL-LAST-BP BUFFER)))
	   (CL:PPRINT (FDEFINITION FUNCTION-SPEC)
		      (OPEN-INTERVAL-STREAM LAST-BP LAST-BP T)))
	 (SEND SUPERIOR ':ADD-NODE-BEFORE-NODE ':POINT 'BUFFER-DEFINITION-SUBNODE
	       ':FUNCTION-SPEC FUNCTION-SPEC ':DEFINITION-TYPE DEFINITION-TYPE
	       ':BUFFER BUFFER)
	 (SEND SUPERIOR ':DELETE-NODE SELF)))
  NIL)

(DEFUN-IN-FLAVOR (LOCATE-DEFINITION-FOR-NODE DEFINITIONS-EDITING-BUFFER)
		 (&OPTIONAL START-NODE)
  (WHEN START-NODE
    (LET ((POINT (SEND SELF :POINT)))
      (MOVE-BP POINT (INTERVAL-FIRST-BP START-NODE))))
  (LOOP AS NODE = (SEND SELF :NEXT-NODE)
	WHEN (NULL NODE)
	  DO
	    (LET ((FUNCTION-SPEC (CAR FUNCTION-SPECS)))
	      (OR *MINI-BUFFER-COMMAND*
		  (SEND *MINI-BUFFER-HISTORY* ':PUSH
			(SETQ *MINI-BUFFER-COMMAND* `((COM-EDIT-DEFINITION NIL 1)
						      ,(FORMAT NIL "~S" FUNCTION-SPEC)))))
	      (LET ((FILE (ACCEPT-DEFAULTED-PATHNAME `("Read ~? from what file"
						       "~S" (,FUNCTION-SPEC))
						     (PATHNAME-DEFAULTS))))
		(SETQ NODE (SEND SELF ':ADD-NODE 'FILE-DEFINITION-SUBNODE
				 ':FUNCTION-SPEC FUNCTION-SPEC ':DEFINITION-TYPE NIL
				 ':PATHNAME FILE))))
	DO
    (MULTIPLE-VALUE-BIND (BP BUFFER)
	(SEND NODE ':DEFINITION-LOCATION)
      (COND (BP
	     (LOOP WHILE (SETQ NODE (NODE-NEXT NODE))
		   COUNT (SEND NODE ':DEFINITION-P) INTO COUNT
		   FINALLY (AND (PLUSP COUNT)
				(TYPEIN-LINE "~D more definition~:P as well" COUNT)))
	     (RETURN (VALUES BP BUFFER)))
	    (BUFFER
	     ;; What the hell is this trying to do?  Who knows, but at least
	     ;; make it win more often.  --SWM
	     (LET ((PEEKED-NODE (SEND SELF :NEXT-NODE T)))
	       (UNLESS (AND PEEKED-NODE (EQ (SEND PEEKED-NODE :DEFINITION-TYPE)
					    (SEND NODE :DEFINITION-TYPE)))
		 (WHEN (NULL PEEKED-NODE)
		   ;; Only crap out if there are no more nodes.  --SWM
		   (TYPEIN-LINE "Best available location is somewhere in ~A." (SEND BUFFER :NAME))
		   (RETURN (VALUES (NODE-FIRST-BP BUFFER) BUFFER))))))))))

(DEFMETHOD (:LOCATE-DEFINITION DEFINITIONS-EDITING-BUFFER) (NODE)
  (MULTIPLE-VALUE-BIND (BP BUFFER)
      (LOCATE-DEFINITION-FOR-NODE NODE)
    (MAKE-BUFFER-CURRENT BUFFER)
    (MOVE-POINT BP)
    (MUST-REDISPLAY *WINDOW* DIS-ALL)))

(DEFMETHOD (:NEXT-DEFINITION DEFINITIONS-EDITING-BUFFER) ()
  (LOCATE-DEFINITION-FOR-NODE))

;;; This gets called whenever a buffer is killed, it takes account of old definitions
(DEFMETHOD (:BUFFER-KILLED DEFINITIONS-EDITING-BUFFER) (BUFFER)
  (DOLIST (SUBNODE (CDR INFERIORS))
    (AND (TYPECASE SUBNODE
	   ((SECTION-DEFINITION-SUBNODE BUFFER-DEFINITION-SUBNODE)
	     (EQ (SEND SUBNODE :BUFFER) BUFFER)))
	 (LET ((PATHNAME (SEND BUFFER ':SEND-IF-HANDLES ':PATHNAME)))
	   (AND PATHNAME
		(SEND SELF ':ADD-NODE-BEFORE-NODE SUBNODE
		      'FILE-DEFINITION-SUBNODE ':PATHNAME PATHNAME
		      ':FUNCTION-SPEC (SEND SUBNODE ':FUNCTION-SPEC)
		      ':DEFINITION-TYPE (SEND SUBNODE ':DEFINITION-TYPE)))
	   (SEND SELF ':DELETE-NODE SUBNODE)))))

;;; This gets called whenever a buffer is sectionized, it takes account of new or changed
;;; definitions, etc.
(DEFMETHOD (:BUFFER-SECTIONIZED DEFINITIONS-EDITING-BUFFER)
	   (BUFFER &OPTIONAL (CONTAINING-BUFFER BUFFER))
  (LET ((SECTIONS-ALREADY-KNOWN NIL)
	BUFFER-P)
    (DOLIST (SUBNODE (CDR INFERIORS))
      (COND ((TYPEP SUBNODE 'SECTION-DEFINITION-SUBNODE)
	     (PUSH (SEND SUBNODE ':SECTION) SECTIONS-ALREADY-KNOWN))
	    ((OR (SETQ BUFFER-P (TYPEP SUBNODE 'BUFFER-DEFINITION-SUBNODE))
		 (TYPEP SUBNODE 'FILE-DEFINITION-SUBNODE))
	     (WHEN (IF BUFFER-P (EQ (SEND SUBNODE ':BUFFER) CONTAINING-BUFFER)
				(EQ (SEND (SEND SUBNODE ':PATHNAME) :TRANSLATED-PATHNAME)
				    (SEND BUFFER ':SEND-IF-HANDLES ':PATHNAME)))
	       ;; If we just did this subnode, do it or anything resulting from it again
	       (IF (BP-= (SEND SELF ':POINT) (INTERVAL-LAST-BP SUBNODE))
		   (MOVE-BP (SEND SELF ':POINT) (INTERVAL-FIRST-BP SUBNODE)))
	       ;; Any sections (other than lookalike sections) that we just discovered go
	       ;; in place of this file, before anything resulting from other files
	       (LOOP WITH TARGET-TYPE = (SEND SUBNODE ':DEFINITION-TYPE)
		     WITH FUNCTION-SPEC = (SEND SUBNODE ':FUNCTION-SPEC)
		     WITH SECTION-FOUND = NIL
		     FOR (TYPE SECTION) IN (SI:FUNCTION-SPEC-GET FUNCTION-SPEC 'ZMACS-BUFFERS)
		     WHEN (AND (NOT (MEMQ SECTION SECTIONS-ALREADY-KNOWN))
			       (OR (EQ TYPE TARGET-TYPE)
				   (MEMQ TARGET-TYPE (GET TYPE 'IMPLIED-TARGET-TYPE))
				   (NULL (GET TYPE 'SI:DEFINITION-TYPE-NAME)))
			       (EQ (INTERVAL-HOME-BUFFER SECTION CONTAINING-BUFFER) CONTAINING-BUFFER))
		       DO (SEND SELF ':ADD-NODE-BEFORE-NODE SUBNODE
				      'SECTION-DEFINITION-SUBNODE
				      ':FUNCTION-SPEC FUNCTION-SPEC
				      ':DEFINITION-TYPE TYPE
				      ':SECTION SECTION
				      ':BUFFER CONTAINING-BUFFER)
			  (PUSH SECTION SECTIONS-ALREADY-KNOWN)
			  (SETQ SECTION-FOUND T)
		     FINALLY 
		       ;; If a file was read in but no sections were found in it,
		       ;; convert it into a buffer so we will resectionize it
		       ;; (uselessly) and then do a textual search
		       (OR SECTION-FOUND BUFFER-P
			   (SEND SELF ':ADD-NODE-BEFORE-NODE SUBNODE
				       'BUFFER-DEFINITION-SUBNODE
				       ':FUNCTION-SPEC FUNCTION-SPEC
				       ':DEFINITION-TYPE TARGET-TYPE
				       ':BUFFER CONTAINING-BUFFER))
		       ;; Delete this file//buffer subnode if we replaced it with anything
		       (IF (OR SECTION-FOUND (NOT BUFFER-P))
			   (SEND SELF ':DELETE-NODE SUBNODE)))))))
    ;; Now collect any other newly-discovered sections, normal or lookalike, and insert
    ;; them at the right place.
    (LET ((FIRST-VAGUE-SUBNODE (DOLIST (SUBNODE (CDR INFERIORS))
				 (OR (TYPEP SUBNODE 'SECTION-NODE) (RETURN SUBNODE)))))
      (DOLIST (SECTION (BUFFER-SECTIONS BUFFER))
	(AND (TYPEP SECTION 'SECTION-NODE)
	     (NOT (MEMQ SECTION SECTIONS-ALREADY-KNOWN))
	     (LET ((SECTION-FUNCTION-SPEC (SECTION-NODE-FUNCTION-SPEC SECTION)))
	       (OR (MEMBER SECTION-FUNCTION-SPEC FUNCTION-SPECS)
		   (AND LOOKALIKES-ALLOWED (SYMBOLP SECTION-FUNCTION-SPEC)
			(LOOP FOR FSPEC IN FUNCTION-SPECS
			      THEREIS (AND (SYMBOLP FSPEC)
					   (STRING= FSPEC SECTION-FUNCTION-SPEC))))))
	     (OR (NULL ALLOWED-DEFINITION-TYPES)
		 (LET ((TYPE (SECTION-NODE-DEFINITION-TYPE SECTION)))
		   (OR (MEMQ TYPE ALLOWED-DEFINITION-TYPES)
		       (NULL (GET TYPE 'SI:DEFINITION-TYPE-NAME)))))
	     (LET ((NODE (SEND SELF ':ADD-NODE-BEFORE-NODE FIRST-VAGUE-SUBNODE
			       'SECTION-DEFINITION-SUBNODE
			       ':FUNCTION-SPEC (SECTION-NODE-FUNCTION-SPEC SECTION)
			       ':DEFINITION-TYPE (SECTION-NODE-DEFINITION-TYPE SECTION)
			       ':SECTION SECTION
			       ':BUFFER CONTAINING-BUFFER))
		   (POINT (SEND SELF ':POINT)))
	       ;; Move point to the first new node
	       (WHEN (BP-< (INTERVAL-FIRST-BP NODE) POINT)
		 (MOVE-BP POINT (INTERVAL-FIRST-BP NODE)))))))))

;;; Some utilities that may really belong elsewhere.



(DEFUN NEWEST-TYPED-PATHNAME (PATHNAME)
  (LET ((FILE-TYPE (SEND PATHNAME ':CANONICAL-TYPE)))
    (SEND PATHNAME ':NEW-PATHNAME ':TYPE (OR FILE-TYPE ':LISP) ':VERSION ':NEWEST)))

(DEFUN FUNCTION-SPEC-NAME (FSPEC &OPTIONAL (DTYPE 'DEFUN))
  (FORMAT NIL "~A ~S"
	  (CL:GET DTYPE 'SI:DEFINITION-TYPE-NAME (CL:STRING-CAPITALIZE (STRING DTYPE)))
	  FSPEC))



;--- Should be an interface exported by the flavor system
(DEFUN GENERIC-FUNCTION-METHODS (GENERIC-FUNCTION-NAME)
  (LOOP WITH GF = (FLAVOR:FIND-GENERIC-FUNCTION GENERIC-FUNCTION-NAME)
	FOR FLAVOR IN (SYS:GENERIC-FUNCTION-FLAVORS GF)
	AS FL = (FLAVOR:FIND-FLAVOR FLAVOR NIL)
	WHEN FL
	  APPEND (LOOP FOR MH IN (CDR (ASSOC GENERIC-FUNCTION-NAME
					     (FLAVOR::FLAVOR-METHOD-TABLE FL)))
		       AS METHOD = (FLAVOR::METHOD-HOLDER-FUNCTION-SPEC MH)
		       UNLESS (EQ (FLAVOR:METHOD-TYPE METHOD) 'FLAVOR:COMBINED)
			 COLLECT METHOD)))

(DEFCOM COM-EDIT-DEFINITION-AND-OTHER-DEFINITIONS
	"Prepares to edit the definition of a specified function.
It prompts for a function name from the minibuffer.  Name completion is
available for definitions in files that have already been loaded into buffers.
You can select a function name by clicking the mouse over function names in
the current buffer.  It selects the buffer containing the definition for that
function, first reading in the file if necessary.  With a numeric argument, it
selects the next definition satisfying the most recent name given.  " ()
  (IF (NOT *NUMERIC-ARG-P*)
      (LET ((FSPECS (READ-FUNCTION-SPECS-TO-EDIT :GENERIC-FUNCTIONS-ALLOWED T)))
	(SEND *ZMACS-COMMAND-LOOP* ':SETUP-FUNCTION-SPECS-TO-EDIT
	      FSPECS NIL T T NIL))
    (EDIT-NEXT-FUNCTION-SPEC))
  DIS-NONE)

(DEFCOM COM-EDIT-DEFINITION
	"Prepares to edit the definition of a specified function.
It prompts for a function name from the minibuffer.  Name completion is
available for definitions in files that have already been loaded into buffers.
You can select a function name by clicking the mouse over function names in
the current buffer.  It selects the buffer containing the definition for that
function, first reading in the file if necessary.

With a numeric argument, it prompts a second time for one or more specific
definition types.  "
	()
  (LET* ((FSPECS (READ-FUNCTION-SPECS-TO-EDIT))
	 (DEFINITION-TYPES
	   (AND *NUMERIC-ARG-P*
	        (TYPEIN-LINE-ACCEPT
		  `(DW:TOKEN-OR-TYPE (("Any" . NIL))
		     (CL:SEQUENCE (SI:DEFINITION-TYPE-NAME ,(FIRST FSPECS))))
		  :DEFAULT NIL))))
    (SEND *ZMACS-COMMAND-LOOP* ':SETUP-FUNCTION-SPECS-TO-EDIT
	      FSPECS DEFINITION-TYPES T T NIL))
  DIS-NONE)

(DEFCOM COM-EDIT-INSTALLED-DEFINITION
	"Like Edit Definition, except that it edits the installed definition
rather than the most recent definition." ()
  (IF (NOT *NUMERIC-ARG-P*)
      (LET ((FSPECS (READ-FUNCTION-SPECS-TO-EDIT)))
	(SEND *ZMACS-COMMAND-LOOP* ':SETUP-FUNCTION-SPECS-TO-EDIT
	      FSPECS NIL T T T))
      (EDIT-NEXT-FUNCTION-SPEC))
  DIS-NONE)


(DEFCOM COM-LIST-ALL-DEFINITIONS
	"Like Edit Definition, but lists all the different definitions
in the typeout window." ()
  (LET ((FSPECS (READ-FUNCTION-SPECS-TO-EDIT)))
    (SEND *ZMACS-COMMAND-LOOP* ':SETUP-FUNCTION-SPECS-TO-EDIT
	      FSPECS NIL NIL T NIL))
  (SEND *ZMACS-DEFINITIONS-BUFFER* :LIST-POSSIBILITIES NIL)
  DIS-NONE)

;(TV:ADD-TYPEOUT-ITEM-TYPE *TYPEOUT-COMMAND-ALIST* FUNCTION-NAME "Edit" EDIT-DEFINITION T
;			  "Edit this function.")

;;; Same as si:edit-definition but produces a Zmacs command instead of a CP command
(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR EDIT-DEFINITION
			     (SYS:EXPRESSION "Edit definition" *ZMACS-COMTAB*
			      :GESTURE :SELECT)
			     (EXPRESSION)
  (MULTIPLE-VALUE-BIND (FUNCTION-SPEC DEFINITION-TYPE)
      (EXPRESSION-TO-FUNCTION-SPEC EXPRESSION NIL T NIL NIL T)
    (WHEN FUNCTION-SPEC
      (IF DEFINITION-TYPE
	  `(EDIT-DEFINITION ,FUNCTION-SPEC (,DEFINITION-TYPE))
	  `(EDIT-DEFINITION ,FUNCTION-SPEC NIL)))))

;;; Provide the same functionality for Zwei contexts outside the editor (Zmail,
;;; Converse, freestanding editors): make the :EDIT-FUNCTION gesture (usually #\m-Left)
;;; on a function spec, to do the equivalent of :Edit Definition <#\c-Middle on spec>.
(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR ZMACS-EDIT-CODE-FRAGMENT
   (SYS:EXPRESSION
     "Edit definition" *STANDARD-COMTAB*
     :GESTURE :EDIT-FUNCTION)
   (EXPRESSION &KEY PRESENTATION)
  (MULTIPLE-VALUE-BIND (FUNCTION-SPEC DEFINITION-TYPE)
      (EXPRESSION-TO-FUNCTION-SPEC EXPRESSION NIL T NIL PRESENTATION)
    (WHEN FUNCTION-SPEC
      `(ED (EDIT-DEFINITION ,FUNCTION-SPEC ,(AND DEFINITION-TYPE (LIST DEFINITION-TYPE)))))))

;;; K-L-U-D-G-E
(cl:defparameter *EDIT-DEFINITION-VIA-MENUS* nil)

(DEFUN EDIT-DEFINITION (FSPEC &OPTIONAL (ALLOWED-DEFINITION-TYPES '(DEFUN)) OK-TO-ASK)
  (COND ((STRINGP FSPEC)
	 (MULTIPLE-VALUE-BIND (NEW-FSPEC ERROR-P)
	     (SYMBOL-FROM-STRING FSPEC NIL OK-TO-ASK)
	   (IF ERROR-P (BARF "~S is not a valid function spec name" FSPEC)
	       (SETQ FSPEC NEW-FSPEC)))))
  (LET-IF (NOT (OPERATION-HANDLED-P STANDARD-OUTPUT :SUPERIOR))
	  ;; if this isn't the real window system, do it the old way
	  ((*EDIT-DEFINITION-VIA-MENUS* NIL))
    (COND (*EDIT-DEFINITION-VIA-MENUS*
	   ;; wants menuized behavior
	   (SEND *ZMACS-COMMAND-LOOP* :SETUP-FUNCTION-SPECS-TO-EDIT
		 (LIST FSPEC) ALLOWED-DEFINITION-TYPES NIL)
	   #-IGNORE (BARF "Sorry, editing definitions via menus is not yet available.")
	   #+IGNORE (EDIT-DEFINITION-VIA-MENUS))
	  (T
	   (SEND *ZMACS-COMMAND-LOOP* ':SETUP-FUNCTION-SPECS-TO-EDIT
		 (LIST FSPEC) ALLOWED-DEFINITION-TYPES))))
  NIL)

;;; This returns a list of function specs to edit (or do anything else with)
(DEFUN READ-FUNCTION-SPECS-TO-EDIT (&KEY
				    (PROMPT-STRING "Edit definition")
				    (PACKAGE-LOOKALIKE *ENABLE-PACKAGE-DWIM*)
				    GENERIC-FUNCTIONS-ALLOWED)
  (LET* ((DEFAULT (RELEVANT-FUNCTION-NAME (POINT) NIL :ANY))
	 (TYPE (IF GENERIC-FUNCTIONS-ALLOWED
		   '((OR ((SYS:FUNCTION-SPEC :DEFINED-P :ANY))
			 ;;--- :DEFINED-P :ANY prevents completion from working!
			 SYS:GENERIC-FUNCTION-NAME
			 CLOS:GENERIC-FUNCTION-NAME))
		 '((SYS:FUNCTION-SPEC :DEFINED-P :ANY))))
	 (FSPEC (TYPEIN-LINE-ACCEPT TYPE
				    :DEFAULT DEFAULT
				    :PROMPT PROMPT-STRING)))
    (LET ((OTHERS (AND PACKAGE-LOOKALIKE
		       (SYMBOLP FSPEC)
		       ;; Don't do package DWIM if the user explicitly typed in
		       ;; a package name different from the current package, or
		       ;; if he took the default.
		       (AND (EQ PACKAGE (SYMBOL-PACKAGE FSPEC))
			    (NEQ FSPEC DEFAULT))
		       (PACKAGE-LOOKALIKE-SYMBOLS FSPEC))))
      (CONS FSPEC (DELQ FSPEC OTHERS)))))

;;; If ALLOWED-DEFINITION-TYPES is NIL, then all are allowed.
;;; FUNCTION-SPECS should be a list of "lookalikes".
(DEFMETHOD (:SETUP-FUNCTION-SPECS-TO-EDIT ZMACS-EDITOR)
	   (FUNCTION-SPECS &OPTIONAL (ALLOWED-DEFINITION-TYPES NIL)
				     (START-EDITING T)
				     (LOOKALIKES-ALLOWED NIL)
				     (EDIT-INSTALLED-DEFINITION-P NIL))
  (SETQ *ZMACS-DEFINITIONS-BUFFER* (SEND SELF ':FIND-SPECIAL-BUFFER ':DEFINITIONS T
					 ':SET-FUNCTION-SPECS FUNCTION-SPECS
					 ':SET-ALLOWED-DEFINITION-TYPES
					   ALLOWED-DEFINITION-TYPES
					 ':SET-LOOKALIKES-ALLOWED
					   LOOKALIKES-ALLOWED
					 ':SET-EDIT-INSTALLED-DEFINITION-P
					   EDIT-INSTALLED-DEFINITION-P
					 ':SET-COMMAND-LOOP
					   *CURRENT-COMMAND-LOOP*))
  (AND START-EDITING (EDIT-NEXT-FUNCTION-SPEC)))

(DEFUN EDIT-NEXT-FUNCTION-SPEC ()
  (AND (NULL *ZMACS-DEFINITIONS-BUFFER*)
       (BARF "No more definitions."))
  (MULTIPLE-VALUE-BIND (BP BUFFER)
      (SEND *ZMACS-DEFINITIONS-BUFFER* ':NEXT-DEFINITION)
    (POINT-PDL-PUSH (POINT) *WINDOW* T)
    ;; Position at top of window
    (MAKE-BUFFER-CURRENT BUFFER)
    ;; Back up version controlled buffers so bubble diagram line is exposed
    (RECENTER-WINDOW *WINDOW* ':START (IF (BUFFER-VERSION-CONTROLLED-P BUFFER)
					  (NODE-FIRST-BP (BP-TOP-LEVEL-NODE BP))
					  (BACKWARD-OVER-COMMENT-LINES BP NIL)))
    (MOVE-POINT BP)))

;;; Called with something that we got handed out of the source locators.  Who knows how
;;; old it is.  Be sure that it's gonna be okay to move point there.  An edit-definition
;;; was just done to the right place, so it should be within that interval.
(DEFUN VALIDATE-BP-FOR-CURRENT-SECTION (BP)
  (AND (EQ (INTERVAL-BUFFER (BP-TOP-LEVEL-NODE BP)) *INTERVAL*)
       (NEQ (LINE-TICK (BP-LINE BP)) 'DELETED)
       ( (BP-INDEX BP) (BP-INDEX (END-OF-LINE (BP-LINE BP))))
       (LET ((NODE (SEND (SEND *INTERVAL* :MAJOR-MODE) :DEFINITION-INTERVAL (POINT) T)))
	 (AND NODE
	      (LOOP WITH TARGET = (BP-LINE BP)
		    AND END-LINE = (BP-LINE (INTERVAL-LAST-BP NODE))
		    FOR LINE = (BP-LINE (INTERVAL-FIRST-BP NODE)) THEN (LINE-NEXT LINE)
		    THEREIS (EQ LINE TARGET)
		    UNTIL (EQ LINE END-LINE))))))
