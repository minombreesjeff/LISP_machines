;;; -*- Mode: LISP; Package: ZWEI; Base: 10; Lowercase: Yes -*-
;;; Character style hacking function and commands
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Change the character style in the given area
(defun change-style-interval (start-bp &optional end-bp in-order-p
						 (style (si:index-character-style *style*)))
  ;;--- Remove this in Release 8
  (when (numberp style)
    (setq style (si:index-character-style style)))
  (get-interval start-bp end-bp in-order-p)
  (with-interval-write-locked (start-bp end-bp t)
    (mung-bp-interval start-bp)
    (with-undo-save ("change character style" start-bp end-bp t)
      (change-style-interval-internal start-bp end-bp t style)))
  dis-text)

(defun change-style-interval-internal (start-bp &optional end-bp in-order-p style)
  (let ((style (si:style-index style t)))
    (get-interval start-bp end-bp in-order-p)
    (do ((line (bp-line start-bp) (line-next-in-buffer line))
	 (limit-line (bp-line end-bp))
	 (start-index (bp-index start-bp) 0)
	 (last-line-p))
	(nil)
      (setq last-line-p (eq line limit-line))
      (or (zerop style) (string-fat-p line)
	  (setq line (set-line-array-type line 'art-fat-string)))
      (mung-line line)
      (let ((line line))
	(declare (sys:array-register line))
	(do ((index start-index (1+ index))
	     (limit-index (if last-line-p (bp-index end-bp) (line-length line))))
	    (( index limit-index))
	  (setf (si:char-style-index (aref line index)) style)))
      (and last-line-p (return nil)))))

(defun change-one-style-interval (start-bp &optional end-bp in-order-p from-style to-style)
  (let ((from-style (si:style-index from-style))
	(to-style (si:style-index to-style t)))
    (get-interval start-bp end-bp in-order-p)
    (with-interval-write-locked (start-bp end-bp t)
      (mung-bp-interval start-bp)
      (with-undo-save ("change character style" start-bp end-bp t)
	(do ((line (bp-line start-bp) (line-next-in-buffer line))
	     (limit-line (bp-line end-bp))
	     (start-index (bp-index start-bp) 0)
	     (last-line-p))
	    (nil)
	  (setq last-line-p (eq line limit-line))
	  (or (zerop to-style) (string-fat-p line)
	      (setq line (set-line-array-type line 'art-fat-string)))
	  (setq line (mung-line line))
	  (let ((line line))
	    (declare (sys:array-register line))
	    (do ((index start-index (1+ index))
		 (limit-index (if last-line-p (bp-index end-bp) (line-length line))))
		(( index limit-index))
	      (let ((ch (aref line index)))
		(when (= (si:char-style-index ch) from-style)
		  (setf (si:char-style-index ch) to-style)
		  (setf (aref line index) ch)))))
	  (and last-line-p (return nil))))))
  dis-text)

(defun merge-style-interval (start-bp &optional end-bp in-order-p
						(style (si:index-character-style *style*)))
  (get-interval start-bp end-bp in-order-p)
  (with-interval-write-locked (start-bp end-bp t)
    (mung-bp-interval start-bp)
    (with-undo-save ("merge character style" start-bp end-bp t)
      (merge-style-interval-internal start-bp end-bp t style)))
  dis-text)

(defun merge-style-interval-internal (start-bp &optional end-bp in-order-p style)
  (get-interval start-bp end-bp in-order-p)
  (do ((line (bp-line start-bp) (line-next-in-buffer line))
       (limit-line (bp-line end-bp))
       (start-index (bp-index start-bp) 0)
       (last-line-p))
      (nil)
    (setq last-line-p (eq line limit-line))
    (or (zerop (si:style-index style t)) (string-fat-p line)
	(setq line (set-line-array-type line 'art-fat-string)))
    (mung-line line)
    (let ((line line))
      (declare (sys:array-register line))
      (do ((index start-index (1+ index))
	   (limit-index (if last-line-p (bp-index end-bp) (line-length line))))
	  (( index limit-index))
	(let* ((old-style (si:index-character-style
			    (si:char-style-index (aref line index))))
	       (new-style
		 ;; The idea of merging instead of setting is to preserve
		 ;; whatever style components the char had.
		 (si:merge-character-styles old-style style))
	       (new-style-num (si:style-index new-style t)))
	(setf (si:char-style-index (aref line index)) new-style-num))))
    (and last-line-p (return nil))))


(defun update-style-name ()
  (let ((style-id *style*))
    (setq *style-name*
	  (unless (zerop style-id)
	    (let ((style (aref si:*character-style-index-table* style-id)))
	      (when style
		(si:string-for-style-name style :in-brackets T)))))))

;;I guess there's no reason to move this to DEFS.
(defvar *last-input-character-style-name* si:*null-style*
  "Used by INPUT-STYLE-NAME to remember the last style named")

;; Newer character-style input paradigm, optionally using single-key accelerators

;;hash table for the accelerators used in "Quick" mode of prompting for new style
(defvar *character-style-dispatch-table* (make-hash-table))

(defsubst character-style-dispatch (char)
  (gethash (char-upcase char) *character-style-dispatch-table*))

(defsubst set-character-style-dispatch (char style)
  (setf (character-style-dispatch char) (si:parse-character-style style)))

;;define a pretty intuitive default set of accelerators
(defun initialize-character-style-dispatch-set ()
  (set-character-style-dispatch #\b '(nil :bold        nil))
  (set-character-style-dispatch #\i '(nil :italic      nil))
  (set-character-style-dispatch #\p '(nil :bold-italic nil))
  (set-character-style-dispatch #\n '(nil nil          nil))
  (set-character-style-dispatch #\s '(nil nil          :smaller))
  (set-character-style-dispatch #\l '(nil nil          :larger))
  )

(add-initialization "Set default quick-character-style accelerators"
		    '(initialize-character-style-dispatch-set) '(:once))

(defun quick-character-style-default-dispatch-default ()
  (maphash #'(lambda (char style)
	       (if (eql style *last-input-character-style-name*)
		   (return-from quick-character-style-default-dispatch-default char)))
	   *character-style-dispatch-table*))

;;Called by the various commands (c-J, m-J, etc.)
;;Prompts if necessary for a new character style, in a manner determined by
;; *CHANGE-STYLE-MODE* : either in the minibuffer, for a full character-style spec,
;; or using dispatch accelerators.
(defun input-style-name (use-previous-p &optional (prompt "") &rest format-args)
  (block result
    (flet ((read-full-style (&optional (prompt prompt) &rest fmt-args)
	     (let ((format-args (or fmt-args format-args)))
	       (read-character-style (if format-args
					 (format () "~?" prompt format-args)
				       prompt)
				     :default si:*null-style*)))
	   (lose (ch) (barf "~:C is not a valid character style dispatch character." ch))
	   (get-char ()
	     (dw:with-presentation-input-context
		((let ((sheet (window-sheet *window*)))
		   `((scl:character-style-for-device
		       :device ,(send sheet :display-device-type)
		       :against-default ,(send sheet :default-character-style)))))
		(blip)
		  (let ((dw:*allow-sensitive-raw-text-override* t))
		    (read-argument-character-with-possible-prompt-and-presentation-context
		      t "~:|~?~:[~; [default ~@[~:C  ~]~A]~]: "
		      prompt format-args *last-input-character-style-name*
		      (quick-character-style-default-dispatch-default)
		      *last-input-character-style-name*))
		(t
		  (return-from result
		    (dw:presentation-blip-object blip)))))
	   (typein-line-more-if-exposed (prompted-p format-string &rest format-args)
	     (when (and prompted-p (send *typein-window* :exposed-p))
	       (lexpr-funcall #'typein-line-more format-string format-args))))
      (unless (and use-previous-p
		   (eq *last-command-type* 'style-change)
		   *last-input-character-style-name*)
	(setq *last-input-character-style-name*
	      (if (eql *change-style-mode* :prompt-for-name)
		  (read-full-style)
		(multiple-value-bind (ch prompt-printed-p) (get-char)
		  (loop until (not (char= ch #\help))
			as l = nil
			do (maphash #'(lambda (x y) (push (list x y) l))
				    *character-style-dispatch-table*)
			   (format t "~&Use a defined character-style dispatch D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")char0,~@
                                      ~T or use Meta-1char0 to (re)define a 1char0.")
			   (when l
			     (setq l (sortcar l 'alphalessp))
			     (format t "~&The presently defined dispatch characters are:~@
				      ~T1Char0  1Style0~:{~
				 ~%  ~:C~6T~A~}~%" l))
			   (format t "~&~:C prompts for a full style, and uses it once~@
                                      ~T without defining a dispatch character.~@
				      ~:C or ~:C uses the default.~@
                                      ~:C uses the null style.~@
                                      ~:C or ~:C or ~:C aborts the command."
				   #\escape #\space #\return #\end #\abort #\rubout #\c-g)
			   (cl:multiple-value-setq (ch prompt-printed-p) (get-char)))
		  (cond ((or (char= ch #\space)
			     (char= ch #\return)
			     (char= ch *last-command-char*))
			 (typein-line-more-if-exposed
			   prompt-printed-p "~A" *last-input-character-style-name*)
			 *last-input-character-style-name*)
			((char= ch #\end)
			 (typein-line-more-if-exposed prompt-printed-p "~A" si:*null-style*)
			 (setq *last-input-character-style-name* si:*null-style*))
			((char= ch #\escape)
			 (read-full-style))
			((or (char= ch #\abort)
			     (char= ch #\control-g)
			     (char= ch #\rubout))
			 (typein-line "~:|")
			 (signal 'sys:abort))
			((or (char-bit ch :control)
			     (char-bit ch :super)
			     (char-bit ch :hyper))
			 (lose ch))
			((char-bit ch :meta)
			 (setf (character-style-dispatch (set-char-bit ch :meta nil))
			       (read-full-style "Redefine ~:C as character style"
						(char-upcase (set-char-bit ch :meta nil)))))
			(t
			 (let ((style (character-style-dispatch ch)))
			   (cond ((not style)
				  (setf (character-style-dispatch ch)
					(read-full-style "Define ~:C as character style"
							 (char-upcase ch))))
				 (t
				  (typein-line-more-if-exposed
				    prompt-printed-p "~C" (char-upcase ch))
				  (setq *last-input-character-style-name* style))))))))))    
      (setq *current-command-type* 'style-change)
      *last-input-character-style-name*)))

(defun read-character-style (prompt &key default)
  (typein-line-accept `((scl:character-face-or-style
			  :device ,si:*b&w-screen*
			  :against-default ,(send (window-sheet *window*)
						  :default-character-style)))
		      :prompt prompt :default default))


;;; See if there are any fat characters in the interval.
(defun interval-fat-p (from-bp &optional to-bp in-order-p)
  (get-interval from-bp to-bp in-order-p)
  (let ((from-line (bp-line from-bp))
	(to-line (bp-line to-bp)))
    (loop named outer
	  for line = (bp-line from-bp) then (line-next-in-buffer line)
	  while line
	  do
      (when (string-fat-p line)
	(let ((first-index (if (eq line from-line)
			       (bp-index from-bp)
			       0))
	      (last-index (if (eq line to-line)
			      (bp-index to-bp)
			      (line-length line)))
	      (line line))
	  (declare (sys:array-register line))
	  (loop for i from first-index below last-index
		for ch = (aref line i)
		when (char-fat-p ch)
		  do (return-from outer t))))
      (when (eq line to-line)
	(loop-finish)))))


;;Needed to provide largely common documentation for change-style commands.
(defvar *change-style-documentation-individual-strings-alist*
	'((com-change-style-char
	    "Change the character style of one or more characters forward.")
	  (com-change-style-word
	    "Change the character style of one or more words forward.")
	  (com-change-style-region
	    "Change the character style between point and the mark."
	    "With a numeric argument, merges against the specified character style.")
	  (com-merge-style-region
	    "Merge the character style between point and the mark.")
	  (com-change-one-style-region
	"Change characters of one character style into another between point and the mark.")
	  (com-change-typein-style
	    "Set the character style for newly inserted characters.")))

;;Common doc function for the change-style commands.
(defun document-change-style (command ignore type)
  (selectq type
    (:name (get command 'command-name))
    ((:full :short)
     (funcall standard-output :line-out
	      (second (assq command  *change-style-documentation-individual-strings-alist*)))
     (when (eq type ':full)
       (let ((rest
	       (third (assq command  *change-style-documentation-individual-strings-alist*))))
	 (when rest
	   (funcall standard-output :line-out rest)))
       (funcall standard-output :line-out
		(if (eql *change-style-mode* :prompt-for-name)
		    "Prompts in the minibuffer for the name of the new character style."
		  "Reads a dispatch character in the echo area.
 A normal character prompts for a character style if undefined,
   then uses that character style thereafter.
 A Meta-character forces redefinition of the character.
 ESCAPE prompts for a character style in the minibuffer, but doesn't remember it on any key.
 SPACE or RETURN accepts the default.
 END uses the null character style.
 RUBOUT or c-G cancels the command."))
       (funcall standard-output :line-out
		"
Change the variable ZWEI:*CHANGE-STYLE-MODE* (using m-X Set Variable) to get")
       (funcall standard-output :string-out
		(if (eql *change-style-mode* :prompt-for-name)
		    "quick" "full character style name"))
       (funcall standard-output :string-out " prompting.")))))

;;Commonly c-J
(defcom com-change-style-char document-change-style ()
  (let ((bp1 (forward-char (point) *numeric-arg* t *interval*)))
    (change-style-interval (point) bp1 nil
			   (input-style-name t
			     "Change style of ~:[~D~:* ~]character~P to"
			     (= *numeric-arg* 1) *numeric-arg*))
    (move-point bp1)
    dis-text))

;;Commonly c-sh-J
(defcom com-show-character "Show the font of the current character."
	(km)
  (let ((standard-output *typein-window*))
    (send standard-output :clear-window)
    (describe (bp-char (point))))
  dis-none)
  
;;Commonly m-J
(defcom com-change-style-word document-change-style ()
  (let ((bp1 (forward-word (point) *numeric-arg* t *interval*)))
    (change-style-interval (point) bp1 nil
			   (input-style-name t
			     "Change character style of ~:[~D~:* ~]word~P to"
			     (= *numeric-arg* 1) *numeric-arg*))
    (and (plusp *numeric-arg*) (move-point bp1))
    dis-text))

;; If anything more general is done about requiring a visible region in order to do
;; region-based operations, this should be merged into it and removed.
(defvar *require-real-region-for-style-change* nil)

;;Commonly c-X c-J
(defcom com-change-style-region document-change-style ()
  (when (and *require-real-region-for-style-change* (not (window-mark-p *window*)))
    (barf))
  (if *numeric-arg-p*
      (com-merge-style-region)
    (definition-region (bp1 bp2)
      (change-style-interval bp1 bp2 t
			     (input-style-name nil "Change character style of region to")))))

(defcom com-merge-style-region document-change-style ()
  (when (and *require-real-region-for-style-change* (not (window-mark-p *window*)))
    (barf))
  (definition-region (bp1 bp2)
    (merge-style-interval bp1 bp2 t
			  (input-style-name nil "Merge character style of region against"))))

;;Best assigned to some mouse click.  Which?
;;This is an accelerator for [right] [Change Style Region] [point at char]
(defcom com-mouse-change-style-region
	"Change character style between point and the mark to that of the character 
pointed to by the mouse" ()
  (definition-region (bp1 bp2)
    (let ((char (bp-char (mouse-bp *window* *mouse-x* *mouse-y*))))
      (typein-line "~A" (si:char-style char))
      (change-style-interval bp1 bp2 T
			     (si:index-character-style (si:char-style-index char)))))
  dis-text)

;;Commonly "Not available in the current context"
(defcom com-change-one-style-region document-change-style ()
  (let* ((from-style (input-style-name nil
		       "Change region's characters of style"))
	 (to-style (input-style-name nil
		     (format nil "Change ~A in region to style" from-style))))
    (definition-region (bp1 bp2)
      (change-one-style-interval bp1 bp2 t from-style to-style))))

;;Commonly c-m-J
(defcom com-change-typein-style document-change-style ()
  (let ((new-style (input-style-name nil "Set typein character style to")))
    (setq *style* (si:style-index new-style t))
    (when (zmacs-buffer-p *interval*)
      (setf (buffer-typein-character-style *interval*) new-style)))
  (update-style-name)
  dis-bps)					;This may change the size of the blinker


(defcom com-find-character-in-style 
  "Search forward for the next character in a given character style." ()
  (let* ((style (read-character-style "Find character in style"))
	 (style-index (barf-on-errors (error)
			(si:style-index style))))
    (charmap ((forward-char (point) 1 t) (interval-last-bp *interval*))
      (when (= (si:char-style-index (charmap-char)) style-index)
	(maybe-push-point (prog1 (copy-bp (point))
				 (move-point (charmap-bp-before))))
	(return-from com-find-character-in-style dis-bps)))
    (barf "No character in style ~A found." style)))

(defcom com-show-character-styles
	"Show all character styles used in the region, or in the whole buffer
if there is no region.  For each character style used, display its
name, the font used to display characters in that style on this window,
a sample piece of canned text in that style, and a sample piece of
text that actually appears in the buffer in that style.
Clicking on a character style shows all lines containing text in that style.
Clicking on a font shows all characters in that font.
Clicking on a piece of sample text from the buffer jumps to it." (km)
  (if (window-mark-p *window*)
      (format *typeout-window* "~&Character styles used in region:~%")
      (format *typeout-window* "~&Character styles used in ~\presentation\~%" *interval*))
  (display-character-styles (if (window-mark-p *window*)
				(collect-character-styles-in-interval (point) (mark))
				(collect-character-styles-in-interval *interval*))
			    (send (window-sheet *window*) :default-character-style))
  dis-none)

;;; Collect all character styles used in interval
;;; With each style is a sample, some substring of a line
;;; The first one found at least 15 characters long, or the longest found, is used
;;; Results are in the order of first appearance of the style in the interval
(defun collect-character-styles-in-interval (from-bp &optional to-bp in-order-p ignore-nongraphics)
  (get-interval from-bp to-bp in-order-p)
  (let ((table nil))				; list of elements (character-style line from-index to-index)
    (linemap (from-bp to-bp table)
      (flet ((do-segment (from to)
	       (when ignore-nongraphics
		 ;; Ignore non-graphic characters (especially tabs)
		 (loop while (> to from)
		       until (graphic-char-p (aref line from))
		       do (incf from))
		 (loop while (> to from)
		       until (graphic-char-p (aref line (1- to)))
		       do (decf to)))
	       ;; Ignore blank lines and otherwise empty segments
	       (when (> to from)
		 (let* ((character-style (si:char-style (aref line from)))
			(elem (assq character-style table)))
		   (cond ((null elem) (push (list character-style line from to) table))
			 ((and (> (- to from) (- (fourth elem) (third elem)))
			       (< (- (fourth elem) (third elem)) 15))
			  (setf (second elem) line)
			  (setf (third elem) from)
			  (setf (fourth elem) to)))))))
	(if (string-fat-p line)
	    (let ((line line))
	      (declare (sys:array-register line))
	      (loop with start = *first-index* with start-style-index = -1
		    for i from *first-index* below *last-index*
		    as style-index = (si:char-style-index (aref line i))
		    do (unless (= style-index start-style-index)
			 (do-segment start i)
			 (setq start i start-style-index style-index))
		    finally (do-segment start i)))
	    (do-segment *first-index* *last-index*))))
    ;; Now nicen up the sample text for each style
    (loop with whitespace-chars = *whitespace-chars*
	  for (character-style line from-index to-index) in (nreverse table)
	  do (setq from-index (or (string-search-not-set whitespace-chars
							 line from-index to-index)
				  from-index)
		   to-index (or (string-reverse-search-not-set whitespace-chars
							       line from-index to-index)
				to-index))
	     (when (> (- to-index from-index) 25)
	       (setq to-index (or (string-search-set whitespace-chars
						     line (+ from-index 15) to-index)
				  to-index)))
	  collect (list character-style
			(create-bp line from-index)
			(create-bp line to-index)))))

(defun show-lines-containing-character-style (character-style
					      &optional (from-bp *interval*) to-bp in-order-p)
  (get-interval from-bp to-bp in-order-p)
  (cl:fresh-line)
  (let ((style-index (si:style-index character-style nil)))
    (linemap (from-bp to-bp)
      (when (> *last-index* *first-index*)
	(when (if (string-fat-p line)
		  (let ((line line))
		    (declare (sys:array-register line))
		    (loop for i from *first-index* below *last-index*
			  thereis (= (si:char-style-index (aref line i)) style-index)))
		  (eq character-style si:*null-style*))
	  (present-line line standard-output))))))

(define-presentation-to-editor-command-translator show-lines-containing-character-style
	(scl:character-style "Show lines containing character style"
	 *standard-comtab*
	 :gesture :select
	 :tester si:ignore-true)
	(x)
  `(show-lines-containing-character-style ,x))

(scl:define-presentation-type bp ()
   :expander 'dw:raw-text)

(defun display-character-styles (styles-table buffer-default-character-style)
  (let ((different-cs
	  ;; When the buffer's window has a different default character style than
	  ;; the typeout window does, save it to use for showing the buffer text
	  (and (operation-handled-p standard-output :default-character-style)
	       (neq buffer-default-character-style
		    (send standard-output :default-character-style))
	       buffer-default-character-style)))
    (cl:write-string "  ")			;indent the whole table two spaces
    (scl:formatting-table (standard-output :inter-column-spacing 13)
      (scl:formatting-column-headings ()
	(dolist (x '("Character Style" "Font" "Sample" "Buffer Text"))
	  (scl:formatting-cell () (scl:with-underlining () (princ x)))))
      (dolist (style-entry styles-table)
	(destructuring-bind (style bp1 bp2) style-entry
	  (let* ((sheet (window-sheet *window*))
		 (merged-style (si:merge-character-styles style (send sheet :default-style)))
		 (font (si:get-font (send sheet :display-device-type)
				    si:*standard-character-set* merged-style ())))
	    (scl:formatting-row ()
	      (dw:with-output-as-presentation (:object style :type (typep style))
		(scl:formatting-cell () (princ style)))
	      ;; The font, as name and sample
	      (cond (font
		     (dw:with-output-as-presentation (:object font :type (typep font))
		       (scl:formatting-cell ()
			 (scl:present font))
		       (scl:formatting-cell ()
			 (scl:with-character-style (merged-style)
			   (scl:write-string "AaBbCc")))))
		    (t
		     (scl:formatting-cell () (scl:write-string "<no font>"))
		     (scl:formatting-cell () )))	;Showing a sample would blow up.
	      ;; The BP, a sample of something actually in the buffer
	      (scl:formatting-cell ()
		(dw:with-output-as-presentation (:object bp1 :type 'bp
							 :stream standard-output)
		  ;; with-character-style-if, if I thought I could stand it.
		  (if different-cs
		      (scl:with-character-style (different-cs)
			(cl:write-string (bp-line bp1) standard-output
					 :start (bp-index bp1) :end (bp-index bp2)))
		      (cl:write-string (bp-line bp1) standard-output
				       :start (bp-index bp1) :end (bp-index bp2))))))
	    ;; When how the style prints is misleading because it suppresses package prefixes,
	    ;; put another representation of the same style on a following line.
	    ;; Too bad it can't get the mouse-sensitivity boxes to join with those on
	    ;; the first of the two lines.
	    (flet ((unusual (sym)
		     (and sym (neq sym '*) (neq (symbol-package sym) pkg-keyword-package))))
	      (when (and (neq (si:cs-family style) :device-font)
			 (or (unusual (si:cs-family style))
			     (unusual (si:cs-face style))
			     (unusual (si:cs-size style))))
		(scl:formatting-row (nil :single-column t)
		  (scl:formatting-cell ()
		    (cl:write-string " Lisp expression for this style = ")
		    (dw:with-output-as-presentation (:object style :type (typep style))
		      (prin1 (si:unparse-character-style style)))))))))))))

(defun current-font (window &optional (style-number *style*))
  (let ((sheet (window-sheet window)))
    (si:get-font (send sheet :display-device-type) nil
		 (si:merge-character-styles (aref si:*character-style-index-table*
						  style-number)
				  (send sheet :merged-current-style)))))

;;; Diagram stuff
(defun diagram-escape-convert (contents)
  (scl:with-standard-io-environment
    (multiple-value-bind (flavor index)
	(read-from-string contents)
      (let ((diagram (instantiate-diagram flavor)))
	(send diagram :set-contents contents index)
	diagram))))

(defflavor line-diagram-mixin () ()
  )

(defmethod (:string-for-file line-diagram-mixin :default) ()
  "")

(defmethod (:form-for-file line-diagram-mixin :default) ()
  `(make-instance 'invalid-line-diagram :original-contents ,(format nil "~S" (typep self))))

(defmethod (:editor-height line-diagram-mixin :default) (window line)
  line
  (send window :line-height))

(defmethod (:editor-draw line-diagram-mixin :default) (line window cursor-x cursor-y)
  line
  (multiple-value-bind (after-x after-y)
      (draw-engrayed-text window cursor-x cursor-y "Diagram: ~s" self)
    (values cursor-x cursor-y after-x after-y)))

(defmethod (:editor-insert line-diagram-mixin :default) (line index thing from to)
  (ignore line)
  (if (and (zerop index)
	   (cl:typecase thing
	     (character (char-equal thing #\cr))
	     (string (or (= from to)
			 (char-equal (aref thing (1- to)) #\Return)))
	     (interval (or (bp-= from to)
			   (zerop (bp-index to))))	1;Inserting up to prior newline.
0	     (otherwise nil)))
      :permit
      (barf "Cannot insert into a diagram line.")))

;;; Non-structural diagrams can freely be deleted and copied.
(defmethod (:editor-delete line-diagram-mixin :default) (from to)
  (ignore from to)
  nil)

(defmethod (:editor-copy line-diagram-mixin :default) ()
  self)

(defmethod (:can-draw-self-p line-diagram-mixin :default) () nil)

;;; A diagram that relates to the structure of the buffer, and so cannot
;;; be deleted or moved around.
(defflavor structural-line-diagram-mixin () ())

(defmethod (:editor-delete structural-line-diagram-mixin) (from to)
  (ignore from to)
  (when *enable-structural-diagrams*
    (barf "Cannot delete a structural diagram line.")))

(defmethod (:editor-copy structural-line-diagram-mixin) ()
  (when *enable-structural-diagrams*
    (barf "Cannot copy a structural diagram line."))
  nil)

(defflavor draw-self-diagram-mixin () ()
  (:required-methods :draw-self)
  (:documentation :mixin
   "This mixin is for use on diagrams that can draw themselves using the
generic graphics protocol. It defines a default method for :editor-draw
in terms of :draw-self.  This avoids problems trying to use the :editor-draw
methods of diagrams that use non-generic graphics on hardcopy streams."))

(defmethod (:can-draw-self-p draw-self-diagram-mixin) () t) 

(defmethod (:editor-draw draw-self-diagram-mixin) (ignore stream x y)
  (let ((height (send self :output-height stream)))
    (graphics:with-graphics-transform (stream (list 1 0 0 -1 x (+ y height)))
      (send self :draw-self stream))))

(defmethod (:output-height draw-self-diagram-mixin :default) (stream)
  (multiple-value-bind (nil nil nil nil nil top)
      (dw:continuation-output-size #'(lambda (stream)
				       (graphics:with-graphics-transform
					 (stream (list 1 0 0 -1 0 1000))
					 (send self :draw-self stream)))
				   stream)
    (+ (send stream :vsp) (round (max 1 (- 1000 (or top 1000)))))))

(defmethod (:editor-height draw-self-diagram-mixin) (stream ignore)
  (send self :output-height stream))

(defflavor cached-output-height-diagram-mixin ((height nil)) ()
  (:documentation :mixin "For diagram flavors whose heights rarely change,
this will encache the height.  (send self :clear-height-cache) to flush."))

(defwhopper-subst (:output-height cached-output-height-diagram-mixin) (stream)
  (or height (setq height (continue-whopper stream))))

(defmethod (:clear-height-cache cached-output-height-diagram-mixin) ()
  (setq height nil))

(defflavor restorable-line-diagram-mixin () (line-diagram-mixin)
  (:required-methods :contents :set-contents)
  :initable-instance-variables
  :gettable-instance-variables
  )

(defflavor black-line-diagram-with-legend-mixin
	(legend
	 style
	 height) ; rational fraction of line-height
	(draw-self-diagram-mixin line-diagram-mixin)
  (:init-keywords :structural)
  (:mixture (:structural structural-line-diagram-mixin))
  (:documentation
   "A ZWEI line diagram with a legend in the middle,
of a hight set at instantiation."))
  
(defflavor black-line-diagram-with-legend
	(legend
	 style
	 height)
	(black-line-diagram-with-legend-mixin)
  (:default-init-plist :height 1\2 :character-style '(nil nil nil))
  (:mixture (:structural structural-line-diagram-mixin))
  (:required-init-keywords :legend)
  (:init-keywords :character-style :style :legend :structural)
  (:initable-instance-variables legend height))

(defmethod (:init black-line-diagram-with-legend :after) (init-plist)
  (let ((style-list (cadr (getl init-plist '(:character-style :style)))))
    (setq style (si:parse-character-style style-list))))

(defmethod (:output-height black-line-diagram-with-legend-mixin)
	   (stream)
  (scl:with-character-style (style stream :bind-line-height t)
    (send stream :line-height)))

(defmethod (:draw-self black-line-diagram-with-legend-mixin) (stream)
  (scl:with-character-style (style stream :bind-line-height t)
    (let* ((window-w (send stream :inside-width))
	   (string-w
	     (dw:continuation-output-size
	       #'(lambda (stream)
		   (cl:write-string legend stream))
	       stream))
	   (squeezed-string-w (min string-w (- window-w 100)))
	   (block-w (cl:truncate (- window-w squeezed-string-w) 2))
	   (line-height (- (send stream :line-height) (send stream :vsp)))
	   (line-h (cl:round (* line-height height)))
	   (y-pos (cl:truncate (- line-height line-h) 2)))
      (graphics:draw-rectangle 0 y-pos block-w (+ y-pos line-h)
			       :stream stream :filled t)
      (graphics:draw-rectangle (+ squeezed-string-w block-w 20) y-pos
			       (+ squeezed-string-w block-w block-w)
			       (+ y-pos line-h)
			       :stream stream :filled t)
      (graphics:draw-string legend (+ block-w 10) 0
			    :toward-x (+ block-w 10 squeezed-string-w)
			    :stretch-p t
			    :attachment-y :bottom	
			    :stream stream))))
 
(defmethod (:string-for-file black-line-diagram-with-legend-mixin) ()
  (string-append "============================== " legend "============================== "))

(defflavor black-line-diagram
	(height)
	(draw-self-diagram-mixin line-diagram-mixin)
  (:init-keywords :structural)
  (:mixture (:structural structural-line-diagram-mixin))
  (:initable-instance-variables height)
  (:default-init-plist :height 1\4)
  (:documentation
   "A ZWEI line diagram with a specified height."))

(defmethod (:draw-self black-line-diagram) (stream)
  (let* ((line-height (- (send  stream :line-height) (send stream :vsp)))
	 (d-height (cl:round (cl:* line-height height)))
	 (width (send stream :inside-width))
	 (y-pos (cl:round line-height 2)))
    (graphics:draw-line 0 y-pos width y-pos :thickness d-height :stream stream)))

(defmethod (:output-height black-line-diagram) (stream)
  (send stream :line-height))

(defmethod (:string-for-file black-line-diagram) ()
  "-----------------------------------------------------------------------")

(defmethod (:string-for-file restorable-line-diagram-mixin) ()
  (scl:with-standard-io-environment
    (values (format () "~S ~A" (typep self) (send self :contents))
	    t)))

(defflavor failed-to-restore-line-diagram (flavor (diag-contents ()) options)
	   (restorable-line-diagram-mixin)
  (:initable-instance-variables flavor options)
  )

(defmethod (:maybe-replace-with-real-diagram failed-to-restore-line-diagram) (line)
  (when (flavor:find-flavor flavor nil)
    (let ((diag (lexpr-funcall #'make-instance flavor options)))
      (send diag :set-contents diag-contents)
      (setf (line-diagram line) diag))
    t))

(defmethod (:editor-height failed-to-restore-line-diagram) (window line)
  (if (send self :maybe-replace-with-real-diagram line)
      (send (line-diagram line) :editor-height window line)
      (send window :line-height)))

(defmethod (:editor-draw failed-to-restore-line-diagram) (line window cursor-x cursor-y)
  (if (send self :maybe-replace-with-real-diagram line)
      (send (line-diagram line) :editor-draw line window cursor-x cursor-y)
      (multiple-value-bind (after-x after-y)
	  (draw-engrayed-text window cursor-x cursor-y
			      "<Unrestored diagram of type ~S>" flavor)
	(values cursor-x cursor-y after-x after-y))))

(defmethod (:contents failed-to-restore-line-diagram) (line)
  (if (send self :maybe-replace-with-real-diagram line)
      (send (line-diagram line) :contents line)
      (or diag-contents "")))

(defmethod (:set-contents failed-to-restore-line-diagram) (string &optional (start 0) end)
  (setq diag-contents (substring string start end)))

(defmethod (:string-for-file failed-to-restore-line-diagram) ()
  (scl:with-standard-io-environment
    (values (format () "~S ~A" flavor (send self :contents))
	    t)))

(defmethod (:form-for-file failed-to-restore-line-diagram) ()
  `(make-instance 'failed-to-restore-line-diagram :flavor ',flavor :options ',options))

(defflavor invalid-line-diagram ((original-contents ""))
	   (restorable-line-diagram-mixin)
  (:initable-instance-variables original-contents)
  )

(defmethod (make-instance invalid-line-diagram) (&key &allow-other-keys)
  1;; Copy the contents now as it's a stack array.
0  (setq original-contents (substring original-contents 0)))

(defmethod (:editor-draw invalid-line-diagram) (line window cursor-x cursor-y)
  (ignore line)
  (multiple-value-bind (after-x after-y)
      (draw-engrayed-text window cursor-x cursor-y "<Invalid diagram ~A>" original-contents)
    (values cursor-x cursor-y after-x after-y)))

(defmethod (:contents invalid-line-diagram) (line)
  (ignore line)
  original-contents)

(defmethod (:set-contents invalid-line-diagram) (string &optional (start 0) end)
  (setq original-contents (substring string start end)))

(defmethod (:string-for-file invalid-line-diagram) ()
  (scl:with-standard-io-environment
    (values (format () "~A" (send self :contents))
	    t)))

(defmethod (:form-for-file invalid-line-diagram) ()
  `(make-instance 'invalid-line-diagram :original-contents ',original-contents))


;;Return bottom-right coords
(defun draw-engrayed-text (window cursor-x cursor-y format-string &rest format-args)
  (let ((lh (send window :line-height))
	(rw (* 5 (send window :char-width))))
    (send window :draw-1-bit-raster rw lh tv:75%-gray 0 0 cursor-x cursor-y :draw color:alu-noop)
    (send window :set-cursorpos (+ cursor-x rw) cursor-y)
    (lexpr-funcall #'format window format-string format-args)
    (multiple-value-bind (after-x after-y) (send window :read-cursorpos)
      (send window :draw-1-bit-raster rw lh tv:75%-gray 0 0 after-x after-y :draw color:alu-noop)
      (send window :draw-1-bit-raster (- after-x (+ cursor-x rw)) lh
	    tv:hes-gray 0 0 (+ cursor-x rw) cursor-y :draw color:alu-noop)
      (incf after-x rw)
      (send window :set-cursorpos after-x ())
      (values after-x (+ after-y lh)))))

(defun insert-diagram (bp diagram &rest options)
  (multiple-value-bind (line diag)
      (lexpr-funcall #'make-diagram-line diagram options)
    (mung-bp-interval bp)
    (prepare-to-insert (beg-line bp) nil)
    (insert-line-with-leader line (bp-line bp))
    diag))

(defun make-diagram-line (diagram &rest options)
  (when (symbolp diagram)
    (setq diagram (lexpr-funcall #'instantiate-diagram diagram options)))
  (let ((line (make-line :make-array (:area *line-area* :type 'art-string)
			 line-tick *tick* line-length 0)))
    (setf (line-diagram line) diagram)
    (values line diagram)))

(defun instantiate-diagram (flavor &rest options)
  (if (flavor:find-flavor flavor nil)
      (lexpr-funcall #'make-instance flavor options)
      (make-instance 'failed-to-restore-line-diagram :flavor flavor :options options)))


(defflavor black-block-diagram () (line-diagram-mixin))

(defmethod (:editor-draw black-block-diagram) (ignore sheet ignore cursor-y)
  (graphics:draw-rectangle  0 cursor-y (tv:sheet-inside-width sheet)
			    (+ cursor-y (tv:sheet-line-height sheet))
			    :filled t
			    :stream sheet))

(defvar *black-block-diagram* 'black-block-diagram)

(defun insert-black-block-diagram (bp)
  (setq *black-block-diagram* (insert-diagram bp 'black-block-diagram)))

(defflavor grey-block-diagram () (line-diagram-mixin))

(defmethod (:editor-draw grey-block-diagram) (ignore sheet ignore cursor-y)
  (graphics:draw-rectangle  0 cursor-y (tv:sheet-inside-width sheet)
			    (+ cursor-y (tv:sheet-line-height sheet))
			    :filled t
			    :stream sheet
			    :pattern tv:50%-gray))

(defvar *grey-block-diagram* 'grey-block-diagram)

(defun insert-grey-block-diagram (bp)
  (setq *grey-block-diagram* (insert-diagram bp 'grey-block-diagram)))


(defmethod (:displayed-presentation-at-position line-diagram-mixin :default)
	   (line x y line-x line-y window)
  (ignore line x y line-x line-y window)
  nil)

(defflavor mouse-sensitive-diagram-mixin
	((presentation nil))
	()
  (:required-flavors line-diagram-mixin))

(scl:define-presentation-type sensitive-diagram-output ())

1;;; Since this whopper is on editor draw, anything that is both
;;; mouse sensitive and :draw-self won't run this when not drawing
;;; in the editor.
0(defwhopper (:editor-draw mouse-sensitive-diagram-mixin) (line stream x y)
  (setq presentation (dw:with-simulated-presentation-recording
		       (stream :x-offset x :y-offset y
			       :object self :type 'sensitive-diagram-output)
		       (continue-whopper line stream x y))))

(defmethod (:displayed-presentation-at-position mouse-sensitive-diagram-mixin)
	   (ignore x y line-x line-y ignore)
  (and presentation
       (dw::simulated-presentation-inferior-at-position presentation
							(- x line-x) (- y line-y)
							line-x line-y)))

(defflavor essential-editor-command-menu-diagram
	((command-alist nil)
	 body-character-style)
	(mouse-sensitive-diagram-mixin draw-self-diagram-mixin line-diagram-mixin)
  (:conc-name editor-command-menu-diagram-)
  (:initable-instance-variables command-alist)
  (:init-keywords :body-character-style)
  (:default-init-plist :body-character-style '(nil nil nil))
  (:writable-instance-variables))

(defmethod (make-instance essential-editor-command-menu-diagram)
	   (&key ((:body-character-style bcs)) &allow-other-keys)
  (setq body-character-style (si:parse-character-style bcs)))

(defflavor editor-command-menu-diagram
	((title "Editor Commands")
	 title-character-style
	 title-alignment
	 title-position)
	(essential-editor-command-menu-diagram)
  (:initable-instance-variables title title-alignment title-position)
  (:writable-instance-variables title title-alignment title-position)
  (:init-keywords :title-character-style)
  (:default-init-plist :title-character-style '(nil nil nil)
		       :title-alignment :left
		       :title-position :top))

(defmethod (make-instance editor-command-menu-diagram)
	   (&key ((:title-character-style tcs)) &allow-other-keys)
  (setq title-character-style (si:parse-character-style tcs)))

(defmethod ((cl:setf editor-command-menu-diagram-title-character-style)
	    editor-command-menu-diagram) (ns)
  (setq title-character-style (si:parse-character-style ns)))

(defflavor structural-editor-command-menu-diagram
	()
	(structural-line-diagram-mixin editor-command-menu-diagram))

(defgeneric editor-command-menu-diagram-draw-title (editor-command-menu-diagram stream)
  (:method (essential-editor-command-menu-diagram)
   (ignore stream)
   nil)
  (:method (editor-command-menu-diagram)
   (scl:with-character-style (title-character-style stream :bind-line-height t)
     (cl:write-string title stream))
   ))

(defgeneric editor-command-menu-diagram-draw-menu (editor-command-menu-diagram stream)
  (:method (essential-editor-command-menu-diagram)
   (scl:with-character-style (body-character-style stream :bind-line-height t)
     (scl:formatting-item-list (stream :row-wise t :output-row-wise t)
       (loop for (name . command) in command-alist
	     do
	 (scl:formatting-cell (stream)
	   (dw:with-output-as-presentation (:stream stream :object command
						    :type 'extended-command-name
						    :single-box t)
	     (cl:write-string name stream))))))))

(defmethod (:draw-self editor-command-menu-diagram) (stream)
  (let ((transform (graphics:stream-transform stream)))
    (send stream :set-cursorpos (graphics::graphics-transform-tx transform)
	  (graphics::graphics-transform-ty transform)
	  :pixel))
  (scl:surrounding-output-with-border
    (stream :thickness 2 :margin 2 :label-position title-position
	    :label-separator-line t 
	    :label-alignment title-alignment
	    :label (editor-command-menu-diagram-draw-title self stream))
    (editor-command-menu-diagram-draw-menu self stream)))

(defmethod (:draw-self essential-editor-command-menu-diagram) (stream)
  (let ((transform (graphics:stream-transform stream)))
    (send stream :set-cursorpos (graphics::graphics-transform-tx transform)
	  (graphics::graphics-transform-ty transform)
	  :pixel))
  (editor-command-menu-diagram-draw-title self stream)
  (cl:fresh-line stream)
  (editor-command-menu-diagram-draw-menu self stream))

(compile-flavor-methods structural-editor-command-menu-diagram editor-command-menu-diagram)


(defflavor graphics-line-diagram
	((drawing-function nil)
	 (scale 1)
	 (binary-encoding nil))
	(draw-self-diagram-mixin cached-output-height-diagram-mixin
	 restorable-line-diagram-mixin)
  :initable-instance-variables
  (:settable-instance-variables scale))

(defmethod (:output-height graphics-line-diagram :before) (stream)
  (ignore stream)
  (when (null drawing-function)
    (if binary-encoding
	(setq drawing-function
	      (graphics:binary-decode-graphics-from-array-into-function binary-encoding))
	(debugging-barf "This diagram has no way to display itself."))))

(defmethod (:draw-self graphics-line-diagram) (stream)
  (graphics:with-graphics-scale (stream scale)
    (funcall drawing-function stream)))

(defmethod (:string-for-file graphics-line-diagram) ()
  (when (null binary-encoding)
    (setq binary-encoding (graphics:binary-encode-graphics-to-array drawing-function)))
  (scl:with-standard-io-environment
    (values (with-output-to-string (stream)
	      (prin1-then-space (typep self) stream)
	      (prin1-then-space scale stream)
	      (graphics:write-encoded-graphics-as-characters binary-encoding stream))
	    t)))

(defmethod (:form-for-file graphics-line-diagram) ()
  (when (null binary-encoding)
    (setq binary-encoding (graphics:binary-encode-graphics-to-array drawing-function)))
  `(make-instance 'graphics-line-diagram :scale ',scale :binary-encoding ',binary-encoding))

(defmethod (:contents graphics-line-diagram) ()
  (when (null binary-encoding)
    (setq binary-encoding (graphics:binary-encode-graphics-to-array drawing-function)))
  (scl:with-standard-io-environment
    (with-output-to-string (stream)
      (prin1-then-space scale stream)
      (graphics:write-encoded-graphics-as-characters binary-encoding stream))))

(defmethod (:set-contents graphics-line-diagram) (string &optional (start 0) end)
  (scl:with-standard-io-environment
    (with-input-from-string (stream string start end)
      (setq scale (read stream)
	    binary-encoding (graphics:read-encoded-graphics-as-characters stream)))))

(defun insert-graphics-line-diagram (bp &rest args)
  (declare (arglist bp &key (drawing-function nil) (binary-encoding nil) (scale 1)))
  (lexpr-funcall #'insert-diagram bp 'graphics-line-diagram args))

(compile-flavor-methods graphics-line-diagram)

(2 0 (NIL 0) (NIL NIL :SMALL) "TVFONT")#||
(defflavor obese-character () ()
  (:required-methods obese-character-size obese-character-draw))

(defgeneric obese-character-size (character window starting-x))
(defgeneric obese-character-draw (character window x y))


(defflavor bitmap-obese-character (raster) (obese-character)
  :readable-instance-variables
  :initable-instance-variables)

(defmethod (obese-character-size bitmap-obese-character) (&rest ignore)
  (multiple-value-bind (width height)
      (decode-raster-array raster)
    (values width height)))

(defmethod (obese-character-draw bitmap-obese-character) (window x y)
  (multiple-value-bind (width height)
      (decode-raster-array raster)
    (send window :bitblt tv:alu-seta width height raster 0 0 x y)))

(eval-when (eval load compile)
(cl:proclaim (special user:zippy-array)))

(defcom com-pinhead-at-point "" ()
  (insert-moving (point) (cl:make-char #\space 1))
  (unless (variable-boundp user:zippy-array)
    (load "S:>hacks>gc-decorate-zippy-array-rel7-row.bin"))
  (setf (aref (bp-line (point)) (1- (bp-index (point))))
	(make-instance 'tv:bitmap-obese-character :raster user:zippy-array))
  dis-text)
||#

0
(defflavor line-margin () ()
  (:required-methods line-margin-size line-margin-draw))

(defgeneric line-margin-size (line-margin window line)
  (declare (values left-margin top-margin right-margin bottom-margin)))

(defgeneric line-margin-draw (line-margin window line x y width height baseline vsp)
  )

(defmethod (:check-line-redisplay-parameters node :default) (ignore)
  )

(defsubst line-line-margin (line) (cl:getf (line-plist line) :line-margin) )
(defsubst line-tab-function (line) (cl:getf (line-plist line) :tab-function) )
(defsubst line-character-style-function (line)
  (cl:getf (line-plist line) :character-style-function))

(defun line-special-redisplay-properties (line)
  (declare (values diagram line-margin tab-function character-style-function))
  (let ((node (line-node line)))
    (when node
      (send node :check-line-redisplay-parameters line)))
  (let ((diagram nil)
	(line-margin nil)
	(tab-function nil)
	(character-style-function nil))
    (loop for (indicator value) on (line-plist line) by 'cddr do
      (selectq indicator
	(:diagram
	 (setq diagram value))
	(:line-margin
	 (setq line-margin value))
	(:tab-function
	 (setq tab-function value))
	(:character-style-function
	 (setq character-style-function value))))
    (values diagram line-margin tab-function character-style-function)))
