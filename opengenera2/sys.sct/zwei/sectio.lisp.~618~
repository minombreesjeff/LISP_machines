;;; -*- Syntax: Zetalisp; Mode: LISP; Package: ZWEI; Base: 8 -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This file provides the section specific code for ZMACS.

;;; Parse a file, finding the defuns, adding the names to the completion Aarray and the
;;; symbols' property lists
;;; Note that this must be called with PACKAGE bound to the file's package.
;;; If a stream is specified, we read that stream into the buffer until eof,
;;; a line at a time, and sectionize the stuff as we go.

;;; The data base is stored as: a ZMACS-BUFFERS property on each symbol, whose value
;;; is a list of definitions each of the form (type section)
;;; a ZMACS-SECTION-LIST property on each buffer,
;;; whose value is a list of definitions in the file, each of the form (fspec type).

;;;--- There are a bunch of time-bombs in here.  When a NAMED-BUFFER-WITH-SECTIONS
;;;--- that is not a ZMACS BUFFER is sent a :SECTIONIZE-BUFFER or a :CHECK-INTERVAL-SECTIONS
;;;--- message, it will go and play with properties owned by ZMACS and confuse
;;;--- the stuffing out of m-. --BIM

(DEFUN SECTIONIZE-BUFFER (BUFFER &OPTIONAL STREAM)
  (SEND BUFFER :SECTIONIZE-BUFFER STREAM))

(DEFMETHOD (:SECTIONIZE-BUFFER NODE) (STREAM)
  (IGNORE STREAM)
  NIL)

(DEFMETHOD (:SECTIONIZE-BUFFER NAMED-BUFFER-WITH-SECTIONS) (STREAM)
  (SECTIONIZE-BUFFER-INTERNAL SELF STREAM (SEND SELF :MAJOR-MODE)
			      (OR (SEND SELF :GET :PACKAGE) PACKAGE) NIL))

(DEFMETHOD (:SECTIONIZE-BUFFER BUFFER) (STREAM)
  (SECTIONIZE-BUFFER-INTERNAL SELF STREAM (SEND SELF :MAJOR-MODE) (SEND SELF :GET :PACKAGE)
			      NIL))

(DEFUN SECTIONIZE-BUFFER-INTERNAL (BUFFER STREAM MAJOR-MODE PACKAGE ADDED-COMPLETIONS
				   &OPTIONAL (CONTAINING-BUFFER BUFFER))
  ADDED-COMPLETIONS ;ignored, obsolete
  (LET* ((*INTERVAL* BUFFER)
	 (FIRST-BP (INTERVAL-FIRST-BP BUFFER))
	 (LAST-BP (INTERVAL-LAST-BP BUFFER))
	 (INT-STREAM (AND STREAM (OPEN-INTERVAL-STREAM LAST-BP LAST-BP T))))
    (MULTIPLE-VALUE-BIND (PARSING-VARS PARSING-VALS)
	(SEND MAJOR-MODE :PARSING-BINDINGS BUFFER)
      (FLUSH-ZMACS-BUFFERS-PROPERTIES-FOR-BUFFER BUFFER)
      ;; Now scan the buffer and record the definitions.
      (LET ((DEFINITION-LIST NIL)
	    (ABNORMAL T))			;give us a hook for cleaning up if the file
	(UNWIND-PROTECT				;blows out while reading in
	    (PROGV PARSING-VARS PARSING-VALS
	      (MULTIPLE-VALUE (DEFINITION-LIST ABNORMAL)
		(SEND MAJOR-MODE :SECTIONIZE-BUFFER FIRST-BP LAST-BP BUFFER
						    STREAM INT-STREAM NIL)))
	  (WHEN ABNORMAL
	    (FLUSH-ZMACS-BUFFERS-PROPERTIES-FOR-BUFFER BUFFER DEFINITION-LIST))))
      (WHEN (NOT (NULL *ZMACS-DEFINITIONS-BUFFER*))
	(SEND *ZMACS-DEFINITIONS-BUFFER* ':BUFFER-SECTIONIZED BUFFER CONTAINING-BUFFER))
      NIL)))


(SYS:DEFINE-METERS
  *SECTIONIZATION-METERS*
  *SECTIONIZE-BUFFER*
  *CHECK-INTERVAL-SECTIONS*
  *COMPLETELY-MESSED-UP*
  *NO-FIRST-SECTION*
  *NO-VALID-INFERIORS*
  )

;; Controls number of lines of read-ahead for fast sectionization, so that
;; multi-line function-specs have a better chance of being parsed.
(DEFVAR *SECTIONIZATION-READ-AHEAD-THRESHOLD* 20.)

(DEFMETHOD (:SECTIONIZE-BUFFER MAJOR-MODE :DEFAULT)
	   (FIRST-BP LAST-BP BUFFER STREAM INT-STREAM ADDED-COMPLETIONS)
  ADDED-COMPLETIONS ;ignored, obsolete
  (WHEN STREAM
    (SEND-IF-HANDLES STREAM :SET-RETURN-DIAGRAMS-AS-LINES T))
  (INCF *SECTIONIZE-BUFFER*)
  (LET* ((BUFFER-TICK (OR (SEND-IF-HANDLES BUFFER :SAVE-TICK) *TICK*))
	 OLD-CHANGED-SECTIONS
	 (MAJOR-MODE (OR (SEND *INTERVAL* :MAJOR-MODE)
			 (MAJOR-MODE-FROM-KEYWORD :FUNDAMENTAL)))
	 (USE-FAST-LINE-TYPE (SEND MAJOR-MODE :USE-FAST-LINE-TYPE))
	 (LISP-MODE (TYPEP MAJOR-MODE 'LISP-SYNTAX-MIXIN)))
    (TICK)
    ;; Flush old section nodes.  Also collect the names of those that are modified, they are
    ;; the ones that will be modified again after a revert buffer.
    (DOLIST (NODE (NODE-INFERIORS BUFFER))
      (AND (> (NODE-TICK NODE) BUFFER-TICK)
	   (PUSH (LIST (SECTION-NODE-FUNCTION-SPEC NODE)
		       (SECTION-NODE-DEFINITION-TYPE NODE))
		 OLD-CHANGED-SECTIONS))
      (FLUSH-BP (INTERVAL-FIRST-BP NODE))
      (FLUSH-BP (INTERVAL-LAST-BP NODE)))
    (let ((LIMIT (BP-LINE LAST-BP))
	  (ABNORMAL T)
	  (DEFINITION-LIST NIL)
	  (BP (COPY-BP FIRST-BP))
	  (FUNCTION-SPEC)
	  (DEFINITION-TYPE)
	  (STR)
	  (PREV-NODE-START-BP FIRST-BP)
	  (PREV-NODE-DEFINITION-LINE NIL)
	  (PREV-NODE-FUNCTION-SPEC NIL)
	  (PREV-NODE-TYPE 'HEADER)
	  (PREVIOUS-NODE NIL)
	  (LINE-TYPE NIL)
	  (LATEST-BLANK-LINE NIL)
	  (LATEST-BLANK-LINE-TYPE NIL)
	  (LATEST-COMMENT-START-LINE NIL)
	  (LATEST-COMMENT-END-LINE NIL)
	  (NODE-LIST NIL)
	  (STATE (SEND SELF :INITIAL-SECTIONIZATION-STATE))
	  (END-OF-FILE NIL)
	  ;; iteration variables:
	  (INT-LINE)
	  (READ-AHEAD 0))
      (MACROLET ((NEXT-LINE ()					;called at end of loop
		   '(PROGN					; step iteration variables
		      (SETQ INT-LINE (LINE-NEXT INT-LINE))
		      (WHEN STREAM (DECF READ-AHEAD))
		      (FILL-READ-AHEAD)))
		 (NO-MORE-P ()					;called for end test
		   `(IF STREAM
			(<= READ-AHEAD 0)
			(EQ INT-LINE LIMIT))))
	(LABELS ((FILL-READ-AHEAD ()
		   (WHEN STREAM
		     (ZL:LOOP
			UNTIL END-OF-FILE
			UNTIL (>= READ-AHEAD *SECTIONIZATION-READ-AHEAD-THRESHOLD*)
			WHILE (LET* ((DEFAULT-CONS-AREA *LINE-AREA*) LINE)
				(MULTIPLE-VALUE (LINE END-OF-FILE)
				  (SEND STREAM :LINE-IN LINE-LEADER-SIZE))
				(INCF READ-AHEAD)
				(FUNCALL INT-STREAM :LINE-OUT LINE))))))
	  (FILL-READ-AHEAD)
	  (SETQ INT-LINE (BP-LINE FIRST-BP))
	  (CL:LOOP
;	   (format t "~&~2d~:[--~2*~;~:[ ~;~]~:[ ~;~]~] ~s"
;		   read-ahead
;		   int-line
;		   (when int-line (line-previous int-line))
;		   (when int-line (line-next int-line))
;		   int-line)
	     (WHEN INT-LINE
	        (MOVE-BP BP INT-LINE 0)				;Record as potentially start-bp for a section
	        (WHEN USE-FAST-LINE-TYPE
		(SETQ LINE-TYPE (FAST-LINE-TYPE INT-LINE))
		(WHEN (AND LISP-MODE
			 (EQ LINE-TYPE :ATOM)
			 (NOT (OR (SYS:%STRING-EQUAL INT-LINE 0 "#+" 0 2)
				(SYS:%STRING-EQUAL INT-LINE 0 "#-" 0 2)
				(CHAR-EQUAL (AREF INT-LINE
					        (1- (LINE-LENGTH INT-LINE)))
					  #/:))))
		  ;; If the line is an "atom" which is not #+/#- or a package name
		  ;; followed by colon, then treat it as a normal line.
		  (SETQ LINE-TYPE :NORMAL))
		;; The idea here is to be robust against files which might trick you
		;; with long quoted strings, etc.  So we maintain three state variables
		;; to ensure that the blank lines, comment lines, and code fall into a
		;; contiguous block, and that blank lines get into the "right" sections.
		(SELECTQ LINE-TYPE
		  ((:DIAGRAM :BLANK :FORM)
		   (WHEN (OR (NULL LATEST-BLANK-LINE)
			   (EQ (LINE-NEXT LATEST-BLANK-LINE) INT-LINE)
			   (NEQ LATEST-BLANK-LINE-TYPE :FORM))
		     (SETQ LATEST-BLANK-LINE INT-LINE
			 LATEST-BLANK-LINE-TYPE LINE-TYPE)))
		  ((:COMMENT :ATOM)					;atoms include #+3600, etc.
		   (COND ((AND LATEST-BLANK-LINE
			     LATEST-COMMENT-START-LINE))
		         ((AND LATEST-BLANK-LINE
			     (EQ (LINE-NEXT LATEST-BLANK-LINE) INT-LINE))
			(SETQ LATEST-COMMENT-START-LINE INT-LINE))
		         (LATEST-COMMENT-START-LINE)
		         (T
			 (SETQ LATEST-COMMENT-START-LINE INT-LINE)))
		   (SETQ LATEST-COMMENT-END-LINE INT-LINE))))
	      ;; See if the line is the start of a defun.
	        (WHEN (LET (ERR)
		      (MULTIPLE-VALUE (FUNCTION-SPEC DEFINITION-TYPE STR ERR STATE)
		        (SEND SELF ':SECTION-NAME INT-LINE BP STATE))
		      (NOT ERR))
		(PUSH (LIST FUNCTION-SPEC DEFINITION-TYPE) DEFINITION-LIST)
		(SECTION-COMPLETION FUNCTION-SPEC STR NIL)
		;; List methods under both names for user ease.
		(LET ((OTHER-COMPLETION (SEND SELF ':OTHER-SECTION-NAME-COMPLETION
					 FUNCTION-SPEC INT-LINE)))
		  (WHEN OTHER-COMPLETION
		    (SECTION-COMPLETION FUNCTION-SPEC OTHER-COMPLETION NIL)))
		(LET ((PREV-NODE-END-BP 
		        (COND ((AND LATEST-BLANK-LINE
				(OR (EQ (LINE-NEXT LATEST-BLANK-LINE) INT-LINE)
				    (AND (EQ (LINE-NEXT LATEST-BLANK-LINE)
					   LATEST-COMMENT-START-LINE)
				         (EQ (LINE-NEXT LATEST-COMMENT-END-LINE) INT-LINE))))
			     (CREATE-BP LATEST-BLANK-LINE 0))
			    ((AND LATEST-COMMENT-START-LINE
				(EQ (LINE-NEXT LATEST-COMMENT-END-LINE) INT-LINE))
			     (CREATE-BP LATEST-COMMENT-START-LINE 0))
			    ((NOT USE-FAST-LINE-TYPE)
			     (BACKWARD-OVER-COMMENT-LINES BP ':FORM-AS-BLANK))
			    ((AND (NULL LATEST-BLANK-LINE)
				(NULL LATEST-COMMENT-START-LINE))
			     (CREATE-BP INT-LINE 0))
			    (T
			      ;; The comment we have is probably a red herring
			      (BACKWARD-OVER-COMMENT-LINES BP ':FORM-AS-BLANK)))))
		  #+++DEBUGGING
		  (LET ((EBP (BACKWARD-OVER-COMMENT-LINES BP ':FORM-AS-BLANK)))
		    (WHEN (NOT (BP-= PREV-NODE-END-BP EBP))
		      (FORMAT T "~&~S:~%  ~S~%  ~S" INT-LINE PREV-NODE-END-BP EBP)
		      (DBG:WHEN-MODE-LOCK (DBG))))
		  ;; Don't make a section node if it's completely empty.  This avoids making
		  ;; a useless Buffer Header section node. Just set all the PREV variables
		  ;; so that the next definition provokes the *right thing*
		  (UNLESS (BP-= PREV-NODE-END-BP PREV-NODE-START-BP)
		    (SETQ PREVIOUS-NODE
			(ADD-SECTION-NODE PREV-NODE-START-BP
				        (SETQ PREV-NODE-START-BP PREV-NODE-END-BP)
				        PREV-NODE-FUNCTION-SPEC PREV-NODE-TYPE
				        PREV-NODE-DEFINITION-LINE BUFFER PREVIOUS-NODE
				        (IF (LOOP FOR (FSPEC TYPE) IN OLD-CHANGED-SECTIONS
					        THEREIS (AND (EQ PREV-NODE-FUNCTION-SPEC
							     FSPEC)
							 (EQ PREV-NODE-TYPE TYPE)))
					  *TICK* BUFFER-TICK)
				        BUFFER-TICK))
		    (PUSH PREVIOUS-NODE NODE-LIST)))
		(SETQ PREV-NODE-FUNCTION-SPEC FUNCTION-SPEC
		      PREV-NODE-TYPE DEFINITION-TYPE
		      PREV-NODE-DEFINITION-LINE INT-LINE))
	        (WHEN (EQ LINE-TYPE :NORMAL)
		(SETQ LATEST-BLANK-LINE NIL
		      LATEST-BLANK-LINE-TYPE NIL
		      LATEST-COMMENT-START-LINE NIL
		     LATEST-COMMENT-END-LINE NIL)))
	     ;; After processing the last line, exit.
	     (WHEN (no-more-p)
	        ;; If reading a stream, we should not have inserted a CR
	        ;; after the eof line.
	        (WHEN STREAM
		(DELETE-INTERVAL (FORWARD-CHAR LAST-BP -1 T) LAST-BP T))
	        ;; The rest of the buffer is part of the last node
	        (UNLESS (SEND SELF ':SECTION-NAME-TRIVIAL-P)
		;; ---oh dear, what sort of section will this be? A non-empty HEADER
		;; ---node.  Well, ok for now.
		(PUSH (ADD-SECTION-NODE PREV-NODE-START-BP LAST-BP
				    PREV-NODE-FUNCTION-SPEC PREV-NODE-TYPE
				    PREV-NODE-DEFINITION-LINE BUFFER PREVIOUS-NODE
				    (IF (LOOP FOR (FSPEC TYPE) IN OLD-CHANGED-SECTIONS
					    THEREIS (AND (EQ PREV-NODE-FUNCTION-SPEC FSPEC)
						       (EQ PREV-NODE-TYPE TYPE)))
				        *TICK* BUFFER-TICK)
				    BUFFER-TICK)
		      NODE-LIST)
		(SETF (LINE-NODE (BP-LINE LAST-BP)) (CAR NODE-LIST)))
	        (SETF (NODE-INFERIORS BUFFER) (NREVERSE NODE-LIST))
	        (SETF (NAMED-BUFFER-WITH-SECTIONS-FIRST-SECTION BUFFER) (CAR (NODE-INFERIORS BUFFER)))
	        (SETQ ABNORMAL NIL)					;timing windows here
	        ;; Speed up completion if enabled.
	        (WHEN SI:*ENABLE-AARRAY-SORTING-AFTER-LOADS*
		(SI:SORT-AARRAY *ZMACS-COMPLETION-AARRAY*))
	        (SETQ *ZMACS-COMPLETION-AARRAY*
		    (FOLLOW-STRUCTURE-FORWARDING *ZMACS-COMPLETION-AARRAY*))
	        (RETURN
		(VALUES 
		  (CL:SETF (ZMACS-SECTION-LIST BUFFER)
			 (NREVERSE DEFINITION-LIST))
		 ABNORMAL)))
	     (next-line)
	     ))))))

(DEFUN FLUSH-ZMACS-BUFFERS-PROPERTIES-FOR-BUFFER
       (BUFFER &OPTIONAL (SECTION-LIST (BUFFER-SECTIONS BUFFER)))
  (LOOP FOR SECTION IN SECTION-LIST DO
    (MULTIPLE-VALUE-BIND (FUNCTION-SPEC DEFINITION-TYPE)
	(IF (LISTP SECTION)
	    (VALUES (FIRST SECTION) (SECOND SECTION))
	    (VALUES (SEND SECTION :FUNCTION-SPEC) (SEND SECTION :DEFINITION-TYPE)))
      (WHEN (AND FUNCTION-SPEC DEFINITION-TYPE)
	(LET* ((OLD-PROPERTY (SI:FUNCTION-SPEC-GET FUNCTION-SPEC 'ZMACS-BUFFERS))
	       (NEW-PROPERTY (CL:DELETE-IF #'(LAMBDA (ELEM)
					       (WHEN (AND (EQ (FIRST ELEM) DEFINITION-TYPE)
							  (NODE-IN-BUFFER-P (SECOND ELEM)
									    BUFFER))
						 (FLUSH-ZMACS-BUFFERS-PROPERTIES-FOR-BUFFER
						   (SECOND ELEM)
						   (NODE-INFERIORS (SECOND ELEM)))
						 T))
					   OLD-PROPERTY)))
	  (COND (NEW-PROPERTY
		 (SI:FUNCTION-SPEC-PUTPROP FUNCTION-SPEC NEW-PROPERTY 'ZMACS-BUFFERS))
		(OLD-PROPERTY
		 (SI:FUNCTION-SPEC-REMPROP FUNCTION-SPEC 'ZMACS-BUFFERS))))))))

(DEFMETHOD (:INFERIOR-TO-NODE NODE) (NODE)
  (EQ SUPERIOR NODE))
  
;;; Add a symbol to the completion aarray
(DEFUN SECTION-COMPLETION (THING &OPTIONAL STRING MERGING-AARRAY EXTEND-BY)
  MERGING-AARRAY EXTEND-BY ;ignored
  (OR STRING (SETQ STRING (STRING THING)))
  ;; Grow the array by a larger amount than the default.
  (SI:AARRAY-INSERT *ZMACS-COMPLETION-AARRAY* STRING THING NIL
		    #'(LAMBDA (AARRAY)
			(LET ((LENGTH (ARRAY-LENGTH AARRAY)))
			  (ADJUST-ARRAY-SIZE AARRAY
					     (+ LENGTH (MAX (// LENGTH 2) 500.)))))))

;;; Add a new node with one section in it
(DEFUN ADD-SECTION-NODE (START-BP END-BP FUNCTION-SPEC TYPE DEFINITION-LINE BUFFER
			 PREVIOUS-NODE TICK TICK1 &AUX NODE)
  (LET ((DEFAULT-CONS-AREA *NODE-AREA*)
	(*BP-AREA* *NODE-AREA*))		;Put node, boundary bp's, and bp lists here
    (SETQ NODE (MAKE-INSTANCE 'SECTION-NODE
			      ':FIRST-BP (COPY-BP START-BP ':NORMAL)
			      ':LAST-BP (COPY-BP END-BP ':MOVES)
			      ':TICK TICK
			      ':PREVIOUS PREVIOUS-NODE
			      ':SUPERIOR BUFFER
			      ':FUNCTION-SPEC FUNCTION-SPEC
			      ':DEFINITION-TYPE TYPE
			      ':DEFINITION-LINE DEFINITION-LINE
			      ':COMPILE-TICK TICK1
			      ':SECTIONIZATION-TICK *TICK*
			      )))
  (AND PREVIOUS-NODE
       (SETF (NODE-NEXT PREVIOUS-NODE) NODE))
  (DO ((LINE (BP-LINE START-BP) (LINE-NEXT LINE))
       (LIMIT (BP-LINE END-BP)))
      ((AND (EQ LINE LIMIT)
	    (ZEROP (BP-INDEX END-BP))))
    (SETF (LINE-NODE LINE) NODE)
    (AND (EQ LINE LIMIT) (RETURN)))
  (AND FUNCTION-SPEC
       (LET ((PROP (SI:FUNCTION-SPEC-GET FUNCTION-SPEC 'ZMACS-BUFFERS)))
	 (SI:FUNCTION-SPEC-PUTPROP FUNCTION-SPEC (NCONC PROP (NCONS (LIST TYPE NODE)))
				   'ZMACS-BUFFERS)))
  NODE)

(DEFUN GET-SECTION-NODE-IN-FILE (FSPEC TYPE TRUENAME
				 &OPTIONAL (ALLOW-MODIFIED? T) (SAVE-PATCH-FILE? T)
					   (ERROR-P T))
  (LET* ((BUFFER (OR (FIND-BUFFER-NAMED TRUENAME)
		     (CADR (MULTIPLE-VALUE-LIST (FIND-FILE TRUENAME NIL)))))
	 (NODE (GET-SECTION-NODE-IN-BUFFER FSPEC TYPE BUFFER SAVE-PATCH-FILE? NIL)))
    (COND ((NULL NODE)
	   (WHEN ERROR-P
	     (BARF "Cannot find ~S ~S in ~A" TYPE FSPEC TRUENAME))
	   NIL)
	  ((OR ALLOW-MODIFIED? (< (SEND NODE ':TICK) (SEND BUFFER ':SAVE-TICK)))
	   NODE)
	  (T
	   (LET ((NEW-BUFFER (MAKE-BUFFER 'FILE-BUFFER ':PATHNAME TRUENAME ':ACTIVATE-P NIL)))
	     (SEND NEW-BUFFER ':REVERT)
	     (SEND NEW-BUFFER ':ACTIVATE)
	     (GET-SECTION-NODE-IN-BUFFER FSPEC TYPE NEW-BUFFER SAVE-PATCH-FILE? ERROR-P))))))

(DEFUN GET-SECTION-NODE-IN-BUFFER (FSPEC TYPE IN-BUFFER
				   &OPTIONAL (SAVE-PATCH-FILE? T) (ERROR-P T))
  (LET ((ZMACS-BUFFERS-PROPERTY (SI:FUNCTION-SPEC-GET FSPEC 'ZMACS-BUFFERS))
	(MAYBE NIL))
    (LOOP FOR (NODE-TYPE NODE) IN ZMACS-BUFFERS-PROPERTY
	  DO (WHEN (NODE-IN-BUFFER-P NODE IN-BUFFER)
	       (WHEN (EQ NODE-TYPE TYPE)
		 (RETURN NODE))
	       (SETQ MAYBE NODE))
	  FINALLY
	  ;; If we have a patch file try to save ourselves from the way sectionization
	  ;; doesn't work for them by interning the function spec in the patch file's
	  ;; package and trying again.
	  (WHEN (AND SAVE-PATCH-FILE? (SEND IN-BUFFER ':GET ':PATCH-FILE))
	    (WITH-INPUT-FROM-STRING (STR (FORMAT NIL "~S" FSPEC))
	      (LET ((PACKAGE (SEND IN-BUFFER ':GET ':PACKAGE)))
		(RETURN (GET-SECTION-NODE-IN-BUFFER (READ STR)
						    TYPE IN-BUFFER NIL ERROR-P)))))
	  ;; If we found a node with the right name but the wrong type, use it.
	  ;; This is another way to lose with patch buffers, when the defining 
	  ;; special form isn't global.
	  (WHEN MAYBE
	    (RETURN MAYBE))
	  (WHEN ERROR-P
	    (BARF "Cannot find ~S ~S in ~A" TYPE FSPEC (SEND IN-BUFFER ':NAME))))))

;;--- This can't work on version-control buffers, can it?
(DEFUN COMPUTE-SECTION-NODE-TICK (START-BP &OPTIONAL END-BP IN-ORDER-P)
  (GET-INTERVAL START-BP END-BP IN-ORDER-P)
  (DO ((LINE (BP-LINE START-BP) (LINE-NEXT LINE))
       (END-LINE (BP-LINE END-BP))
       (TICK 0))
      ((AND (EQ LINE END-LINE) (ZEROP (BP-INDEX END-BP)))
       TICK)
    (SETQ TICK (MAX TICK (LINE-TICK LINE)))
    (LET ((NEARBY-TICK (LINE-NEARBY-LINE-DELETED LINE)))
      (AND NEARBY-TICK (SETQ TICK (MAX TICK NEARBY-TICK))))
    (AND (EQ LINE END-LINE) (RETURN TICK))))

(DEFUN SPLICE-OUT-SECTIONS (LIST NEW-CDR)
  (DO ((L (CDR LIST) (CDR L)))
      ((EQ L NEW-CDR))
    (LET* ((NODE (CAR L))
	   (FSPEC (SECTION-NODE-FUNCTION-SPEC NODE))
	   (OLD-PROPERTY (SI:FUNCTION-SPEC-GET FSPEC 'ZMACS-BUFFERS))
	   (NEW-PROPERTY (CL:DELETE NODE OLD-PROPERTY :KEY #'SECOND)))
      (COND (NEW-PROPERTY
	     (SI:FUNCTION-SPEC-PUTPROP FSPEC NEW-PROPERTY 'ZMACS-BUFFERS))
	    (OLD-PROPERTY
	     (SI:FUNCTION-SPEC-REMPROP FSPEC 'ZMACS-BUFFERS)))
      ;; Any lines that were owned by this deleted node are now owned by one of its neighbors
      (LOOP FOR LINE = (BP-LINE (INTERVAL-FIRST-BP NODE)) THEN (LINE-NEXT LINE) WHILE LINE
	    WITH NEIGHBOR = (FIRST LIST)
	    WITH END-LINE = (AND NEW-CDR
				 (BP-LINE (INTERVAL-LAST-BP NEIGHBOR)))	;BP-INDEX must be 0
	    DO (WHEN (EQ LINE END-LINE)
		 (SETQ NEIGHBOR (FIRST NEW-CDR)))
	       (WHEN (EQ (LINE-NODE LINE) NODE)
		 (SETF (LINE-NODE LINE) NEIGHBOR))
	    UNTIL (EQ LINE (BP-LINE (INTERVAL-LAST-BP NODE))))))
  (SETF (CDR LIST) NEW-CDR))

(DEFUN SECTION-NODE-SECTIONIZATION-VALID (NODE)
  (AND (TYPEP NODE 'SECTION-NODE)
       ( (NODE-TICK NODE) (SECTION-NODE-SECTIONIZATION-TICK NODE))))

;;; A buffer is unmodified since it was last sectionized if none of the sections was
;;; modified, since the sections always span the whole text even if there are insertions
(DEFUN BUFFER-SECTIONIZATION-VALID (BUFFER)
  (LET ((SECTIONS (BUFFER-SECTIONS BUFFER)))
    (AND SECTIONS
	 (LOOP FOR NODE IN SECTIONS
	       ALWAYS (SECTION-NODE-SECTIONIZATION-VALID NODE)))))

(DEFUN INVALIDATE-BUFFER-SECTIONIZATION (BUFFER)
  (LOOP FOR NODE IN (BUFFER-SECTIONS BUFFER)
	DO (SETF (SECTION-NODE-SECTIONIZATION-TICK NODE) (1- (NODE-TICK NODE)))))


;;; Incrementally resectionize the area around an interval.  Called whenever we care about
;;; sections.  Tries to be as conservative as possible.
(DEFUN CHECK-INTERVAL-SECTIONS (START-BP &OPTIONAL END-BP IN-ORDER-P)
  (GET-INTERVAL START-BP END-BP IN-ORDER-P)
  (IF (EQ (BP-TOP-LEVEL-NODE START-BP) (BP-TOP-LEVEL-NODE END-BP))
      (SEND (BP-TOP-LEVEL-NODE START-BP) :CHECK-INTERVAL-SECTIONS START-BP END-BP)
      (LET ((S-H-B (INTERVAL-HOME-BUFFER (BP-TOP-LEVEL-NODE START-BP)))
	    (E-H-B (INTERVAL-HOME-BUFFER (BP-TOP-LEVEL-NODE END-BP))))
	(UNLESS (EQ S-H-B E-H-B)
	  (DEBUGGING-BARF "CHECK-INTERVAL-SECTIONS called with BP's in two different buffers. Please report this ZWEI bug."))
	(MAP-OVER-HARD-SECTIONS (START-BP END-BP :BUFFER S-H-B)
	  (SEND (BP-TOP-LEVEL-NODE START-BP) :CHECK-INTERVAL-SECTIONS START-BP END-BP)))))
	  
;;; This is a legal noop for non-buffer objects.
(DEFMETHOD (:CHECK-INTERVAL-SECTIONS NODE) (START-BP END-BP)
  (IGNORE START-BP END-BP)
  NIL)

(DEFMETHOD (:CHECK-INTERVAL-SECTIONS NAMED-BUFFER-WITH-SECTIONS) (START-BP END-BP)
  (SEND (SEND SELF :MAJOR-MODE) :CHECK-INTERVAL-SECTIONS START-BP END-BP SELF))

(DEFMETHOD (:CHECK-INTERVAL-SECTIONS MAJOR-MODE :DEFAULT)
	   (START-BP END-BP BUFFER &OPTIONAL (CONTAINING-BUFFER BUFFER))
  (INCF *CHECK-INTERVAL-SECTIONS*)
  (LET ((INFERIORS)
	(COMPLETELY-MESSED-UP NIL)
	(SKIP-OVER-UNMODIFIED NIL)
	(INFERIORS-CHANGED NIL)
	(FIRST-SECTION (NAMED-BUFFER-WITH-SECTIONS-FIRST-SECTION BUFFER))
	(LAST-UNMODIFIED-NODE NIL)		; this can be nil if all (node-inferiors)
						;  are modified.
	)
    (WHEN (AND (SECTIONS-P BUFFER)
	       (NOT (SEND SELF ':SECTION-NAME-TRIVIAL-P)))
      
      ;; Sectionization is meaningful in this buffer.  Find the beginning of
      ;; the modified area of the buffer that includes START-BP.
      
      (WHEN (AND (BP-= START-BP (NODE-FIRST-BP BUFFER))	;if we are starting from the top, 
		 (NEQ (BP-NODE START-BP) FIRST-SECTION)); but the first line
						;isn't in the first node,
	(SETQ FIRST-SECTION NIL))		;forget it.


      (IF (AND FIRST-SECTION (EQ FIRST-SECTION (CAR (NODE-INFERIORS BUFFER))))
	  ;;  If there is no designated FIRST-SECTION, or there are
	  ;; inferiors ahead of it then this has never been sectionized or
	  ;; something nasty has happened.   Skipping this will leave
	  ;; INFERIORS nil,  and provoke COMPLETELY-MESSED-UP
	  (LET ((NODE (BP-NODE START-BP)))
	    (AND (EQ NODE BUFFER) (SETQ NODE NIL))
	    (LOOP NAMED UP-TO-FIRST-UNMODIFIED
		  FOR NODE = NODE THEN (NODE-PREVIOUS NODE)
		  WHILE NODE
		  WHEN (SECTION-NODE-SECTIONIZATION-VALID NODE)
		    DO
		      (SETQ INFERIORS (MEMQ NODE (NODE-INFERIORS BUFFER)))	;the
						;unmodified, et al.
		      (SETQ LAST-UNMODIFIED-NODE INFERIORS)	;the cons whose car is
						; the unmodified section-node.
		      (SETQ INFERIORS (CDR INFERIORS))	;et al
		      (SETQ SKIP-OVER-UNMODIFIED (NOT (NULL (CAR LAST-UNMODIFIED-NODE))))
		      (RETURN-FROM UP-TO-FIRST-UNMODIFIED NIL)
		  FINALLY
		    ;; Modified the beginning of the buffer, start there and find the first
		    ;; section following the header.
		    ;; LAST-UNMODIFIED-NODE is already NIL, no need to set.
		    (SETQ START-BP (INTERVAL-FIRST-BP BUFFER))	;from the top
		    (SETQ INFERIORS (NODE-INFERIORS BUFFER))))	;look at them all.
	  (INCF *NO-FIRST-SECTION*))
      
      ;; If we couldn't find a list of INFERIORS to start with, or the buffer didn't
      ;; have any inferiors, incremental sectionizing won't work so resectionize the
      ;; whole thing.  This can happen if the buffer just became non-empty or the
      ;; major mode was changed.
      (UNLESS (OR LAST-UNMODIFIED-NODE INFERIORS)
	(INCF *NO-VALID-INFERIORS*)
	(SETQ COMPLETELY-MESSED-UP 'NO-INFERIORS))

      ;; We have a place to start
      (UNLESS COMPLETELY-MESSED-UP
	;; This loop iterates once for each modified area
	(LOOP NAMED TOP
	      WITH PACKAGE = (SEND BUFFER :GET ':PACKAGE)
	      WITH *INTERVAL* = BUFFER
	      WITH TEMP-BP = (COPY-BP START-BP)
	      WITH THIS-AREA-END-BP WITH THIS-AREA-INFERIORS-END
	  ALWAYS INFERIORS
	      DO
	  (WHEN (AND SKIP-OVER-UNMODIFIED LAST-UNMODIFIED-NODE)
	    ;; Find next modified area of the interesting part of the buffer
	    (LOOP NAMED FIND-FIRST-UNMODIFIED
	       FOR UNMODIFIED ON LAST-UNMODIFIED-NODE
		   ;; If the end is within this (unmodified) section, we are finished.
		   ;; < and not : if =, the next section might be wholly deleted, so we
		   ;; want to look at it too.
	       WHEN (AND ;; This quick test speeds up whole-buffer case
			 (NOT (BP-= END-BP (INTERVAL-LAST-BP BUFFER)))
			 (BP-< END-BP
			       (IF (NULL (SECOND UNMODIFIED))
				   (INTERVAL-LAST-BP (CAR UNMODIFIED))
				   (BP-MIN
				     (INTERVAL-LAST-BP (CAR UNMODIFIED))
				     (INTERVAL-FIRST-BP (SECOND UNMODIFIED))))))
		 DO (RETURN-FROM TOP)
		    ;; If there are no more sections,
		    ;; or the next one after this is modified, exit.
		    
	       UNLESS (AND (CDR UNMODIFIED)
			   (SECTION-NODE-SECTIONIZATION-VALID (SECOND UNMODIFIED)))
		 DO
		   (SETQ LAST-UNMODIFIED-NODE UNMODIFIED
			 INFERIORS (CDR LAST-UNMODIFIED-NODE))
		   (RETURN-FROM FIND-FIRST-UNMODIFIED NIL))
	    
	    (SETQ START-BP
		  (IF (NULL (FIRST INFERIORS)) (INTERVAL-LAST-BP (CAR LAST-UNMODIFIED-NODE))
		      (BP-MIN
			;; If new text is inserted, nodes will overlap since the
			;; start-bp stays put and the end-bp moves past the new text.
			;; So prefer a start-bp, since that will be earlier.
			(INTERVAL-FIRST-BP (FIRST INFERIORS))
			(INTERVAL-LAST-BP (CAR LAST-UNMODIFIED-NODE)))))
	    ;; If there are no more sections and no more text, we are finished.
	    (WHEN
	      (AND (NULL INFERIORS)		; no modified sections clear to the bottom
		   (BP-= START-BP END-BP))
	      (RETURN-FROM TOP)))
	  
	  ;; We need to parse some of the buffer, so establish any necessary bindings
	  (MULTIPLE-VALUE-BIND (PARSING-VARS PARSING-VALS)
	      (SEND SELF ':PARSING-BINDINGS BUFFER)
	    (PROGV PARSING-VARS PARSING-VALS
	      
	      ;; START-BP is now the first line of the local modified area.
	      ;; LAST-UNMODIFIED-NODE is the unmodified section that
	      ;; precedes the modified area.
	      ;; INFERIORS is the list of modified sections.
	      ;; Find the end of this modified area into THIS-AREA-END-BP.
	      (LOOP NAMED FIND-END-OF-MODIFIED-REGION
		    FOR INFS ON INFERIORS
		    AS INF = (FIRST INFS)
		    WHILE INF
		    FINALLY
		      (SETQ THIS-AREA-END-BP (INTERVAL-LAST-BP BUFFER)
			    THIS-AREA-INFERIORS-END NIL)
		    WHEN (SECTION-NODE-SECTIONIZATION-VALID INF)
		      DO
			(SETQ THIS-AREA-END-BP (INTERVAL-FIRST-BP INF)
			      THIS-AREA-INFERIORS-END INFS)
			(RETURN-FROM FIND-END-OF-MODIFIED-REGION NIL))
	      
	      ;; Now loop through this modified area matching up sections.
	      (LET
		((END-LINE (BP-LINE THIS-AREA-END-BP))
		 (STATE (SEND SELF :INITIAL-SECTIONIZATION-STATE))
		 (PREV-NODE-DEFINITION-LINE NIL) PREV-NODE-START-BP
		 PREV-NODE-FUNCTION-SPEC
		 (PREV-NODE-DEFINITION-TYPE 'HEADER)
		 PREV-NODE-STRING
		 THIS-BP FUNCTION-SPEC DEFINITION-TYPE STRING ERROR-P
		 (AT-END-P NIL))
		(LOOP FOR LINE = (BP-LINE START-BP) THEN (LINE-NEXT LINE)
		      DO
		  (WHEN (NULL LINE) (SETQ AT-END-P T))
		  (WHEN (COND (AT-END-P
			       (SETQ THIS-BP THIS-AREA-END-BP)
			       T)
			      (T
			       (MOVE-BP TEMP-BP LINE 0)	;candidate for beginning of section
			       (MULTIPLE-VALUE (FUNCTION-SPEC DEFINITION-TYPE STRING
						ERROR-P STATE)
				 ;; Side-effects on temp-bp if mode wants to
				 ;; choose section start-bp
				 (SEND SELF :SECTION-NAME LINE TEMP-BP STATE))
			       (UNLESS ERROR-P
				 (SETQ THIS-BP (BACKWARD-OVER-COMMENT-LINES TEMP-BP
									    ':FORM-AS-BLANK))
				 T)))
		    ;; We have found a definition line, or we're done and need to clean up.
		    ;; If there is a previous node, try to match it with one on the
		    ;; list of inferiors. When we arrive here, INFERIORS has be be
		    ;; EQ to (cdr LAST-UNMODIFIED-NODE) or LAST-UNMODIFIED-NODE must be NIL
		    (WHEN (AND PREV-NODE-DEFINITION-LINE
			       (NOT (BP-= PREV-NODE-START-BP THIS-BP)))
		      
		      (CL:ASSERT (OR (NULL LAST-UNMODIFIED-NODE)
				     (EQ INFERIORS (CDR LAST-UNMODIFIED-NODE))))
		      
		      (LOOP FOR INFS = INFERIORS THEN (CDR INFS)
			    AS NODE = (FIRST INFS)
			    DO
			(COND ((EQ INFS THIS-AREA-INFERIORS-END)	; this may be NIL
			       ;; Not found, add a new node here
			       ;; went through all the nodes up to the region end,
			       ;; and didn't find node.
			       (SETQ NODE
				     (ADD-SECTION-NODE
				       PREV-NODE-START-BP THIS-BP
				       PREV-NODE-FUNCTION-SPEC
				       PREV-NODE-DEFINITION-TYPE
				       PREV-NODE-DEFINITION-LINE
				       BUFFER
				       (CAR LAST-UNMODIFIED-NODE)
				       (COMPUTE-SECTION-NODE-TICK
					 PREV-NODE-START-BP THIS-BP T)
				       0))
			       ;; If this is the end of the buffer, there is no next
			       ;; section so make the last line part of this section,
			       ;; as SECTIONIZE-BUFFER does.
			       (WHEN (NULL THIS-AREA-INFERIORS-END)
				 (SETF (LINE-NODE (BP-LINE THIS-BP)) NODE))
			       ;; Adjust boundary between this node and predecessor so no overlap
			       (WHEN LAST-UNMODIFIED-NODE
				 (MOVE-BP (INTERVAL-LAST-BP (CAR LAST-UNMODIFIED-NODE))
					  (INTERVAL-FIRST-BP NODE)))
			       ;; Put this new definition into the completion table
			       (SECTION-COMPLETION PREV-NODE-FUNCTION-SPEC PREV-NODE-STRING)
			       (LET ((OTHER-COMPLETION
				       (SEND SELF ':OTHER-SECTION-NAME-COMPLETION
					     PREV-NODE-FUNCTION-SPEC
					     PREV-NODE-DEFINITION-LINE)))
				 (WHEN OTHER-COMPLETION
				   (SECTION-COMPLETION PREV-NODE-FUNCTION-SPEC OTHER-COMPLETION)))
			       ;; Put this new section into the buffer's list of inferiors
			       (IF LAST-UNMODIFIED-NODE
				   (PROGN
				     (PUSH NODE (CDR LAST-UNMODIFIED-NODE))
				     (SETQ LAST-UNMODIFIED-NODE (CDR LAST-UNMODIFIED-NODE))
				     (SPLICE-OUT-SECTIONS LAST-UNMODIFIED-NODE THIS-AREA-INFERIORS-END))
				   (SETF (NODE-INFERIORS BUFFER) (CONS NODE THIS-AREA-INFERIORS-END))
				   (SETQ LAST-UNMODIFIED-NODE (NODE-INFERIORS BUFFER)))
			       (SETQ INFERIORS (CDR LAST-UNMODIFIED-NODE))
			       (SETQ INFERIORS-CHANGED T)
			       (RETURN))
			      ;; so much for the termination case, now for the normal case.
			      ((AND NODE
				    (EQ (SECTION-NODE-DEFINITION-LINE NODE)
					PREV-NODE-DEFINITION-LINE)
				    (EQUAL (SECTION-NODE-FUNCTION-SPEC NODE)
					   PREV-NODE-FUNCTION-SPEC)
				    (EQ (SECTION-NODE-DEFINITION-TYPE NODE)
					PREV-NODE-DEFINITION-TYPE)
				    (BP-= PREV-NODE-START-BP (INTERVAL-FIRST-BP NODE))
				    (BP-= THIS-BP (INTERVAL-LAST-BP NODE)))
			       ;; Matches this node, can just update the tick
			       (SETF (SECTION-NODE-SECTIONIZATION-TICK NODE) *TICK*)
			       ;; The PREV- variables represent where we are in the text.
			       ;; if the node that we are examining matches the text,
			       ;; we are in synch.  If we had to skip some nodes to
			       ;; achieve this, then (NEQ INFS INFERIORS) and we have to
			       ;; drop the losers.
			       (WHEN (NEQ INFS INFERIORS)
				 ;; Splice out nodes whose definition lines
				 ;; weren't found before this one
				 (IF LAST-UNMODIFIED-NODE
				     (SPLICE-OUT-SECTIONS LAST-UNMODIFIED-NODE INFS)
				     (SETF (NODE-INFERIORS BUFFER) INFS))
				 (SETQ INFERIORS-CHANGED T))
			       (SETQ LAST-UNMODIFIED-NODE INFS)	; move along
			       (SETQ INFERIORS (CDR LAST-UNMODIFIED-NODE))
			       (RETURN)))))
		    ;; If we just cleaned up, exit
		    (WHEN AT-END-P (RETURN))
		    ;; Save the definition line we just found to be used when we get to the
		    ;; end of its section
		    (SETQ PREV-NODE-START-BP THIS-BP
			  PREV-NODE-FUNCTION-SPEC FUNCTION-SPEC
			  PREV-NODE-DEFINITION-TYPE DEFINITION-TYPE
			  PREV-NODE-STRING STRING
			  PREV-NODE-DEFINITION-LINE LINE))
		  ;; Prepare to advance to next line
		  (SETQ AT-END-P (EQ LINE END-LINE))))))

	      ;; The whole of one modified area has been processed.  If there are any
	      ;; sections left over, they must have been deleted.
	      
	  (UNLESS (OR (NULL INFERIORS)
		      (EQ INFERIORS THIS-AREA-INFERIORS-END))
	    (IF LAST-UNMODIFIED-NODE
		(SPLICE-OUT-SECTIONS LAST-UNMODIFIED-NODE THIS-AREA-INFERIORS-END)
		(SETF (NODE-INFERIORS BUFFER) THIS-AREA-INFERIORS-END))
	    (SETQ INFERIORS-CHANGED T))
	  
	  ;; Set up to skip over unmodified area that follows
	  (SETQ SKIP-OVER-UNMODIFIED T)
	  (SETQ LAST-UNMODIFIED-NODE THIS-AREA-INFERIORS-END) ;unmodified or NIL
	  (SETQ INFERIORS (CDR LAST-UNMODIFIED-NODE))))

      ;; All incremental processing completed
      (COND (COMPLETELY-MESSED-UP
	     (INCF *COMPLETELY-MESSED-UP*)
	     (SECTIONIZE-BUFFER BUFFER)
	     ':COMPLETE)
	    (INFERIORS-CHANGED
	     (SETF (NAMED-BUFFER-WITH-SECTIONS-FIRST-SECTION BUFFER)
		   (CAR (NODE-INFERIORS BUFFER)))
	     (LOOP FOR PREV = NIL THEN NODE
		   FOR NODE IN (NODE-INFERIORS BUFFER)
		   DO (SETF (NODE-PREVIOUS NODE) PREV)
		      (AND PREV (SETF (NODE-NEXT PREV) NODE))
		   WHEN (NEQ (SECTION-NODE-DEFINITION-TYPE NODE) 'HEADER)
		     COLLECT (LIST (SECTION-NODE-FUNCTION-SPEC NODE)
				   (SECTION-NODE-DEFINITION-TYPE NODE))
		       INTO DEFINITION-LIST
		   FINALLY (AND NODE (SETF (NODE-NEXT NODE) NIL))
			   (CL:SETF 
			     (ZMACS-SECTION-LIST BUFFER) DEFINITION-LIST))
	     (WHEN (NOT (NULL *ZMACS-DEFINITIONS-BUFFER*))
	       (SEND *ZMACS-DEFINITIONS-BUFFER* :BUFFER-SECTIONIZED BUFFER CONTAINING-BUFFER))
	     T)))))

(DEFMETHOD (SECTIONS-P NODE) () NIL)

(DEFMETHOD (SECTIONS-P NAMED-BUFFER-WITH-SECTIONS) () T)



;;; Convert SPEC to a string the way it is likely to be spelled in the source file
;;; i.e. so that it will match what GET-SECTION-NAME will return.
(DEFUN DEFINITION-NAME-AS-STRING (TYPE SPEC)
  TYPE ;not used now, but might be in the future
  (WITH-OUTPUT-TO-STRING (S)
    (IF (LOOP FOR X IN SPEC ALWAYS (SYMBOLP X))
	;; Try to guess what the package prefixes are in the source file.
	;; This doesn't always work, but works more often than just PRIN1.
	(LET ((PACKAGE (SYMBOL-PACKAGE (CADR SPEC))))
	  (FUNCALL S ':TYO #/()
	  (PRIN1 (CAR SPEC) S)
	  (LOOP FOR X IN (CDR SPEC)
		;; AS P = (SYMBOL-PACKAGE X)
		DO (FUNCALL S ':TYO #\SP)
		   (PRIN1 X S))
	  (FUNCALL S ':TYO #/)))
	;; Not all symbols, stay on the safe side
	(PRIN1 SPEC S))))

;;; Every major mode may have an EDITING-TYPE property that tells Zwei
;;; general things about what the format of text in the buffer is like.
;;; Zwei uses this to figure out how parse sections in the buffer, and
;;; whether Update Attribute List should put in a Package property.
(DEFPROP LISP-MODE :LISP EDITING-TYPE)
(DEFPROP ZTOP-MODE :LISP EDITING-TYPE)
(DEFPROP TEXT-MODE :TEXT EDITING-TYPE)
(DEFPROP BOLIO-MODE :TEXT EDITING-TYPE)
(DEFPROP FUNDAMENTAL-MODE :TEXT EDITING-TYPE)

(COMMENT
(DEFUN GET-SECTION-NAME (EDITING-TYPE LINE BP)
  (DECLARE (VALUES FSPEC TYPE STR ERROR-P))
  (SELECTQ EDITING-TYPE
    (:LISP
     (IF (AND (%STRING-EQUAL LINE 0 "(DEF" 0 4)
	      (NOT (%STRING-EQUAL LINE 4 "PROP " 0 5)))	;"(DEFPROP "
	 (GET-DEFINITION-FUNCTION-SPEC (MOVE-BP BP LINE 0))
	 (VALUES NIL NIL NIL T)))
    (:TEXT
     (IF (%STRING-EQUAL LINE 0 ".DEF" 0 4)
	 (GET-TEXT-DEFINITION-NAME (MOVE-BP BP LINE 0))
	 (VALUES NIL NIL NIL T)))
    (OTHERWISE
     (VALUES NIL NIL NIL T))))
)

(DEFUN DEFSTRUCT-FUNCTION-SPEC-FINDER (BP)
  (FORWARD-LIST BP 1 NIL -1 T))
(DEFPROP DEFSTRUCT DEFSTRUCT-FUNCTION-SPEC-FINDER DEFINITION-FUNCTION-SPEC-FINDER)
(DEFPROP DEFINE-USER-OPTION DEFSTRUCT-FUNCTION-SPEC-FINDER DEFINITION-FUNCTION-SPEC-FINDER)
(DEFUN (DEFINE-SPECIAL-BUFFER-TYPE DEFINITION-FUNCTION-SPEC-FINDER) (BP)
  (FORWARD-SEXP BP 3))

;; DEFSELECT can't use DEFINITION-FUNCTION-SPEC-FINDER-TEMPLATE since the cadr of the form can
;; be either a symbol or a list.

(DEFUN DEFSELECT-FUNCTION-SPEC-FINDER (BP)
  (AND (SETQ BP (FORWARD-OVER *WHITESPACE-CHARS* BP))
       (IF (CHAR-EQUAL (BP-CHAR BP) #/()	;** was BP-CH-CHAR
	   (FORWARD-LIST BP 1 NIL -1 T)		;(defselect (foo bar) ...)
	   BP)))				;(defselect foo ...)

(DEFPROP DEFSELECT         DEFSELECT-FUNCTION-SPEC-FINDER DEFINITION-FUNCTION-SPEC-FINDER)
(DEFPROP SI:DEFSELECT-COLD DEFSELECT-FUNCTION-SPEC-FINDER DEFINITION-FUNCTION-SPEC-FINDER)
;; The Common Lisp DEFSTRUCT is like DEFSELECT.
(DEFPROP CL:DEFSTRUCT      DEFSELECT-FUNCTION-SPEC-FINDER DEFINITION-FUNCTION-SPEC-FINDER)
(DEFPROP LMFS:DEFSTORAGE   DEFSELECT-FUNCTION-SPEC-FINDER DEFINITION-FUNCTION-SPEC-FINDER)
(DEFPROP CLI::DEFINE-KEYWORD-TO-POSITIONAL-ARGUMENTS-FUNCTION
			   DEFSELECT-FUNCTION-SPEC-FINDER DEFINITION-FUNCTION-SPEC-FINDER)

(DEFPROP FUTURE-COMMON-LISP:DEFUN DEFUN DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEF DEFUN DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFF DEFUN DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFFUNCTION DEFUN DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFMACRO DEFUN DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFMACRO-DISPLACE DEFUN DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFMETHOD DEFUN DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFSELECT DEFUN DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP SI:DEFSELECT-COLD DEFUN DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFSUBST DEFUN DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFUNP DEFUN DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFWHOPPER DEFUN DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFWHOPPER-SUBST DEFUN DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFWRAPPER DEFUN DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP CL:DEFINE-MODIFY-MACRO DEFUN DEFINITION-FUNCTION-SPEC-TYPE)

(DEFPROP DEFCONST          DEFVAR DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFCONSTANT	   DEFVAR DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP CL:DEFPARAMETER   DEFVAR DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFVAR-RESETTABLE DEFVAR DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFVAR-STANDARD   DEFVAR DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFINE-METERS	   DEFVAR DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFINE-SITE-ALIST-USER-OPTION DEFVAR DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFINE-SITE-HOST-LIST DEFVAR DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFINE-SITE-USER-OPTION DEFVAR DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFINE-SITE-VARIABLE DEFVAR DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFINE-USER-OPTION DEFVAR DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFINE-USER-OPTION-ALIST DEFVAR DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP SYS:DEFINE-METERS DEFVAR DEFINITION-FUNCTION-SPEC-TYPE)

(DEFPROP TV:DEFWINDOW-RESOURCE DEFRESOURCE DEFINITION-FUNCTION-SPEC-TYPE)

;;; ---this desperately needs an argument to suppress consing the 
;;; --- STRING return value for callers that don't case.
;;; Given a BP to the beginning of a DEFINITION (as returned by BACKWARD-DEFINITION,
;;; or MARK-DEFINITION), return the function spec and definition type for the definition.
(DEFUN GET-DEFINITION-FUNCTION-SPEC (BP &AUX BP1 TYPE)
  (DECLARE (VALUES FSPEC TYPE STR ERROR-P))
  (IF (AND (SETQ BP (FORWARD-CHAR BP))
	   (SETQ BP1 (FORWARD-ATOM BP))
	   (LET ((DEFINITION-NAME
		   (CONDITION-CASE ()
			(WITH-INPUT-FROM-INTERVAL (STREAM BP BP1)
			  (READ STREAM))
		     (SYS:READ-ERROR NIL))))
	     (WHEN (SYMBOLP DEFINITION-NAME)
	       (SETQ TYPE (OR (GET DEFINITION-NAME 'DEFINITION-FUNCTION-SPEC-TYPE)
			      DEFINITION-NAME))
	       (LET ((PARSER (GET DEFINITION-NAME 'DEFINITION-FUNCTION-SPEC-PARSER)))
		 (WHEN PARSER
		   (RETURN-FROM GET-DEFINITION-FUNCTION-SPEC
		     (FUNCALL PARSER (FORWARD-OVER *WHITESPACE-CHARS* BP1)))))
	       (LET ((FINDER (GET DEFINITION-NAME 'DEFINITION-FUNCTION-SPEC-FINDER)))
		 (OR (NULL FINDER)
		     (NOT (NULL (SETQ BP1 (FUNCALL FINDER BP1))))))))
	   (SETQ BP (FORWARD-OVER *WHITESPACE-CHARS* BP1))
	   (SETQ BP1 (FORWARD-SEXP BP)))
      (LET ((STR (STRING-INTERVAL BP BP1)))
	(MULTIPLE-VALUE-BIND (FSPEC ERROR-P)
	    (SYMBOL-FROM-STRING STR (BP-LINE BP))
	  (VALUES FSPEC TYPE STR ERROR-P)))
      (VALUES NIL NIL NIL T)))

;;; Sectionization support

;;; Utility Function for DEFINITION-FUNCTION-SPEC-PARSER's

(DEFUN READ-FSPEC-ITEM-FROM-STRING (STRING &KEY (START 0) END)
  (DECLARE (VALUES THING-READ ERROR-P))
  (LET ((RESULT
	  (CONDITION-CASE (ERROR)
	       (CL:READ-FROM-STRING STRING NIL '|Extraordinarily unlikely function spec|
				    :START START :END END)
	     (SYS:READ-ERROR '|Extraordinarily unlikely function spec|))))
    (IF (EQ RESULT '|Extraordinarily unlikely function spec|)
	(VALUES NIL T)
	(VALUES RESULT NIL))))

(DEFUN READ-FSPEC-ITEM-FROM-INTERVAL (SBP EBP)
  (DECLARE (VALUES THING-READ ERROR-P))
  (LET ((RESULT
	  (CONDITION-CASE (ERROR)
	       (WITH-INPUT-FROM-INTERVAL (STREAM SBP EBP)
		 (CL:READ STREAM NIL '|Extraordinarily unlikely function spec|))
	     (SYS:READ-ERROR '|Extraordinarily unlikely function spec|))))
    (IF (EQ RESULT '|Extraordinarily unlikely function spec|)
	(VALUES NIL T)
	(VALUES RESULT NIL))))

(DEFUN (:PROPERTY DEFMETHOD DEFINITION-FUNCTION-SPEC-PARSER) (BP-AFTER-DEFMETHOD)
  ;; The next SEXP has to be (FSPEC FLAVOR . OTHER-THINGS)
  ;; We return (FLAVOR:METHOD FSPEC FLAVOR OTHER-THINGS)
  (METHOD-DEFINITION-FUNCTION-SPEC-PARSER BP-AFTER-DEFMETHOD 'FLAVOR:METHOD))

(DEFUN METHOD-DEFINITION-FUNCTION-SPEC-PARSER (BP-AFTER-DEFMETHOD TYPE)
  (LET ((AFTER-METHOD-BP (FORWARD-SEXP BP-AFTER-DEFMETHOD)))
    (WHEN AFTER-METHOD-BP
      (MULTIPLE-VALUE-BIND (METHOD-SPEC ERROR-P)
	  (READ-FSPEC-ITEM-FROM-INTERVAL BP-AFTER-DEFMETHOD AFTER-METHOD-BP)
	(IF (OR ERROR-P (SYMBOLP METHOD-SPEC))
	    (VALUES NIL NIL NIL T)
	    (LET ((FSPEC (LIST* TYPE METHOD-SPEC)))
	      (IF 
		(SI:VALIDATE-FUNCTION-SPEC FSPEC)
		;; cons the string if we are really returning. No choice.
		(VALUES FSPEC 'DEFUN (STRING-INTERVAL BP-AFTER-DEFMETHOD AFTER-METHOD-BP T)
			NIL)
		(VALUES NIL NIL NIL T))))))))

(DEFUN (:PROPERTY DEFWHOPPER DEFINITION-FUNCTION-SPEC-PARSER) (BP-AFTER-DEFMETHOD)
  ;; The next SEXP has to be (FSPEC FLAVOR)
  ;; We return (FLAVOR:NCWHOPPER FSPEC FLAVOR)
  (METHOD-DEFINITION-FUNCTION-SPEC-PARSER BP-AFTER-DEFMETHOD 'FLAVOR:NCWHOPPER))

(DEFUN (:PROPERTY DEFWRAPPER DEFINITION-FUNCTION-SPEC-PARSER) (BP-AFTER-DEFMETHOD)
  ;; The next SEXP has to be (FSPEC FLAVOR)
  ;; We return (FLAVOR:WRAPPER FSPEC FLAVOR)
  (METHOD-DEFINITION-FUNCTION-SPEC-PARSER BP-AFTER-DEFMETHOD 'FLAVOR:WRAPPER))

(DEFUN (:PROPERTY DEFWHOPPER-SUBST DEFINITION-FUNCTION-SPEC-PARSER) (BP-AFTER-DEFMETHOD)
  ;; The next SEXP has to be (FSPEC FLAVOR)
  ;; We return (FLAVOR:WRAPPER FSPEC FLAVOR)
  (METHOD-DEFINITION-FUNCTION-SPEC-PARSER BP-AFTER-DEFMETHOD 'FLAVOR:WRAPPER))

(DEFUN CLOS-METHOD-DEFINITION-FUNCTION-SPEC-PARSER (BP-AFTER-DEFMETHOD
						    FUNCTION-NAME-PREPROCESSOR
						    SPECIALIZER-PREPROCESSOR)
  ;; What follows is generic-function-name {qualifier}* specialized-lambda-list
  (DECLARE (VALUES FSPEC TYPE STR ERROR-P)
	   (SYS:DOWNWARD-FUNARG FUNCTION-NAME-PREPROCESSOR SPECIALIZER-PREPROCESSOR))
  (BLOCK BLOCK
    (LET ((QUALIFIERS NIL)
	  GENERIC-FUNCTION-NAME
	  SPECIALIZERS
	  ARGLIST
	  (BP (FORWARD-SEXP BP-AFTER-DEFMETHOD)))
      (UNLESS BP
	(RETURN-FROM BLOCK NIL))
      ;; Parse the generic-function-name
      (MULTIPLE-VALUE-BIND (SEXP ERROR-P)
	  (READ-FSPEC-ITEM-FROM-INTERVAL BP-AFTER-DEFMETHOD BP)
	(WHEN FUNCTION-NAME-PREPROCESSOR
	  (SETQ SEXP (FUNCALL FUNCTION-NAME-PREPROCESSOR SEXP)))
	(WHEN (OR ERROR-P
		  (NOT (SI:VALIDATE-FUNCTION-SPEC (SETQ GENERIC-FUNCTION-NAME SEXP))))
	  (RETURN-FROM BLOCK 
	    (VALUES NIL NIL NIL T))))
      ;; Parse the qualifiers and specialized-lambda-list
      (LOOP AS BP1 = (FORWARD-SEXP BP) DO
	(UNLESS BP1 (RETURN-FROM BLOCK NIL))
	(MULTIPLE-VALUE-BIND (SEXP ERROR-P)
	    (READ-FSPEC-ITEM-FROM-INTERVAL BP BP1)
	  (WHEN ERROR-P
	    (RETURN-FROM BLOCK 
	      (VALUES NIL NIL NIL T)))
	  (WHEN (CL:LISTP SEXP)
	    (RETURN (SETQ ARGLIST SEXP)))
	  (PUSH SEXP QUALIFIERS)
	  (SETQ BP BP1)))
      ;; Parse the parameter specializers
      (SETQ SPECIALIZERS
	    (LOOP WHILE (CL:CONSP ARGLIST)
		  AS ITEM = (POP ARGLIST)
		  UNTIL (MEMQ ITEM LAMBDA-LIST-KEYWORDS)
		  COLLECT (IF (CL:CONSP ITEM)
			      (IF SPECIALIZER-PREPROCESSOR
				  (FUNCALL SPECIALIZER-PREPROCESSOR (SECOND ITEM))
				  (SECOND ITEM))
			      'T)))
      ;; Assemble the function-spec from the pieces
      (LET ((FUNCTION-SPEC `(CLOS:METHOD ,GENERIC-FUNCTION-NAME
						    ,SPECIALIZERS
						    ,@(NREVERSE QUALIFIERS))))
	(IF (SYS:VALIDATE-FUNCTION-SPEC FUNCTION-SPEC)
	    (VALUES FUNCTION-SPEC
		    'DEFUN
		    ;; STR isn't any particular string out of the source, since
		    ;; CLOS doesn't put the method name in a separate syntactic place
		    (FORMAT NIL "~S" (CDR FUNCTION-SPEC))
		    NIL)
	    (VALUES NIL 'DEFUN NIL T))))))

(DEFUN (:PROPERTY CLOS:DEFMETHOD DEFINITION-FUNCTION-SPEC-PARSER) (BP-AFTER-DEFMETHOD)
  ;; What follows is generic-function-name {qualifier}* specialized-lambda-list
  (CLOS-METHOD-DEFINITION-FUNCTION-SPEC-PARSER BP-AFTER-DEFMETHOD NIL NIL))

;;; Unambiguous parser for DEFUN that don't have to pussyfoot with defmethod.

(DEFUN (:PROPERTY DEFUN DEFINITION-FUNCTION-SPEC-PARSER) (BP-AFTER-DEFUN)
  ;; The next SEXP has to be a valid function spec, or a two-list, which we convert
  ;; to (:PROPERTY FOO BAR)
  ;; no sympathy for MacLisp here.
  (LET ((AFTER-FSPEC-BP (FORWARD-SEXP BP-AFTER-DEFUN)))
    (WHEN AFTER-FSPEC-BP
      (MULTIPLE-VALUE-BIND (FSPEC ERROR-P)
	  (READ-FSPEC-ITEM-FROM-INTERVAL BP-AFTER-DEFUN AFTER-FSPEC-BP)
	(COND (ERROR-P
	       (VALUES NIL NIL NIL T))
	      ((NULL FSPEC)
	       (VALUES NIL NIL NIL T))		; DEFUN NIL is not our problem.
	      ((SETQ FSPEC (SYS:STANDARDIZE-FUNCTION-SPEC FSPEC NIL))
	       ;; this includes VALIDATE
	       (VALUES FSPEC 'DEFUN (STRING-INTERVAL BP-AFTER-DEFUN AFTER-FSPEC-BP T) NIL))
	      (T (VALUES FSPEC 'DEFUN (STRING-INTERVAL BP-AFTER-DEFUN AFTER-FSPEC-BP T)
			 NIL)))))))

;;; Likewise for text files
(DEFUN GET-TEXT-DEFINITION-NAME (BP &AUX BP1)
  (ATOM-WORD-SYNTAX-BIND
    ;; Now get the second word after BP.
    (IF (AND (SETQ BP (FORWARD-WORD BP))
	     (SETQ BP (FORWARD-OVER *BLANKS* BP))
	     (SETQ BP1 (FORWARD-WORD BP)))
	(LET ((STRING (STRING-INTERVAL BP BP1)))
	  (VALUES (INTERN STRING *UTILITY-PACKAGE*) NIL STRING))
	(VALUES NIL NIL NIL T))))

;;; Return a BP within INTERVAL likely to define SYMBOL,
;;; Priority is: line starting with (, non-comment line, comment line, start of buffer
(DEFUN DEFINITION-LIKELY-POSITION (BP1 &OPTIONAL BP2 IN-ORDER-P SYMBOL
				       &AUX DEFINITION-LINE NON-DEFINITION-LINE COMMENT-LINE
					    BUFFER)
  (GET-INTERVAL BP1 BP2 IN-ORDER-P)
  (DO ((LINE (BP-LINE BP1) (LINE-NEXT-IN-BUFFER LINE))
       (FROM-INDEX (BP-INDEX BP1) 0)
       (END-LINE (BP-LINE BP2))
       (KEY (STRING-FROM-NAME SYMBOL))
       (INDEX) (TEM))
      (NIL)
    (AND (SETQ INDEX (STRING-SEARCH KEY LINE FROM-INDEX
				    (AND (EQ LINE END-LINE) (BP-INDEX BP2))))
	 (COND ((CHAR-EQUAL #/( (AREF LINE 0))
		(SETQ DEFINITION-LINE LINE)
		(RETURN T))
	       ((AND (NULL COMMENT-LINE) (SETQ TEM (FIND-COMMENT-START LINE)) (< TEM INDEX))
		(SETQ COMMENT-LINE LINE))
	       ((NULL NON-DEFINITION-LINE)
		(SETQ NON-DEFINITION-LINE LINE))))
    (AND (EQ LINE END-LINE)
	 (RETURN NIL)))
  (SETQ BUFFER (BP-TOP-LEVEL-NODE BP1))  
  (VALUES (CREATE-BP (OR DEFINITION-LINE NON-DEFINITION-LINE COMMENT-LINE (BP-LINE BP1))
		     0)
	  BUFFER))

(DEFUN STRING-FROM-NAME (NAME)
  (COND ((STRINGP NAME) NAME)
	((SYMBOLP NAME) (GET-PNAME NAME))
	(T (FORMAT NIL "~S" NAME))))

(DEFUN PACKAGE-LOOKALIKE-SYMBOLS (PNAME
				  &OPTIONAL TOP-PACKAGE
					    (PROPERTIES '(:SOURCE-FILE-NAME ZMACS-BUFFERS)))
  (SI:POOR-MAN/'S-WITH-COLLECTION (ANSWER)
    (DBG:MAP-OVER-LOOKALIKE-SYMBOLS PNAME TOP-PACKAGE
      #'(LAMBDA (SYMBOL)
	  (WHEN (AND (OR (EQ PROPERTIES T)
		       (LOOP FOR PROP IN PROPERTIES
			     THEREIS (GET SYMBOL PROP)))
		     (NOT (MEMQ SYMBOL ANSWER)))
	    (COLLECT-ANSWER SYMBOL))))
    ANSWER))

;;; The following provides a form to toss into VC hard sections that are otherwise
;;; anonymous.
(DEFPROP DEFINE-SECTION-NAME "Section Name" SI:DEFINITION-TYPE-NAME)
(DEFMACRO DEFINE-SECTION-NAME (&REST IGNORE)
  )
