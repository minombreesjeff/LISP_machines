;;; -*- Syntax: Zetalisp; Mode: LISP; Package: ZWEI; Base: 8 -*-
;;; Some simple ZWEI command functions.

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; DEFS contains a list of all free variables used by these commands.
;;; Any editor that wishes to use these commands must bind all of them.
;;; When adding any to this file, or to primitives called by functions
;;; in this file, update the list in DEFS.

;;; The caller of these functions should also provide a function
;;; called BARF, to report errors.  It should take arguments like
;;; the &REST to FORMAT.

;;; Commands in this file also use the PROMPT and TYPEIN lines
;;; to interact with the user.  In order to keep the implementation
;;; of these lines as flexible as possible, a very minimal interface
;;; is defined herein.  The following functions may be used to access
;;; these lines:

;;; (PROMPT-LINE <ctl-string> . <args>)
;;;    Do formatted output to the prompt line.  The line is cleared and homed first.

;;; (PROMPT-LINE-MORE <ctl-string> . <args>)
;;;    Do formatted output to the prompt line, without clearing and homeing.

;;; (TYPEIN-LINE <ctl-string> . <args>)
;;;    Do formatted output to the typein line.  The line is cleared and homed first.

;;; (TYPEIN-LINE-MORE <ctl-string> . <args>)
;;;    Do formatted output to the typein line, without clearing and homeing.

;;; (TYPEIN-LINE-Y-OR-N-P <ctl-string> . <args>)
;;;    Do formatted output to the typein line, and ask for a Y or N answer (see Y-OR-N-P).

;;; (TYPEIN-LINE-ACTIVATE . <body>)
;;;    This is a SPECIAL FORM.  Within the body, the blinker for the typein line
;;;    will be on, and input from the typein line is allowed by using the
;;;    value of TYPEIN-LINE-STREAM, on which regular stream input operations will
;;;    work.  None of the other TYPEIN line or PROMPT line functions should
;;;    be called while in the scope of a TYPEIN-LINE-ACTIVATE; all you may
;;;    do is read from the stream.

;;; (TYPEIN-LINE-READLINE <ctl-string> . <args>)
;;;    Read in a line from the typein line, with editing.  The arguments
;;;    are passed along to the prompt line.

;;; (TYPEIN-LINE-READ <ctl-string> . <args>)
;;;    Like the above, but does a READ instead of a READLINE.

;;; *TYPEOUT-WINDOW*
;;;    A larger, menu-like window for random stream output.

(DEFCOM COM-SELF-INSERT "Inserts the last character typed.
With a numeric argument (n), it inserts the character n times." (NM)
  (LET* ((CHAR (IN-CURRENT-STYLE *LAST-COMMAND-CHAR*))
	 (POINT (POINT)))
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK POINT))
      (DOTIMES (IGNORE *NUMERIC-ARG*)
	(INSERT-MOVING POINT CHAR))
      (MOVE-POINT POINT)
      (SETQ *CURRENT-COMMAND-TYPE* 'SELF-INSERT)
      (IF (CHAR= CHAR #\CR) DIS-TEXT
	;;--- Changed to not copy (BP-LINE POINT) before munging the line, for copy-on-write
	(VALUES DIS-LINE (BP-LINE POINT) (- (BP-INDEX POINT) *NUMERIC-ARG*))))))


(DEFCOM COM-QUOTED-INSERT
	"Inserts any keyboard character unless it is a digit.
If a digit follows, an octal number is read and that character code is inserted.
With a numeric argument, it inserts that many copies of the character.
With modifier keys, it inserts the ASCII control character equivalent." (NM)
  (LET ((CH (READ-ARGUMENT-CHARACTER-WITH-POSSIBLE-PROMPT
	       "~:[~*~;~D ~]~:C: " *NUMERIC-ARG-P* *NUMERIC-ARG* *LAST-COMMAND-CHAR*)))
    (WHEN (DIGIT-CHAR-P CH 8)
      (SETQ CH (DIGIT-CHAR-P CH 8))
      (LOOP REPEAT 2
	    AS CH1 = (FUNCALL STANDARD-INPUT :TYI)
	    DO (IF (DIGIT-CHAR-P CH1 8)
		   (SETQ CH (+ (* CH 8) (DIGIT-CHAR-P CH1 8)))
		 (OR (CHAR-EQUAL CH1 #\SP)
		     (FUNCALL STANDARD-INPUT :UNTYI CH1))
		 (RETURN NIL)))
      (SETQ CH (CODE-CHAR CH)))
    (LET ((*LAST-COMMAND-CHAR* (IF (NOT (ZEROP (CHAR-BITS CH)))
				   (CODE-CHAR (LOGAND #O037 (CHAR-CODE CH)))
				 CH)))
      (COM-SELF-INSERT))))

(DEFCOM COM-FORWARD "Moves forward one character.
With a numeric argument (n), it moves forward n characters." (KM R)
  (MOVE-POINT (OR (FORWARD-CHAR (POINT) *NUMERIC-ARG* nil *interval*) (BARF)))
  (SET-CENTERING-FRACTION *NUMERIC-ARG*)
  DIS-BPS)

(DEFCOM COM-BACKWARD "Moves backward one character.
With a numeric argument (n), it moves backward n characters." (KM -R)
  (MOVE-POINT (OR (FORWARD-CHAR (POINT) (- *NUMERIC-ARG*) nil *interval*) (BARF)))
  (SET-CENTERING-FRACTION (- *NUMERIC-ARG*))
  DIS-BPS)

(DEFCOM COM-GOTO-CHARACTER "Moves point to the nth character from top of the buffer.  
Newlines count as two characters.
If argument (n) is:      Point moves forward:
Negative		 |n|
Positive		  n
0 or no argument	  0 (beeps)" (KM)
  (UNLESS *NUMERIC-ARG-P*
    (BARF))
  (MOVE-POINT (OR (FUNCALL (IF (MINUSP *NUMERIC-ARG*) #'FORWARD-ITS-CHAR #'FORWARD-CHAR)
			   (INTERVAL-FIRST-BP *INTERVAL*) (ABS *NUMERIC-ARG*))
		  (BARF "There are fewer than ~D. characters in the buffer." *NUMERIC-ARG*)))
  DIS-BPS)

(DEFCOM COM-DOWN-REAL-LINE "Moves down vertically to next line.
With a numeric argument (n), it moves down vertically n lines.
It tries to keep the point as close as possible to its original
column position (goal column) for successive commands." (KM R)
  (DOWN-REAL-LINE *NUMERIC-ARG*))

(DEFCOM COM-UP-REAL-LINE "Moves up vertically to previous line.
With a numeric argument (n), it moves up vertically n lines.
It tries to keep the point as close as possible to its original
column position (goal column) for successive commands." (KM -R)
  (DOWN-REAL-LINE (- *NUMERIC-ARG*)))

(DEFCOM COM-BEGINNING-OF-NEXT-LINE "Move to beginning of next line.
With a numeric argument (n), it moves down n lines." (KM R)
  (DOWN-REAL-LINE *NUMERIC-ARG* 0))

(DEFCOM COM-BEGINNING-OF-PREV-LINE "Move to beginning of previous line.
With a numeric argument (n), it moves up n lines." (KM -R)
  (DOWN-REAL-LINE (- *NUMERIC-ARG*) 0))

(DEFUN DOWN-REAL-LINE (N-LINES &OPTIONAL (GOAL-XPOS-OVERRIDE *PERMANENT-REAL-LINE-GOAL-XPOS*))
  (SETQ *CURRENT-COMMAND-TYPE* 'REAL-MOVE)
  (SET-CENTERING-FRACTION N-LINES)
  (LET ((POINT (POINT))
	(RET DIS-BPS))
    (LET ((DEST (FORWARD-LINE POINT N-LINES NIL *INTERVAL*)))
      (COND ((NULL DEST)
	     ;; He overshot.
	     (COND ((AND (MINUSP N-LINES) *NUMERIC-ARG-P*)
		    (LET ((TARGET-BP (INTERVAL-FIRST-BP *INTERVAL*)))
		      (IF (AND ;; We're not going to extend the buffer in this case,
			       ;; but this makes the behavior symmetric with the
			       ;; end-of-buffer behavior.
			       ;; This also has a good effect on runaway keyboard macros!
			       (NOT (MEMBER *LINE-MOTION-EXTENDS-BUFFER*
					    '(:BACKWARD :ALWAYS)))
			       (BP-= TARGET-BP POINT))
			  (BARF "Attempt to move backward past beginning of buffer."))
		      ;; He was going backwards, go to beginnning.
		      (MOVE-POINT TARGET-BP)
		      (SETQ *REAL-LINE-GOAL-XPOS* 0)))
		   ((NOT *NUMERIC-ARG-P*)
		    ;; No explicit argument given
		    (COND ((MINUSP N-LINES)
			   ;; Going up
			   (IF (NOT (MEMBER *LINE-MOTION-EXTENDS-BUFFER*
					    '(:BACKWARD :ALWAYS)))
			       (BARF
				 "Attempt to move backward past beginning of buffer."))
			   ;; Create a line.
			   (SETQ RET DIS-TEXT)
			   (INSERT (INTERVAL-FIRST-BP *INTERVAL*) #\CR)
			   (MOVE-POINT (INTERVAL-FIRST-BP *INTERVAL*)))
			  (T
			   ;; Going down
			   (IF (NOT (MEMBER *LINE-MOTION-EXTENDS-BUFFER*
					    '(:FORWARD :ALWAYS)))
			       (BARF "Attempt to move forward past end of buffer."))
			   ;; Create a line at end of buffer.
			   (SETQ RET DIS-TEXT)
			   (MOVE-POINT (INSERT (INTERVAL-LAST-BP *INTERVAL*) #\CR)))))
		   (T
		    (LET ((TARGET-BP (INTERVAL-LAST-BP *INTERVAL*)))
		      (IF (AND ;; Stop runaway keyboard macros, etc.
			       (NOT (MEMBER *LINE-MOTION-EXTENDS-BUFFER*
					    '(:FORWARD :ALWAYS)))
			       (BP-= TARGET-BP POINT))
			  (BARF "Attempt to move forward past end of buffer."))
		      ;; He was going forwards, go to end.
		      (MOVE-POINT TARGET-BP)
		      (SETQ *REAL-LINE-GOAL-XPOS* (BP-INDENTATION POINT))))))
	    (T
	     (SETQ DEST (BP-LINE DEST))
	     (SETQ *REAL-LINE-GOAL-XPOS*
		   (COND (GOAL-XPOS-OVERRIDE)
			 ((EQ *LAST-COMMAND-TYPE* 'REAL-MOVE)
			  *REAL-LINE-GOAL-XPOS*)
			 (T (BP-INDENTATION POINT))))
	     (LET ((INDEX (INDENTATION-INDEX DEST *REAL-LINE-GOAL-XPOS*)))
	       (MOVE-POINT DEST
			   (COND (INDEX)
				 ((NEQ DEST (BP-LINE (INTERVAL-LAST-BP *INTERVAL*)))
				  (LINE-LENGTH DEST))
				 (T (BP-INDEX (INTERVAL-LAST-BP *INTERVAL*)))))))))
    RET))

(DEFCOM COM-SET-GOAL-COLUMN "Sets the default column position (goal column).
(The goal column sets point position for Up Real Line and Down
Real Line.)  It disables the default action of matching the goal column
to the current point and sets the goal column to zero instead.  With a numeric
argument (n), it sets the goal column to n." (KM)
  (LET ((COL (IF (> *NUMERIC-ARG* 1) NIL (BP-INDENTATION (POINT)))))
    (SET-VARIABLE-VALUE '*PERMANENT-REAL-LINE-GOAL-XPOS* COL ':ASK)
    (REPORT-COLUMN-SETTING "c-N//c-P goal column" COL))
  DIS-NONE)

(DEFCOM COM-RECENTER-WINDOW
	"Redisplays the buffer, possibly changing what part of the buffer is displayed.
With no argument, it moves the line containing point to near the middle
of the screen.  The exact position is controlled by the variable Center
Fraction.  A numeric argument specifies where to place the line
containing point by specifying which line of the window. Negative
arguments count up from the bottom." (KM)
  (IF *NUMERIC-ARG-P*
      (RECENTER-WINDOW *WINDOW* :ABSOLUTE *NUMERIC-ARG* :LINE)
    (MUST-REDISPLAY *WINDOW* DIS-ALL)
    (RECENTER-WINDOW *WINDOW* :ABSOLUTE))
  DIS-NONE)

(DEFCOM COM-COMPLETE-REDISPLAY "Redisplays all windows." (KM)
  (FUNCALL *TYPEOUT-WINDOW* ':DEACTIVATE)
  (FUNCALL *MODE-LINE-WINDOW* ':REFRESH)
  (SELECT-WINDOW *WINDOW*)
  (DOLIST (WINDOW *WINDOW-LIST*)
    (AND (WINDOW-READY-P WINDOW)
	 (FUNCALL (WINDOW-SHEET WINDOW) ':REFRESH)))
  DIS-NONE)

(DEFCOM COM-NEXT-SCREEN "Displays the next screenful of text.
With a numeric argument (n), it moves window down n lines (rather than n
screens)." (KM)
  (SELECTQ *NUMERIC-ARG-P*
    ((NIL :SIGN)
     (RECENTER-WINDOW-RELATIVE *WINDOW* *NUMERIC-ARG* :SCREEN))
    (OTHERWISE
     (RECENTER-WINDOW-RELATIVE *WINDOW* *NUMERIC-ARG* :LINE)))
  DIS-NONE)

(DEFCOM COM-PREVIOUS-SCREEN "Displays the previous screenful of text.
With a numeric argument (n), it moves window up n lines (rather than n
screens)." (KM)
  (SELECTQ *NUMERIC-ARG-P*
    ((NIL :SIGN)
     (RECENTER-WINDOW-RELATIVE *WINDOW* (- *NUMERIC-ARG*) :SCREEN))
    (OTHERWISE
     (RECENTER-WINDOW-RELATIVE *WINDOW* (- *NUMERIC-ARG*) :LINE)))
  DIS-NONE)

(DEFCOM COM-NEXT-SEVERAL-SCREENS "Moves forward in the buffer by one screenful of text.
With a numeric argument (n), it moves down n screenfuls." (KM)
  (RECENTER-WINDOW-RELATIVE *WINDOW* *NUMERIC-ARG* :SCREEN)
  DIS-NONE)

(DEFCOM COM-PREVIOUS-SEVERAL-SCREENS "Moves backward in the buffer by one screenful of text.
With a numeric argument (n), it moves back n screenfuls." (KM)
  (RECENTER-WINDOW-RELATIVE *WINDOW* (- *NUMERIC-ARG*) :SCREEN)
  DIS-NONE)

(DEFCOM COM-BEGINNING-OF-LINE "Moves to the beginning of the line.
With a numeric argument (n), it also moves forward by n-1 lines." (KM)
  (MOVE-POINT (BEG-LINE (POINT) (1- *NUMERIC-ARG*) T))
  DIS-BPS)

(DEFCOM COM-END-OF-LINE "Moves to the end of the line.
With a numeric argument (n), it also moves forward by n-1 lines." (KM)
  (MOVE-POINT (END-LINE (POINT) (1- *NUMERIC-ARG*) T))
  DIS-BPS)

(DEFCOM COM-MOVE-TO-SCREEN-EDGE
	"Moves to the beginning of a specified line on the screen.
With no argument, it moves to the beginning of a line near the middle of
the screen.  The exact line is controlled by the variable Center
Fraction.  A numeric argument specifies a particular line to move to.
Negative arguments count up from the bottom of the window." (KM)
  (REDISPLAY *WINDOW* ':POINT NIL NIL T)	;Force redisplay to completion first
  (LET* ((N-PLINES (WINDOW-N-PLINES *WINDOW*))
	 (PLINE (RANGE (IF *NUMERIC-ARG-P*
			   (+ *NUMERIC-ARG*
			      (IF (MINUSP *NUMERIC-ARG*) N-PLINES 0))
			   (FIX (* *CENTER-FRACTION* N-PLINES)))
		       0 (1- N-PLINES))))
    (MOVE-POINT (PLINE-LINE *WINDOW* PLINE) (PLINE-FROM-INDEX *WINDOW* PLINE)))
  DIS-BPS)

(DEFCOM COM-GOTO-BEGINNING "Moves to the beginning of the buffer.
With a numeric argument (n), where n is from 0 to 10, it goes n//tenths
of the length of the buffer down from the beginning." (KM PUSH)
  (IF *NUMERIC-ARG-P*
      (MOVE-FRACTIONALLY *NUMERIC-ARG*)
      (MOVE-POINT (INTERVAL-FIRST-BP *INTERVAL*)))
  DIS-BPS)

(DEFCOM COM-GOTO-END "Moves to the end of the buffer.
With a numeric argument (n), where n is from 0 to 10, it moves n//tenths
of the length of the buffer up from the end." (KM PUSH)
  (IF *NUMERIC-ARG-P*
      (MOVE-FRACTIONALLY (- 10. *NUMERIC-ARG*))
      (MOVE-POINT (INTERVAL-LAST-BP *INTERVAL*)))
  DIS-BPS)

(DEFUN MOVE-FRACTIONALLY (TENTHS)
  (COND ((OR (> TENTHS 10.)
	     (< TENTHS 0))
	 (BARF "The argument must be between 0 and 10."))
	(T
	 (MOVE-POINT (FORWARD-LINE (INTERVAL-FIRST-BP *INTERVAL*)
				   (// (* (COUNT-LINES *INTERVAL*) TENTHS) 10.)
				   T)))))

(DEFCOM COM-MARK-BEGINNING "Puts the mark at the beginning of the buffer.
It marks a region delimited by the beginning of the buffer and the
point." (SM)
  (MOVE-MARK (INTERVAL-FIRST-BP *INTERVAL*))
  DIS-BPS)

(DEFCOM COM-MARK-END "Puts the mark at the end of the buffer.
It marks a region delimited by the point and the end of the buffer." (SM)
  (MOVE-MARK (INTERVAL-LAST-BP *INTERVAL*))
  DIS-BPS)

(DEFCOM COM-SWAP-POINT-AND-MARK "Exchanges the point and the mark.
It works even when no region is active.  It highlights the text between
point and mark." (SM)
  (UNLESS (EQ (BP-BUFFER (POINT)) (BP-BUFFER (MARK)))
    (BARF "Point and mark not in same buffer"))
  (UNLESS *NUMERIC-ARG-P*
    (SWAP-POINT-AND-MARK))
  DIS-BPS)

(DEFCOM COM-SET-POP-MARK "Sets or pops the mark.
With no c-U's, it sets the mark at the point and pushes point onto the point pdl.
With one c-U, it pops the point pdl.
With two c-U's, it pops the point pdl and throws it away.
With an argument of zero, it displays the point pdl." (KM)
  (COND ((ZEROP *NUMERIC-ARG*)
	 ;; *POINT-PDL-MAX* is small enough that we can just display the whole history
	 (FORMAT *TYPEOUT-WINDOW* "~&Point pdl:~%")
	 (LOOP FOR (BP) IN (WINDOW-POINT-PDL *WINDOW*) DO
	   (FORMAT *TYPEOUT-WINDOW* "~2@T")
	   (DW:WITH-OUTPUT-AS-PRESENTATION (:OBJECT BP :TYPE 'BP :STREAM *TYPEOUT-WINDOW*)
	     (STRING-OUT (BP-LINE BP) *TYPEOUT-WINDOW* 0 (BP-INDEX BP))
	     (MULTIPLE-VALUE-BIND (X Y) (SEND *TYPEOUT-WINDOW* :READ-CURSORPOS)
	       (STRING-OUT (BP-LINE BP) *TYPEOUT-WINDOW* (BP-INDEX BP))
	       ;; (X,Y) coordinates of bottom center of character cursor would blink on
	       (INCF X (FLOOR (SEND *TYPEOUT-WINDOW* :CHAR-WIDTH) 2))
	       (INCF Y (SEND *TYPEOUT-WINDOW* :LINE-HEIGHT))
	       (TERPRI *TYPEOUT-WINDOW*) (TERPRI *TYPEOUT-WINDOW*)
	       (GRAPHICS:DRAW-STRING #.(CL:MAKE-STRING 1 :INITIAL-ELEMENT
						           #\MOUSE:SHORT-UP-ARROW)
				     X Y :ATTACHMENT-X :CENTER :ATTACHMENT-Y :TOP
				     :STREAM *TYPEOUT-WINDOW*))))
	 DIS-NONE)
	(( *NUMERIC-ARG* 3)
	 (POINT-PDL-PUSH (POINT) *WINDOW* NIL)
	 (MOVE-MARK (POINT))
	 (SETF (WINDOW-MARK-P *WINDOW*) T)
	 DIS-BPS)
	(( *NUMERIC-ARG* 15.)
	 (MULTIPLE-VALUE-BIND (BP PLINE)
	     (POINT-PDL-POP *WINDOW*)
	   (POINT-PDL-MOVE BP PLINE))
	 DIS-BPS)
	(T
	 (POINT-PDL-POP *WINDOW*)
	 DIS-NONE)))

(DEFCOM COM-PUSH-POP-POINT-EXPLICIT "Pushes or pops point onto the point pdl.
With no argument, it pushes point onto the point pdl.
With a numeric argument (n), it exchanges point with the nth position on the
stack." (KM)
  (COND ((NOT *NUMERIC-ARG-P*)
	 (POINT-PDL-PUSH (POINT) *WINDOW* T)
	 DIS-NONE)
	(T
	 (MULTIPLE-VALUE-BIND (BP PLINE)
	      (POINT-PDL-EXCH (POINT) *WINDOW* *NUMERIC-ARG-P* *NUMERIC-ARG*)
	   (POINT-PDL-MOVE BP PLINE))
	 DIS-BPS)))

(DEFCOM COM-MOVE-TO-PREVIOUS-POINT "Exchanges point and top of point pdl.
A numeric argument rotates top arg entries of the point pdl (the default
numeric argument is 2).  An argument of 1 rotates the whole point pdl
and a negative argument rotates the other way." ()
  (ROTATE-POINT-PDL *WINDOW* (IF (MEMQ *NUMERIC-ARG-P* '(:SIGN NIL))
				 (* 2 *NUMERIC-ARG*) *NUMERIC-ARG*)))

(DEFVAR *DEFAULT-PREVIOUS-POINT-ARG* 3)
(DEFCOM COM-MOVE-TO-DEFAULT-PREVIOUS-POINT "Rotates the point pdl.
A numeric argument specifies the number of entries to rotate and sets the new default." ()
  (OR (MEMQ *NUMERIC-ARG-P* '(:SIGN NIL))
      (SETQ *DEFAULT-PREVIOUS-POINT-ARG* *NUMERIC-ARG*))
  (ROTATE-POINT-PDL *WINDOW* (IF (EQ *NUMERIC-ARG-P* ':SIGN)
				 (* *NUMERIC-ARG* *DEFAULT-PREVIOUS-POINT-ARG*)
				 *DEFAULT-PREVIOUS-POINT-ARG*)))

(DEFCOM COM-INSERT-CRS "Inserts a newline into the buffer at point.
With a numeric argument (n), it inserts n newlines." ()
  (LET ((POINT (POINT)))
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK POINT))
      (LET ((NEXT-LINE (LINE-NEXT-IN-BUFFER (BP-LINE POINT))))
	(COND ((AND (= (BP-INDEX POINT) (LINE-LENGTH (BP-LINE POINT)))
		    (NOT (LINE-DIAGRAM (BP-LINE POINT)))	;diagram lines look blank
		    (NOT *NUMERIC-ARG-P*)
		    (NEQ (BP-LINE POINT) (BP-LINE (INTERVAL-LAST-BP *INTERVAL*)))
		    (LINE-BLANK-P NEXT-LINE)
		    (OR (EQ NEXT-LINE (BP-LINE (INTERVAL-LAST-BP *INTERVAL*)))
			(LINE-BLANK-P (LINE-NEXT-IN-BUFFER NEXT-LINE))))
	       (DELETE-INTERVAL (BEG-OF-LINE NEXT-LINE) (END-OF-LINE NEXT-LINE))
	       (MOVE-POINT (BEG-OF-LINE NEXT-LINE)))
	      (T
	       (SETQ *CURRENT-COMMAND-TYPE* 'INSERT-CR)
	       (DOTIMES (IGNORE *NUMERIC-ARG*)
		 (INSERT-MOVING POINT #\CR)))))))
  DIS-TEXT)

(DEFCOM COM-MAKE-ROOM "Inserts a blank line after point.
With a numeric argument (n), it inserts n blank lines." ()
  (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
    (INSERT-CHARS (POINT) #\CR *NUMERIC-ARG*))
  DIS-TEXT)

(DEFCOM COM-SPLIT-LINE "Moves rest of current line down one line.
It inserts a carriage-return and indents new line directly beneath point.
With a numeric argument (n), it moves down n lines." ()
  (LET ((POINT (POINT)))
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK POINT))
      (MOVE-POINT (FORWARD-OVER *BLANKS* POINT))
      (LET ((IND (BP-INDENTATION POINT))
	    (BP (INSERT-CHARS POINT #\CR (MAX *NUMERIC-ARG* 1))))
	(INDENT-LINE BP IND))))
  DIS-TEXT)

(DEFCOM COM-THIS-INDENTATION "Indents a new line to this point.
With argument of 0, it indents current line to point.
With positive argument, it creates a new line indented to point." ()
  (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
    (LET ((BP1 (FORWARD-OVER *BLANKS* (IF (OR (NOT *NUMERIC-ARG-P*) (ZEROP *NUMERIC-ARG*))
					  (POINT)
					(BEG-LINE (POINT)))))
	  (BP2 (IF (ZEROP *NUMERIC-ARG*)
		   (POINT)
		 (INSERT-MOVING (END-LINE (POINT)) #\CR))))
      (MOVE-POINT (INDENT-LINE BP2 (BP-INDENTATION BP1)))))
  DIS-TEXT)

(DEFCOM COM-DELETE-INDENTATION "Deletes CRLF and any indentation at front of line.
It leaves a space in place of them where appropriate (e.g., beginning of sentence).
Any numeric argument moves down a line first (killing the end of the current line)." ()
  (LET* ((POINT (POINT))
	 (LINE (BP-LINE POINT)))
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK POINT))
      (COND ((AND *NUMERIC-ARG-P*
		  (NEQ LINE (BP-LINE (INTERVAL-LAST-BP (LINE-TOP-LEVEL-NODE LINE)))))
	     (SETQ LINE (LINE-NEXT-IN-BUFFER LINE))))
      (MOVE-POINT LINE 0)
      (COND ((NOT (EQ LINE (BP-LINE (INTERVAL-FIRST-BP *INTERVAL*))))
	     (DELETE-INTERVAL (END-OF-LINE (LINE-PREVIOUS-IN-BUFFER LINE)) POINT)))
      (DELETE-AROUND *BLANKS* POINT)
      (WHEN (OR (SEND (SEND *INTERVAL* :MAJOR-MODE) ':NON-LISP-SYNTAX POINT)
		(LET ((SYNTAX-BEFORE (LIST-SYNTAX (BP-CHAR-BEFORE POINT))))
		  (NOT (OR (= (LIST-SYNTAX (BP-CHAR POINT)) LIST-CLOSE)
			   (= SYNTAX-BEFORE LIST-OPEN)
			   (= SYNTAX-BEFORE LIST-SINGLE-QUOTE)))))
	(INSERT-MOVING POINT (IN-CURRENT-STYLE #\SP))
	(MOVE-POINT POINT))))
  DIS-TEXT)

(DEFCOM COM-DELETE-FORWARD "Deletes one character forward.
With a numeric argument (n), kills n characters forward, placing
them in the kill history." ()
  (LET* ((POINT (POINT))
	 (BP (FORWARD-CHAR POINT *NUMERIC-ARG*)))
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK POINT))
      (COND ((NULL BP) (BARF))
	    ((EQ (BP-LINE POINT) (BP-LINE BP))
	     ;;--- Changed to not copy (BP-LINE POINT) before munging the line,
	     ;;--- for copy-on-write
	     (MUNG-LINE (BP-LINE BP))		;there must be a more modular way!
	     (MUST-REDISPLAY *WINDOW*
			     DIS-LINE
			     (BP-LINE BP)
			     (MIN (BP-INDEX BP) (BP-INDEX POINT))))
	    (T (MUST-REDISPLAY *WINDOW* DIS-TEXT)))
      ;;Diagram always goes on the kill ring.
      (COND ((OR *NUMERIC-ARG-P* (LINE-DIAGRAM (BP-LINE POINT)))
	     (SETQ *CURRENT-COMMAND-TYPE* 'KILL)
	     (KILL-INTERVAL BP POINT))
	    (T
	     (DELETE-INTERVAL BP POINT)))))
  DIS-NONE)

(DEFCOM COM-RUBOUT "Deletes one character backward.
With a numeric argument (n), kills n characters backward, placing
them in the kill history." ()
  (LET* ((POINT (POINT))
	 (BP (FORWARD-CHAR POINT (- *NUMERIC-ARG*) T)))
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK POINT))
      (COND ((EQ (BP-LINE POINT) (BP-LINE BP))
	     ;;--- Changed to not copy (BP-LINE POINT) before munging the line,
	     ;;--- for copy-on-write
	     (MUNG-LINE (BP-LINE BP))		;there must be a more modular way!
	     (MUST-REDISPLAY *WINDOW*
			     DIS-LINE
			     (BP-LINE BP)
			     (MIN (BP-INDEX BP) (BP-INDEX POINT))))
	    (T (MUST-REDISPLAY *WINDOW* DIS-TEXT)))
      ;;Diagram always goes on kill ring.
      (COND ((OR *NUMERIC-ARG-P*
		 ;; When point is at the beginning of a line,
		 ;; you want to save the other line if it's a diagram.
		 (LINE-DIAGRAM (BP-LINE BP)))
	     (SETQ *CURRENT-COMMAND-TYPE* 'KILL)
	     (KILL-INTERVAL BP POINT))
	    (T
	     (DELETE-INTERVAL BP POINT)))))
  DIS-NONE)

(DEFCOM COM-KILL-LINE "Kills forward to end of line or kills an end of line.
Before a CRLF it deletes the blank line, otherwise it clears the line.
With a numeric argument (n), it kills n lines." ()
  (LET ((POINT (POINT)))
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK POINT))
      (COND ((AND (BP-= POINT (INTERVAL-LAST-BP *INTERVAL*)) (PLUSP *NUMERIC-ARG*))
	     (BARF "Attempt to kill past the end of the buffer."))
	    (T
	     (SETQ *CURRENT-COMMAND-TYPE* 'KILL)
	     (COND (*NUMERIC-ARG-P*
		    (KILL-INTERVAL-ARG POINT
				       (BEG-LINE POINT *NUMERIC-ARG* T)
				       *NUMERIC-ARG*)
		    DIS-TEXT)
		   ((END-LINE-P (FORWARD-OVER *BLANKS* POINT))
		    (KILL-INTERVAL POINT (BEG-LINE POINT 1 T) T T)
		    DIS-TEXT)
		   (T
		    (KILL-INTERVAL POINT (END-LINE POINT) T T)
		    (VALUES DIS-LINE (BP-LINE POINT) (BP-INDEX POINT)))))))))

(DEFCOM COM-CLEAR "Kills backward to the start of the current line.
If point is already at the beginning of the line, it kills the previous line.
With a numeric argument (n), it kills between point and the nth start of
line above the current point." ()
  (SETQ *CURRENT-COMMAND-TYPE* 'KILL)
  (LET ((POINT (POINT)))
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK POINT))
      (LET ((BP (BEG-LINE POINT
			  (IF (BEG-LINE-P POINT)
			      (IF *NUMERIC-ARG-P*
				  (- *NUMERIC-ARG*)
				-1)
			    (IF *NUMERIC-ARG-P*
				(- (SUB1 *NUMERIC-ARG*))
			      0))
			  T)))
	(KILL-INTERVAL BP POINT NIL NIL))))
  DIS-TEXT)

;; You could bind this to super-W if you wanted to...
(DEFCOM COM-SAVE-REGION 
	"Puts region on kill-ring without deleting it.
In more detail, this first attempts to push any text marked in the typeout window
onto the kill-ring, if the typeout window is exposed.  Failing that, it attempts
to push a marked region in the buffer onto the kill-ring." ()
  (LET ((BUFFER-MARKED (WINDOW-REGION-P *WINDOW*))
	(TYPEOUT-MARKED (SEND-IF-HANDLES *TYPEOUT-WINDOW* :MARKED-TEXT))
	(TYPEOUT-EXPOSED (SEND *TYPEOUT-WINDOW* :EXPOSED-P)))
    (COND ((AND TYPEOUT-EXPOSED TYPEOUT-MARKED)
	   (DW::KILL-RING-PUSH-MARKED-TEXT *TYPEOUT-WINDOW*))
	  (BUFFER-MARKED
	   (WITH-REGION-BPS (BP1 BP2 :EMPTY-OK T)
	     (WITH-INTERVAL-READ-LOCKED (BP1 BP2 T)
	       (KILL-RING-SAVE-INTERVAL BP1 BP2 T))))
	  (TYPEOUT-MARKED
	   (DW::KILL-RING-PUSH-MARKED-TEXT *TYPEOUT-WINDOW*))
	  (T
	   (BARF "There is no text marked in the buffer or typeout window"))))
  DIS-NONE)

(DEFCOM COM-KILL-REGION "Kills from point to mark.
It places killed text on the kill-ring for retrieval." ()
  (AND (EQ *LAST-COMMAND-TYPE* 'YANK)		;By special case.
       (SETF (WINDOW-MARK-P *WINDOW*) T))
  (REGION (BP1 BP2 :EMPTY-OK T :ENFORCE-SINGLE-SECTION T)
    (WITH-INTERVAL-WRITE-LOCKED (BP1 BP2 T)
      (KILL-INTERVAL BP1 BP2 T T T)))
  (SETQ *CURRENT-COMMAND-TYPE* 'KILL)
  (CLEAN-POINT-PDL *WINDOW*)
  (LET ((BP (LOOP FOR (BP) IN (WINDOW-POINT-PDL *WINDOW*)
		  WHEN (EQL (BP-BUFFER BP) *INTERVAL*)
		    DO (RETURN BP))))
    (WHEN BP (MOVE-MARK BP)))
  DIS-TEXT)

(DEFCOM COM-APPEND-NEXT-KILL "Makes next kill command append text to previous one." (KM)
  (UNLESS (EQ *KILL-HISTORY-USER* *CURRENT-COMMAND-LOOP*)
    (TYPEIN-LINE "Will append to text saved by ~A" *KILL-HISTORY-USER*)
    (SETQ *KILL-HISTORY-USER* *CURRENT-COMMAND-LOOP*))
  (SETQ *CURRENT-COMMAND-TYPE* 'KILL)
  DIS-NONE)

;(TV:ADD-TYPEOUT-ITEM-TYPE *ZWEI-TYPEOUT-COMMAND-ALIST* YANK "Yank" YANK-FROM-MOUSE T
;			  "Yank this text.")

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR YANK-FROM-MOUSE
						  (SI:HISTORY-AND-ELEMENT "Yank this text"
									  *STANDARD-COMTAB*)
						  (HISTORY-AND-ELEMENT)
  `(YANK-FROM-MOUSE ,HISTORY-AND-ELEMENT))

(DEFCOM COM-YANK "Insert the last piece of text that was killed or saved.
Point ends up after the text, and mark before the text.
c-U puts point before the text instead.
A numeric argument of 0 displays the kill history.
A non-zero numeric argument selects an element of the kill history." ()
  
  (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
    (YANK-COMMAND *KILL-HISTORY*)))

(DEFUN YANK-COMMAND (HISTORY)
  (COND ((ZEROP *NUMERIC-ARG*)
	 (DISPLAY-HISTORY-MENU *TYPEOUT-WINDOW* HISTORY *HISTORY-MENU-LENGTH* NIL)
	 DIS-NONE)
	(T
	 (LET ((POINT-BEFORE (EQ *NUMERIC-ARG-P* ':CONTROL-U)))
	   (YANK-TEXT (OR (SEND HISTORY ':YANK (AND *NUMERIC-ARG-P* (NOT POINT-BEFORE)
						    *NUMERIC-ARG*))
			  (BARF "No more history"))
		      POINT-BEFORE))
	 (SETQ *CURRENT-COMMAND-TYPE* 'YANK)
	 (SETQ *CURRENT-YANK-HISTORY* HISTORY)
	 DIS-TEXT)))

(DEFUN YANK-FROM-MOUSE (THING)
  (WHEN (LISTP THING)				;Extract text from kill-history display
    (SETQ *CURRENT-COMMAND-TYPE* 'YANK)
    (SETQ *CURRENT-YANK-HISTORY* (CAR THING))
    (SEND (CAR THING) :NOTE-ELEMENT-YANKED (CDR THING))
    (SETQ THING (CDR THING)))
  (YANK-TEXT THING NIL)				;Yank text, make it a non-underlined region
  ;; Cause a redisplay of the yanked text
  (SEND *TYPEOUT-WINDOW* :MAKE-COMPLETE)
  (MUST-REDISPLAY *WINDOW* DIS-TEXT)
  NIL)

(DEFCOM COM-YANK-MATCHING "Insert text that was killed or saved and contains a substring.
Point ends up after the text, and mark before the text.
c-U puts point before the text instead.
A numeric argument of 0 displays the kill history.
A non-zero numeric argument takes the nth most recent matching piece of text." ()
  (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
    (YANK-MATCHING-COMMAND *KILL-HISTORY*)))

(DEFUN YANK-MATCHING-COMMAND (HISTORY)
  (COND ((ZEROP *NUMERIC-ARG*)
	 (DISPLAY-HISTORY-MENU *TYPEOUT-WINDOW* HISTORY *HISTORY-MENU-LENGTH* NIL 'YANK
			       (QUERY-READ-STRING "List elements of ~A history that match: "
						  HISTORY))
	 DIS-NONE)
	(T
	 (LET ((POINT-BEFORE (EQ *NUMERIC-ARG-P* ':CONTROL-U))
	       (MATCH (QUERY-READ-STRING "Yank text from ~A history that matches: " HISTORY)))
	   (SETQ *CURRENT-COMMAND-TYPE* 'YANK)
	   (SETQ *CURRENT-YANK-HISTORY* (CONS HISTORY MATCH))
	   (YANK-TEXT (OR (SEND HISTORY ':YANK-MATCHING MATCH (AND *NUMERIC-ARG-P*
								   (NOT POINT-BEFORE)
								   *NUMERIC-ARG*))
			  (BARF "No matching history element found"))
		      POINT-BEFORE))
	 DIS-TEXT)))

;A kludge to avoid recursive minibuffers
(DEFUN QUERY-READ-STRING (FORMAT-STRING &REST FORMAT-ARGS)
  (IF (NOT *MINI-BUFFER-COMMAND-IN-PROGRESS*)
      (LEXPR-FUNCALL #'TYPEIN-LINE-READLINE FORMAT-STRING FORMAT-ARGS)
      (PROG1
	(LET ((SYS:RUBOUT-HANDLER NIL)
	      (SYS:*INPUT-EDITOR-OPTIONS* NIL))
	  (WITH-INPUT-EDITING-OPTIONS ((:PROMPT (LEXPR-FUNCALL #'FORMAT NIL FORMAT-STRING
									    FORMAT-ARGS)))
	    (READLINE *TYPEIN-WINDOW*)))
	(SEND *TYPEIN-WINDOW* :MAKE-COMPLETE))))

;;; Substitute for generic function.
(DEFSUBST YANK-TEXT-INTERVAL (INTERVAL THING POINT-BEFORE)
  (SEND INTERVAL :YANK-TEXT THING POINT-BEFORE))

(DEFUN YANK-TEXT (THING POINT-BEFORE)
  (YANK-TEXT-INTERVAL *INTERVAL* THING POINT-BEFORE))

(DEFMETHOD (:YANK-TEXT NODE :DEFAULT) (THING POINT-BEFORE)
  (WHEN (NULL THING) (BARF "No history"))
  (LET ((POINT (POINT))
	(YANK-IS-SEPARATELY-UNDOABLE *YANK-IS-SEPARATELY-UNDOABLE*))
    (LET ((BP (IF (OR (NULL YANK-IS-SEPARATELY-UNDOABLE)
		      (AND (EQ YANK-IS-SEPARATELY-UNDOABLE :MULTI-LINE)
			   (CL:TYPECASE THING
			     ((OR STRING SYMBOL) (NOT (STRING-SEARCH-CHAR #\RETURN THING)))
			     (CHARACTER (NOT (EQL THING #\RETURN)))
			     (OTHERWISE (EQ (BP-LINE (INTERVAL-FIRST-BP THING))
					    (BP-LINE (INTERVAL-LAST-BP THING)))))))
		  (INSERT-KILL-RING-THING POINT THING)
		  (WITH-UNDO-SAVE-SIMPLE (POINT POINT T)
		    (INSERT-KILL-RING-THING POINT THING)))))
      (COND (POINT-BEFORE
	     (POINT-PDL-PUSH BP *WINDOW* NIL NIL)
	     (MOVE-MARK BP))
	    (T
	     (POINT-PDL-PUSH POINT *WINDOW* NIL NIL)
	     (MOVE-MARK POINT)
	     (MOVE-POINT BP))))))

(DEFCOM COM-YANK-POP "Corrects a yank to use a different element of its history.
The most recent command must be a yanking command.  The text that was yanked
by that command, i.e. the text between point and mark, is replaced by the
previous element of the relevant history.  The history is rotated to bring
this element to the top.
A numeric argument of zero displays the history.
A positive numeric argument moves to that much older a history element.
A negative numeric argument moves to a newer history element; this
only makes sense after the history has been rotated." ()
  ;; Need not check for MARK-P, by special case.
  (UNLESS (EQ *LAST-COMMAND-TYPE* 'YANK) (BARF))
  (SETQ *CURRENT-COMMAND-TYPE* 'YANK)
  (WHEN (LISTP *CURRENT-YANK-HISTORY*)
    (SETQ *CURRENT-YANK-HISTORY* (CAR *CURRENT-YANK-HISTORY*)))
  (COND ((ZEROP *NUMERIC-ARG*)
	 (DISPLAY-HISTORY-MENU *TYPEOUT-WINDOW* *CURRENT-YANK-HISTORY*
			       *HISTORY-MENU-LENGTH* T)
	 DIS-NONE)
	(T (LET ((THING (SEND *CURRENT-YANK-HISTORY* ':YANK-NEXT *NUMERIC-ARG*))
		 (SWAP-P (BP-< (POINT) (MARK))))
	     (WHEN (NULL THING) (BARF))
	     (WITH-INTERVAL-WRITE-LOCKED ((POINT) (MARK))
	       (LET ((*FORCIBLY-MERGE-CHANGE-RECORD* T))
		 (DELETE-INTERVAL (POINT) (MARK))
		 (MOVE-POINT (INSERT-KILL-RING-THING (POINT) THING))
		 (WHEN SWAP-P (SWAP-POINT-AND-MARK))))
	     DIS-TEXT))))

(DEFCOM COM-YANK-POP-MATCHING "Corrects a yank to use a different element of its history.
The most recent command must be a yanking command.  The text that was yanked
by that command, i.e. the text between point and mark, is replaced by a
previous element of the relevant history that contains a substring.
If the previous command read a substring, the same substring is used.
The history is rotated to bring this element to the top.
A numeric argument of zero displays the history.
A positive numeric argument moves to that much older a history element.
A negative numeric argument moves to a newer history element; this
only makes sense after the history has been rotated." ()
  ;; Need not check for MARK-P, by special case.
  (UNLESS (EQ *LAST-COMMAND-TYPE* 'YANK) (BARF))
  (SETQ *CURRENT-COMMAND-TYPE* 'YANK)
  (MULTIPLE-VALUE-BIND (HISTORY MATCH)
      (IF (ATOM *CURRENT-YANK-HISTORY*)
	  (VALUES *CURRENT-YANK-HISTORY*
		  (QUERY-READ-STRING (IF (ZEROP *NUMERIC-ARG*)
					 "List elements of ~A history that match: "
					 "Yank different text from ~A history that matches: ")
				     *CURRENT-YANK-HISTORY*))
	  (VALUES (CAR *CURRENT-YANK-HISTORY*)
		  (CDR *CURRENT-YANK-HISTORY*)))
    (SETQ *CURRENT-YANK-HISTORY* (CONS HISTORY MATCH))
    (COND ((ZEROP *NUMERIC-ARG*)
	   (DISPLAY-HISTORY-MENU *TYPEOUT-WINDOW* HISTORY *HISTORY-MENU-LENGTH* T 'YANK MATCH)
	   DIS-NONE)
	  (T (LET ((THING (SEND HISTORY ':YANK-NEXT *NUMERIC-ARG* MATCH))
		   (SWAP-P (BP-< (POINT) (MARK))))
	       (WHEN (NULL THING) (BARF))
	       (WITH-INTERVAL-WRITE-LOCKED ((POINT) (MARK))
		 (DELETE-INTERVAL (POINT) (MARK))
		 (MOVE-POINT (INSERT-KILL-RING-THING (POINT) THING))
		 (WHEN SWAP-P (SWAP-BPS (POINT) (MARK))))
	       DIS-TEXT)))))

(DEFCOM COM-YANK-IN-CONTEXT DOCUMENT-YANK-IN-CONTEXT ()
  (YANK-COMMAND *CONTEXT-HISTORY*))

(DEFUN DOCUMENT-YANK-IN-CONTEXT (IGNORE IGNORE OP)
  (COND ((EQ OP ':NAME) "Yank in Context")
	(T
	 (PRINC "Insert the last piece of text typed in this context.")
	 (WHEN (EQ OP ':FULL)
	   (FORMAT T "~%Point ends up after the text, and mark before the text.~@
			c-U puts point before the text instead.~@
			A numeric argument of 0 displays the ~A history.~@
			A non-zero numeric argument selects an element of the ~:*~A history."
		   (STRING-DOWNCASE (SEND *CONTEXT-HISTORY* ':NAME)))))))

(DEFCOM COM-YANK-MATCHING-IN-CONTEXT DOCUMENT-YANK-MATCHING-IN-CONTEXT ()
  (YANK-MATCHING-COMMAND *CONTEXT-HISTORY*))

(DEFUN DOCUMENT-YANK-MATCHING-IN-CONTEXT (IGNORE IGNORE OP)
  (COND ((EQ OP ':NAME) "Yank Matching in Context")
	(T
	 (PRINC "Insert text typed in this context that contains a substring.")
	 (WHEN (EQ OP ':FULL)
	   (FORMAT T "~%Point ends up after the text, and mark before the text.~@
			c-U puts point before the text instead.~@
			A numeric argument of 0 displays the ~A history.~@
			A non-zero numeric argument takes the nth most recent matching text."
		   (STRING-DOWNCASE (SEND *CONTEXT-HISTORY* ':NAME)))))))

;;; If there was no arg at all, *NUMERIC-ARG-P* is NIL and *NUMERIC-ARG* is 1.
;;; If user just typed -, then *NUMERIC-ARG-P* is :SIGN and *NUMERIC-ARG* is -1.
;;; If numeric arg commands were typed, *NUMERIC-ARG-P* is :DIGITS and
;;; *NUMERIC-ARG* is the number.
;;; Note that - does not toggle negativeness, it turns it on.

(DEFCOM COM-QUADRUPLE-NUMERIC-ARG "Multiplies the next command's numeric argument by 4." ()
  (SETQ *NUMERIC-ARG* (* *NUMERIC-ARG* 4)
	*NUMERIC-ARG-P* ':CONTROL-U)
  ':ARGUMENT)

(DEFCOM COM-NUMBERS "part of the next command's numeric argument." ()
  (LET ((FLAG NIL)
	(DIGIT (DIGIT-CHAR-P *LAST-COMMAND-CHAR*)))
    (COND ((< *NUMERIC-ARG* 0)
	   (SETQ FLAG T)
	   (SETQ *NUMERIC-ARG* (MINUS *NUMERIC-ARG*))))
    (SETQ *NUMERIC-ARG*
	  (IF (EQ *NUMERIC-ARG-P* ':DIGITS)
	      (+ (* 10. *NUMERIC-ARG*) DIGIT)
	      DIGIT))
    (AND FLAG (SETQ *NUMERIC-ARG* (MINUS *NUMERIC-ARG*))))
  (SETQ *NUMERIC-ARG-P* ':DIGITS)
  ':ARGUMENT)

(DEFCOM COM-NEGATE-NUMERIC-ARG "Negates the next command's numeric argument." ()
  (SETQ *NUMERIC-ARG* (MINUS (ABS *NUMERIC-ARG*))
	*NUMERIC-ARG-P* ':SIGN)
  ':ARGUMENT)

(DEFCOM COM-SIMPLE-EXCHANGE-CHARACTERS
	"Interchanges the characters before and after the cursor.
With a positive argument (n), it interchanges the characters before and
after the cursor, moves right, and repeats n times, dragging the character
to the left of the cursor right.  With a negative argument, it interchanges
the two characters to the left of the cursor, moves between them, and repeats
n times, exactly undoing the positive argument form.  With a zero
argument, it interchanges the characters at point and mark." ()
  (EXCHANGE-SUBR 'FORWARD-CHAR *NUMERIC-ARG*)
  DIS-TEXT)

(DEFCOM COM-EXCHANGE-CHARACTERS "Interchanges the characters before and after the cursor.
With a positive argument (n), it interchanges the characters before and
after the cursor, moves right, and repeats n times, dragging the character
to the left of the cursor right.  With a negative argument, it interchanges
the two characters to the left of the cursor, moves between them, and repeats
n times, exactly undoing the positive argument form.  With a zero
argument, it interchanges the characters at point and mark.
No argument is like an argument of 1, except at the end of a line
the previous two characters are interchanged." ()
  (COND ((AND (NOT *NUMERIC-ARG-P*)
	      (NOT (LINE-DIAGRAM (BP-LINE (POINT))))	;diagram lines look like #\CRs
	      (CHAR= (BP-CHAR (POINT)) #\CR))
	 (MOVE-POINT (OR (FORWARD-CHAR (POINT) -1) (BARF)))))
  (EXCHANGE-SUBR 'FORWARD-CHAR *NUMERIC-ARG*)
  DIS-TEXT)

(DEFCOM COM-EXCHANGE-WORDS "Interchanges the words before and after the cursor.
With a positive argument (n), it interchanges the words before and
after the cursor, moves right, and repeats n times, dragging the word
to the left of the cursor right.  With a negative argument, it interchanges
the two words to the left of the cursor, moves between them, and repeats
n times, exactly undoing the positive argument form.  With a zero argument,
it interchanges the words at point and mark." ()
  (EXCHANGE-SUBR 'FORWARD-WORD *NUMERIC-ARG*)
  DIS-TEXT)

(DEFCOM COM-EXCHANGE-LINES "Interchanges the lines before and after the cursor.
With a positive argument (n), it interchanges the lines before and
after the cursor, moves right, and repeats n times, dragging the line to the
left of the cursor right.  With a negative argument, it interchanges the two
lines to the left of the cursor, moves between them, and repeats n times,
exactly undoing the positive argument form.  With a zero argument, it interchanges
the lines at point and mark." ()
  (EXCHANGE-SUBR 'FORWARD-LINE *NUMERIC-ARG*)
  DIS-TEXT)

(DEFCOM COM-EXCHANGE-SEXPS
	"Interchanges the Lisp expressions before and after point.
It accepts a numeric argument, which has the following effect.
Argument      Effect on A B <cursor> C D
 1 (or none)     A C B <cursor> D
 -1              B <cursor> A C D

With a positive argument, it interchanges the Lisp expressions before and after
the cursor, moves right, and repeats until it has finished the specified
number of times.  This pulls the Lisp expression to the left of the cursor right.

With a negative argument, it first moves over the Lisp expression to the left of
the cursor and then interchanges the two Lisp expressions now surrounding the
cursor.  It repeats this until it has finished the specified number of times.

Due to this definition, the behavior with a negative argument is exactly the
inverse of the result with a positive argument.

With a zero argument, it interchanges the first Lisp expression in the
region with the Lisp expression after the region.  " ()
  (EXCHANGE-SUBR 'FORWARD-SEXP *NUMERIC-ARG*)   DIS-TEXT)

(DEFUN EXCHANGE-SUBR (FN N)
  ;; Treat this as a simple change if it's c-T or c-- c-T
  (LET ((SAVE (NOT (AND (EQ FN 'FORWARD-CHAR) (= (ABS N) 1)))))
    (COND ((PLUSP N)
	   ;; Exchange the expression to the left of point (not counting any expression
	   ;; point's inside of) with n expressions to the right of point
	   (WITH-BP (BP1 (OR (FUNCALL FN (OR (FUNCALL FN (POINT) 1) (BARF)) -2) (BARF))
			 :NORMAL)
	     (WITH-BP (BP2 (OR (FUNCALL FN BP1 1) (BARF)) :MOVES)
	       (WITH-BP (BP3 (OR (FUNCALL FN (OR (FUNCALL FN BP2 1) (BARF)) -1) (BARF))
			     :NORMAL)
		 (WITH-BP (BP4 (OR (FUNCALL FN BP3 N) (BARF)) :MOVES)
		   (EXCHANGE-INTERVALS BP1 BP2 BP3 BP4 SAVE)
		   (MOVE-POINT BP4))))))
	  ((MINUSP N)
	   ;; Exchange the expression that point is to the right of or inside of
	   ;; with -n expressions to the left of point
	   (WITH-BP (BP3 (OR (FUNCALL FN (POINT) -1) (BARF)) :NORMAL)
	     (WITH-BP (BP4 (OR (FUNCALL FN BP3 1) (BARF)) :MOVES)
	       (WITH-BP (BP1 (OR (FUNCALL FN BP3 N) (BARF)) :NORMAL)
		 (WITH-BP (BP2 (OR (FUNCALL FN BP1 (- N)) (BARF)) :MOVES)
		   (EXCHANGE-INTERVALS BP1 BP2 BP3 BP4 SAVE)
		   (MOVE-POINT BP2))))))
	  (T
	   (REGION (BP1 BP3 :EMPTY-OK T :ENFORCE-SINGLE-SECTION T)
	     (WITH-BP (BP1 (OR (FUNCALL FN BP1 1) (BARF)) ':NORMAL)
	       (OR (SETQ BP1 (FUNCALL FN BP1 -1)) (BARF))
	       (WITH-BP (BP4 (OR (FUNCALL FN BP3 1) (BARF)) ':NORMAL)
		 (WITH-BP (BP3 (OR (FUNCALL FN BP4 -1) (BARF)) ':NORMAL)
		   (WITH-BP (BP2 (OR (FUNCALL FN BP1 1) (BARF)) ':NORMAL)
		     (EXCHANGE-INTERVALS BP1 BP2 BP3 BP4 SAVE)
		     (MOVE-POINT BP4)
		     (MOVE-MARK BP2)
		     (SETQ *MARK-STAYS* T))))))))))

;This function ought to share code with the EXCHANGE-SUBR functions above, but can't.
(DEFCOM COM-EXCHANGE-REGIONS "Exchanges region delimited by point and last three marks." (KM)
  (OR (WINDOW-MARK-P *WINDOW*) (BARF "There is no region"))	;Avoid accidental lossage
  (LET ((POINT (POINT)) (MARK (MARK))
	BP1 BP2 BP3 BP4)
    (OR (BP-= MARK (CAAR (WINDOW-POINT-PDL *WINDOW*)))
	(BARF "Mark not at the same place as top of point pdl"))
    (SETQ BP1 POINT
	  BP2 (POINT-PDL-POP *WINDOW*)
	  BP3 (POINT-PDL-POP *WINDOW*)
	  BP4 (POINT-PDL-POP *WINDOW*))
    (LET ((LIST (LIST BP1 BP2 BP3 BP4)))
      (SETQ LIST (SORT LIST #'(LAMBDA (BP1 BP2)
				(AND (EQ (BP-TOP-LEVEL-NODE BP1) (BP-TOP-LEVEL-NODE BP2))
				     (BP-< BP1 BP2)))))
      (SETQ BP1 (FIRST LIST)
	    BP2 (SECOND LIST)
	    BP3 (THIRD LIST)
	    BP4 (FOURTH LIST)))
    (OR (AND (EQ (BP-TOP-LEVEL-NODE BP1) (BP-TOP-LEVEL-NODE BP2))
	     (EQ (BP-TOP-LEVEL-NODE BP3) (BP-TOP-LEVEL-NODE BP4)))
	(BARF "Regions are not both within single buffers"))
    ;; Copy the argument bp's
    (WITH-BP (BP1 BP1 :NORMAL)
      (WITH-BP (BP2 BP2 :MOVES)
	(WITH-BP (BP3 BP3 :NORMAL)
	  (WITH-BP (BP4 BP4 :MOVES)
	    (EXCHANGE-INTERVALS BP1 BP2 BP3 BP4 T)
	    (POINT-PDL-PUSH BP1 *WINDOW*)
	    (POINT-PDL-PUSH BP2 *WINDOW*)
	    (POINT-PDL-PUSH BP3 *WINDOW*)
	    (MOVE-MARK BP3)
	    (MOVE-POINT BP4)
	    DIS-TEXT))))))
;;; Exchange the text between BP1,BP2 with the text between BP3,BP4
;;; BP's must have been sorted already
;;; If SAVE is true, save a change-record
;;; Moves the argument BP's so they still surround the intervals
(DEFUN EXCHANGE-INTERVALS (BP1 BP2 BP3 BP4 SAVE)
  (WITH-INTERVAL-WRITE-LOCKED (BP1 BP4 T)
    ;; Check for overlap, because it can produce devastating results.
    (WHEN (BP-< BP3 BP2)
      (BARF "Expressions to be exchanged overlap in text /"~A/"" (STRING-INTERVAL BP3 BP2 T)))
    ;; Check the rest of the sorting too, probably only for temporary detection of coding bugs
    ;; Intervals must be non-empty for the various BP motions to come out right
    (UNLESS (AND (BP-< BP1 BP2) (BP-< BP3 BP4))
      (BARF (IF (OR (BP-= BP1 BP2) (BP-= BP3 BP4))
		"Intervals to be exchanged must be non-empty"
		"INTERNAL ZWEI ERROR: BP's not sorted in EXCHANGE-INTERVALS")))
    (LET ((TOUCH (BP-= BP2 BP3)))		;Special hair when the two intervals touch
      (WITH-CUSTOM-UNDO-SAVE (BP1 BP4
			      (LET ((BP1 (COPY-BP BP1 :NORMAL))
				    (BP2 (COPY-BP BP2 :MOVES))
				    (BP3 (IF TOUCH BP2 (COPY-BP BP3 :NORMAL)))
				    (BP4 (COPY-BP BP4 :MOVES)))
				(MAKE-EXCHANGE-RECORD BP1 BP2 BP3 BP4
						      (FINALIZE-BP-POSITIONS BP-POSITIONS)))
			      :TEST SAVE)
	 (WITH-BP (BP2A BP2 :NORMAL)
	   (WITH-BP (BP3 BP3 :NORMAL)
	     (WITH-BP (BP4A BP4 :NORMAL)
	       (UNLESS SAVE
		 (PREPARE-TO-CHANGE BP1 BP4))
	       (WHEN TOUCH
		 ;; Make sure there is space between BP2 and BP3
		 (INSERT-MOVING BP3 #\SPACE)
		 (WHEN (BP-= BP2 BP3)
		   (DBP BP2)))
	       (INSERT-INTERVAL-MOVING BP2 BP3 BP4 T)
	       (INSERT-INTERVAL-MOVING BP4 BP1 BP2A T)
	       (WHEN TOUCH
		 (DBP BP3))	;to delete the space
	       (DELETE-INTERVAL BP3 BP4A T)
	       (DELETE-INTERVAL BP1 BP2A T))))))))

(DEFUN REVERSE-SUBR (FN N &OPTIONAL (BP (POINT)) BP-LIST)
  (AND (MINUSP N)
       (SETQ BP (FUNCALL FN BP N)
	     N (- N)))
  (UNWIND-PROTECT
      (DO ((I 0 (1+ I))
	   (START-BP BP END-BP)
	   (END-BP))
	  (( I N)
	   (WITH-INTERVAL-WRITE-LOCKED (BP END-BP T)
	     (WITH-UNDO-SAVE ("reverse" BP END-BP T)
	       (DO ((I 0 (1+ I))
		    (N (// N 2))
		    (LIST-FROM-THE-RIGHT BP-LIST (CDR LIST-FROM-THE-RIGHT))
		    (LIST-FROM-THE-LEFT (REVERSE BP-LIST) (CDR LIST-FROM-THE-LEFT))
		    (RIGHT-START-BP) (RIGHT-END-BP)
		    (LEFT-START-BP) (LEFT-END-BP))
		   (( I N))
		 (SETQ LEFT-START-BP (CAAR LIST-FROM-THE-LEFT)
		       LEFT-END-BP (CADAR LIST-FROM-THE-LEFT))
		 (SETQ RIGHT-START-BP (CAAR LIST-FROM-THE-RIGHT)
		       RIGHT-END-BP (CADAR LIST-FROM-THE-RIGHT))
		 (INSERT-INTERVAL LEFT-START-BP
				  (PROG1 (COPY-INTERVAL RIGHT-START-BP RIGHT-END-BP T)
					 (DELETE-INTERVAL RIGHT-START-BP RIGHT-END-BP T)))
		 (INSERT-INTERVAL RIGHT-START-BP
				  (PROG1 (COPY-INTERVAL LEFT-START-BP LEFT-END-BP T)
					 (DELETE-INTERVAL LEFT-START-BP LEFT-END-BP T)))))))
	(SETQ END-BP (OR (FUNCALL FN START-BP 1) (BARF))
	      START-BP (OR (FUNCALL FN END-BP -1) (BARF)))
	(WHEN (ZEROP I)
	  (SETQ BP START-BP))
	(PUSH (LIST (COPY-BP START-BP ':MOVES) (COPY-BP END-BP ':NORMAL)) BP-LIST))
    (DO ((BPS BP-LIST (CDR BPS)))
	((NULL BPS))
      (FLUSH-BP (CAAR BPS))
      (FLUSH-BP (CADAR BPS)))))

(DEFCOM COM-REVERSE-LINES "Reverses the order of the specified number of lines." ()
  (REVERSE-SUBR 'FORWARD-LINE *NUMERIC-ARG*)
  DIS-TEXT)

(DEFCOM COM-REVERSE-FOLLOWING-LIST "Reverses the elements of the list after point." ()
  (LET* ((BP (POINT))
	 (COUNT (OR (COUNT-LIST-ELEMENTS BP) (BARF))))
    (REVERSE-SUBR #'FORWARD-SEXP COUNT (FORWARD-LIST BP 1 NIL -1 T)))
  DIS-TEXT)

(DEFUN KILL-COMMAND-INTERNAL (FUNCTION ARG &AUX (POINT (POINT)))
  (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK POINT))
    (LET* ((OTHER-END (OR (FUNCALL FUNCTION POINT ARG) (BARF)))
	   (SAME-LINE-P (EQ (BP-LINE POINT) (BP-LINE OTHER-END))))
      (KILL-INTERVAL-ARG POINT OTHER-END ARG)
      (SETQ *CURRENT-COMMAND-TYPE* 'KILL)
      (MOVE-MARK POINT)
      (COND ((AND SAME-LINE-P
		  (= (BP-INDEX POINT) (LINE-LENGTH (BP-LINE POINT))))
	     (VALUES DIS-LINE (BP-LINE POINT) (BP-INDEX POINT)))
	    (T DIS-TEXT)))))

(DEFCOM COM-FORWARD-WORD "Moves forward one word.
It accepts numeric arguments for repetition count." (KM)
  (MOVE-POINT (OR (FORWARD-WORD (POINT) *NUMERIC-ARG* NIL *INTERVAL*) (BARF)))
  (SET-CENTERING-FRACTION *NUMERIC-ARG*)
  DIS-BPS)

(DEFCOM COM-BACKWARD-WORD "Moves backward one word.
It accepts numeric arguments for repetition count." (KM)
  (MOVE-POINT (OR (FORWARD-WORD (POINT) (- *NUMERIC-ARG*) NIL *INTERVAL*) (BARF)))
  (SET-CENTERING-FRACTION (- *NUMERIC-ARG*))
  DIS-BPS)

(DEFCOM COM-KILL-WORD "Kills forward one word.
It accepts numeric arguments for repetition count." ()
  (KILL-COMMAND-INTERNAL #'FORWARD-WORD *NUMERIC-ARG*))

(DEFCOM COM-BACKWARD-KILL-WORD "Kills backward one word.
It accepts numeric arguments for repetition count." ()
  (KILL-COMMAND-INTERNAL #'FORWARD-WORD (- *NUMERIC-ARG*)))

(DEFCOM COM-MARK-WORD "Sets mark forward one word from point.
With a numeric argument (n), sets mark at nth word 
forward from point." (SM)
  (MOVE-MARK (OR (FORWARD-WORD (POINT) *NUMERIC-ARG*) (BARF)))
  DIS-BPS)

(DEFCOM COM-FORWARD-SEXP "Moves forward over exactly one Lisp expressions.
It positions point after appropriate close parenthesis.
It accepts numeric arguments for repetition count." (KM)
  (MOVE-POINT (OR (FORWARD-SEXP (POINT) *NUMERIC-ARG*) (BARF)))
  (SET-CENTERING-FRACTION *NUMERIC-ARG*)
  DIS-BPS)

(DEFCOM COM-FORWARD-SEXP-NO-UP "Moves forward one Lisp expression.
It never moves over an unbalanced right parenthesis.  
It accepts numeric arguments for repetition count.
It is useful in, for example, keyboard macros." (KM)
  (MOVE-POINT (OR (FORWARD-SEXP (POINT) *NUMERIC-ARG* NIL 0 NIL T T) (BARF)))
  (SET-CENTERING-FRACTION *NUMERIC-ARG*)
  DIS-BPS)

(DEFCOM COM-BACKWARD-SEXP-NO-UP "Moves backward one Lisp expression.
It never moves over an unbalanced left parenthesis.  
It accepts numeric arguments for repetition count.
It is useful in, for example, keyboard macros." (KM)
  (MOVE-POINT (OR (FORWARD-SEXP (POINT) (- *NUMERIC-ARG*) NIL 0 NIL T T) (BARF)))
  (SET-CENTERING-FRACTION (- *NUMERIC-ARG*))
  DIS-BPS)

(DEFCOM COM-FORWARD-LIST "Moves one list forward.  
It accepts numeric arguments for repetition count." (KM)
  (MOVE-POINT (OR (FORWARD-LIST (POINT) *NUMERIC-ARG*) (BARF)))
  (SET-CENTERING-FRACTION *NUMERIC-ARG*)
  DIS-BPS)

(DEFCOM COM-BACKWARD-SEXP "Moves backward over exactly one balanced Lisp expression.
It accepts numeric arguments for repetition count." (KM)
  (MOVE-POINT (OR (FORWARD-SEXP (POINT) (- *NUMERIC-ARG*)) (BARF)))
  (SET-CENTERING-FRACTION (- *NUMERIC-ARG*))
  DIS-BPS)

(DEFCOM COM-BACKWARD-LIST "Moves backward over one list.
It accepts numeric arguments for repetition count." (KM)
  (MOVE-POINT (OR (FORWARD-LIST (POINT) (- *NUMERIC-ARG*)) (BARF)))
  (SET-CENTERING-FRACTION (- *NUMERIC-ARG*))
  DIS-BPS)

(DEFCOM COM-KILL-SEXP "Kills forward over exactly one balanced Lisp expression.
It accepts numeric arguments for repetition count." ()
  (KILL-COMMAND-INTERNAL #'FORWARD-SEXP *NUMERIC-ARG*))

(DEFCOM COM-KILL-SEXP-NO-UP "Kills forward one Lisp expression.
It never kills over an unbalanced right parenthesis.  It accepts numeric
arguments for repetition count." ()
  (KILL-COMMAND-INTERNAL #'FORWARD-SEXP-NO-UP *NUMERIC-ARG*))

(DEFCOM COM-BACKWARD-KILL-SEXP "Kills backward over exactly one balanced Lisp expressions.
It accepts numeric arguments for repetition count." ()
  (KILL-COMMAND-INTERNAL #'FORWARD-SEXP (- *NUMERIC-ARG*)))

(DEFCOM COM-BACKWARD-KILL-SEXP-NO-UP "Kills one Lisp expression backward.
It never kills over an unbalanced left parenthesis.
It accepts numeric arguments for repetition count." ()
  (KILL-COMMAND-INTERNAL #'FORWARD-SEXP-NO-UP (- *NUMERIC-ARG*)))

(DEFCOM COM-MARK-SEXP "Sets mark one Lisp expression from point.
It accepts numeric arguments for repetition count." (SM)
  (MOVE-MARK (OR (FORWARD-SEXP (POINT) *NUMERIC-ARG*) (BARF)))
  DIS-BPS)

(DEFCOM COM-FORWARD-UP-LIST "Moves forward one level of list structure.
It searches for close parenthesis.
It accepts numeric arguments for repetition count.
Also, if called inside of a string, it moves up out of that string." (KM)
 (LET ((BP (FORWARD-UP-LIST-OR-STRING (POINT) *NUMERIC-ARG*)))
  (OR BP (BARF))
  (MOVE-POINT BP))
  (SET-CENTERING-FRACTION *NUMERIC-ARG*)
  DIS-BPS)

(DEFCOM COM-BACKWARD-UP-LIST "Moves backward one level of list structure.
It searches for open parenthesis.
It accepts numeric arguments for repetition count.
Also, if called inside of a string, it moves back up out of that string." (KM)
  (LET ((BP (FORWARD-UP-LIST-OR-STRING (POINT) (- *NUMERIC-ARG*))))
    (OR BP (BARF))
    (MOVE-POINT BP))
  (SET-CENTERING-FRACTION (- *NUMERIC-ARG*))
  DIS-BPS)

(DEFCOM COM-BEGINNING-OF-DEFINITION
	"Moves to the beginning of the current definition.
It places point directly before the last open
parenthesis at the left margin of the current
definition.  With a numeric argument (n), it moves
back to the beginning of the nth previous definition." (KM)
  (LET ((BP (OR (FORWARD-DEFINITION (POINT) (- *NUMERIC-ARG*) NIL *INTERVAL*) (BARF))))
    (POINT-PDL-PUSH (POINT) *WINDOW*)
    (MOVE-POINT BP))
  (SET-CENTERING-FRACTION (- *NUMERIC-ARG*))
  DIS-BPS)

(DEFCOM COM-END-OF-DEFINITION
	"Moves to the end of the current definition.
It places point directly after last close parenthesis
of current definition.  With a numeric argument (n),
it moves ahead to the end of the nth succeeding definition." (KM)
  (LET ((BP (FORWARD-DEFINITION (POINT) -1 T)))		;Go to front of defun.
    (OR (SETQ BP (FORWARD-SEXP BP)) (BARF))		; and forward over it.
    (SETQ BP (BEG-LINE BP 1 T))
    (COND ((OR (BP-< BP (POINT))                      ;If we were between defuns,
	       (AND (PLUSP *NUMERIC-ARG*) (BP-= BP (POINT))))
	   (SETQ BP (END-LINE BP -1 T))
	   (OR (SETQ BP (FORWARD-SEXP (FORWARD-DEFINITION BP 1 T *INTERVAL*)))
	       (BARF))
	   (SETQ BP (BEG-LINE BP 1 T))))              ; then move ahead another.
    (POINT-PDL-PUSH (POINT) *WINDOW*)
    (OR (= *NUMERIC-ARG* 1)
	(SETQ BP (BEG-LINE (FORWARD-SEXP (FORWARD-DEFINITION BP
							     (1- *NUMERIC-ARG*)
							     T
							     *INTERVAL*)
					 1 T)
			   1 T)))
    (MOVE-POINT BP))
  (SET-CENTERING-FRACTION *NUMERIC-ARG*)
  DIS-BPS)

(DEFCOM COM-DOWN-LIST "Moves down one level of list structure.
It searches for an open parenthesis.
With a numeric argument (n), it moves down n levels." (KM)
  (MOVE-POINT (OR (FORWARD-LIST (POINT) 1 NIL (- *NUMERIC-ARG*) T) (BARF)))
  DIS-BPS)

(DEFCOM COM-BACKWARD-DOWN-LIST
	"Moves backward down one level of list structure.
It moves to the right of the current list and searches for close parenthesis.
With a numeric argument (n), it moves backward down n levels." (KM)
  (MOVE-POINT (OR (FORWARD-LIST (POINT) -1 NIL (- *NUMERIC-ARG*) T T) (BARF)))
  DIS-BPS)

(DEFCOM COM-CONSOLE-CUT
	"Does a Kill Region and also sends the region to the console.
The console puts it in the embedded window system kill ring, if any."
	()
  (LET ((HISTORY (SYS:CONSOLE-KILL-HISTORY (TV:SHEET-CONSOLE TERMINAL-IO))))
    (WHEN (NULL HISTORY) (BARF))
    (MULTIPLE-VALUE-PROG1
      (COM-KILL-REGION)
      (LET ((INTERVAL (SEND *KILL-HISTORY* :YANK)))
	(WHEN (NULL INTERVAL) (BARF))
	(SEND HISTORY :PUSH INTERVAL)))))

(DEFCOM COM-CONSOLE-COPY
	"Does a Save Region and also sends the region to the console.
The console puts it in the embedded window system kill ring, if any."
	()
  (LET ((HISTORY (SYS:CONSOLE-KILL-HISTORY (TV:SHEET-CONSOLE TERMINAL-IO))))
    (WHEN (NULL HISTORY) (BARF))
    (MULTIPLE-VALUE-PROG1
      (COM-SAVE-REGION)
      (LET ((INTERVAL (SEND *KILL-HISTORY* :YANK)))
	(WHEN (NULL INTERVAL) (BARF))
	(SEND HISTORY :PUSH INTERVAL)))))

(DEFCOM COM-CONSOLE-PASTE
	"Pastes text from the embedded window system kill ring, if any."
	()
  (LET ((HISTORY (SYS:CONSOLE-KILL-HISTORY (TV:SHEET-CONSOLE TERMINAL-IO))))
    (WHEN (NULL HISTORY) (BARF))
    (YANK-COMMAND HISTORY)))

(DEFCOM COM-CONSOLE-PASTE-POP
	"Corrects a paste from the embedded window system kill ring, if any."
	()
  (LET ((HISTORY (SYS:CONSOLE-KILL-HISTORY (TV:SHEET-CONSOLE TERMINAL-IO))))
    (WHEN (OR (NULL HISTORY) (NEQ HISTORY *CURRENT-YANK-HISTORY*)) (BARF))
    (COM-YANK-POP)))

