;;; -*- Mode: LISP; Syntax: Zetalisp; Package: ZWEI; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Tag Tables and related items.

;;; Tag table buffers
(DEFFLAVOR TAG-TABLE-SPECIAL-PURPOSE-BUFFER
	(TAG-TABLE-NAME)
	(HEADER-DESCRIPTION-1-SUBNODE-SPECIAL-PURPOSE-BUFFER-MIXIN
	 SUBNODE-SPECIAL-PURPOSE-BUFFER)
  :SETTABLE-INSTANCE-VARIABLES
  (:METHOD-COMBINATION :BUFFER-INIT-OPTIONS :APPEND))

(DEFMETHOD (:BUFFER-INIT-OPTIONS TAG-TABLE-SPECIAL-PURPOSE-BUFFER) ()
  '(:SET-TAG-TABLE-NAME))

(DEFMETHOD (:DESCRIPTION TAG-TABLE-SPECIAL-PURPOSE-BUFFER) ()
  TAG-TABLE-NAME)

(DEFMETHOD (:BUFFER-KILLED TAG-TABLE-SPECIAL-PURPOSE-BUFFER) (BUFFER)
  (DOLIST (NODE (CDR INFERIORS))
    (WHEN (SEND-IF-HANDLES NODE :SAME-BUFFER-P BUFFER)
      (SEND SELF :DELETE-NODE NODE))))

(DEFFLAVOR TAG-TABLE-SUBNODE () (NODE)
  (:REQUIRED-METHODS :BUFFER :COPY-SELF-OPTIONS))

(DEFMETHOD (:RESTART TAG-TABLE-SUBNODE) () )

(DEFMETHOD (:SELECT-POSSIBILITY TAG-TABLE-SUBNODE) ()
  (SEND SUPERIOR ':SELECT-POSSIBILITY (SEND SELF ':BUFFER)))

(DEFMETHOD (:SELECT-POSSIBILITY TAG-TABLE-SPECIAL-PURPOSE-BUFFER) (BUFFER)
  (SEND *ZMACS-COMMAND-LOOP* ':SET-INTERVAL BUFFER)
  (MOVE-POINT (INTERVAL-FIRST-BP BUFFER)))

(DEFMETHOD (:NEXT-FILE TAG-TABLE-SPECIAL-PURPOSE-BUFFER)
	   (IGNORE &OPTIONAL (SELECT-P T) DONT-READ-FILE)
  (LET ((NODE (LOOP AS NODE = (SEND SELF ':NEXT-NODE)
		    ;; DONT-READ-FILE means that we shouldn't bother to read in
		    ;; the file, even if it's not in a buffer.  Commands like
		    ;; Add Patch Changed Definitions of Tag Table use it.
		    DO (WHEN (NULL NODE)
			 (RETURN NIL))
		       (UNLESS (AND DONT-READ-FILE
				    (NULL (FIND-BUFFER-NAMED (SEND NODE :PATHNAME) NIL)))
			 (RETURN NODE)))))
    (WHEN (NULL NODE)
      (TYPEIN-LINE "No more files in ")
      (TYPEIN-LINE-MORE (SEND SELF ':DESCRIPTION))
      (ABORT-CURRENT-COMMAND))
    (IF SELECT-P
	(SEND NODE ':SELECT-POSSIBILITY)
      (SEND NODE ':BUFFER))))

(DEFVAR *ZMACS-TAG-TABLE-BUFFER* NIL)

(DEFMETHOD (:KILL TAG-TABLE-SPECIAL-PURPOSE-BUFFER :BEFORE) (&OPTIONAL NO-SAVE-P)
  NO-SAVE-P
  (WHEN (EQ SELF *ZMACS-TAG-TABLE-BUFFER*)
    (SETQ *ZMACS-TAG-TABLE-BUFFER* NIL)))

(DEFMETHOD (:DESCRIPTION TAG-TABLE-SUBNODE) (STREAM)
  (PRINC (SEND SELF ':PATHNAME) STREAM))

(DEFMETHOD (:LIST-SUBNODES TAG-TABLE-SPECIAL-PURPOSE-BUFFER) (FIRST-NODE)
  (SCL:FORMAT-ITEM-LIST (LOOP FOR NODE FIRST FIRST-NODE THEN (NODE-NEXT NODE)
			      WHILE NODE
			      COLLECT (SEND NODE :PATHNAME))))

(DEFFLAVOR FILE-TAG-TABLE-SUBNODE (PATHNAME) (TAG-TABLE-SUBNODE)
  :GETTABLE-INSTANCE-VARIABLES
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (MAKE-INSTANCE FILE-TAG-TABLE-SUBNODE) (&REST IGNORE)
  ;; Make sure the version is :NEWEST, not NIL, so FIND-BUFFER-NAMED will work
  (SETQ PATHNAME (FS:MERGE-PATHNAMES PATHNAME *PATHNAME-DEFAULTS*)))

(DEFMETHOD (:BUFFER FILE-TAG-TABLE-SUBNODE) (&AUX BUFFER)
  (IF (SETQ BUFFER (FIND-BUFFER-NAMED PATHNAME))
      (TYPEIN-LINE "~A" PATHNAME)
      (MULTIPLE-VALUE (NIL BUFFER) (FIND-FILE PATHNAME NIL)))
  BUFFER)

(DEFMETHOD (:RESTART FILE-TAG-TABLE-SUBNODE) (&AUX BUFFER)
  (AND (SETQ BUFFER (FIND-BUFFER-NAMED PATHNAME))
       (MOVE-BP (IF (EQ BUFFER *INTERVAL*) (POINT) (BUFFER-SAVED-POINT BUFFER))
		(INTERVAL-FIRST-BP BUFFER))))

(DEFMETHOD (:COPY-SELF-OPTIONS FILE-TAG-TABLE-SUBNODE) ()
  `(:PATHNAME ,PATHNAME))

(DEFFLAVOR BUFFER-TAG-TABLE-SUBNODE (BUFFER) (TAG-TABLE-SUBNODE)
  :INITABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:BUFFER BUFFER-TAG-TABLE-SUBNODE) ()
  (TYPEIN-LINE "~A" (SEND BUFFER ':NAME))
  BUFFER)

(DEFMETHOD (:SAME-BUFFER-P BUFFER-TAG-TABLE-SUBNODE) (BUF)
  (EQ BUFFER BUF))

(DEFMETHOD (:PATHNAME BUFFER-TAG-TABLE-SUBNODE) () (SEND BUFFER ':PATHNAME))

(DEFMETHOD (:COPY-SELF-OPTIONS BUFFER-TAG-TABLE-SUBNODE) ()
  `(:BUFFER ,BUFFER))

(DEFMETHOD (:RESTART BUFFER-TAG-TABLE-SUBNODE) ()
  (MOVE-BP (IF (EQ BUFFER *INTERVAL*) (POINT) (BUFFER-SAVED-POINT BUFFER))
	   (INTERVAL-FIRST-BP BUFFER)))

(DEFINE-SPECIAL-BUFFER-TYPE FILES-TAG-TABLE-BUFFER
			    (FILES-LIST) (TAG-TABLE-SPECIAL-PURPOSE-BUFFER)
			    :FILES-TAG-TABLE "Tag-Table"
  :SETTABLE-INSTANCE-VARIABLES
  (:BUFFER-INIT-OPTIONS :SET-FILES-LIST))

(DEFMETHOD (:REVERT FILES-TAG-TABLE-BUFFER) ()
  (LOOP FOR FILE IN FILES-LIST
	WHEN (SEND FILE :WILD-P)
	DO (LET ((DIRECTORY-LIST (BARF-ON-ERRORS (FS:FILE-OPERATION-FAILURE)
				   (FS:DIRECTORY-LIST FILE ':FAST ':SORTED)))
		 (NEWEST-CHECK (EQ (SEND FILE ':VERSION) ':NEWEST)))
	     (LOOP FOR (FILE) IN DIRECTORY-LIST
		   DO (UNLESS (NULL FILE)
			(WHEN (OR NEWEST-CHECK
				  (EQ FILE (PROBEF (SEND FILE ':NEW-VERSION ':NEWEST))))
			  (SETQ FILE (SEND FILE ':NEW-VERSION ':NEWEST)))
			(SEND SELF ':ADD-NODE 'FILE-TAG-TABLE-SUBNODE ':PATHNAME FILE))))
	ELSE DO (SEND SELF ':ADD-NODE 'FILE-TAG-TABLE-SUBNODE ':PATHNAME FILE)))

(DEFMETHOD (:HEADER-DESCRIPTION-1 FILES-TAG-TABLE-BUFFER) (STREAM PLURAL-P)
  (FORMAT STREAM "File~P in ~A" PLURAL-P TAG-TABLE-NAME))

(DEFINE-SPECIAL-BUFFER-TYPE SYSTEM-TAG-TABLE-BUFFER
			    (SYSTEMS
			     INCLUDE-COMPONENTS
			     SYSTEM-VERSION
			     SYSTEM-BRANCHES
			     MACHINE-TYPE)
			    (TAG-TABLE-SPECIAL-PURPOSE-BUFFER)
			    :SYSTEM-TAG-TABLE "Tag-Table"
  :SETTABLE-INSTANCE-VARIABLES
  (:BUFFER-INIT-OPTIONS :SET-SYSTEMS :SET-SYSTEM-BRANCHES
			:SET-INCLUDE-COMPONENTS :SET-SYSTEM-VERSION
			:SET-MACHINE-TYPE))

(DEFMETHOD (:REVERT SYSTEM-TAG-TABLE-BUFFER) ()
  (LOOP FOR SYSTEM IN SYSTEMS 
	FOR SYSTEM-BRANCH IN SYSTEM-BRANCHES
			      DOING
    (LOOP WITH SYSTEM = (SCT:FIND-SYSTEM-NAMED (SCT:SYSTEM-SHORT-NAME SYSTEM) T)
	  FOR PATH IN (SCT:GET-ALL-SYSTEM-INPUT-FILES SYSTEM
		        :INCLUDE-COMPONENTS INCLUDE-COMPONENTS
			:SYSTEM-BRANCH SYSTEM-BRANCH
			:VERSION SYSTEM-VERSION
			:MACHINE-TYPE MACHINE-TYPE)
	  DO (WHEN (NULL (SEND PATH :TYPE))	;non-canonical types are acceptable
	       (SETQ PATH (SEND PATH :NEW-TYPE
				(OR (SECOND (ASSQ (SCT:SYSTEM-DEFAULT-MODULE-TYPE SYSTEM)
						  SCT:*MODULE-TYPE-FILE-TYPE-ALIST*))
				    :LISP))))
	     (WHEN (FILE-READABLE-BY-ZMACS PATH)
	       (SEND SELF :ADD-NODE 'FILE-TAG-TABLE-SUBNODE :PATHNAME PATH)))))

(DEFMETHOD (:HEADER-DESCRIPTION-1 SYSTEM-TAG-TABLE-BUFFER) (STREAM PLURAL-P)
  (FORMAT STREAM "File~P in system~P ~A" PLURAL-P (LENGTH SYSTEMS) TAG-TABLE-NAME))

(DEFINE-SPECIAL-BUFFER-TYPE FILE-TAG-TABLE-BUFFER
			    (PATHNAME) (TAG-TABLE-SPECIAL-PURPOSE-BUFFER)
			    :FILE-TAG-TABLE "Tag-Table"
  :SETTABLE-INSTANCE-VARIABLES
  (:BUFFER-INIT-OPTIONS :SET-PATHNAME))

(DEFMETHOD (:SET-PATHNAME FILE-TAG-TABLE-BUFFER :AFTER) (IGNORE)
  (SETQ TAG-TABLE-NAME (STRING PATHNAME)))

(DEFMETHOD (:REVERT FILE-TAG-TABLE-BUFFER) ()
  (LOOP FOR FILE IN (READ-TAG-TABLE PATHNAME)
	DO (SEND SELF ':ADD-NODE 'FILE-TAG-TABLE-SUBNODE ':PATHNAME FILE)))

(DEFMETHOD (:HEADER-DESCRIPTION-1 FILE-TAG-TABLE-BUFFER) (STREAM PLURAL-P)
  (FORMAT STREAM "File~P in tag table file ~A" PLURAL-P PATHNAME))

(DEFINE-SPECIAL-BUFFER-TYPE BUFFERS-TAG-TABLE-BUFFER
			    (BUFFERS-LIST) (TAG-TABLE-SPECIAL-PURPOSE-BUFFER)
			    :BUFFERS-TAG-TABLE "Tag-Table"
  :SETTABLE-INSTANCE-VARIABLES
  (:BUFFER-INIT-OPTIONS :SET-BUFFERS-LIST))

(DEFMETHOD (:REVERT BUFFERS-TAG-TABLE-BUFFER) ()
  (LOOP FOR BUFFER IN BUFFERS-LIST
	DO (SEND SELF ':ADD-NODE 'BUFFER-TAG-TABLE-SUBNODE ':BUFFER BUFFER)))

(DEFMETHOD (:HEADER-DESCRIPTION-1 BUFFERS-TAG-TABLE-BUFFER) (STREAM PLURAL-P)
  (FORMAT STREAM "Buffer~P in ~A" PLURAL-P TAG-TABLE-NAME))

;;; Something that actually does something with the buffers (e.g. tags search)
(DEFFLAVOR TAG-TABLE-USER-SPECIAL-PURPOSE-BUFFER
	(TAG-TABLE-BUFFER)
	(REUSABLE-POSSIBILITIES-SPECIAL-PURPOSE-BUFFER-MIXIN
	 SUBNODE-SPECIAL-PURPOSE-BUFFER)
  (:METHOD-COMBINATION :BUFFER-INIT-OPTIONS :APPEND)
  :SETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:KILL TAG-TABLE-USER-SPECIAL-PURPOSE-BUFFER :BEFORE) (&OPTIONAL NO-SAVE-P)
  NO-SAVE-P
  (WHEN (EQ SELF *ZMACS-TAG-TABLE-USER*)
    (SETQ *ZMACS-TAG-TABLE-USER* NIL)))

(DEFMETHOD (:BUFFER-INIT-OPTIONS TAG-TABLE-USER-SPECIAL-PURPOSE-BUFFER) ()
  '(:SET-TAG-TABLE-BUFFER))

(DEFMETHOD (:DESCRIPTION TAG-TABLE-USER-SPECIAL-PURPOSE-BUFFER) ()
  (WITH-OUTPUT-TO-STRING (STREAM)
    (SEND SELF ':DESCRIPTION-1 STREAM)
    (FORMAT STREAM " in ~A" (SEND TAG-TABLE-BUFFER ':DESCRIPTION))))

;;; We continue with the same buffer until told not to
(DEFMETHOD (:NEXT-NODE-PEEK-P TAG-TABLE-USER-SPECIAL-PURPOSE-BUFFER) () T)

(DEFMETHOD (:REVERT TAG-TABLE-USER-SPECIAL-PURPOSE-BUFFER) ()
  (LOOP FOR NODE IN (NODE-INFERIORS TAG-TABLE-BUFFER)
	WHEN (TYPEP NODE 'TAG-TABLE-SUBNODE)
	DO (LEXPR-SEND SELF ':ADD-NODE (TYPEP NODE) (SEND NODE ':COPY-SELF-OPTIONS))))

(DEFMETHOD (:RESTART TAG-TABLE-USER-SPECIAL-PURPOSE-BUFFER :AFTER) ()
  (LOOP FOR NODE IN INFERIORS
	WHEN (TYPEP NODE 'TAG-TABLE-SUBNODE)
	RETURN (SEND NODE ':RESTART)))

(DEFMETHOD (:HEADER-DESCRIPTION TAG-TABLE-USER-SPECIAL-PURPOSE-BUFFER :AFTER) (STREAM)
  (FORMAT STREAM " in:~%")
  (SEND TAG-TABLE-BUFFER ':HEADER-DESCRIPTION STREAM))

(DEFMETHOD (:NEXT-BUFFER TAG-TABLE-USER-SPECIAL-PURPOSE-BUFFER) (&OPTIONAL NOSKIP-P)
  (OR NOSKIP-P (SEND SELF ':NEXT-NODE NIL))	;Advance to next file
  (LET ((NODE (SEND SELF ':NEXT-NODE T)))
    (COND ((NULL NODE)
	   (TYPEIN-LINE "No more files.")
	   (POP-POSSIBILITIES-BUFFER)
	   (ABORT-CURRENT-COMMAND))
	  (T
	   (SEND NODE ':BUFFER)))))

(DEFMETHOD (:NEXT-FILE TAG-TABLE-USER-SPECIAL-PURPOSE-BUFFER) (NOSKIP-P &AUX BUFFER)
  (SETQ BUFFER (SEND SELF ':NEXT-BUFFER NOSKIP-P))
  (SEND *ZMACS-COMMAND-LOOP* ':SET-INTERVAL BUFFER)
  (MOVE-POINT (INTERVAL-FIRST-BP BUFFER)))

(DEFMETHOD (:LIST-POSSIBILITIES TAG-TABLE-USER-SPECIAL-PURPOSE-BUFFER) (REMAINING-P)
  (SEND SELF ':HEADER-DESCRIPTION STANDARD-OUTPUT)
  (LET ((FIRST-NODE (IF REMAINING-P (SEND SELF ':NEXT-NODE T) (CADR INFERIORS))))
    (FORMAT T "~&~:[ F~; Remaining f~]iles:~%"
	    (AND REMAINING-P (NEQ FIRST-NODE (CADR INFERIORS))))
    (LOOP FOR NODE FIRST FIRST-NODE THEN (NODE-NEXT NODE)
	  WHILE NODE
	  DO (FUNCALL STANDARD-OUTPUT ':FRESH-LINE)
	     (SEND NODE ':DESCRIPTION STANDARD-OUTPUT))))

(DEFINE-SPECIAL-BUFFER-TYPE TAGS-SEARCH-BUFFER
			    (SEARCH-FUNCTION SEARCH-KEY SEARCH-STRING
			     SKIP-TABLE REOCCURRENCE-TABLE)
			    (TAG-TABLE-USER-SPECIAL-PURPOSE-BUFFER)
			    :TAGS-SEARCH "Tags-Search"
  :SETTABLE-INSTANCE-VARIABLES
  (:BUFFER-INIT-OPTIONS :SET-SEARCH-FUNCTION :SET-SEARCH-KEY :SET-SEARCH-STRING
			:SET-SKIP-TABLE :SET-REOCCURRENCE-TABLE))

(DEFMETHOD (:DESCRIPTION-1 TAGS-SEARCH-BUFFER) (STREAM)
  (WITH-EXTENDED-SEARCH-DISPLAY
    (FORMAT STREAM "/"~A/"" SEARCH-STRING)))

(DEFMETHOD (:HEADER-DESCRIPTION TAGS-SEARCH-BUFFER) (STREAM)
  (WITH-EXTENDED-SEARCH-DISPLAY
    (FORMAT STREAM "Search for /"~A/"" SEARCH-STRING)))

(DEFMETHOD (:DOCUMENT TAGS-SEARCH-BUFFER) (IGNORE)
  (WITH-EXTENDED-SEARCH-DISPLAY
    (FORMAT T "Search for the next occurrence of /"~A/"" SEARCH-STRING)))

(DEFMETHOD (:SELECT-POSSIBILITY TAGS-SEARCH-BUFFER) (STARTING-BUFFER)
  (LOOP FOR BUFFER = STARTING-BUFFER THEN (SEND SELF ':NEXT-BUFFER)
	FOR BP = (IF (EQ BUFFER *INTERVAL*) (POINT) (BUFFER-SAVED-POINT BUFFER))
	       THEN (INTERVAL-FIRST-BP BUFFER)
	WHEN (SETQ BP (LET ((*INTERVAL* BUFFER))
			(IF (AND (EQ SEARCH-FUNCTION 'SEARCH)
				 SKIP-TABLE REOCCURRENCE-TABLE)
			    (SEARCH BP SEARCH-KEY NIL NIL NIL NIL
				    *ALPHABETIC-CASE-AFFECTS-SEARCH*
				    SKIP-TABLE REOCCURRENCE-TABLE)
			    (FUNCALL SEARCH-FUNCTION BP SEARCH-KEY))))
	  DO (POINT-PDL-PUSH (POINT) *WINDOW*)
	     (SEND *ZMACS-COMMAND-LOOP* ':SET-INTERVAL BUFFER)
	     (MOVE-POINT BP)
	     (RETURN DIS-TEXT)))

(DEFINE-SPECIAL-BUFFER-TYPE TAGS-FIND-PATTERN-BUFFER
	(SEARCH-PATTERN SEARCH-RESTART)
	(TAG-TABLE-USER-SPECIAL-PURPOSE-BUFFER)
	:TAGS-FIND-PATTERN "Tags-Find-Pattern"
  :SETTABLE-INSTANCE-VARIABLES
  (:BUFFER-INIT-OPTIONS :SET-SEARCH-PATTERN))

(DEFMETHOD (:DESCRIPTION-1 TAGS-FIND-PATTERN-BUFFER) (STREAM)
  (FORMAT STREAM "/"~s/"" SEARCH-PATTERN))

(DEFMETHOD (:HEADER-DESCRIPTION TAGS-FIND-PATTERN-BUFFER) (STREAM)
  (FORMAT STREAM "Search for /"~s/"" SEARCH-PATTERN))

(DEFMETHOD (:DOCUMENT TAGS-FIND-PATTERN-BUFFER) (IGNORE)
  (FORMAT T "Search for the next occurrence of /"~s/"" SEARCH-PATTERN))

(DEFMETHOD (:SELECT-POSSIBILITY TAGS-FIND-PATTERN-BUFFER) (STARTING-BUFFER)
  (LOOP FOR BUFFER = STARTING-BUFFER THEN (SEND SELF ':NEXT-BUFFER)
	DO
    (UNLESS (EQ BUFFER *INTERVAL*)
      (SETQ SEARCH-RESTART NIL)
      (SEND *ZMACS-COMMAND-LOOP* :SET-INTERVAL BUFFER)
      (MOVE-POINT (INTERVAL-FIRST-BP BUFFER)))
    (LET ((BP))
      (MULTIPLE-VALUE (BP SEARCH-RESTART)
	(FIND-PATTERN (POINT) SEARCH-PATTERN SEARCH-RESTART))
      (WHEN BP
	(SETQ *LAST-PATTERN* SEARCH-PATTERN
	      *LAST-PATTERN-BP* BP *LAST-PATTERN-RESTART-LIST* SEARCH-RESTART)
	(POINT-PDL-PUSH (POINT) *WINDOW*)
	(MOVE-POINT BP)
	(RETURN DIS-TEXT)))
	FINALLY (RETURN DIS-TEXT)))
						
(DEFINE-SPECIAL-BUFFER-TYPE TAGS-QUERY-REPLACE-BUFFER
			    (FROM TO DELIMITED) (TAG-TABLE-USER-SPECIAL-PURPOSE-BUFFER)
			    :TAGS-QUERY-REPLACE "Tags-Query-Replace"
  :SETTABLE-INSTANCE-VARIABLES
  (:BUFFER-INIT-OPTIONS :SET-FROM :SET-TO :SET-DELIMITED))

(DEFMETHOD (:DESCRIPTION-1 TAGS-QUERY-REPLACE-BUFFER) (STREAM)
  (FORMAT STREAM "~A~A" FROM TO))

(DEFMETHOD (:HEADER-DESCRIPTION TAGS-QUERY-REPLACE-BUFFER) (STREAM)
  (PRINC "Query replace " STREAM)
  (SEND SELF ':DESCRIBE-QUERY-REPLACE-STRINGS STREAM))

(DEFMETHOD (:DOCUMENT TAGS-QUERY-REPLACE-BUFFER) (IGNORE)
  (PRINC "Continue query replacement of ")
  (SEND SELF ':DESCRIBE-QUERY-REPLACE-STRINGS STANDARD-OUTPUT))

(DEFMETHOD (:DESCRIBE-QUERY-REPLACE-STRINGS TAGS-QUERY-REPLACE-BUFFER) (STREAM)
  (FORMAT STREAM "/"~A/" with /"~A/"" FROM TO))

(DEFMETHOD (:SELECT-POSSIBILITY TAGS-QUERY-REPLACE-BUFFER) (STARTING-BUFFER)
  (LOOP FOR BUFFER = STARTING-BUFFER THEN (SEND SELF ':NEXT-BUFFER)
	FOR START-BP = (IF (EQ BUFFER *INTERVAL*) (POINT) (BUFFER-SAVED-POINT BUFFER))
		     THEN (INTERVAL-FIRST-BP BUFFER)
	AS VAL = NIL
	DO
    (UNLESS (EQ *INTERVAL* BUFFER)
      (MAKE-BUFFER-CURRENT BUFFER))
    (SETQ VAL (SEND SELF :QUERY-REPLACE BUFFER START-BP))
	WHEN (EQ VAL 'ABORTED) RETURN DIS-TEXT))

(DEFMETHOD (:QUERY-REPLACE TAGS-QUERY-REPLACE-BUFFER) (BUFFER START-BP)
  (QUERY-REPLACE FROM TO DELIMITED BUFFER START-BP))

(DEFINE-SPECIAL-BUFFER-TYPE TAGS-MULTIPLE-QUERY-REPLACE-BUFFER ()
			    (TAGS-QUERY-REPLACE-BUFFER)
			    :TAGS-MULTIPLE-QUERY-REPLACE "Tags-Multiple-Query-Replace"
  :SETTABLE-INSTANCE-VARIABLES)

(DEFMETHOD (:QUERY-REPLACE TAGS-MULTIPLE-QUERY-REPLACE-BUFFER) (BUFFER START-BP)
  (LET-IF (AND DELIMITED (MINUSP DELIMITED))
	  ((*MODE-WORD-SYNTAX-TABLE* *ATOM-WORD-SYNTAX-TABLE*))
    (QUERY-REPLACE-LIST START-BP FROM TO DELIMITED BUFFER)))

(DEFMETHOD (:DESCRIPTION-1 TAGS-MULTIPLE-QUERY-REPLACE-BUFFER) (STREAM)
  (SEND SELF ':DESCRIBE-QUERY-REPLACE-STRINGS STREAM))

(DEFMETHOD (:DESCRIBE-QUERY-REPLACE-STRINGS TAGS-MULTIPLE-QUERY-REPLACE-BUFFER) (STREAM)
  (LOOP FOR FROM-L ON FROM
	FOR TO-L ON TO
	WITH COMMA-P = NIL
	WHEN COMMA-P DO (PRINC ", " STREAM)
			(AND (CDR FROM-L) (CDR TO-L) (PRINC "and " STREAM))
	ELSE DO (SETQ COMMA-P T)
	DO (PRIN1 (CAR FROM-L) STREAM)
	   (PRINC "" STREAM)
	   (PRIN1 (CAR TO-L) STREAM)))

;;; Tag table stuff
(DEFCOM COM-VISIT-TAG-TABLE "Reads in the specified tag table file.
It prompts for a file name from the minibuffer.  It goes through the tag
table, and marks the name of each tag as being a possible section of its file.
Later, the Edit Definition command uses these marks to figure out which file
to use.

These files are produced by a program that runs on ITS, not
by writing out the buffers produced by Select System As Tags Table
and friends." ()
  (LET ((PATHNAME (ACCEPT-DEFAULTED-PATHNAME "Tag Table" (PATHNAME-DEFAULTS)
					     :SPECIAL-TYPE :TAGS)))
    (SELECT-TAG-TABLE ':FILE-TAG-TABLE ':SET-PATHNAME PATHNAME))
  DIS-NONE)


(DEFUN READ-TAG-TABLE (FILE)
  (WITH-OPEN-FILE (STREAM FILE :DIRECTION :INPUT :SUPER-IMAGE T)
    (DO ((LINE) (EOF)
	 (HOST (SEND (SEND STREAM ':PATHNAME) ':HOST))
	 (FILE-LIST) (PATHNAME) (MODE))
	(NIL)
      (MULTIPLE-VALUE (LINE EOF)
	(SEND STREAM :LINE-IN))
      (WHEN EOF (RETURN FILE-LIST))
      (FLET ((REPORT-INVALID-FILE (MSG)
	       (BARF "Error reading tag table: ~~A~~@
		      ~A is not a valid (PDP-10 style) Tags table."
		     MSG (SEND STREAM :TRUENAME))))
	(CONDITION-CASE (.ERROR-OR-PATHNAME.)
	    (FS:PARSE-PATHNAME LINE HOST)
	  (FS:PATHNAME-ERROR (REPORT-INVALID-FILE .ERROR-OR-PATHNAME.))
	  (:NO-ERROR
	   (SETQ PATHNAME (FS:MERGE-PATHNAMES .ERROR-OR-PATHNAME. *PATHNAME-DEFAULTS*))))
	(PUSH PATHNAME FILE-LIST)
	(SETQ LINE (SEND STREAM :LINE-IN))	;Length,Mode
	(LET ((COMMA-POS (STRING-SEARCH-CHAR #/, LINE)))
	  (UNLESS COMMA-POS
	    (REPORT-INVALID-FILE (FORMAT NIL "Missing file mode in /"~A/"" LINE)))
	  (SETQ MODE (SUBSTRING LINE (1+ comma-pos)))))
      (DO ((PACKAGE (PKG-FIND-PACKAGE (OR (FUNCALL (FUNCALL PATHNAME ':GENERIC-PATHNAME)
						   ':GET ':PACKAGE)
					  PACKAGE)))
	   (SPACE-POS) (RUBOUT-POS)
	   (STR) (SNAME))
	  ((CHAR-EQUAL (AREF (SETQ LINE (FUNCALL STREAM ':LINE-IN)) 0) #/))
	(COND ((SETQ SPACE-POS (STRING-SEARCH-SET '(#\SP #\TAB) LINE))
	       (SETQ SPACE-POS (1+ SPACE-POS)
		     RUBOUT-POS (COND ((STRING-SEARCH-CHAR (CODE-CHAR #O177) LINE SPACE-POS))
				      (T (SEND STREAM ':LINE-IN)
					 (1+ (STRING-LENGTH LINE))))
		     STR (SUBSTRING LINE SPACE-POS (1- RUBOUT-POS)))
	       (COND ((SELECTOR MODE STRING-EQUAL
			("LISP"
			 (AND (%STRING-EQUAL LINE 0 "(DEF" 0 4)
			      (NOT (%STRING-EQUAL LINE 0 "(DEFPROP " 0 9))
			      (SETQ SNAME (SYMBOL-FROM-STRING STR))))
			(("TEXT" "BOLIO" "R")
			 (AND (%STRING-EQUAL LINE 0 ".DEF" 0 4)
			      (SETQ SNAME (INTERN STR *UTILITY-PACKAGE*))))
			(OTHERWISE NIL))
		      (SECTION-COMPLETION SNAME STR NIL 1000)
		      (OR (GET SNAME ':SOURCE-FILE-NAME)
			  (PUTPROP SNAME PATHNAME ':SOURCE-FILE-NAME))))))))))

(DEFCOM COM-LIST-TAG-TABLES "Lists the names of all the tag table files read in.  " ()
  (DOLIST (BUFFER *ZMACS-BUFFER-LIST*)
    (AND (TYPEP BUFFER 'TAG-TABLE-SPECIAL-PURPOSE-BUFFER)
	 (SEND BUFFER ':LIST-POSSIBILITIES NIL)))
  (FORMAT *TYPEOUT-WINDOW* "~&Done.~%")
  DIS-NONE)

(DEFCOM COM-NEXT-FILE 
  "Moves to the next file in the tags table, skipping the remainder of the current file.
If given an argument, starts over in the list." ()
  (LET ((BUFFER (OR *ZMACS-TAG-TABLE-USER* (SELECT-TAG-TABLE NIL))))
    (AND *NUMERIC-ARG-P* (SEND BUFFER ':RESTART))
    (SEND BUFFER ':NEXT-FILE *NUMERIC-ARG-P*))
  DIS-TEXT)

(DEFVAR *FIND-FILES-STACK-GROWN* NIL)

(DEFCOM COM-FIND-FILES-IN-TAG-TABLE
  "Reads all files in the current tag table into the editor." ()
  (CONDITION-BIND ((SYS:PDL-OVERFLOW
		     #'(LAMBDA (CONDITION)
			 (WHEN (DBG:PROCEED-TYPE-P CONDITION :GROW-PDL)
			   (UNLESS *FIND-FILES-STACK-GROWN*
			    ;(FORMAT T "~&Growing stack.~%");For debugging
			     (SETQ *FIND-FILES-STACK-GROWN* T)
			     :GROW-PDL)))))
    (LET ((BUFFER (SELECT-TAG-TABLE NIL)))
      (SEND BUFFER ':RESTART)
      (LOOP DOING (SEND BUFFER ':NEXT-FILE NIL NIL))))
  DIS-NONE)

(DEFCOM COM-TAGS-SEARCH "Searches for the specified string within files of the tags table." ()
  (MULTIPLE-VALUE-BIND (FUNCTION KEY NIL NIL NIL SKIP REOCCURRENCE)
      (GET-EXTENDED-STRING-SEARCH-STRINGS NIL "Tags search:" *SEARCH-MINI-BUFFER-COMTAB*)
    (SELECT-TAG-TABLE-USER ':TAGS-SEARCH
			   ':SET-SEARCH-FUNCTION FUNCTION ':SET-SEARCH-KEY KEY
			   ':SET-SEARCH-STRING *EXTENDED-STRING-SEARCH-LAST-STRING*
			   :SET-SKIP-TABLE SKIP :SET-REOCCURRENCE-TABLE REOCCURRENCE)))

(DEFCOM COM-TAGS-FIND-PATTERN "Move to next occurrence of the given pattern within files
of the tags table. The pattern must be a list, ** matches any one thing, ... any number
of things. A numeric argument repeats the last search." ()
  (LET ((FORM))
    (COND (*NUMERIC-ARG-P*
	   (SETQ FORM (OR *LAST-PATTERN* (BARF "No previous pattern")))
	   (TYPEIN-LINE "Finding ~S" FORM))
	  (T
	   (SETQ FORM (TYPEIN-LINE-ACCEPT 'SYS:EXPRESSION
					   :DEFAULT *LAST-PATTERN*
					   :PROMPT "Pattern to search for"))
	   (SETQ FORM (SUBLIS (LIST (CONS (INTERN "...") ':...)
				    (CONS (INTERN "**") ':**))
			      FORM))))
    (SELECT-TAG-TABLE-USER ':TAGS-FIND-PATTERN
			   ':SET-SEARCH-PATTERN FORM)))

(DEFCOM COM-TAGS-FIND-SYMBOLS-IN-REGION
	"Searches for the symbols in the marked region, within files of the tags table." ()
  (LET ((STRINGS (REGION (BP1 BP2)
		   (LOOP WITH STREAM = (INTERVAL-STREAM BP1 BP2)
			 AS SEXP = (CL:READ STREAM NIL STREAM)
			 UNTIL (EQ SEXP STREAM)
			 NCONC (LABELS ((COLLECT-STRINGS (TREE)
					  (COND ((SYMBOLP TREE)
						 (NCONS (STRING-APPEND ;; %FSM-SYMBOL-DELIMITER
								       (CODE-CHAR 8 %FSM-SET)
								       (STRING TREE)
								       (CODE-CHAR 8 %FSM-SET)
								       )))
						((CL:SIMPLE-VECTOR-P TREE)
						 (LOOP FOR X BEING THE ARRAY-ELEMENTS OF TREE
						       NCONC (COLLECT-STRINGS X)))
						((ATOM TREE) NIL)
						(T (NCONC
						     (LOOP NCONC (COLLECT-STRINGS (POP TREE))
							   WHILE (CL:CONSP TREE))
						     (UNLESS (NULL TREE)
						       (COLLECT-STRINGS TREE)))))))
				 (COLLECT-STRINGS SEXP))))))
    (COND ((NULL STRINGS) (FORMAT *TYPEIN-WINDOW* "~&No symbols found in region."))
	  (T (FORMAT *TYPEIN-WINDOW* "~&Searching for ~:D symbol~:P." (LENGTH STRINGS))
	     (SELECT-TAG-TABLE-USER ':TAGS-SEARCH
				    ':SET-SEARCH-FUNCTION 'FSM-SEARCH
				    ':SET-SEARCH-KEY STRINGS
				    ':SET-SEARCH-STRING "<symbols>")))))

(DEFCOM COM-TAGS-QUERY-REPLACE
	"Replaces occurrences of one string with another within the tags table files,
asking about each occurrence.
It prompts first for the string to remove and second for the string to replace
it with.  A numeric argument means to consider only the cases where the string
to remove occurs as a word (rather than within a word).  When it finds an
occurrence of the first string, it stops and waits for you to supply
confirmation by typing a character.

Space   Replaces the first string and moves to its next occurrence.
Rubout  Skips this occurrence and moves to the next one.
Comma   Replaces this occurrence and redisplays the result, waiting for further
        confirmation (in the form of Space, c-R, or End).
Period  Replaces this occurrence and stops.
End     Stops without doing any replacement.
!    Replaces all remaining occurrences without any more prompting for this particular
     file.  Querying resumes with the next file.
^    Returns to the site of the previous occurrence  (actually, pops the point pdl).
c-W  Deletes this occurrence and enters a recursive editing level.
c-R  Enters a recursive editing level without doing any replacement or deletion.
c-L  Redisplays the screen.

Any other character causes this command to terminate (the character is then
read as input by the editor).

Usually it attempts to match the case of the replacements with the case of the
string being replaced.  This behavior is controlled by ZWEI:*CASE-REPLACE-P*.
When it is null, case matching does not take place." ()
  (LET ((ARG (AND *NUMERIC-ARG-P* *NUMERIC-ARG*)))
    (MULTIPLE-VALUE-BIND (FROM-STRING TO-STRING)
	(QUERY-REPLACE-STRINGS NIL ARG "replace (within the tags table files)")
      (SETUP-TAGS-QUERY-REPLACE ':TAGS-QUERY-REPLACE FROM-STRING TO-STRING ARG))))

(DEFCOM COM-TAGS-MULTIPLE-QUERY-REPLACE
	"Replaces occurrences of any number of strings with other strings within the tags
table files, asking about each change.
It prompts for the strings in pairs, first for the string to remove and second
for the string to replace it with.  When you have entered all the pairs you
need, end it with Return.  Then it begins searching for any of the strings and
stops when it finds any occurrence, waiting for you to supply confirmation.

A positive numeric argument means to consider only the cases where the strings
to replace occur as a word (rather than within a word).  A negative numeric
argument means to consider only delimited atoms, rather than words. 

This command has the same options as Query Replace.  See the documentation for
Query Replace." ()
  (LET ((ARG (AND *NUMERIC-ARG-P* *NUMERIC-ARG*)))
    (MULTIPLE-VALUE-BIND (FROM-LIST TO-LIST)
	(MULTIPLE-QUERY-REPLACE-STRINGS NIL ARG)
      (SETUP-TAGS-QUERY-REPLACE ':TAGS-MULTIPLE-QUERY-REPLACE FROM-LIST TO-LIST ARG))))

(DEFCOM COM-TAGS-MULTIPLE-QUERY-REPLACE-FROM-BUFFER
	"Replaces occurrences of any number of strings with other strings within the tags
table files, asking about each change.
The current buffer should contain pairs of replacement strings, on single lines separated
by spaces or surrounded by /"'s.

A positive numeric argument means to consider only the cases where the strings
to replace occur as a word (rather than within a word).  A negative numeric
argument means to consider only delimited atoms, rather than words. 

This command has the same options as Query Replace.  See the documentation for
Query Replace." ()
  (MULTIPLE-VALUE-BIND (FROM-LIST TO-LIST)
      (PARSE-BUFFER-REPLACE-PAIRS *INTERVAL*)
    (SETUP-TAGS-QUERY-REPLACE ':TAGS-MULTIPLE-QUERY-REPLACE FROM-LIST TO-LIST
			      (AND *NUMERIC-ARG-P* *NUMERIC-ARG*))))

(DEFUN SETUP-TAGS-QUERY-REPLACE (TYPE FROM TO DELIMITED)
  (SELECT-TAG-TABLE-USER TYPE ':SET-FROM FROM ':SET-TO TO ':SET-DELIMITED DELIMITED))

(DEFCOM COM-SELECT-TAG-TABLE "Makes a tag table current for commands like tags search." ()
  (SELECT-TAG-TABLE T)
  DIS-NONE)

(DEFCOM COM-SELECT-SYSTEM-AS-TAG-TABLE
	"Select all the files in a system as a tags table.
With a numeric argument, reads the files of the component system, too." ()
  (SELECT-SYSTEM-AS-TAG-TABLE *NUMERIC-ARG-P*)
  DIS-NONE)

(DEFCOM COM-SELECT-SYSTEM-VERSION-AS-TAG-TABLE
	"Selects all the files in a specified major version of a system as a tags table.
With a numeric argument, reads the files of the component system, too." ()
  (SELECT-SYSTEM-AS-TAG-TABLE *NUMERIC-ARG-P* :VERSION ':ASK)
  DIS-NONE)

(DEFCOM COM-SELECT-SYSTEM-FOR-MACHINE-TYPES-AS-TAG-TABLE
	"Selects all the files in a system for the specified machine type as a tags table.
With a numeric argument, reads the files of the component system, too." ()
  (SELECT-SYSTEM-AS-TAG-TABLE *NUMERIC-ARG-P* :MACHINE-TYPE ':ASK)
  DIS-NONE)

(DEFUN SELECT-SYSTEM-AS-TAG-TABLE (INCLUDE-COMPONENTS &KEY VERSION (MACHINE-TYPE :ALL))
  (LET* ((DEFAULT (SUBSYSTEM-FOR-BUFFER *INTERVAL*))
	 (SYSTEM-SPECS (TYPEIN-LINE-ACCEPT
			 '((SCL:SEQUENCE
			     ((SCL:TYPE-OR-STRING ((OR SCT:SUBSYSTEM SCT:SYSTEM))))))
			 :DEFAULT (WHEN DEFAULT (LIST DEFAULT))
			 :PROMPT "Select system (or subsystem)"))
	 (SYSTEMS (LOOP FOR SYS IN SYSTEM-SPECS
			AS SYSTEM = (IF (OR (NULL SYS)
					    (AND (STRINGP SYS) (STRING= SYS "")))
					(BARF "/"/" is not a valid system name")
				      (SCT:FIND-SYSTEM-NAMED SYS NIL NIL))
			DO (WHEN (NULL SYSTEM)
			     (BARF "There is no such system as ~A" SYS))
			COLLECT SYSTEM))
	 (VERSION-SPEC (AND (= (LENGTH SYSTEMS) 1)
			    (IF (EQ VERSION ':ASK)
				(TYPEIN-LINE-ACCEPT
				  `((SCT:SYSTEM-VERSION :SYSTEM ,(FIRST SYSTEMS)))
				  :DEFAULT :LATEST
				  :PROMPT "System version")
			      VERSION)))
	 (BRANCHES (LOOP FOR SYSTEM IN SYSTEMS
			 AS VC-BRANCH = (AND (SCT:SYSTEM-VERSION-CONTROLLED SYSTEM)
					     (TYPEIN-LINE-ACCEPT 'CL:STRING
					       :PROMPT
					         (FORMAT NIL "System branch for ~A" SYSTEM)
					       :DEFAULT
					         (STRING
						   (SCT:SYSTEM-DEFAULT-SYSTEM-BRANCH SYSTEM))))
			 COLLECT VC-BRANCH))
	 (MACHINE-TYPE (IF (EQ MACHINE-TYPE :ASK)
			   (TYPEIN-LINE-ACCEPT
			     `(SCL:TOKEN-OR-TYPE
				(:ALL)
				(SCL:SEQUENCE (SCL:MEMBER ,@SCT:*ALL-MACHINE-TYPES*))) 
			     :DEFAULT (LIST SCT:*CURRENT-MACHINE-TYPE*) 
			     :PROMPT "machine types")
			   MACHINE-TYPE)))
    (LET* ((NAME (IF (= (LENGTH SYSTEMS) 1)
		     (SCT:SYSTEM-SHORT-NAME (FIRST SYSTEMS))
		   (LET ((NAME (MAKE-ARRAY 100 :TYPE 'ART-STRING :FILL-POINTER 0)))
		     (WITH-OUTPUT-TO-STRING (S NAME)
		       (SCL:FORMAT-TEXTUAL-LIST
			 SYSTEMS
			 #'(LAMBDA (SYSTEM STREAM)
			     (PRINC (SCT:SYSTEM-SHORT-NAME SYSTEM) STREAM))
			 :CONJUNCTION "and" :STREAM S)
		       NAME)))))
      (SELECT-TAG-TABLE ':SYSTEM-TAG-TABLE
			':SET-TAG-TABLE-NAME NAME
			':SET-SYSTEMS SYSTEMS
			':SET-SYSTEM-BRANCHES BRANCHES
			':SET-SYSTEM-VERSION VERSION-SPEC
			':SET-INCLUDE-COMPONENTS INCLUDE-COMPONENTS
			':SET-MACHINE-TYPE MACHINE-TYPE))))

(DEFCOM COM-SELECT-ALL-BUFFERS-AS-TAG-TABLE "Selects all existing file buffers.
With a numeric argument, prompts for a string and only buffers whose name
contains that string are considered." ()
  (SELECT-ALL-BUFFERS-AS-TAG-TABLE
    (WHEN *NUMERIC-ARG-P*
      (TYPEIN-LINE-READLINE "Select buffers matching substring:")))
  DIS-NONE)

(DEFUN SELECT-ALL-BUFFERS-AS-TAG-TABLE (&OPTIONAL APROPOS)
  (SELECT-TAG-TABLE ':BUFFERS-TAG-TABLE
		    ':SET-BUFFERS-LIST
		    (LOOP FOR BUFFER IN *ZMACS-BUFFER-LIST*
			  WHEN (AND (OR (NOT APROPOS)
					(STRING-SEARCH APROPOS (SEND BUFFER :NAME)))
				    (FUNCALL BUFFER ':EDITING-FILE-P))
			    COLLECT BUFFER)
		    ':SET-TAG-TABLE-NAME
		    (FORMAT NIL "All buffers~@[ matching ~S~]" APROPOS)))

(DEFCOM COM-SELECT-SOME-BUFFERS-AS-TAG-TABLE
"Selects some existing file buffers, querying about each one.
With a numeric argument, prompts for a string and only buffers whose name
contains that string are considered." ()
  (LET ((APROPOS))
    (IF *NUMERIC-ARG-P*
	(SETQ APROPOS (TYPEIN-LINE-READLINE "Select buffers matching substring:")))
    (LET ((BUFFERS
	    (LOOP WITH QUERY-IO = *TYPEOUT-WINDOW*
		  FOR BUFFER IN *ZMACS-BUFFER-LIST*
		  WHEN
		    (AND (OR (NOT APROPOS)
			     (STRING-SEARCH APROPOS (SEND BUFFER :NAME)))
			 (SEND BUFFER ':EDITING-FILE-P)
			 (FQUERY '(:SELECT T) "Buffer ~A, select it? "
				 (SEND BUFFER :NAME)))
		    COLLECT BUFFER)))
      (SELECT-TAG-TABLE ':BUFFERS-TAG-TABLE
			':SET-BUFFERS-LIST BUFFERS
			':SET-TAG-TABLE-NAME (FORMAT NIL "Some buffers~@[ matching ~S~]"
						     APROPOS))))
  DIS-NONE)

(DEFCOM COM-SELECT-SOME-FILES-AS-TAG-TABLE
"Selects some files as a tag table.  Read successive pathnames from the mini-buffer." ()
  (LET ((FILES (LOOP AS DEFAULT = (PATHNAME-DEFAULTS) THEN PATHNAME
		     AND FIRST-P = T THEN NIL
		     AS PATHNAME = (ACCEPT-DEFAULTED-PATHNAME "File(s) in tag table" DEFAULT)
		     UNTIL (AND (NOT FIRST-P) (EQ PATHNAME DEFAULT))
		     COLLECT PATHNAME)))
    (SELECT-TAG-TABLE ':FILES-TAG-TABLE
		      ':SET-FILES-LIST FILES
		      ':SET-TAG-TABLE-NAME "Some files"))
  DIS-NONE)

(DEFUN SELECT-FILE-LIST-AS-TAG-TABLE (FILES-LIST NAME)
  (SELECT-TAG-TABLE ':FILES-TAG-TABLE
		    ':SET-FILES-LIST FILES-LIST
		    ':SET-TAG-TABLE-NAME NAME))

(DEFUN SELECT-TAG-TABLE-USER (TYPE &REST OPTIONS)
  (PROG1 (LET ((TAG-TABLE (SELECT-TAG-TABLE NIL)))
	   (LEXPR-FUNCALL #'PUSH-POSSIBILITIES-BUFFER ':START-EDITING TYPE
			  ':SET-TAG-TABLE-BUFFER TAG-TABLE OPTIONS))
	 (SETQ *ZMACS-TAG-TABLE-USER* (CAR *ZMACS-POSSIBILITIES-BUFFERS*))))

;;; Assure that we have only one tags table to worry about
(DEFUN SELECT-TAG-TABLE (TYPE &REST SET-OPTIONS &AUX ALIST)
  (COND ((NOT (MEMQ TYPE '(T NIL)))
	 (SETQ *ZMACS-TAG-TABLE-BUFFER* (LEXPR-SEND *CURRENT-COMMAND-LOOP*
						    ':FIND-SPECIAL-BUFFER TYPE T
						    SET-OPTIONS)))
	((NULL (SETQ ALIST (LOOP FOR BUFFER IN *ZMACS-BUFFER-LIST*
				 WHEN (TYPEP BUFFER 'TAG-TABLE-SPECIAL-PURPOSE-BUFFER)
				 COLLECT (CONS (SEND BUFFER ':TAG-TABLE-NAME) BUFFER))))
	 (SELECTQ (FQUERY `(:CHOICES (((:FILE "File") #/F)
				      ((:ALL-BUFFERS "All Buffers") #/B)
				      ((:SYSTEM "System") #/S)))
			    "Specify tag table how? ")
	   (:FILE
	    (LET ((PATHNAME (ACCEPT-DEFAULTED-PATHNAME "Tag table" (PATHNAME-DEFAULTS)
						       :SPECIAL-TYPE :TAGS)))
	      (SELECT-TAG-TABLE ':FILE-TAG-TABLE ':SET-PATHNAME PATHNAME)))
	   (:ALL-BUFFERS
	    (SELECT-ALL-BUFFERS-AS-TAG-TABLE))
	   (:SYSTEM
	    (SELECT-SYSTEM-AS-TAG-TABLE T))))	;has to be one or the other.
	((AND (EQ TYPE 'NIL) (RASSQ *ZMACS-TAG-TABLE-BUFFER* ALIST))
	 *ZMACS-TAG-TABLE-BUFFER*)
	((AND (EQ TYPE 'NIL) (NULL (CDR ALIST)))
	 (SETQ *ZMACS-TAG-TABLE-BUFFER* (CDAR ALIST)))
	(T
	 (SETQ *ZMACS-TAG-TABLE-BUFFER*
	       (TYPEIN-LINE-ACCEPT `((DW:MENU-CHOOSE :ALIST ,ALIST) :DESCRIPTION "tag table")
				   :DEFAULT (AND *ZMACS-TAG-TABLE-BUFFER*
						 (SEND *ZMACS-TAG-TABLE-BUFFER*
						       :TAG-TABLE-NAME))
				   :PROMPT "Tag table")))))

(DEFCOM COM-MULTIPLE-QUERY-REPLACE-FROM-BUFFER
	"Performs a multiple query replace from the contents of the specified buffer." ()
  (WITH-BOUNDED-INTERVAL (REGION-P)
    (LET-IF (AND *NUMERIC-ARG-P* (MINUSP *NUMERIC-ARG*))
	    ((*MODE-WORD-SYNTAX-TABLE* *ATOM-WORD-SYNTAX-TABLE*))
      (MULTIPLE-VALUE-BIND (FROM-LIST TO-LIST)
	  (PARSE-BUFFER-REPLACE-PAIRS ':OTHER)
	(QUERY-REPLACE-LIST (POINT) FROM-LIST TO-LIST *NUMERIC-ARG-P*)
	(TYPEIN-LINE "Query replace done.")
	DIS-TEXT))))

;;; Return two lists from a given buffer
(DEFUN PARSE-BUFFER-REPLACE-PAIRS (DEFAULT)
  (LET ((*INTERVAL* (READ-BUFFER-NAME "Use replacements in buffer" DEFAULT))
	(WHITESPACE-CHARS *WHITESPACE-CHARS*)
	(BLANKS *BLANKS*))
    (DO ((BP (INTERVAL-FIRST-BP *INTERVAL*))
	 (END-BP (INTERVAL-LAST-BP *INTERVAL*))
	 (FROM-LIST) (TO-LIST) (TEM))
	(NIL)
      (SETQ BP (FORWARD-OVER WHITESPACE-CHARS BP))
      (AND (BP-= BP END-BP) (RETURN (VALUES (NREVERSE FROM-LIST) (NREVERSE TO-LIST))))
      (IF (CHAR-EQUAL (BP-CHAR BP) #/;)
	  (SETQ BP (BEG-LINE BP 1))
	  (MULTIPLE-VALUE (TEM BP)
	    (PARSE-BUFFER-REPLACE-PAIRS-1 BP))
	  (PUSH TEM FROM-LIST)
	  (SETQ BP (FORWARD-OVER BLANKS BP))
	  (AND (END-LINE-P BP) (BARF "Only one item on line ~S" (BP-LINE BP)))
	  (MULTIPLE-VALUE (TEM BP)
	    (PARSE-BUFFER-REPLACE-PAIRS-1 BP))
	  (PUSH TEM TO-LIST)))))

(DEFUN PARSE-BUFFER-REPLACE-PAIRS-1 (BP &AUX BP1 STR)
  (UNLESS (SETQ BP1 (FORWARD-SEXP BP))
    (BARF "Premature eof on line ~S" (BP-LINE BP)))
  (SETQ STR (STRING-INTERVAL BP BP1 T))
  (WHEN (CHAR-EQUAL (AREF STR 0) #/")
    (SETQ STR (LET ((SI:*SUPPRESS-READ-EVAL* T))
		(READ-FROM-STRING STR))))
  (VALUES STR BP1))
