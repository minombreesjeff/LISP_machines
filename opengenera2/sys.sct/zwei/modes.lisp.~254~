;;; -*- Syntax: Zetalisp; Mode: LISP; Package: ZWEI; Base: 8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Functions to implement major and minor modes.

;;; Two specials, bound at every ZWEI invocation, are used to keep track
;;; of modes.  *MODE-LIST* is a list, each of whose elements speaks of a
;;; mode that is in effect.  The most recent mode entered is at the head
;;; of the list, and the least recent at the end.  Modes are turned on
;;; and off in a stack-like fashion, to prevent a bug in which keys end
;;; up redefined even after all modes are turned off.

;;; Each mode is an instance of a flavor.  There is only one such
;;; instance in the world.

;;; Messages to modes:
;;; :COMMAND-EXECUTE ()
;;;   used to invoke the command. [Do not redefine.]
;;; :MAJOR-MODE-P ()  BOOLEAN
;;;   T for major modes, NIL for minor modes.  [Do not redefine.]
;;; :MODE-FORMS ()  FORMS-LIST
;;;   forms for peforming key rebindings, etc.  [Must be present.]
;;; :EVALUATE-MODE-FORMS ()  UNDO-LIST.  [Do not redefine.]
;;; :EXECUTE-MODE-HOOK ()
;;;   called when mode turned on.  FUNCALL's LISP-MODE-HOOK, etc.  [Do not redefine.]
;;; :MODE-HOOK-VALUE ()  VALUE
;;;   value of MIDAS-MODE-HOOK, etc.  [Do not redefine.]
;;; :MODE-LINE-NAME ()  STRING
;;;   pretty (well-cased) version of name.  [Default for major modes in associated keyword.]
;;; :MODE-LINE-POSITION ()  NUMBER
;;;   position in ()'s in mode line.  [0 for major mode, required for minor modes.]

;;; Messages to major modes:
;;; :ADDITIONAL-ATTRIBUTES ()  LIST
;;;   each element of LIST is (INDICATOR NAME FORMAT-STRING), e.g. (:BASE "Base" "~D").
;;;   used for -*- line and by c-sh-C to bind attributes of the buffer over those of the
;;;   file.  [Default NIL]
;;; :ALL-UPPERCASE ()  BOOLEAN
;;;   modes like Lisp and Midas.  Used by case replace.  [Default NIL]
;;; :ATTRIBUTE-COMMENT-START ()  STRING  [Default based on *COMMENT-BEGIN*.]
;;; :ATTRIBUTE-COMMENT-END ()  STRING
;;;   used to delimit the -*- line.  [Default based on *COMMENT-END*.]
;;; :CHECK-PARENS-WHEN-SAVING ()  BOOLEAN
;;;   anded with user variable.  [Default NIL.]
;;; :COMPILER-FUNCTION ()  DEFSELECT
;;;   used by c-sh-C.  Value like #'COMPILER:COMPILE-TO-CORE.  [Default passed to LISP.]
;;; COMPILE-INTERVAL-1 (COMPILE-P BUFFER GENERIC-PATHNAME COMPILER-FUNCTION ADDITIONAL-BINDINGS
;;;				  BP1 &OPTIONAL BP2 IN-ORDER-P)
;;;   See the definition of COMPILE-INTERVAL in SYS:ZWEI;COMC for details.
;;;   The use of this method allows major/minor mode combinations (e.g., Minima) to use a
;;;   special purpose compiler/evaluator.  This method kicks in at a higher level than
;;;   :COMPILER-FUNCTION/:EVAL-PRINT-FUNCTION to allow greater flexibility when needed.
;;;   [Default calls DEFAULT-COMPILE-INTERVAL-1 which uses the :COMPILER-FUNCTION and
;;;   :EVAL-PRINT-FUNCTION methods.]
;;; :COMPILE-TO-FILE-FUNCTION ()  FUNCTION or NIL
;;;   If non-nil value returned, is a FUNCTION (INPUT-PATH &OPTIONAL OUTPUT-PATH)  OBJECT
;;;   where OBJECT is the pathname on which the object was created.
;;;   The compile-to-file function for this mode: for lisp, compiler:compile-file.
;;;   [Default NIL.]
;;; :COMPILATION-SUPPORTED ()  BOOLEAN
;;;   non-nil if the notion of compilation makes sense for this mode.
;;;   [Default NIL].
;;; :DEFAULT-COMPILER-OBJECT-FILE-TYPE ()  One of the canonical types for an object file
;;;   For lisp, SI:*DEFAULT-BINARY-FILE-TYPE*.  [Default NIL.]
;;; :DEFAULT-SOURCE-FILE-TYPE ()  The canonical type for an source file
;;;   For lisp, :LISP  [Default NIL.]
;;; :DEFINITION-INTERVAL (BP &OPTIONAL COMMENTS-P PKG)  INTERVAL NAME ERROR-P
;;;   ERROR-P is string or NIL.  If NIL, INTERVAL delimits area named NAMED around BP.
;;;   used by c-sh-C.  [Default passed to LISP.]
;;; :LOAD-FILE-FUNCTION ()  FUNCTION
;;;   Invoked by m-X Load File and friends with one argument, the file to be loaded.
;;;   [Default passed to LISP.]
;;; :EVAL-PRINT-FUNCTION ()  FUNCTION
;;;   argument to function is form to evaluation.  E.g. #'EVAL-PRINT.
;;;   [Default passed to LISP.]
;;; :EVALUATION-SUPPORTED ()  BOOLEAN
;;;   non-nil if the notion of evaluation (as distinct from compilation) makes sense
;;;   for this mode. [Default NIL].
;;; :FIND-COMMENT-START (LINE &OPTIONAL BEGIN-ALSO)  COMMENT-START-START COMMENT-START-END
;;;   return range of comment start in LINE.  [Default based on *COMMENT-START*.]
;;; :INITIAL-SECTIONIZATION-STATE ()  anything
;;;   For those modes which require some state for efficient line-by-line sectionization,
;;;   this is the state structure.  For nested block-structured kinds of languages, this
;;;   could be quite complicated, and this message is provided so that the state can be
;;;   consed only once during sectionization.  [Default NIL.]
;;; :MAJOR-MODE-KEYWORD ()  KEYWORD
;;;   e.g. :MIDAS.  [Supplied in DEFMODE form.]
;;; :MATCHING-CHAR-TO-BLINK (BP LIMIT-BP)  MATCHING-BP
;;;   Return the patching open delimiter for close delimiter near BP within LIMIT-BP.
;;;   [Default none.]
;;; :MOUSE-MARK-THING (POINT MARK CHAR LINE CHAR-POS)
;;;   For mouse-m-1.  [Default somewhat like text.]
;;; :NON-LISP-SYNTAX (BP)  BOOLEAN
;;;   For whitespace canonicalizer.  [Default T]
;;; :QUICK-DEFINITION-LINE-P (LINE)  BOOLEAN
;;;   T if line could be a definition line.  Used by M-X Print Modifications.  OK for this
;;;   to return T too often.  [Default NIL]
;;; :RELEVANT-FUNCTION-NAME (BP)  FUNCTION
;;;   For M-. default, c-sh-A, etc.  [Default passed to LISP.]
;;; :SECTION-NAME (BP TEMP-BP-TO-USE STATE)
;;;   FUNCTION-SPEC DEFINITION-TYPE NAME-OF-FUNCTION ERROR-P NEW-STATE
;;;   For sectionization.  STATE and NEW-STATE can be anything and is
;;;   :INITIAL-SECTIONIZATION-STATE initially.
;;;   [Default NIL]
;;; :SECTION-NAME-TRIVIAL-P ()  BOOLEAN
;;;   T if :SECTION-NAME always returns ERROR-P, sections not being meaningful.
;;;   [Default T]

;;; Messages to minor modes:

;;; The macro DEFMODE is used to associate the single instance of a
;;; flavor with a mode and to make it available as a command.

;;; The macros DEFMAJOR and DEFMINOR can be used to define simple modes
;;; in just one form.


;;; Base flavors
(DEFFLAVOR MODE
	(HOOK-SYMBOL
	 MODE-FORMS
	 (USER-MODE-FORMS NIL))
	()
  (:SETTABLE-INSTANCE-VARIABLES USER-MODE-FORMS)
  (:REQUIRED-METHODS :MODE-FORMS :MODE-LINE-NAME)
  (:METHOD-COMBINATION :MODE-FORMS :APPEND))

(DEFMETHOD (:INIT MODE) (IGNORE)
  (SETQ HOOK-SYMBOL (INTERN (STRING-APPEND (TYPEP SELF) "-HOOK") *EDITOR-PACKAGE*))
  ;; Make this hook-symbol be declared special
  (CL:PROCLAIM `(SPECIAL ,HOOK-SYMBOL))
  ;; and give it some reasonable documentation
  (SETF (CL:DOCUMENTATION HOOK-SYMBOL 'DEFVAR)
	(FORMAT NIL "The mode hook for ~A.  If this is unbound
or NIL, there is no hook function.  SETQ this to a function of no
arguments or a list of functions of no arguments to be run whenever
~:*~A is set up."
		(SCL:STRING-CAPITALIZE-WORDS (CL:TYPE-OF SELF))))
  ;; Give it a value so people can do PUSH onto it.
  (UNLESS (BOUNDP HOOK-SYMBOL)
    (SET HOOK-SYMBOL NIL))
  )

;;; This is a list of all modes.
(DEFVAR *MODES* NIL)

(DEFGENERIC ADD-MODE-HOOK (HOOK MODE)
  (:FUNCTION
    (CL:ETYPECASE MODE
      (MODE)
      (CL:KEYWORD
	(SETQ MODE (MAJOR-MODE-FROM-KEYWORD MODE)))
      (SYMBOL
	(SETQ MODE
	      (LOOP FOR M IN *MODES*
		    WHEN (EQ MODE (CL:TYPE-OF M))
		      RETURN M))))
    (FUNCALL (FLAVOR:GENERIC ADD-MODE-HOOK) MODE HOOK)))

(DEFMETHOD (ADD-MODE-HOOK MODE) (HOOK)
  (COND ((NOT (BOUNDP HOOK-SYMBOL))
	 (SET HOOK-SYMBOL (LIST HOOK)))
	((AND (SYMEVAL HOOK-SYMBOL)
	      (OR (ATOM (SYMEVAL HOOK-SYMBOL))
		  (FUNCTIONP (SYMEVAL HOOK-SYMBOL))))
	 (SET HOOK-SYMBOL (LIST HOOK (SYMEVAL HOOK-SYMBOL))))
	(T (CL:PUSHNEW HOOK (SYMEVAL HOOK-SYMBOL) :LOCALIZE T))))

(DEFMETHOD (:EVALUATE-MODE-FORMS MODE) ()
  (LET ((FORMS (IF USER-MODE-FORMS
		   (APPEND (SEND SELF ':MODE-FORMS) USER-MODE-FORMS)
		   (SEND SELF ':MODE-FORMS))))
    (EVALUATE-FORMING-UNDO-LIST FORMS SELF)))

(DEFMETHOD (:MODE-FORMS MODE :DEFAULT) () NIL)

(DEFMETHOD (:MODE-HOOK-VALUE MODE) ()
  (AND (BOUNDP HOOK-SYMBOL)
       (SYMEVAL HOOK-SYMBOL)))

(DEFMETHOD (:EXECUTE-MODE-HOOK MODE) (&AUX FUN)
  (AND (BOUNDP HOOK-SYMBOL)
       (SETQ FUN (SYMEVAL HOOK-SYMBOL))
       (IF (CL:FUNCTIONP FUN) (FUNCALL FUN)
	   (DOLIST (F FUN) (FUNCALL F)))))

(DEFWRAPPER (:MODE-FORMS MODE) (IGNORE . BODY)
  `(IF (VARIABLE-BOUNDP MODE-FORMS)
       MODE-FORMS
       (SETQ MODE-FORMS (PROGN . ,BODY))))

(DEFMETHOD (:CLEAR-MODE-FORMS-CACHE MODE) ()
  (VARIABLE-MAKUNBOUND MODE-FORMS))

(DEFUN ADD-MODE (FLAVOR)
  (LET ((OLD (MODE-OF-FLAVOR FLAVOR T)))
    (IF (NULL OLD)
	(PUSH (MAKE-INSTANCE FLAVOR) *MODES*)
      (SEND OLD ':CLEAR-MODE-FORMS-CACHE))))

(DEFUN MODE-OF-FLAVOR (FLAVOR &OPTIONAL NO-ERROR-P)
  (LOOP FOR MODE IN *MODES*
	WHEN (EQ (SI:FLAVOR-NAME (SYS:%INSTANCE-FLAVOR MODE)) FLAVOR)
	  RETURN MODE
	FINALLY (UNLESS NO-ERROR-P
		  (FERROR "~S is not a mode flavor." FLAVOR))))

;;; An alist of major mode keywords (e.g. :LISP) and instances.
(DEFVAR *MAJOR-MODE-ALIST* NIL)

(DEFUN ADD-MAJOR-MODE (MODE-FLAVOR MAJOR-MODE-KEYWORD)
  (SETQ *MAJOR-MODE-ALIST* (DELQ (ASSQ MAJOR-MODE-KEYWORD *MAJOR-MODE-ALIST*)
				 *MAJOR-MODE-ALIST*))
  (PUSH (CONS MAJOR-MODE-KEYWORD (MODE-OF-FLAVOR MODE-FLAVOR))
	*MAJOR-MODE-ALIST*))

(DEFUN MAJOR-MODE-FROM-KEYWORD (MAJOR-MODE-KEYWORD &OPTIONAL NO-ERROR-P)
  (IF (TYPEP MAJOR-MODE-KEYWORD 'MAJOR-MODE) MAJOR-MODE-KEYWORD
      (COND ((CDR (ASSQ MAJOR-MODE-KEYWORD *MAJOR-MODE-ALIST*)))
	    (T
	     (SELECTQ NO-ERROR-P
	       (NIL
		(UNLESS *ZMACS-FORCE-FUNDAMENTAL-MODE*
		  (CL:CERROR "Use :FUNDAMENTAL mode instead"
			     "~S is not the name of a major mode." MAJOR-MODE-KEYWORD)
		  (MAJOR-MODE-FROM-KEYWORD :FUNDAMENTAL)))
	       (:SILENT)			;for the bin loader
	       (OTHERWISE
		(UNLESS *ZMACS-FORCE-FUNDAMENTAL-MODE*
		  (TYPEIN-LINE "Warning: ~S is not the name of a major mode."
			       MAJOR-MODE-KEYWORD))))
	     NIL))))

;;; find the major-mode-keyword implied by the canonical-type of a pathname, or else return
;;; the *default-major-mode*
(DEFUN MAJOR-MODE-KEYWORD-FROM-PATHNAME (PATHNAME)
  (MAJOR-MODE-KEYWORD-FROM-CANONICAL-TYPE (SEND PATHNAME ':CANONICAL-TYPE)))

(DEFUN MAJOR-MODE-FROM-PATHNAME (PATHNAME)
  (MAJOR-MODE-FROM-KEYWORD (MAJOR-MODE-KEYWORD-FROM-PATHNAME PATHNAME)))

;;; given a canonical type, find the major mode implied by it, else return the
;;; *default-major-mode*
(DEFUN MAJOR-MODE-KEYWORD-FROM-CANONICAL-TYPE (CANONICAL-TYPE)
  (OR (CDR (ASSQ CANONICAL-TYPE FS:*FILE-TYPE-MODE-ALIST*))
      *DEFAULT-MAJOR-MODE*))

(DEFUN MAJOR-MODE-FROM-CANONICAL-TYPE (CANONICAL-TYPE)
  (MAJOR-MODE-FROM-KEYWORD (MAJOR-MODE-KEYWORD-FROM-CANONICAL-TYPE CANONICAL-TYPE)))

;;; Given a major mode keyword, find the first canonical type which implies that mode
(DEFUN CANONICAL-TYPE-FROM-MAJOR-MODE-KEYWORD (MAJOR-MODE-KEYWORD)
  (OR (CAR (RASSQ MAJOR-MODE-KEYWORD FS:*FILE-TYPE-MODE-ALIST*)) ':LISP))

(DEFUN CANONICAL-TYPE-FROM-MAJOR-MODE (MAJOR-MODE)
  (CANONICAL-TYPE-FROM-MAJOR-MODE-KEYWORD (SEND MAJOR-MODE ':MAJOR-MODE-KEYWORD)))

(DEFPROP DEFMODE DEFUN DEFINITION-FUNCTION-SPEC-TYPE)
(DEFMACRO DEFMODE (COMMAND-NAME MODE-FLAVOR DOCUMENTATION &OPTIONAL MAJOR-MODE-KEYWORD)
  `(PROGN
     (ADD-MODE ',MODE-FLAVOR)
     ,@(AND MAJOR-MODE-KEYWORD
	`((DEFMETHOD (:MAJOR-MODE-KEYWORD ,MODE-FLAVOR) () ',MAJOR-MODE-KEYWORD)
	  (ADD-MAJOR-MODE ',MODE-FLAVOR ',MAJOR-MODE-KEYWORD)))
     ,@(AND COMMAND-NAME
	    `((DEFCOM ,COMMAND-NAME ,DOCUMENTATION ()
		(SEND (MODE-OF-FLAVOR ',MODE-FLAVOR) ':COMMAND-EXECUTE)
		DIS-TEXT)))
     (COMPILE-FLAVOR-METHODS ,MODE-FLAVOR)))

(DEFPROP DEFMAJOR DEFUN DEFINITION-FUNCTION-SPEC-TYPE)
(DEFMACRO DEFMAJOR (COMMAND-NAME MODE-FLAVOR MODE-NAME
		    COMMAND-DOCUMENTATION IGNORE &BODY BODY)
  `(PROGN
     (DEFFLAVOR ,MODE-FLAVOR () (MAJOR-MODE))
     (DEFMETHOD (:MODE-LINE-NAME ,MODE-FLAVOR) () ',MODE-NAME)
     (DEFMETHOD (:MODE-FORMS ,MODE-FLAVOR) () ',(COPYLIST BODY))
     (DEFMODE ,COMMAND-NAME ,MODE-FLAVOR ,COMMAND-DOCUMENTATION
	      ,(INTERN (STRING-UPCASE MODE-NAME) SI:PKG-KEYWORD-PACKAGE))))

(DEFPROP DEFMINOR DEFUN DEFINITION-FUNCTION-SPEC-TYPE)
(DEFMACRO DEFMINOR (COMMAND-NAME MODE-FLAVOR MODE-NAME MODE-LINE-POSITION
		    COMMAND-DOCUMENTATION IGNORE &BODY BODY)
  `(PROGN
     (DEFFLAVOR ,MODE-FLAVOR ((MODE-LINE-POSITION ,MODE-LINE-POSITION)) (MINOR-MODE))
     (DEFMETHOD (:MODE-LINE-NAME ,MODE-FLAVOR) ()
       ,(IF (EQUAL MODE-NAME "") 'NIL (STRING-APPEND #\SP MODE-NAME)))
     (DEFMETHOD (:MODE-FORMS ,MODE-FLAVOR) () ',(COPYLIST BODY))
     (DEFMODE ,COMMAND-NAME ,MODE-FLAVOR ,COMMAND-DOCUMENTATION)))

(DEFUN VARIABLE-VALUE (VARIABLE-NAME &AUX VALUE BOUND-P)
  (COND ((AND (VARIABLE-BOUNDP *INTERVAL*)
	      *INTERVAL*			;global value is NIL
	      (PROGN (MULTIPLE-VALUE (VALUE BOUND-P)
		       (SEND *INTERVAL* :SEND-IF-HANDLES :VARIABLE-VALUE VARIABLE-NAME))
		     BOUND-P))
	 (VALUES VALUE :BUFFER))
	((AND (VARIABLE-BOUNDP *INTERVAL*)
	      *INTERVAL*			;Better safe than sorry.
	      (SEND *INTERVAL* :MAJOR-MODE)
	      (PROGN (MULTIPLE-VALUE (VALUE BOUND-P)
		       (SEND (SEND *INTERVAL* :MAJOR-MODE) :VARIABLE-VALUE VARIABLE-NAME))
		     BOUND-P))
	 (VALUES VALUE :MODE))
	(T
	 (VALUES (IF (BOUNDP VARIABLE-NAME)
		     (SYMEVAL VARIABLE-NAME)
		     (CL:GETF (PLIST VARIABLE-NAME) 'VARIABLE-INIT))
		 :GLOBAL)))) 

(DEFUN SET-VARIABLE-VALUE (VARIABLE-NAME VALUE &OPTIONAL WHERE SET-FN)
  (WHEN (OR (NULL WHERE)
            (EQ WHERE ':ASK))
    (LET (PROMPT CHOICES)
      (COND ((AND (VARIABLE-BOUNDP *INTERVAL*) *INTERVAL*
		  (SEND-IF-HANDLES *INTERVAL*
				   ':VARIABLE-BOUNDP VARIABLE-NAME))
	     (SETQ WHERE ':BUFFER))
	    ((AND (VARIABLE-BOUNDP *INTERVAL*) *INTERVAL* (SEND *INTERVAL* :MAJOR-MODE)
		  (SEND-IF-HANDLES (SEND *INTERVAL* :MAJOR-MODE)
				   ':VARIABLE-BOUNDP VARIABLE-NAME))
	     (IF (NULL WHERE)
		 (SETQ WHERE ':MODE)
		 (SETQ PROMPT "Set ~A in Buffer~@[ (~A)~] or Mode (~A)? "
		       CHOICES '(:CHOICES (((:BUFFER "Current buffer") #/B)
					   ((:MODE "Major mode") #/M))))))
	    (T
	     (IF (NULL WHERE)
		 (SETQ WHERE ':GLOBAL)
		 (SETQ PROMPT "Set ~A in Buffer~@[ (~A)~], Mode (~A), or globally? "
		       CHOICES '(:CHOICES (((:BUFFER "Current buffer") #/B)
					   ((:MODE "Major mode") #/M)
					   ((:GLOBAL "Globally") #/G)))))))
      (AND (EQ WHERE ':ASK)
	   (LET ((BUFFER-NAME (SEND-IF-HANDLES *INTERVAL* ':NAME)))
	     (SETQ WHERE (FQUERY CHOICES PROMPT
				 (GET VARIABLE-NAME 'VARIABLE-NAME) BUFFER-NAME
				 (SEND (SEND *INTERVAL* :MAJOR-MODE) ':MODE-LINE-NAME)))))))
  (SELECTQ WHERE
    (:BUFFER (SEND-IF-HANDLES *INTERVAL*
			      ':SET-VARIABLE-VALUE VARIABLE-NAME VALUE))
    (:MODE (SEND-IF-HANDLES (SEND *INTERVAL* :MAJOR-MODE)
			    ':SET-VARIABLE-VALUE VARIABLE-NAME VALUE))
    (OTHERWISE (IF SET-FN (CL:APPLY SET-FN (LIST VARIABLE-NAME VALUE))
		 (SET VARIABLE-NAME VALUE))))
  WHERE) 

(DEFUN (ZWEI:SET-VARIABLE-VALUE :UNDO-FUNCTION) (FORM)
  (DESTRUCTURING-BIND (NAME IGNORE &OPTIONAL WHERE IGNORE)
      (CDR FORM)
    (SETQ NAME (EVAL NAME) WHERE (EVAL WHERE))
    (FLET ((MAKE-GLOBAL-UNDO ()
	     (IF (BOUNDP NAME)
		 `(SETF (SYMEVAL ',NAME) ',(SYMEVAL NAME))
		 `(MAKUNBOUND ',NAME)))
	   (MAKE-BUFFER-UNDO ()
	     (LET (VALUE BOUND-P)
	       (WHEN (AND (VARIABLE-BOUNDP *INTERVAL*)
			  *INTERVAL*)
		 (IF (PROGN (CL:MULTIPLE-VALUE-SETQ (VALUE BOUND-P)
			      (SEND-IF-HANDLES *INTERVAL* :VARIABLE-VALUE NAME))
			    BOUND-P)
		     `(SEND-IF-HANDLES ',*INTERVAL* :SET-VARIABLE-VALUE    ',NAME ',VALUE)
		     `(SEND-IF-HANDLES ',*INTERVAL* :REMOVE-VARIABLE-VALUE ',NAME)))))
	   (MAKE-MODE-UNDO ()
	     (LET (VALUE BOUND-P MODE)
	       (WHEN (AND (VARIABLE-BOUNDP *INTERVAL*)
			  *INTERVAL*
			  (SETQ MODE (SEND *INTERVAL* :MAJOR-MODE)))
		 (IF (PROGN (CL:MULTIPLE-VALUE-SETQ (VALUE BOUND-P)
			      (SEND-IF-HANDLES MODE :VARIABLE-VALUE NAME))
			    BOUND-P)
		     `(SEND-IF-HANDLES ',MODE :SET-VARIABLE-VALUE    ',NAME ',VALUE)
		     `(SEND-IF-HANDLES ',MODE :REMOVE-VARIABLE-VALUE ',NAME))))))
      (CL:CASE WHERE
	((:GLOBAL) (MAKE-GLOBAL-UNDO))
	((:BUFFER) (MAKE-BUFFER-UNDO))
	((:MODE)   (MAKE-MODE-UNDO))
	(OTHERWISE
	  (LET ((FORMS (CL:REMOVE NIL (LIST (MAKE-BUFFER-UNDO)
					    (MAKE-MODE-UNDO)
					    (MAKE-GLOBAL-UNDO)))))
	    (IF (CDR FORMS) `(PROGN ,@FORMS) (CAR FORMS))))))))

(DEFUN SET-A-VARIABLE-VALUE (VARIABLE-NAME VALUE &OPTIONAL WHERE (SET-FN NIL SET-FN-FURNISHED))
  (IF (AND (NULL SET-FN-FURNISHED)
	   (CL:RASSOC VARIABLE-NAME *VARIABLE-ALIST*))
      ;; use SET-ZWEI-VARIABLE for these variables, to get arg checking on the value;
      ;; SET-ZWEI-VARIABLE eventually calls SET-VARIABLE-VALUE.
      (SET-ZWEI-VARIABLE VARIABLE-NAME VALUE :WHERE WHERE)
    (SET-VARIABLE-VALUE VARIABLE-NAME VALUE WHERE SET-FN)))

(CL:DEFSETF VARIABLE-VALUE SET-A-VARIABLE-VALUE)

(DEFMETHOD (:VARIABLE-VALUE LOCAL-VARIABLE-MIXIN) (VARIABLE-NAME)
  (LET ((ELEM (ASSQ VARIABLE-NAME VARIABLE-VALUES)))
    (IF (NULL ELEM)
	(VALUES NIL NIL)
	(VALUES (CDR ELEM) T))))

(DEFMETHOD (:SET-VARIABLE-VALUE LOCAL-VARIABLE-MIXIN) (VARIABLE-NAME VALUE)
  (LET ((ELEM (ASSQ VARIABLE-NAME VARIABLE-VALUES)))
    (IF (NULL ELEM)
	(PUSH (CONS VARIABLE-NAME VALUE) VARIABLE-VALUES)
	(SETF (CDR ELEM) VALUE))))

(DEFMETHOD (:REMOVE-VARIABLE-VALUE LOCAL-VARIABLE-MIXIN) (VARIABLE-NAME)
  (LET ((ELEM (ASSQ VARIABLE-NAME VARIABLE-VALUES)))
    (AND ELEM (SETQ VARIABLE-VALUES (DELQ ELEM VARIABLE-VALUES)))))

(DEFMETHOD (:VARIABLE-BOUNDP LOCAL-VARIABLE-MIXIN) (VARIABLE-NAME)
  (NOT (NULL (ASSQ VARIABLE-NAME VARIABLE-VALUES))))


;;;; Support functions

;;; Turn off the mode.  If it is not on, do nothing.
(DEFUN TURN-OFF-MODE (MODE)
  (SYS:WITHOUT-ABORTS ("Turning off modes")
    (WHEN (SYMBOLP MODE)
      (SETQ MODE (MODE-OF-FLAVOR MODE)))
    (LET ((MODE-ELEMENT (ASSQ MODE *MODE-LIST*)))
      (UNLESS (NULL MODE-ELEMENT)
	;; We must first turn off all more-recently added modes,
	;; then turn off this mode, and then turn the more-recently added
	;; modes on in reverse order.  To accomplish the last, backward step
	;; more elegantly, we use a recursive subfunction.
	(TURN-OFF-MODE-UNDERSCORE *MODE-LIST* MODE-ELEMENT)))
    (SETQ *MODE-NAME-LIST* (DELQ MODE *MODE-NAME-LIST*))))

;;; Internal recursive subfunction of TURN-OFF-MODE.
(DEFUN TURN-OFF-MODE-UNDERSCORE (LIST ELEMENT)
  (COND ((EQ (CAR LIST) ELEMENT)
	 (MAPC #'EVAL (SECOND ELEMENT))
	 (SETQ *MODE-LIST* (DELQ ELEMENT *MODE-LIST*)))
	(T
	 (MAPC #'EVAL (SECOND (CAR LIST)))
	 (TURN-OFF-MODE-UNDERSCORE (CDR LIST) ELEMENT)
	 (SETF (SECOND (CAR LIST)) (SEND (CAAR LIST) ':EVALUATE-MODE-FORMS)))))

;;; Turn on the mode.  If it is already on, do nothing.
(DEFUN TURN-ON-MODE (MODE)
  (SYS:WITHOUT-ABORTS ("Turning on modes")
    (WHEN (SYMBOLP MODE)
      (SETQ MODE (MODE-OF-FLAVOR MODE)))
    (UNLESS (ASSQ MODE *MODE-LIST*)
      (WHEN (SEND MODE ':MAJOR-MODE-P)
	(SETQ *MAJOR-MODE* MODE)		;:EVALUATE-MODE-FORMS may need this
	(SEND-IF-HANDLES *INTERVAL* ':PUTPROP MODE ':MAJOR-MODE))
      (PUSH (LIST MODE (SEND MODE ':EVALUATE-MODE-FORMS)) *MODE-LIST*))
    (UNLESS (MEMQ MODE *MODE-NAME-LIST*)
      (PUSH MODE *MODE-NAME-LIST*))
    (WHEN (SEND MODE ':MAJOR-MODE-P)
      (SETQ *MAJOR-MODE* MODE)			;Ensure this is set all the time
      (DOLIST (MINOR *INITIAL-MINOR-MODES*)	;Note: elements are flavor names
	(TURN-ON-MODE MINOR)))
    (SEND MODE ':EXECUTE-MODE-HOOK)
    (SETQ *MODE-NAME-LIST* (SORT *MODE-NAME-LIST* #'(LAMBDA (X Y)
						      (< (SEND X ':MODE-LINE-POSITION)
							 (SEND Y ':MODE-LINE-POSITION)))))))

;;; Take a list of forms, evaluate them, and produce a list of forms which,
;;; when evaluated, will undo the effects of the evaluatation of the original list.
;;; These forms are very restricted; they must be SETQ, ASET, SET-COMTAB,
;;; PUSH, SET-CHAR-SYNTAX, SET-SYNTAX-TABLE-INDIRECTION or COMMAND-HOOK forms.
;;; PROGN FORMS are accepted, but not undone.
;;; PROGN-LATER forms are themselves undo forms without do forms.
(DEFUN EVALUATE-FORMING-UNDO-LIST (FORM-LIST MODE)
  (LET ((RESULT NIL))
    (DOLIST (FORM FORM-LIST)
      (SELECTQ (CAR FORM)
	(SETQ
	 (PUSH (MODE-SET-VARIABLE (SECOND FORM) (EVAL (THIRD FORM)) MODE) RESULT))
	(ASET
	 (PUSH `(ASET ',(EVAL `(AREF . ,(CDDR FORM))) . ,(CDDR FORM)) RESULT)
	 (EVAL FORM))
	(SET-COMTAB
	 ;; Knowledge of how to reverse SET-COMTAB is kept in the COMTAB > file.
	 (PUSH (MAKE-SET-COMTAB-UNDO-LIST FORM) RESULT)
	 (EVAL FORM))
	(PUSH
	 (PUSH (MODE-SET-VARIABLE (THIRD FORM) (CONS (EVAL (SECOND FORM))
						     (VARIABLE-VALUE (THIRD FORM)))
				  MODE)
	       RESULT))
	(COMMAND-HOOK
	 (LET ((THING (EVAL (SECOND FORM))))
	   (PUSH `(SETF ,(THIRD FORM)
			(DELQ ',THING ,(THIRD FORM)))
		 RESULT)
	   (COMMAND-HOOK THING (THIRD FORM))))
	;; SET-SYNTAX-TABLE-INDIRECTION should appear before any SET-CHAR-SYNTAX
	;; in mode-forms
	(SET-SYNTAX-TABLE-INDIRECTION
	 (LET ((OF (SECOND FORM))
	       (TO (THIRD FORM)))
	   (PUSH `(SETQ ,OF ,(SYMEVAL OF)) RESULT)
	   (SET OF (SYMEVAL TO))))
	(SET-CHAR-SYNTAX
	 (LET ((SYNTAX-TABLE (SYMEVAL (THIRD FORM)))
	       (CHAR (FOURTH FORM)))
	   (PUSH `(SET-CHAR-SYNTAX ,(CHAR-SYNTAX CHAR SYNTAX-TABLE) ',SYNTAX-TABLE ,CHAR)
		 RESULT))
	 (EVAL FORM))
	(PROGN
	 (EVAL FORM))
	(PROGN-LATER
	 (PUSH `(PROGN ,@(CDR FORM)) RESULT))
	(OTHERWISE
	 (FERROR NIL "The form ~S cannot be used in a mode, because I can't invert it."
		 FORM))))
    RESULT))

(DEFUN MODE-SET-VARIABLE (VARIABLE-NAME VALUE MODE &AUX GLOBALLY)
  (MULTIPLE-VALUE-BIND (SYMBOL-MACRO-P EXPANSION)
      (LT:SYMBOL-MACRO-P VARIABLE-NAME)
    (WHEN (AND SYMBOL-MACRO-P
	       (NOT (EQ (FIRST EXPANSION) 'VARIABLE-VALUE)))
      (FERROR "Not allowed to set ~S in a mode form." VARIABLE-NAME)))
  (WHEN (GETL VARIABLE-NAME '(MODE-SETTABLE-P))
    (SETQ GLOBALLY T))
  (COND (GLOBALLY
	 (PROG1 `(SETQ ,VARIABLE-NAME ',(SYMEVAL VARIABLE-NAME))
		(SET VARIABLE-NAME VALUE)))
	((SEND MODE ':MAJOR-MODE-P)
	 ;; Major mode, setting does not need to be undone.
	 ;; Perhaps this should even be set if unbound?
	 (SEND MODE ':SET-VARIABLE-VALUE VARIABLE-NAME VALUE)
	 'NIL)
	(T
	 ;; Minor mode, set inside the current buffer
	 (MULTIPLE-VALUE-BIND (OLD-VALUE BOUND-P)
	     (SEND *INTERVAL* ':VARIABLE-VALUE VARIABLE-NAME)
	   (SEND *INTERVAL* ':SET-VARIABLE-VALUE VARIABLE-NAME VALUE)
	   (IF BOUND-P
	       `(SEND ',*INTERVAL* ':SET-VARIABLE-VALUE ',VARIABLE-NAME ',OLD-VALUE)
	       `(SEND ',*INTERVAL* ':REMOVE-VARIABLE-VALUE ',VARIABLE-NAME))))))

;;; Turn off all modes.  For ZMACS.
(DEFUN UN-SET-MODES ()
  (SYS:WITHOUT-ABORTS ("Un-setting modes")
    (DOLIST (L *MODE-LIST*)
      (MAPC #'EVAL (SECOND L)))
    (SETQ *MODE-NAME-LIST* NIL
	  *MODE-LIST* NIL)))

(DEFGENERIC EXECUTE-BUFFER-MODE-HOOK (BUFFER)
  (:METHOD (NODE) ()))

;;; Turn on a saved set of modes.  For ZMACS.
(DEFUN SET-MODES (MODE-LIST MAJOR-MODE)
  (SYS:WITHOUT-ABORTS ("Setting modes")
    (SET-MODES-UNDERSCORE MODE-LIST)
    (TURN-ON-MODE MAJOR-MODE)
    (EXECUTE-BUFFER-MODE-HOOK *INTERVAL*)))

(DEFUN SET-MODES-UNDERSCORE (LIST)
  (COND ((NULL LIST) NIL)
	(T
	 (SET-MODES-UNDERSCORE (CDR LIST))
	 (PUSH (LIST (CAAR LIST) (SEND (CAAR LIST) ':EVALUATE-MODE-FORMS))
	       *MODE-LIST*)
	 (SETQ *MODE-NAME-LIST* (NCONC *MODE-NAME-LIST* (NCONS (CAAR LIST)))))))

(DEFUN STICKY-MODE-LIST ()
  (AND (VARIABLE-BOUNDP *MODE-LIST*)			;Somewhat of a kludge
       (DO ((MODES *MODE-LIST* (CDR MODES))
	    (NMODES NIL))
	   ((NULL MODES)
	    (NREVERSE NMODES))
	 (AND (MEMQ (TYPEP (CAAR MODES)) *STICKY-MINOR-MODES*)	;Elements are symbols
	      (PUSH (CAR MODES) NMODES)))))

;;; This is called by each command loop once per login session, it turns on modes that
;;; the user always wants, such as EMACS compatibility.
(DEFUN TURN-ON-USER-MODES ()
  (COND ((NULL *USER-MODES-SET*)
	 (TURN-ON-MODE *MAJOR-MODE*)		;Maybe electric shift lock mode
	 (SETQ *USER-MODES-SET* T))))

(DEFUN TURN-ON-EMACS-MODE ()
  (OR (MEMQ 'EMACS-MODE *INITIAL-MINOR-MODES*)
      (LOGIN-SETQ *INITIAL-MINOR-MODES* (CONS 'EMACS-MODE *INITIAL-MINOR-MODES*))))

(DEFUN TURN-OFF-EMACS-MODE ()
  (LOGIN-SETQ *INITIAL-MINOR-MODES* (REMQ 'EMACS-MODE *INITIAL-MINOR-MODES*)))

;;;; Simple major modes
(DEFFLAVOR MAJOR-MODE () (MODE LOCAL-VARIABLE-MIXIN)
  :ABSTRACT-FLAVOR
  (:METHOD-COMBINATION :ADDITIONAL-ATTRIBUTES :APPEND
                       :GET-DEFAULT-ATTRIBUTE :CASE))

(DEFMETHOD (:MAJOR-MODE-P MAJOR-MODE) () T)

(DEFMETHOD (:MODE-LINE-NAME MAJOR-MODE) () (STRING (SEND SELF ':MAJOR-MODE-KEYWORD)))

(DEFUN NAME-OF-MAJOR-MODE ()
  (SEND (SEND *INTERVAL* :MAJOR-MODE) ':MODE-LINE-NAME))		

(DEFMETHOD (:MODE-LINE-POSITION MAJOR-MODE) () 0)

(DEFMETHOD (:ADDITIONAL-ATTRIBUTES MAJOR-MODE :DEFAULT) () NIL)

(DEFMETHOD (:GET-DEFAULT-ATTRIBUTE MAJOR-MODE :OTHERWISE) (IGNORE) NIL)

(DEFMETHOD (:DEFAULT-CHARACTER-STYLE MAJOR-MODE :DEFAULT) ()
  (SI:PARSE-CHARACTER-STYLE SI:*STANDARD-DEFAULT-CHARACTER-STYLE*))

(DEFMETHOD (MAJOR-MODE-DEFAULT-PACKAGE MAJOR-MODE :DEFAULT) ()
  (SEND SELF :VARIABLE-VALUE '*DEFAULT-PACKAGE*))



(DEFGENERIC MAJOR-MODE-DEFAULT-DEFAULT-PACKAGE (MAJOR-MODE)
  "This generic is applied when a major mode is instantiated.  If
it returns a second value of T, then the first value is interpreted as a package
name that should be established as the value of *default-package* local to the
mode.  If the second value is nil, then the mode establishes no local value,
and continues to use the global value of *default-package*."
  (DECLARE (VALUES PACKAGE-NAME PACKAGE-NAME-P))
  (:METHOD (MAJOR-MODE :DEFAULT)
   (VALUES NIL NIL))				;by default, modes share the
						;global (lisp) value.
  )
(DEFMETHOD (MAKE-INSTANCE MAJOR-MODE :AFTER)  (&REST IGNORE)
  (MULTIPLE-VALUE-BIND (DD-PACKAGE-NAME DD-PACKAGE-EXISTS)
      (MAJOR-MODE-DEFAULT-DEFAULT-PACKAGE SELF)
    (WHEN DD-PACKAGE-EXISTS
      (SEND SELF :SET-VARIABLE-VALUE
	    '*DEFAULT-PACKAGE* DD-PACKAGE-NAME))))

(DEFMETHOD (MAJOR-MODE-DEFAULT-PACKAGE-USE-LIST-FOR-BUFFER MAJOR-MODE :DEFAULT) (BUFFER)
  "Given a buffer, return the :USE list to offer when creating a package for that
buffer."
  (SI:LISP-SYNTAX-DEFAULT-PACKAGE-USE-LIST 
    (SI:FIND-LISP-SYNTAX (SEND BUFFER :GET :SYNTAX) NIL :COMMON-LISP)))

(DEFMETHOD (:COMMAND-EXECUTE MAJOR-MODE) ()
  (WHEN (SEND *INTERVAL* :MAJOR-MODE)
    (TURN-OFF-MODE (SEND *INTERVAL* :MAJOR-MODE)))
  (DOLIST (MODE *UNSTICKY-MINOR-MODES*)
    (TURN-OFF-MODE MODE))
  (TURN-ON-MODE SELF)
  (WHEN (CURRENT-ZMACS-BUFFER)			;NIL in ZMAIL and suchlike places.
						;but T for non-File buffers, which
						;is only reasonable.
    (SET-ATTRIBUTE-INTERNAL ':MODE "Mode"
			    (SEND SELF ':MODE-LINE-NAME) (SEND SELF ':MAJOR-MODE-KEYWORD)) 
    ;; Changing the major mode renders these invalid.
    (CLEAR-ALL-INTERVAL-PRESENTATION-NODES *INTERVAL*)))

(DEFMETHOD (LOCK-ENTIRE-BUFFER MAJOR-MODE) ()
  ;; By default, we lock on a node-by-node basis.
  NIL)

;;; Some defaults
(DEFMETHOD (:FIND-COMMENT-START MAJOR-MODE) (LINE &OPTIONAL BEGIN-ALSO
						  &AUX START-START-INDEX START-END-INDEX)
  (AND (OR *COMMENT-START* BEGIN-ALSO)
       (SETQ START-START-INDEX (STRING-SEARCH (OR *COMMENT-START* *COMMENT-BEGIN*)
					      LINE))
       (SETQ START-END-INDEX (+ START-START-INDEX
				(STRING-LENGTH (OR *COMMENT-START* *COMMENT-BEGIN*)))))
  (VALUES START-START-INDEX START-END-INDEX))

(DEFMETHOD (:USE-FAST-LINE-TYPE MAJOR-MODE) () NIL)

(DEFMETHOD (:COMMENT-STARTS-AT-INDEX-P MAJOR-MODE) (LINE INDEX)
  (LET ((IDX (SEND SELF :FIND-COMMENT-START LINE)))
    (AND IDX ( IDX INDEX))))

(DEFMETHOD (:ATTRIBUTE-COMMENT-START MAJOR-MODE) ()
  (AND *COMMENT-START* *COMMENT-BEGIN*))

(DEFMETHOD (:ATTRIBUTE-COMMENT-END MAJOR-MODE) ()
  (AND *COMMENT-START* *COMMENT-END*))

(DEFMETHOD (:MOUSE-MARK-THING MAJOR-MODE) (POINT MARK CHAR LINE CHAR-POS)
  (DEFAULT-MARK-THING POINT MARK CHAR LINE CHAR-POS))

(DEFMETHOD (:NON-LISP-SYNTAX MAJOR-MODE) (IGNORE) T)

(DEFMETHOD (:SECTION-NAME-TRIVIAL-P MAJOR-MODE) () T)

(DEFMETHOD (:SECTION-NAME MAJOR-MODE) (LINE TEMP-BP STATE)
  (DECLARE (VALUES FSPEC TYPE STR ERROR-P NEW-STATE))
  LINE TEMP-BP STATE
  (VALUES NIL NIL NIL T))

(DEFMETHOD (:OTHER-SECTION-NAME-COMPLETION MAJOR-MODE) (IGNORE IGNORE)
  NIL)

(DEFMETHOD (:CHECK-PARENS-WHEN-SAVING MAJOR-MODE) () NIL)

(DEFMETHOD (:ALL-UPPERCASE MAJOR-MODE) () NIL)

(DEFMETHOD (:QUICK-DEFINITION-LINE-P MAJOR-MODE) (IGNORE) NIL)

(DEFMETHOD (:AUTO-FILL-SUPPORTED-P MAJOR-MODE :DEFAULT) () T)

;; Default method to ignore mung line region activity
(DEFMETHOD (:MUNG-LINE MAJOR-MODE :DEFAULT) (IGNORE &OPTIONAL IGNORE) NIL)

;; Default method to ignore line token message
(DEFMETHOD (:CLEAR-LINE-TOKEN MAJOR-MODE :DEFAULT) (IGNORE) NIL)

(DEFMETHOD (:MODIFIED-SECTIONS MAJOR-MODE :DEFAULT) (BUFFER-FLAVOR BUFFER CRITERION-TICK)
  (COND ((NOT (NULL CRITERION-TICK))
	 (DOLIST (SECTION (BUFFER-SECTIONS BUFFER))
	   (AND (TYPEP SECTION 'SECTION-NODE)
		(> (NODE-TICK SECTION)
		   (IF (EQ CRITERION-TICK ':COMPILE)
		       (SECTION-NODE-COMPILE-TICK SECTION)
		     CRITERION-TICK))
		(NOT (NULL (SECTION-NODE-DEFINITION-LINE SECTION)))
		(SEND BUFFER-FLAVOR ':ADD-NODE
				    'SECTION-SUBNODE ':SECTION SECTION ':BUFFER BUFFER))))))

(DEFMETHOD (:MATCHING-CHAR-TO-BLINK MAJOR-MODE) (IGNORE IGNORE IGNORE) NIL)

;; The default sends :MATCHING-CHAR-TO-BLINK, and returns a BP and a size of 1
(DEFMETHOD (:MATCHING-INTERVAL-TO-BLINK MAJOR-MODE :DEFAULT) (POINT START-BP END-BP)
  (LET ((BP (SEND SELF ':MATCHING-CHAR-TO-BLINK POINT START-BP END-BP)))
    (WHEN BP
      (VALUES BP 1))))

;;; added by Stryker
(DEFMETHOD (:DEFAULT-SOURCE-FILE-TYPE MAJOR-MODE) () NIL)

;;; These allow compilation and evaluation from Text mode to be LISP like.
(DEFVAR *DEFAULT-LANGUAGE-MODE* ':LISP)

(DEFMETHOD (:RELEVANT-FUNCTION-NAME MAJOR-MODE) (&REST ARGS)
  (LEXPR-SEND (MAJOR-MODE-FROM-KEYWORD *DEFAULT-LANGUAGE-MODE*) ':RELEVANT-FUNCTION-NAME
	      ARGS))

(DEFMETHOD (:DEFINITION-INTERVAL MAJOR-MODE) (&REST ARGS)
  (LEXPR-SEND (MAJOR-MODE-FROM-KEYWORD *DEFAULT-LANGUAGE-MODE*) ':DEFINITION-INTERVAL
	      ARGS))

;;; Default for DEFINITION-REGION and related macros when there is no region
(DEFMETHOD (:DEFAULT-DEFINITION-REGION MAJOR-MODE) (&REST ARGS)
  (DECLARE (VALUES INTERVAL NAME))
  (LEXPR-SEND (MAJOR-MODE-FROM-KEYWORD *DEFAULT-LANGUAGE-MODE*) ':DEFAULT-DEFINITION-REGION
	      ARGS))

(DEFMETHOD (:DEFINITION-AROUND-BP MAJOR-MODE) (&REST ARGS)
  (LEXPR-SEND (MAJOR-MODE-FROM-KEYWORD *DEFAULT-LANGUAGE-MODE*) ':DEFINITION-AROUND-BP
	      ARGS))

(DEFMETHOD (COMPILE-INTERVAL-1 MAJOR-MODE :DEFAULT) (COMPILE-P BUFFER GENERIC-PATHNAME
						     COMPILER-FUNCTION ADDITIONAL-BINDINGS
						     BP1 &OPTIONAL BP2 IN-ORDER-P)
  (DEFAULT-COMPILE-INTERVAL-1 SELF COMPILE-P BUFFER GENERIC-PATHNAME COMPILER-FUNCTION
			      ADDITIONAL-BINDINGS BP1 BP2 IN-ORDER-P))

(DEFMETHOD (:COMPILER-FUNCTION MAJOR-MODE) ()
  (SEND (MAJOR-MODE-FROM-KEYWORD *DEFAULT-LANGUAGE-MODE*) ':COMPILER-FUNCTION))

(DEFMETHOD (:EVAL-PRINT-FUNCTION MAJOR-MODE) ()
  (SEND (MAJOR-MODE-FROM-KEYWORD *DEFAULT-LANGUAGE-MODE*) ':EVAL-PRINT-FUNCTION))

(DEFMETHOD (:COMPILATION-SUPPORTED MAJOR-MODE) ()
  (SEND (MAJOR-MODE-FROM-KEYWORD *DEFAULT-LANGUAGE-MODE*) ':COMPILATION-SUPPORTED))

(DEFMETHOD (:EVALUATION-SUPPORTED MAJOR-MODE) ()
  (SEND (MAJOR-MODE-FROM-KEYWORD *DEFAULT-LANGUAGE-MODE*) ':EVALUATION-SUPPORTED))

(DEFMETHOD (:INITIAL-SECTIONIZATION-STATE MAJOR-MODE) ()
  (SEND (MAJOR-MODE-FROM-KEYWORD *DEFAULT-LANGUAGE-MODE*) ':INITIAL-SECTIONIZATION-STATE))

(DEFMETHOD (:DEFAULT-COMPILER-OBJECT-FILE-TYPE MAJOR-MODE) ()
  (SEND (MAJOR-MODE-FROM-KEYWORD *DEFAULT-LANGUAGE-MODE*)
	':DEFAULT-COMPILER-OBJECT-FILE-TYPE))

(DEFMETHOD (:COMPILE-TO-FILE-FUNCTION MAJOR-MODE) ()
  (SEND (MAJOR-MODE-FROM-KEYWORD *DEFAULT-LANGUAGE-MODE*) ':COMPILE-TO-FILE-FUNCTION))

(DEFMETHOD (:LOAD-FILE-FUNCTION MAJOR-MODE) ()
  (SEND (MAJOR-MODE-FROM-KEYWORD *DEFAULT-LANGUAGE-MODE*) ':LOAD-FILE-FUNCTION))

(DEFMETHOD (:LOAD-BINARY-FILE MAJOR-MODE :DEFAULT) (IGNORE STREAM)
  (SI:BIN-LOAD-TOP-LEVEL STREAM))

(DEFMETHOD (DEFINITION-UNDEFINING-FORM MAJOR-MODE) (TYPE NAME)
  (DEFINITION-UNDEFINING-FORM (MAJOR-MODE-FROM-KEYWORD *DEFAULT-LANGUAGE-MODE*) TYPE NAME))

;;; These bindings should be established by anything that might try to
;;; do mode specific parsing when a buffer isn't current.
(DEFMETHOD (:PARSING-BINDINGS MAJOR-MODE) (BUFFER)
  BUFFER
  (VALUES NIL NIL))

(DEFMETHOD (SHOW-EFFECT-OF-DEFINITION MAJOR-MODE) ()
  (SHOW-EFFECT-OF-DEFINITION (MAJOR-MODE-FROM-KEYWORD *DEFAULT-LANGUAGE-MODE*)))

;;;; Support for setting breakpoints from Zmacs and the display debugger
(DEFMETHOD (:FIND-PC-FROM-LINE MAJOR-MODE) (IGNORE &OPTIONAL IGNORE)
  NIL)

;;;; Support for setting breakpoints from Zmacs and the display debugger
(DEFMETHOD (:DEBUGGING-INFO MAJOR-MODE) (IGNORE)
  (BARF (FORMAT
	  NIL
	  "The major mode ~A does not support setting breakpoints from within the editor."
		(SEND SELF :MAJOR-MODE-KEYWORD))))

(COMPILE-FLAVOR-METHODS MAJOR-MODE)


(DEFMAJOR COM-FUNDAMENTAL-MODE FUNDAMENTAL-MODE "Fundamental"
          "Return to ZWEI's fundamental mode." ())

(DEFMETHOD (:RELEVANT-FUNCTION-NAME FUNDAMENTAL-MODE) (&REST ARGS)
  (LEXPR-FUNCALL #'BOUNDED-RELEVANT-FUNCTION-NAME ARGS))

;; Unnecessary sinc this is inthe expansion of the DEFMAJOR above.
;(COMPILE-FLAVOR-METHODS FUNDAMENTAL-MODE)


;;;; Minor modes

(DEFFLAVOR MINOR-MODE (MODE-LINE-POSITION) (MODE)
  (:GETTABLE-INSTANCE-VARIABLES MODE-LINE-POSITION)
  :ABSTRACT-FLAVOR)

(DEFMETHOD (:MAJOR-MODE-P MINOR-MODE) () NIL)

(DEFMETHOD (:COMMAND-EXECUTE MINOR-MODE) ()
  (IF (IF *NUMERIC-ARG-P* (ZEROP *NUMERIC-ARG*)
	  (ASSQ SELF *MODE-LIST*))
      (TURN-OFF-MODE SELF)
      (TURN-ON-MODE SELF)))

(COMPILE-FLAVOR-METHODS MINOR-MODE)

(DEFMINOR COM-ATOM-WORD-MODE ATOM-WORD-MODE "" 1
	  "Make word commands deal with lisp atoms.
With an argument of zero, exit Atom Word mode; otherwise enter it.
In Atom Word mode, all word commands act on Lisp atoms." ()
  (SET-SYNTAX-TABLE-INDIRECTION *MODE-WORD-SYNTAX-TABLE* *ATOM-WORD-SYNTAX-TABLE*))

(DEFMINOR COM-EMACS-MODE EMACS-MODE "Emacs" 1
	  "Minor mode to provide commands for EMACS users.
This is for people who have used EMACS from non-TV keyboards for a long
time and are not yet adjusted to the more winning commands.  It puts
bit prefix commands on Altmode, Control-^ and Control-C, and Universal
Argument on Control-U." ()
  (SET-COMTAB *MODE-COMTAB* '(#\c-^ COM-PREFIX-CONTROL
			      #\ALTMODE COM-PREFIX-META
			      #\c-C COM-PREFIX-CONTROL-META
			      #\c-U COM-UNIVERSAL-ARGUMENT
			      #\c-I (0 #\TAB)
			      #\c-H (0 #\BS)
			      #\c-] (0 #\ABORT))))

;;; Gets a single character from the user.  If HIGHBITSP is true, does not
;;; strip the control and meta bis.
(DEFUN GET-ECHO-CHAR (PROMPT HIGHBITSP &AUX CHAR)
  (TYPEIN-LINE "~A" PROMPT)
  (TYPEIN-LINE-ACTIVATE
    (SETQ CHAR (CHAR-UPCASE (FUNCALL STANDARD-INPUT ':TYI))))
  (OR HIGHBITSP (SETQ CHAR (MAKE-CHAR CHAR)))
  (TYPEIN-LINE-MORE "~:C" CHAR)
  CHAR)

(DEFCOM COM-PREFIX-CONTROL DOCUMENT-PREFIX-CHAR ()
  (PROCESS-PREFIX-COMMAND-CHAR (SET-CHAR-BIT (GET-ECHO-CHAR "Control-" NIL) :CONTROL T)))

(DEFCOM COM-PREFIX-META DOCUMENT-PREFIX-CHAR ()
  (PROCESS-PREFIX-COMMAND-CHAR (SET-CHAR-BIT
				       (GET-ECHO-CHAR "Meta-"
						      (EQL *LAST-COMMAND-CHAR* #\ALTMODE))
				       :META T)))

(DEFCOM COM-PREFIX-CONTROL-META DOCUMENT-PREFIX-CHAR ()
  (PROCESS-PREFIX-COMMAND-CHAR
    (SET-CHAR-BIT (SET-CHAR-BIT (GET-ECHO-CHAR "Control-Meta-" NIL) :CONTROL T) :META T)))

(DEFUN PROCESS-PREFIX-COMMAND-CHAR (KEY &AUX VALUE)
  (SETQ VALUE (PROCESS-COMMAND-CHAR KEY))
  (IF (EQ VALUE ':ARGUMENT) VALUE DIS-NONE))

(DEFUN DOCUMENT-PREFIX-CHAR (COMMAND IGNORE OP &AUX COLNUM)
  (SETQ COLNUM (CDR (ASSQ COMMAND '((COM-PREFIX-CONTROL . 1)
				    (COM-PREFIX-META . 2)
				    (COM-PREFIX-CONTROL-META . 3)))))
  (SELECTQ OP
    (:NAME (GET COMMAND 'COMMAND-NAME))
    (:SHORT (FORMAT T "Set the ~[Control~;Meta~;Control-Meta~] prefix." (1- COLNUM)))
    (:FULL (FORMAT T "Set the ~[Control~;Meta~;Control-Meta~] prefix.
Make the next character act as if it were typed with ~[CTRL~;META~;CTRL and META~]
held down, just as if you were on a losing terminal that doesn't
support all of the wonderful keys that we cleverly provide
on these marvelous keyboards.
Type a subcommand to document (or /"*/" for all): " (1- COLNUM) (1- COLNUM))
	   (LET ((CHAR (SEND STANDARD-INPUT ':TYI)))
	     (COND ((CHAR-EQUAL CHAR #/*)
		    (FORMAT T "~2%The following ~[Control~;Meta~;Control-Meta~]- commands are availible:~%" (1- COLNUM))
		    (DO ((I 0 (1+ I))
			   (LIM 220))
			  (( I LIM))
			(PRINT-SHORT-DOC-FOR-TABLE (CODE-CHAR I COLNUM) *COMTAB* 3)))
		   (T 
		    ;; Make sure to upcase the char since that's what PROCESS-PREFIX-CHAR
		    ;; will do, and since otherwise lowercase chars will look like
		    ;; bucky-sh-char rather than bucky-char due to obscureness in the
		    ;; representation of bucky chars. -kmp 25-Sep-92
		    (SETQ CHAR (MAKE-CHAR (CHAR-UPCASE CHAR) COLNUM))
		    (FORMAT T "~:C~2%" CHAR)
		    (DOCUMENT-KEY CHAR *COMTAB*)))))))

(DEFCOM COM-UNIVERSAL-ARGUMENT "Sets argument or multiplies it by four.
Followed by digits, uses them to specify the
argument for the command after the digits.
Not followed by digits, multiplies the argument by four." ()
  (SETQ *NUMERIC-ARG-P* ':CONTROL-U)
  (DO ((FIRSTP T NIL)
       (MINUSP NIL)
       (DIGITP NIL)
       (NUM 1)
       (TEM)
       (CHAR)
       )
      (NIL)
    (SETQ CHAR (FUNCALL STANDARD-INPUT ':TYI))
    (COND ((AND FIRSTP (CHAR-EQUAL CHAR #/-))
	   (SETQ MINUSP T
		 *NUMERIC-ARG-P* ':SIGN))
	  ((SETQ TEM (DIGIT-CHAR-P CHAR))
	   (COND (DIGITP (SETQ NUM (+ TEM (* NUM 10.))))
		 (T (SETQ NUM TEM
			  *NUMERIC-ARG-P* ':DIGITS
			  DIGITP T))))
	  (T
	   (COND ((OR MINUSP DIGITP)
		  (SETQ *NUMERIC-ARG* (IF MINUSP (MINUS NUM) NUM)))
		 (T (SETQ *NUMERIC-ARG* (* 4 *NUMERIC-ARG*))))
	   (FUNCALL STANDARD-INPUT ':UNTYI CHAR)
	   (RETURN ':ARGUMENT)))))

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; Auto Fill Mode

0(DEFMINOR COM-AUTO-FILL-MODE AUTO-FILL-MODE "Fill" 2
	  "Turn on auto filling.
Without an argument, toggles the mode."
	  ()
  (COMMAND-HOOK 'AUTO-FILL-HOOK *POST-COMMAND-HOOK*))

1;;; Can't use the standard (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB"):command-execute1 method for minor modes --
;;;    We need to explicitly set the 2:nofill1 property to reflect the user's desire that
;;;    0Auto Fill1 be on/off in the buffer.  Otherwise, 0Auto Fill1 will always return after
;;;    switching buffers if the 2auto-fill-if-appropriate1 hook is used.
0(DEFMETHOD (:COMMAND-EXECUTE AUTO-FILL-MODE) ()
  (LABELS ((TWIDDLE-AUTO-FILL (NEW-SETTING)
	     (SEND *INTERVAL* :PUTPROP (NOT NEW-SETTING) :NOFILL)
	     (IF NEW-SETTING
		 (TURN-ON-MODE SELF)
	       (TURN-OFF-MODE SELF))))
    (IF (IF *NUMERIC-ARG-P* (ZEROP *NUMERIC-ARG*)
	  (ASSQ SELF *MODE-LIST*))
	(TWIDDLE-AUTO-FILL NIL)
      (TWIDDLE-AUTO-FILL T))))

(DEFPROP AUTO-FILL-HOOK 20 COMMAND-HOOK-PRIORITY)
;;--- Should this take a prefix variable, too?
(DEFUN AUTO-FILL-HOOK (CHAR &OPTIONAL (FILL-COLUMN-VARIABLE '*FILL-COLUMN*))
  (LET ((FILL-COLUMN (VARIABLE-VALUE FILL-COLUMN-VARIABLE))
	(MAJOR-MODE (SEND *INTERVAL* :MAJOR-MODE))
	BP)
    (AND (MEMQ CHAR *AUTO-FILL-ACTIVATION-CHARACTERS*)
	 (NOT *NUMERIC-ARG-P*)
	 (NEQ *INTERVAL* (WINDOW-INTERVAL *MINI-BUFFER-WINDOW*))
	 (IF MAJOR-MODE (SEND MAJOR-MODE :AUTO-FILL-SUPPORTED-P) T)
	 (LET ((LINE (BP-LINE (POINT))))
	   (AND (CHAR= CHAR #\CR) (LINE-PREVIOUS-IN-BUFFER LINE)
		(SETQ LINE (LINE-PREVIOUS-IN-BUFFER LINE)))
	   (SETQ BP (DO ((SHEET (WINDOW-SHEET *WINDOW*))		     
			 (LEN (1+ (OR (STRING-REVERSE-SEARCH-NOT-CHAR #\SP LINE) -1)))
			 (POS 0)
			 (CHAR-POS 0 CP)
			 (CP))
			((= CHAR-POS LEN) NIL)
		      (SETQ CP (OR (STRING-SEARCH-CHAR #\SP LINE (1+ CHAR-POS)) LEN)
			    POS (FUNCALL SHEET ':STRING-LENGTH LINE CHAR-POS CP NIL NIL POS))
		      (AND (> POS FILL-COLUMN) (> CHAR-POS 0)
			   (RETURN (CREATE-BP LINE CHAR-POS))))))
	 (WITH-BP (PT (POINT) ':MOVES)		;Save point
	   (MOVE-POINT BP)
	   (LET ((LINE (BP-LINE BP))
		 (LINE2 NIL))
	     (IF (OR (END-LINE-P (FORWARD-OVER *BLANKS* PT))
		     (EQ LINE (BP-LINE (INTERVAL-LAST-BP *INTERVAL*)))
		     (NULL (SETQ LINE2 (LINE-NEXT-IN-BUFFER LINE)))
		     (FIND-COMMENT-START LINE)
		     (> (+ (STRING-WIDTH LINE (BP-INDEX BP))
			   (STRING-WIDTH LINE2))
			FILL-COLUMN))
		 ;; Simply change a space to a return (plus a fill prefix or comment prefix)
		 ;; *FORCIBLY-MERGE-CHANGE-RECORD* makes it look like the user had typed
		 ;; the return instead of the space in the first place
		 (LET ((*FORCIBLY-MERGE-CHANGE-RECORD* T))
		   (DELETE-INTERVAL BP (FORWARD-CHAR BP))
		   (LET ((AT-POINT-P (BP-= PT BP)))
		     (MUST-REDISPLAY *WINDOW* (COM-INDENT-NEW-COMMENT-LINE))
		     (AND AT-POINT-P (MOVE-BP PT (POINT)))))
		 ;; The more complex line-splitting case
		 (LET ((BP-LINE2 (CREATE-BP LINE2 0)))
		   (WITH-UNDO-SAVE-SIMPLE (BP (FORWARD-OVER *BLANKS* BP-LINE2) T)
		     (WHEN (IF (PLUSP (STRING-LENGTH *FILL-PREFIX*))
			       (NOT (LOOKING-AT BP-LINE2 *FILL-PREFIX*))
			       (SELECTQ (LINE-TYPE LINE2)
				 (:BLANK
				  (NOT (OR (EQ LINE2 (BP-LINE (INTERVAL-LAST-BP *INTERVAL*)))
					   (LINE-BLANK-P (LINE-NEXT-IN-BUFFER LINE2)))))
				 (:DIAGRAM T)
				 (OTHERWISE
				  (BP-LOOKING-AT-LIST BP-LINE2 *PARAGRAPH-DELIMITER-LIST*))))
		       (INSERT BP-LINE2 #\CR)
		       (SETQ LINE2 (LINE-PREVIOUS-IN-BUFFER LINE2))
		       (INSERT (CREATE-BP LINE2 0) *FILL-PREFIX*))
		     (LET ((IDX (1+ (BP-INDEX BP))))
		       (INSERT
			 (INSERT (FORWARD-OVER *BLANKS*
					       (CREATE-BP LINE2 (STRING-LENGTH *FILL-PREFIX*)))
				 (NSUBSTRING LINE IDX))
			 " ")
		       (AND (EQ (BP-LINE PT) (BP-LINE BP))
			    ( (SETQ IDX (- (BP-INDEX PT) IDX)) 0)
			    (MOVE-BP PT LINE2 (+ IDX (STRING-LENGTH *FILL-PREFIX*)))))
		     (DELETE-INTERVAL BP (END-OF-LINE LINE))
		     (MUST-REDISPLAY *WINDOW* DIS-TEXT)))))
	   (MOVE-POINT PT)))))

(DEFPROP AUTO-FILL-HOOK DOCUMENT-AUTO-FILL-HOOK HOOK-DOCUMENTATION-FUNCTION)

(DEFUN DOCUMENT-AUTO-FILL-HOOK (IGNORE CHAR)
  (AND (MEMQ CHAR *AUTO-FILL-ACTIVATION-CHARACTERS*)
       (PRINC "With no numeric argument, auto fill line if needed.
")))

(DEFMINOR COM-FULL-AUTO-FILL-MODE FULL-AUTO-FILL-MODE "Full Fill" 2
          "Turn on full auto filling.
Without an argument, toggles the mode." ()
  (COMMAND-HOOK 'FULL-AUTO-FILL-HOOK *POST-COMMAND-HOOK*))

(DEFPROP FULL-AUTO-FILL-HOOK 20 COMMAND-HOOK-PRIORITY)
(DEFUN FULL-AUTO-FILL-HOOK (CHAR)
  (WHEN (AND (NEQ *INTERVAL* (WINDOW-INTERVAL *MINI-BUFFER-WINDOW*))
	     (> (NODE-TICK *INTERVAL*)
		(OR (SEND *INTERVAL* :GET 'FILL-TICK) 0))
	     (NOT (SEND STANDARD-INPUT :LISTEN)))
    (MULTIPLE-VALUE-BIND (FIRST-BP LIMITED)
	(SELECTQ (COMMAND-LOOKUP CHAR *COMTAB*)
	  (COM-STANDARD
	   (VALUES (BEG-LINE (POINT)) T))
	  (COM-RUBOUT
	   (VALUES (BEG-LINE (POINT)) T))
	  (COM-INSERT-CRS
	   (VALUES (POINT) T))
	  (OTHERWISE
	   (FORWARD-PARAGRAPH (POINT) -1)))
      (WHEN FIRST-BP
	(LET ((END-BP (IF LIMITED
			  (INTERVAL-LAST-BP *INTERVAL*)	;Can have it do stopping.
			  (FORWARD-PARAGRAPH FIRST-BP))))
	  (WHEN (AND END-BP (NOT (BP-< END-BP (POINT))))
	    (LET ((TICK (NODE-TICK *INTERVAL*)))
	      (FILL-INTERVAL FIRST-BP END-BP T)
	      (WHEN (> (NODE-TICK *INTERVAL*) TICK)
		;; Only if it did something.
		(MUST-REDISPLAY *WINDOW* DIS-TEXT))))
	  (SETF (SEND *INTERVAL* :GET 'FILL-TICK) (TICK)))))))

(DEFMINOR COM-OVERWRITE-MODE OVERWRITE-MODE "Overwrite" 4
	  "Turn on overwrite mode.
An argument of 0 turns it off; a non-zero argument turns it on;
no argument toggles it.  In overwrite mode, normal characters replace
the character they are over, instead of inserting." ()
  (SETQ *STANDARD-COMMAND* 'COM-SELF-OVERWRITE))

(DEFCOM COM-SELF-OVERWRITE "Replace the character at point with the character typed.
At the end of a line, inserts instead of replacing the newline." ()
  (LET ((CHAR (IN-CURRENT-STYLE *LAST-COMMAND-CHAR*))
	(PT (POINT)))
    (WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK PT))
      (LET ((LINE (BP-LINE PT)) (INDEX (BP-INDEX PT)))
	(DOTIMES (IGNORE *NUMERIC-ARG*)
	  (UNLESS (END-LINE-P PT)
	    (DELETE-INTERVAL PT (FORWARD-CHAR PT)))
	  (INSERT-MOVING PT CHAR))
	;; CR probably never handled by this function...
	(IF (CHAR= CHAR #\CR) DIS-TEXT (VALUES DIS-LINE LINE INDEX))))))

;;; Word abbrev mode

(DEFINE-LOCAL-VARIABLE *LAST-EXPANDED* NIL)
(DEFINE-LOCAL-VARIABLE *LAST-EXPANSION* NIL)
(DEFINE-LOCAL-VARIABLE *LAST-EXPANSION-BP* NIL)
(DEFINE-LOCAL-VARIABLE *LAST-EXPANSION-SYMBOL*)
(DEFINE-LOCAL-VARIABLE *LAST-EXPANSION-USAGE-PROP*)
(DEFINE-LOCAL-VARIABLE *WORD-ABBREV-PREFIX-MARK* NIL)

(DEFUN INITIALIZE-WORD-ABBREV-TABLE ()
  (LET ((INIT  " ~@#;$%^&*()-_=+[]\/|:'`/"{},<.>//?!
212"))
    (SETQ *WORD-ABBREV-TABLE* (MAKE-ARRAY 400 ':TYPE 'ART-1B))
    (DO ((I 0 (1+ I))
	 (LIM (STRING-LENGTH INIT)))
	(( I LIM))
      (ASET 1 *WORD-ABBREV-TABLE* (CHAR-CODE (AREF INIT I))))))

(DEFCOM COM-EXPAND-ONLY "Expand last word, but insert nothing after it.
If given an argument, beep unless expanded." ()
  (AND (NULL (EXPAND-ABBREV)) *NUMERIC-ARG-P*
       (BARF))
  DIS-TEXT)

(DEFPROP EXPAND-ABBREV-HOOK 10 COMMAND-HOOK-PRIORITY)
(DEFUN EXPAND-ABBREV-HOOK (IGNORE)
  (AND (EXPAND-P *LAST-COMMAND-CHAR*)
       (NOT *NUMERIC-ARG-P*)
       (EXPAND-ABBREV)
       (MUST-REDISPLAY *WINDOW* DIS-TEXT)))

(DEFPROP EXPAND-ABBREV-HOOK DOCUMENT-EXPAND-ABBREV-ITEM HOOK-DOCUMENTATION-FUNCTION)
(DEFUN DOCUMENT-EXPAND-ABBREV-ITEM (IGNORE CHAR)
  (AND (EXPAND-P CHAR)
       (PRINC "With no numeric argument, expand preceeding word abbrev if any.
")))

;;; Does this character try to expand preceeding abbrev?
(DEFUN EXPAND-P (CHAR)
  (AND (NOT (MOUSE-CHAR-P CHAR))
       (ZEROP (CHAR-BITS CHAR))
       (NOT (ZEROP (AREF *WORD-ABBREV-TABLE* (CHAR-CODE CHAR))))))

;;; Returns T when it actually expands something, NIL otherwise, so the caller knows
(DEFUN EXPAND-ABBREV (&AUX BP STRING SYM TEM PROP)
  (AND (= (WORD-SYNTAX (BP-CHAR-BEFORE (POINT))) WORD-ALPHABETIC)
       (MULTIPLE-VALUE (STRING BP)
	 (BOUND-WORD (POINT))))
  (COND ((AND STRING
	      (SETQ SYM (INTERN-SOFT (STRING-UPCASE (STRING-THIN STRING)) *UTILITY-PACKAGE*))
	      (SETQ TEM (OR (GET SYM (SETQ PROP (GET-ABBREV-MODE-NAME)))
			    (GET SYM (SETQ PROP '*-ABBREV)))))
	 (COND (*LAST-EXPANSION-BP*
		(MOVE-BP *LAST-EXPANSION-BP* BP))
	       (T
		(SETF *LAST-EXPANSION-BP* (COPY-BP BP ':NORMAL))))
	 (COND ((AND (CHAR-EQUAL (BP-CHAR-BEFORE BP) #/-)
		     (BP-= (MOVE-BP BP (FORWARD-CHAR BP -1))
			   *WORD-ABBREV-PREFIX-MARK*))
		(SETQ STRING (STRING-APPEND "-" STRING))
		(DELETE-INTERVAL BP (FORWARD-CHAR BP) T))
	       (T
		(SETQ STRING (STRING-APPEND STRING))))
	 (SETF *LAST-EXPANDED* STRING)
	 (SETF *LAST-EXPANSION* TEM)
	 (SETF *LAST-EXPANSION-SYMBOL* SYM)
	 (SETF *LAST-EXPANSION-USAGE-PROP* (GET-ABBREV-USAGE-NAME PROP))
	 (LET ((V (GET SYM *LAST-EXPANSION-USAGE-PROP*)))
	   (PUTPROP SYM (IF V (1+ V) 1) *LAST-EXPANSION-USAGE-PROP*))
	 (LET ((OLD-*SRP* *STYLE-REPLACE-P*))
	   (UNWIND-PROTECT
	       (PROGN
		 ;; Retain character style
		 (SET '*STYLE-REPLACE-P* NIL)
		 (MOVE-POINT (CASE-REPLACE *LAST-EXPANSION-BP* (POINT) TEM)))
	     (SET '*STYLE-REPLACE-P* OLD-*SRP*)))
	 T)))

(DEFCOM COM-UNEXPAND-LAST-WORD "Undo last expansion, leaving the abbrev." ()
  (LET (BP TEM)
    (OR *LAST-EXPANSION* (BARF "No last expansion"))
    (SETQ BP (FORWARD-CHAR *LAST-EXPANSION-BP* (ARRAY-ACTIVE-LENGTH *LAST-EXPANSION*)))
    (OR (STRING-EQUAL (STRING-INTERVAL *LAST-EXPANSION-BP* BP T) *LAST-EXPANSION*)
	(BARF "No last expansion"))
    (SETQ TEM (BP-= BP (POINT))
          BP (INSERT (DELETE-INTERVAL *LAST-EXPANSION-BP* BP)
                     *LAST-EXPANDED*))
    (PUTPROP *LAST-EXPANSION-SYMBOL*
	     (1- (GET *LAST-EXPANSION-SYMBOL*
		      *LAST-EXPANSION-USAGE-PROP*))
	     *LAST-EXPANSION-USAGE-PROP*)
    (AND TEM (MOVE-POINT BP)))
  DIS-TEXT)

(DEFMINOR COM-WORD-ABBREV-MODE WORD-ABBREV-MODE "Abbrev" 3
          "Mode for expanding word abbrevs.
No arg or non-zero arg sets the mode, 0 arg clears it." ()
; (SET-COMTAB *MODE-COMTAB* '(#\SP COM-EXPAND-ONLY))
  (SET-COMTAB *STANDARD-CONTROL-X-COMTAB*
	      '(#/U COM-UNEXPAND-LAST-WORD
		#/c-A COM-ADD-MODE-WORD-ABBREV
		#/+ COM-ADD-GLOBAL-WORD-ABBREV))
  (COMMAND-HOOK 'EXPAND-ABBREV-HOOK *COMMAND-HOOK*)
  (SETQ *LAST-EXPANSION-BP* NIL)
  (SETQ *LAST-EXPANDED* NIL)
  (SETQ *LAST-EXPANSION* NIL)
  (SETQ *WORD-ABBREV-PREFIX-MARK* NIL))

(DEFCOM COM-MAKE-WORD-ABBREV "Prompts for and make a new word abbrev.
An argument means make global abbrev, else local for this mode.
It prompts twice, first for the whole word that you want the abbrev
to expand to, then for the abbrev itself." ()
  (MAKE-WORD-ABBREV
    *NUMERIC-ARG-P*
    (TYPEIN-LINE-READLINE "Define ~:[~A mode~;global~*~] abbreviation for this word: "
			  *NUMERIC-ARG-P* (NAME-OF-MAJOR-MODE))))

(DEFCOM COM-ADD-MODE-WORD-ABBREV "Prompts for mode abbrev for words before point.
A numeric argument specifies how many words preceding point to take as the
expansion for the new abbrev.  A negative argument means to delete an existing 
abbrev for the word before point.  (If there is no such mode abbrev, but there
is a global, ask if should kill the global.)  If there is a region, it ignores 
any numeric argument and uses the region instead." ()
  (COND ((MINUSP *NUMERIC-ARG*)
	 (LET ((*NUMERIC-ARG* (MINUS *NUMERIC-ARG*)))
	   (COM-KILL-MODE-WORD-ABBREV)))
	(T
	 (MAKE-WORD-ABBREV NIL))))

(DEFCOM COM-ADD-GLOBAL-WORD-ABBREV "Prompts for global abbrev for words before point.
A numeric argument specifies how many words preceding point to take as the
expansion for the new abbrev.  A negative argument means to delete an existing 
abbrev for the word before point.  If there is a region, it ignores any numeric
argument and uses the region instead." ()
  (COND ((MINUSP *NUMERIC-ARG*)
	 (LET ((*NUMERIC-ARG* (MINUS *NUMERIC-ARG*)))
	   (COM-KILL-GLOBAL-WORD-ABBREV)))
	(T
	 (MAKE-WORD-ABBREV T))))

(DEFUN MAKE-WORD-ABBREV (GLOBAL-P &OPTIONAL STRING &AUX ABBREV)
  (OR STRING
      (SETQ STRING (COND ((WINDOW-MARK-P *WINDOW*)
			  (STRING-INTERVAL (MARK) (POINT)))
			 (T
			  (OR (BOUND-WORD (POINT) (ABS *NUMERIC-ARG*))
			      (BARF))))))
  (OR (STRINGP STRING)
      (SETQ STRING (STRING-APPEND "" STRING)))
  (SETQ ABBREV (LET ((*COMMAND-HOOK* NIL))	;Don't expand abbrevs within
		 (TYPEIN-LINE-HISTORY-READLINE NIL STRING NIL
					       "~:[~A mode~;Global~*~] abbrev for /"~A/": "
					       GLOBAL-P (NAME-OF-MAJOR-MODE) STRING)))
  (PUTPROP (INTERN (STRING-UPCASE (STRING-THIN ABBREV)) *UTILITY-PACKAGE*)
	   (STRING-APPEND STRING)
	   (IF GLOBAL-P '*-ABBREV (GET-ABBREV-MODE-NAME)))
  (SETQ *WORD-ABBREV-TICK* (TICK))
  DIS-NONE)

(DEFCOM COM-KILL-MODE-WORD-ABBREV "Cause mode abbrev typed to be expunged." ()
  (KILL-ABBREV NIL))

(DEFCOM COM-KILL-GLOBAL-WORD-ABBREV "Cause global abbrev typed to be expunged." ()
  (KILL-ABBREV T))

(DEFUN KILL-ABBREV (GLOBAL-P &AUX STRING SYM MODE-NAME PROP)
  (SETQ STRING (LET ((*COMMAND-HOOK* NIL))	;Don't expand abbrevs within
		 (TYPEIN-LINE-READLINE "Kill ~:[~A mode~;global~*~] abbrev: "
				       GLOBAL-P (NAME-OF-MAJOR-MODE))))
  (OR (SETQ SYM (INTERN-SOFT (STRING-UPCASE (STRING-THIN STRING)) *UTILITY-PACKAGE*))
      (BARF "No such abbrev defined"))
  (COND (GLOBAL-P
	 (OR (GET SYM '*-ABBREV) (BARF "No such global abbrev defined."))
	 (SI:NREMPROP SYM '*-ABBREV)
	 (SI:NREMPROP SYM '*-ABBREV-USAGE))
	((GET SYM (SETQ MODE-NAME (SETQ PROP (GET-ABBREV-MODE-NAME))))
	 (SI:NREMPROP SYM MODE-NAME)
	 (SI:NREMPROP SYM (GET-ABBREV-USAGE-NAME PROP)))
	((NOT (GET SYM '*-ABBREV))
	 (BARF "No such abbrev defined."))
	((FQUERY '(:SELECT T) "~A is not a ~A mode abbrev, but is a global one, kill it? "
		 STRING (NAME-OF-MAJOR-MODE))
	 (SI:NREMPROP SYM '*-ABBREV)
	 (SI:NREMPROP SYM '*-ABBREV-USAGE))
	(T
	 (PROMPT-LINE "~&Not killed.")))
  (SETQ *WORD-ABBREV-TICK* (TICK))
  DIS-NONE)

(DEFCOM COM-KILL-ALL-WORD-ABBREVS "No word abbrevs are defined after this." ()
  (MAPATOMS #'KILL-ALL-ABBREVS-1 *UTILITY-PACKAGE* NIL)
  ;; This will inhibit saving anything now.
  (SETQ *WORD-ABBREV-FILE-TICK* (TICK))
  DIS-NONE)

(DEFUN KILL-ALL-ABBREVS-1 (SYM)
  (DO ((L (PLIST SYM) (CDDR L))
       (IND)
       (IND-NAME)
       (LEN))
      ((NULL L))
    (SETQ IND (CAR L)
	  IND-NAME (GET-PNAME IND)
	  LEN (STRING-LENGTH IND-NAME))
    (AND (> LEN 7)
	 (STRING-EQUAL (NSUBSTRING IND-NAME (- (STRING-LENGTH IND-NAME) 7))
		       "-ABBREV")
	 (SI:NREMPROP SYM IND)
	 (SI:NREMPROP SYM (GET-ABBREV-USAGE-NAME IND-NAME)))))

(DEFUN BOUND-WORD (BP &OPTIONAL (TIMES 1) &AUX BP1 STRING)
  (AND (SETQ BP (FORWARD-TO-WORD BP -1))
       (SETQ BP1 (FORWARD-WORD BP (- TIMES)))
       (SETQ STRING (STRING-INTERVAL BP BP1)))
  (VALUES STRING BP1))

(DEFCOM COM-WORD-ABBREV-PREFIX-MARK "Mark point as end of a prefix" ()
  (EXPAND-ABBREV)
  (COND (*WORD-ABBREV-PREFIX-MARK*
	 (MOVE-BP *WORD-ABBREV-PREFIX-MARK* (POINT)))
	(T
	 (SETF *WORD-ABBREV-PREFIX-MARK* (COPY-BP (POINT) ':NORMAL))))
  (LET ((POINT (POINT)))
    (INSERT-MOVING POINT "-")
    (MOVE-POINT POINT))
  DIS-TEXT)

(DEFCOM COM-LIST-WORD-ABBREVS "Lists all current abbrevs and their expansions. " ()
  (FORMAT T "~%abbrev:   (mode)             count:     /"expansion/"~3%")
  (LIST-WORD-ABBREV-1 STANDARD-OUTPUT)
  DIS-NONE)

(DEFCOM COM-INSERT-WORD-ABBREVS "Insert all abbrevs and their expansions into the buffer."
	()
  (LIST-WORD-ABBREV-1 (OPEN-INTERVAL-STREAM *INTERVAL*))
  DIS-TEXT)

(DEFUN LIST-WORD-ABBREV-1 (STREAM)
  (MAPATOMS
    #'(LAMBDA (SYM)
	(DO ((L (PLIST SYM) (CDDR L))
	     (IND)
	     (IND-NAME)
	     (USAGE)
	     (LEN)
	     (STRING ""))
	    ((NULL L)
	     (FUNCALL STREAM :STRING-OUT STRING))
	  (SETQ IND (CAR L)
		IND-NAME (GET-PNAME IND)
		LEN (STRING-LENGTH IND-NAME)
		USAGE (OR (GET SYM (GET-ABBREV-USAGE-NAME IND-NAME)) 0))
	  (AND (> LEN 7)
	       (STRING-EQUAL (NSUBSTRING IND-NAME (- LEN 7))
			     "-ABBREV")
	       (SETQ STRING (FORMAT NIL
				    "~A~10,4,2A~:[~15,4,2A~;~15@T~*~] ~6D~6@T /"~A/"~%"
				    STRING
				    (STRING-APPEND SYM ":")
				    (EQ IND '*-ABBREV)
				    (STRING-APPEND "("
						   (NSUBSTRING IND-NAME 0 (- LEN 7))
						   ")")
				    USAGE
				    (CADR L))))))
    *UTILITY-PACKAGE*))

(DEFCOM COM-DEFINE-WORD-ABBREVS "Define word abbrevs from buffer" ()
  (DO ((BP1 (COPY-BP (INTERVAL-FIRST-BP *INTERVAL*)))
       (BP2)
       (MODE "*" "*")
       (USAGE)
       (SYM)
       (TEM))
      (())
    (OR (SETQ BP2 (SEARCH BP1 #/:)) (RETURN NIL))
    (SETQ TEM (STRING-UPCASE (STRING-THIN (STRING-INTERVAL BP1 (FORWARD-CHAR BP2 -1)))))
    (SETQ SYM (INTERN TEM *UTILITY-PACKAGE*))
    (SETQ BP2 (FORWARD-OVER *BLANKS* (FORWARD-CHAR BP2)))
    (COND ((CHAR-EQUAL (BP-CHAR BP2) #/()
	   (OR (SETQ BP1 (SEARCH (SETQ BP2 (FORWARD-CHAR BP2)) #/)))
	       (BARF "Unmatched paren ~A" (BP-LINE BP2)))
	   (SETQ MODE (STRING-INTERVAL BP2 (FORWARD-CHAR BP1 -1)))
	   (SETQ BP2 (PROG1 (FORWARD-OVER *BLANKS* (FORWARD-CHAR BP1))
			    (SETQ BP1 BP2)))))
    (MULTIPLE-VALUE (USAGE TEM)
      (PARSE-NUMBER (BP-LINE BP2) (BP-INDEX BP2) NIL 10.))
    (IGNORE USAGE)
    (AND (= TEM (BP-INDEX BP2)) (BARF "No usage count ~A" (BP-LINE BP2)))
    (SETF (BP-INDEX BP2) TEM)
    (SETQ BP2 (FORWARD-OVER *BLANKS* BP2))
    (OR (CHAR-EQUAL (BP-CHAR BP2) #/")
	(BARF "No expansion ~A" (BP-LINE BP2)))
    (OR (SETQ BP1 (SEARCH (SETQ BP2 (FORWARD-CHAR BP2)) #/"))
	(BARF "Unmatched quote ~A" (BP-LINE BP2)))
    (PUTPROP SYM (STRING-APPEND (STRING-INTERVAL BP2 (FORWARD-CHAR BP1 -1)))
	     (GET-ABBREV-MODE-NAME MODE))
    (AND (EQ (BP-LINE BP1) (BP-LINE (INTERVAL-LAST-BP *INTERVAL*)))
	 (RETURN NIL))
    (MOVE-BP BP1 (BEG-LINE BP1 1)))
  DIS-NONE)

(DEFUN GET-ABBREV-MODE-NAME (&OPTIONAL (MODE (STRING (NAME-OF-MAJOR-MODE))))
  (INTERN (STRING-APPEND MODE "-ABBREV") *EDITOR-PACKAGE*))

;;; Given the name of a X-ABBREV prop, return the usage count property.
(DEFUN GET-ABBREV-USAGE-NAME (STR)
  (INTERN (STRING-APPEND STR "-USAGE") *EDITOR-PACKAGE*))

(DEFCOM COM-EDIT-WORD-ABBREVS "Enter recursive edit on the abbrev definitions." ()
  (SEND *CURRENT-COMMAND-LOOP* ':SELECT-SPECIAL-BUFFER ':WORD-ABBREVS T)
  (LET ((*SET-ATTRIBUTE-UPDATES-LIST* NIL))
    (COM-EDIT-WORD-ABBREVS-MODE))
  DIS-TEXT)

(DEFMAJOR COM-EDIT-WORD-ABBREVS-MODE EDIT-WORD-ABBREVS-MODE "Edit Word Abbrevs"
  "Prepares for editing word abbrevs" ()
  (SET-COMTAB *MODE-COMTAB* '(#\ABORT COM-ABORT-EDIT-WORD-ABBREVS
			      #\END COM-EXIT-EDIT-WORD-ABBREVS))
  (SETQ *MODE-LINE-LIST* (APPEND *MODE-LINE-LIST* '("     (End to update and exit)"))))

(DEFCOM COM-ABORT-EDIT-WORD-ABBREVS "Exit from edit word abbrevs without updating." ()
  (DIRED-EXIT))

(DEFCOM COM-EXIT-EDIT-WORD-ABBREVS "Update word abbrevs and exit from edit." ()
  (COM-KILL-ALL-WORD-ABBREVS)
  (COM-DEFINE-WORD-ABBREVS)
  (DIRED-EXIT))

(DEFCOM COM-RECURSIVE-EDIT-BEEP "Exit from recursive edit without updating." ()
  (BEEP)
  (MUST-REDISPLAY *WINDOW* DIS-TEXT)
  (THROW 'TOP-LEVEL T))

(DEFVAR APROPOS-KEY)
(DEFVAR APROPOS-SEARCH-FUNCTION)

(DEFCOM COM-LIST-SOME-WORD-ABBREVS
	"Lists the abbreviations or expansions that contain the given string.  " ()
  (MULTIPLE-VALUE-BIND (APROPOS-SEARCH-FUNCTION APROPOS-KEY)
      (GET-EXTENDED-SEARCH-STRINGS "Word abbrev apropos (substring:)")
    (MAPATOMS #'WORD-ABBREV-APROPOS-INTERNAL *UTILITY-PACKAGE* NIL))
  (FORMAT T "Done.~%")
  DIS-NONE)

(DEFUN WORD-ABBREV-APROPOS-INTERNAL (SYM)
  (DO ((L (PLIST SYM) (CDDR L))
       (IND)
       (IND-NAME)
       (LEN))
      ((NULL L))
    (SETQ IND (CAR L)
	  IND-NAME (GET-PNAME IND)
	  LEN (STRING-LENGTH IND-NAME))
    (AND (> LEN 7)
	 (STRING-EQUAL (NSUBSTRING IND-NAME (- LEN 7))
		       "-ABBREV")
	 (OR (FUNCALL APROPOS-SEARCH-FUNCTION APROPOS-KEY (GET-PNAME SYM))
	     (FUNCALL APROPOS-SEARCH-FUNCTION APROPOS-KEY (CADR L)))
	 (FORMAT T "~A:	~:[(~A)~;~*~]	/"~A/"~%"
		 SYM (EQ IND '*-ABBREV)
		 (NSUBSTRING IND-NAME 0 (- LEN 7)) (CADR L)))))

(DEFCOM COM-READ-WORD-ABBREV-FILE "Load up new format word abbrev file." ()
  (AND *WORD-ABBREV-FILE-NAME*
       (FS:SET-DEFAULT-PATHNAME *WORD-ABBREV-FILE-NAME* *PATHNAME-DEFAULTS*))
  (LET ((FNAME (ACCEPT-DEFAULTED-PATHNAME "Load QWABL file" (PATHNAME-DEFAULTS)
					  :SPECIAL-TYPE "QWABL")))
    (WITH-OPEN-FILE (STREAM FNAME :DIRECTION :INPUT)
      (LOAD-QWABL STREAM))
    (SETQ *WORD-ABBREV-FILE-NAME* FNAME
	  *WORD-ABBREV-FILE-TICK* (TICK)))
  DIS-NONE)

(DEFUN LOAD-QWABL (STREAM)
  (FUNCALL STREAM ':LINE-IN)			;Flush some TECO macros
  (FUNCALL STREAM ':LINE-IN)
  (DO ((SYM)
       (USAGE)
       (MODE)
       (STR)
       (EOFP)
       (TEM)
       (TEM1))
      (())
    (MULTIPLE-VALUE (STR EOFP)
      (FUNCALL STREAM ':LINE-IN T))
    (AND EOFP (RETURN NIL))
    (OR (SETQ TEM (STRING-SEARCH-CHAR #\SP STR))
	(BARF "No abbrev ~S" STR))
    (SETQ TEM (1+ TEM))
    (OR (SETQ TEM1 (STRING-SEARCH-CHAR #\SP STR TEM))
	(BARF "No mode ~S" STR))
    (SETQ SYM (STRING-UPCASE (NSUBSTRING STR TEM TEM1))
	  TEM1 (1+ TEM1))
    (OR (SETQ TEM (STRING-SEARCH-CHAR #\SP STR TEM1))
	(BARF "No end of mode ~S" STR))
    (SETQ MODE (NSUBSTRING STR TEM1 TEM)
	  TEM (1+ TEM))
    (SETQ MODE (GET-ABBREV-MODE-NAME MODE))
    (OR (SETQ TEM1 (STRING-SEARCH-CHAR #/ STR TEM))
	(BARF "No expansion ~S" STR))
    (SETQ STR (NSUBSTRING STR (1+ TEM1)))
    (SETQ STR (DO ((EXPANSION "" (STRING-APPEND EXPANSION STR #\CR))
		   (STR STR (FUNCALL STREAM ':LINE-IN))
		   (POS))
		  (())
		(COND ((SETQ POS (STRING-SEARCH-CHAR #/ STR))
		       (SETQ USAGE (PARSE-NUMBER STR (1+ POS) NIL 10.))
		       (SETQ STR (NSUBSTRING STR 0 POS))
		       (RETURN (STRING-APPEND EXPANSION STR))))))
    (SETQ SYM (INTERN SYM *UTILITY-PACKAGE*))
    (PUTPROP SYM STR MODE)
    (PUTPROP SYM USAGE (GET-ABBREV-USAGE-NAME MODE))
    ))

(DEFUN WRITE-QWABL (STREAM &AUX L)
  (SEND STREAM ':LINE-OUT "m.m& Make Usage Abbrev Variable[V")
  (SEND STREAM ':LINE-OUT "q..q[..o")
  (DO-LOCAL-SYMBOLS (SYM *UTILITY-PACKAGE*)
    (PUSH SYM L))
  (SETQ L (SORT L #'STRING-LESSP))
  (DOLIST (SYM L)
    (LOOP FOR (PROPNAME VALUE) ON (PLIST SYM) BY 'CDDR
	  DO (LET ((LPROPNAME (STRING-LENGTH PROPNAME)))
	       (WHEN (AND (> LPROPNAME 7)
			  (STRING-EQUAL "-ABBREV" PROPNAME 0 (- LPROPNAME 7)))
		 (FORMAT STREAM "MVX ~A ~A Abbrev~A~D~%"
			 (STRING-DOWNCASE SYM)
			 (SUBSTRING PROPNAME 0 (- LPROPNAME 7))
			 VALUE
			 (OR (GET SYM (GET-ABBREV-USAGE-NAME PROPNAME)) 0)
			 ))))))

(DEFCOM COM-WRITE-WORD-ABBREV-FILE "Write out all word abbrevs in QWABL format." ()
  (AND *WORD-ABBREV-FILE-NAME*
       (FS:SET-DEFAULT-PATHNAME *WORD-ABBREV-FILE-NAME* *PATHNAME-DEFAULTS*))
  (LET ((FN (ACCEPT-DEFAULTED-PATHNAME
	      "Write word abbrevs to" (PATHNAME-DEFAULTS)
	      :SPECIAL-TYPE "QWABL" :SPECIAL-VERSION NIL :DIRECTION :WRITE)))
    (COM-WRITE-WORD-ABBREV-FILE-INTERNAL FN))
  DIS-NONE)

(DEFCOM COM-SAVE-WORD-ABBREV-FILE "Writed out word abbrevs if changed." ()
  (COM-SAVE-WORD-ABBREV-FILE-INTERNAL ':EXPLICIT)
  DIS-NONE)

(DEFUN COM-SAVE-WORD-ABBREV-FILE-INTERNAL (WHEN)
  (COND (( *WORD-ABBREV-TICK* *WORD-ABBREV-FILE-TICK*)
	 (AND (EQ WHEN ':EXPLICIT)
	      (TYPEIN-LINE "(Word abbrevs do not need to be saved)")))
	((AND (EQ WHEN ':ASK)
	      (NOT (FQUERY '(:SELECT T) "Save word abbrevs~@[ on file ~A~]? "
			   *WORD-ABBREV-FILE-NAME*))))
	(T
	 (OR *WORD-ABBREV-FILE-NAME*
	     (SETQ *WORD-ABBREV-FILE-NAME*
		   (IF *INTERVAL*
		       (ACCEPT-DEFAULTED-PATHNAME
			 "Save word abbrevs to" (PATHNAME-DEFAULTS)
			 :SPECIAL-TYPE "QWABL" :SPECIAL-VERSION NIL :DIRECTION :WRITE)
		     ;; In the following case, the query is happening outside of
		     ;; Zmacs.  This is needed for SAVE-ALL-FILES as called by
		     ;; :Logout and :Save File Buffers.  A better fix for the
		     ;; future might be to get ACCEPT-DEFAULTED-PATHNAME or
		     ;; TYPEIN-LINE-ACCEPT to deal with the non-Zmacs environment.
		     (SCL:ACCEPT `((FS:PATHNAME) :DEFAULT-TYPE "QWABL"
				   :DEFAULT-VERSION NIL :DIRECTION :WRITE)
				 :DEFAULT (FS:DEFAULT-PATHNAME)
				 :PROMPT " Save word abbrevs to"))))
	 (COM-WRITE-WORD-ABBREV-FILE-INTERNAL *WORD-ABBREV-FILE-NAME*))))

(DEFUN COM-WRITE-WORD-ABBREV-FILE-INTERNAL (FN)
  (WITH-OPEN-FILE (STREAM FN :DIRECTION :OUTPUT)
    (WRITE-QWABL STREAM)
    (CLOSE STREAM)
    (TYPEIN-LINE "Written: ~A" (FUNCALL STREAM ':TRUENAME)))
  (SETQ *WORD-ABBREV-FILE-NAME* FN
	*WORD-ABBREV-FILE-TICK* (TICK)))


;; Minor modes

(DEFMINOR COM-ELECTRIC-SHIFT-LOCK-MODE ELECTRIC-SHIFT-LOCK-MODE "Electric Shift-lock" 5
          "Uppercase things other than comments and strings" ()
  (COMMAND-HOOK 'SHIFT-LOCK-HOOK *COMMAND-HOOK*))

(DEFMINOR COM-ELECTRIC-CHARACTER-STYLE-LOCK-MODE ELECTRIC-CHARACTER-STYLE-LOCK-MODE
	  "Electric Character-style-lock" 5
          "Put comments in italic" ()
  (COMMAND-HOOK 'CHARACTER-STYLE-LOCK-HOOK *COMMAND-HOOK*)
  (COMMAND-HOOK 'CHARACTER-STYLE-LOCK-ENTER-COMMENT-HOOK *ENTER-COMMENT-HOOK*))

(DEFVAR *SHIFT-LOCK-HOOK-LAST-LINE* NIL)	
(DEFVAR *SHIFT-LOCK-HOOK-DEFINITION-BEGINNING* NIL)

(DEFUN SHIFT-LOCK-HOOK-CACHED-SYNTACTIC-CONTEXT ()
  (DECLARE (VALUES STRING SLASH COMMENT))
  (LET ((POINT (POINT))
	(*LISP-PARSE-PREPARSED-FLAG* T))
    (UNLESS (AND (EQ *LAST-COMMAND-TYPE* 'SELF-INSERT)
		 (EQ (BP-LINE POINT) *SHIFT-LOCK-HOOK-LAST-LINE*))
      (SETQ *SHIFT-LOCK-HOOK-DEFINITION-BEGINNING* (FORWARD-DEFINITION POINT -1 T)
	    *SHIFT-LOCK-HOOK-LAST-LINE* (BP-LINE POINT)
	    *LISP-PARSE-PREPARSED-FLAG* NIL))
    (LISP-BP-SYNTACTIC-CONTEXT POINT *SHIFT-LOCK-HOOK-DEFINITION-BEGINNING*)))

(DEFPROP SHIFT-LOCK-HOOK 10 COMMAND-HOOK-PRIORITY)
(DEFUN SHIFT-LOCK-HOOK (CHAR)
  (WHEN (AND (CHARACTERP CHAR)			;needed because #\mouse-L will blow out
	     (ALPHA-CHAR-P CHAR)		; on alpha-char-p!!!  outrageous!!
	     (NEQ *INTERVAL* (WINDOW-INTERVAL *MINI-BUFFER-WINDOW*)))
    (MULTIPLE-VALUE-BIND (STRING SLASH COMMENT)
	(SHIFT-LOCK-HOOK-CACHED-SYNTACTIC-CONTEXT)
      (UNLESS (OR STRING SLASH COMMENT)
	(SETQ *LAST-COMMAND-CHAR* (IF *ELECTRIC-SHIFT-LOCK-XORS*
				      (CHAR-FLIPCASE CHAR)
				      (CHAR-UPCASE CHAR)))))))

(DEFCONST *COMMENTS-CHARACTER-STYLE-INDEX*
	  (SI:STYLE-INDEX (SI:PARSE-CHARACTER-STYLE '(NIL :ITALIC NIL)) T))

(DEFPROP CHARACTER-STYLE-LOCK-HOOK 10 COMMAND-HOOK-PRIORITY)
(DEFUN CHARACTER-STYLE-LOCK-HOOK (CHAR)
  (WHEN (NEQ *INTERVAL* (WINDOW-INTERVAL *MINI-BUFFER-WINDOW*))
      (LET ((NEW-CHARACTER-STYLE
	      (MULTIPLE-VALUE-BIND (STRING SLASH COMMENT)
		  (SHIFT-LOCK-HOOK-CACHED-SYNTACTIC-CONTEXT)
		(COND ((OR COMMENT
			   (AND (NOT (OR STRING SLASH))
				(CHARACTERP CHAR)	1;Ignore mouse "chars".
0				(= (LIST-SYNTAX CHAR) LIST-COMMENT)))
		       *COMMENTS-CHARACTER-STYLE-INDEX*)
		      ((ZMACS-BUFFER-P *INTERVAL*)
		       (SI:STYLE-INDEX (BUFFER-TYPEIN-CHARACTER-STYLE *INTERVAL*)))
		      (T 0)))))
	(UNLESS (= *STYLE* NEW-CHARACTER-STYLE)
	  (SETQ *STYLE* NEW-CHARACTER-STYLE)
	  (UPDATE-STYLE-NAME)))))

(DEFPROP CHARACTER-STYLE-LOCK-ENTER-COMMENT-HOOK 20 COMMAND-HOOK-PRIORITY)
(DEFUN CHARACTER-STYLE-LOCK-ENTER-COMMENT-HOOK ()
  (UNLESS (= *STYLE* *COMMENTS-CHARACTER-STYLE-INDEX*)
    (SETQ *STYLE* *COMMENTS-CHARACTER-STYLE-INDEX*)
    (UPDATE-STYLE-NAME)))

;It is useful to setq LISP-MODE-HOOK to this
(DEFUN ELECTRIC-SHIFT-LOCK-IF-APPROPRIATE ()
  (IF (SEND *INTERVAL* ':GET ':LOWERCASE)
      (TURN-OFF-MODE 'ELECTRIC-SHIFT-LOCK-MODE)
      (TURN-ON-MODE 'ELECTRIC-SHIFT-LOCK-MODE)))

;It is useful to setq LISP-MODE-HOOK to this
(DEFUN ELECTRIC-CHARACTER-STYLE-LOCK-IF-APPROPRIATE ()
  (TURN-ON-MODE 'ELECTRIC-CHARACTER-STYLE-LOCK-MODE))

;For compatibility with old init files
(DEFUN ELECTRIC-FONT-LOCK-IF-APPROPRIATE ()
  (ELECTRIC-CHARACTER-STYLE-LOCK-IF-APPROPRIATE))

;It is useful to setq TEXT-MODE-HOOK to this
(DEFUN AUTO-FILL-IF-APPROPRIATE ()
  (IF (SEND *INTERVAL* ':GET ':NOFILL)
      (TURN-OFF-MODE 'AUTO-FILL-MODE)
      (TURN-ON-MODE 'AUTO-FILL-MODE)))

(DEFMINOR COM-AUTO-FILL-LISP-COMMENTS-MODE AUTO-FILL-LISP-COMMENTS-MODE
	  "Fill-Comments" 2
          "Turn on auto filling of comments, but not code.
Without an argument, toggles the mode." ()
  (COMMAND-HOOK 'AUTO-FILL-LISP-COMMENTS-HOOK *POST-COMMAND-HOOK*))

(DEFVARIABLE *LISP-COMMENT-FILL-COLUMN* 680. :FIXNUM "Fill column for lisp comments.")

(DEFPROP AUTO-FILL-LISP-COMMENTS-HOOK 20 COMMAND-HOOK-PRIORITY)
(DEFUN AUTO-FILL-LISP-COMMENTS-HOOK (CHAR)
  (WHEN (AND (MEMQ CHAR *AUTO-FILL-ACTIVATION-CHARACTERS*)
	     (NOT *NUMERIC-ARG-P*)
	     (NEQ *INTERVAL* (WINDOW-INTERVAL *MINI-BUFFER-WINDOW*)))
    (WHEN (MULTIPLE-VALUE-BIND (NIL NIL COMMENT)
	      (SHIFT-LOCK-HOOK-CACHED-SYNTACTIC-CONTEXT)
	    COMMENT)
      (AUTO-FILL-HOOK CHAR '*LISP-COMMENT-FILL-COLUMN*))))
