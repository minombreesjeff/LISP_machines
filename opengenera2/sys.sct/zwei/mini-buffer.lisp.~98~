;;; -*- Mode: LISP; Syntax: Zetalisp; Package: ZWEI; Base: 8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;; Prompt line and typein line.
(DEFUN PROMPT-LINE (STRING &REST ARGS)
  (FUNCALL *MODE-LINE-WINDOW* ':CLOBBER)
  (FUNCALL *MODE-LINE-WINDOW* ':HOME-CURSOR)
  (FUNCALL *MODE-LINE-WINDOW* ':CLEAR-REST-OF-LINE)
  (*CATCH 'MODE-LINE-OVERFLOW
    (LEXPR-FUNCALL #'FORMAT *MODE-LINE-WINDOW* STRING ARGS)))

(DEFUN PROMPT-LINE-MORE (STRING &REST ARGS)
  (FUNCALL *MODE-LINE-WINDOW* ':CLOBBER)
  (*CATCH 'MODE-LINE-OVERFLOW
    (LEXPR-FUNCALL #'FORMAT *MODE-LINE-WINDOW* STRING ARGS)))

(DEFUN PROMPT-LINE-WITH-REDISPLAY (STRING &REST ARGS)
  (REDISPLAY *WINDOW* ':NONE)
  (LEXPR-FUNCALL #'PROMPT-LINE STRING ARGS))

(DEFUN TYPEIN-LINE-DURABLE (STRING &REST ARGS)
  (UNLESS (SEND-IF-HANDLES *TYPEIN-WINDOW* :PREPARE-FOR-TYPEOUT)
    (SEND *TYPEIN-WINDOW* :FRESH-LINE))
  (CL:APPLY #'FORMAT *TYPEIN-WINDOW* STRING ARGS)
  (SEND-IF-HANDLES *TYPEIN-WINDOW* :TYPEOUT-STAYS))

(DEFUN TYPEIN-LINE-MORE-DURABLE (STRING &REST ARGS)
  (SEND-IF-HANDLES *TYPEIN-WINDOW* :PREPARE-FOR-MORE-TYPEOUT)
  (CL:APPLY #'FORMAT *TYPEIN-WINDOW* STRING ARGS)
  (SEND-IF-HANDLES *TYPEIN-WINDOW* :TYPEOUT-STAYS))

(DEFUN TYPEIN-LINE (STRING &REST ARGS)
  (UNLESS (SEND *TYPEIN-WINDOW* ':SEND-IF-HANDLES ':PREPARE-FOR-TYPEOUT)
    (SEND *TYPEIN-WINDOW* ':FRESH-LINE))
  (LEXPR-FUNCALL #'FORMAT *TYPEIN-WINDOW* STRING ARGS))

(DEFUN TYPEIN-LINE-MORE (STRING &REST ARGS)
  (FUNCALL *TYPEIN-WINDOW* ':SEND-IF-HANDLES ':PREPARE-FOR-MORE-TYPEOUT)
  (LEXPR-FUNCALL #'FORMAT *TYPEIN-WINDOW* STRING ARGS))

(DEFUN TYPEIN-LINE-WITH-REDISPLAY (STRING &REST ARGS)
  (AND (WINDOW-READY-P *WINDOW*)	;E.g. searching inside mini-buffer
       (REDISPLAY *WINDOW* ':NONE))
  (LEXPR-FUNCALL #'TYPEIN-LINE STRING ARGS))

;;; TYPEIN-LINE-ACTIVATE is in MACROS

;;; Ask a Yes/No question in the typein-line.
(DEFUN TYPEIN-LINE-YES-OR-NO-P (FORMAT-STRING &REST FORMAT-ARGS)
  (LET ((QUERY-IO *TYPEIN-WINDOW*))
    (LEXPR-FUNCALL #'FQUERY `(:CHOICES ,FORMAT:YES-OR-NO-P-CHOICES
			      :FRESH-LINE NIL
			      :TYPE :READLINE)
		   FORMAT-STRING FORMAT-ARGS)))

;;; Noisily ask a Yes/No question in the typein-line.
(DEFUN TYPEIN-LINE-BEEP-YES-OR-NO-P (FORMAT-STRING &REST FORMAT-ARGS)
  (LET ((QUERY-IO *TYPEIN-WINDOW*))
    (LEXPR-FUNCALL #'FQUERY `(:CHOICES ,FORMAT:YES-OR-NO-P-CHOICES
			      :BEEP T
			      :FRESH-LINE NIL
			      :TYPE :READLINE)
		   FORMAT-STRING FORMAT-ARGS)))

;;; Ask a Yes/No question in the typein-line.
(DEFUN TYPEIN-LINE-Y-OR-N-P (FORMAT-STRING &REST FORMAT-ARGS)
  (LET ((QUERY-IO *TYPEIN-WINDOW*))
    (LEXPR-FUNCALL #'FQUERY `(:CHOICES ,FORMAT:Y-OR-N-P-CHOICES
			      :FRESH-LINE T
			      :TYPE :TYI)
		   FORMAT-STRING FORMAT-ARGS)))

;Read a line from the typein-line, defaulting if the user just hits Return.
;HISTORY is the history to use (NIL uses the default, and doesn't save).
;DEFAULT controls the default.  c-m-Y will always yank this.
;  a string -- this is the default
;  NIL -- there is no default (c-m-Y might still find something in the history)
;  T -- use the first thing in the history as a default (illegal if history is NIL)
;BLANK-LINE-DEFAULTS controls what happens if the user inputs a blank line.
;  T -- return the default instead (error if the default was NIL)
;  NIL -- don't treat blank lines differently from other input.
;  :ERROR -- a blank line is always an error
;FORMAT is applied to PROMPT-STRING, PROMPT-ARGS, and DEFAULT to make the prompt.
(DEFUN TYPEIN-LINE-HISTORY-READLINE (HISTORY DEFAULT BLANK-LINE-DEFAULTS
				     PROMPT-STRING &REST PROMPT-ARGS)
  (LET ((PUSH-DEFAULT (COND ((EQ DEFAULT T)
			     (SETQ DEFAULT (SEND HISTORY ':ELEMENT 0))
			     NIL)
			    (T DEFAULT)))
	(PROMPT (LEXPR-FUNCALL #'FORMAT NIL PROMPT-STRING
					    (APPEND PROMPT-ARGS (LIST DEFAULT))))
	(*CONTEXT-HISTORY* (OR HISTORY *DEFAULT-HISTORY*)))
    (MULTIPLE-VALUE-BIND (NIL NIL INTERVAL)
	(SEND *CONTEXT-HISTORY* ':FUNCALL-WITH-DEFAULT (AND PUSH-DEFAULT DEFAULT)
			#'EDIT-IN-MINI-BUFFER *MINI-BUFFER-COMTAB* NIL NIL (NCONS PROMPT))
      (COND ((OR (NOT BLANK-LINE-DEFAULTS)
		 (NOT (BP-= (INTERVAL-FIRST-BP INTERVAL) (INTERVAL-LAST-BP INTERVAL))))
	     (LET ((STRING (STRING-INTERVAL INTERVAL)))
	       (AND HISTORY (SEND HISTORY ':PUSH STRING))
	       STRING))
	    ((OR (NULL DEFAULT) (NEQ BLANK-LINE-DEFAULTS T))
	     (BARF "There is no default."))
	    (T (SEND *CONTEXT-HISTORY* ':CANONICALIZE-DEFAULT DEFAULT))))))

;Non-history-keeping version of the above.  This is semi-obsolete.
(DEFUN TYPEIN-LINE-READLINE (CTL-STRING &REST ARGS &AUX INTERVAL PROMPT)
  (SETQ PROMPT (IF (NULL ARGS) CTL-STRING
		   (LEXPR-FUNCALL #'FORMAT NIL CTL-STRING ARGS)))
  (MULTIPLE-VALUE (NIL NIL INTERVAL)
    (EDIT-IN-MINI-BUFFER *MINI-BUFFER-COMTAB* NIL NIL (AND PROMPT (NCONS PROMPT))))
  (STRING-INTERVAL INTERVAL))

;Read an expression from the typein-line, defaulting if the user just hits Return.
;HISTORY is the history to use (NIL uses the default, and doesn't save).
;DEFAULT controls the default.  c-m-Y will always yank this.
;  a string -- this is the default
;  NIL -- there is no default (c-m-Y might still find something in the history)
;  T -- use the first thing in the history as a default (illegal if history is NIL)
; NOTE WELL: the default is a string, not a Lisp object!
;BLANK-LINE-DEFAULTS controls what happens if the user inputs a blank line.
;  T -- return the default instead (error if the default was NIL)
;  NIL or :ERROR -- a blank line is always an error
;FORMAT is applied to PROMPT-STRING, PROMPT-ARGS, and DEFAULT to make the prompt.
(DEFUN TYPEIN-LINE-HISTORY-READ (HISTORY DEFAULT BLANK-LINE-DEFAULTS
				 PROMPT-STRING &REST PROMPT-ARGS)
  (LET ((PUSH-DEFAULT (COND ((EQ DEFAULT T)
			     (SETQ DEFAULT (SEND HISTORY ':ELEMENT 0))
			     NIL)
			    (T DEFAULT)))
	(PROMPT (LEXPR-FUNCALL #'FORMAT NIL PROMPT-STRING
					    (IF DEFAULT (APPEND PROMPT-ARGS (LIST DEFAULT))
						PROMPT-ARGS)))
	(*CONTEXT-HISTORY* (OR HISTORY *DEFAULT-HISTORY*))
	STRING)
    (MULTIPLE-VALUE-BIND (NIL NIL INTERVAL)
	(SEND *CONTEXT-HISTORY* ':FUNCALL-WITH-DEFAULT
				(AND PUSH-DEFAULT DEFAULT)
				#'EDIT-IN-MINI-BUFFER
				*MINI-BUFFER-COMTAB* NIL NIL (NCONS PROMPT))
      (COND ((NOT (BP-= (INTERVAL-FIRST-BP INTERVAL) (INTERVAL-LAST-BP INTERVAL)))
	     (SETQ STRING (STRING-INTERVAL INTERVAL))
	     (AND HISTORY (SEND HISTORY ':PUSH STRING)))
	    ((OR (NULL DEFAULT) (NEQ BLANK-LINE-DEFAULTS T))
	     (BARF "There is no default."))
	    (T (SETQ STRING (SEND *CONTEXT-HISTORY* ':CANONICALIZE-DEFAULT DEFAULT))))
      (BARF-ON-ERRORS (SYS:READ-ERROR)
	(LET ((SI:*SUPPRESS-READ-EVAL* T))
	  (READ-FROM-STRING STRING))))))

;Non-history-keeping version of the above
(DEFUN TYPEIN-LINE-READ (CTL-STRING &REST ARGS &AUX INTERVAL PROMPT)
  (SETQ PROMPT (IF (NULL ARGS) CTL-STRING
		   (LEXPR-FUNCALL #'FORMAT NIL CTL-STRING ARGS)))
  (MULTIPLE-VALUE (NIL NIL INTERVAL)
    (EDIT-IN-MINI-BUFFER *MINI-BUFFER-COMTAB* NIL NIL (AND PROMPT (NCONS PROMPT))))
  (BARF-ON-ERRORS (SYS:READ-ERROR)
    (LET ((SI:*SUPPRESS-READ-EVAL* T))
      (READ (OPEN-INTERVAL-STREAM INTERVAL)))))

(DEFUN TYPEIN-LINE-MULTI-LINE-READ (CTL-STRING &REST ARGS &AUX INTERVAL PROMPT)
  (SETQ PROMPT (IF (NULL ARGS) CTL-STRING
		   (LEXPR-FUNCALL #'FORMAT NIL CTL-STRING ARGS)))
  (MULTIPLE-VALUE (NIL NIL INTERVAL)
    (EDIT-IN-MINI-BUFFER *MINI-BUFFER-MULTI-LINE-COMTAB* NIL NIL (AND PROMPT (NCONS PROMPT))))
  (BARF-ON-ERRORS (SYS:READ-ERROR)
    (LET ((SI:*SUPPRESS-READ-EVAL* T))
      (READ (OPEN-INTERVAL-STREAM INTERVAL)))))

;Read a line from the typein-line, using both completion and histories.
;Returns two values: the string, and what it associated to (NIL if not in ALIST).
;HISTORY is the history to use (NIL uses the default, and doesn't save).
;  This must be a history whose elements are strings.
;DEFAULT controls the default.  c-m-Y will always yank this.
;  a string -- this is the default
;  NIL -- there is no default (c-m-Y might still find something in the history)
;  T -- use the first thing in the history as a default (illegal if history is NIL)
;  anything else -- something the history can canonicalize into a string
;BLANK-LINE-DEFAULTS controls what happens if the user inputs a blank line.
;  T -- return the default instead (error if the default was NIL)
;  NIL -- don't treat blank lines differently from other input.
;  :ERROR -- a blank line is always an error
;PROMPT is a string.  If a blank line will default, that fact is appended to the prompt.
; PROMPT can also be NIL meaning not to prompt.
;ALIST is the alist or aarray with respect to which completion occurs.
;IMPOSSIBLE-IS-OK-P controls what happens if the user inputs something not in the alist
;	followed by a carriage return.
;  NIL -- try to complete it.  If there is not exactly one completion, i.e. it is
;	unknown or ambiguous, barf and don't return.  This is the default.
;  RETURN -- try to complete it.  If it is ambiguous, barf and don't return.
;	But if there is no possible completion, return what the user typed and NIL.
;  T -- do not try to complete it, just return what the user typed and NIL.
;--- I think this next one should go away  (only READ-FUNCTION-SPEC-STRING uses it)
;  ALWAYS-STRING -- just return what the user typed and NIL even if it's in the alist.
;INITIAL-COMPLETE
;  NIL -- normal
;  T -- pretend the user typed the Complete key.
;  a string -- pretend the user typed the string and the Complete key.
;HELP-MESSAGE
;  a string -- printed on a separate line at the beginning of any help requested.
;  NIL -- default to "You are in the completing reader."
;DOCUMENTER
;  If non-NIL, a function that is called on an alist entry when help is requested
;  and there is exactly one possible completion.  The function should output
;  a description of that alist entry to *TYPEOUT-WINDOW*.
;MORE-PROMPT
;  If non-NIL, a string to be appended to the prompt after the default

(DEFUN TYPEIN-LINE-COMPLETING-READ (HISTORY DEFAULT BLANK-LINE-DEFAULTS PROMPT ALIST
				    &OPTIONAL IMPOSSIBLE-IS-OK-P INITIAL-COMPLETE
				    HELP-MESSAGE DOCUMENTER MORE-PROMPT)
  (DECLARE (VALUES STRING OBJECT))
  (LET* ((PUSH-DEFAULT (COND ((EQ DEFAULT T)
			      (SETQ DEFAULT (SEND HISTORY ':ELEMENT 0))
			      NIL)
			     (T DEFAULT)))
	 (*CONTEXT-HISTORY* (OR HISTORY *DEFAULT-HISTORY*))
	 (DEFAULT-STRING (SEND *CONTEXT-HISTORY* ':CANONICALIZE-DEFAULT DEFAULT)))
    (WITH-STACK-LIST (TOTAL-PROMPT "~A~@[ (Default is ~A)~]~@[ ~A~]"
				   PROMPT DEFAULT-STRING MORE-PROMPT)
      (LET ((X (SEND *CONTEXT-HISTORY* ':FUNCALL-WITH-DEFAULT (AND PUSH-DEFAULT DEFAULT)
		     #'COMPLETING-READ-FROM-MINI-BUFFER
		     TOTAL-PROMPT
		     ALIST IMPOSSIBLE-IS-OK-P INITIAL-COMPLETE HELP-MESSAGE DOCUMENTER)))
	(COND ((AND BLANK-LINE-DEFAULTS (EQUAL X ""))
	       (WHEN (OR (EQ BLANK-LINE-DEFAULTS ':ERROR) (NOT DEFAULT))
		 (BARF "There is no default."))
	       (VALUES DEFAULT-STRING
		       (CDR (ASS #'STRING-EQUAL DEFAULT-STRING
				 (IF (ARRAYP ALIST) (G-L-P ALIST) ALIST)))))
	      ((STRINGP X)
	       (AND HISTORY (SEND HISTORY ':PUSH X))
	       (VALUES X NIL))
	      (T
	       (AND HISTORY (SEND HISTORY ':PUSH (CAR X)))
	       (VALUES (CAR X) (CDR X))))))))

;;; Completing-reader and other mini-buffer stuff

(DEFCOM COM-END-OF-MINI-BUFFER "Terminates input from the typein line." ()
  (THROW 'RETURN-FROM-COMMAND-LOOP NIL))

;; The c-G command in the minibuffer.
(DEFCOM COM-MINI-BUFFER-BEEP "Aborts the current minibuffer typein.
If there is a numeric argument, get rid of it.
Otherwise, if there is a region, get rid of it.
Otherwise, if there is any text in the minibuffer, get rid of it.
Otherwise, when the minibuffer is already empty, quit the minibuffer." ()
  (BEEP)
  (COND (*NUMERIC-ARG-P*
	 (SETQ *MARK-STAYS* T)
	 DIS-NONE)
	((WINDOW-MARK-P *WINDOW*)
	 DIS-NONE)
	((BP-= (INTERVAL-FIRST-BP *INTERVAL*) (INTERVAL-LAST-BP *INTERVAL*))
	 (THROW 'TOP-LEVEL T))
	(T
	 (DELETE-INTERVAL *INTERVAL*)
	 DIS-TEXT)))

(DEFUN EDIT-IN-MINI-BUFFER (&OPTIONAL (COMTAB *MINI-BUFFER-COMTAB*)
				      INITIAL-CONTENTS INITIAL-CHAR-POS MODE-LINE-LIST)
  (CALL-IN-MINI-BUFFER
    (LAMBDA (INTERVAL)
      (VALUES (COMMAND-LOOP COMTAB *MINI-BUFFER-WINDOW* 'EDITOR "Minibuffer Command Level")
	      *MINI-BUFFER-WINDOW*
	      INTERVAL))
    MODE-LINE-LIST INITIAL-CONTENTS INITIAL-CHAR-POS))

(DEFUN CALL-IN-MINI-BUFFER (FUNCTION MODE-LINE-LIST INITIAL-CONTENTS INITIAL-CHAR-POS
			    &AUX (*MINI-BUFFER-TO-BE-SAVED* (NULL *MINI-BUFFER-COMMAND*))
				 (INTERVAL (WINDOW-INTERVAL *MINI-BUFFER-WINDOW*)))
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  ;; Recursive mini-buffers don't work
  (AND *MINI-BUFFER-COMMAND-IN-PROGRESS*
       (BARF "Mini-buffer entered recursively"))
  ;; Replay next mini buffer from previous command, if requested
  (WHEN *MINI-BUFFER-REPEATED-COMMAND*
    (LET ((STRING (POP *MINI-BUFFER-REPEATED-COMMAND*)))
      ;; If both the history and the caller are trying to specify an initial-contents,
      ;; arbitrate between them.  Assume the caller may be specifying a more up-to-date
      ;; piece of information, but the history may be replaying the result of the user
      ;; appending additional data to the initial contents.
      (WHEN (OR (NULL INITIAL-CONTENTS)
		(%STRING-EQUAL STRING 0 INITIAL-CONTENTS 0 (STRING-LENGTH INITIAL-CONTENTS)))
	(SETQ INITIAL-CONTENTS STRING)
	(SETQ INITIAL-CHAR-POS (STRING-LENGTH STRING)))))
  ;; Prepare the initial contents of the mini buffer
  (DELETE-INTERVAL (WINDOW-INTERVAL *MINI-BUFFER-WINDOW*))
  (MUST-REDISPLAY *MINI-BUFFER-WINDOW* DIS-TEXT)
  (LET ((*INTERVAL* INTERVAL)
	(BP (WINDOW-POINT *MINI-BUFFER-WINDOW*)))
    (WHEN INITIAL-CONTENTS
      (INSERT BP INITIAL-CONTENTS))
    (WHEN INITIAL-CHAR-POS
      (MOVE-BP BP (FORWARD-CHAR BP INITIAL-CHAR-POS))))
  ;; If this is the first mini buffer for a command, initialize history element
  (UNLESS *MINI-BUFFER-COMMAND*
    (SETQ *MINI-BUFFER-COMMAND* `((,*CURRENT-COMMAND*
				   ,*NUMERIC-ARG-P*
				   ,*NUMERIC-ARG*
				   ,*LAST-COMMAND-CHAR*))))
  ;; Enter a recursive editor
  (UNWIND-PROTECT
    (LET ((*MINI-BUFFER-COMMAND-IN-PROGRESS* *MINI-BUFFER-COMMAND*)
	  (*MINI-BUFFER-USING-COMMAND-LOOP* *CURRENT-COMMAND-LOOP*)
	  (*MAJOR-MODE* (IF NIL ;(TYPEP *MAJOR-MODE* 'SYNTAX-EDITOR-MIXIN)
			    (MAJOR-MODE-FROM-KEYWORD :LISP)
			  *MAJOR-MODE*))
	  (PACKAGE PACKAGE)
	  (*MODE-LINE-LIST* MODE-LINE-LIST))
      (FUNCALL FUNCTION INTERVAL))
    ;; Save what was read, in the minibuffer history
    (RPLACD (LAST *MINI-BUFFER-COMMAND*) (NCONS (STRING-INTERVAL INTERVAL)))
    (WHEN *MINI-BUFFER-TO-BE-SAVED*
      (SEND *MINI-BUFFER-HISTORY* ':PUSH *MINI-BUFFER-COMMAND*))
    ;; Switch back to normal window configuration
    (DISAPPEAR-MINI-BUFFER-WINDOW)
;   (REDISPLAY-MODE-LINE)
    (LET ((TYPEOUT-WINDOW (TV:ESSENTIAL-WINDOW-WITH-TYPEOUT-MIXIN-TYPEOUT-WINDOW
			    (WINDOW-SHEET *WINDOW*))))
      (IF (AND TYPEOUT-WINDOW
	       (TV:BASIC-TYPEOUT-WINDOW-BOTTOM-REACHED TYPEOUT-WINDOW))
	  (SEND TYPEOUT-WINDOW :SELECT-RELATIVE)
	(SELECT-WINDOW *WINDOW*)))))

(DEFCOM COM-RECURSIVE-EDIT-ABORT "Quits out of recursive edit right away" ()
  ;; Don't make trivial entries on the minibuffer history, they annoy people.
  (AND *MINI-BUFFER-COMMAND-IN-PROGRESS*
       (BP-= (INTERVAL-FIRST-BP *INTERVAL*) (INTERVAL-LAST-BP *INTERVAL*))
       (SETQ *MINI-BUFFER-TO-BE-SAVED* NIL))
  (THROW 'TOP-LEVEL T))

(DEFVAR *LAST-MINI-BUFFER-MATCH-STRING* NIL)
(DEFCOM COM-REPEAT-LAST-MINI-BUFFER-COMMAND
	"Repeats a recent minibuffer command.
A numeric argument does the nth previous one.  An argument of 0 lists which
ones are remembered." ()
  (COND ((ZEROP *NUMERIC-ARG*)
	 (DISPLAY-HISTORY-MENU *TYPEOUT-WINDOW* *MINI-BUFFER-HISTORY*
			       *HISTORY-MENU-LENGTH*)
	 (SETQ *MARK-STAYS* T)
	 DIS-NONE)
	(T
	 (SETQ *LAST-MINI-BUFFER-MATCH-STRING* NIL)
	 (RE-EXECUTE-MINI-BUFFER-COMMAND (SEND *MINI-BUFFER-HISTORY* ':YANK
					       (AND *NUMERIC-ARG-P* *NUMERIC-ARG*))))))

;(TV:ADD-TYPEOUT-ITEM-TYPE *ZWEI-TYPEOUT-COMMAND-ALIST* DISPLAY-REST-OF-HISTORY
;			  "Display rest of history" DISPLAY-REST-OF-HISTORY T
;			  "Display all the remaining elements of this history.")

(SCL:DEFINE-PRESENTATION-TYPE DISPLAY-REST-OF-HISTORY ()
   :EXPANDER 'T
   :PRINTER ((IGNORE STREAM)
	     (CL:WRITE-STRING "(More items in history.)" STREAM)))

(DW:DEFINE-PRESENTATION-ACTION DISPLAY-REST-OF-HISTORY
   (DISPLAY-REST-OF-HISTORY SI:INPUT-EDITOR
    :DOCUMENTATION "Display rest of this history")
   (DISPLAY-REST-OF-HISTORY)
  (SI:WITH-IE-TYPEOUT-IF-APPROPRIATE ()
    (DISPLAY-REST-OF-HISTORY DISPLAY-REST-OF-HISTORY)))

;(TV:ADD-TYPEOUT-ITEM-TYPE *TYPEOUT-COMMAND-ALIST* :MINI-BUFFER-COMMAND "Re-execute"
;			  RE-EXECUTE-MINI-BUFFER-COMMAND-FROM-MOUSE T
;			  "Re-execute this command.")

(DEFINE-PRESENTATION-TO-EDITOR-COMMAND-TRANSLATOR RE-EXECUTE-MINI-BUFFER-COMMAND-FROM-MOUSE
						  (MINI-BUFFER-COMMAND
						    "Re-execute command"
						    *ZMACS-COMTAB*
						    :GESTURE :SELECT)
						  (MINI-BUFFER-COMMAND)
  `(RE-EXECUTE-MINI-BUFFER-COMMAND-FROM-MOUSE ,MINI-BUFFER-COMMAND))

(DEFUN RE-EXECUTE-MINI-BUFFER-COMMAND-FROM-MOUSE (COMMAND)
  (LET (*CURRENT-COMMAND*)			;Don't SETQ the global value
    (LET ((HISTORY (CAR COMMAND)))
      (SETQ COMMAND (CDR COMMAND))
      (SEND HISTORY :NOTE-ELEMENT-YANKED COMMAND)
      (RE-EXECUTE-MINI-BUFFER-COMMAND COMMAND))))

(DEFUN RE-EXECUTE-MINI-BUFFER-COMMAND (*MINI-BUFFER-REPEATED-COMMAND*)
  (WHEN (OR (NULL *MINI-BUFFER-REPEATED-COMMAND*)
	    (NULL (CAAR *MINI-BUFFER-REPEATED-COMMAND*)))
    (BARF "No previous command"))
  (WHEN *MINI-BUFFER-COMMAND-IN-PROGRESS*
    (SETQ *YANKED-MINI-BUFFER-COMMAND*
	  `(:EXECUTE-AS-COMMAND
	     RE-EXECUTE-MINI-BUFFER-COMMAND ,*MINI-BUFFER-REPEATED-COMMAND*))
    (SETQ *MINI-BUFFER-TO-BE-SAVED* NIL)
    (THROW 'TOP-LEVEL T))
  (OR (COMMAND-AVAILABLE (CAAR *MINI-BUFFER-REPEATED-COMMAND*))
      (BARF "~A is not available in the current context"
	    (GET (CAAR *MINI-BUFFER-REPEATED-COMMAND*) 'COMMAND-NAME)))
  (POP *MINI-BUFFER-REPEATED-COMMAND*
       `(,*CURRENT-COMMAND* ,*NUMERIC-ARG-P* ,*NUMERIC-ARG* ,*LAST-COMMAND-CHAR*))
  (FUNCALL *CURRENT-COMMAND*))

(DEFCOM COM-MINI-BUFFER-OR-YANK-POP "Use a previous element of the most recent history.
The most recent command must be either a yanking command or use of the minibuffer.
In the case of a yanking command, the text that was yanked
by that command, i.e. the text between point and mark, is replaced by the
previous element of the relevant history.
In the case of the minibuffer, the current minibuffer command is aborted
and it or a previous command is re-executed.

In either case, the history is rotated to bring this element to the top.
A numeric argument of zero displays the history.
A positive numeric argument moves to that much older a history element.
A negative numeric argument moves to a newer history element; this
only makes sense after the history has been rotated." ()
  (COND ((EQ *LAST-COMMAND-TYPE* 'YANK)
	 (COM-YANK-POP))			;Ordinary meta-Y
	((OR (EQ *LAST-COMMAND-TYPE* 'FIRST)	     
	     (BP-= (INTERVAL-FIRST-BP *INTERVAL*) (INTERVAL-LAST-BP *INTERVAL*)))
	 ;; We just entered a minibuffer, or else the minibuffer is empty.
	 ;; If this is the first minibuffer of a command, switch to previous command.
	 ;; If this is not the first minibuffer, go back to the first one (if no numeric arg).
	 (COND ((AND (NOT *NUMERIC-ARG-P*)
		     (CDR *MINI-BUFFER-COMMAND-IN-PROGRESS*))
		(RE-EXECUTE-MINI-BUFFER-COMMAND *MINI-BUFFER-COMMAND-IN-PROGRESS*))
	       ((ZEROP *NUMERIC-ARG*)
		(DISPLAY-HISTORY-MENU *TYPEOUT-WINDOW* *MINI-BUFFER-HISTORY*
				      *HISTORY-MENU-LENGTH* T)
		(SETQ *CURRENT-COMMAND-TYPE* 'FIRST)
		DIS-NONE)
	       (T (RE-EXECUTE-MINI-BUFFER-COMMAND
		    (LET ((*COMTAB* (SYMEVAL-IN-INSTANCE *MINI-BUFFER-USING-COMMAND-LOOP*
							 '*COMTAB*)))
		      (SEND *MINI-BUFFER-HISTORY* ':YANK-NEXT *NUMERIC-ARG*))))))
	(T (BARF))))

(DEFCOM COM-REPEAT-LAST-MATCHING-MINI-BUFFER-COMMAND
	"Repeats a recent minibuffer command that contains a substring.
A numeric argument does the nth previous one.  An argument of 0 lists which
ones are remembered." ()
  (COND ((ZEROP *NUMERIC-ARG*)
	 (DISPLAY-HISTORY-MENU *TYPEOUT-WINDOW* *MINI-BUFFER-HISTORY*
			       *HISTORY-MENU-LENGTH* NIL ':MINI-BUFFER-COMMAND
			       (QUERY-READ-STRING "List commands that match: "))
	 (SETQ *MARK-STAYS* T)
	 DIS-NONE)
	(T
	 (LET ((MATCH (LET ((*MINI-BUFFER-COMMAND* (NCONS NIL)))
			(QUERY-READ-STRING "Re-execute command that matches: "))))
	   (SETQ *LAST-MINI-BUFFER-MATCH-STRING* MATCH)
	   (RE-EXECUTE-MINI-BUFFER-COMMAND
	     (SEND *MINI-BUFFER-HISTORY* :YANK-MATCHING
		   MATCH
		   (1+ *NUMERIC-ARG*)))))))	;1+ is to skip self, already in history

(DEFCOM COM-MINI-BUFFER-OR-YANK-POP-MATCHING
	"Use a previous element of the most recent history that contains a substring.
The most recent command must be either a yanking command or use of the minibuffer.
In the case of a yanking command, the text that was yanked
by that command, i.e. the text between point and mark, is replaced by a
previous element of the relevant history.
In the case of the minibuffer, the current minibuffer command is aborted
a previous command is re-executed.

In either case, the history is rotated to bring this element to the top.
A numeric argument of zero displays the history.
A positive numeric argument moves to that much older a history element.
A negative numeric argument moves to a newer history element; this
only makes sense after the history has been rotated." ()
  (COND ((EQ *LAST-COMMAND-TYPE* 'YANK)
	 (COM-YANK-POP-MATCHING))			;Ordinary meta-shift-Y
	((OR (EQ *LAST-COMMAND-TYPE* 'FIRST)	     
	     (BP-= (INTERVAL-FIRST-BP *INTERVAL*) (INTERVAL-LAST-BP *INTERVAL*)))
	 ;; We just entered a minibuffer, or else the minibuffer is empty.
	 ;; Switch to a previous command (never restart the current command)
	 (COND ((ZEROP *NUMERIC-ARG*)
		(DISPLAY-HISTORY-MENU *TYPEOUT-WINDOW* *MINI-BUFFER-HISTORY*
				      *HISTORY-MENU-LENGTH* T ':MINI-BUFFER-COMMAND
				      (OR *LAST-MINI-BUFFER-MATCH-STRING*
					  (QUERY-READ-STRING "List commands that match: ")))
		(SETQ *CURRENT-COMMAND-TYPE* 'FIRST)
		DIS-NONE)
	       (T (RE-EXECUTE-MINI-BUFFER-COMMAND
		    (LET ((*COMTAB* (SYMEVAL-IN-INSTANCE *MINI-BUFFER-USING-COMMAND-LOOP*
							 '*COMTAB*)))
		      (SEND *MINI-BUFFER-HISTORY* :YANK-NEXT *NUMERIC-ARG*
			    (OR *LAST-MINI-BUFFER-MATCH-STRING*
				(QUERY-READ-STRING "Re-execute command that matches: "))))))))
	(T (BARF))))

;Call FQUERY, but save the response in the mini-buffer history
(DEFUN FQUERY-WITH-MINI-BUFFER-HISTORY (OPTIONS &OPTIONAL FORMAT-STRING &REST FORMAT-ARGS)
  (LET* ((TYPE-FUNCTION (GET (OR (GET (LOCF OPTIONS) ':TYPE) ':TYI) 'FORMAT:FQUERY-FUNCTION))
	 (CHOICES (OR (GET (LOCF OPTIONS) ':CHOICES) FORMAT:Y-OR-N-P-CHOICES))
	 (CHOICE
	   (OR (AND *MINI-BUFFER-REPEATED-COMMAND*
		    ;; Replaying a mini-buffer command, retrieve the saved typein
		    (LET ((TYPEIN (POP *MINI-BUFFER-REPEATED-COMMAND*)))
		      (WHEN (CHARACTERP (CADAR CHOICES))	;Single-character input wanted
			(SETQ TYPEIN (AREF TYPEIN 0)))
		      (LOOP FOR CHOICE IN CHOICES
			    WHEN (EQ CHOICE ':ANY)
			      RETURN TYPEIN
			    WHEN (FUNCALL TYPE-FUNCTION ':MEMBER TYPEIN (CDR CHOICE))
			      RETURN (IF (LISTP (CAR CHOICE)) (CAAR CHOICE) (CAR CHOICE)))))
	       ;; Not replaying, or replay failed, ask user
	       (LEXPR-FUNCALL #'FQUERY OPTIONS FORMAT-STRING FORMAT-ARGS)))
	 (TYPEIN
	   ;; Retrieve the typein
	   (LOOP FOR X IN CHOICES
		 WHEN (EQ (IF (LISTP (CAR X)) (CAAR X) (CAR X)) CHOICE)
		   RETURN (CADR X)
		 FINALLY (RETURN CHOICE))))
    ;; Save the typein as a string
    (UNLESS *MINI-BUFFER-COMMAND*
      (SETQ *MINI-BUFFER-COMMAND* `((,*CURRENT-COMMAND*
				     ,*NUMERIC-ARG-P*
				     ,*NUMERIC-ARG*
				     ,*LAST-COMMAND-CHAR*)))
      (SEND *MINI-BUFFER-HISTORY* ':PUSH *MINI-BUFFER-COMMAND*))
    (RPLACD (LAST *MINI-BUFFER-COMMAND*) (NCONS (STRING TYPEIN)))
    CHOICE))

;;; Compatibility
(SCL:DEFINE-PRESENTATION-TYPE COMPLETION-ELEMENT ((ALIST)
						  &KEY HELP-MESSAGE DOCUMENTER
						       IMPOSSIBLE-IS-OK-P)
  :DESCRIPTION "a completion"
  :PRINTER ((THING STREAM)
	    ;;--- The things we do to be compatible...  --SWM
	    (IF (STRINGP THING)
		(CL:WRITE-STRING THING STREAM)
	      (BLOCK PRINTER
		(CL:MAP NIL #'(LAMBDA (ELT)
				(DESTRUCTURING-BIND (NAME . REST) ELT
				  (WHEN (EQUAL REST THING)
				    (CL:WRITE-STRING NAME STREAM)
				    (RETURN-FROM PRINTER))))
			ALIST)
		(IF (LISTP THING)
		    (CL:WRITE-STRING (FIRST THING) STREAM)
		  (CL:WRITE-STRING THING STREAM)))))
  :PARSER ((STREAM &KEY TYPE)
	   (DW:WITH-ACCEPT-HELP-IF HELP-MESSAGE ((:SUBHELP HELP-MESSAGE))
	     (MULTIPLE-VALUE-BIND (STRING SUCCESS OBJECT)
		 (BLOCK CATCH-NULL-STRING
		   (CONDITION-BIND
		     ((DW:INPUT-NOT-OF-REQUIRED-TYPE
			(LAMBDA (E)
			  (WHEN (STRING-EQUAL (SEND E :STRING) "")
			    (RETURN-FROM CATCH-NULL-STRING (VALUES "" NIL))))))
		     (DW::COMPLETE-INPUT-FROM-AARRAY
		       ALIST STREAM
		       :TYPE TYPE
		       :ALLOW-ANY-INPUT (NOT (MEMQ IMPOSSIBLE-IS-OK-P '(RETURN NIL)))
		       ;; All these old-style guys have to be treated this way
		       :WHOLE-CDR T
		       :ENABLE-FORCED-RETURN (EQ IMPOSSIBLE-IS-OK-P 'RETURN)
		       :POSSIBILITY-PRINTER
		         #'(LAMBDA (STRING OBJECT STREAM &OPTIONAL PRESENTATION-TYPE)
			     (IGNORE PRESENTATION-TYPE)
			     (DW:WITH-OUTPUT-AS-PRESENTATION (:STREAM STREAM
							      :TYPE TYPE
							      :OBJECT OBJECT)
			       (CL:WRITE-STRING STRING STREAM)))
		       :DOCUMENTER
		         (AND DOCUMENTER
			      #'(LAMBDA (THING STANDARD-OUTPUT)
				  ;; Since the documenter doesn't
				  ;; get a stream presumably it
				  ;; knows which stream to write
				  ;; to but just in case, we'll
				  ;; bind standard-output here.
				  (FUNCALL DOCUMENTER THING)))
		       :DOCUMENT (AND DOCUMENTER :IF-UNIQUE))))
	       (VALUES
		 (COND ((AND SUCCESS (NULL STRING)
			     (NOT (NULL OBJECT)))
			OBJECT)
		       ((EQ IMPOSSIBLE-IS-OK-P 'ALWAYS-STRING)
			STRING)
		       ((NOT SUCCESS)
			STRING)
		       (T
			(IF (ARRAYP ALIST)
			    (SI:AARRAY-LOOKUP STRING ALIST)
			    (ASS 'STRING-EQUAL STRING ALIST)))))))))

(DEFUN COMPLETING-READ-FROM-MINI-BUFFER (PROMPT ALIST &OPTIONAL IMPOSSIBLE-IS-OK-P
								INITIAL-COMPLETE
								HELP-MESSAGE
								DOCUMENTER)
  (TYPEIN-LINE-ACCEPT `((COMPLETION-ELEMENT ,ALIST)
			:IMPOSSIBLE-IS-OK-P ,IMPOSSIBLE-IS-OK-P
			:HELP-MESSAGE ,HELP-MESSAGE :DOCUMENTER ,DOCUMENTER)
		      :PROMPT PROMPT :PROMPT-MODE :RAW
		      :INITIAL-COMPLETE INITIAL-COMPLETE))

#||	;Obsolete completion interface.  Aarrays and internal completer still used.

(DEFVAR *COMPLETING-ALIST*)
(DEFVAR *COMPLETING-IMPOSSIBLE-IS-OK-P*)
(DEFVAR *COMPLETING-HELP-MESSAGE*)
(DEFVAR *COMPLETING-DOCUMENTER*)

(DEFUN COMPLETING-READ-FROM-MINI-BUFFER (PROMPT *COMPLETING-ALIST*
					 &OPTIONAL *COMPLETING-IMPOSSIBLE-IS-OK-P*
						   INITIAL-COMPLETE
						   *COMPLETING-HELP-MESSAGE*
						   *COMPLETING-DOCUMENTER*
					 &AUX CONTENTS CHAR-POS)
  (AND INITIAL-COMPLETE
       (MULTIPLE-VALUE (CONTENTS NIL NIL CHAR-POS)
	 (COMPLETE-STRING (IF (EQ INITIAL-COMPLETE T) "" INITIAL-COMPLETE)
			  *COMPLETING-ALIST* *COMPLETING-DELIMS* T
			  (IF (STRINGP INITIAL-COMPLETE)
			      (STRING-LENGTH INITIAL-COMPLETE)
			      0))))
  (EDIT-IN-MINI-BUFFER *COMPLETING-READER-COMTAB* CONTENTS CHAR-POS
		       (IF *COMPLETING-ALIST*
			   (IF PROMPT `(,PROMPT (:RIGHT-FLUSH " (Completion)"))
			       '(:RIGHT-FLUSH " (Completion)"))
			   (NCONS PROMPT))))

;; Note that WINDOW is a window system type window, not a ZWEI-WINDOW
(DEFUN COMPLETING-READ (WINDOW *COMPLETING-ALIST*
			&OPTIONAL PROMPT *COMPLETING-IMPOSSIBLE-IS-OK-P*
			INITIAL-COMPLETE *COMPLETING-HELP-MESSAGE*
			*COMPLETING-DOCUMENTER*
			&AUX ZWEI-WINDOW CONTENTS CHAR-POS)
  (AND INITIAL-COMPLETE
       (MULTIPLE-VALUE (CONTENTS NIL NIL NIL CHAR-POS)
	 (COMPLETE-STRING "" *COMPLETING-ALIST* *COMPLETING-DELIMS* T 0)))
  (AND PROMPT (SEND WINDOW ':SET-LABEL PROMPT))
  (SETQ ZWEI-WINDOW (SEND WINDOW ':ZWEI-WINDOW))
  (LET ((INTERVAL (WINDOW-INTERVAL ZWEI-WINDOW)))
    (IF INTERVAL (DELETE-INTERVAL INTERVAL)
	(SET-WINDOW-INTERVAL ZWEI-WINDOW (CREATE-INTERVAL NIL NIL 'TOP-LEVEL-NODE))))
  (SETF (WINDOW-REDISPLAY-DEGREE ZWEI-WINDOW) DIS-ALL)
  (AND CONTENTS (NOT (EQUAL CONTENTS ""))
       (LET ((*INTERVAL* (WINDOW-INTERVAL ZWEI-WINDOW))
	     (BP (WINDOW-POINT ZWEI-WINDOW)))
	 (INSERT BP CONTENTS)
	 (AND CHAR-POS (MOVE-BP BP (FORWARD-CHAR BP CHAR-POS)))))
  (LET ((OLD-STATUS (SEND WINDOW ':STATUS)))
    (UNWIND-PROTECT
      (TV:WINDOW-CALL (WINDOW)
	(COMMAND-LOOP *COMPLETING-READER-COMTAB* ZWEI-WINDOW
		      'TOP-LEVEL-EDITOR "Completing Reader Top Level"))
      (SEND WINDOW ':SET-STATUS OLD-STATUS))))

(DEFCOM COM-COMPLETE "Attempts to complete the current line." ()
  (COMPLETE-LINE T T)
  DIS-TEXT)

(DEFCOM COM-SELF-INSERT-AND-COMPLETE
	"Attempts to complete after inserting break character." ()
  (OR (END-LINE-P (POINT)) (INSERT-MOVING-POINT *LAST-COMMAND-CHAR*))
  (COMPLETE-LINE NIL NIL *LAST-COMMAND-CHAR*)
  DIS-TEXT)

(DEFCOM COM-COMPLETE-AND-EXIT "Attempts to complete and returns if unique." ()
  (COMPLETE-AND-EXIT-INTERNAL T)
  DIS-TEXT)

(DEFCOM COM-COMPLETE-AND-EXIT-IF-UNIQUE "Attempts to complete and returns only if unique." ()
  (LET ((*COMPLETING-IMPOSSIBLE-IS-OK-P* NIL))
    (COMPLETE-AND-EXIT-INTERNAL NIL))
  DIS-TEXT)

(DEFUN COMPLETE-AND-EXIT-INTERNAL (IGNORE-RIGHT-SPACE)
  (PROG ((LINE (BP-LINE (WINDOW-START-BP *WINDOW*)))
	 COMPLETION VAL)
    (SETQ VAL (COND ((ZEROP (LINE-LENGTH LINE))	;Allow typing just CR
		     "")
		    ((EQ 'NIL *COMPLETING-IMPOSSIBLE-IS-OK-P*)
		     ;; If the string doesn't complete at all, return NIL
		     (SETQ COMPLETION (COMPLETE-LINE T NIL NIL IGNORE-RIGHT-SPACE))
		     (COND ((NULL (CDR COMPLETION))
			    (SETQ VAL (CAR COMPLETION)))
			   ((NULL (SETQ VAL (ASSOC LINE COMPLETION))) ;Something ambiguous,
			    (RETURN NIL)))	;return for something good
		     (MUST-REDISPLAY *WINDOW* DIS-TEXT)	;Typed something good
		     (AND (WINDOW-READY-P *WINDOW*) (REDISPLAY *WINDOW* ':NONE))
		     VAL)
		    ((EQ 'RETURN *COMPLETING-IMPOSSIBLE-IS-OK-P*)
		     ;; If the string doesn't complete at all, throw out.
		     (SETQ COMPLETION (COMPLETE-LINE T NIL NIL IGNORE-RIGHT-SPACE))
		     (COND ((NULL COMPLETION)
			    (SETQ VAL (STRING-APPEND LINE)))
			   ((NULL (CDR COMPLETION))
			    (SETQ VAL (CAR COMPLETION)))
			   ((NULL (SETQ VAL (ASSOC LINE COMPLETION))) ;Something ambiguous,
			    (RETURN NIL)))	;return for something good
		     (MUST-REDISPLAY *WINDOW* DIS-TEXT)	;Typed something good
		     (AND (WINDOW-READY-P *WINDOW*) (REDISPLAY *WINDOW* ':NONE))
		     VAL)
		    ((AND (NEQ *COMPLETING-IMPOSSIBLE-IS-OK-P* 'ALWAYS-STRING)
			  (SETQ COMPLETION
				(IF (ARRAYP *COMPLETING-ALIST*)
				    (STRING-IN-AARRAY-P LINE *COMPLETING-ALIST*)
				    (ASS 'STRING-EQUAL LINE *COMPLETING-ALIST*))))
		     COMPLETION)
		    (T
		     (STRING-APPEND LINE))))
    (THROW 'RETURN-FROM-COMMAND-LOOP VAL)))

(DEFCOM COM-LIST-COMPLETIONS "Displays a menu of possible completions for string so far." ()
  (LET (POSS)
    (MULTIPLE-VALUE (NIL POSS)
      (COMPLETE-STRING (BP-LINE (POINT)) *COMPLETING-ALIST* *COMPLETING-DELIMS*))
    (OR POSS (BARF))
    (AND *COMPLETING-HELP-MESSAGE* (FORMAT *TYPEOUT-WINDOW* "~&~A" *COMPLETING-HELP-MESSAGE*))
    (LIST-COMPLETIONS-INTERNAL POSS))
  DIS-NONE)

(DEFUN LIST-COMPLETIONS-INTERNAL (POSS &OPTIONAL (ITEM-COMPLETION 'COMPLETION))
  (SI:DISPLAY-COMPLETIONS *TYPEOUT-WINDOW* POSS ITEM-COMPLETION *COMPLETING-DOCUMENTER*
			  (ARRAYP *COMPLETING-ALIST*))
  (FORMAT *TYPEOUT-WINDOW* "~&~%"))

(DEFCOM COM-COMPLETION-APROPOS
	"Does Apropos within the completions of what has been typed." ()
  (LET ((LINE (BP-LINE (POINT)))
	FUNCTION)
    (LET (IDX)
      (IF (SETQ IDX (STRING-SEARCH-SET *COMPLETING-DELIMS* LINE))
	  (SETQ LINE (DELETE ""
			     (DO ((I 0)
				  (J IDX)
				  (LIST))
				 (NIL)
			       (PUSH (SUBSTRING LINE I J) LIST)
			       (OR J
				   (RETURN (NREVERSE LIST)))
			       (SETQ I (1+ J)
				     J (STRING-SEARCH-SET *COMPLETING-DELIMS* LINE I))))
		FUNCTION 'FSM-STRING-SEARCH)
	  (SETQ FUNCTION 'STRING-SEARCH)))
    (AND *COMPLETING-HELP-MESSAGE*
	 (FORMAT *TYPEOUT-WINDOW* "~&~A" *COMPLETING-HELP-MESSAGE*))
    (FORMAT *TYPEOUT-WINDOW*
	    "~&These are the completions containing the substring~:[ /"~A/"~;~{ /"~A/"~^ or~}~]:~2%"
	    (LISTP LINE) LINE)
    (AND (LISTP LINE)
	 (SETQ LINE (LIST LINE NIL NIL)))
    (DO ((ALIST (IF (ARRAYP *COMPLETING-ALIST*) (G-L-P *COMPLETING-ALIST*)
		    *COMPLETING-ALIST*)
		(CDR ALIST))
	 (POSS NIL))
	((NULL ALIST)
	 (SI:DISPLAY-ITEM-LIST *TYPEOUT-WINDOW* 'COMPLETION 
			       (SORT (MAPCAR #'CAR POSS) #'STRING-LESSP)))
      (DO NIL ((LISTP ALIST)) (SETQ ALIST (CAR ALIST)))	;Indirect through multiple alists
      (AND (FUNCALL FUNCTION LINE (CAAR ALIST))
	   (PUSH (CAR ALIST) POSS))))
  (TERPRI *TYPEOUT-WINDOW*)
  DIS-NONE)

(TV:ADD-TYPEOUT-ITEM-TYPE *ZWEI-TYPEOUT-COMMAND-ALIST* COMPLETION "Select" SELECT-COMPLETION T
			  "Use this completion.")

;Called if the user mouses one of the completions
(DEFUN SELECT-COMPLETION (STRING)
  (OR (EQ *INTERVAL* (WINDOW-INTERVAL *MINI-BUFFER-WINDOW*)) (BARF))
  (FUNCALL *TYPEOUT-WINDOW* ':MAKE-COMPLETE)	;Only one completion can be meaningful
  (DELETE-INTERVAL *INTERVAL*)
  (INSERT-MOVING-POINT STRING)
  (MUST-REDISPLAY *WINDOW* DIS-TEXT)
  (COM-COMPLETE-AND-EXIT))

;;; This command is on the HELP key when the user is in the completing reader.
;;; The caller of the completing reader can pass this two implicit arguments
;;; through the specal variables *COMPLETING-HELP-MESSAGE* and *COMPLETING-DOCUMENTER*.
;;; The command first prints the value of *COMPLETING-HELP-MESSAGE*, if non-NIL;
;;; otherwise it prints "You are in the completing reader."  The top-level value
;;; of this variable is NIL.  Then it explains how completion works, and tells
;;; the user what options he can complete to.  If there is only one option,
;;; and *COMPLETING-DOCUMENTER* is non-NIL, then *COMPLETING-DOCUMENTER* is
;;; applied to the one element of the ALIST that the user is indicating;
;;; the function should output helpful cruft to *TYPEOUT-WINDOW*.
(DEFCOM COM-DOCUMENT-COMPLETING-READ "Explains how the completing reader works.
Tells you what you are currently doing." ()
  (LET (POSS)
   (FORMAT T "~&~A~2%"
	   (OR *COMPLETING-HELP-MESSAGE* "You are in the completing reader."))
   (FORMAT T
"You are typing to a mini-buffer, with the following commands redefined:

~A~10TCauses as much of the string as can be determined to be inserted
          into the mini-buffer (this is called command completion).
Space, )  Completes up to the next space or ) in the name.
Control-? Lists all the strings that complete what you have typed so far.
Control-// Does Apropos for each of the partial words you have typed so far.
End       Completes and returns if the result is unique.
Return    Completes as much as possible and "
      "Complete")
   (FORMAT T
	   (IF *COMPLETING-IMPOSSIBLE-IS-OK-P*
	       "returns the result."
	       "if that is a valid string
          returns it."))
   (FORMAT T "~2%")
   (MULTIPLE-VALUE (NIL POSS)
     (COMPLETE-STRING (BP-LINE (POINT)) *COMPLETING-ALIST* *COMPLETING-DELIMS*))
   (LIST-COMPLETIONS-INTERNAL POSS))
  DIS-NONE)

(DEFUN COMPLETE-LINE (FORWARD-OK MUST-COMPLETE &OPTIONAL INSERT IGNORE-RIGHT-SPACE
		      &AUX NSTR POSS WINP LINE POINT CHAR-POS EOLP MAGIC-POS)
  (SETQ POINT (POINT))
  (SETQ LINE (BP-LINE POINT)
	CHAR-POS (BP-INDEX POINT))
  (SETQ EOLP (= CHAR-POS (LINE-LENGTH LINE)))
  (MULTIPLE-VALUE (NSTR POSS WINP CHAR-POS MAGIC-POS)
    (COMPLETE-STRING LINE *COMPLETING-ALIST* *COMPLETING-DELIMS* T CHAR-POS
		     (NOT FORWARD-OK) IGNORE-RIGHT-SPACE))
  (AND MAGIC-POS FORWARD-OK
       (SETQ CHAR-POS MAGIC-POS))
  (COND (POSS
	 (DELETE-INTERVAL (BEG-LINE POINT) (END-LINE POINT))
	 (INSERT-MOVING POINT NSTR)))
  ;; Insert the given character, unless we have fully completed only one completion.
  (AND INSERT EOLP (OR (NEQ WINP 'NOSPACE)
		       (AND (ASSOC LINE POSS) (NOT (NULL (CDR POSS)))))
       (INSERT-MOVING POINT INSERT))
  (COND (WINP)
	((AND (NOT *COMPLETING-IMPOSSIBLE-IS-OK-P*) (NULL POSS))
	 (BARF))
	(FORWARD-OK
	 (COND (MAGIC-POS
		(MOVE-POINT LINE MAGIC-POS))
	       ((AND MUST-COMPLETE (NULL POSS))
		(BARF)))))
  POSS)

||#

(DEFVAR *MINI-IE-PROMPT*)
(DEFVAR *MINI-IE-ADDITIONAL-PROMPT*)
(DEFVAR *MINI-IE-STREAM*)

(DEFCOM COM-MINI-IE-SPECIAL-CHARACTER "Input editor activation character" ()
  (COM-MINI-IE-SPECIAL-CHARACTER-INTERNAL *LAST-COMMAND-CHAR*)
  (BARF))

(DEFCOM COM-MINI-IE-SPECIAL-CHARACTER-OR-SELF-INSERT
	"Insert character unless input editor activation character" ()
  (COM-MINI-IE-SPECIAL-CHARACTER-INTERNAL *LAST-COMMAND-CHAR*)
  (COM-SELF-INSERT))

(DEFCOM COM-MINI-IE-SPECIAL-CHARACTER-OR-INSERT-RETURN
	"Insert a return unless input editor activation character" ()
  (COM-MINI-IE-SPECIAL-CHARACTER-INTERNAL *LAST-COMMAND-CHAR*)
  (COM-INSERT-CRS))

(DEFCOM COM-MINI-IE-HELP
	"Give standard input editor style help" ()
  (COM-MINI-IE-SPECIAL-CHARACTER-INTERNAL *LAST-COMMAND-CHAR*)
  (SEND *MINI-IE-STREAM* :RESET '(:DEFAULT-HELP #\Help))
  DIS-NONE)

(DEFUN MINI-IE-DEFAULT-HELP ()
  (FORMAT *TYPEOUT-WINDOW*
	  "~&You are typing at a mini-buffer that acts like an input editor.~%")
  (LET ((HELP-OPTION (OR (SI:INPUT-EDITOR-OPTION :BRIEF-HELP)
			 (SI:INPUT-EDITOR-OPTION :COMPLETE-HELP)
			 (SI:INPUT-EDITOR-OPTION :PARTIAL-HELP))))
    (WHEN HELP-OPTION
      (SI:DISPLAY-HELP-OPTION *TYPEOUT-WINDOW* HELP-OPTION)))
  (SEND *TYPEOUT-WINDOW* :FRESH-LINE))

(DEFUN MINI-IE-SPECIAL-CHARACTER (CHAR)
  (LET ((BLIP-CHARACTER (SI:INPUT-EDITOR-OPTION :BLIP-CHARACTER))
	(ACTIVATION (SI:INPUT-EDITOR-OPTION :ACTIVATION))
	(COMMAND (SI:INPUT-EDITOR-OPTION :COMMAND)))
    (COND ((AND (LISTP CHAR)
		(NOT (KEYWORDP (FIRST CHAR))))
	   CHAR)
	  ;; Keeps Zmail happy if you should click on the summary window.
	  ((AND (ATOM CHAR) (NOT (CHARACTERP CHAR)))
	   NIL)
	  ;; Keeps Zmail happy if you should click on the command menu.
	  ((AND (LISTP CHAR) (EQ (FIRST CHAR) ':MENU))
	   NIL)
	  ((AND BLIP-CHARACTER (LEXPR-FUNCALL (CAR BLIP-CHARACTER) CHAR (CDR BLIP-CHARACTER)))
	   (SI:IE-MAKE-BLIP :BLIP-CHARACTER CHAR (AND *NUMERIC-ARG-P* *NUMERIC-ARG*)))
	  ((AND ACTIVATION (LEXPR-FUNCALL (CAR ACTIVATION) CHAR (CDR ACTIVATION)))
	   (SI:IE-MAKE-BLIP :ACTIVATION CHAR (AND *NUMERIC-ARG-P* *NUMERIC-ARG*)))
	  ((AND COMMAND (LEXPR-FUNCALL (CAR COMMAND) CHAR (CDR COMMAND)))
	   (SI:IE-MAKE-BLIP :COMMAND CHAR (AND *NUMERIC-ARG-P* *NUMERIC-ARG*)))
	  ;; This is because ACCEPT does not use the blip mechanism
	  ;; properly.  It should enable these as blip chars too and
	  ;; then do replace-input of them.  That way the client can
	  ;; also know whether they were typed or rescanned.
	  ((AND DW::*ACCEPT-ACTIVE* (DW::ACCEPT-BLIP-P CHAR))
	   CHAR))))

;;; If this returns, the char isn't special
(DEFUN COM-MINI-IE-SPECIAL-CHARACTER-INTERNAL (CHAR)
  (LET ((SPECIAL-CHAR (MINI-IE-SPECIAL-CHARACTER CHAR)))
    (WHEN SPECIAL-CHAR
      (SEND *MINI-IE-STREAM* :RESET SPECIAL-CHAR))))

(DEFFLAVOR MINI-IE-STREAM
	((SPECIAL-CHAR NIL)
	 (LAST-SPECIAL-CHAR NIL)
	 (INITIAL-INPUT NIL)
	 (INITIAL-POSITION NIL)
	 (OLD-STANDARD-INPUT STANDARD-INPUT)
	 )
	(INTERVAL-STREAM))

(DEFUN MAKE-MINI-IE-STREAM (&REST OPTIONS)
  (LEXPR-FUNCALL #'MAKE-INSTANCE 'MINI-IE-STREAM
		 :INTERVAL (CREATE-INTERVAL)
		 :BUFFER (WINDOW-INTERVAL *MINI-BUFFER-WINDOW*)
		 OPTIONS))

(DEFMETHOD (MINI-IE-STREAM-RESET MINI-IE-STREAM) (&KEY (INITIAL-COMPLETE NIL)
						       ((:INITIAL-INPUT NEW-INITIAL-INPUT)
							NIL)
						       ((:INITIAL-POSITION
							  NEW-INITIAL-POSITION)
							NIL))
  (WHEN *MINI-BUFFER-COMMAND-IN-PROGRESS*
    (BARF "Mini-buffer entered recursively"))
  (IGNORE INITIAL-COMPLETE)
  (SETQ SPECIAL-CHAR NIL LAST-SPECIAL-CHAR NIL
	INITIAL-INPUT NEW-INITIAL-INPUT INITIAL-POSITION NEW-INITIAL-POSITION
	OLD-STANDARD-INPUT STANDARD-INPUT))

(DEFUN MINI-IE-FORWARD-OUTPUT-MESSAGE (IGNORE IGNORE OP &REST ARGS)
  (LEXPR-SEND *TYPEOUT-WINDOW* OP ARGS))

;;; I wish there were input only interval streams so that I could know
;;;  when I forgot one of these
(DEFMETHOD (:TYO MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:STRING-OUT MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:LINE-OUT MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:FRESH-LINE MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:READ-CURSORPOS MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:SET-CURSORPOS MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:INCREMENT-CURSORPOS MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:CLEAR-BETWEEN-CURSORPOSES MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:CLEAR-REGION MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:OUTPUT-AS-PRESENTATION MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:OUTPUT-AS-PRESENTATION-1 MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:PRINT MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:GPRINT MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:CHARACTER-WIDTH MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:STRING-LENGTH MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:SIZE-IN-CHARACTERS MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:VISIBLE-CURSORPOS-LIMITS MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:INSIDE-SIZE MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:INSIDE-WIDTH MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:INSIDE-HEIGHT MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:CHAR-WIDTH MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:LINE-HEIGHT MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:REAL-SET-CURSORPOS MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:DISPLAY-LOZENGED-STRING MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)
(DEFMETHOD (:LOZENGED-STRING-LENGTH MINI-IE-STREAM) MINI-IE-FORWARD-OUTPUT-MESSAGE)

(DEFMETHOD (:MOUSE-SENSITIVE-STREAM-P MINI-IE-STREAM) ()
  (DW::MOUSE-SENSITIVE-STREAM-P *TYPEOUT-WINDOW*))

(DEFMETHOD (:START-TYPEOUT MINI-IE-STREAM) (&REST IGNORE)
  (SEND *TYPEOUT-WINDOW* :FRESH-LINE))

(DEFMETHOD (:FINISH-TYPEOUT MINI-IE-STREAM) (&REST IGNORE) )

(DEFMETHOD (:DEFAULT-STYLE MINI-IE-STREAM) () (SEND SELF :DEFAULT-CHARACTER-STYLE))
(DEFMETHOD (:DEFAULT-CHARACTER-STYLE MINI-IE-STREAM) ()
  (SEND (WINDOW-SHEET *WINDOW*) :DEFAULT-CHARACTER-STYLE))

;;; White lie
(DEFMETHOD (:INTERACTIVE MINI-IE-STREAM) () T)

(DEFMETHOD (:RESET MINI-IE-STREAM) (CHAR)
  (IF (NOT (CHARACTERP CHAR))
      (SETQ SPECIAL-CHAR CHAR)			;Out of band
    (INSERT-MOVING-POINT CHAR)
    (MUST-REDISPLAY *WINDOW* DIS-TEXT)
    (SETQ SPECIAL-CHAR NIL))
  (SEND SELF :SET-INTERVAL *INTERVAL*)
  (THROW 'INPUT-EDITOR-RESCAN T))

(DEFMETHOD (:FORCE-RESCAN MINI-IE-STREAM) ()
  (THROW 'INPUT-EDITOR-RESCAN T))

(DEFWHOPPER (:INPUT-EDITOR MINI-IE-STREAM) (FUNCTION &REST ARGS)
  (LET ((SI:*INPUT-EDITOR-STREAM* SELF))
    (LEXPR-CONTINUE-WHOPPER FUNCTION ARGS)))

(DEFMETHOD (:INPUT-EDITOR MINI-IE-STREAM) (FUNCTION &REST ARGS)
  (LET ((RUBOUT-HANDLER T)
	(*MINI-IE-STREAM* SELF)
	(*MINI-IE-PROMPT* (WITH-OUTPUT-TO-STRING (STREAM)
			    (SI:DISPLAY-PROMPT-OPTION
			      STREAM
			      (OR (SI:INPUT-EDITOR-OPTION :REPROMPT)
				  (SI:INPUT-EDITOR-OPTION :PROMPT)))))
	(*MINI-IE-ADDITIONAL-PROMPT* NIL))
    (WITH-THIS-PROCESS-MOUSE-FONT-CHAR (#\MOUSE:UP-ARROW)
      (SETF (TV:MOUSE-RECONSIDER (TV:SHEET-MOUSE (WINDOW-SHEET *WINDOW*))) T)
      (UNWIND-PROTECT
	  (LET ((*CONTEXT-HISTORY* (OR (SI:INPUT-EDITOR-FLAG :INPUT-HISTORY)
				       *DEFAULT-HISTORY*)))
	    (FLET ((DO-IT ()
		     (DECLARE (SYS:DOWNWARD-FUNCTION))
		     (CALL-IN-MINI-BUFFER
		       (LAMBDA (MINI-INTERVAL)
			 (SEND SELF :SET-INTERVAL MINI-INTERVAL)
			 (LETF (((SYMEVAL '*STANDARD-COMMAND*)
				 'COM-MINI-IE-SPECIAL-CHARACTER-OR-SELF-INSERT))
			   (LOOP DOING
			     (CATCH 'INPUT-EDITOR-RESCAN
			       (CONDITION-BIND ((UNKNOWN-SPECIAL-COMMAND
						  #'(LAMBDA (ERROR)
						      (DECLARE (SYS:DOWNWARD-FUNCTION))
						      (COM-MINI-IE-SPECIAL-CHARACTER-INTERNAL
							(CONS (SEND ERROR :COMMAND-TYPE)
							      (SEND ERROR :REST)))
						      NIL))
						(SYS:PARSE-ERROR
						  #'(LAMBDA (ERROR)
						      (DECLARE (SYS:DOWNWARD-FUNCTION))
						      (MINI-IE-PARSE-ERROR-HANDLER SELF
										   ERROR))))
				 (RETURN
				   (APPLY FUNCTION ARGS)))))))
		       '(*MINI-IE-PROMPT* (:RIGHT-FLUSH *MINI-IE-ADDITIONAL-PROMPT*))
		       (OR (SI:INPUT-EDITOR-OPTION :INITIAL-INPUT) INITIAL-INPUT)
		       INITIAL-POSITION)))
	      (LET ((HISTORY-DEFAULT (SI:INPUT-EDITOR-OPTION :INPUT-HISTORY-DEFAULT)))
		(IF HISTORY-DEFAULT
		    (SEND *CONTEXT-HISTORY* :FUNCALL-WITH-DEFAULT
			  (FIRST HISTORY-DEFAULT) #'DO-IT)
		    (DO-IT)))))
	(SETF (TV:MOUSE-RECONSIDER (TV:SHEET-MOUSE (WINDOW-SHEET *WINDOW*))) T)))))

;;; A CL type expression.
(DEFVAR *MINI-IE-PARSE-ERROR-TYPE-THAT-JUST-BEEPS* 'DW:INPUT-NOT-OF-REQUIRED-TYPE)

(DEFMETHOD (PARSE-ERROR-ADDITIONAL-PROMPT SYS:CONDITION) () NIL)
(DEFMETHOD (PARSE-ERROR-ADDITIONAL-PROMPT
	     DW::INPUT-NOT-OF-REQUIRED-TYPE-UNLESS-CONTROL-RETURN)
	   ()
  (FORMAT NIL "(c-Return creates a new ~(~A~))" DW::TYPE))

(DEFUN MINI-IE-PARSE-ERROR-HANDLER (STREAM ERROR)
  (BEEP)
  (IF (CL:TYPEP ERROR *MINI-IE-PARSE-ERROR-TYPE-THAT-JUST-BEEPS*)
      (LET ((ADDITIONAL-PROMPT (PARSE-ERROR-ADDITIONAL-PROMPT ERROR)))
	(WHEN ADDITIONAL-PROMPT
	  (SETQ *MINI-IE-ADDITIONAL-PROMPT* ADDITIONAL-PROMPT)))
    (SEND *TYPEOUT-WINDOW* :FRESH-LINE)
    (SEND ERROR :REPORT *TYPEOUT-WINDOW*)
    (SEND *TYPEOUT-WINDOW* :MAKE-COMPLETE))
  (SEND STREAM :ENTER-EDITOR NIL))

(DEFMETHOD (:ENTER-EDITOR MINI-IE-STREAM) (&OPTIONAL (MOVE-BP T))
  (WHEN MOVE-BP
    (MOVE-BP (WINDOW-POINT *MINI-BUFFER-WINDOW*) (SEND SELF :READ-BP)))
  (MUST-REDISPLAY *MINI-BUFFER-WINDOW* DIS-BPS)
  (LET ((STANDARD-INPUT OLD-STANDARD-INPUT))
    (UNWIND-PROTECT
	(COMMAND-LOOP *MINI-IE-COMTAB* *MINI-BUFFER-WINDOW* 'EDITOR NIL NIL)
      ;; Don't allow stream position to be garbled by editing, which can happen because
      ;; the stream's position isn't a bp and therefore doesn't get relocated.
      (COND ((NULL INDEX))
	    ((EQ (LINE-TICK LINE) 'DELETED)
	     (SEND SELF :SET-BP (INTERVAL-FIRST-BP (WINDOW-INTERVAL *MINI-BUFFER-WINDOW*))))
	    ((> INDEX (LINE-LENGTH LINE))
	     (SEND SELF :SET-BP (CREATE-BP LINE (LINE-LENGTH LINE))))))))

(DEFMETHOD (:ACTIVATOR MINI-IE-STREAM) () NIL)	;Or should it be SPECIAL-CHAR

(DEFMETHOD (:RESCANNING-P MINI-IE-STREAM) ()
  (OR (AND SPECIAL-CHAR
	   (OR (DW:PRESENTATION-BLIP-P SPECIAL-CHAR)
	       (MINI-IE-SPECIAL-CHARACTER (SECOND SPECIAL-CHAR))))
      (AND INDEX
	   (OR (< INDEX STOP-INDEX)
	       (NEQ LINE LAST-LINE)))))

;;; Need diagram characters I guess to get this really right.
(DEFMETHOD (:INSERT-INPUT-BLIP MINI-IE-STREAM) (BLIP &OPTIONAL START-LOC)
  (SEND SELF :REPLACE-INPUT-SINCE (OR START-LOC (SEND SELF :READ-LOCATION))
	(SCL:PRESENT-TO-STRING (DW:PRESENTATION-BLIP-OBJECT BLIP)
			       (DW:PRESENTATION-BLIP-PRESENTATION-TYPE BLIP))))

(DEFMETHOD (:REPLACE-INPUT MINI-IE-STREAM) (LENGTH &REST ARGS)
  (LET ((BP (SEND SELF :READ-LOCATION)))
    (ARGUMENT-TYPECASE LENGTH
      (:STRING (SETQ LENGTH (STRING-LENGTH LENGTH)))
      (:NUMBER ))
    (UNLESS (ZEROP LENGTH)
      (SETQ BP (FORWARD-CHAR BP (- LENGTH))))
    (LEXPR-SEND SELF :REPLACE-INPUT-SINCE BP ARGS)))

(DEFWHOPPER (:REPLACE-INPUT-SINCE MINI-IE-STREAM) (&REST ARGS)
  (WITH-BP (PT (WINDOW-POINT *MINI-BUFFER-WINDOW*) :MOVES)
    (LEXPR-CONTINUE-WHOPPER ARGS)
    (MOVE-BP (WINDOW-POINT *MINI-BUFFER-WINDOW*) PT)
    (MUST-REDISPLAY *MINI-BUFFER-WINDOW* DIS-TEXT)))

(DEFMETHOD (:SET-TYPEIN-LOCATION MINI-IE-STREAM) (LOCATION &OPTIONAL (DELTA 0))
  (SEND SELF :SET-LOCATION (FORWARD-CHAR LOCATION DELTA T))
  (SEND SELF :ENTER-EDITOR))			;Will throw out

(DEFMETHOD (:SAVE-INPUT-BUFFER MINI-IE-STREAM) (IGNORE)
  (STRING-INTERVAL (WINDOW-INTERVAL *MINI-BUFFER-WINDOW*)))

(DEFMETHOD (:RESTORE-INPUT-BUFFER MINI-IE-STREAM) (STRING)
  (DELETE-INTERVAL (WINDOW-INTERVAL *MINI-BUFFER-WINDOW*))
  (INSERT-MOVING (WINDOW-POINT *MINI-BUFFER-WINDOW*) STRING)
  (MUST-REDISPLAY *MINI-BUFFER-WINDOW* DIS-TEXT))

(DEFMETHOD (:COPY-INPUT-SINCE MINI-IE-STREAM) (START-BP)
  (STRING-INTERVAL START-BP (SEND SELF :READ-BP)))

(DEFMETHOD (:FQUERY-STREAM MINI-IE-STREAM) () *TYPEOUT-WINDOW*)

;;; Pleasantly plump characters
(DEFFLAVOR NOISE-STRING-CHARACTER-SET
	()
	(SI:CHARACTER-SET-NO-CASE-MIXIN SI:BASIC-CHARACTER-SET)
  (:DEFAULT-INIT-PLIST
   :NAME "NOISE-STRINGS"
   :N-CHARACTERS #O177
   :CHARACTERS '#O((0 "a noise string"))))

(DEFMETHOD (:GRAPHIC-CHAR-P NOISE-STRING-CHARACTER-SET) (IGNORE) NIL)

(COMPILE-FLAVOR-METHODS NOISE-STRING-CHARACTER-SET)

(DEFCONST *NOISE-STRINGS-BLIPS-CHARACTER-SET* (MAKE-INSTANCE 'NOISE-STRING-CHARACTER-SET))

(DEFFLAVOR NOISE-STRING-BLIP
	((REAL-CHARACTER NIL)
	 STRING)
	()
  (:CONSTRUCTOR MAKE-NOISE-STRING-BLIP (STRING REAL-CHARACTER))
  :INITABLE-INSTANCE-VARIABLES
  :READABLE-INSTANCE-VARIABLES)

(COMPILE-FLAVOR-METHODS NOISE-STRING-BLIP)

(DEFUN NOISE-STRING-BLIP-EQUAL (BLIP STRING CHARACTER)
  (AND (STRING= STRING (NOISE-STRING-BLIP-STRING BLIP))
       (EQL CHARACTER (NOISE-STRING-BLIP-REAL-CHARACTER BLIP))))

(DEFVAR *NOISE-STRINGS* NIL)

(DEFUN NOISE-STRING-INTO-BLIP (STRING CHARACTER)
  (WHEN (NULL *NOISE-STRINGS*)
    (SETQ *NOISE-STRINGS* (MAKE-ARRAY 3 :FILL-POINTER 0)))
  (LET ((INDEX (OR (LOOP FOR BLIP BEING THE ARRAY-ELEMENTS OF *NOISE-STRINGS*
				  USING (INDEX INDEX)
			 WHEN (NOISE-STRING-BLIP-EQUAL BLIP STRING CHARACTER)
			   RETURN INDEX)
		   (PROG1 (FILL-POINTER *NOISE-STRINGS*)
			  (ARRAY-PUSH-EXTEND *NOISE-STRINGS*
					     (MAKE-NOISE-STRING-BLIP STRING CHARACTER))))))
    (CODE-CHAR (SEND *NOISE-STRINGS-BLIPS-CHARACTER-SET* :MAKE-CHAR INDEX))))

(DEFUN NOISE-STRING-BLIP-P (CHAR)
  (EQ (SI:CHAR-CHAR-SET-AND-INDEX CHAR) *NOISE-STRINGS-BLIPS-CHARACTER-SET*))

(DEFUN NOISE-STRING-FUNNY-CHAR-HOOK (CHAR)
  (WHEN (NOISE-STRING-BLIP-P CHAR)
    (VALUES (NOISE-STRING-BLIP-STRING (AREF *NOISE-STRINGS* (CHAR-SUBINDEX CHAR)))
	    T)))

(DEFWHOPPER (:TYI MINI-IE-STREAM) (&OPTIONAL EOF ANY-TYI)
  ;; Don't allow reading past the point unless activating.
  (WHEN (AND (NULL SPECIAL-CHAR)
	     LINE INDEX
	     (EQ LINE (BP-LINE (WINDOW-POINT *MINI-BUFFER-WINDOW*)))
	     ( INDEX (BP-INDEX (WINDOW-POINT *MINI-BUFFER-WINDOW*))))
    (SEND SELF :ENTER-EDITOR))
  (SETQ LAST-SPECIAL-CHAR NIL)
  (LET ((CHAR NIL))
    (LOOP DOING
      (SETQ CHAR (CONTINUE-WHOPPER EOF))
      (WHEN (OR (NULL CHAR) (NOT (NOISE-STRING-BLIP-P CHAR)))
	(RETURN))
      (SETQ CHAR (NOISE-STRING-BLIP-REAL-CHARACTER
		   (AREF *NOISE-STRINGS* (CHAR-SUBINDEX CHAR))))
      (WHEN CHAR
	(RETURN)))
    (COND (CHAR)
	  (SPECIAL-CHAR
	   (SETQ LAST-SPECIAL-CHAR SPECIAL-CHAR
		 SPECIAL-CHAR NIL)
	   ;; Check that the activation predicates haven't changed.
	   ;; Unfortunately, we can only demote characters based on
	   ;; this.
	   (IF (DW:PRESENTATION-BLIP-P LAST-SPECIAL-CHAR)
	       LAST-SPECIAL-CHAR
	       (LET ((CHAR (SECOND LAST-SPECIAL-CHAR)))
		 (IF (NOT ANY-TYI)
		     CHAR
		     (LET ((BLIP (MINI-IE-SPECIAL-CHARACTER CHAR)))
		       (IF BLIP
			   (SETQ LAST-SPECIAL-CHAR BLIP)
			 (COND ((NOT (CHARACTERP CHAR))
				(BEEP))
			       ((OR (CHAR-EQUAL CHAR #\Return)
				    (CL:GRAPHIC-CHAR-P CHAR))
				(INSERT-MOVING (WINDOW-POINT *MINI-BUFFER-WINDOW*) CHAR)
				(MUST-REDISPLAY *MINI-BUFFER-WINDOW* DIS-TEXT))
			       ((CHAR-EQUAL CHAR #\Help)
				(MINI-IE-DEFAULT-HELP))
			       (T
				(BEEP)))
			 (SEND SELF :ENTER-EDITOR)))))))
	  (T
	   (SEND SELF :ENTER-EDITOR)))))

(DEFMETHOD (:ANY-TYI MINI-IE-STREAM) (&OPTIONAL EOF)
  (SEND SELF :TYI EOF T))

(DEFWHOPPER (:UNTYI MINI-IE-STREAM) (CHAR)
  (COND ((AND LAST-SPECIAL-CHAR
	      (OR (EQUAL CHAR LAST-SPECIAL-CHAR)
		  (AND (LISTP LAST-SPECIAL-CHAR)
		       (EQL CHAR (SECOND LAST-SPECIAL-CHAR)))))
	 (SETQ SPECIAL-CHAR (PROG1 LAST-SPECIAL-CHAR
				   (SETQ LAST-SPECIAL-CHAR NIL))))
	((LISTP CHAR)
	 (SETQ SPECIAL-CHAR CHAR
	       LAST-SPECIAL-CHAR NIL))
	(T
	 (WHEN (AND INDEX (PLUSP INDEX))
	   (LET ((LINE-CHAR (AREF LINE (1- INDEX))))
	     (WHEN (AND (NOISE-STRING-BLIP-P LINE-CHAR)
			(EQL (NOISE-STRING-BLIP-REAL-CHARACTER
			       (AREF *NOISE-STRINGS* (CHAR-SUBINDEX LINE-CHAR)))
			     CHAR))
	       (SETQ CHAR LINE-CHAR))))
	 (CONTINUE-WHOPPER CHAR))))

(DEFMETHOD (:NOISE-STRING-OUT MINI-IE-STREAM) (STRING)
  (LET* ((BP (SEND SELF :READ-BP))
	 (CHAR NIL))
    (WHEN (BP-= BP (INTERVAL-LAST-BP INTERVAL))
      ;; Try to find a space character in the vacinity to merge the noise string with.
      ;; It then assumes the syntactic place of that character.
      (WHEN (NOT (BP-= BP (INTERVAL-FIRST-BP INTERVAL)))
	(LET ((CHAR-BEFORE (BP-CHAR-BEFORE BP)))
	  (WHEN (CHAR-EQUAL CHAR-BEFORE #\Space)
	    (SETQ CHAR CHAR-BEFORE
		  STRING (STRING-APPEND CHAR STRING))
	    (SETQ BP (FORWARD-CHAR BP -1)))))
      (LET ((BLIP (NOISE-STRING-INTO-BLIP STRING CHAR)))
	(IF CHAR
	    (LET ((LINE (BP-LINE BP))
		  (INDEX (BP-INDEX BP)))
	      (MUNG-LINE LINE)
	      (SETF (AREF LINE INDEX) BLIP))
	    (LET* ((POINT (WINDOW-POINT *MINI-BUFFER-WINDOW*))
		   (POINT-P (BP-= BP POINT)))
	      (SETQ BP (INSERT BP BLIP))
	      (WHEN POINT-P
		(MOVE-BP POINT BP))
	      BP))))))

(DEFRESOURCE MINI-IE-STREAM ()
  :CONSTRUCTOR (MAKE-MINI-IE-STREAM))

(DEFMACRO WITH-TYPEIN-LINE-IE ((STREAM . OPTIONS) &BODY BODY)
  `(USING-RESOURCE (,STREAM MINI-IE-STREAM)
     (MINI-IE-STREAM-RESET ,STREAM . ,OPTIONS)
     (LET ((TV:*FUNNY-CHAR-HOOK* #'NOISE-STRING-FUNNY-CHAR-HOOK))
       (WITH-INPUT-EDITING-OPTIONS ((:HELP-STREAM *TYPEOUT-WINDOW*))
	 . ,BODY))))

(DEFUN TYPEIN-LINE-ACCEPT (TYPE &REST OPTIONS
				&KEY INITIAL-INPUT INITIAL-POSITION INITIAL-COMPLETE
				&ALLOW-OTHER-KEYS)
  (WITH-TYPEIN-LINE-IE (STREAM :INITIAL-INPUT INITIAL-INPUT
			       :INITIAL-POSITION INITIAL-POSITION
			       :INITIAL-COMPLETE INITIAL-COMPLETE)
    (SI:WITH-REM-KEYWORDS (SOME-OPTIONS OPTIONS '(:INITIAL-INPUT :INITIAL-POSITION
						  :INITIAL-COMPLETE))
      (WITH-STACK-LIST* (DW::*COMPLETE-INPUT-RIGHT-TRIMS-CHARACTERS*
			  #\SPACE DW::*COMPLETE-INPUT-RIGHT-TRIMS-CHARACTERS*)
	(LEXPR-FUNCALL #'SCL:ACCEPT TYPE :STREAM STREAM SOME-OPTIONS)))))

;;; This returns the name of a function, either from the buffer with the mouse, or the
;;; mini-buffer.  MUST-BE-FUNCTION can also be 'LAMBDA-OK to make this function accept
;;; lambda expressions; this is used in e.g. the DIRED "A" (apply) command.
(DEFUN READ-FUNCTION-SPEC (PROMPT &OPTIONAL DEFAULT (MUST-BE-FUNCTION T))
  (TYPEIN-LINE-ACCEPT (SELECTQ MUST-BE-FUNCTION
			((NIL) 'SYS:FUNCTION-SPEC)
			((T) '((AND SYS:FUNCTION-SPEC
				    ((CL:SATISFIES SI:VALID-FUNCTION-DEFINITION)))))
			((LAMBDA-OK)
			 '((OR ((AND SYS:FUNCTION-SPEC
				     ((CL:SATISFIES SI:VALID-FUNCTION-DEFINITION))))
			       ((AND SYS:EXPRESSION
				     ((CL:SATISFIES (LAMBDA (X)
						      (AND (LISTP X)
							   (EQ (CAR X) 'FUNCTION)
							   (SETQ X (CADR X)))
						      (AND (LISTP X)
							   (EQ (CAR X) 'LAMBDA)))))))))))
		      :DEFAULT DEFAULT
		      :DEFAULT-TYPE 'SYS:FUNCTION-SPEC
		      :PROMPT PROMPT))

(DEFCOM COM-EXECUTE-CP-COMMAND
	"Read a CP command line from the mini-buffer and execute that command.
With a numeric argument, puts the result into the current buffer." (SM)
  (LET ((COMMAND (TYPEIN-LINE-ACCEPT 'CP:COMMAND)))
    (IF *NUMERIC-ARG-P*
	(WITH-NODE-WRITE-LOCKED ((BP-NODE-TO-LOCK (POINT)))
	  (WITH-INTERVAL-STREAM (STREAM (POINT))
	    (LET ((STANDARD-OUTPUT STREAM)
		  (OLD-POINT (COPY-BP (POINT) :NORMAL)))
	      (WITH-CUSTOM-UNDO-SAVE (OLD-POINT OLD-POINT
				      (MAKE-INSERT-RECORD OLD-POINT
							  (COPY-BP OLD-POINT ':MOVES)))
		(APPLY (FIRST COMMAND) (REST1 COMMAND)))))
	  DIS-TEXT)
      (APPLY (FIRST COMMAND) (REST1 COMMAND))
      DIS-NONE)))

FORMAT::(PROGN

(DEFPROP :MINI-BUFFER-OR-READLINE MINI-BUFFER-OR-READLINE-FQUERY-FUNCTION FQUERY-FUNCTION)
(DEFUN MINI-BUFFER-OR-READLINE-FQUERY-FUNCTION (OPERATION &REST ARGS)
  (SELECTQ OPERATION
    (:CHOOSE
     (WITH-INPUT-EDITING-OPTIONS (((:PROMPT :OVERRIDE) #'FQUERY-PROMPT)
				  (:BRIEF-HELP FQUERY-HELP-FUNCTION))
       ;; We never return from here without success; errors are caught by the input editor.
       (LET ((CHOICE (FUNCALL (IF (AND (VARIABLE-BOUNDP ZWEI:*MINI-BUFFER-WINDOW*)
				       ZWEI:*MINI-BUFFER-WINDOW*)
				  #'ZWEI:TYPEIN-LINE-ACCEPT
				  #'SCL:ACCEPT)
			      `((FQUERY-CHOICE :CHOICES ,FQUERY-CHOICES)))))
	 (VALUES (IF (STRINGP CHOICE) CHOICE (FIRST CHOICE)) T))))
    (OTHERWISE
     (LEXPR-FUNCALL #'READLINE-FQUERY-FUNCTION OPERATION ARGS))))

)
