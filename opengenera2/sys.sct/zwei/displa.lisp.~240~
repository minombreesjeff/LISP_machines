;;; -*- Mode:LISP; Package:ZWEI; Base:8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This file provides functions dealing with redisplay:
;;; MUST-REDISPLAY  - Tell a window that redisplay is needed.
;;; MUNG-LINE       - Tell redisplay that a line has changed.
;;; REDISPLAY       - Update the image of a window.

;;;   Functions in this file will NOT touch any part of the window
;;; that is in the margins of the window;  the caller may do as he
;;; wishes with the margins.

;;;   This function tells a window that at least a certain amount of
;;; redisplay is needed.  The value you give will be "max'ed" into
;;; the value saved in the window.  The first argument is the window.
;;; The second argument is a keyword explaining the degree to which the
;;; parameters of the text being displayed have changed.  It should the
;;; value of one of the DIS- symbols:
;;;    DIS- code:         Meaning:
;;;      DIS-NONE           No text has changed, no bps have moved.
;;;      DIS-MARK-GOES      The state of existence of the region may have changed.
;;;      DIS-BPS            Any BPs may have moved.
;;;      DIS-LINE           See below.
;;;      DIS-TEXT           Any text may have been changed.
;;;      DIS-ALL            The window may be clobbered, don't trust information
;;;                           in the window data structure at all.
;;;   Each condition includes all of the conditions above.
;;;   When giving DIS-LINE as the argument, a third and fourth argument
;;; should also be given, and they should be a line and an index.  DIS-LINE
;;; means that text has changed, but only on that line after that index.

(DEFUN MUST-REDISPLAY (WINDOW DEGREE &OPTIONAL LINE INDEX (DONT-RECURSE NIL))
  (LET ((W-DEGREE (WINDOW-REDISPLAY-DEGREE WINDOW)))
    (COND ((= DEGREE DIS-LINE)
	   (COND ((AND (WINDOW-BACKSPACE-OVERPRINTING-FLAG WINDOW)
		       (STRING-SEARCH-CHAR #\BS LINE))
		  (SETF (WINDOW-REDISPLAY-DEGREE WINDOW) (MAX W-DEGREE DIS-TEXT)))
		 ((= W-DEGREE DIS-LINE)
		  (COND ((EQ (WINDOW-REDISPLAY-LINE WINDOW) LINE)
			 (SETF (WINDOW-REDISPLAY-INDEX WINDOW)
			       (MIN INDEX (WINDOW-REDISPLAY-INDEX WINDOW))))
			(T 
			  (SETF (WINDOW-REDISPLAY-DEGREE WINDOW) DIS-TEXT))))
		 ((< W-DEGREE DIS-LINE)
		  (SETF (WINDOW-REDISPLAY-DEGREE WINDOW) DIS-LINE)
		  (SETF (WINDOW-REDISPLAY-LINE WINDOW) LINE)
		  (SETF (WINDOW-REDISPLAY-INDEX WINDOW) INDEX))))
	  (T (SETF (WINDOW-REDISPLAY-DEGREE WINDOW) (MAX W-DEGREE DEGREE)))))
  (WHEN (NOT DONT-RECURSE)
    (MUST-REDISPLAY-OTHER-WINDOWS (WINDOW-INTERVAL WINDOW) WINDOW DEGREE LINE INDEX)))

;;; Also redisplay all other windows than WINDOW which point to INTERVAL
(DEFUN MUST-REDISPLAY-OTHER-WINDOWS (INTERVAL WINDOW DEGREE &OPTIONAL LINE INDEX)
  (FLET ((DO-OTHERS (WINDOW-LIST)
	   (DOLIST (OTHER-WINDOW WINDOW-LIST)
	     (WHEN (AND (NEQ OTHER-WINDOW WINDOW)
			(EQ INTERVAL (WINDOW-INTERVAL OTHER-WINDOW)))
	       (MUST-REDISPLAY OTHER-WINDOW DEGREE LINE INDEX T)))))
    (DO-OTHERS *WINDOW-LIST*)
    (UNLESS (MEMQ *CURRENT-COMMAND*
		  ;; These don't require that other editors redisplay
		  ;; anything, because nothing really changed
		  '(COM-RECENTER-WINDOW COM-COMPLETE-REDISPLAY))
      (DOLIST (OTHER-COMMAND-LOOP *ZMACS-COMMAND-LOOPS*)
	(WHEN (NEQ OTHER-COMMAND-LOOP *ZMACS-COMMAND-LOOP*)
	  (DO-OTHERS (SYMEVAL-IN-INSTANCE OTHER-COMMAND-LOOP '*WINDOW-LIST*)))))))

;;; Redisplay all the exposed windows associated with this editor,
;;; unless typeahead prevents, in which case T is returned.
(DEFUN REDISPLAY-ALL-WINDOWS (&OPTIONAL (FORCE-TO-COMPLETION-P NIL) (SELECT-P T))
 (IF (AND (NOT FORCE-TO-COMPLETION-P)
	  (OR *YANKED-MINI-BUFFER-COMMAND*
	      (SEND STANDARD-INPUT ':LISTEN)))	;Suppress redisplay if typeahead
      T
    (WHEN SELECT-P
      (SEND (WINDOW-SHEET *WINDOW*) ':FINISH-DELAYED-SELECT))
    (DOLIST (WINDOW *WINDOW-LIST*)
      (WHEN (WINDOW-READY-P WINDOW SELECT-P)
	(REDISPLAY WINDOW)))
    (REDISPLAY-MODE-LINE)
    NIL))

;;; This function is called to tell redisplay that the text of a given
;;; line has just changed.
;;; Returns the line, which may have changed if it was a copy-on-write line.
(DEFUN MUNG-LINE (LINE)
  (COND ((LINE-COPY-ON-WRITE LINE)
	 (COPY-MUNGED-LINE LINE))
	(T
	 (LET ((MAJOR-MODE (AND (VARIABLE-BOUNDP *INTERVAL*) *INTERVAL*
				(SEND *INTERVAL* ':MAJOR-MODE))))
	   (SETF (LINE-CONTENTS-PLIST LINE) NIL)
	   (SETF (LINE-TICK LINE) (TICK))
	   (WHEN MAJOR-MODE (SEND MAJOR-MODE ':MUNG-LINE LINE))
	   LINE))))

;;; This function indicates that the line should be copied if it is copy-on-write,
;;; but that no changes are being made to its text.  This avoids redisplay of 
;;; non-copy-on-write lines whenever their properties change.  

(DEFUN MUNG-LINE-PROPERTIES (LINE)
  (IF (LINE-COPY-ON-WRITE LINE)
      (COPY-MUNGED-LINE LINE)
      LINE))

;;;  This generates and returns a new value of TICK.
(DEFUN TICK ()
  (SETQ *TICK* (1+ *TICK*)))

;;; Set the *CENTERING-FRACTION* based on the sign of X.
(DEFUN SET-CENTERING-FRACTION (X)
  (SETQ *CENTERING-FRACTION*
	(IF (MINUSP X) *MAX-RESET-FRACTION* *MIN-RESET-FRACTION*)))

;;; This is a function for commands like C-V to call to scroll the window some
(DEFUN RECENTER-WINDOW-RELATIVE (WINDOW DELTA &OPTIONAL (UNIT :LINE))
  (WHEN (AND (> (WINDOW-REDISPLAY-DEGREE WINDOW) DIS-MARK-GOES)
	     (NULL (PLINE-OF-POINT T WINDOW (WINDOW-POINT WINDOW))))
    ;; If there is a pending redisplay and point is no longer valid, we must
    ;; first correct point and the start of the window.
    (RECENTER-WINDOW WINDOW :ABSOLUTE))
  (LET ((START-BP (COPY-BP (WINDOW-START-BP WINDOW))))
    (RECENTER-WINDOW WINDOW :RELATIVE DELTA UNIT)
    (COND ((AND (BP-= (WINDOW-START-BP WINDOW) START-BP) (NOT (ZEROP DELTA)))
	   ;; Tried to scroll backward beyond the beginning of the interval.
	   (BARF))
	  ((BP-= (WINDOW-START-BP WINDOW) (INTERVAL-LAST-BP (WINDOW-INTERVAL WINDOW)))
	   ;; Tried to scroll forward beyond the end of the interval.
	   (RECENTER-WINDOW WINDOW :START START-BP)
	   (BARF)))))

;;; Change the window-start-bp of a window for the next redisplay
;;; See the function REDISPLAY for what our arguments do.
;;; Recentering-types :NONE and :POINT are not meaningful 
;;; This should ALWAYS leave point within the range of things that will be
;;; displayed according to the start-bp that we set up.
;;--- Bug here if this moves point into a different section?
(DEFUN RECENTER-WINDOW (WINDOW RECENTER-TYPE &OPTIONAL RC1 RC2 &AUX TOP-LINE TOP-INDEX
                               POINT-PLINE POINT SHEET INTERVAL FIRST-BP LAST-BP DEGREE
                               N-PLINES START-BP POINT-Y POSITION-TYPE)
  (SETQ SHEET (WINDOW-SHEET WINDOW)
	DEGREE (WINDOW-REDISPLAY-DEGREE WINDOW)
	N-PLINES (WINDOW-N-PLINES WINDOW)
	POINT (WINDOW-POINT WINDOW)
	INTERVAL (WINDOW-INTERVAL WINDOW)
	START-BP (WINDOW-START-BP WINDOW)
	FIRST-BP (INTERVAL-FIRST-BP INTERVAL)
	LAST-BP (INTERVAL-LAST-BP INTERVAL)
	POSITION-TYPE :LINE)
  (SELECTQ RECENTER-TYPE
    (:ABSOLUTE
     (SELECTQ RC2
       (:LINE
	(IF ( RC1 0)
	    (SETQ POINT-PLINE RC1
		  POSITION-TYPE :LINE)
	    ;; Position point at end of window by line number.
	    ;; Compute position of start of window if that were that many lines back, ...
	    (MULTIPLE-VALUE-BIND (LINE INDEX REAL-PLINE)
		(PUT-POINT-AT-PLINE SHEET (BP-LINE POINT) (BP-INDEX POINT)
				    RC1 FIRST-BP LAST-BP :LINE)
	      (LET ((BOTTOM (TV:SHEET-INSIDE-HEIGHT SHEET)))
		(WHEN (> REAL-PLINE RC1)
		  ;; If we tried to move past the end of the buffer for that, compute
		  ;; size of ending portion of the buffer and place things that far up.
		  (MULTIPLE-VALUE-BIND (NIL NIL NIL Y)
		      (PUT-POINT-AT-PLINE SHEET LINE INDEX
					  (- REAL-PLINE RC1) FIRST-BP LAST-BP :LINE)
		    (DECF BOTTOM Y)))
		;; and arrange for that to be just past the bottom
		(MULTIPLE-VALUE (LINE INDEX)
		  (PUT-POINT-AT-PLINE SHEET LINE INDEX BOTTOM
				      FIRST-BP LAST-BP :PIXEL)))
	      (RETURN-FROM RECENTER-WINDOW
		(RECENTER-WINDOW WINDOW :START LINE INDEX)))))
       (:PIXEL
	(SETQ POINT-PLINE RC1
	      POSITION-TYPE RC2))
       (OTHERWISE
	(SETQ POINT-PLINE (FIX (* (OR RC1 *CENTERING-FRACTION*)
				  (TV:SHEET-INSIDE-HEIGHT SHEET)))
	      POSITION-TYPE :PIXEL))))
    ((:START :START-IF-POSSIBLE)
      ;; The new start has been specified explicitly.
      (IF RC2
	  (SETQ TOP-LINE RC1 TOP-INDEX RC2)
	  (SETQ TOP-LINE (BP-LINE RC1) TOP-INDEX (BP-INDEX RC1)))
      (MOVE-BP START-BP TOP-LINE TOP-INDEX)
      (SETF (WINDOW-REDISPLAY-DEGREE WINDOW)
	    (SETQ DEGREE (MAX (WINDOW-REDISPLAY-DEGREE WINDOW) DIS-TEXT)))
      (LET ((P (PLINE-OF-POINT T WINDOW POINT)))
	(WHEN (AND (NULL P) (EQ RECENTER-TYPE :START))
	  (MOVE-WINDOW-POINT WINDOW TOP-LINE TOP-INDEX)
	  (SETQ POINT-PLINE 0))))
    (:RELATIVE
      ;; Move POINT by RC1 plines in RC2 units.
      (OR RC2 (SETQ RC2 :LINE))
      (WHEN (EQ RC2 :SCREEN)
	(SELECTOR RC1 =
	  (+1					;c-V: put bottom line at top
	    (IF ( DEGREE DIS-BPS)
		(SETQ RC1 (1- (WINDOW-N-PLINES WINDOW))
		      RC2 :LINE)
	      (MULTIPLE-VALUE-BIND (LINE INDEX)
		  (PUT-POINT-AT-PLINE SHEET (BP-LINE START-BP) (BP-INDEX START-BP)
				      (- (POINT-LINE-HEIGHT SHEET START-BP)
					 (TV:SHEET-INSIDE-HEIGHT SHEET))
				      FIRST-BP LAST-BP :PIXEL)
		(RETURN-FROM RECENTER-WINDOW
		  (RECENTER-WINDOW WINDOW :START LINE INDEX)))))
	  (-1					;m-V: put top line at bottom
	    (IF (AND (NOT (WINDOW-LAST-BP-DISPLAYED-P WINDOW))
		     ( DEGREE DIS-BPS))
		(SETQ RC1 (- 1 (WINDOW-N-PLINES WINDOW))
		      RC2 :LINE)
	      (MULTIPLE-VALUE-BIND (LINE INDEX)
		  (PUT-POINT-AT-PLINE SHEET (BP-LINE START-BP) (BP-INDEX START-BP)
				      (- (TV:SHEET-INSIDE-HEIGHT SHEET)
					 (POINT-LINE-HEIGHT SHEET START-BP))
				      FIRST-BP LAST-BP :PIXEL)
		(RETURN-FROM RECENTER-WINDOW
		  (RECENTER-WINDOW WINDOW :START LINE INDEX)))))
	  (OTHERWISE
	    (SETQ RC1 (* RC1 (TV:SHEET-INSIDE-HEIGHT (WINDOW-SHEET WINDOW)))
		  RC2 :PIXEL))))
      (COND ((AND (EQ RC2 :LINE)
		  ( DEGREE DIS-BPS)
		  ( RC1 0)
		  (< RC1 N-PLINES)
		  (PLINE-LINE WINDOW RC1))
	     ;; What luck! No text has changed, and the goal PLINE is in the window.
	     (IF ( (PLINE-FROM-INDEX WINDOW RC1) 0)
		 (SETQ TOP-LINE (PLINE-LINE WINDOW RC1)
		       TOP-INDEX (PLINE-FROM-INDEX WINDOW RC1))
		 (SETQ TOP-LINE (LINE-NEXT-IN-BUFFER (PLINE-LINE WINDOW RC1) :BUFFER INTERVAL)
		       TOP-INDEX 0))
	     (WHEN (< (WINDOW-LAST-POINT-PLINE WINDOW) RC1)
	       (MOVE-WINDOW-POINT WINDOW TOP-LINE TOP-INDEX)
	       (SETQ POINT-PLINE 0)))
	    (T
	     (SETQ TOP-LINE (BP-LINE START-BP)
		   TOP-INDEX (BP-INDEX START-BP))
	     (MULTIPLE-VALUE-BIND (P Y)
		 (PLINE-OF-POINT NIL WINDOW POINT)
	       (SETQ POSITION-TYPE RC2
		     POINT-PLINE (- (IF (EQ RC2 :LINE) P Y) RC1)))))))
  (COND (POINT-PLINE
	 (MULTIPLE-VALUE (TOP-LINE TOP-INDEX POINT-PLINE POINT-Y)
	   (PUT-POINT-AT-PLINE SHEET (BP-LINE POINT) (BP-INDEX POINT) POINT-PLINE
			       FIRST-BP LAST-BP POSITION-TYPE))
	 ;; If recentering pushes point out the top or bottom, pull it back
	 ;; just far enough to be back inside.  Also update POINT-PLINE for how point moves.
	 (WHEN (MINUSP POINT-PLINE)
	   (SETQ POINT-PLINE 0
		 POINT-Y 0)
	   (MOVE-WINDOW-POINT WINDOW TOP-LINE TOP-INDEX))
	 (WHEN (PLUSP POINT-Y)
	   (LET ((LINE-HEIGHT (POINT-LINE-HEIGHT SHEET POINT)))
	     (WHEN (> (+ POINT-Y LINE-HEIGHT) (TV:SHEET-INSIDE-HEIGHT SHEET))
	       (SETQ POINT-Y (- (TV:SHEET-INSIDE-HEIGHT SHEET) LINE-HEIGHT))
	       (MULTIPLE-VALUE-BIND (POINT-LINE POINT-INDEX)
		   (PUT-POINT-AT-PLINE SHEET TOP-LINE TOP-INDEX (- POINT-Y)
				       FIRST-BP LAST-BP :PIXEL)
		 (MOVE-WINDOW-POINT WINDOW POINT-LINE POINT-INDEX)))))
	 (SETF (WINDOW-LAST-POINT-PLINE WINDOW) POINT-PLINE)))
  (MOVE-BP START-BP TOP-LINE TOP-INDEX)
  (NOTIFY-SCROLL-BAR WINDOW)
  (SETF (WINDOW-REDISPLAY-DEGREE WINDOW) (MAX DEGREE DIS-TEXT)))

(DEFFLAVOR REDISPLAY-CERROR
	()
	(CLI::DEFAULT-ERROR))
(COMPILE-FLAVOR-METHODS REDISPLAY-CERROR)

;;;   This function is the only entrypoint into redisplay proper.  It does
;;; anything anyone would ever need (ha ha).
;;; The first argument is the window to be redisplayed.
;;; The second argument is a keyword which says what kind of recentering
;;; is desired, and the third and fourth arguments are parameters whose meanings depend
;;; on the second argument.  Valid keywords are:
;;;   Recentering type:       Parameters:      Meaning:
;;;         :NONE             (none)           Do not recenter at all.
;;;         :POINT            raster_fraction  Keep POINT's blinker on the window.  If
;;;                                            necessary, recenter.  Recenter in such a
;;;                                            way that the blinker ends up near the given
;;;                                            raster line.  If raster_fraction is NIL, 
;;;                                            the *CENTERING-FRACTION* is used.
;;;         :START            line, index      Recenter so that the position (line, index)
;;;                            (or a bp)       appears at the top of the window.
;;;	    :START-IF-POSSIBLE  (same)	       Same as :START, but if that would move POINT
;;;					       off the window, do nothing.
;;;         :RELATIVE         number,unit      Recenter to scroll window up <number> units.
;;;                                            If <unit> is negative, scroll down.  Unit
;;;                                            is :LINE, :PIXEL, or :SCREEN.
;;;         :ABSOLUTE         number,unit      Same as :POINT except always recenter, if
;;;         					no unit.  Else unit is :LINE or :PIXEL
;;;         					and number is new position in those units.

;;; The elements of a window PLINE are the:
;;; PLINE-LINE			;Editor line displayed, NIL if blank
;;; PLINE-FROM-INDEX		;First character displayed
;;; PLINE-TO-INDEX		;Last character displayed+1
;;; PLINE-TICK			;TICK as of last time pline updated on display
;;; PLINE-MARKING-LEFT		;NIL no marking, or X coord of start of region-marking
;;; PLINE-MARKING-WIDTH		;Horizontal extent of marking
;;; PLINE-TEXT-WIDTH		;Horizontal extent of text
;;; PLINE-Y  			;Vertical position of pline
;;; PLINE-LINE-HEIGHT		;Height of this pline
;;; Note that for non-continuation lines, PLINE-TEXT-WIDTH includes a little
;;; extra for the pseudo-space at the end of the line which corresponds to the #\CR.
;;; PLINE-TEXT-WIDTH is used only for region marking.

(DEFUN REDISPLAY (WINDOW &OPTIONAL (RECENTER-TYPE ':POINT)
                         RC1 RC2 (FORCE-TO-COMPLETION-P NIL))
  (PREPARE-WINDOW-FOR-REDISPLAY WINDOW)
  (LET* ((N-PLINES (WINDOW-N-PLINES WINDOW))
	 (MAX-N-PLINES (ARRAY-DIMENSION-N 2 WINDOW))
	 (POINT (WINDOW-POINT WINDOW))
	 (SHEET (WINDOW-SHEET WINDOW))
	 (MAX-Y (SEND SHEET :INSIDE-HEIGHT))
	 (VSP (WINDOW-VSP WINDOW))
	 (DEGREE (WINDOW-REDISPLAY-DEGREE WINDOW))
	 (POINT-BLINKER (WINDOW-POINT-BLINKER WINDOW))
	 (INTERVAL (WINDOW-INTERVAL WINDOW))
	 (START-BP (WINDOW-START-BP WINDOW))
	 (NOW (TICK))
	 (POINT-LINE (BP-LINE POINT))
	 (POINT-INDEX (BP-INDEX POINT))
	 (TOP-LINE (BP-LINE START-BP))
	 (TOP-INDEX (BP-INDEX START-BP))
	 (LAST-BP (INTERVAL-LAST-BP INTERVAL))
	 (INITIAL-DEGREE DEGREE)
	 ;; Bind *INTERVAL* in case we decide to call any primitives, e.g. inside the
	 ;; special-blinker which blinks matching parens.  This is an implicit argument.
	 (*INTERVAL* INTERVAL)
	 POINT-PLINE
	 LAST-VISIBLE-LINE)
    (CATCH-ERROR-RESTART ((ERROR) "Skip redisplay")
     (BLOCK ABORT-REDISPLAY
      ;; We prefer not to start redisplay in the middle of a line.
      ;; The start-bp of the window may have ended up there via a command like rubout at
      ;; the beginning of the window or may have been scrolled there explicitly.  If the
      ;; start-bp would be at the beginning of a pline if redisplay had started at
      ;; the beginning of the line, then it is right.  Otherwise it is wrong and we should
      ;; recenter unless that would move point entirely off the window.
      (AND (EQ RECENTER-TYPE ':POINT)
	   (NOT (ZEROP TOP-INDEX))
	   (EQ POINT-LINE TOP-LINE)
	   ;; This next predicate prevents proper redisplay when the only line in the
	   ;; window is the last line (which has no Newline at the end).  We can't figure
	   ;; out what it is there for, so it's commented out.  -- Dodds 5/07/87
	   ;(> N-PLINES 1)
	   (LET ((NEW-TOP-INDEX (IF (EQ TOP-LINE (BP-LINE (INTERVAL-FIRST-BP INTERVAL)))
				    (BP-INDEX (INTERVAL-FIRST-BP INTERVAL))
				    0)))
	     (AND (NOT (ZEROP (SEND SHEET :COMPUTE-MOTION TOP-LINE NEW-TOP-INDEX
							  TOP-INDEX 0 0 NIL 0 NIL NIL NIL T)))
		  (MULTIPLE-VALUE-BIND (NIL Y)
		      (SEND SHEET :COMPUTE-MOTION TOP-LINE NEW-TOP-INDEX
						  POINT-INDEX 0 0 NIL 0 NIL NIL NIL T)
		    (< Y MAX-Y))
		  (SETQ RECENTER-TYPE ':ABSOLUTE))))
      ;; :POINT recentering is a conditional sort of :ABSOLUTE recentering.
      ;; So decide here whether :ABSOLUTE recentering should be done.
      (AND (EQ RECENTER-TYPE ':POINT)
	   (COND (( DEGREE DIS-MARK-GOES))
		 ;; When typing at the end of the line, dont try to compute POINT-PLINE yet,
		 ;; but wait till after we have faked out the pline-text-width correctly.
		 ;; Otherwise it will be much, much slower
		 ((AND (= DEGREE DIS-LINE)
		       (EQ (WINDOW-REDISPLAY-LINE WINDOW) POINT-LINE)
		       ;; I don't know what this test was for.  It seems to only make typing
		       ;; at the end of the buffer slower.  The first character to generate
		       ;; a continuation line off the screen still works properly without it.
		       ;; (NEQ POINT-LINE (PLINE-LINE WINDOW (1- N-PLINES)))
		       (OR ( (1+ (WINDOW-REDISPLAY-INDEX WINDOW)) POINT-INDEX)
			   (= (MULTIPLE-VALUE-BIND (NIL Y)
				  (FUNCALL SHEET ':COMPUTE-MOTION POINT-LINE
					   0 POINT-INDEX 0 0 T)
				Y)
			      0))))
		 ((SETQ POINT-PLINE (PLINE-OF-POINT T WINDOW POINT)))
		 (T (SETQ RECENTER-TYPE ':ABSOLUTE))))
      ;; If recentering is needed, do it, and see what changes it made.
      (UNLESS (MEMQ RECENTER-TYPE '(:NONE :POINT))
	(RECENTER-WINDOW WINDOW RECENTER-TYPE RC1 RC2)
	(SETQ DEGREE (WINDOW-REDISPLAY-DEGREE WINDOW)
	      START-BP (WINDOW-START-BP WINDOW)
	      TOP-LINE (BP-LINE START-BP)
	      TOP-INDEX (BP-INDEX START-BP)
	      POINT-LINE (BP-LINE POINT)
	      POINT-INDEX (BP-INDEX POINT))
	;; Gobble point-pline as computed by recenter-window
	;; if it is accurate.
	(SETQ POINT-PLINE (WINDOW-LAST-POINT-PLINE WINDOW))
	(OR (AND 
		 ;; The following predicate keeps it from blowing out when you forward-char
		 ;; off the end of a window on a line that is more than one pline long, but
		 ;; fails to recenter at all.  Needs more debugging. -- Dodds 5/07/87
		 ;(< POINT-PLINE MAX-N-PLINES)
		 (EQ POINT-LINE (PLINE-LINE WINDOW POINT-PLINE))
		 ( (PLINE-FROM-INDEX WINDOW POINT-PLINE) POINT-INDEX)
		 (< POINT-INDEX (PLINE-TO-INDEX WINDOW POINT-PLINE)))
	    (SETQ POINT-PLINE NIL)))
      ;; Now we have TOP-LINE and TOP-INDEX, and possibly POINT-PLINE.

      ;; First, handle the case where just one line needs to be updated.
      (WHEN (= DEGREE DIS-LINE)
	(LET ((LINE (WINDOW-REDISPLAY-LINE WINDOW))
	      (INDEX (WINDOW-REDISPLAY-INDEX WINDOW)))
	  (LET ((P (FIND-BP-IN-WINDOW WINDOW LINE INDEX))
		(LINE-LENGTH (IF (EQ LINE (BP-LINE LAST-BP)) (BP-INDEX LAST-BP)
				 (LINE-LENGTH LINE)))
		START-X)
	    ;; LEN gets the raster position in the pline P
	    ;; of the character in LINE at position INDEX.
	    (WHEN P
	      (MULTIPLE-VALUE (NIL NIL START-X)
		(LINE-NUMBER-OF-PLINES SHEET LINE (PLINE-FROM-INDEX WINDOW P) INDEX)))
	    (COND ((AND P
			;; If P and LEN say we are at the start of a continuation line,
			;; then maybe they are wrong
			;; (if the contin line has been exactly deleted).
			(OR (NOT (ZEROP START-X))
			    (ZEROP INDEX)))
		   ;; Reverse-video region marking must be removed before updating.
		   (AND (EQ *REGION-MARKING-MODE* ':REVERSE-VIDEO)
			(OR (PLINE-MARKING-LEFT WINDOW P)
			    (PLINE-MARKING-LEFT WINDOW (MIN (1+ P) (1- N-PLINES))))
			(REGION-UNMARK-PLINE WINDOW P))
		   ;; Go to the place in the line where changes start. Clear from there.
		   ;; This means that any region marking from there on is gone now.
		   (COND ((AND (PLINE-MARKING-LEFT WINDOW P)
			       (< (PLINE-MARKING-LEFT WINDOW P) START-X))
			  (SETF (PLINE-MARKING-WIDTH WINDOW P)
				(MIN (- START-X (PLINE-MARKING-LEFT WINDOW P))
				     (PLINE-MARKING-WIDTH WINDOW P))))
			 (T (SETF (PLINE-MARKING-LEFT WINDOW P) NIL)
			    (SETF (PLINE-MARKING-WIDTH WINDOW P) NIL)))
		   (MULTIPLE-VALUE-BIND (WIDTH HEIGHT BASELINE NEW-INDEX)
		       (LINE-DISPLAYED-SIZE SHEET LINE INDEX LINE-LENGTH START-X)
		     (COND ((AND (EQL BASELINE (PLINE-BASELINE WINDOW P))
				 (EQL HEIGHT (PLINE-HEIGHT WINDOW P)))
			    (LET ((START-INDEX INDEX)
				  (START-X START-X))
			      (MULTIPLE-VALUE-BIND (LEFT-KERN-INDEX-ADJUSTMENT
						    LEFT-KERN-X-ADJUSTMENT)
				  (BACK-INDEX-OVER-OVERLAPPING-CHARACTER-KERNING
				    LINE INDEX SHEET)
				(WHEN LEFT-KERN-INDEX-ADJUSTMENT
				  (DECF START-INDEX LEFT-KERN-INDEX-ADJUSTMENT)
				  (DECF START-X LEFT-KERN-X-ADJUSTMENT)
				  ;; Don't let the left-kern back past start of window
				  (WHEN (MINUSP START-X)
				    (SETQ START-X 0
					  START-INDEX (PLINE-FROM-INDEX WINDOW P)))))
			      (DISPLAY-LINE SHEET LINE START-INDEX NEW-INDEX
					    START-X (PLINE-Y WINDOW P)
					    WIDTH HEIGHT BASELINE VSP))
			    ;; We have output the first PLINE of this line
			    (LET ((CONTINUATION-NEEDED (< NEW-INDEX LINE-LENGTH)))
			      (UNLESS CONTINUATION-NEEDED
				(INCF NEW-INDEX))
			      (SETF (PLINE-TEXT-WIDTH WINDOW P)
				    (IF CONTINUATION-NEEDED WIDTH
					(+ WIDTH (TV:SHEET-CHAR-WIDTH SHEET))))	;Allow for CR
			      (WHEN CONTINUATION-NEEDED
				(DISPLAY-CONTINUATION-MARKER SHEET (PLINE-Y WINDOW P)
							     HEIGHT)))
			    (SETF (PLINE-TO-INDEX WINDOW P) NEW-INDEX)
			    (SETF (PLINE-TICK WINDOW P) NOW)
			    ;; See if plines below this need to be redisplayed, due
			    ;; to line-continuation issues
			    (WHEN (AND ( (+ (PLINE-Y WINDOW P) HEIGHT VSP) MAX-Y)
				       (OR ( NEW-INDEX LINE-LENGTH)
					   ( WIDTH (TV:SHEET-INSIDE-WIDTH SHEET))
					   (AND (< (1+ P) N-PLINES)
						(EQ (PLINE-LINE WINDOW (1+ P)) LINE))))
			      (SETQ DEGREE DIS-TEXT POINT-PLINE NIL)
			      ;; If we are just creating a new continuation line, make it
			      ;; still look munged, so REDISPLAY-BLT can understand.
			      (UNLESS (AND (< (1+ P) N-PLINES)
					   (EQ (PLINE-LINE WINDOW (1+ P)) LINE))
				(SETF (PLINE-TICK WINDOW P) -1))))
			   (T
			    ;; Line has changed height, must do more redisplay.
			    (SETQ DEGREE DIS-TEXT POINT-PLINE NIL)))))
		  (T
		   (SETQ DEGREE DIS-TEXT POINT-PLINE NIL))))))
	  ;; If all the window should be redisplayed, mark each pline as unknown.
	  (WHEN ( DEGREE DIS-ALL)
	    (SEND SHEET :CLEAR-WINDOW)
	    (DO I 0 (1+ I) (= I N-PLINES)
		(SETF (PLINE-TICK WINDOW I) -1)
		(SETF (PLINE-MARKING-LEFT WINDOW I) NIL)))
	  (WHEN ( DEGREE DIS-TEXT)
	    ;; In case we abort before we are done, don't forget what's needed.
	    (SETF (WINDOW-REDISPLAY-DEGREE WINDOW) DIS-TEXT)
	    (SETF (WINDOW-LAST-BP-DISPLAYED-P WINDOW) NIL)
	    (DO L (WINDOW-SPECIAL-BLINKER-LIST WINDOW) (CDR L) (NULL L)
		(TV:BLINKER-SET-VISIBILITY (CDAR L) NIL))
	    ;; Abort now if input available
	    (AND (NOT FORCE-TO-COMPLETION-P)
		 (FUNCALL STANDARD-INPUT ':LISTEN)
		 (RETURN-FROM ABORT-REDISPLAY NIL))
	    ;; Attempt to do insert and delete line cleverness.
	    (REDISPLAY-BLT WINDOW)
	    ;; This might have invalidated the value of POINT-PLINE.
	    ;; It won't be hard to recompute, so do so.
	    (SETQ POINT-PLINE NIL
		  N-PLINES (WINDOW-N-PLINES WINDOW))
	    ;; Unless the height needed for each pline in the new display is the same as
	    ;; that for the corresponding pline in the old, reverse-video region marking
	    ;; must be removed before redisplaying any lines to avoid ugly interactions
	    ;; when line height changes.  Unfortunately, this also causes ugly effects:
	    ;; the redisplay is sometimes jerky because first all the region marking is
	    ;; cleared, and then all the lines are repainted (perhaps with region marking).
	    ;; But this is momentary and minimal, better than permanent reversed stripes.
	    (WHEN (AND (EQ *REGION-MARKING-MODE* :REVERSE-VIDEO)
		       (LOOP FOR PLINE FROM 0 BELOW N-PLINES
			     THEREIS (PLINE-MARKING-LEFT WINDOW PLINE))	; for speed
		       (LOOP NAMED LINE-HEIGHTS-CHANGED
			     WITH TO-INDEX AND NEW-Y
			     WITH PLINE = 0
			     AND Y = 0
			     AND STOP-LINE = (BP-LINE LAST-BP)
			     FOR LINE FIRST TOP-LINE
				      THEN (LINE-NEXT-IN-BUFFER LINE :BUFFER INTERVAL)
			     FOR FROM-INDEX FIRST TOP-INDEX THEN 0 DO
			 ;; Check for falling off the end of LINE-NEXT chain
			 (WHEN (OR (NULL LINE)
				   (EQ (LINE-TICK LINE) 'DELETED))
			   (CL:CERROR 'REDISPLAY-CERROR
				      "Reset WINDOW-START-BP and attempt to continue"
				      "WINDOW-START-BP is not in the interval being displayed")
			   (MOVE-BP START-BP (INTERVAL-FIRST-BP INTERVAL))
			   (MOVE-WINDOW-POINT WINDOW START-BP)
			   (RETURN-FROM ABORT-REDISPLAY NIL))
			 (SETQ TO-INDEX (IF (EQ LINE STOP-LINE) (BP-INDEX LAST-BP)
					  (LINE-LENGTH LINE)))
			 ;; Now loop over the plines of this line.
			 (LOOP DO
			   ;; Check for a line that has not been changed.
			   (COND ((AND (< PLINE N-PLINES)
				       (EQ LINE (PLINE-LINE WINDOW PLINE))
				       (> (PLINE-TICK WINDOW PLINE) (LINE-TICK LINE))
				       (= (PLINE-FROM-INDEX WINDOW PLINE) FROM-INDEX)
				       (= (PLINE-Y WINDOW PLINE) Y))
				  (SETQ FROM-INDEX (PLINE-TO-INDEX WINDOW PLINE)
					NEW-Y (+ Y (PLINE-HEIGHT WINDOW PLINE) VSP)))
				 (T
				  (MULTIPLE-VALUE-BIND (NIL HEIGHT NIL NEW-INDEX)
				      (LINE-DISPLAYED-SIZE SHEET LINE FROM-INDEX TO-INDEX)
				    (SETQ NEW-Y (+ Y HEIGHT VSP))
				    (WHEN (OR (> NEW-Y MAX-Y)	; bottom of window
					      ( PLINE N-PLINES))	;no old plines left
				      (RETURN-FROM LINE-HEIGHTS-CHANGED NIL))
				    (UNLESS (= NEW-Y (+ (PLINE-Y WINDOW PLINE)
							(PLINE-HEIGHT WINDOW PLINE) VSP))
				      (RETURN-FROM LINE-HEIGHTS-CHANGED T))
				    (LET ((CONTINUATION-NEEDED (< NEW-INDEX
								  (LINE-LENGTH LINE))))
				      (UNLESS CONTINUATION-NEEDED
					(INCF NEW-INDEX)))
				    (SETQ FROM-INDEX NEW-INDEX))))
			   (SETQ Y NEW-Y)
			   (SETQ PLINE (1+ PLINE))
			   (WHEN (> FROM-INDEX TO-INDEX) (RETURN)))
			 ;; Check for the last line in the interval.
			 (WHEN (EQ LINE STOP-LINE)
			   (RETURN-FROM LINE-HEIGHTS-CHANGED NIL))))
	      (LOOP FOR PLINE FROM 0 BELOW N-PLINES
		    WHEN (OR (PLINE-MARKING-LEFT WINDOW PLINE)
			     (PLINE-MARKING-LEFT WINDOW (MIN (1+ PLINE) (1- N-PLINES))))
		      DO (REGION-UNMARK-PLINE WINDOW PLINE)))
	    ;; First loop over actual lines.
	    (DO-NAMED LINES
		      ((LINE TOP-LINE (LINE-NEXT-IN-BUFFER LINE :BUFFER INTERVAL))
		       (FROM-INDEX TOP-INDEX 0)
		       (TO-INDEX)
		       (PLINE 0)
		       (Y 0) (NEW-Y)
		       (STOP-LINE (BP-LINE LAST-BP))
		       (LAST-VISIBLE-END (IF (PLUSP N-PLINES)
					     (+ (PLINE-Y WINDOW (1- N-PLINES))
						(PLINE-HEIGHT WINDOW (1- N-PLINES)))
					     0)))
		      (NIL)
	      (LABELS ((END-OF-LINES ()
			 (WHEN (OR (< PLINE N-PLINES)	;Fewer lines this time
				   (< Y LAST-VISIBLE-END))	;or shorter
			   ;; Clear out any junk at the bottom of the screen;
			   ;; we cannot use :set-cursorpos / clear-rest-of-window, because it
			   ;; honors line-height and we may wish to clear a partial line.
			   (SEND SHEET :DRAW-RECTANGLE (TV:SHEET-INSIDE-WIDTH SHEET)
				 (- (TV:SHEET-INSIDE-HEIGHT SHEET) Y) 0 Y :ERASE))
			 (SETQ N-PLINES PLINE)
			 (SETF (WINDOW-N-PLINES WINDOW) N-PLINES)
			 (SETQ LAST-VISIBLE-LINE LINE)
			 (RETURN-FROM LINES)))
		;; Check for falling off the end of LINE-NEXT chain
		(WHEN (OR (NULL LINE)
			  (EQ (LINE-TICK LINE) 'DELETED))
		  (CL:CERROR 'REDISPLAY-CERROR
			     "Reset WINDOW-START-BP and attempt to continue"
			     "WINDOW-START-BP is not in the interval being displayed")
		  (MOVE-BP START-BP (INTERVAL-FIRST-BP INTERVAL))
		  (MOVE-WINDOW-POINT WINDOW START-BP)
		  (RETURN-FROM ABORT-REDISPLAY NIL))
		;; Between lines, check for input available and abort if so.
		(AND (NOT FORCE-TO-COMPLETION-P)
		     (ZEROP (\ PLINE 30.))
		     (FUNCALL STANDARD-INPUT ':LISTEN)
		     (RETURN-FROM ABORT-REDISPLAY NIL))
		(SETQ TO-INDEX (IF (EQ LINE STOP-LINE) (BP-INDEX LAST-BP)
				   (LINE-LENGTH LINE)))
		;; Now loop over the plines of this line.
		(DO ()
		    (NIL)
		  ;; Check for a line that has not been changed.
		  (COND ((AND (< PLINE N-PLINES)
			      (EQ LINE (PLINE-LINE WINDOW PLINE))
			      (> (PLINE-TICK WINDOW PLINE) (LINE-TICK LINE))
			      (= (PLINE-FROM-INDEX WINDOW PLINE) FROM-INDEX)
			      (= (PLINE-Y WINDOW PLINE) Y))
			 (SETQ FROM-INDEX (PLINE-TO-INDEX WINDOW PLINE)
			       NEW-Y (+ Y (PLINE-HEIGHT WINDOW PLINE) VSP)))
			(T
			 (MULTIPLE-VALUE-BIND (WIDTH HEIGHT BASELINE NEW-INDEX)
			     (LINE-DISPLAYED-SIZE SHEET LINE FROM-INDEX TO-INDEX)
			   (SETQ NEW-Y (+ Y HEIGHT VSP))
			   (WHEN (> NEW-Y MAX-Y)
			     ;; Bottom of window reached.  Is next line the last
			     ;; one, and is it empty?
			     (WHEN (AND (EQ LINE STOP-LINE)
					(= (BP-INDEX LAST-BP) 0))
			       ;; then pretend last BP is displayed, because there
			       ;; is nothing more to show...
			       (SETF (WINDOW-LAST-BP-DISPLAYED-P WINDOW) T))
			     (END-OF-LINES))
			   (DISPLAY-LINE SHEET LINE FROM-INDEX NEW-INDEX 0 Y
					 WIDTH HEIGHT BASELINE VSP)
			   (WHEN ( PLINE N-PLINES)
			     (SETQ N-PLINES (1+ PLINE))
			     (WHEN (> N-PLINES MAX-N-PLINES)
			       (ASSURE-ROOM-FOR-N-PLINES WINDOW N-PLINES)
			       (SETQ MAX-N-PLINES (ARRAY-DIMENSION-N 2 WINDOW)))
			     (SETF (WINDOW-N-PLINES WINDOW) N-PLINES))
			   (SETF (PLINE-LINE WINDOW PLINE) LINE)
			   (SETF (PLINE-FROM-INDEX WINDOW PLINE) FROM-INDEX)
			   (SETF (PLINE-TICK WINDOW PLINE) NOW)
			   (SETF (PLINE-MARKING-LEFT WINDOW PLINE) NIL)
			   (LET ((CONTINUATION-NEEDED (< NEW-INDEX
							 (LINE-LENGTH LINE))))
			     (UNLESS CONTINUATION-NEEDED
			       (INCF NEW-INDEX))
			     (SETF (PLINE-TEXT-WIDTH WINDOW PLINE)
				   (IF CONTINUATION-NEEDED WIDTH
				       (+ WIDTH (TV:SHEET-CHAR-WIDTH SHEET))))
			     (WHEN CONTINUATION-NEEDED
			       (DISPLAY-CONTINUATION-MARKER SHEET Y HEIGHT)))
			   (SETF (PLINE-TO-INDEX WINDOW PLINE) NEW-INDEX)
			   (SETF (PLINE-Y WINDOW PLINE) Y)
			   (SETF (PLINE-BASELINE WINDOW PLINE) BASELINE)
			   (SETF (PLINE-HEIGHT WINDOW PLINE) HEIGHT)
			   (SETQ FROM-INDEX NEW-INDEX))))
		  (SETQ Y NEW-Y)
		  (SETQ PLINE (1+ PLINE))
		  (WHEN (> FROM-INDEX TO-INDEX) (RETURN)))
		;; Check for the last line in the interval.
		(WHEN (EQ LINE STOP-LINE)
		  (SETF (WINDOW-LAST-BP-DISPLAYED-P WINDOW) T)
		  (END-OF-LINES)))))
	  (WHEN ( DEGREE DIS-BPS)
	    ;; BPs have moved.  Reposition the POINT blinker.
	    (OR POINT-PLINE
		(SETQ POINT-PLINE (FIND-BP-IN-WINDOW WINDOW POINT-LINE POINT-INDEX))
		(EQ RECENTER-TYPE ':NONE)
		(IF (AND (= INITIAL-DEGREE DIS-LINE) (= DEGREE DIS-TEXT))
		    ;;Somewhat anomalous case, try again with greater redisplay degree
		    (RETURN-FROM ABORT-REDISPLAY
		      (REDISPLAY WINDOW RECENTER-TYPE RC1 RC2 FORCE-TO-COMPLETION-P))
		    ;; Point somehow got off the window.  Signal recoverable error.
		    (CL:CERROR 'REDISPLAY-CERROR
			       "Reset point and attempt to continue"
			       "Recenter type ~S left point outside the window" RECENTER-TYPE)
		    ;; Recover by moving point to top of window, since it probably somehow
		    ;; got moved to a nonexistent line.
		    (MOVE-WINDOW-POINT WINDOW START-BP)))
	    (COND ((NULL POINT-PLINE)
		   ;; POINT is not on the window, so make it go away.
		   (TV:BLINKER-SET-VISIBILITY POINT-BLINKER NIL))
		  (T
		   ;; POINT is on the window, find its Y position, set up the blinker.
		   (TV:BLINKER-SET-VISIBILITY POINT-BLINKER
					      (SEND *CURRENT-COMMAND-LOOP*
						    :POINT-BLINKER-VISIBILITY WINDOW))
		   (COND ((NOT (EQ POINT-LINE (PLINE-LINE WINDOW POINT-PLINE)))
			  (DPRINT POINT-LINE POINT-PLINE (PLINE-LINE WINDOW POINT-PLINE))
			  (FERROR "Position of POINT on window is screwed up:")))
		   (SET-BLINKER-SIZE
		     POINT
		     WINDOW
		     POINT-BLINKER
		     (MULTIPLE-VALUE-BIND (DIAGRAM LINE-MARGIN)
			 (LINE-SPECIAL-REDISPLAY-PROPERTIES POINT-LINE)
		       (IF DIAGRAM
			   (IF LINE-MARGIN
			       (LINE-MARGIN-SIZE LINE-MARGIN SHEET POINT-LINE)
			       0)
			   (LINE-DISPLAYED-SIZE SHEET POINT-LINE
						(PLINE-FROM-INDEX WINDOW POINT-PLINE)
						POINT-INDEX)))
		     (PLINE-Y WINDOW POINT-PLINE)
		     (PLINE-BASELINE WINDOW POINT-PLINE)
		     SHEET)
		   (SETF (WINDOW-LAST-POINT-PLINE WINDOW) POINT-PLINE)))
	    ;; Blink the parens, etc.
	    (WITH-STACK-LIST (END-BP LAST-VISIBLE-LINE 0)	;"with-stack-bp"
	      (WHEN (NULL (BP-LINE END-BP))
		;; Too bad LAST-VISIBLE-LINE only gets set when the redisplay
		;; degree is  DIS-TEXT
		(SETQ END-BP NIL))
	      (DOLIST (BL (WINDOW-SPECIAL-BLINKER-LIST WINDOW))
		(FUNCALL (CAR BL) (CDR BL) WINDOW POINT START-BP END-BP))))
	  (WHEN ( DEGREE DIS-MARK-GOES)
	    ;; The region marking may have changed.
	    (UPDATE-REGION-MARKING WINDOW))
	  ;;The character under the mouse also
	  (WHEN ( DEGREE DIS-BPS) (MOUSE-RETHINK WINDOW))
	  (WHEN ( DEGREE DIS-TEXT) (NOTIFY-SCROLL-BAR WINDOW))
	  (SETF (WINDOW-REDISPLAY-DEGREE WINDOW) DIS-NONE)
	  )))
  NIL)
 
(DEFUN ASSURE-ROOM-FOR-N-PLINES (WINDOW N-PLINES)
  (WHEN (> N-PLINES (ARRAY-DIMENSION-N 2 WINDOW))
    (ARRAY-GROW WINDOW *NUMBER-OF-PLINE-PARAMETERS* (// (* N-PLINES 3) 2))))

(DEFUN REDISPLAY-BLT (WINDOW)
  (LET* ((START-BP (WINDOW-START-BP WINDOW))
	 (N-PLINES (WINDOW-N-PLINES WINDOW))
	 (INTERVAL (WINDOW-INTERVAL WINDOW))
	 (NEW-FIRST-LINE (BP-LINE START-BP))
	 (FIRST-CHANGED-LINE NEW-FIRST-LINE) (FIRST-CHANGED-PLINE 0)
	 (SHEET (WINDOW-SHEET WINDOW))
	 LAST-OCCUPIED-PLINE
	 FIRST-UNCHANGED-PLINE FIRST-UNCHANGED-LINE
	 FIRST-UNCHANGED-LINE-NEW-PLINE)

    (UNLESS (PLUSP N-PLINES)
      (RETURN-FROM REDISPLAY-BLT NIL))

    (COND ((AND (EQ NEW-FIRST-LINE (PLINE-LINE WINDOW 0))
		(= (BP-INDEX START-BP) (PLINE-FROM-INDEX WINDOW 0)))
	   ;; Find the first place in the window at which anything is changed.
	   ;; FIRST-CHANGED-LINE gets the NEW line that should be displayed there.
	   ;; Make sure that FIRST-CHANGED-PLINE gets the FIRST pline of that line!
	   ;; When a character is inserted into a line which is continued,
	   ;; REDISPLAY's DIS-LINE processing updates the first pline including tick
	   ;; before noticing the continuation.  Then, the continuation pline would
	   ;; be the first mismatch!
	   (DO ((PLINE 0 (1+ PLINE))
		(VSP (WINDOW-VSP WINDOW))
		(Y 0 (+ Y (PLINE-HEIGHT WINDOW PLINE) VSP))
		(LINE NEW-FIRST-LINE))
	       ((OR ( PLINE N-PLINES)
		    (NEQ (PLINE-LINE WINDOW PLINE) LINE)
		    (< (PLINE-TICK WINDOW PLINE)
		       (LINE-TICK LINE))
		    ( Y (PLINE-Y WINDOW PLINE))))
	     (AND (> (PLINE-TO-INDEX WINDOW PLINE)
		     (LINE-LENGTH LINE))
		  (NOT (SETQ LINE (LINE-NEXT-IN-BUFFER LINE :BUFFER INTERVAL)
			     FIRST-CHANGED-PLINE (1+ PLINE)
			     FIRST-CHANGED-LINE LINE))
		  (RETURN-FROM REDISPLAY-BLT NIL)))))

      ;; Now find the last non-null line (that used to be) in the window.
      ;; LAST-OCCUPIED-PLINE says where to find it in the window.
      (DO ((PLINE (1- N-PLINES) (1- PLINE)))
          ((PLINE-LINE WINDOW PLINE)
           (SETQ LAST-OCCUPIED-PLINE PLINE))
        (AND (ZEROP PLINE) (RETURN-FROM REDISPLAY-BLT (VALUES))))
      ;; Now scan upward from there till we find a change.
      (DO ((PLINE LAST-OCCUPIED-PLINE (1- PLINE))
           (LINE (PLINE-LINE WINDOW LAST-OCCUPIED-PLINE)))
          ((OR (MINUSP PLINE)
               (NEQ (PLINE-LINE WINDOW PLINE) LINE)
               ;; Give up if we come across a deleted line.
               ;; That tells us that these lines are no longer relevant.
               (AND (EQ (LINE-TICK LINE) 'DELETED)
                    (RETURN-FROM REDISPLAY-BLT (VALUES)))
               (< (PLINE-TICK WINDOW PLINE)
                  (LINE-TICK LINE))))
        ;; If we have reached the line which will now occupy the first pline,
        ;; then if it will be split across the top of the window,
        ;; we must not include it in the blt.
        ;; If we are going to include it, we will exit after doing so
        ;; via the RETURN in the COND below.
        (AND (EQ LINE NEW-FIRST-LINE)
             (NOT (ZEROP (BP-INDEX START-BP)))
             (RETURN))
        ;; When we come move back past the start of a line in the window,
        ;; do so also in the interval,
        ;; and include the line we have moved over in the blt.
        ;; This way, a line which used to be split over the top of the window
        (COND ((ZEROP (PLINE-FROM-INDEX WINDOW PLINE))
               (SETQ FIRST-UNCHANGED-PLINE PLINE
                     FIRST-UNCHANGED-LINE LINE)
               (AND (EQ LINE NEW-FIRST-LINE)
                    (RETURN))
               (SETQ LINE (LINE-PREVIOUS-IN-BUFFER LINE :BUFFER INTERVAL)))))
      ;; FIRST-UNCHANGED-LINE is the first line of those to be blt'ed.
      ;; But make sure that it is still in the interval, and not too far away,
      ;; before we do anything to it.  Note, maybe we passed it in the last DO.
      (DO ((I N-PLINES (1- I))
           (LINE FIRST-UNCHANGED-LINE (LINE-PREVIOUS-IN-BUFFER LINE :BUFFER INTERVAL)))
          ((OR (ZEROP I) (NULL LINE)) (RETURN-FROM REDISPLAY-BLT (VALUES)))
        (AND (EQ LINE FIRST-CHANGED-LINE) (RETURN NIL)))
      ;; Now we know we can win, so find out where to blt FIRST-UNCHANGE-LINE to.
      (SETQ FIRST-UNCHANGED-LINE-NEW-PLINE
	    (+ FIRST-CHANGED-PLINE
	       (MULTIPLE-VALUE-BIND (NIL NIL PLINE-OFFSET)
		   (PUT-POINT-AT-PLINE SHEET FIRST-UNCHANGED-LINE 0
				       (- N-PLINES FIRST-CHANGED-PLINE)
				       (IF (ZEROP FIRST-CHANGED-PLINE) START-BP
					   (CREATE-BP FIRST-CHANGED-LINE
					     (IF (NEQ (PLINE-LINE WINDOW FIRST-CHANGED-PLINE)
						      FIRST-CHANGED-LINE)
						 0
						 (PLINE-FROM-INDEX WINDOW
								   FIRST-CHANGED-PLINE))))
				       NIL :LINE)
		 PLINE-OFFSET)))
      (AND ( FIRST-UNCHANGED-LINE-NEW-PLINE N-PLINES)
	   (RETURN-FROM REDISPLAY-BLT NIL))
      (AND (= FIRST-UNCHANGED-LINE-NEW-PLINE FIRST-UNCHANGED-PLINE)
	   (RETURN-FROM REDISPLAY-BLT NIL))
      ;; If the number of lines to be preserved is less than 1/4 of the distance they move,
      ;; don't bother moving them, since it looks ugly anyway.
      (AND (< (* 4 (- N-PLINES (MAX FIRST-UNCHANGED-LINE-NEW-PLINE FIRST-UNCHANGED-PLINE)))
	      (ABS (- FIRST-UNCHANGED-LINE-NEW-PLINE FIRST-UNCHANGED-PLINE)))
           (RETURN-FROM REDISPLAY-BLT NIL))
      ;; Eliminate any region marking on the first line to be moved
      ;; since it may overlap the vsp above the line, and get split by the move, yech.
      ;; It will get turned back on again if necessary by UPDATE-REGION-MARKING.
      ;; Done only if we are using solid region marking and there is marking where it matters.
      (WHEN (AND (EQ *REGION-MARKING-MODE* ':REVERSE-VIDEO)
		 (OR (PLINE-MARKING-LEFT WINDOW FIRST-UNCHANGED-PLINE)
		     (IF (< FIRST-UNCHANGED-LINE-NEW-PLINE FIRST-UNCHANGED-PLINE)
			 (PLINE-MARKING-LEFT WINDOW FIRST-UNCHANGED-LINE-NEW-PLINE)
			 (PLINE-MARKING-LEFT WINDOW
					     (- N-PLINES
						(- FIRST-UNCHANGED-LINE-NEW-PLINE
						   FIRST-UNCHANGED-PLINE)
						1)))))
	;; We have ascertained that there is marking that needs to be cleared out.
	(REGION-UNMARK-RANGE WINDOW FIRST-UNCHANGED-PLINE (1+ FIRST-UNCHANGED-PLINE))
	(IF (< FIRST-UNCHANGED-LINE-NEW-PLINE FIRST-UNCHANGED-PLINE)
	    ;; Copying upward.  Also flush region marking on old line being moved to.
	    (REGION-UNMARK-RANGE WINDOW FIRST-UNCHANGED-LINE-NEW-PLINE
				 (1+ FIRST-UNCHANGED-LINE-NEW-PLINE))
	    ;; Copying downward.  Flush region marking on last line moving to bottom.
	    (REGION-UNMARK-RANGE WINDOW
				 (- N-PLINES
				    (- FIRST-UNCHANGED-LINE-NEW-PLINE
				       FIRST-UNCHANGED-PLINE)
				    1)
				 N-PLINES)))
      ;; Now do the actual moving of text on the screen.
      (SEND SHEET :SET-CURSORPOS 0
	    (PLINE-Y WINDOW (MIN FIRST-UNCHANGED-LINE-NEW-PLINE FIRST-UNCHANGED-PLINE))
	    :PIXEL)
      (IF (< FIRST-UNCHANGED-LINE-NEW-PLINE FIRST-UNCHANGED-PLINE)
	  ;; Copying upward.
	  (SEND SHEET :DELETE-LINE
		(- (PLINE-Y WINDOW FIRST-UNCHANGED-PLINE)
		   (PLINE-Y WINDOW FIRST-UNCHANGED-LINE-NEW-PLINE))
		:PIXEL)
	  ;; Copying downward.
	  (LET ((MAX-Y (TV:SHEET-INSIDE-HEIGHT SHEET))
		(DELTA-Y (- (PLINE-Y WINDOW FIRST-UNCHANGED-LINE-NEW-PLINE)
			    (PLINE-Y WINDOW FIRST-UNCHANGED-PLINE))))
	    (SEND SHEET :INSERT-LINE DELTA-Y :PIXEL)
	    (LOOP FOR PLINE FROM FIRST-UNCHANGED-PLINE BELOW N-PLINES
		  DOING
	      (LET ((NEW-TOP (+ (PLINE-Y WINDOW PLINE) DELTA-Y)))
		(WHEN (> (+ NEW-TOP (PLINE-HEIGHT WINDOW PLINE) (WINDOW-VSP WINDOW)) MAX-Y)
		  ;; Cannot use :CLEAR-REST-OF-WINDOW because of exceptions.
		  (SEND SHEET :DRAW-RECTANGLE (TV:SHEET-INSIDE-WIDTH SHEET) (- MAX-Y NEW-TOP)
			0 NEW-TOP :ERASE)
		  (SETQ N-PLINES PLINE)
		  (RETURN))))
	    ;; Total up number of plines, is old visible (determined above) plus
	    ;; number inserted.
	    (INCF N-PLINES (- FIRST-UNCHANGED-LINE-NEW-PLINE FIRST-UNCHANGED-PLINE))
	    (ASSURE-ROOM-FOR-N-PLINES WINDOW N-PLINES)))
      ;; Now copy the contents of the window array just as we moved the bits.
      (LET ((INC (IF (< FIRST-UNCHANGED-LINE-NEW-PLINE FIRST-UNCHANGED-PLINE) 1 -1))
	    (DELTA-Y (- (PLINE-Y WINDOW FIRST-UNCHANGED-LINE-NEW-PLINE)
			(PLINE-Y WINDOW FIRST-UNCHANGED-PLINE)))
	    (NEW-START FIRST-UNCHANGED-LINE-NEW-PLINE))
	(AND (MINUSP INC) (SETQ NEW-START (1- N-PLINES)))
	(DO ((NEW-PLINE NEW-START (+ INC NEW-PLINE))
	     (OLD-PLINE (+ NEW-START (- FIRST-UNCHANGED-PLINE FIRST-UNCHANGED-LINE-NEW-PLINE))
			(+ INC OLD-PLINE)))
	    ((= OLD-PLINE N-PLINES)		;Ran off the bottom
	     (SETQ N-PLINES NEW-PLINE))
	  (WHEN (< OLD-PLINE FIRST-UNCHANGED-PLINE)	;Ran off the top
	    (RETURN))
	  (SETF (PLINE-LINE WINDOW NEW-PLINE)
		(PLINE-LINE WINDOW OLD-PLINE))
	  (SETF (PLINE-FROM-INDEX WINDOW NEW-PLINE)
		(PLINE-FROM-INDEX WINDOW OLD-PLINE))
	  (SETF (PLINE-TO-INDEX WINDOW NEW-PLINE)
		(PLINE-TO-INDEX WINDOW OLD-PLINE))
	  (SETF (PLINE-TEXT-WIDTH WINDOW NEW-PLINE)
		(PLINE-TEXT-WIDTH WINDOW OLD-PLINE))
	  (SETF (PLINE-MARKING-LEFT WINDOW NEW-PLINE)
		(PLINE-MARKING-LEFT WINDOW OLD-PLINE))
	  (SETF (PLINE-MARKING-WIDTH WINDOW NEW-PLINE)
		(PLINE-MARKING-WIDTH WINDOW OLD-PLINE))
	  (SETF (PLINE-TICK WINDOW NEW-PLINE)
		(PLINE-TICK WINDOW OLD-PLINE))
	  (SETF (PLINE-HEIGHT WINDOW NEW-PLINE)
		(PLINE-HEIGHT WINDOW OLD-PLINE))
	  (SETF (PLINE-BASELINE WINDOW NEW-PLINE)
		(PLINE-BASELINE WINDOW OLD-PLINE))
	  (SETF (PLINE-Y WINDOW NEW-PLINE)
		(+ (PLINE-Y WINDOW OLD-PLINE) DELTA-Y)))
	;; Mark as clear lines opened by insert line.
	(WHEN (MINUSP INC)
	  (DO ((PLINE FIRST-UNCHANGED-PLINE (1+ PLINE)))
	      ((= PLINE FIRST-UNCHANGED-LINE-NEW-PLINE))
	    (SETF (PLINE-MARKING-LEFT WINDOW PLINE) NIL)
	    (SETF (PLINE-LINE WINDOW PLINE) NIL)))
	(SETF (WINDOW-N-PLINES WINDOW) N-PLINES)))
  NIL)

;;; This is an internal function of REDISPLAY.
;;; Find the PLINE on which POINT should be displayed, given the current
;;; window-start-bp.  If the PLINE is out of the window, then
;;; (if IN-BOUNDS-P, return NIL; else return the PLINE anyway).
;;; POINT can be a BP or just a line.
(DEFUN PLINE-OF-POINT (IN-BOUNDS-P WINDOW POINT &AUX (START-BP (WINDOW-START-BP WINDOW)))
  (DECLARE (VALUES PLINE PLINE-Y))
  (LET (POINT-LINE POINT-INDEX
	(TOP-LINE (BP-LINE START-BP))
	(TOP-INDEX (BP-INDEX START-BP))
	(SHEET (WINDOW-SHEET WINDOW))
	(INTERVAL (WINDOW-INTERVAL WINDOW))
	POINT-PLINE PLINE-Y MAYBE-START-LINE MAYBE-START-INDEX)
    (COND ((LISTP POINT)
	   (SETQ POINT-LINE (BP-LINE POINT)
		 POINT-INDEX (BP-INDEX POINT)))
	  (T (SETQ POINT-LINE POINT POINT-INDEX 0)))
    (COND ((AND ( (WINDOW-REDISPLAY-DEGREE WINDOW) DIS-BPS)
		;; This clause is a short-cut, to avoid SHEET-COMPUTE-MOTION.
		;; No text has changed.  If we can find POINT in the old
		;; state of the window, then that is its current position.
		;; Otherwise: if IN-BOUNDS-P, return NIL, else try slow way.
		(OR
		 (SETQ POINT-PLINE (FIND-BP-IN-WINDOW WINDOW POINT-LINE POINT-INDEX))
		 IN-BOUNDS-P))
	   (VALUES POINT-PLINE
		   (AND POINT-PLINE (PLINE-Y WINDOW POINT-PLINE))))
	  ;; Some text has changed, the existing WINDOW state is useless.
	  ;; Assume we were to redisplay with the same TOP-LINE and TOP-INDEX
	  ;; and figure out where that would put POINT.
	  ((AND (COND (IN-BOUNDS-P
		       (DO ((LINE TOP-LINE (LINE-NEXT-IN-BUFFER LINE :BUFFER INTERVAL))
			    (END-LINE (BP-LINE (INTERVAL-LAST-BP (WINDOW-INTERVAL WINDOW))))
			    ;; This isn't exactly correct, but I think it's good enough.
			    ;; Cannot limit by n-plines, since more lines might fit this
			    ;; time around or the end of the screen might be currently
			    ;; displayed.  Important to limit the search somehow, though.
			    (MAX-N-PLINES (ARRAY-DIMENSION-N 2 WINDOW))
			    (I 0 (1+ I)))
			   (( I MAX-N-PLINES) NIL)
			 (AND (EQ LINE POINT-LINE) (RETURN T))
			 (AND (EQ LINE END-LINE) (RETURN NIL))))
		      (T (SEARCH-FOR-LINE POINT-LINE TOP-LINE)))
		(OR (NEQ POINT-LINE TOP-LINE)
		    ( POINT-INDEX TOP-INDEX)))
	   ;; POINT is past the top-line, top-index position.
	   ;; Compute position as if start of window were start of buffer, asking for
	   ;; end of window if in bounds, else infinity.  The returned line will be
	   ;; the least position it could occupy given that starting point.
	   (MULTIPLE-VALUE (MAYBE-START-LINE MAYBE-START-INDEX POINT-PLINE PLINE-Y)
	     (PUT-POINT-AT-PLINE SHEET POINT-LINE POINT-INDEX
				 (IF IN-BOUNDS-P (TV:SHEET-INSIDE-HEIGHT SHEET) 777777)
				 START-BP NIL :PIXEL))
	   (AND (NOT (AND IN-BOUNDS-P
			  (OR (NEQ MAYBE-START-LINE TOP-LINE)
			      ( MAYBE-START-INDEX TOP-INDEX)
			      ;; Line must fit when displayed there.
			      (> (+ PLINE-Y (POINT-LINE-HEIGHT SHEET POINT-LINE POINT-INDEX))
				 (TV:SHEET-INSIDE-HEIGHT SHEET)))))
		(VALUES POINT-PLINE PLINE-Y)))
	   ;; The POINT-LINE is behind TOP-LINE.
	  (IN-BOUNDS-P NIL)
	  (T
	   ;; It's above the top and we really want to know exactly where.
	   ;; Amazingly, we can just ask to display point infinitely far before
	   ;; the place which is the top, and see where it would manage to appear!
	   (MULTIPLE-VALUE (NIL NIL POINT-PLINE PLINE-Y)
	       (PUT-POINT-AT-PLINE SHEET
				   POINT-LINE POINT-INDEX -777777
				   NIL START-BP :PIXEL))
	   (VALUES POINT-PLINE PLINE-Y)))))

;;; This is an internal function of REDISPLAY, PLINE-OF-POINT, UPDATE-REGION-MARKING.
;;; Search in WINDOW for BP.  BP may be given, or LINE and INDEX.
;;; Assumes that the window's display information is up to date.
(DEFUN FIND-BP-IN-WINDOW (WINDOW BP-LINE &OPTIONAL BP-INDEX)
  (COND ((NULL BP-INDEX)
	 (SETQ BP-INDEX (BP-INDEX BP-LINE) BP-LINE (BP-LINE BP-LINE))))
  (LET ((N-PLINES (WINDOW-N-PLINES WINDOW))
	(HINT (WINDOW-LAST-POINT-PLINE WINDOW)))
    (COND ((AND (< HINT N-PLINES)
		(EQ BP-LINE (PLINE-LINE WINDOW HINT))
		( (PLINE-FROM-INDEX WINDOW HINT) BP-INDEX)
		(< BP-INDEX (PLINE-TO-INDEX WINDOW HINT)))
	   ;; The hint from last time payed off!
	   HINT)
	  ((LINE-DIAGRAM BP-LINE)
	   (LOOP FOR PLINE BELOW N-PLINES
		 WHEN (EQ BP-LINE (PLINE-LINE WINDOW PLINE))
		 RETURN PLINE))
	  (T
	   ;; The hint didn't do it, search for the pline.
	   (DO ((PLINE 0 (1+ PLINE)))
	       (( PLINE N-PLINES)
		NIL)
	     (COND ((AND (EQ BP-LINE (PLINE-LINE WINDOW PLINE))
			 ( (PLINE-FROM-INDEX WINDOW PLINE) BP-INDEX)
			 (< BP-INDEX (PLINE-TO-INDEX WINDOW PLINE)))
		    (RETURN PLINE))))))))

;;; This is an internal function of REDISPLAY.
;;; Figures out where to start redisplay so that POINT ends up on or near POINT-PLINE.
;;; Returns a LINE and an INDEX indicating where to start redisplay, and the
;;; real value of POINT-PLINE.  Usually this third value equals the POINT-PLINE,
;;; but sometimes it will be smaller because you cannot start redisplay before
;;; the beginning of the interval (unlike MagicSix TV, may it rest in peace).
(DEFUN PUT-POINT-AT-PLINE (SHEET POINT-LINE POINT-INDEX POINT-POSITION FIRST-BP LAST-BP UNIT
			   &AUX (INTERVAL (WINDOW-INTERVAL (SEND SHEET :ZWEI-WINDOW))))
  (DECLARE (VALUES START-LINE START-INDEX POINT-PLINE POINT-Y))
  (IF ( POINT-POSITION 0)
      ;; Algorithm: first find LINE, which will be the new TOP-LINE,
      ;; by scanning backwards.  Then knock off plines from the front
      ;; of it until POINT ends up at POINT-PLINE.
      ;; P is the number of plines between POINT and the beginning
      ;; of the current LINE.
      (LET ((P 0) (Y 0)
	    ;; P is the point-pline if we start at the beginning of LINE.
	    (STOP-LINE (BP-LINE FIRST-BP)))
	(LOOP FOR LINE = POINT-LINE THEN (LINE-PREVIOUS-IN-BUFFER LINE :BUFFER INTERVAL)
	      AS LINE-START-INDEX = (IF (EQ LINE STOP-LINE) (BP-INDEX FIRST-BP) 0)
	      AS POINT-LINE-P = T THEN NIL
	      DO
	  (WHEN (NULL LINE)
	    (CL:CERROR 'REDISPLAY-CERROR
		       "Reset point and attempt to continue"
		       "POINT is not in the interval being displayed")
	    (PREPARE-WINDOW-FOR-REDISPLAY (SEND SHEET :ZWEI-WINDOW))
	    (RETURN (VALUES STOP-LINE (BP-INDEX FIRST-BP) -1 0)))
	  (MULTIPLE-VALUE-BIND (DP DY)
	      (LINE-NUMBER-OF-PLINES SHEET LINE LINE-START-INDEX
				     (AND POINT-LINE-P POINT-INDEX)
				     (NOT POINT-LINE-P) POINT-LINE-P)
	    (INCF P DP)
	    (INCF Y DY)
	    (LET ((DIFFERENCE (CL:ECASE UNIT
				(:LINE (- P POINT-POSITION))
				(:PIXEL (- Y POINT-POSITION)))))
	      (WHEN ( DIFFERENCE 0)
		;; We have found the new TOP-LINE.  Now find TOP-INDEX.
		(LET ((TOP-INDEX LINE-START-INDEX))
		  (UNLESS (ZEROP DIFFERENCE)
		    (LET ((NEXT-LINE (LINE-NEXT-IN-BUFFER LINE :BUFFER INTERVAL)))
		      (BLOCK ACCOUNT-FOR-CONTINUATION
			(BLOCK GO-BACK-A-LINE
			  (UNLESS (AND (EQ UNIT :PIXEL) (= DP 1) NEXT-LINE)
			    ;; Compute motion to move P/Y down DIFFERENCE (p)lines.
			    (MULTIPLE-VALUE-BIND (INDEX NLINES HEIGHT)
				(LINE-INDEX-FOR-HEIGHT SHEET DIFFERENCE
						       LINE UNIT
						       LINE-START-INDEX NIL POINT-LINE-P)
			      ;; In pixel mode, things don't round out right.  We want to
			      ;; round down, not up.  This may mean backing up a line if
			      ;; even the first pline of this one goes too far.
			      (WHEN (AND (EQ UNIT :PIXEL) (= NLINES DP) NEXT-LINE)
				(RETURN-FROM GO-BACK-A-LINE))
			      ;; Amount to remove is this part above.
			      (SETQ DP NLINES)
			      (SETQ DY HEIGHT)
			      (SETQ TOP-INDEX (MAX INDEX LINE-START-INDEX))
			      (RETURN-FROM ACCOUNT-FOR-CONTINUATION))))
			;; Don't try to use continuation to make up a line fraction,
			;; just take back the whole line.
			(SETQ LINE NEXT-LINE)))
		    (DECF P DP)
		    (DECF Y DY))
		  (RETURN (VALUES LINE TOP-INDEX P Y))))))
	    (WHEN (EQ LINE STOP-LINE)
	      (RETURN (VALUES LINE LINE-START-INDEX P Y)))))
      ;; POINT-PLINE is negative, do the same thing in reverse.
      (LET ((P 0) (Y 0)
	    ;; P is the point-pline if we display from beg of (LINE-NEXT LINE).
	    ;; This line is the one if P is too far.
	    (STOP-LINE (BP-LINE LAST-BP)))
	(LOOP FOR LINE = POINT-LINE THEN (LINE-NEXT-IN-BUFFER LINE :BUFFER INTERVAL)
	      AS POINT-LINE-P = T THEN NIL
	      DO
	  (WHEN (NULL LINE)
	    (CL:CERROR 'REDISPLAY-CERROR
		       "Reset point and attempt to continue"
		       "POINT is not in the interval being displayed")
	    (PREPARE-WINDOW-FOR-REDISPLAY (SEND SHEET ':ZWEI-WINDOW))
	    (RETURN (VALUES STOP-LINE (BP-INDEX LAST-BP) -1)))
	  (MULTIPLE-VALUE-BIND (DP DY)
	      (LINE-NUMBER-OF-PLINES SHEET LINE
				     (IF POINT-LINE-P POINT-INDEX 0)
				     (AND (EQ LINE STOP-LINE) (BP-INDEX LAST-BP))
				     (NEQ LINE STOP-LINE) POINT-LINE-P)
	    (DECF P DP)
	    (DECF Y DY)
	    (LET ((DIFFERENCE (CL:ECASE UNIT
				(:LINE (- P POINT-POSITION))
				(:PIXEL (- Y POINT-POSITION)))))
	      (WHEN (< DIFFERENCE 0)
		;; We have found the new TOP-LINE.  Now find TOP-INDEX.
		(LET ((TOP-INDEX 0))
		  (UNLESS (OR (= DIFFERENCE (IF (EQ UNIT :LINE) (- DP) (- DY)))
			      (AND (EQ UNIT :PIXEL) (= DP 1)))
		    (MULTIPLE-VALUE-BIND (INDEX NLINES HEIGHT)
			(LINE-INDEX-FOR-HEIGHT
			  SHEET (MULTIPLE-VALUE-BIND (NP NY)
				    (IF POINT-LINE-P
					(LINE-NUMBER-OF-PLINES SHEET LINE)
					(VALUES DP DY))
				  (+ (IF (EQ UNIT :LINE) NP NY)
				     DIFFERENCE))
			  LINE UNIT 0 NIL POINT-LINE-P)
		      ;; Discount amount before
		      (DECF DP NLINES)
		      (DECF DY HEIGHT)
		      (SETQ TOP-INDEX (IF (EQ LINE STOP-LINE)
					  (MIN INDEX (BP-INDEX LAST-BP))
					  INDEX))))
		  (INCF P DP)
		  (INCF Y DY)
		  (RETURN
		    (VALUES LINE TOP-INDEX P Y))))))
	  (WHEN (EQ LINE STOP-LINE)
	    (RETURN (VALUES LINE 0 P Y)))))))

;;; This is an internal function of REDISPLAY.
(DEFUN UPDATE-REGION-MARKING (WINDOW &AUX (SHEET (WINDOW-SHEET WINDOW)))
  (LET ((MARK-P (WINDOW-MARK-P WINDOW))
	(BP1 (WINDOW-POINT WINDOW))
	(BP2 (WINDOW-MARK WINDOW))
	(N-PLINES (WINDOW-N-PLINES WINDOW))
	(LAST-PLINE (1- (WINDOW-N-PLINES WINDOW)))
	PLINE-1 X-1 PLINE-2 X-2)
    (WHEN *REGION-MARKING-MODE*
      (COND ((NOT MARK-P)
	     (REGION-UNMARK-RANGE WINDOW 0 N-PLINES))
	    (T
	     (WHEN (LISTP MARK-P)		;Kludge for UNDO-COMMAND
	       (SETQ BP1 (FIRST MARK-P) BP2 (SECOND MARK-P)))
	     (LET ((LINE-1 (BP-LINE BP1))
		   (INDEX-1 (BP-INDEX BP1))
		   (LINE-2 (BP-LINE BP2))
		   (INDEX-2 (BP-INDEX BP2))
		   (LAST-LINE (PLINE-LINE WINDOW LAST-PLINE))
		   P1 P2)
	       ;; Each BP may be before the window, after the window, or in the window.
	       (SETQ P1 (FIND-BP-IN-WINDOW WINDOW LINE-1 INDEX-1))
	       (SETQ P2 (FIND-BP-IN-WINDOW WINDOW LINE-2 INDEX-2))
	       ;; Hold on to your hats!  Here we effectively do a 9-way dispatch, based
	       ;; on whether each of the two bps is in, before, or after the window.
	       ;; If PLINE-n is left NIL, it and X-n will be set to zero.
	       ;; If PLINE-n is set but X-n isn't, X-n will come from SHEET-COMPUTE-MOTION.
	       (COND ((NULL P1)
		      ;; Line 1 is not on the screen, which way did he go?
		      (COND ((AND LAST-LINE (SEARCH-FOR-LINE LINE-1 LAST-LINE))
			     ;; Line 1 is ahead of the screen, check out Line 2.
			     (COND ((NULL P2)
				    ;; Line 2 isn't on the window either.
				    (COND ((AND LAST-LINE
						(SEARCH-FOR-LINE LINE-2 LAST-LINE))
					   ;; ** They are both ahead, no display.
					   )
					  (T	; ** Line 2 is behind, mark all.
					   (SETQ X-2 (PLINE-TEXT-WIDTH WINDOW LAST-PLINE)
						 PLINE-2 LAST-PLINE))))
				   (T		; ** Line 2 is on, Line 1 is ahead.
				    (SETQ PLINE-1 P2 LINE-1 LINE-2 INDEX-1 INDEX-2
					  PLINE-2 LAST-PLINE
					  X-2 (PLINE-TEXT-WIDTH WINDOW LAST-PLINE)))))
			    (T ;; Line 1 is behind the window, check out Line 2.
			     (COND ((NULL P2)
				    ;; Line 2 isn't on the screen either.
				    (COND ((AND LAST-LINE
						(SEARCH-FOR-LINE LINE-2 LAST-LINE))
					   ;; ** Line 2 is ahead, mark all.
					   ;; ** Otherwise no marking.
					   (SETQ X-2 (PLINE-TEXT-WIDTH WINDOW LAST-PLINE)
						 PLINE-2 LAST-PLINE))))
				   (T		; ** Line 2 is on, Line 1 is behind.
				    (SETQ PLINE-2 P2))))))
		     (T				; Line 1 is on the window, check out Line 2.
		      (COND ((NULL P2)
			     ;; Line 2 is not on the window.
			     (COND ((AND LAST-LINE
					 (SEARCH-FOR-LINE LINE-2 LAST-LINE))
				    ;; ** Line 2 is ahead and Line 1 is on.
				    (SETQ PLINE-1 P1 PLINE-2 LAST-PLINE
					  X-2 (PLINE-TEXT-WIDTH WINDOW LAST-PLINE)))
				   (T		; ** Line 2 is behind, Line 1 is on.
				    (SETQ PLINE-2 P1 LINE-2 LINE-1 INDEX-2 INDEX-1))))
			    (T			; ** Both are on.
			     (COND ((OR (NOT (SEARCH-FOR-LINE LINE-1 LINE-2))
					(AND (EQ LINE-1 LINE-2)
					     (< INDEX-1 INDEX-2)))
				    ;; Line 1 is behind Line 2.
				    (SETQ PLINE-1 P1 PLINE-2 P2))
				   (T
				    (SETQ LINE-1 (PROG1 LINE-2 (SETQ LINE-2 LINE-1)))
				    (SETQ INDEX-1 (PROG1 INDEX-2
							 (SETQ INDEX-2 INDEX-1)))
				    (SETQ PLINE-1 P2 PLINE-2 P1)))))))
	       (COND ((NULL PLINE-1)
		      (SETQ PLINE-1 0 X-1 0))
		     ((NULL X-1)
		      (SETQ X-1
			    (IF (LINE-DIAGRAM LINE-1) 0
				(LINE-DISPLAYED-SIZE SHEET LINE-1
						     (PLINE-FROM-INDEX WINDOW PLINE-1)
						     INDEX-1)))))
	       (COND ((NULL PLINE-2)
		      (SETQ PLINE-2 0 X-2 0))
		     ((NULL X-2)
		      (SETQ X-2
			    (IF (LINE-DIAGRAM LINE-2) 0
				(LINE-DISPLAYED-SIZE SHEET LINE-2
						     (PLINE-FROM-INDEX WINDOW PLINE-2)
						     INDEX-2)))))
	       ;; Now PLINE-1, X-1 and PLINE-2, X-2 are set up.
	       (REGION-UNMARK-RANGE WINDOW 0 PLINE-1)
	       (COND ((EQ PLINE-1 PLINE-2)
		      (REGION-MARK-PLINE WINDOW PLINE-1 X-1 X-2))
		     (T
		      (REGION-MARK-PLINE WINDOW PLINE-1 X-1)
		      (REGION-MARK-RANGE WINDOW (1+ PLINE-1) PLINE-2)
		      (REGION-MARK-PLINE WINDOW PLINE-2 0 X-2)))
	       (REGION-UNMARK-RANGE WINDOW (1+ PLINE-2) N-PLINES)))))))

(DEFUN REGION-UNMARK-RANGE (WINDOW START-PLINE END-PLINE)
  (LOOP FOR PLINE FROM START-PLINE BELOW END-PLINE
	DO (REGION-UNMARK-PLINE WINDOW PLINE)))

(DEFUN REGION-UNMARK-PLINE (WINDOW PLINE)
  (LET ((PML (PLINE-MARKING-LEFT WINDOW PLINE)))
    (WHEN PML
      (REGION-DRAW-MARKING WINDOW PLINE PML (PLINE-MARKING-WIDTH WINDOW PLINE))
      (SETF (PLINE-MARKING-LEFT WINDOW PLINE) NIL))))

(DEFUN REGION-MARK-RANGE (WINDOW START-PLINE END-PLINE)
  (LOOP FOR PLINE FROM START-PLINE BELOW END-PLINE
	DO (REGION-MARK-PLINE WINDOW PLINE)))

;;; This is an internal function of UPDATE-REGION-MARKING.
(DEFUN REGION-MARK-PLINE (WINDOW PLINE &OPTIONAL (NEW-LEFT 0) NEW-RIGHT)
  (WHEN (NULL NEW-RIGHT)
    (SETQ NEW-RIGHT (IF *REGION-RIGHT-MARGIN-MODE*
			(SEND (WINDOW-SHEET WINDOW) :INSIDE-WIDTH)
			(PLINE-TEXT-WIDTH WINDOW PLINE))))
  (LET ((PML (PLINE-MARKING-LEFT WINDOW PLINE))
	(PMW (PLINE-MARKING-WIDTH WINDOW PLINE))
	(NEW-WIDTH (MAX 0 (- NEW-RIGHT NEW-LEFT))))	;A negative number here would lose badly
    (COND ((NOT (AND (EQ PML NEW-LEFT)
		     (EQ PMW NEW-WIDTH)))
	   (WHEN PML
	     (REGION-DRAW-MARKING WINDOW PLINE PML PMW))
	   (REGION-DRAW-MARKING WINDOW PLINE NEW-LEFT NEW-WIDTH)
	   (SETF (PLINE-MARKING-LEFT WINDOW PLINE) NEW-LEFT)
	   (SETF (PLINE-MARKING-WIDTH WINDOW PLINE) NEW-WIDTH)))))

(DEFUN REGION-DRAW-MARKING (WINDOW PLINE LEFT WIDTH)
  (LET (BAR-HEIGHT OFFSET)
    (SELECTQ *REGION-MARKING-MODE*
      (:UNDERLINE
       (SETQ BAR-HEIGHT 1
	     OFFSET (1- (PLINE-HEIGHT WINDOW PLINE))))
      (:REVERSE-VIDEO
       (SETQ BAR-HEIGHT (+ (PLINE-HEIGHT WINDOW PLINE) (WINDOW-VSP WINDOW))
	     ;; Would look a little nicer to have it overlap above and below, but that's
	     ;; incompatible with the clearing that happens when line has changed.  VSP
	     ;; belongs to the line above it always.
	     OFFSET 0 #|| (- (// (WINDOW-VSP WINDOW) 2)) ||#)))
    (SEND (WINDOW-SHEET WINDOW) :DRAW-RECTANGLE WIDTH BAR-HEIGHT
	  LEFT (+ (PLINE-Y WINDOW PLINE) OFFSET) :FLIP)))

(DEFVAR *MORE-ABOVE-MODE-LINE-STRING* "[More above]")
(DEFVAR *MORE-BELOW-MODE-LINE-STRING* "[More below]")
(DEFVAR *MORE-ABOVE-AND-BELOW-MODE-LINE-STRING* "[More above and below]")

(DEFUN REDISPLAY-MODE-LINE ()
  (LET ((*MODE-LINE-MORE-ABOVE-BELOW*
	  (LET ((MORE-ABOVE (NOT (BP-= (INTERVAL-FIRST-BP (WINDOW-INTERVAL *WINDOW*))
				       (WINDOW-START-BP *WINDOW*))))
		(MORE-BELOW (NOT (WINDOW-LAST-BP-DISPLAYED-P *WINDOW*))))
	    (IF MORE-ABOVE
		(IF MORE-BELOW *MORE-ABOVE-AND-BELOW-MODE-LINE-STRING*
			       *MORE-ABOVE-MODE-LINE-STRING*)
		(IF MORE-BELOW *MORE-BELOW-MODE-LINE-STRING*)))))
    (LET-IF (AND (VARIABLE-BOUNDP ZWEI:*ALWAYS-LABEL-ZMACS-WINDOWS*)
		 (EQL *ALWAYS-LABEL-ZMACS-WINDOWS* :VC-BUFFERS-ONLY))
	    ((*ALWAYS-LABEL-ZMACS-WINDOWS*
	       (TYPEP (WINDOW-INTERVAL *WINDOW*) 'VC-FILE-BUFFER)))
      (SEND *MODE-LINE-WINDOW* ':REDISPLAY *MODE-LINE-LIST*))))

;Set the size of BLINKER to be appropriate to the char BP points at,
;assuming the font map of WINDOW;  then position it on the character
;which is assumed to be located at X Y.  Where the char is really located
;on the screen depends on the baseline of the font.
(DEFUN SET-BLINKER-SIZE (BP WINDOW BLINKER X Y BASELINE SHEET)
  (IGNORE WINDOW)
  (MULTIPLE-VALUE-BIND (CHAR-WIDTH CHAR-HEIGHT CHAR-BASELINE)
      (LET* ((LINE (BP-LINE BP))
	     (DIAGRAM (LINE-SPECIAL-REDISPLAY-PROPERTIES (BP-LINE BP)))
	     (CHAR (BP-CHAR BP)) CHAR2)
	(IF T #||(CHARACTERP CHAR)||#
	    (LET ((FONT (COND ((CHAR-NOT-EQUAL CHAR #\CR)
			       (TV:SHEET-GET-CHAR-FONT CHAR NIL SHEET))
			      ((CHAR-NOT-EQUAL (SETQ CHAR2 (BP-CHAR-BEFORE BP)) #\CR)
			       (TV:SHEET-GET-CHAR-FONT CHAR2 NIL SHEET)))))
	      (COND (DIAGRAM
		     (SETQ CHAR #\SP))
		    ((CHAR-EQUAL CHAR #\CR)
		     ;; At end of line, make blinker the width of a space.
		     (SETQ CHAR #\SP))
		    ((AND (CHAR-EQUAL CHAR #\TAB) *TAB-BLINKER-FLAG*)
		     ;; Some people find blinkers over tabs annoying.
		     (SETQ CHAR #\SP)))
	      (VALUES (MAX 1
			   (ABS (IF (CHAR-EQUAL CHAR #\TAB)
				    (- (LET ((INDEX (BP-INDEX BP)))
					 (LINE-DISPLAYED-SIZE SHEET LINE INDEX (1+ INDEX)
							      X))
				       X)
				    (SEND SHEET :CHARACTER-WIDTH CHAR FONT))))
		      (IF DIAGRAM
			  (SEND DIAGRAM :EDITOR-HEIGHT SHEET LINE)
			  (IF FONT
			      (FONT-RASTER-HEIGHT FONT)
			      (TV:SHEET-LOZENGE-BASELINE SHEET)))
		      (AND (NULL DIAGRAM) FONT (FONT-BASELINE FONT))))
	    (TV:OBESE-CHARACTER-SIZE CHAR SHEET X)))
    ;; Set the blinker position, adjusting for the difference between
    ;; this font's baseline and other fonts' baselines.
    (INCF Y (- BASELINE (OR CHAR-BASELINE CHAR-HEIGHT)))
    (TV:BLINKER-SET-CURSORPOS BLINKER X Y)		;Assure blinker overlaps char
    (TV:BLINKER-SET-SIZE BLINKER CHAR-WIDTH CHAR-HEIGHT)))

;; Return position at which BP occurs in WINDOW relative to its SHEET
;; or NIL NIL if BP is not on the screen.
;; Assumes that the window's display information is up to date.
(DEFUN FIND-BP-IN-WINDOW-COORDS (BP WINDOW)
  (DECLARE (VALUES X Y BASELINE))
  (LET ((PLINE (FIND-BP-IN-WINDOW WINDOW BP)))
    (COND ((NULL PLINE) NIL)
	  (T
	   (LET ((SHEET (WINDOW-SHEET WINDOW)))
	     (IF (LINE-DIAGRAM (BP-LINE BP))
		 (VALUES 0 (PLINE-Y WINDOW PLINE) (PLINE-BASELINE WINDOW PLINE))
		 (VALUES (LINE-DISPLAYED-SIZE SHEET (BP-LINE BP)
					      (PLINE-FROM-INDEX WINDOW PLINE) (BP-INDEX BP))
			 (PLINE-Y WINDOW PLINE) (PLINE-BASELINE WINDOW PLINE))))))))

;; Cause the matching paren to flash, WINDOW-START-BP is the beginning of the
;; window, and gets passed as a magic argument to FORWARD-SEXP to tell it not to
;; try to go past that.  The message to the major mode returns a line, start,
;; and end, from which is extracted a string
(DEFUN BLINK-MATCHING-THING (BLINKER WINDOW POINT WINDOW-START-BP WINDOW-END-BP)
  (BLOCK TURN-ON
    (WHEN (AND *FLASH-MATCHING-PAREN*
	       (EQ (TV:BLINKER-VISIBILITY (WINDOW-POINT-BLINKER WINDOW)) ':BLINK))
      (MULTIPLE-VALUE-BIND (BP SIZE)
	  (SEND (SEND (WINDOW-INTERVAL WINDOW) :MAJOR-MODE)
		:MATCHING-INTERVAL-TO-BLINK POINT WINDOW-START-BP WINDOW-END-BP)
	(WHEN BP
	  (MULTIPLE-VALUE-BIND (X Y BASELINE)
	      (FIND-BP-IN-WINDOW-COORDS BP WINDOW)
	    (WHEN (AND X Y)
	      (WITHOUT-INTERRUPTS
		(SEND BLINKER :SET-BASELINE BASELINE)
		(LET ((INDEX (BP-INDEX BP)))
		  (SEND BLINKER :SET-STRING (BP-LINE BP) INDEX (+ INDEX SIZE)))
		(TV:BLINKER-SET-CURSORPOS BLINKER X Y)
		(TV:BLINKER-SET-VISIBILITY BLINKER :BLINK))
	      (RETURN-FROM TURN-ON T))))))
    (TV:BLINKER-SET-VISIBILITY BLINKER NIL)))

;;; Cause the matching paren to flash, WINDOW-START-BP is the beginning
;;; of the window, and gets passed as a magic argument to FORWARD-SEXP
;;; to tell it not to try to go past that.
;(DEFUN BLINK-MATCHING-PAREN (BLINKER WINDOW POINT WINDOW-START-BP &AUX BP X Y)
;  (COND ((AND *FLASH-MATCHING-PAREN*
;	      (EQ (TV:BLINKER-VISIBILITY (WINDOW-POINT-BLINKER WINDOW)) ':BLINK)
;	      (SETQ BP (SEND (OR (SEND (WINDOW-INTERVAL WINDOW) ':SEND-IF-HANDLES
;				       ':GET ':MAJOR-MODE)
;				 *MAJOR-MODE*)
;			     ':MATCHING-CHAR-TO-BLINK POINT
;			     (BP-MAX
;			       (NODE-FIRST-BP (BP-TOP-LEVEL-NODE POINT))
;			       WINDOW-START-BP)))
;	      (PROGN (MULTIPLE-VALUE (X Y) (FIND-BP-IN-WINDOW-COORDS BP WINDOW)) X))
;	 (LET ((SHEET (WINDOW-SHEET WINDOW))
;	       (CHAR (BP-CHAR BP)))
;	   (MULTIPLE-VALUE-BIND (INDEX FONT)
;	       (TV:SHEET-GET-CHAR-INDEX-AND-FONT CHAR NIL SHEET)
;	     (LET ((LKT (FONT-LEFT-KERN-TABLE FONT)))
;	       (AND LKT (SETQ X (- X (AREF LKT INDEX)))))
;	     (SETQ Y (+ Y (TV:SHEET-GET-TOP-OF-FONT FONT SHEET))))
;	   (WITHOUT-INTERRUPTS
;	     (TV:BLINKER-SET-CHARACTER BLINKER CHAR)
;	     (TV:BLINKER-SET-CURSORPOS BLINKER X Y)
;	     (TV:BLINKER-SET-VISIBILITY BLINKER ':BLINK))))
;	(T (TV:BLINKER-SET-VISIBILITY BLINKER NIL)))) 

;; Returns the width (in pixels) of the given substring of STRING
;; when displayed on SHEET.  FROM and TO default to the beginning and
;; ending of the string.
(DEFUN STRING-WIDTH (STRING &OPTIONAL (FROM 0)
				      (TO (STRING-LENGTH STRING))
				      (SHEET (WINDOW-SHEET *WINDOW*)))
  (FUNCALL SHEET ':STRING-LENGTH STRING FROM TO))

;;; How many plines does this line need?
(DEFUN LINE-NUMBER-OF-PLINES (SHEET LINE &OPTIONAL (START-INDEX 0) END-INDEX
						   (CR-AT-END T) CONTINUATION-AFTER)
  (DECLARE (VALUES NLINES TOTAL-HEIGHT FINAL-X))
  (LET ((LINE-LENGTH (LINE-LENGTH LINE)))
    (IF (NULL END-INDEX)
	(SETQ END-INDEX LINE-LENGTH)
	(WHEN CONTINUATION-AFTER
	  ;; Account for continuation afterwards.
	  (SETQ END-INDEX (MIN (1+ END-INDEX) LINE-LENGTH)))))
  (LET ((VSP (SEND SHEET :VSP))
	(TOTAL-HEIGHT 0)
	(NLINES 0)
	FINAL-X)
    (LOOP WITH INDEX = START-INDEX
	  WITH HEIGHT
	  DO (MULTIPLE-VALUE (FINAL-X HEIGHT NIL INDEX)
	       (LINE-DISPLAYED-SIZE SHEET LINE INDEX END-INDEX))
	  WHEN (AND (= INDEX END-INDEX) (NOT CR-AT-END))
	    RETURN NIL
	  DO (INCF NLINES)
	     (INCF TOTAL-HEIGHT (+ HEIGHT VSP))
	  WHEN (= INDEX END-INDEX)
	    RETURN NIL)
    (VALUES NLINES TOTAL-HEIGHT FINAL-X)))

;;; How far do you need to go down this line to account for this number of continuations?
(DEFUN LINE-INDEX-FOR-HEIGHT (SHEET HEIGHT LINE UNIT &OPTIONAL (START-INDEX 0) END-INDEX
							       CONTINUATION-AFTER)
  (DECLARE (VALUES INDEX NLINES REAL-HEIGHT))
  (UNLESS END-INDEX
    (SETQ END-INDEX (LINE-LENGTH LINE)))
  (LET ((VSP (SEND SHEET :VSP))
	(INDEX START-INDEX)
	(NLINES 0) (TOTAL 0)
	DELTA)
    (LOOP DO
      (MULTIPLE-VALUE (NIL DELTA NIL INDEX)
	(LINE-DISPLAYED-SIZE SHEET LINE INDEX END-INDEX))
      (INCF DELTA VSP)
      (INCF NLINES)
      (INCF TOTAL DELTA)
      (WHEN ( (IF (EQ UNIT :LINE) NLINES TOTAL) HEIGHT)
	;; Compensate for continuation caused by following characters only.
	(WHEN (AND CONTINUATION-AFTER (= INDEX END-INDEX))
	  (DECF TOTAL DELTA)
	  (DECF NLINES))
	(RETURN (VALUES INDEX NLINES TOTAL))))))

D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");;; What is the height of the (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")pline1 that includes this position?
0(DEFUN POINT-LINE-HEIGHT (SHEET LINE &OPTIONAL INDEX)
  (WHEN (NULL INDEX)
    (SETQ INDEX (BP-INDEX LINE)
	  LINE  (BP-LINE LINE)))
  (MULTIPLE-VALUE-BIND (DIAGRAM LINE-MARGIN TAB-FUNCTION CHARACTER-STYLE-FUNCTION)
      (LINE-SPECIAL-REDISPLAY-PROPERTIES LINE)
    (COND (DIAGRAM
	   1;; A diagram -- just use its height directly.
0	   (SEND DIAGRAM :EDITOR-HEIGHT SHEET LINE))
	  ((AND (= (SYS:ARRAY-TYPE-FIELD LINE) SYS:ART-STRING)
		(NULL LINE-MARGIN)
		(NULL TAB-FUNCTION)
		(NULL CHARACTER-STYLE-FUNCTION))
	   1;; Simple thin string -- All 2pline1s will be the height of the window.
0	   (TV:SHEET-LINE-HEIGHT SHEET))
	  (T
	   ;; 1Fat string, margins, or non-standard tabs --
0	   ;; 1   Find out which continuation line contains the position and use its height.
0	   (LET ((END-INDEX (LINE-LENGTH LINE))
		 (START-INDEX 0))
	     (WITH-CHARACTER-STYLE-FROM-FUNCTION (CHARACTER-STYLE-FUNCTION LINE SHEET)
	       (LOOP DOING
		 (MULTIPLE-VALUE-BIND (NIL HEIGHT NIL LINE-INDEX)
		     (LINE-DISPLAYED-SIZE SHEET LINE START-INDEX END-INDEX)
		   (WHEN (OR (> LINE-INDEX INDEX)
			     ( LINE-INDEX END-INDEX))	1;Only happens when point at EOL.
0		     (RETURN (+ HEIGHT (SEND SHEET :VSP))))
		   (SETQ START-INDEX LINE-INDEX)))))))))

(DEFUN DISPLAY-CONTINUATION-MARKER (SHEET Y HEIGHT)
  (SEND SHEET :DRAW-RECTANGLE 2 HEIGHT (- (TV:SHEET-INSIDE-WIDTH SHEET) 2) Y))

;;; Put the given bp on the given pline.  NOT-IF-DISPLAYED-P means don't do anything if it
;;; is already on the screen.  This is useful when given something off the point pdl e.g.
;;; If putting the given bp on the given pline would leave Point off-screen,
;;; Point stays where it is and the given bp will be on some other pline, or off-screen.
(DEFUN REDISPLAY-POINT-ON-PLINE (BP WINDOW PLINE &OPTIONAL (NOT-IF-DISPLAYED-P T)
							   (RECENTER-TYPE :START-IF-POSSIBLE))
  (OR (AND (FIND-BP-IN-WINDOW WINDOW BP) NOT-IF-DISPLAYED-P)
      (MULTIPLE-VALUE-BIND (LINE INDEX)
	  (PUT-POINT-AT-PLINE (WINDOW-SHEET WINDOW) (BP-LINE BP) (BP-INDEX BP) PLINE
			      (INTERVAL-FIRST-BP (WINDOW-INTERVAL WINDOW))
			      (INTERVAL-LAST-BP (WINDOW-INTERVAL WINDOW))
			      :LINE)
	(RECENTER-WINDOW WINDOW RECENTER-TYPE LINE INDEX))))


(DEFUN BACK-INDEX-OVER-OVERLAPPING-CHARACTER-KERNING (LINE INDEX SHEET)
  ;; If the character is wider than it claims to be, draw an extra
  ;; character, since the clear-rest-of-line will erase part of a character.
  (LET ((KERN-CHECK-INDEX INDEX)
	(LEFT-KERN-X-ADJUSTMENT 0)
	(LEFT-KERN-INDEX-ADJUSTMENT NIL))
    (LOOP DOING
      (WHEN (ZEROP KERN-CHECK-INDEX)
	(RETURN))
      (DECF KERN-CHECK-INDEX)
      (LET* ((CH (AREF LINE KERN-CHECK-INDEX))
	     (CODE (CHAR-CODE CH)))
	(WHEN (AND ( CODE #o200) (< CODE #o300))
	  (RETURN))
	(MULTIPLE-VALUE-BIND (CH-INDEX CH-FONT)
	    (TV:SHEET-GET-CHAR-INDEX-AND-FONT CH NIL SHEET)
	  (UNLESS (AND CH-INDEX CH-FONT)
	    (RETURN))
	  (LET ((CWT (FONT-CHAR-WIDTH-TABLE CH-FONT))
		(LKT (FONT-LEFT-KERN-TABLE CH-FONT)))
	    (UNLESS (AND ( CODE #o301)
			 (NULL CWT) (NULL LKT)
			 ;; Non spacing diacritics within a fixed width font specially treated.
			 (OR ( CODE #o310) ( #o312 CODE #o317))
			 (< CODE (FLOOR (DECODE-RASTER-ARRAY CH-FONT)
					(FONT-RASTER-WIDTH CH-FONT))))
	      (UNLESS CWT
		(RETURN))
	      (WHEN (> CH-INDEX (ARRAY-ACTIVE-LENGTH CWT))
		(RETURN))
	      (LET ((CWID (AREF CWT CH-INDEX))
		    (RWID (FED:FONT-CHAR-MIN-RASTER-WIDTH CH-FONT CH-INDEX)))
		(WHEN LKT
		  (LET ((KERN (AREF LKT CH-INDEX)))
		    ;;Kern can shift raster to the right
		    (WHEN (MINUSP KERN)
		      (DECF RWID KERN))))
		(UNLESS (> RWID CWID)
		  (RETURN))
		(INCF LEFT-KERN-X-ADJUSTMENT CWID))))))
      (SETQ LEFT-KERN-INDEX-ADJUSTMENT (- INDEX KERN-CHECK-INDEX)))
    (VALUES LEFT-KERN-INDEX-ADJUSTMENT LEFT-KERN-X-ADJUSTMENT)))

;;; Things dealing with windows
;;; This takes a window, and creates a new window on top of it in the default font.
(DEFVAR *OVERLYING-WINDOW-LIST* NIL)		;This buys a little speed

(DEFUN CREATE-OVERLYING-WINDOW (WINDOW &AUX (SHEET (WINDOW-SHEET WINDOW)) NEW-WINDOW)
  (IF (SETQ NEW-WINDOW (CDR (ASSQ WINDOW *OVERLYING-WINDOW-LIST*)))
      (LEXPR-FUNCALL (WINDOW-SHEET NEW-WINDOW) ':SET-EDGES
		     (MULTIPLE-VALUE-LIST (FUNCALL SHEET ':EDGES)))
      (SETQ NEW-WINDOW (CREATE-WINDOW (TYPEP SHEET)
				      ':EDGES-FROM SHEET
				      ':SAVE-BITS NIL
				      ':IO-BUFFER (FUNCALL SHEET ':IO-BUFFER)
				      ':SUPERIOR (TV:SHEET-SUPERIOR SHEET)))
      (PUSH (CONS WINDOW NEW-WINDOW) *OVERLYING-WINDOW-LIST*))
  NEW-WINDOW)

(DEFUN CREATE-WINDOW (SHEET &REST OPTIONS &AUX NEW-SHEET-P)
  (WHEN (SYMBOLP SHEET)
    (SETQ SHEET (LEXPR-FUNCALL #'TV:MAKE-WINDOW (OR SHEET 'ZWEI-WINDOW)
			       ':ZWEI-WINDOW NIL
			       OPTIONS)
	  NEW-SHEET-P T))
  (LET ((GUESS-SIZE (// (TV:SHEET-INSIDE-HEIGHT SHEET) (TV:SHEET-LINE-HEIGHT SHEET)))
	(STRING-BLINKER (TV:MAKE-BLINKER SHEET 'TV:STRING-BLINKER
					 ':VISIBILITY NIL ':HALF-PERIOD 8
					 ':DESELECTED-VISIBILITY ':OFF
					 ':STRING "(")))
    (LET ((WINDOW (MAKE-WINDOW :MAKE-ARRAY (:DIMENSIONS `(,*NUMBER-OF-PLINE-PARAMETERS*
							  ,GUESS-SIZE))
			       N-PLINES 0
			       REDISPLAY-DEGREE DIS-ALL
			       LAST-POINT-PLINE 0
			       SHEET SHEET
			       POINT-BLINKER (CAR (LAST (TV:SHEET-BLINKER-LIST SHEET)))
			       SPECIAL-BLINKER-LIST `((BLINK-MATCHING-THING
							. ,STRING-BLINKER))
			       BUFFER-HISTORY (COPYLIST *ZMACS-BUFFER-HISTORY*
							*ZMACS-BUFFER-AREA*))))
      (WHEN NEW-SHEET-P
	(SET-IN-INSTANCE SHEET 'ZWEI-WINDOW WINDOW))
      WINDOW)))
