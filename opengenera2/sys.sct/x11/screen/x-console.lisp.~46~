;;; -*- Base: 10; Package: X-SCREEN; Mode: LISP; Syntax: Common-lisp; Lowercase: T -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; From an original prototype by Bob Scheifler.  

;;; Principal contributers:  Charles Hornig of Symbolics, Chris Lindblad of
;;; ILA, and Bill York of ILA

(defflavor x-console
	(host (protocol nil) (display-number 0) (screen-number 0) (id 0) (reuse-old-screen-p t)
	 (display-device nil)
	 (window-name nil) (icon-name nil)
	 (icon-x nil) (icon-y nil) (icon-width nil) (icon-height nil)
	 (icon-raster nil)  (icon-mask-raster nil) (client-machine nil)
	 (window-group nil) (window-gravity nil) 
	 (window-x nil) (window-y nil)
	 (window-width nil) (window-height nil) 
	 (window-min-width nil) (window-min-height nil)
	 (window-max-width nil) (window-max-height nil)
	 (window-width-inc nil) (window-height-inc nil)
	 (window-min-aspect nil) (window-max-aspect nil)
	 (user-specified-size-p nil) (user-specified-position-p nil)
	 (foreground nil) (background nil) (border nil)
	 (resource-name nil) (resource-class nil)
	 (remote-program nil) (activity nil)
	 (function-keys-enabled t) (select-keys-enabled t)
	 (system-menu-enabled t) (restartable nil)
	 (run-lights-positioner #'ignore) (run-lights-remover #'ignore)

	 who-line-p (default-who-line-p nil)
	 compatible-color-p (default-compatible-color-p nil)
	 (icon-geometry nil) (default-icon-geometry nil)
	 (window-geometry nil) (default-window-geometry nil)
	 (window-depth nil) (default-window-depth most-positive-fixnum)
	 (border-width nil) (default-border-width 0)
	 (initial-state nil) (default-initial-state :normal)
	 (foreground-color nil) (default-foreground-color "black")
	 (background-color nil) (default-background-color "white")
	 (border-color nil) (default-border-color "black")
	 (cursor-foreground-color nil) (default-cursor-foreground-color nil)
	 (cursor-background-color nil) (default-cursor-background-color nil) 

	 (display nil) screen visual-info colormap root window resource-database
	 (window-visibility :fully-obscured)
	 blank-cursor (icon-pixmap nil) (icon-mask nil)
	 (icon-window nil) icon-window-width icon-window-height
	 icon-color-s icon-color-c icon-color-t
	 (asynchronous-errors nil) (input-process nil)
	 (keycode-offset 7)
	 (have-focus-p nil) (have-pointer-p nil)
	 (command nil) (pending-warp-pointer nil)
	 (kill-history nil)
	 (pixmap-validity-table (make-hash-table :test #'eql :ignore-gc t))
	 (last-server-event-time 0)
	 (last-local-event-time 0))
	(tv:basic-remote-console)
  (:initable-instance-variables
   host protocol display-number screen-number reuse-old-screen-p
   who-line-p compatible-color-p
   window-name icon-name icon-raster icon-geometry
   client-machine
   window-geometry window-group window-gravity window-depth
   window-width window-height window-depth
   window-min-width window-min-height
   window-max-width window-max-height
   window-width-inc window-height-inc
   window-min-aspect window-max-aspect
   user-specified-size-p user-specified-position-p
   border-width initial-state 
   foreground-color background-color border-color
   cursor-foreground-color cursor-background-color
   resource-name resource-class
   remote-program activity
   default-who-line-p default-compatible-color-p default-icon-geometry default-window-geometry
   default-border-width default-initial-state default-foreground-color
   default-background-color default-border-color default-cursor-foreground-color
   default-cursor-background-color 
   function-keys-enabled select-keys-enabled system-menu-enabled
   restartable run-lights-positioner run-lights-remover
   )
  :readable-instance-variables
  (:writable-instance-variables restartable))

(defflavor restart-x-console (console) (condition)
  :initable-instance-variables
  :readable-instance-variables
  (:required-init-keywords :console))

(defmethod (dbg:report restart-x-console) (stream)
  (format stream "Restart ~A" console))

(compile-flavor-methods restart-x-console)

(defmethod (with-x-console-restart-internal x-console) (function &optional abort-action)
  (declare (sys:downward-funarg function))
  (unwind-protect-case ()
      (block with-x-console-restart
	(tagbody
	  normal
	     (condition-bind-if (and restartable reuse-old-screen-p)
				((restart-x-console
				   #'(lambda (cond)
				       (when (eq self (restart-x-console-console cond))
					 (go restart)))))
	       (catch-error-restart (error "Kill ~A" self)
		 (catch-error-restart (error "Shutdown ~A" self)
		   (catch-error-restart-if (and restartable reuse-old-screen-p)
					   (error "Restart ~A" self)
		     (return-from with-x-console-restart
		       (funcall function)))
		   (go restart))
		 (go shutdown))
	       (go kill))
	  kill
	     (return-from with-x-console-restart
	       (process:process-run-function
		 `(:name ,(format nil "Kill ~A" self)
		   :priority ,(process:make-process-priority :fg 5 :preemptive t)
		   :system-process t
		   :flags (:no-background-interactor ,(cli::console-master-p self)))
		 #'x-console-shutdown self :kill t))
	  shutdown
	     (return-from with-x-console-restart
	       (process:process-run-function
		 `(:name ,(format nil "Shutdown ~A" self)
		   :priority ,(process:make-process-priority :fg 5 :preemptive t)
		   :system-process t
		   :flags (:no-background-interactor ,(cli::console-master-p self)))
		 #'x-console-shutdown self))
	  restart
	     (return-from with-x-console-restart
	       (process:process-run-function
		 `(:name ,(format nil "Restart ~A" self)
		   :priority ,(process:make-process-priority :fg 5 :preemptive t)
		   :system-process t
		   :flags (:no-background-interactor ,(cli::console-master-p self)))
		 #'x-console-restart self))))
    (:abort
      (case abort-action
	(:shutdown (x-console-shutdown self :abort t))
	(:kill (x-console-shutdown self :abort t :kill t))))))

(defmacro with-x-console-restart ((console &optional abort-action) &body body)
  `(with-x-console-restart-internal
     ,console
     #'(lambda () ,@body)
     ,@(and abort-action `(,abort-action))))

(defmethod (x-console-restart x-console) ()
  (unless (and restartable reuse-old-screen-p)
    (cerror "Restart ~A anyway." "~A isn't restartable" self))
  (x-console-shutdown self)
  (with-x-console-restart (self :shutdown)
    (sys:console-initialize self)))

(defwhopper (cli::keyboard-process-top-level x-console) ()
  (with-x-console-restart (self)
    (continue-whopper)))

(defmethod (x-console-name x-console) (&optional title)
  (format nil "~:[~;Main ~]~@[X ~A ~]~A:~D.~D ~D~@[ (~A)~]"
	  (and title (cli::console-master-p self)) title
	  host display-number screen-number id window-name))

(defmethod (sys:print-self x-console) (stream print-depth slashify-p)
  (declare (ignore print-depth))
  (if slashify-p
      (sys:printing-random-object (self stream :typep)
	(write-string (x-console-name self) stream))
    (format stream "~A ~A" (type-of self) (x-console-name self))))

(defmethod (sys:console-create-mouse x-console) ()
  (make-instance (if (cli::console-master-p self) 'x-primary-mouse 'x-secondary-mouse)
		 :console self))

(defmethod (sys:console-video-address x-console) ()
  (values window window-width window-height window-depth 0 0 0 0))

(defmethod (sys:console-who-line-template x-console) ()
  (and who-line-p
       (tv:default-construct-who-line-template display-device)))

(defmethod (sys:console-screen-acceptable-p x-console) (screen)
  (and (if compatible-color-p
	   (typep screen 'x-colorcompat-real-screen)
	   (or (null (flavor:find-flavor 'x-colorcompat-real-screen nil))
	       (not (typep screen 'x-colorcompat-real-screen))))
       (let ((activity (and activity (cli::lookup-activity activity :error-p nil)))
	     (screen-activities
	       (loop for inferior in (tv:sheet-inferiors screen)
		     for activities =
			 (and (eq (tv:sheet-screen inferior) screen)
			      (loop for activity being the hash-elements of
					cli::*activity-table*
				    when (cli::activity-frame-acceptable-p activity inferior)
				      collect activity))
		     when activities
		       collect activities))
	     (screen-has-initial-lisp-listener
	       (and tv:initial-lisp-listener
		    (eq (tv:sheet-screen tv:initial-lisp-listener) screen))))
	 (cond (activity
		(and (null screen-has-initial-lisp-listener)
		     (= (length screen-activities) 1)
		     (member activity (first screen-activities))))
	       ((cli::console-master-p self)
		screen-has-initial-lisp-listener)
	       (t
		(and (null screen-has-initial-lisp-listener)
		     (loop with lisp-activity = (cli::lookup-activity "Lisp")
			   for frame-activities in screen-activities
			   thereis (member lisp-activity frame-activities))))))))

(defmethod (sys:console-screen-create x-console) (who-line-p &rest make-window-args)
  (apply #'tv:make-window
	 (if who-line-p
	     (if compatible-color-p 'x-colorcompat-who-line-screen 'x-who-line-screen)
	     (if compatible-color-p 'x-colorcompat-real-screen 'x-real-screen))
	 :console self :superior nil :display-device-type display-device
	 make-window-args))

(defparameter
  *keys-to-assign*
  '(#\Space #\! #\" #\# #\$ #\% #\& #\' #\( #\) #\* #\+ #\, #\- #\. #\/ #\0 #\1 #\2
    #\3 #\4 #\5 #\6 #\7 #\8 #\9 #\: #\; #\< #\= #\> #\? #\@ #\A #\B #\C #\D #\E #\F
    #\G #\H #\I #\J #\K #\L #\M #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z
    #\[ #\\ #\] #\^ #\_ #\` #\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m #\n
    #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z #\{ #\| #\} #\~ #\‡
    #\Suspend #\Clear-Input #\Function #\Help #\Rubout #\Back-Space #\Tab #\Line
    #\Refresh #\Page #\Return #\Abort #\Resume #\End #\Square #\Circle
    #\Triangle #\Scroll #\Select #\Network #\Escape #\Complete
    :left-symbol :left-hyper :left-super :left-meta :left-control
    :left-shift :right-shift :right-control :right-meta :right-super :right-hyper
    :right-symbol :mode-lock :caps-lock
    #\ #\ #\ #\‡ #\Symbol-Help #\ #\ #\Œ #\ #\ #\ #\‰ #\ #\ #\ˆ #\  #\ #\
    #\ #\ #\ #\ #\ #\ #\ #\ #\ #\ #\ #\ #\Š #\ #\ #\))

(defparameter
  *symbol-keys*
  '((#\B #\) (#\. #\) (#\, #\) (#\/ #\‡) (#\Help #\Symbol-Help) (#\h #\) (#\k #\)
    (#\: #\Œ) (#\A #\) (#\D #\) (#\g #\) (#\G #\‰) (#\j #\) (#\l #\) (#\L #\ˆ)
    (#\' #\ ) (#\w #\) (#\r #\) (#\y #\) (#\i #\) (#\p #\) (#\P #\) (#\q #\)
    (#\e #\) (#\E #\) (#\t #\) (#\u #\) (#\o #\) (#\* #\) (#\= #\) (#\+ #\Š)
    (#\- #\) (#\` #\) (#\Escape #\)))

(defsubst-in-flavor (keycode->keynum x-console) (code)
  (- code keycode-offset))

(defsubst-in-flavor (keynum->keycode x-console) (keynum)
  (+ keynum keycode-offset))

(defun-in-flavor (clear-keyboard-table x-console) (table)
  (loop with null-mapping = (sys:standardize-keyboard-mapping nil t)
	with rows = (array-dimension table 0)
	with cols = (array-dimension table 1)
	for row below rows
	do (loop for col below cols
		 do (setf (aref table row col) null-mapping))))

(defun-in-flavor (fill-keyboard-table-general x-console) (table layout-type)
  (declare (ignore layout-type))
  (loop with nxshifts = (array-dimension (xlib::display-keyboard-mapping display) 1)
	with nlshifts = (array-dimension table 0)
	with null-mapping = (sys:standardize-keyboard-mapping nil t)
	for code from (xlib:display-min-keycode display)
		 to (xlib:display-max-keycode display)
	do (loop for shift below (min nxshifts nlshifts)
		 for key = (xlib:keycode->character display code shift)
		 when (and key
			   (or (characterp key)
			       (find key sys:*kbd-mapping-bit-names*)
			       (find key sys:*kbd-mapping-mouse-button-names*))
			   (= (aref table shift (keycode->keynum code)) null-mapping))
		   do (setf (aref table shift (keycode->keynum code))
			    (sys:standardize-keyboard-mapping key t)))))

(defparameter
  *modifier-mapping-alist*
  '((:shift :left-shift :right-shift)
    (:lock :caps-lock)
    (:control :left-control :right-control)
    (:meta :left-meta :right-meta)
    (:super :left-super :right-super)
    (:hyper :left-hyper :right-hyper)
    (:symbol :left-symbol :right-symbol)
    (:function :mode-lock #\Abort #\Select #\Function #\Network #\Suspend #\Resume #\Help)))

(defun-in-flavor (fill-keyboard-table-specific x-console) (table layout-type)
  (loop with nxshifts = (array-dimension (xlib::display-keyboard-mapping display) 1)
	with nlshifts = (array-dimension table 0)
	with null-mapping = (sys:standardize-keyboard-mapping nil t)
	with keyboard-mapping =
	  (keyboard-mapping-keys 
	    (or (layout-type-keyboard-mapping layout-type)
		(layout-type-keyboard-mapping :default)))
	for code from (xlib:display-min-keycode display)
		 to (xlib:display-max-keycode display)
	for code-keys = (cdr (assoc (keycode->keynum code) keyboard-mapping))
	do (when code-keys
	     ;; key code specific key mappings have the highest priority
	     (loop for lshift below nlshifts
		   for key = (or (nth lshift code-keys) (first code-keys))
		   when (and key
			     (= (aref table lshift (keycode->keynum code))
				null-mapping))
		     do (setf (aref table lshift (keycode->keynum code))
			      (sys:standardize-keyboard-mapping key t))))
	   ;; Next comes shift specific key mappings 
	   (loop with unshifted-keysym = (xlib:keycode->keysym display code 0)
		 for xshift below nxshifts
		 for lshift below nlshifts
		 when (= (aref table lshift (keycode->keynum code)) null-mapping)
		   do (loop with shifted-keysym = (xlib:keycode->keysym display code xshift)
			    with shifted-keysym-names =
			      (gethash shifted-keysym *keysym-name-table*)
			    for shifted-keysym-name in shifted-keysym-names
			    for shifted-key =
				(cadr (assoc shifted-keysym-name keyboard-mapping))
			    when (and shifted-key
				      (not (= unshifted-keysym shifted-keysym))
				      (= (aref table lshift (keycode->keynum code))
					 null-mapping))
			      do (setf (aref table lshift (keycode->keynum code))
				       (sys:standardize-keyboard-mapping shifted-key t))
			      and return))
	   ;; finally mappings based on the unshifted keysym
	   (loop with unshifted-keysym = (xlib:keycode->keysym display code 0)
		 with unshifted-keysym-names = (gethash unshifted-keysym *keysym-name-table*)
		 for lshift below nlshifts
		 do (loop for unshifted-keysym-name in unshifted-keysym-names
			  for unshifted-keys =
			      (cdr (assoc unshifted-keysym-name keyboard-mapping))
			  for key = (or (nth lshift unshifted-keys) (first unshifted-keys))
			  when (and key
				    (= (aref table lshift (keycode->keynum code))
				       null-mapping))
			    do (setf (aref table lshift (keycode->keynum code))
				     (sys:standardize-keyboard-mapping key t))))))

(defun-in-flavor (keyboard-table-lookup x-console) (table code shift)
  (declare (values key options))
  (let ((mapping (aref table shift (keycode->keynum code))))
    (cond ((characterp mapping)
	   mapping)
	  ((not (ldb-test sys:%%kbd-mapping-special mapping))
	   (code-char mapping))
	  (t
	   (selector (ldb sys:%%kbd-mapping-special-class mapping) =
	     (sys:%kbd-mapping-special-shift
	       (aref sys:*kbd-mapping-bit-names*
		     (ldb sys:%%kbd-mapping-shift-index mapping)))
	     (sys:%kbd-mapping-special-locking-shift
	       (values (aref sys:*kbd-mapping-bit-names*
			     (ldb sys:%%kbd-mapping-shift-index mapping))
		       '(:locking t)))
	     (sys:%kbd-mapping-special-locking-once-shift
	       (values (aref sys:*kbd-mapping-bit-names*
			     (ldb sys:%%kbd-mapping-shift-index mapping))
		       '(:locking :once)))
	     (sys:%kbd-mapping-special-mouse-button
	       (aref sys:*kbd-mapping-mouse-button-names*
		     (ldb sys:%%kbd-mapping-bit-number mapping))))))))

(defmethod (x-console-make-keyboard-table-argument x-console) ()
  (loop with table = (sys:keyboard-keyboard-table cli::keyboard)
	with nshifts = (array-dimension table 0)
	for code from (keynum->keycode 0) upto (keynum->keycode 255)
	for mapping = (loop for shift below nshifts
			    collect
			      (multiple-value-bind (key options)
				  (keyboard-table-lookup table code shift)
				(if options (cons key options) key)))
	do (loop with reversed-mapping = (reverse mapping)
		 while (and reversed-mapping (null (first reversed-mapping)))
		 do (pop reversed-mapping)
		 finally (setq mapping (reverse reversed-mapping)))
	collect (if (and (not (consp (first mapping)))
			 (loop for m in mapping always (eq m (first mapping))))
		    (first mapping)
		  mapping)))

(defun-in-flavor (fill-keyboard-table-symbol x-console) (table layout-type)
  (declare (ignore layout-type))
  (loop with null-mapping = (sys:standardize-keyboard-mapping nil t)
	with symbol-bit = (dpb 1 sys:%%kbd-mapping-table-index-symbol 0)
	for code from (xlib:display-min-keycode display)
		 to (xlib:display-max-keycode display)
	do (loop for shift below symbol-bit
		 for symbol-shift upfrom symbol-bit
		 for (key options) =
		     (multiple-value-list (keyboard-table-lookup table code shift))
		 for symbol-key =
		     (and key
			  (or (second (assoc key *symbol-keys*))
			      (and (or (not (characterp key))
				       (not (graphic-char-p key)))
				   key)))
		 for mapping = (aref table symbol-shift (keycode->keynum code))
		 when (or (= mapping null-mapping)
			  (loop for shift below symbol-bit
				thereis (= (aref table shift (keycode->keynum code)) mapping)))
		   do (setf (aref table symbol-shift (keycode->keynum code))
			    (sys:standardize-keyboard-mapping
			      (if (and options (eq symbol-key key))
				  (cons symbol-key options)
				symbol-key)
			      t)))))

(defun-in-flavor (fill-keyboard-table-fixup x-console) (table layout-type)
  (declare (ignore layout-type))
  ;; Heuristic hair to make sure there's enough modifier keys.
  (let ((modifier-keys nil))
    ;; Collect together the modifier keys.
    (loop with nshifts = (array-dimension table 0)
	  for code from (keynum->keycode 0) upto (keynum->keycode 255)
	  do (loop for shift below nshifts
		   for mapping = (aref table shift (keycode->keynum code))
		   when (and (not (characterp mapping))
			     (ldb-test sys:%%kbd-mapping-special mapping)
			     (= (ldb sys:%%kbd-mapping-special-class mapping)
				sys:%kbd-mapping-special-shift))
		     do (push (cons code mapping) modifier-keys)
			and return))
    ;; Sort them into some priority order, lower bit numbers first, then
    ;; within a bit number, left before right, etc.
    (setq modifier-keys
	  (sort modifier-keys
		#'(lambda (x y)
		    (if (= (ldb sys:%%kbd-mapping-bit-number x)
			   (ldb sys:%%kbd-mapping-bit-number y))
			(and (not (ldb-test sys:%%kbd-mapping-right-p x))
			     (ldb-test sys:%%kbd-mapping-right-p y))
		      (< (ldb sys:%%kbd-mapping-bit-number x)
			 (ldb sys:%%kbd-mapping-bit-number y))))
		:key #'cdr))
    ;; Check if any modifier keys we need are missing and find a home for them
    (let ((bits-we-need (list sys:%kbd-shifts-shift sys:%kbd-shifts-control
			      sys:%kbd-shifts-meta sys:%kbd-shifts-super
			      sys:%kbd-shifts-hyper sys:%kbd-shifts-symbol)))
      ;; Figure out which bits we need.
      (loop for pair in modifier-keys
	    for bit = (ldb sys:%%kbd-mapping-bit-number (cdr pair))
	    do (setq bits-we-need (delete bit bits-we-need)))
      ;; Now reassign any bits we need
      (loop with modifier-keys-available = (copy-list modifier-keys)
	    for bit in bits-we-need do
	;; Make all modifier keys that are the only key for their bit
	;; unavailable for reassignment.
	(loop for pair in modifier-keys-available
	      unless (loop for avail in modifier-keys-available
			   thereis (and (neq pair avail)
					(= (ldb sys:%%kbd-mapping-bit-number (cdr pair))
					   (ldb sys:%%kbd-mapping-bit-number (cdr avail)))))
		do (setq modifier-keys-available (delete pair modifier-keys-available)))
	;; First try to reassign to the first key we find of lower priority,
	;; then if we can't do that, to the last key we find of higher
	;; priority.
	(unless (loop for pair in modifier-keys-available
		      when (> (ldb sys:%%kbd-mapping-bit-number (cdr pair)) bit)
			do (setf (ldb sys:%%kbd-mapping-bit-number (cdr pair)) bit)
			and return t)
	  (loop for pair in (reverse modifier-keys-available)
		when (< (ldb sys:%%kbd-mapping-bit-number (cdr pair)) bit)
		  do (setf (ldb sys:%%kbd-mapping-bit-number (cdr pair)) bit)
		     and return t))))
    ;; Update the keyboard table from this list of modifier keys
    (loop with nshifts = (array-dimension table 0)
	  for (code . mapping) in modifier-keys
	  do (loop for shift below nshifts
		   do (setf (aref table shift (keycode->keynum code)) mapping)))))

(defun-in-flavor (fill-keyboard-table x-console) (table layout-type)
  (clear-keyboard-table table)
  (fill-keyboard-table-general table layout-type)
  (fill-keyboard-table-specific table layout-type)
  (fill-keyboard-table-symbol table layout-type)
  (fill-keyboard-table-fixup table layout-type))

(defun-in-flavor (keyboard-table-all-keys-up-shift-keys x-console)
		 (keyboard-table layout-type)
  (declare (values all-keys-up-shift-keys)
	   (ignore keyboard-table layout-type))
  nil)

(defun-in-flavor (keyboard-table-mouse-button-shift-keys x-console)
		 (keyboard-table layout-type)
  (declare (values mouse-button-shift-keys)
	   (ignore keyboard-table layout-type))
  nil)

(defun-in-flavor (tokenize-user-property x-console) (line)
  (loop with set = '(#\sp #\return #\tab #\line #\,)
	for lastpos first 0 then pos
	while lastpos
	for startpos = (string-search-not-set set line :start lastpos)
	while startpos
	for pos = (string-search-set set line :start startpos)
	collect (substring line startpos pos)))

(defun-in-flavor (keyboard-layout-type x-console) ()
  (declare (values layout-type keycode-offset))
  (let ((keyboard-type
	  (loop for (key val) in (send host :user-property)
		when (eq key :keyboard-layout-type)
		  thereis
		    (let ((tokens (tokenize-user-property val)))
		      (cond ((= (length tokens) 1)
			     (intern (string-upcase (first tokens)) "KEYWORD"))
			    ((and (= (length tokens) 2)
				  (= (parse-integer (first tokens) :junk-allowed t)
				     display-number))
			     (intern (string-upcase (second tokens)) "KEYWORD")))))))
    (if keyboard-type
	(values
	  keyboard-type 
	  (let ((signature
		  (find keyboard-type *keyboard-signatures*
			:test #'(lambda (keyboard-type signature)
				  (and (eq (keyboard-signature-name signature) keyboard-type)
				       (string-equal
					 (keyboard-signature-vendor-name signature)
					 (xlib:display-vendor-name display)))))))
	    (and signature (keyboard-signature-keycode-offset signature))))
      (multiple-value-bind (type offset) (display-keyboard-layout-type display)
	(values (or type (send host :machine-type)) offset)))))

(defun-in-flavor (update-key-states x-console) (console-key-states)
  (let ((genera-key-states (sys:keyboard-key-states cli::keyboard))
	(console-key-states console-key-states))
    (declare (sys:array-register genera-key-states console-key-states))
    (loop with keyboard-table = (sys:keyboard-keyboard-table cli::keyboard)
	  with all-keys-up-shift-keys = (cli::keyboard-all-keys-up-shift-keys cli::keyboard)
	  with mouse-button-shift-keys = (cli::keyboard-mouse-button-shift-keys cli::keyboard)
	  for code from (xlib:display-min-keycode display)
		   to (xlib:display-max-keycode display)
	  for keynum = (keycode->keynum code)
	  for console-key-state = (not (zerop (aref console-key-states code)))
	  for genera-key-state = (aref genera-key-states keynum)
	  for mapping = (aref keyboard-table 0 keynum)
	  when (and (neq console-key-state genera-key-state)
		    (or (null console-key-state)
			(and (ldb-test sys:%%kbd-mapping-special mapping)
			     (= (ldb sys:%%kbd-mapping-special-class mapping)
				sys:%kbd-mapping-special-shift))
			(member keynum all-keys-up-shift-keys)
			(member keynum mouse-button-shift-keys)))
	    do (let ((hard-char
		       (dpb (if console-key-state sys:%type-key-down sys:%type-key-up)
			    sys:%%kbd-hardware-char-opcode
			    (dpb (keycode->keynum code)
				 sys:%%kbd-hardware-char-key-number
				 0))))
		 (tv:io-buffer-put tv:keystroke-buffer hard-char t nil nil)
		 (tv:console-process-input self))
	  finally
	    (when (and cli::esc-function cli::keyboard-process)
	      (process:process-wakeup cli::keyboard-process)))))

(defflavor x-keyboard
	((last-shifts nil)
	 (leds nil))
	(cli::keyboard)
  :initable-instance-variables
  :readable-instance-variables
  :writable-instance-variables)

(defmethod (sys:print-self x-keyboard) (stream print-depth slashify-p)
  (declare (ignore print-depth slashify-p))
  (sys:printing-random-object (self stream :typep)
    (write-string (x-console-name cli::console) stream)))

(defmethod (cli::keyboard-note-change-of-shift-keys x-keyboard :after) ()
  (let ((display (and cli::console (x-console-display cli::console)))
	(shifts (logior cli::left-shifts cli::right-shifts)))
    (catch-network-errors ()
      (loop for (led-number led-bit) in leds
	    when (or (null last-shifts)
		     (neq (logtest last-shifts led-bit) (logtest shifts led-bit)))
	      do (xlib:change-keyboard-control
		   display
		   :led led-number
		   :led-mode (if (logtest led-bit shifts) :on :off))
		 (tv:remote-console-note-pending-output cli::console)))
    (setq last-shifts shifts)))

(compile-flavor-methods x-keyboard)

(defun-in-flavor (layout-type-leds x-console) (layout-type)
  (loop with mapping = (or (layout-type-keyboard-mapping layout-type)
			   (layout-type-keyboard-mapping :default))
	with leds = (keyboard-mapping-leds mapping)
	for (led-number led-shift) in leds
	for led-bit = (ash 1 (position led-shift sys:*kbd-mapping-bit-names*))
	collect (list led-number led-bit)))

(defmethod (cli::console-create-keyboard x-console) ()
  (make-instance
    'x-keyboard
    :console self
    :keyboard-table (make-array '(4 256) :element-type '(unsigned-byte 16))))

(defun-in-flavor (key-should-not-auto-repeat-p x-console) (key)
  (and key
       (or (not (characterp key))
	   (member key '(#\Function #\Select #\Network #\Suspend #\Resume #\Abort #\Help)))))

(defun-in-flavor (display-modifier-mapping x-console) ()
  (multiple-value-bind (shift lock control mod1 mod2 mod3 mod4 mod5)
      (xlib:modifier-mapping display)
    (list :shift shift :lock lock :control control :mod1 mod1
	  :mod2 mod2 :mod3 mod3 :mod4 mod4 :mod5 mod5)))

(defun-in-flavor (decode-modifier-mapping x-console) (table modifier-mapping)
  (loop with nshifts = (array-dimension table 0)
	for (name mapping) on modifier-mapping by #'cddr
	appending
	  (list name
		(remove-duplicates 
		  (loop for code in mapping
			appending
			  (loop for shift below nshifts
				collect (or (keyboard-table-lookup table code shift) code)))
		  :from-end t))))

(defun-in-flavor (bound-modifier-mapping x-console) (table modifier-mapping)
  (loop with decoded-modifier-mapping = (decode-modifier-mapping table modifier-mapping)
	with real-names = (list :shift :lock :control :mod1 :mod2 :mod3 :mod4 :mod5)
	with last-real-name-used = nil
	for (name . keys) in *modifier-mapping-alist*
	for real-name = (if (member name real-names)
			    name
			  (loop for key in keys
				thereis
				  (loop for (modifier-name modifier-keys)
					    on decoded-modifier-mapping by #'cddr
					when (and (member key modifier-keys)
						  (member modifier-name real-names))
					  return modifier-name)))
	if real-name
	  do (setq real-names (delete real-name real-names))
	     (setq last-real-name-used real-name)
	  and append (list real-name keys) into defined-modifiers
	else append (list name keys) into undefined-modifiers
	finally
	  ;; Grab as many unassigned modifiers as we can
	  (loop for (name keys) on (copy-list undefined-modifiers) by #'cddr
		for real-name
		    = (loop for real-name = (pop real-names)
			    while (and real-name (getf modifier-mapping real-name))
			    finally (return real-name))
		while real-name
		do (remf undefined-modifiers name)
		   (setf (getf defined-modifiers real-name) keys)
		   (setq last-real-name-used real-name))
	  ;; If we still need some, just use the last one we get for everthing we 
	  ;; have yet to assign.
	  (when (and undefined-modifiers last-real-name-used)
	    (loop for (name keys) on (copy-list undefined-modifiers) by #'cddr
		  do (remf undefined-modifiers name)
		     (setf (getf defined-modifiers last-real-name-used)
			   (append (getf defined-modifiers last-real-name-used) keys))))
	  (return defined-modifiers)))

(defun-in-flavor (update-server-modifier-mapping x-console) ()
  (loop
    for i below 10
    while 
      (eq (xlib:with-server-grabbed (display)
	    (loop
              with table = (sys:keyboard-keyboard-table cli::keyboard)
	      with nshifts = (array-dimension table 0)
	      with display-modifier-mapping = (display-modifier-mapping)
	      with modifier-mapping = (copy-tree display-modifier-mapping)
	      with bound-modifier-mapping =
		(bound-modifier-mapping table display-modifier-mapping)
	      for code from (xlib:display-min-keycode display)
		       to (xlib:display-max-keycode display)
	      do (loop
                   for shift below nshifts
		   for key = (keyboard-table-lookup table code shift)
		   when key
		     thereis 
		       (loop
                         for (name keys) on bound-modifier-mapping by #'cddr
			 when (member key keys)
			   do (pushnew code (getf modifier-mapping name))
			   and return t))
	      finally
		(return
		  (unless (equal modifier-mapping display-modifier-mapping)
		    (catch-network-errors ()
		      (apply #'xlib:set-modifier-mapping display modifier-mapping))))))
	  :busy)
    do (cli::console-beep self)
       (sleep 1)))

(defmethod (x-console-update-keyboard-mapping x-console) ()
  (let ((table (sys:keyboard-keyboard-table cli::keyboard))
	(layout-type (sys:keyboard-layout-type cli::keyboard)))
    (fill-keyboard-table table layout-type)
    (dolist (remapping cli::*keyboard-table-remappings*)
      (destructuring-bind (value remapping-layout-type . rest) remapping
	(when (eq remapping-layout-type layout-type)
	  (apply #'sys:set-keyboard-table-mapping value table rest))))
    (setf (cli::keyboard-all-keys-up-shift-keys cli::keyboard)
	  (keyboard-table-all-keys-up-shift-keys table layout-type))
    (setf (cli::keyboard-mouse-button-shift-keys cli::keyboard)
	  (keyboard-table-mouse-button-shift-keys table layout-type))
    (setf (x-keyboard-leds cli::keyboard) (layout-type-leds layout-type)))
  (cli::keyboard-initialize cli::keyboard)
  (update-server-modifier-mapping))

(defmethod (x-console-parse-color x-console) (string)
  (let* ((length (string-length string))
	 (ndigits (min (floor (1- length) 3) 4)))
    (if (and (> length 1) (char= (aref string 0) #\#))
	(flet ((parse-color-hex (start end)
		 (/ (float (* (or (parse-integer
				    string :start start :end end :radix 16 :junk-allowed t)
				  0)
			      (expt 16 (- 4 ndigits))))
		    65536.0)))
	  (xlib:make-color
	    :red (parse-color-hex 1 (1+ ndigits))
	    :green (parse-color-hex (1+ ndigits) (1+ (* ndigits 2)))
	    :blue (parse-color-hex (1+ (* ndigits 2)) (1+ (* ndigits 3)))))
      string)))

(defmethod (x-console-get-default x-console) (name class)
  (stack-let ((full-name (ncons resource-name))
	      (full-class (ncons resource-class)))
    (xlib:get-resource resource-database name class full-name full-class)))

(defmethod (x-console-get-default-color x-console) (name class color default)
  (unless color (setq color (x-console-get-default self name class)))
  (unless color (setq color default))
  (when (stringp color) (setq color (x-console-parse-color self color)))
  (or color default))

(defmethod (x-console-get-default-integer x-console) (name class integer default)
  (unless integer (setq integer (x-console-get-default self name class)))
  (when (stringp integer) (setq integer (parse-integer integer :junk-allowed t)))
  (or integer default))

(defmethod (x-console-get-default-keyword x-console) 
	   (name class keyword default &optional acceptable-keywords)
  (unless keyword (setq keyword (x-console-get-default self name class)))
  (when (stringp keyword) (setq keyword (intern (string-upcase keyword) "KEYWORD")))
  (or (and (or (null acceptable-keywords)
	       (member keyword acceptable-keywords))
	   keyword)
      default))

(defmethod (x-console-get-default-boolean x-console) (name class boolean default)
  (unless boolean (setq boolean (x-console-get-default self name class)))
  (cond ((and boolean (string-equal boolean "Yes")) t)
	((and boolean (string-equal boolean "No")) nil)
	(t default)))

(defmethod (x-console-parse-geometry x-console) (geometry)
  (declare (values x y width height))
  (let* ((height-start (string-search "x" geometry))
	 (x-start (string-search-set "+-" geometry))
	 (y-start (and x-start (string-search-set "+-" geometry :start (1+ x-start))))
	 (width 
	   (and height-start
		(parse-integer geometry :end height-start :junk-allowed t)))
	 (height
	   (and height-start
		(parse-integer geometry :start (1+ height-start) :end x-start
			       :junk-allowed t)))
	 (x-minus
	   (and x-start
		(char= (aref geometry x-start) #\-)))
	 (x
	   (and x-start
		(parse-integer geometry :start (1+ x-start) :end y-start :junk-allowed t)))
	 (y-minus
	   (and y-start
		(char= (aref geometry y-start) #\-)))
	 (y
	   (and y-start
		(parse-integer geometry :start (1+ y-start) :junk-allowed t))))
    (when (and width x-minus x)
      (setq x (- (xlib:screen-width screen) width x)))
    (when (and height y-minus y)
      (setq y (- (xlib:screen-height screen) height y)))
    (values x y width height)))

(defmethod (x-console-get-default-geometry x-console)
	   (name class geometry default-x default-y default-width default-height)
  (unless geometry (setq geometry (x-console-get-default self name class)))
  (multiple-value-bind (x y width height)
      (x-console-parse-geometry self geometry)
    (values (or x default-x) (or y default-y)
	    (or width default-width) (or height default-height))))

(defmethod (x-console-unparse-color x-console) (color)
  (etypecase color
    (string color)
    (xlib:color
      (format nil "#~4,'0X~4,'0X~4,'0X"
	      (min #xffff (floor (* (xlib:color-red color) 65536.0)))
	      (min #xffff (floor (* (xlib:color-green color) 65536.0)))
	      (min #xffff (floor (* (xlib:color-blue color) 65536.0)))))))

(defun-in-flavor (update-command x-console) ()
  (setf command
	(present-to-string
	  `(com-start-x-screen
	     ,host
	     ,@(and (not (zerop display-number)) `(:display ,display-number))
	     ,@(and (not (zerop screen-number)) `(:screen ,screen-number))
	     :geometry ,(format nil "~Dx~D+~D+~D" window-width window-height window-x window-y)
	     ,@(and remote-program `(:program ,(dw:program-name remote-program)))	
	     ,@(and (null reuse-old-screen-p) `(:reuse ,reuse-old-screen-p))
	     ,@(and foreground-color
		    `(:foreground ,(x-console-unparse-color self foreground-color)))
	     ,@(and background-color
		    `(:background ,(x-console-unparse-color self background-color)))
	     ,@(and border-width `(:border-width ,border-width))
	     ,@(and border-color
		    `(:border-color ,(x-console-unparse-color self border-color)))
	     ,@(and activity `(:activity ,activity))
	     :who-line ,who-line-p
	     :compatible-color ,compatible-color-p
	     :initial-state ,initial-state)
	  'cp:command
	  :acceptably :very
	  :for-context-type '((cp:command-or-form :dispatch-mode :form-preferred)))))

(defparameter *genera-icon-rasters*
	      `((,(xlib:read-bitmap-file "SYS:X11;SCREEN;GENERA-ICON-32.XBM")
		 ,(xlib:read-bitmap-file "SYS:X11;SCREEN;GENERA-MASK-32.XBM"))
		(,(xlib:read-bitmap-file "SYS:X11;SCREEN;GENERA-ICON-16.XBM")
		 ,(xlib:read-bitmap-file "SYS:X11;SCREEN;GENERA-MASK-16.XBM"))))

#|| ;; These functions were used to make the original icon bitmaps.  
(defun make-genera-icon-raster (width height)
  (graphics:with-output-to-bitmap (stream :width width :height height)
    (graphics:with-graphics-scale (stream (/ width 32.0) (/ height 32.0))
      (graphics:draw-rectangle 0 0 32 32 :stream stream :gray-level 0)
      (graphics:draw-rectangle 10 3 19 12
			       :stream stream
			       :stipple (tv:make-binary-gray 2 4 '#2r(0101 1010))
			       :opaque t)
      (graphics:draw-rectangle 10 3 19 12
			       :stream stream :filled nil)
      (graphics:draw-circle (- 32 10) 16 7
			    :stream stream
			    :stipple (tv:make-binary-gray 4 3 '#2r(100 010 001 010))
			    :opaque t)
      (graphics:draw-circle (- 32 10) 16 7 :stream stream :filled nil)
      (graphics:draw-triangle 3 (- 32 3) (+ 3 7) (- 32 3 14) (+ 3 14) (- 32 3)
			      :stream stream
			      :stipple (tv:make-binary-gray 4 2 '#2r(01 10 10 01))
			      :opaque t)
      (graphics:draw-triangle 3 (- 32 3) (+ 3 7) (- 32 3 14) (+ 3 14) (- 32 3)
			      :stream stream :filled nil))))

(defun make-genera-icon-mask-raster (width height)
  (graphics:with-output-to-bitmap (stream :width width :height height)
    (graphics:with-graphics-scale (stream (/ width 32.0) (/ height 32.0))
      (graphics:draw-rectangle 0 0 32 32 :stream stream :gray-level 0)
      (graphics:draw-rectangle 10 3 19 12
			       :stream stream)
      (graphics:draw-rectangle 10 3 19 12
			       :stream stream :filled nil)
      (graphics:draw-circle (- 32 10) 16 7
			    :stream stream)
      (graphics:draw-circle (- 32 10) 16 7 :stream stream :filled nil)
      (graphics:draw-triangle 3 (- 32 3) (+ 3 7) (- 32 3 14) (+ 3 14) (- 32 3)
			      :stream stream)
      (graphics:draw-triangle 3 (- 32 3) (+ 3 7) (- 32 3 14) (+ 3 14) (- 32 3)
			      :stream stream :filled nil))))
||#

(defun-in-flavor (raster-pixmap x-console) (raster)
  (let* ((image (if (arrayp raster)
		    (let ((depth (sys:array-bits-per-element (sys:array-type-field raster))))
		      (xlib:create-image :data raster :bits-per-pixel depth))
		    raster))
	 (width (xlib:image-width image))
	 (height (xlib:image-height image))
	 (depth (xlib:image-depth image)))
    (with-pixmap ((pm gc) width height depth root)
      (xlib:put-image pm gc image :x 0 :y 0 :width width :height height)
      (shiftf pm nil))))

(defun-in-flavor (compute-icon-pixmaps x-console) (user-icon user-mask)
  (setf icon-raster user-icon)
  (setf icon-mask-raster user-mask)
  (setf icon-window nil)
  (let ((hints (xlib:icon-sizes root)))
    (when (null icon-raster)
      (when (< (xlib:screen-root-depth screen) 4)
	(loop for (icon mask) in *genera-icon-rasters* do
	  (when (or (null hints)
		    (and (let ((width (xlib:image-width icon))
			       (min-width (xlib:wm-size-hints-min-width hints))
			       (max-width (xlib:wm-size-hints-max-width hints))
			       (width-inc (xlib:wm-size-hints-width-inc hints)))
			   (and (or (null min-width)
				    ( min-width width))
				(or (null max-width)
				    ( max-width width))
				(or (null min-width)
				    (null width-inc)
				    (zerop width-inc)
				    (zerop (mod (- width min-width) width-inc)))))
			 (let ((height (xlib:image-height icon))
			       (min-height (xlib:wm-size-hints-min-height hints))
			       (max-height (xlib:wm-size-hints-max-height hints))
			       (height-inc (xlib:wm-size-hints-height-inc hints)))
			   (and (or (null min-height)
				    ( min-height height))
				(or (null max-height)
				    ( max-height height))
				(or (null min-height)
				    (null height-inc)
				    (zerop height-inc)
				    (zerop (mod (- height min-height) height-inc)))))))
	    (setf icon-raster icon)
	    (setf icon-mask-raster mask)
	    (return)))))
    (cond (icon-raster
	   (setf icon-pixmap (raster-pixmap icon-raster))
	   (setf icon-mask (raster-pixmap icon-mask-raster))
	   (setf icon-window nil))
	  (t
	   (setf icon-pixmap nil)
	   (setf icon-mask nil)
	   (setf icon-window-width
		 (or icon-width
		     (and hints
			  (let ((min-width (xlib:wm-size-hints-min-width hints))
				(max-width (xlib:wm-size-hints-max-width hints)))
			    (cond ((< 32 min-width) min-width)
				  ((< 32 max-width) 32)
				  (t max-width))))
		     32))
	   (setf icon-window-height
		 (or icon-height
		     (and hints
			  (let ((min-height (xlib:wm-size-hints-min-height hints))
				(max-height (xlib:wm-size-hints-max-height hints)))
			    (cond ((< 32 min-height) min-height)
				  ((< 32 max-height) 32)
				  (t max-height))))
		     32))
	   (cond ((< (xlib:screen-root-depth screen) 4)
		  (setf icon-window (xlib:create-window
				      :parent root :x (or icon-x 0) :y (or icon-y 0)
				      :width icon-window-width :height icon-window-height
				      :background (xlib:screen-white-pixel screen)
				      :event-mask '(:exposure :structure-notify)))
		  (setf icon-color-s
			(setf icon-color-c
			      (setf icon-color-t (xlib:screen-black-pixel screen)))))
		 (t
		  (flet ((cgc (r g b)
			   (condition-case ()
				(xlib:alloc-color (xlib:screen-default-colormap screen)
						  (xlib:make-color :red r :green g :blue b))
			      (xlib:alloc-error
				(if (< 3 (+ r g b))
				    (xlib:screen-black-pixel screen)
				    (xlib:screen-white-pixel screen))))))
		    (setf icon-window (xlib:create-window
					:parent root :x (or icon-x 0) :y (or icon-y 0)
					:width icon-window-width :height icon-window-height
					:background (cgc 1.0 1.0 1.0)
					:event-mask '(:exposure :structure-notify)))
		    (setf icon-color-s (cgc 0.0 1.0 0.0))
		    (setf icon-color-c (cgc 1.0 0.0 0.0))
		    (setf icon-color-t (cgc 1.0 0.0 1.0))))))))	 
  nil)

(defun-in-flavor (show-icon x-console) ()
  (let ((icon-gc (xlib:create-gcontext :drawable icon-window))
	(size (min icon-window-width icon-window-height)))
    (let ((xoff (floor (- icon-window-width size) 2))
	  (yoff (floor (- icon-window-height size) 2)))
      (macrolet ((fix (x) `(round (* size ,(/ x 32.0)))))
	(setf (xlib:gcontext-foreground icon-gc) icon-color-s)
	(xlib:draw-rectangle icon-window icon-gc
			     (+ xoff (fix 10)) (+ yoff (fix 3)) (fix 9) (fix 9) t)
	(setf (xlib:gcontext-foreground icon-gc) icon-color-c)
	(xlib:draw-arc icon-window icon-gc
		       (+ xoff (fix 15)) (+ yoff (fix 9)) (fix 14) (fix 14) 0 (* 2 pi) t)
	(setf (xlib:gcontext-foreground icon-gc) icon-color-t)
	(xlib:draw-lines icon-window icon-gc
			 `(,(+ xoff (fix 3)) ,(+ yoff (fix 29))
			   ,(+ xoff (fix 10)) ,(+ yoff (fix 15))
			   ,(+ xoff (fix 17)) ,(+ yoff (fix 29)))
			 :fill-p t :shape :convex)))
    (xlib:free-gcontext icon-gc)))

(defun-in-flavor (initialize-options x-console) ()
  ;; Assign the defaults that don't come from the resource database
  (unless resource-class (setq resource-class "Genera"))
  (unless resource-name (setq resource-name "genera"))

  (unless window-name
    (setq window-name (format nil "Genera on ~A" (send net:*local-host* :pretty-name))))
  (unless icon-name (setq icon-name "Genera"))

  (unless client-machine (setq client-machine (string net:*local-host*)))

  ;; Set up the resource database
  (setq resource-database (xlib:make-resource-database))
  (xlib:wm-resources resource-database root)

  (setq who-line-p
	(x-console-get-default-boolean
	  self "whoLine" "WhoLine"
	  (and (variable-boundp who-line-p) (if who-line-p "Yes" "No"))
	  default-who-line-p))

  ;; Compatible color if specified and if capable (has correct visual info)
  (block colormap
    (when (x-console-get-default-boolean
	    self "compatibleColor" "CompatibleColor"
	    (and (variable-boundp compatible-color-p) (if compatible-color-p "Yes" "No"))
	    default-compatible-color-p)
      (setf visual-info (find :pseudo-color (rest (assoc 8 (xlib:screen-depths screen)))
			      :key #'xlib:visual-info-class))
      (when visual-info
	(setf colormap (xlib:create-colormap visual-info root t))
	(setf compatible-color-p t)
	(return-from colormap)))
    (setf compatible-color-p nil)
    (let* ((depth (xlib:screen-root-depth screen))
	   (visuals (rest (assoc depth (xlib:screen-depths screen)))))
      (cond ((<= depth 2)
	     (setf visual-info (find :static-gray visuals :key #'xlib:visual-info-class))
	     (when visual-info
	       (setf colormap (xlib:create-colormap visual-info root))
	       (return-from colormap)))
	    ((<= depth 4)
	     (setf visual-info (find :static-color visuals :key #'xlib:visual-info-class))
	     (when visual-info
	       (setf colormap (xlib:create-colormap visual-info root))
	       (return-from colormap)))))
    (setf visual-info (xlib:screen-root-visual-info screen))
    (setf colormap (xlib:screen-default-colormap screen)))

  (unless window-min-width (setq window-min-width (if who-line-p 640 320)))
  (unless window-min-height (setq window-min-height (if who-line-p 320 160)))
  (unless window-max-width (setq window-max-width (xlib:screen-width screen)))
  (unless window-max-height (setq window-max-height (xlib:screen-height screen)))

  ;; default the stuff from the resource database that should be defaulted
  (unless (and window-x window-y window-width window-height)
    (multiple-value-setq (window-x window-y window-width window-height)
      (x-console-get-default-geometry
	self "geometry" "Geometry"
	(or window-geometry default-window-geometry)
	(or window-x (round (xlib:screen-width screen) 20))
	(or window-y (round (xlib:screen-height screen) 20))
	(or window-width (- (xlib:screen-width screen) (round (xlib:screen-width screen) 10)))
	(or window-height
	    (- (xlib:screen-height screen) (round (xlib:screen-height screen) 10))))))
  (setq window-width (max (min window-width window-max-width) window-min-width))
  (setq window-height (max (min window-height window-max-height) window-min-height))

  (unless window-depth
    (setq window-depth
	(x-console-get-default-integer
	  self "depth" "Depth" window-depth default-window-depth)))
  (setq window-depth (min window-depth (xlib:screen-root-depth screen)))

  (unless (and icon-x icon-y)
    (multiple-value-setq (icon-x icon-y icon-width icon-height)
      (x-console-get-default-geometry
	self "iconGeometry" "IconGeometry"
	(or icon-geometry default-icon-geometry)
	nil nil nil nil)))

  (unless initial-state
    (setq initial-state
	  (x-console-get-default-keyword
	    self "initialState" "InitialState"
	    initial-state default-initial-state
	    '(:dont-care :normal :iconic))))

  (setq border-color
	(x-console-get-default-color
	  self "borderColor" "BorderColor"
	  border-color default-border-color))
  (setq border
	(if compatible-color-p
	    255
	    (xlib:alloc-color colormap border-color)))
  (setq border-width
	(x-console-get-default-integer
	  self "borderWidth" "BorderWidth"
	  border-width default-border-width))

  (setq foreground-color
	(x-console-get-default-color
	  self "foreground" "Foreground"
	  foreground-color default-foreground-color))
  (setq foreground
	(if compatible-color-p
	    255
	    (xlib:alloc-color colormap foreground-color)))
  (setq background-color
	(x-console-get-default-color
	  self "background" "Background"
	  background-color default-background-color))
  (setq background
	(if compatible-color-p
	    0
	    (xlib:alloc-color colormap background-color)))
  (when (= foreground background)
    (setq foreground (xlib:screen-black-pixel screen)
	  background (xlib:screen-white-pixel screen)))

  (setq cursor-foreground-color
	(x-console-get-default-color
	  self "cursorForeground" "CursorForeground"
	  cursor-foreground-color
	  (or default-cursor-foreground-color foreground-color)))
  (when (stringp cursor-foreground-color)
    (setf cursor-foreground-color (xlib:lookup-color colormap cursor-foreground-color)))
  (setq cursor-background-color
	(x-console-get-default-color
	  self "cursorBackground" "CursorBackground"
	  cursor-background-color
	  (or default-cursor-background-color background-color)))
  (when (stringp cursor-background-color)
    (setf cursor-background-color (xlib:lookup-color colormap cursor-background-color)))

  (update-command)
  )

(defun-in-flavor (set-wm-properties x-console) ()
  (xlib:set-wm-properties window
			  :name window-name
			  :resource-name resource-name :resource-class resource-class
			  :input :on :initial-state initial-state
			  :icon-x icon-x :icon-y icon-y :icon-name icon-name
			  :icon-pixmap icon-pixmap :icon-mask icon-mask
			  :icon-window icon-window
			  :min-width window-min-width :min-height window-min-height
			  :max-width window-max-width :max-height window-max-height
			  :min-aspect window-min-aspect :max-aspect window-max-aspect
			  :user-specified-size-p user-specified-size-p
			  :user-specified-position-p user-specified-position-p
			  :program-specified-size-p (not user-specified-size-p)
			  :program-specified-position-p (not user-specified-position-p)
			  :base-width window-width :base-height window-height
			  :window-group window-group))

(defun-in-flavor (setup-root-window x-console) ()
  (setf display (xlib:open-display host :display display-number :protocol protocol))
  (setf screen (elt (xlib:display-roots display) screen-number))
  (setf root (xlib:screen-root screen))
  (x-display-device-initialize display-device)
  (initialize-options)
  (setf blank-cursor
	(stack-let ((raster (make-raster-array 32 1 :element-type 'bit)))
	  (x-console-make-cursor self raster 1 1 0 0)))
  (setf window
	(xlib:create-window
	  :parent root :x window-x :y window-y
	  :depth window-depth :width window-width :height window-height
	  :visual visual-info :colormap colormap
	  :background background :cursor blank-cursor
	  :border border :border-width border-width
	  :backing-store :always
	  :bit-gravity :forget
	  :event-mask '(:key-press :key-release :button-press :button-release
			:exposure :visibility-change :structure-notify :pointer-motion
			:keymap-state :enter-window :leave-window :focus-change)))
  (compute-icon-pixmaps icon-raster icon-mask-raster)
  (set-wm-properties)
  (xlib:map-window window))

(defmethod (x-console-set-icon-raster x-console) (raster &optional mask-raster)
  (catch-network-errors ()
    (let ((old-pixmap (shiftf icon-pixmap nil))
	  (old-mask (shiftf icon-mask nil))
	  (old-window (shiftf icon-window nil)))
      (compute-icon-pixmaps raster mask-raster)
      (set-wm-properties)
      (when old-pixmap (xlib:free-pixmap old-pixmap))
      (when old-mask   (xlib:free-pixmap old-mask))
      (when old-window (xlib:destroy-window old-window))))
  nil)

(defun-in-flavor (ensure-id-unique x-console) ()
  (loop while (loop for console in sys:*consoles*
		    thereis (and (typep console 'x-console)
				 (= (x-console-display-number console) display-number)
				 (= (x-console-screen-number console) screen-number)
				 (= (x-console-id console) id)
				 (neq console self)))
	do (incf id)))

(defmethod (sys:console-initialize x-console :before) ()
  (ensure-id-unique)
  (unless (and (variable-boundp cli::keyboard) cli::keyboard)
    (setq cli::keyboard (cli::console-create-keyboard self)))
  (unless (and (variable-boundp cli::mouse) cli::mouse)
    (setq cli::mouse (sys:console-create-mouse self)))
  (unless display-device
    (setq display-device
	  (make-instance 'x-display-device :console self :display-device si:*b&w-screen*)))
  (setq asynchronous-errors nil
	window-visibility :fully-obscured
	have-focus-p nil
	have-pointer-p nil)
  (setup-root-window)
  (multiple-value-bind (layout-type offset) (keyboard-layout-type)
    (setf (sys:keyboard-layout-type cli::keyboard) layout-type)
    (when offset (setq keycode-offset offset)))
  (x-console-update-keyboard-mapping self)
  (sys:console-ensure-mouse-and-keyboard self)
  (setf (process-name tv:output-process) (x-console-name self "Output"))
  (tv:without-screen-management 
    (tv:initialize-one-screen
      (when reuse-old-screen-p
	(let ((screen nil))
	  (process:atomic-replacef
	    tv:*old-console-screens*
	    (remove (setq screen (find self tv:*old-console-screens*
				       :test #'sys:console-screen-acceptable-p))
		    tv:*old-console-screens*))
	  screen))
      self (cli::console-master-p self)))
  (xlib:display-finish-output display)
  (setf (xlib:display-report-asynchronous-errors display) '(:before-event-handling))
  (setf (xlib::buffer-debug-io display) "CLX display locked"))

;;New method to set the keyboard layout type after the console has already been 
;;initialized
(defmethod (console-set-keyboard-type x-console) (&optional 
						      (layout-type (keyboard-layout-type))
						      (offset (second (multiple-value-list (keyboard-layout-type)))))
  (setf (sys:keyboard-layout-type cli::keyboard) layout-type)
  (when offset (setq keycode-offset offset))
  (x-console-update-keyboard-mapping self)
  )

(defmethod (sys:console-initialize x-console :after) ()
  (pushnew self sys:*consoles*)
  (pushnew cli::screen tv:*console-screens*)
  (cond ((cli::console-master-p self)
	 (setf sys:*main-console* self)
	 (setf sys:*console* self)
	 (setf tv:main-screen cli::screen)
	 (setf tv:default-screen cli::screen)
	 (tv:maybe-run-window-initializations))
	(t
	 (pushnew self sys:*secondary-consoles*)))
  (tv:mouse-initialize-internal cli::mouse cli::screen)
  (setf input-process
	(process:make-process
	  (x-console-name self "Input")
	  :priority (process:make-process-priority :fg 9 :preemptive t)
	  :system-process t
	  :flags `(:no-run-light t
		   :no-kbd-arrest t
		   :no-background-interactor ,(cli::console-master-p self))
	  :warm-boot-action 'process:process-warm-boot-reset
	  :initial-function #'x-console-input-process-top-level
	  :initial-function-arguments `(,self))))

(defmethod (cli::console-note-keyboard-process x-console :after) (process)
  (process:set-process-base-priority
    process (process:make-process-priority :fg 8 :preemptive t))
  (setf (process-name process) (x-console-name self "Keyboard")))

(defmethod (cli::console-note-keyboard-table-remapping x-console)
	   (value layout-type &rest rest)
  (when (eq layout-type (sys:keyboard-layout-type cli::keyboard))
    (apply #'sys:set-keyboard-table-mapping
	   value (sys:keyboard-keyboard-table cli::keyboard) rest)))

;;; This method is called by NETI:CHANGE-LOCAL-SITE-AND-HOST to update the window
;;; and icon names of any active X consoles.  We can't just unconditionally recompute
;;; the names as the user may have setup the names to not include the local host's
;;; name.  Therefore, we examine the contents of the window and icon names and, if
;;; we find the host's name, we replace the old name by the new one.  By the time
;;; we're called, however, the old host names are unavailable so our caller must
;;; provide them.
(defmethod (x-console-note-host-name-change x-console) (old-host-pretty-name
							old-host-short-name)
  (flet ((build-new-name (name use-short-name-p)
	   (when name
	     (multiple-value-bind (position length)
		 (let ((position nil))
		   (cond ((setq position (string-search old-host-pretty-name name))
			  (values position (string-length old-host-pretty-name)))
			 ((setq position (string-search old-host-short-name name))
			  (values position (string-length old-host-short-name)))
			 (t
			   (values nil nil))))
	       (when position
		 (string-append (substring name 0 position)
				(if (and use-short-name-p
					 (send net:*local-host* :get :short-name))
				    (send net:*local-host* :short-name)
				    (send net:*local-host* :pretty-name))
				(substring name (+ position length))))))))
    (let ((new-window-name (build-new-name window-name nil))
	  (new-icon-name (build-new-name icon-name t)))
      (cond ((and new-window-name new-icon-name)
	     (setf window-name new-window-name
		   icon-name new-icon-name)
	     (xlib:set-wm-properties window
				     :name window-name
				     :icon-name icon-name))
	    (new-window-name
	      (setf window-name new-window-name)
	      (xlib:set-wm-properties window
				      :name window-name))
	    (new-icon-name
	      (setf icon-name new-icon-name)
	      (xlib:set-wm-properties window
				      :icon-name icon-name)))))
  (update-command))

(defmethod (x-console-shutdown x-console) (&key abort kill)
  (when (and cli::mouse (tv:mouse-process cli::mouse))
    (tv:shutdown-this-mouse cli::mouse))
  (tv:clear-previously-selected-windows self)
  (setq cli::selected-window nil)
  (dolist (screen tv:all-the-screens)
    (when (eq (send screen :console) self)
      (x-screen-shutdown screen :abort abort :kill kill)))
  (sys:console-disable self :abort abort)
  (cli::console-remove self)
  (maphash #'(lambda (key session)
	       (ignore key)
	       (when (and (eq host (xdm-session-host session))
			  (= display-number (xdm-session-display-number session)))
		 (setf (xdm-session-root session) nil)))
	   *xdm-sessions*))

(defmethod (sys:console-disable x-console :before) (&key abort)
  (declare (ignore abort))
  (when cli::keyboard-process
    (setf (process-name cli::keyboard-process) "Keyboard")
    (process:set-process-base-priority
      cli::keyboard-process (process:make-process-priority :fg 30 :preemptive t))))

(defmethod (sys:console-disable x-console) (&key abort)
  (when display-device (x-display-device-reset display-device))
  (when (and input-process (neq input-process *current-process*))
    (process:kill input-process))
  (when display
    (catch-network-errors ()
      (xlib:close-display display :abort abort))))

(defparameter *unacceptable-asynchronous-error-count* 10)
(defparameter *unacceptable-asynchronous-error-interval* (* 5 60))

(defun-in-flavor (x-error-handler x-console)
		 (display error-key &rest key-vals &key asynchronous resource-id
			  &allow-other-keys)
  (condition-case-if asynchronous (error)
       (apply #'xlib:default-error-handler display error-key key-vals)
     (conditions:error
       (when (and resource-id
		  (gethash resource-id pixmap-validity-table))
	 (push error (getf (gethash resource-id pixmap-validity-table) :errors))
	 (return-from x-error-handler nil))
       (push (list (time:time) error) asynchronous-errors)
       ;; Enter the debugger if we're getting too many errors.
       (let ((interval
	       (and ( (length asynchronous-errors) *unacceptable-asynchronous-error-count*)
		    (time:time-difference 
		      (time:time)
		      (first (nth (1- *unacceptable-asynchronous-error-count*)
				  asynchronous-errors))))))
	 (if (and interval ( interval *unacceptable-asynchronous-error-interval*))
	     (dbg:enter-debugger
	       error
	       (format nil "~D asynchronous errors have occured in ~A"
		       *unacceptable-asynchronous-error-count*
		       (with-output-to-string (stream)
			 (time:print-interval-or-never (ceiling interval 60) stream)))
	       '(((#\RESUME) :EXIT-DEBUGGER "Proceed anyway."))
	       t)
	     (tv:notify nil "X Error in process ~A:~%~~A~" *current-process* error))))))

(defun-in-flavor (local-event-time-from-server-event-time x-console) (server-event-time)
  (prog1
    (setq last-local-event-time
	  (let ((server-event-time-delta (- server-event-time last-server-event-time)))
	    (if (>= 2000 server-event-time-delta 0)
		(+ last-local-event-time (* 1000 server-event-time-delta))
	      (time:fixnum-microsecond-time))))
    (setq last-server-event-time server-event-time)))

(defmethod (x-console-input-process-top-level x-console) ()
  (with-x-console-restart (self)
    (unwind-protect
	(progn
	  (setq input-process *current-process*)
	  (catch-network-errors ()
	    (setf (xlib:display-error-handler display) #'x-error-handler)
	    (xlib:event-case (display :discard-p t :force-output-p nil)
	      ((:motion-notify) (x y)
	       (let ((mx x) (my y))
		 ;; Skip over any strung-together mouse motion events and
		 ;; set the mouse cursor to the most recent one.
		 (xlib:process-event
		   display
		   :force-output-p nil
		   :discard-p t
		   :peek-p t
		   :timeout 0
		   :handler #'(lambda (&key event-key x y &allow-other-keys)
				(declare (sys:downward-function))
				(cond ((eq event-key :motion-notify)
				       (setq mx x my y)
				       nil)
				      (t))))
		 (when (and have-pointer-p have-focus-p)
		   (tv:remote-console-new-mouse-position mx my)))
	       nil)
	      ((:button-press :button-release) (event-key code state x y time)
	       (tv:remote-console-new-mouse-buttons
		 (sys:%logldb (byte 3 8)
			      (ecase event-key
				(:button-press (logior (lsh 1_7 code) state))
				(:button-release (logandc1 (lsh 1_7 code) state))))
		 x y (local-event-time-from-server-event-time time))
	       nil)
	      ((:key-press :key-release) (event-key code)
	       (let ((hard-char (dpb (ecase event-key
				       (:key-press sys:%type-key-down)
				       (:key-release sys:%type-key-up))
				     sys:%%kbd-hardware-char-opcode
				     (dpb (keycode->keynum code)
					  sys:%%kbd-hardware-char-key-number
					  0))))
		 (tv:io-buffer-put tv:keystroke-buffer hard-char t nil nil)
		 (tv:console-process-input self)
		 (when (and cli::esc-function cli::keyboard-process)
		   (process:process-wakeup cli::keyboard-process)))
	       nil)
	      ((:exposure) (count (:window in-window) x y width height)
	       (cond ((xlib:window-equal in-window window)
		      (dolist (screen tv:all-the-screens)
			(when (and (eq self (send screen :console))
				   (eq in-window (tv:screen-buffer screen)))
			  (tv:remote-console-asynchronous-refresh
			    self screen x y (+ x width) (+ y height) :wakeup (zerop count)))))
		     ((and icon-window (xlib:window-equal in-window icon-window))
		      (show-icon)))
	       nil)
	      ((:visibility-notify) (state)
	       (setf window-visibility state)
	       nil)
	      ((:mapping-notify) (request start count)
	       (xlib:mapping-notify display request start count)
	       (case request
		 (:keyboard (x-console-update-keyboard-mapping self))
		 (:modifier (x-console-update-keyboard-mapping self))
		 (:pointer))
	       nil)
	      ((:keymap-notify) (keymap)
	       (update-key-states keymap)
	       nil)
	      ((:configure-notify) ((:window in-window) x y width height (:border-width bw))
	       (cond ((xlib:window-equal in-window window)
		      (setq window-x x window-y y border-width bw)
		      (setq border-width bw)
		      (setq user-specified-size-p t user-specified-position-p t)
		      (unless (and (= window-width width) (= window-height height))
			(setf window-width width window-height height)
			(tv:remote-console-note-size-changed self)))
		     ((and icon-window (xlib:window-equal in-window icon-window))
		      (setf icon-window-width width)
		      (setf icon-window-height height)))
	       nil)
	      ((:enter-notify) (x y focus-p)
	       (setf have-pointer-p t)
	       (when (and focus-p (not have-focus-p))
		 (setf have-focus-p :from-enter-notify))
	       (when have-focus-p
		 (tv:remote-console-new-mouse-position x y)
		 (when pending-warp-pointer
		   (apply #'x-console-warp-pointer self (shiftf pending-warp-pointer nil))))
	       nil)
	      ((:leave-notify) (focus-p)
	       (setf have-pointer-p nil)
	       (when (or (not focus-p) (eq have-focus-p :from-enter-notify))
		 (setf have-focus-p nil))
	       (tv:remote-console-new-mouse-position -1 -1)
	       nil)
	      ((:focus-in) ()
	       (setf have-focus-p t)
	       (when (and have-pointer-p pending-warp-pointer)
		 (apply #'x-console-warp-pointer self (shiftf pending-warp-pointer nil)))
	       nil)
	      ((:focus-out) ()
	       (setf have-focus-p nil)
	       (tv:remote-console-new-mouse-position -1 -1)
	       nil)
	      ((:map-notify) ((:window in-window))
	       (cond ((xlib:window-equal in-window window)
		      (setf initial-state :normal)
		      (tv:remote-console-new-mouse-position -1 -1)))
	       nil)
	      ((:unmap-notify) ((:window in-window))
	       (cond ((xlib:window-equal in-window window)
		      (setf initial-state :iconic)
		      (tv:remote-console-new-mouse-position -1 -1)))
	       nil)
	      ((:client-message) (format data)
	       (when remote-program
		 (x-screen-program-client-message-event remote-program format data))
	       nil)
	      ))
	  (setf (xlib:display-error-handler display) #'xlib:default-error-handler)
	  (x-console-shutdown self))
      (store-conditional (locf input-process) *current-process* nil))))

(defmethod (tv:remote-console-force-output x-console) ()
  (catch-network-errors ()
    (xlib:display-force-output display)))

;;; The VLM console channel is a zero-latency channel.  Whenever we issue
;;; a write request to the channel, it is immediately sent to the server.
;;; (The write request is implemented by a %COPROCESSOR-WRITE that doesn't
;;; return until all data has been handed off to the server.)  Therefore,
;;; we don't need to do anything to ensure that the blinkers made it out.
;;; In fact, if we do, we seem to trigger a bug in DEC's X server that
;;; causes replies to be dropped which leads to the infamous "UI hang bug".
(defmethod (tv:remote-console-finish-blinkers x-console) ()
  (unless (eql protocol :VLM)
    (tv:remote-console-finish self)))

(defmethod (tv:remote-console-finish x-console) ()
  (catch-network-errors ()
    (xlib:display-finish-output display)))

(defmethod (x-console-make-cursor x-console) (raster width height x-offset y-offset)
  (sys:with-data-stack
    (catch-network-errors ()
      (let* ((nwidth (+ width 2))
	     (nheight (+ height 2))
	     (nspan (* 32 (ceiling nwidth 32)))
	     (pattern (sys:make-stack-array `(,nheight ,nspan) :element-type 'bit))
	     (mask (sys:make-stack-array `(,nheight ,nspan) :element-type 'bit)))
	(bitblt boole-1 width height raster 0 0 pattern 1 1)
	(dotimes (i 2)
	  (dotimes (j 2)
	    (bitblt boole-ior width height raster 0 0 mask i j)))
	(let ((pimage (xlib:create-image :data pattern))
	      (mimage (xlib:create-image :data mask)))
	  (with-pixmap ((ppm pgc) nwidth nheight 1 root)
	    (with-pixmap ((mpm mgc) nwidth nheight 1 root)
	      (xlib:put-image ppm pgc pimage :x 0 :y 0 :width nwidth :height nheight)
	      (xlib:put-image mpm mgc mimage :x 0 :y 0 :width nwidth :height nheight)
	      (xlib:create-cursor :source ppm :mask mpm
				  :x (1+ x-offset) :y (1+ y-offset)
				  :foreground cursor-foreground-color
				  :background cursor-background-color))))))))

(defmethod (x-console-free-cursor x-console) (cursor)
  (catch-network-errors ()
    (xlib:free-cursor cursor)
    (tv:remote-console-note-pending-output self)))

(defmethod (x-console-install-cursor x-console) (cursor)
  (catch-network-errors ()
    (setf (xlib:window-cursor window) (or cursor blank-cursor))
    (tv:remote-console-force-output self)))

(defmethod (cli::console-beep x-console) ()
  (catch-network-errors ()
    (xlib:bell display)
    (tv:remote-console-finish self)))

(defwhopper (tv:console-screens-for-selection x-console) ()
  (and reuse-old-screen-p
       (continue-whopper)))

(defmethod (x-console-warp-pointer x-console) (dst x y)
  (if (and have-pointer-p have-focus-p)
      (catch-network-errors ()
	(xlib:warp-pointer dst x y)
	(tv:remote-console-note-pending-output self))
    (setq pending-warp-pointer (list dst x y))))

(defun-in-flavor (key-mapping-interesting-p x-console) (genera-keys chars all match)
  (loop with chars = chars
	for shift upfrom 0
	for genera-key in genera-keys
	for char = (pop chars)
	thereis
	  (and genera-key
	       (or all
		   match
		   (and (not (eql char genera-key))
			(zerop (ldb sys:%%kbd-mapping-table-index-symbol shift))))
	       (or (null match)
		   (string-search
		     match
		     (if (characterp genera-key)
			 (char-name genera-key)
		       (string genera-key)))))))

(defun-in-flavor (get-keyboard-mapping x-console) (all match)
  (declare (values console-key-assignments unassigned-genera-keys unassigned-console-keys))
  (loop with unassigned-genera-keys = (copy-list *keys-to-assign*)
	with nxshifts = (array-dimension (xlib::display-keyboard-mapping display) 1)
	with table = (sys:keyboard-keyboard-table cli::keyboard)
	with nlshifts = (array-dimension table 0)
	for code from (xlib:display-min-keycode display)
		 to (xlib:display-max-keycode display)
	for chars = (loop for shift below nxshifts
			  collect (xlib:keycode->character display code shift))
	for genera-keys =
	    (loop for shift below nlshifts
		  collect (keyboard-table-lookup table code shift))
	for keysyms = (loop for shift below nxshifts
			    collect (xlib:keycode->keysym display code shift))
	when (and (loop for genera-key in genera-keys never genera-key)
		  (loop for keysym in keysyms thereis (plusp keysym)))
	  collect code into unassigned-console-keys
	do (loop for genera-key in genera-keys
		 when genera-key
		   do (setq unassigned-genera-keys
			    (delete genera-key unassigned-genera-keys)))
	when (key-mapping-interesting-p genera-keys chars all match)
	  collect (cons code genera-keys) into console-key-assignments
	finally
	  (return
	    (values
	      console-key-assignments unassigned-genera-keys unassigned-console-keys))))

(defun-in-flavor (print-key-name x-console) (code &optional (stream *standard-output*))
  (format stream "~3,'0D " (keycode->keynum code))
  (format-textual-list
    (delete-duplicates
      (loop for j below (array-dimension (xlib::display-keyboard-mapping display) 1)
	    for keysym = (xlib:keycode->keysym display code j)
	    when (plusp keysym) collect keysym)
      :from-end t)
    #'(lambda (keysym stream)
	(format-textual-list
	  (mapcar #'string-capitalize-words (gethash keysym *keysym-name-table*))
	  #'princ
	  :stream stream)
	(format stream " (~3,'0D,~3,'0D)"
		(ldb (byte 8 8) keysym)
		(ldb (byte 8 0) keysym)))
    :separator "; "
    :stream stream))

(defmethod (x-console-describe-keyboard-mapping x-console)
	   (&key all (stream *standard-output*) match)
  (let ((layout-type (sys:keyboard-layout-type cli::keyboard)))
    (format stream "~2&The keyboard layout type is ~S.~%" layout-type)
    (unless (layout-type-keyboard-mapping layout-type)
      (format stream
	      "Since no specific key binding has deen defined for this layout type,~%")
      (format stream "  the default binding is being used.~%")))
  (format stream "~%")
  (multiple-value-bind
    (console-key-assignments unassigned-genera-keys unassigned-console-keys)
      (get-keyboard-mapping all match)
    (cond ((and (null console-key-assignments) (null match))
	   (format stream "Standard Genera keyboard mapping in effect."))
	  ((and (null console-key-assignments) match)
	   (format stream "There is no mapping for any Genera key that matches the substring ~S." match))
	  (t
	   (formatting-table (stream)
	     (formatting-row (stream)
	       (loop for string in '("Key" "Shift" "Symbol" "Symbol-Shift" "Console Key")
		     do (formatting-cell (stream) (princ string stream))))
	     (loop for (code . genera-keys) in console-key-assignments
		   do (formatting-row (stream)
			(loop for key in genera-keys
			      do (formatting-cell (stream) (when key (prin1 key stream))))
			(formatting-cell (stream) (print-key-name code stream)))))))
    (when (and match unassigned-genera-keys)
      (loop for genera-key in unassigned-genera-keys
	    when (string-search
		   match
		   (if (characterp genera-key)
		       (char-name genera-key)
		     (string genera-key)))
	      collect genera-key into matches
	    finally (setq unassigned-genera-keys matches)))
    (when unassigned-genera-keys
      (format stream "~2&No console keys map to the Genera key~P "
	      (length unassigned-genera-keys))
      (format-textual-list unassigned-genera-keys #'prin1
			   :filled t
			   :conjunction "and"
			   :after-line-break "   "
			   :stream stream)
      (format stream ".~%"))
    (when (and unassigned-console-keys (null match))
      (format stream "~2&No Genera keys map to the console key~P "
	      (length unassigned-genera-keys))
      (format-textual-list (nreverse unassigned-console-keys)
			   #'(lambda (code stream)
			       (format stream "[")
			       (print-key-name code stream)
			       (format stream "]"))
			   :filled t
			   :conjunction "and"
			   :after-line-break "   "
			   :stream stream)
      (format stream ".~%"))))

(defmethod (x-console-describe-font-mapping x-console) ()
  (x-display-device-describe-font-mapping display-device))

(defmethod (tv:remote-console-get-whole-screen-image x-console)
	   (&optional screen-number (full-depth-p nil))
  (declare (ignore screen-number))
  (let ((screen-width (xlib:screen-width screen))
	(screen-height (xlib:screen-height screen))
	(screen-depth (xlib:screen-root-depth screen)))
    (let ((raster (make-raster-array
		    screen-width screen-height
		    :element-type (if full-depth-p `(unsigned-byte ,screen-depth) 'bit))))
      (if (or full-depth-p (= screen-depth 1))
	  (tv:remote-get-image cli::screen boole-1 screen-width screen-height
			       root 0 0 raster 0 0)
	(tv:remote-read-1-bit-raster
	  cli::screen screen-width screen-height root 0 0 raster 0 0 nil))
      (values raster screen-width screen-height))))

(defmethod (dw:console-remote-program x-console) ()
  remote-program)

(defmethod (sys:console-kill-history x-console) ()
  (or kill-history
      (setq kill-history (make-instance 'x-cut-buffer-history :console self))))

(defmethod (sys:console-activate-screen-saver x-console) ()
  (sleep 2)
  (catch-network-errors ()
    (xlib:activate-screen-saver display)))

(defwhopper (sys:console-function-keys-enabled x-console) ()
  (let ((keys (continue-whopper)))
    (cond ((eq keys nil) nil)
	  ((eq function-keys-enabled nil) nil)
	  ((eq keys t) function-keys-enabled)
	  ((eq function-keys-enabled t) keys)
	  ((intersection keys function-keys-enabled :test #'char-equal)))))

(defwhopper (sys:console-select-keys-enabled x-console) ()
  (let ((keys (continue-whopper)))
    (cond ((eq keys nil) nil)
	  ((eq select-keys-enabled nil) nil)
	  ((eq keys t) select-keys-enabled)
	  ((eq select-keys-enabled t) keys)
	  ((intersection keys select-keys-enabled :test #'char-equal)))))

(defwhopper (sys:console-system-menu-enabled x-console) ()
  (and system-menu-enabled (continue-whopper)))



(defflavor x-main-console () (x-console cli::main-console))

(compile-flavor-methods x-console x-main-console)






(defflavor x-cut-buffer-history 
	(console (lock (process:make-lock "X Cut Buffer Lock")))
	(zwei:abbreviating-history)
  (:default-init-plist :name "X cut buffer" :maximum-length 8)
  (:initable-instance-variables console)
  (:required-init-keywords :console))

(defmethod (make-instance x-cut-buffer-history) (&rest ignore)
  (send self :reset))

(defmethod (:reset x-cut-buffer-history) ()
  (variable-makunbound zwei:list)
  (setq zwei:current-length 8 zwei:rotation 0 zwei:temporary-element nil))

(defun-in-flavor (prepare-element-for-storing x-cut-buffer-history) (element)
  (let ((string
	  (string-thin
	    (typecase element
	      (string element)
	      (zwei:interval (zwei:string-interval element))
	      (otherwise nil)))))
    (when (and string (not (string-fat-p string)))
      string)))

(defun-in-flavor (cut-buffer-write x-cut-buffer-history) (buffer string)
  (loop with display = (x-console-display console)
	with window = (xlib:screen-root (first (xlib:display-roots display)))
	with property = (aref '#(:cut_buffer0 :cut_buffer1
				 :cut_buffer2 :cut_buffer3
				 :cut_buffer4 :cut_buffer5
				 :cut_buffer6 :cut_buffer7)
			      buffer)
	with chunk-length = (* (- (xlib:display-max-request-length display) 6) 4)
	with length = (length string)
	for start first 0 then end
	for end = (+ start chunk-length)
	while (< start length)
	do (xlib:change-property
	     window property string :string 8
	     :start start
	     :end (and (< end length) end)
	     :mode (if (zerop start) :replace :append)
	     :transform #'xlib:char->card8)))

(defmethod (:push x-cut-buffer-history) (element)
  (let ((string (prepare-element-for-storing element)))
    (process:with-lock (lock)
      (when string
	(catch-network-errors ()
	  (xlib:rotate-cut-buffers (x-console-display console) -1 t)
	  (cut-buffer-write 0 string)))
      (setq zwei:rotation 0 zwei:temporary-element nil))))

(defmethod (:pop x-cut-buffer-history) ()
  (process:with-lock (lock)
    (xlib:rotate-cut-buffers (x-console-display console) 1 t)
    (xlib:cut-buffer (x-console-display console) :buffer 7)))

(defmethod (:replace-top x-cut-buffer-history) (element)
  (let ((string (prepare-element-for-storing element)))
    (process:with-lock (lock)
      (when string
	(catch-network-errors ()
	  (cut-buffer-write 0 string))))))

(defmethod (:element x-cut-buffer-history) (n &optional fixup-p &aux (delta 0))
  (declare (values element index))
  (process:with-lock (lock)
    (block nil
      (when zwei:temporary-element
	(when (or (zerop n) (and fixup-p (minusp n)))
	  (return (values zwei:temporary-element 0)))
	(decf n)
	(incf delta))
      (cond ((minusp n)
	     (values (and fixup-p (xlib:cut-buffer (x-console-display console))) delta))
	    ((< n 8)
	     (values (xlib:cut-buffer (x-console-display console) :buffer n) (+ n delta)))
	    (fixup-p
	     (values (xlib:cut-buffer (x-console-display console) :buffer 7) (+ 7 delta)))
	    (t nil)))))

(defmethod (:length x-cut-buffer-history) () (if zwei:temporary-element 9 8))

(defmethod (:set-maximum-length x-cut-buffer-history) (n) (declare (ignore n)))

(compile-flavor-methods x-cut-buffer-history)



(defflavor x-mouse-mixin () ()
  (:required-flavors tv:basic-mouse))

(defmethod (sys:print-self x-mouse-mixin) (stream print-depth slashify-p)
  (declare (ignore print-depth slashify-p))
  (sys:printing-random-object (self stream :typep)
    (write-string (x-console-name tv:console) stream)))

(defmethod (tv:mouse-process-initialize x-mouse-mixin :after) ()
  (setf (process-name (tv:mouse-process self)) (x-console-name tv:console "Mouse"))
  (process:set-process-base-priority
    (tv:mouse-process self) (process:make-process-priority :fg 8 :preemptive t)))

(defmethod (tv:mouse-process-shutdown x-mouse-mixin :before) ()
  (when (tv:mouse-process self)
    (setf (process-name (tv:mouse-process self)) "Mouse")
    (process:set-process-base-priority
      (tv:mouse-process self) (process:make-process-priority :fg 31 :preemptive t))))

(defmethod (tv:open-mouse-cursor x-mouse-mixin) () nil)

(defmethod (tv:close-mouse-cursor x-mouse-mixin) () nil)

(defmethod (tv:mouse-check-fast-tracking x-mouse-mixin) (ignore) nil)

(defmethod (tv:mouse-unlocked-check-fast-tracking x-mouse-mixin) (ignore ignore) nil)

(defmethod (tv:mouse-set-prepared-sheet x-mouse-mixin) (ignore ignore ignore ignore) nil)

(defmethod (tv:mouse-resume-tracking x-mouse-mixin) () nil)

(defmethod (tv:mouse-warp-1 x-mouse-mixin :after) (new-x new-y)
  (declare (ignore new-x new-y))
  (tv:remote-console-note-mouse-warp tv:console))

(defmethod (tv:remote-mouse-p x-mouse-mixin) () t)

(defmethod (tv:mouse-halt-fast-tracking x-mouse-mixin) ()
  (x-console-install-cursor tv:console nil))

(defmethod (tv:mouse-make-cursor x-mouse-mixin) (raster width height x-offset y-offset)
  (and (<= 0 x-offset) (<= 0 y-offset)
       (x-console-make-cursor tv:console raster width height x-offset y-offset)))

(defmethod (tv:mouse-free-cursor x-mouse-mixin) (cursor)
  (x-console-free-cursor tv:console cursor))

(defmethod (tv:mouse-fast-track x-mouse-mixin) (cursor ignore)
  (x-console-install-cursor tv:console cursor))

(defflavor x-primary-mouse ()
	   (x-mouse-mixin tv:primary-mouse-mixin tv:nonlocal-mouse-mixin tv:basic-mouse))

(defflavor x-secondary-mouse ()
	   (x-mouse-mixin tv:secondary-nonlocal-mouse-mixin tv:basic-mouse))

(compile-flavor-methods x-primary-mouse x-secondary-mouse)
