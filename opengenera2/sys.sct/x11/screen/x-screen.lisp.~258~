;;; -*- Base: 10; Package: X-SCREEN; Mode: LISP; Syntax: Common-lisp; Lowercase: T -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; From an original prototype by Bob Scheifler.  

;;; Principal contributers:  Charles Hornig of Symbolics, Chris Lindblad of
;;; ILA, and Bill York of ILA

(defflavor x-screen
	(gcontext
	 gcontext-values
	 graphics-gcontext graphics-gcontext-values
	 (last-saved-gcontext nil)
	 (gcontext-cache (make-hash-table :test #'equal))
	 (copy-area-gcontexts (make-array 16))
	 (color->aluf-cache (make-hash-table :test #'equal))
	 (pixel->color-cache (make-hash-table))
	 (raster->pixmap-cache (make-hash-table))
	 )
	()
  (:required-flavors tv:basic-remote-screen)
  :abstract-flavor
  :readable-instance-variables)

(eval-when (eval compile load)
  (defconstant
    *gcontext-components*
    '(
      :function :plane-mask :foreground :background
      :line-width :line-style :cap-style :join-style :fill-style
      :fill-rule :tile :stipple :ts-x :ts-y :font :subwindow-mode
      :exposures :clip-x :clip-y :clip-mask :dash-offset :dashes
      :arc-mode)))

(eval-when (eval compile load)
  (defconstant
    *gcontext-tests*
    '((:function eq) (:plane-mask eq) (:foreground eq) (:background eq)
      (:line-width eq) (:line-style eq) (:cap-style eq) (:join-style eq)
      (:fill-style eq) (:fill-rule eq) (:tile eq) (:stipple eq) (:ts-x eq)
      (:ts-y eq) (:font eq) (:subwindow-mode eq) (:exposures eq) (:clip-x eq)
      (:clip-y eq) (:clip-mask clip-mask-equal) (:dash-offset eq)
      (:dashes equal) (:arc-mode eq))))

(eval-when (eval compile load)
  (defconstant
    *gcontext-copiers*
    '((:function progn) (:plane-mask progn) (:foreground progn) (:background progn)
      (:line-width progn) (:line-style progn) (:cap-style progn) (:join-style progn)
      (:fill-style progn) (:fill-rule progn) (:tile progn) (:stipple progn) (:ts-x progn)
      (:ts-y progn) (:font progn) (:subwindow-mode progn) (:exposures progn) (:clip-x progn)
      (:clip-y progn) (:clip-mask copy-if-necessary) (:dash-offset progn)
      (:dashes copy-if-necessary) (:arc-mode progn))))

(defsubst copy-if-necessary (object)
  (declare lt:(side-effects reader))
  (cond ((keywordp object) object)
	((typep object 'fixnum) object)
	(t (sys:copy-if-necessary object))))

(defsubst clip-mask-equal (x y)
  (cond ((atom x) (eql x y))
	((listp y)
	 (and (eql (pop x) (pop y))
	      (eql (pop x) (pop y))
	      (eql (pop x) (pop y))
	      (eql (pop x) (pop y))))))

(defmacro set-gcontext ((gcontext gcontext-values) &body plist &environment env)
  (declare (arglist (gcontext gcontext-values) &key 
		    function plane-mask foreground background
		    line-width line-style cap-style join-style fill-style
		    fill-rule tile stipple ts-x ts-y font subwindow-mode
		    exposures clip-x clip-y clip-mask dash-offset dashes
		    arc-mode))
  `(let ((gcontext ,gcontext)
	 (gcontext-values ,gcontext-values))
     (declare (sys:array-register gcontext gcontext-values))
     ,@(loop for (ind val) on plist by #'cddr
	     for position = (position ind *gcontext-components*)
	     for test = (second (assoc ind *gcontext-tests*))
	     for copier = (second (assoc ind *gcontext-copiers*))
	     for accessor = (intern (string-append "GCONTEXT-" (symbol-name ind)) "XLIB")
	     if (null position)
	       do (warn "Unknown gcontext component ~S" ind)
	     else
	       collect
		 (once-only (val &environment env)
		   `(unless (or (eq ,val :dont-care)
				(,test ,val (aref gcontext-values ,position)))
		      (setf (aref gcontext-values ,position) nil)
		      (setf (,accessor gcontext) ,val)
		      (setf (aref gcontext-values ,position) (,copier ,val)))))))

(defmethod (:activate x-screen :before) ()
  (when (tv:screen-has-blinker-timer-p self)
    (setf (process-name tv:blinker-process) (x-console-name tv:console "Blinkers"))
    (setf (process:timer-name tv:blinker-timer) (x-console-name tv:console "Blinkers")))
  (clrhash color->aluf-cache)
  (clrhash pixel->color-cache)
  (clrhash raster->pixmap-cache)
  (flet ((make-alu (data)
	   (setf data (sys:%logldb (byte tv:depth 0) data))
	   (cond ((zerop data)
		  boole-andc1)
		 ((= -1 (sys:%logdpb data (byte tv:depth 0) -1))
		  boole-ior)
		 (t
		  (color:sc-fill-alu data -1)))))
    (setf tv:char-aluf (make-alu (x-console-foreground tv:console)))
    (setf tv:erase-aluf (make-alu (x-console-background tv:console))))
  (setq tv:display-device-type (x-console-display-device tv:console))
  (send self :update-current-timestamp)
  (tv:sheet-resolve-inferior-time-stamps self)
  nil)

(defmethod (:expose x-screen :before) (&rest ignore)
  (unless (and (variable-boundp gcontext)
	       (eq (xlib::gcontext-drawable gcontext) tv:root-drawable))
    (setq last-saved-gcontext nil)
    (fill copy-area-gcontexts nil)
    (setq graphics-gcontext-values (make-array (length *gcontext-components*)))
    (setq graphics-gcontext (xlib:create-gcontext :drawable tv:root-drawable))
    (setq gcontext-values (make-array (length *gcontext-components*)))
    (setq gcontext (xlib:create-gcontext :drawable tv:root-drawable))))

(defmethod (:user-visible x-screen) ()
  (and tv:console
       (not (eq (x-console-window-visibility tv:console) :fully-obscured))))

(defmethod (tv:screen-has-focus-p x-screen) ()
  (and tv:console (x-console-have-focus-p tv:console)))

(defvar *allocate-pixmaps-for-temporary-bit-arrays* t
  "Whether to use remote X pixmaps for temporary bitmaps.
If this variable is non-NIL, then Genera will use pixmaps on the X server
for its temporary bitmaps, up to the limit of X server memory.  If this variable
is NIL, Genera will never use pixmaps for temporary bitmaps.  Because some
X servers, particularly X terminals with limited memory, fail gracelessly when
they near memory exhaustion, some users may wish to set this to NIL; note that
this can impose a performance penalty, particularly on color X servers.")

(defmethod (tv:%screen-allocate-sheet-temporary-bit-array x-screen) (sheet width height)
  (when *allocate-pixmaps-for-temporary-bit-arrays*
    (let* ((asynchronous-error-p nil)
	   (display (x-console-display tv:console))
	   (error-handler (xlib:display-error-handler display)))
      (flet ((pixmap-asynchronous-error-handler (error-display error-key &rest key-vals)
	       (if (and (eq error-display display) (eq error-key 'xlib::alloc-error))
		   (setf asynchronous-error-p t)
		   (apply error-handler error-display error-key key-vals))))
	(when (and (plusp width)
		   (plusp height))
	  (xlib:display-finish-output display)
	  (unwind-protect
	      (progn
		(setf (xlib:display-error-handler display) #'pixmap-asynchronous-error-handler)
		(let ((pixmap (xlib:create-pixmap :width width :height height :depth tv:depth
						  :drawable tv:root-drawable)))
		  (xlib:display-finish-output display)
		  (unless asynchronous-error-p
		    (setf (gethash (xlib:drawable-id pixmap)
				   (x-console-pixmap-validity-table tv:console))
			  (list :sheet sheet))
		    pixmap)))
	    (setf (xlib:display-error-handler display) error-handler)))))))

(defmethod (tv:%screen-deallocate-sheet-temporary-bit-array x-screen) (sheet pixmap)
  (declare (ignore sheet))
  (when (and tv:console
	     (remhash (xlib:drawable-id pixmap) (x-console-pixmap-validity-table tv:console)))
    (catch-network-errors ()
      (xlib:free-pixmap pixmap))))

(defmethod (tv:screen-permits-bit-save-arrays x-screen) ()
  (and tv:console (xlib:screen-save-unders-p (x-console-screen tv:console))))

(defmethod (tv:verify-drawable x-screen) (pixmap sheet direction)
  (declare (ignore sheet direction))
  (and tv:console
       (xlib:drawable-p pixmap)
       (let ((entry (gethash (xlib:drawable-id pixmap)
			     (x-console-pixmap-validity-table tv:console))))
	 (and (null (getf entry :errors))
	      (setf (getf entry :verified) t)))
       :remote))

(defsubst x-pixel-from-fixnum (value)
  (cond ((not (minusp value)) value)
	((= value -1) (ldb (byte 32 0) -1))
	(t (ldb (byte 32 0) value))))

(defsubst-in-flavor (pixel->aluf x-screen) (pixel)
  (let ((mask (lsh -1 (- tv:depth 32))))
    (setf pixel (logand pixel mask))
    (cond ((zerop pixel)
	   boole-andc1)
	  ((= -1 (logorc2 pixel mask))
	   boole-ior)
	  (t
	   (color:sc-fill-alu pixel -1)))))

(defsubst-in-flavor (aluf->pixel x-screen) (aluf)
  (select aluf
    (boole-andc1 0)
    (boole-ior (lsh -1 (- tv:depth 32)))
    (otherwise (send aluf :fill-data))))

(defmethod (color:%screen-inferior-color-p x-screen) (sheet)
  (declare (ignore sheet))
  (and (< 1 tv:depth) :local))

(defmethod (:compute-rgb-alu x-screen) (ignore &rest rgb)
  (or (gethash rgb color->aluf-cache)
      (let* ((r (pop rgb)) (g (pop rgb)) (b (pop rgb))
	     (rgb (list r g b))
	     (pixel (sys:%logldb (byte 32 0)
				 (xlib:alloc-color
				   (x-console-colormap tv:console)
				   (xlib:make-color :red r :green g :blue b)))))
	(setf (gethash pixel pixel->color-cache) rgb)
	(setf (gethash rgb color->aluf-cache) (pixel->aluf pixel)))))

(defmethod (:flonum-rgb-for-color x-screen) (aluf)
  (let* ((pixel (aluf->pixel aluf))
	 (color (gethash pixel pixel->color-cache)))
    (if color
	(color:color-rgb color)
	(multiple-value-bind (r g b)
	    (xlib:color-rgb (first (xlib:query-colors (x-console-colormap tv:console)
						      (list (x-pixel-from-fixnum pixel)))))
	  (setf (gethash (list r g b) color->aluf-cache) aluf)
	  (setf (gethash pixel pixel->color-cache) (color:make-standard-color :rgb r g b))
	  (values r g b)))))

(defmethod (:read-screen-map x-screen) (&optional map map-segment map-image)
  (declare (ignore map-segment map-image))
  (case (xlib:visual-info-class (x-console-visual-info tv:console))
    ((:static-gray :static-color :gray-scale :pseudo-color)
     (let ((ncolors (ash 1 tv:depth)))
       (send map :set-size ncolors)
       (let ((colors (stack-let ((pixels (make-array ncolors)))
		       (dotimes (i ncolors)
			 (setf (aref pixels i) i))
		       (xlib:query-colors (x-console-colormap tv:console) pixels
					  :result-type 'vector))))
	 (dotimes (i ncolors)
	   (multiple-value-bind (r g b)
	       (xlib:color-rgb (aref colors i))
	     (send map :write-color-map i r g b))))))))

(defmethod (:default-inferior-alufs x-screen) ()
  (values tv:char-aluf tv:erase-aluf
	  (send self :exchange-two-colors-aluf tv:char-aluf tv:erase-aluf)))

(defmethod (:exchange-two-colors-aluf x-screen) (old-1 old-2)
  (when (or (and (eql old-1 boole-andc1) (eql old-2 boole-ior))
	    (and (eql old-1 boole-ior) (eql old-2 boole-andc1)))
    (return-from :exchange-two-colors-aluf boole-xor))
  (flet ((decode-alu (alu)
	   (etypecase alu
	     (integer
	       (select alu
		 ((boole-ior boole-set boole-1) (values boole-1 -1 -1))
		 ((boole-andc1 boole-clr boole-c1) (values boole-1 0 -1))
		 (otherwise (values alu -1 -1))))
	     (instance
	       (multiple-value-bind (nil mask nil data alu)
		   (send alu :sc-parameters self)
		 (values alu data mask))))))
    (multiple-value-bind (old-1-alu old-1-data old-1-mask)
	(decode-alu old-1)
      (multiple-value-bind (old-2-alu old-2-data old-2-mask)
	  (decode-alu old-2)
	(assert (and (= old-1-alu boole-1) (= old-2-alu boole-1)))
	(let ((fill (sys:%logldb (byte tv:depth 0)
				 (logxor (logand old-1-data old-1-mask)
					 (logand old-2-data old-2-mask))))
	      (ones (sys:%logdpb -1 (byte tv:depth 0) 0)))
	  (if (= fill ones)
	      boole-xor
	      (make-instance 'color:general-sc-color-alu
			     :alu tv:alu-xor
			     :fill-data fill
			     :plane-mask -1
			     :array :default)))))))

(defun-in-flavor (x-copy-area-gc x-screen) (alu)
  (or (aref copy-area-gcontexts alu)
      (setf (aref copy-area-gcontexts alu)
	    (xlib:create-gcontext :drawable tv:root-drawable
				  :function alu
				  :clip-mask :none
				  :plane-mask (x-pixel-from-fixnum -1)
				  :exposures :off))))

(defmethod (tv:remote-copy-area x-screen)
	   (alu w h from-drawable from-x from-y to-drawable to-x to-y
		&optional (fill-data -1) (plane-mask -1))
  (declare (ignore fill-data plane-mask))
  (catch-network-errors ()
    (xlib:copy-area from-drawable (x-copy-area-gc alu) from-x from-y w h to-drawable to-x to-y)
    (tv:remote-console-note-pending-output tv:console)))

(defmethod (tv:remote-tile-area x-screen)
	   (alu w h tile tile-x tile-y tile-width tile-height tile-x-offset tile-y-offset
		drawable to-x to-y &optional (fill-data -1) (plane-mask -1))
  (declare (ignore fill-data plane-mask))
  (catch-network-errors ()
    (set-gcontext (gcontext gcontext-values)
      :function alu
      :clip-mask :none)
    (cond ((and (= tile-x 0) (- tile-y 0)
		(xlib:pixmap-p tile))
	   (set-gcontext (gcontext gcontext-values)
	     :fill-style :tiled
	     :tile tile
	     :ts-x (- to-x tile-x-offset)
	     :ts-y (- to-y tile-y-offset))
	   (xlib:draw-rectangle drawable gcontext to-x to-y w h t))
	  (t
	   (error "Not yet implemented.")))
    (tv:remote-console-note-pending-output tv:console)))

(defwhopper (tv:remote-read-1-bit-raster x-screen)
	    (w h drawable from-x from-y to-array to-x to-y sheet &rest args)
  (let ((read-pixel-function (first args)))
    (catch-network-errors ()
      (if (and (> tv:depth 1) (member read-pixel-function '(nil :zero :nonzero)))
	  ;; Let the server do all the work
	  (multiple-value-bind (data sense)
	      (ecase read-pixel-function
		((nil) (values (x-console-background tv:console) nil))
		(:zero (values 0 t))
		(:nonzero (values 0 nil)))
	    (with-pixmap ((rpm rgc) w h 1 drawable :foreground (if sense 1 0))
	      ;; Start with rpm all ones if we are sensing true, zeros if
	      ;; false
	      (xlib:draw-rectangle rpm rgc 0 0 w h t)
	      ;; Read the 1-bit raster into rpm, using and for each matching
	      ;; plane if sensing true, orc1 if false
	      (setf (xlib:gcontext-function rgc) (if sense boole-and boole-orc1))
	      (with-pixmap ((ppm pgc) w h 1 drawable)
		(dotimes (plane tv:depth)
		  (let ((mask (lsh 1 plane))
			(fg (if (logbitp plane data) 1 0)))
		    (setf (xlib:gcontext-foreground pgc) fg
			  (xlib:gcontext-background pgc) (- 1 fg))
		    (xlib:copy-plane drawable pgc mask from-x from-y w h ppm 0 0)
		    (xlib:copy-area ppm rgc 0 0 w h rpm 0 0))))
	      ;; Now copy rpm into to-array
	      (if (and (zerop to-x) (zerop to-y))
		  (xlib:get-image rpm :x 0 :y 0 :width w :height h :format :z-pixmap
				  :data to-array)
		(stack-let* ((sw (sys:%fixnum-multiply (sys:%fixnum-ceiling w 32) 32))
			     (dims (list h sw)))
		  (tv:with-temp-sheet-raster (data dims :type (sys:array-type to-array))
		    (xlib:get-image rpm :x 0 :y 0 :width w :height h :format :z-pixmap
				    :data data)
		    (bitblt boole-1 w h data 0 0 to-array to-x to-y))))))
	;; Use the default mechanism
	(lexpr-continue-whopper w h drawable from-x from-y to-array to-x to-y sheet args)))))

(defmethod (tv:remote-get-image x-screen)
	   (alu w h from-drawable from-x from-y to-array to-x to-y)
  (catch-network-errors ()
    (if (and (= alu boole-1) (zerop to-x) (zerop to-y))
	(xlib:get-image from-drawable :x from-x :y from-y :format :z-pixmap
			:width w :height h :data to-array)
      (stack-let* ((type (sys:array-type to-array))
		   (dims (list h (tv:raster-width-for-bitblt w type))))
	(tv:with-temp-sheet-raster (data dims :type type)
	  (xlib:get-image from-drawable :x from-x :y from-y :format :z-pixmap
			  :width w :height h :data data)
	  (bitblt alu w h data 0 0 to-array to-x to-y))))))

(defmethod (tv:remote-put-image x-screen)
	   (alu w h from-array from-x from-y to-drawable to-x to-y
		&optional fill-data plane-mask)
  (declare (ignore fill-data plane-mask))
  (catch-network-errors ()
    (set-gcontext (gcontext gcontext-values)
      :function alu
      :plane-mask (x-pixel-from-fixnum -1)
      :clip-mask :none)
    (multiple-value-bind (swidth sheight) (decode-raster-array from-array)
      (cond ((and (<= 0 from-x) (<= (+ from-x w) swidth)
		  (<= 0 from-y) (<= (+ from-y h) sheight))
	     ;; If the bitblt source rectangle is contained completely in the source array,
	     ;; just draw the subrectangle of the array.
	     (set-gcontext (gcontext gcontext-values)
	       :fill-style :solid)
	     (xlib:put-image
	       to-drawable gcontext
	       (xlib:create-image :width (+ from-x w) :height (+ from-y h) :depth tv:depth
				  :data from-array)
	       :src-x from-x :src-y from-y :x to-x :y to-y :width w :height h))
	    (t
	     ;; Otherwise, send the whole source array across and draw it in tiled mode.
	     (with-pixmap ((tile tile-gc) swidth sheight tv:depth to-drawable
			   :function boole-1)
	       (xlib:put-image
		 tile tile-gc
		 (xlib:create-image :width swidth :height sheight :depth tv:depth
				    :data from-array)
		 :x 0 :y 0 :width swidth :height sheight)
	       (set-gcontext (gcontext gcontext-values)
		 :fill-style :tiled
		 :tile tile
		 :ts-x (- to-x from-x)
		 :ts-y (- to-y from-y))
	       (xlib:draw-rectangle to-drawable gcontext to-x to-y w h t)))))
    (tv:remote-console-note-pending-output tv:console)))

(defmethod (tv:remote-draw-1-bit-raster x-screen)
	   (w h pattern from-x from-y to-drawable to-x to-y
	      o-boole o-data o-mask z-boole z-data z-mask)
  (unless (and (= o-boole boole-2) (= z-boole boole-2))
    (catch-network-errors ()
      (let* ((image (xlib:create-image :data pattern))
	     (swidth (xlib:image-width image))
	     (sheight (xlib:image-height image)))
	(cond ((and (= o-boole z-boole) (= o-mask z-mask)
		    (<= 0 from-x) (<= 0 from-y)
		    (<= 0 w) (<= 0 h)
		    (<= (+ from-x w) swidth) (<= (+ from-y h) sheight))
	       ;; Use put-image in the special case when we can
	       (set-gcontext (gcontext gcontext-values)
		 :function o-boole
		 :plane-mask (x-pixel-from-fixnum o-mask)
		 :foreground (x-pixel-from-fixnum o-data)
		 :background (x-pixel-from-fixnum z-data)
		 :clip-mask :none)
	       (xlib:put-image to-drawable gcontext image :bitmap-p t :width w :height h
			       :x to-x :y to-y :src-x from-x :src-y from-y))
	      (t
	       ;; Use a stipple in the general case
	       (let ((put-boole boole-1))
		 (when (= o-boole boole-2)
		   (setf o-boole z-boole)
		   (setf o-data z-data)
		   (setf o-mask z-mask)
		   (setf z-boole boole-2)
		   (setf put-boole boole-c1))
		 (with-pixmap ((stipple stipple-gc) swidth sheight 1 to-drawable
			       :function put-boole)
		   ;; Fill in the stipple
		   (xlib:put-image stipple stipple-gc image :x 0 :y 0
				   :width swidth :height sheight)
		   ;; Do the ones.  Also the zeros if the alus and masks are the same.
		   (set-gcontext (gcontext gcontext-values)
		     :fill-style (if (and (= o-boole z-boole) (= o-mask z-mask))
				     :opaque-stippled :stippled)
		     :function o-boole
		     :stipple stipple
		     :ts-x (- to-x from-x) :ts-y (- to-y from-y)
		     :plane-mask (x-pixel-from-fixnum o-mask)
		     :foreground (x-pixel-from-fixnum o-data)
		     :background (x-pixel-from-fixnum z-data)
		     :clip-mask :none)
		   (xlib:draw-rectangle to-drawable gcontext to-x to-y w h t)
		   ;; Do the zeros if the alus and masks aren't the same and the zeros
		   ;; alu isn't a noop.
		   (unless (or (and (= o-boole z-boole) (= o-mask z-mask))
			       (= z-boole boole-2))
		     (with-pixmap ((inverted-stipple) swidth sheight 1 to-drawable)
		       (setf (xlib:gcontext-function stipple-gc) boole-c1)
		       (xlib:copy-area stipple stipple-gc 0 0 swidth sheight
				       inverted-stipple 0 0)
		       ;; Now draw the inverted stipple into the window in zeros-alu
		       (set-gcontext (gcontext gcontext-values)
			 :function z-boole
			 :stipple inverted-stipple
			 :plane-mask (x-pixel-from-fixnum z-mask)
			 :foreground (x-pixel-from-fixnum z-data))
		       (xlib:draw-rectangle to-drawable gcontext to-x to-y w h t))))))))
      (tv:remote-console-note-pending-output tv:console)))
  nil)

(defmethod (tv:remote-draw-line x-screen)
	   (drawable x1 y1 x2 y2 alu fill-data plane-mask draw-end-point)
  (catch-network-errors ()
    (set-gcontext (gcontext gcontext-values)
      :fill-style :solid
      :line-style :solid
      :cap-style (if draw-end-point :butt :not-last)
      :clip-mask :none
      :function alu
      :foreground (x-pixel-from-fixnum fill-data)
      :plane-mask (x-pixel-from-fixnum plane-mask))
    (xlib:draw-line drawable gcontext x1 y1 x2 y2)
    (unless draw-end-point
      (xlib:draw-point drawable gcontext x1 y1))
    (tv:remote-console-note-pending-output tv:console)
    nil))

(defmethod (tv:remote-draw-multiple-lines x-screen)
	   (drawable lines draw-end-point alu fill-data plane-mask)
  (catch-network-errors ()
    (set-gcontext (gcontext gcontext-values)
      :fill-style :solid
      :line-style :solid
      :cap-style (if draw-end-point :butt :not-last)
      :clip-mask :none
      :function alu
      :foreground (x-pixel-from-fixnum fill-data)
      :plane-mask (x-pixel-from-fixnum plane-mask))
    (xlib:draw-segments drawable gcontext lines)
    (unless draw-end-point
      (xlib:draw-point drawable gcontext (aref lines 0) (aref lines 1)))
    (tv:remote-console-note-pending-output tv:console)
    nil))

(defmethod (tv:remote-draw-point x-screen) (drawable x y alu fill-data plane-mask)
  (catch-network-errors ()
    (set-gcontext (gcontext gcontext-values)
      :fill-style :solid
      :clip-mask :none
      :function alu
      :foreground (x-pixel-from-fixnum fill-data)
      :plane-mask (x-pixel-from-fixnum plane-mask))
    (xlib:draw-point drawable gcontext x y)
    (tv:remote-console-note-pending-output tv:console)
    nil))

(defmethod (tv:remote-read-point x-screen) (drawable x y)
  (stack-let* ((data8 (make-array 4 :element-type '(unsigned-byte 8)))
	       (data (make-array 1 :element-type 'fixnum :displaced-to data8)))
    (xlib:get-raw-image drawable :data data8 :x x :y y :width 1 :height 1 :format :z-pixmap)
    (ldb (byte tv:depth 0) (aref data 0))))

(defmethod (tv:remote-draw-rectangle x-screen) (w h drawable x y alu fill-data plane-mask)
  (when (and (plusp w) (plusp h))
    (catch-network-errors ()
      ;; If the rectangle is gonna be the background color, use the (faster)
      ;; clear area operation.
      (let ((foreground (x-pixel-from-fixnum fill-data)))
	(cond ((and (= plane-mask -1)
		    (xlib:window-p drawable)
		    (or (and (= alu boole-1)
			     (= foreground (x-console-background tv:console)))
			(and (= alu boole-andc1) (= fill-data -1)
			     (zerop (x-console-background tv:console)))))
	       (xlib:clear-area drawable :x x :y y :width w :height h))
	      (t
	       (set-gcontext (gcontext gcontext-values)
		 :fill-style :solid
		 :clip-mask :none
		 :function alu
		 :foreground foreground
		 :plane-mask (x-pixel-from-fixnum plane-mask))
	       (xlib:draw-rectangle drawable gcontext x y w h t))))
      (tv:remote-console-note-pending-output tv:console)))
  nil)

(defmethod (tv:remote-draw-multiple-rectangles x-screen)
	   (drawable rectangles alu fill-data plane-mask)
  (catch-network-errors ()
    (set-gcontext (gcontext gcontext-values)
      :fill-style :solid
      :clip-mask :none
      :function alu
      :foreground (x-pixel-from-fixnum fill-data)
      :plane-mask (x-pixel-from-fixnum plane-mask))
    (let ((rectangles rectangles))
      (declare (sys:array-register rectangles))
      (stack-let ((rects (make-array (length rectangles))))
	(declare (sys:array-register rects))
	(loop for i below (length rectangles) by 4 do
	  (let* ((x (aref rectangles (+ i 0)))
		 (y (aref rectangles (+ i 1)))
		 (w (- (aref rectangles (+ i 2)) x))
		 (h (- (aref rectangles (+ i 3)) y)))
	    (when (minusp h) (incf y h) (setf h (- h)))
	    (when (minusp w) (incf x w) (setf w (- w)))
	    (setf (aref rects (+ i 0)) x)
	    (setf (aref rects (+ i 1)) y)
	    (setf (aref rects (+ i 2)) w)
	    (setf (aref rects (+ i 3)) h)))
	(xlib:draw-rectangles drawable gcontext rects t)
	(tv:remote-console-note-pending-output tv:console)
	nil))))

(defmethod (tv:remote-draw-triangle x-screen)
	   (drawable x1 y1 x2 y2 x3 y3 alu fill-data plane-mask limits)
  (catch-network-errors ()
    (destructuring-bind (left top right bottom) limits
      (stack-let ((clip-mask (list left top (- right left) (- bottom top))))
	(set-gcontext (gcontext gcontext-values)
	  :function alu
	  :foreground (x-pixel-from-fixnum fill-data)
	  :plane-mask (x-pixel-from-fixnum plane-mask)
	  :fill-style :solid
	  :clip-mask clip-mask)))
    (stack-let ((points (list x1 y1 x2 y2 x3 y3 x1 y1)))
      (xlib:draw-lines drawable gcontext points :fill-p t :shape :convex))
    (tv:remote-console-note-pending-output tv:console)
    nil))

(defun-in-flavor (draw-pixmap-glyph x-screen) (drawable index font x y)
  (let* ((it (tv:font-indexing-table font))
	 (sheight (tv:font-raster-height font))
	 (swidth (tv:font-raster-width font))
	 (floor (sys:%fixnum-floor index *pixmap-font-glyphs-per-line*))
	 (base (sys:%fixnum-multiply floor *pixmap-font-glyphs-per-line*))
	 (mod (sys:%fixnum-mod index *pixmap-font-glyphs-per-line*))
	 (sy (* floor sheight)))
    (multiple-value-bind (sx swidth)
	(if it
	    (values (- (aref it index) (aref it base)) 
		    (- (aref it (1+ index)) (aref it index)))
	  (values (* mod swidth)
		  swidth))
      (set-gcontext (gcontext gcontext-values)
	:ts-x (- x sx)
	:ts-y (- y sy))
      (xlib:draw-rectangle drawable gcontext x y swidth sheight t))))

(defmethod (tv:remote-draw-glyph x-screen) (index font drawable x y
						  alu fill-data plane-mask limits)
  (catch-network-errors ()
    (destructuring-bind (left top right bottom) limits
      (stack-let ((clip-mask (list left top (- right left) (- bottom top))))
	(set-gcontext (gcontext gcontext-values)
	  :function alu
	  :foreground (x-pixel-from-fixnum fill-data)
	  :plane-mask (x-pixel-from-fixnum plane-mask)
	  :clip-mask clip-mask)))
    (multiple-value-bind (xfopm index)
	(x-display-device-indexed-xfopm-lookup tv:display-device-type font index)
      (etypecase xfopm
	;; If we have a real X font, use CLX glyph-drawing.
	(xlib:font
	  (set-gcontext (gcontext gcontext-values)
	    :fill-style :solid
	    :font xfopm)
	  (xlib:draw-glyph
	    drawable gcontext
	    x (+ y (tv:font-baseline font))
	    index :translate #'singular-identity-translate))
	;; Otherwise, we are "simulating" X fonts.
	(xlib:pixmap
	  (let ((tvfont (getf (xlib:pixmap-plist xfopm) 'tv:font)))
	    (when (and (< index (tv:font-fill-pointer tvfont))
		       (let ((cet (tv:font-chars-exist-table tvfont)))
			 (or (null cet) (aref cet index))))
	      (set-gcontext (gcontext gcontext-values)
		:fill-style :stippled
		:stipple xfopm)
	      (draw-pixmap-glyph drawable index tvfont x y))))))
    (tv:remote-console-note-pending-output tv:console)
    nil))

(defmethod (tv:remote-draw-glyphs x-screen)
	   (string index limit font drawable x y alu fill-data plane-mask limits)
  (when (< index limit)
    (catch-network-errors ()
      (destructuring-bind (left top right bottom) limits
	(stack-let ((clip-mask (list left top (- right left) (- bottom top))))
	  (set-gcontext (gcontext gcontext-values)
	    :function alu
	    :foreground (x-pixel-from-fixnum fill-data)
	    :plane-mask (x-pixel-from-fixnum plane-mask)
	    :clip-mask clip-mask)))
      (loop 
	(multiple-value-bind (xfopm ignore xfopm-vector index-vector)
	    (let ((char (aref string index)))
	      (multiple-value-bind (ignore index) (si:char-char-set-and-index char)
		(x-display-device-indexed-xfopm-lookup tv:display-device-type font index)))
	  (multiple-value-bind (new-index width)
	      (etypecase xfopm
		(xlib:font
		  (set-gcontext (gcontext gcontext-values)
		    :fill-style :solid
		    :font xfopm)
		  (xlib:draw-glyphs
		    drawable gcontext
		    x (+ y (tv:font-baseline font))
		    string :start index :end limit
		    :size (if (< (xlib:font-max-char xfopm) 256) 8 16)
		    :translate
		    #'(lambda (src src-start src-end font dst dst-start)
			(declare (sys:downward-function))
			(translate src src-start src-end font dst dst-start
				   xfopm-vector index-vector))))
		(xlib:pixmap
		  (set-gcontext (gcontext gcontext-values)
		    :fill-style :stippled
		    :stipple xfopm)
		  (stack-let* ((tvfont (getf (xlib:pixmap-plist xfopm) 'tv:font))
			       (glyphs
				 (sys:make-array 
				   (- limit index)
				   :type (if (<= (tv:font-fill-pointer tvfont) 256)
					     'sys:art-8b 'sys:art-16b))))
		    (declare (sys:array-register glyphs))
		    (loop with width = 0
			  with limit = (translate string index limit xfopm glyphs 0
						  xfopm-vector index-vector)
			  with cw = (tv:font-char-width tvfont)
			  with cwt = (tv:font-char-width-table tvfont)
			  for i below (- limit index)
			  for glyph = (aref glyphs i)
			  do (draw-pixmap-glyph drawable glyph tvfont (+ x width) y)
			     (incf width (if cwt (aref cwt glyph) cw))
			  finally (return (values limit width))))))
	    (when (or (null new-index) (= new-index limit))
	      (return))
	    (when (null width)
	      (stack-let* ((length (- new-index index))
			   (indices (make-array length :element-type '(unsigned-byte 16))))
		(translate string index new-index nil indices 0 nil nil)
		(setq width (tvfont-text-width font indices length))))
	    (setq index new-index x (+ x width)))))
      (tv:remote-console-note-pending-output tv:console))))

(defmethod (tv:remote-warp-mouse x-screen) (x y)
  (x-console-warp-pointer tv:console tv:root-drawable x y))

(defmethod (x-screen-cache-raster-pixmap x-screen) (raster)
  (let ((table (x-console-pixmap-validity-table tv:console)))
    (let ((pixmap (gethash raster raster->pixmap-cache)))
      (when pixmap
	(let ((id (xlib:pixmap-id pixmap)))
	  (cond ((null (getf (gethash id table) :errors))
		 (return-from x-screen-cache-raster-pixmap pixmap))
		(t
		 (unwind-protect 
		     (catch-network-errors ()
		       (xlib:free-pixmap pixmap))
		   (remhash raster raster->pixmap-cache)
		   (remhash id table)))))))
    (setf (gethash raster raster->pixmap-cache)
	  (multiple-value-bind (width height) (tv:decode-raster-array raster)
	    (with-pixmap ((pm gc) width height
			  (or (sys:array-bits-per-element (sys:array-type-field raster))
			      tv:depth)
			  tv:root-drawable :function boole-1)
	      (xlib:put-image pm gc (xlib:create-image :data raster) :x 0 :y 0)
	      (setf (gethash (xlib:pixmap-id pm) table) (list :raster raster))
	      (shiftf pm nil))))))

(defstruct (saved-gcontext (:type vector) :named (:copier nil) (:predicate nil)
			   (:constructor make-saved-gcontext ()))
  (background :dont-care)
  (cap-style :dont-care)
  (dash-offset :dont-care)
  (dashes :dont-care)
  (fill-style :dont-care)
  (foreground :dont-care)
  (function :dont-care)
  (join-style :dont-care)
  (line-style :dont-care)
  (line-width :dont-care)
  (plane-mask :dont-care)
  (pixmap :dont-care))
  
(defmethod (x-save-graphics-state graphics::raster-drawing-state) (stream table)
  (stack-let ((key (list graphics::thickness
			 graphics::scale-thickness
			 graphics::line-end-shape
			 graphics::line-joint-shape
			 graphics::dashed
			 graphics::dash-pattern
			 graphics::initial-dash-phase
			 graphics::scale-dashes
			 graphics::alu
			 graphics::pattern
			 graphics::stipple
			 graphics::tile
			 graphics::gray-level
			 graphics::color
			 graphics::opaque)))
    (or (gethash key table)
	(multiple-value-bind (pattern ones-alu zeros-alu)
	    (graphics::drawing-state-source-and-alu self stream)
	  (and (not (instancep pattern))
	       (setf (gethash (copy-list key) table)
		     (block gcontext 
		       (let ((gcontext (make-saved-gcontext)))
			 (declare (sys:array-register gcontext))
			 (sys:with-data-stack
			   (setf (saved-gcontext-line-width gcontext)
				 (ceiling (graphics::drawing-state-scaled-thickness self)))
			   (setf (saved-gcontext-cap-style gcontext)
				 (ecase graphics::line-end-shape
				   (:butt :butt)
				   (:square :projecting)
				   (:round :round)
				   (:no-end-point :not-last)))
			   (setf (saved-gcontext-join-style gcontext)
				 (ecase graphics::line-joint-shape
				   (:miter :miter)
				   ((:bevel :none) :bevel)
				   (:round :round)))
			   (multiple-value-bind (dashed pattern phase partial-dashes)
			       (graphics::drawing-state-scaled-dash-pattern self)
			     partial-dashes
			     (cond ((null dashed)
				    (setf (saved-gcontext-line-style gcontext) :solid))
				   (t
				    (setf (saved-gcontext-line-style gcontext) :dash)
				    (let ((dashes
					    (loop for i below (length pattern)
						  for elt = (elt pattern i)
						  for floor = (floor elt)
						  for ceiling = (ceiling elt)
						  unless (and ( 0 floor 255)
							      (= floor ceiling))
						    do (return-from gcontext nil)
						  collect floor)))
				      (cond ((and (= (length dashes) 2)
						  (= (first dashes) (second dashes)))
					     (setf (saved-gcontext-dash-offset gcontext) 0)
					     (setf (saved-gcontext-dashes gcontext)
						   (first dashes)))
					    (t
					     (setf (saved-gcontext-dash-offset gcontext) phase)
					     (setf (saved-gcontext-dashes gcontext)
						   dashes)))))))
			   (flet ((decode-alu (alu)
				    (setf alu (graphics::standardize-alu stream alu))
				    (cl:etypecase alu
				      ((cl:unsigned-byte 4)
				       (if (logtest alu #b0001)
					   (if (logtest alu #b0100)
					       (values boole-1 -1 -1)
					     (values boole-2 -1 -1))
					 (if (logtest alu #b0100)
					     (values boole-c2 -1 -1)
					   (values boole-1 0 -1))))
				      (scl:instance
					(multiple-value-bind (nil mask nil data boole)
					    (send alu :sc-parameters stream)
					  (values boole data mask))))))		
			     (multiple-value-bind (alu fill-data plane-mask)
				 (decode-alu ones-alu)
			       (setf (saved-gcontext-function gcontext) alu)
			       (setf (saved-gcontext-foreground gcontext)
				     (x-pixel-from-fixnum fill-data))
			       (setf (saved-gcontext-plane-mask gcontext)
				     (x-pixel-from-fixnum plane-mask))
			       (cond ((null pattern)
				      (setf (saved-gcontext-fill-style gcontext)
					    :solid))
				     ((instancep pattern)
				      (return-from gcontext nil))
				     (t
				      (cond
					((eq zeros-alu :tile)
					 (setf (saved-gcontext-fill-style gcontext)
					       :tiled)
					 (setf (saved-gcontext-pixmap gcontext)
					       pattern))
					(t
					 (multiple-value-bind
					   (z-alu z-fill-data z-plane-mask)
					     (decode-alu zeros-alu)
					   (cond ((eql z-alu boole-2)
						  (setf (saved-gcontext-fill-style gcontext)
							:stippled))
						 ((and (eql z-alu alu)
						       (eql plane-mask z-plane-mask))
						  (setf (saved-gcontext-fill-style gcontext)
							:opaque-stippled)
						  (setf (saved-gcontext-background gcontext)
							(x-pixel-from-fixnum z-fill-data)))
						 (t
						  (return-from gcontext nil)))
					   (setf (saved-gcontext-pixmap gcontext) pattern))))
				      )))))
			 gcontext))))))))

(defmacro-in-flavor (with-adjusted-graphics-offsets x-screen)
		    ((sheet drawable dx dy clip-mask) &body body)
  `(let ((,dx 0) (,dy 0))
     (tv:prepare-sheet (,sheet)
       (let* ((,drawable (tv:update-offsets ,sheet nil ,dx ,dy))
	      (sheet-clip (tv:sheet-clipping-region ,sheet))
	      (clip-left   (+ (pop sheet-clip) ,dx))
	      (clip-top    (+ (pop sheet-clip) ,dy))
	      (clip-right  (+ (pop sheet-clip) ,dx))
	      (clip-bottom (+ (pop sheet-clip) ,dy)))
	 (stack-let ((,clip-mask
		      (list clip-left clip-top
			    (- clip-right clip-left) (- clip-bottom clip-top))))
	   (incf ,dx (tv:sheet-left-margin-size ,sheet))
	   (incf ,dy (tv:sheet-top-margin-size ,sheet))
	   (progn ,@body))))))

;;(zwei:defindentation (with-adjusted-graphics-offsets 0 4 1 1))

(defun-in-flavor (x-update-graphics-state x-screen) (saved-gcontext clip-mask alu sheet)
  (set-gcontext (graphics-gcontext graphics-gcontext-values)
    :clip-mask clip-mask)
  (unless (eq last-saved-gcontext saved-gcontext)
    ;(setq last-saved-gcontext nil)
    (set-gcontext (graphics-gcontext graphics-gcontext-values)
      :line-width (saved-gcontext-line-width saved-gcontext)
      :cap-style (saved-gcontext-cap-style saved-gcontext)
      :join-style (saved-gcontext-join-style saved-gcontext)
      :plane-mask (saved-gcontext-plane-mask saved-gcontext)
      :line-style (saved-gcontext-line-style saved-gcontext)
      :dash-offset (saved-gcontext-dash-offset saved-gcontext)
      :dashes (saved-gcontext-dashes saved-gcontext)))
  (cond ((eql alu (tv:sheet-erase-aluf sheet))
	 (multiple-value-bind (alu fill-data plane-mask)
	     (cl:etypecase alu
	       ((cl:unsigned-byte 4)
		(if (logtest alu #b0001)
		    (if (logtest alu #b0100)
			(values boole-1 -1 -1)
			(values boole-2 -1 -1))
		    (if (logtest alu #b0100)
			(values boole-c2 -1 -1)
			(values boole-1 0 -1))))
	       (scl:instance
		 (multiple-value-bind (nil mask nil data boole)
		     (send alu :sc-parameters sheet)
		   (values boole data mask))))
	   (declare (ignore plane-mask))
	   (set-gcontext (graphics-gcontext graphics-gcontext-values)
	     :function alu
	     :foreground (x-pixel-from-fixnum fill-data))
	   (ecase (saved-gcontext-fill-style saved-gcontext)
	     ((:solid :tiled :opaque-stippled)
	      (set-gcontext (graphics-gcontext graphics-gcontext-values)
		:fill-style :solid))
	     ((:stippled)
	      (set-gcontext (graphics-gcontext graphics-gcontext-values)
		:fill-style :stippled
		:stipple (x-screen-cache-raster-pixmap
			   self (saved-gcontext-pixmap saved-gcontext)))))
	   (setq last-saved-gcontext nil)))
	((not (eq last-saved-gcontext saved-gcontext))
	 (set-gcontext (graphics-gcontext graphics-gcontext-values)
	   :function (saved-gcontext-function saved-gcontext)
	   :foreground (saved-gcontext-foreground saved-gcontext)
	   :background (saved-gcontext-background saved-gcontext)
	   :fill-style (saved-gcontext-fill-style saved-gcontext))
	 (ecase (saved-gcontext-fill-style saved-gcontext)
	   ((:solid))
	   ((:tiled)
	    (set-gcontext (graphics-gcontext graphics-gcontext-values)
	      :tile (x-screen-cache-raster-pixmap
		      self (saved-gcontext-pixmap saved-gcontext))))
	   ((:stippled :opaque-stippled)
	    (set-gcontext (graphics-gcontext graphics-gcontext-values)
	      :stipple (x-screen-cache-raster-pixmap
			 self (saved-gcontext-pixmap saved-gcontext)))))
	 (setq last-saved-gcontext saved-gcontext)))
  t)

(defun-in-flavor (x-screen-two-point-graphics-call x-screen)
		 (sheet function left top right bottom alu
			bounding-box refined-position-test refined-box
			saved-gcontext &rest args)
  (declare (ignore bounding-box refined-position-test refined-box))
  (when (with-adjusted-graphics-offsets (sheet drawable dx dy clip-mask)
	  (incf left dx) (incf top dy) (incf right dx) (incf bottom dy)
	  (x-update-graphics-state saved-gcontext clip-mask alu sheet)
	  (apply function self drawable left top right bottom args))
    (tv:remote-console-note-pending-output tv:console)
    t))

(defun-in-flavor (x-screen-n-point-graphics-call x-screen)
		 (sheet function points alu
			bounding-box refined-position-test refined-box
			saved-gcontext &rest args)
  (declare (ignore bounding-box refined-position-test refined-box))
  (when (with-adjusted-graphics-offsets (sheet drawable dx dy clip-mask)
	  (stack-let ((new-points (make-array (length points) :initial-contents points)))
	    (loop for i from 0 by 2 below (length new-points) do
	      (incf (aref new-points i) dx)
	      (incf (aref new-points (1+ i)) dy))
	    (x-update-graphics-state saved-gcontext clip-mask alu sheet)
	    (apply function self drawable new-points args)))
    (tv:remote-console-note-pending-output tv:console)
    t))

(graphics::define-screen-specific-graphics-type
  x-screen x-screen-two-point-graphics-call x-screen-n-point-graphics-call)

(defmacro with-x-drawing-state ((&key (stream 'stream)
				      (drawing-state `(graphics::get-drawing-state ,stream))
				      (host-test 't))
				default-form
				&body body)
  (declare (zwei:indentation 0 4 1 4 2 1))
  `(let ((drawing-state ,drawing-state)
	 (x-drawing-state nil))
     (if (and (ldb-test graphics::%%scan-conversion-host-allowed
			(graphics::get-drawing-state-scan-conversion-flags drawing-state))
	      ,host-test
	      (setq x-drawing-state
		    (x-save-graphics-state drawing-state ,stream gcontext-cache)))
	 (progn ,@body)
       ,default-form)))

(defmacro x-screen-specific-graphics
	  (&key (stream 'stream)
	   (drawing-state 'drawing-state)
	   default-function screen-function
	   argument-type point-arguments
	   (default-arguments nil)
	   (default-drawing-arguments '((progn x-drawing-state nil)))
	   (other-arguments nil)
	   (screen-arguments nil)
	   bounding-box
	   refined-position-test refined-box)
  `(graphics::screen-specific-graphics
     :type 'x-screen
     :stream ,stream :drawing-state ,drawing-state
     :alu (graphics::standardize-alu ,stream (graphics::drawing-state-alu drawing-state))
     :bounding-box ,bounding-box
     :refined-position-test ,refined-position-test :refined-box ,refined-box
     :default-function ,default-function :screen-function ,screen-function
     :default-arguments ,default-arguments
     :default-drawing-arguments ,default-drawing-arguments
     :screen-arguments ,(append '(x-drawing-state) screen-arguments) 
     :argument-type ,argument-type :point-arguments ,point-arguments :transform-points t
     :other-arguments ,other-arguments))

(defmethod (x-screen-graphics-draw-line x-screen) (drawable start-x start-y end-x end-y)
  (xlib:draw-line drawable graphics-gcontext start-x start-y end-x end-y)
  t)

(defsubst line-bounding-box (left top right bottom thickness)
  (let* ((smaller-half-thickness (sys:%fixnum-floor thickness 2))
	 (larger-half-thickness (max 1 (sys:%fixnum-ceiling thickness 2))))
    (values (- left smaller-half-thickness) (- top smaller-half-thickness)
	    (+ right larger-half-thickness) (+ bottom larger-half-thickness))))

(defun x-screen-graphics-draw-thick-line
       (start-x start-y end-x end-y thickness stream drawing-state x-drawing-state)
  (x-screen-specific-graphics
    :default-function (flavor:generic graphics::default-draw-line)
    :screen-function (flavor:generic x-screen-graphics-draw-line)
    :argument-type :two-point
    :point-arguments (start-x start-y end-x end-y)
    :bounding-box (line-bounding-box
		    (min start-x end-x) (min start-y end-y)
		    (max start-x end-x) (max start-y end-y)
		    thickness)
    :refined-position-test ((x y)
			    (dw::point-close-to-line-p
			      x y start-x start-y end-x end-y thickness))
    :refined-box (dw::outline-line-with-hexagon
		   start-x start-y end-x end-y thickness)))

(defmethod (graphics::%screen-draw-line x-screen)
	   (stream start-x start-y end-x end-y &rest args &key &allow-other-keys)
  (with-x-drawing-state ()
       (apply #'graphics::default-draw-line stream start-x start-y end-x end-y args)
    (let ((thickness (saved-gcontext-line-width x-drawing-state)))
      (if ( thickness 1)
	  (x-screen-specific-graphics
	    :default-function (flavor:generic graphics::default-draw-line)
	    :screen-function (flavor:generic x-screen-graphics-draw-line)
	    :argument-type :two-point
	    :point-arguments (start-x start-y end-x end-y)
	    :bounding-box (line-bounding-box
			    (min start-x end-x) (min start-y end-y)
			    (max start-x end-x) (max start-y end-y)
			    thickness)
	    :refined-position-test ((x y)
				    (dw::point-close-to-line-p
				      x y start-x start-y end-x end-y))
	    :refined-box (dw::outline-line-with-hexagon
			   start-x start-y end-x end-y))
	(x-screen-graphics-draw-thick-line
	  start-x start-y end-x end-y thickness stream drawing-state x-drawing-state)))))

(defmethod (x-screen-graphics-draw-lines x-screen) (drawable points)
  (xlib:draw-lines drawable graphics-gcontext points)
  t)

(defmethod (graphics::%screen-draw-lines x-screen)
	   (stream points &rest args &key (closed nil) (join-to-path nil) &allow-other-keys)
  (with-x-drawing-state (:host-test (not join-to-path))
       (apply #'graphics::default-draw-lines stream points args)
    (if closed
	(apply #'graphics::%screen-draw-polygon self stream points :filled nil args)
      (let ((thickness (saved-gcontext-line-width x-drawing-state)))
	(x-screen-specific-graphics
	  :default-function (flavor:generic graphics::default-draw-lines)
	  :screen-function (flavor:generic x-screen-graphics-draw-lines)
	  :argument-type :n-point
	  :point-arguments (points)
	  :bounding-box (multiple-value-bind (left top right bottom)
			    (dw::point-sequence-box points)
			  (line-bounding-box left top right bottom thickness)))))))

(defmethod (x-screen-graphics-draw-rectangle x-screen)
	   (drawable left top right bottom &key (filled t))
  (xlib:draw-rectangle
    drawable graphics-gcontext (min left right) (min top bottom)
    (abs (- right left)) (abs (- bottom top))
    filled)
  t)

(defmethod (graphics::%screen-draw-rectangle x-screen)
	   (stream left top right bottom &rest args &key (filled t) &allow-other-keys)
  (with-x-drawing-state ()
       (apply #'graphics::default-draw-rectangle stream left top right bottom args)
    (cond ((not (zerop (graphics:decompose-transform
			 (graphics::drawing-state-transform drawing-state))))
	   ;; Rotated, might be any quadrilateral
	   (stack-let ((points (list left top left bottom right bottom right top)))
	     (apply #'graphics::%screen-draw-polygon
		    self stream points :points-are-convex-p t args)))
	  (filled
	   (x-screen-specific-graphics
	     :default-function (flavor:generic graphics::default-draw-rectangle)
	     :screen-function (flavor:generic x-screen-graphics-draw-rectangle)
	     :argument-type :two-point
	     :point-arguments (left top right bottom)
	     :bounding-box (values left top right bottom)))
	  (t
	   (let ((thickness (saved-gcontext-line-width x-drawing-state)))
	     (x-screen-specific-graphics
	       :default-function (flavor:generic graphics::default-draw-rectangle)
	       :screen-function (flavor:generic x-screen-graphics-draw-rectangle)
	       :argument-type :two-point
	       :point-arguments (left top right bottom)
	       :other-arguments (:filled nil)
	       :bounding-box (line-bounding-box left top right bottom thickness)))))))

(defmethod (x-screen-graphics-draw-polygon x-screen)
	   (drawable points &key (filled t) (shape :complex))
  (xlib:draw-lines drawable graphics-gcontext points :fill-p filled :shape shape)
  t)

(defmethod (graphics::%screen-draw-triangle x-screen)
	   (stream x1 y1 x2 y2 x3 y3 &rest args &key (filled t) &allow-other-keys)
  (with-x-drawing-state ()
       (apply #'graphics::default-draw-triangle stream x1 y1 x2 y2 x3 y3 args)
    (stack-let ((points (list x1 y1 x2 y2 x3 y3)))
      (if filled
	  (x-screen-specific-graphics
	    :default-function (flavor:generic graphics::default-draw-polygon)
	    :screen-function (flavor:generic x-screen-graphics-draw-polygon)
	    :argument-type :n-point-closed
	    :point-arguments (points)
	    :other-arguments (:shape :convex)
	    :bounding-box (dw::point-sequence-box points))
	(let ((thickness (saved-gcontext-line-width x-drawing-state)))
	  (x-screen-specific-graphics
	    :default-function (flavor:generic graphics::default-draw-polygon)
	    :screen-function (flavor:generic x-screen-graphics-draw-polygon)
	    :argument-type :n-point-closed
	    :point-arguments (points)
	    :other-arguments (:filled nil :shape :convex)
	    :bounding-box (multiple-value-bind (left top right bottom)
			      (dw::point-sequence-box points)
			    (line-bounding-box left top right bottom thickness))))))))

(defmethod (graphics::%screen-draw-polygon x-screen)
	   (stream points &rest args &key (points-are-convex-p nil) (filled t)
		   &allow-other-keys)
  (with-x-drawing-state ()
       (apply #'graphics::default-draw-polygon stream points args)
    (if filled
	(x-screen-specific-graphics
	  :default-function (flavor:generic graphics::default-draw-polygon)
	  :screen-function (flavor:generic x-screen-graphics-draw-polygon)
	  :argument-type :n-point-closed
	  :point-arguments (points)
	  :default-arguments (:points-are-convex-p points-are-convex-p)
	  :bounding-box (dw::point-sequence-box points))
      (let ((thickness (saved-gcontext-line-width x-drawing-state)))
	(x-screen-specific-graphics
	  :default-function (flavor:generic graphics::default-draw-polygon)
	  :screen-function (flavor:generic x-screen-graphics-draw-polygon)
	  :argument-type :n-point-closed
	  :point-arguments (points)
	  :other-arguments (:filled nil)
	  :default-arguments (:points-are-convex-p points-are-convex-p)
	  :bounding-box (multiple-value-bind (left top right bottom)
			    (dw::point-sequence-box points)
			  (line-bounding-box left top right bottom thickness)))))))

(defmethod (x-screen-graphics-draw-ellipse x-screen)
	   (drawable left top right bottom &key (filled t) (start-angle 0)
		     (end-angle graphics:2pi))
  (when (< right left)
    (rotatef right left)
    (setq start-angle (- pi start-angle) end-angle (- end-angle)))
  (when (< bottom top)
    (rotatef bottom top)
    (setq start-angle (- start-angle) end-angle (- end-angle)))
  (xlib:draw-arc drawable graphics-gcontext
		 left top (- right left) (- bottom top)
		 start-angle end-angle filled)
  t)

(defun x-default-graphics-draw-ellipse (stream left top right bottom &rest args)
  (apply #'graphics::default-draw-ellipse 
	 stream
	 (floor (+ left right) 2) (floor (+ top bottom) 2)
	 (abs (floor (- right left) 2)) (abs (floor (- bottom top) 2))
	 args))

(defun x-screen-graphics-draw-filled-full-ellipse
       (left top right bottom start-angle end-angle
	stream drawing-state x-drawing-state)
  (x-screen-specific-graphics
    :default-function #'x-default-graphics-draw-ellipse
    :screen-function (flavor:generic x-screen-graphics-draw-ellipse)
    :argument-type :two-point
    :point-arguments (left top right bottom)
    :other-arguments (:start-angle start-angle
		      :end-angle end-angle
		      :filled t)
    :bounding-box (values left top right bottom)
    :refined-position-test ((x y)
			    (let ((center-x (floor (+ left right) 2))
				  (center-y (floor (+ top bottom) 2))
				  (x-radius (floor (- right left) 2))
				  (y-radius (floor (- bottom top) 2)))
			      ( (+ (expt (* (- x center-x) y-radius) 2)
				    (expt (* (- y center-y) x-radius) 2))
				 (expt (* x-radius y-radius) 2))))
    :refined-box (dw:computing-outline-from-path (stream)
		   (let ((center-x (floor (+ left right) 2))
			 (center-y (floor (+ top bottom) 2))
			 (x-radius (abs (floor (- right left) 2)))
			 (y-radius (abs (floor (- bottom top) 2))))
		     (graphics::draw-scaled-simple-ellipse
		       stream center-x center-y
		       (+ x-radius 2) (+ y-radius 2))))))

(defun x-screen-graphics-draw-outline-full-ellipse
       (left top right bottom start-angle end-angle thickness
	stream drawing-state x-drawing-state)
  (x-screen-specific-graphics
    :default-function #'x-default-graphics-draw-ellipse
    :screen-function (flavor:generic x-screen-graphics-draw-ellipse)
    :argument-type :two-point
    :point-arguments (left top right bottom)
    :other-arguments (:start-angle start-angle
		      :end-angle end-angle
		      :filled nil)
    :bounding-box (line-bounding-box left top right bottom thickness)
    :refined-position-test ((x y)
			    (let ((center-x (floor (+ left right) 2))
				  (center-y (floor (+ top bottom) 2))
				  (x-radius (floor (- right left) 2))
				  (y-radius (floor (- bottom top) 2))
				  (ht (max 2 (sys:%fixnum-ceiling thickness 2))))
			      (and (dw::point-inside-ellipse-p
				     x y center-x center-y
				     (+ x-radius ht) (+ y-radius ht))
				   (or ( x-radius ht) ( y-radius ht)
				       (not (dw::point-inside-ellipse-p
					      x y center-x center-y
					      (- x-radius ht) (- y-radius ht)))))))
    :refined-box (dw:computing-outline-from-path (stream)
		   (let ((center-x (floor (+ left right) 2))
			 (center-y (floor (+ top bottom) 2))
			 (x-radius (abs (floor (- right left) 2)))
			 (y-radius (abs (floor (- bottom top) 2)))
			 (ht (max 2 (sys:%fixnum-ceiling thickness 2))))
		     (graphics::draw-scaled-simple-ellipse
		       stream center-x center-y
		       (+ x-radius ht) (+ y-radius ht))
		     (when (and (> x-radius ht) (> y-radius ht))
		       (graphics::draw-scaled-simple-ellipse
			 stream center-x center-y
			 (- x-radius ht) (- y-radius ht)))))))

(defun x-screen-graphics-draw-filled-partial-ellipse
       (left top right bottom start-angle delta-angle
	stream drawing-state x-drawing-state)
  (x-screen-specific-graphics
    :default-function #'x-default-graphics-draw-ellipse
    :screen-function (flavor:generic x-screen-graphics-draw-ellipse)
    :argument-type :two-point
    :point-arguments (left top right bottom)
    :other-arguments (:start-angle start-angle
		      :end-angle		; zzz should really be delta-angle
		      delta-angle
		      :filled t)
    :bounding-box (multiple-value-bind (dw-start-angle dw-end-angle)
		      (if (minusp delta-angle)	; cw?
			  (values (mod start-angle graphics:2pi)
				  (+ (mod start-angle graphics:2pi)
				     (- delta-angle)))
			  ;; ccw
			  (values (mod (- start-angle delta-angle) graphics:2pi)
				  (mod start-angle graphics:2pi)))
		    (dw::elliptical-arc-box
		      (floor (+ left right) 2)
		      (floor (+ top bottom) 2)
		      (floor (- right left) 2)
		      (floor (- bottom top) 2)
		      ;; (- start-angle) (- delta-angle)
		      dw-start-angle dw-end-angle 
		      t))
    :refined-position-test ((x y)
			    (let ((center-x (floor (+ left right) 2))
				  (center-y (floor (+ top bottom) 2))
				  (x-radius (abs (floor (- right left) 2)))
				  (y-radius (abs (floor (- bottom top) 2))))
			      (and ( (+ (expt (* (- x center-x) y-radius) 2)
					 (expt (* (- y center-y) x-radius) 2))
				      (expt (* x-radius y-radius) 2))
				   (dw::point-between-angles-p
				     x y center-x center-y
				     (- start-angle) (- delta-angle)))))
    :refined-box (dw:computing-outline-from-path (stream)
		   (let ((center-x (floor (+ left right) 2))
			 (center-y (floor (+ top bottom) 2))
			 (x-radius (abs (floor (- right left) 2)))
			 (y-radius (abs (floor (- bottom top) 2))))
		     (graphics:draw-ellipse
		       center-x center-y
		       x-radius y-radius
		       ;; :start-angle (- start-angle) :end-angle (- delta-angle)
		       :start-angle start-angle :end-angle (+ start-angle delta-angle)
		       :filled nil :stream stream)
		     (graphics:with-graphics-translation
		       (stream center-x center-y)
		       (graphics:draw-line
			 0 0 y-radius 0
			 :rotation (- start-angle)
			 :scale-x (/ x-radius y-radius)
			 :stream stream)
		       (graphics:draw-line
			 0 0 y-radius 0
			 :rotation (- delta-angle)
			 :scale-x (/ x-radius y-radius)
			 :stream stream))))))

(defun x-screen-graphics-draw-outline-partial-ellipse
       (left top right bottom start-angle delta-angle thickness
	stream drawing-state x-drawing-state)
  (x-screen-specific-graphics
    :default-function #'x-default-graphics-draw-ellipse
    :screen-function (flavor:generic x-screen-graphics-draw-ellipse)
    :argument-type :two-point
    :point-arguments (left top right bottom)
    :other-arguments (:start-angle start-angle
		      :end-angle delta-angle
		      :filled nil)
    :bounding-box (multiple-value-bind (left top right bottom)
		      (multiple-value-bind (dw-start-angle dw-end-angle)
			  (if (minusp delta-angle)	; cw?
			      (values (mod start-angle graphics:2pi)
				      (+ (mod start-angle graphics:2pi)
					 (- delta-angle)))
			      ;; ccw
			      (values (mod (- start-angle delta-angle) graphics:2pi)
				      (mod start-angle graphics:2pi)))
			(dw::elliptical-arc-box
			  (floor (+ left right) 2)
			  (floor (+ top bottom) 2)
			  (floor (- right left) 2)
			  (floor (- bottom top) 2)
			  ;; (- start-angle) (- delta-angle)
			  dw-start-angle dw-end-angle 
			  nil))
		    (line-bounding-box left top right bottom thickness))
    :refined-position-test ((x y)
			    (let ((center-x (floor (+ left right) 2))
				  (center-y (floor (+ top bottom) 2))
				  (x-radius (abs (floor (- right left) 2)))
				  (y-radius (abs (floor (- bottom top) 2)))
				  (ht (max 2 (sys:%fixnum-ceiling thickness 2))))
			      (and (dw::point-inside-ellipse-p
				     x y center-x center-y
				     (+ x-radius ht) (+ y-radius ht))
				   (or ( x-radius ht) ( y-radius ht)
				       (not (dw::point-inside-ellipse-p
					      x y center-x center-y
					      (- x-radius ht)
					      (- y-radius ht))))
				   (dw::point-between-angles-p
				     x y center-x center-y
				     (- start-angle) (- delta-angle)))))
    :refined-box (dw:computing-outline-from-path (stream)
		   (let ((center-x (floor (+ left right) 2))
			 (center-y (floor (+ top bottom) 2))
			 (x-radius (abs (floor (- right left) 2)))
			 (y-radius (abs (floor (- bottom top) 2))))
		     (graphics:draw-ellipse
		       center-x center-y
		       x-radius y-radius
		       :start-angle (- start-angle)
		       :end-angle (- delta-angle)
		       :thickness thickness
		       :filled nil :stream stream)))
    ))

(defmethod (graphics::%screen-draw-ellipse x-screen)
	   (stream center-x center-y x-radius y-radius &rest args &key (inner-x-radius 0)
		   (inner-y-radius 0) (start-angle 0) (end-angle graphics:2pi) (clockwise nil)
		   (join-to-path nil) (filled t) &allow-other-keys)
  (with-x-drawing-state
       (:host-test (and (not join-to-path)
			(zerop inner-x-radius)
			(zerop inner-y-radius)))
       (apply #'graphics::default-draw-ellipse
	      stream center-x center-y x-radius y-radius args)
    ;; An ellipse or arc is distorted by rotation and an arc by stretching.
    (if (block hard
	  (multiple-value-bind (rotation scale-x scale-y)
	      (graphics:decompose-transform
		(graphics::drawing-state-transform drawing-state))
	    (when (not (zerop rotation))
	      (return-from hard t))
	    (when (or ( x-radius y-radius)
		      (not (graphics::full-circle-p start-angle end-angle)))
	      (when (not (zerop rotation))
		(return-from hard t))
	      (when (not (graphics::full-circle-p start-angle end-angle))
		(when ( (abs scale-x) (abs scale-y))
		  (return-from hard t))
		(when (minusp scale-x)
		  (setq start-angle (- pi start-angle)
			end-angle (- pi end-angle)
			clockwise (not clockwise)))
		(when (minusp scale-y)
		  (setq start-angle (- start-angle)
			end-angle (- end-angle)
			clockwise (not clockwise)))))
	    nil))
	(apply #'graphics::default-draw-ellipse
	       stream center-x center-y x-radius y-radius args)
      (let ((left (- center-x x-radius))
	    (top (- center-y y-radius))
	    (right (+ center-x x-radius))
	    (bottom (+ center-y y-radius)))
	(if (graphics::full-circle-p start-angle end-angle)
	    (if filled
		(x-screen-graphics-draw-filled-full-ellipse
		  left top right bottom start-angle end-angle
		  stream drawing-state x-drawing-state)
	      (x-screen-graphics-draw-outline-full-ellipse
		left top right bottom start-angle end-angle
		(saved-gcontext-line-width x-drawing-state)
		stream drawing-state x-drawing-state))
	  (multiple-value-bind (start-angle end-angle)
	      (values start-angle (mod (- end-angle start-angle) graphics:2pi))
	    (when clockwise (decf end-angle graphics:2pi))
	    (if filled
		(x-screen-graphics-draw-filled-partial-ellipse
		  left top right bottom start-angle end-angle
		  stream drawing-state x-drawing-state)
	      (x-screen-graphics-draw-outline-partial-ellipse
		left top right bottom start-angle end-angle
		(saved-gcontext-line-width x-drawing-state)
		stream drawing-state x-drawing-state))))))))

(defmethod (x-screen-graphics-draw-glyph x-screen) (drawable points index font)
  (multiple-value-bind (xfopm index)
      (x-display-device-indexed-xfopm-lookup tv:display-device-type font index)
    (when (xlib:font-p xfopm)
      (set-gcontext (graphics-gcontext graphics-gcontext-values)
	:font xfopm)
      (xlib:draw-glyph
	drawable graphics-gcontext
	(elt points 0) (+ (elt points 1) (tv:font-baseline font))
	index :translate #'singular-identity-translate)
      t)))

(defun x-default-graphics-draw-glyph (stream points index font)
  (graphics::default-draw-glyph stream index font (elt points 0) (elt points 1)))

(defmethod (graphics::%screen-draw-glyph x-screen)
	   (stream index font x y &rest args &key &allow-other-keys)
  (with-x-drawing-state ()
       (apply #'graphics::default-draw-glyph stream index font x y args)
    (stack-let ((points (list x y)))
      (x-screen-specific-graphics
	:default-function #'x-default-graphics-draw-glyph
	:screen-function (flavor:generic x-screen-graphics-draw-glyph)
	:argument-type :n-point
	:point-arguments (points)
	:other-arguments (index font)
	:bounding-box (let* ((x (elt points 0))
			     (y (elt points 1))
			     (left (+ x (let ((lkt (tv:font-left-kern-table font)))
					  (if lkt (aref lkt index) 0)))))
			(values left
				y
				(+ left (let ((it (tv:font-indexing-table font)))
					  (if it (- (aref it (1+ index)) (aref it index))
					    (tv:font-raster-width font))))
				(+ y (tv:font-char-height font))))))))

(defmethod (x-screen-graphics-draw-glyphs x-screen) (drawable points indices font-symbol)
  (let ((xfopm (x-display-device-xfopm-lookup tv:display-device-type font-symbol)))
    (when (xlib:font-p xfopm)
      (set-gcontext (graphics-gcontext graphics-gcontext-values)
	:font xfopm)
      (xlib:draw-glyphs
	drawable graphics-gcontext (elt points 0) (elt points 1) indices
	:size (if (< (xlib:font-max-char xfopm) 256) 8 16)
	:translate #'identity-translate)
      t)))

(defun x-default-graphics-draw-glyphs (stream points indices font-symbol)
  (let ((font (and (fed:font-boundp font-symbol) (symbol-value font-symbol))))
    (when font
      (let ((char-width-table (zl:font-char-width-table font))
	    (x (elt points 0))
	    (y (- (elt points 1) (tv:font-baseline font)))
	    (indices indices))
	(declare (sys:array-register indices))
	(if char-width-table
	    (let ((char-width-table char-width-table))
	      (declare (sys:array-register char-width-table))
	      (loop for index being the array-elements of indices
		    do (graphics::default-draw-glyph stream index font x y)
		       (incf x (aref char-width-table index))))
	  (loop with cw = (zl:font-char-width font)
		for index being the array-elements of indices
		do (graphics::default-draw-glyph stream index font x y)
		   (incf x cw)))))))

(defun-in-flavor (x-screen-draw-string-portion x-screen)
		 (stream string index limit x baseline-y style drawing-state x-drawing-state)
  (multiple-value-bind (xfopm ignore xfopm-vector index-vector)
      (let* ((char (aref string index))
	     (style (si:merge-style-of-character-with-character-style char style)))
	(multiple-value-bind (char-set char-index) (si:char-char-set-and-index char)
	  (x-display-device-indexed-xfopm-lookup
	    tv:display-device-type
	    (si:get-font tv:display-device-type char-set style)
	    char-index)))
    (loop for symbol first (xfopm-symbol xfopm)
		     then (getf (xlib:font-plist xfopm) 'tv:font-name)
	  for nindices = (- limit index)
	  for indices-size first (if (< (xfopm-max-char xfopm) 256) 8 16)
			   then (if (< (xlib:font-max-char xfopm) 256) 8 16)
	  for indices-type = (if (= indices-size 8) 'sys:art-8b 'sys:art-16b)
	  do (stack-let ((points (list x baseline-y))
			 (indices (sys:make-array nindices :type indices-type)))
	       (multiple-value-bind (new-index new-xfont)
		   (translate string index limit xfopm indices 0 xfopm-vector index-vector)
		 (let* ((count (- new-index index))
			(indices
			  (if (= nindices count) 
			      indices
			    (let ((new (sys:make-stack-array count :type indices-type)))
			      (copy-array-portion indices 0 count new 0 count)
			      new))))
		   (multiple-value-bind (left top right bottom new-x)
		       (xfopm-text-bounds xfopm indices count x baseline-y)
		     (x-screen-specific-graphics
		       :stream stream :drawing-state drawing-state
		       :default-function #'x-default-graphics-draw-glyphs
		       :screen-function (flavor:generic x-screen-graphics-draw-glyphs)
		       :argument-type :n-point
		       :point-arguments (points)
		       :other-arguments (indices symbol)
		       :bounding-box (values left top right bottom))
		     (setf index new-index
			   xfopm new-xfont
			   x new-x)))))
	  while xfopm
	  finally (return (values index x)))))

(defmethod (graphics::%screen-draw-string x-screen)
	   (stream string x y &rest args &key (toward-x (1+ x)) (toward-y y) (stretch-p nil)
		   (character-style nil) (record-as-text nil) &allow-other-keys)
  (with-x-drawing-state
       (:host-test (and (= toward-y y) ( toward-x x) (not stretch-p)
			(zerop
			  (graphics:decompose-transform
			    (graphics::drawing-state-transform drawing-state)))))
       (apply #'graphics::default-draw-string stream string x y args)
    (graphics::transform-and-fix-points-internal
      (graphics:stream-transform stream) x y toward-x toward-y)
    (multiple-value-bind (left top right bottom baseline-y)
	(apply #'graphics::draw-string-bounding-box-internal stream string x y
	       :toward-x toward-x :toward-y toward-y args)
      (declare (ignore top bottom right))
      (if (and record-as-text (send-if-handles stream :output-recording-enabled))
	  (multiple-value-bind (ox oy)
	      (send stream :read-cursorpos)
	    (with-character-style (character-style stream :bind-line-height t)
	      (send stream :set-cursorpos left (- baseline-y (send stream :baseline)))
	      (send stream :string-out string))
	    (send stream :set-cursorpos ox oy))
	(graphics:with-graphics-identity-transform (stream)
	  (loop with sheet-style = (tv:sheet-merged-current-style stream)
		with style = (si:merge-character-styles character-style sheet-style)
		with index = 0
		with limit = (length string)
		until (or (null index) (>= index limit))
		do (multiple-value-setq (index left)
		     (x-screen-draw-string-portion
		       stream string index limit left baseline-y style
		       drawing-state x-drawing-state))))))))

(defflavor x-real-screen
	()
	(x-screen tv:basic-remote-screen))

(defmethod (:activate x-real-screen :before) ()
  (setf tv:name (x-console-name tv:console "Screen")))

(defmethod (x-screen-shutdown x-real-screen) (&key abort kill)
  (unless abort
    ;; Try not to nail processes that might be drawing on the screen, but only wait 5 seconds
    (process:process-wait-with-timeout
      "Sheet Lock" 5 #'tv:sheet-can-get-lock self *current-process*))
  (tv:screen-clear-locks self)
  (tv:without-screen-management
    (dolist (inferior (copy-list (tv:sheet-exposed-inferiors self)))
      (send inferior :deexpose nil))
    (send self :deactivate))
  (send self :set-console nil)
  (incf tv:resource-tick)
  (send self :update-current-timestamp)
  (if kill (send self :kill)
    ;; tv:reset-tree-dynamic-state but without resetting any processes
    (tv:map-over-all-inferiors self #'tv:reset-dynamic-state))
  (store-conditional (locf tv:default-screen) self nil)
  (store-conditional (locf tv:main-screen) self nil)
  (process:atomic-replacef tv:*console-screens* (remove self tv:*console-screens*))
  (unless kill
    (pushnew self tv:*old-console-screens*))
  nil)



(defflavor x-who-line-screen
	()
	(tv:generic-who-line-screen-mixin
	 tv:no-change-of-default-font-mixin
	 tv:slave-screen-mixin
	 x-screen
	 tv:basic-remote-screen)
  (:default-init-plist
   :gray-array-for-unused-areas :white
   :property-list (list :video :black-and-white
			:controller :remote
			:who-line t)))

(defmethod (:activate x-who-line-screen :before) ()
  (setq tv:console (send tv:parent-screen :console))
  (setf tv:name (x-console-name tv:console "Who Screen")))

(defmethod (tv:who-line-screen-enable x-who-line-screen :after) ()
  (setf (process-name tv:update-process) (x-console-name tv:console "Who Screen")))

(defmethod (x-screen-shutdown x-who-line-screen) (&key abort kill)
  (declare (ignore abort))
  (tv:remove-active-who-line-screen self)
  (send self :set-console nil)
  (incf tv:resource-tick)
  (send self :update-current-timestamp)
  (if kill (send self :kill)
    (tv:map-over-all-inferiors self #'tv:reset-dynamic-state)))

(defmethod (:expose x-who-line-screen :after) (&rest ignore)
  (let ((run-line-field (tv:get-who-line-field :run-line self))
	(run-state-field (tv:get-who-line-field :run-state self)))
    (when run-line-field
      (let ((y (send run-line-field :y-offset))
	    (x (if run-state-field (send run-state-field :x-offset) 0)))
	(funcall (x-console-run-lights-positioner tv:console)
		 (x-console-display-number tv:console)
		 (x-console-screen-number tv:console)
		 (xlib:window-id tv:root-drawable)
		 6 32 1 (+ tv:x-offset (max 0 (- x (* 6 32)))) (+ tv:y-offset y 1) 64 0
		 (x-console-foreground tv:console) (x-console-background tv:console)
		 (x-pixel-from-fixnum -1))))))

(defmethod (:deexpose x-who-line-screen :before) (&rest ignore)
  (when (and tv:console tv:root-drawable)
    (funcall (x-console-run-lights-remover tv:console)
	     (x-console-display-number tv:console)
	     (x-console-screen-number tv:console)
	     (xlib:window-id tv:root-drawable))))

(defflavor x-bitmap-screen () (x-screen tv:basic-remote-bitmap-screen)
  (:constructor make-x-bitmap-screen ()))

(defresource x-bitmap-screen ()
  :constructor (make-x-bitmap-screen))

(defmethod (tv:deallocate-bitmap-stream x-bitmap-screen) ()
  (deallocate-resource 'x-bitmap-screen self))

(defmethod (:screen-allocate-bitmap-stream x-screen) (&rest ignore)
  (allocate-resource 'x-bitmap-screen))


(compile-flavor-methods x-screen x-real-screen x-who-line-screen x-bitmap-screen)
