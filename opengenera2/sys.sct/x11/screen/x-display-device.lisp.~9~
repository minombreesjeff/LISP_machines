;;; -*- Base: 10; Package: X-SCREEN; Mode: LISP; Syntax: Common-lisp; Lowercase: T -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; The implementation is a compromise.  It is a straight macro so we don't
;;; have to funcall the continuation for each operation, but it does call
;;; a function to handle the error so that changes can be made without recompilation.
;;; We use condition-bind so that we can filter FATAL-ERROR's (see comment below).
(defmacro catch-network-errors (() &body body)
  `(catch 'ignore-error
     ;; I don't want to duplicate the list of errors here and in
     ;; handle-network-error, and I especially don't want to build them into
     ;; the macro, so just handle any error and rely on handle-network-error
     ;; to ignore the ones it isn't interested in.
     (condition-bind ((future-common-lisp:error 'handle-network-error))
       ,@body)))

(defun handle-network-error (error)
  (when (or (typep error 'sys:network-error)
	    (typep error 'xlib:closed-display)
	    (and (typep error 'sys:fatal-error)
		 (string-equal (send error :format-string) "Other side of pipe is closed.")))
    (when (typep error '(and sys:network-error
			     (not (or sys:connection-closed
				      sys:connection-closed-locally
				      sys:stream-closed))))
      (tv:notify nil "X Network Error in process ~A:~%~~A~" *current-process* error))
    (throw 'ignore-error nil)))

(defmacro with-pixmap (((pixmap &optional gcontext)
			width height depth drawable &rest gcontext-options)
		       &body body)
  `(let ((,pixmap nil)
	 ,@(when gcontext
	     `((,gcontext nil))))
     (unwind-protect
	 (progn
	   (setq ,pixmap
		 (xlib:create-pixmap
		   :width ,width :height ,height :depth ,depth :drawable ,drawable))
	   ,@(when gcontext
	       `((setq ,gcontext
		       (xlib:create-gcontext :drawable ,pixmap ,@gcontext-options))))
	   ,@body)
       (catch-network-errors ()
	 ,@(when gcontext
	     `((when ,gcontext (xlib:free-gcontext ,gcontext))))
	 (when ,pixmap (xlib:free-pixmap ,pixmap))))))

(defparameter
  *font-family-family-alists*
  `((,si:*standard-character-set*
     (:fix 				"Courier")
     (:swiss		 		"Helvetica")
     (:dutch 				"Times")
     (:jess				"Helvetica"))
    (,si:*symbol-character-set*
     (:fix 				"Courier")
     (:swiss		 		"Helvetica")
     (:dutch 				"Times")
     (:jess				"Helvetica"))))

(defun cs-families (charset style)
  (cdr (assoc (si:cs-family style) (cdr (assoc charset *font-family-family-alists*)))))

(defparameter
  *font-face-weight-alists*
  `((,si:*standard-character-set*
     (:roman 				"Medium")
     (:italic 				"Medium")
     (:bold 				"Bold")
     (:bold-italic 			"Bold")
     (:extended 			"Medium")
     (:italic-extended 			"Medium")
     (:bold-extended 			"Bold")
     (:bold-italic-extended 		"Bold")
     (:condensed 			"Medium")
     (:condensed-caps			"Medium")
     (:italic-condensed 		"Medium")
     (:bold-condensed 			"Bold")
     (:bold-condensed-caps		"Bold")
     (:bold-italic-condensed 		"Bold")
     (:extra-condensed 			"Medium")
     (:italic-extra-condensed 		"Medium")
     (:bold-extra-condensed 		"Bold")
     (:bold-italic-extra-condensed 	"Bold"))
    (,si:*symbol-character-set*
     (:roman 				"Medium")
     (:italic 				"Medium")
     (:bold 				"Bold")
     (:bold-italic 			"Bold")
     (:extended 			"Medium")
     (:italic-extended 			"Medium")
     (:bold-extended 			"Bold")
     (:bold-italic-extended 		"Bold")
     (:condensed 			"Medium")
     (:condensed-caps			"Medium")
     (:italic-condensed 		"Medium")
     (:bold-condensed 			"Bold")
     (:bold-condensed-caps		"Bold")
     (:bold-italic-condensed 		"Bold")
     (:extra-condensed 			"Medium")
     (:italic-extra-condensed 		"Medium")
     (:bold-extra-condensed 		"Bold")
     (:bold-italic-extra-condensed 	"Bold"))))

(defun cs-weights (charset style)
  (cdr (assoc (si:cs-face style) (cdr (assoc charset *font-face-weight-alists*)))))

(defparameter
  *font-face-slant-alists*
  `((,si:*standard-character-set*
     (:roman 				"R")
     (:italic 				"I" "O")
     (:bold 				"R")
     (:bold-italic 			"I" "O")
     (:extended 			"R")
     (:italic-extended 			"I" "O")
     (:bold-extended 			"R")
     (:bold-italic-extended 		"R")
     (:condensed 			"R")
     (:condensed-caps			"R")
     (:italic-condensed 		"I" "O")
     (:bold-condensed 			"R")
     (:bold-condensed-caps		"R")
     (:bold-italic-condensed 		"I" "O")
     (:extra-condensed 			"R")
     (:italic-extra-condensed 		"I" "O")
     (:bold-extra-condensed 		"R")
     (:bold-italic-extra-condensed 	"I" "O"))
    (,si:*symbol-character-set*
     (:roman 				"R")
     (:italic 				"I" "O")
     (:bold 				"R")
     (:bold-italic 			"I" "O")
     (:extended 			"R")
     (:italic-extended 			"I" "O")
     (:bold-extended 			"R")
     (:bold-italic-extended 		"R")
     (:condensed 			"R")
     (:condensed-caps			"R")
     (:italic-condensed 		"I" "O")
     (:bold-condensed 			"R")
     (:bold-condensed-caps		"R")
     (:bold-italic-condensed 		"I" "O")
     (:extra-condensed 			"R")
     (:italic-extra-condensed 		"I" "O")
     (:bold-extra-condensed 		"R")
     (:bold-italic-extra-condensed 	"I" "O"))
    ))

(defun cs-slants (charset style)
  (cdr (assoc (si:cs-face style) (cdr (assoc charset *font-face-slant-alists*)))))

(defparameter
  *font-face-setwidth-alists*
  `((,si:*standard-character-set*
     (:roman 				"Normal")
     (:italic 				"Normal")
     (:bold 				"Normal")
     (:bold-italic 			"Normal")
     (:extended 			"Extended" "Wide" "Double Wide" "Normal")
     (:italic-extended 			"Extended" "Wide" "Double Wide" "Normal")
     (:bold-extended 			"Extended" "Wide" "Double Wide" "Normal")
     (:bold-italic-extended 		"Extended" "Wide" "Double Wide" "Normal")
     (:condensed 			"Condensed" "Narrow" "Normal")
     (:condensed-caps			"Condensed" "Narrow" "Normal")
     (:italic-condensed 		"Condensed" "Narrow" "Normal")
     (:bold-condensed 			"Condensed" "Narrow" "Normal")
     (:bold-condensed-caps		"Condensed" "Narrow" "Normal")
     (:bold-italic-condensed 		"Condensed" "Narrow" "Normal")
     (:extra-condensed 			"Extra Condensed" "Condensed" "Narrow" "Normal")
     (:italic-extra-condensed 		"Extra Condensed" "Condensed" "Narrow" "Normal")
     (:bold-extra-condensed 		"Extra Condensed" "Condensed" "Narrow" "Normal")
     (:bold-italic-extra-condensed 	"Extra Condensed" "Condensed" "Narrow" "Normal"))
    (,si:*symbol-character-set*
     (:roman 				"Normal")
     (:italic 				"Normal")
     (:bold 				"Normal")
     (:bold-italic 			"Normal")
     (:extended 			"Extended" "Wide" "Double Wide" "Normal")
     (:italic-extended 			"Extended" "Wide" "Double Wide" "Normal")
     (:bold-extended 			"Extended" "Wide" "Double Wide" "Normal")
     (:bold-italic-extended 		"Extended" "Wide" "Double Wide" "Normal")
     (:condensed 			"Condensed" "Narrow" "Normal")
     (:condensed-caps			"Condensed" "Narrow" "Normal")
     (:italic-condensed 		"Condensed" "Narrow" "Normal")
     (:bold-condensed 			"Condensed" "Narrow" "Normal")
     (:bold-condensed-caps		"Condensed" "Narrow" "Normal")
     (:bold-italic-condensed 		"Condensed" "Narrow" "Normal")
     (:extra-condensed 			"Extra Condensed" "Condensed" "Narrow" "Normal")
     (:italic-extra-condensed 		"Extra Condensed" "Condensed" "Narrow" "Normal")
     (:bold-extra-condensed 		"Extra Condensed" "Condensed" "Narrow" "Normal")
     (:bold-italic-extra-condensed 	"Extra Condensed" "Condensed" "Narrow" "Normal"))))

(defun cs-setwidths (charset style)
  (cdr (assoc (si:cs-face style) (cdr (assoc charset *font-face-setwidth-alists*)))))

(defparameter
  *font-size-size-alists*
  `((,si:*standard-character-set*
     (:tiny				"6")
     (:very-small			"8")
     (:small				"10")
     (:normal				"12")
     (:large				"14")
     (:very-large			"18")
     (:huge				"24")
     )
    (,si:*symbol-character-set*
     (:tiny				"6")
     (:very-small			"8")
     (:small				"10")
     (:normal				"12")
     (:large				"14")
     (:very-large			"18")
     (:huge				"24")
     )))

(defun cs-sizes (charset style)
  (cdr (assoc (si:cs-size style) (cdr (assoc charset *font-size-size-alists*)))))

(defun make-mapping-vector (character-set mappings)
  (flet ((decode (c)
	   (etypecase c
	     (character (multiple-value-bind (ignore i) (si:char-char-set-and-index c) i))
	     (fixnum c))))
    (loop with vector = (make-array (send character-set :n-characters))
	  for (from to) in mappings
	  when to
	    do (if (consp from)
		   (loop for char-index from (decode (first from)) to (decode (second from))
			 for font-index upfrom to
			 do (setf (aref vector char-index) font-index))
		 (setf (aref vector (decode from)) to))
	  finally (return vector))))

(defparameter
  *font-charset-mapping-alist*
  `((,si:*standard-character-set* 
     ((:charset-registry "ISO8859"
       :charset-encoding "1")
      ,(make-mapping-vector
	 si:*standard-character-set*
	 '(((#\Space #\~) 32) (#\  183) (#\ 172) (#\å 177))))
     ((:family "Symbol"
       :charset-registry "Adobe"
       :charset-encoding "FontSpecific")
      ,(make-mapping-vector
	 si:*standard-character-set*
	 '((#\ 175) (#\  97) (#\  98) (#\ 217) (#\ 206) (#\ 112) (#\à 108) (#\â  99)
	   (#\ç 100) (#\ 173) (#\ä 197) (#\ 165) (#\ 182) (#\ 204) (#\ 201) (#\ 199)
	   (#\ 200) (#\  34) (#\  36) (#\ 196) (#\ 171) (#\ 172) (#\ 174) (#\ 185)
	   (#\ 224) (#\ 163) (#\ 179) (#\ 186) (#\ 218) (#\á 242)))))
    (,si:*symbol-character-set*
     ((:family "Symbol"
       :charset-registry "Adobe"
       :charset-encoding "FontSpecific")
      ,(make-mapping-vector
	 si:*standard-character-set*
	 '((#o000    ) (#o001 175) (#o002  97) (#o003  98)
	   (#o004 217) (#o005 228) (#o006 206) (#o007 112)
	   (#o010 108) (#o011  99) (#o012 100) (#o013 173)
	   (#o014 177) (#o015 197) (#o016 165) (#o017    )
	   (#o020    ) (#o021 201) (#o022 199) (#o023 200)
	   (#o024  34) (#o025  36) (#o026 196) (#o027 171)
	   (#o030 172) (#o031    ) (#o032 185) (#o033 224)
	   (#o034 163) (#o035 179) (#o036 186) (#o037 218)
	   (#o040    ) (#o041    ) (#o042    ) (#o043    )
	   (#o044    ) (#o045    ) (#o046  38) (#o047    )
	   (#o050  40) (#o051  41) (#o052  42) (#o053 177)
	   (#o054  44) (#o055  45) (#o056    ) (#o057  47)
	   (#o060    ) (#o061    ) (#o062    ) (#o063  97)
	   (#o064  96) (#o065  99) (#o066 100) (#o067    )
	   (#o070    ) (#o071    ) (#o072    ) (#o073    )
	   (#o074    ) (#o075    ) (#o076    ) (#o077    )
	   (#o100    ) (#o101    ) (#o102 226) (#o103 227)
	   (#o104    ) (#o105    ) (#o106    ) (#o107    )
	   (#o110    ) (#o111 242) (#o112    ) (#o113    )
	   (#o114    ) (#o115    ) (#o116    ) (#o117    )
	   (#o120    ) (#o121    ) (#o122    ) (#o123    )
	   (#o124 204) (#o125    ) (#o126    ) (#o127 201)
	   (#o130    ) (#o131    ) (#o132    ) (#o133    )
	   (#o134    ) (#o135    ) (#o136    ) (#o137    )
	   (#o140    ) (#o141 172) (#o142 174) (#o143    )
	   (#o144 175) (#o145    ) (#o146    ) (#o147    )
	   (#o150    ) (#o151 165) (#o152    ) (#o153    )
	   (#o154    ) (#o155 190) (#o156    ) (#o157 183)
	   (#o160    ) (#o161    ) (#o162 226) (#o163    )
	   (#o164    ) (#o165 173) (#o166    ) (#o167    )
	   (#o170    ) (#o171    ) (#o172    ) (#o173    )
	   (#o174    ) (#o175    ) (#o176 126) (#o177 242))))
     ((:charset-registry "ISO8859"
       :charset-encoding "1")
      ,(make-mapping-vector
	 si:*standard-character-set*
	 '((#o047 39) (#o000 183) (#o136  94) (#o137 95) (#o140  96)))))))

(defun translate-thin-string
       (src src-start src-end font dst dst-start xfopm-vector index-vector)
  (let ((s src)
	(d dst)
	(si src-start)
	(di dst-start))
    (declare (sys:array-register s d))
    (if xfopm-vector
	(let ((xv xfopm-vector)
	      (iv index-vector))
	  (declare (sys:array-register xv iv))
	  (dotimes (ignore (- src-end src-start))
	    (let* ((i (sys:char-subindex (aref s si)))
		   (f (aref xv i)))
	      (unless (eq font f)
		(return-from translate-thin-string
		  (values si (and (xlib:font-p f) f))))
	      (setf (aref d di) (aref iv i)))
	    (incf si)
	    (incf di)))
      (dotimes (ignore (- src-end src-start))
	(setf (aref d di) (sys:char-subindex (aref s si)))
	(incf si)
	(incf di)))
    (values si)))

(defun translate-unstyled-fat-string
       (src src-start src-end font dst dst-start xfopm-vector index-vector)
  (let ((s src)
	(d dst)
	(si src-start)
	(di dst-start)
	(cache-set nil)
	(cache-index nil)
	(cache-offset nil))
    (declare (sys:array-register s d))
    (if xfopm-vector
	(let ((xv xfopm-vector)
	      (iv index-vector))
	  (declare (sys:array-register xv iv))
	  (dotimes (ignore (- src-end src-start))
	    (let ((c (aref s si)))
	      (if (plusp (si:char-style-index c))
		  (return-from translate-unstyled-fat-string si)
		(let ((char-set-index (si:char-char-set-index c)))
		  (when (neq char-set-index cache-index)
		    (multiple-value-bind (char-set char-offset)
			(si:char-set-and-offset (setq cache-index char-set-index))
		      (when (and cache-set (neq cache-set char-set))
			(return-from translate-unstyled-fat-string si))
		      (setq cache-set char-set cache-offset char-offset)))
		  (let* ((i (+ (sys:char-subindex c) cache-offset))
			 (f (aref xv i)))
		    (unless (eq font f)
		      (return-from translate-unstyled-fat-string
			(values si (and (xlib:font-p f) f))))
		    (setf (aref d di) (aref iv i))))))
	    (incf si)
	    (incf di)))
      (dotimes (ignore (- src-end src-start))
	(let ((c (aref s si)))
	  (if (plusp (si:char-style-index c))
	      (return-from translate-unstyled-fat-string si)
	    (let ((char-set-index (si:char-char-set-index c)))
	      (when (neq char-set-index cache-index)
		(multiple-value-bind (char-set char-offset)
		    (si:char-set-and-offset (setq cache-index char-set-index))
		  (when (and cache-set (neq cache-set char-set))
		    (return-from translate-unstyled-fat-string si))
		  (setq cache-set char-set cache-offset char-offset)))
	      (setf (aref d di) (+ (sys:char-subindex c) cache-offset)))))
	(incf si)
	(incf di)))
    (values si)))

(defun translate-styled-fat-string
       (src src-start src-end font dst dst-start xfopm-vector index-vector style)
  (let ((s src)
	(d dst)
	(si src-start)
	(di dst-start)
	(cache-set nil)
	(cache-index nil)
	(cache-offset nil))
    (declare (sys:array-register s d))
    (if xfopm-vector
	(let ((xv xfopm-vector)
	      (iv index-vector))
	  (declare (sys:array-register xv iv))
	  (dotimes (ignore (- src-end src-start))
	    (let* ((c (aref s si))
		   (char-set-index (si:char-char-set-index c)))
	      (when (neq char-set-index cache-index)
		(multiple-value-bind (char-set char-offset)
		    (si:char-set-and-offset (setq cache-index char-set-index))
		  (when (and cache-set (neq cache-set char-set))
		    (return-from translate-styled-fat-string si))
		  (setq cache-set char-set cache-offset char-offset)))
	      (unless (eq (si:char-style-index c) style)
		(return-from translate-styled-fat-string si))
	      (let* ((i (+ (sys:char-subindex c) cache-offset))
		     (f (aref xv i)))
		(unless (eq font f)
		  (return-from translate-styled-fat-string
		    (values si (and (xlib:font-p f) f))))
		(setf (aref d di) (aref iv i))))
	    (incf si)
	    (incf di)))
      (dotimes (ignore (- src-end src-start))
	(let* ((c (aref s si))
	       (char-set-index (si:char-char-set-index c)))
	  (when (neq char-set-index cache-index)
	    (multiple-value-bind (char-set char-offset)
		(si:char-set-and-offset (setq cache-index char-set-index))
	      (when (and cache-set (neq cache-set char-set))
		(return-from translate-styled-fat-string si))
	      (setq cache-set char-set cache-offset char-offset)))
	  (unless (eq (si:char-style-index c) style)
	    (return-from translate-styled-fat-string si))
	  (setf (aref d di) (+ (sys:char-subindex c) cache-offset)))
	(incf si)
	(incf di)))
    (values si)))

(defun translate
       (src src-start src-end font dst dst-start xfopm-vector index-vector)
  (select (sys:array-type-field src)
    (sys:art-string
     (translate-thin-string
       src src-start src-end font dst dst-start xfopm-vector index-vector))
    (sys:art-fat-string
     (let ((style (si:char-style-index (aref src src-start))))
       (if (zerop style)
	   (translate-unstyled-fat-string
	     src src-start src-end font dst dst-start xfopm-vector index-vector)
	 (translate-styled-fat-string
	   src src-start src-end font dst dst-start xfopm-vector index-vector style))))
    (otherwise
     (copy-array-portion src src-start src-end
			 dst dst-start (+ dst-start (- src-end src-start)))
     (values src-end))))

(defun identity-translate (src src-start src-end font dst dst-start)
  (declare (ignore font))
  (copy-array-portion src src-start src-end dst dst-start (+ dst-start (- src-end src-start)))
  (values src-end))

(defun singular-identity-translate (src src-start src-end font dst dst-start)
  (declare (ignore font))
  (setf (aref dst dst-start) (aref src src-start))
  (values src-end))

(defun xfopm-symbol (xfopm)
  (etypecase xfopm
    (xlib:font (getf (xlib:font-plist xfopm) 'tv:font-name))
    (xlib:pixmap (tv:font-name (getf (xlib:pixmap-plist xfopm) 'tv:font)))))

(defun xfopm-max-char (xfopm)
  (etypecase xfopm
    (xlib:font (xlib:font-max-char xfopm))
    (xlib:pixmap (1- (tv:font-fill-pointer (getf (xlib:pixmap-plist xfopm) 'tv:font))))))

(defun xfopm-min-char (xfopm)
  (etypecase xfopm
    (xlib:font (xlib:font-min-char xfopm))
    (xlib:pixmap 0)))

(defun xfopm-char-exists-p (xfopm index)
  (etypecase xfopm
    (xlib:font (<= (xlib:font-min-char xfopm) index (xlib:font-max-char xfopm)))
    (xlib:pixmap (< index (tv:font-fill-pointer (getf (xlib:pixmap-plist xfopm) 'tv:font))))))

(defun xfopm-char-width (xfopm charset)
  (etypecase xfopm
    (xlib:font
      (flet ((width (idx)
	       (when (and idx (<= (xlib:font-min-char xfopm) idx (xlib:font-max-char xfopm)))
		 (let ((w (xlib:char-width xfopm idx))) (and w (plusp w) w)))))
	(or (width (xlib:font-default-char xfopm))
	    (and (eq charset si:*standard-character-set*)
		 (width (si:char-subindex #\Space)))
	    (xlib:max-char-width xfopm))))
    (xlib:pixmap (tv:font-char-width (getf (xlib:pixmap-plist xfopm) 'tv:font)))))

(defun xfopm-vector-char-width (xfopm-vector charset)
  (let ((xfopm-vector xfopm-vector))
    (declare (sys:array-register xfopm-vector))
    (loop with xfopm-frequency-alist
	  for xfopm being the array-elements of xfopm-vector
	  when xfopm
	    do (incf (cdr (or (assoc xfopm xfopm-frequency-alist)
			      (car (push (cons xfopm 0) xfopm-frequency-alist)))))
	  finally
	    (return
	      (loop with most-frequent-xfopm
		    with highest-frequency = -1
		    for (xfopm . frequency) in xfopm-frequency-alist
		    when (> frequency highest-frequency)
		      do (setq most-frequent-xfopm xfopm highest-frequency frequency)
		    finally (return (xfopm-char-width most-frequent-xfopm charset)))))))

(defun xfopm-baseline (xfopm)
  (etypecase xfopm
    (xlib:font (xlib:font-ascent xfopm))
    (xlib:pixmap (tv:font-baseline (getf (xlib:pixmap-plist xfopm) 'tv:font)))))

(defun xfopm-vector-baseline (xfopm-vector)
  (let ((xfopm-vector xfopm-vector))
    (declare (sys:array-register xfopm-vector))
    (loop for xfopm being the array-elements of xfopm-vector
	  when xfopm maximize (xfopm-baseline xfopm))))

(defun xfopm-line-spacing (xfopm)
  (etypecase xfopm
    (xlib:font (+ (xlib:font-ascent xfopm) (xlib:font-descent xfopm)))
    (xlib:pixmap (tv:font-char-height (getf (xlib:pixmap-plist xfopm) 'tv:font)))))

(defun xfopm-vector-line-spacing (xfopm-vector)
  (let ((xfopm-vector xfopm-vector))
    (declare (sys:array-register xfopm-vector))
    (loop for xfopm being the array-elements of xfopm-vector
	  when xfopm maximize (xfopm-line-spacing xfopm))))

(defun xfopm-bcd (xfopm index bcd-char-code baseline)
  (etypecase xfopm
    (xlib:font
      (let ((width (+ (xlib:char-left-bearing xfopm index)
		      (xlib:char-right-bearing xfopm index)))
	    (height (+ (xlib:char-ascent xfopm index)
		       (xlib:char-descent xfopm index))))
	(fed::make-bchar-descriptor
	  :dimensions (fed::bitbltable-dims width height)
	  :char-code bcd-char-code
	  :left-kern (- (xlib:char-left-bearing xfopm index))
	  :top-kern (- (xlib:char-ascent xfopm index) baseline)
	  :set-width (xlib:char-width xfopm index)
	  :raster-width width
	  :raster-height height)))
    (xlib:pixmap
      (let* ((tvfont (getf (xlib:pixmap-plist xfopm) 'tv:font))
	     (width (let ((it (tv:font-indexing-table tvfont)))
		      (if it (- (aref it (1+ index)) (aref it index))
			(tv:font-raster-width tvfont))))
	     (height (tv:font-raster-height tvfont)))
	(fed::make-bchar-descriptor
	  :dimensions (fed::bitbltable-dims width height)
	  :char-code bcd-char-code
	  :left-kern (let ((lkt (tv:font-left-kern-table tvfont)))
		       (if lkt (aref lkt index) 0))
	  :top-kern (- (tv:font-baseline tvfont) baseline)
	  :set-width (let ((cwt (tv:font-char-width-table tvfont)))
		       (if cwt (aref cwt index) (tv:font-char-width tvfont)))
	  :raster-width width
	  :raster-height height)))))

(defun xfopm-vector-bfd (xfopm-vector index-vector font-symbol charset)
  (loop with baseline = (xfopm-vector-baseline xfopm-vector)
	with line-spacing = (xfopm-vector-line-spacing xfopm-vector)
	with char-width = (xfopm-vector-char-width xfopm-vector charset)
	with length = (length xfopm-vector)
	with bfd = (fed::make-bfont-descriptor
		     :length length
		     :fill-pointer length
		     :name font-symbol
		     :baseline baseline
		     :line-spacing line-spacing
		     :char-width char-width
		     :plist (list 'xfopm-vector xfopm-vector 'index-vector index-vector))
	for i below length
	for xfopm being the array-elements of xfopm-vector
	for index being the array-elements of index-vector
	when xfopm
	  do (setf (aref bfd i) (xfopm-bcd xfopm index i line-spacing))
	finally (return bfd)))

(defun xfopm-vector-tvfont (xfopm-vector index-vector font-symbol charset)
  (fed:font-from-bfd (xfopm-vector-bfd xfopm-vector index-vector font-symbol charset)))

(defun tvfont-text-width (tvfont indices nindices)
  (declare (values width last-width))
  (let ((cwt (tv:font-char-width-table tvfont)))
    (if cwt
	(let ((indices indices)
	      (cwt cwt))
	  (declare (sys:array-register indices cwt))
	  (loop for i below nindices
		for index = (aref indices i)
		for last-width first 0 then width
		summing (aref cwt index) into width
		finally (return (values width last-width))))
      (let* ((cw (tv:font-char-width tvfont))
	     (last-width (* cw (1- nindices))))
	(values (+ last-width cw) last-width)))))

(defun tvfont-text-bounds (tvfont indices nindices x baseline-y)
  (declare (values left top right bottom new-x))
  (if (zerop nindices)
      (values x baseline-y x baseline-y x)
    (multiple-value-bind (width last-width) (tvfont-text-width tvfont indices nindices)
      (let* ((lkt (tv:font-left-kern-table tvfont))
	     (it (tv:font-indexing-table tvfont))
	     (top (- baseline-y (tv:font-baseline tvfont)))
	     (bottom (+ top (tv:font-char-height tvfont)))
	     (new-x (+ x width))
	     (last-x (+ x last-width))
	     (index (aref indices 0))
	     (last-index (aref indices (1- nindices))))
	(if (< x new-x)
	    (values (+ x
		       (if lkt (aref lkt index) 0))
		    top
		    (+ last-x
		       (if lkt (aref lkt last-index) 0)
		       (if it (- (aref it (1+ last-index)) (aref it last-index))
			 (tv:font-raster-width tvfont)))
		    bottom
		    new-x)
	  (values
	    (+ last-x
	       (if lkt (aref lkt last-index) 0))
	    top
	    (+ x
	       (if lkt (aref lkt index) 0)
	       (if it (- (aref it (1+ index)) (aref it index))
		 (tv:font-raster-width tvfont)))
	    bottom
	    new-x))))))

(defun xfopm-text-bounds (xfopm indices nindices x baseline-y)
  (declare (values left top right bottom new-x))
  (if (zerop nindices)
      (values x baseline-y x baseline-y x)
    (etypecase xfopm
      (xlib:font
	(let ((tvfont (getf (xlib:font-plist xfopm) 'tv:font)))
	  (if tvfont (tvfont-text-bounds tvfont indices nindices x baseline-y)
	    (multiple-value-bind (width ascent descent left right)
		(xlib:text-extents xfopm indices :end nindices :translate #'identity-translate)
	      (values (- x left) (- baseline-y ascent) (+ x right) (+ baseline-y descent)
		      (+ x width))))))
      (xlib:pixmap
	(tvfont-text-bounds (getf (xlib:pixmap-plist xfopm) 'tv:font) indices nindices
			    x baseline-y)))))

(defun xlfd-name (&key foundry family weight slant set-width style
		  pixel-size point-size resolution-x resolution-y spacing average-width
		  charset-registry charset-encoding)
  (format nil "-~A-~A-~A-~A-~A~@[-~A~]--~A-~A-~A-~A-~A-~A-~A-~A"
	  (or foundry "*") (or family "*") (or weight "*") (or slant "*") (or set-width "*")
	  style (or pixel-size "*") (or point-size "*") (or resolution-x "*")
	  (or resolution-y "*") (or spacing "*") (or average-width "*")
	  (or charset-registry "*") (or charset-encoding "*")))

(defun find-matching-font-name
       (display families weights slants setwidths sizes &rest xlfd-name-options)
  (multiple-value-bind (families weights slants setwidths sizes)
      (flet ((option-or-list (option list)
	       (let ((value (getf xlfd-name-options option)))
		 (if value (ncons value) list))))
	(values (option-or-list :family families)
		(option-or-list :weight weights)
		(option-or-list :slant slants)
		(option-or-list :set-width setwidths)
		(option-or-list :pixel-size sizes)))
    (let ((candidates
	    (mapcar #'(lambda (name)
			(string-right-trim (string (code-char 0)) name))
		    (xlib:list-font-names
		      display
		      (apply #'xlfd-name
			     :family (and (null (cdr families)) (car families))
			     :weight (and (null (cdr weights)) (car weights))
			     :slant (and (null (cdr slants)) (car slants))
			     :set-width (and (null (cdr setwidths)) (car setwidths))
			     :pixel-size (and (null (cdr sizes)) (car sizes))
			     xlfd-name-options)))))
      (dolist (family families)
	(dolist (weight weights)
	  (dolist (slant slants)
	    (dolist (setwidth setwidths)
	      (dolist (size sizes)
		(let ((wildspec
			(apply #'xlfd-name
			       :family family
			       :weight weight
			       :slant slant
			       :set-width setwidth
			       :pixel-size size
			       xlfd-name-options)))
		  (dolist (candidate candidates)
		    (when (fs:wildcard-match wildspec candidate)
		      (return-from find-matching-font-name
			(intern (string-upcase candidate)
				si:pkg-fonts-package)))))))))))))

(defflavor x-display-device
	((initialized nil)
	 (console nil)
	 (display-device nil)
	 (xfopm-table (make-hash-table :test 'eq))
	 (tvfont-table (make-hash-table :test 'eq))
	 (present-tvfont-table (make-hash-table :test 'eq))
	 (present-xfont-table (make-hash-table :test 'eq))
	 (xfopm-vector-table (make-hash-table :test 'eq))
	 (index-vector-table (make-hash-table :test 'eq)))
	(si:display-device)
  (:initable-instance-variables console display-device)
  (:required-init-keywords :console :display-device)
  (:default-init-plist :name "X Screen"))

(defmethod (x-display-device-reset x-display-device) ()
  (setq initialized nil)
  (setq si:name "X Screen" si:pretty-name si:name)
  (clrhash xfopm-table)
  (clrhash tvfont-table)
  (clrhash present-tvfont-table)
  (clrhash present-xfont-table)
  (clrhash xfopm-vector-table)
  (clrhash index-vector-table)
  (loop for (nil table) on (cdr si:charsets&stylesspecs) by #'cddr
	do (clrhash table)))

(defmethod (x-display-device-initialize x-display-device) ()
  (x-display-device-reset self)
  (dolist (name (xlib:list-font-names (x-console-display console) "genera-*"))
    (let* ((string (string-upcase (subseq (string-right-trim (string (code-char 0)) name) 7)))
	   (symbol (intern string si:pkg-fonts-package)))
      (setf (gethash symbol present-tvfont-table) t)))
  (setq si:name
	(multiple-value-bind (vendor release)
	    (xlib:display-vendor (x-console-display console))
	  (let* ((screen (x-console-screen console))
		 (visual-info (xlib:screen-root-visual-info screen)))
	    (format nil "~D-bit ~A X Screen ~A:~D.~D~@[ for ~A~] with ~D Genera fonts (~A R~D)"
		    (xlib:screen-root-depth screen)
		    (xlib:visual-info-class visual-info)
		    (x-console-host console)
		    (x-console-display-number console)
		    (x-console-screen-number console)
		    (x-console-activity console)
		    (hash-table-count present-tvfont-table)
		    vendor release)))
	si:pretty-name si:name)
  (setq initialized t))

(defconstant *pixmap-font-glyphs-per-line* 256)

(defun-in-flavor (make-pixmap x-display-device) (tvfont-or-symbol)
  (let* ((tvfont (if (symbolp tvfont-or-symbol)
		     (fed:find-and-load-font tvfont-or-symbol)
		   tvfont-or-symbol))
	 (limit (tv:font-fill-pointer tvfont))
	 (it (tv:font-indexing-table tvfont))
	 (iwidth (if it (aref it limit) (* limit (tv:font-raster-width tvfont))))
	 (iheight (tv:font-raster-height tvfont))
	 (image (xlib:create-image :width iwidth :height iheight :depth 1 :data tvfont))
	 (pmwidth
	   (loop for index first 0 then next-index
		 until (= index limit)
		 for next-index = (min (+ index *pixmap-font-glyphs-per-line*) limit)
		 for src-x first 0 then next-src-x
		 for next-src-x = (if it (aref it next-index)
				    (* next-index (tv:font-raster-width tvfont)))
		 maximize (- next-src-x src-x)))
	 (pmheight (* iheight (sys:%fixnum-ceiling limit *pixmap-font-glyphs-per-line*))))
    (with-pixmap ((pm gc) pmwidth pmheight 1 (x-console-window console))
      (setf (getf (xlib:pixmap-plist pm) 'tv:font) tvfont)
      (loop for index first 0 then next-index
	    until (>= index limit)
	    for next-index = (min (+ index *pixmap-font-glyphs-per-line*) limit)
	    for src-x first 0 then next-src-x
	    for next-src-x = (if it (aref it next-index)
			       (* next-index (tv:font-raster-width tvfont)))
	    for y upfrom 0 by iheight
	    unless (= next-src-x src-x)
	      do (xlib:put-image pm gc image :x 0 :y y
				 :src-x src-x
				 :width (- next-src-x src-x)
				 :height iheight))
      (shiftf pm nil))))

(defun-in-flavor (make-xfont x-display-device) (symbol)
  (let ((xfont
	  (xlib:open-font
	    (x-console-display console)
	    (let ((string (symbol-name symbol)))
	      (if (gethash symbol present-tvfont-table)
		  (string-append "GENERA-" string)
		string)))))
    (setf (getf (xlib:font-plist xfont) 'tv:font-name) symbol)
    (when (boundp symbol)
      (setf (getf (xlib:font-plist xfont) 'tv:font) (symbol-value symbol)))
    xfont))

(defmethod (x-display-device-xfopm-lookup x-display-device) (tvfont-or-symbol)
  (let ((symbol (if (symbolp tvfont-or-symbol)
		    tvfont-or-symbol
		  (tv:font-name tvfont-or-symbol))))
    (or (gethash symbol xfopm-table)
	(setf (gethash symbol xfopm-table)
	      (if (or (gethash symbol present-xfont-table)
		      (gethash symbol present-tvfont-table)
		      (and (not (fed:font-boundp symbol))
			   ;; If the font symbol isn't in the
			   ;; present-xfont-table or the present-tvfont-table
			   ;; and it isn't bound to a tvfont struct, it's
			   ;; either an X font we don't know about or a tvfont
			   ;; stored in a file somewhere.  Check whether it's
			   ;; an x font.  Don't worry about this taking a
			   ;; round trip, because certainly looking for a file
			   ;; will take a while too.
			   (let ((names 
				   (xlib:list-font-names
				     (x-console-display console)
				     (symbol-name symbol))))
			     (and (= (length names) 1)
				  (string-equal (first names) (symbol-name symbol))
				  (setf (gethash symbol present-xfont-table) t)))))
		  (make-xfont symbol)
		(make-pixmap tvfont-or-symbol))))))

(defmethod (x-display-device-indexed-xfopm-lookup x-display-device) (tvfont-or-symbol index)
  (declare (values xfopm index xfopm-vector index-vector))
  (let* ((symbol (if (symbolp tvfont-or-symbol)
		     tvfont-or-symbol
		   (tv:font-name tvfont-or-symbol)))
	 (xfopm-vector (gethash symbol xfopm-vector-table))
	 (index-vector (gethash symbol index-vector-table)))
    (if (and xfopm-vector index-vector)
	(values (aref xfopm-vector index) (aref index-vector index) xfopm-vector index-vector)
      (values (x-display-device-xfopm-lookup self tvfont-or-symbol) index nil nil))))

(defun-in-flavor (get-xfopm-vector x-display-device) (charset style tvfont-or-nil)
  (declare (values xfopm-vector index-vector font-symbol))
  (let* ((families (cs-families charset style))
	 (weights (cs-weights charset style))
	 (slants (cs-slants charset style))
	 (setwidths (cs-setwidths charset style))
	 (sizes (cs-sizes charset style)))
    (when (and families weights slants setwidths sizes)
      (loop with length = (if tvfont-or-nil
			      (tv:font-fill-pointer tvfont-or-nil)
			    (send charset :n-characters))
	    with xfopm-vector = (make-array length)
	    with index-vector = (make-array length)
	    with font-symbol
	    with symbols
	    for (xlfd-options mapping-vector) in
		(cdr (assoc charset *font-charset-mapping-alist*))
	    for symbol = (apply #'find-matching-font-name
				(x-console-display console)
				families weights slants setwidths sizes
				xlfd-options)
	    while symbol
	    do (setf (gethash symbol present-xfont-table) t)
	       (push symbol symbols)
	       (loop with xfopm
		     for index below (min length (length mapping-vector))
		     for mapping = (aref mapping-vector index)
		     unless (or (null mapping) (aref xfopm-vector index))
		       do (unless xfopm
			    (setq xfopm (x-display-device-xfopm-lookup self symbol)))
			  (when (xfopm-char-exists-p xfopm mapping)
			    (setf (aref xfopm-vector index) xfopm
				  (aref index-vector index) mapping)))
	    finally
	      (when tvfont-or-nil
		(loop with tvfont = tvfont-or-nil
		      with cet = (tv:font-chars-exist-table tvfont)
		      with xfopm 
		      for index below (min length (tv:font-fill-pointer tvfont))
		      unless (or (aref xfopm-vector index)
				 (and cet (null (aref cet index))))
			do (setf (aref xfopm-vector index)
				 (or xfopm
				     (setq xfopm (x-display-device-xfopm-lookup self tvfont)))
				 (aref index-vector index) index)))
	      (when symbols
		(setq font-symbol
		      (intern
			(format nil "XFONT.~@[~A.~]~A.~A.~A"
				(and (neq charset si:*standard-character-set*)
				     (string-upcase (send charset :name)))
				(symbol-name (si:cs-family style))
				(symbol-name (si:cs-face style))
				(symbol-name (si:cs-size style)))
			si:pkg-fonts-package))
		(setf (gethash font-symbol xfopm-vector-table) xfopm-vector)
		(setf (gethash font-symbol index-vector-table) index-vector))
	      (return (values xfopm-vector index-vector font-symbol))))))

(defun-in-flavor (get-xfopm-vector-tvfont-mapping x-display-device)
		 (symbol charset style tvfont-or-nil)
  (let ((xfopm-vector (gethash symbol xfopm-vector-table))
	(index-vector (gethash symbol index-vector-table))
	(font-symbol symbol))
    (unless (and xfopm-vector index-vector font-symbol)
      (multiple-value-setq (xfopm-vector index-vector font-symbol)
	(get-xfopm-vector charset style tvfont-or-nil)))
    (when font-symbol
      (xfopm-vector-tvfont xfopm-vector index-vector font-symbol charset))))

(defwhopper (:get-mapping x-display-device) (charset style &optional inquiry-only)
  (if (null initialized)
      (send display-device :get-mapping charset style inquiry-only)
    (let ((spec (continue-whopper charset style inquiry-only)))
      (or (and (or (not (symbolp spec)) inquiry-only) spec)
	  (and spec (gethash spec tvfont-table))
	  (let ((display-device-spec (send display-device :get-mapping charset style)))
	    (if (typep display-device-spec 'tv:font)
		(let ((tvfont display-device-spec))
		  (unless (gethash (tv:font-name tvfont) present-tvfont-table)
		    (let ((tvf (get-xfopm-vector-tvfont-mapping spec charset style tvfont)))
		      (when tvf (setq tvfont tvf))))
		  (when tvfont
		    (setf (gethash (tv:font-name tvfont) tvfont-table) tvfont)
		    (when (neq spec (tv:font-name tvfont))
		      (send self :set-mapping charset style (tv:font-name tvfont))))
		  (if (and inquiry-only tvfont) (tv:font-name tvfont) tvfont))
	      display-device-spec))))))

(defmethod (:set-mapping x-display-device :after) (charset style spec)
  (when (and (eq (si:cs-family style) :device-font)
	     (typep spec '(or symbol tv:font)))
    (send display-device :set-mapping charset style spec)))

(defmethod (x-display-device-describe-font-mapping x-display-device) ()
  (let ((xfonts nil)
	(pixmaps nil))
    (loop for xfopm being the hash-elements of xfopm-table with-key symbol
	  when (xlib:font-p xfopm) do (push (cons symbol xfopm) xfonts)
	  when (xlib:pixmap-p xfopm) do (push (cons symbol xfopm) pixmaps))
    (if (null xfonts)
	(format t "~2&No server fonts are being used.~%")
      (format t "~2&The server font~P being used ~A "
	      (length xfonts) (if (cdr xfonts) "are" "is"))
      (format-textual-list
	xfonts
	#'(lambda (pair stream)
	    (destructuring-bind (symbol . xfont) pair
	      (dw:with-output-as-presentation (:stream stream :object xfont)
		(princ symbol stream))))
	:filled t :conjunction "and" :after-line-break "  ")
      (format t ".~%"))
    (if (null pixmaps)
	(format t "~2&No fonts are currently displayed by using pixmaps and draw-rectangle.~%")
      (format t "~2&Pixmaps are being used to display the font~P " (length pixmaps))
      (format-textual-list
	pixmaps
	#'(lambda (pair stream)
	    (destructuring-bind (symbol . pixmap) pair
	      (dw:with-output-as-presentation (:stream stream :object pixmap)
		(princ symbol stream))))
	:filled t :conjunction "and" :after-line-break "  ")
      (format t ".~%")))
  (loop for (charset table) on (cdr si:charsets&stylesspecs) by #'cddr
	for mappings =
	    (loop for spec being the hash-elements of table with-key style
		  when (and (symbolp spec)
			    (eq (symbol-package spec) si:pkg-fonts-package))
		    collect (cons style (or (gethash spec tvfont-table) spec)))
	when mappings
	  do (format t "~2&Character style to font mappings~@[ for the ~A character set~]:~%"
		     (and (neq charset si:*standard-character-set*) charset))
	     (loop for (style . spec) in mappings do (format t "~&  ~A  ~A" style spec)))
  (let ((generated-fonts
	  (loop for xfopm-vector being the hash-elements of xfopm-vector-table with-key symbol
		collect
		  (cons symbol
			(loop with xfopms
			      for xfopm being the array-elements of xfopm-vector
			      when xfopm
				do (pushnew xfopm xfopms)
			      finally (return (nreverse xfopms)))))))
    (when generated-fonts
      (format t "~2&Generated fonts and their components:~%")
      (loop for (symbol . xfopms) in generated-fonts
	    do (format t "~&  ~A: " (gethash symbol tvfont-table))
	       (format-textual-list
		 xfopms
		 #'(lambda (xfopm stream)
		     (dw:with-output-as-presentation (:stream stream :object xfopm)
		       (princ 
			 (etypecase xfopm
			   (xlib:font
			     (or (getf (xlib:font-plist xfopm) 'tv:font)
				 (getf (xlib:font-plist xfopm) 'tv:font-name)))
			   (xlib:pixmap
			     (getf (xlib:pixmap-plist xfopm) 'tv:font)))
			 stream)))
		 :filled t :conjunction "and" :after-line-break "    ")))))

(compile-flavor-methods x-display-device)
