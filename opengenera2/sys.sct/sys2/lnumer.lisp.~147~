;;; -*- Mode: LISP; Package: SYSTEM-INTERNALS; Base: 10; Lowercase: T; Syntax: Zetalisp -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; 3600 Floating-Point Constants and Routines

(eval-when (compile load eval)

(defconstant most-positive-single-float
	     (%flonum (dpb (1- %single-exponent-max)
			     %%single-exponent
			     (dpb -1 %%single-fraction 0))))

(defconstant most-negative-single-float
	     (- most-positive-single-float))

(defconstant infinite-positive-single-float
	     (%flonum (dpb %single-exponent-max %%single-exponent 0)))

(defconstant infinite-negative-single-float
	     (- infinite-positive-single-float))

(defconstant most-positive-double-float
	     (%make-double (dpb (1- %double-exponent-max)
				  %%double-exponent
				  (dpb -1 %%double-fraction-high 0))
			     -1))

(defconstant most-negative-double-float
	     (- most-positive-double-float))

(defconstant infinite-positive-double-float
	     (%make-double (dpb %double-exponent-max %%double-exponent 0)
			     0))

(defconstant infinite-negative-double-float
	     (- infinite-positive-double-float))

;;; N.B.  empirically, (// 1 pi) is correctly rounded in IEEE double-precision
(defconstant pi    3.1415926535897932384626433832795028841972L0)
(defconstant 1//90 0.011111111111111111111111111111111111111111L0)

(defconstant *double-eps*          (ash 1.0d0 -53))
(defconstant *eps*		   (ash 1.0 -24))

);eval-when
(eval-when (compile load eval)

(defconstant *inf-tanh-arg*	   (// (- (log *eps*)) 2))

(defconstant *double-sqrt-eps*     (sqrt *double-eps*))

(defconstant *double-inf-tanh-arg* (ash (- (log *double-eps*)) -1))

;(defconstant *double-sqrt-2*       1.41421356237309504880d0)
(defconstant *double-sqrt-1//2*    0.70710678118654752440d0)
(defconstant *double-log-2*        0.69314718055994530942d0)
(defconstant *double-log10-e*      0.43429448190325182765d0)
(defconstant *double-log2-e*       1.44269504088896340736d0)

);eval-when

(defdouble double-min (:double :double) :double double-min-function)
(defsubst double-min-function (x-high x-low y-high y-low)
  ;; can't use double-names stuff in a subst
  (if (minusp (%double-floating-compare x-high x-low y-high y-low))
      (values x-high x-low) (values y-high y-low)))

(defdouble double-max (:double :double) :double double-max-function)
(defsubst double-max-function (x-high x-low y-high y-low)
  ;; can't use double-names stuff in a subst
  (if (plusp (%double-floating-compare x-high x-low y-high y-low))
      (values x-high x-low) (values y-high y-low)))

(defdouble double-aref (:array :integer) :double double-aref-function)
(defun double-aref-function (array integer)
  (values (aref array integer) (aref array (1+ integer))))

(defdouble double-aset (:double :array :integer) nil double-aset-function)
(defun double-aset-function (double-high double-low array integer)
  (with-double-names (double)
    (setf (aref array integer) double-high)
    (setf (aref array (1+ integer)) double-low)))

(defsubst values-with-typed-zero (val)
  (let ((x val)) (values x (typed-zero x))))

(defun typed-zero (typed-number)
  (typecase typed-number
    (:complex (complex (typed-zero (complex-realpart typed-number))))
    (:double-float 0.0d0)
    (:single-float 0.0f0)
    (otherwise 0)))

(defun typed-one (typed-number)
  (typecase typed-number
    (:complex (complex (typed-one (complex-realpart typed-number))))
    (:double-float 1.0d0)
    (:single-float 1.0f0)
    (otherwise 1)))

(defun coerce-number-to-type-of-number (number typed-number)
  (typecase typed-number
    (:single-float (float number))
    (:double-float (dfloat number))
    (:complex (complex (coerce-number-to-type-of-number number
							(complex-realpart typed-number))))
    (otherwise number)))

(defun coerce-number-to-type (number type)
  (selectq type
    (:single-float (float number))
    (:double-float (dfloat number))
    (:complex (typecase number			;Disgusted yet?
		(:complex number)
		(otherwise (complex number))))
    (:rational (rational number))
    (otherwise (ferror "Unknown number type ~S" type))))

(defun type-of-numeric-result (first second)
  (typecase first
    (:complex :complex)
    (:double-float
     (if (typep second :complex)
	 :complex
	 :double-float))
    (:single-float
     (typecase second
       (:complex :complex)
       (:double-float :double-float)
       (otherwise :single-float)))
    (otherwise (typecase second
		 (:complex :complex)
		 (:double-float :double-float)
		 (:single-float :single-float)
		 (otherwise :rational)))))

(defsubst cos-and-sin (real-x) (cis-components real-x))
(defsubst cosd-and-sind (real-x) (cisd-components real-x))

(defdouble double-decode-float (:double) :double double-decode-float-components)
(defun double-decode-float-components (double-high double-low)
  (let ((sign (if (minusp double-high) -1.0d0 1.0d0)))
    (select (ldb %%double-exponent double-high)
      (0					;zero or denormalized
       (let ((high-fraction (ldb %%double-fraction-high double-high)))
	 (if (and (zerop high-fraction) (zerop double-low))
	     (values 0 0 0 sign)
	   ;; normalize and smash the exponent
	   (let* ((fraction (dpb double-low (byte 32 0)
				 (ash high-fraction 32)))
		  (fraction-length (haulong fraction))
		  (normalized-fraction (ash fraction (- 53 fraction-length))))
	     (values (dpb (1- %double-exponent-bias) %%double-exponent
			  (ldb (byte 20 32) normalized-fraction))
		     (%logdpb (ldb (byte 1 31) normalized-fraction) (byte 1 31)
			      (ldb (byte 31 0) normalized-fraction))
		     (- fraction-length
			(+ (- %double-exponent-bias 1) 52))
		     sign)))))
      (%double-exponent-max
       (values (ldb %%double-fraction-high double-high)
	       double-low
	       (if (and (zerop double-low)
			(zerop (ldb %%double-fraction-high double-high)))
		   ':infinity ':nan)
	       sign))
      (otherwise				;normalized
       ;; it's normalized -- just smash the exponent
       (values (%logdpb 0 %%double-sign
			(%logdpb (- %double-exponent-bias 1) %%double-exponent double-high))
	       double-low
	       (- (ldb %%double-exponent double-high) (- %double-exponent-bias 1))
	       sign)))))

(defsubst normalize-denormalized-single (float)
  ;; resulting exponent will be %single-exponent-bias - 2 + 24. too big
  (float (ldb %%single-fraction (%fixnum float))))

(defun decode-float (float)
  (declare lt:(side-effects simple reducible))
  (declare (values fraction exponent sign))
  (cl:etypecase float
    (cl:single-float
     (let ((sign (if (minusp (%fixnum float)) -1.0 1.0)))
       (select (ldb %%single-exponent (%fixnum float))
	 (0					;zero or denormalized
	  (if (zerop float)
	      (values 0.0 0 sign)
	    ;; normalize and smash the exponent
	    (let ((normalized (%fixnum (normalize-denormalized-single float))))
	      (values (%flonum (%logdpb (- %single-exponent-bias 1)
					%%single-exponent normalized))
		      (- (ldb %%single-exponent normalized)
			 (+ (- %single-exponent-bias 1) (- %single-exponent-bias 2) 24.))
		      sign))))
	 (%single-exponent-max
	  (let ((fraction (ldb %%single-fraction (%fixnum float))))
	    (values fraction
		    (if (zerop fraction) ':infinity ':nan)
		    sign)))
	 (otherwise				;normalized
	  ;; it's normalized -- just smash the exponent
	  (values (%flonum (%logdpb 0 %%single-sign
				    (%logdpb (- %single-exponent-bias 1) %%single-exponent
					     (%fixnum float))))
		  (- (ldb %%single-exponent (%fixnum float)) (- %single-exponent-bias 1))
		  sign)))))
    (cl:double-float
     (multiple-value-bind (fraction-high fraction-low exponent sign)
	 (double-decode-float (double-components float))
       (with-double-names (fraction)
	 (values (double-to-consed fraction) exponent sign))))))

(defun decode-float-of-float (number)
  ;; like (DECODE-FLOAT (FLOAT number)), but won't overflow or underflow
  (declare (values fraction exponent sign))
  (cl:etypecase number
    (cl:fixnum (decode-float (float number)))
    (cl:bignum (decode-float-of-bignum number))
    (cl:ratio (decode-float-of-rational number))
    (cl:single-float (decode-float number))
    (cl:double-float
      (multiple-value-bind (fraction-high fraction-low exponent sign)
	  (double-decode-float (double-components number))
	(with-double-names (fraction)
	  (multiple-value-bind (single-fraction single-exponent)
	      (decode-float (double-to-single fraction))
	    ;; account for possible rounding in double-to-single
	    (values single-fraction
		    (+ exponent single-exponent)
		    (float sign))))))))

(defun double-decode-float-of-float-components (number)
  ;; like (DECODE-FLOAT (DFLOAT number)), but won't overflow or underflow
  (declare (values fraction-high fraction-low exponent sign))
  (cl:typecase number
    (cl:bignum
      (multiple-value-bind (x-sign high-digit next-digit shift rest-zerop)
	  (decode-bignum-high-bits number)
	;; shift 64 bits down to 56.  (- 64. 56.) = 8
	(setq shift (+ shift 8)
	      rest-zerop (and rest-zerop (zerop (ldb (byte 8 0) next-digit)))
	      next-digit (%lshc-bignum-step next-digit high-digit (- 32. 8.))
	      high-digit (lsh high-digit -8))
	;; maybe set sticky bit
	(when (and (evenp next-digit)
		   (not rest-zerop))
	  (setq next-digit (logior next-digit 1)))
	;; round appropriately
	(multiple-value-bind (hd-high-29 hd-low-3 nd-high-3 nd-low-29)
	    (values (ldb (byte 29. 3) high-digit)
		    (ldb (byte 3   0) high-digit)
		    (ldb (byte 3 29.) next-digit)
		    (ldb (byte 29. 0) next-digit))
	  (let ((new-nd-low-30 (right-ash-and-round-fraction nd-low-29 3 x-sign)))
	    ;; ash the rest right, ADDING back in new-next-digit, etc etc.
	    (multiple-value-bind (nd-all-32 carry)
		(%add-bignum-step new-nd-low-30 (%logdpb hd-low-3 (byte 3 29.)
							 (dpb nd-high-3 (byte 3 26.) 0))
				  0)
	      (setq high-digit (%32-bit-plus hd-high-29 carry)
		    next-digit nd-all-32))
	    (incf shift 3)))
	(values (dpb high-digit %%double-fraction-high
		     (dpb (- %double-exponent-bias 1)
			  %%double-exponent 0))
		next-digit
		(+ 53. shift (ldb (byte 1 21.) high-digit))
		(if (minusp x-sign) -1.0d0 1.0d0))))
    (cl:ratio
      (let* ((numerator (abs (rational-numerator number)))
	     (denominator (rational-denominator number))
	     (shift-factor (+ (- (haulong denominator) (haulong numerator))
			      56.))		;<significant digits>+G+R+S
	     (quotient (logior (// (ash numerator shift-factor) denominator) 1)))
	;; We want to set the sticky bit if either we shifted ones from the end of
	;; the numerator, or the remainder is non-zero.  Fortunately, the rational
	;; came in normalized, so if we didn't lose any ones, the remainder must be
	;; non-zero.  So we always set the sticky bit.
       
	;; The FLOAT will do correct rounding, and the ASH will check the range
	(multiple-value-bind (high low expt sign)
	    (double-decode-float (double-dfloat (if (minusp number) (- quotient) quotient)))
	  (values high low
		  (- expt shift-factor)
		  sign))))
    (otherwise
      (double-decode-float (double-dfloat number)))))

(defdouble double-integer-decode-float (:double) :three-integers
	   double-integer-decode-float-components)
(defun double-integer-decode-float-components (d-high d-low)
  (let ((exponent (ldb %%double-exponent d-high))
	(fraction (dpb d-high (byte 20. 32.)
		       (dpb d-low (byte 32. 0) 0)))
	(sign (- 1 (* (ldb %%double-sign d-high) 2))))
    (select exponent
      (0
       (values fraction
	       (if (zerop fraction) 0 (- 1 (+ %double-exponent-bias 52.)))
	       sign))
      (%double-exponent-max
       (values fraction (if (zerop fraction) ':infinity ':nan) sign))
      (otherwise
       (values (dpb 1 (byte 1 52.) fraction)
	       (- exponent (+ %double-exponent-bias 52.))
	       sign)))))

(defun integer-decode-float (float)
  (declare lt:(side-effects simple reducible))
  (declare (values integer exponent sign))
  (cl:etypecase float
    (cl:single-float
     (let ((exponent (ldb %%single-exponent (%fixnum float)))
	   (fraction (ldb %%single-fraction (%fixnum float)))
	   (sign (- 1 (* (ldb %%single-sign (%fixnum float)) 2))))
       (select exponent
	 (0
	  (values fraction
		  (if (zerop fraction) 0 (- 1 (+ %single-exponent-bias 23.)))
		  sign))
	 (%single-exponent-max
	  (values fraction (if (zerop fraction) ':infinity ':nan) sign))
	 (otherwise
	  (values (dpb 1 (byte 1 23.) fraction)
		  (- exponent (+ %single-exponent-bias 23.))
		  sign)))))
    (cl:double-float
     (double-integer-decode-float (double-components float)))))

(defun nextafter (x y)
  (declare lt:(side-effects simple reducible))
  ;; returns the next representable floating-point neighbor of x in the direction toward y
  (cl:etypecase x
    (cl:single-float
      (cond ((= x y)
	     x)
	    ((zerop x)				;zeros are signed
	     (if (< x y)
		 (%flonum 1)
		 (%flonum (%logdpb -1 %%single-sign 1))))
	    ((neq (< x y) (minusp x))
	     (%flonum (1+ (%fixnum x))))
	    (t
	     (%flonum (1- (%fixnum x))))))
    (cl:double-float
      (with-double-components (x x-high x-low)
	(cond ((= x y)
	       x)
	      ((zerop x)			;zeros are signed
	       (if (< x y)
		   (%make-double 0 1)
		   (%make-double (%logdpb -1 %%double-sign 0) 1)))
	      ((neq (< x y) (minusp x))
	       (if (= x-low -1)			;increment with carry
		   (%make-double (1+ x-high) 0)
		   (%make-double x-high (1+ x-low))))
	      (t 
	       (if (= x-low 0)			;decrement with carry
		   (%make-double (1- x-high) -1)
		   (%make-double x-high (1- x-low)))))))))

(defun dfloat-components (x)
  (cl:etypecase x
    (cl:fixnum (integer-to-double x))
    (cl:single-float (single-to-double x))
    (cl:bignum
     (multiple-value-bind (x-sign high-digit next-digit shift rest-zerop)
	 (decode-bignum-high-bits x)
       ;; shift 64 bits down to 56.  (- 64. 56.) = 8
       (setq shift (+ shift 8)
	     rest-zerop (and rest-zerop (zerop (ldb (byte 8 0) next-digit)))
	     next-digit (%lshc-bignum-step next-digit high-digit (- 32. 8.))
	     high-digit (lsh high-digit -8))
       ;; maybe set sticky bit
       (when (and (evenp next-digit)
		  (not rest-zerop))
	 (setq next-digit (logior next-digit 1)))
       ;; round appropriately
       (multiple-value-bind (hd-high-29 hd-low-3 nd-high-3 nd-low-29)
	   (values (ldb (byte 29. 3) high-digit)
		   (ldb (byte 3   0) high-digit)
		   (ldb (byte 3 29.) next-digit)
		   (ldb (byte 29. 0) next-digit))
	 (let ((new-nd-low-30 (right-ash-and-round-fraction nd-low-29 3 x-sign)))
	   ;; ash the rest right, ADDING back in new-next-digit, etc etc.
	   (multiple-value-bind (nd-all-32 carry)
	       (%add-bignum-step new-nd-low-30 (%logdpb hd-low-3 (byte 3 29.)
							(dpb nd-high-3 (byte 3 26.) 0))
				 0)
	     (setq high-digit (%32-bit-plus hd-high-29 carry)
		   next-digit nd-all-32))
	   (incf shift 3)))
       (double-ash (double-pair (%logdpb x-sign %%double-sign
					 (dpb high-digit %%double-fraction-high
					      (dpb (+ %double-exponent-bias -1 53.)
						     %%double-exponent 0)))
				next-digit)
		   ;; shift accounting for possible round up
		   (+ shift (ldb (byte 1 21.) high-digit)))))
    (cl:ratio
     (let* ((numerator (abs (rational-numerator x)))
	    (denominator (rational-denominator x))
	    (shift-factor (+ (- (haulong denominator) (haulong numerator))
			     56.))		;<significant digits>+G+R+S
	    (quotient (logior (// (ash numerator shift-factor) denominator) 1)))
       ;; We want to set the sticky bit if either we shifted ones from the end of
       ;; the numerator, or the remainder is non-zero.  Fortunately, the rational
       ;; came in normalized, so if we didn't lose any ones, the remainder must be
       ;; non-zero.  So we always set the sticky bit.
       
       ;; The FLOAT will do correct rounding, and the ASH will check the range
       (double-ash (double-dfloat (if (minusp x) (- quotient) quotient))
		   (- shift-factor))))
    (cl:double-float (%fast-double-components x))))

(defun dfloat (number)
  (declare lt:(side-effects simple reducible))
  (if (double-float-p number)
      number					; special case to avoid consing
      (double-to-consed (double-dfloat number))))

(defdouble double-ftrunc (:double) :double double-ftrunc-components)
(defdouble double-ffloor (:double) :double double-ffloor-components)

(defdouble single-extended-scale-and-floor (:single :double) :integer-and-float
	   single-extended-scale-and-floor-components)
(defun single-extended-scale-and-floor-components (x scale-high scale-low)
  (with-double-names (scale)
    (double-let* ((cli::double (double-* (single-to-double x) scale)))
      (cli::integer-quotient-double-1-double-arg
	(floor cl:integer cl:single-float cli::quotient-and-remainder)
	cli::double))))

(defdouble single-to-double-scale-and-floor (:single :double) :integer-and-double
	   single-to-double-scale-and-floor-components)
(defun single-to-double-scale-and-floor-components (x scale-high scale-low)
  (with-double-names (scale)
    (double-let* ((cli::double (double-* (single-to-double x) scale)))
      (cli::integer-quotient-double-1-double-arg
	(floor cl:integer cli::unboxed-double cli::quotient-and-remainder)
	cli::double))))

(defconstant %%high-3-bits (byte 3 29.))
(defconstant %%low-3-bits (byte 3 0))

(defdouble dsqrt-aux (:double) :double dsqrt-components-aux)
(defun dsqrt-components-aux (high low)
  (let ((saved-inexact-flag (float-flag? :inexact-result)))
    (with-double-names ((double-x (high low)))
      (with-float-operating-mode ((:round :zero) (:trap-disables :inexact-result))
	;;"chopped" floating-point arithmetic
	(let* ((unbiased-double-expt (- (ldb %%double-exponent high) %double-exponent-bias))
	       (x (%flonum (dpb (+ (ldb (byte 1 0) unbiased-double-expt)
				   %single-exponent-bias)
				%%single-exponent
				(%lshc-bignum-step low
						   (ldb %%double-fraction-high high)
						   3))))
	       (y (%flonum (+ (ldb (byte 31 1) (%fixnum x)) 127_22 -320000)))
	       ;;Now magically y approximates sqrt(x) to almost 5 sig. bits
	       ;;Heron's rule twice
	       (z (%flonum (- (%fixnum (+ y (// x y))) (+ 1_23 3149)))))
	  ;;z approximates sqrt(x) to over 11 sig. bits
	  ;; now switch to double-precision
	  (double-let* ((double-z (values (dpb (+ (ash unbiased-double-expt -1)
						  (- %double-exponent-bias
						     %single-exponent-bias)
						  (ldb %%single-exponent
						       (%fixnum z)))
					       %%double-exponent
					       (ldb (byte 20 3) (%fixnum z)))
					  (%logdpb (%fixnum z) (byte 3 29) 0)))
			(double-y (double-+ double-z (double-// double-x double-z))))
	    (decf double-y-high (dpb 1 %%double-exponent 0))	;divide by 2
	    (double-setq double-z (double-+ double-y (double-// double-x double-y)))
	    (decf double-z-high (dpb 1 %%double-exponent 0))	;divide by 2
	    (setf (float-flag? :inexact-result) nil)
	    (double-setq double-y (double-// double-x double-z))
	    (when (not (float-flag? :inexact-result))
	      (when (and (= double-y-high double-z-high)
			 (= double-y-low double-z-low))
		;; sqrt was exact, so restore the flag
		(setf (float-flag? :inexact-result) saved-inexact-flag)
		(return-from dsqrt-components-aux (double-value double-y)))
	      (when (zerop double-y-low)	;the following decrement will borrow
		(decf double-y-high))
	      (setq double-y-low (%32-bit-difference double-y-low 1)))
	    (setf (float-flag? :inexact-result) t)
;	    (unless (= (ldb %%double-exponent double-y-high)
;		       (ldb %%double-exponent double-z-high))
;	      (format t "~& exponent mismatch y = ~F   z = ~F"
;		      (double-to-consed double-y) (double-to-consed double-z)))
	    (if (not (float-trap-enable? :inexact-result .old-float-operating-mode.))
		;; add and divide by 2, using integer arithmetic, since the exponents are =
		(multiple-value-bind (sum-low carry)
		    (%add-bignum-step double-z-low double-y-low
				      (cond ((float-rounding-mode?
					       nearest .old-float-operating-mode.)
					     1)
					    ((float-rounding-mode?
					       plus .old-float-operating-mode.)
					     2)
					    (t 0)))
		  (let ((sum-high (%add-bignum-step double-z-high double-y-high carry)))
		    (values (ldb (byte 31 1) sum-high)
			    (%lshc-bignum-step sum-low sum-high 31))))
		(signal-proceed-case
		  ((value)
		   'float-inexact-result
		   :operation 'cl:sqrt
		   :operands (list (double-to-consed double-x))
		   :non-trap-result
		   (double-to-consed
		     (multiple-value-bind (sum-low carry)
			 (%add-bignum-step double-z-low double-y-low
					   (cond ((float-rounding-mode? nearest .old-float-operating-mode.)
						  1)
						 ((float-rounding-mode?
						    plus .old-float-operating-mode.)
						  2)
						 (t 0)))
		       (let ((sum-high (%add-bignum-step double-z-high double-y-high carry)))
			 (values (ldb (byte 31 1) sum-high)
				 (%lshc-bignum-step sum-low sum-high 31)))))
		   :saved-float-operation-status (float-operation-status))
		  ((:use-non-trap-result :new-value)
		   (dfloat-components value))))))))))

;;Return the components of the sqrt of the components
(defdouble double-sqrt (:double) :double dsqrt-components)
(defun dsqrt-components (double-high double-low)
  (with-double-names (double)
    (macrolet ((try-fpa (&body body)
		 #+3600 `(progn ,@body)
		 #+imach `(cli::double-float-trap-body (dsqrt-components double-high double-low)
						       (cli::double-sqrt double-high double-low)
			    ,@body)))
      (try-fpa
	(let ((exp (ldb %%double-exponent double-high)))
	  (cond ((= exp %double-exponent-max)
		 (cond ((or (not (zerop (ldb %%double-fraction-high double-high)))
			    (not (zerop double-low)))
			(double-value double))	;anything(NaN)  NaN
		       ((minusp double-high)
			(double-invalid-operation
			  'sqrt (list (double-to-consed double))))
		       (T (double-value double))))
		((minusp double-high)
		 (if (and (zerop double-low)
			  (zerop (ldb %%double-except-sign-high double-high)))
		     (double-value double)	;sqrt(-0)=-0
		     (if (float-trap-enable? :invalid-operation)
			 (signal-proceed-case
			   ((value)
			    'negative-sqrt
			    :operation 'sqrt
			    :operands (list (double-to-consed double))
			    :non-trap-result
			    (%make-double (dpb %double-exponent-max
					       %%double-exponent
					       (dpb -1 %%double-fraction-high 0))
					  -1))
			   ((:use-non-trap-result :new-value)
			    (dfloat-components value)))
			 (float-set-flag :invalid-operation)
			 (values (dpb %double-exponent-max
				      %%double-exponent
				      (dpb -1 %%double-fraction-high 0))
				 -1))))
		((= exp 0)
		 (if (and (zerop (ldb %%double-fraction-high double-high))
			  (zerop double-low))
		     (double-value double)	;sqrt(0)=Œ0
		     (double-ash (dsqrt-aux (double-ash double 100)) -50)))
		(t (dsqrt-aux double))))))))

(defun sqrt (number)
  (declare lt:(side-effects simple reducible))
  (cl:etypecase number
    (cl:single-float
      (macrolet ((trying-fpa (&body body)
		   #+3600 `(progn ,@body)
		   #+imach  `(cli::single-float-trap-body (sqrt number)
							  (cli::single-sqrt number)
			       ,@body)))
	(let* ((fixnum-number (%fixnum number)))
	  (if (not (minusp fixnum-number))
	      (trying-fpa
		(select (ldb %%single-exponent fixnum-number)
		  (%single-exponent-max number)
		  (0 (if (zerop fixnum-number)
			 number
			 ;; normalize (wrap), sqrt, then scale back
			 (* (sqrt (- (%flonum (dpb 193 %%single-exponent fixnum-number))
				     (%flonum (dpb 193 %%single-exponent 0))))
			    (ash 1.0 -96))))
		  (t (sqrt-aux number))))
	      (if (= (ldb %%single-exponent fixnum-number) %single-exponent-max)
		  (if (not (zerop (ldb %%single-fraction fixnum-number)))
		      number			;NaN
		      (float-invalid-operation 'sqrt (list number)))
		  (if (zerop (ldb %%single-except-sign fixnum-number))
		      number
		      (if (float-trap-enable? :invalid-operation)
			  (signal-proceed-case ((value)
						'negative-sqrt
						:operation 'sqrt
						:operands (list number)
						:non-trap-result
						(%flonum (dpb %single-exponent-max
							      %%single-exponent -1)))
			    (:use-non-trap-result value)
			    (:new-value value))
			  (float-set-flag :invalid-operation)
			  (%flonum (dpb %single-exponent-max %%single-exponent -1)))))))))
    (cl:double-float (double-to-consed (double-sqrt (%fast-double-components number))))
    (cl:complex (box-complex-operation complex-sqrt-components number))
    (cl:number
      (if (minusp number)
	  (if (float-trap-enable? :invalid-operation)
	      (signal-proceed-case ((value)
				    'negative-sqrt
				    :operation 'sqrt
				    :operands (list number)
				    :non-trap-result
				    (%flonum (dpb %single-exponent-max
						  %%single-exponent -1)))
		(:use-non-trap-result value)
		(:new-value value))
	      (float-set-flag :invalid-operation)
	      (%flonum (dpb %single-exponent-max %%single-exponent -1)))
	  (multiple-value-bind (fraction exponent)
	      (decode-float-of-float number)
	    (ash (sqrt (if (evenp exponent) fraction (* fraction 2)))
		 (ash exponent -1)))))))

(defun sqrt-aux (x)
  ;; From an algorithm by Kahan
  (let ((saved-inexact-flag (float-flag? :inexact-result)))
    (with-float-operating-mode ((:round :zero) (:trap-disables :inexact-result))
      (let* ((y (%flonum (+ (ldb (byte 31 1) (%fixnum x)) 127_22 -320000)))
	     ;;Now magically y approximates sqrt(x) to almost 5 sig. bits
	     ;;Heron's rule twice
	     ;; Kahan's paper uses 3150 here.  That works for everything except
	     ;; 1.0 and other even powers of 2, where :inexact gets incorrectly signalled
	     ;; Empirically, 3149 works for that case, too.
	     (z (%flonum (- (%fixnum (+ y (// x y))) (+ 1_23 3149)))))
	;;z approximates sqrt(x) to over 11 sig. bits
	(setq y (%flonum (- (%fixnum (+ z (// x z))) 1_23)))
	;;y approximates sqrt(x) to within 1 ulp
	;;"Most sqrt(x) programs do no better than this, but we must
	;;persevere to get sqrt(x) correctly rounded and, if round-to-nearest,
	;;accurate within 1/2 ulp."
	;;Twiddle last bit using integer add and shift
	(setf (float-flag? :inexact-result) ())
	(setq z (// x y))			;possibly inexact
	(when (not (float-flag? :inexact-result))
	  (when (= z y)
	    ;; sqrt itself was exact, so restore the flag
	    (setf (float-flag? :inexact-result) saved-inexact-flag)
	    (return-from sqrt-aux y))
	  (setq y (%flonum (1- (%fixnum y)))))
	(setf (float-flag? :inexact-result) t)
	(if (not (float-trap-enable? :inexact-result .old-float-operating-mode.))
	    (%flonum (ldb (byte 31 1)		;add and divide by 2
			  (cond ((float-rounding-mode? nearest .old-float-operating-mode.)
				 (%32-bit-plus (1+ (%fixnum y)) (%fixnum z)))
				((float-rounding-mode? plus .old-float-operating-mode.)
				 (%32-bit-plus (1+ (%fixnum y)) (1+ (%fixnum z))))
				(T (%32-bit-plus (%fixnum y) (%fixnum z))))))
	    (signal-proceed-case
	      ((value)
	       'float-inexact-result
	       :operation 'cl:sqrt
	       :operands (list x)
	       :non-trap-result
	       ;; just pack the result
	       (%flonum (ldb (byte 31 1)	;add and divide by 2
			     (cond ((float-rounding-mode? nearest .old-float-operating-mode.)
				    (%32-bit-plus (1+ (%fixnum y)) (%fixnum z)))
				   ((float-rounding-mode? plus .old-float-operating-mode.)
				    (%32-bit-plus (1+ (%fixnum y)) (1+ (%fixnum z))))
				   (T (%32-bit-plus (%fixnum y) (%fixnum z))))))
	       :saved-float-operation-status (float-operation-status))
	      ((:use-non-trap-result :new-value) value)))))))

;; Common Lisp sqrt
(defun cl:sqrt (number)
  (declare lt:(side-effects simple reducible))
  (macrolet ((square-testing-fixnum (bits)
	       (let* ((modulus (expt 2 bits))
		      (fixnum 0))
		 (loop for i below modulus
		       do (setf fixnum (logior fixnum (lsh 1 (mod (expt i 2) modulus)))))
		 fixnum))
	     (fast-square-p (number)
	       ;; filter out some non-squares
	       ;; true of all squares
	       ;; true of 7/32 (~21%) of all integers
	       `(not (zerop (logand (square-testing-fixnum 5)
				    (lsh 1 (ldb (byte 5 0) ,number)))))))
    (cl:etypecase number
      (cl::single-float
	(macrolet ((trying-fpa (&body body)
		     #+3600 `(progn ,@body)
		     #+imach  `(cli::single-float-trap-body (cl:sqrt number)
							    (cli::single-sqrt number)
				 ,@body)))
	  (if (not (minusp (%fixnum number)))
	      (trying-fpa
		(select (ldb %%single-exponent (%fixnum number))
		  (%single-exponent-max number)
		  (0
		   (if (zerop number)
		       number
		       (* (cl:sqrt (- (%flonum (dpb 193 %%single-exponent
						    (ldb %%single-fraction
							 (%fixnum number))))
				      (%flonum (dpb 193 %%single-exponent 0))))
			  (ash 1.0 -96))))
		  (otherwise
		   (sqrt-aux number))))
	      (if (zerop number)
		  number
		  (%make-complex 0.0 (cl:sqrt (- number)))))))
      (cl:double-float
	;; Takes a double returns a double or complex
	(block the-sqrt
	  ;; cli::double-float-trap-body wraps a CL:SQRT block around its body, so we
	  ;; need something else to return from.
	  (double-let* ((d (double-components number)))
	    (macrolet ((try-fpa (&body body)
			 #+3600 `(progn ,@body)
			 #+imach `(cli::double-float-trap-body (cl:sqrt number)
							       (cli::double-sqrt d-high d-low)
				    ,@body)))
	      (if (not (minusp d-high))
		  (double-to-consed
		    (try-fpa
		      (select (ldb %%double-exponent d-high)
			(%double-exponent-max
			 (return-from the-sqrt number))
			(0
			 (if (and (zerop (ldb %%double-fraction-high d-high))
				  (zerop d-low))
			     (return-from the-sqrt number)	;sqrt(-0)=-0
			     (double-ash (dsqrt-aux (double-ash (double-abs d) 100)) -50)))
			(otherwise
			 (dsqrt-aux d)))))
		  (if (double-= d 0.0d0)
		      number
		      (%make-complex 0.0 (cl:sqrt (double-to-consed (double-minus d))))))))))
      (cl:integer
	(if (minusp number)
	    (complex 0 (cl:sqrt (- number)))
	    (let (isqrt)
	      (if (and (fast-square-p number)
		       (= number (cl:expt (setq isqrt (isqrt number)) 2)))
		  isqrt
		  (multiple-value-bind (fraction exponent)
		      (decode-float-of-float number)
		    (ash (cl:sqrt (if (evenp exponent) fraction (* fraction 2)))
			 (ash exponent -1)))))))
      (cl:ratio
	(if (minusp number)
	    (complex 0 (cl:sqrt (- number)))
	    (let* ((num (rational-numerator number))
		   (den (rational-denominator number))
		   num-root
		   den-root)
	      (if (and (fast-square-p num)
		       (fast-square-p den)
		       (= num (^ (setq num-root (isqrt num)) 2))
		       (= den (^ (setq den-root (isqrt den)) 2)))
		  (%make-rational num-root den-root)
		  (multiple-value-bind (fraction exponent)
		      (decode-float-of-rational number)
		    (ash (cl:sqrt (if (evenp exponent) fraction (* fraction 2)))
			 (ash exponent -1)))))))
      (cl:complex (box-complex-operation complex-sqrt-components number)))))

(defdouble double-log (:double) :double dlog-components)
(defun dlog-components (n-high n-low)
  ;; This approximation is from Hart, "Computer Approximations": LOGE 2665
  ;; The notion of shifting the range of z to fix accuracy around 1
  ;;   is from Hastings, "Approximations for Digital Computers"
  (with-double-names (n)
    (cond ((double- n 0.0d0)
	   (ERROR 'NON-POSITIVE-LOG ':NUMBER (%make-double n-high n-low)))
	  (t
	   (multiple-value-bind (f-high f-low exponent)
	       (double-decode-float n)
	     (cond ((fixp exponent)
		    (with-double-names (f)
		      (when (double-< f (// (sqrt 2.0d0)))
			(double-setq f (double-ash f 1))
			(decf exponent))
		      (double-let* ((z (double-// (double-- f 1.0d0)
						  (double-+ f 1.0d0)))
				    (z^2 (double-* z z)))
			(double-+ (double-* (integer-to-double exponent) *double-log-2*)
				  (double-* z (double-horner z^2
							     2.00000000000000261007d0
							     0.6666666666633660894d0
							     0.400000001206045365d0
							     0.2857140915904889d0
							     0.22223823332791d0
							     0.1811136267967d0
							     0.16948212488d0))))))
		   (t
		    (double-value n))))))))

(defun dlog-of-float (number)
  ;; (CL:LOG (FLOAT number 0.0d0))
  (if (= number 0)
      (ERROR 'NON-POSITIVE-LOG ':NUMBER number)
      (multiple-value-bind (f-high f-low exponent)
	  (double-decode-float-of-float-components number)
	(if (fixp exponent)
	    (with-double-names (f)
	      (when (double-< f (// (sqrt 2.0d0)))
		(double-setq f (double-ash f 1))
		(decf exponent))
	      (double-let* ((z (double-// (double-- f 1.0d0)
					  (double-+ f 1.0d0)))
			    (z^2 (double-* z z)))
		(let ((logabs
			(double-to-consed
			  (double-+ (double-* (integer-to-double exponent)
					      *double-log-2*)
				    (double-* z (double-horner z^2
							       2.00000000000000261007d0
							       0.6666666666633660894d0
							       0.400000001206045365d0
							       0.2857140915904889d0
							       0.22223823332791d0
							       0.1811136267967d0
							       0.16948212488d0))))))
		  (if (> number 0)
		      logabs
		      (%make-complex logabs (dfloat pi))))))
	    (dfloat number)))))

(defdouble double-log10 (:double) :double dlog10-components)
(defun dlog10-components (n-high n-low)
  (with-double-names (n)
    (double-* (double-log n) *double-log10-e*)))

(defun log (n)
  (declare lt:(side-effects simple reducible))
  (cl:etypecase n
    (cl:single-float
      (if ( n 0)
	  (ERROR 'NON-POSITIVE-LOG ':NUMBER N)
	  ;; This approximation is from Hart, "Computer Approximations": LOGE 2662
	  ;; The notion of shifting the range of z to fix accuracy around 1
	  ;;   is from Hastings, "Approximations for Digital Computers"
	  (multiple-value-bind (f exponent)
	      (decode-float n)
	    (cond ((fixp exponent)
		   (when (< f (// (sqrt 2)))
		     (setq f (ash f 1))
		     (decf exponent))
		   (let* ((z (// (- f 1.0) (+ f 1.0)))
			  (z^2 (* z z)))
		     (+ (* exponent (log 2.0))
			(* z (horner z^2 1.9999999937438 .666669484507
				     .39965794919 .301003281)))))
		  (t
		   ;; (log NaN) => NaN, (log +1e) = +1e
		   n)))))
    (cl:double-float (double-to-consed (double-log (%fast-double-components n))))
    (cl:complex (box-complex-operation complex-log-components n))
    (cl:number
      (if ( n 0)
	  (ERROR 'NON-POSITIVE-LOG ':NUMBER N)
	  ;; This approximation is from Hart, "Computer Approximations": LOGE 2662
	  ;; The notion of shifting the range of z to fix accuracy around 1
	  ;;   is from Hastings, "Approximations for Digital Computers"
	  (multiple-value-bind (f exponent)
	      (decode-float-of-float n)
	    (cond ((fixp exponent)
		   (when (< f (// (sqrt 2)))
		     (setq f (ash f 1))
		     (decf exponent))
		   (let* ((z (// (- f 1.0) (+ f 1.0)))
			  (z^2 (* z z)))
		     (+ (* exponent (log 2.0))
			(* z (horner z^2 1.9999999937438 .666669484507
				     .39965794919 .301003281)))))
		  (t
		   ;; (log NaN) => NaN, (log +1e) = +1e
		   n)))))))

(defun log-1-arg (number)
  ;; one-arg case of cl:log
  (cl:etypecase number
    (cl:single-float
      (if (zerop number)
	  (error 'non-positive-log :number number)
	  ;; This approximation is from Hart, "Computer Approximations": LOGE 2661
	  ;; The notion of shifting the range of z to fix accuracy around 1
	  ;;   is from Hastings, "Approximations for Digital Computers"
	  (multiple-value-bind (f exponent)
	      (decode-float number)
	    (let ((log (cond ((fixp exponent)
			      (when (< f (// (sqrt 2)))
				(setq f (* f 2))
				(decf exponent))
			      (let* ((z (// (- f 1.0) (+ f 1.0)))
				     (z^2 (expt z 2)))
				(+ (* exponent (log 2.0))
				   (* z (horner z^2 1.9999999937438 .666669484507
						.39965794919 .301003281)))))
			     (t
			      ;; (log NaN) => NaN, (log +1e) = +1e
			      number))))
	      (if (plusp number)
		  log
		  (%make-complex log (float pi)))))))
    (cl:double-float
      (double-let* ((number (double-components number))
		    (abs (double-abs number)))
	(if (and (zerop abs-high) (zerop abs-low))
	    (error 'non-positive-log :number number)
	    (let ((log (double-to-consed (double-log abs))))
	      (if (double-> number 0.0d0)
		  log
		  (%make-complex log (dfloat pi)))))))
    (cl:complex (box-complex-operation complex-log-components number))
    (cl:number
      (if (zerop number)
	  (error 'non-positive-log :number number)
	  ;; This approximation is from Hart, "Computer Approximations": LOGE 2661
	  ;; The notion of shifting the range of z to fix accuracy around 1
	  ;;   is from Hastings, "Approximations for Digital Computers"
	  (multiple-value-bind (f exponent)
	      (decode-float-of-float number)
	    (let ((log (cond ((fixp exponent)
			      (when (< f (// (sqrt 2)))
				(setq f (* f 2))
				(decf exponent))
			      (let* ((z (// (- f 1.0) (+ f 1.0)))
				     (z^2 (expt z 2)))
				(+ (* exponent (log 2.0))
				   (* z (horner z^2 1.9999999937438 .666669484507
						.39965794919 .301003281)))))
			     (t
			      ;; (log NaN) => NaN, (log +1e) = +1e
			      number))))
	      (if (plusp number)
		  log
		  (%make-complex log (float pi)))))))))

(compiler:defoptimizer (cl:log log-1-arg-optimizer log-1-arg) (form)
  (compiler:matchp form
    (('cl:log number)
     (return-from log-1-arg-optimizer
       `(log-1-arg ,number))))
  form)

(defun cl:log (number &optional base)
  (declare lt:(side-effects simple reducible)
	   (unspecial base))
  (cl:etypecase base
    (cl:double-float
      (cl:etypecase number
	(cl:complex
	  (complex-2-arg-log (complex-realpart number) (complex-imagpart number)
			     base 0.0d0))
	(cl:number
	  (cl:// (dlog-of-float number) (cl:log base)))))
    (cl:complex
     (cl:etypecase number
       (cl:complex
	 (complex-2-arg-log (complex-realpart number) (complex-imagpart number)
			    (complex-realpart base) (complex-imagpart base)))
       (cl:number
	 (complex-2-arg-log number 0
			    (complex-realpart base) (complex-imagpart base)))))
    (cl:number
     (cl:etypecase number
       (cl:double-float
	 (cl:// (cl:log number) (dlog-of-float base)))
       (cl:complex
	 (complex-2-arg-log (complex-realpart number) (complex-imagpart number)
			    base 0))
       (cl:number
	 (cl:// (cl:log number) (cl:log base)))))
    (cl:null
     (log-1-arg number))))

(defun cl:expt (base-number power-number)
  (declare lt:(side-effects simple reducible))
  (cond ((zerop power-number)
	 (cond ((typep power-number :fix)
		(typed-one base-number))
	       ((zerop base-number)
		(float-invalid-operation 'cl:expt (list base-number power-number)))
	       (t (coerce-number-to-type 1
					 (type-of-numeric-result base-number power-number)))))
	((zerop base-number)
	 (if (plusp (realpart power-number))
	     base-number
	     (error 'zero-to-negative-power 
		    :function 'cl:expt
		    :exponent power-number
		    :operands (list base-number power-number))))
	(t
	 (labels ((^fix (base-number power-number)
		    ;; POWER-NUMBER is known to be positive by now
		    (selector base-number =
		      (1 base-number)
		      (-1 (if (oddp power-number) base-number (- base-number)))
		      (otherwise
			(cl:typecase base-number
			  (cl:ratio
			    (%make-rational (scalar^fix (rational-numerator base-number)
							power-number)
					    (scalar^fix (rational-denominator base-number)
							power-number)))
			  (cl:double-float
			    (%multiple-value-call-n
			      %make-double
			      (double^fix (double-high base-number) (double-low base-number)
					  power-number)
			      2))
			  (otherwise
			    (scalar^fix base-number power-number))))))
		  (scalar^fix (base-number power-number)
		    ;; Only one big * per expt bit. for big BASE-NUMBER.
		    ;; Emprically, this is marginally more accurate than
		    ;; the usual square-and-multiply.
		    ;; Since HAULONG is such a dog, the recursive version is
		    ;; actually faster for POWER-NUMBER less than 30 or so.
		    (if (= 1 power-number) base-number
			(let* ((sqrt (scalar^fix base-number (ash power-number -1)))
			       (result (* sqrt sqrt)))
			  (if (oddp power-number) (* base-number result) result))))
		  (double^fix (num-high num-low power-number)
		    (if (= 1 power-number) (values num-high num-low)
			(multiple-value-bind (sqrt-high sqrt-low)
			    (double^fix num-high num-low (ash power-number -1))
			  (multiple-value-bind (result-high result-low)
			      (%double-floating-multiply sqrt-high sqrt-low
							 sqrt-high sqrt-low)
			    (if (oddp power-number)
				(%double-floating-multiply num-high num-low
							   result-high result-low)
				(values result-high result-low)))))))
	   (cl:etypecase power-number
	     (cl:integer
	       (if (minusp power-number)
		   (rational-quotient 1 (^fix base-number (- power-number)))
		   (^fix base-number power-number)))
	     (cl:ratio
	       (if (= (rational-denominator power-number) 2)
		   (let ((numerator (rational-numerator power-number))
			 (sqrt (cl:sqrt base-number)))
		     (if (minusp numerator)
			 (cl:// 1 (^fix sqrt (- numerator)))
			 (^fix sqrt numerator)))
		   (cl:typecase base-number
		     (cl:complex (complex-expt base-number power-number))
		     (otherwise
		       (exp (* power-number (cl:log base-number)))))))
	     (cl:float
	       (cl:typecase base-number
		 (cl:complex (complex-expt base-number power-number))
		 (otherwise
		   (exp (* power-number
			   (cl:typecase power-number
			     (cl:double-float
			       (dlog-of-float base-number))
			     (otherwise
			       (cl:log base-number))))))))
	     (cl:complex (complex-expt base-number power-number)))))))

(defun make-double-array (doubles)
  (let ((array (make-array (* 2 (length doubles)))))
    (loop for i upfrom 0 by 2
	  for d in doubles do
	  (multiple-value-bind (d-high d-low)
	      (double-components d)
	    (setf (aref array i) d-high)
	    (setf (aref array (1+ i)) d-low)))
    array))

(defdouble-array *double-exp-factor-array*
  ;; entries are 2^(n/16) (courtesy of MACSYMA)
  1.0d0
  1.04427378242741384032d0
  1.09050773266525765921d0
  1.13878863475669165370d0
  1.18920711500272106672d0
  1.24185781207348404859d0
  1.29683955465100966593d0
  1.35425554693689272830d0
  1.41421356237309504880d0
  1.47682614593949931139d0
  1.54221082540794082361d0
  1.61049033194925430818d0
  1.68179283050742908606d0
  1.75625216037329948311d0
  1.83400808640934246349d0
  1.91520656139714729387d0)

(defdouble double-exp2 (:double) :double dexp2-components)
(defun dexp2-components (n-high n-low)
  ;; Hart, EXPB 1121
  (with-double-names (n)
    (double-let* ((log2 (double-ash n 4))
		  (fixlog2 (double-ffloor log2))
		  (x (double-ash (double-- log2 fixlog2) -4)))
      (let ((int-fixlog2 (double-to-integer fixlog2)))
	(double-let* ((x^2 (double-* x x))
		      (xp (double-* x (double-horner x^2
						     7.2135034108448192083d0
						     0.057761135831801928d0)))
		      (q (double-horner x^2 20.8137711965230361973d0 1.0d0))
		      (2^x (double-* (double-// (double-+ q xp)
						(double-- q xp))
				     (double-aref *double-exp-factor-array*
						  (ash (ldb (byte 4 0) int-fixlog2) 1)))))
	  (double-ash 2^x (ash int-fixlog2 -4)))))))

(defdouble double-exp (:double) :double dexp-components)
(defun dexp-components (x-high x-low)
  (with-double-names (x)
    (if (= (ldb %%double-exponent x-high) %double-exponent-max)
	(if (and (zerop x-low) (zerop (ldb %%double-fraction-high x-high)))
	    (if (minusp x-high)
		(double-value 0.0d0) (double-value +1d))
	    (double-value x))
	(if (< (ldb %%double-exponent x-high)
	       (ldb %%double-exponent (double-high (// cl:double-float-epsilon 2))))
	    (double-value 1.0d0)
	    (double-exp2 (double-* x *double-log2-e*))))))

(defun make-lnumer-array (values)
  (loop for nil being the array-elements of (make-array (length values))
	  using (index index) (sequence array)
	for value in values
	do (setf (aref array index) value)
	finally (return array)))

(defnumeric-array *exp-factor-table*			;2^(n/4)
  1.0 1.189207115 1.414213562 1.681792831)

;; Hart 1080 and 1100 are marginally inferior to this
(defun exp (number)
  (declare lt:(side-effects simple reducible))
  (cl:etypecase number
    (cl:single-float
      (if (= (ldb %%single-exponent (%fixnum number)) %single-exponent-max)
	  (if (zerop (ldb %%single-fraction (%fixnum number)))
	      (if (minusp number) 0.0 +1e)	;(exp +/-1e)
	      number)				;(exp NaN)
	  (multiple-value-bind (fourths fraction*4)
	      (single-extended-scale-and-floor number (* 4 *double-log2-e*))
	    ;; Hart, et. al. EXPB 1001
	    (let ((number (ash fraction*4 -2))	;0  number < 1/4
		  (table (aref *exp-factor-table* (ldb (byte 2 0) fourths))))
	      (ash (+ table
		      (* (horner number
				 .00000000254251 .6931466590125849 .24024343859214
				 .0553133644158 .01048536383644)
			 table))
		   (ash fourths -2))))))
    (cl:double-float
      (double-to-consed (double-exp (%fast-double-components number))))
    (cl:complex
      (box-complex-operation complex-exp-components number))
    (cl:number
      (exp (float number)))))

(defdouble double-expt (:double :double) :double dexpt-components)
(defun dexpt-components (base-high base-low power-high power-low)
  (with-double-names (base power)
    (let ((compare (double-compare base 0.0d0)))
      (cond ((plusp compare)
	     (double-exp (double-* (double-log base) power)))
	    ((zerop compare)
	     (if (double- power 0.0d0)
		 (double-invalid-operation
		   'expt
		   (list (double-to-consed base) (double-to-consed power)))
	       (double-value base)))
	    (t
	     (double-invalid-operation
	       'expt
	       (list (double-to-consed base) (double-to-consed power))))))))

(defdouble double-expt-integer (:double :integer) :double dexpt-integer-components)
(defun dexpt-integer-components (double-high double-low integer)
  (with-double-names (double)
    (double-let* ((product (if (oddp integer)
			       (double-value double)
			       (double-components 1.0d0))))
      (loop with power = (abs integer)
	    until (zerop (setq power (ash power -1))) do
		  (double-setq double (double-* double double))
		  (when (oddp power)
		    (double-setq product (double-* product double))))
      (if (minusp integer)
	  (double-// 1.0d0 product)
	  (double-value product)))))

(defdouble double-sin-cos-aux (:double :integer) :double double-sin-cos-aux-components)
(defdouble double-sin (:double) :double dsin-components)
(defdouble double-cos (:double) :double dcos-components)
(defdouble double-sind (:double) :double dsind-components)
(defdouble double-cosd (:double) :double dcosd-components)

(defun dsin-components (x-high x-low)
  (with-double-names (x)
    (if (< (ldb %%double-exponent x-high)
	   (ldb %%double-exponent (double-high 7.4476d-8)))
	(double-value x)
	(double-sin-cos-aux (double-* x (dfloat (// 2 pi))) 0))))

(defun dcos-components (x-high x-low)
  (with-double-names (x)
    (double-sin-cos-aux (double-* x (dfloat (// 2 pi))) 1)))

(defun dsind-components (x-high x-low)
  (with-double-names (x)
    (if (< (ldb %%double-exponent x-high)
	   (ldb %%double-exponent (double-high (* (// 7.4476d-8 pi) 180))))
	(double-* x (dfloat (// pi 180)))
	(double-sin-cos-aux (double-* x (dfloat 1//90)) 0))))

(defun dcosd-components (x-high x-low)
  (with-double-names (x)
    (double-sin-cos-aux (double-* x (dfloat 1//90)) 1)))

(defun double-sin-cos-aux-components (x-high x-low quadrant-adjustment)
  ;; From Hart, et. al.  Computer Approximations -- SIN 3304
  ;; x is scaled so that the integer part is the quadrant number,
  ;; and the fraction is the part of the quadrant
  (with-double-names (x)
    (double-let* ((integer-x (double-ffloor x))
		  (y (double-- x integer-x)))	; 0  y < 1
      (let ((quadrant (+ (double-to-integer integer-x) quadrant-adjustment)))
	(unless (zerop (ldb (byte 1 0) quadrant))
	  (double-setq y (double-- 1.0d0 y)))
	(double-let* ((y^2 (double-* y y))
		      (sin (double-* y (double-horner
					 y^2 
					 +1.5707963267948950978d0
					 -0.64596409750617316602d0
					 +0.796926262451428611d-1
					 -0.468175412887387128d-2
					 +0.16044116327434152d-3
					 -0.35988024751212d-5
					 +0.568776939525d-7
					 -0.64348418394d-9))))
	  (unless (< (ldb %%double-exponent sin-high)
		     (ldb %%double-exponent (double-high 1.0d0)))
	    ;; occasionally the above formula can go over 1.0
	    (double-setq sin (double-components 1.0d0)))
	  (values (%logdpb (ldb (byte 1 1) quadrant) %%double-sign sin-high)
		  sin-low))))))

(defun sin-cos-internal (x scale-high scale-low quadrant-adjust)
  ;; 0  x; x single-precision
  ;; smallness test has already been done, since quadrant reduction can't give a small result
  (multiple-value-bind (quadrant y-high y-low)
      (single-to-double-scale-and-floor-components x scale-high scale-low)
    ;; quadrant-adjust is 0 for sin, 1 for cos
    (incf quadrant quadrant-adjust)
    ;; Hastings, "Approximations for Digital Computers", Sheet 16
    ;; relative error is about .000000005
    ;; -1  y  1
    (let* ((y (double-to-single (if (zerop (ldb (byte 1 0) quadrant))
				    (values y-high y-low)
				    (double-- 1.0d0 (values y-high y-low)))))
	   (y^2 (^ y 2))
	   (sin (%fixnum (* y (horner y^2 1.5707963185 -.6459637111
				      .07968967928 -.00467376557 .00015148419)))))
      (unless (< (ldb %%single-exponent sin)
		 (ldb %%single-exponent (%fixnum 1.0)))
	;; occasionally the above formula can go over 1.0
	(setq sin (%fixnum 1.0)))
      ;; (if (zerop (ldb (byte 1 1) quadrant)) sin (- sin))
      (%flonum (%logdpb (ldb (byte 1 1) quadrant) %%single-sign sin)))))

(defun cos-and-sin-internal (x scale-high scale-low)
  (with-double-names (scale)
    (double-let* ((scaled-x (double-* (single-to-double x) scale))
		  (integer-scaled-x (double-ffloor scaled-x))
		  (y (double-- scaled-x integer-scaled-x)))
      (let* ((quadrant (double-to-integer integer-scaled-x))
	     (y-sin (double-to-single y))
	     (y-cos (double-to-single (double-- 1.0d0 y)))
	     ;; Hastings, "Approximations for Digital Computers", Sheet 16
	     ;; relative error is about .000000005
	     ;; 0  y < 1
	     (y-sin^2 (^ y-sin 2))
	     (y-cos^2 (^ y-cos 2))
	     (s (* y-sin (horner y-sin^2 1.5707963185 -.6459637111
				 .07968967928 -.00467376557 .00015148419)))
	     (sin (if ( s 1.0) s 1.0))
	     (c (* y-cos (horner y-cos^2 1.5707963185 -.6459637111
				 .07968967928 -.00467376557 .00015148419)))
	     (cos (if ( c 1.0) c 1.0)))
	(cl:case (ldb (byte 2 0) quadrant)
	  (0 (values cos sin))
	  (1 (values (- sin) cos))
	  (2 (values (- cos) (- sin)))
	  (otherwise (values sin (- cos))))))))

(defun sind-cosd-rational-internal (degrees quadrant-adjust)
  ;; since we have a rational arg, do quadrant reduction first, then smallness test
  (multiple-value-bind (floor remainder)
      (floor degrees 90)
    (let* ((quadrant (+ floor quadrant-adjust))
	   (remainder-degrees (if (zerop (ldb (byte 1 0) quadrant))
				  remainder
				  (- 90 remainder)))
	   (sin (if ( remainder-degrees 3\100)
		    (* (float remainder-degrees) (float (// pi 180)))
		    ;; Hastings, "Approximations for Digital Computers", Sheet 16
		    ;; relative error is about .000000005
		    ;; 0  y < 1
		    (let* ((y (// (float remainder-degrees) 90.0))
			   (y^2 (^ y 2))
			   (s (* y (horner y^2 1.5707963185 -.6459637111
					   .07968967928 -.00467376557 .00015148419))))
		      (if ( s 1.0) s 1.0)))))
      (if (zerop (ldb (byte 1 1) quadrant)) sin (- sin)))))

(defun sin (radians)
  (declare lt:(side-effects simple reducible))
  (cl:etypecase radians
    (cl:single-float
     (if (< (ldb %%single-exponent (%fixnum radians))
	    (ldb %%single-exponent (%fixnum 5.980022e-4)))	;( (abs radians) ~5.980022e-4)
	 ;; avoid underflow, keep accuracy
	 radians
	 (%flonum
	   (logxor
	     (%fixnum
	       (%multiple-value-call-n sin-cos-internal
				       (%single-floating-abs radians) 1
				       (double-components (dfloat (// 2 pi))) 2
				       0 1))
	     (dpb 0 %%single-except-sign (%fixnum radians))))))
    (cl:double-float
     (double-let* ((r (double-components radians)))
       (if (< (ldb %%double-exponent r-high)	;( (abs radians) ~7.4476d-8)
	      (ldb %%double-exponent (double-high 7.4476d-8)))
	   radians
	   (double-let* ((sin (double-sin-cos-aux
				(double-* (values (ldb %%double-except-sign-high r-high)
						  r-low)
					  (dfloat (// 2 pi)))
				0)))
	     (double-to-consed (values (logxor sin-high
					       (dpb 0 %%double-except-sign-high r-high))
				       sin-low))))))
    (cl:complex
     (box-complex-operation
       (lambda (real imag)
	 (if (zerop imag)
	     (values-with-typed-zero (sin real))
	     (multiple-value-bind (cos sin) (cos-and-sin real)
	       (multiple-value-bind (cosh sinh) (cosh-and-sinh imag)
		 (values (* sin cosh) (* cos sinh))))))
       radians))
    (cl:number (sin (float radians)))))

(defun cos (radians)
  (declare lt:(side-effects simple reducible))
  (cl:etypecase radians
    (cl:single-float
     (%multiple-value-call-n sin-cos-internal
			     (%single-floating-abs radians) 1
			     (double-components (dfloat (// 2 pi))) 2
			     1 1))
    (cl:double-float
     (double-to-consed (double-sin-cos-aux (double-* (double-abs (double-components radians))
						     (dfloat (// 2 pi)))
					   1)))
    (cl:complex
     (box-complex-operation
       (lambda (real imag)
	 (if (zerop imag)
	     (values-with-typed-zero (cos real))
	     (multiple-value-bind (cos sin) (cos-and-sin real)
	       (multiple-value-bind (cosh sinh) (cosh-and-sinh imag)
		 (values (* cos cosh) (- (* sin sinh)))))))
       radians))
    (cl:number (cos (float radians)))))

(defun radians-from-degrees (n)
  (cl:etypecase n
    (cl:double-float (* n (// pi 180.)))
    (cl:number (* n (float (// pi 180.))))))


#||
(defun choose-limit (start direction)
  (loop for x = start then (nextafter x direction) do
    (let ((s1 (* x (float (// pi 180))))
	  (s2 (%multiple-value-call-n sin-cos-internal
				      x 1
				      (double-components (dfloat 1//90)) 2
				      0 1)))
      (unless (eql s1 s2)
	(let* ((s3 (sind (dfloat x)))
	       (r1 (abs (float (// (- s1 s3) s3))))
	       (r2 (abs (float (// (- s2 s3) s3)))))
	(format t "~&  x = ~A  sin = ~A  sin-x = ~A  d = ~A  choose ~A" x s1 s2 (float s3)
		(cond ((< r1 r2)
		       "sin")
		      ((< r2 r1)
		       "sin-x")
		      (t "either"))))))))
||#

(defun sind (degrees)
  (declare lt:(side-effects simple reducible))
  (cl:etypecase degrees
    (cl:single-float
     (if ( (ldb %%single-exponent (%fixnum degrees))
	    (ldb %%single-exponent (%fixnum (float (* (// 5.980022e-4 pi) 180)))))
	 ;; avoid underflow in sin-cos-internal
	 (* degrees (float (// pi 180)))
	 (%multiple-value-call-n sin-cos-internal
				 degrees 1
				 (double-components (dfloat 1//90)) 2
				 0 1)))
    (cl:double-float
     (double-let* ((d (double-components degrees)))
       (if (< (ldb %%double-exponent d-high)
	      (ldb %%double-exponent (double-high (* (// 7.4476d-8 pi) 180))))
	   (double-to-consed (double-* d (dfloat (// pi 180))))
	   (double-to-consed (double-sin-cos-aux (double-* d (dfloat 1//90))
						 0)))))
    (cl:complex
     (box-complex-operation
       (lambda (real imag)
	 (if (zerop imag)
	     (values-with-typed-zero (sind real))
	     (multiple-value-bind (cos sin) (cosd-and-sind real)
	       (multiple-value-bind (cosh sinh) (cosh-and-sinh (radians-from-degrees imag))
		 (values (* sin cosh) (* cos sinh))))))
       degrees))
    (cl:number
      (sind-cosd-rational-internal degrees 0))))

(defun cosd (degrees)
  (declare lt:(side-effects simple reducible))
  (cl:etypecase degrees
    (cl:single-float
     (%multiple-value-call-n sin-cos-internal
			     degrees 1
			     (double-components (dfloat 1//90)) 2
			     1 1))
    (cl:double-float
     (double-to-consed (double-sin-cos-aux (double-* (double-components degrees)
						     (dfloat 1//90))
					   1)))
    (cl:complex
     (box-complex-operation
       (lambda (real imag)
	 (if (zerop imag)
	     (values-with-typed-zero (cosd real))
	     (multiple-value-bind (cos sin) (cosd-and-sind real)
	       (multiple-value-bind (cosh sinh) (cosh-and-sinh (radians-from-degrees imag))
		 (values (* cos cosh) (- (* sin sinh)))))))
       degrees))
    (cl:number
      (sind-cosd-rational-internal degrees 1))))

(defdouble dtan-internal (:double :double) :double dtan-internal-components)
(defun dtan-internal-components (x-high x-low scale-high scale-low)
  (with-double-names (x scale)
    (double-let* ((scaled-x (double-* x scale))
		  (floor-scaled-x (double-ffloor scaled-x))
		  (y (double-- scaled-x floor-scaled-x)))
      (let ((octant (double-to-integer floor-scaled-x)))
	(unless (zerop (ldb (byte 1 0) octant))
	  (double-setq y (double-- 1.0d0 y)))
	(double-let* ((y^2 (double-* y y))
		      ;; Hart, TAN 4286
		      ;; 0  y*/4  /4
		      (tan (double-* y
				     (double-//
				       (double-horner y^2
						      +0.1088860043728168752138857983d+8
						      -0.8958884400676804108729639541d+6
						      +0.1418985425276177838800394831d+5
						      -0.45649319438665631873961137d+2)
				       (double-horner y^2
						      +0.1386379666356762916533913361d+8
						      -0.399130951803516515044342794d+7
						      +0.1353827128051190938289294872d+6
						      -0.1014656190252885338754401947d+4
						      +1.0d0)))))
	  (cl:case (ldb (byte 2 0) octant)
	    (0 (double-value tan))
	    (1 (double-// 1.0d0 tan))
	    (2 (double-// -1.0d0 tan))
	    (otherwise (double-minus tan))))))))

(defdouble double-tan (:double) :double dtan-components)
(defun dtan-components (x-high x-low)
  (with-double-names (x)
    (if (< (ldb %%double-exponent x-high)
	   (ldb %%double-exponent (double-high 1.7316779d-8)))
	(double-value x)
	(dtan-internal x (dfloat (// 4 pi))))))

(defdouble double-tand (:double) :double dtand-components)
(defun dtand-components (x-high x-low)
  (with-double-names (x)
    (if (< (ldb %%double-exponent x-high)
	   (ldb %%double-exponent (double-high (* (// 1.7316779d-8 pi) 180))))
	(double-* x (dfloat (// pi 180)))
	(dtan-internal x (// 4 180.0d0)))))

#|
1. tan(-x) = -tan(x)
2. Range reduce to 0<x<+
3. If x > /4 then tan(x) = 1 / (tan(/2 - x))
4. Now we have an argument between 0 and /4.  Take I and F, the integer and 
   fraction parts of 4*arg.  F is then in 0 < x < /16, which is what TAN 4123 wants.
5. Evaluate tan(F) = F * P(F^2) / Q(F^2).
6. Use I to table-lookup tan(I*/16). 
7. tan_IF = (tan_I + tan_F) / (1 - (tan_I * tan_F))
|#

(defun tan-internal (x scale-high scale-low)
  (multiple-value-bind (octant y-high y-low)
      (single-to-double-scale-and-floor-components x scale-high scale-low)
    (let* ((y (double-to-single (if (zerop (ldb (byte 1 0) octant))
				    (values y-high y-low)
				    (double-- 1.0d0 (values y-high y-low)))))
	   ;; Hart, TAN 4265
	   ;; N.B. Hart, TAN 4282 empirically is slightly less accurate
	   (y^2 (^ y 2))
	   (tan (* y (horner y^2 .785398176 .161489778 .398659105e-1 .983459454e-2
			     .279743350e-2 .203117108e-3 .410974195e-3))))
      (cl:case (ldb (byte 2 0) octant)
	(0 tan)
	(1 (// 1.0 tan))
	(2 (// -1.0 tan))
	(otherwise (- tan))))))

(defun tand-rational-internal (degrees)
  ;; since we have a rational arg, do quadrant reduction first, then smallness test
  (multiple-value-bind (octant remainder)
      (floor degrees 45)
    (let* ((remainder-degrees (if (zerop (ldb (byte 1 0) octant))
				  remainder
				  (- 45 remainder)))
	   (tan (if ( remainder-degrees 215\10000)
		    (* (float remainder-degrees) (float (// pi 180)))
		    (let* ((y (// (float remainder-degrees) 45.0))
			   (y^2 (^ y 2)))
		      (* y (horner y^2 .785398176 .161489778 .398659105e-1
				   .983459454e-2 .279743350e-2 .203117108e-3
				   .410974195e-3))))))
      (cl:case (ldb (byte 2 0) octant)
	(0 tan)
	(1 (// 1.0 tan))
	(2 (// -1.0 tan))
	(otherwise (- tan))))))

(defun tan (radians)
  (declare lt:(side-effects simple reducible))
  (cl:etypecase radians
    (cl:single-float
      (if (< (ldb %%single-exponent (%fixnum radians))
	     (ldb %%single-exponent (%fixnum 3.5211173e-4)))	;empirically determined
	  ;; avoid underflow, keep accuracy
	  radians
	  (%multiple-value-call-n tan-internal
				  radians 1
				  (double-components (dfloat (// 4 pi))) 2)))
    (cl:double-float
      (double-let* ((r (double-components radians)))
	(if (< (ldb %%double-exponent r-high)
	       (ldb %%double-exponent (double-high 1.7316779d-8)))
	    radians
	    (double-to-consed (dtan-internal r (dfloat (// 4 pi)))))))
    (cl:complex
      (box-complex-operation
	(lambda (real imag)
	  (if (zerop imag)
	      (values-with-typed-zero (tan real))
	      (multiple-value-bind (cos sin) (cos-and-sin (* 2 real))
		(multiple-value-bind (cosh sinh) (cosh-and-sinh (* 2 imag))
		  (let ((denom (+ cos cosh)))
		    (values (rational-quotient sin denom) (rational-quotient sinh denom)))))))
	radians))
    (cl:number
      (tan (float radians)))))

#||
(defun choose-limit (start direction)
  (loop for x = start then (nextafter x direction) do
    (let ((s1 (* x (float (// pi 180))))
	  (s2 (%multiple-value-call-n tan-internal
				  x 1
				  (double-components (// 4.0d0 180.0d0)) 2)))
      (unless (eql s1 s2)
	(let* ((s3 (tand (dfloat x)))
	       (r1 (abs (float (// (- s1 s3) s3))))
	       (r2 (abs (float (// (- s2 s3) s3)))))
	(format t "~&  x = ~A  sin = ~A  sin-x = ~A  d = ~A  choose ~A" x s1 s2 (float s3)
		(cond ((< r1 r2)
		       "sin")
		      ((< r2 r1)
		       "sin-x")
		      (t "either"))))))))
||#

(defun tand (degrees)
  (declare lt:(side-effects simple reducible))
  (cl:etypecase degrees
    (cl:single-float
      (if (< (ldb %%single-exponent (%fixnum degrees))
	     (ldb %%single-exponent (%fixnum 3.5211173e-4)))
	  ;; avoid underflow, keep accuracy
	  (* degrees (float (// pi 180)))
	  (%multiple-value-call-n tan-internal
				  degrees 1
				  (double-components (// 4.0d0 180.0d0)) 2)))
    (cl:double-float
      (double-let* ((d (double-components degrees)))
	(if (< (ldb %%double-exponent d-high)
	       (ldb %%double-exponent (double-high (* (// 1.7316779d-8 pi) 180))))
	    (double-to-consed (double-* d (dfloat (// pi 180))))
	    (double-to-consed (dtan-internal d (// 4 180.0d0))))))
    (cl:complex
      (box-complex-operation
	(lambda (real imag)
	  (if (zerop imag)
	      (values-with-typed-zero (tand real))
	      (multiple-value-bind (cos sin) (cosd-and-sind (* 2 real))
		(multiple-value-bind (cosh sinh)
		    (cosh-and-sinh (radians-from-degrees (* 2 imag)))
		  (let ((denom (+ cos cosh)))
		    (values (rational-quotient sin denom) (rational-quotient sinh denom)))))))
	degrees))
    (cl:number
      (tand-rational-internal degrees))))

(defdouble-array *atan-double-table*
  ;; atan(i/16, for i:0..16)
  0.0d0
  0.062418809995957348474d0
  0.12435499454676143503d0
  0.18534794999569476489d0
  0.24497866312686415417d0
  0.30288486837497140556d0
  0.3587706702705722204d0
  0.4124104415973873069d0
  0.46364760900080611622d0
  0.51238946031073770667d0
  0.55859931534356243597d0
  0.60228734613496418168d0
  0.6435011087932843868d0
  0.68231655487474807826d0
  0.71882999962162450542d0
  0.75315128096219438952d0
  0.78539816339744830962d0)

(defdouble double-atan-innards (:double) :double datan-innards)
(defun datan-innards (x-high x-low)
  ;;Hart ARCTN 4903
  ;; 0  x  1
  (with-double-names (x)
    (double-let* ((x-sixteenths (double-ash x 4))
		  (x-sixteenths-floor (double-ffloor x-sixteenths))
		  ;; 0  t0 < 1/16 < (tan (// pi 32))
		  (t0 (double-// (double-- x-sixteenths x-sixteenths-floor)
				 (double-+ #.(ash 1.0d0 4) (double-* x x-sixteenths-floor)))))
      (double-+ (if (< (ldb %%double-exponent t0-high)
		       (ldb %%double-exponent (double-high 1.8d-8)))
		    (double-value t0)
		    (double-let* ((t0^2 (double-* t0 t0)))
		      (double-* t0 (double-horner t0^2
						  +0.999999999999999969557d0
						  -0.33333333333310718d0
						  +0.19999999972769276d0
						  -0.142857022886077d0
						  +0.1110871947826d0
						  -0.08870580341d0))))
		(double-aref *atan-double-table*
			     (* 2 (double-to-integer x-sixteenths-floor)))))))

(defdouble double-atan2 (:double :double) :double datan2-components)
(defun datan2-components (y-high y-low &optional x-high x-low)
  (with-double-names (x y)
    (if (null x-high)
	(selectq (double-compare y 0.0d0)
	  (+1 (if (double-> y 1.0d0)
		  (double-- (dfloat (// pi 2)) (double-atan-innards (double-// 1.0d0 y)))
		(double-atan-innards y)))
	  (-1 (if (double-< y -1.0d0)
		  (double-- (double-atan-innards (double-// 1.0d0 (double-minus y)))
			    (dfloat (// pi 2)))
		(double-minus (double-atan-innards (double-minus y)))))
	  (otherwise (double-value y)))
	(selectq (double-compare y 0.0d0)
	  (+1
	   (selectq (double-compare x 0.0d0)
	     (+1				;1st quadrant
	      (if (double-> y x)
		  (double-- (dfloat (// pi 2)) (double-atan-innards (double-// x y)))
		(double-atan-innards (double-// y x))))
	     (-1				;2nd quadrant
	      (if (double-> y (double-minus x))
		  (double-+ (double-atan-innards (double-// (double-minus x) y))
			    (dfloat (// pi 2)))
		(double-- (dfloat pi)
			  (double-atan-innards (double-// y (double-minus x))))))
	     (otherwise (double-value (dfloat (// pi 2))))))
	  (-1
	   (selectq (double-compare x 0.0d0)
	     (+1				;4th quadrant
	      (if (double-> (double-minus y) x)
		  (double-- (double-atan-innards (double-// x (double-minus y)))
			    (dfloat (// pi 2)))
		(double-minus (double-atan-innards (double-// (double-minus y) x)))))
	     (-1				;3rd quadrant
	      (if (double-< y x)
		  (double-- (dfloat (- (// pi 2))) (double-atan-innards (double-// x y)))
		(double-- (double-atan-innards (double-// y x)) (dfloat pi))))
	     (otherwise (double-value (dfloat (- (// pi 2)))))))
	  (otherwise
	   (if (minusp x-high)
	       (values (dpb (double-high (dfloat pi)) %%double-except-sign-high y-high)
		       (double-low (dfloat pi)))
	       (double-value y)))))))

(defnumeric-array *atan-single-table*
  0.0 6.2418809995957348474e-2
  1.2435499454676143503e-1 1.8534794999569476489e-1
  2.4497866312686415417e-1 3.0288486837497140556e-1
  3.587706702705722204e-1  4.124104415973873069e-1
  4.6364760900080611622e-1 5.1238946031073770667e-1
  5.5859931534356243597e-1 6.0228734613496418168e-1
  6.435011087932843868e-1  6.8231655487474807826e-1
  7.1882999962162450542e-1 7.5315128096219438952e-1
  7.8539816339744830962e-1)

(defun atan-innards (x)
  ;; Hart ARCTN 4900
  ;; 0  x  1
  (multiple-value-bind (integer-sixteenths frac-sixteenths)
      (ffloor (ash x 4))
    (let ((t0 (// frac-sixteenths
		  (+ (ash 1.0 4)
		     (* x integer-sixteenths)))))	; 0  t0 < 1/16 < (tan (// pi 32))
      (+ (if (< (ldb %%single-exponent (%fixnum t0))
		(ldb %%single-exponent (%fixnum 0.00042286)))
	     t0
	     (let ((t0^2 (expt t0 2)))
	       (* t0 (horner t0^2 +.9999999959792 -.33332586045 +.197939543))))
	 (aref *atan-single-table*
	       (sys:%convert-single-to-fixnum integer-sixteenths))))))

(defun atan (y x)
  (declare lt:(side-effects simple reducible))
  (let ((result (atan2 y x)))
    (if (minusp result)
	(typecase result
	  (:double-float
	   (double-to-consed (double-+ (double-components result) (dfloat (* pi 2)))))
	  (otherwise
	    (+ result (float (* pi 2)))))
      result)))

(defun atan2 (y &optional x)
  (declare lt:(side-effects simple reducible))
  (if (double-float-p y)
      (if x
	  (double-to-consed (double-atan2 (double-components y) (double-dfloat x)))
	  (double-to-consed (double-atan2 (double-components y))))
      (if (double-float-p x)
	  (double-to-consed (double-atan2 (double-dfloat y) (double-components x)))
	  (setq y (float y))
	  (if (null x)
	      (cond ((plusp y)
		     (if (> y 1.0)
			 (- (float (// pi 2)) (atan-innards (// 1.0 y)))
			 (atan-innards y)))
		    ((minusp y)
		     (if (< y -1.0)
			 (- (atan-innards (// -1.0 y)) (float (// pi 2)))
			 (- (atan-innards (- y)))))
		    (T 0.0))
	      (setq x (float x))
	      (cond ((plusp y)
		     (cond ((plusp x)		;1st quadrant
			    (if (> y x)
				(- (float (// pi 2)) (atan-innards (// x y)))
				(atan-innards (// y x))))
			   ((minusp x)		;2nd quadrant
			    (if (> y (- x))
				(+ (atan-innards (// (- x) y)) (float (// pi 2)))
				(- (float pi) (atan-innards (// y (- x))))))
			   (T (float (// pi 2)))))
		    ((minusp y)
		     (cond ((plusp x)		;4th quadrant
			    (if (> (- y) x)
				(- (atan-innards (// x (- y))) (float (// pi 2)))
				(- (atan-innards (// (- y) x)))))
			   ((minusp x)		;3rd quadrant
			    (if (< y x)
				(- (float (- (// pi 2))) (atan-innards (// x y)))
				(- (atan-innards (// y x)) (float pi))))
			   (T (- (float (// pi 2))))))
		    (T (cond ((plusp x) 0.0)
			     ((minusp x) (float pi))
			     (T (float-invalid-operation 'atan2 (list y x))))))))))

(defun atan-1-arg (y)
  (cl:etypecase y
    (cl:single-float
      (cond ((plusp y)
	     (if (> y 1.0)
		 (- (float (// pi 2)) (atan-innards (// 1.0 y)))
		 (atan-innards y)))
	    ((minusp y)
	     (if (< y -1.0)
		 (- (atan-innards (// -1.0 y)) (float (// pi 2)))
		 (- (atan-innards (- y)))))
	    (t y)))
    (cl:double-float
      (double-to-consed (double-atan2 (double-components y))))
    (cl:complex
      (complex-let* ((y (complex-parts y)))
	(if (zerop y-imag)
	    (let ((atan (atan-1-arg y-real)))
	      (complex atan 0))
	    (box-complex-values
	      (complex-*-i
		(complex-log
		  (complex-* (complex-1+ (complex-*i y))
			     (complex-sqrt
			       (complex-// #c(1.0 0.0)
					   (complex-1+ (complex-^2 y)))))))))))
    (cl:number
      (atan-1-arg (float y)))))

(defun atan-2-args (y x)
  (cl:etypecase y
    (cl:single-float
      (cl:etypecase x
	(cl:single-float
	  (cond ((plusp y)
		 (cond ((plusp x)		;1st quadrant
			(if (> y x)
			    (- (float (// pi 2)) (atan-innards (// x y)))
			    (atan-innards (// y x))))
		       ((minusp x)		;2nd quadrant
			(if (> y (- x))
			    (+ (atan-innards (// (- x) y)) (float (// pi 2)))
			    (- (float pi) (atan-innards (// y (- x))))))
		       (t (float (// pi 2)))))
		((minusp y)
		 (cond ((plusp x)		;4th quadrant
			(if (> (- y) x)
			    (- (atan-innards (// x (- y))) (float (// pi 2)))
			    (- (atan-innards (// (- y) x)))))
		       ((minusp x)		;3rd quadrant
			(if (< y x)
			    (- (float (- (// pi 2))) (atan-innards (// x y)))
			    (- (atan-innards (// y x)) (float pi))))
		       (t (- (float (// pi 2))))))
		((minusp (%fixnum x))
		 (%flonum (dpb (%fixnum (float pi))
			       %%single-except-sign
			       (%fixnum y))))
		(t y)))
	(cl:double-float
	  (double-to-consed (double-atan2 (double-dfloat y) (double-components x))))
	(future-common-lisp:real
	  (atan-2-args y (float x)))))
    (cl:double-float
     (cl:etypecase x
       (cl:double-float
	 (double-to-consed (double-atan2 (double-components y)
					 (double-components x))))
       (future-common-lisp:real
	 (double-to-consed (double-atan2 (double-components y) (double-dfloat x))))))
    (future-common-lisp:real
     (atan-2-args (float y) x))))

;	Condition			result
;	y=+0  x>0			   +0
;	y=-0  x>0			   -0
;	y=+0  x<0			   +pi
;	y=-0  x<0			   -pi
;	y=+0  x=+0			   +0
;	y=-0  x=+0			   -0
;	y=+0  x=-0			   +pi
;	y=-0  x=-0			   -pi

(defun cl:atan (y &optional x)
  (declare lt:(side-effects simple reducible))
  (if (null x)
      (atan-1-arg y)
      (atan-2-args y x)))

(compiler:defoptimizer (cl:atan atan-arg-optimizer atan-1-arg atan-2-args) (form)
  (compiler:matchp (cdr form)
    ((y)
     `(atan-1-arg ,y))
    ((y x)
     `(atan-2-args ,y ,x))
    (* form)))

;;Verify that datan2 is at least monotonic about the breakpoints in its range reduction.
#+Franz
(defun datan-around ()
  (loop for i from 1 to 17.
	do (multiple-value-bind (dhi dlo) (%convert-single-to-double (// i 16.0))
	     (unless (zerop dlo) (ferror "Inexact division by 16??"))
	     (double-let* ((atan-lo (double-atan2 (1- dhi) -1))
			   (atan-mid (double-atan2 dhi 0))
			   (atan-hi (double-atan2 dhi 1)))
	       (let ((lo-mid (double-compare atan-lo atan-mid))
		     (mid-hi (double-compare atan-mid atan-hi)))
		 (unless (and ( lo-mid 0) ( mid-hi 0))
		   (format T "~&~3d//16" i)
		   (pdoub "  lo" atan-lo-high atan-lo-low)
		   (pdoub "  mid" atan-mid-high atan-mid-low)
		   (pdoub "  hi" atan-hi-high atan-hi-low)))))))
			    

#+Franz
(defun double&big-atan2 (x)
  (setq x (endouble x))
  (values (multiple-value-bind (hi lo)
	      (with-double-components (x x-high x-low)
		(double-atan2-components x-high x-low))
	    (%make-double hi lo))
	  (macsyma:bf-atan x)))

;;; These all are awful, but better than nothing
(defun cl:asin (number)
  (declare lt:(side-effects simple reducible))
  ;;---I hope we can do a little better than these...
  (flet ((single-asin (number)
	   (cl:atan number (cl:sqrt (- 1.0 (* number number)))))
	 (double-asin (number)
	   (cl:atan number (cl:sqrt (- 1.0d0 (* number number)))))
	 (complex-asin (number)
	   (if (or (minusp (imagpart number))
		   (and (zerop (imagpart number))
			(plusp (realpart number))))
	       (* #c(0 -1) (cl:log (+ (cl:sqrt (- 1 (^ number 2)))
				      (* #c(0 1) number))))
	       (* #c(0 1) (cl:log (- (cl:sqrt (- 1 (^ number 2)))
				     (* #c(0 1) number)))))))
    (cl:etypecase number
      (cl:single-float
       (cond ((> (%single-floating-abs number) 1.0)
	      (complex-asin number))
	     ((< (%single-floating-abs number) (sqrt *eps*)) number)
	     (T (single-asin number))))
      (cl:double-float
       (cond ((> (abs number) 1.0d0)
	      (complex-asin number))
	     ((< (abs number) *double-sqrt-eps*) number)
	     (T (double-asin number))))
      (cl:complex (complex-asin number))
      (cl:number (cl:asin (float number))))))

(defun cl:acos (number)
  (declare lt:(side-effects simple reducible))
  ;;---I hope we can do a little better than these...
  (flet ((single-acos (number)
	   (cl:atan (cl:sqrt (- 1.0 (* number number))) number))
	 (double-acos (number)
	   (cl:atan (cl:sqrt (- 1.0d0 (* number number))) number))
	 (complex-acos (number)
	   (if (or (minusp (imagpart number))
		   (and (zerop (imagpart number))
			(plusp (realpart number))))
	       (* #c(0 1) (cl:log (- number (* #c(0 1) (cl:sqrt (- 1 (^ number 2)))))))
	       (* #c(0 -1) (cl:log (+ number (* #c(0 1) (cl:sqrt (- 1 (^ number 2))))))))))
    (cl:etypecase number
      (cl:single-float
       (cond ((> (%single-floating-abs number) 1.0)
	      (complex-acos number))
	     ((< (%single-floating-abs number) (sqrt *eps*)) (- (float (// pi 2)) number))
	     (T (single-acos number))))
      (cl:double-float
       (cond ((> (abs number) 1.0d0)
	      (complex-acos number))
	     ((< (abs number) *double-sqrt-eps*) (- (// pi 2) number))
	     (T (double-acos number))))
      (cl:complex (complex-acos number))
      (cl:number (cl:acos (float number))))))

;;; functions which used to be in f:>sys>fortran>libraries, but won't compile
;;; now that double-numer is in si:.  The reason, pointed out by Rick, is that intern
;;; is called by double-name stuff.
;;;
(defun double-mod-components (value-high value-low modulus-high modulus-low)
  (si:with-double-names (value modulus)
    (si:double-- value (double-* modulus (double-ftrunc (double-// value modulus))))))

(defun double-nearest-whole-components (double-high double-low)
  (with-double-names (double)
    (with-float-operating-mode ((:round :zero))
      (double-let* ((abs (double-ftrunc (si:double-+ (double-abs double) 0.5d0))))
	(values (%logdpb (ldb %%double-sign double-high)
			 (byte 1 31.) abs-high)
		abs-low)))))

(defun double-positive-difference-components (a1-high a1-low a2-high a2-low)
  (with-double-names (a1 a2)
    (if (double- a1 a2)
	(double-components 0.0d0)
      (double-- a1 a2))))

(defun double-min-components (double1-high double1-low &rest doubles)
  (with-double-names (double1)
    (loop for (double2-high double2-low) on doubles by 'rest2 do
	  (with-double-names (double2)
	    (if (double-> double1 double2)
		(double-setq double1 double2))))
    (double-value double1)))

(defun double-max-components (double1-high double1-low &rest doubles)
  (with-double-names (double1)
    (loop for (double2-high double2-low) on doubles by 'rest2 do
	  (with-double-names (double2)
	    (if (double-< double1 double2)
		(double-setq double1 double2))))
    (double-value double1)))

(defun double-product-components (real1 real2)
  (double-* (single-to-double real1) (single-to-double real2)))

(defun double-sign-components (double1-high double1-low double2-high double2-low)
  double2-low					;ignored
  (values (%logdpb double1-high %%double-except-sign-high double2-high)
	  double1-low))

(defun dasin-components (num-high num-low)
  (with-double-names (num)
    (double-let* ((abs-num (double-abs num)))
       (cond ((double-> abs-num 1.0d0)
	      (ferror "The range of the argument to arcsin must be -1.0 .. 1.0"))
	     ((double-< abs-num *double-sqrt-eps*)
	      (double-value num))
	     (t
	      (double-atan2 num (double-sqrt (double-- 1.0d0 (double-* num num)))))))))

(defun dacos-components (num-high num-low)
  (with-double-names (num)
    (double-let* ((abs-num (double-abs num)))
       (cond ((double-> abs-num 1.0d0)
	      (ferror "The range of the argument to arccos must be -1.0 .. 1.0"))
	     ((double-< abs-num *double-sqrt-eps*)
	      (double-- (dfloat (// pi 2)) (double-value num)))
	     (t
	      (double-atan2 (double-sqrt (double-- 1.0d0 (double-* num num))) num))))))

(defun dsinh-components (num-high num-low)
  (with-double-names (num)
    (double-let* ((abs-num (double-abs num)))
       (if (double-< abs-num *double-sqrt-eps*)
	   (double-value num)
	 (double-let* ((exp-num (double-exp abs-num))
		       (sinh-num (double-ash (double-- exp-num (double-// 1.0d0 exp-num))
					     -1)))
	   (cond ((double-< num 0.0d0)
		  (double-minus sinh-num))
		 (t (double-value sinh-num))))))))

(defun dcosh-components (num-high num-low)
  (with-double-names (num)
    (double-let* ((exp-num (double-exp num)))
      (double-ash (double-+ exp-num (double-// 1.0d0 exp-num)) -1))))


(defun dtanh-components (num-high num-low)
  (with-double-names (num)
    (double-let* ((abs-num (double-abs num)))
       (if (double-< abs-num *double-sqrt-eps*)
	   (double-value num)
	 (double-let* ((tanh-num
			 (if (double-> abs-num *double-inf-tanh-arg*)
			     (double-components -1.0d0)
			   (double-let* ((exp-1 (double-exp
						  (double-minus (double-ash abs-num 1)))))
			     (double-// (double-- exp-1 1.0d0)
					(double-+ exp-1 1.0d0))))))
	   (cond ((double-> num 0.0d0)
		  (double-minus tanh-num))
		 (t (double-value tanh-num))))))))

;;; The algorithms here should be investigated by Cassels, and call
;;; the double float stuff correctly
(defun sinh (number)
  (declare lt:(side-effects simple reducible))
  (cl:etypecase number
    (cl:single-float
     (let* ((abs-x (%single-floating-abs number))
	    (exp-x (exp abs-x))
	    (//exp-x (// exp-x)))
       (if (< abs-x (sqrt *eps*))
	   number
	   (let ((sinh-x (ash (- exp-x //exp-x) -1)))
	     (if (minusp number) (- sinh-x) sinh-x)))))
    (cl:double-float
     (let* ((abs-x (abs number))
	    (exp-x (exp abs-x))
	    (//exp-x (// exp-x)))
       (if (< abs-x *double-sqrt-eps*)
	   number
	   (let ((sinh-x (ash (- exp-x //exp-x) -1)))
	     (if (minusp number) (- sinh-x) sinh-x)))))
    (cl:complex
     (box-complex-operation
       (lambda (real imag)
	 (if (zerop imag)
	     (values-with-typed-zero (sinh real))
	     (multiple-value-bind (cosh sinh) (cosh-and-sinh real)
	       (multiple-value-bind (cos sin) (cos-and-sin imag)
		 (values (* sinh cos) (* cosh sin))))))
       number))
    (cl:number (sinh (float number)))))

(defun cosh (number)
  (declare lt:(side-effects simple reducible))
  (cl:etypecase number
    (cl:single-float
      (let ((exp-x (exp (%single-floating-abs number))))
	(if ( exp-x (// (sqrt cl:single-float-epsilon)))
	    (ash exp-x -1)
	    (ash (+ exp-x (// exp-x)) -1))))
    (cl:double-float
      (let ((exp-x (exp (abs number))))
	(if ( exp-x (// (sqrt cl:double-float-epsilon)))
	    (ash exp-x -1)
	    (ash (+ exp-x (// exp-x)) -1))))
    (cl:complex
     (box-complex-operation
       (lambda (real imag)
	 (if (zerop imag)
	     (values-with-typed-zero (cosh real))
	     (multiple-value-bind (cosh sinh) (cosh-and-sinh real)
	       (multiple-value-bind (cos sin) (cos-and-sin imag)
		 (values (* cosh cos) (* sinh sin))))))
       number))
    (cl:number
      (cosh (float number)))))

(defun cosh-and-sinh (real-x)
  (cl:etypecase real-x
    (cl:single-float
      (let* ((abs-x (%single-floating-abs real-x))
	     (exp-x (exp abs-x)))
	(if ( exp-x (// (sqrt cl:single-float-epsilon)))
	    (let* ((cosh-x (ash exp-x -1)))
	      (values cosh-x (if (minusp real-x) (- cosh-x) cosh-x)))
	    (let* ((//exp-x (rational-quotient exp-x))
		   (cosh-x (ash (+ exp-x //exp-x) -1))
		   (sinh-x (if (< abs-x cl:single-float-epsilon)
			       abs-x
			       (ash (- exp-x //exp-x) -1))))
	      (values cosh-x (if (minusp real-x) (- sinh-x) sinh-x))))))
    (cl:double-float
      (let* ((abs-x (abs real-x))
	     (exp-x (exp abs-x)))
	(if ( exp-x (// (sqrt cl:double-float-epsilon)))
	    (let* ((cosh-x (ash exp-x -1)))
	      (values cosh-x (if (minusp real-x) (- cosh-x) cosh-x)))
	    (let* ((//exp-x (rational-quotient exp-x))
		   (cosh-x (ash (+ exp-x //exp-x) -1))
		   (sinh-x (if (< abs-x cl:double-float-epsilon)
			       abs-x
			       (ash (- exp-x //exp-x) -1))))
	      (values cosh-x (if (minusp real-x) (- sinh-x) sinh-x))))))
    (future-common-lisp:real
      (cosh-and-sinh (float real-x)))))

(defun tanh (number)
  (declare lt:(side-effects simple reducible))
  (cl:etypecase number
    (cl:single-float
      (let ((abs-x (%single-floating-abs number)))
	(if (< abs-x (sqrt *eps*))
	    number
	    (let ((tanh-x (if (> abs-x *inf-tanh-arg*)
			      -1.0
			      (let ((exp-1 (exp (- (ash abs-x 1)))))
				(// (1- exp-1) (1+ exp-1))))))
	      (if (> number 0) (- tanh-x) tanh-x)))))
    (cl:double-float
      (let ((abs-x (abs number)))
	(if (< abs-x (sqrt *eps*))
	    number
	    (let ((tanh-x (if (> abs-x *double-inf-tanh-arg*)
			      -1.0d0
			      (let ((exp-1 (exp (- (ash abs-x 1)))))
				(// (1- exp-1) (1+ exp-1))))))
	      (if (> number 0) (- tanh-x) tanh-x)))))
    (cl:complex
      (box-complex-operation
	(lambda (real imag)
	  (if (zerop imag)
	      (values-with-typed-zero (tanh real))
	      (let ((abs-real (if (minusp real) (- real) real)))
		(if (> abs-real (if (double-float-p real)
				    *double-inf-tanh-arg*
				    *inf-tanh-arg*))
		    (if (double-float-p real)
			(values (if (minusp real) -1.0d0 1.0d0)
				(if ( abs-real (// (log (nextafter +1d 0.0)) 2))
				    0.0d0
				    (// (sin (* 2 imag)) (cosh (* 2 real)))))
			(values (if (minusp real) -1.0 1.0)
				(if ( abs-real (// (log (nextafter +1e 0.0)) 2))
				    0.0
				    (// (sin (* 2 imag)) (cosh (* 2 real))))))
		    (multiple-value-bind (cosh sinh) (cosh-and-sinh (* 2 real))
		      (multiple-value-bind (cos sin) (cos-and-sin (* 2 imag))
			(let ((denom (+ cosh cos)))
			  (values (// sinh denom) (// sin denom)))))))))
	number))
    (cl:number (tanh (float number)))))
