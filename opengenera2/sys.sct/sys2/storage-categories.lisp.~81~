;;; -*- Mode: Lisp; Syntax: ZetaLisp; Package: SI; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;; This file is in the cold load.

;; This file contains the substrate for declaring things to be SAFEGUARDED
;; or WIRED.  See D:>dla>igc>storage-categories.text for complete documentation.

;; Some definitions:
;;   Permanent:    Never gets flipped.  Subset of Static.
;;   Safeguarded:  Never gets scavenged except explicitly.  Subset of Permanent.
;;		   The garbage collector and its clients are safeguarded.
;;   Physical:	   Permanently in physical memory, bypassing virtual memory translation.
;;		   Physical objects are never scavenged except explicitly.
;;   Wired:	   Synonym for physical.  But sometimes in paging code "wired" refers
;;		   to virtual pages which have been made permanent in the PHT.

(DEFCONST *SAFEGUARDED-AREAS* (LIST SAFEGUARDED-OBJECTS-AREA
				    STACK-AREA
				    #+IMach CONTROL-STACK-AREA
				    #+IMach STRUCTURE-STACK-AREA))
(DEFCONST *WIRED-AREAS* (LIST WIRED-CONTROL-TABLES))

#+3600
(DEFUN WIRED-P (OBJECT)
  (OR (%POINTER-LESSP OBJECT %WIRED-VIRTUAL-ADDRESS-HIGH)
      (= (%LOGLDB %%VMA-EQUALS-AMEM (%POINTER OBJECT)) %VMA-EQUALS-AMEM)))

#+IMach
(DEFSUBST WIRED-P (OBJECT)
  (= (%LDB %%VMA-ZONE-NUM OBJECT) %WIRED-ZONE))

#+3600
(DEFUN SAFEGUARDED-P (OBJECT)
  (CL:MEMBER (%AREA-NUMBER OBJECT) *SAFEGUARDED-AREAS*))

#+IMach
(DEFSUBST SAFEGUARDED-P (OBJECT)
  (= (%LDB %%VMA-ZONE-NUM OBJECT) %SAFEGUARDED-ZONE))

#+3600
(DEFSUBST WIRED-OR-SAFEGUARDED-P (OBJECT)
  (OR (WIRED-P OBJECT) (SAFEGUARDED-P OBJECT)))

#+IMach ;; Tweak this on Ivory.
(DEFSUBST WIRED-OR-SAFEGUARDED-P (OBJECT)
  (= (%LDB (BYTE (1- (BYTE-SIZE %%VMA-ZONE-NUM))
		 (1+ (BYTE-POSITION %%VMA-ZONE-NUM)))
	   OBJECT)
     (LSH %SAFEGUARDED-ZONE -1)))

;; Returns NIL if queried about an undefined function.
(DEFUN ACTUAL-STORAGE-CATEGORY (REFERENCE-TYPE OBJECT)
  (CL:ECASE REFERENCE-TYPE
    (:CONSTANT )
    (:FUNCTION (IF (FDEFINEDP OBJECT)
		   (SETQ OBJECT (FDEFINITION OBJECT))
		   (RETURN-FROM ACTUAL-STORAGE-CATEGORY NIL)))
    (:FUNCTION-CELL (SETQ OBJECT (FOLLOW-CELL-FORWARDING (FDEFINITION-LOCATION OBJECT) NIL)))
    (:VARIABLE (SETQ OBJECT (FOLLOW-CELL-FORWARDING (LOCF (SYMBOL-VALUE-CELL OBJECT)) NIL))))
  (COND ((WIRED-P OBJECT) :WIRED)
	((SAFEGUARDED-P OBJECT) :SAFEGUARDED)
	(T :UNSAFEGUARDED)))

(DEFUN STORAGE-CATEGORY-LESSP (CATEGORY1 CATEGORY2)
  (CL:CASE CATEGORY1
    (:WIRED NIL)
    (:SAFEGUARDED (EQ CATEGORY2 :WIRED))
    (OTHERWISE (CL:MEMBER CATEGORY2 '(:WIRED :SAFEGUARDED)))))

(DEFUN CHECK-STORAGE-TYPE-CONSISTENCY ()
  (FLET ((UNSAFEGUARDED-P (THING)
	   (NOT (OR (WIRED-P THING) (SAFEGUARDED-P THING)))))
    (WITH-FAST-STORAGE-ACCESSORS (AREA-REGION-LIST REGION-LIST-THREAD
				  REGION-ORIGIN REGION-LENGTH REGION-FREE-POINTER)
      (LOOP FOR AREA BELOW (N-AREAS) DO
	(LOOP FOR REGION = (AREA-REGION-LIST AREA) THEN (REGION-LIST-THREAD REGION)
	      WHILE (REGION-VALID-P REGION)
	      AS ORIGIN = (REGION-ORIGIN REGION)
	      WHEN (CL:MEMBER AREA *WIRED-AREAS*)
		DO (LET ((LENGTH (REGION-FREE-POINTER REGION)))
		     (UNLESS (AND (WIRED-P ORIGIN)
				  (OR (ZEROP LENGTH)
				      (WIRED-P (%32-BIT-DIFFERENCE
						 (%32-BIT-PLUS ORIGIN LENGTH) 1))))
		       (FORMAT T "~%Area ~A region ~O is not properly wired."
			       (AREA-NAME AREA) REGION)))
	      ELSE WHEN (CL:MEMBER AREA *SAFEGUARDED-AREAS*)
		     DO (LET ((LENGTH (REGION-LENGTH REGION)))
			  (UNLESS (AND (SAFEGUARDED-P ORIGIN)
				       (OR (ZEROP LENGTH)
					   (SAFEGUARDED-P (%32-BIT-DIFFERENCE
							    (%32-BIT-PLUS ORIGIN LENGTH) 1))))
			    (FORMAT T "~%Area ~A region ~O is not properly safeguarded."
				    (AREA-NAME AREA) REGION)))
	      ELSE
		DO (LET ((LENGTH (REGION-LENGTH REGION)))
		     (UNLESS (AND (UNSAFEGUARDED-P ORIGIN)
				  (OR (ZEROP LENGTH)
				      (UNSAFEGUARDED-P (%32-BIT-DIFFERENCE
							 (%32-BIT-PLUS ORIGIN LENGTH) 1))))
		       (FORMAT T "~%Area ~A region ~O is mistakenly wired or safeguarded."
			       (AREA-NAME AREA) REGION))))))))

;; Reference Mapping -- Machine-independent mapping constructs.

;; DO-FUNCTION-CONSTANTS (const-var &optional location-var) cf &body body
;;   Maps over all "constants" referenced by a compiled function.  Does not
;;   map over any "variables".
;; DO-FUNCTION-REFERENCES (reference-type reference) cf &body body
;;   Maps over all external references of a compiled function.  REFERENCE-TYPE
;;   may be one of :CONSTANT, :FUNCTION, or :VARIABLE.   Within the body,
;;   the macro (SET-FUNCTION-REFERENCE type reference) sets the current reference
;; MAP-OVER-REFERENCE constant function
;;   maps functions recursively over all references from a constant.  Does not
;;   recurse into compiled functions.  Function is applied to 
;;   (reference-type reference location).

#+IMach
(DEFMACRO DO-COMPILED-FUNCTION-INSTRUCTIONS
	  ((INSTRUCTION-WORD-VARIABLE &OPTIONAL LOCATION-VARIABLE
	    &KEY (BAR 2) (PREFETCH NIL) (SKIP-ENTRY-INSTRUCTION NIL))
	   FUNCTION &BODY BODY)
  `(WITH-BLOCK-REGISTERS (,BAR)
     ;; Most callers skip the entry instruction word since it can't contain a constant.
     ;; Loop until we see the sequencing fence.
     (SETF (%BLOCK-REGISTER ,BAR)
	   ,(IF SKIP-ENTRY-INSTRUCTION
		`(%POINTER-PLUS ,FUNCTION 1)
		FUNCTION))
     (LOOP ,@(WHEN LOCATION-VARIABLE
	       `(AS ,LOCATION-VARIABLE = (%BLOCK-REGISTER ,BAR)))
	   AS ,INSTRUCTION-WORD-VARIABLE = (%BLOCK-READ ,BAR :CYCLE-TYPE %MEMORY-SCAVENGE
							     :SET-CDR-NEXT NIL
							     :PREFETCH ,PREFETCH)
	   UNTIL (= (LDB %%Q-CDR-CODE-WITHIN-TAG (%TAG ,INSTRUCTION-WORD-VARIABLE))
		    SEQUENCING-FENCE)
	   DO (PROGN . ,BODY))))

#+3600
(DEFMACRO DO-COMPILED-FUNCTION-CONSTANT-TABLE ((CONSTANT-VARIABLE &OPTIONAL LOCATION-VARIABLE)
					       FUNCTION &BODY BODY)
  (LET ((LOCATION-VARIABLE (OR LOCATION-VARIABLE (GENSYM)))
	(OFFSET (GENSYM)))
    `(LOOP WITH ,OFFSET = (%P-LDB %%ENTRY-INSTRUCTION-TABLE-SIZE ,FUNCTION)
	   WITH ,LOCATION-VARIABLE = (%MAKE-POINTER-OFFSET
				       DTP-LOCATIVE ,FUNCTION (- -1 ,OFFSET))
	   REPEAT ,OFFSET
	   AS ,CONSTANT-VARIABLE = (%P-CONTENTS-INCREMENT-POINTER ,LOCATION-VARIABLE)
	   DO (PROGN . ,BODY))))

;; Maps over the simple constants of a function.
;; This returns semantically different things on different processors, and in
;; different linking modes.  Use this only when that doesn't matter, otherwise
;; use the above primitives
(DEFMACRO DO-FUNCTION-CONSTANTS ((CONSTANT-VARIABLE &OPTIONAL LOCATION-VARIABLE
						    &KEY SHARABLE READ-ONLY)
				 FUNCTION &BODY BODY)
  (LET ((SHARABLE-TEMP (GENSYM))
	(READ-ONLY-TEMP (GENSYM))
	(DEBUG-INFO-TEMP (GENSYM)))
    `(LET* (,@(AND (OR SHARABLE READ-ONLY)
		   `((,DEBUG-INFO-TEMP (COMPILED-FUNCTION-DEBUGGING-INFO ,FUNCTION))))
	    ,@(AND SHARABLE
		   `((,SHARABLE-TEMP (CDR (ASSQ 'SI:UNSHARABLE-CONSTANTS ,DEBUG-INFO-TEMP)))))
	    ,@(AND READ-ONLY
		   `((,READ-ONLY-TEMP (CDR (ASSQ 'SI:WRITABLE-CONSTANTS ,DEBUG-INFO-TEMP))))))
       (#+3600  DO-COMPILED-FUNCTION-CONSTANT-TABLE
	#+IMach DO-COMPILED-FUNCTION-INSTRUCTIONS (,CONSTANT-VARIABLE ,LOCATION-VARIABLE) ,FUNCTION
	(WHEN (AND #+IMach ( DTP-FIXNUM
			      (LDB %%Q-TYPE-WITHIN-TAG (%TAG ,CONSTANT-VARIABLE))
			      DTP-ODD-PC)
		   (NOT (LOCATIVEP ,CONSTANT-VARIABLE)))
	  (LET (,@(AND SHARABLE
		       `((,SHARABLE (NOT (MEMQ ,CONSTANT-VARIABLE ,SHARABLE-TEMP)))))
		,@(AND READ-ONLY
		       `((,READ-ONLY (NOT (MEMQ ,CONSTANT-VARIABLE ,READ-ONLY-TEMP))))))
	    ,@BODY))))))

#+3600
(DEFMACRO DO-FUNCTION-REFERENCES ((TYPE-VAR REFERENCE-VAR) FUNCTION &BODY BODY)
  `(MACROLET ((SET-FUNCTION-REFERENCE (TYPE REFERENCE)
		`(SETF (LOCATION-CONTENTS .LOCATION.)
		       ,(CL:ECASE TYPE
			  (:CONSTANT REFERENCE)
			  (:FUNCTION `(FOLLOW-CELL-FORWARDING
					(FDEFINITION-LOCATION ,REFERENCE) NIL))
			  (:VARIABLE `(FOLLOW-CELL-FORWARDING
					(VALUE-CELL-LOCATION ,REFERENCE) NIL))))))
     (DO-COMPILED-FUNCTION-CONSTANT-TABLE (.CONTENTS. .LOCATION.) ,FUNCTION
       (MULTIPLE-VALUE-BIND (,REFERENCE-VAR ,TYPE-VAR)
	   (IF (LOCATIVEP .CONTENTS.)
	       (COMPILER:DISASSEMBLE-DECODE-LOCATIVE .CONTENTS.)
	       (VALUES .CONTENTS. :CONSTANT))
	 (WHEN (EQ ,TYPE-VAR :RANDOM)
	   (SETQ ,TYPE-VAR :CONSTANT))
	 . ,BODY))))

#+IMach
(DEFMACRO DO-FUNCTION-REFERENCES ((TYPE-VAR REFERENCE-VAR) FUNCTION &BODY BODY)
  (LET ((BLOCK-NAME (GENSYM)))
    `(MACROLET ((SET-FUNCTION-REFERENCE (TYPE REFERENCE)
		  `(PROGN (SETF (%BLOCK-REGISTER 2) (%POINTER-PLUS (%BLOCK-REGISTER 2) -1))
			  (%BLOCK-WRITE 2
			    ,(CL:ECASE TYPE
			       (:CONSTANT REFERENCE)
			       (:FUNCTION `(FOLLOW-CELL-FORWARDING
					     (FDEFINITION-LOCATION ,REFERENCE) NIL))
			       (:VARIABLE `(FOLLOW-CELL-FORWARDING
					     (VALUE-CELL-LOCATION ,REFERENCE) NIL)))))))
       (DO-COMPILED-FUNCTION-INSTRUCTIONS (.INSTRUCTION.) ,FUNCTION
	 (BLOCK ,BLOCK-NAME
	   (MULTIPLE-VALUE-BIND (,REFERENCE-VAR ,TYPE-VAR)
	       (COND ;; Common case first.
		     (( (LDB %%Q-TYPE-WITHIN-TAG (%TAG .INSTRUCTION.))
			 DTP-PACKED-INSTRUCTION-60)
		      (RETURN-FROM ,BLOCK-NAME NIL))
		     ((TYPE-MEMBER .INSTRUCTION. DTP-EXTERNAL-VALUE-CELL-POINTER
						 DTP-LOCATIVE
						 DTP-CALL-INDIRECT
						 DTP-CALL-INDIRECT-PREFETCH)
		      (COMPILER:DISASSEMBLE-DECODE-LOCATIVE
			(%SET-TAG .INSTRUCTION. DTP-LOCATIVE)))
		     ((TYPE-MEMBER .INSTRUCTION. DTP-CALL-COMPILED-EVEN
						 DTP-CALL-COMPILED-EVEN-PREFETCH
						 DTP-CALL-COMPILED-ODD
						 DTP-CALL-COMPILED-ODD-PREFETCH)
		      (VALUES (CAR (CCA-EXTRA-INFO (%FIND-STRUCTURE-LEADER .INSTRUCTION.)))
			      :FUNCTION))
		     ((TYPE-MEMBER .INSTRUCTION. DTP-CALL-GENERIC
						 DTP-CALL-GENERIC-PREFETCH)
		      (VALUES (%SET-TAG .INSTRUCTION. DTP-GENERIC-FUNCTION)
			      :CONSTANT))
		     (T (VALUES .INSTRUCTION. :CONSTANT)))
	     (COMPILER:%ERROR-WHEN (EQ ,TYPE-VAR :RANDOM)
	       (SETQ ,TYPE-VAR :CONSTANT))
	     . ,BODY))))))

(DEFUN MAP-OVER-REFERENCE (REFERENCE LOCATION FUNCTION)
  (DECLARE (DOWNWARD-FUNARG FUNCTION))
  (MULTIPLE-VALUE-BIND (REFERENCE REFERENCE-TYPE)
      (IF (LOCATIVEP REFERENCE)
	  (COMPILER:DISASSEMBLE-DECODE-LOCATIVE REFERENCE)
	  (VALUES REFERENCE :CONSTANT))
    (WHEN (EQ REFERENCE-TYPE :RANDOM)
      (SETQ REFERENCE-TYPE :CONSTANT))
    ;; Ultra-kludge.  But then again, I think everything in the system would break
    ;; if COMPILER:EVAL-AT-LOAD-TIME-MARKER got stored inside list structures.
    (WHEN (AND (EQ REFERENCE-TYPE :CONSTANT)
	       (CL:CONSP REFERENCE)
	       (VARIABLE-BOUNDP COMPILER:EVAL-AT-LOAD-TIME-MARKER)
	       (EQ (CAR REFERENCE) COMPILER:EVAL-AT-LOAD-TIME-MARKER))
      (RETURN-FROM MAP-OVER-REFERENCE NIL))
    (FUNCALL FUNCTION REFERENCE-TYPE REFERENCE LOCATION)
    (WHEN (EQ REFERENCE-TYPE :CONSTANT)
      ;; Map over the modified reference!
      (WHEN LOCATION
	(SETQ REFERENCE (LOCATION-CONTENTS LOCATION)))
      (COND (#+3600  (CL:CONSP REFERENCE)
	     #+IMach (OR (TYPE-MEMBER REFERENCE
				      DTP-LIST DTP-LEXICAL-CLOSURE DTP-DYNAMIC-CLOSURE)
			 (TYPE-MEMBER REFERENCE
				      DTP-DOUBLE-FLOAT DTP-BIG-RATIO DTP-COMPLEX))
	     (DO ((R #+3600 REFERENCE #+IMach (%SET-TAG REFERENCE DTP-LIST) (CDR R)))
		 ((ATOM (CDR R))
		  (MAP-OVER-REFERENCE (CAR R) (LOCF (CAR R)) FUNCTION)
		  (WHEN (CDR R)
		    (MAP-OVER-REFERENCE (CDR R) R FUNCTION)))
	       (MAP-OVER-REFERENCE (CAR R) (LOCF (CAR R)) FUNCTION)))
	    ((AND (ARRAYP REFERENCE)
		  (CL:MEMBER (ARRAY-TYPE REFERENCE) '(ART-Q ART-Q-LIST))
		  (ARRAY-CAN-BE-COPIED-P REFERENCE))
	     (DOTIMES (I (ARRAY-TOTAL-SIZE REFERENCE))
	       (MAP-OVER-REFERENCE (%1D-AREF REFERENCE I) (%1D-ALOC REFERENCE I) FUNCTION))
	     (WHEN (ARRAY-HAS-LEADER-P REFERENCE)
	       (DOTIMES (I (ARRAY-LEADER-LENGTH REFERENCE))
		 (MAP-OVER-REFERENCE (ARRAY-LEADER REFERENCE I)
				     (LOCF (ARRAY-LEADER REFERENCE I))
				     FUNCTION))))))))

;; Storage Categories are :WIRED, :SAFEGUARDED, :UNSAFEGUARDED, or NIL (undeclared).

;; Storage category declarations are put into the debugging info via the DEBUG-INFO
;; mechanism, and then canonicalized into a STORAGE-CATEGORY declaration.  The
;; storage category declaration which goes on the debugging info looks like
;; (SYS:STORAGE-CATEGORY <descriptor> . <references>)
;; The descriptor is a fixnum with byte fields:

(DEFSTRUCT (FUNCTION-STORAGE-CATEGORY-DESCRIPTOR (:TYPE FIXNUM) (:CONC-NAME FSC-DESC-))
   ((FUNCTION-STORAGE-CATEGORY (BYTE 2 0))	;The function storage category
    (DISABLE-REFERENCE-VALIDATION (BYTE 1 2))	;Like it says.
						;... 2 spare bits
    (WIRED-REFERENCE-COUNT (BYTE 8 5))		;Number of wired references which follow
    (SAFEGUARDED-REFERENCE-COUNT (BYTE 8 13))	;Number of safeguarded references which follow
    (UNSAFEGUARDED-REFERENCE-COUNT (BYTE 8 21))	;Price of SMBX in 3 months
    ))						;... and 3 spare bits

(DEFPROP WIRED-FUNCTION			T DEBUG-INFO)
(DEFPROP SAFEGUARDED-FUNCTION		T DEBUG-INFO)
(DEFPROP UNSAFEGUARDED-FUNCTION 	T DEBUG-INFO)

(DEFPROP WIRED-REFERENCE		T DEBUG-INFO)
(DEFPROP SAFEGUARDED-REFERENCE		T DEBUG-INFO)
(DEFPROP UNSAFEGUARDED-REFERENCE	T DEBUG-INFO)

(DEFVAR *STORAGE-CATEGORY-DECLARATIONS*
	'(WIRED-FUNCTION SAFEGUARDED-FUNCTION UNSAFEGUARDED-FUNCTION
	  WIRED-REFERENCE SAFEGUARDED-REFERENCE UNSAFEGUARDED-REFERENCE))

(DEFCONSTANT %STORAGE-CATEGORY-UNSAFEGUARDED 0)
(DEFCONSTANT %STORAGE-CATEGORY-SAFEGUARDED 1)
(DEFCONSTANT %STORAGE-CATEGORY-WIRED 2)

;; '#. so the cold loader can load this.
(DEFCONST *STORAGE-CATEGORIES*		;The storage category symbols, in order.
	  '#.(CL:VECTOR :UNSAFEGUARDED :SAFEGUARDED :WIRED))

;; '#. so the cold loader can load this.
(DEFCONST *FUNCTION-CATEGORY-DECLARATIONS*	 ;The corresponding function declarations,
	  '#.(CL:VECTOR 'UNSAFEGUARDED-FUNCTION	 ;in order.
			'SAFEGUARDED-FUNCTION
			'WIRED-FUNCTION))

;; '#. so the cold loader can load this.
(DEFCONST *FUNCTION-REFERENCE-DECLARATIONS*	 ;The corresponding reference declarations,
	  '#.(CL:VECTOR 'UNSAFEGUARDED-REFERENCE ;in order.
			'SAFEGUARDED-REFERENCE
			'WIRED-REFERENCE))

(DEFUN CANONICALIZE-STORAGE-CATEGORY-DEBUGGING-INFO
       (DEBUGGING-INFO &OPTIONAL INHERITED-STORAGE-CATEGORY)
  (DECLARE (VALUES DEBUGGING-INFO))
  (LET ((RELEVANT-ENTRIES (LOOP FOR FROB IN DEBUGGING-INFO
				WHEN (CL:MEMBER (CAR FROB) *STORAGE-CATEGORY-DECLARATIONS*)
				  COLLECT FROB)))
    (IF (AND (NULL RELEVANT-ENTRIES)
	     (MEMQ INHERITED-STORAGE-CATEGORY '(NIL :UNSAFEGUARDED)))
	DEBUGGING-INFO ;Don't bother consing up a new copy; return NIL for other values.
      (LET* ((BASHED-DEBUGGING-INFO (CL:SET-DIFFERENCE DEBUGGING-INFO RELEVANT-ENTRIES))
	     (DISABLE-REFERENCE-VALIDATION 0)
	     (FUNCTION-STORAGE-CATEGORY
	       (LOOP WITH STORAGE-CATEGORY = NIL
		     FOR FROB IN RELEVANT-ENTRIES
		     AS CATEGORY = (CL:POSITION (CAR FROB) *FUNCTION-CATEGORY-DECLARATIONS*)
		     WHEN CATEGORY
		       DO (WHEN (EQ (CADR FROB) 'DISABLE-REFERENCE-VALIDATION)
			    (SETQ DISABLE-REFERENCE-VALIDATION 1))
			  (IF STORAGE-CATEGORY
			      (WARN "Conflicting storage category declarations, ~
				     using the first.")
			      (SETQ STORAGE-CATEGORY CATEGORY))
		     FINALLY
		       (UNLESS STORAGE-CATEGORY
			 (SETQ STORAGE-CATEGORY
			       (CL:POSITION INHERITED-STORAGE-CATEGORY *STORAGE-CATEGORIES*)))
		       (IF STORAGE-CATEGORY
			   (RETURN STORAGE-CATEGORY)
			 (WARN "Declarations related to storage categories exist, but no~@
				storage category declarations are present.  Assuming~@
				that UNSAFEGUARDED-FUNCTION was intended.")
			 (RETURN %STORAGE-CATEGORY-UNSAFEGUARDED))))
	     UNSAFEGUARDED-REFERENCES
	     SAFEGUARDED-REFERENCES
	     WIRED-REFERENCES)
	(LOOP FOR FROB IN RELEVANT-ENTRIES DO
	  (CL:CASE (CAR FROB)
	    (UNSAFEGUARDED-REFERENCE
	     (SETQ UNSAFEGUARDED-REFERENCES (APPEND UNSAFEGUARDED-REFERENCES (CDR FROB))))
	    (SAFEGUARDED-REFERENCE
	     (SETQ SAFEGUARDED-REFERENCES (APPEND SAFEGUARDED-REFERENCES (CDR FROB))))
	    (WIRED-REFERENCE
	     (SETQ WIRED-REFERENCES (APPEND WIRED-REFERENCES (CDR FROB))))))
	(CONS (LIST* 'STORAGE-CATEGORY
		     (MAKE-FUNCTION-STORAGE-CATEGORY-DESCRIPTOR
		       FUNCTION-STORAGE-CATEGORY FUNCTION-STORAGE-CATEGORY
		       DISABLE-REFERENCE-VALIDATION DISABLE-REFERENCE-VALIDATION
		       WIRED-REFERENCE-COUNT (LENGTH WIRED-REFERENCES)
		       SAFEGUARDED-REFERENCE-COUNT (LENGTH SAFEGUARDED-REFERENCES)
		       UNSAFEGUARDED-REFERENCE-COUNT (LENGTH UNSAFEGUARDED-REFERENCES))
		     (APPEND WIRED-REFERENCES
			     SAFEGUARDED-REFERENCES
			     UNSAFEGUARDED-REFERENCES))
	      BASHED-DEBUGGING-INFO)))))

(DEFUN ENCODE-STORAGE-CATEGORY-DEBUGGING-INFO-ENTRY (FUNCTION-STORAGE-CATEGORY
						     DISABLE-REFERENCE-VALIDATION
						     WIRED-REFERENCES
						     SAFEGUARDED-REFERENCES
						     UNSAFEGUARDED-REFERENCES)
  (DECLARE (VALUES DEBUGGING-INFO-ENTRY))
  (LIST* 'STORAGE-CATEGORY
	 (MAKE-FUNCTION-STORAGE-CATEGORY-DESCRIPTOR
	   FUNCTION-STORAGE-CATEGORY (CL:POSITION FUNCTION-STORAGE-CATEGORY
						  *STORAGE-CATEGORIES*)
	   DISABLE-REFERENCE-VALIDATION (IF DISABLE-REFERENCE-VALIDATION 1 0)
	   WIRED-REFERENCE-COUNT (LENGTH WIRED-REFERENCES)
	   SAFEGUARDED-REFERENCE-COUNT (LENGTH SAFEGUARDED-REFERENCES)
	   UNSAFEGUARDED-REFERENCE-COUNT (LENGTH UNSAFEGUARDED-REFERENCES))
	 (APPEND WIRED-REFERENCES
		 SAFEGUARDED-REFERENCES
		 UNSAFEGUARDED-REFERENCES)))

(DEFUN DECODE-STORAGE-CATEGORY-DEBUGGING-INFO (DEBUGGING-INFO)
  (DECLARE (VALUES FUNCTION-STORAGE-CATEGORY
		   DISABLE-REFERENCE-VALIDATION
		   WIRED-REFERENCES
		   SAFEGUARDED-REFERENCES
		   UNSAFEGUARDED-REFERENCES))
  (LET ((ENTRY (CL:ASSOC 'STORAGE-CATEGORY DEBUGGING-INFO)))
    (WHEN ENTRY
      (DECODE-STORAGE-CATEGORY-DEBUGGING-INFO-ENTRY ENTRY))))

(DEFUN DECODE-STORAGE-CATEGORY-DEBUGGING-INFO-ENTRY (ENTRY)
  (DECLARE (VALUES FUNCTION-STORAGE-CATEGORY
		   DISABLE-REFERENCE-VALIDATION
		   WIRED-REFERENCES
		   SAFEGUARDED-REFERENCES
		   UNSAFEGUARDED-REFERENCES))
  (WHEN ENTRY
    (LET* ((CDR (CDR ENTRY))
	   (DESCRIPTOR (POP CDR)))
      (VALUES (AREF *STORAGE-CATEGORIES* (FSC-DESC-FUNCTION-STORAGE-CATEGORY DESCRIPTOR))
	      (PLUSP (FSC-DESC-DISABLE-REFERENCE-VALIDATION DESCRIPTOR))
	      (LOOP REPEAT (FSC-DESC-WIRED-REFERENCE-COUNT DESCRIPTOR)
		    COLLECT (POP CDR))
	      (LOOP REPEAT (FSC-DESC-SAFEGUARDED-REFERENCE-COUNT DESCRIPTOR)
		    COLLECT (POP CDR))
	      (LOOP REPEAT (FSC-DESC-UNSAFEGUARDED-REFERENCE-COUNT DESCRIPTOR)
		    COLLECT (POP CDR))))))

(DEFCONSTANT *REFERENCE-TYPE-DECLARATION-ALIST*
	     '((:FUNCTION FUNCTION-STORAGE-CATEGORY)
	       (:FUNCTION-CELL FUNCTION-CELL-STORAGE-CATEGORY)
	       (:VARIABLE VARIABLE-STORAGE-CATEGORY)
	       (:CONSTANT CONSTANT-STORAGE-CATEGORY)))

;; This returns NIL if a storage category hasn't been declared yet.
(DEFUN DECLARED-STORAGE-CATEGORY (REFERENCE-TYPE REFERENCE
				  &OPTIONAL (COMPILER-ENVIRONMENT-P T))
  (OR (AND COMPILER-ENVIRONMENT-P
	   (MULTIPLE-VALUE-BIND (VALUE FOUND)
	       (COMPILER:FILE-DECLARATION
		 REFERENCE
		 (OR (CADR (CL:ASSOC REFERENCE-TYPE *REFERENCE-TYPE-DECLARATION-ALIST*))
		     (ERROR "Unknown reference type ~S" REFERENCE-TYPE)))
	     (WHEN FOUND
	       ;; Force NIL to be returned if there is an entry which says NIL.
	       (RETURN-FROM DECLARED-STORAGE-CATEGORY VALUE))))
      (CL:ECASE REFERENCE-TYPE
	(:FUNCTION
	  ;;--- This line is a kludge for cross-compilation.
	  (OR (FUNCTION-SPEC-GET REFERENCE 'FUNCTION-STORAGE-CATEGORY)
	      (LET ((DEFINITION (VALID-FUNCTION-DEFINITION REFERENCE)))
		(COND ;; If it's defined as a compile function, use the function's
		  ;; declared storage category.
		  ((TYPEP DEFINITION :COMPILED-FUNCTION)
		   (IF (PROGN #+3600 NIL
			      #+IMach (ZEROP (%REGION-NUMBER DEFINITION)))
		       :WIRED			;All FEP functions are wired.
		       (VALUES
			 (DECODE-STORAGE-CATEGORY-DEBUGGING-INFO
			   (COMPILED-FUNCTION-DEBUGGING-INFO DEFINITION)))))
		  ;; If the function isn't defined yet, return NIL.
		  ((NULL DEFINITION) NIL)
		  ;; If the function isn't compiled, return :UNSAFEGUARDED.
		  (T :UNSAFEGUARDED)))))
	(:FUNCTION-CELL
	 ;; If it has no declaration, return NIL regardless of its definition status.
	 (FUNCTION-SPEC-GET REFERENCE 'FUNCTION-CELL-STORAGE-CATEGORY))
	(:VARIABLE
	 (CL:CHECK-TYPE REFERENCE SYMBOL)
	 ;; If the variable isn't defined yet, return NIL.
	 (GET REFERENCE 'VARIABLE-STORAGE-CATEGORY))
	(:CONSTANT
	 (CL:CHECK-TYPE REFERENCE SYMBOL)
	 (COND #+IMach ((CL:MEMBER REFERENCE '(T NIL)) :WIRED)
	       (T (LET ((PKG (SYMBOL-PACKAGE REFERENCE)))
		    (COND ((NULL PKG) :UNSAFEGUARDED)
			  ((CL:MEMBER REFERENCE (PKG-SAFEGUARDED-SYMBOLS PKG) :TEST #'STRING=)
			   :SAFEGUARDED)
			  (T :UNSAFEGUARDED)))))))))

(DEFMACRO DECLARE-STORAGE-CATEGORY (REFERENCE-TYPE REFERENCE CATEGORY)
  `(PROGN (EVAL-WHEN (COMPILE)
	    (DECLARE-STORAGE-CATEGORY-COMPILE ',REFERENCE-TYPE ',REFERENCE ',CATEGORY))
	  (EVAL-WHEN (LOAD EVAL)
	    (DECLARE-STORAGE-CATEGORY-LOAD ',REFERENCE-TYPE ',REFERENCE ',CATEGORY))))

(DEFUN DECLARE-STORAGE-CATEGORY-COMPILE (REFERENCE-TYPE REFERENCE CATEGORY)
  (CL:CHECK-TYPE CATEGORY (CL:MEMBER :WIRED :SAFEGUARDED :UNSAFEGUARDED))
  (CL:CHECK-TYPE REFERENCE-TYPE (CL:MEMBER :VARIABLE :FUNCTION :FUNCTION-CELL :CONSTANT))
  (WHEN (EQ REFERENCE-TYPE :VARIABLE)
    (CL:CHECK-TYPE CATEGORY SYMBOL))
  (IF COMPILER:COMPILER-WARNINGS-CONTEXT
      (COMPILER:FILE-DECLARE
	REFERENCE
	(OR (CADR (CL:ASSOC REFERENCE-TYPE *REFERENCE-TYPE-DECLARATION-ALIST*))
	    (ERROR "Unknown reference type ~S" REFERENCE-TYPE))
	CATEGORY)
      (ERROR "DECLARE-STORAGE-CATEGORY-COMPILE called outside of compiler context.")))

(DEFUN DECLARE-STORAGE-CATEGORY-LOAD (REFERENCE-TYPE REFERENCE CATEGORY)
  (CL:CHECK-TYPE CATEGORY (CL:MEMBER :WIRED :SAFEGUARDED :UNSAFEGUARDED))
  (CL:CHECK-TYPE REFERENCE-TYPE (CL:MEMBER :VARIABLE :FUNCTION :FUNCTION-CELL :CONSTANT))
  (CL:CASE REFERENCE-TYPE
    ((:VARIABLE :FUNCTION-CELL)
     (CL:CHECK-TYPE REFERENCE SYMBOL)
     (LET ((DECLARATION (CADR (CL:ASSOC REFERENCE-TYPE *REFERENCE-TYPE-DECLARATION-ALIST*))))
       (IF (EQ CATEGORY :UNSAFEGUARDED)
	   (REMPROP REFERENCE DECLARATION)
	   (SETF (GET REFERENCE DECLARATION) CATEGORY))
       (LET ((ACTUAL (ACTUAL-STORAGE-CATEGORY REFERENCE-TYPE REFERENCE)))
	 (UNLESS (EQ ACTUAL CATEGORY)
	   (FORWARD-SYMBOL-CELL
	     (IF (EQ REFERENCE-TYPE :VARIABLE)
		 (VALUE-CELL-LOCATION REFERENCE)
		 (FUNCTION-CELL-LOCATION REFERENCE))
	     CATEGORY))))
     CATEGORY)
    (OTHERWISE
     (ERROR "~S cannot globally declare storage categories~@
	     of anything except variables and function cells."
	    'DECLARE-STORAGE-CATEGORY-LOAD))))

(DEFUN ARRAY-CAN-BE-COPIED-P (ARRAY)
  (NOT (OR (NAMED-STRUCTURE-P ARRAY)
	   (ARRAY-HAS-LEADER-P ARRAY)
	   (ARRAY-INDIRECT-P ARRAY)
	   (ARRAY-DISPLACED-P ARRAY))))

;; These are optimized out by the compiler and the cold-loader.
;; Their interpreted definitions exist for use in DEFVARs.
;;--- Note that nesting these doesn't work:
;;--- (DEFVAR-WIRED *FOO* (WIRED-REFERENCE (LIST 'A 'B (SAFEGUARDED-REFERENCE "C"))))
;;--- will cause the whole thing to be wired.  Fixing this requires making these
;;--- special forms, which I don't think is worth it.

(DEFUN WIRED-REFERENCE (X)
  (COPY-INTO-STORAGE-CATEGORY X :WIRED))

(DEFUN SAFEGUARDED-REFERENCE (X)
  (COPY-INTO-STORAGE-CATEGORY X :SAFEGUARDED))

(DEFUN UNSAFEGUARDED-REFERENCE (X)
  (COPY-INTO-STORAGE-CATEGORY X :UNSAFEGUARDED))

(DEFUN AREA-FOR-STORAGE-CATEGORY (CATEGORY &OPTIONAL (UNSAFEGUARDED-AREA WORKING-STORAGE-AREA))
  (CL:ECASE CATEGORY
    (:WIRED WIRED-CONTROL-TABLES)
    (:SAFEGUARDED SAFEGUARDED-OBJECTS-AREA)
    (:UNSAFEGUARDED UNSAFEGUARDED-AREA)))

(DEFUN COPY-INTO-STORAGE-CATEGORY (OBJECT CATEGORY)
  (LET ((RESULT OBJECT)
	(AREA (AREA-FOR-STORAGE-CATEGORY CATEGORY)))
    (MAP-OVER-REFERENCE RESULT (LOCF RESULT)
      (LAMBDA (REFERENCE-TYPE REFERENCE LOCATION)
	(DECLARE (DOWNWARD-FUNCTION))
	(CL:CASE REFERENCE-TYPE
	  (:CONSTANT
	    (TYPECASE REFERENCE
	      (:SYMBOL
		(WHEN (AND (NEQ CATEGORY :UNSAFEGUARDED)
			   (EQ (ACTUAL-STORAGE-CATEGORY REFERENCE-TYPE REFERENCE)
			       :UNSAFEGUARDED))
		  (WARN "Constant ~S is has a declared storage category of unsafeguarded,~@
			 but it should be safeguarded to be referenced in this context."
			REFERENCE)))
	      (:LIST
		(SETF (LOCATION-CONTENTS LOCATION) (COPYLIST REFERENCE AREA)))
	      (:STRING
		(SETF (LOCATION-CONTENTS LOCATION) (SUBSTRING REFERENCE 0 NIL AREA)))
	      (:EXTENDED-NUMBER
		(SETF (LOCATION-CONTENTS LOCATION) (COPY-EXTENDED-NUMBER REFERENCE AREA)))
	      (:ARRAY
		(WHEN (AND (CL:MEMBER (ARRAY-TYPE REFERENCE) '(ART-Q ART-Q-LIST))
			   (ARRAY-CAN-BE-COPIED-P REFERENCE))
		  (SETF (LOCATION-CONTENTS LOCATION) (COPY-ARRAY-CONSTANT REFERENCE AREA))))))
	  (OTHERWISE
	    (WARN "Reference to the ~A ~S inside a constant structure."
		  (STRING-DOWNCASE REFERENCE-TYPE) REFERENCE)))))
    RESULT))

#+3600 (PROGN

(DEFUN (WIRED-REFERENCE COMPILER:PHASE-1-HANDLER) (BODY DESTINATION)
  (SPECIAL-REFERENCE-PHASE-1-HANDLER :WIRED BODY DESTINATION))

(DEFUN (SAFEGUARDED-REFERENCE COMPILER:PHASE-1-HANDLER) (BODY DESTINATION)
  (SPECIAL-REFERENCE-PHASE-1-HANDLER :SAFEGUARDED BODY DESTINATION))

(DEFUN (UNSAFEGUARDED-REFERENCE COMPILER:PHASE-1-HANDLER) (BODY DESTINATION)
  (SPECIAL-REFERENCE-PHASE-1-HANDLER :UNSAFEGUARDED BODY DESTINATION))

(DEFUN SPECIAL-REFERENCE-PHASE-1-HANDLER (CATEGORY BODY DESTINATION)
  (UNLESS (= (LENGTH BODY) 1)
    (COMPILER:PHASE-1-BAD-FORM))
  (LET* ((FORM (CAR BODY))
	 (REFERENCE (COND ((SYMBOLP FORM) FORM)
			  ((AND (CL:CONSP FORM)
				(CL:CONSP (CDR FORM))
				(NULL (CDDR FORM))
				(EQ (CAR FORM) 'FUNCTION)
				(VALIDATE-FUNCTION-SPEC (CADR FORM)))
			   (CADR FORM))
			  (T (COMPILER:PHASE-1-BAD-FORM
			       "~S is not a special variable or a function spec reference~@
				and therefore thus cannot be allocated specially." FORM))))
	 (DEBUGGING-INFO (COMPILER:FUNCTION-USER-DECLARES COMPILER:*FUNCTION*)))
    (MULTIPLE-VALUE-BIND (FCAT DRV WREF SREF UREF)
	(DECODE-STORAGE-CATEGORY-DEBUGGING-INFO DEBUGGING-INFO)
      (COND ((NULL FCAT)
	     (WARN "No storage declaration exists; ~S declaration for ~S will be ignored."
		   CATEGORY REFERENCE))
	    ((OR (AND (NOT (EQ CATEGORY :WIRED))
		      (CL:MEMBER REFERENCE WREF))
		 (AND (NOT (EQ CATEGORY :SAFEGUARDED))
		      (CL:MEMBER REFERENCE SREF))
		 (AND (NOT (EQ CATEGORY :UNSAFEGUARDED))
		      (CL:MEMBER REFERENCE UREF)))
	     (WARN "The conflicting ~S declaration for ~S will be ignored."
		   CATEGORY REFERENCE))
	    (T (CL:CASE CATEGORY
		 (:WIRED (CL:PUSHNEW REFERENCE WREF))
		 (:SAFEGUARDED (CL:PUSHNEW REFERENCE SREF))
		 (:UNSAFEGUARDED (CL:PUSHNEW REFERENCE UREF)))
	       (LET ((NEW-ENTRY (ENCODE-STORAGE-CATEGORY-DEBUGGING-INFO-ENTRY
				  FCAT DRV WREF SREF UREF)))
		 (LOOP FOR SUBLIST ON DEBUGGING-INFO
		       WHEN (EQ (CAAR SUBLIST) 'STORAGE-CATEGORY)
			 RETURN (SETF (CAR SUBLIST) NEW-ENTRY)))))
      (IF (SYMBOLP FORM)
	  (COMPILER:PHASE-1-VARIABLE REFERENCE DESTINATION)
	  (COMPILER:PHASE-1-FUNCTION REFERENCE DESTINATION)))))

)

;; Compiler Warnings

(DEFUN ILLEGAL-REFERENCE-P (STORAGE-CATEGORY-DECLARATION
			    REFERENCE-DECLARATION
			    DEFAULT-P)
  (IF DEFAULT-P
      (STORAGE-CATEGORY-LESSP
	REFERENCE-DECLARATION STORAGE-CATEGORY-DECLARATION)
      (NEQ (OR REFERENCE-DECLARATION :UNSAFEGUARDED)
	   (OR STORAGE-CATEGORY-DECLARATION :UNSAFEGUARDED))))

;; Fix this someday to warn if the function later gets defined in the wrong SC.
(DEFVAR *INHIBIT-STORAGE-CATEGORY-FORWARD-REFERENCE-WARNINGS* T)

;; This is the hook for load-time warnings.
;; We assume the loader has put the function and constants in the proper place.
;; Check that everything else is properly located.
(DEFUN VALIDATE-FUNCTION-STORAGE-CATEGORY-DECLARATIONS
       (FUNCTION &OPTIONAL (EXTRA-INFO (CCA-EXTRA-INFO (COMPILED-FUNCTION-CCA FUNCTION))))
  (DESTRUCTURING-BIND (NAME . DEBUG-INFO) EXTRA-INFO
    (LET ((COMPILER:DEFAULT-WARNING-FUNCTION NAME))
      (MULTIPLE-VALUE-BIND (FUNCTION-STORAGE-CATEGORY
			    DISABLE-REFERENCE-VALIDATION
			    WIRED-REFERENCES
			    SAFEGUARDED-REFERENCES
			    UNSAFEGUARDED-REFERENCES)
	  (DECODE-STORAGE-CATEGORY-DEBUGGING-INFO DEBUG-INFO)
	(WHEN (NULL FUNCTION-STORAGE-CATEGORY)
	  (SETQ FUNCTION-STORAGE-CATEGORY :UNSAFEGUARDED))
	(LABELS
	  ((HACK-REFERENCE (REFERENCE-TYPE REFERENCE &OPTIONAL IGNORE)
	     (UNLESS (AND (EQ REFERENCE-TYPE :CONSTANT)
			  (NSYMBOLP REFERENCE))
	       (LET ((DECLARED-STORAGE-CATEGORY
		       (COND ((CL:MEMBER REFERENCE WIRED-REFERENCES :TEST #'CL:EQUAL)
			      :WIRED)
			     ((CL:MEMBER REFERENCE SAFEGUARDED-REFERENCES :TEST #'CL:EQUAL)
			      :SAFEGUARDED)
			     ((CL:MEMBER REFERENCE UNSAFEGUARDED-REFERENCES :TEST #'CL:EQUAL)
			      :UNSAFEGUARDED)))
		     (ACTUAL-STORAGE-CATEGORY (ACTUAL-STORAGE-CATEGORY
						REFERENCE-TYPE REFERENCE)))
		 (COND ((NULL ACTUAL-STORAGE-CATEGORY)
			(UNLESS *INHIBIT-STORAGE-CATEGORY-FORWARD-REFERENCE-WARNINGS*
			  (WARN "Reference to undefined function ~S~%from ~A function ~S."
				REFERENCE (STRING-DOWNCASE FUNCTION-STORAGE-CATEGORY)
				NAME)))
		       (DISABLE-REFERENCE-VALIDATION)
		       (DECLARED-STORAGE-CATEGORY
			(WHEN (NEQ ACTUAL-STORAGE-CATEGORY DECLARED-STORAGE-CATEGORY)
			  (WARN "Reference to ~A ~S was declared ~A,~@
				 but in fact it is currently ~:[undefined~;~:*~A~]."
				(STRING-DOWNCASE REFERENCE-TYPE) REFERENCE
				(STRING-DOWNCASE DECLARED-STORAGE-CATEGORY)
				(AND ACTUAL-STORAGE-CATEGORY
				     (STRING-DOWNCASE ACTUAL-STORAGE-CATEGORY)))))
		       (T (LET ((REQUIRED-STORAGE-CATEGORY
				  (IF (AND (EQ FUNCTION-STORAGE-CATEGORY :WIRED)
					   (EQ REFERENCE-TYPE :CONSTANT))
				      :SAFEGUARDED
				      FUNCTION-STORAGE-CATEGORY)))
			    (WHEN (STORAGE-CATEGORY-LESSP
				    ACTUAL-STORAGE-CATEGORY REQUIRED-STORAGE-CATEGORY)
			      (WARN "~A ~S is ~A,~%but it must be ~A to be referenced from ~S."
				    (STRING-CAPITALIZE-WORDS REFERENCE-TYPE) REFERENCE
				    (STRING-DOWNCASE ACTUAL-STORAGE-CATEGORY)
				    (STRING-DOWNCASE REQUIRED-STORAGE-CATEGORY)
				    NAME)))))))))
	(DO-FUNCTION-REFERENCES (REFERENCE-TYPE REFERENCE) FUNCTION
	  (IF (AND (EQ REFERENCE-TYPE :CONSTANT)
		   (NSYMBOLP REFERENCE))
	      (MAP-OVER-REFERENCE REFERENCE NIL #'HACK-REFERENCE)
	      (HACK-REFERENCE REFERENCE-TYPE REFERENCE))))))))

(DEFUN ISSUE-STORAGE-CATEGORY-WARNINGS (FSPEC OBJECT-ARRAY DEBUG-INFO)
  (MULTIPLE-VALUE-BIND (FUNCTION-STORAGE-CATEGORY
			DISABLE-REFERENCE-VALIDATION
			WIRED-REFERENCES
			SAFEGUARDED-REFERENCES
			UNSAFEGUARDED-REFERENCES)
      (DECODE-STORAGE-CATEGORY-DEBUGGING-INFO DEBUG-INFO)
    (IF (OR (NULL FUNCTION-STORAGE-CATEGORY) DISABLE-REFERENCE-VALIDATION)
	(WHEN (OR WIRED-REFERENCES SAFEGUARDED-REFERENCES UNSAFEGUARDED-REFERENCES)
	  (WARN "Reference storage category declarations from ~S will be ignored." FSPEC))
      (LET ((OBJECT-ARRAY OBJECT-ARRAY)
	    (WARNINGS-ISSUED NIL))
	(DECLARE (ARRAY-REGISTER OBJECT-ARRAY))
	(DOTIMES (I (VECTOR-LENGTH OBJECT-ARRAY))
	  (MAP-OVER-REFERENCE (AREF OBJECT-ARRAY I) NIL
	    (LAMBDA (REFERENCE-TYPE REFERENCE IGNORE)
	      ;; For some reason DOWNWARD-FUNARG in MAP-OVER-REFERENCE doesn't always work.
	      (DECLARE (DOWNWARD-FUNCTION))
	      (UNLESS (AND (EQ REFERENCE-TYPE :CONSTANT)
			   (NSYMBOLP REFERENCE))
		;; CATEGORY is the declared or default storage category of the reference.
		(MULTIPLE-VALUE-BIND (CATEGORY DEFAULT-P)
		    (OR (COND ((CL:MEMBER REFERENCE WIRED-REFERENCES :TEST #'CL:EQUAL)
			       :WIRED)
			      ((CL:MEMBER REFERENCE SAFEGUARDED-REFERENCES :TEST #'CL:EQUAL)
			       :SAFEGUARDED)
			      ((CL:MEMBER REFERENCE UNSAFEGUARDED-REFERENCES :TEST #'CL:EQUAL)
			       :UNSAFEGUARDED))
			(VALUES (DEFAULT-REFERENCE-STORAGE-CATEGORY
				  FUNCTION-STORAGE-CATEGORY REFERENCE-TYPE REFERENCE)
				T))
		  ;; DECLARED-CATEGORY is the declared storage category of the object.
		  (LET ((DECLARED-CATEGORY
			  (DECLARED-STORAGE-CATEGORY REFERENCE-TYPE REFERENCE)))
		    (WHEN (ILLEGAL-REFERENCE-P CATEGORY DECLARED-CATEGORY DEFAULT-P)
		      ;; At this point in time, the reference is illegal.  However,
		      ;; DECLARED-CATEGORY is a function of the compilation
		      ;; environment, and therefore can change.  So queue a delayed
		      ;; warning, which will wait until the end of the compilation
		      ;; session and check this again before issuing the warning.
		      ;;
		      ;; Note that the compilation environment can change in the
		      ;; reverse way, too, and a reference which is now legal can
		      ;; become illegal.  But in order to check for those cases we'd
		      ;; have to queue warnings for every reference.  Since that can
		      ;; only happen when a declaration is removed, it's not worth the
		      ;; effort.
		      (LET ((LIST (LIST REFERENCE-TYPE REFERENCE)))
			(UNLESS (CL:MEMBER LIST WARNINGS-ISSUED :TEST #'CL:EQUAL)
			  (PUSH LIST WARNINGS-ISSUED)
			  (QUEUE-STORAGE-CATEGORY-WARNING
			    FSPEC REFERENCE-TYPE REFERENCE CATEGORY DEFAULT-P))))))))))))))

(DEFUN QUEUE-STORAGE-CATEGORY-WARNING (FSPEC REFERENCE-TYPE REFERENCE CATEGORY DEFAULT-P)
  (COMPILER:WARN-1 'COMPILER:STORAGE-CATEGORY-WARNING
		   :DELAYED T
		   :FUNCTION FSPEC
		   :DEFINITION-TYPE 'DEFUN
		   :REFERENCE-TYPE REFERENCE-TYPE
		   :REFERENCE REFERENCE
		   :CATEGORY CATEGORY
		   :DEFAULT-P DEFAULT-P))

;; From wired functions, the default is that all references are wired except symbols, 
;; which are safeguarded.
;; From safeguarded functions, the default is that all references are safeguarded.
;; From unsafeguarded functions, the default is that all references are unsafeguarded.
(DEFUN DEFAULT-REFERENCE-STORAGE-CATEGORY (FUNCTION-CATEGORY REFERENCE-TYPE REFERENCE)
  (CL:ECASE FUNCTION-CATEGORY
    (:WIRED (IF (AND (EQ REFERENCE-TYPE :CONSTANT)
		     (SYMBOLP REFERENCE))
		:SAFEGUARDED :WIRED))
    (:SAFEGUARDED :SAFEGUARDED)
    (:UNSAFEGUARDED :UNSAFEGUARDED)))

;; These are here because they are called by LOAD-COMPILED-FUNCTION in the cold load.

;; This is one of :UNLOCALIZED, :COPY, or :SHARE
;; The default is to share compiled function constants in 7.2, even though this
;; slows down loading somewhat.  Ideally the compiler should do the sharing, and
;; the default should be :COPY.  But the compiler doesn't always share, and BIN
;; files don't always preserve sharing anyway.
(DEFVAR *COMPILED-FUNCTION-CONSTANT-MODE* :SHARE)

;; Utility for COPY-COMPILED-FUNCTION-CONSTANTS.
;; This function destructively divides the list into two parts.
(DEFUN SUBDIVIDE-LIST (PREDICATE LIST)
  (DECLARE (DOWNWARD-FUNARG PREDICATE) (VALUES TRUE-LIST FALSE-LIST))
  (LET* ((TRUE-LIST NIL)
	 (TRUE-LIST-TAIL (LOCF TRUE-LIST))
	 (FALSE-LIST NIL)
	 (FALSE-LIST-TAIL (LOCF FALSE-LIST)))
    (DO ((THIS LIST NEXT)
	 (NEXT (CDR LIST) (CDR NEXT)))
	((NULL THIS)
	 (SETF (CDR TRUE-LIST-TAIL) NIL)
	 (SETF (CDR FALSE-LIST-TAIL) NIL)
	 (VALUES TRUE-LIST FALSE-LIST))
      (IF (FUNCALL PREDICATE (CAR THIS))
	  (SETF (CDR TRUE-LIST-TAIL) (SETQ TRUE-LIST-TAIL THIS))
	  (SETF (CDR FALSE-LIST-TAIL) (SETQ FALSE-LIST-TAIL THIS))))))

;; Note:  This violates common lisp somewhat by sharing Q arrays.
;;-- This doesn't share CDRs of list blocks.  For instance, the CDR of
;;-- (A B C D) and (C B C D) will not be shared, even if it had been originally.
;;-- This could also share '(3 4) and #C(3 4), but I don't think that's important.
#+3600
(DEFUN COPY-COMPILED-FUNCTION-CONSTANTS (FUNCTION AREA
					 &AUX (MODE *COMPILED-FUNCTION-CONSTANT-MODE*))
  (DECLARE (DOWNWARD-FUNARG *) (VALUES OBJECT-LIST EMBEDDED-LISTS-OBJECT))
  ;; Don't attempt to map over the constants when in :UNLOCALIZED mode, since they
  ;; may be circular.  But switch to :COPY mode if the constants are being wired or
  ;; safeguarded.
  (WHEN (EQ MODE :UNLOCALIZED)
    (IF (OR (EQL AREA WIRED-CONTROL-TABLES)
	    (EQL AREA SAFEGUARDED-OBJECTS-AREA))
	(PROGN (WARN "~S is set to ~S,~%but since ~S is declared ~A,~@
		      all constants will be copied into ~S."
		     '*COMPILED-FUNCTION-CONSTANT-MODE* :UNLOCALIZED FUNCTION
		     (IF (EQL AREA WIRED-CONTROL-TABLES) "wired" "safeguarded")
		     (AREA-NAME AREA))
	       (SETQ MODE :COPY))
	(RETURN-FROM COPY-COMPILED-FUNCTION-CONSTANTS (VALUES NIL NIL))))
  (POOR-MAN/'S-WITH-COLLECTION (SHARING-LIST)
    ;; Map over all the constants and collect them into sets of shared constants.
    (DO-FUNCTION-CONSTANTS (CONST NIL :SHARABLE SHARABLE :READ-ONLY READ-ONLY) FUNCTION
      (WHEN READ-ONLY
	(MAP-OVER-REFERENCE CONST NIL
	  (LAMBDA (TYPE CONST IGNORE)
	    (WHEN (AND (EQ TYPE :CONSTANT)
		       (OR (CL:CONSP CONST)
			   (STRINGP CONST)
			   (TYPEP CONST :EXTENDED-NUMBER)
			   (AND (ARRAYP CONST)
				(ARRAY-CAN-BE-COPIED-P CONST))))
	      (WHEN (LOOP FOR ELEMENT IN SHARING-LIST
			  NEVER (CL:MEMBER CONST ELEMENT :TEST #'EQ))
		(IF (OR (EQ MODE :COPY) (NOT SHARABLE))
		    (COLLECT-SHARING-LIST (LIST CONST))
		    (LOOP FOR SUBLIST ON SHARING-LIST
			  WHEN (EQUAL-INCLUDING-ARRAYS (CAAR SUBLIST) CONST)
			    RETURN (PUSH CONST (CAR SUBLIST))
			  FINALLY (COLLECT-SHARING-LIST (LIST CONST))))))))))
    ;; Divide the constants into list-format constants and structure-format constants.
    (MULTIPLE-VALUE-BIND (LISTS NONLISTS)
	(SUBDIVIDE-LIST #'(LAMBDA (ELEM) (CL:CONSP (CAR ELEM))) SHARING-LIST)
      ;; Copy all the list constants and embed them as appropriate.
      (MULTIPLE-VALUE-BIND (COPIED-LISTS EMBEDDING-OBJECT)
	  (COPY-LISTS-INTO-ART-Q-LIST-ARRAY (MAPCAR #'CAR LISTS) AREA)
	;; Now copy all the structure constants.
	;; Do this after embedding the lists, to increase the likelihood of
	;; growing the CCA in place.
	(POOR-MAN/'S-WITH-COLLECTION (COPIED-NONLISTS)
	  (LOOP FOR (CONST) IN NONLISTS DO
	    (COLLECT-COPIED-NONLISTS
	      (COND ((STRINGP CONST) (SUBSTRING CONST 0 NIL AREA))
		    ((TYPEP CONST :EXTENDED-NUMBER) (COPY-EXTENDED-NUMBER CONST AREA))
		    ((ARRAYP CONST) (COPY-ARRAY-CONSTANT CONST AREA))
		    (T (ERROR "Internal error")))))
	  ;; Loop fixing up all pointers.
	  (DO-FUNCTION-CONSTANTS (CONST LOC :READ-ONLY READ-ONLY) FUNCTION
	    (WHEN READ-ONLY
	      (MAP-OVER-REFERENCE CONST LOC
		(LAMBDA (TYPE CONST LOC)
		  (WHEN (EQ TYPE :CONSTANT)
		    (IF (CL:CONSP CONST)
			(LOOP FOR ORIGINALS IN LISTS
			      FOR COPY IN COPIED-LISTS
			      WHEN (CL:MEMBER CONST ORIGINALS :TEST #'EQ)
				RETURN (SETF (LOCATION-CONTENTS LOC) COPY))
			(LOOP FOR ORIGINALS IN NONLISTS
			      FOR COPY IN COPIED-NONLISTS
			      WHEN (CL:MEMBER CONST ORIGINALS :TEST #'EQ)
				RETURN (SETF (LOCATION-CONTENTS LOC) COPY))))))))
	  ;; Return a list of all "constants" referenced.  All the lists count as one
	  ;; constant if they're embedded in an array.
	  (IF EMBEDDING-OBJECT
	      (VALUES (CONS EMBEDDING-OBJECT COPIED-NONLISTS) EMBEDDING-OBJECT)
	      (VALUES COPIED-NONLISTS NIL)))))))

;; Note:  This violates common lisp somewhat by sharing Q arrays.
;;-- This doesn't share CDRs of list blocks.  For instance, the CDR of
;;-- (A B C D) and (C B C D) will not be shared, even if it had been originally.
;;-- This could also share '(3 4) and #C(3 4), but I don't think that's important.
#+IMach
(DEFUN COPY-COMPILED-FUNCTION-CONSTANTS (FUNCTION AREA &OPTIONAL EMBED-P
					 &AUX (MODE *COMPILED-FUNCTION-CONSTANT-MODE*)
					 NEW-FUNCTION)
  (DECLARE (DOWNWARD-FUNARG *) (VALUES OBJECT-LIST EMBEDDED-LISTS-OBJECT NEW-FUNCTION))
  ;; Don't attempt to map over the constants when in :UNLOCALIZED mode, since they
  ;; may be circular.  But switch to :COPY mode if the constants are being wired or
  ;; safeguarded.
  (WHEN (EQ MODE :UNLOCALIZED)
    (IF (OR (EQL AREA WIRED-CONTROL-TABLES)
	    (EQL AREA SAFEGUARDED-OBJECTS-AREA))
	(PROGN (WARN "~S is set to ~S,~%but since ~S is declared ~A,~@
		      all constants will be copied into ~S."
		     '*COMPILED-FUNCTION-CONSTANT-MODE* :UNLOCALIZED FUNCTION
		     (IF (EQL AREA WIRED-CONTROL-TABLES) "wired" "safeguarded")
		     (AREA-NAME AREA))
	       (SETQ MODE :COPY))
	(RETURN-FROM COPY-COMPILED-FUNCTION-CONSTANTS (VALUES NIL NIL FUNCTION))))
  (POOR-MAN/'S-WITH-COLLECTION (SHARING-LIST)
    ;; Hacks to allow I-Machine to ignore internal constants.
    (MACROLET ((WITH-FUNCTION-SIZE (&BODY BODY)
		 `(MULTIPLE-VALUE-BIND (NIL FUNCTION-LEADER FUNCTION-SIZE)
		      (%FIND-STRUCTURE-EXTENT FUNCTION)
		    . ,BODY))
	       (INTERNAL-CONSTANT-P (CONSTANT &ENVIRONMENT ENV)
		 (ONCE-ONLY (CONSTANT &ENVIRONMENT ENV)
		   `(AND (%POINTERP ,CONSTANT)
			 (NOT (%POINTER-LESSP ,CONSTANT FUNCTION-LEADER))
			 (%UNSIGNED-LESSP
			   (%POINTER-DIFFERENCE ,CONSTANT FUNCTION-LEADER)
			   FUNCTION-SIZE))))
	       (LIST-FORMAT-P (CONSTANT)
		 ;; Write it this way to make sure the common case (DTP-LIST)
		 ;; is tested first.  Don't bother with ONCE-ONLY for the usages here.
		 `(OR (TYPE-MEMBER ,CONSTANT DTP-LIST DTP-LEXICAL-CLOSURE DTP-DYNAMIC-CLOSURE)
		      (TYPE-MEMBER ,CONSTANT DTP-DOUBLE-FLOAT DTP-BIG-RATIO DTP-COMPLEX))))
      (WITH-FUNCTION-SIZE
	;; Map over all the constants and collect them into sets of shared constants.
	(DO-FUNCTION-CONSTANTS (CONST NIL :SHARABLE SHARABLE :READ-ONLY READ-ONLY) FUNCTION
	  (WHEN READ-ONLY
	    (MAP-OVER-REFERENCE CONST NIL
	      (LAMBDA (TYPE CONST IGNORE)
		(WHEN (AND (EQ TYPE :CONSTANT)
			   (NOT (INTERNAL-CONSTANT-P CONST))
			   (OR (LIST-FORMAT-P CONST)
			       (STRINGP CONST)
			       (TYPEP CONST :EXTENDED-NUMBER)
			       (AND (ARRAYP CONST)
				    (ARRAY-CAN-BE-COPIED-P CONST))))
		  (WHEN (LOOP FOR ELEMENT IN SHARING-LIST
			      NEVER (CL:MEMBER CONST ELEMENT :TEST #'EQ))
		    (IF (OR (EQ MODE :COPY) (NOT SHARABLE))
			(COLLECT-SHARING-LIST (LIST CONST))
			(LOOP FOR SUBLIST ON SHARING-LIST
			      WHEN (EQUAL-INCLUDING-ARRAYS (CAAR SUBLIST) CONST)
				RETURN (PUSH CONST (CAR SUBLIST))
			      FINALLY (COLLECT-SHARING-LIST (LIST CONST))))))))))
	;; Divide the constants into list-format constants and structure-format constants.
	(MULTIPLE-VALUE-BIND (LISTS NONLISTS)
	    (SUBDIVIDE-LIST #'(LAMBDA (ELEM) (LIST-FORMAT-P (CAR ELEM))) SHARING-LIST)
	  ;; Copy all the list constants and embed them as appropriate.
	  (MULTIPLE-VALUE-BIND (COPIED-LISTS EMBEDDING-OBJECT)
	      (IF EMBED-P
		  (COPY-LISTS-INTO-CCA (MAPCAR #'CAR LISTS) (COMPILED-FUNCTION-CCA FUNCTION))
		  (COPY-LISTS-INTO-ART-Q-LIST-ARRAY (MAPCAR #'CAR LISTS) AREA))
	  (WHEN EMBED-P
	    (SETQ NEW-FUNCTION (CCA-COMPILED-CODE-OBJECT EMBEDDING-OBJECT))
	    (WHEN (EQ FUNCTION NEW-FUNCTION) (SETQ NEW-FUNCTION NIL)))
	  ;; Now copy all the structure constants.
	  ;; Do this after embedding the lists, to increase the likelihood of
	  ;; growing the CCA in place.
	  (POOR-MAN/'S-WITH-COLLECTION (COPIED-NONLISTS)
	    (WHEN (NEQ EMBED-P :EMBED-ONLY)
	      (LOOP FOR (CONST) IN NONLISTS DO
		(COLLECT-COPIED-NONLISTS
		  (COND ((STRINGP CONST) (SUBSTRING CONST 0 NIL AREA))
			((TYPEP CONST :EXTENDED-NUMBER) (COPY-EXTENDED-NUMBER CONST AREA))
			((ARRAYP CONST) (COPY-ARRAY-CONSTANT CONST AREA))
			(T (ERROR "Internal error"))))))
	    ;; Loop fixing up all pointers.
	    (DO-FUNCTION-CONSTANTS (CONST LOC :READ-ONLY READ-ONLY) (OR NEW-FUNCTION FUNCTION)
	      (WHEN READ-ONLY
		(MAP-OVER-REFERENCE CONST LOC
		  (LAMBDA (TYPE CONST LOC)
		    (WHEN (EQ TYPE :CONSTANT)
		      (COND ((INTERNAL-CONSTANT-P CONST)
			     (WHEN NEW-FUNCTION
			       (SETF (LOCATION-CONTENTS LOC)
				     (%POINTER-PLUS CONST
				       (%POINTER-DIFFERENCE NEW-FUNCTION FUNCTION)))))
			    ((LIST-FORMAT-P CONST)
			     ;; If we stumble across an internal constant of NEW-FUNCTION,
			     ;; already relocated by GROW-CCA or a previous pass of this
			     ;; function, then we'll just fall off the end of this loop.
			     (LOOP FOR ORIGINALS IN LISTS
				   FOR COPY IN COPIED-LISTS
				   WHEN (CL:MEMBER CONST ORIGINALS :TEST #'EQ)
				     DO (SETF (LOCATION-CONTENTS LOC) COPY)
					(RETURN)))
			    ((NEQ EMBED-P :EMBED-ONLY)
			     (LOOP FOR ORIGINALS IN NONLISTS
				   FOR COPY IN COPIED-NONLISTS
				   WHEN (CL:MEMBER CONST ORIGINALS :TEST #'EQ)
				     DO (SETF (LOCATION-CONTENTS LOC) COPY)
					(RETURN)))))))))
	    ;; Return a list of all "constants" referenced.  All the lists count as one
	    ;; constant if they're embedded in an array.
	    (VALUES (IF EMBEDDING-OBJECT
			(IF EMBED-P
			    COPIED-NONLISTS
			    (CONS EMBEDDING-OBJECT COPIED-NONLISTS))
			COPIED-NONLISTS)
		    EMBEDDING-OBJECT
		    (OR NEW-FUNCTION FUNCTION)))))))))

;;--- This copies not only lists, but list-format objects as well.
(DEFUN COPY-LISTS-INTO-ART-Q-LIST-ARRAY (LISTS AREA)
  (LOOP FOR LIST IN LISTS
	#+IMach DO #+IMach (SETQ LIST (%SET-TAG LIST DTP-LIST))
	SUM (LENGTH LIST) INTO TOTAL-SIZE
	WHEN (CDR (LAST LIST)) SUM 1 INTO TOTAL-SIZE
	FINALLY
	  (WHEN (PLUSP TOTAL-SIZE)
	    (LET ((RESULT (MAKE-ARRAY TOTAL-SIZE :TYPE 'ART-Q-LIST :AREA AREA))
		  (INDEX 0))
	      (RETURN
		(VALUES
		  (PROG1 (LOOP FOR LIST IN LISTS
			       COLLECT #+3600 (%MAKE-POINTER DTP-LIST (ALOC RESULT INDEX))
				       #+IMach (%SET-TAG (ALOC RESULT INDEX) (%TAG LIST))
			       DO
			   #+IMach (SETQ LIST (%SET-TAG LIST DTP-LIST))
			   (DO ((L LIST (CDR L)))
			       ((ATOM L)
				(IF (NULL L)
				    (%P-STORE-CDR-CODE (ALOC RESULT (- INDEX 1)) CDR-NIL)
				  (SETF (AREF RESULT INDEX) L)
				  (INCF INDEX)
				  (%P-STORE-CDR-CODE (ALOC RESULT (- INDEX 2)) CDR-NORMAL)
				  (%P-STORE-CDR-CODE (ALOC RESULT (- INDEX 1)) CDR-NIL)))
			     (SETF (AREF RESULT INDEX) (CAR L))
			     (INCF INDEX)))
			 (WHEN ( INDEX TOTAL-SIZE)
			   (ERROR "Error estimating size of lists")))
		  RESULT))))))

;; This is a version of CL:EQUAL which has been hacked to treat arrays first class.
(DEFUN EQUAL-INCLUDING-ARRAYS (X Y)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (DECLARE (COMPILER:RETURN-TYPE BOOLEAN))
  (CL:LOOP
    (COND ((EQL X Y) (RETURN T))
	  ((NOT (= (SYS:%DATA-TYPE X) (SYS:%DATA-TYPE Y))) (RETURN NIL))
	  ((CL:CONSP X)
	   (CL:LOOP
	     (UNLESS (OR (EQL (CAR X) (CAR Y))
			 (EQUAL-INCLUDING-ARRAYS (CAR X) (CAR Y)))
	       (RETURN-FROM EQUAL-INCLUDING-ARRAYS NIL))
	     (SETQ X (CDR X) Y (CDR Y))
	     (UNLESS (AND (CL:CONSP X) (CL:CONSP Y))
	       (RETURN))))
	  ((ARRAYP X) ;optimize out the common case
	   (COND ((STRINGP X) (RETURN (AND (STRINGP Y) (SYS:%STRING= X 0 Y 0 NIL))))
		 ((CL:BIT-VECTOR-P X) (RETURN (AND (CL:BIT-VECTOR-P Y)
						   (CLI::BIT-VECTOR-EQUAL X Y))))
		 (T (RETURN
		      (AND (ARRAYP Y)
			   (NOT (ARRAY-DISPLACED-P X))
			   (NOT (ARRAY-DISPLACED-P Y))
			   (NOT (ARRAY-INDIRECT-P X))
			   (NOT (ARRAY-INDIRECT-P Y))
			   (CL:EQUAL (ARRAY-DIMENSIONS X) (ARRAY-DIMENSIONS Y))
			   (EQL (ARRAY-LEADER-LENGTH X) (ARRAY-LEADER-LENGTH Y))
			   (EQL (NAMED-STRUCTURE-P X) (NAMED-STRUCTURE-P Y))
			   (LET ((X X) (Y Y))
			     (DECLARE (ARRAY-REGISTER-1D X Y))
			     (MACROLET ((NUMERIC-ARRAY-TYPE (X)
					  #+3600 `(BIT-MEMBER (ARRAY-TYPE-FIELD ,X)
						    (LOGIOR (LSH 1 ART-BOOLEAN)
							    (LSH 1 ART-1B)
							    (LSH 1 ART-2B)
							    (LSH 1 ART-4B)
							    (LSH 1 ART-8B)
							    (LSH 1 ART-16B)
							    (LSH 1 ART-FIXNUM)))
					  #+IMach `( (LDB %%ARRAY-TYPE-ELEMENT-TYPE
							   (ARRAY-TYPE-FIELD ,X))
						      ARRAY-ELEMENT-TYPE-OBJECT)))
			       (IF (AND (NUMERIC-ARRAY-TYPE X) (NUMERIC-ARRAY-TYPE Y))
				   (LOOP FOR I BELOW (ARRAY-TOTAL-SIZE X)
					 ALWAYS (EQ (%1D-AREF X I) (%1D-AREF Y I)))
				   (LOOP FOR I BELOW (ARRAY-TOTAL-SIZE X)
					 ALWAYS (EQUAL-INCLUDING-ARRAYS (%1D-AREF X I)
									(%1D-AREF Y I))))))
			   (LOOP FOR I BELOW (OR (ARRAY-LEADER-LENGTH X) 0)
			     ALWAYS (EQUAL-INCLUDING-ARRAYS (ARRAY-LEADER X I)
							    (ARRAY-LEADER Y I))))))))
	  (T (RETURN NIL)))))

;; This is an internal function to COPY-COMPILED-FUNCTION-CONSTANTS.
;; It returns NIL if it's an array it doesn't want to copy.
(DEFUN COPY-ARRAY-CONSTANT (ARRAY AREA)
  (WHEN (ARRAY-CAN-BE-COPIED-P ARRAY)
    (LET ((COPY (MAKE-ARRAY (ARRAY-DIMENSIONS ARRAY)
			    :AREA AREA
			    :TYPE (ARRAY-TYPE ARRAY)
			    :LEADER-LENGTH (ARRAY-LEADER-LENGTH ARRAY)
			    :NAMED-STRUCTURE-SYMBOL (NAMED-STRUCTURE-P ARRAY))))
      (COPY-ARRAY-CONTENTS-AND-LEADER ARRAY COPY)
      COPY)))

;; Based on COPY-LISTS-INTO-ART-Q-LIST-ARRAY .
;;--- This copies not only lists, but list-format objects as well.
#+IMach
(DEFUN COPY-LISTS-INTO-CCA (LISTS CCA)
  (LOOP FOR LIST IN LISTS
	DO (SETQ LIST (%SET-TAG LIST DTP-LIST))
	SUM (LENGTH LIST) INTO TOTAL-SIZE
	WHEN (CDR (LAST LIST)) SUM 1 INTO TOTAL-SIZE
	FINALLY
	  (IF (NOT (PLUSP TOTAL-SIZE))
	      (RETURN (VALUES NIL CCA))
	    (LET* ((CCA-POINTER (CCA-TOTAL-SIZE CCA))
		   (NEW (GROW-CCA CCA (+ TOTAL-SIZE CCA-POINTER))))
	      (RETURN
		(VALUES 
		  (PROG1
		    (LOOP FOR LIST IN LISTS
			  COLLECT (%SET-TAG (%POINTER-PLUS NEW CCA-POINTER) (%TAG LIST))
			  DO (SETQ LIST (%SET-TAG LIST DTP-LIST))
			     (DO ((L LIST (CDR L)))
				 ((ATOM L)
				  (IF (NULL L)
				      (%P-STORE-CDR-CODE (%POINTER-PLUS NEW (- CCA-POINTER 1))
							 CDR-NIL)
				    (%MEMORY-WRITE (%POINTER-PLUS NEW CCA-POINTER) L)
				    (INCF CCA-POINTER)
				    (%P-STORE-CDR-CODE (%POINTER-PLUS NEW (- CCA-POINTER 2))
						       CDR-NORMAL)
				    (%P-STORE-CDR-CODE (%POINTER-PLUS NEW (- CCA-POINTER 1))
						       CDR-NIL)))
			       (%MEMORY-WRITE (%POINTER-PLUS NEW CCA-POINTER) (CAR L))
			       (INCF CCA-POINTER)))
		    (WHEN ( (CCA-TOTAL-SIZE NEW) CCA-POINTER)
		      (ERROR "Error estimating size of lists")))
		  NEW))))))

;; If we can't grow the CCA, it returns a new one.  We do not structure-forward.
#+IMach
(DEFUN GROW-CCA (CCA NEW-SIZE)
  (DECLARE (VALUES NEW-CCA))
  (LET ((CURRENT-SIZE (CCA-TOTAL-SIZE CCA)))
    (UNLESS (< CURRENT-SIZE NEW-SIZE)
      (ERROR "Growing a CCA, but the specified new size is smaller."))
    (UNLESS (< NEW-SIZE (LSH 1 (BYTE-SIZE CCA-TOTAL-SIZE)))
      (ERROR "Attempt to grow a CCA beyond the architectural limit."))
    (WITHOUT-INTERRUPTS-AND-STACK-OVERFLOWS (200.)
      (UPDATE-CONS-CACHE-REGION-FREE-POINTERS)
      (LET* ((REGION (%REGION-NUMBER CCA))
	     (ORIGIN (REGION-ORIGIN REGION))
	     (FP (REGION-FREE-POINTER REGION))
	     (LENGTH (REGION-LENGTH REGION))
	     (DELTA (- NEW-SIZE CURRENT-SIZE)))
	(COND ((AND (= (%32-BIT-PLUS (%POINTER CCA) CURRENT-SIZE)
		       (%32-BIT-PLUS ORIGIN FP))
		    ( (%32-BIT-PLUS (%POINTER CCA) NEW-SIZE)
		       (%32-BIT-PLUS ORIGIN LENGTH)))
	       ;; We can grow the CCA in place.
	       (GC-RESET-FREE-POINTER REGION (+ DELTA FP))
	       (%BLOCK-STORE-TAG-AND-POINTER (%32-BIT-PLUS ORIGIN FP) DELTA DTP-NIL NIL 0)
	       (%P-DPB NEW-SIZE CCA-TOTAL-SIZE CCA)
	       (%P-DPB (+ (CCA-SUFFIX-SIZE CCA) DELTA) CCA-SUFFIX-SIZE CCA)
	       CCA)
	      (T ;; We have to make a new one.
		(LET ((NEW-CCA (MAKE-COMPILED-CODE NEW-SIZE
						   (+ (CCA-SUFFIX-SIZE CCA) DELTA)
						   (%AREA-NUMBER CCA)))
		      (POINTER-TYPE-P *POINTER-TYPE-P*))
		  (DECLARE (ARRAY-REGISTER POINTER-TYPE-P))
		  ;; Copy the CCA, forwarding self-references as we go.
		  (WITH-BLOCK-REGISTERS (1 2)
		    (SETF (%BLOCK-REGISTER 1)
			  (%POINTER-PLUS CCA (DEFSTORAGE-SIZE COMPILED-FUNCTION)))
		    (SETF (%BLOCK-REGISTER 2)
			  (%POINTER-PLUS NEW-CCA (DEFSTORAGE-SIZE COMPILED-FUNCTION)))
		    (DOTIMES (IGNORE (- CURRENT-SIZE (DEFSTORAGE-SIZE COMPILED-FUNCTION)))
		      (LET ((WORD (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-SCAVENGE
						 :SET-CDR-NEXT NIL)))
			(COMPILER:%ERROR-WHEN (AND (AREF POINTER-TYPE-P (%DATA-TYPE WORD))
						   (NOT (%POINTER-LESSP WORD CCA))
						   (%UNSIGNED-LESSP
						     (%POINTER-DIFFERENCE WORD CCA)
						     CURRENT-SIZE))
			  (SETQ WORD (%SET-TAG (%POINTER-PLUS WORD
						 (%POINTER-DIFFERENCE NEW-CCA CCA))
					       (%TAG WORD))))
			(SI:PREPARE-FOR-BLOCK-WRITE)
			(%BLOCK-WRITE 2 WORD))))
		  (%BLOCK-STORE-TAG-AND-POINTER (%POINTER-PLUS NEW-CCA CURRENT-SIZE)
						DELTA DTP-NIL NIL 0)
		  NEW-CCA)))))))

#| Test function for constant copying.  Compile this, and then use memory tools
   to verify that constants are shared as specified, in proper areas, and that
   proper warnings were issued. |
;;; -*- Mode: LISP; Syntax: Common-lisp; Package: User; Base: 10 -*-

(DEFUN TEST ()
  '(A))

(DEFUN TEST-CONSTANTS ()
  ;(DECLARE (SYS:SAFEGUARDED-FUNCTION))		;Test warning
  (LIST '((A B) C (A B))			;Test general list copying, sharing (A B)
	'(FOO . BAR)				;Test dotted lists
	'#.(CL:VECTOR '(FOO . BAR))		;Test simple arrays, sharing (FOO . BAR)
	'("Yow" "Foo" "Yow" "FOO" "D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")Foo0")	;Test sharing strings.
	'#.(MAKE-ARRAY 1			;Shouldn't be copied
	     :NAMED-STRUCTURE-SYMBOL 'FOO
	     :AREA SI:PERMANENT-STORAGE-AREA)
	'(1.0 1.0d0 3\5 399999\599999		;Test numbers
	  #C(1.0d0 2.0d0)
	  666777888999000
	  666777888999000)
	'#.(CL:MAKE-ARRAY '(1000 1000)		 ;Test that big bit arrays don't take
			  :ELEMENT-TYPE 'CL:BIT) ;a long time to copy.
	))

(DEFUN TEST-CIRCULAR-CONSTANTS ()		;This should work in :UNLOCALIZED mode.
  (LIST '#1=(#1#) '#2=(() . #2#)))

||#
