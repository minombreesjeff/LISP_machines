;; -*- Mode:LISP; Package:SYSTEM-INTERNALS; Base:8 -*-
;; These are the macros in the Lisp Machine system.
;; They used to be in LISPM;MACROS > but have been moved
;; so the compiler can properly compile the system

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

; Macros which do the equivalent of a displace MUST use DISPLACE
; to make sure that temporary area problems are worried about.

;The IF-IN-MACLISP/IF-IN-LISPM conditionals have to do with not breaking
;the Maclisp environment when compiling.  The optimizers in COMPAT take
;over these functions when compiling in Maclisp.

(DEFVAR COMPILING-FOR-LISPM)

;THESE ARE CONDITIONAL ON WHICH SYSTEM IS EXECUTING THEM.
(DEFMACRO IF-IN-MACLISP (&REST FORMS)
    (COND ((NOT (STATUS FEATURE LISPM))
	   `(PROGN 'COMPILE . ,FORMS))))

(DEFMACRO IF-IN-LISPM (&REST FORMS)
    (COND ((STATUS FEATURE LISPM)
	   `(PROGN 'COMPILE . ,FORMS))))

;THESE ARE CONDITIONAL ON WHICH SYSTEM RESULT IS INTENDED "FOR ".
; THIS IS THE SAME AS WHICH SYSTEM IS "IN" EXCEPT IN THE CASE
; COMPILING IN MACLISP FOR LISPM (IE QCMP, AFTER COMPILER ITSELF HAS
; BEEN LOADED).  THE COMPILING-FOR-LISPM SWITCH IS SET BY .LISP. (INIT)
; AFTER QCMP HAS BEEN LOADED.

(DEFMACRO IF-FOR-MACLISP (&REST FORMS)
    (COND ((AND (NOT (STATUS FEATURE LISPM))		;IN MACLISP
		(OR (NOT (VARIABLE-BOUNDP COMPILING-FOR-LISPM))
		    (NULL COMPILING-FOR-LISPM)))
	   `(PROGN 'COMPILE . ,FORMS))))

(DEFMACRO IF-FOR-LISPM (&REST FORMS)
    (COND ((OR (STATUS FEATURE LISPM)
	       (AND (VARIABLE-BOUNDP COMPILING-FOR-LISPM)
		    COMPILING-FOR-LISPM))
	   `(COMPILER-LET ((RUN-IN-MACLISP-SWITCH NIL))
			  (PROGN 'COMPILE . ,FORMS)))))

(DEFMACRO IF-FOR-MACLISP-ELSE-LISPM (MACLISP-FORM LISPM-FORM)
    (COND ((NOT (STATUS FEATURE LISPM))
	   (COND ((OR (NOT (VARIABLE-BOUNDP COMPILING-FOR-LISPM))	;QCMP DEFINES THIS TO T
		      (NULL COMPILING-FOR-LISPM))
		  MACLISP-FORM)
		 (T `(COMPILER-LET ((RUN-IN-MACLISP-SWITCH NIL)) ,LISPM-FORM))))
    ;COMPLR DOESNT KNOW (OR CARE) ABOUT COMPILER-LET.
	  (T LISPM-FORM)))

;; Needed when conditionalizing something at top level with #Q or #M because
;; splicing readmacros flushed then.  #Q and #M now work at top level, so this
;; is for compatibility only.
(DEFMACRO NULL-MACRO (FORM) FORM)

;These must appear before anything in this file that uses LET in order to win
; at cold-load readin time.

(DEFMACRO PUSH (ITEM LIST)
   (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
   `(SETF ,LIST (CONS ,ITEM ,LIST)))

(DEFMACRO PUSH-IN-AREA (ITEM LIST AREA)
   (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
   `(SETF ,LIST (CONS-IN-AREA ,ITEM ,LIST ,AREA)))

(DEFMACRO POP (LIST &OPTIONAL DEST)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(PROG1 ,(COND ((NULL DEST)          
                  `(CAR ,LIST))
                 (T `(SETF ,DEST (CAR ,LIST))))
           (SETF ,LIST (CDR ,LIST))))

(DEFMACRO PUSH* (ITEM LIST)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(OR (MEMQ ,ITEM ,LIST) (PUSH ,ITEM ,LIST)))

(DEFMACRO PUSH*-IN-AREA (ITEM LIST AREA)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(OR (MEMQ ,ITEM ,LIST) (PUSH-IN-AREA ,ITEM ,LIST ,AREA)))

;;; Define a symbol macro.
(DEFMACRO DEFINE-SYMBOL-MACRO (NAME FORM)
  `(PROGN
     (EVAL-WHEN (COMPILE)
       (DEFINE-SYMBOL-MACRO-COMPILE ',NAME ',FORM))
     (EVAL-WHEN (LOAD EVAL)
       (DEFINE-SYMBOL-MACRO-LOAD ',NAME ',FORM))))

(DEFPROP DEFINE-SYMBOL-MACRO "Symbol Macro" SI:DEFINITION-TYPE-NAME)

;Macros in Lambda position of function
(DEFMACRO LAMBDA-MACRO (FUNCTION LAMBDA-LIST &BODY BODY)
  (LET ((NAME `(:LAMBDA-MACRO ,FUNCTION)))
    `(PROGN (EVAL-WHEN (COMPILE)
	      (PUTDECL ',FUNCTION 'LAMBDA-MACRO
		       #'(LAMBDA ,LAMBDA-LIST
			   (DECLARE (SYS:FUNCTION-NAME ,NAME))
			   ,@BODY)))
	    (DEFUN ,NAME ,LAMBDA-LIST
	      ,@BODY))))

;Permits defining a function with an arbitrary lambda keyword
(DEFMACRO DEFFUNCTION (FSPEC LAMBDA-TYPE LAMBDA-LIST &BODY REST &ENVIRONMENT ENV)
  (LET ((FUNCTION (LET ((COMPILER:DEFAULT-WARNING-FUNCTION FSPEC))
		    (LAMBDA-MACRO-EXPAND `(,LAMBDA-TYPE ,LAMBDA-LIST . ,REST) ENV))))
    (UNLESS (INTERPRETED-LAMBDA-P FUNCTION)
      (FERROR NIL "~A (a lambda macro) did not expand into a LAMBDA." LAMBDA-TYPE))
    `(DEFUN ,FSPEC ,@(INTERPRETED-LAMBDA-LAMBDA-LIST-AND-BODY FUNCTION))))

;Make a declaration at load time and compile time in appropriate ways.
;At run time, puts on a property.  At compile time, puts on a local declaration.
;Use GETDECL in a macro to get the current declared value of the property.
(DEFMACRO DEFDECL (NAME PROP VALUE)
  `(PROGN (DEFPROP ,NAME ,VALUE ,PROP)
	  (EVAL-WHEN (COMPILE)
	    (PUTDECL ',NAME ',PROP ',VALUE))))

(DEFMACRO @DEFINE (&REST IGNORE) NIL)

(DEFMACRO DEFPROP (SYM VALUE INDICATOR)
  (WHEN (NOT (SYMBOLP SYM))
    (FERROR "~S is not a symbol" SYM))
  `(SETF (GET ',SYM ',INDICATOR) ',VALUE))

(DEFSUBST FILL-POINTER (ARRAY)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (ARRAY-LEADER ARRAY 0))

(DEFSUBST REST1 (LIST)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (NTHCDR 1 LIST))

(DEFSUBST REST2 (LIST)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (NTHCDR 2 LIST))

(DEFSUBST REST3 (LIST)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (NTHCDR 3 LIST))

(DEFSUBST REST4 (LIST)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (NTHCDR 4 LIST))

(DEFSUBST LOCATION-CONTENTS (LOCATIVE)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (CDR LOCATIVE))

(DEFSUBST NEQ (X Y)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (NOT (EQ X Y)))

#-IMACH
(CL:PROCLAIM '(CL:INLINE BIT-TEST))

(DEFUN BIT-TEST (INTEGER1 INTEGER2)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (NOT (ZEROP (LOGAND INTEGER1 INTEGER2))))

(DEFSUBST LDB-TEST (BYTESPEC INTEGER)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (NOT (ZEROP (LDB BYTESPEC INTEGER))))

(DEFMACRO ARRAYCALL (IGNORE ARRAY &REST DIMS)
  `(FUNCALL ,ARRAY . ,DIMS))

#-row-major (progn 
(defun raster-aref       (raster-array x y)
  (declare lt:(side-effects reader))
  (aref       raster-array x y))
(defun raster-aset (value raster-array x y) (aset value raster-array x y))
(defun raster-aloc       (raster-array x y) (aloc       raster-array x y))
)

#+row-major (progn 
(defsubst raster-aref       (raster-array x y)
  (declare lt:(side-effects reader))
  (aref       raster-array y x))
(defsubst raster-aset (value raster-array x y) (aset value raster-array y x))
(defsubst raster-aloc       (raster-array x y) (aloc       raster-array y x))
)

(cl:defsetf raster-aref (raster-array x y) (value)
  `(raster-aset ,value ,raster-array ,x ,y))

(scl:deflocf raster-aref (raster-array x y)
  `(raster-aloc ,raster-array ,x ,y))



(DEFMACRO SELECTQ (TEST-OBJECT &BODY CLAUSES)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(CL:CASE ,TEST-OBJECT
     ,@(MAPCAR #'(LAMBDA (CLAUSE)
		   `(,(LET ((KEY (FIRST CLAUSE)))
			(IF (NULL KEY)
			    '(NIL)
			    KEY))
		     ,@(REST1 CLAUSE)))
	       CLAUSES)))

;;;This should be sufficient for the moment:
(DEFMACRO CASEQ (TEST-OBJECT &BODY CLAUSES)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(SELECTQ ,TEST-OBJECT ,@CLAUSES))

(DEFMACRO SELECT (TEST-OBJECT &BODY CLAUSES)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(SELECTOR ,TEST-OBJECT EQL ,@CLAUSES))

(DEFUN EXPAND-SELECTOR (TEST-OBJECT TEST-FUNCTION CLAUSES ENV)
  (ONCE-ONLY (TEST-OBJECT &ENVIRONMENT ENV)
    `(COND ,@(MAPCAR #'(LAMBDA (CLAUSE)
			 `(,(LET ((KEY (FIRST CLAUSE)))
			      (COND ((CL:MEMBER KEY '(OTHERWISE T)) T)
				    ((CL:CONSP KEY)	;not LISTP
				     `(OR ,@(MAPCAR #'(LAMBDA (KEY)
							`(,TEST-FUNCTION ,TEST-OBJECT ,KEY))
						    KEY)))
				    (T
				     `(,TEST-FUNCTION ,TEST-OBJECT ,KEY))))
			   ,@(OR (REST1 CLAUSE) '(NIL))))
		     CLAUSES))))

(DEFMACRO SELECTOR (TEST-OBJECT TEST-FUNCTION &BODY CLAUSES &ENVIRONMENT ENV)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (EXPAND-SELECTOR TEST-OBJECT TEST-FUNCTION CLAUSES ENV))

;EVENTUALLY THE MICRO COMPILER SHOULD BE AWARE OF THIS (ha ha) [ho ho] <he he> {heh heh}
(DEFMACRO DISPATCH (PPSS WORD &BODY CLAUSES)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(SELECTOR (LDB ,PPSS ,WORD) EQL		;safe to use EQL since LDB returns an integer
     ,@CLAUSES))

(DEFUN LET-GLOBALLY-EXPAND (COND VARLIST BODY ENV)
  (LET* ((COND-CONSTANT (CL:CONSTANTP COND ENV))
	 (COND-VALUE (IF COND-CONSTANT
			 (LT:EVALUATE-CONSTANT COND ENV)
			 (GENSYM))))
    (WHEN (AND COND-CONSTANT (NULL COND-VALUE))
      (RETURN-FROM LET-GLOBALLY-EXPAND
	`(CL:LOCALLY ,@BODY)))
    (MULTIPLE-VALUE-BIND (DECLARATIONS REAL-BODY)
	(FIND-BODY-DECLARATIONS BODY ENV)
      (LET ((VARS NIL)
	    (VALS NIL)
	    (TVARS NIL)
	    (TVALS NIL)
	    (STORES NIL)
	    (STORE-FORMS NIL)
	    (ACCESS-FORMS NIL)
	    (GENSYMS1 NIL)
	    (GENSYMS2 NIL))
	(DOLIST (V VARLIST)
	  (PUSH (GENSYM) GENSYMS1)
	  (MULTIPLE-VALUE-BIND (VAR VAL)
	      (IF (ATOM V)
		  (VALUES V NIL)
		  (VALUES (FIRST V) (SECOND V)))
	    (SETF VARS (NCONC VARS (NCONS VAR)))
	    (SETF VALS (NCONC VALS (NCONS VAL)))
	    (MULTIPLE-VALUE-BIND (SVARS SVALS SSTORES STORE-FORM ACCESS-FORM UNBOUND-GENSYM)
		(CONDITION-CASE ()
		     (LET* ((LOCF-FORM (LT::EXPAND-LOCF VAR ENV))
			    (LTEMP (GENSYM))
			    (STEMP (GENSYM)))
		       #+3600
		       (VALUES (LIST LTEMP) (LIST LOCF-FORM) (LIST STEMP)
			       `(CL:SETF (LOCATION-CONTENTS ,LTEMP) ,STEMP)
			       `(LOCATION-CONTENTS ,LTEMP)
			       (GENSYM))
		       #+IMACH
		       (VALUES (LIST LTEMP)
			       (LIST `(SYS:%MEMORY-READ-ADDRESS
					,LOCF-FORM
					:CYCLE-TYPE SYS:%MEMORY-BIND-WRITE))
			       (LIST STEMP)
			       `(SYS:%MEMORY-WRITE ,LTEMP ,STEMP)
			       ;; Cells being bound shouldn't have a cdr-code of 3,
			       ;; so this should be okay (two words in a row with
			       ;; cdr-code 3 will br interpreted by stack-wiring as a
			       ;; stack frame, which will result in a fast trip to
			       ;; the FEP.
			       `(SYS:%MEMORY-READ ,LTEMP :CYCLE-TYPE SYS:%MEMORY-BIND-WRITE)
			       NIL)
		       )
		   (ERROR
		     (MULTIPLE-VALUE-BIND (SVARS SVALS SSTORES STORE-FORM ACCESS-FORM)
			 (CL:GET-SETF-METHOD VAR ENV)
		       (VALUES SVARS SVALS SSTORES STORE-FORM ACCESS-FORM NIL))))
	      (SETF TVARS (APPEND TVARS SVARS))
	      (SETF TVALS (APPEND TVALS SVALS))
	      (SETF STORES (APPEND STORES SSTORES))
	      (SETF STORE-FORMS (NCONC STORE-FORMS (NCONS STORE-FORM)))
	      (SETF ACCESS-FORMS (NCONC ACCESS-FORMS (NCONS ACCESS-FORM)))
	      (SETF GENSYMS2 (NCONC GENSYMS2 (NCONS UNBOUND-GENSYM)))
	      )))
	(LABELS ((SAVE-OLD-VALUE (GENSYMS1 GENSYMS2 ACCESS-FORMS FORM)
		   (IF (NULL GENSYMS1)
		       FORM
		       (LET ((ACCESS-FORM (POP ACCESS-FORMS))
			     (GENSYM1 (POP GENSYMS1))
			     (GENSYM2 (POP GENSYMS2)))
			 (IF (NULL GENSYM2)
			     `(LET ((,GENSYM1 ,ACCESS-FORM))
				,(SAVE-OLD-VALUE GENSYMS1 GENSYMS2 ACCESS-FORMS FORM))
			     `(LET* ((,GENSYM2 (VARIABLE-BOUNDP ,ACCESS-FORM))
				     (,GENSYM1 (AND ,GENSYM2 ,ACCESS-FORM)))
				,(SAVE-OLD-VALUE GENSYMS1 GENSYMS2 ACCESS-FORMS FORM))))))
		 (SIMPLE-LET (STORE VAL STORE-FORM)
		   (LT:LET-SUBST (LIST STORE) (LIST VAL) STORE-FORM ENV))
		 (CONDITIONALIZE (FORMS)
		   (IF COND-CONSTANT
		       FORMS
		       `((WHEN ,COND-VALUE
			   ,@FORMS)))))
	  (LET ((BODY-FORM
		  `(UNWIND-PROTECT
		       (PROGN
			 ,@(CONDITIONALIZE (MAPCAR #'SIMPLE-LET STORES VALS STORE-FORMS))
			 ,@REAL-BODY)
		     ,@(CONDITIONALIZE
			 (MAPCAR
			   #'(LAMBDA (STORE STORE-FORM ACCESS-FORM GENSYM1 GENSYM2)
			       (IF (NULL GENSYM2)
				   (SIMPLE-LET STORE GENSYM1 STORE-FORM)
				   `(IF ,GENSYM2
					,(SIMPLE-LET STORE GENSYM1 STORE-FORM)
					(VARIABLE-MAKUNBOUND ,ACCESS-FORM))))
			   STORES STORE-FORMS ACCESS-FORMS GENSYMS1 GENSYMS2)))))
	    (WHEN DECLARATIONS
	      (SETQ BODY-FORM `(CL:LOCALLY
				 ,@DECLARATIONS
				 ,BODY-FORM)))
	    (IF COND-CONSTANT
		`(LET* (,@(MAPCAR #'LIST TVARS TVALS))
		   ,(SAVE-OLD-VALUE GENSYMS1 GENSYMS2 ACCESS-FORMS BODY-FORM))
		(LET ((ALL-TEMPS (APPEND TVARS (LOOP FOR GENSYM1 IN GENSYMS1
						     FOR GENSYM2 IN GENSYMS2
						     WHEN GENSYM2 COLLECT GENSYM2
						     COLLECT GENSYM1))))
		  `(LET ((,COND-VALUE ,COND))
		     (DECLARE (COMPILER:VARIABLE-INLINABLE ,COND-VALUE))
		     (MULTIPLE-VALUE-BIND ,ALL-TEMPS
			 (AND ,COND-VALUE
			      (LET* (,@(MAPCAR #'LIST TVARS TVALS))
				,(SAVE-OLD-VALUE GENSYMS1 GENSYMS2 ACCESS-FORMS
						 `(VALUES ,@ALL-TEMPS))))
		       ,BODY-FORM))))))))))

;;;  LET-GLOBALLY is similar to LETF, except that the binding applies
;;;  to the whole world, not just the currently-executing stack group.
;;;  For the moment, anyway, it is implemented using UNWIND-PROTECT.
;;;  This works for any SETF-able or LOCF-able place.
(DEFMACRO LET-GLOBALLY (VARLIST &BODY BODY &ENVIRONMENT ENV)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (LET-GLOBALLY-EXPAND T VARLIST BODY ENV))

(DEFMACRO LET-GLOBALLY-IF (COND VARLIST &BODY BODY &ENVIRONMENT ENV)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (LET-GLOBALLY-EXPAND COND VARLIST BODY ENV))

;;; DEFUNP is like DEFUN but provides an implicit PROG.
;;; However, the value on falling off the end is the last thing in the body.
(DEFMACRO DEFUNP (FUNCTION ARGS &REST BODY &ENVIRONMENT ENV)
  (MULTIPLE-VALUE-BIND (DECLARATIONS REAL-BODY)
      (FIND-BODY-DECLARATIONS BODY ENV)
    (SETF REAL-BODY (COPYLIST REAL-BODY))
    (LET ((LAST (LAST REAL-BODY)))
      (UNLESS (ATOM (CAR LAST))
	(SETF (CAR LAST) `(RETURN ,(CAR LAST)))))
    `(DEFUN ,FUNCTION ,ARGS
       ,@DECLARATIONS
       (PROG () ,@REAL-BODY))))

;;; (KEYWORD-EXTRACT <keylist> KEY (FOO (UGH BLETCH) BAR) (FLAG FALG) <otherwise> ...)
;;; parses a TV-DEFINE-PC-PPR style list of alternating keywords and values, <keylist>.
;;; The symbol KEY is bound internally to remaineder of the keyword list.
;;; The keywords recognized are :FOO, :BAR and UGH;  whatever follows
;;; the keyword UGH is put in the variable BLETCH, whatever follows the
;;; keyword :FOO is put in the variable FOO, and similar for BAR.
;;; The flags are :FLAG and :FALG;  if :FLAG is seen, FLAG is set to T.
;;; <otherwise> is one or more SELECTQ clauses which can be used
;;; to recognize whatever else you like, in nonstandard format.
;;; To gobble the next thing from the <keylist>, say (CAR (SETQ KEY (CDR KEY))).
(DEFMACRO KEYWORD-EXTRACT (KEYLIST KEYVAR KEYWORDS &OPTIONAL FLAGS &BODY OTHERWISE)
  `(DO ((,KEYVAR ,KEYLIST (CDR ,KEYVAR)))
       ((NULL ,KEYVAR))
     (SELECTQ (CAR ,KEYVAR)
       ,@(MAPCAR (FUNCTION (LAMBDA (KEYWORD)
			     (COND ((ATOM KEYWORD)
				    `(,(INTERN (STRING KEYWORD) PKG-KEYWORD-PACKAGE)
				      (SETQ ,KEYWORD (CAR (SETQ ,KEYVAR (CDR ,KEYVAR))))))
				   (T `(,(CAR KEYWORD)
					(SETQ ,(CADR KEYWORD)
					      (CAR (SETQ ,KEYVAR (CDR ,KEYVAR)))))))))
		 KEYWORDS)
       ,@(MAPCAR (FUNCTION (LAMBDA (KEYWORD)
			     (COND ((ATOM KEYWORD)
				    `(,(INTERN (STRING KEYWORD) PKG-KEYWORD-PACKAGE)
				      (SETQ ,KEYWORD T)))
				   (T `(,(CAR KEYWORD)
					(SETQ ,(CADR KEYWORD) T))))))
		 FLAGS)
       ,@OTHERWISE
       ,@(UNLESS (MEMQ (CAAR (LAST OTHERWISE)) '(T OTHERWISE))
	   `((OTHERWISE
	       (SIGNAL 'UNDEFINED-KEYWORD-ARGUMENT
		       ':KEYWORD (CAR ,KEYVAR)
		       ':PROCEED-TYPES '(:NO-ACTION))))))))

;;; PSETQ looks like SETQ but does its work in parallel.
;;; Note that the return value of PSETQ is -not- guaranteed.
(DEFMACRO PSETQ (&REST REST)
  ;; To improve the efficiency of do-stepping, by using the SETE-CDR, SETE-CDDR,
  ;; SETE-1+, and SETE-1- instructions, we try to do such operations with SETQ
  ;; rather than PSETQ.  To avoid having to do full code analysis, never rearrange
  ;; the order of any code when doing this, and only do it when there are no
  ;; variable name duplications.
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (LOOP FOR (VAL VAR) ON (REVERSE REST) BY 'CDDR
	WITH SETQS = NIL WITH PSETQS = NIL
	DO (IF (AND (NULL PSETQS)
		    (LISTP VAL)
		    (MEMQ (CAR VAL) '(1+ 1- CDR CDDR))
		    (EQ (CADR VAL) VAR)
		    (NOT (MEMQ VAR SETQS)))
	       (SETQ SETQS (CONS VAR (CONS VAL SETQS)))
	       (SETQ PSETQS (CONS VAR (CONS VAL PSETQS))))
	FINALLY
	  (SETQ PSETQS (PSETQ-PROG1IFY PSETQS))
	  (RETURN (COND ((NULL SETQS) PSETQS)
			((NULL PSETQS) (CONS 'SETQ SETQS))
			(T `(PROGN ,PSETQS (SETQ . ,SETQS)))))))

(DEFUN PSETQ-PROG1IFY (X)
  (COND ((NULL X) NIL)
	((NULL (CDDR X)) (CONS 'SETQ X))
	(T `(SETQ ,(CAR X) (PROG1 ,(CADR X) ,(PSETQ-PROG1IFY (CDDR X)))))))

;;; (LOCAL-DECLARE ((SPECIAL FOO) (UNSPECIAL BAR)) code)
;;; declares FOO and BAR locally within <code>.
;;; LOCAL-DECLARE can also be used by macros to pass information down
;;; to other macros that expand inside the code they produce.
;;; The list of declarations (in this case, ((MUMBLE FOO BAR))) is appended
;;; onto the front of LOCAL-DECLARATIONS, which can be searched by
;;; macros expending inside of <code>.
(DEFMACRO LOCAL-DECLARE (DECLARATIONS &BODY BODY)
  `(COMPILER-LET ((LOCAL-DECLARATIONS (APPEND ',DECLARATIONS LOCAL-DECLARATIONS)))
     . ,BODY))

;;; (LET-CLOSED (variables as in LET) initializations ... (FUNCTION ..))
;;; binds the variables and executes the initialization,
;;; then returns the last thing in the body, closed over those variables.
(DEFMACRO LET-CLOSED (VARS &BODY BODY)
  (LET ((VARNAMES (MAPCAR (FUNCTION (LAMBDA (V) (COND ((ATOM V) V) (T (CAR V))))) VARS)))
    `(LET ,VARS
       (DECLARE (SPECIAL . ,VARNAMES))
       (CLOSURE ',VARNAMES (PROGN . ,BODY)))))

(DEFMACRO SPECIAL (&REST SYMBOLS)
  `(PROGN ,@(MAPCAR #'(LAMBDA (SYMBOL) `(CL:PROCLAIM '(SPECIAL ,SYMBOL)))
		    SYMBOLS)))

(DEFMACRO UNSPECIAL (&REST SYMBOLS)
  `(PROGN ,@(MAPCAR #'(LAMBDA (SYMBOL) `(CL:PROCLAIM '(ZL:UNSPECIAL ,SYMBOL)))
		    SYMBOLS)))

;;; Make a variable special and, optionally, initialize it.
;;; This is recorded as a definition by TAGS and ZWEI.
(DEFMACRO DEFVAR (NAME &OPTIONAL (INITIAL-VALUE NIL INITIAL-VALUE-P) &REST ARGS)
  (DECLARE (ARGLIST NAME &OPTIONAL INITIAL-VALUE
				   DOCUMENTATION-OR-FIRST-KEY
			 &KEY DOCUMENTATION LOCALIZE))
  `(PROGN
     (EVAL-WHEN (COMPILE)
       (SPECIAL-COMPILE ',NAME))
     (EVAL-WHEN (LOAD EVAL)
       (DEFVAR-1 ,NAME
		 ,@(WHEN INITIAL-VALUE-P
		     `(,INITIAL-VALUE
		       ,@(WHEN ARGS
			   (IF (SI:SOME-STRING (FIRST ARGS))
			       ARGS
			       (DESTRUCTURING-BIND (&KEY DOCUMENTATION (LOCALIZE NIL LOC-P))
				   ARGS				 
				 (IF LOC-P
				     (LIST DOCUMENTATION LOCALIZE)
				     (LIST DOCUMENTATION)))))))))))

(EVAL-WHEN (COMPILE LOAD EVAL)
(DEFUN DEFCONSTANT-COPY-VALUE-P (VALUE)
  (FLET ((COPYABLE-ATOM (VALUE)
	   (AND (NOT (SYMBOLP VALUE)) (%POINTERP VALUE))))
    (IF (ATOM VALUE)
	(COPYABLE-ATOM VALUE)
	(AND (EQ (FIRST VALUE) 'QUOTE)
	     (COPYABLE-ATOM (SECOND VALUE))))))
);end EVAL-WHEN

;;; Similar to DEFVAR, but if initialization given, always use it (not just if
;;; variable was previously unbound).
(DEFMACRO DEFCONST (VARIABLE INITIAL-VALUE &OPTIONAL (DOCUMENTATION NIL DOCUMENTATION-P))
  ;; Copy constants into PERMANENT-STORAGE-AREA, but don't mess with
  ;; initial values that might be shared with other structure.
  ;; I assume that #. and #, and #n# aren't being used to share constants with other data.
  ;; Copying constants is good because it makes them more compact in virtual memory.
  (LET ((COPIED-VALUE (IF (DEFCONSTANT-COPY-VALUE-P INITIAL-VALUE)
			  `(COPYTREE-AND-LEAVES ,INITIAL-VALUE PERMANENT-STORAGE-AREA)
			  INITIAL-VALUE)))
    `(PROGN
       (EVAL-WHEN (COMPILE)
	 (SPECIAL-COMPILE ',VARIABLE))
       (EVAL-WHEN (LOAD EVAL)
	 (DEFCONST-1 ,VARIABLE ,COPIED-VALUE ,@(WHEN DOCUMENTATION-P `(,DOCUMENTATION)))))))

;;; Similar to DEFCONST, but allows the compiler to open-code
(DEFMACRO DEFCONSTANT (NAME VALUE &OPTIONAL (DOCUMENTATION NIL DOCUMENTATION-P))
  (LET ((COPIED-VALUE (IF (DEFCONSTANT-COPY-VALUE-P VALUE)
			  `(COPYTREE-AND-LEAVES ,VALUE PERMANENT-STORAGE-AREA)
			  VALUE)))
    `(PROGN
       (EVAL-WHEN (COMPILE)
	 (DEFCONSTANT-COMPILE ',NAME ',VALUE))
       (EVAL-WHEN (LOAD EVAL)
	 (DEFCONSTANT-1 ,NAME ,COPIED-VALUE ,@(WHEN DOCUMENTATION-P `(,DOCUMENTATION)))))))



;;; The following stuff is to handle standard bindings

(DEFMACRO DEFVAR-RESETTABLE (NAME INITIAL-VALUE
			     &OPTIONAL (WARM-BOOT-VALUE INITIAL-VALUE) DOCUMENTATION)
  (DECLARE (ZWEI:INDENTATION 1 2))
  `(PROGN (DEFVAR ,NAME ,INITIAL-VALUE ,DOCUMENTATION)
	  (REMEMBER-VARIABLE-BINDING ',NAME ,WARM-BOOT-VALUE
				     '*WARM-BOOT-BINDINGS*)))

(DEFMACRO DEFVAR-STANDARD (NAME INITIAL-VALUE
			   &OPTIONAL IGNORE (STANDARD-VALUE INITIAL-VALUE) VALIDATION-PREDICATE
			   DOCUMENTATION)
  (DECLARE (ZWEI:INDENTATION 1 2))
  `(PROGN
     (DEFVAR ,NAME ,INITIAL-VALUE ,DOCUMENTATION)
     (REMEMBER-VARIABLE-BINDING ',NAME ,STANDARD-VALUE
				'*STANDARD-BINDINGS*)
     ,(IF VALIDATION-PREDICATE
	  `(DEFUN (:PROPERTY ,NAME VALIDATION-FUNCTION) (,NAME)
	     (DECLARE (SYS:FUNCTION-PARENT ,NAME DEFVAR))
	     ,(IF (SYMBOLP VALIDATION-PREDICATE)
		  `(FUNCALL ',VALIDATION-PREDICATE ,NAME)
		  VALIDATION-PREDICATE))
	  `(NREMPROP ',NAME 'VALIDATION-FUNCTION))))

;; This binds the interactive bindings list to include the bindings
;; specified by VARS and VALS.  The symbols specified in VARS are then
;; bound to the values in VALS, as in PROGV.  VALS are not evaluated.
(DEFMACRO STANDARD-VALUE-PROGV (VARS VALS &BODY BODY &ENVIRONMENT ENV)
  (DECLARE (ZWEI:INDENTATION 0 3 2 1))
  (ONCE-ONLY (VARS VALS &ENVIRONMENT ENV)
    `(LET-IF ,VARS ((*INTERACTIVE-BINDINGS* *INTERACTIVE-BINDINGS*))
       (WHEN ,VARS
	 (LOOP FOR VAR IN ,VARS
	       FOR VAL IN ,VALS
	       DO (BIND-INTERACTIVE-VALUE-INTERNAL VAR VAL)))
       (PROGV ,VARS ,VALS
	 ,@BODY))))

;; Cannot make obsolete, because we cannot UNDO SETF's very easily.
(DEFMACRO SETQ-STANDARD-VALUE (NAME FORM &OPTIONAL (SETQ-P T) (GLOBALLY-P T) (ERROR-P T))
  (IGNORE ERROR-P)
  `(SETF (STANDARD-VALUE ',NAME :GLOBAL-P ,GLOBALLY-P :SETQ-P ,SETQ-P) ,FORM))

(DEFUN (:PROPERTY SETQ-STANDARD-VALUE :UNDO-FUNCTION) (FORM)
  (DESTRUCTURING-BIND (NIL NAME NIL) FORM
    `(SETQ-STANDARD-VALUE ,NAME ',(SYMEVAL NAME))))

;; The LET-style of STANDARD-VALUE-PROGV.  VALS are evaluated
(DEFMACRO STANDARD-VALUE-LET (VARS-AND-VALS &BODY BODY)
  `(LET ((*INTERACTIVE-BINDINGS* *INTERACTIVE-BINDINGS*))
     (LET ,VARS-AND-VALS
       ,@(LOOP FOR (VAR) IN VARS-AND-VALS
	       COLLECT `(BIND-INTERACTIVE-VALUE-INTERNAL ',VAR ,VAR))
       ,@BODY)))

(DEFMACRO STANDARD-VALUE-LET* (VARS-AND-VALS &BODY BODY)
  `(LET ((*INTERACTIVE-BINDINGS* *INTERACTIVE-BINDINGS*))
     (LET* ,VARS-AND-VALS
       ,@(LOOP FOR (VAR) IN VARS-AND-VALS
	       COLLECT `(BIND-INTERACTIVE-VALUE-INTERNAL ',VAR ,VAR))
       ,@BODY)))


;;; Allow easy creation of meters and a handle to them.
(DEFMACRO DEFINE-METERS (METER-LIST-NAME . METER-NAMES)
  (DECLARE (ARGLIST METER-LIST-NAME &REST METER-NAMES))
  `(PROGN (PUSH* ',METER-LIST-NAME *ALL-METER-SETS*)
	  (RECORD-SOURCE-FILE-NAME ',METER-LIST-NAME 'DEFINE-METERS)
	  (DEFCONST ,METER-LIST-NAME
		    ',(LOOP FOR METER-NAME IN METER-NAMES
			    COLLECT (IF (ATOM METER-NAME) METER-NAME (CAR METER-NAME))))
	  ,@(LOOP FOR METER-NAME IN METER-NAMES
		  WHEN (ATOM METER-NAME)
		    DO (SETQ METER-NAME (LIST METER-NAME))
		  COLLECT `(,(COND ((GET METER-NAME :WIRED) 'DEFVAR-SAFEGUARDED)
				   ((GET METER-NAME :SAFEGUARDED) 'DEFVAR-SAFEGUARDED)
				   (T 'DEFVAR))
			     ,(CAR METER-NAME) 0))))

;;; For use by low-level system code, such as storage allocation ("consing"), which
;;; cannot tolerate stack overflow and the resultant signalling of a condition.
;;; Within the body, scheduling and control-stack overflows can't happen.
;;; Metering traps on function entry and exit are also disabled, because these can
;;; cause (1) allocation, and (2) stack overflows.
;;; CONTROL-STACK-SPACE is the maximum number of words of stack needed by the body.
;;; The body should avoid using the binding and data stacks.
(DEFMACRO WITHOUT-INTERRUPTS-AND-STACK-OVERFLOWS ((CONTROL-STACK-SPACE) &BODY BODY)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  ;;The implementation is machine-dependent.
  `(LET ((OLD-INHIBIT-SCHEDULING-FLAG INHIBIT-SCHEDULING-FLAG)
	 (INHIBIT-SCHEDULING-FLAG T))
     (WITH-METERING-DISABLED
       ;; If a stack overflow might occur in the body, signal it now
       (LOOP WHILE
	       (< (SYS:%POINTER-DIFFERENCE
		    (PROGN #+3600 SYS:%CONTROL-STACK-LIMIT
			   #+IMACH (%POINTER-PLUS
				     (SYS:SG-CONTROL-STACK-LIMIT SYS:%CURRENT-STACK-GROUP)
				     (- (+ SYS:CONTROL-STACK-MAX-FRAME-SIZE
					   SYS:CONTROL-STACK-OVERFLOW-MARGIN))))
		    (SYS:%STACK-FRAME-POINTER))
		  ,CONTROL-STACK-SPACE)
	     DO (STACK-OVERFLOW NIL OLD-INHIBIT-SCHEDULING-FLAG)
		(SETQ INHIBIT-SCHEDULING-FLAG T))
       ;; It is now safe to execute the body
       ,@BODY)))

(DEFMACRO AVOID-STACK-OVERFLOW (SIZE)
  `(WHEN
     (AND (< (SYS:%POINTER-DIFFERENCE
	       (PROGN #+3600 SYS:%CONTROL-STACK-LIMIT
		      #+IMACH (%POINTER-PLUS
				(SYS:SG-CONTROL-STACK-LIMIT SYS:%CURRENT-STACK-GROUP)
				(- (+ SYS:CONTROL-STACK-MAX-FRAME-SIZE
				      SYS:CONTROL-STACK-OVERFLOW-MARGIN))))
	       (SYS:%STACK-FRAME-POINTER))
	     ,SIZE)
	  (LET ((ABSOLUTE (SYS:SG-ABSOLUTE-CONTROL-STACK-LIMIT SYS:%CURRENT-STACK-GROUP)))
	    (OR (NOT ABSOLUTE)
		( (* DBG:PDL-GROW-RATIO
		      (SI:%POINTER-DIFFERENCE
			(PROGN #+3600 SYS:%CONTROL-STACK-LIMIT
			       #+IMACH (SYS:SG-CONTROL-STACK-LIMIT SYS:%CURRENT-STACK-GROUP))
			SYS:%CONTROL-STACK-LOW))
		   ABSOLUTE))))
     (SYS:STACK-OVERFLOW NIL SYS:INHIBIT-SCHEDULING-FLAG)))

(DEFMACRO WITHOUT-FLOATING-UNDERFLOW-TRAPS (&BODY BODY)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (LET ((OLD-FOM (GENSYM)))
    `(LET ((,OLD-FOM (FLOAT-OPERATING-MODE)))
       (UNWIND-PROTECT
	 (PROGN (SET-FLOAT-OPERATING-MODE (DPB 0 %%FLOAT-TRAP-ENABLE-UNDERFLOW ,OLD-FOM))
		NIL				; in case there's no body
		. ,BODY)
	 (SET-FLOAT-OPERATING-MODE ,OLD-FOM)))))

;;; MAPC with a prog body instead of a function.  <form> evaluates to a list,
;;; and <body> is executed with <var> bound to successive elements of the list.
(DEFMACRO DOLIST ((VAR FORM) &BODY BODY &ENVIRONMENT ENV)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (CLI::EXPAND-DOLIST VAR FORM NIL BODY ENV 'NULL))

;;; Repeat a number of times.  <form> evaluates to the number of times,
;;; and <body> is executed with <var> bound to 0, 1, ...
(DEFMACRO DOTIMES ((VAR FORM) &BODY BODY)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(CL:DOTIMES (,VAR ,FORM) ,@BODY))

(EVAL-WHEN (EVAL LOAD COMPILE)
(DEFUN TYPECASE-DEFINER (PREDICATE OBJECT BODY &OPTIONAL ENVIRONMENT)
  (ONCE-ONLY (OBJECT &ENVIRONMENT ENVIRONMENT)
    `(COND
       . ,(LOOP FOR (TYPES . CONSEQUENTS) IN BODY
		COLLECT `(,(COND ((EQ TYPES 'OTHERWISE)
				  'T)
				 ((ATOM TYPES)
				  `(,PREDICATE ,OBJECT ',TYPES))
				 (T
				  `(OR . ,(LOOP FOR TYPE IN TYPES
						COLLECT `(,PREDICATE ,OBJECT ',TYPE)))))
			  . ,(OR CONSEQUENTS '(NIL))))))))

(DEFMACRO TYPECASE (OBJECT &BODY BODY &ENVIRONMENT ENV)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (TYPECASE-DEFINER 'TYPEP OBJECT BODY ENV))

(DEFMACRO WITH-INDENTATION ((STREAM-VAR RELATIVE-INDENTATION) &BODY BODY &ENVIRONMENT ENV)
  (ONCE-ONLY (RELATIVE-INDENTATION &ENVIRONMENT ENV)
    (LET ((INDENTING-STREAM (GENSYM)))
      `(MULTIPLE-VALUE-BIND (,STREAM-VAR ,INDENTING-STREAM)
	   (MAKE-STREAM-INDENTABLE ,STREAM-VAR ,RELATIVE-INDENTATION)
	 (UNWIND-PROTECT
	   (PROGN . ,BODY)
	   (FUNCALL ,STREAM-VAR ':INDENT-RELATIVE (MINUS ,RELATIVE-INDENTATION))
	   (AND ,INDENTING-STREAM
		(DEALLOCATE-RESOURCE 'INDENTING-STREAM ,INDENTING-STREAM)))))))

(DEFMACRO PKG-BIND (PKG &BODY BODY)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(LET ((PACKAGE (PKG-FIND-PACKAGE ,PKG)))
     . ,BODY))

;;; user is allowed to muck with aborted-p-var if desired.
(DEFMACRO UNWIND-PROTECT-CASE ((&OPTIONAL ABORTED-P-VAR) BODY-FORM &REST CLEANUP-CLAUSES)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (DECLARE (ZWEI:INDENTATION 1 3 2 1))
  (IF (NULL ABORTED-P-VAR) (SETQ ABORTED-P-VAR (GENSYM)))
  `(LET ((,ABORTED-P-VAR T))
     (UNWIND-PROTECT
	 (MULTIPLE-VALUE-PROG1 ,BODY-FORM (SETQ ,ABORTED-P-VAR NIL))
       ,@(LOOP FOR (CLEANUP-CONDITION . FORMS) IN CLEANUP-CLAUSES
	       COLLECT (SELECTQ CLEANUP-CONDITION
			 (:NORMAL `(WHEN (NOT ,ABORTED-P-VAR) ,@FORMS))
			 (:ABORT `(WHEN ,ABORTED-P-VAR ,@FORMS))
			 (:ALWAYS `(PROGN ,@FORMS))
			 (OTHERWISE (FERROR "~S is not a valid cleanup-condition condition,~@
					     expected one of :NORMAL, :ABORT, :ALWAYS"
					    CLEANUP-CONDITION)))))))

;; New Error System macros
(EVAL-WHEN (COMPILE LOAD EVAL)
(DEFUN MASSAGE-CONDITION-BIND-HANDLER (FUNCTION &AUX LAM)
  (COND ((AND (LISTP FUNCTION)
	      (EQ (CAR FUNCTION) 'FUNCTION)
	      (LISTP (CADR FUNCTION))
	      (MEMQ (CAR (CADR FUNCTION)) '(LAMBDA NAMED-LAMBDA DIGESTED-LAMBDA)))
	 (SETQ LAM (CADR FUNCTION)))
	((AND (LISTP FUNCTION)
	      (MEMQ (CAR FUNCTION) '(LAMBDA NAMED-LAMBDA DIGESTED-LAMBDA)))
	 (SETQ LAM FUNCTION)))
  (COND ((NULL LAM) FUNCTION)
	(T (SETQ LAM (UNDIGEST LAM))
	   `#',(SELECTQ (CAR LAM)
		 (LAMBDA
		  `(LAMBDA ,(SECOND LAM)
		     (DECLARE (DOWNWARD-FUNCTION) (DBG:ERROR-REPORTER T))
		     . ,(CDDR LAM)))
		 (NAMED-LAMBDA
		  `(NAMED-LAMBDA
		     ,(SECOND LAM) ,(THIRD LAM)
		     (DECLARE (DOWNWARD-FUNCTION) (DBG:ERROR-REPORTER T))
		     ,@(CDDDR LAM)))))))


(DEFUN EXPAND-CONDITION-BIND (HANDLER-LIST COND LIST BODY)
  (LOOP FOR (FLAVOR-LIST) IN LIST
	WHEN (NLISTP FLAVOR-LIST)
	  DO (SETQ FLAVOR-LIST (LIST FLAVOR-LIST))
	DO (DOLIST (FLAVOR FLAVOR-LIST)
	     (FLAVOR:CHECK-FLAVOR-NAME FLAVOR "condition")))
  (LET ((CONDLIST-VAR (GENSYM)))
    `(WITH-STACK-LIST (,CONDLIST-VAR
		       . ,(LOOP FOR (FLAVOR-LIST FUNCTION) IN LIST
				APPEND `(',(IF (LISTP FLAVOR-LIST)
					       FLAVOR-LIST
					       (LIST FLAVOR-LIST))
					 ,(MASSAGE-CONDITION-BIND-HANDLER FUNCTION))))
       (DBG:WITH-STACK-LIST*-IF
	 ,COND
	 (,HANDLER-LIST
	  #'(LAMBDA (MESSAGE &REST ARGS)
	      (DECLARE (DOWNWARD-FUNCTION) (DBG:ERROR-REPORTER T))
	      (LEXPR-FUNCALL
		#'DBG:CONDITION-BIND-HANDLER MESSAGE ,CONDLIST-VAR ARGS))
	  ,HANDLER-LIST)
	 . ,BODY)))) 

(DEFUN CONDITION-CASE-INTERNAL (VARLIST CLAUSES)
  ;; If we need a variable to receive the condition object, make sure we have one
  (WHEN (AND (NULL (CAR VARLIST)) (NOT (NULL (CDR CLAUSES))))
    (SETQ VARLIST (CONS (GENSYM) (CDR VARLIST))))
  (LOOP FOR (FLAVOR-LIST . CODE) IN CLAUSES
	DO (IGNORE CODE)
	WHEN (LISTP FLAVOR-LIST)
	  APPEND FLAVOR-LIST INTO LIST
	  ELSE COLLECT FLAVOR-LIST INTO LIST
	FINALLY
	  (DOLIST (FLAVOR LIST)
	    (FLAVOR:CHECK-FLAVOR-NAME FLAVOR "condition"))
	  (RETURN
	    (VALUES (MAKE-INSTANCE 'DBG:CASE-HANDLER ':FLAVOR-LIST LIST)
		    (AND (CAR VARLIST) (LIST (CAR VARLIST)))
		    VARLIST
		    (IF (NULL (CDR CLAUSES))
			`(PROGN . ,(CDAR CLAUSES))
			`(TYPECASE ,(CAR VARLIST)
			   . ,(MAKE-LAST-CLAUSE-OTHERWISE CLAUSES)))))))

(DEFUN CONDITION-CALL-INTERNAL (VARLIST CLAUSES)
  (LOOP FOR (PREDICATE . BODY) IN CLAUSES
	FOR MARKER FROM 0
	DO (COND ((SYMBOLP PREDICATE)
		  (COMPILER:FUNCTION-REFERENCED PREDICATE))
		 ((AND (LISTP PREDICATE) (FUNCTIONP PREDICATE))
		  (COMPILER:WARN () "The predicate ~S will not be compiled and will not inherit a lexical environment." PREDICATE))
		 (T (FERROR "~S is an invalid predicate in CONDITION-CALL" PREDICATE)))
	COLLECT (LIST PREDICATE MARKER) INTO ALIST
	COLLECT (CONS MARKER BODY) INTO CLAUSES
	WITH VAR = (CAR VARLIST)
	WITH MARKER-VAR = (GENSYM)
	FINALLY
	  (RETURN (VALUES (MAKE-INSTANCE 'DBG:CALL-HANDLER ':PREDICATE-ALIST ALIST)
			  (COND ((CDR CLAUSES) `(,VAR ,MARKER-VAR))
				((NULL VAR) NIL)
				(T `(,VAR)))
			  VARLIST
			  (IF (CDR CLAUSES)
			      `(SELECTQ ,MARKER-VAR
				 . ,(MAKE-LAST-CLAUSE-OTHERWISE CLAUSES))
			      `(PROGN . ,(CDAR CLAUSES)))))))

(DEFUN CONDITION-CASE-EXPAND (MACRO INTERNAL COND VARLIST FORM CLAUSES)
  (LET ((NO-ERROR-CLAUSE (AND (EQ (CAAR (LAST CLAUSES)) ':NO-ERROR)
			      (PROG1 (CAR (LAST CLAUSES))
				     (SETQ CLAUSES (BUTLAST CLAUSES))))))
    (WHEN (ASSQ ':NO-ERROR CLAUSES)
      (COMPILER:WARN () "The ~S clause ~S must be the last clause to be recognized."
		     MACRO (ASSQ ':NO-ERROR CLAUSES)))
    ;; Without a :NO-ERROR clause, binding extra variables
    ;; is meaningless.  Warn and bind 'em to NIL.
    (AND (NOT NO-ERROR-CLAUSE)
	 (CDR VARLIST)
	 (COMPILER:WARN () "Extra bound variables ~S supplied in ~S,~@
			    but there is no :NO-ERROR clause."
			(CDR VARLIST) MACRO))
    (IF (MEMBER COND '(NIL 'NIL))
	(IF NO-ERROR-CLAUSE
	    `(MULTIPLE-VALUE-BIND ,VARLIST ,FORM
	       ,@(CDR NO-ERROR-CLAUSE))
	  FORM)
	(LET ((RETURN-FROM-ALL (GENSYM)) (RETURN-FOR-NO-ERROR (GENSYM)))
	  ;; Canonicalize ways of ignoring condition (as far as the user's code is concerned)
	  (WHEN (OR (STRING-EQUAL (CAR VARLIST) "IGNORE")
		    (STRING-EQUAL (CAR VARLIST) "IGNORED"))
	    (SETQ VARLIST (CONS NIL (CDR VARLIST))))
	  ;; Convert the clauses into an appropriate dispatch
	  (MULTIPLE-VALUE-BIND (HANDLER SETQS VARLIST CLAUSES)
	      (FUNCALL INTERNAL VARLIST CLAUSES)
	    (LET ((ANSWER `(MULTIPLE-VALUE-BIND ,SETQS
			       (DBG:CONDITION-INTERNAL ,COND ',HANDLER
				 (RETURN-FROM ,(IF NO-ERROR-CLAUSE
						   RETURN-FOR-NO-ERROR
						   RETURN-FROM-ALL)
				   ,FORM))
			     ;; Touch the first SETQ, since it may be
			     ;; the name of a variable used only in a
			     ;; :NO-ERROR clause and not used here.
			     (IGNORE ,(FIRST SETQS))
			     (RETURN-FROM ,RETURN-FROM-ALL
			       ,CLAUSES))))
	      ;; If there is a :NO-ERROR clause, (multiple-value-)bind
	      ;; it's for the result(s) of FORM and execute the
	      ;; :NO-ERROR clause in that environment.
	      (IF NO-ERROR-CLAUSE
		  (SETQ ANSWER `(MULTIPLE-VALUE-BIND ,VARLIST
				    (BLOCK ,RETURN-FOR-NO-ERROR
				      ;; (DECLARE (INVISIBLE-BLOCK T))
				      ,ANSWER)
				  ;; This is how we touch variables.
				  ;; Only touch the first, since that
				  ;; could also be the error which is
				  ;; handled in another clause.
				  (IGNORE ,(FIRST VARLIST))
				  (RETURN-FROM ,RETURN-FROM-ALL
				    (PROGN ,@(CDR NO-ERROR-CLAUSE))))))
	      ;; Finally, put the outside named block
	      (SETQ ANSWER `(BLOCK ,RETURN-FROM-ALL
			      ;; (DECLARE (INVISIBLE-BLOCK T))
			      ,ANSWER))
	      ANSWER))))))

);End EVAL-WHEN

(DEFMACRO CONDITION-BIND (LIST &BODY BODY)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (EXPAND-CONDITION-BIND 'DBG:*BOUND-HANDLERS* T LIST BODY))

(DEFMACRO CONDITION-BIND-IF (COND LIST &BODY BODY)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (EXPAND-CONDITION-BIND 'DBG:*BOUND-HANDLERS* COND LIST BODY))

(DEFMACRO CONDITION-BIND-DEFAULT (LIST &BODY BODY)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (EXPAND-CONDITION-BIND 'DBG:*DEFAULT-HANDLERS* T LIST BODY))

(DEFMACRO CONDITION-BIND-DEFAULT-IF (COND LIST &BODY BODY)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (EXPAND-CONDITION-BIND 'DBG:*DEFAULT-HANDLERS* COND LIST BODY))

(DEFMACRO CONDITION-CASE ((&REST VARLIST) FORM &REST CLAUSES)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (DECLARE (ZWEI:INDENTATION 1 4 2 2))
  (CONDITION-CASE-EXPAND 'CONDITION-CASE #'CONDITION-CASE-INTERNAL
			 T VARLIST FORM CLAUSES))

(DEFMACRO CONDITION-CASE-IF (COND (&REST VARLIST) FORM &REST CLAUSES)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (DECLARE (ZWEI:INDENTATION 2 4 3 2))
  (CONDITION-CASE-EXPAND 'CONDITION-CASE-IF #'CONDITION-CASE-INTERNAL
			 COND VARLIST FORM CLAUSES))

(DEFMACRO CONDITION-CALL ((&REST VARLIST) FORM &BODY CLAUSES)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (CONDITION-CASE-EXPAND 'CONDITION-CALL #'CONDITION-CALL-INTERNAL
			 T VARLIST FORM CLAUSES))

(DEFMACRO CONDITION-CALL-IF (COND (&REST VARLIST) FORM &BODY CLAUSES)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (CONDITION-CASE-EXPAND 'CONDITION-CALL-IF #'CONDITION-CALL-INTERNAL
			 COND VARLIST FORM CLAUSES))

;;; Execute body with a stream open.  Abnormal exit aborts the file (if it's an output file).
;;; The stream variable may be setq'ed to NIL or to an error object in which case
;;; no attempt will be made to close it.  (The error-object case is obsolete but
;;; is still documented, hence it is still supported.)
;;; This code has a timing window; if you abort between the time the stream is
;;; created, somewhere inside the construction-form or something it calls, and
;;; the time the unwind-protect has been set up, the stream will not get closed.
;;; This is impossible to avoid without an entirely different way of keeping track
;;; of what temporarily-allocated resources exist.

(DEFMACRO WITH-OPEN-STREAM ((STREAM-VARIABLE CONSTRUCTION-FORM) &BODY BODY &ENVIRONMENT ENV)
  (MULTIPLE-VALUE-BIND (DECLARATIONS REAL-BODY)
      (SI:FIND-BODY-DECLARATIONS BODY ENV)
    `(LET ((.STREAM-ABORT-FLAG. ':ABORT)
	   (,STREAM-VARIABLE ,CONSTRUCTION-FORM))
       ,@DECLARATIONS
       (UNWIND-PROTECT
	   (MULTIPLE-VALUE-PROG1 (PROGN . ,REAL-BODY)
				 (SETQ .STREAM-ABORT-FLAG. NIL))
	 (CLOSE-OPEN-STREAM ,STREAM-VARIABLE .STREAM-ABORT-FLAG.)))))

;;; Execute body with a file open.  See comments on WITH-OPEN-STREAM.
(DEFMACRO WITH-OPEN-FILE ((STREAM-VARIABLE FILENAME . OPTIONS) &BODY BODY)
  `(WITH-OPEN-STREAM (,STREAM-VARIABLE (OPEN ,FILENAME . ,OPTIONS))
     . ,BODY))

;;; Do the kind of searching that LOAD and related functions do
;;; All the arguments can be evaluated multiple times
;;; PATHNAME can be SETQ'ed
;;; If AUTO-RETRY isn't NIL, code is included to prompt for a new pathname
;;;  if no file is found and the MULTIPLE-FILE-NOT-FOUND condition isn't handled.
(DEFMACRO WITH-OPEN-FILE-SEARCH ((STREAM-VARIABLE
					   (OPERATION DEFAULTS AUTO-RETRY)
					   (TYPE-LIST-FUNCTION PATHNAME . TYPE-LIST-ARGS)
					   . OPEN-OPTIONS)
					  &BODY BODY)
  `(WITH-OPEN-STREAM (,STREAM-VARIABLE
		       (OPEN-FILE-SEARCH (,OPERATION ,DEFAULTS ,AUTO-RETRY)
					 (,TYPE-LIST-FUNCTION ,PATHNAME . ,TYPE-LIST-ARGS)
					 . ,OPEN-OPTIONS))
     . ,BODY))

;;; The part of WITH-OPEN-FILE-SEARCH that opens a file and returns a stream
;;; This is so hairy to be sure to preserve the order of evaluation of the old one.
(DEFMACRO OPEN-FILE-SEARCH ((OPERATION DEFAULTS &OPTIONAL AUTO-RETRY)
			    (TYPE-LIST-FUNCTION PATHNAME &REST TYPE-LIST-ARGS)
			    &REST OPEN-OPTIONS)
  (LET ((OPERATION-VAR (MAKE-SYMBOL "OPERATION"))
	(DEFAULTS-VAR (MAKE-SYMBOL "DEFAULTS"))
	(AUTO-RETRY-VAR (MAKE-SYMBOL "AUTO-RETRY"))
	(PATHNAME-VAR (MAKE-SYMBOL "PATHNAME"))
	(TYPE-LIST-ARGS-VAR (MAKE-SYMBOL "TYPE-LIST-ARGS"))
	(OPEN-OPTIONS-VAR (MAKE-SYMBOL "OPEN-OPTIONS"))
	(NEW-PATHNAME-VAR (MAKE-SYMBOL "NEW-PATHNAME")))
    `(LET ((,OPERATION-VAR ,OPERATION)
	   (,DEFAULTS-VAR ,DEFAULTS)
	   (,AUTO-RETRY-VAR ,AUTO-RETRY)
	   (,PATHNAME-VAR ,PATHNAME))
       (WITH-STACK-LIST (,TYPE-LIST-ARGS-VAR ,@TYPE-LIST-ARGS)
	 (WITH-STACK-LIST (,OPEN-OPTIONS-VAR ,@OPEN-OPTIONS)
	   (OPEN-FILE-SEARCH-INTERNAL ,OPERATION-VAR ,DEFAULTS-VAR ,AUTO-RETRY-VAR
				      #',TYPE-LIST-FUNCTION ,PATHNAME-VAR ,TYPE-LIST-ARGS-VAR
				      ,OPEN-OPTIONS-VAR
				      #'(LAMBDA (,NEW-PATHNAME-VAR)
					  (SETF ,PATHNAME ,NEW-PATHNAME-VAR))))))))


(EVAL-WHEN (COMPILE LOAD EVAL)
(DEFUN OPEN-FILE-SEARCH-INTERNAL (OPERATION DEFAULTS AUTO-RETRY
				  TYPE-LIST-FUNCTION PATHNAME TYPE-LIST-ARGS
				  OPEN-OPTIONS PATHNAME-CONTINUATION)
  (DECLARE (SYS:DOWNWARD-FUNARG PATHNAME-CONTINUATION))
  (CONDITION-BIND-DEFAULT-IF AUTO-RETRY
			     ((FS:MULTIPLE-FILE-NOT-FOUND
				'FS:MULTIPLE-FILE-NOT-FOUND-HANDLER))
    (PROG T ()
       RESTART
	  (RETURN-FROM T
	    (MULTIPLE-VALUE-BIND (TYPE-LIST BASE-PATHNAME)
		(LEXPR-FUNCALL TYPE-LIST-FUNCTION PATHNAME TYPE-LIST-ARGS)
	      (LOOP FOR OPEN-PATHNAME = NIL
		    FOR TYPE IN TYPE-LIST
		    DO (CONDITION-CASE ()
			   (PROGN
			     (SETQ OPEN-PATHNAME
				   (FS:MERGE-PATHNAME-DEFAULTS BASE-PATHNAME
							       DEFAULTS TYPE))
			     (RETURN (LEXPR-FUNCALL #'OPEN OPEN-PATHNAME OPEN-OPTIONS)))
			 ((FS:PATHNAME-ERROR FS:FILE-NOT-FOUND)))
		    WHEN OPEN-PATHNAME
		      COLLECT OPEN-PATHNAME INTO PATHNAMES
		    FINALLY
		      (SIGNAL-PROCEED-CASE ((NEW-PATHNAME) 'FS:MULTIPLE-FILE-NOT-FOUND
					    ':OPERATION OPERATION
					    ':PATHNAME PATHNAME
					    ':PATHNAMES PATHNAMES)
			(:NEW-PATHNAME
			  ;;; Do it in the outer context, too.
			  (FUNCALL PATHNAME-CONTINUATION NEW-PATHNAME)
			  (SETQ PATHNAME NEW-PATHNAME)
			  (GO RESTART)))))))))
);End EVAL-WHEN

;;; A repeatable PRINT/READ environment.
(DEFMACRO SCL:WITH-STANDARD-IO-ENVIRONMENT (&BODY BODY)
  `(MULTIPLE-VALUE-BIND (VARS VALS)
       (CLI::STANDARD-IO-ENVIRONMENT-VARS-AND-VALS)
     (PROGV VARS VALS
       ,@BODY)))

;;; Another repeatable PRINT/READ environment.
(DEFMACRO FUTURE-COMMON-LISP:WITH-STANDARD-IO-SYNTAX (&BODY BODY)
  `(CLI::WITH-STANDARD-IO-SYNTAX-1 #'(LAMBDA () ,@BODY)))

;;; Combination of WITH-OPEN-STREAM and CONDITION-CASE.  See comments on WITH-OPEN-STREAM.
;;; The window here is four 3600 instructions longer than for plain WITH-OPEN-STREAM.
(DEFMACRO WITH-OPEN-STREAM-CASE ((VAR CONSTRUCTION-FORM) &BODY CLAUSES)
  `(CONDITION-CASE (,VAR) ,CONSTRUCTION-FORM
     ,@(LOOP FOR (CONDITION . FORMS) IN CLAUSES
	     WHEN (EQ CONDITION ':NO-ERROR)
	       DO (SETQ FORMS `((LET ((.STREAM-ABORT-FLAG. ':ABORT))
				  (UNWIND-PROTECT
				    (MULTIPLE-VALUE-PROG1 (PROGN . ,FORMS)
					   (SETQ .STREAM-ABORT-FLAG. NIL))
				    (CLOSE-OPEN-STREAM ,VAR .STREAM-ABORT-FLAG.)))))
	     COLLECT `(,CONDITION . ,FORMS))))

(DEFMACRO WITH-OPEN-STREAM-CASE-IF (COND (VAR CONSTRUCTION-FORM) &BODY CLAUSES)
  `(CONDITION-CASE-IF ,COND (,VAR) ,CONSTRUCTION-FORM
     ,@(LOOP FOR (CONDITION . FORMS) IN CLAUSES
	     WHEN (EQ CONDITION ':NO-ERROR)
	       DO (SETQ FORMS `((LET ((.STREAM-ABORT-FLAG. ':ABORT))
				  (UNWIND-PROTECT
				    (MULTIPLE-VALUE-PROG1 (PROGN . ,FORMS)
					   (SETQ .STREAM-ABORT-FLAG. NIL))
				    (CLOSE-OPEN-STREAM ,VAR .STREAM-ABORT-FLAG.)))))
	     COLLECT `(,CONDITION . ,FORMS))))

;;; Combination of WITH-OPEN-FILE and CONDITION-CASE.  See comments on WITH-OPEN-STREAM.
(DEFMACRO WITH-OPEN-FILE-CASE ((VAR PATHNAME . OPTIONS) &BODY CLAUSES)
  `(WITH-OPEN-STREAM-CASE (,VAR (OPEN ,PATHNAME . ,OPTIONS))
     . ,CLAUSES))

(DEFMACRO WITH-OPEN-FILE-CASE-IF (COND (VAR PATHNAME . OPTIONS) &BODY CLAUSES)
  `(WITH-OPEN-STREAM-CASE-IF ,COND (,VAR (OPEN ,PATHNAME . ,OPTIONS))
     . ,CLAUSES))

(EVAL-WHEN (COMPILE LOAD EVAL)
(DEFUN MAKE-LAST-CLAUSE-OTHERWISE (CLAUSES)
  (DO ((C CLAUSES (CDR C))
       (R NIL (CONS (CAR C) R)))
      ((NULL (CDR C))
       (NREVERSE (CONS (CONS 'OTHERWISE (CDAR C)) R)))))
);End EVAL-WHEN

(DEFPROP DEFINE-GLOBAL-HANDLER DEFUN ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)

(DEFMACRO DEFINE-GLOBAL-HANDLER (NAME CONDITIONS ARGLIST &BODY BODY)
  (CHECK-ARG-TYPE NAME :SYMBOL)
  (CHECK-ARG CONDITIONS (NOT (NULL CONDITIONS)) "a non-empty list")
  (WHEN (NLISTP CONDITIONS)
    (SETQ CONDITIONS (LIST CONDITIONS)))
  (LET ((COMPILER:DEFAULT-WARNING-DEFINITION-TYPE 'DEFUN)
	(COMPILER:DEFAULT-WARNING-FUNCTION NAME))
    (DOLIST (FLAVOR CONDITIONS)
      (FLAVOR:CHECK-FLAVOR-NAME FLAVOR "condition")))
  (CHECK-ARG ARGLIST
	     (AND (LISTP ARGLIST) (= (LENGTH ARGLIST) 1))
	     "an argument list with one argument")
  `(PROGN
     (DEFUN ,NAME ,ARGLIST . ,BODY)
     (DBG:DEFINE-GLOBAL-HANDLER-1 ',NAME ',CONDITIONS)))

(DEFPROP DEFINE-GLOBAL-HANDLER "Global Handler" SI:DEFINITION-TYPE-NAME)

(DEFMACRO UNDEFINE-GLOBAL-HANDLER (NAME)
  `(DBG:REMOVE-GLOBAL-HANDLER ',NAME))

;; This is gross because it is called incessantly, and therefore shouldn't cons.
;; Someday maybe it will be possible to do this right...
(DEFMACRO CATCH-ERROR-RESTART ((FLAVORS DESCRIPTION . ARGS) &BODY BODY)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (LET ((DESC-VAR (GENSYM))
	(CLOSURE-LIST (GENSYM)))
    (OR (LISTP FLAVORS) (SETQ FLAVORS (LIST FLAVORS)))
    (DOLIST (FLAVOR FLAVORS)
      (FLAVOR:CHECK-FLAVOR-NAME FLAVOR "condition"))
    `(CL:LOCALLY (DECLARE (SPECIAL DBG:.RESTART.DESCRIPTION.))
       (WITH-STACK-LIST (,DESC-VAR ,DESCRIPTION . ,ARGS)
	 (WITH-STACK-LIST (,CLOSURE-LIST
			   ',(MAKE-INSTANCE 'DBG:ERROR-RESTART-HANDLER ':FLAVORS FLAVORS)
			   (VARIABLE-LOCATION DBG:.RESTART.DESCRIPTION.)
			   (VARIABLE-LOCATION ,DESC-VAR))
	   (WITH-STACK-LIST* (.NEW-RESTART-HANDLERS.
			       (%MAKE-POINTER #+3600 DTP-CLOSURE #+IMACH DTP-DYNAMIC-CLOSURE
					      ,CLOSURE-LIST)
			       DBG:*RESTART-HANDLERS*)
	     ;; set up the catch BEFORE updating the real
	     ;; restart-handlers, since typing c-abort during setup could
	     ;; cause a no-pending-catch error.
	     (CATCH (%MAKE-POINTER DTP-LOCATIVE .NEW-RESTART-HANDLERS.)
	       (LET ((DBG:*RESTART-HANDLERS* .NEW-RESTART-HANDLERS.))
		 . ,BODY))))))))

(DEFMACRO CATCH-ERROR-RESTART-IF (COND (FLAVORS DESCRIPTION . ARGS) &BODY BODY
				  &ENVIRONMENT ENV)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (LET ((DESC-VAR (GENSYM))
	(CLOSURE-LIST (GENSYM)))
    (OR (LISTP FLAVORS) (SETQ FLAVORS (LIST FLAVORS)))
    (DOLIST (FLAVOR FLAVORS)
      (FLAVOR:CHECK-FLAVOR-NAME FLAVOR "condition"))
    (ONCE-ONLY (COND &ENVIRONMENT ENV)
      `(CL:LOCALLY (DECLARE (SPECIAL DBG:.RESTART.DESCRIPTION.))
	 (WITH-STACK-LIST (,DESC-VAR ,DESCRIPTION . ,ARGS)
	   (WITH-STACK-LIST (,CLOSURE-LIST
			     ',(MAKE-INSTANCE 'DBG:ERROR-RESTART-HANDLER ':FLAVORS FLAVORS)
			     (VARIABLE-LOCATION DBG:.RESTART.DESCRIPTION.)
			     (VARIABLE-LOCATION ,DESC-VAR))
	     (WITH-STACK-LIST* (.NEW-RESTART-HANDLERS.
				 (%MAKE-POINTER #+3600 DTP-CLOSURE #+IMACH DTP-DYNAMIC-CLOSURE
						,CLOSURE-LIST)
				 DBG:*RESTART-HANDLERS*)
	       ;; set up the catch BEFORE updating the real
	       ;; restart-handlers, since typing c-abort during setup could
	       ;; cause a no-pending-catch error.
	       (DBG:CATCH-IF ,COND (%MAKE-POINTER DTP-LOCATIVE .NEW-RESTART-HANDLERS.)
		 (LET-IF ,COND ((DBG:*RESTART-HANDLERS* .NEW-RESTART-HANDLERS.))
		   . ,BODY)))))))))

(DEFMACRO ERROR-RESTART ((FLAVORS DESCRIPTION . ARGS) &BODY BODY)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (LET ((TAG (GENSYM)) (NAME (GENSYM)))
    `(PROG ,NAME ()
       (DECLARE (INVISIBLE-BLOCK T))
   ,TAG
       (CATCH-ERROR-RESTART (,FLAVORS ,DESCRIPTION . ,ARGS)
	 (RETURN-FROM ,NAME (PROGN . ,BODY)))
       (GO ,TAG))))

(DEFMACRO ERROR-RESTART-IF (COND (FLAVORS DESCRIPTION . ARGS) &BODY BODY)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (LET ((TAG (GENSYM)) (NAME (GENSYM)))
    `(PROG ,NAME ()
       (DECLARE (INVISIBLE-BLOCK T))
   ,TAG
       (CATCH-ERROR-RESTART-IF ,COND (,FLAVORS ,DESCRIPTION . ,ARGS)
	 (RETURN-FROM ,NAME (PROGN . ,BODY)))
       (GO ,TAG))))

(DEFMACRO ERROR-RESTART-LOOP ((FLAVORS DESCRIPTION . ARGS) &BODY BODY)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (LET ((TAG (GENSYM)))
    `(PROG () ,TAG
       (CATCH-ERROR-RESTART (,FLAVORS ,DESCRIPTION . ,ARGS) . ,BODY)
       (GO ,TAG))))

(DEFMACRO IGNORE-ERRORS (&BODY BODY)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(LET ((DBG:REPORT-IGNORED-ERRORS NIL))
     (WITH-STACK-LIST* (.NEW-BOUND-HANDLERS. 'DBG:IGNORE-ERRORS-HANDLER DBG:*BOUND-HANDLERS*)
       (CATCH (%MAKE-POINTER DTP-LOCATIVE .NEW-BOUND-HANDLERS.)
	 (VALUES (LET ((DBG:*BOUND-HANDLERS* .NEW-BOUND-HANDLERS.))
		   ,@BODY)
		 NIL)))))

(DEFMACRO CATCH-ERROR (FORM &OPTIONAL (PRINTFLAG T))
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(LET ((DBG:REPORT-IGNORED-ERRORS ,PRINTFLAG))
     (WITH-STACK-LIST* (.NEW-BOUND-HANDLERS. 'DBG:IGNORE-ERRORS-HANDLER DBG:*BOUND-HANDLERS*)
       (CATCH (%MAKE-POINTER DTP-LOCATIVE .NEW-BOUND-HANDLERS.)
	 (VALUES
	   (LET ((DBG:*BOUND-HANDLERS* .NEW-BOUND-HANDLERS.))
	     ,FORM)
	   NIL)))))

;; Analogous to CATCH-ERROR-RESTART, but runs FORM first
(defmacro dbg:catch-error-restart-command ((flavors description &rest args) form
					   &body body)
  (declare (compiler:do-not-record-macroexpansions)
	   (zwei:indentation 1 3 2 1))
  (dbg:error-restart-command-internal flavors description args form
				      body 'dbg:private-restart-command-handler))

(defun dbg:error-restart-command-internal (flavors description args form
					   body handler-flavor)
  (let ((description-var (gensym))
	(function-var (gensym))
	(closure-list (gensym))
	(function
	  ;; This function must never return NIL, because then the condition
	  ;; system thinks that nothing ever got run.
	  `(named-lambda user-form () ,form t)))
    (or (listp flavors) (setq flavors (list flavors)))
    (dolist (flavor flavors)
      (flavor:check-flavor-name flavor "condition"))
    `(cl:locally (declare (special dbg:.restart.description. dbg:.restart.function.))
       (with-stack-list (,description-var ,description ,@args)
	 (with-stack-list (,function-var #',function)
	   (with-stack-list (,closure-list
			     ',(make-instance handler-flavor :flavors flavors)
			     (variable-location dbg:.restart.description.)
			      (variable-location ,description-var)
			     (variable-location dbg:.restart.function.)
			      (variable-location ,function-var))
	     (with-stack-list* (.new-restart-handlers.
				 (%make-pointer #+3600 dtp-closure #+IMACH dtp-dynamic-closure
						,closure-list)
				 dbg:*restart-handlers*)
	       ;; Set up the catch BEFORE updating the real restart-handlers,
	       ;; since typing c-Abort during setup could cause a
	       ;; no-pending-catch error.
	       (catch (%make-pointer dtp-locative .new-restart-handlers.)
		 (let ((dbg:*restart-handlers* .new-restart-handlers.))
		   ,@body)))))))))

;; Analogous to ERROR-RESTART, but runs FORM first
(defmacro dbg:error-restart-command ((flavors description . args) form
				     &body body)
  (declare (compiler:do-not-record-macroexpansions)
	   (zwei:indentation 1 3 2 1))
  (let ((tag (gensym))
	(name (gensym)))
    `(prog ,name ()
       (declare (si:invisible-block t))
     ,tag
       (dbg:catch-error-restart-command (,flavors ,description ,@args)
	   ,form
	 (return-from ,name (progn ,@body)))
     (go ,tag))))

(defmacro dbg:with-debugger-special-command ((flavors description &rest args) form
					     &body body)
  (declare (compiler:do-not-record-macroexpansions)
	   (zwei:indentation 1 3 2 1))
  (dbg:error-restart-command-internal flavors description args form
				      body 'dbg:private-special-command-handler))

(DEFMACRO ERRSET (FORM &OPTIONAL (PRINTFLAG T))
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(CATCH-ERROR (LIST ,FORM) ,PRINTFLAG))

(DEFMACRO SIGNAL-PROCEED-CASE ((VARLIST . SIGNAL-ARGS) &BODY CLAUSES)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (LET ((GENSYM (GENSYM))
	(NILP))
    `(MULTIPLE-VALUE-BIND (,GENSYM . ,VARLIST)
	 (SIGNAL ,@SIGNAL-ARGS
		 ':PROCEED-TYPES
		 ',(LOOP FOR CLAUSE IN CLAUSES
			 WHEN (MEMBER (CAR CLAUSE) '(NIL (NIL)))
			   DO (SETQ NILP T)
			 ELSE WHEN (ATOM (CAR CLAUSE))
			   COLLECT (CAR CLAUSE)
			 ELSE APPEND (CAR CLAUSE)))
       (SELECTQ ,GENSYM
	 . ,(LOOP FOR L ON CLAUSES
		  WHEN (OR (NOT NILP) (CDR L))
		    WHEN (LISTP (CAAR L))
		      COLLECT (CAR L)
		    ELSE COLLECT `((,(CAAR L)) . ,(CDAR L))
		  ;; Assume that all the proceed types adhere to the specified protocol.
		  ELSE COLLECT `(OTHERWISE . ,(CDAR L)))))))

(DEFMACRO CHECK-ARG (ARG-NAME PREDICATE-OR-FORM TYPE-STRING)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(COMPILER:%ERROR-UNLESS-RETRY ,(IF (ATOM PREDICATE-OR-FORM)
				      `(,PREDICATE-OR-FORM ,ARG-NAME)
				      PREDICATE-OR-FORM)
     (SETQ ,ARG-NAME (DBG:CHECK-ARG-1 ',ARG-NAME ,ARG-NAME ,TYPE-STRING))))

(DEFMACRO CHECK-ARG-TYPE (ARG-NAME TYPE &OPTIONAL TYPE-STRING)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(COMPILER:%ERROR-UNLESS-RETRY (TYPEP ,ARG-NAME ',TYPE)
     (SETQ ,ARG-NAME (DBG:CHECK-ARG-1 ',ARG-NAME ,ARG-NAME
				      ',(OR TYPE-STRING (GET TYPE 'TYPE-NAME) TYPE)))))

(DEFMACRO ARGUMENT-TYPECASE (ARG-NAME &BODY CLAUSES)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(PROG T () LOOP
     (RETURN-FROM T
       (TYPECASE ,ARG-NAME
	 ,@CLAUSES
	 (OTHERWISE (SETQ ,ARG-NAME (DBG:ARGUMENT-TYPECASE-1
				      ',ARG-NAME ,ARG-NAME
				      ',(LOOP FOR (X) IN CLAUSES
					      WHEN (LISTP X) APPEND X ELSE COLLECT X)))
		    (GO LOOP))))))

;; Bind the lockedness of a package
(DEFMACRO WITH-PACKAGE-LOCK (PKG LOCK-VALUE &BODY BODY)
  `(LETF (((PKG-LOCKED ,PKG) ,LOCK-VALUE))
     . ,BODY))

;; Obsolete name for STORE-CONDITIONAL
(DEFMACRO %STORE-CONDITIONAL (POINTER OLD NEW)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(STORE-CONDITIONAL ,POINTER ,OLD ,NEW))

;; Temporarily prevent GC from changing %POINTER of objects
(DEFMACRO INHIBIT-GC-FLIPS (&BODY BODY)
  (LET ((INCREMENTED-P-VAR (GENSYM)))
    `(LET ((,INCREMENTED-P-VAR NIL))
       (CHECK-FOR-GC-WAITING-TO-FLIP)
       (UNWIND-PROTECT
	   (LET ((NESTED-INHIBIT-GC-FLIPS-FLAG
		   (WITHOUT-INTERRUPTS
		     (INCF GC-FLIP-INHIBIT)
		     (SETQ ,INCREMENTED-P-VAR T)
		     T)))
	     . ,BODY)
	 (WITHOUT-INTERRUPTS
	   (IF ,INCREMENTED-P-VAR 
	       (IF (MINUSP (DECF GC-FLIP-INHIBIT))
		   (SETQ GC-FLIP-INHIBIT 0))))))))

;; Temporarily prevent GC from reclaiming oldspace.
(DEFMACRO INHIBIT-OLDSPACE-RECLAMATION (&BODY BODY)
  (LET ((INCREMENTED-P-VAR (GENSYM)))
    `(LET ((,INCREMENTED-P-VAR NIL))
       (UNWIND-PROTECT
	   (PROGN (WITHOUT-INTERRUPTS (SETQ ,INCREMENTED-P-VAR
					    (INCF GC-RECLAIM-OLDSPACE-INHIBIT)))
		  . ,BODY)
	 (WITHOUT-INTERRUPTS
	   (IF ,INCREMENTED-P-VAR 
	       (IF (MINUSP (DECF GC-RECLAIM-OLDSPACE-INHIBIT))
		   (SETQ GC-RECLAIM-OLDSPACE-INHIBIT 0))))))))

;; This prevents consing properly only if interrupts are inhibited.
(DEFMACRO INHIBIT-CONSING (&BODY BODY)
  `(LET ((*INHIBIT-CONSING-FLAG* T))
     ;; On the I machine *INHIBIT-CONSING-FLAG* is not in A-memory, and only
     ;; affects the escape routines.  So in order it to be effective we have to
     ;; ensure that the allocation instructions will trap by clearing the caches.
     #+IMach (CLEAR-CONS-CACHES)
     . ,BODY))

(DEFVAR-RESETTABLE *INHIBIT-LENGTHY-BACKGROUND-UPDATES* 0)
(DEFVAR *POSTPONED-LENGTHY-BACKGROUND-UPDATES* NIL)

(DEFMACRO INHIBIT-LENGTHY-BACKGROUND-UPDATES (&BODY BODY)
  (LET ((INCREMENTED-P-VAR (GENSYM)))
    `(LET ((,INCREMENTED-P-VAR NIL))
       (UNWIND-PROTECT
	   (PROGN
	     (WITHOUT-INTERRUPTS
	       (INCF *INHIBIT-LENGTHY-BACKGROUND-UPDATES*)
	       (SETQ ,INCREMENTED-P-VAR T))
	     ,@BODY)
	 (WITHOUT-INTERRUPTS
	   (WHEN ,INCREMENTED-P-VAR 
	     (WHEN (MINUSP (DECF *INHIBIT-LENGTHY-BACKGROUND-UPDATES*))
	       (SETQ *INHIBIT-LENGTHY-BACKGROUND-UPDATES* 0))))
	 ;; Run the postponed forms, avoiding race conditions I hope
	 (WHEN (ZEROP *INHIBIT-LENGTHY-BACKGROUND-UPDATES*)
	   (MAPC 'EVAL *POSTPONED-LENGTHY-BACKGROUND-UPDATES*))))))

(DEFMACRO DEFINE-POSTPONED-LENGTHY-BACKGROUND-UPDATE (FORM)
  (DECLARE (ZWEI:INDENTATION 0 1))
  `(CL:PUSHNEW ',FORM *POSTPONED-LENGTHY-BACKGROUND-UPDATES*
	       :TEST #'EQUAL))


;; Macros related to the input editor

;; Macro for specifying options to the input editor.  Options are collected dynamically in the
;; special variable *INPUT-EDITOR-OPTIONS*.

(DEFMACRO WITH-INPUT-EDITING-OPTIONS (OPTIONS &BODY BODY)
  (DECLARE (ZWEI:INDENTATION 0 3 1 1))
  (CHECK-ARG OPTIONS
	     (AND (CL:LISTP OPTIONS)
		  (EVERY OPTIONS #'LISTP))
	     "a list of input editor options")
  (LOOP FOR OPTION IN OPTIONS
	AS OPTION-NAME = (IF (SYMBOLP (CAR OPTION)) (CAR OPTION) (CAAR OPTION))
	AS OVERRIDE-P = (AND (LISTP (CAR OPTION)) (MEMQ :OVERRIDE (CDAR OPTION)))
	AS OPTION-ARGS = (CDR OPTION)
	DO
    (SETQ BODY
	  (IF (AND (CL:CONSTANTP OPTION-NAME)
		   (EVERY OPTION-ARGS #'CL:CONSTANTP))
	      `((STACK-LET ((*INPUT-EDITOR-OPTIONS*
			      (CONS '(,(EVAL OPTION-NAME) . ,(MAPCAR #'EVAL OPTION-ARGS))
				    *INPUT-EDITOR-OPTIONS*)))
		  ,@(UNLESS OVERRIDE-P
		      `((IF (ASSQ ,(EVAL OPTION-NAME) (CDR *INPUT-EDITOR-OPTIONS*))
			    (POP *INPUT-EDITOR-OPTIONS*))))
		  . ,BODY))
	      `((STACK-LET ((*INPUT-EDITOR-OPTIONS*
			      (CONS (LIST ,OPTION-NAME . ,OPTION-ARGS)
				    *INPUT-EDITOR-OPTIONS*)))
		  ,@(UNLESS OVERRIDE-P
		      `((IF (ASSQ ,(IF (CL:CONSTANTP OPTION-NAME)
				       (EVAL OPTION-NAME)
				       '(CAAR *INPUT-EDITOR-OPTIONS*))
				  (CDR *INPUT-EDITOR-OPTIONS*))
			    (POP *INPUT-EDITOR-OPTIONS*))))
		  . ,BODY)))))
  (IF (CDR BODY) `(PROGN . ,BODY) (CAR BODY)))

(DEFMACRO WITH-INPUT-EDITING-OPTIONS-IF (COND OPTIONS &BODY BODY)
  (DECLARE (ZWEI:INDENTATION 0 3 2 1))
  `(LET ((.OLD-OPTIONS. *INPUT-EDITOR-OPTIONS*))
     (WITH-INPUT-EDITING-OPTIONS ,OPTIONS
       (UNLESS ,COND
	 (SETQ *INPUT-EDITOR-OPTIONS* .OLD-OPTIONS.))
       . ,BODY)))

(DEFUN COMBINE-INPUT-EDITING-OPTIONS-LISTS (NEW-LIST OLD-LIST)
  (LOOP FOR OPTION IN NEW-LIST
	AS OPTION-NAME = (IF (SYMBOLP (CAR OPTION)) (CAR OPTION) (CAAR OPTION))
	AS OVERRIDE-P = (AND (LISTP (CAR OPTION)) (MEMQ :OVERRIDE (CDAR OPTION)))
	AS OPTION-ARGS = (CDR OPTION)
	WHEN (OR OVERRIDE-P (NOT (ASSQ OPTION-NAME OLD-LIST)))
	  COLLECT
	    (IF (SYMBOLP (CAR OPTION))
		OPTION
		`(,OPTION-NAME ,@OPTION-ARGS))
	    INTO NEW-ITEMS
	FINALLY (RETURN (NCONC NEW-ITEMS OLD-LIST))))

(DEFMACRO WITH-INPUT-EDITING-OPTIONS-LIST (OPTIONS-LIST &BODY BODY)
  `(LET ((*INPUT-EDITOR-OPTIONS*
	   (COMBINE-INPUT-EDITING-OPTIONS-LISTS ,OPTIONS-LIST *INPUT-EDITOR-OPTIONS*)))
     . ,BODY))

;; STREAM is the stream from which input will be read within the body.
;;   If the body reads only from STANDARD-INPUT, then this may be omitted.  NIL may also be
;;   used in this position to mean STANDARD-INPUT, if a keyword is being specified.
;; KEYWORD can be NIL, :LINE, :LINE-ACTIVATION, or :END-ACTIVATION.
;;   :END-ACTIVATION means to set up End as an activation character.
;;   :LINE-ACTIVATION means to set up the activation characters for READLINE.
;;   :LINE implies :LINE-ACTIVATION, and also to :TYO a newline before returning.

(DEFMACRO WITH-INPUT-EDITING ((&OPTIONAL STREAM KEYWORD) &BODY BODY)
  `(WITH-INPUT-EDITING-INTERNAL ,STREAM
				(LAMBDA () . ,BODY)
				,(SELECTQ KEYWORD
				   (:END-ACTIVATION
				    ''(#\END))
				   ((:LINE :LINE-ACTIVATION)
				    ''(#\END #\RETURN #\LINE)))
				,(EQ KEYWORD :LINE)))

;;; Use this instead of WITH-INPUT-EDITING to allow either the Genera or the 
;;; CLIM input editor to be used.
(DEFMACRO WITH-CLIM-COMPATIBLE-INPUT-EDITING ((STREAM) &BODY BODY)
  `(WITH-CLIM-COMPATIBLE-INPUT-EDITING-INTERNAL ,STREAM
						(LAMBDA (,STREAM) . ,BODY)))

;; A macro for use with read functions.  Encapsulate an error of flavor ERROR-FLAVOR in
;; one of flavor PARSE-ERROR.  This probably should be using something more similar to
;; ENCAPSULATED-READ-ERROR.

(DEFMACRO WITH-PARSE-FERROR ((ERROR-FLAVOR) &BODY BODY)
  `(CONDITION-CASE (.ERROR.)
       ,(IF (CDR BODY) `(PROGN . ,BODY) (CAR BODY))
     (,ERROR-FLAVOR
      (PARSE-FERROR "~A" .ERROR.))))

(DEFMACRO WITH-PARSE-FERROR-IF (COND (ERROR-FLAVOR) &BODY BODY)
  `(CONDITION-CASE-IF ,COND (.ERROR.)
       ,(IF (CDR BODY) `(PROGN . ,BODY) (CAR BODY))
     (,ERROR-FLAVOR
      (PARSE-FERROR "~A" .ERROR.))))

;;; Adds an entry to an alist of the form ((<key> . <elements>) (<key> . <elements>)).
;;; Takes a <key> and an <element> as arguments. If there is no <key> sublist in the
;;; alist it adds one with <element> as its only element. If there is a <key> sublist
;;; in the alist it adds <element> to that sublist unless it is already present. By
;;; default ASSOC is used for the alist lookup and MEMBER is used for deciding if an
;;; element is present. Supplying a PRESENT-P argument of NIL will disable the check
;;; to see if <element> is present in a sublist before adding it.

(DEFMACRO ADD-TO-ALIST (ALIST KEY ELEMENT &OPTIONAL (ALIST-FN 'ASSOC) (PRESENT-P 'MEMBER))
  `(LET ((ALIST-ENTRY (,ALIST-FN ,KEY ,ALIST)))
     (IF ALIST-ENTRY
	 (UNLESS ,(IF PRESENT-P `(,PRESENT-P ,ELEMENT (CDR ALIST-ENTRY)) NIL)
	   (NCONC ALIST-ENTRY (NCONS ,ELEMENT)))
	 (SETF ,ALIST (NCONC  ,ALIST `((,,KEY ,,ELEMENT)))))))

;;; Code which LOADs a file (e.g. READFILE-INTERNAL BIN-LOAD-FILE-INTERNAL) should do so
;;; inside of a LOADING-FILE special form. The first argument is the generic-pathname of
;;; the file being loaded, the body should be the code that actually reads and evaluates
;;; the forms from the file.

(DEFMACRO LOADING-FILE (GENERIC-PLIST &BODY BODY)
  `(LET* ((FDEFINE-FILE-DEFINITIONS NIL)
	  (FDEFINE-FILE-DISAPPEARING-DEFINITIONS (GET ,GENERIC-PLIST 'SI:DEFINITIONS))
	  (FDEFINE-FILE-APPEARING-DEFINITIONS NIL))
     (STANDARD-VALUE-LET ((PACKAGE PACKAGE))
       (UNWIND-PROTECT
	   (PROGN . ,BODY)
	 (PUTPROP ,GENERIC-PLIST FDEFINE-FILE-DEFINITIONS 'SI:DEFINITIONS)
	 ;; Handle any warnings about appearing and disappearing definitions is a separate
	 ;; function so that it will be easy for us to change our mind about how to do this
	 ;; in patch files.
	 (LOADING-FILE-HANDLE-DEFINITION-CHANGES FDEFINE-FILE-PATHNAME
						 FDEFINE-FILE-DEFINITIONS
						 FDEFINE-FILE-DISAPPEARING-DEFINITIONS
						 FDEFINE-FILE-APPEARING-DEFINITIONS)))))

;; For functions which want to accept either a thing or a list of things as an argument.
;; A thing cannot be a list or NIL.

(DEFMACRO COERCE-TO-LIST (VARIABLE &BODY BODY)
  `(LET ((.ORIGINAL-VALUE. ,VARIABLE))
     (WITH-STACK-LIST (,VARIABLE ,VARIABLE)
       (IF (OR (NULL .ORIGINAL-VALUE.) (LISTP .ORIGINAL-VALUE.))
	   (SETQ ,VARIABLE .ORIGINAL-VALUE.))
       . ,BODY)))

(DEFMACRO WITH-PROGRESS-REPORT ((TEXT) &BODY BODY)
  `(FLET ((.BODY. () ,@BODY))
     (PROGRESS-REPORT-FUNCTION ,TEXT #'.BODY.)))

(DEFMACRO WITH-PROGRESS-REPORT-IF (CONDITION (TEXT) &BODY BODY)
  `(FLET ((.BODY. () ,@BODY))
     (IF ,CONDITION (PROGRESS-REPORT-FUNCTION ,TEXT #'.BODY.) (.BODY.))))

;;; Is this obsolete?
(DEFMACRO WITH-PROCESS-LOCK ((LOCATIVE-POINTER &OPTIONAL (WHOSTATE "Lock")
					       (LOCK-VALUE `CURRENT-PROCESS))
			     &BODY BODY &ENVIRONMENT ENV)
  (ONCE-ONLY (LOCATIVE-POINTER LOCK-VALUE &ENVIRONMENT ENV)
    `(SI:WITH-LOCK-HELD ((LOCATION-CONTENTS ,LOCATIVE-POINTER)
			 :WHOSTATE ,WHOSTATE :LOCK-VALUE ,LOCK-VALUE)
       ,@BODY)))

;; STACK-LET and STACK-LET* are macros which provide an alternate syntax for constructing
;; stack lists.  The syntax of these macros is identical to LET and LET*, respectively,
;; however expressions in the LET clauses which use LIST and LIST* cause lists to be
;; constructed on the stack rather than in the heap.  For example, the form:
;;
;;          		(STACK-LET ((A (LIST X Y Z))) BODY)
;; expands into:
;;			(WITH-STACK-LIST (A X Y Z) BODY)
;;
;; This syntax is convenient for complex expressions involving nested lists, such as:
;;
;;			(STACK-LET ((A `((:FOO ,FOO) (:BAR ,BAR)))) BODY)
;;
;; which expands into three nested WITH-STACK-LIST forms.  If an expression in a LET
;; clause is of the form:
;;				(LIST (REVERSE (LIST ...)))
;;
;; only the outermost LIST is constructed on the stack.  No codewalking is performed,
;; the other major effect of this being that constructors of a DEFSTRUCT which
;; is implemented as an array or an array leader don't get optimally expanded when
;; initial slot values are specified.  Such expanders look like this:
;;   (LAMBDA (#:G1234) (ASET val #:G1234 sub) ... (ASET val #:G1234 sub) #:G1234)
;; Notice that if you include :AREA or :ADJUSTABLE as an argument to MAKE-ARRAY,
;; WITH-STACK-ARRAY will catch it later

;; For additional examples, try c-sh-M on the commented forms below.
;; Format is (thing min-args max-args constructor)
(EVAL-WHEN (COMPILE LOAD EVAL)
(DEFCONST *STACK-LET-OPERATIONS*
	  '((CONS 2 2 WITH-STACK-LIST*)
	    (NCONS 1 1 WITH-STACK-NCONS)
	    (LIST 0 NIL WITH-STACK-LIST)
	    (LIST* 2 NIL WITH-STACK-LIST*)
	    (XR-BQ-CONS 2 2 WITH-STACK-LIST*)
	    (XR-BQ-LIST 0 NIL WITH-STACK-LIST)
	    (XR-BQ-LIST* 2 NIL WITH-STACK-LIST*)
	    (MAKE-ARRAY 1 NIL WITH-STACK-ARRAY)
	    (CL:MAKE-ARRAY 1 NIL WITH-STACK-ARRAY)
	    (MAKE-RASTER-ARRAY 2 NIL WITH-RASTER-STACK-ARRAY)
	    (SCL:MAKE-RASTER-ARRAY 2 NIL WITH-RASTER-STACK-ARRAY)
	    (CL:VECTOR 0 NIL WITH-STACK-VECTOR)
	    (MAKE-INSTANCE 1 NIL WITH-STACK-INSTANCE)
	    ;; Forward reference to CLOS, which isn't part of System
	    ;; but is reliably available in all distributed products. -kmp 20-Aug-92
	    (CLOS:MAKE-INSTANCE 1 NIL CLOS-INTERNALS::WITH-STACK-INSTANCE)
	    (CL:MAKE-HASH-TABLE 0 NIL CLI::WITH-STACK-TABLE)
	    (MULTIPLE-VALUE-LIST 1 1 WITH-STACK-MULTIPLE-VALUE-LIST)
	    (SYS:MAKE-LEXICAL-CLOSURE 2 2 WITH-STACK-LEXICAL-CLOSURE)
	    ))

;; Construct a new body which binds VARIABLE to VALUE.  If PARALLEL? is T, then BODY contains
;; an automatically generated LET or WITH-STACK-LIST form constructed by CONSTRUCT-STACK-LET.
;; If it is a LET, then this binding can be added to the end of its bindings.  If VARIABLE is
;; a gensym, and the same gensym appears as the value of some other clause, then merge the
;; two.
(DEFUN CONSTRUCT-LET (VARIABLE VALUE BODY PARALLEL?)
  (IF (OR (NOT PARALLEL?)
	  (NEQ (CAAR BODY) 'LET))
      `((LET ((,VARIABLE ,VALUE)) . ,BODY))
      (LET ((CLAUSES NIL)
	    (MERGED? NIL))
	(DOLIST (CLAUSE (CADAR BODY))
	  (COND ((AND (LISTP CLAUSE)
		      (SYMBOLP (CADR CLAUSE))
		      (NULL (SYMBOL-PACKAGE (CADR CLAUSE)))
		      (EQ (CADR CLAUSE) VARIABLE))
		 (PUSH (LIST (CAR CLAUSE) VALUE) CLAUSES)
		 (SETQ MERGED? T))
		(T (PUSH CLAUSE CLAUSES))))
	(UNLESS MERGED?
	  (PUSH (LIST VARIABLE VALUE) CLAUSES))
	`((LET ,(REVERSE CLAUSES) . ,(CDDAR BODY))))))

;; Construct a new body which binds VARIABLE to VALUE, using a special stack constructor if
;; possible.  If BODY is just a single LET form, then add the binding to the end of its
;; bindings.  If the first form in BODY is a declaration, then wrap a LET around the body so
;; that the declaration will be seen.
(DEFUN CONSTRUCT-STACK-LET (VARIABLE VALUE BODY PARALLEL? ENV)
  (FLET ((RETURN-LET ()
	   (RETURN-FROM CONSTRUCT-STACK-LET
	     (CONSTRUCT-LET VARIABLE VALUE BODY PARALLEL?))))
    (LET ((REAL-VALUE VALUE))
      (CL:LOOP
	 (WHEN (ATOM REAL-VALUE) (RETURN-LET))
	 (LET ((OPERATION (ASSQ (CAR REAL-VALUE) *STACK-LET-OPERATIONS*)))
	   (WHEN OPERATION
	     (DESTRUCTURING-BIND (MIN-ARGS MAX-ARGS CONSTRUCTOR) (CDR OPERATION)
	       (LET ((ELEMENTS (NCONS VARIABLE))
		     (LENGTH (LENGTH (CDR REAL-VALUE))))
		 (IF (< LENGTH MIN-ARGS)
		     (STACK-LET-ERROR "Too few arguments in ~S" VALUE))
		 (IF (AND MAX-ARGS (> LENGTH MAX-ARGS))
		     (STACK-LET-ERROR "Too many arguments in ~S" VALUE))
		 (SETQ BODY `((,CONSTRUCTOR ,ELEMENTS ,@BODY)))
		 (DOLIST (X (REVERSE (CDR REAL-VALUE)))
		   (IF (OR (ATOM X)
			   (NOT (ASSQ (CAR X) *STACK-LET-OPERATIONS*)))
		       (PUSH X (CDR ELEMENTS))
		       (LET ((GENSYM (GENSYM)))
			 (SETQ BODY (CONSTRUCT-STACK-LET GENSYM X BODY NIL ENV))
			 (PUSH GENSYM (CDR ELEMENTS)))))
		 (RETURN-FROM CONSTRUCT-STACK-LET
		   BODY)))))
	 (WHEN (EQ REAL-VALUE
		   (SETQ REAL-VALUE
			 (COMPILER:OPTIMIZE-FORM REAL-VALUE ENV
						 :DO-MACRO-EXPANSION T :DO-INLINE-FORMS T
						 :DO-FUNCTION-ARGS T)))
	   (RETURN-LET))))))

(DEFUN CONSTRUCT-STACK-LET-CLAUSE (CLAUSE BODY PARALLEL? ENV)
  (IF (SYMBOLP CLAUSE)
      (CONSTRUCT-LET CLAUSE NIL BODY PARALLEL?)
      (CONSTRUCT-STACK-LET (CAR CLAUSE) (CADR CLAUSE) BODY PARALLEL? ENV)))

(DEFUN CHECK-STACK-LET-CLAUSE (CLAUSE FORM-TYPE)
  (WHEN (OR (AND (ATOM CLAUSE)
		 (NOT (SYMBOLP CLAUSE)))
	    (AND (NOT (ATOM CLAUSE))
		 (OR (NOT (SYMBOLP (CAR CLAUSE)))
		     (CDDR CLAUSE))))
    (STACK-LET-ERROR "~S is not a valid ~A clause" CLAUSE FORM-TYPE)))

(DEFUN STACK-LET-ERROR (&REST FORMAT-ARGS)
  (LEXPR-FUNCALL #'COMPILER:WARN NIL FORMAT-ARGS)
  (THROW 'STACK-LET-ERROR NIL))
);End EVAL-WHEN

;; Like LET.  Binds bindings in parallel.
(DEFMACRO STACK-LET (BINDINGS &BODY BODY &ENVIRONMENT ENV)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (CATCH 'STACK-LET-ERROR
    (LET ((VARIABLES ())
	  (GENSYMS ()))
      (DOLIST (BINDING (BUTLAST BINDINGS))
	(CHECK-STACK-LET-CLAUSE BINDING "STACK-LET")
	(COND ((SYMBOLP BINDING)
	       (PUSH BINDING VARIABLES)
	       (PUSH NIL GENSYMS))
	      ((CL:CONSTANTP (CADR BINDING) ENV)
	       (PUSH (CAR BINDING) VARIABLES)
	       (PUSH (CADR BINDING) GENSYMS))
	      (T (PUSH (CAR BINDING) VARIABLES)
		 (PUSH (GENSYMBOL "STACK-LET-") GENSYMS))))
      (WHEN (CDR BINDINGS)
	(SETQ BODY
	      `((LET ,(LOOP FOR VARIABLE IN (REVERSE VARIABLES)
			    FOR GENSYM IN (REVERSE GENSYMS)
			    COLLECT (LIST VARIABLE GENSYM))
		  . ,BODY))))
      (SETQ BINDINGS (REVERSE BINDINGS))
      ;; No need to generate a gensym for the final binding.
      (CHECK-STACK-LET-CLAUSE (CAR BINDINGS) "STACK-LET")
      (SETQ BODY (CONSTRUCT-STACK-LET-CLAUSE (CAR BINDINGS) BODY (CDR BINDINGS) ENV))
      ;; Use gensyms for all bindings except the first.
      (LOOP FOR BINDING IN (CDR BINDINGS)
	    FOR GENSYM IN GENSYMS
	    DO
	(UNLESS (OR (SYMBOLP BINDING) (CL:CONSTANTP (CADR BINDING) ENV))
	  (SETQ BODY (CONSTRUCT-STACK-LET GENSYM (CADR BINDING) BODY T ENV))))
      (CAR BODY))))

;; Like LET*.  Binds bindings in sequence.
(DEFMACRO STACK-LET* (BINDINGS &BODY BODY &ENVIRONMENT ENV)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (CATCH 'STACK-LET-ERROR
    (DOLIST (BINDING (REVERSE BINDINGS))
      (CHECK-STACK-LET-CLAUSE BINDING "STACK-LET*")
      (SETQ BODY (CONSTRUCT-STACK-LET-CLAUSE BINDING BODY NIL ENV)))
    (CAR BODY)))

(DEFMACRO WITH-STACK-MULTIPLE-VALUE-LIST ((VAR MV-FORM) &BODY BODY)
  `(MULTIPLE-VALUE-CALL #'(LAMBDA (&REST ,VAR) ,@BODY)
			,MV-FORM))

(DEFMACRO WITH-STACK-NCONS ((VAR FORM) &BODY BODY)
  `(WITH-STACK-LIST* (,VAR ,FORM NIL) ,@BODY))

(DEFMACRO WITH-STACK-VECTOR ((VAR &REST ELEMENTS) &BODY BODY &ENVIRONMENT ENV)
  (MULTIPLE-VALUE-BIND (NIL FREE-VARS) (LT:ANNOTATE-FORM `(PROGN ,@ELEMENTS) NIL ENV)
    (IF (MEMBER VAR FREE-VARS)
	;; Have to generate more elaborate code to bind VAR at proper time
	(LET ((TEMP (GENSYM)))
	  `(WITH-STACK-ARRAY (,TEMP ,(LENGTH ELEMENTS))
	     ,@(LOOP FOR FORM IN ELEMENTS FOR INDEX FROM 0
		     COLLECT `(SETF (AREF ,TEMP ,INDEX) ,FORM))
	     (LET ((,VAR ,TEMP))
	       ,@BODY)))
	;; Normal case
	`(WITH-STACK-ARRAY (,VAR ,(LENGTH ELEMENTS))
	   ,@(LOOP FOR FORM IN ELEMENTS FOR INDEX FROM 0
		   COLLECT `(SETF (AREF ,VAR ,INDEX) ,FORM))
	   ,@BODY))))

(COMMENT 
  
  (STACK-LET ((A (LIST 1 2 3)))
    B1 B2 B3)

  (STACK-LET ((A (LIST 1 2 3)))
    (DECLARE)
    B1 B2 B3)

  (STACK-LET ((A (LIST A B C))
	      (B (LIST A B C))
	      (C (LIST A B C)))
    B1 B2 B3)

  (STACK-LET ((A (LIST A B C))
	      (B (+ A B C))
	      (C (LIST A B C)))
    B1 B2 B3)

  (STACK-LET ((A (LIST A B C))
	      (B (LIST A B C))
	      (C (+ A B C)))
    B1 B2 B3)

  (STACK-LET ((A (+ A B C))
	      (B (LIST A B C))
	      (C (+ A B C)))
    B1 B2 B3)

  (STACK-LET ((A (LIST A B C))
	      (B (+ A B C))
	      (C (+ A B C)))
    B1 B2 B3)

  (STACK-LET ((A (+ A B C))
	      (B (+ A B C))
	      (C (+ A B C)))
    B1 B2 B3)

  (STACK-LET ((A (LIST A B C D))
	      (B (+ A B C D))
	      (C (+ A B C D))
	      (D (LIST A B C D)))
    B1 B2 B3)

  (STACK-LET ((A (+ A B C D))
	      (B (LIST A B C D))
	      (C (+ A B C D))
	      (D (+ A B C D)))
    B1 B2 B3)

  (STACK-LET ((V1 (COMPUTE-V1))
	      (V2 `((,A) (,B)))
	      (V3 (COMPUTE-V3)))
    B1 B2 B3)

  (STACK-LET* ((V (LIST (LIST (F1)) (LIST (F2)))))
    B1 B2 B3)
  
  (STACK-LET* ((V (LIST (LIST (F1)) (LIST (F2)))))
    (DECLARE)
    B1 B2 B3)

  (STACK-LET* ((V0 1)
	       (V1 (LIST (LIST X1 X2)))
	       (V2 (LIST (LIST Y1 Y2)))
	       (V3 (LIST V1 V2))
	       (V4 1))
    B1 B2 B3)

  (STACK-LET (A B) FOO)

  (STACK-LET ((A (NCONS B))))

  ;; Don't use this if you want to look at the second value returned by TV:MENU-CHOOSE.

  (DEFUN CHOOSE (A B)
    (STACK-LET ((CHOICES `(("A" ,A) ("B" ,B))))
      (VALUES (TV:MENU-CHOOSE CHOICES))))

  (DEFUN YES-OR-NO (MESSAGE)
    (STACK-LET ((OPTIONS `(:CHOICES ,FORMAT:YES-OR-NO-P-CHOICES
			   :TYPE :READLINE
			   :BEEP T)))
      (FQUERY OPTIONS MESSAGE)))

  )

(DEFMACRO BREAK (&OPTIONAL TAG (CONDITIONAL T))
  `(WHEN ,CONDITIONAL
     (BREAK-INTERNAL ',TAG T)))



(DEFMACRO RETURN (&REST ARGS)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (DECLARE (ARGLIST &OPTIONAL RESULT))
  `(RETURN-FROM NIL ,@ARGS))

(COMPILER:MAKE-OBSOLETE RETURN-LIST "use (RETURN (VALUES-LIST ...)) instead.")
(DEFMACRO RETURN-LIST (FORM)
  `(RETURN (VALUES-LIST ,FORM)))

;;; I don't think anything uses this, but just in case...
(DEFMACRO COMPILER:RETURN-FROM-T (&REST VALUES)
  `(RETURN-FROM T ,@VALUES))

;;; Has been obsolete for a long time, but it's still in GLOBAL, so define it
(COMPILER:MAKE-OBSOLETE MULTIPLE-VALUE-RETURN "use (RETURN (VALUES ...)) instead.")
(DEFMACRO MULTIPLE-VALUE-RETURN (&REST VALUES)
  `(RETURN (VALUES ,@VALUES)))

;This can't go into SYSDF1, so put it here.
(COMPILER:MAKE-OBSOLETE ALPHABETIC-CASE-AFFECTS-STRING-COMPARISON
  "Character and string-comparison primitives no longer pay attention to this
variable.  Use CHAR= or CHAR-EQUAL, STRING= or STRING-EQUAL, STRING< or STRING-LESSP,
STRING-SEARCH or STRING-SEARCH-EXACT, as appropriate."
  DEFVAR)

(DEFMACRO VARIABLE-MAKUNBOUND (PLACE &OPTIONAL HINT)
  (WHEN (AND (SYMBOLP PLACE) (NULL HINT))
    (SETQ HINT `',PLACE))
  `(LOCATION-MAKUNBOUND (LOCF ,PLACE) ,HINT))

(DEFMACRO VARIABLE-BOUNDP (PLACE)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(LOCATION-BOUNDP (LOCF ,PLACE)))

(DEFMACRO FUNCTION-DEFINED-P (FSPEC)
  `(VARIABLE-BOUNDP #',FSPEC))

;; This is obolete now.
(DEFMACRO MAKUNBOUNDF (PLACE &OPTIONAL HINT)
  `(VARIABLE-MAKUNBOUND ,PLACE ,HINT))

;; This is obolete now.
(DEFMACRO BOUNDPF (PLACE)
  `(VARIABLE-BOUNDP ,PLACE))

(DEFPROP DEFINE-FUNCTION-SPEC-HANDLER "Function spec handler" DEFINITION-TYPE-NAME)

(DEFMACRO DEFINE-FUNCTION-SPEC-HANDLER
	  (SYMBOL (&REST ARGS)
	   &BODY BODY)
  `(PROGN
     (UNLESS (MEMQ ',SYMBOL *ALL-FUNCTION-SPEC-HANDLERS*)
       (PUSH ',SYMBOL *ALL-FUNCTION-SPEC-HANDLERS*))
     (RECORD-SOURCE-FILE-NAME ',SYMBOL 'DEFINE-FUNCTION-SPEC-HANDLER)
     (DEFUN (:PROPERTY ,SYMBOL FUNCTION-SPEC-HANDLER)
	    (,@ARGS)
       (DECLARE (SYS:FUNCTION-PARENT ,SYMBOL DEFINE-FUNCTION-SPEC-HANDLER))
       ,@BODY)))

(DEFPROP DEFINE-DERIVED-FUNCTION-TYPE "Derived function type" DEFINITION-TYPE-NAME)

(DEFMACRO DEFINE-DERIVED-FUNCTION-TYPE (NAME PROPERTY &OPTIONAL DEFINITION-SLOTS)
  `(PROGN (RECORD-SOURCE-FILE-NAME ',NAME 'DEFINE-DERIVED-FUNCTION-TYPE)
	  (CL:PUSHNEW ',NAME *DERIVED-FUNCTION-TYPES*)
	  (DEFPROP ,NAME ,PROPERTY DERIVED-FUNCTION-PROPERTY)
	  (CL:PUSHNEW ',NAME *ALL-FUNCTION-SPEC-HANDLERS*)
	  (DEFPROP ,NAME DERIVED-FUNCTION-SPEC-HANDLER FUNCTION-SPEC-HANDLER)
	  ,@(WHEN DEFINITION-SLOTS
	      `((DEFPROP ,NAME ,DEFINITION-SLOTS DERIVED-FUNCTION-CELL-TABLE-LENGTH)))))

(DEFUN ZWEI:SOME-PLIST (PLIST PROPERTIES)
  (DO ((PLIST PLIST (CDDR PLIST))
       (LIST NIL))
      ((NULL PLIST) (NREVERSE LIST))
    (COND ((MEMQ (CAR PLIST) PROPERTIES)
	   (PUSH (CAR PLIST) LIST)
	   (PUSH (CADR PLIST) LIST)))))

(DEFUN ZWEI:SOME-PLIST-NOT (PLIST PROPERTIES)
  (DO ((PLIST PLIST (CDDR PLIST))
       (LIST NIL))
      ((NULL PLIST) (NREVERSE LIST))
    (COND ((NOT (MEMQ (CAR PLIST) PROPERTIES))
	   (PUSH (CAR PLIST) LIST)
	   (PUSH (CADR PLIST) LIST)))))

;;; This wants to be a declare someday.
(DEFMACRO FLAVOR::DEFINE-MAKE-INSTANCE-FUNCTION
	  (NAME
	   &KEY
	   FLAVOR-NAME-CONSTANT
	   (FLAVOR-NAME-OFFSET 0)
	   (INIT-PLIST-OFFSET 1)
	   (FLAVOR-NAME-QUOTED T))
  "Declares a function, special form or macro to be a maker of instances.
:FLAVOR-NAME-OFFSET is the number of forms to skip after the car of the form to get to
the flavor name.  :INIT-PLIST-OFFSET is the number of forms to skip after the car to
find the init plist."
  `(PROGN
     (DEFUN (COMPILER:STYLE-CHECKER FLAVOR::MAKE-INSTANCE-FUNCTION ,NAME) (FORM)
       (DECLARE (SYS:FUNCTION-PARENT ,NAME FLAVOR::DEFINE-MAKE-INSTANCE-FUNCTION))
       "The NTH's in here get optimized out."
       (FLAVOR:CHECK-INIT-KEYWORDS
	 ,(COND (FLAVOR-NAME-CONSTANT)
		(FLAVOR-NAME-OFFSET
		 (IF FLAVOR-NAME-QUOTED
		     `(NTH (+ 1 ,FLAVOR-NAME-OFFSET) FORM)
		     `(QUOTE (NTH (+ 1 ,FLAVOR-NAME-OFFSET) FORM))))
		(T NIL))
	 ,(IF INIT-PLIST-OFFSET
	      `(NTHCDR (+ 1 ,INIT-PLIST-OFFSET) FORM)
	      NIL)))
     (SI:FUNCTION-SPEC-PUTPROP ',NAME `(
					:FLAVOR-NAME-OFFSET ,,FLAVOR-NAME-OFFSET
					:INIT-PLIST-OFFSET ,,INIT-PLIST-OFFSET
					:FLAVOR-NAME-CONSTANT ,,FLAVOR-NAME-CONSTANT
					:FLAVOR-NAME-QUOTED ,,FLAVOR-NAME-QUOTED)
			       'FLAVOR::MAKE-INSTANCE-FUNCTION-INFO)
     (RECORD-SOURCE-FILE-NAME ',NAME 'FLAVOR::DEFINE-MAKE-INSTANCE-FUNCTION)))



(DEFMACRO MULTIPLE-VALUE-FUNCALL-N (FUNCTION &BODY FORMS-AND-COUNTS)
  (COMPILER:MATCHP FUNCTION
    (('FUNCTION FUN)
     `(SYS:%MULTIPLE-VALUE-CALL-N ,FUN ,@FORMS-AND-COUNTS))
    (* `(SYS:%MULTIPLE-VALUE-CALL-N FUNCALL ,FUNCTION 1 ,@FORMS-AND-COUNTS))))

(DEFMACRO NET:IN-SECURE-SERVER-ENVIRONMENT (&BODY BODY)
  `(LET ((LMFS:*LOCAL-PRIVILEGE* NIL)
	 (LMFS:*ACCESS-GROUPS* NIL))
     (DECLARE (SPECIAL LMFS:*LOCAL-PRIVILEGE* LMFS:*ACCESS-GROUPS*))
     ,@BODY))

(DEFMACRO GLOBAL-VALUE (REFERENCE)
  `(LOCATION-CONTENTS (GLOBAL-CELL-LOCATION (LOCF ,REFERENCE))))

(DEFMACRO SETQ-GLOBALLY (&REST VARS-AND-VALS)
  (WHEN (ODDP (LENGTH VARS-AND-VALS)) (FERROR "Wrong number of arguments for SETQ-GLOBALLY."))
  `(PROGN ,@(LOOP FOR (VAR VAL) ON VARS-AND-VALS BY 'CDDR
		  COLLECT `(CL:SETF (GLOBAL-VALUE (SYMEVAL ',VAR)) ,VAL))))

;;;

(DEFMACRO %CURRENT-STACK-GROUP-METER-ENABLE-FLAG ()
  #+3600 `(LDB-TEST (DEFSTORAGE-FIELD-BYTE SG-METER-ENABLE)
		    %CURRENT-STACK-GROUP-STATUS-BITS)
  #+IMACH `(LDB-TEST %%CR.CALL-TRACE
		     (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER)))

;; Imach version in ISTACK.
#+3600
(DEFSUBST %SET-CURRENT-STACK-GROUP-METER-ENABLE-FLAG (FLAG)
  (IF FLAG (%METER-ON) (%METER-OFF))
  FLAG)

(CL:DEFSETF %CURRENT-STACK-GROUP-METER-ENABLE-FLAG %SET-CURRENT-STACK-GROUP-METER-ENABLE-FLAG)

(DEFMACRO WITH-METERING-DISABLED (&BODY BODY)
  (LET ((ENABLED-FLAG (MAKE-SYMBOL "ENABLED-FLAG")))
    `(LET ((,ENABLED-FLAG (%CURRENT-STACK-GROUP-METER-ENABLE-FLAG))
	   (METERING:*ENABLE-METERING-ON-FUNCTION-CALLS* NIL))
       (UNWIND-PROTECT
	   (PROGN (WHEN (AND #+IMACH ,ENABLED-FLAG)
		    (SETF (%CURRENT-STACK-GROUP-METER-ENABLE-FLAG) NIL))
		  ,@BODY)
	 (WHEN (AND ,ENABLED-FLAG
		    #+IMACH (NOT (%CURRENT-STACK-GROUP-METER-ENABLE-FLAG)))
	   (SETF (%CURRENT-STACK-GROUP-METER-ENABLE-FLAG) T))))))

;;;

;;; Macros for defining FS directions.

(DEFMACRO FS:DEFINE-OPEN-DIRECTION (DIRECTION-NAME DIRECTION-TYPE)
  "DIRECTION-TYPE must be :INPUT or :OUTPUT"
  (CL:CHECK-TYPE DIRECTION-TYPE (CL:MEMBER :INPUT :OUTPUT))
  `(WHEN (RECORD-SOURCE-FILE-NAME ',DIRECTION-NAME 'FS:DEFINE-OPEN-DIRECTION)
     (PUTPROP ',DIRECTION-NAME ,DIRECTION-TYPE 'FS:OPEN-DIRECTION-TYPE)))

(DEFPROP FS:DEFINE-OPEN-DIRECTION "FS:OPEN :DIRECTION value" SI:DEFINITION-TYPE-NAME)

;;;

(DEFMACRO WHEN-IN-INCREMENTAL-WHO-CALLS-MODE (&BODY BODY)
  `(WHEN (MEMQ *WHO-CALLS-MODE* '(:MAKING :ALL :NEW))
    ,@BODY))

(DEFMACRO STATUS (STATUS-FUNCTION &OPTIONAL (ITEM NIL ITEM-P))
  `(STATUS-INTERNAL ',STATUS-FUNCTION ,@(WHEN ITEM-P `(',ITEM))))

(DEFMACRO SSTATUS (STATUS-FUNCTION ITEM)
  `(SSTATUS-INTERNAL ',STATUS-FUNCTION ',ITEM))

(DEFMACRO WITH-REM-KEYWORDS ((NEW-LIST LIST KEYWORDS-TO-REMOVE) &BODY BODY)
  `(WITH-DATA-STACK
     (LET ((,NEW-LIST (REM-KEYWORDS-INTO-NEW-ARRAY ,LIST ,KEYWORDS-TO-REMOVE)))
       ,@BODY)))

;This is used in this file so must be at begining of file to win at cold-load time.
(DEFMACRO DEF (FUNCTION &REST DEFINING-FORMS)
  `(PROGN ,@DEFINING-FORMS ',FUNCTION))

(DEFMACRO DEFF (FUNCTION DEFINITION)
  `(PROGN
     (EVAL-WHEN (COMPILE)
       (COMPILER:FUNCTION-DEFINED ',FUNCTION))
     (FDEFINE ',FUNCTION ,DEFINITION T)))


;; Here for lack of a better place.

(DEFMACRO POOR-MAN/'S-WITH-COLLECTION ((&REST VARIABLES) &BODY BODY)
  (LET ((TAILS (LOOP REPEAT (LENGTH VARIABLES)
		     COLLECT (GENSYM))))
    `(MACROLET ,(LOOP FOR VARIABLE IN VARIABLES
		      FOR TAIL IN TAILS
		      COLLECT `(,(INTERN (STRING-APPEND "COLLECT-" VARIABLE)) (THING)
				(ONCE-ONLY (THING)
				  `(PROGN (SETF (CDR ,',TAIL) (NCONS ,THING))
					  (SETF ,',TAIL (CDR ,',TAIL))
					  ,THING))))
       (LET ,VARIABLES
	 (LET ,(LOOP FOR TAIL IN TAILS
		     FOR VARIABLE IN VARIABLES
		     COLLECT `(,TAIL (LOCF ,VARIABLE)))
	   . ,BODY)))))

(DEFMACRO WITH-UNBOUND-LOGIC-VARIABLES (VARIABLE-LIST &BODY BODY &ENVIRONMENT ENV)
  ;; execute body with lisp variables bound to unbound logic variables.
  (MULTIPLE-VALUE-BIND (DECLARATIONS REAL-BODY)
      (FIND-BODY-DECLARATIONS BODY ENV)
    `(LET ,VARIABLE-LIST
       (DECLARE (LOGIC-VARIABLE ,@VARIABLE-LIST))       ; ensure dereferencing
       ,@DECLARATIONS
       ,@(LOOP FOR VARIABLE IN VARIABLE-LIST
	       COLLECTING `(INITIALIZE-LOGIC-VARIABLE (VARIABLE-LOCATION ,VARIABLE)))
       NIL					;make sure we don't return one of the above
       ,@REAL-BODY)))

(DEFUN INITIALIZE-LOGIC-VARIABLE (LOCATION)
  ;; this does not work interpreted
  (%P-STORE-CONTENTS LOCATION (%MAKE-POINTER DTP-LOGIC-VARIABLE LOCATION)))

;; Obsolete defining forms, supported for compatibility.

(DEFPROP DEFWIREDFUN DEFUN ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFWIREDFUN-IN-PLACE DEFUN ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFWIREDSUBST DEFUN ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFWIREDSUBST-IN-PLACE DEFUN ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFWIREDVAR DEFVAR ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)

(DEFMACRO DEFWIREDFUN (FUNCTION ARGLIST &BODY BODY)
  `(DEFUN ,FUNCTION ,ARGLIST
     (DECLARE (WIRED-FUNCTION))
     . ,BODY))

(DEFMACRO DEFWIREDFUN-IN-PLACE (FUNCTION ARGLIST &BODY BODY)
  `(DEFUN ,FUNCTION ,ARGLIST
     (DECLARE (WIRED-FUNCTION) (PATCH-IN-PLACE))
     . ,BODY))

(DEFMACRO DEFWIREDSUBST (FUNCTION ARGLIST &BODY BODY)
  `(DEFSUBST ,FUNCTION ,ARGLIST
     (DECLARE (WIRED-FUNCTION))
     . ,BODY))

(DEFMACRO DEFWIREDSUBST-IN-PLACE (FUNCTION ARGLIST &BODY BODY)
  `(DEFSUBST ,FUNCTION ,ARGLIST
     (DECLARE (WIRED-FUNCTION) (PATCH-IN-PLACE))
     . ,BODY))

(DEFMACRO DEFWIREDVAR (&REST REST)
  `(DEFVAR-WIRED . ,REST))


;; Modern defining forms and declarations.

(DEFPROP DEFVAR-WIRED DEFVAR ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFVAR-SAFEGUARDED DEFVAR ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFVAR-UNSAFEGUARDED DEFVAR ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFPARAMETER-WIRED CL:DEFPARAMETER ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFPARAMETER-SAFEGUARDED CL:DEFPARAMETER ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)
(DEFPROP DEFPARAMETER-UNSAFEGUARDED CL:DEFPARAMETER ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)

(DEFMACRO DEFVAR-WIRED (VAR &REST ARGS)
  `(PROGN (DECLARE-STORAGE-CATEGORY :VARIABLE ,VAR :WIRED)
	  (DEFVAR ,VAR . ,ARGS)))
	 
(DEFMACRO DEFVAR-SAFEGUARDED (VAR &REST ARGS)
  `(PROGN (DECLARE-STORAGE-CATEGORY :VARIABLE ,VAR :SAFEGUARDED)
	  (DEFVAR ,VAR . ,ARGS)))
	 
(DEFMACRO DEFVAR-UNSAFEGUARDED (VAR &REST ARGS)
  `(PROGN (DECLARE-STORAGE-CATEGORY :VARIABLE ,VAR :UNSAFEGUARDED)
	  (DEFVAR ,VAR . ,ARGS)))

(DEFMACRO DEFPARAMETER-WIRED (VAR &REST ARGS)
  `(PROGN (DECLARE-STORAGE-CATEGORY :VARIABLE ,VAR :WIRED)
	  (CL:DEFPARAMETER ,VAR . ,ARGS)))
	 
(DEFMACRO DEFPARAMETER-SAFEGUARDED (VAR &REST ARGS)
  `(PROGN (DECLARE-STORAGE-CATEGORY :VARIABLE ,VAR :SAFEGUARDED)
	  (CL:DEFPARAMETER ,VAR . ,ARGS)))
	 
(DEFMACRO DEFPARAMETER-UNSAFEGUARDED (VAR &REST ARGS)
  `(PROGN (DECLARE-STORAGE-CATEGORY :VARIABLE ,VAR :UNSAFEGUARDED)
	  (CL:DEFPARAMETER ,VAR . ,ARGS)))
