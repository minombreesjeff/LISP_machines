;;; -*- Base: 8; Mode: Lisp; Package: SYSTEM-INTERNALS; Lowercase: True -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>


;;; See DEFS in STRUCT-DEFS.LISP.

;;; This program is no longer maintained in several places.
;;; For historical information, see the end.

(defun defstruct-inline-p (description type name)
  (let ((inlines (defstruct-description-inline)))
    (or (memq type inlines)
	(member name inlines))))

(defun defstruct-inline-proclamation (description type name)
  `(cl:proclaim '(,(if (defstruct-inline-p description type name)
		       'cl:inline
		       'cl:notinline)
		  ,name)))

;; (DEFSTRUCT (<name> . <options>) . <slots>) or (DEFSTRUCT <name> . <slots>)
;;
;; <options> is of the form (<option> <option> (<option> <val>) ...)
;;
;; <slots> is of the form (<slot> (<slot> <initial-value>) ...)
;;
;; Options:
;;   :TYPE defaults to HUNK
;;   :CONSTRUCTOR defaults to "MAKE-<name>"
;;   :DEFAULT-POINTER defaults to empty (if no <val> given defaults to "<name>")
;;   :CONC-NAME defaults to empty (if no <val> given defaults to "<name>-")
;;   :SIZE-SYMBOL defaults to empty (if no <val> given defaults to "<name>-SIZE")
;;   :SIZE-MACRO defaults to empty (if no <val> given defaults to "<name>-SIZE")
;;   :ALTERANT defaults to "ALTER-<name>"
;;   :BUT-FIRST must have a <val> given
;;   :INCLUDE must have a <val> given
;;   :PROPERTY (:property foo bar) gives the structure a foo
;;     property of bar.  (:property foo) gives a foo property of T.
;;   :INITIAL-OFFSET can cause defstruct to skip over that many slots.
;;   :NAMED takes no value.  Tries to make the structure a named type.
;;   :CALLABLE-ACCESSORS defaults to true on the LispMachine and NIL.  False
;;     elsewhere. 
;;   :EVAL-WHEN defaults to (eval compile load).  <val> must be given.
;;   :PREDICATE defaults to empty (if no <val> given defaults
;;     to "<name>-P").  Generates a predicate if possible.
;;   :COPIER defaults to empty (if no <val> given defaults to
;;     "COPY-<name>").  Generates a function to copy this structure.
;;   :PRINT (:print "#<spaceship at ~S by ~S>" (x-pos spaceship)
;;     (y-pos spaceship))  The name of the structure is used as
;;     the variable.
;;   :EXPORT defaults to exporting all generated accessors.  Permissible
;;     values are :ACCESSORS, :ALTERANT, :CONSTRUCTOR, :COPIER, :PREDICATE,
;;     :SIZE-MACRO, :SIZE-SYMBOL, or the name of a slot.  For example,
;;     (:EXPORT :CONSTRUCTOR x-pos y-pos) exports the constructor macro,
;;     spaceship-x-pos, and spaceship-y-pos from the package in which the
;;     defstruct for spaceship is read.
;;   :INLINE defaults to compiling accessors, constructors, and predicates inline.
;;     Permissible values are :ACCESSORS, :CONSTRUCTOR, :COPIER, :PREDICATE,
;;     or the name of a slot.  For example, (:INLINE :CONSTRUCTOR x-pos y-pos)
;;     causes the constructor function, spaceship-x-pos, and spaceship-y-pos to be compiled
;      in line.
;;   <type> any type name can be used without a <val> instead of
;;     saying (:TYPE <type>) 
;;   <other> any symbol with a non-nil :defstruct-option property.  You say
;;     (<other> <val>) and the effect is that of (:property <other> <val>)
;;
;; Symbol properties used:
;;   DEFSTRUCT-TYPE-DESCRIPTION each type has one, it is a type-description.
;;   DEFSTRUCT-NAME each constructor, alterant and size macro
;;     has one, it is a name. 
;;   DEFSTRUCT-DESCRIPTION each name has one, it is a description (see below).
;;   DEFSTRUCT-SLOT each accesor has one, it is of the form: (<name> . <slot>)
;;   :DEFSTRUCT-OPTION if a symbol FOO has this property then it can be used as
;;     an option giving the structure a FOO property of the value (or T).

(defprop defstruct "Structure" definition-type-name)

;;;The order of forms returned by defstruct is sometimes critical.  Keep this
;;;in mind when munging this code:
(defmacro defstruct (options &body items)
  (let* ((description (defstruct-parse-options options))
	 (type-description (get (defstruct-description-type)
				'defstruct-type-description))
	 (name (defstruct-description-name))
	 (new-slots (defstruct-parse-items items description))
	 (exports nil)
	 (returns nil))
    ;;This must be last, since to compile it might require that the structure
    ;;already be operable:
    (cond ((defstruct-description-print)
	   (push (defstruct-define-printer name (defstruct-description-print))
		 returns)))
    ;;Keep this as close to last as possible:
    (cond ((defstruct-type-description-defstruct-expander)
	   (setq returns (append (funcall (defstruct-type-description-defstruct-expander)
					  description)
				 returns))))
    (let ((alterant (defstruct-description-alterant))
	  (size-macro (defstruct-description-size-macro))
	  (size-symbol (defstruct-description-size-symbol))
	  (predicate (defstruct-description-predicate))
	  (copier (defstruct-description-copier)))
      (cond (predicate
	     (push (funcall (or (defstruct-type-description-predicate)
				(defstruct-error
				  "This defstruct type cannot produce a predicate"
				  (defstruct-description-type) 'in name))
			    description
			    predicate)
		   returns)
	     (push (defstruct-inline-proclamation description :predicate predicate)
		   returns)
	     (push `(:predicate ,predicate ,(symbol-package predicate)) exports)))
      (cond (copier
	     (push
	       (let ((copy-fun (defstruct-type-description-copier)))
		 (cond (copy-fun
			(funcall copy-fun description copier))
		       ((not (= 1 (defstruct-type-description-ref-no-args)))
			(defstruct-error
			  "This defstruct type cannot produce a copying function"
			  (defstruct-description-type) 'in name))
		       (t (do ((i (1- (defstruct-description-size)) (1- i))
			       (l nil (cons (cons i
						  (funcall
						    (defstruct-type-description-ref-expander)
						    i description 'x))
					    l)))
			      ((< i 0)
			       `(defun ,copier (x)
				  (declare (sys:function-parent ,name defstruct))
				  ,(invoke-defstruct-constructor-expander
				     description type-description l nil)))))))
	       returns)
	     (push (defstruct-inline-proclamation description :copier copier)
		   returns)
	     (push `(:copier ,copier ,(symbol-package copier)) exports)))
      (cond (alterant
	     (defstruct-put-macro alterant 'defstruct-expand-alter-macro)
	     (defstruct-putprop alterant name 'defstruct-name)
	     (push `(:alterant ,alterant ,(symbol-package alterant)) exports)))
      (cond (size-macro
	     (defstruct-put-macro size-macro 'defstruct-expand-size-macro)
	     (defstruct-putprop size-macro name 'defstruct-name)
	     (push `(:size-macro ,size-macro ,(symbol-package size-macro)) exports)))
      (cond (size-symbol
	     (push `(defconst ,size-symbol
			      ,(+ (defstruct-description-size)
				  (defstruct-type-description-overhead)))
		   returns)
	     (push `(:size-symbol ,size-symbol ,(symbol-package size-symbol)) exports)))
      (defstruct-putprop name description 'defstruct-description)
      (do ((cs (defstruct-description-constructors) (cdr cs)))
	  ((null cs))
	(let ((cs-name (caar cs)))
	  (defstruct-put-macro cs-name 'defstruct-expand-cons-macro)
	  (defstruct-putprop cs-name name 'defstruct-name)
	  (push `(:constructor ,cs-name ,(symbol-package cs-name)) exports)))
      (let ((named-p (memq (defstruct-description-type description)
			   '(:named-array :named-array-leader))))
	`(eval-when ,(defstruct-description-eval-when)
	   (multiple-definition ,name defstruct
	     ,(when named-p
		(if predicate
		    `(cli::deftype-as-function ,name ,predicate)
		    `(record-definition-source-file ',name 'cl:deftype
						    :start-type-definition nil)))
	     ;; Do this after we've already done the deftype, so we don't interleave
	     ;; type redefinitions.  --RWK
	     (start-defstruct-definition ',name
					 :record-source-file-name nil
					 ,@(when named-p
					     `(:start-type-definition t)))
	     ,.(defstruct-define-ref-macros new-slots description exports)
	     ,.returns
	     (finish-defstruct-definition ',name
					  ,@(when named-p
					      `(:finish-type-definition t)))
	     ',name))))))


;;;General philosophy on the :print option is to not bother the
;;;user if printing cannot be controled.  This allows for
;;;portability without pain.  This may prove to be a bogus philoshphy.
(defun defstruct-define-printer (name rest)
  (let ((args (gensym)))
    `(local-declare ((function-parent ,name defstruct))
       (defselect ((:property ,name named-structure-invoke))
	 (:print-self (,name &rest ,args)
	  (if print-readably (print-not-readable ,name))
	  (format (car ,args) . ,rest))))))

(defun defstruct-parse-options (options)
  (let ((name (if (atom options) options (car options)))
	(type nil)
	(constructors (make-empty))
	(alterant (make-empty))
	(included nil)
	(named-p nil)
	(but-first nil)
	(description (make-defstruct-description)))
    (setf (defstruct-description-name) name)
    (do ((op) (val) (vals)
	 (options (if (atom options) nil (cdr options))
		  (cdr options)))
	((null options))
      (if (atom (setq op (car options)))
	  (setq vals nil)
	  (setq op (prog1 (car op) (setq vals (cdr op)))))
      (setq val (if (null vals) (make-empty) (car vals)))
AGAIN (selectq op
	(:type
	 (if (defstruct-emptyp val)
	     (defstruct-error
	       "The type option to defstruct must have a value given"
	       name))
	 (setq type val))
	(:named
	 (or (defstruct-emptyp val)
	     (defstruct-error
	       "The named option to defstruct doesn't take a value" name))
	 (setq named-p t))
	(:default-pointer
	 (setf (defstruct-description-default-pointer)
	       (if (defstruct-emptyp val) name val)))
	(:conc-name
	 (setf (defstruct-description-conc-name)
	       (if (defstruct-emptyp val)
		   (append-symbols name '-)
		   val)))
	(:print
	 (if (defstruct-emptyp val)
	     (defstruct-error
	       "The print option to defstruct requires a value"
	       name))
	 (setf (defstruct-description-print) vals))
	(:include
	 (if (defstruct-emptyp val)
	     (defstruct-error
	       "The include option to defstruct requires a value"
	       name))
	 (setq included val)
	 (setf (defstruct-description-include) vals))
	(:predicate
	 (setf (defstruct-description-predicate)
	       (if (defstruct-emptyp val)
		   (append-symbols name '-p)
		   val)))
	(:constructor
	 (cond ((null val)
		(setq constructors nil))
	       (t
		(and (defstruct-emptyp val)
		     (setq val (append-symbols 'make- name)))
		(setq val (cons val (cdr vals)))
		(if (defstruct-emptyp constructors)
		    (setq constructors (list val))
		    (push val constructors)))))
	(:copier
	 (setf (defstruct-description-copier)
	       (if (defstruct-emptyp val)
		   (append-symbols 'copy- name)
		   val)))
	(:eval-when
	 (and (defstruct-emptyp val)
	      (defstruct-error
		"The eval-when option to defstruct requires a value"
		name))
	 (setf (defstruct-description-eval-when) val))
	(:alterant
	 (setq alterant val))
	(:but-first
	 (if (defstruct-emptyp val)
	     (defstruct-error
	       "The but-first option to defstruct must have a value given"
	       name))
	 (setq but-first val)
	 (setf (defstruct-description-but-first) val))
	(:size-macro
	 (setf (defstruct-description-size-macro)
	       (if (defstruct-emptyp val)
		   (append-symbols name '-size)
		   val)))
	(:size-symbol
	 (setf (defstruct-description-size-symbol)
	       (if (defstruct-emptyp val)
		   (append-symbols name '-size)
		   val)))
	(:callable-accessors
	 (setf (defstruct-description-callable-accessors)
	       (if (defstruct-emptyp val) t val)))
	(:property
	 (if (defstruct-emptyp val)
	     (defstruct-error
	       "The property option to defstruct requires a value"
	       name))
	 (push (cons val (if (null (cdr vals)) t (cadr vals)))
	       (defstruct-description-property-alist)))
	(:initial-offset
	 (and (or (defstruct-emptyp val)
		  (not (fixp val)))
	      (defstruct-error
		"The initial-offset option to defstruct requires a fixnum"
		name))
	 (setf (defstruct-description-initial-offset) val))
	(:export
	 (setf (defstruct-description-exports)
	       (if (defstruct-emptyp val)
		   '(:accessors :alterant :constructor :copier
		     :predicate :size-symbol :size-macro)
		 vals)))
	(:inline
	 (setf (defstruct-description-inline)
	       (if (defstruct-emptyp val)
		   '(:accessors :constructor :copier :predicate)
		 vals)))
	(t
	 (cond ((get op 'defstruct-type-description)
		(or (defstruct-emptyp val)
		    (defstruct-error
		      "defstruct type used as an option with a value"
		      op 'in name))
		(setq type op))
	       ((get op ':defstruct-option)
		(push (cons op (if (defstruct-emptyp val) t val))
		      (defstruct-description-property-alist)))
	       (t
		(let ((new (defstruct-retry-keyword op)))
		  (cond ((not (eq new op))
			 (setq op new)
			 (go AGAIN)))
		  (defstruct-error
		    "defstruct doesn't understand this option"
		    op 'in name)))))))
    (cond ((defstruct-emptyp constructors)
	   (setq constructors
		 (list (cons (append-symbols 'make- name)
			     nil)))))
    (setf (defstruct-description-constructors) constructors)
    (cond ((defstruct-emptyp alterant)
	   (setq alterant
		 (append-symbols 'alter- name))))
    (setf (defstruct-description-alterant) alterant)
    (cond ((not (null type))
	   (let ((type-description
		  (or (get type 'defstruct-type-description)
		      (let ((new (defstruct-retry-keyword type)))
			(cond ((eq type new) nil)
			      (t
			       (setq type new)
			       (get type 'defstruct-type-description))))
		      (defstruct-error
			"Unknown type in defstruct"
			type 'in name))))
	     (if named-p
		 (setq type
		       (or (defstruct-type-description-named-type)
			   (defstruct-error
			    "There is no way to make this defstruct type named"
			    type 'in name)))))))
    (cond (included
	   (let ((d (get-defstruct-description included)))
	     (if (null type)
		 (setq type (defstruct-description-type d))
		 (or (eq type (defstruct-description-type d))
		     (defstruct-error
		       "defstruct types must agree for include option"
		       included 'included 'by name)))
	     (and named-p
		  (not (eq type (defstruct-type-description-named-type
				  (or (get type 'defstruct-type-description)
				      (defstruct-error
					"Unknown type in defstruct"
					type 'in name 'including included)))))
		  (defstruct-error
		    "Included defstruct's type isn't a named type"
		    included 'included 'by name))
	     (if (null but-first)
		 (setf (defstruct-description-but-first)
		       (defstruct-description-but-first d))
		 (or (equal but-first (defstruct-description-but-first d))
		     (defstruct-error
		       "but-first options must agree for include option"
		       included 'included 'by name)))
	     (defstruct-check-obsolete-inclusion name included)
	     ))
	  ((null type)
	   (setq type
	     (cond (named-p ':named-array)
		   (t :array)))))
    (let ((type-description (or (get type 'defstruct-type-description)
				(defstruct-error
				  "Undefined defstruct type"
				  type 'in name))))
      (setf (defstruct-description-type) type)
      (setf (defstruct-description-named-p)
	    (eq (defstruct-type-description-named-type) type)))
    description))

(defun defstruct-parse-items (items description)
  (let ((name (defstruct-description-name))
	(offset (defstruct-description-initial-offset))
	(include (defstruct-description-include))
	(o-slot-alist nil)
	(conc-name (defstruct-description-conc-name)))
    (or (null include)
	(let ((d (get (car include) 'defstruct-description)))
	  (setq offset (+ offset (defstruct-description-size d))) 
	  (setq o-slot-alist
		(subst nil nil (defstruct-description-slot-alist d)))
	  (do ((l (cdr include) (cdr l))
	       (it) (val))
	      ((null l))
	    (cond ((atom (setq it (car l)))
		   (setq val (make-empty)))
		  (t
		   (setq val (cadr it))
		   (setq it (car it))))
	    (let ((slot-description (cdr (assq it o-slot-alist))))
	      (and (null slot-description)
		   (defstruct-error
		     "Unknown slot in included defstruct"
		     it 'in include 'included 'by name))
	      (setf (defstruct-slot-description-init-code) val)))))
    (do ((i offset (1+ i))
	 (l items (cdr l))
	 (slot-alist nil))
	((null l)
	 (setq slot-alist (nreverse slot-alist))
	 (setf (defstruct-description-size) i)
	 (setf (defstruct-description-slot-alist)
	       (nconc o-slot-alist slot-alist))
	 slot-alist)
      (cond ((atom (car l))
	     (push (defstruct-parse-one-field
		     (car l) i nil nil conc-name)
		   slot-alist))
	    ((atom (caar l))
	     (push (defstruct-parse-one-field
		     (caar l) i nil (cdar l) conc-name)
		   slot-alist))
	    (t
	     (do ((ll (car l) (cdr ll)))
		 ((null ll))
	       (push (defstruct-parse-one-field
		       (caar ll) i (cadar ll)
		       (cddar ll) conc-name)
		     slot-alist)))))))

(defun defstruct-parse-one-field (it number ppss rest conc-name)
  (let ((mname (if conc-name (append-symbols conc-name it)
		   it)))
    (cons it (make-defstruct-slot-description
	       number number
	       ppss ppss
	       init-code (if (null rest) (make-empty) (car rest))
	       ref-macro-name mname))))

(defun defstruct-expand-access (ppss ref)
  (cond ((null ppss) ref)
	((and (fixp ppss) (zerop (byte-size ppss)))
	 `(ldb-test (byte 1 ,(byte-position ppss)) ,ref))
	((numberp ppss) `(ldb (byte ,(byte-size ppss) ,(byte-position ppss)) ,ref))
	(t `(ldb ,ppss ,ref))))

(defun defstruct-adjust-byte-specifier (ppss)
  (if (and (numberp ppss) (zerop (byte-size ppss)))
      (byte 1 (byte-position ppss))
      ppss))

(defun defstruct-define-ref-macros (new-slots description exports)
  ;;this should be called precisely once
  (setf (defstruct-description-exports)
	(canonicalize-exports description (defstruct-description-exports)))
  (setf (defstruct-description-inline)
	(canonicalize-exports description (defstruct-description-inline)))
  (let ((name (defstruct-description-name)))
    (when (not (defstruct-description-callable-accessors))
      (return-from defstruct-define-ref-macros
	(do ((l new-slots (cdr l))
	     (returns nil)
	     (mname))
	    ((null l) returns)
	  (setq mname (defstruct-slot-description-ref-macro-name (cdar l)))
	  (defstruct-put-macro mname 'defstruct-expand-ref-macro)
	  (defstruct-putprop mname (cons name (caar l)) 'defstruct-slot)
	  (push `(:accessors ,mname ,(symbol-package mname)) exports))))
    (let* ((type-description
	     (get (defstruct-description-type)
		  'defstruct-type-description))
	   (code (defstruct-type-description-ref-expander))
	   (n (defstruct-type-description-ref-no-args))
	   (but-first (defstruct-description-but-first))
	   (default-pointer (defstruct-description-default-pointer))
	   ;;Last arg (if it exists) is name of structure,
	   ;; for documentation purposes.
	   (args (list* (if (special-variable-p name)
			    ;; If the name is declared
			    ;; special, use an uninterned
			    ;; symbol as the subst
			    ;; parameter instead of the
			    ;; special.
			    (make-symbol (get-pname name))
			    name)
			(loop repeat (1- n) collect (gensym))))
	   (body (list* (if but-first
			    `(,but-first ,(car args))
			    (car args))
			(cdr args))))
      (when default-pointer
	(setq args `((,(car args) ,default-pointer)
		     &optional ,@(cdr args))))
      (setq args (reverse args))
      (setq body (reverse body))
      (do ((l new-slots (cdr l))
	   (returns nil))
	  ((null l)
	   (let ((export-returns
		   (loop with things = (defstruct-description-exports)
			 for (type name pack) in exports
			 if (or (memq type things)
				(memq name things))
			   collect `(export ',name ,(pkg-name pack)))))
	     `(,@returns
	       ,@export-returns)))
	(let* ((slotd (cdar l))
	       (mname (defstruct-slot-description-ref-macro-name slotd)))
	  (if default-pointer
	      ;; Anything that has a default pointer can't be a subst,
	      ;; and can't be callable, because the default value for the
	      ;; optional argument has to be evaluated in the caller's
	      ;; lexical environment.
	      (defstruct-put-macro mname 'defstruct-expand-ref-macro)
	      (let* ((ppss (defstruct-slot-description-ppss slotd))
		     (ref (defstruct-expand-access
			    ppss (cl:apply code (defstruct-slot-description-number slotd)
					   description body))))
		(cond ((cl:getf (defstruct-slot-description-property-alist slotd) :read-only)
		       (push `(define-setf-property ',mname 'lt::setf-method
				'setf-defstruct-read-only-slot)
			     returns)
		       (push `(define-locf-property ',mname 'lt::locf-method
				'locf-defstruct-read-only-slot)
			     returns))
		      ((defstruct-type-description-immutable type-description)
		       (push `(cl:define-setf-method ,mname ,args
				;;(declare (sys:function-parent ,name defstruct))
				(defstruct-setf-method ',mname ,@args))
			     returns))
		      (t
		       (let ((setf-name `(cl:setf ,mname))
			     (type :accessors))
			 (unless (defstruct-inline-p description type mname)
			   ;; Only generate a SETF function when the accessors are
			   ;; notinline.  Let subst expanders do their job.  This
			   ;; means that SETF and LOCF functions are not callable
			   ;; when the accessors are inline.  Even if the SETF
			   ;; function is notinline, it's still inlinable.
			   (push (defstruct-inline-proclamation description type setf-name)
				 returns)
			   (push `(defun ,setf-name (,@args .value.)
				    (declare (sys:function-parent ,name defstruct))
				    (cl:setf ,ref .value.))
				 returns)
			   (push `(cl:proclaim '(cl:inline ,setf-name)) returns)))
		       (when (null ppss)
			 (let ((locf-name `(locf ,mname))
			       (type :accessors))
			   (unless (defstruct-inline-p description type mname)
			     ;; Ditto for LOCF functions.
			     (push (defstruct-inline-proclamation description type locf-name)
				   returns)
			     (push `(defun ,locf-name ,args
				      (declare (sys:function-parent ,name defstruct))
				      (locf ,ref))
				   returns)
			     (push `(cl:proclaim '(cl:inline ,locf-name)) returns))))))
		(push (defstruct-accessor-definition description name
			mname args ref)
		      returns)))
	  (push `(:accessors ,mname ,(symbol-package mname)) exports)
	  (defstruct-putprop mname
			     (cons name (caar l))
	    'defstruct-slot))))))

(defun canonicalize-exports (description exports)
  (loop with conc-name = (defstruct-description-conc-name)
	for accessor in exports
	when (not (keywordp accessor))
	  do (setq accessor
		   (if conc-name
		       (append-symbols conc-name accessor)
		       accessor))
	collect accessor))

(defprop shared-structure-accessor t debug-info)

(defmacro define-shared-structure-accessors (&rest type-and-counts)
  `(progn . ,(loop for (function count) in type-and-counts
		   with (defs names)
		   do (multiple-value (defs names)
			(loop for n to count
			      as name = (fintern "STRUCTURE-~A-~D" function n)
			      collect name into names
			      collect `(defsubst ,name (structure)
					 (declare (shared-structure-accessor))
					 (,function
					  ,(if (eq function 'nth) n 'structure)
					  ,(if (eq function 'nth) 'structure n)))
				into defs
			      finally (return (values defs names))))
		   nconc defs into all-defs
		   collect (list* function names) into all-names
		   finally (return (cons `(defconst *shared-structure-accessors* ',all-names)
					 all-defs)))))

(defun defstruct-accessor-definition (description name mname args ref)
  (let* ((inline-p (defstruct-inline-p description :accessors mname))
	 (inline (defstruct-inline-proclamation description :accessors mname))
	 (form `(progn
		  (cl:proclaim '(cl:inline ,mname))	;inlinable even if notinline
		  (defun ,mname ,args
		    (declare (sys:function-parent ,name defstruct))
		    ,ref)
		  ,@(unless inline-p `(,inline)))))
    (when (and (eq (car args) name)
	       (null (cdr args))
	       (listp ref))
      (let* ((function (car ref))
	     (shared (assq function *shared-structure-accessors*)))
	(when (and shared
		   (= (length ref) 3)
		   (eq (if (eq function 'nth) (third ref) (second ref)) name))
	  (let ((n (if (eq function 'nth) (second ref) (third ref))))
	    (when (fixp n)
	      (let ((shared-function (nth n (cdr shared))))
		(when shared-function
		  (return-from defstruct-accessor-definition
		    `(progn
		       ;; At load time, just share.
		       ,inline
		       (deff ,mname #',shared-function)
		       ,@(when inline-p
			   `((eval-when (compile)
			       ;; At compile time, normal inline thing, since compiler doesn't
			       ;; seem to notice deff to subst correctly.
			       (compiler:file-declare ',mname 'compiler:def
				 (lt:find-inline-form-method ',shared-function))))))))))))))
    form))

(defprop defstruct-expand-cons-macro
	 defstruct-function-parent
	 macroexpander-function-parent)

(defprop defstruct-expand-size-macro
	 defstruct-function-parent
	 macroexpander-function-parent)

(defprop defstruct-expand-alter-macro
	 defstruct-function-parent
	 macroexpander-function-parent)

(defprop defstruct-expand-ref-macro 
	 defstruct-function-parent
	 macroexpander-function-parent)

(defun defstruct-function-parent (sym)
  (values (or (get sym 'defstruct-name)
	      (car (get sym 'defstruct-slot)))
	  'defstruct))

(defun defstruct-expand-size-macro (x &optional ignore)	;ENV for macro
  (let ((description (get-defstruct-description (get (car x) 'defstruct-name))))
    (let ((type-description (or (get (defstruct-description-type)
				     'defstruct-type-description)
				(defstruct-error
				  "Unknown defstruct type"
				  (defstruct-description-type)))))
      (+ (defstruct-description-size)
	 (defstruct-type-description-overhead)))))

(defun defstruct-expand-ref-macro (x &optional ignore)	;ENV for macro
  (let* ((pair (get (car x) 'defstruct-slot))
	 (description (get-defstruct-description (car pair)))
	 (type-description (or (get (defstruct-description-type)
				    'defstruct-type-description)
			       (defstruct-error
				 "Unknown defstruct type"
				 (defstruct-description-type))))
	 (code (defstruct-type-description-ref-expander))
	 (n (defstruct-type-description-ref-no-args))
	 (args (reverse (cdr x)))
	 (nargs (length args))
	 (default (defstruct-description-default-pointer))
	 (but-first (defstruct-description-but-first)))
    (cond ((= n nargs)
	   (and but-first
		(rplaca args `(,but-first ,(car args)))))
	  ((and (= n (1+ nargs)) default)
	   (setq args (cons (if but-first
				`(,but-first ,default)
				default)
			    args)))
	  (t
	   (defstruct-error
	     "Wrong number of args to an accessor macro" x)))
    (let* ((slot-description 
	     (cdr (or (assq (cdr pair)
			    (defstruct-description-slot-alist))
		      (defstruct-error
			"This slot no longer exists in this structure"
			(cdr pair) 'in (car pair)))))
	    (ref (lexpr-funcall
		   code
		   (defstruct-slot-description-number)
		   description
		   (nreverse args)))
	    (ppss (defstruct-slot-description-ppss)))
      (defstruct-expand-access ppss ref))))

(defun defstruct-parse-setq-style-slots (l slots others x)
  (do ((l l (cddr l))
       (kludge (cons nil nil)))
      ((null l) kludge)
    (or (and (cdr l)
	     (symbolp (car l)))
	(defstruct-error
	  "Bad argument list to constructor or alterant macro" x))
    (defstruct-make-init-dsc kludge (car l) (cadr l) slots others x)))

(defun defstruct-make-init-dsc (kludge name code slots others x)
  (let ((p (assq name slots)))
    (if (null p)
	(if (memq name others)
	    (push (cons name code) (cdr kludge))
	    (let ((new (defstruct-retry-keyword name)))
	      (if (memq new others)
		  (push (cons new code) (cdr kludge))
		  (defstruct-error
		    "Unknown slot to constructor or alterant macro"
		    name 'in x))))
	(let* ((slot-description (cdr p))
	       (number (defstruct-slot-description-number))
	       (ppss (defstruct-slot-description-ppss))
	       (dsc (assoc number (car kludge))))
	  (cond ((null dsc)
		 (setq dsc (list* number nil (make-empty) 0 0 nil))
		 (push dsc (car kludge))))
	  (cond ((null ppss)
		 (setf (car (cddr dsc)) code)
		 (setf (cadr dsc) t))
		(t (cond ((and (numberp ppss) (numberp code))
			  (let ((ppss (defstruct-adjust-byte-specifier ppss)))
			    (setf (ldb ppss (cadr (cddr dsc))) -1)
			    (setf (ldb ppss (caddr (cddr dsc))) code)))
			 ((and (numberp ppss) (zerop (byte-size ppss)))
			  (push (cons (byte 1 (byte-position ppss))
				      `(if ,code 1 0))
				(cdddr (cddr dsc))))
			 (t
			  (push (cons ppss code) (cdddr (cddr dsc)))))
		   (or (eq t (cadr dsc))
		       (push name (cadr dsc)))))))))

(defun defstruct-code-from-dsc (dsc)
  (flet ((make-byte-specifier (ppss)
	   (if (fixp ppss)
	       `(byte ,(ldb (byte 6 0) ppss) ,(ldb (byte 6 6) ppss))
	     ppss)))
    (let ((code (car (cddr dsc)))
	  (mask (cadr (cddr dsc)))
	  (bits (caddr (cddr dsc))))
      (if (defstruct-emptyp code)
	  (setq code bits)
	(or (zerop mask)
	    (setq code (if (numberp code)
			   (boole 7 bits (boole 2 mask code))
			 (if (zerop (logand mask
					    (1+ (logior mask (1- mask)))))
			     (let ((ss (haulong (boole 2 mask (1- mask)))))
			       `(dpb ,(lsh bits (- ss))
				     ,(make-byte-specifier
					(logior (lsh ss 6)
						(logand #o77
							(- (haulong mask) ss))))
				     ,code))
			   `(boole 7 ,bits (boole 2 ,mask ,code)))))))
      (do ((l (cdddr (cddr dsc)) (cdr l)))
	  ((null l))
	(setq code (let ((value (cdar l))
			 (byte-specifier (caar l)))
		     (if (and (fixp byte-specifier) (zerop (byte-size byte-specifier)))
			 `(dpb (if ,value 1 0) ,(make-byte-specifier byte-specifier) ,code)
		       `(dpb ,value ,(make-byte-specifier byte-specifier) ,code)))))
      code)))


(defun defstruct-expand-cons-macro (x &optional ignore)	;ENV for macro
  (let* ((description (get-defstruct-description (get (car x) 'defstruct-name)))
	 (type-description (or (get (defstruct-description-type)
				    'defstruct-type-description)
			       (defstruct-error
				 "Unknown defstruct type"
				 (defstruct-description-type))))
	 (slot-alist (defstruct-description-slot-alist))
	 (cons-keywords (defstruct-type-description-cons-keywords))
	 (kludge nil)
	 (constructor-description 
	   (cdr (or (assq (car x) (defstruct-description-constructors))
		    (defstruct-error
		      "This constructor is no longer defined for this structure"
		      (car x) 'in (defstruct-description-name)))))
	 (aux nil)
	 (aux-init nil))
     (if (null constructor-description)
	 (setq kludge (defstruct-parse-setq-style-slots (cdr x)
							slot-alist
							cons-keywords
							x))
	 (prog (args l)
	       (setq kludge (cons nil nil))
	       (setq args (cdr x))
	       (setq l (car constructor-description))
	     R (cond ((null l)
		      (if (null args)
			  (return nil)
			  (go barf-tma)))
		     ((atom l) (go barf))
		     ((eq (car l) '&optional) (go O))
		     ((eq (car l) '&rest) (go S))
		     ((eq (car l) '&aux) (go A))
		     ((null args) (go barf-tfa)))
	       (defstruct-make-init-dsc kludge
					(pop l)
					(pop args)
					slot-alist
					cons-keywords
					x)
	       (go R)
	     O (and (null args) (go OD))
	       (pop l)
	       (cond ((null l) (go barf-tma))
		     ((atom l) (go barf))
		     ((eq (car l) '&optional) (go barf))
		     ((eq (car l) '&rest) (go S))
		     ((eq (car l) '&aux) (go barf-tma)))
	       (defstruct-make-init-dsc kludge
					(if (atom (car l)) (car l) (caar l))
					(pop args)
					slot-alist
					cons-keywords
					x)
	       (go O)
	    OD (pop l)
	       (cond ((null l) (return nil))
		     ((atom l) (go barf))
		     ((eq (car l) '&optional) (go barf))
		     ((eq (car l) '&rest) (go S))
		     ((eq (car l) '&aux) (go A)))
	       (or (atom (car l))
		   (defstruct-make-init-dsc kludge
					    (caar l)
					    (cadar l)
					    slot-alist
					    cons-keywords
					    x))
	       (go OD)
	     S (and (atom (cdr l)) (go barf))
	       (defstruct-make-init-dsc kludge
					(cadr l)
					`(list ,@args)
					slot-alist
					cons-keywords
					x)
	       (setq l (cddr l))
	       (and (null l) (return nil))
	       (and (atom l) (go barf))
	       (or (eq (car l) '&aux) (go barf))
	     A (pop l)
	       (cond ((null l) (return nil))
		     ((atom l) (go barf))
		     ((atom (car l))
		      (push (car l) aux)
		      (push (make-empty) aux-init))
		     (t
		      (push (caar l) aux)
		      (push (cadar l) aux-init)))
	       (go A)
	  barf (defstruct-error
		 "Bad format for defstruct constructor arglist"
		 `(,(car x) ,@(car constructor-description)))
      barf-tfa (defstruct-error "Too few arguments to constructor macro" x)
      barf-tma (defstruct-error "Too many arguments to constructor macro" x)))
     (do ((l slot-alist (cdr l)))
	 ((null l))
       (let* ((name (caar l))
	      (slot-description (cdar l))
	      (code (do ((aux aux (cdr aux))
			 (aux-init aux-init (cdr aux-init)))
			((null aux) (defstruct-slot-description-init-code))
		      (and (eq name (car aux)) (return (car aux-init)))))
	      (ppss (defstruct-slot-description-ppss)))
	 (or (and (defstruct-emptyp code) (null ppss))
	     (let* ((number (defstruct-slot-description-number))
		    (dsc (assoc number (car kludge))))
	       (cond ((null dsc)
		      (setq dsc (list* number nil (make-empty) 0 0 nil))
		      (push dsc (car kludge))))
	       (cond ((defstruct-emptyp code))
		     ((eq t (cadr dsc)))
		     ((null ppss)
		      (and (defstruct-emptyp (car (cddr dsc)))
			   (setf (car (cddr dsc)) code)))
		     ((memq name (cadr dsc)))
		     ((and (numberp ppss) (numberp code))
		      (let ((ppss (defstruct-adjust-byte-specifier ppss)))
			(setf (ldb ppss (cadr (cddr dsc))) -1)
			(setf (ldb ppss (caddr (cddr dsc))) code)))
		     ((and (numberp ppss) (zerop (byte-size ppss)))
		      (push (cons (byte 1 (byte-position ppss))
				  `(if ,code 1 0))
			    (cdddr (cddr dsc))))
		     (t
		      (push (cons ppss code) (cdddr (cddr dsc)))))))))
     (do ((l (car kludge) (cdr l)))
	 ((null l))
       (rplacd (car l) (defstruct-code-from-dsc (car l))))
     (invoke-defstruct-constructor-expander
       description type-description
       (car kludge) (cdr kludge))))

(defun invoke-defstruct-constructor-expander (description type-description arg etc)
  (funcall (defstruct-type-description-cons-expander)
	   (selectq (defstruct-type-description-cons-flavor)
	     (:list
	      (let ((l (cl:make-list (defstruct-description-size))))
		(dolist (slot-descriptor arg)
		  (setf (nth (car slot-descriptor) l) (cdr slot-descriptor)))
		l))
	     (:alist arg)
	     (t
	      (defstruct-error
		"Unknown constructor kind in this defstruct type"
		(defstruct-description-type))))
	   description etc))

(defun defstruct-expand-alter-macro (x &optional ignore)	;ENV for macro
  (let* ((description (get-defstruct-description (get (car x) 'defstruct-name)))
	 (type-description (or (get (defstruct-description-type)
				    'defstruct-type-description)
			       (defstruct-error
				 "Unknown defstruct type"
				 (defstruct-description-type))))
	 (ref-code (defstruct-type-description-ref-expander))
	 (ref-nargs (defstruct-type-description-ref-no-args)))
    (do ((l (car (defstruct-parse-setq-style-slots 
		   (nthcdr (1+ ref-nargs) x)
		   (defstruct-description-slot-alist)
		   nil
		   x))
	    (cdr l))
	 (but-first (defstruct-description-but-first))
	 (body nil)
	 (avars (do ((i 0 (1+ i))
		     (l nil (cons (gensym) l)))
		    ((= i ref-nargs) l)))
	 (vars nil)
	 (vals nil))
	((null l)
	 `((lambda ,avars
	     ,@(if (null vars)
		   body
		   `(((lambda ,vars ,@body) ,.vals))))
	   ,@(do ((i (1- ref-nargs) (1- i))
		  (l `(,(if but-first
			    `(,but-first ,(nth ref-nargs x))
			    (nth ref-nargs x)))
		     (cons (nth i x) l)))
		 ((= i 0) l))))
      (let ((ref (lexpr-funcall ref-code (caar l) description avars)))
	(and (defstruct-emptyp (car (cddr (car l))))
	     (setf (car (cddr (car l))) ref))
	(let ((code (defstruct-code-from-dsc (car l))))
	  (if (null (cdr l))
	      (push `(setf ,ref ,code) body)
	      (let ((sym (gensym)))
		(push `(setf ,ref ,sym) body)
		(push sym vars)
		(push code vals))))))))

(defprop defstruct-define-type "Structure Type" si:definition-type-name)

(defmacro defstruct-define-type (type &body options)
  (do ((options options (cdr options))
       (op) (args)
       (type-description (make-defstruct-type-description))
       (cons-expander nil)
       (ref-expander nil)
       (returns `(',type)))
      ((null options)
       (or cons-expander
	   (defstruct-error "No cons option in defstruct-define-type" type))
       (or ref-expander
	   (defstruct-error "No ref option in defstruct-define-type" type))
       `(progn 'compile
	       ,cons-expander
	       ,ref-expander
	       (defprop ,type ,type-description defstruct-type-description)
	       ,@returns))
    (cond ((atom (setq op (car options)))
	   (setq args nil))
	  (t
	   (setq args (cdr op))
	   (setq op (car op))))
 AGAIN
    (selectq op
      (:cons
        (or (> (length args) 2)
	    (defstruct-error
	      "Bad cons option in defstruct-define-type"
	      (car options) 'in type))
	(let ((n (length (car args)))
	      (name (append-symbols type '-defstruct-cons)))
	  (or (= n 3)
	      (defstruct-error
		"Bad cons option in defstruct-define-type"
		(car options) 'in type))
	  (setf (defstruct-type-description-cons-flavor)
		(defstruct-retry-keyword (cadr args)))
	  (setf (defstruct-type-description-cons-expander) name)
	  (setq cons-expander `(defun ,name ,(car args)
				 ,@(cddr args)))))
      (:ref
        (or (> (length args) 1)
	    (defstruct-error
	      "Bad ref option in defstruct-define-type"
	      (car options) 'in type))
	(let ((n (length (car args)))
	      (name (append-symbols type '-defstruct-ref)))
	  (or (> n 2)
	      (defstruct-error
		"Bad ref option in defstruct-define-type"
		(car options) 'in type))
	  (setf (defstruct-type-description-ref-no-args) (- n 2))
	  (setf (defstruct-type-description-ref-expander) name)
	  (setq ref-expander `(defun ,name ,(car args)
				,@(cdr args)))))
      (:predicate
        (or (> (length args) 1)
	    (defstruct-error
	      "Bad predicate option in defstruct-define-type"
	      (car options) 'in type))
        (let ((name (append-symbols type '-defstruct-predicate)))
	  (setf (defstruct-type-description-predicate) name)
	  (push `(defun ,name ,(car args)
		   ,@(cdr args))
		returns)))
      (:copier
        (or (> (length args) 1)
	    (defstruct-error
	      "Bad copier option in defstruct-define-type"
	      (car options) 'in type))
        (let ((name (append-symbols type '-defstruct-copier)))
	  (setf (defstruct-type-description-copier) name)
	  (push `(defun ,name ,(car args)
		   ,@(cdr args))
		returns)))
      (:overhead
        (setf (defstruct-type-description-overhead)
	      (if (null args)
		  (defstruct-error
		    "Bad option to defstruct-define-type"
		    (car options) 'in type)
		  (car args))))
      (:named
        (setf (defstruct-type-description-named-type)
	      (if (null args)
		  type
		  (car args))))
      (:keywords
        (setf (defstruct-type-description-cons-keywords) args))
      (:defstruct
        (or (> (length args) 1)
	    (defstruct-error
	      "Bad defstruct option in defstruct-define-type"
	      (car options) 'in type))
	(let ((name (append-symbols type '-defstruct-expand)))
	  (setf (defstruct-type-description-defstruct-expander) name)
	  (push `(defun ,name ,@args) returns)))
      (:immutable
       (setf (defstruct-type-description-immutable type-description) t))
      (t
       (let ((new (defstruct-retry-keyword op)))
	 (cond ((not (eq op new))
		(setq op new)
		(go AGAIN)))
	 (defstruct-error
	   "Unknown option to defstruct-define-type"
	   op 'in type))))))

(defprop :make-array t :defstruct-option)

(defstruct-define-type :array
  (:named :named-array)
  (:keywords :make-array)
  (:cons (arg description etc) :alist
    (lispm-array-for-defstruct arg #'(lambda (v a i) `(aset ,v ,a ,i))
			       description etc nil nil nil 1))
  (:ref (n description arg)
    description		;ignored
    `(aref ,arg ,n)))

(defstruct-define-type :named-array
  (:keywords :make-array)
  :named (:overhead 1)
  (:cons (arg description etc) :alist
	 (lispm-array-for-defstruct arg #'(lambda (v a i) `(aset ,v ,a ,(1+ i)))
				    description etc nil t nil 1))
  (:ref (n description arg)
   description					;ignored
   `(aref ,arg ,(1+ n)))
  (:predicate (description name)
   `(defun ,name (x)
      (typep x ',(defstruct-description-name)))))

(defstruct-define-type :fixnum-array
  (:keywords :make-array)
  (:cons (arg description etc) :alist
    (lispm-array-for-defstruct arg #'(lambda (v a i) `(aset ,v ,a ,i))
			       description etc 'art-32b nil nil 1))
  (:ref (n description arg)
    description		;ignored
    `(aref ,arg ,n)))

(defstruct-define-type :flonum-array
  (:keywords :make-array)
  (:cons (arg description etc) :alist
    (lispm-array-for-defstruct arg #'(lambda (v a i) `(aset ,v ,a ,i))
			       description etc 'art-float nil nil 1))
  (:ref (n description arg)
    description		;ignored
    `(aref ,arg ,n)))

(defstruct-define-type :array-leader
  (:named :named-array-leader)
  (:keywords :make-array)
  (:cons (arg description etc) :alist
    (lispm-array-for-defstruct arg #'(lambda (v a i)
				       `(store-array-leader ,v ,a ,i))
			       description etc nil nil t 1))
  (:ref (n description arg)
    description		;ignored
    `(array-leader ,arg ,n)))

(defstruct-define-type :named-array-leader
  (:keywords :make-array)
  :named (:overhead 1)
  (:cons (arg description etc) :alist
	 (lispm-array-for-defstruct
	   arg
	   #'(lambda (v a i)
	       `(store-array-leader ,v ,a ,(if (zerop i)
					       0
					       (1+ i))))
	   description etc nil t t 1))
  (:ref (n description arg)
   description					;ignored
   (if (zerop n)
       `(array-leader ,arg 0)
       `(array-leader ,arg ,(1+ n))))
  (:predicate (description name)
   `(defun ,name (x)
      (typep x ',(defstruct-description-name)))))

(defprop :times t :defstruct-option)

(defstruct-define-type :grouped-array
  (:keywords :make-array :times)
  (:cons (arg description etc) :alist
    (lispm-array-for-defstruct
      arg
      #'(lambda (v a i) `(aset ,v ,a ,i))
      description etc nil nil nil
      (or (cdr (or (assq ':times etc)
		   (assq ':times (defstruct-description-property-alist))))
	  1)))
  (:ref (n description index arg)
    description		;ignored
    (cond ((numberp index)
	   `(aref ,arg ,(+ n index)))
	  ((zerop n)
	   `(aref ,arg ,index))
	  (t `(aref ,arg (+ ,n ,index))))))

(defun lispm-array-for-defstruct (arg cons-init description etc type named-p leader-p times)
  (let ((p (cons nil nil))
	(no-op nil))
    (defstruct-grok-make-array-args
      (cdr (assq ':make-array (defstruct-description-property-alist)))
      p)
    (defstruct-grok-make-array-args
      (cdr (assq ':make-array etc))
      p)
    (and type (putprop p type ':type))
    (and named-p (putprop p `',(defstruct-description-name) ':named-structure-symbol))
    (let ((property (if leader-p ':leader-length ':dimensions))
	  (size (if named-p
		    (max (1+ (defstruct-description-size))
			 (if leader-p 2 0))
		    (defstruct-description-size))))
      (setq size (if (numberp times)
		     (* size times)
		     `(* ,size ,times)))
      (let ((arg (get p property)))
	(when arg
	  (setq size `(or ,arg ,size))))
      (putprop p size property))
    (or leader-p
	(if (get p ':initial-value)
	    (setq no-op (make-empty))
	    (let ((type (get p ':type)))
	      (or (atom type)
		  (not (eq (car type) 'quote))
		  (setq type (cadr type)))
	      (caseq type
		((nil art-q art-q-list art-boolean))  ;no-op remains nil
		((art-16b art-8b art-4b art-2b art-1b art-string art-fat-string)
		 (setq no-op 0))
		(t (setq no-op (make-empty)))))))
    (let ((dims (prog1 (get p :dimensions) (nremprop p :dimensions))))
      (do ((l (cdr p) (cddr l)))
	  ((null l))
	(rplaca l `',(car l)))
      (cond ((and named-p (not leader-p)
		  (eql dims (1+ (defstruct-description-size)))
		  ;; just the named-structure-symbol
		  (= (length (cdr p)) 2))
	     `(make-named-structure-vector-n
		,dims
		',(defstruct-description-name)
		;; turn the alist into an ordered list
		,@(let ((l (cl:make-list (defstruct-description-size))))
		    (dolist (slot-descriptor arg)
		      (setf (nth (car slot-descriptor) l) (cdr slot-descriptor)))
		    l)))
	    ((and (not named-p) (not leader-p)
		  (eql dims (defstruct-description-size))
		  (null (cdr p)))
	     `(make-structure-vector-n
		,dims
		;; turn the alist into an ordered list
		,@(let ((l (cl:make-list (defstruct-description-size))))
		    (dolist (slot-descriptor arg)
		      (setf (nth (car slot-descriptor) l) (cdr slot-descriptor)))
		    l)))
	    (t
	     (do ((creator `(make-array ,(or dims 0) ,@(cdr p)))
		  (var (gensym))
		  (set-ups nil (if (equal (cdar l) no-op)
				   set-ups
				   (cons (funcall cons-init (cdar l) var (caar l))
					 set-ups)))
		  (l arg (cdr l)))
		 ((null l)
		  (if set-ups
		      `(let ((,var ,creator))
			 ,@(nreverse set-ups)
			 ,var)
		      creator))))))))

(defun defstruct-grok-make-array-args (args p)
  (do ((l args (cddr l)))
      ((null l) p)
    (putprop p
	     (cadr l)
	     (if (eq (car l) ':length)
		 ':dimensions
		 (car l)))))

(defprop :make-list t :defstruct-option)

(defun defstruct-make-list-function (arg description &optional list*-p)
  (let* ((make-list-options
	   (cdr (assq ':make-list (defstruct-description-property-alist))))
	 (area (cadr (assq ':area (ncons make-list-options)))))
    (if area
	(if list*-p
	    `(list*-in-area ,area ,.arg)
	  `(list-in-area ,area ,.arg))
      (if list*-p
	  `(list* ,.arg)
	`(list ,.arg)))))

(defstruct-define-type :list
  (:named :named-list)
  (:cons (arg description etc) :list
    description		;ignored
    etc			;ignored
    (defstruct-make-list-function arg description))
  (:ref (n description arg)
    description		;ignored
    `(nth ,n ,arg))
  (:copier (description name)
    (do ((l `((car x)) (cons `(prog1 (car x) (setq x (cdr x))) l))
	 (i (defstruct-description-size) (1- i)))
	((<= i 1)
	 `(defun ,name (x)
	    (list ,@l))))))

(defstruct-define-type :named-list
  :named (:overhead 1)
  (:cons (arg description etc) :list
    etc			;ignored
    ;`(list ',(defstruct-description-name) ,.arg))
    (defstruct-make-list-function `(',(defstruct-description-name) ,.arg) description))
  (:ref (n description arg)
    description		;ignored
    `(nth ,(1+ n) ,arg))
  (:predicate (description name)
    `(defun ,name (x)
       (and
	 (not (atom x))
	 (eq (car x) ',(defstruct-description-name)))))
  (:copier (description name)
    (do ((l `((car x)) (cons `(prog1 (car x) (setq x (cdr x))) l))
	 (i (defstruct-description-size) (1- i)))
	((<= i 1)
	 `(defun ,name (x)
	    (setq x (cdr x))
	    (list ',(defstruct-description-name) ,@l))))))

(defstruct-define-type :list*
  (:cons (arg description etc) :list
    description		;ignored
    etc			;ignored
    (defstruct-make-list-function arg description t))
  (:ref (n description arg)
    (let ((size (1- (defstruct-description-size))))
      (if (< n size)
	  `(nth ,n ,arg)
	  `(nthcdr ,n ,arg))))
  (:defstruct (description)
    (and (defstruct-description-include)
	 (defstruct-error
	   "Structure of type list* cannot include another"
	   (defstruct-description-name)))
    nil)
  (:copier (description name)
    (do ((l `(x) (cons `(prog1 (car x) (setq x (cdr x))) l))
	 (i (defstruct-description-size) (1- i)))
	((<= i 1)
	 `(defun ,name (x)
	    (list* ,@l))))))

(defstruct-define-type :tree
  (:cons (arg description etc) :list
    etc			;ignored
    (if (null arg) (defstruct-error
		     "defstruct cannot make an empty tree"
		     (defstruct-description-name)))
    (make-tree-for-defstruct arg (defstruct-description-size)))
  (:ref (n description arg)
    (do ((size (defstruct-description-size))
	 (a arg)
	 (tem))
	(nil)
      (cond ((= size 1) (return a))
	    ((< n (setq tem (// size 2)))
	     (setq a `(car ,a))
	     (setq size tem))
	    (t (setq a `(cdr ,a))
	       (setq size (- size tem))
	       (setq n (- n tem))))))
  (:defstruct (description)
    (and (defstruct-description-include)
	 (defstruct-error
	   "Structure of type tree cannot include another"
	   (defstruct-description-name)))
    nil)
  (:copier (description name)
    `(defun ,name (x)
       ,(copy-tree-for-defstruct nil (defstruct-description-size)))))

(defun make-tree-for-defstruct (arg size)
  (cond ((= size 1) (car arg))
	((= size 2) `(cons ,(car arg) ,(cadr arg)))
	(t (do ((a (cdr arg) (cdr a))
		(m (// size 2))
		(n (1- (// size 2)) (1- n)))
	       ((zerop n)
		`(cons ,(make-tree-for-defstruct arg m)
		       ,(make-tree-for-defstruct a (- size m))))))))

(defun copy-tree-for-defstruct (popx? size)
  (cond ((= size 1)
	 (if popx?
	     `(prog1 (car x) (setq x (cdr x)))
	     `x))
	((= size 2)
	 (if popx?
	     `((lambda (x) (cons (car x) (cdr x)))
	       (prog1 (car x) (setq x (cdr x))))
	     `(cons (car x) (cdr x))))
	(popx?
	 `((lambda (x)
	     (cons ,(copy-tree-for-defstruct t (// size 2))
		   ,(copy-tree-for-defstruct nil (- size (// size 2)))))
	   (prog1 (car x) (setq x (cdr x)))))
	(t
	 `(cons ,(copy-tree-for-defstruct t (// size 2))
		,(copy-tree-for-defstruct nil (- size (// size 2)))))))

(defstruct-define-type :fixnum
  (:cons (arg description etc) :list
    etc			;ignored
    (and (or (null arg)
	     (not (null (cdr arg))))
	 (defstruct-error
	   "Structure of type fixnum must have exactly 1 slot to be constructable"
	   (defstruct-description-name)))
    (car arg))
  (:ref (n description arg)
    n			;ignored
    description		;ignored
    arg)
  :immutable)

(defvar *defstruct-examine&deposit-arg*)

(defun defstruct-examine (*defstruct-examine&deposit-arg*
			  name slot-name)
  (eval (list (defstruct-slot-description-ref-macro-name
		(defstruct-examine&deposit-find-slot-description
		  name slot-name))
	      '*defstruct-examine&deposit-arg*)))

(defvar *defstruct-examine&deposit-val*)

(defun defstruct-deposit (*defstruct-examine&deposit-val*
			  *defstruct-examine&deposit-arg*
			  name slot-name)
  (eval (list 'setf
	      (list (defstruct-slot-description-ref-macro-name
		     (defstruct-examine&deposit-find-slot-description
		       name slot-name))
		    '*defstruct-examine&deposit-arg*)
	      '*defstruct-examine&deposit-val*)))

(defun defstruct-get-locative (*defstruct-examine&deposit-arg*
			       name slot-name)
  (let ((slot-description (defstruct-examine&deposit-find-slot-description
			    name slot-name)))
    (or (null (defstruct-slot-description-ppss))
	(defstruct-error
	  "You cannot get a locative to a byte field"
	  slot-name 'in name))
    (eval (list 'locf
		(list (defstruct-slot-description-ref-macro-name)
		      '*defstruct-examine&deposit-arg*)))))

(defun defstruct-examine&deposit-find-slot-description (name slot-name)
  (let ((description (get-defstruct-description name)))
    (let ((slot-description
	    (cdr (or (assq slot-name (defstruct-description-slot-alist))
		     (defstruct-error
		       "No such slot in this structure"
		       slot-name 'in name))))
	  (type-description
	    (or (get (defstruct-description-type) 'defstruct-type-description)
		(defstruct-error
		  "Undefined defstruct type"
		  (defstruct-description-type)))))
      (or (= (defstruct-type-description-ref-no-args) 1)
	  (defstruct-error
	    "defstruct-examine and defstruct-deposit cannot handle structures of this type"
	    (defstruct-description-type)))
      slot-description)))

;;; Support for make-obsolete:
;;;    Obsolete the structure so that including it in other defstructs will generate
;;;    a warning.
;;;    Obsolete the constructor, size-macro, alterant, predicate, copier and all the
;;;    accessors so that use of them will generate a warning.
;;; Its ok that this calls functions that aren't defined when struct is loaded because
;;; it can't get called until compiler:make-obsolete-1 is defined anyways.
(defprop defstruct make-defstruct-obsolete compiler:make-obsolete)

(defun make-defstruct-obsolete (structure-type reason &optional ignore)
  (let ((description (get-defstruct-description structure-type))
	(warning (string-append "is an obsolete structure; " reason))
	(ctl (format nil "it is ~~A for the obsolete ~S structure" structure-type)))
    (putprop structure-type (cons warning fdefine-file-pathname) 'obsolete-defstruct)
    (loop with accessor-reason = (format nil ctl "an accessor")
	   for (nil . slot-description) in (defstruct-description-slot-alist)
	   for ref-macro-name = (defstruct-slot-description-ref-macro-name)
	    do (when (eq (car (get ref-macro-name 'defstruct-slot)) structure-type)
		 (compiler:make-obsolete-1 ref-macro-name accessor-reason 'defun)))
    (loop for (constructor) in (defstruct-description-constructors)
	  with constructor-reason = (format nil ctl "a constructor")
	    do (compiler:make-obsolete-1 constructor constructor-reason 'defun))
    (loop for (slot . name) in '((defstruct-description-size-macro . "the size macro")
				 (defstruct-description-alterant   . "the alterant")
				 (defstruct-description-predicate  . "the predicate")
				 (defstruct-description-copier     . "the copier"))
	  for value = (funcall slot description)
	   do (when value
		(compiler:make-obsolete-1
		  value (format nil ctl name) 'defun)))))

(defun defstruct-check-obsolete-inclusion (name included)
  (let ((obsolete (get included 'obsolete-defstruct))
	(compiler:default-warning-function name))
    (when obsolete    
      (compiler:warn '(:definition-type defstruct)
		     "The included structure ~S ~A." included (car obsolete)))))

(sstatus feature defstruct)



;;; Common Lisp defstruct parsing code

(defprop cl:defstruct defstruct zwei:definition-function-spec-type)

;;;The order of forms returned by defstruct is sometimes critical.  Keep this
;;;in mind when munging this code:
(defmacro cl:defstruct (options &body items)
  (let* ((description (defstruct-parse-cl-options options))
	 (type-description (get (defstruct-description-type)
				'defstruct-type-description))
	 (name (defstruct-description-name))
	 (documentation (and (stringp (first items)) (pop items)))
	 (new-slots (defstruct-parse-cl-items items description))
	 (returns nil))
    ;;This must be last, since to compile it might require that the structure
    ;;already be operable:
    (cond ((defstruct-description-print)
	   (push (defstruct-define-printer name (defstruct-description-print))
		 returns))
	  ((assq ':print-function (defstruct-description-property-alist))
	   (push `(defselect ((:property ,name named-structure-invoke))
		    (:print-self (,name stream i-prindepth cl:*print-escape*)
		      (,(cdr (assq ':print-function (defstruct-description-property-alist)))
		       ,name stream i-prindepth)))
		 returns)))
    ;;Keep this as close to last as possible:
    (cond ((defstruct-type-description-defstruct-expander)
	   (setq returns (append (funcall (defstruct-type-description-defstruct-expander)
					  description)
				 returns))))
    ;; Store documentation
    (when documentation
      (push `(cl:setf (documentation ',name 'cl:structure) ,documentation) returns))
    (let ((alterant (defstruct-description-alterant))
	  (size-macro (defstruct-description-size-macro))
	  (size-symbol (defstruct-description-size-symbol))
	  (predicate (defstruct-description-predicate))
	  (copier (defstruct-description-copier)))
      (cond (predicate
	     (push (funcall (or (defstruct-type-description-predicate)
				(defstruct-error
				  "This defstruct type cannot produce a predicate"
				  (defstruct-description-type) 'in name))
			    description
			    predicate)
		   returns)
	     (push (defstruct-inline-proclamation description :predicate predicate)
		   returns)))
      (cond (copier
	     (push
	       (let ((copy-fun (defstruct-type-description-copier)))
		 (cond (copy-fun
			(funcall copy-fun description copier))
		       ((not (= 1 (defstruct-type-description-ref-no-args)))
			(defstruct-error
			  "This defstruct type cannot produce a copying function"
			  (defstruct-description-type) 'in name))
		       (t (do ((i (1- (defstruct-description-size)) (1- i))
			       (l nil (cons (cons i (funcall (defstruct-type-description-ref-expander)
							     i description 'x))
					    l)))
			      ((< i 0)
			       `(defun ,copier (x)
				  (declare (function-parent ,name defstruct))
				  ,(invoke-defstruct-constructor-expander
				     description type-description l nil)))))))
	       returns)
	     (push (defstruct-inline-proclamation description :copier copier)
		   returns)))
      (cond (alterant
	     (defstruct-put-macro alterant 'defstruct-expand-alter-macro)
	     (defstruct-putprop alterant name 'defstruct-name)))
      (cond (size-macro
	     (defstruct-put-macro size-macro 'defstruct-expand-size-macro)
	     (defstruct-putprop size-macro name 'defstruct-name)))
      (cond (size-symbol
	     (push `(defconst ,size-symbol
		      ,(+ (defstruct-description-size)
			  (defstruct-type-description-overhead)))
		   returns)))
      (defstruct-putprop name description 'defstruct-description)
      (do ((cs (defstruct-description-constructors) (cdr cs)))
	  ((null cs))
	(push (defstruct-define-cons-function (caar cs) (cdar cs) description type-description)
	      returns))
      (let ((named-p (memq (defstruct-description-type description)
			   '(:named-array :named-array-leader))))
	`(eval-when ,(defstruct-description-eval-when)
	   (multiple-definition ,name defstruct
	     ,(when named-p
		(if predicate
		    `(cli::deftype-as-function ,name ,predicate)
		    `(record-definition-source-file ',name 'cl:deftype
						    :start-type-definition nil)))
	     ;; Do this after we've already done the deftype, so we don't interleave
	     ;; type redefinitions.  --RWK
	     (start-defstruct-definition ',name
					 :record-source-file-name nil
					 ,@(when named-p
					     `(:start-type-definition t)))
	     ,.(defstruct-define-ref-macros new-slots description nil)
	     ,.returns
	     (finish-defstruct-definition ',name
					  ,@(when named-p
					      `(:finish-type-definition t)))
	     ',name))))))

(defun defstruct-parse-cl-options (options)
  (let* ((name (if (atom options) options (car options)))
	 (type nil)
	 (named-p nil)
	 (constructors (make-empty))
	 (alterant nil)
	 (copier (make-empty))
	 (included nil)
	 (but-first nil)
	 (conc-name (make-empty))
	 (pred-name (make-empty))
	 (description (make-defstruct-description name name eval-when '(load eval))))
    (do ((op) (val) (vals)
	 (options (if (atom options) nil (cdr options))
		  (cdr options)))
	((null options))
      (if (atom (setq op (car options)))
	  (setq vals nil)
	  (setq op (prog1 (car op) (setq vals (cdr op)))))
      (setq val (if (null vals) (make-empty) (car vals)))
      (selectq op
	(:type
	 (if (defstruct-emptyp val)
	     (defstruct-error "The :type option to defstruct requires a value" name))
	 (setq type val))
	(:named
	 (or (defstruct-emptyp val)
	     (defstruct-error "The :named option to defstruct doesn't take a value" name))
	 (setq named-p t))
	(:default-pointer
	 (setf (defstruct-description-default-pointer)
	       (if (defstruct-emptyp val) name val)))
	(:conc-name
	 (setq conc-name val))
	(:print
	 (if (defstruct-emptyp val)
	     (defstruct-error "The :print option to defstruct requires a value" name))
	 (setf (defstruct-description-print) vals))
	(:include
	 (if (defstruct-emptyp val)
	     (defstruct-error "The :include option to defstruct requires a value" name))
	 (setq included val)
	 (setf (defstruct-description-include) vals))
	(:predicate
	 (setq pred-name val))
	(:constructor
	 (cond ((null val)
		(setq constructors nil))
	       (t
		(when (defstruct-emptyp val)
		  (setq val (append-symbols 'make- name)))
		(setq val (cons val (cdr vals)))
		(if (defstruct-emptyp constructors)
		    (setq constructors (list val))
		    (push val constructors)))))
	(:constructor-make-array-keywords
	 (push (cons op vals) (defstruct-description-property-alist)))
	(:copier
	 (setq copier val))
	(:eval-when
	 (and (defstruct-emptyp val)
	      (defstruct-error "The :eval-when option to defstruct requires a value" name))
	 (setf (defstruct-description-eval-when) val))
	(:alterant
	 (setq alterant val))
	(:but-first
	 (if (defstruct-emptyp val)
	     (defstruct-error "The :but-first option to defstruct requires a value" name))
	 (setq but-first val)
	 (setf (defstruct-description-but-first) val))
	(:size-macro
	 (setf (defstruct-description-size-macro)
	       (if (defstruct-emptyp val)
		   (append-symbols name '-size)
		   val)))
	(:size-symbol
	 (setf (defstruct-description-size-symbol)
	       (if (defstruct-emptyp val)
		   (append-symbols name '-size)
		   val)))
	(:callable-accessors
	 (setf (defstruct-description-callable-accessors)
	       (if (defstruct-emptyp val) t val)))
	(:property
	 (if (defstruct-emptyp val)
	     (defstruct-error "The :property option to defstruct requires a value" name))
	 (push (cons val (if (null (cdr vals)) t (cadr vals)))
	       (defstruct-description-property-alist)))
	(:initial-offset
	 (and (or (defstruct-emptyp val)
		  (not (fixp val)))
	      (defstruct-error "The :initial-offset option to defstruct requires a fixnum"
			       name))
	 (setf (defstruct-description-initial-offset) val))
	(:export
	 (setf (defstruct-description-exports)
	       (if (defstruct-emptyp val)
		   '(:accessors :alterant :constructor :copier
		     :predicate :size-symbol :size-macro)
		 vals)))
	(:inline
	 (setf (defstruct-description-inline)
	       (if (defstruct-emptyp val)
		   '(:accessors :constructor :copier :predicate)
		 vals)))
	(:print-function
	 (unless (= (length vals) 1)
	   (defstruct-error "The :print-function option to defstruct requires one value"
			    name))
	 (push (cons op val) (defstruct-description-property-alist)))
	(t
	 (cond ((get op 'defstruct-type-description)
		(or (defstruct-emptyp val)
		    (defstruct-error
		      "defstruct type used as an option with a value"
		      op 'in name))
		(setq type op))
	       ((get op ':defstruct-option)
		(push (cons op (if (defstruct-emptyp val) t val))
		      (defstruct-description-property-alist)))
	       (t
		(defstruct-error "defstruct doesn't understand this option"
				 op 'in name))))))

    (cond ((eq type 'cl:list)			;Convert Common Lisp types
	   (setq type ':list))
	  ((eq type 'cl:vector)
	   (setq type ':array))
	  ((and (listp type)
		(eq (first type) 'cl:vector)
		(cl-sys:type-array-element-type (second type)))
	   (push `(:make-array :type ',(cl-sys:type-array-element-type (second type)))
		 (defstruct-description-property-alist))
	   (setq type ':array)))
    (when (null type)
      (setq type (if included
		     (defstruct-description-type (get-defstruct-description included))
		     ':named-array))
      (setq named-p nil))
    (let ((type-description
	    (or (get type 'defstruct-type-description)
		(defstruct-error "Unknown type in defstruct" type 'in name))))
      (when named-p
	(setq type (or (defstruct-type-description-named-type)
		       (defstruct-error "There is no way to make this defstruct type named"
					type 'in name)))
	(setq type-description (or (get type 'defstruct-type-description)
				   (defstruct-error "Unknown type in defstruct"
						    type 'in name))))
      (setf (defstruct-description-type) type)
      (setf (defstruct-description-named-p)
	    (setq named-p (eq (defstruct-type-description-named-type) type))))
    (when included
      (let ((d (get-defstruct-description included)))
	(unless (eq type (defstruct-description-type d))
	  (defstruct-error "defstruct types must agree for include option"
			   included 'included 'by name))
	(if (null but-first)
	    (setf (defstruct-description-but-first)
		  (defstruct-description-but-first d))
	    (or (equal but-first (defstruct-description-but-first d))
		(defstruct-error "but-first options must agree for include option"
				 included 'included 'by name)))))

    (setf (defstruct-description-conc-name)
	  (cond ((defstruct-emptyp conc-name) (append-symbols name '-))
		((null conc-name) nil)
		(t (string conc-name))))
    (cond ((null pred-name))
	  (named-p
	   (setf (defstruct-description-predicate) (if (defstruct-emptyp pred-name)
						       (append-symbols name '-p)
						       pred-name)))
	  ((not (defstruct-emptyp pred-name))
	   (defstruct-error
	     "A predicate may not be specified if the structure is not named")))
    (setf (defstruct-description-copier) (if (defstruct-emptyp copier)
					     (append-symbols 'copy- name)
					     copier))
    (cond ((defstruct-emptyp constructors)
	   (setq constructors
		 (list (cons (append-symbols 'make- name)
			     nil)))))
    (setf (defstruct-description-constructors) constructors)
    (cond ((defstruct-emptyp alterant)
	   (setq alterant
		 (append-symbols 'alter- name))))
    (setf (defstruct-description-alterant) alterant)
    description))

(defun defstruct-parse-cl-items (items description)
  (let ((name (defstruct-description-name))
	(offset (defstruct-description-initial-offset))
	(include (defstruct-description-include))
	(o-slot-alist nil)
	(conc-name (defstruct-description-conc-name)))
    (or (null include)
	(let ((d (get (car include) 'defstruct-description)))
	  (setq offset (+ offset (defstruct-description-size d))) 
	  (setq o-slot-alist (copytree (defstruct-description-slot-alist d)))
	  (do ((l (cdr include) (cdr l))
	       (it) (val))
	      ((null l))
	    (cond ((atom (setq it (car l)))
		   (setq val (make-empty)))
		  (t
		   (setq val (cadr it))
		   (setq it (car it))))
	    (let ((slot-description (cdr (assq it o-slot-alist))))
	      (and (null slot-description)
		   (defstruct-error
		     "Unknown slot in included defstruct"
		     it 'in include 'included 'by name))
	      (setf (defstruct-slot-description-init-code) val)))
	  (when conc-name
	    (do ((l o-slot-alist (cdr l)))
		((null l))
	      (let ((slot-description (cdar l)))
		(setf (defstruct-slot-description-ref-macro-name)
		      (append-symbols conc-name (caar l))))))))
    (let ((slots
	    (do ((i offset (1+ i))
		 (l items (cdr l))
		 (slot-alist nil))
		((null l)
		 (setq slot-alist (nreverse slot-alist))
		 (setf (defstruct-description-size) i)
		 (setf (defstruct-description-slot-alist) (nconc o-slot-alist slot-alist))
		 (if (and include conc-name)
		     (defstruct-description-slot-alist)
		     slot-alist))
	      (cond ((atom (car l))
		     (push (defstruct-parse-one-cl-field (car l) i nil nil conc-name)
			   slot-alist))
		    ((atom (caar l))
		     (push (defstruct-parse-one-cl-field (caar l) i (cdar l) nil conc-name)
			   slot-alist))
		    (t
		     (do ((ll (car l) (cdr ll)))
			 ((null ll))
		       (push (defstruct-parse-one-cl-field (caar ll) i (cdar ll) t conc-name)
			     slot-alist)))))))
      ;;; first check for duplicates
      (do ((slots slots (cdr slots)))
	  ((null slots))
	(when (lisp:member (car (first slots)) (cdr slots)
			   :test #'string= :key #'car)
	  ;;; ANSI doesn't specify what error to signal here.  ***ANSI-COMPATABILITY***
	  (error "The slot name ~a appears multiple times in the definition of ~a"
		 (caar slots) (defstruct-description-name))))
      slots)))

(defun defstruct-parse-one-cl-field (name number rest packed conc-name)
  (let ((mname (if conc-name (append-symbols conc-name name) name))
	(init-code (if (null rest) (make-empty) (pop rest)))
	(byte nil)
	(type 't)
	(plist nil))
    (do () ((null rest))
      (selectq (car rest)
	(:type (setq type (cadr rest)))
	(:byte (unless packed
		 (defstruct-error ":BYTE is illegal in non-packed defstruct slot" name))
	       (setq byte (cadr rest)))
	(:initialized (when (null (cadr rest))
			(setq init-code (make-empty))))
	(otherwise
	 (if (and (symbolp (car rest)) (get (car rest) 'defstruct-slot-property))
	     (putprop (locf plist) (cadr rest) (car rest))
	     (defstruct-error "Unrecognized slot option" (car rest) 'in 'slot name))))
      (setq rest (cddr rest)))
    (cons name (make-defstruct-slot-description
		 number number
		 ppss byte
		 init-code init-code
		 type type
		 property-alist plist
		 ref-macro-name mname))))

(defprop :read-only t defstruct-slot-property)

(defvar *enable-defstruct-read-only-checking* t)

(defun defstruct-slot-read-only-p (structure-name slot-name)
  (when *enable-defstruct-read-only-checking*
    (get (locf (defstruct-slot-description-property-alist
		 (cdr (assq slot-name (defstruct-description-slot-alist
					(get-defstruct-description structure-name))))))
	 :read-only)))

(defun defstruct-setf-method (slot &rest args)
  (cl:get-setf-method (defstruct-expand-ref-macro `(,slot ,@args))))

(defun setf-defstruct-read-only-slot (reference)
  (error "Attempt to SETF read-only DEFSTRUCT slot: ~S" reference))

(defun locf-defstruct-read-only-slot (reference)
  (error "Attempt to LOCF read-only DEFSTRUCT slot: ~S" reference))


;;; Build constructor as a subst rather than a macro
;;; Note that this disallows the "cons-keywords" feature of ZL defstruct

(defun defstruct-define-cons-function (name constructor-description
				       description type-description)
  ;; Develop the argument list for the subst we will generate, into lambda-list
  (let* ((slot-alist (defstruct-description-slot-alist))
	 (lambda-list (if (null constructor-description)
			  `(&key ,.(mapcar #'car slot-alist))
			  (copylist (first constructor-description))))
	 (kludge (cons nil nil)))
    ;; Lambda variables that lack an explicit default get it from the slot
    ;; Generate the construction code in terms of these lambda variables, into kludge
    (do ((l lambda-list (cdr l))
	 (optional nil)
	 (var) (slot-description))
	((null l))
      (setq var (car l))
      (cond ((memq var lambda-list-keywords)
	     (cond ((memq var '(&optional &aux &key))
		    (setq optional t))
		   ((eq var '&rest)
		    (setq optional nil))))
	    (t
	     (when (and optional (symbolp var))
	       (unless (setq slot-description (cdr (assq var slot-alist)))
		 (defstruct-error "Unknown slot name" var 'in 'constructor name))
	       (unless (defstruct-emptyp (defstruct-slot-description-init-code))
		 (setf (car l) (list (car l) (defstruct-slot-description-init-code)))))
	     (unless (atom var)
	       (setq var (car var)))
	     (defstruct-make-init-dsc kludge var var slot-alist nil name))))
    ;; Generate construction code for slots not settable by arguments
    (do ((l slot-alist (cdr l)))
	((null l))
      (let* ((name (caar l))
	     (slot-description (cdar l))
	     (code (defstruct-slot-description-init-code))
	     (ppss (defstruct-slot-description-ppss)))
	(or (and (defstruct-emptyp code) (null ppss))
	    (let* ((number (defstruct-slot-description-number))
		   (dsc (assoc number (car kludge))))
	      (cond ((null dsc)
		     (setq dsc (list* number nil (make-empty) 0 0 nil))
		     (push dsc (car kludge))))
	      (cond ((defstruct-emptyp code))
		    ((eq t (cadr dsc)))
		    ((null ppss)
		     (and (defstruct-emptyp (car (cddr dsc)))
			  (setf (car (cddr dsc)) code)))
		    ((memq name (cadr dsc)))
		    ((and (numberp ppss) (numberp code))
		      (let ((ppss (defstruct-adjust-byte-specifier ppss)))
			(setf (ldb ppss (cadr (cddr dsc))) -1)
			(setf (ldb ppss (caddr (cddr dsc))) code)))
		     ((and (numberp ppss) (zerop (byte-size ppss)))
		      (push (cons (byte 1 (byte-position ppss))
				  `(if ,code 1 0))
			    (cdddr (cddr dsc))))
		    (t
		     (push (cons ppss code) (cdddr (cddr dsc)))))))))
    ;; Process special constructor keywords
    ;;--- This is kludged up unmodularly so I don't have to change all
    ;;--- the type-definitions; fix this later.
    ;; E.g. append any make-array &KEY arguments to the lambda-list
    (let ((additional-keywords nil))    
      (dolist (key (defstruct-type-description-cons-keywords))
	(selectq key
	  (:make-array
	    (let ((x (cdr (assq ':constructor-make-array-keywords
				(defstruct-description-property-alist)))))
	      (when x
		(setq additional-keywords (append additional-keywords x))
		(push (cons ':make-array
			    (loop for x in x
				  do (unless (atom x) (setq x (car x)))
				  collect (intern (string x) pkg-keyword-package)
				  collect x))
		      (cdr kludge)))))
	  (:times
	    (setq additional-keywords (append additional-keywords '((times 1))))
	    (push `(:times . times) (cdr kludge)))
	  (otherwise (ferror "~S cons-keyword not handled; more kludges required" key))))
      (when additional-keywords
	(let ((l (or (memq '&key lambda-list)
		     (memq '&aux lambda-list))))
	  (setq lambda-list (append (ldiff lambda-list l)
				    (cons '&key (append additional-keywords
							(if (eq (car l) '&key)
							    (cdr l) l))))))))
    ;; Finalize the code
    (do ((l (car kludge) (cdr l)))
	((null l))
      (rplacd (car l) (defstruct-code-from-dsc (car l))))
    ;; Assemble it all into a subst
    `(progn
       ,(defstruct-inline-proclamation description :constructor name)
       (defun ,name ,lambda-list
	 (declare (sys:function-parent ,(defstruct-description-name) defstruct))
	 ,(invoke-defstruct-constructor-expander description type-description
						 (car kludge) (cdr kludge))))))



;;; Given the name of a structure, return the name of a by-keyword constructor
;;; macro for that structure.  If none exists, NIL is returned.
(defun get-defstruct-constructor-macro-name (structure-name)
  (let ((desc (get structure-name 'defstruct-description)))
    (when desc
      (return-from get-defstruct-constructor-macro-name
	(values (dolist (x (defstruct-description-constructors desc))
		  (when (null (rest1 x))
		    (return (first x))))
		t))))
  nil)

(defun get-structure-init-list (structure)
  (declare (values init-list structure-name))
  (let* ((structure-name (named-structure-p structure))
	 (description (get structure-name 'defstruct-description)))
    (when description
      (values (loop for (slot . plist) in (defstruct-description-slot-alist description)
		    collect (intern (get-pname slot) pkg-keyword-package)
		    collect (eval `(,(defstruct-slot-description-ref-macro-name plist)
				    ',structure)))
	      structure-name))))

(defun default-structure-fasd-form (structure)
  (multiple-value-bind (init-list structure-name)
      (get-structure-init-list structure)
    (when structure-name
      (let ((constructor (get-defstruct-constructor-macro-name structure-name)))
	(when constructor
	  (list* constructor init-list))))))


;;;------ Historical Data --------

;The master copy of this file is in MC:ALAN;NSTRUCT > [++ but see below]
;The current PDP10 MacLisp copy is in MC:ALAN;STRUCT > 
;The current Lisp machine copy is in SYS:SYS2;STRUCT LISP >
;  The above line is obviously obsolete, since there is no more AI machine
;  The current Symbolics copy is in SCRC|QUABBIN:>sys>sys2>struct.lisp.newest --RWK
;The current Multics MacLisp copy is in >udd>Mathlab>Bawden>defstruct.lisp
;  on MIT-Multics
;The current VMS-NIL copy is in [NIL.SRC.SPEC]STRUCT.LSP on HTJR

;*****  READ THIS PLEASE!  ***** [++ But see below]
;If you are thinking of munging anything in this file you might want to
;consider finding me (ALAN) and asking me to mung it for you.  There is more
;than one copy of this file in the world (it runs in PDP10 and Multics MacLisp,
;NIL, Franz, PSL and on LispMachines) and whatever amazing features you are
;considering adding might be usefull to those people as well.  If you still
;cannot contain yourself long enough to find me, AT LEAST send me a piece of
;mail describing what you did and why.  Thanks for reading this flame.
;[++ But see below]
;				Alan Bawden (ALAN@MC)
;
;
;Currently the Symbolics copy of this program has been allowed to diverge
;somewhat from Bawden's copy.  They might be merged back together at
;some convenient time in the future.
;
;[++ This is below]  ALAN no longer takes responsibility for the LispM
;implementation of defstruct (see message of 13 September 1984
;10:57-EDT from ALAN to Bug-LispM@SCRC-TENEX).  The above comment is
;mostly for historical purposes; he need not be asked to munge the
;master any more.

;;; 10 October 1985.  On the advice that the multi-sexuality of this file is 
;;; of no further use to Symbolics, Inc., I commented out this entire region, and
;;; replaced it by the un-commented out form for the LispM.  This makes defstruct
;;; patchable in most cases.  Others can continue this process as the need arises.
;;; --BIM

;;; 13 April 1986.  I removed the commented out region, plus some additional sharpsign and
;;; run-time conditionalized code, because some of that code had syntax that confused
;;; zwei's paren checking, and much of the rest of it confused the m-. command (and me).
;;; Computer archeologists should refer to the backup tapes or Release 6 distribution
;;; for that information.  --RWK

;;; 27 January 1987:  I removed all remaining non-Symbolics conditionalizations. --Hornig
