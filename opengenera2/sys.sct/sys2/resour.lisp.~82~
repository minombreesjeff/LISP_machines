;;;-*- Mode:LISP; Package: SYSTEM-INTERNALS; Base:8. -*-

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This file is in the cold load.

;;; New version of resource package, subsumes system-window facility
;;; Note that WITH-RESOURCE is obsolete because it takes its "arguments"
;;; in the wrong order.  It has been replaced by USING-RESOURCE.

;;; Old form of DEFRESOURCE:
;;;	(DEFRESOURCE [name | (name dont-make-initial-copy)] . creator-body)
;;; New form of DEFRESOURCE:
;;;	(DEFRESOURCE name parameters keyword value keyword value ...)
;;;  Keywords are:
;;;	:CONSTRUCTOR form   (this is required unless :FINDER is used)
;;;		Sees parameters as arguments.
;;;	:FINDER form
;;;		Sees parameters as arguments.
;;;	:CHECKER form
;;;		Sees OBJECT and IN-USE-P (in current package) and parameters as arguments.
;;;	:MATCHER form
;;;		Sees OBJECT (in current package) and parameters as arguments.
;;;	:INITIALIZER form
;;;		Sees OBJECT and parameters as arguments.
;;;	:DEINITIALIZER form
;;;		Sees OBJECT as argument.
;;;	  In the above six options, form may also be a symbol which is a function to call.
;;;	  It gets the resource data structure as its first argument then the specified args.
;;;	:INITIAL-COPIES number  (default 0)
;;;		If this is specified, all parameters must be &optional and
;;;		have suitable defaults.  This is generally a good idea anyway.
;;;		Specifying NIL here is the same as zero.
;;;     :FREE-LIST-SIZE number  (default 20.)
;;;		If this is specified, the size of the free-list for this resource
;;;		will initially be that number.
;;;	:CLEAR-FOR-GC type
;;;		If this is specified, a garbage collection of the specified type
;;;		will discard all the objects in the resource.  The argument <type>
;;;		is one of :SYSTEM-RELEASE, :FULL-GC, or :CLEANUP
;;;
;;;  If :FINDER is specified, we keep no record of free objects and use :FINDER
;;;  to find a free one by looking through the general environment.  The :CONSTRUCTOR
;;;  form is ignored in this case.
;;;  Otherwise we keep a table of objects and whether they are free.
;;;  If :CHECKER is specified, then it gets to pass on each object to decide whether
;;;  or not to reuse it, whether or not it is already marked as in-use.
;;;  If :MATCHER is specified, we use it to check objects against the parameters.
;;;  Otherwise the table also includes the parameter values, which are checked
;;;  with CL:EQUAL (not EQ).
;;;
;;;  The matcher and checker are called without-interrupts.
;;;  The finder, constructor, and initializer are not.
;;;  The deinitializer can be called either way.
;;;
;;;  Possible feature that might be added: ability to keep a free list threaded
;;;  through the objects.
;;;
;;;  Note: for windows, you typically want to use DEFWINDOW-RESOURCE,
;;;  which supplies the right options to DEFRESOURCE.
;;;
;;; DEFRESOURCE no longer uses the value and function cells of the resource's name.
;;; It puts on a DEFRESOURCE property of the following defstruct.  Note: only the
;;; functions right here are "allowed" to know what is in this structure.
;;;
;;; Resources are synchronized by manipulating the resource-structure in a
;;; (WITH-RESOURCE-LOCKED ...) form, which is really (WITHOUT-INTERRUPTS...).
;;; Using a real lock might be nice, but there would be bad problems with
;;; being robust against aborts, and more importantly, resources are often
;;; used in places where it is not valid to PROCESS-WAIT.
;;; It is very complicated to fix the world to be able to use locks instead,
;;; but, he said, with a far off look in his eyes, "I have a plan ..."

(DEFSTRUCT (RESOURCE (:TYPE :NAMED-ARRAY-LEADER)
		     :CONC-NAME)
  (N-OBJECTS 0)			;Total number of objects in resource.  Fill pointer
                                ;for array, but not valid as a fill-pointer since a
				;resource-element occupies multiple array elements.
  (FIRST-FREE-OBJECT 0)		;Index of lowest object on the free list
  NAME				;Symbol which names this resource
  (VERSION-NUMBER 2)		;So we can introduce changes in data structure more easily.
  				;All the code in this file works with VERSION-NUMBER = 2
  PARAMETIZER			;Function which defaults the parameters and returns them
  CONSTRUCTOR			;Constructor function
  MATCHER			;Optional matcher function
  CHECKER			;Optional checker function
  INITIALIZER			;Optional initializer function
  DEINITIALIZER			;Optional deinitializer function
  ALLOCATOR			;Allocator function, (may be old finder function)
  NUMBER-OF-PARAMS		;Maximum number of arguments accepted
  USER-DEFINED-ALLOCATOR?	;True if ALLOCATOR is really FINDER
  LOCK				;For synchronization (not used)
  CLEAR-FOR-GC			;When the resource can be cleared to make space.
  ARGLIST			;lambda-list supplied with DEFRESOURCE, for documentation
  )

;; The array portion of a version-2 RESOURCE is a grouped-array of this form.
;; Usage of the PARAMETER-1 and PARAMETER-2 fields depends on RESOURCE-NUMBER-OF-PARAMS:
;;   0	not used
;;   1  PARAMETER-1 is the parameter
;;   2	PARAMETER-1 is the first parameter, PARAMETER-2 is the second
;; else PARAMETER-1 is a list of the parameters
;; Note that in any case these are the processed parameters, after defaulting of
;; optionals and stripping of keywords, not the raw parameters supplied by the user.
;; The constructor receives the raw parameters, but the processed parameters
;; are stored for matching reused objects.
;; We choose to store two parameters because the majority of resources have two
;; or fewer (and most resources with more have many more), and because that
;; makes RESOURCE-ELEMENT-SIZE a power of 2.
(DEFSTRUCT (RESOURCE-ELEMENT :GROUPED-ARRAY :CONC-NAME (:DEFAULT-POINTER RESOURCE)
			     (:SIZE-MACRO RESOURCE-ELEMENT-SIZE)
			     (:CONSTRUCTOR NIL) (:ALTERANT NIL))
  OBJECT			;The object itself
  (IN-USE-P NIL)		;NIL => free, T => allocated
  PARAMETER-1
  PARAMETER-2)

(DEFCONSTANT RESOURCE-ELEMENT-SIZE (RESOURCE-ELEMENT-SIZE))

(DEFUN RESOURCE-ELEMENT-PARAMETERS (INDEX RESOURCE)
  (UNLESS (OR (RESOURCE-USER-DEFINED-ALLOCATOR? RESOURCE)	;no parameters stored
	      (RESOURCE-MATCHER RESOURCE))			;..
    (CL:CASE (RESOURCE-NUMBER-OF-PARAMS RESOURCE)
      (0 NIL)
      (1 (LIST (RESOURCE-ELEMENT-PARAMETER-1 INDEX RESOURCE)))
      (2 (LIST (RESOURCE-ELEMENT-PARAMETER-1 INDEX RESOURCE)
	       (RESOURCE-ELEMENT-PARAMETER-2 INDEX RESOURCE)))
      (OTHERWISE (RESOURCE-ELEMENT-PARAMETER-1 INDEX RESOURCE)))))

(DEFMACRO SWAP-RESOURCE-ELEMENTS (INDEX1 INDEX2)
  `(LET ((OBJECT (RESOURCE-ELEMENT-OBJECT ,INDEX1))
	 (IN-USE-P (RESOURCE-ELEMENT-IN-USE-P ,INDEX1))
	 (PARAMETER-1 (RESOURCE-ELEMENT-PARAMETER-1 ,INDEX1))
	 (PARAMETER-2 (RESOURCE-ELEMENT-PARAMETER-2 ,INDEX1)))
     (SETF (RESOURCE-ELEMENT-OBJECT ,INDEX1) (RESOURCE-ELEMENT-OBJECT ,INDEX2))
     (SETF (RESOURCE-ELEMENT-IN-USE-P ,INDEX1) (RESOURCE-ELEMENT-IN-USE-P ,INDEX2))
     (SETF (RESOURCE-ELEMENT-PARAMETER-1 ,INDEX1) (RESOURCE-ELEMENT-PARAMETER-1 ,INDEX2))
     (SETF (RESOURCE-ELEMENT-PARAMETER-2 ,INDEX1) (RESOURCE-ELEMENT-PARAMETER-2 ,INDEX2))
     (SETF (RESOURCE-ELEMENT-OBJECT ,INDEX2) OBJECT)
     (SETF (RESOURCE-ELEMENT-IN-USE-P ,INDEX2) IN-USE-P)
     (SETF (RESOURCE-ELEMENT-PARAMETER-1 ,INDEX2) PARAMETER-1)
     (SETF (RESOURCE-ELEMENT-PARAMETER-2 ,INDEX2) PARAMETER-2)))

#|
(DEFMACRO WITH-RESOURCE-LOCKED
	  ((RESOURCE
	     &OPTIONAL (COMMIT-POINT-REACHED? 'COMMIT-POINT PROVIDED?)
	     &BODY CLEANUP-FORMS)
	   &BODY BODY)
  (LET ((LOCK-POINTER (GENSYM)))
    `(LET ((,LOCK-POINTER (LOCF (RESOURCE-LOCK ,RESOURCE))))
       (UNWIND-PROTECT
	   (PROGN
	     (UNLESS
	       (STORE-CONDITIONAL ,LOCK-POINTER NIL CURRENT-PROCESS)
	       (PROCESS-LOCK ,LOCK-POINTER CURRENT-PROCESS "Resource Lock"))
	     . ,BODY)
	 ,@(WHEN PROVIDED? `(UNLESS ,COMMIT-POINT-REACHED? ,@CLEANUP-FORMS))
	 (STORE-CONDITIONAL ,LOCK-POINTER CURRENT-PROCESS NIL)))))
|#

(DEFMACRO WITH-RESOURCE-LOCKED
	  ((RESOURCE
	     &OPTIONAL (COMMIT-POINT-REACHED? 'COMMIT-POINT PROVIDED?)
	     &BODY CLEANUP-FORMS)
	   &BODY BODY)
  (PROGN
    (IGNORE RESOURCE COMMIT-POINT-REACHED? PROVIDED? CLEANUP-FORMS)
    `(WITHOUT-INTERRUPTS ,@BODY)))


(DEFSELECT ((:PROPERTY RESOURCE NAMED-STRUCTURE-INVOKE) NIL NO-WHICH-OPERATIONS)
  ;; This is done this weird way so as to work on the L machine in the cold load.
  (:WHICH-OPERATIONS (IGNORE) '(:DESCRIBE :PRINT-SELF :FASD-FORM))
  (:PRINT-SELF (RESOURCE STREAM IGNORE IGNORE)
   (SYS:PRINTING-RANDOM-OBJECT (RESOURCE STREAM :TYPEP)
     (FORMAT STREAM "~A" (RESOURCE-NAME RESOURCE))))
  (:DESCRIBE (RESOURCE)
   (DESCRIBE-RESOURCE RESOURCE))
  (:FASD-FORM (RESOURCE)
   `(FIND-RESOURCE ',(RESOURCE-NAME RESOURCE))))

;; Called at load time when a resource has been used as a constant in COMPILE-FILE.
(DEFUN FIND-RESOURCE (RESOURCE-NAME)
  (OR (GET RESOURCE-NAME 'DEFRESOURCE)
      ;; If this is a forward reference, create a dummy resource object.
      (PROGN
	(INITIALIZE-RESOURCE RESOURCE-NAME
			     NIL 'ALLOCATE-FROM-UNDEFINED-RESOURCE
			     NIL NIL NIL 0 24 NIL NIL 0 NIL NIL NIL 2)
	(GET RESOURCE-NAME 'DEFRESOURCE))))

(DEFUN ALLOCATE-FROM-UNDEFINED-RESOURCE (RESOURCE &REST IGNORE)
  (DECLARE (DBG:ERROR-REPORTER))
  (ERROR "The resource ~S has not been defined." (RESOURCE-NAME RESOURCE)))

(DEFCONST *DEFRESOURCE-KEYWORDS*
	  '(:CONSTRUCTOR :FINDER :MATCHER :CHECKER
			 :INITIALIZER :DEINITIALIZER :INITIAL-COPIES :FREE-LIST-SIZE)
  ;; used by defwindow-resource to determine what extra keywords to pass through
  "Keywords accepted by defresource.")

(DEFPROP DEFRESOURCE "Resource" DEFINITION-TYPE-NAME)

; add (resource-number-of-params resource), and (resource-user-defined-allocator? resource)
(DEFMACRO DEFRESOURCE (NAME PARAMETERS &REST OPTIONS)
  ;; Old format?
  (IF (OR (LISTP NAME) (NULL OPTIONS) (LISTP (CAR OPTIONS)))
      (PROGN (FORMAT ERROR-OUTPUT "~&WARNING: Obsolete form of DEFRESOURCE ~S.~%" NAME)
	     `(DEFRESOURCE ,(IF (LISTP NAME) (CAR NAME) NAME)
			   ()
			   :INITIAL-COPIES ,(IF (AND (LISTP NAME) (CADR NAME)) 0 1)
			   :CONSTRUCTOR (PROGN ,PARAMETERS ,@(COPYLIST OPTIONS))))
      (LET ((CONSTRUCTOR-FORM NIL) (FINDER-FORM NIL) (MATCHER-FORM NIL) (CHECKER-FORM NIL)
	    (CONSTRUCTOR-FUNCTION NIL) (FINDER-FUNCTION NIL) (MATCHER-FUNCTION NIL)
	    (PARAMETIZER-FUNCTION NIL) (CHECKER-FUNCTION NIL) (INITIAL-COPIES 0)
	    (INITIALIZER-FORM NIL) (INITIALIZER-FUNCTION NIL)
	    (DEINITIALIZER-FORM NIL) (DEINITIALIZER-FUNCTION NIL)
	    (ALLOCATOR-FUNCTION NIL)
	    (CLEAR-FOR-GC NIL) (FREE-LIST-SIZE 20.)
	    (USER-DEFINED-ALLOCATOR NIL)
	    (PARAMETIZER-RETURN 'LIST)
	    (LL-INFO (LT:PARSE-LAMBDA-LIST PARAMETERS)))
	(LOOP FOR (KEYWORD VALUE) ON OPTIONS BY #'CDDR
	      DO (SELECTQ KEYWORD
		   (:CONSTRUCTOR (SETQ CONSTRUCTOR-FORM VALUE))
		   (:FINDER (SETQ FINDER-FORM VALUE))
		   (:MATCHER (SETQ MATCHER-FORM VALUE))
		   (:CHECKER (SETQ CHECKER-FORM VALUE))
		   (:INITIALIZER (SETQ INITIALIZER-FORM VALUE))
		   (:DEINITIALIZER (SETQ DEINITIALIZER-FORM VALUE))
		   (:INITIAL-COPIES
		     (SETQ INITIAL-COPIES
			   (COND ((NULL VALUE) 0)
				 ((NUMBERP VALUE) VALUE)
				 (T
				  (WARN
				    ":INITIAL-COPIES ~S can not be evaluated at compile time"
				    VALUE)
				  VALUE))))
		   (:CLEAR-FOR-GC
		    (WHEN (EQ VALUE T)
		      (SETQ VALUE :SYSTEM-RELEASE))
		    (CL:CHECK-TYPE VALUE (CL:MEMBER :SYSTEM-RELEASE :FULL-GC :CLEANUP))
		    (SETQ CLEAR-FOR-GC VALUE))
		   (:FREE-LIST-SIZE
		    (SETQ FREE-LIST-SIZE
			  (COND ((NULL VALUE) 20.)
				((NUMBERP VALUE) VALUE)
				(T (FERROR ":FREE-LIST-SIZE ~S - number required")))))
		   (OTHERWISE (FERROR "~S illegal option in DEFRESOURCE" KEYWORD))))
	(OR CONSTRUCTOR-FORM FINDER-FORM
	    (ERROR "DEFRESOURCE ~S requires either the :CONSTRUCTOR or the :FINDER option"
		   NAME))
	;;Pick function names.  Note that NIL is SYMBOLP.
	(SETQ CONSTRUCTOR-FUNCTION (IF (SYMBOLP CONSTRUCTOR-FORM) CONSTRUCTOR-FORM
				       `(:PROPERTY ,NAME RESOURCE-CONSTRUCTOR)))
	(SETQ FINDER-FUNCTION (IF (SYMBOLP FINDER-FORM) FINDER-FORM
				  `(:PROPERTY ,NAME RESOURCE-FINDER)))
	(SETQ MATCHER-FUNCTION (IF (SYMBOLP MATCHER-FORM) MATCHER-FORM
				   `(:PROPERTY ,NAME RESOURCE-MATCHER)))
	(SETQ CHECKER-FUNCTION (IF (SYMBOLP CHECKER-FORM) CHECKER-FORM
				   `(:PROPERTY ,NAME RESOURCE-CHECKER)))
	(SETQ INITIALIZER-FUNCTION (IF (SYMBOLP INITIALIZER-FORM) INITIALIZER-FORM
				     `(:PROPERTY ,NAME RESOURCE-INITIALIZER)))
	(SETQ DEINITIALIZER-FUNCTION (IF (SYMBOLP DEINITIALIZER-FORM) DEINITIALIZER-FORM
				       `(:PROPERTY ,NAME RESOURCE-DEINITIALIZER)))
	(SETQ PARAMETIZER-FUNCTION (IF (AND (NOT MATCHER-FORM) (NOT FINDER-FORM)
					    (OR (LT:LLI-REST LL-INFO) (LT:LLI-KEY LL-INFO)
						(> (LT:LLI-N-OPTIONAL LL-INFO) 0)))
				       `(:PROPERTY ,NAME RESOURCE-PARAMETIZER)))
	(SETQ USER-DEFINED-ALLOCATOR (NOT (NULL FINDER-FUNCTION)))
	;; Special case various configurations to optimize allocator.
	(SETQ ALLOCATOR-FUNCTION
	      (OR FINDER-FUNCTION	;The man rolls his own, ain't nuthin we can do.
		  (LET ((N-REQ (LT:LLI-N-REQUIRED LL-INFO))
			(N-OPT (LT:LLI-N-OPTIONAL LL-INFO))
			(REST (OR (LT:LLI-REST LL-INFO) (LT:LLI-KEY LL-INFO))))
		    (UNLESS (OR REST (> (+ N-REQ N-OPT) 2))
		      (SETQ PARAMETIZER-RETURN (IF (AND (= N-REQ 1) (= N-OPT 1))
						   `(LAMBDA (ARG1 ARG2)
						      (DECLARE (IGNORE ARG1))
						      ARG2)
						   'VALUES)))
		    (COND (MATCHER-FUNCTION	;hence no parametizer
			   (IF (OR REST (PLUSP N-OPT))
			       'RESOURCE-ALLOCATOR-N
			       (CL:CASE N-REQ
				 (0 'RESOURCE-ALLOCATOR-0)
				 (1 'RESOURCE-ALLOCATOR-1)
				 (2 'RESOURCE-ALLOCATOR-2)
				 (OTHERWISE 'RESOURCE-ALLOCATOR-N))))
			  (CHECKER-FUNCTION
			   (IF (OR REST (> (+ N-REQ N-OPT) 2))
			       'RESOURCE-ALLOCATOR-N
			       (CL:CASE (+ (* N-REQ 10) N-OPT)
				 (00 'RESOURCE-ALLOCATOR-0)
				 (10 'RESOURCE-ALLOCATOR-1)
				 (20 'RESOURCE-ALLOCATOR-2)
				 (01 'RESOURCE-ALLOCATOR-1-OPTIONAL)
				 (02 'RESOURCE-ALLOCATOR-2-OPTIONAL)
				 (11 'RESOURCE-ALLOCATOR-1-REQUIRED-1-OPTIONAL))))
			  (INITIALIZER-FUNCTION
			   (IF (OR REST (> (+ N-REQ N-OPT) 2))
			       'RESOURCE-ALLOCATOR-N
			       (CL:CASE (+ (* N-REQ 10) N-OPT)
				 (00 'RESOURCE-ALLOCATOR-INIT-0)
				 (10 'RESOURCE-ALLOCATOR-INIT-1)
				 (20 'RESOURCE-ALLOCATOR-INIT-2)
				 (01 'RESOURCE-ALLOCATOR-1-OPTIONAL)
				 (02 'RESOURCE-ALLOCATOR-2-OPTIONAL)
				 (11 'RESOURCE-ALLOCATOR-1-REQUIRED-1-OPTIONAL))))
			  (T
			   (IF (OR REST (> (+ N-REQ N-OPT) 2))
			       'RESOURCE-ALLOCATOR-SIMPLE-N
			       (CL:CASE (+ (* N-REQ 10) N-OPT)
				 (00 'RESOURCE-ALLOCATOR-SIMPLE-0)
				 (10 'RESOURCE-ALLOCATOR-SIMPLE-1)
				 (20 'RESOURCE-ALLOCATOR-SIMPLE-2)
				 (01 'RESOURCE-ALLOCATOR-SIMPLE-1-OPTIONAL)
				 (02 'RESOURCE-ALLOCATOR-SIMPLE-2-OPTIONAL)
				 (11 'RESOURCE-ALLOCATOR-SIMPLE-1-REQUIRED-1-OPTIONAL))))))))
	(LET* ((PARAMETER-NAMES (LOOP FOR P IN PARAMETERS
				      UNLESS (MEMQ P LAMBDA-LIST-KEYWORDS)
					COLLECT (IF (SYMBOLP P) P
						    (IF (SYMBOLP (CAR P)) (CAR P)
							(CAAR P)))))
	       (IGNORE-PARAMETERS-TO-AVOID-COMPILER-WARNINGS `(IGNORE ,@PARAMETER-NAMES)))
	  (WHEN (LT:LLI-REST LL-INFO)
	    (SETQ PARAMETER-NAMES (APPEND (REMOVE (LT:LLI-REST LL-INFO) PARAMETER-NAMES)
					  `((COPYLIST ,(LT:LLI-REST LL-INFO))))
		  PARAMETIZER-RETURN 'LIST*))
	  `(MULTIPLE-DEFINITION ,NAME DEFRESOURCE
	     ,(IF (NOT (SYMBOLP CONSTRUCTOR-FORM))
		  `(DEFUN ,CONSTRUCTOR-FUNCTION (IGNORE ,@PARAMETERS)
		     ,IGNORE-PARAMETERS-TO-AVOID-COMPILER-WARNINGS
		     ,CONSTRUCTOR-FORM))
	     ,(IF (NOT (SYMBOLP ALLOCATOR-FUNCTION))	; Can only mean user supplied form.
		  `(DEFUN ,FINDER-FUNCTION (IGNORE ,@PARAMETERS)
		     ,IGNORE-PARAMETERS-TO-AVOID-COMPILER-WARNINGS
		     ,FINDER-FORM))
	     ,(IF (NOT (SYMBOLP MATCHER-FORM))
		  `(DEFUN ,MATCHER-FUNCTION (IGNORE ,(INTERN "OBJECT") ,@PARAMETERS)
		     ,IGNORE-PARAMETERS-TO-AVOID-COMPILER-WARNINGS
		     ,MATCHER-FORM))
	     ,(IF (NOT (SYMBOLP CHECKER-FORM))
		  `(DEFUN ,CHECKER-FUNCTION (IGNORE ,(INTERN "OBJECT") ,(INTERN "IN-USE-P")
					     ,@PARAMETERS)
		     ,IGNORE-PARAMETERS-TO-AVOID-COMPILER-WARNINGS
		     ,CHECKER-FORM))
	     ,(IF (NOT (SYMBOLP INITIALIZER-FORM))
		  `(DEFUN ,INITIALIZER-FUNCTION (IGNORE ,(INTERN "OBJECT") ,@PARAMETERS)
		     ,IGNORE-PARAMETERS-TO-AVOID-COMPILER-WARNINGS
		     ,INITIALIZER-FORM))
	     ,(IF (NOT (SYMBOLP DEINITIALIZER-FORM))
		  `(DEFUN ,DEINITIALIZER-FUNCTION (IGNORE ,(INTERN "OBJECT"))
		     ,DEINITIALIZER-FORM))
	     ,(IF PARAMETIZER-FUNCTION
		  `(DEFUN ,PARAMETIZER-FUNCTION ,PARAMETERS
		     (,PARAMETIZER-RETURN ,@PARAMETER-NAMES)))
	     (INITIALIZE-RESOURCE ',NAME ',CONSTRUCTOR-FUNCTION ',ALLOCATOR-FUNCTION
				  ',MATCHER-FUNCTION ',CHECKER-FUNCTION
				  ',PARAMETIZER-FUNCTION ,INITIAL-COPIES ',FREE-LIST-SIZE
				  ',INITIALIZER-FUNCTION
				  ',DEINITIALIZER-FUNCTION
				  ',(+ (LT:LLI-N-REQUIRED LL-INFO)
				       (LT:LLI-N-OPTIONAL LL-INFO)
				       (IF (OR (LT:LLI-REST LL-INFO) (LT:LLI-KEY LL-INFO))
					   CL:CALL-ARGUMENTS-LIMIT
					   0))
				  ',USER-DEFINED-ALLOCATOR
				  ',CLEAR-FOR-GC
				  ',PARAMETERS
				  2))))))

(DEFVAR *ALL-RESOURCES* NIL)

(DEFUN INITIALIZE-RESOURCE (NAME CONSTRUCTOR-FUNCTION ALLOCATOR-FUNCTION MATCHER-FUNCTION
			    CHECKER-FUNCTION PARAMETIZER-FUNCTION INITIAL-COPIES
			    ;; Keep this &OPTIONAL for the time being so old QFASLs work.
			    &OPTIONAL (FREE-LIST-SIZE 20.)
			    INITIALIZER-FUNCTION DEINITIALIZER-FUNCTION
			    ;; These are optional so old DEFRESOURCEs that haven't been
			    ;; recompiled will still work.
			    NUMBER-OF-PARAMS USER-SUPPLIED CLEAR-FOR-GC PARAMETERS
			    ;; Version of DEFRESOURCE macro expansion, 7.4 was 1, 7.5 is 2
			    (VERSION-NUMBER 1))
  ;;--- Remove this in Release 8, when old BIN/IBIN files don't need to be supported
  (WHEN (OR (NULL ALLOCATOR-FUNCTION)	; Old version of defresource must have been used.
	    (NULL NUMBER-OF-PARAMS))	; because these can't be NIL in current version.
    (IF ALLOCATOR-FUNCTION
	(SETQ USER-SUPPLIED 'T)
	(SETQ ALLOCATOR-FUNCTION 'GENERAL-ALLOCATE-RESOURCE)))
  ;;--- Remove this in Release 8, when old BIN/IBIN files don't need to be supported
  (WHEN (= VERSION-NUMBER 1)
    ;; Repair number-of-params and convert old macroexpanded references to
    ;; functions that don't exist any more
    (MULTIPLE-VALUE (ALLOCATOR-FUNCTION NUMBER-OF-PARAMS)
      (UPGRADE-RESOURCE-ALLOCATOR PARAMETIZER-FUNCTION CONSTRUCTOR-FUNCTION MATCHER-FUNCTION
				  CHECKER-FUNCTION INITIALIZER-FUNCTION ALLOCATOR-FUNCTION))
    ;; Figure out the PARAMETERS argument, which was not supplied to us
    (CONDITION-CASE ()
	 (SETQ PARAMETERS (IF PARAMETIZER-FUNCTION
			      (ARGLIST PARAMETIZER-FUNCTION)
			      (CDR (ARGLIST (OR CONSTRUCTOR-FUNCTION ALLOCATOR-FUNCTION)))))
       (UNDEFINED-FUNCTION)))
  (OR (SYMBOLP CONSTRUCTOR-FUNCTION)
      (SETQ CONSTRUCTOR-FUNCTION (FDEFINITION CONSTRUCTOR-FUNCTION)))
  (WHEN (OR (LISTP ALLOCATOR-FUNCTION)
	    ;; Prefer speed over easy redefinability for the system-defined ones
	    (MEMQ ALLOCATOR-FUNCTION '(RESOURCE-ALLOCATOR-0 RESOURCE-ALLOCATOR-1
				       RESOURCE-ALLOCATOR-2 RESOURCE-ALLOCATOR-1-OPTIONAL
				       RESOURCE-ALLOCATOR-1-REQUIRED-1-OPTIONAL
				       RESOURCE-ALLOCATOR-2-OPTIONAL RESOURCE-ALLOCATOR-N
				       RESOURCE-ALLOCATOR-INIT-0 RESOURCE-ALLOCATOR-INIT-1
				       RESOURCE-ALLOCATOR-INIT-2 RESOURCE-ALLOCATOR-SIMPLE-0
				       RESOURCE-ALLOCATOR-SIMPLE-1 RESOURCE-ALLOCATOR-SIMPLE-2
				       RESOURCE-ALLOCATOR-SIMPLE-1-OPTIONAL
				       RESOURCE-ALLOCATOR-SIMPLE-1-REQUIRED-1-OPTIONAL
				       RESOURCE-ALLOCATOR-SIMPLE-2-OPTIONAL
				       RESOURCE-ALLOCATOR-SIMPLE-N)))
      (SETQ ALLOCATOR-FUNCTION (FDEFINITION ALLOCATOR-FUNCTION)))
  (OR (SYMBOLP MATCHER-FUNCTION)
      (SETQ MATCHER-FUNCTION (FDEFINITION MATCHER-FUNCTION)))
  (OR (SYMBOLP CHECKER-FUNCTION)
      (SETQ CHECKER-FUNCTION (FDEFINITION CHECKER-FUNCTION)))
  (OR (SYMBOLP INITIALIZER-FUNCTION)
      (SETQ INITIALIZER-FUNCTION (FDEFINITION INITIALIZER-FUNCTION)))
  (OR (SYMBOLP DEINITIALIZER-FUNCTION)
      (SETQ DEINITIALIZER-FUNCTION (FDEFINITION DEINITIALIZER-FUNCTION)))
  (OR (SYMBOLP PARAMETIZER-FUNCTION)
      (SETQ PARAMETIZER-FUNCTION (FDEFINITION PARAMETIZER-FUNCTION)))
  (WHEN (OR (> VERSION-NUMBER 1)	;inside of SYS:MULTIPLE-DEFINITION
	    (RECORD-SOURCE-FILE-NAME NAME 'DEFRESOURCE))
    (LET ((RESOURCE (GET NAME 'DEFRESOURCE)))
      (COND ((NULL RESOURCE)		;Defining for the first time
	     (WHEN USER-SUPPLIED (SETQ FREE-LIST-SIZE 0))
	     (SETQ RESOURCE (MAKE-RESOURCE NAME NAME
					   :MAKE-ARRAY
					    (:LENGTH (* FREE-LIST-SIZE RESOURCE-ELEMENT-SIZE)
					     :AREA PERMANENT-STORAGE-AREA)
					   PARAMETIZER PARAMETIZER-FUNCTION
					   CONSTRUCTOR CONSTRUCTOR-FUNCTION
					   ALLOCATOR ALLOCATOR-FUNCTION
					   MATCHER MATCHER-FUNCTION
					   CHECKER CHECKER-FUNCTION
					   INITIALIZER INITIALIZER-FUNCTION
					   DEINITIALIZER DEINITIALIZER-FUNCTION
					   NUMBER-OF-PARAMS NUMBER-OF-PARAMS
					   USER-DEFINED-ALLOCATOR? USER-SUPPLIED
					   CLEAR-FOR-GC CLEAR-FOR-GC
					   ARGLIST PARAMETERS))
	     (PUTPROP NAME RESOURCE 'DEFRESOURCE)
	     (CL:PUSHNEW NAME *ALL-RESOURCES* :LOCALIZE T))
	    (T				;Redefining
	     (WITH-RESOURCE-LOCKED (RESOURCE)
	       (CL:SETF (RESOURCE-PARAMETIZER RESOURCE) PARAMETIZER-FUNCTION
			(RESOURCE-CONSTRUCTOR RESOURCE) CONSTRUCTOR-FUNCTION
			(RESOURCE-ALLOCATOR RESOURCE) ALLOCATOR-FUNCTION
			(RESOURCE-MATCHER RESOURCE) MATCHER-FUNCTION
			(RESOURCE-CHECKER RESOURCE) CHECKER-FUNCTION
			(RESOURCE-INITIALIZER RESOURCE) INITIALIZER-FUNCTION
			(RESOURCE-DEINITIALIZER RESOURCE) DEINITIALIZER-FUNCTION
			(RESOURCE-NUMBER-OF-PARAMS RESOURCE) NUMBER-OF-PARAMS
			(RESOURCE-USER-DEFINED-ALLOCATOR? RESOURCE) USER-SUPPLIED
			(RESOURCE-CLEAR-FOR-GC RESOURCE) CLEAR-FOR-GC
			(RESOURCE-ARGLIST RESOURCE) PARAMETERS))))
      (LOOP FOR OBJECT IN (LOOP REPEAT INITIAL-COPIES COLLECT (ALLOCATE-RESOURCE NAME))
	    DO (DEALLOCATE-RESOURCE NAME OBJECT))))
  NAME)

;; Given pre-7.5 resource data, compute what we will use in 7.5
;; This can go away in Release 8
(DEFUN UPGRADE-RESOURCE-ALLOCATOR (PARAMETIZER CONSTRUCTOR MATCHER CHECKER
				   INITIALIZER ALLOCATOR)
  (DECLARE (VALUES ALLOCATOR NUMBER-OF-PARAMS))
  ;; Figure out what arguments the resource wants.  Prefer looking at the parametizer,
  ;; but if there isn't one, there will always be either a constructor or a user-defined
  ;; allocator (finder), so look there.
  (LET* ((ARGS-INFO (ARGS-INFO (OR PARAMETIZER CONSTRUCTOR ALLOCATOR)))
	 (REQ (LDB %%ARG-DESC-MIN-ARGS ARGS-INFO))
	 (MAX (IF (LDB-TEST %%ARG-DESC-REST-ARG ARGS-INFO) CL:CALL-ARGUMENTS-LIMIT
		  (LDB %%ARG-DESC-MAX-ARGS ARGS-INFO))))
    ;; CONSTRUCTOR and ALLOCATOR take one extra argument, the RESOURCE structure
    (UNLESS PARAMETIZER
      (DECF REQ)
      (DECF MAX))
    ;; Repair number-of-params, which used to be computed without regard for &optional, &rest
    (LET ((NUMBER-OF-PARAMS MAX))
      ;; Convert to the new allocator functions unless old allocator was user-defined
      (WHEN (MEMQ ALLOCATOR '(SIMPLE-ALLOCATE-RESOURCE SIMPLE-ALLOCATE-RESOURCE-INIT
			      GENERAL-ALLOCATE-RESOURCE
			      GENERAL-ALLOCATE-RESOURCE-WITHOUT-PARAMETERS))
	;; Can't use the ones that depend on the new parametizer calling sequence
	;; i.e. where there are optionals but no rest, so use -N instead.
	(UNLESS (= REQ MAX) (SETQ REQ -1))
	(SETQ ALLOCATOR (COND ((OR MATCHER CHECKER)
			       (CL:CASE REQ
				 (0 'RESOURCE-ALLOCATOR-0)
				 (1 'RESOURCE-ALLOCATOR-1)
				 (2 'RESOURCE-ALLOCATOR-2)
				 (OTHERWISE 'RESOURCE-ALLOCATOR-N)))
			      (INITIALIZER
			       (CL:CASE REQ
				 (0 'RESOURCE-ALLOCATOR-INIT-0)
				 (1 'RESOURCE-ALLOCATOR-INIT-1)
				 (2 'RESOURCE-ALLOCATOR-INIT-2)
				 (OTHERWISE 'RESOURCE-ALLOCATOR-N)))
			      (T
			       (CL:CASE REQ
				 (0 'RESOURCE-ALLOCATOR-SIMPLE-0)
				 (1 'RESOURCE-ALLOCATOR-SIMPLE-1)
				 (2 'RESOURCE-ALLOCATOR-SIMPLE-2)
				 (OTHERWISE 'RESOURCE-ALLOCATOR-SIMPLE-N))))))
      (VALUES ALLOCATOR NUMBER-OF-PARAMS))))

(DEFUN UNDEFRESOURCE (RESOURCE-NAME &AUX RESOURCE)
  (CHECK-ARG RESOURCE-NAME (SETQ RESOURCE (GET RESOURCE-NAME 'DEFRESOURCE))
	     "the name of a resource")
  (WITH-RESOURCE-LOCKED (RESOURCE)
    RESOURCE
    (CLEAR-RESOURCE RESOURCE-NAME)
    (SETQ *ALL-RESOURCES* (DELQ RESOURCE-NAME *ALL-RESOURCES*))
    (DOLIST (PROPERTY '(DEFRESOURCE RESOURCE-CONSTRUCTOR RESOURCE-FINDER RESOURCE-MATCHER
				    RESOURCE-CHECKER RESOURCE-INITIALIZER
				    RESOURCE-DEINITIALIZER RESOURCE-PARAMETIZER))
      (REMPROP RESOURCE-NAME PROPERTY))))

(DEFUN CLEAR-RESOURCE (RESOURCE-NAME &AUX RESOURCE)
  (CHECK-ARG RESOURCE-NAME (SETQ RESOURCE (GET RESOURCE-NAME 'DEFRESOURCE))
	     "the name of a resource")
  (WITH-RESOURCE-LOCKED (RESOURCE)
    (SETF (RESOURCE-FIRST-FREE-OBJECT RESOURCE) 0)
    (SETF (RESOURCE-N-OBJECTS RESOURCE) 0)
    ;; Clear the actual cells so the old objects can be garbage collected immediately.
    (FILL-ARRAY RESOURCE NIL NIL)))

(DEFUN DESCRIBE-RESOURCE (RESOURCE)
  (CHECK-ARG RESOURCE (OR (TYPEP RESOURCE 'RESOURCE)
			  (AND (SYMBOLP RESOURCE) (GET RESOURCE 'DEFRESOURCE)))
	     "a resource or the name of a resource")
  (WHEN (SYMBOLP RESOURCE)
    (SETQ RESOURCE (GET RESOURCE 'DEFRESOURCE)))
  (DESCRIBE-DEFSTRUCT RESOURCE)
  (LET ((N-OBJECTS (RESOURCE-N-OBJECTS RESOURCE)))
    (COND ((ZEROP N-OBJECTS)
	   (FORMAT T "~&There are currently no objects.~%"))
	  (T (FORMAT T "~&There ~[~;is~:;are~] currently ~:*~D object~:P in the resource:~@
                        Object~40TParameters~60TIn Use"
		     N-OBJECTS)
	     (UNLESS (ZEROP (RESOURCE-FIRST-FREE-OBJECT RESOURCE))
	       (FORMAT T "~&~20TBusy objects"))
	     (LOOP WITH FREE-POINTER = (RESOURCE-FIRST-FREE-OBJECT RESOURCE)
		   FOR INDEX FROM 0 BY RESOURCE-ELEMENT-SIZE
			     BELOW (* N-OBJECTS RESOURCE-ELEMENT-SIZE)
		   WHEN (= INDEX FREE-POINTER)
		     DO (FORMAT T "~&~20TFree objects")
		   DO (FORMAT T "~%~S~40T~S~60T~:[No~;Yes~]"
			      (RESOURCE-ELEMENT-OBJECT INDEX)
			      (RESOURCE-ELEMENT-PARAMETERS INDEX RESOURCE)
			      (RESOURCE-ELEMENT-IN-USE-P INDEX)))
	     (FORMAT T "~%")))))

(DEFUN MAP-RESOURCE (RESOURCE-NAME FUNCTION &REST ARGS &AUX RESOURCE)
  ;; For back-compatibility, allow first two arguments to be reversed.
  (WHEN (AND (SYMBOLP FUNCTION) (GET FUNCTION 'DEFRESOURCE))
    (PSETQ RESOURCE-NAME FUNCTION FUNCTION RESOURCE-NAME))
  (CHECK-ARG RESOURCE-NAME (SETQ RESOURCE (GET RESOURCE-NAME 'DEFRESOURCE))
	     "the name of a resource")
  ;;Windows are the user's problem....
  (STACK-LET ((OBJS (MAKE-ARRAY (* (+ (RESOURCE-N-OBJECTS RESOURCE) 2) 2) :FILL-POINTER 0)))
    (WITH-RESOURCE-LOCKED (RESOURCE)
      (LOOP REPEAT (RESOURCE-N-OBJECTS RESOURCE)
	    FOR J FROM 0 BY RESOURCE-ELEMENT-SIZE DO
	(ARRAY-PUSH-EXTEND OBJS (RESOURCE-ELEMENT-OBJECT J))
	(ARRAY-PUSH-EXTEND OBJS (RESOURCE-ELEMENT-IN-USE-P J))))
    (LOOP FOR I FROM 0 BELOW (FILL-POINTER OBJS) BY 2
	  AS OBJECT = (AREF OBJS I)
	  AS IN-USE-P = (AREF OBJS (1+ I)) DO
      (LEXPR-FUNCALL FUNCTION OBJECT IN-USE-P RESOURCE-NAME ARGS))))

(DEFUN ALLOCATE-RESOURCE (RESOURCE-NAME &REST PARAMETERS)
  (LET ((RESOURCE (GET RESOURCE-NAME 'DEFRESOURCE)))
    (CHECK-ARG RESOURCE-NAME (NOT (NULL RESOURCE)) "the name of a resource")
    (LEXPR-FUNCALL (RESOURCE-ALLOCATOR RESOURCE) RESOURCE PARAMETERS)))

;;; The next four functions are targets of optimization

(DEFUN ALLOCATE-RESOURCE-0 (RESOURCE)
  (FUNCALL (RESOURCE-ALLOCATOR RESOURCE) RESOURCE))

(DEFUN ALLOCATE-RESOURCE-1 (RESOURCE ARG1)
  (FUNCALL (RESOURCE-ALLOCATOR RESOURCE) RESOURCE ARG1))

(DEFUN ALLOCATE-RESOURCE-2 (RESOURCE ARG1 ARG2)
  (FUNCALL (RESOURCE-ALLOCATOR RESOURCE) RESOURCE ARG1 ARG2))

(DEFUN ALLOCATE-RESOURCE-N (RESOURCE &REST ARGS)
  (LEXPR-FUNCALL (RESOURCE-ALLOCATOR RESOURCE) RESOURCE ARGS))

(COMPILER:DEFOPTIMIZER (ALLOCATE-RESOURCE OPTIMIZE-ALLOCATE-RESOURCE
			ALLOCATE-RESOURCE-0 ALLOCATE-RESOURCE-1
			ALLOCATE-RESOURCE-2 ALLOCATE-RESOURCE-N)
		       (FORM &AUX RESOURCE)
  (COMPILER:MATCHP (CDR FORM)
    ((('QUOTE RESOURCE-NAME) . PARAMETERS)
     (IF (AND (SYMBOLP RESOURCE-NAME)
	      (SETQ RESOURCE (GET RESOURCE-NAME 'DEFRESOURCE)))
	 (CL:CASE (LENGTH PARAMETERS)
	   (0 `(ALLOCATE-RESOURCE-0 ',RESOURCE))
	   (1 `(ALLOCATE-RESOURCE-1 ',RESOURCE ,@PARAMETERS))
	   (2 `(ALLOCATE-RESOURCE-2 ',RESOURCE ,@PARAMETERS))
	   (OTHERWISE `(ALLOCATE-RESOURCE-N ',RESOURCE ,@PARAMETERS)))
	 FORM))
    (* FORM)))

;; This macro generates the body of a resource allocation routine.
;; The variable RESOURCE must be bound to the resource object.
;; MATCHER, CHECKER, INITIALIZER tell us whether to look for those functions.
;; These values are NIL if there definitely isn't one, T if there definitely
;; is one, or MAYBE if there might be one.
;; PROCESSED-PARAMETERS is a list of 0, 1, or 2 variables bound to the processed
;; parameters, or a single variable bound to a list of the processed parameters.
;; It must match RESOURCE-NUMBER-OF-PARAMS' implications for the RESOURCE-ELEMENT format.
;; RAW-PARAMETERS are variables bound to the raw user-supplied parameters.
;; CALL is FUNCALL, or APPLY if the last of RAW-PARAMETERS is really an &rest list.
(DEFMACRO RESOURCE-ALLOCATOR-BODY (MATCHER CHECKER INITIALIZER PROCESSED-PARAMETERS
				   CALL &REST RAW-PARAMETERS)
  (LET ((MATCH ;; The form that checks the parameters
	  (COND ((NULL PROCESSED-PARAMETERS) `T)	;no parameters
		((NOT (LISTP PROCESSED-PARAMETERS))	;list of the processed parameters
		 `(CL:EQUAL ,PROCESSED-PARAMETERS (RESOURCE-ELEMENT-PARAMETER-1 INDEX)))
		((NULL (CDR PROCESSED-PARAMETERS))	;one parameter
		 `(CL:EQUAL ,(FIRST PROCESSED-PARAMETERS)
			    (RESOURCE-ELEMENT-PARAMETER-1 INDEX)))
		(T					;two parameters
		 `(AND (CL:EQUAL ,(FIRST PROCESSED-PARAMETERS)
				 (RESOURCE-ELEMENT-PARAMETER-1 INDEX))
		       (CL:EQUAL ,(SECOND PROCESSED-PARAMETERS)
				 (RESOURCE-ELEMENT-PARAMETER-2 INDEX)))))))
    (CL:ECASE MATCHER
      ((NIL))
      ((T) (SETQ MATCH `(,CALL MATCHER RESOURCE NEW-OBJECT ,@RAW-PARAMETERS)))
      ((MAYBE) (SETQ MATCH `(IF MATCHER
				(,CALL MATCHER RESOURCE NEW-OBJECT ,@RAW-PARAMETERS)    
				,MATCH))))
    `(LET* (,@(WHEN CHECKER `((CHECKER (RESOURCE-CHECKER RESOURCE))))
	    ,@(WHEN MATCHER `((MATCHER (RESOURCE-MATCHER RESOURCE))))
	    ; *Synch*
	    (OLD-FLAG INHIBIT-SCHEDULING-FLAG)
	    NEW-OBJECT INDEX)
       (WITH-RESOURCE-LOCKED (RESOURCE)
	 (LET ((FIRST-FREE (RESOURCE-FIRST-FREE-OBJECT RESOURCE))
	       (LIMIT (%FIXNUM-MULTIPLY (RESOURCE-N-OBJECTS RESOURCE) RESOURCE-ELEMENT-SIZE)))
	   (BLOCK FIND
	     ,(LET ((IF-NO-CHECKER
		      `;; If there is no checker, search the free portion of the array
		       (LOOP INITIALLY (SETQ INDEX FIRST-FREE)
			     WHILE (< INDEX LIMIT) DO
			 ;; This RESOURCE-ELEMENT-IN-USE-P test should be redundant
			 (UNLESS (RESOURCE-ELEMENT-IN-USE-P INDEX)
			   (SETQ NEW-OBJECT (RESOURCE-ELEMENT-OBJECT INDEX))
			   (WHEN ,MATCH (RETURN-FROM FIND)))
			 (INCF INDEX RESOURCE-ELEMENT-SIZE)))
		    (IF-CHECKER
		      `;; Run this loop if there is a checker
		       (LOOP INITIALLY (SETQ INDEX LIMIT)
			     DO (DECF INDEX RESOURCE-ELEMENT-SIZE)
			     WHILE ( INDEX 0) DO
			 (SETQ NEW-OBJECT (RESOURCE-ELEMENT-OBJECT INDEX))
			 (WHEN (AND (,CALL CHECKER RESOURCE NEW-OBJECT
						   (RESOURCE-ELEMENT-IN-USE-P INDEX)
						   ,@RAW-PARAMETERS)
				    ,MATCH)
			   (RETURN-FROM FIND)))))
		(CL:ECASE CHECKER
		  ((NIL) IF-NO-CHECKER)
		  ((T) IF-CHECKER)
		  ((MAYBE) `(IF (NOT CHECKER) ,IF-NO-CHECKER ,IF-CHECKER))))
	     ;; No existing object found, have to create a new one
	     (LET ((DEFAULT-CONS-AREA ;; Don't get screwed by temporary area problems
		     WORKING-STORAGE-AREA))
	       (LET ((INHIBIT-SCHEDULING-FLAG OLD-FLAG))	; *Synch*
		 (SETQ NEW-OBJECT (,CALL (RESOURCE-CONSTRUCTOR RESOURCE) RESOURCE
									 ,@RAW-PARAMETERS)))
	       ;; Recompute values that might have changed while unlocked
	       (SETQ FIRST-FREE (RESOURCE-FIRST-FREE-OBJECT RESOURCE)
		     LIMIT (%FIXNUM-MULTIPLY (RESOURCE-N-OBJECTS RESOURCE)
					     RESOURCE-ELEMENT-SIZE))
	       ;; Create a new resource-element at the end of the array
	       (SETQ INDEX LIMIT)
	       (UNLESS ( (ARRAY-LENGTH RESOURCE) (+ INDEX RESOURCE-ELEMENT-SIZE))
		 (ADJUST-ARRAY-SIZE RESOURCE (* (ARRAY-LENGTH RESOURCE) 2)))
	       (SETF (RESOURCE-ELEMENT-OBJECT INDEX) NEW-OBJECT)
	       ,@(COND ((NULL PROCESSED-PARAMETERS) NIL)	;no parameters
		       ((NOT (LISTP PROCESSED-PARAMETERS))	;list of processed parameters
			(CL:ECASE MATCHER
			  ((NIL)
			   `((SETF (RESOURCE-ELEMENT-PARAMETER-1 INDEX)
				   (COPY-IF-NECESSARY ,PROCESSED-PARAMETERS))))
			  ((T) NIL)		;don't store parameters if there is a matcher
			  ((MAYBE)
			   `((UNLESS MATCHER
			       (SETF (RESOURCE-ELEMENT-PARAMETER-1 INDEX)
				     (COPY-IF-NECESSARY ,PROCESSED-PARAMETERS)))))))
		       ((NULL (CDR PROCESSED-PARAMETERS))	;one parameter
			`((SETF (RESOURCE-ELEMENT-PARAMETER-1 INDEX)
				,(FIRST PROCESSED-PARAMETERS))))
		       (T					;two parameters
			`((SETF (RESOURCE-ELEMENT-PARAMETER-1 INDEX)
				,(FIRST PROCESSED-PARAMETERS))
			  (SETF (RESOURCE-ELEMENT-PARAMETER-2 INDEX)
				,(SECOND PROCESSED-PARAMETERS)))))
	       (INCF (RESOURCE-N-OBJECTS RESOURCE))))
	   ;; Allocate NEW-OBJECT at INDEX
	   (SETF (RESOURCE-ELEMENT-IN-USE-P INDEX) T)
	   (WHEN (> INDEX FIRST-FREE)
	     ;; Move this resource-element down to the in-use portion of the array
	     (SWAP-RESOURCE-ELEMENTS INDEX FIRST-FREE)
	     (SETQ INDEX FIRST-FREE))
	   (UNLESS (< INDEX FIRST-FREE)
	     ;; Expand the in-use portion of the array by moving the boundary up
	     (SETF (RESOURCE-FIRST-FREE-OBJECT RESOURCE)
		   (+ FIRST-FREE RESOURCE-ELEMENT-SIZE)))))
       ;; Resource is now unlocked
       ,(CL:ECASE INITIALIZER
	  ((NIL) NIL)
	  ((T) `(,CALL (RESOURCE-INITIALIZER RESOURCE) RESOURCE NEW-OBJECT ,@RAW-PARAMETERS))
	  ((MAYBE) `(LET ((INITIALIZER (RESOURCE-INITIALIZER RESOURCE)))
		      (WHEN INITIALIZER
			(,CALL INITIALIZER RESOURCE NEW-OBJECT ,@RAW-PARAMETERS)))))
       (VALUES NEW-OBJECT INDEX))))

;;; The following routines can be (RESOURCE-ALLOCATOR RESOURCE)

(DEFUN RESOURCE-ALLOCATOR-0 (RESOURCE)
  (RESOURCE-ALLOCATOR-BODY MAYBE MAYBE MAYBE () FUNCALL))

(DEFUN RESOURCE-ALLOCATOR-1 (RESOURCE ARG1)
  (RESOURCE-ALLOCATOR-BODY MAYBE MAYBE MAYBE (ARG1) FUNCALL ARG1))

(DEFUN RESOURCE-ALLOCATOR-2 (RESOURCE ARG1 ARG2)
  (RESOURCE-ALLOCATOR-BODY MAYBE MAYBE MAYBE (ARG1 ARG2) FUNCALL ARG1 ARG2))

(DEFUN RESOURCE-ALLOCATOR-1-OPTIONAL (RESOURCE &OPTIONAL (ARG1 NIL ARG1-P))
  (UNLESS ARG1-P
    (SETQ ARG1 (FUNCALL (RESOURCE-PARAMETIZER RESOURCE))))
  (RESOURCE-ALLOCATOR-BODY MAYBE MAYBE MAYBE (ARG1) FUNCALL ARG1))

(DEFUN RESOURCE-ALLOCATOR-1-REQUIRED-1-OPTIONAL (RESOURCE ARG1 &OPTIONAL (ARG2 NIL ARG2-P))
  (UNLESS ARG2-P
    (SETQ ARG2 (FUNCALL (RESOURCE-PARAMETIZER RESOURCE) ARG1)))
  (RESOURCE-ALLOCATOR-BODY MAYBE MAYBE MAYBE (ARG1 ARG2) FUNCALL ARG1 ARG2))

(DEFUN RESOURCE-ALLOCATOR-2-OPTIONAL (RESOURCE &OPTIONAL (ARG1 NIL ARG1-P) (ARG2 NIL ARG2-P))
  (UNLESS ARG2-P
    (MULTIPLE-VALUE (ARG1 ARG2)
      (IF ARG1-P
	  (FUNCALL (RESOURCE-PARAMETIZER RESOURCE) ARG1)
	  (FUNCALL (RESOURCE-PARAMETIZER RESOURCE)))))
  (RESOURCE-ALLOCATOR-BODY MAYBE MAYBE MAYBE (ARG1 ARG2) FUNCALL ARG1 ARG2))

(DEFUN RESOURCE-ALLOCATOR-N (RESOURCE &REST ARGS)
  (LET* ((PARAMETIZER (RESOURCE-PARAMETIZER RESOURCE))
	 (PROCESSED-PARAMETERS (IF PARAMETIZER (CL:APPLY PARAMETIZER ARGS) ARGS)))
    (RESOURCE-ALLOCATOR-BODY MAYBE MAYBE MAYBE PROCESSED-PARAMETERS CL:APPLY ARGS)))

;;; The following routines can be (RESOURCE-ALLOCATOR RESOURCE)
;;; and are used when there is no matcher, checker, or initializer

(DEFUN RESOURCE-ALLOCATOR-SIMPLE-0 (RESOURCE)
  (RESOURCE-ALLOCATOR-BODY NIL NIL NIL () FUNCALL))

(DEFUN RESOURCE-ALLOCATOR-SIMPLE-1 (RESOURCE ARG1)
  (RESOURCE-ALLOCATOR-BODY NIL NIL NIL (ARG1) FUNCALL ARG1))

(DEFUN RESOURCE-ALLOCATOR-SIMPLE-2 (RESOURCE ARG1 ARG2)
  (RESOURCE-ALLOCATOR-BODY NIL NIL NIL (ARG1 ARG2) FUNCALL ARG1 ARG2))

(DEFUN RESOURCE-ALLOCATOR-SIMPLE-1-OPTIONAL (RESOURCE &OPTIONAL (ARG1 NIL ARG1-P))
  (UNLESS ARG1-P
    (SETQ ARG1 (FUNCALL (RESOURCE-PARAMETIZER RESOURCE))))
  (RESOURCE-ALLOCATOR-BODY NIL NIL NIL (ARG1) FUNCALL ARG1))

(DEFUN RESOURCE-ALLOCATOR-SIMPLE-1-REQUIRED-1-OPTIONAL (RESOURCE ARG1
							&OPTIONAL (ARG2 NIL ARG2-P))
  (UNLESS ARG2-P
    (SETQ ARG2 (FUNCALL (RESOURCE-PARAMETIZER RESOURCE) ARG1)))
  (RESOURCE-ALLOCATOR-BODY NIL NIL NIL (ARG1 ARG2) FUNCALL ARG1 ARG2))

(DEFUN RESOURCE-ALLOCATOR-SIMPLE-2-OPTIONAL (RESOURCE &OPTIONAL (ARG1 NIL ARG1-P)
								(ARG2 NIL ARG2-P))
  (UNLESS ARG2-P
    (MULTIPLE-VALUE (ARG1 ARG2)
      (IF ARG1-P
	  (FUNCALL (RESOURCE-PARAMETIZER RESOURCE) ARG1)
	  (FUNCALL (RESOURCE-PARAMETIZER RESOURCE)))))
  (RESOURCE-ALLOCATOR-BODY NIL NIL NIL (ARG1 ARG2) FUNCALL ARG1 ARG2))

(DEFUN RESOURCE-ALLOCATOR-SIMPLE-N (RESOURCE &REST ARGS)
  (LET* ((PARAMETIZER (RESOURCE-PARAMETIZER RESOURCE))
	 (PROCESSED-PARAMETERS (IF PARAMETIZER (CL:APPLY PARAMETIZER ARGS) ARGS)))
    (RESOURCE-ALLOCATOR-BODY NIL NIL NIL PROCESSED-PARAMETERS CL:APPLY ARGS)))

;;; The following routines can be (RESOURCE-ALLOCATOR RESOURCE)
;;; and are used when there is an initializer but no matcher or checker

(DEFUN RESOURCE-ALLOCATOR-INIT-0 (RESOURCE)
  (RESOURCE-ALLOCATOR-BODY NIL NIL T () FUNCALL))

(DEFUN RESOURCE-ALLOCATOR-INIT-1 (RESOURCE ARG1)
  (RESOURCE-ALLOCATOR-BODY NIL NIL T (ARG1) FUNCALL ARG1))

(DEFUN RESOURCE-ALLOCATOR-INIT-2 (RESOURCE ARG1 ARG2)
  (RESOURCE-ALLOCATOR-BODY NIL NIL T (ARG1 ARG2) FUNCALL ARG1 ARG2))

(DEFUN DEALLOCATE-RESOURCE (RESOURCE-NAME OBJECT &OPTIONAL (INDEX-HINT NIL))
  (LET ((RESOURCE (GET RESOURCE-NAME 'DEFRESOURCE)))
    (CHECK-ARG RESOURCE-NAME (NOT (NULL RESOURCE)) "the name of a resource")
    (DEALLOCATE-RESOURCE-INTERNAL RESOURCE OBJECT INDEX-HINT)))

(COMPILER:DEFOPTIMIZER (DEALLOCATE-RESOURCE OPTIMIZE-DEALLOCATE-RESOURCE
			DEALLOCATE-RESOURCE-INTERNAL)
		       (FORM &AUX RESOURCE)
  (COMPILER:MATCHP (CDR FORM)
    ((('QUOTE RESOURCE-NAME) . OBJECT-AND-HINT)
     (IF (AND (SYMBOLP RESOURCE-NAME)
	      (SETQ RESOURCE (GET RESOURCE-NAME 'DEFRESOURCE)))
	 `(DEALLOCATE-RESOURCE-INTERNAL ',RESOURCE ,@OBJECT-AND-HINT)
	 FORM))
    (* FORM)))

(DEFUN DEALLOCATE-WHOLE-RESOURCE (RESOURCE-NAME)
  (LET ((RESOURCE (GET RESOURCE-NAME 'DEFRESOURCE)))
    (CHECK-ARG RESOURCE-NAME (NOT (NULL RESOURCE)) "the name of a resource")
    (UNLESS (RESOURCE-USER-DEFINED-ALLOCATOR? RESOURCE)
      (LET ((DEINITIALIZER (RESOURCE-DEINITIALIZER RESOURCE)))
	(WITH-RESOURCE-LOCKED (RESOURCE)
	  (LOOP FOR INDEX FROM 0 BELOW (RESOURCE-FIRST-FREE-OBJECT RESOURCE)
			  BY RESOURCE-ELEMENT-SIZE DO
	    (SETF (RESOURCE-ELEMENT-IN-USE-P INDEX) NIL)
	    (WHEN DEINITIALIZER
	      (FUNCALL DEINITIALIZER RESOURCE (RESOURCE-ELEMENT-OBJECT INDEX))))
	  (SETF (RESOURCE-FIRST-FREE-OBJECT RESOURCE) 0))))))

(DEFUN DEALLOCATE-RESOURCE-INTERNAL (RESOURCE OBJECT &OPTIONAL (INDEX-HINT NIL))
  (COMPILER:%ERROR-WHEN (RESOURCE-USER-DEFINED-ALLOCATOR? RESOURCE)
    ;; When there is a user-defined allocator, do nothing except deinitialize
    (RETURN-FROM DEALLOCATE-RESOURCE-INTERNAL
      (FUNCALL (OR (RESOURCE-DEINITIALIZER RESOURCE)
		   (RETURN-FROM DEALLOCATE-RESOURCE-INTERNAL NIL))
	       RESOURCE OBJECT)))
  (WITH-RESOURCE-LOCKED (RESOURCE)
    (LET* ((TOP-INDEX (%FIXNUM-MULTIPLY (1- (RESOURCE-N-OBJECTS RESOURCE))
					RESOURCE-ELEMENT-SIZE))
	   (TOP-BUSY-INDEX (- (RESOURCE-FIRST-FREE-OBJECT RESOURCE) RESOURCE-ELEMENT-SIZE))
	   (CHECKER (RESOURCE-CHECKER RESOURCE)) 
	   (FORWARDED-OBJECT (FOLLOW-STRUCTURE-FORWARDING OBJECT))
	   (RESOURCE RESOURCE)
	   (INDEX ;; Find the index of the object's resource-element
	     (COND ((AND INDEX-HINT
			 ( 0 INDEX-HINT TOP-INDEX)
			 (EQ (FOLLOW-STRUCTURE-FORWARDING (RESOURCE-ELEMENT-OBJECT INDEX-HINT))
			     FORWARDED-OBJECT))
		    INDEX-HINT)
		   ((LOOP FOR INDEX FROM (IF CHECKER TOP-INDEX TOP-BUSY-INDEX) DOWNTO 0
				    BY RESOURCE-ELEMENT-SIZE DO
		      (WHEN (EQ (FOLLOW-STRUCTURE-FORWARDING (RESOURCE-ELEMENT-OBJECT INDEX))
				FORWARDED-OBJECT)
			(RETURN INDEX))))
		   ((LOOP FOR INDEX FROM (+ TOP-BUSY-INDEX RESOURCE-ELEMENT-SIZE) TO TOP-INDEX
				    BY RESOURCE-ELEMENT-SIZE DO
		      (WHEN (EQ (FOLLOW-STRUCTURE-FORWARDING (RESOURCE-ELEMENT-OBJECT INDEX))
				FORWARDED-OBJECT)
			(RETURN INDEX))))
		   (T
		    (SIGNAL 'RESOURCE-OBJECT-NOT-FOUND :OBJECT OBJECT :RESOURCE RESOURCE)
		    (RETURN-FROM DEALLOCATE-RESOURCE-INTERNAL NIL)))))
      (DECLARE (SYS:ARRAY-REGISTER RESOURCE))
      (COMPILER:%ERROR-UNLESS (OR CHECKER (RESOURCE-ELEMENT-IN-USE-P INDEX))
	(SIGNAL 'RESOURCE-EXTRA-DEALLOCATION :OBJECT OBJECT :RESOURCE RESOURCE)
	(RETURN-FROM DEALLOCATE-RESOURCE-INTERNAL NIL))
      (SETF (RESOURCE-ELEMENT-IN-USE-P INDEX) NIL)
      (UNLESS CHECKER
	(SETF (RESOURCE-ELEMENT-OBJECT INDEX) FORWARDED-OBJECT))
      (UNLESS ( INDEX TOP-BUSY-INDEX)
	;; Move this resource-element into the free section of the array
	(SWAP-RESOURCE-ELEMENTS INDEX TOP-BUSY-INDEX))
      (UNLESS (> INDEX TOP-BUSY-INDEX)
	;; Expand the free section of the array by moving its start down by one
	(SETF (RESOURCE-FIRST-FREE-OBJECT RESOURCE) TOP-BUSY-INDEX))
      (WHEN (RESOURCE-DEINITIALIZER RESOURCE)
	(FUNCALL (RESOURCE-DEINITIALIZER RESOURCE) RESOURCE OBJECT))
      NIL)))

(DEFUN REPAIR-RESOURCE (RESOURCE-NAME)
  (LET ((RESOURCE (GET RESOURCE-NAME 'DEFRESOURCE))
	(ERRORS-TO-REPORT (MAKE-ARRAY 4 :FILL-POINTER 0)))
    (FLET ((REPORT-ERROR (CONTROL-STRING &REST FORMAT-ARGS)
	     (ARRAY-PUSH-EXTEND ERRORS-TO-REPORT
				(LEXPR-FUNCALL #'FORMAT NIL CONTROL-STRING FORMAT-ARGS))))
    (CHECK-ARG RESOURCE-NAME (NOT (NULL RESOURCE)) "the name of a resource")
    (IF (RESOURCE-USER-DEFINED-ALLOCATOR? RESOURCE)
	(FORMAT T
	 "There is nothing simple that can be done, since this is a user defined resource.")
	(WITH-RESOURCE-LOCKED (RESOURCE)
	  (LET* ((FIRST-FREE (RESOURCE-FIRST-FREE-OBJECT RESOURCE))
		 (TOP-BUSY (- FIRST-FREE RESOURCE-ELEMENT-SIZE))
		 (NUMBER-OF-OBJECTS (RESOURCE-N-OBJECTS RESOURCE))
		 (COUNTER 0))
	    (WHEN (> (%FIXNUM-FLOOR FIRST-FREE RESOURCE-ELEMENT-SIZE) NUMBER-OF-OBJECTS)
	      (REPORT-ERROR
		"Resources free pointer was incorrect. ~D, but only ~D objects in resource."
		(%FIXNUM-FLOOR FIRST-FREE RESOURCE-ELEMENT-SIZE) NUMBER-OF-OBJECTS)
	      (SETQ FIRST-FREE (* NUMBER-OF-OBJECTS RESOURCE-ELEMENT-SIZE))
	      (SETQ TOP-BUSY (- FIRST-FREE RESOURCE-ELEMENT-SIZE)))
	    (LOOP FOR N FROM FIRST-FREE BELOW (* NUMBER-OF-OBJECTS RESOURCE-ELEMENT-SIZE)
			BY RESOURCE-ELEMENT-SIZE DO
	      (WHEN (RESOURCE-ELEMENT-IN-USE-P N)
		(SETF (RESOURCE-ELEMENT-IN-USE-P N) NIL)
		(REPORT-ERROR
		  "Object ~S was actually free, but the resource incorrectly marked it."
		  (RESOURCE-ELEMENT-OBJECT N))
		(INCF COUNTER)))
	    (LOOP FOR N FROM TOP-BUSY DOWNTO 0 BY RESOURCE-ELEMENT-SIZE DO
	      (UNLESS (RESOURCE-ELEMENT-IN-USE-P N)
		(WHEN ( N TOP-BUSY)
		  (SWAP-RESOURCE-ELEMENTS N TOP-BUSY)
		  (DECF TOP-BUSY RESOURCE-ELEMENT-SIZE)
		  (DECF FIRST-FREE RESOURCE-ELEMENT-SIZE)
		  (REPORT-ERROR
		    "Object ~S was actually free, but the resource didn't notice it."
		    (RESOURCE-ELEMENT-OBJECT N))
		  (INCF COUNTER))))
	    (IF (ZEROP COUNTER)
		(REPORT-ERROR "Resource ~S (~S) was not modified." RESOURCE-NAME RESOURCE)
		(REPORT-ERROR "Repairing ~S (~S): ~D object~:P freed."
			      RESOURCE-NAME RESOURCE COUNTER))
	    (SETF (RESOURCE-FIRST-FREE-OBJECT RESOURCE) FIRST-FREE)
	    (RETURN-FROM REPAIR-RESOURCE NIL)))))
    (LOOP FOR LINE BEING THE ARRAY-ELEMENTS OF ERRORS-TO-REPORT
	  DO (FORMAT T "~&~A" LINE))))

(DEFMACRO USING-RESOURCE (VARLIST &BODY BODY &ENVIRONMENT ENV)
  (DECLARE (ARGLIST (VARIABLE RESOURCE-NAME . PARAMETERS) . BODY)
	   (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  ;; Convert single-resource style to multiple-resource style.
  (UNLESS (LISTP (CAR VARLIST)) (SETQ VARLIST (NCONS VARLIST)))
  (MULTIPLE-VALUE-BIND (DECLARATIONS BODY)
      (FIND-BODY-DECLARATIONS BODY ENV)
    (LET ((INDEX-HINT-VARS (IF (< (LENGTH VARLIST) 2)
			       '(.RESOURCE-INDEX-HINT.)
			       (LOOP REPEAT (LENGTH VARLIST) COLLECT (GENSYM)))))
      `(LET (,@(MAPCAR #'CAR VARLIST) . ,INDEX-HINT-VARS)
	 ,@DECLARATIONS
	 (UNWIND-PROTECT 
	     (PROGN
	       ,@(LOOP FOR (VAR NAME . PARAMETERS) IN VARLIST
		       FOR INDEX-HINT-VAR IN INDEX-HINT-VARS
		       COLLECT `(MULTIPLE-VALUE (,VAR ,INDEX-HINT-VAR)
				  (ALLOCATE-RESOURCE ',NAME . ,PARAMETERS)))
	       . ,BODY)
	   ,@(LET (CLEANUPS)
	       (LOOP FOR (VAR NAME) IN VARLIST
		     FOR INDEX-HINT-VAR IN INDEX-HINT-VARS
		     DO (PUSH `(WHEN ,VAR (DEALLOCATE-RESOURCE ',NAME ,VAR ,INDEX-HINT-VAR))
			      CLEANUPS))
	       CLEANUPS))))))

;For compatibility with old programs
(DEFMACRO WITH-RESOURCE ((NAME VAR) &BODY BODY)
  `(USING-RESOURCE (,VAR ,NAME) . ,BODY))

;; GC cleanups of resources

(DEFINE-GC-OPTIMIZATION CLEAR-RESOURCES-FOR-GC-CLEANUP (:CLEANUP)
  (:DOCUMENTATION "Clear some resources")
  (:BEFORE-FLIP (IGNORE)
    (GC-CLEAR-RESOURCES '(:CLEANUP))))

(DEFINE-GC-OPTIMIZATION CLEAR-RESOURCES-FOR-LAYERED-SYSTEM-RELEASE (:LAYERED-SYSTEM-RELEASE)
  (:DOCUMENTATION "Clear some resources")
  (:BEFORE-FLIP (IGNORE)
    ;; :FULL-GC is an obsolete synonym for :LAYERED-SYSTEM-RELEASE
    (GC-CLEAR-RESOURCES '(:CLEANUP :FULL-GC :LAYERED-SYSTEM-RELEASE))))

(DEFINE-GC-OPTIMIZATION CLEAR-RESOURCES-FOR-SYMBOLICS-SYSTEM-RELEASE (SYMBOLICS-SYSTEM-RELEASE)
  (:DOCUMENTATION "Clear some resources")
  (:BEFORE-FLIP (IGNORE)
    ;; :FULL-GC is an obsolete synonym for :LAYERED-SYSTEM-RELEASE
    ;; :SYSTEM-RELEASE is an obsolete synonym for SI:SYMBOLICS-SYSTEM-RELEASE
    (GC-CLEAR-RESOURCES '(:CLEANUP :FULL-GC :LAYERED-SYSTEM-RELEASE
			  :SYSTEM-RELEASE SYMBOLICS-SYSTEM-RELEASE))))

(DEFUN GC-CLEAR-RESOURCES (ALLOWED)
  (DOLIST (RESOURCE-NAME *ALL-RESOURCES*)
    (LET ((RESOURCE (GET RESOURCE-NAME 'DEFRESOURCE)))
      (WHEN (MEMQ (RESOURCE-CLEAR-FOR-GC RESOURCE) ALLOWED)
	(CLEAR-RESOURCE RESOURCE-NAME)))))

(DEFVAR SI:*COLD-FIND-RESOURCE-MARKER*)		;filled in by cold-load generator

(DEFUN BOOTSTRAP-RESOURCE-REFERENCES ()
  (SI:MAP-COMPILED-FUNCTIONS T NIL NIL
    #'(LAMBDA (FUNCTION IGNORE)
	#+3600
	(SI:DO-COMPILED-FUNCTION-CONSTANT-TABLE (VAL LOC) FUNCTION
	  (WHEN (AND (LISTP VAL)
		     (EQ (FIRST VAL) SI:*COLD-FIND-RESOURCE-MARKER*))
	    (SETF (LOCATION-CONTENTS LOC) (FIND-RESOURCE (SECOND VAL)))))
	#+IMach
	(SI:DO-COMPILED-FUNCTION-INSTRUCTIONS (VAL LOC) FUNCTION
	  (WHEN (AND (LISTP VAL)
		     (EQ (FIRST VAL) SI:*COLD-FIND-RESOURCE-MARKER*))
	    (SETF (LOCATION-CONTENTS LOC) (FIND-RESOURCE (SECOND VAL)))
	    #+VLM (%COPROCESSOR-WRITE LOC %COPROCESSOR-REGISTER-FLUSH-CACHES-FOR-VMA))))))

(ADD-INITIALIZATION "Bootstrap resources" '(BOOTSTRAP-RESOURCE-REFERENCES) '(:ONCE))
