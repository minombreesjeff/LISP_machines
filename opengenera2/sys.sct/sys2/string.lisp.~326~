;;; -*- Package:SYSTEM-INTERNALS; Mode:LISP; Base:8; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Machine independent string and character manipulating functions.
;;; This file is in the cold load.

;;; Useful macros

(DEFMACRO CODE-UPPER-CASE-P (CODE)
  `(<= (CHAR-CODE #/A) ,CODE (CHAR-CODE #/Z)))

(DEFMACRO CODE-LOWER-CASE-P (CODE)
  `(<= (CHAR-CODE #/a) ,CODE (CHAR-CODE #/z)))

;;; Variables

(DEFVAR *STANDARD-CHARACTER-SET*)

;;; Functions

(DEFSUBST %MAKE-CHARACTER (INTEGER)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE))		;not REDUCIBLE
  (%MAKE-POINTER DTP-CHARACTER INTEGER))

(CL:DEFINE-SETF-METHOD CHAR-LDB-INTERNAL (PPSS CHAR &ENVIRONMENT ENV)
  (MULTIPLE-VALUE-BIND (CHAR-TEMPS CHAR-VALS CHAR-STORES CHAR-STORE-FORM CHAR-ACCESS-FORM)
      (CL:GET-SETF-METHOD CHAR ENV)
    (LET ((STORE (GENSYM))
	  (NTEMP (GENSYM))
	  (VTEMP (GENSYM)))
      (LET ((*SIMPLE-VARIABLES* (APPEND CHAR-TEMPS (LIST NTEMP))))
	(VALUES *SIMPLE-VARIABLES*
		(APPEND CHAR-VALS (LIST PPSS))
		(LIST STORE)
		`(LET-VALUE ,VTEMP ,STORE
			    ,(LT:LET-SUBST CHAR-STORES
					   `((CLI::CHAR-DPB-INTERNAL ,VTEMP ,NTEMP ,CHAR-ACCESS-FORM))
					   CHAR-STORE-FORM
					   ENV))
		`(CHAR-LDB-INTERNAL ,NTEMP ,CHAR-ACCESS-FORM))))))

;;; Some useful constants

(DEFCONSTANT CHAR-CODE-LIMIT (ASH 1 (BYTE-SIZE %%CHAR-CODE)))
(DEFCONSTANT CHAR-FONT-LIMIT 1)
(DEFCONSTANT CHAR-BITS-LIMIT (ASH 1 (BYTE-SIZE %%CHAR-BITS)))
(DEFCONSTANT *WEIGHT-DIGITS* "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ")
(DEFCONSTANT CHAR-CONTROL-BIT 1)
(DEFCONSTANT CHAR-META-BIT 2)
(DEFCONSTANT CHAR-SUPER-BIT 4)
(DEFCONSTANT CHAR-HYPER-BIT 8)

;; This macro to coerce string arguments to other string functions.

(DEFMACRO COERCE-STRING-ARG (ARG-NAME &OPTIONAL DESTRUCTIVE)
  `(IF ,DESTRUCTIVE
       (CL:CHECK-TYPE ,ARG-NAME STRING)
       (UNLESS (STRINGP ,ARG-NAME)
	 (SETQ ,ARG-NAME (STRING ,ARG-NAME)))))

(DEFMACRO CHECK-CHAR-ARG (ARG-NAME)
  `(CHECK-ARG ,ARG-NAME CHARACTERP "a character"))

;;; Character functions which are available to users.

(DEFSUBST CHARACTERP (OBJECT)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (= (%DATA-TYPE OBJECT) DTP-CHARACTER))

(DEFUN INT-CHAR (INTEGER)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE))		;not REDUCIBLE
  (CL:CHECK-TYPE INTEGER #+IMACH CL:FIXNUM #+3600 (CL:UNSIGNED-BYTE #.(BYTE-SIZE %%CHAR-ALL)))
  (%MAKE-CHARACTER INTEGER))

(DEFSUBST CHAR-INT (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE))		;not REDUCIBLE
  (CHAR-LDB-INTERNAL %%CHAR-ALL CHAR))

(DEFSUBST CHAR-CODE (CHAR)
  "Return the character code for this character, ignoring style and bits"
  (DECLARE LT:(SIDE-EFFECTS SIMPLE))		;not REDUCIBLE
  (CHAR-LDB-INTERNAL %%CHAR-CODE CHAR))

(DEFSUBST CHAR-BITS (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (CHAR-LDB-INTERNAL %%CHAR-BITS CHAR))

(DEFSUBST CHAR-CHAR-SET-INDEX (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE))
  (CHAR-LDB-INTERNAL %%CHAR-CHAR-SET CHAR))

(DEFSUBST CHAR-SUBINDEX (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (CHAR-LDB-INTERNAL %%CHAR-SUBINDEX CHAR))

(DEFSUBST CHAR-STYLE-INDEX (CHAR)		;not REDUCIBLE
  (DECLARE LT:(SIDE-EFFECTS SIMPLE))
  (CHAR-LDB-INTERNAL %%CHAR-STYLE CHAR))

;; This function has a compiler optimizer for the fast case.
(DEFUN CODE-CHAR (CODE &OPTIONAL (BITS 0) (FONT 0))
  (DECLARE LT:(SIDE-EFFECTS SIMPLE))		;not REDUCIBLE
  (UNLESS (AND (<= 0 BITS (1- CHAR-BITS-LIMIT))
	       (<= 0 FONT (1- CHAR-FONT-LIMIT)))
    (FERROR "BITS or FONT out of range."))	       
  (%MAKE-CHARACTER (%LOGDPB BITS %%CHAR-BITS CODE)))

;; This function has a compiler optimizer for the fast case.
(DEFUN MAKE-CHAR (CHAR &OPTIONAL (BITS 0) (FONT 0))
  (DECLARE LT:(SIDE-EFFECTS SIMPLE))		;not REDUCIBLE
  (WHEN (AND (<= 0 FONT (1- CHAR-FONT-LIMIT))
	     (<= 0 BITS (1- CHAR-BITS-LIMIT)))
    (SETQ CHAR (MAKE-CHAR CHAR))		;Inline version to get proper stripping.
    (SETF (CHAR-BITS CHAR) BITS)
    CHAR))

;;; This is called with style already parsed, at compile time.
;;; Therefore, it doesn't do run-time error checking.  Don't call it
;;; otherwise!
(DEFUN MAKE-CHARACTER-INTERNAL (CHAR BITS STYLE)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (LET ((NEW-CHAR (CHAR-DPB-INTERNAL BITS %%CHAR-BITS	;Open-code D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")make-char
0				     (CHAR-DPB-INTERNAL 0 %%CHAR-STYLE CHAR))))
    (UNLESS (OR (CHAR-EQUAL CHAR #/Return)
		(NOT (ZEROP BITS)))
      (SETF (SI:CHAR-STYLE-INDEX NEW-CHAR)
	    (OR (CS-INDEX STYLE)
		(LOOKUP-STYLE-INDEX STYLE))))
    NEW-CHAR))

;;; This has a compiler optimizer that parses constant styles, open-codes if
;;; (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")bits0 is constant (0 or otherwise), etc.
(DEFUN MAKE-CHARACTER (CHAR &KEY (BITS 0) (STYLE NIL))
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (MAKE-CHARACTER-INTERNAL CHAR BITS (SI:PARSE-CHARACTER-STYLE (OR STYLE SI:*NULL-STYLE*))))


(DEFUN NAME-BIT (NAME)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (SELECTQ NAME
    (:CONTROL CHAR-CONTROL-BIT)
    (:META CHAR-META-BIT)
    (:SUPER CHAR-SUPER-BIT)
    (:HYPER CHAR-HYPER-BIT)
    (T (FERROR "Unknown bit name: ~S" NAME))))

(DEFUN CHAR-BIT (CHAR NAME)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (BIT-TEST (NAME-BIT NAME) (CHAR-BITS CHAR)))

(CL:DEFINE-SETF-METHOD CHAR-BIT (CHARACTER NAME &ENVIRONMENT ENV)
  (MULTIPLE-VALUE-BIND (CHAR-TEMPS CHAR-VALS CHAR-STORES CHAR-STORE-FORM CHAR-ACCESS-FORM)
      (CL:GET-SETF-METHOD CHARACTER ENV)
    (LET ((STORE (GENSYM))
	  (NTEMP (GENSYM))
	  (VTEMP (GENSYM)))
      (LET ((*SIMPLE-VARIABLES* (APPEND CHAR-TEMPS (LIST NTEMP))))
	(VALUES *SIMPLE-VARIABLES*
		(APPEND CHAR-VALS (LIST NAME))
		(LIST STORE)
		`(LET-VALUE ,VTEMP ,STORE
			    ,(LT:LET-SUBST CHAR-STORES
					   `((SET-CHAR-BIT ,CHAR-ACCESS-FORM ,NTEMP ,VTEMP))
					   CHAR-STORE-FORM
					   ENV))
		`(CHAR-BIT ,CHAR-ACCESS-FORM ,NTEMP))))))

(DEFUN SET-CHAR-BIT (CHAR NAME VALUE)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (SETF (CHAR-BITS CHAR)
	(BOOLE (IF VALUE
		   CL:BOOLE-IOR
		   CL:BOOLE-ANDC2)
	       (CHAR-BITS CHAR)
	       (NAME-BIT NAME)))
  CHAR)

(DEFUN CHARACTER (X)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (CL:ETYPECASE X
    (CL:CHARACTER X)
    (CL:STRING (IF (= (STRING-LENGTH X) 1)
		   (AREF X 0)
		   (FERROR "~S is not one character long." X)))
    (CL:SYMBOL (CHARACTER (GET-PNAME X)))
    (CL:INTEGER (INT-CHAR X))))

(DEFUN DIGIT-CHAR (WEIGHT &OPTIONAL (RADIX 10.) (FONT 0))
  (DECLARE LT:(SIDE-EFFECTS SIMPLE))
  (AND (<= 2 RADIX 36.)
       (NOT (MINUSP WEIGHT))
       (< WEIGHT RADIX)
       (MAKE-CHAR (AREF *WEIGHT-DIGITS* WEIGHT) 0 FONT)))

(DEFUN CHAR-NAME (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (AND (ZEROP (CHAR-BITS CHAR))
       (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR))
	   (WHEN (VARIABLE-BOUNDP *STANDARD-CHARACTER-SET*)
	     (SEND *STANDARD-CHARACTER-SET* :CHAR-NAME (CHAR-CODE CHAR)))
	   (MULTIPLE-VALUE-BIND (CHAR-SET INDEX)
	       (CHAR-CHAR-SET-AND-INDEX CHAR)
	     (MULTIPLE-VALUE-BIND (CHAR-NAME SET-NAME)
		 (SEND CHAR-SET :CHAR-NAME INDEX)
	       (WHEN CHAR-NAME 
		 (STRING-APPEND SET-NAME #/: CHAR-NAME)))))))

(DEFUN NAME-CHAR (NAME)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE))
  (COERCE-STRING-ARG NAME)
  (LET ((CODE (LET ((INDEX (STRING-SEARCH-CHAR #/: NAME)))
		(IF INDEX
		    (LET ((SET (LOOKUP-CHARACTER-SET (SUBSTRING NAME 0 INDEX) NIL)))
		      (WHEN SET
			(SEND SET :NAME-CHAR (SUBSTRING NAME (1+ INDEX)))))
		    (SEND *STANDARD-CHARACTER-SET* :NAME-CHAR NAME)))))
    (AND CODE (CODE-CHAR CODE))))



;;; Character comparisons that look only at the code, and ignore alphabetic case

;; T if two characters are equal, ignoring font and alphabetic case
;; for those in the standard character set.
;;; This is in microcode.
#+IMACH
(DEFUN CHAR-EQUAL-INTERNAL (CHAR1 CHAR2)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE))
  (LET ((CODE1 (CHAR-CODE CHAR1))
	(CODE2 (CHAR-CODE CHAR2))
	(BITS1 (CHAR-BITS CHAR1))
	(BITS2 (CHAR-BITS CHAR2)))
    (IF (ZEROP BITS1)
	(IF (ZEROP BITS2)
	    (OR (= CODE1 CODE2)
		(IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR1))
		    (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR2))
			(AND (ZEROP (LOGAND #O337 (LOGXOR CODE1 CODE2)))
			     (OR (CODE-UPPER-CASE-P CODE1) (CODE-LOWER-CASE-P CODE1))
			     (OR (CODE-UPPER-CASE-P CODE2) (CODE-LOWER-CASE-P CODE2)))
			NIL)
		    (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR2))
			NIL
			(CHAR-EQUAL-ESCAPE CHAR1 CHAR2))))
	    NIL)
	(IF (= BITS1 BITS2)
	    (= CODE1 CODE2)
	    NIL))))

;;; This will not be in microcode.
(DEFUN CHAR-EQUAL-ESCAPE (CHAR1 CHAR2)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE) (SAFEGUARDED-FUNCTION)
	   (UNSAFEGUARDED-REFERENCE SI:CHAR-CHAR-SET-AND-INDEX :CHAR-EQUAL))
  (MULTIPLE-VALUE-BIND (CHAR-SET-1 INDEX-1)
      (CHAR-CHAR-SET-AND-INDEX CHAR1)
    (MULTIPLE-VALUE-BIND (CHAR-SET-2 INDEX-2)
	(CHAR-CHAR-SET-AND-INDEX CHAR2)
      (AND (EQ CHAR-SET-1 CHAR-SET-2)
	   (SEND CHAR-SET-1 :CHAR-EQUAL INDEX-1 INDEX-2)))))

;; Order characters, ignoring font,
;; Use dictionary order using char-set, then char-bits, and finally char-code.  If char-bits
;; of both characters are zero, then ignore alphabetic case in a character set dependent
;; way.
(DEFUN CHAR-LESSP-INTERNAL (CHAR1 CHAR2)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE))
  (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR1))
      (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR2))
	  (LET ((BITS1 (CHAR-BITS CHAR1))
		(BITS2 (CHAR-BITS CHAR2)))
	    (IF (ZEROP BITS1)
		(IF (ZEROP BITS2)
		    (LET ((CODE1 (CHAR-CODE CHAR1))
			  (CODE2 (CHAR-CODE CHAR2)))
		      (WHEN (CODE-LOWER-CASE-P CODE1)
			(SETQ CODE1 (LOGXOR CODE1 #O40)))
		      (WHEN (CODE-LOWER-CASE-P CODE2)
			(SETQ CODE2 (LOGXOR CODE2 #O40)))
		      (< CODE1 CODE2))
		    T)
		(OR (< BITS1 BITS2)
		    (AND (= BITS1 BITS2)
			 (< (CHAR-CODE CHAR1)
			    (CHAR-CODE CHAR2))))))
	  T)
      (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR2))
	  NIL
	  (MULTIPLE-VALUE-BIND (CHAR-SET-1 INDEX-1)
	      (CHAR-CHAR-SET-AND-INDEX CHAR1)
	    (MULTIPLE-VALUE-BIND (CHAR-SET-2 INDEX-2)
		(CHAR-CHAR-SET-AND-INDEX CHAR2)
	      (IF (EQ CHAR-SET-1 CHAR-SET-2)
		  (LET ((BITS1 (CHAR-BITS CHAR1))
			(BITS2 (CHAR-BITS CHAR2)))
		    (IF (ZEROP BITS1)
			(IF (ZEROP BITS2)
			    (SEND CHAR-SET-1 :CHAR-LESSP INDEX-1 INDEX-2)
			    T)
			(OR (< BITS1 BITS2)
			    (AND (= BITS1 BITS2)
				 (< INDEX-1 INDEX-2)))))
		  (< (CHAR-CHAR-SET-INDEX CHAR1) (CHAR-CHAR-SET-INDEX CHAR2))))))))


(COMPILER:DEFINE-CHARACTER-COMPARISON-OPERATION CHAR-EQUAL
  (LAMBDA (X Y) `(CHAR-EQUAL-INTERNAL ,X ,Y)))
(COMPILER:DEFINE-CHARACTER-NOT-EQUAL-OPERATION CHAR-NOT-EQUAL
  (LAMBDA (X Y) `(NOT (CHAR-EQUAL-INTERNAL ,X ,Y))))
(COMPILER:DEFINE-CHARACTER-COMPARISON-OPERATION CHAR-LESSP
  (LAMBDA (X Y) `(CHAR-LESSP-INTERNAL ,X ,Y)))
(COMPILER:DEFINE-CHARACTER-COMPARISON-OPERATION CHAR-GREATERP
  (LAMBDA (X Y) `(CHAR-LESSP-INTERNAL ,Y ,X)))
(COMPILER:DEFINE-CHARACTER-COMPARISON-OPERATION CHAR-NOT-LESSP
  (LAMBDA (X Y) `(NOT (CHAR-LESSP-INTERNAL ,X ,Y))))
(COMPILER:DEFINE-CHARACTER-COMPARISON-OPERATION CHAR-NOT-GREATERP
  (LAMBDA (X Y) `(NOT (CHAR-LESSP-INTERNAL ,Y ,X))))

;;; Case-, style-, and bits-dependent character comparisons

;; The IMACH versions of these two functions exist only to support
;; files compiled in Genera 7.3

;; This is in microcode on the 3600, inline on Ivory.
#+IMACH
(DEFSUBST CHAR=-INTERNAL (CHAR1 CHAR2)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE))
  (= (CHAR-INT CHAR1) (CHAR-INT CHAR2)))

;;; This will not be in microcode.
(DEFSUBST CHAR<-INTERNAL (CHAR1 CHAR2)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE))
  (#+3600 < #+imach %UNSIGNED-LESSP (CHAR-INT CHAR1) (CHAR-INT CHAR2)))

(COMPILER:DEFINE-CHARACTER-COMPARISON-OPERATION CHAR=
  (LAMBDA (X Y) `(CHAR=-INTERNAL ,X ,Y)))
(COMPILER:DEFINE-CHARACTER-NOT-EQUAL-OPERATION CHAR
  (LAMBDA (X Y) `(NOT (CHAR=-INTERNAL ,X ,Y))))
(COMPILER:DEFINE-CHARACTER-COMPARISON-OPERATION CHAR<
  (LAMBDA (X Y) `(CHAR<-INTERNAL ,X ,Y)))
(COMPILER:DEFINE-CHARACTER-COMPARISON-OPERATION CHAR>
  (LAMBDA (X Y) `(CHAR<-INTERNAL ,Y ,X)))
(COMPILER:DEFINE-CHARACTER-COMPARISON-OPERATION CHAR
  (LAMBDA (X Y) `(NOT (CHAR<-INTERNAL ,X ,Y))))
(COMPILER:DEFINE-CHARACTER-COMPARISON-OPERATION CHAR
  (LAMBDA (X Y) `(NOT (CHAR<-INTERNAL ,Y ,X))))



;;; Character predicates

(DEFSUBST CHAR-FAT-P (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (NOT (ZEROP (CHAR-LDB-INTERNAL %%CHAR-ALL-BUT-SUBINDEX CHAR))))

(DEFUN GRAPHIC-CHAR-P (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (AND (ZEROP (CHAR-BITS CHAR))
       (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR))
	   (< (CHAR-SUBINDEX CHAR) #O200)
	   (MULTIPLE-VALUE-BIND (CHAR-SET INDEX)
	       (CHAR-CHAR-SET-AND-INDEX CHAR)
	     (SEND CHAR-SET :GRAPHIC-CHAR-P INDEX)))))

;;; A non-Common-Lisp predicate which is true if the character produces an
;;; invisible or illegible mark on the display, and thus should be portrayed
;;; as its name rather than itself.  This is almost (NOT (GRAPHIC-CHAR-P CHAR))
;;; except that the CHAR-BITS don't matter and Common Lisp says that Space is graphic.
;;;--- Unclear what to do about space characters in other character sets.
(DEFUN FORMATTING-CHAR-P (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR))
      (OR (CHAR-EQUAL CHAR #\SPACE)
	  ( (CHAR-SUBINDEX CHAR) #O200))
      (MULTIPLE-VALUE-BIND (CHAR-SET INDEX)
	  (CHAR-CHAR-SET-AND-INDEX CHAR)
	(NOT (SEND CHAR-SET :GRAPHIC-CHAR-P INDEX)))))

(DEFUN UPPER-CASE-P (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (AND (ZEROP (CHAR-BITS CHAR))
       (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR))
	   (CODE-UPPER-CASE-P (CHAR-SUBINDEX CHAR))
	   (MULTIPLE-VALUE-BIND (CHAR-SET INDEX)
	       (CHAR-CHAR-SET-AND-INDEX CHAR)
	     (SEND CHAR-SET :UPPER-CASE-P INDEX)))))

(DEFUN LOWER-CASE-P (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (AND (ZEROP (CHAR-BITS CHAR))
       (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR))
	   (CODE-LOWER-CASE-P (CHAR-SUBINDEX CHAR))
	   (MULTIPLE-VALUE-BIND (CHAR-SET INDEX)
	       (CHAR-CHAR-SET-AND-INDEX CHAR)
	     (SEND CHAR-SET :LOWER-CASE-P INDEX)))))

(DEFUN BOTH-CASE-P (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (AND (ZEROP (CHAR-BITS CHAR))
       (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR))
	   (LET ((CODE (CHAR-SUBINDEX CHAR)))
	     (OR (CODE-UPPER-CASE-P CODE) (CODE-LOWER-CASE-P CODE)))
	   (MULTIPLE-VALUE-BIND (CHAR-SET INDEX)
	       (CHAR-CHAR-SET-AND-INDEX CHAR)
	     (SEND CHAR-SET :BOTH-CASE-P INDEX)))))

(DEFUN ALPHA-CHAR-P (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (AND (ZEROP (CHAR-BITS CHAR))
       (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR))
	   (LET ((CODE (CHAR-SUBINDEX CHAR)))
	     (OR (CODE-UPPER-CASE-P CODE) (CODE-LOWER-CASE-P CODE)))
	   (MULTIPLE-VALUE-BIND (CHAR-SET INDEX)
	       (CHAR-CHAR-SET-AND-INDEX CHAR)
	     (SEND CHAR-SET :ALPHA-CHAR-P INDEX)))))

(DEFUN DIGIT-CHAR-P (CHAR &OPTIONAL (RADIX 10.))
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (LET ((INDEX (LET ((CODE (CHAR-CODE CHAR)))
		 (IF (<= (CHAR-CODE #/0) CODE (CHAR-CODE #/9))
		     (- CODE (CHAR-CODE #/0))
		     (WHEN (> RADIX 10.)
		       (COND ((CODE-UPPER-CASE-P CODE)
			      (+ 10. (- CODE (CHAR-CODE #/A))))
			     ((CODE-LOWER-CASE-P CODE)
			      (+ 10. (- CODE (CHAR-CODE #/a))))))))))
    (AND INDEX (< INDEX RADIX) INDEX)))

(DEFUN ALPHANUMERICP (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (OR (ALPHA-CHAR-P CHAR) (NOT (NULL (DIGIT-CHAR-P CHAR)))))

(DEFUN DIACRITIC-CHAR-P (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (AND (ZEROP (CHAR-BITS CHAR))
       (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR))
	   ( #o300 (CHAR-SUBINDEX CHAR) #o317)
	   (MULTIPLE-VALUE-BIND (CHAR-SET INDEX)
	       (CHAR-CHAR-SET-AND-INDEX CHAR)
	     (SEND CHAR-SET :DIACRITIC-CHAR-P INDEX)))))

(DEFUN CHAR-UPCASE (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (WHEN (ZEROP (CHAR-BITS CHAR))
    (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR))
	(LET ((CODE (CHAR-SUBINDEX CHAR)))
	  (WHEN (CODE-LOWER-CASE-P CODE)
	    (SETF (CHAR-SUBINDEX CHAR) (LOGXOR #O40 CODE))))
	(MULTIPLE-VALUE-BIND (CHAR-SET INDEX)
	    (CHAR-CHAR-SET-AND-INDEX CHAR)
	  (LET ((NEW-INDEX (SEND CHAR-SET :CHAR-UPCASE INDEX)))
	    (UNLESS (= INDEX NEW-INDEX)
	      (SETF (CHAR-CODE CHAR) (SEND CHAR-SET :MAKE-CHAR NEW-INDEX)))))))
  CHAR)

(DEFUN CHAR-DOWNCASE (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (WHEN (ZEROP (CHAR-BITS CHAR))
    (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR))
	(LET ((CODE (CHAR-SUBINDEX CHAR)))
	  (WHEN (CODE-UPPER-CASE-P CODE)
	    (SETF (CHAR-SUBINDEX CHAR) (LOGXOR #O40 CODE))))
	(MULTIPLE-VALUE-BIND (CHAR-SET INDEX)
	    (CHAR-CHAR-SET-AND-INDEX CHAR)
	  (LET ((NEW-INDEX (SEND CHAR-SET :CHAR-DOWNCASE INDEX)))
	    (UNLESS (= INDEX NEW-INDEX)
	      (SETF (CHAR-CODE CHAR) (SEND CHAR-SET :MAKE-CHAR NEW-INDEX)))))))
  CHAR)

(DEFUN CHAR-FLIPCASE (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (WHEN (ZEROP (CHAR-BITS CHAR))
    (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR))
	(LET ((CODE (CHAR-SUBINDEX CHAR)))
	  (WHEN (OR (CODE-UPPER-CASE-P CODE) (CODE-LOWER-CASE-P CODE))
	    (SETF (CHAR-SUBINDEX CHAR) (LOGXOR #O40 CODE))))
	(MULTIPLE-VALUE-BIND (CHAR-SET INDEX)
	    (CHAR-CHAR-SET-AND-INDEX CHAR)
	  (LET ((NEW-INDEX (SEND CHAR-SET :CHAR-FLIPCASE INDEX)))
	    (UNLESS (= INDEX NEW-INDEX)
	      (SETF (CHAR-CODE CHAR) (SEND CHAR-SET :MAKE-CHAR NEW-INDEX)))))))
  CHAR)

;;; These functions are used by low-level I/O code.

(DEFSUBST %CHAR-ALL-BUT-SUBINDEX (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE))
  (CHAR-LDB-INTERNAL %%CHAR-ALL-BUT-SUBINDEX CHAR))

;;; Returns T if the two characters have the same style and character set.
;;; Code is highly bummed for speed.
(DEFUN %CHARS-SHARE-DEVICE-FONT-P (CHAR FIRST-CHAR SUBINDEX-IS-INDEX)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE))
  (IF SUBINDEX-IS-INDEX
      (WHEN (= (%CHAR-ALL-BUT-SUBINDEX CHAR) (%CHAR-ALL-BUT-SUBINDEX FIRST-CHAR))
	(CHAR-SUBINDEX CHAR))
      (WHEN (= (CHAR-STYLE-INDEX CHAR) (CHAR-STYLE-INDEX FIRST-CHAR))
	(MULTIPLE-VALUE-BIND (CHAR-SET INDEX)
	    (CHAR-CHAR-SET-AND-INDEX CHAR)
	  (WHEN (EQ CHAR-SET (CHAR-CHAR-SET-AND-INDEX FIRST-CHAR))
	    INDEX)))))

(DEFUN SXHASH-CHARACTER (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE))
  (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR))
      (LOGAND (CHAR-SUBINDEX CHAR) #O337)
      (MULTIPLE-VALUE-BIND (CHAR-SET INDEX)
	  (CHAR-CHAR-SET-AND-INDEX CHAR)
	(SEND CHAR-SET :EQUAL-HASH INDEX))))



;The string functions:

;(STRING-LENGTH string) returns the number of characters in a given string.
;(SUBSTRING string from to) returns an arbitrary substring of a given string, copied.
; Omitting <to> means go all the way to the end of the string.
;(NSUBSTRING string from to) is like SUBSTRING, but returns a shared substring, not copied.
;(STRING-APPEND string ...) concatenates strings.
;(STRING-NCONC string1 string ...) concatenates strings by extending.
;(STRING-NCONC-PORTION string1 {string from to} ...) concatenates parts of strings.
;(STRING-SEARCH-CHAR char string from to) searches a string for a given character.
;  Returns index if found, else NIL.
;(STRING-REVERSE-SEARCH-CHAR char string from to) searches backwards, as above.
;(STRING-SEARCH-NOT-CHAR char string from to) searches a string for anything other
;   than a given char.  Returns index if found, else NIL.
;(STRING-REVERSE-SEARCH-NOT-CHAR char string from to) searches backwards, as above.
;(STRING-SEARCH key string from to) searches for <key> in <string>.
;  Returns index if found, else NIL.
;(STRING-REVERSE-SEARCH key string from to) searches backwards for <key> in <string>.
;(STRING-SEARCH-SET charlist string from to) searches in <string> from <from>
; for a char in <charlist>.
;(STRING-SEARCH-NOT-SET charlist string from to) searches in <string> from <from>
; for a char not in <charlist>.
;(STRING-REVERSE-SEARCH-SET charlist string from to) searches backwards in <string>
; from <from> for a char in <charlist>.
;(STRING-REVERSE-SEARCH-NOT-SET charlist string from to) searches backwards in <string>
; from <from> for a char not in <charlist>.
;(STRING-TRIM charlist string) returns a copy of <string> with all leading and
; trailing members of <charlist> truncated.
;(STRING-LEFT-TRIM charlist string) is like STRING-TRIM but only hacks leading characters.
;(STRING-RIGHT-TRIM charlist string) is analogous.
;(STRING-NREVERSE string) reverses the elements of <string>, in place.
;(STRING-REVERSE string) returns a copy of <string> with the characters reversed.
;(STRING-UPCASE string) returns string copied and converted to all upper case.
;(STRING-DOWNCASE string) returns string copied and converted to all lower case.
;(CHAR-UPCASE char) returns the character converted to upper case.
;(CHAR-DOWNCASE char) returns the character converted to lower case.
;(STRING-COMPARE s1 s2 &optional (from1 0) (from2 0) to1 to2)
;(STRING-LESSP s1 s2) says whether s1 is less than s2, in dictionary ordering.
;(SUBSTRING-AFTER-CHAR char string) "" if char not in string.
;(STRING-PLURALIZE string) returns plural of word in string.
;(STRING-CAPITALIZE-WORDS string) turns hyphens into spaces and capitalizes
; the first letter of each word.
;STRING turns a character (ie, a number) into a string containing just that character.
; It turns a symbol into its pname.  A string is returned unchanged.
;STRINGP returns T if its arg is a string.
;MAKE-STRING takes a list of characters (numbers) and returns a string containing them.
; The inverse of MAKE-STRING is EXPLODEC, sort of.
; You probably want to use STRING-APPEND instead.
;STRING-EQUAL what EQUAL uses to compare strings

;SUBSTRING and NSUBSTRING take an optional area argument.

;Note that most of the functions in this package will consider a number
;to be a string one character long.  However, they will never return
;a number instead of a string one character long.
;Symbols given as arguments will be converted into their pnames.



;True of all 1-dimensional arrays of characters and 1-dimensional arrays of
;numbers that stand for characters.

#+CADR ;In microcode now.
(DEFUN STRINGP (X)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (AND (ARRAYP X)
       ( (ARRAY-DISPATCH-FIELD X) %ARRAY-DISPATCH-LONG-MULTIDIMENSIONAL)
       (LET ((TYPE (ARRAY-TYPE-FIELD X)))
	 (OR (= TYPE ART-STRING)
	     (= TYPE ART-FAT-STRING)))))

(DEFSUBST STRING-FAT-P (STRING)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (= (ARRAY-TYPE-FIELD STRING) ART-FAT-STRING))

;; STRING-APPEND concatenates any number of strings, arrays, symbols, or fixnums.  Symbols
;; and fixnums are coerced.  A single string will be copied.  An empty string will be
;; returned if given no arguments.  The type of the result is the same as the type of the
;; argument with the greatest number of bits per element.
(DEFUN STRING-APPEND (&REST STRINGS &AUX STRING)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (LET ((LENGTH 0)
	(FAT-P NIL))
    ;; Figure out how big it has to be.
    (LOOP WITH COPIED = NIL
	  FOR S IN STRINGS
	  FOR POS FROM 0
	  DO (COND ((CHARACTERP S)
		    (INCF LENGTH)
		    (WHEN (CHAR-FAT-P S)
		      (SETF FAT-P T)))
		   (T (UNLESS (ARRAYP S)
			(UNLESS COPIED
			  (SETF STRINGS (COPYLIST STRINGS))
			  (SETF COPIED T))
			(LET ((NEW-S (STRING S)))
			  (SETF (NTH POS STRINGS) NEW-S)
			  (SETF S NEW-S)))
		      (INCF LENGTH (ARRAY-ACTIVE-LENGTH S))
		      (WHEN (STRING-FAT-P S)
			(SETF FAT-P T)))))
    ;; Make the new string
    (SETQ STRING (MAKE-ARRAY LENGTH :TYPE (IF FAT-P 'ART-FAT-STRING 'ART-STRING))))
  ;; Copy stuff into it
  (LOOP WITH I = 0
	FOR S IN STRINGS DO
    (COND ((CHARACTERP S)
	   (SETF (AREF STRING I) (CHARACTER S))
	   (INCF I))
	  (T (LET ((LENGTH (ARRAY-ACTIVE-LENGTH S)))
	       (COPY-ARRAY-PORTION S 0 LENGTH STRING I (INCF I LENGTH))))))
  STRING)

(DEFUN STRING-NCONC (TO-STRING &REST STRINGS &AUX LEN FINAL-LEN S2LEN)
  "STRING-NCONC extends the first string and tacks on any number of additional strings.
   The first argument must be a string with a fill-pointer.
   Returns the first argument, which may have been moved and forwarded,
   just like ADJUST-ARRAY-SIZE."
  (SETQ FINAL-LEN (SETQ LEN (FILL-POINTER TO-STRING)))
  (DOLIST (STR2 STRINGS)
    (INCF FINAL-LEN (STRING-LENGTH STR2)))
  (WHEN (> FINAL-LEN (ARRAY-LENGTH TO-STRING))
    (ADJUST-ARRAY-SIZE TO-STRING FINAL-LEN))
  (DOLIST (STR2 STRINGS)
    (COND ((CHARACTERP STR2)
	   (ARRAY-PUSH TO-STRING (CHARACTER STR2))
	   (INCF LEN))
	  (T
	   (SETQ STR2 (IF (STRINGP STR2) STR2 (STRING STR2))
		 S2LEN (ARRAY-ACTIVE-LENGTH STR2))
	   (COPY-ARRAY-PORTION STR2 0 S2LEN TO-STRING LEN (INCF LEN S2LEN))
	   (SETF (FILL-POINTER TO-STRING) LEN))))
  TO-STRING)

;;;For adding stuff onto a string without having to cons multitudes of substrings.  Just
;;;make sure the first arg string has a fill pointer and the second arg can be anything.
;;;The first arg gets added to.  It can also get structure forwarded and stuff if it has
;;;to grow to hold all the contents, so it is also returned by the function.
;;;It takes a rest argument of "string portion specs", being string/from/to triples.
;;;From and to are required but can be nil and nil.
(DEFUN STRING-NCONC-PORTION (TO-STRING &REST STRING-DATA)
  (DECLARE (ARGLIST TO-STRING {FROM-STRING FROM TO} ...))
  (LOOP FOR (FROM-STRING FROM TO) ON STRING-DATA BY 'REST3
	DO (SETQ FROM-STRING (STRING FROM-STRING))	;coerce to string, to accept symbols, chars
	   (UNLESS (AND (OR (NOT FROM) (TYPEP FROM :NUMBER))
			(OR (NOT TO) (TYPEP TO :NUMBER)))
	     (FERROR "Need from and to indexes for ~S, received ~D ~D" FROM-STRING FROM TO))
	   (SETQ TO-STRING
		 (ARRAY-PUSH-PORTION-EXTEND TO-STRING FROM-STRING (OR FROM 0) TO)))
  TO-STRING)

;STRING-LENGTH returns the length in characters of a given string.
(DEFUN STRING-LENGTH (STRING &AUX TEM)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COND ((ARRAYP STRING) (ARRAY-ACTIVE-LENGTH STRING))
	((CHARACTERP STRING) 1)
	((SYMBOLP STRING) (ARRAY-ACTIVE-LENGTH (GET-PNAME STRING)))
	((AND (TYPEP STRING ':INSTANCE)
	      (SETQ TEM (SEND STRING ':SEND-IF-HANDLES ':STRING-FOR-PRINTING)))
	 (ARRAY-ACTIVE-LENGTH TEM))
	(T (FERROR "Cannot coerce ~S into a string." STRING))))

(DEFUN STRING (X)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COND ((STRINGP X) X)
        ((SYMBOLP X)
	 (GET-PNAME X))
	((CHARACTERP X)
	 (LET ((STR (MAKE-ARRAY 1 :TYPE (IF (CHAR-FAT-P X) 'ART-FAT-STRING 'ART-STRING))))
	   (SETF (AREF STR 0) X)
	   STR))
	((AND (TYPEP X ':INSTANCE)
	      (SEND X ':SEND-IF-HANDLES ':STRING-FOR-PRINTING)))
	(T 
	 (FERROR "Cannot coerce ~S into a string" X))))


2;;
;; [ddyer] conceptually, this extends STRINGP to allow instances to be
;; considered as strings if they want to be.  This should be used
;; in place of STRINGP unless you are interested in the physical
;; representation of the string.
;; Since the value it returns is a real string or NIL, This function can
;;  be used as a predicate or as a converter from virtual strings to real strings.
;;
0(defun some-string (s)
  (cond ((stringp s) s)
	((and (instancep s)
	      (operation-handled-p s :string-for-printing))
	 (send s :string-for-printing))))
2;;
;; This is for use by SXHASH-STRING.  The problem is that the hash key for
;; string-equal hash tables musn't change, or else we won't be able to find
;; strings after we change languages.
;;
0(defun reference-string (s)
  (cond ((eq (typep s) 'mutable-string)
2	 ;this TYPEP test is a temporary expedient, until
	 ;the mutable-string flavor is installed.
0	 (get-reference-string s))
	(t (string s))))
2;;
;;this macro is intended for users of check-arg who want to check for strings
;;
0(defmacro check-string-arg (var)
  `(check-arg ,var (or (stringp ,var)
		       (symbolp ,var)
		       (let ((v (si:some-string ,var)))
			 (when v (setq ,var v))))
	      "a string or a symbol"))



;Return the plural of the word supplied as argument.
;Attempts to preserve the case-pattern and font-pattern of the word.
(DEFUN STRING-PLURALIZE (STRING)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  ;; Somehow ZL:STRING-PLURALIZE and SCL:STRING-PLURALIZE got split off from
  ;; each other. The SCL version wasn't picking up new fixes until I created
  ;; the ~\PLURALIZE\ format op without realizing I was using the unmaintained
  ;; version.  I've merged the better ZL algorithm with the new SCL modularity
  ;; to support format, so now again there's only one algorithm which tracks
  ;; all fixes.  I stopped short of merging the symbols only because I was
  ;; exhausted when I was done and had some deadline pressures hanging over me.
  ;; Someone should one day merge the two symbols. -kmp 2-Oct-89
  (SCL:STRING-PLURALIZE STRING))

;; The &OPTIONAL arg is a kludge to provide a non-copying version of this function until
;; a general philosophy is worked out which includes functions like STRING-TRIM and
;; STRING-PLURALIZE as well as this one.
(DEFUN STRING-CAPITALIZE-WORDS (STRING &OPTIONAL (COPY-P T) KEEP-HYPHEN)
  (COERCE-STRING-ARG STRING (NOT COPY-P))
  (WHEN COPY-P (SETQ STRING (SUBSTRING STRING 0)))
  (DO ((I 0 (1+ I))
       (FLAG T)
       (CHAR)
       (LIM (STRING-LENGTH STRING)))
      (( I LIM) STRING)
    (SETQ CHAR (AREF STRING I))
    (COND ((CHAR-EQUAL CHAR #/-)
	   (UNLESS KEEP-HYPHEN
	     (SETF (CHAR-CODE CHAR) (CHAR-CODE #\SP))
	     (SETF (AREF STRING I) CHAR))
	   (SETQ FLAG T))
	  ((CHAR-EQUAL CHAR #\SP)
	   (SETQ FLAG T))
	  (FLAG
	   (WHEN (LOWER-CASE-P CHAR)
	     (SETF (AREF STRING I) (CHAR-UPCASE CHAR)))
	   (SETQ FLAG NIL))
	  ((UPPER-CASE-P CHAR)
	   (SETF (AREF STRING I) (CHAR-DOWNCASE CHAR))))))

;;; Until character sets are implemented.
(DEFUN ASSURE-FAT-STRING (ARRAY &OPTIONAL CHECK-ONLY)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (COND ((STRING-FAT-P ARRAY)
	 ARRAY)
	((NOT CHECK-ONLY)
	 (LET ((NEW-ARRAY (MAKE-ARRAY (ARRAY-LENGTH ARRAY)
				      :TYPE 'ART-FAT-STRING
				      :LEADER-LENGTH (ARRAY-LEADER-LENGTH ARRAY))))
	   (COPY-ARRAY-CONTENTS-AND-LEADER ARRAY NEW-ARRAY)
	   NEW-ARRAY))))



;; Non-exact string comparisons

(DEFUN %STRING-EQUAL (STRING1 INDEX1 STRING2 INDEX2 COUNT)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COND ((IF (NULL COUNT)
	     ( (SETQ COUNT (- (ARRAY-ACTIVE-LENGTH STRING1) INDEX1))
		(- (ARRAY-ACTIVE-LENGTH STRING2) INDEX2))
	     (OR (> (+ INDEX1 COUNT) (ARRAY-ACTIVE-LENGTH STRING1))
		 (> (+ INDEX2 COUNT) (ARRAY-ACTIVE-LENGTH STRING2))))
	 NIL)
	;; Fast version which minimizes memory reads.
	((AND (> COUNT 4)			;AREF loop is faster in this case.
	      (ZEROP INDEX1)
	      (ZEROP INDEX2)
	      (LET ((H1 (%P-POINTER (SETQ STRING1 (FOLLOW-STRUCTURE-FORWARDING STRING1))))
		    (H2 (%P-POINTER (SETQ STRING2 (FOLLOW-STRUCTURE-FORWARDING STRING2)))))
		#+3600 (AND (= (LDB ARRAY-DISPATCH-FIELD H1) %ARRAY-DISPATCH-CHARACTER)
			    (= (LDB ARRAY-DISPATCH-FIELD H2) %ARRAY-DISPATCH-CHARACTER)
			    (= (LDB ARRAY-TYPE-FIELD     H1) ART-STRING)
			    (= (LDB ARRAY-TYPE-FIELD     H2) ART-STRING))
		#+IMach (AND (ZEROP (LDB ARRAY-LONG-PREFIX-BIT H1))
			     (ZEROP (LDB ARRAY-LONG-PREFIX-BIT H2))
			     (= (LDB ARRAY-TYPE-FIELD     H1) ART-STRING)
			     (= (LDB ARRAY-TYPE-FIELD     H2) ART-STRING))))
	 (#+IMach WITH-BLOCK-REGISTERS #+IMach (1 2) #+3600 PROGN
	  #+IMach (SETF (%BLOCK-REGISTER 1) (%MAKE-POINTER-OFFSET DTP-LOCATIVE STRING1 1))
	  #+IMach (SETF (%BLOCK-REGISTER 2) (%MAKE-POINTER-OFFSET DTP-LOCATIVE STRING2 1))
	  (LET* (#+3600 (POINTER1 (%MAKE-POINTER DTP-LOCATIVE STRING1))
		 #+3600 (POINTER2 (%MAKE-POINTER DTP-LOCATIVE STRING2))
		 (CASE-MASK (LOGIOR #o337 (LSH #o337 #o10) (LSH #o337 #o20) (LSH #o337 #o30)))
		 (INVERTED-CASE-MASK (LOGNOT CASE-MASK))
		 (MASK (LDB (BYTE 2 0) COUNT))
		 WORD1 DIFFERENCE)
	    (MACROLET ((CHAR-EQUAL-WORDS-P ()
			 `(OR (ZEROP DIFFERENCE)
			      (AND (ZEROP (LOGAND DIFFERENCE CASE-MASK))
				   (LOOP FOR DIFF-CHARS = (LOGAND DIFFERENCE
								  INVERTED-CASE-MASK)
							THEN (LDB (BYTE 24. 8) DIFF-CHARS)
					 UNTIL (ZEROP DIFF-CHARS)
					 FOR WORD = (LOGAND WORD1 CASE-MASK)
						  THEN (LDB (BYTE 24. 8) WORD)
					 ;; if the characters differ, they must be letters
					 ALWAYS (OR (ZEROP (LDB (BYTE 8 0) DIFF-CHARS))
						    ( #.(CHAR-INT #\A)
						       (LDB (BYTE 8 0) WORD)
						       #.(CHAR-INT #\Z))))))))
	      (DO ((N (LDB (BYTE #o35 2) COUNT) (1- N)))
		  (( N 0)
		   (OR (ZEROP MASK)
		       (PROGN (SETQ WORD1 #+3600  (%P-CONTENTS-INCREMENT-POINTER POINTER1)
				          #+IMach (%BLOCK-READ 1 :SET-CDR-NEXT T :PREFETCH NIL
							       :FIXNUM-ONLY T :NO-INCREMENT T))
			      (SETQ DIFFERENCE
				    (LOGAND (LOGXOR WORD1
					     #+3600  (%P-CONTENTS-INCREMENT-POINTER POINTER2)
					     #+IMach (%BLOCK-READ 2 :SET-CDR-NEXT T
								    :PREFETCH NIL
								    :FIXNUM-ONLY T
								    :NO-INCREMENT T))
					     (LSH -1 (- (DPB (- 4 MASK) (BYTE 2 3) 0)))))
			      (CHAR-EQUAL-WORDS-P))))
		(SETQ WORD1 #+3600 (%P-CONTENTS-INCREMENT-POINTER POINTER1)
			    #+IMach (%BLOCK-READ 1 :SET-CDR-NEXT T :PREFETCH NIL
							:FIXNUM-ONLY T))
		(SETQ DIFFERENCE (LOGXOR WORD1
					 #+3600 (%P-CONTENTS-INCREMENT-POINTER POINTER2)
					 #+IMach (%BLOCK-READ 2 :SET-CDR-NEXT T :PREFETCH NIL
							      :FIXNUM-ONLY T)))
		(UNLESS (CHAR-EQUAL-WORDS-P)
		  (RETURN NIL)))))))
	(T (LET ((STRING1 STRING1) (STRING2 STRING2))
	     (DECLARE (SYS:ARRAY-REGISTER STRING1 STRING2))
	     (DO () ((ZEROP COUNT) T)
	       (UNLESS (CHAR-EQUAL (AREF STRING1 INDEX1) (AREF STRING2 INDEX2))
		 (RETURN NIL))
	       (INCF INDEX1)
	       (INCF INDEX2)
	       (DECF COUNT))))))

#| Metering for hairy string functions |
;; I think this is a pretty exhaustive test of everything which can go wrong
;; in %STRING-EQUAL and %STRING=
(DEFUN TEST-NEW-%STRING-EQUAL ()
  (LET ((TEST-STRINGS '#.(LET ((STR "abcdefgh"))
			   (APPEND (NCONS STR)
				   (LOOP FOR I BELOW 8
					 AS S = (SUBSTRING STR 0)
					 DO (SETF (AREF S I)
						  (CHAR-UPCASE (AREF S I)))
					 COLLECT S)
				   (LOOP FOR I BELOW 7
					 AS S = (SUBSTRING STR 0)
					 DO (SETF (AREF S I)
						  (CHAR-UPCASE (AREF S I)))
					    (SETF (AREF S (1+ I))
						  (CHAR-UPCASE (AREF S (1+ I))))
					 COLLECT S)
				   (LOOP FOR I BELOW 8
					 AS S = (SUBSTRING STR 0)
					 DO (SETF (AREF S I) #\X)
					 COLLECT S)
				   (LIST "[[[[[[[[" "{{{{{{{{")))))
    (FLET ((TEST (STRING1 STRING2 &OPTIONAL COUNT)
	     (UNLESS (EQL (NEW-%STRING-EQUAL STRING1 0 STRING2 0 COUNT)
			  (%STRING-EQUAL STRING1 0 STRING2 0 COUNT))
	       (FORMAT T "~%Failed on %STRING-EQUAL ~S ~S ~S" STRING1 STRING2 COUNT))
	     (UNLESS (EQL (NEW-%STRING= STRING1 0 STRING2 0 COUNT)
			  (%STRING= STRING1 0 STRING2 0 COUNT))
	       (FORMAT T "~%Failed on %STRING= ~S ~S ~S" STRING1 STRING2 COUNT))))
      (LOOP FOR I FROM 0 TO 8 DO
	(LOOP FOR STRING1 IN TEST-STRINGS DO
	  (LOOP FOR STRING2 IN TEST-STRINGS DO
	    (TEST STRING1 STRING2 I))))
      (LOOP FOR STRING1 IN TEST-STRINGS DO
	(LOOP FOR STRING2 IN TEST-STRINGS DO
	  (TEST STRING1 STRING2))))))

(DEFUN METER-NEW-%STRING= ()
  (LABELS ((TEST (STRING1 STRING2)
	     (MULTIPLE-VALUE-BIND (OLD NEW)
		 (WITHOUT-INTERRUPTS
		   (VALUES (DO ((TIME (%MICROSECOND-CLOCK))
				(COUNT 100. (1- COUNT)))
			       (( COUNT 0)
				(%32-BIT-DIFFERENCE (%MICROSECOND-CLOCK) TIME))
			     (%STRING= STRING1 0 STRING2 0 NIL)
			     (%STRING= STRING1 0 STRING2 0 NIL)
			     (%STRING= STRING1 0 STRING2 0 NIL)
			     (%STRING= STRING1 0 STRING2 0 NIL))
			   (DO ((TIME (%MICROSECOND-CLOCK))
				(COUNT 100. (1- COUNT)))
			       (( COUNT 0)
				(%32-BIT-DIFFERENCE (%MICROSECOND-CLOCK) TIME))
			     (NEW-%STRING= STRING1 0 STRING2 0 NIL)
			     (NEW-%STRING= STRING1 0 STRING2 0 NIL)
			     (NEW-%STRING= STRING1 0 STRING2 0 NIL)
			     (NEW-%STRING= STRING1 0 STRING2 0 NIL))))
	       (FORMAT T "~%~36<(~2D) ~S:~;~> Old ~,,6$ us, New ~,,6$ us.  Ratio = ~$"
		       (STRING-LENGTH STRING1) STRING1 (// OLD 400.0) (// NEW 400.0)
		       (// (FLOAT NEW) OLD)))))
    (LOOP FOR I TO 26. DO
      (TEST (SUBSTRING "abcdefghijklmnopqrstuvwxyz" 0 I)
	    (SUBSTRING "abcdefghijklmnopqrstuvwxyz" 0 I)))))
||#

(DEFUN %STRING-COMPARE (STRING1 INDEX1 STRING2 INDEX2 COUNT)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (LET ((STRING1 STRING1) (STRING2 STRING2))
    (DECLARE (SYS:ARRAY-REGISTER STRING1 STRING2))
    (LET ((SUBRANGE1 (- (STRING-LENGTH STRING1) INDEX1))
	  (SUBRANGE2 (- (STRING-LENGTH STRING2) INDEX2))
	  (STATUS 0))
      (COND ((NULL COUNT)
	     (SETQ COUNT (MIN SUBRANGE1 SUBRANGE2)
		   STATUS 1))
	    ((> COUNT SUBRANGE1)
	     (COND ((> COUNT SUBRANGE2)
		    (SETQ COUNT (MIN SUBRANGE1 SUBRANGE2)
			  STATUS 1))
		   (T (SETQ COUNT SUBRANGE1
			    STATUS 2))))
	    ((> COUNT SUBRANGE2)
	     (SETQ COUNT SUBRANGE2
		   STATUS 3)))
      (DO ((I1 INDEX1 (1+ I1))
	   (I2 INDEX2 (1+ I2))
	   CHAR1 CHAR2)
	  ((ZEROP COUNT)
	   (SELECTQ STATUS
	     (0 0)
	     (1 (COND ((= SUBRANGE1 SUBRANGE2) 0)
		      ((< SUBRANGE1 SUBRANGE2) (- -1 I1))
		      (T (1+ I1))))
	     (2 (- INDEX1 I1 1))
	     (T (1+ (- I1 INDEX1)))))
	(SETQ CHAR1 (AREF STRING1 I1)
	      CHAR2 (AREF STRING2 I2))
	(OR (CHAR-EQUAL CHAR1 CHAR2)
	    (RETURN (IF (CHAR-LESSP CHAR1 CHAR2)
			(- INDEX1 I1 1)
			(- (1+ I1) INDEX1))))
	(DECF COUNT)))))

(DEFUN %STRING-LESSP (STRING1 STRING2)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (MINUSP (%STRING-COMPARE STRING1 0 STRING2 0 NIL)))

(DEFUN STRING-EQUAL (STRING1 STRING2 &OPTIONAL (IDX1 0) (IDX2 0) LIM1 LIM2)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COERCE-STRING-ARG STRING1)
  (COERCE-STRING-ARG STRING2)
  (COND ((OR LIM1 LIM2)
	 (OR LIM1 (SETQ LIM1 (ARRAY-ACTIVE-LENGTH STRING1)))
	 (OR LIM2 (SETQ LIM2 (ARRAY-ACTIVE-LENGTH STRING2)))
	 (AND (= (SETQ LIM1 (- LIM1 IDX1)) (- LIM2 IDX2))
	      (%STRING-EQUAL STRING1 IDX1 STRING2 IDX2 LIM1)))
	(T (%STRING-EQUAL STRING1 IDX1 STRING2 IDX2 NIL))))

(DEFUN STRING-LESSP (STRING1 STRING2 &OPTIONAL (IDX1 0) (IDX2 0) LIM1 LIM2)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COERCE-STRING-ARG STRING1)
  (COERCE-STRING-ARG STRING2)
  (COND ((OR LIM1 LIM2)
	 (OR LIM1 (SETQ LIM1 (ARRAY-ACTIVE-LENGTH STRING1)))
	 (OR LIM2 (SETQ LIM2 (ARRAY-ACTIVE-LENGTH STRING2)))
	 (LET* ((LEN2 (- LIM2 IDX2))
		(LEN1 (- LIM1 IDX1))
		(RESULT (%STRING-COMPARE STRING1 IDX1 STRING2 IDX2 (MIN LEN1 LEN2))))
	   (IF (ZEROP RESULT)
	       (< LEN1 LEN2)
	       (MINUSP RESULT))))
	(T (MINUSP (%STRING-COMPARE STRING1 IDX1 STRING2 IDX2 NIL)))))

(DEFUN STRING-GREATERP (STRING1 STRING2 &OPTIONAL (IDX1 0) (IDX2 0) LIM1 LIM2)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COERCE-STRING-ARG STRING1)
  (COERCE-STRING-ARG STRING2)
  (COND ((OR LIM1 LIM2)
	 (OR LIM1 (SETQ LIM1 (ARRAY-ACTIVE-LENGTH STRING1)))
	 (OR LIM2 (SETQ LIM2 (ARRAY-ACTIVE-LENGTH STRING2)))
	 (LET* ((LEN2 (- LIM2 IDX2))
		(LEN1 (- LIM1 IDX1))
		(RESULT (%STRING-COMPARE STRING1 IDX1 STRING2 IDX2 (MIN LEN1 LEN2))))
	   (IF (ZEROP RESULT)
	       (> LEN1 LEN2)
	       (PLUSP RESULT))))
	(T (PLUSP (%STRING-COMPARE STRING1 IDX1 STRING2 IDX2 NIL)))))

(DEFSUBST STRING-NOT-GREATERP (STRING1 STRING2 &OPTIONAL (IDX1 0) (IDX2 0) LIM1 LIM2)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (NOT (STRING-GREATERP STRING1 STRING2 IDX1 IDX2 LIM1 LIM2)))

(DEFSUBST STRING-NOT-LESSP (STRING1 STRING2 &OPTIONAL (IDX1 0) (IDX2 0) LIM1 LIM2)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (NOT (STRING-LESSP STRING1 STRING2 IDX1 IDX2 LIM1 LIM2)))

(DEFSUBST STRING-NOT-EQUAL (STRING1 STRING2 &OPTIONAL (IDX1 0) (IDX2 0) LIM1 LIM2)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (NOT (STRING-EQUAL STRING1 STRING2 IDX1 IDX2 LIM1 LIM2)))

(DEFUN STRING-COMPARE (STRING1 STRING2 &OPTIONAL (IDX1 0) (IDX2 0) LIM1 LIM2)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  "Compares the two substrings in dictionary order.
   Returns a positive number if STR1>STR2
   Returns zero if STR1=STR2
   Returns a negative number if STR1<STR2
   If the strings are not equal, the absolute value of the number returned is
   one more than the index (in STR1) at which the difference occured."
  (COERCE-STRING-ARG STRING1)
  (COERCE-STRING-ARG STRING2)
  (COND ((OR LIM1 LIM2)
	 (OR LIM1 (SETQ LIM1 (ARRAY-ACTIVE-LENGTH STRING1)))
	 (OR LIM2 (SETQ LIM2 (ARRAY-ACTIVE-LENGTH STRING2)))
	 (LET* ((LEN2 (- LIM2 IDX2))
		(LEN1 (- LIM1 IDX1))
		(RESULT (%STRING-COMPARE STRING1 IDX1 STRING2 IDX2 (MIN LEN1 LEN2))))
	   (IF (ZEROP RESULT)
	       (COND ((= LEN1 LEN2) 0)
		     ((> LEN1 LEN2) (1+ LEN2))
		     (T (- -1 LEN1)))
	       RESULT)))
	(T (%STRING-COMPARE STRING1 IDX1 STRING2 IDX2 NIL))))

;;; Exact string comparisons

(DEFUN %STRING= (STRING1 INDEX1 STRING2 INDEX2 COUNT)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COND ((IF (NULL COUNT)
	     ( (SETQ COUNT (- (ARRAY-ACTIVE-LENGTH STRING1) INDEX1))
		(- (ARRAY-ACTIVE-LENGTH STRING2) INDEX2))
	     (OR (> (+ INDEX1 COUNT) (ARRAY-ACTIVE-LENGTH STRING1))
		 (> (+ INDEX2 COUNT) (ARRAY-ACTIVE-LENGTH STRING2))))
	 NIL)
	;; Fast version which minimizes memory reads.
	((AND (> COUNT 4)			;Aref loop is faster in this case.
	      (ZEROP INDEX1)
	      (ZEROP INDEX2)
	      (LET ((H1 (%P-POINTER (SETQ STRING1 (FOLLOW-STRUCTURE-FORWARDING STRING1))))
		    (H2 (%P-POINTER (SETQ STRING2 (FOLLOW-STRUCTURE-FORWARDING STRING2)))))
		#+3600 (AND (= (LDB ARRAY-DISPATCH-FIELD H1) %ARRAY-DISPATCH-CHARACTER)
			    (= (LDB ARRAY-DISPATCH-FIELD H2) %ARRAY-DISPATCH-CHARACTER)
			    (= (LDB ARRAY-TYPE-FIELD     H1) ART-STRING)
			    (= (LDB ARRAY-TYPE-FIELD     H2) ART-STRING))
		#+IMach (AND (ZEROP (LDB ARRAY-LONG-PREFIX-BIT H1))
			     (ZEROP (LDB ARRAY-LONG-PREFIX-BIT H2))
			     (= (LDB ARRAY-TYPE-FIELD     H1) ART-STRING)
			     (= (LDB ARRAY-TYPE-FIELD     H2) ART-STRING))))
	 (#+IMach WITH-BLOCK-REGISTERS #+IMach (1 2) #+3600 PROGN
	  #+IMach (SETF (%BLOCK-REGISTER 1) (%POINTER-PLUS STRING1 1))
	  #+IMach (SETF (%BLOCK-REGISTER 2) (%POINTER-PLUS STRING2 1))
	  (LET (#+3600 (POINTER1 (%MAKE-POINTER DTP-LOCATIVE STRING1))
		#+3600 (POINTER2 (%MAKE-POINTER DTP-LOCATIVE STRING2))
		(MASK (LDB (BYTE 2 0) COUNT)))
	    (DO ((N (LDB (BYTE #o35 2) COUNT) (1- N)))
		(( N 0)
		 (OR (ZEROP MASK)
		     (= (LOGAND #+3600  (%P-CONTENTS-INCREMENT-POINTER POINTER1)
				#+IMach (%BLOCK-READ 1 :SET-CDR-NEXT T :PREFETCH NIL
						     :FIXNUM-ONLY T :NO-INCREMENT T)
				(SETQ MASK (LSH -1 (- (DPB (- 4 MASK) (BYTE 2 3) 0)))))
			(LOGAND #+3600  (%P-CONTENTS-INCREMENT-POINTER POINTER2)
				#+IMach (%BLOCK-READ 2 :SET-CDR-NEXT T :PREFETCH NIL
						     :FIXNUM-ONLY T :NO-INCREMENT T)
				MASK))))
	      (IF #+3600  ( (%P-CONTENTS-INCREMENT-POINTER POINTER1)
			     (%P-CONTENTS-INCREMENT-POINTER POINTER2))
		  #+IMach ( (%BLOCK-READ 1 :SET-CDR-NEXT T :PREFETCH NIL :FIXNUM-ONLY T)
			     (%BLOCK-READ 2 :SET-CDR-NEXT T :PREFETCH NIL :FIXNUM-ONLY T))
		  (RETURN NIL))))))
	(T (LET ((STRING1 STRING1) (STRING2 STRING2))
	     (DECLARE (SYS:ARRAY-REGISTER STRING1 STRING2))
	     (DO () ((ZEROP COUNT) T)
	       (UNLESS (CHAR= (AREF STRING1 INDEX1) (AREF STRING2 INDEX2))
		 (RETURN NIL))
	       (INCF INDEX1)
	       (INCF INDEX2)
	       (DECF COUNT))))))

(DEFUN %STRING-EXACT-COMPARE (STRING1 INDEX1 STRING2 INDEX2 COUNT)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (LET ((STRING1 STRING1) (STRING2 STRING2))
    (DECLARE (SYS:ARRAY-REGISTER STRING1 STRING2))
    (LET* ((SUBRANGE1 (- (STRING-LENGTH STRING1) INDEX1))
	   (SUBRANGE2 (- (STRING-LENGTH STRING2) INDEX2))
	   (STATUS 0))
      (COND ((NULL COUNT)
	     (SETQ COUNT (MIN SUBRANGE1 SUBRANGE2)
		   STATUS 1))
	    ((> COUNT SUBRANGE1)
	     (COND ((> COUNT SUBRANGE2)
		    (SETQ COUNT (MIN SUBRANGE1 SUBRANGE2)
			  STATUS 1))
		   (T (SETQ COUNT SUBRANGE1
			    STATUS 2))))
	    ((> COUNT SUBRANGE2)
	     (SETQ COUNT SUBRANGE2
		   STATUS 3)))
      (DO ((I1 INDEX1 (1+ I1))
	   (I2 INDEX2 (1+ I2))
	   CHAR1 CHAR2)
	  ((ZEROP COUNT)
	   (SELECTQ STATUS
	     (0 0)
	     (1 (COND ((= SUBRANGE1 SUBRANGE2) 0)
		      ((< SUBRANGE1 SUBRANGE2) (- -1 I1))
		      (T (1+ I1))))
	     (2 (- INDEX1 I1 1))
	     (T (1+ (- I1 INDEX1)))))
	(SETQ CHAR1 (AREF STRING1 I1)
	      CHAR2 (AREF STRING2 I2))
	(UNLESS (CHAR= CHAR1 CHAR2)
	  (RETURN (IF (CHAR< CHAR1 CHAR2)
		      (- INDEX1 I1 1)
		      (- (1+ I1) INDEX1))))
	(DECF COUNT)))))

(DEFUN STRING-EXACT-COMPARE (STRING1 STRING2 &OPTIONAL (IDX1 0) (IDX2 0) LIM1 LIM2)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  "Compares the two substrings, comparing characters exactly.
   Returns a positive number if STR1>STR2
   Returns zero if STR1=STR2
   Returns a negative number if STR1<STR2
   If the strings are not equal, the absolute value of the number returned is
   one more than the index (in STR1) at which the difference occured."
  (COERCE-STRING-ARG STRING1)
  (COERCE-STRING-ARG STRING2)
  (COND ((OR LIM1 LIM2)
	 (OR LIM1 (SETQ LIM1 (ARRAY-ACTIVE-LENGTH STRING1)))
	 (OR LIM2 (SETQ LIM2 (ARRAY-ACTIVE-LENGTH STRING2)))
	 (LET* ((LEN2 (- LIM2 IDX2))
		(LEN1 (- LIM1 IDX1))
		(RESULT (%STRING-EXACT-COMPARE STRING1 IDX1 STRING2 IDX2 (MIN LEN1 LEN2))))
	   (IF (ZEROP RESULT)
	       (COND ((= LEN1 LEN2) 0)
		     ((> LEN1 LEN2) (1+ LEN2))
		     (T (- -1 LEN1)))
	       RESULT)))
	(T (%STRING-EXACT-COMPARE STRING1 IDX1 STRING2 IDX2 NIL))))

(DEFUN STRING= (STRING1 STRING2 &OPTIONAL (IDX1 0) (IDX2 0) LIM1 LIM2)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COERCE-STRING-ARG STRING1)
  (COERCE-STRING-ARG STRING2)
  (COND ((OR LIM1 LIM2)
	 (OR LIM1 (SETQ LIM1 (ARRAY-ACTIVE-LENGTH STRING1)))
	 (OR LIM2 (SETQ LIM2 (ARRAY-ACTIVE-LENGTH STRING2)))
	 (AND (= (SETQ LIM1 (- LIM1 IDX1)) (- LIM2 IDX2))
	      (%STRING= STRING1 IDX1 STRING2 IDX2 LIM1)))
	(T (%STRING= STRING1 IDX1 STRING2 IDX2 NIL))))

(DEFUN STRING< (STRING1 STRING2 &OPTIONAL (IDX1 0) (IDX2 0) LIM1 LIM2)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COERCE-STRING-ARG STRING1)
  (COERCE-STRING-ARG STRING2)
  (COND ((OR LIM1 LIM2)
	 (OR LIM1 (SETQ LIM1 (ARRAY-ACTIVE-LENGTH STRING1)))
	 (OR LIM2 (SETQ LIM2 (ARRAY-ACTIVE-LENGTH STRING2)))
	 (LET* ((LEN2 (- LIM2 IDX2))
		(LEN1 (- LIM1 IDX1))
		(RESULT (%STRING-EXACT-COMPARE STRING1 IDX1 STRING2 IDX2 (MIN LEN1 LEN2))))
	   (IF (ZEROP RESULT)
	       (< LEN1 LEN2)
	       (MINUSP RESULT))))
	(T (MINUSP (%STRING-EXACT-COMPARE STRING1 IDX1 STRING2 IDX2 NIL)))))

(DEFUN STRING> (STRING1 STRING2 &OPTIONAL (IDX1 0) (IDX2 0) LIM1 LIM2)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COERCE-STRING-ARG STRING1)
  (COERCE-STRING-ARG STRING2)
  (COND ((OR LIM1 LIM2)
	 (OR LIM1 (SETQ LIM1 (ARRAY-ACTIVE-LENGTH STRING1)))
	 (OR LIM2 (SETQ LIM2 (ARRAY-ACTIVE-LENGTH STRING2)))
	 (LET* ((LEN2 (- LIM2 IDX2))
		(LEN1 (- LIM1 IDX1))
		(RESULT (%STRING-EXACT-COMPARE STRING1 IDX1 STRING2 IDX2 (MIN LEN1 LEN2))))
	   (IF (ZEROP RESULT)
	       (> LEN1 LEN2)
	       (PLUSP RESULT))))
	(T (PLUSP (%STRING-EXACT-COMPARE STRING1 IDX1 STRING2 IDX2 NIL)))))

(DEFSUBST STRING (STRING1 STRING2 &OPTIONAL (IDX1 0) (IDX2 0) LIM1 LIM2)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (NOT (STRING> STRING1 STRING2 IDX1 IDX2 LIM1 LIM2)))

(DEFSUBST STRING (STRING1 STRING2 &OPTIONAL (IDX1 0) (IDX2 0) LIM1 LIM2)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (NOT (STRING< STRING1 STRING2 IDX1 IDX2 LIM1 LIM2)))

(DEFSUBST STRING (STRING1 STRING2 &OPTIONAL (IDX1 0) (IDX2 0) LIM1 LIM2)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (NOT (STRING= STRING1 STRING2 IDX1 IDX2 LIM1 LIM2)))

;;; Case-independent string searches

(DEFUN %STRING-SEARCH-CHAR (CHAR STRING START END)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (LET ((STR STRING))
    (DECLARE (SYS:ARRAY-REGISTER STR))
    (DO ((I START (1+ I)))
	(( I END) NIL)
      (WHEN (CHAR-EQUAL (AREF STR I) CHAR)
	(RETURN I)))))

;STRING-SEARCH-CHAR returns the index in STRING of the first occurrence of CHAR past FROM.
(DEFUN STRING-SEARCH-CHAR (CHAR STRING &OPTIONAL (FROM 0) TO)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (CHECK-CHAR-ARG CHAR)
  (COERCE-STRING-ARG STRING)
  (OR TO (SETQ TO (ARRAY-ACTIVE-LENGTH STRING)))
  (%STRING-SEARCH-CHAR CHAR STRING FROM TO))

(DEFUN STRING-REVERSE-SEARCH-CHAR (CHAR STRING &OPTIONAL FROM (TO 0))
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (CHECK-CHAR-ARG CHAR)
  (COERCE-STRING-ARG STRING)
  (OR FROM (SETQ FROM (ARRAY-ACTIVE-LENGTH STRING)))
  (DO ((I (1- FROM) (1- I)))
      ((< I TO) NIL)
    (WHEN (CHAR-EQUAL CHAR (AREF STRING I))
      (RETURN I))))

;STRING-SEARCH-NOT-CHAR returns the index in STRING of the first occurrence of
;  a character other than CHAR past FROM.
(DEFUN STRING-SEARCH-NOT-CHAR (CHAR STRING &OPTIONAL (FROM 0) TO)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (CHECK-CHAR-ARG CHAR)
  (COERCE-STRING-ARG STRING)
  (OR TO (SETQ TO (ARRAY-ACTIVE-LENGTH STRING)))
  (DO ((I FROM (1+ I)))
      ((>= I TO) NIL)
    (UNLESS (CHAR-EQUAL CHAR (AREF STRING I))
      (RETURN I))))

(DEFUN STRING-REVERSE-SEARCH-NOT-CHAR (CHAR STRING &OPTIONAL FROM (TO 0))
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (CHECK-CHAR-ARG CHAR)
  (COERCE-STRING-ARG STRING)
  (OR FROM (SETQ FROM (ARRAY-ACTIVE-LENGTH STRING)))
  (DO ((I (1- FROM) (1- I)))
      ((< I TO) NIL)
    (UNLESS (CHAR-EQUAL CHAR (AREF STRING I))
      (RETURN I))))

;(STRING-SEARCH <key> <string> <from> <to>) returns the index in <string> of the
;first occurrence of <key> past index <from>, or NIL if there is none.
(DEFUN STRING-SEARCH (KEY STRING &OPTIONAL (FROM 0) TO (KEY-START 0) KEY-END &AUX KEY-LEN)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COERCE-STRING-ARG STRING)
  (COERCE-STRING-ARG KEY)
  (OR KEY-END (SETQ KEY-END (ARRAY-ACTIVE-LENGTH KEY)))
  (SETQ KEY-LEN (- KEY-END KEY-START))
  (OR TO (SETQ TO (ARRAY-ACTIVE-LENGTH STRING)))
  (COND ((ZEROP KEY-LEN)
	 (AND ( FROM TO) FROM))
	(T
	 (SETQ TO (1+ (- TO KEY-LEN)))  ;Last position at which key may start +1
	 (PROG (CH1)
	   (COND ((MINUSP TO) (RETURN NIL)))
	   (SETQ CH1 (AREF KEY KEY-START))
	  LOOP	;Find next place key might start
	   (OR (SETQ FROM (%STRING-SEARCH-CHAR CH1 STRING FROM TO))
	       (RETURN NIL))
	   (AND (%STRING-EQUAL KEY KEY-START STRING FROM KEY-LEN)
		(RETURN FROM))
	   (SETQ FROM (1+ FROM))  ;Avoid infinite loop.  %STRING-SEARCH-CHAR does right
	   (GO LOOP)))))	  ; thing if from  to.

;(STRING-REVERSE-SEARCH <key> <string> <from> <to>) returns the index in <string> of the
;last occurrence of <key> ending before index <from>, or NIL if there is none.
(DEFUN STRING-REVERSE-SEARCH (KEY STRING &OPTIONAL FROM (TO 0) (KEY-START 0) KEY-END
			      &AUX KEY-LEN)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COERCE-STRING-ARG STRING)
  (COERCE-STRING-ARG KEY)
  (OR KEY-END (SETQ KEY-END (ARRAY-ACTIVE-LENGTH KEY)))
  (SETQ KEY-LEN (- KEY-END KEY-START))
  (OR FROM (SETQ FROM (ARRAY-ACTIVE-LENGTH STRING)))
  (SETQ TO (+ TO (1- KEY-LEN)))		;First position at which last char of key may be
  (COND ((ZEROP KEY-LEN) FROM)
	(T
	 (DO ((N (1- FROM) (1- N))
	      (CH1 (AREF KEY (1- KEY-END))))
	     ((< N TO) NIL)
	   (AND (CHAR-EQUAL (AREF STRING N) CH1)
		(%STRING-EQUAL KEY KEY-START STRING (1+ (- N KEY-LEN)) KEY-LEN)
		(RETURN (1+ (- N KEY-LEN)))))
	 )))

;;; Case-dependent string searches

(DEFUN %STRING-SEARCH-EXACT-CHAR (CHAR STRING START END)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (MULTIPLE-VALUE-BIND (S-ARRAY S-CONTROL S-ADDRESS S-BOUND #+3600 S-OFFSET)
      (#+IMACH SETUP-1D-ARRAY #+3600 SETUP-1D-ARRAY-SEQUENTIAL STRING)
    #+3600 (DECLARE (IGNORE S-ARRAY S-BOUND S-CONTROL))
    (WHEN (OR (< (- END START) 8)		;overhead threshold
	      ( (CHAR-LDB-INTERNAL %%CHAR-ALL-BUT-SUBINDEX CHAR) 0)
	      #+3600 ( (ARRAY-TYPE-FIELD STRING) ART-STRING)
	      #+IMACH ( (LDB (BYTE (+ (BYTE-SIZE ARRAY-REGISTER-BYTE-PACKING)
				       (BYTE-SIZE ARRAY-REGISTER-ELEMENT-TYPE))
				    (BYTE-POSITION ARRAY-REGISTER-BYTE-PACKING))
			      S-CONTROL)
			 (DPB ARRAY-ELEMENT-TYPE-CHARACTER
			      (BYTE (BYTE-SIZE ARRAY-REGISTER-ELEMENT-TYPE)
				    (BYTE-SIZE ARRAY-REGISTER-BYTE-PACKING))
			      2)))
      (RETURN-FROM %STRING-SEARCH-EXACT-CHAR
	(LET ((I START)
	      ;; On the 3600 you have to redecode the array register to deal with offsets
	      #+3600 (STRING STRING))
	  #+3600 (DECLARE (SYS:ARRAY-REGISTER STRING))
	  (DOTIMES (IGNORE (- END START))
	    (COMPILER:%ERROR-WHEN
	      (EQ #+3600 (AREF STRING I)
		  #+Imach (FAST-AREF-1 I (COMPILER:REFERENCING-VARIABLES-PROGN
					   ;; make sure the compiler doesn't remove these
					   S-ARRAY S-ADDRESS S-BOUND S-CONTROL))
		  CHAR)
	      (RETURN I))
	    (INCF I)))))
    (#+IMach WITH-BLOCK-REGISTERS #+IMach (1) #+3600 PROGN
     (LET* ((CHARACTER-MASK
	      (LET* ((MASK8 (CHAR-SUBINDEX CHAR))	;replicate mask in all four bytes
		     (MASK16 (%LOGDPB MASK8 (BYTE 8 8) MASK8)))
		(%LOGDPB MASK16 (BYTE 16. 16.) MASK16)))
	    (BYTE-0-MASK #o377)
	    (BYTE-1-MASK (ROT #o377 8))
	    (BYTE-2-MASK (ROT #o377 16.))
	    (BYTE-3-MASK (ROT #o377 24.))
	    (BASE-ADDRESS			;first word to look at
	      #+3600
	      (%MAKE-POINTER-OFFSET DTP-LOCATIVE S-ADDRESS
	        (%FIXNUM-FLOOR (+ S-OFFSET START) 4))
	      #+IMACH
	      (%POINTER-PLUS S-ADDRESS
	        (%FIXNUM-FLOOR (+ (LDB ARRAY-REGISTER-BYTE-OFFSET S-CONTROL) START) 4)))
	    ;; The number of bytes to ignore in the first word
	    (BASE-OFFSET
	      #+3600 (%FIXNUM-MOD (+ S-OFFSET START) 4)
	      #+IMACH (%FIXNUM-MOD (+ (LDB ARRAY-REGISTER-BYTE-OFFSET S-CONTROL) START) 4))
	    ;; The number of words to look at
	    (WORDS (%FIXNUM-CEILING (+ (- END START) BASE-OFFSET) 4))
	    #+3600 (POINTER (%MAKE-POINTER-OFFSET DTP-LOCATIVE BASE-ADDRESS -1)))
       (MACROLET ((UNLESS* (CONDITION ALTERNATIVE)
		    `(COMPILER:%ERROR-UNLESS ,CONDITION ,ALTERNATIVE))
		  (READ-WORD ()
		    #+IMACH `(%BLOCK-READ 1 :FIXNUM-ONLY T)
		    #+3600 `(%P-CONTENTS-INCREMENT-POINTER POINTER)))
	 ;; Search for a word address and byte offset 
	 (LET* ((BYTE
		  (BLOCK SEARCH
		    #+Imach (SETF (%BLOCK-REGISTER 1) BASE-ADDRESS)
		    ;; If we're only looking at part of the first word, treat it specially
		    (WHEN ( BASE-OFFSET 0)
		      (LET ((WORD (LOGXOR (READ-WORD) CHARACTER-MASK)))
			(WHEN ( BASE-OFFSET 1)
			  (UNLESS* (CL:LOGTEST WORD BYTE-1-MASK) (RETURN-FROM SEARCH 1)))
			(WHEN ( BASE-OFFSET 2)
			  (UNLESS* (CL:LOGTEST WORD BYTE-2-MASK) (RETURN-FROM SEARCH 2)))
			(WHEN ( BASE-OFFSET 3)
			  (UNLESS* (CL:LOGTEST WORD BYTE-3-MASK) (RETURN-FROM SEARCH 3))))
		      (DECF WORDS))
		    (DOTIMES (IGNORE WORDS)
		      (LET ((WORD (LOGXOR (READ-WORD) CHARACTER-MASK)))
			(UNLESS* (CL:LOGTEST WORD BYTE-0-MASK) (RETURN-FROM SEARCH 0))
			(UNLESS* (CL:LOGTEST WORD BYTE-1-MASK) (RETURN-FROM SEARCH 1))
			(UNLESS* (CL:LOGTEST WORD BYTE-2-MASK) (RETURN-FROM SEARCH 2))
			(UNLESS* (CL:LOGTEST WORD BYTE-3-MASK) (RETURN-FROM SEARCH 3))))))
		(INDEX
		  (IF (NULL BYTE)
		      (RETURN-FROM %STRING-SEARCH-EXACT-CHAR NIL)
		    (+ (%FIXNUM-MULTIPLY
			 #+3600 (%POINTER-DIFFERENCE POINTER BASE-ADDRESS)
			 #+IMACH (1- (%POINTER-DIFFERENCE (%BLOCK-REGISTER 1) BASE-ADDRESS))
			 4)
		       (- BASE-OFFSET)
		       START
		       BYTE))))
	   ;; The index might be past the end, since we looked at the whole last word
	   (AND (< INDEX END) INDEX)))))))

#||

(defun test-string-search-exact-char ()
  (labels ((reference (char string start end)
	     (loop for i from start below end do
	       (when (eq (aref string i) char)
		 (return i)))))
    (loop for end below 5 do
      (loop for start below 5 do
	(loop for string in '(""
			      "abcd"
			      "abcd*fghijkl"
			      "abcde*ghijkl"
			      "abcdef*hijkl"
			      "abcdefg*ijkl"
			      "abcdefgh*jkl"
			      "abcdefghi*kl"
			      "abcdefghij*l"
			      "abcdefghijk*"
			      "abcdefghij*"
			      "abcdefghi*")
	      unless (eql (%string-search-exact-char #/* string start
						     (- (string-length string) end))
			  (reference #/* string start (- (string-length string) end)))
		do (print string))))))

(defun benchmark (f l)
  (let ((str (cl:make-string l)))
    (process:without-preemption
      (let ((start (%microsecond-clock)))
	(dotimes (ignore 100)
	  (funcall f #/* str 0 l)
	  (funcall f #/* str 0 l)
	  (funcall f #/* str 0 l)
	  (funcall f #/* str 0 l)
	  (funcall f #/* str 0 l)
	  (funcall f #/* str 0 l)
	  (funcall f #/* str 0 l)
	  (funcall f #/* str 0 l))
	(- (%microsecond-clock) start)))))

||#

(DEFUN STRING-SEARCH-EXACT-CHAR (CHAR STRING &OPTIONAL (FROM 0) TO)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (CHECK-CHAR-ARG CHAR)
  (COERCE-STRING-ARG STRING)
  (UNLESS TO (SETQ TO (ARRAY-ACTIVE-LENGTH STRING)))
  (%STRING-SEARCH-EXACT-CHAR CHAR STRING FROM TO))

(DEFUN STRING-REVERSE-SEARCH-EXACT-CHAR (CHAR STRING &OPTIONAL FROM (TO 0))
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (CHECK-CHAR-ARG CHAR)
  (COERCE-STRING-ARG STRING)
  (UNLESS FROM (SETQ FROM (ARRAY-ACTIVE-LENGTH STRING)))
  (DO ((I (1- FROM) (1- I)))
      ((< I TO) NIL)
    (WHEN (CHAR= CHAR (AREF STRING I))
      (RETURN I))))

(DEFUN STRING-SEARCH-NOT-EXACT-CHAR (CHAR STRING &OPTIONAL (FROM 0) TO)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (CHECK-CHAR-ARG CHAR)
  (COERCE-STRING-ARG STRING)
  (UNLESS TO (SETQ TO (ARRAY-ACTIVE-LENGTH STRING)))
  (DO ((I FROM (1+ I)))
      ((>= I TO) NIL)
    (UNLESS (CHAR= CHAR (AREF STRING I))
      (RETURN I))))

(DEFUN STRING-REVERSE-SEARCH-NOT-EXACT-CHAR (CHAR STRING &OPTIONAL FROM (TO 0))
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (CHECK-CHAR-ARG CHAR)
  (COERCE-STRING-ARG STRING)
  (UNLESS FROM (SETQ FROM (ARRAY-ACTIVE-LENGTH STRING)))
  (DO ((I (1- FROM) (1- I)))
      ((< I TO) NIL)
    (UNLESS (CHAR= CHAR (AREF STRING I))
      (RETURN I))))

(DEFUN STRING-SEARCH-EXACT (KEY STRING &OPTIONAL (FROM 0) TO (KEY-START 0) KEY-END
			    &AUX KEY-LEN)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COERCE-STRING-ARG STRING)
  (COERCE-STRING-ARG KEY)
  (OR KEY-END (SETQ KEY-END (ARRAY-ACTIVE-LENGTH KEY)))
  (SETQ KEY-LEN (- KEY-END KEY-START))
  (OR TO (SETQ TO (ARRAY-ACTIVE-LENGTH STRING)))
  (COND ((ZEROP KEY-LEN)
	 (AND ( FROM TO) FROM))
	(T
	 (SETQ TO (1+ (- TO KEY-LEN)))  ;Last position at which key may start +1
	 (PROG (CH1)
	   (COND ((MINUSP TO) (RETURN NIL)))
	   (SETQ CH1 (AREF KEY KEY-START))
	  LOOP	;Find next place key might start
	   (OR (SETQ FROM (%STRING-SEARCH-EXACT-CHAR CH1 STRING FROM TO))
	       (RETURN NIL))
	   (AND (%STRING= KEY KEY-START STRING FROM KEY-LEN)
		(RETURN FROM))
	   (SETQ FROM (1+ FROM))  ;Avoid infinite loop.  %STRING-SEARCH-EXACT-CHAR does right
	   (GO LOOP)))))	  ; thing if from  to.

(DEFUN STRING-REVERSE-SEARCH-EXACT (KEY STRING &OPTIONAL FROM (TO 0) (KEY-START 0) KEY-END
				    &AUX KEY-LEN)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COERCE-STRING-ARG STRING)
  (COERCE-STRING-ARG KEY)
  (OR KEY-END (SETQ KEY-END (ARRAY-ACTIVE-LENGTH KEY)))
  (SETQ KEY-LEN (- KEY-END KEY-START))
  (OR FROM (SETQ FROM (ARRAY-ACTIVE-LENGTH STRING)))
  (SETQ TO (+ TO (1- KEY-LEN)))		;First position at which last char of key may be
  (COND ((ZEROP KEY-LEN) FROM)
	(T
	 (DO ((N (1- FROM) (1- N))
	      (CH1 (AREF KEY (1- KEY-END))))
	     ((< N TO) NIL)
	   (AND (CHAR= (AREF STRING N) CH1)
		(%STRING= KEY KEY-START STRING (1+ (- N KEY-LEN)) KEY-LEN)
		(RETURN (1+ (- N KEY-LEN)))))
	 )))

;; Converts the argument to upper-case, either by returning a copy or by modifying the
;; argument.  Any bits in the characters, above the %%CH-CHAR part are ignored and not
;; changed, for those in the standard character set.
(DEFUN STRING-UPCASE (STRING &OPTIONAL (FROM 0) TO (COPY-P T)) 
  (COERCE-STRING-ARG STRING (NOT COPY-P))
  (IF COPY-P (SETQ STRING (SUBSTRING STRING 0)))
  (DO ((LEN (OR TO (ARRAY-ACTIVE-LENGTH STRING)))
       (I FROM (1+ I)))
      ((= I LEN))
    (LET* ((CHAR (AREF STRING I))
	   (NEWCHAR (CHAR-UPCASE CHAR)))
      (UNLESS (CHAR= CHAR NEWCHAR)
	(SETF (AREF STRING I) NEWCHAR))))
  STRING)

;; Converts the argument to lower-case, either by returning a coy or by modifying the
;; argument.  Any bits in the characters, above the %%CH-CHAR part are ignored and not
;; changed, for those in the standard character set.
(DEFUN STRING-DOWNCASE (STRING &OPTIONAL (FROM 0) TO (COPY-P T))
  (COERCE-STRING-ARG STRING (NOT COPY-P))
  (IF COPY-P (SETQ STRING (SUBSTRING STRING 0)))
  (DO ((LEN (OR TO (ARRAY-ACTIVE-LENGTH STRING)))
       (I FROM (1+ I)))
      ((= I LEN))
    (LET* ((CHAR (AREF STRING I))
	   (NEWCHAR (CHAR-DOWNCASE CHAR)))
      (UNLESS (CHAR= CHAR NEWCHAR)
	(SETF (AREF STRING I) NEWCHAR))))
  STRING)

;; Like STRING-UPCASE and STRING-DOWNCASE, but swap upper and lower cases
(DEFUN STRING-FLIPCASE (STRING &OPTIONAL (FROM 0) TO (COPY-P T))
  (COERCE-STRING-ARG STRING (NOT COPY-P))
  (IF COPY-P (SETQ STRING (SUBSTRING STRING 0)))
  (DO ((LEN (OR TO (ARRAY-ACTIVE-LENGTH STRING)))
       (I FROM (1+ I)))
      ((= I LEN))
    (LET* ((CHAR (AREF STRING I))
	   (NEWCHAR (CHAR-FLIPCASE CHAR)))
      (UNLESS (CHAR= CHAR NEWCHAR)
	(SETF (AREF STRING I) NEWCHAR))))
  STRING)

;Same as STRING-UPCASE but copies only if necessary.
(DEFUN STRING-UPCASE-IF-NECESSARY (STRING &OPTIONAL (FROM 0) TO)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COERCE-STRING-ARG STRING)
  (IF (LOOP FOR I FROM FROM BELOW (OR TO (ARRAY-ACTIVE-LENGTH STRING))
	    THEREIS (LOWER-CASE-P (AREF STRING I)))
      (STRING-UPCASE STRING FROM TO)
      STRING))

;Same as STRING-DOWNCASE but copies only if necessary.
(DEFUN STRING-DOWNCASE-IF-NECESSARY (STRING &OPTIONAL (FROM 0) TO)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COERCE-STRING-ARG STRING)
  (IF (LOOP FOR I FROM FROM BELOW (OR TO (ARRAY-ACTIVE-LENGTH STRING))
	    THEREIS (UPPER-CASE-P (AREF STRING I)))
      (STRING-DOWNCASE STRING FROM TO)
      STRING))

;Same as STRING-FLIPCASE but copies only if necessary
(DEFUN STRING-FLIPCASE-IF-NECESSARY (STRING &OPTIONAL (FROM 0) TO)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COERCE-STRING-ARG STRING)
  (IF (LOOP FOR I FROM FROM BELOW (OR TO (ARRAY-ACTIVE-LENGTH STRING))
	    AS CH = (AREF STRING I)
	    THEREIS (BOTH-CASE-P CH))
      (STRING-FLIPCASE STRING FROM TO)
      STRING))

; NSUBSTRING creates a substring of a given string.  The first
; arg is the string, the second is the FROM char-pos, and the third is the
; TO char-pos.  TO omitted or NIL means "all the way to the end",
; The substring is an index-offset array, so clobbering
; the original string will also clobber the substring.  Taking
; a substring of a substring will not produce a long chain; it
; will look at the given substring and create a new pointer to the
;  original array.

(DEFUN NSUBSTRING (STRING FROM &OPTIONAL TO (AREA NIL)
		   &AUX LENGTH ARRAYTYPE)
  (COERCE-STRING-ARG STRING)
  (OR TO (SETQ TO (ARRAY-ACTIVE-LENGTH STRING)))
  (SETQ LENGTH (- TO FROM))
  (UNLESS (AND (>= LENGTH 0) (>= FROM 0) (<= TO (ARRAY-ACTIVE-LENGTH STRING)))
    (FERROR "Args ~S and ~S out of range for ~S" FROM TO STRING))
  (SETQ ARRAYTYPE (ARRAY-TYPE STRING))
  (COND ((NOT (ARRAY-INDEXED-P STRING))
	 (MAKE-ARRAY LENGTH
		     ':AREA AREA ':TYPE ARRAYTYPE
		     ':DISPLACED-TO STRING	;DISPLACED
		     ':DISPLACED-INDEX-OFFSET FROM))	;INDEX OFFSET
	;; Otherwise, probably a substring of a substring
	(T
	 (MAKE-ARRAY LENGTH
		     ':AREA AREA ':TYPE ARRAYTYPE
		     ':DISPLACED-TO (ARRAY-INDIRECT-TO STRING)
		     ':DISPLACED-INDEX-OFFSET (+ FROM (ARRAY-INDEX-OFFSET STRING))))))

;SUBSTRING copies out an arbitrary substring of a given string.
(DEFUN SUBSTRING (STRING FROM &OPTIONAL TO (AREA NIL)
		  &AUX ARRAY-ACTIVE-LENGTH)	;for caching
  (DECLARE LT:(SIDE-EFFECTS READER))
  (COERCE-STRING-ARG STRING)
  (OR TO (SETQ TO (SETQ ARRAY-ACTIVE-LENGTH (ARRAY-ACTIVE-LENGTH STRING))))
  (UNLESS (AND (>= TO FROM) (>= FROM 0)
	       (<= TO (OR ARRAY-ACTIVE-LENGTH (ARRAY-ACTIVE-LENGTH STRING))))
    (FERROR "One or both of FROM (~S) and TO (~S) are out of range for ~S"
	    FROM TO STRING))
  (LET* ((RES-LENGTH (- TO FROM))
	 (RES (MAKE-ARRAY RES-LENGTH
			  ':TYPE (ARRAY-TYPE-FIELD STRING)
			  ':AREA AREA)))
    (COPY-ARRAY-PORTION STRING FROM TO
			RES 0 RES-LENGTH)
    RES))

(DEFUN SUBSTRING-AFTER-CHAR (CHAR STRING &OPTIONAL (AREA NIL))
  (DECLARE LT:(SIDE-EFFECTS READER))
  (LET ((IDX (STRING-SEARCH-CHAR CHAR STRING)))
    (COND ((NULL IDX) "")
	  (T (SUBSTRING STRING (1+ IDX) NIL AREA)))))

;Reverse the characters in a string, in place.
(DEFUN STRING-NREVERSE (STRING)
  (COERCE-STRING-ARG STRING T)
  (LET ((LEN (ARRAY-ACTIVE-LENGTH STRING))
	(STRING STRING))
    (DECLARE (ARRAY-REGISTER STRING))
    (DO ((I 0 (1+ I))
	 (J (1- LEN) (1- J)))
	(( J I))
      ;; SWAPF introduces its own temp for string, which has no array-register declaration.
      (LET ((TEM (AREF STRING I)))
	(SETF (AREF STRING I) (AREF STRING J))
	(SETF (AREF STRING J) TEM))))
  STRING)

;Make a reversed copy of a string
(DEFUN STRING-REVERSE (STRING)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (STRING-NREVERSE (SUBSTRING STRING 0)))



;Internal function.
(DEFUN ARRAY-MEM (FUNCTION ITEM ARRAY)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (DOTIMES (I (ARRAY-ACTIVE-LENGTH ARRAY))
    (WHEN (FUNCALL FUNCTION ITEM (AREF ARRAY I))
      (RETURN T))))

;STRING-SEARCH-SET returns the index in STRING of the first char which belongs to CHAR-SET,
;or NIL if there is none.
(DEFUN STRING-SEARCH-SET (CHAR-SET STRING &OPTIONAL (FROM 0) TO &AUX FUNCTION)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (ARGUMENT-TYPECASE CHAR-SET
    (:LIST-OR-NIL (SETQ FUNCTION #'MEM))	;The NIL case could be faster, I guess
    (:STRING (SETQ FUNCTION #'ARRAY-MEM)))
  (COERCE-STRING-ARG STRING)
  (OR TO (SETQ TO (ARRAY-ACTIVE-LENGTH STRING)))
  (DO ((I FROM (1+ I)))
      ((>= I TO) NIL)
    (WHEN (FUNCALL FUNCTION #'CHAR-EQUAL (AREF STRING I) CHAR-SET)
      (RETURN I))))

;STRING-REVERSE-SEARCH-SET returns the index in STRING 
;of the last char which belongs to CHAR-SET, or NIL if there is none.
(DEFUN STRING-REVERSE-SEARCH-SET (CHAR-SET STRING &OPTIONAL FROM (TO 0) &AUX FUNCTION)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (ARGUMENT-TYPECASE CHAR-SET
    (:LIST-OR-NIL (SETQ FUNCTION #'MEM))	;The NIL case could be faster, I guess
    (:STRING (SETQ FUNCTION #'ARRAY-MEM)))
  (COERCE-STRING-ARG STRING)
  (OR FROM (SETQ FROM (ARRAY-ACTIVE-LENGTH STRING)))
  (DO ((I (1- FROM) (1- I)))
      ((< I TO) NIL)
    (WHEN (FUNCALL FUNCTION #'CHAR-EQUAL (AREF STRING I) CHAR-SET)
      (RETURN I))))

;STRING-SEARCH-NOT-SET returns the index in STRING of the first char not in CHAR-SET,
;or NIL if there is none.
(DEFUN STRING-SEARCH-NOT-SET (CHAR-SET STRING &OPTIONAL (FROM 0) TO &AUX FUNCTION)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (ARGUMENT-TYPECASE CHAR-SET
    (:LIST-OR-NIL (SETQ FUNCTION #'MEM))	;The NIL case could be faster, I guess
    (:STRING (SETQ FUNCTION #'ARRAY-MEM)))
  (COERCE-STRING-ARG STRING)
  (OR TO (SETQ TO (ARRAY-ACTIVE-LENGTH STRING)))
  (DO ((I FROM (1+ I)))
      ((>= I TO) NIL)
    (UNLESS (FUNCALL FUNCTION #'CHAR-EQUAL (AREF STRING I) CHAR-SET)
      (RETURN I))))

;STRING-REVERSE-SEARCH-NOT-SET returns the index in STRING 
;of the last char not in CHAR-SET, or NIL if there is none.
(DEFUN STRING-REVERSE-SEARCH-NOT-SET (CHAR-SET STRING &OPTIONAL FROM (TO 0) &AUX FUNCTION)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (ARGUMENT-TYPECASE CHAR-SET
    (:LIST-OR-NIL (SETQ FUNCTION #'MEM))	;The NIL case could be faster, I guess
    (:STRING (SETQ FUNCTION #'ARRAY-MEM)))
  (COERCE-STRING-ARG STRING)
  (OR FROM (SETQ FROM (ARRAY-ACTIVE-LENGTH STRING)))
  (DO ((I (1- FROM) (1- I)))
      ((< I TO) NIL)
    (UNLESS (FUNCALL FUNCTION #'CHAR-EQUAL (AREF STRING I) CHAR-SET)
      (RETURN I))))

;Strip off the beginning and end of STRING all characters in CHAR-SET.
(DEFUN STRING-TRIM (CHAR-SET STRING &AUX I J)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (SETQ I (STRING-SEARCH-NOT-SET CHAR-SET STRING))
  (COND ((NULL I) "")
	(T (SETQ J (STRING-REVERSE-SEARCH-NOT-SET CHAR-SET STRING))
	   (SUBSTRING STRING I (1+ J)))))

(DEFCONSTANT *WHITESPACE* '(#\SPACE #\TAB #\RETURN))

;Strip off the beginning and end of STRING all whitespace characters
(DEFUN STRING-TRIM-WHITESPACE (STRING)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (STRING-TRIM *WHITESPACE* STRING))
;Strip off the beginning of STRING all characters in CHAR-SET.
(DEFUN STRING-LEFT-TRIM (CHAR-SET STRING &AUX I)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (SETQ I (STRING-SEARCH-NOT-SET CHAR-SET STRING))
  (COND (I (SUBSTRING STRING I (STRING-LENGTH STRING)))
	(T "")))

;Strip off the end of STRING all characters in CHAR-SET.
(DEFUN STRING-RIGHT-TRIM (CHAR-SET STRING &AUX I)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (SETQ I (STRING-REVERSE-SEARCH-NOT-SET CHAR-SET STRING))
  (COND (I (SUBSTRING STRING 0 (1+ I)))
	(T "")))



;; Compare how X and Y print.  Does X print as something "less" than what Y prints as?
;; Exception: numbers occurring anywhere in X and Y are compared numerically.
(DEFUN ALPHALESSP (X Y)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COND ((NUMBERP X) (OR (NOT (NUMBERP Y)) (< X Y)))
	((NUMBERP Y) NIL)
	((OR (SYMBOLP X) (STRINGP X))
	 (OR (NOT (OR (SYMBOLP Y) (STRINGP Y)))
	     (STRING-LESSP X Y)))
	((OR (SYMBOLP Y) (STRINGP Y)) NIL)
	((NLISTP X) (OR (LISTP Y)
			(STRING-LESSP (FORMAT NIL "~S" X) (FORMAT NIL "~S" Y))))
	((NLISTP Y) NIL)
	(T (DO ((X1 X (CDR X1)) (Y1 Y (CDR Y1)))
	       (NIL)
	     (COND ((NULL Y1)				(RETURN NIL))
		   ((NULL X1)				(RETURN T))
		   ((OR (NLISTP Y1) (NLISTP X1))	(RETURN (ALPHALESSP X1 Y1)))
		   ((ALPHALESSP (CAR X1) (CAR Y1))	(RETURN T))
		   ((ALPHALESSP (CAR Y1) (CAR X1))	(RETURN NIL)))))))

;; Compare how X and Y print.  Do they print the same way?
;; Exception: numbers occurring anywhere in X and Y are compared numerically.
(DEFUN ALPHAEQUAL (X Y)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COND ((NUMBERP X) (AND (NUMBERP Y) (= X Y)))
	((OR (SYMBOLP X) (STRINGP X))
	 (AND (OR (SYMBOLP Y) (STRINGP Y))
	      (STRING-EQUAL X Y)))
	((NLISTP X) (AND (NLISTP Y)
			 (STRING-EQUAL (FORMAT NIL "~S" X) (FORMAT NIL "~S" Y))))
	((NLISTP Y) ())
	(T (DO ((X1 X (CDR X1)) (Y1 Y (CDR Y1)))
	       (NIL)
	     (COND ((NULL X1)				 (RETURN (NULL Y1)))
		   ((NULL Y1)				 (RETURN NIL))
		   ((OR (NLISTP X1) (NLISTP Y1))	 (RETURN (ALPHAEQUAL X1 Y1)))
		   ((NOT (ALPHAEQUAL (CAR X1) (CAR Y1))) (RETURN NIL)))))))



;;; Stuff to deal with ASCII.

(defvar *char-to-ascii* (cl:make-array 256. :element-type '(cl:unsigned-byte 8)))
(defvar *ascii-to-char* (cl:make-array 256. :element-type 'cl:string-char))

(defun fill-ascii-translation-tables ()
  (loop for i below 256.
	do (cl:setf (aref *char-to-ascii* i) i
		    (aref *ascii-to-char* i) (code-char i)))
  (labels ((twiddle (char index)
	     (let ((index1 (char-code char))
		   (index2 index))
	       (cl:rotatef (aref *char-to-ascii* index1) (aref *char-to-ascii* index2))
	       (cl:rotatef (aref *ascii-to-char* index1) (aref *ascii-to-char* index2)))))
    (twiddle #\BS #o010)
    (twiddle #\TAB #o011)
    (twiddle #\LINE #o012)
    (twiddle #\FF #o014)
    (twiddle #\Return #o015)
    (twiddle #\Rubout #o177)))

(fill-ascii-translation-tables)

(defsubst char-to-ascii (char)
  (declare lt:(side-effects simple reducible))
  (unless (zerop (si:char-char-set-index char))
    (char-to-ascii-error char))
  (aref *char-to-ascii* (si:char-subindex char)))

(defsubst ascii-to-char (ascii-code)
  (declare lt:(side-effects simple reducible))
  (unless (< -1 ascii-code 256.)
    (ascii-to-char-error ascii-code))
  (aref *ascii-to-char* ascii-code))

(defun char-to-ascii-error (char)
  (error "~S is not a standard character; it cannot be translated to ASCII." char))

(defun ascii-to-char-error (ascii-code)
  (error "~S is not an ASCII code." ascii-code))

(DEFUN ASCII-CODE (SPEC)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (IF (OR (STRINGP SPEC) (SYMBOLP SPEC))
      (OR (CDR (ASS #'STRING-EQUAL (STRING SPEC)
		    '(("NUL" . #O000) ("SOH" . #O001) ("STX" . #O002) ("ETX" . #O003)
		      ("EOT" . #O004) ("ENQ" . #O005) ("ACK" . #O006) ("BEL" . #O007)
		      ("BS" . #O010) ("TAB" . #O011) ("HT" . #O011) ("LF" . #O012)
		      ("NL" . #O012) ("VT" . #O013) ("FF" . #O014) ("CR" . #O015)
		      ("SO" . #O016) ("SI" . #O017) ("DLE" . #O020) ("DC1" . #O021)
		      ("DC2" . #O022) ("DC3" . #O023) ("DC4" . #O024) ("NAK" . #O025)
		      ("SYN" . #O026) ("ETB" . #O027) ("CAN" . #O030) ("EM" . #O031)
		      ("SUB" . #O032) ("ESC" . #O033) ("ALT" . #O033)
		      ("FS" . #O034) ("GS" . #O035) ("RS" . #O036) ("US" . #O037)
		      ("SP" . #O040) ("DEL" . #O177))))
	  (FERROR "~S unrecognized name of an ASCII code" SPEC))
      (CHAR-TO-ASCII SPEC)))

(DEFUN STRING-TO-ASCII (LISPM-STRING)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  "Convert a Lisp string to an ART-8B array of bytes containing ASCII character codes."
  (LET* ((LENGTH (STRING-LENGTH LISPM-STRING))
	 (ASCII-ARRAY (MAKE-ARRAY LENGTH :TYPE 'ART-8B))
	 (LISPM-STRING LISPM-STRING))
    (DECLARE (ARRAY-REGISTER ASCII-ARRAY LISPM-STRING))
    (LOOP FOR INDEX FROM 0 BELOW LENGTH
	  DO (SETF (AREF ASCII-ARRAY INDEX) (CHAR-TO-ASCII (AREF LISPM-STRING INDEX))))
    ASCII-ARRAY))

(DEFUN ASCII-TO-STRING (ASCII-ARRAY)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  "Convert an ART-8B array of bytes representing ASCII characters into a Lisp string."
  (LET* ((LENGTH (ARRAY-ACTIVE-LENGTH ASCII-ARRAY))
	 (LISPM-STRING (MAKE-ARRAY LENGTH :TYPE 'ART-STRING))
	 (ASCII-ARRAY ASCII-ARRAY))
    (DECLARE (ARRAY-REGISTER ASCII-ARRAY LISPM-STRING))
    (LOOP FOR INDEX FROM 0 BELOW LENGTH
	  DO (SETF (AREF LISPM-STRING INDEX) (ASCII-TO-CHAR (AREF ASCII-ARRAY INDEX))))
    LISPM-STRING))

;;; Read a number out of a string (starting at FROM, in the given RADIX).
;;; Returns the number, or NIL if no number was seen.
;;; Second value returned is where in the string the number ended
;;; (index of first non-digit). FAIL-IF-NOT-WHOLE-STRING causes nil
;;; to be returned unless the whole string is a number
(DEFUN PARSE-NUMBER (STRING &OPTIONAL (FROM 0) TO RADIX FAIL-IF-NOT-WHOLE-STRING)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (DECLARE (VALUES NUMBER-OR-NIL ENDING-INDEX))
  (LOOP WITH SIGN = NIL
	WITH NUM = NIL
	WITH RADIX = (OR RADIX 10.)
	WITH DIGIT
	FOR I FROM FROM BELOW (OR TO (STRING-LENGTH STRING))
	FOR CH = (AREF STRING I)
	DO (COND ((AND (NULL SIGN) (NULL NUM) (CHAR-EQUAL CH #/+)) (SETQ SIGN 1))
		 ((AND (NULL SIGN) (NULL NUM) (CHAR-EQUAL CH #/-)) (SETQ SIGN -1))
		 ((COND ((SETQ DIGIT (DIGIT-CHAR-P CH RADIX))
			 (SETQ NUM (+ (* (OR NUM 0) RADIX) DIGIT)))))
		 (T
		  (IF FAIL-IF-NOT-WHOLE-STRING
		      (RETURN (VALUES NIL 0))
		      (LOOP-FINISH))))
	FINALLY (RETURN (VALUES (AND NUM (* NUM (OR SIGN 1))) (IF NUM I 0)))))

;;; "Print" a number into an array the fast way
(DEFUN NUMBER-INTO-ARRAY (ARRAY N &OPTIONAL (RADIX BASE) (AT-INDEX 0) (MIN-COLUMNS 0)
				  &AUX QUOT)
  (COND ((< N 0)
	 (ASET #\- ARRAY AT-INDEX)
	 (NUMBER-INTO-ARRAY ARRAY (- N) RADIX (1+ AT-INDEX) (1- MIN-COLUMNS)))
	(T (IF (ZEROP (SETQ QUOT (// N RADIX)))
	       (DOTIMES (I (1- MIN-COLUMNS))
		 (DECLARE (IGNORE I))
		 (ASET #\SP ARRAY AT-INDEX)
		 (SETQ AT-INDEX (1+ AT-INDEX)))
	     (SETQ AT-INDEX (NUMBER-INTO-ARRAY ARRAY QUOT RADIX AT-INDEX (1- MIN-COLUMNS))))
	   (ASET (DIGIT-CHAR (\ N RADIX) RADIX) ARRAY AT-INDEX)
	   (1+ AT-INDEX))))

;;; Add an array to the end of another
(DEFUN APPEND-TO-ARRAY (TO-ARRAY FROM-ARRAY &OPTIONAL (FROM-START 0) FROM-END
					    &AUX OLD-LENGTH NEW-LENGTH)
  (OR FROM-END (SETQ FROM-END (ARRAY-ACTIVE-LENGTH FROM-ARRAY)))
  (SETQ NEW-LENGTH (+ (SETQ OLD-LENGTH (ARRAY-LEADER TO-ARRAY 0)) (- FROM-END FROM-START)))
  (AND (< (ARRAY-LENGTH TO-ARRAY) NEW-LENGTH) (ADJUST-ARRAY-SIZE TO-ARRAY NEW-LENGTH))
  (COPY-ARRAY-PORTION FROM-ARRAY FROM-START FROM-END TO-ARRAY OLD-LENGTH NEW-LENGTH)
  (STORE-ARRAY-LEADER NEW-LENGTH TO-ARRAY 0))

#||
;; This is the original (slower and simpler) definition
(DEFUN SXHASH-STRING (STRING)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (COERCE-STRING-ARG STRING)
  (LET* ((STRING STRING)
	 (LENGTH (ARRAY-ACTIVE-LENGTH STRING))
	 (HASH 0))
    (DECLARE (SYS:ARRAY-REGISTER STRING))
    (IF (STRING-FAT-P STRING)
	(DOTIMES (I LENGTH)
	  (SETQ HASH (ROT (LOGXOR (SXHASH-CHARACTER (AREF STRING I)) HASH) 7)))
	(DOTIMES (I LENGTH)
	  (SETQ HASH (ROT (LOGXOR (LOGAND (CHAR-SUBINDEX (AREF STRING I)) #O337) HASH) 7))))
    (NON-NEGATIVE-FIXNUM HASH)))
||#

;This ignores bit 5 of each character so that equal strings will have the same sxhash.
;Also ignores any high-order bits if the string is a 16-bit string.
(DEFUN SXHASH-STRING (STRING)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (unless (stringp string)
    (setq string (reference-string string)))
  (COERCE-STRING-ARG STRING)
  (LET* ((LENGTH (ARRAY-ACTIVE-LENGTH STRING))
	 (HASH 0))
    (COND ((STRING-FAT-P STRING)
	   (LET ((STRING STRING))
	     (DECLARE (SYS:ARRAY-REGISTER STRING))
	     (DOTIMES (I LENGTH)
	       (SETQ HASH (ROT (LOGXOR (SXHASH-CHARACTER (AREF STRING I)) HASH) 7)))))
	  ((AND (> LENGTH 4) ;Other algorithm usually works better for length  4.
		#+IMach (ZEROP (%P-LDB ARRAY-LONG-PREFIX-BIT
				       (SETQ STRING (FOLLOW-STRUCTURE-FORWARDING STRING))))
		#+3600  (= (%P-LDB ARRAY-DISPATCH-FIELD
				   (SETQ STRING (FOLLOW-STRUCTURE-FORWARDING STRING)))
			   %ARRAY-DISPATCH-CHARACTER))
	   #+IMach (SETF (%BLOCK-REGISTER 1) (%POINTER-PLUS STRING 1))
	   (DO ((MASK #o337)
		#+3600 (POINTER (%MAKE-POINTER DTP-LOCATIVE STRING))
		(COUNT (LDB (BYTE #o35 2) (1- LENGTH)) (1- COUNT)))
	       (( COUNT 0)
		(DO ((WORD #+3600  (%P-CONTENTS-INCREMENT-POINTER POINTER)
			   #+IMach (%BLOCK-READ 1 :FIXNUM-ONLY T :SET-CDR-NEXT T :PREFETCH NIL
						  :NO-INCREMENT T)
			   (ROT WORD -8))
		     (COUNT (1+ (LDB (BYTE 2 0) (1- LENGTH))) (1- COUNT)))
		    (( COUNT 0))
		  (SETQ HASH (ROT (LOGXOR (LOGAND (%LOGLDB (BYTE 8 0) WORD) MASK) HASH) 7))))
	     (LET* ((WORD #+3600  (%P-CONTENTS-INCREMENT-POINTER POINTER)
			  #+IMach (%BLOCK-READ 1 :FIXNUM-ONLY T :SET-CDR-NEXT T)))
	       (SETQ HASH
		     (ROT (LOGXOR
			    (LOGAND (%LOGLDB (BYTE 8 #o30) WORD) MASK)
			    (%LOGDPB (LOGAND (%LOGLDB (BYTE 8 #o20) WORD) MASK) (BYTE 8 7) 0)
			    (%LOGDPB (LOGAND (%LOGLDB (BYTE 8 #o10) WORD) MASK) (BYTE 8 14.) 0)
			    (%LOGDPB (LOGAND WORD MASK) (BYTE 8 21.) 0)
			    (ROT HASH 21.))
			  7)))))
	  (T
	   (LET ((STRING STRING)
		 (MASK #o337))
	     (DECLARE (SYS:ARRAY-REGISTER STRING))
	     (DOTIMES (I LENGTH)
	       (SETQ HASH (ROT (LOGXOR (LOGAND (CHAR-SUBINDEX (AREF STRING I)) MASK) HASH)
			       7))))))
    (NON-NEGATIVE-FIXNUM HASH)))

#| Metering and testing functions for SXHASH-STRING |
(DEFUN METER-NEW-SXHASH-STRING ()
  (LABELS ((TEST (STRING)
	     (MULTIPLE-VALUE-BIND (OLD NEW)
		 (WITHOUT-INTERRUPTS
		   (VALUES (DO ((TIME (%MICROSECOND-CLOCK))
				(COUNT 100. (1- COUNT)))
			       (( COUNT 0)
				(%32-BIT-DIFFERENCE (%MICROSECOND-CLOCK) TIME))
			     (SXHASH-STRING STRING)
			     (SXHASH-STRING STRING)
			     (SXHASH-STRING STRING)
			     (SXHASH-STRING STRING))
			   (DO ((TIME (%MICROSECOND-CLOCK))
				(COUNT 100. (1- COUNT)))
			       (( COUNT 0)
				(%32-BIT-DIFFERENCE (%MICROSECOND-CLOCK) TIME))
			     (NEW-SXHASH-STRING STRING)
			     (NEW-SXHASH-STRING STRING)
			     (NEW-SXHASH-STRING STRING)
			     (NEW-SXHASH-STRING STRING))))
	       (FORMAT T "~%~36<(~2D) ~S:~;~> Old ~,,6$ us, New ~,,6$ us.  Ratio = ~$"
		       (STRING-LENGTH STRING) STRING (// OLD 400.0) (// NEW 400.0)
		       (// (FLOAT NEW) OLD)))))
    (LOOP FOR I TO 26 DO
      (TEST (SUBSTRING "abcdefghijklmnopqrstuvwxyz" 0 I)))))

(DEFUN TEST-NEW-SXHASH-STRING ()
  (LABELS ((TEST (STRING)
	     (LET ((OLD (SXHASH-STRING STRING))
		   (NEW (NEW-SXHASH-STRING STRING)))
	       (WHEN ( OLD NEW)
		 (FORMAT T "~&Mismatch on ~S:  old=~O, new=~O" STRING OLD NEW)))))
    (LOOP FOR I TO 26 DO
      (TEST (SUBSTRING "abcdefghijklmnopqrstuvwxyz" 0 I)))
    (MAP-OVER-OBJECTS
      #'(LAMBDA (AREA) (OR (= AREA PNAME-AREA)))
      #'REGION-PREDICATE-STRUCTURE
      #'(LAMBDA (AREA REGION ADDRESS HEADER LEADER SIZE)
	  (DECLARE (IGNORE AREA REGION ADDRESS LEADER SIZE))
	  (WHEN (STRINGP HEADER)
	    (TEST HEADER))))))

;; Average pname length seems to vary between 11 and 18 for all packages.
(DEFUN AVERAGE-PNAME-LENGTH (PKG)
  (LET ((SUM 0) (COUNT 0))
    (DO-SYMBOLS (SYMBOL PKG)
      (INCF COUNT)
      (INCF SUM (STRING-LENGTH (GET-PNAME SYMBOL))))
    (// SUM (FLOAT COUNT))))
||#



;(WITH-INPUT-FROM-STRING (var string &optional index limit)
;   body)

;body is executed with var bound to a stream which reads
;from string (or the given substring)
;Value is value of last form in body.
;If index is included and non-NIL, it is a variable or SETF'able field which
; contains the index into the string.  It is not bound by the form
; and must be initialized on the outside to the starting index,
; usually zero.  Upon normal completion it contains the index
; of the first character not read (the length of the string if
; it read all the way to the end and got an eof).
;If limit is supplied non-NIL, it is the string length to use.
;string and limit are evaluated.
;A "downward closure" is used, so be careful what you do with var.
;You cannot save it away.

(DEFMACRO WITH-INPUT-FROM-STRING ((VAR STRING &OPTIONAL INDEX LIMIT) &BODY BODY)
  `(CL:WITH-INPUT-FROM-STRING (,VAR ,STRING
			       ,@(WHEN INDEX `(:START ,INDEX :INDEX ,INDEX))
			       ,@(WHEN LIMIT `(:END ,LIMIT)))
     ,@BODY))

;(WITH-OUTPUT-TO-STRING (var &optional string index)
;   body)
;body is executed with var bound to a stream which outputs to
; a string.  If string and index are not supplied, the returned
; value is the string.  If string and index are supplied, string
; is evaluated to supply the string to be modified and index
; is a variable or SETF'able field which contains the index of the next character
; to be stored; it must be initialized on the outside and
; is updated upon normal exit.  In this case the returned value
; is the value of the last form in the body.
; If string is supplied and index is omitted, string is "nconced"
; onto.
; If string has an array-leader, the fill-pointer is updated.
; If the user does not supply a string, the system-supplied string
; will not have an array leader.
; A system-supplied string will be adjusted to just the right length,
; but a user-supplied string will not be adjusted downwards in size,
; only upwards, hence may end up bigger than necessary.
;A "downward closure" is used, so be careful what you do with var.
;You cannot save it away and cannot nest two of these and try
;to use both var's inside the inner one.
;Multiple values are never returned.

(DEFMACRO WITH-OUTPUT-TO-STRING ((VAR &OPTIONAL (STRING NIL STRING-P) INDEX) &BODY BODY)
  (LET ((ARGS (COND (INDEX
		     `(,STRING :INDEX ,INDEX))
		    (STRING-P
		     `(,STRING)))))
    `(CL:WITH-OUTPUT-TO-STRING (,VAR ,@ARGS)
       ,@BODY)))


;;;; Mouse "characters"

(DEFSTRUCT (MOUSE-CHAR :CONC-NAME :NAMED
		       (:CONSTRUCTOR MAKE-MOUSE-CHAR-INTERNAL)
		       (:MAKE-ARRAY (:AREA SAFEGUARDED-OBJECTS-AREA))
		       (:ALTERANT NIL))
  BUTTON
  BITS)

(DEFSELECT-COLD ((MOUSE-CHAR NAMED-STRUCTURE-INVOKE))
  (:PRINT-SELF (CHAR STREAM IGNORE IGNORE)
   (FORMAT:FORMAT-MOUSE-CHARACTER STREAM CHAR NIL NIL NIL T))
  (:FASD-FORM (CHAR)
   `(MAKE-MOUSE-CHAR ,(MOUSE-CHAR-BUTTON CHAR) ,(MOUSE-CHAR-BITS CHAR)))
  )

(DEFUN MAKE-MOUSE-CHAR-CACHE ()
  ;; The (* 2 ..) is to make room for Shift.
  (LOOP WITH ARRAY = (MAKE-ARRAY (LIST 3 (* 2 CHAR-BITS-LIMIT))
				 :AREA SAFEGUARDED-OBJECTS-AREA)
	FOR BUTTON BELOW 3
	DO (LOOP FOR BITS BELOW (* 2 CHAR-BITS-LIMIT)
		 DO (SETF (AREF ARRAY BUTTON BITS)
			  (MAKE-MOUSE-CHAR-INTERNAL BUTTON BUTTON BITS BITS)))
	FINALLY (RETURN ARRAY)))

(DEFVAR *MOUSE-CHAR-CACHE* (MAKE-MOUSE-CHAR-CACHE))

(DEFUN MAKE-MOUSE-CHAR (BUTTON &OPTIONAL (BITS 0))
  (DECLARE LT:(SIDE-EFFECTS READER))
  (AREF *MOUSE-CHAR-CACHE* BUTTON BITS))

(DEFUN MOUSE-CHAR-P (CHAR)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE))
  (TYPEP CHAR 'MOUSE-CHAR))

(DEFUN CHAR-MOUSE-EQUAL (CHAR1 CHAR2)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (CHECK-ARG CHAR1 MOUSE-CHAR-P "a mouse character")
  (CHECK-ARG CHAR2 MOUSE-CHAR-P "a mouse character")
  (EQ CHAR1 CHAR2))

(DEFUN CHAR-MOUSE-< (CHAR1 CHAR2)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (OR (< (CHAR-MOUSE-BITS CHAR1) (CHAR-MOUSE-BITS CHAR2))
      (AND (= (CHAR-MOUSE-BITS CHAR1) (CHAR-MOUSE-BITS CHAR2))
	   (< (CHAR-MOUSE-BUTTON CHAR1) (CHAR-MOUSE-BUTTON CHAR2)))))

(DEFUN CHAR-MOUSE- (CHAR1 CHAR2)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (OR (CHAR-MOUSE-EQUAL CHAR1 CHAR2)
      (CHAR-MOUSE-< CHAR1 CHAR2)))

(DEFUN CHAR-MOUSE-BUTTON (CHAR)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (MOUSE-CHAR-BUTTON CHAR))

(DEFUN CHAR-MOUSE-BITS (CHAR)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (MOUSE-CHAR-BITS CHAR))


;; The grand-unified string thinifier.
;; This doesn't do any copying if it doesn't have to.
(defun string-thin (string &key (start 0) end
				(remove-style t)
				(remove-bits nil)
				(error-if nil)
				area)
  (when (not (string-fat-p string))
    (return-from string-thin string))
  (let* ((source-length (string-length string))
	 (source-string string)
	 (end (or end source-length))
	 ;; Fatten the result string only when necessary
	 (result-length (- end start))
	 (result-string (make-array result-length
				    :type art-string
				    :area area
				    :fill-pointer result-length)))
    (declare (sys:array-register source-string result-string))
    (macrolet ((process-char (char bits style-index)
		 `(let ((new-char
			  (char-dpb-internal ,bits %%char-bits
					     (char-dpb-internal 0 %%char-style
								,char))))
		    (unless (or (char-equal ,char #/Return)
				(not (zerop ,bits)))
		      (setf (si:char-style-index new-char) ,style-index))
		    new-char)))
      (loop with result-thin = t
	    for from-index upfrom start below end
	    for to-index upfrom 0
	    as char = (aref source-string from-index)
	    as style-index = (if remove-style
				 0
			       (char-ldb-internal %%char-style char))
	    as bits = (if remove-bits
			  0
			(char-ldb-internal %%char-bits char))
	    as new-char = (process-char char bits style-index)
	    doing
	(let ((new-char-fat (char-fat-p new-char)))
	  (when (and error-if
		     (cl:ecase error-if
		       (:fat new-char-fat)
		       (:bits (not (zerop (char-ldb-internal %%char-bits new-char))))))
	    ;;--- We can do better than this
	    (ferror "The string ~S ~:[still contains bits~;is still fat~] ~
		     after ~A been removed"
	      source-string (eq error-if :fat)
	      (cond ((and remove-bits remove-style)
		     "style information and bits have")
		    (remove-bits
		     "bits have")
		    (remove-style
		     "style information has"))))
	  (when (and new-char-fat result-thin)
	    ;; We are stashing a fat character into a thin string, so fatten
	    ;; the result string.
	    (let ((new-result-string (make-array result-length
						 :type art-fat-string
						 :area area
						 :fill-pointer result-length)))
	      (when (not (zerop to-index))
		(copy-array-portion-internal
		  result-string 0 to-index
		  new-result-string 0 to-index))
	      (setq result-thin nil)
	      (setq result-string new-result-string)
	      (sys:array-register-event)))
	  (setf (aref result-string to-index) new-char))
	    finally
	      (return result-string)))))

#||

;; Test cases

(defvar gratuitously-fat-string
	cl:(make-array 7 :element-type 'character :initial-contents "gratuit"))
(defvar stylish-fat-string
	cl:(make-array 7 :element-type 'character :initial-contents "1stylish0"))
(defvar bits-fat-string
	cl:(make-array 5 :element-type 'character :initial-element #\control-A))
(defvar truly-fat-string
	cl:(make-array 5 :element-type 'character :initial-element #\mouse:nw-arrow))

(string-thin gratuitously-fat-string :remove-style nil :remove-bits nil)
(string-thin gratuitously-fat-string :remove-style nil :remove-bits t  )
(string-thin gratuitously-fat-string :remove-style t   :remove-bits nil)
(string-thin gratuitously-fat-string :remove-style t   :remove-bits t  )
(string-thin gratuitously-fat-string :remove-style nil :remove-bits nil :error-if :fat)
(string-thin gratuitously-fat-string :remove-style nil :remove-bits t   :error-if :fat)
(string-thin gratuitously-fat-string :remove-style t   :remove-bits nil :error-if :fat)
(string-thin gratuitously-fat-string :remove-style t   :remove-bits t   :error-if :fat)
(string-thin gratuitously-fat-string :remove-style nil :remove-bits nil :error-if :bits)
(string-thin gratuitously-fat-string :remove-style nil :remove-bits t   :error-if :bits)
(string-thin gratuitously-fat-string :remove-style t   :remove-bits nil :error-if :bits)
(string-thin gratuitously-fat-string :remove-style t   :remove-bits t   :error-if :bits)

(string-thin stylish-fat-string :remove-style nil :remove-bits nil)
(string-thin stylish-fat-string :remove-style nil :remove-bits t  )
(string-thin stylish-fat-string :remove-style t   :remove-bits nil)
(string-thin stylish-fat-string :remove-style t   :remove-bits t  )
(string-thin stylish-fat-string :remove-style nil :remove-bits nil :error-if :fat)
(string-thin stylish-fat-string :remove-style nil :remove-bits t   :error-if :fat)
(string-thin stylish-fat-string :remove-style t   :remove-bits nil :error-if :fat)
(string-thin stylish-fat-string :remove-style t   :remove-bits t   :error-if :fat)
(string-thin stylish-fat-string :remove-style nil :remove-bits nil :error-if :bits)
(string-thin stylish-fat-string :remove-style nil :remove-bits t   :error-if :bits)
(string-thin stylish-fat-string :remove-style t   :remove-bits nil :error-if :bits)
(string-thin stylish-fat-string :remove-style t   :remove-bits t   :error-if :bits)

(string-thin bits-fat-string :remove-style nil :remove-bits nil)
(string-thin bits-fat-string :remove-style nil :remove-bits t  )
(string-thin bits-fat-string :remove-style t   :remove-bits nil)
(string-thin bits-fat-string :remove-style t   :remove-bits t  )
(string-thin bits-fat-string :remove-style nil :remove-bits nil :error-if :fat)
(string-thin bits-fat-string :remove-style nil :remove-bits t   :error-if :fat)
(string-thin bits-fat-string :remove-style t   :remove-bits nil :error-if :fat)
(string-thin bits-fat-string :remove-style t   :remove-bits t   :error-if :fat)
(string-thin bits-fat-string :remove-style nil :remove-bits nil :error-if :bits)
(string-thin bits-fat-string :remove-style nil :remove-bits t   :error-if :bits)
(string-thin bits-fat-string :remove-style t   :remove-bits nil :error-if :bits)
(string-thin bits-fat-string :remove-style t   :remove-bits t   :error-if :bits)

(string-thin truly-fat-string :remove-style nil :remove-bits nil)
(string-thin truly-fat-string :remove-style nil :remove-bits t  )
(string-thin truly-fat-string :remove-style t   :remove-bits nil)
(string-thin truly-fat-string :remove-style t   :remove-bits t  )
(string-thin truly-fat-string :remove-style nil :remove-bits nil :error-if :fat)
(string-thin truly-fat-string :remove-style nil :remove-bits t   :error-if :fat)
(string-thin truly-fat-string :remove-style t   :remove-bits nil :error-if :fat)
(string-thin truly-fat-string :remove-style t   :remove-bits t   :error-if :fat)
(string-thin truly-fat-string :remove-style nil :remove-bits nil :error-if :bits)
(string-thin truly-fat-string :remove-style nil :remove-bits t   :error-if :bits)
(string-thin truly-fat-string :remove-style t   :remove-bits nil :error-if :bits)
(string-thin truly-fat-string :remove-style t   :remove-bits t   :error-if :bits)

||#
