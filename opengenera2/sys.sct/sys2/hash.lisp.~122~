;;; -*- Mode: LISP; Package: SYSTEM-INTERNALS; Base: 10 -*-
;;; Created 5/27/82 14:07:17 by BEE
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;--- Minimally converted to new flavor system, still using solid message passing
;--- Conversion isn't considered to be finished, this version is just for debugging

;;; Defined operations:
;;; :CHOOSE-NEW-SIZE (SIZE-OFFER) returns REAL-SIZE
;;;     - given a suggested size, returns the real size in elements
;;; :CLEAR-HASH (&optional FORCE-P)
;;;    - clear out the hash table FORCE-P causes it to be done even if empty already
;;; :GET-HASH (KEY) returns VALUE,FOUND
;;;    - returns value associated with the KEY
;;; :PUT-HASH (KEY VALUE)
;;;    - associates VALUE with the KEY in hash table
;;; :SWAP-HASH (KEY NEW-VALUE) returns OLD-VALUE,FOUND
;;;    - associates NEW-VALUE with KEY, returns old VALUE associated with key and
;;;      found if there was one
;;; :REM-HASH (KEY) returns FOUND
;;;    - removes KEY and associated value from the table returns T if it had a value
;;; :MAP-HASH (FUNCTION &REST OTHER-ARGS)
;;;    - calls function on (KEY VALUE . OTHER-ARGS) for every KEY and VALUE in hash table
;;; :MODIFY-HASH (key function &rest other_arguments)
;;;    - calls function on (key value key-exists-p . other_arguments)
;;;	 and associates the result with KEY.
;;; :NEXT-ELEMENT
;;;    - for LOOP iteration path

;;; The following messages are internal and may only be sent with the
;;; hash table locked:
;;;	:GROW	:COPY-HASH	:NEW-ARRAY	:BLOCK-POINTER

;;; Internal interface must also supply:
;;; :NEW-ARRAY (SIZE-OFFER) - creates a new hash-array of size  SIZE-OFFER

(DEFFLAVOR BASIC-HASH-TABLE
	(HASH-ARRAY
	 (FILLED-ELEMENTS 0)
	 (SIZE 100)
	 AREA
	 HASH-TABLE-LOCK)
	(FUTURE-COMMON-LISP:HASH-TABLE)
  (:INITABLE-INSTANCE-VARIABLES SIZE AREA)
  (:REQUIRED-METHODS :NEW-ARRAY :CLEAR-HASH :GET-HASH :PUT-HASH
                     :SWAP-HASH :REM-HASH :MAP-HASH :MODIFY-HASH)
  (:DEFAULT-INIT-PLIST :AREA DEFAULT-CONS-AREA)
  (:INIT-KEYWORDS :REHASH-BEFORE-COLD :INITIAL-DATA)
  (:GETTABLE-INSTANCE-VARIABLES FILLED-ELEMENTS SIZE)
  )

(DEFMETHOD (MAKE-INSTANCE BASIC-HASH-TABLE) (&KEY REHASH-BEFORE-COLD INITIAL-DATA
					     &ALLOW-OTHER-KEYS)
  (SETF HASH-TABLE-LOCK (PROCESS:MAKE-LOCK "Hash Table Lock" :RECURSIVE T :AREA AREA))
  (SEND SELF ':NEW-ARRAY SIZE)
  (SEND SELF ':CLEAR-HASH)
  (WHEN REHASH-BEFORE-COLD
    (PUSH SELF REHASH-THESE-HASH-TABLES-BEFORE-COLD))
  (WHEN INITIAL-DATA
    (SEND SELF ':PUT-DATA-ARRAY INITIAL-DATA)))

(DEFMACRO LOCK-HASH-TABLE (&BODY BODY)
  `(PROCESS:WITH-LOCK (HASH-TABLE-LOCK)
     ,@BODY))

(DEFMETHOD (:FASD-FORM BASIC-HASH-TABLE) ()
  `(CREATE-HASH-TABLE :FLAVOR ',(TYPEP SELF)
		      :AREA ,(IF (SYMBOLP AREA) AREA (AREA-NAME AREA))
		      :SIZE ',SIZE
		      :INITIAL-DATA ',(SEND SELF ':GET-DATA-ARRAY)))

(DEFUN CREATE-HASH-TABLE (FLAVOR-KEYWORD &REST OPTIONS)
  (UNLESS (EQ FLAVOR-KEYWORD ':FLAVOR)
    (ERROR "First keyword argument must be :FLAVOR"))
  (APPLY #'MAKE-INSTANCE OPTIONS))

;;; Compatibility with new hash tables.

(DEFMETHOD (CL:GETHASH BASIC-HASH-TABLE) (KEY &OPTIONAL DEFAULT)
  (MULTIPLE-VALUE-BIND (VALUE FLAG)
      (SEND SELF :GET-HASH KEY)
    (VALUES (IF FLAG VALUE DEFAULT)
	    FLAG)))

(DEFMETHOD (CLI::PUTHASH BASIC-HASH-TABLE) (KEY VALUE)
  (SEND SELF :PUT-HASH KEY VALUE))

(DEFMETHOD (CL:REMHASH BASIC-HASH-TABLE) (KEY)
  (SEND SELF :REM-HASH KEY))

(DEFMETHOD (CLI::FAST-TABLE-GET BASIC-HASH-TABLE) (KEY)
  (VALUES (SEND SELF :GET-HASH KEY)))

(DEFMETHOD (SCL:MODIFY-HASH BASIC-HASH-TABLE) (KEY FUNCTION)
  (SEND SELF :MODIFY-HASH KEY FUNCTION))

(DEFMETHOD (CL:HASH-TABLE-COUNT BASIC-HASH-TABLE) ()
  (SEND SELF :FILLED-ELEMENTS))

(DEFMETHOD (CL:MAPHASH BASIC-HASH-TABLE) (FUNCTION)
  (SEND SELF :MAP-HASH FUNCTION))

(DEFMETHOD (CL:CLRHASH BASIC-HASH-TABLE) ()
  (SEND SELF :CLEAR-HASH)
  SELF)



(DEFPROP DEFINE-BASIC-HASH-TABLE-FLAVOR "Hash table methods" SI:DEFINITION-TYPE-NAME)

(DEFMACRO DEFINE-BASIC-HASH-TABLE-FLAVOR (FLAVOR LOCK-FUN)
`(LOCAL-DECLARE ((SYS:FUNCTION-PARENT ,FLAVOR DEFINE-BASIC-HASH-TABLE-FLAVOR))

(DEFMETHOD (:GET-DATA-ARRAY ,FLAVOR) ()
  (,LOCK-FUN
    (LET ((DATA-ARRAY (MAKE-ARRAY (* 2 FILLED-ELEMENTS) ':FILL-POINTER 0)))
      (SEND SELF ':MAP-HASH #'(LAMBDA (KEY VALUE ARRAY)
				(ARRAY-PUSH ARRAY KEY)
				(ARRAY-PUSH ARRAY VALUE))
			    DATA-ARRAY)
      DATA-ARRAY)))

(DEFMETHOD (:PUT-DATA-ARRAY ,FLAVOR) (DATA-ARRAY)
  (,LOCK-FUN
    (LOOP FOR I FROM 0 BELOW (ARRAY-ACTIVE-LENGTH DATA-ARRAY) BY 2
	  DO (SEND SELF ':PUT-HASH (AREF DATA-ARRAY I) (AREF DATA-ARRAY (1+ I))))))

(DEFMETHOD (:COPY-HASH-LOCKED ,FLAVOR) (OLD-ARRAY OLD-SIZE)
  (,LOCK-FUN
    (SEND SELF :COPY-HASH OLD-ARRAY OLD-SIZE)))

(DEFMETHOD (CLI::WITH-TABLE-LOCKED-INTERNAL ,FLAVOR) (FUNCTION)
  (,LOCK-FUN
   (FUNCALL FUNCTION)))

));end DEFMACRO DEFINE-BASIC-HASH-TABLE-FLAVOR

(DEFFLAVOR EQ-HASH-TABLE
	   (GC-GENERATION-NUMBER		;Value of %GC-GENERATION-NUMBER when rehashed
	    GC-DYNAMIC-GENERATION-NUMBER	;Value of %GC-DYNAMIC-GENERATION-NUMBER when
						;rehashed if no ephemeral keys; otherwise NIL
	    (GROWTH-FACTOR 1.3))
	   (BASIC-HASH-TABLE)
  (:INITABLE-INSTANCE-VARIABLES GROWTH-FACTOR)
  (:INIT-KEYWORDS :REHASH-THRESHOLD))		;ignored, but we accept it anyway

(DEFPROP DEFINE-EQ-HASH-TABLE-FLAVOR "Hash table methods" SI:DEFINITION-TYPE-NAME)

(DEFMACRO DEFINE-EQ-HASH-TABLE-FLAVOR (FLAVOR LOCK-FUN)
`(LOCAL-DECLARE ((SYS:FUNCTION-PARENT ,FLAVOR DEFINE-EQ-HASH-TABLE-FLAVOR))

(DEFINE-BASIC-HASH-TABLE-FLAVOR ,FLAVOR ,LOCK-FUN)

(DEFMETHOD (:CLEAR-HASH ,FLAVOR) (&OPTIONAL FORCE-P)
  (,LOCK-FUN
    (COND ((OR FORCE-P (> FILLED-ELEMENTS 0))
	   ;; Fill with NIL
	   (PAGE-IN-ARRAY HASH-ARRAY NIL NIL NIL)
	   (FILL-ARRAY HASH-ARRAY (* 2 SIZE) NIL)
	   ;; Fill key positions with dtp-nulls
	   (LOOP WITH ARRAY = HASH-ARRAY	;get it in a local
		 WITH MAX-IDX = (* 2 SIZE)
		 FOR BASE-IDX UPFROM 0 BY 16. BELOW MAX-IDX DO
	     (LOOP REPEAT 8.
		   FOR IDX UPFROM BASE-IDX BELOW MAX-IDX
		   AS LOC = (ALOC ARRAY IDX) DO
	       (%P-STORE-TAG-AND-POINTER LOC DTP-NULL LOC)))
	   ;; I have no idea if this is right...
	   ;; DCP does't think so.  I think all places that send
	   ;; :clear-hash in this file use the array very soon
	   ;; thereafter, especially copy-hash.  I'm willing to bet most
	   ;; outside users send :clear-hash in order to start over, and
	   ;; not to just get rid of it.  Under these assumptions,
	   ;; page-out-array is the wrong thing. 
	   ;(PAGE-OUT-ARRAY HASH-ARRAY)
	   (SETQ FILLED-ELEMENTS 0)))
    (SETQ GC-GENERATION-NUMBER %GC-GENERATION-NUMBER
	  GC-DYNAMIC-GENERATION-NUMBER %GC-DYNAMIC-GENERATION-NUMBER))
  SELF)

(DEFMETHOD (:GET-HASH ,FLAVOR) (KEY)
  (,LOCK-FUN
    (INHIBIT-GC-FLIPS
      (IF ( GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
	  (SEND SELF ':COPY-HASH HASH-ARRAY SIZE))
      (LOOP REPEAT 8
	    FOR LOC FIRST (SEND SELF ':BLOCK-POINTER KEY)
	    THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE LOC 1)
	    IF (%P-CONTENTS-EQ LOC KEY)
	    DO (RETURN (VALUES (%P-CONTENTS-OFFSET LOC 8) T))))))

(DEFMETHOD (:PUT-HASH ,FLAVOR) (KEY VALUE)
  (,LOCK-FUN
    (INHIBIT-GC-FLIPS
      (IF ( GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
	  (SEND SELF ':COPY-HASH HASH-ARRAY SIZE))
      (LOOP REPEAT 8
	    WITH FIRST-EMPTY = NIL
	    FOR LOC FIRST (SEND SELF ':BLOCK-POINTER KEY)
	    THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE LOC 1)
	    IF (%P-CONTENTS-EQ LOC KEY)
	      DO (%P-STORE-CONTENTS-OFFSET VALUE LOC 8)
		 (RETURN)
	    IF (AND (NULL FIRST-EMPTY) (= (%P-DATA-TYPE LOC) DTP-NULL))
	      DO (SETQ FIRST-EMPTY LOC)
	    FINALLY 
	    (COND (FIRST-EMPTY			;Add to table using empty slot found
		   ;; make sure key, value and size are updated atomically
		   (,(IF (EQ LOCK-FUN 'WITHOUT-INTERRUPTS) 'PROGN 'WITHOUT-INTERRUPTS)
		    (%P-STORE-CONTENTS FIRST-EMPTY KEY)
		    (%P-STORE-CONTENTS-OFFSET VALUE FIRST-EMPTY 8)
		    (INCF FILLED-ELEMENTS)
		    (WHEN (%EPHEMERALP KEY)	;Have to rehash on ephemeral flips, too
		      (SETQ GC-DYNAMIC-GENERATION-NUMBER NIL))))
		  (T				;Need to make more room, then try again
		   (SEND SELF ':GROW)
		   (SEND SELF ':PUT-HASH KEY VALUE))))
      VALUE)))

(DEFMETHOD (:SWAP-HASH ,FLAVOR) (KEY VALUE)
  (,LOCK-FUN
   (INHIBIT-GC-FLIPS
     (IF ( GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
	 (SEND SELF ':COPY-HASH HASH-ARRAY SIZE))
     (LOOP REPEAT 8
	   WITH FIRST-EMPTY = NIL
	   FOR LOC FIRST (SEND SELF ':BLOCK-POINTER KEY)
	       THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE LOC 1)
	   IF (%P-CONTENTS-EQ LOC KEY)
	     DO (RETURN (VALUES (PROG1 (%P-CONTENTS-OFFSET LOC 8)
				       (%P-STORE-CONTENTS-OFFSET VALUE LOC 8))
				T))
	   IF (AND (NULL FIRST-EMPTY) (= (%P-DATA-TYPE LOC) DTP-NULL))
	     DO (SETQ FIRST-EMPTY LOC)
	   FINALLY 
	     (COND (FIRST-EMPTY			;Add to table using empty slot found
		    (,(IF (EQ LOCK-FUN 'WITHOUT-INTERRUPTS) 'PROGN 'WITHOUT-INTERRUPTS)
		     (%P-STORE-CONTENTS FIRST-EMPTY KEY)
		     (%P-STORE-CONTENTS-OFFSET VALUE FIRST-EMPTY 8)
		     (INCF FILLED-ELEMENTS)
		     (WHEN (%EPHEMERALP KEY)	;Have to rehash on ephemeral flips, too
		       (SETQ GC-DYNAMIC-GENERATION-NUMBER NIL))))
		   (T				;Need to make more room, then try again
		    (SEND SELF ':GROW)
		    (SEND SELF ':PUT-HASH KEY VALUE)))
	     (RETURN (VALUES NIL NIL))))))

(DEFMETHOD (:MODIFY-HASH ,FLAVOR) (KEY FUNCTION &REST OTHER_ARGUMENTS)
  (,LOCK-FUN
    (INHIBIT-GC-FLIPS
      (IF ( GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
	  (SEND SELF ':COPY-HASH HASH-ARRAY SIZE))
      (LOOP REPEAT 8
	    WITH FIRST-EMPTY = NIL
	    FOR LOC FIRST (SEND SELF ':BLOCK-POINTER KEY)
		    THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE LOC 1)
	    DO (WHEN (%P-CONTENTS-EQ LOC KEY)
		 (LET ((VALUE (LEXPR-FUNCALL FUNCTION KEY (%P-CONTENTS-OFFSET LOC 8) T
					     OTHER_ARGUMENTS)))
		   (%P-STORE-CONTENTS-OFFSET VALUE LOC 8)
		   (RETURN VALUE)))
	       (AND (NULL FIRST-EMPTY) (= (%P-DATA-TYPE LOC) DTP-NULL)
		    (SETQ FIRST-EMPTY LOC))
	    FINALLY
	    (RETURN
	      (COND (FIRST-EMPTY		;Add to table using empty slot found
		     (LET ((VALUE (LEXPR-FUNCALL FUNCTION KEY NIL NIL OTHER_ARGUMENTS)))
		       (,(IF (EQ LOCK-FUN 'WITHOUT-INTERRUPTS) 'PROGN 'WITHOUT-INTERRUPTS)
			(%P-STORE-CONTENTS-OFFSET VALUE FIRST-EMPTY 8)
			(%P-STORE-CONTENTS FIRST-EMPTY KEY)
			(INCF FILLED-ELEMENTS)
			(WHEN (%EPHEMERALP KEY)	;Have to rehash on ephemeral flips, too
			  (SETQ GC-DYNAMIC-GENERATION-NUMBER NIL)))
		       VALUE))
		    (T				;Need to make more room, then try again
		     (SEND SELF ':GROW)
		     (LEXPR-SEND SELF ':MODIFY-HASH KEY FUNCTION OTHER_ARGUMENTS))))))))

(DEFMETHOD (:REM-HASH ,FLAVOR) (KEY)
  (,LOCK-FUN
    (INHIBIT-GC-FLIPS
      (IF ( GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
	  (SEND SELF ':COPY-HASH HASH-ARRAY SIZE))
      (LOOP REPEAT 8
	    FOR LOC FIRST (SEND SELF ':BLOCK-POINTER KEY)
		    THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE LOC 1)
	    IF (%P-CONTENTS-EQ LOC KEY)
	      DO (,(IF (EQ LOCK-FUN 'WITHOUT-INTERRUPTS) 'PROGN 'WITHOUT-INTERRUPTS)
		  (%P-STORE-CONTENTS-OFFSET NIL LOC 8)	;Wipe out old value
		  (%P-STORE-TAG-AND-POINTER LOC DTP-NULL LOC)	;Remove entry
		  (DECF FILLED-ELEMENTS))
		 (RETURN T)))))

));end DEFMACRO DEFINE-EQ-HASH-TABLE-FLAVOR

(DEFINE-EQ-HASH-TABLE-FLAVOR EQ-HASH-TABLE LOCK-HASH-TABLE)

;This is temporary until this really exists.
;It is supposed to be a microcode primitive that does the EQ test without
;transporting the contents of P and without barfing if it sees a DTP-NULL.
;This is needed for hash tables with weak links, which were never implemented.
(DEFSUBST %P-CONTENTS-EQ (P X) (AND (NEQ (%P-DATA-TYPE P) DTP-NULL)
				    (EQ (CAR P) X)))

(DEFMETHOD (:NEW-ARRAY EQ-HASH-TABLE) (NEW-SIZE)
  (LET* ((CHOSEN-SIZE (SEND SELF :CHOOSE-NEW-SIZE NEW-SIZE))
	 (NEW-HASH-ARRAY (MAKE-ARRAY (* 2 CHOSEN-SIZE) :AREA AREA :TYPE 'ART-Q)))
    (WITHOUT-INTERRUPTS
      (SETQ HASH-ARRAY NEW-HASH-ARRAY
	    SIZE       CHOSEN-SIZE)))
  (SEND SELF :CLEAR-HASH T))

(DEFMETHOD (:CHOOSE-NEW-SIZE EQ-HASH-TABLE) (SIZE-OFFER)
  (LET ((BLOCK-SIZE (// (+ SIZE-OFFER 7) 8)))	;Next higher multiple of 8
    (IF (EVENP BLOCK-SIZE)
	(INCF BLOCK-SIZE))			;Find next higher more-or-less prime
    (LOOP FOR PRIME-SIZE FROM BLOCK-SIZE BY 2
	  UNTIL (AND (NOT (ZEROP (\ PRIME-SIZE 3)))
		     (NOT (ZEROP (\ PRIME-SIZE 5)))
		     (NOT (ZEROP (\ PRIME-SIZE 7))))
	  FINALLY (RETURN (* 8 PRIME-SIZE)))))

(DEFMETHOD (:GROW EQ-HASH-TABLE) ()
  (LET ((OLD-ARRAY HASH-ARRAY)
	(OLD-SIZE SIZE))
    (SEND SELF ':NEW-ARRAY (IF (NOT (FIXP GROWTH-FACTOR))
			       (FIX (* SIZE GROWTH-FACTOR))
			       (+ SIZE GROWTH-FACTOR)))
    (SEND SELF ':COPY-HASH OLD-ARRAY OLD-SIZE)))

(DEFMETHOD (:COPY-HASH EQ-HASH-TABLE) (FROM-ARRAY FROM-SIZE)
  (COND ((AND (EQ FROM-ARRAY HASH-ARRAY)
	      (EQL GC-DYNAMIC-GENERATION-NUMBER %GC-DYNAMIC-GENERATION-NUMBER))
	 ;; Just doing a rehash (not growing), only ephemeral flips have occurred,
	 ;; and none of the keys are ephemeral.  We don't need to bother rehashing.
	 (SETQ GC-GENERATION-NUMBER %GC-GENERATION-NUMBER))
	((EQ FROM-ARRAY HASH-ARRAY)
	 ;; Really need to rehash
	 ;; No temporary array supplied by caller--make one.  Put it in the permanent
	 ;; area to decrease the chance of something else getting consed in the default
	 ;; area while we are rehashing, preventing RETURN-ARRAY from doing anything.
	 (LET ((TEMP-ARRAY (MAKE-ARRAY (+ FROM-SIZE FROM-SIZE) :AREA PERMANENT-STORAGE-AREA))
	       (MAX-DATUMS 0))
	   ;; Copy it all out into TEMP-ARRAY
	   (LOOP FOR I FROM 0 BELOW (+ FROM-SIZE FROM-SIZE)	;(* FROM-SIZE 2)
		 FOR LOC FIRST (%MAKE-POINTER-OFFSET DTP-LOCATIVE FROM-ARRAY
						     (ARRAY-DATA-OFFSET FROM-ARRAY))
		     THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE LOC 1)
		 DO (COND ((LDB-TEST (BYTE 1 3) I) ;(ODDP (// I 8))
			   (INCF I 7)
			   (SETQ LOC (%MAKE-POINTER-OFFSET DTP-LOCATIVE LOC 7)))
			  ((= (%P-DATA-TYPE LOC) DTP-NULL))
			  (T (ASET (CAR LOC) TEMP-ARRAY MAX-DATUMS)
			     (ASET (%P-CONTENTS-OFFSET LOC 8) TEMP-ARRAY (1+ MAX-DATUMS))
			     (INCF MAX-DATUMS 2))))
	   (SEND SELF ':CLEAR-HASH)			;Clear new array
	   (LOOP FOR I FROM 0 BELOW MAX-DATUMS BY 2
		 DO (SEND SELF ':PUT-HASH (AREF TEMP-ARRAY I) (AREF TEMP-ARRAY (1+ I))))
	   (RETURN-ARRAY TEMP-ARRAY)))
	(T
	 ;; Need to rehash, but caller supplied a temporary array to use
	 (SEND SELF ':CLEAR-HASH)			;Clear new array
	 (LOOP FOR I FROM 0 BELOW (+ FROM-SIZE FROM-SIZE)	;(* FROM-SIZE 2)
	       FOR LOC FIRST (%MAKE-POINTER-OFFSET DTP-LOCATIVE FROM-ARRAY
						   (ARRAY-DATA-OFFSET FROM-ARRAY))
		   THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE LOC 1)
	       DO (COND ((LDB-TEST (BYTE 1 3) I) ;(ODDP (// I 8))
			 (INCF I 7)
			 (SETQ LOC (%MAKE-POINTER-OFFSET DTP-LOCATIVE LOC 7)))
			((= (%P-DATA-TYPE LOC) DTP-NULL))
			(T (SEND SELF ':PUT-HASH (CAR LOC) (%P-CONTENTS-OFFSET LOC 8))))))))

;Given a EQ-HASH-TABLE and a key, return a locative to the start
;of the block in the array which may contain an association from that key.
;Cannot use ALOC because it gets an error if there is a DTP-NULL in the array.
(DEFMETHOD (:BLOCK-POINTER EQ-HASH-TABLE) (KEY)
  (%MAKE-POINTER-OFFSET DTP-LOCATIVE HASH-ARRAY
			(+ (ARRAY-DATA-OFFSET HASH-ARRAY)
			   (* (MOD ;; Pack the pointer and data type fields of the key
				   ;; into a fixnum.  Don't use %data-type because it
				   ;; throws away the high bits of fixnums and flonums.
				   (LOGXOR (%LOGDPB (%P-DATA-TYPE (LOCF KEY))
						    (BYTE 6 26.) 0)
					   (%POINTER KEY))
				   (// SIZE 8))
			      16.))))

;; Doesn't lock hash table, entries which are added or deleted during one of these
;; may or may not get seen.
(DEFMETHOD (:MAP-HASH EQ-HASH-TABLE) (FUNCTION &REST ARGS)
  (INHIBIT-GC-FLIPS
    ;; Rehash now so that deleting the current element won't disturb the mapping operation
    (IF ( GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
	(SEND SELF ':COPY-HASH-LOCKED HASH-ARRAY SIZE))
    (MULTIPLE-VALUE-BIND (LENGTH LOCATIVE)
	(WITHOUT-INTERRUPTS
	  ;; need to get length and loc atomically in case someone decides
	  ;; to add an element and possibly grow the table in the
	  ;; middle of this function setting up state.
	  (VALUES (ARRAY-LENGTH HASH-ARRAY)
		  (%MAKE-POINTER-OFFSET DTP-LOCATIVE HASH-ARRAY
					(ARRAY-DATA-OFFSET HASH-ARRAY))))
      (LOOP FOR I FROM 0 BELOW LENGTH
	    FOR LOC FIRST LOCATIVE THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE LOC 1)
	    DO (COND ((LDB-TEST (BYTE 1 3) I)	; (ODDP (// I 8))
		      (INCF I 7)
		      (SETQ LOC (%MAKE-POINTER-OFFSET DTP-LOCATIVE LOC 7)))
		     ((= (%P-DATA-TYPE LOC) DTP-NULL))
		     (T (LEXPR-FUNCALL FUNCTION (CAR LOC) (%P-CONTENTS-OFFSET LOC 8)
				       ARGS)))))))

;Returns 3 values an updated locative (or nil if no more elements), the key and the value
(DEFMETHOD (:NEXT-ELEMENT EQ-HASH-TABLE) (OLD-LOC)
  (DECLARE (VALUES NEW-LOCATIVE-OR-NIL KEY VALUE))
  (LET* ((ARRAY-LOC (%MAKE-POINTER-OFFSET DTP-LOCATIVE HASH-ARRAY
					  (ARRAY-DATA-OFFSET HASH-ARRAY)))
	 (START-INDEX
	   (COND ((NULL OLD-LOC)		;Initialize on first call
		  ;; Rehash now so that deleting the current element won't
		  ;; disturb the mapping operation
		  (WHEN ( GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
		    (SEND SELF ':COPY-HASH-LOCKED HASH-ARRAY SIZE)
		    ;; reset array-loc in case table grew as part of rehash
		    (SETQ ARRAY-LOC (%MAKE-POINTER-OFFSET DTP-LOCATIVE HASH-ARRAY
							  (ARRAY-DATA-OFFSET HASH-ARRAY))))
		  0)
		 (T (1+ (%POINTER-DIFFERENCE OLD-LOC ARRAY-LOC))))))
    (IF (OR (< START-INDEX 0) ( START-INDEX (ARRAY-LENGTH HASH-ARRAY)))
	(FERROR "Location given to :NEXT-ELEMENT is outside of the hash table."))
    (LOOP FOR I FROM START-INDEX BELOW (ARRAY-LENGTH HASH-ARRAY)
	  FOR LOC = (%MAKE-POINTER-OFFSET DTP-LOCATIVE ARRAY-LOC I)
	  DO (COND ((LDB-TEST (BYTE 1 3) I)	; (ODDP (// I 8))
		    (INCF I 7))
		   ((= (%P-DATA-TYPE LOC) DTP-NULL))
		   (T (RETURN (VALUES LOC (CAR LOC) (%P-CONTENTS-OFFSET LOC 8)))))
	  FINALLY (RETURN (VALUES NIL NIL NIL)))))

(DEFMETHOD (:DESCRIBE EQ-HASH-TABLE) ()
  (FORMAT T "~&~S is a hash-table with ~D entr~:@P out of a possible ~D (~D%)."
	  SELF FILLED-ELEMENTS SIZE (// (* FILLED-ELEMENTS 100.) SIZE))
  (IF ( GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
      (FORMAT T "~%Rehash is required due to GC."))
  (FORMAT T "~%The increase parameter is ~D." GROWTH-FACTOR)
  (IF (Y-OR-N-P "Do you want to see the block fullness distribution? ")
      (LOOP WITH NBLOCKS = (// SIZE 8)
	    AND INFO = (MAKE-ARRAY 9 ':INITIAL-VALUE 0)
	    FOR BLOCK-INDEX FROM 0 BELOW NBLOCKS
	    DO (LOOP WITH COUNT = 0
		     REPEAT 8
		     FOR LOC FIRST (%MAKE-POINTER-OFFSET DTP-LOCATIVE HASH-ARRAY
							 (+ (ARRAY-DATA-OFFSET HASH-ARRAY)
							    (* BLOCK-INDEX 16.)))
		         THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE LOC 1)
		     IF ( (%P-DATA-TYPE LOC) DTP-NULL)
		     DO (INCF COUNT)
		     FINALLY (WHEN (= COUNT 8)(PRINT BLOCK-INDEX))
			     (INCF (AREF INFO COUNT)))
	    FINALLY (LOOP FOR COUNT FROM 0 BELOW 9
			  DO (FORMAT T "~%Blocks with ~D elements: ~4D ~3D%"
				     COUNT (AREF INFO COUNT)
				     (// (* (AREF INFO COUNT) 100.) NBLOCKS)))))
  (IF (AND (NOT (ZEROP FILLED-ELEMENTS))
	   (Y-OR-N-P "Do you want to see the contents of the hash table? "))
      (IF (NOT (Y-OR-N-P "Do you want it sorted? "))
	  (SEND SELF ':MAP-HASH
		#'(LAMBDA (KEY VALUE) (FORMAT T "~% ~S  ~S" KEY VALUE)))
	  (LET ((L NIL))
	    (SEND SELF ':MAP-HASH #'(LAMBDA (KEY VALUE) (PUSH (LIST KEY VALUE) L)))
	    (SETQ L (SORTCAR L #'ALPHALESSP))
	    (FORMAT T "~:{~% ~S  ~S~}" L)))))

(DEFMETHOD (CLI::REHASH-IF-NECESSARY EQ-HASH-TABLE) ()
  (SYS:WITH-TABLE-LOCKED (SELF)
    (INHIBIT-GC-FLIPS
      (UNLESS (OR (= GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
		  (EQL GC-DYNAMIC-GENERATION-NUMBER %GC-DYNAMIC-GENERATION-NUMBER))
	(SEND SELF :COPY-HASH HASH-ARRAY SIZE)
	T))))

;;;

(DEFFLAVOR WITHOUT-INTERRUPTS-EQ-HASH-TABLE () (EQ-HASH-TABLE))

(DEFINE-EQ-HASH-TABLE-FLAVOR WITHOUT-INTERRUPTS-EQ-HASH-TABLE WITHOUT-INTERRUPTS)


;;; Note: These tables, replace the hash of a deleted object with -1. All
;;; searching code must skip over -1, and terminate the search only on a hash of NIL
(DEFFLAVOR EQUAL-HASH-TABLE
	((REHASH-THRESHOLD .8S0)
	 (GROWTH-FACTOR 1.3S0)
	 GC-GENERATION-NUMBER		;Value of %GC-GENERATION-NUMBER when rehashed, or
					;NIL if no keys' hash functions depend on address
	 GC-DYNAMIC-GENERATION-NUMBER)	;Value of %GC-DYNAMIC-GENERATION-NUMBER when
					;rehashed if no ephemeral keys; otherwise NIL
	(BASIC-HASH-TABLE)
  (:INITABLE-INSTANCE-VARIABLES REHASH-THRESHOLD GROWTH-FACTOR))

;;; 2-D manual defstruct
(DEFMACRO EQUAL-HASH-HASH (IDX &OPTIONAL (ARRAY 'HASH-ARRAY))
  `(AREF ,ARRAY ,IDX 0))

(DEFMACRO EQUAL-HASH-KEY (IDX &OPTIONAL (ARRAY 'HASH-ARRAY))
  `(AREF ,ARRAY ,IDX 1))

(DEFMACRO EQUAL-HASH-VALUE (IDX &OPTIONAL (ARRAY 'HASH-ARRAY))
  `(AREF ,ARRAY ,IDX 2))

(DEFMETHOD (:NEW-ARRAY EQUAL-HASH-TABLE) (NEW-SIZE)
  (LET* ((CHOSEN-SIZE (SEND SELF :CHOOSE-NEW-SIZE NEW-SIZE))
	 (NEW-HASH-ARRAY (MAKE-ARRAY (LIST CHOSEN-SIZE 3) :AREA AREA :TYPE 'ART-Q)))
    (WITHOUT-INTERRUPTS
      (SETQ HASH-ARRAY NEW-HASH-ARRAY
	    SIZE       CHOSEN-SIZE)))
  (SEND SELF ':CLEAR-HASH T))

(DEFMETHOD (:CHOOSE-NEW-SIZE EQUAL-HASH-TABLE) (SIZE-OFFER)
  (IF (EVENP SIZE-OFFER)
      (INCF SIZE-OFFER))
  (LOOP NAMED CHOOSE-SIZE
	FOR NEW-SIZE IN PKG-GOOD-SIZES
	IF ( NEW-SIZE SIZE-OFFER)
	RETURN NEW-SIZE
	FINALLY (LOOP FOR PRIME-SIZE FROM SIZE-OFFER BY 2
		      UNTIL (AND (NOT (ZEROP (\ PRIME-SIZE 3)))
				 (NOT (ZEROP (\ PRIME-SIZE 5)))
				 (NOT (ZEROP (\ PRIME-SIZE 7))))
		      FINALLY (RETURN-FROM CHOOSE-SIZE PRIME-SIZE))))

(DEFMETHOD (:GROW EQUAL-HASH-TABLE) ()
  (LET ((OLD-ARRAY HASH-ARRAY)
	(OLD-SIZE SIZE)
	;; See <850906022809.5.GREENWALD@TURKEY.SCRC.Symbolics.COM> in the bug-LispM archives
	(X GC-GENERATION-NUMBER)	;Preserve these through :CLEAR-HASH in :NEW-ARRAY
	(Y GC-DYNAMIC-GENERATION-NUMBER))
    (SEND SELF ':NEW-ARRAY (IF (NOT (FIXP GROWTH-FACTOR))
			       (FIX (* SIZE GROWTH-FACTOR))
			       (+ SIZE GROWTH-FACTOR)))
    (SETQ GC-GENERATION-NUMBER X GC-DYNAMIC-GENERATION-NUMBER Y)
    (SEND SELF ':COPY-HASH OLD-ARRAY OLD-SIZE)))

(DEFMETHOD (:COPY-HASH EQUAL-HASH-TABLE) (FROM-ARRAY FROM-SIZE)
  (COND ((AND GC-GENERATION-NUMBER
	      (EQ FROM-ARRAY HASH-ARRAY)
	      (EQL GC-DYNAMIC-GENERATION-NUMBER %GC-DYNAMIC-GENERATION-NUMBER))
	 ;; Just doing a rehash (not growing), only ephemeral flips have occurred,
	 ;; and none of the keys are ephemeral.  We don't need to bother rehashing.
	 (SETQ GC-GENERATION-NUMBER %GC-GENERATION-NUMBER))
	((EQ FROM-ARRAY HASH-ARRAY)
	 ;; Need to rehash because some keys have changed their addresses.
	 ;; No temporary array supplied by caller--make one.  Put it in the permanent
	 ;; area to decrease the chance of something else getting consed in the default
	 ;; area while we are rehashing, preventing RETURN-ARRAY from doing anything.
	 (LET ((TEMP-ARRAY (MAKE-ARRAY (* 2 FROM-SIZE) :AREA PERMANENT-STORAGE-AREA)))
	   (LOOP WITH J = 0
		 FOR I FROM 0 BELOW FROM-SIZE
		 AS HASH-CODE = (EQUAL-HASH-HASH I FROM-ARRAY)
		 WHEN (AND HASH-CODE (NOT (MINUSP HASH-CODE)))
		   DO (ASET (EQUAL-HASH-KEY I FROM-ARRAY) TEMP-ARRAY J)
		      (INCF J)
		      (ASET (EQUAL-HASH-VALUE I FROM-ARRAY) TEMP-ARRAY J)
		      (INCF J)
		 FINALLY (SEND SELF ':CLEAR-HASH)
			 (LOOP FOR I FROM 0 BELOW J BY 2
			       DO (SEND SELF ':PUT-HASH
					(AREF TEMP-ARRAY I) (AREF TEMP-ARRAY (1+ I))))
			 (RETURN-ARRAY (PROG1 TEMP-ARRAY (SETQ TEMP-ARRAY NIL))))))
	;; Caller supplied a temporary array, presumably to grow the table
	((OR (NULL GC-GENERATION-NUMBER)
	     (= GC-GENERATION-NUMBER %GC-GENERATION-NUMBER))
	 ;; None of the hash codes have changed.
	 (LET ((X GC-GENERATION-NUMBER)		;Preserve these through :CLEAR-HASH
	       (Y GC-DYNAMIC-GENERATION-NUMBER))
	   (SEND SELF ':CLEAR-HASH)
	   (SETQ GC-GENERATION-NUMBER X GC-DYNAMIC-GENERATION-NUMBER Y))
	 (LOOP FOR I BELOW FROM-SIZE
	       AS HASH = (EQUAL-HASH-HASH I FROM-ARRAY)
	       WHEN (AND HASH ( HASH 0))
		 DO (LOOP FOR INDEX = (\ HASH SIZE) THEN (\ (1+ INDEX) SIZE)
			  UNTIL (NULL (EQUAL-HASH-HASH INDEX))
			  FINALLY (SETF (EQUAL-HASH-HASH INDEX) HASH)
				  (SETF (EQUAL-HASH-KEY INDEX)
					(EQUAL-HASH-KEY I FROM-ARRAY))
				  (SETF (EQUAL-HASH-VALUE INDEX)
					(EQUAL-HASH-VALUE I FROM-ARRAY))
				  (INCF FILLED-ELEMENTS))))
	(T ;; Some of the hash values may have changed.
	 (SEND SELF ':CLEAR-HASH)
	 (LOOP FOR I FROM 0 BELOW FROM-SIZE
	       AS HASH = (EQUAL-HASH-HASH I FROM-ARRAY)
	       WHEN (AND HASH ( HASH 0))
	         DO (SEND SELF :PUT-HASH (EQUAL-HASH-KEY I FROM-ARRAY)
					 (EQUAL-HASH-VALUE I FROM-ARRAY))))))

(DEFMETHOD (CLI::REHASH-IF-NECESSARY EQUAL-HASH-TABLE) ()
  (SYS:WITH-TABLE-LOCKED (SELF)
    (INHIBIT-GC-FLIPS
      (UNLESS (OR (NULL GC-GENERATION-NUMBER)
		  (= GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
		  (EQL GC-DYNAMIC-GENERATION-NUMBER %GC-DYNAMIC-GENERATION-NUMBER))
	(SEND SELF :COPY-HASH HASH-ARRAY SIZE)
	T))))

(DEFPROP DEFINE-EQUAL-HASH-TABLE-FLAVOR "Hash table methods" SI:DEFINITION-TYPE-NAME)

(DEFMACRO DEFINE-EQUAL-HASH-TABLE-FLAVOR (FLAVOR EQUAL-FUN HASH-FUN
					  &OPTIONAL (LOCK-FUN 'LOCK-HASH-TABLE))
`(LOCAL-DECLARE ((SYS:FUNCTION-PARENT ,FLAVOR DEFINE-EQUAL-HASH-TABLE-FLAVOR))

(DEFINE-BASIC-HASH-TABLE-FLAVOR ,FLAVOR ,LOCK-FUN)

(DEFMETHOD (:GET-HASH ,FLAVOR) (KEY)
  (,LOCK-FUN
    (INHIBIT-GC-FLIPS
      (AND GC-GENERATION-NUMBER
	   ( GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
	   (SEND SELF ':COPY-HASH HASH-ARRAY SIZE))
      (LOOP WITH HASH = (ABS (,HASH-FUN KEY))
	    REPEAT SIZE
	    FOR INDEX = (\ HASH SIZE) THEN (\ (1+ INDEX) SIZE)
	    FOR HASH-CODE = (EQUAL-HASH-HASH INDEX)
	    UNTIL (NULL HASH-CODE)
	    IF (AND (= HASH HASH-CODE) (,EQUAL-FUN KEY (EQUAL-HASH-KEY INDEX)))
	      DO (RETURN (VALUES (EQUAL-HASH-VALUE INDEX) T))
	    FINALLY (RETURN (VALUES NIL NIL))))))

(DEFMETHOD (:PUT-HASH ,FLAVOR) (KEY VALUE &AUX FLAG)
  (,LOCK-FUN
    (INHIBIT-GC-FLIPS
      (AND GC-GENERATION-NUMBER
	   ( GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
	   (SEND SELF ':COPY-HASH HASH-ARRAY SIZE))
      (LOOP WITH HASH = (ABS (PROG1 (MULTIPLE-VALUE (NIL FLAG) (,HASH-FUN KEY))
				    (WHEN FLAG	;This key's hash depends on its address
				      (SETQ GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
				      (WHEN (NEQ FLAG ':DYNAMIC) ;Have to rehash on ephemeral
					(SETQ GC-DYNAMIC-GENERATION-NUMBER NIL))))) ;flips too
	    AND FIRST-FREE = NIL
	    FOR INDEX = (\ HASH SIZE) THEN (\ (1+ INDEX) SIZE)
	    FOR HASH-CODE = (EQUAL-HASH-HASH INDEX)
	    REPEAT SIZE
	    DO (COND ((NULL HASH-CODE)
		      (,(IF (EQ LOCK-FUN 'WITHOUT-INTERRUPTS) 'PROGN 'WITHOUT-INTERRUPTS)
		       (IF FIRST-FREE (SETQ INDEX FIRST-FREE))
		       (SETF (EQUAL-HASH-HASH INDEX) HASH)
		       (SETF (EQUAL-HASH-KEY INDEX) KEY)
		       (SETF (EQUAL-HASH-VALUE INDEX) VALUE)
		       (INCF FILLED-ELEMENTS))
		      (IF (> FILLED-ELEMENTS (* SIZE REHASH-THRESHOLD))
			  (SEND SELF ':GROW))
		      (RETURN))
		     ((AND (< HASH-CODE 0) (NULL FIRST-FREE)) (SETQ FIRST-FREE INDEX))
		     ((AND (= HASH HASH-CODE) (,EQUAL-FUN KEY (EQUAL-HASH-KEY INDEX)))
		      (SETF (EQUAL-HASH-VALUE INDEX) VALUE)
		      (RETURN)))
	    FINALLY (SEND SELF ':COPY-HASH HASH-ARRAY SIZE)
		    (SEND SELF ':PUT-HASH KEY VALUE))
      VALUE)))

(DEFMETHOD (:SWAP-HASH ,FLAVOR) (KEY VALUE &AUX FLAG)
  (,LOCK-FUN
   (INHIBIT-GC-FLIPS
     (AND GC-GENERATION-NUMBER
	  ( GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
	  (SEND SELF ':COPY-HASH HASH-ARRAY SIZE))
     (LOOP WITH HASH = (ABS (PROG1 (MULTIPLE-VALUE (NIL FLAG) (,HASH-FUN KEY))
				   (WHEN FLAG	;This key's hash depends on its address
				     (SETQ GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
				     (WHEN (NEQ FLAG ':DYNAMIC)	;Have to rehash on ephemeral
				       (SETQ GC-DYNAMIC-GENERATION-NUMBER NIL)))))	;flips too
	   AND FIRST-FREE = NIL
	   FOR INDEX = (\ HASH SIZE) THEN (\ (1+ INDEX) SIZE)
	   FOR HASH-CODE = (EQUAL-HASH-HASH INDEX)
	   REPEAT SIZE
	   DO (COND ((NULL HASH-CODE)
		     (,(IF (EQ LOCK-FUN 'WITHOUT-INTERRUPTS) 'PROGN 'WITHOUT-INTERRUPTS)
		      (IF FIRST-FREE (SETQ INDEX FIRST-FREE))
		      (SETF (EQUAL-HASH-HASH INDEX) HASH)
		      (SETF (EQUAL-HASH-KEY INDEX) KEY)
		      (SETF (EQUAL-HASH-VALUE INDEX) VALUE)
		      (INCF FILLED-ELEMENTS))
		     (IF (> FILLED-ELEMENTS (* SIZE REHASH-THRESHOLD))
			 (SEND SELF ':GROW))
		     (RETURN (VALUES NIL NIL)))
		    ((AND (< HASH-CODE 0) (NULL FIRST-FREE))(SETQ FIRST-FREE INDEX))
		    ((AND (= HASH HASH-CODE) (,EQUAL-FUN KEY (EQUAL-HASH-KEY INDEX)))
		     (RETURN (VALUES (PROG1 (EQUAL-HASH-VALUE INDEX)
					    (SETF (EQUAL-HASH-VALUE INDEX) VALUE))
				     T))))
	   FINALLY (SEND SELF ':COPY-HASH HASH-ARRAY SIZE)
		   (RETURN (SEND SELF ':SWAP-HASH KEY VALUE))))))

(DEFMETHOD (:MODIFY-HASH ,FLAVOR) (KEY FUNCTION &REST OTHER_ARGUMENTS &AUX FLAG)
  (,LOCK-FUN
    (INHIBIT-GC-FLIPS
      (AND GC-GENERATION-NUMBER
	   ( GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
	   (SEND SELF ':COPY-HASH HASH-ARRAY SIZE))
      (LOOP WITH HASH = (ABS (PROG1 (MULTIPLE-VALUE (NIL FLAG) (,HASH-FUN KEY))
				    (WHEN FLAG	;This key's hash depends on its address
				      (SETQ GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
				      (WHEN (NEQ FLAG ':DYNAMIC) ;Have to rehash on ephemeral
					(SETQ GC-DYNAMIC-GENERATION-NUMBER NIL))))) ;flips too
	    AND FIRST-FREE = NIL
	    FOR INDEX = (\ HASH SIZE) THEN (\ (1+ INDEX) SIZE)
	    FOR HASH-CODE = (EQUAL-HASH-HASH INDEX)
	    REPEAT SIZE
	    DO (COND ((NULL HASH-CODE)
		      (LET ((VALUE (LEXPR-FUNCALL FUNCTION KEY NIL NIL OTHER_ARGUMENTS)))
			(,(IF (EQ LOCK-FUN 'WITHOUT-INTERRUPTS) 'PROGN 'WITHOUT-INTERRUPTS)
			 (IF FIRST-FREE (SETQ INDEX FIRST-FREE))
			 (SETF (EQUAL-HASH-VALUE INDEX) VALUE)
			 (SETF (EQUAL-HASH-HASH INDEX) HASH)
			 (SETF (EQUAL-HASH-KEY INDEX) KEY)
			 (INCF FILLED-ELEMENTS))
			(WHEN (> FILLED-ELEMENTS (* SIZE REHASH-THRESHOLD))
			  (SEND SELF ':GROW))
			(RETURN VALUE)))
		     ((AND (< HASH-CODE 0) (NULL FIRST-FREE)) (SETQ FIRST-FREE INDEX))
		     ((AND (= HASH HASH-CODE) (,EQUAL-FUN KEY (EQUAL-HASH-KEY INDEX)))
		      (RETURN
			(SETF (EQUAL-HASH-VALUE INDEX)
			      (LEXPR-FUNCALL FUNCTION KEY (EQUAL-HASH-VALUE INDEX) T
					     OTHER_ARGUMENTS)))))
	    FINALLY (SEND SELF ':COPY-HASH HASH-ARRAY SIZE)
	    	    (RETURN (LEXPR-SEND SELF ':MODIFY-HASH KEY FUNCTION OTHER_ARGUMENTS))))))

(DEFMETHOD (:REM-HASH ,FLAVOR) (KEY)
  (,LOCK-FUN
    (INHIBIT-GC-FLIPS
      (AND GC-GENERATION-NUMBER
	   ( GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
	   (SEND SELF ':COPY-HASH HASH-ARRAY SIZE))
      (LOOP WITH HASH = (ABS (,HASH-FUN KEY))
	    FOR INDEX = (\ HASH SIZE) THEN (\ (1+ INDEX) SIZE)
	    FOR HASH-CODE = (EQUAL-HASH-HASH INDEX)
	    REPEAT SIZE
	    DO (COND ((NULL HASH-CODE)
		      (RETURN NIL))
		     ((AND (= HASH-CODE HASH)
			   (,EQUAL-FUN KEY (EQUAL-HASH-KEY INDEX)))
		      (,(IF (EQ LOCK-FUN 'WITHOUT-INTERRUPTS) 'PROGN 'WITHOUT-INTERRUPTS)
		       (SETF (EQUAL-HASH-HASH INDEX) -1)
		       (SETF (EQUAL-HASH-KEY INDEX) NIL)
		       (SETF (EQUAL-HASH-VALUE INDEX) NIL)
		       (DECF FILLED-ELEMENTS)
		       ;; If the guy following this one is NIL, can make this NIL too and 
		       ;; continue clobbering all consecutive previous -1s to NIL.
		       (IF (NULL (EQUAL-HASH-HASH (\ (1+ INDEX) SIZE)))
			   (LOOP FOR INDEX DOWNFROM INDEX
				 WHEN (< INDEX 0)
				   DO (SETQ INDEX (1- SIZE))
				 UNTIL (NEQ (EQUAL-HASH-HASH INDEX) -1)
				 DO (SETF (EQUAL-HASH-HASH INDEX) NIL))))
		      (RETURN T)))
	    FINALLY (SEND SELF ':COPY-HASH HASH-ARRAY SIZE)
	    	    (RETURN (SEND SELF ':REM-HASH KEY))))))

(DEFMETHOD (:CLEAR-HASH ,FLAVOR) (&OPTIONAL FORCE-P)
  (,LOCK-FUN
    ;; No keys yet depend on their addresses to compute their hash codes
    (SETQ GC-GENERATION-NUMBER NIL)
    ;; No keys yet are ephemeral
    (SETQ GC-DYNAMIC-GENERATION-NUMBER %GC-DYNAMIC-GENERATION-NUMBER)
    (COND ((OR FORCE-P (> FILLED-ELEMENTS 0))
	   (PAGE-IN-ARRAY HASH-ARRAY NIL NIL NIL)
	   (FILL-ARRAY HASH-ARRAY (* SIZE 3) NIL)
	   ;; I have no idea if this is right...
	   ;; DCP doesn't think so.  I think all places that send
	   ;; :clear-hash in this file use the array very soon
	   ;; thereafter, especially copy-hash.  I'm willing to bet most
	   ;; outside users send :clear-hash in order to start over, and
	   ;; not to just get rid of it.  Under these assumptions,
	   ;; page-out-array is the wrong thing. 
	   ;(PAGE-OUT-ARRAY HASH-ARRAY)
	   (SETQ FILLED-ELEMENTS 0))))
  SELF)

));end DEFMACRO DEFINE-EQUAL-HASH-TABLE-FLAVOR

(DEFINE-EQUAL-HASH-TABLE-FLAVOR EQUAL-HASH-TABLE EQUAL EQUAL-HASH)

(DEFMETHOD (:MAP-HASH EQUAL-HASH-TABLE) (FUNCTION &REST ARGS)
  (INHIBIT-GC-FLIPS
    ;; Rehash now so that deleting the current element won't disturb the mapping operation
    (AND GC-GENERATION-NUMBER
	 ( GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
	 (SEND SELF ':COPY-HASH-LOCKED HASH-ARRAY SIZE))
    (MULTIPLE-VALUE-BIND (SIZ ARRAY)
	(WITHOUT-INTERRUPTS
	  ;; see comment in (:METHOD EQ-HASH-TABLE :MAP-HASH)
	  (VALUES SIZE HASH-ARRAY))
      (LOOP FOR INDEX FROM 0 BELOW SIZ
	    FOR HASH = (EQUAL-HASH-HASH INDEX ARRAY)
	    IF (AND HASH ( HASH 0))
	      DO (LEXPR-FUNCALL FUNCTION (EQUAL-HASH-KEY INDEX ARRAY)
				(EQUAL-HASH-VALUE INDEX ARRAY) ARGS)))))

(DEFMETHOD (:NEXT-ELEMENT EQUAL-HASH-TABLE) (OLD-LOC)
  (COND ((NULL OLD-LOC)				;Initialize on first call
	 (SETQ OLD-LOC -1)
	 ;; Rehash now so that deleting the current element won't
	 ;; disturb the mapping operation
	 (AND GC-GENERATION-NUMBER
	      ( GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
	      (SEND SELF ':COPY-HASH-LOCKED HASH-ARRAY SIZE)))
	((OR (< OLD-LOC 0) ( OLD-LOC SIZE))
	 (FERROR "Location given to :NEXT-ELEMENT is outside of the hash table.")))
  (LOOP FOR INDEX FROM (1+ OLD-LOC) BELOW SIZE
	FOR HASH = (EQUAL-HASH-HASH INDEX)
	DO (IF (AND HASH ( HASH 0))
	       (RETURN (VALUES INDEX (EQUAL-HASH-KEY INDEX) (EQUAL-HASH-VALUE INDEX))))
	FINALLY (RETURN (VALUES NIL NIL NIL))))

(DEFMETHOD (:DESCRIBE EQUAL-HASH-TABLE) ()
  (FORMAT T "~&~S is a hash-table with ~D entr~:@P out of a possible ~D (~D%)."
	  SELF FILLED-ELEMENTS SIZE (// (* FILLED-ELEMENTS 100.) SIZE))
  (FORMAT T "~%Rehash threshold = ~2F, Growth factor = ~D"
	  REHASH-THRESHOLD GROWTH-FACTOR)
  (COND (GC-GENERATION-NUMBER
	 (FORMAT T "~%Some hash entries depend on the GC generation.")
	 (COND (( GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
		(FORMAT T "~%Rehash is required due to GC.~%")))))
  (IF (AND (> FILLED-ELEMENTS 0)
	   (Y-OR-N-P "Do you want to see distribution information? "))
      (LOOP WITH DIFFS = (MAKE-ARRAY SIZE ':INITIAL-VALUE 0)
	    FOR INDEX FROM 0 BELOW SIZE
	    FOR HASH-CODE = (EQUAL-HASH-HASH INDEX)
	    IF (AND HASH-CODE ( HASH-CODE 0))
	    DO (LET ((DIFF (- INDEX (\ HASH-CODE SIZE))))
		 (IF (MINUSP DIFF) (INCF DIFF SIZE))
		 (INCF (AREF DIFFS DIFF)))
	    FINALLY (LOOP FOR DIST BELOW SIZE
			  IF (> (AREF DIFFS DIST) 0)
			  DO (FORMAT T "~%~D entr~:@P off by ~D" (AREF DIFFS DIST) DIST))))
  (IF (AND (> FILLED-ELEMENTS 0)
	   (Y-OR-N-P "Do you want to see the contents of the hash table? "))
      (IF (NOT (Y-OR-N-P "Do you want it sorted? "))
	  (SEND SELF ':MAP-HASH #'(LAMBDA (KEY VALUE)
				       (FORMAT T "~% ~S  ~S" KEY VALUE)))
	  (LET ((L NIL))
	    (SEND SELF ':MAP-HASH #'(LAMBDA (KEY VALUE)
				      (PUSH (LIST KEY VALUE) L)))
	    (SETQ L (SORTCAR L #'ALPHALESSP))
	    (FORMAT T "~:{~% ~S  ~S~}" L)))))

;;;

(DEFFLAVOR WITHOUT-INTERRUPTS-EQUAL-HASH-TABLE () (EQUAL-HASH-TABLE))

(DEFINE-EQUAL-HASH-TABLE-FLAVOR WITHOUT-INTERRUPTS-EQUAL-HASH-TABLE
				EQUAL EQUAL-HASH WITHOUT-INTERRUPTS)

;;;

(DEFFLAVOR GENERIC-HASH-TABLE () (EQUAL-HASH-TABLE)
  (:REQUIRED-METHODS :EQUAL-ITEMS :HASH-ITEM)
  :ABSTRACT-FLAVOR)

(DEFMACRO GENERIC-HASH-EQUAL (X Y)
  `(SEND SELF ':EQUAL-ITEMS ,X ,Y))

(DEFMACRO GENERIC-HASH-HASH (KEY)
  `(SEND SELF ':HASH-ITEM ,KEY))

(DEFINE-EQUAL-HASH-TABLE-FLAVOR GENERIC-HASH-TABLE GENERIC-HASH-EQUAL GENERIC-HASH-HASH
				LOCK-HASH-TABLE)


(DEFFLAVOR CASE-SENSITIVE-EQUAL-HASH-TABLE () (EQUAL-HASH-TABLE))

(DEFSUBST CASE-SENSITIVE-EQUAL (X Y) (CL:EQUAL X Y))

(DEFINE-EQUAL-HASH-TABLE-FLAVOR
  CASE-SENSITIVE-EQUAL-HASH-TABLE CASE-SENSITIVE-EQUAL EQUAL-HASH LOCK-HASH-TABLE)

;;;

(DEFSUBST CASE-INSENSITIVE-EQUAL (X Y) (GLOBAL:EQUAL X Y))

(DEFFLAVOR CASE-INSENSITIVE-EQUAL-HASH-TABLE () (EQUAL-HASH-TABLE))

(DEFINE-EQUAL-HASH-TABLE-FLAVOR
  CASE-INSENSITIVE-EQUAL-HASH-TABLE CASE-INSENSITIVE-EQUAL EQUAL-HASH LOCK-HASH-TABLE)

;;; For LOOP hash-elements iteration path

(DEFMETHOD (WITH-TABLE-ELEMENTS-1 EQ-HASH-TABLE) (FUNCTION)
  (WITH-TABLE-LOCKED (SELF)
    ;; Rehash now so that deleting the current element won't
    ;; disturb the mapping operation
    (WHEN ( GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
      (SEND SELF ':COPY-HASH-LOCKED HASH-ARRAY SIZE))
    (LET ((ARRAY-LOC (%MAKE-POINTER-OFFSET DTP-LOCATIVE HASH-ARRAY
					   (ARRAY-DATA-OFFSET HASH-ARRAY)))
	  (INDEX 0)
	  (LIMIT (ARRAY-LENGTH HASH-ARRAY)))
      (LABELS ((GENERATOR ()
		 (DECLARE (DOWNWARD-FUNCTION))
		 (LOOP WHILE (< INDEX LIMIT)
		       AS LOC = (%MAKE-POINTER-OFFSET DTP-LOCATIVE ARRAY-LOC INDEX)
		       DO (COND ((LDB-TEST (BYTE 1 3) INDEX)	; (ODDP (// INDEX 8))
				 (INCF INDEX 8))
				((= (%P-DATA-TYPE LOC) DTP-NULL) (INCF INDEX))
				(T (INCF INDEX)
				   (RETURN (VALUES (%P-CONTENTS-OFFSET LOC 8) (CAR LOC)
						   #'GENERATOR)))))))
	(FUNCALL FUNCTION #'GENERATOR)))))

(DEFMETHOD (WITH-TABLE-ELEMENTS-1 EQUAL-HASH-TABLE) (FUNCTION)
  (WITH-TABLE-LOCKED (SELF)
    ;; Rehash now so that deleting the current element won't
    ;; disturb the mapping operation
    (AND GC-GENERATION-NUMBER
	 ( GC-GENERATION-NUMBER %GC-GENERATION-NUMBER)
	 (SEND SELF ':COPY-HASH-LOCKED HASH-ARRAY SIZE))
    (LET ((INDEX 0))
      (LABELS ((GENERATOR ()
		 (DECLARE (DOWNWARD-FUNCTION))
		 (LOOP WHILE (< INDEX SIZE)
		       AS HASH = (EQUAL-HASH-HASH INDEX)
		       DO (INCF INDEX)
			  (WHEN (AND HASH ( HASH 0))
			    (RETURN (VALUES (EQUAL-HASH-VALUE (1- INDEX))
					    (EQUAL-HASH-KEY (1- INDEX))
					    #'GENERATOR))))))
	(FUNCALL FUNCTION #'GENERATOR)))))

(COMMENT
(DEFVAR GOOD-DOUBLE-PRIMES '(103. 139. 181. 229. 283. 349. 433. 523. 619. 811.
			     1021. 1231. 1453. 1621. 1849. 2029. 2341. 2713. 2971.
			     3529. 4003. 4423. 5023. 5503. 6091. 6553. 7129. 7591.
			     8221. 8971. 9631. 10273. 14983. 16063. 17029. 18043.
			     19081. 20023. 22039. 24109. 25999. 28099. 30013.
			     33073. 36013. 39841.))

(DEFFLAVOR SELDOM-DELETE-HASH-TABLE (MODULUS GC-GENERATION-NUMBER (GROWTH-FACTOR 1.3))
	   (BASIC-HASH-TABLE)
  (:INITABLE-INSTANCE-VARIABLES GROWTH-FACTOR))

;;--- If anybody ever uses this, you should make this always return a fixnum.
(DEFMETHOD (:CHOOSE-NEW-SIZE SELDOM-DELETE-HASH-TABLE) (SIZE-OFFER)
  (LOOP FOR PRIME IN GOOD-DOUBLE-PRIMES
	IF (> PRIME SIZE-OFFER)
	RETURN PRIME))

(DEFMETHOD (:NEW-ARRAY SELDOM-DELETE-HASH-TABLE) (NEW-SIZE)
  (SETQ SIZE (SEND SELF ':CHOOSE-NEW-SIZE NEW-SIZE)
	MODULUS (- SIZE 2))
  (SETQ HASH-ARRAY (MAKE-ARRAY (* 2 SIZE) ':AREA AREA ':TYPE ART-Q))
  (SEND SELF ':CLEAR-HASH T))
)

(COMPILE-FLAVOR-METHODS EQ-HASH-TABLE WITHOUT-INTERRUPTS-EQ-HASH-TABLE EQUAL-HASH-TABLE
			WITHOUT-INTERRUPTS-EQUAL-HASH-TABLE GENERIC-HASH-TABLE
			CASE-SENSITIVE-EQUAL-HASH-TABLE CASE-INSENSITIVE-EQUAL-HASH-TABLE)

