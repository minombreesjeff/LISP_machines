;;; -*- Mode: LISP; Package: SYSTEM-INTERNALS; Base: 8; Lowercase: please; -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;   Life is a big numb.

;;; N.B.: before calling trim-bignum, be sure to SETQ any advancing
;;; or retreating pointers into the bignum to something valid.
;;; Otherwise, storage conventions are being violated and there are timing
;;; windows with the GC.  [This isn't true any longer, but it's still
;;; good practice.]

;;; *setz* is open coded in this file.  Because of the bin file format, that means you have
;;; to be able to negate -setz (a bignum) during bootstrapping.  That's all this function
;;; knows how to do.  It must not itself open code *setz*.
(defun-handler bootstrap-minus-bignum (x) 1 nil
  (declare (cl:notinline rot)
	   (safeguarded-function disable-reference-validation))
  (let ((setz (rot 1 -1)))			;can't constant fold yet!
    (unless (and (= (bignum-length x) 1)
		 (= (bignum-sign x) 0)
		 (= (bignum-ref x 0) setz))
      (ferror "Trying to negate something other than -setz during bootstrapping."))
    setz))

(defnumop - ((x bignum)) bootstrap-minus-bignum)

;;; These must be after the bootstrapping kludge above but before their values are used.

(defconstant *largest-fixnum* (lsh -1 -1))

(defconstant *setz* (rot 1 -1))


  ;;
;;;;;; Low level bignum stuff
  ;;

#+3600
(defun cons-bignum (sign length)
  "sign  {0,-1}.  Makes a new bignum, filling it in with the sign (all zeros or all ones)"
  #||
  (check-arg sign (or (equal sign 0) (equal sign -1)) "a fixnum zero or minus-one")
  (check-arg length (and (fixnump length)
			 (> length 0)
			 (< length 1_23.))
	     "a positive fixnum less than 2^23.")
  ||#
  (let ((pointer (%allocate-structure-block (1+ length) default-cons-area)))
    ;; flips now inhibited (see comment above SI:BUILD-ALLOCATE-FUNCTION)
    (%p-store-cdr-type-and-pointer pointer
				   %header-type-number dtp-header-i
				   (dpb %header-type-bignum %%header-subtype-field
					(dpb sign %%bignum-sign length)))
    (%block-store-cdr-and-contents (%make-pointer-offset dtp-locative pointer 1) length
				   0 sign 0)
    (prog1 (%make-pointer dtp-extended-number pointer)
	   (%frame-consing-done))))

#+IMACH
(defun cons-bignum (sign length)
  "sign  {0,-1}.  Makes a new bignum, filling it in with the sign (all zeros or all ones)"
  (let ((pointer (%allocate-structure-block default-cons-area (1+ length))))
    ;; flips now inhibited (see comment above SI:BUILD-ALLOCATE-FUNCTION)
    (%p-store-cdr-type-and-pointer pointer
				   %header-type-number dtp-header-i
				   (dpb %header-subtype-bignum %%header-subtype-field
					(dpb sign %%bignum-sign length)))
    (%block-store-cdr-and-contents (%make-pointer-offset dtp-locative pointer 1) length
				   0 sign 0)
    (%make-pointer dtp-bignum pointer)))

#||
(defun cons-bignum (sign length)
  "sign  {0,-1}.  Makes a new bignum, filling it in with the sign (all zeros or all ones)"
  (check-arg sign (or (equal sign 0) (equal sign -1)) "a fixnum zero or minus-one")
  (check-arg length (and (fixnump length)
			 (> length 0)
			 (< length 1_23.))
	     "a positive fixnum less than 2^23.")
  (let ((new (%make-structure dtp-extended-number dtp-header-i %header-type-number
			      (dpb %header-type-bignum %%header-subtype-field
				   (dpb sign %%bignum-sign length))
			      default-cons-area
			      (1+ length))))
    (%block-store-cdr-and-contents (%make-pointer-offset dtp-locative new 1) length
				   0 sign 0)
    new))
||#

#+3600
(defun cons-stack-bignum (sign length)
  "sign  {0,-1}.  Makes a new bignum, filling it in with the sign (all zeros or all ones)"
  (check-arg sign (or (equal sign 0) (equal sign -1)) "a fixnum zero or minus-one")
  (check-arg length (and (fixnump length)
			 (> length 0)
			 (< length 1_23.))
	     "a positive fixnum less than 2^23.")
  (let ((pointer (allocate-data-stack (1+ length))))
    (%p-store-cdr-type-and-pointer pointer
				   %header-type-number dtp-header-i
				   (dpb %header-type-bignum %%header-subtype-field
					(dpb sign %%bignum-sign length)))
    (%block-store-cdr-and-contents (%make-pointer-offset dtp-locative pointer 1) length
				   0 sign 0)
    (%make-pointer dtp-extended-number pointer)))

#+IMACH
(defun cons-stack-bignum (sign length)
  "sign  {0,-1}.  Makes a new bignum, filling it in with the sign (all zeros or all ones)"
  (check-arg sign (or (equal sign 0) (equal sign -1)) "a fixnum zero or minus-one")
  (check-arg length (and (fixnump length)
			 (> length 0)
			 (< length 1_23.))
	     "a positive fixnum less than 2^23.")
  (let ((pointer (allocate-data-stack (1+ length))))
    (%p-store-cdr-type-and-pointer pointer
				   %header-type-number dtp-header-i
				   (dpb %header-subtype-bignum %%header-subtype-field
					(dpb sign %%bignum-sign length)))
    (%block-store-cdr-and-contents (%make-pointer-offset dtp-locative pointer 1) length
				   0 sign 0)
    (%make-pointer dtp-bignum pointer)))

;Return the storage occupied by a bignum
(defun unmake-bignum (bignum)
  (%unmake-structure bignum (1+ (bignum-length (prog1 bignum (setq bignum nil))))))

#+3600
(defun %make-bignum-from-fixnum-components (sign n-components &rest components)
  (declare lt:(side-effects reducible))
  "sign  {0,-1}.  Components least significant first.  Internal; no legality checking."
  (let ((pointer (%allocate-structure-block (1+ n-components) default-cons-area)))
    ;; flips now inhibited (see comment above SI:BUILD-ALLOCATE-FUNCTION)
    (%p-store-cdr-type-and-pointer pointer
				   %header-type-number dtp-header-i
				   (dpb %header-type-bignum %%header-subtype-field
					(dpb sign %%bignum-sign n-components)))
    (loop with set-bignum = (get-bignum-advancing-pointer pointer 0)
	  repeat n-components
	  do (bignum-advance-set set-bignum (pop components)))
    (prog1 (%make-pointer dtp-extended-number pointer)
	   (%frame-consing-done))))

#+IMACH
(defun %make-bignum-from-fixnum-components (sign n-components &rest components)
  (declare lt:(side-effects reducible))
  "sign  {0,-1}.  Components least significant first.  Internal; no legality checking."
  (let ((pointer (%allocate-structure-block default-cons-area (1+ n-components))))
    ;; flips now inhibited (see comment above SI:BUILD-ALLOCATE-FUNCTION)
    (%p-store-cdr-type-and-pointer pointer
				   %header-type-number dtp-header-i
				   (dpb %header-subtype-bignum %%header-subtype-field
					(dpb sign %%bignum-sign n-components)))
    (loop with set-bignum = (get-bignum-advancing-pointer pointer 0)
	  repeat n-components
	  do (bignum-advance-set set-bignum (pop components)))
    (%make-pointer dtp-bignum pointer)))

;;; Legalize a bignum.  Legal bignums can be one word (not including
;;; header) long.  The highest order word is never an extension of the
;;; sign (0 for positive bignums, -1 for negative bignums).  If the
;;; "bignum" is one word and the high bit is the same as the sign bit,
;;; then the result is really a fixnum.  
(defun trim-bignum (bignum)
  (check-arg-type bignum :bignum)
  (loop with length = (bignum-length bignum)
	with sign = (bignum-sign bignum)
	with pointer = (get-bignum-pointer-retreating bignum (1- length))
	for new-length downfrom length
	as word = (bignum-ref-retreat pointer)
	until (or (= new-length 1)
		  ( word sign))
	finally
	  (setq pointer nil)
	  (cond ((and (= new-length 1)
		      (= sign (fixnum-sign word)))
		 (%unmake-structure (prog1 bignum (setq bignum nil)) (1+ length))
		 (return word))
		(T (when ( new-length length)
		     (let ((excess-pointer (%p-structure-offset bignum (1+ new-length))))
		       (without-interrupts
			 (setf (bignum-length bignum) new-length)
			 (%unmake-structure (prog1 excess-pointer (setq excess-pointer nil))
					    (- length new-length)))))
		   (return bignum)))))

;;; returns the number of 0s at the left of the leftmost 1.
(defun fixnum-jffo (f &aux (jffo 0) high)
  (if (zerop (setq high (ldb (byte 20 20) f))) (incf jffo 20) (setq f high))
  (if (zerop (setq high (ldb (byte 10 10) f))) (incf jffo 10) (setq f high))
  (if (zerop (setq high (ldb (byte 04 04) f))) (incf jffo 04) (setq f high))
  (if (zerop (setq high (ldb (byte 02 02) f))) (incf jffo 02) (setq f high))
  (if (zerop (setq high (ldb (byte 01 01) f))) (incf jffo 01) (setq f high))
  (if (zerop f) (incf jffo))
  jffo)

(defun integer-low-bits-as-fixnum (integer)
  (declare lt:(side-effects simple reducible))
  (if (fixnump integer)
      integer
      (bignum-ref integer 0)))

;;; Enough stuff to let us load up bignums.

(defun extend-fixnum-to-bignum (fixnum nbits)
  (let ((bignum (cons-bignum (fixnum-sign fixnum) (bits-bignum-digits (+ nbits 31.)))))
    (bignum-set bignum 0 fixnum)
    ;; cons-bignum already extended sign
    bignum))

(defun extend-bignum (x nbits)
  (let* ((x-length (bignum-length x))
	 (z (cons-bignum (bignum-sign x)
			    (max x-length (bits-bignum-digits (+ nbits 31.))))))
    (loop with ref-x = (get-bignum-advancing-pointer x 0)
	  with set-z = (get-bignum-advancing-pointer z 0)
	  repeat x-length
	  do (bignum-advance-set set-z (bignum-advance-ref ref-x)))
    ;; cons-bignum already extended sign
    z))

(defsubst fixnum-fixnum-deposit-byte-internal (value position size byte)
  (let ((.mask. (lsh -1 (- size 32.))))
    (logior (lsh (logand byte .mask.) position)
	    (logand value (lognot (lsh .mask. position))))))

(defun bignum-fixnum-deposit-byte-internal (y pp ss x)
  ;; fixnum gets sign extended if necessary.  Y is known to be big enough.
  (let* ((pp-digit (bits-bignum-digits pp))
	 (ref-y (get-bignum-advancing-pointer y pp-digit))
	 (set-y ref-y)
	 (bits-to-go ss)
	 (x-fragment x))
    ;; modify the lowest word
    (let* ((pp-bits (bits-bignum-residue pp))
	   (ss-fragment (- (min (+ pp-bits bits-to-go) 32.) pp-bits)))
      (bignum-advance-set set-y (fixnum-fixnum-deposit-byte-internal
				  (bignum-advance-ref ref-y)
				  pp-bits ss-fragment
				  x-fragment))
      (decf bits-to-go ss-fragment)
      (setq x-fragment (ash x-fragment (- ss-fragment))))
    ;; fill in middle portion
    (loop repeat (bits-bignum-digits bits-to-go)
	  do (bignum-advance-set set-y x-fragment)
	     (setq ref-y (%make-pointer-offset dtp-locative ref-y 1))
	     (decf bits-to-go *bignum-digit-size*)
	     (setq x-fragment (ash x-fragment (- *bignum-digit-size*))))
    ;; fill in high portion
    (when (> bits-to-go 0)
      (bignum-advance-set set-y (fixnum-fixnum-deposit-byte-internal
				  (bignum-advance-ref ref-y)
				  0 bits-to-go
				  x-fragment)))
    ;; trimming is not part of this function's contract
    y))

(defun bignum-bignum-deposit-byte-internal (y pp ss x)
  ;; X ges sign extended if necessary.  Y is known to be big enough.
  (let* ((pp-digit (bits-bignum-digits pp))
	 (ref-y (get-bignum-advancing-pointer y pp-digit))
	 (set-y ref-y)
	 (ref-x (get-bignum-advancing-pointer x 0))
	 (x-digits-remaining (bignum-length x))
	 (x-sign (bignum-sign x))
	 (bits-to-go ss)
	 x-fragment-low x-fragment-high
	 shift)
    ;; get the first digit from x
    (setq x-fragment-high (bignum-advance-ref ref-x))
    (decf x-digits-remaining)
    ;; modify the lowest word
    (let* ((pp-bits (bits-bignum-residue pp))
	   (ss-fragment (- (min (+ pp-bits bits-to-go) 32.) pp-bits)))
      (bignum-advance-set set-y (fixnum-fixnum-deposit-byte-internal
				  (bignum-advance-ref ref-y)
				  pp-bits ss-fragment
				  x-fragment-high))
      (decf bits-to-go ss-fragment))
    ;; compute shift for remaining right-aligned digits
    (setq shift (bits-bignum-residue pp))
    ;; fill in middle portion
    (loop repeat (bits-bignum-digits bits-to-go)
	  do (setq x-fragment-low  x-fragment-high
		   x-fragment-high (if ( x-digits-remaining 0)
				       x-sign
				     (prog1 (bignum-advance-ref ref-x)
					    (decf x-digits-remaining))))
	     (bignum-advance-set
	       set-y (%lshc-bignum-step x-fragment-low x-fragment-high shift))
	     (setq ref-y (%make-pointer-offset dtp-locative ref-y 1))
	     (decf bits-to-go 32.))
    ;; fill in the high portion
    (when (> bits-to-go 0)
      (setq x-fragment-low  x-fragment-high
	    x-fragment-high (if ( x-digits-remaining 0)
				x-sign
			      (prog1 (bignum-advance-ref ref-x)
				     (decf x-digits-remaining))))
      (bignum-advance-set set-y (fixnum-fixnum-deposit-byte-internal
				  (bignum-advance-ref ref-y)
				  0 bits-to-go
				  (%lshc-bignum-step x-fragment-low x-fragment-high
							  shift))))
    ;; trimming is not part of this function's contract
    y))

(defun fixnum-fixnum-deposit-byte (value position size byte)
  (check-arg-type value :fixnum)
  (check-arg-type position :fixnum)
  (check-arg-type size :fixnum)
  (check-arg-type byte :fixnum)
  (let* ((pp+ss (+ position size)))
    (cond ((= size 0) value)
	  (( pp+ss *bignum-digit-size*)
	   (let ((value-sign (fixnum-sign value))
		 (answer (fixnum-fixnum-deposit-byte-internal value position size byte)))
	     (if (= (fixnum-sign answer) value-sign)
		 answer
	       (%make-bignum-from-fixnum-components value-sign 1 answer))))
	  (T (trim-bignum
	       (bignum-fixnum-deposit-byte-internal
		 (extend-fixnum-to-bignum value pp+ss) position size byte))))))

(defun fixnum-bignum-deposit-byte (value position size byte)
  (check-arg-type value :fixnum)
  (check-arg-type position :fixnum)
  (check-arg-type size :fixnum)
  (check-arg-type byte :bignum)
  (let* ((pp+ss (+ position size)))
    (cond ((= size 0) value)
	  (( pp+ss 32.)
	   (let* ((value-sign (fixnum-sign value))
		  (answer (fixnum-fixnum-deposit-byte-internal
			    value position size (bignum-ref byte 0))))
	     (if (= value-sign (fixnum-sign answer))
		 answer
	       (%make-bignum-from-fixnum-components value-sign 1 answer))))
	  (( size 32.)
	   (trim-bignum
	     (bignum-fixnum-deposit-byte-internal
	       (extend-fixnum-to-bignum value pp+ss) position size (bignum-ref byte 0))))
	  (T (trim-bignum
	       (bignum-bignum-deposit-byte-internal
		 (extend-fixnum-to-bignum value pp+ss) position size byte))))))

(defun bignum-fixnum-deposit-byte (value position size byte)
  (check-arg-type value :bignum)
  (check-arg-type position :fixnum)
  (check-arg-type size :fixnum)
  (check-arg-type byte :fixnum)
  (cond ((= size 0) value)
	(T (trim-bignum
	     (bignum-fixnum-deposit-byte-internal
	       (extend-bignum value (+ position size)) position size byte)))))

(defun bignum-bignum-deposit-byte (value position size byte)
  (check-arg-type value :bignum)
  (check-arg-type position :fixnum)
  (check-arg-type size :fixnum)
  (check-arg-type byte :bignum)
  (let* ((pp+ss (+ position size)))
    (cond ((= size 0) value)
	  (( size *bignum-digit-size*)
	   (trim-bignum
	     (bignum-fixnum-deposit-byte-internal
	       (extend-bignum value pp+ss) position size (bignum-ref byte 0))))
	  (T (trim-bignum
	       (bignum-bignum-deposit-byte-internal
		 (extend-bignum value pp+ss) position size byte))))))

(defun-handler bignum-minus (x) 1 nil
  (declare (safeguarded-function disable-reference-validation))
  (let ((x-length (bignum-length x))
	(x-sign (bignum-sign x)))
    (if (and (= x-length 1)
	     (= x-sign 0)
	     (= (bignum-ref x 0) *setz*))
	*setz*
      (loop with y-sign = (other-bignum-sign x-sign)
	    with extra-length = (if (and (= x-sign -1)
					 (zerop (bignum-ref x (1- x-length))))
				    1 0)
	    with y = (cons-bignum y-sign (+ x-length extra-length))
	    with ref-x = (get-bignum-advancing-pointer x 0)
	    with set-y = (get-bignum-advancing-pointer y 0)
	    with last-digit
	    with borrow = 0
	    repeat x-length
	    do (bignum-advance-set set-y (multiple-value (last-digit borrow)
					   (%sub-bignum-step
					     0 (bignum-advance-ref ref-x) borrow)))
	    finally
	      (unless (zerop extra-length)
		(bignum-advance-set set-y (multiple-value (last-digit)
					    (%sub-bignum-step
					      0 x-sign borrow))))
	      (setq set-y nil)
	      (return (if (= last-digit y-sign)
			  (trim-bignum y)
			y))))))

(defnumop - ((x bignum)) bignum-minus)

;;;Frequently consed bignums:
(defconstant *minus-setz* (%make-bignum-from-fixnum-components 0 1 *setz*))

#+imach
(defnumop - ((x fixnum))
  (if (= x *setz*)
      *minus-setz*
      (halt)))


(defconstant *bignum-setz^2*
	     (%make-bignum-from-fixnum-components
	       0				;setz^2 is positive
	       2				;2 components
	       0				;has 0 for the low 32 bits
	       (lsh 1 (- 62. 32.))))		;has 62 bits of zeros, 32 of 
						;which are in the previous word

;;; this is a very wierd bignum!
(defconstant *bignum-2setz* (%make-bignum-from-fixnum-components -1 1 0))

;;; Normal arithmetic

(defnumop + ((f fixnum) (x bignum))
  (if (zerop f)
      x
    (let* ((x-length (bignum-length x))
	   (x-sign (bignum-sign x))
	   (f-sign (fixnum-sign f)))
      (if (= x-length 1)
	  (multiple-value-bind (sum next-digit)	;really carry
	      (%add-bignum-step f (bignum-ref x 0) 0)
	    (setq next-digit (+ f-sign x-sign next-digit))
	    (cond ((= (fixnum-sign sum) next-digit) sum)
		  ((= x-sign next-digit)
		     (%make-bignum-from-fixnum-components x-sign 1 sum))
		  (T (%make-bignum-from-fixnum-components x-sign 2 sum next-digit))))
	  (loop with extra-length = (cond (( x-sign f-sign) 0)
					  ((= (bignum-ref x (1- x-length))
					      (other-bignum-sign x-sign))
					   1)
					  (T 0))
		with z = (cons-bignum x-sign (+ x-length extra-length))
		with ref-x = (get-bignum-advancing-pointer x 0)
		with set-z = (get-bignum-advancing-pointer z 0)
		with last-digit
		with carry = 0
		for f-digit = f then f-sign
		repeat x-length
		do (bignum-advance-set set-z
				       (multiple-value (last-digit carry)
					 (%add-bignum-step f-digit
								(bignum-advance-ref ref-x)
								carry)))
		finally
		  (unless (zerop extra-length)
		    (bignum-advance-set set-z (multiple-value (last-digit)
						(%add-bignum-step f-digit
								       x-sign
								       carry))))
		  (setq set-z nil)
		  (return (if (= last-digit x-sign)
			      (trim-bignum z)
			    z)))))))

(defnumop - ((f fixnum) (x bignum))
  (let* ((x-length (bignum-length x))
	 (x-sign (bignum-sign x))
	 (f-sign (fixnum-sign f))
	 (z-sign (other-bignum-sign x-sign)))
    (if (= x-length 1)
	(multiple-value-bind (difference next-digit)	;really borrow
	    (%sub-bignum-step f (bignum-ref x 0) 0)
	  (setq next-digit (- f-sign x-sign next-digit))
	  (cond ((= (fixnum-sign difference) next-digit) difference)
		((= z-sign next-digit)
		   (%make-bignum-from-fixnum-components z-sign 1 difference))
		(T (%make-bignum-from-fixnum-components z-sign 2 difference next-digit))))
	(loop with extra-length = (cond ((= x-sign f-sign) 0)
					((= (bignum-ref x (1- x-length)) z-sign) 1)
					(T 0))
	      with z = (cons-bignum z-sign (+ x-length extra-length))
	      with ref-x = (get-bignum-advancing-pointer x 0)
	      with set-z = (get-bignum-advancing-pointer z 0)
	      with last-digit
	      with borrow = 0
	      for f-digit = f then f-sign
	      repeat x-length
	      do (bignum-advance-set set-z
				     (multiple-value (last-digit borrow)
				       (%sub-bignum-step f-digit
							      (bignum-advance-ref ref-x)
							      borrow)))
	      finally
		(unless (zerop extra-length)
		  (bignum-advance-set set-z (multiple-value (last-digit)
					      (%sub-bignum-step f-digit
								     x-sign
								     borrow))))
		(setq set-z nil)
		(return (if (= last-digit z-sign)
			    (trim-bignum z)
			  z))))))


(defnumop - ((x bignum) (f fixnum))
  (if (zerop f)
      x
    (let* ((x-length (bignum-length x))
	   (x-sign (bignum-sign x))
	   (f-sign (fixnum-sign f)))
      (if (= x-length 1)
	  (multiple-value-bind (difference next-digit)	;really borrow
	      (%sub-bignum-step (bignum-ref x 0) f 0)
	    (setq next-digit (- x-sign f-sign next-digit))
	    (cond ((= (fixnum-sign difference) next-digit) difference)
		  ((= x-sign next-digit)
		     (%make-bignum-from-fixnum-components x-sign 1 difference))
		  (T (%make-bignum-from-fixnum-components x-sign 2 difference next-digit))))
	  (loop with extra-length = (cond ((= x-sign f-sign) 0)
					  ((= (bignum-ref x (1- x-length)) f-sign) 1)
					  (T 0))
		with z = (cons-bignum x-sign (+ x-length extra-length))
		with ref-x = (get-bignum-advancing-pointer x 0)
		with set-z = (get-bignum-advancing-pointer z 0)
		with last-digit
		with borrow = 0
		for f-digit = f then f-sign
		repeat x-length
		do (bignum-advance-set set-z
				       (multiple-value (last-digit borrow)
					 (%sub-bignum-step (bignum-advance-ref ref-x)
								f-digit
								borrow)))
		finally
		  (unless (zerop extra-length)
		    (bignum-advance-set set-z
					(multiple-value (last-digit)
					  (%sub-bignum-step x-sign
								 f-digit
								 borrow))))
		  (setq set-z nil)
		  (return (if (= last-digit x-sign)
			      (trim-bignum z)
			    z)))))))

(defnumop + ((x bignum) (y bignum))
  (let ((x-length (bignum-length x))
	(y-length (bignum-length y)))
    (when (and (= x-length 1) (= y-length 1))
      (return-from +
	(multiple-value-bind (sum next-digit)	;really carry
	      (%add-bignum-step (bignum-ref x 0) (bignum-ref y 0) 0)
	    (setq next-digit (+ (bignum-sign x) (bignum-sign y) next-digit))
	    (let ((sign (fixnum-sign next-digit)))
	      (cond ((= (fixnum-sign sum) next-digit) sum)
		    ((= sign next-digit) (%make-bignum-from-fixnum-components sign 1 sum))
		    (T (%make-bignum-from-fixnum-components sign 2 sum next-digit)))))))
    (when (< x-length y-length)
      (swapf x y)
      (swapf x-length y-length))
    ;; x-length >= y-length
    (let* ((x-sign (bignum-sign x))
	   (y-sign (bignum-sign y))
	   (z-sign (and (or (= x-sign y-sign) ( x-length y-length)) x-sign))
	   (extra-length (cond (( x-sign y-sign) 0)
			       ((= x-length y-length)
				(multiple-value-bind (nil carry)
				    (%add-bignum-step (bignum-ref x (1- x-length))
							   (bignum-ref y (1- y-length))
							   (1+ x-sign))	;worst-case-carry
				  (logxor (- x-sign) carry)))
			       ((= (bignum-ref x (1- x-length))
				   (other-bignum-sign x-sign))
				1)
			       (T 0)))
	   (z-length (+ x-length extra-length))
	   (z (cons-bignum (or z-sign 0) z-length))
	   (ref-x (get-bignum-advancing-pointer x 0))
	   (ref-y (get-bignum-advancing-pointer y 0))
	   (set-z (get-bignum-advancing-pointer z 0))
	   last-digit
	   (carry 0))
      (loop repeat y-length
	    do (bignum-advance-set set-z
				   (multiple-value (last-digit carry)
				     (%add-bignum-step (bignum-advance-ref ref-x)
							    (bignum-advance-ref ref-y)
							    carry))))
      (loop repeat (- x-length y-length)
	    do (bignum-advance-set set-z
				   (multiple-value (last-digit carry)
				     (%add-bignum-step (bignum-advance-ref ref-x)
							    y-sign
							    carry))))
      (unless (zerop extra-length)
	(bignum-advance-set set-z
			    (multiple-value (last-digit carry)
			      (%add-bignum-step x-sign
						     y-sign
						     carry))))
      (when (not z-sign)			;same length, different sign.
	(setf (bignum-sign z) (setq z-sign (1- carry))))
      (setq set-z nil)
      (if (= (if (= z-length 1) (fixnum-sign last-digit) last-digit)
	     z-sign)
	  (trim-bignum z)
	  z))))

(defnumop - ((x bignum) (y bignum))
  (let* ((x-length (bignum-length x))
	 (y-length (bignum-length y))
	 (x-sign (bignum-sign x))
	 (y-sign (bignum-sign y))
	 (max-length x-length)
	 (min-length y-length))
    (when (and (= x-length 1) (= y-length 1))
      (return-from -
	(multiple-value-bind (difference next-digit)	;really borrow
	      (%sub-bignum-step (bignum-ref x 0) (bignum-ref y 0) 0)
	    (setq next-digit (- x-sign y-sign next-digit))
	    (if (= (fixnum-sign difference) next-digit) difference
		(let ((sign (fixnum-sign next-digit)))
		  (if (= sign next-digit)
		      (%make-bignum-from-fixnum-components sign 1 difference)
		      (%make-bignum-from-fixnum-components sign 2 difference next-digit)))))))
    (when (< max-length min-length)
      (swapf max-length min-length))
    (multiple-value-bind (z-sign extra-length)
	(cond ((= x-sign y-sign)
	       (values (cond ((> x-length y-length) x-sign)
			     ((> y-length x-length) (other-bignum-sign y-sign))
			     (T nil))
		       0))
	      ((= x-length y-length)
	       (multiple-value-bind (nil borrow)
		   (%sub-bignum-step (bignum-ref x (1- x-length))
					  (bignum-ref y (1- y-length))
					  (1+ y-sign))
		 (values x-sign (logxor (- y-sign) borrow))))
	      ((> x-length y-length)
	         (values x-sign (if (= (bignum-ref x (1- x-length)) y-sign) 1 0)))
	      (T (values x-sign (if (= (bignum-ref y (1- y-length)) x-sign) 1 0))))
      (let* ((z-length (+ max-length extra-length))
	     (z (cons-bignum (or z-sign 0) z-length))
	     (ref-x (get-bignum-advancing-pointer x 0))
	     (ref-y (get-bignum-advancing-pointer y 0))
	     (set-z (get-bignum-advancing-pointer z 0))
	     last-digit
	     (borrow 0))
	(loop repeat min-length
	      do (bignum-advance-set set-z
				     (multiple-value (last-digit borrow)
				       (%sub-bignum-step (bignum-advance-ref ref-x)
							      (bignum-advance-ref ref-y)
							      borrow))))
      (cond ((> x-length y-length)
	     (loop repeat (- max-length min-length)
		   do (bignum-advance-set set-z
					  (multiple-value (last-digit borrow)
					    (%sub-bignum-step (bignum-advance-ref ref-x)
								   y-sign
								   borrow)))))
	    ((> y-length x-length)
	     (loop repeat (- max-length min-length)
		   do (bignum-advance-set set-z
					  (multiple-value (last-digit borrow)
					    (%sub-bignum-step x-sign
								   (bignum-advance-ref ref-y)
								   borrow))))))
      (unless (zerop extra-length)
	(bignum-advance-set set-z
			    (multiple-value (last-digit borrow)
			      (%sub-bignum-step x-sign
						     y-sign
						     borrow))))
      (when (not z-sign)
	(setf (bignum-sign z) (setq z-sign (- borrow))))
      (setq set-z nil)
      (if (= (if (= z-length 1) (fixnum-sign last-digit) last-digit)
	     z-sign)
	  (trim-bignum z)
	  z)))))


(defnumop * ((f fixnum) (x bignum))		;++ tuning (slower than before)
  (cl:case f
    (0 0)
    (1 x)
    (-1 (bignum-minus x))
    (otherwise
      (let* ((x-length (bignum-length x))
	     (x-sign (bignum-sign x))
	     (f-sign (fixnum-sign f))
	     (multiplier (fixnum-minus-maybe f f-sign))
	     (z-sign (logxor x-sign f-sign))
	     (z-length (1+ x-length))
	     (z (cons-bignum z-sign z-length))
	     (ref-x (get-bignum-advancing-pointer x 0))
	     (set-z (get-bignum-advancing-pointer z 0))
	     (last-digit)
	     (high-part 0)
	     (carry 0)
	     (z-fixup-carry (- f-sign)))
	(if (zerop f-sign)
	    (dotimes (i x-length)
	      (declare (ignore i))
	      (bignum-advance-set set-z
		(multiple-value (last-digit z-fixup-carry)
		  (%add-bignum-step
		    (multiple-value (nil carry)
		      (%add-bignum-step
			high-part
			(multiple-value (nil high-part)
			  (%multiply-bignum-step
			    (bignum-advance-ref ref-x)
			    multiplier))
			carry))
		    0 z-fixup-carry))))
	    (dotimes (i x-length)
	      (declare (ignore i))
	      (bignum-advance-set set-z
		(multiple-value (last-digit z-fixup-carry)
		  (%add-bignum-step
		    (logxor (multiple-value (nil carry)
			      (%add-bignum-step
				high-part
				(multiple-value (nil high-part)
				  (%multiply-bignum-step
				    (bignum-advance-ref ref-x)
				    multiplier))
				carry))
			    f-sign)
		    0 z-fixup-carry)))))
	(bignum-advance-set set-z
	  (multiple-value (last-digit)
	    (%add-bignum-step
	      (logxor (%add-bignum-step
			high-part
			(%multiply-bignum-step
			  x-sign multiplier)
			carry)
		      f-sign)
	      0 z-fixup-carry)))
	(setq set-z nil)
	(if (= last-digit z-sign)
	    (trim-bignum z)
	    z)))))

#|| (

Complexity analysis of two possible bignum-bignum-* routines.  The inner
loop of both routines is a multiply step.  There are length1*length2 of
these in both cases.  All fixups are linear in either length1 or length2
and are therefore second order effect.

The method used by the old sign-magnitude bignum code was to accumulate
the product digits once.  This is done by keeping a running sum of 3
digits.  A multiply step multiplies the cross products that contribute
to the digit being constructed and accumulates the sum in the running
sum.  This is done with 
	(multiple-value (low mid high)
	  (multiply-bignum-digits (bignum-advance-ref ref-a)
				     (bignum-ref-retreat ref-b)
				     low mid high))
which turns into the following code:
	  2 BUILTIN %P-CONTENTS-INCREMENT-POINTER STACK FP|3    ;REF-A
	  3 BUILTIN %P-CONTENTS-POINTER-DECREMENT STACK FP|4    ;REF-B
	  4 BUILTIN %MULTIPLY-BIGNUM-STEP TO 2 
	  5 PUSH-NIL                    ;creating .LOW.(FP|5), .HIGH.(FP|6), .CARRY.(FP|7)
	  6 PUSH-LOCAL FP|0             ;LOW
	  7 PUSH-LOCAL FP|5             ;.LOW.
	 10 PUSH-IMMED 0
	 11 BUILTIN %ADD-BIGNUM-STEP TO 2 
	 12 POP-LOCAL FP|7              ;.CARRY.
	 13 PUSH-LOCAL FP|1             ;MID
	 14 PUSH-LOCAL FP|6             ;.HIGH.
	 15 PUSH-LOCAL FP|7             ;.CARRY.
	 16 BUILTIN %ADD-BIGNUM-STEP TO 2 
	 17 POP-LOCAL FP|7              ;.CARRY.
	 20 PUSH-LOCAL FP|2             ;HIGH
	 21 PUSH-LOCAL FP|7             ;.CARRY.
	 22 BUILTIN %32-BIT-PLUS STACK 
	 23 POP-LOCAL FP|2              ;HIGH
	 24 POP-LOCAL FP|1              ;MID
	 25 MOVEM-LOCAL FP|0            ;LOW
	 26 POP-N 4


Another possible way to multiply is to pull out a digit from one of the
numbers, and multiply it with the digits of the other number.  This is
how some of us were taught in school.  The result of the multiplication
gets added to the running product.  This is done with
	(bignum-advance-set set-z
			    (multiple-value (nil carry)
			      (%add-bignum-step
				high
				(bignum-advance-ref ref-z)
				(multiple-value (nil high)
				  (%multiply-bignum-step
				    (bignum-advance-ref ref-x)
				    y-digit)))))
	(setq high (%32-bit-plus high carry))
which turns into the following code:
	  2 PUSH-LOCAL FP|1             ;HIGH
	  3 BUILTIN %P-CONTENTS-INCREMENT-POINTER STACK FP|4    ;REF-Z
	  4 BUILTIN %P-CONTENTS-INCREMENT-POINTER STACK FP|3    ;REF-X
	  5 PUSH-LOCAL FP|2             ;Y-DIGIT
	  6 BUILTIN %MULTIPLY-BIGNUM-STEP TO 2 
	  7 POP-LOCAL FP|1              ;HIGH
	 10 BUILTIN %ADD-BIGNUM-STEP TO 2 
	 11 POP-LOCAL FP|0              ;CARRY
	 12 BUILTIN %P-STORE-CONTENTS-INCREMENT-POINTER IGNORE FP|5     ;SET-Z
	 13 PUSH-LOCAL FP|1             ;HIGH
	 14 PUSH-LOCAL FP|0             ;CARRY
	 15 BUILTIN %32-BIT-PLUS STACK 
	 16 POP-LOCAL FP|1              ;HIGH

For TMC5 machines this is 8 less instructions (2 ifu-emptry-traps, 8?
total cycles).  In terms of cycles, the following comparison applies:
	Case1	Case2	Delta	Cycles/inst	dCycles	Inst
	 2	 2	 0	5?		 0	%p-contents-xxx-pointer-yyy 
	 1	 1	 0	8?		 0	%multiply-bignum-step
	14	 7	 7	1		 7	push/pop/movem-local/immed
	 2	 1	 1	4		 4	%add-bignum-step
	 1	 1	 0	1		 0	%32-bit-plus
	 1	 0	 1	1?		 1?	POP-N
	 0	 1	-1	7?		-7?	%p-store-contents-xxx-pointer
						---
						 5?
In other words, the new case is faster by roughly 5 cycles or 11%.



) ||#


(comment 
  see discussion above
  defnumop * ((a bignum) (b bignum))		;++ possibly broken
  (ferror "This routine not fully debugged!")
  (let* ((length-a (bignum-length a))
	 (length-b (bignum-length b))
	 ;; -1_32. * -1_32. = 1_64., a 3 word bignum
	 (length-p (+ length-a length-b 1)))	;++
    (when (> length-a length-b)
      (swapf a b)
      (swapf length-a length-b))
    ;; length-b >= length-a
    (let* ((sign-a (bignum-sign a))
	   (sign-b (bignum-sign b))
	   (p (cons-bignum (logxor sign-a sign-b) length-p))
	   (set-pointer (get-bignum-advancing-pointer p 0))
	   (low 0) (mid 0) (high 0))
      (do ((n 0 (1+ n)))
	  (( n length-a))
	(loop with ref-a = (get-bignum-advancing-pointer a 0)
	      with ref-b = (get-bignum-pointer-retreating b n)
	      repeat (1+ n)
	      do (multiple-value (low mid high)
		   (multiply-bignum-digits (bignum-advance-ref ref-a)
					      (bignum-ref-retreat ref-b)
					      low mid high)))
	(bignum-advance-set set-pointer low)
	(setq low mid mid high high 0))
      (do ((n length-a (1+ n)))
	  (( n length-b))
	(loop with ref-a = (get-bignum-advancing-pointer a 0)
	      with ref-b = (get-bignum-pointer-retreating b n)
	      repeat length-a
	      do (multiple-value (low mid high)
		   (multiply-bignum-digits (bignum-advance-ref ref-a)
					      (bignum-ref-retreat ref-b)
					      low mid high)))
	(bignum-advance-set set-pointer low)
	(setq low mid mid high high 0))
      (do ((n 1 (1+ n))
	   (rep-count (1- length-a) (1- rep-count)))
	  (( n length-a))
	(loop with ref-a = (get-bignum-advancing-pointer a n)
	      with ref-b = (get-bignum-pointer-retreating b (1- length-b))
	      repeat rep-count
	      do (multiple-value (low mid high)
		   (multiply-bignum-digits (bignum-advance-ref ref-a)
					      (bignum-ref-retreat ref-b)
					      low mid high)))
	(bignum-advance-set set-pointer low)
	(setq low mid mid high high 0))
      (bignum-advance-set set-pointer low)
      ;; adjust for signs, if necessary
      (loop repeat 2
	    for sign = sign-a then sign-b
	    for bign = b then a
	    for offset = length-a then length-b
	    for rep-count = length-b then length-a
	    do (when (not (zerop sign))
		 (loop with ref-p = (get-bignum-advancing-pointer p offset)
		       with set-p = ref-p
		       with ref-big = (get-bignum-advancing-pointer bign 0)
		       with borrow = 0
		       repeat rep-count
		       do (bignum-advance-set set-p
					      (multiple-value (nil borrow)
						(%sub-bignum-step
						  (bignum-advance-ref ref-p)
						  (bignum-advance-ref ref-big)
						  borrow)))
		       finally
			 (bignum-advance-set set-p
					     (%sub-bignum-step
					       (bignum-advance-ref ref-p)
					       0
					       borrow)))))
      ;; If both signs are on...
      (incf (bignum-ref p (+ length-a length-b))
	    (logand (- sign-a) (- sign-b)))
      (setq set-pointer nil)
      (trim-bignum p))))

(defnumop * ((x bignum) (y bignum))
  (let* ((x-length (bignum-length x))
	 (y-length (bignum-length y)))
    (when (> x-length y-length)
      (swapf x y)
      (swapf x-length y-length))
    ;; x-length  y-length
    (let* ((x-sign (bignum-sign x))
	   (y-sign (bignum-sign y))
	   (z-sign (logxor x-sign y-sign))
	   (extra-length (if (and (not (zerop x-sign))
				  (not (zerop y-sign))
				  (zerop (bignum-ref x (1- x-length)))
				  (zerop (bignum-ref y (1- y-length))))
			     ;; possible -1_32. * 1_32. = 1_64, a 3 word bignum
			     1 0))
	   ;; digits of running product must be 0 for algorithm to work.
	   ;; Fake it by allocating a bignum with sign 0 and bashing
	   ;; the sign afterwards.  
	   (z (cons-bignum 0 (+ x-length y-length extra-length)))
	   last-digit)
      (setf (bignum-sign z) z-sign)
      (loop with borrow = 0
	    with ref-x = (get-bignum-advancing-pointer x 0)
	    with y-base = (get-bignum-advancing-pointer y 0)
	    for scan-z = (get-bignum-advancing-pointer z 0)
	      then (%make-pointer-offset dtp-locative scan-z 1)
	    repeat x-length
	    as x-digit = (bignum-advance-ref ref-x)
	    do (loop with carry = 0 with high
		     with ref-y = y-base
		     with ref-z = scan-z	;need copies for auto-increment
		     with set-z = scan-z
		     repeat y-length
		     do (bignum-advance-set set-z
					    (multiple-value (last-digit carry)
					      (%add-bignum-step
						(bignum-advance-ref ref-z)
						(multiple-value (nil high)
						  (%multiply-bignum-step
						    (bignum-advance-ref ref-y)
						    x-digit))
						carry)))
			;; carry + high never overflows into 33 bits:
		        ;; Worst case multiplication is (1- 1_32.)^2,
			;; which is (- 1_32. 2),,1.  Worst possible
			;; previous carry (induction works because first
			;; carry is 0) is (1- 1_32.).  This produces a
			;; final result of (1- 1_32.),,0.
			(setq carry (%32-bit-plus carry high))
		     finally
		       (bignum-advance-set set-z
					   (if (zerop y-sign)
					       (setq last-digit carry)
					     (multiple-value (last-digit borrow)
					       (%sub-bignum-step
						 carry	; @++ref-z always 0 here!!
						 x-digit
						 borrow)))))
	    finally
	      (unless (zerop x-sign)
		(loop with borrow2 = 0
		      with ref-y = y-base
		      with ref-z = scan-z
		      with set-z = scan-z
		      repeat y-length
		      do (bignum-advance-set set-z
					     (multiple-value (last-digit borrow2)
					       (%sub-bignum-step
						 (bignum-advance-ref ref-z)
						 (bignum-advance-ref ref-y)
						 borrow2)))
		      finally
			(unless (zerop extra-length)
			  ;; we can only get here if both bignums are
			  ;; negative.  The 1 (first arg to -) is the
			  ;; product of the signs (both -1).
			  (bignum-advance-set set-z (setq last-digit
							  (- 1 borrow borrow2)))))))
      (if (= last-digit z-sign)
	  (trim-bignum z)
	z))))


#+IMach
(defnumop // ((f1 fixnum) (f2 fixnum))
  ;; this can only be x = *setz*, y = -1
  (declare (ignore f1 f2))
  (- *setz*))

(defnumop // ((f fixnum) (b bignum))
  (if (and (= f *setz*)
	   (= (bignum-length b) 1)
	   (= (bignum-sign b) 0)
	   (= (bignum-ref b 0) f))
      -1
      0))

#+3600
(defnumop \ ((f fixnum) (b bignum))
  (if (and (= f *setz*)
	   (= (bignum-length b) 1)
	   (= (bignum-sign b) 0)
	   (= (bignum-ref b 0) f))
      0
      f))

#+3600
(defnumop mod ((f fixnum) (b bignum))
  (cond ((zerop f) 0)
	((not (minusp f))
	 (if (not (zerop (bignum-sign b))) (+ f b) f))
	((and (= f *setz*)
	      (= (bignum-length b) 1)
	      (= (bignum-sign b) 0)
	      (= (bignum-ref b 0) f))
	 0)
	(t (if (not (zerop (bignum-sign b))) f (+ f b)))))

#+imach
(defun-handler fixnum-bignum-truncate (u v) 2 nil
  (declare (safeguarded-function disable-reference-validation))
  (if (and (= u *setz*)
	   (= (bignum-length v) 1)
	   (= (bignum-sign v) 0)
	   (= (bignum-ref v 0) u))
      (values -1 0)
      (values 0 u)))

#+imach
(defun-handler fixnum-bignum-floor (u v) 2 nil
  (declare (safeguarded-function disable-reference-validation))
  (if (or (zerop u)
	  (= (fixnum-sign u) (bignum-sign v)))
      (values 0 u)
      (values -1 (+ u v))))

#+imach
(defun-handler fixnum-bignum-ceiling (u v) 2 nil
  (declare (safeguarded-function disable-reference-validation))
  (cond ((zerop u)
	 (values 0 0))
	((= (fixnum-sign u) (bignum-sign v))
	 (values 1 (- u v)))
	((and (= u *setz*)
	      (= (bignum-length v) 1)
	      ;; (= (bignum-sign v) 0) must be true
	      (= (bignum-ref v 0) u))		; u = *setz*
	 (values -1 0))
	(t
	 (values 0 u))))

#+imach
(defun-handler bignum-round (u v) 2 nil
  (declare (safeguarded-function disable-reference-validation))
  (multiple-value-bind (quotient remainder) (floor u v)
    (let ((twice-remainder (* remainder 2)))
      (if (or (if (minusp v) (< twice-remainder v)
		  (> twice-remainder v))
	      (and (= twice-remainder v) (oddp quotient)))
	  (values (1+ quotient) (- remainder v))
	  (values quotient remainder)))))

#+IMACH
(defnumop truncate ((x fixnum) (y bignum)) fixnum-bignum-truncate)

#+IMACH
(defnumop floor ((x fixnum) (y bignum)) fixnum-bignum-floor)

#+IMACH
(defnumop ceiling ((x fixnum) (y bignum)) fixnum-bignum-ceiling)

#+IMACH
(defnumop round ((x fixnum) (y bignum)) bignum-round)



(defnumop // ((x bignum) (f fixnum))
  (cond ((= f 1) x)
  	((= f -1) (bignum-minus x))
	(T
  	 (let* ((x-length (bignum-length x))
		(x-sign (bignum-sign x))
		(f-sign (fixnum-sign f))
  		(z-sign (logxor x-sign f-sign))
		(abs-f (fixnum-minus-maybe f f-sign)))
	   (if (= x-length 1)
	       (let ((big-part (bignum-ref x 0)))
		 (if (and (zerop big-part) (= f -2))
		     *minus-setz*
		   ;; Watch carefully, and don't blink!
		   (fixnum-minus-maybe (%divide-bignum-step
					 (fixnum-minus-maybe big-part x-sign)
					 (if (zerop big-part) 1 0)
					 abs-f)
				       z-sign)))
	     (loop with z = (cons-bignum z-sign x-length)
		   with ref-x = (get-bignum-pointer-retreating x (1- x-length))
		   with set-z = (get-bignum-pointer-retreating z (1- x-length))
		   with rem = 0
		   repeat x-length
		   do (bignum-set-retreat set-z
					  (multiple-value (nil rem)
					    (%divide-bignum-step
					      (bignum-ref-retreat ref-x x-sign)
					      rem
					      abs-f))
					  z-sign)
		   finally 
		     ;; do sign corrections
		     ;; If Z is negative, then what is stored in Z is the
		     ;; complement of ABS(Z) and we need to add 1 to make
		     ;; it two's complement.  Additionally, if X was
		     ;; negative, we were complementing it as we
		     ;; extracted, but 1 also needs to be added to it.
		     ;; The effect this has on the result is that 1 needs
		     ;; to be added to the remainder.  If the new
		     ;; remainder now equals the divisor (abs-f), then we
		     ;; have to add one to ABS(Z).  If Z is positive, this
		     ;; is adding 1, if negative, subtracting 1.
		     ;; Remembering that z-sign is 0 or -1, this all
		     ;; colapses into the following, which luckily is
		     ;; always 0 or 1, so we only have to propigate
		     ;; carries instead of having to worry about borrows.
		     (loop with carry = (if (and (not (zerop x-sign))
						 (= abs-f (%32-bit-plus rem 1)))
					    (1+ z-sign)
					  (- z-sign))
			   with ref-z = set-z
			   repeat x-length
			   until (zerop carry)
			   do (bignum-advance-set set-z
						  (multiple-value (nil carry)
						    (%add-bignum-step
						      (bignum-advance-ref ref-z)
						      0 carry))))
		     (setq set-z nil)
		     (return (trim-bignum z))))))))

#+3600
(defnumop \ ((x bignum) (f fixnum))
  (bignum-fixnum-rem-or-mod x f :rem))

#+3600
(defnumop mod ((x bignum) (f fixnum))
  (bignum-fixnum-rem-or-mod x f :mod))

(defun bignum-fixnum-rem-or-mod (x f dispatch)
  (loop with x-length = (bignum-length x)
	with x-sign = (bignum-sign x)
	with f-sign = (fixnum-sign f)
	with abs-f = (fixnum-minus-maybe f f-sign)
	with ref-x = (get-bignum-pointer-retreating x (1- x-length))
	with rem = 0
	repeat x-length
	do (multiple-value (nil rem)
	     (%divide-bignum-step (bignum-ref-retreat ref-x x-sign) rem abs-f))
	finally
	  (setq rem (%32-bit-difference rem x-sign))	;add 1 if x was negative
	  (if (= rem abs-f) (setq rem 0))	;in case of overflow
	  (return 
	    (selectq dispatch
	      (:rem (fixnum-minus-maybe rem x-sign))
	      (:mod (cond ((zerop rem) 0)
			  ((= x-sign f-sign) (fixnum-minus-maybe rem f-sign))
			  (T (fixnum-minus-maybe (%32-bit-difference abs-f rem) f-sign))))
	      (otherwise (ferror "Bad dispatch -- bignum implementation bug"))))))

(defun bignum-fixnum-divide&remainder (x f)
  (cond ((= f 1) (values x 0))
  	((= f -1) (values (bignum-minus x) 0))
	(T
  	 (let* ((x-length (bignum-length x))
		(x-sign (bignum-sign x))
		(f-sign (fixnum-sign f))
  		(z-sign (logxor x-sign f-sign))
		(abs-f (fixnum-minus-maybe f f-sign)))
	   (if (= x-length 1)
	       (let ((big-part (bignum-ref x 0)))
		 (if (and (zerop big-part) (= f -2))
		     (values *minus-setz* 0)
		     ;; Watch carefully, and don't blink!
		     (multiple-value-bind (q r)
			 (%divide-bignum-step (fixnum-minus-maybe big-part x-sign)
					      (if (zerop big-part) 1 0)
					      abs-f)
			 (values (fixnum-minus-maybe q z-sign)
				 (fixnum-minus-maybe r x-sign)))))
	     (loop with z = (cons-bignum z-sign x-length)
		   with ref-x = (get-bignum-pointer-retreating x (1- x-length))
		   with set-z = (get-bignum-pointer-retreating z (1- x-length))
		   with rem = 0
		   repeat x-length
		   do (bignum-set-retreat set-z
					  (multiple-value (nil rem)
					    (%divide-bignum-step
					      (bignum-ref-retreat ref-x x-sign)
					      rem
					      abs-f))
					  z-sign)
		   finally 
		     ;; do sign corrections
		     ;; If Z is negative, then what is stored in Z is the
		     ;; complement of ABS(Z) and we need to add 1 to make
		     ;; it two's complement.  Additionally, if X was
		     ;; negative, we were complementing it as we
		     ;; extracted, but 1 also needs to be added to it.
		     ;; The effect this has on the result is that 1 needs
		     ;; to be added to the remainder.  If the new
		     ;; remainder now equals the divisor (abs-f), then we
		     ;; have to add one to ABS(Z).  If Z is positive, this
		     ;; is adding 1, if negative, subtracting 1.
		     ;; Remembering that z-sign is 0 or -1, this all
		     ;; colapses into the following, which luckily is
		     ;; always 0 or 1, so we only have to propagate
		     ;; carries instead of having to worry about borrows.
		     (loop with carry = (if (and (not (zerop x-sign))
						 (= abs-f (setq rem (%32-bit-plus rem 1))))
					    (progn (setq rem 0)
						   (1+ z-sign))
					    (- z-sign))
			   with ref-z = set-z
			   repeat x-length
			   until (zerop carry)
			   do (bignum-advance-set set-z
						  (multiple-value (nil carry)
						    (%add-bignum-step
						      (bignum-advance-ref ref-z)
						      0 carry))))
		     (setq set-z nil)
		     (return (values z (fixnum-minus-maybe rem x-sign)))))))))

#+imach
(defun-handler bignum-fixnum-truncate (u v) 2 nil
  (declare (safeguarded-function disable-reference-validation))
  (multiple-value-bind (q r)
      (bignum-fixnum-divide&remainder u v)
    (values (if (typep q :bignum)
		(trim-bignum q)
		q)
	    r)))

#+imach
(defun-handler bignum-fixnum-floor (u v) 2 nil
  (declare (safeguarded-function disable-reference-validation))
  (multiple-value-bind (q r)
      (bignum-fixnum-divide&remainder u v)
    (if (zerop r)
	(values (if (typep q :bignum) (trim-bignum q) q) r)
	(let ((u-sign (bignum-sign u))
	      (v-sign (fixnum-sign v)))
	  (if (= u-sign v-sign)
	      (values (if (typep q :bignum) (trim-bignum q) q) r)
	      ;; We have to decrement q and add v to r.
	      (values
		(cond ((fixnump q) (1- q))
		      (t
		       ;; Q is a bignum.  bid&r leaves enough room to decrement in place
		       (loop with borrow = 1
			     with ref-q = (get-bignum-advancing-pointer q 0)
			     with set-q = ref-q
			     repeat (bignum-length q)
			     until (zerop borrow)
			     doing
			 (bignum-advance-set set-q (multiple-value (nil borrow)
						     (%sub-bignum-step
						       (bignum-advance-ref ref-q)
						       0 borrow))))
		       (trim-bignum q)))
		(+ r v)))))))

#+imach
(defun-handler bignum-fixnum-ceiling (u v) 2 nil
  (declare (safeguarded-function disable-reference-validation))
  (multiple-value-bind (q r)
      (bignum-fixnum-divide&remainder u v)
    (if (zerop r)
	(values (if (typep q :bignum) (trim-bignum q) q) r)
	(let ((u-sign (bignum-sign u))
	      (v-sign (fixnum-sign v)))
	  (if ( u-sign v-sign)
	      (values  (if (typep q :bignum) (trim-bignum q) q) r)
	      ;; We have to increment q and subtrace v to r.
	      (values
		(cond ((fixnump q) (1+ q))
		      (t
		       ;; Q is a bignum.  bid&r leaves enough room to increment in place
		       (loop with carry = 1
			     with ref-q = (get-bignum-advancing-pointer q 0)
			     with set-q = ref-q
			     repeat (bignum-length q)
			     until (zerop carry)
			     doing
			 (bignum-advance-set set-q (multiple-value (nil carry)
						     (%add-bignum-step
						       (bignum-advance-ref ref-q)
						       0 carry))))
		       (trim-bignum q)))
		(- r v)))))))


#+IMACH
(defnumop truncate ((x bignum) (y fixnum)) bignum-fixnum-truncate)

#+IMACH
(defnumop floor ((x bignum) (y fixnum)) bignum-fixnum-floor)

#+IMACH
(defnumop ceiling ((x bignum) (y fixnum)) bignum-fixnum-ceiling)

#+IMACH
(defnumop round ((x bignum) (y fixnum)) bignum-round)


(defnumop // ((u bignum) (v bignum))
  (if (bignum-magnitude-lessp u v)
      0
    (multiple-value-bind (q r)
	(bignum-bignum-division&remainder u v)
      (unmake-bignum r)
      (trim-bignum q))))

#+3600
(defnumop \ ((u bignum) (v bignum))
  (if (bignum-magnitude-lessp u v)
      u
    (multiple-value-bind (q r shift r-sign)
	(bignum-bignum-division&remainder u v t)
      (unmake-bignum q)
      (if (loop with ref-r = (get-bignum-advancing-pointer r 0)
		repeat (bignum-length r)
		always (zerop (bignum-advance-ref ref-r)))
	  (progn (unmake-bignum r) 0)
	(bignum-ash-down r r shift r-sign)
	(trim-bignum r)))))

#+3600
(defnumop mod ((u bignum) (v bignum))
  (let ((u-sign (bignum-sign u))
	(v-sign (bignum-sign v)))
    (if (bignum-magnitude-lessp u v)
	(if (= u-sign v-sign)
	    u
	  (+ u v))
      (multiple-value-bind (q r shift r-sign)
	  (bignum-bignum-division&remainder u v t)
	(unmake-bignum q)
	(if (loop with ref-r = (get-bignum-advancing-pointer r 0)
		  repeat (bignum-length r)
		  always (zerop (bignum-advance-ref ref-r)))
	    (progn (unmake-bignum r) 0)
	  (bignum-ash-down r r shift r-sign)
	  (when ( u-sign v-sign)
	    ;; bash r in place.  bbd&r makes sure it is big enough
	    (let* ((v-length (bignum-length v))
		   (r-length (bignum-length r))
		   (set-r (get-bignum-advancing-pointer r 0))
		   (carry 0))
	      (loop with ref-r = set-r
		    with ref-v = (get-bignum-advancing-pointer v 0)
		    repeat v-length
		    do (bignum-advance-set set-r (multiple-value (nil carry)
						   (%add-bignum-step
						     (bignum-advance-ref ref-r)
						     (bignum-advance-ref ref-v)
						     carry))))
	      (loop repeat (- r-length v-length)
		    do (bignum-advance-set set-r v-sign))
	      (setf (bignum-sign r) v-sign)))
	  (trim-bignum r))))))

(defun bignum-bignum-division&remainder (u v &optional cons-remainder-first)
  (declare (values quo rem rem-shift rem-sign))
  (let* ((u-length (bignum-length u))
  	 (v-length (bignum-length v))
  	 (u-sign (bignum-sign u))
  	 (v-sign (bignum-sign v))
	 (u-length (+ u-length (if (and (not (zerop u-sign))
					(loop with ref-u = (get-bignum-pointer-retreating
							     u (1- u-length))
					      repeat u-length
					      always (zerop (bignum-ref-retreat ref-u))))
				   1 0)))
  	 (q-length (- u-length v-length -1))
	 (q-sign (logxor u-sign v-sign))
  	 (r-consed-first (and cons-remainder-first (cons-bignum 0 (+ u-length 2))))
  	 (q (cons-bignum q-sign q-length))
  	 (r (or r-consed-first (cons-bignum 0 (+ u-length 2))))
  	 (shift (+ 32. (let ((high-digit (bignum-ref v (1- v-length) v-sign)))
			 ;; maybe add in carry
			 (when (and (not (zerop v-sign))
				    (or (= v-length 1)
					(loop with ref-v = (get-bignum-pointer-retreating
							     v (- v-length 2))
					      repeat (1- v-length)
					      always (zerop (bignum-ref-retreat ref-v)))))
			   (setq high-digit (%32-bit-plus high-digit 1)))
			 (if (zerop high-digit)
			     -1
			 (fixnum-jffo high-digit)))))
	 (old-v v)
  	 (v (cons-bignum 0 (1+ v-length))))
    (bignum-ash-up u r shift u-sign)
    (bignum-ash-up old-v v shift v-sign)
    (loop with v0 = (bignum-ref v v-length)
  	  with v1 = (bignum-ref v (1- v-length))
  	  with set-q = (get-bignum-pointer-retreating q (1- q-length))
  	  repeat q-length
  	  for scan-r-for-guess = (get-bignum-pointer-retreating r (1+ u-length))
	    then (%make-pointer-offset dtp-locative scan-r-for-guess -1)
  	  for scan-r-for-*-sub = (get-bignum-advancing-pointer r (1- q-length))
	    then (%make-pointer-offset dtp-locative scan-r-for-*-sub -1)
  	  as q-digit = (prog* ((ref-r scan-r-for-guess)
			       (r0 (bignum-ref-retreat ref-r))
			       (r1 (bignum-ref-retreat ref-r))
			       (r2 (bignum-ref-retreat ref-r))
			       q^ r^ r^-overflow)
			      (cond ((= v0 r0)
				     (setq q^ -1)
				     (multiple-value (r^ r^-overflow)
				       (%add-bignum-step r1 v0 0))
				     (unless (zerop r^-overflow) (return q^)))
				    (T (multiple-value (q^ r^)
					 (%divide-bignum-step r1 r0 v0))))
			      (multiple-value-bind (low high)
				  (%multiply-bignum-step v1 q^)
				(cond ((or (unsigned-< r^ high)
					   (and (= high r^)
						(unsigned-< r2 low)))
				       (setq q^ (%32-bit-difference q^ 1))
				       (multiple-value (r^ r^-overflow)
					 (%add-bignum-step r^ v0 0))
				       (unless (zerop r^-overflow) (return q^)))
				      (t (return q^))))
			      (multiple-value-bind (low high)
				  (%multiply-bignum-step v1 q^)
				(cond ((or (unsigned-< r^ high)
					   (and (= high r^)
						(unsigned-< r2 low)))
				       (setq q^ (%32-bit-difference q^ 1)))))
			      (return q^))
  	  do (loop with ref-v = (get-bignum-advancing-pointer v 0)
		   with ref-r = scan-r-for-*-sub
  		   with set-r = scan-r-for-*-sub
		   with borrow = 0
  		   with carry = 0 with high-part
  		   repeat (1+ v-length)
  		   do (bignum-advance-set set-r
					  (multiple-value (nil borrow)
					    (%sub-bignum-step
					      (bignum-advance-ref ref-r)
					      (multiple-value (nil carry)
						(%add-bignum-step
						  (multiple-value (nil high-part)
						    (%multiply-bignum-step
						      (bignum-advance-ref ref-v) q-digit))
						  0 carry))
					      borrow)))
		      (setq carry (%32-bit-plus carry high-part))
  		   finally
		     (bignum-advance-set set-r
					 (multiple-value (carry borrow)
					   (%sub-bignum-step (bignum-advance-ref ref-r)
								  carry
								  borrow)))
		     (cond ((not (zerop (%32-bit-plus carry borrow)))
			    (ferror "Bignum divide error after multiply-subtract."))
			   ((zerop carry)
			    (bignum-set-retreat set-q (logxor q-digit q-sign)))
			   (T
			    ;; add-back
			    (loop with ref-v = (get-bignum-advancing-pointer v 0)
				  with ref-r = scan-r-for-*-sub
				  with set-r = scan-r-for-*-sub
				  with carry = 0
				  repeat (1+ v-length)
				  do (bignum-advance-set set-r
							 (multiple-value (nil carry)
							   (%add-bignum-step
							     (bignum-advance-ref ref-r)
							     (bignum-advance-ref ref-v)
							     carry)))
				  finally
				    (unless (= carry 1)
				      (ferror "Bignum divide internal error after add-back."))
				    (bignum-advance-set set-r 0))
			    (bignum-set-retreat set-q (logxor (%32-bit-difference q-digit 1)
							      q-sign))))))
    (unless (zerop q-sign)
      ;; q is complemented.  Need to add 1
      (loop with carry = 1
	    with ref-q = (get-bignum-advancing-pointer q 0)
	    with set-q = ref-q
	    repeat q-length
	    until (zerop carry)
	    do (bignum-advance-set set-q
				   (multiple-value (nil carry)
				     (%add-bignum-step (bignum-advance-ref ref-q)
							    0 carry)))))
    (unmake-bignum v)
    (values q r shift u-sign)))

#+imach
(defun-handler bignum-bignum-truncate (u v) 2 nil
  (declare (safeguarded-function disable-reference-validation))
  (if (bignum-magnitude-lessp u v)
      (values 0 u)
      (multiple-value-bind (q r shift r-sign)
	  (bignum-bignum-division&remainder u v)
	(values
	  (trim-bignum q)
	  (if (loop with ref-r = (get-bignum-advancing-pointer r 0)
		    repeat (bignum-length r)
		    always (zerop (bignum-advance-ref ref-r)))
	      (progn (unmake-bignum r) 0)
	      (trim-bignum (bignum-ash-down r r shift r-sign)))))))

#+imach
(defun-handler bignum-bignum-floor (u v) 2 nil
  (declare (safeguarded-function disable-reference-validation))
  (let ((u-sign (bignum-sign u))
	(v-sign (bignum-sign v)))
    (if (bignum-magnitude-lessp u v)
	(if (= u-sign v-sign)
	    (values 0 u)
	    (values -1 (+ u v)))
	(multiple-value-bind (q r shift r-sign)
	    (bignum-bignum-division&remainder u v)
	  (if (loop with ref-r = (get-bignum-advancing-pointer r 0)
		    repeat (bignum-length r)
		    always (zerop (bignum-advance-ref ref-r)))
	      (values (trim-bignum q) 0)
	      (bignum-ash-down r r shift r-sign)
	      (when ( u-sign v-sign)
		;; Division truncated, so we want to decrement q by 1
		;; and add v from the remainder.  bbd&r returns a q
		;; which is big enough to decrement by 1 in place, and
		;; an r which is big enough to subtract -q from in
		;; place.
		(loop with borrow = 1
		      with ref-q = (get-bignum-advancing-pointer q 0)
		      with set-q = ref-q
		      repeat (bignum-length q)
		      until (zerop borrow)
		      doing
		  (bignum-advance-set set-q (multiple-value (nil borrow)
					      (%sub-bignum-step
						(bignum-advance-ref ref-q)
						0 borrow))))
		;; bash r in place.  bbd&r makes sure it is big enough
		(let* ((v-length (bignum-length v))
		       (r-length (bignum-length r))
		       (set-r (get-bignum-advancing-pointer r 0))
		       (carry 0))
		  (loop with ref-r = set-r
			with ref-v = (get-bignum-advancing-pointer v 0)
			repeat v-length
			do (bignum-advance-set set-r (multiple-value (nil carry)
						       (%add-bignum-step
							 (bignum-advance-ref ref-r)
							 (bignum-advance-ref ref-v)
							 carry))))
		  (loop repeat (- r-length v-length)
			do (bignum-advance-set set-r v-sign))
		  (setf (bignum-sign r) v-sign)))
	      (values (trim-bignum q)
		      (trim-bignum r)))))))

#+imach
(defun-handler bignum-bignum-ceiling (u v) 2 nil
  (declare (safeguarded-function disable-reference-validation))
  (let ((u-sign (bignum-sign u))
	(v-sign (bignum-sign v)))
    (if (bignum-magnitude-lessp u v)
	(if (= u-sign v-sign)
	    (values 1 (- u v))
	    (values 0 u))
	(multiple-value-bind (q r shift r-sign)
	    (bignum-bignum-division&remainder u v)
	  (if (loop with ref-r = (get-bignum-advancing-pointer r 0)
		    repeat (bignum-length r)
		    always (zerop (bignum-advance-ref ref-r)))
	      (values (trim-bignum q) 0)
	      (bignum-ash-down r r shift r-sign)
	      (when (= u-sign v-sign)
		;; Division truncated, so we want to increment q by 1 and subtract v from
		;; the remainder.  bbd&r returns a q which is big enough to increment by 1 in
		;; place, and an r which is big enough to add q to in place.
		(loop with carry = 1
		      with ref-q = (get-bignum-advancing-pointer q 0)
		      with set-q = ref-q
		      repeat (bignum-length q)
		      until (zerop carry)
		      doing
		  (bignum-advance-set set-q (multiple-value (nil carry)
					      (%add-bignum-step
						(bignum-advance-ref ref-q)
						0 carry))))
		;; bash r in place.  bbd&r makes sure it is big enough
		(let* ((v-length (bignum-length v))
		       (r-length (bignum-length r))
		       (set-r (get-bignum-advancing-pointer r 0))
		       (borrow 0))
		  (loop with ref-r = set-r
			with ref-v = (get-bignum-advancing-pointer v 0)
			repeat v-length
			do (bignum-advance-set set-r (multiple-value (nil borrow)
						       (%sub-bignum-step
							 (bignum-advance-ref ref-r)
							 (bignum-advance-ref ref-v)
							 borrow))))
		  (loop with r-sign = (logxor v-sign -1)
			repeat (- r-length v-length)
			do (bignum-advance-set set-r r-sign)
			finally
			  (setf (bignum-sign r) r-sign))))
	      (values (trim-bignum q)
		      (trim-bignum r)))))))


#+IMACH
(defnumop truncate ((x bignum) (y bignum)) bignum-bignum-truncate)

#+IMACH
(defnumop floor ((x bignum) (y bignum)) bignum-bignum-floor)

#+IMACH
(defnumop ceiling ((x bignum) (y bignum)) bignum-bignum-ceiling)

#+IMACH
(defnumop round ((x bignum) (y bignum)) bignum-round)

;;;Some of these guys could be making some decisions purely on the basis
;;;of an EQ test.  Is this worth it?

(defnumop = ((f fixnum) (b bignum))
  f	;ignored, also necessary to give this definition a body
  b	;also ignored
  nil)

(defnumop < ((x bignum) (f fixnum))
  f  ;ignored
  (negative-bignum-p x))

(defnumop < ((f fixnum) (x bignum))
  f  ;ignored
  (positive-bignum-p x))

(defnumop < ((x bignum) (y bignum))
  (if (positive-bignum-p x)
      (and (positive-bignum-p y)
	   (bignum-magnitude-same-sign-lessp x y))
      (or (positive-bignum-p y)
	  (bignum-magnitude-same-sign-lessp y x))))

(defun bignum-magnitude-lessp (a b)
  (let ((sign-a (bignum-sign a)))
    (cond ((= sign-a (bignum-sign b)) (bignum-magnitude-same-sign-lessp a b))
	  ((zerop sign-a) (bignum-magnitude-different-sign-lessp a b))
	  (T		  (bignum-magnitude-different-sign-lessp b a nil)))))

(defun bignum-magnitude-same-sign-lessp (a b)
  (let ((length-a (bignum-length a))
	(length-b (bignum-length b)))
    (or (< length-a length-b)
	(and (= length-a length-b)
	     (loop with ref-a = (get-bignum-pointer-retreating a (1- length-a))
		   with ref-b = (get-bignum-pointer-retreating b (1- length-b))
		   repeat length-a
		   do (multiple-value-bind (difference borrow)
			  (%sub-bignum-step (bignum-ref-retreat ref-a)
						 (bignum-ref-retreat ref-b)
						 0)
			(when (not (zerop difference))
			  #+ignore
			  (return (if (positive-bignum-p a)
				      (not (zerop borrow))
				    (zerop borrow)))
			  (return ( (bignum-sign a) (- borrow)))))
		   finally (return nil))))))	;magnitudes equal

(defun bignum-magnitude-different-sign-lessp (pos neg &optional (dont-invert t))
  (let* ((length-pos (bignum-length pos))
	 (length-neg (bignum-length neg)))
    (cond ((< length-pos length-neg) dont-invert)
	  ((= length-pos length-neg)
	   ;; hairy.
	   (loop with ref-pos = (get-bignum-pointer-retreating pos (1- length-pos))
		 with ref-neg = (get-bignum-pointer-retreating neg (1- length-neg))
		 for ref downfrom (1- length-pos) to 0
		 do (multiple-value-bind (difference borrow)
			(%sub-bignum-step (bignum-ref-retreat ref-pos)
					       (bignum-ref-retreat ref-neg -1)
					       0)
		      (cond ((zerop difference))	;keep looping
			    ((not (zerop borrow)) (return dont-invert))	;POS is smaller
			    ((= difference 1)
			     ;; either all the other digits are 0 and this
			     ;; digit is where the add-one-to-complement
			     ;; happened, or POS is larger than NEG.
			     (return (if (loop repeat ref
					       always (zerop (bignum-ref-retreat ref-pos))
					       always (zerop (bignum-ref-retreat ref-neg)))
					 NIL	;equal magnituds
				       (not dont-invert))))	;POS is larger
			    (T (return (not dont-invert)))))	;POS is larger
		 finally
		   ;; if we get here, pos = com(neg) = (-neg)-1
		   (return dont-invert)))	;POS is smaller
	  ((and (= length-pos (1+ length-neg))
		;; possible special case.  -1_(32n) .compare. 1_(32n)
		(= (bignum-ref pos (1- length-pos)) 1)
		(loop with ref-pos = (get-bignum-advancing-pointer pos 0)
		      with ref-neg = (get-bignum-advancing-pointer neg 0)
		      repeat length-neg
		      always (zerop (bignum-advance-ref ref-pos))
		      always (zerop (bignum-advance-ref ref-neg))))
	   nil)					;equal
	  (T (not dont-invert)))))

;(defnumop max ((f fixnum) (x bignum))
;  (if (positive-bignum-p x) x f))
;
;(defnumop min ((f fixnum) (x bignum))
;  (if (positive-bignum-p x) f x))
;
;(defnumop max ((a bignum) (b bignum))
;  (if (positive-bignum-p a)
;      (if (positive-bignum-p b)
;	  (if (bignum-magnitude-same-sign-lessp a b) b a)
;	  a)
;      (if (positive-bignum-p b)
;	  b
;	  (if (bignum-magnitude-same-sign-lessp a b) a b))))
;
;(defnumop min ((a bignum) (b bignum))
;  (if (positive-bignum-p a)
;      (if (positive-bignum-p b)
;	  (if (bignum-magnitude-same-sign-lessp a b) a b)
;	  b)
;      (if (positive-bignum-p b)
;	  a
;	  (if (bignum-magnitude-same-sign-lessp a b) b a))))

#+3600
(defnumop fix ((x bignum))
  (progn x))

(defnumop zerop ((x bignum))
  x	;ignored, also gives this function a body
  nil)

(defnumop plusp ((x bignum))
  (positive-bignum-p x))

(defnumop minusp ((x bignum))
  (negative-bignum-p x))

(defconstant %bignum-digit-excess-26-pos (- *bignum-digit-size* 26.))
(defconstant %%bignum-digit-high-26 (byte 26. %bignum-digit-excess-26-pos))
(defconstant %%bignum-digit-excess-26  (byte %bignum-digit-excess-26-pos 0))

(defun decode-bignum-high-bits (x)
  (declare (values (x-sign high-digit next-digit shift rest-zerop)))
  (let* ((x-sign (bignum-sign x))
	 (x-length (bignum-length x))
	 (ref-x (get-bignum-pointer-retreating x (1- x-length)))
	 (high-digit (bignum-ref-retreat ref-x x-sign))
	 (next-digit (if ( x-length 2)
			 (bignum-ref-retreat ref-x x-sign)
			 x-sign))
	 (third-digit (if ( x-length 3)
			  (bignum-ref-retreat ref-x x-sign)
			  x-sign))
	 ;; search from high-order words, which are more likely to be non-zero
	 (rest-zerop (loop repeat (- x-length 3)
			   always (zerop (bignum-ref-retreat ref-x)))))
    ;; adjust one's complement to two's complement, if necessary
    (when (and rest-zerop (minusp x-sign))
      (when (zerop (setq third-digit (%32-bit-plus third-digit 1)))
	(when (zerop (setq next-digit (%32-bit-plus next-digit 1)))
	  (when (zerop (setq high-digit (%32-bit-plus high-digit 1)))
	    ;; all high digits zero -- must be -(2^(32*x-length))
	    (return-from decode-bignum-high-bits
	      (values x-sign (rot 1 -1) 0 (1+ (* *bignum-digit-size* (- x-length 2))) t))))))
    (let ((jffo (fixnum-jffo high-digit)))
      (setq high-digit (%lshc-bignum-step next-digit high-digit jffo))
      (setq next-digit (%lshc-bignum-step third-digit next-digit jffo))
      (setq third-digit (lsh third-digit jffo))
      (values x-sign high-digit next-digit
	      (- (* *bignum-digit-size* (- x-length 2)) jffo)
	      (and rest-zerop (zerop third-digit))))))

#+3600
(defnumop float ((x bignum))
  ;; get just enough bits so the microcode can do the float
  ;; and get rounding and flag bits correct:
  ;; 24 fraction bits, a round bit, and a sticky bit
  ;; This was easier in the old bignum code, where it was
  ;; sign-magnitude, just like floating point.
  (multiple-value-bind (x-sign high-digit next-digit shift rest-zerop)
      (decode-bignum-high-bits x)
    (let ((fixnum (ldb %%bignum-digit-high-26 high-digit))
	  (shift (+ shift *bignum-digit-size* %bignum-digit-excess-26-pos)))
      (when (and (evenp fixnum)			;don't bother if sticky already on
		 (not (and rest-zerop
			   (zerop next-digit)
			   (zerop (ldb %%bignum-digit-excess-26 high-digit)))))
	(setq fixnum (logior fixnum 1)))
      ;; the out-of-range check will be done by ASH
      (ash (float (fixnum-minus-maybe fixnum x-sign)) shift))))

#+IMACH
(defun float-bignum (x)
  ;; get just enough bits so the microcode can do the float
  ;; and get rounding and flag bits correct:
  ;; 24 fraction bits, a round bit, and a sticky bit
  ;; This was easier in the old bignum code, where it was
  ;; sign-magnitude, just like floating point.
  (multiple-value-bind (x-sign high-digit next-digit shift rest-zerop)
      (decode-bignum-high-bits x)
    (let ((fixnum (ldb %%bignum-digit-high-26 high-digit))
	  (shift (+ shift *bignum-digit-size* %bignum-digit-excess-26-pos)))
      (when (and (evenp fixnum)			;don't bother if sticky already on
		 (not (and rest-zerop
			   (zerop next-digit)
			   (zerop (ldb %%bignum-digit-excess-26 high-digit)))))
	(setq fixnum (logior fixnum 1)))
      ;; the out-of-range check will be done by ASH
      (ash (float (fixnum-minus-maybe fixnum x-sign)) shift))))


(defun decode-float-of-bignum (bignum)
  ;; like (DECODE-FLOAT (FLOAT bignum)), but won't overflow
  (declare (values fraction exponent sign))
  (multiple-value-bind (x-sign high-digit next-digit shift rest-zerop)
      (decode-bignum-high-bits bignum)
    (let ((fixnum (ldb %%bignum-digit-high-26 high-digit))
	  (shift (+ shift *bignum-digit-size* %bignum-digit-excess-26-pos)))
      (when (and (evenp fixnum)			;don't bother if sticky already on
		 (not (and rest-zerop
			   (zerop next-digit)
			   (zerop (ldb %%bignum-digit-excess-26 high-digit)))))
	(setq fixnum (logior fixnum 1)))
      (multiple-value-bind (fraction exponent sign)
	  (decode-float (float (fixnum-minus-maybe fixnum x-sign)))
	(values fraction (+ exponent shift) sign)))))

;Convert a single-float to a bignum.  All exceptions already handled,
;and only left-shifting and no rounding can be involved, since the single-float
;fraction width is smaller than the fixnum width.
;Also, since the largest floating point number is ~3.4e38 which is 
#+3600
(defun convert-single-to-bignum-trap (f)
  (declare (safeguarded-function disable-reference-validation))
  (setq f (%fixnum f))
  (let* ((shift (- (ldb %%single-exponent f) %single-exponent-bias 23.))
	 (digit (bits-bignum-digits shift))
	 (residue (bits-bignum-residue shift))
	 (sign (- (ldb %%single-sign f)))
	 (fixnum (fixnum-minus-maybe (dpb 1 %%single-n-bit (ldb %%single-fraction f)) sign))
	 (high-digit (%lshc-bignum-step fixnum sign residue))
	 (next-digit (lsh fixnum residue))
	 (x-length (+ digit (if (= high-digit sign) 1 2))))
    (cond ((> x-length 1)
	   (let ((x (cons-bignum 0 x-length)))	;force all digits to 0
	     (setf (bignum-sign x) sign)			;correct sign bit
	     (unless (= high-digit sign)
	       (bignum-set x (1+ digit) high-digit))
	     (bignum-set x digit next-digit)
	     x))
	  ((= sign (fixnum-sign next-digit))
	   next-digit)
	  (T (%make-bignum-from-fixnum-components sign 1 next-digit)))))

;Convert a double-float to a bignum.  Exceptions already handled.
;The shift can be either to the left or to the right, depending on z-expt.
;If shifting to the right, microcode has already handled rounding, inexact result.
#+3600
(defun convert-double-to-bignum-trap (z-frac-hi z-frac-lo z-expt z-sign)
  (declare (safeguarded-function disable-reference-validation))
  (let* ((shift (- z-expt 3))			;Amount of left shift (-3 is for GRS bits)
	 (sign (- (ldb %%double-sign z-sign))))
    (when (minusp sign)
      (when (minusp shift)
	;; clear the low bits so the negate works correctly
	(setq z-frac-lo (logand z-frac-lo (lsh -1 (- shift)))))
      ;; negate the components
      (setq z-frac-hi
	    (%32-bit-plus (lognot z-frac-hi)
			  (if (zerop (setq z-frac-lo
					   (%32-bit-plus (lognot z-frac-lo) 1)))
			      1 0))))
    (multiple-value-bind (digit residue)
	(if (minusp shift)
	    (values -1 (+ *bignum-digit-size* shift))
	    (values (bits-bignum-digits shift) (bits-bignum-residue shift)))
      (let* ((high-digit (%lshc-bignum-step z-frac-hi sign residue))
	     (next-digit (%lshc-bignum-step z-frac-lo z-frac-hi residue))
	     (third-digit (lsh z-frac-lo residue))
	     (x-length (+ digit (if (= high-digit sign) 2 3))))
	(cond ((> x-length 1)
	       (let ((x (cons-bignum 0 x-length)))		;force all digits to 0
		 (setf (bignum-sign x) sign)		;correct sign bit
		 (unless (= high-digit sign)
		   (bignum-set x (+ digit 2) high-digit))
		 (bignum-set x (+ digit 1) next-digit)
		 (unless (minusp digit)
		   (bignum-set x digit third-digit))
		 x))
	      ((= sign (fixnum-sign next-digit))
	       next-digit)
	      (T (%make-bignum-from-fixnum-components sign 1 next-digit)))))))

#+3600
(defnumop oddp ((x bignum))
  (oddp (bignum-ref x 0)))

#+3600
(defnumop evenp ((x bignum))
  (evenp (bignum-ref x 0)))

(defun bignum-haulong (x)
  (let* ((x-length (bignum-length x))
	 (last-x (bignum-ref x (1- x-length))))
    (- (* x-length *bignum-digit-size*)
       (if (positive-bignum-p x)
	   (fixnum-jffo last-x)
	 (let* ((digit (lognot last-x))
		(fjffo1 (fixnum-jffo digit))
		(fjffo2 (fixnum-jffo (%32-bit-plus digit 1))))
	   (cond ((= fjffo1 fjffo2) fjffo1)
		 ((loop with ref-x = (get-bignum-pointer-retreating x (- x-length 2))
			repeat (1- x-length)
			always (zerop (bignum-ref-retreat ref-x)))
		  ;; not fjffo2.  Consider -1_64., in which last-x = 0,
		  ;; fjffo1 = 0 and fjffo2 = 31.
		  (1- fjffo1))
		 (T fjffo1)))))))

#+3600
(defnumop haulong ((x bignum)) bignum-haulong)


(defun-handler arithmetic-function-ash-fixnum-fixnum (f n) 1 nil
  (declare (safeguarded-function disable-reference-validation))
  (cond	((plusp n)		;Result must be a bignum
	 (cond ((zerop f) 0)
	       ((> n 1_29.) (ferror "ASH shifting much too far to the left"))
	       (T
		 (saving-registers (%register-alu-and-rotate-control)
		   (saving-rotate-latch 
		     (let* ((digit-shift (bits-bignum-digits n))
			    (bit-shift (bits-bignum-residue n))
			    (f-sign (fixnum-sign f))
			    (z (cons-bignum f-sign (bits-bignum-digits (+ n 32. 31.)))))
		       (when (minusp f)
			 (loop with set-z = (get-bignum-advancing-pointer z 0)
			       repeat digit-shift
			       do (bignum-advance-set set-z 0)))
		       (bignum-set z digit-shift
				   (%lshc-bignum-step 0 f bit-shift))
		       (unless (zerop bit-shift)
			 (bignum-set z (1+ digit-shift)
				     (%lshc-bignum-step f f-sign bit-shift)))
		       (trim-bignum z)))))))
	((= n *setz*)		;Gets here because of a hardware bug/misfeature
	 (fixnum-sign f))
	(t (ferror "Microcode failed to handle ASH when it should have"))))

;The microcode handles the easy cases of this in the real machine
(defnumop ash ((f fixnum) (n fixnum)) arithmetic-function-ash-fixnum-fixnum)

(defnumop ash ((x bignum) (n fixnum))
  (saving-registers (%register-alu-and-rotate-control)
    (saving-rotate-latch
      (cond ((= 0 n) x)
	    ((> n #+3600 1_29. #+imach 1_33.) (ferror "ASH shifting much too far to the left"))
	    ((> n 0)
	     (let ((z (cons-bignum (bignum-sign x)
				   (+ (bignum-length x) (bits-bignum-digits (+ n 31.))))))
	       (bignum-ash-up x z n)
	       (trim-bignum z)))
	    ((= n *setz*) (bignum-sign x))
	    (t
	      (let* ((n (- n))
		     (z-length (- (bignum-length x) (bits-bignum-digits n))))
		(if ( z-length 0)
		    (bignum-sign x)
		    (let ((z (cons-bignum (bignum-sign x) z-length)))
		      (bignum-ash-down x z n)
		      (trim-bignum z)))))))))

(defnumop ash ((x fixnum) (n bignum))
  (cond ((negative-bignum-p n) (fixnum-sign x))
	((zerop x) 0)
	(t (ferror "ASH shifting much too far to the left"))))

(defnumop ash ((x bignum) (n bignum))
  (cond ((negative-bignum-p n) (bignum-sign x))
	(t (ferror "ASH shifting much too far to the left"))))


#+3600
(defnumop abs ((x bignum))
  (if (positive-bignum-p x)
      x
    (bignum-minus x)))


;;;When the microcode traps out with an overflow it calls one of these
;;;two functions:

;;;In this case there was a one bit overflow.  The microcode simply
;;;hands us the overflowed fixnum answer.  We can infer what the 33rd
;;;bit was from the sign of that fixnum.
#+3600
(defun additive-fixnum-overflow (f)
  (declare (safeguarded-function disable-reference-validation))
  (check-arg-type f :fixnum)
  (if (= f 0)
      *bignum-2setz*
    ;; for extra speed, completely open code this common case
    (%make-extended-number (pointer 2 %header-type-bignum
				    (dpb (other-bignum-sign (fixnum-sign f))
					 %%bignum-sign 1))
      (%p-store-cdr-and-contents (1+ pointer) f 0))))

#+imach
(defun additive-fixnum-overflow (f)
  (check-arg-type f :fixnum)
  (if (= f 0)
      *bignum-2setz*
      ;; for extra speed, completely open code this common case
      (let ((pointer (%allocate-structure-block default-cons-area 2)))
	(prepare-for-block-write)
	(%block-write 1
		      (%set-tag
			(%logdpb %header-subtype-bignum %%header-subtype-field
				 (%logdpb (other-bignum-sign (fixnum-sign f))
					  %%bignum-sign
					  (%logdpb 1 %%bignum-length 0)))
			(dpb %header-type-number %%q-cdr-code-within-tag dtp-header-i)))
	(%block-write 1 f)
	(%make-pointer dtp-bignum pointer))))

#+IMACH
(defnumop + ((x fixnum) (y fixnum))
  (saving-registers (%register-bar-1)
    (with-system-block-registers (1)
      (block +
	;; We know that there is an overflow.  This means X and Y have the same sign, and X
	;; and Y are both non-zero.
	(let ((sum (%32-bit-plus x y))
	      (sign (%logldb (byte 1. 31.) x)))
	   (when (and (zerop sum)
		      (not (zerop sign)))
	      (return-from + *bignum-2setz*))
	   (let ((pointer (%allocate-structure-block default-cons-area 2)))
	      (prepare-for-block-write)
	      (%block-write 1
			    (%set-tag
			      (%logdpb %header-subtype-bignum %%header-subtype-field
				       (%logdpb sign %%bignum-sign
						(%logdpb 1 %%bignum-length 0)))
			      (dpb %header-type-number %%q-cdr-code-within-tag dtp-header-i)))
	      (%block-write 1 sum)
	      (%make-pointer dtp-bignum pointer)))))))

#+IMACH
(defnumop - ((x fixnum) (y fixnum))
  (saving-registers (%register-bar-1)
    (with-system-block-registers (1)
      (block -
	;; We know that there is an overflow, and the result has the sign of X. 
	(let ((difference (%32-bit-difference x y))
	      (sign (%logldb (byte 1. 31.) x)))
	   (when (and (zerop difference)
		      (not (zerop sign)))
	      (return-from - *bignum-2setz*))
	   (let ((pointer (%allocate-structure-block default-cons-area 2)))
	      (prepare-for-block-write)
	      (%block-write 1
			    (%set-tag
			      (%logdpb %header-subtype-bignum %%header-subtype-field
				       (%logdpb sign %%bignum-sign
						(%logdpb 1 %%bignum-length 0)))
			      (dpb %header-type-number %%q-cdr-code-within-tag dtp-header-i)))
	      (%block-write 1 difference)
	      (%make-pointer dtp-bignum pointer)))))))

;;;In this case we have a doubleword answer.  Our first argument is a
;;;positive fixnum containing the low 31 bits of the answer, the second
;;;contains the high 32.  The high word thus has the correct sign for
;;;the answer EXCEPT in the setz^2 case.  
;;; +++The microcode should be changed when bignums work to return 32
;;; bits in low and 32 in high.
(defun multiplicative-fixnum-overflow (low high)
  (declare (safeguarded-function disable-reference-validation))
  (check-arg-type low :fixnum)
  (check-arg-type high :fixnum)
  (if (= high *setz*)
      *bignum-setz^2*
    (let* ((low (%logdpb high (byte 1 31.) low))
	   (high (ash high -1))
	   (sign (fixnum-sign high)))
      (if (= high sign)
	  (%make-bignum-from-fixnum-components sign 1 low)
	  (%make-bignum-from-fixnum-components sign 2 low high)))))

#+IMACH
(defnumop * ((x fixnum) (y fixnum))
  (declare (sys:wired-function)
	   (sys:unsafeguarded-reference %make-bignum-from-fixnum-components))
  (multiple-value-bind (low high)
      (%multiply-double x y)
    (let ((sign (- (%logldb (byte 1. 31.) high)))
	  (low-sign (- (%logldb (byte 1. 31.) low))))
      ;; Turn off integer overflow sticky-bit
      (when (cli::fp-coprocessor-enabled-p)
	(setf (cli::%fpa-sticky-bits-register)
	      (dpb 0 cli::%%w3x64-integer-overflow-flag (cli::%fpa-sticky-bits-register)))
	(setf (cli::%fpa-fpex-divide-status-register) 0))
      (cond ((and (= sign high) (= sign low-sign))
	     ;; Shouldnt have overflowed, just return low
	     low)
	    ((= sign high)
	     ;; Single word bignum
	     (%make-bignum-from-fixnum-components sign 1 low))
	    (t
	     (%make-bignum-from-fixnum-components sign 2. low high))))))

;; Rev 4 Ivory has a bug (fixed in 4A) where it doesn't wait long enough
;; for the FPA to complete an integer multiply.  This trap handler,
;; which should only be installed on Rev 4 Ivories while the FPA is
;; enabled, compensates for the Ivory bug by first checking to see if
;; the FPA has an answer ready, in which case we return that answer.
;; Note D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")rev4-integer-multiply-trap-handler-check0, which installs and
;; deinstalls this trap handler as appropriate.  Note also that the
;; 1arithmetic-operation-times-fixnum-fixnum0 trap handler does work on
;; Rev 4, but it's slow.
#+(and IMach (not VLM))
(defun-handler arithmetic-operation-times-fixnum-fixnum-rev4 (x y) 1 *
  (declare (dbg:error-reporter))
  (declare (wired-function) (unsafeguarded-reference %make-bignum-from-fixnum-components))
  (let ((value (cli::%fpa-result fixnum-multiply)))
    (when (typep value ':single-float)
      (setq value (%fixnum value))
      (%return-kludge 1)))
  (multiple-value-bind (low high)
      (%multiply-double x y)
    (let ((sign (- (%logldb (byte 1. 31.) high)))
	  (low-sign (- (%logldb (byte 1. 31.) low))))
      ;; Turn off integer overflow sticky-bit
      (when (cli::fp-coprocessor-enabled-p)
	(setf (cli::%fpa-sticky-bits-register)
	      (dpb 0 cli::%%w3x64-integer-overflow-flag (cli::%fpa-sticky-bits-register)))
	(setf (cli::%fpa-fpex-divide-status-register) 0))
      (cond ((and (= sign high) (= sign low-sign))
	     ;; Shouldnt have overflowed, just return low
	     low)
	    ((= sign high)
	     ;; Single word bignum
	     (%make-bignum-from-fixnum-components sign 1 low))
	    (t
	     (%make-bignum-from-fixnum-components sign 2. low high))))))

;;; SI:REV4-INTEGER-MULTIPLY-TRAP-HANDLER-CHECK defined in SYS:I-SYS;FLOAT
#+(and IMach (not VLM))
(add-initialization "Reset Rev4 IMUL trap-handler"
		    '(rev4-integer-multiply-trap-handler-check nil)
		    '(:before-cold))


;;;Same as the A-Machine microcode function of the same name:
(defun bignum-to-array (bignum radix)
  (check-arg-type bignum :bignum "a bignum")
  (check-arg radix (and (fixnump radix) (> radix 1)) "a fixnum greater than 1")
  (let* ((bignum-length (1+ (bignum-length bignum)))
	 (array-length (1+ (// (* *bignum-digit-size* bignum-length)
			       (1- (haulong radix)))))
	 (array (make-array array-length))
	 (scratch (cons-bignum 0 bignum-length)))
    (loop with ref-b = (get-bignum-advancing-pointer bignum 0)
	  with set-s = (get-bignum-advancing-pointer scratch 0)
	  with xor-ref = (bignum-sign bignum)	;0 or -1
	  with carry = (- xor-ref)		;0 or 1
	  repeat (1- bignum-length)
	  do (bignum-advance-set set-s (multiple-value (nil carry)
					 (%add-bignum-step
					   (bignum-advance-ref ref-b xor-ref) 0 carry)))
	  finally (bignum-advance-set set-s carry))
    (loop named convert
	  for k upfrom 0 below array-length
	  do (loop with set-s = (get-bignum-pointer-retreating scratch (1- bignum-length))
		   with ref-s = set-s
		   with rem = 0
		   repeat bignum-length
		   do (bignum-set-retreat set-s (multiple-value (nil rem)
						  (%divide-bignum-step
						    (bignum-ref-retreat ref-s) rem radix)))
		   finally (setf (aref array k) rem))
	  do (loop with ref-s = (get-bignum-pointer-retreating scratch (1- bignum-length))
		   for i downfrom (1- bignum-length)
		   do (when (< i 0)
			(setq ref-s nil)
			(unmake-bignum scratch)
			(return-from convert (adjust-array-size array (1+ k))))
		      (when (not (zerop (bignum-ref-retreat ref-s)))
			(setq bignum-length (1+ i))
			(return)))
	  finally 
	    (ferror "Internal bignum-to-array error."))))

(defun bignum-ash-up (from to delta &optional (nsign 0))
  (check-arg-type from :bignum)
  (check-arg-type to   :bignum)
  (check-arg delta (and (fixnump delta) ( 0 delta) (< delta 1_28.))
	     "a fixnum between in the range [0,1_28.)")
  (when (eq from to)
    (ferror "Not allowed to ash-up a bignum in place"))
  (let* ((from-length (bignum-length from))
	 (from-sign (bignum-sign from))
	 (to-length (bignum-length to))
	 (to-sign (logxor from-sign nsign))
	 (delta-digits (bits-bignum-digits delta))
	 (delta-bits (bits-bignum-residue delta))
	 (set-to (get-bignum-advancing-pointer to 0))
	 (to-idx 0)
	 (to-fixup-carry (- nsign)))
    ;; first clear out the low bits
    (loop with to-idx-clear-limit = (min delta-digits to-length)
	  until ( to-idx to-idx-clear-limit)
	  do (bignum-advance-set set-to 0)
	     (incf to-idx))
    ;; Move the bits
    (loop with ref-from = (get-bignum-advancing-pointer from 0)
	  until ( to-idx to-length)
	  repeat from-length
	  for low-digit = 0 then high-digit
	  as high-digit = (bignum-advance-ref ref-from)
	  do (bignum-advance-set set-to
				 (multiple-value (nil to-fixup-carry)
				   (%add-bignum-step
				     (logxor (%lshc-bignum-step low-digit high-digit
								     delta-bits)
					     nsign)
				     0 to-fixup-carry)))
	     (incf to-idx)
	  finally
	    (unless ( to-idx to-length)
	      (bignum-advance-set set-to
				  (multiple-value (nil to-fixup-carry)
				    (%add-bignum-step
				      (logxor (%lshc-bignum-step high-digit from-sign
								      delta-bits)
					      nsign)
				      0 to-fixup-carry)))
	      (incf to-idx)))
    ;; fill in high part
    (loop until ( to-idx to-length)
	  do (bignum-advance-set set-to to-sign)
	     (incf to-idx))
    ;; and the sign
    (setf (bignum-sign to) to-sign))
  to)

(defun bignum-ash-down (from to delta &optional (nsign 0))
  "FROM and TO may be the same bignum"
  (check-arg-type from :bignum)
  (check-arg-type to   :bignum)
  (check-arg delta (and (fixnump delta) ( 0 delta) (< delta 1_28.))
	     "a fixnum between in the range [0,1_28.)")
  (loop with from-length = (bignum-length from)
	with from-sign = (bignum-sign from)
	with to-sign = (logxor from-sign nsign)
	with delta-digits = (bits-bignum-digits delta)
	with delta-bits = (- 32. (bits-bignum-residue delta))
	with set-to = (get-bignum-advancing-pointer to 0)
	with to-fixup-carry = (- nsign)
	with ref-from = (and (< delta-digits from-length)
			     (get-bignum-advancing-pointer from delta-digits))
	with from-idx = delta-digits
	repeat (bignum-length to)
	for low-digit = (if ( from-idx from-length)
			   from-sign
			 (prog1 (bignum-advance-ref ref-from)
				(incf from-idx)))
	  then high-digit
	as high-digit = (if ( from-idx from-length)
			    from-sign
			  (prog1 (bignum-advance-ref ref-from)
				 (incf from-idx)))
	do (bignum-advance-set set-to
			       (multiple-value (nil to-fixup-carry)
				 (%add-bignum-step
				   (logxor (%lshc-bignum-step low-digit high-digit
								   delta-bits)
					   nsign)
				   0 to-fixup-carry)))
	finally
	  (setf (bignum-sign to) to-sign))
  to)


;;; +++ does this belong in arithdefs?
(defvar boole-op-swap (make-array #o20 ':type 'art-4b))

(defun setup-boole-op-swap ()
  (dotimes (i #o20)
    ;; reflect about the diagonal; swap middle two bits
    (aset (dpb (ldb (byte 1 1) i) (byte 1 2) (dpb (ldb (byte 1 2) i) (byte 1 1) i))
	  boole-op-swap i)))

(setup-boole-op-swap)

(defun bignum-fixnum-boole (op b f)
  (fixnum-bignum-boole (aref boole-op-swap op) f b))

(defun fixnum-bignum-boole (op f y)
  (cl:ecase (ldb (byte 4 0) op)
    (#o00 0)
    (#o01 (fixnum-bignum-logand f y))
    (#o02 (fixnum-bignum-logand (lognot f) y))	;logandc1
    (#o03 y)					;arg2
    (#o04 (fixnum-bignum-logand f y t))	;logandc2
    (#o05 f)					;arg1
    (#o06 (fixnum-bignum-logxor f y))
    (#o07 (fixnum-bignum-logior f y))
    ;;; invert
    (#o10 (fixnum-bignum-logand (lognot f) y t))	;lognot(logior) = logandc1c2
    (#o11 (fixnum-bignum-logxor (lognot f) y))	;logeqv
    (#o12 (lognot f))				;lognot(arg1)
    (#o13 (fixnum-bignum-logior (lognot f) y))	;logiorc1, or, lognot(logandc2)
    (#o14 (fixnum-bignum-logxor -1 y))	;lognot(arg2)
    (#o15 (fixnum-bignum-logior f y t))	;logiorc2, or, lognot(logandc1)
    (#o16 (fixnum-bignum-logior (lognot f) y t))	;lognot(logand) = logiorc1c2
    (#o17 -1)))

(defun bignum-bignum-boole (op x y)
  (cl:ecase (ldb (byte 4 0) op)
    (#o00 0)
    (#o01 (bignum-bignum-logand x y))
    (#o02 (bignum-bignum-logand x y t nil))	;logandc1
    (#o03 y)					;arg2
    (#o04 (bignum-bignum-logand x y nil t))	;logandc2
    (#o05 x)					;arg1
    (#o06 (bignum-bignum-logxor x y))
    (#o07 (bignum-bignum-logior x y))
    ;;; invert
    (#o10 (bignum-bignum-logand x y t t))	;lognot(logior) = logandc1c2
    (#o11 (bignum-bignum-logxor x y t))	;logeqv
    (#o12 (fixnum-bignum-logxor -1 x))	;lognot(arg1)
    (#o13 (bignum-bignum-logior x y t nil))	;logiorc1, or, lognot(logandc2)
    (#o14 (fixnum-bignum-logxor -1 y))	;lognot(arg2)
    (#o15 (bignum-bignum-logior x y nil t))	;logiorc2, or, lognot(logandc1)
    (#o16 (bignum-bignum-logior x y t t))	;lognot(logand) = logiorc1c2
    (#o17 -1)))


(defun fixnum-bignum-logand (x y &optional invert-y &aux (y-xor (if invert-y -1 0)))  
  (cond ((= x -1) (if invert-y (fixnum-bignum-logxor -1 y) y))
	(( x 0) (logand x (bignum-ref y 0 y-xor)))
	(T (loop with y-length = (bignum-length y)
		 with b = (cons-bignum (logxor (bignum-sign y) y-xor) y-length)
		 with ref-y = (get-bignum-advancing-pointer y 0)
		 with set-b = (get-bignum-advancing-pointer b 0)
		 initially (bignum-advance-set set-b
					       (logand x (bignum-advance-ref ref-y y-xor)))
		 repeat (1- y-length)
		 do (bignum-advance-set set-b (bignum-advance-ref ref-y y-xor))
		 finally
		   ;; no trimming necessary because x is negative and the
		   ;; only thing logand can affect are the low 31 bits.
		   (return b)))))

#+3600
(defnumop logand ((x fixnum) (y bignum)) fixnum-bignum-logand)

#+IMACH
(defnumop logand ((x fixnum) (y bignum))
  (values (fixnum-bignum-logand x y)))

#+imach
(defnumop logtest ((x fixnum) (y bignum))
  (when (zerop x)
    (return-from logtest nil))
  (when (minusp x)
    ;; Y must have bits past bit 31 since it is a bignum.  X is all 1s past bit 31.
    (return-from logtest t))
  (cl:logtest x (bignum-ref y 0)))
    
(defun bignum-bignum-logand (x y &optional invert-x invert-y
				   &aux (x-xor (if invert-x -1 0))
					(y-xor (if invert-y -1 0)))
  (loop with x-sign = (logxor (bignum-sign x) x-xor)
	with y-sign = (logxor (bignum-sign y) y-xor)
	with x-length = (bignum-length x)
	with y-length = (bignum-length y)
	with common-length = (min x-length y-length)
	with z-sign = (logand x-sign y-sign)
	with z-length = (if (zerop x-sign)
			    (if (zerop y-sign)
				common-length
			      x-length)
			  (if (zerop y-sign)
			      y-length
			    (max x-length y-length)))
	with z = (cons-bignum z-sign z-length)
	with ref-x = (get-bignum-advancing-pointer x 0)
	with ref-y = (get-bignum-advancing-pointer y 0)
	with set-z = (get-bignum-advancing-pointer z 0)
        repeat common-length
	do (bignum-advance-set set-z (logand (bignum-advance-ref ref-x x-xor)
					     (bignum-advance-ref ref-y y-xor)))
	finally 
	  (when (> z-length common-length)
	    ;; at least one of the args is negative and there is
	    ;; copying to do.  If there is a positive arg, then it is
	    ;; the one to copy.  Else, find the longer of the two
	    ;; negative args and copy it.
	    (multiple-value-bind (ref-rest rest-xor)
		(cond ((zerop x-sign)        (values ref-x x-xor))
		      ((zerop y-sign)	      (values ref-y y-xor))
		      ((> x-length y-length) (values ref-x x-xor))
		      (T		      (values ref-y y-xor)))
	      (loop repeat (- z-length common-length)
		    do (bignum-advance-set set-z (bignum-advance-ref ref-rest rest-xor)))))
	  ;; There is no need to trim if there was copying involved, since
	  ;; the shorter number could not affect the trim condition
	  (setq set-z nil)
	  (return (if (> z-length common-length) z (trim-bignum z)))))

#+3600
(defnumop logand ((x bignum) (y bignum)) bignum-bignum-logand)

#+IMACH
(defnumop logand ((x bignum) (y bignum))
  (values (bignum-bignum-logand x y)))

#+imach
(defnumop logtest ((x bignum) (y bignum))
  (let ((x-sign (bignum-sign x))
	(y-sign (bignum-sign y))
	(x-length (bignum-length x))
	(y-length (bignum-length y)))
    (when (or (and (= x-sign -1)
		   (or (= y-sign -1)
		       (> y-length x-length)))
	      (and (= y-sign -1)
		   (> x-length y-length)))
      (return-from logtest t))
    (loop with common-length = (min x-length y-length)
	  with ref-x = (get-bignum-advancing-pointer x 0)
	  with ref-y = (get-bignum-advancing-pointer y 0)
	  repeat common-length
	  do
      (unless (zerop (logand (bignum-advance-ref ref-x)
			     (bignum-advance-ref ref-y)))
	(return-from logtest t)))))

(defun fixnum-bignum-logxor (x y) 1 nil
  (if (zerop x)
      y
    (loop with x-sign = (fixnum-sign x)
	  with y-sign = (bignum-sign y)
	  with y-length = (bignum-length y)
	  with z = (cons-bignum (logxor x-sign y-sign) y-length)
	  with ref-y = (get-bignum-advancing-pointer y 0)
	  with set-z = (get-bignum-advancing-pointer z 0)
	  initially (bignum-advance-set set-z (logxor x (bignum-advance-ref ref-y)))
	  repeat (1- y-length)
	  do (bignum-advance-set set-z (logxor x-sign (bignum-advance-ref ref-y)))
	  finally
	    ;; no trimming is necessary!!  If X is non-negative then the
	    ;; sign bit and trim-extension does not change.  If X is
	    ;; negative, then the sign bit AND the trim-extension are inverted.
	    (return z))))

#+3600
(defnumop logxor ((x fixnum) (y bignum)) fixnum-bignum-logxor)

#+imach
(defnumop logxor ((x fixnum) (y bignum))
  (fixnum-bignum-logxor x y))

(defun bignum-bignum-logxor (x y &optional invert-ans
				   &aux (ans-xor (if invert-ans -1 0)))
  (loop with x-sign = (bignum-sign x)
	with y-sign = (bignum-sign y)
	with x-length = (bignum-length x)
	with y-length = (bignum-length y)
	with common-length = (min x-length y-length)
	with z-sign = (logxor x-sign y-sign ans-xor)
	with z-length = (max x-length y-length)
	with z = (cons-bignum z-sign z-length)
	with ref-x = (get-bignum-advancing-pointer x 0)
	with ref-y = (get-bignum-advancing-pointer y 0)
	with set-z = (get-bignum-advancing-pointer z 0)
	repeat common-length
	do (bignum-advance-set set-z
			       (logxor (bignum-advance-ref ref-x)
				       (bignum-advance-ref ref-y))
			       ans-xor)
	finally (when (> z-length common-length)
		  ;; args of different length.  "copy" the remaining
		  ;; piece of the longer bignum, XORing with the sign
		  ;; extension of the shorter.
		  (multiple-value-bind (ref-rest xor-mask)
		      (if (> x-length y-length)
			  (values ref-x y-sign)
			(values ref-y x-sign))
		    (loop repeat (- z-length common-length)
			  do (bignum-advance-set
			       set-z (logxor xor-mask (bignum-advance-ref ref-rest))
			       ans-xor))))
		;; only need to trim if there was no copying
		(setq set-z nil)
		(return (if (> z-length common-length)
			    z
			  (trim-bignum z)))))

#+3600
(defnumop logxor ((x bignum) (y bignum)) bignum-bignum-logxor)

#+IMACH
(defnumop logxor ((x bignum) (y bignum))
  (values (bignum-bignum-logxor x y)))



(defun fixnum-bignum-logior (x y &optional invert-y &aux (y-xor (if invert-y -1 0)))
  (cond ((= x 0) (if invert-y (fixnum-bignum-logxor -1 y) y))
	((< x 0) (logior x (bignum-ref y 0 y-xor)))
	(T (loop with y-length = (bignum-length y)
		 with z = (cons-bignum (logxor (bignum-sign y) y-xor) y-length)
		 with ref-y = (get-bignum-advancing-pointer y 0)
		 with set-z = (get-bignum-advancing-pointer z 0)
		 initially (bignum-advance-set set-z
					       (logior x (bignum-advance-ref ref-y y-xor)))
		 repeat (1- y-length)
		 do (bignum-advance-set set-z (bignum-advance-ref ref-y y-xor))
		 finally
		   ;; no trimming necessary because x is positive and the
		   ;; only thing logior can affect are the low 31 bits.
		   (return z)))))

#+3600
(defnumop logior ((x fixnum) (y bignum)) fixnum-bignum-logior)

#+IMACH
(defnumop logior ((x fixnum) (y bignum))
  (values (fixnum-bignum-logior x y)))

(defun bignum-bignum-logior (x y &optional invert-x invert-y
				   &aux (x-xor (if invert-x -1 0))
					(y-xor (if invert-y -1 0)))
  (loop with x-sign = (logxor (bignum-sign x) x-xor)
	with y-sign = (logxor (bignum-sign y) y-xor)
	with x-length = (bignum-length x)
	with y-length = (bignum-length y)
	with common-length = (min x-length y-length)
	with z-sign = (logior x-sign y-sign)
	with z-length = (if (zerop x-sign)
			    (if (zerop y-sign)
				(max x-length y-length)
			      y-length)
			  (if (zerop y-sign)
			      x-length
			    common-length))
	with z = (cons-bignum z-sign z-length)
	with ref-x = (get-bignum-advancing-pointer x 0)
	with ref-y = (get-bignum-advancing-pointer y 0)
	with set-z = (get-bignum-advancing-pointer z 0)
	repeat common-length
	do (bignum-advance-set set-z (logior (bignum-advance-ref ref-x x-xor)
					     (bignum-advance-ref ref-y y-xor)))
	finally
	  (when (> z-length common-length)
	    ;; at least one of the args is positive and there is
	    ;; copying to do.  If there is a negative arg, then it is
	    ;; the one to copy.  Else, find the longer of the two
	    ;; positive args and copy it.
	    (multiple-value-bind (ref-rest rest-xor)
		(cond ((not (zerop x-sign))  (values ref-x x-xor))
		      ((not (zerop y-sign))  (values ref-y y-xor))
		      ((> x-length y-length) (values ref-x x-xor))
		      (T		      (values ref-y y-xor)))
	      (loop repeat (- z-length common-length)
		    do (bignum-advance-set set-z (bignum-advance-ref ref-rest rest-xor)))))
	  ;; There is no need to trim if there was copying involved, since
	  ;; the shorter number could not affect the trim condition
	  (setq set-z nil)
	  (return (if (> z-length common-length) z (trim-bignum z)))))

#+3600
(defnumop logior ((x bignum) (y bignum)) bignum-bignum-logior)

#+IMACH
(defnumop logior ((x bignum) (y bignum))
  (values (bignum-bignum-logior x y)))


;This is currently only reached from the LDB instruction when it encounters a bignum
(defun fixnum-load-byte-returning-bignum (x pp ss)
  (check-arg-type x :fixnum)
  (check-arg-type pp :fixnum)
  (check-arg-type ss :fixnum)
  (if (or (< ss 32.) ( x 0))			;just in case
      (logand (lognot (lsh -1 ss)) (ash x (- pp)))
    (loop with ss-digits = (bits-bignum-digits ss)
	  with ss-bits   = (bits-bignum-residue  ss)
	  with z = (cons-bignum 0 (if (zerop ss-bits) ss-digits (1+ ss-digits)))
	  with set-z = (get-bignum-advancing-pointer z 0)
	  initially (bignum-advance-set set-z (ash x (- pp)))
	  repeat (1- ss-digits)
	  do (bignum-advance-set set-z -1)
	  finally
	    (unless (zerop ss-bits)
	      (bignum-advance-set set-z (lognot (lsh -1 ss-bits))))
	    ;; no trimming necessary
	    (return z))))

(defun bignum-load-byte (x pp ss)
  (check-arg-type x :bignum)
  (check-arg-type pp :fixnum)
  (check-arg-type ss :fixnum)
  (let* ((pp-digits (bits-bignum-digits pp))
	 (pp-bits (bits-bignum-residue pp))
	 (shift (- *bignum-digit-size* pp-bits))
	 (x-sign (bignum-sign x))
	 (x-length (bignum-length x)))		
    (cond (( ss 32.)
	   (let* ((pp-dig0 pp-digits)
		  (pp-dig1 (1+ pp-digits))
		  (dig0 (if ( pp-dig0 x-length) x-sign (bignum-ref x pp-dig0)))
		  (dig1 (if ( pp-dig1 x-length) x-sign (bignum-ref x pp-dig1)))
		  (fixnum (logand (lognot (lsh -1 ss))
				  (%lshc-bignum-step dig0 dig1 shift))))
	     (if (minusp fixnum)
		 (%make-bignum-from-fixnum-components 0 1 fixnum)
		 fixnum)))
	  (T (loop with ss-digits = (bits-bignum-digits ss)
		   with ss-bits =   (bits-bignum-residue  ss)
		   with z = (cons-bignum 0 (if (zerop ss-bits) ss-digits (1+ ss-digits)))
		   with set-z = (get-bignum-advancing-pointer z 0)
		   with ref-x = (and (< pp-digits x-length)
				     (get-bignum-advancing-pointer x pp-digits))
		   for high-digit-index upfrom (1+ pp-digits)
		   for low-digit = (if ( high-digit-index x-length)	;note LE
				       (bignum-advance-ref ref-x)
				     x-sign)
		     then high-digit
		   as high-digit = (if (< high-digit-index x-length)	;note LT
				       (bignum-advance-ref ref-x)
				     x-sign)
		   as z-digit = (%lshc-bignum-step low-digit high-digit shift)
		   repeat ss-digits
		   do (bignum-advance-set set-z z-digit)
		   finally
		     (unless (zerop ss-bits)
		       (bignum-advance-set set-z (logand (lognot (lsh -1 ss-bits)) z-digit)))
		     (setq set-z nil)
		     (return (trim-bignum z)))))))

;;; GCD

;This is the "instruction" that compiled calls to GCD and \\ end up calling

;;; thanks to RWG for pointing out that this is much faster than the binary version
(defun \\-internal (x y)
  (check-arg-type x :fix)
  (check-arg-type y :fix)
  (loop until (zerop y)
	do (psetq x y
		  y (remainder x y))
	   ;; for various reasons, abs is a function
	finally (return (if (minusp x) (- x) x))))

;;; someday, DCP will finish debugging this
#+ignore
(defun new-\\-internal (x y)
  (check-arg-type x :fix)
  (check-arg-type y :fix)
  (setq x (abs x) y (abs y))
  (loop named gcd
	with shift = 0 do
    (when (zerop y) (return (ash x shift)))
    (when (= y 1)   (return (ash 1 shift)))
    (if (< x y) (psetq x y y x))
    ;; x  y
    (cond ((fixnump x)				;therefore y also fixnum
	   ;; special fixnum-fixnum loop
	   (loop do
	     (if (ldb-test (byte 1 0) x)	;oddp x
		 (if (ldb-test (byte 1 0) y)	;oddp y (x is odd)
		     (psetq x y y (- x y))
		   (setq y (ldb (byte 31. 1) y)))	;(ash y -1)
	       (if (ldb-test (byte 1 0) y)	;oddp y (x is even)
		   (setq x (ldb (byte 31. 1) x))	;(ash x -1)
		 (setq x (ldb (byte 31. 1) x)
		       y (ldb (byte 31. 1) y)
		       shift (1+ shift))))
	     (when (zerop y) (return-from gcd (ash x shift)))
	     (when (= y 1)   (return-from gcd (ash 1 shift)))
	     (if (< x y) (psetq x y y x))))
	  ;; x is a bignum
	  ((fixnump y) (psetq x y y (\ x y)))	;should be fixnum-fixnum now
	  ;; both bignum
	  (( (bignum-length x) (bignum-length y))
	   (psetq x y y (\ x y)))
	  ((> (lsh (bignum-ref x (1- (bignum-length x))) -2)
	      (bignum-ref y (1- (bignum-length y))))
	   (psetq x y y (\ x y)))
	  (T (if (oddp x)
		 (if (oddp y)
		     (psetq x y y (- x y))
		   (setq y (ash y -1)))
	       (if (oddp y)
		   (setq x (ash x -1))
		 (setq x (ash x -1)
		       y (ash y -1)
		       shift (1+ shift))))))))
	       


;;;Define print-bignum to be this if bignum printing is screwing up.
(defun simple-print-bignum (x stream &optional ignore)
  (printing-random-object (x stream :typep)
    (loop initially (format stream "~[+~;-~]" (- (bignum-sign x)))
	  for idx downfrom (1- (bignum-length x)) to 0
	  as last-digit = 0 then digit
	  as digit = (bignum-ref x idx)
	  do (cl:case (\ idx 3)
	       (0 (format t "~O~10,'0O"
			  (dpb last-digit (byte 1 2)
			       (ldb (byte 02. 30.) digit))
			  (ldb (byte 30. 0) digit)))
	       (1 (format t "~O~10,'0O"
			  (dpb last-digit (byte 2 1)
			       (ldb (byte 01. 31.) digit))
			  (ldb (byte 30. 1) digit)))
	       (2 (format t "~10,'0O" (ldb (byte 30. 02.) digit)))))))

;;; Bignum/float arithmetic
(defmacro def-simple-bignum-float-ops (&rest ops)
  `(progn 'compile
     .,(loop for op in ops
	     collect `(defnumop ,op ((f float) (b bignum))
			(,op f (float b)))
	     unless (defnumop-binary-converse-is-identical op)
	       collect `(defnumop ,op ((b bignum) (f float))
			  (,op (float b) f)))))

(def-simple-bignum-float-ops + - * //)

(defun describe-bignum (x)
  (check-arg-type x :bignum)
  (let ((len (bignum-length x)))
    (format t "~&~S is a bignum.~&It is ~R word~:P long.  It is ~[positive~;negative~].  ~
                 It is stored starting at location: ~\SI:ADDRESS\~&Its contents:~2%"
	    x len (- (bignum-sign x)) (%pointer x))
    (loop for i from 0 below len
	  as w = (bignum-ref x i) do
      (format t "~3O: ~2,16,'0R~2,16,'0R  ~O,~10,'0O  ~O,~10,'0O,~O  ~10,'0O,~O~%"
	      i
	      (ldb (byte 16. 16.) w) (ldb (byte 16. 00.) w)
	      (ldb (byte 02. 30.) w) (ldb (byte 30. 00.) w)
	      (ldb (byte 01. 31.) w) (ldb (byte 30. 01.) w) (ldb (byte 01. 00.) w)
	      (ldb (byte 30. 02.) w) (ldb (byte 02. 00.) w))))
  x)


;; Can't do this until we have trap handlers
#+IMach
(ADD-INITIALIZATION "Initialize FPA" '(CLI::INITIALIZE-W3X64) '(:WARM :NOW))
