;; -*- Mode:LISP; Package:SYSTEM-INTERNALS; Base:8; Syntax: Zetalisp -*-
;; These are the macros in the Lisp Machine system.
;; They used to be in LISPM;MACROS > but have been moved
;; so the compiler can properly compile the system

;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; From LMMAC.500
;;; Merged in LMACRO.77
;;; Moved Area/Region stuff to ALLOCATE
;;; Moved %MAKE-EXTENDED-NUMBER to LCONS
;;; I am not sure what should be restricted, and what should not be restricted.

;;; This has all the machine-dependent macros.  Compile this file for
;;; effect in the remote world on either machine and your macros will expand right
;;; for the rest of the compilation.

;;; Calling a function with a variable number of arguments

;Destination may be one of NIL (for effect), T (for 1 value), RETURN (return from me)
;Need anything for multiple values??
;The arguments are to be supplied via %PUSH
;LEXPR is true if the last argument is going to be a list of arguments,
;note that N-ARGUMENTS counts this as one argument.
;This only works in compiled code, of course.

#+3600
(DEFMACRO %START-FUNCTION-CALL (FUNCTION DESTINATION N-ARGUMENTS LEXPR)
  FUNCTION DESTINATION LEXPR  ;ignored
  `(PROGN (%ASSURE-PDL-ROOM (+ ,N-ARGUMENTS 2))
	  (%PUSH ,FUNCTION)))

#+IMACH
(DEFMACRO %START-FUNCTION-CALL (FUNCTION DESTINATION N-ARGUMENTS LEXPR)
  (DECLARE (IGNORE DESTINATION LEXPR))
  `(PROGN
     (%ASSURE-PDL-ROOM (+ ,N-ARGUMENTS 3))
     (COMPILER:START-CALL ,FUNCTION)))

; %FINISH-FUNCTION-CALL (FUNCTION DESTINATION N-ARGUMENTS LEXPR)
; is recognized by the compiler as a special form.  FUNCTION is ignored.
; N-ARGUMENTS is evaluated and pushed on the stack.
; DESTINATION is a symbol used to select the appropriate FUNCALL-N-dest instruction.
; LEXPR is NIL or T to select the FUNCALL-N vs LEXPR-FUNCALL-N instruction

;;; Open compiled version of VALUES-LIST, used for writing interpreter function by the same
;;; name.
(DEFSUBST %VALUES-LIST (LIST)
  (LET ((COUNT (CL:LENGTH LIST)))
    (%ASSURE-PDL-ROOM COUNT)
    (DO ()
	((ENDP LIST)
	 (%PUSH COUNT)
	 (%RETURN-MULTIPLE))
      (%PUSH (POP LIST)))))


;;;; I Machine subprimitives

#+IMACH
(PROGN

;;; Internal and coprocessor registers

(CL:DEFSETF %READ-INTERNAL-REGISTER (REGISTER) (NEW-VALUE)
  `(%WRITE-INTERNAL-REGISTER ,NEW-VALUE ,REGISTER))

(CL:DEFSETF %COPROCESSOR-READ (REGISTER) (NEW-VALUE)
  `(%COPROCESSOR-WRITE ,NEW-VALUE ,REGISTER))

;; You must not SETF this to TRAP-MODE-FEP when the current mode is TRAP-MODE-EMULATOR
;; or TRAP-MODE-EXTRA-STACK.  Use %SET-TRAP-MODE instead of SETF in that case.
;; This is because of a pipelining Ivory rev 1 that can halt the machine if
;; a sequence break arrives simultaneously with raising the mode.
;; Also be aware that if you are raising the mode to disable sequence breaks,
;; there may be a one instruction delay before the change takes effect.
(DEFSUBST %TRAP-MODE ()
  (%LOGLDB %%CR.TRAP-MODE (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER)))

(DEFMACRO %AUXILIARY-STACK-P ()
  `(LDB-TEST %%CR.TRAP-MODE (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER)))

;;; The first arg is a value-disposition relic from the 3600?
(DEFMACRO %FUNCALL-IN-AUXILIARY-STACK-BUFFER (IGNORE &REST ARGS)
  `(%FUNCALL-IN-AUX-STACK ,(CAR ARGS) ,@(CDR ARGS)))

;; Called in trap handlers which are initially run in extra-stack mode and want to
;; revert to emulator mode.  Callers must ensure that they really can revert back!
(DEFMACRO %REVERT-TO-EMULATOR-MODE ()
  `(PROGN (LOOP UNTIL (%POINTER-LESSP
			(%STACK-FRAME-POINTER)
			(%READ-INTERNAL-REGISTER %REGISTER-CONTROL-STACK-LIMIT))
		DO (STACK-OVERFLOW-TRAP-HANDLER NIL NIL))
	  ;; Drop back into emulator mode
	  (SETF (%TRAP-MODE) TRAP-MODE-EMULATOR)))

(DEFINE-SYMBOL-MACRO %BINDING-STACK-POINTER
		     (%READ-INTERNAL-REGISTER %REGISTER-BINDING-STACK-POINTER))

(CL:DEFSETF %SAVED-CONTROL-REGISTER () (NEW-VALUE)
  `(CLI::%SET-SAVED-CONTROL-REGISTER
     (%SET-TAG ,NEW-VALUE (DPB 3 %%Q-CDR-CODE-WITHIN-TAG (%TAG ,NEW-VALUE)))))

(SCL:DEFLOCF %SAVED-CONTROL-REGISTER CLI::%SAVED-CONTROL-REGISTER-ADDRESS)

(CL:DEFSETF %SAVED-CONTINUATION-REGISTER () (NEW-VALUE)
  `(CLI::%SET-SAVED-CONTINUATION-REGISTER
     (%SET-TAG ,NEW-VALUE (DPB 3 %%Q-CDR-CODE-WITHIN-TAG (%TAG ,NEW-VALUE)))))

(DEFSUBST CLI::%SAVED-CONTINUATION-REGISTER-ADDRESS ()
  (%STACK-FRAME-POINTER))

(SCL:DEFLOCF %SAVED-CONTINUATION-REGISTER CLI::%SAVED-CONTINUATION-REGISTER-ADDRESS)

(DEFMACRO SET-ALU-AND-ROTATE-CONTROL (&REST REST
				      &KEY BYTE-R BYTE-S
				      FUNCTION FUNCTION-CLASS FUNCTION-BITS
				      CONDITION CONDITION-SENSE
				      ENABLE-CONDITION-EXCEPTION
				      ENABLE-LOAD-CARRY-IN)
  BYTE-R BYTE-S FUNCTION FUNCTION-CLASS FUNCTION-BITS CONDITION CONDITION-SENSE
  ENABLE-CONDITION-EXCEPTION ENABLE-LOAD-CARRY-IN
  (LET (CONDITION-P CONDITION-EXCEPTION-P)
    `(SETF (%READ-INTERNAL-REGISTER %REGISTER-ALU-AND-ROTATE-CONTROL)
	   (%LOGDPBS ,@(LOOP FOR (KEYWORD VAL) ON REST BY 'CDDR
			     WHEN (MEMQ KEYWORD '(:CONDITION :CONDITION-SENSE))
			       DO (SETQ CONDITION-P T)
			     WHEN (EQ KEYWORD ':ENABLE-CONDITION-EXCEPTION)
			       DO (SETQ CONDITION-EXCEPTION-P T)
			     COLLECT VAL
			     COLLECT (OR (CADR (ASSOC KEYWORD
						      '((:BYTE-R %%ALU-BYTE-R)
							(:BYTE-S %%ALU-BYTE-S)
							(:FUNCTION %%ALU-FUNCTION)
							(:FUNCTION-CLASS %%ALU-FUNCTION-CLASS)
							(:FUNCTION-BITS %%ALU-FUNCTION-BITS)
							(:CONDITION-SENSE
							  %%ALU-CONDITION-SENSE)
							(:CONDITION %%ALU-CONDITION)
							(:ENABLE-CONDITION-EXCEPTION
							  %%ALU-ENABLE-CONDITION-EXCEPTION)
							(:ENABLE-LOAD-CARRY-IN
							  %%ALU-ENABLE-LOAD-CIN)
							)))
					 (ERROR "UNKNOWN KEYWORD ~S" KEYWORD))
			     FINALLY
			       (WHEN (AND CONDITION-P (NULL CONDITION-EXCEPTION-P))
				 (WARN "A condition was specified without :ENABLE-CONDITION-EXCEPTION being specified")))
		     ;; Defaultly enable this for approximate binary software compatibility
		     ;; with Rev3 Ivory.  Neither enabling nor disabling is
		     ;; completelt compatible.
		     ,@(UNLESS CONDITION-EXCEPTION-P
			 '(1 %%ALU-ENABLE-CONDITION-EXCEPTION))
		     ,@(UNLESS CONDITION-P
			 '(%ALU-CONDITION-SIGNED-OVERFLOW %%ALU-CONDITION))
		     0))))

(DEFMACRO %ALU-FUNCTION-DPB (BACKGROUND ROTATE-LATCH)
  `(%LOGDPBS %ALU-FUNCTION-OP-DPB (BYTE 3. 3.)
	     ,ROTATE-LATCH (BYTE 1. 2.)
	     ,BACKGROUND (BYTE 2. 0.)
	     0))

(DEFMACRO %ALU-FUNCTION-LDB (BACKGROUND ROTATE-LATCH)
  `(%LOGDPBS %ALU-FUNCTION-OP-LDB (BYTE 3. 3.)
	     ,ROTATE-LATCH (BYTE 1. 2.)
	     ,BACKGROUND (BYTE 2. 0.)
	     0))

(DEFMACRO %ALU-FUNCTION-ADD (SECOND-OPERAND OP2-ACTION CARRY-IN)
  `(%LOGDPBS %ALU-FUNCTION-OP-ADD (BYTE 3. 3.)
	     ,OP2-ACTION (BYTE 1 2)
	     ,SECOND-OPERAND (BYTE 1. 1.)
	     ,CARRY-IN (BYTE 1. 0.)
	     0))

(DEFSUBST ARRAY-EVENT-COUNT ()
  (%READ-INTERNAL-REGISTER %REGISTER-EVENT-COUNT))

;;; Bashes %REGISTER-ALU-AND-ROTATE-CONTROL
(DEFSUBST %ROTATE-LATCH ()
  (%LOGDPB (PROGN (SET-ALU-AND-ROTATE-CONTROL
		    :BYTE-R 16.
		    :BYTE-S 15.
		    :FUNCTION-CLASS %ALU-FUNCTION-CLASS-BYTE
		    :FUNCTION-BITS #B0001)	;DPB, no load
		  (%ALU 0 0))
	   (BYTE 16. 0.)
	   (PROGN (SET-ALU-AND-ROTATE-CONTROL
		    :BYTE-R 0
		    :BYTE-S 15.
		    :FUNCTION-CLASS %ALU-FUNCTION-CLASS-BYTE
		    :FUNCTION-BITS #B1001)	;LDB, no load
		  (%ALU 0 0))))

;;; Bashes %REGISTER-ALU-AND-ROTATE-CONTROL
(CL:DEFSETF %ROTATE-LATCH () (NEW-VALUE)
 (ONCE-ONLY (NEW-VALUE)
   `(PROGN (SET-ALU-AND-ROTATE-CONTROL
	     :BYTE-R 0.
	     :BYTE-S 0.
	     :FUNCTION-CLASS %ALU-FUNCTION-CLASS-BYTE
	     :FUNCTION-BITS #B0100)
	   (%ALU ,NEW-VALUE ,NEW-VALUE))))

;;; Bashes %REGISTER-ALU-AND-ROTATE-CONTROL
(DEFMACRO SAVING-ROTATE-LATCH (&BODY BODY)
  (LET ((ROTATE-LATCH (GENSYMBOL "ROTATE-LATCH-")))
    `(LET ((,ROTATE-LATCH (%ROTATE-LATCH)))
       (MULTIPLE-VALUE-PROG1
	 (PROGN ,@BODY)
	 (SET-ALU-AND-ROTATE-CONTROL
	     :BYTE-R 0.
	     :BYTE-S 0.
	     :FUNCTION-CLASS %ALU-FUNCTION-CLASS-BYTE
	     :FUNCTION-BITS #B0100)
	 (%ALU ,ROTATE-LATCH ,ROTATE-LATCH)))))

;;; Restore the original values of the registers on normal exit from the macro.
(DEFMACRO SAVING-REGISTERS ((&REST REGISTER-NAMES) &BODY BODY)
  (LOOP FOR REGISTER IN REGISTER-NAMES
	AS VARIABLE = (GENSYM)
	COLLECT `(,VARIABLE (%READ-INTERNAL-REGISTER ,REGISTER)) INTO BINDINGS
	COLLECT `(SETF (%READ-INTERNAL-REGISTER ,REGISTER) ,VARIABLE) INTO CLEANUPS
	FINALLY
	  (RETURN
	    `(LET ,BINDINGS
	       (MULTIPLE-VALUE-PROG1 (PROGN . ,BODY)
		 . ,(NREVERSE CLEANUPS))))))

;;; Generates more efficient code when you know you're not using the value in BODY.
(DEFMACRO SAVING-REGISTERS-FOR-EFFECT ((&REST REGISTER-NAMES) &BODY BODY)
  (LOOP WITH RESULT = `(PROGN . ,BODY)
	FOR REGISTER-NAME IN REGISTER-NAMES
	DO (SETQ RESULT `(SETF (%READ-INTERNAL-REGISTER ,REGISTER-NAME)
			       (PROG1 (%READ-INTERNAL-REGISTER ,REGISTER-NAME) ,RESULT)))
	FINALLY (RETURN RESULT)))

(DEFMACRO SAVING-REGISTERS-FOR-VALUE ((&REST REGISTER-NAMES) &BODY BODY)
  (LET ((TEMP (GENSYM)))
    (LOOP WITH RESULT = `(SETQ ,TEMP (PROGN . ,BODY))
	FOR REGISTER-NAME IN REGISTER-NAMES
	DO (SETQ RESULT `(SETF (%READ-INTERNAL-REGISTER ,REGISTER-NAME)
			       (PROG1 (%READ-INTERNAL-REGISTER ,REGISTER-NAME) ,RESULT)))
	FINALLY (RETURN `(LET ((,TEMP))
			   ,RESULT
			   ,TEMP)))))

#+IMACH
(DEFMACRO SAVING-REGISTERS-FOR-TRAP-FOR-EFFECT (&BODY BODY)
  `(SAVING-REGISTERS-FOR-EFFECT (%REGISTER-BAR-1 %REGISTER-ALU-AND-ROTATE-CONTROL)
      (SAVING-ROTATE-LATCH
	(CLI::WITH-FLOATING-POINT-STATUS-SAVED-FOR-TRAP
	  ,@BODY))))

#+IMACH
(DEFMACRO SAVING-REGISTERS-FOR-TRAP-FOR-VALUE (&BODY BODY)
  `(SAVING-REGISTERS-FOR-VALUE (%REGISTER-BAR-1 %REGISTER-ALU-AND-ROTATE-CONTROL)
      (SAVING-ROTATE-LATCH
	(CLI::WITH-FLOATING-POINT-STATUS-SAVED-FOR-TRAP
	  ,@BODY))))

#+IMACH
(DEFMACRO SAVING-REGISTERS-FOR-TRAP-FOR-MULTIPLE-VALUES (&BODY BODY)
  `(SAVING-REGISTERS (%REGISTER-BAR-1 %REGISTER-ALU-AND-ROTATE-CONTROL)
      (SAVING-ROTATE-LATCH
	(CLI::WITH-FLOATING-POINT-STATUS-SAVED-FOR-TRAP
	  ,@BODY))))

(DEFCONSTANT %COPROCESSOR-MICROSECOND-CLOCK-ADDRESS #o1002)

(DEFSUBST %MICROSECOND-CLOCK ()
  (%COPROCESSOR-READ %COPROCESSOR-MICROSECOND-CLOCK-ADDRESS))


;;;; I-machine memory subprimitives

(EVAL-WHEN (COMPILE LOAD EVAL)
(DEFUN PACK-BLOCK-BITS (&KEY CYCLE-TYPE
			(FIXNUM-ONLY NIL) (SET-CDR-NEXT NIL)
			(PREFETCH T) (NO-INCREMENT NIL))
  (%LOGDPB
    (cl:etypecase cycle-type
      (null 0)
      (cl:symbol (symeval cycle-type))
      (cl:fixnum cycle-type))
    %%MEMORY-CYCLE-TYPE
    (%LOGDPB
      (IF FIXNUM-ONLY 1 0)
      %%MEMORY-FIXNUM-ONLY
      (%LOGDPB
	(IF SET-CDR-NEXT 1 0)
	%%MEMORY-SET-CDR-NEXT
	(%LOGDPB
	  (IF PREFETCH 0 1)
	  %%MEMORY-LAST-WORD
	  (%LOGDPB
	    (IF NO-INCREMENT 1 0)
	    %%MEMORY-NO-INCREMENT
	    0))))))

(DEFUN BLOCK-REGISTER-NAME (N)
  (CL:ECASE N
    (1 'SYS:%REGISTER-BAR-1)
    (2 'SYS:%REGISTER-BAR-2)
    (3 'SYS:%REGISTER-BAR-3)))
);End EVAL-WHEN

(DEFMACRO %MEMORY-READ (ADDRESS &KEY (CYCLE-TYPE '%MEMORY-DATA-READ)
				     FIXNUM-ONLY
				     (SET-CDR-NEXT T))
  `(%MEMORY-READ-INTERNAL
     ,ADDRESS
     ,(PACK-BLOCK-BITS :CYCLE-TYPE CYCLE-TYPE
		       :FIXNUM-ONLY FIXNUM-ONLY
		       :SET-CDR-NEXT SET-CDR-NEXT)))

(DEFMACRO %MEMORY-READ-ADDRESS (ADDRESS &KEY (CYCLE-TYPE '%MEMORY-DATA-READ)
					FIXNUM-ONLY (SET-CDR-NEXT T))
  `(%MEMORY-READ-ADDRESS-INTERNAL
     ,ADDRESS
     ,(PACK-BLOCK-BITS :CYCLE-TYPE CYCLE-TYPE
		       :FIXNUM-ONLY FIXNUM-ONLY
		       :SET-CDR-NEXT SET-CDR-NEXT)))

;This would be a bad idea, since SETF of many reads should result in something
;other than a raw-write.
;(CL:DEFSETF %MEMORY-READ-INTERNAL (ADDRESS IGNORE) (NEW-VALUE)
;  `(%MEMORY-WRITE ,ADDRESS ,NEW-VALUE))

(DEFMACRO %BLOCK-REGISTER (N)
  `(%READ-INTERNAL-REGISTER ,(BLOCK-REGISTER-NAME N)))

(DEFMACRO %BLOCK-READ (BAR &KEY (CYCLE-TYPE '%MEMORY-DATA-READ) FIXNUM-ONLY
		       (SET-CDR-NEXT T) (PREFETCH T) NO-INCREMENT)
  `(,(SELECT BAR
       (1 '%BLOCK-1-READ)
       (2 '%BLOCK-2-READ)
       (3 '%BLOCK-3-READ)
       (OTHERWISE (ERROR "~a is not a valid BAR number" BAR)))
    ,(PACK-BLOCK-BITS :CYCLE-TYPE CYCLE-TYPE
		      :FIXNUM-ONLY FIXNUM-ONLY
		      :SET-CDR-NEXT SET-CDR-NEXT
		      :PREFETCH PREFETCH
		      :NO-INCREMENT NO-INCREMENT)))

(DEFMACRO %BLOCK-READ-SHIFT (BAR &KEY (CYCLE-TYPE '%MEMORY-DATA-READ) FIXNUM-ONLY
			     (SET-CDR-NEXT T) (PREFETCH T)
			     NO-INCREMENT)
  `(,(SELECT BAR
       (1 '%BLOCK-1-READ-SHIFT)
       (2 '%BLOCK-2-READ-SHIFT)
       (3 '%BLOCK-3-READ-SHIFT)
       (OTHERWISE (ERROR "~a is not a valid BAR number" BAR)))
    ,(PACK-BLOCK-BITS :CYCLE-TYPE CYCLE-TYPE
		      :FIXNUM-ONLY FIXNUM-ONLY
		      :SET-CDR-NEXT SET-CDR-NEXT
		      :PREFETCH PREFETCH
		      :NO-INCREMENT NO-INCREMENT)))

(DEFMACRO %BLOCK-READ-ALU (BAR ARG)
  `(,(SELECT BAR
       (1 '%BLOCK-1-READ-ALU)
       (2 '%BLOCK-2-READ-ALU)
       (3 '%BLOCK-3-READ-ALU)
       (OTHERWISE (ERROR "~a is not a valid BAR number" BAR)))
    ,ARG))

;;; This has to be special form of some sort because it can branch.
(DEFMACRO %BLOCK-READ-TEST (BAR &KEY (CYCLE-TYPE '%MEMORY-DATA-READ) FIXNUM-ONLY
			    (SET-CDR-NEXT T) (PREFETCH T) NO-INCREMENT
			    REQUIRE-TOS-VALID)
  `(%BLOCK-READ-TEST-INTERNAL
     ,BAR
     ,(PACK-BLOCK-BITS :CYCLE-TYPE CYCLE-TYPE
		       :FIXNUM-ONLY FIXNUM-ONLY
		       :SET-CDR-NEXT SET-CDR-NEXT
		       :PREFETCH PREFETCH
		       :NO-INCREMENT NO-INCREMENT)
     ,REQUIRE-TOS-VALID))

(DEFMACRO %BLOCK-WRITE
	  (BAR VALUE)
  `(,(SELECT BAR
       (1 '%BLOCK-1-WRITE)
       (2 '%BLOCK-2-WRITE)
       (3 '%BLOCK-3-WRITE)
       (OTHERWISE (ERROR "~a is not a valid BAR number" BAR)))
    ,VALUE))

;;; Preserve the values of the specified block registers, using the appropriate policies.
(DEFMACRO WITH-BLOCK-REGISTERS ((&REST REGISTERS) &BODY BODY)
  ;; This is obscure to ensure that only one unwind-protect is generated.
  (LOOP WITH (BINDINGS WINDINGS UNWINDINGS)
	FOR REGISTER IN REGISTERS DO
    (CL:ECASE REGISTER
      (1)
      (2 (LET ((NAME (GENSYMBOL "SAVED-BLOCK-REGISTER-")))
	   (PUSH `(,NAME (%READ-INTERNAL-REGISTER %REGISTER-BAR-2)) BINDINGS)
	   (PUSH `(%WRITE-INTERNAL-REGISTER ,NAME %REGISTER-BAR-2) UNWINDINGS)))
      (3 (LET ((NAME (GENSYMBOL "SAVED-BLOCK-REGISTER-"))
	       (ADDRESS (GENSYMBOL "COUNT-ADDRESS-"))
	       (COUNT (GENSYMBOL "COUNT-")))
	   (PUSH `(,NAME (%READ-INTERNAL-REGISTER %REGISTER-BAR-3)) BINDINGS)
	   (PUSH `(,ADDRESS
		   (LOCF (SG-STRUCTURE-STACK-POINTER-COUNT %CURRENT-STACK-GROUP)))
		 BINDINGS)
	   (PUSH `(,COUNT (LOCATION-CONTENTS ,ADDRESS)) BINDINGS)
	   ;; If the count is zero, write the bar to sg-structure-stack-pointer-haven.
	   (PUSH `(WHEN (AND %CURRENT-STACK-GROUP (= ,COUNT 0))
		    (%MEMORY-WRITE (%POINTER-PLUS ,ADDRESS 1) ,NAME))
		 WINDINGS)
	   ;; Increment the count before executing the body.
	   (PUSH `(WHEN %CURRENT-STACK-GROUP (%MEMORY-WRITE ,ADDRESS (1+ ,COUNT))) WINDINGS)
	   ;; Restore the previous count after executing.
	   (PUSH `(WHEN %CURRENT-STACK-GROUP (%MEMORY-WRITE ,ADDRESS ,COUNT)) UNWINDINGS)
	   ;; If the previous count was zero, clobber sg-structure-stack-pointer-haven
	   ;; to nil after executing.  This is to avoid storing the value of bar 3
	   ;; because it might point to a large garbage collectable object.
	   (PUSH `(WHEN (AND %CURRENT-STACK-GROUP (= ,COUNT 0))
		    (%MEMORY-WRITE (%POINTER-PLUS ,ADDRESS 1) NIL))
		 UNWINDINGS)
	   (PUSH `(%WRITE-INTERNAL-REGISTER ,NAME %REGISTER-BAR-3) UNWINDINGS))))
	FINALLY
	  (RETURN (COND ((OR WINDINGS UNWINDINGS)
			 `(LET* ,(REVERSE BINDINGS)
			    (UNWIND-PROTECT
				(PROGN ,@(REVERSE WINDINGS) . ,BODY)
			      ,@(REVERSE UNWINDINGS))))
			(BINDINGS
			  `(LET* ,(REVERSE BINDINGS) . ,BODY))
			(T `(PROGN . ,BODY))))))

;;; Preserve the values of the specified block registers, using the appropriate policies.
;;; For use in the wired system only.
(DEFMACRO WITH-SYSTEM-BLOCK-REGISTERS ((&REST REGISTERS) &BODY BODY)
  (LET* ((REGISTERS (MAPCAR #'BLOCK-REGISTER-NAME (CL:DELETE 1 REGISTERS)))
	 (VARS (LOOP FOR REGISTER IN REGISTERS
		     DO (IGNORE REGISTER)
		     COLLECT (GENSYMBOL "SAVED-BLOCK-REGISTER-"))))
    (IF (NULL REGISTERS)
	`(PROGN . ,BODY)
	`(LET ,(LOOP FOR REGISTER IN REGISTERS
		     FOR VAR IN VARS
		     COLLECT `(,VAR (%READ-INTERNAL-REGISTER ,REGISTER)))
	   (MULTIPLE-VALUE-PROG1
	     (PROGN . ,BODY)
	     . ,(LOOP FOR REGISTER IN REGISTERS
		      FOR VAR IN VARS
		      COLLECT `(%WRITE-INTERNAL-REGISTER ,VAR ,REGISTER)))))))

;;; For compatibility.
(DEFF USING-BARS #'WITH-BLOCK-REGISTERS)
(DEFF SAVING-BARS #'WITH-BLOCK-REGISTERS)

;; Rev1 and Rev2 feature.
#+Ivory-Rev-1
(DEFMACRO PREPARE-FOR-BLOCK-WRITE ()
  `(%WRITE-INTERNAL-REGISTER '#.(%SET-TAG 0 DTP-PHYSICAL-ADDRESS) %REGISTER-BAR-0))

(DEFMACRO PREPARE-FOR-BLOCK-WRITE ()
  NIL)

(DEFMACRO %RETURN-KLUDGE-0 ()
  `(%RETURN-KLUDGE 0))

;;; Pointer construction

(DEFSUBST %MAKE-POINTER (DATA-TYPE POINTER)
  ;; Note that cdr-next is zero, so the LDB does the right thing.
  (%SET-TAG POINTER (LDB %%Q-TYPE-WITHIN-TAG DATA-TYPE)))

(DEFSUBST %MAKE-POINTER-OFFSET (NEW-DTP POINTER OFFSET)
  (%MAKE-POINTER NEW-DTP (%POINTER-PLUS POINTER OFFSET)))

(DEFSUBST %POINTER (X)
  (%MAKE-POINTER DTP-FIXNUM X))

(DEFSUBST %DATA-TYPE (X)
  (LDB %%Q-TYPE-WITHIN-TAG (%TAG X)))

(DEFSUBST %MAKE-PHYSICAL-ADDRESS (PMA)
  (%SET-TAG (%LOGLDB (BYTE 32. 0) PMA) DTP-PHYSICAL-ADDRESS))

(DEFSUBST %MAKE-UNMAPPED-ADDRESS (PMA)
  (%SET-TAG (%LOGDPB %VMA-EQUALS-PMA %%VMA-EQUALS-PMA PMA) DTP-LOCATIVE))

;;; Obsolete?
;(DEFSUBST CHAR-LDB-IMMED (CHAR BYTE)
;  (LDB BYTE (%FIXNUM CHAR)))

;;; Do we want to take the time to check the data-type here?   Most code
;;; that is using this should already have checked it.  Presumably this
;;; will be used with small rationals as well as floats.
(DEFSUBST %FIXNUM (X)
  (%MAKE-POINTER DTP-FIXNUM X))

(DEFSUBST %FLONUM (X)
  (%MAKE-POINTER DTP-SINGLE-FLOAT X))

(DEFSUBST %SMALL-RATIO (X)
  (%MAKE-POINTER DTP-SMALL-RATIO X))

(DEFSUBST %P-STORE-CDR-AND-CONTENTS (POINTER VALUE CDR)
  (%MEMORY-WRITE POINTER (%SET-TAG VALUE (DPB CDR %%Q-CDR-CODE-WITHIN-TAG (%TAG VALUE)))))

(DEFSUBST %P-STORE-TAG-AND-POINTER (POINTER TAG-FIELD POINTER-FIELD)
  (%MEMORY-WRITE POINTER (%SET-TAG POINTER-FIELD TAG-FIELD)))

(DEFSUBST %P-CONTENTS-AS-LOCATIVE (X)
  (%MAKE-POINTER DTP-LOCATIVE (%MEMORY-READ X :CYCLE-TYPE %MEMORY-SCAVENGE :SET-CDR-NEXT T)))

;;; Preserves the data type of the structure.
(DEFSUBST %P-STRUCTURE-OFFSET-INTERNAL (STRUCTURE OFFSET)
  (%POINTER-PLUS (%MEMORY-READ-ADDRESS STRUCTURE :CYCLE-TYPE %MEMORY-STRUCTURE-OFFSET) OFFSET))

;;; Returns a locative, for compatibility with the 3600.
(DEFSUBST %P-STRUCTURE-OFFSET (STRUCTURE OFFSET)
  (%SET-TAG (%P-STRUCTURE-OFFSET-INTERNAL STRUCTURE OFFSET) DTP-LOCATIVE))

(DEFMACRO %SET-CDR-CODE-NIL (THING)
  `(%SET-CDR-CODE-1 ,THING))

(DEFMACRO %SET-CDR-CODE-NORMAL (THING)
  `(%SET-CDR-CODE-2 ,THING))

;;; Users of these should be replaced by block functions when there is time to do so

(DEFMACRO %P-CONTENTS-INCREMENT-POINTER (POINTER)
  (UNLESS (SYMBOLP POINTER)
    (ERROR "~A is not a variable" POINTER))
  `(PROGN (SETF ,POINTER (%POINTER-PLUS ,POINTER 1))
	  (%MEMORY-READ ,POINTER)))

(DEFMACRO %P-STORE-CONTENTS-INCREMENT-POINTER (VALUE POINTER)
  (UNLESS (SYMBOLP POINTER)
    (ERROR "~a is not a variable" POINTER))
  `(PROGN (SETF ,POINTER (%POINTER-PLUS ,POINTER 1))
	  (CL:SETF (LOCATION-CONTENTS (%SET-TAG ,POINTER DTP-LOCATIVE)) ,VALUE)))

(DEFMACRO %P-CONTENTS-POINTER-DECREMENT (POINTER)
  (UNLESS (SYMBOLP POINTER)
    (ERROR "~a is not a variable" POINTER))
  `(PROG1 (%MEMORY-READ ,POINTER)
	  (SETF ,POINTER (%POINTER-PLUS ,POINTER -1))))

(DEFMACRO %P-STORE-CONTENTS-POINTER-DECREMENT (VALUE POINTER)
  (UNLESS (SYMBOLP POINTER)
    (ERROR "~a is not a variable" POINTER))
  `(PROG1 (CL:SETF (LOCATION-CONTENTS (%SET-TAG ,POINTER DTP-LOCATIVE)) ,VALUE)
	  (SETF ,POINTER (%POINTER-PLUS ,POINTER -1))))

(DEFSUBST FRAME-PREVIOUS-TOP (FRAME)
  (%POINTER-PLUS FRAME -1))

(DEFSUBST DEFSTORAGE-OFFSET (OPTIONS)
  (LOGXOR (1- (// (DEFSYSBYTE-LIMIT-VALUE %%DEFSTORAGE-OFFSET) 2))
	  (- (1- (// (DEFSYSBYTE-LIMIT-VALUE %%DEFSTORAGE-OFFSET) 2))
	     (LDB %%DEFSTORAGE-OFFSET OPTIONS))))

(DEFUN COMPACT-DEFSTORAGE-ACCESSOR (OBJECT OPTIONS &OPTIONAL FULL-OFFSET)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (FLET ((READ-WORD ()
	   (IF (OR FULL-OFFSET (LDB-TEST %%DEFSTORAGE-OFFSET OPTIONS))
	       (%MEMORY-READ
		 (%POINTER-PLUS
		   (IF (LDB-TEST %%DEFSTORAGE-FORWARDABLE OPTIONS)
		       (IF (LDB-TEST %%DEFSTORAGE-STRUCTURE OPTIONS)
			   (%MEMORY-READ-ADDRESS OBJECT :CYCLE-TYPE %MEMORY-HEADER)
			   (%MEMORY-READ-ADDRESS OBJECT :CYCLE-TYPE %MEMORY-DATA-READ))
		       OBJECT)
		   (OR FULL-OFFSET (DEFSTORAGE-OFFSET OPTIONS)))
		 :CYCLE-TYPE %MEMORY-DATA-READ
		 :SET-CDR-NEXT NIL)
	       (IF (LDB-TEST %%DEFSTORAGE-STRUCTURE OPTIONS)
		   (%MEMORY-READ OBJECT :CYCLE-TYPE %MEMORY-HEADER :SET-CDR-NEXT NIL)
		   (%MEMORY-READ OBJECT :CYCLE-TYPE %MEMORY-DATA-READ :SET-CDR-NEXT NIL)))))
    (IF (LDB-TEST %%DEFSTORAGE-SIZE OPTIONS)
	(LET ((PP (LDB %%DEFSTORAGE-POSITION OPTIONS))
	      (SS (LDB %%DEFSTORAGE-SIZE OPTIONS)))
	  (IF ( (+ PP SS) 32.)
	      (LDB (BYTE SS PP) (%SET-TAG (READ-WORD) DTP-FIXNUM))
	      (IF (AND ( PP 32.) ( (+ PP SS) 40.))
		  (LDB (BYTE SS (- PP 32.)) (%TAG (READ-WORD)))
		  (ERROR "Illegal byte field for DEFSTORAGE accessor"))))
	(READ-WORD)))) 

(DEFUN SET-COMPACT-DEFSTORAGE-ACCESSOR
       (VALUE OBJECT OPTIONS &OPTIONAL FULL-OFFSET)
  (FLET ((ADDRESS-WORD ()
	   (%POINTER-PLUS
	     (IF (LDB-TEST %%DEFSTORAGE-FORWARDABLE OPTIONS)
		 (IF (LDB-TEST %%DEFSTORAGE-STRUCTURE OPTIONS)
		     (%MEMORY-READ-ADDRESS OBJECT :CYCLE-TYPE %MEMORY-HEADER)
		     (%MEMORY-READ-ADDRESS OBJECT :CYCLE-TYPE %MEMORY-DATA-WRITE))
		 OBJECT)
	     (OR FULL-OFFSET (DEFSTORAGE-OFFSET OPTIONS)))))
    (IF (LDB-TEST %%DEFSTORAGE-SIZE OPTIONS)
	(%P-DPB VALUE (BYTE (LDB %%DEFSTORAGE-SIZE OPTIONS)
			    (LDB %%DEFSTORAGE-POSITION OPTIONS))
		(ADDRESS-WORD))
	(IF (LDB-TEST %%DEFSTORAGE-PRESERVE-CDR-CODES OPTIONS)
	    (%P-STORE-CONTENTS (ADDRESS-WORD) VALUE)
	    (%MEMORY-WRITE (ADDRESS-WORD) VALUE)))
    VALUE))

(CL:DEFSETF COMPACT-DEFSTORAGE-ACCESSOR
	    (OBJECT OPTIONS &OPTIONAL FULL-OFFSET)
	    (VALUE)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(SET-COMPACT-DEFSTORAGE-ACCESSOR ,VALUE ,OBJECT ,OPTIONS ,FULL-OFFSET))

(SCL:DEFLOCF COMPACT-DEFSTORAGE-ACCESSOR
	     (OBJECT OPTIONS &OPTIONAL FULL-OFFSET)
  (WHEN (LDB-TEST %%DEFSTORAGE-SIZE OPTIONS)
    (ERROR "LOCF of defstorage byte"))
  ;; For 3600 compatibility, don't follow any forwarding.
  (IF (LDB-TEST %%DEFSTORAGE-PHYSICAL OPTIONS)
      `(%POINTER-PLUS ,OBJECT ,(OR FULL-OFFSET (DEFSTORAGE-OFFSET OPTIONS)))
      `(%SET-TAG (%POINTER-PLUS ,OBJECT ,(OR FULL-OFFSET (DEFSTORAGE-OFFSET OPTIONS)))
		 SYS:DTP-LOCATIVE)))

(DEFUN DEFSTORAGE-ACCESSOR
       (OBJECT OFFSET FORWARDABLE STRUCTURE PRESERVE-CDR-CODES FIXNUM-ONLY &OPTIONAL SS PP)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (DECLARE (IGNORE PRESERVE-CDR-CODES))
  (WHEN (NUMBERP FIXNUM-ONLY)
    (SETQ PP SS
	  SS FIXNUM-ONLY
	  FIXNUM-ONLY NIL))
  (FLET ((READ-WORD ()
	   (IF (EQL OFFSET 0)
	       (IF STRUCTURE
		   (%MEMORY-READ OBJECT :CYCLE-TYPE %MEMORY-HEADER :SET-CDR-NEXT NIL)
		   (%MEMORY-READ OBJECT :CYCLE-TYPE %MEMORY-DATA-READ :SET-CDR-NEXT NIL))
	       (%MEMORY-READ
		 (%POINTER-PLUS
		   (IF FORWARDABLE
		       (IF STRUCTURE
			   (%MEMORY-READ-ADDRESS OBJECT :CYCLE-TYPE %MEMORY-HEADER)
			   (%MEMORY-READ-ADDRESS OBJECT :CYCLE-TYPE %MEMORY-DATA-READ))
		       OBJECT)
		   OFFSET)
		 :CYCLE-TYPE %MEMORY-DATA-READ
		 :SET-CDR-NEXT NIL))))
    (IF (NULL SS)
	(READ-WORD)
	(IF ( (+ PP SS) 32.)
	    (LDB (BYTE SS PP) (%SET-TAG (READ-WORD) DTP-FIXNUM))
	    (IF (AND ( PP 32.) ( (+ PP SS) 40.))
		(LDB (BYTE SS (- PP 32.)) (%TAG (READ-WORD)))
		(ERROR "Illegal byte field for DEFSTORAGE accessor"))))))

(DEFUN SET-DEFSTORAGE-ACCESSOR
       (VALUE OBJECT OFFSET FORWARDABLE STRUCTURE PRESERVE-CDR-CODES FIXNUM-ONLY SS PP)
  (DECLARE (IGNORE FIXNUM-ONLY))
  (FLET ((ADDRESS-WORD ()
	   (%POINTER-PLUS
	     (IF FORWARDABLE
		 (IF STRUCTURE
		     (%MEMORY-READ-ADDRESS OBJECT :CYCLE-TYPE %MEMORY-HEADER)
		     (%MEMORY-READ-ADDRESS OBJECT :CYCLE-TYPE %MEMORY-DATA-WRITE))
		 OBJECT)
	     OFFSET)))
    (IF (NULL SS)
	(IF PRESERVE-CDR-CODES
	    (%P-STORE-CONTENTS (ADDRESS-WORD) VALUE)
	    (%MEMORY-WRITE (ADDRESS-WORD) VALUE))
	(%P-DPB VALUE (BYTE SS PP) (ADDRESS-WORD)))
    VALUE))

(CL:DEFSETF DEFSTORAGE-ACCESSOR
	    (OBJECT OFFSET FORWARDABLE STRUCTURE PRESERVE-CDR-CODES FIXNUM-ONLY
		    &OPTIONAL SS PP)
	    (VALUE)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  `(SET-DEFSTORAGE-ACCESSOR
     ,VALUE ,OBJECT ,OFFSET ,FORWARDABLE ,STRUCTURE ,PRESERVE-CDR-CODES ,FIXNUM-ONLY ,SS ,PP))

(SCL:DEFLOCF DEFSTORAGE-ACCESSOR
	     (OBJECT OFFSET FORWARDABLE STRUCTURE PRESERVE-CDR-CODES FIXNUM-ONLY
		     &OPTIONAL SS PP)
  (DECLARE (IGNORE PRESERVE-CDR-CODES STRUCTURE FORWARDABLE FIXNUM-ONLY))
  (WHEN (OR SS PP)
    (ERROR "LOCF of defstorage byte"))
  ;; For 3600 compatibility, don't follow any forwarding.
  (IF (EQL OFFSET 0)
      `(%SET-TAG ,OBJECT SYS:DTP-LOCATIVE)
    `(%SET-TAG (%POINTER-PLUS ,OBJECT ,OFFSET) SYS:DTP-LOCATIVE)))

;;; Wrap this around a defstorage accessor, and it won't follow forwarding.
(DEFMACRO DONT-FOLLOW-FORWARDING (ACCESS &ENVIRONMENT ENV)
  (LET ((FORM (LET ((METHOD (LT:FIND-INLINE-FORM-METHOD (FIRST ACCESS) ENV)))
		(IF METHOD
		    (LT:EXPAND-INLINE-FORM METHOD ACCESS ENV :NEVER-BIND-LOCALS T)
		    (MACROEXPAND-1 ACCESS ENV)))))
    (COND ((CL:CONSP FORM)
	   (CL:CASE (FIRST FORM)
	     (DEFSTORAGE-ACCESSOR
	       (LET ((NEW-FORM (COPYLIST FORM)))
		 (SETF (FOURTH NEW-FORM) NIL)
		 NEW-FORM))
	     (COMPACT-DEFSTORAGE-ACCESSOR
	       `(COMPACT-DEFSTORAGE-ACCESSOR
		  ,(SECOND FORM)
		  (%LOGDPB 0 %%DEFSTORAGE-FORWARDABLE ,(THIRD FORM)) ,@(CDDDR FORM)))
	     (OTHERWISE
	       (WARN "~S is not understood by ~S" (CAR FORM) 'DONT-FOLLOW-FORWARDING)
	       FORM)))
	  (T (WARN "~S is not understood by ~S" (CAR FORM) 'DONT-FOLLOW-FORWARDING)
	     FORM))))
); End #+IMACH 

#+3600
(PROGN

(DEFMACRO SAVING-ROTATE-LATCH (&BODY BODY)
  `(PROGN ,@BODY))

;;; Restore the original values of the registers on normal exit from the macro.
(DEFMACRO SAVING-REGISTERS ((&REST REGISTER-NAMES) &BODY BODY)
  (DECLARE (IGNORE REGISTER-NAMES))
  `(PROGN ,@BODY))

;;; Generates more efficient code when you know you're not using the value in BODY.
(DEFMACRO SAVING-REGISTERS-FOR-EFFECT ((&REST REGISTER-NAMES) &BODY BODY)
  (DECLARE (IGNORE REGISTER-NAMES))
  `(PROGN ,@BODY))

(DEFMACRO SAVING-REGISTERS-FOR-VALUE ((&REST REGISTER-NAMES) &BODY BODY)
  (DECLARE (IGNORE REGISTER-NAMES))
  `(PROGN ,@BODY))

);End #+3600

;;; Field-referencing subprimitives defined in terms of the general ones

(DEFSUBST %P-POINTER (POINTER)
  (%P-LDB %%Q-POINTER POINTER))

(DEFSUBST %P-DATA-TYPE (POINTER)		;Assume full-size data type
  (%P-LDB %%Q-DATA-TYPE POINTER))

(DEFSUBST %P-CDR-CODE (POINTER)
  (%P-LDB %%Q-CDR-CODE POINTER))

(DEFSUBST %P-STORE-POINTER (POINTER VALUE)	;Note reversed order of evaluation!
  (DECLARE (COMPILER:RETURN-TYPE))
  (%P-DPB VALUE %%Q-POINTER POINTER))

(DEFSUBST %P-STORE-DATA-TYPE (POINTER VALUE)
  (DECLARE (COMPILER:RETURN-TYPE))
  (%P-DPB VALUE %%Q-DATA-TYPE POINTER))

(DEFSUBST %P-STORE-CDR-CODE (POINTER VALUE)
  (DECLARE (COMPILER:RETURN-TYPE))
  (%P-DPB VALUE %%Q-CDR-CODE POINTER))

(DEFSUBST %P-STORE-CDR-TYPE-AND-POINTER (POINTER CDR-FIELD TYPE-FIELD POINTER-FIELD)
  (%P-STORE-TAG-AND-POINTER
    POINTER
    (DPB CDR-FIELD %%Q-CDR-CODE-WITHIN-TAG TYPE-FIELD)
    POINTER-FIELD))

(DEFSUBST %P-STORE-TYPE-AND-POINTER (POINTER TYPE-FIELD POINTER-FIELD)
  #+3600
  (%P-STORE-CDR-TYPE-AND-POINTER
    POINTER
    (%P-CDR-CODE POINTER)
    TYPE-FIELD
    POINTER-FIELD)
  #+IMACH
  (%P-STORE-CONTENTS POINTER (%SET-TAG POINTER-FIELD TYPE-FIELD)))

;;; Offset subprimitives

(DEFSUBST %P-CONTENTS-OFFSET (POINTER OFFSET)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (CDR (%P-STRUCTURE-OFFSET POINTER OFFSET)))

(DEFSUBST %P-CONTENTS-AS-LOCATIVE-OFFSET (POINTER OFFSET)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  #+3600 (%P-CONTENTS-AS-LOCATIVE (%P-STRUCTURE-OFFSET POINTER OFFSET))
  #+IMach (%P-CONTENTS-AS-LOCATIVE (%P-STRUCTURE-OFFSET-INTERNAL POINTER OFFSET)))

(DEFSUBST %P-LDB-OFFSET (PPSS POINTER OFFSET)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  #+3600 (%P-LDB PPSS (%P-STRUCTURE-OFFSET POINTER OFFSET))
  #+IMach (%P-LDB PPSS (%P-STRUCTURE-OFFSET-INTERNAL POINTER OFFSET)))

(DEFSUBST %P-DPB-OFFSET (VALUE PPSS POINTER OFFSET)
  (DECLARE (COMPILER:RETURN-TYPE))
  #+3600 (%P-DPB VALUE PPSS (%P-STRUCTURE-OFFSET POINTER OFFSET))
  #+IMach (%P-DPB VALUE PPSS (%P-STRUCTURE-OFFSET-INTERNAL POINTER OFFSET)))

(DEFSUBST %P-STORE-CONTENTS-OFFSET (VALUE POINTER OFFSET)	;Note reversed order of eval!
  #+3600 (%P-STORE-CONTENTS (%P-STRUCTURE-OFFSET POINTER OFFSET) VALUE)
  #+IMach (%P-STORE-CONTENTS (%P-STRUCTURE-OFFSET-INTERNAL POINTER OFFSET) VALUE))

;;; Given a 2-long list, change it into a cons by hacking the cdr codes
;;; Unlike the A machine, the L machine wants CDR-NIL in the cdr cell of a pair.
(DEFSUBST %CHANGE-LIST-TO-CONS (LIST)
  (DECLARE (COMPILER:RETURN-TYPE))
  (%P-STORE-CDR-CODE LIST CDR-NORMAL))


;;; Predicate which is true if the first address is earlier in memory than the second.
#+3600
(DEFSUBST %POINTER-LESSP (P1 P2)
  (MINUSP (%POINTER-DIFFERENCE P1 P2)))

#+IMach
(DEFSUBST %POINTER-LESSP (P1 P2)
  (%UNSIGNED-LESSP P1 P2))

;; These make it easier to think about unsigned arithmetic.
(DEFSUBST %POINTER-< (P1 P2)		(%POINTER-LESSP P1 P2))
(DEFSUBST %POINTER-GREATERP (P1 P2)	(%POINTER-LESSP P2 P1))
(DEFSUBST %POINTER-> (P1 P2)		(%POINTER-LESSP P2 P1))
(DEFSUBST %POINTER- (P1 P2)		(NOT (%POINTER-LESSP P2 P1)))
(DEFSUBST %POINTER- (P1 P2)		(NOT (%POINTER-LESSP P1 P2)))

;; These were stolen from KHS.  They should have optimizers for the case
;; where everything is a constant.  That is,
;; (DPBS 1 (BYTE 8 8) 0 (BYTE 8 0) X) should turn into
;; (DPBS 1_8 (BYTE 16 0) X).
;; Well, maybe.  As long as it doesn't make the L machine generate a PUSH-CONSTANT.

(DEFMACRO %LOGDPBS (&REST VALUES-AND-FIELDS)
  (UNLESS (ODDP (LENGTH VALUES-AND-FIELDS))
    (ERROR "~S must be an odd length list." VALUES-AND-FIELDS))
  (LOOP WITH F-AND-V = (REVERSE VALUES-AND-FIELDS)
	WITH ANSWER = (POP F-AND-V) FINALLY (RETURN ANSWER)
	FOR (FIELD VALUE) ON F-AND-V BY 'CDDR
	DO (SETQ ANSWER `(SYS:%LOGDPB ,VALUE ,FIELD ,ANSWER))))

(DEFMACRO DPBS (&REST VALUES-AND-FIELDS)
  (UNLESS (ODDP (LENGTH VALUES-AND-FIELDS))
    (ERROR "~S must be an odd length list." VALUES-AND-FIELDS))
  (LOOP WITH F-AND-V = (REVERSE VALUES-AND-FIELDS)
	WITH ANSWER = (POP F-AND-V) FINALLY (RETURN ANSWER)
	FOR (FIELD VALUE) ON F-AND-V BY 'CDDR
	DO (SETQ ANSWER `(DPB ,VALUE ,FIELD ,ANSWER))))

(DEFMACRO %LDB (BYTE-SPECIFIER WORD)
  `(%LOGLDB ,BYTE-SPECIFIER (%POINTER ,WORD)))

;Given an instance, get its flavor defstruct
;This gets the instance-descriptor and assumes that it is an array
#+3600
(DEFSUBST %INSTANCE-FLAVOR (INSTANCE)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (%MAKE-POINTER DTP-ARRAY (%P-CONTENTS-AS-LOCATIVE-OFFSET INSTANCE 0)))

#+IMACH
(DEFSUBST %INSTANCE-FLAVOR (INSTANCE)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (%POINTER-PLUS (%SET-TAG (%MEMORY-READ INSTANCE :CYCLE-TYPE %MEMORY-HEADER :SET-CDR-NEXT T)
			   DTP-ARRAY)
		 -3))

;;; This only follows EVCPs on the 3600.  It follows the other kinds of forwarding
;;; pointers on both architectures.  Using forwarding-pointers in weakspace
;;; is not such a hot idea anyway.
(DEFSUBST %WEAK-LINK-CONTENTS (LOCATION &OPTIONAL DEFAULT)
  (DECLARE (VALUES VALUE BOUNDP))
  #+IMACH
  ;; This %MEMORY-READ transports and fetches the contents of the location.
  ;; If a transport trap occurs and the scavenger is in its weak phase, the
  ;; transporter could break the link and change the location to a DTP-NULL.
  ;; Since we only read the location once, there is no danger of inconsistency
  ;; between the DTP-NULL check and the fetch of the contents.
  (LET ((VALUE (%MEMORY-READ LOCATION :CYCLE-TYPE %MEMORY-BIND-READ :SET-CDR-NEXT T)))
    (IF (CL:TYPEP VALUE '(DATA-TYPE DTP-NULL))
	(VALUES DEFAULT NIL)
	(VALUES VALUE T)))
  #+3600
  ;; On the 3600 we don't have as nice a set of subprimitives so we
  ;; are forced to read the location three times.  We have to worry about
  ;; the GC changing the contents of the location between our reads.  
  (WITHOUT-INTERRUPTS				;Don't let the GC break the weak link
    (COMPILER:FOR-EFFECT			;If there is going to be a transport trap,
      (%P-CONTENTS-AS-LOCATIVE LOCATION))	; take it before the BOUNDP check
    (IF (LOCATION-BOUNDP LOCATION)		;Note: LOCATION-BOUNDP does not transport
	(VALUES (LOCATION-CONTENTS LOCATION) T)
	(VALUES DEFAULT NIL))))

(DEFMACRO WITH-READ-ONLY-INHIBITED (&BODY BODY)
  `(UNWIND-PROTECT
       (PROGN (%FUNCALL-IN-AUX-STACK #'%INHIBIT-READ-ONLY)
	      ,@BODY)
     (%FUNCALL-IN-AUX-STACK #'%PERMIT-READ-ONLY)))

(DEFMACRO WITHOUT-ABORTS (STUFF &BODY BODY)
  (DECLARE (ARGLIST ([OPTIONAL-IDENTIFIER] REASON &REST FORMAT-ARGS) &BODY BODY))
  (MULTIPLE-VALUE-BIND (OPTIONS REASON FORMAT-ARGS)
      (COND ((AND (LISTP STUFF) (SI:SOME-STRING (FIRST STUFF)))
	     (VALUES NIL (FIRST STUFF) (CDR STUFF)))
	    ((AND (LISTP STUFF) (SYMBOLP (FIRST STUFF)) (SI:SOME-STRING (SECOND STUFF)))
	     (VALUES `(',(FIRST STUFF)) (SECOND STUFF) (CDDR STUFF)))
	    (T
	     (WARN "~S is invalid in SYS:WITHOUT-ABORTS.~@
	This special form requires its first subform to be a list of an optional identifying~@
	symbol, followed by a FORMAT string, optionally followed by FORMAT arguments."
		   STUFF)
	     (VALUES NIL "(invalid syntax in SYS:WITHOUT-ABORTS)" NIL)))
    `(UNWIND-PROTECT
	 (WITH-STACK-LIST (*WITHOUT-ABORTS-REASON*
			    ,@OPTIONS
			    ,(OR (FORMAT:SIMPLIFY-FORMAT-STRING REASON T)
				 REASON)
			    ,@FORMAT-ARGS)
	   ,@BODY)
       (WHEN *PENDING-PROCESS-ABORTS*
	 (PROCESS::CHECK-PENDING-PROCESS-ABORTS)))))

(DEFMACRO WITH-ABORTS-ENABLED ((&REST IDENTIFIERS) &BODY BODY)
  ;; ZL:LISTP because at least one identifier is required.
  (UNLESS (AND (ZL:LISTP IDENTIFIERS) (EVERY IDENTIFIERS #'SYMBOLP))
    (WARN "~S is invalid in SYS:WITH-ABORTS-ENABLED.~@
	This special form requires a list of one or more symbols, identifying~@
	SYS:WITHOUT-ABORTS forms or UNWIND-PROTECTs, as its first subform."
	  IDENTIFIERS))
  (SETQ BODY (IF (CDR BODY) (CONS 'PROGN BODY) (CAR BODY)))
  (DOLIST (ID IDENTIFIERS)
    (SETQ BODY `(LET ((*WITHOUT-ABORTS-REASON* ',ID)) ,BODY)))
  BODY)

(DEFSUBST N-REGIONS () *NUMBER-OF-ACTIVE-REGIONS*)

;It's an ART-Q-LIST array with a fill-pointer
(DEFSUBST N-AREAS () (FILL-POINTER *AREA-NAME*))

#-CROSS-COMPILATION-ENVIRONMENT
(DEFMACRO ARRAY-USED-AS-FUNCTION (SYMBOL)
  (LET ((STAR-SYMBOL (INTERN (STRING-APPEND #/* (GET-PNAME SYMBOL) #/*))))
    `(DEFSUBST ,SYMBOL (INDEX)
       (AREF ,STAR-SYMBOL INDEX))))

;See AREA-INITIALIZE in the cold-load generator
(ARRAY-USED-AS-FUNCTION AREA-NAME)
(ARRAY-USED-AS-FUNCTION AREA-MAXIMUM-QUANTUM-SIZE)
(ARRAY-USED-AS-FUNCTION AREA-REGION-QUANTUM-SIZE)
(ARRAY-USED-AS-FUNCTION AREA-REGION-LIST)
(ARRAY-USED-AS-FUNCTION AREA-REGION-BITS)

(DEFPROP AREA-MAXIMUM-SIZE AREA-MAXIMUM-QUANTUM-SIZE FAST-STORAGE-QUANTUM-ACCESSOR)
(DEFPROP AREA-MAXIMUM-SIZE DPB FAST-STORAGE-QUANTUM-MULTIPLIER)
(DEFSUBST AREA-MAXIMUM-SIZE (INDEX)
  (* (AREA-MAXIMUM-QUANTUM-SIZE INDEX) %ADDRESS-SPACE-QUANTUM-SIZE))

(DEFPROP AREA-REGION-SIZE AREA-REGION-QUANTUM-SIZE FAST-STORAGE-QUANTUM-ACCESSOR)
(DEFPROP AREA-REGION-SIZE DPB FAST-STORAGE-QUANTUM-MULTIPLIER)
(DEFSUBST AREA-REGION-SIZE (INDEX)
  (* (AREA-REGION-QUANTUM-SIZE INDEX) %ADDRESS-SPACE-QUANTUM-SIZE))

(ARRAY-USED-AS-FUNCTION REGION-QUANTUM-ORIGIN)
(ARRAY-USED-AS-FUNCTION REGION-QUANTUM-LENGTH)
(ARRAY-USED-AS-FUNCTION REGION-FREE-POINTER)
(ARRAY-USED-AS-FUNCTION REGION-GC-POINTER)
(ARRAY-USED-AS-FUNCTION REGION-FREE-POINTER-BEFORE-FLIP)
(ARRAY-USED-AS-FUNCTION REGION-CREATED-PAGES)
(ARRAY-USED-AS-FUNCTION REGION-BITS)
(ARRAY-USED-AS-FUNCTION REGION-LIST-THREAD)
(ARRAY-USED-AS-FUNCTION REGION-AREA)

(ARRAY-USED-AS-FUNCTION DATA-TYPE-NAME)

#+3600(PROGN
(ARRAY-USED-AS-FUNCTION ARRAY-BITS-PER-ELEMENT)
(ARRAY-USED-AS-FUNCTION ARRAY-ELEMENTS-PER-Q)
(ARRAY-USED-AS-FUNCTION ARRAY-TYPES)
(ARRAY-USED-AS-FUNCTION ARRAY-NULL-ELEMENT)
)

(DEFPROP REGION-ORIGIN REGION-QUANTUM-ORIGIN FAST-STORAGE-QUANTUM-ACCESSOR)
(DEFPROP REGION-ORIGIN %LOGDPB FAST-STORAGE-QUANTUM-MULTIPLIER)
(DEFSUBST REGION-ORIGIN (REGION)
  (%LOGDPB (REGION-QUANTUM-ORIGIN REGION) %%VMA-QUANTUM-NUM 0))

(DEFPROP REGION-LENGTH REGION-QUANTUM-LENGTH FAST-STORAGE-QUANTUM-ACCESSOR)
(DEFPROP REGION-LENGTH %LOGDPB FAST-STORAGE-QUANTUM-MULTIPLIER)
(DEFSUBST REGION-LENGTH (REGION)
  (%LOGDPB (REGION-QUANTUM-LENGTH REGION) %%VMA-QUANTUM-NUM 0))

(CL:DEFSETF REGION-ORIGIN (REGION) (VALUE)
  `(SETF (REGION-QUANTUM-ORIGIN ,REGION) (%LOGLDB %%VMA-QUANTUM-NUM ,VALUE)))

(CL:DEFSETF REGION-LENGTH (REGION) (VALUE)
  `(SETF (REGION-QUANTUM-LENGTH ,REGION) (%LOGLDB %%VMA-QUANTUM-NUM ,VALUE)))

#+IMach (ARRAY-USED-AS-FUNCTION ZONE-LEVEL)
#+IMach (ARRAY-USED-AS-FUNCTION DEMILEVEL-LEVEL)
#+IMach (ARRAY-USED-AS-FUNCTION EPHEMERAL-LEVEL-GROUP)
(ARRAY-USED-AS-FUNCTION LEVEL-TYPE)
(ARRAY-USED-AS-FUNCTION OBLAST-FREE-SIZE)

;; This is a little stupid right now, but what the hell.
;; Maybe someone who understands LT can do it right.
(DEFMACRO WITH-FAST-STORAGE-ACCESSORS (NAMES &BODY BODY)
  (LOOP FOR NAME IN NAMES
	AS QUANTUM = (GET NAME 'FAST-STORAGE-QUANTUM-ACCESSOR)
	WHEN QUANTUM DO (PUSH* QUANTUM NAMES))
  (LET* ((NAME-ALIST
	   (LOOP FOR NAME IN NAMES
		 COLLECT (LIST NAME
			       (AND (NOT (GET NAME 'FAST-STORAGE-QUANTUM-ACCESSOR))
				    (INTERN (STRING-APPEND #\. NAME #\.)))
			       (AND (NOT (GET NAME 'FAST-STORAGE-QUANTUM-ACCESSOR))
				    (INTERN (STRING-APPEND #\* NAME #\*)))))))
  `(LET ,(LOOP FOR (NAME INTERNAL-NAME EXTERNAL-NAME) IN NAME-ALIST
	       DO (IGNORE NAME)
	       WHEN INTERNAL-NAME
		 COLLECT `(,INTERNAL-NAME ,EXTERNAL-NAME))
     (DECLARE (ARRAY-REGISTER . ,(LOOP FOR (NIL INTERNAL-NAME) IN NAME-ALIST
				       WHEN INTERNAL-NAME
					 COLLECT INTERNAL-NAME)))
     (MACROLET ,(LOOP FOR (NAME INTERNAL-NAME) IN NAME-ALIST
		      COLLECT (IF (GET NAME 'FAST-STORAGE-QUANTUM-ACCESSOR)
				  `(,NAME (ARG)
				    `(,',(GET NAME 'FAST-STORAGE-QUANTUM-MULTIPLIER)
				      (,',(GET NAME 'FAST-STORAGE-QUANTUM-ACCESSOR) ,ARG)
				      %%VMA-QUANTUM-NUM 0))
				  `(,NAME (ARG) `(AREF ,',INTERNAL-NAME ,ARG))))
       . ,BODY))))

;;; Stuff that is useful in patch files that patch things in SYSDF1
;;; Do not call any of this from source files!

#+3600
(DEFUN ADD-MAGIC-LOCATION (AREA ADDRESS &OPTIONAL TYPE NAME)
  "This does not setup the forwarding pointer; you have to do that yourself"
  (LET* ((ENTRY (ASSQ AREA SYS:*MAGIC-LOCATIONS*))
	 (OLD-BOUNDARY (THIRD ENTRY))
	 (BOUND (%MAKE-POINTER-OFFSET DTP-LOCATIVE ADDRESS 1))
	 (DIFF (%POINTER-DIFFERENCE OLD-BOUNDARY BOUND))
	 (WHERE (%POINTER (SECOND ENTRY))))
    (COND ((LOOP FOR (X Y) IN (CDDDR ENTRY)
		 THEREIS (AND (EQ X TYPE) (EQ Y NAME))
		 DO (INCF WHERE))
	   ;; Already present
	   (UNLESS (= (%POINTER ADDRESS) WHERE)
	     (FERROR "~S expected to be at ~O in ~S, but already present at ~O"
		     NAME ADDRESS AREA WHERE))
	   NIL)
	  (TYPE
	   ;; Add it
	   ;; If the next-free pointer is skewed, don't make it a fatal error
	   ;; so that multiple patches to different systems can be loaded in either order.
	   (COND ((> DIFF -1)			;Space is already allocated
		  (LET ((ELEM (NTH (%POINTER-DIFFERENCE ADDRESS (SECOND ENTRY))
				   (CDDDR ENTRY))))
		    (WHEN (SECOND ELEM)
		      (FERROR "~S expected to be at ~O in ~S, but ~S is there already"
			      NAME ADDRESS AREA (SECOND ELEM)))
		    (SETF (FIRST ELEM) TYPE)
		    (SETF (SECOND ELEM) NAME)))
		 (T				;Allocate some space
		  (LOOP REPEAT (- -1 DIFF)
			DO (RPLACD (LAST ENTRY) (NCONS (LIST NIL NIL))))
		  (RPLACD (LAST ENTRY) (NCONS (LIST TYPE NAME)))
		  (SETF (THIRD ENTRY) BOUND)))
	   ADDRESS)
	  (T
	   ;; Add it, unnamed
	   (UNLESS (PLUSP DIFF)
	     (SETF (THIRD ENTRY) BOUND))
	   BOUND))))

#+3600
(DEFMACRO DEFINE-SYSTEM-COMMUNICATION-VARIABLE
	  (NAME ADDRESS &OPTIONAL (VALUE NAME VALUE-SUPPLIED-P))
  `(PROGN
     (DEFVAR ,NAME)
     (WHEN (ADD-MAGIC-LOCATION 'SYSTEM-COMMUNICATION-AREA ,ADDRESS ':VARIABLE ',NAME)
       ,(IF VALUE-SUPPLIED-P
	    `(%P-STORE-CONTENTS ,ADDRESS ,VALUE)
	    `(WHEN (BOUNDP ',NAME)
	       (%P-STORE-CONTENTS ,ADDRESS ,NAME)))
       (%P-STORE-TAG-AND-POINTER (LOCF (SYMBOL-VALUE-CELL ',NAME))
				 DTP-ONE-Q-FORWARD ,ADDRESS))))

#+3600
(DEFMACRO DEFINE-A-MEMORY-VARIABLE (NAME A-MEMORY-ADDRESS &OPTIONAL VALUE)
  (SETQ A-MEMORY-ADDRESS (+ A-MEMORY-VIRTUAL-ADDRESS A-MEMORY-ADDRESS))
  `(PROGN
     (WHEN (ADD-MAGIC-LOCATION 'SYS:A-MEMORY-VARIABLES ,A-MEMORY-ADDRESS ':VARIABLE ',NAME)
       (%P-STORE-CONTENTS (LOCF (SYMEVAL ',NAME))
			  (%MAKE-POINTER DTP-ONE-Q-FORWARD ,A-MEMORY-ADDRESS))
       (%P-STORE-CONTENTS ,A-MEMORY-ADDRESS ,VALUE))
     (DEFVAR ,NAME)))

#+3600
(DEFMACRO DEFINE-MICROCODE-TRAP-FUNCTION (NAME A-MEMORY-ADDRESS)
  (SETQ A-MEMORY-ADDRESS (+ A-MEMORY-VIRTUAL-ADDRESS A-MEMORY-ADDRESS))
  `(PROGN 'COMPILE
     (WHEN (ADD-MAGIC-LOCATION 'SYS:MICROCODE-CONSTANTS ,A-MEMORY-ADDRESS ':FUNCTION ',NAME)
       (LET ((CELL (FOLLOW-CELL-FORWARDING (FUNCTION-CELL-LOCATION ',NAME) NIL)))
	 (%P-COPY-Q CELL ,A-MEMORY-ADDRESS)
	 (%P-STORE-CONTENTS CELL (%MAKE-POINTER DTP-ONE-Q-FORWARD ,A-MEMORY-ADDRESS))))))

#+3600
(DEFMACRO DEFINE-ESCAPE-FUNCTION-PATCH (NAME ESCAPE-PC-ADDRESS &REST INSTRUCTIONS)
  `(DEFINE-ESCAPE-FUNCTION-PATCH-INTERNAL ',NAME ',ESCAPE-PC-ADDRESS ',INSTRUCTIONS))

;;;--- Fix this before using it!
;;;--- It has to learn about keywords, and should reuse any
;;;--- microcode constants it can find in *magic-locations*.
;;;--- It has to learn about forwarded function/value cells.
#+3600
(DEFUN DEFINE-ESCAPE-FUNCTION-PATCH-INTERNAL (NAME ESCAPE-PC-ADDRESS INSTRUCTIONS)
  (MULTIPLE-VALUE-BIND (ESCAPE-PC CONSTANT-LOCATIONS)
      (L-LISP-COMPILER:ASSEMBLE-ESCAPE-FUNCTION NAME INSTRUCTIONS T)
    (LET ((ESCAPE-FUNCTION (%FIND-STRUCTURE-HEADER ESCAPE-PC)))	;ART-16B array
      (LOOP FOR INST BEING THE ARRAY-ELEMENTS OF ESCAPE-FUNCTION USING (INDEX ADDRESS)
	    AS TEM = (CDR (ASSQ ADDRESS CONSTANT-LOCATIONS))
	    WHEN TEM
	    DO (LOOP WITH ELEM = (ASSQ 'SYS:MICROCODE-ESCAPE-CONSTANTS SYS:*MAGIC-LOCATIONS*)
		     WITH (NIL START END) = ELEM
		     FOR ADDR FIRST START
		       THEN (%MAKE-POINTER-OFFSET DTP-LOCATIVE ADDR 1)
		     DO (COND ((EQ ADDR END)
			       (IF (EQ (CAR TEM) 'QUOTE)
				   (%P-STORE-CONTENTS ADDR (CADR TEM))
				   (%P-STORE-TAG-AND-POINTER ADDR DTP-ONE-Q-FORWARD
				     (FUNCTION-CELL-LOCATION (CADR TEM))))
			       (SETF (THIRD ELEM) 
				     (%MAKE-POINTER-OFFSET DTP-LOCATIVE ADDR 1))
			       (SI:LOOP-FINISH))
			      ((EQ (CAR TEM) 'QUOTE)
			       (AND ( (%P-DATA-TYPE ADDR) DTP-ONE-Q-FORWARD)
				    (EQ (CDR (%MAKE-POINTER DTP-LOCATIVE ADDR)) (CADR TEM))
				    (SI:LOOP-FINISH)))
			      ((AND (= (%P-DATA-TYPE ADDR) DTP-ONE-Q-FORWARD)
				    (EQ (%P-CONTENTS-AS-LOCATIVE ADDR)
					(FUNCTION-CELL-LOCATION (CADR TEM)))
				    (SI:LOOP-FINISH))))
		     FINALLY
		        (SETF (L-LISP-COMPILER:GET-OPERAND INST)
			      (%POINTER-DIFFERENCE ADDR START))
			(ASET INST ESCAPE-FUNCTION ADDRESS)))
      (LET* ((LISP-VARIABLE (WITH-PACKAGE-LOCK PKG-SYSTEM-PACKAGE NIL
			      (INTERN (STRING-APPEND NAME "-ESCAPE-PC") PKG-SYSTEM-PACKAGE)))
	     (A-ESCAPE-PC (+ A-MEMORY-VIRTUAL-ADDRESS ESCAPE-PC-ADDRESS))
	     (LISP-VALUE-CELL (VALUE-CELL-LOCATION LISP-VARIABLE)))
	(COND ((= (%P-DATA-TYPE LISP-VALUE-CELL) DTP-ONE-Q-FORWARD)
	       (UNLESS (= (%POINTER (%P-CONTENTS-AS-LOCATIVE LISP-VALUE-CELL))
			  A-ESCAPE-PC)
		 (FERROR "~S already misdefined as escape pc" LISP-VARIABLE)))
	      (T
	       (%P-STORE-TAG-AND-POINTER LISP-VALUE-CELL DTP-ONE-Q-FORWARD A-ESCAPE-PC)))
	(ADD-MAGIC-LOCATION 'SYS:MICROCODE-ESCAPE-ROUTINES A-ESCAPE-PC
			    ':VARIABLE LISP-VARIABLE)
	(DEFCONST-1-INTERNAL LISP-VARIABLE ESCAPE-PC)))))


;;; Compiled function object functions, here so that they can be present at compile time

(DEFSUBST CCA-ARGS-INFO (CCA)
  (COMPILED-FUNCTION-ARGS-INFO CCA))

(CL:DEFSETF CCA-INSTRUCTION CCA-SET-INSTRUCTION)

#+3600
(PROGN

(DEFSUBST CCA-FUNCTION-CELL (CCA)
  (COMPILED-FUNCTION-FUNCTION-CELL CCA))

(DEFSUBST CCA-EXTRA-INFO (CCA)
  (COMPILED-FUNCTION-EXTRA-INFO CCA))

(DEFSUBST CCA-N-OBJECTS (CCA)
  (COMPILED-FUNCTION-TABLE-SIZE CCA))

(CL:DEFSETF CCA-OBJECT CCA-SET-OBJECT)
(DEFUN (:PROPERTY CCA-OBJECT LOCF) (FORM)
  `(CCA-OBJECT-LOCATION . ,(CDR FORM)))

(CL:DEFSETF COMPILED-FUNCTION-INSTRUCTION COMPILED-FUNCTION-SET-INSTRUCTION)

); End #+3600

#+IMACH(Progn

;;; Should be a SUBST (or just DEFFed), but SETF and LOCF wouldn't work.
(DEFMACRO COMPILED-FUNCTION-FUNCTION-CELL (CCA) `(CCA-FUNCTION-CELL ,CCA))

(DEFSUBST CCA-N-OBJECTS (CCA) CCA 0)

(DEFSUBST CCA-EXTRA-INFO (CCA)
  (LET ((HEADER (%POINTER (%MEMORY-READ CCA :CYCLE-TYPE %MEMORY-HEADER :SET-CDR-NEXT T))))
    (%P-CONTENTS-OFFSET
      CCA (- (%LOGLDB CCA-TOTAL-SIZE HEADER) (%LOGLDB CCA-SUFFIX-SIZE HEADER)))))

(DEFSUBST (CL:SETF CCA-EXTRA-INFO) (CCA NEW-EXTRA-INFO)
  (LET ((HEADER (%POINTER (%MEMORY-READ CCA :CYCLE-TYPE %MEMORY-HEADER :SET-CDR-NEXT T))))
    (CL:SETF (%P-CONTENTS-OFFSET
	       CCA (- (%LOGLDB CCA-TOTAL-SIZE HEADER) (%LOGLDB CCA-SUFFIX-SIZE HEADER)))
	     NEW-EXTRA-INFO)))

(DEFMACRO COMPILED-FUNCTION-EXTRA-INFO (CCA) `(CCA-EXTRA-INFO ,CCA))

;;; Should be a SUBST (or just DEFFed), but SETF and LOCF wouldn't work.
(DEFMACRO COMPILED-FUNCTION-TOTAL-SIZE (CCA) `(CCA-TOTAL-SIZE ,CCA))

); End #+IMACH

(DEFSUBST LEXICAL-MAP-VARIABLE-GENERATION (DESCRIPTOR)
  (LDB (BYTE 8 8) DESCRIPTOR))

(DEFSUBST LEXICAL-MAP-VARIABLE-LOCATION (DESCRIPTOR)
  (LDB (BYTE 8 0) DESCRIPTOR))

;;; Stack groups
(DEFSUBST SG-RESUMABLE-P (SG)
  (ZEROP (SG-NONRESUMABILITY SG)))

(DEFSUBST SG-NEVER-RUN (SG)
  (NOT (ZEROP (SG-UNINITIALIZED-BIT SG))))

(DEFUN DECLARE-SAFEGUARDED-IF-NECESSARY (DECLS)
  ;; Insert a SAFEGUARDED-FUNCTION declaration if one isn't already there.
  (LOOP NAMED TOP FOR FORM IN DECLS
	WHEN (AND (CL:CONSP FORM)
		  (EQ (CAR FORM)
		      #+CROSS-COMPILER-ENVIRONMENT 'L:CL:DECLARE
		      #-CROSS-COMPILER-ENVIRONMENT 'CL:DECLARE
		      ))
	  DO (LOOP FOR DECL IN (CDR FORM)
		   WHEN (CL:FIND (CAR DECL) *FUNCTION-CATEGORY-DECLARATIONS*)
		     DO (RETURN-FROM TOP DECLS))
	FINALLY
	  (RETURN (CONS '(DECLARE (SAFEGUARDED-FUNCTION)) DECLS))))

#+IMACH
(DEFMACRO RETURN-KLUDGE-BODY (FSPEC FIRST-FORM REAL-BODY)
  ;; Try to find an appropriate block name
  (LET ((BLOCK (LOOP FOR BLOCK = FSPEC THEN (SECOND BLOCK) DO
		 (COND ((NULL BLOCK) (RETURN NIL))
		       ((SYMBOLP BLOCK) (RETURN BLOCK))
		       ((NOT (LISTP BLOCK)) (RETURN NIL))
		       ((NOT (LISTP (CDR BLOCK))) (RETURN NIL))))))
    `(RETURN-KLUDGE
       ,(IF BLOCK
	    `(BLOCK ,BLOCK ,FIRST-FORM ,@(CDR REAL-BODY))
	    `(PROGN ,FIRST-FORM ,@(CDR REAL-BODY))))))

#+IMACH
(DEFMACRO DEFUN-HANDLER (FSPEC ARGUMENTS RETURNED-VALUES NAME &BODY BODY)
  (MULTIPLE-VALUE-BIND (DECLARATIONS REAL-BODY FIRST-FORM)
      (SYS:FIND-BODY-DECLARATIONS BODY NIL)
    (LET ((CALLER-FSPEC (INTERN (STRING-APPEND FSPEC "-TRAP-HANDLER"))))
      `(MULTIPLE-DEFINITION ,FSPEC DEFUN-HANDLER
	 (DEFSUBST ,FSPEC ,ARGUMENTS
	   (DECLARE (FUNCTION-PARENT ,FSPEC DEFUN-HANDLER))
	   (,CALLER-FSPEC NIL NIL ,@ARGUMENTS))
	 (CL:PROCLAIM
	   '(COMPILER:NUMBER-OF-RETURNED-VALUES ,RETURNED-VALUES ,CALLER-FSPEC))
	 (DEFUN ,CALLER-FSPEC (.INDEX. .PC. ,@ARGUMENTS)
	   (DECLARE (FUNCTION-PARENT ,FSPEC DEFUN-HANDLER))
	   ,@(DECLARE-SAFEGUARDED-IF-NECESSARY DECLARATIONS)
	   .INDEX. .PC.
	   (RETURN-KLUDGE-BODY ,(OR NAME FSPEC) ,FIRST-FORM ,REAL-BODY))))))

#+3600
(DEFMACRO DEFUN-HANDLER (FSPEC ARGUMENTS RETURNED-VALUES NAME &BODY BODY)
  (DECLARE (IGNORE RETURNED-VALUES NAME))
  `(MULTIPLE-DEFINITION ,FSPEC DEFUN-HANDLER
     (DEFUN ,FSPEC ,ARGUMENTS
       (DECLARE (FUNCTION-PARENT ,FSPEC DEFUN-HANDLER))
       ,@BODY)))

#+IMACH
(DEFMACRO DEF-TRAP-HANDLER (FSPEC (VECTOR-ENTRIES MODE) ARGUMENTS &BODY BODY)
  (WHEN (SYMBOLP VECTOR-ENTRIES)		;Works for T, too.
    (SETQ VECTOR-ENTRIES (LIST VECTOR-ENTRIES)))
  (MULTIPLE-VALUE-BIND (DECLARATIONS REAL-BODY FIRST-FORM)
      (SYS:FIND-BODY-DECLARATIONS BODY NIL)
    `(MULTIPLE-DEFINITION ,FSPEC DEF-TRAP-HANDLER
       (DEFUN ,FSPEC ,ARGUMENTS
	 (DECLARE (FUNCTION-PARENT ,FSPEC DEF-TRAP-HANDLER))
	 ,@(DECLARE-SAFEGUARDED-IF-NECESSARY DECLARATIONS)
	 (RETURN-KLUDGE-BODY ,FSPEC ,FIRST-FORM ,REAL-BODY))
       ,@(LOOP FOR VECTOR-ENTRY IN VECTOR-ENTRIES COLLECTING
	   `(SET-TRAP-VECTOR-ENTRY ,VECTOR-ENTRY ,MODE ',FSPEC
				   ,(NOT (NULL (OR (MEMBER '&REST ARGUMENTS)
						   (MEMBER '&KEY ARGUMENTS)
						   (MEMBER '&OPTIONAL ARGUMENTS)))))))))

#+IMACH
(DEFMACRO DEFINE-TRAP-HANDLER ((FSPEC &KEY TRAP-VECTOR (TRAP-MODE 0) WIRED)
			       ARGUMENTS
			       &BODY BODY)
  (MULTIPLE-VALUE-BIND (DECLARATIONS REAL-BODY FIRST-FORM)
      (SYS:FIND-BODY-DECLARATIONS BODY NIL)
    ;; Try to find the appropriate block name for this
    `(MULTIPLE-DEFINITION ,FSPEC DEFINE-TRAP-HANDLER
       (DEFUN ,FSPEC ,ARGUMENTS
	 (DECLARE (FUNCTION-PARENT ,FSPEC DEFINE-TRAP-HANDLER))
	 ,@(IF WIRED
	       `((DECLARE (WIRED-FUNCTION)) . ,DECLARATIONS)
	       (DECLARE-SAFEGUARDED-IF-NECESSARY DECLARATIONS))
	 (RETURN-KLUDGE-BODY ,FSPEC ,FIRST-FORM ,REAL-BODY))
       (SET-TRAP-VECTOR-ENTRY ,TRAP-VECTOR ,TRAP-MODE ',FSPEC
			      ,(NOT (NULL (OR (MEMBER '&REST ARGUMENTS)
					      (MEMBER '&KEY ARGUMENTS)
					      (MEMBER '&OPTIONAL ARGUMENTS))))))))

#+IMACH
(DEFMACRO DEFINE-INSTRUCTION-EXCEPTION-HANDLER (INSTRUCTION MODE ARGS &BODY BODY)
  ;; Look for &PC and &INDEX keywords in the arguments
  (LET ((ARGLIST
	  (LOOP WITH REAL-ARGS = NIL
		WITH ARGS = ARGS
		WITH PC = '#:PC
		WITH INDEX = '#:INDEX
		UNTIL (NULL ARGS)
		DOING
	    (LET ((FIRST (POP ARGS)))
	      (SELECTQ FIRST
		(&PC (SETQ PC (POP ARGS)))
		(&INDEX (SETQ INDEX (POP ARGS)))
		(OTHERWISE (PUSH FIRST REAL-ARGS))))
		FINALLY (RETURN `(,INDEX ,PC ,@(NREVERSE REAL-ARGS)))))
	(OPCODE (ILC:OPCODE-FOR-INSTRUCTION INSTRUCTION))
	(FSPEC (INTERN (STRING-APPEND INSTRUCTION "-TRAP-HANDLER"))))
    (MULTIPLE-VALUE-BIND (DECLARATIONS REAL-BODY FIRST-FORM)
	(SYS:FIND-BODY-DECLARATIONS BODY NIL)
      `(MULTIPLE-DEFINITION ,INSTRUCTION DEFINE-INSTRUCTION-EXCEPTION-HANDLER
	 (DEFUN ,FSPEC ,ARGLIST
	   (DECLARE (FUNCTION-PARENT ,INSTRUCTION DEFINE-INSTRUCTION-EXCEPTION-HANDLER))
	   ,@(DECLARE-SAFEGUARDED-IF-NECESSARY DECLARATIONS)
	   ,(FIRST ARGLIST) ,(SECOND ARGLIST)
	   (RETURN-KLUDGE-BODY ,FSPEC ,FIRST-FORM ,REAL-BODY))
	 (SET-TRAP-VECTOR-ENTRY ,(+ OPCODE %INSTRUCTION-EXCEPTION-VECTOR)
				,MODE ',FSPEC
				,(NOT (NULL (OR (MEMBER '&REST ARGLIST)
						(MEMBER '&KEY ARGLIST)
						(MEMBER '&OPTIONAL ARGLIST)))))))))

#+IMACH
(DEFMACRO DEF-INTERPRETER-FUNCTION (DATA-TYPE ARGS &BODY BODY)
  (LET ((NAME (IF (SYMBOLP ARGS)
		  ARGS
		  `(:PROPERTY ,DATA-TYPE INTERPRETER-FUNCTION))))
    `(MULTIPLE-DEFINITION ,DATA-TYPE DEF-INTERPRETER-FUNCTION
       ,(UNLESS (SYMBOLP ARGS)
	  (MULTIPLE-VALUE-BIND (DECLS REAL-BODY)
	      (SYS:FIND-BODY-DECLARATIONS BODY NIL)
	    `(DEFUN ,NAME ,ARGS
	       (DECLARE (FUNCTION-PARENT ,DATA-TYPE DEF-INTERPRETER-FUNCTION))
	       ,@(DECLARE-SAFEGUARDED-IF-NECESSARY DECLS)
	       ,@REAL-BODY)))
       (SET-TRAP-VECTOR-ENTRY ,(+ (SYMEVAL DATA-TYPE) %INTERPRETER-FUNCTION-VECTOR)
			      TRAP-MODE-EMULATOR ',NAME T))))

#+IMACH
(DEFMACRO DEF-FLAVOR-INTERPRETER-FUNCTION (DATA-TYPE HANDLER)
  (LET ((NAME `(:PROPERTY ,DATA-TYPE INTERPRETER-FUNCTION)))
    `(MULTIPLE-DEFINITION ,DATA-TYPE DEF-FLAVOR-INTERPRETER-FUNCTION
       (DEFUN (:PROPERTY ,DATA-TYPE INTERPRETER-FUNCTION) ()
	 (DECLARE ;(SAFEGUARDED-FUNCTION)	;would be enough
		  (WIRED-FUNCTION) 		;avoid map-cache turbulence
		  (FUNCTION-PARENT ,DATA-TYPE DEF-FLAVOR-INTERPRETER-FUNCTION))
	 (WHEN ( (%READ-INTERNAL-REGISTER %REGISTER-CR.ARGUMENT-SIZE) 4.)
	   (,HANDLER))
	 (,(SELECTQ HANDLER
	     (%GENERIC-DISPATCH '%GENERIC-DISPATCH-PULL)
	     (%MESSAGE-DISPATCH '%MESSAGE-DISPATCH-PULL)))
	 (,HANDLER))
       (SET-TRAP-VECTOR-ENTRY ,(+ (SYMEVAL DATA-TYPE) %INTERPRETER-FUNCTION-VECTOR)
			      TRAP-MODE-EMULATOR ',NAME))))

;;;; Wired objects, mostly looked at specially by the cold load generator.

;;; Modern defining forms and declarations.

;;; like sys:define-meters, but creates wired meters
(DEFMACRO DEFINE-WIRED-METERS (METER-LIST-NAME . METER-NAMES)
  (DECLARE (ARGLIST METER-LIST-NAME &REST METER-NAMES))
  `(LOCAL-DECLARE ((SYS:FUNCTION-PARENT ,METER-LIST-NAME 'DEFINE-METERS))
     ;;--- avoid rebuilding the cold load for this, remove post-328
     (UNLESS (VARIABLE-BOUNDP *ALL-METER-SETS*) (SETQ *ALL-METER-SETS* NIL))
     (PUSH* ',METER-LIST-NAME *ALL-METER-SETS*)
     (RECORD-SOURCE-FILE-NAME ',METER-LIST-NAME 'DEFINE-METERS)
     (DEFCONST ,METER-LIST-NAME ',METER-NAMES)
     ,@(LOOP FOR METER-NAME IN METER-NAMES COLLECT `(DEFWIREDVAR ,METER-NAME 0))))


(DEFMACRO WITH-STACK-LEXICAL-CLOSURE ((VAR ENVIRONMENT FUNCTION) &BODY BODY)
  `(WITH-STACK-LIST* (,VAR ,ENVIRONMENT ,FUNCTION)
     (SETF ,VAR (%MAKE-POINTER DTP-LEXICAL-CLOSURE ,VAR))
     ,@BODY))

;A convenience macro to make the code easier to read
;Install this somewhere more prominent?
(DEFMACRO BUILD-DEFSTORAGE-WORD (&REST FIELDS-AND-VALUES)
  (IF (NULL FIELDS-AND-VALUES) 0
      `(%LOGDPB ,(SECOND FIELDS-AND-VALUES) (DEFSTORAGE-FIELD-BYTE ,(FIRST FIELDS-AND-VALUES))
		(BUILD-DEFSTORAGE-WORD . ,(CDDR FIELDS-AND-VALUES)))))

#+IMACH
(PROGN
(DEFSUBST ARRAY-ELEMENTS-PER-Q (ARRAY-TYPE)
  (ROT 1 (%LOGLDB %%ARRAY-TYPE-BYTE-PACKING ARRAY-TYPE)))

(DEFSUBST %ARRAY-BITS-PER-ELEMENT (ARRAY-TYPE)
  (ROT 1 (- 5 (%LOGLDB %%ARRAY-TYPE-BYTE-PACKING ARRAY-TYPE))))

(DEFSUBST ARRAY-BITS-PER-ELEMENT (ARRAY-TYPE)
  (AND ( (LDB %%ARRAY-TYPE-ELEMENT-TYPE ARRAY-TYPE) ARRAY-ELEMENT-TYPE-OBJECT)
       (%ARRAY-BITS-PER-ELEMENT ARRAY-TYPE)))

(DEFSUBST ARRAY-ELEMENT-WORDS (LENGTH ARRAY-TYPE)
  (LSH (+ LENGTH (ARRAY-ELEMENTS-PER-Q ARRAY-TYPE) -1)
       (- (%LOGLDB %%ARRAY-TYPE-BYTE-PACKING ARRAY-TYPE))))
);End #+IMACH

(DEFMACRO FEATURE-CASE (&BODY CLAUSES &AUX OTHERWISE-PRESENT)
  (LABELS ((%PARSE-TYPES (EXPRESSION)
	     (TYPECASE EXPRESSION
	       (:LIST
		 (LET ((OPERAND (CAR EXPRESSION)))
		   (CL:CASE OPERAND
		     ((AND OR) (LIST* OPERAND (MAPCAR #'%PARSE-TYPES (CL:REST EXPRESSION))))
		     (NOT (WHEN (CDDR EXPRESSION) (PARSE-TYPES-ERROR EXPRESSION))
			  `(NOT ,(%PARSE-TYPES (SECOND EXPRESSION))))
		     (OTHERWISE (PARSE-TYPES-ERROR EXPRESSION)))))
	       (OTHERWISE `(CL:MEMBER ,EXPRESSION CL:*FEATURES*))))
           (PARSE-TYPES-ERROR (EXPRESSION)
	     (WARN NIL "Invalid clause ~S will be skipped in FEATURE-CASE" EXPRESSION)
	     (THROW :SKIP-INVALID-CLAUSE NIL))
	   (PARSE-TYPES (EXPRESSION)
	     (COND
	       ((AND (CL:CONSP EXPRESSION)
		     (NOT (CL:MEMBER (CAR EXPRESSION) '(AND OR NOT))))
		`(CLI::INTERSECTION-P ',EXPRESSION CL:*FEATURES*))
	       ((OR (EQ EXPRESSION 'T)
		    (EQ EXPRESSION 'OTHERWISE))
		(SETQ OTHERWISE-PRESENT 'T))
	       (T (CATCH :SKIP-INVALID-CLAUSE (%PARSE-TYPES EXPRESSION))))))
    `(COND ,@(LOOP FOR (TYPES . REST) IN CLAUSES
		   UNTIL OTHERWISE-PRESENT
		   COLLECT `(,(PARSE-TYPES TYPES) ,@REST))
	   ,(LET ((FEATURES
		    (IF OTHERWISE-PRESENT
			(LOOP AS CLAUSES ON CLAUSES
			      AS TYPES = (CAAR CLAUSES)
			      UNTIL (CL:MEMBER TYPES '(T OTHERWISE))
			      FINALLY
				(LOOP FOR CLAUSE IN (CDR CLAUSES) DO
				  (WARN '(:BAD-STYLE T)
					"~S clause in FEATURE-CASE follows an OTHERWISE clause."
					CLAUSE)))
			(LOOP AS CLAUSES ON CLAUSES
			      AS TYPES = (CAAR CLAUSES)
			      APPEND (IF (AND (CL:LISTP TYPES)
					      (NOT (CL:MEMBER (CAR TYPES) '(AND OR NOT))))
					 TYPES
					 (LIST TYPES))))))
		(UNLESS OTHERWISE-PRESENT
		  `(T (ERROR
		      ,(IF (CDR FEATURES)
			   (FORMAT NIL "None of the features ~{~S~^, ~} are present."
				   FEATURES)
			   (FORMAT NIL "The feature ~S is not present."
				   (FIRST FEATURES))))))))))

#+(AND IMACH (NOT VLM))
(DEFCONST *REQUIRED-SYSTEM-TYPES*
	  '(%SYSTEM-TYPE-MACIVORY-1&2 %SYSTEM-TYPE-MACIVORY-3
	    %SYSTEM-TYPE-ZORA
	    %SYSTEM-TYPE-XL400  %SYSTEM-TYPE-UX400S  %SYSTEM-TYPE-UX400G
	    %SYSTEM-TYPE-XL1200 %SYSTEM-TYPE-UX1200S %SYSTEM-TYPE-UX1200G
	    %SYSTEM-TYPE-NXP1000
	    ))

#+(AND IMACH VLM)
(DEFCONST *REQUIRED-SYSTEM-TYPES*
	  '(%SYSTEM-TYPE-ALPHA-VLM
	    ))

;;; The next two definitions must define the same set of abbreviations for both
;;; the VLM and I-machine architectures.  Of course, the expansion of each
;;; abbreviation will be different ...

#+(AND IMACH (NOT VLM))
(DEFCONST *SYSTEM-TYPE-ABBREVIATIONS*
	  ;; The union of EMBEDDED and NATIVE should include all system types.
	  '((EMBEDDED . (%SYSTEM-TYPE-MACIVORY-1&2 %SYSTEM-TYPE-MACIVORY-3
			 %SYSTEM-TYPE-UX400S %SYSTEM-TYPE-UX400G
			 %SYSTEM-TYPE-UX1200S %SYSTEM-TYPE-UX1200G))
	    (NATIVE . (%SYSTEM-TYPE-XL400 %SYSTEM-TYPE-XL1200 %SYSTEM-TYPE-ZORA
		       %SYSTEM-TYPE-NXP1000))
	    (VME . (%SYSTEM-TYPE-XL400 %SYSTEM-TYPE-UX400S %SYSTEM-TYPE-UX400G
		    %SYSTEM-TYPE-XL1200 %SYSTEM-TYPE-UX1200S %SYSTEM-TYPE-UX1200G))
	    ;; MERLIN is the union of MERLIN-I and MERLIN-II
	    (MERLIN . (%SYSTEM-TYPE-XL400 %SYSTEM-TYPE-UX400S %SYSTEM-TYPE-UX400G
		       %SYSTEM-TYPE-XL1200 %SYSTEM-TYPE-UX1200S %SYSTEM-TYPE-UX1200G))
	    (MERLIN-I . (%SYSTEM-TYPE-XL400 %SYSTEM-TYPE-UX400S %SYSTEM-TYPE-UX400G))
	    (MERLIN-II . (%SYSTEM-TYPE-XL1200 %SYSTEM-TYPE-UX1200S %SYSTEM-TYPE-UX1200G))
	    (SOLSTICE . (%SYSTEM-TYPE-UX400S %SYSTEM-TYPE-UX400G
			 %SYSTEM-TYPE-UX1200S %SYSTEM-TYPE-UX1200G))
	    ;; UX is the documented synonym for Solstice
	    (UX . (%SYSTEM-TYPE-UX400S %SYSTEM-TYPE-UX400G
		   %SYSTEM-TYPE-UX1200S %SYSTEM-TYPE-UX1200G))
	    (MACIVORY . (%SYSTEM-TYPE-MACIVORY-1&2 %SYSTEM-TYPE-MACIVORY-3))
	    (DOMINO . (%SYSTEM-TYPE-NXP1000))
	    (VLM . ())
	    ))

#+(AND IMACH VLM)
(DEFCONST *SYSTEM-TYPE-ABBREVIATIONS*
	  ;; The union of EMBEDDED and NATIVE should include all system types.
	  '((EMBEDDED . (%SYSTEM-TYPE-ALPHA-VLM))
	    (NATIVE . ())
	    (VME . ())
	    ;; MERLIN is the union of MERLIN-I and MERLIN-II
	    (MERLIN . ())
	    (MERLIN-I . ())
	    (MERLIN-II . ())
	    (SOLSTICE . ())
	    ;; UX is the documented synonym for Solstice
	    (UX . ())
	    (MACIVORY . ())
	    (DOMINO . ())
	    (VLM . (%SYSTEM-TYPE-ALPHA-VLM))
	    ))

#+(AND IMACH (NOT VLM))
(DEFCONST *ORIGINAL-POSSIBLE-SYSTEM-TYPES*
	  (MAPCAR #'(LAMBDA (X) (LDB (BYTE 8 0) X))
		  (LIST %SYSTEM-TYPE-UX400G %SYSTEM-TYPE-XL400 %SYSTEM-TYPE-MACIVORY-1&2
			%SYSTEM-TYPE-UX400S %SYSTEM-TYPE-ZORA %SYSTEM-TYPE-XL1200
			%SYSTEM-TYPE-UX1200S %SYSTEM-TYPE-UX1200G %SYSTEM-TYPE-MACIVORY-3
			%SYSTEM-TYPE-NXP1000)))

#+(AND IMACH VLM)
(DEFCONST *ORIGINAL-POSSIBLE-SYSTEM-TYPES*
	  (MAPCAR #'(LAMBDA (X) (LDB (BYTE 8 0) X))
		  (LIST %SYSTEM-TYPE-ALPHA-VLM)))

#+IMACH
(DEFMACRO SYSTEM-CASE (&BODY CLAUSES)
  (SYSTEM-CASE-EXPANDER *REQUIRED-SYSTEM-TYPES* *ORIGINAL-POSSIBLE-SYSTEM-TYPES* CLAUSES
			'SELECT '*SYSTEM-TYPE* *SYSTEM-TYPE-ABBREVIATIONS*
			#'(LAMBDA (ERROR-MSG)
			    `(WIRED-FERROR :PROCEEDABLE-HALT ,ERROR-MSG))
			'ERROR
			'FUTURE-COMMON-LISP:ERROR))

#+IMACH
(DEFUN SYSTEM-CASE-EXPANDER (ORIGINAL-REQUIRED-SYSTEM-TYPES ORIGINAL-POSSIBLE-TYPES-SUBSET
			     CLAUSES CASE-MACRO SYSTEM-TYPE-VARIABLE SYSTEM-TYPE-ABBREVIATIONS
			     ERROR-CLAUSE-GENERATOR
			     &REST ERROR-SYMBOLS)
  (DECLARE (DOWNWARD-FUNARG ERROR-CLAUSE-GENERATOR))
  (LET ((REQUIRED-SYSTEM-TYPES (COPYLIST ORIGINAL-REQUIRED-SYSTEM-TYPES))
	(POSSIBLE-TYPES-SUBSET (COPYLIST ORIGINAL-POSSIBLE-TYPES-SUBSET))
	(HANDLED-SYSTEM-TYPES NIL)
	(NEVER-SYSTEM-TYPES NIL)
	(OTHERWISE NIL)
	(OUTPUT-CLAUSES NIL))
    (LABELS ((OTHERWISE-CLAUSE-P (KEY)
	       (MEMBER KEY '(OTHERWISE T)))
	     (ERROR-CLAUSE-P (FORMS)
	       (AND (= (LENGTH FORMS) 1)
		    (LISTP (CAR FORMS))
		    (= (LENGTH (CAR FORMS)) 1)
		    (CL:MEMBER (CAAR FORMS) ERROR-SYMBOLS)))
	     (TYPE-VALUE (SYMBOL)
	       ;; Stripping off bit 9 results in more efficient code
	       (LDB (BYTE 8 0) (COMPILER:CONSTANT-EVALUATOR SYMBOL)))
	     (CONVERT (KEY &OPTIONAL (TYPE :HANDLED))
	       (LET* ((CONSTANT (CL:FIND-SYMBOL (STRING-APPEND "%SYSTEM-TYPE-" KEY)
						PKG-SYSTEM-PACKAGE))
		      (ELEM (CL:ASSOC KEY SYSTEM-TYPE-ABBREVIATIONS :TEST #'STRING-EQUAL))
		      (LIST (COND (ELEM (CDR ELEM))
				  (CONSTANT (LIST CONSTANT))
				  (T (WARN "~A is not a defined system type" KEY)
				     '()))))
		 (SETQ REQUIRED-SYSTEM-TYPES (CL:SET-DIFFERENCE REQUIRED-SYSTEM-TYPES LIST))
		 (CL:ECASE TYPE
		   (:HANDLED
		     (SETQ HANDLED-SYSTEM-TYPES (CL:UNION HANDLED-SYSTEM-TYPES LIST)))
		   (:NEVER
		     (SETQ NEVER-SYSTEM-TYPES (CL:UNION NEVER-SYSTEM-TYPES LIST))))
		 (MAPCAR #'TYPE-VALUE LIST))))
      ;; Strip out (ERROR) clauses, so that they report the standard error, but
      ;; still count in HANDLED-SYSTEM-TYPES.
      ;; This is only applicable when there is no OTHERWISE clause.
      (UNLESS (AND (OTHERWISE-CLAUSE-P (CAAR (LAST CLAUSES)))
		   (NOT (ERROR-CLAUSE-P (CDAR (LAST CLAUSES)))))
	(LOOP FOR CLAUSE IN CLAUSES
	      AS (KEY . FORMS) = CLAUSE DO
	  (MULTIPLE-VALUE-BIND (IS-ERROR-CLAUSE REAL-KEYS)
	      (COND ((OTHERWISE-CLAUSE-P KEY)
		     (VALUES NIL NIL))
		    ((ERROR-CLAUSE-P FORMS)
		     (VALUES T KEY))
		    ((AND (ATOM KEY)
			  (OR (NULL KEY)
			      (STRING-EQUAL (CL:SYMBOL-NAME KEY) "NEVER")))
		     (VALUES T FORMS))
		    (T
		     (VALUES NIL NIL)))
	    (WHEN IS-ERROR-CLAUSE
	      (IF (CL:LISTP REAL-KEYS)
		  (DOLIST (KEY REAL-KEYS)
		    (CONVERT KEY :NEVER))
		  (CONVERT KEY :NEVER))
	      (SETQ CLAUSES (REMOVE CLAUSE CLAUSES))))))
      ;; Generate the individual clauses -- If we're expanding a recursive SYSTEM-CASE,
      ;; don't generate clauses which do not match at least one of the types specified
      ;; in the outer SYSTEM-CASE's containing clause.  (Those types are passed to us
      ;; in our ORIGINAL-POSSIBLE-TYPES-SUBSET argument.)
      (LOOP WITH NEVER-SYSTEM-TYPE-VALUES = (MAPCAR #'TYPE-VALUE NEVER-SYSTEM-TYPES)
	    FOR (KEY . FORMS) IN CLAUSES
	    DO
	(LET ((KEY (COND ((OTHERWISE-CLAUSE-P KEY)
			  (COND ((ERROR-CLAUSE-P FORMS)
				 (SETQ REQUIRED-SYSTEM-TYPES NIL)
				 NIL)
				(T
				 (SETQ OTHERWISE T)
				 KEY)))
			 ((CL:LISTP KEY)
			  (MAPCAN #'CONVERT KEY))
			 (T (CONVERT KEY)))))
	  (IF (CL:LISTP KEY)
	      (LET* ((KEY (CL:REMOVE-IF #'(LAMBDA (X) (CL:MEMBER X NEVER-SYSTEM-TYPE-VALUES))
					(IF POSSIBLE-TYPES-SUBSET
					    (CL:INTERSECTION KEY POSSIBLE-TYPES-SUBSET)
					    KEY)))
		     (REQUIRED-SYSTEM-TYPES-SUBSET
		       (CL:REMOVE-IF-NOT #'(LAMBDA (X) (CL:MEMBER (TYPE-VALUE X) KEY))
					 ORIGINAL-REQUIRED-SYSTEM-TYPES)))
		(WHEN KEY
		  (PUSH `(,KEY
			  (MACROLET ((SYSTEM-CASE (&BODY CLAUSES)
				       (SYSTEM-CASE-EXPANDER ',REQUIRED-SYSTEM-TYPES-SUBSET
							     ',KEY
							     CLAUSES
							     ',CASE-MACRO
							     ',SYSTEM-TYPE-VARIABLE
							     ',SYSTEM-TYPE-ABBREVIATIONS
							     ,ERROR-CLAUSE-GENERATOR
							     ,@(MAPCAR
								 #'(LAMBDA (X) `',X)
								 ERROR-SYMBOLS))))
			    ,@FORMS))
			OUTPUT-CLAUSES))
		(SETQ POSSIBLE-TYPES-SUBSET (CL:SET-DIFFERENCE POSSIBLE-TYPES-SUBSET KEY)))
	      (PUSH (CONS KEY FORMS) OUTPUT-CLAUSES)))
	    FINALLY
	      (SETQ OUTPUT-CLAUSES (NREVERSE OUTPUT-CLAUSES)))
      ;; If we're expanding a recursive SYSTEM-CASE and the first clause that we'll generate
      ;; matches all of the types specified in the outer SYSTEM-CASE's containing clause,
      ;; expand into just the forms of that clause without the redundant SELECT form.
      (WHEN (CL:LISTP (FIRST (FIRST OUTPUT-CLAUSES)))
	(DESTRUCTURING-BIND (KEY . FORMS) (FIRST OUTPUT-CLAUSES)
	  (WHEN (AND (CL:EVERY (LAMBDA (X) (CL:MEMBER X ORIGINAL-POSSIBLE-TYPES-SUBSET)) KEY)
		     (CL:EVERY (LAMBDA (X) (CL:MEMBER X KEY)) ORIGINAL-POSSIBLE-TYPES-SUBSET))
	    (RETURN-FROM SYSTEM-CASE-EXPANDER
	      `(PROGN ,@FORMS)))))
      ;; Generate an efficient SELECT form.
      `(,CASE-MACRO (LDB (BYTE 8 0) ,SYSTEM-TYPE-VARIABLE)
	 ,@OUTPUT-CLAUSES
	 ,@(UNLESS (OR OTHERWISE
		       (AND ORIGINAL-POSSIBLE-TYPES-SUBSET (NULL POSSIBLE-TYPES-SUBSET)))
	     ;; Generate an OTHERWISE clause if the user didn't supply one unless we're
	     ;; expanding a recursive SYSTEM-CASE and all of the types specified in the
	     ;; outer SYSTEM-CASE's containing clause we're mentioned in this SYSTEM-CASE.
	     (WHEN REQUIRED-SYSTEM-TYPES
	       (WARN "SYSTEM-CASE clause~P for ~{~A~^, ~} must be supplied."
		     (LENGTH REQUIRED-SYSTEM-TYPES)
		     (MAPCAR #'(LAMBDA (X) (SUBSTRING X #.(CL:LENGTH "%SYSTEM-TYPE-")))
			     REQUIRED-SYSTEM-TYPES)))
	     (SETQ HANDLED-SYSTEM-TYPES (CL:SET-DIFFERENCE HANDLED-SYSTEM-TYPES
							   NEVER-SYSTEM-TYPES))
	     `((OTHERWISE
		 ,(FUNCALL ERROR-CLAUSE-GENERATOR
			   (WITH-OUTPUT-TO-STRING (S)
			     (PRINC "The system is not " S)
			     (IF (= (LENGTH HANDLED-SYSTEM-TYPES) 1)
				 (CL:WRITE-STRING (STRING (FIRST HANDLED-SYSTEM-TYPES)) S
						  :START #.(CL:LENGTH "%SYSTEM-TYPE-"))
			       (PRINC "one of " S)
			       (LOOP FOR (X . MORE) ON HANDLED-SYSTEM-TYPES DO
				 (CL:WRITE-STRING (STRING X) S
						  :START #.(CL:LENGTH "%SYSTEM-TYPE-"))
				 (WHEN MORE (PRINC ", " S)))))))))))))

#+IMACH
(DEFMACRO WRITE-MACIVORY-REGISTER (REGISTER VALUE)
  `(SYS:SYSTEM-CASE
     (MacIvory-1&2
       (%COPROCESSOR-WRITE ,VALUE ,(+ #O1000 REGISTER)))
     (MacIvory-3
       (%MEMORY-WRITE ,(%MAKE-PHYSICAL-ADDRESS (%LOGDPB 2 (BYTE 2 30.) REGISTER)) ,VALUE))
     (OTHERWISE NIL)))

;;;; Support for bit shuffling hardware

#+IMACH
(DEFCONSTANT %BIT-SHUFFLING-MODE 0)

#+IMACH
(DEFCONSTANT %NIBBLE-SHUFFLING-MODE 1)

#+IMACH
(DEFCONSTANT %BYTE-SHUFFLING-MODE 2)

#+IMACH
(DEFCONSTANT %FIXNUM-SHUFFLING-MODE 3)

#+IMACH
(DEFCONSTANT %SINGLE-FLOAT-SHUFFLING-MODE 4)

#+IMACH
;;; Convert symbols to numbers for the benefit of wired, safeguarded code
(DEFUN ENCODE-BIT-SHUFFLING-MODE (SYMBOL)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE REDUCIBLE))
  (CL:ECASE SYMBOL
    (:BIT %BIT-SHUFFLING-MODE)
    (:NIBBLE %NIBBLE-SHUFFLING-MODE)
    (:BYTE %BYTE-SHUFFLING-MODE)
    (:FIXNUM %FIXNUM-SHUFFLING-MODE)
    (:SINGLE-FLOAT %SINGLE-FLOAT-SHUFFLING-MODE)))

#+IMACH
(DEFMACRO WITH-HARDWARE-BIT-SHUFFLING ((VARIABLE MODE) &BODY BODY)
  (CL:CHECK-TYPE VARIABLE CL:SYMBOL)
  `(LET ((.OLD-MODE. NIL))
     (UNWIND-PROTECT
	 (LET ((,VARIABLE (SET-HARDWARE-BIT-SHUFFLING-MODE ,VARIABLE
							   (ENCODE-BIT-SHUFFLING-MODE ,MODE)
							   (LOCF .OLD-MODE.))))
	   ,@BODY)
       (RESTORE-HARDWARE-BIT-SHUFFLING-MODE .OLD-MODE.))))

#+IMACH
(DEFMACRO WITH-HARDWARE-BIT-SHUFFLING-BAR ((BAR-NUMBER MODE) &BODY BODY)
  (CL:CHECK-TYPE BAR-NUMBER (CL:MEMBER 1 2 3))
  `(LET ((.OLD-MODE. NIL))
     (UNWIND-PROTECT
	 (PROGN (SETF (%BLOCK-REGISTER ,BAR-NUMBER) 
		      (SET-HARDWARE-BIT-SHUFFLING-MODE (%BLOCK-REGISTER ,BAR-NUMBER)
						       (ENCODE-BIT-SHUFFLING-MODE ,MODE)
						       (LOCF .OLD-MODE.)))
		,@BODY)
       (SETF (%BLOCK-REGISTER ,BAR-NUMBER)
	     (RESTORE-HARDWARE-BIT-SHUFFLING-ADDRESS (%BLOCK-REGISTER ,BAR-NUMBER)))
       (RESTORE-HARDWARE-BIT-SHUFFLING-MODE .OLD-MODE.))))
