;;; -*- Package:SYSTEM-INTERNALS; Mode:LISP; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

#|
Possible future optimization:

- If it really is right for us to check the validity of style components
  by checking for list membership in a *VALID-... list, then perhaps we can
  use an interning scheme that puts a property on each valid symbol which
  yields a number.  These numbers would then be mangled together (multiplication,
  bit fields, etc.) to generate an array or hashtable reference.
|#

;;; Don't put italics in any string constant in this file.  You'll screw
;;; up the bootstrapping of *char-style-index-table*.

;; This should really be a flavor instance.  Since it isn't and since it is special-cased by
;; the BIN dumper, we have to make undumped slots be notinline so they won't be
;; handled by the constant folder.

;; Character styles  
(defstruct (character-style
	     (:conc-name cs-)
	     :named
	     :size-symbol
	     ;; All character-styles live in PSA
	     (:make-array (:area permanent-storage-area))
	     (:inline :constructor family face size extended-attributes))
  family
  face
  size
  index
  extended-attributes)

(defselect ((:property character-style named-structure-invoke))
  (:print-self (self stream ignore slashify-p)
   (if scl:*print-readably*
       (if future-common-lisp:*read-eval*
	   (let ((cl:*package* nil))
	     (format stream "#.~S"
		     `(parse-character-style
			'(,(cs-family self) ,(cs-face self) ,(cs-size self)))))
	   (print-not-readable self))
       (flet ((doit () (format stream "~A.~A.~A"
			       (cs-family self)
			       (cs-face self)
			       (cs-size self))))
	 (if slashify-p
	     (si:printing-random-object (self stream :typep)
	       (doit))
	     (doit))))))

;; This is called either on a list or a character-style structure
(defun character-style-item-hash-function (item)
  (if (cl:consp item)
      (cli::xequal-hash item)
      ;; It would be nice to store this in the structure itself.
      ;; ---Abstraction violation police alert --
      ;; Too bad character style structures aren't flavor instances.
      (let ((item item))
	(declare (array-register item))
	(with-stack-list (list (cs-family item)
			       (cs-face item)
			       (cs-size item))
	  (cli::xequal-hash list)))))

;; This is called with lists or character-style structures
(defun character-style-hash-table-item-equal-test (item1 item2)
  (macrolet ((compare (access1 access2)
	       (let ((body
		       `(and ,@(cl:map 'cl:list
				       (lambda (a1 a2) `(eq (,a1 item1) (,a2 item2)))
				       (cl:ecase access1
					 (cs '(cs-family cs-face cs-size))
					 (pop '(pop pop pop)))
				       (cl:ecase access2
					 (cs '(cs-family cs-face cs-size))
					 (pop '(pop pop pop)))))))
		 `(let (,@(and (eql access1 'cs) '((item1 item1)))
			,@(and (eql access2 'cs) '((item2 item2))))
		    (declare (array-register ,@(and (eql access1 'cs) '(item1))
					     ,@(and (eql access2 'cs) '(item2))))
		    ,body))))
    (if (atom item1)
	(if (atom item2)
	    (eq item1 item2)
	    (compare cs pop))
	(if (atom item2)
	    (compare pop cs)
	    (compare pop pop)))))


;;; NOTE: There has to be a compile-table-flavor in table-flavor or this
;;;  will blow up when loaded inner system.
;; Tables indexed by character style structures (or lists of family,face,size)
(defun make-character-style-hash-table (&rest make-hash-table-args)
  (scl:apply #'scl:make-hash-table
	     :test #'character-style-hash-table-item-equal-test
	     :hash-function #'character-style-item-hash-function
	     :rehash-after-full-gc T
	     :locking NIL	;the old nested plist implementation didn't
	     make-hash-table-args))

(defflavor character-style-error () (error))

(defmacro with-interactive-character-style-error-recovery (&body body)
  `(condition-bind-default ((character-style-error
			      #'with-interactive-character-style-error-recovery-1))
     . ,body))

;;; Simple interactive handler instead of debugger.  Does not offer all the choices
;;; that the debugger would.
(defun with-interactive-character-style-error-recovery-1 (error)
  (let ((choices
	  (let ((possible (send error :proceed-types)))
	    (loop for elem in '(("Undefined" :value :use-undefined-style
				 :documentation "Use the style reserved for undefined styles")
				("New-style" :value :replace-entire-style
				 :documentation "Use a different style instead")
				("Font" :value :other-font
				 :documentation "Use some other font instead")
				("Debugger" :value nil
				 :documentation "Enter the debugger"))
		  when (let ((value (tv:menu-execute-no-side-effects elem)))
			 (or (null value) (member value possible)))
		    collect elem))))
    (when choices
      (format query-io "~&~A~%" error)
      (let ((action (accept `((alist-member :alist ,choices)))))
	(when action
	  (send error :proceed action))))))

(defflavor invalid-character-style-component
	(which-component
	 component-value
	 valid-values
	 given-style-values)
	(character-style-error)
  :initable-instance-variables
  :gettable-instance-variables)

(defmethod (:report invalid-character-style-component) (str)
  (format str "The style component ~S is invalid as a ~(~A~). ~@
		Valid ~(~A~): "
	  component-value which-component (string-pluralize (string which-component)))
  (format-textual-list valid-values #'prin1 :conjunction "and"
		       :filled t :after-line-break "  " :stream str))

(defmethod (:proceed invalid-character-style-component :no-action) ()
  "Accept it anyway"
  (values :no-action))

(defmethod (:proceed invalid-character-style-component :make-it-valid) ()
  "Add it to the list of valid ones."
  (values :make-it-valid))

(defmethod (:document-proceed-type invalid-character-style-component :make-it-valid) (stream)
  (format stream "Add ~s to the list of valid ~(~a~)"
	  component-value (string-pluralize (string which-component))))

(defmethod (:proceed invalid-character-style-component :new-component) ()
  (values :new-component
	  (prompt-and-accept `((dw:member-sequence ,valid-values))
			     "Enter a new ~(~a~)" which-component)))

(defmethod (:document-proceed-type invalid-character-style-component :new-component) (stream)
  (format stream "Supply another ~(~a~) to use instead" which-component))

(defmethod (:proceed invalid-character-style-component :replace-entire-style) ()
  (values :replace-entire-style
	  ;; Can't just accept a character-style because it validates
	  ;; against against-default and device.  However, this sux fer sure.
	  ;; Our caller (actually, SIGNAL's caller) trusts us to return valid components.
	  (list (accept `((dw:member-sequence ,*valid-families*))
			:prompt "Family")
		(accept `((dw:member-sequence ,*valid-faces*))
			:prompt "Face")
		(accept `((dw:member-sequence ,*valid-sizes*))
			:prompt "Size"))))

(defmethod (:document-proceed-type invalid-character-style-component :replace-entire-style)
	   (stream)
  (format stream "Supply a different style to use instead of ~S" given-style-values))

(defmethod (:proceed invalid-character-style-component :use-undefined-style) ()
  "Use the mapping for undefined character styles."
  (values :replace-entire-style *undefined-character-style*))

(compile-flavor-methods invalid-character-style-component)

;;; The global character-style-index table.

(defvar *character-style-index-table-size* 256)

(defvar *character-style-index-table* (make-array *character-style-index-table-size*
						  :initial-value nil))

(defun style-index (style &optional (allocate-p nil))
  (let ((style (parse-character-style style)))
    (or (cs-index style)
	(lookup-style-index style allocate-p))))

;;; Note that the D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")allocate-p0 argument defaults to 1t0, the opposite of 1si:style-index0.
;;; This is so compiled code can be smaller.
(defun lookup-style-index (style &optional (allocate-p t))
  (let ((index (loop for i from 0 below (array-length *character-style-index-table*)
		     as interned-style = (aref *character-style-index-table* i)
		     do (cond ((null interned-style)  ;; No more styles to check
			       (cond ((null allocate-p)
				      (ferror "Style ~A does not have an index." style))
				     (t
				      (setf (aref *character-style-index-table* i)
					    style)
				      (return i))))
			      ((eq style interned-style)
			       (return i)))
		     finally (ferror "Style index table completely full."))))
    (setf (cs-index style) index)
    index))

(defvar *undefined-character-style*)  ;; set at end of this file.

(defsubst index-character-style (style-index)
  (or (aref *character-style-index-table* style-index)
      *undefined-character-style*))

(defsubst char-style (char)
  (index-character-style (char-style-index char)))

(cl:defsetf char-style (char) (value)
  `(setf (si:char-style-index ,char) (si:style-index ,value t)))

(defsubst merge-style-of-character-with-character-style (character default-character-style)
  (let ((i (char-style-index character)))
    (if (zerop i)
	default-character-style
	(merge-character-styles (index-character-style i) default-character-style))))

(defun make-merged-char (char style)
  (setf (char-style-index char)
	(style-index (merge-style-of-character-with-character-style char style) t))
  char)

(defun parse-character-style (style-spec)
  #+Before-bumming-this-was
  (cl:etypecase style-spec
    ((cl:structure character-style) style-spec)
    (list (apply #'intern-character-style (or style-spec '(nil nil nil)))))
  ;; Open-code typep-structure, named-structure-p, named-structure-symbol
  ;; This reduces time to 38% of the above in the common case of it already being
  ;; a style object.
  (cond ((and (arrayp style-spec)
	      (not (zerop (array-named-structure-bit style-spec)))
	      (let ((xname (aref style-spec 0)))
		(or (eq xname 'character-style)
		    (loop while xname
			  do (setq xname (let ((d (get xname 'defstruct-description)))
					   (and (defstruct-description-named-p d)
						(car (defstruct-description-include d)))))
			  when (eq xname 'character-style)
			    return t))))
	 style-spec)
	((cl:consp style-spec)
	 (apply #'intern-character-style style-spec))
	((null style-spec)
	 *null-style*)
	(T (error "The argument ~s does not represent a character style" style-spec))))

(defun unparse-character-style (style)
  (declare (values list-of-family-face-size))
  (setq style (parse-character-style style))		;Why not?  It's consistent.
  (list (cs-family style)
	(cs-face style)
	(cs-size style)))

(defun unparse-style-components (style)
  (declare (values parsed-style family face size))
  (setq style (parse-character-style style))		;Why not?  It's consistent.
  (values style
	  (cs-family style)
	  (cs-face style)
	  (cs-size style)))

;;; Device for character display
(defflavor display-device
	(name
	 pretty-name
	 (charsets&stylesspecs (list nil)))
	()
  :writable-instance-variables
  :initable-instance-variables
  (:required-init-keywords :name))

(defmethod (make-instance display-device :after) (&rest ignore)
  (unless (and (variable-boundp pretty-name) pretty-name)
    ;; shorn of terminal *'s and made into separate capitalized words
    (setq pretty-name (make-command-name name))))

(defvar *display-devices* nil :localize t)

(defun translate-device-type-to-device-instance (device-type)
  (if (numberp device-type)
      (loop for device in *display-devices*
	    when (eql (send device :old-style-name) device-type)
	      return device)
      device-type))

(defsubst valid-display-device (device)
  (memq device *display-devices*))

(defun register-display-device-1 (name flavor &optional pretty-name)
  (or (cl:find name *display-devices* :key #'display-device-name)
      (let ((new-device (make-instance flavor :name name :pretty-name pretty-name)))
	(push new-device *display-devices*)
	new-device)))

(defmacro register-display-device (name flavor &optional pretty-name)
  `(cl:defparameter ,name (register-display-device-1 ',name ',flavor ',pretty-name)
     "Display Device"))

(defmethod (:set-mapping display-device) (charset style spec)
  (let (style-map)
    (without-interrupts
      (setq style-map (get charsets&stylesspecs charset))
      (when (null style-map)
	(setq style-map (make-character-style-hash-table))
	(setf (get charsets&stylesspecs charset) style-map)
	;; Keep the list localized in vm
	(setq charsets&stylesspecs (copylist charsets&stylesspecs))))
    (setf (gethash style style-map) spec)))

(defmethod (:get-mapping display-device) (charset style &optional inquiry-only)
  (ignore inquiry-only)
  (let ((style-map (get charsets&stylesspecs charset)))
    (and style-map
	 (gethash style (get charsets&stylesspecs charset)))))

(defmethod (remove-character-style-translation display-device) (character-set character-style)
  (let ((style-map (get charsets&stylesspecs character-set)))
    (when style-map
      (remhash character-style style-map))))

(defun map-over-character-style-translations (continuation &key display-device character-set)
  "The continuation gets called on display-device, character-set, character-style, translation"
  (if display-device
      (display-device-map-over-character-style-translations
	display-device continuation character-set)
      (dolist (device *display-devices*)
	(display-device-map-over-character-style-translations
	  device continuation character-set))))

(defmethod (display-device-map-over-character-style-translations display-device)
	   (continuation limited-to-character-set)
  (flet ((doit (cset table)
	   (maphash (named-lambda maphash (character-style translation)
		      (funcall continuation self cset character-style translation))
		    table)))
    (if limited-to-character-set
	(doit limited-to-character-set
	      (get charsets&stylesspecs limited-to-character-set))
	(loop for (character-set table) on (rest1 charsets&stylesspecs) by #'rest2
	      do (doit character-set table)))))

(defflavor b&w-screen-display-device
	()
	(display-device))

(defmethod (:set-mapping b&w-screen-display-device :after) (charset ignore spec)
  (when (and (eq charset *standard-character-set*)
	     (symbolp spec)
	     (eq (symbol-package spec) pkg-fonts-package)
	     (not (and (boundp spec) (typep (symeval spec) 'font)))
	     (variable-boundp #'fed:find-and-load-font))	;cold load
    (condition-case ()
	 (fed:find-and-load-font spec)
       (fed:font-not-found
	 ;;Not found?  Ignore it for now, blow out later.
	 ))))

(defwhopper (:get-mapping b&w-screen-display-device) (charset style &optional inquiry-only)
  (let ((spec (continue-whopper charset style inquiry-only)))
    (cond ((not (symbolp spec)) spec)
	  (inquiry-only spec)
	  ((boundp spec) (symeval spec))
	  (t
	   (condition-case ()
		(fed:find-and-load-font spec)
	      (fed:font-not-found
		(multiple-value-bind (nil new-thing)
		    (signal 'no-character-style-mapping :style style
			    :character-set charset :device self
			    :proceed-types
			      (if (get-font self charset *undefined-character-style* nil t)
				 '(:replace-entire-style :use-undefined-style :other-font)
				 '(:replace-entire-style :other-font)))
		  (let ((spec (get-font self charset new-thing)))
		    ;; Install so only blow out once.  Hopefully the mapping gets cleared
		    ;; when/if the real thing gets defined.
		    (send self :set-mapping charset style spec)
		    spec))))))))

(compile-flavor-methods b&w-screen-display-device)

(defflavor no-character-style-mapping
	(style character-set device (font-substitution nil))
	(character-style-error)
  :initable-instance-variables)

(defmethod (:report no-character-style-mapping) (stream)
  (if (and (eq (cs-family style) :device-font)
	   (or (member (cs-size style) '(* :normal))
	       (eq (cs-size style) device)))
      (format stream "The font ~S could not be found for the device ~A"
	      (cs-face style) (display-device-name device))
      (format stream "No mapping is defined for ~A for the device ~A~
~@[ and the character set ~A~]"
	      style (display-device-name device) (send character-set :name))))

(defmethod (:proceed no-character-style-mapping :replace-entire-style) ()
  "Use some other character style"
  (values :replace-entire-style
	  (accept `((character-style-for-device :device ,device))
		  :prompt (format nil "Style to use instead of ~A" style)
		  ;; Should this default to old one?
		  ;; You might want to change just the size, e.g.
		  ;; In any case, don't offer a default if the mapping isn't defined
		  :default (and (get-font device character-set
					  *standard-default-character-style* nil t)
				*standard-default-character-style*))))

(defmethod (:proceed no-character-style-mapping :use-undefined-style) ()
  "Use the mapping for undefined character styles."
  (values :replace-entire-style *undefined-character-style*))

(defmethod (:proceed no-character-style-mapping :other-font) ()
  "Use some other font"
  (values :replace-entire-style
	  (intern-character-style :device-font
				  (prompt-and-accept 'font-name "Font to use")
				  :normal)))

;; Simulate remote proceed handlers, flush this when Common Lisp Error System becomes real
(defmethod (add-font-substitution no-character-style-mapping) (document proceed)
  (setq font-substitution (list document proceed))
  (cl:pushnew ':font-substitution dbg:proceed-types))

(defmethod (:document-proceed-type no-character-style-mapping :font-substitution) (stream)
  (funcall (first font-substitution) stream))

(defmethod (:proceed no-character-style-mapping :font-substitution) ()
  (funcall (second font-substitution)))

(compile-flavor-methods no-character-style-mapping)

(defvar *character-style-global-tick-symbols* nil)

(defun invalidate-all-character-style-caches ()
  (loop for global-tick-symbol in *character-style-global-tick-symbols*
	do (incf (symeval global-tick-symbol))))

(defflavor basic-cache ((hits 0)
			(probes 0)
			(generation 1)
			global-tick-symbol
			tick)
	   ()
    (:init-keywords :global-tick-symbol)
    (:required-methods :table-clear :table-enter :table-lookup))
  
(defmethod (:init basic-cache :after) (plist)
  (setq global-tick-symbol (get plist :global-tick-symbol)
	tick 0)
  (send self :table-clear)
  (when (not (memq global-tick-symbol *character-style-global-tick-symbols*))
    (push global-tick-symbol *character-style-global-tick-symbols*)))

(defmethod (:print-self basic-cache) (stream ignore slashify-p)
  (let ((info
	  (if (zerop probes)
	      (format nil "Generation ~D cache" generation)
	      (format nil "Generation ~D cache: ~D% hit rate on ~D probes"
		      generation (fix (* 100 (// (float hits) (float probes)))) probes))))
    (if slashify-p
	(si:printing-random-object (self stream :typep) (format stream "~A" info))
	(format stream "~A" info))))

(defmethod (:encached-value basic-cache) (continuation &rest args)
  (let ((valid-tick? (= tick (symeval global-tick-symbol))))
    (multiple-value-bind (table-entry in-cache? valid-cache?)
	(send self :table-lookup args)
      (cond
	(2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; cache was valid and we had it in cache.
0	((and valid-tick? in-cache?)
	 (incf probes) (incf hits)
	 table-entry)
	2;; cache was valid, but we didn't have it.  fill cache and return it.
0	((and valid-tick? valid-cache?)
	 (incf probes)
	 (let ((new-value (lexpr-send continuation args)))
	   (send self :table-enter (copylist args) new-value)
	   new-value))
	2;; cache was invalid.  clear it, fill it, and return it.
0	(t
	 (setq hits 0 probes 1)
	 (setq tick (symeval global-tick-symbol))
	 (send self :table-clear)
	 (let ((new-value (lexpr-send continuation args)))
	   (send self :table-enter (copylist args) new-value)
	   new-value)))))) 

(defmacro cache-lookup (cache cache-miss-handler &rest args)
  `(send ,cache :encached-value ,cache-miss-handler ,@args))

(defmacro using-cache ((cache &rest args) &body body)
  `(send ,cache :encached-value
	 (lambda ,args
	   (declare (sys:downward-function))
	   ,@body)
	 ,@args))

#||
(defflavor foo-cache
	(table)
	(basic-cache))

(defmethod (:table-clear foo-cache) ()
  (setq table (list nil)))

(defmethod (:table-enter foo-cache) (args result)
  (push `(,args ,result) table)
  result)

(defmethod (:table-lookup foo-cache) (args)
  (let ((cached-result (second (assoc args table))))
    (if cached-result
	(values cached-result t)
	(values nil nil))))

(defvar *foo-cache-tick* 0)
(defvar *foo-cache* (make-instance 'foo-cache :global-tick-symbol '*foo-cache-tick*))

(defun foo (x y)
  (using-cache (*foo-cache* x y)
    (format T "~&Running the inner value computer, on ~d ~d" x y)
    (+ x y)))

||#

2;;; (3 0 (NIL 0) (NIL :BOLD-ITALIC NIL) "CPTFONTBI")Font caches2 cache mappings of {device,charset,style}font.  All such
;;; caches must provide three methods:
;;;     3:table-clear                                      2invalidates the cache
;;;     3:table-enter2 (device charset style) result0             2enters mapping into cache
;;;     3:table-lookup 2(device charset style)                   returns two values, an entry
;;;                                                                and its validity

;;; A very simple cache.  Good for applications where we expect many calls with
;;; the same parameters, e.g. blindly translating every character of a buffer.
0(defflavor single-font-cache
	((cached-device)
	 (cached-charset)
	 (cached-style)
	 (cached-font))
	(basic-cache))

(defmethod (:table-clear single-font-cache) ()
  (setq cached-device nil cached-charset nil cached-style nil cached-font nil))

(defmethod (:table-enter single-font-cache) (args result)
  (dlet (((device charset style) args))
    (setq cached-device device cached-charset charset cached-style style
	  cached-font result)))

(defmethod (:table-lookup single-font-cache) (args)
  (declare (values value in-cache cache-valid))
  (dlet (((device charset style) args))
    (let ((cache-valid (and (eq device cached-device)
			    (eq charset cached-charset))))
      (values cached-font
	      (and cache-valid (eq style cached-style))
	      cache-valid))))

(compile-flavor-methods single-font-cache)

2;;; Slightly more elaborate cache.  Good for applications where the device and
;;; character set don't change much and the styles vary a lot.
0(defflavor variable-style-font-cache
	((cached-device)
	 (cached-charset)
	 (stylesfonts (list ())))
	(basic-cache))

(defmethod (:table-clear variable-style-font-cache) ()
  (setq cached-device nil cached-charset nil stylesfonts (list ())))

(defmethod (:table-enter variable-style-font-cache) (args result)
  (dlet (((device charset style) args))
    (setq cached-device device cached-charset charset)
    (setf (get stylesfonts style) result)
    (setq stylesfonts (localize-list stylesfonts))))
  
(defmethod (:table-lookup variable-style-font-cache) (args)
  (declare (values value in-cache cache-valid))
  (dlet (((device charset style) args))
    (let ((table-entry (get stylesfonts style))
	  (cache-valid (and (eq device cached-device)
			    (eq charset cached-charset))))
      (values table-entry
	      (and cache-valid table-entry)
	      cache-valid))))

(compile-flavor-methods variable-style-font-cache)


(defsubst valid-character-set (char-set)
  (typep char-set 'basic-character-set))

(defvar *valid-families* '(nil :fix :swiss :jess :eurex :dutch :handwritten
			       :device-font))
(defsubst valid-family (family) (memq family *valid-families*))
(defun add-character-style-family (&rest families)
  (dolist (family families) (push* family *valid-families*)))

(defvar *valid-faces* '(nil :roman :bold :italic :bold-italic :uppercase
			    :bold-extended :condensed :extra-condensed))
(defsubst valid-face (face) (memq face *valid-faces*))
(defun add-character-style-face (&rest faces)
  (dolist (face faces) (push* face *valid-faces*)))

;;; In this list, nil is the obsolete way of saying :same
(defvar *valid-sizes*
	'(nil
	   :smaller :same :bigger :larger
	   :tiny :very-small :small :normal :stretched :large :very-large :huge))
(defsubst valid-size (size) (memq size *valid-sizes*))

(defun add-character-style-size (&rest sizes)
  (dolist (size sizes) (push* size *valid-sizes*)))

(defvar *null-style*)		; Filled in at the end of this file.

;;; *** Doesn't hack extended-attributes.
(defun merge-character-styles (style default-style)
  (setq style (parse-character-style style)
	default-style (parse-character-style default-style))
  (cond ((eq style *null-style*)
	 default-style)
	((eq (cs-family style) :device-font)
	 ;; No matter what you merge a device-font against, you get that device-font.
	 style)
	((eq (cs-family default-style) :device-font)
	 ;; If you merge against a device font, you get that device font, unless the
	 ;; style is fully specified
	 (if (and (cs-family style) (cs-face style) (cs-size style)
		  (not (memq (cs-size style) '(:smaller :same :bigger :larger))))
	     style
	     default-style))
	(T
	 (let ((family (or (cs-family style) (cs-family default-style)))
	       (face (or (cs-face style) (cs-face default-style)))
	       (size (selectq (cs-size style)
		       ((:same nil) (cs-size default-style))
		       ((:larger :bigger)
			(let ((size (cs-size default-style)))
			  (or (second (memq size '(:tiny :very-small :small :normal
							 :large :very-large :huge)))
			      size
			      (cs-size style))))
		       (:smaller
			(let ((size (cs-size default-style)))
			  (or (second (memq size '(:huge :very-large :large :normal
							 :small :very-small :tiny)))
			      size
			      (cs-size style))))
		       (otherwise (cs-size style)))))
	   (intern-character-style family face size)))))

(defvar *character-style-hash-table*
	(or (and (boundp '*character-style-hash-table*)
		 *character-style-hash-table*)
	    (make-character-style-hash-table :size 523)))

(defvar *character-style-family-substitutions*
	;; Each CAR is preferred over each family in each CDR.
	;; I.e., :swiss is preferred over :sans-serif and :helvetica
	(loop with table = (scl:make-hash-table :test 'eq :size 4
						;; Accesses after this DEFVAR will all
						;;  be reads.
						:locking nil
						;; Keys are symbols, they're not going
						;;  anywhere.
						:ignore-gc t :rehash-after-full-gc t
						;; Table will probably always be small.
						:mutating nil)
	      ;; Just what is repudiated is canned here, instead of being split out
	      ;; into some defvar.  All this is a conservative compatibility
	      ;; with history.  It is not intended as a general-purpose mechanism 
	      ;; for later extension.
	      for (preferred . repudiated) in '((:swiss :sans-serif :helvetica)
						(:dutch :serif :times-roman))
	      do (setq *valid-families*
		       (cons preferred
			     (cl:remove preferred
					(cl:set-difference *valid-families* repudiated))))
	      do (dolist (loser repudiated)
		   (setf (gethash loser table) preferred))
	      finally (return table)))

;;; Map over all stylefont translations.  If translations are found for repudiated
;;; family names, and the preferred style name has no translation, install it on the
;;; preferred name.
(defun redo-substituted-character-style-families ()
  (map-over-character-style-translations
    (lambda (device character-set character-style translation)
      (let* ((this-family (cs-family character-style))
	     (preferred-family (gethash this-family *character-style-family-substitutions*)))
	;; 2preferred-family0, if non-nil, is the family name preferred over 2this-family
0	(when preferred-family
	  (let ((preferred-style (intern-character-style preferred-family
							 (cs-face character-style)
							 (cs-size character-style))))
	    (unless (get-font device character-set preferred-style nil T)
	      (define-font-internal translation device character-set 0	;1--- 0???
0				    preferred-family
				    (cs-face character-style)
				    (cs-size character-style)))))))))

;;; Look up the components.  If a char style object is already there, return it.
;;; Else, validate the components.
;;;  If they are valid (perhaps by forcefully installing one), cons a new char-style object
;;;     and install and return it.
;;;  Else new (valid) components were received from the validation.
;;;  Look them up.  
;;;  If a char style object is already there, return it
;;;  Else cons a new one and install and return that.
;;; In all cases also return the components of the style.

(defun intern-character-style (family face size)
  (declare (values style family face size))
  (flet ((lookup (&rest key)			;family face size
	   (gethash key *character-style-hash-table*))
	 (install (family face size)
	   (let ((style (make-character-style family family face face size size)))
	     (setf (gethash (list family face size) *character-style-hash-table*) style)
	     (values style family face size))))
    (let ((existing-style (lookup family face size)))
      (if existing-style
	  (values existing-style family face size)
	  (multiple-value-bind (old-components-were-valid new-family new-face new-size)
	      (validate-character-style-components family face size)
	    (if old-components-were-valid
		(install family face size)
		(let ((style-for-new-components (lookup new-family new-face new-size)))
		  (if style-for-new-components
		      (values style-for-new-components new-family new-face new-size)
		      (install new-family new-face new-size)))))))))

(defun validate-character-style-components (family face size)
  (declare (values old-components-were-valid new-family new-face new-size))
  (let ((old-components-were-valid T))
    (let ((new-value (gethash family *character-style-family-substitutions*)))
      (when new-value
	(setq family new-value
	      old-components-were-valid nil)))
    (flet ((signal-it (component value valid-values make-it-valid)
	     (declare (dbg:error-reporter))
	     (signal-proceed-case ((new-value) 'invalid-character-style-component
				   :given-style-values (list family face size)
				   :which-component component
				   :component-value value
				   :proceed-types	;I see no better way to control this.
				   (if make-it-valid
				       '(:new-component :no-action
					 :use-undefined-style :replace-entire-style
					 :make-it-valid)
				       '(:new-component :no-action
					 :use-undefined-style :replace-entire-style))
				   :valid-values valid-values)
	       (:new-component
		 (setq old-components-were-valid NIL)
		 new-value)
	       (:no-action (throw 'take-it-anyway nil))	
	       (:replace-entire-style
		 (multiple-value-bind (nil family face size)
		     (unparse-style-components new-value)
		   (return-from validate-character-style-components
		     ;; We are trusting the debugger to have returned valid components.
		     (values nil family face size))))
	       (:make-it-valid
		 (funcall make-it-valid value)
		 value)))
	   (valid-device-name (name)
	     ;; For now.  RWK thinks it should be :* or device name.
	     (memq name '(:normal *))))
    (macrolet ((check-component (which valid? list adder)
		 `(catch 'take-it-anyway
		    (loop until (,valid? ,which)
			  do (setq ,which (signal-it
					    ',which ,which ,list ',adder))))))
      (selectq family
	(:device-font
	 ;; It's too hard to hook all the :DEVICE-FONT special casing into
	 ;; the condition handling above, so punt it for now.
	 (let ((former-face face))		;so we can tell if it was changed
	   (check-arg face (and (symbolp face)
				(eq (symbol-package face) pkg-fonts-package))
		      "a symbol in the FONTS package")
	   ;; The size component wants to be a device, but that part of the design isn't
	   ;; implemented yet.
	   (check-component size valid-device-name '(* :normal) nil)
	   (values (and old-components-were-valid (eq face former-face))
		   family face size)))
	(otherwise
	 (check-component family valid-family *valid-families* add-character-style-family)
	 (check-component face valid-face *valid-faces* add-character-style-face)
	 (check-component size valid-size *valid-sizes* add-character-style-size)
	 (values old-components-were-valid family face size)))))))

#||
;;; This dangerous thing uninterns one that may have been there previously.
(defun modify-style (family face size new-style)
  ;;First make sure the cell exists
  ;;---What about invalid fam/fac/siz replacement?
  (intern-character-style family face size)
  (setf (get (get (get *character-style-table* family) face) size) new-style))
||#

(defun map-all-character-styles (function &rest function-args)
  (declare (downward-funarg function))
  (maphash (lambda (ignore style) (scl:apply function style function-args))
	   *character-style-hash-table*))

(defmacro do-all-character-styles ((var) &body body)
  ;;Terminate body with NIL so it's for effect, not value.
  ;;The COLLECT macrology cares about that.
  `(map-all-character-styles (lambda (,var) ,@body nil)))

(defun list-all-character-styles ()
  (let ((l ()))
    (do-all-character-styles (style) (push style l))
    (nreverse l)))

(defun get-font (device character-set style &optional (error-p t) inquiry-only)
  (setf style (parse-character-style style))
  (setq character-set (lookup-character-set character-set))
  (if (memq (cs-size style) '(:smaller :same :bigger :larger *))
      (if error-p
	  (ferror "Relative size passed to ~s" 'get-font)
	  nil)
      (flet ((recurse (new-style &rest others)
	       (when (eq new-style style)
		 (ferror "~s is about to recurse infinitely upon ~s" 'get-font new-style))
	       (cl:apply #'get-font device character-set new-style others)))
	(let* ((spec (send device :get-mapping character-set style inquiry-only)))
	  (when (null spec)
	    2;; didn't get it right off, but we're not done yet
0	    (setq spec
		  (if (eql (cs-family style) :device-font)
		      2;; It's a device font, go validate it and set its mapping for next time.
0		      (get-font-device-font-internal device character-set style
						     error-p inquiry-only)
		      2;; See if there's some size of it.
0		      (send device :get-mapping character-set
			    (condition-bind-if (not error-p)
					       ((invalid-character-style-component
						  ;; accept it anyway
						  (lambda (cond)
						    (send cond :proceed :no-action))))
			      (merge-character-styles '(nil nil *) style))
			    inquiry-only))))
	  2;; If it's a logical style or 1??logical font??2 then handle appropriately
0	  (loop while (typep spec :list) do
	    (unless (keywordp (first spec))
	      (return))
	    (cl:ecase (first spec)
	      (:style
		(setq spec (recurse (condition-bind-if (not error-p)
						       ((invalid-character-style-component
							  ;; accept it anyway
							  (lambda (cond)
							    (send cond :proceed :no-action))))
				      (merge-character-styles (second spec) style))
				     error-p inquiry-only)))
	      (:font
		(setq spec (second spec))
		(loop-finish))))
	  (cond (spec spec)
		((and (character-set-styleless character-set)
		      (not (and (eq (cs-family style) :fix)
				(eq (cs-face style) :roman)
				(eq (cs-size style) :normal))))
		 (recurse '(:fix :roman :normal) error-p inquiry-only))
		(inquiry-only nil)
		(error-p
		 (multiple-value-bind (nil new-style)
		     (signal 'no-character-style-mapping :style style
			     :character-set character-set :device device
			     :proceed-types
			       (if (recurse *undefined-character-style* nil t)
				   '(:use-undefined-style :replace-entire-style)
				   '(:replace-entire-style)))
		   (unless (eq style new-style)
		     ;; Install mapping so don't blow out again.
		     (send device :set-mapping character-set style `(:style ,new-style)))
		   (get-font device character-set new-style)))
		(t nil))))))

;;; The character-style is a :device-font, resulting from character-style-for-device-font
;;; or backtranslate-font.  Its cs-face is the actual font, or at least some device-specific
;;; representation of it (like, a symbol in the FONTS: package).  Its cs-size is * or :normal,
;;; or in new code, the device that this device-font is for.
;;; This function is called only from get-font, which has already determined that there is
;;; no stylefont mapping for this style.  Part of our contract here is to install that
;;; mapping.  That accomplishes (a) encaching the translation so we don't have to do all
;;; this next time; and (b) gives :get-mapping a chance to translate font names into
;;; font structures (like FONTS:CPTFONT  #<FONT CPTFONT 42546343>).  Except that we don't
;;; do that in case of error, or inquiry-only.
(defun get-font-device-font-internal (device character-set character-style error-p inquiry-only)
  ;; It's a device font.  Its cs-face is the device font; the cs-size is * or :normal,
  ;; or else it's a device.  If the latter, make sure it's for the same device!
  (let ((font-in-style (cs-face character-style))
	(device-in-style (cs-size character-style)))
    (flet ((valid-device ()
	     (if (memq device-in-style '(* :normal))
		 T
		 (if (eql device-in-style device)
		     T
		     NIL))))
      (cond (inquiry-only
	     (if (valid-device)
		 font-in-style
		 nil))
	    ((not (valid-device))
	     (cond (error-p
		    (multiple-value-bind (nil new-thing)
			(signal 'no-character-style-mapping :style character-style
				:character-set character-set :device device
				:proceed-types
				  (if (get-font device character-set
						*undefined-character-style* nil t)
				      '(:use-undefined-style :replace-entire-style)
				      '(:replace-entire-style)))
		      (unless (eq new-thing character-style)
			(send device :set-mapping character-set character-style
								`(:style ,new-thing)))
		      (get-font device character-set new-thing error-p)))
		   (T nil)))
	    (T (send device :set-mapping character-set character-style font-in-style)
	       ;; See commentary above.
	       (send device :get-mapping character-set character-style))))))

(defun lookup-index-and-font (char device-type style-default &optional (error-p t))
  (declare (values index font))
  (let ((style (merge-style-of-character-with-character-style char style-default)))
    (multiple-value-bind (char-set index)
	(char-char-set-and-index char)
      (values index (get-font device-type char-set style error-p)))))

(defstruct (character-style-font-cache
	     :named-array-leader :conc-name
	     (:make-array (:length (lsh 1 (byte-size sys:%%char-style)))))
  (length (lsh 1 (byte-size sys:%%char-style)))
  (last-style nil))

(defun lookup-index-and-font-cached (char device-type merged-style cache
				     &optional ;;---optional only for patch file
				     charset&stylefont-cache)
  (declare (values index font))
  (when cache
    (when (zerop (char-char-set-index char))
      (when (not (zerop (char-bits char)))
	(return-from lookup-index-and-font-cached
	  (values nil nil)))
      (let ((index (char-subindex char))
	    (style (char-style-index char)))
	(when (neq (character-style-font-cache-last-style cache) merged-style)
	  (cl:fill cache nil)
	  (setf (character-style-font-cache-last-style cache) merged-style))
	(let ((font (aref cache style)))
	  (when (null font)
	    (setq font (lookup-font-cached charset&stylefont-cache
					   char device-type merged-style nil))
	    (setf (aref cache style) font))
	  (return-from lookup-index-and-font-cached
	    (values index font))))))
  (lookup-index-and-font char device-type merged-style nil))

(defun lookup-font (char device-type style-default &optional (error-p t) inquiry-only)
  (let ((style (condition-bind-if (not error-p)
				  ((invalid-character-style-component
				     ;; accept it anyway
				     (lambda (cond) (send cond :proceed :no-action))))
		 (merge-style-of-character-with-character-style char style-default)))
	(char-set (char-set-and-offset (char-char-set-index char))))
    (get-font device-type char-set style error-p inquiry-only)))

(defun lookup-font-cached (charset&stylefont-cache char device-type style-default
			   &optional (error-p t))
  (let ((style (condition-bind-if (not error-p)
				  ((invalid-character-style-component
				     ;; accept it anyway
				     (lambda (cond) (send cond :proceed :no-action))))
		 (merge-style-of-character-with-character-style char style-default)))
	(char-set (char-set-and-offset (char-char-set-index char))))
    (if charset&stylefont-cache
	(cache-lookup charset&stylefont-cache #'get-font
		      device-type char-set style error-p)
	(get-font device-type char-set style error-p))))

(defun style-valid-p (style against-default &optional (device *b&w-screen*))
  (when against-default
    (setq style (merge-character-styles style against-default)))
  (when (multiple-value-bind (ignore family face size)
	    (unparse-style-components style)
	  (and family face size (not (memq size '(:smaller :same :bigger :larger)))))
    (get-font device nil style nil t)))

;; Builtin knowledge in this function.
(defun character-style-relative-p (char-style)
  (or
    (memq (cs-size char-style)
	     '(nil :smaller :same :bigger :larger *))
    (null (cs-family char-style))
    (null (cs-face char-style))))

;;; See also SI:STYLIZE-STRING for a more efficient version of that that
;;; runs faster and also doesn't copy the string if no change is required.
(defun change-string-character-style (string style)
  (let ((style-index (style-index (parse-character-style style) T))
	(string string)
	(new-string (make-array (string-length string) :type 'art-fat-string)))
    (declare (sys:array-register string new-string))
    ;;Isn't there something like this in the character-stream stuff?
    (loop for i below (string-length string)
	  for old-char = (aref string i)
	  do (setf (char-style-index old-char) style-index)
	     (setf (aref new-string i) old-char))
    new-string))

;; Merge each char's style against the supplied character-style.
;; This takes its args in opposite order from change-string-character-style so
;; we can get the substring args in the right place.
(defun merge-string-character-style (character-style string &optional (start 0) end)
  (setq character-style (parse-character-style character-style))
  (when (null end) (setq end (string-length string)))
  (if (eql character-style *null-style*)
      (if (and (= start 0) (= end (string-length string)))
	  string
	  (substring string start end))
      (let ((new-string (make-array (- end start) :type 'art-fat-string))
	    (string string)
	    (character-style-index-table *character-style-index-table*))
	(declare (sys:array-register new-string string character-style-index-table))
	(loop for i from start below end
	      for j from 0
	      do
	  ;; This is pretty bummed, hence excessively subprimitive.
	  (let* ((char (aref string i))
		 (style-index (char-style-index char))
		 (new-style (if (zerop style-index)	;*null-style*
				character-style
				(merge-character-styles
				  (or (aref character-style-index-table style-index)
				      *undefined-character-style*)
				  character-style)))
		 (new-style-index (or (cs-index new-style)
				      (style-index new-style t))))
	    (setf (char-style-index char) new-style-index)
	    (setf (aref new-string j) char)))
	new-string)))

(defun string-for-style-name (style &key in-brackets)
  ;; I suppose someone will define some print-controlling-flag which
  ;; will require this to use with-standard-io-environment.  Foo upon it all.
  (if in-brackets
      (format nil "[~a]" style)
      (format nil "~a" style)))


;;; The for-device-type argument is scheduled to be made a required argument.
(defun backtranslate-font (font &optional for-device-type)
  (declare (values style character-set charset-offset device-type))
  (setq font
	(cl:etypecase font
	  (symbol font)
	  ((cl:structure font) (font-name font))
	  (string (intern font "FONTS"))))
  (flet ((make-device-font (font)
	   (values ;; 1*** :normal0 until this becomes the device name.
	     (intern-character-style :device-font font :normal)
	     si:*standard-character-set*
	     0
	     ;; Until this becomes a required argument!
	     (or for-device-type si:*b&w-screen*))))
    (cond ((null for-device-type)
	   (block mumble1
	     (dolist (prop '(style-backtranslation font-specs))
	       (loop for item in (get font prop)
		     for style = (car item)
		     unless (gethash (cs-family style) *character-style-family-substitutions*)
		       do (return-from mumble1 (values-list item))))
	     (make-device-font font)))
	  (t
	   (block mumble2
	     (dolist (prop '(style-backtranslation font-specs))
	       (loop for (style character-set charset-offset device-type)
			 in (get font prop)
		     when (eql device-type for-device-type)
		       unless (gethash (cs-family style) *character-style-family-substitutions*)
		       do (return-from mumble2
			    (values style character-set charset-offset device-type))))
	     (make-device-font font))))))
#||
(defun test-that-backtranslation-doesnt-return-repudiated-styles ()
  (let ((number-of-styles 0)
	(i 0))
    (do-all-character-styles (ignore) (incf number-of-styles))
    (tv:noting-progress ((format () "Checking ~d styles" number-of-styles))
      (zwei:zcollecting-into (losers)
	(do-all-character-styles (style)
	  (tv:note-progress i number-of-styles)
	  (incf i)
	  (condition-case ()
	       (let ((font (get-font *b&w-screen* *standard-character-set* style ())))
		 (when font
		   (let ((back-style (backtranslate-font (font-name font) *b&w-screen*)))
		     (when (gethash (cs-family back-style)
				    *character-style-family-substitutions*)
		       (zwei:zcollect losers (list font back-style))))))
	     (error)))
	losers))))

||#


(defun define-font-internal (font device-type character-set charset-offset family face size)
  (let ((style (intern-character-style family face size)))
    (when (eq size '*)
      (unless (and (listp font)
		   (eq (first font) :style))
	(error "The target of wildcard-size character style translations must specify a character style.~@
		However, this attempts to translate from ~s to ~s" style font)))
    (send device-type :set-mapping character-set style font)
    (when (symbolp font)
      (let ((spec (list style character-set charset-offset device-type)))
	(unless (member spec (get font 'font-specs))
	  (setf (get font 'font-specs) (append (get font 'font-specs) (list spec))))))
    style))

;;There's no good reason why device and character-set couldn't be moved into
;;the nested plist tree as well.
(defun define-character-style-families (device character-set &rest plists)
  ;;If someone's trying to define a style, don't hassle hir about invalid style components.
  (condition-bind ((invalid-character-style-component
		     (lambda (cond) (send cond :proceed :make-it-valid))))
    (labels ((walk (list family face size)
	       (if (not (listp list))
		   (define-font-internal list device character-set 0 family face size)
		   (selectq (first list)
		     (:family
		      (loop for (family value) on (rest1 list) by #'rest2
			    do 
			(check-token family "family")
			(walk value family face size)))
		     (:face
		      (loop for (face value) on (rest1 list) by #'rest2
			    do
			(check-token face "face")
			(walk value family face size)))
		     (:size
		      (loop for (size value) on (rest1 list) by #'rest2
			    do
			(check-token size "size")
			(walk value family face size)))
		     (:font
		      (unless (= (length list) 2)
			(error
			  "List ~S, whose car is :FONT, did not have exactly two elements."
			  list))
		      (define-font-internal (copylist list) device character-set
					    0 family face size))
		     (:style
		      (define-font-internal (list :style (parse-character-style (rest1 list)))
					    device character-set 0 family face size))
		     (otherwise (error "Malformed clause ~s" list)))))
	     (check-token (token what)
	       (unless (symbolp token)
		 (error "~A specifications must be symbols; ~S is not a symbol."
			what token))))
      (dolist (x plists) (walk x () () ()))))
  (invalidate-all-character-style-caches)
  nil)

(defun make-character-style-translation (translation character-style &optional
					 (device *b&w-screen*)
					 (character-set *standard-character-set*)
					 (offset 0))
  (condition-bind ((invalid-character-style-component
		     (lambda (cond) (send cond :proceed :no-action))))	;accept it anyway
    (setq character-style (parse-character-style character-style)))
  (define-font-internal translation device character-set offset
			(cs-family character-style)
			(cs-face character-style)
			(cs-size character-style)))

2;;; +++ Move all this to TVDEFS someday
0(register-display-device *b&w-screen* b&w-screen-display-device "B&W Screen")

(define-character-style-families *b&w-screen* *standard-character-set*
  '(:family :fix
	    (:size :normal (:face :roman fonts:cptfont
				  :italic fonts:cptfonti
				  :bold fonts:cptfontcb
				  :bold-italic fonts:cptfontbi
				  :bold-extended fonts:cptfontb
				  :condensed fonts:cptfontc
				  :extra-condensed fonts:cptfontcc)
		   :small (:face :roman fonts:tvfont
				 :italic fonts:tvfonti
				 :bold fonts:tvfontcb
				 :bold-italic fonts:tvfontbi
				 ;; needed for presentation-inspector
				 :bold-extended fonts:tvfontb
				 :condensed fonts:tvfont
				 :extra-condensed fonts:tvfont
				 )
		   :very-small (:face :roman fonts:einy7
				      :italic fonts:einy7	;can't do much better, 
				      :bold fonts:einy7		;  when it gets this small.
				      :bold-italic fonts:einy7
				      :condensed fonts:einy7
				      :extra-condensed fonts:einy7
				      :bold-extended fonts:einy7
				      :uppercase fonts:5x5)
		   :tiny (:face :roman fonts:tiny
				:italic fonts:tiny :bold fonts:tiny :bold-italic fonts:tiny)
		   :large (:face :roman fonts:medfnt
				 :italic fonts:medfnti
				 :bold fonts:medfntb
				 :bold-italic fonts:medfntbi)
		   :very-large (:face :roman fonts:bigfnt
				      :italic fonts:bigfnti
				      :bold fonts:bigfntb
				      :bold-italic fonts:bigfntbi))))

(define-character-style-families *b&w-screen* *standard-character-set*
  '(:family :swiss (:size :normal (:face :roman fonts:hl12
					 :bold fonts:hl12b
					 :italic fonts:hl12i
					 :bold-italic fonts:hl12bi
					 :condensed-caps fonts:swiss12-ccaps
					 :bold-condensed-caps fonts:swiss12b-ccaps)
			  :small (:face :roman fonts:hl10
					:bold fonts:hl10b
					:italic fonts:hl10i
					:bold-italic fonts:hl10bi
					;; Needed by the presentation inspector
					:condensed-caps fonts:hl10
					:bold-extended fonts:hl10b
					:bold-condensed-caps fonts:hl10b
					:condensed fonts:hl10)
			  :very-small (:face :roman fonts:hl8
					     :italic fonts:hl8i
					     :bold fonts:hl8b
					     :bold-italic fonts:hl8bi)
			  :large (:face :roman fonts:hl14
					:italic fonts:hl14i
					:bold fonts:hl14b
					:bold-italic fonts:hl14bi
					;; Needed by the presentation inspector
					:bold-extended fonts:hl14b
					:condensed fonts:hl14)
			  :very-large (:face :roman fonts:Swiss20
					     :italic fonts:Swiss20i
					     :bold fonts:Swiss20b
					     :bold-italic fonts:Swiss20bi))
	    :dutch (:size :very-small (:face :roman fonts:tr8
					     :bold fonts:tr8b
					     :italic fonts:tr8i
					     :bold-italic fonts:tr8bi)
			  :small (:face :roman fonts:tr10
					:bold fonts:tr10b
					:italic fonts:tr10i
					:bold-italic fonts:tr10bi)
			  :normal (:face :roman fonts:tr12
					 :italic fonts:tr12i
					 :bold fonts:tr12b
					 :bold-italic fonts:tr12bi)
			  :large (:face :roman fonts:Dutch14
					:italic fonts:Dutch14i
					:bold fonts:Dutch14b
					:bold-italic fonts:Dutch14bi)
			  :very-large (:face :roman fonts:Dutch20
					     :italic fonts:Dutch20i
					     :bold fonts:Dutch20b
					     :bold-italic fonts:Dutch20bi))
	    ;;This tree is sliced differently just because.
	    :jess (:face :roman (:size :small fonts:jess11
				       :normal fonts:jess13
				       :large fonts:jess14)
			 :bold (:size :small fonts:jess11b
				      :normal fonts:jess13b
				      :large fonts:jess14b)
			 :italic (:size :small fonts:jess11i
					:normal fonts:jess13i
					:large fonts:jess14i))
	    :eurex (:size
		     :very-large (:face :italic fonts:eurex21i)
		     :huge (:face :italic fonts:eurex24i))))



  ;; *** Next line is bogus.. Style should be per character set, I think.
(define-character-style-families *b&w-screen* *mouse-character-set*
  '(:family :fix (:size :normal (:face :roman fonts:mouse))))

(define-character-style-families *b&w-screen* *arrow-character-set*
  '(:family :fix (:size :normal (:face :roman fonts:narrow))))

(define-character-style-families *b&w-screen* *symbol-character-set*
  '(:family :swiss (:size :normal (:face :roman fonts:symbol12))))

(define-character-style-families *b&w-screen* *standard-character-set*
  '(:size *
	  (:family tv:choose-variable-values-menu
		   (:face :roman (:style :fix :roman :same)
			  :italic (:style :fix :italic :same)
			  :bold (:style :fix :bold :same)
			  :bold-italic (:style :fix :bold-italic :same)
			  :fix (:style :fix :roman :same)
			  tv:string (:style tv:choose-variable-values-menu :roman :same)
			  tv:name (:style tv:choose-variable-values-menu :roman :same)
			  tv:value (:style tv:choose-variable-values-menu :roman :same)
			  tv:unselected-choice (:style :swiss :roman :smaller)
			  tv:selected-choice (:style :swiss :bold :smaller)))))


;;; Get the standard font into slot 0 of the style index table
(setq *null-style* (intern-character-style nil nil nil))
(unless (= 0 (lookup-style-index *null-style*))
  (ferror "Something other than the standard font (i.e. (nil nil nil)) is in ~
           slot 0 of the style index table."))

;; This is only necessary for fonts that might have many styles mapped to it, and which
;; we prefer a particular style for backtranslation.  The CPTFONT family leaps to mind
;; in this regard.  We'll probably think of some others.
(defun define-font-backtranslation-internal (font device character-set charset-offset
					     family face size)
  (unless (symbolp font)
    (ferror "Can only backtranslate from font symbols, not ~S which is not a symbol" font))
  (let* ((style (intern-character-style family face size))
	 (spec (list style character-set charset-offset device)))
    (unless (member spec (get font 'style-backtranslation))
      (push spec (get font 'style-backtranslation)))))

(defun define-font-backtranslations (device character-set &rest plists)
  (labels ((walk (list family face size)
	     (if (not (listp list))
		 (define-font-backtranslation-internal
		   list device character-set 0 family face size)
		 (selectq (first list)
		   (:family
		    (loop for (family value) on (rest1 list) by #'rest2
			  do (walk value family face size)))
		   (:face
		    (loop for (face value) on (rest1 list) by #'rest2
			  do (walk value family face size)))
		   (:size
		    (loop for (size value) on (rest1 list) by #'rest2
			  do (walk value family face size)))
		   (:font
		    (define-font-backtranslation-internal
		      list device character-set 0 family face size))
		   (otherwise (ferror "Malformed clause ~s" list))))))
    (dolist (x plists) (walk x () () ()))))

(define-font-backtranslations *b&w-screen* *standard-character-set*
  '(:size :normal
	  (:family :fix (:face :roman fonts:cptfont
			       :italic fonts:cptfonti
			       :bold fonts:cptfontcb
			       :bold-extended fonts:cptfontb)
		   :swiss (:face :roman fonts:hl12
				 :bold fonts:hl12b
				 :italic fonts:hl12i
				 :bold-italic fonts:hl12bi))
	  :large
	  (:family :dutch (:face :roman fonts:tr14
				 :bold fonts:tr14b
				 :italic fonts:tr14i))
	  :very-large
	  (:family :dutch (:face :roman fonts:tr18
				 :bold fonts:tr18b))))

(defun character-style-for-device-font (font-symbol device
					&optional (character-set *standard-character-set*)
					(charset-offset 0))
  (condition-bind ((invalid-character-style-component
		     (lambda (cond) (send cond :proceed :no-action))))	;accept it anyway
    (define-font-internal font-symbol device character-set charset-offset
			  :device-font font-symbol :normal)))

;;; Known undefined font.
(setq *undefined-character-style* 
      (condition-bind ((invalid-character-style-component
			 (lambda (cond) (send cond :proceed :no-action))))	;accept it anyway
	(intern-character-style 'si:standin-for-undefined-styles :roman :normal)))

(make-character-style-translation 'fonts:boxfont *undefined-character-style*
				  *b&w-screen* *standard-character-set* 0)

(make-character-style-translation 'fonts:boxfont *undefined-character-style*
				  *b&w-screen* *symbol-character-set* 0)

;(define-character-style-families *b&w-screen* *standard-character-set*
;     `(:family hacks:handwritten (:size :normal
;				  (:face :cursive fonts:hand
;					 :roman   fonts:scrawl))))

;; This will commonly complain about PRESS and XGP as output devices. (!).
(defun verify-that-undefined-style-works-for-all-devices ()
  (let ((text
	  (with-output-to-string (stream)
	    (dolist (device *display-devices*)
	      (flet ((check ()
		       (condition-case (err)
			    (get-font device *standard-character-set*
				      *undefined-character-style*
				      nil T)
			  (error 'loser-because-of-error)))
		     (warning ()
		       (format stream
			       "~&WARNING! ~s, which is supposed to be a safe fallback,~@
				may well cause some user to wind up in the debugger~@
				attempting to use the output device ~s"
			       '*undefined-character-style* device)))
		(let ((winning (check)))
		  (cond ((null winning)
			 (format stream "~&Establishing translation for ~s" device)
			 (make-character-style-translation
			   `(:style ,*standard-default-character-style*)
			   *undefined-character-style*
			   device
			   *standard-character-set* 0)
			 (setq winning (check))
			 (when (or (null winning) (eql winning 'loser-because-of-error))
			   (warning)))
			((eq winning 'loser-because-of-error)
			 (warning))
			(T ))))))))
    (when (> (string-length text) 0)
      (tv:notify () "Messages from ~s:~&~a" 
		 'verify-that-undefined-style-works-for-all-devices
		 text))))

;; This only runs at FULL-GC time for now, since customers shouldn't have to see
;; all the bogus warnings it generates.
(define-gc-optimization verify-that-undefined-style-works-for-all-devices
			symbolics-system-release
  (:before-flip (ignore)
   (verify-that-undefined-style-works-for-all-devices)))

(defun character-style-lessp (x y)
  (block nil
    (macrolet ((compare (x y &rest special)
		 `(let ((x ,x) (y ,y))
		    (unless (eq x y)
		      ,@(loop for s in special
			      append `((when (eq x ',s)
					 (return t))
				       (when (eq y ',s)
					 (return nil))))
		      (return (alphalessp x y))))))
      (compare (cs-family x) (cs-family y) nil :fix)
      (compare (cs-face x) (cs-face y) nil :roman)
      (compare (cs-size x) (cs-size y) nil :normal))))

(add-initialization "cdr-code character-style data"
  '(setq *display-devices* (localize-list *display-devices*))
  '(before-cold))

(define-gc-optimization optimize-display-device-character-style-tables :layered-system-release
  (:documentation "Localize device tables used for character style display")
  (:before-flip (ignore)
   (dolist (device *display-devices*)
     (setf (symeval-in-instance device 'charsets&stylesspecs)
	   (copylist (symeval-in-instance device 'charsets&stylesspecs))))))
