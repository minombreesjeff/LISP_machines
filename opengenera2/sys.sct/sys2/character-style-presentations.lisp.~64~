;;; -*- Package: dw; Mode:LISP; Base: 10; Lowercase: Yes; Syntax: Common-lisp -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;;  Character style presentation type system.
;;;;  Split out from CHARACTER-STYLES.LISP.105 by York on 11/18/85 so that
;;;;  the dependencies on DYNAMIC-WINDOWS can be satisfied (i.e. CHARACTER-STYLES
;;;;  is part of the core system and is loaded long before DYNAMIC-WINDOWS.  This
;;;;  chunk of code had the comment "Hope this loads ok!"


;;; New implementation of the character style parser. -- Doughty, York, RLB

#|
CRUFT FROM RLB'S WHITEBOARD

ACCEPT

 Generic ch. style - debugger intern-char-style, bad components
   character-style

 Default char-style -
	fully-specified
	translatable
	specific device
	offer default, no against-default
	m-X Set Default Ch Style
	:Hardcopy File
	- IWBNI c-Return

 ch style to be merged against a default
  bare-face-or-style
  translatable
  specific device
  against-default
  offer default

  Zmacs m-J, etc.
  Input editor c-m-J
  Set Window Options Echo style, etc.

  Args: 
    device (req'd)
    fully-specified
    against-default


[In green, second column]
ISSUES
against-default vs default
Help vs bare face or style
Stryker proposal face.size.family
Defaulting/completing all fields swi.<return>
device-fonts?
minibuffer loses
<clear-input> restore prompt/noise
specific device
typing space vs "."
Never default from against-default
Default from nil.nil.nil if no other default
|#

(defvar *character-style-validity-cache*
	(make-good-table :name "Character style validity"
			 :test #'fringe-eql :hash-function #'fringe-eql-hash
			 :store-hash-code t :area *handler-dynamic-area*))

;;; (incf *character-style-validity-cache-tick*)
(defvar *character-style-validity-cache-tick* 0)
(pushnew '*character-style-validity-cache-tick* si:*character-style-global-tick-symbols*)
(defvar *character-style-validity-last-tick* -1)
(defun character-style-valid? (style against-default device)
  ;; This DOES NOT do si:parse-xxx on its args!
  (unless (eql *character-style-validity-last-tick* *character-style-validity-cache-tick*)
    (clrhash *character-style-validity-cache*)
    (setq *character-style-validity-last-tick* *character-style-validity-cache-tick*))
  (with-stack-list (key style against-default device)
    (multiple-value-bind (value found-p)
	(gethash key *character-style-validity-cache*)
      (cond (found-p
	     value)
	    (T (assert (typep style '(structure si:character-style)))
	       (assert (typep against-default '(or null (structure si:character-style))))
	       (assert (typep device 'si:display-device))
	       ;; I suppose after a while of confidence we need no longer
	       ;; verify the assertions.
	       (let ((valid?
		       (flet ((merge-cs (style against)
				;; merge-character-styles doesn't do size of '*,
				;; nor do I really think it should.
				(if against
				    (si:merge-character-styles
				      (if (eql (si:cs-size style) '*)
					  (si:intern-character-style
					    (si:cs-family style)
					    (si:cs-face style)
					    (si:cs-size against))
					  style)
				      against)
				    style)))
			 (multiple-value-bind (mstyle family face size)
			     (si:unparse-style-components
			       (merge-cs style against-default))
			   (and family face size
				(not (member size '(:smaller :same :bigger :larger)))
				(si:get-font device nil mstyle nil T))))))
		 (setf (gethash (copy-tree key *handler-dynamic-area*)
				*character-style-validity-cache*)
		       valid?)
		 valid?))))))

;;; If DEVICE is supplied, we only want families that belong to styles that are translatable
;;; for the device.
(defun map-over-valid-character-style-families (function &key device allow-relative)
  (when allow-relative
    (funcall function nil))
  (if (null device)
      (dolist (family si:*valid-families*)
	(when family
	  (unless (eql family :device-font)
	    (funcall function family))))
      (sys:with-stack-array (already (length si:*valid-families*) :element-type 'boolean)
	(let ((weirdos ()))	;someone might have told the debugger, "Use it anyway"
	  (si:map-over-character-style-translations
	    (lambda (display-device character-set character-style translation)
	      (ignore display-device character-set translation)
	      (let ((family (si:cs-family character-style)))
		(when (and family (not (eql family :device-font)))
		  (let ((family-number (position family si:*valid-families*)))
		    (if family-number
			(when (null (aref already family-number))
			  (when (character-style-valid? character-style nil device)
			    (funcall function family)
			    (setf (aref already family-number) T)))
			(unless (member family weirdos)
			  (when (character-style-valid? character-style nil device)
			    (funcall function family)
			    (push family weirdos))))))))
	    :display-device device
	    :character-set si:*standard-character-set*)))))

#+This-is-the-old-code
(defun map-over-valid-character-style-families (function &key device allow-relative)
  (dolist (family si:*valid-families*)
    ;; built-in knowledge of the relative families (i.e. NIL)
    (cond ((null family)
	   ;; only do the NIL family when ALLOW-RELATIVE was supplied
	   (when allow-relative
	     (funcall function family)))
	  ;; gack!
	  ((eq family :device-font) nil)
	  ;; non-relative families, must translate if device supplied
	  ((or (null device)
	       ;; a likely common case
	       (si:style-valid-p (si:intern-character-style family :roman :normal) nil device)
	       (block any-valid-combinations
		 (dolist (face si:*valid-faces*)
		   (dolist (size si:*valid-sizes*)
		     (let ((style (si:intern-character-style family face size)))
		       (when (si:style-valid-p style nil device)
			 (return-from any-valid-combinations t)))))))
	   (funcall function family)))))

#||
(cl:time (map-over-valid-character-style-families #'ignore :device si:*b&w-screen*))
   => 8.4 sec without special casing *.roman.normal
   => 4.6 sec with special case.

(cl:time (map-over-valid-character-style-families #'ignore :device si:*b&w-screen*))
   => 0.10 sec with map-over-c-s-translations
   => 0.03 sec with valid-p cache

||#

(defun map-over-valid-character-style-faces-for-family (function family against-default
							&key (allow-relative t)
							device)
  (declare (sys:downward-funarg function))
  (cond ((null device)				;no device, can't validate
	 (if allow-relative
	     (map nil function si:*valid-faces*)
	     (dolist (face si:*valid-faces*)
	       ;; Built-in knowledge of relative faces (i.e. NIL)
	       (unless (null face) (funcall function face)))))
	(T
	 (setq against-default (si:parse-character-style against-default))
	 (when (null family)
	   ;;--- I suppose we know something about si:merge-character-styles here.
	   (setq family (si:cs-family against-default)))
	 (sys:with-stack-array (already (length si:*valid-faces*) :element-type 'boolean)
	   (let ((weirdos ()))
	     (flet ((if-valid (display-device character-set character-style translation)
		      (ignore display-device character-set translation)
		      (when (eql (si:cs-family character-style) family)
			(let ((face (si:cs-face character-style)))
			  (let ((face-number (position face si:*valid-faces*)))
			    (if face-number
				(when (null (aref already face-number))
				  (when (character-style-valid? character-style
								against-default
								device)
				    (funcall function face)
				    (setf (aref already face-number) T)))
				(unless (member face weirdos)
				  (when (character-style-valid? character-style
								against-default
								device)
				    (funcall function face)
				    (push face weirdos)))))))))
	       (when allow-relative
		 (if-valid nil nil (si:intern-character-style family nil nil) nil))
	       (si:map-over-character-style-translations
		 #'if-valid
		 :display-device device
		 :character-set si:*standard-character-set*)))))))

#+|This is the old code|
(defun map-over-valid-character-style-faces-for-family (function family against-default
							&key (allow-relative t)
							device)
  (dolist (face si:*valid-faces*)
    ;; built-in knowledge of the relative faces (i.e. NIL)
    (cond ((null face)
	   (when allow-relative
	     (funcall function face)))
	  ((or (null device)
	       (si:style-valid-p
		 ;; Speed bum?
		 (si:intern-character-style family face :normal)
		 against-default device)
	       (dolist (size si:*valid-sizes*)
		 (when (or allow-relative
			   (not (member size '(nil :smaller :same :bigger :larger))))
		     (let ((style (si:intern-character-style family face size)))
		       (when (si:style-valid-p style against-default device)
			 (return T))))))
	   (funcall function face)))))

#||
(map-over-valid-character-style-faces-for-family #'print :fix
						 (si:intern-character-style
						   :fix :roman :normal)
						 :allow-relative T
						 :device si:*b&w-screen*)
(cl:time (map-over-valid-character-style-faces-for-family #'ignore
							  :fix
							  (si:intern-character-style
							    :fix :roman :normal)
							  :allow-relative T
							  :device si:*b&w-screen*))
0.94 sec  with the old code
0.027 sec with the map-over-xxx-translations
0.019 with valid-p table cache (after the first pass, of course)
||#

(defun map-over-valid-character-style-sizes-for-family-face
       (function family face against-default &key device (allow-relative t))
  (setq against-default (si:parse-character-style against-default))
  (dolist (size (if (eq family :device-font)
		    '(:normal *)
		  si:*valid-sizes*))
    ;; built-in knowledge of relative sizes
    (cond ((null size)
	   (when allow-relative
	     (funcall function size)))
	  ((member size '(:smaller :same :bigger :larger))
	   (when (and allow-relative
		      (or (null device)
			  (character-style-valid? (si:intern-character-style family face size)
						  against-default device)))
	     (funcall function size)))
	  ((or (null device)
	       (character-style-valid? (si:intern-character-style family face size)
				       against-default device))
	   (funcall function size)))))
#||
(cl:time (map-over-valid-character-style-sizes-for-family-face #'ignore
							       :fix :roman
							       (si:intern-character-style
								 :fix :roman :normal)
							       :allow-relative T
							       :device si:*b&w-screen*))
||#

(defmacro kludging-character-style-family-input-context
	  ((stream start-loc device &key signal-p allow-relative)
					   &body body)
  `(with-presentation-input-context (`((character-style-family
					 :device ,,device
					 :allow-relative ,,allow-relative
					 :allow-device-font t))
				     :stream ,stream)
				    (.blip.)
	(progn ,@body)
      (character-style-family
	(let ((string (string (presentation-blip-object .blip.))))
	  (presentation-replace-input ,stream ,start-loc string)
	  ,(if signal-p
	       `(signal 'input-not-of-required-type 
			:type ,signal-p
			:string string)
	       nil)))))
      
(defmacro kludging-character-style-face-input-context ((stream start-loc device
							       against-default) &body body)
  `(with-presentation-input-context (`((character-style-face
					 :device ,,device
					 :family nil
					 :against-default ,,against-default
					 :allow-relative t))
				     :stream ,stream)
				    (.blip.)
	(progn ,@body)
      (character-style-face
	(let* ((face (presentation-blip-object .blip.))
	       (style (si:intern-character-style nil face nil))
	       (string (string face)))
	  (presentation-replace-input ,stream ,start-loc string)
	  style))))

(define-presentation-type character-style-family ((&key device (allow-relative t)
							(allow-device-font nil)))
   :expander 't ;This makes it print in uppercase, which is what it does elsewhere.
   :parser ((stream &key original-type initially-display-possibilities)
	    (dw:with-accept-help
		((:subhelp
		   "You are currently entering a character style family (e.g. Swiss)."))
	      (let ((dw:*allow-sensitive-raw-text-override* t))
		(values
		  (dw:completing-from-suggestions
		    (stream
		      :type original-type
		      :initially-display-possibilities initially-display-possibilities)
		    (when allow-device-font
		      (suggest "DEVICE-FONT" :DEVICE-FONT))
		    (map-over-valid-character-style-families
		      (lambda (family)
			(suggest (string family) family))
		      :device device :allow-relative allow-relative))))))
   :description "a character style family"
   )

(define-presentation-type character-style-face ((&key family against-default device
						      (allow-relative t))
						&key (provide-subhelp t))
   :expander 't
   :parser ((stream &key original-type initially-display-possibilities)
	    (dw:with-accept-help-if provide-subhelp
		((:subhelp
		   "You are currently entering a character style face (e.g. Bold)."))
	      (let ((dw:*allow-sensitive-raw-text-override* t))
		(values
		  (dw:completing-from-suggestions (stream
						    :type original-type
						    :initially-display-possibilities
						    initially-display-possibilities)
		    (map-over-valid-character-style-faces-for-family
		      #'(lambda (face) (dw:suggest (string face) face))
		      family against-default
		      :device device :allow-relative allow-relative))))))
   :describer ((stream &key plural-count)
	       (ignore against-default)
	       (when (numberp plural-count)
		 (setq plural-count (> plural-count 1)))
	       (cl:write-string (if plural-count
				    "character style faces"
				    "a character style face")
				stream)
	       (format stream " for family ~A" family))
   )

(define-presentation-type character-style-size ((&key family face against-default
						      device (allow-relative t)))
   :expander 't
   :parser ((stream &key original-type initially-display-possibilities)
	    (dw:with-accept-help
		((:subhelp
		   "You are currently entering a character style size (e.g. Large)."))
	      (let ((dw:*allow-sensitive-raw-text-override* t))
		(values
		  (dw:completing-from-suggestions (stream
						    :type original-type
						    :initially-display-possibilities
						    initially-display-possibilities)
		    (map-over-valid-character-style-sizes-for-family-face
		      #'(lambda (size) (dw:suggest (string size) size))
		      family face against-default
		      :device device :allow-relative allow-relative))))))
   :describer ((stream &key plural-count)
	       (ignore against-default)
	       (when (numberp plural-count)
		 (setq plural-count (> plural-count 1)))
	       (cl:write-string (if plural-count
				    "character style sizes"
				    "a character style size")
				stream)
	       (format stream " for family ~A face ~A" family face)))

(defun read-character-style-component (stream component-default provide-default dot-p
				       p-t-name &rest p-t-data-args)
  (let ((p-t `((,p-t-name ,@(copy-list p-t-data-args))))
	(dw:*allow-sensitive-raw-text-override* t))
    (prog1 (accept p-t
		   :default component-default
		   :provide-default provide-default
		   :stream stream
		   :prompt nil
		   :additional-blip-chars (when dot-p `(#\.)))
	   (when dot-p
	     (let ((delim (read-char-for-accept stream)))
	       (unless (compare-char-for-accept delim #\.)
		 (unread-char-for-accept delim stream)
		 (presentation-replace-input stream (send stream :read-location)
					     "." :dont-quote t)))))))


(defun show-character-style-family-help (stream stuff-so-far device &key (allow-relative t) (allow-device-font t))
  (show-help-for-presentation-type `((character-style-family :device ,device
							     :allow-relative ,allow-relative
							     :allow-device-font ,allow-device-font))
				   stream stuff-so-far))

(defun show-character-style-face-help (stream stuff-so-far against-default device)
  (show-help-for-presentation-type `((character-style-face :device ,device
							   :family NIL
							   :against-default ,against-default
							   :allow-relative t))
				   stream stuff-so-far))

(define-presentation-type character-style (() &key for-attribute-list)
   :history t
   :no-deftype t
   :description "a character style"
   :parser ((stream &key default)
	    (with-accept-help
		((:subhelp "A character style is composed of a family, face, and size, separated
by dots, as in `FIX.ROMAN.NORMAL'.~&"))
	      (multiple-value-bind (ignore default-family default-face default-size)
		  (when default
		    (si:unparse-style-components default))
		(let* ((family (read-character-style-component
				 stream default-family (not (null default)) t
				 'character-style-family))
		       (face (read-character-style-component
			       stream default-face (not (null default)) t
			       'character-style-face :family family))
		       (size (read-character-style-component
			       stream default-size (not (null default)) nil
			       'character-style-size :family family :face face)))
		  (si:intern-character-style family face size)))))
   :printer ((style stream)
		(setq style (si:parse-character-style style))
		(if for-attribute-list
		    (let ((cl:*package* nil))
		      (prin1 (si:unparse-character-style style)))
		    (princ style stream))))



(defvar si:*standard-default-character-style*
	(si:parse-character-style '(:fix :roman :normal)))

(defun read-menu-blip (stream against-default device allow-relative)
  ;; This is used by more than one of these presentation-types.
  ;; First peek ahead to see if the :menu gesture is gestured.
  (let ((char (dw::with-in-band-menu (:name "Character style menu")
		(dw::with-accept-blip-chars ('(#\Space #\.))
		  ;; Special case c-? and c-/ as well.
		  (dw::with-accept-activation-chars ('(#\c-? #\c-/))
		    (dw:peek-char-for-accept stream t))))))
    ;; Magic code from MMcM
    (cond ((and (listp char) (eq (first char) :activation)
		(dw::accept-activation-p (second char)))
	   (zl:parse-ferror "A family, face, and size are required."))
	  ((and (listp char) (eq (first char) 'dw::in-band-menu))
	   ;; get the menu blip out and call the character style menu
	   (dw:read-char-for-accept stream)
	   (let ((style
		   (get-character-style-from-menu
		     against-default device allow-relative)))
	     (when (null style)
	       ;; If the mouse moves off the menu, throw
	       (send stream :force-rescan))
	     ;; Echo the character style from the menu
	     (echo-presentation-blip stream `(character-style
					       ,(second char)
					       ,style))
	     ;; and return it.
	     style))
	  (T nil))))

(define-presentation-type character-style-for-device
      ((&key
	 device
	 (against-default si:*standard-default-character-style*)
	 (allow-relative t)
	 (allow-device-font nil))
       &key for-attribute-list (provide-subhelp t))
   :expander `character-style
   ;; :TYPEP actually makes the data arguments mean something as far as mouse
   ;; sensitivity is concerned.  The default values of the data arguments need
   ;; to default to the most general case.
   :typep ((char-style)
	   (ignore allow-device-font)
	   (and (typep char-style 'character-style)
		(or allow-relative
		    (not (si:character-style-relative-p char-style)))
		;; Needs to hack :ALLOW-RELATIVE.
		(or (null device)
		    (si:style-valid-p char-style against-default device))))
   :describer ((stream)
	       (cond (allow-relative
		      (write-string "a character style" stream))
		      (t (write-string "a fully specified character style" stream))))
   :parser
     ((stream &key default)
      (let ((start-loc (send stream :read-location))
	    (at-top-level-p t))
	(when (null device)
	  (error "You must supply a device."))
	(with-accept-help-if provide-subhelp
	    ((:subhelp #'(lambda (stream ignored)
			   (ignore ignored)
			   (format stream
			       "A character style is composed of a family, face, and size, separated
by dots, as in `FIX.ROMAN.NORMAL'.~&")
			   (when at-top-level-p
			     (terpri stream)
			     (show-character-style-family-help stream "" device
			       :allow-relative allow-relative
			       :allow-device-font allow-device-font)))))
	  (multiple-value-bind (ignore default-family default-face default-size)
	      (when default
		(si:unparse-style-components default))
	    (setq against-default (si:parse-character-style against-default))
	    (flet ((read-character-style ()
		     (send stream :set-location start-loc)
		     (let ((family (read-character-style-component
				     stream default-family (not (null default)) T
				     'character-style-family
				     :device device
				     :allow-relative allow-relative
				     :allow-device-font allow-device-font)))
		       (cond ((eq family :device-font)
			      (accept `((character-style-device-font :device ,device))
				      :prompt nil :default nil :stream stream))
			     (t (let* ((face (read-character-style-component
					       stream default-face (not (null default)) T
					       'character-style-face
					       :device device
					       :family family
					       :allow-relative allow-relative
					       :against-default against-default))
				       (size (read-character-style-component
					       stream default-size (not (null default)) nil
					       'character-style-size
					       :family family
					       :face face
					       :device device
					       :allow-relative allow-relative
					       :against-default against-default)))
				  (let ((style (si:intern-character-style family face size)))
				    ;; We think that this code is necessary, but we can't produce
				    ;; a test case.
				    (if allow-relative
					(unless (character-style-valid? style against-default device)
					  (cp::cp-error t "The style ~A is not a valid character style for ~
					 device ~A."
							style device))
				      (unless (character-style-valid? style nil device)
					(cp::cp-error t "The style ~A is not a valid, fully-specified ~
					 character style for device ~A."
						      style device)))
				    style)))))))
	      (let ((dw:*allow-sensitive-raw-text-override* t))
		(or
		  (dw::with-accept-help
		      ((:subhelp "You can click on a family from the list above,~%~
or you can click mouse right to enter the character style through a menu."))
		    (kludging-character-style-family-input-context
		      (stream start-loc device :allow-relative allow-relative)
		      (read-menu-blip stream against-default device allow-relative)))
		  (progn (setq at-top-level-p nil)
			 (read-character-style))))))))))

(define-presentation-type character-style-device-font ((&key device)
						       &key (provide-subhelp t))
   :expander 't
   :printer ((device-font stream)
	     (write-string (symbol-name (si:cs-face device-font)) stream))
   :parser ((stream &key original-type initially-display-possibilities)
	    (when (null device)
	      (error "You must supply a device."))
	    (unless (eq device si:*b&w-screen*)
	      (sys:parse-ferror
		"DEVICE-FONT is currently supported only for the B&W-Screen device."))
	    (dw:with-accept-help-if provide-subhelp
		((:subhelp
		   "You are currently entering the name of a device font (e.g. SWISS20B)."))
	      (let ((dw:*allow-sensitive-raw-text-override* t))
		(values
		  (dw:completing-from-suggestions (stream
						    :type original-type
						    :initially-display-possibilities
						    initially-display-possibilities)
		    (do-symbols (symbol "FONTS")
		      (when (and (boundp symbol)
				 (typep (symbol-value symbol) '(structure sys:font)))
			(dw:suggest (string symbol) (si:character-style-for-device-font
						      symbol device)))))))))
   :describer ((stream &key plural-count)
	       (when (numberp plural-count)
		 (setq plural-count (> plural-count 1)))
	       (cl:write-string (if plural-count
				    "device fonts"
				    "a device font")
				stream))
   )

(COMPILER-LET ((COMPILER:*ENABLE-FRAME-SPLITTING* t))
(define-presentation-type character-face-or-style
      ((&key
	 device
	 ;; No need for (:allow-relative t) because relative styles are of course
	 ;; accepted for this.  What do you think BOLD is?
	 (against-default si:*standard-default-character-style*))
       &key for-attribute-list)
   :description "a character face or style"
;; Don't need this :ABBREVIATION-FOR any more.  All the relevant mouse-sensitivity
;; happens through explicit calls to ACCEPT or through explicit 
;; with-presentation-input-contexts
;   :abbreviation-for `((or ((character-style-for-device
;			      :device ,device
;			      :against-default ,against-default
;			      :allow-relative t))
;			   ((character-style-face :device ,device
;						  :against-default ,against-default
;						  :allow-relative t))))
   :history t	;character-style	--- Doesn't work because of incompatible types.
   
   :parser ((stream &key default)
	    ;; Device is really required.
	    (let ((at-top-level-p t))
	      ;; Deliberately didn't indent this so that source compare has
	      ;; some hope of working.
	      (when (null device)
		(error "You must supply a device."))
	      (setq against-default (si:parse-character-style against-default))
	      (with-accept-help
		  ((:subhelp #'(lambda (stream ignored)
				 (declare (sys:downward-function))
				 (format stream
				     "You can type:
  a character style face, as in ITALIC, or
  a character-style, as in FIX.ROMAN.NORMAL, or
  a device font, as in DEVICE-FONT.SWISS20B.
You can click on a visible character to use its style.
Click mouse right for a menu of common character styles.")
				 (when at-top-level-p
				   (terpri stream)
				   (terpri stream)
				   (dw::show-character-style-family-help stream "" device)
				   (terpri stream)
				   (dw::show-character-style-face-help stream "" against-default device)
				   ))))
		;; Need this PRESENTATION-INPUT-CONTEXT so that characters
		;; will be sensitive as character-style-for-devices.
		(with-presentation-input-context (`((character-style-for-device
						    :device ,device
						    :against-default ,against-default
						    :allow-relative t))
						  :stream stream)
					       (blip)
		   (let ((start-loc (send stream :read-location)))
		     (labels ((read-style-face ()
				(with-accept-help
				    ((:subhelp #'(lambda (stream string-so-far)
						   (declare (sys:downward-function))
						   (show-character-style-family-help
						     stream string-so-far device))))
				  (kludging-character-style-family-input-context
				    (stream start-loc device :signal-p 'character-style-face :allow-relative t)
				    ;; KLUDGE!!!!!
				    (let
				      ((foo
					 (with-accept-blip-chars ('(#\.))
					   (with-accept-activation-chars ('(#\complete
									    #\c-/
									    #\c-?))
					     (with-in-band-menu (:name "Menu of faces.")
					       (with-accept-help
						   ((:subhelp
						      #'(lambda (stream string)
							  (declare (sys:downward-function))
							  (terpri stream)
							  (show-character-style-face-help
							    stream string
							    against-default device))))
						 (kludging-character-style-face-input-context
						   (stream start-loc device against-default)
						   (read-standard-token stream)))))))
					  (delim (read-char-for-accept stream)))
				      (when (compare-char-for-accept delim #\.)
					(signal 'input-not-of-required-type
						:type 'character-style-face
						:string foo))
				      (unread-char-for-accept delim stream)
				      (send stream :set-location start-loc))
				      (let ((face (accept `((character-style-face
							    :device ,device
							    :against-default ,against-default)
							  :provide-subhelp nil)
							:prompt nil
							:additional-blip-chars '(#\.)
							:default (when (symbolp default)
								   default)
							:stream stream))
					  ;; don't need to specify hang-p, there must be a delimiter.
					  (delimiter (peek-char-for-accept stream)))
				      ;; If the delimiter is a #\. assume that a character-style
				      ;; was being typed, not a character-style-face.
				      (when (compare-char-for-accept delimiter #\.)
					;; This parse-ferror is only being used to trigger the rescanning.
					;; This is what it should say:
					;; "A period should not be used to terminate a character-style-face."
					(signal 'input-not-of-required-type
						:type 'character-style-face
						:string (string face)))
				      ;; Make up a character style using the specified face
				      (si:intern-character-style nil face nil))
				    )))
			    (read-character-style ()
			      (send stream :set-location start-loc)
			      (let ((valid-default
				      ;; Don't offer the default if it isn't valid.
				      ;; Perhaps last time it wouldn't allow-relative.
				      (and (typep default 'character-style)
					   (character-style-valid?
					     default
					     against-default
					     device))))
				(let ((style
					(accept `((character-style-for-device
						    :device ,device
						    :against-default ,against-default
						    :allow-device-font t
						    :allow-relative t)
						  :provide-subhelp nil)
						:prompt nil
						:default (and valid-default default)
						:stream stream)))
				  style)))
			    )
		       (let ((dw:*allow-sensitive-raw-text-override* t))
			 (condition-case ()
			      (or (kludging-character-style-family-input-context
				    (stream start-loc device :signal-p 'character-style-face :allow-relative t)
				    (kludging-character-style-face-input-context
				      (stream start-loc device against-default)
				      (read-menu-blip stream against-default device t)))
				  (progn (setq at-top-level-p nil)
					 (read-style-face)))
			    (input-not-of-required-type
			      ;; Really we should make sure that the type that the
			      ;; "input was not of" is a character-style-face.
			      (read-character-style))))))
		   (character-style-for-device (presentation-blip-object blip)))))))
)


#||
(defvar *do-some-args* ())
(defvar *do-some-count-pass* ())
(defvar *do-some-count* ())
(defvar *do-some-total-count* ())

(defmacro do-some ((keyword &rest values) &body body)
  `(do-some-internal (zl:named-lambda do-some () ,@body) ,keyword ,@values))

(defun do-some-internal (continuation keyword &rest values)
  (declare (sys:downward-funarg continuation))
  (flet ((doit ()
	   (dolist (value values)
	     (if (eq value :unsupplied)
		 (funcall continuation)
		 (stack-let ((*do-some-args* (list* keyword value *do-some-args*)))
		   (funcall continuation))))))
    (cond ((null *do-some-total-count*)
	   (let ((*do-some-total-count* (length values)))
	     (let ((*do-some-count-pass* T))
	       (funcall continuation))		;increments *do-some-total-count*
	     (let ((*do-some-count* 0))
	       (tv:noting-progress ((format nil "~d test cases" *do-some-total-count*))
		 (doit)))))
	  (*do-some-count-pass*
	   (setq *do-some-total-count* (* *do-some-total-count* (length values)))
	   (funcall continuation))
	  (T (doit)))))

(defun zaccept (presentation-type-name &rest accept-args)
  (unless *do-some-count-pass*
    (let ((*query-io* *terminal-io*))
      (terpri *query-io*)
      (when *do-some-total-count*
	(incf *do-some-count*)
	(tv:note-progress *do-some-count* *do-some-total-count*)
	(format *query-io* "~d/~d" *do-some-count* *do-some-total-count*))
      (format *query-io* "~~{~(~s~) ~s~%~^~}~" *do-some-args*)
      (stack-let ((p-t `((,presentation-type-name ,@*do-some-args*))))
	(values (apply #'accept p-t accept-args))))))

(zaccept 'character-style-family)

;; These have to be compiled, because of an interpreter bug (actually mapforms)
(defun test-family ()
  (do-some (:allow-relative :unsupplied nil T)
    (do-some (:device :unsupplied si:*b&w-screen* lgp:*lgp2-printer*)
      (zaccept 'character-style-family))))

(zaccept 'character-style-face)

(defun test-face ()
  (do-some (:family :unsupplied :jess :swiss)
    (do-some (:device :unsupplied si:*b&w-screen* lgp:*lgp2-printer*)
      (do-some (:against-default :unsupplied '(:fix :roman :normal))
	(do-some (:allow-relative :unsupplied nil T)
	  (zaccept 'character-style-face))))))

(defun test-size ()
  (do-some (:device :unsupplied si:*b&w-screen* lgp:*lgp2-printer*)
    (do-some (:family :unsupplied :jess :swiss)
      (do-some (:face :unsupplied :bold)
	(do-some (:against-default :unsupplied '(:fix :roman :normal))
	  (do-some (:allow-relative :unsupplied nil T)
	    (zaccept 'character-style-size)))))))

(stack-let ((*do-some-args* `(:family :swiss
			      :face :italic
			      :against-default (:fix :roman :small)
			      :allow-relative t
			      :device ,lgp:*lgp2-printer*)))
  (zaccept 'character-style-size :default :large))

(cp:define-command (com-test-new-style :command-table 'user)
    ((cs 'character-style
	 :default (si:parse-character-style '(:fix :roman :normal))))
   (princ cs))

(cp:define-command (com-test-two-style :command-table 'user)
    ((dev '((member screen lgp2)))
     (cs `((character-style-for-device :allow-relative nil
			    :device ,(ecase dev
				       (screen si:*b&w-screen*)
				       (lgp2 lgp:*lgp2-printer*))))
	 :default (si:parse-character-style '(:fix :roman :normal))))
   (princ cs))

(cp:define-command (com-test-three-style :command-table 'user)
    ((dev '((member screen lgp2)))
     (cs `((character-face-or-style :device ,(ecase dev
					       (screen si:*b&w-screen*)
					       (lgp2 lgp:*lgp2-printer*))))
	 :default si:*standard-default-character-style*))
   (princ cs))

;;; Family TEST, merged against a default of FIX.ROMAN.NORMAL will not map to
;;; a valid
si:
(define-character-style-families *b&w-screen* *standard-character-set*
  '(:family test
	    (:size :normal
		   (:face :roman (:style test1 :roman :smaller)
			  :italic (:style :eurex :italic :huge)))
	    test1
	    (:size :small
		   (:face :roman fonts:cptfont
			  :italic (:style :eurex :italic :huge)))))
||#
(defun get-character-style-from-menu (default device allow-relative)
  (let ((choice (style-from-menu-first-choice default device allow-relative)))
    (if (neq choice :other-style)
	choice
	(style-from-menu-choose-family default device allow-relative))))

(defun style-from-menu-first-choice-fully-specified ()
  (zwei:zcollecting-into (l)
    (loop for (family family-desc) in '((:fix "FIX.ROMAN.NORMAL")
					(:swiss "SWISS.ROMAN.NORMAL")
					(:dutch "DUTCH.ROMAN.NORMAL"))
	  as style = (si:intern-character-style family :roman :normal)
	  do (zwei:zcollect l
			    (list (si:change-string-character-style
				    family-desc
				    style)
				  :value style
				  :documentation (format nil "Use character style ~a"
							 (si:string-for-style-name style)))))
    (zwei:zcollect l '("Other style, by Family/Face/Size ..."
		       :value :other-style
		       :documentation "Choose style components from separate menus"))
    (menu-choose l :prompt "Fully Specified Character Style")))


(defun style-from-menu-first-choice (default device allow-relative)
  (if (not allow-relative)
      (style-from-menu-first-choice-fully-specified)
    (zwei:zcollecting-into (l)
      (loop for (family family-desc) in
		'((nil "---Unspecific (family NIL)---")
		  (:fix "---Code (family Fix)---")
		  (:swiss "---Text (family Swiss)---"))
	    do (zwei:zcollect l
			      (list
				(si:change-string-character-style
				  family-desc
				  (stack-let ((s (list family :roman nil)))
				    (si:merge-character-styles s default)))
				:no-select T))
	       (loop for faces on '(:roman :italic :bold :bold-italic)
		     for (face . more-faces) = faces
		     for face-desc in '("Roman" "Italic" "Bold" "Bold Italic")
		     for style = (si:intern-character-style family face nil)
		     for font-p = (si:style-valid-p style default device)
		     do (ignore more-faces)
		     when font-p
		       do (zwei:zcollect l
					 `(,(si:change-string-character-style
					      (cl:princ-to-string face-desc)
					      (si:merge-character-styles style default))
					   :value ,style
					   :documentation
					   ,(format () "Use character style ~a"
						    (si:string-for-style-name style))))))
      (zwei:zcollect l '("Other style, by Family/Face/Size ..."
			 :value :other-style
			 :documentation "Choose style components from separate menus"))
      (menu-choose l :prompt "Character Face Code"))))

(defun style-from-menu-choose-family (against-default device allow-relative)
  (flet ((choose (choices label-string &optional (sort-p t))
	   (when sort-p
	     (setq choices (sort choices #'string-lessp :key #'car)))
	   (multiple-value-bind (choice item)
	       (menu-choose choices
			    :prompt
			    (si:change-string-character-style
			      label-string '(nil :bold nil)))
	     (if item
		 choice
		 (return-from style-from-menu-choose-family ())))))
    (flet ((choose-family ()
	     (let ((choices nil))
	       (map-over-valid-character-style-families
		 #'(lambda (family)
		     (push `(,(princ-to-string family) ,family) choices))
		 :device device
		 :allow-relative allow-relative)
	       (choose choices "Character Style Family")))
	   (choose-face (family-name)
	     (let ((choices nil))
	       (map-over-valid-character-style-faces-for-family
		 #'(lambda (face)
		     (push `(,(princ-to-string face) ,face) choices))
		 family-name against-default
		 :device device
		 :allow-relative allow-relative)
	       (choose choices (format () "Face for family ~a" family-name))))
	   (choose-size (family-name face-name)
	     (let ((choices nil)
		   (relative-choices nil))
	       (map-over-valid-character-style-sizes-for-family-face
		 #'(lambda (size)
		     (if (si:character-style-relative-p (si:intern-character-style family-name face-name size))
			 (push `(,(princ-to-string size) ,size) relative-choices)
			 (push `(,(princ-to-string size) ,size) choices)))
		 family-name face-name against-default
		 :device device
		 :allow-relative allow-relative)
	       (choose (append '(("          Absolute sizes" :no-select t))
				 choices
				 '(("          Relative sizes" :no-select t))
				 relative-choices)
		       (format () "Size for Family ~a face ~a"
			       family-name face-name)
		       nil))))
      (let* ((family (choose-family))
	     (face (choose-face family))
	     (size (choose-size family face)))
	(si:intern-character-style family face size)))))


(defun narrow-type-equivalent (type-1 type-2)
  (with-presentation-type-key (key-1 type-1)
    (with-presentation-type-key (key-2 type-2)
      (fringe-eql key-1 key-2))))

;;; Support for the translators.
(defun exact-match-in-tree-p (presentation)
  (loop for presentation = presentation then (presentation-superior
					       presentation)
	while presentation
	doing (map-over-input-contexts
		#'(lambda (context)
		    (when (narrow-type-equivalent
			    (presentation-input-context-presentation-type
			      context)
			    (presentation-type presentation))
		      (return-from exact-match-in-tree-p t))))))

;;; Some translators
(define-presentation-translator characters-character-style
   (raw-text character-style
    :tester ((bp &key input-context presentation)
	     (when (< (second bp) (string-length (first bp)))
	       (cond ((not
			(handler-applies-in-limited-context-p
			  input-context
			  'character-style))
		      nil)
		     (t
		      (not (exact-match-in-tree-p presentation)))))))
   (bp)
  (when (< (second bp) (string-length (first bp)))
    (let ((char (aref (first bp) (second bp))))
      (si:char-style char))))

(define-presentation-translator characters-character-style-for-device
   (raw-text character-style-for-device
    :tester ((bp &key input-context presentation)
	     (when (< (second bp) (string-length (first bp)))
	       (cond ((not
			(handler-applies-in-limited-context-p
			  input-context
			  'character-style-for-device))
		      nil)
		     (t
		      (not (exact-match-in-tree-p presentation)))))))
   (bp)
  (when (< (second bp) (string-length (first bp)))
    (let ((char (aref (first bp) (second bp))))
      (si:char-style char))))

(define-presentation-translator characters-character-style-for-device-from-menu
   (raw-text character-style-for-device
    :do-not-compose t
    :gesture :menu
    :documentation "Character style menu"
    :tester ((ignore &key input-context presentation)
	     (when (and
		     (handler-applies-in-limited-context-p
		       input-context
		       'character-style-for-device)
		     (not (exact-match-in-tree-p presentation)))
	       t)))
   (ignore &key input-context)
  (let ((context-type (presentation-input-context-presentation-type input-context)))
    (with-presentation-type-arguments (character-style-for-device context-type)
      ;; Return only one value, so that if the user moves the mouse out of the
      ;; menu and we return nil, accept keeps awaiting input instead of
      ;; returning the character style nil.nil.nil
      (values (get-character-style-from-menu against-default device allow-relative)))))

(define-presentation-translator characters-character-style-family
   (raw-text character-style-family
    :tester ((ignore &key input-context)
	     ;; Defer to characters-character-style or characters-character-style-for-device
	     ;; if there is an outer context that wants a whole character style
	     (not (handler-applies-in-limited-context-p input-context 'character-style))))
   (bp)
  (when (< (second bp) (string-length (first bp)))
    (let ((char (aref (first bp) (second bp))))
      (values (si:cs-family (si:char-style char))
	      'character-style-family))))

(define-presentation-translator characters-character-style-face
   (raw-text character-style-face
    :tester ((bp &key input-context)
	     ;; Defer to characters-character-style or characters-character-style-for-device
	     ;; if there is an outer context that wants a whole character style.
	     (or (not (handler-applies-in-limited-context-p input-context 'character-style))
		 ;; However, if we are accepting a character-face-or-style, and the
		 ;; character's only non-null style component is the face, the mouse
		 ;; documentation line looks nicer if we show just the face,
		 ;; rather than NIL.face.NIL.
		 (and (handler-applies-in-limited-context-p input-context
							    'character-face-or-style)
		      (< (second bp) (string-length (first bp)))
		      (let ((style (si:char-style (aref (first bp) (second bp)))))
			(and (not (null (si:cs-face style)))
			     (null (si:cs-family style))
			     (null (si:cs-size style))))))))
   (bp)
  (when (< (second bp) (string-length (first bp)))
    (let ((char (aref (first bp) (second bp))))
      (values (si:cs-face (si:char-style char))
	      'character-style-face))))

(define-presentation-translator characters-character-style-size
   (raw-text character-style-size
    :tester ((ignore &key input-context)
	     ;; Defer to characters-character-style or characters-character-style-for-device
	     ;; if there is an outer context that wants a whole character style
	     (not (handler-applies-in-limited-context-p input-context 'character-style))))
   (bp)
  (when (< (second bp) (string-length (first bp)))
    (let ((char (aref (first bp) (second bp))))
      (values (si:cs-size (si:char-style char))
	      'character-style-size))))
