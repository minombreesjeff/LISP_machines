;; -*- Mode: LISP; Syntax: Common-Lisp; Base: 10; Package: CONVERSION-TOOLS; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Tool for aiding conversion of Dynamic Windows applications to CLIM
;;; This is generally targeted to CLIM 1.1 and CLIM 2.0 (as of 27-Jul-92).

;;; Note that we have to use CLIM:: everywhere because there is no guarantee
;;; that these symbols are exported from the CLIM package (e.g., CLIM 1.1
;;; symbols that are not in a CLIM 2.0 world).

(define-conversion-set dw-to-clim
		       define-dw-to-clim-substitution	;symbol  symbol substitution
		       define-dw-to-clim-conversion	;form  form conversion
		       :funarg-macro define-dw-to-clim-funarg-substitution
		       :message-macro define-dw-to-clim-message-conversion
		       :pretty-name "DW to CLIM")

;; Symbols to be exported from the CLIM package when running CLIM 1.1
(defvar *clim1-symbols-to-export*
	'(*abort-gestures*
	  *activation-gestures*
	  *completion-gestures*
	  *delimiter-gestures*
	  *help-gestures*
	  *possibilities-gestures*
	  *standard-activation-gestures*
	  *unsupplied-argument-marker*
	  +background-ink+
	  +foreground-ink+
	  +textual-dialog-view+
	  +textual-menu-view+
	  activation-gesture-p
	  add-gesture-name
	  add-output-record
	  apply-presentation-generic-function
	  bounding-rectangle-position
	  bounding-rectangle-set-position
	  command-enabled
	  compose-rotation-with-transformation
	  compose-scaling-with-transformation
	  compose-translation-with-transformation
	  cursor-position
	  cursor-set-position
	  delete-gesture-name
	  delete-output-record
	  delimiter-gesture-p
	  drag-output-record
	  draw-pattern*
	  draw-text
	  draw-text*
	  event-modifier-state
	  event-sheet
	  frame-current-layout
	  frame-top-level-sheet
	  funcall-presentation-generic-function
	  make-ihs-color
	  make-rgb-color
	  map-over-output-records
	  map-over-output-records-containing-position
	  map-over-output-records-overlapping-region
	  output-record-children
	  output-record-count
	  output-record-end-cursor-position
	  output-record-position
	  output-record-refined-position-test
	  output-record-set-end-cursor-position
	  output-record-set-position
	  output-record-set-start-cursor-position
	  output-record-start-cursor-position
	  point-position
	  pointer-position
	  pointer-set-position
	  position-sheet-carefully
	  position-sheet-near-pointer
	  presentation-type-of
	  redisplay-output-record
	  region-contains-position-p
	  replay-output-record
	  simple-parse-error
	  size-frame-from-contents
	  stream-add-output-record
	  stream-current-output-record
	  stream-cursor-position
	  stream-drawing-p
	  stream-increment-cursor-position
	  stream-insertion-pointer
	  stream-output-history
	  stream-pointer-position
	  stream-recording-p
	  stream-replay
	  stream-rescanning-p
	  stream-scan-pointer
	  stream-set-cursor-position
	  stream-set-pointer-position
	  stream-vertical-spacing
	  text-style-mapping
	  textual-dialog-view
	  textual-menu-view
	  transform-position
	  untransform-position
	  window-set-viewport-position
	  window-viewport-position
	  with-activation-gestures
	  with-delimiter-gestures))

;; Symbols to be exported from the CLIM package when running CLIM 2.0
(defvar *clim2-symbols-to-export*
	'(*abort-characters*
	  *activation-characters*
	  *blip-characters*
	  *completion-characters*
	  *help-characters*
	  *possibilities-characters*
	  *standard-activation-characters*
	  *unsupplied-argument*
	  +background+
	  +dialog-view+
	  +foreground+
	  +menu-view+
	  activation-character-p
	  #+ignore add-output-record		;in CLIM 2.0, but does something different
	  add-output-record-element
	  add-pointer-gesture-name
	  add-text-style-mapping
	  blip-character-p
	  bounding-rectangle-position*
	  bounding-rectangle-set-position*
	  (call-presentation-generic-function clim-internals)
	  command-enabled-p
	  compose-rotation-transformation
	  compose-scaling-transformation
	  compose-translation-transformation
	  cursor-position*
	  cursor-set-position*
	  delete-output-record-element
	  (dialog-view silica)
	  disable-command
	  dragging-output-record
	  draw-character
	  draw-character*
	  draw-icon
	  draw-icon*
	  draw-string
	  draw-string*
	  enable-command
	  (event-window clx-clim)
	  frame-top-level-window
	  (input-position clim-internals)
	  (insertion-pointer clim-internals)
	  make-color-ihs
	  make-color-rgb
	  map-over-output-record-elements
	  map-over-output-record-elements-containing-point*
	  map-over-output-record-elements-overlapping-region
	  menu-view
	  open-root-window
	  output-record-element-count
	  output-record-elements
	  output-record-end-position*
	  output-record-position*
	  output-record-refined-sensitivity-test
	  output-record-set-end-position*
	  output-record-set-position*
	  output-record-set-start-position*
	  output-record-start-position
	  output-record-start-position*
	  output-recording-stream-current-output-record-stack
	  output-recording-stream-output-record
	  output-recording-stream-output-record
	  output-recording-stream-replay
	  #+ignore parse-error			;in CLIM 2.0, but slightly different
	  point-position*
	  pointer-event-shift-mask
	  pointer-position*
	  pointer-set-position*
	  position-window-near-carefully
	  position-window-near-pointer
	  redisplay-1
	  region-contains-point*-p
	  remove-pointer-gesture-name
	  (replay-1 clim-internals)
	  (rescanning-p clim-internals)
	  set-frame-layout
	  size-menu-appropriately
	  stream-cursor-position*
	  stream-draw-p
	  stream-increment-cursor-position*
	  stream-pointer-position*
	  stream-pointer-position*
	  stream-record-p
	  stream-set-cursor-position*
	  stream-set-pointer-position*
	  stream-set-pointer-position*
	  stream-vsp
	  transform-point*
	  untransform-point*
	  window-set-viewport-position*
	  window-viewport-position*
	  with-activation-characters
	  with-blip-characters
	  with-frame-state-variables))

(defun mung-clim-package ()
  (let ((clim (find-package 'clim)))
    (si:with-package-lock clim nil
      (dolist (sym-and-pkg (cond ((member :clim-1 *features*) 
				  *clim1-symbols-to-export*)
				 ((member :clim-2 *features*)
				  *clim2-symbols-to-export*)))
	(let* ((sym (if (listp sym-and-pkg) (first sym-and-pkg) sym-and-pkg))
	       (pkg (if (listp sym-and-pkg) (second sym-and-pkg) clim))
	       (symbol (if (eq pkg clim)
			   (intern (symbol-name sym) pkg)
			   (multiple-value-bind (symbol foundp)
			       (find-symbol (symbol-name sym) clim)
			     (if foundp
				 symbol
				 (progn
				   ;; Avoid error in EXPORT below
				   (si:import-internal (intern (symbol-name sym) pkg) clim)
				   (intern (symbol-name sym) clim)))))))
	  ;; EXPORT will complain anyway
	  (si:set-symbol-status symbol clim si:pkg-external-code))))))

(defun unmung-clim-package ()
  (let ((clim (find-package 'clim)))
    (si:with-package-lock clim nil
      (dolist (sym-and-pkg (cond ((member :clim-1 *features*) 
				  *clim1-symbols-to-export*)
				 ((member :clim-2 *features*)
				  *clim2-symbols-to-export*)))
	(let* ((sym (if (listp sym-and-pkg) (first sym-and-pkg) sym-and-pkg))
	       (pkg (if (listp sym-and-pkg) (second sym-and-pkg) clim))
	       (symbol (if (eq pkg clim)
			   (intern (symbol-name sym) pkg)
			   (multiple-value-bind (symbol foundp)
			       (find-symbol (symbol-name sym) clim)
			     (if foundp
				 symbol
				 (progn
				   (si:import-internal (intern (symbol-name sym) pkg) clim)
				   (intern (symbol-name sym) clim)))))))
	  (unexport symbol clim))))))

(defvar *clim-version*)

(defmethod (with-additional-conversion-state dw-to-clim) (continuation)
  (let ((*clim-version* (zwei:typein-line-accept '(alist-member :alist (("1.1" 1) ("2.0" 2)))
			  :prompt "Convert to CLIM 1.1 or CLIM 2.0"
			  :default #+CLIM-2 2 #-CLIM-2 1)))
    (unwind-protect
	(progn
	  (mung-clim-package)
	  (funcall continuation))
      (unmung-clim-package))))

;; First value is the new option list
;; Second value is T if unable to parse the options
;; Warn if a DW option that does not exist in CLIM is used, and leave it in with a flag
;; This assumes all option keywords are self-evaluating so they don't have to be requoted
(defun verify-clim-options (dw-function clim-function eval options common-options dw-options
			    &optional ignore-options rename-options-alist)
  (declare (values options error))
  (let ((not-dw nil) (not-clim nil) (new-options nil) (not-dw-options nil))
    (unless (and (listp options) (null (cdr (last options))) (evenp (length options)))
      (return-from verify-clim-options (values options t)))
    (loop for (key val) on options by #'cddr with rename do
      (when eval
	(unless (constantp key)
	  (return-from verify-clim-options (values options t)))
	(setq key (eval key)))
      (cond ((setq rename (assoc key rename-options-alist))
	     (setq new-options (nconc new-options (list* (second rename) val nil))))
	    ((member key ignore-options))
	    ((member key common-options)
	     (setq new-options (nconc new-options (list* key val nil))))
	    ((not (member key dw-options))
	     (pushnew key not-dw)
	     (push key not-dw-options)
	     (push val not-dw-options))
	    (t (pushnew key not-clim))))
    (when not-dw
      (warn "~{~S~^, ~} ~:[is not a valid option~;are not valid options~] for ~S in DW.~@
	     ~2:*~:[It~;They~] will be left as :UNCONVERTED-DW-OPTIONS."
	    not-dw (cdr not-dw) dw-function)
      (setq new-options `(,@new-options
			  :unconverted-dw-options ,(nreverse not-dw-options))))
    (when not-clim
      (warn "~{~S~^, ~} ~:[is not a valid option~;are not valid options~] for ~S in CLIM.~@
	     ~2:*~:[It~;They~] will be ignored."
	    not-clim (cdr not-clim) clim-function))
    new-options))

(defun propertyp (plist indicator)
  (loop for key in plist by #'cddr
	when (eq key indicator) return t))


;;; Formatted output

;; This assumes that DW pixels and CLIM pixels are the same size
;; CLIM also has :RECORD-TYPE
(define-dw-to-clim-conversion formatting-table
			      ((&optional (stream nil stream-p) &rest options)
			       &body body)
  :modification-depth 2
  :form
  (multiple-value-bind (options error)
      (verify-clim-options 'formatting-table 'clim::formatting-table nil options
			   (case *clim-version*
			     (1 '(:inter-row-spacing :inter-column-spacing
				  :multiple-columns :multiple-columns-inter-column-spacing
				  :equalize-column-widths))
			     (2 '(:multiple-columns :equalize-column-widths)))
			   '(:extend-width :extend-height 
			     :equalize-multiple-column-widths
			     :output-multiple-columns-row-wise :rules)
			   '(:dont-snapshot-variables)
			   (case *clim-version*
			     (1)
			     (2 '((:inter-row-spacing :y-spacing)
				  (:inter-column-spacing :x-spacing)
				  (:multiple-columns-inter-column-spacing 
				    :multiple-columns-x-spacing)))))
    (unless error
      (setq options (copy-list options))
      (case *clim-version*
	(1 (when (propertyp options :inter-column-spacing)
	     (setf (getf options :inter-column-spacing)
		   (convert-column-spacing (getf options :inter-column-spacing))))
	   (when (propertyp options :multiple-columns-inter-column-spacing)
	     (setf (getf options :multiple-columns-inter-column-spacing)
		   (convert-column-spacing (getf options :multiple-columns-inter-column-spacing)))))
	(2 (when (propertyp options :x-spacing)
	     (setf (getf options :x-spacing)
		   (convert-column-spacing (getf options :x-spacing))))
	   (when (propertyp options :multiple-columns-x-spacing)
	     (setf (getf options :multiple-columns-x-spacing)
		   (convert-column-spacing (getf options :multiple-columns-x-spacing))))))
      `(clim::formatting-table (,@(and (or stream-p options) `(,stream)) ,@options)
	 ,@body))))

(defun convert-column-spacing (spacing)
  ;; String and function are compatible
  ;; Integer can be characters or pixels in DW, pixels [what??] in CLIM
  ;;   DW accepts any number, CLIM only accepts integers
  ;; List is compatible, CLIM also accepts :POINT (not mentioned in the spec)
  ;; CLIM also accepts characters and explicit NILs
  (if (constantp spacing)
      (let ((value (eval spacing)))
	(if (numberp value)
	    (if (< value 10)		;really stream's :char-width, which we can't know
		`'(,(round value) :character)
		(round value))
	    spacing))
      ;; I guess we'll be chintzy and assume that a non-constant argument is
      ;; compatible, rather than putting in a call to a conversion function
      spacing))

;; CLIM also has :RECORD-TYPE
(define-dw-to-clim-conversion formatting-row
			      ((&optional (stream nil stream-p) &rest options)
			       &body body)
  :modification-depth 2
  :form
  (multiple-value-bind (options error)
      (verify-clim-options 'formatting-row 'clim::formatting-row nil options
			   '()
			   '(:single-column)
			   '(:dont-snapshot-variables))
    (unless error
      `(clim::formatting-row (,@(and stream-p `(,stream)) ,@options)
	 ,@body))))

;; Undocumented in CLIM
;; CLIM also has :RECORD-TYPE
(define-dw-to-clim-conversion formatting-column
			      ((&optional (stream nil stream-p) &rest options)
			       &body body)
  :modification-depth 2
  :form
  (multiple-value-bind (options error)
      (verify-clim-options 'formatting-column 'clim::formatting-column nil options
			   '()
			   '()
			   '(:dont-snapshot-variables))
    (unless error
      `(clim::formatting-column (,@(and stream-p `(,stream)) ,@options)
	 ,@body))))

;; CLIM also has :RECORD-TYPE, :MINIMUM-WIDTH, and :MINIMUM-HEIGHT
;; CLIM :ALIGN-Y defaults to :TOP in the implementation, but :BASELINE in the spec
;; DW :ALIGN-Y defaults to :BOTTOM, also allows :TOP and :CENTER but not :BASELINE
;; I can't find any code in CLIM that actually uses these so I don't know what
;; the actual choices are.  I'll assume no conversion of these arguments is required
(define-dw-to-clim-conversion formatting-cell
			      ((&optional (stream nil stream-p) &rest options)
			       &body body)
  :modification-depth 2
  :form
  (multiple-value-bind (options error)
      (verify-clim-options 'formatting-cell 'clim::formatting-cell nil options
			   '(:align-x :align-y)
			   '()
			   '(:dont-snapshot-variables))
    (unless error
      `(clim::formatting-cell (,@(and (or stream-p options) `(,stream)) ,@options)
	 ,@body))))

(define-dw-to-clim-conversion format-cell (object printer &rest options)
  ;;--- Assumes the source code doesn't have quotes in front of the keywords
  (let ((stream (getf options :stream `*standard-output*)))
    (multiple-value-bind (options error)
	(verify-clim-options 'format-cell 'clim::formatting-cell t options
			     '(:align-x :align-y)
			     '()
			     '(:stream))
      (unless error
	`(clim::formatting-cell (,stream ,@options)
	   (funcall ,printer ,object ,stream))))))

;  FORMATTING-MULTIPLE-COLUMNS      ;does not exist
;  FORMATTING-COLUMN-HEADINGS       ;does not exist
;  FORMAT-SEQUENCE-AS-TABLE-ROWS    ;does not exist
;  FORMATTING-TEXTUAL-LIST          ;does not exist
;  FORMATTING-TEXTUAL-LIST-ELEMENT  ;does not exist

;; DW also has :ROW-WISE :OUTPUT-ROW-WISE :EQUALIZE-COLUMN-WIDTHS :INSIDE-WIDTH :INSIDE-HEIGHT
;; CLIM also has :RECORD-TYPE :STREAM-WIDTH :STREAM-HEIGHT :MOVE-CURSOR
;; CLIM's :STREAM-WIDTH :STREAM-HEIGHT :MOVE-CURSOR are undocumented
;; It appears :STREAM-WIDTH and :STREAM-HEIGHT are only used to choose the proportions
;; of the display, whereas :INSIDE-WIDTH and :INSIDE-HEIGHT specify the exact size
(define-dw-to-clim-conversion formatting-item-list
			      ((&optional (stream nil stream-p) &rest options)
			       &body body)
  :modification-depth 2
  :form
  (multiple-value-bind (options error)
      (verify-clim-options 'formatting-item-list 'clim::formatting-item-list nil options
			   (case *clim-version*
			     (1 '(:inter-row-spacing :inter-column-spacing
				  :n-rows :n-columns :max-width :max-height))
			     (2 '(:n-rows :n-columns :max-width :max-height)))
			   '(:row-wise :output-row-wise :equalize-column-widths
			     :inside-width :inside-height)
			   '(:dont-snapshot-variables)
			   (case *clim-version*
			     (1)
			     (2 '((:inter-row-spacing :y-spacing)
				  (:inter-column-spacing :x-spacing)))))
    (unless error
      (setq options (copy-list options))
      (case *clim-version*
	(1 (when (propertyp options :inter-column-spacing)
	     (setf (getf options :inter-column-spacing)
		   (convert-column-spacing (getf options :inter-column-spacing)))))
	(2 (when (propertyp options :x-spacing)
	     (setf (getf options :x-spacing)
		   (convert-column-spacing (getf options :x-spacing))))))
      `(clim::formatting-item-list (,@(and (or stream-p options) `(,stream)) ,@options)
	 ,@body))))

;; DW also has :KEY :FRESH-LINE :RETURN-AT-END :ORDER-COLUMNWISE :OPTIMAL-NUMBER-OF-ROWS
;;      :ADDITIONAL-INDENTATION :EQUALIZE-COLUMN-WIDTHS
;; CLIM also has :INTER-ROW-SPACING :INTER-COLUMN-SPACING :N-ROWS :N-COLUMNS :RECORD-TYPE
;;      :CELL-ALIGN-X :CELL-ALIGN-Y
(define-dw-to-clim-conversion format-item-list
			      (list &rest options)
  (multiple-value-bind (options error)
      (verify-clim-options 'format-item-list 'clim::format-items t options
			   '(:stream :printer :presentation-type :max-width :max-height)
			   '(:key :fresh-line :return-at-end :order-columnwise
			     :optimal-number-of-rows :additional-indentation
			     :equalize-column-widths))
    (unless error
      `(clim::format-items ,list ,@options))))

(define-dw-to-clim-conversion format-textual-list (sequence function &rest options)
  (multiple-value-bind (options error)
      (verify-clim-options 'format-textual-list 'clim::format-textual-list t options
			   '(:stream :separator :conjunction)
			   '(:finally :if-two :filled :fill-column :after-line-break))
    (unless error
      `(clim::format-textual-list ,sequence ,function ,@options))))

;  ABBREVIATING-OUTPUT  ;doesn't exist

(define-dw-to-clim-conversion filling-output
			      ((&optional (stream nil stream-p) &rest options)
			       &body body)
  :modification-depth 2
  :form
  (multiple-value-bind (options error)
      (verify-clim-options 'filling-output 'clim::filling-output nil options
			   '(:fill-characters :after-line-break)
			   '()
			   '(:dont-snapshot-variables)
			   '((:fill-column :fill-width)
			     (:after-line-break-initially-too :after-line-break)))
    (unless error
      (setq options (copy-list options))
      (when (propertyp options :fill-column)
	(setf (getf options :fill-column)
	      (convert-column-spacing (getf options :fill-column))))
      `(clim::filling-output (,@(and (or stream-p options) `(,stream)) ,@options)
	 ,@body))))

(define-dw-to-clim-conversion indenting-output ((stream indentation) &body body)
  :modification-depth 2
  :form
  `(clim::indenting-output (,stream ,(convert-column-spacing indentation))
     ,@body))

(define-dw-to-clim-conversion format-graph-from-root 
			      (root-object object-printer inferior-producer
			       &rest options 
			       &key (root-is-sequence nil ris-p)
				    (default-drawing-mode nil ddm-p)
			       &allow-other-keys)
  (multiple-value-bind (options error)
      (verify-clim-options 'format-graph-from-root 'clim::format-graph-from-root t options
			   '(:stream :orientation :cutoff-depth :key :test)
			   '(:direction :border :balance-evenly :branch-point :allow-overlap)
			   '(:root-is-sequence :default-drawing-mode)
			   '((:dont-draw-duplicates :merge-duplicates)
			     (:key :duplicate-key)
			     (:test :duplicate-test)
			     (:default-drawing-options :arc-drawing-options)
			     (:row-spacing :generation-separation)
			     (:column-spacing :generation-separation)
			     (:within-row-spacing :within-generation-separation)
			     (:within-column-spacing :within-generation-separation)))
    (unless error
      (let ((arc-drawer (and ddm-p
			     (constantp default-drawing-mode)
			     (eq (eval default-drawing-mode) ':arrow)
			     '(:arc-drawer 'clim::draw-arrow*)))
	    (function (if (and ris-p 
			       (constantp root-is-sequence)
			       (eq (eval root-is-sequence) 't))
			  'clim::format-graph-from-roots
			  'clim::format-graph-from-root)))
	`(,function ,root-object ,object-printer ,inferior-producer
		    ,@arc-drawer
		    ,@options)))))

;  FORMATTING-GRAPH		  ;does not exist
;  FORMATTING-GRAPH-NODE	  ;does not exist

;;--- I didn't check whether these were really completely compatible
(define-dw-to-clim-conversion surrounding-output-with-border
			      ((&optional (stream nil stream-p) &rest options)
			       &body body)
  :modification-depth 2
  :form
  (multiple-value-bind (options error)
      (verify-clim-options 'surrounding-output-with-border 'clim::surrounding-output-with-border
			   nil options
			   '(:shape)
			   '(:thickness :margin :pattern :gray-level :opaque :filled :alu
			     :move-cursor :width :height :label :label-position
			     :label-separator-line :label-separator-line-thickness
			     :label-alignment))
    (unless error
      `(clim::surrounding-output-with-border (,@(and (or stream-p options) `(,stream))
					     ,@options)
	 ,@body))))

(define-dw-to-clim-conversion with-underlining
			      ((&optional stream &rest options)
			       &body body)
  :modification-depth 2
  :form
  (multiple-value-bind (options error)
      (verify-clim-options 'with-underlining 'clim::surrounding-output-with-border
			   t options
			   '()
			   '(:underline-whitespace))
    (declare (ignore options))			;no options in common
    (unless error
      `(clim::surrounding-output-with-border (,stream :shape :underline)
	 ,@body))))


;;; Character styles

;; From SI:*VALID-FACES* and CLIM::*FACE->FACE-CODE-CACHE*
(defvar *character-face-conversions* '((:roman :roman) (:bold :bold) (:italic :italic)
				       (:bold-italic (:bold :italic))
				       (:bold-extended (:bold :extended))
				       (:condensed :condensed)
				       (:extra-condensed (:extra :condensed))
				       (:uppercase :uppercase)
				       (:bold-condensed-caps (:bold :condensed :caps))
				       (:condensed-caps (:condensed :caps))
				       (nil nil)))

;; From SI:*VALID-FAMILIES* and CLIM::*TEXT-STYLE-INTERN-TABLE*
;; CLIM spec mentions :TYPEWRITER but :FIX seems to be what is implemented
(defvar *character-family-conversions* '((:fix :fix)
					 (:dutch :serif)
					 (:swiss :sans-serif)
					 (nil nil)))

;; From SI:*VALID-SIZES*, CLIM::*TEXT-STYLE-INTERN-TABLE*, and CLIM::*VALID-TEXT-STYLE-SIZES*
;; I can't find any documentation of what CLIM allows so I don't know if this is right
;; Also I thought I heard CLIM allows numeric sizes, but I don't see them
(defvar *character-size-conversions* '((:huge :huge)
				       (:very-large :very-large)
				       (:large :large)
				       (:normal :normal)
				       (:small :small)
				       (:very-small :very-small)
				       (:tiny :tiny)
				       (:smaller :smaller)
				       (:larger :larger)
				       (:bigger :larger)
				       ;; No :SAME in CLIM
				       (nil nil)))

(defun convert-character-face (face &optional constant)
  (when (or constant (constantp face))
    ;; Convert DW face name to CLIM face name, assuming no :DEVICE-FONT junk
    (let ((value (if constant face (eval face))))
      (unless (member value si:*valid-faces*)
	(warn "~S is not a known DW character face name" value))
      (let ((elem (assoc value *character-face-conversions*)))
	(setq value (if elem (second elem)
			(let ((new (accept 'sys:expression
					   :default value :display-default nil
					   :prompt (format nil "CLIM text face for DW face ~S"
							   value))))
			  (push (list value new) *character-face-conversions*)
			  new)))
	(setq face (if (or constant (null value) (keywordp value)) value
		       (list 'quote value))))))
  face)

(defun convert-character-family (family &optional constant)
  (when (or constant (constantp family))
    ;; Convert DW family name to CLIM family name, assuming no :DEVICE-FONT junk
    (let ((value (if constant family (eval family))))
      (unless (member value si:*valid-families*)
	(warn "~S is not a known DW character family name" value))
      (let ((elem (assoc value *character-family-conversions*)))
	(setq value (if elem (second elem)
			(let ((new (accept 'sys:expression
					   :default value :display-default nil
					   :prompt (format nil
							   "CLIM text family for DW family ~S"
							   value))))
			  (push (list value new) *character-family-conversions*)
			  new)))
	(setq family (if (or constant (null value) (keywordp value)) value
			 (list 'quote value))))))
  family)

(defun convert-character-size (size &optional constant)
  (when (or constant (constantp size))
    ;; Convert DW size to CLIM size
    (let ((value (if constant size (eval size))))
      (unless (member value si:*valid-sizes*)
	(warn "~S is not a known DW character size" value))
      (let ((elem (assoc value *character-size-conversions*)))
	(setq value (if elem (second elem)
			(let ((new (accept 'sys:expression
					   :default value :display-default nil
					   :prompt (format nil "CLIM text size for DW size ~S"
							   value))))
			  (push (list value new) *character-size-conversions*)
			  new)))
	(setq size (if (or constant (null value) (keywordp value)) value
		       (list 'quote value))))))
  size)

;; DW allows NIL or a CHARACTER-STYLE structure or a list of the three components
;; CLIM allows NIL or a list of the three components or a DEVICE-FONT or TEXT-STYLE object
(defun convert-character-style (style)
  (if (constantp style)
      `',(convert-character-style-1 (eval style))
      style))

(defun convert-character-style-1 (style)
  (if (and (consp style) (= (length style) 3))
      `(,(convert-character-family (first style) t)
	,(convert-character-face (second style) t)
	,(convert-character-size (third style) t))
      style))

(define-dw-to-clim-conversion with-character-face
			      ((face &optional (stream nil stream-p) &rest options)
			       &body body)
  :modification-depth 2
  :form
  (multiple-value-bind (options error)
      (verify-clim-options 'with-character-face 'clim::with-text-face nil options
			   '()
			   '(:bind-line-height))
    (unless error
      (case *clim-version*
	(1 `(clim::with-text-face (,(convert-character-face face)
				  ,@(and (or stream-p options) `(,stream))
				  ,@options)
	      ,@body))
	(2 `(clim::with-text-face (,(if stream-p stream t)
				  ,(convert-character-face face)
				  ,@options)
	      ,@body))))))

(define-dw-to-clim-conversion with-character-family
			      ((family &optional (stream nil stream-p) &rest options)
			       &body body)
  :modification-depth 2
  :form
  (multiple-value-bind (options error)
      (verify-clim-options 'with-character-family 'clim::with-text-family nil options
			   '()
			   '(:bind-line-height))
    (unless error
      (case *clim-version*
	(1 `(clim::with-text-family (,(convert-character-family family)
				    ,@(and (or stream-p options) `(,stream))
				    ,@options)
	      ,@body))
	(2 `(clim::with-text-family (,(if stream-p stream t)
				    ,(convert-character-family family)
				    ,@options)
	      ,@body))))))

(define-dw-to-clim-conversion with-character-size
			      ((size &optional (stream nil stream-p) &rest options)
			       &body body)
  :modification-depth 2
  :form
  (multiple-value-bind (options error)
      (verify-clim-options 'with-character-size 'clim::with-text-size nil options
			   '()
			   '(:bind-line-height))
    (unless error
      (case *clim-version*
	(1 `(clim::with-text-size (,(convert-character-size size)
				  ,@(and (or stream-p options) `(,stream))
				  ,@options)
	      ,@body))
	(2 `(clim::with-text-size (,(if stream-p stream t)
				  ,(convert-character-size size)
				  ,@options)
	      ,@body))))))

(define-dw-to-clim-conversion with-character-style
			      ((style &optional (stream nil stream-p) &rest options)
			       &body body)
  :modification-depth 2
  :form
  (multiple-value-bind (options error)
      (verify-clim-options 'with-character-style 'clim::with-text-style nil options
			   '()
			   '(:bind-line-height))
    (unless error
      (case *clim-version*
	(1 `(clim::with-text-style (,(convert-character-style style)
				   ,@(and (or stream-p options) `(,stream))
				   ,@options)
	      ,@body))
	(2 `(clim::with-text-style (,(if stream-p stream t)
				   ,(convert-character-style style)
				   ,@options)
	      ,@body))))))


;;; Presentation types, ACCEPT and PRESENT

;; Converting this presentation type specifier as if it was a form will work
(define-dw-to-clim-conversion dw:alist-member (&key alist)
  (when alist
    `(clim::member-alist ,alist)))

;;--- Maybe the way this handles things it can't convert is wrong
;;--- The code this produces will not always compile cleanly, but it's a start
(define-dw-to-clim-conversion dw:define-presentation-type (name arglist &rest args)
  :modification-depth 1000	;the right number is more like 5
  :documentation-level 2
  :form
  (let ((parameters (car arglist))
	(options (cdr arglist))
	(abbreviation nil)
	(clauses nil)
	(methods nil))
    ;; The next form is only to allow converting old CLIM to new CLIM
    (when (and (symbolp parameters) (not (null parameters)))
      (setq parameters arglist options nil))
    (when options
      (if (eq (first options) '&key)
	  (pop options)
	  (error "Options (called presentation-arguments in DW) must start with &KEY, not ~S"
		 (first options))))
    (labels ((presentation-method-keywords (name cruft allowed-keywords)
	       (declare (values type-var arglist-keywords))
	       ;; It is not a bug that this changes :ORIGINAL-TYPE to TYPE.  DW massages
	       ;; the :TYPE argument, but CLIM does not massage the TYPE argument.
	       (when (eq (first cruft) '&rest) (setq cruft (cddr cruft)))
	       (when (eq (first cruft) '&key) (pop cruft))
	       (let* ((type-var 'type)
		      (arglist-keywords
			(loop for item in cruft
			      as key = (clim-utils:parameter-specifier-keyword item)
			      if (member key allowed-keywords)
				collect item
			      else if (eq key :original-type)
				     do (setq type-var item)
			      else do (warn "~S is not one of the keywords allowed in ~
					     presentation methods for ~S."
					    key name))))
		 (values type-var `(&key ,@arglist-keywords))))
	     (presentation-method-arguments (name cruft keyword)
	       (declare (values type-var other-var))
	       (when (eq (first cruft) '&rest) (setq cruft (cddr cruft)))
	       (when (eq (first cruft) '&key) (pop cruft))
	       (let ((type-var 'type)
		     (other-var (intern (string keyword))))
		 (loop for item in cruft
		       as key = (clim-utils:parameter-specifier-keyword item)
		       do (cond ((eq key :type) (setq type-var item))
				((eq key keyword) (setq other-var item))
				(t (warn "~S is not one of the keywords allowed in ~
					  presentation methods for ~S."
					 key name))))
		 (values type-var other-var))))
      (loop for (key val) on args by #'cddr do
	(case key		;This gives up for the ones that are too hard to convert
	  (:abbreviation-for (setq abbreviation val))
	  (:expander (setq clauses `(,@clauses :inherit-from ,val)))
	  (:description (setq clauses `(,@clauses :description ,val)))
	  (:history (setq clauses `(,@clauses :history ,val)))
	  ((:no-deftype :viewspec-choices 		  ;I think we can ignore these
	    :disallow-atomic-type :data-arguments-are-disjoint))
	  (:parser
	    (destructuring-bind ((stream . cruft) . body) val
	      (multiple-value-bind (type arglist-keywords)
		  (presentation-method-keywords 'clim::accept cruft '(:default :default-type))
		(push `(clim::define-presentation-method clim::accept
							((,type ,name) ,stream
							 (,(intern "VIEW") clim::textual-view)
							 ,@arglist-keywords)
			 ,@body)
		      methods))))
	  (:printer
	    (destructuring-bind ((object stream . cruft) . body) val
	      (multiple-value-bind (type arglist-keywords)
		  (presentation-method-keywords 'clim::present cruft
						'(:acceptably :for-context-type))
		(push `(clim::define-presentation-method clim::present
							(,object (,type ,name) ,stream
							 (,(intern "VIEW") clim::textual-view)
							 ,@arglist-keywords)
			 ,@body)
		      methods))))
	  (:describer
	    (destructuring-bind ((stream . cruft) . body) val
	      (multiple-value-bind (type plural-count)
		  (presentation-method-arguments 'clim::describe-presentation-type
						 cruft ':plural-count)
		(push `(clim::define-presentation-method clim::describe-presentation-type
							((,type ,name) ,stream ,plural-count)
			 ,@body)
		      methods))))
	  ((:presentation-subtypep :data-args-comparator)	;d-a-c for old to new CLIM
						;--- :DATA-ARGS-COMPARATOR may get wrong args?
	    (destructuring-bind ((subtype supertype) . body) val
	      (push `(clim::define-presentation-method clim::presentation-subtypep
						      ((,subtype ,name) ,supertype)
		       ,@body)
		    methods)))
	  ((:typep :object-validator)	;:OBJECT-VALIDATOR is for old to new CLIM
	    (destructuring-bind ((object) . body) val
	      (push `(clim::define-presentation-method clim::presentation-typep
						      (,object (type ,name))
		       ,@body)
		    methods)))
	  ;;--- :HIGHLIGHTING-BOX-FUNCTION can't be converted automatically because
	  ;;--- the arguments to CLIM::HIGHLIGHT-PRESENTATION methods are too incompatible
	  (otherwise
	    (warn "Unable to convert ~S option to DW:DEFINE-PRESENTATION-TYPE" key))))
      (cond (abbreviation
	     (when (or clauses methods)
	       (warn "Invalid combination of :ABBREVIATION-FOR with other options"))
	     `(clim::define-presentation-type-abbreviation ,name ,parameters
		,abbreviation
		,@(when options `(:options ,options))))
	    (t
	     (let ((def `(clim::define-presentation-type ,name ,parameters
			   ,@(when options `(:options ,options))
			   ,@clauses)))
	       (if methods
		   `(progn ,def ,@(nreverse methods))
		   def)))))))

(define-dw-to-clim-conversion dw:accept (type &rest options)
  `(clim::accept ,type ,@(convert-accept-options options)))

;; These DW options do not exist in CLIM::ACCEPT:
;;   :ORIGINAL-TYPE :PRESENT-DEFAULT :INITIALLY-DISPLAY-POSSIBILITIES
;;   :PROMPTS-IN-LINE :INPUT-SENSITIZER :HANDLER-TYPE :INHERIT-CONTEXT
;;   :CHANGED-VALUE-OVERRIDES-DEFAULT :NEWLINE-AFTER-QUERY :QUERY-ENTRY-MODE
;;   :SEPARATE-INFERIOR-QUERIES :CONFIRM :ENSURE-OBJECT
;; These were renamed to eschew abbreviation:
;;   :ACTIVATION-CHARS :ADDITIONAL-ACTIVATION-CHARS :BLIP-CHARS :ADDITIONAL-BLIP-CHARS
;; Also the default for :PROMPT is T instead of :ENTER-TYPE
(defun convert-accept-options (options)
  (loop for (key-form val-form) on options by #'cddr append
   (block convert
     (when (constantp key-form)
       (let* ((key (eval key-form))
	      (rename (cdr (assoc key (case *clim-version*
					(1 '((:activation-chars .
					      :activation-characters)
					     (:additional-activation-chars .
					      :additional-activation-characters)
					     (:blip-chars .
					      :blip-characters)
					     (:additional-blip-chars .
					      :additional-blip-characters)))
					(2 '((:activation-chars .
					      :activation-gestures)
					     (:additional-activation-chars .
					      :additional-activation-gestures)
					     (:blip-chars .
					      :delimiter-gestures)
					     (:additional-blip-chars .
					      :additional-delimiter-gestures))))))))
	 (when rename
	   (setq key-form rename))
	 (when (member key
		       '(:original-type :present-default :inherit-context :prompts-in-line))
	   (return-from convert nil))	;These can safely be discarded
	 (when (member key '(:initially-display-possibilities :input-sensitizer
			     :handler-type :changed-value-overrides-default
			     :newline-after-query :query-entry-mode 
			     :separate-inferior-queries :confirm :ensure-object))
	   (warn "CLIM::ACCEPT does not support ~S, the option will be discarded." key)
	   (return-from convert nil))	;These can be discarded but not so safely, so warn
	 (when (and (eq key :prompt)
		    (member val-form '(:enter-type ':enter-type) :test #'equal))
	   (setq val-form t))))
     `(,key-form ,val-form))))

(define-dw-to-clim-conversion accept-from-string (presentation-type string &rest options)
  (let ((accept-options (convert-accept-options (si:rem-keywords options
								 '(:index :start :end))))
	(string-options (loop for (key val) on options by #'cddr
			      when (member key '(:index :start :end))
				append (list key val)))
	(object-var (intern "OBJECT"))
	(type-var (intern "TYPE"))
	(index-var (getf options :index)))
    (unless index-var
      (setf (getf string-options :index) (setq index-var (intern "STRING-INDEX"))))
    (let ((form `(multiple-value-bind (,object-var ,type-var)
		     (with-input-from-string (stream ,string ,@string-options)
		       (clim::accept ,presentation-type :stream stream ,@accept-options))
		   (values ,object-var ,type-var ,index-var))))
      (if (getf options :index)
	  form
	  `(let (,index-var) ,form)))))

(define-dw-to-clim-substitution dw:with-accept-help clim::with-accept-help)

(define-dw-to-clim-conversion dw:present
			      (object &optional (type nil type-supplied-p) &rest options)
  ;; These DW options do not exist in CLIM::PRESENT:
  ;;   :CHECK-TYPE :ALLOW-SENSITIVE-RAW-TEXT :REDISPLAY-PLACE-HOLDER :ORIGINAL-TYPE
  ;; These DW options were replaced by :MODIFIER:
  ;;   :FORM :LOCATION
  `(clim::present ,object ,@(and type-supplied-p `(,type))
     ,@(loop for (key-form val-form) on options by #'cddr append
	(block convert
	  (when (constantp key-form)
	    (let ((key (eval key-form)))
	      (case key
		(:form
		  (setq key-form :modifier
			val-form `#'(lambda (new-value)
				      (setf ,val-form new-value))))
		(:location
		  (setq key-form :modifier
			val-form `#'(lambda (new-value)
				      (setf (location-contents ,val-form) new-value))))
		((:check-type :allow-sensitive-raw-text   ;I think we can safely ignore these
		  :redisplay-place-holder :original-type)
		 (return-from convert nil)))))
	  `(,key-form ,val-form)))))

(define-dw-to-clim-conversion dw:present-to-string
			      (object &optional (type nil type-supplied-p) &rest options)
  ;; These DW options do not exist in CLIM::PRESENT-TO-STRING:
  ;;   :CHECK-TYPE :ORIGINAL-TYPE
  `(clim::present-to-string ,object ,@(and type-supplied-p `(,type))
     ,@(loop for (key-form val-form) on options by #'cddr append
	(block convert
	  (when (constantp key-form)
	    (let ((key (eval key-form)))
	      (case key
		((:check-type :original-type)   ;I think we can safely ignore these
		 (return-from convert nil)))))
	  `(,key-form ,val-form)))))

(define-dw-to-clim-conversion dw:with-output-as-presentation ((&rest options) &body body)
  :modification-depth 2				;because OPTIONS can be removed
  :form
  ;; These DW options do not exist in CLIM::WITH-OUTPUT-AS-PRESENTATION:
  ;;   :CHECK-TYPE :ALLOW-SENSITIVE-RAW-TEXT :REDISPLAY-PLACE-HOLDER
  ;; These DW options were replaced by :MODIFIER:
  ;;   :FORM :LOCATION
  (let ((stream nil)
	(object nil)
	(type nil)
	(new-options nil))
    (loop for (key-form val-form) on options by #'cddr doing
      (block convert
	(when (constantp key-form)
	  (let ((key (eval key-form)))
	    (case key
	      (:form
		(setq key-form :modifier
		      val-form `#'(lambda (new-value)
				    (setf ,val-form new-value))))
	      (:location
		(setq key-form :modifier
		      val-form `#'(lambda (new-value)
				    (setf (location-contents ,val-form) new-value))))
	      (:type
		(when (and (consp val-form)
			   (eq (first val-form) 'type-of))
		  (setq val-form (cons 'clos:class-of (rest val-form)))))
	      ((:check-type :allow-sensitive-raw-text	;We can safely ignore these
		:redisplay-place-holder)
	       (return-from convert nil)))))
	(case key-form
	  (:stream (setq stream val-form))
	  (:object (setq object val-form))
	  (:type   (setq type   val-form))
	  (otherwise (setq new-options (append new-options `(,key-form ,val-form)))))))
    (case *clim-version*
      (1 `(clim::with-output-as-presentation (:stream ,stream
					     :object ,object
					     :type ,type
					     ,@new-options)
	    ,@body))
      (2 `(clim::with-output-as-presentation (,stream ,object ,type
					     ,@new-options)
	    ,@body)))))

;; This doesn't handle the general case where TYPE-OR-ARGS can't be figured out
;; at compile time.  Just leave it unconverted and let the user write PROMPT-AND-ACCEPT
(define-dw-to-clim-conversion dw:prompt-and-accept (type-or-args &rest format-junk)
  (let ((prompt (and format-junk `(:prompt (format nil ,@format-junk)))))
    (cond ((constantp type-or-args)
	   (setq type-or-args (eval type-or-args))
	   (if (or (atom type-or-args) (not (keywordp (first type-or-args))))
	       `(clim::accept ',type-or-args ,@prompt)
	       (accept-dw-to-clim-converter
		 `(dw:accept ',(getf type-or-args :type) ,@prompt
			     ,@(si:rem-keywords type-or-args '(:type))))))
	  ((and (consp type-or-args)
		(eq (first type-or-args) 'si:xr-bq-list)
		(keywordp (second type-or-args))
		(getf (cdr type-or-args) :type))
	   (accept-dw-to-clim-converter
	     `(dw:accept ,(getf (cdr type-or-args) :type) ,@prompt
			 ,@(si:rem-keywords (cdr type-or-args) '(:type)))))
	  ((and (consp type-or-args)
		(eq (first type-or-args) 'si:xr-bq-list*)
		(constantp (car (last type-or-args))))
	   (prompt-and-accept-dw-to-clim-converter
	     `(dw:prompt-and-accept (si:xr-bq-list ,@(butlast (cdr type-or-args))
						   ,@(mapcar #'(lambda (item)
								 (if (keywordp item) item
								     `',item))
							     (eval (car (last type-or-args)))
							     ))))))))

(define-dw-to-clim-conversion with-input-editing ((stream keyword) &body body)
  (progn
    keyword
    `(clim::with-input-editing (,stream) ,@body)))

; WITH-INPUT-EDITING-OPTIONS
; WITH-INPUT-EDITING-OPTIONS-IF


;;; Transformations

(define-dw-to-clim-substitution graphics:2pi clim-utils:2pi)

(define-dw-to-clim-substitution graphics:*identity-transform* clim::+identity-transformation+)

(define-dw-to-clim-substitution graphics:compose-transforms clim::compose-transformations)
(define-dw-to-clim-substitution graphics:invert-transform clim::invert-transformation)

(define-dw-to-clim-conversion graphics:make-identity-transform
			      ()
  `clim::+identity-transformation+)

(define-dw-to-clim-conversion graphics:make-graphics-transform
			      (&key r11 r12 r21 r22 tx ty)
  `(clim::make-transformation ,r11 ,r12 ,r21 ,r22 ,tx ,ty))

(define-dw-to-clim-conversion graphics:transform-point
			      (x y transform)
  (case *clim-version*
    (1 `(clim::transform-point* ,transform ,x ,y))
    (2 `(clim::transform-position ,transform ,x ,y))))

(define-dw-to-clim-conversion graphics:transform-distance
			      (x y transform)
  `(clim::transform-distance ,transform ,x ,y))

(define-dw-to-clim-conversion graphics:untransform-point
			      (x y transform)
  (case *clim-version*
    (1 `(clim::untransform-point* ,transform ,x ,y))
    (2 `(clim::untransform-position ,transform ,x ,y))))

(define-dw-to-clim-conversion graphics:untransform-distance
			      (x y transform)
  `(clim::untransform-distance ,transform ,x ,y))

(define-dw-to-clim-substitution graphics:stream-transform clim::medium-transformation)

(define-dw-to-clim-conversion graphics:stream-transform-point
			      (x y stream)
  (case *clim-version*
    (1 `(clim::transform-point* (clim::medium-transformation ,stream) ,x ,y))
    (2 `(clim::transform-position (clim::medium-transformation ,stream) ,x ,y))))

(define-dw-to-clim-conversion graphics:stream-untransform-point
			      (x y stream)
  (case *clim-version*
    (1 `(clim::untransform-point* (clim::medium-transformation ,stream) ,x ,y))
    (2 `(clim::untransform-position (clim::medium-transformation ,stream) ,x ,y))))

(define-dw-to-clim-conversion graphics:with-graphics-identity-transform
			      ((stream) &body body)
  `(clim::with-drawing-options (,stream :transformation clim::+identity-transformation+)
     ,@body))

(define-dw-to-clim-conversion graphics:with-graphics-transform
			      ((stream transform) &body body)
  :modification-depth 2
  :form
  `(clim::with-drawing-options (,stream :transformation ,transform)
     ,@body))

(define-dw-to-clim-substitution graphics:with-graphics-translation clim::with-translation)
(define-dw-to-clim-substitution graphics:with-graphics-rotation clim::with-rotation)
(define-dw-to-clim-substitution graphics:with-graphics-scale clim::with-scaling)

(define-dw-to-clim-conversion graphics:graphics-transform
			      (transform &key (stream `*standard-output*))
  :modification-depth 2
  :form
  (let ((setf (intern "SETF")))
    `(,setf (clim::medium-transformation ,stream)
	    (clim::compose-transformations (clim::medium-transformation ,stream) ,transform))))

(define-dw-to-clim-conversion graphics:graphics-translate
			      (dx dy &key (stream `*standard-output*))
  :modification-depth 2
  :form
  (let ((setf (intern "SETF")))
    (case *clim-version*
      (1 `(,setf (clim::medium-transformation ,stream)
		 (clim::compose-translation-transformation
		   (clim::medium-transformation ,stream) ,dx ,dy)))
      (2 `(,setf (clim::medium-transformation ,stream)
		 (clim::compose-translation-with-transformation
		   (clim::medium-transformation ,stream) ,dx ,dy))))))


(define-dw-to-clim-conversion graphics:graphics-rotate
			      (angle &key (stream `*standard-output*))
  :modification-depth 2
  :form
  (let ((setf (intern "SETF")))
    (case *clim-version*
      (1 `(,setf (clim::medium-transformation ,stream)
		 (clim::compose-rotation-transformation
		   (clim::medium-transformation ,stream) ,angle)))
      (2 `(,setf (clim::medium-transformation ,stream)
		 (clim::compose-rotation-with-transformation
		   (clim::medium-transformation ,stream) ,angle))))))

(define-dw-to-clim-conversion graphics:graphics-scale
			      (x-scale y-scale &key (stream `*standard-output*))
  :modification-depth 2
  :form
  (let ((setf (intern "SETF")))
    (case *clim-version*
      (1 `(,setf (clim::medium-transformation ,stream)
		 (clim::compose-scaling-transformation
		   (clim::medium-transformation ,stream) ,x-scale ,y-scale)))
      (2 `(,setf (clim::medium-transformation ,stream)
		 (clim::compose-scaling-with-transformation
		   (clim::medium-transformation ,stream) ,x-scale ,y-scale))))))


;;; Drawing functions

(define-dw-to-clim-conversion color:make-color
			      (&key red green blue intensity hue saturation)
  (case *clim-version*
    (1 (if (or red green blue)
	   `(clim::make-color-rgb ,red ,green ,blue)
	   `(clim::make-color-ihs ,intensity ,hue ,saturation)))
    (2 (if (or red green blue)
	   `(clim::make-rgb-color ,red ,green ,blue)
	   `(clim::make-ihs-color ,intensity ,hue ,saturation)))))

(define-dw-to-clim-conversion graphics:make-contrasting-pattern
			      (index n-indices)
  `(clim::make-contrasting-inks ,n-indices ,index))

(defvar *dw-color-to-clim-color*
	'((:black   clim::+black+)
	  (:white   clim::+white+)
	  (:red	    clim::+red+)
	  (:green   clim::+green+)
	  (:blue    clim::+blue+)
	  (:cyan    clim::+cyan+)
	  (:yellow  clim::+yellow+)
	  (:magenta clim::+magenta+)))

(defvar *dw-stipple-to-clim-pattern*
	`((stipples:5.5%-gray 0.055)
	  (stipples:6%-gray   0.06)
	  (stipples:7%-gray   0.07)
	  (stipples:8%-gray   0.08)
	  (stipples:9%-gray   0.09)
	  (stipples:10%-gray  0.10)
	  (stipples:12%-gray  0.12)
	  (stipples:25%-gray  0.25)
	  (stipples:33%-gray  0.33)
	  (stipples:50%-gray  0.50)
	  (stipples:75%-gray  0.75)))

(defun process-standard-graphics-options (options)
  (let ((unprocessed-options nil))
    (flet ((unprocessed-option (key val)
	     (setq unprocessed-options
		   (append unprocessed-options (list key val)))))
      (loop with stream
	    with transform and translation and rotation and scale-x and scale-y
	    for (key val) on options by #'cddr
	    append
	      (block convert
		(if (not (constantp key))
		    (unprocessed-option key val)
		  (case key
		    (:stream
		     (setq stream val)
		     (return-from convert nil))
		    (:alu
		     (case val
		       (:draw  (case *clim-version*
				 (1 (setq key :ink val 'clim::+foreground+))
				 (2 (setq key :ink val 'clim::+foreground-ink+))))
		       (:erase (case *clim-version*
				 (1 (setq key :ink val 'clim::+background+))
				 (2 (setq key :ink val 'clim::+background-ink+))))
		       (:flip  (setq key :ink val 'clim::+flipping-ink+))
		       (otherwise
			 (unprocessed-option key val)
			 (return-from convert nil))))
		    (:color
		     (let (clim-color
			   (e-val (and (constantp val)
				       (eval val))))
		       (cond ((setq clim-color
				    (second (assoc e-val *dw-color-to-clim-color*)))
			      (setq key :ink val clim-color))
			     ((and (listp e-val)
				   (= (length e-val) 3))
			      (setq key :ink 
				    val (case *clim-version*
					  (1 `(clim::make-color-rgb ,@e-val))
					  (2 `(clim::make-rgb-color ,@e-val)))))
			     (t
			      (unprocessed-option key val)
			      (return-from convert nil)))))
		    (:gray-level
		     (setq key :ink val `(clim::make-gray-color ,val)))
		    (:stipple
		     (let ((luminance (second (assoc val *dw-stipple-to-clim-pattern*))))
		       (cond (luminance
			      (setq key :ink
				    val `(clim::make-gray-color ,luminance)))
			     (t
			      (unprocessed-option key val)
			      (return-from convert nil)))))
;--- Most of these can be converted by combining them into the :INK argument
;--- but it's just too much trouble to be worth doing automatically
;		    (:OPAQUE
;		      ---)
;		    ((:PATTERN :TILE)
;		     ---)
;		    ((:MASK :MASK-X :MASK-Y)
;		     ---)
		    (:transform
		     (setq transform val)
		     (return-from convert nil))
		    (:translation
		     (setq translation val)
		     (return-from convert nil))
		    (:rotation
		     (setq rotation val)
		     (return-from convert nil))
		    (:scale
		     (setq scale-x val scale-y val)
		     (return-from convert nil))
		    (:scale-x
		     (setq scale-x val)
		     (return-from convert nil))
		    (:scale-y
		     (setq scale-y val)
		     (return-from convert nil))
		    (otherwise
		     ;; Catches :RETURN-PRESENTATION and others I might not know about
		     (unprocessed-option key val)
		     (return-from convert nil)))
		  (list key val))) into standard-options
	    finally (when (or transform translation rotation scale-x scale-y)
		      ;; Close your eyes, this is pretty tasteless
		      ;;--- Who knows if the order of composition is right...
		      (when translation
			(let ((dx (if (constantp translation) `',(first (eval translation))
				      `(first ,translation)))
			      (dy (if (constantp translation) `',(second (eval translation))
				      `(second ,translation))))
			  (if (null transform)
			      (setq transform `(clim::make-translation-transformation ,dx ,dy))
			    (setq transform `(clim::compose-translation-transformation
					       ,transform ,dx ,dy)))))
		      (when rotation
			(if (null transform)
			    (setq transform `(clim::make-rotation-transformation
					       ,rotation))
			  (setq transform `(clim::compose-rotation-transformation
					     ,transform ,rotation))))
		      (when (or scale-x scale-y)
			(if (null transform)
			    (setq transform `(clim::make-scaling-transformation
					       ,scale-x ,scale-y))
			  (setq transform `(clim::compose-scaling-transformation
					     ,transform ,scale-x ,scale-y))))
		      (setq standard-options
			    (append standard-options `(:transformation ,transform))))
		    (return (values (or stream 't)
				    standard-options
				    unprocessed-options))))))

(defun process-graphics-path-options (options)
  (let ((unprocessed-options nil))
    (flet ((unprocessed-option (key val)
	     (setq unprocessed-options
		   (append unprocessed-options (list key val)))))
      (loop with dashes = 'unseen
	    for (key val) on options by #'cddr
	    append
	      (block convert
		(if (not (constantp key))
		    (unprocessed-option key val)
		  (case key
		    (:filled
		      (return-from convert nil))
		    (:thickness
		      (setq key :line-thickness))
		    (:dashed
		      (setq dashes val)
		      (return-from convert nil))
		    (:dash-pattern
		      (setq dashes val)
		      (return-from convert nil))
		    (:initial-dash-phase
		      ;;--- Maybe CLIM will support this someday
		      (unprocessed-option key val)
		      (return-from convert nil))
		    (:line-end-shape 
		      (setq key :line-cap-shape))
		    (:line-joint-shape
		      (setq key :line-joint-shape))
		    (otherwise
		      ;;--- Catches :SCALE-THICKNESS, :SCALE-DASHES, :DRAW-PARTIAL-DASHES,
		      ;;--- :JOIN-TO-PATH, and others I might not know about
		      (unprocessed-option key val)
		      (return-from convert nil)))
		  (list key val))) into shape-options
	    finally (return (values (if (eq dashes 'unseen)
					shape-options
				        (append shape-options `(:dashes ,dashes)))
				    unprocessed-options))))))

(defun process-graphics-area-options (options)
  (let ((unprocessed-options nil))
    (flet ((unprocessed-option (key val)
	     (setq unprocessed-options
		   (append unprocessed-options (list key val)))))
      (loop for (key val) on options by #'cddr
	    append
	      (block convert
		(if (not (constantp key))
		    (unprocessed-option key val)
		  (case key
		    (:filled
		      (return-from convert nil))
		    (otherwise
		      ;; Catches things I might not know about
		      (unprocessed-option key val)
		      (return-from convert nil)))
		  (list key val))) into shape-options
	    finally (return (values shape-options
				    unprocessed-options))))))

(defun process-graphics-text-options (options)
  (let ((unprocessed-options nil))
    (flet ((unprocessed-option (key val)
	     (setq unprocessed-options
		   (append unprocessed-options (list key val)))))
      (loop for (key val) on options by #'cddr
	    append
	      (block convert
		(if (not (constantp key))
		    (unprocessed-option key val)
		  (case key
		    (:attachment-x (setq key :align-x))
		    (:attachment-y (setq key :align-y))
		    (:toward-x (case *clim-version*
				 (1 nil)
				 (2 (setq key :towards-x))))
		    (:toward-y (case *clim-version*
				 (1 nil)
				 (2 (setq key :towards-y))))
		    (:character-style
		      (setq key :text-style val (convert-character-style val)))
		    (otherwise
		      ;; Catches things I might not know about
		      (unprocessed-option key val)
		      (return-from convert nil)))
		  (list key val))) into text-options
	    finally (return (values text-options
				    unprocessed-options))))))

(define-dw-to-clim-conversion graphics:draw-point
			      (x y &rest options)
  (multiple-value-bind (stream standard-options unprocessed-options)
      (process-standard-graphics-options options)
    `(clim::draw-point* ,stream ,x ,y
		       ,@standard-options
		       ,@(and unprocessed-options
			      `(:unprocessed-graphics-options ,unprocessed-options)))))

(define-dw-to-clim-conversion graphics:draw-line
			      (start-x start-y end-x end-y &rest options)
  (multiple-value-bind (stream standard-options unprocessed-options)
      (process-standard-graphics-options options)
    (multiple-value-bind (shape-options unprocessed-options)
	(process-graphics-path-options unprocessed-options)
      `(clim::draw-line* ,stream ,start-x ,start-y ,end-x ,end-y
			,@standard-options
			,@shape-options
			,@(and unprocessed-options
			       `(:unprocessed-graphics-options ,unprocessed-options))))))

(define-dw-to-clim-conversion graphics:draw-arrow
			      (start-x start-y end-x end-y &rest options
			       &key (from-head nil fh-p) (to-head t th-p)
				    (head-length 10 hl-p) (head-width 5 hw-p))
  (multiple-value-bind (stream standard-options unprocessed-options)
      (process-standard-graphics-options options)
    (multiple-value-bind (shape-options unprocessed-options)
	(process-graphics-path-options unprocessed-options)
      (setq unprocessed-options
	    (si:rem-keywords unprocessed-options
			     '(:from-head :to-head :head-length :head-width)))
      `(clim::draw-arrow* ,stream ,start-x ,start-y ,end-x ,end-y
			 ,@standard-options
			 ,@shape-options
			 ,@(and fh-p `(:from-head ,from-head))
			 ,@(and th-p `(:to-head ,to-head))
			 ,@(and hl-p `(:head-length ,head-length))
			 ,@(and hw-p `(:head-width ,head-width))
			 ,@(and unprocessed-options
				`(:unprocessed-graphics-options ,unprocessed-options))))))

(define-dw-to-clim-conversion graphics:draw-rectangle
			      (left top right bottom &rest options
			       &key (filled t filled-p)
			       &allow-other-keys)
  (multiple-value-bind (stream standard-options unprocessed-options)
      (process-standard-graphics-options options)
    (multiple-value-bind (shape-options unprocessed-options)
	(if filled
	    (process-graphics-area-options unprocessed-options)
	    (process-graphics-path-options unprocessed-options))
      (setq unprocessed-options
	    (si:rem-keywords unprocessed-options '(:filled)))
      `(clim::draw-rectangle* ,stream ,left ,top ,right ,bottom
			     ,@(and filled-p `(:filled ,filled))
			     ,@standard-options
			     ,@shape-options
			     ,@(and unprocessed-options
				    `(:unprocessed-graphics-options ,unprocessed-options))))))

(define-dw-to-clim-conversion graphics:draw-polygon
			      (points &rest options
			       &key (filled t filled-p) (points-are-convex-p nil)
			       &allow-other-keys)
  (multiple-value-bind (stream standard-options unprocessed-options)
      (process-standard-graphics-options options)
    (multiple-value-bind (shape-options unprocessed-options)
	(if filled
	    (process-graphics-area-options unprocessed-options)
	    (process-graphics-path-options unprocessed-options))
      ;;--- What about :POINTS-ARE-CONVEX-P?
      (setq unprocessed-options
	    (si:rem-keywords unprocessed-options '(:filled)))
      `(clim::draw-polygon* ,stream ,points
			   ,@(and filled-p `(:filled ,filled))
			   ,@standard-options
			   ,@shape-options
			   ,@(and unprocessed-options
				  `(:unprocessed-graphics-options ,unprocessed-options))))))

(define-dw-to-clim-conversion graphics:draw-triangle
			      (x1 y1 x2 y2 x3 y3 &rest options
			       &key (filled t filled-p)
			       &allow-other-keys)
  (multiple-value-bind (stream standard-options unprocessed-options)
      (process-standard-graphics-options options)
    (multiple-value-bind (shape-options unprocessed-options)
	(if filled
	    (process-graphics-area-options unprocessed-options)
	    (process-graphics-path-options unprocessed-options))
      (setq unprocessed-options
	    (si:rem-keywords unprocessed-options '(:filled)))
      `(clim::draw-triangle* ,stream ,x1 ,y1 ,x2 ,y2 ,x3 ,y3
			    ,@(and filled-p `(:filled ,filled))
			    ,@standard-options
			    ,@shape-options
			    ,@(and unprocessed-options
				   `(:unprocessed-graphics-options ,unprocessed-options))))))

(define-dw-to-clim-conversion graphics:draw-regular-polygon
			      (start-x start-y end-x end-y nsides
			       &rest options
			       &key (filled t filled-p) (handedness :left handedness-p)
			       &allow-other-keys)
  (multiple-value-bind (stream standard-options unprocessed-options)
      (process-standard-graphics-options options)
    (multiple-value-bind (shape-options unprocessed-options)
	(if filled
	    (process-graphics-area-options unprocessed-options)
	    (process-graphics-path-options unprocessed-options))
      (setq unprocessed-options
	    (si:rem-keywords unprocessed-options '(:filled :handedness)))
      `(clim::draw-regular-polygon* ,stream ,start-x ,start-y ,end-x ,end-y ,nsides
				   ,@(and filled-p `(:filled ,filled))
				   ,@(and handedness-p `(:handedness ,handedness))
				   ,@standard-options
				   ,@shape-options
				   ,@(and unprocessed-options
					  `(:unprocessed-graphics-options ,unprocessed-options))))))

(define-dw-to-clim-conversion graphics:draw-ellipse
			      (center-x center-y x-radius y-radius &rest options
			       &key (filled t filled-p) 
				    (inner-x-radius 0) (inner-y-radius 0)
				    (clockwise nil cw-p)
				    (start-angle 0 start-angle-p)
				    (end-angle graphics:2pi end-angle-p)
			       &allow-other-keys)
  (multiple-value-bind (stream standard-options unprocessed-options)
      (process-standard-graphics-options options)
    (multiple-value-bind (shape-options unprocessed-options)
	(if filled
	    (process-graphics-area-options unprocessed-options)
	    (process-graphics-path-options unprocessed-options))
      (when (and cw-p (constantp clockwise))
	(when (eval clockwise)
	  (rotatef start-angle end-angle))
	(setq unprocessed-options
	      (si:rem-keywords unprocessed-options '(:clockwise))))
      ;;--- What about :INNER-X-RADIUS and :INNER-Y-RADIUS?
      (setq unprocessed-options
	    (si:rem-keywords unprocessed-options '(:filled :start-angle :end-angle)))
      `(clim::draw-ellipse* ,stream ,center-x ,center-y
			   ,x-radius 0 0 ,y-radius
			   ,@(and filled-p `(:filled ,filled))
			   ,@standard-options
			   ,@shape-options
			   ,@(and start-angle-p `(:start-angle ,start-angle))
			   ,@(and end-angle-p `(:end-angle ,end-angle))
			   ,@(and unprocessed-options
				  `(:unprocessed-graphics-options ,unprocessed-options))))))

(define-dw-to-clim-conversion graphics:draw-circle
			      (center-x center-y radius &rest options
			       &key (filled t filled-p) (inner-radius 0)
				    (clockwise nil cw-p)
				    (start-angle 0 start-angle-p)
				    (end-angle graphics:2pi end-angle-p)
			       &allow-other-keys)
  (multiple-value-bind (stream standard-options unprocessed-options)
      (process-standard-graphics-options options)
    (multiple-value-bind (shape-options unprocessed-options)
	(if filled
	    (process-graphics-area-options unprocessed-options)
	    (process-graphics-path-options unprocessed-options))
      (when (and cw-p (constantp clockwise))
	(when (eval clockwise)
	  (rotatef start-angle end-angle))
	(setq unprocessed-options
	      (si:rem-keywords unprocessed-options '(:clockwise))))
      ;;--- What about :INNER-RADIUS?
      (setq unprocessed-options
	    (si:rem-keywords unprocessed-options '(:filled :start-angle :end-angle)))
      `(clim::draw-circle* ,stream ,center-x ,center-y ,radius
			  ,@(and filled-p `(:filled ,filled))
			  ,@standard-options
			  ,@shape-options
			  ,@(and start-angle-p `(:start-angle ,start-angle))
			  ,@(and end-angle-p `(:end-angle ,end-angle))
			  ,@(and unprocessed-options
				 `(:unprocessed-graphics-options ,unprocessed-options))))))

(define-dw-to-clim-conversion graphics:draw-oval
			      (center-x center-y x-radius y-radius &rest options
			       &key (filled t filled-p))
  (multiple-value-bind (stream standard-options unprocessed-options)
      (process-standard-graphics-options options)
    (multiple-value-bind (shape-options unprocessed-options)
	(if filled
	    (process-graphics-area-options unprocessed-options)
	    (process-graphics-path-options unprocessed-options))
      (setq unprocessed-options
	    (si:rem-keywords unprocessed-options '(:filled)))
      `(clim::draw-oval* ,stream ,center-x ,center-y ,x-radius ,y-radius
			,@(and filled-p `(:filled ,filled))
			,@standard-options
			,@shape-options
			,@(and unprocessed-options
			       `(:unprocessed-graphics-options ,unprocessed-options))))))

(define-dw-to-clim-conversion graphics:draw-string (string x y &rest options)
  (multiple-value-bind (stream standard-options unprocessed-options)
      (process-standard-graphics-options options)
    (multiple-value-bind (text-options unprocessed-options)
	(process-graphics-text-options unprocessed-options)
      `(clim::draw-text* ,stream ,string ,x ,y ,@standard-options ,@text-options
			,@(and unprocessed-options
			       `(:unprocessed-graphics-options ,unprocessed-options))))))

(define-dw-to-clim-conversion dw:erase-displayed-presentation
			      (displayed-presentation
			       &key (window '*standard-output*)
				    recursive as-single-box (clear-inferiors t))
  (progn
    recursive as-single-box clear-inferiors
    `(clim::erase-output-record ,displayed-presentation ,window)))

(define-dw-to-clim-conversion graphics:erase-graphics-presentation
			      (presentation
			       &key (stream '*standard-output*)
				    (redisplay-overlapping-presentations t))
  (progn
    redisplay-overlapping-presentations
    `(clim::erase-output-record ,presentation ,stream)))

(define-dw-to-clim-conversion dw:redraw-displayed-presentation (presentation window box)
  ;;--- I think BOX is a replay region...
  `(clim::replay ,presentation ,window ,box))

;--- These are called, are there any CLIM equivalents?
;  GRAPHICS:DRAW-IMAGE
;  GRAPHICS:DRAW-GLYPH
;  GRAPHICS:DRAW-STRING-IMAGE
;  GRAPHICS:WITH-OUTPUT-AS-GRAPHICS-PRESENTATION


;;; Simplest box arithmetic

(define-dw-to-clim-substitution dw:box-edges  clim::bounding-rectangle*)
(define-dw-to-clim-substitution dw:box-left   clim::bounding-rectangle-left)
(define-dw-to-clim-substitution dw:box-top    clim::bounding-rectangle-top)
(define-dw-to-clim-substitution dw:box-right  clim::bounding-rectangle-right)
(define-dw-to-clim-substitution dw:box-bottom clim::bounding-rectangle-bottom)

(define-dw-to-clim-substitution dw:box-size    clim::bounding-rectangle-size)
(define-dw-to-clim-substitution dw::box-width  clim::bounding-rectangle-width)
(define-dw-to-clim-substitution dw::box-height clim::bounding-rectangle-height)

(define-dw-to-clim-conversion dw::box-position (box)
  (case *clim-version*
    (1 `(clim::bounding-rectangle-position* ,box))
    (2 `(clim::bounding-rectangle-position ,box))))

(define-dw-to-clim-conversion dw::box-center-x (box)
  (let ((cx (intern "CX"))
	(cy (intern "CY")))
    `(multiple-value-bind (,cx ,cy) (clim::bounding-rectangle-center* ,box)
       (declare (ignore ,cy))
       ,cx)))

(define-dw-to-clim-conversion dw::box-center-y (box)
  (let ((cx (intern "CX"))
	(cy (intern "CY")))
    `(multiple-value-bind (,cx ,cy) (clim::bounding-rectangle-center* ,box)
       (declare (ignore ,cx))
       ,cy)))


;;; "Higher Level Stuff"

;;--- This doesn't deal with the change in FRESH-LINE rules
(define-dw-to-clim-conversion dw:accepting-values ((&optional (stream '*query-io*)
						    &rest options)
						   &body body)
  :modification-depth 2
  :form
  (multiple-value-bind (options error)
      (verify-clim-options 'dw:accepting-values 'clim::accepting-values t options
			   '(:own-window :label :initially-select-query-identifier
			     :resynchronize-every-pass)
			   '(:display-exit-boxes :temporary-p :near-mode
			     :queries-are-independent
			     :changed-value-overrides-default :query-entry-mode)
			   '())
    (unless error
      `(clim::accepting-values (,stream ,@options) ,@body))))

;  DW:WITH-TYPEOUT-WINDOW-FOR-ACCEPT-VALUES has no equivalent at present

(define-dw-to-clim-conversion dw:accept-values-command-button
			      ((&optional (stream `*standard-output*) &rest options)
			       prompt &body body)
  :modification-depth 2
  :form
  (multiple-value-bind (options error)
      (verify-clim-options 'dw:accept-values-command-button 'clim::accept-values-command-button
			   t options '(:query-identifier :cache-value :cache-test) '()
			   '(:short-prompt :default-p)	;DW ignores these anyway
			   '((:who-line-documentation-string :documentation)))
    (unless error
      `(clim::accept-values-command-button (,stream ,@options) ,prompt ,@body))))

(defun get-command-table-name ()
  (or (getf *conversion-state* 'get-command-table-name)
      (setf (getf *conversion-state* 'get-command-table-name)
	    (let ((*query-io* zwei:*typeout-window*))
	      (zwei:show-interval-in-context (zwei:point) (zwei:forward-sexp (zwei:point)))
	      (accept 'symbol :prompt "Please enter the name of your command table"
		      :provide-default nil)))))

;; DW allows strings but CLIM only allows symbols
(defun convert-command-table-name (form eval)
  (when (and eval (consp form) (eq (first form) 'quote) (stringp (second form)))
    (setq form (second form)))
  (when (stringp form)
    (setq form (intern (string-upcase form)))
    (when eval (setq form `',form)))
  form)

(define-dw-to-clim-conversion dw:define-presentation-translator
			      (name (from-type to-type &rest original-options)
			       arglist &body body)
  :modification-depth 1000
  :form
  (convert-define-presentation-translator 'dw:define-presentation-translator
					  'clim::define-presentation-translator
					  name from-type to-type original-options
					  arglist body '()))

(define-dw-to-clim-conversion dw:define-presentation-action
			      (name (from-type to-type &rest original-options)
			       arglist &body body)
  :modification-depth 1000
  :form
  (convert-define-presentation-translator 'dw:define-presentation-action
					  'clim::define-presentation-action
					  name from-type to-type original-options
					  arglist body '(:defines-menu)))

(define-dw-to-clim-conversion dw:define-presentation-to-command-translator
			      (name (from-type &rest original-options)
			       arglist &body body)
  :modification-depth 1000
  :form
  ;; Have to figure out the command-name and change the value returned by the body
  (let ((form (car (last body)))
	(command-name nil))
    (cond ((atom form))
	  ((and (eq (first form) 'quote) (consp (second form)))
	   (setq command-name `(quote ,(first (second form)))
		 form `(quote ,(rest (second form)))))
	  ((member (first form) '(cons list* si:xr-bq-cons si:xr-bq-list*))
	   (setq command-name (second form)
		 form (if (cdddr form) (cons 'list* (cddr form)) (third form))))
	  ((member (first form) '(list si:xr-bq-list cp:build-command))
	   (setq command-name (second form)
		 form (and (cddr form) (cons 'list (cddr form))))))
    (if (constantp command-name)
	(setq command-name (eval command-name))
	(warn "Command-name ~S is not a constant, it will be left as-is but won't work."
	      command-name))
    (if command-name
	(convert-define-presentation-translator 'dw:define-presentation-to-command-translator
						'clim::define-presentation-to-command-translator
						name from-type command-name original-options
						arglist `(,@(butlast body) ,form) '())
	(warn "Unable to find what the ~S body ~{~S ~} uses for a command-name."
	      'dw:define-presentation-to-command-translator body))))

(defun convert-define-presentation-translator (dw-fun clim-fun name from-type to-type
					       original-options arglist body
					       additional-dw-options)
  (multiple-value-bind (options error)
      (verify-clim-options dw-fun clim-fun nil original-options
			   '(:tester :gesture :documentation :menu :priority)
			   `(:context-independent :exclude-other-handlers
			     :suppress-highlighting ,@additional-dw-options)
			   '(:blank-area))	;I think it's safe to ignore :BLANK-AREA
    (unless error
      (setq options (copy-list options))
      (when (getf original-options :blank-area)
	(setq from-type 'clim::blank-area))
      (let ((hints nil))
	(labels ((fix-arglist (arglist-and-forms &optional additional-arguments)
		   ;; DW arglist: (object &key presentation presentation-type input-context
		   ;;                          gesture mouse-char window x y handler)
		   ;; CLIM arglist: no lambda-list keywords, object must be named OBJECT,
		   ;;  args are (object presentation context-type frame event window x y) 
		   (let ((arglist (car arglist-and-forms))
			 (forms (cdr arglist-and-forms)))
		     (labels ((rename (old new)
				(setq forms (subst new old forms)))
			      (symbol (name)
				(intern (string name))))
		       (unless (null arglist)
			 (setq arglist (delete '&key (copy-list arglist)))
			 (rename (first arglist) (setf (first arglist) (symbol 'object)))
			 (when (member 'gesture arglist :test #'string=)
			   (let ((gesture (symbol 'gesture))
				 (event (symbol 'event)))
			     (setq arglist (subst event gesture arglist))
			     (rename gesture event)))
			 (dolist (item (cdr arglist))
			   (unless (and (symbolp item)
					(or (member item '(presentation event window x y)
						    :test #'string=)
					    (member item additional-arguments :test #'string=)))
			     (warn "~S is not recognized as an argument in ~S.~@
				  It will be left in the arglist but will not work.
				  Valid arguments are ~{~A~^, ~}."
				   item clim-fun (append additional-arguments
							 '(presentation event window x y
							   ;; These exist in CLIM but not DW
							   context-type frame))))))
		       (unless (eq arglist (car arglist-and-forms))
			 (push (list arglist (car arglist-and-forms)) hints))
		       (unless (eq forms (cdr arglist-and-forms))
			 (push (list forms (cdr arglist-and-forms)) hints)
			 (loop for new in forms and old in (cdr arglist-and-forms) do
			   (unless (eq new old)
			     (push (list new old) hints))))
		       (cons arglist forms))))
		 (fix-function (name &optional additional-arguments)
		   (when (propertyp options name)
		     (let ((function (getf options name)))
		       (when (consp function)
			 (setf (getf options name) (fix-arglist function
								additional-arguments)))))))
	  (fix-function :tester)
	  (fix-function :documentation '(stream))
	  (values `(,clim-fun ,name
		    (,from-type ,to-type ,(get-command-table-name) ,@options)
		    ,@(fix-arglist (cons arglist body)))
		  hints))))))

;; This is compatible except the last argument ("reason") disappears
;; also nil as a plural-count has a different meaning (in CLIM, no article)
(define-dw-to-clim-conversion dw:describe-presentation-type (type &rest args)
  (progn
    (when (> (length args) 2) (setq args (subseq args 0 2)))	;abandon reason
    (when (and (> (length args) 1)
	       (member (second args) '(nil 'nil) :test #'equal))
      (setq args (list (first args) 1)))
    `(clim::describe-presentation-type ,type ,@args)))

;; DW values are (CHOICE ITEM MOUSE-CHAR), CLIM values are (VALUE CHOSEN-ITEM GESTURE),
;; I think that's close enough.  The third CLIM value is really a button-press-event.
;; :ASSOCIATED-WINDOW is not optional in CLIM
;; :ASSOCIATED-WINDOW is not the same as :SUPERIOR, but it should be close enough
(define-dw-to-clim-conversion dw:menu-choose (item-list &rest options)
  (multiple-value-bind (options error)
      (verify-clim-options 'dw:menu-choose 'clim::menu-choose t options
			   '(:presentation-type :printer)
			   '(:row-wise :center-p :character-style :momentary-p :temporary-p
			     :minimum-width :minimum-height)
			   '(:near-mode :alias-for-selected-windows)
			   '((:prompt :label) (:default :default-item)
			     (:superior :associated-window)))
    (unless error
      `(clim::menu-choose ,item-list ,@options))))

;; In CLIM the user has to come up with the menu
;; I assume the drawer protocol is compatible, but failed to verify that
(define-dw-to-clim-conversion dw:menu-choose-from-drawer (drawer presentation-type
							  &rest options)
  (multiple-value-bind (options error)
      (verify-clim-options 'dw:menu-choose-from-drawer 'clim::menu-choose-from-drawer
			   t options
			   '()
			   '(:default :row-wise :center-p :character-style
			     :momentary-p :temporary-p
			     :use-redisplay :minimum-width :minimum-height)
			   '(:superior :near-mode :alias-for-selected-windows)
			   '((:prompt :label)))
    (unless error
      (let ((associated-window (getf options :superior)))
	`(clim::with-menu (menu ,@(and associated-window (list associated-window)))
	   (clim::menu-choose-from-drawer menu ,presentation-type ,drawer))))))

(define-dw-to-clim-substitution dw:*program* clim::*application-frame*)

(define-dw-to-clim-substitution dw:*program-frame*
				(clim::frame-top-level-window clim::*application-frame*))

;; CLIM returns one more value than DW, which should be no problem
(define-dw-to-clim-conversion dw:completing-from-suggestions ((stream &rest options)
							      &body body)
  :modification-depth 2
  :form
  (multiple-value-bind (options error)
      (verify-clim-options 'dw:completing-from-suggestions 'clim::completing-from-suggestions
			   nil options
			   '(:partial-completers :allow-any-input)
			   '(:delimiters :enable-forced-return :force-complete :type
			     :parser :complete-activates :compress-choices
			     :compression-delimiter :initially-display-possibilities))
    (unless error
      `(clim::completing-from-suggestions (,stream ,@options)
	 ,@body))))

;; Only the 2-argument form converts
(define-dw-to-clim-conversion dw:suggest (name object)
  `(clim::suggest ,name ,object))

(define-dw-to-clim-conversion dw:default-command-top-level (program &rest options)
  (multiple-value-bind (options error)
      (verify-clim-options 'dw:default-command-top-level 'clim::default-frame-top-level
			   t options
			   '(:prompt)
			   '(:window-wakeup :abort-exits :command-evaluator :form-evaluator
			     :environment :form-values-print-function :initial-redisplay
			     ;; DW:READ-PROGRAM-COMMAND options not in the declared arglist
			     :stream :dispatch-mode :keyboard-accelerators
			     :environment :input-wait-handler :intercept-function
			     ;; CP:READ-ACCELERATED-COMMAND options not in the declared arglist
			     :help-stream :echo-stream :whostate :command-prompt
			     :full-command-full-rubout :special-blip-handler :timeout
			     :input-wait :input-block :handle-clear-input
			     :catch-accelerator-errors :echo-accelerators
			     :unknown-accelerator-is-command :unknown-accelerator-tester
			     :blank-line-mode :process-unknown-accelerator
			     :abort-chars :suspend-chars :status :notification
			     ;; CP:READ-COMMAND-OR-FORM options not in the declared arglist
			     :exception-chars :expression-reader :expression-printer)
			   '()
			   '((:command-prompt :prompt)))
    (unless error
      `(clim::default-frame-top-level ,program ,@options))))

(define-dw-to-clim-conversion dw:get-program-pane (name &key (if-does-not-exist :error))
  `(clim::get-frame-pane clim::*application-frame* ,name
			,@(unless (member if-does-not-exist '(:error ':error) :test #'equal)
			    `(:errorp ,if-does-not-exist))))

(define-dw-to-clim-conversion dw:set-program-frame-configuration
			      (name &optional (frame 'dw:*program-frame*))
  (case *clim-version*
    (1 `(clim::set-frame-layout
	  ,(if (eq frame 'dw:*program-frame*) 'clim::*application-frame* frame) ,name))
    (2 `(,(intern "SETF")
	 (clim::frame-current-layout
	   ,(if (eq frame 'dw:*program-frame*) 'clim::*application-frame* frame))
	 ,name))))

(define-dw-to-clim-conversion dw:tracking-mouse ((&optional stream &rest options)
						 &body clauses)
  :modification-depth 1000
  :form
  (multiple-value-bind (options error)
      (verify-clim-options 'dw:tracking-mouse 'clim::tracking-pointer t options
			   '(:multiple-window)
			   '(:whostate :who-line-documentation-string
			     :who-line-more-documentation-string))
    (unless error
      (when (null stream) (setq stream '*standard-output*))
      ;; Translate the clauses.  CLIM allows arguments to be left out, but
      ;; the user has to use the CLIM names.  DW uses normal arglists, and
      ;; in some cases passes fewer arguments than CLIM does.
      (flet ((translate-clause (clause)
	       (destructuring-bind (keyword arglist . body) clause
		 (let ((info (assoc keyword
				    '((:mouse-motion (x y)
				       :pointer-motion (window x y))
				      (:mouse-click (mouse-char x y)
				       :pointer-button-press (event x y))
				      (:release-mouse ()
				       :pointer-button-release (event x y))
				      (:keyboard (character)
				       :keyboard (character))
				      (:presentation (presentation)
				       :presentation (presentation window x y))
				      (:presentation-click (mouse-char presentation)
				       :presentation-button-press (presentation event x y)))))
		       clim-arglist
		       dw-arglist
		       (renames nil)
		       (new-arglist nil)
		       (event-var nil))
		   (cond ((null info)
			  (warn "~S does not support ~S clauses.~@
				 The clause will be left in, but it will not work."
			      'clim::tracking-pointer keyword)
			  (setq new-arglist arglist))
			 (t
			  (setq dw-arglist (second info)
				keyword (third info)
				clim-arglist (fourth info))
			  (ignore clim-arglist)	;as it turns out, we don't use it yet
			  (dolist (item arglist)
			    (unless (member item lambda-list-keywords)
			      (let ((dw-arg (pop dw-arglist)))
				(when (eq dw-arg 'mouse-char)
				  (setq event-var (intern "EVENT"))
				  (push event-var new-arglist))
				(if (and event-var
					 (member dw-arg '(mouse-char x y)))
				    (let ((accessor (second (assoc dw-arg
								   '((x clim::pointer-event-x)
								     (y clim::pointer-event-y)
								     (mouse-char clim::pointer-event-button))))))	;close as we can get
				      (push (cons item `(,accessor ,event-var))
					    renames))
				  (let ((new-item (intern (string dw-arg))))
				    (push (cons item new-item) renames)
				    (push new-item new-arglist))))))
			  (setq new-arglist (nreverse new-arglist))
			  (setq body (lt:copyforms
				       #'(lambda (subform kind usage)
					   (declare (ignore usage))
					   (if (and (member kind 'lt:(set symeval))
						    (not (member subform lt:*mapforms-bound-variables*))
						    (setq kind (assoc subform renames)))
					       (cdr kind)
					     subform))
				       `(progn ,@body)
				       :bound-variables nil
				       :back-translate-macros t))
			  (setq body (if (and (consp body) (eq (car body) 'progn))
					 (cdr body)
				       (list body)))))
		   `(,keyword ,new-arglist ,@body)))))
	`(clim::tracking-pointer (,stream ,@options)
	   ,@(mapcar #'translate-clause clauses))))))

(define-dw-to-clim-conversion dw:with-output-recording-disabled
			      ((&optional (stream '*standard-output*)) &body body)
  :modification-depth 2
  :form
  (case *clim-version*
    (1 `(clim::with-output-recording-options (,stream :record-p nil)
	  ,@body))
    (2 `(clim::with-output-recording-options (,stream :record nil)
	  ,@body))))

(define-dw-to-clim-conversion dw:with-output-truncation
			      ((stream &key (horizontal t horizontal-p)
					    (vertical t vertical-p))
			       &body body)
  :modification-depth 2
  :form
  (let (eol-action eop-action)
    (when (null stream)
      (setq stream '*standard-output*))
    (cond ((and horizontal-p (not vertical-p))
	   (setq vertical nil))
	  ((and vertical-p (not horizontal-p))
	   (setq horizontal nil)))
    (setq eol-action (if horizontal :allow :wrap))
    (setq eop-action (if vertical :allow :scroll))
    (case *clim-version*
      (1 `(clim::with-end-of-line-action (,eol-action ,stream)
	    (clim::with-end-of-page-action (,eop-action ,stream)
	      ,@body)))
      (2 `(clim::with-end-of-line-action (,stream ,eol-action)
	    (clim::with-end-of-page-action (,stream ,eop-action)
	      ,@body))))))

;; It's not strictly correct to rename these, but it's close enough...
(define-dw-to-clim-substitution graphics:with-room-for-graphics clim::with-room-for-graphics)
(define-dw-to-clim-substitution dw:with-own-coordinates clim::with-local-coordinates)
(define-dw-to-clim-substitution dw:in-sub-window clim::with-local-coordinates)

;; This doesn't worry about element-to-sequence coercion and missing required argument handling
(define-dw-to-clim-conversion cp:build-command (command-name &rest command-arguments)
  (block convert
    (cond ((stringp command-name)
	   (setq command-name `(clim::find-command-from-command-line-name
				 ,command-name
				 (clim::frame-command-table clim::*application-frame*))))
	  ((and (consp command-name)
		(eq (first command-name) 'quote)
		(symbolp (second command-name))))
	  (t (return-from convert nil)))
    `(list ,command-name ,@command-arguments)))

(define-dw-to-clim-conversion cp:define-command (name-and-options arguments &body body)
  :modification-depth 1000
  :form
  (convert-define-command name-and-options arguments body))

(define-dw-to-clim-conversion define-cp-command (name-and-options arguments &body body)
  :modification-depth 1000
  :form
  (convert-define-command name-and-options arguments body))

(defun convert-define-command (name-and-options arguments body)
  (unless (atom name-and-options)
    ;; Remove :provide-output-destination-keyword, :values, and :explicit-arglist
    ;; That seems generally better than giving up on the conversion if they are present
    (setq name-and-options
	  (cons (car name-and-options)
		(loop for (key val) on (cdr name-and-options) by #'cddr
		      append (case key
			       ((:name) (list key val))
			       ((:command-table :comtab)
				(list :command-table (convert-command-table-name val nil)))
			       ;; The following are only allowed in DW:DEFINE-PROGRAM-COMMAND
			       ((:keyboard-accelerator) (list :keystroke val))
			       ((:menu-accelerator)
				(let ((doc (getf (cdr name-and-options) :menu-documentation)))
				  (cond ((and (stringp doc) (stringp val))
					 `(:menu (,val :documentation ,doc)))
					((stringp doc)
					 `(:menu (,(clim::command-name-from-symbol
						     (car name-and-options))
						  :documentation ,doc)))
					(t `(:menu ,val)))))
			       ((:menu-documentation) nil)	;already handled
			       (otherwise
				 (warn "CLIM does not have an equivalent of the ~S~@
					define-command option.  The option will be removed."
				       key)
				 nil))))))
  `(clim::define-command ,name-and-options
			,(convert-define-command-arguments name-and-options arguments)
     ,@body))

;; DW and CLIM are pretty close in argument specification syntax, but we need to strip
;; :CONFIRM, and warn about other options that CLIM doesn't have.
(defun convert-define-command-arguments (command-name arguments)
  (unless (atom command-name) (setq command-name (car command-name)))
  (loop for argument in arguments collect
    (if (atom argument) argument	;&KEY
	`(,(first argument)		;name
	  ,(second argument)		;presentation type
	  ,@(loop for (key val) on (cddr argument) by #'cddr
		  append (case key
			   ((:default :mentioned-default :default-type
			     :provide-default :history :display-default
			     :prompt :documentation :when)
			    (list key val))
			   ((:confirm) nil)
			   (otherwise
			     (warn "CLIM does not support the ~S option in the argument~@
				    specification for the ~S argument to ~S.~@
				    The option will be removed."
				   key (first argument) command-name)
			     nil)))))))

;; CLIM doesn't support numeric arguments [still true?], so this is a bit limited.
;; As for the options, CLIM doesn't have numeric arguments, and we can't do
;; :ACTIVATE nor :ECHO, so we have to just ignore the options and hope for the best.
(define-dw-to-clim-conversion cp:define-command-accelerator (name command-table characters
							     options arglist &body body)
  (labels ((translate (character)
	     `(clim::add-keystroke-to-command-table ',command-table ,character
						   :command ,body
						   :errorp nil)))
    (ignore name)			;no place to stick it
    (ignore options)			;can't do any of them
    (setq command-table (convert-command-table-name command-table nil))
    (setq body (if (cdr body) `(progn ,@body) (car body)))
    (when arglist			;Guaranteed no numeric arg supplied
      (setq body (lt:let-subst arglist '(nil 1) body)))
    ;; If it's constant list-structure, fully quotify it
    (when (and (member (first body) '(list si:xr-bq-list list* si:xr-bq-list* cons
				      cp:build-command))
	       (every #'constantp (rest body)))
      (when (eq (first body) 'cp:build-command)
	(setq body (cons 'list (rest body))))
      (setq body `',(eval body)))
    ;; If it's a constant command with no arguments, reduce to the command name
    ;; partly because it looks nicer, and partly because there's a bug in the other case
    (when (and (consp body) (eq (first body) 'quote)
	       (consp (second body)) (null (cdr (second body))))
      (setq body `',(car (second body))))
    (let ((forms (mapcar #'translate
			 (if (atom characters) (list characters) characters))))
      (if (cdr forms) `(progn ,@forms) (car forms)))))

(define-dw-to-clim-substitution scl:beep clim::beep)


;;; Incremental redisplay

;; No real equivalent to this, just wrap CLIM::UPDATING-OUTPUT around the body
(define-dw-to-clim-conversion dw:redisplayer ((stream) &body body)
  :modification-depth 2
  :form
  `(clim::updating-output (,stream)
     ,@body))

(define-dw-to-clim-conversion dw:with-redisplayable-output ((&rest options) &body body)
  :modification-depth 2
  :form
  (multiple-value-bind (new-options error)
      (verify-clim-options 'dw:with-redisplayable-output 'clim::updating-output
			   nil options
			   '(:unique-id :id-test :cache-value :cache-test
			     :copy-cache-value)
			   '(:redisplay-piece :piece-hook :piece-flavor)
			   '(:dont-snapshot-variables :stream))
    (unless error
      `(clim::updating-output (,(getf options :stream `*standard-output*) ,@new-options)
	 ,@body))))

(define-dw-to-clim-conversion dw:do-redisplay
			      (piece &optional (stream '*standard-output*) &rest options)
  (multiple-value-bind (options error)
      (verify-clim-options 'dw:do-redisplay 'clim::redisplay t options
			   '()
			   '()
			   '(:full-set-cursorpos :truncate-p :once-only
			     :save-cursor-position :limit-to-viewport))
    (declare (ignore options))
    (unless error
      `(clim::redisplay ,piece ,stream))))

(define-dw-to-clim-conversion dw:redisplayable-present 
			      (object ptype &rest options
			       &key (unique-id nil id-p) &allow-other-keys)
  `(clim::updating-output (,(getf options :stream `*standard-output*)
			  ,@(and id-p `(:unique-id ,unique-id))
			  :cache-value ,object)
     (clim::present ,object ,ptype ,@(si:rem-keywords options '(:unique-id)))))

(define-dw-to-clim-conversion dw:redisplayable-format
			      (stream format-string &rest format-args)
  `(clim::updating-output (,stream :unique-id ,format-string
				  :cache-value (list ,@format-args)
				  :cache-test #'equal)
     (clim-lisp:format ,stream ,format-string ,@format-args)))


;;; Application Frameworks

(define-dw-to-clim-conversion dw:define-program-framework (frame-name &rest options)
  :modification-depth 1000
  :form
  (let* ((slots (getf options :state-variables))
	 (superclasses (getf options :inherit-from))
	 (flavor-options (getf options :other-defflavor-options))
	 (conc-name (loop for item in flavor-options
			  do (when (and (consp item) (eq (car item) :conc-name))
			       (unless (eq (second item) t)
				 (return (or (second item) ""))))
			  finally (return (string-append frame-name "-"))))
	 (initable (loop for item in flavor-options do
		     (when (eq item :initable-instance-variables) (return t))
		     (when (and (consp item) (eq (car item) :initable-instance-variables))
		       (return (cdr item))))))
    (multiple-value-bind (options error)
	(verify-clim-options 'dw:define-program-framework 'clim::define-application-frame
			     nil (si:rem-keywords options '(:state-variables :inherit-from
							    :other-defflavor-options))
			     '(:command-definer :top-level :command-table :panes)
			     '(:pretty-name :command-evaluator :selected-pane :query-io-pane
			       :terminal-io-pane :label-pane :selectable :select-key
			       :system-menu :size-from-pane)
			     '()
			     '((:configurations :layout)))
      (unless error
	(setq options (copy-list options))

	;; :TOP-LEVEL has compatible syntax
	;; :COMMAND-TABLE has a rather different syntax.  :KBD-ACCELERATOR-P can be discarded.
	(let ((inherit-from (getf (getf options :command-table) :inherit-from)))
	  (cond ((null inherit-from)
		 (remf options :command-table))
		((and (consp inherit-from)
		      (eq (first inherit-from) 'quote)
		      (listp (second inherit-from)))
		 (setf (getf options :command-table)
		       `(,frame-name :inherit-from ,(mapcar #'convert-command-table-name
							    (second inherit-from)
							    (circular-list nil)))))
		(t
		 (warn ":COMMAND-TABLE (:INHERIT-FROM ~S) not converted because ~
			it's not constant"
		       inherit-from)
		 (remf options :command-table))))

	;; Default command table name in later presentation translators
	(setf (getf *conversion-state* 'get-command-table-name) frame-name)

	(setf (getf options :panes) (convert-application-panes frame-name
							       (getf options :panes)))
	(let ((layout (getf options :layout)))
	  (when layout
	    (setf (getf options :layout) (convert-application-layout frame-name layout))))

	;; Translate the slot specifications
	(setq slots (loop for (slot default ptype) in slots
			  ;; Doesn't support the complex form of :INITABLE-INSTANCE-VARIABLES
			  with initarg = (and (or (eq initable t) (member slot initable))
					      (intern (string slot) "KEYWORD"))
			  collect `(,slot :initform ,default
				    ,@(when initarg `(:initarg ,initarg))
				    ,@(when ptype `(:type ,ptype))
				    :accessor ,(intern (string-append conc-name slot)))))

	;; Arrange to convert command definitions
	(let ((command-definer (getf options :command-definer)))
	  (when command-definer
	    (when (eq command-definer t)
	      (setq command-definer (intern (string-append "DEFINE-" frame-name "-COMMAND"))))
	    (unless (string-search "DEF" command-definer)
	      (warn "The command-definer for ~S, ~S, will~@
		     probably fail to be recognized by the Conversion Tool since~@
		     its name does not include \"DEF\"."
		    frame-name command-definer))
	    (add-function-conversion 'dw-to-clim command-definer
				     :name 'convert-define-program-command
				     :modification-depth 1000)
	    ;; Save the slots for CONVERT-DEFINE-PROGRAM-COMMAND
	    (setf (getf (getf *conversion-state* command-definer) 'frame-slots) slots)))

	;; Don't forget that CLIM uses parenthesized syntax for its options
	(setq options (loop for (key val) on options by #'cddr
			    collect `(,key ,val)))

	;; Translate the Flavors options to class options
	(loop for item in flavor-options
	      as key = (if (atom item) item (car item)) do
	  (case key
	    ((:conc-name :initable-instance-variables))	;already handled
	    ((:documentation)
	     (setq options (append options (list item))))
	    ((:default-init-plist)
	     (setq options (append options `((:default-initargs ,@(cdr item))))))
	    (otherwise (warn "Flavor option ~S is being ignored." item))))

	;; Now that everything is translated, put it all back together again
	`(clim::define-application-frame ,frame-name ,superclasses ,slots ,@options)))))

;; The CLIM documentation for this is nearly nonexistent.  This function does what
;; I figured out from looking at the source.
(defun convert-application-panes (frame-name panes)
  ;; Since we can't control where *STANDARD-OUTPUT* goes, if there's a :DISPLAY pane
  ;; with :TYPEOUT-WINDOW T, move it to the top of the list.  If there isn't, move
  ;; the first :DISPLAY pane to the top of the list.
  (let ((output-pane (loop for pane in panes
			   as (type . options) = (cdr pane)
			   with first-display = nil
			   do (when (eq type :display)
				(unless first-display (setq first-display pane))
				(when (getf options :typeout-window)
				  (return pane)))
			   finally (return first-display))))
    (when output-pane
      (setq panes (cons output-pane (remove output-pane panes)))))
  (let ((type-translations '((:title :title)
			     (:command-menu :command-menu)
			     (:display :application)
			     (:interactor :interactor)
			     (:listener :interactor)		;I guess
			     (:accept-values :accept-values)))
	(option-translations
	  '((:default-character-style :default-text-style convert-character-style-1)
	    (:vsp :vsp)
	    (:incremental-redisplay :incremental-redisplay)
	    (:redisplay-function :display-function)
	    (:accept-values-function :display-function convert-accept-values-function)
	    (:redisplay-after-commands :display-after-commands)
	    (:redisplay-string :display-string)
	    (:size-from-output :default-size (constantly :compute))
	    (:height :height)		;I couldn't figure out if this is really allowed
	    (:width :width)		;..
	    (:margin-components list convert-margin-components)
	    (:blinker-p :initial-cursor-visibility convert-blinker-p-window-option)
	    (:end-of-page-mode :end-of-page-action convert-end-of-page-mode)
	    (:label :label)
	    (:flavor :window-class)
	    (:height-in-lines :height-in-lines)
	    ;;--- I couldn't figure out how to do these, the remaining documented DW options.
	    ; :TYPEOUT-WINDOW
	    ; :AUTOMATICALLY-REMOVE-TYPEOUT-WINDOW
	    ; :MENU-LEVEL
	    ; :ROWS
	    ; :COLUMNS
	    ; :EQUALIZE-COLUMN-WIDTHS
	    ; :CENTER-P
	    ; :SCROLL-FACTOR
	    )))
    (loop for (pane-name type . options) in panes
	  as translation = (assoc type type-translations)
	  do (unless translation
	       (warn "The pane-type ~S for pane ~S of application frame ~S~@
		      is not recognized and will be left for manual conversion."
		     type pane-name frame-name))
	  collect `(,pane-name ,(or (second translation) type)
		    ,@(loop for (key val) on options by #'cddr
			    as translation = (assoc key option-translations)
			    do (unless translation
				 (warn "The option ~S for pane ~S of application frame ~S~@
					is not recognized and will be left for manual ~
					conversion."
				       key pane-name frame-name))
			    as (new-key translator) = (cdr translation)
			    do (cond ((constantp val)
				      (setq val (eval val)))
				     ((and (consp val)
					   (eq (first val) 'si:parse-character-style)
					   (constantp (second val)))
				      (setq val (eval (second val))))
				     (t
				      (warn "The option ~S ~S for pane ~S of ~
					     application frame ~S~@
					     will not be converted correctly because it's not ~
					     a constant."
					  key val pane-name frame-name)))
			       (setq val (cond ((null translator) val)
					       ((atom translator) (funcall translator val))
					       (t (second translator))))	;constantly
			       (when (eq new-key 'list)
				 (setq new-key (first val))
				 (setq val (second val)))
			       (unless (constantp val)
				 (setq val (list 'quote val)))
			    append (list (or new-key key) val))))))

(defun convert-accept-values-function (val)
  `(clim::accept-values-pane-displayer :displayer ,val))

(defun convert-blinker-p-window-option (val)
  (if (constantp val)
      (and (eval val) ':off)
      `(and ,val ':off)))

(defun convert-end-of-page-mode (val)
  (or (and (constantp val)
	   (cdr (assoc (eval val)
		       '((:truncate . :allow) (:scroll . :scroll) (:wrap . :wrap)))))
      val))

;; This throws away most of the information since CLIM gives so little control
(defun convert-margin-components (components)
  (let* ((scroll-bars nil)
	 (options (loop for (type . options) in components append
		    (case type
		      (dw:margin-label
			`(:label ,(getf options :string "***Your label here***")))
		      (dw:margin-borders
			`(:borders t))
		      (dw:margin-scroll-bar
			(pushnew (case (getf options :margin :default)
				   ((:default :left :right) :vertical)
				   (otherwise :horizontal))
				 scroll-bars)
			nil)))))
    (when scroll-bars
      (setq options `(:scroll-bars ,(if (cdr scroll-bars) ':both (car scroll-bars))
		      ,@options)))
    options))

;; This can't be an exact conversion since the (non-Silica) CLIM layout language
;; is too weak.  The appalling thing is that CLIM can't even be told to make a pane
;; a certain number of lines, so we have to use a guess to convert line counts
;; to frame-size fractions.  Since :LAYOUT is completely undocumented there is
;; plenty of scope for mistakes here.
(defun convert-application-layout (frame-name layout)
  (unless (constantp layout)
    (warn "The layout for application frame ~S, ~S,~@
	   is not a constant and hence cannot be converted."
	  frame-name layout)
    (return-from convert-application-layout
      `(:unconverted-dw-configurations ,layout)))
  (loop for (name . stuff) in (eval layout)
	as layout = (cdr (assoc :layout stuff))
	as sizes = (cdr (assoc :sizes stuff))
	with lines-per-screen = 30
	collect (labels ((convert (item sizes-clause)
			   (let ((layout (cdr (assoc item layout))))
			     (if (null layout)
				 ;; This is a pane
				 `(,item ,(convert-size item sizes-clause))
				 ;; This is a row or a column
				 `(,(first layout)	;:ROW or :COLUMN
				   ,(convert-size item sizes-clause)
				   ,@(let ((sizes-clause (cdr (assoc item sizes))))
				       (mapcar #'(lambda (item) (convert item sizes-clause))
					       (cdr layout)))))))
			 (item-size (item sizes-clause)
			   (dolist (elem sizes-clause)
			     (when (and (consp elem) (eq (first elem) item))
			       (return (rest elem)))))
			 (convert-size (item sizes-clause)
			   (let ((size (item-size item sizes-clause)))
			     (cond ((null size) ':compute)
				   ((null (cdr size))
				    (setq size (first size))
				    (cond ((numberp size) size)
					  ((eq size ':even) ':rest)
					  (t ':compute)))
				   ((and (numberp (first size)) (eq (second size) ':lines))
				    (if (= (first size) 1)
					':compute	;e.g. :TITLE pane, this works better
					(/ (round (* (/ (first size) lines-per-screen) 100))
					   100.0)))
				   (t ':compute)))))	;:ASK-WINDOW etc.
		  (list (if (string= name 'main)	;DW::MAIN
			    (intern "DEFAULT")
			    name)
			(convert name `((,name 1.0)))))))

(defun convert-define-program-command (form)
  (destructuring-bind-carefully (definer name-and-options arguments &body body) form
    ;; Convert instance variable references to accessor calls
    (let ((slots (getf (getf *conversion-state* definer) 'frame-slots)))
      (labels ((translate (form)
		 (let ((slots-referenced
			 (lt:mapforms (lambda (subform kind usage slots-referenced)
					(declare (ignore usage))
					(if (and (member kind 'lt:(set symeval))
						 (not (member subform
							      lt:*mapforms-bound-variables*))
						 (assoc subform slots))
					    (adjoin subform slots-referenced)
					    slots-referenced))
				      form :bound-variables nil)))
		   (if (null slots-referenced)
		       form
		       `(clos:with-slots ,(nreverse slots-referenced)
					 clim::*application-frame*
			  ,@(if (and (consp form) (eq (first form) 'progn))
				(rest form)
				(list form))))))
	       (translate-argument (argument)
		 (if (atom argument) argument
		     (cons (first argument) (mapcar #'translate (rest argument))))))
	(setq body (translate (if (cdr body) (cons 'progn body) (car body))))
	(setq body (if (and (consp body) (eq (first body) 'progn)) (rest body) (list body)))
	(setq arguments (mapcar #'translate-argument arguments))))
    ;; Convert to CLIM DEFINE-COMMAND syntax
    (let ((new-args (cdr (convert-define-command name-and-options arguments body))))
      (unless (equal new-args (cdr form))
	(cons definer new-args)))))

;; This unmodular kludge is so that the conversion tool will find calls to the
;; application's command-definer macro, assuming its name contains "DEF".
;; Searching for DEF rather than DEFINE will slow conversion down epsilonically,
;; but should cover 99.9% of all command-definer macro names.
(pushnew "DEF" (symbol-value-in-instance (find-conversion-set 'dw-to-clim) 'search-strings))

(define-dw-to-clim-message-conversion :redisplay-pane (frame pane-name &optional force-p)
  (progn
    ;; DW wants the window, CLIM wants the application
    (when (eq frame 'dw:*program-frame*)
      (setq frame 'clim::*application-frame*))
    ;; DW accepts either a pane or a pane-name, CLIM accepts only a pane-name
    (when (and (consp pane-name)
	       (eq (first pane-name) 'dw:get-program-pane))
      (setq pane-name (second pane-name)))
    `(clim::redisplay-frame-pane ,frame ,pane-name 
				,@(if force-p `(:force-p ,force-p)))))

(define-dw-to-clim-message-conversion :get-pane (frame pane-name)
  (progn
    ;; DW wants the window, CLIM wants the application
    (when (eq frame 'dw:*program-frame*)
      (setq frame 'clim::*application-frame*))
    `(clim::get-frame-pane ,frame ,pane-name)))

(define-dw-to-clim-message-conversion :clear-history (window &rest ignore-options)
  (progn
    ignore-options
    `(clim::window-clear ,window)))

;; One test program uses :CLEAR-WINDOW, but on a non-dynamic window where it means
;; what :CLEAR-HISTORY means on a dynamic window.  We can offer a choice.
(define-dw-to-clim-message-conversion :clear-window (window &rest ignore-options)
  :documentation "Erase the entire drawing surface, as for a non-dynamic window in Genera"
  :form (progn
	  ignore-options
	  `(clim::window-clear ,window)))

(define-dw-to-clim-message-conversion :clear-window (window &rest ignore-options)
  :documentation "Scroll the window to the end, as for a dynamic window in Genera"
  :name convert-clear-window-to-scroll-to-end
  :form (let ((x (intern "X"))
	      (y (intern "Y")))
	  ignore-options
	  ;; See (FLAVOR:METHOD :CLEAR-WINDOW DW:DYNAMIC-WINDOW)
	  ;; This is rather simple-minded compared to that, as befits CLIM
	  (case *clim-version*
	    (1 `(progn 
		  (fresh-line ,window)
		  (multiple-value-bind (,x ,y)
		      (clim::stream-cursor-position* ,window)
		    (clim::window-set-viewport-position* ,window ,x ,y))))
	    (2 `(progn
		  (fresh-line ,window)
		  (multiple-value-bind (,x ,y)
		      (clim::stream-cursor-position ,window)
		    (clim::window-set-viewport-position ,window ,x ,y)))))))

(define-dw-to-clim-message-conversion :refresh (window &optional ignore-type)
  (progn
    ignore-type
    `(clim::window-refresh ,window)))

(define-dw-to-clim-message-conversion :expose (window)
  `(clim::window-expose ,window))

(define-dw-to-clim-message-conversion :deexpose (window)
  `(setf (clim::window-visibility ,window) nil))

(define-dw-to-clim-message-conversion :bury (window)
  `(clim::window-stack-on-bottom ,window))

(define-dw-to-clim-message-conversion :superior (window)
  `(clim::window-parent ,window))

(define-dw-to-clim-message-conversion :inferiors (window)
  `(clim::window-children ,window))

(define-dw-to-clim-message-conversion :inside-edges (window)
  `(clim::window-inside-edges ,window))

(define-dw-to-clim-message-conversion :inside-size (window)
  `(clim::window-inside-size ,window))

(define-dw-to-clim-message-conversion :line-height (window)
  `(clim::stream-line-height ,window))

(define-dw-to-clim-message-conversion :inside-width (window)
  `(clim::window-inside-width ,window))

(define-dw-to-clim-message-conversion :inside-height (window)
  `(clim::window-inside-height ,window))

(define-dw-to-clim-message-conversion :string-length (window string
						      &optional (start 0) (end nil)
								(stop-x nil) (style nil)
								(start-x 0) (max-x 0))
  (when (and (eql stop-x nil) (eql start-x 0) (eql max-x 0))
    (let ((width (intern "WIDTH"))
	  (height (intern "HEIGHT"))
	  (final-x (intern "FINAL-X"))
	  (final-y (intern "FINAL-Y"))
	  (baseline (intern "BASELINE")))
      `(multiple-value-bind (,width ,height ,final-x ,final-y ,baseline)
	   (clim::text-size ,window ,string
			   ,@(when style
			       `(:text-style ,(convert-character-style style)))
			   ,@(unless (eql start 0) `(:start ,start))
			   ,@(unless (eql end nil) `(:end ,end)))
	 (values ,final-x "final index not available in CLIM"
		 ,width ,final-y ,height ,baseline)))))

(define-dw-to-clim-message-conversion :character-width (window character
							&optional font x style)
  (unless (or font x)
    `(clim::stream-character-width ,window ,character
				  ,@(and style (list (convert-character-style style))))))

(define-dw-to-clim-message-conversion :vsp (window)
  (case *clim-version*
    (1 `(clim::stream-vsp ,window))
    (2 `(clim::stream-vertical-spacing ,window))))

(define-dw-to-clim-message-conversion :read-cursorpos (window &rest args)
  (progn
    args
    (case *clim-version*
      (1 `(clim::stream-cursor-position* ,window))
      (2 `(clim::stream-cursor-position ,window)))))

(define-dw-to-clim-message-conversion :set-cursorpos (window x y &optional unit)
  (progn
    unit
    (case *clim-version*
      (1 `(clim::stream-set-cursor-position* ,window ,x ,y))
      (2 `(clim::stream-set-cursor-position ,window ,x ,y)))))

(define-dw-to-clim-message-conversion :mouse-position (window)
  (case *clim-version*
    (1 `(clim::stream-pointer-position* ,window))
    (2 `(clim::stream-pointer-position ,window))))

(define-dw-to-clim-message-conversion :set-mouse-position (window x y &optional error-p)
  (progn
    error-p
    (case *clim-version*
      (1 `(clim::stream-set-pointer-position* ,window ,x ,y))
      (2 `(clim::stream-set-pointer-position ,window ,x ,y)))))

;;--- This really does too much work...
(define-dw-to-clim-message-conversion :x-scroll-position (window)
  (let ((x (intern "X"))
	(y (intern "Y"))
	(left (intern "LEFT"))
	(top (intern "TOP"))
	(right (intern "RIGHT"))
	(bottom (intern "BOTTOM"))
	(width (intern "WIDTH"))
	(ignoramus (intern "IGNORE"))
	(viewport-position 
	  (case *clim-version*
	    (1 'clim::window-viewport-position*)
	    (2 'clim::window-viewport-position)))
	(output-history 
	  (case *clim-version*
	    (1 'clim::output-recording-stream-output-record)
	    (2 'clim::stream-output-history))))
    `(multiple-value-bind (,x ,y) (,viewport-position ,window)
       (declare (ignore ,y))
       (clim::with-bounding-rectangle* (,left ,top ,right ,bottom) 
	   (,output-history ,window)
	 (declare (,ignoramus ,top ,bottom))
	 (let ((,width (clim::window-inside-width ,window)))
	   (values ,x ,width ,left ,right))))))

(define-dw-to-clim-message-conversion :x-scroll-to (window position type)
  (when (constantp type)
    (let ((x (intern "X")) 
	  (y (intern "Y"))
	  (viewport-position 
	    (case *clim-version*
	      (1 'clim::window-viewport-position*)
	      (2 'clim::window-viewport-position)))
	  (set-viewport-position 
	    (case *clim-version*
	      (1 'clim::window-set-viewport-position*)
	      (2 'clim::window-set-viewport-position))))
      (case (eval type)
	((:relative-jump :relative)
	 `(multiple-value-bind (,x ,y) (,viewport-position ,window)
	    (,set-viewport-position ,window (+ ,x ,position) ,y)))
	(:absolute
	 `(multiple-value-bind (,x ,y) (,viewport-position ,window)
	    (declare (ignore ,x))
	    (,set-viewport-position ,window ,position ,y)))
	(:screenful
	 `(multiple-value-bind (,x ,y) (,viewport-position ,window)
	    (,set-viewport-position ,window 
				    (- ,x (* (clim::bounding-rectangle-width
					       (clim::window-viewport ,window))
					     (signum ,position))) ,y)))))))

;;--- This really does too much work...
(define-dw-to-clim-message-conversion :y-scroll-position (window)
  (let ((x (intern "X"))
	(y (intern "Y"))
	(left (intern "LEFT"))
	(top (intern "TOP"))
	(right (intern "RIGHT"))
	(bottom (intern "BOTTOM"))
	(height (intern "HEIGHT"))
	(ignoramus (intern "IGNORE"))
	(viewport-position 
	  (case *clim-version*
	    (1 'clim::window-viewport-position*)
	    (2 'clim::window-viewport-position)))
	(output-history 
	  (case *clim-version*
	    (1 'clim::output-recording-stream-output-record)
	    (2 'clim::stream-output-history))))
    `(multiple-value-bind (,x ,y) (,viewport-position ,window)
       (declare (ignore ,x))
       (clim::with-bounding-rectangle* (,left ,top ,right ,bottom) 
	   (,output-history ,window)
	 (declare (,ignoramus ,left ,right))
	 (let ((,height (clim::window-inside-height ,window)))
	   (values ,y ,height ,top ,bottom))))))

;; This doesn't do DW's fancy stuff about aligning to text line boundaries
;; and clipping to the bounding rectangle of what's actually drawn on the drawing surface
(define-dw-to-clim-message-conversion :y-scroll-to (window position type)
  (when (constantp type)
    (let ((x (intern "X")) 
	  (y (intern "Y"))
	  (viewport-position 
	    (case *clim-version*
	      (1 'clim::window-viewport-position*)
	      (2 'clim::window-viewport-position)))
	  (set-viewport-position 
	    (case *clim-version*
	      (1 'clim::window-set-viewport-position*)
	      (2 'clim::window-set-viewport-position))))
      (case (eval type)
	((:relative-jump :relative)
	 `(multiple-value-bind (,x ,y) (,viewport-position ,window)
	    (,set-viewport-position ,window ,x (+ ,y ,position))))
	(:absolute
	 `(,set-viewport-position ,window
				  (,viewport-position ,window) ,position))
	(:screenful
	 `(multiple-value-bind (,x ,y) (,viewport-position ,window)
	    (,set-viewport-position ,window 
				    ,x
				    (- ,y (* (clim::bounding-rectangle-height
					       (clim::window-viewport ,window))
					     (signum ,position))))))))))

;;--- Probably there are a few more messages to be converted, these are
;;--- just the convertible ones that I found used in a certain program

;  DW:FIND-AND-SELECT-PROGRAM-WINDOW has no equivalent at present


;;; "Table of Facilities for Defining Presentation Types" and nearby sections

(define-dw-to-clim-conversion dw:with-presentation-input-context
			      ((presentation-type &rest options) (&optional blip-var)
			       non-blip-form &body blip-cases)
  :modification-depth 1000
  :form
  (multiple-value-bind (options error)
      (verify-clim-options 'dw:with-presentation-input-context 'clim::with-input-context
			   nil options
			   '(:inherit)
			   '(:stream :inherit)
			   '(:stream))
    (unless error
      ;; The one option in common has reversed sense and a different name
      (setq options (copy-list options))
      (let ((inherit (getf options :inherit t)))
	(remf options :inherit)
	(unless (eq inherit t)
	  (setq options `(:override ,(if (eq inherit nil) t `(not ,inherit)) ,@options))))
      ;; The issue here is that CLIM destructures the BLIP for you and DW doesn't.
      ;; So find calls to the blip accessor functions and replace them with references
      ;; to the variables holding the destructuring.  Omit blip-var itself from the result.
      (let ((object-var nil)
	    (type-var nil)
	    (gesture-var nil))
	(labels ((fix-case (case)
		   (cons (car case) (mapcar #'fix-form (cdr case))))
		 (fix-form (form)
		   (lt:copyforms #'translate-form form :back-translate-macros t))
		 (translate-form (form kind usage)
		   (declare (ignore usage))
		   (if (and (listp kind) (listp form) (consp (cdr form))
			    (eq (second form) blip-var) (null (cddr form)))
		       (case (first form)
			 (dw:presentation-blip-object
			   (or object-var (setq object-var (intern "BLIP-OBJECT"))))
			 (dw:presentation-blip-presentation-type
			   (or type-var (setq type-var (intern "BLIP-TYPE"))))
			 (dw:presentation-blip-mouse-char
			   (or gesture-var (setq gesture-var (intern "BLIP-GESTURE"))))
			 (otherwise form))
		       form)))
	  (setq blip-cases (mapcar #'fix-case blip-cases))
	  `(clim::with-input-context (,presentation-type ,@options)
				    (,@(when (or object-var type-var gesture-var)
					 `(,object-var
					   ,@(when (or type-var gesture-var)
					       `(,type-var
						 ,@(when gesture-var
						     `(,gesture-var)))))))
		,non-blip-form
	      ,@blip-cases))))))

(define-dw-to-clim-conversion dw:read-standard-token (stream &rest options)
  (multiple-value-bind (options error)
      (verify-clim-options 'dw:read-standard-token 'clim::read-token t options
			   '()
			   '(:quote-p))
    (unless error
      `(clim::read-token ,stream ,@options))))

(define-dw-to-clim-conversion dw:with-accept-blip-chars (chars &body body)
  (case *clim-version*
    (1 `(clim::with-blip-characters ,chars ,@body))
    (2 `(clim::with-delimiter-gestures ,chars ,@body))))

(define-dw-to-clim-conversion dw:with-accept-activation-chars (chars &body body)
  (case *clim-version*
    (1 `(clim::with-activation-characters ,chars ,@body))
    (2 `(clim::with-activation-gestures ,chars ,@body))))

(define-dw-to-clim-conversion dw:complete-input (stream function &rest options)
  (multiple-value-bind (options error)
      (verify-clim-options 'dw:complete-input 'clim::complete-input t options
			   '(:allow-any-input :partial-completers :possibility-printer)
			   '(:force-complete :enable-forced-return :type :parser
			     :compress-choices :compression-delimiter
			     :help-offers-possibilities :initially-display-possibilities
			     :complete-activates :documenter :document)
			   '()
			   '((:help-offers-possibilities :help-displays-possibilities)))
    (unless error
      `(clim::complete-input ,stream ,function ,@options))))

(define-dw-to-clim-conversion dw:complete-from-sequence
			      (sequence stream &rest options
			       &key (name-key #'string) (value-key #'identity)
				    (predicate #'true)
				    (delimiters dw::*standard-completion-delimiters*)
				    partial-completers
			       &allow-other-keys)
  `(clim::complete-input ,stream
			#'(lambda (string action)
			    (clim::complete-from-possibilities
			      string ,sequence ,delimiters
			      :action action
			      :name-key ,name-key :value-key ,value-key
			      :predicate ,predicate))
			:partial-completers ,partial-completers
			,@(let ((unprocessed
				  (si:rem-keywords '(:name-key :value-key :predicate
						     :delimiters :partial-completers)
						   options)))
			    (and unprocessed `(:unprocessed-complete-options ,unprocessed)))))

(define-dw-to-clim-substitution dw:presentation-type-p clim::presentation-type-specifier-p)

(define-dw-to-clim-substitution dw:presentation-object clim::presentation-object)

(define-dw-to-clim-substitution dw:presentation-type clim::presentation-type)

;  DW:PRESENTATION-EQUAL has no equivalent at present

;  DW:CHECK-PRESENTATION-TYPE-ARGUMENT has no equivalent at present

(define-dw-to-clim-conversion dw:with-presentation-type-arguments ((type-name type) &body body)
  `(clim::with-presentation-type-parameters (,type-name ,type)
     (clim::with-presentation-type-options (,type-name ,type)
       ,@body)))

(define-dw-to-clim-substitution dw:with-type-decoded clim::with-presentation-type-decoded)

(define-dw-to-clim-substitution dw:presentation-type-name clim::presentation-type-name)

(define-dw-to-clim-substitution dw::find-accept-history clim::presentation-type-history)

(define-dw-to-clim-conversion dw:presentation-type-default (type)
  (let ((history (intern "HISTORY"))
	(element (intern "ELEMENT")))
    `(let* ((,history (clim::presentation-type-history ,type))
	    (,element (and ,history (clim::yank-from-history ,history))))
       (if ,element
	   (values (clim::presentation-history-element-object ,element)
		   (clim::presentation-history-element-type ,element)
		   t)
	   (values nil nil nil)))))

(define-dw-to-clim-conversion sys:parse-error ()
  (case *clim-version*
    (1 '(clim::parse-error))
    (2 '(clim::simple-parse-error))))

;; The following two are conditions, CLIM uses the same condition for both
(define-dw-to-clim-substitution dw:input-not-of-required-type clim::input-not-of-required-type)
(define-dw-to-clim-substitution dw:object-parsed-not-of-type clim::input-not-of-required-type)

;; CLIM doesn't change characters into blips

(define-dw-to-clim-substitution dw:compare-char-for-accept char-equal)

(define-dw-to-clim-conversion dw:read-char-for-accept (stream)
  `(clim::read-gesture :stream ,stream))

(define-dw-to-clim-conversion dw:unread-char-for-accept (char stream)
  `(clim::unread-gesture ,char :stream ,stream))

(define-dw-to-clim-conversion dw:peek-char-for-accept (stream &optional hang)
  `(clim::read-gesture :stream ,stream :peek-p t
		      ,@(cond ((member hang '(t 't) :test #'equal) nil)
			      ((member hang '(nil 'nil) :test #'equal) `(:timeout 0))
			      (t `(:timeout (and (not ,hang) 0))))))

(define-dw-to-clim-substitution dw::ptypep clim::presentation-typep)

(define-dw-to-clim-substitution dw:presentation-subtypep clim::presentation-subtypep)


;;; Presentation types and ptype abbreviations where the symbols aren't EQ.

(define-dw-to-clim-substitution boolean clim::boolean)
(define-dw-to-clim-substitution sys:expression clim::expression)
(define-dw-to-clim-substitution sys:form clim::form)
(define-dw-to-clim-substitution dw:member-sequence clim::member-sequence)
(define-dw-to-clim-substitution null-or-type clim::null-or-type)
(define-dw-to-clim-substitution pathname clim::pathname)
(define-dw-to-clim-substitution sequence-enumerated clim::sequence-enumerated)
(define-dw-to-clim-substitution subset clim::subset)
(define-dw-to-clim-substitution token-or-type clim::token-or-type)
(define-dw-to-clim-substitution type-or-string clim::type-or-string)

;; The following documented presentation types in the SCL package
;; do not have analogues in CLIM

;  CHARACTER-FACE-OR-STYLE	;[Presentation type]
;  CHARACTER-STYLE		;[Presentation type]
;  CHARACTER-STYLE-FOR-DEVICE   ;[Presentation type]
;  INSTANCE			;[Presentation type]
;  INVERTED-BOOLEAN		;[Presentation type]
;  PACKAGE			;[Presentation type]
;  SYMBOL-NAME			;[Presentation type]

