;;; -*- Mode: LISP; Syntax: Common-lisp; Package: CONVERSION-TOOLS; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Tool for aiding porting of Symbolics Common Lisp applications to other Common Lisps.
;;; In general the strategy is to convert to CLtL Common Lisp when that is possible
;;; and otherwise leave things unconverted, rather than taking advantage of extensions
;;; present in particular Common Lisp implementations.  However, sometimes features
;;; from ANSI Common Lisp are exploited, resulting in a FUTURE-COMMON-LISP: prefix.

;;; This knows about the differences between the SCL package and the CL Developer's
;;; LISP package.  

;;;--- Symbolics features in packages other than SCL perhaps to be added later.
;;;--- Where this calls WARN, it would be nice if the conversion substrate
;;;--- would bind compiler:default-warning-function based on the current section-node.
;;;--- See comment on CONVERT-FALSE-ANSI, need substrate improvement.

;;; This does not convert any DW stuff, that's a separate conversion step.
;;; This does not convert Flavors constructs, that's a separate conversion step.
;;; This does not convert LOOP into something from CLtL since a portable, compatible
;;; LOOP macro is available, and is part of ANSI Common Lisp.
;;; This does not convert DESTRUCTURING-BIND since it's in ANSI Common Lisp and
;;; since it's hard to translate to pure CLtL constructs.
;;; This does not convert functions only intended to be called interactively, like WHO-CALLS.
;;; This does not convert locatives, there is nothing to convert them to.
;;; This does not convert array leaders, there is nothing to convert them to.
;;; For things with area arguments, we just discard the argument on the assumption
;;; that that is the best you can do.
;;; For things like resources, initializations, SCT, etc. no conversion is attempted,
;;; the user should convert by hand or obtain an implementation in the target environment.


(DEFINE-CONVERSION-SET SCL-TO-CL
		       DEFINE-SCL-SUBSTITUTION	;symbol  symbol substitution
		       DEFINE-SCL-CONVERSION	;form  form conversion
		       :FUNARG-MACRO DEFINE-SCL-FUNARG-SUBSTITUTION
		       :MESSAGE-MACRO DEFINE-SCL-MESSAGE-CONVERSION
		       :PRETTY-NAME "Symbolics Common Lisp to portable Common Lisp")

(DEFMACRO DEFINE-SCL-MACRO-CONVERSION (MACRO &OPTIONAL REPLACEMENT)
  `(DEFINE-SCL-CONVERSION ,MACRO (&REST ARGS)
     (VALUES (MACROEXPAND-2 `(,',MACRO ,@ARGS))
	     ,@(WHEN REPLACEMENT
		 `('((,REPLACEMENT ,MACRO)))))))	;hint

(DEFPROP DEFINE-SCL-MACRO-CONVERSION DEFINE-SCL-CONVERSION ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)

;;; This is like MACROEXPAND-1 except it also expands SUBSTs
(DEFUN MACROEXPAND-2 (FORM &OPTIONAL ENV)
  (LT:COPYFORMS (LAMBDA (SUBFORM KIND USAGE)
		  (DECLARE (IGNORE KIND USAGE))
		  (VALUES SUBFORM (NEQ SUBFORM FORM)))
		FORM :EXPAND-SUBSTS T :EXPAND-ALL-MACROS T :ENVIRONMENT ENV))

;;; Returns NIL, rather than original form, if nothing has changed
(DEFUN REMOVE-KEYWORD-ARGUMENTS (FRONT BACK REMOVE &OPTIONAL CONSTANT)
  (WHEN (AND (LISTP BACK) (NULL (CDR (LAST BACK))) (EVENP (LENGTH BACK)))
    (LET ((NEW-BACK (LOOP FOR (KEY VAL) ON BACK BY #'CDDR
			  UNLESS (IF CONSTANT
				     (MEMBER KEY REMOVE)
				     (AND (CONSTANTP KEY)
					  (MEMBER (EVAL KEY) REMOVE)))
			    APPEND `(,KEY ,VAL))))
      (UNLESS (EQUAL NEW-BACK BACK)
	(APPEND FRONT NEW-BACK)))))

(DEFUN KEYWORD-ARGUMENT-PRESENT (KEYWORD BACK &OPTIONAL CONSTANT)
  (DECLARE (VALUES PRESENT VALUE))
  (AND (LISTP BACK) (NULL (CDR (LAST BACK))) (EVENP (LENGTH BACK))
       (LOOP FOR (KEY VAL) ON BACK BY #'CDDR DO
	 (WHEN (IF CONSTANT
		   (EQ KEY KEYWORD)
		   (AND (CONSTANTP KEY) (EQ (EVAL KEY) KEYWORD)))
	   (RETURN-FROM KEYWORD-ARGUMENT-PRESENT
	     (VALUES T VAL))))))

;; Avoid generating gensyms and COMPILER:VARIABLE-INLINABLE declarations
;; so that the generated code will be portable
(DEFMACRO ONCE-ONLY-1 ((&REST VARIABLES) &BODY BODY)
  `(LET ((ONCE-ONLY-TEMPS
	   (LIST ,@(LOOP FOR L IN VARIABLES
			 COLLECT `(INTERN ,(STRING-APPEND "." L "."))))))
     (LET ((FORM (LT:LET-SUBST ONCE-ONLY-TEMPS
			       (LIST ,@VARIABLES)
			       (LET ,(LOOP FOR VAR IN VARIABLES FOR I FROM 0
					   ;;COLLECT `(,VAR (POP ONCE-ONLY-TEMPS))
					   ;;Above fails to substitute constants into lambdas
					   ;;due to a bug that was put into LET-SUBST-DECIDE
					   ;;in 1986.  It's easier just to work around it.
					   COLLECT `(,VAR (IF (CONSTANTP ,VAR) ,VAR
							      (NTH ,I ONCE-ONLY-TEMPS)))
					     )
				 ,@BODY))))
       (IF (AND (CONSP FORM)
		(EQ (FIRST FORM) 'LET)
		(CONSP (THIRD FORM))
		(EQ (FIRST (THIRD FORM)) 'DECLARE)
		(EQ (FIRST (SECOND (THIRD FORM))) 'COMPILER:VARIABLE-INLINABLE))
	   `(LET ,(SECOND FORM) ,@(CDDDR FORM))
	   FORM))))

#||
;; This form produces the agenda for conversion
(LOOP FOR SYMBOL IN (SORT (FUTURE-COMMON-LISP:LOOP FOR SYMBOL BEING
						       THE EXTERNAL-SYMBOLS OF "SCL"
				AS CLTL = (FIND-SYMBOL (STRING SYMBOL) "CLtL")
				UNLESS (EQ CLTL SYMBOL)
				  COLLECT SYMBOL)
			  #'STRING<)
      AS CLTL = (FIND-SYMBOL (STRING SYMBOL) "CLtL")
      DO (FORMAT T "~%; ~S~@[  ~S~]" SYMBOL CLTL))

;; This form produces a list of symbols that exist in both packages but aren't EQ
(LOOP FOR SYMBOL IN (SORT (FUTURE-COMMON-LISP:LOOP FOR SYMBOL BEING
						       THE EXTERNAL-SYMBOLS OF "SCL"
				AS CLTL = (FIND-SYMBOL (STRING SYMBOL) "CLtL")
				WHEN CLTL
				  UNLESS (EQ CLTL SYMBOL)
				    COLLECT SYMBOL)
			  #'STRING<)
      DO (FORMAT T "~%; ~S" SYMBOL))
||#

(DEFINE-SCL-SUBSTITUTION  /=)
(DEFINE-SCL-SUBSTITUTION  <=)
(DEFINE-SCL-SUBSTITUTION  >=)

;;; Overlooked in CL Developer
;;; Strip :AREA and :LOCALIZE because they are just optimizations
;;; :REPLACE is an extension that is hard to emulate
(DEFINE-SCL-CONVERSION ADJOIN (ITEM LIST &REST OPTIONS)
  (MULTIPLE-VALUE-BIND (REPLACE VALUE)
      (KEYWORD-ARGUMENT-PRESENT :REPLACE OPTIONS)
    (WHEN (AND REPLACE (NOT (AND (CONSTANTP VALUE) (NULL (EVAL VALUE)))))
      (WARN "Common Lisp ADJOIN doesn't support :REPLACE.  The converted~@
	     code will probably not do what was intended."))
    (REMOVE-KEYWORD-ARGUMENTS `(ADJOIN ,ITEM ,LIST) OPTIONS '(:AREA :LOCALIZE :REPLACE))))

(DEFINE-SCL-SUBSTITUTION CHAR CHAR/=)
(DEFINE-SCL-SUBSTITUTION CHAR CHAR<=)
(DEFINE-SCL-SUBSTITUTION CHAR CHAR>=)

(DEFINE-SCL-CONVERSION CHAR-FLIPCASE (CHAR)
  (ONCE-ONLY-1 (CHAR)
    `(IF (LOWER-CASE-P ,CHAR)
	 (CHAR-UPCASE ,CHAR)
	 (CHAR-DOWNCASE ,CHAR))))

(DEFINE-SCL-CONVERSION CIRCULAR-LIST (&REST ARGS)
  `(LET ((CIRCULAR-LIST (LIST* ,@ARGS NIL)))
     (SETF (CDR (LAST CIRCULAR-LIST)) CIRCULAR-LIST)
     CIRCULAR-LIST))

(DEFINE-SCL-MACRO-CONVERSION COND-EVERY)
  
;; This :DOCUMENTATION doesn't get used since there is only one choice anyway
(DEFINE-SCL-CONVERSION CONS-IN-AREA (CAR CDR AREA)
  :DOCUMENTATION "Discard the AREA argument"
  :FORM (PROGN
	  (IGNORE AREA)
	  `(CONS ,CAR ,CDR)))

(DEFINE-SCL-CONVERSION COPY-ALIST (ALIST AREA)
  (PROGN
    (IGNORE AREA)
    `(COPY-ALIST ,ALIST)))

;; Ignore AREA since that's the best we can do
;; Ignore FORCE-DOTTED since other Common Lisps don't sport cdr-coding
(DEFINE-SCL-CONVERSION COPY-LIST (LIST AREA &OPTIONAL FORCE-DOTTED)
  (PROGN
    (IGNORE AREA FORCE-DOTTED)
    `(COPY-LIST ,LIST)))

;; Ignore AREA since that's the best we can do
;; Just COPY-LIST since other Common Lisps don't sport cdr-coding
(DEFINE-SCL-CONVERSION COPY-LIST* (LIST AREA)
  (PROGN
    (IGNORE AREA)
    `(COPY-LIST ,LIST)))

;; Ignore AREA since that's the best we can do
(DEFINE-SCL-CONVERSION COPY-SEQ (SEQUENCE AREA)
  (PROGN
    (IGNORE AREA)
    `(COPY-SEQ ,SEQUENCE)))

(DEFINE-SCL-CONVERSION COPY-ARRAY-CONTENTS (FROM TO)
  :NAME CONVERT-COPY-ARRAY-CONTENTS-1
  :DOCUMENTATION "If both arrays are one-dimensional and don't have fill-pointers
and the value returned (T) doesn't matter"
  :FORM (ONCE-ONLY-1 (FROM TO)
	  `(REPLACE ,TO ,FROM)))

(DEFINE-SCL-CONVERSION COPY-ARRAY-CONTENTS (FROM TO)
  :NAME CONVERT-COPY-ARRAY-CONTENTS-2
  :DOCUMENTATION "If the arrays might be multi-dimensional or have fill-pointers,
or if the return value of T matters"
  :FORM (ONCE-ONLY-1 (FROM TO)
	  `(LET ((FROM (MAKE-ARRAY (ARRAY-TOTAL-SIZE ,FROM)
				   :ELEMENT-TYPE (ARRAY-ELEMENT-TYPE ,FROM)
				   :DISPLACED-TO ,FROM))
		 (TO (MAKE-ARRAY (ARRAY-TOTAL-SIZE ,TO)
				 :ELEMENT-TYPE (ARRAY-ELEMENT-TYPE ,TO)
				 :DISPLACED-TO ,TO)))
	     (DECLARE (FUTURE-COMMON-LISP:DYNAMIC-EXTENT FROM TO))
	     (REPLACE TO FROM)
	     T)))

(DEFINE-SCL-CONVERSION COPY-ARRAY-PORTION (FROM-ARRAY FROM-START FROM-END
					   TO-ARRAY TO-START TO-END)
  :NAME CONVERT-COPY-ARRAY-PORTION-1
  :DOCUMENTATION "If both arrays are one-dimensional and don't have fill-pointers, the
lengths of the two array portions are equal, and the value returned (T) doesn't matter"
  :FORM (ONCE-ONLY-1 (FROM-ARRAY FROM-START FROM-END TO-ARRAY TO-START TO-END)
	  `(REPLACE ,TO-ARRAY ,FROM-ARRAY :START1 ,TO-START :END1 ,TO-END
					  :START2 ,FROM-START :END2 ,FROM-END)))

(DEFINE-SCL-CONVERSION COPY-ARRAY-PORTION (FROM-ARRAY FROM-START FROM-END
					   TO-ARRAY TO-START TO-END)
  :NAME CONVERT-COPY-ARRAY-PORTION-2
  :DOCUMENTATION "If the arrays might be multi-dimensional or have fill-pointers,
or if the return value of T matters"
  :FORM (ONCE-ONLY-1 (FROM-ARRAY FROM-START FROM-END TO-ARRAY TO-START TO-END)
	  `(LET ((FROM (MAKE-ARRAY (- ,FROM-END ,FROM-START)
				   :ELEMENT-TYPE (ARRAY-ELEMENT-TYPE ,FROM-ARRAY)
				   :DISPLACED-TO ,FROM-ARRAY
				   :DISPLACED-INDEX-OFFSET ,FROM-START))
		 (TO (MAKE-ARRAY (- ,TO-END ,TO-START)
				 :ELEMENT-TYPE (ARRAY-ELEMENT-TYPE ,TO-ARRAY)
				 :DISPLACED-TO ,TO-ARRAY
				 :DISPLACED-INDEX-OFFSET ,TO-START)))
	     (DECLARE (FUTURE-COMMON-LISP:DYNAMIC-EXTENT FROM TO))
	     (REPLACE TO FROM)
	     (FILL TO (LET ((TYPE (ARRAY-ELEMENT-TYPE TO)))
			(COND ((SUBTYPEP TYPE 'INTEGER) 0)
			      ((SUBTYPEP TYPE 'CHARACTER) #\SPACE)  ;#\Center-dot in Genera
			      (T NIL)))
		   :START (- ,FROM-END ,FROM-START))
	     T)))

(DEFINE-SCL-CONVERSION COSD (DEGREES)
  `(COS (* ,DEGREES (/ PI 180))))

(DEFINE-SCL-CONVERSION DEF (FUNCTION-SPEC &REST DEFINING-FORMS)
  `(PROGN ,@DEFINING-FORMS ',FUNCTION-SPEC))

(DEFINE-SCL-CONVERSION DEFF (FUNCTION-SPEC DEFINITION)
  (IF (SYMBOLP FUNCTION-SPEC)
      `(SETF (SYMBOL-FUNCTION ',FUNCTION-SPEC) ,DEFINITION)
      `(SETF (FUTURE-COMMON-LISP:FDEFINITION ',FUNCTION-SPEC) ,DEFINITION)))

;; Convert to the not quite compatible ANSI CL version of DEFPACKAGE
;; ANSI CL supports these options that SCL does not: :SHADOWING-IMPORT-FROM :INTERN
;; SCL supports these options that ANSI CL does not: :PREFIX-NAME :IMPORT :SHADOWING-IMPORT
;;   :RELATIVE-NAMES :RELATIVE-NAMES-FOR-ME :EXTERNAL-ONLY :NEW-SYMBOL-FUNCTION
;;   :HASH-INHERITED-SYMBOLS :INVISIBLE :COLON-MODE :PREFIX-INTERN-FUNCTION :INCLUDE
;;   :SAFEGUARDED :SYNTAX
;; ANSI CL allows symbols or strings to be used, symbols' packages never matter here
(DEFINE-SCL-CONVERSION DEFPACKAGE (NAME &REST OPTIONS)
  `(FUTURE-COMMON-LISP:DEFPACKAGE ,NAME
     ,@(LOOP FOR OPTION IN OPTIONS
	     APPEND (MULTIPLE-VALUE-BIND (KEY ARGS)
			(IF (ATOM OPTION)
			    (VALUES OPTION NIL)
			    (VALUES (CAR OPTION) (CDR OPTION)))
		      (CASE KEY
			((:NICKNAMES :USE :SHADOW :EXPORT :SIZE)
			 (LIST OPTION))
			((:IMPORT-FROM)
			 (IF (LISTP (FIRST ARGS))
			     (LOOP FOR ARG IN ARGS
				   COLLECT `(:IMPORT-FROM ,@ARG))
			     (LIST OPTION)))
			((:IMPORT :SHADOWING-IMPORT)
			 (LET ((ALIST NIL))
			   (DOLIST (ARG ARGS)
			     (LET* ((PACKAGE (SYMBOL-PACKAGE ARG))
				    (ELEM (ASSOC PACKAGE ALIST)))
			       (UNLESS ELEM
				 (PUSH (SETQ ELEM (NCONS PACKAGE)) ALIST))
			       (PUSH ARG (CDR ELEM))))
			   (LOOP FOR ELEM IN (NREVERSE ALIST)
				 COLLECT `(,(IF (EQ KEY ':IMPORT)
						:IMPORT-FROM
						:SHADOWING-IMPORT-FROM)
					   ,(INTERN (PACKAGE-NAME (CAR ELEM)))
					   ,@(NREVERSE (CDR ELEM))))))
			(OTHERWISE
			  (WARN "I don't know how to convert the ~S DEFPACKAGE option."
				KEY)
			  (LIST OPTION)))))))

(DEFINE-SCL-CONVERSION DEFPROP (SYMBOL VALUE INDICATOR)
  `(SETF (GET ',SYMBOL ',INDICATOR) ',VALUE))

(DEFINE-SCL-MACRO-CONVERSION DEFSUBST DEFUN)

;;; :REPLACE is an extension that is hard to emulate
(DEFINE-SCL-CONVERSION DELETE-DUPLICATES (SEQUENCE &REST OPTIONS)
  (MULTIPLE-VALUE-BIND (REPLACE VALUE)
      (KEYWORD-ARGUMENT-PRESENT :REPLACE OPTIONS)
    (WHEN (AND REPLACE (NOT (AND (CONSTANTP VALUE) (NULL (EVAL VALUE)))))
      (WARN "Common Lisp DELETE-DUPLICATES doesn't support :REPLACE.  The converted~@
	     code will probably not do what was intended."))
    (REMOVE-KEYWORD-ARGUMENTS `(DELETE-DUPLICATES ,SEQUENCE) OPTIONS '(:REPLACE))))

(DEFINE-SCL-MACRO-CONVERSION DEPOSIT-BYTE)

(DEFINE-SCL-FUNARG-SUBSTITUTION FALSE
  :NAME CONVERT-FALSE-CLTL
  :DOCUMENTATION "Using CLtL Common Lisp, but making a new function each time"
  :NEW-FUNCTION (LAMBDA (&REST IGNORE) NIL))

#+IGNORE  ;Unfortunately this does not work, because the #' is still there
(DEFINE-SCL-FUNARG-SUBSTITUTION FALSE
  :NAME CONVERT-FALSE-ANSI
  :DOCUMENTATION "Using ANSI Common Lisp"
  :NEW-FUNCTION (FUTURE-COMMON-LISP:CONSTANTLY NIL))

;;; This only matches IF forms with two or more ELSE clauses, the Symbolics extension
(DEFINE-SCL-CONVERSION IF (CONDITION THEN ELSE MORE-ELSE &REST YET-MORE-ELSE)
  `(IF ,CONDITION ,THEN (PROGN ,ELSE ,MORE-ELSE ,@YET-MORE-ELSE)))

;;;--- This one is a real problem, since often when IGNORE is the CAR of a list
;;;--- that list is not a form.  It's better not to try to convert this.
;;;(DEFINE-SCL-MACRO-CONVERSION IGNORE)

(DEFINE-SCL-CONVERSION INTERN-SOFT (SYM &REST ARGS)
  `(FIND-SYMBOL (STRING ,SYM) ,@ARGS))

(DEFINE-SCL-CONVERSION LIST*-IN-AREA (AREA &REST ELEMENTS)
  (PROGN
    (IGNORE AREA)
    `(LIST* ,@ELEMENTS)))

(DEFINE-SCL-CONVERSION LIST-IN-AREA (AREA &REST ELEMENTS)
  (PROGN
    (IGNORE AREA)
    `(LIST ,@ELEMENTS)))

(DEFINE-SCL-MACRO-CONVERSION LOAD-BYTE)

(DEFINE-SCL-CONVERSION LSH (NUMBER COUNT)
  (COND ((CONSTANTP COUNT)
	 (SETQ COUNT (EVAL COUNT))
	 (COND ((ZEROP COUNT) NUMBER)
	       ((> COUNT 31) (IF (CONSTANTP NUMBER) 0 `(PROGN ,NUMBER 0)))
	       ((< COUNT -31) `(- (LDB (BYTE 1 31) ,NUMBER)))
	       ((MINUSP COUNT) `(LDB (BYTE ,(+ 32 COUNT) ,(- COUNT)) ,NUMBER))
	       (T (ONCE-ONLY-1 (NUMBER)
		    `(DPB ,NUMBER (BYTE ,(- 31 COUNT) ,COUNT)
			  (- (LDB (BYTE 1 ,(- 31 COUNT)) ,NUMBER)))))))
	(T
	 (ONCE-ONLY-1 (NUMBER COUNT)
	   `(COND ((ZEROP ,COUNT) ,NUMBER)
		  ((> ,COUNT 31) 0)
		  ((< ,COUNT -31) (- (LDB (BYTE 1 31) ,NUMBER)))
		  ((MINUSP ,COUNT) (LDB (BYTE (+ 32 ,COUNT) (- ,COUNT)) ,NUMBER))
		  (T (DPB ,NUMBER (BYTE (- 31 ,COUNT) ,COUNT)
			  (- (LDB (BYTE 1 (- 31 ,COUNT)) ,NUMBER)))))))))

;; Can't use DEFINE-SCL-MACRO-CONVERSION because the expansion isn't portable
(DEFINE-SCL-CONVERSION MACRO (NAME (FORM &OPTIONAL ENVIRONMENT) &BODY BODY)
  `(DEFMACRO ,NAME (&WHOLE ,FORM ,@(AND ENVIRONMENT `(&ENVIRONMENT ,ENVIRONMENT)))
     ,@BODY))

(DEFINE-SCL-CONVERSION MAKE-ARRAY (DIMENSIONS &REST OPTIONS)
  (PROGN
    (DOLIST (KEYWORD '(:AREA :DISPLACED-CONFORMALLY :LEADER-LENGTH
		       :LEADER-LIST :NAMED-STRUCTURE-SYMBOL))
      (MULTIPLE-VALUE-BIND (PRESENT VALUE)
	  (KEYWORD-ARGUMENT-PRESENT KEYWORD OPTIONS)
	(WHEN (AND PRESENT (NOT (AND (CONSTANTP VALUE) (NULL (EVAL VALUE)))))
	  (WARN "Common Lisp MAKE-ARRAY doesn't support ~S.  The converted~@
	         code will probably not do what was intended." KEYWORD))))
    (REMOVE-KEYWORD-ARGUMENTS `(MAKE-ARRAY ,DIMENSIONS) OPTIONS
			      '(:AREA :DISPLACED-CONFORMALLY :LEADER-LENGTH
				:LEADER-LIST :NAMED-STRUCTURE-SYMBOL))))

;;; CL Developer forgets to check the :TEST
(DEFINE-SCL-CONVERSION MAKE-HASH-TABLE (&REST OPTIONS)
  (PROGN
    (DOLIST (KEYWORD '(:AREA :ENTRY-SIZE :GC-PROTECT-VALUES :GROWTH-FACTOR :GROWTH-THRESHOLD
		       :HASH-FUNCTION :IGNORE-GC :INITIAL-CONTENTS :LOCKING :MUTATING
		       :NUMBER-OF-VALUES :OPTIMIZATIONS :REHASH-AFTER-FULL-GC
		       :REHASH-BEFORE-COLD :STORE-HASH-CODE))
      (MULTIPLE-VALUE-BIND (PRESENT VALUE)
	  (KEYWORD-ARGUMENT-PRESENT KEYWORD OPTIONS)
	(WHEN PRESENT
	  (IGNORE VALUE)
	  (WARN "Common Lisp MAKE-HASH-TABLE doesn't support ~S.  The converted~@
	         code will probably not do what was intended." KEYWORD))))
    (MULTIPLE-VALUE-BIND (PRESENT TEST)
	(KEYWORD-ARGUMENT-PRESENT :TEST OPTIONS)
      (WHEN PRESENT
	(UNLESS (MEMBER TEST '('EQ 'EQL 'EQUAL #'EQ #'EQL #'EQUAL) :TEST #'EQUAL)
	  ;; Could also check for EQUALP, added by ANSI Common Lisp
	  (WARN "Common Lisp MAKE-HASH-TABLE doesn't support ~S ~S." :TEST TEST))))
    (REMOVE-KEYWORD-ARGUMENTS `(MAKE-HASH-TABLE) OPTIONS
		     '(:AREA :ENTRY-SIZE :GC-PROTECT-VALUES :GROWTH-FACTOR :GROWTH-THRESHOLD
		       :HASH-FUNCTION :IGNORE-GC :INITIAL-CONTENTS :LOCKING :MUTATING
		       :NUMBER-OF-VALUES :OPTIMIZATIONS :REHASH-AFTER-FULL-GC
		       :REHASH-BEFORE-COLD :STORE-HASH-CODE))))

(DEFINE-SCL-CONVERSION MAKE-LIST (SIZE &REST OPTIONS)
  (REMOVE-KEYWORD-ARGUMENTS `(MAKE-LIST ,SIZE) OPTIONS '(:AREA)))

(DEFINE-SCL-CONVERSION MAKE-RASTER-ARRAY (WIDTH HEIGHT &REST OPTIONS)
  (ONCE-ONLY-1 (WIDTH HEIGHT)
    `(MAKE-ARRAY (LIST ,HEIGHT ,WIDTH) ,@OPTIONS)))

(DEFINE-SCL-CONVERSION MAKE-SEQUENCE (TYPE SIZE &REST OPTIONS)
  (REMOVE-KEYWORD-ARGUMENTS `(MAKE-SEQUENCE ,TYPE ,SIZE) OPTIONS '(:AREA)))

(DEFINE-SCL-CONVERSION MAKE-STRING (SIZE &REST OPTIONS)
  (REMOVE-KEYWORD-ARGUMENTS `(MAKE-STRING ,SIZE) OPTIONS '(:AREA :ELEMENT-TYPE)))

;; Ignore PERMANENT-P since it just controls what area it goes into
(DEFINE-SCL-CONVERSION MAKE-SYMBOL (NAME PERMANENT-P)
  (PROGN
    (IGNORE PERMANENT-P)
    `(MAKE-SYMBOL ,NAME)))

; MACROEXPAND-2 doesn't work for MAXF, MINF, because we lose the SETF
; and see the expansion of the SETF instead, which is not portable
; So let's instead assume we can get away with generating code that might
; be wrong in general because of multiple evaluation
(DEFINE-SCL-CONVERSION MAXF (REFERENCE &REST MAXIMA)
  `(SETF ,REFERENCE (MAX ,REFERENCE ,@MAXIMA)))

(DEFINE-SCL-CONVERSION MINF (REFERENCE &REST MINIMA)
  `(SETF ,REFERENCE (MIN ,REFERENCE ,@MINIMA)))

;; CLtL doesn't allow NIL among VARS
(DEFINE-SCL-CONVERSION MULTIPLE-VALUE-BIND (VARS VALUE &BODY BODY)
  (WHEN (MEMBER NIL VARS)
    (SETQ VARS (COPY-LIST VARS))
    (LOOP WHILE (AND VARS (NULL (CAR (LAST VARS)))) DO	;Strip trailing NILs
      (SETQ VARS (NBUTLAST VARS)))
    (LET ((IGNORES (LOOP WITH I = 0 FOR V ON VARS
			 WHEN (NULL (CAR V))
			   COLLECT (SETF (CAR V)
					 (IF (ZEROP I) 'IGNORE (FINTERN "IGNORE-~D" I)))
			   AND DO (INCF I))))
      `(MULTIPLE-VALUE-BIND ,VARS ,VALUE
	 ,@(WHEN IGNORES `((DECLARE (IGNORE ,@IGNORES))))
	 ,@BODY))))

;; CLtL doesn't allow NIL among VARS
(DEFINE-SCL-CONVERSION MULTIPLE-VALUE-SETQ (VARS VALUE)
  (WHEN (MEMBER NIL VARS)
    (SETQ VARS (COPY-LIST VARS))
    (LOOP WHILE (AND VARS (NULL (CAR (LAST VARS)))) DO	;Strip trailing NILs
      (SETQ VARS (NBUTLAST VARS)))
    (LET ((IGNORES (LOOP WITH I = 0 FOR V ON VARS
			 WHEN (NULL (CAR V))
			   COLLECT (SETF (CAR V)
					 (IF (ZEROP I) 'IGNORE (FINTERN "IGNORE-~D" I)))
			   AND DO (INCF I))))
      (IF (NULL IGNORES)
	  `(MULTIPLE-VALUE-SETQ ,VARS ,VALUE)
	  `(LET ,IGNORES
	     (MULTIPLE-VALUE-SETQ ,VARS ,VALUE))))))

(DEFINE-SCL-CONVERSION NCONS (X)
  `(CONS ,X NIL))

(DEFINE-SCL-CONVERSION NCONS-IN-AREA (X AREA)
  (PROGN
    (IGNORE AREA)
    `(CONS ,X NIL)))

(DEFINE-SCL-MACRO-CONVERSION NEQ EQ)

(DEFINE-SCL-MACRO-CONVERSION NLISTP LISTP)

(DEFINE-SCL-CONVERSION NSTRING-FLIPCASE (STRING &REST START-END)
  (ONCE-ONLY-1 (STRING)
    (DESTRUCTURING-BIND (&KEY (START 0) (END NIL)) START-END	;ignoring order of evaluation
      `(DO ((I ,START (1+ I))
	    (CHAR)
	    (N ,(IF END
		    `(OR ,END (LENGTH ,STRING))
		    `(LENGTH ,STRING))))
	   ((>= I N) ,STRING)
	 (SETQ CHAR (AREF ,STRING I))
	 (SETF (AREF ,STRING I) (IF (LOWER-CASE-P CHAR)
				    (CHAR-UPCASE CHAR)
				    (CHAR-DOWNCASE CHAR)))))))

(DEFINE-SCL-CONVERSION NSUBSTRING (STRING FROM &OPTIONAL TO AREA)
  (LET ((REAL-TO TO))
    (ONCE-ONLY-1 (STRING FROM TO)
      (IGNORE AREA)
      `(MAKE-ARRAY (- ,(IF REAL-TO `(OR ,TO (LENGTH ,STRING)) `(LENGTH ,STRING)) ,FROM)
		   :ELEMENT-TYPE 'STRING-CHAR
		   :DISPLACED-TO ,STRING
		   :DISPLACED-INDEX-OFFSET ,FROM))))

(DEFINE-SCL-MACRO-CONVERSION NSYMBOLP SYMBOLP)

;; Cheat like hell, or in other words, assume the compiler optimizes out temporary variables
;; It looks like for this to be really usable we will need to instruct
;; FORM-CORRESPONDENCE-REPLACEMENT to turn SI:XR-BQ-LIST* back into backquote
(DEFINE-SCL-CONVERSION ONCE-ONLY ((&REST VARIABLES) &BODY BODY)
  (LET ((ENV (MEMBER '&ENVIRONMENT VARIABLES)))
    (WHEN ENV
      (SETQ VARIABLES (APPEND (LDIFF VARIABLES ENV) (CDDR ENV))))
    (LET ((ONCE-ONLY-TEMPS (LOOP FOR L IN VARIABLES
				 COLLECT (INTERN (STRING-APPEND "." L ".")))))
      ``(LET ,',(LOOP FOR TEMP IN ONCE-ONLY-TEMPS AND VAR IN VARIABLES
		      COLLECT `(,TEMP ,VAR))
	  ,@',(LOOP FOR FORM IN BODY
		    COLLECT (LT:COPYFORMS
			      #'(LAMBDA (SUBFORM KIND USAGE)
				  (DECLARE (IGNORE USAGE))
				  (IF (AND (MEMBER SUBFORM VARIABLES)
					   (MEMBER KIND 'LT:(SET SYMEVAL))
					   (NOT (MEMBER SUBFORM
							LT:*MAPFORMS-BOUND-VARIABLES*)))
				      (NTH (POSITION SUBFORM VARIABLES) ONCE-ONLY-TEMPS)
				      SUBFORM))
			      FORM :BOUND-VARIABLES NIL :BACK-TRANSLATE-MACROS T))))))

;; First argument can be a package, a string, or a symbol
;; Doesn't try to convert the more complex cases involving the third and fourth arguments
;; Doesn't try to convert CREATE-P values of :ASK and T
(DEFINE-SCL-CONVERSION PKG-FIND-PACKAGE (NAME &OPTIONAL (CREATE-P :ERROR))
  (BLOCK CONVERT
    (WHEN (CONSTANTP CREATE-P)
      (SETQ CREATE-P (EVAL CREATE-P))
      (ONCE-ONLY-1 (NAME)
	`(IF (PACKAGEP ,NAME) ,NAME
	     ,(CASE CREATE-P
		((:FIND) `(FIND-PACKAGE ,NAME))
		((:ERROR NIL) `(OR (FIND-PACKAGE ,NAME)
				   (ERROR "Package ~A not found" ,NAME)))
		(OTHERWISE (RETURN-FROM CONVERT NIL))))))))

(DEFINE-SCL-CONVERSION PROG (VARS-AND-VALS &REST BODY)
  (CONVERT-NAMED-PROG 'PROG VARS-AND-VALS BODY))

(DEFINE-SCL-CONVERSION PROG* (VARS-AND-VALS &REST BODY)
  (CONVERT-NAMED-PROG 'PROG* VARS-AND-VALS BODY))

;; See SI:EXPAND-PROG
(DEFUN CONVERT-NAMED-PROG (PROG VARS-AND-VALS BODY)
  (WHEN (NOT (CL:LISTP VARS-AND-VALS))		;if this is a named prog
    (LET ((BLOCK-NAME VARS-AND-VALS))
      (SETQ VARS-AND-VALS (POP BODY))
      (MULTIPLE-VALUE-BIND (DECLARATIONS REAL-BODY)
	  (SI:FIND-BODY-DECLARATIONS BODY NIL)
	;; This craziness implements "invisible" (actually visible) blocks.
	(IF (BLOCK INVISIBLE
	      (DOLIST (DCLS DECLARATIONS)
		(WHEN (AND (LISTP DCLS)
			   (EQ (FIRST DCLS) 'DECLARE))
		  (DOLIST (DCL (REST DCLS))
		    (WHEN (AND (LISTP DCL)
			       (SYMBOLP (FIRST DCL))
			       (STRING-EQUAL (FIRST DCL) "INVISIBLE-BLOCK"))
		      (RETURN-FROM INVISIBLE (SECOND DCL))))))
	      (EQ BLOCK-NAME T))
	    ;; The usual block name of NIL is suppressed
	    `(BLOCK ,BLOCK-NAME
	       (,(IF (EQ PROG 'PROG) 'LET 'LET*) ,VARS-AND-VALS
		,@DECLARATIONS
		(TAGBODY
		  ,@REAL-BODY)))
	    ;; Normal case of named-prog
	    `(BLOCK ,BLOCK-NAME
	       (,PROG ,VARS-AND-VALS ,@BODY)))))))

;; :AREA and :LOCALIZE are just optimizations, and everyone knows Unix workstations
;; are infinitely fast and never take page faults, so just discard them
(DEFINE-SCL-CONVERSION PUSH (ITEM LIST &REST OPTIONS)
  (REMOVE-KEYWORD-ARGUMENTS `(PUSH ,ITEM ,LIST) OPTIONS '(:AREA :LOCALIZE) T))

;;; This is a macro but the keyword options are evaluated as for a function
;;; Strip :AREA and :LOCALIZE because they are just optimizations
;;; :REPLACE is an extension that is hard to emulate
(DEFINE-SCL-CONVERSION PUSHNEW (ITEM LIST &REST OPTIONS)
  (MULTIPLE-VALUE-BIND (REPLACE VALUE)
      (KEYWORD-ARGUMENT-PRESENT :REPLACE OPTIONS)
    (WHEN (AND REPLACE (NOT (AND (CONSTANTP VALUE) (NULL (EVAL VALUE)))))
      (WARN "Common Lisp PUSHNEW doesn't support :REPLACE.  The converted~@
	     code will probably not do what was intended."))
    (REMOVE-KEYWORD-ARGUMENTS `(PUSHNEW ,ITEM ,LIST) OPTIONS '(:AREA :LOCALIZE :REPLACE))))

(DEFINE-SCL-MACRO-CONVERSION RASTER-AREF AREF)

(DEFINE-SCL-CONVERSION RASTER-INDEX-OFFSET (RASTER X Y)
  (ONCE-ONLY-1 (X Y)
    `(ARRAY-ROW-MAJOR-INDEX ,RASTER ,Y ,X)))

(DEFINE-SCL-CONVERSION RASTER-WIDTH-AND-HEIGHT-TO-MAKE-ARRAY-DIMENSIONS (WIDTH HEIGHT)
  (ONCE-ONLY-1 (WIDTH HEIGHT)
    `(LIST ,HEIGHT ,WIDTH)))

;CL Developer bug, doesn't enforce #args for RETURN even though it's commented to
;On the other hand, SCL's RETURN no longer accepts more than one argument anyway
;so we don't need any conversion for RETURN and RETURN-FROM

(DEFINE-SCL-CONVERSION ROT (NUMBER COUNT)
  (COND ((CONSTANTP COUNT)
	 (SETQ COUNT (MOD (EVAL COUNT) 32))
	 (IF (ZEROP COUNT) NUMBER
	     (ONCE-ONLY-1 (NUMBER)
	       `(DPB (LDB (BYTE ,COUNT ,(- 32 COUNT)) ,NUMBER)
		     (BYTE ,COUNT 0)
		     ,(IF (< COUNT 31)
			  `(DPB ,NUMBER (BYTE ,(- 31 COUNT) ,COUNT)
				(- (LDB (BYTE 1 ,(- 31 COUNT)) ,NUMBER)))
			  `(- (LDB (BYTE 1 ,(- 31 COUNT)) ,NUMBER)))))))
	(T
	 (ONCE-ONLY-1 (NUMBER)
	   `(LET ((COUNT (MOD ,COUNT 32)))
	      (IF (ZEROP COUNT) ,NUMBER
		  (DPB (LDB (BYTE COUNT (- 32 COUNT)) ,NUMBER)
		       (BYTE COUNT 0)
		       ;; This assumes a byte-size of zero is allowed.  CLtL doesn't say.
		       (DPB ,NUMBER (BYTE (- 31 COUNT) COUNT)
			    (- (LDB (BYTE 1 (- 31 COUNT)) ,NUMBER))))))))))

(DEFINE-SCL-CONVERSION SELECT (TEST-OBJECT &BODY CLAUSES)
  (VALUES (MACROEXPAND-2 `(SELECTOR ,TEST-OBJECT EQL ,@CLAUSES))))

(DEFINE-SCL-MACRO-CONVERSION SELECTOR)

;; Expand twice to avoid asking the user about COND-EVERY
(DEFINE-SCL-CONVERSION SELECTQ-EVERY (OBJ &BODY CLAUSES)
  (LET ((FORM (MACROEXPAND-2 `(SELECTQ-EVERY ,OBJ ,@CLAUSES))))
    (ECASE (FIRST FORM)
      (LET `(LET ,(SECOND FORM) ,@(MAPCAR #'MACROEXPAND-2 (CDDR FORM))))
      (COND-EVERY (VALUES (MACROEXPAND-2 FORM))))))

(DEFINE-SCL-CONVERSION SIND (DEGREES)
  `(SIN (* ,DEGREES (/ PI 180))))

#+IGNORE ;; I guess for Cloe we'd rather leave it as STACK-LET
(DEFINE-SCL-CONVERSION STACK-LET (BINDINGS &BODY BODY)
  `(LET ,BINDINGS
     (DECLARE (FUTURE-COMMON-LISP:DYNAMIC-EXTENT ,@(MAPCAR #'FIRST BINDINGS)))
     ,@BODY))

#+IGNORE ;; I guess for Cloe we'd rather leave it as STACK-LET*
(DEFINE-SCL-CONVERSION STACK-LET* (BINDINGS &BODY BODY)
  `(LET* ,BINDINGS
     (DECLARE (FUTURE-COMMON-LISP:DYNAMIC-EXTENT ,@(MAPCAR #'FIRST BINDINGS)))
     ,@BODY))

(DEFINE-SCL-SUBSTITUTION STRING STRING/=)
(DEFINE-SCL-SUBSTITUTION STRING STRING<=)
(DEFINE-SCL-SUBSTITUTION STRING STRING>=)

(DEFINE-SCL-CONVERSION STRING-APPEND (&REST STRINGS)
  :NAME STRING-APPEND-GENERAL
  :DOCUMENTATION "If the arguments could be strings or symbols"
  :FORM `(CONCATENATE 'STRING ,@(MAPCAR #'(LAMBDA (X) `(STRING ,X)) STRINGS)))

(DEFINE-SCL-CONVERSION STRING-APPEND (&REST STRINGS)
  :NAME STRING-APPEND-OPTIMIZED
  :DOCUMENTATION "If the arguments are guaranteed to be strings"
  :FORM `(CONCATENATE 'STRING ,@STRINGS))

(DEFINE-SCL-CONVERSION STRING-FLIPCASE (STRING &REST START-END)
  (PROGN
    (IF START-END
	(DESTRUCTURING-BIND (&KEY (START 0) (END NIL)) START-END ;ignoring order of evaluation
	  (SETQ STRING `(SUBSEQ ,(STRING STRING) ,START ,@(AND END (LIST END)))))
	(SETQ STRING `(STRING ,STRING)))
    `(MAP 'STRING #'(LAMBDA (CHAR) (IF (LOWER-CASE-P CHAR)
				       (CHAR-UPCASE CHAR)
				       (CHAR-DOWNCASE CHAR)))
		  ,STRING)))

(DEFINE-SCL-CONVERSION STRING-LENGTH (STRING)
  :NAME STRING-LENGTH-GENERAL
  :DOCUMENTATION "If the argument could be a string or a symbol"
  :FORM `(LENGTH (STRING ,STRING)))

(DEFINE-SCL-CONVERSION STRING-LENGTH (STRING)
  :NAME STRING-LENGTH-OPTIMIZED
  :DOCUMENTATION "If the argument is guaranteed to be a string"
  :FORM `(LENGTH ,STRING))

;; Signals an error if the argument is not a string, so it's probably safe to
;; convert unconditionally into a general sequence function
(DEFINE-SCL-CONVERSION STRING-NREVERSE (STRING &REST OPTIONS)
  (IF (NULL OPTIONS)
      `(NREVERSE ,STRING)
      (ONCE-ONLY-1 (STRING)
	`((LAMBDA (&KEY (START 0) (END NIL))
	    (DO ((I START (1+ I))
		 (J (1- (OR END (LENGTH ,STRING))) (1- J)))
		((>= I J) ,STRING)
	      (ROTATEF (AREF ,STRING I) (AREF ,STRING J))))
	  ,@OPTIONS))))
					
(DEFINE-SCL-CONVERSION STRING-REVERSE (STRING &REST OPTIONS)
  :NAME STRING-REVERSE-GENERAL
  :DOCUMENTATION "If the argument could be a string or a symbol"
  :FORM (IF (NULL OPTIONS)
	    `(REVERSE (STRING ,STRING))
	    (DESTRUCTURING-BIND (&KEY (START 0) (END NIL END-P)) OPTIONS
	      `(NREVERSE (SUBSEQ (STRING ,STRING) ,START ,@(AND END-P `(,END)))))))
			
(DEFINE-SCL-CONVERSION STRING-REVERSE (STRING &REST OPTIONS)
  :NAME STRING-REVERSE-OPTIMIZED
  :DOCUMENTATION "If the argument is guaranteed to be a string"
  :FORM (IF (NULL OPTIONS)
	    `(REVERSE ,STRING)
	    (DESTRUCTURING-BIND (&KEY (START 0) (END NIL END-P)) OPTIONS
	      `(NREVERSE (SUBSEQ ,STRING ,START ,@(AND END-P `(,END)))))))

(DEFINE-SCL-CONVERSION STRING-SEARCH (KEY STRING &REST OPTIONS)
  :NAME STRING-SEARCH-GENERAL
  :DOCUMENTATION "If the arguments could be strings, symbols, or characters"
  :FORM `(SEARCH (STRING ,KEY) (STRING ,STRING) :TEST #'CHAR-EQUAL ,@OPTIONS))

(DEFINE-SCL-CONVERSION STRING-SEARCH (KEY STRING &REST OPTIONS)
  :NAME STRING-SEARCH-OPTIMIZED
  :DOCUMENTATION "If the arguments are guaranteed to be strings"
  :FORM `(SEARCH ,KEY ,STRING :TEST #'CHAR-EQUAL ,@OPTIONS))

(DEFINE-SCL-CONVERSION STRING-SEARCH (KEY STRING &REST OPTIONS)
  :NAME STRING-SEARCH-CHARACTER
  :DOCUMENTATION "If the first argument is guaranteed to be a character and the
second argument is guaranteed to be a string"
  :FORM (UNLESS (OR (KEYWORD-ARGUMENT-PRESENT :START1 OPTIONS)
		    (KEYWORD-ARGUMENT-PRESENT :END1 OPTIONS))
	  `(POSITION ,KEY ,STRING :TEST #'CHAR-EQUAL
		     ,@(LOOP FOR (KEY VAL) ON OPTIONS BY #'CDDR
			     COLLECT (IF (CONSTANTP KEY)
					 (CASE (EVAL KEY)
					   (:START2 :START)
					   (:END2 :END)
					   (OTHERWISE KEY))
					 KEY)
			     COLLECT VAL))))

(DEFINE-SCL-CONVERSION STRING-SEARCH-EXACT (KEY STRING &REST OPTIONS)
  :NAME STRING-SEARCH-EXACT-GENERAL
  :DOCUMENTATION "If the arguments could be strings, symbols, or characters"
  :FORM `(SEARCH (STRING ,KEY) (STRING ,STRING) ,@OPTIONS))

(DEFINE-SCL-CONVERSION STRING-SEARCH-EXACT (KEY STRING &REST OPTIONS)
  :NAME STRING-SEARCH-EXACT-OPTIMIZED
  :DOCUMENTATION "If the arguments are guaranteed to be strings"
  :FORM `(SEARCH ,KEY ,STRING ,@OPTIONS))

(DEFINE-SCL-CONVERSION STRING-SEARCH-EXACT (KEY STRING &REST OPTIONS)
  :NAME STRING-SEARCH-EXACT-CHARACTER
  :DOCUMENTATION "If the first argument is guaranteed to be a character and the
second argument is guaranteed to be a string"
  :FORM (UNLESS (OR (KEYWORD-ARGUMENT-PRESENT :START1 OPTIONS)
		    (KEYWORD-ARGUMENT-PRESENT :END1 OPTIONS))
	  `(POSITION ,KEY ,STRING
		     ,@(LOOP FOR (KEY VAL) ON OPTIONS BY #'CDDR
			     COLLECT (IF (CONSTANTP KEY)
					 (CASE (EVAL KEY)
					   (:START2 :START)
					   (:END2 :END)
					   (OTHERWISE KEY))
					 KEY)
			     COLLECT VAL))))

(DEFINE-SCL-CONVERSION STRING-SEARCH-CHAR (KEY STRING &REST OPTIONS)
  :NAME STRING-SEARCH-CHAR-GENERAL
  :DOCUMENTATION "If the second argument could be a string or a symbol"
  :FORM `(POSITION ,KEY (STRING ,STRING) :TEST #'CHAR-EQUAL ,@OPTIONS))

(DEFINE-SCL-CONVERSION STRING-SEARCH-CHAR (KEY STRING &REST OPTIONS)
  :NAME STRING-SEARCH-CHAR-OPTIMIZED
  :DOCUMENTATION "If the second argument is guaranteed to be a string"
  :FORM `(POSITION ,KEY ,STRING :TEST #'CHAR-EQUAL ,@OPTIONS))

(DEFINE-SCL-CONVERSION STRING-SEARCH-EXACT-CHAR (KEY STRING &REST OPTIONS)
  :NAME STRING-SEARCH-EXACT-CHAR-GENERAL
  :DOCUMENTATION "If the second argument could be a string or a symbol"
  :FORM `(POSITION ,KEY (STRING ,STRING) ,@OPTIONS))

(DEFINE-SCL-CONVERSION STRING-SEARCH-EXACT-CHAR (KEY STRING &REST OPTIONS)
  :NAME STRING-SEARCH-EXACT-CHAR-OPTIMIZED
  :DOCUMENTATION "If the second argument is guaranteed to be a string"
  :FORM `(POSITION ,KEY ,STRING ,@OPTIONS))

(DEFINE-SCL-CONVERSION STRING-SEARCH-NOT-CHAR (KEY STRING &REST OPTIONS)
  :NAME STRING-SEARCH-NOT-CHAR-GENERAL
  :DOCUMENTATION "If the second argument could be a string or a symbol"
  :FORM `(POSITION ,KEY (STRING ,STRING) :TEST-NOT #'CHAR-EQUAL ,@OPTIONS))

(DEFINE-SCL-CONVERSION STRING-SEARCH-NOT-CHAR (KEY STRING &REST OPTIONS)
  :NAME STRING-SEARCH-NOT-CHAR-OPTIMIZED
  :DOCUMENTATION "If the second argument is guaranteed to be a string"
  :FORM `(POSITION ,KEY ,STRING :TEST-NOT #'CHAR-EQUAL ,@OPTIONS))

(DEFINE-SCL-CONVERSION STRING-SEARCH-NOT-EXACT-CHAR (KEY STRING &REST OPTIONS)
  :NAME STRING-SEARCH-NOT-EXACT-CHAR-GENERAL
  :DOCUMENTATION "If the second argument could be a string or a symbol"
  :FORM `(POSITION ,KEY (STRING ,STRING) :TEST-NOT #'EQL ,@OPTIONS))

(DEFINE-SCL-CONVERSION STRING-SEARCH-NOT-EXACT-CHAR (KEY STRING &REST OPTIONS)
  :NAME STRING-SEARCH-NOT-EXACT-CHAR-OPTIMIZED
  :DOCUMENTATION "If the second argument is guaranteed to be a string"
  :FORM `(POSITION ,KEY ,STRING :TEST-NOT #'EQL ,@OPTIONS))

(DEFINE-SCL-CONVERSION STRING-SEARCH-SET (CHAR-SET STRING &REST OPTIONS)
  :NAME STRING-SEARCH-SET-GENERAL
  :DOCUMENTATION "If the second argument could be a string or a symbol"
  :FORM (LET ((TEST (IF (AND (CONSTANTP CHAR-SET) (LISTP (EVAL CHAR-SET)))
			'MEMBER 'POSITION)))
	  (ONCE-ONLY-1 (CHAR-SET)
	    `(POSITION-IF #'(LAMBDA (CHAR) (,TEST CHAR ,CHAR-SET :TEST #'CHAR-EQUAL))
			  (STRING ,STRING) ,@OPTIONS))))

(DEFINE-SCL-CONVERSION STRING-SEARCH-SET (CHAR-SET STRING &REST OPTIONS)
  :NAME STRING-SEARCH-SET-OPTIMIZED
  :DOCUMENTATION "If the second argument is guaranteed to be a string"
  :FORM (LET ((TEST (IF (AND (CONSTANTP CHAR-SET) (LISTP (EVAL CHAR-SET)))
			'MEMBER 'POSITION)))
	  (ONCE-ONLY-1 (CHAR-SET)
	    `(POSITION-IF #'(LAMBDA (CHAR) (,TEST CHAR ,CHAR-SET :TEST #'CHAR-EQUAL))
			  ,STRING ,@OPTIONS))))

(DEFINE-SCL-CONVERSION STRING-SEARCH-NOT-SET (CHAR-SET STRING &REST OPTIONS)
  :NAME STRING-SEARCH-NOT-SET-GENERAL
  :DOCUMENTATION "If the second argument could be a string or a symbol"
  :FORM (LET ((TEST (IF (AND (CONSTANTP CHAR-SET) (LISTP (EVAL CHAR-SET)))
			'MEMBER 'POSITION)))
	  (ONCE-ONLY-1 (CHAR-SET)
	    `(POSITION-IF #'(LAMBDA (CHAR) (NOT (,TEST CHAR ,CHAR-SET :TEST #'CHAR-EQUAL)))
			  (STRING ,STRING) ,@OPTIONS))))

(DEFINE-SCL-CONVERSION STRING-SEARCH-NOT-SET (CHAR-SET STRING &REST OPTIONS)
  :NAME STRING-SEARCH-NOT-SET-OPTIMIZED
  :DOCUMENTATION "If the second argument is guaranteed to be a string"
  :FORM (LET ((TEST (IF (AND (CONSTANTP CHAR-SET) (LISTP (EVAL CHAR-SET)))
			'MEMBER 'POSITION)))
	  (ONCE-ONLY-1 (CHAR-SET)
	    `(POSITION-IF #'(LAMBDA (CHAR) (NOT (,TEST CHAR ,CHAR-SET :TEST #'CHAR-EQUAL)))
			  ,STRING ,@OPTIONS))))

(DEFINE-SCL-CONVERSION SUBSTRING (STRING FROM &OPTIONAL (TO NIL TO-P) AREA)
  :NAME SUBSTRING-GENERAL
  :DOCUMENTATION "If the argument could be a string or a symbol"
  :FORM (PROGN
	  (IGNORE AREA)
	  `(SUBSEQ (STRING ,STRING) ,FROM ,@(AND TO-P `(,TO)))))

(DEFINE-SCL-CONVERSION SUBSTRING (STRING FROM &OPTIONAL (TO NIL TO-P) AREA)
  :NAME SUBSTRING-OPTIMIZED
  :DOCUMENTATION "If the argument is guaranteed to be a string"
  :FORM (PROGN
	  (IGNORE AREA)
	  `(SUBSEQ ,STRING ,FROM ,@(AND TO-P `(,TO)))))

(DEFINE-SCL-CONVERSION TAND (DEGREES)
  `(TAN (* ,DEGREES (/ PI 180))))

(DEFINE-SCL-FUNARG-SUBSTITUTION TRUE
  :NAME CONVERT-TRUE-CLTL
  :DOCUMENTATION "Using CLtL Common Lisp, but making a new function each time"
  :NEW-FUNCTION (LAMBDA (&REST IGNORE) T))

#+IGNORE  ;Unfortunately this does not work, because the #' is still there
(DEFINE-SCL-FUNARG-SUBSTITUTION TRUE
  :NAME CONVERT-TRUE-ANSI
  :DOCUMENTATION "Using ANSI Common Lisp"
  :NEW-FUNCTION (FUTURE-COMMON-LISP:CONSTANTLY T))

(DEFINE-SCL-MACRO-CONVERSION UNWIND-PROTECT-CASE)

;;;  Genera's VECTOR-POP takes an extra optional argument of a default.
(DEFINE-SCL-CONVERSION VECTOR-POP (ARRAY DEFAULT)
  (ONCE-ONLY-1 (ARRAY DEFAULT)
    `(IF (PLUSP (FILL-POINTER ,ARRAY))
	 (VECTOR-POP ,ARRAY)
	 ,DEFAULT)))

#+IGNORE ;; I guess for Cloe we'd rather leave it as WITH-STACK-LIST
(DEFINE-SCL-CONVERSION WITH-STACK-LIST ((VAR &REST ELEMENTS) &BODY BODY)
  `(LET ((,VAR (LIST ,@ELEMENTS)))
     (DECLARE (FUTURE-COMMON-LISP:DYNAMIC-EXTENT ,VAR))
     ,@BODY))

#+IGNORE ;; I guess for Cloe we'd rather leave it as WITH-STACK-LIST*
(DEFINE-SCL-CONVERSION WITH-STACK-LIST* ((VAR &REST ELEMENTS) &BODY BODY)
  `(LET ((,VAR (LIST* ,@ELEMENTS)))
     (DECLARE (FUTURE-COMMON-LISP:DYNAMIC-EXTENT ,VAR))
     ,@BODY))

;; Some Lisps may not implement WITH-STANDARD-IO-SYNTAX, but this is the best we can do
(DEFINE-SCL-SUBSTITUTION WITH-STANDARD-IO-ENVIRONMENT
			 FUTURE-COMMON-LISP:WITH-STANDARD-IO-SYNTAX)

(DEFINE-SCL-CONVERSION XCONS (CDR CAR)
  (ONCE-ONLY-1 (CDR CAR)
    `(CONS ,CAR ,CDR)))

(DEFINE-SCL-CONVERSION XCONS-IN-AREA (CDR CAR AREA)
  (PROGN
    (IGNORE AREA)
    (ONCE-ONLY-1 (CDR CAR)
      `(CONS ,CAR ,CDR))))

;;;; Conditions

; Except for ERROR, most SCL condition types either have the same name or don't
; exist at all in ANSI Common Lisp, either way there is no conversion to be done.

; *ERROR-MESSAGE-HOOK* has no equivalent in ANSI Common Lisp

(DEFINE-SCL-CONVERSION CATCH-ERROR (FORM &OPTIONAL (PRINTFLAG T))
  `(FUTURE-COMMON-LISP:HANDLER-CASE (VALUES ,FORM NIL)
     (FUTURE-COMMON-LISP:ERROR (ERROR)
       (WHEN ,PRINTFLAG
	 (FORMAT *ERROR-OUTPUT* "~&~A~%" ERROR))
       (VALUES NIL T))))

(DEFUN CONVERT-FLAVORS-TO-TYPE-SPECIFIER (FLAVORS &OPTIONAL REMOVE-TYPES)
  (IF (LISTP FLAVORS)
      (IF (CDR (SETQ FLAVORS (SET-DIFFERENCE FLAVORS REMOVE-TYPES)))
	  `(OR ,@FLAVORS)
	  (CAR FLAVORS))
      (IF (MEMBER FLAVORS REMOVE-TYPES)
	  'CONDITION
	  FLAVORS)))

(DEFINE-SCL-CONVERSION CATCH-ERROR-RESTART ((FLAVORS DESCRIPTION &REST ARGS)
					    &BODY BODY)
  :MODIFICATION-DEPTH 3
  :FORM (CONVERT-ERROR-RESTART T NIL FLAVORS DESCRIPTION ARGS BODY))
	 
(DEFINE-SCL-CONVERSION CATCH-ERROR-RESTART-IF (COND (FLAVORS DESCRIPTION &REST ARGS)
					       &BODY BODY)
  :MODIFICATION-DEPTH 3
  :FORM (CONVERT-ERROR-RESTART COND NIL FLAVORS DESCRIPTION ARGS BODY))

; CONDITION is the same symbol in both packages

(DEFINE-SCL-CONVERSION CONDITION-BIND (HANDLERS &BODY BODY)
  `(FUTURE-COMMON-LISP:HANDLER-BIND
       ,(LOOP FOR (FLAVORS FUNCTION) IN HANDLERS
	      COLLECT `(,(CONVERT-FLAVORS-TO-TYPE-SPECIFIER FLAVORS) ,FUNCTION))
     ,@BODY))

; CONDITION-BIND-DEFAULT has no equivalent in ANSI Common Lisp
; CONDITION-BIND-DEFAULT-IF has no equivalent in ANSI Common Lisp

(DEFINE-SCL-CONVERSION CONDITION-BIND-IF (COND HANDLERS &BODY BODY)
  `(FLET ((CONDITION-BIND-IF-BODY ()
	    ,@BODY))
     (IF ,COND
	 (FUTURE-COMMON-LISP:HANDLER-BIND
	   ,(LOOP FOR (FLAVORS FUNCTION) IN HANDLERS
		  COLLECT `(,(CONVERT-FLAVORS-TO-TYPE-SPECIFIER FLAVORS) ,FUNCTION))
	   (CONDITION-BIND-IF-BODY))
	 (CONDITION-BIND-IF-BODY))))
  
(DEFINE-SCL-CONVERSION CONDITION-CALL (VARLIST FORM &BODY CLAUSES)
  (CONVERT-CONDITION-CALL T VARLIST FORM CLAUSES))

(DEFINE-SCL-CONVERSION CONDITION-CALL-IF (COND VARLIST FORM &BODY CLAUSES)
  (CONVERT-CONDITION-CALL COND VARLIST FORM CLAUSES))

(DEFUN CONVERT-CONDITION-CALL (COND VARLIST FORM CLAUSES)
  (LET* ((NO-ERROR (AND (EQ (CAAR (LAST CLAUSES)) ':NO-ERROR)
			(PROG1 (CAR (LAST CLAUSES))
			       (SETQ CLAUSES (BUTLAST CLAUSES)))))
	 (CONDITIONAL (NOT (AND (CONSTANTP COND) (NOT (NULL (EVAL COND))))))
	 (TAGS (LOOP FOR I FROM 1 TO (LENGTH CLAUSES)
		     COLLECT (INTERN (FORMAT NIL "CONDITION-CALL-TAG-~D" I))))
	 (FORM `(TAGBODY
		  (FUTURE-COMMON-LISP:HANDLER-BIND
		    ,(LOOP FOR (PREDICATE . FORMS) IN CLAUSES AND TAG IN TAGS
			   DO (IGNORE FORMS)
			   COLLECT `(T #'(LAMBDA (.CONDITION.)
					   (WHEN ,(IF CONDITIONAL
						      `(AND .CONDITIONAL.
							    (,PREDICATE .CONDITION.))
						      `(,PREDICATE .CONDITION.))
					     ,@(WHEN VARLIST
						 `((SETQ ,(FIRST VARLIST) .CONDITION.)))
					     (GO ,TAG)))))
		    (RETURN-FROM CONDITION-CALL-SUCCESS ,FORM))
		  ,@(LOOP FOR (PREDICATE . FORMS) IN CLAUSES AND TAG IN TAGS
			  DO (IGNORE PREDICATE)
			  COLLECT TAG
			  COLLECT `(RETURN-FROM CONDITION-CALL-FAILURE
				     ,(IF (CDR FORMS) `(PROGN ,@FORMS) (CAR FORMS)))))))
    (WHEN VARLIST
      (SETQ FORM `(LET ,VARLIST ,FORM)))
    (WHEN CONDITIONAL
      (SETQ FORM `(LET ((.CONDITIONAL. ,COND)) ,FORM)))
    (IF NO-ERROR
	`(BLOCK CONDITION-CALL-FAILURE
	   (MULTIPLE-VALUE-BIND ,VARLIST (BLOCK CONDITION-CALL-SUCCESS ,FORM)
	     ,@(CDR NO-ERROR)))
	`(BLOCK CONDITION-CALL-FAILURE
	   (BLOCK CONDITION-CALL-SUCCESS
	     ,FORM)))))

(DEFINE-SCL-CONVERSION CONDITION-CASE (VARLIST FORM &REST CLAUSES)
  (CONVERT-CONDITION-CASE T VARLIST FORM CLAUSES))

(DEFINE-SCL-CONVERSION CONDITION-CASE-IF (COND VARLIST FORM &REST CLAUSES)
  (CONVERT-CONDITION-CASE COND VARLIST FORM CLAUSES))

(DEFUN CONVERT-CONDITION-CASE (COND VARLIST FORM CLAUSES)
  (LET ((CONDITIONAL (NOT (AND (CONSTANTP COND) (NOT (NULL (EVAL COND))))))
	(CLAUSES (LOOP FOR (FLAVORS . FORMS) IN CLAUSES
		       COLLECT (IF (EQ FLAVORS ':NO-ERROR)
				   `(,FLAVORS ,VARLIST ,@FORMS)
				   `(,(CONVERT-FLAVORS-TO-TYPE-SPECIFIER FLAVORS)
				     ,(AND VARLIST `(,(FIRST VARLIST)))
				     ,@FORMS)))))
    (IF CONDITIONAL
	`(FLET ((CONDITION-CASE-IF-BODY ()
		  ,FORM))
	   (IF ,COND
	       (FUTURE-COMMON-LISP:HANDLER-CASE (CONDITION-CASE-IF-BODY) ,@CLAUSES)
	       (CONDITION-CASE-IF-BODY)))
	`(FUTURE-COMMON-LISP:HANDLER-CASE ,FORM ,@CLAUSES))))

; DEFINE-GLOBAL-HANDLER has no equivalent in ANSI Common Lisp

(DEFINE-SCL-CONVERSION ERROR-RESTART ((FLAVORS DESCRIPTION &REST ARGS) &BODY BODY)
  :MODIFICATION-DEPTH 3
  :FORM (CONVERT-ERROR-RESTART T 'ERROR FLAVORS DESCRIPTION ARGS BODY))

(DEFINE-SCL-CONVERSION ERROR-RESTART-IF (COND (FLAVORS DESCRIPTION &REST ARGS) &BODY BODY)
  :MODIFICATION-DEPTH 3
  :FORM (CONVERT-ERROR-RESTART COND 'ERROR FLAVORS DESCRIPTION ARGS BODY))

(DEFINE-SCL-CONVERSION ERROR-RESTART-LOOP ((FLAVORS DESCRIPTION &REST ARGS) &BODY BODY)
  :MODIFICATION-DEPTH 3
  :FORM (CONVERT-ERROR-RESTART T 'BOTH FLAVORS DESCRIPTION ARGS BODY))

(DEFUN CONVERT-ERROR-RESTART (COND LOOP FLAVORS DESCRIPTION ARGS BODY)
  (LET* ((CONDITIONAL (NOT (AND (CONSTANTP COND) (NOT (NULL (EVAL COND))))))
	 (TAG (INTERN "CATCH-ERROR-RESTART"))	;put these in the user's package
	 (CONDITION-VAR (INTERN ".CONDITION."))
	 (CONDITIONAL-VAR (INTERN ".CONDITIONAL."))
	 (STREAM-VAR (INTERN ".STREAM."))
	 (FORM (COND ((EQ LOOP 'BOTH) `(PROGN ,@BODY (GO ,TAG)))
		     ((CDR BODY) `(PROGN ,@BODY))
		     (T (CAR BODY))))
	 (BLOCK-NAME (IF (EQ LOOP 'BOTH) 'NIL TAG))
	 (TYPEP `(OR (NULL ,CONDITION-VAR)	;supposed to be true if no condition supplied
		     (TYPEP ,CONDITION-VAR
			    ;; Remove SYS:ABORT since it's not a condition type in ANSI CL,
			    ;; but it appears in nearly all error-restarts in Genera.
			    ',(CONVERT-FLAVORS-TO-TYPE-SPECIFIER FLAVORS '(SYS:ABORT)))))
	 (RESTART `(NIL () :TEST (LAMBDA (,CONDITION-VAR)
				   ,(IF CONDITIONAL
					`(AND ,CONDITIONAL-VAR ,TYPEP)
					TYPEP))
			   :REPORT ,(IF (AND (NULL ARGS)
					     (STRINGP DESCRIPTION)
					     (NOT (FIND #\~ DESCRIPTION :TEST #'CHAR-EQUAL)))
					DESCRIPTION
					`(LAMBDA (,STREAM-VAR)
					  (FORMAT ,STREAM-VAR ,DESCRIPTION ,@ARGS)))
		     ,(IF LOOP
			  `(GO ,TAG)
			  `(RETURN-FROM ,BLOCK-NAME (VALUES NIL T)))))
	 (RESTART-CASE `(FUTURE-COMMON-LISP:RESTART-CASE ,FORM ,RESTART)))
    (WHEN LOOP
      (SETQ RESTART-CASE `(TAGBODY ,TAG ,RESTART-CASE)))
    (WHEN CONDITIONAL
      (SETQ RESTART-CASE `(LET ((,CONDITIONAL-VAR ,COND)) ,RESTART-CASE)))
    `(BLOCK ,BLOCK-NAME
       ,RESTART-CASE)))

(DEFINE-SCL-SUBSTITUTION ERROR FUTURE-COMMON-LISP:ERROR)

(DEFINE-SCL-CONVERSION ERRORP (THING)
  `(TYPEP ,THING 'FUTURE-COMMON-LISP:ERROR))

(DEFINE-SCL-CONVERSION IGNORE-ERRORS (&BODY BODY)
  `(FUTURE-COMMON-LISP:IGNORE-ERRORS (VALUES ,(IF (CDR BODY) `(PROGN ,@BODY) (CAR BODY))
					     NIL)))

(DEFINE-SCL-CONVERSION MAKE-CONDITION (CONDITION-NAME &REST INIT-OPTIONS)
  `(FUTURE-COMMON-LISP:MAKE-CONDITION ,CONDITION-NAME ,@INIT-OPTIONS))

;;; The important difference is that SCL:SIGNAL will enter the debugger
;;; for a serious condition and FUTURE-COMMON-LISP:SIGNAL won't.
(DEFINE-SCL-CONVERSION SIGNAL (DATUM &REST ARGUMENTS)
  :NAME CONVERT-SIGNAL-TO-ERROR
  :DOCUMENTATION "Automatically enter the debugger if this is a SERIOUS-CONDITION"
  :FORM `(FUTURE-COMMON-LISP:ERROR ,DATUM ,@ARGUMENTS))

(DEFINE-SCL-CONVERSION SIGNAL (DATUM &REST ARGUMENTS)
  :NAME CONVERT-SIGNAL-TO-SIGNAL
  :DOCUMENTATION "Don't automatically enter the debugger"
  :FORM `(FUTURE-COMMON-LISP:SIGNAL ,DATUM ,@ARGUMENTS))

;; This can only be an approximate conversion.  There are probably :PROCEED and
;; :DOCUMENT-PROCEED-TYPE methods that need to be merged into here.  What we will
;; do is provide dummy places in which that information could be inserted, marked
;; with *** (chosen because it will print without a package prefix; maybe a bad idea
;; because it will also compile without a compiler warning, being declared SPECIAL).
(DEFINE-SCL-CONVERSION SIGNAL-PROCEED-CASE ((VARLIST &REST SIGNAL-ARGS) &BODY CLAUSES)
  (LET ((SIGNAL `(FUTURE-COMMON-LISP:SIGNAL ,@SIGNAL-ARGS))
	(CLAUSES (LOOP FOR CLAUSE IN CLAUSES
		       NCONC (IF (ATOM (CAR CLAUSE))
				 (LIST CLAUSE)
				 (LOOP FOR PROCEED-TYPE IN (CAR CLAUSE)
				       COLLECT `(,PROCEED-TYPE ,@(CDR CLAUSE)))))))
    (DOLIST (CLAUSE CLAUSES)
      (WHEN (NULL (CAR CLAUSE))
	(SETQ CLAUSES (REMOVE CLAUSE CLAUSES))
	(SETQ SIGNAL `(OR ,SIGNAL ,(IF (CDDR CLAUSE) `(PROGN ,@(CDR CLAUSE)) (CADR CLAUSE))))
	(RETURN)))
    `(FUTURE-COMMON-LISP:RESTART-CASE ,SIGNAL
       ,@(LOOP FOR (PROCEED-TYPE . FORMS) IN CLAUSES
	       COLLECT `(,PROCEED-TYPE ,VARLIST
			   ,@(WHEN VARLIST
			       (UNLESS (MEMBER (FIRST VARLIST) '(&OPTIONAL &REST &KEY))
				 `(:INTERACTIVE (LAMBDA () (LIST ***)))))
			   :REPORT (LAMBDA (STREAM) ***)
			  ,@FORMS)))))

; UNDEFINE-GLOBAL-HANDLER has no equivalent in ANSI Common Lisp

(DEFINE-SCL-CONVERSION WITH-OPEN-FILE-CASE ((VAR PATHNAME &REST OPTIONS) &BODY CLAUSES)
  (CONVERT-WITH-OPEN-FILE-CASE 'WITH-OPEN-FILE-CASE `(OPEN ,PATHNAME ,@OPTIONS) VAR CLAUSES T))

(DEFINE-SCL-CONVERSION WITH-OPEN-FILE-CASE-IF (COND (VAR PATHNAME &REST OPTIONS) &BODY CLAUSES)
  (CONVERT-WITH-OPEN-FILE-CASE 'WITH-OPEN-FILE-CASE `(OPEN ,PATHNAME ,@OPTIONS)
			       VAR CLAUSES COND))

(DEFINE-SCL-CONVERSION WITH-OPEN-STREAM-CASE ((VAR STREAM-FORM) &BODY CLAUSES)
  (CONVERT-WITH-OPEN-FILE-CASE 'WITH-OPEN-STREAM-CASE STREAM-FORM VAR CLAUSES T))

(DEFINE-SCL-CONVERSION WITH-OPEN-STREAM-CASE-IF (COND (VAR STREAM-FORM) &BODY CLAUSES)
  (CONVERT-WITH-OPEN-FILE-CASE 'WITH-OPEN-STREAM-CASE STREAM-FORM VAR CLAUSES COND))

(DEFUN CONVERT-WITH-OPEN-FILE-CASE (BLOCK-NAME STREAM-FORM VAR CLAUSES COND)
  (LET ((CONDITIONAL (NOT (AND (CONSTANTP COND) (NOT (NULL (EVAL COND))))))
	(BODY (DOLIST (CLAUSE CLAUSES)
		(WHEN (EQ (CAR CLAUSE) ':NO-ERROR)
		  (SETQ CLAUSES (REMOVE CLAUSE CLAUSES))
		  (RETURN (CDR CLAUSE)))))
	(HANDLER-CASE `(FUTURE-COMMON-LISP:HANDLER-CASE ,STREAM-FORM
			 ,@(LOOP FOR (FLAVORS . FORMS) IN CLAUSES
				 COLLECT `(,(CONVERT-FLAVORS-TO-TYPE-SPECIFIER FLAVORS)
					   (,VAR)
					   (RETURN-FROM ,BLOCK-NAME
					     ,(IF (CDR FORMS)
						  `(PROGN ,@FORMS)
						  (CAR FORMS))))))))
    `(BLOCK ,BLOCK-NAME 
       (WITH-OPEN-STREAM (,VAR ,(IF CONDITIONAL
				    `(IF ,COND ,HANDLER-CASE ,STREAM-FORM)
				    HANDLER-CASE))
	 ,@BODY))))


; WITHOUT-FLOATING-UNDERFLOW-TRAPS has no equivalent in ANSI Common Lisp


;;;; Pathname Messages

;;; These pathname conversions are correct for Symbolics Common Lisp,
;;; but not for ANSI Common Lisp where cl:pathname-name = :raw-name.
;;; Other Common Lisp implementations vary in their interpretation of 
;;; the alphabetic case rules, so there is nothing safe to assume.
;;; Just make the simplest conversion and let the user adjust if required.

(define-SCL-message-conversion :host (pathname)
  :flavor pathname
  :form `(pathname-host ,pathname))

(define-SCL-message-conversion :device (pathname)
  :flavor pathname
  :form `(pathname-device ,pathname))

(define-SCL-message-conversion :directory (pathname)
  :flavor pathname
  :form `(pathname-directory ,pathname))

(define-SCL-message-conversion :name (pathname)
  :flavor pathname
  :form `(pathname-name ,pathname))

(define-SCL-message-conversion :type (pathname)
  :flavor pathname
  :form `(pathname-type ,pathname))

(define-SCL-message-conversion :version (pathname)
  :flavor pathname
  :form `(pathname-version ,pathname))

(define-SCL-message-conversion :new-host (pathname host)
  :flavor pathname
  :form `(make-pathname :defaults ,pathname :host ,host))

(define-SCL-message-conversion :new-device (pathname device)
  :flavor pathname
  :form `(make-pathname :defaults ,pathname :device ,device))

(define-SCL-message-conversion :new-directory (pathname directory)
  :flavor pathname
  :form `(make-pathname :defaults ,pathname :directory ,directory))

(define-SCL-message-conversion :new-name (pathname name)
  :flavor pathname
  :form `(make-pathname :defaults ,pathname :name ,name))

(define-SCL-message-conversion :new-type (pathname type)
  :flavor pathname
  :form `(make-pathname :defaults ,pathname :type ,type))

(define-SCL-message-conversion :new-version (pathname version)
  :flavor pathname
  :form `(make-pathname :defaults ,pathname :version ,version))

(define-SCL-message-conversion :new-pathname (pathname &rest keywords)
  :flavor pathname
  :form `(make-pathname :defaults ,pathname ,@keywords))

;;;--- Could translate the logical-pathname and raw-name messages to their ANSI Common Lisp
;;;--- equivalents.  Maybe it's not worth it.

;;;; File Stream Messages

(define-SCL-message-conversion :creation-date (stream)
  :flavor stream
  :form `(file-write-date ,stream))

(define-SCL-message-conversion :length (stream)
  :flavor stream
  :form `(file-length ,stream))

(define-SCL-message-conversion :pathname (stream)
  :flavor (or pathname stream)
  :form `(pathname ,stream))

(define-SCL-message-conversion :truename (stream)
  :flavor (or pathname stream)
  :form `(truename ,stream))

;;;; Stream Messages

(define-SCL-message-conversion :characters (stream)
  :flavor stream
  :form `(subtypep (stream-element-type ,stream) 'character))

(define-SCL-message-conversion :clear-input (stream)
  :flavor stream
  :form `(clear-input ,stream))

(define-SCL-message-conversion :clear-output (stream)
  :flavor stream
  :form `(clear-output ,stream))

(define-SCL-message-conversion :close (stream &optional (mode nil mode-p))
  :flavor stream
  :form (cond ((not mode-p) `(close ,stream))
	      ((or (eq mode ':abort) (equal mode '':abort)) `(close ,stream :abort t))
	      (t `(close ,stream :abort (eq ,mode ':abort)))))

(define-SCL-message-conversion :direction (stream)
  :flavor stream
  :form `(cond ((not (input-stream-p ,stream)) ':output)
	       ((not (output-stream-p ,stream)) ':input)
	       (t ':bidirectional)))

(define-SCL-message-conversion :finish (stream)
  :flavor stream
  :form `(finish-output ,stream))

(define-SCL-message-conversion :force-output (stream)
  :flavor stream
  :form `(force-output ,stream))

(define-SCL-message-conversion :fresh-line (stream)
  :flavor stream
  :form `(fresh-line ,@(unless (eq stream '*standard-output*) `(,stream))))

;; As documented, not all cases of :line-in correspond to read-line
;; Also the EOF conventions are different so we have to convert
(define-SCL-message-conversion :line-in (stream &optional (leader nil))
  :flavor stream
  :form (when (member leader '(nil 'nil t 't) :test #'equal)
	  (let ((line (intern "LINE"))
		(eof (intern "EOF")))
	    `(multiple-value-bind (,line ,eof)
		 (read-line ,stream nil nil)
	       (values (or ,line "") (or ,eof (not ,line)))))))

(define-SCL-message-conversion :line-out (stream string &rest bounds)
  :flavor stream
  :form `(write-line ,string ,stream
		     ,@(and bounds `(:start ,(pop bounds)))
		     ,@(and bounds `(:end ,(pop bounds)))))

(define-SCL-message-conversion :listen (stream)
  :flavor stream
  :form `(listen ,stream))

(define-SCL-message-conversion :string-out (stream string &rest bounds)
  :flavor stream
  :form (unless (cddr bounds)
	  `(write-string ,string ,stream
			 ,@(and bounds `(:start ,(pop bounds)))
			 ,@(and bounds `(:end ,(pop bounds))))))

(define-SCL-message-conversion :tyi (stream &optional (eof nil eof-p))
  :documentation "Use READ-CHAR to :TYI a character (echoing behavior might vary)"
  :flavor stream
  :form `(read-char ,stream ,@(cond ((or (not eof-p) (eq eof nil) (equal eof ''nil))
				     `(nil nil))
				    (t `(,eof)))))	;close enough for gov't work

(define-SCL-message-conversion :tyi (stream &optional (eof nil eof-p))
  :name send-tyi-to-read-byte
  :documentation "Use READ-BYTE to :TYI a byte"
  :flavor stream
  :form (unless (member stream '(*standard-input* *query-io* *terminal-io*))
	  `(read-byte ,stream ,@(cond ((or (not eof-p) (eq eof nil) (equal eof ''nil))
				       `(nil nil))
				      (t `(,eof))))))	;close enough for gov't work

(define-SCL-message-conversion :tyi-no-hang (stream &optional (eof nil eof-p))
  :flavor stream
  :form `(read-char-no-hang ,stream ,@(cond ((or (not eof-p) (eq eof nil) (equal eof ''nil))
					     `(nil nil))
					    (t `(,eof)))))	;close enough for gov't work

(define-SCL-message-conversion :tyipeek (stream &optional (eof nil eof-p))
  :flavor stream
  :form `(peek-char nil ,stream ,@(cond ((or (not eof-p) (eq eof nil) (equal eof ''nil))
					 `(nil nil))
					(t `(,eof)))))		;close enough for gov't work

(define-SCL-message-conversion :tyo (stream char)
  :name send-tyo-to-terpri
  :documentation "Use TERPRI to :TYO a newline"
  :flavor stream
  :form (when (or (eq char '#\return) (equal char ''#\return))
	  `(terpri ,stream)))

(define-SCL-message-conversion :tyo (stream char)
  :documentation "Use WRITE-CHAR to :TYO a character"
  :flavor stream
  :form `(write-char ,char ,@(unless (eq stream '*standard-output*) `(,stream))))

(define-SCL-message-conversion :tyo (stream byte)
  :name send-tyo-to-write-byte
  :documentation "Use WRITE-BYTE to :TYO a byte"
  :flavor stream
  :form (unless (member stream '(*standard-output* *query-io* *terminal-io*))
	  `(write-byte ,byte ,stream)))

(define-SCL-message-conversion :untyi (stream char)
  :flavor stream
  :form `(unread-char ,char ,@(unless (eq stream '*standard-input*) `(,stream))))


;;;; Common Lisp to Common Lisp Developer

(DEFINE-CONVERSION-SET CL-TO-CLYDE DEFINE-CLYDE-SUBSTITUTION DEFINE-CLYDE-CONVERSION
		       :PRETTY-NAME "Common Lisp to Common Lisp Developer")

(DEFINE-CLYDE-SUBSTITUTION CL:*FEATURES* CLTL:*FEATURES*)

(DEFINE-CLYDE-SUBSTITUTION CL:ADJUST-ARRAY CLTL:ADJUST-ARRAY)

(DEFINE-CLYDE-SUBSTITUTION CL:ADJUSTABLE-ARRAY-P CLTL:ADJUSTABLE-ARRAY-P)

(DEFINE-CLYDE-SUBSTITUTION CL:APPLY CLTL:APPLY)

(DEFINE-CLYDE-SUBSTITUTION CL:APPLYHOOK CLTL:APPLYHOOK)

(DEFINE-CLYDE-SUBSTITUTION CL:APROPOS CLTL:APROPOS)

(DEFINE-CLYDE-SUBSTITUTION CL:APROPOS-LIST CLTL:APROPOS-LIST)

(DEFINE-CLYDE-SUBSTITUTION CL:ASH CLTL:ASH)

(DEFINE-CLYDE-SUBSTITUTION CL:ASSOC-IF CLTL:ASSOC-IF)

(DEFINE-CLYDE-SUBSTITUTION CL:ASSOC-IF-NOT CLTL:ASSOC-IF-NOT)

(DEFINE-CLYDE-SUBSTITUTION CL:CHAR-EQUAL CLTL:CHAR-EQUAL)

(DEFINE-CLYDE-SUBSTITUTION CL:CHAR-GREATERP CLTL:CHAR-GREATERP)

(DEFINE-CLYDE-SUBSTITUTION CL:CHAR-LESSP CLTL:CHAR-LESSP)

(DEFINE-CLYDE-SUBSTITUTION CL:CHAR-NOT-EQUAL CLTL:CHAR-NOT-EQUAL)

(DEFINE-CLYDE-SUBSTITUTION CL:CHAR-NOT-GREATERP CLTL:CHAR-NOT-GREATERP)

(DEFINE-CLYDE-SUBSTITUTION CL:CHAR-NOT-LESSP CLTL:CHAR-NOT-LESSP)

(DEFINE-CLYDE-SUBSTITUTION CL:COMPILE-FILE CLTL:COMPILE-FILE)

(DEFINE-CLYDE-SUBSTITUTION CL:COND CLTL:COND)

(DEFINE-CLYDE-CONVERSION CL:COPY-ALIST (ALIST)
  `(CLTL:COPY-ALIST ,ALIST))

(DEFINE-CLYDE-CONVERSION CL:COPY-LIST (LIST)
  `(CLTL:COPY-LIST ,LIST))

(DEFINE-CLYDE-CONVERSION CL:COPY-SEQ (SEQUENCE)
  `(CLTL:COPY-SEQ ,SEQUENCE))

;;--- Defstruct is really a hell of a lot harder than this, but what can ya do
(DEFINE-CLYDE-SUBSTITUTION CL:DEFSTRUCT CLTL:DEFSTRUCT)

(DEFINE-CLYDE-SUBSTITUTION CL:DEFUN CLTL:DEFUN)

(DEFINE-CLYDE-SUBSTITUTION CL:DELETE-DUPLICATES CLTL:DELETE-DUPLICATES)

(DEFINE-CLYDE-SUBSTITUTION CL:DESCRIBE CLTL:DESCRIBE)

(DEFINE-CLYDE-SUBSTITUTION CL:DIRECTORY CLTL:DIRECTORY)

(DEFINE-CLYDE-SUBSTITUTION CL:DIRECTORY-NAMESTRING CLTL:DIRECTORY-NAMESTRING)

(DEFINE-CLYDE-SUBSTITUTION CL:DISASSEMBLE CLTL:DISASSEMBLE)

(DEFINE-CLYDE-SUBSTITUTION CL:DO CLTL:DO)

(DEFINE-CLYDE-SUBSTITUTION CL:DO* CLTL:DO*)

(DEFINE-CLYDE-SUBSTITUTION CL:DO-ALL-SYMBOLS CLTL:DO-ALL-SYMBOLS)

(DEFINE-CLYDE-SUBSTITUTION CL:DOCUMENTATION CLTL:DOCUMENTATION)

(DEFINE-CLYDE-SUBSTITUTION CL:DOLIST CLTL:DOLIST)

(DEFINE-CLYDE-SUBSTITUTION CL:DOTIMES CLTL:DOTIMES)

(DEFINE-CLYDE-SUBSTITUTION CL:DRIBBLE CLTL:DRIBBLE)

(DEFINE-CLYDE-SUBSTITUTION CL:ENOUGH-NAMESTRING CLTL:ENOUGH-NAMESTRING)

(DEFINE-CLYDE-SUBSTITUTION CL:EVAL CLTL:EVAL)

(DEFINE-CLYDE-SUBSTITUTION CL:EVAL-WHEN CLTL:EVAL-WHEN)

(DEFINE-CLYDE-SUBSTITUTION CL:EVALHOOK CLTL:EVALHOOK)

(DEFINE-CLYDE-SUBSTITUTION CL:EXPORT CLTL:EXPORT)

(DEFINE-CLYDE-SUBSTITUTION CL:FILE-NAMESTRING CLTL:FILE-NAMESTRING)

(DEFINE-CLYDE-SUBSTITUTION CL:FIND-PACKAGE CLTL:FIND-PACKAGE)

(DEFINE-CLYDE-SUBSTITUTION CL:FIND-SYMBOL CLTL:FIND-SYMBOL)

(DEFINE-CLYDE-SUBSTITUTION CL:FLET CLTL:FLET)

(DEFINE-CLYDE-SUBSTITUTION CL:FUNCALL CLTL:FUNCALL)

(DEFINE-CLYDE-SUBSTITUTION CL:FUNCTIONP CLTL:FUNCTIONP)

(DEFINE-CLYDE-SUBSTITUTION CL:GET-SETF-METHOD CLTL:GET-SETF-METHOD)

(DEFINE-CLYDE-SUBSTITUTION CL:GET-SETF-METHOD-MULTIPLE-VALUE CLTL:GET-SETF-METHOD-MULTIPLE-VALUE)

(DEFINE-CLYDE-SUBSTITUTION CL:HOST-NAMESTRING CLTL:HOST-NAMESTRING)

(DEFINE-CLYDE-CONVERSION CL:IF (CONDITION THEN &OPTIONAL (ELSE NIL ELSE-P))
  `(CLTL:IF ,CONDITION ,THEN ,@(AND ELSE-P `(,ELSE))))

;These aren't the same, CL:IGNORE is a function as well as a declaration, CLTL:IGNORE
;is only a declaration.  The conversion tool can't tell whether it's used in form
;context or declaration context, so this will have to be converted by hand
;(DEFINE-CLYDE-SUBSTITUTION CL:IGNORE CLTL:IGNORE)

(DEFINE-CLYDE-SUBSTITUTION CL:IMPORT CLTL:IMPORT)

(DEFINE-CLYDE-SUBSTITUTION CL:IN-PACKAGE CLTL:IN-PACKAGE)

(DEFINE-CLYDE-SUBSTITUTION CL:INSPECT CLTL:INSPECT)

(DEFINE-CLYDE-SUBSTITUTION CL:INTERN CLTL:INTERN)

(DEFINE-CLYDE-SUBSTITUTION CL:LABELS CLTL:LABELS)

;These aren't the same, CL:LAMBDA is a macro and CLTL:LAMBDA is not.
;The conversion tool can't tell whether it's used in form context or function context
;so this will have to be converted by hand
;(DEFINE-CLYDE-SUBSTITUTION CL:LAMBDA CLTL:LAMBDA)

(DEFINE-CLYDE-SUBSTITUTION CL:LET CLTL:LET)

(DEFINE-CLYDE-SUBSTITUTION CL:LISP-IMPLEMENTATION-TYPE CLTL:LISP-IMPLEMENTATION-TYPE)

(DEFINE-CLYDE-SUBSTITUTION CL:LISP-IMPLEMENTATION-VERSION CLTL:LISP-IMPLEMENTATION-VERSION)

(DEFINE-CLYDE-SUBSTITUTION CL:LIST-ALL-PACKAGES CLTL:LIST-ALL-PACKAGES)

(DEFINE-CLYDE-SUBSTITUTION CL:LOAD CLTL:LOAD)

;These aren't the same, CLTL:LOOP only accepts the simple form
;(DEFINE-CLYDE-SUBSTITUTION CL:LOOP CLTL:LOOP)

(DEFINE-CLYDE-SUBSTITUTION CL:MACHINE-INSTANCE CLTL:MACHINE-INSTANCE)

(DEFINE-CLYDE-SUBSTITUTION CL:MACHINE-TYPE CLTL:MACHINE-TYPE)

(DEFINE-CLYDE-SUBSTITUTION CL:MACHINE-VERSION CLTL:MACHINE-VERSION)

(DEFINE-CLYDE-SUBSTITUTION CL:MACRO-FUNCTION CLTL:MACRO-FUNCTION)

(DEFINE-CLYDE-SUBSTITUTION CL:MACROEXPAND CLTL:MACROEXPAND)

(DEFINE-CLYDE-SUBSTITUTION CL:MACROEXPAND-1 CLTL:MACROEXPAND-1)

(DEFINE-CLYDE-CONVERSION CL:MAKE-ARRAY (DIMENSIONS &REST OPTIONS)
  (WHEN (LOOP FOR KEYWORD IN '(:AREA :DISPLACED-CONFORMALLY :LEADER-LENGTH
			       :LEADER-LIST :NAMED-STRUCTURE-SYMBOL)
	      NEVER (KEYWORD-ARGUMENT-PRESENT KEYWORD OPTIONS))
    `(CLTL:MAKE-ARRAY ,DIMENSIONS ,@OPTIONS)))

(DEFINE-CLYDE-SUBSTITUTION CL:MAKE-CONCATENATED-STREAM CLTL:MAKE-CONCATENATED-STREAM)

(DEFINE-CLYDE-SUBSTITUTION CL:MAKE-ECHO-STREAM CLTL:MAKE-ECHO-STREAM)

(DEFINE-CLYDE-CONVERSION CL:MAKE-HASH-TABLE (&REST OPTIONS)
  (WHEN (LOOP FOR KEYWORD IN '(:AREA :ENTRY-SIZE :GC-PROTECT-VALUES
			       :GROWTH-FACTOR :GROWTH-THRESHOLD
			       :HASH-FUNCTION :IGNORE-GC :INITIAL-CONTENTS :LOCKING :MUTATING
			       :NUMBER-OF-VALUES :OPTIMIZATIONS :REHASH-AFTER-FULL-GC
			       :REHASH-BEFORE-COLD :STORE-HASH-CODE)
	      NEVER (KEYWORD-ARGUMENT-PRESENT KEYWORD OPTIONS))
    (WHEN (MULTIPLE-VALUE-BIND (PRESENT TEST)
	      (KEYWORD-ARGUMENT-PRESENT :TEST OPTIONS)
	    (OR (NOT PRESENT)
		(MEMBER TEST '('EQ 'EQL 'EQUAL #'EQ #'EQL #'EQUAL) :TEST #'EQUAL)))
      `(CLTL:MAKE-HASH-TABLE ,@OPTIONS))))

(DEFINE-CLYDE-CONVERSION CL:MAKE-LIST (SIZE &REST OPTIONS)
  (UNLESS (KEYWORD-ARGUMENT-PRESENT ':AREA OPTIONS)
    `(CLTL:MAKE-LIST ,SIZE ,@OPTIONS)))

(DEFINE-CLYDE-SUBSTITUTION CL:MAKE-PACKAGE CLTL:MAKE-PACKAGE)

(DEFINE-CLYDE-CONVERSION CL:MAKE-SEQUENCE (TYPE SIZE &REST OPTIONS)
  (UNLESS (KEYWORD-ARGUMENT-PRESENT ':AREA OPTIONS)
    `(CLTL:MAKE-SEQUENCE ,TYPE ,SIZE ,@OPTIONS)))

(DEFINE-CLYDE-CONVERSION CL:MAKE-STRING (SIZE &REST OPTIONS)
  (UNLESS (OR (KEYWORD-ARGUMENT-PRESENT ':AREA OPTIONS)
	      (KEYWORD-ARGUMENT-PRESENT ':ELEMENT-TYPE OPTIONS))
    `(CLTL:MAKE-STRING ,SIZE ,@OPTIONS)))

(DEFINE-CLYDE-CONVERSION CL:MAKE-SYMBOL (NAME)
  `(CLTL:MAKE-SYMBOL ,NAME))

(DEFINE-CLYDE-SUBSTITUTION CL:MAKE-SYNONYM-STREAM CLTL:MAKE-SYNONYM-STREAM)

(DEFINE-CLYDE-SUBSTITUTION CL:MERGE-PATHNAMES CLTL:MERGE-PATHNAMES)

(DEFINE-CLYDE-SUBSTITUTION CL:MULTIPLE-VALUE-BIND CLTL:MULTIPLE-VALUE-BIND)

(DEFINE-CLYDE-SUBSTITUTION CL:MULTIPLE-VALUE-SETQ CLTL:MULTIPLE-VALUE-SETQ)

(DEFINE-CLYDE-SUBSTITUTION CL:NAMESTRING CLTL:NAMESTRING)

(DEFINE-CLYDE-SUBSTITUTION CL:NSUBLIS CLTL:NSUBLIS)

(DEFINE-CLYDE-SUBSTITUTION CL:NSUBST CLTL:NSUBST)

(DEFINE-CLYDE-SUBSTITUTION CL:NSUBST-IF CLTL:NSUBST-IF)

(DEFINE-CLYDE-SUBSTITUTION CL:NSUBST-IF-NOT CLTL:NSUBST-IF-NOT)

(DEFINE-CLYDE-SUBSTITUTION CL:OPEN CLTL:OPEN)

(DEFINE-CLYDE-SUBSTITUTION CL:PACKAGE-NAME CLTL:PACKAGE-NAME)

(DEFINE-CLYDE-SUBSTITUTION CL:PACKAGE-NICKNAMES CLTL:PACKAGE-NICKNAMES)

(DEFINE-CLYDE-SUBSTITUTION CL:PATHNAME CLTL:PATHNAME)

(DEFINE-CLYDE-SUBSTITUTION CL:PATHNAME-DEVICE CLTL:PATHNAME-DEVICE)

(DEFINE-CLYDE-SUBSTITUTION CL:PATHNAME-DIRECTORY CLTL:PATHNAME-DIRECTORY)

(DEFINE-CLYDE-SUBSTITUTION CL:PATHNAME-HOST CLTL:PATHNAME-HOST)

(DEFINE-CLYDE-SUBSTITUTION CL:PATHNAME-NAME CLTL:PATHNAME-NAME)

(DEFINE-CLYDE-SUBSTITUTION CL:PATHNAME-TYPE CLTL:PATHNAME-TYPE)

(DEFINE-CLYDE-SUBSTITUTION CL:PATHNAME-VERSION CLTL:PATHNAME-VERSION)

(DEFINE-CLYDE-SUBSTITUTION CL:PEEK-CHAR CLTL:PEEK-CHAR)

(DEFINE-CLYDE-SUBSTITUTION CL:PRIN1 CLTL:PRIN1)

(DEFINE-CLYDE-SUBSTITUTION CL:PROG CLTL:PROG)

(DEFINE-CLYDE-SUBSTITUTION CL:PROG* CLTL:PROG*)

(DEFINE-CLYDE-CONVERSION CL:PUSH (ITEM LIST &REST OPTIONS)
  (UNLESS (OR (KEYWORD-ARGUMENT-PRESENT ':AREA OPTIONS T)
	      (KEYWORD-ARGUMENT-PRESENT ':LOCALIZE OPTIONS T))
    `(CLTL:PUSH ,ITEM ,LIST ,@OPTIONS)))

(DEFINE-CLYDE-CONVERSION CL:PUSHNEW (ITEM LIST &REST OPTIONS)
  (WHEN (LOOP FOR KEYWORD IN '(:AREA :LOCALIZE :REPLACE)
	      NEVER (KEYWORD-ARGUMENT-PRESENT KEYWORD OPTIONS))
    `(CLTL:PUSHNEW ,ITEM ,LIST ,@OPTIONS)))

(DEFINE-CLYDE-SUBSTITUTION CL:RASSOC-IF CLTL:RASSOC-IF)

(DEFINE-CLYDE-SUBSTITUTION CL:RASSOC-IF-NOT CLTL:RASSOC-IF-NOT)

(DEFINE-CLYDE-SUBSTITUTION CL:READ-CHAR CLTL:READ-CHAR)

(DEFINE-CLYDE-SUBSTITUTION CL:RENAME-PACKAGE CLTL:RENAME-PACKAGE)

(DEFINE-CLYDE-SUBSTITUTION CL:RETURN CLTL:RETURN)

(DEFINE-CLYDE-SUBSTITUTION CL:RETURN-FROM CLTL:RETURN-FROM)

(DEFINE-CLYDE-SUBSTITUTION CL:ROOM CLTL:ROOM)

(DEFINE-CLYDE-SUBSTITUTION CL:SHADOW CLTL:SHADOW)

(DEFINE-CLYDE-SUBSTITUTION CL:SHADOWING-IMPORT CLTL:SHADOWING-IMPORT)

(DEFINE-CLYDE-SUBSTITUTION CL:SLEEP CLTL:SLEEP)

(DEFINE-CLYDE-SUBSTITUTION CL:SOFTWARE-TYPE CLTL:SOFTWARE-TYPE)

(DEFINE-CLYDE-SUBSTITUTION CL:SOFTWARE-VERSION CLTL:SOFTWARE-VERSION)

(DEFINE-CLYDE-SUBSTITUTION CL:SPECIAL-FORM-P CLTL:SPECIAL-FORM-P)

(DEFINE-CLYDE-SUBSTITUTION CL:STRING-CAPITALIZE CLTL:STRING-CAPITALIZE)

(DEFINE-CLYDE-SUBSTITUTION CL:STRING-DOWNCASE CLTL:STRING-DOWNCASE)

(DEFINE-CLYDE-SUBSTITUTION CL:STRING-EQUAL CLTL:STRING-EQUAL)

(DEFINE-CLYDE-SUBSTITUTION CL:STRING-GREATERP CLTL:STRING-GREATERP)

(DEFINE-CLYDE-SUBSTITUTION CL:STRING-LEFT-TRIM CLTL:STRING-LEFT-TRIM)

(DEFINE-CLYDE-SUBSTITUTION CL:STRING-LESSP CLTL:STRING-LESSP)

(DEFINE-CLYDE-SUBSTITUTION CL:STRING-NOT-EQUAL CLTL:STRING-NOT-EQUAL)

(DEFINE-CLYDE-SUBSTITUTION CL:STRING-NOT-GREATERP CLTL:STRING-NOT-GREATERP)

(DEFINE-CLYDE-SUBSTITUTION CL:STRING-NOT-LESSP CLTL:STRING-NOT-LESSP)

(DEFINE-CLYDE-SUBSTITUTION CL:STRING-RIGHT-TRIM CLTL:STRING-RIGHT-TRIM)

(DEFINE-CLYDE-SUBSTITUTION CL:STRING-TRIM CLTL:STRING-TRIM)

(DEFINE-CLYDE-SUBSTITUTION CL:STRING-UPCASE CLTL:STRING-UPCASE)

(DEFINE-CLYDE-SUBSTITUTION CL:STRING/= CLTL:STRING/=)

(DEFINE-CLYDE-SUBSTITUTION CL:STRING< CLTL:STRING<)

(DEFINE-CLYDE-SUBSTITUTION CL:STRING<= CLTL:STRING<=)

(DEFINE-CLYDE-SUBSTITUTION CL:STRING= CLTL:STRING=)

(DEFINE-CLYDE-SUBSTITUTION CL:STRING> CLTL:STRING>)

(DEFINE-CLYDE-SUBSTITUTION CL:STRING>= CLTL:STRING>=)

(DEFINE-CLYDE-SUBSTITUTION CL:STRUCTURE CLTL:STRUCTURE)

(DEFINE-CLYDE-SUBSTITUTION CL:SUBLIS CLTL:SUBLIS)

(DEFINE-CLYDE-SUBSTITUTION CL:SUBST CLTL:SUBST)

(DEFINE-CLYDE-SUBSTITUTION CL:SUBST-IF CLTL:SUBST-IF)

(DEFINE-CLYDE-SUBSTITUTION CL:SUBST-IF-NOT CLTL:SUBST-IF-NOT)

(DEFINE-CLYDE-SUBSTITUTION CL:TIME CLTL:TIME)

(DEFINE-CLYDE-SUBSTITUTION CL:TRACE CLTL:TRACE)

(DEFINE-CLYDE-SUBSTITUTION CL:TRUENAME CLTL:TRUENAME)

(DEFINE-CLYDE-SUBSTITUTION CL:UNEXPORT CLTL:UNEXPORT)

(DEFINE-CLYDE-SUBSTITUTION CL:UNINTERN CLTL:UNINTERN)

(DEFINE-CLYDE-SUBSTITUTION CL:UNLESS CLTL:UNLESS)

(DEFINE-CLYDE-SUBSTITUTION CL:UNTRACE CLTL:UNTRACE)

(DEFINE-CLYDE-SUBSTITUTION CL:UNUSE-PACKAGE CLTL:UNUSE-PACKAGE)

(DEFINE-CLYDE-SUBSTITUTION CL:USE-PACKAGE CLTL:USE-PACKAGE)

(DEFINE-CLYDE-SUBSTITUTION CL:VECTOR-POP CLTL:VECTOR-POP)

(DEFINE-CLYDE-SUBSTITUTION CL:VECTOR-PUSH-EXTEND CLTL:VECTOR-PUSH-EXTEND)

(DEFINE-CLYDE-SUBSTITUTION CL:WHEN CLTL:WHEN)

(DEFINE-CLYDE-SUBSTITUTION CL:WITH-OPEN-FILE CLTL:WITH-OPEN-FILE)

(DEFINE-CLYDE-SUBSTITUTION CL:WRITE CLTL:WRITE)

(DEFINE-CLYDE-SUBSTITUTION CL:WRITE-TO-STRING CLTL:WRITE-TO-STRING)


;;;; The remainder of this file is a list of symbols that are part of Symbolics Common Lisp
;;;; and might want conversions, but don't have them.  None of these are both possible
;;;; and important to convert.

#||

;;; Things that are best converted by just implementing the function in a portable way

 ALPHALESSP
 ASCII-CODE			
 ASCII-TO-CHAR
 ASCII-TO-STRING

 BIT-VECTOR-CARDINALITY
 BIT-VECTOR-DISJOINT-P
 BIT-VECTOR-EQUAL
 BIT-VECTOR-POSITION
 BIT-VECTOR-SUBSET-P
 BIT-VECTOR-ZERO-P

 CHAR-TO-ASCII
 COPY-TREE-SHARE

 DEFSELECT
 DO-LOCAL-SYMBOLS

 EQUAL-TYPEP

 FQUERY

 MAP-INTO

 NLEFT
 NSTRING-CAPITALIZE-WORDS

 STRING-A-OR-AN
 STRING-CAPITALIZE-WORDS
 STRING-COMPARE
 STRING-EXACT-COMPARE
 STRING-NCONC
 STRING-NCONC-PORTION
 STRING-PLURALIZE

 STRING-TO-ASCII

 VECTOR-PUSH-PORTION-EXTEND

;;; Resources

 ALLOCATE-RESOURCE
 CLEAR-RESOURCE
 DEALLOCATE-RESOURCE
 DEALLOCATE-WHOLE-RESOURCE
 DEFRESOURCE
 MAP-RESOURCE
 USING-RESOURCE

;;; Initializations

 ADD-INITIALIZATION
 DELETE-INITIALIZATION
 INITIALIZATIONS
 RESET-INITIALIZATIONS


;;; Things that I haven't figured out how to convert

 *COMPILE-FILE-SET-DEFAULT-PATHNAME*
 *CURRENT-PROCESS*
 *DEFAULT-CONS-AREA*
 *LOAD-PATHNAME-DEFAULTS*
 *LOAD-SET-DEFAULT-PATHNAME*
 *PRINT-ABBREVIATE-QUOTE*
 *PRINT-ARRAY-LENGTH*
 *PRINT-BIT-VECTOR-LENGTH*
 *PRINT-EXACT-FLOAT-VALUE*
 *PRINT-INTEGER-LENGTH*
 *PRINT-PRETTY-PRINTER*
 *PRINT-READABLY*
 *PRINT-STRING-LENGTH*
 *PRINT-STRUCTURE-CONTENTS*

 2D-ARRAY-BLT

 ARGLIST
 ARGS-INFO

 BEEP
 BITBLT
 BOOLEAN				;a type and a presentation type
 BOUNDP-IN-CLOSURE

 CHAR-FAT-P
 CHAR-MOUSE-BITS
 CHAR-MOUSE-BUTTON
 CHAR-MOUSE-EQUAL

 CLOSURE-FUNCTION
 COPY-DYNAMIC-CLOSURE
 COPY-FILE

 DEBUGGING-INFO
 DECODE-RASTER-ARRAY
 DEFFUNCTION
 DEFINE-MODIFY-METHOD
 DEFINE-SYMBOL-MACRO
 DEFLAMBDA-MACRO
 DEFSTRUCT-DEFINE-TYPE
 DOCUMENTATION  		;CLTL:DOCUMENTATION
 DYNAMIC-CLOSURE-ALIST
 DYNAMIC-CLOSURE-VARIABLES

 FDEFINE			;SETF of FDEFINITION, except for the optional args
 FDEFINEDP			;FBOUNDP in ANSI CL
 FDEFINITION			;exists in ANSI CL
 FUNDEFINE			;FMAKUNBOUND in ANSI CL

 GC-IMMEDIATELY
 GLOBALIZE

 IN-PACKAGE  			;CLTL:IN-PACKAGE		???
 INHIBIT-STYLE-WARNINGS

 INTERN-LOCAL
 INTERN-LOCAL-SOFT

 LAMBDA-MACRO

 LET-AND-MAKE-DYNAMIC-CLOSURE
 LET-GLOBALLY
 LET-GLOBALLY-IF
 LET-IF
 LETF
 LETF*

 MAKE-AREA
 MAKE-CHARACTER
 MAKE-DYNAMIC-CLOSURE
 MAKE-HEAP
 MAKE-MOUSE-CHAR
 MAKE-PACKAGE  		;CLTL:MAKE-PACKAGE	;we have a buncha extensions
 MAKUNBOUND-GLOBALLY
 MAKUNBOUND-IN-CLOSURE
 MODIFY-HASH
 MOUSE-CHAR-P

 PACKAGE-EXTERNAL-SYMBOLS
 PKG-ADD-RELATIVE-NAME
 PKG-DELETE-RELATIVE-NAME

 PROGW

 RANDOM-NORMAL
 READ-DELIMITED-STRING
 READ-LINE-NO-ECHO
 READ-LINE-TRIM
 READ-OR-END
 RECORD-SOURCE-FILE-NAME
 REMOVE-PROCLAIMS

 SET-CHARACTER-TRANSLATION

 SORT-GROUPED-ARRAY
 SORT-GROUPED-ARRAY-GROUP-KEY

 STREAM-COPY-UNTIL-EOF

 STRING-FAT-P
 STRING-THIN

 SWAPHASH
 SYMBOL-VALUE-GLOBALLY
 SYMBOL-VALUE-IN-CLOSURE
 TABLE-SIZE

 TIME-DIFFERENCE
 TIME-ELAPSED-P
 TIME-INCREMENT
 TIME-LESSP
 UNBOUND-LOGIC-VARIABLE
 UNDELETE-FILE

 VARIABLE-BOUNDP
 VARIABLE-MAKUNBOUND


;;; Things that don't need to be converted

 ASH		;CLTL:ASH		no float allowed as first arg in CLtL

 ASSOC-IF	;CLTL:ASSOC-IF		no :KEY in CLtL, but ANSI CL allows it
 ASSOC-IF-NOT	;CLTL:ASSOC-IF-NOT
 RASSOC-IF	;CLTL:RASSOC-IF
 RASSOC-IF-NOT	;CLTL:RASSOC-IF-NOT

 CHAR-EQUAL	;CLTL:CHAR-EQUAL		CLtL says to ignore bits, ANSI CL doesn't
 CHAR-GREATERP	;CLTL:CHAR-GREATERP
 CHAR-LESSP	;CLTL:CHAR-LESSP
 CHAR-NOT-EQUAL	;CLTL:CHAR-NOT-EQUAL
 CHAR-NOT-GREATERP	;CLTL:CHAR-NOT-GREATERP
 CHAR-NOT-LESSP	;CLTL:CHAR-NOT-LESSP

 DEFSTRUCT	;CLTL:DEFSTRUCT	??
 EVAL		;CLTL:EVAL		only allows one argument

 GET-SETF-METHOD		;CLTL:GET-SETF-METHOD	no optional for-effect argument
 GET-SETF-METHOD-MULTIPLE-VALUE	;CLTL:GET-SETF-METHOD-MULTIPLE-VALUE		..

 LEAST-NEGATIVE-NORMALIZED-DOUBLE-FLOAT		;in ANSI Common Lisp
 LEAST-NEGATIVE-NORMALIZED-LONG-FLOAT
 LEAST-NEGATIVE-NORMALIZED-SHORT-FLOAT
 LEAST-NEGATIVE-NORMALIZED-SINGLE-FLOAT
 LEAST-POSITIVE-NORMALIZED-DOUBLE-FLOAT
 LEAST-POSITIVE-NORMALIZED-LONG-FLOAT
 LEAST-POSITIVE-NORMALIZED-SHORT-FLOAT
 LEAST-POSITIVE-NORMALIZED-SINGLE-FLOAT

 LOAD	;CLTL:LOAD		no :PACKAGE keyword.  Other differences?
 OPEN	;CLTL:OPEN		default :ELEMENT-TYPE (ANSI vs CLtL), nonstandard options

 PRIN1	;CLTL:PRIN1		because of the defvar, the functions are the same

 SLEEP	;CLTL:SLEEP			:SLEEP-REASON

;CL Dev forbids character-to-string, pathname-to-string coercion on these
;It's probably not possible for a conversion tool to detect that, so punt
;CL Developer bug, CLtL says to ignore bits, ANSI CL doesn't, CL Dev doesn't
 STRING-CAPITALIZE	;CLTL:STRING-CAPITALIZE
 STRING-DOWNCASE	;CLTL:STRING-DOWNCASE
 STRING-EQUAL		;CLTL:STRING-EQUAL
 STRING-GREATERP	;CLTL:STRING-GREATERP
 STRING-LEFT-TRIM	;CLTL:STRING-LEFT-TRIM
 STRING-LESSP		;CLTL:STRING-LESSP
 STRING-NOT-EQUAL	;CLTL:STRING-NOT-EQUAL
 STRING-NOT-GREATERP	;CLTL:STRING-NOT-GREATERP
 STRING-NOT-LESSP	;CLTL:STRING-NOT-LESSP
 STRING-RIGHT-TRIM	;CLTL:STRING-RIGHT-TRIM
 STRING-TRIM	;CLTL:STRING-TRIM
 STRING-UPCASE	;CLTL:STRING-UPCASE
 STRING/=	;CLTL:STRING/=
 STRING<	;CLTL:STRING<
 STRING<=	;CLTL:STRING<=
 STRING=	;CLTL:STRING=
 STRING>	;CLTL:STRING>
 STRING>=	;CLTL:STRING>=

;A type-specifier that doesn't exist in CL?
 STRUCTURE	;CLTL:STRUCTURE

 WITH-OPEN-FILE	;CLTL:WITH-OPEN-FILE		see OPEN



;;; Only intended to be called interactively

 *APROPOS-LIST*
 ADVISE
 ADVISE-WITHIN
 BREAKON
 DESCRIBE	;CLTL:DESCRIBE
 DESCRIBE-AREA
 DESCRIBE-DEFSTRUCT
 DESCRIBE-FUNCTION
 DESCRIBE-PACKAGE
 DESCRIBE-SYSTEM
 DISASSEMBLE	;CLTL:DISASSEMBLE
 DRIBBLE	;CLTL:DRIBBLE
 GRINDEF
 INSPECT	;CLTL:INSPECT
 LOGIN-FORMS
 MEXP
 PKG-KILL
 PRINT-COMPILER-WARNINGS
 PRINT-SENDS
 ROOM	;CLTL:ROOM
 STEP-FORM
 STEP-VALUE
 STEP-VALUES
 TIME	;CLTL:TIME
 TRACE	;CLTL:TRACE
 UNADVISE
 UNADVISE-WITHIN
 UNBREAKON
 UNCOMPILE
 UNDEFUN
 UNTRACE	;CLTL:UNTRACE
 WHAT-FILES-CALL
 WHERE-IS
 WHO-CALLS
 WHO-USES

;;; SCT

 COMPILE-SYSTEM
 DEFSUBSYSTEM
 DEFSYSTEM
 LOAD-PATCHES
 LOAD-SYSTEM
 NOTE-PRIVATE-PATCH

;;; Flavors (we already have a Flavors to CLOS conversion tool)

 BOUNDP-IN-INSTANCE
 CHANGE-INSTANCE-FLAVOR
 COMPILE-FLAVOR-METHODS
 CONTINUE-WHOPPER
 DEFFLAVOR
 DEFGENERIC
 DEFINE-METHOD-COMBINATION
 DEFINE-SIMPLE-METHOD-COMBINATION
 DEFMACRO-IN-FLAVOR
 DEFMETHOD
 DEFSUBST-IN-FLAVOR
 DEFUN-IN-FLAVOR
 DEFWHOPPER
 DEFWHOPPER-SUBST
 DEFWRAPPER
 FLAVOR-ALLOWS-INIT-KEYWORD-P
 GET-HANDLER-FOR
 INSTANCE
 INSTANCEP
 LEXPR-CONTINUE-WHOPPER
 LEXPR-SEND
 LEXPR-SEND-IF-HANDLES
 MAKE-INSTANCE
 OPERATION-HANDLED-P
 RECOMPILE-FLAVOR
 SELF
 SEND
 SEND-IF-HANDLES
 SYMBOL-VALUE-IN-INSTANCE

;;; Locatives and forwarding

 DEFLOCF
 FOLLOW-CELL-FORWARDING
 FOLLOW-STRUCTURE-FORWARDING
 FORWARD-VALUE-CELL
 LOCATION-BOUNDP
 LOCATION-CONTENTS
 LOCATION-MAKUNBOUND
 LOCATIVE
 LOCATIVEP
 LOCF
 STORE-CONDITIONAL
 STRUCTURE-FORWARD

;;; Array leaders and other array extensions

 ARRAY-HAS-LEADER-P
 ARRAY-LEADER
 ARRAY-LEADER-LENGTH
 ARRAY-LEADER-LENGTH-LIMIT
 COPY-ARRAY-CONTENTS-AND-LEADER
 G-L-P
 LIST-ARRAY-LEADER
 NAMED-STRUCTURE-INVOKE
 NAMED-STRUCTURE-P
 NAMED-STRUCTURE-SYMBOL

;;; Planes

 MAKE-PLANE
 PLANE-AREF
 PLANE-DEFAULT
 PLANE-EXTENSION

;;; Dynamic Windows

 ABBREVIATING-OUTPUT
 ACCEPT
 ACCEPT-FROM-STRING
 ALIST-MEMBER
 CHARACTER-FACE-OR-STYLE
 CHARACTER-STYLE
 CHARACTER-STYLE-FOR-DEVICE
 DEFINE-CP-COMMAND
 DEFINE-PRESENTATION-ACTION
 DEFINE-PRESENTATION-TO-COMMAND-TRANSLATOR
 DEFINE-PRESENTATION-TRANSLATOR
 DEFINE-PRESENTATION-TYPE
 FILLING-OUTPUT
 FORMAT-CELL
 FORMAT-GRAPH-FROM-ROOT
 FORMAT-ITEM-LIST
 FORMAT-SEQUENCE-AS-TABLE-ROWS
 FORMAT-TEXTUAL-LIST
 FORMATTING-CELL
 FORMATTING-COLUMN
 FORMATTING-COLUMN-HEADINGS
 FORMATTING-GRAPH
 FORMATTING-GRAPH-NODE
 FORMATTING-ITEM-LIST
 FORMATTING-MULTIPLE-COLUMNS
 FORMATTING-ROW
 FORMATTING-TABLE
 FORMATTING-TEXTUAL-LIST
 FORMATTING-TEXTUAL-LIST-ELEMENT
 INDENTING-OUTPUT
 INVERTED-BOOLEAN
 NULL-OR-TYPE
 PRESENT
 PRESENT-TO-STRING
 PROMPT-AND-ACCEPT
 SEQUENCE-ENUMERATED
 SUBSET
 SURROUNDING-OUTPUT-WITH-BORDER
 TOKEN-OR-TYPE
 TYPE-OR-STRING
 WITH-CHARACTER-FACE
 WITH-CHARACTER-FAMILY
 WITH-CHARACTER-SIZE
 WITH-CHARACTER-STYLE
 WITH-INPUT-EDITING
 WITH-INPUT-EDITING-OPTIONS
 WITH-INPUT-EDITING-OPTIONS-IF
 WITH-UNDERLINING

;;; Processes and Stack Groups

 MAKE-PROCESS
 MAKE-STACK-GROUP
 PROCESS-ABORT
 PROCESS-ACTIVE-P
 PROCESS-ALLOW-SCHEDULE
 PROCESS-DISABLE
 PROCESS-DISABLE-ARREST-REASON
 PROCESS-DISABLE-RUN-REASON
 PROCESS-ENABLE
 PROCESS-ENABLE-ARREST-REASON
 PROCESS-ENABLE-RUN-REASON
 PROCESS-FLUSH
 PROCESS-INITIAL-FORM
 PROCESS-INITIAL-STACK-GROUP
 PROCESS-INTERRUPT
 PROCESS-KILL
 PROCESS-LOCK
 PROCESS-NAME
 PROCESS-PRESET
 PROCESS-PRIORITY
 PROCESS-QUANTUM
 PROCESS-QUANTUM-REMAINING
 PROCESS-RESET
 PROCESS-RESET-AND-ENABLE
 PROCESS-RUN-FUNCTION
 PROCESS-SIMPLE-P
 PROCESS-STACK-GROUP
 PROCESS-UNLOCK
 PROCESS-WAIT
 PROCESS-WAIT-ARGUMENT-LIST
 PROCESS-WAIT-FOREVER
 PROCESS-WAIT-FUNCTION
 PROCESS-WAIT-WITH-TIMEOUT
 PROCESS-WARM-BOOT-ACTION
 PROCESS-WHOSTATE
 SET-PROCESS-WAIT
 STACK-GROUP-PRESET
 STACK-GROUP-RESUME
 STACK-GROUP-RETURN
 SYMBOL-VALUE-IN-STACK-GROUP
 WITHOUT-INTERRUPTS

;;; Silly user-options facility

 CHOOSE-USER-OPTIONS
 DEFINE-USER-OPTION
 DEFINE-USER-OPTION-ALIST
 RESET-USER-OPTIONS
 WRITE-USER-OPTIONS

;;; Pre-DW version of ACCEPT
;;; We could write conversions for these if anyone still uses them

 DEFINE-PROMPT-AND-READ-TYPE
 PROMPT-AND-READ

||#
