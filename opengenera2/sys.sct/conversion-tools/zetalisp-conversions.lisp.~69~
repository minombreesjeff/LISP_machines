;;; -*- Mode: LISP; Syntax: Common-lisp; Package: conversion-tools; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(define-conversion-set zlcl
		       define-zetalisp-symbol-conversion
		       define-zetalisp-function-conversion
		       :funarg-macro define-zetalisp-funarg-conversion
		       :pretty-name "Zetalisp to Common LISP"
		       :search-strings '("ZL:" "SYS:" "SI:" "FS:"))

(define-zetalisp-symbol-conversion zl:*catch cl:catch)

(define-zetalisp-function-conversion zl:*throw (tag value)
  :modification-depth 3
  :form (if (constantp tag)
	    `(cl:throw ,tag (values ,value ,tag))
	    (let ((tagvar (gentemp "TAG")))
	      `(let ((,tagvar ,tag))
		 (cl:throw ,tagvar (values ,value ,tagvar))))))

(define-zetalisp-function-conversion zl:*throw (tag values)
  :name modernize-*throw
  :documentation "To be able to throw multiple values (but not throw the tag as ZL would)"
  :form `(cl:throw ,tag ,values))

(define-zetalisp-symbol-conversion zl:+$ cl:+)
(define-zetalisp-symbol-conversion zl:-$ cl:-)
(define-zetalisp-symbol-conversion zl:*$ cl:*)

(define-zetalisp-function-conversion zl:/ (&rest numbers)
  (unless (manifestly-floating-point numbers)
    `(cl:floor . ,numbers)))

(define-zetalisp-function-conversion zl:/ (&rest numbers)
  :name divide-use-truncate
  :documentation "To get FORTRAN style rounding with negative numbers"
  :form (unless (manifestly-floating-point numbers)
	  `(cl:truncate . ,numbers)))

(define-zetalisp-function-conversion zl:/ (&rest numbers)
  :name divide-use-/
  :documentation "To get exact rational division or for dividing floats"
  :form `(cl:/ . ,numbers))

(defun manifestly-floating-point (numbers)
  (some (lambda (form) (and (constantp form) (floatp (eval form)))) numbers))

(define-zetalisp-symbol-conversion zl:/$ cl:/)
(define-zetalisp-symbol-conversion zl:1+$ cl:1+)
(define-zetalisp-symbol-conversion zl:1-$ cl:1-)
(define-zetalisp-symbol-conversion zl:add1 cl:1+)

(define-zetalisp-function-conversion zl:adjust-array-size (array new-length)
  `(cl:adjust-array ,array ,new-length))

(define-zetalisp-function-conversion zl:aloc (array &rest subscripts)
  `(locf (aref ,array . ,subscripts)))

(define-zetalisp-function-conversion zl:ap-1 (array sub)
  `(locf (aref ,array ,sub)))

(define-zetalisp-function-conversion zl:ap-2 (array sub1 sub2)
  `(locf (aref ,array ,sub1 ,sub2)))

(define-zetalisp-function-conversion zl:ap-leader (array index)
  `(locf (array-leader ,array ,index)))

(define-zetalisp-symbol-conversion zl:append-to-array scl:vector-push-portion-extend)
(define-zetalisp-symbol-conversion zl:apply cl:apply)
(define-zetalisp-symbol-conversion zl:ar-1 cl:aref)
(define-zetalisp-symbol-conversion zl:ar-2 cl:aref)

(define-zetalisp-function-conversion zl:argument-typecase (form &rest types)
  :form `(cl:etypecase ,form . ,(typecase-convert-types types))
  :modification-depth 2)

(define-zetalisp-symbol-conversion zl:array-#-dims cl:array-rank)
(define-zetalisp-symbol-conversion zl:array-active-length cl:length)

(define-zetalisp-function-conversion zl:array-dimension-n (index array)
  (cond ((eql index 0)
	 `(array-leader-length ,array))
	((integerp index)
	 `(cl:array-dimension ,array ,(1- index)))))

(define-zetalisp-symbol-conversion zl:array-length cl:array-total-size)
(define-zetalisp-symbol-conversion zl:array-pop cl:vector-pop)

(define-zetalisp-function-conversion zl:array-push (array thing)
  `(cl:vector-push ,thing ,array))

(define-zetalisp-function-conversion zl:array-push-extend (array thing)
  `(cl:vector-push-extend ,thing ,array))

(define-zetalisp-symbol-conversion zl:array-push-portion-extend
				   scl:vector-push-portion-extend)

(define-zetalisp-function-conversion zl:as-1 (value array index)
  `(cl:setf (aref ,array ,index) ,value))

(define-zetalisp-function-conversion zl:as-2 (value array index1 index2)
  `(cl:setf (aref ,array ,index1 ,index2) ,value))

(define-zetalisp-function-conversion zl:aset (value array &rest indices)
  `(cl:setf (aref ,array . ,indices) ,value))

(define-zetalisp-function-conversion zl:ass (pred item list)
  (item-pred-use-test-and-key `(cl:assoc ,item ,list) pred))

(defparameter *commutative-test-functions*
	      '(eq eql equal zl:equal equalp =  /=
		string-equal zl:string-equal string= zl:string=
		string-not-equal zl:string-not-equal string zl:string string/=
		sys:%string-equal sys:%string=
		char= char-equal char-not-equal char char/= char-mouse-equal
		tree-equal equal-typep bit-vector-equal))

;; Append :test and :key arguments to form instead of using :test #'(lambda ...)
(defun item-pred-use-test-and-key (form predicate)
  (when (and (consp predicate) (eq (car predicate) 'lambda))
    (setq predicate `(function ,predicate)))
  (or (destructuring-bind-carefully (function (lambda (x y) (f x1 (g y1)))) predicate
	(and (eq function 'function)
	     (eq lambda 'lambda)
	     (eq x1 x)
	     (eq y1 y)
	     (append form `(:test #',f :key #',g))))
      (destructuring-bind-carefully (function (lambda (x y) (f (g y1) x1))) predicate
	(and (eq function 'function)
	     (eq lambda 'lambda)
	     (eq x1 x)
	     (eq y1 y)
	     ;; f must be commutative
	     (member f *commutative-test-functions*)
	     (append form `(:test #',f :key #',g))))
      (append form `(:test ,predicate))))

(defmacro define-zetalisp-equal-conversion (zl-function template (test-var) form)
  `(progn
     . ,(loop for (test doc) in
	  '((cl:equal "Use EQUAL for comparing lists")
	    (cl:equalp "Use EQUALP so that string case will be ignored")
	    (nil "Use EQL, since EQUAL was used only for comparing numbers correctly"))
	      collect `(define-zetalisp-function-conversion ,zl-function ,template
			 :name ,(fintern "~A-USE-~A" zl-function (or test 'eql))
			 :documentation ,doc :documentation-level 2
			 :form (let ((,test-var ',test))
				 ,form)))))

;; Returns true if this test is stupid (possible tests are equal, equalp, or nil [eql])
(defun check-for-stupid-equal-test (test item &optional list key)
  (flet ((stupidp (value)
	   (typecase value
	     ((or number symbol) (member test '(equal equalp)))
	     (character (eq test 'equal))
	     (list (or (eq test 'nil)
		       (and (eq test 'equalp)
			    (loop for item in value
				  always (typep item '(or number symbol))))))
	     (string (member test '(nil equal))))))
    (or (and (constantp item) (stupidp (eval item)))
	(and (constantp list)
	     (setq list (eval list))		;doesn't count if empty
	     (loop for item in list
		   always (if key
			      (and (consp item) (stupidp (funcall key item)))
			      (stupidp item)))))))

;; Returns true if this test is stupid (possible tests are equal, equalp, or nil [eql])
(defun check-for-stupid-equal (test item1 item2)
  (flet ((stupidp (value)
	   (typecase value
	     ((or number symbol) (member test '(equal equalp)))
	     (character (eq test 'equal))
	     (list (or (eq test 'nil)
		       (and (eq test 'equalp)
			    (loop for item in value
				  always (typep item '(or number symbol))))))
	     (string (member test '(nil equal))))))
    (or (and (constantp item1) (stupidp (eval item1)))
	(and (constantp item2) (stupidp (eval item2))))))

(define-zetalisp-equal-conversion zl:assoc (item list) (test)
  ;; Check whether this test is stupid for these arguments
  (unless (check-for-stupid-equal-test test item list #'car)
    (if test
	`(cl:assoc ,item ,list :test #',test)
	`(cl:assoc ,item ,list))))

(define-zetalisp-symbol-conversion zl:assq cl:assoc)
(define-zetalisp-symbol-conversion zl:atan cl:atan)
(define-zetalisp-symbol-conversion zl:atan2 cl:atan)
(define-zetalisp-symbol-conversion zl:base cl:*print-base*)

(define-zetalisp-function-conversion zl:bigp (number)
  `(cl:typep ,number 'cl:bignum))
  
(define-zetalisp-symbol-conversion zl:bit-test cl:logtest)

(define-zetalisp-function-conversion zl:car-location (list)
  `(locf (car ,list)))

(defun selectq-convert (item clauses)
  (let ((clause (assoc 't clauses)))
    (when clause
      (setq clauses (append (remove clause clauses) `((otherwise . ,(rest clause)))))))
  (let ((clause (assoc 'nil clauses)))
    (when clause
      (let ((sub (member clause clauses)))
	(setq clauses (append (ldiff clauses sub)
			      (list (cons '(nil) (rest clause)))
			      (rest sub))))))
  `(case ,item . ,clauses))

(define-zetalisp-function-conversion zl:caseq (item &rest clauses)
  :form (selectq-convert item clauses)
  :modification-depth 2)

#|| ;Finds candidates for type predicate cognates.
    ;I used this code to help seed the list which follows.

 (let ((l '()))
   (dolist (package '("SCL" "GLOBAL"))
     (do-external-symbols (s package)
       (let* ((name (symbol-name s))
	      (len (string-length name))
	      (last-char (aref name (1- len))))
	 (when (and (eql last-char #\P) 
		    (find-symbol (substring name 0 (1- len)) "SCL"))
	   (pushnew s l)))))
   (sort l #'string-lessp))

||#

(defvar *predicate-conversions*
	'((arrayp       array)
	  (characterp   character)
	  (commonp      common)
	  (complexp     complex)
	  (consp        cons)
	  (errorp       error)
	  (sys:fixnump  fixnum)
	  (floatp       float)
	  (functionp    function)
	  (instancep    instance)
	  (integerp     integer)
	  (keywordp     keyword)
	  (zl:listp     cons) ;!
	  (listp        list)
	  (locativep    locative)
	  (not          null)
	  (null         null)
	  (numberp      number)
	  (packagep     package)
	  (pathnamep    pathname)
	  (zl:rationalp ratio) ;!
	  (rationalp    rational)
	  (readtablep   readtable)
	  (streamp      stream)
	  (stringp      string)
	  (symbolp      symbol)
	  (vectorp      vector)))

(define-zetalisp-function-conversion zl:check-arg (place check type-string)
  ;; Can't use BLOCK...RETURN-FROM due to compiler bug (reported). -kmp 16-Oct-92
  (catch 'fail
    (flet ((fail (n form) n form (throw 'fail nil)))
      (labels ((convert-to-type (predicate)
		 (let ((entry (assoc predicate *predicate-conversions*)))
		   (if entry (cadr entry) `(satisfies ,predicate))))
	       (convert-to-type-recursively (form &optional recursing-p)
		 (cond ((consp form)
			(cond ((and (symbolp (car form))
				    (cdr form)
				    (null (cddr form))
				    (equal (cadr form) place))
			       (convert-to-type (car form)))
			      ((member (car form) '(and or not))
			       (cons (car form)
				     (mapcar #'(lambda (x) (convert-to-type-recursively x t))
					     (cdr form))))
			      (t (fail 1 form))))
		       ((not recursing-p) (convert-to-type form))
		       (t (fail 2 form))))
	       (compute-type-description (type)
		 (with-output-to-string (str) (sys:print-type-description type str))))
	(let* ((type (convert-to-type-recursively check))
	       (desc (compute-type-description type)))
	  (when (string-equal desc type-string) (setq type-string nil))
	  (if type-string 
	      `(cl:check-type ,place ,type ,type-string)
	      `(cl:check-type ,place ,type)))))))

(defparameter *typep-conversions*
  '((:array array) (:atom atom) (:bignum bignum) (:character character)
    (:closure sys:dynamic-closure) (:compiled-function compiled-function) (:complex complex)
    (:double-float double-float) (:extended-number (or ratio double-float bignum))
    (:fix integer) (:fixnum fixnum) (:float float) 
    (:generic-function sys:generic-function) (:instance instance) (:list cons)
    (:list-or-nil list) (:locative locative) (:non-complex-number (and number (not complex)))
    (:non-negative-fixnum (integer 0)) (:null null) (:number number)
    (:positive-fixnum (integer (0))) (:rational ratio) (:single-float single-float)
    (:stack-group sys:stack-group) (:string string) (:symbol symbol)
    (:lexical-closure sys:lexical-closure)))

(defun convert-type-form (form &optional evaluated)
  (flet ((convert-symbol (symbol)
	   (let ((entry (assoc symbol *typep-conversions*)))
	     (when entry
	       (if evaluated
		   `',(cadr entry)
		   (cadr entry))))))
    (or (convert-symbol
	  (if (and evaluated (consp form) (eq (first form) 'quote))
	      (second form)
	      form))
	form)))

(define-zetalisp-function-conversion zl:check-arg-type (place type
							&optional (type-string nil stringp))
  `(cl:check-type ,place ,(convert-type-form type) ,@(and stringp `(,type-string))))

(define-zetalisp-function-conversion zl:close (stream &optional (abort nil abort-p))
  (if abort-p
      `(cl:close ,stream :abort ,abort)
      `(cl:close ,stream)))

(define-zetalisp-symbol-conversion zl:clrhash-equal cl:clrhash)
(define-zetalisp-symbol-conversion zl:copyalist cl:copy-alist)
(define-zetalisp-symbol-conversion zl:copyf scl:copy-file)
(define-zetalisp-symbol-conversion zl:copylist cl:copy-list)
(define-zetalisp-function-conversion zl:copylist* (list &optional area)
  `(cl:copy-list ,list ,area t))

(define-zetalisp-symbol-conversion zl:copysymbol cl:copy-symbol)
(define-zetalisp-symbol-conversion zl:copytree cl:copy-tree)
(define-zetalisp-symbol-conversion zl:copytree-share scl:copy-tree-share)
(define-zetalisp-symbol-conversion zl:debug-io cl:*debug-io*)
(define-zetalisp-symbol-conversion zl:defconst cl:defparameter)
(define-zetalisp-symbol-conversion zl:defmacro-displace cl:defmacro)
(define-zetalisp-symbol-conversion zl:defpackage scl:defpackage)

(define-zetalisp-function-conversion zl:defunp (function args &rest body)
  `(defun ,function ,args (prog () (return (progn . ,body)))))

(define-zetalisp-function-conversion zl:del (pred item list &optional (ntimes nil ntimes-p))
  (if ntimes-p
      (item-pred-use-test-and-key `(cl:delete ,item ,list :count ,ntimes) pred)
      (item-pred-use-test-and-key `(cl:delete ,item ,list) pred)))

(define-zetalisp-symbol-conversion zl:del-if cl:delete-if)
(define-zetalisp-symbol-conversion zl:del-if-not cl:delete-if-not)

(define-zetalisp-equal-conversion zl:delete (item list &optional (ntimes nil ntimes-p)) (test)
  ;; Check whether this test is stupid for these arguments
  (unless (check-for-stupid-equal-test test item)
    (if test
	(if ntimes-p
	    `(cl:delete ,item ,list :test #',test :ntimes ,ntimes)
	    `(cl:delete ,item ,list :test #',test))
	(if ntimes-p
	    `(cl:delete ,item ,list :ntimes ,ntimes)
	    `(cl:delete ,item ,list)))))

(define-zetalisp-symbol-conversion zl:deletef cl:delete-file)

(define-zetalisp-function-conversion zl:delq (item list &optional (ntimes nil ntimes-p))
  (if ntimes-p
      `(cl:delete ,item ,list :count ,ntimes)
      `(cl:delete ,item ,list)))

(define-zetalisp-symbol-conversion zl:destructuring-bind scl:destructuring-bind)
(define-zetalisp-function-conversion zl:dfloat (x)
  `(cl:float ,x 0.0d0))

(define-zetalisp-symbol-conversion zl:difference cl:-)
(define-zetalisp-symbol-conversion zl:dolist cl:dolist)
(define-zetalisp-symbol-conversion zl:dotimes cl:dotimes)

(define-zetalisp-function-conversion si:eliminate-duplicates (list
							      &optional (predicate nil predp))
 (progn
  (when (and predp (consp predicate) (eq (car predicate) 'lambda))
    (setq predicate `(function ,predicate)))
  (cond ((not predp)
	 `(cl:delete-duplicates ,list))
	((destructuring-bind-carefully (function (lambda (x y) (f (g x1) (g1 y1)))) predicate
	   (and (eq function 'function)
		(eq lambda 'lambda)
		(eq x1 x)
		(eq y1 y)
		(eq g1 g)
		`(cl:delete-duplicates ,list :test #',f :key #',g))))
	(t
	 `(cl:delete-duplicates ,list :test ,predicate)))))

(define-zetalisp-equal-conversion zl:equal (x y) (test)
  ;; Check whether this test is stupid for these arguments
  (unless (check-for-stupid-equal test x y)
    `(,(or test `eql) ,x ,y)))

(define-zetalisp-funarg-conversion zl:equal
  :name funarg-equal-use-equal
  :documentation "Use EQUAL for comparing lists" :documentation-level 2
  :new-function cl:equal)

(define-zetalisp-funarg-conversion zl:equal
  :name funarg-equal-use-equalp
  :documentation "Use EQUALP so that string case will be ignored" :documentation-level 2
  :new-function cl:equalp)

(define-zetalisp-funarg-conversion zl:equal
  :name funarg-equal-use-eql
  :documentation "Use EQL, since EQUAL was used only for comparing numbers correctly"
  :documentation-level 2
  :new-function cl:eql)

(define-zetalisp-symbol-conversion zl:error-output cl:*error-output*)

;;; ZL version takes more arguments, so we use an explicit template to get the error
;;; checking which will suppress the conversion when the extra argument is given.
(define-zetalisp-function-conversion zl:every (list pred)
  `(cl:every ,pred ,list))

(define-zetalisp-symbol-conversion zl:expt cl:expt)

(defun convert-format-string (string)
  (if (not (stringp string)) string
      (let ((new-string nil)
	    (output-index 0)
	    (index 0))
	(flet ((output-string (&optional index)
		 (when (or index new-string)
		   (when (null new-string)
		     (setq new-string (make-array (length string) :fill-pointer 0
						  :element-type (array-element-type string))))
		   (vector-push-portion-extend new-string string output-index index)
		   (setq output-index index))))
	  (loop doing
	    (let ((next-index (string-search-char #\~ string :start index)))
	      (when (null next-index)
		(return))
	      (setq index (string-search-not-set ":@" string :start (1+ next-index)))
	      (when (null index)
		(return))
	      (setq next-index (string-search-not-set "0123456789V" string :start index))
	      (when (null next-index)
		(return))
	      (setq next-index (string-search-not-set ":@" string :start next-index))
	      (when (null next-index)
		(return))
	      (selector (aref string next-index) char-equal
		(#\G
		 (output-string next-index)
		 (string-nconc new-string "@*")
		 (incf output-index))
		((#\E #\F)
		 (let ((num (parse-integer string :start index :end next-index
					   :junk-allowed t)))
		   (when num
		     (output-string index)
		     (string-nconc new-string (format nil "~D" (1+ num)))
		     (setq output-index next-index))))
		(#\X
		 (output-string next-index)
		 (string-nconc new-string "@T")
		 (incf output-index)))
	      (setq index (1+ next-index))))
	  (output-string)
	  (or new-string string)))))

(define-zetalisp-function-conversion zl:ferror (format-string &rest format-args)
  (progn
    ;; Compatibility for old FERROR
    (or format-string (setq format-string (pop format-args)))
    `(cl:error ,(convert-format-string format-string) . ,format-args)))

(define-zetalisp-function-conversion zl:fillarray (&rest args)
  :name fillarray-no-change
  :documentation "If the array is multi-dimensional (there is no CL equivalent)"
  :form `(zl:fillarray . ,args))

(define-zetalisp-function-conversion zl:fillarray (array source)
  :documentation "If the array is one-dimensional"
  :form (when (and (consp source)
		   (eq (car source) 'quote)
		   (consp (cadr source))
		   (= (length (cadr source)) 1))
	  `(cl:fill ,array ,(let ((element (caadr source)))
			      (if (and (atom element) (constantp element))
				  element
				  `',element)))))

(define-zetalisp-symbol-conversion zl:find-position-in-list cl:position)

(define-zetalisp-equal-conversion zl:find-position-in-list-equal (item list) (test)
  ;; Check whether this test is stupid for these arguments
  (unless (check-for-stupid-equal-test test item list)
    (if test
	`(cl:position ,item ,list :test #',test)
	`(cl:position ,item ,list))))

(define-zetalisp-function-conversion zl:firstn (n list)
  `(cl:subseq ,list 0 ,n))

(define-zetalisp-symbol-conversion zl:fix cl:floor)

(define-zetalisp-function-conversion zl:fixnump (x)
  `(cl:typep ,x 'cl:fixnum))

(define-zetalisp-symbol-conversion zl:fixp cl:integerp)

(define-zetalisp-symbol-conversion zl:fixr cl:round)

(define-zetalisp-symbol-conversion zl:float cl:float)

(define-zetalisp-function-conversion zl:flonump (x)
  `(cl:typep ,x 'cl:float))

(define-zetalisp-function-conversion zl:format (destination format-string &rest format-args)
  `(cl:format ,destination ,(convert-format-string format-string) . ,format-args))

(define-zetalisp-function-conversion zl:fset (symbol definition)
  `(cl:setf (cl:symbol-function ,symbol) ,definition))

(define-zetalisp-function-conversion zl:fsignal (&rest args)
  `(cl:cerror "Proceed without any special action" ,@args))

(define-zetalisp-symbol-conversion zl:fsymeval cl:symbol-function)

(define-zetalisp-function-conversion zl:funcall-self (&rest args)
  `(send self ,@args))

(define-zetalisp-function-conversion zl:function-cell-location (symbol)
  `(locf (cl:symbol-function ,symbol)))

(define-zetalisp-symbol-conversion zl:function-documentation cl:documentation)
(define-zetalisp-symbol-conversion zl:gcd cl:gcd)
(define-zetalisp-symbol-conversion zl:gensym cl:gensym)

(define-zetalisp-function-conversion zl:get (symbol indicator)
  (cond ((and (consp symbol) (eq (first symbol) 'locf))
	 `(cl:getf ,(second symbol) ,indicator))
	((and (consp symbol)
	      (eq (first symbol) 'quote)
	      (or (consp (second symbol))
		  ;; This next one is pathological but handle anyway.
		  ;; Could happen in cases like (ZL:GET '#.*SOME-LOCATIVE* ...)
		  (typep (second symbol) 'locative)))
	 `(cl:getf (cdr ,symbol) ,indicator))
	(t
	 `(cl:get ,symbol ,indicator))))

(define-zetalisp-function-conversion zl:get (plist indicator)
  :documentation "For use with disembodied property lists"
  :name get-disembodied
  :form (unless (or (and (consp plist) (eq (first plist) 'locf))
		    (and (consp plist) (eq (first plist) 'quote)
			 ;; Don't do this test here because if arg was quoted, the
			 ;; previous rewrite rule already reliably chose the right thing.
			 ;(consp (second plist)) 
			 ))
	  `(cl:getf (cdr ,plist) ,indicator)))

(define-zetalisp-symbol-conversion zl:get-pname cl:symbol-name)

(define-zetalisp-symbol-conversion zl:gethash cl:gethash)
(define-zetalisp-symbol-conversion zl:gethash-equal cl:gethash)
(define-zetalisp-symbol-conversion zl:greaterp cl:>)
(define-zetalisp-symbol-conversion zl:haulong cl:integer-length)
(define-zetalisp-symbol-conversion zl:ibase cl:*read-base*)
(define-zetalisp-symbol-conversion zl:intern cl:intern)

(define-zetalisp-function-conversion zl:intersection (list1 list2)
  `(cl:intersection ,list1 ,list2))

(define-zetalisp-symbol-conversion zl:length cl:length)
(define-zetalisp-symbol-conversion zl:lessp cl:<)
(define-zetalisp-symbol-conversion zl:lexpr-funcall cl:apply)

(define-zetalisp-function-conversion zl:lexpr-funcall-self (&rest args)
  `(apply self ,@args))

(define-zetalisp-function-conversion zl:listarray (&rest args)
  :name listarray-no-change
  :documentation "If the array is multi-dimensional (there is no CL equivalent)"
  :form `(zl:listarray . ,args))

(define-zetalisp-function-conversion zl:listarray (array &optional (limit nil limit-p))
  :documentation "If the array is one-dimensional"
  :form (if limit-p
	    `(cl:coerce (cl:subseq array 0 ,limit) 'cl:list)
	    `(cl:coerce ,array 'cl:list)))

(define-zetalisp-function-conversion zl:listp (list)
  :name list-use-consp
  :documentation "If NIL should not be considered a list"
  :form `(cl:consp ,list))

(define-zetalisp-function-conversion zl:listp (list)
  :name list-use-listp
  :documentation "If NIL should be considered as a list"
  :form `(cl:listp ,list))

(define-zetalisp-funarg-conversion zl:listp
  :name funarg-listp-use-consp
  :documentation "If NIL should not be considered a list"
  :new-function cl:consp)

(define-zetalisp-funarg-conversion zl:listp
  :documentation "If NIL should be considered as a list"
  :new-function cl:listp)

(define-zetalisp-function-conversion zl:load (pathname &optional pkg nonexistent-ok-flag
								 dont-set-default-p
								 no-msg-p)
  `(cl:load ,pathname ,@(and pkg `(:package ,pkg))
		      ,@(and nonexistent-ok-flag
			     `(:if-does-not-exist ,(if (constantp nonexistent-ok-flag)
						       (if (eval nonexistent-ok-flag)
							   `nil `:error)
						       `(if ,nonexistent-ok-flag
							    'nil ':error))))
		      ,@(and dont-set-default-p
			     `(:set-default-pathname ,(if (constantp dont-set-default-p)
							  (if (eval dont-set-default-p)
							      `nil `t)
							  `(not ,dont-set-default-p))))
		      ,@(and no-msg-p `(:verbose ,(if (constantp no-msg-p)
						      (if (eval no-msg-p) `nil `t)
						      `(not ,no-msg-p))))))

(define-zetalisp-symbol-conversion zl:load cl:load)	;for eval-when

(define-zetalisp-symbol-conversion zl:log cl:log)
(define-zetalisp-symbol-conversion zl:logand cl:logand)
(define-zetalisp-symbol-conversion zl:logior cl:logior)
(define-zetalisp-symbol-conversion zl:logxor cl:logxor)
(define-zetalisp-symbol-conversion zl:loop cl:loop)

;;; This is a copy of cli::*array-element-types*, but without the type reduction that
;;; has for speed.
(defparameter *array-element-types*
  '((sys:art-1b . cl:bit)
    (sys:art-2b . (cl:unsigned-byte 2))
    (sys:art-4b . (cl:unsigned-byte 4))
    (sys:art-8b . (cl:unsigned-byte 8))
    (sys:art-16b . (cl:unsigned-byte 16))
    (sys:art-fixnum . cl:fixnum)
    (sys:art-string . cl:string-char)
    (sys:art-fat-string . cl:character)
    (sys:art-boolean . scl:boolean)
    (sys:art-q . t)
    ;; (sys:art-q-list . t)	;Punt if get this one.
    ))

(defun convert-make-array-args (args)
  (loop for (keyword value) on args by 'cddr
	do (when (and (consp keyword) (eq (first keyword) 'quote))
	     (setq keyword (second keyword)))
	   (case keyword
	     (:type
	       (if (and (consp value) (eq (first value) 'zl:array-type))
		   (setq keyword :element-type
			 value `(cl:array-element-type ,(second value)))
		 (when (and (consp value) (eq (first value) 'quote))
		   (setq value (second value)))
		 (let ((new-type (cdr (assoc value *array-element-types*))))
		   (if new-type
		       (setq keyword :element-type
			     value `',new-type)
		       (throw 'punt-make-array-conversion nil)))))
	     (:initial-value (setq keyword :initial-element))
	     ((:area :displaced-to :displaced-index-offset :displaced-conformally
               :adjustable :leader-list :leader-length :named-structure-symbol
               :fill-pointer))
	     (otherwise (throw 'punt-make-array-conversion nil)))
	collect keyword collect value))

(define-zetalisp-function-conversion zl:make-array (dimensions &rest args)
  (catch 'punt-make-array-conversion
    `(cl:make-array ,dimensions . ,(convert-make-array-args args))))

(define-zetalisp-equal-conversion zl:make-equal-hash-table (&rest args) (test)
  (if test
      `(cl:make-hash-table :test ',test . ,args)
      `(cl:make-hash-table . ,args)))

(define-zetalisp-symbol-conversion zl:make-hash-table cl:make-hash-table)

(define-zetalisp-function-conversion zl:make-list (length &key (area nil area-p)
							       (initial-value nil iv-p))
  `(cl:make-list ,length ,@(and area-p `(:area ,area))
		         ,@(and iv-p `(:initial-element ,initial-value))))

(define-zetalisp-symbol-conversion zl:make-package cl:make-package)

;; cl:make-pathname is compatible except for the handling of the :defaults option
;; validity of this transformation assumes no non-constant keywords turning into :defaults
(define-zetalisp-function-conversion fs:make-pathname (&rest stuff)
  (loop for l on stuff by #'cddr
	as (kwd val) = l
	do (when (or (eq kwd ':defaults) (equal kwd '':defaults))
	     (return `(cl:make-pathname ,@(ldiff stuff l)
					:host (cl:pathname-host ,val)
					,@(cddr l))))
        finally (return `(cl:make-pathname ,@stuff))))

(define-zetalisp-function-conversion zl:make-raster-array (width height &rest args)
  (catch 'punt-make-array-conversion
    `(scl:make-raster-array ,width ,height . ,(convert-make-array-args args))))

(define-zetalisp-symbol-conversion zl:make-syn-stream cl:make-synonym-stream)
(define-zetalisp-symbol-conversion zl:map cl:mapl)

(define-zetalisp-function-conversion zl:mem (pred item list)
  (item-pred-use-test-and-key `(cl:member ,item ,list) pred))

(define-zetalisp-function-conversion zl:memass (pred item list)
  `(cl:member ,item ,list :test ,pred :key #'car))

(define-zetalisp-equal-conversion zl:member (item list) (test)
  ;; Check whether this test is stupid for these arguments
  (unless (check-for-stupid-equal-test test item list)
    (if test
	`(cl:member ,item ,list :test #',test)
	`(cl:member ,item ,list))))

(define-zetalisp-symbol-conversion zl:memq cl:member)

(define-zetalisp-function-conversion fs:merge-pathnames (pathname default
							 &optional (default-version nil versp))
  (if versp
      `(cl:merge-pathnames ,pathname ,default ,default-version)
      `(cl:merge-pathnames ,pathname ,default)))

(define-zetalisp-symbol-conversion zl:minus cl:-)
(define-zetalisp-symbol-conversion zl:multiple-value cl:multiple-value-setq)

;;; ZL version takes many lists
(define-zetalisp-function-conversion zl:nintersection (list1 list2)
  `(cl:nintersection ,list1 ,list2))

(define-zetalisp-function-conversion zl:nlistp (list)
  :name nlistp-assume-cl-conses
  :documentation "If NIL should not be considered a list"
  :form `(cl:atom ,list))

(define-zetalisp-function-conversion zl:nlistp (list)
  :name nlistp-assume-cl-lists
  :documentation "If NIL should be considered as a list"
  :form `(scl:nlistp ,list))

(define-zetalisp-funarg-conversion zl:nlistp
  :name funarg-nlistp-assume-cl-conses
  :documentation "If NIL should not be considered a list"
  :new-function cl:atom)

(define-zetalisp-funarg-conversion zl:nlistp
  :name funarg-nlistp-assume-cl-lists
  :documentation "If NIL should be considered as a list"
  :new-function scl:nlistp)

(define-zetalisp-symbol-conversion zl:nreverse cl:nreverse)
(define-zetalisp-symbol-conversion zl:nsublis cl:nsublis)
(define-zetalisp-symbol-conversion zl:nsubst cl:nsubst)

(define-zetalisp-function-conversion zl:nunion (list1 list2)
  `(cl:nunion ,list1 ,list2))

(define-zetalisp-symbol-conversion zl:package cl:*package*)
(define-zetalisp-symbol-conversion zl:pairlis cl:pairlis)

(define-zetalisp-function-conversion zl:parse-number (string &optional (from 0 from-p)
							     (to nil to-p)
							     (radix nil radix-p)
							     (fail-if-not-whole-string
							       nil fail-p))
  (cond ((not from-p)
	 `(cl:parse-integer ,string :junk-allowed t))
	((not to-p)
	 `(cl:parse-integer ,string :start ,from :junk-allowed t))
	((not radix-p)
	 `(cl:parse-integer ,string :start ,from :end ,to :junk-allowed t))
	((not fail-p)
	 `(cl:parse-integer ,string :start ,from :end ,to :radix ,radix :junk-allowed t))
	(t
	 `(cl:parse-integer ,string :start ,from :end ,to :radix ,radix
				    :junk-allowed (not ,fail-if-not-whole-string)))))

(define-zetalisp-function-conversion fs:parse-pathname (string)
  `(cl:pathname ,string))

(define-zetalisp-symbol-conversion zl:plist cl:symbol-plist)
(define-zetalisp-symbol-conversion zl:plus cl:+)

(define-zetalisp-function-conversion zl:pop (list &optional (dest nil dest-p))
  (if dest-p
      `(cl:setf ,dest (cl:pop ,list))
      `(cl:pop ,list)))

(define-zetalisp-symbol-conversion zl:prinlength cl:*print-length*)
(define-zetalisp-symbol-conversion zl:prinlevel cl:*print-level*)
(define-zetalisp-symbol-conversion zl:probef cl:probe-file)

(define-zetalisp-function-conversion zl:process-sleep (interval &optional (state nil state-p))
  (flet ((convert-time (n)
	   (if (cl:integerp n)
	       (cl:/ n 60)
	       `(cl:/ n 60))))
    (if state-p
	`(cl:sleep ,(convert-time interval) :sleep-reason ,state)
	`(cl:sleep ,(convert-time interval)))))

(define-zetalisp-symbol-conversion zl:progv cl:progv)
(define-zetalisp-symbol-conversion zl:psetq cl:psetq)
(define-zetalisp-symbol-conversion zl:push cl:push)
(define-zetalisp-symbol-conversion si:push* cl:pushnew)

(define-zetalisp-function-conversion zl:push-in-area (item list area)
  `(cl:push ,item ,list :area ,area))

(define-zetalisp-function-conversion zl:puthash (key value table)
  `(cl:setf (cl:gethash ,key ,table) ,value))

(define-zetalisp-function-conversion zl:puthash-equal (key value table)
  `(cl:setf (cl:gethash ,key ,table) ,value))

(define-zetalisp-function-conversion zl:putprop (symbol val ind)
  (if (and (consp symbol)
	   (eq (first symbol) 'locf))
      `(cl:setf (cl:getf ,(second symbol) ,ind) ,val)
      `(cl:setf (cl:get ,symbol ,ind) ,val)))

(define-zetalisp-function-conversion zl:putprop (plist val ind)
  :name putprop-disembodied
  :documentation "For use with disembodied property lists"
  :form (unless (and (consp plist)
		     (eq (first plist) 'locf))
	  `(cl:setf (cl:getf (cdr ,plist) ,ind) ,val)))

(define-zetalisp-symbol-conversion zl:query-io cl:*query-io*)

(define-zetalisp-function-conversion zl:quotient (&rest numbers)
  (unless (manifestly-floating-point numbers)
    `(cl:floor . ,numbers)))

(define-zetalisp-function-conversion zl:quotient (&rest numbers)
  :name quotient-use-truncate
  :documentation "To get FORTRAN style rounding with negative numbers"
  :form (unless (manifestly-floating-point numbers)
	  `(cl:truncate . ,numbers)))

(define-zetalisp-function-conversion zl:quotient (&rest numbers)
  :name quotient-use-/
  :documentation "To get exact rational division or for dividing floats"
  :form `(cl:/ . ,numbers))

(define-zetalisp-function-conversion zl:random (&optional arg array)
  (when (and arg (not array))
    `(cl:random ,arg)))

(define-zetalisp-function-conversion zl:rass (pred item list)
  (item-pred-use-test-and-key `(cl:rassoc ,item ,list) pred))

(define-zetalisp-equal-conversion zl:rassoc (item list) (test)
  ;; Check whether this test is stupid for these arguments
  (unless (check-for-stupid-equal-test test item list #'cdr)
    (if test
	`(cl:rassoc ,item ,list :test #',test)
	`(cl:rassoc ,item ,list))))

(define-zetalisp-symbol-conversion zl:rassq cl:rassoc)

(define-zetalisp-symbol-conversion zl:rational cl:rationalize)

(define-zetalisp-function-conversion zl:rationalp (x)
  `(cl:typep ,x 'cl:ratio))

(define-zetalisp-function-conversion zl:read (&optional (stream nil stream-p)
							(eof-option nil eof-opt-p))
  (cond ((not stream-p)
	 `(cl:read))
	((not eof-opt-p)
	 `(cl:read ,stream))
	(t
	 `(cl:read ,stream nil ,eof-option))))

(define-zetalisp-function-conversion zl:read-delimited-string
				     (&optional (delimiters nil del-p)
						(stream nil stream-p)
						(eof nil eof-p)
				      &rest make-array-args)
  (cond ((not del-p)
	 `(scl:read-delimited-string '(#\End)))
	((not stream-p)
	 `(scl:read-delimited-string ,delimiters))
	((not eof-p)
	 `(scl:read-delimited-string ,delimiters ,stream))
	((not make-array-args)
	 `(scl:read-delimited-string ,delimiters ,stream nil ,eof))))

(define-zetalisp-function-conversion zl:read-from-string (string
							   &optional (eof nil eof-p)
								     (start nil start-p)
								     (end nil end-p)
								     (pres-whitespace nil
										      pw-p))
  (cond ((not eof-p)
	 `(cl:read-from-string ,string))
	((not start-p)
	 `(cl:read-from-string ,string nil ,eof))
	((not end-p)
	 `(cl:read-from-string ,string nil ,eof :start ,start))
	((not pw-p)
	 `(cl:read-from-string ,string nil ,eof :start ,start :end ,end))
	(t
	 `(cl:read-from-string ,string nil ,eof :start ,start :end ,end
			       :preserve-whitespace ,pres-whitespace))))
							  
(define-zetalisp-function-conversion zl:readfile (path &optional (pkg nil pkg-p)
								 (no-msg nil no-msg-p))
  (cond ((not pkg-p)
	 `(cl:load ,path))
	((not no-msg-p)
	 `(cl:load ,path :package ,pkg))
	(t
	 `(cl:load ,path :package ,pkg :verbose (not ,no-msg)))))

(define-zetalisp-function-conversion zl:readline (&optional (stream nil stream-p)
							    (eof nil eof-p))
  (cond ((not stream-p)
	 `(cl:read-line))
	((not eof-p)
	 `(cl:read-line ,stream))
	(t
	 `(cl:read-line ,stream nil ,eof))))

(define-zetalisp-symbol-conversion zl:readtable cl:*readtable*)

(define-zetalisp-function-conversion zl:rem (pred item list &optional (ntimes nil ntimes-p))
  (if ntimes-p
      (item-pred-use-test-and-key `(cl:remove ,item ,list :count ,ntimes) pred)
      (item-pred-use-test-and-key `(cl:remove ,item ,list) pred)))

(define-zetalisp-symbol-conversion zl:rem-if cl:remove-if)
(define-zetalisp-symbol-conversion zl:rem-if-not cl:remove-if-not)

(define-zetalisp-symbol-conversion zl:remainder cl:rem)
(define-zetalisp-symbol-conversion zl:remhash-equal cl:remhash)
(define-zetalisp-symbol-conversion zl:remob cl:unintern)

(define-zetalisp-equal-conversion zl:remove (item list &optional (ntimes nil ntimes-p)) (test)
  ;; Check whether this test is stupid for these arguments
  (unless (check-for-stupid-equal-test test item list)
    (if test
	(if ntimes-p
	    `(cl:remove ,item ,list :test #',test :ntimes ,ntimes)
	    `(cl:remove ,item ,list :test #',test))
	(if ntimes-p
	    `(cl:remove ,item ,list :ntimes ,ntimes)
	    `(cl:remove ,item ,list)))))

(define-zetalisp-symbol-conversion zl:remprop cl:remprop)

(define-zetalisp-function-conversion zl:remq (item list &optional (ntimes nil ntimes-p))
  (if ntimes-p
      `(cl:remove ,item ,list :count ,ntimes)
      `(cl:remove ,item ,list)))

(define-zetalisp-symbol-conversion zl:renamef cl:rename-file)
(define-zetalisp-symbol-conversion zl:rest1 cl:rest)
(define-zetalisp-symbol-conversion zl:rest2 cddr)
(define-zetalisp-symbol-conversion zl:rest3 cdddr)
(define-zetalisp-symbol-conversion zl:rest4 cddddr)	;Yuck.
(define-zetalisp-symbol-conversion zl:reverse cl:reverse)
(define-zetalisp-symbol-conversion zl:samepnamep cl:string=)

(define-zetalisp-function-conversion zl:selectq (item &rest clauses)
  :form (selectq-convert item clauses)
  :modification-depth 2)

(define-zetalisp-function-conversion zl:set-globally (sym val)
  `(cl:setf (scl:symbol-value-globally ,sym) ,val))

(define-zetalisp-function-conversion zl:set-in-instance (instance symbol value)
  `(cl:setf (scl:symbol-value-in-instance ,instance ,symbol) ,value))

(define-zetalisp-symbol-conversion zl:setf cl:setf)

(define-zetalisp-function-conversion zl:setplist (symbol plist)
  `(cl:setf (cl:symbol-plist ,symbol) ,plist))

(define-zetalisp-function-conversion zl:setq-globally (&rest vars-and-vals)
  (let ((forms (loop for (var val) on vars-and-vals by 'cddr
		     collect `(cl:setf (scl:symbol-value-globally ',var) ,val))))
    (if (= (length forms) 1)
	(first forms)
	`(progn . ,forms))))

(define-zetalisp-function-conversion zl:some (list pred)
  `(cl:some ,pred ,list))

(define-zetalisp-symbol-conversion zl:sort cl:sort)

(define-zetalisp-function-conversion zl:sortcar (x pred)
  `(cl:sort ,x ,pred :key #'car))

(define-zetalisp-symbol-conversion zl:sqrt cl:sqrt)
(define-zetalisp-symbol-conversion zl:stable-sort cl:stable-sort)
(define-zetalisp-symbol-conversion zl:standard-input cl:*standard-input*)
(define-zetalisp-symbol-conversion zl:standard-output cl:*standard-output*)

(define-zetalisp-function-conversion zl:store-array-leader (value array index)
  `(cl:setf (array-leader ,array ,index) ,value))

(defmacro define-string-comparison-conversion (zl-function cl-function)
  `(progn
     (define-zetalisp-function-conversion ,zl-function (string1 string2
							&optional (idx1 0 idx1-p)
								  (idx2 0 idx2-p)
								  (lim1 nil lim1-p)
								  (lim2 nil lim2-p))
       (cond ((not idx1-p)
	      `(,',cl-function ,string1 ,string2))
	     ((not idx2-p)
	      `(,',cl-function ,string1 ,string2 :start1 ,idx1))
	     ((not lim1-p)
	      `(,',cl-function ,string1 ,string2 :start1 ,idx1 :start2 ,idx2))
	     ((not lim2-p)
	      `(,',cl-function ,string1 ,string2 :start1 ,idx1 :start2 ,idx2 :end1 ,lim1))
	     (t
	      `(,',cl-function ,string1 ,string2 :start1 ,idx1 :start2 ,idx2
						 :end1 ,lim1 :end2 ,lim2))))
     (define-zetalisp-funarg-conversion ,zl-function ,cl-function)))

(defmacro define-string-case-conversion (zl-name cl-name ncl-name)
  `(define-zetalisp-function-conversion ,zl-name (string &optional (start 0 start-p)
							 (end nil end-p)
							 (copy-p t))
     (case copy-p
       ((t)
	(cond ((not start-p)
	       `(,',cl-name ,string))
	      ((not end-p)
	       `(,',cl-name ,string :start ,start))
	      (t
	       `(,',cl-name ,string :start ,start :end ,end))))
       ((nil)
	(cond ((not start-p)
	       `(,',ncl-name ,string))
	      ((not end-p)
	       `(,',ncl-name ,string :start ,start))
	      (t
	       `(,',ncl-name ,string :start ,start :end ,end)))))))

(defmacro define-string-search-conversion (zl-name cl-name &key from-end string2)
  (if string2
      `(define-zetalisp-function-conversion ,zl-name
					    (key string &optional (start 0 start-p)
								  (end nil end-p)
								  (key-start nil key-start-p)
								  (key-end nil key-end-p))
	 ,(if (not from-end)
	      `(cond ((not start-p)
		      `(,',cl-name ,key ,string))
		     ((not end-p)
		      `(,',cl-name ,key ,string :start2 ,start))
		     ((not key-start-p)
		      `(,',cl-name ,key ,string :start2 ,start :end2 ,end))
		     ((not key-end-p)
		      `(,',cl-name ,key ,string :start2 ,start :end2 ,end
			:start1 ,key-start))
		     (t
		      `(,',cl-name ,key ,string :start2 ,start :end2 ,end
			:start1 ,key-start :end1 ,key-end)))
	      `(append (cond ((not start-p)
			      `(,',cl-name ,key ,string))
			     ((not end-p)
			      `(,',cl-name ,key ,string :end2 ,start))
			     ((not key-start-p)
			      `(,',cl-name ,key ,string :end2 ,start :start2 ,end))
			     ((not key-end-p)
			      `(,',cl-name ,key ,string :end2 ,start :start2 ,end
				:start1 ,key-start))
			     (t
			      `(,',cl-name ,key ,string :end2 ,start :start2 ,end
				:start1 ,key-start :end1 ,key-end)))
		       '(:from-end t))))
      `(define-zetalisp-function-conversion ,zl-name
					    (key string &optional (start 0 start-p)
								  (end nil end-p))
	 ,(if (not from-end)
	      `(cond ((not start-p)
		      `(,',cl-name ,key ,string))
		     ((not end-p)
		      `(,',cl-name ,key ,string :start ,start))
		     (t
		      `(,',cl-name ,key ,string :start ,start :end ,end)))
	      `(append (cond ((not start-p)
			      `(,',cl-name ,key ,string))
			     ((not end-p)
			      `(,',cl-name ,key ,string :end ,start))
			     (t
			      `(,',cl-name ,key ,string :end ,start :start ,end)))
		       '(:from-end t))))))

(define-zetalisp-function-conversion zl:string-capitalize-words (string
								  &optional (copy-p t)
									    (keep-hypen nil))
  (case keep-hypen
    ((nil)
     (case copy-p
       ((t)
	`(scl:string-capitalize-words ,string))
       ((nil)
	`(scl:nstring-capitalize-words ,string))))
    ((t)
     (case copy-p
       ((t)
	`(cl:string-capitalize ,string))
       ((nil)
	`(cl:nstring-capitalize ,string))))))

(define-string-comparison-conversion zl:string scl:string)
(define-string-comparison-conversion zl:string scl:string)
(define-string-comparison-conversion zl:string scl:string)
(define-string-comparison-conversion zl:string-compare scl:string-compare)
(define-string-case-conversion zl:string-downcase cl:string-downcase cl:nstring-downcase)
(define-string-comparison-conversion zl:string-equal cl:string-equal)
(define-string-comparison-conversion zl:string-exact-compare scl:string-exact-compare)
(define-string-case-conversion zl:string-flipcase scl:string-flipcase scl:nstring-flipcase)
(define-string-comparison-conversion zl:string-greaterp cl:string-greaterp)
(define-zetalisp-symbol-conversion zl:string-left-trim cl:string-left-trim)
(define-string-comparison-conversion zl:string-lessp cl:string-lessp)
(define-zetalisp-symbol-conversion zl:string-nconc scl:string-nconc)
(define-string-comparison-conversion zl:string-not-equal cl:string-not-equal)
(define-string-comparison-conversion zl:string-not-greaterp cl:string-not-greaterp)
(define-string-comparison-conversion zl:string-not-lessp cl:string-not-lessp)
(define-zetalisp-symbol-conversion zl:string-nreverse cl:nreverse)
(define-zetalisp-symbol-conversion zl:string-pluralize scl:string-pluralize)
(define-zetalisp-symbol-conversion zl:string-reverse cl:reverse)
(define-string-search-conversion zl:string-reverse-search scl:string-search
				 :from-end t :string2 t)
(define-string-search-conversion zl:string-reverse-search-char scl:string-search-char
				 :from-end t)
(define-string-search-conversion zl:string-reverse-search-exact scl:string-search-exact 
				 :from-end t :string2 t)
(define-string-search-conversion zl:string-reverse-search-exact-char
				 scl:string-search-exact-char :from-end t)
(define-string-search-conversion zl:string-reverse-search-not-char
				 scl:string-search-not-char :from-end t)
(define-string-search-conversion zl:string-reverse-search-not-exact-char 
				 scl:string-search-not-exact-char :from-end t)
(define-string-search-conversion zl:string-reverse-search-not-set
				 scl:string-search-not-set :from-end t)
(define-string-search-conversion zl:string-reverse-search-set scl:string-search-set
				 :from-end t)
(define-zetalisp-symbol-conversion zl:string-right-trim cl:string-right-trim)
(define-string-search-conversion zl:string-search scl:string-search :string2 t)
(define-string-search-conversion zl:string-search-char scl:string-search-char)
(define-string-search-conversion zl:string-search-exact scl:string-search-exact :string2 t)
(define-string-search-conversion zl:string-search-exact-char scl:string-search-exact-char)
(define-string-search-conversion zl:string-search-not-char scl:string-search-not-char)
(define-string-search-conversion zl:string-search-not-exact-char
				 scl:string-search-not-exact-char)
(define-string-search-conversion zl:string-search-not-set scl:string-search-not-set)
(define-string-search-conversion zl:string-search-set scl:string-search-set)
(define-zetalisp-symbol-conversion zl:string-trim cl:string-trim)
(define-string-case-conversion zl:string-upcase cl:string-upcase cl:nstring-upcase)
(define-string-comparison-conversion zl:string< cl:string<)
(define-string-comparison-conversion zl:string= cl:string=)
(define-string-comparison-conversion zl:string> cl:string>)

(define-zetalisp-symbol-conversion zl:sub1 cl:1-)
(define-zetalisp-symbol-conversion zl:sublis cl:sublis)

(define-zetalisp-function-conversion zl:subset (pred list)
  `(cl:delete-if-not ,pred ,list))

(define-zetalisp-function-conversion zl:subset-not (pred list)
  `(cl:delete-if ,pred ,list))

(define-zetalisp-symbol-conversion zl:subst cl:subst)
(define-zetalisp-symbol-conversion zl:swapf cl:rotatef)
(define-zetalisp-symbol-conversion zl:swaphash-equal scl:swaphash)
(define-zetalisp-symbol-conversion zl:symeval cl:symbol-value)
(define-zetalisp-symbol-conversion zl:symeval-globally scl:symbol-value-globally)
(define-zetalisp-symbol-conversion zl:symeval-in-instance scl:symbol-value-in-instance)
(define-zetalisp-symbol-conversion zl:terminal-io cl:*terminal-io*)
(define-zetalisp-symbol-conversion zl:terpri cl:terpri)
(define-zetalisp-symbol-conversion zl:trace-output cl:*trace-output*)

(define-zetalisp-function-conversion zl:tyi (&optional (stream nil stream-p)
							    (eof nil eof-p))
  (cond ((not stream-p)
	 `(cl:read-char))
	((not eof-p)
	 `(cl:read-char ,stream))
	(t
	 `(cl:read-char ,stream nil ,eof))))

(define-zetalisp-function-conversion zl:tyipeek (&optional (peek-type nil pt-p)
							   (stream nil stream-p)
							   (eof nil eof-p))
  (cond ((not pt-p)
	 `(cl:peek-char))
	((not stream-p)
	 `(cl:peek-char ,peek-type))
	((not eof-p)
	 `(cl:peek-char ,peek-type ,stream))
	(t
	 `(cl:peek-char ,peek-type ,stream nil ,eof))))

(define-zetalisp-symbol-conversion zl:tyo cl:write-char)

(defun typecase-convert-types (clauses)
  (loop for (type . clause) in clauses
	collect (cons (if (consp type)
			  `(or . ,(map 'list #'convert-type-form type))
			  (convert-type-form type))
		      clause)))

(define-zetalisp-function-conversion zl:typecase (form &rest types)
  :form `(cl:typecase ,form . ,(typecase-convert-types types))
  :modification-depth 2)

(define-zetalisp-function-conversion zl:typep (thing &optional (type nil type-p))
  (if type-p
      `(cl:typep ,thing ,(convert-type-form type t))
      `(cl:type-of ,thing)))

(define-zetalisp-symbol-conversion zl:undeletef scl:undelete-file)

(define-zetalisp-function-conversion zl:union (list1 list2)
  `(cl:union ,list1 ,list2))

(define-zetalisp-function-conversion zl:value-cell-location (symbol)
  `(locf (cl:symbol-value ,symbol)))

(define-zetalisp-symbol-conversion zl:variable-location scl:locf)

(define-zetalisp-function-conversion zl:with-input-from-string ((var string
								 &optional (index nil index-p)
									   (end nil end-p))
								&body body)
  (cond ((not index-p)
	 `(cl:with-input-from-string (,var ,string) . ,body))
	((not end-p)
	 `(cl:with-input-from-string (,var ,string :start ,index :index ,index) . ,body))
	(t
	 `(cl:with-input-from-string (,var ,string :start ,index :index ,index :end ,end)
	    . ,body))))

(define-zetalisp-function-conversion zl:with-output-to-string ((var &optional 
								    (string nil string-p)
								    (index nil index-p))
							       &body body)
  (cond ((not string-p)
	 `(cl:with-output-to-string (,var) . ,body))
	((not index-p)
	 `(cl:with-output-to-string (,var ,string) . ,body))
	(t
	 `(cl:with-output-to-string (,var ,string :index ,index) . ,body))))

;;; Template used to suppress explicit stream case, too.
(define-zetalisp-function-conversion zl:y-or-n-p (&optional (message nil mess-p))
  (if mess-p
      (if (and (consp message)
	       (member (first message) '(zl:format cl:format))
	       (eq (second message) 'nil)
	       (stringp (third message)))
	  `(cl:y-or-n-p ,(if (eq (first message) 'cl:format)
				(third message)
				(convert-format-string (third message)))
			   . ,(nthcdr 3 message))
	  `(cl:y-or-n-p ,message))
      `(cl:y-or-n-p)))

(define-zetalisp-function-conversion zl:yes-or-no-p (&optional (message nil mess-p))
  (if mess-p
      (if (and (consp message)
	       (member (first message) '(zl:format cl:format))
	       (eq (second message) 'nil)
	       (stringp (third message)))
	  `(cl:yes-or-no-p ,(if (eq (first message) 'cl:format)
				(third message)
				(convert-format-string (third message)))
			   . ,(nthcdr 3 message))
	  `(cl:yes-or-no-p ,message))
      `(cl:yes-or-no-p)))

(define-zetalisp-symbol-conversion zl:\\ cl:rem)
(define-zetalisp-symbol-conversion zl:\\\\ cl:gcd)
(define-zetalisp-symbol-conversion zl:^ cl:expt)
(define-zetalisp-symbol-conversion zl:^$ cl:expt)

(define-conversion-set zl-defstructcl
		       define-defstruct-symbol-conversion
		       define-defstruct-function-conversion
		       :pretty-name "DEFSTRUCT"
		       :search-strings '("ZL:DEFSTRUCT" "(MAKE-")
		       :default-conversions '(zl-defstruct-constructor-converter))

(defvar *defstruct-conversions* ())

(defstruct (defstruct-converted :list)
  structure-name
  constructor-name
  (make-array-keywords ()))

(define-defstruct-function-conversion zl:defstruct (options &body items)
  :modification-depth 4
  :form (let ((hints nil))
	  (values
	    (list* 'cl:defstruct
	      (if (atom options) (list options '(:conc-name nil))
		(cond ((member ':conc-name (rest options))
		       (setq options (remove ':conc-name options)))
		      ((si:assq-careful ':conc-name (rest options)) )
		      (t (setq options (list* (first options)
					      '(:conc-name nil)
					      (rest options)))))
		(let ((make-array (si:assq-careful ':make-array (rest options))))
		  (when make-array
		    (let ((keywords (convert-constructor-make-array-args
				      (second make-array))))
		      (setq options `(,@(remove make-array options)
				      (:constructor-make-array-keywords
					. ,(loop for (key value) on keywords by 'cddr
						 collect (list (intern (symbol-name key))
							       value)))))
		      (push (make-defstruct-converted
			      :structure-name (first options)
			      :constructor-name (or (second (si:assq-careful ':constructor
									     (rest options)))
						    (fintern "MAKE-~A" (first options)))
			      :make-array-keywords (loop for (key) on keywords by 'cddr
							 collect key))
			    *defstruct-conversions*))))
		(dolist (option options)
		  (when (or (atom option) (eq (first option) ':type))
		    (let* ((old (if (atom option) option (second option)))
			   (new (cdr (assoc old '((:array . vector)
						  (:list . list)
						  (:named-list . list))))))
		      (when new
			(unless (and (eq new 'vector) (member ':named options))
			  (setq options (subst `(:type ,new) option options))
			  (when (eq old ':named-list) (push ':named options)))))))
		options)
	      (if (loop for item in items always (or (atom item) (atom (car item))))
		  items				;Fast arrangement for EQness
		(loop for item in items
		      collect (if (or (atom item) (atom (car item))) item
				(let ((new (loop for subitem in item collect
					     (list* (first subitem)
						    (when (rest subitem)
						      (if (rest (rest subitem))
							  `(,(second (rest subitem))
							    :byte ,(first (rest subitem)))
							  `(0 :byte . ,(rest subitem))))))))
				  (push (list new item) hints)
				  new)))))
	    hints)))

(defun convert-constructor-make-array-args (args)
  (let ((length-prop (zl:getl (locf args) '(:length :dimensions))))
    (if length-prop
	(list* (first length-prop) (second length-prop)
	       (convert-make-array-args (nconc (ldiff args length-prop) (cddr length-prop))))
	(convert-make-array-args args))))

(define-defstruct-function-conversion make-thing (&rest options)
  :name zl-defstruct-constructor-converter
  :form (when (and options (evenp (length options))
		   (string= conversion-tools:function-name "MAKE-" :end1 5))
	  (catch 'punt-make-array-conversion
	    (block skip-it
	      (cons conversion-tools:function-name
		(let ((new-options nil))
		  (loop for (name value) on options by 'cddr do
		    (cond ((not (symbolp name))
			   (return-from skip-it nil))
			  ((string= name :make-array)
			   (setq new-options (nconc new-options
						    (convert-constructor-make-array-args
						      value)))
			   (let ((entry (find conversion-tools:function-name *defstruct-conversions*
					      :key #'defstruct-converted-constructor-name)))
			     (when (null entry)
			       (setq entry (make-defstruct-converted
					     :structure-name (intern (substring
								       conversion-tools:function-name
								       5))
					     :constructor-name conversion-tools:function-name))
			       (push entry *defstruct-conversions*))
			     (let ((unhandled
				     (set-difference
				       (loop for (key) on value by 'cddr collect key)
				       (defstruct-converted-make-array-keywords entry))))
			       (when unhandled
				 (let ((compiler:default-warning-function
					 (defstruct-converted-structure-name entry))
				       (compiler:default-warning-definition-type 'defstruct))
				   (compiler:warn 
				     "You need to add ~{~A~^, ~} to the ~
:CONSTRUCTOR-MAKE-ARRAY-KEYWORDS option of this structure."
				     unhandled))
				 (setf (defstruct-converted-make-array-keywords entry)
				       (nconc (defstruct-converted-make-array-keywords entry)
					      unhandled))))))
			  ((keywordp name)
			   ;; This filters out flavor constructors because they take
			   ;; keywords, instead of symbols in the constructors'
			   ;; package.
			   (return-from skip-it nil))
			  (t
			   (setq new-options (nconc new-options
						    (list* (intern (symbol-name name) "")
							   value
							   nil))))))
		  new-options))))))
