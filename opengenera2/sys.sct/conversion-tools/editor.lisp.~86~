;;; -*- Mode: LISP; Syntax: Zetalisp; Package: ZWEI; Base: 10; Lowercase: T -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(defun conversion-read-error-handler (condition)
  (format error-output "~&Error: ~~A~~%Unable to parse line " condition)
  (let* ((stream (send condition :stream))
	 (bp (send condition :location)))
    (present-line (bp-line bp) error-output)
    (let ((name (get-definition-name (forward-definition bp -1 t))))
      (unless (cl:equal name "Definition")
	(format error-output "Unable to process ~A.~%" name)))
    (setq bp (forward-definition bp))
    (cond (bp
	   (format error-output "~%Proceeding with ~A.~%" (get-definition-name bp))
	   (send stream :set-bp bp)
	   (throw 'skip-error t))
	  (t
	   (format error-output "~%Skipping rest of file.~%")
	   (throw 'skip-end t)))))

;;;; Syntax

(defcom com-convert-lisp-syntax-of-region
	"Convert the current region from Zetalisp syntax to Common lisp syntax.
Mostly, this involves swapping // and /\.  This operation is undoable." ()
  (definition-region (bp1 bp2)
    ;; (undo-save bp1 bp2 t "Syntax convert")
    (convert-lisp-syntax-interval bp1 bp2 t))
  dis-text)

(defcom com-convert-lisp-syntax-of-buffer
	"Convert a buffer in Zetalisp syntax to Common lisp syntax.
Also does what m-X Set Lisp Syntax would do." ()
  (let ((buffer (read-buffer-name "Convert LISP Syntax of Buffer" *interval*)))
    (let ((current (send buffer :get :syntax)))
      (unless (eq current :zetalisp)
	(unless (typeout-beep-yes-or-no-p "~A currently has ~S for its syntax property.
Okay to go ahead anyway? " buffer current)
	  (abort-current-command))))
    (convert-lisp-syntax-buffer buffer))
  dis-text)

(defcom com-convert-lisp-syntax-of-tag-table
  "Convert some of the buffers in a Tag Table from Zetalisp syntax to Common lisp syntax.
Queries with a list of files currently in Zetalisp syntax." ()
  (let ((buffers nil))
    (let ((tags-buffer (select-tag-table nil)))
      (send tags-buffer :restart)
      (loop doing
	(let ((node (send tags-buffer :next-node)))
	  (when (null node)
	    (return))
	  (let ((buffer (send node :buffer)))
	    (when (eq (send buffer :get :syntax) :zetalisp)
	      (push buffer buffers))))))
    (setq buffers (nreverse buffers))
    (when (null buffers) (barf "There are no files in Zetalisp syntax."))
    (let ((query-io sys:syn-terminal-io))
      (format t "File~P to be converted:~%" (length buffers))
      (scl:format-item-list buffers)
      (selectq (fquery '(:choices (((t "Yes.") #\Y #\Space)
				   ((nil "No.") #\N #\Rubout)
				   ((:selective "Selective.") #\S)))
		       "Okay? ")
	((t) )
	((nil) (setq buffers nil))
	((:selective)
	 (setq buffers (loop for buffer in buffers
			     when (cl:y-or-n-p "Convert ~A? " buffer)
			       collect buffer)))))
    (when buffers
      (let ((update-list *set-attribute-updates-list*))
	(when (eq update-list :ask)
	  (let ((query-io sys:syn-terminal-io))
	    (setq update-list (fquery () "Set the file attribute lists, too? "))))
	(dolist (buffer buffers)
	  (format t "~&Converting ~A ..." buffer)
	  (convert-lisp-syntax-buffer buffer update-list)))
      (format t "~&Done.~%")))
  dis-text)

(defun convert-lisp-syntax-buffer (buffer
				   &optional (*set-attribute-updates-list* t))	;don't query
  (make-buffer-current buffer)			;So that other specials bound.
  (convert-lisp-syntax-interval buffer)
  (send buffer :putprop :common-lisp :syntax)
  (set-attribute-internal :syntax "Syntax" "Common-lisp" :common-lisp)
  (let ((new-package (fs:find-package-for-syntax (cl:package-name package) :common-lisp)))
    (when (not (eq package new-package))
      (set-one-context-variable 'package new-package)))
  (set-evaluation-context buffer)
  (invalidate-buffer-sectionization buffer)
  (send *major-mode* :execute-mode-hook))

(defun convert-lisp-syntax-interval (bp1 &optional bp2 in-order-p)
  (let ((stream (open-interval-stream bp1 bp2 in-order-p))
	(eof-marker (ncons nil)))
    (condition-bind ((sys:read-error #'conversion-read-error-handler))
      (catch 'skip-end
	(loop doing
	  (let ((thing (catch 'skip-error
			 (si:read-converting-syntax stream eof-marker))))
	    (when (eq thing eof-marker)
	      (return)))))))
  t)

(defcom com-convert-base-of-region
	"Convert the current region from octal to decimal.
You will be asked given a choice of what to do with large octal numbers.
This operation is undoable." ()
  (definition-region (bp1 bp2)
    ;; (undo-save bp1 bp2 t "Base convert")
    (convert-base-interval (read-base-conversion-mode) bp1 bp2 t))
  dis-text)

(defcom com-convert-base-of-buffer
	"Convert a buffer from octal to decimal.
You will be asked given a choice of what to do with large octal numbers.
Also does what m-X Base would do." ()
  (let ((buffer (read-buffer-name "Convert Base of Buffer" *interval*)))
    (let ((current (send buffer :get :base)))
      (unless (eql current 8)
	(unless (typeout-beep-yes-or-no-p "~A currently has ~D for its base property.
Okay to go ahead anyway? " buffer current)
	  (abort-current-command))))
    (convert-base-buffer buffer (read-base-conversion-mode)))
  dis-text)

(defcom com-convert-base-of-tag-table
  "Convert some of the buffers in a Tag Table from octal to decimal.
You will be asked given a choice of what to do with large octal numbers.
Queries with a list of files currently in octal." ()
  (let ((buffers nil))
    (let ((tags-buffer (select-tag-table nil)))
      (send tags-buffer :restart)
      (loop doing
	(let ((node (send tags-buffer :next-node)))
	  (when (null node)
	    (return))
	  (let ((buffer (send node :buffer)))
	    (when (eql (send buffer :get :base) :8)
	      (push buffer buffers))))))
    (setq buffers (nreverse buffers))
    (when (null buffers) (barf "There are no files in octal."))
    (let ((query-io sys:syn-terminal-io))
      (format t "File~P to be converted:~%" (length buffers))
      (scl:format-item-list buffers)
      (selectq (fquery '(:choices (((t "Yes.") #\Y #\Space)
				   ((nil "No.") #\N #\Rubout)
				   ((:selective "Selective.") #\S)))
		       "Okay? ")
	((t) )
	((nil) (setq buffers nil))
	((:selective)
	 (setq buffers (loop for buffer in buffers
			     when (cl:y-or-n-p "Convert ~A? " buffer)
			       collect buffer))))
      (when buffers
	(let ((mode (read-base-conversion-mode))
	      (update-list *set-attribute-updates-list*))
	  (when (eq update-list :ask)
	    (setq update-list (fquery () "Set the file attribute lists, too? ")))
	  (dolist (buffer buffers)
	    (format t "~&Converting ~A ..." buffer)
	    (convert-base-buffer buffer mode update-list))
	  (format t "~&Done.~%")))))
  dis-text)

(defun read-base-conversion-mode ()
  (fquery '(:choices (((:octal "Octal.") #\O)
		      ((:decimal "Decimal.") #\D)
		      ((:selective "Selective.") #\S)))
 "Should large octal numbers be converted to octal prefix notation (#o) or decimal radix? "))

(defun convert-base-buffer (buffer mode
			    &optional (*set-attribute-updates-list* t))	;don't query
  (make-buffer-current buffer)
  (convert-base-interval mode buffer)
  (send buffer :putprop 10 :base)
  (set-attribute-internal :base "Base" "10" 10)
  (set-one-context-variable 'base 10)
  (set-one-context-variable 'ibase 10)
  (send *major-mode* :execute-mode-hook))

(defun convert-base-interval (mode bp1 &optional bp2 in-order-p)
  (let ((stream (open-interval-stream bp1 bp2 in-order-p))
	(query-io sys:syn-terminal-io)
	(eof-marker (ncons nil)))
    (condition-bind ((sys:read-error #'conversion-read-error-handler))
      (catch 'skip-end
	(loop doing
	  (let ((thing (catch 'skip-error
			 (si:read-converting-base stream eof-marker mode))))
	    (when (eq thing eof-marker)
	      (return)))))))
  (send *typeout-window* :make-complete)
  t)

;;;; Symbol name conflicts
(defcom com-find-conflicting-symbols-in-buffer
	"Make a new buffer with a list of symbols from this buffer that are global in the new package but local in the old package.
You can then use m-X Multiple Query Replace from Buffer to substitute new names for these."
	()
  (find-conflicting-symbols-from-buffers
    (list (read-buffer-name "Find Conflicting Symbols in Buffer" *interval*))))

(defcom com-find-conflicting-symbols-in-tag-table
	"Make a new buffer with a list of symbols from the buffers in the tag table that are global in the new package but local in the old package.
You can then use m-X Tags Multiple Query Replace from Buffer to substitute new names for these."
	()
  (find-conflicting-symbols-from-buffers
    (let ((buffers nil))
      (let ((tags-buffer (select-tag-table nil)))
	(send tags-buffer :restart)
	(loop doing
	  (let ((node (send tags-buffer :next-node)))
	    (when (null node)
	      (return))
	    (push (send node :buffer) buffers))))
      (nreverse buffers))))

(defun find-conflicting-symbols-from-buffers (buffers)
  (send *typein-window* :clear-window)
  (let* ((packages (loop for buffer in buffers
			 collect (or (send buffer :get :package) package)))
	 (pkg-alist (get-packages-to-convert (cl:remove-duplicates packages) t))
	 (symbols nil))
    (loop for buffer in buffers
	  for old-pkg in packages
	  for new-pkg = (cdr (assq old-pkg pkg-alist)) do
      (when new-pkg
	(dolist (node (node-inferiors buffer))
	  (when (typep node 'section-node)
	    (let ((function-spec (send node :function-spec))
		  (section-type (send node :definition-type)))
	      (when (and (symbolp function-spec)
			 (not (memq function-spec symbols))
			 (eq (symbol-package function-spec) old-pkg)
			 (let ((conflict (intern-soft (get-pname function-spec) new-pkg)))
			   (and conflict
				(neq (symbol-package conflict) new-pkg)
				(loop for (type) in (si:get-all-source-file-names conflict)
				      ;; Ignore deftype stream, e.g.
				      thereis (eq type section-type)))))
		(push function-spec symbols)))))))
    (when (null symbols)
      (barf "There were no conflicting symbols."))
    (setq symbols (sort symbols #'string-lessp))
    (with-editor-stream (stream :buffer-name "Conflicting symbols" :kill t)
      (dolist (symbol symbols)
	(format stream "~S~%" symbol))))
  (let ((buffer (find-buffer-named "Conflicting symbols")))
    (send buffer :putprop package :package)
    (make-buffer-current buffer))
  dis-text)

(defcom com-convert-package-of-region
	"Convert the current region from the current package to another package." ()
  (definition-region (bp1 bp2)
    ;; (undo-save bp1 bp2 t "Package convert")
    (convert-package-interval (get-one-package-to-convert *interval*) bp1 bp2 t))
  dis-text)

(defcom com-convert-package-of-buffer
	"Convert a buffer from the current package to another package.
Also does what m-X Set Package would do." ()
  (let ((buffer (read-buffer-name "Convert Package of Buffer" *interval*)))
    (convert-package-buffer (get-one-package-to-convert buffer) buffer))
  dis-text)

(defcom com-convert-package-of-tag-table
  "Convert some of the buffers in a Tag Table from their current package to another package."
  ()
  (let ((tags-buffer (select-tag-table nil))
	(buffers nil)
	(packages nil))
    (send tags-buffer :restart)
    (loop as node = (send tags-buffer :next-node) while node
	  as buffer = (send node :buffer)
	  as pkg = (send buffer :get :package) do
      (when pkg
	(push buffer buffers)
	(cl:pushnew pkg packages)))
    (unless buffers
      (barf "There are no files with packages in ~A (~A)."
	    (send tags-buffer :name) (send tags-buffer :description)))
    (let ((mappings (get-packages-to-convert (nreverse packages))))
      (setq buffers (loop for buffer in (nreverse buffers)
			  as pkg = (send buffer :get :package)
			  as new-pkg = (cdr (assq pkg mappings))
			  when (and new-pkg (neq new-pkg pkg))
			    collect buffer))
      (unless buffers
	(barf "There are no files to be converted in ~A (~A)."
	      (send tags-buffer :name) (send tags-buffer :description)))
      (let ((query-io sys:syn-terminal-io))
	(format t "File~P to be converted:~%" (length buffers))
	(scl:format-item-list buffers)
	(selectq (fquery '(:choices (((t "Yes.") #\Y #\Space)
				     ((nil "No.") #\N #\Rubout)
				     ((:selective "Selective.") #\S)))
			 "Okay? ")
	  ((t) )
	  ((nil) (setq buffers nil))
	  ((:selective)
	   (setq buffers (loop for buffer in buffers
			       when (cl:y-or-n-p "Convert ~A? " buffer)
				 collect buffer)))))
      (when buffers
	(let ((update-list *set-attribute-updates-list*))
	  (when (eq update-list :ask)
	    (let ((query-io sys:syn-terminal-io))
	      (setq update-list (fquery () "Set the file attribute lists, too? "))))
	  (dolist (buffer buffers)
	    (format t "~&Converting ~A ..." buffer)
	    (convert-package-buffer (cdr (assq (send buffer :get :package) mappings))
				    buffer update-list))
	  (format t "~&Done.~%")))
      dis-text)))

(defun get-one-package-to-convert (buffer)
  (let ((pkg (send buffer :get :package)))
    (or (cdr (assq pkg (get-packages-to-convert (list pkg))))
	(abort-current-command))))

(defvar *pkg-conversion-alist* (list (cons (cl:find-package "ZL-USER")
					   (cl:find-package "CL-USER"))))
(defvar *symbols-not-to-package-convert* '(zl:array zl:arg zl:arglist zl:args
					   zl:comment zl:expr zl:plist zl:status zl:step))

;; Note that this bashes the global values of *pkg-conversion-alist* and
;; *symbols-not-to-package-convert* so that part of what the user specifies
;; in one conversion is remembered as a default for the next conversion.
(defun get-packages-to-convert (packages &optional no-symbols-not-to-package-convert-query)
  (cl:fresh-line)
  (let ((prompts (loop for pkg in packages
		       collect (list " ~A becomes" pkg)))
	(alists nil)
	(dont-convert *symbols-not-to-package-convert*) 	;Don't setq until End pressed
	(previous-dont-convert nil)
	(query-io sys:syn-terminal-io))
    (flet ((write-prompt-line (string)
	     (dw:with-redisplayable-output (:stream query-io
					    :unique-id string
					    :cache-value string)
	       (cl:write-string string query-io))
	     (terpri query-io))
	   (syntax-package-alist (syntax)
	     (loop for must in (si:lisp-syntax-packages-must-use syntax)
		   ;; You might think this should use si:find-package-for-syntax
		   ;; rather than pkg-find-package, but you'd be wrong.
		   ;; The packages-must-use list is always in Zetalisp syntax.
		   as pkgs = (mapcar #'pkg-find-package must)
		   collect
		     (list (with-output-to-string (s)
			     (loop for (pkg . more) on pkgs do
			       ;; pkg-name returns the long, human-readable name,
			       ;; unlike cl:package-name or si:package-name-for-syntax
			       (cl:write-string (string-capitalize-words (pkg-name pkg)) s)
			       (when more (cl:write-string ", " s))))
			   pkgs))))
      (let ((new-packages
	      ;; new-packages is a list in same order as packages.
	      ;; Each element is a package, a list of a name, a syntax and a use-list (when
	      ;; creating a new package), or :dont to avoid converting this package.
	      (dw:accepting-values ()
		(write-prompt-line "Package conversions:")
		(prog1
		  (loop for pkg in packages
			for prompt in prompts collect
		    (let ((spec (scl:accept '((scl:token-or-type
						(("A new package" . :new)
						 ("Don't convert" . :dont))
						cl:package))
				  :query-identifier pkg
				  :prompt prompt
				  :default (or (cdr (assq pkg *pkg-conversion-alist*))
					       :new))))
		      (when (eq spec :new)
			(let ((syntax (lisp-syntax-for-package pkg)))
			  (dw:with-redisplayable-output (:stream query-io
							 :unique-id syntax
							 :cache-value pkg)
			    (format query-io "  Package ~A is in package universe ~A.~%"
				    pkg syntax))
			  (write-prompt-line "  Create new package in package universe:")
			  (setq syntax (scl:accept 'package-universe-lisp-syntax
					 :query-identifier (locf (si:pkg-nicknames pkg))
					 :prompt "    " :prompt-mode :raw
					 :default (si:find-lisp-syntax
						    (if (eq syntax (si:find-lisp-syntax "CL"))
							(si:find-lisp-syntax "CLtL")
							(si:find-lisp-syntax "CL")))))
			  (let ((alist (cdr (assq syntax alists))))
			    (unless alist
			      (push (cons syntax (setq alist (syntax-package-alist syntax)))
				    alists))
			  (let ((use-packages (scl:accept `((scl:alist-member :alist ,alist))
							  :query-identifier (cons pkg alist)
							  :prompt "  New package uses package"
							  :default (cadar alist)))
				(name (scl:accept 'string
						  :query-identifier (locf (pkg-name pkg))
						  :prompt "  New package is named"
						  :default	;Find an unused name
				    (loop for index from 1
					  as name = (format nil "~A-~A" syntax pkg)
						  then (format nil "~A-~A-~D" syntax pkg index)
					  as p = (cl:find-package name)
					  until (null p)
					  as key = (intern (cl:package-name p) "KEYWORD")
					  while (get key ':source-file-name)
					  finally (return name)))))
			    (setq spec (list name syntax use-packages))))))
		      spec))
		  (unless no-symbols-not-to-package-convert-query
		    (write-prompt-line " ")
		    (write-prompt-line 
 "Some symbols are more often used as local variable names than as functions.")
		    (setq dont-convert
			  (scl:accept '((cl:sequence symbol))
			    :prompt " Symbols not to be given package prefixes"
			    :default
			      (let ((l ;; Filter out non-accessible Zetalisp symbols
				      (cl:delete-duplicates
					(loop for sym in dont-convert
					      nconc (loop for pkg in packages
							  as s = (intern-soft sym pkg)
							  when s
							    unless (eq (symbol-package s) pkg)
							      collect s)))))
				;; Keep the default EQ to avoid excess redisplay.
				;; Note that the ACCEPT copies the list somehow, hence  
				;; we have to play games with previous-dont-convert
				;; instead of just using dont-convert for this.
				(if (equal l previous-dont-convert)
				    previous-dont-convert
				    (setq previous-dont-convert l))))))))))
	(send *typeout-window* :make-complete)
	(loop for old-pkg in packages
	      for new in new-packages
	      do
	  (if (eq new :dont)
	      (setq *pkg-conversion-alist* (cl:remove old-pkg *pkg-conversion-alist*
						      :key #'car))
	      (let ((new-pkg (if (atom new) new
				 (destructuring-bind (name syntax use-packages) new
				   (let ((pkg (cl:find-package name)))
				     (when pkg
				       (unuse-package (package-use-list pkg) pkg))
				     (funcall (if pkg #'si:re-make-package #'cl:make-package)
					      name
					      :syntax syntax
					      :use use-packages))))))
		(cl:pushnew (cons old-pkg new-pkg) *pkg-conversion-alist*
			    :key #'car :replace t))))
	(unless no-symbols-not-to-package-convert-query
	  (setq *symbols-not-to-package-convert* dont-convert))
	*pkg-conversion-alist*))))

(defun convert-package-buffer (pkg buffer
			       &optional (*set-attribute-updates-list* t))	;don't query
  (make-buffer-current buffer)
  (convert-package-interval pkg buffer)
  (set-one-context-variable 'package pkg)
  (send buffer :putprop pkg :package)
  (set-attribute-internal :package "Package" (cl:package-name pkg) pkg)
  (invalidate-buffer-sectionization buffer)
  (send *major-mode* :execute-mode-hook))

(defun convert-package-interval (new-pkg bp1 &optional bp2 in-order-p)
  (let ((stream (open-interval-stream bp1 bp2 in-order-p))
	(eof-marker (ncons nil)))
    (condition-bind ((sys:read-error #'conversion-read-error-handler))
      (catch 'skip-end
	(loop doing
	  (let ((thing (catch 'skip-error
			 (si:read-converting-package stream eof-marker
						     package new-pkg
						     *symbols-not-to-package-convert*))))
	    (when (eq thing eof-marker)
	      (return)))))))
  t)

;; Filter out syntaxes like Lisp+C that don't define separate package universes
(defun lisp-syntax-is-package-universe (syntax)
  (let ((from (si:lisp-syntax-inherits-from syntax)))
    (not (and from (setq from (si:find-lisp-syntax from nil))
	      (equal (si:lisp-syntax-packages-must-use syntax)
		     (si:lisp-syntax-packages-must-use from))
	      (eq (si:lisp-syntax-shadow-global-packages syntax)
		  (si:lisp-syntax-shadow-global-packages from))))))

(defun lisp-syntax-for-package (pkg)
  (dolist (syntax si:*known-lisp-syntaxes*)
    (when (lisp-syntax-is-package-universe syntax)
      (when (si:package-satisfies-syntax pkg syntax)
	(return-from lisp-syntax-for-package syntax))))
  (si:find-lisp-syntax "CL"))

;; Same as (and si:lisp-syntax (cl:satisfies lisp-syntax-is-package-universe))
;; except that DW didn't know to filter completion possibilities by the "satisfies" predicate.
(dw:define-presentation-type package-universe-lisp-syntax ()
   :abbreviation-for `(and si:lisp-syntax (cl:satisfies lisp-syntax-is-package-universe))
   :parser ((stream)
	    (multiple-value-bind (syntax success name)
		(dw:completing-from-suggestions (stream :force-complete t
							:partial-completers '(#\sp))
		  (loop for x in si:*known-lisp-syntaxes* do
		    (when (lisp-syntax-is-package-universe x)
		      (dw:suggest (si:lisp-syntax-external-name x) x))))
	      (ignore success name)
	      (values syntax 'si:lisp-syntax)))
   :description "a lisp syntax that is a package-universe"
   :choose-displayer ((stream object query-identifier &key original-type)
		      (dw:accept-values-choose-from-sequence stream
			(loop for x in si:*known-lisp-syntaxes*
			      when (lisp-syntax-is-package-universe x)
				collect x)
			object query-identifier
			:type original-type)))

(defvar *do-simple-conversions-automatically*)
(defvar *automatic-function-conversions*)

;; Enable automatic c-m-Q after inserting a multiline replacement
(defvar *reindent-after-conversion*)

(defvar *use-conversion-feature-expression* nil)
(defvar *conversion-feature-expression* nil)

(defmacro with-function-conversion-state ((&optional set) &body body)
  `(with-function-conversion-state-internal ,set
      #'(lambda (set)
	  (declare (future-common-lisp:ignorable set))
	  ,@body)))

(defun with-function-conversion-state-internal (set continuation)
  (let* ((set (or set (typein-line-accept 'conversion-tools:conversion-set
					  :prompt "Conversion to use")))
	 (*do-simple-conversions-automatically*
	   (and (plusp (cl:hash-table-count
			 (conversion-tools::conversion-set-symbol-conversions set)))
		(cl:yes-or-no-p "Do you want straightforward renamings done without a query? "
				)))
	 (*automatic-function-conversions* nil)
	 (*reindent-after-conversion*
	   (cl:yes-or-no-p "Do you want automatic re-indentation of converted code? "))
	 (*conversion-feature-expression* *conversion-feature-expression*)
	 (*use-conversion-feature-expression* *use-conversion-feature-expression*)
	 (conversion-tools::*conversion-state* nil))
    ;; The defvar isn't always seen before this is compiled
    (declare (special *do-simple-conversions-automatically* *automatic-function-conversions*
		      *reindent-after-conversion* conversion-tools::*conversion-state*
		      *conversion-feature-expression* *use-conversion-feature-expression*))
    (conversion-tools:with-additional-conversion-state
       set #'(lambda () (funcall continuation set)))))

(defcom com-convert-functions-of-region
      "Convert functions in the region using a specified set of templates.
This operation is undoable." ()
  (definition-region (bp1 bp2)
    (with-function-conversion-state ()
      (convert-functions-interval set bp1 bp2 t)))
  dis-text)

(defcom com-convert-functions-of-buffer
	"Convert some of the functions in a buffer using a specified set of templates." ()
  (let ((buffer (read-buffer-name "Convert Functions of Buffer" *interval*)))
    (with-function-conversion-state ()
      (make-buffer-current buffer)
      (convert-functions-interval set buffer)))
  dis-text)

(defcom com-convert-functions-of-tag-table
  "Convert some of the functions in a Tag Table using a specified set of templates." ()
  (let ((set (typein-line-accept 'conversion-tools:conversion-set
				 :prompt "Conversion to use")))
    (select-tag-table-user :convert-functions :set-conversion-set set)))

(define-special-buffer-type convert-functions-buffer
			    (conversion-set) (tag-table-user-special-purpose-buffer)
			    :convert-functions "Convert-functions"
  :settable-instance-variables
  (:buffer-init-options :set-conversion-set))

(defmethod (:description-1 convert-functions-buffer) (stream)
  (cl:write-string
    (conversion-tools:conversion-set-pretty-name conversion-set)
    stream))

(defmethod (:header-description convert-functions-buffer) (stream)
  (format stream "Convert functions ")
  (send self :description-1 stream))

(defmethod (:document convert-functions-buffer) (ignore)
  (format t "Convert functions ")
  (send self :description-1 standard-output))

(defmethod (:select-possibility convert-functions-buffer) (starting-buffer)
  (with-function-conversion-state (conversion-set)
    (loop for buffer = starting-buffer then (send self :next-buffer)
	  for bp = (if (eq buffer *interval*) (point) (buffer-saved-point buffer))
		 then (interval-first-bp buffer)
	  do (send *zmacs-command-loop* :set-interval buffer)
	     (convert-functions-interval conversion-set bp (interval-last-bp buffer) t))))

(defvar *override-conversion-next-bp* nil)

(defun bp-after-string-p (bp string)
  (let ((len (string-length string)))
    (and (>= (bp-index bp) len)
	 (string-equal (bp-line bp) string (- (bp-index bp) len) 0 (bp-index bp) len))))

(defun convert-functions-interval (conversion-set bp1 &optional bp2 in-order-p)
  (get-interval bp1 bp2 in-order-p)
  (let ((search-strings (conversion-tools:conversion-set-search-strings conversion-set))
	(bp bp1)
	(*override-conversion-next-bp* nil))
    (with-bp (bp2 bp2 :moves)
      (loop doing
	(setq bp (fsm-search (or *override-conversion-next-bp* bp) search-strings
			     nil nil nil bp2))
	(when *override-conversion-next-bp*
	  (flush-bp *override-conversion-next-bp*)
	  (setq *override-conversion-next-bp* nil))
	(when (null bp)
	  (return nil))
	(let* ((front-bp (forward-atom bp -1 t))
	       (back-bp (forward-atom front-bp)))
	  (block done-with-this
	    (when (null back-bp) (return-from done-with-this))
	    (select (list-syntax (bp-char-before front-bp))
	      (list-open
		(block trying-whole-list
		  (let (form correspondences)
		    (condition-case (error)
			 (let ((bp1 (forward-char front-bp -1))
			       (si:xr-maintain-correspondence t)
			       (si:xr-correspondences nil)
			       ;; prevent comma not inside backquote error
			       (si:**backquote-count** 1000))
			   (move-point bp1)	;some conversions need point
			   (setq form (read (open-interval-stream bp1 bp2))
				 correspondences si:xr-correspondences))
		       (error
			 (let ((cl:*print-level* 3)	;Enough for a defmethod
			       (cl:*print-length* 4))
			   (format t "~&WARNING: Unable to parse ~S:~%~9@T~~A~"
				   (string-interval (forward-char front-bp -1)
						    (zwei:forward-list front-bp 1 t 1))
				   error)
			   (return-from trying-whole-list))))	;Try just car
		    (catch-error-restart (error "Skip converting ~Q"
						(lambda ()
						  (cl:write form :level 2 :length 4)))
		      (let ((possibilities (conversion-tools:form-conversions conversion-set
									      form)))
			;; Each element of possibilities is (new-form converter hints)
			(when possibilities
			  (conversion-query-list-possibilities form correspondences
							       possibilities)))))
		  (return-from done-with-this)))
	      (list-single-quote
	        ;; Look for a functional argument written as #'f
		(when (bp-after-string-p front-bp "#'")
		  (catch-error-restart (error "Skip converting #'~Q"
					      (lambda ()
						(stream-out-interval standard-output
								     front-bp back-bp t)))
		    (when (convert-funarg conversion-set front-bp back-bp)
		      (return-from done-with-this)))))
	      (list-delimiter
	        ;; Look for a function argument written as (function f)
		(let ((bp (forward-list front-bp -1 nil 1)))
		  (when (and bp
			     (eq (condition-case ()
				      (read-from-string (bp-line bp) nil (1+ (bp-index bp)))
				    (error nil))
				 'function))
		    (catch-error-restart (error "Skip converting ~Q"
						(lambda ()
						  (stream-out-interval standard-output
								       bp (forward-list bp)
								       t)))
		      (when (convert-funarg conversion-set front-bp back-bp)
			(return-from done-with-this)))))))
	    ;; An atom in the middle of a list, just try simple substitutions.
	    (let ((line (bp-line front-bp)))
	      (unless (eq line (bp-line back-bp))
		(return-from done-with-this))
	      (condition-case (atom)
		   (read-from-string line nil (bp-index front-bp) (bp-index back-bp))
		 (error (return-from done-with-this))
		 (:no-error
		   (unless (symbolp atom) (return-from done-with-this))
		   (catch-error-restart (error "Skip converting ~S" atom)
		     (let ((new-atom (conversion-tools:symbol-conversion conversion-set
									 atom)))
		       (unless new-atom (return-from done-with-this))
		       (conversion-query-atom atom new-atom front-bp back-bp))))))))))))

(defun convert-funarg (conversion-set front-bp back-bp)
  (condition-case (function)
       (read-from-string (bp-line front-bp) nil (bp-index front-bp) (bp-index back-bp))
     (error nil)
     (:no-error
       (when (symbolp function)
	 (let ((possibilities (conversion-tools:funarg-conversions conversion-set function)))
	   (when possibilities
	     (conversion-query-atom-possibilities function possibilities
						  front-bp back-bp)))))))

(defun pretty-feature-name (feature)
  (and feature
       (or (if (symbolp feature) (get feature 'feature-pretty-name))
	   (if (or (stringp feature) (symbolp feature))
	       (cl:string-capitalize feature))
	   feature)))

(defmacro convert-maybe-saving-old ((bp1 bp2 &rest options) &body forms)
  (cl:check-type bp1 symbol "a variable name")
  (cl:check-type bp2 symbol "a variable name")
  `(convert-maybe-saving-old-internal ,bp1 ,bp2 #'(lambda (,bp1 ,bp2) ,@forms) ,@options))

(defun convert-maybe-saving-old-internal (bp1 bp2 continuation &key multi-line-p)
  (declare (future-common-lisp:dynamic-extent continuation))
  (let ((separator (if multi-line-p #\Newline (si:pttbl-space cl:*readtable*)))
	(prefix-string nil))
    (with-bp (cursor bp1 :moves)
      (when (and *use-conversion-feature-expression* *conversion-feature-expression*)
	;; This next little item is a minor kludge to handle the practical fact that
	;;   #'#+FOO X #-FOO Y
	;; while technically correct, looks better as
	;;   #+FOO #'X #-FOO #'Y
	;; It could be removed with no change to the functional correctness of this code.
	;; -kmp 29-Oct-92
	(dolist (possible-prefix '("#'" "'"))
	  (when (bp-after-string-p cursor possible-prefix)
	    (move-bp cursor
		     (bp-line cursor)
		     (- (bp-index cursor) (string-length possible-prefix)))
	    (setq prefix-string possible-prefix)
	    (return)))
	(insert-moving cursor
		       (format nil "#-~A~C~@[~A~]~A~C#+~A~C~@[~A~]"
			       (pretty-feature-name *conversion-feature-expression*)
			       separator
			       prefix-string
			       (string-interval bp1 bp2)
			       separator
			       (pretty-feature-name *conversion-feature-expression*)
			       separator
			       prefix-string))
	(setq *override-conversion-next-bp* (copy-bp cursor)))
      (funcall continuation cursor bp2))))

(defvar *conversion-possibility-cache* '())

(defun conversion-possibility-cache (n)
  (declare (values ptype prompt))
  (let ((entry (cl:assoc n *conversion-possibility-cache*)))
    (if entry
	(values (cadr entry) (caddr entry))
      (let* ((options (loop for i from 1 to n collect (cl:digit-char i 36.)))
	     (options-string
	       (format nil "~{~A~^~#[~; or ~:;, ~]~}" options))
	     (ptype `((and cl:character
			   (cl:member
			     ,@(loop for i from 1 to n
				     collect (cl:digit-char i 36.)
				     when (>= i 10)
				       collect (char-downcase (cl:digit-char i 36.)))))
		      :description
		      ,(format nil "a character (~A)" options-string)))
	     (prompt (format nil "Which replacement? ~@[(1-~A) ~]"
			     (if (> n 1) (car (last options))))))
	(push (list n ptype prompt) *conversion-possibility-cache*)
	(values ptype prompt)))))

;;; Returns t if it did a conversion, nil if it didn't
(defun conversion-query-possibilities (&key multiple-prompt-function
				            unique-prompt-function
					    simple-p-function
					    replacement-function
					    autokey-key-function
					    autokey-choice-function
					    autokey-setup-function
					    possibilities start-bp end-bp
					    &aux (cl:*standard-output* *typeout-window*)
					    	 (n-possibilities (length possibilities))
						 (unique (= n-possibilities 1)))
  (labels ((show-context ()
	   (show-interval-in-context start-bp end-bp))
	   (echo (format-string &rest format-args)
	     (scl:with-character-style ('(nil :italic nil))
	       (cl:apply #'format t format-string format-args))
	     (terpri))
	   (show-command-prompt ()
	     (format t "~&Conversion command (or ~C): " #\Help))
	   (set-current-feature-name (&key (no-nulls t))
	     (setq *conversion-feature-expression*
		   (typein-line-accept
		     (if no-nulls 'cl:keyword '((scl:null-or-type cl:keyword)))
		     :prompt "Feature name upon which to conditionalize changes (or None)"
		     :provide-default nil)))
	   (prompt-for-possibility ()
	     (let ((cl:*query-io* *typeout-window*))
	       (if unique
		   (values (first possibilities) #\1)
		   (let ((char (multiple-value-bind (ptype prompt)
				   (conversion-possibility-cache n-possibilities)
				 (scl:accept ptype
					     :display-default t
					     :prompt prompt
					     :prompt-mode :raw))))
		     (cl:write-char #\Space cl:*query-io*)
		     (values (possibility-named char) (char-upcase char))))))
	   (possibility-named (char)
	     (let ((weight (cl:digit-char-p char 36.)))
	       (when (and weight (<= 1 weight n-possibilities))
		 (nth (1- weight) possibilities)))))
    ;; Check for case of no need to query
    (when (and *do-simple-conversions-automatically*
	       unique
	       (funcall simple-p-function (first possibilities)))
      (with-interval-write-locked (start-bp end-bp t)
	(funcall replacement-function (first possibilities)))
      (return-from conversion-query-possibilities t))
    (multiple-value-bind (key1 key2) (funcall autokey-key-function)
      (let ((proceed (or (cl:assoc key1 *automatic-function-conversions* :test #'cl:equal)
			 (and key2 (cl:assoc key2 *automatic-function-conversions*
					     :test #'cl:equal)))))
	(when proceed
	  (multiple-value-bind (possibility saved-state)
	      (funcall autokey-choice-function proceed possibilities)
	    (when possibility
	      (zwei:with-interval-write-locked (start-bp end-bp t)
		;; Note that sometimes the replacement-function gets saved-state arguments
		;; (i.e., here it does) and other places it does not (i.e., other places
		;; it does not), so all such arguments must be optional in the replacement
		;; function so that it doesn't err on wrong-number-of-arguments when they
		;; are not passed (or when they are).  The intent is that they should default
		;; from global state, but that the autokey-setup-function could record
		;; that global state at the time of setup to later override the global state
		;; that's available here.
		(cl:apply replacement-function possibility saved-state))
	      (return-from conversion-query-possibilities t))))))

    ;; Show context
    (move-point start-bp)
    (show-context)

    (loop with dont-prompt = nil
	  ;; Contain the effect of pressing # to just this command.
	  with *use-conversion-feature-expression* = *use-conversion-feature-expression*
	  doing
      ;; Describe the possible conversion(s)
      (unless dont-prompt
	(cl:fresh-line)
	(cond (unique
	       (funcall unique-prompt-function (first possibilities) cl:*standard-output*)
	       (show-command-prompt))
	      (t
	       (format t "Possible conversions being considered~Q:~%"
		       #'mention-conversion-style)
	       (loop for n from 1
		     for possibility in possibilities do
		 (format t "~C. " (cl:digit-char n 36))
		 (funcall multiple-prompt-function possibility cl:*standard-output*)
		 (terpri))
	       (show-command-prompt))))
      (setq dont-prompt nil)

      ;; Accept and execute a response character
      (let ((char (send *typeout-window* :tyi)))
	(selector char char-equal
	  ((#\Space #\Y)
	   (echo (if (> n-possibilities 1) "Yes, first conversion." "Yes."))
	   (send *typeout-window* :make-complete)
	   (with-interval-write-locked (start-bp end-bp t)
	     (funcall replacement-function (first possibilities)))
	   (must-redisplay *window* dis-text)
	   (return t))
	  ((#\Rubout #\N)
	   (echo "No.")
	   (send *typeout-window* :make-complete)
	   (return nil))
	  ((#\P)
	   (echo "Proceed automatically.")
	   (let ((possibility (prompt-for-possibility)))
	     (send *typeout-window* :make-complete)
	     (with-interval-write-locked (start-bp end-bp t)
	       (funcall replacement-function possibility))
	     (must-redisplay *window* dis-text)
	     (funcall autokey-setup-function possibility)
	     (return t)))
	  ((#/;)
	   (echo "Convert with comment.")
	   (let ((possibility (prompt-for-possibility)))
	     (send *typeout-window* :make-complete)
	     (with-interval-write-locked (start-bp end-bp t)
	       (with-bp (start-bp start-bp :normal)
		 (funcall replacement-function possibility)
		 ;; Split the line
		 (let ((ind (bp-indentation start-bp))
		       (bp (insert start-bp #\CR)))
		   (indent-line bp ind))
		 ;; Add a comment
		 (insert start-bp ";;---** Is this conversion correct? **---")))
	     (must-redisplay *window* dis-text)
	     (return t)))
	  ((#/, #/. #//)
	   (let ((n (cl:position char ",.//" :test #'char-equal)) possibility char)
	     (when (or (and (< n 2) (< n n-possibilities))
		       (and (= n 2) (= 3 n-possibilities)))
	       (setq possibility (nth n possibilities)
		     char (cl:digit-char (1+ n) 36.)))
	     (unless char
	       (cl:multiple-value-setq (possibility char) (prompt-for-possibility)))
	     (echo (if unique "Convert then edit." "Do ~:R conversion then edit.")
		   (cl:digit-char-p char 36.))
	     (send *typeout-window* :make-complete)
	     (with-interval-write-locked (start-bp end-bp t)
					 (funcall replacement-function possibility))
	     (must-redisplay *window* dis-text)
	     (control-R)
	     (must-redisplay *window* dis-bps)
	     (return t)))
	  ((#\c-L #\Refresh)
	   (send *typeout-window* :clear-window)
	   (show-context))
	  ((#\c-R)
	   (send *typeout-window* :make-complete)
	   (control-R)
	   (must-redisplay *window* dis-bps))
	  ((#\Help)
	   (echo "Show full command documentation.")
	   ;; This intentionally does not list the scrolling commands, since those
	   ;; ought to work in every context.
	   (macrolet ((entry (commands format-string &rest format-args)
			`(dw:formatting-row ()
			   (dw:formatting-cell ()
			     (format t "~{~A~^ or ~}" ,commands))
			   (dw:formatting-cell ()
			     (format t ,format-string ,@format-args)))))
	     (terpri)
	     (send *typeout-window* :clear-window)
	     (scl:surrounding-output-with-border (t :thickness 2
						    :margin (* 1 (send cl:*standard-output*
								       :char-width))
						    :label "Conversion Commands"
						    :label-separator-line t
						    :label-position :top
						    :label-alignment :center)
	       (dw:formatting-table (t :inter-column-spacing
				       (* (send cl:*standard-output* :char-width) 2))
		 (dw:formatting-row ()
		   (dw:formatting-cell () (scl:with-underlining (t :underline-whitespace nil)
					    (princ "Command")))
		   (dw:formatting-cell () (scl:with-underlining () (princ "Effect"))))
		 (cond (unique
			 (entry '("Y" "Space") "Make this replacement."))
		       (t
			 (entry '("Y" "Space" 1) "Make the first replacement.")
			 (loop for i from 2 to n-possibilities
			       do (entry (list i) "Make the ~:R replacement." i))))
		 (entry '("N" "Rubout") "Skip making this replacement.")
		 (entry '("P") "Make ~:[a~;this~] replacement each time it occurs, ~
			        without always asking.~:*~:[~
			      ~%  Prompts for which of the ~R replacement options to use.~
				  ~;~*~]"
			unique n-possibilities)
		 (entry '("Control-R") "Edit the buffer and ask again after End is pressed.")
		 (entry '("Comma (,)")
			"Make the~:[ first~;~] replacement and then edit."
			unique)
		 (when (> n-possibilities 1)
		   (entry '("Period (.)") "Make the second replacement and then edit."))
		 (when (> n-possibilities 2)
		   (entry '("Slash (//)")
			  (if (= n-possibilities 3)
			      "Make the third replacement and then edit."
			      "Make a replacement and then edit.~
			     ~%Prompts for which of the ~R replacement options to use.")
			  n-possibilities))
		 (entry '("Control-L" "Refresh") "Show context and ask again.")
		 (entry '("Semicolon (;)")
			"Make the replacement with an /"Is this correct?/" comment.")
		 (entry '("#")
			"Arrange for the replacement of this ``old'' expression to be~
		       ~%  ~:[just ``new''~*~;``#-~A old #+~:*~A new''~]~2:* rather than~
		       ~:[ ~;~%  ~]~:*the current replacement style,~
		       ~:[~%  ~; ~]~:*which is ~
		       ~:[``#-~A old #+~:*~A new''~;just ``new''~*~].~:[~;~
		       ~%  (Prompts for a feature name to use instead of ``something''.)~]~
		       ~%  This doesn't cause the replacement to occur.  You still have ~
		       ~%  to use a command like Y or P to make it take effect.~
		       ~%  This command is a toggle; ~
			   pressing it twice undoes the first effect."
			(not *use-conversion-feature-expression*) ;i.e., effect of toggling
			(or (pretty-feature-name *conversion-feature-expression*)
			    "something")
			(and (not *use-conversion-feature-expression*)
			     (not *conversion-feature-expression*)))
		 (entry '("Control-#")
			"Prompt for a feature name to be used by the # command~:[~;~
		       ~%  instead of ~:*~A~]."
			(pretty-feature-name *conversion-feature-expression*))
		 (entry '("Help") "Show a full description of the available commands.")
		 ))
	     (show-context)))
	  ((#\c-#)
	   (echo "Set feature name default.")
	   (set-current-feature-name :no-nulls nil)
	   (if *conversion-feature-expression*
	       (format t "~&The default is now to use #+~A conditionals."
		       (pretty-feature-name *conversion-feature-expression*))
	       (format t "~&There is currently no default feature name.~
			  ~%I will prompt for a feature name next time I need one.")))
	  ((#\#)
	   (let ((use-p (not *use-conversion-feature-expression*)))
	     (echo "Change replacement style to ~:[``new''~;``#-~A old #+~:*~A new''~]."
		   use-p (or (pretty-feature-name *conversion-feature-expression*)
			     "something"))
	     (when (and use-p (not *conversion-feature-expression*))
	       (set-current-feature-name))
	     ;; Set this last so that if the user aborts out of the ACCEPT,
	     ;; he aborts the entire effect.
	     (setq *use-conversion-feature-expression* use-p)))
	  ((#\Scroll #\Control-V #\Control-Scroll)
	   (cp::scroll-window-command-internal :screen 1 :y *typeout-window*)
	   (setq dont-prompt t))
	  ((#\Meta-Scroll #\Meta-V #\Meta-Control-Scroll
	    #\Keyboard:Back-Scroll #\Control-Keyboard:Back-Scroll)
	   (cp::scroll-window-command-internal :screen -1 :y *typeout-window*)
	   (setq dont-prompt t))
	  ((#\Super-S #\Keyboard:Find)
	   (cp::scroll-search-command-internal :window *typeout-window* :direction :forward)
	   (setq dont-prompt t))
	  ((#\Super-R #\Meta-Keyboard:Find)
	   (cp::scroll-search-command-internal :window *typeout-window* :direction :backward)
	   (setq dont-prompt t))
	  (otherwise
	    (let ((possibility (possibility-named char)))
	      (when possibility
		(echo "Yes, use ~:R conversion." (cl:digit-char-p char 36.))
		(send *typeout-window* :make-complete)
		(with-interval-write-locked (start-bp end-bp t)
		  (funcall replacement-function possibility))
		(must-redisplay *window* dis-text)
		(return t))
	      (beep)
	      (echo "Invalid command: ~@:C" char)
	      (format t "~&Conversion commands are single characters.~%")
	      (format t "Press Y")
	      (when (> n-possibilities 1)
		(format t " (or 1)")
		(loop for n from 2 to n-possibilities do
		  (format t ", ~C" (cl:digit-char n 36))))
	      (format t ", N, P, c-R, ")
	      (dotimes (n (min n-possibilities 3))
		(format t "~A, " (nth n '("comma" "period" "slash"))))
	      (format t "c-L, semicolon, #, c-# or Help.~
		       ~%If you're not sure which command you want, press Help.~%")
	      (show-command-prompt)
	      (setq dont-prompt t))))))))

(defun mention-conversion-style ()
  (when *use-conversion-feature-expression*
    (let ((x (send cl:*standard-output* :read-cursorpos :character))
	  (wid (send cl:*standard-output* :size-in-characters))
	  (string (format nil "conditional upon #+~A"
			  (pretty-feature-name
			    (or *conversion-feature-expression*
				"D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")something0")))))
      (format t ",~:[ ~;~%~]~A" (> (+ x (string-length string) 4) wid) string))))

(defun show-interval-in-context (start-bp end-bp)
  (multiple-value-bind (area-start-bp area-end-bp)
      (let ((interval (definition-interval start-bp)))
	(values (interval-first-bp interval) (interval-last-bp interval)))
    (let ((3-lines-before (forward-line start-bp -3 t)))
      (when (bp-< area-start-bp 3-lines-before)
	(setq area-start-bp 3-lines-before)))
    (let ((3-lines-after (forward-line end-bp +3 t)))
      (when (bp-< 3-lines-after area-end-bp)
	(setq area-end-bp 3-lines-after)))
    (format *typeout-window* "~2&For this fragment:~%")
    (stream-out-interval *typeout-window* area-start-bp start-bp)
    (scl:with-character-face (:bold *typeout-window*)
      (stream-out-interval *typeout-window* start-bp end-bp))
    (stream-out-interval *typeout-window* end-bp area-end-bp)
    (terpri *typeout-window*)))

(defun conversion-query-atom (old new start-bp end-bp)
  (with-bp (head start-bp :moves)
    (with-bp (tail end-bp :normal)
      (conversion-query-possibilities
	:unique-prompt-function
	(zl:named-lambda unique-prompt (possibility stream)
	    (declare (ignore possibility) (sys:downward-function))
	    (format stream "Replace ~S with ~S~Q? "
		    old new #'mention-conversion-style))
	:simple-p-function #'false
	:replacement-function
	(zl:named-lambda replacement (possibility
				       &key (*use-conversion-feature-expression*
					      *use-conversion-feature-expression*)
				            (*conversion-feature-expression*
					      *conversion-feature-expression*))
	    (declare (ignore possibility) (sys:downward-function))
	    (convert-maybe-saving-old (head tail)
	      (case-replace head tail (cl:write-to-string new :case :downcase))))
	:autokey-key-function
	(zl:named-lambda autokey-key () (values old nil))
	:autokey-choice-function
	(zl:named-lambda autokey-choice (proceed possibilities)
	    (declare (ignore possibilities))
	    (values t (cdr proceed)))
	:autokey-setup-function
	(zl:named-lambda autokey-setup (possibility)
	    (declare (ignore possibility) (sys:downward-function))
	    (push (list old :*use-conversion-feature-expression*
			     *use-conversion-feature-expression*
			    :*conversion-feature-expression*
			     *conversion-feature-expression*)
		  *automatic-function-conversions*))
	:possibilities '(nil) :start-bp head :end-bp tail))))

(defun conversion-query-atom-possibilities (old possibilities start-bp end-bp)
  (with-bp (head start-bp :moves)
    (with-bp (tail end-bp :normal)
      (conversion-query-possibilities
	:multiple-prompt-function
	(zl:named-lambda multiple-prompt (possibility standard-output)
	    (declare (sys:downward-function))
	    (let ((new (conversion-tools::funarg-conversion-new-function possibility)))
	      (conversion-tools::function-conversion-document-form new old possibility)
	      (format t "   ")
	      (conversion-tools::function-conversion-print-form new old possibility)))
	:unique-prompt-function
	(zl:named-lambda unique-prompt (possibility stream)
	    (declare (sys:downward-function))
	    (format stream "Replace ~S with ~S~Q? "
		    old (conversion-tools::funarg-conversion-new-function possibility)
		    #'mention-conversion-style))
	:simple-p-function #'false
	:replacement-function
	(zl:named-lambda replacement (possibility
				       &key (*use-conversion-feature-expression*
					      *use-conversion-feature-expression*)
				             (*conversion-feature-expression*
					       *conversion-feature-expression*))
	    (declare (sys:downward-function))
	    (convert-maybe-saving-old (head tail)
	      (case-replace head tail (cl:write-to-string
					(conversion-tools::funarg-conversion-new-function
					  possibility)
					:case :downcase))))
	:autokey-key-function
	(zl:named-lambda autokey-key () (values old nil))
	:autokey-choice-function
	(zl:named-lambda autokey-choice (proceed possibilities)
	    (values (cl:find (second proceed) possibilities
			     :key #'conversion-tools::function-conversion-name)
		    (cddr proceed)))
	:autokey-setup-function
	(zl:named-lambda autokey-setup (possibility)
	    (declare (sys:downward-function))
	    (push (list old (conversion-tools::function-conversion-name possibility)
			:*use-conversion-feature-expression*
			 *use-conversion-feature-expression*
			:*conversion-feature-expression*
			 *conversion-feature-expression*)
		  *automatic-function-conversions*))
	:possibilities possibilities :start-bp head :end-bp tail))))

(defun conversion-query-list-possibilities (original-form correspondences possibilities)
  (multiple-value-bind (start-bp end-bp)
      (form-correspondence-range original-form correspondences)
    (unwind-protect
	(zwei:conversion-query-possibilities
	  :multiple-prompt-function
	  (zl:named-lambda multiple-prompt (possibility standard-output)
	      (destructuring-bind (new-form converter hints) possibility
		(declare (ignore hints))
		(conversion-tools:function-conversion-document-form
		  new-form original-form converter)
		(format t "~&  ")
		(conversion-tools:function-conversion-print-form
		  new-form original-form converter)))
	  :unique-prompt-function
	  (zl:named-lambda unique-prompt (possibility standard-output)
	      (destructuring-bind (new-form converter hints) possibility
		(declare (ignore hints))
		(multiple-value-bind (x y) (send standard-output :read-cursorpos)
		  (format t "Replace ")
		  (conversion-tools:function-conversion-print-form original-form new-form nil)
		  (multiple-value-bind (xx yy) (send standard-output :read-cursorpos)
		    (ignore x xx)
		    (if (eql y yy)
			(format t " with ")
			(format t "~%with ")))
		  (conversion-tools:function-conversion-print-form
		    new-form original-form converter)
		  (format t "~Q? " #'mention-conversion-style))))
	  :simple-p-function
	  (zl:named-lambda simple-p (possibility)
	      (null (second possibility)))	;no converter
	  :replacement-function
	  (zl:named-lambda replacement (possibility
					 &key (*use-conversion-feature-expression*
						*use-conversion-feature-expression*)
					      (*conversion-feature-expression*
						*conversion-feature-expression*))
	      (destructuring-bind (new-form converter hints) possibility
		(multiple-value-bind (new-string start-bp end-bp)
		    (form-correspondence-replacement
		      original-form new-form hints correspondences
		      (if converter
			  (conversion-tools:function-conversion-modification-depth converter)
			  1))
		  (cl:assert (stringp new-string))	;make sure it didn't return nil
		  ;; Remove a common tail of completely unchanged lines
		  ;; E.g. when converting selectq to case
		  (let ((length (string-length new-string)))
		    (loop as index = (cl:position #\Return new-string :end length :from-end t)
			  until (null index)
			  until (eq (bp-line end-bp) (bp-line start-bp))
			  while (cl:string= new-string (bp-line end-bp)
					    :start1 (1+ index) :end1 length
					    :start2 0 :end2 (bp-index end-bp))
			  do (setq length index)
			     (setq end-bp (end-line end-bp -1)))
		    (with-bp (start-bp start-bp :normal)
		      (with-undo-save ("conversion" start-bp end-bp t)
			(convert-maybe-saving-old (start-bp end-bp :multi-line-p t)
			  (delete-interval start-bp end-bp t)
			  (insert start-bp new-string 0 length))
			;; If stuff is changed after the first line, re-indent
			(when (and *reindent-after-conversion*
				   (or (and *conversion-feature-expression*
					    *use-conversion-feature-expression*)
				       (cl:find #\Return new-string :end length)))
			  (with-node-write-locked ((bp-node-to-lock start-bp))
			    ;; Why do we do all this idiotic forward/backward-sexp
			    ;; stuff when it looks like start-bp and end-bp already
			    ;; exactly bound our converted region?? -kmp 29-Oct-92
			    (let ((bp2 (forward-sexp
					 start-bp
					 (if (and *conversion-feature-expression*
						  *use-conversion-feature-expression*)
					     4 1)))
				  (bp1 (beg-line start-bp 1 t)))
			      (when (and bp1 bp2 (bp-< bp1 bp2))
				(indent-interval-for-lisp bp1 bp2 t)))))))))))
	  :autokey-key-function
	  (zl:named-lambda autokey-key () (values (list (car original-form)) original-form))
	  :autokey-choice-function
	  (zl:named-lambda autokey-choice (proceed possibilities)
	      (dolist (possibility possibilities)
		(when (memq (second possibility) (cadr proceed))
		  (return (values possibility (cddr proceed))))))
	  :autokey-setup-function
	  (zl:named-lambda autokey-setup (possibility)
	      (let ((key (if (and (second possibility)
				  ;; Question is phrased so the most common answer is yes
				  (not
				    (y-or-n-p "Automatic even with different arguments? ")))
			     original-form (list (car original-form)))))
		(let ((proceed (cl:assoc key *automatic-function-conversions*
					 :test #'cl:equal)))
		  (unless proceed
		    (push (setq proceed (list* key '() '()))
			  *automatic-function-conversions*))
		  (push (second possibility) (cadr proceed))
		  (setf (cddr proceed)
			(list :*use-conversion-feature-expression*
			       *use-conversion-feature-expression*
			      :*conversion-feature-expression*
			       *conversion-feature-expression*)))))
	  :possibilities possibilities :start-bp start-bp :end-bp end-bp)
      (flush-bp start-bp)
      (flush-bp end-bp))))

(defun form-correspondence-range (form correspondences)
  (declare (values start-bp end-bp))
  (let ((entry (assq form correspondences)))
    (values (copy-bp (si:correspondence-interval-start-bp
		       (si:correspondence-entry-interval entry))
		     :moves)
	    (copy-bp (si:correspondence-interval-end-bp
		       (si:correspondence-entry-interval entry))
		     :normal))))

;;; Pauper's grinder:
;;; If we are past margin-1, then if the next thing to print would go
;;; past margin-3 (or the next two would go past margin-2 if the next
;;; thing to print is a keyword), then use Return instead of Space
(cl:defparameter *form-replacement-right-margin-1* 40)
(cl:defparameter *form-replacement-right-margin-2* 70)
(cl:defparameter *form-replacement-right-margin-3* 70)

;;; The idea is to keep the comments as close to the correct place as possible. 
;;; modification-depth is the depth down from the original form in which lists have some
;;; elements changed.  It is usually 1 except for things like selectq  case, where a t
;;; might turn into an otherwise.
(defun form-correspondence-replacement (old-form new-form hints
					correspondences modification-depth)
 (let ((case (if (assq (mode-of-flavor 'electric-shift-lock-mode t) *mode-list*)
		 :upcase :downcase))
       (entry (assq old-form correspondences)))
  (when entry
   (values
    (with-output-to-string (stream)
     (labels
       ((output-interval (bp1 bp2)
	  (stream-out-interval stream bp1 bp2))
	(output-atom (atom)
	  (cl:write atom :stream stream :case case))
	(output-string (string)
	  (cl:write-string string stream))
	(output-char (char)
	  (cl:write-char char stream))
	;; output-newline and output-space-or-newline are terrible kludges, but I don't
	;; seem to have the option of using a real pretty-printer here, and without
	;; this we generate lines that are much, much too long
	(output-newline ()
	  (output-string #.(string-append #\Return #\Tab #\Tab)))
	(output-space-or-newline (list enclosing-form)
	  (let ((x (send stream :read-cursorpos :character)))
	    (cond ((and (> x *form-replacement-right-margin-1*)
			(if (or (and (keywordp (car list)) (evenp (length list)))
				(memq (car list) lambda-list-keywords))
			    (> (+ x (flatsize (car list))
				  (if (cl:consp (cdr list)) (flatsize (cadr list)) 0))
			       *form-replacement-right-margin-2*)
			    (> (+ x (flatsize (car list)))
			       *form-replacement-right-margin-3*)))
		   ;; Not enough room left on the line
		   (output-newline))
		  ((and (tailp list enclosing-form)
			(neq list enclosing-form)
			(symbolp (first enclosing-form))
			(fdefinedp (first enclosing-form))
			(let ((arglist (arglist (first enclosing-form))))
			  (and (cl:consp (last arglist))
			       (memq '&body arglist)
			       (loop for item in arglist
				     with args = (cdr enclosing-form) do
				 (cond ((eq item '&body) (return (eq args list)))
				       ((memq item lambda-list-keywords))
				       (t (pop args)))))))
		   ;; Always put a newline before the body of a special form or macro
		   (output-newline))
		  (t
		   (output-char (si:pttbl-space readtable))))))
	(same-car-p (old new)
	  (loop while (and (cl:consp old) (cl:consp new))
		thereis (eq (car old) (car new))
		do (setq old (car old) new (car new))))
	(output-form (form)
	  (if (atom form)
	      (output-atom form)
	      (let ((entry (assq form correspondences)))
		(cond (entry
		       (lexpr-funcall #'output-interval
				      (si:correspondence-entry-interval entry)))
		      ((memq (car form) '(quote function))
		       (output-atom form))
		      (t
		       (output-char (si:pttbl-open-paren readtable))
		       (do ((list form (cdr list)))
			   ((atom list)
			    (when list
			      (output-string (si:pttbl-cons-dot readtable))
			      (output-form list)))
			 (unless (eq list form)
			   (output-space-or-newline list form))
			 (output-form (car list)))
		       (output-char (si:pttbl-close-paren readtable)))))))
	(output-modified-form (old-form new-form entry depth tail)
	  ;; Can sometimes get here for things that aren't printed enclosed in parentheses
	  (when (or (atom new-form)
		    (memq (car new-form) '(quote function)))
	    (return-from output-modified-form
	      (output-atom new-form)))
	  (unless entry		;old-form is probably an atom
	    (return-from output-modified-form
	      (output-form new-form)))
	  ;; Normal case, old-form and new-form are similar lists
	  (let* ((interval (si:correspondence-entry-interval entry))
		 (interval-end (forward-char (si:correspondence-interval-end-bp interval) -1))
		 (inferiors (nthcdr (or tail 0)
				    (si:correspondence-entry-inferiors entry))))
	    ;; Open list
	    (cond (tail
		   (when (zerop tail)
		     ;; Just about to start a wrapped unmodified tail.
		     ;; The space that would go here was already
		     ;; used preceding the wrapping form.
		     (output-newline))		   
		   (output-char (si:pttbl-open-paren readtable)))
		  ((and inferiors (cl:some #'si:correspondence-interval-start-bp inferiors))
		   ;; Output the characters from the beginning of the list up to the
		   ;; beginning of the first list element, normally just an open parenthesis
		   ;; Skip intervals of NIL, list elements with no source, as in backquote
		   (output-interval (si:correspondence-interval-start-bp interval)
				    (loop for inf in inferiors
					  unless (null inf)
					    return (si:correspondence-interval-start-bp inf))))
		  (t
		   ;; old-form = ()
		   (output-char (bp-char (si:correspondence-interval-start-bp interval)))))
	    ;; Maintain place in original source where thing found,
	    ;; set of delimiter intervals (this is where the comments are),
	    ;; flag when subform used, flag when space after subform used,
	    ;; flag when subform starts on a new line but the space before it
	    ;; contained a comment that was glued to the preceding form,
	    ;; flags for last subform of new-form wraps around a tail of old-form.
	    (stack-let ((sources (make-array (length new-form)))
			(spaces (make-array (1+ (length new-form))))
			(more-spaces (make-array (length new-form)))
			(form-used-p (make-array (length inferiors) :type 'sys:art-boolean))
			(space-used-p (make-array (length inferiors) :type 'sys:art-boolean))
			(new-line-p (make-array (length new-form) :type 'sys:art-boolean))
			(new-tail nil)
			(old-tail nil))
	      ;; This is a four pass algorithm.  The first pass, the body of this flet,
	      ;; matches up the subforms of new-form and of old-form, recording its results
	      ;; in the sources and form-used-p arrays.   These three flets are the final
	      ;; three passes: a second pass of matching up subforms, a pass that decides
	      ;; where the comments will go and records its results in the spaces and
	      ;; space-used-p arrays, and finally the actual outputting of the subforms,
	      ;; the spaces/comments between them, and the close.
	      (flet ((assign-subforms (new-limit old-limit)
		       ;; Match up subforms that haven't been matched up yet, using less
		       ;; ironclad methods than were used by the first pass
		       (loop for j below new-limit
			     for subform in new-form do
			 (unless (or (aref sources j) (atom subform))
			   (loop for i below old-limit
				 for old-subform in old-form do
			     (unless (aref form-used-p i)
			       (when (same-car-p old-subform subform)
				 (setf (aref sources j) i)
				 (setf (aref form-used-p i) t)
				 (return)))))))
		     
		     (assign-comments (new-limit)
		       ;; First pass: glue comments onto their associated forms 
		       (dotimes (j new-limit)
			 (let ((index (if (eql j new-tail)
					  old-tail		;in case comment precedes it
					  (aref sources j))))
			   (when index
			     ;; If we know where this subform came from, and there
			     ;; was a comment after it, try to keep the comment in
			     ;; the corresponding place.
			     (unless (or (aref space-used-p index)
					 (null (nth index inferiors)))
			       (let* ((bp1 (si:correspondence-interval-end-bp
					     (nth index inferiors)))
				      (bp2 (or (si:correspondence-interval-start-bp
						 (nth (1+ index) inferiors))
					       interval-end))
				      (bp3 (forward-over *blanks* bp1 bp2)))
				 ;; If there is something nonblank on the first line
				 ;; of this space, then it goes with the form preceding
				 ;; it rather than the form following it.
				 ;; This is only a heuristic, of course.
				 (unless (or (bp-= bp3 bp2)
					     (char-equal (bp-char bp3) #\Return))
				   (setf (aref spaces (1+ j)) index)
				   (setf (aref space-used-p index) t)
				   ;; Remember that the subform that followed this one in
				   ;; the old-form had a newline in front of it
				   (dotimes (j new-limit)
				     (let ((i (if (eql j new-tail)
						  old-tail
						  (aref sources j))))
				       (when (eql i (1+ index))
					 (setf (aref new-line-p j) t)))))))
			     ;; If we know where this subform came from, and there
			     ;; was a comment before it, try to keep the comment in
			     ;; the corresponding place.
			     (unless (or (zerop index)
					 (aref space-used-p (1- index))
					 (null (nth (1- index) inferiors))
					 (null (nth index inferiors)))
			       (let* ((bp1 (si:correspondence-interval-end-bp
					     (nth (1- index) inferiors)))
				      (bp2 (si:correspondence-interval-start-bp
					     (nth index inferiors)))
				      (bp3 (forward-over *blanks* bp1 bp2)))
				 ;; If this space starts with a carriage return, then
				 ;; it goes with the form following it rather than
				 ;; the form preceding it.
				 ;; This is only a heuristic, of course.
				 (unless (or (bp-= bp3 bp2)
					     (char-not-equal (bp-char bp3) #\Return)
					     ;; Don't put a newline after the function name
					     (and (= j 1)
						  (bp-= (forward-over *whitespace-chars*
								      bp3 bp2)
							bp2)))
				   (if (or (zerop j) (aref spaces j))
				       (setf (aref more-spaces j) (1- index))
				       (setf (aref spaces j) (1- index)))
				   (setf (aref space-used-p (1- index)) t)))))))
		       ;; Second pass: Assign remaining carriage returns
		       (dotimes (j (min new-limit (1- (length new-form))))
			 (let ((index (aref sources j)))
			   (when index
			     ;; If we know where this subform came from, and there was
			     ;; a carriage return after it that was not already
			     ;; assigned elsewhere, keep it after this subform.
			     ;; A non-blank space not containing a carriage return
			     ;; would have been assigned already.
			     ;; But don't put anything after the last subform.
			     (unless (or (aref spaces (1+ j))
					 (aref space-used-p index)
					 (null (nth index inferiors)))
			       (let* ((bp1 (si:correspondence-interval-end-bp
					     (nth index inferiors)))
				      (bp2 (or (si:correspondence-interval-start-bp
						 (nth (1+ index) inferiors))
					       interval-end))
				      (bp3 (forward-over *blanks* bp1 bp2)))
				 (unless (bp-= bp3 bp2)
				   (setf (aref spaces (1+ j)) index)
				   (setf (aref space-used-p index) t))))))))
		     
		     (output-pieces (new-limit old-limit)
		       (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")#+ignore0  ;; Turn this on if needed for debugging
		       (let ((cl:*print-array* t))
			 (format t "~2&output-pieces: sources ~S spaces ~S more-spaces ~S~@
				 new-line-p ~S space-used-p ~S new-limit ~S old-limit ~S~@
				 new-tail ~S old-tail ~S tail ~S~@
				 new-form ~S old-form ~S"
				 sources spaces more-spaces
				 new-line-p space-used-p new-limit old-limit
				 new-tail old-tail tail
				 new-form old-form))

		       ;; Output the changed portions of new-form
		       (do ((list new-form (cdr list))
			    (j 0 (1+ j)))
			   (( j new-limit)
			    ;; If a comment was assigned to follow the last changed
			    ;; subform, put it there, unless it's going to be put
			    ;; there as part of the common tail
			    (let ((space-index (aref spaces j)))
			      (when (and space-index
					 (< space-index (1- (or old-tail old-limit))))
				(output-interval
				  (si:correspondence-interval-end-bp
				    (nth space-index inferiors))
				  (or (si:correspondence-interval-start-bp
					(nth (1+ space-index) inferiors))
				      interval-end)))))
			 ;; Put some space before this subform
			 (when (plusp j)
			   (if (and tail (= (- (length new-form) j) (length old-form)))
			       ;; Just about to start a wrapped tail.  The space
			       ;; that would go here was already used preceding
			       ;; the wrapping form.
			       (output-newline)
			       ;; Prefer a space assigned by the earlier heuristics
			       (let ((space-index (aref spaces j)))
				 ;; Don't put space after a no-source item (e.g. xr-bq-list)
				 (when (or space-index
					   (null (aref sources (1- j)))
					   (not (null (nth (aref sources (1- j)) inferiors))))
				   ;; If no space assigned yet, take the next one from
				   ;; among those that didn't get specific locations
				   ;; This preserves comments in completely rewritten
				   ;; subforms, such as the slots list of defclass
				   (unless (or space-index (aref new-line-p j))
				     (do ((i 0 (1+ i))
					  (inf inferiors (cdr inf)))
					 (( i (or old-tail old-limit)))
				       (unless (or (aref space-used-p i)
						   (null (car inf))
						   (null (cdr inf)))
					 (setq space-index i)
					 (setf (aref space-used-p i) t)
					 (return))))
				   (cond (space-index
					  (let ((bp1 (si:correspondence-interval-end-bp
						       (nth space-index inferiors)))
						(bp2 (or (si:correspondence-interval-start-bp
							   (nth (1+ space-index) inferiors))
							 interval-end)))
					    (if (and (eq (bp-line bp1) (bp-line bp2))
						     (= (1+ (bp-index bp1)) (bp-index bp2))
						     (char-equal (bp-char bp1) #\space))
						;; If it was just one space, maybe we
						;; would prefer a newline instead
						(output-space-or-newline list new-form)
						(output-interval bp1 bp2))))
					 ((and (> j 1) (aref new-line-p j))
					  ;; If this form started on a new line (after
					  ;; a comment), start it on a new line again, but
					  ;; don't put a newline right after the function name
					  (output-newline))
					 (t
					  ;; If just couldn't find any space to use,
					  ;; put in a space or a newline
					  (output-space-or-newline list new-form)))))))
			 ;; If there were actually two spaces trying to go before this subform,
			 ;; because one is a comment that goes before it and the other is a
			 ;; comment that goes after its predecessor, put them both in.
			 (let ((space-index (aref more-spaces j)))
			   (when space-index
			     (let ((bp1 (si:correspondence-interval-end-bp
					  (nth space-index inferiors)))
				   (bp2 (or (si:correspondence-interval-start-bp
					      (nth (1+ space-index) inferiors))
					    interval-end)))
			       (when (aref spaces j)
				 ;; Join them seamlessly
				 (setq bp1 (forward-over *whitespace-chars* bp1)))
			       (output-interval bp1 bp2))))
			 ;; Output this subform, recursing as necessary
			 (let ((subform (car list)))
			   (let ((old-idx (aref sources j)))
			     (cond (old-idx
				    ;; We know where this subform came from
				    (let ((old-subform (nth old-idx old-form)))
				      (cond ((not (cl:equal old-subform subform))
					     ;; Only sort of matches.
					     (output-modified-form old-subform subform
								   (assq old-subform
									 correspondences)
								   (1+ depth) nil))
					    ((not (null (nth old-idx inferiors)))
					     ;; Really matches
					     (lexpr-funcall #'output-interval
							    (nth old-idx inferiors)))
					    (t
					     ;; Just xr-bq-list or something, no source
					     ))))
				   ((eql j new-tail)
				    ;; This subform includes a tail of old-form
				    (output-modified-form (nthcdr old-tail old-form)
							  subform entry (1+ depth)
							  old-tail))
				   (t
				    ;; This subform is totally new
				    (output-form subform))))))
		       ;; Spew out any nonblank spaces that haven't been used
		       ;; yet so we don't drop comments on the floor when the
		       ;; new form is shorter than the old form.
		       ;; Stop before the spaces that will be output below as
		       ;; the text for the common tail.
		       (loop for space-index from 0 below (1- (or old-tail old-limit)) do
			 (unless (aref space-used-p space-index)
			   (let ((bp1 (si:correspondence-interval-end-bp
					(nth space-index inferiors)))
				 (bp2 (or (si:correspondence-interval-start-bp
					    (nth (1+ space-index) inferiors))
					  interval-end)))
			     (unless (or (null bp1)
					 (bp-= (forward-over si:*whitespace* bp1 bp2) bp2))
			       (output-interval bp1 bp2)))))
		       ;; Output the text for the common tail of old-form & new-form
		       (if new-tail
			   ;; The recursive call will do it, so just close the list
			   (output-char (si:pttbl-close-paren readtable))
			   ;; Output everything from the space after the last
			   ;; subform that was handled to the closing parenthesis
			   (output-interval
			     (cond ((plusp old-limit)
				    (si:correspondence-interval-end-bp (nth (1- old-limit)
									    inferiors)))
				   ((and tail (plusp tail))
				    ;; Just about to start a wrapped unmodified tail.
				    ;; The space that would go here was already
				    ;; used preceding the wrapping form.  The last thing
				    ;; output was not an open parenthesis, since tail0.
				    (output-space-or-newline (nthcdr new-limit new-form)
							     new-form)
				    (si:correspondence-interval-start-bp (first inferiors)))
				   (t
				    (forward-char (si:correspondence-interval-start-bp
						    interval))))
			     (si:correspondence-interval-end-bp interval)))))

		;; First remove any residue left behind by these stupid displacing macros
		(do ((list new-form (cdr list)))
		    ((atom list))
		  (when (and (cl:consp (car list)) (eq (caar list) 'si:displaced))
		    (let ((original (second (car list))))
		      (setf (caar list) (car original))
		      (setf (cdar list) (cdr original)))))
		(do ((list old-form (cdr list)))
		    ((atom list))
		  (when (and (cl:consp (car list)) (eq (caar list) 'si:displaced))
		    (let ((original (second (car list))))
		      (setf (caar list) (car original))
		      (setf (cdar list) (cdr original)))))

		;; Now perform the first pass of matching up new and old subforms
		(do-named done
			  ((list new-form (cdr list))
			   (j 0 (1+ j)))
			  (())
		  ;; See whether we have reached a point where the rest of the
		  ;; list matches.  If so, we are done.
		  (do ((old-list old-form (cdr old-list))
		       (i 0 (1+ i)))
		      (())
		    (when (eq old-list list)
		      (assign-subforms j i)
		      (assign-comments j)
		      (output-pieces j i)
		      (return-from done t))
		    (when (atom old-list)
		      (return nil)))
		  ;; See where this piece of the list came from.
		  (block subform
		    (let ((subform (car list)))
		      ;; First see if this piece was copied without change.
		      (labels ((find-old-place (pred)
				 (do ((i 0 (1+ i))
				      (list old-form (cdr list))
				      (infs inferiors (cdr infs)))
				     ((null infs) nil)
				   (when (and (not (aref form-used-p i))
					      (funcall pred subform (car list))
					      (< (count-that-works subform old-form) 2))
				     (return i))))
			       (count-that-works (item list)
				 ;; cl:count gets an error if the list is dotted
				 (loop until (atom list)
				       count (eql (pop list) item))))
			(let ((index (or (find-old-place #'eql)
					 (find-old-place #'cl:equal))))
			  (when index
			    (setf (aref sources j) index)
			    (setf (aref form-used-p index) j)
			    (return-from subform))))
		      ;; Let the converter help out on really complicated changes
		      (let ((hint (cl:assoc subform hints)))
			(when hint
			  (loop for item in old-form for index from 0 do
			    (when (and (eql (second hint) item)
				       (not (aref form-used-p index)))
			      (setf (aref sources j) index)
			      (setf (aref form-used-p index) j)
			      (return-from subform)))))
		      (when (and (listp subform)
				 (> modification-depth depth))
			;; Check for some element of the old form having a common
			;; proper nthcdr with this element of the new form.
			;; This is how a comment on a typecase clause gets
			;; preserved, when the clause key probably changed.
			(let ((index (do-named found
					       ((i 0 (1+ i))
						(list old-form (cdr list))
						(infs inferiors (cdr infs)))
					       ((null infs) nil)
				       (unless (aref form-used-p i)
					 (do ((old-rest (car list) (cdr old-rest)))
					     ((atom old-rest) nil)
					   (do ((new-rest subform (cdr new-rest)))
					       ((atom new-rest))
					     (when (eq new-rest old-rest)
					       (return-from found i))))))))
			  (when index
			    (setf (aref sources j) index)
			    (setf (aref form-used-p index) j)
			    (return-from subform))))
		      ;; Check for the case where the last subform of new-form
		      ;; is something wrapped around a tail of old-subform.
		      ;; When this happens, the nesting depths of new-form and
		      ;; old-form don't match and the recursion in output-pieces
		      ;; has to be modified accordingly.
		      (when (and (null (cdr list)) (listp subform))
			(loop for i downfrom (1- (length old-form)) to 0
			      and k downfrom (1- (length subform)) to 0
			      until (aref form-used-p i)
			      as old = (nth i old-form)
			      as new = (nth k subform)
			      while (or (cl:equal old new)
					(eq (second (cl:assoc new hints)) old)
					(same-car-p old new))
			      finally
				(unless (= i (1- (length old-form)))
				  (setq old-tail (1+ i) new-tail j))))))))))))

       (output-modified-form old-form new-form entry 1 nil)))
    (copy-bp (si:correspondence-interval-start-bp (si:correspondence-entry-interval entry))
	     :moves)
    (copy-bp (si:correspondence-interval-end-bp (si:correspondence-entry-interval entry))
	     :normal)))))

(set-comtab *zmacs-comtab* nil
  (make-command-alist
    '(com-convert-lisp-syntax-of-region com-convert-lisp-syntax-of-buffer
      com-convert-lisp-syntax-of-tag-table
      com-convert-base-of-region com-convert-base-of-buffer com-convert-base-of-tag-table
      com-find-conflicting-symbols-in-buffer com-find-conflicting-symbols-in-tag-table
      com-convert-package-of-region com-convert-package-of-buffer
      com-convert-package-of-tag-table
      com-convert-functions-of-region com-convert-functions-of-buffer
      com-convert-functions-of-tag-table
      )))
