;;; -*- Mode: LISP; Syntax: Common-lisp; Package: CONVERSION-TOOLS; Base: 10; Lowercase:Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Conversion tool for Flavors to CLOS


;;--- Other issues to consider:
;;	:which-operations and friends might have a non-obvious conversion?
;;	I wish defflavor :constructor could be converted
;;	Should defflavor :required-flavors convert to ordinary direct superclasses?

;;; The value of *conversion-state* is a plist that associates with each
;;; symbol a plist with the following properties:
;;;   FLAVOR - list of three lists: names of direct component flavors
;;;				    names of direct instance variables
;;;				    names of direct defun-in-flavors
;;;   MESSAGE - name of generic function to replace this message
;;;   GENERIC - alist of ((function-spec arglist method-combination)...)

;;; defun-in-flavors are converted to methods with the same name
;;; defmacro-in-flavors are converted to ordinary macros with the same name
;;; Wrappers are not converted, they are just left in place

;;; Flavor options that can't be converted, or aren't converted yet,
;;; are turned into a bogus :unconverted-flavor-options defclass option
;;; Similarly, :unconverted-defgeneric-options for defgeneric

;;; At the same time, this also converts messages to generic functions
;;; We'll assume SEND is used rather than FUNCALL for sending messages

;;; Note that the program is assumed to have been converted from Zetalisp to
;;; (Symbolics) Common Lisp by the time we get here.  That really doesn't
;;; matter, except that we don't have to worry about handling ZL:SETF.

(define-conversion-set Flavors-to-CLOS nil
  define-Flavors-to-CLOS-conversion
  :pretty-name "Flavors to CLOS")

(define-Flavors-to-CLOS-conversion defflavor (&rest args)
  :modification-depth 3		;(defclass ... ((slot ... unchanged-form ...)...)...)
  :form (convert-flavor-to-clos args))

(defun convert-flavor-to-clos (args)
  (unless (symbolp (first args))
    (warn "Unable to parse (~S ~S ...)" 'defflavor (first args))
    (return-from convert-flavor-to-clos nil))
  (let* ((hints nil)
	 (tem nil)
	 (context `(defflavor ,@args))
	 (flavor (multiple-value-bind (info flavor)
		     ;; Parse the defflavor and remember its salient aspects for later
		     (set-direct-slots-and-functions-for-defflavor context)
		   (declare (ignore info))
		   flavor))
	 (superclasses (flavor::flavor-local-components flavor))
	 (conc-name (string-append (first args) "-"))
	 (init (flavor::flavor-local-instance-variable-initializations flavor))
	 (initable (flavor::flavor-local-initable-instance-variables flavor))
	 (readable (flavor::flavor-local-readable-instance-variables flavor))
	 (writable (flavor::flavor-local-writable-instance-variables flavor))
	 (locatable (flavor::flavor-local-locatable-instance-variables flavor))
	 (slots (loop for slot in (flavor::flavor-local-instance-variables flavor)
		      as initform = (assoc slot init)
		      as initargs = (loop for (initarg name) in initable
					  when (eq name slot)
					    collect initarg)
		      as readers = (delete-duplicates
				     (loop for (generic name) in readable
					   when (eq name slot)
					     collect (convert-to-CLOS-if-message
						       generic context nil conc-name))
				     :test #'equal)
		      as writers = (delete-duplicates
				     (loop for (generic name) in writable
					   when (eq name slot)
					     collect (convert-to-CLOS-if-message
						       generic context
						       'future-common-lisp:setf
						       conc-name))
				     :test #'equal)
		      as locators = (delete-duplicates
				      (loop for (generic name) in locatable
					     when (eq name slot)
					       collect (convert-to-CLOS-if-message
							 generic context 'locf conc-name))
				      :test #'equal)
		      as accessor = (and readers writers (not locators)
					 (or (equal (first writers) `(setf ,(first readers)))
					     (equal (first writers) `(future-common-lisp:setf
								       ,(first readers))))
					 (prog1 (pop readers) (pop writers)))
		      collect (if (or initform initargs readers writers locators accessor)
				  `(,slot ,@(when initform `(:initform ,(second initform)))
					  ,@(loop for initarg in initargs
						  append `(:initarg ,initarg))
					  ,@(loop for reader in readers
						  append `(:reader ,reader))
					  ,@(loop for writer in writers
						  append `(:writer ,writer))
					  ,@(loop for locator in locators
						  append `(:locator ,locator))
					  ,@(when accessor `(:accessor ,accessor)))
				  slot)))
	 (documentation (when (setq tem (find-if #'stringp
						 (flavor:flavor-documentation flavor)))
			  `(:documentation ,tem)))
	 (default-initargs (when (setq tem (flavor::flavor-default-init-plist flavor))
			     `(:default-initargs ,@tem))))
    ;; Create hints for items that end up out of order
    (push (list superclasses (third args)) hints)
    (push (list slots (second args)) hints)
    (when documentation
      (loop for option in (cdddr args) do
	(when (and (consp option)
		   (eq (car option) ':documentation))
	  (return (push (list documentation option) hints)))))
    (when default-initargs
      (loop for option in (cdddr args) do
	(when (and (consp option)
		   (eq (car option) ':default-init-plist))
	  (return (push (list default-initargs option) hints)))))
    ;; Compose the result
    (values
      `(clos:defclass ,(flavor:flavor-name flavor)
		 ,superclasses
	 ,slots
	 ;; Class options
	 ,@(when documentation (list documentation))
	 ,@(when default-initargs (list default-initargs))    
	 ;; Unconverted flavor options
	 ,@(when (setq tem (loop for clause in (cdddr args)
				 when (member (if (atom clause) clause (car clause))
					      '(:abstract-flavor :area-keyword
						:component-order :constructor
						:default-handler
						:included-flavors :init-keywords
						:method-combination :method-order
						:mixture :no-vanilla-flavor
						:ordered-instance-variables
						:required-flavors :required-init-keywords
						:required-instance-variables
						:required-methods
						:select-method-order
						:special-instance-variable-binding-methods
						:special-instance-variables))
				   collect clause))
	     (let ((option `(:unconverted-flavor-options ,@tem)))
	       (push (list option (first tem)) hints)
	       (list option))))
      hints)))

(defun get-slots-and-functions-for-flavor (flavor-name)
  (declare (values slot-names function-names))
  (multiple-value-bind (superclass-names slot-names function-names)
      (get-direct-slots-and-functions-for-flavor flavor-name)
    (dolist (superclass superclass-names)
      (multiple-value-bind (s f) (get-slots-and-functions-for-flavor superclass)
	(setq slot-names (union slot-names s)
	      function-names (union function-names f))))
    (values slot-names function-names)))

(defun get-direct-slots-and-functions-for-flavor (flavor-name)
  (declare (values superclass-names slot-names function-names))
  (let ((info (getf (getf *conversion-state* flavor-name) 'flavor))
	;; The CLIM package might not be defined when this is compiled or loaded
	(define-application-frame (and (find-package "CLIM")
				       (find-symbol "DEFINE-APPLICATION-FRAME" "CLIM"))))
    (cond (info
	   (values (first info) (second info) (third info)))
	  ((and (setq info (second (let ((sections (get flavor-name 'zwei:zmacs-buffers)))
				     (or (assoc 'defflavor sections)
					 (assoc 'clos:defclass sections)
					 (assoc 'dw:define-program-framework sections)
					 (and define-application-frame
					      (assoc define-application-frame sections))))))
		(let ((zwei:*interval* (zwei:interval-buffer info)))
		  (zwei:with-evaluation-context
		    (zwei:with-interval-stream (s info)
		      (let ((form (condition-case () (read s)
				     (sys:parse-error nil))))
			(cond ((atom form))
			      ((eq (first form) 'defflavor)
			       (setq info (set-direct-slots-and-functions-for-defflavor form)))
			      ((or (eq (first form) 'clos:defclass)
				   (and define-application-frame
					(eq (first form) define-application-frame)))
			       ;; This won't pick up the default superclass for
			       ;; clim:define-application-frame, but we don't care since
			       ;; we don't inherit any slots from it that matter
			       (setq info (list (third form)	;direct superclasses
						(loop for slot in (fourth form)	;direct slots
						      collect (if (atom slot) slot (car slot)))
						()))		;no local functions
			       (setf (getf (getf *conversion-state* flavor-name) 'flavor)
				     info))
			      ((eq (first form) 'dw:define-program-framework)
			       ;; This won't pick up the default superclass for
			       ;; dw:define-program-framework, but we don't care since
			       ;; we don't inherit any slots from it that matter
			       (let ((slots (getf (cddr form) :state-variables))
				     (superclasses (getf (cddr form) :inherit-from)))
				 (setq info (list superclasses
						(loop for slot in slots
						      collect (if (atom slot) slot (car slot)))
						()))		;no local functions
				 (setf (getf (getf *conversion-state* flavor-name) 'flavor)
				       info)))))))))
	   (values (first info) (second info) (third info)))
	  ((setq info (flavor:find-flavor flavor-name nil))
	   (values (append (flavor::flavor-local-components info)
			   (flavor::flavor-required-flavors info))
		   (flavor::flavor-local-instance-variables info)
		   (mapcar #'flavor:method-generic
			   (mapcar #'flavor::method-holder-function-spec
				   (flavor::flavor-local-functions info)))))
	  (t (warn "Unable to find a flavor definition for ~S" flavor-name)))))

(defun set-direct-slots-and-functions-for-defflavor (defflavor)
  (declare (values info flavor))
  (destructuring-bind-carefully (flavor-name instance-variables component-flavors . options)
				(cdr defflavor)
    (let ((fls (flavor::parse-defflavor flavor-name instance-variables component-flavors
					options nil)))
      (values
	(setf (getf (getf *conversion-state* flavor-name) 'flavor)
	      (list (append (flavor::flavor-local-components (first fls))
			    (flavor::flavor-required-flavors (first fls)))
		    (flavor::flavor-local-instance-variables (first fls))
		    (mapcar #'flavor:method-generic
			     (mapcar #'flavor::method-holder-function-spec
				     (flavor::flavor-local-functions (first fls))))))
	(first fls)))))

(defun add-function-for-flavor (flavor-name function-name)
  (multiple-value-bind (superclass-names slot-names function-names)
      (get-direct-slots-and-functions-for-flavor flavor-name)
    (unless (member function-name function-names)
      (setf (getf (getf *conversion-state* flavor-name) 'flavor)
	    (list superclass-names slot-names (cons function-name function-names))))))

;; Value is never NIL.
;; The setf-locf argument tells us to offer by default to turn :set-foo into (setf foo).
;; The value of the setf-locf argument is the particular setf symbol to use.
(defun convert-to-CLOS-if-message (generic-function context &optional setf-locf conc-name)
  (when (symbolp generic-function)
    (let ((gf (flavor:find-generic-function generic-function nil)))
      (when (or (if gf (flavor::generic-function-message-p gf) (keywordp generic-function))
		(get generic-function 'flavor::compatible-generic))
	(let ((generic (get-replacement-CLOS-generic-function generic-function context
							      setf-locf conc-name)))
	  (when generic
	    (setq generic-function generic))))))
  generic-function)

;; Value can be NIL if the user says not to change the message to a generic function.
;; The setf-locf argument tells us to offer by default to turn :set-foo into (setf foo).
;; The value of the setf-locf argument is the particular setf symbol to use.
;; It's too bad this interaction has to happen before showing the real context,
;; but it does.  Forge ahead and hope for the best.  Fortunately this only
;; happens once per message, not every time the message is used.
(defun get-replacement-clos-generic-function (message context &optional setf-locf conc-name)
  (or (get message 'flavor::compatible-generic)
      (let ((*query-io* *standard-output*)	;typeout window
	    (entry (getf (getf *conversion-state* message) 'message)))
	(unless entry
	  (format *query-io* "~2&The message ~S is used in context:~%  " message)
	  (write context :stream *query-io* :pretty t :level 2 :length 8)
	  (setq entry (list message
			    (accept '((token-or-type (("None" . nil))
					((and sys:function-spec
					      (satisfies good-clos-generic-function-name))
					 :description
					   "available as a CLOS generic function name"))
				      :description "None, a symbol, or (SETF symbol)")
				    :prompt (format nil "Generic function to replace ~
							message ~S with" message)
				    :default
				      (let ((default
					     (if (and setf-locf
						      (> (string-length message) 4)
						      (string-equal message setf-locf
								    :end1 3 :end2 3)
						      (string-equal message "-"
								    :start1 3 :end1 4))
						 `(,setf-locf ,(intern (string-append
									 (or conc-name "")
									 (substring message 4)
									 )))
						 (intern (if conc-name
							     (string-append conc-name message)
							     (symbol-name message))))))
					(cond ((good-clos-generic-function-name default))
					      ((atom default)
					       (setq default (intern (string-append default
								       "-METHOD"))))
					      (t
					       (setq default (list (first default)
								   (intern (string-append
									     (second default)
									     "-METHOD"))))))
					(and (good-clos-generic-function-name default)
					     default)))))
	  (send-if-handles *query-io* :make-complete)
	  (setf (getf (getf *conversion-state* message) 'message) entry))
	(second entry))))

(defvar *other-good-generic-function-names*
	'(future-common-lisp:pathname-host
	  future-common-lisp:pathname-device
	  future-common-lisp:pathname-directory
	  future-common-lisp:pathname-name
	  future-common-lisp:pathname-type
	  future-common-lisp:pathname-version))

(defun good-clos-generic-function-name (function-spec)
  (and (or (and (symbolp function-spec) (not (null function-spec)))
	   (and (consp function-spec)
		(member (car function-spec) '(setf future-common-lisp:setf locf))
		(consp (cdr function-spec)) (symbolp (cadr function-spec))
		(null (cddr function-spec))))
       (or (not (fdefinedp function-spec))
	   (typep (fdefinition function-spec)
		  '(or flavor:generic-function clos:generic-function))
	   (member function-spec *other-good-generic-function-names*))))

(defun get-generic-function-information (generic-function-name)
  (declare (values arglist method-combination))
  (let* ((key (if (listp generic-function-name) (second generic-function-name)
		  generic-function-name))
	 (info (assoc generic-function-name (getf (getf *conversion-state* key) 'generic)
		      :test #'equal)))
    (cond (info
	   (values (second info) (third info)))
	  ((and (setq info (second (assoc 'defun (si:function-spec-get generic-function-name
								       'zwei:zmacs-buffers))))
		(let ((zwei:*interval* (zwei:interval-buffer info)))
		  (zwei:with-evaluation-context
		    (zwei:with-interval-stream (s info)
		      (let ((form (condition-case () (read s)
				     (sys:parse-error nil))))
			(when (and (consp form)
				   (member (first form) '(defgeneric clos:defgeneric))
				   (consp (cdr form))
				   (equal (second form) generic-function-name))
			  (setq info (set-generic-function-information
				       generic-function-name (third form)
				       (loop for option in (cdddr form)
					     when (and (listp option)
						       (eq (car option) ':method-combination))
					       return (cdr option))))))))))
	   (values (second info) (third info)))
	  ((setq info (flavor:find-generic-function generic-function-name nil))
	   (values ;; arglist omits the receiver for messages, so use the primitive
	           ;; this may be a compressed arglist, but the args-info is the same
		   (sys:generic-function-arglist info)
		   (sys:generic-function-method-combination info)))
	  (t nil))))

(defun set-generic-function-information
       (generic-function-name arglist method-combination)
  (let* ((key (if (listp generic-function-name) (second generic-function-name)
		  generic-function-name))
	 (alist (getf (getf *conversion-state* key) 'generic))
	 (elem (assoc generic-function-name alist :test #'equal)))
    (cond (elem
	   (setf (second elem) arglist (third elem) method-combination))
	  (t
	   (push (setq elem (list generic-function-name arglist method-combination)) alist)
	   (setf (getf (getf *conversion-state* key) 'generic) alist)))
    elem))

(defvar *simple-method-combination-conversions*
	'((:sum +) (:and and) (:append append) (:list list)
	  (:max max) (:min min) (:nconc nconc) (:or or) (:progn progn)))

(defvar *complex-method-combination-conversions*
	'((:daemon clos:standard)))

;; Argument is normally a list, but a symbol is also permitted
;; Value is always a list
;; This of course only knows the standard built-in method combination types
;; It doesn't look like any of them need conversion
(defun convert-method-combination-to-clos (mc)
  (multiple-value-bind (name arguments)
      (if (listp mc) (values (car mc) (cdr mc))
	  (values mc nil))
    (when (and (eq name ':daemon)
	       (equal arguments '(:most-specific-first)))
      (setq arguments nil))
    (let ((new (second (or (assoc name *simple-method-combination-conversions*)
			   (assoc name *complex-method-combination-conversions*)))))
      (cons (or new name) arguments))))

(define-Flavors-to-CLOS-conversion defgeneric (function-spec arglist . options)
  :name convert-defgeneric-to-clos
  :modification-depth 1000	;can change anything in the body of a :method option
  :form (convert-generic-to-clos function-spec arglist options))

(define-Flavors-to-CLOS-conversion defgeneric (function-spec arglist . options)
  :name convert-defgeneric-to-clos-old-setf
  :documentation "Use the old SETF argument order, new-value last"
  :modification-depth 1000	;can change anything in the body of a :method option
  :form (convert-generic-to-clos function-spec arglist options t))

(defun convert-generic-to-clos (function-spec arglist options &optional use-old-setf)
  ;; Check for junk that we don't understand, e.g. from backquote
  (unless (and (or (symbolp function-spec)
		   (and (listp function-spec)
			(member (car function-spec) '(setf future-common-lisp:setf locf))
			(listp (cdr function-spec))
			(symbolp (cadr function-spec))
			(null (cddr function-spec))))
	       (listp arglist))
    (unless use-old-setf	;don't warn twice
      (warn "Unable to parse ~S" `(defgeneric ,function-spec ,arglist ,@options)))
    (return-from convert-generic-to-clos nil))
  ;; Some of the stuff we call might generate warnings
  (let ((compiler:default-warning-function function-spec)
	(compiler:default-warning-definition-type 'defun)
	(original-function-spec function-spec)
	(original-arglist arglist)
	(self (intern "SELF" *package*))
	(hints nil))
    ;; If it's a message, convert it to a generic function
    (setq function-spec (convert-to-CLOS-if-message function-spec
						    `(defgeneric ,function-spec ,arglist
						       ,@options)))
    ;; Check whether this conversion is applicable now that we know what the
    ;; generic function will be.
    (when use-old-setf
      ;; The second conversion is only applicable if it's a setf generic and
      ;; not already using future-common-lisp:setf
      (unless (and (listp function-spec) (eq (first function-spec) 'setf))
	(return-from convert-generic-to-clos nil)))
    ;; If not supposed to use old setf, upgrade
    (when (and (listp function-spec)
	       (eq (first function-spec) 'setf)
	       (not use-old-setf))
      (setq function-spec (list 'future-common-lisp:setf (second function-spec))))
    ;; If converting to new setf from a message or old setf, upgrade arglist
    ;; by moving the new-value parameter to the front
    (when (and (listp function-spec)
	       (eq (first function-spec) 'future-common-lisp:setf)
	       (or (atom original-function-spec)
		   (eq (first original-function-spec) 'setf)))
      (loop for item in arglist do
	(when (member item lambda-list-keywords)
	  (warn "Cannot convert arglist ~:S to new SETF because the~@
		last parameter is not a required parameter." arglist)
	  (return)))
      (setq arglist `(,(car (last arglist)) ,@(butlast arglist))))
    (push `(,arglist ,original-arglist) hints)
    ;; Translate the options
    (let ((unconverted-defgeneric-options nil)
	  (declarations nil)
	  (methods nil)
	  (method-arglist (lt:remove-arguments-from-lambda-list 1 original-arglist))
	  (method-combination nil))
      (setq options (loop for option in options
			  do (unless (listp option)
			       (let ((new-option (if (stringp option)
						     `(:documentation ,option)
						     `(,option))))
				 (push `(,new-option ,option) hints)
				 (setq option new-option)))
			  if (eq (car option) ':documentation)
			    collect option
			  else if (eq (car option) ':method-combination)
			    collect `(:method-combination
				       ,@(convert-method-combination-to-clos
					   (setq method-combination (cdr option))))
			  else do
			    (case (car option)
			      (:method (push (cdr option) methods))
			      (:method-arglist (setq method-arglist (cdr option)))
			      (:optimize (push `(optimize ,@(loop for quality in (cdr option)
								  collect
								    (if (atom quality)
									`(,quality 3)
									quality)))
					       declarations))
			      (declare (setq declarations (append declarations (cdr option))))
			      (otherwise (push option unconverted-defgeneric-options)))))
      (set-generic-function-information original-function-spec original-arglist
					method-combination)
      (set-generic-function-information function-spec original-arglist
					method-combination)
      (when declarations
	(push `(declare ,@declarations) options))
      (setq options (nconc options
			   (loop with setf = (and (listp function-spec)
						  (eq (first function-spec)
						      'future-common-lisp:setf))
				 for ((flavor . qualifiers) . body) in (reverse methods)
				 collect
				   (multiple-value-bind (arglist body)
				       (convert-method-body-to-clos flavor method-arglist body)
				     (setq arglist (if setf
						       `(,(car (last arglist))
							 (,self ,flavor)
							 ,@(butlast arglist))
						       `((,self ,flavor) ,@arglist)))
				     `(:method ,@qualifiers ,arglist ,@body)))))
      (when unconverted-defgeneric-options
	(setq unconverted-defgeneric-options (nreverse unconverted-defgeneric-options))
	(let ((option `(:unconverted-defgeneric-options ,@unconverted-defgeneric-options)))
	  (push (list option (first unconverted-defgeneric-options)) hints)
	  (setq options (nconc options (list option))))))
    ;; Return it in CLOS syntax
    (values `(clos:defgeneric ,function-spec ,arglist ,@options)
	    hints)))

;;; Alist from message/generic-function name to a conversion function for methods
;;; that receives and returns generic-function-name, arglist, qualifiers, body, and hints
;;; also receives the cddr of the alist element as arguments
;;; :unclaimed-message to no-applicable-method would be nice, but unfortunately CLOS's
;;; no-applicable-method is too weak, can't dispatch on anything but the generic function.
(defvar *flavors-to-clos-method-conversions*
	'((:init convert-init-method)
	  (make-instance convert-make-instance-method)
	  (:print-self convert-print-self-method)
	  (sys:print-self convert-print-self-method)
	  (:describe convert-generic-function-name clos:describe-object)
	  (:fasd-form convert-generic-function-name future-common-lisp:make-load-form)))

(define-Flavors-to-CLOS-conversion defmethod ((generic-function flavor . qualifiers) arglist
					      . body)
  :name convert-defmethod-to-clos
  :modification-depth 1000	;can change anything in the body
  :form (convert-method-to-clos 'defmethod generic-function flavor qualifiers arglist body))

(define-Flavors-to-CLOS-conversion defmethod ((generic-function flavor . qualifiers) arglist
					      . body)
  :name convert-defmethod-to-clos-old-setf
  :documentation "Use the old SETF argument order, new-value last"
  :modification-depth 1000	;can change anything in the body
  :form (convert-method-to-clos 'defmethod generic-function flavor qualifiers arglist body t))

(define-Flavors-to-CLOS-conversion defwhopper ((generic-function flavor) arglist
					      . body)
  :name convert-defwhopper-to-clos
  :modification-depth 1000	;can change anything in the body
  :form (convert-method-to-clos 'defwhopper generic-function flavor nil arglist body))

(define-Flavors-to-CLOS-conversion defwhopper ((generic-function flavor) arglist
					      . body)
  :name convert-defwhopper-to-clos-old-setf
  :documentation "Use the old SETF argument order, new-value last"
  :modification-depth 1000	;can change anything in the body
  :form (convert-method-to-clos 'defwhopper generic-function flavor nil arglist body t))

;;; defwhopper-subst just turns into defwhopper and then into an around method
;;; No attempt to make it compile inline
(define-Flavors-to-CLOS-conversion defwhopper-subst ((generic-function flavor) arglist
						     . body)
  :name convert-defwhopper-subst-to-clos
  :modification-depth 1000	;can change anything in the body
  :form (convert-method-to-clos 'defwhopper-subst generic-function flavor nil arglist body))

(define-Flavors-to-CLOS-conversion defwhopper-subst ((generic-function flavor) arglist
						     . body)
  :name convert-defwhopper-subst-to-clos-old-setf
  :documentation "Use the old SETF argument order, new-value last"
  :modification-depth 1000	;can change anything in the body
  :form (convert-method-to-clos 'defwhopper-subst generic-function flavor nil arglist body t))

(defun convert-method-to-clos (operator generic-function flavor qualifiers arglist body
			       &optional use-old-setf)
  ;; Check for junk that we don't understand, e.g. from backquote
  (unless (and (or (symbolp generic-function)
		   (and (listp generic-function)
			(member (car generic-function) '(setf future-common-lisp:setf locf))
			(listp (cdr generic-function))
			(symbolp (cadr generic-function))
			(null (cddr generic-function))))
	       (symbolp flavor)
	       (listp qualifiers)
	       (null (cdr (last qualifiers)))
	       (every #'atom qualifiers))
    (unless use-old-setf	;don't warn twice
      (warn "Unable to parse (~S ~S ...)" operator `(,generic-function ,flavor ,@qualifiers)))
    (return-from convert-method-to-clos nil))
  ;; If it's already in CLOS syntax, do nothing.  The setf case is the only
  ;; case not already filtered out by destructuring-bind-carefully.
  (when (and (member generic-function '(setf future-common-lisp:setf locf))
	     (null qualifiers))
    (return-from convert-method-to-clos nil))
  ;; Some of the stuff we call might generate warnings
  (let ((compiler:default-warning-function `(,(ecase operator
						((defun-in-flavor defsubst-in-flavor)
						 'defun-in-flavor)
						(defmethod 'flavor:method)
						(defwhopper 'flavor:ncwhopper)
						(defwhopper-subst 'flavor:wrapper))
					     ,generic-function ,flavor . ,qualifiers))
	(compiler:default-warning-definition-type 'defun)
	(original-generic-function generic-function)
	(original-arglist arglist)
	(convert-method (assoc generic-function *flavors-to-clos-method-conversions*))
	(self (intern "SELF" *package*))
	hints)
    ;; Find out what we know about the original generic function
    (multiple-value-bind (generic-arglist method-combination)
	(get-generic-function-information generic-function)
      ;; If it's a message, convert it to a generic function
      (unless convert-method
	(setq generic-function (convert-to-CLOS-if-message generic-function
				 `(,operator (,generic-function ,flavor . ,qualifiers) ,arglist
				   . ,body))))
      ;; Check whether this conversion is applicable now that we know what the
      ;; generic function will be.
      (when use-old-setf
	;; The second conversion is only applicable if it's a setf method and
	;; not already using future-common-lisp:setf
	(unless (and (listp generic-function) (eq (first generic-function) 'setf))
	  (return-from convert-method-to-clos nil)))
      ;; If not supposed to use old setf, upgrade
      (when (and (listp generic-function)
		 (eq (first generic-function) 'setf)
		 (not use-old-setf))
	(setq generic-function (list 'future-common-lisp:setf (second generic-function))))
      (multiple-value-setq (arglist body hints)
	(convert-method-body-to-clos flavor arglist body))
      ;; Change whoppers to around methods
      (when (member operator '(defwhopper defwhopper-subst))
	(setq qualifiers '(:around)))
      ;; Perform any specific conversion
      (when convert-method
	(multiple-value-setq (generic-function arglist qualifiers body hints)
	  (apply (second convert-method) generic-function arglist qualifiers body hints
					 (cddr convert-method))))
      ;; Remove &allow-other-keys since the arglist congruency rules are different
      (setq arglist (remove '&allow-other-keys arglist))
      ;; In CLOS there is no implicit self argument, so make it explicit
      (setq arglist `((,self ,flavor) ,@arglist))
      ;; CLOS has more stringent rules for arglist congruency than Flavors
      ;; We can't fix this in general, since pretty serious rewriting of method
      ;; bodies would be required, for example for a whopper with an arglist of &rest args
      ;; that in CLOS should use the correct arglist, ignore the parameters, and
      ;; call call-next-method with no arguments.  However, we can do the easiest case.
      (let ((tail (member '&rest arglist)))
	(when (and tail generic-arglist (string= (second tail) 'ignore)
		   (not (member '&key arglist)))
	  (let ((info (sys:args-info-from-lambda-list generic-arglist)))
	    (unless (ldb-test sys:%%arg-desc-rest-arg info)
	      ;; Method takes a rest argument, but generic function does not
	      ;; Remove the rest argument, put in some optional ignores if necessary
	      (let* ((head (ldiff arglist tail))
		     (n (- (ldb sys:%%arg-desc-max-args info)
			   (ldb sys:%%arg-desc-max-args
				(sys:args-info-from-lambda-list head)))))
		(when (> n 0)
		  (setq head (append head
				     (unless (member '&optional head) '(&optional))
				     (loop repeat n collect (intern "IGNORE" *package*)))))
		(unless (minusp n)
		  (setq arglist (append head (cddr tail)))))))))
      ;; If converting to new setf from a message or old setf, upgrade arglist
      ;; by moving the new-value parameter to the front
      (when (and (listp generic-function)
		 (eq (first generic-function) 'future-common-lisp:setf)
		 (or (atom original-generic-function)
		     (eq (first original-generic-function) 'setf)))
	(loop for list on arglist
	      until (or (null (cdr list)) (eq (cadr list) '&aux))
	      do (when (member (car list) lambda-list-keywords)
		   (warn "Cannot convert arglist ~:S to new SETF because the~@
			  last parameter is not a required parameter." arglist)
		   (return))
	      finally
		(setq arglist `(,(car list) ,@(ldiff arglist list) ,@(cdr list)))))
      ;; Simple method combination uses a different qualifier naming convention.
      ;; We don't know what the user might have defined, so just convert the
      ;; intersection of the Flavors and CLOS built-in method combination types,
      ;; and furthermore guess that if a qualifier that could be used with a
      ;; method combination type is used, that type must be in use.
      (when (and (not method-combination)
		 qualifiers (null (cdr qualifiers))
		 (member (first qualifiers) *simple-method-combination-conversions*
			 :key #'first))
	(setq method-combination qualifiers))
      (let ((mc (car (convert-method-combination-to-clos method-combination))))
	(when (and (or (null qualifiers)
		       (and (null (cdr qualifiers))
			    (eq (first qualifiers) (first method-combination))))
		   (member mc *simple-method-combination-conversions* :key #'second))
	  (setq qualifiers (list mc))))
      ;; Return it in CLOS syntax
      (values `(clos:defmethod ,generic-function ,@qualifiers ,arglist
		 ,@body)
	      ;; Hints
	      `((,arglist ,original-arglist) ,@hints)))))

(defun convert-method-body-to-clos (flavor arglist body)
  (declare (values arglist body hints))
  (let ((self (intern "SELF" *package*))
	(hints nil)
	(bound-variables nil))
    ;; Change the body into a form so we can deal with it more easily
    (multiple-value-bind (declarations body)
	(si:find-body-declarations body nil arglist)
      (setq body `(progn ,@body))
      (multiple-value-bind (slot-names function-names)
	  (get-slots-and-functions-for-flavor flavor)
	;; Throw in any necessary with-slots, add self as an argument to any calls to
	;; defun-in-flavor functions, and change continue-whopper to call-next-method,
	;; and change from scl:self to self in the current package.
	;; This doesn't bother figuring out the case where continue-whopper is just
	;; passing the unmodified original arguments, so call-next-method could be called
	;; with no arguments.  I would hope that the compiled code is the same either way.
	(labels ((convert (form)
		   (let* ((slots-used nil)
			  (new (lt:copyforms
				 (lambda (subform kind usage)
				   (declare (ignore usage))
				   (when (and (member kind 'lt:(symeval set))
					      (member subform slot-names)
					      (not (member subform
							   lt:*mapforms-bound-variables*))
					      (not (member subform slots-used)))
				     (push subform slots-used))
				   (cond ((and (eq subform 'scl:self)
					       (member kind 'lt:(symeval set let)))
					  (values self t))
					 ((not (and (listp kind) (listp subform)))
					  subform)	;not a function call
					 ((and (member (first subform) function-names)
					       ;; If the self is already there, assume this
					       ;; has been already converted.  Otherwise
					       ;; we get into an infinite recursion.  There is
					       ;; a case where this can go wrong, of course.
					       (neq (second subform) self))
					  `(,(first subform) ,self ,@(rest subform)))
					 ((and (eq (first subform) 'function)
					       (member (second subform) function-names))
					  (values `#'(lambda (&rest args)
						       (apply #',(second subform) ,self args))
						  t))
					 ((eq (first subform) 'continue-whopper)
					  `(clos:call-next-method ,self ,@(rest subform)))
					 ((eq (first subform) 'lexpr-continue-whopper)
					  `(apply #'clos:call-next-method ,self
						  ,@(rest subform)))
					 (t subform)))
				 form :bound-variables bound-variables
				      :back-translate-macros t)))
		     ;; Record hints for the changes we just made, so that if this
		     ;; body gets wrapped in with-slots it can be figured out
		     (unless (eq new form)
		       (when (consp form)
			 (if (eq (first form) 'progn)
			     (loop for x in (rest new) and y in (rest form) do
			       (unless (eq x y)
				 (push (list x y) hints)))
			     (push (list new form) hints))))
		     (setq form new)
		     (if slots-used
			 `(clos:with-slots ,(nreverse slots-used)	;in order of appearance
					   ,self
			    ,@(if (and (consp form) (eq (first form) 'progn)) (rest form)
				  (list form)))
			 form))))
	  (setq arglist (copy-list arglist))
	  (lt:map-over-lambda-list arglist
				   (lambda (cons type)
				     (when (and (listp (car cons))
						(listp (cdar cons))
						(member type '(:optional :key :aux)))
				       ;; Convert this argument's default-value form
				       (let* ((old-form (cadar cons))
					      (new-form (convert old-form)))
					 (unless (eq new-form old-form)
					   (setf (car cons) `(,(caar cons) ,new-form
							      . ,(cddar cons))))))
				     (unless (member type '(:dotted-tail :&-key))
				       (let ((parameter (car cons)))
					 (cond ((atom parameter)
						(push parameter bound-variables))
					       (t
						(push (if (atom (car parameter))
							  (car parameter)	;optional
							  (cadar parameter))	;keyword
						      bound-variables)
						(when (cddr parameter)
						  (push (caddr parameter)	;supplied-p
							bound-variables))))))))
	  (setq body (convert body))
	  ;; Convert the body back into a body
	  (setq body `(,@declarations
		       ,@(if (and (consp body) (eq (first body) 'progn)) (rest body)
			     (list body))))
	  (values arglist body hints))))))

;;; Converters for methods for specific generic functions

(defun convert-init-method (generic-function arglist qualifiers body hints)
  (declare (values generic-function arglist qualifiers body hints))
  ;; We'd like to translate :INIT methods to clos:initialize-instance methods, but the
  ;; problem is that we don't know whether the method body will use CAR or CDR
  ;; to get from the :INIT argument to the initialize-instance &rest argument.
  ;; Let's handle just some easy cases.
  (when (or (= (length arglist) 1)
	    (eql (position '&aux arglist) 1))
    (block too-hard
      (let ((init-plist (first arglist))
	    (referenced nil))
	(when (member (first arglist) lambda-list-keywords)
	  (return-from too-hard))
	(dolist (aux (cdr (member '&aux arglist)))
	  (when (consp aux)
	    (lt:mapforms (lambda (subform ignore ignore ignore)
			   (when (eq subform init-plist)
			     (return-from too-hard)))
			 (second aux))))
	(lt:mapforms (lambda (subform kind ignore ignore)
		       (cond ((member init-plist lt:*mapforms-bound-variables*))
			     ((and (eq subform init-plist)
				   (member kind 'lt:(set symeval)))
			      (return-from too-hard))
			     ((not (and (listp subform) (listp kind))))
			     ((and (member (first subform) '(car cdr zl:get))
				   (eq (second subform) init-plist))
			      (setq referenced t)
			      (values t t))))
		     `(progn ,@body)
		     :bound-variables nil)
	;; Okay, it's an easy case, init-plist is unreferenced or used in easy ways
	(setq generic-function 'clos:initialize-instance)
	(unless qualifiers
	  (setq qualifiers '(:after)))
	(cond (referenced
	       (setq arglist `(&rest ,init-plist ,@(rest arglist)))
	       (setq body (lt:copyforms (lambda (subform kind ignore)
					  (cond ((member init-plist
							 lt:*mapforms-bound-variables*)
						 subform)
						((not (and (listp subform) (listp kind)))
						 subform)
						((and (member (first subform) '(car cdr))
						      (eq (second subform) init-plist))
						 init-plist)
						((and (eq (first subform) 'zl:get)
						      (eq (second subform) init-plist))
						 `(cl:getf ,@(rest subform)))
						(t subform)))
					`(progn ,@body)
					:bound-variables nil :back-translate-macros t))
	       (setq body (if (and (consp body) (eq (first body) 'progn)) (rest body)
			      (list body))))
	      (t
	       (setq arglist `(&key ,@(rest arglist))))))))
  (values generic-function arglist qualifiers body hints))

;; Flavors MAKE-INSTANCE does not translate into CLOS MAKE-INSTANCE
(defun convert-make-instance-method (generic-function arglist qualifiers body hints)
  (declare (values generic-function arglist qualifiers body hints))
  (declare (ignore generic-function))
  (values 'clos:initialize-instance arglist (or qualifiers '(:after)) body hints))

;; Flavors arguments are object stream print-depth slashify-p
;; CLOS arguments are object stream
(defun convert-print-self-method (generic-function arglist qualifiers body hints)
  (declare (values generic-function arglist qualifiers body hints))
  (declare (ignore generic-function))
  (let* ((tail (cdr (member '&aux arglist)))
	 (stream (first arglist))
	 (print-depth (second arglist))
	 (slashify-p (third arglist)))
    (values 'clos:print-object
	    `(,stream &aux (,print-depth 0) (,slashify-p *print-escape*) ,@tail)
	    qualifiers
	    body
	    hints)))

(defun convert-generic-function-name (generic-function arglist qualifiers body hints
				      new-generic)
  (declare (values generic-function arglist qualifiers body hints))
  (declare (ignore generic-function))
  (values new-generic arglist qualifiers body hints))

(define-Flavors-to-CLOS-conversion defun-in-flavor ((function flavor) arglist . body)
  :modification-depth 1000	;can change anything in the body
  :form
    (progn
      (add-function-for-flavor flavor function)
      (convert-method-to-clos 'defun-in-flavor function flavor nil arglist body)))

;; Sorry, the inline proclamation just gets lost
(define-Flavors-to-CLOS-conversion defsubst-in-flavor ((function flavor) arglist . body)
  :modification-depth 1000	;can change anything in the body
  :form
    (progn
      (add-function-for-flavor flavor function)
      (convert-method-to-clos 'defsubst-in-flavor function flavor nil arglist body)))

(define-Flavors-to-CLOS-conversion defmacro-in-flavor ((function flavor) arglist . body)
  :form
    (progn (ignore flavor)
	   `(defmacro ,function ,arglist . ,body)))

(define-Flavors-to-CLOS-conversion send (object message &rest args)
  (when (or (keywordp message)
	    (and (consp message)
		 (eq (first message) 'quote)
		 (= (length message) 2)
		 (symbolp (setq message (second message)))))
    (let ((generic (get-replacement-CLOS-generic-function message
							  `(send ,object ,message ,@args))))
      (when generic
	(cond ((atom generic)
	       `(,generic ,object ,@args))
	      ((eq (first generic) 'locf)
	       `(,(first generic) (,(second generic) ,object ,@args)))
	      (t
	       `(,(intern "SETF" *package*)
		   (,(second generic) ,object ,@(butlast args))
		   ,@(last args))))))))

(define-Flavors-to-CLOS-conversion lexpr-send (object message &rest args)
  (when (and (cdr args)
	     (or (keywordp message)
		 (and (consp message)
		      (eq (first message) 'quote)
		      (= (length message) 2)
		      (symbolp (setq message (second message))))))
    (let ((generic (get-replacement-CLOS-generic-function message
							  `(lexpr-send ,object ,message
								       ,@args))))
      (when generic
	(cond ((atom generic)
	       `(apply #',generic ,object ,@args))
	      ((eq (first generic) 'locf)
	       `(locf (apply #',(second generic) ,object ,@args)))
	      (t
	       ;; This is only right for future-common-lisp:setf, but there is nothing
	       ;; better to do for cl:setf so just leave it
	       `(,(intern "SETF" *package*)
		    (apply #',(second generic) ,object ,@(rest args))
		    ,(first args))))))))

(define-Flavors-to-CLOS-conversion boundp-in-instance (instance slot-name)
  `(clos:slot-boundp ,instance ,slot-name))

(define-Flavors-to-CLOS-conversion change-instance-flavor (instance class-name)
  `(clos:change-class ,instance ,class-name))

(define-Flavors-to-CLOS-conversion define-simple-method-combination
				   (name operator &optional single-arg-is-value pretty-name)
  :form
    (progn
      (ignore pretty-name)	;no CLOS equivalent, not too important so just discard it
      `(clos:define-method-combination ,name :operator ,operator
				       :identity-with-one-argument ,single-arg-is-value)))
				   
(define-Flavors-to-CLOS-conversion make-instance (class-name &rest initargs)
  `(clos:make-instance ,class-name ,@initargs))

;;; Only if no-error-p is not specified
(define-Flavors-to-CLOS-conversion symbol-value-in-instance (instance slot-name)
  `(clos:slot-value ,instance ,slot-name))
