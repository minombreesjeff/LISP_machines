;;; -*- Mode: LISP; Syntax: Common-LISP; Package: Graphic-input; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Additional substrate for input of graphical objects.  An extension to graphics,
;;; so in its own package.  Also, useful stuff associated with such input, like grid
;;; maintenance.

;;;; Mouse input of shapes

;;; Functions that take arguments named window (never defaulted) deal in window coordinates.
;;; Functions that take arguments named stream (almost always defaulted to *standard-output*),
;;;  deal in stream coordinates, including both encapsulation offset and graphics transform.
;;; When both are arguments, the stream is usually called original-stream.
;;; All this effort is to be able to rubber band the lines without resorting to
;;; transforming while tracking.  Points are transformed when they come in and then
;;; back out again.

(defmacro with-special-mouse-blinker-macros ((window blinker string-p
					      quantize-position quantization-function)
					     (quantize-position-macro set-string-macro)
					     &body body)
  `(macrolet ((,quantize-position-macro (x y &optional (stream ',window)
						       (x-offset '0) (y-offset '0)
						       (transform nil)
						       (quantize-position ',quantize-position))
	       `(multiple-value-setq (,x ,y)
		  (quantize-position-internal ,quantize-position ,',quantization-function
					      ,',blinker ,x ,y ,stream ,x-offset ,y-offset
					      ,transform)))
	      (,set-string-macro ((&optional (stream '*standard-output*))
				  &body body)
	       `(when ,',string-p
		  (sys:with-stack-array (.string. 10 :element-type 'string-char
						     :fill-pointer 0)
		    (with-output-to-string (,stream .string.)
		      . ,body)
		    (send ,',blinker :set-string .string.)))))
     . ,body))

(defmacro with-special-mouse-blinker* ((window &rest lexpr-options)
				      (quantize-position-macro set-string-macro)
				      &body body)
  `(let (.old-blinker-type.)
     (unwind-protect
	 (let (.blinker. .string-p. .quantize-position. .quantization-function.)
	   (multiple-value-setq (.old-blinker-type. .blinker.
				 .string-p. .quantize-position. .quantization-function.)
	     (call-with-mouse-blinker-options #'with-special-mouse-blinker-internal
					      ,window . ,lexpr-options))
	   (with-special-mouse-blinker-macros (,window .blinker. .string-p.
					       .quantize-position. .quantization-function.)
					      (,quantize-position-macro ,set-string-macro)
	     . ,body))
       (when .old-blinker-type.
	 (set-window-mouse-blinker-type ,window .old-blinker-type.)))))

(defmacro with-special-mouse-blinker ((window &rest options)
				      (quantize-position-macro set-string-macro)
				      &body body)
  (declare (arglist (window &key show-position
				 quantize-position position-quantum quantization-function)
		    (quantize-position-macro set-string-macro)
		    &body body))
  `(let (.old-blinker-type.)
     (unwind-protect
	 (let (.blinker. .string-p. .quantization-function.)
	   (multiple-value-setq (.old-blinker-type. .blinker.
				 .string-p. .quantize-position. .quantization-function.)
	     (with-special-mouse-blinker-internal ,window . ,options))
	   (with-special-mouse-blinker-macros (,window .blinker. .string-p.
					       .quantize-position. .quantization-function.)
					      (,quantize-position-macro ,set-string-macro)
	     . ,body))
       (when .old-blinker-type.
	 (set-window-mouse-blinker-type ,window .old-blinker-type.)))))

;;; Simple use of :allow-other-keys t passes on things like :while-held too often.
(defparameter *mouse-blinker-option-keywords*
	      '(:show-position :position-transform :quantize-position
		:position-quantum :quantization-function))

(defun call-with-mouse-blinker-options (function &rest lexpr-args)
  (let ((nargs (+ (1- (length lexpr-args))
		  (* (loop for (keyword value) on (first (last lexpr-args)) by 'cddr
			   count (member keyword *mouse-blinker-option-keywords*))
		     2))))
    (sys:%start-function-call function return nargs nil)
    (loop while (cdr lexpr-args) do (sys:%push (pop lexpr-args)))
    (setq lexpr-args (car lexpr-args))
    (loop while lexpr-args
	  when (member (first lexpr-args) *mouse-blinker-option-keywords*)
	    do (sys:%push (first lexpr-args)) (sys:%push (second lexpr-args))
	  do (setq lexpr-args (cddr lexpr-args)))
    (sys:%finish-function-call function return nargs nil)))

(defun with-special-mouse-blinker-internal (window &key show-position quantize-position
							position-quantum position-transform
							quantization-function)
  (declare (values old-blinker-type blinker string-p quantize-position quantization-function)
	   (ignore position-transform))
  (when (and quantize-position (null quantization-function) position-quantum)
    (setq quantization-function (lambda (x y)
				  (macrolet ((round-to (n)
					       `(* position-quantum
						   (round ,n position-quantum))))
				    (values (round-to x) (round-to y))))))
  (multiple-value-bind (old-blinker-type blinker)
      (set-window-special-mouse-blinker window :show-position show-position
					       :quantize-position quantize-position
					       :always-set nil)
    (values old-blinker-type blinker
	    show-position quantize-position quantization-function)))

;;; Non-lexical version of above.
(defun set-window-special-mouse-blinker (window &key show-position quantize-position
						     (always-set t))
  (declare (values old-blinker-type blinker))
  (let ((new-type nil))
    (cond (show-position
	   (setq new-type (if quantize-position
			      '(:character-and-string-and-other-character :set-string "")
			      '(:character-and-string :set-string ""))))
	  (quantize-position
	   (setq new-type :character-and-other-character))
	  (always-set
	   (setq new-type dw:*default-mouse-blinker-type*)))
    (when new-type
      (set-window-mouse-blinker-type window new-type))))

(defun set-window-mouse-blinker-type (window new-type)
  (declare (values old-blinker-type blinker))
  (let ((old-type (send window :mouse-blinker-type))
	(blinker nil))
    (send window :set-mouse-blinker-type new-type)
    (without-interrupts
      (let ((mouse (tv:sheet-mouse window)))
	(cond ((send window :still-the-mouse-window)
	       (tv:mouse-standard-blinker window)
	       (setq blinker (tv:mouse-blinker mouse)))
	      (t
	       (setq blinker (tv:mouse-get-blinker (if (consp new-type)
						       (first new-type)
						       new-type)
						   nil mouse))))))
    (values old-type blinker)))

(defun default-show-position-function (stream x y)
  (flet ((show-num (n)
	   (if (integerp n)
	       (prin1 n stream)
	       (let ((n1 (round (* n 100))))
		 (multiple-value-bind (m d)
		     (floor n1 100)
		   (if (zerop d)
		       (prin1 m stream)
		       (format stream "~D.~2,'0D" m d)))))))
    (show-num x)
    (write-char #\, stream)
    (show-num y)))

(defmacro do-show-new-position ((show-new-position x y
				 &optional (show-position-function
					     '#'default-show-position-function))
				(stream x-offset y-offset transform))
  `(,show-new-position (string-stream)
     (multiple-value-bind (stream-x stream-y)
	 ,(if transform
	      `(progn
		 (ignore ,stream)
		 (graphics:untransform-point (- ,x ,x-offset) (- ,y ,y-offset) ,transform))
	      `(graphics:stream-untransform-point (- ,x ,x-offset) (- ,y ,y-offset) ,stream))
       (funcall ,show-position-function string-stream stream-x stream-y))))

(defun quantize-position-internal (quantize-position quantization-function blinker
				   x y stream x-offset y-offset transform)
  (when quantize-position
    ;; Convert to stream coordinate system
    #||
    (unless transform
      (setq transform (graphics:stream-transform stream)))
    ||#
    (multiple-value-bind (new-x new-y)
	(multiple-value-bind (stream-x stream-y)
	    (graphics:untransform-point (- x x-offset) (- y y-offset) transform)
	  ;; Quantize with user function
	  (if (eq quantize-position :force-grid)
	      (funcall quantization-function stream-x stream-y t)
	      (funcall quantization-function stream-x stream-y)))
      ;; And convert back to window coordinates
      (multiple-value-setq (new-x new-y)
	(graphics:transform-point new-x new-y transform))
      (setq new-x (+ (round new-x) x-offset)
	    new-y (+ (round new-y) y-offset))    
      (when blinker
	(send blinker :set-other-character-offsets (+ 2 (- new-x x)) (+ 1 (- new-y y))))
      (setq x new-x y new-y)))
  (send stream :update-margin-component-mouse-position-display x y)
  (values x y))

;;; Non-lexical version of above.
(defun update-window-mouse-blinker (window &key show-position quantize-position
						position-quantum quantization-function
						(show-position-function
						  #'default-show-position-function)
						(transform
						  (graphics:stream-transform window)))
  (without-interrupts
    (when (and (or show-position quantize-position
		   (send window :mouse-position-margin-components))
	       ;;(send window :still-the-mouse-window)
	       ;;Don't want the typeout window to impersonate us.
	       (eq window (tv:mouse-window (tv:sheet-mouse window)))
	       (not (send window :mouse-motion-pending))
	       (null (send window :mouse-margin-component)))
      (multiple-value-bind (x y)
	  (send window :mouse-position)
	(let* ((mouse (tv:sheet-mouse window))
	       (blinker (tv:mouse-blinker mouse))
	       (blinker-type (let ((type (send window :mouse-blinker-type)))
			       (if (consp type) (first type) type))))
	  ;; Avoid timing problem where proper blinker hasn't been installed yet, because
	  ;; mouse left window and just reentered, e.g.
	  (when (eq blinker (tv:mouse-get-blinker blinker-type nil mouse))
	    (let ((string-p
		    (and show-position
			 (member blinker-type '(:character-and-string-and-other-character
						 :character-and-string))))
		  (quantization-function
		    (and quantize-position
			 (member blinker-type
				 '(:character-and-string-and-other-character
				    :character-and-other-character))
			 (or quantization-function
			     (and position-quantum
				  (lambda (x y)
				    (declare (sys:downward-function))
				    (macrolet
				      ((round-to (n)
					 `(* position-quantum
					     (round ,n
						    position-quantum))))
				      (values (round-to x)
					      (round-to y)))))))))
	      (with-special-mouse-blinker-macros
		  (window blinker string-p quantize-position quantization-function)
		  (quantize-position show-new-position)
		(quantize-position x y window 0 0 transform)
		(when (or show-position quantize-position)
		  (do-show-new-position
		    (show-new-position x y show-position-function)
		    (window 0 0 transform)))))))))))

(defun drag-presentations-with-mouse (presentations &rest args
						    &key (stream *standard-output*)
							 (erase-first t)
						    &allow-other-keys)
  (declare (arglist presentations &key (stream *standard-output*) (erase-first t)
				       start-x start-y
				       (while-held (not (null start-x)))
				       (warp-mouse (null start-x))
				       (show-position nil)
				       (position-transform
					 (graphics:stream-transform stream))
				       (quantize-position nil)
				       (position-quantum nil) (quantization-function nil))
	   (values dx dy))
  (let ((box (presentations-displayed-box presentations)))
    (unwind-protect-case ()
	(si:with-rem-keywords (some-args args '(:stream :erase-first))
	  (apply #'dragging-output-with-mouse-internal
		 (lambda (window)
		   (dolist (presentation presentations)
		     (dw:redraw-displayed-presentation presentation window box)))
		 stream :box box
		 :erase-first-function
		  (when erase-first
		    (lambda (stream)
		      (declare (sys:downward-function))
		      (erase-presentations presentations
					   :stream stream
					   :redisplay-overlapping-presentations
					    (neq erase-first :partially-erase))))
		 some-args))
      (:abort
	(when erase-first
	  (unerase-presentations presentations :stream stream :box box))))))

(defmacro dragging-output-with-mouse ((stream &rest args) &body body)
  (declare (arglist (stream &key start-x start-y box
				 (while-held (not (null start-x)))
				 (warp-mouse (null start-x))
				 (whostate "Dragging")
				 (who-line-documentation-string nil)
				 (translate-output nil)
				 (show-position nil)
				 (position-transform
				   (graphics:stream-transform stream))
				 (show-position-function
				   #'default-show-position-function))
		    &body body))
  (dw:format-output-macro-default-stream stream)
  `(dragging-output-with-mouse-internal
     (dw:named-continuation dragging-output-with-mouse (,stream) . ,body)
     ,stream . ,args))

(defmacro dragging-output-with-mouse* ((stream &rest lexpr-args) &body body)
  (dw:format-output-macro-default-stream stream)
  `(apply #'dragging-output-with-mouse-internal
	  (dw:named-continuation dragging-output-with-mouse (,stream) . ,body)
	  ,stream :allow-other-keys t . ,lexpr-args))

(defun dragging-output-with-mouse-internal (continuation stream 
					    &rest args
					    &key start-x start-y box
						 (while-held (not (null start-x)))
						 (warp-mouse (null start-x))
						 (whostate "Dragging")
						 (who-line-documentation-string nil)
						 (translate-output nil)
						 (erase-first-function nil)
						 (position-transform
						   (graphics:stream-transform stream))
						 (show-position-function
						   #'default-show-position-function))
  (declare (sys:downward-funarg continuation))
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (graphics:with-output-to-bitmap-stream (bitmap-stream :for-stream stream)
      (when box
	(multiple-value-call
	  #'send bitmap-stream :assure-room-for-output (dw:box-edges box)))
      (funcall continuation bitmap-stream)
      (when erase-first-function
	(funcall erase-first-function stream))
      (multiple-value-bind (bitmap b-origin-x b-origin-y b-left b-top b-right b-bottom)
	  (send bitmap-stream :bitmap-and-edges)
	(let ((left b-left) (top b-top) (right b-right) (bottom b-bottom)
	      (width (- b-right b-left)) (height (- b-bottom b-top))
	      (drawn-left nil) (drawn-top nil) (drawn-right nil) (drawn-bottom nil)
	      (shadow-array nil) (shadow-total-width -1) (shadow-total-height -1))
	  (when warp-mouse
	    (unless start-x (setq start-x (- left x-offset)))
	    (unless start-y (setq start-y (- top y-offset)))
	    (send stream :set-mouse-position start-x start-y))
	  (unless (and start-x start-y)
	    (multiple-value-bind (x y)
		(send window :mouse-position)
	      (unless start-x (setq start-x (- x x-offset)))
	      (unless start-y (setq start-y (- y y-offset)))))
	  (when translate-output
	    (incf left start-x) (incf right start-x)
	    (incf top start-y) (incf bottom start-y))
	  ;; Convert start position into window coordinates
	  (incf start-x x-offset)
	  (incf start-y y-offset)
	  ;; Convert bitmap position into raster indices
	  (decf b-left b-origin-x)
	  (decf b-top b-origin-y)
	  (unwind-protect
	      (let ((last-x start-x)
		    (last-y start-y))
		(with-special-mouse-blinker* (window args)
					     (quantize-position show-new-position)
		  (flet ((new-position (x y)
			   (quantize-position x y stream
					      x-offset y-offset position-transform)
			   (do-show-new-position (show-new-position x y
								    show-position-function)
						 (stream x-offset y-offset
							 position-transform))
			   (let* ((new-drawn-left (+ left (- x start-x)))
				  (new-drawn-top (+ top (- y start-y)))
				  (new-drawn-right (+ new-drawn-left width))
				  (new-drawn-bottom (+ new-drawn-top height)))
			     (if (null drawn-left)
				 (send window :bitblt tv:alu-xor width height
				       bitmap b-left b-top new-drawn-left new-drawn-top)
				 (let* ((shadow-left (min drawn-left new-drawn-left))
					(shadow-top (min drawn-top new-drawn-top))
					(shadow-width (- (max drawn-right new-drawn-right)
							 shadow-left))
					(shadow-height (- (max drawn-bottom new-drawn-bottom)
							  shadow-top)))
				   (when (or (> shadow-width shadow-total-width)
					     (> shadow-height shadow-total-height))
				     (when shadow-array
				       (tv:deallocate-temp-sheet-raster-and-header
					 shadow-array))
				     (setq shadow-total-width (* 32 (ceiling shadow-width 32))
					   shadow-total-height shadow-height)
				     (with-stack-list (dims shadow-total-height
							    shadow-total-width)
				       (setq shadow-array
					     (tv:allocate-temp-sheet-raster-and-header
					       dims :type (sys:array-type bitmap)))))
				   (send window :bitblt-from-sheet tv:alu-seta
					 shadow-width shadow-height shadow-left shadow-top
					 shadow-array 0 0)
				   (bitblt tv:alu-xor width height bitmap b-left b-top
					   shadow-array (- drawn-left shadow-left)
					   (- drawn-top shadow-top))
				   (bitblt tv:alu-xor width height bitmap b-left b-top
					   shadow-array (- new-drawn-left shadow-left)
					   (- new-drawn-top shadow-top))
				   (send window :bitblt tv:alu-seta
					 shadow-width shadow-height shadow-array 0 0
					 shadow-left shadow-top)))
			     (setq drawn-left new-drawn-left drawn-top new-drawn-top
				   drawn-right new-drawn-right drawn-bottom new-drawn-bottom)
			     (setq last-x x last-y y)))
			 (return-answer (x y &optional click)
			   (cond (translate-output
				   (graphics:untransform-window-points stream x y)
				   (return-from dragging-output-with-mouse-internal
				     (values x y click)))
				  (t
				   (let ((dx (- x start-x))
					 (dy (- y start-y)))
				     (multiple-value-setq (dx dy)
				       (graphics:untransform-distance
					 dx dy
					 (graphics:stream-transform stream)))
				     (return-from dragging-output-with-mouse-internal
				       (values dx dy click)))))))
		    (if while-held
			(dw:tracking-mouse
			    (window :whostate whostate
				    :who-line-documentation-string
				     who-line-documentation-string)
			  (:release-mouse ()
			   (return-answer last-x last-y))
			  (:mouse-motion-hold (x y)
			   (new-position x y)))
			(dw:tracking-mouse 
			    (window :whostate whostate
				    :who-line-documentation-string
				     who-line-documentation-string)
			  (:mouse-click (click x y)
			   (quantize-position x y stream x-offset y-offset position-transform)
			   (return-answer x y click))
			  (:mouse-motion (x y)
			   (new-position x y)))))))
	    (when shadow-array
	      (tv:deallocate-temp-sheet-raster-and-header shadow-array))
	    (when drawn-left
	      (send window :bitblt tv:alu-xor width height
		    bitmap b-left b-top drawn-left drawn-top))))))))

(defmacro rotating-output-with-mouse ((&optional stream &rest options) &body body)
  (dw:format-output-macro-default-stream stream)
  `(rotating-output-with-mouse-internal
     (dw:named-continuation rotating-output-with-mouse (,stream) . ,body)
     ,stream
     . ,options))

(defun rotating-output-with-mouse-internal (continuation stream
					    &rest args
					    &key presentations
						 (erase-first t)
						 (center-x nil) (center-y nil)
						 (while-held center-x)
						 (position-transform
						   (graphics:stream-transform stream))
					    &allow-other-keys)
  (declare (sys:downward-funarg continuation))
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (if (and center-x center-y)
	(graphics:transform-window-points stream center-x center-y)
      (multiple-value-setq (center-x center-y)
	(call-with-mouse-blinker-options #'mouse-input-point-internal
					 window "Pick rotation center and hold"
					 :who-line-documentation-string
 "L: Put center of rotation here (and hold); M: Abort.  Abort also aborts"
					 args))
      (setq while-held t))
    (unwind-protect-case ()
	(let ((rotation nil)
	      (last-x nil) (last-y nil))
	  (when erase-first
	    (erase-presentations presentations))
	  (multiple-value-bind (x-center-x x-center-y)
	      (graphics:stream-untransform-point center-x center-y window)
	    (flet ((draw-it (window)
		     (dw:with-output-recording-disabled (window)
		       (graphics:with-graphics-translation (window x-center-x x-center-y)
			 (graphics:with-graphics-rotation (window (or rotation 0))
			   (graphics:with-graphics-translation (window (- x-center-x)
								       (- x-center-y))
			     (funcall continuation window)))))))
	      (with-special-mouse-blinker* (window args)
					   (quantize-position show-new-angle)
		(flet ((compute-new-rotation (x y)
			 (multiple-value-bind (x-x x-y)
			     (graphics:stream-untransform-point x y window)
			   (let ((dx (- x-x x-center-x))
				 (dy (- x-y x-center-y)))
			     (setq rotation (atan-careful dy dx nil)))))
		       (show-new-rotation ()
			 (when rotation
			   (show-new-angle (stream)
					   (write (floor (* rotation 180) pi)
						  :stream stream)))))
		  (unwind-protect
		      (if while-held
			  (dw:tracking-mouse
			      (window :whostate "Rotating"
				      :who-line-documentation-string
 "Move to other end of rotation vector and release.  Abort aborts.")
			    (:release-mouse ()
			      (unless rotation (signal 'sys:abort))
			      (return))
			    (:mouse-motion-hold (x y)
			     (quantize-position x y stream
						x-offset y-offset position-transform)
			     (unless (and (eql x last-x) (eql y last-y))
			       (when last-x (draw-it window))
			       (setq last-x x last-y y)
			       (compute-new-rotation x y)
			       (show-new-rotation)
			       (draw-it window))))
			  (dw:tracking-mouse (window :whostate "Rotating"
						     :who-line-documentation-string
 "L: Put other end of rotation vector here; M: Abort.  Abort also aborts.")
			    (:mouse-click (click x y)
			      (unless (eql click #\Mouse-left)
				(signal 'sys:abort))
			      (quantize-position x y stream
						 x-offset y-offset position-transform)
			      (compute-new-rotation x y)
			      (unless rotation (signal 'sys:abort))
			      (return))
			    (:mouse-motion (x y)
			     (quantize-position x y stream
						x-offset y-offset position-transform)
			     (unless (and (eql x last-x) (eql y last-y))
			       (when last-x (draw-it window))
			       (setq last-x x last-y y)
			       (compute-new-rotation x y)
			       (show-new-rotation)
			       (draw-it window)))))
		    (when last-x (draw-it window)))))))
	  (graphics:untransform-window-points stream center-x center-y)
	  (values center-x center-y rotation))
      (:abort
	(when erase-first
	  (unerase-presentations presentations))))))

(defmacro mouse-inputting-point ((window x y &rest options) echo &body body)
  (declare (arglist (window x y &key (while-held nil)
				     (whostate "Pick a point")
				     (who-line-documentation-string nil)
				     (show-position nil)
				     (position-transform
				       (graphics:stream-transform window))
				     (show-position-function
				       #'default-show-position-function)
				     (quantize-position nil)
				     (position-quantum nil) (quantization-function nil)
				     (original-stream window) (x-offset 0) (y-offset 0))
		    echo &body body)
	   (zwei:indentation 1 3 2 1))
  `(multiple-value-bind (,x ,y)
       (mouse-inputting-point-internal (dw:named-continuation mouse-inputting-point
							       (,window ,x ,y)
					 ,echo)
				       ,window . ,options)
     . ,body))

(defmacro mouse-inputting-point* ((window x y &rest lexpr-options) echo &body body)
  (declare (zwei:indentation 1 3 2 1))
  `(multiple-value-bind (,x ,y)
       (apply #'mouse-inputting-point-internal
	      (dw:named-continuation mouse-inputting-point (,window ,x ,y)
		,echo)
	      ,window :allow-other-keys t . ,lexpr-options)
     . ,body))

(defun mouse-inputting-point-internal (echo window &rest args
						   &key (while-held nil)
							(whostate "Pick a point")
							(who-line-documentation-string nil)
							(position-transform
							  (graphics:stream-transform window))
							(show-position-function
							  #'default-show-position-function)
							(original-stream window)
							(if-null :current)
							(x-offset 0)
							(y-offset 0)
						   &allow-other-keys)
  (dw:with-output-recording-disabled (window)
    (let ((drawn-x nil) (drawn-y nil)
	  ;; Save the transform and replace with identity, so that echo can use graphics
	  ;; primitives if it wishes.
	  (original-transform position-transform))
      (graphics:with-graphics-identity-transform (window)
	(with-special-mouse-blinker* (window args)
				     (quantize-position show-new-position)
	  (flet ((echo (x y)
		   (quantize-position x y original-stream
				      x-offset y-offset original-transform)
		   (unless (and (eql x drawn-x) (eql y drawn-y))
		     (do-show-new-position (show-new-position x y show-position-function)
					   (original-stream x-offset y-offset
					    original-transform))
		     (when drawn-x 
		       (funcall echo window drawn-x drawn-y))
		     (funcall echo window x y)
		     (setq drawn-x x drawn-y y))))
	    (unwind-protect
		(if while-held
		    (dw:tracking-mouse (window :whostate whostate
					       :who-line-documentation-string
					       (or who-line-documentation-string
						   "Release mouse when done.  Abort aborts."))
		      (:release-mouse ()
		       (if drawn-x
			   (return (values drawn-x drawn-y))
			   (ecase if-null
			     (:return
			       (return nil))
			     (:current
			       (multiple-value-bind (x y)
				   (send window :mouse-position)
				 (quantize-position x y original-stream
						    x-offset y-offset original-transform)
				 (return (values x y))))
			     (:abort
			       (signal 'sys:abort)))))
		      (:mouse-motion-hold (x y)
		       (echo x y)))
		    (dw:tracking-mouse (window :whostate whostate
					       :who-line-documentation-string
					       (or who-line-documentation-string
  "L: Pick this point; M: abort.  Abort also aborts."))
		      (:mouse-motion (x y)
		       (echo x y))
		      (:mouse-click (click x y)
		       (quantize-position x y original-stream
					  x-offset y-offset original-transform)
		       (unless (eql click #\Mouse-left)
			 (signal 'sys:abort))
		       (return (values x y click)))))
	      (when drawn-x 
		(funcall echo window drawn-x drawn-y)))))))))

(defun mouse-input-point-internal (window whostate &rest args)
  (declare (arglist window whostate &key (while-held nil)
		    (who-line-documentation-string nil)
		    (show-position nil)
		    (position-transform
		      (graphics:stream-transform window))
		    (show-position-function
		      #'default-show-position-function)
		    (quantize-position nil)
		    (position-quantum nil)
		    (quantization-function nil)
		    (original-stream window)
		    (x-offset 0) (y-offset 0)))
  (mouse-inputting-point* (window x y :whostate whostate args)
      (ignore window x y)
    (values x y)))

(defun mouse-input-point (&rest args
			  &key (stream *standard-output*)
			       (whostate "Select a point")
			       (who-line-documentation-string nil)
			  &allow-other-keys)
  (multiple-value-bind (x y)
      (multiple-value-bind (window x-offset y-offset)
	  (send stream :window-and-offsets)
	(call-with-mouse-blinker-options #'mouse-input-point-internal
					 window whostate
					 :who-line-documentation-string
					  who-line-documentation-string
					 :original-stream stream
					 :x-offset x-offset :y-offset y-offset
					 args))
    (graphics:untransform-window-points stream x y)
    (values x y)))

(defun mouse-input-line (&rest args
			 &key (stream *standard-output*)
			      (first-whostate "Start of line")
			      (second-whostate "End of line")
			      (first-who-line-documentation-string nil)
			      (second-who-line-documentation-string nil)
			      start-x start-y (while-held t)
			 &allow-other-keys)
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    ;; Get into window coordinates.
    (when (and start-x start-y)
      (graphics:transform-window-points stream start-x start-y))
    (multiple-value-bind (start-x start-y end-x end-y)
	(call-with-mouse-blinker-options #'mouse-input-line-internal
					 window first-whostate second-whostate
					 :first-who-line-documentation-string
					  first-who-line-documentation-string
					 :second-who-line-documentation-string
					  second-who-line-documentation-string
					 :start-x start-x :start-y start-y
					 :original-stream stream
					 :x-offset x-offset :y-offset y-offset
					 :while-held while-held
					 args)
      (graphics:untransform-window-points stream start-x start-y end-x end-y)
      (values start-x start-y end-x end-y))))

(defun mouse-input-line-internal (window first-whostate second-whostate
				  &rest args
				  &key first-who-line-documentation-string
				       second-who-line-documentation-string
				       start-x start-y while-held
				  &allow-other-keys)
  (unless (and start-x start-y)
    (multiple-value-setq (start-x start-y)
      (call-with-mouse-blinker-options #'mouse-input-point-internal 
				       window first-whostate
				       :who-line-documentation-string
				        (or first-who-line-documentation-string
					    (if while-held
 "L: Put start of line here (and hold); M: Abort.  Abort also aborts"
 "L: Put start of line here; M: Abort.  Abort also aborts"))
				       args)))
  (mouse-inputting-point* (window end-x end-y :whostate second-whostate
					      :who-line-documentation-string
					       (cond (second-who-line-documentation-string)
						     (while-held 
  "Release at other end of line.  Abort aborts")
						     (t 
  "L: Put other end of line here; M: Abort.  Abort also aborts."))
					     args)
      (graphics:draw-line start-x start-y end-x end-y :stream window :alu :flip)
    (values start-x start-y end-x end-y)))

(defmacro mouse-inputting-scale ((stream &rest options) &body body)
  (dw:format-output-macro-default-stream stream)
  `(mouse-input-scale-internal
     (dw:named-continuation mouse-inputting-scale (,stream) . ,body)
     ,stream
     . ,options))
  
(defun mouse-input-scale-internal (continuation stream
				   &rest args
				   &key (start-x nil) (start-y nil) (while-held t)
					(position-transform
					  (graphics:stream-transform stream))
				   &allow-other-keys)
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (multiple-value-bind (center-x center-y)
	(if (not (and start-x start-y))
	    (call-with-mouse-blinker-options #'mouse-input-point-internal 
					     window "Pick fixed point"
					     :who-line-documentation-string
 "L: Set point that remains fixed here; M: Abort.  Abort also aborts."
					     args)
	  (graphics:transform-window-points stream start-x start-y)
	  (values start-x start-y))
      (multiple-value-setq (start-x start-y)
	(call-with-mouse-blinker-options #'mouse-input-point-internal 
					 window "Pick point to move and hold"
					 :who-line-documentation-string 
  "L: Scale according to movement of this point (and hold); M: Abort.  Abort also aborts."
					 args))
      (multiple-value-setq (start-x start-y)
	(graphics:stream-untransform-point start-x start-y window))
      (multiple-value-bind (x-center-x x-center-y)
	  (graphics:stream-untransform-point center-x center-y window)
	(let ((start-dx (- start-x x-center-x))
	      (start-dy (- start-y x-center-y))
	      (scale nil) (last-x nil) (last-y nil))
	  (when (and (zerop start-dx) (zerop start-dy))
	    (dw:command-error "You must must select a point away from the fixed point."))
	  (flet ((draw-it (window)
		   (dw:with-output-recording-disabled (window)
		     (graphics:with-graphics-translation (window x-center-x x-center-y)
		       (graphics:with-graphics-scale (window (or scale 1))
			 (graphics:with-graphics-translation (window (- x-center-x)
								     (- x-center-y))
			   (funcall continuation window)))))))
	    (with-special-mouse-blinker* (window args)
					 (quantize-position show-new-scale-internal)
	      (flet ((compute-new-scale (x y)
		       (multiple-value-bind (x-x x-y)
			   (graphics:stream-untransform-point x y window)
			 (let ((dx (- x-x x-center-x))
			       (dy (- x-y x-center-y)))
			   (setq scale (cond ((and (zerop dx) (zerop dy)) 1)
					     ((zerop start-dx) (/ dy start-dy))
					     ((zerop start-dy) (/ dx start-dx))
					     (t (min (/ dx start-dx) (/ dy start-dy))))))))
		     (show-new-scale ()
		       (when scale
			 (show-new-scale-internal (stream) (write scale :stream stream)))))
		(unwind-protect
		    (if while-held
			(dw:tracking-mouse (window :whostate "Scaling"
						   :who-line-documentation-string
  "Move to new scaled point and release.  Abort aborts.")
			  (:release-mouse ()
			    (unless scale (signal 'sys:abort))
			    (return))
			  (:mouse-motion-hold (x y)
			   (quantize-position x y stream x-offset y-offset position-transform)
			   (unless (and (eql x last-x) (eql y last-y))
			     (when last-x (draw-it window))
			     (setq last-x x last-y y)
			     (compute-new-scale x y)
			     (show-new-scale)
			     (draw-it window))))
			(dw:tracking-mouse (window :whostate "Scaling"
						   :who-line-documentation-string
 "L: Put new scaled point here; M: Abort.  Abort also aborts.")
			  (:mouse-click (click x y)
			   (unless (eql click #\Mouse-left)
			     (signal 'sys:abort))
			   (quantize-position x y stream x-offset y-offset position-transform)
			   (compute-new-scale x y)
			   (unless scale (signal 'sys:abort))
			   (return))
			  (:mouse-motion (x y)
			   (quantize-position x y stream x-offset y-offset position-transform)
			   (unless (and (eql x last-x) (eql y last-y))
			     (when last-x (draw-it window))
			     (setq last-x x last-y y)
			     (compute-new-scale x y)
			     (show-new-scale)
			     (draw-it window)))))
		  (when last-x (draw-it window))))))
	  (graphics:untransform-window-points stream center-x center-y)
	  (values center-x center-y scale))))))

(defmacro mouse-inputting-stretch ((stream &rest options) &body body)
  (dw:format-output-macro-default-stream stream)
  `(mouse-input-stretch-internal
     (dw:named-continuation mouse-inputting-stretch (,stream) . ,body)
     ,stream
     . ,options))
  
(defun mouse-input-stretch-internal (continuation stream
				     &rest args
				     &key (start-x nil) (start-y nil) (while-held t)
					  (position-transform
					    (graphics:stream-transform stream))
				     &allow-other-keys)
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (multiple-value-bind (center-x center-y)
	(if (not (and start-x start-y))
	    (call-with-mouse-blinker-options #'mouse-input-point-internal 
					     window "Pick fixed point"
					     :who-line-documentation-string
 "L: Set point that remains fixed here; M: Abort.  Abort also aborts."
					     args)
	  (graphics:transform-window-points stream start-x start-y)
	  (values start-x start-y))
      (multiple-value-setq (start-x start-y)
	(call-with-mouse-blinker-options #'mouse-input-point-internal 
					 window "Pick point to move and hold"
					 :who-line-documentation-string 
  "L: Stretch according to movement of this point (and hold); M: Abort.  Abort also aborts."
					 args))
      (multiple-value-setq (start-x start-y)
	(graphics:stream-untransform-point start-x start-y window))
      (multiple-value-bind (x-center-x x-center-y)
	  (graphics:stream-untransform-point center-x center-y window)
	(let ((start-dx (- start-x x-center-x))
	      (start-dy (- start-y x-center-y))
	      (stretch-x nil) (stretch-y nil) (last-x nil) (last-y nil))
	  (when (or (zerop start-dx) (zerop start-dy))
	    (dw:command-error "You must must select a point away from the fixed point."))
	  (flet ((draw-it (window)
		   (dw:with-output-recording-disabled (window)
		     (graphics:with-graphics-translation (window x-center-x x-center-y)
		       (graphics:with-graphics-scale (window (or stretch-x 1)
							     (or stretch-y 1))
			 (graphics:with-graphics-translation (window (- x-center-x)
								     (- x-center-y))
			   (funcall continuation window)))))))
	    (with-special-mouse-blinker* (window args)
					 (quantize-position show-new-stretch-internal)
	      (flet ((compute-new-stretch (x y)
		       (multiple-value-bind (x-x x-y)
			   (graphics:stream-untransform-point x y window)
			 (let ((dx (- x-x x-center-x))
			       (dy (- x-y x-center-y)))
			   (setq stretch-x (if (zerop dx) 1 (/ dx start-dx))
				 stretch-y (if (zerop dy) 1 (/ dy start-dy))))))
		     (show-new-stretch ()
		       (when stretch-x
			 (show-new-stretch-internal (stream)
			   (format stream "~Dx~D" stretch-x stretch-y)))))
		(unwind-protect
		    (if while-held
			(dw:tracking-mouse (window :whostate "Stretching"
						   :who-line-documentation-string
  "Move to new stretched point and release.  Abort aborts.")
			  (:release-mouse ()
			    (unless stretch-x (signal 'sys:abort))
			    (return))
			  (:mouse-motion-hold (x y)
			   (quantize-position x y stream x-offset y-offset position-transform)
			   (unless (and (eql x last-x) (eql y last-y))
			     (when last-x (draw-it window))
			     (setq last-x x last-y y)
			     (compute-new-stretch x y)
			     (show-new-stretch)
			     (draw-it window))))
			(dw:tracking-mouse (window :whostate "Stretching"
						   :who-line-documentation-string
  "L: Put new stretched point here; M: Abort.  Abort also aborts.")
			  (:mouse-click (click x y)
			   (unless (eql click #\Mouse-left)
			     (signal 'sys:abort))
			   (quantize-position x y stream x-offset y-offset position-transform)
			   (compute-new-stretch x y)
			   (unless stretch-x (signal 'sys:abort))
			   (return))
			  (:mouse-motion (x y)
			   (quantize-position x y stream x-offset y-offset position-transform)
			   (unless (and (eql x last-x) (eql y last-y))
			     (when last-x (draw-it window))
			     (setq last-x x last-y y)
			     (compute-new-stretch x y)
			     (show-new-stretch)
			     (draw-it window)))))
		  (when last-x (draw-it window))))))
	  (graphics:untransform-window-points stream center-x center-y)
	  (values center-x center-y stretch-x stretch-y))))))

(defmacro mouse-inputting-shear ((stream &rest options) &body body)
  (dw:format-output-macro-default-stream stream)
  `(mouse-input-shear-internal
     (dw:named-continuation mouse-inputting-shear (,stream) . ,body)
     ,stream
     . ,options))
  
(defun mouse-input-shear-internal (continuation stream
				   &rest args
				   &key (start-x nil) (start-y nil) (while-held t)
					(position-transform
					  (graphics:stream-transform stream))
				   &allow-other-keys)
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (multiple-value-bind (fixed-x1 fixed-y1 fixed-x2 fixed-y2)
	(call-with-mouse-blinker-options #'mouse-input-line-internal 
					 window
					 "Pick start of fixed line" "Pick end of fixed line"
					 :start-x start-x :start-y start-y
					 :while-held while-held
					 args)
      (multiple-value-setq (start-x start-y)
	(call-with-mouse-blinker-options #'mouse-input-point-internal 
					 window "Pick point to move and hold"
					 :who-line-documentation-string 
  "L: Shear according to movement of this point (and hold); M: Abort.  Abort also aborts."
					 args))
      (let ((transform nil) (last-x nil) (last-y nil)
	    x-start-x x-start-y x-fixed-x1 x-fixed-y1 x-fixed-x2 x-fixed-y2)
	  (multiple-value-setq (x-start-x x-start-y)
	    (graphics:stream-untransform-point start-x start-y window))
	  (multiple-value-setq (x-fixed-x1 x-fixed-y1)
	    (graphics:stream-untransform-point fixed-x1 fixed-y1 window))
	  (multiple-value-setq (x-fixed-x2 x-fixed-y2)
	    (graphics:stream-untransform-point fixed-x2 fixed-y2 window))
	  (graphics:draw-line x-fixed-x1 x-fixed-y1 x-fixed-x2 x-fixed-y2
			      :dashed t :dash-pattern #(2 2) :alu :flip :stream window)
	  (flet ((draw-it (window)
		   (dw:with-output-recording-disabled (window)
		     (graphics:with-graphics-transform (window
							 (or transform
							     graphics:*identity-transform*))
		       (funcall continuation window)))))
	    (with-special-mouse-blinker* (window args)
					 (quantize-position show-new-position)
	      (flet ((compute-new-transform (x y)
		       (multiple-value-bind (x-x x-y)
			   (graphics:stream-untransform-point x y window)
			 (setq transform (unless (or (triangle-colinear-p fixed-x1 fixed-y1
									  fixed-x2 fixed-y2
									  x-start-x x-start-y)
						     (triangle-colinear-p fixed-x1 fixed-y1
									  fixed-x2 fixed-y2
									  x-x x-y))
					   (with-stack-list (points fixed-x1 fixed-y1
								    fixed-x2 fixed-y2
								    x-start-x x-start-y
								    fixed-x1 fixed-y1
								    fixed-x2 fixed-y2
								    x-x x-y)
					     (graphics:build-multiple-point-transform
					       points)))))))
		(unwind-protect
		    (dw:tracking-mouse (window :whostate "Shearing"
					       :who-line-documentation-string
  "Move to new point and release.  Abort aborts.")
		      (:release-mouse ()
		       (unless transform (signal 'sys:abort))
		       (return))
		      (:mouse-motion-hold (x y)
		       (quantize-position x y stream x-offset y-offset position-transform)
		       (unless (and (eql x last-x) (eql y last-y))
			 (when last-x (draw-it window))
			 (setq last-x x last-y y)
			 (compute-new-transform x y)
			 (do-show-new-position (show-new-position x y)
					       (stream x-offset y-offset position-transform))
			 (draw-it window))))
		  (when last-x (draw-it window))
		  (graphics:draw-line x-fixed-x1 x-fixed-y1 x-fixed-x2 x-fixed-y2
				      :dashed t :dash-pattern #(2 2) :alu :flip
				      :stream window)))))
	  transform))))

(defun mouse-input-circle (&rest args
			   &key (stream *standard-output*)
				(start-x nil) (start-y nil) (while-held t)
				(initially-display-object t) (position-transform nil)
			   &allow-other-keys)
  (ignore initially-display-object)		;+++
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (multiple-value-bind (center-x center-y)
	(if (not (and start-x start-y))
	    (call-with-mouse-blinker-options #'mouse-input-point-internal 
					     window "Pick center and hold"
					     :who-line-documentation-string
  "L: Put center of circle here (and hold); M: Abort.  Abort also aborts"
					     args)
	  (graphics:transform-window-points stream start-x start-y)
	  (values start-x start-y))
      (multiple-value-bind (user-center-x user-center-y)
	  (graphics:untransform-point center-x center-y
				      (or position-transform
					  (graphics:stream-transform stream)))
	(mouse-inputting-point* (window other-x other-y
					:while-held while-held
					:show-position-function
					#'(lambda (stream other-x other-y)
					    (format stream "~$"
						    (sqrt
						      (+ (expt (- other-x user-center-x) 2)
							 (expt (- other-y user-center-y) 2)))))
					:original-stream stream
					:x-offset x-offset :y-offset y-offset
					args)
	    (graphics:draw-circle center-x center-y (isqrt (+ (expt (- other-x center-x) 2)
							      (expt (- other-y center-y) 2)))
				  :stream window :alu :flip :filled nil)
	  (graphics:untransform-window-points stream center-x center-y other-x other-y)
	  (when (and (= other-x center-x)
		     (= other-y center-y))
	    (dw:command-error "Circle must have positive radius"))
	  (values center-x center-y (sqrt (+ (expt (- other-x center-x) 2)
					     (expt (- other-y center-y) 2)))))))))

(defun old-mouse-input-rectangle (&rest args
			      &key (stream *standard-output*)
			      dashed
			      (first-whostate "Pick corner and hold")
			      (second-whostate "Inputting rectangle")
			      (first-who-line-documentation-string 
 "L: Put one corner of rectangle here; M: Abort.  Abort also aborts.")
			      (second-who-line-documentation-string
 "Release at other end of rectangle")
			      (start-x nil) (start-y nil) (while-held (not (null start-x)))
			      &allow-other-keys)
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (if (and start-x start-y)
	(graphics:transform-window-points stream start-x start-y)
	(multiple-value-setq (start-x start-y)
	  (call-with-mouse-blinker-options #'mouse-input-point-internal 
					   window first-whostate
					   :who-line-documentation-string
					    first-who-line-documentation-string
					   args))
	(setq while-held t))
    (mouse-inputting-point* (window end-x end-y
				    :whostate second-whostate
				    :who-line-documentation-string
				     second-who-line-documentation-string
				     :while-held while-held
				     :original-stream stream
				     :x-offset x-offset :y-offset y-offset
				     args)
	(graphics:draw-rectangle start-x start-y end-x end-y
				 :stream window :alu :flip :filled nil
				 :dashed dashed :dash-pattern #(1 4))
      (graphics:untransform-window-points stream start-x start-y end-x end-y)
      (values start-x start-y end-x end-y))))

(defun warp-mouse-at-least (window start-x start-y min-x min-y)
  (multiple-value-bind (x-now y-now)
      (send window :mouse-position)
    (when (and (< (abs (- x-now start-x)) (abs min-x))
	       (< (abs (- y-now start-y)) (abs min-y)))
      (send window :set-mouse-position (+ start-x min-x) (+ start-y min-y)))))

(defun mouse-input-rectangle (&rest args
			      &key (stream *standard-output*)
			      dashed
			      (initially-display-object t)
			      (first-whostate "Pick corner and hold")
			      (second-whostate "Inputting rectangle")
			      (first-who-line-documentation-string 
				"L: Put one corner of rectangle here; M: Abort.  Abort also aborts.")
			      (second-who-line-documentation-string
				"Release at other end of rectangle")
			      (start-x nil) (start-y nil) (while-held (not (null start-x)))
			      &allow-other-keys)
  (let ((initial-width 60)
	(initial-height 40))
    (multiple-value-bind (window x-offset y-offset)
	(send stream :window-and-offsets)
      (if (and start-x start-y)
	  (graphics:transform-window-points stream start-x start-y)
	  (multiple-value-setq (start-x start-y)
	    (mouse-inputting-point* (window start-x start-y
					    :whostate first-whostate
					    :who-line-documentation-string first-who-line-documentation-string
					    args)
		(when initially-display-object
		  (graphics:draw-rectangle start-x start-y
					   (+ start-x initial-width) (+ start-y initial-height)
					   :stream window :alu :flip :filled nil))
	      (values start-x start-y)))
	  (setq while-held t))
      (when initially-display-object
	(warp-mouse-at-least window start-x start-y initial-width initial-height))
      (mouse-inputting-point* (window end-x end-y
				      :whostate second-whostate
				      :who-line-documentation-string
				      second-who-line-documentation-string
				      :while-held while-held
				      :original-stream stream
				      :x-offset x-offset :y-offset y-offset
				      args)
	  (graphics:draw-rectangle start-x start-y end-x end-y
				   :stream window :alu :flip :filled nil
				   :dashed dashed :dash-pattern #(1 4))
	(graphics:untransform-window-points stream start-x start-y end-x end-y)
	(values start-x start-y end-x end-y)))))

(defun old-mouse-input-triangle (&rest args
			     &key (stream *standard-output*)
				  (start-x nil) (start-y nil) (while-held t)
			     &allow-other-keys)
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (when (and start-x start-y)
      (graphics:transform-window-points stream start-x start-y))
    (multiple-value-bind (x1 y1 x2 y2)
	(call-with-mouse-blinker-options #'mouse-input-line-internal 
					 window
					 "Pick first corner and hold"
					 "Pick second corner of triangle"
					 ;; sort of a weird effect, but less of
					 ;; a surprise if you are used to the
					 ;; rectangle inputter
					 :start-x start-x :start-y start-y
					 :while-held while-held
					 args)
      (mouse-inputting-point* (window x3 y3 :whostate "Inputting triangle"
				      :original-stream stream
				      :x-offset x-offset :y-offset y-offset
				      args)
	  (graphics:draw-triangle x1 y1 x2 y2 x3 y3 :stream window :alu :flip :filled nil)
	(graphics:untransform-window-points stream x1 y1 x2 y2 x3 y3)
	(values x1 y1 x2 y2 x3 y3)))))

(defun mouse-input-triangle (&rest args
			     &key (stream *standard-output*)
			     ((:start-x x1) nil) ((:start-y y1) nil) (while-held t)
			     (initially-display-object t)
			     &allow-other-keys)
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (if (and x1 y1)
	(graphics:transform-window-points stream x1 y1)
	(multiple-value-setq (x1 y1)
	  (mouse-inputting-point* (window x1 y1
					  :whostate "Pick first corner and hold"
					  :original-stream stream
					  :x-offset x-offset :y-offset y-offset
					  args)
	      (when initially-display-object
		(graphics:draw-triangle x1 y1 (- x1 10) (+ y1 30) (+ x1 30) (+ y1 25)
					:alu :flip :filled nil :stream window))
	    (values x1 y1))))
    (when initially-display-object
      (warp-mouse-at-least window x1 y1 -10 +30))
    (multiple-value-bind (x2 y2)
	(mouse-inputting-point* (window x2 y2
					:whostate "Pick second corner of triangle"
					:original-stream stream
					:x-offset x-offset :y-offset y-offset
					:while-held while-held
					args)
	    (if initially-display-object
		(graphics:draw-triangle x1 y1 x2 y2 (+ x2 40) (- y2 5)
					:alu :flip :filled nil :stream window)
		(graphics:draw-line x1 y1 x2 y2 :alu :flip :stream window))
	  (values x2 y2))
      (when initially-display-object
	(warp-mouse-at-least window x2 y2 +40 -5))
      (mouse-inputting-point* (window x3 y3
				      :whostate "Pick third corner of triangle"
				      :original-stream stream
				      :x-offset x-offset :y-offset y-offset
				      :while-held nil
				      args)
	  (graphics:draw-triangle x1 y1 x2 y2 x3 y3
				  :alu :flip :filled nil :stream window)
	(graphics:untransform-window-points stream x1 y1 x2 y2 x3 y3)
	(values x1 y1 x2 y2 x3 y3)))))

(defun mouse-input-simple-ellipse (&rest args
				   &key (drawing-function #'graphics:draw-ellipse)
					(start-x nil) (start-y nil) (while-held t)
					(stream *standard-output*)
				   &allow-other-keys)
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (if (and start-x start-y)
	(graphics:transform-window-points stream start-x start-y)
	(multiple-value-setq (start-x start-y)
	  (call-with-mouse-blinker-options #'mouse-input-point-internal 
					   window "Pick the corner and hold"
					   :who-line-documentation-string
  "L: Put corner of the bounding rectangle here (and hold); M: Abort.  Abort also aborts"
					   args)))
    (mouse-inputting-point* (window end-x end-y
				    :whostate "Inputting ellipse"
				    :while-held while-held
				    :original-stream stream
				    :x-offset x-offset :y-offset y-offset
				    args)
	(funcall drawing-function
		 (round (+ start-x end-x) 2) (round (+ start-y end-y) 2)
		 (round (abs (- end-x start-x)) 2) (round (abs (- end-y start-y)) 2)
		 :stream window :alu :flip :filled nil)
      (graphics:untransform-window-points stream start-x start-y end-x end-y)
      (when (or (= start-x end-x) (= start-y end-y))
	(dw:command-error "Ellipse is flat"))
      (values (/ (+ start-x end-x) 2) (/ (+ start-y end-y) 2)
	      (/ (abs (- end-x start-x)) 2) (/ (abs (- end-y start-y)) 2)))))

(defun mouse-input-oval (&rest args)
  (apply #'mouse-input-simple-ellipse :drawing-function #'graphics:draw-oval args))

(defun mouse-input-general-ellipse (&rest args
				    &key (stream *standard-output*)
					 (start-x nil) (start-y nil) (while-held t)
				    &allow-other-keys)
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (when (and start-x start-y)
      (graphics:transform-window-points stream start-x start-y))
    (multiple-value-bind (center-x center-y axis-1-x axis-1-y)
	(call-with-mouse-blinker-options #'mouse-input-line-internal 
					 window "Pick center of ellipse and hold"
					 "Pick end of primary axis"
					 :first-who-line-documentation-string
 "L: Put center of ellipse here (and hold); M: Abort.  Abort also aborts."
					 :second-who-line-documentation-string
 "Release at other end of one axis."
					 :start-x start-x :start-y start-y
					 :while-held while-held
					 args)
      (flet ((compute-ellipse (axis-2-x axis-2-y)
	       (declare (values x-radius y-radius rotation))
	       (values (sqrt (+ (expt (- axis-1-x center-x) 2)
				(expt (- axis-1-y center-y) 2)))
		       (sqrt (+ (expt (- axis-2-x center-x) 2)
				(expt (- axis-2-y center-y) 2)))
		       (atan-careful (- axis-1-y center-y) (- axis-1-x center-x)))))
	(mouse-inputting-point* (window axis-2-x axis-2-y
					:whostate "Inputting ellipse"
					:who-line-documentation-string
 "L: Put end of other axis here; M: Abort.  Abort also aborts."
					:x-offset x-offset :y-offset y-offset
					:original-stream stream
					args)
	    (multiple-value-bind (x-radius y-radius rotation)
		(compute-ellipse axis-2-x axis-2-y)
	      (graphics:draw-ellipse 0 0 x-radius y-radius :rotation rotation
				     :stream window :alu :flip :filled nil
				     :translation (list center-x center-y)))
	  (graphics:untransform-window-points stream center-x center-y
					      axis-1-x axis-1-y
					      axis-2-x axis-2-y)
	  (multiple-value-bind (x-radius y-radius rotation)
	      (compute-ellipse axis-2-x axis-2-y)
	    (values center-x center-y x-radius y-radius rotation)))))))

(defun mouse-input-circular-arc (&rest args
				 &key (stream *standard-output*)
				      (start-x nil) (start-y nil) (while-held t)
				 &allow-other-keys)
  (declare (values center-x center-y radius start-angle end-angle))
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (when (and start-x start-y)
      (graphics:transform-window-points stream start-x start-y))
    (multiple-value-bind (center-x center-y axis-1-x axis-1-y)
	(call-with-mouse-blinker-options #'mouse-input-line-internal 
					 window "Pick center and hold" "Pick starting radius"
					 :first-who-line-documentation-string
 "L: Put center of circle here (and hold); M: Abort.  Abort also aborts."
					 :second-who-line-documentation-string
 "L: Put first (clockwisemost) arc point here; M: Aborts.  Abort also aborts."
					 :start-x start-x :start-y start-y
					 :while-held while-held
					 args)
      (let ((radius (isqrt (+ (expt (- axis-1-x center-x) 2) (expt (- axis-1-y center-y) 2))))
	    (theta-1 (atan-careful (- axis-1-y center-y) (- axis-1-x center-x))))
	(mouse-inputting-point* (window axis-2-x axis-2-y 
					:whostate "Inputting arc"
					:who-line-documentation-string
 "L: Put other end of counterclockwise arc here; M: Abort.  Abort also aborts."
					:x-offset x-offset :y-offset y-offset
					:original-stream stream
					:while-held nil
					args)
	    (let ((theta-2 (atan-careful (- axis-2-y center-y) (- axis-2-x center-x))))
	      (graphics:draw-circle center-x center-y radius
				    :start-angle theta-2 :end-angle theta-1
				    :stream window :alu :flip :filled nil))
	  (graphics:untransform-window-points stream center-x center-y
					      axis-1-x axis-1-y
					      axis-2-x axis-2-y)
	  (values center-x center-y 
		  (sqrt (+ (expt (- axis-1-x center-x) 2) (expt (- axis-1-y center-y) 2)))
		  (atan-careful (- axis-1-y center-y) (- axis-1-x center-x))
		  (atan-careful (- axis-2-y center-y) (- axis-2-x center-x))))))))

(defun alternative-mouse-input-circular-arc (&rest args
					     &key (stream *standard-output*)
						  (start-x nil) (start-y nil) (while-held t)
					     &allow-other-keys)
  (declare (values center-x center-y radius start-angle end-angle))
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (when (and start-x start-y)
      (graphics:transform-window-points stream start-x start-y))
    (multiple-value-bind (start-x start-y end-x end-y)
	(call-with-mouse-blinker-options #'mouse-input-line-internal 
					 window
					 "Pick starting point and hold" "Pick ending point"
					 :first-who-line-documentation-string
 "L: Put first point of arc here (and hold); M: Abort.  Abort also aborts."
					 :second-who-line-documentation-string
 "L: Put end of arc here here; M: Aborts.  Abort also aborts."
					 :start-x start-x :start-y start-y
					 :while-held while-held
					 args)
      (mouse-inputting-point* (window intermediate-x intermediate-y
				      :whostate "Inputting arc"
				      :who-line-documentation-string
 "L: Put intermediate arc point here; M: Abort.  Abort also aborts."
				       :x-offset x-offset :y-offset y-offset
				       :original-stream stream
				       :while-held nil
				       args)
	  (unless (triangle-colinear-p start-x start-y end-x end-y
				       intermediate-x intermediate-y)
	    (multiple-value-bind (center-x center-y radius)
		(graphics:triangle-circumscribed-circle start-x start-y end-x end-y
							intermediate-x intermediate-y)
	      (let ((theta-1 (atan-careful (- start-y center-y) (- start-x center-x)))
		    (theta-2 (atan-careful (- end-y center-y) (- end-x center-x))))
		(unless (graphics:angle-between-angles-p
			  (atan-careful (- intermediate-y center-y)
					(- intermediate-x center-x))
			  theta-1 theta-2)
		  (rotatef theta-1 theta-2))
		(graphics:draw-circle center-x center-y radius
				      :start-angle theta-1 :end-angle theta-2
				      :stream window :alu :flip :filled nil))))
	  (graphics:untransform-window-points stream start-x start-y end-x end-y
						     intermediate-x intermediate-y)
	  (when (triangle-colinear-p start-x start-y end-x end-y
				     intermediate-x intermediate-y)
	    (dw:command-error "Points should not be colinear"))
	  (multiple-value-bind (center-x center-y radius)
	      (graphics:triangle-circumscribed-circle start-x start-y end-x end-y
						      intermediate-x intermediate-y)
	      (let ((theta-1 (atan-careful (- start-y center-y) (- start-x center-x)))
		    (theta-2 (atan-careful (- end-y center-y) (- end-x center-x))))
		(unless (graphics:angle-between-angles-p
			  (atan-careful (- intermediate-y center-y)
					(- intermediate-x center-x))
			  theta-1 theta-2)
		  (rotatef theta-1 theta-2))
		(values center-x center-y radius theta-1 theta-2)))))))

(defun mouse-input-quarter-ellipse (&rest args
				    &key (stream *standard-output*)
					 (start-x nil) (start-y nil) (while-held t)
				    &allow-other-keys)
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (if (and start-x start-y)
	(graphics:transform-window-points stream start-x start-y)
	(multiple-value-setq (start-x start-y)
	  (call-with-mouse-blinker-options #'mouse-input-point-internal 
					   window "Pick starting point and hold"
					   :who-line-documentation-string 
 "L: Put one end of quarter ellipse here (and hold); M: Abort.  Abort also aborts."
					   args)))
    (mouse-inputting-point* (window end-x end-y
				    :whostate "Quarter ellipse"
				    :who-line-documentation-string
 "Release at other end of elliptical arc.  Abort aborts."
				    :x-offset x-offset :y-offset y-offset
				    :original-stream stream :while-held while-held
				    args)
	(draw-quarter-ellipse start-x start-y end-x end-y
			      :stream window :filled nil :alu :flip)
      (graphics:untransform-window-points stream start-x start-y end-x end-y)
      (values start-x start-y end-x end-y))))

(defun mouse-input-bezier-curve (&rest args
				 &key (stream *standard-output*)
				      (start-x nil) (start-y nil) (while-held t)
				 &allow-other-keys)
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (when (and start-x start-y)
      (graphics:transform-window-points stream start-x start-y))
    (multiple-value-bind (x1 y1 x4 y4)
	(call-with-mouse-blinker-options #'mouse-input-line-internal 
					 window
					 "Pick start of curve and hold" "Pick end of curve"
					 :first-who-line-documentation-string
 "L: Put starting end of curve here (and hold); M: Abort.  Abort also aborts."
					 :second-who-line-documentation-string
 "Release at other end of curve.  Abort aborts."
					 :start-x start-x :start-y start-y
					 :while-held while-held
					 args)
      (when (and (= x1 x4) (= y1 y4))
	(dw:command-error "Curve must have positive length."))
      (mouse-inputting-point* (window x2 y2 :whostate "First control point"
					    :who-line-documentation-string
 "L: Put first control point here; M: Abort.  Abort also aborts."
					    :x-offset x-offset :y-offset y-offset
					    :original-stream stream
					    :while-held nil
					    args)
          (graphics:draw-bezier-curve x1 y1 x4 y4 x2 y2 x2 y2
				      :number-of-samples 10
				      :stream window :alu :flip)
	(mouse-inputting-point* (window x3 y3 :whostate "Second control point"
					      :who-line-documentation-string
 "L: Put second control point here; M: Abort.  Abort also aborts."
					      :x-offset x-offset :y-offset y-offset
					      :original-stream stream
					      :while-held nil
					      args)
	    (graphics:draw-bezier-curve x1 y1 x4 y4 x2 y2 x3 y3
					:number-of-samples 10
					:stream window :alu :flip)
	  (graphics:untransform-window-points stream x1 y1 x2 y2 x3 y3 x4 y4)
	  (values x1 y1 x4 y4 x2 y2 x3 y3))))))

(defun mouse-input-freehand-curve (&rest args
				   &key (stream *standard-output*)
					(start-x nil) (start-y nil) (while-held t)
					(position-transform
					  (graphics:stream-transform stream))
				   &allow-other-keys)
  (ignore while-held)
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (multiple-value-bind (last-x last-y)
	(if (not (and start-x start-y))
	    (call-with-mouse-blinker-options #'mouse-input-point-internal 
					     window "Pick starting point and hold" 
					     :who-line-documentation-string 
 "L: Start drawing curve here (and hold); M: Abort.  Abort also aborts."
					     args)
	  (graphics:transform-window-points stream start-x start-y)
	  (values start-x start-y))
      (sys:with-stack-array (points 100 :fill-pointer 0)
	(vector-push-extend last-x points)
	(vector-push-extend last-y points)
	(dw:with-output-recording-disabled (window)
	  (unwind-protect
	      (with-special-mouse-blinker* (window args)
					   (quantize-position show-new-position)
		(dw:tracking-mouse (window :whostate "Drawing"
					   :who-line-documentation-string
  "Release mouse when done drawing.  Abort aborts.")
		  (:mouse-motion-hold (x y)
		   (quantize-position x y stream x-offset y-offset position-transform)
		   (do-show-new-position (show-new-position x y)
					 (stream x-offset y-offset position-transform))
		   (send window :draw-line last-x last-y x y :flip nil)
		   (vector-push-extend x points)
		   (vector-push-extend y points)
		   (setq last-x x last-y y))
		  (:release-mouse () (return nil))))
	    (tv:prepare-sheet (window)
	      (setq last-x (aref points 0)
		    last-y (aref points 1))
	      (loop for i from 2 below (fill-pointer points) by 2 do
		(let ((x (aref points i))
		      (y (aref points (1+ i))))
		  (send window :draw-line last-x last-y x y :flip nil)
		  (setq last-x x last-y y))))))
	(let* ((length (fill-pointer points))
	       (result (make-array length)))
	  (when ( length 2)
	    (dw:command-error "Curve must have more than one point"))
	  (loop for i below length by 2 do
	    (let ((x (- (aref points i) x-offset))
		  (y (- (aref points (1+ i)) y-offset)))
	      (multiple-value-setq (x y)
		(graphics:stream-untransform-point x y window))
	      (setf (aref result i) x)
	      (setf (aref result (1+ i)) y)))
	  result)))))

(defparameter *mouse-input-lines-mouse-clicks*
	      '((#\mouse-left :add-point)
		(#\shift-mouse-left :add-final-point)
		(#\mouse-middle :add-existing-point)
		(#\shift-mouse-middle :add-final-existing-point)
		(#\mouse-right :done)
		(#\control-mouse-left :add-grid-point)
		(#\control-shift-mouse-left :add-final-grid-point)))
(defparameter *mouse-input-lines-mouse-documentation*
  "L: Add point; sh-L: Add point and finish; M: Add existing point; sh-M: Add existing and finish; R: Finish without.  Abort aborts.")

(defun classify-mouse-input-lines-click (mouse-char)
  (declare (values valid-p done-p gravity))
  (let ((type (second (assoc mouse-char *mouse-input-lines-mouse-clicks*))))
    (when type
      (values t
	      (case type
		(:done :done)
		((:add-final-point :add-final-existing-point :add-final-grid-point) t))
	      (case type
		((:add-existing-point :add-final-existing-point) :existing)
		((:add-grid-point :add-final-grid-point) :grid))))))

(defparameter *nearby-existing-point-threshold* 64)	;Within 8 pixels

(defun nearby-existing-point (points x y)
  (let ((best-x nil)
	(best-y nil)
	(best-distance *nearby-existing-point-threshold*))
    (graphics:map-points #'(lambda (existing-x existing-y &optional ignore)
			     (let ((distance (+ (expt (- existing-x x) 2)
						(expt (- existing-y y) 2))))
			       (when (< distance best-distance)
				 (setq best-x existing-x best-y existing-y
				       best-distance distance))))
			 points)
    ;; We return the last point in the sequence that's as close as any other.
    (values best-x best-y)))

(defun mouse-input-lines (&rest args
			  &key (stream *standard-output*)
			       (start-x nil) (start-y nil) (while-held t)
			       (position-transform
				 (graphics:stream-transform stream))
			  &allow-other-keys)
  (ignore while-held)
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (multiple-value-bind (last-x last-y)
	(if (not (and start-x start-y))
	    (call-with-mouse-blinker-options #'mouse-input-point-internal 
					     window "Pick starting point"
					     :who-line-documentation-string
 "L: Put first point here; M: Abort.  Abort also aborts."
					     args)
	    (graphics:transform-window-points stream start-x start-y)
	    (values start-x start-y))
      (sys:with-stack-array (points 100 :fill-pointer 0)
	(vector-push-extend last-x points)
	(vector-push-extend last-y points)
	(with-special-mouse-blinker* (window args)
				     (quantize-position show-new-position)
	  (dw:with-output-recording-disabled (window)
	    (let ((drawn-x nil) (drawn-y nil))
	      (unwind-protect
		  (dw:tracking-mouse (window :whostate "Pick next point"
					     :who-line-documentation-string
					     *mouse-input-lines-mouse-documentation*)
		    (:mouse-motion (x y)
		     (quantize-position x y stream x-offset y-offset position-transform)
		     (do-show-new-position (show-new-position x y)
					   (stream x-offset y-offset position-transform))
		     (when drawn-x
		       (send window :draw-line last-x last-y drawn-x drawn-y :flip nil))
		     (send window :draw-line last-x last-y x y :flip nil)
		     (setq drawn-x x drawn-y y))
		    (:mouse-click (click x y)
		     (multiple-value-bind (valid-p done-p gravity)
			 (classify-mouse-input-lines-click click)
		       (quantize-position x y stream x-offset y-offset position-transform
					  (if (eq gravity :grid) :force-grid
					      .quantize-position.))
		       (block handled
			 (unless valid-p
			   (return-from handled nil))
			 (when (eq done-p :done)
			   (return t))
			 (when (eq gravity :existing)
			   (multiple-value-setq (x y)
			     (nearby-existing-point points x y))
			   (unless (and x y) (beep) (return-from handled nil)))
			 (unless (and (eql x drawn-x) (eql y drawn-y))
			   (when drawn-x
			     (send window :draw-line last-x last-y drawn-x drawn-y
				   :flip nil))
			   (send window :draw-line last-x last-y x y :flip nil))
			 (vector-push-extend x points)
			 (vector-push-extend y points)
			 (setq drawn-x nil)
			 (when done-p
			   (return t))
			 (setq last-x x last-y y)))))
		(tv:prepare-sheet (window)
		  (when drawn-x
		    (send window :draw-line last-x last-y drawn-x drawn-y :flip nil))
		  (setq last-x (aref points 0)
			last-y (aref points 1))
		  (loop for i from 2 below (fill-pointer points) by 2 do
		    (let ((x (aref points i))
			  (y (aref points (1+ i))))
		      (send window :draw-line last-x last-y x y :flip nil)
		      (setq last-x x last-y y))))))))
	(let* ((length (fill-pointer points))
	       (result (make-array length)))
	  (when ( length 2)
	    (dw:command-error "Curve must have more than one point"))
	  (loop for i below length by 2 do
	    (let ((x (- (aref points i) x-offset))
		  (y (- (aref points (1+ i)) y-offset)))
	      (multiple-value-setq (x y)
		(graphics:stream-untransform-point x y window))
	      (setf (aref result i) x)
	      (setf (aref result (1+ i)) y)))
	  result)))))

(defun mouse-input-rectilinear-lines (&rest args
				      &key (stream *standard-output*)
					   (start-x nil) (start-y nil) (while-held t)
					   (position-transform
					     (graphics:stream-transform stream))
				      &allow-other-keys)
  (ignore while-held)
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (multiple-value-bind (last-x last-y)
	(if (not (and start-x start-y))
	    (call-with-mouse-blinker-options #'mouse-input-point-internal 
					     window "Pick starting point" 
					     :who-line-documentation-string
 "L: Put first point here; M: Abort.  Abort also aborts."
					     args)
	  (graphics:transform-window-points stream start-x start-y)
	  (values start-x start-y))
      (sys:with-stack-array (points 100 :fill-pointer 0)
	(vector-push-extend last-x points)
	(vector-push-extend last-y points)
	(with-special-mouse-blinker* (window args)
				     (quantize-position show-new-position)
	  (dw:with-output-recording-disabled (window)
	    (let ((drawn-x nil) (drawn-y nil)
		  (direction :unknown))
	      (unwind-protect
		  (flet ((restrict-line-direction (x y)
			   (declare (values x y direction))
			   (let ((this-direction direction))
			     (when (eq this-direction :unknown)
			       (setq this-direction (if (> (abs (- y last-y))
							   (abs (- x last-x)))
							:vertical :horizontal)))
			     (if (eq this-direction :vertical)
				 (values last-x y this-direction)
				 (values x last-y this-direction)))))
		    (dw:tracking-mouse (window :whostate "Pick next point"
					       :who-line-documentation-string
					       *mouse-input-lines-mouse-documentation*)
		      (:mouse-motion (x y)
		       (quantize-position x y stream x-offset y-offset position-transform)
		       (when drawn-x
			 (send window :draw-line last-x last-y drawn-x drawn-y :flip
			       nil))
		       (multiple-value-setq (x y)
			 (restrict-line-direction x y))
		       (do-show-new-position (show-new-position x y)
					     (stream x-offset y-offset position-transform))
		       (send window :draw-line last-x last-y x y :flip nil)
		       (setq drawn-x x drawn-y y))
		      (:mouse-click (click x y)
		       (multiple-value-bind (valid-p done-p gravity)
			   (classify-mouse-input-lines-click click)
			 (quantize-position x y stream x-offset y-offset position-transform
					    (if (eq gravity :grid) :force-grid
						.quantize-position.))
			 (block handled
			   (unless valid-p
			     (return-from handled nil))
			   (when (eq done-p :done)
			     (return t))
			   (when (eq gravity :existing)
			     (multiple-value-setq (x y)
			       (nearby-existing-point points x y))
			     (unless (and x y) (beep) (return-from handled nil)))
			   (multiple-value-setq (x y direction)
			     (restrict-line-direction x y))
			   (unless (and (eql x drawn-x) (eql y drawn-y))
			     (when drawn-x
			       (send window :draw-line last-x last-y drawn-x drawn-y
				     :flip nil))
			     (send window :draw-line last-x last-y x y :flip nil))
			   (vector-push-extend x points)
			   (vector-push-extend y points)
			   (setq drawn-x nil)
			   (when done-p
			     (return t))
			   (setq direction (if (eq direction :vertical) :horizontal :vertical))
			   (setq last-x x last-y y))))))
		(tv:prepare-sheet (window)
		  (when drawn-x
		    (send window :draw-line last-x last-y drawn-x drawn-y
			  :flip nil))
		  (setq last-x (aref points 0)
			last-y (aref points 1))
		  (loop for i from 2 below (fill-pointer points) by 2 do
		    (let ((x (aref points i))
			  (y (aref points (1+ i))))
		      (send window :draw-line last-x last-y x y :flip nil)
		      (setq last-x x last-y y))))))))
	(let* ((length (fill-pointer points))
	       (result (make-array length)))
	  (when ( length 2)
	    (dw:command-error "Curve must have more than one point"))
	  (loop for i below length by 2 do
	    (let ((x (- (aref points i) x-offset))
		  (y (- (aref points (1+ i)) y-offset)))
	      (multiple-value-setq (x y)
		(graphics:stream-untransform-point x y window))
	      (setf (aref result i) x)
	      (setf (aref result (1+ i)) y)))
	  result)))))

(defun mouse-input-points (&rest args
			   &key (stream *standard-output*)
				(start-x nil) (start-y nil) (while-held t)
				(position-transform
				  (graphics:stream-transform stream))
			   &allow-other-keys)
  (ignore while-held)
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (sys:with-stack-array (points 100 :fill-pointer 0)
      (flet ((highlight-point (x y &optional ignore)
	       ;; Lazy icon
	       (send window :draw-glyph (sys:char-subindex #\x) fonts:tvfont
					(- x 3) (- y 4) :flip)))
	(when (and start-x start-y)
	  (graphics:transform-window-points stream start-x start-y)
	  (vector-push-extend start-x points)
	  (vector-push-extend start-y points)
	  (highlight-point start-x start-y))
	(with-special-mouse-blinker* (window args)
				     (quantize-position show-new-position)
	  (dw:with-output-recording-disabled (window)
	    (unwind-protect
		(dw:tracking-mouse (window :whostate "Pick next point"
					   :who-line-documentation-string
					   *mouse-input-lines-mouse-documentation*)
		  (:mouse-motion (x y)
		   (quantize-position x y stream x-offset y-offset position-transform)
		   (do-show-new-position (show-new-position x y)
					 (stream x-offset y-offset position-transform)))
		  (:mouse-click (click x y)
		   (multiple-value-bind (valid-p done-p gravity)
		       (classify-mouse-input-lines-click click)
		     (quantize-position x y stream x-offset y-offset position-transform
					(if (eq gravity :grid) :force-grid
					    .quantize-position.))
		     (block handled
		       (unless valid-p
			 (return-from handled nil))
		       (when (eq done-p :done)
			 (return t))
		       (when (eq gravity :existing)
			 (multiple-value-setq (x y)
			   (nearby-existing-point points x y))
			 (unless (and x y) (beep) (return-from handled nil)))
		       (vector-push-extend x points)
		       (vector-push-extend y points)
		       (highlight-point x y)
		       (when done-p
			 (return))))))
	      (tv:prepare-sheet (window)
		(graphics:map-points #'highlight-point points)))
	    (let* ((length (fill-pointer points))
		   (result (make-array length)))
	      (when ( length 2)
		(dw:command-error "Curve must have more than one point"))
	      (loop for i below length by 2 do
		(let ((x (- (aref points i) x-offset))
		      (y (- (aref points (1+ i)) y-offset)))
		  (multiple-value-setq (x y)
		    (graphics:stream-untransform-point x y window))
		  (setf (aref result i) x)
		  (setf (aref result (1+ i)) y)))
	      result)))))))

(defun mouse-position-text (string &rest args
				   &key (character-style nil)
					(sizing :normal) (input-second-point t)
					(stream *standard-output*)
					(start-x nil) (start-y nil) (while-held nil)
				   &allow-other-keys)
  (declare (values x y to-x to-y)
	   (ignore while-held))
  (when (member sizing '(:unscaled-one-point :scaled-one-point))
    (setq input-second-point nil))
  (multiple-value-bind (x y click)
      (if start-x
	  (values start-x start-y #\Mouse-L)
	  (dragging-output-with-mouse* (stream :whostate (if (not input-second-point)
							     "Position text with mouse"
							     "Text left and hold")
					       :who-line-documentation-string
					        (if (not input-second-point)
  "L: Put text down here; M: Abort.  Abort also aborts."
  "L: Put left of text here (and hold); M: Abort.  Abort also aborts.")
					       :translate-output t :warp-mouse nil
					       args)
	    (graphics:with-graphics-identity-transform (stream)
	      (graphics:with-graphics-scale (stream 1 -1)
		(graphic-input:draw-sized-string string 0 0 :character-style character-style
						 :stream stream)))))
    (unless (eql click #\Mouse-left)
      (signal 'sys:abort))
    (macrolet ((get-other-point ((window window-x window-y to-x to-y) draw &body body)
		 `(multiple-value-bind (,window x-offset y-offset)
		      (send stream :window-and-offsets)
		    (let (,to-x ,to-y)
		      (multiple-value-bind (,window-x ,window-y)
			  (graphics:stream-transform-point x y stream)
			(setq ,window-x (round (+ ,window-x x-offset))
			      ,window-y (round (+ ,window-y y-offset)))
			(when input-second-point
			  (multiple-value-setq (,to-x ,to-y)
			    (mouse-inputting-point* (,window ,to-x ,to-y
						     :whostate "Stretching text"
						     :who-line-documentation-string
   "Release at other end of text.  Abort aborts."
						     :while-held t
						     :if-null :return
						     :x-offset x-offset
						     :y-offset y-offset
						     :original-stream stream
						     args)
				,draw
			      (values ,to-x ,to-y))))
			;; If you click and don't hold, make reasonably instead of
			;; all squished.
			(unless ,to-x
			  (setq ,to-x (+ ,window-x (graphics:transform-distance 
						     (multi-line-string-size
						       string
						       :character-style character-style
						       :stream ,window)
						     0 (graphics:stream-transform window)))
				,to-y ,window-y)))
		      (graphics:untransform-window-points stream ,to-x ,to-y)
		      . ,body))))
    (ecase sizing
      ((:unscaled-one-point :scaled-one-point)
	(values x y))
      ((:unscaled-tilted :unscaled-stretched :unscaled-tilted-and-stretched)
       (get-other-point (window window-x window-y to-x to-y) 
           (graphics:draw-string string window-x window-y
				 :character-style character-style
				 :stretch-p (member sizing
						    '(:unscaled-stretched
						      :unscaled-tilted-and-stretched))
				 :toward-x to-x
				 :toward-y (if (member sizing
						       '(:unscaled-tilted
							 :unscaled-tilted-and-stretched))
					       to-y window-y)
				 :stream window :alu :flip)
         (unless (member sizing '(:unscaled-tilted :unscaled-tilted-and-stretched))
	   (setq to-y y))
	 (values x y to-x to-y)))
      ((:scaled-tilted :scaled-stretched :scaled-tilted-and-stretched)
       (get-other-point (window window-x window-y to-x to-y)
	   (let ((x to-x) (y to-y))
	     (case sizing
	       (:scaled-tilted-and-stretched )
	       (:scaled-stretched (setq y window-y))
	       (:scaled-tilted
		 (let* ((dx (- to-x window-x))
			(dy (- to-y window-y))
			(length (sqrt (+ (expt dx 2) (expt dy 2))))
			(width (graphics:transform-distance 
				 (send window :draw-string-size string character-style)
				 0 (graphics:stream-transform window))))
		   (when (zerop length)
		     (setq dx 1 dy 0 length 1))
		   (setq x (+ window-x (/ (* dx width) length))
			 y (+ window-y (/ (* dy width) length))))))
	     (draw-scaled-string-image string window-x window-y x y
				       :character-style character-style
				       :scale-y -1
				       :stream window :alu :flip))
	 (values x y to-x to-y)))))))

(defun mouse-position-image (image &rest args
				   &key (scale-x 1) (scale-y 1)
					(image-left 0) (image-top 0) image-right image-bottom
					(stream *standard-output*)
				   &allow-other-keys)
  (declare (values x y))
  (dragging-output-with-mouse* (stream :whostate "Positioning image"
				       :who-line-documentation-string
 "L: Put down image here; M: Abort.  Abort also aborts."
				       :translate-output t :warp-mouse nil
				       args)
    (graphics:with-graphics-identity-transform (stream)
      (graphics:draw-image image 0 0
			   :image-left image-left :image-top image-top
			   :image-right image-right :image-bottom image-bottom
			   :scale-x scale-x :scale-y scale-y :stream stream))))

(defun mouse-input-multiple-point-transform (&rest args
					     &key (stream *standard-output*)
						  (number-of-points 4)
					     &allow-other-keys)
  (let ((points
	  (let ((window (send stream :window-and-offsets)))
	    (dw:with-output-recording-disabled (window)
	      (ecase number-of-points
		(2
		 (multiple-value-bind (from-x from-y to-x to-y)
		     (call-with-mouse-blinker-options #'mouse-input-line-internal 
						      window
						      "From position and hold" "To position"
						      :first-who-line-documentation-string
 "L: Put starting end of translation vector here (and hold); M: Abort.  Abort also aborts."
						      :second-who-line-documentation-string
 "Release at other end of translation vector.  Abort aborts."
						      :while-held t
						      args)
		   (graphics:untransform-window-points stream from-x from-y to-x to-y)
		   (list from-x from-y to-x to-y)))
		(4
		 (multiple-value-bind (from-x1 from-y1 from-x2 from-y2)
		     (call-with-mouse-blinker-options #'mouse-input-line-internal 
						      window
						      "First point of from vector"
						      "Second point of from vector"
						      :first-who-line-documentation-string
  "L: Put starting end of original vector image here; M: Abort.  Abort also aborts."
						      :second-who-line-documentation-string
  "Release at other end of original vector image.  Abort aborts."
						      :while-held t
						      args)
		   (when (and (= from-x1 from-x2) (= from-y1 from-y2))
		     (dw:command-error "Length must not be zero"))
		   (graphics:untransform-window-points stream from-x1 from-y1
							      from-x2 from-y2)
		   (multiple-value-bind (to-x1 to-y1 to-x2 to-y2)
		       (unwind-protect
			   (progn
			     (graphics:draw-line from-x1 from-y1 from-x2 from-y2
						 :stream stream :dashed t :alu :flip)
			     (multiple-value-bind (to-x1 to-y1 to-x2 to-y2)
				 (call-with-mouse-blinker-options #'mouse-input-line-internal
				   window
				   "First point of to vector"
				   "Second point of to vector"
				   :first-who-line-documentation-string
 "L: Put starting end of scaled and rotated vector image here; M: Abort.  Abort also aborts."
				   :second-who-line-documentation-string
 "Release at other end of scaled and rotated vector image.  Abort aborts."
				   :while-held t
				   args)
			       (when (and (= to-x1 to-x2) (= to-y1 to-y2))
				 (dw:command-error "Length must not be zero"))
			       (graphics:untransform-window-points stream to-x1 to-y1
									  to-x2 to-y2)
			       (values to-x1 to-y1 to-x2 to-y2)))
			 (graphics:draw-line from-x1 from-y1 from-x2 from-y2
					     :stream stream :dashed t :alu :flip))
		     (list from-x1 from-y1 from-x2 from-y2 to-x1 to-y1 to-x2 to-y2))))
		(6
		 (format *query-io* "
Enter two triangles.  
Transform will be the one that takes the first triangle and transforms into the second.")
		 (multiple-value-bind (from-x1 from-y1 from-x2 from-y2 from-x3 from-y3)
		     (call-with-mouse-blinker-options #'mouse-input-triangle 
						      :stream stream args)
		   (when (triangle-colinear-p from-x1 from-y1 from-x2 from-y2 from-x3 from-y3)
		     (dw:command-error "Triangle must be well formed"))
		   (multiple-value-bind (to-x1 to-y1 to-x2 to-y2 to-x3 to-y3)
		       (unwind-protect
			   (progn
			     (graphics:draw-triangle from-x1 from-y1 from-x2 from-y2
						     from-x3 from-y3
						     :filled nil :dashed t
						     :stream stream :alu :flip)
			     (call-with-mouse-blinker-options #'mouse-input-triangle 
							      :stream stream args))
			 (graphics:draw-triangle from-x1 from-y1 from-x2 from-y2
						 from-x3 from-y3
						 :filled nil :dashed t
						 :stream stream :alu :flip))
		     (when (triangle-colinear-p to-x1 to-y1 to-x2 to-y2 to-x3 to-y3)
		       (dw:command-error "Triangle must be well formed"))
		     (list from-x1 from-y1 from-x2 from-y2 from-x3 from-y3
			   to-x1 to-y1 to-x2 to-y2 to-x3 to-y3)))))))))
    (graphics:build-multiple-point-transform points)))

;;;; Grid maintenance

(defun grid-redisplay-limits (pane scale)
  (multiple-value-bind (left top right bottom)
      (send pane :visible-cursorpos-limits)
    (values (floor left scale)
	    (floor top scale)
	    (ceiling right scale)
	    (ceiling bottom scale))))

;;; Use a pattern mask for a zillion times faster drawing than individual points.
(defvar *scale-grids* (make-hash-table :test '= 
				       ;; The code that uses this ensures that this
				       ;; won't be used with keys that are = but
				       ;; have different types.  Therefore xeqlhash
				       ;; is adequate.
				       :hash-function 'cli::xeqlhash))

(defstruct (scale-grid :named-array-leader
		       (:constructor-make-array-keywords dimensions
							 ;---
							 #+fixed (element-type 'bit)
							 #-fixed (type 'sys:art-1b)))
  (scale 1))

(defun normalize-grid-scale (scale)
  (unless (integerp scale)
    (let ((iscale (round (* scale 1000))))
      (multiple-value-bind (nscale diff)
	  (floor iscale 1000)
	(setq scale (if (zerop diff) nscale (/ iscale 1000.0))))))
  ;;Can't have more than one mark per pixel.
  (setq scale (max 1 scale)))

(define-presentation-type grid-output ())

(defun draw-grid (stream scale &key (alu :flip) (x-phase 0) (y-phase 0))
  (multiple-value-bind (left top right bottom)
      (grid-redisplay-limits stream scale)
    (ignore left top)
    (setq scale (normalize-grid-scale scale))
    (let ((scale-grid (gethash scale *scale-grids*)))
      (when (null scale-grid)
	(setq scale-grid (make-scale-grid :scale scale
					  :dimensions (if (integerp scale)
							  (list 1 (lcm scale 32))
							  '(1 4000))))
	(loop with limit = (decode-raster-array scale-grid)
	      for x from 0 by scale
	      for rx = (round x)
	      until ( rx limit)
	      do
	  (setf (raster-aref scale-grid (round x) 0) 1))
	(setf (gethash scale *scale-grids*) scale-grid))
      (let* ((no-highlighting '(:lines nil :boxes nil))
	     (presentation (dw:with-output-as-presentation (:stream stream
							    :type 'grid-output
							    :highlighting-boxes
							     no-highlighting)
			     (tv:prepare-sheet (stream)
			       (loop for y below bottom do
				 (send stream :draw-1-bit-raster
				       (round (- (* right scale) x-phase)) 1
				       scale-grid 0 0
				       (round x-phase) (round (+ (* y scale) y-phase))
				       alu :noop))))))
	;; Make sure that nothing here will light up when the anonymous type commands
	;; are available.
	(dolist (inferior (dw:presentation-inferiors presentation))
	  (setf (dw:displayed-presentation-highlighting-boxes inferior) no-highlighting))
	presentation))))

;;; Bugger the window's history to have more background grid when scrolling.
(defun make-grid-large-enough (stream scale left top right bottom)
  (ignore left top)
  (setq scale (normalize-grid-scale scale))
  (setq right (ceiling (* scale (ceiling right scale)))
	bottom (ceiling (* scale (ceiling bottom scale))))
  (let ((scale-grid (gethash scale *scale-grids*))
	(bottom-found 0)
	(x-phase 0))
    (when scale-grid
      (send stream :map-over-overlapping-presentations
	    0 0 right bottom
	    #'(lambda (presentation)
		(typecase presentation
		  (dw::1-bit-raster-graphics-displayed-presentation
		    (let ((args (dw::graphics-displayed-presentation-arguments presentation)))
						;width height raster rx ry wx wy alu alu
		      (when (eq (third args) scale-grid)
			(maxf (first args) right)
			(maxf (dw:box-right (dw:presentation-displayed-box presentation))
			      right)
			(setq x-phase (sixth args))
			(maxf bottom-found (seventh args)))))))
	    :graphics t :presentations nil)
      (loop for y from (+ bottom-found scale) below bottom by scale do
	(send stream :draw-1-bit-raster right 1 scale-grid 0 0 x-phase (round y)
					:flip color:alu-noop))))
  (maxf (send stream :maximum-x-position) right)
  (maxf (send stream :maximum-y-position) bottom))

(define-presentation-type window-wakeup-synchronous-scroll ()
   :expander 'dw::window-wakeup)		;--- Export

(defun grid-scroll-position-function (window scale direction type position)
  (multiple-value-bind (left top)
      (send window :viewport-position)
    (multiple-value-bind (width height)
	(dw:box-size (send window :cursor-viewport))
      (labels ((round-correctly (old-value new-value)
		 (if scale
		     (* scale (funcall (if (> old-value new-value) #'floor #'ceiling)
				       new-value scale))
		     new-value))
	       (adjust-position (value size)
		 (ecase type
		   (:relative-jump (+ value (* (or scale 10) position)))
		   (:relative (round-correctly value (+ value position)))
		   (:absolute (round-correctly value position))
		   (:screenful (round-correctly value (+ value (* size position)))))))
	(let ((nleft left)
	      (ntop top))
	  (ecase direction
	    (:x (setq nleft (round (adjust-position nleft width))))
	    (:y (setq ntop (round (adjust-position ntop height)))))
	  ;; Trying to scroll past the beginning.  Inform the program of the request so
	  ;; it can do a move view.
	  (when (or (minusp nleft) (minusp ntop))
	    (send window :force-kbd-input (dw::make-presentation-blip	;--- Export
					    :presentation-type
					      'window-wakeup-synchronous-scroll
					    :object (list window nleft ntop)))
	    (setq nleft (max 0 nleft) ntop (max 0 ntop)))
	  (setq left nleft top ntop)))
      (when scale
	(make-grid-large-enough window scale left top (+ left width) (+ top height))))
    (values left top)))

;;;; Presentation types for some graphical drawing options.

(define-presentation-type gray-level ()
   :expander '((number 0 1))
   ;; This is necessary to keep from blowing out.
   :parser ((stream &key default)
	    (accept '((number 0 1)) :stream stream :prompt nil :default default))
   :printer ((level stream)
	     ;; What I'd really like is no leading zero, a decimal point, and at least
	     ;; two digits but otherwise as many as are necessary as free format would
	     ;; give.  I wonder how to specify that.
	     (format stream "~,0$" level)))

(define-presentation-type proper-gray-level ()
   :abbreviation-for '((and gray-level ((satisfies (lambda (x) (< 0 x 1))))))
   :description "a proper gray level (not 0 or 1)")

(defvar *sample-gray-levels* '(.75 .50 .33 .25 .12 .10 .09 .08 .06 .05))

(defun display-gray-level-menu (&key (stream *standard-output*)
				     (levels *sample-gray-levels*))
  (display-stipple-menu stream levels 'proper-gray-level :gray-level nil))

(defun display-stipple-menu (stream set presentation-type keyword other-drawing-keywords)
  (let ((sample-type `((dw:accept-values-sample :original-type ,presentation-type))))
    (formatting-item-list (stream :n-rows 1)
      (dolist (item set)
	(dw:with-output-as-presentation (:stream stream
					 :single-box t
					 :object item
					 :type sample-type)
	  (dw:with-output-as-presentation (:stream stream
					   :single-box t
					   :object item
					   :type presentation-type)
	    (formatting-cell (stream)
	      (multiple-value-bind (x y)
		  (send stream :read-cursorpos)
		(apply #'graphics:draw-rectangle x y (+ x 50) (+ y 50) :stream stream
		       keyword item other-drawing-keywords)
		(dw:with-output-truncation (stream)
		  (send stream :set-cursorpos nil (+ y 50)))
		(present item presentation-type :stream stream))))))))
  (terpri stream))

(define-presentation-type pattern-stipple ()
   :expander 'graphics:stipple-array
   :parser ((stream)
	    (dw:complete-from-sequence graphics:*pattern-stipple-arrays* stream
				       :name-key #'graphics:stipple-array-name))
   :printer ((stipple stream)
	     (write-string (graphics:stipple-array-name stipple) stream)))

(defun display-pattern-menu (&key (stream *standard-output*)
				  (stipples graphics:*pattern-stipple-arrays*))
  (display-stipple-menu stream stipples 'pattern-stipple :pattern nil))

(define-presentation-type line-thickness ()
   ;;:expander '((number (0)))
   :printer ((object stream) (prin1 object stream))
   :parser ((stream &key default)
	    (accept '((number (0))) :stream stream :prompt nil :default default)))

(defvar *sample-thicknesses* '(1 2 4 8))

(defun display-thickness-menu (&key (stream *standard-output*)
				    (thicknesses *sample-thicknesses*))
  (display-line-menu stream thicknesses 'line-thickness :thickness nil))

(define-presentation-type dash-pattern ()
   :expander '((sequence ((integer (0)))))
   :printer ((pattern stream)
	     ;; The inherited printer uses English conjunctions too often.
	     (format-textual-list pattern #'prin1 :stream stream)))

(defvar *sample-dashes* '(#(10 10) #(4 4) #(2 2) #(4 2) #(1 4)))

(defun display-dashes-menu (&key (stream *standard-output*)
				 (dashes *sample-dashes*))
  (display-line-menu stream dashes 'dash-pattern :dash-pattern '(:dashed t)))

(defun display-line-menu (stream set presentation-type keyword other-drawing-keywords)
  (let ((sample-type `((dw:accept-values-sample :original-type ,presentation-type))))
    (formatting-table (stream :multiple-columns t)
      (let ((baseline/2 (floor (send stream :baseline) 2)))
	(dolist (item set)
	  (dw:with-output-as-presentation (:stream stream
					   :single-box t
					   :object item
					   :type sample-type)
	    (dw:with-output-as-presentation (:stream stream
					     :single-box t
					     :object item
					     :type presentation-type)
	      (formatting-row (stream)
		(formatting-cell (stream)
		  (present item presentation-type :stream stream))
		(formatting-cell (stream)
		  (multiple-value-bind (x y)
		      (send stream :read-cursorpos)
		    (let ((y (+ y baseline/2)))
		      (apply #'graphics:draw-line x y (+ x 100) y :stream stream
			     keyword item other-drawing-keywords))
		    (send stream :set-cursorpos (+ x 100) y))))))))))
  (terpri stream))

(defvar *sample-colors* (map 'list #'color:name-color '(:red :blue :green
						        :cyan :yellow :magenta)))

(defun display-color-menu (&key (stream *standard-output*)
				(colors *sample-colors*))
  (display-stipple-menu stream colors 'color:color :color nil))
