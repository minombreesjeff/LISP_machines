;;; -*- Mode: LISP; Syntax: Common-LISP; Package: Graphic-editor; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;;+++
(define-interaction-style-option *default-entity-highlighting-mode* :outline
				 ((member :outline :bounding-box))
				 "Default highlighting")
(define-interaction-style-option *circular-arc-entry-mode* :end-points-bow
				 ((alist-member
				    :alist (("Center and two radii" . :center-radius)
					    ("Two endpoints and bow" . :end-points-bow)
					    )))
				 "Circular arc input")
(define-interaction-style-option *text-entry-mode* :read-line
				 ((alist-member :alist (("AVV menu" . :menu)
							("Line of text" . :read-line))))
				 "Text entry mode")
;;;+++

(defvar *entity-shape-alist* ())

(defstruct (entity-shape :list (:constructor make-entity-shape (keyword name flavor)))
  keyword
  name
  flavor)

(define-presentation-type entity-shape ()
   :choose-displayer ((stream object query-identifier &key original-type)
		      (dw:accept-values-choose-from-sequence
			stream *entity-shape-alist* object query-identifier
			:type original-type
			:key #'entity-shape-keyword))
   :parser ((stream)
	    (dw:complete-from-sequence *entity-shape-alist* stream
				       :name-key #'entity-shape-name
				       :value-key #'entity-shape-keyword))
   :printer ((object stream)
	     (write-string (entity-shape-keyword-name object) stream))
   :description "a shape")

(defun entity-shape-keyword-name (shape)
  (entity-shape-name (find shape *entity-shape-alist* :key #'entity-shape-keyword)))

(defun define-entity-internal (shape name flavor)
  (when (si:record-source-file-name shape 'define-entity)
    (pushnew (make-entity-shape shape name flavor) *entity-shape-alist*
	     :key #'entity-shape-keyword :replace t)))

(defun merge-plists (&rest lists)
  (let ((result nil))
    (dolist (list lists)
      (if (null result)
	  (setq result list)
	  (setq result (nconc (loop for (ind val) on list by 'cddr
				    when (eq (getf result ind 'not-present) 'not-present)
				      collect ind and collect val)
			      result))))
    result))

(flavor:define-simple-method-combination :property-list merge-plists t)

(defparameter *initial-outline-drawing-options* '(:opaque t))
(defparameter *initial-inside-drawing-options* '(:gray-level .25 :opaque t))

;; These can't be in the DEFFLAVOR because the SETF method won't get set up.
(defgeneric entity-own-option (entity keyword value)
  (:method-combination :case))
(defgeneric (setf entity-own-option) (entity keyword value)
  (:method-combination :case))

(defflavor graphic-entity
	((name nil)
	 (outline-drawing-options *initial-outline-drawing-options*)
	 (inside-drawing-options *initial-inside-drawing-options*)
	 (presentation nil)
	 (handles nil)
	 (bbox-handles nil)
	 (copy-of nil)
	 (presentation-data nil))
	()
  :initable-instance-variables
  :writable-instance-variables
  (:method-combination entity-variable-values-internal :property-list)
  (:method-combination entity-choose-own-option :case)
  (:default-init-plist :allow-other-keys t)	;Because of defaults.
  )

(defmethod (sys:print-self graphic-entity) (stream ignore ignore)
  (sys:printing-random-object (self stream :typep)
    (when name
      (write-string (string name) stream))))

(defprop define-entity "Graphical entity shape" si:definition-type-name)

(defmacro define-entity (shape variables &body options)
  (let ((flavor-name (fintern "~A-ENTITY" shape))
	(variable-names (loop for variable in variables
			      collect (if (atom variable) variable (first variable))))
	(abstract nil)
	(inherit-from '(graphic-entity))
	(name (string-capitalize-words shape))
	(points-to-transform nil) (transform nil)
	(input-function nil) (output-function nil)
	(sample-shape nil) (handles nil) (input-handle-motion nil) (move-handle nil)
	(outline-p t) (filled-p t) (own-options nil) (code nil))
    (dolist (option options)
      (ecase (first option)
	(:abstract (setq abstract (second option)))
	(:input-function (setq input-function (rest option)))
	(:output-function (setq output-function (rest option)))
	(:inherit-from (setq inherit-from (rest option)))
	(:name (setq name (second option)))
	(:points-to-transform (setq points-to-transform (rest option)))
	(:transform (setq transform (rest option)))
	(:sample-shape (setq sample-shape (rest option)))
	(:handles (setq handles (rest option)))
	(:input-handle-motion (setq input-handle-motion (rest option)))
	(:move-handle (setq move-handle (rest option)))
	(:outline-p (setq outline-p (second option)))
	(:filled-p (setq filled-p (second option)))
	(:own-options (setq own-options (rest option)))
	(:code (setq code (rest option)))
	))
    (when (and points-to-transform transform)
      (warn () "You cannot specify both :POINTS-TO-TRANSFORM and :TRANSFORM."))
    (flet ((make-variable-setter (form)
	     (if (equal variables variable-names)	;No optional
		 `(multiple-value-setq ,variables ,form)
		 (let ((temps (loop for variable in variable-names
				    collect (cons variable
						  (make-symbol (symbol-name variable))))))
		   `(multiple-value-call
		      #'(lambda ,(loop for (nil . temp) in temps
				       for variable in variables
				       with opt-p = nil
				       as this-opt-p = (not (atom variable))
				       when (and this-opt-p (not opt-p))
					 collect '&optional and do (setq opt-p t)
				       collect (if this-opt-p (sublis temps variable) temp))
			  . ,(loop for (variable . temp) in temps
				   collect `(setq ,variable ,temp)))
		      ,form)))))
      `(sys:local-declare ((sys:function-parent ,shape define-entity))
	 (defflavor ,flavor-name
		 ,(loop for variable in variables
			collect (if (and (consp variable)
					 (member (second variable) variables))
				    ;; Very special case for initialization across i.v.'s
				    (first variable)
				    variable))
		 ,inherit-from
	   (:initable-instance-variables . ,variable-names)
	   :writable-instance-variables)
	 ,(if abstract
	      `(si:record-source-file-name ',shape 'define-entity)
	      `(define-entity-internal ',shape ',name ',flavor-name))
	 (defmethod (entity-shape ,flavor-name) () ',shape)
	 (defmethod (entity-variable-values-internal ,flavor-name) ()
	   (list . ,(loop for variable in variable-names
			  collect (intern (symbol-name variable) "")
			  collect variable)))
	 ,(when input-function
	    `(defmethod (entity-input-internal ,flavor-name) 
	       . ,(if (and (atom (first input-function))
			   (null (rest input-function)))
		    `((&rest args)
		      ,(make-variable-setter `(apply #',(first input-function) args)))
		    input-function)))
	 ,(when output-function
	    `(defmethod (entity-output-internal ,flavor-name)
	       . ,(if (and (atom (first output-function))
			   (null (rest output-function)))
		      `((&rest args)
			(apply #',(first output-function) ,@variable-names args))
		      output-function)))
	 ,(cond (transform
		 `(defmethod (entity-transform-internal ,flavor-name) . ,transform))
		(points-to-transform
		 `(defmethod (entity-transform-internal ,flavor-name) (transform)
		    (transform-points transform . ,points-to-transform))))
	 ,(when (or sample-shape inherit-from)
	    `(defmethod (entity-set-sample-shape ,flavor-name) ()
	       . ,(when sample-shape
		    (list (make-variable-setter `(values . ,sample-shape))
			  t))))
	 ,(when handles
	    `(defmethod (entity-reset-handles ,flavor-name) ()
	       (setq handles (progn . ,handles))))
	 ,(when input-handle-motion
	    `(defmethod (entity-input-handle-motion ,flavor-name) . ,input-handle-motion))
	 ,(when move-handle
	    `(progn
	       (defmethod (entity-move-handle-internal ,flavor-name) . ,move-handle)
	       (defmethod (entity-can-move-handle ,flavor-name) (ignore) t)))
	 ,(unless (and (eq outline-p t) (eq filled-p t))
	    `(progn
	       (defmethod (entity-output-pieces ,flavor-name) ()
		 (values ,outline-p ,filled-p))
	       (defmethod (entity-merge-options ,flavor-name) ()
		 (single-draw-merge-options))))
	 ,@(loop for own-option in own-options collect
	     (destructuring-bind (variable type &optional (name (string-capitalize-words
								  variable)))
		own-option
	       (let ((keyword (intern (symbol-name variable) "")))
		 `(progn
		    (defmethod (entity-own-option ,flavor-name ,keyword) ()
		      (values ,variable `(,,type :prompt ,',name)))
		    (defmethod ((setf entity-own-option) ,flavor-name ,keyword) (.new-value.)
		      (setf ,variable .new-value.))))))
	 ,(when code
	    `(defmethod (entity-code-internal ,flavor-name) ()
	       . ,(if (and (atom (first code))
			   (null (rest code)))
		      (let ((form `(list ',(first code)
					 . ,(map 'list #'(lambda (x) `(list 'quote ,x))
						 variable-names))))
			`((basic-entity-code self ,form)))
		      code)))
	 (compile-flavor-methods ,flavor-name)
	 ))))

(defun (:property define-entity zwei:kill-definition) (shape)
  (flavor:remove-flavor (fintern "~A-ENTITY" shape))
  (setq *entity-shape-alist* (delete shape *entity-shape-alist*
				     :key #'entity-shape-keyword))
  )

(define-presentation-type graphic-entity-output ()
   :parser ((stream) (loop doing (dw:read-char-for-accept stream)))
   :printer ((object stream)
	     (if (null (graphic-entity-name object))
		 (dolist (entry *entity-shape-alist*)
		   (when (typep object (entity-shape-flavor entry))
		     (return (format stream "~A" (entity-shape-name entry)))))
		 (write-string (graphic-entity-name object) stream)))
   )

(defmethod (entity-presentation-type graphic-entity) () 'graphic-entity-output)

(defmethod (graphic-entity-graphics-priority graphic-entity) ()
  (or (and presentation (dw:graphics-displayed-presentation-priority presentation)) -1))

(defmethod (entity-shape graphic-entity) () nil)

(defmethod (entity-redraw graphic-entity) ()
  (when presentation
    (entity-erase self)
    (entity-output self)))

(defmethod (entity-erase graphic-entity) ()
  (when presentation
    (send *standard-output* :erase-displayed-presentation presentation)))

;;; By default, can have outline or filled, or both.  This restricts the possibilities
;;; for some shapes.  Also a little work is necessary to avoid talking about :filled when
;;; an output function only works one way (whether logically filled or not).
(defmethod (entity-output-pieces graphic-entity) ()
  (values t t))

(defun drawing-options-invisible-p (options)
  (or (null options)				;Not drawn,
      (= (getf options :gray-level 1) 0)))	;or drawn white.

(defmethod (entity-just-outline-p graphic-entity) ()
  (and (drawing-options-invisible-p inside-drawing-options)	;Inside white or clear.
       (= (getf outline-drawing-options :thickness 1) 1)))	;and outline not thick.

(defmethod (entity-outline-for-highlighting graphic-entity) ()
  (entity-outline self))

(defun entity-default-highlighting-boxes (entity)
  (ecase *default-entity-highlighting-mode*
    (:bounding-box (values nil t))
    (:outline
      (entity-outline-highlighting-boxes entity))))

(defun entity-outline-highlighting-boxes (entity)
  (unless (entity-just-outline-p entity)
    (dw:computing-outline-from-path (t :transform (graphics:stream-transform
						    *standard-output*))
      (entity-outline-for-highlighting entity))))

(defmethod (entity-highlighting-boxes graphic-entity) ()
  (entity-default-highlighting-boxes self))

(defmethod (entity-output graphic-entity) ()
  (multiple-value-bind (highlighting-boxes single-box)
      (entity-highlighting-boxes self)
    (setq presentation (dw:with-output-as-presentation (:object self
							:type (entity-presentation-type self)
							:highlighting-boxes highlighting-boxes
							:single-box single-box)
			 (entity-output-1 self)))))

(defmethod (entity-output-1 graphic-entity) ()
  (flet ((do-it ()
	   (multiple-value-bind (outline-p inside-p)
	       (entity-output-pieces self)
	     (cond ((and outline-p inside-p)
		    (when inside-drawing-options
		      (apply #'entity-output-internal self inside-drawing-options))
		    (when outline-drawing-options
		      (apply #'entity-output-internal self
			     :filled nil :scale-thickness t :scale-dashes t
			     outline-drawing-options)))
		   (inside-p
		    (apply #'entity-output-internal self inside-drawing-options))
		   (outline-p
		    (apply #'entity-output-internal self
			   :scale-thickness t :scale-dashes t
			   outline-drawing-options))))))
    (destructuring-bind (&key pobject ptype presentable)
	presentation-data
      (if (and presentable
	       D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; Not drawing to the graphic-editor drawing pane
0	       (let* ((stream (si:follow-syn-stream *standard-output*))
		      (superior (send-if-handles stream :superior)))
		 (or (not superior)
		     (neq (send-if-handles superior :pane-name stream) 'drawing))))
	  (dw:with-output-as-presentation (:object pobject
					   :type ptype
					   :single-box t)
	    (do-it))
	  (do-it)))))

(defmethod (entity-output-for-bounding-box graphic-entity) ()
  (entity-output-internal self))

(defmethod (entity-outline graphic-entity) ()
  (multiple-value-bind (outline-p inside-p)
      (entity-output-pieces self)
    (if (and outline-p inside-p)
	(entity-output-internal self :filled nil :alu :flip)
	(entity-output-internal self :alu :flip))))

(defmethod (entity-clear-inside graphic-entity) ()
  (multiple-value-bind (outline-p inside-p)
      (entity-output-pieces self)
    (ignore outline-p)
    (if (not inside-p)
	(entity-output-internal self :alu :erase :thickness 4)
	(entity-output-internal self :alu :erase))))

(defmethod (entity-output-for-sample graphic-entity) ()
  (multiple-value-bind (outline-p inside-p)
      (entity-output-pieces self)
    (if (and (or (not outline-p) (drawing-options-invisible-p outline-drawing-options))
	     (or (not inside-p) (drawing-options-invisible-p inside-drawing-options)))
	(if outline-p
	    (if inside-p
		(entity-output-internal self :filled nil)
		(entity-output-internal self))
	    (entity-output-internal self))
	(entity-output-1 self))))

(defmethod (entity-transform graphic-entity) (&rest args)
  (apply #'entity-transform-internal self args)
  (entity-reset-handles self))

(defmacro transform-points (transform &rest points)
  `(progn . ,(loop with opt-p = nil
		   while points
		   do (case (first points)
			(&optional
			  (setq opt-p t)
			  (pop points))
			(&rest
			  (pop points)
			  (return
			    (nconc forms
				   `((transform-point-set ,(pop points) ,transform))))))
		   collect (let ((x (pop points))
				 (y (pop points)))
			     (if opt-p
				 `(when (and ,x ,y)
				    (multiple-value-setq (,x ,y)
				      (graphics:transform-point ,x ,y ,transform)))
				 `(multiple-value-setq (,x ,y)
				    (graphics:transform-point ,x ,y ,transform))))
		     into forms
		   finally (return forms))))

(defun transform-point-set (points transform)
  (loop for i below (length points) by 2 do
    (let ((x (elt points i))
	  (y (elt points (1+ i))))
      (multiple-value-setq (x y)
	(graphics:transform-point x y transform))
      (setf (elt points i) x
	    (elt points (1+ i)) y))))

(defmethod (entity-reset-handles graphic-entity) ()
  (setq handles nil))

(defun accept-presentation-data (default &rest options)
  (destructuring-bind (&key (pobject nil)
			    (ptype nil)
			    &allow-other-keys)
      default
    (let ((command-table (if (eq (dw:presentation-type-name ptype) 'cp:command)
			     (dw:with-presentation-type-arguments (cp:command ptype)
			       cp:command-table)
			     (cp:find-command-table "User")))
	  ptype-name)
      (setq ptype-name (apply #'accept
			      `(null-or-type (alist-member
					       :alist ,graphics::*binary-encodable-ptypes*))
			       :default (dw:presentation-type-name ptype)
			       options)
	    ptype ptype-name)
      (when (eq ptype-name 'cp:command)
	(setq command-table (accept 'cp:command-table :default command-table))
	(setq ptype `((cp:command :command-table ,command-table))))
      (when ptype
	(setq pobject (accept ptype
			      :default (if (dw::ptypep pobject ptype)
					   pobject
					   (dw:presentation-type-default ptype))))))
    (list :pobject pobject
	  :ptype ptype
	  :presentable (dw::ptypep pobject ptype))))

(defmethod (entity-input graphic-entity) (&rest args)
  (apply #'entity-input-internal self args)
  (entity-reset-handles self)
  (destructuring-bind (&key ptype) presentation-data 
    (if ptype
	(setf presentation-data
	      (dw:accepting-values ()
		(accept-presentation-data presentation-data
					  :prompt "Presentation Type"))))))

(defmethod (entity-choose-own-option graphic-entity :presentation-data)
	   (type default &rest options)  
  (declare (ignore type))
  (apply #'accept-presentation-data default options))

(defmethod (entity-own-option graphic-entity :presentation-data) ()
  (values presentation-data '(t :prompt "Presentation type")))

(defmethod ((setf entity-own-option) graphic-entity :presentation-data) (new-value)
  (setf presentation-data new-value))

(defmethod (entity-code graphic-entity) ()
  (let ((code (entity-code-internal self)))
    (destructuring-bind (&key ptype pobject presentable)
	presentation-data
      (if presentable
	  (multiple-value-bind (object-generating-form type-generating-form)
	      (graphics::make-presentation-object-printable pobject ptype)
	    `(dw:with-output-as-presentation
		 (:object ,object-generating-form
		  :type ',type-generating-form
		  :single-box t)
	       ,@(if (eq (car code) 'progn)
		     (cdr code)
		     (list code))))
	  code)))) 

(defmethod (entity-set-sample-shape graphic-entity) () nil)

(defflavor entity-shape-sample
	(shape
	 entity
	 highlighting-mask highlighting-mask-left highlighting-mask-top)
	()
  :initable-instance-variables
  :writable-instance-variables
  (:constructor make-entity-shape-sample (shape entity)))

(defmethod (entity-set-sample-shape entity-shape-sample) ()
  (entity-set-sample-shape entity))

(defmethod (entity-shape-sample-edges entity-shape-sample) (stream transform)
  (multiple-value-bind (right bottom nil nil left top)
      (dw:continuation-output-size
	(lambda (*standard-output*)
	  (graphics:with-graphics-transform (t transform)
	    (entity-output-for-bounding-box entity)))
	stream)
    (values left top right bottom)))

(defmethod (entity-shape-sample-transform entity-shape-sample) (transform)
  (entity-transform-internal entity transform))

(defmethod (entity-shape-sample-draw entity-shape-sample) ()
  (let ((boxes (entity-highlighting-boxes entity)))
    (dw:with-output-as-presentation (:object shape
				     :type 'entity-shape
				     :highlighting-boxes boxes :single-box t
				     :allow-sensitive-inferiors nil)
      (entity-output-for-sample entity))))

;;; Don't use normal set-options method, since I'm not sure it's good to override the
;;; character style and rounded cornerness in the shapes menu.
(defmethod (entity-set-sample-own-options graphic-entity) (ignore) )

(defmethod (entity-shape-sample-reset-drawing-defaults entity-shape-sample)
	   (global-defaults outline-defaults inside-defaults)
  (entity-set-sample-own-options entity global-defaults)	;---?
  (entity-set-options entity nil outline-defaults inside-defaults)
  (entity-redraw entity))

(defmethod (entity-shape-sample-reset-highlighting-mask entity-shape-sample)
	   (stream transform left top width height)
  (ignore stream)
  (multiple-value-setq (highlighting-mask highlighting-mask-left highlighting-mask-top)
    ;; Don't say :for-stream stream here, since we want 1-bit images, not n-bit.
    ;; (See thing that draws them below.)
    (graphics:with-output-to-bitmap (bitmap-stream :graphics-transform transform)
      (graphics:transform-window-points bitmap-stream left top)
      (send bitmap-stream :draw-1-bit-raster (round width) (round height)
					     tv:hes-gray 0 0 left top)
      (let ((*standard-output* bitmap-stream))
	(entity-clear-inside entity)))))

(defmethod (entity-shape-sample-xor-highlighting entity-shape-sample) (window)
  (multiple-value-bind (width height)
      (decode-raster-array highlighting-mask)
    (send window :draw-1-bit-raster width height highlighting-mask 0 0
	  highlighting-mask-left highlighting-mask-top :flip :noop)))

(compile-flavor-methods entity-shape-sample)

(defun layout-entity-samples (stream samples transform-parameters)
  (declare (values samples transform-parameters))
  (multiple-value-bind (width height)
      (multiple-value-bind (left top right bottom)
	  (send stream :visible-cursorpos-limits)
	(values (- right left) (- bottom top)))
    (stack-let ((new-transform-parameters (list width height (list 1 0 0 -1 0 height))))
      (when (equal new-transform-parameters transform-parameters)
	;; Same shape window, can reuse samples
	(return-from layout-entity-samples
	  (values samples transform-parameters)))
      (setq transform-parameters (copy-tree new-transform-parameters)))
    (when (null samples)
      (dolist (entry *entity-shape-alist*)
	(push (let ((name (entity-shape-keyword entry)))
		(make-entity-shape-sample name (make-instance (entity-shape-flavor entry)
							      :name name)))
	      samples)))
    (setq samples (delete-if-not #'entity-set-sample-shape samples))
    (let* ((window-transform (third transform-parameters))
	   (n-columns (max 1 (floor width 100)))
	   (cell-width (floor width n-columns))
	   (max-cell-height (floor height (ceiling (length samples) n-columns)))
	   (shape-margin 10))
      (stack-let ((row-samples (make-array n-columns))
		  (row-scales (make-array n-columns))
		  (row-widths (make-array n-columns))
		  (row-heights (make-array n-columns)))
	(let ((cell-top height)
	      (column-index 0))
	  (flet ((output-row ()
		   (let* ((max-height (loop for i below column-index
					    maximize (aref row-heights i)))
			  (center-y (- cell-top (floor max-height 2))))
		     (dotimes (i column-index)
		       (let ((sample (aref row-samples i)))
			 (let* ((center-x (+ (* i cell-width) (floor cell-width 2)))
				(cell-left (- center-x (floor (aref row-widths i) 2)))
				(cell-bottom (- center-y (ceiling (aref row-heights i) 2)))
				(scale (aref row-scales i)))
			   (stack-let ((cell-transform (list scale 0 0 scale
							     cell-left cell-bottom)))
			     (entity-shape-sample-transform sample cell-transform)))
			 (entity-shape-sample-reset-highlighting-mask sample stream
								      window-transform
								      (* i cell-width)
								      cell-top
								      cell-width
								      (+ max-height
									 shape-margin))))
		     (decf cell-top (+ max-height shape-margin))
		     (setq column-index 0))))
	    ;; Remember that entity shape output is done in the primary Cartesian quadrant,
	    ;; but the sizing stream looks like a window.
	    (dolist (sample samples)
	      (setf (aref row-samples column-index) sample)
	      (let ((nominal-scale 100.0))
		(stack-let ((nominal-transform (list nominal-scale 0 0 (- nominal-scale)
						     0 1000)))
		  (multiple-value-bind (left top right bottom)
		      (entity-shape-sample-edges sample stream nominal-transform)
		    (multiple-value-setq (left top)
		      (graphics:untransform-point left top nominal-transform))
		    (multiple-value-setq (right bottom)
		      (graphics:untransform-point right bottom nominal-transform))
		    ;; Most sample shapes should have a corner at 0,0.  Correct if not.
		    (unless (and (zerop left) (zerop bottom))
		      (stack-let ((align-transform (list 1 0 0 1 (- left) (- bottom))))
			(entity-shape-sample-transform sample align-transform)))
		    (let* ((width (- right left))
			   (height (- top bottom))
			   (scale (min (floor (- cell-width shape-margin) width)
				       (floor (- max-cell-height shape-margin) height))))
		      (setf (aref row-scales column-index) scale
			    (aref row-widths column-index) (* width scale)
			    (aref row-heights column-index) (* height scale))))))
	      (incf column-index)
	      (when (zerop (mod column-index n-columns))
		(output-row)))
	    (when (plusp column-index)
	      (output-row)))))))
  (values samples transform-parameters))

(defmethod (entity-copy graphic-entity) ()
  (let* ((fl (sys:%instance-flavor self))
	 (new (make-instance (sys:%flavor-typename fl))))
    (flavor::%block-copy-allow-null self new (flavor::flavor-instance-size fl))
    (entity-copy-instance-variables new self)
    new))

;;; Here new instance makes own writable copies of instance variables, if any.
(defmethod (entity-copy-instance-variables graphic-entity) (old)
  (flet ((clone-entity-handles (handles)
	   (loop for old-h in handles
		 collect (make-entity-handle self
					     (entity-handle-key old-h)
					     (entity-handle-x-position old-h)
					     (entity-handle-y-position old-h)))))
    (setq copy-of old
	  presentation nil
	  handles (clone-entity-handles (graphic-entity-handles old))
	  bbox-handles (clone-entity-handles (graphic-entity-bbox-handles old)))))

(defmethod (entity-variable-values-internal graphic-entity) ()
  (list :name name
	:outline-drawing-options outline-drawing-options
	:inside-drawing-options inside-drawing-options))

(defmethod (entity-merge-options graphic-entity) () )

;;; This acts as a combination of inside and outline, so combine at first for the sake
;;; of not trying to gray or hollow the inside.
(defmethod (make-instance graphic-entity) (&rest ignore)
  (entity-merge-options self))

(defun-in-flavor (single-draw-merge-options graphic-entity) ()
  (setq inside-drawing-options (nconc (loop for both in '(:pattern :gray-level :color)
					    as out = (getf outline-drawing-options both)
					    and in = (getf inside-drawing-options both)
					    when (and out (eql out in))
					      collect both and collect in)
				      (loop for either in '(:opaque )
					    as out = (getf outline-drawing-options either)
					    and in = (getf inside-drawing-options either)
					    as value = (or out in)
					    when value
					      collect either and collect value))))

(defmethod (entity-own-option graphic-entity :otherwise) (ignore) 'no-such-value)

(defun entity-accept-values-own-options (entity keywords-and-values keywords-and-types)
  (loop for (keyword value) on keywords-and-values by 'cddr
	collect keyword
	collect (destructuring-bind (type . options) (getf keywords-and-types keyword)
		  (apply #'entity-choose-own-option entity keyword type value options))))

(defmethod (entity-choose-own-option graphic-entity :otherwise)
	   (ignore type default &rest options)
  (apply #'accept type :default default :provide-default t options))

(defmethod (entity-set-options graphic-entity) (own-options outline-options inside-options)
  (loop for (keyword value) on own-options by 'cddr
	;; When compiling without this system loaded first, this setf will generate a compiler
	;; warning.  I don't know how to instruct the flavor system to make the right setf
	;; form from the :method-combination option that defines it.
	do (setf (entity-own-option self keyword) value))
  (setq outline-drawing-options outline-options
	inside-drawing-options inside-options)
  (entity-merge-options self))

(defmethod (entity-save-options graphic-entity) (own-options)
  (list (loop for (keyword) on own-options by 'cddr
	      collect keyword
	      collect (entity-own-option self keyword))
	outline-drawing-options inside-drawing-options))

(defmethod (entity-possible-own-options graphic-entity) ()
  (reverse (entity-own-option self :which-operations)))

(defmethod (entity-possible-common-options graphic-entity) ()
  (remove :presentation-data (entity-possible-own-options self)))

(defmethod (grouped-entity-possible-common-options graphic-entity) ()
  '(:presentation-data))

(defun entities-common-options (entities)
  (let ((keywords (if (null (rest entities))
		      (entity-possible-own-options (first entities))
		      (reduce #'intersection
			      (map 'list #'entity-possible-common-options entities)))))
    (loop for keyword in keywords
	  with (value type)
	  do (multiple-value-setq (value type)
	       (entity-own-option (first entities) keyword))
	  collect keyword into plist collect value into plist
	  collect keyword into types collect type into types
	  finally (return (values plist types)))))

(defun compute-entities-alignment (entities phase x-alignment y-alignment)
  (let ((translation-alist (loop for entity in entities
				 collect (list entity 0 0))))
    (unless (eq x-alignment :none)
      (flet ((alignment-position (entity)
	       (ecase x-alignment
		 (:left (entity-bounding-box-edges entity))
		 (:center (entity-bounding-box-center entity))
		 (:right (multiple-value-bind (nil nil right nil)
			     (entity-bounding-box-edges entity)
			   right)))))
	(let ((average (/ (loop for entity in entities sum (alignment-position entity))
			  (length entities))))
	  (when phase
	    (setq average (* phase (round average phase))))
	  (loop for elem in translation-alist
		as (entity) = elem
		do (setf (second elem) (- average (alignment-position entity)))))))
    (unless (eq y-alignment :none)
      (flet ((alignment-position (entity)
	       (ecase y-alignment
		 (:top (multiple-value-bind (nil top nil nil)
			   (entity-bounding-box-edges entity)
			 top))
		 (:center (multiple-value-bind (nil y)
			      (entity-bounding-box-center entity)
			    y))
		 (:bottom (multiple-value-bind (nil nil nil bottom)
			      (entity-bounding-box-edges entity)
			    bottom)))))
	(let ((average (/ (loop for entity in entities sum (alignment-position entity))
			  (length entities))))
	  (when phase
	    (setq average (* phase (round average phase))))
	  (loop for elem in translation-alist
		as (entity) = elem
		do (setf (third elem) (- average (alignment-position entity)))))))
    translation-alist))

(defmethod (entity-bounding-box-edges graphic-entity) (&key (stream *standard-output*)
							    (force-computation nil))
  (multiple-value-bind (left top right bottom)
      (if (and presentation (not force-computation))
	  (dw:box-edges (dw:presentation-displayed-box presentation))
	  (multiple-value-bind (right bottom nil nil left top)
	      (dw:continuation-output-size
		(lambda (*standard-output*)
		  (replace (graphics:stream-transform *standard-output*)
			   (graphics:stream-transform stream))
		  (entity-output-for-bounding-box self))
		stream)
	    (unless left (setq left right))
	    (unless top (setq top bottom))
	    (values left top right bottom)))
    (graphics:untransform-window-points stream left top right bottom)
    (values (min left right) (max top bottom)
	    (max left right) (min top bottom))))

(defmethod (entity-bounding-box-center graphic-entity) (&rest args)
  (declare (arglist &key (stream *standard-output*)))
  (multiple-value-bind (left top right bottom)
      (apply #'entity-bounding-box-edges self args)
    (values (/ (+ left right) 2) (/ (+ top bottom) 2))))

(defun resequence-entities (entities)
  (map () #'(lambda (entity)
	      (send *standard-output* :reorder-graphics-displayed-presentation-priority
		    (graphic-entity-presentation entity)))
	 entities))

(defun redisplay-entities (entities)
  (send *standard-output* :redraw-inside-sets (entities-displayed-box entities)))

(defun entities-displayed-box (entities)
  (if (null (rest entities))
      (dw:presentation-displayed-box (graphic-entity-presentation (first entities)))
      (multiple-value-bind (left top right bottom)
	  (dw:box-edges
	    (dw:presentation-displayed-box
	      (graphic-entity-presentation (first entities))))
	(dolist (other (rest entities))
	  (multiple-value-bind (oleft otop oright obottom)
	      (dw:box-edges
		(dw:presentation-displayed-box
		  (graphic-entity-presentation other)))
	    (minf left oleft) (minf top otop)
	    (maxf right oright) (maxf bottom obottom)))
	(dw:make-temporary-box left top right bottom))))

(defun redraw-later-overlapping-entities (entities all-entities)
  (let* ((box (entities-displayed-box entities))
	 (lowest-index (loop for entity in entities
			     minimize (position entity all-entities :from-end t)))
	 (next-index (loop for other-entity being the array-elements of all-entities
			   using (index index) from (1+ lowest-index) do
		       (when (and (dw:boxes-overlap-p
				    (dw:presentation-displayed-box
				      (graphic-entity-presentation other-entity))
				    box)
				  (not (find other-entity entities)))
			 (return index)))))
    (when next-index
      (loop for other-entity being the array-elements of all-entities from next-index do
	(send *standard-output* :reorder-graphics-displayed-presentation-priority
	      (graphic-entity-presentation other-entity)))
      (send *standard-output* :redraw-inside-sets box))))

(defun entity-position-offsets (graphic-entity other-entity)
  (multiple-value-bind (left1 top1)
      (entity-bounding-box-edges graphic-entity)
    (multiple-value-bind (left2 top2)
	(entity-bounding-box-edges other-entity)
      (values (- left2 left1) (- top2 top1)))))

(defun basic-entity-code (entity template)
  (basic-entity-code-1 entity #'(lambda (&rest args) (append template args))))

(defmethod (basic-entity-code-1 graphic-entity) (template-function)
  (flet ((call-template-function (&rest args &key (filled t) (opaque t) &allow-other-keys)
	   (when filled
	     (setq args (si:rem-keywords args '(:filled))))
	   (when opaque
	     (setq args (si:rem-keywords args '(:opaque))))
	   (let ((form (apply template-function args)))
	     (loop for form in form
		   collect (cond ((and (consp form)
				       (eq (first form) 'quote)
				       (atom (second form)) (constantp (second form)))
				  (second form))
				 ((typep form 'graphics:stipple-array)
				  (let ((symbol (graphics:find-stipple-named form)))
				    (or symbol form)))
				 ((typep form 'color:color)
				  `',(multiple-value-list (color:color-rgb form)))
				 (t form))))))
  (multiple-value-bind (outline-p inside-p)
      (entity-output-pieces self)
    (cond ((and outline-p outline-drawing-options
		inside-p inside-drawing-options)
	   `(progn
	      ,(apply #'call-template-function inside-drawing-options)
	      ,(apply #'call-template-function :filled nil outline-drawing-options)))
	  ((and inside-p inside-drawing-options)
	   (apply #'call-template-function inside-drawing-options))
	  ((and outline-p outline-drawing-options)
	   (when inside-p
	     ;; If both are possible for this shape, need to say filled nil explicitly.
	     ;; Otherwise, say nothing, since filled might not be an option.
	     (setq outline-drawing-options `(:filled nil . ,outline-drawing-options)))
	   (apply #'call-template-function outline-drawing-options))))))


(defvar *global-entity-option-set-parsers* nil)

(defprop define-global-entity-option-set "Entity global option set" si:definition-type-name)

(defmacro define-global-entity-option-set (name arglist &body body)
  (let ((function-name (fintern "~A-OPTION-PARSER" name)))
    `(progn
       (defun ,function-name ,arglist
	 (declare (sys:function-parent name define-global-entity-option-set))
	 . ,body)
       (add-global-entity-option-set ',function-name))))

(defun add-global-entity-option-set (function)
  (unless (member function *global-entity-option-set-parsers*)
    (setq *global-entity-option-set-parsers*
	  (nconc *global-entity-option-set-parsers* (ncons function)))))

(defun collect-initial-global-entity-option-set ()
  (let ((options nil))
    (dw:accept-values-for-defaults
      #'(lambda (stream)
	  (dolist (function *global-entity-option-set-parsers*)
	    (setq options (nconc options
				 (funcall function nil stream))))))
    options))

(defun edit-global-entity-option-set (options &optional (stream *query-io*))
  (let ((new-options nil))
    (dolist (function *global-entity-option-set-parsers*)
      (setq new-options (nconc new-options (funcall function options stream))))
    new-options))

(defflavor entity-handle
	(entity
	 key
	 x-position
	 y-position
	 (presentation nil))
	()
  :readable-instance-variables
  (:initable-instance-variables entity key x-position y-position)
  (:constructor make-entity-handle (entity key x-position y-position)))

(defmethod (sys:print-self entity-handle) (stream ignore ignore)
  (sys:printing-random-object (self stream :typep)
    (format stream "~A ~S" (graphic-entity-name entity) key)))

(defmethod (entity-handle-position entity-handle) ()
  (values x-position y-position))

(defvar *selected-handle-image* (make-raster-array 32 6 :element-type 'bit
				 :initial-contents  '(#*11111100000000000000000000000000
						      #*11111100000000000000000000000000
						      #*11001100000000000000000000000000
						      #*11001100000000000000000000000000
						      #*11111100000000000000000000000000
						      #*11111100000000000000000000000000)))

(defvar *unselected-handle-image* (make-raster-array 32 6 :element-type 'bit
				    :initial-contents  '(#*11111100000000000000000000000000
							 #*10000100000000000000000000000000
							 #*10000100000000000000000000000000
							 #*10000100000000000000000000000000
							 #*10000100000000000000000000000000
							 #*11111100000000000000000000000000)))

(define-presentation-type entity-handle-output ()
   :printer ((handle stream)
	     (format stream "~A ~A" (graphic-entity-name (entity-handle-entity handle))
				    (entity-handle-key handle)))
   )

(defmethod (entity-handle-draw entity-handle) (&optional (selected-p t)
							 (stream *standard-output*))
  (multiple-value-bind (x y)
      (graphics::transform-and-fix-point x-position y-position
					 (graphics:stream-transform stream))
    (setq presentation (dw:with-output-as-presentation (:type 'entity-handle-output
							:object self
							:stream stream)
			 (send stream :draw-1-bit-raster 6 6
			       (if selected-p
				   *selected-handle-image*
				   *unselected-handle-image*)
			       0 0 (- x 3) (- y 3) :flip :noop)))))

(defmethod (entity-handle-erase entity-handle) (&optional (stream *standard-output*))
  (when presentation
    (send stream :erase-displayed-presentation presentation
		 :redisplay-overlapping-presentations nil)
    (setq presentation nil)))

(defmethod (entity-input-handle-motion graphic-entity) (handle &rest args)
  (apply #'entity-default-input-handle-motion self handle args))

(defmethod (entity-can-move-handle graphic-entity) (ignore) nil)

(defmethod (entity-move-handle graphic-entity) (handle dx dy)
  (entity-erase self)
  (entity-move-handle-internal self handle dx dy)
  (entity-reset-handles self)
  (entity-output self))

(defun make-entity-vertex-handles (entity points)
  (let ((handles nil)
	(point-number 0))
    (graphics:map-points #'(lambda (x y &optional ignore)
			     (push (make-entity-handle entity point-number x y)
				   handles)
			     (incf point-number))
			 points)
    (nreverse handles)))

(defun entity-input-vertex-motion (entity points handle
				   &rest args
				   &key (closed-p nil)
					(start-x nil) (start-y nil)
					(while-held (not (null start-x)))
					(stream *standard-output*)
				   &allow-other-keys)
  (declare (values dx dy)
	   (ignore entity))
  (let (neighbor-x1 neighbor-y1 neighbor-x2 neighbor-y2)
    (let ((index (entity-handle-key handle))
	  (length (floor (length points) 2)))
      (cond ((plusp index)
	     (setq neighbor-x1 (elt points (* (1- index) 2))
		   neighbor-y1 (elt points (1- (* index 2)))))
	    (closed-p
	     (setq neighbor-x1 (elt points (* (1- length) 2))
		   neighbor-y1 (elt points (1- (* length 2))))))
      (cond ((< (1+ index) length)
	     (setq neighbor-x2 (elt points (* (1+ index) 2))
		   neighbor-y2 (elt points (+ (* index 2) 3))))
	    (closed-p
	     (setq neighbor-x2 (elt points 0)
		   neighbor-y2 (elt points 1)))))
    (graphic-input:call-with-mouse-blinker-options
      #'mouse-input-vertex-motion
      (multiple-value-bind (handle-x handle-y)
	  (entity-handle-position handle)
	(list
	  (nconc
	    (list handle-x handle-y)
	    (and neighbor-x1 (list neighbor-x1 neighbor-y1))
	    (and neighbor-x2 (list neighbor-x2 neighbor-y2)))))
      :start-x start-x :start-y start-y
      :while-held while-held
      :stream stream
      args)))

(defun entity-default-input-handle-motion (entity handle
					   &rest args
					   &key (stream *standard-output*)
						(start-x nil) (start-y nil)
						(while-held (not (null start-x)))
					   &allow-other-keys)
  (declare (values dx dy))
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (unless (and start-x start-y)
      (multiple-value-setq (start-x start-y)
	(send window :mouse-position)))
    (let ((original-transform (graphics:stream-transform stream)))
      (graphic-input:mouse-inputting-point* (window x y
						    :whostate "Moving handle"
						    :who-line-documentation-string
						     (if while-held
  "Release at new position for this handle.  Abort aborts."
  "L: Place this handle here; M: Abort.  Abort also aborts.")
						     :while-held while-held
						     :original-stream stream
						     :x-offset x-offset :y-offset y-offset
						     args)
	  (graphics:with-graphics-translation (window x-offset y-offset)
	    (graphics:with-graphics-transform (window original-transform)
	      (multiple-value-bind (dx dy)
		  (graphics:untransform-distance (- x start-x) (- y start-y)
						 original-transform)
		(unwind-protect
		    (progn
		      (entity-move-handle-internal entity handle dx dy)
		      (entity-outline entity))
		  (entity-move-handle-internal entity handle (- dx) (- dy))))))
	(graphics:untransform-distance (- x start-x) (- y start-y) original-transform)))))

(defun mouse-input-vertex-motion (point-sets &rest args
					     &key (stream *standard-output*)
						  (start-x nil) (start-y nil)
						  (while-held (not (null start-x)))
					     &allow-other-keys)
  (declare (values dx dy))
  (multiple-value-bind (window x-offset y-offset)
      (send stream :window-and-offsets)
    (setq point-sets (loop for elem in point-sets
			   collect (loop for (x y) on elem by 'cddr
					 do (graphics:transform-window-points stream x y)
					 collect x collect y)))
    (unless (and start-x start-y)
      (multiple-value-setq (start-x start-y)
	(send window :mouse-position)))
    (graphic-input:mouse-inputting-point* (window x y 
						  :whostate "Moving handle"
						  :who-line-documentation-string
						   (if while-held
  "Release at new position for this handle.  Abort aborts."
  "L: Place this handle here; M: Abort.  Abort also aborts.")
						   :while-held while-held
						   :original-stream stream
						   :x-offset x-offset :y-offset y-offset
						   args)
	(let ((dx (- x start-x))
	      (dy (- y start-y)))
	  (loop for (start-x start-y . other-points) in point-sets do
	    (loop for (other-x other-y) on other-points by 'cddr do
	      (send window :draw-line (+ start-x dx) (+ start-y dy) other-x other-y :flip))))
      (graphics:untransform-distance (- x start-x) (- y start-y)
				     (graphics:stream-transform stream)))))

(defmethod (entity-reset-handles graphic-entity :after) ()
  (setq bbox-handles nil))

;;; This is easier to compute after we have drawn the thing, so just use instance variable
;;; as a cache.
(defmethod (graphic-entity-bounding-box-handles graphic-entity) ()
  (or bbox-handles
      (multiple-value-bind (left top right bottom)
	  (entity-bounding-box-edges-for-handles self)
	(let ((center-x (/ (+ left right) 2))
	      (center-y (/ (+ top bottom) 2)))
	  (setq bbox-handles (list (make-entity-handle self :left left center-y)
				   (make-entity-handle self :top center-x top)
				   (make-entity-handle self :right right center-y)
				   (make-entity-handle self :bottom center-x bottom)
				   (make-entity-handle self :upper-left left top)
				   (make-entity-handle self :upper-right right top)
				   (make-entity-handle self :lower-right right bottom)
				   (make-entity-handle self :lower-left left bottom)))))))

(defmethod (entity-bounding-box-edges-for-handles graphic-entity) ()
  (entity-bounding-box-edges self))

(defmethod (entity-handle-bounding-box-p entity-handle) ()
  (member key '(:left :top :right :bottom
		:upper-left :upper-right :lower-right :lower-left)))

(defwhopper (entity-input-handle-motion graphic-entity) (handle &rest args)
  (if (entity-handle-bounding-box-p handle)
      ;; Always transform.
      (apply #'entity-default-input-handle-motion self handle args)
      (lexpr-continue-whopper handle args)))

(defwhopper-subst (entity-can-move-handle graphic-entity) (handle)
  (if (entity-handle-bounding-box-p handle) t (continue-whopper handle)))

(defwhopper (entity-move-handle-internal graphic-entity) (handle dx dy)
  (if (entity-handle-bounding-box-p handle)
      (let ((transform (entity-bounding-box-handle-transform self handle dx dy)))
	(entity-transform-internal self transform)
	;; Other handles need to stay consistent during motion.
	(dolist (handle bbox-handles)
	  (entity-handle-transform handle transform)))
      (continue-whopper handle dx dy)))

(defmethod (entity-handle-transform entity-handle) (transform)
  (multiple-value-setq (x-position y-position)
    (graphics:transform-point x-position y-position transform)))

(defun entity-bounding-box-handle-transform (entity handle dx dy)
  (multiple-value-bind (fixed-point-key x-moves y-moves)
      (ecase (entity-handle-key handle)
	(:left (values :right t nil))
	(:top (values :bottom nil t))
	(:right (values :left t nil))
	(:bottom (values :top nil t))
	(:upper-left (values :lower-right t t))
	(:upper-right (values :lower-left t t))
	(:lower-right (values :upper-left t t))
	(:lower-left (values :upper-right t t)))
    (multiple-value-bind (x y)
	(entity-handle-position handle)
      (multiple-value-bind (fixed-x fixed-y)
	  (let ((handle (find fixed-point-key (graphic-entity-bbox-handles entity)
			      :key #'entity-handle-key)))
	    (entity-handle-position handle))
	(graphics:building-graphics-transform ()
	  (graphics:graphics-translate fixed-x fixed-y)
	  (flet ((/* (x y)
		   ;; Don't let the shape deteriorate into a point, because then it couldn't
		   ;; be recovered.
		   (/ (if (zerop x) 1 x)
		      (if (zerop y) 1 y))))
	    (graphics:graphics-scale (if (not x-moves) 1
					 (/* (- (+ x dx) fixed-x) (- x fixed-x)))
				     (if (not y-moves) 1
					 (/* (- (+ y dy) fixed-y) (- y fixed-y)))))
	  (graphics:graphics-translate (- fixed-x) (- fixed-y)))))))

(compile-flavor-methods entity-handle)

;;; Stub for now.
(defun note-entities-transform (entities)
  (ignore entities)
  )

(define-entity basic-vector (x1 y1 x2 y2)
  (:abstract t)
  (:points-to-transform x1 y1 x2 y2)
  (:handles (with-stack-list (points x1 y1 x2 y2)
	      (make-entity-vertex-handles self points)))
  (:move-handle (handle dx dy)
   (ecase (entity-handle-key handle)
     ((0)
      (incf x1 dx)
      (incf y1 dy))
     ((1)
      (incf x2 dx)
      (incf y2 dy))))
  )

(define-entity basic-points (points (closed-p nil))
  (:abstract t)
  (:points-to-transform &rest points)
  (:handles (make-entity-vertex-handles self points))
  (:input-handle-motion (handle &rest args)
   (apply #'entity-input-vertex-motion self points handle :closed-p closed-p args))
  (:move-handle (handle dx dy)
   (let ((n (entity-handle-key handle)))
     (incf (elt points (* n 2)) dx)
     (incf (elt points (1+ (* n 2))) dy)))
  )

(defmethod (entity-copy-instance-variables basic-points-entity :after) (ignore)
  (setq points (copy-seq points)))

(defmethod (entity-output-for-bounding-box basic-points-entity) ()
  (graphics:draw-lines points))

(defun draw-basic-polygon (points &optional (closed-p nil) (roundedness nil)
				  &rest args &key (filled t) &allow-other-keys)
  (cond ((eq roundedness :midpoint-spline)
	 (if closed-p
	     ;; Midpoint- one is superior because it is bounded by the unsmoothed shape.
	     (apply #'graphic-input:draw-midpoint-cubic-spline points :closed t args)
	     ;; Presumably boundaries aren't important.
	     (if filled
		 (apply #'graphics:draw-path
			#'(lambda (*standard-output*)
			    (apply #'graphics:draw-cubic-spline points))
			args)
		 (si:with-rem-keywords (some-args args '(:filled))
		   (apply #'graphics:draw-cubic-spline points some-args)))))
	((not (null roundedness))
	 (apply #'graphics:draw-rounded-corner-lines points roundedness
		:closed closed-p args))
	((or closed-p filled)			;PostScript compatibility
	 (apply #'graphics:draw-polygon points args))
	(filled
	 (apply #'graphics:draw-path
		#'(lambda (*standard-output*)
		    (graphics:draw-lines points))
		args))
	(t
	 (si:with-rem-keywords (some-args args '(:filled))
	   (apply #'graphics:draw-lines points some-args)))))

(defun basic-polygon-code (entity points &optional (closed-p nil) (roundedness nil))
  (basic-entity-code-1 entity
    #'(lambda (&rest args &key (filled t) &allow-other-keys)
	(cond ((eq roundedness :midpoint-spline)
	       (if closed-p
		   `(graphic-input:draw-midpoint-cubic-spline ',points :closed t . ,args)
		   `(graphics:draw-cubic-spline ',points . ,args)))
	      ((not (null roundedness))
	       `(graphics:draw-rounded-corner-lines ',points ,roundedness
						    :closed ,closed-p
						    . ,args))
	      ((or closed-p filled)		;See above
	       `(graphics:draw-polygon ',points . ,args))
	      (filled
	       `(graphics:draw-path
		  #'(lambda (*standard-output*) (graphics:draw-lines ',points))
		  . ,args))
	      (t
	       (si:with-rem-keywords (some-args args '(:filled))
		 `(graphics:draw-lines ',points . ,some-args)))))))

(define-entity basic-polygon (points (closed-p nil) (roundedness nil))
  (:abstract t)
  (:inherit-from basic-points-entity)
  (:output-function draw-basic-polygon)
  (:code (basic-polygon-code self points closed-p roundedness))
  (:own-options (roundedness 't)))

(defun accept-roundedness (default &rest options)
  (let ((rounded-p (apply #'accept '((alist-member :alist (("Unrounded" . nil)
							   ("Rounded" . :rounded)
							   ("Smoothed" . :midpoint-spline))))
			  :default (if (numberp default) :rounded default)
			  options)))
    (if (neq rounded-p :rounded) rounded-p
	(accept 'number :prompt " Corner radius"
		:default (if (numberp default) default 10)))))

(defmethod (entity-choose-own-option basic-polygon-entity :roundedness)
	   (type default &rest options)
  (ignore type)
  (apply #'accept-roundedness default options))

(define-global-entity-option-set roundedness (options *query-io*)
  (list :roundedness (accept-roundedness (getf options :roundedness)
					 :prompt "Polygon roundedness")))

(define-entity basic-rectilinear (points closed-p)
  (:abstract t)
  (:inherit-from basic-polygon-entity)
  (:input-handle-motion (handle &rest args)
   (apply #'entity-default-input-handle-motion self handle args))
  (:move-handle (handle dx dy)
   (move-rectangle-corner-handle points closed-p (entity-handle-key handle) dx dy))
  )

(define-entity :rectangle (points (closed-p t))
  (:inherit-from basic-rectilinear-entity)
  (:input-function (&rest args)
    (multiple-value-bind (left top right bottom)
	(apply #'graphic-input:mouse-input-rectangle args)
      (setq points (list left top left bottom right bottom right top))))
  (:output-function (&rest args)
   (if (and (null roundedness) (= (length points) 8)
	    (destructuring-bind (x1 y1 x2 y2 x3 y3 x4 y4) points
	      (and (= x1 x2) (= y1 y4) (= x3 x4) (= y2 y3))))
       (destructuring-bind (x1 y1 nil nil x3 y3 nil nil) points
	 ;; This might gain a little speed by drawing as one block instead of two.
	 (apply #'graphics:draw-rectangle x1 y1 x3 y3 args))
       (apply #'draw-basic-polygon points closed-p roundedness args)))
  (:code
   (if (and (null roundedness) (= (length points) 8)
	    (destructuring-bind (x1 y1 x2 y2 x3 y3 x4 y4) points
	      (and (= x1 x2) (= y1 y4) (= x3 x4) (= y2 y3))))
       (destructuring-bind (x1 y1 nil nil x3 y3 nil nil) points
	 ;; This might gain a little speed by drawing as one block instead of two.
	 (basic-entity-code self `(graphics:draw-rectangle ,x1 ,y1 ,x3 ,y3)))
       (basic-polygon-code self points closed-p roundedness)))
  (:sample-shape (copy-list '(0 0 0 1 2 1 2 0)))
  )

(defun rectangle-still-a-rectangle-p (points)
  (and (= (length points) 8)
       (destructuring-bind (x1 y1 x2 y2 x3 y3 x4 y4) points
	 (and (= x1 x2) (= y1 y4) (= x3 x4) (= y2 y3)))))

(defmethod (entity-highlighting-boxes rectangle-entity) ()
  (if (rectangle-still-a-rectangle-p points)
      (values nil t)
      (entity-default-highlighting-boxes self)))

(define-entity :triangle (points (closed-p t))
  (:inherit-from basic-polygon-entity)
  (:input-function (&rest args)
   (multiple-value-bind (x1 y1 x2 y2 x3 y3)
       (apply #'graphic-input:mouse-input-triangle args)
     (setq points (list x1 y1 x2 y2 x3 y3))))
  (:output-function (&rest args)
   (if (and (null roundedness) (= (length points) 6))
       (destructuring-bind (x1 y1 x2 y2 x3 y3) points
	 (apply #'graphics:draw-triangle x1 y1 x2 y2 x3 y3 args))
       (apply #'draw-basic-polygon points closed-p roundedness args)))
  (:code
   (if (and (null roundedness) (= (length points) 6))
       (destructuring-bind (x1 y1 x2 y2 x3 y3) points
	 (basic-entity-code self `(graphics:draw-triangle ,x1 ,y1 ,x2 ,y2 ,x3 ,y3)))
       (basic-polygon-code self points closed-p roundedness)))
  (:sample-shape (list 0 0 1 0 .5 (float (* .5 (tan (/ pi 3))) 0.0)))
  )

(define-entity basic-ellipse (center-x center-y x-radius y-radius
			      (rotation 0) (start-angle 0) (end-angle graphics:2pi))
  (:abstract t)
  (:output-function (&rest args)
    (apply #'graphics:draw-ellipse 0 0 x-radius y-radius
				   :start-angle start-angle :end-angle end-angle
				   :rotation rotation :translation (list center-x center-y)
				   args))
  (:code
    (basic-entity-code self
		       (let ((angles (unless (graphics::full-circle-p start-angle end-angle)
				       `(:start-angle ,start-angle :end-angle ,end-angle))))
			 (cond ((= x-radius y-radius)
				`(graphics:draw-circle ,center-x ,center-y ,x-radius
						       . ,angles))
			       ((zerop rotation)
				`(graphics:draw-ellipse ,center-x ,center-y ,x-radius ,y-radius
							. ,angles))
			       (t
				`(graphics:draw-ellipse 0 0 ,x-radius ,y-radius ,@angles
							:rotation ,rotation
							:translation (list ,center-x ,center-y)
							))))))
  (:transform (transform)
   ;; Take what we do to the unit circle to make ourselves.  Transform that as desired
   ;; and pick it back apart.
   (multiple-value-setq (rotation x-radius y-radius center-x center-y)
     (graphics:decompose-transform (graphics:build-graphics-transform
				     :transform transform
				     :translation (list center-x center-y)
				     :scale-x x-radius :scale-y y-radius
				     :rotation rotation)))
   ;; And distort any arc boundaries according to the transform.
   (unless (and (= start-angle 0)
		(= end-angle graphics:2pi))
     (multiple-value-bind (rotation scale-x scale-y)
	 (graphics:decompose-transform transform)
       (unless (and (zerop rotation)
		    (= scale-x scale-y))
	 (when (minusp scale-x)
	   (setq scale-x (- scale-x))
	   (rotatef start-angle end-angle)
	   (setq start-angle (- pi start-angle)
		 end-angle (- pi end-angle)))
	 (when (minusp scale-y)
	   (setq scale-y (- scale-y))
	   (rotatef start-angle end-angle)
	   (setq start-angle (- start-angle)
		 end-angle (- end-angle)))
	 (unless (= scale-x scale-y)		;No distortion
	   (unless (zerop (mod start-angle (/ pi 2)))
	     (let ((sin (sin start-angle))
		   (cos (cos start-angle)))
	       (unless (or (< (abs sin) 1e-5) (< (abs cos) 1e-5))
		 (setq start-angle (atan (* sin scale-y) (* cos scale-x))))))
	   (unless (zerop (mod end-angle (/ pi 2)))
	     (let ((sin (sin end-angle))
		   (cos (cos end-angle)))
	       (unless (or (< (abs sin) 1e-5) (< (abs cos) 1e-5))
		 (setq end-angle (atan (* sin scale-y) (* cos scale-x)))))))))
     ))
  (:handles (basic-ellipse-handles self center-x center-y x-radius y-radius rotation))
  (:move-handle (handle dx dy)
   (multiple-value-setq (x-radius y-radius)
     (basic-ellipse-move-handle handle dx dy center-x center-y x-radius y-radius)))
  )

(defun basic-ellipse-handles (entity center-x center-y x-radius y-radius rotation)
  (let ((x1 x-radius)
	(y1 0)
	(x2 0)
	(y2 y-radius))
    (unless (zerop rotation)
      (let ((transform (graphics:build-graphics-transform :rotation rotation)))
	(multiple-value-setq (x1 y1)
	  (graphics:transform-point x1 y1 transform))
	(multiple-value-setq (x2 y2)
	  (graphics:transform-point x2 y2 transform))))
    (list (make-entity-handle entity :x-radius (+ x1 center-x) (+ y1 center-y))
	  (make-entity-handle entity :y-radius (+ x2 center-x) (+ y2 center-y)))))

(defun basic-ellipse-move-handle (handle dx dy center-x center-y x-radius y-radius)
  (let ((length (multiple-value-bind (hx hy)
		    (entity-handle-position handle)
		  (incf hx dx)
		  (incf hy dy)
		  (sqrt (+ (expt (- hx center-x) 2) (expt (- hy center-y) 2))))))
    (ecase (entity-handle-key handle)
      (:x-radius
	(values length y-radius))
      (:y-radius
	(values x-radius length)))))

(defmethod (entity-highlighting-boxes basic-ellipse-entity) ()
  (entity-outline-highlighting-boxes self))

(defmethod (entity-outline-for-highlighting basic-ellipse-entity) ()
  (graphics:draw-ellipse 0 0 (+ x-radius 2) (+ y-radius 2)
			 :start-angle start-angle :end-angle end-angle
			 :rotation rotation :translation (list center-x center-y)
			 :filled nil :alu :flip))

;;; The filled shape has a larger footprint than the unfilled if there is an angle range.
(defmethod (entity-output-for-bounding-box basic-ellipse-entity) ()
  (if (or inside-drawing-options
	  (graphics::full-circle-p start-angle end-angle))
      (entity-output-internal self)
      (entity-output-internal self :filled nil)))

(define-entity :circle (center-x center-y x-radius (y-radius x-radius))
  (:inherit-from basic-ellipse-entity)
  (:input-function graphic-input:mouse-input-circle)
  (:sample-shape 0 0 1)
  (:handles (if (= x-radius y-radius)		;Still a circle
		(nbutlast (basic-ellipse-handles self center-x center-y x-radius y-radius
						 rotation))
		(basic-ellipse-handles self center-x center-y x-radius y-radius rotation)))
  (:move-handle (handle dx dy)
   (if ( x-radius y-radius)
       (multiple-value-setq (x-radius y-radius)
	 (basic-ellipse-move-handle handle dx dy center-x center-y x-radius y-radius))
       (setq x-radius (basic-ellipse-move-handle handle dx dy center-x center-y
						 x-radius y-radius)
	     y-radius x-radius))))

(define-entity :rectilinear-ellipse (center-x center-y x-radius y-radius)
  (:inherit-from basic-ellipse-entity)
  (:input-function graphic-input:mouse-input-simple-ellipse)
  (:sample-shape 0 0 2 1)
  )

(define-entity :oval (center-x center-y x-radius y-radius (rotation 0))
  (:inherit-from basic-ellipse-entity)
  (:input-function graphic-input:mouse-input-oval)
  (:output-function (&rest args)
    (apply #'graphics:draw-oval 0 0 x-radius y-radius
	   :translation (list center-x center-y)
	   :rotation rotation
	   args))
  (:code
    (basic-entity-code self
		       (if (zerop rotation)
			   `(graphics:draw-oval ,center-x ,center-y ,x-radius ,y-radius)
			   `(graphics:draw-oval 0 0 ,x-radius ,y-radius
						:rotation ,rotation
						:translation (list ,center-x ,center-y)))))
  (:sample-shape 0 0 2 1))

(defmethod (entity-outline-for-highlighting oval-entity) ()
  (graphics:draw-oval 0 0 (+ x-radius 2) (+ y-radius 2)
		      :start-angle start-angle :end-angle end-angle
		      :rotation rotation :translation (list center-x center-y)
		      :filled nil :alu :flip))

(define-entity :ellipse (center-x center-y x-radius y-radius rotation)
  (:inherit-from basic-ellipse-entity)
  (:input-function graphic-input:mouse-input-general-ellipse)
  (:sample-shape 0 0 2 1 (/ (float pi 0.0) 3))
  )

(define-entity :circular-arc (center-x center-y x-radius start-angle end-angle
			      (y-radius x-radius))
  (:inherit-from basic-ellipse-entity)
  (:name "Circular Arc/Sector")
  (:input-function (&rest args)
   (multiple-value-setq (center-x center-y x-radius start-angle end-angle)
     (apply (ecase *circular-arc-entry-mode*
	      (:center-radius #'graphic-input:mouse-input-circular-arc)
	      (:end-points-bow #'graphic-input::alternative-mouse-input-circular-arc))
	    args))
   (setq y-radius x-radius))
  (:sample-shape 0 0 1 (/ (float pi 0.0) 4) (/ (float pi 0.0) 2))
  #+maybe-better
  (:transform (transform)
   (flet ((one-point (theta)
	    (graphics:transform-point (+ center-x (* x-radius (cos theta)))
				      (+ center-y (* y-radius (sin theta)))
				      transform)))
     (multiple-value-bind (start-x start-y)
	 (one-point start-angle)
       (multiple-value-bind (end-x end-y)
	   (one-point end-angle)
	 (multiple-value-bind (intermediate-x intermediate-y)
	     (one-point (/ (+ start-angle end-angle) 2))
	   (multiple-value-setq (center-x center-y x-radius)
	     (graphics:triangle-circumscribed-circle start-x start-y end-x end-y
						     intermediate-x intermediate-y))
	   (setq start-angle (atan (- start-y center-y) (- start-x center-x))
		 end-angle (atan (- end-y center-y) (- end-x center-x)))
	   (unless (graphics:angle-between-angles-p
		     (atan (- intermediate-y center-y)
			   (- intermediate-x center-x))
		     start-angle end-angle)
	     (rotatef start-angle end-angle)))))))
  (:handles (flet ((one-point (theta key)
		     (let ((x (* x-radius (cos theta)))
			   (y (* y-radius (sin theta))))
		       (unless (zerop rotation)
			 (let ((transform
				 (graphics:build-graphics-transform :rotation rotation)))
			   (multiple-value-setq (x y)
			     (graphics:transform-point x y transform))))
		       (make-entity-handle self key (+ x center-x) (+ y center-y)))))
	      (list (one-point start-angle :start-angle)
		    (one-point (/ (+ start-angle end-angle) 2) :middle)
		    (one-point end-angle :end-angle))))
  (:move-handle (handle dx dy)
   (flet ((get-new-angle (theta)
	    (let ((x (* x-radius (cos theta)))
		  (y (* y-radius (sin theta))))
	      (atan (+ y dy) (+ x dx)))))
     (ecase (entity-handle-key handle)
       (:start-angle (setq start-angle (get-new-angle start-angle)))
       (:end-angle (setq end-angle (get-new-angle end-angle)))
       (:middle (let (x1 y1 x2 y2 x3 y3)
		  (multiple-value-setq (x1 y1)
		    (entity-handle-position (first handles)))
		  (multiple-value-setq (x2 y2)
		    (entity-handle-position (second handles)))
		  (multiple-value-setq (x3 y3)
		    (entity-handle-position (third handles)))
		  (incf x2 dx) (incf y2 dy)
		  (multiple-value-setq (center-x center-y x-radius)
		    (graphics:triangle-circumscribed-circle x1 y1 x2 y2 x3 y3))
		  (setq y-radius x-radius
			start-angle (graphic-input:atan-careful
				      (- y1 center-y) (- x1 center-x))
			end-angle (graphic-input:atan-careful
				    (- y3 center-y) (- x3 center-x))))))))
  )

(define-entity :quarter-ellipse (x1 y1 x2 y2)
  (:inherit-from basic-vector-entity)
  (:input-function graphic-input:mouse-input-quarter-ellipse)
  (:output-function graphic-input:draw-quarter-ellipse)
  (:code graphic-input:draw-quarter-ellipse)
  )

(define-entity :polygon (points closed-p)
  (:inherit-from basic-polygon-entity)
  (:input-function (&rest args)
   (multiple-value-setq (closed-p points)
     (points-are-closed (apply #'graphic-input:mouse-input-lines args) t)))
  (:sample-shape (copy-list '(0 0 1 2 2 1 3 2 4 1 5 2 6 0)) t)
  )

(define-entity :rectilinear-lines (points closed-p)
  (:inherit-from basic-rectilinear-entity)
  (:input-function (&rest args)
   (multiple-value-setq (closed-p points)
     (points-are-closed (apply #'graphic-input:mouse-input-rectilinear-lines args) t)))
  (:sample-shape (copy-list '(0 0 0 2 3 2 3 1 2 1 2 0)) t)
  )

(defun points-are-closed (points &optional return-adjustment)
  (declare (values closed-p adjusted-points))
  (let ((length (length points)))
    (if (and (> length 2)
	     (= (elt points 0) (elt points (- length 2)))
	     (= (elt points 1) (elt points (1- length))))
	(values t (and return-adjustment (subseq points 0 (- length 2))))
	(values nil points))))

(defun move-rectangle-corner-handle (points closed-p index dx dy)
  ;; Decompose the movement vector according to the basis of the two lines meeting at
  ;; this corner.  Then apply each of the pieces to the adjacent points.
  (let (next-unit-x next-unit-y
	previous-unit-x previous-unit-y)
    (let ((x (elt points (* index 2)))
	  (y (elt points (1+ (* index 2)))))
      (if (zerop index)
	  ;; First point, take the next.
	  (let* ((next-x (elt points (+ (* index 2) 2)))
		 (next-y (elt points (+ (* index 2) 3)))
		 (next-dx (- next-x x))
		 (next-dy (- next-y y))
		 (length (sqrt (+ (expt next-dx 2) (expt next-dy 2)))))
	    (setq next-unit-x (/ next-dy length)
		  next-unit-y (- (/ next-dx length)))
	    (setq previous-unit-x (- next-unit-y)
		  previous-unit-y next-unit-x))
	  ;; Otherwise, take previous
	  (let* ((prev-x (elt points (- (* index 2) 2)))
		 (prev-y (elt points (- (* index 2) 1)))
		 (prev-dx (- prev-x x))
		 (prev-dy (- prev-y y))
		 (length (sqrt (+ (expt prev-dx 2) (expt prev-dy 2)))))
	    (setq previous-unit-x (/ prev-dy length)
		  previous-unit-y (- (/ prev-dx length)))
	    (setq next-unit-x (- previous-unit-y)
		  next-unit-y previous-unit-x))))
    (let ((scale-next (/ (- (* dy previous-unit-x) (* dx previous-unit-y))
			 (- (* next-unit-y previous-unit-x) (* next-unit-x previous-unit-y))))
	  (scale-previous (/ (- (* dy next-unit-x) (* dx next-unit-y))
			     (- (* previous-unit-y next-unit-x)
				(* previous-unit-x next-unit-y)))))
      (setq next-unit-x (* scale-next next-unit-x)
	    next-unit-y (* scale-next next-unit-y))
      (setq previous-unit-x (* scale-previous previous-unit-x)
	    previous-unit-y (* scale-previous previous-unit-y)))
    (let ((prev-index2 (cond ((plusp index)
			      (* (1- index) 2))
			     (closed-p
			      (- (length points) 2)))))
      (when prev-index2
	(incf (elt points prev-index2) previous-unit-x)
	(incf (elt points (1+ prev-index2)) previous-unit-y)))
    (incf (elt points (* index 2)) dx)
    (incf (elt points (1+ (* index 2))) dy)
    (let ((next-index2 (cond ((< (* (1+ index) 2) (length points))
			      (* (1+ index) 2))
			     (closed-p
			      0))))
      (when next-index2
	(incf (elt points next-index2) next-unit-x)
	(incf (elt points (1+ next-index2)) next-unit-y))))
  points)

(define-entity :freehand-curve (points)
  (:inherit-from basic-points-entity)
  (:input-function graphic-input:mouse-input-freehand-curve)
  (:output-function (&rest args &key (filled t) &allow-other-keys)
    ;; Actually, the inherited one would also work, but takes longer because the
    ;; triangulation is slower for a large set than vertical scan conversion.
    (if filled
	(apply #'graphics:draw-path
	       #'(lambda (*standard-output*)
		   (graphics:draw-lines points))
	       args)
	(si:with-rem-keywords (some-args args '(:filled))
	  (apply #'graphics:draw-lines points some-args))))
  (:code
    (basic-entity-code-1 self
      #'(lambda (&rest args &key filled &allow-other-keys)
	  (si:with-rem-keywords (some-args args '(:filled))
	    (if filled
		`(graphics:draw-path
		   #'(lambda (*standard-output*) (graphics:draw-lines ',points))
		   . ,some-args)
		`(graphics:draw-lines ',points . ,some-args))))))
  (:sample-shape (graphics:compute-cubic-spline-points '(0 3 1 4 2 3 6 0 10 3 6 6 2 3 1 2 0 3)
						       :start-relaxation :cyclic
						       :number-of-samples 3))
  )

(define-entity :bezier-curve (x1 y1 x4 y4 x2 y2 x3 y3)
  (:name "Be'zier Cubic")
  (:input-function graphic-input:mouse-input-bezier-curve)
  (:output-function (&rest args &key (filled t) &allow-other-keys)
    (if filled
	(apply #'graphics:draw-path
	       #'(lambda (*standard-output*)
		   (graphics:set-current-position x2 y2)
		   (graphics:draw-line-to x1 y1)
		   (graphics:draw-bezier-curve-to x4 y4 x2 y2 x3 y3)
		   (graphics:close-path))
	       args)
	(si:with-rem-keywords (some-args args '(:filled))
	  (apply #'graphics:draw-bezier-curve x1 y1 x4 y4 x2 y2 x3 y3 some-args))))
  (:code
    (basic-entity-code-1 self
      #'(lambda (&rest args &key filled &allow-other-keys)
	  (si:with-rem-keywords (some-args args '(:filled))
	    (if filled
		`(graphics:draw-path
		   #'(lambda (*standard-output*)
		       (graphics:set-current-position ,x2 ,y2)
		       (graphics:draw-line-to ,x1 ,y1)
		       (graphics:draw-bezier-curve-to ,x4 ,y4 ,x2 ,y2 ,x3 ,y3)
		       (graphics:close-path))
		   . ,some-args)
		`(graphics:draw-bezier-curve ,x1 ,y1 ,x4 ,y4 ,x2 ,y2 ,x3 ,y3 . ,some-args))))))
  (:points-to-transform x1 y1 x4 y4 x2 y2 x3 y3)
  (:handles (with-stack-list (points x1 y1 x2 y2 x3 y3 x4 y4)
	      (make-entity-vertex-handles self points)))
  (:move-handle (handle dx dy)
   (ecase (entity-handle-key handle)
     ((0)
      (incf x1 dx)
      (incf y1 dy))
     ((1)
      (incf x2 dx)
      (incf y2 dy))
     ((2)
      (incf x3 dx)
      (incf y3 dy))
     ((3)
      (incf x4 dx)
      (incf y4 dy))))
  )

(defmethod (entity-output-for-bounding-box bezier-curve-entity) ()
  (graphics:draw-triangle x1 y1 x4 y4 x2 y2)
  (graphics:draw-triangle x1 y1 x4 y4 x3 y3))

(define-entity :cubic-spline (points relaxation)
  (:inherit-from basic-points-entity)
  (:input-function (&rest args)
   (setq points (apply #'graphic-input:mouse-input-points args)
	 relaxation (if (points-are-closed points) :cyclic :relaxed)))
  (:output-function (&rest args &key (filled t) &allow-other-keys)
   (if (and filled (eq relaxation :cyclic))
       (apply #'graphics:draw-path
	      #'(lambda (*standard-output*)
		  (graphics:draw-cubic-spline points :start-relaxation relaxation))
	      args)
       (si:with-rem-keywords (some-args args '(:filled))
	 (apply #'graphics:draw-cubic-spline points :start-relaxation relaxation
		some-args))))
  (:code
    (basic-entity-code-1 self
      #'(lambda (&rest args &key filled &allow-other-keys)
	  (si:with-rem-keywords (some-args args '(:filled))
	    (let ((relax (unless (eq relaxation :relaxed)
			   `(:start-relaxation ,relaxation))))
	      (if filled
		  `(graphics:draw-path
		     #'(lambda (*standard-output*)
			 (graphics:draw-cubic-spline ',points . ,relax))
		     . ,some-args)
		  `(graphics:draw-cubic-spline ',points ,@relax . ,some-args))))))))

(define-entity :text (x y string character-style
		      (sizing :unscaled-one-point) (to-x nil) (to-y nil))
  (:input-function (&rest args)
   (multiple-value-setq (x y string character-style sizing to-x to-y)
     (apply #'input-and-place-text :character-style character-style args)))
  (:output-function (&rest args)
   (apply #'graphic-input:draw-sized-string string x y
	  :sizing sizing :character-style character-style
	  :toward-x to-x :toward-y to-y
	  args))
  (:code
   (basic-entity-code self
		      `(graphic-input:draw-sized-string ,string ,x ,y
			 :sizing ,sizing
			 ,@(unless (eq character-style si:*null-style*)
			     `(:character-style ',(cdr (multiple-value-list
							 (si:parse-character-style
							   character-style)))))
			 ,@(when (or to-x to-y)
			     `(:toward-x ,to-x :toward-y ,to-y)))))
  (:points-to-transform x y &optional to-x to-y)
  (:outline-p nil)
  (:sample-shape 0 0 "Text" (si:parse-character-style '(:dutch :roman :very-large)))
  (:handles (if (member sizing '(:unscaled-one-point :scaled-one-point))
		(list (make-entity-handle self :position x y))
		(list (make-entity-handle self :from x y)
		      (make-entity-handle self :to to-x to-y))))
  (:move-handle (handle dx dy)
   (case (entity-handle-key handle)
     (:to (incf to-x dx) (incf to-y dy))
     (otherwise (incf x dx) (incf y dy))))
  (:own-options (string 'string)
		(character-style `((character-face-or-style
				     :device ,(send *standard-output* :display-device-type)
				     :against-default ,(send *standard-output*
							     :default-character-style))))
		(sizing '((member :unscaled-one-point :unscaled-tilted :unscaled-stretched
				  :unscaled-tilted-and-stretched
				  :scaled-one-point :scaled-tilted :scaled-stretched
				  :scaled-tilted-and-stretched))))
  )

(define-global-entity-option-set character-style (options stream)
  (list :character-style (accept `((character-face-or-style
				     :device ,(send tv:main-screen :display-device-type)
				     :against-default ,(send tv:main-screen
							     :default-character-style)))
				 :prompt "Text character style" :stream stream
				 :default (getf options :character-style si:*null-style*))))

(defparameter *text-sizing-alist*
  '(("Same font"
     :value (("Just start moves" :value :unscaled-one-point
	      :documentation "Only the lefthand point of the text is transformed.")
	     ("Slope changes" :value :unscaled-tilted
	      :documentation "Slope of text changes, but character spacing remains.")
	     ("Stretches horizontally" :value :unscaled-stretched
	      :documentation "Spacing is stretched out horizontally.")
	     ("Tilts and stretches" :value :unscaled-tilted-and-stretched
	      :documentation "Text is stretched and tilted between two control points."))
     :documentation "Keep the specified font regardless of transformation.")
    ("Different size font"
     :value (("Just start moves" :value :scaled-one-point
	      :documentation "Only the lefthand point of the text is transformed.")
	     ("Orientation changes" :value :scaled-tilted
	      :documentation "Slope of text and orientation of glyphs changes, but character spacing remains.")
	     ("Stretches horizontally" :value :scaled-stretched
	      :documentation "Spacing and size is stretched out horizontally.")
	     ("Tilts and stretches" :value :scaled-tilted-and-stretched
	      :documentation "Text is transformed all along line between control points."))
     :documentation "Transform character glyphs just like any other shape.")))

(defun accept-text-sizing (&optional (default :unscaled-one-point))
  (let ((subalist (accept `((alist-member :alist ,*text-sizing-alist*))
			  :default (dolist (elem *text-sizing-alist*)
				     (let ((subalist (tv:menu-execute-no-side-effects elem)))
				       (when (find default subalist
						   :key #'tv:menu-execute-no-side-effects)
					 (return subalist))))
			  :query-identifier 'text-sizing
			  :prompt "When scaled")))
    (accept `((alist-member :alist ,subalist))
	    :default (if (find default subalist :key #'tv:menu-execute-no-side-effects)
			 default (tv:menu-execute-no-side-effects (first subalist)))
	    :query-identifier (list 'text-subsizing subalist)
	    :prompt "When rotated")))

(defmethod (entity-choose-own-option text-entity :sizing) (type default &rest options)
  (ignore type options)
  (accept-text-sizing default))

(define-presentation-type text-string-internal ()
   :parser ((stream &key default)
	    (let ((value (copy-list default)))
	      (when (let ((start-loc (send stream :read-location)))
		      (dw:with-accept-blip-chars ('(#\Tab))
			(setf (getf value :string)
			      (accept 'string :default (getf default :string)
				      :stream stream :prompt nil))
			(let ((terminator (dw:read-char-for-accept stream)))
			  (cond ((dw:compare-char-for-accept terminator #\Space)
				 t)
				((dw:compare-char-for-accept terminator #\Tab)
				 ;; Need for force quotes here?
				 (dw::presentation-replace-input stream start-loc
								 (getf value :string))
				 (setq start-loc (send stream :read-location))
				 (dw::presentation-replace-input stream start-loc " "
								 :dont-quote t)
				 t)
				(t
				 (dw:unread-char-for-accept terminator stream)
				 nil)))))
		(setf (getf value :character-style)
		      (accept 'character-style :default (getf default :character-style)
			      :stream stream :prompt "character style")))
	      value)))

(defun accept-text-string (default prompt)
  (accept 'text-string-internal :default default :prompt prompt
				:provide-default t :display-default nil))

(defmethod (entity-merge-options text-entity :after) ()
  (when handles	;Do this after an explicit change, not at the very start.
    (flet ((get-width ()
	     ;; Should this obey as-if-hardcopy?
	     (graphic-input::multi-line-string-size string :character-style character-style)))
      (let ((changed-p nil))
	(cond ((member sizing '(:unscaled-one-point :scaled-one-point))
	       (when (or to-x to-y)
		 (setq to-x nil to-y nil)
		 (setq changed-p t)))
	      ((or (null to-x) (null to-y))
	       (setq to-x (+ x (round (get-width))) to-y y)
	       (setq changed-p t))
	      ((member sizing '(:unscaled-tilted :scaled-tilted))
	       (let* ((dx (- to-x x))
		      (dy (- to-y y))
		      (scale (sqrt (+ (expt dx 2) (expt dy 2))))
		      (width (get-width)))
		 (setq to-x (+ x (round (* width dx) scale))
		       to-y (+ y (round (* width dy) scale))))
	       (setq changed-p t)))
	(when changed-p
	  (entity-reset-handles self))))))

(defmethod (entity-highlighting-boxes text-entity) () (values nil t))

(defwhopper-subst (entity-possible-common-options text-entity) ()
  (remove :string (continue-whopper)))

(defun input-and-place-text (&rest args &key (character-style si:*null-style*)
					     start-x start-y position-transform
					&allow-other-keys)
  (declare (values (x y string character-style sizing to-x to-y)))
  (multiple-value-bind (string character-style sizing no-second-point)
      (ecase *text-entry-mode*
	(:menu
	  (let ((ctype `((character-face-or-style
			   :device ,(send *standard-output* :display-device-type)
			   :against-default ,(send *standard-output*
						   :default-character-style)))))
	    (dw:with-typeout-window-for-accept-values
	      (dw:accepting-values ()
		(values (accept 'string :prompt "String")
			(accept ctype :default character-style :prompt "Character style")
			(accept-text-sizing))))))
	(:read-line
	  (let ((value (list :character-style character-style)))
	    (setq value (accept-text-string value
			  #'(lambda (stream &optional ignore)
			      (format stream "Text to add")
			      (unless (eq character-style si:*null-style*)
				(format stream " in ~A" character-style))
			      (when (and start-x start-y position-transform)
				(multiple-value-bind (x y)
				    (graphics:stream-transform-point start-x start-y
								     *standard-output*)
				  (multiple-value-setq (x y)
				    (graphics:untransform-point x y position-transform))
				  (format stream " at ~$,~$" x y))))))
	    (values (getf value :string) (getf value :character-style)
		    :scaled-tilted t))))
    (unless string
      (dw:command-error "You must specify a string."))
    (multiple-value-bind (x y to-x to-y)
	(apply #'graphic-input:mouse-position-text string :character-style character-style
							  :sizing sizing
							  :input-second-point
							   (not no-second-point)
							  args)
      (values x y string character-style sizing to-x to-y))))

(defvar *text-bounding-box-as-if-hardcopy-device* ())
(defvar *text-bounding-box-as-if-hardcopy-device-streams* nil)

(defun as-if-hardcopy-device-stream (device)
  (let ((elem (assoc device *text-bounding-box-as-if-hardcopy-device-streams*)))
    (when (null elem)
      (setq elem (list device 
		       (with-open-stream (stream (hardcopy:make-hardcopy-stream device))
			 (close stream :abort t)
			 stream)))
      (push elem *text-bounding-box-as-if-hardcopy-device-streams*))
    (second elem)))

(defmethod (entity-bounding-box-edges-for-handles text-entity) ()
  (if *text-bounding-box-as-if-hardcopy-device*
      (let ((stream (as-if-hardcopy-device-stream *text-bounding-box-as-if-hardcopy-device*))
	    (scale (/ *pixels-per-point*)))
	(multiple-value-bind (right bottom nil nil left top)
	    (dw:continuation-output-size
	      (lambda (*standard-output*)
		(graphics:with-graphics-transform (t (list scale 0 0 (- scale) 0 1000))
		  (entity-output-for-bounding-box self)))
	      stream)
	  (setq left (round left scale)
		top (round (- 1000 top) scale)
		right (round right scale)
		bottom (round (- 1000 bottom) scale))
	  (psetq top (+ y (- y bottom))
		 bottom (+ y (- y top)))
	  (values left top right bottom)))
      (entity-bounding-box-edges self)))

(define-entity :line (x1 y1 x2 y2 arrow-parameters)
  (:inherit-from basic-vector-entity)
  (:input-function (&rest args)
   (multiple-value-setq (x1 y1 x2 y2)
     (apply #'graphic-input:mouse-input-line args)))
  (:output-function (&rest args)
   (destructuring-bind (&key arrowhead
			     (arrow-head-length graphics:*default-arrow-length*)
			     (arrow-base-width graphics:*default-arrow-width*))
      arrow-parameters
     (if (null arrowhead)
	 (apply #'graphics:draw-line x1 y1 x2 y2 args)
	 (apply #'graphics:draw-arrow x1 y1 x2 y2
		:arrow-head-length arrow-head-length
		:arrow-base-width arrow-base-width
		:from-arrow-head (member arrowhead '(:reverse :double))
		:to-arrow-head (member arrowhead '(:single :double))
		args))))
  (:filled-p nil)
  (:code
    (basic-entity-code-1 self
      #'(lambda (&rest args)
	  (destructuring-bind (&key arrowhead
				    (arrow-head-length graphics:*default-arrow-length*)
				    (arrow-base-width graphics:*default-arrow-width*))
	      arrow-parameters
	    (let ((arrow `(,@(unless (eql arrow-head-length graphics:*default-arrow-length*)
			       `(:arrow-head-length ,arrow-head-length))
			   ,@(unless (eql arrow-base-width graphics:*default-arrow-width*)
			       `(:arrow-base-width ,arrow-base-width)))))
	      (if (null arrowhead)
		  `(graphics:draw-line ,x1 ,y1 ,x2 ,y2 . ,args)
		  (let ((heads `(,@(when (eq arrowhead :reverse)
				     `(:to-arrow-head nil))
				 ,@(when (member arrowhead '(:reverse :double))
				     `(:from-arrow-head t)))))
		    `(graphics:draw-arrow ,x1 ,y1 ,x2 ,y2 ,@heads ,@arrow . ,args))))))))
  (:sample-shape 0 0 1 1)
  (:own-options (arrow-parameters t "Arrowhead(s)"))
  )

(defmethod (entity-choose-own-option line-entity :arrow-parameters)
	   (type default &rest options)
  (ignore type)
  (apply #'accept-arrow-parameters default options))

(define-global-entity-option-set line-arrowness (options *query-io*)
  (list :arrow-parameters (accept-arrow-parameters (getf options :arrow-parameters)
						   :prompt "Arrowhead(s)")))

(defun accept-arrow-parameters (default &rest options)
  (destructuring-bind (&key (arrowhead nil)
			    (arrow-head-length graphics:*default-arrow-length*)
			    (arrow-base-width graphics:*default-arrow-width*))
     default
    (setq arrowhead (let ((heads (append (and (member arrowhead '(:reverse :double))
					      '(:start))
					 (and (member arrowhead '(:single :double))
					      '(:end)))))
		      (setq heads (apply #'accept '((dw::alist-subset
						      :alist (("Start" :value :start
							       :documentation "An arrowhead at the first point")
							      ("End" :value :end
							       :documentation "An arrowhead at the second point"))))
					 :default heads options))
		      (if (member :end heads)
			  (if (member :start heads) :double :single)
			  (if (member :start heads) :reverse nil))))
    (when arrowhead
      (setq arrow-head-length (accept 'number :prompt " Arrow head length" 
				      :default arrow-head-length)
	    arrow-base-width (accept 'number :prompt " Arrow base width" 
				     :default arrow-base-width)))
    (list :arrowhead arrowhead
	  :arrow-head-length arrow-head-length :arrow-base-width arrow-base-width)))

(define-global-entity-option-set presentation-data (options *query-io*)
  (list :presentation-data
	(list :ptype (accept `(null-or-type (alist-member
					      :alist ,graphics::*binary-encodable-ptypes*))
			     :prompt "Presentation type"
			     :default (getf (getf options :presentation-data)
					    :ptype)))))

;;; System default is better.
(defmethod (entity-highlighting-boxes line-entity) () nil)

(defmethod (entity-set-sample-own-options line-entity) (options)
  (setf arrow-parameters (getf options :arrow-parameters)))

;;; Always give control points.
(defmethod (graphic-entity-bounding-box-handles line-entity) ()
  (graphic-entity-handles self))

(define-entity :image (bitmap x y (scale nil) (scale-x 1) (scale-y 1) (width nil) (height nil))
  (:input-function (&rest ignore)
   (dw:command-error "You cannot enter an image this way."))
  (:output-function (&rest args)
   (let* ((opaque (getf args :opaque)))
      (si:with-rem-keywords (some-args args '(:opaque))
       (apply #'graphics:draw-image bitmap 0 0
				    :translation (list x y)
				    :image-right width :image-bottom height
				    :scale-x scale-x
				    ;; Images assumed to be in TV scan order.
				    :scale-y (- scale-y)
				    :opaque opaque	;can't specify :opaque nil to GRED
				    some-args))))
  (:code
   (basic-entity-code self `(graphics:draw-image ',bitmap 0 0 :translation (list ,x ,y)
						 :image-right ,width :image-bottom ,height
						 :scale-x ,scale-x :scale-y (- ,scale-y))))
  (:outline-p nil)
  (:points-to-transform x y)
  (:handles (list (make-entity-handle self nil x y))))

(defmethod (make-instance image-entity :after) (&rest ignore)
  (when scale
    (setf scale-x scale
	  scale-y scale)))

(defmethod (entity-highlighting-boxes image-entity) () (values nil t))
    
#||	;Include these forms if you require strict compatibility
(defun kbd-graphic-edit-bitmap (&optional arg)
  (hci::hardcopy-screen-1 (case arg
			    (2 '(:whole-screen))
			    (3 '(:selected-window))
			    (4 '(:mouse-window))
			    (5 '(:who-line))
			    (otherwise '(:rectangle)))
			  '(:graphic-editor)))

(tv:add-function-key #\super-shift-Q 'kbd-graphic-edit-bitmap
		     "Pass a screen image to the graphic editor.
  1 or no arg allows specification of a rectangle.
  2 takes the whole screen.
  3 takes just the selected window.
  4 takes the window under the mouse.
  5 takes just the mouse documentation line.")
||#

(defflavor basic-group-entity ((entities nil)) (graphic-entity)
  :readable-instance-variables
  :initable-instance-variables)

(defflavor group-entity () (basic-group-entity))

(defvar *group-entity-shape* (make-entity-shape :group "Group" 'group-entity))

(define-presentation-type group-entity-output ()
   :expander 'graphic-entity-output)

(defmethod (entity-presentation-type group-entity) () 'group-entity-output)

;;; Put together a list of inferiors highlighting for use as our own.  This is done
;;; ex post facto, since it may require the bounding box of inferiors without explicit
;;; :highlighting-boxes.
(defun-in-flavor (compute-group-highlighting-boxes group-entity) ()
  (let ((total nil))
    (labels ((add-one-presentation (presentation)
	       (let ((highlighting-boxes (dw:displayed-presentation-highlighting-boxes
					   presentation)))
		 (cond (highlighting-boxes
			(loop for (key val) on highlighting-boxes by 'cddr
			      do (setf (getf total key)
				       (nconc (copy-list val) (getf total key)))))
		       ((dw:displayed-presentation-single-box presentation)
			(push (multiple-value-list
				(dw:box-edges (dw:presentation-displayed-box presentation)))
			      (getf total :boxes)))
		       (t
			(map () #'add-one-presentation
			     (dw:presentation-inferiors presentation)))))))
      (dolist (entity entities)
	(let ((presentation (graphic-entity-presentation entity)))
	  (when presentation
	    (add-one-presentation presentation)))))
    total))

(define-presentation-type imploded-entity () )

(defmethod (group-entity-implode group-entity) (new-entities)
  (setq entities new-entities
	handles (loop for entity in entities
		      append (graphic-entity-handles entity))
	presentation (send *standard-output* :implode-presentations
			   (loop for entity in entities
				 as presentation = (graphic-entity-presentation entity)
				 do (setf (dw:presentation-type presentation)
					  'imploded-entity)
				 collect presentation)
			   :object self :type (entity-presentation-type self)
			   :highlighting-boxes (compute-group-highlighting-boxes))))

(defmethod (group-entity-explode group-entity) ()
  (when presentation
    (dolist (inferior-presentation (dw:presentation-inferiors presentation))
      (when (eq (dw:presentation-type inferior-presentation) 'imploded-entity)
	(setf (dw:presentation-type inferior-presentation)
	      (entity-presentation-type (dw:presentation-object inferior-presentation)))))
    (send *standard-output* :explode-presentation presentation)
    (setq presentation nil))
  (setq handles nil)
  (prog1 entities (setq entities nil)))

(defun entities-bounding-box-edges (entities &rest args)
  (declare (arglist entities &key (stream *standard-output*) (force-computation nil)))
  (let (min-left max-top max-right min-bottom)	;Note Cartesian orientation
    (flet ((add-edges (entity)
	      (multiple-value-bind (left top right bottom)
		  (apply #'entity-bounding-box-edges entity args)
		(when (or (null min-left) (< left min-left))
		  (setq min-left left))
		(when (or (null max-top) (> top max-top))
		  (setq max-top top))
		(when (or (null max-right) (> right max-right))
		  (setq max-right right))
		(when (or (null min-bottom) (< bottom min-bottom))
		  (setq min-bottom bottom)))))
      (map () #'add-edges entities))
    (values min-left max-top max-right min-bottom)))

(defmethod (entity-bounding-box-edges group-entity) (&rest args)
  (apply #'entities-bounding-box-edges entities args))

(defmethod (entity-copy-instance-variables basic-group-entity :after) (ignore)
  (setq entities (map 'list #'entity-copy entities)))

;;; Should not be asked this, we do things a little differently.
(defmethod (entity-highlighting-boxes group-entity) () (values nil t))

(defmethod (entity-output-for-bounding-box basic-group-entity) ()
  (map () #'entity-output-for-bounding-box entities))

(defmethod (entity-outline basic-group-entity) ()
  (map () #'entity-outline entities))

(defmethod (entity-output group-entity) ()
  (when (setq presentation (dw:with-output-as-presentation (:object self
							    :type (entity-presentation-type
								    self))
			     (map () #'entity-output entities)))
    (dolist (inferior (dw:presentation-inferiors presentation))
      (setf (dw:presentation-type inferior) 'imploded-entity))
    (setf (dw:displayed-presentation-highlighting-boxes presentation)
	  (compute-group-highlighting-boxes))))

(defmethod (entity-output-1 group-entity) ()
  (destructuring-bind (&key pobject ptype presentable)
	presentation-data
      (if (and presentable
	       1;; Not drawing to the graphic-editor drawing pane
0	       (let* ((stream (si:follow-syn-stream *standard-output*))
		      (superior (send-if-handles stream :superior)))
		 (or (not superior)
		     (neq (send-if-handles superior :pane-name stream) 'drawing))))
	  (dw:with-output-as-presentation (:object pobject
					   :type ptype
					   :single-box t)
	    (map () #'entity-output-1 entities))
	  (map () #'entity-output-1 entities))))

(defmethod (entity-possible-own-options group-entity) ()
  (reduce #'intersection (map 'list #'grouped-entity-possible-common-options entities)))

(defmethod (entity-own-option group-entity :otherwise) (key)
  (entity-own-option (first entities) key))

(defmethod (entity-choose-own-option group-entity :otherwise) (key &rest args)
  (apply #'entity-choose-own-option (first entities) key args))

(defmethod (entity-save-options group-entity) (own-options)
  (entity-save-options (first entities) own-options))

(defmethod (graphic-entity-outline-drawing-options group-entity) ()
  (graphic-entity-outline-drawing-options (first entities)))

(defmethod (graphic-entity-inside-drawing-options group-entity) ()
  (graphic-entity-inside-drawing-options (first entities)))

(defmethod (entity-set-options group-entity) (own-options outline-options inside-options)
  (declare (ignore outline-options inside-options))
  (loop for (keyword value) on own-options by 'cddr
	;; When compiling without this system loaded first, this setf will generate a compiler
	;; warning.  I don't know how to instruct the flavor system to make the right setf
	;; form from the :method-combination option that defines it.
	do (setf (entity-own-option self keyword) value)))

(defmethod (entity-transform-internal basic-group-entity) (&rest args)
  (dolist (entity entities)
    (apply #'entity-transform-internal entity args)))

(defmethod (entity-reset-handles basic-group-entity) ()
  (setq handles (loop for entity in entities
		      do (entity-reset-handles entity)
		      nconc (loop for handle in (graphic-entity-handles entity)
				  collect (multiple-value-bind (x y)
					      (entity-handle-position handle)
					    (make-entity-handle self handle x y))))))

(defmethod (entity-input-handle-motion basic-group-entity) (handle &rest args)
  (let ((real-handle (entity-handle-key handle)))
    (apply #'entity-input-handle-motion (entity-handle-entity real-handle) real-handle args)))

(defmethod (entity-can-move-handle basic-group-entity) (handle)
  (let ((real-handle (entity-handle-key handle)))
    (entity-can-move-handle (entity-handle-entity real-handle) real-handle)))

(defmethod (entity-move-handle-internal basic-group-entity) (handle dx dy)
  (let ((real-handle (entity-handle-key handle)))
    (entity-move-handle-internal (entity-handle-entity real-handle) real-handle dx dy)))

(defmethod (entity-variable-values-internal basic-group-entity) ()
  (list :entities entities))

(defmethod (entity-code basic-group-entity) ()
  (destructuring-bind (&key ptype pobject presentable)
      presentation-data
    (if presentable
	(multiple-value-bind (object-generating-form type-generating-form)
	    (graphics::make-presentation-object-printable pobject ptype)
	  `(dw:with-output-as-presentation
	       (:object ,object-generating-form
		:type ',type-generating-form
		:single-box t)
	     ,@(map 'list #'entity-code entities)))
	`(progn ,@(map 'list #'entity-code entities)))))

(compile-flavor-methods group-entity)
