;;; -*- Mode: LISP; Syntax: Common-LISP; Package: Graphic-editor; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(defflavor drawing
	(name
	 (file nil)
	 (modified-p nil)
	 (entities (make-array 100 :fill-pointer 0))	;This is an array, to add to end.
	 (selected-entities ())			;This is just a set, though.
	 (view-transform (copy-seq graphics:*identity-transform*))
	 (sketch-p nil))
	()
  (:constructor make-drawing (&key name))
  :initable-instance-variables
  :writable-instance-variables)

(defmethod (sys:print-self drawing) (stream ignore ignore)
  (sys:printing-random-object (self stream :typep)
    (write-string name stream)))


(dw:define-program-framework graphic-editor
  :select-key #\G
  :command-definer t
  :top-level (graphic-editor-top-level)
  :inherit-from (dw:help-program undo-program)
  :command-table (:inherit-from '("help-program" "undo-program" "accept-values-pane"))
  :help graphic-editor-help

  :panes
   ((title :title :redisplay-function 'draw-title :redisplay-after-commands nil)
    (interactor :interactor :end-of-page-mode :scroll)
    (drawing :display :typeout-window t
		      :redisplay-function 'display-drawing :redisplay-after-commands nil
		      :margin-components `dw:((margin-ragged-borders )
					      (margin-ruler :margin :left :visibility ())
					      (margin-ruler :margin :top :visibility ())
					      (margin-scroll-bar :shaft-whitespace-thickness 4
								 :history-noun "drawing")
					      (margin-label :margin :bottom
							    :style (:swiss :italic :normal)
							    :string "Drawing-1")
					      (margin-scroll-bar :margin :bottom
								 :history-noun "drawing")
					      (margin-white-borders :thickness 2)))
    (help-menu :command-menu :menu-level :help :columns '(("Help")) :center-p t)
    (undo-menu :command-menu :menu-level :undo :rows '(("Undo" "Redo" "Skip")))
    (io-menu :command-menu :menu-level :io :columns '(("Kill Drawing" "Rename Drawing"
						       "Select Drawing")
						      ("Read File" "Write File")
						      ("Hardcopy" "Done")))
    (selection-menu :command-menu :menu-level :selection
				  :columns '(("Deselect" "Select")
					     ("Select All" "Select Region")
					     ("Group" "Ungroup")))
    (main-menu :command-menu :columns 4)
    (view-menu :command-menu :menu-level :view)
    (options-menu :accept-values :accept-values-function 'accept-values-edit-options
				 :redisplay-after-commands t)
    (registers :display :redisplay-function 'draw-registers
		        :redisplay-after-commands nil
			:margin-components `dw:((margin-borders )
						(margin-white-borders )
						(margin-label :string "Registers"
							      :style (:dutch :italic :normal))
						))
    (shapes-menu :display :redisplay-function 'draw-shapes-menu
			  :redisplay-after-commands nil)
    )

  :configurations
   '((main
       (:layout (main :column row-1 row-2 interactor)
	(row-1 :row title help-menu)
	(row-2 :row drawing menus)
	(menus :column undo-menu io-menu selection-menu main-menu view-menu
		       options-menu registers shapes-menu))
       (:sizes
	 (main (row-1 1 :lines title) (interactor 4 :lines)
	   :then (row-2 :even))
	 (row-1 (help-menu #,*menu-column-fraction*)
	   :then (title :even))
	 (row-2 (menus #,*menu-column-fraction*)
	   :then (drawing :even))
	 (menus (options-menu 7 :lines)
		(undo-menu :ask-window self :size-for-pane undo-menu)
		(io-menu :ask-window self :size-for-pane io-menu)
		(selection-menu :ask-window self :size-for-pane selection-menu)
		(view-menu :ask-window self :size-for-pane view-menu)
		(main-menu :ask-window self :size-for-pane main-menu)
	   :then (registers .35)
	   :then (shapes-menu :even)))))

  :state-variables
   ((shape-samples nil)
    (shape-samples-transform nil)

    (displayed-handles-mode nil)
    (displayed-selected-handles nil)
    (displayed-unselected-handles nil)

    (current-drawing nil)

    (last-shape-created nil)
    (outline-drawing-defaults *initial-outline-drawing-options*)
    (inside-drawing-defaults *initial-inside-drawing-options*)
    (global-entity-defaults (collect-initial-global-entity-option-set))

    (display-handles :bounding-box)
    (display-grid-p nil)
    (grid-size 1)
    (displayed-grid-size nil)
    (display-mouse-position nil)
    (quantize-mouse-position nil)
    (display-rulers-p nil)
    (scale-unit :centimeter)
    (ruler-major-scale 1)
    (ruler-minor-scale 1/10)
    (rulers-displayed-p nil)
    (display-hardcopy-outline nil)
    (hardcopy-outline-displayed nil)
    (drawing-transform (copy-seq graphics:*identity-transform*))
    (show-position-transform (copy-seq graphics:*identity-transform*))
    (last-set-mouse-type nil)
    (last-transform-type nil)
    (mouse-quantize-function nil)

    (registers (make-array 3 :fill-pointer 0))

    (mailbox nil)				;For simple synchronization.

    (experimental-slot-1 nil)			;For the experiments system.
    (experimental-slot-2 nil)
    (experimental-slot-3 nil)

    )

   :other-defflavor-options ((:functions make-new-drawing redisplay-drawing redisplay-handles
					 select-drawing))
   )

(loop for (name char) in '((:add-to-selected #\Shift-Mouse-Left)
			   (:create-line #\Mouse-Middle)
			   ;;--- add-to-selected, ignore blankness
			   (:create-another-of-last-shape #\Meta-Mouse-Left)	;Control-?
			   ;; :create-another-of-this-shape 
			   (:copy-entity #\Mouse-Middle)
			   ;; :pop-up-shapes-menu 
			   )
      do (setf (dw:mouse-char-for-gesture name) char))

(defun current-graphic-editor (&rest args)
  (apply #'dw:current-program :type 'graphic-editor args))

(define-presentation-type window-wakeup-synchronous-select-new-drawing ()
   :expander 'dw::window-wakeup)

(defun-in-flavor (graphic-editor-window-wakeup graphic-editor) (blip)
  (dw:presentation-blip-case blip
    (graphic-input:window-wakeup-synchronous-scroll
      (destructuring-bind (window left top)
	  (dw:presentation-blip-object blip)
	(multiple-value-bind (width height)
	    (dw:box-size (send window :cursor-viewport))
	  (let ((dx (* width (ceiling (max 0 (- left)) width)))
		(dy (* height (ceiling (max 0 (- top)) height))))
	    (when (or (plusp dx) (plusp dy))
	      (let ((transform (copy-seq (drawing-view-transform current-drawing))))
		(incf (fifth transform) dx)
		(decf (sixth transform) dy)
		(setf (drawing-view-transform current-drawing) transform))
	      (redisplay-drawing)
	      (incf left dx)
	      (incf top dy)))
	  (when displayed-grid-size
	    (graphic-input::make-grid-large-enough window (* (first show-position-transform)
							     displayed-grid-size)
						   left top
						   (+ left width) (+ top height))))
	(send window :set-viewport-position left top)))
    (window-wakeup-synchronous-select-new-drawing
      (destructuring-bind (file-name name)
	  (dw:presentation-blip-object blip)
	(select-drawing (find-drawing-named-1 self file-name name)))
      (throw 'dw::return-to-command-loop t))
    (otherwise
      (dw:help-program-check-for-help-wakeup blip))))

(defun-in-flavor (mouse-quantize-function graphic-editor)
		 (x y &optional (grid-p quantize-mouse-position))
  (when grid-p
    (macrolet ((round-to (n)
		 `(* grid-size (round ,n grid-size))))
      (setq x (round-to x)
	    y (round-to y))))
  (values x y))

(defun-in-flavor (mouse-quantize-p graphic-editor) ()
  quantize-mouse-position)

(defmethod (graphic-editor-top-level graphic-editor) (&rest args)
  (when (null current-drawing)
    (select-drawing (make-new-drawing)))
  (let ((drawing (dw:get-program-pane 'drawing)))
    (send drawing :set-scroll-position-function
	  #'(lambda (window &rest args)
	      (apply #'graphic-input:grid-scroll-position-function window 
		     (when displayed-grid-size
		       (* (first show-position-transform) displayed-grid-size))
		     args)))
    (graphic-input:set-window-special-mouse-blinker drawing
						    :show-position display-mouse-position
						    :quantize-position (mouse-quantize-p))
    (setq mouse-quantize-function #'mouse-quantize-function)
    (flet ((update-drawing-mouse-blinker ()
	     (declare (sys:downward-function))
	     (graphic-input:update-window-mouse-blinker drawing
							:show-position display-mouse-position
							:quantize-position (mouse-quantize-p)
							:quantization-function
							 mouse-quantize-function
							:transform show-position-transform)))
    (apply #'dw:default-command-top-level self
	   :window-wakeup #'graphic-editor-window-wakeup
	   :input-wait-handler #'update-drawing-mouse-blinker
	   args))))

(defun-in-flavor (call-with-graphic-editor-mouse-blinker-options graphic-editor)
		 (function &rest args)
  (let ((nargs (+ (length args) 8)))
    (sys:%start-function-call function return nargs nil)
    (loop while args do (sys:%push (pop args)))
    (sys:%push :show-position) (sys:%push display-mouse-position)
    (sys:%push :position-transform) (sys:%push show-position-transform)
    (sys:%push :quantize-position) (sys:%push (mouse-quantize-p))
    (sys:%push :quantization-function) (sys:%push mouse-quantize-function)
    (sys:%finish-function-call function return nargs nil)))

(defmethod (draw-title graphic-editor) (stream)
  (dw:with-output-as-presentation (:stream stream
				   :object 'graphic-editor
				   :type 'dw:program-name)
    (send stream :display-centered-string "Graphic Editor")))

(defmethod (draw-shapes-menu graphic-editor) (*standard-output*)
  (multiple-value-setq (shape-samples shape-samples-transform)
    (layout-entity-samples *standard-output* shape-samples shape-samples-transform))
  (graphics:with-scan-conversion-mode (t :sketch t)
    (graphics:with-graphics-transform (t (third shape-samples-transform))
      (map () #'entity-shape-sample-draw shape-samples))))

(defun-in-flavor (redisplay-shapes-menu graphic-editor) ()
  (let ((*standard-output* (dw:get-program-pane 'shapes-menu)))
    (dolist (sample shape-samples)
      (entity-shape-sample-reset-drawing-defaults sample
						  global-entity-defaults
						  outline-drawing-defaults
						  inside-drawing-defaults)))
  (send dw:*program-frame* :redisplay-pane 'shapes-menu t))

(defmacro with-sample-shape-highlighted ((shape-name) &body body)
  `(let (.sample-highlighted. .sample-highlighted-window.)
     (unwind-protect
	 (progn
	   (multiple-value-setq (.sample-highlighted. .sample-highlighted-window.)
	     (highlight-sample-shape ,shape-name))
	   . ,body)
       (when .sample-highlighted.
	 (entity-shape-sample-xor-highlighting .sample-highlighted.
					       .sample-highlighted-window.)))))

(defun-in-flavor (highlight-sample-shape graphic-editor) (shape-name)
  (let* ((window (dw:get-program-pane 'shapes-menu))
	 (sample (find shape-name shape-samples :key #'entity-shape-sample-shape)))
    (when sample
      (entity-shape-sample-xor-highlighting sample window)
      (values sample window))))

;;;; Buffers and files

;;; List of drawings shared among all graphic editors, like editor buffers.
;;; Could be partioned by console or something like that if separation were desired.
(defvar *all-loaded-drawings* ())
(defvar *drawing-unique-id* 0)

(defmethod (graphic-editor-loaded-drawings graphic-editor) () *all-loaded-drawings*)

(defmethod ((setf graphic-editor-loaded-drawings) graphic-editor) (new-list)
  (setq *all-loaded-drawings* new-list))

(defun-in-flavor (redisplay-drawing graphic-editor) (&key preserve-viewport)
  (multiple-value-bind (x y)
      (send dw:*program-frame* :send-pane 'drawing :viewport-position)
    (send dw:*program-frame* :redisplay-pane 'drawing t)
    (when preserve-viewport
      (send dw:*program-frame* :send-pane 'drawing :set-viewport-position x y))))

(defun-in-flavor (drawing-new-label graphic-editor) ()
  (send (dw:get-program-pane 'drawing) :set-label (drawing-label-name current-drawing)))

(defun-in-flavor (select-drawing graphic-editor) (drawing)
  (without-interrupts
    ;; Move to the front of the history.
    (setf (graphic-editor-loaded-drawings self)
	  (cons drawing (delete drawing (graphic-editor-loaded-drawings self)))))
  (setq current-drawing drawing)
  (drawing-new-label)
  (redisplay-drawing))

(defun-in-flavor (set-drawing-modified graphic-editor) (&optional (modified-p t))
  (unless (eq (drawing-modified-p current-drawing) modified-p)
    (setf (drawing-modified-p current-drawing) modified-p)
    (drawing-new-label)))

(defun-in-flavor (do-undoably-modifying graphic-editor) (&rest args)
  (set-drawing-modified)
  (apply #'do-undoably args))

(defun-in-flavor (make-new-drawing graphic-editor) (&key name activate )
  (if name
      (when (find name (graphic-editor-loaded-drawings self) :key #'drawing-name
							     :test #'string-equal)
	(dw:command-error "There is already a drawing named ~A." name))
      (setq name (format nil "Drawing-~D" (without-interrupts (incf *drawing-unique-id*)))))
  (let ((drawing (make-drawing :name name)))
    (when activate
      (without-interrupts
	(push drawing (graphic-editor-loaded-drawings self))))
    drawing))

(defmethod (drawing-label-name drawing) ()
  (format nil "~A~@[ (~A)~]~:[~; [Not saved]~]" name file modified-p))

(defmethod (drawing-clear drawing) ()
  (setf (fill-pointer entities) 0)
  (setq selected-entities nil))

(defmethod (drawing-binary-encoding drawing) ()
  (multiple-value-bind (left nil nil bottom)
      (entities-bounding-box-edges entities :force-computation t)
    (graphics:binary-encode-graphics-to-array
      #'(lambda (*standard-output*)
	  (graphics:with-scan-conversion-mode (t :sketch sketch-p)
	    (graphics:with-graphics-translation (t (- left) (- bottom))
	      (map () #'entity-output-1 entities)))))))

(defmethod (drawing-code drawing) ()
  `(defun ,(intern (string-upcase (nsubstitute #\- #\space (string-append "draw-" name)))) ()
     . ,(map 'list #'entity-code entities)))

(defmethod (print-drawing-code drawing) (&optional (stream *standard-output*))
  (format stream "~&;;; Drawing ~A" name)
  (when file
    (format stream " from ~A" (or (and (not modified-p)
				       (first (get-drawing-file-info file)))
				  file)))
  (multiple-value-bind (left top right bottom)
      (let ((stream *terminal-io*))		;Not stream
	(entities-bounding-box-edges entities :stream stream :force-computation t))
    (format stream "~%;;; Bounding box ~D,~D  ~D,~D" left top right bottom))
  (format stream "~%(~S ~S ~S"
	  'defun
	  (intern (string-upcase (nsubstitute #\- #\space (string-append "draw-" name))))
	  '(&optional (*standard-output* *standard-output*)))
  (format stream "~%  (~S (~S ~S ~S)" 'graphics:with-scan-conversion-mode 't :sketch sketch-p)
  (labels ((one-entity (entity &optional (indent 4))
	     (format stream "~%~@vT;; ~A~%~@vT" indent (graphic-entity-name entity) indent)
	     (if (not (typep entity 'basic-group-entity))
		 (let ((code (entity-code entity)))
		   (if (eq (car code) 'dw:with-output-as-presentation)
		       (destructuring-bind (function arglist &rest body) code
			 (format stream "(~S ~%~vT"
				 function
				 (+ indent 4))
			 (apply #'format stream "(~@[~~S ~S~@{~%~S ~S~}~~])"
				arglist)
			 (format stream "~%~vT~~{~S~}~)"
				 (+ indent 2)
				 body))
		       (prin1 code stream)))
		 (destructuring-bind (&key ptype pobject presentable)
		     (graphic-entity-presentation-data entity)
		   (if presentable
		       (multiple-value-bind (object-generating-form type-generating-form)
			   (graphics::make-presentation-object-printable pobject ptype)
			 (format stream "(~S ~%~vT(~~S ~S~@{~%~S ~S~}~)"
				 'dw:with-output-as-presentation
				 (+ indent 4)
				 :object object-generating-form
				 :type `',type-generating-form
				 :single-box t))
		       (format stream "(~S" 'progn))
		   (dolist (entity (basic-group-entity-entities entity))
		     (one-entity entity (+ indent 2)))
		   (format stream ")")))))
    (map () #'one-entity entities))
  (format stream "))~%"))

(defmethod (draw-drawing drawing) (&key (stream *standard-output*)
					(if-too-large :clip) (presentations t)
					(unit :pixel) (float-origin nil)
					(set-eps-bounding-box nil))
  (labels ((do-output (stream)
	     (ecase unit
	       (:pixel
		 (do-output-1 stream))
	       (:point
		 (graphics:with-graphics-scale (stream (/ *pixels-per-point*))
		   (do-output-1 stream)))))
	   (do-output-1 (stream)
	     (if float-origin
		 (multiple-value-bind (dleft nil nil dbottom) (drawing-edges)
		   (graphics:with-graphics-translation (stream (- dleft) (- dbottom))
		     (do-output-2 stream)))
		 (do-output-2 stream)))
	   (do-output-2 (stream)
	     (let ((*standard-output* stream))
	       (map () (if presentations #'entity-output #'entity-output-1) entities)))
	   (drawing-edges ()
	     ;; Don't pass in real stream, it might not handle right metrics.
	     (entities-bounding-box-edges entities :stream *terminal-io*
						   :force-computation t))
	   (stream-edges (&optional (unit :device))
	     (ecase unit
	       (:device
		 (values (send stream :bounding-box-left)
			 (send stream :bounding-box-top)
			 (send stream :bounding-box-right)
			 (send stream :bounding-box-bottom)))
	       (:pixel
		 (values (* (send stream :bounding-box-left) *pixels-per-point*)
			 (* (send stream :bounding-box-top) *pixels-per-point*)
			 (* (send stream :bounding-box-right) *pixels-per-point*)
			 (* (send stream :bounding-box-bottom) *pixels-per-point*)))))
	   (set-eps-bounding-box (&rest edges)
	     (when set-eps-bounding-box
	       (unless edges
		 (setq edges (multiple-value-list (drawing-edges))))
	       (setq edges (map 'list #'(lambda (coord) (/ coord *pixels-per-point*)) edges))
	       (rotatef (second edges) (fourth edges))
	       (send stream :set-eps-bounding-box edges))))
    (ecase if-too-large
      (:clip
	(set-eps-bounding-box)
	(do-output stream))
      (:scale
	(multiple-value-bind (dleft dtop dright dbottom) (drawing-edges)
	  (if (multiple-value-bind (hleft htop hright hbottom)
		  (stream-edges :pixel)
		(or (< dleft hleft)
		    (< dbottom hbottom)
		    (> dright hright)
		    (> dtop htop)))
	      (multiple-value-bind (hleft htop hright hbottom)
		  (stream-edges)
		(graphics:with-graphics-translation (stream (/ (+ hleft hright) 2)
							    (/ (+ htop hbottom) 2))
		  (graphics:with-graphics-scale (stream (min (/ (- hbottom htop)
								(- dbottom dtop))
							     (/ (- hright hleft)
								(- dright dleft))))
		    (graphics:with-graphics-translation (stream (- (/ (+ dleft dright) 2))
								(- (/ (+ dtop dbottom) 2)))
		      (do-output-1 stream)))))
	      (set-eps-bounding-box dleft dtop dright dbottom)
	      (do-output stream))))
      (:multiple-pages
	(multiple-value-bind (dleft dtop dright dbottom) (drawing-edges)
	  (multiple-value-bind (hleft htop hright hbottom)
	      (stream-edges :pixel)
	    (graphics:with-graphics-scale (stream (ecase unit
						    (:pixel 1)
						    (:point (/ *pixels-per-point*))))
	      (if (or (< dleft hleft)
		      (< dbottom hbottom)
		      (> dright hright)
		      (> dtop htop))
		  (let ((hwidth (- hright hleft))
			(hheight (- htop hbottom))
			(first-page-p t))
		    (loop for y downfrom (1- (ceiling dtop hheight))
				downto (floor dbottom hheight)
			  do
		      (loop for x from (floor dleft hwidth) to (1- (ceiling dright hwidth))
			    do
			(if first-page-p
			    (setq first-page-p nil)
			    (send stream :eject-page))
			(graphics:with-graphics-translation (stream (- (* x hwidth))
								    (- (* y hheight)))
			  (do-output-1 stream)))))
		  (set-eps-bounding-box dleft dtop dright dbottom)
		  (do-output-1 stream)))))))))

(define-presentation-type drawing ((&key editor))
   :no-deftype t
   :parser ((stream)
	    (unless editor
	      (setq editor (current-graphic-editor)))
	    (dw:complete-from-sequence (graphic-editor-loaded-drawings editor) stream
				       :name-key #'drawing-name))
   :printer ((drawing stream)
	     (write-string (drawing-name drawing) stream))
   :description "a drawing")

(defun choose-drawing (&key (prompt nil)
			    (editor (current-graphic-editor))
			    (or-new nil)
			    (default nil))
  (multiple-value-bind (drawing-alist drawing-type)
      (graphic-editor-loaded-drawings-alist editor)
    (let ((total-type (if or-new `((token-or-type (:new) ,drawing-type)) drawing-type)))
      (dw:menu-choose-from-drawer
	#'(lambda (stream &rest ignore &aux presentations)
	    (loop for (file . drawings) in drawing-alist do
	      (when file
		(with-character-face (:italic stream)
		  (format stream "~A:~%" file)))
	      (dolist (drawing drawings)
		(write-string "  " stream)
		(push (present drawing drawing-type :stream stream) presentations)
		(terpri stream)))
	    (when or-new
	      (with-character-face (:bold stream)
		(present :new total-type :stream stream))
	      (terpri stream))
	    presentations)
	total-type
	:default default
	:prompt prompt))))

(defun graphic-editor-loaded-drawings-alist (editor)
  (declare (values alist type))
  (let ((drawing-alist ())
	(drawing-type `((drawing :editor ,editor))))
    (dolist (drawing (graphic-editor-loaded-drawings editor))
      (let* ((file (drawing-file drawing))
	     (elem (assoc file drawing-alist)))
	(when (null elem)
	  (push (setq elem (ncons file)) drawing-alist))
	(push drawing (rest elem))))
    (setq drawing-alist (sort drawing-alist #'(lambda (file-1 file-2)
						(cond ((null file-2) nil)
						      ((null file-1) t)
						      (t (string-lessp file-1 file-2))))
			      :key #'car))
    (dolist (elem drawing-alist)
      (setf (cdr elem) (sort (cdr elem) #'string-lessp :key #'drawing-name)))
    (values drawing-alist drawing-type)))

(defmethod (select-drawing-default graphic-editor) () 
  (find current-drawing (graphic-editor-loaded-drawings self) :test #'neq))

(define-graphic-editor-command (com-select-drawing )
    ((drawing `((type-or-string ((drawing :editor ,self))))
	      :default (select-drawing-default self)
	      :prompt "A drawing or a name for a new drawing"))
   (when (stringp drawing)
     (setq drawing (make-new-drawing :name drawing)))
   (select-drawing drawing))

(dw:define-command-menu-handler ("Select Drawing" graphic-editor :io
				 :gesture (:left :right)
				 )
				(&rest args &key window (gesture :left) &allow-other-keys)
  (block select
    (case dw:*command-menu-test-phase*
      ((t) (throw 'dw:command-menu-test-phase `(com-select-drawing)))
      ((:documentation)
       (case gesture
	 (:right
	  (throw 'dw:command-menu-test-phase "Menu for Select drawing"))
	 (otherwise
	  (let ((drawing (let ((editor (current-graphic-editor :window window :error-p nil)))
			   (when editor
			     (select-drawing-default editor)))))
	    (when drawing
	      (throw 'dw:command-menu-test-phase `(com-select-drawing ,drawing)))))))
      (otherwise
	(when (eq gesture :right)
	  (let* ((editor (current-graphic-editor :window window))
		 (drawing (choose-drawing :prompt "Select drawing"
					  :editor editor
					  :default (select-drawing-default editor)
					  :or-new t)))
	    (unless (eq drawing :new)
	      (return-from select
		(and drawing `(com-select-drawing ,drawing))))))))
    (apply #'dw:standard-command-menu-handler 'com-select-drawing
	   :mode (and (eq gesture :right) :keyboard) args)))

(define-presentation-to-command-translator com-select-drawing (drawing) (drawing)
  `(com-select-drawing ,drawing))

(define-graphic-editor-command (com-show-loaded-drawings ) ()
   (fresh-line)
   (multiple-value-bind (alist type)
       (graphic-editor-loaded-drawings-alist self) 
     (loop for (file . drawings) in alist do
       (if file
	   (format t "In file ~A:~%" file)
	   (format t "Not associated with any file:~%"))
       (dolist (drawing drawings)
	 (write-string "  ")
	 (present drawing type)
	 (when (drawing-modified-p drawing)
	   (write-string " [Not saved]"))
	 (terpri)))))

(define-graphic-editor-command (com-kill-drawing ) ((drawing `((drawing :editor ,self))
							     :default current-drawing
							     :confirm t))
   (let ((selected-p (eq drawing current-drawing)))
     (undoably (drawing selected-p) (format nil "Kill drawing ~A" (drawing-name drawing))
       (progn
	 (without-interrupts
	   (setf (graphic-editor-loaded-drawings self)
		 (delete drawing (graphic-editor-loaded-drawings self))))
	 (when selected-p
	   (select-drawing (or (first (graphic-editor-loaded-drawings self))
			       (make-new-drawing)))))
       (progn
	 (without-interrupts
	   (pushnew drawing (graphic-editor-loaded-drawings self)))
	 (when selected-p
	   (select-drawing drawing))))))

(dw:define-command-menu-handler ("Kill Drawing" graphic-editor :io
				 :gesture (:left :right))
				(&rest args &key window (gesture :left) &allow-other-keys)
  (if (eq gesture :right)
      (case dw:*command-menu-test-phase*
	((t) (throw 'dw:command-menu-test-phase `(com-kill-drawing)))
	((:documentation) (throw 'dw:command-menu-test-phase "Menu for Kill drawing"))
	(otherwise
	  (let ((drawing (choose-drawing :prompt "Kill drawing"
					 :editor (current-graphic-editor :window window))))
	    (when drawing
	      `(com-kill-drawing ,drawing)))))
      (apply #'dw:standard-command-menu-handler 'com-kill-drawing args)))

(define-presentation-to-command-translator com-kill-drawing (drawing :gesture ()) (drawing)
  `(com-kill-drawing ,drawing))

(defun-in-flavor (default-drawing-pathname graphic-editor) ()
  (or (loop for drawing in (graphic-editor-loaded-drawings self)
	    thereis (drawing-file drawing))
      (send (si:pathname-history-first-pathname) :new-type :bin)))

(defun-in-flavor (file-drawings graphic-editor) (file)
  (remove-if-not #'(lambda (drawing)
		     (eq (drawing-file drawing) file))
		 (graphic-editor-loaded-drawings self)))

(define-graphic-editor-command (com-read-file :menu-accelerator t :menu-level :io)
    ((files '((sequence pathname)) :default (let ((path (default-drawing-pathname)))
					      (and path (list path)))
				   :confirm t))
   ;; Remove logical pathnames and canonicalize .newest truename version into .newest
   ;; if it is the newest and we have not read in .newest.  Both of these things that
   ;; Zmacs does in the corresponding circumstances.  At the same time, expand wildcards.
   (let* ((expanded-files (flet ((canonicalize (file)
				   (setq file (send file :translated-pathname))
				   (when (and (neq (send file :version) :newest)
					      (null (get-drawing-file-info file))
					      (eq file (probe-file
							 (send file :new-version :newest))))
				     (setq file (send file :new-version :newest)))
				   file))
			    (loop for file in files
				  nconc (if (send file :wild-p)
					    (map 'list #'canonicalize (directory file))
					    (list (canonicalize file))))))
	  (old-drawings (loop for file in expanded-files
			      append (file-drawings file)))
	  (new-drawings (loop for file in expanded-files
			      append (read-drawings-from-file file))))
     (when (null new-drawings)
       (dw:command-error "There are no drawings in ~{~A~^, ~}." files))
     (let ((old-not-present (set-difference old-drawings new-drawings
					    :key #'drawing-name :test #'string-equal))
	   (old-not-saved (remove-if-not #'drawing-modified-p old-drawings)))
       (when (or old-not-present old-not-saved)
	 (when old-not-present
	   (format t "~&The drawing~P ~{~A~^, ~} 
 from the same file~P ~:[is~;are~] not in the new version just read in and will be lost.~%"
		   (length old-not-present) (map 'list #'drawing-name old-not-present)
		   (length expanded-files) (cdr old-not-present)))
	 (when old-not-saved
	   (format t "~&The drawing~P ~{~A~^, ~} 
 from the same file~P ~:[has~;have~] not been saved out.  The changes will be lost.~%"
		   (length old-not-saved) (map 'list #'drawing-name old-not-saved)
		   (length expanded-files) (cdr old-not-saved)))
	 (case (let ((*query-io* *standard-input*))
		 (fquery `(:type :readline
			   :choices ((t "Yes")
				     (nil "No")
				     (:menu "Menu")))
			 "Go ahead anyway? "))
	   ((t))
	   ((nil)
	    (signal 'sys:abort))
	   ((:menu)
	    (loop for (drawing . keys)
		      ;; Should use a DW version in the typeout window.
		      in (tv:multiple-choose
			   "Drawing"
			   (loop for drawing in old-drawings
				 collect (list drawing
					       (drawing-name drawing)
					       (copy-list 
						 (cond ((member drawing old-not-present)
							'((:disassociate nil)
							  (:keep t)))
						       ((member drawing old-not-saved)
							'((:disassociate t)))
						       (t
							'((:disassociate nil)))))))
			   '((:disassociate "Disassociate")
			     (:keep "Keep")))
		  do
	      (when keys
		(setq old-drawings (delete drawing old-drawings)))	;Don't kill
	      (when (member :disassociate keys)
		(setf (drawing-file drawing) nil)))))))
     (without-interrupts
       (setf (graphic-editor-loaded-drawings self)
	     (append (set-difference (graphic-editor-loaded-drawings self) old-drawings)
		     new-drawings)))
     (if (null (rest new-drawings))
	 (select-drawing (first new-drawings))
	 (let ((drawing (dw:menu-choose-from-set new-drawings `((drawing :editor ,self))
						 :prompt "Select which drawing:")))
	   (when drawing
	     (select-drawing drawing))))))

(defun-in-flavor (save-drawing-file graphic-editor) (file)
  (let ((drawings (file-drawings file)))
    (let ((truename (write-drawings-to-file drawings file)))
      (format *query-io* "~&Written: ~A.~%" truename))
    (dolist (drawing drawings)
      (setf (drawing-modified-p drawing) nil))))

(define-graphic-editor-command (com-write-file :menu-accelerator t :menu-level :io)
    ((file 'pathname :default (default-drawing-pathname) :confirm t))
   (setq file (send file :translated-pathname))
   (unless (eq (drawing-file current-drawing) file)
     (setf (drawing-file current-drawing) file))
   (save-drawing-file file)
   (drawing-new-label))

(define-graphic-editor-command (com-save-drawing )
    ((drawings `((token-or-type (:all) ((sequence ((drawing :editor ,self))))))
	       :default (list current-drawing))
     &key
     (query 'boolean
	    ;; Have to confirm if saving all, or if saving something unmodified, or if saving
	    ;; modified others at the same time implicitly.
	    :default (or (eq drawings :all)
			 (loop for drawing in drawings
			       thereis (or (not (drawing-modified-p drawing))
					   (loop for other in (file-drawings
								(drawing-file drawing))
						 thereis (and (neq other drawing)
							      (drawing-modified-p other))))))
	    :documentation "Ask about saving files"))
   (save-drawing-execute dw:*program* (save-drawing-query dw:*program* drawings query)))

(defmethod (save-drawing-query graphic-editor) (drawings query)
   (when (eq drawings :all)
     (setq drawings (remove-if-not #'(lambda (drawing)
				       (and (drawing-file drawing)
					    (drawing-modified-p drawing)))
				   (graphic-editor-loaded-drawings self))))
   (let ((files (loop for drawing in drawings
		      collect (or (drawing-file drawing)
				  (setf (drawing-file drawing)
					(accept 'pathname :default (default-drawing-pathname)
						:prompt `("Save ~A to what file"
							  ,(drawing-name drawing))))))))
     (setq files (delete-duplicates files))
     (let-if query ((*query-io* *standard-output*))	;Use typeout window
       (when query
	 (setq files (remove-if-not
		       #'(lambda (file)
			   (fquery () "~Q"
			     #'(lambda ()
				 (let* ((drawings (file-drawings file))
					(unmodified (remove-if #'drawing-modified-p drawings))
					(modified (set-difference drawings unmodified)))
				   (format t "Save ")
				   (flet ((show-list (list)
					    (format t "modified drawing~P " (length list))
					    (format-textual-list list
					      #'(lambda (drawing stream)
						  (present drawing 'drawing :stream stream))
					      :conjunction "and"
					      :filled t :after-line-break "  ")
					    (format t " ")))
				     (when modified
				       (show-list modified))
				     (when unmodified
				       (when modified
					 (format t "and "))
				       (format t "un")
				       (show-list unmodified))
				     (when drawings
				       (format t "to "))
				     (format t "file ~A? " file))))))
		       files))))
     files))

(defmethod (save-drawing-execute graphic-editor) (files)
  (dolist (file files)
    (save-drawing-file file))
  (drawing-new-label))

(define-presentation-to-command-translator com-save-drawing (drawing :gesture ()) (drawing)
  `(com-save-drawing (,drawing)))

;;; Name by analogy with zmacs and zmail.
(defun save-all-files ()
  (save-all-files-execute (save-all-files-query)))

(defun save-all-files-query ()
  (let ((dw:*program-frame* (dw:find-program-window 'graphic-editor :create-p nil)))
    (when dw:*program-frame*
      (let ((dw:*program* (send dw:*program-frame* :program)))
	(when (and (loop for drawing in (graphic-editor-loaded-drawings dw:*program*)
			 thereis (and (drawing-file drawing)
				      (drawing-modified-p drawing)))
		   (y-or-n-p "There are modified Graphic Editor drawings, save them? "))
	  (save-drawing-query dw:*program* :all t))))))

(defun save-all-files-execute (files)
  (when files
    (let ((dw:*program-frame* (dw:find-program-window 'graphic-editor :create-p nil)))
      (when dw:*program-frame*
	(let ((dw:*program* (send dw:*program-frame* :program)))
	  (save-drawing-execute dw:*program* files))))))

(si:define-application-logout-initialization save-graphic-editor-buffers-initialization
 ((save-graphic-buffers 'scl:boolean
		       :default t
		       :documentation
		       "Save modified graphic editor buffers before logging out"))
  (when save-graphic-buffers
    (save-all-files-execute (si:application-logout-separate-querying (save-all-files-query)))))

(define-graphic-editor-command (com-rename-drawing :menu-accelerator t :menu-level :io)
    ((new-name 'string :prompt "new name" :default (drawing-name current-drawing) :confirm t))
   (if (string-equal "" new-name)
	   (dw:command-error "Drawings cannot be renamed to the NULL string.")
	   (setf (drawing-name current-drawing) new-name))
   (drawing-new-label))

(define-graphic-editor-command (com-set-drawing-file )
    ((drawing `((drawing :editor ,self)) :default current-drawing)
     (file '((null-or-type pathname)) :default (default-drawing-pathname) :confirm t))
   (when file
     (setq file (send file :translated-pathname))
     (when (and (null (get-drawing-file-info file))
		(probe-file file)
		(yes-or-no-p "Would you like to read ~A in right now? " file))
       (let ((drawings (read-drawings-from-file file)))
	 (without-interrupts
	   (setf (graphic-editor-loaded-drawings self)
	     (append (graphic-editor-loaded-drawings self) drawings))))))
   (setf (drawing-file drawing) file)
   (set-drawing-modified)
   (drawing-new-label))

(defmethod (copy-drawing drawing) (&rest init-options)
  (let ((new (apply #'make-drawing init-options)))
    (let ((new-entities (drawing-entities new)))
      (dotimes (i (fill-pointer entities))
	(vector-push-extend (entity-copy (aref entities i)) new-entities))
      (setf (drawing-selected-entities new)
	    (loop for entity in selected-entities
		  collect (aref new-entities (position entity entities)))))
    (replace (drawing-view-transform new) view-transform)
    (setf (drawing-modified-p new) t)
    new))

(define-graphic-editor-command (com-copy-drawing )
    ((from-drawing 'drawing :default current-drawing)
     (new-name 'string :prompt "new name" :default (drawing-name from-drawing) :confirm t))
   (select-drawing (copy-drawing from-drawing :name new-name)))

(define-graphic-editor-command (com-copy-drawing-to-image)
    ((image-name 'string
		 :prompt "to image"
		 :default (loop for i from 1
				for name = (format nil "~A-Image~[~1;~:;(~:*~D)~]"
						   (drawing-name current-drawing)
						   i)
				unless (images:find-image-named name
								:if-does-not-exist :ignore)
				  return name))
     (scale '(number (0) *)
	    :prompt "scale"
	    :default 1))
   (images:set-default-image
     (images:make-image-from-raster
       (tv:with-output-to-bitmap (stream :graphics-transform (list scale 0 0 (- scale) 0 0))
	 (draw-drawing current-drawing :stream stream))
       :name image-name)))

;;; Perhaps these should be per drawing, too?
(define-command-default *hardcopy-drawing-orientation* :portrait
  ((cl:member :landscape :portrait)) "Hardcopy orientation")
(define-command-default *hardcopy-drawing-if-too-large* :multiple-pages
  ((member :clip :scale :multiple-pages)) "Hardcopy if too large")

(defprop define-hardcopy-command cp:define-command zwei:definition-function-spec-type)

(defmacro define-hardcopy-command ((name . command-options) operands
				   drawings &rest drawing-options)
  `(define-graphic-editor-command (,name . ,command-options)
       (,@operands
	(printer '((token-or-type (:file) sys:printer))
		 :prompt "printer" :default hardcopy:*default-text-printer*)
	(file 'pathname :when (eq printer :file) :prompt "file")
	&key
	(orientation '((cl:member :landscape :portrait))
		     :default *hardcopy-drawing-orientation*
		     :documentation "Orientation to use with respect to the paper")
	(if-too-large '((member :clip :scale :multiple-pages))
		      :default *hardcopy-drawing-if-too-large*
		      :documentation "What to do if the drawing won't all fit."))
      (hardcopy-drawings-internal ,drawings
				  :printer (if (eq printer :file) (list :file file) printer)
				  :orientation orientation
				  :if-too-large if-too-large
				  . ,drawing-options)))

(defun hardcopy-drawings-internal (drawings
				   &key (printer hardcopy:*default-text-printer*)
					(orientation *hardcopy-drawing-orientation*)
					(if-too-large *hardcopy-drawing-if-too-large*)
					(title nil))
  (maybe-stick-command-defaults *hardcopy-drawing-orientation* orientation
				*hardcopy-drawing-if-too-large* if-too-large)
  (with-open-stream (stream
		      (hardcopy:make-hardcopy-stream
			printer
			:landscape-p (eq orientation :landscape)
			:title (or title
				   (with-output-to-string (stream)
				     (format-textual-list drawings
							  #'(lambda (drawing stream)
							      (princ (drawing-name drawing)
								     stream))
							  :stream stream)))))
    (let ((eps-p nil))
      (when (and (null (rest drawings))
		 (consp printer))
	(send-if-handles stream :set-run-length-encode-images t)
	;; If printing just one drawing to a file, attempt to set the EPSF %%BoundingBox.
	(setq eps-p (operation-handled-p stream :set-eps-bounding-box)))
      (loop for (drawing . rest) on drawings do
	(draw-drawing drawing :stream stream :presentations nil
		      :if-too-large if-too-large :unit :point
		      :set-eps-bounding-box eps-p)
	(when rest (send stream :eject-page))))))

(define-hardcopy-command (com-hardcopy-drawing :menu-accelerator "Hardcopy" :menu-level :io)
			 ((drawings '((sequence drawing)) :prompt "drawing(s)"
							  :default (list current-drawing)))
  drawings)

(define-hardcopy-command (com-hardcopy-file )
			 ((dfile 'pathname :default (default-drawing-pathname)))
  (or (file-drawings dfile)
      (let ((drawings (read-drawings-from-file dfile)))
	(without-interrupts
	  (setf (graphic-editor-loaded-drawings self)
		(append (graphic-editor-loaded-drawings self) drawings)))
	drawings))
  :title (with-output-to-string (stream)
	   (format stream "Drawing")
	   (let ((drawings (file-drawings dfile)))
	     (when (rest drawings)
	       (format stream "s (~D)" (length drawings))))
	   (format stream " from ~A" dfile)))

;;; For DYNAMIC-FLET purposes... 
(defun done-1 (graphic-editor)
  (done-2 graphic-editor))

(defmethod (done-2 graphic-editor) ()
  (setq mailbox current-drawing)
  (send dw:*program-frame* :deselect))

(define-graphic-editor-command (com-done :menu-accelerator t :menu-level :io)
    ()
   (done-1 self))

(compile-flavor-methods drawing)

;;;; Main canvas

(defmacro with-drawing-output ((&rest options) &body body)
  (declare (arglist (&key open-handles) &body body))
  `(with-drawing-output-internal (lambda () . ,body) . ,options))

(sys:defvar-resettable *handles-are-open* nil)

(defun-in-flavor (with-drawing-output-internal graphic-editor)
		 (continuation &key (open-handles t) (stream (dw:get-program-pane 'drawing)))
  (dw:remove-window-typeout-window stream :prompt-p nil)
  (graphics:with-scan-conversion-mode (stream :sketch (drawing-sketch-p current-drawing))
    (graphics:saving-graphics-transform (stream)
      (replace (graphics:stream-transform stream) drawing-transform)
      (let ((*standard-output* stream)
	    (me-p (and open-handles (not *handles-are-open*))))
	(if (not me-p)
	    (funcall continuation)
	    (unwind-protect
		(progn
		  (map () #'entity-handle-erase displayed-unselected-handles)
		  (setq displayed-unselected-handles nil)
		  (map () #'entity-handle-erase displayed-selected-handles)
		  (setq displayed-selected-handles nil)
		  (funcall continuation))
	      (redisplay-handles :stream stream)))))))

(defun-in-flavor (redisplay-handles graphic-editor)
		 (&key (stream (dw:get-program-pane 'drawing)))
  (let (selected-on unselected-on)
    (with-drawing-output (:open-handles nil :stream stream)
      (multiple-value-bind (function always)
	  (ecase display-handles
	    (:control (values #'graphic-entity-handles nil))
	    (:control-always (values #'graphic-entity-handles t))
	    (:bounding-box (values #'graphic-entity-bounding-box-handles nil))
	    (:bounding-box-always (values #'graphic-entity-bounding-box-handles t)))
	(let ((selected-set (drawing-selected-entities current-drawing)))
	  (setq selected-on (loop for entity in selected-set
				  append (funcall function entity)))
	  (setq unselected-on (and always
				   (loop for entity being the array-elements
					     of (drawing-entities current-drawing)
					 unless (member entity selected-set)
					   append (funcall function entity))))))

      (map () #'entity-handle-erase (set-difference displayed-selected-handles selected-on))
      (map () #'entity-handle-erase
	   (set-difference displayed-unselected-handles unselected-on))
      (map () #'entity-handle-draw (set-difference selected-on displayed-selected-handles))
      (map () #'(lambda (entity) (entity-handle-draw entity nil))
	   (set-difference unselected-on displayed-unselected-handles)))

    (setq displayed-handles-mode display-handles
	  displayed-selected-handles selected-on
	  displayed-unselected-handles unselected-on)))

(defun-in-flavor (reset-ruler-parameters graphic-editor) (stream)
  (send stream :set-margin-ruler-parameters :scale-transform show-position-transform
					    :scale-units-per-major-division ruler-major-scale
					    :scale-units-per-minor-division ruler-minor-scale
					    :visibility display-rulers-p))

;;; Stub
(defun-in-flavor (draw-drawing-experimental-background graphic-editor) ()
  )

(defmethod (display-drawing graphic-editor) (stream)
  (setq displayed-selected-handles nil
	displayed-unselected-handles nil)
  (unless (eql rulers-displayed-p display-rulers-p)
    ;; Just allocate the right size margin.  Cannot draw until scale known, which requires
    ;; knowing allocate size.  Hence two passes.
    (send stream :set-margin-ruler-parameters :visibility (and display-rulers-p :allocate))
    (setq rulers-displayed-p display-rulers-p))
  (replace drawing-transform graphics:*identity-transform*)
  ;; Make 0,0 be the lower left.
  (setf (fourth drawing-transform) -1)
  (multiple-value-bind (nil top nil bottom)
      (send stream :visible-cursorpos-limits)
    (setf (sixth drawing-transform) (- bottom top)))
  (graphics:compose-transforms drawing-transform (drawing-view-transform current-drawing))
  (replace show-position-transform drawing-transform)
  (ecase scale-unit
    (:pixel )
    (:centimeter
      (graphics:compose-transforms show-position-transform
				   (graphics:build-graphics-transform
				     :scale *pixels-per-centimeter*)))
    (:inch
      (graphics:compose-transforms show-position-transform
				   (graphics:build-graphics-transform
				     :scale *pixels-per-inch*))))
  (setq displayed-grid-size (when display-grid-p
			      (destructuring-bind (quantum nil nil nil x-offset y-offset)
				 show-position-transform
				(setq quantum (* quantum grid-size))
				(graphic-input:draw-grid stream quantum :alu :draw
							 :x-phase (mod x-offset quantum)
							 :y-phase (mod y-offset quantum))
				grid-size)))
  (reset-ruler-parameters stream)
  (when display-hardcopy-outline
    (with-drawing-output (:stream stream)
      (graphics:draw-rectangle 0 11 8.5 0 :scale *pixels-per-inch*
			       :filled nil :thickness 4 :scale-thickness nil
			       :stream stream)
      (graphics:draw-rectangle (+ 0 (/ 2000 2540.0)) (- 11 (/ 1270 2540.0))
			       (- 8.5 (/ 2000 2540.0)) (+ 0 (/ 1270 2540.0))
			       :scale *pixels-per-inch*
			       :filled nil :thickness 2 :scale-thickness nil :dashed t
			       :stream stream)))
  (setq hardcopy-outline-displayed display-hardcopy-outline)
  (with-drawing-output (:stream stream)
    (draw-drawing-experimental-background)
    (draw-drawing current-drawing)))

;;; Should probably have a new name, like edit scale.
(define-graphic-editor-command (com-edit-ruler ) ()
   (let ((on-p display-rulers-p)
	 (unit scale-unit)
	 (units-per-major-division ruler-major-scale)
	 (units-per-minor-division ruler-minor-scale)
	 (grid grid-size)
	 (hardcopy-box display-hardcopy-outline))
     (dw:with-typeout-window-for-accept-values
       (dw:accepting-values ()
	 (setq unit (let ((nunit (accept '((member :centimeter :inch :pixel))
					 :prompt "Scale unit"
					 :default unit)))
		      (unless (eq unit nunit)
			(ecase nunit
			  (:centimeter
			    (setq units-per-major-division 1
				  units-per-minor-division 1/10
				  grid 1))
			  (:inch
			    (setq units-per-major-division 1
				  units-per-minor-division 1/8
				  grid 1))
			  (:pixel
			    (setq units-per-major-division 100
				  units-per-minor-division 10
				  grid 20))))
		      nunit))
	 (when (setq on-p (accept 'boolean :prompt "Display rulers" :default on-p))
	   (setq units-per-major-division (accept 'number
						  :prompt "Units per major division"
						  :default units-per-major-division)
		 units-per-minor-division (accept 'number
						  :prompt "Units per minor division"
						  :default units-per-minor-division)))
	 (when display-grid-p 
	   (setq grid (accept '((number (0))) :prompt "Grid size" :default grid)))
	 (setq hardcopy-box (accept 'boolean :prompt "Display hardcopy box"
				    :default hardcopy-box))))
     (setq display-rulers-p on-p
	   ruler-major-scale units-per-major-division
	   ruler-minor-scale units-per-minor-division)
     (if (and (eq scale-unit unit) (eql grid-size grid)
	      (eql display-hardcopy-outline hardcopy-box))
	 (reset-ruler-parameters (dw:get-program-pane 'drawing))
       (setq scale-unit unit
	     grid-size grid
	     display-hardcopy-outline hardcopy-box)
       (redisplay-drawing :preserve-viewport t))))

;;;; Entity I/O and commands

(define-graphic-editor-command (com-delete-all :menu-accelerator t) ()
  (set-drawing-modified)
  (let ((copy (copy-seq (drawing-entities current-drawing))))
    (undoably () "Delete all"
      (progn
	(drawing-clear current-drawing)
	(redisplay-drawing))
      (progn
	(vector-push-portion-extend (drawing-entities current-drawing) copy)
	(redisplay-drawing)))))

(defun entity-undo-description (verb entities)
  (with-output-to-string (stream)
    (format stream "~A " verb)
    (present entities '((sequence graphic-entity-output)) :stream stream)))

(defprop define-selected-entity-command define-graphic-editor-command
	 zwei:definition-function-spec-type)

(setf (get 'define-selected-entity-command 'zwei:definition-function-spec-finder)
      (get 'define-graphic-editor-command 'zwei:definition-function-spec-finder))

;;; Define commands for the main menu that act on the selected set of a specific entity.
(defmacro define-selected-entity-command ((command-name menu-name
							&key (gesture nil)
							     (entity-translator-type
							       'graphic-entity-output)
							     (entity-predicate nil)
							     (menu-level :top-level)
							     (choose-other-arguments t)
							     )
					  (arg-name &rest other-args)
					  &body command-body)
  `(progn
     (define-graphic-editor-command (,command-name )
	 ((,arg-name `((sequence ((existing-entity :editor ,self))))
		     :default (drawing-selected-entities current-drawing))
	  . ,other-args)
	(unless ,arg-name
	  (dw:command-error "There are no selected entities"))
	. ,command-body)
     ,(when menu-level
	`(dw:define-command-menu-handler
	   (,menu-name graphic-editor ,menu-level :gesture (:left :right))
	   (&rest args)
	   (apply #'selected-entity-command-internal ',command-name ',menu-name
		  ',choose-other-arguments ',(not (null other-args))
		  ,(and entity-predicate `#',entity-predicate)
		  args)))
     ,(when entity-translator-type
	`(define-presentation-to-command-translator ,command-name
						    (,entity-translator-type
						      :documentation ,menu-name
						      :gesture ,gesture)
						    (entity)
	   (when ,(if entity-predicate `(,entity-predicate entity) 't)
	     `(,',command-name (,entity)))))
     ))

;;; Handle click on menu item of the normal kind that deals with selected set.
;;; Actions are as follows:
;;;  click	any-selected?	other-command-args?		action
;;;   left       no              regardless			 read all args from kbd
;;;   left       yes             regardless			 just those args
;;;   right      yes             no 				 just those args
;;;   right      yes             yes				 choose remaining args
;;;   right      no              no				 menu of entities
;;;   right      no              yes				 complete avv
(defun selected-entity-command-internal (command-name menu-name
					 choose-other-args other-args-p predicate
					 &rest args &key window gesture &allow-other-keys)
  (let ((editor (current-graphic-editor :window window :error-p nil)))
    (when editor
      (let ((selected (drawing-selected-entities (graphic-editor-current-drawing editor))))
	(when (and (eq gesture :right) (null selected)
		   (or (not other-args-p) (not choose-other-args)))
	  (return-from selected-entity-command-internal
	    (list command-name
	      (choose-entity-subset editor
				    (let ((set (drawing-entities
						 (graphic-editor-current-drawing editor))))
				      (if predicate
					  (remove-if-not predicate (coerce set 'list))
					  set))
				    :prompt menu-name))))
	(when (and (eq dw:*command-menu-test-phase* :documentation) selected)
	  (when (and (eq gesture :right) other-args-p choose-other-args)
	    ;; Right with other args will choose them.  Make the documentation a
	    ;; little shorter.
	    (throw 'dw:command-menu-test-phase
	      (format nil "Choose arguments for ~A Selected" menu-name)))
	  ;; Left or right without other args uses the default set.
	  ;; Make the documentation a little shorter.
	  (throw 'dw:command-menu-test-phase
	    (format nil "~A Selected" menu-name)))
	(when (and (eq gesture :right) other-args-p (not choose-other-args))
	  (setq gesture :left))			;Don't choose.
	(apply #'dw:standard-command-menu-handler command-name
	       :initial-arguments (when selected (list selected))
	       :command-table (dw:program-command-table editor)
	       :gesture gesture
	       args)))))

(defun choose-entity-subset (editor set &rest args &key prompt &allow-other-keys)
  (case dw:*command-menu-test-phase*
    ((t) set)
    ((:documentation)
     (throw 'dw:command-menu-test-phase
       (format nil "Menu for ~A" (or prompt "entities to use"))))
    (otherwise
      (let ((one (apply #'dw:menu-choose-from-set (coerce set 'list)
						  `((existing-entity :editor ,editor))
						  args)))
	(and one (list one))))))

;;; Presentation type that uses the list of created entities that the
;;; editor maintains to offer (not-very-useful) completion and allow
;;; (very-useful) rescanning of command lines.
(define-presentation-type existing-entity ((&key editor))
   :abbreviation-for 'graphic-entity-output		;to get :printer and sensitivity
   :parser ((stream)
	    (unless editor
	      (setq editor (current-graphic-editor)))
	    (dw:complete-from-sequence (drawing-entities
					 (graphic-editor-current-drawing editor))
				       stream
				       :name-key #'graphic-entity-name)))

(defvar *shape-unique-ids* nil)

(defun entity-shape-new-name (entity-shape)
  (format nil "~A-~D" (entity-shape-name entity-shape)
		      (incf (getf *shape-unique-ids* (entity-shape-keyword entity-shape) 0))))

;;; Make an entity for this drawing and automatically generate a serial-number/name for it.
(defmethod (make-new-entity graphic-editor) (shape &rest options &key name &allow-other-keys)
  (let* ((entry (find shape *entity-shape-alist* :key #'entity-shape-keyword)))
    (unless entry
      (dw:command-error "Unknown shape ~S" shape))
    (apply #'make-instance (entity-shape-flavor entry)
	   :name (or name (entity-shape-new-name entry))
	   :outline-drawing-options outline-drawing-defaults
	   :inside-drawing-options inside-drawing-defaults
	   (append options global-entity-defaults))))

;;; Make without drawing set up yet.  For use by conversion programs from MacDraw, etc.
(defun make-entity (shape &rest options &key name &allow-other-keys)
  (let* ((entry (case shape
		  (:group *group-entity-shape*)
		  (otherwise (find shape *entity-shape-alist* :key #'entity-shape-keyword)))))
    (unless entry
      (dw:command-error "Unknown shape ~S" shape))
    (let ((entity (apply #'make-instance (entity-shape-flavor entry)
			 :name (or name (entity-shape-new-name entry))
			 options)))
      (remake-entity-internal entity)		;As if from .bin file.
      entity)))

(define-symmetric-undo-redo (select-entities deselect-entities)
			    (program entities clear-selection-first deselected)
    (setq deselected (select-entities program entities clear-selection-first))
    (progn
      (when clear-selection-first
	(select-entities program deselected))
      (deselect-entities program entities)))

(defmethod (select-entities graphic-editor) (entities &optional clear-selection-first)
  (let ((old (drawing-selected-entities current-drawing)))
    (setf (drawing-selected-entities current-drawing)
	  (sort (if clear-selection-first (copy-list entities) (union old entities))
		#'< :key #'graphic-entity-graphics-priority))
    (redisplay-handles)
    (when clear-selection-first
      old)))

(defmethod (deselect-entities graphic-editor) (entities)
  (setf (drawing-selected-entities current-drawing)
	(set-difference (drawing-selected-entities current-drawing) entities))
  (redisplay-handles))

(define-graphic-editor-command (com-select-entity :menu-accelerator "Select"
						  :menu-level :selection)
    ((entities `((sequence ((existing-entity :editor ,self)))))
     &key
     (clear-selection-first 'boolean :default nil))
   (do-undoably 'select-entities (entity-undo-description "Select" entities)
		entities clear-selection-first))

(define-graphic-editor-command (com-select-all :menu-accelerator t
					       :menu-level :selection)
    ()
   (do-undoably 'select-entities "Select all"
		(coerce (drawing-entities current-drawing) 'list)))

(define-graphic-editor-command (com-select-entity-and-move-selected )
    ((entities `((sequence ((existing-entity :editor ,self)))))
     &key
     (start-x '((null-or-type number)))
     (start-y '((null-or-type number)))
     (clear-selection-first 'boolean :default nil))
   (com-select-entity entities :clear-selection-first clear-selection-first)
   (com-move-entity (drawing-selected-entities current-drawing)
		    :start-x start-x :start-y start-y))

(defmacro define-simple-undoable-selected-entity-command (command-name name undo-type
							  &optional arglist
							  &rest options)
  (when (null arglist)
    (setq arglist '(entities)))
  (destructuring-bind (arg-name &rest other-args) arglist
    `(define-selected-entity-command (,command-name ,name . ,options) ,arglist
       (do-undoably-modifying ',undo-type (entity-undo-description ,name entities)
			      ,arg-name . ,(loop for other-arg in other-args
						 unless (eq other-arg '&key)
						   collect (first other-arg))))))

(define-simple-undoable-selected-entity-command com-deselect-entity
						"Deselect" deselect-entities ()
						:menu-level ()
						:entity-translator-type ())

(dw:define-command-menu-handler ("Deselect" graphic-editor :selection
				 :gesture (:left :right))
				(&key window gesture)
  (let ((editor (current-graphic-editor :window window :error-p nil)))
    (when editor
      (let ((selected (drawing-selected-entities (graphic-editor-current-drawing editor))))
	;; This could disable the whole deal if there's nothing to deselect.  But that
	;; lost sensitivity seems to be more confusing than useful.
	(if (and (eq gesture :right) (rest selected))
	    (let ((entities (choose-entity-subset editor
						  (drawing-selected-entities
						    (graphic-editor-current-drawing editor))
						  :prompt "Deselect")))
	      (when entities
		`(com-deselect-entity ,entities)))
	    (if (eq dw:*command-menu-test-phase* :documentation)
		(throw 'dw:command-menu-test-phase "Deselect Selected")
		`(com-deselect-entity)))))))

(defmethod (entity-selected-p graphic-editor) (entity)
  (member entity (drawing-selected-entities current-drawing)))

(define-presentation-to-command-translator com-deselect-entity
   (graphic-entity-output :gesture () :documentation "Deselect")
   (entity &key window)
  (when (let ((editor (current-graphic-editor :window window :error-p nil)))
	  (and editor (entity-selected-p editor entity)))
    `(com-deselect-entity (,entity))))

(define-presentation-to-command-translator click-on-entity
					   (graphic-entity-output
					     :menu ()
					     :documentation "Select (Move if held)")
					   (entity &rest args)
  (apply #'click-on-entity entity '(:clear-selection-first t) args))

(define-presentation-to-command-translator shift-click-on-entity
					   (graphic-entity-output
					     :menu ()
					     :gesture :add-to-selected
					     :documentation "Add to selected (Move if held)")
					   (entity &rest args)
  (apply #'click-on-entity entity nil args))

(defun convert-window-coordinates-to-screen-coordinates (window x y)
  (multiple-value-bind (new-x new-y)
      (send window :convert-to-relative-coordinates x y :outside)
    (multiple-value-bind (dx dy)
	(tv:sheet-mouse-offsets window)
      (values (+ new-x dx) (+ new-y dy)))))

(defun mouse-still-held-after-click (window x y)
  (and window
       (not dw:*inside-handler-test-phase*)
       (multiple-value-bind (screen-x screen-y)
	   (convert-window-coordinates-to-screen-coordinates window x y)
	 (let ((mouse (tv:sheet-mouse window)))
	   (process-wait-with-timeout "Hold to move" 30
	     #'(lambda (mouse screen-x screen-y)
		 ;; If the users moves the mouse much, assume that he intended
		 ;; to start moving the object.
		 (or (> (abs (- (tv:mouse-x mouse) screen-x)) 4)
		     (> (abs (- (tv:mouse-y mouse) screen-y)) 4)
		     (zerop (tv:mouse-last-buttons mouse))))
	     mouse screen-x screen-y)
	   (not (zerop (tv:mouse-last-buttons mouse)))))))

(defun quantize-drawing-point (window x y)
  (multiple-value-bind (program stream-x stream-y)
      (drawing-window-point-p window x y :show-position)
    (when (and stream-x stream-y)
      (multiple-value-setq (x y)
	(graphics:transform-point stream-x stream-y
				  (graphic-editor-show-position-transform program)))
      (setq x (round x)
	    y (round y))))
  (values x y))

(defun click-on-entity (entity other-command-args &key window x y &allow-other-keys)
  (if (mouse-still-held-after-click window x y)
      (multiple-value-bind (x y)
	  (quantize-drawing-point window x y)
	`(com-select-entity-and-move-selected (,entity) :start-x ,x :start-y ,y
					      . ,other-command-args))
      `(com-select-entity (,entity) . ,other-command-args)))

(define-graphic-editor-command (com-select-region :menu-accelerator t
						  :menu-level :selection)
    (&key
      (start-x '((null-or-type number)))
      (start-y '((null-or-type number)))
      (clear-selection-first 'boolean :default nil))
   (with-drawing-output (:open-handles nil)
     (multiple-value-bind (left top right bottom)
	 (call-with-graphic-editor-mouse-blinker-options
	   #'graphic-input:mouse-input-rectangle :first-whostate "Pick region start and hold"
						 :second-whostate "Selecting region"
						 :first-who-line-documentation-string
 "L: Start region here; M: Abort.  Abort also aborts."
						 :second-who-line-documentation-string
 "Release mouse at other end of region.  Abort aborts."
						 :start-x start-x :start-y start-y
						 :dashed t :initially-display-object nil)
       (multiple-value-setq (left top)
	 (graphics:transform-point left top drawing-transform))
       (multiple-value-setq (right bottom)
	 (graphics:transform-point right bottom drawing-transform))
       (psetq left (floor (min left right)) right (ceiling (max left right)))
       (psetq top (floor (min top bottom)) bottom (ceiling (max top bottom)))
       (let ((list ()))
	 (send *standard-output* :map-over-overlapping-presentations left top right bottom
	       #'(lambda (presentation)
		   (when (and (dw:box-contained-in-region-p
				(dw:presentation-displayed-box presentation)
				left top right bottom)
			      (dw:presentation-subtypep (dw:presentation-type presentation)
							'graphic-entity-output))
		     (push (dw:presentation-object presentation) list))))
	 (com-select-entity list :clear-selection-first clear-selection-first)))))

;;; If this is a point on the drawing window, return it in the user-visible coordinate system.
(defun drawing-window-point-p (window x y &optional (transform :drawing))
  (declare (values program x y))
  (let ((frame (send window :superior)))
    (when (and (typep frame 'dw:program-frame)
	       (eq window (send frame :get-pane 'drawing)))
      (let ((program (send frame :program)))
	(when (typep program 'graphic-editor)
	  (when (and x y)
	    (multiple-value-setq (x y)
	      (graphics:untransform-point x y
					  (graphic-editor-show-position-transform program)))
	    (multiple-value-setq (x y)
	      (funcall (graphic-editor-mouse-quantize-function program) x y))
	    (ecase transform
	      (:show-position )
	      (:drawing
		(multiple-value-setq (x y)
		  (graphics:transform-point x y
					    (graphic-editor-show-position-transform program)))
		(multiple-value-setq (x y)
		  (graphics:untransform-point x y
					      (graphic-editor-drawing-transform program))))))
	  (values program x y))))))

(define-presentation-to-command-translator select-region
					   (graphic-input:grid-output
					     :blank-area t
					     :documentation 
 "Select region starting here (click and hold)")
					   (ignore &key window x y)
  (multiple-value-bind (drawing-p x y)
      (drawing-window-point-p window x y)
    (when drawing-p
      `(com-select-region :start-x ,x :start-y ,y :clear-selection-first t))))

(define-presentation-to-command-translator add-select-region
					   (graphic-input:grid-output
					     :blank-area t
					     :gesture :add-to-selected
					     :documentation 
 "Add select region starting here (click and hold)")
					   (ignore &key window x y)
  (multiple-value-bind (drawing-p x y)
      (drawing-window-point-p window x y)
    (when drawing-p
      `(com-select-region :start-x ,x :start-y ,y))))

(defun-in-flavor (move-entity-handle graphic-editor) (entity handle dx dy)
  (with-drawing-output ()
    (entity-move-handle entity handle dx dy)
    (note-entities-transform (list entity))
    (redraw-later-overlapping-entities (list entity) (drawing-entities current-drawing))))

(define-graphic-editor-command (com-move-entity-handle )
    ((handle 'entity-handle-output)
     &key
     (start-x '((null-or-type number)))
     (start-y '((null-or-type number))))
   (let ((entity (entity-handle-entity handle)))
     (with-drawing-output ()
       (multiple-value-bind (dx dy)
	   (call-with-graphic-editor-mouse-blinker-options #'entity-input-handle-motion
							   entity handle
							   :start-x start-x :start-y start-y)
	 (set-drawing-modified)
	 (undoably (entity handle) (format nil "Move ~A handle" (graphic-entity-name entity))
	   (move-entity-handle entity handle dx dy)
	   (move-entity-handle entity handle (- dx) (- dy)))))))

(define-presentation-to-command-translator click-on-handle
   (entity-handle-output :documentation "Move this handle (reshaping entity)")
   (handle &key window x y)
  (let ((entity (entity-handle-entity handle)))
    (when (entity-can-move-handle entity handle)
      (multiple-value-bind (x y) (quantize-drawing-point window x y)
	`(com-move-entity-handle ,handle :start-x ,x :start-y ,y)))))

(defundo rename-entity (program entity new-name old-name))

(defmethod (undo-element-redo rename-entity) ()
  (setq old-name (graphic-entity-name entity))
  (setf (graphic-entity-name entity) new-name))

(defmethod (undo-element-undo rename-entity) ()
  (setf (graphic-entity-name entity) old-name))

(define-graphic-editor-command (com-rename-entity )
    ((entity `((existing-entity :editor ,self))
	     :default (first (drawing-selected-entities current-drawing)))
     (new-name 'string
	       :prompt "new name" :default (graphic-entity-name entity)
	       :confirm t))
   (when (find new-name (drawing-entities current-drawing)
	       :test #'string-equal :key #'graphic-entity-name)
     (dw:command-error "There is already an entity named ~A." new-name))
   (do-undoably-modifying 'rename-entity
			  (format nil "Rename ~A to ~A" (graphic-entity-name entity) new-name)
			  entity new-name))

(define-presentation-to-command-translator com-rename-entity
   (graphic-entity-output :documentation "Rename")
   (entity)
  (values `(com-rename-entity ,entity) 'cp:command :activate nil))

(define-symmetric-undo-redo (add-entities delete-entities)
			    (program entities to-select were-selected)
    (setq were-selected (add-entities program entities to-select))
    (setq to-select (delete-entities program entities were-selected)))

(defun-in-flavor (add-entities-internal graphic-editor) (entities)
  (dolist (entity entities)
    (vector-push-extend entity (drawing-entities current-drawing))))

(defmethod (add-entities graphic-editor) (entities to-select)
  (prog1 (copy-list (drawing-selected-entities current-drawing))
    (add-entities-internal entities)
    (with-drawing-output ()
      (dolist (entity entities)
	(entity-output entity))
      (setf (drawing-selected-entities current-drawing) to-select))))

(defun-in-flavor (delete-entities-internal graphic-editor) (entities)
  (setf (drawing-entities current-drawing) 
	(delete-if #'(lambda (thing) (member thing entities))
		   (drawing-entities current-drawing)))
  (setf (drawing-selected-entities current-drawing) 
	(delete-if #'(lambda (thing) (member thing entities))
		   (drawing-selected-entities current-drawing))))

(defmethod (delete-entities graphic-editor) (entities were-selected)
  (prog1 (copy-list (drawing-selected-entities current-drawing))
    (delete-entities-internal entities)
    (with-drawing-output ()
      (dolist (entity entities)
	(entity-erase entity))
      (setf (drawing-selected-entities current-drawing)
	    (union (drawing-selected-entities current-drawing) were-selected)))))

;;; Create a new entity.  Usually invoked via the shapes menu.
(define-graphic-editor-command (com-create-entity)
    ((shape-name 'entity-shape :default last-shape-created :confirm t)
     &key
     (start-x '((null-or-type number)))
     (start-y '((null-or-type number))))
   (unless start-x
     (setq last-shape-created shape-name))
   (let ((entity (make-new-entity self shape-name)))
     (with-drawing-output ()
       (with-sample-shape-highlighted (shape-name)
	 (if (and start-x start-y)
	     (call-with-graphic-editor-mouse-blinker-options #'entity-input entity
							     :while-held t
							     :start-x start-x
							     :start-y start-y)
	     (call-with-graphic-editor-mouse-blinker-options #'entity-input entity)))
       (do-undoably-modifying 'add-entities
			      (format nil "Create ~A" (graphic-entity-name entity))
			      (list entity) (list entity))
       (format *query-io* "~&~A created." (graphic-entity-name entity)))))

(dw:define-command-menu-handler ("Create" graphic-editor :top-level
				 :gesture (:left :right)
				 :documentation "Create an entity of a given shape")
				(&rest args &key gesture window &allow-other-keys)
  (if (neq gesture :right)
      `(com-create-entity
	 . ,(let ((editor (current-graphic-editor :window window :error-p nil)))
	      (when editor
		(let ((shape (graphic-editor-last-shape-created editor)))
		  (when shape
		    (list shape))))))
    (case dw:*command-menu-test-phase*
      ((t) (throw 'dw:command-menu-test-phase
	     `(com-create-entity )))
      ((:documentation)
       (throw 'dw:command-menu-test-phase "Menu for Create Entity"))
      (otherwise
	(let ((shape (dw:menu-choose-from-set
		       (let ((list (copy-list *entity-shape-alist*)))
			 (setq list (sort list #'string-lessp :key #'entity-shape-name))
			 (loop for list on list
			       do (setf (car list) (entity-shape-keyword (car list))))
			 list)
		       'entity-shape
		       :prompt "Create"
		       :default (let ((editor (current-graphic-editor :window window
								       :error-p nil)))
				  (and editor (graphic-editor-last-shape-created editor))))))
	  (when shape
	    `(com-create-entity ,shape)))))))

(define-presentation-to-command-translator create-a-shape (entity-shape) (shape-name)
  `(com-create-entity ,shape-name))

(define-presentation-to-command-translator create-a-line
   (graphic-input:grid-output
     :gesture :create-line
     :blank-area t
     :documentation ((ignore &key window)
		     (let ((editor (current-graphic-editor
				     :window window)))
		       (if (getf (graphic-editor-global-entity-defaults editor) :arrow-p)
			   "Draw arrow starting here (click and hold)"
			   "Draw line starting here (click and hold)"))))
   (ignore &key window x y)
  (multiple-value-bind (editor x y)
      (drawing-window-point-p window x y)
    (when editor
      `(com-create-entity :line :start-x ,x :start-y ,y))))

(define-presentation-to-command-translator create-another-of-last-shape
   (t :gesture :create-another-of-last-shape
      :blank-area t
      :menu ()					;Just causes confusion.
      :documentation
      ((ignore &key window)
       (let* ((editor (current-graphic-editor :window window))
	      (shape (graphic-editor-last-shape-created editor)))
	 (when shape
	   (format nil "Create another ~A"
		   (entity-shape-keyword-name shape))))))
   (ignore &key window x y)
  (multiple-value-bind (editor x y)
      (drawing-window-point-p window x y)
    (when editor
      (let ((shape (graphic-editor-last-shape-created editor)))
	(when shape
	  `(com-create-entity ,shape :start-x ,x :start-y ,y))))))

(define-presentation-to-command-translator create-another-of-this-shape
   (graphic-entity-output :gesture :create-another-of-this-shape
			  :documentation ((entity)
					  (format nil "Create another ~A"
						  (entity-shape-keyword-name
						    (entity-shape entity)))))
   (entity)
  (let ((shape (entity-shape entity)))
    (when shape
      `(com-create-entity ,shape))))

(define-presentation-to-command-translator pop-up-shapes-menu
   (graphic-input:grid-output
     :blank-area t :menu ()
     :gesture :pop-up-shapes-menu	;:menu
     :documentation "Shapes menu")
   (ignore &key window x y)
  (when (drawing-window-point-p window x y)
    (if dw:*inside-handler-test-phase*
	`(com-create-entity)
	(let* ((frame (send window :superior))
	       (shape (dw:menu-choose-from-copy-of-window-contents
			(send frame :get-pane 'shapes-menu) 'entity-shape
			:prompt "Create a shape" :superior frame)))
	  (if (null shape)
	      (signal 'sys:abort)
	      `(com-create-entity ,shape))))))

(define-graphic-editor-command (com-add-image )
    ((image `((images:named-image)) :prompt "image")
     (scale-x 'number :prompt "X scale factor" :default 1 :confirm t)
     (scale-y 'number :prompt "Y scale factor" :default 1 :confirm t))
   (with-drawing-output ()
     (let ((entity nil))
       (images:with-image-raster (bitmap image :width width :height height)
	 (multiple-value-bind (x y)
	     (call-with-graphic-editor-mouse-blinker-options
	       #'graphic-input:mouse-position-image bitmap
	       :image-right width :image-bottom height
	       :scale-x scale-x
	       :scale-y scale-y)
	   (setq entity
		 (make-new-entity self :image
				  :bitmap bitmap :x x :y y :width width :height height
				  :scale-x scale-x :scale-y scale-y :name (images:image-name image)))))
       (do-undoably-modifying 'add-entities
			      (format nil "Create ~A" (graphic-entity-name entity))
			      (list entity) (list entity)))))

(define-selected-entity-command (com-edit-image "Edit image"
				  :menu-level () :gesture :modify
				  :entity-predicate (lambda (entity)
						      (typep entity 'image-entity)))
				(entities)
  (unless (= (length entities) 1)
    (dw:command-error "Don't know how to edit more than one entity at once yet."))
  ;;--- Should be undoable, which would mean saving a copy of the image or editing one.
  ;;--- Should allow new scale too.
  (let ((entity (first entities)))
    (let ((image (images:find-image-named (graphic-entity-name entity)
					  :if-does-not-exist nil)))
      (if (and image (equalp (image-entity-bitmap entity) (images::image-raster image)))
	  ;; If the original image seems to still be lying around in core, edit it rather
	  ;; than a copy.
	  (fed::edit-image image :wait t)
	  (fed:edit-bitmap (image-entity-bitmap entity)
			   :name (graphic-entity-name entity)
			   :width (image-entity-width entity)
			   :height (image-entity-height entity)
			   :wait t))))
  (with-drawing-output ()
    (map () #'entity-erase entities)
    (map () #'entity-output entities)
    (map () #'entity-reset-handles entities)))

(cp:install-commands 'graphic-editor '(images:com-read-image-file
				       images:com-write-image-file))

(define-simple-undoable-selected-entity-command com-delete-entity
						"Delete" delete-entities)

(defun-in-flavor (transform-entities graphic-editor) (entities verb transform)
  (flet ((do-transform (entities transform)
	   (with-drawing-output ()
	     (dolist (entity entities)
	       (entity-erase entity))
	     (dolist (entity entities)
	       (entity-transform entity transform))
	     (dolist (entity entities)
	       (entity-output entity))
	     (note-entities-transform entities)
	     (redraw-later-overlapping-entities entities (drawing-entities current-drawing)))))
    (set-drawing-modified)
    (undoably (entities transform) (entity-undo-description verb entities)
      (do-transform entities transform)
      (do-transform entities (graphics:invert-transform transform)))))

(defun-in-flavor (transform-entities-command graphic-editor)
		 (entities verb transform-type &rest args)
  (with-drawing-output ()
    (multiple-value-bind (transform type)
	(call-with-graphic-editor-mouse-blinker-options
	  (lambda (&rest blinker-args)
	    (apply #'input-entities-transform
		   entities transform-type
		   :default-type last-transform-type
		   (append blinker-args args))))
      (setq last-transform-type type)
      (transform-entities entities verb transform))))

(define-selected-entity-command (com-move-entity "Move") (entities
							   &key
							   (start-x '((null-or-type number)))
							   (start-y '((null-or-type number))))
  (transform-entities-command entities "Move" :move
			      :start-x start-x :start-y start-y))

#||	;Since in Transform
(define-selected-entity-command (com-rotate-entity "Rotate") (entities)
  (transform-entities-command entities "Rotate" :rotate))
||#

(define-selected-entity-command (com-transform-entity "Transform"
						      :choose-other-arguments nil)
				(entities
				  (transform-type 'interactive-transform-type
						  :default :choose))	;---
  (transform-entities-command entities "Transform" transform-type))

(defun-in-flavor (copy-entities graphic-editor) (entities &key transform)
  (setq entities (map 'list #'entity-copy entities))
  (dolist (entity entities)
    (let ((elem (find (type-of entity) *entity-shape-alist* :key #'entity-shape-flavor)))
      (when elem
	(setf (graphic-entity-name entity) (entity-shape-new-name elem)))))
  (if transform
      (dolist (entity entities)
	(entity-transform entity transform))
      (map () #'entity-reset-handles entities))
  entities)

(defun-in-flavor (add-copy-entities graphic-editor) (entities &key transform)
  (let ((copies (copy-entities entities :transform transform)))
    (do-undoably-modifying 'add-entities (entity-undo-description "Copy" entities)
			   copies copies)
    (fresh-line *query-io*)
    (present copies '((sequence graphic-entity-output)) :stream *query-io*)
    (format *query-io* " created.")))

(defparameter *copy-entity-offset* 20)

(defun-in-flavor (default-copy-translation graphic-editor) (entities)
  (let ((dx *copy-entity-offset*)
	(dy *copy-entity-offset*))
    (dolist (entity entities)
      (let ((copy-of (graphic-entity-copy-of entity)))
	(when copy-of
	  (multiple-value-setq (dx dy)
	    (with-drawing-output (:open-handles nil)
	      (entity-position-offsets copy-of entity)))
	  (return))))
    (when quantize-mouse-position
      (multiple-value-setq (dx dy)
	;; drawing units to window units.
	(graphics:transform-distance dx dy drawing-transform))
      (multiple-value-setq (dx dy)
	;; window units to user units.
	(graphics:untransform-distance dx dy show-position-transform))
      ;; quantize
      (setq dx (* grid-size (max 1 (round dx grid-size)))
	    dy (* grid-size (max 1 (round dy grid-size))))
      (multiple-value-setq (dx dy)
	;; user units to window units.
	(graphics:transform-distance dx dy show-position-transform))
      (multiple-value-setq (dx dy)
	;; window units to drawing units.
	(graphics:untransform-distance dx dy drawing-transform)))
    (list dx dy)))

(define-selected-entity-command (com-copy-entity "Copy") (entities)
  (add-copy-entities entities
    :transform (graphics:build-graphics-transform
		 :translation (default-copy-translation entities))))

(defun-in-flavor (transform-and-copy-entities graphic-editor) (entities transform-type
							       &rest args)
  (with-drawing-output ()
    (let* ((transform (call-with-graphic-editor-mouse-blinker-options
			(lambda (&rest blinker-args)
			  (apply #'input-entities-transform entities transform-type
				 :erase-first nil (append blinker-args args))))))
      (add-copy-entities entities :transform transform))))

(define-selected-entity-command (com-copy-and-move-entity "Copy/Move")
				(entities
				  &key
				  (start-x '((null-or-type number)))
				  (start-y '((null-or-type number))))
  (transform-and-copy-entities entities :move :start-x start-x :start-y start-y))

(define-selected-entity-command (com-copy-and-transform-entity "Copy/Transform"
							       :choose-other-arguments nil)
				(entities
				  (transform-type 'interactive-transform-type
						  :default :choose))
  (transform-and-copy-entities entities transform-type))

(define-presentation-to-command-translator copy-entity 
					   (graphic-entity-output
					     :menu ()
					     :gesture :copy-entity
					     :documentation "Copy (Move copy if held)")
					   (entity &key window x y)
  (if (mouse-still-held-after-click window x y)
      (multiple-value-bind (x y)
	  (quantize-drawing-point window x y)
	`(com-copy-and-move-entity (,entity) :start-x ,x :start-y ,y))
      `(com-copy-entity (,entity))))

(defundo align-entities (program entities align-to-grid x-alignment y-alignment
			 translation-alist))

(defmethod (undo-element-redo align-entities) ()
  (setq translation-alist (align-entities program entities
					  align-to-grid x-alignment y-alignment)))

(defmethod (undo-element-undo align-entities) ()
  (align-entities-internal program (loop for (entity dx dy) in translation-alist
					 collect (list entity (- dx) (- dy)))))

(defmethod (align-entities graphic-editor) (entities align-to-grid x-alignment y-alignment)
  (with-drawing-output ()
    (let ((translation-alist (compute-entities-alignment entities
							 (and align-to-grid grid-size)
							 x-alignment y-alignment)))
      (align-entities-internal self translation-alist)
      translation-alist)))

(defmethod (align-entities-internal graphic-editor) (translation-alist)
  (with-drawing-output ()
    (loop for (entity) in translation-alist do
      (entity-erase entity))
    (loop for (entity . translation) in translation-alist do
      (entity-transform entity (graphics:build-graphics-transform :translation translation)))
    (loop for (entity) in translation-alist do
      (entity-output entity))
    (note-entities-transform (map 'list #'car translation-alist))))

(define-simple-undoable-selected-entity-command com-align-entity "Align" align-entities
    (entities
     &key
      (align-to-grid 'boolean :default display-grid-p)
      (x-alignment '((member :left :right :center :none)) :default :left)
      (y-alignment '((member :top :bottom :center :none)) :default :none))
  )

(define-symmetric-undo-redo (bury-entities raise-entities)
			    (program entities)
    (bury-entities program entities)
    (raise-entities program entities))

(defun-in-flavor (raise-or-bury-internal graphic-editor) (entities)
  (with-drawing-output ()
    ;; Resequence, but don't do any output.
    (resequence-entities (drawing-entities current-drawing))
    ;; Then redisplay in the bounding box of the objects changed.  That's the only place
    ;; we care about.
    (redisplay-entities entities)))

(defmethod (bury-entities graphic-editor) (entities)
  (stack-let ((bottom (make-array (length entities))))
    (let* ((array (drawing-entities current-drawing))
	   (write-pointer (fill-pointer array))
	   (bottom-pointer (length entities)))
      ;; Maintain order relative to one another, but otherwise move to beginning.
      (loop for read-pointer from (1- write-pointer) downto 0 do
	(let ((entity (aref array read-pointer)))
	  (if (member entity entities)
	      (setf (aref bottom (decf bottom-pointer)) entity)
	      (decf write-pointer)
	      (unless (= read-pointer write-pointer)
		(setf (aref array write-pointer) entity)))))
      (copy-array-portion bottom bottom-pointer (length bottom) array 0 write-pointer)))
  (raise-or-bury-internal entities))

(defmethod (raise-entities graphic-editor) (entities)
  (stack-let ((top (make-array (length entities))))
    (let ((array (drawing-entities current-drawing))
	  (write-pointer 0)
	  (top-pointer 0))
      ;; Maintain order relative to one another, but otherwise move to end.
      (dotimes (read-pointer (fill-pointer array))
	(let ((entity (aref array read-pointer)))
	  (if (member entity entities)
	      (setf (aref top (prog1 top-pointer (incf top-pointer))) entity)
	      (unless (= read-pointer write-pointer)
		(setf (aref array write-pointer) entity))
	      (incf write-pointer))))
      (copy-array-portion top 0 top-pointer array write-pointer (fill-pointer array))))
  (raise-or-bury-internal entities))

(define-simple-undoable-selected-entity-command com-bury-entity
						"Bury" bury-entities)

(define-simple-undoable-selected-entity-command com-raise-entity
						"Raise" raise-entities)

;;; List order is top (last in drawing-entities) first.
(defundo restack-entities (program stacking old-order))

(defmethod (undo-element-redo restack-entities) ()
  (setq old-order (restack-entities program stacking)))

(defmethod (undo-element-undo restack-entities) ()
  (restack-entities program old-order))

(defmethod (restack-entities graphic-editor) (entities)
  (let ((array (drawing-entities current-drawing))
	(reorder-index 0)
	(old-stacking nil))
    ;; Move to end.  Remember that list order is reverse of array order.
    (stack-let ((reversed (make-array (length entities) :initial-contents entities)))
      (nreverse reversed)
      (dotimes (index (fill-pointer array))
	(let ((entity (aref array index)))
	  (when (member entity entities)
	    (push entity old-stacking)
	    (setf (aref array index) (aref reversed reorder-index))
	    (incf reorder-index)))))
    (raise-or-bury-internal entities)
    old-stacking))

;;; Probably this should have another command argument to restack transitive closure
;;; under overlapping.
(define-selected-entity-command (com-restack-entities "Restack overlapping" :menu-level nil)
				(entities)
  (setq entities (reorder-sequence:reorder-sequence-via-menu
		   (let ((list nil))
		     (map () #'(lambda (entity)
				 (when (loop for other-entity in entities
					     thereis (dw:boxes-overlap-p
						       (dw:presentation-displayed-box
							 (graphic-entity-presentation
							   entity))
						       (dw:presentation-displayed-box
							 (graphic-entity-presentation
							   other-entity))))
				   (push entity list)))
			  (drawing-entities current-drawing))
		     (unless (rest list)
		       (dw:command-error "There isn't more than one overlapping entity."))
		     list)
		   :prompt "Restack overlapping"
		   :presentation-type 'graphic-entity-output))
  (do-undoably-modifying 'restack-entities "Restack overlapping" entities))

;;;; Options and defaults

(defmethod (accept-values-edit-options graphic-editor) (stream)
  ;; Part that logically goes in the accept-values
  (setq display-handles (accept '((alist-member
				    :alist (("Control points" :value :control-always
  :documentation "Always display control points")
					    ("Control if selected" :value :control
  :documentation "Display control points of selected entities")
					    ("Bounding box" :value :bounding-box-always
  :documentation "Always display corners and midpoints of bounding rectangle")
					    ("Box if selected" :value :bounding-box
  :documentation "Display corners and midpoints of bounding rectangle if selected"))))
				:stream stream :prompt "Handles"
				:default display-handles)
	display-grid-p (accept '((alist-member
				   :alist (("Yes" :value t
  :documentation "Display background position grid")
					   ("No" :value nil
  :documentation "Turn off grid display"))))
			       :stream stream :prompt "Display grid"
			       :default display-grid-p))
  (when (or display-grid-p quantize-mouse-position)
    (setq grid-size (accept '((number (0))) :stream stream
			    :prompt (ecase scale-unit
				      (:centimeter "Grid size (cm)")
				      (:inch "Grid size (inches)")
				      (:pixel "Grid size (pixels)"))
			    :default grid-size)))
  (setq display-mouse-position (accept '((alist-member
					   :alist (("Yes" :value t
  :documentation "Display the position of the mouse on the drawing next to the mouse cursor")
						   ("No" :value nil
  :documentation "Turn off mouse position display"))))
				       :stream stream
				       :prompt "Show mouse position"
				       :default display-mouse-position)
	quantize-mouse-position (accept'((alist-member
					   :alist (("Yes" :value t
  :documentation "Round the effective position of the mouse to the nearest grid point")
						   ("No" :value nil
  :documentation "Turn off mouse quantization"))))
					:stream stream
					:prompt "Quantize mouse position"
					:default quantize-mouse-position)
	display-rulers-p (accept '((alist-member
				     :alist (("Yes" :value t
  :documentation "Display a ruler in the margin of the drawing")
					     ("No" :value nil
  :documentation "Turn off ruler display"))))
				 :stream stream
				 :prompt "Display rulers"
				 :default display-rulers-p))
  ;; Processing of those values
  (unless (and (eql (and display-grid-p grid-size) displayed-grid-size)
	       (eql display-rulers-p rulers-displayed-p))
    (redisplay-drawing :preserve-viewport t))
  (unless (eq display-handles displayed-handles-mode)
    (redisplay-handles))
  (let ((set-mouse-type (if display-mouse-position
			    (if quantize-mouse-position :quantized-position :position)
			    (and quantize-mouse-position :quantized))))
    (unless (eq set-mouse-type last-set-mouse-type)
      (graphic-input:set-window-special-mouse-blinker (dw:get-program-pane 'drawing)
	:show-position display-mouse-position
	:quantize-position (mouse-quantize-p))
      (setq last-set-mouse-type set-mouse-type)))
  )

(defun accept-values-pattern-options (prompt defaults)
  (let* ((kind (accept (if (or (color:color-stream-p *query-io*)
			       (getf defaults :color))
			   '((member :black :white :gray :colored :patterned))
			   '((member :black :white :gray :patterned)))
		       :prompt prompt
		       :default (cond ((getf defaults :pattern) :patterned)
				      ((getf defaults :color) :colored)
				      (t
				       (let ((gray-level (getf defaults :gray-level)))
					 (cond ((or (null gray-level) (= gray-level 1))
						:black)
					       ((zerop gray-level) :white)
					       (t :gray))))))))
    (case kind
      (:black nil)
      (:white (copy-list '(:gray-level 0)))
      (:gray (list :gray-level
		   (accept 'graphic-input:proper-gray-level
			   :prompt (format nil " ~A gray level" prompt)
			   :default (let ((val (getf defaults :gray-level 1)))
				      (unless (< 0 val 1)
					(setq val (getf *initial-inside-drawing-options*
							:gray-level)))
				      val))))
      (:patterned (list :pattern
			(accept 'graphic-input:pattern-stipple
				:prompt (format nil " ~A pattern" prompt)
				:default (getf defaults :pattern
					       (getf *initial-inside-drawing-options*
						     :pattern)))))
      (:colored (list :color
		      (accept 'color:color
			      :prompt (format nil " ~A color" prompt)
			      :default (getf defaults :color)))))))

(defun accept-values-outline-defaults (defaults &optional (allow-not-drawn t))
  (let ((opacity (if allow-not-drawn
		     (accept '((alist-member :alist (("Not drawn" . :not-drawn)
						     ("Opaque" . t)
						     ("Non-opaque" . nil))))
			     :prompt "Draw outline"
			     :default (if (null defaults) :not-drawn
					  (getf defaults :opaque)))
		     (accept 'boolean :prompt "Opaque" :default (getf defaults :opaque)))))
    (unless (eq opacity :not-drawn)
      (let ((thickness (accept 'graphic-input:line-thickness :prompt "Thickness"
			       :default (getf defaults :thickness 1)))
	    (pattern-options nil)
	    (line-end-shape :butt)
	    (line-joint-shape :miter)
	    (dashed (accept 'boolean :prompt "Dashed"
			    :default (getf defaults :dashed)))
	    (dash-pattern nil))
	(when (> thickness 1)
	  (setq pattern-options (accept-values-pattern-options "Line pattern" defaults)
		line-end-shape (accept '((member :butt :square :round))
				       :prompt "Line end shape"
				       :default (getf defaults :line-end-shape
						      line-end-shape))
		line-joint-shape (accept '((member :miter :bevel :round :none))
					 :prompt "Line joint shape"
					 :default (getf defaults :line-joint-shape
							line-joint-shape))))
	(when dashed
	  (setq dash-pattern (accept 'graphic-input:dash-pattern :prompt "Dash pattern"
				     :default (getf defaults :dash-pattern))))
	(setq defaults `(:opaque ,opacity))
	(when ( thickness 1)
	  (setf (getf defaults :thickness) thickness)
	  (when (> thickness 1)
	    (setq defaults (nconc pattern-options defaults))))
	(when dashed
	  (setf (getf defaults :dashed) dashed))
	(when dash-pattern
	  (setf (getf defaults :dash-pattern) dash-pattern))
	(unless (eq line-end-shape :butt)
	  (setf (getf defaults :line-end-shape) line-end-shape))
	(unless (eq line-joint-shape :miter)
	  (setf (getf defaults :line-joint-shape) :miter))
	defaults))))

(defun accept-values-inside-defaults (defaults &optional (allow-not-drawn t))
  (let ((opacity (if allow-not-drawn
		     (accept '((alist-member :alist (("Not drawn" . :not-drawn)
						     ("Opaque" . t)
						     ("Non-opaque" . nil))))
			     :prompt "Fill inside"
			     :default (if (null defaults) :not-drawn
					  (getf defaults :opaque)))
		     (accept 'boolean :prompt "Opaque" :default (getf defaults :opaque)))))
    (unless (eq opacity :not-drawn)
      (let ((pattern-options (accept-values-pattern-options "Fill pattern" defaults)))
	(setq defaults `(:opaque ,opacity . ,pattern-options))))))

(defun maybe-display-samples (outline-defaults inside-defaults)
  (when (not (null outline-defaults))
    (dw:accept-values-fixed-line "Sample thicknesses:")
    (dw:with-redisplayable-output (:stream *query-io*
				   :unique-id 'thickness-menu
				   :cache-value graphic-input:*sample-thicknesses*)
      (format *query-io* "  ")
      (graphic-input:display-thickness-menu :stream *query-io*)))
  (when (getf outline-defaults :dashed)
    (dw:accept-values-fixed-line "Sample dash patterns:")
    (dw:with-redisplayable-output (:stream *query-io*
				   :unique-id 'dash-menu
				   :cache-value graphic-input:*sample-dashes*)
      (format *query-io* "  ")
      (graphic-input:display-dashes-menu :stream *query-io*)))
  (when (flet ((gray-p (plist)
		 (let ((gray (getf plist :gray-level 1)))
		   (not (or (= gray 0) (= gray 1))))))
	  (or (gray-p outline-defaults) (gray-p inside-defaults)))
    (dw:accept-values-fixed-line "Sample gray levels:")
    (dw:with-redisplayable-output (:stream *query-io*
				   :unique-id 'gray-menu
				   :cache-value graphic-input:*sample-gray-levels*)
      (format *query-io* "  ")
      (graphic-input:display-gray-level-menu :stream *query-io*)))
  (when (flet ((stipple-p (plist) (neq (getf plist :pattern 'not-present) 'not-present)))
	  (or (stipple-p outline-defaults) (stipple-p inside-defaults)))
    (dw:accept-values-fixed-line "Sample patterns:")
    (dw:with-redisplayable-output (:stream *query-io*
				   :unique-id 'stipple-menu
				   :cache-value graphics:*stipple-arrays*)
      (format *query-io* "  ")
      (graphic-input:display-pattern-menu :stream *query-io*)))
  (when (flet ((colored-p (plist) (neq (getf plist :color 'not-present) 'not-present)))
	  (or (colored-p outline-defaults) (colored-p inside-defaults)))
    (dw:accept-values-fixed-line "Sample colors:")
    (dw:with-redisplayable-output (:stream *query-io*
				   :unique-id 'color-menu
				   :cache-value graphic-input:*sample-colors*)
      (format *query-io* "  ")
      (graphic-input:display-color-menu :stream *query-io*)))
  )

(defundo set-defaults
	 (program
	   other-defaults outline-defaults inside-defaults command-defaults drawing-defaults
	   saved-other-defaults saved-outline-defaults saved-inside-defaults
	   saved-command-defaults saved-drawing-defaults))

(defmethod (undo-element-redo set-defaults) ()
  (multiple-value-setq (saved-other-defaults saved-outline-defaults saved-inside-defaults
			saved-command-defaults saved-drawing-defaults)
    (get-defaults program command-defaults drawing-defaults))
  (set-defaults program other-defaults outline-defaults inside-defaults
		command-defaults drawing-defaults))

(defmethod (undo-element-undo set-defaults) ()
  (set-defaults program saved-other-defaults saved-outline-defaults saved-inside-defaults
		saved-command-defaults saved-drawing-defaults))

(defmethod (get-defaults graphic-editor) (command-defaults drawing-defaults)
  (declare (values other-defaults outline-defaults inside-defaults
		   command-defaults drawing-defaults))
  (values global-entity-defaults outline-drawing-defaults inside-drawing-defaults
	  (loop for (variable) in command-defaults
		collect (list variable (symbol-value variable)))
	  (loop for (read) in drawing-defaults
		collect (list read (funcall read current-drawing)))))

(defmethod (set-defaults graphic-editor)
	   (other-defaults outline-defaults inside-defaults command-defaults drawing-defaults)
  (unless (and (equal global-entity-defaults other-defaults)
	       (equal outline-drawing-defaults outline-defaults)
	       (equal inside-drawing-defaults inside-defaults))
    (setq global-entity-defaults other-defaults
	  outline-drawing-defaults outline-defaults
	  inside-drawing-defaults inside-defaults)
    (redisplay-shapes-menu))
  (loop for (variable value) in command-defaults
	do (setf (symbol-value variable) value))
  (loop for (read value) in drawing-defaults
	do (funcall (fdefinition `(setf ,read)) current-drawing value)
	   (set-drawing-modified)))

(define-graphic-editor-command (com-edit-defaults :menu-accelerator "Defaults") ()
   (let ((global-defaults global-entity-defaults)
	 (outline-defaults outline-drawing-defaults)
	 (inside-defaults inside-drawing-defaults)
	 (command-defaults nil)
	 (drawing-defaults nil))
     (dw:with-typeout-window-for-accept-values
       (graphics:with-scan-conversion-mode (t :sketch (drawing-sketch-p current-drawing))
	 (dw:accepting-values (t :display-exit-boxes nil)
	   (setq global-defaults (edit-global-entity-option-set global-defaults))
	   (dw:accept-values-fixed-line "Outline drawing defaults:")
	   (setq outline-defaults (accept-values-outline-defaults outline-defaults))
	   (dw:accept-values-fixed-line "Inside drawing defaults:")
	   (setq inside-defaults (accept-values-inside-defaults inside-defaults))
	   (dw:accept-values-fixed-line "Other command defaults:")
	   (setq command-defaults (accept-values-command-defaults command-defaults))
	   (dw:accept-values-fixed-line "Other drawing defaults:")
	   (setq drawing-defaults (accept-values-drawing-defaults current-drawing
								  drawing-defaults))
	   (dw:accept-values-display-exit-boxes)
	   (maybe-display-samples outline-defaults inside-defaults))))
     (do-undoably 'set-defaults "Set Defaults"
		  global-defaults outline-defaults inside-defaults
		  command-defaults drawing-defaults)))

(defun accept-values-command-defaults (defaults)
  (loop for (variable type prompt) in *command-defaults*
	as current = (symbol-value variable)
	as default = (let ((elem (assoc variable defaults)))
		       (if elem (second elem) current))
	as value = (accept type :prompt prompt :default default)
	unless (eq value current)
	  collect (list variable value)))

(defparameter *other-drawing-defaults*
  '((drawing-sketch-p boolean "Draw faster rather than more accurately")))

(defun accept-values-drawing-defaults (drawing defaults)
  (loop for (read type prompt) in *other-drawing-defaults*
	as current = (funcall read drawing)
	as default = (let ((elem (assoc read defaults)))
		       (if elem (second elem) current))
	as value = (accept type :prompt prompt :default default)
	unless (eq value current)
	  collect (list read value)))

(define-selected-entity-command (com-change-entity "Change" :gesture :modify)
				(entities)
  (when (and (not (null (cdr entities)))
	     (member 'group-entity entities :key #'type-of))
    D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI");; When there's more than one entity, and one of them is a group
0    (dw:command-error "There are no common options among the selected entities.~@
		       You must change grouped entities individually."))
  (multiple-value-bind (own-default-values own-default-types)
      (entities-common-options entities)
    (let* ((first-entity (first entities))
	   1;; You can't set drawing options of a group entity.
	   ;; We only have to check the first one because, if it is a group, it is
	   ;; guaranteed to be the only one.
0	   (outline-p (unless (typep first-entity 'group-entity)
			(loop for entity in entities
			      always (entity-output-pieces entity))))
	   (outline-defaults (and outline-p
				  (graphic-entity-outline-drawing-options first-entity)))
	   (inside-p (unless (typep first-entity 'group-entity)
		       (loop for entity in entities
			     always (multiple-value-bind (nil filled)
					(entity-output-pieces entity)
				      filled))))
	   (inside-defaults (and inside-p
				 (graphic-entity-inside-drawing-options first-entity))))
      (dw:with-typeout-window-for-accept-values
	(format *query-io* "~&Change ")
	(present entities '((sequence graphic-entity-output)) :stream *query-io*)
	(format *query-io* ":~%")
	(graphics:with-scan-conversion-mode (t :sketch (drawing-sketch-p current-drawing))
	  (dw:accepting-values (t :display-exit-boxes nil)
	    (when own-default-values
	      (dw:accept-values-fixed-line "Entity options:")
	      (setq own-default-values
		    (entity-accept-values-own-options first-entity
						      own-default-values
						      own-default-types)))
	    (when outline-p
	      (when (or inside-p own-default-values)
		(dw:accept-values-fixed-line
		  (if inside-p "Outline drawing options:" "Drawing options:")))
	      (setq outline-defaults (accept-values-outline-defaults outline-defaults
								     inside-p)))
	    (when inside-p
	      (when (or outline-p own-default-values)
		(dw:accept-values-fixed-line
		  (if outline-p "Inside drawing options:" "Drawing options:")))
	      (setq inside-defaults
		    (accept-values-inside-defaults inside-defaults outline-p)))
	    (dw:accept-values-display-exit-boxes)
	    (dw:accept-values-command-button ()
	     (write-line "Click here to fill in from current defaults.")
	      (setq outline-defaults outline-drawing-defaults
		    inside-defaults inside-drawing-defaults
		    own-default-values (loop for (key val) on own-default-values by 'cddr
					     collect key
					     collect (getf global-entity-defaults key val))))
	    (maybe-display-samples outline-defaults inside-defaults))))
      (cond ((and outline-p inside-p))
	    (outline-p
	     (setq inside-defaults outline-defaults))
	    (inside-p
	     (setq outline-defaults inside-defaults)))
      (do-undoably-modifying 'change-entities
			     (entity-undo-description "Change" entities)
			     entities own-default-values outline-defaults inside-defaults)))) 

(defundo change-entities (program entities own-options outline-defaults inside-defaults
				  saved-options))

(defmethod (undo-element-redo change-entities) ()
  (setq saved-options (loop for entity in entities
			    collect (entity-save-options entity own-options)))
  (change-entities program entities own-options outline-defaults inside-defaults))

(defmethod (undo-element-undo change-entities) ()
  (unchange-entities program entities saved-options))

(defmethod (change-entities graphic-editor)
	   (entities own-options outline-defaults inside-defaults)
  (with-drawing-output ()
    (map () #'entity-erase entities)
    (dolist (entity entities)
      (entity-set-options entity own-options outline-defaults inside-defaults))
    (map () #'entity-output entities)
    (redraw-later-overlapping-entities entities (drawing-entities current-drawing))))

(defmethod (unchange-entities graphic-editor) (entities saved-state)
  (with-drawing-output ()
    (map () #'entity-erase entities)
    (loop for entity in entities
	  for (own-options outline-defaults inside-defaults) in saved-state
	  do
      (entity-set-options entity own-options outline-defaults inside-defaults))
    (map () #'entity-output entities)
    (redraw-later-overlapping-entities entities (drawing-entities current-drawing))))

(define-selected-entity-command (com-change-text-string "Change text string"
				  :menu-level () :gesture :modify
				  :entity-predicate (lambda (entity)
						      (typep entity 'text-entity)))
				(entities)
  (dolist (entity entities)
    (unless (typep entity 'text-entity)
      (dw:command-error "~A is not text." (graphic-entity-name entity))))
  (let ((own-default-values (entities-common-options entities))
	(outline-defaults nil)
	(inside-defaults (graphic-entity-inside-drawing-options (first entities))))
    (setq own-default-values (accept-text-string own-default-values
						 (entity-undo-description "new string for"
									  entities)))
    (do-undoably-modifying 'change-entities
			   (entity-undo-description "Change text string" entities)
			   entities own-default-values outline-defaults inside-defaults)))

(define-graphic-editor-command (com-define-new-pattern )
			       ((name '((null-or-type string))
				      :default nil :provide-default t))
   (let ((stipple (fed:design-new-stipple :name (unless (equal name "") name))))
     (when stipple
       (let ((symbol (intern (string-upcase
				    (substitute #\- #\sp
						(graphics:stipple-array-name stipple)))
			     "STIPPLES")))
	 (set symbol stipple))
       (push stipple graphics:*stipple-arrays*)
       (push stipple graphics:*pattern-stipple-arrays*))))

;;;; Groups

(defmethod (entities-to-groups graphic-editor) (groups entities)
  (with-drawing-output (:open-handles nil)
    (loop for group in groups
	  for entities in entities
	  do
      (when (loop for entity in entities
		  thereis (member entity (drawing-selected-entities current-drawing)))
	(pushnew group (drawing-selected-entities current-drawing)))
      (group-entity-implode group entities))
    (dolist (entities entities)
      (delete-entities-internal entities))
    (add-entities-internal groups)
    (setf (drawing-selected-entities current-drawing)
	  (sort (drawing-selected-entities current-drawing)
		#'< :key #'graphic-entity-graphics-priority))
    (redisplay-handles)))

(defmethod (groups-to-entities graphic-editor) (groups)
  (with-drawing-output (:open-handles nil)
    (let ((entities (loop for group in groups
			  as entities = (group-entity-explode group)
			  when (member group (drawing-selected-entities current-drawing))
			    do (setf (drawing-selected-entities current-drawing)
				     (append entities
					     (drawing-selected-entities current-drawing)))
			  collect entities)))
      (delete-entities-internal groups)
      (dolist (entities entities)
	(add-entities-internal entities))
      (setf (drawing-selected-entities current-drawing)
	    (sort (drawing-selected-entities current-drawing)
		  #'< :key #'graphic-entity-graphics-priority))
      (redisplay-handles)
      entities)))

(defundo entity-grouper (program groups entities))

(defflavor group-entities () (entity-grouper))

(defmethod (undo-element-redo group-entities) ()
  (entities-to-groups program groups entities))

(defmethod (undo-element-undo group-entities) ()
  (setq entities (groups-to-entities program groups)))

(defflavor ungroup-entities () (entity-grouper))

(defmethod (undo-element-redo ungroup-entities) ()
  (setq entities (groups-to-entities program groups)))

(defmethod (undo-element-undo ungroup-entities) ()
  (entities-to-groups program groups entities))

(define-selected-entity-command (com-group-entity "Group" :menu-level :selection)
				(entities)
  (do-undoably-modifying 'group-entities (entity-undo-description "Group" entities)
			 (list (make-instance (entity-shape-flavor *group-entity-shape*)
					      :name (entity-shape-new-name
						      *group-entity-shape*)))
			 (list entities)))

(define-selected-entity-command (com-ungroup-entity "Ungroup"
				  :menu-level :selection
				  :entity-translator-type group-entity-output
				  :entity-predicate (lambda (entity)
						      (typep entity 'group-entity)))
				(entities)
  (dolist (entity entities)
    (unless (typep entity 'group-entity)
      (dw:command-error "~A is not a group." (graphic-entity-name entity))))
  (do-undoably-modifying 'ungroup-entities
			 (entity-undo-description "Ungroup" entities)
			 entities nil))

;;;; View menu

(define-graphic-editor-command (com-refresh :menu-accelerator t :menu-level :view) ()
  (redisplay-drawing :preserve-viewport t))

(defundo set-view-transform (program view-transform preserve-viewport saved-view-transform))

(defmethod (undo-element-redo set-view-transform) ()
  (setq saved-view-transform (set-view-transform program view-transform preserve-viewport)))

(defmethod (undo-element-undo set-view-transform) ()
  (set-view-transform program saved-view-transform preserve-viewport))

(defmethod (set-view-transform graphic-editor) (new-transform &optional preserve-viewport)
  (let ((old-transform (drawing-view-transform current-drawing)))
    (multiple-value-bind (left top right bottom)
	(send dw:*program-frame* :send-pane 'drawing :visible-cursorpos-limits)
      (multiple-value-bind (center-x center-y)
	  (graphics:untransform-point (/ (+ left right) 2) (/ (+ top bottom) 2)
				      drawing-transform)
	(setf (drawing-view-transform current-drawing) new-transform)
	(redisplay-drawing :preserve-viewport nil)
	(multiple-value-setq (center-x center-y)
	  (graphics:transform-point center-x center-y drawing-transform))
	(setq left (max 0 (round (- center-x (/ (- right left) 2))))
	      top (max 0 (round (- center-y (/ (- bottom top) 2))))))
      (when preserve-viewport
	(send dw:*program-frame* :send-pane 'drawing :set-viewport-position left top)))
    old-transform))

(defun-in-flavor (set-view-transform-undoably graphic-editor) (reason new-transform
							       &optional preserve-viewport)
  (do-undoably 'set-view-transform reason new-transform preserve-viewport))

(defun-in-flavor (add-view-transform-undoably graphic-editor) (reason new-transform
							       &optional preserve-viewport)
  (stack-let ((temp (graphics:make-graphics-transform)))
    (replace temp (drawing-view-transform current-drawing))
    (graphics:compose-transforms temp new-transform)
    (replace new-transform temp))
  (set-view-transform-undoably reason new-transform preserve-viewport))

(define-command-default *default-zoom-factor* 4 number "Zoom factor")

;;;--- Interactive?
(define-graphic-editor-command (com-zoom-by-factor :menu-accelerator "Zoom by Factor"
						   :menu-level :view)
    ((zoom-factor 'number :default *default-zoom-factor* :confirm t :prompt "Zoom factor"))
   (maybe-stick-command-defaults *default-zoom-factor* zoom-factor)
   (add-view-transform-undoably (format nil "Zoom by ~D" zoom-factor)
				(graphics:build-graphics-transform :scale zoom-factor)
				t))

(define-graphic-editor-command (com-reset-view :menu-accelerator t :menu-level :view)
    ()
   (do-undoably 'set-view-transform "Reset view" graphics:*identity-transform* nil))

(define-graphic-editor-command (com-move-view :menu-accelerator t :menu-level :view)
    ()
   (with-drawing-output ()
     (let ((transform (call-with-graphic-editor-mouse-blinker-options
			#'graphic-input:mouse-input-multiple-point-transform
			:number-of-points 2)))
       (add-view-transform-undoably "Move view" transform))))

(define-graphic-editor-command (com-center-view :menu-accelerator t :menu-level :view)
    ()
   (with-drawing-output ()
     (multiple-value-bind (dx dy)
	 (multiple-value-bind (drawing-center-x drawing-center-y)
	     (multiple-value-bind (left top right bottom)
		 (let ((set (drawing-entities current-drawing)))
		   (unless (plusp (length set))
		     (dw:command-error "There is nothing to center."))
		   (entities-bounding-box-edges set))
	       (values (/ (+ left right) 2) (/ (+ bottom top) 2)))
	   (multiple-value-bind (window-center-x window-center-y)
	       (multiple-value-bind (left top right bottom)
		   (send *standard-output* :visible-cursorpos-limits)
		 (graphics:untransform-point (/ (- right left) 2) (/ (- bottom top) 2)
					     (graphics:stream-transform *standard-output*)))
	     (values (- window-center-x drawing-center-x)
		     (- window-center-y drawing-center-y))))
       (add-view-transform-undoably "Center view" (list 1 0 0 1 dx dy)))))

(defun-in-flavor (fit-view-internal graphic-editor) (verb drawing-left drawing-top
							  drawing-right drawing-bottom)
  (when (or (= drawing-left drawing-right)
	    (= drawing-top drawing-bottom))
    (dw:command-error "You must specify a non-empty region."))
  (multiple-value-bind (window-left window-top window-right window-bottom)
      (send *standard-output* :visible-cursorpos-limits)
    (let ((scale (min (abs (/ (- window-right window-left)
			      (- drawing-right drawing-left)))
		      (abs (/ (- window-bottom window-top)
			      (- drawing-bottom drawing-top))))))
      (set-view-transform-undoably verb
				   (graphics:building-graphics-transform ()
				     (graphics:graphics-scale scale)
				     (graphics:graphics-translate (- drawing-left)
								  (- (min drawing-top
									  drawing-bottom)))
				     )))))

(define-graphic-editor-command (com-fit-view :menu-accelerator t :menu-level :view)
    ()
   (with-drawing-output ()
     (multiple-value-bind (drawing-left drawing-top drawing-right drawing-bottom)
	 (let ((set (drawing-entities current-drawing)))
	   (unless (plusp (length set))
	     (dw:command-error "There is nothing to fit."))
	   (entities-bounding-box-edges set))
       (fit-view-internal "Fit view" drawing-left drawing-top drawing-right drawing-bottom))))

(define-graphic-editor-command (com-zoom/expand
				 :menu-accelerator "Zoom/Expand"
				 :menu-level :view
				 :menu-documentation "Make region occupy whole window")
    ()
   (with-drawing-output ()
     (multiple-value-bind (left top right bottom)
	 (call-with-graphic-editor-mouse-blinker-options #'graphic-input:mouse-input-rectangle
					      :first-who-line-documentation-string
 "L: Make region starting here occupy whole window; M: Abort.  Abort also aborts."
					      :second-whostate "Zooming region out"
					      :second-who-line-documentation-string
 "Release at other end of region to occupy whole window.  Abort aborts."
					      :dashed t)
       (fit-view-internal "Zoom region out" left top right bottom))))

(define-graphic-editor-command (com-zoom/contract
				 :menu-accelerator "Zoom/Contract"
				 :menu-level :view
				 :menu-documentation "Make region contain current view")
    ()
   (with-drawing-output ()
     (multiple-value-bind (drawing-left drawing-top drawing-right drawing-bottom)
	 (call-with-graphic-editor-mouse-blinker-options #'graphic-input:mouse-input-rectangle
					      :first-who-line-documentation-string
 "L: Make region starting here contain current view; M: Abort.  Abort also aborts."
					      :second-whostate "Zooming into region"
					      :second-who-line-documentation-string
 "Release at other end of region to contain present view.  Abort aborts."
					      :dashed t)
       (when (or (= drawing-left drawing-right)
		 (= drawing-top drawing-bottom))
	 (dw:command-error "You must specify a non-empty region."))
       (multiple-value-bind (window-left window-top window-right window-bottom)
	   (send *standard-output* :visible-cursorpos-limits)
	 (let ((scale (min (abs (/ (- drawing-right drawing-left)
				   (- window-right window-left)))
			   (abs (/ (- drawing-bottom drawing-top)
				   (- window-bottom window-top))))))
	   (set-view-transform-undoably "Zoom into Region"
					(graphics:building-graphics-transform ()
					  (graphics:graphics-translate drawing-left
								       (min drawing-top
									    drawing-bottom))
					  (graphics:graphics-scale scale))))))))

;;;; Registers
;;; This code overlaps with some in the bitmap editor, but just not quite enough.

(defflavor register
	(name
	 (entities nil)
	 (left 0) (top 100) (right 100) (bottom 0)
	 (scale 1)
	 )
	()
  :initable-instance-variables
  :readable-instance-variables
  (:writable-instance-variables entities scale)
  (:constructor make-register (&key name)))

(defmethod (register-empty-p register) () (null entities))

(defmethod (register-size register) ()
  (values (- right left) (- bottom top)))

(defmethod (register-set-edges register) (new-left new-top new-right new-bottom)
  (setq left new-left
	top new-top
	right new-right
	bottom new-bottom))

(defmethod (draw-register register) (&optional (stream (dw:get-program-pane 'registers)))
  (send stream :clear-region left top right bottom)
  (dw:with-output-as-presentation (:object self :type 'register
				   :stream stream
				   :displayed-box (dw::make-box left top right bottom)
				   :highlighting-boxes `(:boxes ((,left ,top ,right ,bottom)))
				   :single-box t)
    (when entities
      (graphics:with-graphics-transform (stream (list 1 0 0 -1 left bottom))
	(graphics:with-graphics-scale (stream scale)
	  (let ((*standard-output* stream))
	    (dolist (entity entities)
	      (entity-output-1 entity))))))))

(define-presentation-type register ((&key editor))
   :no-deftype t
   :parser ((stream)
	    (unless editor
	      (setq editor (current-graphic-editor)))
	    (dw:complete-from-sequence (graphic-editor-registers editor) stream
				       :name-key #'register-name))
   :printer ((register stream)
	     (write-string (register-name register) stream)))

(compile-flavor-methods register)

(defmethod (draw-registers graphic-editor) (pane)
  (multiple-value-bind (nil nil width height)
      (send pane :visible-cursorpos-limits)
    (let* ((ncols 3) (nrows 1)			;Seems like a good number
	   (register-width (- (floor width ncols) 4))
	   (register-height (- (floor height nrows) 4))
	   (left (floor (- width (1+ (* ncols (+ register-width 2)))) 2))
	   (top (floor (- height (1+ (* nrows (+ register-height 2)))) 2)))
      (let ((olength (length registers))
	    (nlength (* nrows ncols)))
	(when (> nlength olength)
	  (loop for i from olength below nlength do
	    (vector-push-extend (make-register :name (format nil "Register-~D" (1+ i)))
				registers))))
      (let ((right (+ left (* ncols (+ register-width 2)))))
	(loop repeat (1+ nrows) for y from top by (+ register-height 2) do
	  (graphics:draw-line left y right y :stream pane)))
      (let ((bottom (+ top (* nrows (+ register-height 2)))))
	(loop repeat (1+ ncols) for x from left by (+ register-width 2) do
	  (graphics:draw-line x top x bottom :stream pane)))
      (loop for y from top by (+ register-height 2)
	    for j below nrows do
	(loop for x from left by (+ register-width 2)
	      for i below ncols do
	  (let ((register (aref registers (+ i (* j ncols)))))
	    (register-set-edges register (+ x 2) (+ y 2)
				(+ x register-width 1) (+ y register-height 1))
	    (draw-register register pane)))))))

(defundo change-register (program register
				  add-to-drawing remove-from-drawing
				  new-register-contents new-register-scale
				  former-register-contents former-register-scale))

(defmethod (undo-element-redo change-register) ()
  (setq former-register-contents (register-entities register)
	former-register-scale (register-scale register))
  (when new-register-scale
    (setf (register-scale register) new-register-scale))
  (unless (eq former-register-contents new-register-contents)
    (setf (register-entities register) new-register-contents)
    (draw-register register))
  (when add-to-drawing
    (add-entities program add-to-drawing add-to-drawing))
  (when remove-from-drawing
    (delete-entities program remove-from-drawing nil)))

(defmethod (undo-element-undo change-register) ()
  (unless (eq former-register-contents (register-entities register))
    (setf (register-entities register) former-register-contents)
    (draw-register register))
  (when add-to-drawing
    (delete-entities program add-to-drawing nil))
  (when remove-from-drawing
    (add-entities program remove-from-drawing remove-from-drawing)))

(define-graphic-editor-command (com-retrieve-register )
			       ((register `((register :editor ,self))
					  :default (elt registers 0) :confirm t)
				&key
				(clear-afterwards 'boolean))
   (let* ((register-contents (register-entities register))
	  (copies (multiple-value-bind (x y click)
		      (with-drawing-output ()
			(stack-let ((transform (graphics:make-graphics-transform
						 :tx 0 :ty 0)))
			  (replace transform (graphics:stream-transform *standard-output*)
				   :end1 4)
			  (call-with-graphic-editor-mouse-blinker-options
			    (lambda (&rest args)
			      (graphic-input:dragging-output-with-mouse*
				(t :warp-mouse nil
				   :whostate "Position with mouse"
				   :who-line-documentation-string 
   "L: put down here; M: Abort.  Abort also aborts."
				   :translate-output t
				   args)
				(graphics:with-graphics-identity-transform ()
				  (graphics:graphics-transform transform)
				  (dolist (entity register-contents)
				    (entity-output-1 entity))))))))
		    (unless (eql click #\Mouse-Left)
		      (signal 'sys:abort))
		    (copy-entities register-contents
				   :transform (graphics:build-graphics-transform
						:translation (list x y))))))
     (when clear-afterwards
       (setq register-contents nil))
     (do-undoably-modifying 'change-register
			    (format nil "Retrieve ~A" (register-name register))
			    register copies nil register-contents)))

(define-selected-entity-command (com-store-into-register "Store into Register"
							 :gesture :yank-word
							 :menu-level ())
				(entities
				  (register `(type-or-string ((register :editor ,self)))
					    :default (elt registers 0) :confirm t)
				  &key
				  (delete-too 'boolean))
  (when (stringp register)
    (setq register (make-register :name register))
    (vector-push-extend register registers))
  (multiple-value-bind (copies scale)
      (multiple-value-bind (left top right bottom)
	  (with-drawing-output (:open-handles nil)
	    (entities-bounding-box-edges entities))
	(multiple-value-bind (rwidth rheight)
	    (register-size register)
	  (values (copy-entities entities :transform
				 (graphics:build-graphics-transform
				   :translation (list (- left) (- bottom))))
		  (min 1 (/ rwidth (abs (- right left))) (/ rheight (abs (- bottom top)))))))
    (do-undoably 'change-register (format nil "Store into ~A" (register-name register))
		 register nil (and delete-too entities) copies scale)))

(define-presentation-to-command-translator store-into-register
   (register :gesture ()
	     :documentation "Store Selected into this register")
   (register &key window)
  (let ((editor (current-graphic-editor :window window :error-p nil)))
    (when editor
      (let ((selected (drawing-selected-entities
			(graphic-editor-current-drawing editor))))
	(when selected
	  `(com-store-into-register ,selected ,register))))))

(define-presentation-to-command-translator retrieve-register
   (register :gesture ()
	     :documentation "Retrieve contents of this register")
   (register)
  (unless (register-empty-p register)
    `(com-retrieve-register ,register)))

;;;--- Is this overloading a loss?  Should the predicate be selected set, rather than empty?
(define-presentation-to-command-translator click-on-register
   (register :menu ()
	     :documentation ((register)
			     (if (register-empty-p register)
				 "Store Selected into this register"
				 "Retrieve contents of this register")))
   (register &key window)
  (if (not (register-empty-p register))
      `(com-retrieve-register ,register)
      (let ((editor (current-graphic-editor :window window :error-p nil)))
	(when editor
	  (let ((selected (drawing-selected-entities
			    (graphic-editor-current-drawing editor))))
	    (when selected
	      `(com-store-into-register ,selected ,register)))))))

(define-graphic-editor-command (com-clear-register )
			       ((register `((register :editor ,self))
					  :default (elt registers 0) :confirm t))
   (do-undoably 'change-register (format nil "Clear ~A" (register-name register))
		register nil nil nil 1))

(define-presentation-to-command-translator com-clear-register
					   (register :gesture ())
					   (register)
  `(com-clear-register ,register))

;;;; Help interface

(defmethod (graphic-editor-help graphic-editor) (stream string-so-far)
  (dw:help-program-help self stream string-so-far "
Click on a command from the menus at the right, 
or select a shape to enter from the menu at the bottom.
"))

(define-presentation-translator shape-help (entity-shape dw:help-topic)
				(shape &key window)
  (let ((program (dw:current-program :type 'dw:help-program :window window :error-p nil)))
    (when program
      (values
	(dw:help-topic-available program "the" (entity-shape-keyword-name shape)
				 :program "shape")))))

(define-presentation-translator register-help (register dw:help-topic) (ignore &key window)
  (let ((program (dw:current-program :type 'dw:help-program :window window :error-p nil)))
    (when program
      (values
	(dw:help-topic-available program "Graphic editor register mouse commands")))))

(define-presentation-to-command-translator help-about-this-shape
   (entity-shape :gesture :command-menu-help
		 :documentation ((shape)
				 (format nil "Help about the ~A shape"
					 (entity-shape-keyword-name shape))))
   (shape &key window)
  (let ((program (dw:current-program :type 'dw:help-program :window window :error-p nil)))
    (when program
      (dw:help-command-if-available program "the" (entity-shape-keyword-name shape)
				    :program "shape"))))

(define-presentation-to-command-translator help-about-registers
   (register :gesture :command-menu-help :documentation "Help about registers")
   (ignore &key window)
  (let ((program (dw:current-program :type 'dw:help-program :window window :error-p nil)))
    (when program
      (dw:help-command-if-available program "Graphic editor register mouse commands"))))

;;;; Temporary stuff

(define-graphic-editor-command (com-edit-interaction-style ) ()
  (let ((redisplay-p nil))
    (loop for (symbol value) in 
	      (dw:with-typeout-window-for-accept-values
		(dw:accepting-values ()
		  (loop for (symbol type prompt) in *interaction-style-options*
			collect (list symbol
				      (accept type
					      :prompt prompt
					      :default (symbol-value symbol))))))
	  do
      (when (and (member symbol '(*default-entity-highlighting-mode*))
		 (not (eql value (symbol-value symbol))))
	(setq redisplay-p t))
      (setf (symbol-value symbol) value))
    (when redisplay-p
      (redisplay-drawing :preserve-viewport t))))

;;;; Debugging tools

#||

(define-graphic-editor-command (com-where-am-i ) ((x 'number) (y 'number))
   (format t "~&Position is ~D,~D.~%" x y))

(define-presentation-to-command-translator where-am-i
					   (graphic-input:grid-output
					     :gesture :super-left
					     :blank-area t)
					   (ignore &key window x y)
  (multiple-value-bind (drawing-p x y)
      (drawing-window-point-p window x y)
    (when drawing-p
      `(com-where-am-i ,x ,y))))

(define-graphic-editor-command (com-warp-mouse ) ((x 'number) (y 'number))
   (multiple-value-setq (x y)
     (graphics:transform-point x y drawing-transform))
   (send (dw:get-program-pane 'drawing) :set-mouse-position (round x) (round y)))

(define-selected-entity-command (com-describe-entity "Describe" :menu-level :describe)
				(entities)
  (map () #'describe entities))

(define-graphic-editor-command (com-show-missing-help :provide-output-destination-keyword t)
    ()
   (dw::help-program-show-missing-help self)
   (let ((shapes (loop for entry in *entity-shape-alist*
		       as name = (entity-shape-name entry)
		       unless (dw:help-topic-available self "the" name :program "shape")
			 collect name)))
     (format t "~2&Shapes:~%")
     (format-item-list shapes)))

||#

;;; External interface

(defun find-drawing-named (file-name name)
  ;; create a graphic editor if necessary
  (let* ((program-window (dw:find-program-window 'graphic-editor))
	 (program (send program-window :program)))
    (find-drawing-named-1 program file-name name)))

;;; This could use some condition-handling.  What if the file is not found?
(defmethod (find-drawing-named-1 graphic-editor) (file-name name)
  (when file-name
    (setq file-name (fs:merge-pathnames file-name)))	;Might be string.
  (let ((file-drawings (file-drawings file-name)))
    (when (null file-drawings)
      (setq file-drawings (read-drawings-from-file file-name))
      (without-interrupts
	(setf (graphic-editor-loaded-drawings self)
	      (append (graphic-editor-loaded-drawings self) file-drawings))))
    (or (find name file-drawings :test #'string-equal :key #'drawing-name)
	(if file-name
	    (dw:command-error "The drawing named ~A was not found in the file ~A."
			      name file-name)
	    (dw:command-error "The drawing named ~A is not currently in the graphic editor and is not
associated with any file." name)))))

;;; external interface to graphic editor internals
(sage:define-picture-type :graphic-editor
  :binary-encoding binary-encoding-for-drawing-named
  :edit-drawing edit-drawing-named
  :argument-reader read-drawing-pathname-and-name)

;;; So concordia can DYNAMIC-FLET this.
(defun (2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")locate-graphic-editor0 ()
  (let ((program-window (dw:find-program-window 'graphic-editor)))
    (send program-window :program)))

(defun 2binary-encoding-for-drawing-named0 (file-name name)
  (binary-encoding-for-drawing-named-1 (locate-graphic-editor) file-name name))

(defmethod (binary-encoding-for-drawing-named-1 graphic-editor) (file-name name)
  (let ((drawing (find-drawing-named-1 self file-name name)))
    (when (zerop (length (drawing-entities drawing)))
      (dw:command-error "The drawing ~A is empty." (drawing-name drawing)))
    (drawing-binary-encoding drawing)))

(defun 2edit-drawing-named0 (file-name name)
  (edit-drawing-named-1 (locate-graphic-editor) file-name name))

(defmethod (edit-drawing-named-1 graphic-editor) (file-name name)
  (setq mailbox nil)
  (send dw::frame :select)
  (send (send dw::frame :get-pane 'drawing) :force-kbd-input
	(dw::make-presentation-blip
	  :presentation-type 'window-wakeup-synchronous-select-new-drawing
	  :object `(,file-name ,name)))
  (process-wait "Wait for Graphic Editor" #'(lambda () mailbox))
  mailbox)

(define-presentation-type drawing-or-pathname ((&key editor))
   :parser ((stream)
	    (let ((start-loc (send stream :read-location)))
	      (condition-case ()
		   (dw:with-accept-help ((:subhelp "You can either enter the name of a drawing presently loaded into the graphic editor,
or you can enter the name of a pathname in which a drawing can be found."))
		     (accept `((drawing :editor ,editor)) :stream stream
			     :default nil
			     :prompt nil))
		 (sys:parse-error
		   (send stream :set-location start-loc)
		   (accept 'pathname :stream stream :default nil :prompt nil)))))
   :printer ((thing stream)
	     (present thing (type-of thing) :stream stream)))

(defun 2read-drawing-pathname-and-name0 ()
  (read-drawing-pathname-and-name-1 (locate-graphic-editor)))

(defmethod (read-drawing-pathname-and-name-1 graphic-editor) ()
  (let ((thing (zwei:typein-line-accept
		 `((drawing-or-pathname :editor ,self))
		 :default (and (variable-boundp current-drawing)
			       current-drawing)
		 :prompt "Enter the name of a loaded drawing or a pathname")))
    (cond ((typep thing 'drawing)
	   (unless (drawing-file thing)
	     (warn "The drawing ~A is not associated with any file.  ~
                    You should save it first." (drawing-name thing)))
	   (values (drawing-file thing)
		   (drawing-name thing)))
	  (t (values thing
		     (zwei:typein-line-accept
		       `((member ,@(getf (fs:pathname-attribute-list thing) 'drawings-in-file))
			 :description "a drawing")
		       :prompt (format nil "Enter the name of a drawing ~
                                       ( for a list of drawings in file ~a)" thing)))))))
