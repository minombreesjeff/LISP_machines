;;; -*- Syntax: Zetalisp; Package: SYSTEM-INTERNALS; Mode: LISP; Base: 8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Random machine independent lisp functions.
;;; This file is in the cold load.

;;; This is need so that old BIN files will load.
(defmacro dbg:fasd-instance (flavor &rest args)
  `(lexpr-funcall #'make-instance ',flavor ',args))

;;; This is needed here so FDEFINE, DEFVAR-1-INTERNAL, etc don't trip
;;; from the cold load.  Rest of who-calls moved from LISPFN to
;;; who-calls in the utilities system.

(defvar *who-calls-mode* ':uninitialized
  "One of :UNINITIALIZED, :DISABLED, :MAKING, :ALL, :NEW, or :EXPLICIT.  
Use the SI:ENABLE-WHO-CALLS function to set this.")

;; A defconstant whose value is effectively defconstantable may be open-compiled.
;; An object is effectively defconstantable if it can be dumped out into multiple
;; BIN files and after the files are reloaded all the "copies" of the object are EQL.
;; This means numbers, characters, and interned symbols.

(defun effectively-defconstantable-evalled (x)		;already optimized
  (or (effectively-defconstantable-self-evaluating x)
      (and (symbolp x) (not (null (symbol-package x))))))

(defun effectively-defconstantable-self-evaluating (x)
  (or (numberp x)
      (si:characterp x)
      (keywordp x)
      (eq x t)
      (eq x nil)
      #+IMACH
      (physical-address-p x)))

(defun effectively-defconstantable (x)		;X is a form
  (cond ((atom x) (effectively-defconstantable-self-evaluating x))
	((and (eq (car x) 'quote)
	      (cdr x)
	      (null (cddr x))
	      (atom (cadr x)))
	 (effectively-defconstantable-evalled (cadr x)))
	(t nil)))

;; Used by DEFVAR-STANDARD, etc.
(defun remember-variable-binding (name value list)
  (let ((old-value (assq name (symeval list))))
    (cond (old-value
	   (setf (second old-value) value))
	  (t
	   (cl:push (list name value (locf (symeval name))) (symeval list) :localize 2)))))

;; Boundedness

;; LOCATION-BOUNDP is in microcode

(defun location-makunbound (loc &optional variable-name)
  (setq loc (follow-cell-forwarding loc t))
  (%p-store-cdr-type-and-pointer loc (%p-cdr-code loc) dtp-null
				 (or variable-name (%find-structure-header loc)))
  variable-name)

(defun makunbound (symbol)
  (check-symbol-setability symbol "make unbound")
  (variable-makunbound (symeval symbol) symbol)
  symbol)

(defun fmakunbound (symbol)
  (variable-makunbound (fsymeval symbol) symbol)
  symbol)

;;; Globally stuff

;;; Accessing global variable values, bypassing any bindings in the current stack group

(defun global-cell-location (cell)
  (dbg:cell-location-in-stack-group cell %current-stack-group :bottom))

(defun global-value-cell-location (var)
  (declare lt:(side-effects reader))
  (locf (global-value (symeval var))))

(defun scl:symbol-value-globally (var)
  (declare lt:(side-effects reader))
  (global-value (symeval var)))

(cl:defsetf scl:symbol-value-globally (var) (val)
  `(setf (si:global-value (cl:symbol-value ,var)) ,val))

(defun (:property setq-globally :undo-function) (form)
  `(progn ,@(loop for (var value) on (cdr form) by 'cddr
		  for global-cell = (locf (global-value (symeval var)))
		  do (ignore value)
		  collect (if (location-boundp global-cell)
			      `(set-globally ',var ',(location-contents global-cell))
			      `(makunbound-globally ',var)))))

(defun set-globally (var value)
  (cl:setf (global-value (symeval var)) value))

(defun makunbound-globally (var)
  (variable-makunbound (global-value (symeval var)) var))

(defun boundp-globally (var)
  (declare lt:(side-effects reader))
  (variable-boundp (global-value (symeval var))))

;;;; Symbol related functions

(defun plist (symbol)
  (declare lt:(side-effects reader))
  (argument-typecase symbol
    (:symbol (cl:symbol-plist symbol))
    (:locative (location-contents symbol))
    (:list (cdr symbol))))

(defun setplist (symbol list)
  (argument-typecase symbol
    (:symbol (setf (cl:symbol-plist symbol) list))
    (:locative (setf (location-contents symbol) list))
    (:list (setf (cdr symbol) list)))
  list)

(defun fset (symbol definition)
  (cl:setf (location-contents (locf (cl:symbol-function symbol))) definition))

(defvar-resettable area-for-property-lists property-list-area)

(defun putprop (sym value indicator)
  (argument-typecase sym
    (:symbol
      (cli::putprop sym value indicator))
    ((:locative :list)
     (setf (cl:getf (cdr sym) indicator) value)))
  value)

;; This is Zetalisp/MacLisp-compatibility REMPROP.
;; It always uses RPLACD to destruct the list, and returns a sublist pointer,
;; doesn't remove pointers to removed property values.
;; New programs should use ZL:NREMPROP or the Common Lisp functions.
(defun remprop (sym indicator &aux ppl pl)
  "Remove a property.  Returns NIL if not present, or a sublist whose CAR is the property."
  (argument-typecase sym
    (:symbol (setq ppl (locf (plist sym))))
    ((:locative :list) (setq ppl sym)))
  (setq pl (cdr ppl))
  (without-interrupts
    (loop do
      (compiler:%error-when (endp pl)
	(return nil))
      (compiler:%error-when (eq (pop pl) indicator)
	(setf (location-contents ppl) (cdr pl))
	(return pl))
      (psetq ppl pl pl (cdr pl)))))

;; This is "New", or "Destructive" remprop.  It is just like Common Lisp
;; REMPROP except that it also works on disembodied plists.
(defun nremprop (sym indicator &aux ppl)
  (argument-typecase sym
    (:symbol (setq ppl (locf (plist sym))))
    ((:locative :list) (setq ppl sym)))
  (cl:remf (location-contents ppl) indicator))

;;Like FOLLOW-STRUCTURE-FORWARDING
;;This is now in microcode
#||
(defun follow-cell-forwarding (loc evcp-p)
  (do () (nil)
    (select (%p-data-type loc)
      ((dtp-header-forward dtp-body-forward #+3600 dtp-element-forward)
       (setq loc (follow-structure-forwarding loc)))
      (dtp-one-q-forward
       (setq loc (%make-pointer (%data-type loc) (%p-contents-as-locative loc))))
      (dtp-external-value-cell-pointer
       (or evcp-p (return loc))
       (setq loc (%make-pointer (%data-type loc) (%p-contents-as-locative loc))))
      (otherwise (return loc)))))
||#

#+3600
(defun %p-safe-pointer (p)
  (if (%pointer-type-p (%p-data-type p))
      (%p-contents-as-locative p)
      (%p-pointer p)))

#+3600
(defun %p-copy-q (from to &aux (inhibit-scheduling-flag t))
  (%p-store-tag-and-pointer to
			    (%p-ldb %%q-all-but-pointer from)
			    (%p-safe-pointer from)))

#+IMACH
(defsubst %p-copy-q (from to)
  (%memory-write to (%memory-read from :cycle-type %memory-scavenge :set-cdr-next nil)))

;Get pointer field of a memory location as either a number or a locative
;depending on the data type.  This probably ought to be built in.
(defun car-location (cons)
  (declare lt:(side-effects reader))
  (cl:check-type cons cl:cons)
  (%make-pointer dtp-locative cons))

(defun get-location (symbol property &optional default)
  (argument-typecase symbol
    (:symbol (locf (cl:getf (cl:symbol-plist symbol) property default)))
    (:list (locf (cl:getf (cdr symbol) property default)))
    (:locative (locf (cl:getf (location-contents symbol) property default)))))

(defvar *gensym-prefix #/G)
(defvar *gensym-counter 0)

(defun gensym (&optional arg &aux pname)
  (declare lt:(side-effects reader))
  (cond ((null arg))
	((numberp arg)
	 (setq *gensym-counter arg))
	((symbolp arg)
	 (setq *gensym-prefix (aref (get-pname arg) 0)))
	((stringp arg)
	 (setq *gensym-prefix (aref arg 0))))
  (and (> (setq *gensym-counter (1+ *gensym-counter)) 9999.)
       (setq *gensym-counter 0))
  (setq pname (make-array 5 ':type 'art-string))
  (setf (aref pname 0) *gensym-prefix)
  (setf (aref pname 1) (digit-char (// *gensym-counter 1000.)))
  (setf (aref pname 2) (digit-char (\ (// *gensym-counter 100.) 10.)))
  (setf (aref pname 3) (digit-char (\ (// *gensym-counter 10.) 10.)))
  (setf (aref pname 4) (digit-char (\ *gensym-counter 10.)))
  (make-symbol pname))

(defun samepnamep (x y)
  (declare lt:(side-effects simple reducible))
  (string= (get-pname x) (get-pname y)))

;;; Function calling functions

(defsubst apply (fn args)
  (declare (sys:downward-funarg fn))
  (cl:apply fn args))

(defun funcall (fn &rest args)
  (declare (sys:downward-funarg fn))
  #+IMACH (declare (sys:wired-function))	;Compiler sometimes generates this.
  (apply fn args))

;The elements of <ARGS> are arguments to be supplied to <FUNCTION>,
; except for the last one, which is a list whose elements are arguments
; to be supplied to <FUNCTION>.
(defun cl:apply (function argument &rest arguments)
  (declare (sys:downward-funarg function))
  (let ((nargs (1+ (length arguments))))
    (%start-function-call function return nargs t)
    ;; Push the spread arguments and the rest argument
    (%push argument)
    (cl:loop
       (when (null arguments) (return))
       (%push (pop arguments)))
    (%finish-function-call function return nargs t)))

(defun handler-max-number-of-args (function arg)
  (loop while (symbolp function)
	do (setq function (cl:symbol-function function)))
  (let ((handler (cl:typecase function
		   (scl:instance
		     (get-handler-for function arg))
		   (sys:generic-function
		     ;; get handler only if there isn't an explicit g-f arglist
		     (and (not (flavor::generic-function-explicit function))
			  (get-handler-for arg (generic-function-name function)))))))
    (and handler
	 ;; subtract for mapping table, generic
	 (- (function-max-number-of-args handler) #+3600 2 #+IMACH 1))))

;(CALL function arg-desc-1 arg-data-1 arg-desc-2 arg-data-2 ...)
;The first argument is a function to call.
;The remaining arguments are in pairs, consisting of
;a descriptor arg and a data arg.
;The descriptor arg says what to do with the data arg.
;The descriptor arg value should be either a keyword or
;a list of keywords, the allowed keywords being :SPREAD and :OPTIONAL.
;:SPREAD means that the data argument is a list of arguments
;rather than a single argument.
;:OPTIONAL means that the data argument can be ignored if
;the function being called doesn't ask for it.
;After the first :OPTIONAL, all args supplied are considered optional.

;;; Remember, on a 3600 you cannot create local variables after %start-function-call
(defun call (fn &rest alternates &aux (fn-max-args (function-max-number-of-args fn)))
  (declare (sys:downward-funarg fn))
  (do ((count-only t nil)
       (n-args 0)
       max-args handler-max-args
       y optional-flag spread-flag		;for expansion of major do loop
       x .selectq-item.)			;for other locals
      (nil)
    (or count-only (%start-function-call fn return n-args nil))
    (prog nil					;major do loop expanded
	  (setq max-args fn-max-args
		y alternates
		optional-flag nil
		spread-flag nil)
	  (go end-test)
       iterate (setq y (cddr y)
		     spread-flag nil)
       end-test (if (null y) (return nil))
       body (cond ((and (symbolp (car y)) (not (null (car y))))
		   (setq .selectq-item. (car y))
		   (selectq .selectq-item.
		     (:spread (setq spread-flag t))
		     (:optional (setq optional-flag t))
		     (otherwise (ferror "Invalid CALL keyword ~S" (car y)))))
		  (t (prog nil
			   (setq x (car y))
			   (go end-test)
			iterate (setq x (cdr x))
			end-test (if (null x) (return nil))
			body
			   (setq .selectq-item. (car x))
			   (selectq .selectq-item.
			     (:spread (setq spread-flag t))
			     (:optional (setq optional-flag t))
			     (otherwise (ferror "Invalid CALL keyword ~S" (car x))))
			   (go iterate))))
	  (and optional-flag (<= max-args 0)
	       (return nil))
	  (cond (spread-flag
		 (prog nil
		       (setq x (cadr y))
		       (go end-test)
		    iterate (setq x (cdr x))
		    end-test (if (or (null x) (and optional-flag (<= max-args 0)))
				 (return nil))
		    body
		       (cond (count-only
			      (when (zerop n-args)
				(setq handler-max-args (handler-max-number-of-args fn (car x)))
				(when handler-max-args
				  (setq fn-max-args handler-max-args)
				  (setq max-args handler-max-args)))
			      (incf n-args))
			     (t (%push (car x))))
		       (setq max-args (1- max-args))
		       (go iterate)))
		(t
		 (cond (count-only
			(when (zerop n-args)
			  (setq handler-max-args (handler-max-number-of-args fn (cadr y)))
			  (when handler-max-args
			    (setq fn-max-args handler-max-args)
			    (setq max-args handler-max-args)))
			(incf n-args))
		       (t (%push (cadr y))))
		 (setq max-args (1- max-args))))
	  (go iterate))
    (or count-only (return-from call (%finish-function-call fn return n-args nil)))))

;;; ;;; Old definition, which is wrong, since max-args is not reset in the frame build loop
;;; (DEFUN CALL (FN &REST ALTERNATES &AUX (MAX-ARGS (FUNCTION-MAX-NUMBER-OF-ARGS FN)))
;;;   (DO ((COUNT-ONLY T NIL)
;;;        (N-ARGS 0))
;;;       (NIL)
;;;     (OR COUNT-ONLY (%START-FUNCTION-CALL FN RETURN N-ARGS NIL))
;;;     (DO ((Y ALTERNATES (CDDR Y))
;;; 	 (OPTIONAL-FLAG)
;;; 	 (SPREAD-FLAG NIL NIL))
;;; 	((NULL Y))
;;;       (COND ((AND (SYMBOLP (CAR Y)) (NOT (NULL (CAR Y))))
;;; 	     (SELECTQ (CAR Y)
;;; 	       (:SPREAD (SETQ SPREAD-FLAG T))
;;; 	       (:OPTIONAL (SETQ OPTIONAL-FLAG T))
;;; 	       (OTHERWISE (FERROR "Invalid CALL keyword ~S" (CAR Y)))))
;;; 	    (T (DO X (CAR Y) (CDR X) (NULL X)
;;; 		   (SELECTQ (CAR X)
;;; 		     (:SPREAD (SETQ SPREAD-FLAG T))
;;; 		     (:OPTIONAL (SETQ OPTIONAL-FLAG T))
;;; 		     (OTHERWISE (FERROR "Invalid CALL keyword ~S" (CAR X)))))))
;;;       (AND OPTIONAL-FLAG (<= MAX-ARGS 0)
;;; 	   (RETURN NIL))
;;;       (COND (SPREAD-FLAG
;;; 	     (DO X (CADR Y) (CDR X) (OR (NULL X) (AND OPTIONAL-FLAG (<= MAX-ARGS 0)))
;;; 		 (IF COUNT-ONLY (INCF N-ARGS) (%PUSH (CAR X)))
;;; 		 (SETQ MAX-ARGS (1- MAX-ARGS))))
;;; 	    (T
;;; 	     (IF COUNT-ONLY (INCF N-ARGS) (%PUSH (CADR Y)))
;;; 	     (SETQ MAX-ARGS (1- MAX-ARGS)))))
;;;     (OR COUNT-ONLY (%FINISH-FUNCTION-CALL FN RETURN N-ARGS NIL))))


(defun prog1 (value &rest ignore)
  (declare lt:(arg-template return (repeat effect)))
  (declare lt:(side-effects simple reducible))
  value)

(defun prog2 (ignore value &rest ignore)
  (declare lt:(arg-template effect return (repeat effect)))
  (declare lt:(side-effects simple reducible))
  value)

(defun values (&rest values)
  (declare lt:(arg-template (repeat return)))
  (declare lt:(side-effects simple))
  (%values-list values))

(defun values-list (values)
  (declare lt:(side-effects simple reducible))
  (%values-list values))			;expanded by compiler into appropriate code

(defun %non-local-go (tag tag-name pc)
  (condition-case ()
       (throw tag pc)
     (throw-tag-not-seen
       (error "GO tag ~S is no longer dynamically active." tag-name))))

(defun %return-from-lambda (tag block-name &rest return-values)
  (condition-case ()
      (throw tag (values-list return-values))
     (throw-tag-not-seen
       (error "BLOCK ~S is no longer dynamically active." block-name))))

(defun %dispatch-elt (value pc-array limit)
  (if (and (fixp value)
	   (<= 0 value)
	   (< value limit))
      (location-contents (%make-pointer-offset dtp-locative pc-array (1+ value)))
      (car pc-array)))

;;; List manipulation functions.

#+3600
(defun last-escape (list)
  (declare (safeguarded-function) lt:(side-effects reader reducible))
  (if (atom list)
      list
      (do ((p list list))
	  (nil)
	(setf list (cdr list))
	(when (atom list) (return p)))))

#+3600
(defun length-internal (x i)
  (declare (cl:type cl:list x))
  (declare lt:(side-effects reader reducible))
  (declare (compiler:return-type cl:fixnum))
  (declare (safeguarded-function disable-reference-validation))
  (check-arg x (cl:listp x) "a list")
  (do ()
      ((atom x) i)
    (incf i)
    (setf x (cdr x))))

#+3600
(defun cl-length-internal (x i)
  (declare (cl:type cl:sequence x))
  (declare lt:(side-effects reader reducible))
  (declare (compiler:return-type cl:fixnum))
  (declare (safeguarded-function disable-reference-validation))
  (cl:etypecase x
    (cl:list
      (do ()
	  ((atom x) i)
	(incf i)
	(setf x (cdr x))))
    (cl:array
      (+ i (sys:vector-length x)))))

(defsubst make-list (length &key area initial-value)
  (declare lt:(side-effects reader))
  (%make-list initial-value area length))

(defun reverse (list)
  (declare lt:(side-effects reader))
  (prog (v)
 	(when (atom list) (go end))
  l	(setq v (cons (car list) v))
	(setq list (cdr list))
	(unless (atom list) (go l))
  end   (return v)))

;; Highly bummed REVERSE which returns a cdr-coded list by making two passes.
(defun %reverse-and-cdr-code (list &optional area)
  (declare lt:(side-effects reader))
  (when list
    (let* ((length (length list))
	   (new-list (%make-list nil area length))
	   (pointer (%make-pointer-offset dtp-locative new-list (1- length))))
      ;; Have to do the last cons separately in order to preserve the CDR-NIL.
      ;; %P-STORE-CONTENTS-POINTER-DECREMENT inserts CDR-NIL
      (setf (location-contents pointer) (car list))
      (if (null (cdr list))
	  new-list
	(setf pointer (%make-pointer-offset dtp-locative pointer -1))
	(do* ((l (cdr list) next)
	      (next (cdr l) (cdr next)))
	     ((atom next)
	      (%p-store-contents pointer (car l))	;Don't leave an illegal pointer here.
	      new-list)
	  (%p-store-contents-pointer-decrement (car l) pointer))))))

(defun default-copy-area-argument (list)
  (if (atom list)
      default-cons-area
      (let* ((region (%region-number list))
	     (bits (region-bits region)))
	(if (or (ldb-test %%region-stack bits)
		(ldb-test %%region-read-only bits)
		(ldb-test %%region-no-cons bits)
		(let ((level (ldb %%region-level bits)))
		  (or (= level %safeguarded-level) (= level %wired-level))))
	    default-cons-area
	    (region-area region)))))

(defun copylist (list &optional area force-dotted)
  "Copy top level of list structure.  Dotted pair termination of list will be copied"
  (declare lt:(side-effects reader))
  (unless area
    (setq area (default-copy-area-argument list)))
  (if (atom list)
      list					;Might be NIL
      (let ((dotted (or force-dotted (cdr (last list)))))
	(let ((newlist (make-list (if dotted (1+ (length list)) (length list))
				  :area area)))
	  (do ((l1 list (cdr l1))
	       (l2 newlist (cdr l2))
	       (ol2 nil l2))
	      ((atom l1)
	       (cond (dotted
		      (rplaca l2 l1)
		      (%change-list-to-cons ol2))))
	    (rplaca l2 (car l1)))
	  newlist))))

(defun copylist* (list &optional area)
  "Like COPYLIST but never cdr-codes the last pair of the list."
  (declare lt:(side-effects reader))
  (copylist list area t))

(defun copyalist (al &optional area)
  "Copies top two levels of list structure.  Dotted pair termination of list will be copied"
  (declare lt:(side-effects reader))
  (unless area
    (setq area (default-copy-area-argument al)))
  (cond ((nlistp al) al)
	(t (setq al (copylist al area t))	  ;RECOPY THE TOP LEVEL.
	   (let ((default-cons-area (or area default-cons-area)))
	     (do ((p al (cdr p)))
		 ((nlistp p) al)
	       (cond ((listp (car p))		  ;THEN RECOPY THE ASSOC CELLS.
		      (rplaca p (cons (caar p) (cdar p))))))))))

;;; (SUBST NIL NIL ...) is such an ugly language idiom...
(defun copytree (tree &optional area)
  "Copies a binary tree of CONSES.  The result is optimally cdr-coded."
  (declare lt:(side-effects reader))
  (unless area
    (setq area (default-copy-area-argument tree)))
  (if (atom tree)
      tree
      (let ((result (copylist tree area)))
	(do ((r result (cdr r))) ((nlistp r) result)
	  (rplaca r (copytree (car r) area))))))

(defun copytree-and-leaves (tree &optional area)
  (declare lt:(side-effects reader))
  (unless area
    (setq area (default-copy-area-argument tree)))
  (typecase tree
    (:list (let ((result (copylist tree area)))
	     (do ((last nil r)
		  (r result (cdr r)))
		 ((nlistp r)
		  (when r (rplacd last (copytree-and-leaves r area)))
		  result)
	       (rplaca r (copytree-and-leaves (car r) area)))))
    (:string (substring tree 0 nil area))
    (:extended-number (copy-extended-number tree area))
    (otherwise tree)))

;;; This function may be very slow in the general case, for long lists.
;;; But applying it at the appropriate level of a specific
;;; structure-copying routine (furnishing a common externally-created
;;; hash table) is likely to yield all the sharing possible, at a much
;;; lower computational cost.  Example: apply COPYTREE-SHARE only to the
;;; branches of a long alist.
;;; If CDR-CODE is non-NIL, then lists will never be "forked" part way through
;;; to enable sharing a tail.  This wastes space but improves locality.
(defun copytree-share
       (tree &optional area
	(hash (cl:make-hash-table :test #'equal :locking nil :number-of-values 0))
	cdr-code)
  "Copies a binary tree of CONSES.  The result is optimally cdr-coded as well as EQUAL shared"
  (unless area
    (setf area (default-copy-area-argument tree)))
  (typecase tree
    (#+commonlisp cons #-commonlisp :list
     (multiple-value-bind (unshared-length last puthash-length)
	 (loop with length = (length tree)
	       for unshared-length downfrom (if cdr-code 0 (1- length)) to 0
	       as last-shared = (nthcdr length tree) then shared
	       as branch = (nthcdr unshared-length tree)
	       as shared = (multiple-value-bind (nil nil shared)
			       (cl:gethash branch hash)
			     shared)
	       when (not shared)
		 return (cond (cdr-code (values length nil length))
			      ((and (listp last-shared) (null (cdr last-shared)))
			       ;; Case where cdr-next followed by cdr-nil
			       ;; is as good as a cdr-normal pair
			       (values length nil (1- length)))
			      (t (values (1+ unshared-length) last-shared
					 (1+ unshared-length))))
	       finally (return (values 0 shared 0)))
       (if (zerop unshared-length)
	   last
	   (let ((result (make-list (+ unshared-length (if last 1 0)) :area area)))
	     ;; first make the list structure EQUAL
	     (loop for len upfrom 1
		   for ntree on result
		   for tree on tree
		   do (setf (car ntree) (car tree))
		      (when (and last (= len unshared-length))
			(%change-list-to-cons ntree)
			(setf (cdr ntree) last)
			(return)))
	     ;; now enter everything into the hash table
	     (loop repeat puthash-length
		   for subtree on result
		   do (setf (cl:gethash subtree hash) subtree))
	     ;; finally, copytree the CARs
	     (loop repeat unshared-length
		   for subtree on result
		   do (setf (car subtree) (copytree-share (car subtree) area hash cdr-code)))
	     result))))
    (:extended-number
     (copytree-share-copy-extended-number tree area hash))
    (:string
     (copytree-share-copy-string tree area hash))
    (otherwise tree)))

(defun copytree-share-copy-extended-number (tree area hash)
  (multiple-value-bind (nil foundp value)
      (cl:gethash tree hash)
    (if foundp value
	(let ((new (if ( (%area-number tree) area)
		       (copy-extended-number tree area)
		       tree)))
	  (setf (cl:gethash new hash) new)
	  new))))

(defun copytree-share-copy-string (tree area hash)
  (multiple-value-bind (nil foundp value)
      (cl:gethash tree hash)
    (if foundp value
	(let ((new (if ( (%area-number tree) area)
		       (substring tree 0 nil area)
		       tree)))
	  (setf (cl:gethash new hash) new)
	  new))))

(defun append (&rest lists)
  (declare lt:(side-effects reader))
  (prog (total-length argp val valp ovalp)
	(cond ((atom lists) (return nil))
	      ((atom (cdr lists)) 
		(return (car lists))))
	(setq total-length 0)
	;; Accumulate length of args we must copy
	(do ((argp lists (cdr argp)))
	    ((atom (cdr argp))
	     ;; Plus one more if the last arg is not NIL.
	     ;; But if all are NIL so far, leave it 0 as signal to COND that follows.
	     (and (car argp) (not (zerop total-length))
		  (setq total-length (1+ total-length))))
	  (setq total-length (+ total-length (length (car argp)))))
  	(cond ((zerop total-length) (return (car (last lists)))))
	(setq valp (setq val (make-list total-length)))
	(setq argp lists)
  l2	(cond ((null (cdr argp))
	       ;; When we reach the last arg, if it's NIL, we are done.
	       (or (car argp) (return val))
	       ;; Otherwise, stick in a pointer to the last arg,
	       ;; and then change it from an element to a cdr.
	       (rplaca valp (car argp))
	       (%change-list-to-cons ovalp)
	       (return val)))
	(do ((arglp (car argp) (cdr arglp)))
	    ((atom arglp) 
	     (setq argp (cdr argp))
	     (go l2))
	  (rplaca valp (car arglp))
	  (setq ovalp valp
		valp (cdr valp))) ))

;;; Optimized 2-argument version of the above.
#+3600
(defun append-2 (list-1 list-2)
  (declare lt:(side-effects reader))
  (cond ((null list-1)
	 list-2)
	((and (listp list-1)
	      (atom (cdr list-1)))
	 (cons (car list-1) list-2))
	(t
	 (let ((length (length list-1)))
	   (when list-2 (incf length))
	   (let ((result-ptr (%allocate-list-block length default-cons-area)))
	     (loop with ptr = (1- result-ptr)
		   do (%p-store-contents-increment-pointer (pop list-1) ptr)
		   until (atom list-1)
		   finally
		     (when list-2
		       (setf (%p-cdr-code ptr) cdr-normal)
		       (%p-store-contents-increment-pointer list-2 ptr))
		     (setf (%p-cdr-code ptr) cdr-nil))
	     (prog1 (%make-pointer dtp-list result-ptr)
		    (%frame-consing-done)))))))

#+IMACH
(defun append-2 (list-1 list-2)
  (declare lt:(side-effects reader))
  (cond ((null list-1)
	 list-2)
	((and (listp list-1)
	      (atom (cdr list-1)))
	 (cons (car list-1) list-2))
	(t
	 (let ((length (length list-1)))
	   (prog1
	     (%make-pointer dtp-list (%allocate-list-block
				       default-cons-area
				       (if list-2 (1+ length) length)))
	     (unroll-block-forms ((1- length) 4)
	       (%block-write 1 (prog1 (pop list-1) (prepare-for-block-write))))
	     (let ((elt (car list-1)))
	       (prepare-for-block-write)
	       (cond (list-2
		       (%set-cdr-code-normal (locf elt))
		       (%block-write 1 elt)
		       (%set-cdr-code-nil (locf list-2))
		       (%block-write 1 list-2))
		     (t (%set-cdr-code-nil (locf elt))
			(%block-write 1 elt)))))))))

(defun union (&rest lists &aux result (tail (locf result)))
  (declare lt:(side-effects reader))
  (do ((list lists (cdr list))) ((null list))
    (do ((elem (car list) (cdr elem))) ((null elem))
      (cond ((not (memq (car elem) result))
	     (rplacd tail (ncons (car elem)))
	     (setq tail (cdr tail))))))
  result)

;; Destructive version of UNION.  No argument is safe.
(defun nunion (&rest lists &aux result (tail (locf result)) next)
  (do ((list lists (cdr list))) ((null list))
    (do ((elem (car list) next)) ((null elem))
      (setq next (cdr elem))
      (cond ((not (memq (car elem) result))
	     (rplacd tail elem)
	     (rplacd elem nil)
	     (setq tail (cdr tail))))))
  result)

(defun intersection (&rest lists &aux result (tail (locf result)))
  (declare lt:(side-effects reader))
  (do ((list (car lists) (cdr list))) ((null list))
    (do ((rest (cdr lists) (cdr rest)))
	((null rest)
	 (rplacd tail (ncons (car list)))
	 (setq tail (cdr tail)))
      (or (memq (car list) (car rest))
	  (return nil))))
  result)

;; Destructive version of INTERSECTION.  Only the first argument is bashed.
(defun nintersection (&rest lists)
  (prog* ((first (car lists))
	  (loc (locf first))
	  (f first))
      l  (or f (return first))
	 (do ((list (cdr lists) (cdr list)))
	     ((null list)
	      (setq loc (cdr loc)))
	   (or (memq (car f) (car list))
	       (return (rplacd loc (cdr f)))))
	 (setq f (cdr f))
	 (go l)))

(defun nconc (&rest arg)
	(cond ((null arg) nil)
	      ((null (cdr arg)) (car arg))
	      (t (*nconc1 arg))))

(defun *nconc1 (arg)
	(cond ((null (cddr arg))
		(*nconc (car arg) (cadr arg))) 
	      (t (*nconc (car arg) (*nconc1 (cdr arg))))))

(defun assoc (item in-list)
  (declare lt:(side-effects reader reducible))
  (if (symbolp item)
      ;; this could also be done for FIXNUMs, SINGLE-FLOATs, and (non-extended) CHARACTERs
      ;; but maybe the type-checking overhead is too expensive
      (assq item in-list)			;Turbo assist from microcode
      (do () (nil)
	(cond ((null in-list) (return nil))
	      ((equal item (caar in-list)) (return (car in-list))))
	(setq in-list (cdr in-list)))))

(defun sassoc (item in-list else)
	(declare (sys:downward-funarg else))
	(or (assoc item in-list)
	    (apply else nil)))

(defun sassq (item in-list else)
	(declare (sys:downward-funarg else))
	(or (assq item in-list)
	    (apply else nil)))

(defun ass (pred item list)
  (declare (sys:downward-funarg pred))
  (do l list (cdr l) (null l)
    (and (funcall pred item (caar l))
	 (return (car l)))))

#+IMACH
(defun assq (item list)
  (if (not (compiler:type-member item dtp-double-float dtp-bignum dtp-big-ratio
				      dtp-complex dtp-spare-number))
      (cl:assoc item list)
      ;; ZL:ASSQ is different from CL:ASSOC because EQ is different from EQL
      ;; This way of writing it generates the best code: 6 instructions in the loop
      (tagbody
	loop (compiler:%error-when (null list)
	       (return-from assq nil))
	     (let ((pair (pop list)))
	       (unless (eq (car pair) item)
		 (go loop))
	       (return-from assq pair)))))

(defun rassoc (item in-list) 
  (declare lt:(side-effects reader reducible))
  (do l in-list (cdr l) (null l) 
    (and (equal item (cdar l)) 
	 (return (car l)))))

(defun rassq (item in-list) 
  (declare lt:(side-effects reader reducible))
  (do l in-list (cdr l) (null l) 
    (and (eq item (cdar l)) 
	 (return (car l)))))

(defun rass (pred item in-list) 
  (declare (sys:downward-funarg pred))
  (do l in-list (cdr l) (null l) 
    (and (funcall pred item (cdar l))
	 (return (car l)))))

;Like ASSQ, but doesnt complain if list element is not a cons.  Just ignores those.
(defun assq-careful (key lst)
  (declare lt:(side-effects reader reducible))
  (prog nil 
    l	(cond ((atom lst) (return nil))
              ((atom (car lst)))
              ((eq key (caar lst))
               (return (car lst))))
    	(setq lst (cdr lst))
        (go l)))

(defun assoc-careful (key lst)
  (declare lt:(side-effects reader reducible))
  (prog nil 
    l	(cond ((atom lst) (return nil))
              ((atom (car lst)))
              ((equal key (caar lst))
               (return (car lst))))
    	(setq lst (cdr lst))
        (go l)))

;LDIFF as in Interlisp:  applied to (A B C D E) and (D E), it returns (A B C).
(defun ldiff (list sublist)
  (declare lt:(side-effects reader))
  (let* ((result nil)
	 (tail (locf result)))
    (do ((l list (cdr l)))
	((or (null l) (eq l sublist)) result)
      (setf (cdr tail)
	    (setq tail (ncons (car l)))))))

;FIRSTN of a number and a list returns the first that many elements of the list.
;If the list isn't that long, it is extended with NILs.  Like Take in APL.
(defun firstn (n list)
  (declare lt:(side-effects reader))
  (let ((new-list (make-list n)))
    (do ((list list (cdr list))
	 (new-list new-list (cdr new-list)))
	((or (null list) (null new-list)))
      (rplaca new-list (car list)))
    new-list))

(defun member (item in-list)
  (declare lt:(side-effects reducible))
  (if #+3600 (symbolp item)
      #+IMACH (or (symbolp item) (fixnump item))
      (#+3600 memq #+IMACH cl:member item in-list)	;Turbo assist from microcode
      (do () (nil)
	(cond ((null in-list) (return nil))
	      ((equal item (car in-list)) (return in-list)))
	(setq in-list (cdr in-list)))))

(defun mem (pred item list)
  (declare (sys:downward-funarg pred))
  (do l list (cdr l) (null l)
    (and (funcall pred item (car l))
	 (return l))))

#+IMACH
(defun memq (item in-list)
  (declare lt:(side-effects reducible))
  (if (not (compiler:type-member item dtp-double-float dtp-bignum dtp-big-ratio
				      dtp-complex dtp-spare-number))
      (cl:member item in-list)
      ;; ZL:MEMQ and CL:MEMBER don't do the same thing, because EQ and EQL don't
      ;; This way of writing it generates the best code: 5 instructions in the loop
      (tagbody
	loop (compiler:%error-when (null in-list)
	       (return-from memq nil))
	     (let ((sublist-before in-list))
	       (unless (eq (pop in-list) item)
		 (go loop))
	       (return-from memq sublist-before)))))

;(MEMASS PRED ITEM LIST) = (MEM PRED (ASS PRED ITEM LIST) LIST) but twice as fast.
(defun memass (pred item list)
  (declare (sys:downward-funarg pred))
  (do l list (cdr l) (null l)
    (and (funcall pred item (caar l))
	 (return l))))

(defun memassq (item list)
  (declare lt:(side-effects reader reducible))
  (do l list (cdr l) (null l)
    (and (eq item (caar l)) (return l))))

(defun circular-list (&rest args)
  (declare lt:(side-effects reader))
  (and args
       (let ((list (copylist* args)))
	 (rplacd (last list) list)
	 list)))

;;; simple mapping functions

#| Old macro definitions -- look at these when thinking about compiler optimizers |
(defmacro-displace every (list pred &optional (step ''cdr))
  (once-only (pred)
    (let ((gensym (gensym)))
      `(do ((,gensym ,list (funcall ,step ,gensym)))
	   ((null ,gensym) t)
	 (or (funcall ,pred (car ,gensym)) (return nil))))))

(defmacro-displace some (list pred &optional (step ''cdr))
  (once-only (pred)
    (let ((gensym (gensym)))
      `(do ((,gensym ,list (funcall ,step ,gensym)))
	   ((null ,gensym) nil)
	 (and (funcall ,pred (car ,gensym)) (return ,gensym))))))
||#

(defun every (list pred &optional (step #'cdr))
  (declare (downward-funarg pred step))
  (do ((list list (funcall step list)))
      ((null list) t)
    (when (not (funcall pred (car list)))
      (return nil))))

(defun some (list pred &optional (step #'cdr))
  (declare (downward-funarg pred step))
  (do ((list list (funcall step list)))
      ((null list) nil)
    (when (funcall pred (car list))
      (return list))))


;; These are not generated by the compiler any more, but are here for old compiler code.
;; The compiler knows how to turn the general mapping functions into
;; these more efficient versions
(defmacro define-fast-mapping-function (name in-or-on collector return-first-list n-fcns)
  `(progn 'compile
     ,@(loop for j upfrom 1 below (1+ n-fcns)
	     as mapper = (intern (string-append "%" (string name) "-" (format nil "~D" j)))
	     as arglist = `(fcn ,@(loop for i below j
					collect (intern
						  (string-append "LIST"
								 (format nil "~D" i)))))
	     as lists = (loop for i below j
			      collect (intern (string-append "L" (format nil "~D" i))))
	     collect `(defun ,mapper ,arglist
			(declare (sys:function-parent ,name 'define-fast-mapping-function)
				 (sys:downward-funarg fcn))
			(loop with f = fcn
				,@(loop repeat j
					for list in (cdr arglist)
					for l in lists
					nconc `(for ,l ,in-or-on ,list))
				,collector (funcall f ,@lists)
				,@(when return-first-list `(finally (return list0))))))))

;; If you change any of these, look at LLC:MAPPING-FUNCTION-KNOWN-NARGS
(define-fast-mapping-function mapc    in do      t   3)
(define-fast-mapping-function map     on do      t   3)
(define-fast-mapping-function mapcar  in collect nil 3)
(define-fast-mapping-function maplist on collect nil 3)
(define-fast-mapping-function mapcan  in nconc   nil 3)
(define-fast-mapping-function mapcon  on nconc   nil 3)


;; Return a list of all elements of LIST for which PRED is true.
;; If extra args are supplied, their successive elements are passed
;; to PRED along with elements of LIST.  Unlike MAP, etc., we process
;; every element of LIST even if extra args are exhausted by cdr'ing.
(defun subset (pred list &rest extra-lists)
  (declare (sys:downward-funarg pred))
  (let* ((lp)
	 (value)
	 (p (locf value))			;Accumulate LIST in P, VALUE
	 (n-args (1+ (length extra-lists))))
    (do () ((null list) value)
      (setq lp extra-lists)
      (%start-function-call pred t n-args nil)
      (%push (car list))			;push next element of LIST.
      
      (do () ((null lp))			;LP scans down the extra lists.
	(%push (caar lp))			;Push car of each one.
	(pop (car lp))				;cdr this list.
	(pop lp))				;advance to next list.
      ;;If value non-nil, put this one in the value.
      (when (%finish-function-call pred t n-args nil)
	(rplacd p (setq p (ncons (car list)))))
      
      (pop list))))

;; Like SUBSET but negates the predicate.
(defun subset-not (pred list &rest extra-lists)
  (declare (sys:downward-funarg pred))
  (let* ((lp)
	 (value)
	 (p (locf value))			;Accumulate LIST in P, VALUE
	 (n-args (1+ (length extra-lists))))
    (do () ((null list) value)
      (setq lp extra-lists)
      (%start-function-call pred t n-args nil)
      (%push (car list))			;push next element of LIST.
      
      (do () ((null lp))			;LP scans down the extra lists.
	(%push (caar lp))			;Push car of each one.
	(pop (car lp))				;cdr this list.
	(pop lp))				;advance to next list.
      
      ;;If value nil, put this one in the value.
      (unless (%finish-function-call pred t n-args nil)
	(rplacd p (setq p (ncons (car list)))))
      
      (pop list))))


(defun tailp (tail list)
  (declare lt:(side-effects reader reducible))
  (do () ((eq tail list) t)
    (if (atom list)
	(return nil)
	(setf list (cdr list)))))

;MEM and ASS are special cases of this, which is to TAILP as MEM is to MEMQ.
(defun pred-tailp (pred tail list)
  (declare (sys:downward-funarg pred))
  (do () ((funcall pred tail list) t)
    (if (atom list)
	(return nil)
	(setf list (cdr list)))))

(defun find-position-in-list-equal (item list)
  (declare lt:(side-effects reader reducible))
  (do ((c 0 (1+ c)))
      ((endp list))
    (when (equal item (pop list)) (return c))))

(defun nleft (n l &optional tail)
  (declare lt:(side-effects reader))
  (do ((l1 l (cdr l1))
       (l2 (nthcdr n l) (cdr l2)))
      ((eq l2 tail) l1)
    (and (null l2) (return nil))))

;Returns a list of all of the elements of LIST, up to and not including
;the first one for which (FUNCALL PRED X <tail of list>) is true.
;If PRED is EQ, this performs LDIFF.
(defun pred-butlast (pred tail list)
  (declare (sys:downward-funarg pred))
  (cond ((funcall pred tail list) nil)
	(t (cons (car list) (pred-butlast pred tail (cdr list))))))

(defun nreverse (l)
  (nreconc l nil))

;; *** Warning:  The RPLACD in this function can trap from microcode to RPLACD-ESCAPE,
;; *** which handles this function specially, by calling %NREVERSE-PRESERVE-CDR-CODE.
;; *** Thus in most cases this function doesn't rplacd forward.
;; *** DO NOT EDIT THIS FUNCTION UNTIL YOU UNDERSTAND RPLACD-ESCAPE!
(defun nreconc (l tail)
  (prog ()
	(when (atom l) (go end))
     l  (setq l (prog1 (cdr l)
		       (setq tail (rplacd l tail))))
	(unless (atom l)
	  (go l))
     end
	(return tail)))

;; This doesn't return the same result as NREVERSE if the last cons is dotted.
(defun %nreverse-preserve-cdr-code (list)
  (declare (values list last))
  (let ((length (length list)))
    (with-stack-array (array length)
      (declare (array-register array))
      (do ((l list (cdr l))
	   (i 0 (1+ i)))
	  ((atom l))
	(setf (aref array i) (car l)))
      (do ((l list (cdr l))
	   (last list l)
	   (i (1- length) (1- i)))
	  ((atom l) (values list last))
	(setf (car l) (aref array i))))))

(defun delq (item list &optional (ntimes -1))
  ;; Remove any occurrences of ITEM from the front of LIST
  (loop doing
    (cond ((or (zerop ntimes) (atom list))
	   (return-from delq list))
	  ((eq item (car list))
	   (setq list (cdr list))
	   (setq ntimes (1- ntimes)))
	  (t (return))))
  ;; Remove interior occurrences of ITEM
  (prog1 list
	 (let ((previous list))
	   (setq list (cdr list))
	   (loop until (atom list) do
	     (cond ((eq item (car list))
		    (cond ((= (%p-cdr-code previous) cdr-next)
			   ;; Splice ITEM out of list without consing and without
			   ;; delocalizing the list
			   (%p-store-cdr-and-contents list (setq list (cdr list)) cdr-nil)
			   (%p-store-cdr-code previous cdr-normal))
			  (t (rplacd previous (setq list (cdr list)))))
		    (setq ntimes (1- ntimes))
		    (when (zerop ntimes) (return)))
		   (t (setq previous list
			    list (cdr list))))))))

(defun delete (item list &optional (ntimes -1))
  ;; Remove any occurrences of ITEM from the front of LIST
  (loop doing
    (cond ((or (zerop ntimes) (atom list))
	   (return-from delete list))
	  ((equal item (car list))
	   (setq list (cdr list))
	   (setq ntimes (1- ntimes)))
	  (t (return))))
  ;; Remove interior occurrences of ITEM
  (prog1 list
	 (let ((previous list))
	   (setq list (cdr list))
	   (loop until (atom list) do
	     (cond ((equal item (car list))
		    (cond ((= (%p-cdr-code previous) cdr-next)
			   ;; Splice ITEM out of list without consing and without
			   ;; delocalizing the list
			   (%p-store-cdr-and-contents list (setq list (cdr list)) cdr-nil)
			   (%p-store-cdr-code previous cdr-normal))
			  (t (rplacd previous (setq list (cdr list)))))
		    (setq ntimes (1- ntimes))
		    (when (zerop ntimes) (return)))
		   (t (setq previous list
			    list (cdr list))))))))

(defun del (pred item list &optional (ntimes -1))
  (declare (sys:downward-funarg pred))
  ;; Remove any occurrences of ITEM from the front of LIST
  (loop doing
    (cond ((or (zerop ntimes) (atom list))
	   (return-from del list))
	  ((funcall pred item (car list))
	   (setq list (cdr list))
	   (setq ntimes (1- ntimes)))
	  (t (return))))
  ;; Remove interior occurrences of ITEM
  (prog1 list
	 (let ((previous list))
	   (setq list (cdr list))
	   (loop until (atom list) do
	     (cond ((funcall pred item (car list))
		    (cond ((= (%p-cdr-code previous) cdr-next)
			   ;; Splice ITEM out of list without consing and without
			   ;; delocalizing the list
			   (%p-store-cdr-and-contents list (setq list (cdr list)) cdr-nil)
			   (%p-store-cdr-code previous cdr-normal))
			  (t (rplacd previous (setq list (cdr list)))))
		    (setq ntimes (1- ntimes))
		    (when (zerop ntimes) (return)))
		   (t (setq previous list
			    list (cdr list))))))))

;This copies only as much as it needs to in order to avoid bashing the original list
(defun remove (item list &optional (times cl:most-positive-fixnum))
  (declare lt:(side-effects reader reducible))
  (if (plusp times)
      (loop with head = (locf list)
	    as tail = (loop for l on (cdr head)		;(MEMBER ITEM (CDR HEAD)) faster
			    when (equal (car l) item) return l)
	    until (null tail)
	    do (loop until (eq (cdr head) tail)
		     do (rplacd head (setq head (cons (cadr head) (cddr head)))))
	       (rplacd head (cdr tail))
	    until (zerop (setq times (1- times)))))
  list)

;This copies only as much as it needs to in order to avoid bashing the original list
(defun remq (item list &optional (times cl:most-positive-fixnum))
  (declare lt:(side-effects reader reducible))
  (if (plusp times)
      (loop with head = (locf list)
	    as tail = (memq item (cdr head))
	    until (null tail)
	    do (loop until (eq (cdr head) tail)
		     do (rplacd head (setq head (cons (cadr head) (cddr head)))))
	       (rplacd head (cdr tail))
	    until (zerop (setq times (1- times)))))
  list)

;This copies only as much as it needs to in order to avoid bashing the original list
(defun rem (pred item list &optional (times cl:most-positive-fixnum))
  (declare (sys:downward-funarg pred))
  (if (plusp times)
      (loop with head = (locf list)
	    as tail = (loop for l on (cdr head)
			    when (funcall pred item (car l)) return l)
	    until (null tail)
	    do (loop until (eq (cdr head) tail)
		     do (rplacd head (setq head (cons (cadr head) (cddr head)))))
	       (rplacd head (cdr tail))
	    until (zerop (setq times (1- times)))))
  list)

(compiler:define-synonym-function rem-if-not subset)
(compiler:define-synonym-function rem-if subset-not)

(defun eliminate-duplicates (l &optional (predicate #'eq) &aux (marker '(duplicate)))
  "Destructively takes out any duplicate elements in the list.
   Leaves the first instance where it is and removes following instances."
  (declare (sys:downward-funarg predicate))
  (unwind-protect
    (do ((l1 l (cdr l1)))
	((null l1))
      (let ((car1 (car l1)))
	(unless (eq car1 marker)
	  (do ((l2 (cdr l1) (cdr l2)))
	      ((null l2))
	    (let ((car2 (car l2)))
	      (cond ((eq car2 marker))		;leave it alone, don't feed to PREDICATE
		    ((funcall predicate car1 car2)
		     (rplaca l2 marker))))))))
    (setq l (delq marker l)))
  l)

(defun nsubst (new old s-exp &aux tem)
    (cond ((eq old s-exp) new)
	  ((atom s-exp) s-exp)
	  (t (do ((s s-exp (cdr s))
		  (prev nil s))
		 ((atom s)
		  (setq tem (nsubst new old s))
		  (or (eq tem s) (rplacd prev tem)))
	       (rplaca s (nsubst new old (car s))))
	     s-exp)))

(defun subst (new old s-exp &aux tem)
  (declare lt:(side-effects reader))
    (cond ((equal old s-exp) new)
	  ((atom s-exp) s-exp)
	  (t (setq s-exp (copylist s-exp))
	     (do ((s s-exp (cdr s))
		  (prev nil s))
		 ((atom s)
		  (setq tem (subst new old s))
		  (or (eq tem s) (rplacd prev tem)))
	       (rplaca s (subst new old (car s))))
	     s-exp)))

(defun sublis (alist form &aux car cdr)
  (declare lt:(side-effects reader))
    (cond ((symbolp form)
	   (cond ((setq car (assq form alist))
		  (cdr car))
		 (t form)))
	  ((listp form)
	   (setq car (sublis alist (car form))
		 cdr (sublis alist (cdr form)))
	   (cond ((and (eq (car form) car)
		       (eq (cdr form) cdr))
		  form)
		 (t (cons car cdr))))
	  (t form)))

(defun nsublis (alist form &aux tem)
    (cond ((symbolp form)
	   (cond ((setq tem (assq form alist))
		  (cdr tem))
		 (t form)))
	  ((listp form)
	   (rplaca form (nsublis alist (car form)))
	   (setq tem (nsublis alist (cdr form)))
	   (or (eq (cdr form) tem)
	       (rplacd form tem))
	   form)
	  (t form)))

(defun pairlis (vars vals &aux alst)
  (declare lt:(side-effects reader))
       (setq alst (make-list (length vars)))
       (do ((vars vars (cdr vars))
            (vals vals (cdr vals))
            (tem alst (cdr tem)))
           ((null vars) alst)
           (rplaca tem (cons (car vars) (car vals)))))

(defun del-if-not (pred list)
	(declare (sys:downward-funarg pred))
	(prog (lst olst)
        a    (cond ((atom list) (return list))
                   ((funcall pred (car list)))
                   (t
                    (setq list (cdr list))
                    (go a)))
             (setq olst (setq lst list))
        b    (setq lst (cdr lst))
             (cond ((atom lst) (return list))
                   ((funcall pred (car lst))
                    (setq olst lst))
                   (t
                    (rplacd olst (cdr lst))))
             (go b)))

(defun del-if (pred list)
       (declare (sys:downward-funarg pred))
       (prog (lst olst)
        a    (cond ((atom list) (return list))
                   ((funcall pred (car list))
                    (setq list (cdr list))
                    (go a)))
             (setq olst (setq lst list))
        b    (setq lst (cdr lst))
             (cond ((atom lst) (return list))
                   ((funcall pred (car lst))
                    (rplacd olst (cdr lst)))
                   (t
                    (setq olst lst)))
             (go b)))

(defsubst ignore (&rest ignore)
  (declare lt:(side-effects simple reducible))
  (declare (compiler:do-not-record-macroexpansions))
  nil)

;; These exist to make microcode escapes faster than calling IGNORE.
#+3600
(defun return-nil-one-arg (arg1)
  (declare (ignore arg1))
  nil)

#+3600
(defun return-nil-two-args (arg1 arg2)
  (declare (ignore arg1 arg2))
  nil)

(defun locate-in-closure (closure ptr)
  (cl:etypecase closure
    (lexical-closure
      (let ((env (lexical-closure-environment closure))
	    (fcn (lexical-closure-function closure)))
	(if (typep fcn :compiled-function)
	    (let ((map (assq ptr
			     (rest1 (or (assq :lexical-map
					      (compiled-function-debugging-info
						fcn))
					(ferror "Function does not have a lexical map."))))))
	      (if map
		  (let ((descriptor (second map)))
		    (loop repeat (1- (lexical-map-variable-generation descriptor))
			  do (setq env (%p-contents-offset env 0)))
		    (locf (%p-contents-offset env (lexical-map-variable-location descriptor))))
		  (value-cell-location ptr)))
	    (eval `(variable-location ,ptr) env))))
    (dynamic-closure
     (check-arg ptr (cond ((symbolp ptr) (setq ptr (value-cell-location ptr)))
			  ((= (%data-type ptr) dtp-locative)))
		"a symbol or a locative")
     (do ((l (cdr (%make-pointer dtp-list closure)) (cddr l)))
	 ((null l)
	  ptr)
       (and (eq (car l) ptr)
	    (return (cadr l)))))))

(defsubst symeval-in-closure (closure ptr)
  (declare lt:(side-effects reader))
  (location-contents (locate-in-closure closure ptr)))

(defun set-in-closure (closure ptr val)
  (cl:setf (symeval-in-closure closure ptr) val))

(defun boundp-in-closure (closure ptr)
  (declare lt:(side-effects reader))
  (variable-boundp (symeval-in-closure closure ptr)))

(defun makunbound-in-closure (closure ptr)
  (variable-makunbound (symeval-in-closure closure ptr) ptr))

(defun closure-function (closure)
  (declare lt:(side-effects reader))
  (argument-typecase closure
    (:lexical-closure
      (lexical-closure-function closure))
    ((:closure)
     (car (%make-pointer dtp-list closure)))))

(defun closure-variables (closure)
  (declare lt:(side-effects reader))
  (check-arg-type closure :closure)
  (loop for l on (cdr (%make-pointer dtp-list closure)) by 'cddr
	collect (%make-pointer-offset dtp-symbol (car l) -1)))

;; This function is pretty random, and doesn't work with unbound closure variables.
(defun closure-alist (closure)
  (declare lt:(side-effects reader))
  (check-arg-type closure :closure)
  (loop for l on (cdr (%make-pointer dtp-list closure)) by 'cddr
	collect (cons (%make-pointer-offset dtp-symbol (car l) -1) (caadr l))))

(defun copy-closure (closure)
  (check-arg-type closure :closure)
  (let* ((closure1 (%make-pointer dtp-list closure))
	 (ans (make-list (length closure1))))
    (rplaca ans (car closure1))			;Close over same fctn
    (do ((l (cdr closure1) (cddr l))
	 (n (cdr ans) (cddr n)))
	((null l) (%make-pointer (%data-type closure) ans))
      (rplaca n (car l))			;Same internal value cell
      (let ((new-exvc (%make-pointer dtp-locative (make-list 1))))
	(%p-copy-q (cadr l) new-exvc)
	(rplaca (cdr n) new-exvc)))))

(defun find-position-in-bindings (ptr bindings &aux (pos 0))
  (setq ptr (follow-cell-forwarding ptr nil))
  (dolist (b bindings)
    (cond ((numberp b)
	   (incf pos b))
	  ((eq (follow-cell-forwarding b nil) ptr)
	   (return pos))
	  (t (incf pos)))))

;;;; Number functions.

(compiler:define-synonym-function plus +)
(compiler:define-synonym-function +$ +)

(defun difference (number &rest more-numbers)
  (declare lt:(side-effects simple reducible))
  (loop while more-numbers
	do (decf number (pop more-numbers)))
  number)

(compiler:define-synonym-function -$ -)

(compiler:define-synonym-function times *)
(compiler:define-synonym-function *$ *)

(defun quotient (number &rest more-numbers)
  (declare lt:(side-effects simple reducible))
  (do ((numbers more-numbers (cdr numbers))
       (ans number))
      ((null numbers) ans)
    (setq ans (// ans (car numbers)))))

(defun // (number &rest more-numbers)
  (declare lt:(side-effects simple reducible))
  (cond ((null more-numbers) (// 1 number))
	((do ((numbers more-numbers (cdr numbers))
	      (ans number))
	     ((null numbers) ans)
	   (setq ans (// ans (car numbers)))))))

(compiler:define-synonym-function //$ //)
 
(defun \\ (integer1 integer2 &rest more-integers)
  (declare lt:(side-effects simple reducible))
  (loop with answer = (\\ integer1 integer2)
	for z in more-integers
	do (setq answer (\\ answer z))
	finally (return answer)))

(compiler:define-synonym-function gcd \\)

(defun logand (integer &rest more-integers)
  (declare lt:(side-effects simple reducible))
  (do ((ans integer (logand ans (car l)))
       (l more-integers (cdr l)))
      ((null l) ans)))

(defun logior (integer &rest more-integers)
  (declare lt:(side-effects simple reducible))
  (do ((ans integer (logior ans (car l)))
       (l more-integers (cdr l)))
      ((null l) ans)))

(defun logxor (integer &rest more-integers)
  (declare lt:(side-effects simple reducible))
  (do ((ans integer (logxor ans (car l)))
       (l more-integers (cdr l)))
      ((null l) ans)))

(defsubst lognot (integer)
  (declare lt:(side-effects simple reducible))
  (logxor integer -1))

(compiler:define-synonym-function add1 1+)
(compiler:define-synonym-function sub1 1-)
(compiler:define-synonym-function 1+$ 1+)
(compiler:define-synonym-function 1-$ 1-)
(compiler:define-synonym-function remainder \)
(compiler:define-synonym-function ^$ ^)
(compiler:define-synonym-function expt ^)
(compiler:define-synonym-function null not)

(defun fixr (number)
  (declare lt:(side-effects simple reducible))
  (if (fixp number) number (fix (+ number 0.5s0))))

(defun boole (op integer1 &rest more-integers)
  (declare lt:(side-effects simple reducible))
  (do ((ans integer1 (boole-internal op ans (car l)))
       (l more-integers (cdr l)))
      ((null l) ans)))

(defun haipart (x n &aux tem)
  (declare lt:(side-effects simple reducible))
  ;; Get number of significant bits
  (setq tem (haulong (setq x (abs x))))
  (cond ;; Positive N means get high N bits, or as many as there are
	((> n 0) (setq tem (- n tem))	;minus number of low bits to discard
		 (cond ((< tem 0) (ash x tem))
		       (t x)))
	;; Zero N means return no bits
	((= n 0) 0)
	;; Negative N means get low -N bits, or as many as there are
	((< (setq n (minus n)) tem)
	 (\ x (ash 1 n)))
	(t x)))

;These are for reading in QCOM, and the like
(defun assign-alternate (x)
   (prog nil 
    l	(cond ((null x)(return nil)))
	(set (car x) (cadr x))
	(setq x (cddr x))
	(go l)))

(defun get-alternate (x)
   (prog (y)
    l	(cond ((null x)(return (reverse y))))
	(setq y (cons (car x) y))
	(setq x (cddr x))
	(go l)))

(defun assign-values (input-list &optional (shift 0) (init 0) (delta 1))
   (prog ()
lp	(cond ((null input-list)(return init)))
	(set (car input-list) (lsh init shift))
	(setq input-list (cdr input-list))
	(setq init (+ init delta))
	(go lp)))

(defun assign-values-init-delta (input-list shift init delta)
    (prog nil 
lp	(cond ((null input-list) (return init)))
	(set (car input-list) (lsh init shift))
	(setq input-list (cdr input-list))
	(setq init (+ init delta))
	(go lp)))

;;; These are like things in the [X]CONS files, but machine independent
;;; Array functions.

(defun aref (array &rest subscripts)
  (declare lt:(side-effects reader))
  (%lexpr-aref array subscripts))

(defun aset (element array &rest subscripts)
  (%lexpr-aset element array subscripts))

(defun aloc (array &rest subscripts)
  (declare lt:(side-effects reader))
  (%lexpr-aloc array subscripts))

;;; Lisp implementation of the C octet array accessors.
;;;
;;; On the newer models of L machines, these are in microcode, but trap
;;; here on old models.
;;;
;;; This particular implementation is designed to be fast at the expense of meaningful
;;; error messages.

(defmacro octet-aref-index (octet-index shift)
  `(compiler:inverted-ldb ,octet-index (byte ,(+ shift 30.) 2)))

(defun compiler:inverted-ldb (value byte-spec)
  (declare lt:(side-effects simple reducible))
  (sys:%logldb (byte (byte-size byte-spec) 0) (rot value (- (byte-position byte-spec)))))

;;;

#+IMACH (cl:proclaim '(cl:inline sys:octet-aref))
(defun sys:octet-aref (array octet-index)
  #+3600 (declare (sys:safeguarded-function))
  (aref array (octet-aref-index octet-index 2)))

(defun sys:octet-aref-16 (array octet-index)
  #+3600 (declare (sys:safeguarded-function))
  (let ((element (aref array (octet-aref-index octet-index 1))))
    (if (ldb-test (byte 1 1) octet-index)
	(sys:%logldb (byte 16. 16.) element)
	(sys:%logldb (byte 16. 0) element))))

(defun sys:octet-aref-8 (array octet-index)
  #+3600 (declare (sys:safeguarded-function))
  (let ((element (aref array (octet-aref-index octet-index 0))))
    (if (not (ldb-test (byte 1 1) octet-index))
	(if (not (ldb-test (byte 1 0) octet-index))
	    (sys:%logldb (byte 8 0) element)
	    (sys:%logldb (byte 8 8) element))
	(if (not (ldb-test (byte 1 0) octet-index))
	    (sys:%logldb (byte 8 16.) element)
	    (sys:%logldb (byte 8 24.) element)))))

#+IMACH (cl:proclaim '(cl:inline sys:octet-aset))
(defun sys:octet-aset (value array octet-index)
  #+3600 (declare (sys:safeguarded-function))
  (setf (aref array (octet-aref-index octet-index 2)) value))

(defun sys:octet-aset-16 (value array octet-index)
  #+3600 (declare (sys:safeguarded-function))
  (let ((element (aref array (octet-aref-index octet-index 1))))
    (compiler:%push value)
    (compiler:%push (if (fixnump element) element 0))
    (setf (aref array (octet-aref-index octet-index 1))
	  (if (not (ldb-test (byte 1 1) octet-index))
	      (sys:%logdpb (sys:%pop) (byte 16. 0) (sys:%pop))
	      (sys:%logdpb (sys:%pop) (byte 16. 16.) (sys:%pop))))
    value))

(defun sys:octet-aset-8 (value array octet-index)
  #+3600 (declare (sys:safeguarded-function))
  (let ((element (aref array (octet-aref-index octet-index 0))))
    (compiler:%push value)
    (compiler:%push (if (fixnump element) element 0))
    (setf (aref array (octet-aref-index octet-index 0))
	  (if (not (ldb-test (byte 1 1) octet-index))
	      (if (not (ldb-test (byte 1 0) octet-index))
		  (sys:%logdpb (compiler:%pop) (byte 8 0) (compiler:%pop))
		  (sys:%logdpb (compiler:%pop) (byte 8 8) (compiler:%pop)))
	      (if (not (ldb-test (byte 1 0) octet-index))
		  (sys:%logdpb (compiler:%pop) (byte 8 16.) (compiler:%pop))
		  (sys:%logdpb (compiler:%pop) (byte 8 24.) (compiler:%pop)))))
    value))

(cl:defsetf si:octet-aref-8 (array octet-index) (value)
  `(si:octet-aset-8 ,value ,array ,octet-index))

(cl:defsetf si:octet-aref-16 (array octet-index) (value)
  `(si:octet-aset-16 ,value ,array ,octet-index))

(cl:defsetf si:octet-aref (array octet-index) (value)
  `(si:octet-aset ,value ,array ,octet-index))

;;; Functions for reading and writing through locatives for Pascal and C.
;;; We can't use LOCATION-CONTENTS because these might be physical pointers.

(defsubst cts-read-location (locative)
  (#+3600 location-contents #+IMACH sys:%memory-read locative))

#+IMACH
(defsubst cts-write-location (locative value)
  (sys:%memory-write (sys:follow-cell-forwarding locative t) value)
  value)

#+IMACH
(cl:defsetf cts-read-location cts-write-location)


(defun arraydims (array &aux type)
  (declare lt:(side-effects reader))
  (and (symbolp array) (setq array (fsymeval array)))
  (check-arg array arrayp "an array")
  (setq type (array-type array))
  (cons type (array-dimensions array)))

(defun array-push-extend (array data &optional extension
			  &aux (inhibit-scheduling-flag t))
    (cond ((array-push array data))
	  (t (adjust-array-size array (+ (array-length array)
					 ;; If amount to extend by not specified,
					 ;; try to guess a reasonable amount
					 (cond (extension
						(max extension 1))
					       ((< (%structure-total-size
						     ;; It might have been moved!
						     (follow-structure-forwarding array))
						   page-size)
						(max (array-length array) 100))
					       (t (// (array-length array) 4)))))
	     (array-push array data))))

;;;Copies a portion of one array to the end of another, updating the fill pointer of
;;; the other to reflect the new stuff.  This is equivalent to N array-push-extend
;;; calls but hopefully faster.  It returns the destination array and a pointer to
;;; the next position to be filled.
(defun array-push-portion-extend (to-array from-array &optional (from-start 0) from-end)
  (declare (values to-array to-array-end))
  (setq from-end (or from-end (array-active-length from-array)))
  (let* ((portion-length (- from-end from-start))
	 (to-array-start (fill-pointer to-array))
	 (to-array-end (+ to-array-start portion-length)))
    (cond ((= portion-length 0) ())		;nothing to copy
	  ((minusp portion-length)
	   (ferror "Attempting to copy ~D elements from ~D to ~D of ~S"
		   portion-length from-start from-end from-array))
	  (t
	   (when (> to-array-end (array-length to-array))	;the array is too small now
	     (setq to-array			;new array, plenty big
		   (adjust-array-size		;cribbed from array-push-extend
		     to-array (+ (array-length to-array)	;this does cdr-codes
				 (cond ((< (%structure-total-size
					     (follow-structure-forwarding to-array))
					   page-size)
					(max portion-length #o100))
				       (t (max (// (array-length to-array) 4)
					       portion-length)))))))
	   (copy-array-portion from-array from-start from-end
			       to-array to-array-start to-array-end)
	   (setf (fill-pointer to-array) to-array-end)	;sanitize
	   (when (= (array-type-field to-array) art-q-list)
	     ;; set last active element to CDR-NIL
	     (%p-store-cdr-code (aloc to-array (1- to-array-end)) cdr-nil)
	     ;; also set intervening elements to CDR-NEXT
	     (loop for cdr-next-index
		       upfrom (max 0 (1- to-array-start))
		       below (1- to-array-end)
		   do (setf (%p-cdr-code (locf (aref to-array cdr-next-index))) cdr-next)))))
    (values to-array to-array-end)))

;ARRAY-POP, eventually to be micro-coded [said someone many, many years ago]
;undoes (ARRAY-PUSH ARRAY <DATA>) and returns <DATA>
;The optional second argument is a value to return if the array is empty.
;If no second argument is supplied, an error is signalled if the array is empty.
(defun array-pop (array &optional (default nil default-supplied))
  (without-interrupts
    (let ((idx (fill-pointer array)))
      (cond ((plusp idx)
	     (prog2 (decf idx)
		    (aref array idx)		;Value to return
		    (setf (fill-pointer array) idx)
		    (let ((array-type (array-type array)))
		      (when (memq array-type '(art-q art-q-list))
			(aset nil array idx))	;Flush so not there for GC
		      (when (and (eq array-type 'art-q-list)
				 (not (zerop idx)))
			(%p-store-cdr-code (aloc array (1- idx)) cdr-nil)))))
	    (default-supplied default)
	    (t (ferror "~S Overpopped" array))))))

(defun list-array-leader (array &optional limit)
  (declare lt:(side-effects reader))
  (if (and (symbolp array)
	   (fboundp array)
	   (arrayp (fsymeval array)))
      (setq array (fsymeval array)))
  (if (null limit)
      (setq limit (or (array-leader-length array) 0)))
  (let ((list (make-list limit)))
    (do ((i 0 (1+ i))
	 (l list (cdr l)))
	((>= i limit)
	 list)
      (rplaca l (array-leader array i)))))

(defun array-in-bounds-p (array &rest point)
  (declare lt:(side-effects reducible))
  (or (= (length point) (array-#-dims array))
      (error 'array-wrong-number-of-subscripts
	     ':function 'array-in-bounds-p ':array array
	     ':subscripts-given point))
  (loop for subscript in point for i upfrom 1
	always (and ( subscript 0)
		    (< subscript (array-dimension-n i array)))))

;;;
(defun fill-array (array size value)
  (let ((real-size (or size (array-length array))))
    (if (< real-size 20.)			;the approx. measured break-even point...
	;; Small arrays can be done in the traditional way.
	(let ((array array))
	  (declare (sys:array-register-1d array))
	  (loop for idx below real-size
		do (sys:%1d-aset value array idx)))
	(fast-fill-array-portion array 0 real-size value)))
  nil)

(defun fill-array-portion (array start end value)
  (if (< (- end start) 20.)			;the approx. measured break-even point...
      ;; Small arrays can be done in the traditional way.
      (let ((array array))
	(declare (sys:array-register-1d array))
	(loop for idx from start below end
	      do (sys:%1d-aset value array idx)))
      (fast-fill-array-portion array start end value))
  nil)

#+3600
(defun fast-fill-array-portion (array start end value)
  ;; Use block-copyage to make larger arrays fill faster.
  (multiple-value-bind (array nil bace bound offset)	;#$%^ BASE specvar
      (sys:setup-force-1d-array-sequential array)
    (when (> end (- bound offset))
      (ferror "Attempt to fill ~d elements of ~s, which is past the end of the array."
	      end array))
    (let* ((type (array-type-field array))
	   (epq (array-elements-per-q type)))
      (if (eql epq 1)
	  (%fast-block-store
	    (%make-pointer-offset (%data-type bace) bace (+ offset start))
	    (- end start)
	    (progn
	      (when (= type art-fat-string)
		(compiler:%error-unless (cl:typep value 'character)
		  (cl:error "Fill value ~s for a string array is not a character" value)))
	      value))
	  (let* ((bpe (array-bits-per-element type))
		 (store-value
		   (loop with sub-value = (selector type =
					    (art-boolean (if value -1 0))
					    (art-string
					      (compiler:%error-when
						(or (not (cl:typep value 'character))
						    (char-fat-p value))
						(cl:error
						  "Fill value ~s is not a thin character"
						  value))
					      (char-subindex value))
					    (otherwise value))
			 repeat epq		;Concatenate bits of numeric value
			 as num = sub-value then (dpb sub-value (byte bpe 0) (lsh num bpe))
			 finally (return num))))
	    (multiple-value-bind (beginning-offset beginning-bits)
		(ceiling (* (+ offset start) bpe) 32.)
	      (multiple-value-bind (ending-offset ending-bits)
		  (floor (* (+ offset end) bpe) 32.)
		(let ((n-words (- ending-offset beginning-offset))
		      (address (%make-pointer-offset (%data-type bace) bace
						     beginning-offset)))
		  (if (minusp n-words)
		      ;; Handle case all within one word.
		      (%p-dpb store-value
			      (byte (- ending-bits (+ 32. beginning-bits))
				    (+ 32. beginning-bits))
			      (%make-pointer-offset dtp-locative address -1))
		      ;; Drop in the initial piece...
		      (unless (zerop beginning-bits)
			(%p-dpb store-value
				(byte (- beginning-bits) (+ beginning-bits 32.))
				(%make-pointer-offset dtp-locative address -1)))
		      (%fast-block-store address n-words store-value)
		      ;; Drop in the trailing portion.
		      (unless (zerop ending-bits)
			(%p-dpb store-value (byte ending-bits 0)
				(%make-pointer-offset dtp-locative address n-words)))))))))))
  nil)

#+IMACH
(defun fast-fill-array-portion (array start end value)
  (when ( end start) (return-from fast-fill-array-portion nil))
  ;; Use block-copyage to make larger arrays fill faster.
  (multiple-value-bind (array control bace bound)	;#$%^ BASE specvar
      (sys:setup-force-1d-array array)
    (when (> end bound)
      (ferror "Attempt to fill ~d elements of ~s, which is past the end of the array."
	      end array))
    (let ((byte-packing (ldb array-register-byte-packing control))
	  (element-type (ldb array-register-element-type control)))
      (if (= byte-packing 0)
	  (%fast-block-store
	    (%pointer-plus bace start) (- end start)
	    (cond ((= element-type array-element-type-character)
		   (compiler:%error-unless (cl:typep value 'character)
		     (cl:error "Fill value ~s for a string array is not a character" value))
		   (%pointer value))
		  (t value)))
	  (let* ((bit-rot (- 5 byte-packing))
		 (store-value
		   (let ((num (selector element-type =
				(array-element-type-boolean (if value -1 0))
				(array-element-type-character
				  (compiler:%error-when (or (not (cl:typep value 'character))
							    (char-fat-p value))
				    (cl:error "Fill value ~s is not a thin character" value))
				  (char-subindex value))
				(otherwise (%logdpb value (byte 32. 0.) 0)))))
		     ;; Build the initial word which will fill the array
		     (tagbody
		       (cl:case byte-packing
			 (1 (go 16-bit))
			 (2 (go 8-bit))
			 (3 (go 4-bit))
			 (4 (go 2-bit)))
		    1-bit
		       (setq num (%logdpb num (byte 1. 1.) num))
		    2-bit
		       (setq num (%logdpb num (byte 2. 2.) num))
		    4-bit
		       (setq num (%logdpb num (byte 4. 4.) num))
		    8-bit
		       (setq num (%logdpb num (byte 8. 8.) num))
		    16-bit
		       (setq num (%logdpb num (byte 16. 16.) num)))
		     num))
		 (offset (ldb array-register-byte-offset control))
		 (start-elt (+ offset start))
		 (start-word-offset (lsh start-elt (- byte-packing)))
		 (start-word-address (%pointer-plus bace start-word-offset))
		 (start-bits (rot (- start-elt (lsh start-word-offset byte-packing)) bit-rot))
		 (end-elt (+ offset end))
		 (end-word-offset (lsh end-elt (- byte-packing)))
		 (end-bits (lsh (- end-elt (lsh end-word-offset byte-packing)) bit-rot))
		 (n-words (- end-word-offset start-word-offset)))
	    (unless (plusp n-words)
	      ;; everything is in the first word
	      (unless (= end-bits start-bits)
		(let ((old-word (%memory-read start-word-address :set-cdr-next nil))
		      (mask (rot (lsh -1 (- end-bits start-bits)) start-bits)))
		  (%memory-write start-word-address
				 (%set-tag (logior (logand old-word mask)
						   (cl:logandc2 store-value mask))
					   (%tag old-word)))))
	      (return-from fast-fill-array-portion nil))
	    (unless (zerop start-bits)
	      ;; Drop in the initial piece...
	      (let ((old-word (%memory-read start-word-address :set-cdr-next nil))
		    (mask (lsh -1 start-bits)))
		(%memory-write start-word-address
			       (%set-tag (logior (cl:logandc2 old-word mask)
						 (logand store-value mask))
					 (%tag old-word))))
	      (setq start-word-address (%pointer-plus start-word-address 1))
	      (decf n-words))
	    (%fast-block-store start-word-address n-words store-value)
	    (unless (zerop end-bits)
	      ;; Drop in the trailing portion.
	      (let* ((end-word-address (%pointer-plus start-word-address n-words))
		     (old-word (%memory-read end-word-address :set-cdr-next nil))
		     (mask (lsh -1 end-bits)))
		(%memory-write end-word-address
			       (%set-tag (logior (logand old-word mask)
						 (cl:logandc2 store-value mask))
					 (%tag old-word)))))))
      nil)))

(defun %fast-block-store (address n-words value)
  ;; Block store the bulk...
  ;; Do this by 64 page chunks when large.  This gives the paging system
  ;; a chance to move things in while we're storing.
  (loop with segsize = (min n-words %address-space-quantum-size)
	initially (when (> n-words (* 2 page-size))
		    (page-in-words address segsize :type :normal :hang-p nil))
	while (plusp n-words)
	for next-n-words = (- n-words segsize)
	for next-address = (%make-pointer-offset (%data-type address) address segsize)
	for next-segsize = (min next-n-words %address-space-quantum-size)
	do (when (plusp next-n-words)
	     ;; Pre-page the next block, don't wait for i/o
	     (page-in-words next-address next-segsize :type :normal :hang-p nil))
	   (%block-store-cdr-and-contents address segsize cdr-next value 0)
	   (setf n-words next-n-words)
	   (setf address next-address)
	   (setf segsize next-segsize)))

;; Like VECTOR-POP, but faster because it omits certain features: checking for an
;; empty vector, nulling out popped entries so the object can be garbage collected,
;; maintaining cdr-codes in ART-Q-LIST arrays, and multiprocess interlocking.
(defun fast-vector-pop (vector)
  (let ((index (1- (fill-pointer vector))))
    (setf (fill-pointer vector) index)
    (aref vector index)))

;; Like VECTOR-POP, but faster because it omits certain features: nulling out popped
;; entries so the object can be garbage collected, maintaining cdr-codes in ART-Q-LIST
;; arrays, and multiprocess interlocking.
(defun fast-vector-pop2 (vector default)
  (let ((index (1- (fill-pointer vector))))
    (compiler:%error-when (minusp index)
      (return-from fast-vector-pop2 default))
    (setf (fill-pointer vector) index)
    (aref vector index)))

;; Like VECTOR-PUSH-EXTEND, but faster because it omits certain features: multiprocess
;; interlocking, maintaining cdr-codes in ART-Q-LIST arrays, and user-specifiable
;; extension amount.  Also this is more tightly coded.
(defun fast-vector-push-extend (new-element vector)
  (multiple-value-bind (array array-register base bound)
      (sys:setup-1d-array vector)
    (declare (unspecial base))
    #+3600 (declare (ignore array base #+3600 array-register))
    (let ((index (fill-pointer vector)))
      (cond ((< index bound)
	     #+3600 (setf (aref vector index) new-element)	;compiler deficiency
	     #+IMACH (sys:fast-aset-1 new-element index
				      (compiler:referencing-variables-progn
					array base bound array-register)))
	    (t
	     (si:adjust-array-size vector
				   (+ bound (if (< (sys:%structure-total-size
						     (sys:follow-structure-forwarding vector))
						   sys:page-size)
						(max bound 100)
						(floor bound 4))))
	     (setf (aref vector index) new-element)))	;array register would be slower here!
      (setf (fill-pointer vector) (1+ index))
      index)))

;;;

(defun named-structure-symbol (named-structure)
  (declare lt:(side-effects reader))
  (let ((sym (if (array-has-leader-p named-structure)
		 (array-leader named-structure 1)
		 (aref named-structure 0))))
    (or (symbolp sym)
	(ferror "~S not a symbol in named-structure-symbol slot of ~S"
		sym named-structure))
    sym))

(defun named-structure-p (structure)
  "If argument is a named-structure, return its name, otherwise NIL"
  (declare #+IMACH (wired-function) lt:(side-effects reader))
  #+3600
  (and (arrayp structure)
       (not (zerop (array-named-structure-bit structure)))
       (named-structure-symbol structure))
  #+IMACH
  (and (arrayp structure)
       (let* ((header (%memory-read structure :cycle-type %memory-header :set-cdr-next nil))
	      (fixnum (%pointer header)))
	 (and (ldb-test array-named-structure-bit fixnum)
	      (if (ldb-test array-leader-length-field fixnum)
		  (array-leader structure 1)
		(aref structure 0))))))

(defun make-array-into-named-structure (array)
  (check-arg-type array :array)
  (setf (array-named-structure-bit array) 1)
  array)

;;; Send a message to a named structure
(defun named-structure-invoke (operation structure &rest args)
  ;; This function used to take its first two arguments in the other order.
  ;; We are comitted to supporting the old argument order indefinitely.
  (if (arrayp operation)
      (psetq operation structure structure operation))
  (check-arg-type operation :symbol)
  (check-arg-type structure :array)
  (lexpr-funcall (get (named-structure-symbol structure) 'named-structure-invoke)
		 operation structure args))


;; Alter the dimensions of an array, using an invisible pointer,
;; preserving all elements whose indices continue to be within range.
;; The leader is also preserved.  Like ADJUST-ARRAY-SIZE, we return the
;; new array, in case you want to make things point directly at it to save indirct cycles.
(defun array-grow (array &rest dimensions
			 &aux (old-dims (array-dimensions array))
			 index new-array)
  (setq array (follow-structure-forwarding array))
    (prog ()
        (check-arg array arrayp "an array")
	;; Extend or truncate the supplied list of dimensions.
	;; Omitted dimensions are left unchanged.
	(and (< (length dimensions) (length old-dims))
	     (setq dimensions (append dimensions (nthcdr (length dimensions) old-dims))))
	(and (> (length dimensions) (length old-dims))
	     (setq dimensions (firstn (length old-dims) dimensions)))
	;; If it's 1-dimensional, might as well try to grow it in place.
	(and (null (cdr dimensions))
	     (return (adjust-array-size array (car dimensions))))
	;; Make the new array.
	(setq new-array (make-array dimensions
				    ':area (%area-number array)
				    ':type (array-type array)
				    ':leader-length (array-leader-length array)))
	;; Copy the array leader.
        (do ((i 0 (1+ i))
             (n (or (array-leader-length array) 0) (1- n)))
            ((zerop n))
	  (setf (array-leader new-array i) (array-leader array i)))

	;; Check for zero-size array, which the code below doesn't handle correctly
	(and (do ((l dimensions (cdr l)) (l1 old-dims (cdr l1))) ((null l) nil)
	       (and (or (zerop (car l)) (zerop (car l1)))
		    (return t)))
	     (go done))

	;; Create a vector of fixnums to use as subscripts to step thru the arrays.
	(setq index nil)
	(do ((l dimensions (cdr l))) ((null l))
	   (setq index (cons 0 index)))

        ;; Make the first increment of INDEX bring us to element 0 0 0 0..
        (rplaca index -1)

	;; This works in row-major and column-major
	loop
	
	;; Increment the vector of subscripts INDEX.
        ;; Go to DONE if we have exhausted all elements that need copying.
	(do ((i index (cdr i))
	     (o old-dims (cdr o))
	     (n dimensions (cdr n)))
	    ((null i) (go done))
	   ;; Increment one index
	   (rplaca i (1+ (car i)))
	   ;; and decide whether to "carry" to the next one.
	   (cond ((or (>= (car i) (car o)) (>= (car i) (car n)))
		  (rplaca i 0))
		 (t (return nil))))

	(%lexpr-aset (%lexpr-aref array index) new-array index)
	(go loop)

	done

	;; The contents have been copied.  Copy a few random things.
	(setf (array-named-structure-bit new-array) (array-named-structure-bit array))
	#+IMACH
	(unless (zerop (array-long-prefix-bit new-array))
	  (setf (array-discontiguous-bit new-array) (array-discontiguous-bit array)))
	#+3600(setf (array-discontiguous-bit new-array) (array-discontiguous-bit array))
	(structure-forward array new-array)
	(return new-array)))

;; Set all free pointers of an area to 0, deleting its entire contents
;; If you free the regions, you better be damn sure that *nothing* points to them.
(defun reset-temporary-area (area &optional free-regions)
  (or (plusp (%logldb %%region-temporary (area-region-bits area)))
      (fsignal "The area given to RESET-TEMPORARY-AREA, ~S, is not a temporary area."
	       (area-name area)))
  (reset-area area free-regions))

;; This resets an area, whether the area is declared temporary or not.  This normally
;; should NOT be used; unfortunately, CHAOS and PACK4 still need to use it.  Any
;; new programs should use RESET-TEMPORARY-AREA and pre-declare the area as temporary.
(defun reset-area (area &optional free-regions)
  (without-interrupts-and-stack-overflows (200.)
    (do-area-regions (region area)
      (gc-reset-free-pointer region 0 t)
      (cond (free-regions
	     (setf (area-region-list area) (region-list-thread region))
	     (%free-region region))))))

;;; Support for the INHIBIT-GC-FLIPS macro

;;; The PROCESS-DEFERENCE field of a process indicates whether the process
;;; has waited, outside of INHIBIT-GC-FLIPS, to give the GC a chance to flip,
;;; when a flip is being held up because someone has inhibited flipping.
;;;   NIL   -- has not waited yet in the current GC cycle
;;;   T     -- has waited
;;;   RETRY -- has waited once but needs to wait again
;;;   WAIT  -- is waiting

(defun check-for-gc-waiting-to-flip ()
  ;; These aren't defined until later, so we have to declare them special here.
  (declare (special gc-flip-waiting nested-inhibit-gc-flips-flag
		    gc-flip-inhibit-wait-interval gc-flip-inhibit-wait-time))
  (when (and gc-flip-waiting
	     (not (or nested-inhibit-gc-flips-flag
		      (eq gc-flip-waiting *current-process*)
		      inhibit-scheduling-flag
		      (not process::*preemption-enabled*)
		      ;; These two forms replace
		      ;; (EQ SCHEDULER-STACK-GROUP %CURRENT-STACK-GROUP)
		      ;; (NOT (SG-RESUMABLE-P SCHEDULER-STACK-GROUP))
		      (null *current-process*)	;--- Can this happen?
		      (not (process::safe-to-process-wait-p *current-process*)))))
    ;; The GC is waiting for everyone to get out of INHIBIT-GC-FLIPS so it
    ;; can flip.  Defer to it unless it's definitely not the fault of this
    ;; process that things are wedged.
    (when (cond ((null (process-deference *current-process*))
		 ;; We have not waited yet, do so now.  Force all other processes
		 ;; to wait some more, since activity is still gradually dying down.
		 (setq gc-flip-inhibit-wait-time
		       (time-increment (time) gc-flip-inhibit-wait-interval))
		 (process:map-over-all-processes
		   #'(lambda (p)
		       (when (eq (process-deference p) t)
			 (setf (process-deference p) 'retry))))
		 t)
		((eq (process-deference *current-process*) 'retry)))
      ;; Note that we are waiting so that if PROCESS-WAIT conses we won't recurse infinitely
      (setf (process-deference *current-process*) 'wait)
      ;; Wait for a while to give the GC a chance to flip
      (process-wait "GC Flip" #'(lambda ()
				  (or (not gc-flip-waiting)
				      (time-lessp gc-flip-inhibit-wait-time (time)))))
      (setf (process-deference *current-process*) t))))

;; Runtime support for compiled functions that use &key.

;; Required keyword args are initialized to this value.
;; We compare the values against it to see which ones are missing.
;;(DEFCONST KEYWORD-GARBAGE '(KEYWORD-GARBAGE))

;Given ARGS, the list of key names and values;
;KEYKEYS, the list of keywords we understand, in their order;
;and FRAME-POINTER, a locative pointing at our caller's frame;
;decode the ARGS and stick the values into the right slots in the frame.
;The next argument is obsolete, and used to be NUMBER-OF-REQUIRED-KEYWORDS.
;SPECVAR-LIST is a list of NIL for nonspecial keyword args
;and symbols for special ones.
;It runs in parallel with KEYKEYS.
;On the L machine, the FRAME-POINTER argument is a locative to the first local
;#+3600 ;There don't seem to be any callers of this
;(DEFUN STORE-KEYWORD-ARG-VALUES (FRAME-POINTER ARGS KEYKEYS ALLOW-OTHER-KEYS
;				 &OPTIONAL IGNORE
;				 SPECVAR-LIST)
;  (DECLARE (DBG:ERROR-REPORTER))
;  (LET ()
;    ;; First decode what was specified.
;    (DO ((ARGS-LEFT ARGS (CDDR ARGS-LEFT)))
;	((NULL ARGS-LEFT))
;      (LET ((KEYWORD (CAR ARGS-LEFT)))
;	;; On 3600 slot is created only for locals
;	(DO-NAMED TRY-AGAIN () (NIL)
;	  (LOOP WITH ARG = (CADR ARGS-LEFT)
;		AND INDEX = 1
;		FOR KEY IN KEYKEYS
;		FOR SPECVAR IN SPECVAR-LIST
;		WHEN (EQ KEY KEYWORD)
;		  DO (IF SPECVAR
;			 (SET SPECVAR ARG)
;			 (%P-STORE-CONTENTS-OFFSET ARG FRAME-POINTER INDEX))
;		     (RETURN-FROM TRY-AGAIN)
;		UNLESS SPECVAR
;		  DO (INCF INDEX)
;		FINALLY
;		  (COND ((NOT ALLOW-OTHER-KEYS)
;			 (IF (EQ (MULTIPLE-VALUE (NIL KEYWORD)
;				   (SIGNAL 'UNDEFINED-KEYWORD-ARGUMENT
;					   ':KEYWORD KEYWORD
;					   ':PROCEED-TYPES '(:NO-ACTION :NEW-KEYWORD)))
;				 ':NO-ACTION)
;			     (RETURN-FROM TRY-AGAIN)))
;			(T (RETURN-FROM TRY-AGAIN)))))
;	))))

;;; This is defined here since macros can be defined before the editor is loaded
;;; In fact even before DEFMACRO is loaded.
;;; Better be defined before any uses of DEFMACRO in this file!
;;; This is now a hash table once the system is loaded, since it's gotten so big.
;;; However, it's still an alist while bootstrapping.
(defvar zwei:*lisp-indentation-offset-hash-table* nil)

(defconst *gprint-format-special-form-functions*
	  'gprint::(format-special-form-0 format-special-form-1 format-special-form-2
		    format-special-form-3 format-special-form-4 format-special-form-5
		    format-special-form-6 format-special-form-7))

(defun defmacro-set-indentation-for-zwei (name indentation)
  (when (symbolp name)
    (when (numberp indentation)
      (let ((formatter (get name 'gprint::formatter)))
	(when (or (null formatter)
		  (member formatter *gprint-format-special-form-functions*))
	  (putprop name (nth indentation *gprint-format-special-form-functions*)
		   'gprint::formatter)))
      (setq indentation (list indentation 1)))
    (if (cl:listp zwei:*lisp-indentation-offset-hash-table*)
	(let ((x (assq name zwei:*lisp-indentation-offset-hash-table*)))
	  (if (null x)
	      (push (cons name indentation) zwei:*lisp-indentation-offset-hash-table*)
	      (rplacd x indentation)))
	(send zwei:*lisp-indentation-offset-hash-table* :put-hash
	      name (copylist indentation zwei:*zmacs-buffer-area*)))))

(defun defmacro-clear-indentation-for-zwei (name)
  (when (symbolp name)
    ;; Remove formatting information if it seems likely that
    ;; DEFMACRO-SET-INDENTATION-FOR-ZWEI put the information there in the first
    ;; place.
    (let ((formatter (get name 'gprint::formatter)))
      (when (member formatter *gprint-format-special-form-functions*)
	(si:nremprop name 'gprint::formatter)))
    (if (cl:listp zwei:*lisp-indentation-offset-hash-table*)
	(setf zwei:*lisp-indentation-offset-hash-table*
	      (delq (assq name zwei:*lisp-indentation-offset-hash-table*)
		    zwei:*lisp-indentation-offset-hash-table*))
	(send zwei:*lisp-indentation-offset-hash-table* :rem-hash name))))

;; Useful user interface function for defining indentation
(defmacro zwei:defindentation ((name &rest indentation))
  `(defmacro-set-indentation-for-zwei ',name ',indentation))

(defun (:property zwei:defindentation :undo-function) (form)
  (let* ((name (first (second form)))
	 (old-indentation (zwei:get-indentation name)))
    `(defmacro-set-indentation-for-zwei ',name ',old-indentation)))

(defun zwei:get-indentation (thing)
  (if (cl:listp zwei:*lisp-indentation-offset-hash-table*)
      (cdr (assq thing zwei:*lisp-indentation-offset-hash-table*))
      (send zwei:*lisp-indentation-offset-hash-table* :get-hash thing)))

;Support for &KEY in DEFMACRO
(defun property-present-p (plist indicator)
  (loop for ind in plist by #'cddr
	thereis (eq ind indicator)))

;Support for &KEY in DEFMACRO
(defun validate-defmacro-keywords (list keys)
  (and (evenp (length list))
       (or (getf list :allow-other-keys)
           (loop for k in list by #'cddr
                 always (memq k keys)))))

;; STATUS and SSTATUS 
;; Note that these have to be Maclisp compatible and therefore have to work
;; independent of packages.  All symbols on feature lists are in the keyword package.

(defvar cl:*features*
	  '(:lispm :symbolics :genera
#+row-major :row-major				;temporary for conversion
#+3600	    3600.
#+3600	    :|3600|
#+IMACH     :imach
#+VLM	    :VLM
#+chaos	    :chaos
#+ether	    :ether
#+(or 3600 IMACH) :ieee-floating-point
	    :sort :fasload :string :newio :roman :trace :grindef :grind))

(defvar status-status-list '(:feature :features :nofeature :status :sstatus :tabsize
			     :userid :site :opsys))

(defvar status-sstatus-list '(:feature :nofeature))

(defun return-status (status-list item item-p)
  (cond ((not item-p) status-list)
	(t (not (null (mem #'(lambda (x y)
			       (cond ((numberp x) (and (numberp y) (= x y)))
				     ((numberp y) nil)
				     (t (string-equal x y))))
			   item status-list))))))

(cl:proclaim '(special local-host-name))

(defun status-internal (status-function &optional (item nil item-p))
  (declare lt:(side-effects reader))
  (selector status-function string-equal
    (('feature 'features) (return-status status-feature-list item item-p))
    (('nofeature) (cond ((not item-p)
			 (ferror "Too few args to STATUS NOFEATURE"))
			(t (not (return-status status-feature-list item item-p)))))
    (('status) (return-status status-status-list item item-p))
    (('sstatus) (return-status status-sstatus-list item item-p))
    (('tabsize) 8)
    (('userid) user-id)
    (('site) local-host-name)
    (('opsys) ':lispm)
    (otherwise (ferror "~S is not a legal STATUS request" status-function))))

(defun sstatus-internal (status-function item
			 &aux (default-cons-area working-storage-area))
  (if (symbolp item)
      (setq item (intern (string item) pkg-keyword-package)))	;These are all keywords
  (selector status-function string-equal
    (('feature) (cond ((not (member item status-feature-list))
		       (setq status-feature-list
			     (cons item status-feature-list))))
		item)
    (('nofeature) (cond ((member item status-feature-list)
			 (setq status-feature-list
			       (delq item status-feature-list))))
		  item)
    (otherwise (ferror "~S is not a legal SSTATUS request" status-function))))

;;;; Site stuff

(defun get-site-option (keyword)
  (send neti:*local-site* keyword))

(defmacro define-site-variable (variable keyword)
  `(progn 'compile
     (defvar ,variable)
     (add-initialization ,(format nil "SITE:~A" variable)
			 `(setq ,',variable (get-site-option ',',keyword))
			 '(site))))

(defmacro define-site-host-list (variable keyword)
  `(define-site-variable ,variable ,keyword))

(defvar *site-system* nil)

(add-initialization "Set site system" '(setq *site-system* (get-site-option ':site-system))
		    '(site normal))

(defun load-site-system (&rest make-system-options)
  (if *site-system*
      (lexpr-funcall #'sct:load-system *site-system* make-system-options)
      (format t "~&No site system is declared for this site.")))

;;; Obarray hacking functions

(defun apropos (apropos-substring &optional pkg (do-packages-used-by t) do-packages-used
		&aux return-list)
  (declare (special apropos-substring return-list))
  (setq pkg (if (null pkg) pkg-global-package (pkg-find-package pkg)))
  (mapatoms #'apropos-1 pkg do-packages-used)
  (and do-packages-used-by
       (dolist (p (pkg-used-by-list pkg))
	 (mapatoms #'apropos-1 p nil)))
  return-list)

(defun apropos-1 (symbol &aux comma)
  (declare (special apropos-substring return-list))
  (cond ((string-search apropos-substring (get-pname symbol))
	 (push symbol return-list)
	 ;; Binding the package to NIL forces the package to be printed.
	 ;; This is better than explicitly printing the package, because
	 ;; this way you get the "short" version.
	 (let ((package nil))
	   (format t "~%~S" symbol))
	 (when (fboundp symbol)
	   (condition-case (error)
		(progn
		  (format t " - Function ")
		  (lt:print-lambda-list (arglist symbol) standard-output :brief t :error-p nil))
	      (error (format t " - Garbage function (~~A~)" error)))
	   (setq comma t))
	 (when (boundp symbol)
	   (send standard-output ':string-out (if comma ", Bound" " - Bound"))
	   (setq comma t))
	 (when (get symbol 'si:flavor)
	   (send standard-output ':string-out (if comma ", Flavor" " - Flavor"))
	   (setq comma t))
	 (when (get symbol 'defresource)
	   (send standard-output ':string-out (if comma ", Resource" " - Resource")))
	 )))

(defun rem-keywords (list keywords)
  (loop with head = (locf list)
	as tail = (loop for l on (cdr head) by 'cddr
			when (memq (car l) keywords) return l)
	until (null tail)
	do (loop until (eq (cdr head) tail)
		 do (rplacd head (setq head (cons (cadr head) (cddr head)))))
	   (rplacd head (cddr tail)))
  list)

(defun rem-keywords-into-new-array (list keywords)
  (cond ((null list) nil)
	((null keywords) list)
	(t
	 (let* ((array (make-stack-array (length list)))
		(first (locf (aref array 0)))
		(pointer (sys:%make-pointer-offset sys:dtp-locative first -1)))
	   ;; Substitute a somewhat more efficient construct for I-machines...
	   (macrolet (#+IMACH
		      (%p-store-contents-increment-pointer (value pointer)
		        `(progn
			   (setq ,pointer (%pointer-plus ,pointer 1))
			   (%memory-write ,pointer ,value))))
	     (loop do (let ((name (pop list))
			    (value (pop list)))
			(when (not (cl:member name keywords))
			  (%p-store-contents-increment-pointer name pointer)
			  (%p-store-contents-increment-pointer value pointer)))
		   while (not (null list))))
	   (if (eq (sys:%make-pointer-offset sys:dtp-locative first -1) pointer)
	       nil
	     (setf (%p-cdr-code pointer) sys:cdr-nil)
	     (sys:%make-pointer sys:dtp-list first))))))


#+3600
(defun %make-pointer-offset (new-dtp pointer offset)
  (%make-pointer new-dtp (%make-pointer-offset dtp-locative pointer offset)))

;;; This is used to define list access functions
(defmacro defcxr (name)
  (check-arg-type name :symbol)
  (let* ((string (string name))
	 (length (1- (string-length string))))
    (or (and (char-equal (aref string 0) #/C) (char-equal (aref string length) #/R))
	(ferror "Not the name of a C...R function ~S" name))
    (do ((i (1- length) (1- i))
	 (form 'x))
	(( i 0)
	 `(,(if (> length 2) 'defsubst 'defun) ,name (x)
	   (declare lt:(side-effects reader reducible)
		    (compiler:do-not-record-macroexpansions))
	   ,form))
      (setq form (list (selector (aref string i) char-equal
			 (#/A 'car)
			 (#/D 'cdr)
			 (otherwise (ferror "Not the name of a C...R function ~S" name)))
		       form)))))

;(DEFCXR CR)

;(DEFCXR CAR)
;(DEFCXR CDR)

(defcxr caar)
(defcxr cadr)
(defcxr cdar)
(defcxr cddr)

(defcxr caaar)
(defcxr caadr)
(defcxr cadar)
(defcxr caddr)
(defcxr cdaar)
(defcxr cdadr)
(defcxr cddar)
(defcxr cdddr)

(defcxr caaaar)
(defcxr caaadr)
(defcxr caadar)
(defcxr caaddr)
(defcxr cadaar)
(defcxr cadadr)
(defcxr caddar)
(defcxr cadddr)
(defcxr cdaaar)
(defcxr cdaadr)
(defcxr cdadar)
(defcxr cdaddr)
(defcxr cddaar)
(defcxr cddadr)
(defcxr cdddar)
(defcxr cddddr)

;;;This is like LIST except that "the last pair is dotted"
(defun list* (&rest args)
  (declare lt:(side-effects reader)
	   (compiler:return-type cl:list)
	   (compiler:do-not-record-macroexpansions))
  (cond ((null args)
	 (error 'too-few-arguments ':function 'list* ':nargs 0 ':argument-list args))
	((null (cdr args)) (car args))
	(t (let ((lst (%make-list nil nil (length args))))
	     (do ((args args (cdr args))
		  (cns lst (cdr cns)))
		 ((null (cddr cns))
		  (%change-list-to-cons cns)
		  (rplaca cns (car args))
		  (rplacd cns (cadr args))
		  lst)
	       (rplaca cns (car args)))))))

;;;This is like LIST-IN-AREA except that "the last pair is dotted"
(defun list*-in-area (area &rest args)
  (declare lt:(side-effects reader)
	   (compiler:return-type cl:list)
	   (compiler:do-not-record-macroexpansions))
  (cond ((null args)
	 (error 'too-few-arguments ':function 'list*-in-area ':nargs 0 ':argument-list args))
	((null (cdr args)) (car args))
	(t (let ((lst (%make-list nil area (length args))))
	     (do ((args args (cdr args))
		  (cns lst (cdr cns)))
		 ((null (cddr cns))
		  (%change-list-to-cons cns)
		  (rplaca cns (car args))
		  (rplacd cns (cadr args))
		  lst)
	       (rplaca cns (car args)))))))

(defun list (&rest elements)
  (declare lt:(side-effects reader)
	   (compiler:return-type cl:list)
	   (compiler:do-not-record-macroexpansions))
  (prog (val tem)
	(or elements (return nil))
	(setq tem (setq val (%make-list nil nil (length elements))))
  l	(rplaca tem (car elements))
	(cond ((null (setq tem (cdr tem))) (return val)))
	(setq elements (cdr elements))
	(go l)))
	
(defun list-in-area (area &rest elements)
  (declare lt:(side-effects reader)
	   (compiler:return-type cl:list))
  (prog (val tem)
	(or elements (return nil))
	(or (numberp area) (setq area (symeval area)))
	(setq tem (setq val (%make-list nil area (length elements))))
  l	(rplaca tem (car elements))
	(cond ((null (setq tem (cdr tem))) (return val)))
	(setq elements (cdr elements))
	(go l)))

#+IMACH
(defun length (x)
  (declare lt:(side-effects reader reducible))
  (declare (compiler:return-type (cl:integer 0 #.cl:most-positive-fixnum)))
  (cl:check-type x cl:list)
  (let ((n 0) (list x))
    (cl:loop		;Loop unrolled eight times
      (compiler:%error-when (atom list)
	(return-from length n))
      (setq list (cdr list))
      (compiler:%error-when (atom list)
	(return-from length (+ n 1)))
      (setq list (cdr list))
      (compiler:%error-when (atom list)
	(return-from length (+ n 2)))
      (setq list (cdr list))
      (compiler:%error-when (atom list)
        (return-from length (+ n 3)))
      (setq list (cdr list))
      (compiler:%error-when (atom list)
        (return-from length (+ n 4)))
      (setq list (cdr list))
      (compiler:%error-when (atom list)
        (return-from length (+ n 5)))
      (setq list (cdr list))
      (compiler:%error-when (atom list)
        (return-from length (+ n 6)))
      (setq list (cdr list))
      (compiler:%error-when (atom list)
        (return-from length (+ n 7)))
      (setq list (cdr list) n (+ n 8)))
    (return-from length n)))

(defun nth (n list)
  (declare lt:(side-effects reader reducible))
  (cl:check-type n cl:(integer 0 *))
  (dotimes (ignore n)
    (setf list (cdr list)))
  (car list))

(defun nthcdr (n list)
  (declare lt:(side-effects reader reducible))
  (cl:check-type n cl:(integer 0 *)) 
  (dotimes (ignore n)
    (setf list (cdr list)))
  list)

(defun array-push (array x)
  (without-interrupts
    (let* ((old-length (array-leader array 0))
	   (new-length (1+ old-length)))
      (cond (( new-length (array-length array))
	     (aset x array old-length)
	     (store-array-leader new-length array 0)
	     (cond ((= (array-type-field array) art-q-list)
		    (if (plusp old-length)
			(%p-store-cdr-code (aloc array (1- old-length)) cdr-next))
		    (%p-store-cdr-code (aloc array old-length) cdr-nil)))
	     old-length)))))

(defun closure (symbol-list function)
  (declare lt:(side-effects reader))
  (if (null symbol-list)
      function
    (let ((list (%make-list nil nil (1+ (* (length symbol-list) 2)))))
      (rplaca list function)
      (loop for symbol in symbol-list
	    for l = (cdr list) then (cddr l)
	    as cell = (value-cell-location symbol)
	    do (rplaca l cell)			;Internal value cell
	       (setq cell (follow-cell-forwarding cell nil))
	       (unless (= (%p-data-type cell) dtp-external-value-cell-pointer)
		 ;; Don't put invisible pointers into A-memory
		 #+3600
		 (unless (%pointer-lessp cell a-memory-virtual-address)
		   (error "Cannot close over ~S because its value cell is in hardware A-memory"
			  symbol))
		 ;; No external value cell exists yet, make one
		 (let ((x (%make-pointer dtp-locative (%make-list nil nil 1))))
		   (if (boundp symbol)
		       (rplaca x (symeval symbol))
		       (%p-store-cdr-type-and-pointer x cdr-nil dtp-null symbol))
		   (%p-store-type-and-pointer cell dtp-external-value-cell-pointer x)))
	       (rplaca (cdr l) (%p-contents-as-locative cell)))	;External value cell
      (%make-pointer #+3600 dtp-closure #+IMACH dtp-dynamic-closure list))))

(defun false (&rest ignore)
  (declare lt:(replicability many-times))
  (declare lt:(side-effects simple reducible))
  nil)

(defun true (&rest ignore)
  (declare lt:(replicability many-times))
  (declare lt:(side-effects simple reducible))
  t)


(defmacro fast-equal (a b &environment env)
  (once-only (a b &environment env)
    `(cond ((eql ,a ,b) t)
	   (t (equal ,a ,b)))))

;;; I think this was the winner in the runoff prior to microcoding this on the A machine
;;; Changed some more since then, though.  Use EQL to compare numbers.
(defun equal (a b)
  (declare lt:(side-effects reader reducible))
  (declare (compiler:return-type scl:boolean))
  (cond ((eql a b)
	 (return-from equal t))
	((not (atom a))
	 (if (atom b)
	     (return-from equal nil)
	     (loop do
	       (cond ((not (fast-equal (pop a) (pop b)))
		      (return-from equal nil))
		     ((not (and (listp a) (listp b)))
		      (return-from equal (fast-equal a b)))))))
	((stringp a)
	 (return-from equal (and (stringp b)
				 (= (array-active-length a) (array-active-length b))
				 (%string-equal a 0 b 0 nil))))))

;;;; Array copying

#+IMACH
(defun copy-array-portion (from-array from-start from-end to-array to-start to-end)
  (cl:check-type from-array cl:array)
  (cl:check-type to-array cl:array)
  (cl:check-type from-start cl:fixnum)
  (cl:check-type from-end cl:fixnum)
  (cl:check-type to-start cl:fixnum)
  (cl:check-type to-end cl:fixnum)
  (multiple-value-bind (s-array s-control s-address s-bound)
      (setup-force-1d-array from-array)
    (declare (ignore s-array))
    (multiple-value-bind (d-array d-control d-address d-bound)
	(setup-force-1d-array to-array)
      (declare (ignore d-array))
      ;; Fast way of assuring that 0  FROM-START  FROM-END  S-BOUND.
      (compiler:%error-unless (and (not (%unsigned-lessp s-bound from-end))
				   (not (%unsigned-lessp from-end from-start)))
        (error "Illegal subscript range for FROM-ARRAY"))
      ;; Fast way of assuring that 0  TO-START  TO-END  D-BOUND.
      (compiler:%error-unless (and (not (%unsigned-lessp d-bound to-end))
				   (not (%unsigned-lessp to-end to-start)))
        (error "Illegal subscript range for TO-ARRAY"))
      (let ((elements (min (- from-end from-start) (- to-end to-start))))
	(cond ((or ;; Setup overhead threshold
		   (< elements 8)
		   ;; Arrays of differing element types can't be copied at all, let the slow
		   ;; case signal the error.  Also, bitwise copying is meaningless for
		   ;; elements of differing sizes; the two fields are conveniently contiguous.
		   ( (ldb (byte (+ (byte-size array-register-element-type)
				    (byte-size array-register-byte-packing))
				 (byte-position array-register-byte-packing))
			   s-control)
		      (ldb (byte (+ (byte-size array-register-element-type)
				    (byte-size array-register-byte-packing))
				 (byte-position array-register-byte-packing))
			   d-control))
		   ;; Arrays containing objects can also contain forwarding pointers and
		   ;; valuable cdr codes, so we can't do a bitwise copy.
		   (= (ldb array-register-element-type s-control) array-element-type-object))
	       (dotimes (ignore (%fixnum-floor elements 4))
		 (fast-aset-1 (fast-aref-1 from-start s-control) to-start d-control)
		 (incf from-start)
		 (incf to-start)
		 (fast-aset-1 (fast-aref-1 from-start s-control) to-start d-control)
		 (incf from-start)
		 (incf to-start)
		 (fast-aset-1 (fast-aref-1 from-start s-control) to-start d-control)
		 (incf from-start)
		 (incf to-start)
		 (fast-aset-1 (fast-aref-1 from-start s-control) to-start d-control)
		 (incf from-start)
		 (incf to-start))
	       (dotimes (ignore (%fixnum-mod elements 4))
		 (fast-aset-1 (fast-aref-1 from-start s-control) to-start d-control)
		 (incf from-start)
		 (incf to-start)))
	      (t
	       (let ((shift (- 5 (ldb array-register-byte-packing s-control))))
		 (%copy-bits
		   (rot elements shift)
		   s-address
		   (rot (+ (ldb array-register-byte-offset s-control) from-start) shift)
		   d-address
		   (rot (+ (ldb array-register-byte-offset d-control) to-start) shift)))
	       (incf to-start elements))))
      (compiler:%error-when (< to-start to-end)
	(loop with null-elem = (array-null-element (ldb array-type-field d-control))
	      do (fast-aset-1 null-elem to-start d-control)
		 (incf to-start)
	      while (< to-start to-end)))
      t)))

#+3600
(defun copy-array-portion (from-array from-start from-end to-array to-start to-end)
  (cl:check-type from-array cl:array)
  (cl:check-type to-array cl:array)
  (cl:check-type from-start cl:fixnum)
  (cl:check-type from-end cl:fixnum)
  (cl:check-type to-start cl:fixnum)
  (cl:check-type to-end cl:fixnum)
  (compiler:%error-unless (<= 0 from-start from-end (cl:array-total-size from-array))
    (error "FROM-END is out of bounds."))
  (compiler:%error-unless (<= 0 to-start to-end (cl:array-total-size to-array))
    (error "TO-END is out of bounds."))
  (let ((s-type (array-type-field from-array))
	(d-type (array-type-field to-array))
	(elements (min (- from-end from-start) (- to-end to-start))))
    (cond ((or ;; Setup overhead threshold
	     (< elements 8)
	     ;; Arrays of differing element types can't be copied at all, let the slow
	     ;; case signal the error.  Also, bitwise copying is meaningless for
	     ;; elements of differing sizes.
	     ( s-type d-type)
	     ;; Arrays whose elements aren't stored as fixnums can't be bitwise copied.
	     (bit-member s-type
	       (logior (rot 1 art-q) (rot 1 art-q-list) (rot 1 art-fat-string))))
	   (let ((from from-array)
		 (to to-array))
	     (declare (sys:array-register-1d from to))
	     (dotimes (ignore (%fixnum-floor elements 4))
	       (setf (aref to to-start) (aref from from-start))
	       (incf from-start)
	       (incf to-start)
	       (setf (aref to to-start) (aref from from-start))
	       (incf from-start)
	       (incf to-start)
	       (setf (aref to to-start) (aref from from-start))
	       (incf from-start)
	       (incf to-start)
	       (setf (aref to to-start) (aref from from-start))
	       (incf from-start)
	       (incf to-start))
	     (dotimes (ignore (%fixnum-mod elements 4))
	       (setf (aref to to-start) (aref from from-start))
	       (incf from-start)
	       (incf to-start))))
	  (t
	   (multiple-value-bind (s-array s-control s-address s-bound s-offset)
	       (sys:setup-force-1d-array-sequential from-array)
	     (declare (ignore s-array s-control s-bound))
	     (multiple-value-bind (d-array d-control d-address d-bound d-offset)
		 (sys:setup-force-1d-array-sequential to-array)
	       (declare (ignore d-array d-control d-bound))
	       (let ((bpe (array-bits-per-element s-type)))
		 (%copy-bits
		   (* elements bpe)
		   s-address
		   (* (+ s-offset from-start) bpe)
		   d-address
		   (* (+ d-offset to-start) bpe)))
	       (incf to-start elements)))))
    (compiler:%error-when (< to-start to-end)
      (let ((to to-array))
	(declare (sys:array-register-1d to))
	(loop with null-elem = (array-null-element d-type)
	      do (setf (aref to to-start) null-elem)
		 (incf to-start)
	      while (< to-start to-end))))
    t))

(deff copy-array-portion-internal #'copy-array-portion)

;;; These three functions work on arrays of any number of dimensions
(defun copy-array-contents (from-array to-array)
  (copy-array-portion from-array 0 (array-length from-array)
		      to-array 0 (array-length to-array)))

(defun copy-array-contents-and-leader (from-array to-array)
  (copy-array-contents from-array to-array)
  (loop for i from 0 below (min (or (array-leader-length from-array) 0)
				(or (array-leader-length to-array) 0))
	do (setf (array-leader to-array i) (array-leader from-array i)))
  t)

(defun copy-string-portion (from-string from-start from-end to-string to-start to-end
			    &key make-thin)
  (cl:check-type from-string cl:string)
  (cl:check-type to-string cl:string)
  (if (or (not make-thin)
	  (not (string-fat-p from-string)))
      (copy-array-portion from-string from-start from-end to-string to-start to-end)
    (cl:check-type from-start (cl:integer 0 *))
    (cl:check-type from-end cl:integer)
    (compiler:%error-unless (<= from-start from-end (cl:array-total-size from-string))
      (error "FROM-END is out of bounds."))
    (cl:check-type to-start (cl:integer 0 *))
    (cl:check-type to-end cl:integer)
    (compiler:%error-unless (<= to-start to-end (cl:array-total-size to-string))
      (error "TO-END is out of bounds."))
    (let ((from-string from-string) (to-string to-string)
	  (index-from from-start) (index-to to-start))
      (declare (compiler:array-register from-string to-string))
      (loop repeat (min (- from-end from-start) (- to-end to-start))
	    ;; Let the microcode complain if the character set is non-zero
	    ;; and we are storing into a thin string
	    do (setf (aref to-string index-to)
		     (code-char (char-code (aref from-string index-from))))
	       (incf index-from)
	       (incf index-to))
      (when (< index-to to-end)
	(cl:loop
	   (setf (aref to-string index-to) (code-char 0))
	   (incf index-to)
	   (unless (< index-to to-end) (return))))
      t)))

#+IMACH
(defwiredfun %copy-bits (bits s-address s-bitpos d-address d-bitpos)
  (macrolet ((combine (mask source destination)
	       `(let ((aluf (%read-internal-register %register-alu-and-rotate-control))
		      (mask ,mask))
		  (%write-internal-register aluf %register-alu-and-rotate-control)
		  (logior (logand ,source mask) (logand ,destination (lognot mask)))))
	     (with-internal-registers ((&rest registers) &body body)
	       (loop for register in registers
		     as variable = (gensym)
		     collect `(,variable (%read-internal-register ,register)) into bindings
		     collect `(%write-internal-register ,variable ,register) into cleanups
		     finally
		       (return
			 `(let ,bindings
			    (unwind-protect
				(progn . ,body)
			      ,@(nreverse cleanups)))))))
    ;; Preserve these registers using an unwind-protect
    (with-internal-registers (%register-bar-2 %register-alu-and-rotate-control)
      (setf (%block-register 1) (%pointer-plus s-address (%fixnum-floor s-bitpos 32.)))
      (setf (%block-register 2) (%pointer-plus d-address (%fixnum-floor d-bitpos 32.)))
      (let ((s-bitpos (%fixnum-mod s-bitpos 32.))
	    (d-bitpos (%fixnum-mod d-bitpos 32.)))
	;; No further uses of BAR 0 in this code, grr...
	(prepare-for-block-write)
	;; Special case short transfers (in particular those where the destination
	;; fits within one word).
	(compiler:%error-when ( bits 32.)
	  (when (= bits 0)
	    (return-from %copy-bits nil))
	  (when ( (+ d-bitpos bits) 32.)	;destination within one word
	    (if ( (+ s-bitpos bits) 32.)	;source within one word
		(set-alu-and-rotate-control :byte-r (- d-bitpos s-bitpos) :byte-s -1)
	      (set-alu-and-rotate-control :byte-r (- d-bitpos s-bitpos)
					  :byte-s (- s-bitpos d-bitpos 1))
	      ;; Might need an extra word of source for the destination word
	      (if (> s-bitpos d-bitpos) (%block-read-shift 1 :fixnum-only t)))
	    (%block-write 2
	      (combine (%32-bit-difference (lsh 1 (+ d-bitpos bits)) (rot 1 d-bitpos))
		       (%block-read-shift 1 :fixnum-only t)
		       (%block-read 2 :no-increment t :fixnum-only t)))
	    (return-from %copy-bits nil)))
	;; Set up the rotate control; the test for = is just a tweak, the other clause works
	(if (= s-bitpos d-bitpos)
	    (set-alu-and-rotate-control :byte-r 0 :byte-s -1)
	  (set-alu-and-rotate-control :byte-r (- d-bitpos s-bitpos)
				      :byte-s (- s-bitpos d-bitpos 1))
	  ;; Might need an extra word of source for the first destination word
	  (if (> s-bitpos d-bitpos) (%block-read-shift 1 :fixnum-only t)))
	;; Do partial word at the front of the destination, if any
	(when ( d-bitpos 0)
	  (%block-write 2
	    (combine (lsh -1 d-bitpos)
		     (%block-read-shift 1 :fixnum-only t)
		     (%block-read 2 :no-increment t :fixnum-only t)))
	  (decf bits (- 32. d-bitpos)))
	;; Copy all the complete words, in 8-word chunks at first
	(let ((words (%fixnum-floor bits 32.)))
	  (dotimes (ignore (%fixnum-floor words 8))
	    (let ((w0 (%block-read-shift 1 :fixnum-only t))
		  (w1 (%block-read-shift 1 :fixnum-only t))
		  (w2 (%block-read-shift 1 :fixnum-only t))
		  (w3 (%block-read-shift 1 :fixnum-only t))
		  (w4 (%block-read-shift 1 :fixnum-only t))
		  (w5 (%block-read-shift 1 :fixnum-only t))
		  (w6 (%block-read-shift 1 :fixnum-only t))
		  (w7 (%block-read-shift 1 :prefetch nil :fixnum-only t)))
	      (%block-write 2 w0)
	      (%block-write 2 w1)
	      (%block-write 2 w2)
	      (%block-write 2 w3)
	      (%block-write 2 w4)
	      (%block-write 2 w5)
	      (%block-write 2 w6)
	      (%block-write 2 w7)))
	  ;; Copy remaining words one at a time
	  (dotimes (ignore (%fixnum-mod words 8))
	    (%block-write 2 (%block-read-shift 1 :fixnum-only t))))
	;; Do partial word at the end of the destination, if any
	(when ( (setq bits (%fixnum-mod bits 32.)) 0)
	  (%block-write 2
	    (combine (%32-bit-difference (rot 1 bits) 1)
		     (if ( (%fixnum-mod (- d-bitpos s-bitpos) 32.) bits)
			 ;; Rotate latch contains enough bits to make the destination
			 (%rotate-latch)	;clobbers BYTE-R and BYTE-S
		       ;; Rotate latch doesn't contain enough bits, read more
		       (%block-read-shift 1 :no-increment t :fixnum-only t))
		     (%block-read 2 :no-increment t :fixnum-only t))))))
    nil))

#+3600
(defun %copy-bits (bits s-address s-bitpos d-address d-bitpos)
  (when ( bits 0)
    (let ((pad-6 nil)
	  (pad-7 nil)
	  (pad-8 nil)
	  (pad-9 nil)
	  ;; This is the block known about by the microcode.
	  (bb-width bits)
	  (bb-s-data-addr s-address)
	  (bb-s-row-offset 0)			;irrelevant for 1d bitblt
	  (bb-s-offset (%fixnum-floor s-bitpos 32.))
	  (bb-s-bitpos (%fixnum-mod s-bitpos 32.))
	  (bb-s-row-length 1_31.)		;disable source wraparound
	  (bb-d-data-addr d-address)
	  (bb-d-offset (%fixnum-floor d-bitpos 32.))
	  (bb-d-bitpos (%fixnum-mod d-bitpos 32.))
	  (bb-event-count nil)			;not used
	  (bb-alu-operation tv:alu-seta))
      (progn pad-6 pad-7 pad-8 pad-9
	     bb-width
	     bb-s-data-addr bb-s-row-offset bb-s-offset bb-s-bitpos bb-s-row-length
	     bb-d-data-addr bb-d-offset bb-d-bitpos bb-event-count bb-alu-operation)
      (if ( bits 32.) (%bitblt-short-row) (%bitblt-long-row))
      nil)))

#||
(defun test-copy-bits ()
  (let* ((s-array (cl:coerce (loop repeat 256 collect (random 2)) 'cl:(vector bit)))
	 (d-array (cl:copy-seq s-array))
	 (s-address (%make-pointer-offset dtp-locative s-array (array-data-offset s-array)))
	 (d-address (%make-pointer-offset dtp-locative d-array (array-data-offset d-array))))
    (declare (sys:array-register s-array d-array))
    (loop for bits in '#10r(1 2 30 31 32 33 63 64 65 66 95 96 97 98) do
      (loop for s-bitpos below 34. do
	(loop for d-bitpos below 34. do
	  (%copy-bits bits s-address s-bitpos d-address d-bitpos)
	  (loop repeat bits for s from s-bitpos and d from d-bitpos do
	    (compiler:%error-when ( (aref s-array s) (aref d-array d))
	      (format t "~&Failed copying ~D bits from bit ~D in ~S to bit ~D in ~S"
		      bits s-bitpos s-array d-bitpos d-array))))))))

(defun test-copy-array-portion ()
  (labels ((test-case (from-type from-start from-end to-type to-start to-end)
	     (stack-let ((from-0 (make-array (1+ from-end) :type from-type))
			 (to-0 (make-array (1+ to-end) :type to-type))
			 (from-1 (make-array (1+ from-end) :type from-type))
			 (to-1 (make-array (1+ to-end) :type to-type)))
	       (declare (sys:array-register from-0 to-0 from-1 to-1))
	       (loop for i below (array-total-size from-0) do (setf (aref from-0 i) i))
	       (loop for i below (array-total-size from-1) do (setf (aref from-1 i) i))
	       (copy-array-portion from-0 from-start from-end to-0 to-start to-end)
	       (loop for i from from-start below from-end
		     for j from to-start below to-end
		     do
		 (setf (aref to-1 j) (aref from-1 i)))
	       (loop for j below (array-total-size to-0) do
		 (compiler:%error-when (not (eql (aref to-0 j) (aref to-1 j)))
		   (format t "~&Mismatch at index ~O, expected ~O, got ~O"
			   j (aref to-1 j) (aref to-0 j))
		   (format t "~&  Arguments: ~A ~O ~O ~A ~O ~O"
			   (array-type from-0) from-start from-end
			   (array-type to-0) to-start to-end)))))
	   (test (s-type d-type bound)
	     (loop for size from 1 below bound do
	       (loop for s-start from 0 below bound do
		 (loop for d-start from 0 below bound do
		   (test-case s-type s-start (+ s-start size)
			      d-type d-start (+ d-start size)))))))
    (test art-q art-q 4)
    (test art-fixnum art-fixnum 4)
    (test art-8b art-8b 16.)
    (test art-1b art-1b 72.)))

(defun meter-copy-array-portion ()
  (labels ((trial (function type size)
	     (stack-let ((array (make-array (+ size 1) :type type)))
	       (process:without-preemption
		 (let ((start-time (%microsecond-clock)))
		   (loop repeat 5 do
		     (loop for ripple below 2 do
		       (funcall function array ripple size array 0 (- size ripple))))
		   (cl:// (%32-bit-difference (%microsecond-clock) start-time) 10.)))))
	   (meter (type size)
	     (let ((old-time (loop repeat 5 minimize (trial #'copy-array-portion type size)))
		   (new-time (loop repeat 5 minimize (trial #'%copy-array-portion type size))))
	       (format t "~&Copy ~D elements of ~A array: ~35T~5D~8D microseconds"
		       size (array-types type) (round old-time) (round new-time)))))
    (meter art-q 2)
    (meter art-q 16.)
    (meter art-q 256.)
    (meter art-8b 2)
    (meter art-8b 16.)
    (meter art-8b 256.)))
||#


(defun g-l-p (array)
  (declare lt:(side-effects reader))
  (check-arg array (and (arrayp array) (= (array-type-field array) art-q-list))
	     "an ART-Q-LIST array")
  (if (zerop (array-active-length array)) nil
      (%make-pointer dtp-list (locf (aref array 0)))))

(defun find-position-in-list (item list)
  (declare lt:(side-effects reader reducible))
  (do ((c 0 (1+ c)))
      ((endp list))
    (when (eq item (pop list)) (return c))))

(defun getl (symbol indicator-list)
  (declare lt:(side-effects reader reducible))
  (multiple-value-bind (nil nil list)
      (cl:get-properties (plist symbol) indicator-list)
    list))

;This is a crock, but there are still two callers of it
(defun multiple-value-get (plist indicator)
  (declare (values value found-p))
  (do ((plist (if (symbolp plist) (plist plist) (cdr plist)) (cddr plist)))
      ((null plist) (values nil nil))
    (and (eq (car plist) indicator)
	 (return (values (cadr plist) t)))))

;; Two argument NCONC, optimized by the compiler.
(defun *nconc (a b)
  (if (atom a)
      b
      (progn (rplacd (last a) b)
	     a)))

;;; do the recursion that can't be done in microcode:
#+3600
(defun unify-list-escape (v1 v2)
  (declare (safeguarded-function))
  ;; both v1 and v2 have been fully dereferenced, and are not variables
  (loop with tail1 = v1
	with tail2 = v2
	do (%unify-value (car tail1) (car tail2))
	   (setq tail1 (cdr tail1)
		 tail2 (cdr tail2))
	while (and (listp tail1) (listp tail2))
	finally (%unify-value tail1 tail2)))

;;;; TYPEP and friends

(defsubst data-type (x)
  (data-type-name (%data-type x)))

(defvar typep-alist '#.`((,dtp-symbol . :symbol)
			 (,dtp-nil . :symbol)
			 (,dtp-list . :list)
			 (,#+3600 dtp-fix #+IMACH dtp-fixnum . :fixnum)
			 (,#+3600 dtp-float #+IMACH dtp-single-float . :single-float)
			 (,dtp-locative . :locative)
			 (,dtp-compiled-function . :compiled-function)
			 (,#+3600 dtp-closure #+IMACH dtp-dynamic-closure . :closure)
			 (,dtp-instance . :instance)
			 (,dtp-generic-function . :generic-function)
			 (,dtp-array . :array)
			 #+IMACH(,dtp-string . :string)
			 #+3600(,dtp-extended-number . :extended-number)
			 #+IMACH(,dtp-double-float . :double-float)
			 #+IMACH(,dtp-bignum . :bignum)
			 #+IMACH(,dtp-complex . :complex)
			 #+IMACH(,dtp-small-ratio . :small-ratio)
			 #+IMACH(,dtp-big-ratio . :big-ratio)
			 #+IMACH(,dtp-physical-address . :physical-address)
			 (,dtp-character . :character)
			 (,dtp-logic-variable . :unbound-logic-variable)
			 #+IMACH(,dtp-spare-immediate-1 . :native-instruction)
			 ))

(defprop :string stringp typep)
(defprop :atom atom typep)
(defprop :bignum bigp typep)
(defprop :fix fixp typep)
(defprop :positive-fixnum positive-fixnump typep)
(defprop :non-negative-fixnum non-negative-fixnump typep)
(defprop :number numberp typep)
(defprop :rational rationalp typep)
(defprop :float floatp typep)
(defprop :single-float single-float-p typep)
(defprop :double-float double-float-p typep)
(defprop :symbol symbolp typep)
(defprop :array arrayp typep)
(defprop :stack-group stack-group-p typep)
(defprop :list-or-nil cl:listp typep)
(defprop :complex complexp typep)
(defprop :non-complex-number not-complex-numberp typep)
(defprop :lexical-closure lexical-closure-p typep)
(defprop :funcallable-instance funcallable-instance-p typep)
#+IMACH
(defprop :extended-number extended-number-p typep)	;Any non-immediate number

;; Although this isn't microcoded, it is optimized by the compiler, so
;; we might as well use it.  Later CL:LISTP will replace LISTP; in Common
;; Lisp "list" includes NIL.
(defprop :list listp typep)
(defprop :null null typep)

;;; Pretty names for types.  This is used by the CHECK-ARG-TYPE macro.
(defprop dtp-nil "NIL" type-name)
(defprop dtp-symbol "a symbol other than NIL" type-name)
(defprop :symbol "a symbol" type-name)
(defprop :list "a list" type-name)
(defprop :null "NIL" type-name)
(defprop :fixnum "a fixnum" type-name)
(defprop :locative "a locative" type-name)
(defprop :unbound-logic-variable "an unbound logic variable" type-name)
(defprop :compiled-function "a compiled function" type-name)
(defprop :closure "a dynamic closure" type-name)
(defprop :instance "an instance" type-name)
(defprop :lexical-closure "a lexical closure" type-name)
(defprop :generic-function "a generic function" type-name)
(defprop :string "a string" type-name)
(defprop :array "an array" type-name)
(defprop :atom "an atom" type-name)
(defprop :bignum "a bignum" type-name)
(defprop :fix "an integer" type-name)
(defprop :positive-fixnum "a positive fixnum" type-name)
(defprop :non-negative-fixnum "a non-negative fixnum" type-name)
(defprop :number "a number" type-name)
(defprop :rational "a ratio" type-name)
(defprop :float "a floating-point number" type-name)
(defprop :single-float "a single-precision floating-point number" type-name)
(defprop :double-float "a double-precision floating-point number" type-name)
(defprop :flonum "a flonum" type-name)
(defprop :character "a character" type-name)
(defprop :stack-group "a stack group" type-name)
(defprop :list-or-nil "a list" type-name)
(defprop :complex "a complex number" type-name)
(defprop :non-complex-number "a non-complex number" type-name)

#+3600
(defsubst listp (object)
  (declare (compiler:do-not-record-macroexpansions))
  (not (atom object)))

#+IMACH
(defun listp (object)
  (declare lt:(side-effects simple reducible) (compiler:return-type scl:boolean))
  (type-member object dtp-list dtp-list-instance))

(defsubst nlistp (x)
  (declare (compiler:do-not-record-macroexpansions))
  (atom x))

(defsubst nsymbolp (x)
  (declare (compiler:do-not-record-macroexpansions))
  (not (symbolp x)))

(defsubst locativep (x)
  (declare (compiler:do-not-record-macroexpansions))
  (= (%data-type x) dtp-locative))

#+IMACH
(defsubst physical-address-p (x)
  (declare (compiler:do-not-record-macroexpansions))
  (type-member x dtp-physical-address))

(defsubst unbound-logic-variable-p (x)
  (declare (compiler:do-not-record-macroexpansions))
  #+3600
  (= (%data-type x) dtp-logic-variable)
  #+IMACH
  (or (type-member x dtp-logic-variable)			;Rev 3
      (and (type-member x dtp-external-value-cell-pointer)	;Rev 2
	   (= (%p-data-type x) dtp-logic-variable))))

#+3600
(defsubst instancep (x)
  (declare (compiler:do-not-record-macroexpansions))
  (= (%data-type x) dtp-instance))

#+IMACH
(defun instancep (x)
  (declare lt:(side-effects simple reducible))
  (type-member x dtp-instance dtp-list-instance dtp-string-instance dtp-array-instance))

(defsubst closurep (x)
  (declare (compiler:do-not-record-macroexpansions))
  (= (%data-type x) #+3600 dtp-closure #+IMACH dtp-dynamic-closure))

(defsubst lexical-closure-p (x)
  (and (= (%data-type x) dtp-lexical-closure)
       (= (lexical-closure-subtype x) lexical-closure-subtype-lexical-closure)))

(defsubst funcallable-instance-p (x)
  (and (= (%data-type x) dtp-lexical-closure)
       (= (lexical-closure-subtype x) lexical-closure-subtype-funcallable-instance)))

(defun clos-internals::generic-function-p (thing)
  (and (sys:funcallable-instance-p thing)
       (= (sys:%data-type (clos-internals::%funcallable-instance-extra-argument thing))
	  sys:dtp-generic-function)))

(defun eql-dispatch-instance-p (x)
  (and (= (%data-type x) dtp-instance)
       (eq (flavor-name (%instance-flavor x)) t)))

(defun flavor-instance-p (x)
  (eq (aref (%instance-flavor x) 0) 'flavor:flavor))

(defun clos-instance-p (x)
  (instancep (flavor-name (%instance-flavor x))))

(defsubst generic-function-p (x)
  (declare (compiler:do-not-record-macroexpansions))
  (= (%data-type x) dtp-generic-function))

;Synonymous with SINGLE-FLOAT-P on the 3600.  This is an archaic name.
(defsubst flonump (object)  "true if single precision flonum"
  (declare (compiler:do-not-record-macroexpansions))
  (single-float-p object))

(defsubst fixnump (object) "Unlike FIXP, true only for fixnums, not bignums"
  (declare (compiler:do-not-record-macroexpansions))
  (= (%data-type object) #+3600 dtp-fix #+IMACH dtp-fixnum))

(defun positive-fixnump (x)
  (declare lt:(side-effects simple reducible))
  (and (fixnump x) (plusp x)))

(defun non-negative-fixnump (x)
  (declare lt:(side-effects simple reducible))
  (and (fixnump x) (not (minusp x))))

(defun bigp (object)
  (declare lt:(side-effects simple reducible))
  #+3600
  (and (= (%data-type object) dtp-extended-number)
       (= (%p-ldb-offset %%header-subtype-field object 0) %header-type-bignum))
  #+IMACH
  (= (%data-type object) dtp-bignum))

#+3600(cl:proclaim '(cl:inline complexp))
(defun complexp (object)
  (declare lt:(side-effects simple reducible))
  #+3600
  (and (numberp object)
       (= (%numeric-dispatch-index object) %numeric-dispatch-index-complex))
  #+IMACH
  (type-member object dtp-complex))
#+3600(cl:proclaim '(cl:notinline complexp))

#+3600(cl:proclaim '(cl:inline realp))
(defun realp (object)
  (declare lt:(side-effects simple reducible))
  #+3600
  (and (numberp object)
       (not (= (%numeric-dispatch-index object) %numeric-dispatch-index-complex)))
  #+IMACH
  (type-member object dtp-fixnum dtp-bignum
		      dtp-single-float dtp-double-float
		      dtp-big-ratio dtp-small-ratio))
#+3600(cl:proclaim '(cl:notinline realp))

(defsubst not-complex-numberp (object)
  (realp object))

;;; Any non-immediate number
(defsubst extended-number-p (object)
  #+IMACH
  (type-member object dtp-big-ratio dtp-bignum dtp-complex dtp-double-float dtp-spare-number)
  #+3600
  (= (%data-type object) dtp-extended-number))

(defsubst stack-group-p (x)
  (and (arrayp x) (eq (named-structure-p x) 'stack-group)))

(defun typep (x &optional type &aux (dtp (%data-type x)))
  "(TYPEP x) => its type.  (TYPEP x y) => T if x is of type y"
  (declare lt:(side-effects simple reducible))
  (if type
      (let ((pred (or (get type 'typep) (car (rassq type typep-alist)))))
	(cond ((numberp pred) (= dtp pred))
	      (pred (funcall (fsymeval pred) x))
	      ((and (= dtp dtp-instance)
		    (get type 'flavor:flavor))
	       #+3600
	       (let ((fl (%p-contents-as-locative-offset x 0)))
		 (and (= (%p-data-type fl) dtp-header-i)
		      (= (%p-ldb-offset %%header-type-field fl 0) %header-type-array)
		      (eq (aref (setq fl (%make-pointer dtp-array fl)) 0) 'flavor:flavor)
		      (not (null (memq type (flavor:flavor-all-components fl))))))
	       #+IMACH
	       (let ((fl (%pointer-plus (%p-contents-as-locative-offset x 0) -3.)))
		 (and (= (%p-data-type fl) dtp-header-i)
		      (= (%p-ldb-offset %%header-type-field fl 0) %header-type-array)
		      (not (null (memq type (flavor:flavor-all-components
					      (%make-pointer dtp-array fl))))))))
	      ((and (= dtp dtp-instance)
		    (setq dtp
			  (if (symbolp type)
			      (clos:find-class type nil)
			      (and (instancep type)
				   type))))
	       #+3600
	       (let ((ii (%p-contents-as-locative-offset x 0)))
		 (and (= (%p-data-type ii) dtp-header-i)
		      (= (%p-ldb-offset %%header-type-field ii 0) %header-type-array)
		      (not (null (memq dtp (flavor:flavor-all-components
					     (%make-pointer dtp-array ii)))))))
	       #+IMACH
	       (let ((ii (%pointer-plus (%p-contents-as-locative-offset x 0) -3.)))
		 (and (= (%p-data-type ii) dtp-header-i)
		      (= (%p-ldb-offset %%header-type-field ii 0) %header-type-array)
		      (not (null (memq dtp (flavor:flavor-all-components
					      (%make-pointer dtp-array ii))))))))
	      ((and (arrayp x)
		    (setq pred (get type 'defstruct-description))
		    (defstruct-description-named-p pred))
	       (do ((symbol (named-structure-p x)
			    (and (setq pred (get symbol 'defstruct-description))
				 (car (defstruct-description-include pred)))))
		   ((null symbol) nil)
		 (and (eq type symbol) (return t))))
	      ((or (get type 'flavor:flavor)
		   (and (setq pred (get type 'defstruct-description))
			(defstruct-description-named-p pred)))
	       nil)
	      (t (ferror "~S is not a type known to TYPEP" type))))
      (cond ((= dtp dtp-instance)
	     (let ((class-or-flavor (flavor-name (%instance-flavor x))))
	       (if (cl:typep class-or-flavor 'symbol)
		   class-or-flavor		;It's a Flavor
		   (clos-internals:class-name-for-type-of class-or-flavor))))
	    ((= dtp dtp-array)
	     (cond ((named-structure-p x))
		   ((stringp x) ':string)
		   (t ':array)))
	    #+3600
	    ((= dtp dtp-extended-number) 
	     (select (%p-ldb-offset %%header-subtype-field x 0)
	       (%header-type-bignum ':bignum)
	       (%header-type-rational ':rational)
	       (%header-type-complex ':complex)
	       (%header-type-double ':double-float)
	       (otherwise ':random)))
	    #+IMACH
	    ((typep x :rational) ':rational)
	    ((= dtp dtp-lexical-closure)
	     (select (lexical-closure-subtype x)
	       (lexical-closure-subtype-lexical-closure :lexical-closure)
	       (lexical-closure-subtype-funcallable-instance :funcallable-instance)
	       (otherwise :random)))
	    ((cdr (assq dtp typep-alist)))
	    (t ':random))))

;;; These next two functions get called by compiler optimization of calls to ZL:TYPEPD,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI") --
0;;;    If you change either of these functions, be sure to change their CL equivalents
;;;    which follow immediately in this source file.
(defun typep-structure (x type &aux xname d)
  (cond ((setq xname (named-structure-p x))
	 (do () ((eq xname type) t)
	   (or (and (setq d (get xname 'defstruct-description))
		    (defstruct-description-named-p d)
		    (setq xname (car (defstruct-description-include d))))
	       (return nil))))
	((and (setq d (get type 'defstruct-description))
	      (defstruct-description-named-p d)
	      (not (and (= (%data-type x) dtp-instance)
			(get type 'flavor:flavor))))
	 nil)
	(t (typep x type))))			;Optimization turned out to be wrong

(defun typep-flavor (object type)
  (cond ((instancep object)
	 (if (cl:member type (flavor:flavor-all-components (%instance-flavor object))) t nil))
	((cl:getf (symbol-property-cell type) 'flavor:flavor) nil)
	(t (typep object type))))		;Optimization turned out to be wrong

;;; These next two functions get called by compiler optimization of calls to CL:TYPEP1 --
0;;;    If you change either of these functions, be sure to change their ZL equivalents
;;;    which preceed immediately in this source file.
(defun cli::typep-structure (x type &aux xname d)
  (cond ((setq xname (named-structure-p x))
	 (do () ((eq xname type) t)
	   (or (and (setq d (get xname 'defstruct-description))
		    (defstruct-description-named-p d)
		    (setq xname (car (defstruct-description-include d))))
	       (return nil))))
	((and (setq d (get type 'defstruct-description))
	      (defstruct-description-named-p d)
	      (not (and (= (%data-type x) dtp-instance)
			(get type 'flavor:flavor))))
	 nil)
	(t (cl:typep x type))))			;Optimization turned out to be wrong

(defun cli::typep-flavor (object type)
  (cond ((instancep object)
	 (if (cl:member type (flavor:flavor-all-components (%instance-flavor object))) t nil))
	((cl:getf (symbol-property-cell type) 'flavor:flavor) nil)
	(t (cl:typep object type))))		;Optimization turned out to be wrong

(defsubst subrp (x)
  (declare (compiler:do-not-record-macroexpansions))
  (= (%data-type x) dtp-compiled-function))

;T if X is something that can be applied to arguments,
;but abstract objects and stack groups are excluded
;because they are not normally thought of as functions
;even though they interface like functions.
;If ALLOW-SPECIAL-FORMS is NIL, this is only true of real functions.
;Otherwise it is also true of macros and special-form functions.
(2 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB");;; Warning:  If you patch FUNCTIONP, then you must also do (CLRHASH DW::*PREDICATE-CACHE*),
;;; since that caches the value of its function cell.
0(defun functionp (x &optional allow-special-forms)
  (declare lt:(side-effects simple))
  (prog (prev-x oddp)
     recursive-functionp
	(return 
	  (select (%data-type x)
	    (dtp-compiled-function
	     (or allow-special-forms
		 (not (ldb-test %%arg-desc-quoted (%args-info x)))))
	    (dtp-list
	     (labels ((real-list-p (list)
			;; Using LAST is faster than looping ourselves.  This works
			;; because (LAST '(A B . C)) ==> (B . C)
			(null (cdr (last list))))
		      (valid-lambda-list (list)
			(loop for l = list then (cdr l)
			      doing
			  (cond ((null l)
				 (return t))
				((atom l)
				 (return nil))
				((eq (car l) '&quote)
				 (return allow-special-forms))))))
	       (if (interpreted-lambda-p x)
		   (and (not (null (cdr x)))	;faster than (> (LENGTH X) 1) for long X
			(real-list-p x)
			(valid-lambda-list (car (interpreted-lambda-lambda-list-and-body x))))
		   (selectq (car x)
		     ((special macro)
		      (and allow-special-forms
			   (real-list-p x)))
		     ((digested-lambda)		;do the slowest cases last...
		      (digested-lambda-p x))
		     (otherwise
		      (if (lambda-macro-call-p x)
			  (progn (setq oddp (not oddp))
				 (when oddp (setq prev-x x))
				 (setq x (lambda-macro-expand x))
				 (unless (equal x prev-x)
						;yes, equal, in case we alternate lambda macros with symbols
				   (go recursive-functionp)))
			  nil))))))
	    ((#+3600 dtp-closure #+IMACH dtp-dynamic-closure dtp-lexical-closure dtp-generic-function)
	     t)
	    (dtp-symbol
	     (cond ((not (fboundp x)) nil)
		   ((arrayp (symbol-function-cell x)) t)
		   (t (progn (setq oddp (not oddp))
			     (when oddp (setq prev-x x))
			     (setq x (fsymeval x))
			     (unless (equal x prev-x)
						;yes, equal, in case we alternate lambda macros with symbols
			       (go recursive-functionp))))))))))

(defun future-common-lisp:functionp (x)
  #+IMACH (sys:type-member x sys:dtp-compiled-function sys:dtp-dynamic-closure
			   sys:dtp-lexical-closure sys:dtp-generic-function)
  #+3600 (scl:select (sys:%data-type x)
	   ((sys:dtp-compiled-function sys:dtp-closure sys:dtp-lexical-closure
				       sys:dtp-generic-function)
	    t)))


;; These definitions are for the evaluator.
;; "Real" definitions in SYS:COMPILER;OPTIMIZE.LISP.

(defun %fixnum-floor (x y)
  (declare lt:(side-effects simple reducible))
  (floor x y))

(defun %fixnum-ceiling (x y)
  (declare lt:(side-effects simple reducible))
  (ceiling x y))

(defun %fixnum-mod (x y)
  (declare lt:(side-effects simple reducible))
  (mod x y))

(defun %fixnum-multiply (x y &optional (background 0))
  (declare lt:(side-effects simple reducible))
  (+ (* x y) background))

(defsubst non-negative-fixnum (x)
  (logxor x (dpb (ldb (byte 1 31.) x) (byte 31. 0) x)))

(defsubst fixnum-multiply-by-prime (x)
  ;; 2^17 - 1 is a (Mersenne) prime.  It's too bad this code uses 2^15-1, which isn't.
  (%32-bit-difference (rot x 17) x))

#||
(defmacro non-negative-fixnum (x)
  (once-only (x)
    `(if (minusp ,x) (logxor ,x -17777777777) ,x)))	;-17777777777 = 20000000001

;;; this is used to spread consecutive values, which might otherwise clog things up
(defmacro fixnum-multiply-by-prime (x)
  ;; 2^17 - 1 is a (Mersenne) prime
  (once-only (x)
    `(%32-bit-difference (rot ,x 17) ,x)))
||#

;This always returns a positive fixnum.  The order of COND clauses is carefully
;chosen to make the most common and important cases fast.  There is duplicated
;code in this function for the same reason.  Two things with the same printed
;representation will get the same sxhash, even in different system incarnations.
;Nothing is guaranteed about the relation between sxhash of a list and sxhash
;of subparts of that list; this is exploited to bum a little extra speed.
(defun sxhash (object)
  (declare lt:(side-effects reducible))
  (cond ((symbolp object) (sxhash-string (get-pname object)))
	((stringp object) (sxhash-string object))
	((fixnump object)
	 ;; offset it so that 0 doesn't hash to 0
	 (non-negative-fixnum (%32-bit-plus (fixnum-multiply-by-prime object) 31.)))
	((listp object)		;Rotate car by 11. and cdr by 7, but do it efficiently
	 (do ((rot 4) (hash 0) y)
	     ((atom object)
	      (or (null object) (setq hash (logxor (rot (sxhash object) (- rot 4)) hash)))
	      (non-negative-fixnum hash))
	   (setq y (car object) object (cdr object))
	   ;(OR (< (SETQ ROT (+ ROT 7)) 32.) (SETQ ROT (- ROT 32.)))
	   (setq rot (ldb (byte 5 0) (+ rot 7)))	;rot = mod(rot+7,32)
	   (setq hash (logxor (rot (cond ((symbolp y) (sxhash-string (get-pname y)))
					 ((stringp y) (sxhash-string y))
					 ((typep y ':fixnum) (%32-bit-plus y 13.))
					 (t (sxhash y)))
				   rot)
			      hash))))
	((fixp object) (logxor (ldb (byte 01 37) object) (ldb (byte 37 00) object)))	;Bignum
	((single-float-p object)
	 ;; offset it so that 0.0 doesn't hash to 0
	 (non-negative-fixnum (%32-bit-plus (%fixnum object) 89.)))
	((double-float-p object)
	 ;; offset it so that 0.0d0 doesn't hash to 0
	 (non-negative-fixnum (%32-bit-plus (logxor (double-high object)
						    (double-low object))
					    107.)))
	((rationalp object) (logxor (sxhash (rational-numerator object))
			       (sxhash (rational-denominator object))))
	((characterp object) (non-negative-fixnum (sxhash-character object)))
	((complexp object)
	 ;; do something so it's not commutative and #c(OBJECT OBJECT) doesn't hash to 0
	 (logxor (sxhash (complex-realpart object))
		 (non-negative-fixnum (rot (sxhash (complex-imagpart object)) 7))))
	(t 0)))

;; This is sort of like SXHASH, but reverts to %POINTER for wierd data types.
;; Returns a second value of T if the value depends on the GC generation.
(defun equal-hash (x &aux (val nil) flag)
 (declare (values hash dependence-on-address))
 (values
  (cond ((symbolp x) (sxhash-string (get-pname x)))
	((stringp x) (sxhash-string x))
	((fixnump x)
	 ;; offset it so that 0 doesn't hash to 0
	 (non-negative-fixnum (%32-bit-plus (fixnum-multiply-by-prime x) 31.)))
	((listp x)		;Rotate car by 11. and cdr by 7, but do it efficiently
	 (do ((rot 4) (hash 0) y)
	     ((atom x)
	      (or (null x)
		  (setq hash (logxor (rot (prog1 (multiple-value (nil flag)
						   (equal-hash x))
						 (and flag (setq val t)))
					  (- rot 4))
				     hash)))
	      (non-negative-fixnum hash))
	   (setq y (car x) x (cdr x))
	   ;(OR (< (SETQ ROT (+ ROT 7)) 32.) (SETQ ROT (- ROT 32.)))
	   (setq rot (ldb (byte 5 0) (+ rot 7)))	;rot = mod(rot+7,32)
	   (setq hash (logxor (rot (cond ((symbolp y) (sxhash-string (get-pname y)))
					 ((stringp y) (sxhash-string y))
					 ((fixnump y) (%32-bit-plus y 13.))
					 (t (prog1 (multiple-value (nil flag)
						     (equal-hash y))
						   ;; T strongest, :DYNAMIC next, do it fast
						   (setq val (or (eq flag 't) val flag)))))
				   rot)
			      hash))))
	((fixp x) (logxor (ldb (byte 01 37) x) (ldb (byte 37 00) x)))	;Bignum
	((single-float-p x)
	 ;; offset it so that 0.0 doesn't hash to 0
	 (non-negative-fixnum (%32-bit-plus (%fixnum x) 89.)))
	((double-float-p x)
	 ;; offset it so that 0.0d0 doesn't hash to 0
	 (non-negative-fixnum (%32-bit-plus (logxor (double-high x)
						    (double-low x))
					    107.)))
	((rationalp x) (logxor (equal-hash (rational-numerator x))
			       (equal-hash (rational-denominator x))))
	((characterp x) (non-negative-fixnum (sxhash-character x)))
	((complexp x)
	 ;; do something so it's not commutative and #c(X X) doesn't hash to 0
	 (logxor (equal-hash (complex-realpart x))
		 (non-negative-fixnum (rot (equal-hash (complex-imagpart x)) 7))))
	(t (setq val (or (%ephemeralp x) ':dynamic))
	   (%pointer x)))
  val))


;; The value here gets modified by REDEFINE-GC-OPTIMIZATION-1.
;; Normally I wouldn't advocate having this as a constant, but we're talking
;; about the cold loader here.
(defvar *immediate-gc-mode-optimization-alist*
	'((:normal)
	  (:cleanup)
	  (:layered-ids-release)
	  (:layered-system-release)
	  (si:symbolics-system-release)))

(defvar *all-gc-optimizations* nil)

;; This is here rather than in FULL-GC so that DEFINE-GC-OPTIMIZATION works in the cold load.
(defun redefine-gc-optimization (name default-modes order doc)
  (cl:remprop name 'gc-optimization-before-flip)
  (cl:remprop name 'gc-optimization-after-flip)
  (cl:remprop name 'gc-optimization-after-reclaim-oldspace)
  (redefine-gc-optimization-1 name default-modes order doc))

;; This is also called by the cold load generator during bootstrapping.
(defun redefine-gc-optimization-1 (name default-modes order doc)
  (cl:pushnew name *all-gc-optimizations*)
  (if order
      (setf (get name 'gc-optimization-order) order)
      (cl:remprop name 'gc-optimization-order))
  (if doc
      (setf (get name 'gc-optimization-documentation) doc)
      (cl:remprop name 'gc-optimization-documentation))
  (loop for element in *immediate-gc-mode-optimization-alist*
	do (if (memq (car element) default-modes)
	       (cl:pushnew name (cdr element))
	       (setf (cdr element) (delq name (cdr element))))))
