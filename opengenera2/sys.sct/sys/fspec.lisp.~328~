;;; -*- Package:SYSTEM-INTERNALS; Mode:LISP; Base:8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Machine independent functions for handling function specs and function related things.
;;; This file is in the cold load.

;;; Function spec and source file name stuff
;;; (The rest of this is in QMISC)

;; A function-specifier is just a way of talking about a function
;; for purposes other than applying it.  It can be a symbol, in which case
;; the function cell of the symbol is used.  Or it can be a list of one of
;; these formats:
;; (:METHOD class-name operation) refers to the method in that class for
;;   that operation; this works for both Class methods and Flavor methods.
;;   In the case of Flavor methods, the specification may also be of the form
;;   (:METHOD flavor-name type operation).
;; (:HANDLER flavor operation) refers to the function that is called when
;;   an object of flavor FLAVOR is sent the message OPERATION.
;; (:WITHIN within-function renamed-function) refers to renamed-function,
;;   but only as called directly from within-function.
;;   Actually, renamed-function is replaced throughout within-function
;;   by an uninterned symbol whose definition is just renamed-function
;;   as soon as an attempt is made to do anything to a function spec
;;   of this form.  The function spec is from then on equivalent
;;   to that uninterned symbol.
;; (:PROPERTY symbol property) refers to (GET symbol property).
;; (:LOCATION locative-or-list-pointer) refers to the CDR of the pointer.
;;   This is for pointing at an arbitrary place
;;   which there is no special way to describe.
;; One place you can use a function specifier is in DEFUN.
;;
;; Or, it can be a flavor object itself, which is expected to handle the
;; :FUNCTION-SPEC-TYPE message, which provides a hook for extensible function spec
;; types (see the code).
;;
; For Maclisp compatibility, a list whose car is not recognized is taken
; to be a list of a symbol and a property, by DEFUN and DEFMACRO.  They
; standardize this by putting :PROPERTY on the front.  These
; non-standard function specs are not accepted by the rest of the
; system.  This is done to avoid ambiguities and inconsistencies.

;The SYS:FUNCTION-SPEC-HANDLER property of a symbol, if present means that that
;symbol is legal as the car of a function spec.  The value of the property
;is a function whose arguments are the function in behalf
;of which to act (not a keyword symbol!) and the arguments to that
;function (the first of which is always the function spec).
;Functions are:
;	FDEFINE definition
;	FDEFINEDP
;	FDEFINITION
;	FDEFINITION-LOCATION
;	DEFINITION-HAS-LOCATION-P
;	FORWARD-FUNCTION-CELL-INTO-COMPILED-FUNCTION-P
;	LOCATION-IS-FDEFINITION-LOCATION-P
;	FUNDEFINE
;	FUNCTION-PARENT
;	COMPILER-FDEFINEDP -- returns T if will be fdefinedp at run time
;	GET indicator
;	PUTPROP value indicator
;       PLIST retrieves the entire PLIST, which for some function specs
;             will also include things put on with regular PUTPROP.

(DEFVAR *ALL-FUNCTION-SPEC-HANDLERS* NIL
  "List of all defined function-spec symbols.")

;;; NIL, T, or :JUST-WARN
;;; This is obsolete, use the REDEFINITION condition instead.
(DEFVAR-RESETTABLE INHIBIT-FDEFINE-WARNINGS NIL)

(DEFVAR *DERIVED-FUNCTION-TYPES* NIL)
(DEFVAR *DERIVED-FUNCTION-CELL-LOCK* (PROCESS:MAKE-LOCK "Derived Function Cell Lock"))

;Predicate for use with CHECK-ARG
;Also returns the type keyword (T for a symbol)
(DEFUN VALIDATE-FUNCTION-SPEC (FUNCTION-SPEC &OPTIONAL NIL-ALLOWED &AUX HANDLER)
  (COND ((NULL FUNCTION-SPEC) NIL-ALLOWED)
	((SYMBOLP FUNCTION-SPEC) T)
	((AND (INSTANCEP FUNCTION-SPEC)		;Allow flavor instances as function specs
	      ;;(Sage uses it for making fraudulent-printing objects)
	      (SEND FUNCTION-SPEC ':SEND-IF-HANDLES ':FUNCTION-SPEC-TYPE)))
	((ATOM FUNCTION-SPEC) NIL)
	((AND (SYMBOLP (CAR FUNCTION-SPEC))
	      (SETQ HANDLER (GET (CAR FUNCTION-SPEC) 'FUNCTION-SPEC-HANDLER))
	      (FUNCALL HANDLER 'VALIDATE-FUNCTION-SPEC FUNCTION-SPEC))
	 (CAR FUNCTION-SPEC))))

(DEFUN FDEFINE (FUNCTION-SPEC DEFINITION &OPTIONAL CAREFULLY-FLAG NO-QUERY-FLAG
		&AUX TYPE INNER-SPEC (NO-CHANGE NIL))
  "Alter the function definition of a function specifier.
CAREFULLY-FLAG means preserve any tracing or advice,
and save the old definition, when possible.
This function returns T if it does define the function, or NIL if it does not.
If FDEFINE-FILE-PATHNAME is non-NIL, then it is the file which this definition
was read from, and we make a note of that fact when possible."

  ;; First, validate the function spec and determine its type
  (CHECK-ARG FUNCTION-SPEC
	     (SETQ TYPE (VALIDATE-FUNCTION-SPEC FUNCTION-SPEC))
	     "a symbol other than NIL or a function-spec list")
  
  (LET* ((UNENCAPSULATED-SPEC (UNENCAPSULATE-FUNCTION-SPEC FUNCTION-SPEC))
	 (UNENCAPSULATED-DEFINITION
	   (AND (FDEFINEDP UNENCAPSULATED-SPEC) (FDEFINITION UNENCAPSULATED-SPEC)))
	 (ENCAPSULATION-P (AND DEFINITION (FUNCTION-ENCAPSULATED-P DEFINITION)))
	 (UNENCAPSULATION-P
	   (AND DEFINITION (EQ UNENCAPSULATED-DEFINITION DEFINITION))))


    ;; Record the source file name, if desired, and check for redefinition errors
    (COND ((OR (EQ TYPE ':INTERNAL)
	       UNENCAPSULATION-P
	       (RECORD-SOURCE-FILE-NAME FUNCTION-SPEC
					(IF ENCAPSULATION-P 'ENCAPSULATION 'DEFUN)
					(OR NO-QUERY-FLAG (NOT CAREFULLY-FLAG)
					    (EQ INHIBIT-FDEFINE-WARNINGS T))))

	   ;; If there is a previous definition,
	   ;; and if it is encapsulated, set INNER-SPEC to the symbol
	   ;; which holds the real definition before encapsulation, and
	   ;; save that definition.
	   (COND ((AND CAREFULLY-FLAG (FDEFINEDP FUNCTION-SPEC))
		  ;; Carry over renamings from previous definition
		  (WHEN (VARIABLE-BOUNDP #'RENAME-WITHIN-NEW-DEFINITION-MAYBE)
		    (SETQ DEFINITION (RENAME-WITHIN-NEW-DEFINITION-MAYBE FUNCTION-SPEC
									 DEFINITION)))
		  ;; See if the unencapsulated definition is really changing.
		  ;; If so, save previous definition if any.
		  ;; If not, avoid duplicate who-calls entries.
		  (SETQ INNER-SPEC UNENCAPSULATED-SPEC)
		  (WHEN (FDEFINEDP INNER-SPEC)
		    (IF UNENCAPSULATION-P
			(SETQ NO-CHANGE T)
			(FUNCTION-SPEC-PUTPROP FUNCTION-SPEC
					       UNENCAPSULATED-DEFINITION
					       ':PREVIOUS-DEFINITION))))
		 ((FDEFINEDP FUNCTION-SPEC)
		  ;; See if the unencapsulated definition is really changing.
		  (WHEN ENCAPSULATION-P (SETQ NO-CHANGE T))
		  ;; Redefine the outer function spec
		  (SETQ INNER-SPEC FUNCTION-SPEC))
		 (T (SETQ INNER-SPEC FUNCTION-SPEC)))

	   ;; Now store the new definition in type-dependent fashion
	   (FDEFINE-INTERNAL INNER-SPEC DEFINITION TYPE)
	   
	   (UNLESS NO-CHANGE
	     (WHEN-IN-INCREMENTAL-WHO-CALLS-MODE
	       (WHO-CALLS-FDEFINE-HOOK FUNCTION-SPEC)))
	   
	   ;; Return T since we did define the function
	   T)
	  ;; Return NIL since we decided not to define the function
	  (T NIL))))

;; Switch to enable unlinking via Who-Calls, which is considered
;; too dangerous an option to offer by default for now.
(DEFVAR *ENABLE-WHO-CALLS-UNLINKING* NIL)

;; This is the layer between FDEFINE and the function-spec implementation which
;; hacks storage categories and function-cell forwarding.
(DEFUN FDEFINE-INTERNAL (FSPEC FUNC &OPTIONAL (TYPE (VALIDATE-FUNCTION-SPEC FSPEC)))
  (LET ((FORWARD-FUNCTION-CELL T)
	(FUNCTION-CELL-STORAGE-CATEGORY
	  (DECLARED-STORAGE-CATEGORY :FUNCTION-CELL FSPEC NIL))
	(OLD-FUNC (AND (FDEFINEDP FSPEC)
		       (FDEFINITION FSPEC)))
	(FUNCTION-STORAGE-CATEGORY (OR (FUNCTION-SPEC-GET FSPEC 'FUNCTION-STORAGE-CATEGORY)
				       (AND (TYPEP FUNC :COMPILED-FUNCTION)
					    (DECODE-STORAGE-CATEGORY-DEBUGGING-INFO
					      (COMPILED-FUNCTION-DEBUGGING-INFO FUNC))))))
    ;; Ensure the function is not linked
    #+IMACH
    (WHEN (AND OLD-FUNC
	       (NEQ OLD-FUNC FUNC)
	       (FUNCTION-LINKED-P OLD-FUNC))
      (SELECTQ (SIGNAL 'LINKED-FUNCTION-REDEFINITION
		       :FUNCTION-SPEC FSPEC
		       :OLD-FUNCTION OLD-FUNC
		       :NEW-FUNCTION FUNC
		       :PROCEED-TYPES (IF *ENABLE-WHO-CALLS-UNLINKING*
					  '(:UNLINK-OLD-FUNCTION
					     :UNLINK-OLD-FUNCTION-USING-WHO-CALLS
					     :UNLINK-ALL
					     :NO-ACTION)
					  '(:UNLINK-OLD-FUNCTION
					     :UNLINK-ALL
					     :NO-ACTION)))
	(:UNLINK-OLD-FUNCTION (CLI::UNLINK-TO-FUNCTIONS OLD-FUNC))
	(:UNLINK-OLD-FUNCTION-USING-WHO-CALLS
	 (CLI::UNLINK-TO-FUNCTIONS-USING-WHO-CALLS OLD-FUNC))
	(:UNLINK-ALL (CLI::UNLINK-TO-FUNCTIONS T))
	(:NO-ACTION)))
    ;; Check for a function-cell storage category different from the function itself.
    (WHEN (AND FUNCTION-CELL-STORAGE-CATEGORY
	       (STORAGE-CATEGORY-LESSP FUNCTION-STORAGE-CATEGORY
				       FUNCTION-CELL-STORAGE-CATEGORY))
      ;; The function cell must be specially forwarded.
      (SETQ FORWARD-FUNCTION-CELL NIL)		;don't reforward later.
      ;; If it's already forwarded to an acceptable cell, don't forward it again.
      (UNLESS (AND (NOT (STORAGE-CATEGORY-LESSP
			  (ACTUAL-STORAGE-CATEGORY :FUNCTION-CELL FSPEC)
			  FUNCTION-CELL-STORAGE-CATEGORY))
		   (NOT (TYPEP (%FIND-STRUCTURE-HEADER
				 (FOLLOW-CELL-FORWARDING (FDEFINITION-LOCATION FSPEC) NIL))
			       :COMPILED-FUNCTION)))
	;; Allocate a variable slot for it.
	(FORWARD-SYMBOL-CELL (FDEFINITION-LOCATION FSPEC) FUNCTION-CELL-STORAGE-CATEGORY)))
    ;; Check for redefinition to a lower storage category.
    ;;--- Don't issue a warning if the old definition was the (safeguarded) symbol IGNORE.
    ;;--- This is because everything in sight has it as a cold-load definition.
    (WHEN (AND OLD-FUNC
	       (STORAGE-CATEGORY-LESSP FUNCTION-STORAGE-CATEGORY
				       (ACTUAL-STORAGE-CATEGORY :CONSTANT OLD-FUNC))
	       (NEQ OLD-FUNC 'IGNORE))
      (LET ((COMPILER:DEFAULT-WARNING-FUNCTION FSPEC))
	(WARN "Function ~S is being redefined with ~A definition.~@
	     Its previous definition was ~A." FSPEC
	      (IF (MEMQ FUNCTION-STORAGE-CATEGORY '(NIL :UNSAFEGUARDED))
		  "an unsafeguarded" "a safeguarded")	;Can't be wired!
	      (STRING-DOWNCASE (ACTUAL-STORAGE-CATEGORY :CONSTANT OLD-FUNC)))))
    ;; Do the definition.
    (IF (SYMBOLP FSPEC)
	(LET ((LOC (FOLLOW-CELL-FORWARDING (FUNCTION-CELL-LOCATION FSPEC) NIL)))
	  #+3600
	  (COMPILER:%ERROR-WHEN (= (%LOGLDB %%VMA-EQUALS-AMEM (%POINTER LOC))
				   %VMA-EQUALS-AMEM)
	    (WHEN (STORAGE-CATEGORY-LESSP
		    (ACTUAL-STORAGE-CATEGORY :CONSTANT FUNC)
		    :SAFEGUARDED)
	      (ERROR "Attempt to define the a-memory function ~S~@
		      to be ~S,~%which is unsafeguarded."
		     FSPEC FUNC)))
	  (SETF (LOCATION-CONTENTS LOC) FUNC))
	(FUNCALL (GET TYPE 'FUNCTION-SPEC-HANDLER) 'FDEFINE FSPEC FUNC))
    ;; Do normal forwarding of function cells, if not handled specially above.
    (WHEN FORWARD-FUNCTION-CELL
      (IF (TYPEP FUNC :COMPILED-FUNCTION)
	  (FORWARD-FUNCTION-CELL-INTO-COMPILED-FUNCTION FSPEC)
	  (WHEN (AND OLD-FUNC (TYPEP OLD-FUNC :COMPILED-FUNCTION))
	    ;; Redefining a compiled function to be a non-compiled function.
	    ;; Unforward it from the compiled function so we can forward it properly
	    ;; to a forwarded table.
	    (UNFORWARD-FUNCTION-CELL FSPEC))
	  ;; Forward all non-compiled definitions of symbols into the forwarded symbol table.
	  (WHEN (SYMBOLP FSPEC)
	    (LET ((FCELL (FUNCTION-CELL-LOCATION FSPEC)))
	      (UNLESS (= (%P-DATA-TYPE (FUNCTION-CELL-LOCATION FSPEC)) DTP-ONE-Q-FORWARD)
		(FORWARD-SYMBOL-CELL FCELL))))))
    (FIXUP-REFERENCES-TO-NEW-FUNCTION-CELL FSPEC)))

;; Undo function for FDEFINE
(DEFUN (:PROPERTY FDEFINE :UNDO-FUNCTION) (FORM)
  (LET ((FUNCTION-SPEC (EVAL (CADR FORM))))
    (UNDO-FUNCTION-DEFINITION FUNCTION-SPEC)))

;; Is a function specifier defined?  A generalization of FBOUNDP.
(DEFUN FDEFINEDP (FUNCTION-SPEC &AUX TYPE)
  "Returns T if the function spec has a function definition."
  (DECLARE LT:(SIDE-EFFECTS READER))
  ;; First, validate the function spec and determine its type
  ;; If the argument is NIL, must return NIL rather than erring, since it's a symbol
  (CHECK-ARG FUNCTION-SPEC
	     (SETQ TYPE (VALIDATE-FUNCTION-SPEC FUNCTION-SPEC T))
	     "a symbol or a function-spec list")
  ;; Then perform type-dependent code
  (IF (SYMBOLP FUNCTION-SPEC) (FBOUNDP FUNCTION-SPEC)
      (NOT (NULL (FUNCALL (GET TYPE 'FUNCTION-SPEC-HANDLER) 'FDEFINEDP FUNCTION-SPEC)))))

(DEFSUBST FUTURE-COMMON-LISP:FBOUNDP (FUNCTION-NAME)
  (FDEFINEDP FUNCTION-NAME))

(DEFSUBST FUTURE-COMMON-LISP:FMAKUNBOUND (FUNCTION-NAME)
  (FUNDEFINE FUNCTION-NAME))

(DEFUN (FUTURE-COMMON-LISP:SETF FUTURE-COMMON-LISP:FDEFINITION)
       (NEW-DEFINITION FUNCTION-NAME)
  (SYS:FDEFINE FUNCTION-NAME NEW-DEFINITION T)
  NEW-DEFINITION)

;; Get the definition of a function specifier.  Generalized FSYMEVAL.
(DEFUN FDEFINITION (FUNCTION-SPEC &AUX TYPE)
  "Returns the function definition of a function spec"
  (DECLARE LT:(SIDE-EFFECTS READER))
  ;; First, validate the function spec and determine its type
  (CHECK-ARG FUNCTION-SPEC
	     (SETQ TYPE (VALIDATE-FUNCTION-SPEC FUNCTION-SPEC))
	     "a symbol or a function-spec list")
  (IF (SYMBOLP FUNCTION-SPEC) (FSYMEVAL FUNCTION-SPEC)
      (FUNCALL (GET TYPE 'FUNCTION-SPEC-HANDLER) 'FDEFINITION FUNCTION-SPEC)))

;; This is a combination of FDEFINEDP and FDEFINITION, which is faster than the
;; common case of calling them both
(DEFUN VALID-FUNCTION-DEFINITION (FUNCTION-SPEC &OPTIONAL FUNCTION-OK &AUX TYPE)
  "Returns the definition of a function spec iff it is valid, otherwise returns NIL."
  (DECLARE LT:(SIDE-EFFECTS READER))
  (IF (AND FUNCTION-OK (TYPEP FUNCTION-SPEC :COMPILED-FUNCTION))
      FUNCTION-SPEC
    (WHEN (SETQ TYPE (VALIDATE-FUNCTION-SPEC FUNCTION-SPEC))
      (IF (SYMBOLP FUNCTION-SPEC)
	  (AND (FBOUNDP FUNCTION-SPEC) (FSYMEVAL FUNCTION-SPEC))
	(LET ((HANDLER (GET TYPE 'FUNCTION-SPEC-HANDLER)))
	  (AND (NOT (NULL (FUNCALL HANDLER 'FDEFINEDP FUNCTION-SPEC)))
	       (FUNCALL HANDLER 'FDEFINITION FUNCTION-SPEC)))))))

;; Given a function spec, return a function spec which is defined.
;; This will signal UNDEFINED-FUNCTION if the function spec is undefined,
;; and will then act according to the proceed types given.
(DEFUN GET-DEFINED-FUNCTION-SPEC (FSPEC)
  (DECLARE (DBG:ERROR-REPORTER))
  (IF (AND (SYMBOLP FSPEC) (FBOUNDP FSPEC))
      FSPEC					;Fast and cheap
    (CHECK-ARG FSPEC
	       (VALIDATE-FUNCTION-SPEC FSPEC)
	       "a symbol or a function-spec list")
    (LOOP UNTIL (FDEFINEDP FSPEC)
	  DO (SIGNAL-PROCEED-CASE ((VALUE) 'UNDEFINED-FUNCTION-SPEC ':FUNCTION-NAME FSPEC)
	       (:NEW-FUNCTION-SPEC (SETQ FSPEC VALUE))
	       (:STORE-NEW-VALUE (RETURN (FDEFINE FSPEC VALUE T)))))
    FSPEC))

(COMPILER:MAKE-OBSOLETE FSET-CAREFULLY "use FDEFINE instead")
;;; This is an old name for FDEFINE which everyone uses.
(DEFUN FSET-CAREFULLY (FUNCTION-SPEC DEFINITION &OPTIONAL NO-QUERY-FLAG)
  (FDEFINE FUNCTION-SPEC DEFINITION T NO-QUERY-FLAG))

;;; A table associating from property name to
;;;    a table associating from function-spec to property value.
;;; This is setup by QLD as soon as everything it will need is loaded in and pathnames work
;;; and so on.
(DEFVAR *FUNCTION-SPEC-HASH-TABLES* NIL)
;;; In the meantime, and from the cold load, this remembers non symbol source files,
;;; elements are (function-spec indicator value).
(DEFVAR COLD-LOAD-FUNCTION-PROPERTY-LISTS)

;Default handler called by function-spec-handlers to do functions they don't
;handle specially.
(DEFUN FUNCTION-SPEC-DEFAULT-HANDLER (FUNCTION FUNCTION-SPEC &REST ARGS)
  (SCL:DESTRUCTURING-BIND (&OPTIONAL ARG1 ARG2 . NIL) ARGS
    (SELECTQ FUNCTION
      (DEFINITION-HAS-LOCATION-P NIL)	    ;Default is not to rely on FDEFINITION-LOCATION
      (FORWARD-FUNCTION-CELL-INTO-COMPILED-FUNCTION-P
       (DEFINITION-HAS-LOCATION-P FUNCTION-SPEC))	;Default is whether there is a location
      (LOCATION-IS-FDEFINITION-LOCATION-P
       (AND (DEFINITION-HAS-LOCATION-P FUNCTION-SPEC)
	    (EQ (FDEFINITION-LOCATION FUNCTION-SPEC) ARG1)))
      (FUNCTION-PARENT NIL)		    ;Default is no embedding in other definitions
      (COMPILER-FDEFINEDP NIL)		    ;Default is no remembering of compiled definitions
      (GET (IF *FUNCTION-SPEC-HASH-TABLES*  ;Default is to use plist hash table
	       (LET ((TABLE (GETHASH ARG1 *FUNCTION-SPEC-HASH-TABLES*)))
		 (AND TABLE (GETHASH FUNCTION-SPEC TABLE)))
	       (LOOP FOR (FS IND PROP) IN COLD-LOAD-FUNCTION-PROPERTY-LISTS
		     WHEN (AND (EQUAL FS FUNCTION-SPEC) (EQ IND ARG1))
		       RETURN PROP)))
      (PLIST (FUNCTION-SPEC-PLIST-1 FUNCTION-SPEC))
      (PUTPROP (IF *FUNCTION-SPEC-HASH-TABLES*
		   (LET ((TABLE (GETHASH ARG2 *FUNCTION-SPEC-HASH-TABLES*)))
		     (UNLESS TABLE
		       (SETF (GETHASH ARG2 *FUNCTION-SPEC-HASH-TABLES*)
			     (SETQ TABLE (CL:MAKE-HASH-TABLE :TEST #'CL:EQUAL))))
		     (SETF (GETHASH FUNCTION-SPEC TABLE) ARG1))
		   (PUSH (LIST FUNCTION-SPEC ARG2 ARG1) COLD-LOAD-FUNCTION-PROPERTY-LISTS)))
      (REMPROP (IF *FUNCTION-SPEC-HASH-TABLES*
		   (LET ((TABLE (GETHASH ARG1 *FUNCTION-SPEC-HASH-TABLES*)))
		     (AND TABLE (REMHASH FUNCTION-SPEC TABLE)))
		   (SETQ COLD-LOAD-FUNCTION-PROPERTY-LISTS
			 (DEL-IF #'(LAMBDA (X)
				     (AND (EQUAL (CAR X) FUNCTION-SPEC)
					  (EQUAL (CADR X) ARG1)))
				 COLD-LOAD-FUNCTION-PROPERTY-LISTS))))
      (OTHERWISE (FERROR "~S is not implemented by the function spec ~S"
			 FUNCTION FUNCTION-SPEC)))))

;; (:PROPERTY symbol property) refers to (GET symbol property).
;; The compiler / cold load generator handle (:property ...) just fine.

(DEFINE-FUNCTION-SPEC-HANDLER :PROPERTY (FUNCTION FUNCTION-SPEC &OPTIONAL ARG1 ARG2)
  (LET* ((VALID (NULL (CDR (LAST FUNCTION-SPEC))))
	 (SYMBOL (AND VALID (SECOND FUNCTION-SPEC)))
	 (INDICATOR (AND VALID (THIRD FUNCTION-SPEC))))
    (SELECTQ FUNCTION
      (VALIDATE-FUNCTION-SPEC (AND VALID (= (LENGTH FUNCTION-SPEC) 3) (SYMBOLP SYMBOL)))
      (FDEFINE (PUTPROP SYMBOL ARG1 INDICATOR))
      ((FDEFINITION FDEFINEDP) (GET SYMBOL INDICATOR))
      (FDEFINITION-LOCATION ;Compiler doesn't need this by special dispensation.
       (FERROR "Properties have no fixed location.
It is not possible to get the FDEFINITION-LOCATION of ~S." FUNCTION-SPEC))
      (FUNDEFINE (SI:NREMPROP SYMBOL INDICATOR))
      (OTHERWISE (FUNCTION-SPEC-DEFAULT-HANDLER FUNCTION FUNCTION-SPEC ARG1 ARG2)))))

(DEFUN FUNCTION-SPEC-PUTPROP (FUNCTION-SPEC VALUE INDICATOR &AUX TYPE)
  (CHECK-ARG FUNCTION-SPEC
	     (SETQ TYPE (VALIDATE-FUNCTION-SPEC FUNCTION-SPEC T))
	     "a symbol or a function-spec list")
  (IF (SYMBOLP FUNCTION-SPEC)
      (PUTPROP FUNCTION-SPEC VALUE INDICATOR)
    (FUNCALL (GET TYPE 'FUNCTION-SPEC-HANDLER) 'PUTPROP FUNCTION-SPEC VALUE INDICATOR)))

(DEFUN FUNCTION-SPEC-GET (FUNCTION-SPEC INDICATOR &OPTIONAL CHASE-PARENTS &AUX TYPE)
  (CHECK-ARG FUNCTION-SPEC
	     (SETQ TYPE (VALIDATE-FUNCTION-SPEC FUNCTION-SPEC T))
	     "a symbol or a function-spec list")
  ;; This is a pretty common thing to want to do, so abstract it here
  (WHEN CHASE-PARENTS
    (LOOP FOR PARENT = FUNCTION-SPEC THEN NEXT-PARENT
	  AS NEXT-PARENT = (FUNCTION-PARENT PARENT 'DEFUN)
	  UNTIL (OR (NULL NEXT-PARENT)
		    (EQ PARENT NEXT-PARENT))
	  FINALLY (SETQ FUNCTION-SPEC PARENT)
		  (SETQ TYPE (VALIDATE-FUNCTION-SPEC FUNCTION-SPEC T))))
  (IF (SYMBOLP FUNCTION-SPEC)
      (GET FUNCTION-SPEC INDICATOR)
    (FUNCALL (GET TYPE 'FUNCTION-SPEC-HANDLER) 'GET FUNCTION-SPEC INDICATOR)))

(DEFUN FUNCTION-SPEC-PLIST-1 (FUNCTION-SPEC)
  (IF *FUNCTION-SPEC-HASH-TABLES*
      (LOOP FOR TABLE BEING THE HASH-ELEMENTS OF *FUNCTION-SPEC-HASH-TABLES*
		      WITH-KEY PROPERTY WITH (VALUE FOUND)
	    DO (MULTIPLE-VALUE (VALUE FOUND) (CL:GETHASH FUNCTION-SPEC TABLE))
	    WHEN FOUND
	      APPEND (LIST PROPERTY VALUE))
      (LOOP FOR (FS IND PROP) IN COLD-LOAD-FUNCTION-PROPERTY-LISTS
	    WHEN (EQUAL FS FUNCTION-SPEC)
	      APPEND (LIST IND PROP))))

(DEFUN FUNCTION-SPEC-PLIST (FUNCTION-SPEC)
  (LET ((TYPE NIL))
    (CHECK-ARG FUNCTION-SPEC
	       (SETQ TYPE (VALIDATE-FUNCTION-SPEC FUNCTION-SPEC T))
	       "a symbol or a function-spec list")
    (IF (SYMBOLP FUNCTION-SPEC)
	(PLIST FUNCTION-SPEC) ;; gets any other properties, too. Too bad.
      (FUNCALL (GET TYPE 'FUNCTION-SPEC-HANDLER) 'PLIST FUNCTION-SPEC))))

(DEFUN FUNCTION-SPEC-REMPROP (FUNCTION-SPEC INDICATOR &AUX TYPE)
  (CHECK-ARG FUNCTION-SPEC
	     (SETQ TYPE (VALIDATE-FUNCTION-SPEC FUNCTION-SPEC T))
	     "a symbol or a function-spec list")
  (IF (SYMBOLP FUNCTION-SPEC)
      (SI:NREMPROP FUNCTION-SPEC INDICATOR)
    (FUNCALL (GET TYPE 'FUNCTION-SPEC-HANDLER) 'REMPROP FUNCTION-SPEC INDICATOR)))

(DEFPROP FUNCTION-SPEC-GET ((FUNCTION-SPEC-GET FUNCTION-SPEC INDICATOR) .
			    (FUNCTION-SPEC-PUTPROP FUNCTION-SPEC VAL INDICATOR))
	 SETF)

(SETQ FS:THIS-IS-A-PATCH-FILE NIL)	;For the cold load

;;; When this variable is bound, RECORD-SOURCE-FILE-NAME assumes that it is being called
;;; inside of a LOADING-FILE special form (meaning that an entire file is being loaded as
;;; opposed to small number of definitions from the interpreter or the editor). Only the
;;; loading-file special form should bind this variable.
(DEFVAR FDEFINE-FILE-DEFINITIONS)
(DEFVAR FDEFINE-FILE-DISAPPEARING-DEFINITIONS NIL)
(DEFVAR FDEFINE-FILE-APPEARING-DEFINITIONS NIL)

(DEFCONST *SOURCE-FILE-TYPES-WHICH-MAY-APPEAR-MORE-THAN-ONCE*
	  '(COMPILER:DEFOPTIMIZER COMPILER:DEFTRANSFORMER
	    #+3600 L-LISP-COMPILER:DEFOPTIMIZER
	    #+3600 L-LISP-COMPILER:DEFTRANSFORMER
	    #+IMach I-LISP-COMPILER::DEFOPTIMIZER
	    #+IMach I-LISP-COMPILER::DEFTRANSFORMER
	    SPECIAL ZL:UNSPECIAL LT::SPECIAL-VARIABLE-DATA-TYPE SI:ENCAPSULATION
	    NET:DEFINE-PROTOCOL
	    ))

(DEFUN LOADING-FILE-HANDLE-DEFINITION-CHANGES (GENERIC CURRENT DISAPPEARING APPEARING)
  (IGNORE APPEARING DISAPPEARING)
  (COMPILER:PURGE-FILE-DECLARATIONS GENERIC)
  ;; Warn about duplicate definitions
  (WHEN (LOOP FOR (TYPE . NAMES) IN CURRENT
	      THEREIS
		(AND (NOT (MEMQ TYPE *SOURCE-FILE-TYPES-WHICH-MAY-APPEAR-MORE-THAN-ONCE*))
		     (LOOP FOR (NAME . REST) ON NAMES
			   THEREIS (MEMBER NAME REST))))
    (COMPILER:COMPILER-WARNINGS-CONTEXT-BIND	;Make sure warning is associated with file
      (LOOP FOR (TYPE . NAMES) IN CURRENT DO
	(WHEN (NOT (MEMQ TYPE *SOURCE-FILE-TYPES-WHICH-MAY-APPEAR-MORE-THAN-ONCE*))
	  (LOOP FOR (NAME . REST) ON NAMES
		WITH MENTIONED = NIL DO
	    (UNLESS (MEMBER NAME MENTIONED)
	      (WHEN (MEMBER NAME REST)
		(STACK-LET ((OPTIONS `(:FUNCTION ,NAME :DEFINITION-TYPE ,TYPE)))
		  (COMPILER:WARN OPTIONS
				 "~A ~S is defined ~[~2;twice~:;~:*~D times~] in the file ~A."
				 (OR (GET TYPE 'DEFINITION-TYPE-NAME) TYPE)
				 NAME
				 (1+ (LOOP FOR OTHER IN REST
					   COUNT (EQUAL OTHER NAME)))
				 GENERIC))
		(PUSH NAME MENTIONED)))))))))

(DEFVAR *UPDATE-TYPES-INCREMENTALLY* NIL)

;;; See comment before RECORD-SOURCE-FILE-NAME
(DEFVAR *RECORD-SOURCE-FILE-NAME-HOOKS* NIL
  "A list of functions to be called whenever record-source-file-name
is called. They are called with the same arguments as record-source-file-name.")

;;; RECORD-SOURCE-FILE-NAME-1/2 are split off like this to make record-source-file-name
;;; look better and for the benefit of canonicalize-cold-load-pathnames. Remember not to
;;; put these after the definition of RECORD-SOURCE-FILE-NAME.
(DEFUN RECORD-SOURCE-FILE-NAME-1 (FSPEC TYPE PATHNAME &OPTIONAL (PROPERTY PATHNAME))
  (LOOP FOR HOOK IN *RECORD-SOURCE-FILE-NAME-HOOKS* DO
    (FUNCALL HOOK FSPEC TYPE PATHNAME PROPERTY))
  (FUNCTION-SPEC-PUTPROP FSPEC PROPERTY ':SOURCE-FILE-NAME)  
  (COND ((VARIABLE-BOUNDP FDEFINE-FILE-DEFINITIONS)
	 ;; We are loading a whole file, this means that fdefine-file-definitons
	 ;; is bound to the file's definitions alist, so we don't have to do the
	 ;; :get and :putprop. It also means that we must update the disappearing
	 ;; and appearing definitions structures.
	 (ADD-TO-ALIST FDEFINE-FILE-DEFINITIONS TYPE FSPEC ASSQ NIL)
	 (LET* ((ALIST (ASSQ TYPE FDEFINE-FILE-DISAPPEARING-DEFINITIONS))
		(DISAPPEARING-TAIL (MEMBER FSPEC (CDR ALIST))))
	   (IF (NOT DISAPPEARING-TAIL)
	       (ADD-TO-ALIST FDEFINE-FILE-APPEARING-DEFINITIONS TYPE FSPEC ASSQ NIL)
	       (IF (EQ DISAPPEARING-TAIL (CDR ALIST))
		   (RPLACD ALIST (CDDR ALIST))
		   (RPLACA DISAPPEARING-TAIL (CADR DISAPPEARING-TAIL))
		   (RPLACD DISAPPEARING-TAIL (CDDR DISAPPEARING-TAIL))))))
	((INSTANCEP PATHNAME)			;This check is required because this code
						;is called before pathnames are instances.
	 (RECORD-SOURCE-FILE-NAME-2 FSPEC TYPE (SEND PATHNAME :GENERIC-PATHNAME)))))

(DEFUN RECORD-SOURCE-FILE-NAME-2 (FSPEC TYPE GENERIC)
  (LET ((DEFINITIONS (SEND GENERIC :GET 'SI:DEFINITIONS)))
    (ADD-TO-ALIST DEFINITIONS TYPE FSPEC ASSQ MEMBER)
    (SEND GENERIC :PUTPROP DEFINITIONS 'SI:DEFINITIONS)))
						
;;; RECORD-SOURCE-FILE-NAME maintains the :SOURCE-FILE-NAME property of function-specs
;;; and the SI:DEFINITIONS property of generic pathnames. RECORD-SOURCE-FILE-NAME should
;;; be called whenever a function-spec is defined, the value returned indicates whether
;;; or not it is ok to go ahead with the definition.
;;; 
;;; The :SOURCE-FILE-NAME property of a function-spec is used to record the pathname of
;;; the file which defined that function-spec. The SI:DEFINITIONS property of a generic-
;;; pathname is used to record the definitions defined by that file when it was last
;;; loaded.
;;;
;;; The :SOURCE-FILE-NAME property of a function spec is a single generic-pathname when
;;; that function-spec was defined with DEFUN by a single file. Otherwise it is a list of
;;; the form: ((<type> . <pathnames>) (<type> . <pathnames>))
;;;  <type>            is a definition type like DEFUN DEFVAR DEFFLAVOR DEFSTRUCT etc.
;;;                    (these are just the second argument to record-source-file-name)
;;;  <pathnames>       is a list of all the pathnames that defined the <type> aspect of
;;;                    the function-spec. The car of this list of pathnames is the most
;;;                    recent pathname to have done that definition, the cadr the next
;;;                    most recent etc.
;;;
;;; The SI:DEFINITIONS property of a generic-pathname is an alist of the form:
;;; ((<type> . <function-specs>) (<type> . <function-specs>))
;;;  <type>            this is the same as <type> in the source file name property.
;;;  <function-specs>  this is a list all of the functions specs whose <type> aspect
;;;                    are defined in this file.
;;;                    Note that the si:definitions property does not really give any
;;;                    information about the order in which the various definitions
;;;                    happen in the file. If however the file is loaded all at once
;;;                    (e.g. with load) then the function-specs under each type will
;;;                    be in the order in which they appeared in the file, but note
;;;                    that it will still be impossible to tell about the ordering
;;;                    between definitions of different types (e.g. the si:definitions
;;;                    property can not be used to tell if a defvar occured before a
;;;                    defun.
;;;
;;; *RECORD-SOURCE-FILE-NAME-HOOKS* is a list of hook functions to be called
;;;                    with all of the arguments of record-source-file-name.
;;;		       It is NOT part of the cold-load environment, and thus
;;;		       hooks pushed onto it have no effect on cold-load.
;;;
;;; The cold-load generator has special knowledge of this function.
;;; Don't change it without checking there.
(DEFUN RECORD-SOURCE-FILE-NAME (FUNCTION-SPEC
				&OPTIONAL (TYPE 'DEFUN)
					  (NO-QUERY (EQ INHIBIT-FDEFINE-WARNINGS T))
				&key (7.1-compatibility t)
				     (start-type-definition t))
  
  (DECLARE (VALUES GO-AHEAD-AND-DEFINE))
  ;; This is done this way for compatibility with 7.1 compiled files.
  (WHEN *UPDATE-TYPES-INCREMENTALLY*
    (WHEN (ATOM FUNCTION-SPEC)
      (WHEN START-TYPE-DEFINITION
	(CL:CASE TYPE
	  (SI:DEFTYPE				;7.1 bug in DEFSTRUCT
	    (DW:PREPARE-FOR-TYPE-CHANGE FUNCTION-SPEC)
	    (WHEN 7.1-COMPATIBILITY
	      (DW::ENQUEUE-FINISH-TYPE-REDEFINITION FUNCTION-SPEC)))
	  ((CL:DEFTYPE)				;7.1 compatibility
	   (DW:PREPARE-FOR-TYPE-CHANGE FUNCTION-SPEC)
	   (WHEN 7.1-COMPATIBILITY
	     (DW::ENQUEUE-FINISH-TYPE-REDEFINITION FUNCTION-SPEC)))))))
  (LET ((PATHNAME FDEFINE-FILE-PATHNAME)
	(PROPERTY (FUNCTION-SPEC-GET FUNCTION-SPEC ':SOURCE-FILE-NAME)))
    (COND ((AND (NULL PROPERTY)			;Check most common case first
		(EQ TYPE 'DEFUN)
		(NOT (NULL PATHNAME))
		(NULL PATCH-SOURCE-FILE-PATHNAME))
	   ;; Type is DEFUN, not defined by any file before, being defined by a file now.
	   (RECORD-SOURCE-FILE-NAME-1 FUNCTION-SPEC TYPE PATHNAME)
	   T)
	  ((AND (NULL PATCH-SOURCE-FILE-PATHNAME)
		(IF (NLISTP PROPERTY)		;This also gets case where both
		    (AND (EQ TYPE 'DEFUN)	;pathname and property are null.
			 (EQ PATHNAME PROPERTY))
		    (EQ PATHNAME (CADR (ASSQ TYPE PROPERTY)))))
	   ;; This pathname already is already known. Have to call record-source-file-name-1
	   ;; though, because when we load a whole file (using LOADING-FILE) we do not try
	   ;; to salvage the pathname's old definitions-alist.
	   (UNLESS (NULL PATHNAME)
	     (RECORD-SOURCE-FILE-NAME-1 FUNCTION-SPEC TYPE PATHNAME PROPERTY))
	   T)
	  (T
	   (WHEN (AND PROPERTY (NLISTP PROPERTY))
	     (SETQ PROPERTY `((DEFUN ,PROPERTY))))
	   (LET ((THIS-TYPE (ASSQ TYPE PROPERTY))
		 (OLD-FILE))
	     (COND ((COND ((NULL THIS-TYPE)
			   (SETQ THIS-TYPE (NCONS TYPE)
				 PROPERTY (NCONC PROPERTY (NCONS THIS-TYPE)))
			   T)
			  (NO-QUERY T)
			  ((SETQ OLD-FILE (DEFINITION-WILL-CLOBBER-PRIVATE-PATCH
					    FUNCTION-SPEC TYPE))
			   ;; Collision, warn the user
			   (QUERY-ABOUT-REDEFINITION FUNCTION-SPEC PATHNAME TYPE OLD-FILE T))
			  (FS:THIS-IS-A-PATCH-FILE T)
			  ((OR (AND (NOT (NULL PROPERTY))	;Kludge during world loading
				    (STRINGP PATHNAME))
			       (NOT (VARIABLE-BOUNDP #'FORMAT)))
			   (PRINT (LIST TYPE FUNCTION-SPEC PATHNAME (CDR THIS-TYPE)))
			   (PRINC "being redefined -- RECORD-SOURCE-FILE-NAME")
			   T)
			  ((NULL (SETQ OLD-FILE
				       (PROGN
					 (LOOP FOR FILE IN (CDR THIS-TYPE)
					       UNLESS (FUNCALL FILE ':GET ':PATCH-FILE)
						 RETURN FILE))))
			   T)
			  ((QUERY-ABOUT-REDEFINITION FUNCTION-SPEC PATHNAME TYPE OLD-FILE)))
		    ;; TYPE has an entry in PROPERTY and it's okay to add this definition
		    ;; If this comes from a patch file, put the name of the patch file first
		    ;; and the name of the original source file second on the list.
		    (WHEN PATHNAME
		      (WHEN PATCH-SOURCE-FILE-PATHNAME
			(UNLESS (EQ (CADR THIS-TYPE) PATCH-SOURCE-FILE-PATHNAME)
			  (SETF (CDR THIS-TYPE)
				(CONS PATCH-SOURCE-FILE-PATHNAME
				      (DELQ PATCH-SOURCE-FILE-PATHNAME (CDR THIS-TYPE))))))
		      (SETF (CDR THIS-TYPE)
			    (CONS PATHNAME (DELQ PATHNAME (CDR THIS-TYPE))))
		      (RECORD-SOURCE-FILE-NAME-1 FUNCTION-SPEC TYPE PATHNAME PROPERTY))
		    T)
		   (T NIL)))))))

;;; New version with better argument protocol.  In SYS:.  Needed for 7.1
;;; compatibility.
(DEFUN RECORD-DEFINITION-SOURCE-FILE (FUNCTION-SPEC TYPE &KEY
				      (NO-QUERY (EQ INHIBIT-FDEFINE-WARNINGS T))
				      (START-TYPE-DEFINITION NIL START-TYPE-DEFINITION-P))
  (DECLARE (VALUES GO-AHEAD-AND-DEFINE))
  ;;--- In the "real 7.2", just ignore the START-TYPE-DEFINITION argument.
  ;;--- You can patch all the callers of RECORD-DEFINITION-SOURCE-FILE if you want.
  #+++IGNORE (IGNORE START-TYPE-DEFINITION)
  ;;--- This is an interim kludge until the real 7.2 world gets built, and
  ;;--- all subsidiary 7.2 layered systems are recompiled.
  ;;--- Remove this via a patch in the "real 7.2"
  #---IGNORE (UNLESS START-TYPE-DEFINITION-P
	       (COND ((EQ TYPE 'CL:DEFTYPE)
		      (SETQ START-TYPE-DEFINITION T))
		     ((EQ TYPE 'DEFSTRUCT)
		      (CL:WARN "This file was compiled with a broken version of DEFSTRUCT;~@
			        it must be recompiled."))))
  (RECORD-SOURCE-FILE-NAME FUNCTION-SPEC TYPE NO-QUERY :7.1-COMPATIBILITY NIL
			   :START-TYPE-DEFINITION START-TYPE-DEFINITION))

(DEFUN DEFINITION-WILL-CLOBBER-PRIVATE-PATCH (FUNCTION-SPEC TYPE)
  (IGNORE FUNCTION-SPEC TYPE)
  ;;--- Coax this into winning someday
  NIL)

;;; Put this in a source file that is not a patch file, right before redefining something,
;;; to prevent a redefinition warning.
(DEFUN ALLOW-REDEFINITION (FUNCTION-SPEC &OPTIONAL (TYPE 'DEFUN))
  (LET-IF (VARIABLE-BOUNDP FDEFINE-FILE-DEFINITIONS)
	  ((FDEFINE-FILE-DEFINITIONS FDEFINE-FILE-DEFINITIONS))
    (VARIABLE-MAKUNBOUND FDEFINE-FILE-DEFINITIONS)
    (RECORD-SOURCE-FILE-NAME FUNCTION-SPEC TYPE T)))

(DEFUN REMOVE-SOURCE-FILE-DEFINITION-FROM-PATHNAME (PATH FUNCTION-SPEC TYPE)
  "Removes info from the si:definitions property of path."
  ;; the si:definitions property is a list thatlooks like ((type . fspecs) ... (type . fspecs))
  (LOOP FOR CELL IN (SEND (SEND PATH :GENERIC-PATHNAME) :GET 'SI:DEFINITIONS)
	WHEN (EQ (CAR CELL) TYPE)
	  ;; found somebody of this type, so flush the function-specs
	  DO (RPLACD CELL (DELETE FUNCTION-SPEC (CDR CELL)))))

(DEFUN REMOVE-SOURCE-FILE-DEFINITION (FUNCTION-SPEC TYPE)
  "Remove source-file definitions from function-spec and its pathname."
  (CHECK-ARG FUNCTION-SPEC #'VALIDATE-FUNCTION-SPEC "a valid function-spec")
  (LET ((SFN (FUNCTION-SPEC-GET FUNCTION-SPEC :SOURCE-FILE-NAME)))
    (COND ((NLISTP SFN)
	   ;; defined by defun by a single file, plist of the form
	   ;; (... :source-file-name #P"foo:bar;source" ...)
	   (WHEN (AND (CL:PATHNAMEP SFN) (EQ TYPE 'DEFUN))
	     ;; first remove from the pathname & then the function-spec
	     (REMOVE-SOURCE-FILE-DEFINITION-FROM-PATHNAME SFN FUNCTION-SPEC TYPE)
	     (FUNCTION-SPEC-REMPROP FUNCTION-SPEC :SOURCE-FILE-NAME)))
	  (T
	    ;; multiple definitions, plist of the form
	    ;; (... :source-file-name ((type . paths) (type . paths)...) ...)
	   (LOOP FOR CELL IN SFN
		 IF (EQ (CAR CELL) TYPE)
		   ;; these will be removed.  Inform the pathnames.
		   DO (LOOP FOR PATH IN (CDR CELL)
			    DOING (REMOVE-SOURCE-FILE-DEFINITION-FROM-PATHNAME PATH FUNCTION-SPEC TYPE))
		 ELSE
		   ;; these will survive
		   COLLECT CELL INTO SURVIVORS
		 FINALLY (SETF (FUNCTION-SPEC-GET FUNCTION-SPEC :SOURCE-FILE-NAME)
			       SURVIVORS))
	    (UNLESS (FUNCTION-SPEC-GET FUNCTION-SPEC :SOURCE-FILE-NAME)
	      ;; when there's no such property, remove it entirely so as
	      ;; not to confuse people who use symbol-plist
	      (FUNCTION-SPEC-REMPROP FUNCTION-SPEC :SOURCE-FILE-NAME)))))
  ;; return something non-dangerous
  T)

;This is useful for sorting function specs
(DEFUN FUNCTION-SPEC-LESSP (FS1 FS2)
  (CL:TYPECASE FS1
    (SYMBOL
      (CL:TYPECASE FS2
	(SYMBOL (STRING-LESSP FS1 FS2))
	(CL:CONS (FUNCTION-SPEC-LESSP FS1 (SECOND FS2)))
	(OTHERWISE T)))
    (CONS
      (FUNCTION-SPEC-LESSP (SECOND FS1) FS2))
    (OTHERWISE
      (CL:TYPECASE FS2
	(SYMBOL NIL)
	(CL:CONS (FUNCTION-SPEC-LESSP FS1 (SECOND FS2)))
	(OTHERWISE (SYS:%POINTER-LESSP FS1 FS2))))))

(DEFUN FUNDEFINE (FUNCTION-SPEC &AUX TYPE)
  "Makes a function spec not have a function definition"
  ;; First, validate the function spec and determine its type
  (CHECK-ARG FUNCTION-SPEC
	     (SETQ TYPE (VALIDATE-FUNCTION-SPEC FUNCTION-SPEC))
	     "a symbol or a function-spec list")
  ;; Unforward the function cell if it's forwarded.  This allows the function
  ;; to be GC'd later.  Unfortunately, if there are outstanding references to this
  ;; undefined function when OPTIMIZE-COMPILED-FUNCTIONS is run, and this function
  ;; is redefined, *COMPILED-FUNCTION-OPTIMIZATION-STATE* may not get updated properly.
  ;; Since this shouldn't be common, and if it occurs the only thing which will go wrong
  ;; is you've got to follow a forwarding pointer, don't worry about it.
  (UNFORWARD-FUNCTION-CELL FUNCTION-SPEC)
  ;; Ensure the function is not linked
  #+Imach
  (WHEN (FDEFINEDP FUNCTION-SPEC)
    (LET ((OLD-FUNC (FDEFINITION FUNCTION-SPEC)))
      (WHEN (FUNCTION-LINKED-P OLD-FUNC)
	(SELECTQ (SIGNAL 'LINKED-FUNCTION-REDEFINITION
			 :FUNCTION-SPEC FUNCTION-SPEC
			 :OLD-FUNCTION OLD-FUNC
			 :PROCEED-TYPES (IF *ENABLE-WHO-CALLS-UNLINKING*
					    '(:UNLINK-OLD-FUNCTION
					      :UNLINK-OLD-FUNCTION-USING-WHO-CALLS
					      :UNLINK-ALL
					      :NO-ACTION)
					    '(:UNLINK-OLD-FUNCTION
					      :UNLINK-ALL
					      :NO-ACTION)))
	  (:UNLINK-OLD-FUNCTION (CLI::UNLINK-TO-FUNCTIONS OLD-FUNC))
	  (:UNLINK-OLD-FUNCTION-USING-WHO-CALLS
	   (CLI::UNLINK-TO-FUNCTIONS-USING-WHO-CALLS OLD-FUNC))
	  (:UNLINK-ALL (CLI::UNLINK-TO-FUNCTIONS T))
	  (:NO-ACTION)))))
  (IF (SYMBOLP FUNCTION-SPEC) (FMAKUNBOUND FUNCTION-SPEC)
      (FUNCALL (GET TYPE 'FUNCTION-SPEC-HANDLER) 'FUNDEFINE FUNCTION-SPEC)))

(DEFUN DEFINITION-HAS-LOCATION-P (FUNCTION-SPEC &AUX TYPE)
  (CHECK-ARG FUNCTION-SPEC
	     (SETQ TYPE (VALIDATE-FUNCTION-SPEC FUNCTION-SPEC))
	     "a symbol or a function-spec list")
  (OR (SYMBOLP FUNCTION-SPEC)
      (FUNCALL (GET TYPE 'FUNCTION-SPEC-HANDLER) 'DEFINITION-HAS-LOCATION-P FUNCTION-SPEC)))

(DEFUN FDEFINITION-LOCATION (FUNCTION-SPEC &OPTIONAL FOR-COMPILER &AUX TYPE)
  "Returns a locative pointer to the cell containing the function spec's definition"
  ;; First, validate the function spec and determine its type
  (CHECK-ARG FUNCTION-SPEC
	     (SETQ TYPE (VALIDATE-FUNCTION-SPEC FUNCTION-SPEC))
	     "a symbol or a function-spec list")
  (IF (SYMBOLP FUNCTION-SPEC)
      (FUNCTION-CELL-LOCATION FUNCTION-SPEC) 
      (FUNCALL (GET TYPE 'FUNCTION-SPEC-HANDLER) 'FDEFINITION-LOCATION FUNCTION-SPEC
								       FOR-COMPILER)))

(DEFUN FORWARD-FUNCTION-CELL-INTO-COMPILED-FUNCTION-P (FUNCTION-SPEC &AUX TYPE)
  (CHECK-ARG FUNCTION-SPEC
	     (SETQ TYPE (VALIDATE-FUNCTION-SPEC FUNCTION-SPEC))
	     "a symbol or a function-spec list")
  (OR (SYMBOLP FUNCTION-SPEC)
      (FUNCALL (GET TYPE 'FUNCTION-SPEC-HANDLER)
	       'FORWARD-FUNCTION-CELL-INTO-COMPILED-FUNCTION-P FUNCTION-SPEC)))

(DEFUN LOCATION-IS-FDEFINITION-LOCATION-P (FUNCTION-SPEC LOCATIVE &AUX TYPE)
  (CHECK-ARG FUNCTION-SPEC
	     (SETQ TYPE (VALIDATE-FUNCTION-SPEC FUNCTION-SPEC))
	     "a symbol or a function-spec list")
  (IF (SYMBOLP FUNCTION-SPEC)
      (EQ (FUNCTION-CELL-LOCATION FUNCTION-SPEC) LOCATIVE)
      (FUNCALL (GET TYPE 'FUNCTION-SPEC-HANDLER)
	       'LOCATION-IS-FDEFINITION-LOCATION-P FUNCTION-SPEC LOCATIVE)))

;;; This works for more than just "functions (definition type defun)"
;;;--- However, it currently uses a series of semi-kludges to do so.
;;;--- Clean up when we really clean up this whole area.
(DEFUN FUNCTION-PARENT (FUNCTION-SPEC &OPTIONAL DEFINITION-TYPE)
  (DECLARE (VALUES NAME TYPE))
  "Returns NIL or the name of another definition which has the same source code.
The second value is the type of that definition (which can be NIL).
This is used for things like internal functions, methods automatically
created by a defflavor, and macros automatically created by a defstruct."
  ;; Compiling an unnamed lambda can produce a function with a null name
  (WHEN (NOT (NULL FUNCTION-SPEC))
    (LET (FUNCTION-SPEC-TYPE)
      (CHECK-ARG FUNCTION-SPEC (SETQ FUNCTION-SPEC-TYPE (VALIDATE-FUNCTION-SPEC FUNCTION-SPEC))
		 "a symbol or a function-spec list")
      (FLET ((DEFINITION-TYPE-OK (DTYPE)
	       (OR (NULL DEFINITION-TYPE) (EQ DEFINITION-TYPE DTYPE))))
	(WHEN (DEFINITION-TYPE-OK 'DEFUN)
	  (LET ((DEF (VALID-FUNCTION-DEFINITION FUNCTION-SPEC)))
	    (WHEN DEF
	      (LET ((INFO (DEBUGGING-INFO DEF)))
		(WHEN (ASSQ 'SHARED-STRUCTURE-ACCESSOR INFO)
		  (LET ((SLOT (GET FUNCTION-SPEC 'DEFSTRUCT-SLOT)))
		    (WHEN SLOT
		      (RETURN-FROM FUNCTION-PARENT
			(VALUES (CAR SLOT) 'DEFSTRUCT)))))
		(LET ((PARENT (ASSQ 'FUNCTION-PARENT INFO)))
		  (WHEN PARENT
		    (RETURN-FROM FUNCTION-PARENT
		      (VALUES-LIST (CDR PARENT))))))
	      (WHEN (AND (LISTP DEF)
			 (EQ (CAR DEF) 'MACRO)
			 (SYMBOLP (CDR DEF)))		;for DEFSTRUCT
		(LET ((FUNCTION (GET (CDR DEF) 'MACROEXPANDER-FUNCTION-PARENT)))
		  (WHEN FUNCTION
		    (RETURN-FROM FUNCTION-PARENT
		      (FUNCALL FUNCTION FUNCTION-SPEC))))))))
	(WHEN (AND (DEFINITION-TYPE-OK 'DEFFLAVOR)
		   (SYMBOLP FUNCTION-SPEC)
		   (GET FUNCTION-SPEC 'SI:FLAVOR))
	  ;; Support the nesting of flavor definitions placed there by
	  ;; defflavor-with-parent.
	  (LET ((FLAVOR-PARENT (GET FUNCTION-SPEC 'SI:FLAVOR-PARENT)))
	    (WHEN FLAVOR-PARENT
	      (RETURN-FROM FUNCTION-PARENT
		(VALUES-LIST FLAVOR-PARENT)))))
	(WHEN (NOT (SYMBOLP FUNCTION-SPEC))
	  (FUNCALL (GET FUNCTION-SPEC-TYPE 'FUNCTION-SPEC-HANDLER)
		   'FUNCTION-PARENT FUNCTION-SPEC))))))

;; (:LOCATION locative-or-list-pointer) refers to the CDR of the pointer.
;; This is for pointing at an arbitrary place which there is no special
;; way to describe.
(DEFINE-FUNCTION-SPEC-HANDLER :LOCATION (FUNCTION FUNCTION-SPEC &OPTIONAL ARG1 ARG2)
  (LET* ((VALID (NULL (CDR (LAST FUNCTION-SPEC))))
	 (LOC (AND VALID (SECOND FUNCTION-SPEC))))
    (SELECTQ FUNCTION
      (VALIDATE-FUNCTION-SPEC (AND VALID
				   (= (LENGTH FUNCTION-SPEC) 2)
				   (OR (= (%DATA-TYPE LOC) DTP-LOCATIVE)
				       (= (%DATA-TYPE LOC) DTP-LIST))))
      (FDEFINE (RPLACD LOC ARG1))
      (FDEFINITION (CDR LOC))
      (FDEFINEDP (AND ( (%P-DATA-TYPE LOC) DTP-NULL) (NOT (NULL (CDR LOC)))))
      (FDEFINITION-LOCATION LOC)
      (DEFINITION-HAS-LOCATION-P T)
      (FORWARD-FUNCTION-CELL-INTO-COMPILED-FUNCTION-P NIL)
      (LOCATION-IS-FDEFINITION-LOCATION-P NIL)
	;FUNDEFINE could store DTP-NULL, which would only be right sometimes
      (OTHERWISE (FUNCTION-SPEC-DEFAULT-HANDLER FUNCTION FUNCTION-SPEC ARG1 ARG2)))))

;Convert old Maclisp-style property function specs
(DEFUN STANDARDIZE-FUNCTION-SPEC (FUNCTION-SPEC &OPTIONAL (ERROR-P T))
  (AND (LISTP FUNCTION-SPEC)
       (= (LENGTH FUNCTION-SPEC) 2)
       (SYMBOLP (CAR FUNCTION-SPEC))
       (NOT (GET (CAR FUNCTION-SPEC) 'FUNCTION-SPEC-HANDLER))
       (SETQ FUNCTION-SPEC (CONS ':PROPERTY FUNCTION-SPEC)))
  (UNLESS (VALIDATE-FUNCTION-SPEC FUNCTION-SPEC)
    (IF ERROR-P
	(ERROR "~S is not a valid function spec" FUNCTION-SPEC)
	(RETURN-FROM STANDARDIZE-FUNCTION-SPEC NIL)))
  FUNCTION-SPEC)

(DEFPROP DEFUN "Function" DEFINITION-TYPE-NAME)
(DEFPROP DEFVAR "Variable" DEFINITION-TYPE-NAME)
(DEFPROP ENCAPSULATION "Encapsulated Function" DEFINITION-TYPE-NAME)

(DEFUN DEFINITION-TYPE-NAME (TYPE)
  (OR (GET TYPE 'DEFINITION-TYPE-NAME) TYPE))

;; Query about any irregularities about redefining the given function symbol now.
;; Return T to tell caller to go ahead and redefine the symbol
;; (no problems or user says ok), NIL to leave it unchanged.
;; NEW-PATHNAME can be NIL if Lisp top level is redefining.
(DEFVAR *FILES-REDEFINED-BY-NIL* NIL)

(DEFUN QUERY-ABOUT-REDEFINITION
       (FUNCTION-SPEC NEW-PATHNAME TYPE OLD-PATHNAME &OPTIONAL MUNGING-PRIVATE-PATCH)
  ;; Detect any cross-file redefinition worth complaining about.
  (COND ((OR (EQ (IF (STRINGP OLD-PATHNAME) OLD-PATHNAME
		     (FUNCALL OLD-PATHNAME :TRANSLATED-PATHNAME))
		 (IF (OR (STRINGP NEW-PATHNAME) (NULL NEW-PATHNAME)) NEW-PATHNAME
		     (FUNCALL NEW-PATHNAME :TRANSLATED-PATHNAME)))
	     (MEMQ OLD-PATHNAME (IF (NULL NEW-PATHNAME)
				    *FILES-REDEFINED-BY-NIL*
				    (FUNCALL NEW-PATHNAME :GET ':REDEFINES-FILES))))
	 T)
	(T
	 (LET* ((CONDITION (MAKE-CONDITION 'REDEFINITION
			     :DEFINITION-TYPE TYPE
			     :NAME FUNCTION-SPEC
			     :OLD-PATHNAME OLD-PATHNAME
			     :NEW-PATHNAME NEW-PATHNAME
			     :MUNGING-PRIVATE-PATCH MUNGING-PRIVATE-PATCH
			     :PROCEED-TYPES '(:NO-ACTION :PROCEED :INHIBIT-DEFINITION)))
		(RESULT (SIGNAL CONDITION)))
	   (OR RESULT
	       (SETQ RESULT
		     (IF (NULL INHIBIT-FDEFINE-WARNINGS)
			 (query-about-redefinition-query-user condition)
			 (IF (EQ INHIBIT-FDEFINE-WARNINGS :JUST-WARN)
			     (FORMAT QUERY-IO "~&Warning:  ~A" CONDITION))
			 :NO-ACTION)))
	   (COND ((NEQ RESULT :INHIBIT-DEFINITION)
		  (COND ((EQ RESULT :PROCEED)
			 ;; Set things up so that in the future, if NEW-PATHNAME tries
			 ;; to redefine OLD-PATHNAME, it will just go ahead.
			 (COND ((NULL NEW-PATHNAME)
				(PUSH OLD-PATHNAME *FILES-REDEFINED-BY-NIL*))
			       (T
				(PUSH OLD-PATHNAME
				      (FUNCALL NEW-PATHNAME :GET ':REDEFINES-FILES))))))
		  T))))))

(defun query-about-redefinition-query-user (prompt)
  (if (fboundp 'fquery)
      (fquery '(:choices
		 (((:no-action "Yes.") #/Y #/T #\sp)
		  ((:proceed "Proceed.") #/P)
		  ((:inhibit-definition "No.") #/N #\rubout))
		 :help-function si:query-about-redefinition-help)
	      "~&Warning:  ~A OK? "
	      prompt)
      (format t "~A OK? " prompt)
      (loop named answer
	    do
	(format t "~&Y for Yes, N for No, P for Proceed: ")
	(let ((char (tyi)))
	  (cond ((char-equal char #/Y) (return-from answer :NO-ACTION))
		((char-equal char #\space) (return-from answer :NO-ACTION))
		((char-equal char #/N) (return-from answer :inhibit-definition))
		((char-equal char #\rubout) (return-from answer :inhibit-definition))
		((char-equal char #/P) (return-from answer :proceed)))))))

(DEFUN QUERY-ABOUT-REDEFINITION-HELP (STREAM)
  (SEND STREAM ':STRING-OUT "
Type Y to proceed to redefine the function, N to not redefine it,
or P to proceed and not ask in the future (for this pair of files)."))

;Restore the saved previous function definition of a symbol.
(DEFUN UNDEFUN (FUNCTION-SPEC &AUX TEM)
  (COND ((SETQ TEM (FUNCTION-SPEC-GET FUNCTION-SPEC ':PREVIOUS-DEFINITION))
	 (LET ((FDEFINE-FILE-PATHNAME NIL))
	   (FDEFINE FUNCTION-SPEC TEM T T)))
	((SETQ TEM (VALID-FUNCTION-DEFINITION FUNCTION-SPEC))
	 (FUNCTION-SPEC-PUTPROP FUNCTION-SPEC TEM ':PREVIOUS-DEFINITION)
	 (FUNDEFINE FUNCTION-SPEC))))

(DEFUN GET-ALL-SOURCE-FILE-NAMES (FUNCTION-SPEC &OPTIONAL CHASE-PARENTS)
  (LET ((PROPERTY (FUNCTION-SPEC-GET FUNCTION-SPEC ':SOURCE-FILE-NAME CHASE-PARENTS)))
    (COND ((NULL PROPERTY) NIL)
	  ((NLISTP PROPERTY)
	   (SETQ PROPERTY `((DEFUN ,PROPERTY)))
	   ;; May as well save this consing.
	   (FUNCTION-SPEC-PUTPROP FUNCTION-SPEC PROPERTY ':SOURCE-FILE-NAME)
	   PROPERTY)
	  (T PROPERTY))))
 
(DEFUN GET-SOURCE-FILE-NAME (FUNCTION-SPEC &OPTIONAL TYPE CHASE-PARENTS PATCH-OK)
  (DECLARE (VALUES PATHNAME TYPE))
  (LET ((PROPERTY (FUNCTION-SPEC-GET FUNCTION-SPEC ':SOURCE-FILE-NAME CHASE-PARENTS)))
    (COND ((NULL PROPERTY) NIL)
	  ((NLISTP PROPERTY)
	   (WHEN (OR (NULL TYPE) (EQ TYPE 'DEFUN))
	     (VALUES PROPERTY 'DEFUN)))
	  (T
	   (LET ((LIST (IF TYPE (ASSQ TYPE PROPERTY) (CAR PROPERTY))))
	     (LOOP FOR FILE IN (CDR LIST)
		   WHEN (NOT (SEND FILE ':GET ':PATCH-FILE))
		     RETURN (VALUES FILE (CAR LIST))
		   FINALLY
		     (WHEN PATCH-OK
		       (RETURN (SECOND LIST)))))))))

(DEFUN GET-INSTALLED-SOURCE-FILE-NAME (FUNCTION-SPEC TYPE &OPTIONAL CHASE-PARENTS)
  (CADR (ASSQ TYPE (GET-ALL-SOURCE-FILE-NAMES FUNCTION-SPEC CHASE-PARENTS))))

(DEFUN GET-INSTALLED-PRIVATE-PATCH-SOURCE-FILE-NAME
       (FUNCTION-SPEC &OPTIONAL TYPE CHASE-PARENTS)
  (DECLARE (VALUES PATHNAME TYPE))
  (FLET ((PRIVATE-PATCH-P (FILE)
	   ;; We consider this file to be a private patch-file if it is a
	   ;; patch-file which has not patch-file-version-info.  Note that
	   ;; if the private patch-file is contained in a private system,
	   ;; then it fails this test!
	   (AND (SEND FILE :GET ':PATCH-FILE)
		(NULL (SEND FILE :GET 'SCT:PATCH-FILE-VERSION-INFO)))))
    (LET ((PROPERTY (FUNCTION-SPEC-GET FUNCTION-SPEC ':SOURCE-FILE-NAME CHASE-PARENTS)))
      (COND ((NULL PROPERTY) NIL)
	    ((NLISTP PROPERTY)
	     (WHEN (AND (OR (NULL TYPE) (EQ TYPE 'DEFUN))
			(PRIVATE-PATCH-P PROPERTY))
	       (VALUES PROPERTY 'DEFUN)))
	    (T
	     (LET ((LIST (IF TYPE (ASSQ TYPE PROPERTY) (CAR PROPERTY))))
	       (LOOP FOR FILE IN (CDR LIST)
		     DOING
		 (WHEN (PRIVATE-PATCH-P FILE)
		   (RETURN (VALUES FILE (CAR LIST)))))))))))

(COMMENT
;;; This function is a temporary hack to make up for the fact that patch file pathnames
;;; are not logical pathnames.  This will be fixed in the next release.  Or the one
;;; after that.  Or the one after that...  Until then, this
;;; hack is being used to allow M-. to work on patched functions at other sites than SCRC.
;;; The function PATCH-SYSTEM-PATHNAME, and the functions below, should be reverted when
;;; patch file pathnames are made logical.
(DEFUN CONVERT-PATCH-FILE-PATHNAME (PATHNAME)
  (LET ((PROP (SEND PATHNAME ':GET 'PATCH-FILE-VERSION-INFO)))
    (IF (NULL PROP)
	PATHNAME
	(LET ((NEW-PATHNAME (SEND (PATCH-SYSTEM-PATHNAME (FIRST PROP) ':PATCH-FILE
							 (SECOND PROP) (THIRD PROP)
							 SI:*DEFAULT-BINARY-FILE-TYPE*)
				  ':GENERIC-PATHNAME)))
	  (LOOP FOR (PROP VAL) ON (SEND PATHNAME ':PROPERTY-LIST) BY 'CDDR
		UNLESS (SEND NEW-PATHNAME ':GET PROP)
		  DO (SEND NEW-PATHNAME ':PUTPROP VAL PROP))
	  NEW-PATHNAME))))

(DEFUN CONVERT-PATCH-FILE-PATHNAME-LIST (LIST)
  (CONS (CAR LIST)
	(MAPCAR 'CONVERT-PATCH-FILE-PATHNAME (CDR LIST))))
)

;;; Get the source file name, rather than the generic pathname.
(DEFUN GET-SOURCE-FILE-FULL-NAME (FUNCTION-SPEC &OPTIONAL TYPE &AUX PATHNAME SOURCE-PATHNAME)
  (SETQ PATHNAME (GET-SOURCE-FILE-NAME FUNCTION-SPEC TYPE))
  (COND (PATHNAME
	 (SETQ SOURCE-PATHNAME (SEND PATHNAME ':GET ':QFASL-SOURCE-FILE-UNIQUE-ID))
	 (IF SOURCE-PATHNAME
	     (FS:MAKE-PATHNAME ':HOST (SEND PATHNAME ':HOST)
			       ':DEVICE (SEND PATHNAME ':DEVICE)
			       ':DIRECTORY (SEND PATHNAME ':DIRECTORY)
			       ':NAME (SEND PATHNAME ':NAME)
			       ':CANONICAL-TYPE (SEND SOURCE-PATHNAME ':CANONICAL-TYPE)
			       ':VERSION (SEND SOURCE-PATHNAME ':VERSION))
	   PATHNAME))))

;Get the documentation string for a definition name, or for a function.
;NIL if not defined or no documentation.
;This is a hybrid of Zetalisp and Common Lisp.
(DEFUN DOCUMENTATION (NAME &OPTIONAL (TYPE 'DEFUN) &AUX DOC)
  (DECLARE LT:(SIDE-EFFECTS READER))
  ;; Convert Common Lisp definition types to Zetalisp types
  (SETQ TYPE (STANDARDIZE-DOCUMENTATION-TYPE TYPE))
  ;; Function documentation is stored in special wierd places, look there first
  ;; Also, if the type is DEFUN then NAME can be a function rather than the name of one
  (WHEN (EQ TYPE 'DEFUN)
    (LET ((DEBUG-INFO NIL))
      (CL:TYPECASE NAME
	((CL:SATISFIES INTERPRETED-FUNCTION-P)
	 (SETF DEBUG-INFO (INTERPRETED-FUNCTION-DEBUGGING-INFO NAME)))
	(CL:CONS
	  (SELECTQ (FIRST NAME)
	    ((SPECIAL)
	     (WHEN (SETQ DOC (DOCUMENTATION (OR (THIRD NAME) (SECOND NAME))))
	       (RETURN-FROM DOCUMENTATION DOC)))))
	(SYS:COMPILED-FUNCTION
	  (SETQ DEBUG-INFO (COMPILED-FUNCTION-DEBUGGING-INFO NAME)))
	(SYS:GENERIC-FUNCTION
	  (SETQ DEBUG-INFO (EXPAND-GENERIC-FUNCTION-DEBUGGING-INFO NAME)))
	(CLOS-INTERNALS:FUNCALLABLE-INSTANCE
	  (SETQ DEBUG-INFO (CLOS-INTERNALS:DEBUGGING-INFORMATION-FUNCTION NAME)))
	(SYS:LEXICAL-CLOSURE
	  (WHEN (SETQ DOC (DOCUMENTATION (LEXICAL-CLOSURE-FUNCTION NAME)))
	    (RETURN-FROM DOCUMENTATION DOC))))
      ;; Didn't find it in any special function-type-dependent places, try the debugging info
      (WHEN (SETQ DOC (CADR (ASSQ ':DOCUMENTATION DEBUG-INFO)))
	(RETURN-FROM DOCUMENTATION DOC))
      ;; If the function is encapsulated, look inside
      (WHEN (AND (SETQ DOC (CADR (ASSQ 'ENCAPSULATED-DEFINITION DEBUG-INFO)))
		 (SETQ DOC (DOCUMENTATION DOC)))
	(RETURN-FROM DOCUMENTATION DOC)))
    ;; If this is the name of a function, try its definition
    ;; If this is an actual function, there is nothing left to try
    (COND ((VALIDATE-FUNCTION-SPEC NAME)
	   (WHEN (AND (FDEFINEDP NAME)
		      (LET ((DEFINITION (FDEFINITION NAME)))
			(AND (FUNCTIONP DEFINITION T)	;don't lose on Prolog functions
			     (SETQ DOC (DOCUMENTATION DEFINITION)))))
	     (RETURN-FROM DOCUMENTATION DOC)))
	  ((FUNCTIONP NAME T)
	   (RETURN-FROM DOCUMENTATION NIL))))

  (WHEN (EQ TYPE 'CL:DEFTYPE)
    ;; Could be a Flavor or class
    (LET ((FLAVOR (FLAVOR:FIND-FLAVOR NAME NIL)))
      (WHEN FLAVOR
	(RETURN-FROM DOCUMENTATION (FLAVOR:FLAVOR-DOCUMENTATION FLAVOR))))
    (WHEN (GET NAME 'DEFSTRUCT-DESCRIPTION)
      (RETURN-FROM DOCUMENTATION (DOCUMENTATION NAME 'CL:STRUCTURE)))
    (LET ((CLASS (CLOS:FIND-CLASS NAME NIL)))
      (WHEN CLASS
	(RETURN-FROM DOCUMENTATION (CLOS:DOCUMENTATION CLASS)))))

  ;; Didn't find it in any special type-dependent places, try the property list
  (COND ((VALIDATE-FUNCTION-SPEC NAME)
	 (SETQ DOC (FUNCTION-SPEC-GET NAME ':DOCUMENTATION)))
	((SYMBOLP NAME)
	 (SETQ DOC (GET NAME ':DOCUMENTATION)))
	(T
	 (CL:CERROR "Use NIL for ~(~A~) ~S's documentation."
		    "I don't know how to find documentation for ~(~A~) ~S."
		    (OR (GET TYPE 'DEFINITION-TYPE-NAME) TYPE) NAME)
	 (RETURN-FROM DOCUMENTATION NIL)))
  (WHEN (SI:SOME-STRING DOC)
    (RETURN-FROM DOCUMENTATION DOC))		;Old-fashioned non-type-specific form
  (AND (LISTP DOC)				;New-fashioned plist of types and strings
       (CL:GETF DOC TYPE)))

;Old name.
(COMPILER:MAKE-OBSOLETE FUNCTION-DOCUMENTATION "use DOCUMENTATION")
(COMPILER:DEFINE-SYNONYM-FUNCTION FUNCTION-DOCUMENTATION DOCUMENTATION)

(CL:DEFSETF DOCUMENTATION SET-DOCUMENTATION)

(DEFUN SET-DOCUMENTATION (NAME TYPE DOC &AUX TEM FUNCTION-P)
  (check-string-arg doc)
  ;; Convert Common Lisp definition types to Zetalisp types
  (SETQ TYPE (STANDARDIZE-DOCUMENTATION-TYPE TYPE))
  ;; Function documentation is stored in special wierd places, look there first
  ;; Also, if the type is DEFUN then NAME can be a function rather than the name of one
  (WHEN (EQ TYPE 'DEFUN)
    (LET ((DEBUG-INFO NIL))
      (CL:TYPECASE NAME
	((CL:SATISFIES INTERPRETED-FUNCTION-P))
	(CL:CONS
	  (SELECTQ (FIRST NAME)
	    ((SPECIAL)
	     (WHEN (DOCUMENTATION (OR (THIRD NAME) (SECOND NAME)))
	       (RETURN-FROM SET-DOCUMENTATION
		 (SET-DOCUMENTATION (OR (THIRD NAME) (SECOND NAME)) TYPE DOC))))))
	(SYS:COMPILED-FUNCTION
	  (SETQ DEBUG-INFO (COMPILED-FUNCTION-DEBUGGING-INFO NAME)))
	(SYS:GENERIC-FUNCTION
	  (SETQ DEBUG-INFO (EXPAND-GENERIC-FUNCTION-DEBUGGING-INFO NAME)))
	(CLOS-INTERNALS:FUNCALLABLE-INSTANCE
	  (SETQ DEBUG-INFO (CLOS-INTERNALS:DEBUGGING-INFORMATION-FUNCTION NAME)))
	(SYS:LEXICAL-CLOSURE
	  (WHEN (DOCUMENTATION (LEXICAL-CLOSURE-FUNCTION NAME))
	    (RETURN-FROM SET-DOCUMENTATION
	      (SET-DOCUMENTATION (LEXICAL-CLOSURE-FUNCTION NAME) TYPE DOC)))))
      ;; Didn't find it in any special function-type-dependent places, try the debugging info
      (WHEN (SETQ TEM (CDR (ASSQ ':DOCUMENTATION DEBUG-INFO)))
	(SETF (CAR TEM) DOC)
	(RETURN-FROM SET-DOCUMENTATION DOC))
      ;; If the function is encapsulated, look inside
      (WHEN (AND (SETQ TEM (CADR (ASSQ 'ENCAPSULATED-DEFINITION DEBUG-INFO)))
		 (DOCUMENTATION TEM))
	(RETURN-FROM SET-DOCUMENTATION
	  (SET-DOCUMENTATION TEM TYPE DOC))))
    ;; If this is the name of a function, try its definition
    ;; If this is an actual function, patching into debugging-info is too
    ;; dangerous so just blow out.  CL doesn't allow passing in a function anyway.
    (COND ((SETQ TEM (VALID-FUNCTION-DEFINITION NAME))
	   (WHEN (AND TEM (DOCUMENTATION TEM))
	     (RETURN-FROM SET-DOCUMENTATION
	       (SET-DOCUMENTATION TEM TYPE DOC))))))

  ;; Didn't find it in any special type-dependent places, try the property list
  ;; Didn't find it in any special type-dependent places, try the property list
  (COND ((VALIDATE-FUNCTION-SPEC NAME)
	 (SETQ TEM (FUNCTION-SPEC-GET NAME ':DOCUMENTATION))
	 (SETQ FUNCTION-P T))
	((SYMBOLP NAME)
	 (SETQ TEM (GET NAME ':DOCUMENTATION)))
	(T
	 (CL:CERROR "Ignore this attempt to set ~(~A~) ~S's documentation."
		    "I don't know how to set documentation for ~(~A~) ~S."
		    (OR (GET TYPE 'DEFINITION-TYPE-NAME) TYPE) NAME)
	 (RETURN-FROM SET-DOCUMENTATION DOC)))

  (WHEN (EQ TYPE 'CL:DEFTYPE)
    ;; Could be a Flavor or class
    (LET ((FLAVOR (FLAVOR:FIND-FLAVOR NAME NIL)))
      (WHEN FLAVOR
	(RETURN-FROM SET-DOCUMENTATION
	  (CL:SETF (FLAVOR:FLAVOR-DOCUMENTATION FLAVOR) DOC))))
    (WHEN (GET NAME 'DEFSTRUCT-DESCRIPTION)
      (RETURN-FROM SET-DOCUMENTATION
	(CL:SETF (DOCUMENTATION NAME 'CL:STRUCTURE) DOC)))
    (LET ((CLASS (CLOS:FIND-CLASS NAME NIL)))
      (WHEN CLASS
	(RETURN-FROM SET-DOCUMENTATION
	  ;; Can't use SETF here because the cold load generator can't
	  ;; deal with SETF function specs.
	  (SET-CLOS-DOCUMENTATION DOC CLASS)))))

  (UNLESS (OR TEM DOC)				;Return early if nothing to do
    (RETURN-FROM SET-DOCUMENTATION DOC))
  (WHEN (SI:SOME-STRING TEM)				;Old-fashioned non-type-specific form
    (SETQ TEM `(DEFVAR ,TEM)))			;Assume a variable is most likely
  (IF DOC
      (SETF (CL:GETF TEM TYPE) DOC)
      (CL:REMF TEM TYPE))
  (IF FUNCTION-P
      (IF TEM
	  (SETF (FUNCTION-SPEC-GET NAME ':DOCUMENTATION) TEM)
	  (FUNCTION-SPEC-REMPROP NAME ':DOCUMENTATION))
      (IF TEM
	  (SETF (GET NAME ':DOCUMENTATION) TEM)
	  (REMPROP NAME ':DOCUMENTATION)))
  DOC)

(DEFUN STANDARDIZE-DOCUMENTATION-TYPE (TYPE)
  (OR (CDR (ASSQ TYPE '((CL:VARIABLE . DEFVAR)
			(CL:FUNCTION . DEFUN)
			(CL:STRUCTURE . DEFSTRUCT)
			(CL:DEFSTRUCT . DEFSTRUCT)
			(CL:TYPE . CL:DEFTYPE)
			(CL:SETF . CL:DEFSETF))))
      TYPE))

;;;; Stuff having less to do with function specs per se

;;; This is called by the machine dependent ARGLIST when it sees an interpreted function
(DEFUN INTERPRETED-FUNCTION-ARGLIST (FUNCTION REAL-FLAG &AUX DEBUG-INFO TEM)
  (WHEN (EQ (CAR FUNCTION) 'DIGESTED-LAMBDA)
    (SETQ DEBUG-INFO (DEBUGGING-INFO FUNCTION))
    (RETURN-FROM INTERPRETED-FUNCTION-ARGLIST
      (COND ((AND (NOT REAL-FLAG)
		  (ASSQ 'ENCAPSULATED-DEFINITION DEBUG-INFO))
	     (ARGLIST (CADR (ASSQ 'ENCAPSULATED-DEFINITION DEBUG-INFO))))
	    (T
	     (VALUES
	       (IF (AND (NOT REAL-FLAG)
			(SETQ TEM (ASSQ 'ARGLIST DEBUG-INFO)))
		   (CDR TEM)
		   (LET ((ARGLIST (IF (EQ (FIRST FUNCTION) 'DIGESTED-LAMBDA)
				      (ARGLIST (SECOND FUNCTION) T)
				      (THIRD FUNCTION))))		      
		     (LDIFF ARGLIST (MEMQ '&AUX ARGLIST))))
	       (CDR (OR (ASSQ 'VALUES DEBUG-INFO) (ASSQ 'RETURN-LIST DEBUG-INFO)))
	       (AND (LT:FUNCTION-INLINE-FORM-METHOD FUNCTION) 'SUBST)
	       (CDR (ASSQ 'COMPILER::ARGLIST-TYPES DEBUG-INFO))
	       (CDR (ASSQ 'COMPILER::VALUE-TYPES DEBUG-INFO)))))))
  (SETQ FUNCTION (LAMBDA-MACRO-EXPAND FUNCTION NIL))
  (LDIFF (CAR (INTERPRETED-LAMBDA-LAMBDA-LIST-AND-BODY FUNCTION))
	 (MEMQ '&AUX (CADR FUNCTION))))

;; Return the debugging info alist of a function.  NIL if there is none or unreasonable arg.
;; Elements of the alist look like one of these things:
;; (SI:ENCAPSULATED-DEFINITION <internal symbol> <type of encapsulation>)
;;    This means that this definition was made to encapsulate an inner definition.
;;    See the file LISPM2;ENCAPS > for more info on these.
;; (SI:RENAMINGS <alist of renamings>)
;;    This sort of item is used together with (ENCAPSULATED-DEFINITION ... SI:RENAME-WITHIN).
;;    It specifies what renamings are to be done to the original definition.
;;    It is an alist of entries of the form (<symbol to rename>  <new name>).
;;    See LISPM2;ENCAPS > for more information.
;; (ARGLIST . <arglist>)
;;    The CDR of this element is an arglist to give the user when he asks.
;;    It is set up by having (LOCAL-DECLARE ((ARGLIST . <arglist>)) ...)
;;    around the function definition when it is compiled.
;;    This is for when the function's actual arglist is not informative enough.
;; (VALUES . <value names>)
;;    The CDR of this is the list of names of returned values,
;;    to return as the second value if the user calls ARGLIST.
;;    It is set up only by a local declare like the one which specifies
;;    an arglist (above).
;;    This used to be called RETURN-LIST, which stil works.
;; (COMPILER:LOCAL-MAP <local map>)
;;    The CADR of this element is a local map which indicates how local variables
;;    are assigned to slots in the function's local block.
;;    The n'th element of the map is a list of the locals that live there.
;;    Actually, as of now, only one local can live in each slot, so the elements
;;    of the map are at most of length one.  The format was chosen to allow expansion.
;; (COMPILER:ARG-MAP <arg map>)
;;    This is just like a local map except that it describes slots in the argument block
;;    rather than slots in the local block.  It replaces keeping names in the ADL.
;; (SYS:FUNCTION-PARENT <name>)
;;    Gives the name of a definition whose source code includes this function.  This
;;    is for functions automatically generated by defstruct, defflavor, etc.
;; (:INTERNAL-FEF-OFFSETS <o1> <o2> ...)
;;    Offsets within the fef of function cells for the :INTERNAL functions
;;
;; The debugging info in a fef is made by the (DEBUG-INFO ...) lap instruction.
;; A NAMED-LAMBDA can also have debugging info.  If its CADR is not a symbol,
;; then it should be a list whose car is the function name and whose cdr is
;; the debugging info alist.

;; Our arg can be a function or a function spec.
(DEFUN DEBUGGING-INFO (FUNCTION)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (CL:TYPECASE FUNCTION
    (COMPILED-FUNCTION
      (COMPILED-FUNCTION-DEBUGGING-INFO FUNCTION))
    (SYS:GENERIC-FUNCTION
      (EXPAND-GENERIC-FUNCTION-DEBUGGING-INFO FUNCTION))
    (SYMBOL
      (AND (FBOUNDP FUNCTION)
	   (DEBUGGING-INFO (FSYMEVAL FUNCTION))))
    ((CL:SATISFIES VALIDATE-FUNCTION-SPEC)
     (DEBUGGING-INFO (VALID-FUNCTION-DEFINITION FUNCTION)))
    ((CL:SATISFIES INTERPRETED-FUNCTION-P)
     (INTERPRETED-FUNCTION-DEBUGGING-INFO FUNCTION))
    (SYS:LEXICAL-CLOSURE
      (DEBUGGING-INFO (LEXICAL-CLOSURE-FUNCTION FUNCTION)))
    (CLOS-INTERNALS:FUNCALLABLE-INSTANCE
      (AND (FBOUNDP 'CLOS-INTERNALS:DEBUGGING-INFORMATION-FUNCTION)
	   (CLOS-INTERNALS:DEBUGGING-INFORMATION-FUNCTION FUNCTION)))
    (CL:CONS
      (SELECTQ (CAR FUNCTION)
	((SPECIAL)
	 ;; Prefer the special-form definition, if any.
	 (DEBUGGING-INFO (OR (THIRD FUNCTION) (SECOND FUNCTION)))))))) 

;;; Function and macro defining.

;; Undo function for DEFF
(DEFUN (:PROPERTY DEFF :UNDO-FUNCTION) (FORM)
  (UNDO-FUNCTION-DEFINITION (CADR FORM)))

;;; Local declaration types which are incorporated into the function debugging info by DEFUN
(DEFPROP ARGLIST T DEBUG-INFO)
(DEFPROP VALUES T DEBUG-INFO)
(DEFPROP RETURN-LIST T DEBUG-INFO)		;Old name for VALUES
(DEFPROP FUNCTION-PARENT T DEBUG-INFO)

(DEFMACRO DEFUN-INTERNAL (LAMBDA FUNCTION-SPEC LAMBDA-LIST &BODY BODY
			  &ENVIRONMENT ENVIRONMENT)
  (LET ((INLINE (AND (EQ (OR (COMPILER:FILE-DECLARATION FUNCTION-SPEC 'LISP:INLINE)
			     (FUNCTION-SPEC-GET FUNCTION-SPEC 'LISP:INLINE))
			 'LISP:INLINE)
		     ;; Inline can't handle environments
		     (OR (NULL-ENVIRONMENT-P ENVIRONMENT)
			 (NULL (LT:FORM-REFERENCES-ENVIRONMENT-P
				 `(FUNCTION (,LAMBDA ,LAMBDA-LIST ,@BODY))
				 ENVIRONMENT
				 ;; Inline forms don't expand their macros, so have
				 ;; to punt even for a macro reference.
				 T))))))
    (MULTIPLE-VALUE-BIND (DECLARATIONS REAL-BODY)
	(SI:FIND-BODY-DECLARATIONS BODY ENVIRONMENT LAMBDA-LIST)
      (MULTIPLE-VALUE-BIND (INLINE-DECLARATION METHOD)
	  (WHEN INLINE
	    (LT::CONSTRUCT-INLINE-FORM-DECLARATION
	      FUNCTION-SPEC LAMBDA-LIST
	      `(,@DECLARATIONS
		,@REAL-BODY)
	      NIL))
	(LOOP FOR DECLARATION IN DECLARATIONS DOING
	  (WHEN (AND (LISP:CONSP DECLARATION)
		     (LISP:ASSOC 'SYS:FUNCTION-NAME (CDR DECLARATION)))
	    (RETURN))
	      FINALLY
		(PUSH `(DECLARE (SYS:FUNCTION-NAME ,FUNCTION-SPEC)) DECLARATIONS))
	`(PROGN
	   (EVAL-WHEN (COMPILE)
	     (COMPILER:FILE-DECLARE ',FUNCTION-SPEC 'COMPILER:DEF ',METHOD))
	   (FDEFINE ',FUNCTION-SPEC
		    #'(,LAMBDA ,LAMBDA-LIST
		       ,@DECLARATIONS
		       ,INLINE-DECLARATION
		       ,@(SI:WRAP-BODY-WITH-BLOCK FUNCTION-SPEC REAL-BODY))
		    T)
	   ',FUNCTION-SPEC)))))

(DEFMACRO FUTURE-COMMON-LISP:DEFUN (FUNCTION-SPEC LAMBDA-LIST &BODY BODY)
  `(DEFUN-INTERNAL FUTURE-COMMON-LISP:LAMBDA ,FUNCTION-SPEC ,LAMBDA-LIST ,@BODY))

(DEFMACRO DEFUN (&WHOLE FORM FUNCTION-SPEC LAMBDA-LIST &BODY BODY)
  (WHEN (VARIABLE-BOUNDP #'DEFUN-COMPATIBILITY)
    (LET* ((TAIL (CDR FORM))
	   (NEW-FORM (DEFUN-COMPATIBILITY TAIL :WARN-IF-OBSOLETE T)))
      (UNLESS (EQ TAIL (CDR NEW-FORM))
	(RETURN-FROM DEFUN NEW-FORM))))
  `(DEFUN-INTERNAL LAMBDA ,FUNCTION-SPEC ,LAMBDA-LIST ,@BODY))

;; Undo function for DEFUN
(DEFUN (:PROPERTY DEFUN :UNDO-FUNCTION) (FORM)
  ;; Turn old Maclisp DEFUNs into standard ones
  (SETQ FORM (DEFUN-COMPATIBILITY (CDR FORM)))
  (IF (EQ (CAR FORM) 'DEFUN)
      ;; Same as (FDEFINE <function> <something>)
      (UNDO-FUNCTION-DEFINITION (CADR FORM))
      (LOGIN-FORMS-1 (LIST FORM))))

(DEFUN UNDO-FUNCTION-DEFINITION (FSPEC)
  (IF (FDEFINEDP FSPEC)
      `(FDEFINE ',FSPEC ',(FDEFINITION FSPEC))
      `(FUNDEFINE ',FSPEC)))

(CL:PROCLAIM '(SPECIAL UNDO-DECLARATIONS-FLAG LOCAL-DECLARATIONS FILE-LOCAL-DECLARATIONS))

(DEFMACRO MACRO (NAME LAMBDA-LIST &BODY BODY &ENVIRONMENT ENVIRONMENT)
  (DECLARE (ARGLIST NAME (FORM ENVIRONMENT) &BODY BODY))
  (OR (SYMBOLP NAME) (SETQ NAME (SI:STANDARDIZE-FUNCTION-SPEC NAME)))
  (UNLESS (AND (CL:CONSP LAMBDA-LIST)
	       (NOT (CL:MEMBER (FIRST LAMBDA-LIST) LAMBDA-LIST-KEYWORDS))
	       (OR (NULL (CDR LAMBDA-LIST))
		   (AND (CL:CONSP (CDR LAMBDA-LIST))
			(NOT (CL:MEMBER (SECOND LAMBDA-LIST) LAMBDA-LIST-KEYWORDS))
			(NULL (CDDR LAMBDA-LIST)))))
    (ERROR "The lambda list ~s for MACRO does not consist of the documented two required ~
            variables, or the obsolete one required variable."
	   LAMBDA-LIST))
  (MULTIPLE-VALUE-BIND (DECLARATIONS REAL-BODY)
      (SI:FIND-BODY-DECLARATIONS BODY ENVIRONMENT LAMBDA-LIST)
    (LOOP FOR DECLARATION IN DECLARATIONS DOING
      (WHEN (AND (CL:CONSP DECLARATION)
		 (CL:ASSOC 'SYS:FUNCTION-NAME (CDR DECLARATION)))
	(RETURN))
	  FINALLY
	    (PUSH `(DECLARE (SYS:FUNCTION-NAME ,NAME)) DECLARATIONS))
    (LET* ((FUNCTION `(LAMBDA ,LAMBDA-LIST
			,@DECLARATIONS
			,@REAL-BODY))
	   (FORM
	     (IF (CDR LAMBDA-LIST)
		 `(LIST 'SPECIAL #',FUNCTION)
		 `(CONS 'MACRO #',FUNCTION))))
      `(PROGN
	 (EVAL-WHEN (COMPILE)
	   ;; If this is for a compilation, check that it wasn't
	   ;; previously assumed to be a function.
	   (COMPILER:MAYBE-WARN-ABOUT-MACRO-DEFINITION ',NAME '(SPECIAL))
	   ;; Put macro definition where it belongs (don't really define it if compiling)
	   (COMPILER:FILE-DECLARE ',NAME 'DEF ,FORM))
	 (FDEFINE ',NAME ,FORM T)
	 ',NAME))))

;;; Do some simple syntax checking of a lambda-list, to try to catch
;;; simple errors that beginners sometimes make.  Warn if anything
;;; goes wrong.
(DEFUN CHECK-LAMBDA-LIST-SYNTAX (LIST)
  (UNLESS (CL:LISTP LIST)			;old-style listp loses
    (COMPILER:WARN () "The lambda list, ~S, is not actually a list" LIST))
  (DO ((X LIST (CDR X))
       (STATE NIL)
       ELEM)
      ((ATOM X)
       (WHEN X
	 (COMPILER:WARN () "The lambda list, ~S, is a dotted list" LIST)))
    (SETQ ELEM (CAR X))
    (COND ((SYMBOLP ELEM)
	   (IF (OR (NULL ELEM) (EQ ELEM 'T) (KEYWORDP ELEM))
	       (COMPILER:WARN () "There is a ~S in the lambda list: ~S" ELEM LIST))
	   (IF (AND (CHAR-EQUAL (AREF (GET-PNAME ELEM) 0) #/&)
		    (NOT (MEMQ ELEM LAMBDA-LIST-KEYWORDS)))
	       (COMPILER:WARN () "~S appears to be a misspelled &-keyword" ELEM))
	   (LET ((ORDER (MEMQ ELEM '(&OPTIONAL &REST &KEY &ALLOW-OTHER-KEYS &AUX))))
	     (WHEN ORDER
	       (COND ((EQ ELEM STATE)
		      ;; This clause isn't really necessary since the next one is
		      ;; technically gonna catch the problem anyway, but for
		      ;;  (&REST X &REST Y)
		      ;; it probably looks better to say "&REST appears twice in ..."
		      ;; rather than "&REST appears before &REST in ...".
		      ;; Of course,
		      ;;  (&OPTIONAL X &REST Y &OPTIONAL Z)
		      ;; will still say "&REST appears before &OPTIONAL in ..." but
		      ;; it's probably not worth the code it would take to make that
		      ;; come out pretty. -kmp 27-Jul-90
		      (COMPILER:WARN () "~S appears twice in ~S" ELEM LIST))
		     ((MEMQ STATE ORDER)
		      (COMPILER:WARN () "~S appears before ~S in ~S" STATE ELEM LIST)))
	       (CL:CASE ELEM
		 (&REST
		   (LET ((L (CDR X)))
		     (DO () ((OR (ATOM L) (NOT (MEMQ (CAR L) '(&SPECIAL &LOCAL))))) (POP L))
		     (COND ((ATOM L)
			    (COMPILER:WARN () "Variable name missing after &REST"))
			   ((MEMQ (CAR L) LAMBDA-LIST-KEYWORDS)
			    (COMPILER:WARN () "Variable name missing between &REST and ~S"
					   (CAR L))))))
		 (&ALLOW-OTHER-KEYS
		   (UNLESS (EQ STATE '&KEY)
		     (COMPILER:WARN () "&ALLOW-OTHER-KEYS appears without &KEY"))))
	       (SETQ STATE ELEM)
	       )))
	  ((LISTP ELEM)
	   (DO ((X ELEM (CDR X)))
	       ((ATOM X)
		(WHEN X
		  (COMPILER:WARN () "The lambda list element, ~S, is a dotted list" ELEM))))
	   (WHEN (> (LENGTH ELEM) 3)
	     (COMPILER:WARN () "The lambda list element, ~S, is too long" ELEM)))
	  (T
	   (COMPILER:WARN () "The lambda list element, ~S, is of the wrong data type"
			  ELEM)))))


;;; Mechanism for deriving function names from other names
;;; Motivation is naming of generics for SETFing other generics
;;; Implementation is as trivial as possible, just use property lists
;;; and forwarded-symbol-cell-tables.
;;; ---- No!  Don't clutter the forwarded-symbol-cell-tables!  They are
;;; ---- there to localize symbol cells, and cluttering them with function
;;; ---- cells which only get referenced during EVAL is silly.  Instead
;;; ---- put a similar table on the derived-function-type plist.
;;; PROPERTY is indicator on plist of DERIVED-FROM function name; the
;;; value of the property is function-cell-location.
;;; Use DEFINE-DERIVED-FUNCTION-TYPE macro to define such function-spec types.

(DEFUN DERIVED-FUNCTION-SPEC-HANDLER (FUNCTION FUNCTION-SPEC &OPTIONAL ARG1 ARG2)
  (LET* ((TYPE (FIRST FUNCTION-SPEC))
	 (DERIVED-FROM (SECOND FUNCTION-SPEC))
	 (PROPERTY (AND (SYMBOLP TYPE) (GET TYPE 'DERIVED-FUNCTION-PROPERTY))))
    (IF (AND (= (LENGTH FUNCTION-SPEC) 2) PROPERTY (VALIDATE-FUNCTION-SPEC DERIVED-FROM))
	(LET ((CELL (FUNCTION-SPEC-GET DERIVED-FROM PROPERTY)))
	  (SELECTQ FUNCTION
	    (VALIDATE-FUNCTION-SPEC T)
	    ((FDEFINE FDEFINITION-LOCATION)
	     (UNLESS CELL
	       (PROCESS:WITH-LOCK (*DERIVED-FUNCTION-CELL-LOCK*)
		 (UNLESS CELL
		   ;; Get the cell table.
		   (LET* ((CELL-TABLES (GET TYPE 'DERIVED-FUNCTION-CELL-TABLES))
			  (CELL-TABLE (CAR CELL-TABLES))
			  FILL-POINTER TABLE-LENGTH)
		     (WHEN CELL-TABLE
		       (SETQ FILL-POINTER (FILL-POINTER CELL-TABLE)
			     TABLE-LENGTH (ARRAY-LENGTH CELL-TABLE)))
		     ;; No room or no table -- create one.
		     (UNLESS (AND CELL-TABLE (< FILL-POINTER TABLE-LENGTH))
		       (SETQ TABLE-LENGTH (OR (GET TYPE 'DERIVED-FUNCTION-CELL-TABLE-LENGTH)
					      400.)
			     CELL-TABLE (MAKE-ARRAY TABLE-LENGTH
						    :FILL-POINTER 0
						    :AREA PERMANENT-STORAGE-AREA)
			     FILL-POINTER 0)
		       (SETF (GET TYPE 'DERIVED-FUNCTION-CELL-TABLES)
			     (CONS-IN-AREA CELL-TABLE CELL-TABLES PERMANENT-STORAGE-AREA)))
		     (SETF (FILL-POINTER CELL-TABLE) (1+ FILL-POINTER))
		     (SETQ CELL (ALOC CELL-TABLE FILL-POINTER))
		     (LOCATION-MAKUNBOUND CELL (LIST-IN-AREA PERMANENT-STORAGE-AREA
							     TYPE DERIVED-FROM))
		     (FUNCTION-SPEC-PUTPROP DERIVED-FROM CELL PROPERTY)))))
	     (IF (EQ FUNCTION 'FDEFINE)
		 (SETF (LOCATION-CONTENTS CELL) ARG1)
		 CELL))
	    (FDEFINITION (IF CELL (LOCATION-CONTENTS CELL)
			     (ERROR 'UNDEFINED-FUNCTION :FUNCTION-NAME FUNCTION-SPEC)))
	    (FDEFINEDP (AND CELL (LOCATION-BOUNDP CELL)))
	    (FUNDEFINE (LOCATION-MAKUNBOUND CELL FUNCTION-SPEC))
	    (COMPILER-FDEFINE (COMPILER:FILE-DECLARE DERIVED-FROM PROPERTY ARG1))
	    (COMPILER-FDEFINEDP (COMPILER:FILE-DECLARATION DERIVED-FROM PROPERTY))
	    (DEFINITION-HAS-LOCATION-P T)
	    (OTHERWISE (FUNCTION-SPEC-DEFAULT-HANDLER FUNCTION FUNCTION-SPEC ARG1 ARG2))))
      (WHEN (NEQ FUNCTION 'VALIDATE-FUNCTION-SPEC)
	(ERROR "~S is not a valid function spec" FUNCTION-SPEC)))))



;Push a random declaration on for the duration of a file being compiled.
(DEFUN PUTDECL (NAME PROP VALUE)
  (IF UNDO-DECLARATIONS-FLAG
      (COMPILER:FILE-DECLARE NAME PROP VALUE)
      (PUTPROP NAME VALUE PROP)))

(CL:DEFSETF GETDECL PUTDECL)

;Get a declaration from compile-time or run-time environment
(DEFUN GETDECL (NAME PROP)
  (BLOCK GETDECL
    (DOLIST (DECL LOCAL-DECLARATIONS)
      (AND (EQ (FIRST DECL) PROP)
	   (EQ (SECOND DECL) NAME)
	   (RETURN-FROM GETDECL (THIRD DECL))))
    (MULTIPLE-VALUE-BIND (VALUE FOUND)
	(COMPILER:FILE-DECLARATION NAME PROP)
      (WHEN FOUND (RETURN-FROM GETDECL VALUE)))
    (GET NAME PROP)))



;;; Local-declaration caching is a feature turned on by certain layered products
;;; such as the Fortran compiler, to speed up the compilation of large functions
;;; by speeding up things such as variable declaration lookup

(DEFVAR *CACHE-LOCAL-DECLARATIONS* NIL)
(DEFVAR *LOCAL-DECLARATIONS-CACHE*)
(DEFVAR *LOCAL-DECLARATIONS-LAST-LOCAL-DECLARATIONS*)

(DEFMACRO COMPILER:CACHING-LOCAL-DECLARATIONS (&BODY BODY)
  `(COMPILER-LET ((*CACHE-LOCAL-DECLARATIONS* T)
		  (*LOCAL-DECLARATIONS-CACHE* NIL)
		  (*LOCAL-DECLARATIONS-LAST-LOCAL-DECLARATIONS* NIL))
     . ,BODY))

(DEFUN CACHED-LOCAL-DECLARATION (FUNCTION ARG &AUX ELEM SUBELEM)
  (IF (NOT *CACHE-LOCAL-DECLARATIONS*)
      (FUNCALL FUNCTION ARG)
      (COND ((NULL *LOCAL-DECLARATIONS-CACHE*)
	     (SETQ *LOCAL-DECLARATIONS-CACHE* (CL:MAKE-HASH-TABLE))
	     (SETQ *LOCAL-DECLARATIONS-LAST-LOCAL-DECLARATIONS* LOCAL-DECLARATIONS))
	    ((NEQ LOCAL-DECLARATIONS *LOCAL-DECLARATIONS-LAST-LOCAL-DECLARATIONS*)
	     (SEND *LOCAL-DECLARATIONS-CACHE* ':CLEAR-HASH)
	     (SETQ *LOCAL-DECLARATIONS-LAST-LOCAL-DECLARATIONS* LOCAL-DECLARATIONS))
	    (T
	     (SETQ ELEM (SEND *LOCAL-DECLARATIONS-CACHE* ':GET-HASH ARG))
	     (SETQ SUBELEM (ASSQ FUNCTION ELEM))))
      (UNLESS SUBELEM
	(SETQ SUBELEM (CONS FUNCTION (FUNCALL FUNCTION ARG)))
	(SEND *LOCAL-DECLARATIONS-CACHE* ':PUT-HASH ARG (CONS SUBELEM ELEM)))
      (CDR SUBELEM)))

(DEFUN DECLARED-DEFINITION (FUNCTION)
  (CACHED-LOCAL-DECLARATION #'DECLARED-DEFINITION-INTERNAL FUNCTION))

;; Given a function-spec, find any definition it has been declared to have
;; for compilation purposes, and return it.
;; Unless the definition is a macro, unencapsulate it.
;; Do not UNDIGEST the definition -- that could lose interpreted debugging-info.
(DEFUN DECLARED-DEFINITION-INTERNAL (FUNCTION)
  (LET ((DEF (BLOCK DEF
	       (DOLIST (L LOCAL-DECLARATIONS)
		 (WHEN (AND (EQ (CAR L) 'DEF)
			    (EQUAL (CADR L) FUNCTION))	;Not EQ, might be a list
		   (RETURN-FROM DEF (CDDR L))))
	       (MULTIPLE-VALUE-BIND (DEF FOUND)
		   (COMPILER:FILE-DECLARATION FUNCTION 'DEF)
		 (WHEN FOUND (RETURN-FROM DEF DEF)))
	       ;;--- well???
	       (WHEN (FDEFINEDP FUNCTION)
		 (LET ((DEF (FDEFINITION FUNCTION)))
		   (RETURN-FROM DEF
		     (IF (OR (ATOM DEF)
			     (EQ (CAR DEF) 'MACRO)
			     (EQ (CAR DEF) 'SPECIAL))
			 DEF
			 (FDEFINITION (UNENCAPSULATE-FUNCTION-SPEC FUNCTION))))))
	       NIL)))
    (COND ((NULL DEF) NIL)
	  ((SYMBOLP DEF) (DECLARED-DEFINITION DEF))
	  (T DEF))))



(DEFCONST *SETF-PROPERTIES*
	  'LT::(DERIVED-SETF-FUNCTION DERIVED-FUTURE-COMMON-LISP-SETF-FUNCTION
				      SETF-EQUIVALENCE SETF-METHOD TRIVIAL-SETF-METHOD
				      SETF-SEND-METHOD TRIVIAL-SETF-SEND-METHOD
				      SETF-SEND-METHOD-WITH-ENVIRONMENT
				      SETF-METHOD-WITH-ENVIRONMENT))

(DEFUN DEFINE-SETF-PROPERTY (NAME PROPERTY VALUE)
  (DOLIST (PROP *SETF-PROPERTIES*)
    (IF (EQ PROP PROPERTY)
	(SETF (FUNCTION-SPEC-GET NAME PROP) VALUE)
	(FUNCTION-SPEC-REMPROP NAME PROP))))

(DEFUN DEFINE-COMPILE-TIME-SETF-PROPERTY (NAME PROPERTY VALUE)
  (DOLIST (PROP *SETF-PROPERTIES*)
    (COMPILER:FILE-DECLARE NAME PROP (IF (EQ PROP PROPERTY) VALUE NIL))))

(DEFCONST *LOCF-PROPERTIES*
	  'LT::(DERIVED-LOCF-FUNCTION SETF-EQUIVALENCE LOCF-METHOD
				      LOCF-METHOD-WITH-ENVIRONMENT TRIVIAL-LOCF-METHOD))

(DEFUN DEFINE-LOCF-PROPERTY (NAME PROPERTY VALUE)
  (DOLIST (PROP *LOCF-PROPERTIES*)
    (IF (EQ PROP PROPERTY)
	(SETF (FUNCTION-SPEC-GET NAME PROP) VALUE)
	(FUNCTION-SPEC-REMPROP NAME PROP))))

(DEFUN DEFINE-COMPILE-TIME-LOCF-PROPERTY (NAME PROPERTY VALUE)
  (DOLIST (PROP *LOCF-PROPERTIES*)
    (COMPILER:FILE-DECLARE NAME PROP (IF (EQ PROP PROPERTY) VALUE NIL))))

;;; Derived function types used by instance-variable accessors
;;; Defined here so they will exist early enough in the cold load

(DEFINE-DERIVED-FUNCTION-TYPE CL:SETF LT::DERIVED-SETF-FUNCTION 2400.)
(DEFINE-DERIVED-FUNCTION-TYPE FUTURE-COMMON-LISP:SETF LT::DERIVED-FUTURE-COMMON-LISP-SETF-FUNCTION 2400.)

(DEFINE-DERIVED-FUNCTION-TYPE SCL:LOCF LT::DERIVED-LOCF-FUNCTION 1600.)
(DEFINE-DERIVED-FUNCTION-TYPE COMPILER:COMPILER-MACRO COMPILER:COMPILER-MACRO)

(DEFINE-FUNCTION-SPEC-HANDLER :INITIALIZATION (FUNCTION FUNCTION-SPEC &OPTIONAL ARG1 ARG2)
  (SCL:DESTRUCTURING-BIND (&OPTIONAL LIST-NAME ENTRY-NAME)
     (IF (LISTP FUNCTION-SPEC) (CDR FUNCTION-SPEC) NIL)
    (LET* ((VALID (AND FUNCTION-SPEC
		       (LISTP FUNCTION-SPEC)
		       (SYMBOLP LIST-NAME)
		       LIST-NAME
		       (OR (STRINGP ENTRY-NAME)
			   (SYMBOLP ENTRY-NAME))))
	   (INIT-ENTRY (AND VALID
			    (BOUNDP LIST-NAME)
			    (CL:ASSOC ENTRY-NAME (CL:SYMBOL-VALUE LIST-NAME)
				      :TEST #'STRING-EQUAL))))
      (SELECTQ FUNCTION
	(VALIDATE-FUNCTION-SPEC (AND VALID 'INITIALIZATION))
	(FUNCTION-PARENT NIL)
	(FDEFINEDP (AND VALID INIT-ENTRY))
	((FDEFINE) (ERROR "It is not possible to define an initialization with FDEFINE."))
	((FDEFINITION) NIL)			; we could return the form,
						; but too many things would barf.
	((FDEFINITION-LOCATION) NIL)
	((GET)
	 (CL:CASE ARG1
	   ((:SOURCE-FILE-NAME)
	    (AND VALID INIT-ENTRY (SI:INIT-SOURCE-FILE INIT-ENTRY)))
	   (OTHERWISE (FUNCTION-SPEC-DEFAULT-HANDLER FUNCTION FUNCTION-SPEC ARG1 ARG2))))
	(OTHERWISE
	 (FUNCTION-SPEC-DEFAULT-HANDLER FUNCTION FUNCTION-SPEC ARG1 ARG2))))))

(DEFINE-FUNCTION-SPEC-HANDLER :LAMBDA-MACRO (FUNCTION FUNCTION-SPEC &OPTIONAL ARG1 ARG2)
  (LET ((SYMBOL (SECOND FUNCTION-SPEC)))
    (SELECTQ FUNCTION
      (VALIDATE-FUNCTION-SPEC (AND (= (LENGTH FUNCTION-SPEC) 2) (SYMBOLP SYMBOL)))
      (FDEFINE (PUTPROP SYMBOL ARG1 'LAMBDA-MACRO))
      ((FDEFINITION FDEFINEDP) (GET SYMBOL 'LAMBDA-MACRO))
      (FDEFINITION-LOCATION (LOCF (GET SYMBOL 'LAMBDA-MACRO)))	;Not perfect, but close
      (FUNDEFINE (SI:NREMPROP SYMBOL 'LAMBDA-MACRO))
      (OTHERWISE (FUNCTION-SPEC-DEFAULT-HANDLER FUNCTION FUNCTION-SPEC ARG1 ARG2)))))

(DEFLAMBDA-MACRO NAMED-LAMBDA (NAME LAMBDA-LIST &BODY BODY &ENVIRONMENT ENVIRONMENT)
  (MULTIPLE-VALUE-BIND (DECLARATIONS REAL-BODY)
      (SI:FIND-BODY-DECLARATIONS BODY ENVIRONMENT LAMBDA-LIST)
    (MULTIPLE-VALUE-BIND (FUNCTION-NAME OTHER-DECLARATIONS)
	(IF (SYMBOLP NAME)
	    (VALUES NAME NIL)
	    (VALUES (FIRST NAME) (CL:REST NAME)))
      `(LAMBDA ,LAMBDA-LIST
	 (DECLARE (SYS:FUNCTION-NAME ,FUNCTION-NAME))
	 (DECLARE ,@OTHER-DECLARATIONS)
	 ,@DECLARATIONS
	 ,@(WRAP-BODY-WITH-BLOCK FUNCTION-NAME REAL-BODY)))))

(DEFLAMBDA-MACRO SUBST (LAMBDA-LIST &BODY BODY)
  `(LAMBDA ,LAMBDA-LIST ,@BODY))

(DEFLAMBDA-MACRO NAMED-SUBST (NAME LAMBDA-LIST &BODY BODY)
  `(NAMED-LAMBDA ,NAME ,LAMBDA-LIST ,@BODY))


;;; Keep this consistent with the non-Genera version.
(CL:DEFPARAMETER CLOS-INTERNALS::*GENERIC-FUNCTION-NAME-VALID-SPEC-TYPES*
		 '(CLOS:SETF SCL:SETF SYS:LOCF :PROPERTY))

;;; Keep this consistent with the non-Genera version.
(DEFUN CLOS-INTERNALS:GENERIC-FUNCTION-NAME-VALID-P (FUNCTION-NAME)
  (OR (AND (SYMBOLP FUNCTION-NAME)
	   (NOT (SPECIAL-FORM-P FUNCTION-NAME)))
      (AND (CL:CONSP FUNCTION-NAME)
	   (CL:MEMBER (FIRST FUNCTION-NAME)
		      CLOS-INTERNALS::*GENERIC-FUNCTION-NAME-VALID-SPEC-TYPES*)
	   (VALIDATE-FUNCTION-SPEC FUNCTION-NAME NIL))))

;;; Keep these consistent with the non-Genera versions.

(CL:PROCLAIM '(CL:INLINE CLOS-INTERNALS:COMPILE-FILE-ENVIRONMENT-P))
(DEFUN CLOS-INTERNALS:COMPILE-FILE-ENVIRONMENT-P (ENVIRONMENT)
  (OR (EQ ENVIRONMENT 'FUTURE-COMMON-LISP:COMPILE-FILE)
      (AND (LISP:CONSP ENVIRONMENT)
	   (LISP:DOLIST (DCLS (SI:ENV-DECLARATIONS ENVIRONMENT) NIL)
	     (WHEN (LISP:ASSOC 'FUTURE-COMMON-LISP:COMPILE-FILE DCLS)
	       (RETURN T))))))
(CL:PROCLAIM '(CL:NOTINLINE CLOS-INTERNALS:COMPILE-FILE-ENVIRONMENT-P))

(DEFUN CLOS-INTERNALS::FBOUNDP-IN-ENVIRONMENT (FUNCTION-NAME ENVIRONMENT)
  (WHEN (CLOS-INTERNALS::COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
    (MULTIPLE-VALUE-BIND (VALUE FOUNDP)
	(COMPILER:FILE-DECLARATION FUNCTION-NAME 'FUTURE-COMMON-LISP:FDEFINITION)
      (DECLARE (IGNORE VALUE))
      (RETURN-FROM CLOS-INTERNALS::FBOUNDP-IN-ENVIRONMENT FOUNDP)))
  (FUTURE-COMMON-LISP:FBOUNDP FUNCTION-NAME))

(DEFPROP CLOS:DEFMETHOD DEFUN ZWEI:DEFINITION-FUNCTION-SPEC-TYPE)

(DEFUN (:PROPERTY CLOS:METHOD SYS:FUNCTION-SPEC-HANDLER)
       (FUNCTION FUNCTION-SPEC &OPTIONAL ARG1 ARG2)
  (MACROLET ((BARF (&REST ERROR-ARGS)		;So we don't error while validating
	       `(IF (EQ FUNCTION 'VALIDATE-FUNCTION-SPEC)
		    (RETURN-FROM CLOS:METHOD NIL)
		    (ERROR ,@ERROR-ARGS)))
	     (DOTTED-BARF ()
	       `(BARF "The function spec, ~S, is a dotted list, which is invalid"
		     FUNCTION-SPEC))
	     (SHORT-BARF ()
	       `(BARF "The function spec, ~s, is not a list of the form ~@
                      (~s generic-function specializers . qualifiers)"
		     FUNCTION-SPEC 'CLOS:METHOD)))
    ;; Defense against dotted lists causing an error while taking function-spec apart
    (LET* ((GENERIC-CONS (CDR FUNCTION-SPEC))
	   (SPECIALIZER-CONS
	     (PROGN
	       (UNLESS GENERIC-CONS (SHORT-BARF))
	       (UNLESS (CL:CONSP GENERIC-CONS) (DOTTED-BARF))
	       (CDR GENERIC-CONS)))
	   (SPECIALIZERS (CAR SPECIALIZER-CONS))
	   (QUALIFIERS
	     (PROGN
	       (UNLESS SPECIALIZER-CONS (SHORT-BARF))
	       (UNLESS (CL:CONSP SPECIALIZER-CONS) (DOTTED-BARF))
	       (CDR SPECIALIZER-CONS)))
	   (ENV (CL:CASE FUNCTION
		  (FDEFINITION-LOCATION (AND ARG1 'FUTURE-COMMON-LISP:COMPILE-FILE))
		  (COMPILER-FDEFINEDP 'FUTURE-COMMON-LISP:COMPILE-FILE)
		  (OTHERWISE NIL)))
	   (GENERIC-FUNCTION-NAME (CAR GENERIC-CONS))
	   (N 0))
      (LOOP WHILE QUALIFIERS DOING
	(UNLESS (CL:CONSP QUALIFIERS)
	  (BARF "The function spec, ~S, is a dotted list, which is invalid." FUNCTION-SPEC))
	(LET ((QUALIFIER (POP QUALIFIERS)))
	  (UNLESS (ATOM QUALIFIER)
	    (BARF "The function spec, ~S, contains an invalid qualifier, ~s"
		  FUNCTION-SPEC QUALIFIER))))
      (UNLESS (CLOS-INTERNALS:GENERIC-FUNCTION-NAME-VALID-P GENERIC-FUNCTION-NAME)
	(BARF "The generic function name, ~s, is invalid" GENERIC-FUNCTION-NAME))
      (LOOP WITH PLACE = SPECIALIZERS DOING
	(WHEN (NULL PLACE) (RETURN))
	(UNLESS (CL:CONSP PLACE)
	  (BARF "The specializers for the function spec ~s are a dotted list"
		FUNCTION-SPEC))
	(LET ((ELT (POP PLACE)))
	  (UNLESS (OR (SYMBOLP ELT)
		      (AND (CL:CONSP ELT)
			   (EQ (FIRST ELT) 'EQL)
			   (CL:CONSP (CDR ELT))
			   (NULL (CDDR ELT)))
		      (CLOS-INTERNALS::CLASSP ELT))
	    (BARF "The specializer ~s is not a symbol, a class, or a list of the form (EQL form)"
		  ELT))
	  (INCF N)))
      ;; Take care of the easy cases now
      (CL:CASE FUNCTION
	    (VALIDATE-FUNCTION-SPEC
	      (RETURN-FROM CLOS:METHOD T))
	    (DEFINITION-HAS-LOCATION-P
	      (RETURN-FROM CLOS:METHOD NIL)))
      ;; Handle some simple operations now before we start doing page-intensive operations.
      (CL:CASE FUNCTION
	((SYS:FDEFINITION-LOCATION)
	 (ERROR "CLOS methods don't have locations."))
	((SYS:FDEFINITION SYS:FDEFINEDP SYS:FUNDEFINE SI:COMPILER-FDEFINEDP
			  SYS:FUNCTION-PARENT SYS:FDEFINE)
	 (LET* ((GENERIC-FUNCTION
		  (WHEN (CLOS-INTERNALS::FBOUNDP-IN-ENVIRONMENT GENERIC-FUNCTION-NAME ENV)
		    (CLOS-INTERNALS::FDEFINITION-IN-ENVIRONMENT
		      GENERIC-FUNCTION-NAME ENV NIL)))
		(METHOD
		  (AND GENERIC-FUNCTION
		       ;; There won't be any generic functions until CLOS is loaded, so
		       ;; we won't get to the undefined type in the next clause if CLOS
		       ;; isn't loaded.
		       (CLOS-INTERNALS::GENERIC-FUNCTION-P GENERIC-FUNCTION)
		       (CL:FIND FUNCTION-SPEC (CLOS:GENERIC-FUNCTION-METHODS GENERIC-FUNCTION)
				:TEST #'CL:EQUAL
				:KEY #'CLOS-INTERNALS:FUNCTION-SPEC-OBJECT))))
	   ;; If the method was not found, it could be an error
	   (UNLESS (OR METHOD
		       (CL:MEMBER FUNCTION '(SCL:FDEFINEDP SCL:FUNDEFINE SI:COMPILER-FDEFINEDP
							   SYS:FUNCTION-PARENT)))
	     (ERROR "~s is not a defined method; it is not possible to ~s it."
		    FUNCTION-SPEC FUNCTION))
	   ;; Do what we were asked to do
	   (CL:CASE FUNCTION
	     (SYS:FDEFINE (FDEFINE METHOD ARG1))
	     (SYS:FDEFINITION (CLOS:METHOD-FUNCTION METHOD))
	     (SYS:FDEFINEDP METHOD)
	     (SYS:FUNDEFINE (WHEN METHOD (CLOS:REMOVE-METHOD GENERIC-FUNCTION METHOD)))
	     (SI:COMPILER-FDEFINEDP (NOT (NULL METHOD)))
	     (SYS:FUNCTION-PARENT
	       (AND METHOD (CLOS-INTERNALS:FUNCTION-PARENT-OBJECT METHOD))))))
	(OTHERWISE
	  (FUNCTION-SPEC-DEFAULT-HANDLER FUNCTION FUNCTION-SPEC ARG1 ARG2))))))

;; Linking

#+IMach
(DEFSUBST COMPILED-FUNCTION-LINKED (COMPILED-FUNCTION)
  (NOT (ZEROP (%P-LDB %%ENTRY-INSTRUCTION-LINKED-REFERENCES-EXIST-P COMPILED-FUNCTION))))

#+IMach
(CL:DEFSETF COMPILED-FUNCTION-LINKED (COMPILED-FUNCTION) (VALUE)
  `(PROGN (SETF (%P-LDB %%ENTRY-INSTRUCTION-LINKED-REFERENCES-EXIST-P ,COMPILED-FUNCTION)
		(IF ,VALUE 1 0))
	  ,VALUE))

#+IMach
(DEFUN FUNCTION-LINKED-P (FUNCTION)
  (TYPECASE FUNCTION
    (:COMPILED-FUNCTION (COMPILED-FUNCTION-LINKED FUNCTION))
    (:GENERIC-FUNCTION  (FLAVOR::GENERIC-FUNCTION-LINKED FUNCTION))))
