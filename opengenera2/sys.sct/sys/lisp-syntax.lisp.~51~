;;; -*- Syntax: Zetalisp; Mode: LISP; Package: SYSTEM-INTERNALS; Base: 8; Lowercase: T -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;;
;;; LISP-SYNTAX: Support for defining, undefining, and reading lisp-syntaxes.
;;;
;;;   Part of making lisp-syntax an extensible notion; consider what
;;;   Set Lisp Context Interlisp or Set Lisp Context Joshua should mean.

(defvar *known-lisp-syntaxes* nil
  "Registry of known lisp syntaxes.")

(defprop define-lisp-syntax "Lisp Syntax" definition-type-name)

(cl:defstruct (lisp-syntax
		(:print-function
		  (lambda (self stream depth)
		    (ignore depth)
		    (let ((pretty-name (lisp-syntax-pretty-name self)))
		      (if *print-escape*
			  (si:printing-random-object (self stream)
			    (format stream "Lisp-Syntax ~A" pretty-name))
			  (format stream pretty-name))))))
  (name-symbol nil)
  (readtable-place nil)				;Obsolete. Position retained for binary
					        ; file compatibility only. Remove in Rel8.
						; -kmp 29-Aug-89
  (pretty-name nil)
  (packages-must-use '())			; the package must use all of the elements
						; of one of these lists
  (short-name nil)
  (readtable nil)
  (default-package-use-list '())
  (relative-names '())				;To be used later,
						; for per-syntax relative names.
  (shadow-global-packages nil)			;Ditto: for shadowing global package system.

  (minor-mode-name nil)
  (user-package nil)
  (reasonable-packages '())
  (list-syntax-table nil)
  (additional-file-attribute-bindings '())
  (package-name-function nil)			;Interim slot. To be phased out in favor
						; of having COMPILER:PACKAGE-NAME-FOR-SYNTAX
						; just work directly off of the syntax's
						; RELATIVE-NAMES or some such.  Details to
						; be worked out. Anyway, for now this does
						; still get used. -kmp 29-Aug-89
  (entry-hook nil)
  (exit-hook nil)
  (documentation nil)
  (options nil)
  (inherits-from nil)				;Reserved for inheritance
						;Note: If this had been a major release,
						; I'd have just flavorized this, but I'm
						; trying not to break existing code, so
  						; we'll simulate some things like parentage.
  						; -kmp 28-Aug-89
  ;; Leave room for future extensions
  (plist '())
  (package-colon-mode :external)
  ;; No one should depend on using this function.  It is purely for use by the 
  ;; function SI:MAKE-PACKAGE-FOR-SYNTAX, and Cloe is the only known thing with
  ;; a dependency on actually filling this slot with something interesting.
  ;; As soon as that dependency by Cloe can be removed, this slot might be
  ;; recycled.
  (make-package-function 'cl:make-package)
  (default-base 10.)
  (package-root nil)
  (package-root-prefix nil)
  (feature-present-p-hook nil))

(defsubst lisp-syntax-external-name (lisp-syntax)
  ;; We renamed a slot in SI:LISP-SYNTAX. This is compatibility for the sake of any old
  ;; compiled code.  New code should prefer the accessor LISP-SYNTAX-PRETTY-NAME so
  ;; that we can remove support for this asap. -kmp 6-Sep-89
  (lisp-syntax-pretty-name lisp-syntax))



;;;Base flavor for all lisp-syntax-related errors
(defflavor lisp-syntax-error () (error) :abstract-flavor)

(defflavor lisp-syntax-not-found (name) (no-action-mixin lisp-syntax-error)
  :initable-instance-variables
  :gettable-instance-variables)

(defmethod (:report lisp-syntax-not-found) (stream)
  (format stream "~:\QUOTED-STRING\ is not a known syntax." name))

(defmethod (:document-proceed-type lisp-syntax-not-found :no-action) (stream)
  (format
    stream
    "Try to find syntax ~:\QUOTED-STRING\ again (presumably after loading its definition)."
    name))

(defmethod (:proceed lisp-syntax-not-found :new-name)
	   (&optional (new-name
			(accept 'lisp-syntax
				:prompt
				 (format nil "Syntax to use instead of ~:\QUOTED-STRING\" name)
				:default (current-lisp-syntax))))
  "Supply a different syntax name to use instead."
  ;; This is actually passing back the syntax, not the name, but we'll define
  ;; the contract to be that either is ok, just as it's ok for find-lisp-syntax.
  ;; -kmp 10-Sep-89
  (values ':new-name new-name))

(defmethod (:proceed lisp-syntax-not-found :create-syntax) (&key (inherits-from nil))
  (if (and (si:find-lisp-syntax name nil)
	   (cl:y-or-n-p "The syntax ~:\QUOTED-STRING\ is now defined.  Use it? " name))
      :no-action
      (values :create-syntax
	      (or (if inherits-from (find-lisp-syntax inherits-from))
		  (accept 'lisp-syntax
			  :prompt
			  (format nil
				  "Make new syntax ~:\QUOTED-STRING\ inherit from what syntax"
				  name)
			  :default (current-lisp-syntax))))))

(defmethod (:document-proceed-type lisp-syntax-not-found :create-syntax) (stream)
  (format stream "Define syntax ~:\QUOTED-STRING\ to inherit from some existing syntax." name))

(compile-flavor-methods lisp-syntax-not-found)



(eval-when (eval load compile) ;Needed at macro-expansion time.

(defun defaulted-syntax-options (parent my-name my-options)
  (flet ((remove-redundant-keys (list)
	   (do ((l list (cddr l))
		(r '() (cons (list (car l) (cadr l)) r)))
	       ((null l)
		(apply #'nconc (cl:delete-duplicates (nreverse r) :key #'car :from-end t))))))
    (let ((seen   (list my-name))
	  (result (list my-options)))
      (cl:loop (let ((parent-syntax (or (compiler:file-declaration parent 'define-lisp-syntax)
					(lisp-syntax-from-keyword parent))))
		 (when (not parent-syntax)
		   (return (remove-redundant-keys (apply #'append (nreverse result)))))
		 (cond ((typep parent-syntax 'lisp-syntax)
			(push (lisp-syntax-options parent-syntax) result)
			(setq parent (lisp-syntax-inherits-from parent-syntax)))
		       (t
			(push parent-syntax result)
			(setq parent (cl:getf parent-syntax :inherits-from))))
		 (when (memq parent seen)	;N^2, but shouldn't matter.
		   (error "Circular dependency: ~(~{~S ~}~S ...)" (reverse seen) parent))
		 (push parent seen))))))

)



;; Some hair to support boot-strapping from the cold load, and also
;; modular extensions to this facility later on.

;; An alist of (key definer-macro undefiner-function)

(eval-when (eval compile load)

(defprop define-lisp-syntax-definition-extension
	 "Lisp Syntax Definition Extension"
	 definition-type-name)

(defvar *lisp-syntax-definition-info* '())

(defmacro define-lisp-syntax-definition-extension (key definer-name &optional undefiner-name)
  `(eval-when (eval compile load)
     (define-lisp-syntax-definition-extension-1 ',key ',definer-name ',undefiner-name)))

(defun define-lisp-syntax-definition-extension-1 (key definer-name undefiner-name)
  (let ((entry (assoc key *lisp-syntax-definition-info*)))
    (when (not entry)
      (setq entry (list key nil nil))
      (setq *lisp-syntax-definition-info* (nconc *lisp-syntax-definition-info* (list entry))))
    (setf (nth 1 entry) definer-name)
    (setf (nth 2 entry) undefiner-name)
    (dolist (syntax *known-lisp-syntaxes*)
      (update-lisp-syntax-definition syntax))
    key))

)

(defun define-lisp-syntax-driver (syntax-name &rest options)
  (dolist (entry *lisp-syntax-definition-info*)
    (let ((definer (nth 1 entry)))
      (when definer (cl:apply definer syntax-name options)))))

(defun update-lisp-syntax-definition (syntax)
  ;; Somewhat kludgey for now, but it works.
  (let ((sys:inhibit-fdefine-warnings t))
    (eval (cl:apply #'define-lisp-syntax-expander
		    (lisp-syntax-name-symbol syntax)
		    (lisp-syntax-options syntax)))))

(defun undefine-lisp-syntax (syntax-name)
  (dolist (entry *lisp-syntax-definition-info*)
    (let ((undefiner (nth 2 entry)))
      (when undefiner (funcall undefiner syntax-name)))))



(defmacro define-lisp-syntax (name &rest options)
  ;; Note that some highly experimental and/or obsolete options
  ;; are not included in this arglist.
  (declare (arglist name &key
		    pretty-name additional-file-attribute-bindings default-base
		    default-package-use-list documentation entry-hook exit-hook
		    inherits-from list-syntax-table minor-mode-name minor-mode-string
		    package-colon-mode package-root package-root-prefix packages-must-use
		    readtable relative-names shadow-global-packages short-name user-package))
  `(sys:multiple-definition ,name define-lisp-syntax
     ,(cl:apply #'define-lisp-syntax-expander name options)))

(defun define-lisp-syntax-expander (name &rest options
			      &key ((:readtable the-readtable)) pretty-name
			      (packages-must-use '())
			      short-name relative-names
			      shadow-global-packages default-package-use-list
			      reasonable-packages user-package
			      additional-file-attribute-bindings
			      package-name-function entry-hook exit-hook
			      inherits-from documentation
			      &allow-other-keys)
  (declare (zwei:indentation 1 1))
  (declare (ignore packages-must-use relative-names shadow-global-packages
		   default-package-use-list user-package
		   additional-file-attribute-bindings 
		   entry-hook exit-hook reasonable-packages))
  "Defines a new lisp syntax."
  (setq options (cl:copy-list options))
  (cl:check-type name cl:keyword)
  (check-arg the-readtable (or (not (atom the-readtable))
			       (and (symbolp the-readtable)
				    (not (null the-readtable)))
			       (and (cl:constantp the-readtable)
				    (cl:typep (eval the-readtable) 'cl:readtable))
			       ;; NIL is ok only if we're inheriting. Such info
			       ;; will be inherited at load time.
			       (and (null the-readtable) inherits-from))
		 "a form which will evaluate to a readtable")
  (cl:check-type documentation (or string null) "a documentation string or NIL")
  (cl:check-type pretty-name (or string null) "a pretty name or NIL")
  (cl:check-type short-name (or string null) "a short name or NIL")
  ;; The function we're likely to receive has a high likelihood of getting
  ;; patched--at least in the case of system syntaxes, and maybe for users too.
  ;; Having this be a function name rather than a function assures us that the
  ;; necessary indirection to the latest definition will occur.  Of course, we
  ;; could allow a non-constant form that evaluates to a symbol, but that's too
  ;; hard to check and not likely to be necesary in practice anyway. -kmp 29-Aug-89
  (check-arg package-name-function (or (null package-name-function)
				       (and (not (atom package-name-function))
					    (eq (car package-name-function) 'quote)
					    (symbolp (cadr package-name-function))))
	     "a quoted package name function name, or NIL")
  (let* ((pretty-name (or pretty-name (cl:string-capitalize name)))
	 (short-name (or short-name pretty-name)))
    (let ((defaulted-options
	    (defaulted-syntax-options inherits-from name
	      `(:pretty-name ,pretty-name
		:short-name ,short-name
		:readtable ,the-readtable
		:inherits-from ,inherits-from
		:options ',options
		,@options))))
      `(progn
	 (eval-when (compile)
	   (compiler:file-declare ',name 'define-lisp-syntax ',defaulted-options))
	 ;; do some bookkeeping
	 (define-lisp-syntax-driver ',name ,@defaulted-options)
	 ;; return the name
	 ',name))))

(defun package-satisfies-syntax (the-package the-syntax)
  (let ((packages-in-use (package-use-list the-package)))
    (dolist (package-names-must-use
	      ;; Permit a packages-must-use list instead of a syntax, for cases where
	      ;; the syntax isn't yet fully constructed.
	      (if (typep the-syntax 'lisp-syntax)
		  (lisp-syntax-packages-must-use the-syntax)
		  the-syntax))
      (let ((possible-packages-to-use (mapcar #'pkg-find-package ;Yes, relative to Zetalisp!
					      package-names-must-use)))
	(when (or
		;; Package either uses all packages in the list
		(not (cl:set-difference possible-packages-to-use packages-in-use))
		;; or else it is the lone package in the list
		(equal possible-packages-to-use (list the-package)))
	  (return t))))))

(defun turn-on-lisp-syntax (syntax-name &optional force-p)
  (let* ((syntax (find-lisp-syntax syntax-name))
	 (pretty-name (lisp-syntax-pretty-name syntax))
	 (the-readtable (lisp-syntax-readtable syntax)))
    (unless (and (eq syntax (current-lisp-syntax)) (not force-p))
      (sys:without-aborts ("The Lisp syntax is being globally changed to ~A." pretty-name)
	(let ((hook (lisp-syntax-exit-hook syntax))) (if hook (funcall hook)))
	(cl:setf (standard-value 'readtable :global-p t :setq-p t) the-readtable
		 (standard-value 'readtable             :setq-p t) the-readtable)
	(si:set-default-lisp-syntax syntax)
	(let ((package-standard-value (standard-value 'package :global-p t))
	      (user-package (lisp-syntax-user-package syntax)))
	  (when (or
		  ;; If the current standard value of CL:*PACKAGE* is one of the
		  ;; USER packages of another syntax, then don't make a fuss about
		  ;; the need to change packages at this point--the user presumably
		  ;; expects the change.
		  (and (neq package-standard-value user-package)
		       (cl:member package-standard-value *known-lisp-syntaxes*
				  :key #'lisp-syntax-user-package))
		  ;; Otherwise, the user is in some custom package, so verify
		  ;; that the package is suitable.  If it's not, tell the user it's
		  ;; not.  He can always use Set Package to get back if he didn't like this.
		  (unless (package-satisfies-syntax package-standard-value syntax)
		    (format error-output
			    "~& Package ~A is not a ~A package.  ~A will be used instead."
			    package-standard-value pretty-name user-package)
		    t))
	    ;; Really make the change...
	    (cl:setf (standard-value 'package :global-p t :setq-p t) user-package
		     (standard-value 'package             :setq-p t) user-package)))
	(let ((hook (lisp-syntax-entry-hook syntax))) (if hook (funcall hook)))))))

(defun readtable-for-syntax (syntax-name)
  (let ((syntax (find-lisp-syntax syntax-name nil)))
    (if syntax
	(lisp-syntax-readtable syntax)
	;; Be fault tolerant...
	standard-readtable)))

(defun lisp-syntax-from-keyword (syntax-keyword)
  (cl:find syntax-keyword *known-lisp-syntaxes* :key #'lisp-syntax-name-symbol))

(defun lisp-syntax-from-string (syntax-name)
  (cl:find syntax-name *known-lisp-syntaxes*
	   :test #'(lambda (string syntax)
		     (or (string-equal string (lisp-syntax-pretty-name syntax))
			 (string-equal string (lisp-syntax-name-symbol syntax))
			 (string-equal string (lisp-syntax-short-name  syntax))))))

(defun lisp-syntax-from-base (default-base)
  (cl:find default-base *known-lisp-syntaxes* :key #'lisp-syntax-default-base))

(defun lisp-syntax-from-package (pkg)
  (cl:find pkg *known-lisp-syntaxes* :test #'package-satisfies-syntax))

(defun query-handle-syntax-not-found (condition)
  (let ((options (nconc (mapcan #'(lambda (x)
				    (if (dbg:proceed-type-p condition (cadr x)) (ncons x)))
				'(("Use another name" :new-name)
				  ("Create" :create-syntax)
				  ("Try again" :no-action)))
			'(("Abort" :abort)))))
    (let ((action (accept `((scl:alist-member :alist ,options))
			  :prompt (format nil "~A~%Select an action (~{~A~^, ~})"
					  condition (mapcar #'car options)))))
      (if (eq action :abort) (signal 'abort))
      (dbg:proceed condition action))))

(defun create-lisp-syntax-with-parent (syntax parent)
  ;; Centralize this icky idiom for defining a new syntax so that when we come up
  ;; with a way to do the creation that doesn't require a call to EVAL, we can easily
  ;; find all the users. -kmp 25-Sep-89
  (let ((syntax-keyword (if (cl:keywordp syntax)
			    syntax
			    (intern (string-upcase syntax) pkg-keyword-package)))
	(parent-keyword (lisp-syntax-name-symbol (find-lisp-syntax parent))))
    (eval `(define-lisp-syntax ,syntax-keyword :inherits-from ,parent-keyword))))

(defun find-lisp-syntax (spec &optional (error-p t) default)
  (cl:loop
    (let ((result (cl:typecase spec
		    (lisp-syntax spec)
		    (cl:keyword  (lisp-syntax-from-keyword spec))
		    (string      (lisp-syntax-from-string spec))
		    (otherwise   nil))))
      (cond ((and (not result) error-p)
	     (condition-bind-default-if (eq error-p :query)
					((lisp-syntax-not-found
					   #'query-handle-syntax-not-found))
	       (if (and (or (cl:keywordp spec) (stringp spec))
			(not (string-equal spec "")))
		   (signal-proceed-case ((data) 'lisp-syntax-not-found :name spec)
		     ((:new-name) (setq spec data))
		     ((:create-syntax)
		      (create-lisp-syntax-with-parent spec data))
		     ((:no-action)))
		   (signal-proceed-case ((data) 'lisp-syntax-not-found :name spec)
		     ((:new-name) (setq spec data))))))
	    (t
	      (return (or result (if default (find-lisp-syntax default)))))))))

(defun undefine-lisp-syntax-1 (syntax-name)
  "Flushes a lisp syntax."
  (let ((syntax (find-lisp-syntax syntax-name)))
    (setq *known-lisp-syntaxes* (cl:delete syntax *known-lisp-syntaxes*))
    (let ((deleted-syntax-packages  (lisp-syntax-reasonable-packages syntax))
	  (deleted-syntax-readtable (lisp-syntax-readtable syntax)))
      (dolist (deleted-syntax-package deleted-syntax-packages)
	(when (cl:every #'(lambda (syntax)
			    (not (member deleted-syntax-package
					 (lisp-syntax-reasonable-packages syntax))))
			*known-lisp-syntaxes*)
	  (setq *reasonable-packages*
		(cl:delete deleted-syntax-package *reasonable-packages*))))
      (setq *reasonable-packages* (cl:copy-list *reasonable-packages*))
      (when (cl:every #'(lambda (syntax) (neq (lisp-syntax-readtable syntax)
					      deleted-syntax-readtable))
		      *known-lisp-syntaxes*)
	(setq *valid-readtables* (cl:delete deleted-syntax-readtable *valid-readtables*)))
      (setq *valid-readtables* (cl:copy-list *valid-readtables*)))))

(defun compatible-package-name-function-for-syntax (syntax-keyword)
  ;; This function is purely for use as a helper in code below that tries to
  ;; retain binary compatibility for Rel7 (i)bin files. This can go away in lockstep
  ;; with references to it in SI:DEFINE-LISP-SYNTAX-1 below on the next major
  ;; release boundary -- or when binary compatibility is finally allowed to break.
  ;; -kmp 30-Aug-89
  #'(lambda (package)
      (funcall (or (get syntax-keyword 'compiler:package-name-function)
		   ;; Be fault tolerant!
		   #'cl:package-name)
	       package)))

(defvar *show-lisp-syntax-compatibility-warnings* nil)	;Just in case we need to debug.

(defun define-lisp-syntax-1 (name
			     &rest options
			     &key pretty-name external-name short-name inherits-from
			          readtable-place relative-names shadow-global-packages
				  package-name-function package-root package-root-prefix
				  default-package-use-list
				  user-package reasonable-packages packages-must-use
				  ((:readtable the-readtable))
			     &allow-other-keys
			     &aux parent-syntax)
  (setq options (cl:copy-list options))		;Protect caller against side-effects.
  ;;  THIS CODE IS FOR BINARY COMPATIBILITY ONLY. 
  ;; It can be removed when binary compatibility restrictions
  ;; with 7.4 layered products are lifted--it won't break 7.4 user code, since it's not
  ;; supposed to be calling this function.
  ;; -kmp 30-Aug-89
  (when (not (getf options :options))		;Only old compiled code will enter this clause.
    (flet ((quote-keyword-options (options)
	     (do ((o options (cddr o))
		  (r '() (list* (if (cl:constantp (cadr o)) (cadr o) `',(cadr o)) (car o) r)))
		 ((null o) (nreverse r)))))
      (let ((old-options options))
	;; We need both the original and a copy for this part, so do another copy.
	(setq options (cl:copy-list options))
	;; The options :READTABLE-PLACE and :EXTERNAL-NAME are obsolete.
	;; Just remove them.  We have their contents in variables already.
	(cl:remf options :readtable-place)
	(cl:remf options :external-name)
	;; This is specifically to get around a programming error in Joshua.
	;; Packages must use should not need to contain both "CL" and "SCL"
	;; Rewrite (("JOSHUA" "CL" "SCL")) as (("JOSHUA" "CL") ("JOSHUA SCL")).
	(when packages-must-use			; :PACKAGES-MUST-USE is expected
	  (setq packages-must-use
		(mapcan #'(lambda (package-name-list)
			    (cond ((and (cl:member "CL"  package-name-list
						   :test #'string-equal)
					(cl:member "SCL" package-name-list
						   :test #'string-equal))
				   ;; This would be redundant
				   (let ((others (cl:remove "CL"
							    (cl:remove "SCL" package-name-list
								       :test #'string-equal)
							    :test #'string-equal)))
				     (list (append others '("SCL"))
					   (append others '("CL")))))
				  (t (ncons package-name-list))))
			packages-must-use))
	  (cl:remf options :packages-must-use)
	  (setq options (list* ':packages-must-use packages-must-use options)))
	;; Upgrade the info that they contained.
	(unless the-readtable			; :READTABLE is not expected.
	  (when (not readtable-place)			
	    ;; This should never happen, but better to err here than later if it does.
	    (error "Didn't specify :READTABLE-PLACE in SI:DEFINE-LISP-SYNTAX."))
	  (setq the-readtable (eval readtable-place))
	  (setq options (list* ':readtable the-readtable options)))
	(unless pretty-name			; :PRETTY-NAME is not expected either.
	  (unless external-name
	    ;; This should never happen, but we can tolerate it if it does.
	    (setq external-name (cl:string-capitalize name)))
	  (setq pretty-name external-name)
	  (setq options (list* ':pretty-name pretty-name options)))
	(unless package-name-function		; :PACKAGE-NAME-FUNCTION is not expected.
	  (setq package-name-function
		(compatible-package-name-function-for-syntax name))
	  (setq options (list* ':package-name-function package-name-function options)))
	(unless default-package-use-list	; :DEFAULT-PACKAGE-USE-LIST is not expected.
	  (setq default-package-use-list (car packages-must-use))
	  (setq options (list* ':default-package-use-list default-package-use-list options)))
	(unless user-package			; :USER-PACKAGE is not expected.
	  ;; Grovel around on the relative names list of the packages-must-use info
	  ;; and see if we can find anything that resembles a USER package.
	  (setq user-package
		(block win
		  (dolist (package-name-list packages-must-use)
		    (dolist (package-name package-name-list)
		      (let ((p (pkg-find-package package-name)))
			(let ((match (cdr (cl:assoc "USER" (si:pkg-relative-names p)
						    :test #'string-equal))))
			  (when match (return-from win match))))))
		  (cl:find-package "CL-USER")))
	  (setq options (list* ':user-package user-package options)))
	(unless relative-names			; :RELATIVE-NAMES is not expected.
	  (let ((l '()))
	    ;; Search user package and its superiors for relative names,
	    ;; and move them to the syntax where they belong.
	    (dolist (pkg (pkg-self-and-use-list
			   ;; Package spec might still be a string at this point.
			   (pkg-find-package user-package)))
	      (dolist (entry (pkg-relative-names pkg))
		;; Don't collect duplicate/shadowed entries
		(unless (ass #'pkg-compare-names (car entry) l)
		  (push entry l))))
	    (setq relative-names (nreverse l))
	    (setf options (list* ':relative-names relative-names options))))
	(unless reasonable-packages		; :REASONABLE-PACKAGES is not expected.
	  (when (and user-package (package-satisfies-syntax
				    ;; USER-PACKAGE might still be a string at this point.
				    (pkg-find-package user-package)
				    packages-must-use))
	    (setq reasonable-packages (list user-package)))
	  (dolist (package-name-list packages-must-use)
	    (dolist (package-name package-name-list)
	      (let ((p (pkg-find-package package-name)))
		(when (package-satisfies-syntax p packages-must-use)
		  (push p reasonable-packages)))))
	  (setq options (list* ':reasonable-packages reasonable-packages options)))
	;; Old binary files will not know they should have given us a :OPTIONS, so simulate
        ;; that. This only works here because we also know that old binary files will not
	;; use :INHERITS-FROM.
	(let ((old-keys (quote-keyword-options old-options))
	      (new-keys (quote-keyword-options options)))
	  (cl:warn "This file contains an obsolete compiled definition of syntax ~A.~
	          ~%Heuristic correction of the definition is being attempted.~:[~;~
		  ~%Approximate old definition:~%~S~
	          ~%Heuristic rewrite:~%~S~]"
		   pretty-name
		   *show-lisp-syntax-compatibility-warnings*
		   `(si:define-lisp-syntax ,name ,@old-keys)
		   `(si:define-lisp-syntax ,name ,@new-keys))
	  (setq options (list* ':options new-keys options))))))
  ;;  THIS CODE IS FOR BINARY COMPATIBILITY ONLY. 
  (setq parent-syntax (if inherits-from (find-lisp-syntax inherits-from)))
  (cl:assert (or (cl:typep the-readtable 'readtable)
		 (and (null the-readtable)
		      parent-syntax
		      (lisp-syntax-readtable parent-syntax)))
	     (the-readtable inherits-from)
	     "The options :READTABLE     '~S~
	    ~%        and :INHERITS-FROM '~S~
	    ~%are not compatible in the definition of syntax ~S.~
	    ~%You must either supply a valid readtable with :READTABLE,~
	    ~%or supply NIL and specify a syntax to inherit from so that a~
	    ~%new readtable can be copied from there."
	     the-readtable inherits-from name)
  ;; Pick up any changes made by the assert
  (unless (eql (getf options :readtable) the-readtable)
    (setf (getf options :readtable) the-readtable))
  (unless (eql (getf options :inherits-from) inherits-from)
    (setf (getf options :inherits-from) inherits-from)
    (setq parent-syntax (if inherits-from (find-lisp-syntax inherits-from))))
  ;; Default the readtable
  (when (not the-readtable)
    (setq the-readtable (copy-readtable (lisp-syntax-readtable parent-syntax)))
    (setf (getf options :readtable) the-readtable)
    (setf (si:readtable-name the-readtable) (format nil "Default-~A" short-name))
    (setf (si:readtable-appropriate-file-syntax the-readtable) name))
  ;; Make sure user-package is a real package
  (when user-package
    (setq user-package (pkg-find-package user-package))
    (setf (getf options :user-package) user-package))
  ;; Make sure reasonable-packages is a real package list
  (when reasonable-packages
    (setq reasonable-packages (mapcar #'pkg-find-package reasonable-packages))
    (setf (getf options :reasonable-packages) reasonable-packages))
  (when relative-names
    (setq relative-names
	  (cl:copy-alist (mapcar #'(lambda (x)
				     (cons (substring (car x) 0 nil pkg-area)
					   (pkg-find-package (if (atom (cdr x))
								 (cdr x)
								 (cadr x)))))
				 relative-names)
			 pkg-area))
    (setf (getf options :relative-names) relative-names))
  (when (and shadow-global-packages (not package-root))
    (error "You must specify a package root when you shadow global packages."))
  (check-arg package-root
	     (or (not package-root)
		 (eq package-root name)
		 (let ((s parent-syntax) (sym (lisp-syntax-name-symbol parent-syntax)))
		   (cl:loop
		      (when (eq sym package-root) (return (lisp-syntax-package-root s)))
		      (setq s (lisp-syntax-inherits-from s))
		      (when (not s) (return nil))
		      (setq s (find-lisp-syntax s))
		      (setq sym (lisp-syntax-name-symbol s)))))
	     (format nil "~S~@[, or the name of a syntax it inherits from~]"
		     name inherits-from))
  (when (not package-root-prefix)
    (setf package-root-prefix
	  (if (or (not package-root) (eq name package-root))
	      (format nil "~A-" (string-upcase (or package-root name)))
	      (let ((root (find-lisp-syntax package-root)))
		(or (lisp-syntax-package-root-prefix root)
		    (error "The syntax ~A does not have a package root." root)))))
    (setf (getf options :package-root-prefix) package-root-prefix))
  (let ((new-syntax (si:with-rem-keywords (new-options options '(:minor-mode-string))
		      (cl:apply #'make-lisp-syntax :name-symbol name new-options))))
    (dolist (existing-syntax *known-lisp-syntaxes*)
      (when (eq (lisp-syntax-name-symbol existing-syntax) name)
	;; old versions of syntax with the same name
	(undefine-lisp-syntax (lisp-syntax-name-symbol existing-syntax))))
    (unless (cl:member default-package-use-list packages-must-use
		       :test #'(lambda (default must-use)
				 (not (cl:set-difference must-use default :test #'cl:equalp))))
      (cl:warn "For syntax ~A:~
              ~% The :default-package-use option should specify a list of package names which~
	      ~% is a subset of one of the lists of package names in :packages-must-use...~
	      ~%  :default-package-use-list '~S~
	      ~%  :packages-must-use '~S"
	       pretty-name default-package-use-list packages-must-use))
    (unless (eq (readtable-appropriate-file-syntax the-readtable) name)
      (cl:warn "For syntax ~A:~% (SI:READTABLE-APPROPRIATE-FILE-SYNTAX '~S) is not ~S."
	       pretty-name the-readtable name))
    (dolist (reasonable-package reasonable-packages)
      (unless (package-satisfies-syntax reasonable-package new-syntax)
	(cl:warn "For syntax ~A:~% (PACKAGE-USE-LIST '~S) does not match ~S."
		 pretty-name reasonable-package
		 (lisp-syntax-packages-must-use new-syntax))))
    ;; The following three list updates are done with CONS+COPYLIST rather than
    ;; PUSH in order to keep things cdr-coded, compact, etc. -kmp 29-Aug-89
    (when reasonable-packages
      (setq *reasonable-packages*
	    (cl:copy-list (cl:union reasonable-packages *reasonable-packages*))))
    (setq *valid-readtables*
	  (cl:copy-list (cl:adjoin the-readtable *valid-readtables*)))
    ;; Install the definition.
    (setq *known-lisp-syntaxes*
	  ;; This list must be maintained in forward order so that general syntaxes
	  ;; get seen before specific ones in attribute list DWIM.  Otherwise, we'll break
	  ;; (FLAVOR:METHOD :GET-DEFAULT-ATTRIBUTE ZWEI:LISP-SYNTAX-MIXIN :SYNTAX).
	  ;; -kmp 8-Sep-89
	  (let ((new-syntax-list (cl:copy-list *known-lisp-syntaxes*)))
	    (if (not inherits-from)
		(push new-syntax new-syntax-list)
		(let ((parent-syntax-position (cl:member parent-syntax new-syntax-list)))
		  (if parent-syntax-position
		      (push new-syntax (cdr parent-syntax-position))
		      (setq new-syntax-list (nconc new-syntax-list (list new-syntax))))))
	    (cl:copy-list new-syntax-list)))
    ;; Make sure already-loaded dependent syntaxes are updated to reflect any new
    ;; inheritance information.
    (dolist (syntax *known-lisp-syntaxes*)
      (when (eq (lisp-syntax-inherits-from syntax) name)
	(update-lisp-syntax-definition syntax)))
    t))

(define-lisp-syntax-definition-extension system-internals
  define-lisp-syntax-1 undefine-lisp-syntax-1)

;;; This next function is a C-R-O-C-K.  There should be a *syntax* variable
;;; for this, in case *readtable* is bound.
(defun current-lisp-syntax ()
  "Returns name of current lisp syntax."
  (lisp-syntax-from-keyword
    (or (readtable-appropriate-file-syntax cl:*readtable*)
	(loop for syntax in *known-lisp-syntaxes*
	      when (eq (lisp-syntax-readtable syntax) readtable)
		;; readtable is same as one this syntax owns
		return (lisp-syntax-name-symbol syntax)
		  ;; didn't find one... sigh.
	      finally (return :unknown)))))

(defun lisp-syntax-possibilities (token)
  "Tries to complete a string against known lisp syntaxes."
  (loop with token-string = (string token)
	with token-length = (string-length token-string)
	for syntax in *known-lisp-syntaxes*
	when (string-search token-string (lisp-syntax-external-name syntax)
			    0. token-length)
	  collect syntax))

(defun default-package-use-list (&optional syntax)
  ;; Returns a syntax-relative version of the default-package-use-list of the
  ;; current or given syntax.
  (setq syntax (find-lisp-syntax (or syntax (current-lisp-syntax))))
  ;; This contortion is because the DEFAULT-PACKAGE-USE-LIST is stored as ZL-relative names.
  ;; Those names may have different meaning in the current syntax, so we first parse
  ;; them ZL-relative with PKG-FIND-PACKAGE, then we resolve them anew using
  ;; COMPILER:PACKAGE-NAME-FOR-SYNTAX to get their proper name for the current syntax.
  ;; This kind of thing may be important in Cloe, where the global package names
  ;; have different local names. -kmp 11-Sep-89
  (mapcar #'(lambda (name)
	      (compiler:package-name-for-syntax (pkg-find-package name) syntax))
	  (lisp-syntax-default-package-use-list syntax)))

(defun make-package-for-syntax (name &rest keys
				     &key (use nil use-p) syntax colon-mode
				     override-package-root
				     &allow-other-keys)
 ;; Unlike some of the -FOR-SYNTAX functions, this is not the same as MAKE-PACKAGE
 ;; when the syntax is NIL.  The reason is that it defaults its arguments differently.
 ;; The :USE argument here defaults to the `interactive default.'  That is, MAKE-PACKAGE
 ;; would default to :USE "LISP", but interactively it must default to :USE "SCL" for 
 ;; reasons of established tradition.  The :COLON-MODE stuff also does something dwim-ish
 ;; which is only really appropriate in interactive situations. -kmp 15-Feb-90
  (setq syntax (find-lisp-syntax (or syntax (current-lisp-syntax))))
  (let ((root (lisp-syntax-package-root syntax)))
    (if (and root
	     ;; This argument is so that MAKE-PACKAGE-FOR-SYNTAX-LOCALLY can call
	     ;; back into this routine without infinite recursion.  Uses of
	     ;; this function other than MAKE-PACKAGE-FOR-SYNTAX-LOCALLY should not
	     ;; specify :OVERRIDE-PACKAGE-ROOT T.
	     (not override-package-root))
	(cl:apply #'si:make-package-for-syntax-locally name :syntax root keys)
	(with-rem-keywords (new-keys keys '(:use #||:syntax||# ;The :SYNTAX argument must go
						 	       ;through so that :IMPORT-FROM,
							       ;:USE, :RELATIVE-NAMES, etc.
						 	       ;can be parsed correctly.
							       ;-kmp 15-Feb-90
					    :colon-mode :override-package-root))
	  (cl:apply #'make-package
		    name
		    :use (if (and use-p (neq use :default))
			     (mapcar #'(lambda (pkg) (find-package-for-syntax pkg syntax))
				     (if (cl:listp use) use (list use)))
			     (default-package-use-list syntax))
		    :colon-mode (or colon-mode (package-colon-mode-dwim name syntax))
		    new-keys)))))

;; This is an option variable which users may set to customize interactive behavior.
(defvar *package-colon-mode-compatibility* :warn
  "Possible values are NIL, :WARN, :SILENT, and :QUERY")

;; This is an internal variable which users should not set.  It may go away at
;; any time in a future release.
(defvar *package-colon-mode-compatibility-syntaxes*
	;; A list of released Symbolics products which have buggy behavior that we should
	;; continue to support for a transition period.
	'(:Common-Lisp :Lisp+C :Joshua :Prolog))

(defun package-colon-mode-dwim (name syntax)
  (setq syntax (find-lisp-syntax syntax))
  (let ((mode (lisp-syntax-package-colon-mode syntax)))
    (or (if (or (neq mode :external)
		(not *package-colon-mode-compatibility*)
		(not (member (lisp-syntax-name-symbol syntax)
			     *package-colon-mode-compatibility-syntaxes*)))
	    mode
	    (cl:ccase *package-colon-mode-compatibility*
	      (:silent nil)
	      (:warn
		(warn "The ~A package ~:\QUOTED-STRING\ is being created with ~
		       :COLON-MODE :EXTERNAL.~
		     ~%In a previous release it would have been created with ~
		       :COLON-MODE :INTERNAL.~
		     ~%If you want the old behavior, you must specify ~
		       :COLON-MODE :INTERNAL~
		     ~%in the package declaration//specification."
		      syntax name)
		nil)
	      (:query
		(warn "The ~A package ~:\QUOTED-STRING\ would have been created ~
		       with :COLON-MODE :INTERNAL~
		     ~%in a previous release, but should really be created with~
		     ~%:COLON-MODE :EXTERNAL like most other ~0@*~A packages.~
   		     ~%External mode means that external (single colon) references ~
		       to symbols~
		     ~%in the ~:\QUOTED-STRING\ package, as in ~
		       ~:*~:@\QUOTED-STRING\:A-SAMPLE-SYMBOL, will signal an error~
		     ~%unless those symbols have been explicitly exported."
		      syntax name)
		(accept '((cl:member :internal :external)
			  :description "a colon mode")
			:prompt "Please specify a colon mode to use"
			:default :external
			))))
	:external)))



(defun lisp-syntax-add-relative-name (from-syntax name to-pkg)
  (let ((syntax (find-lisp-syntax from-syntax)))
    (add-relative-name-internal
      "syntax" syntax (locf (lisp-syntax-relative-names syntax)) name to-pkg)))

(defun lisp-syntax-delete-relative-name (from-syntax name &optional (to-pkg nil to-pkg-p))
  (delete-relative-name-internal
    (locf (lisp-syntax-relative-names (find-lisp-syntax from-syntax))) name to-pkg to-pkg-p))

#|| ;Test suite for relative names stuff

(defun test-add-remove-relative-names ()
  (let* ((sqa :syntax-quality-assurance)
	 (pqa "PACKAGE-QUALITY-ASSURANCE")
	 (sqa-syntax (progn (unless (si:find-lisp-syntax sqa nil)
			      (eval `(si:define-lisp-syntax ,sqa
							    :inherits-from :common-lisp)))
			    (si:find-lisp-syntax sqa)))
	 (pqa-package (or (cl:find-package pqa) (cl:make-package pqa)))
	 (cl-user (cl:find-package "CL-USER"))
	 (zl-user (cl:find-package "ZL-USER"))
	 (problems '())
	 (n-tests 0))
    (flet ((test (thing expected)
	     (incf n-tests)
	     (let ((actual (if (typep thing 'package)
			       (si:pkg-relative-names thing)
			       (si:lisp-syntax-relative-names thing))))
	       (unless (equal actual expected)
		 (push (list n-tests :actual actual :expected expected) problems)))))
      (setf (si:pkg-relative-names         pqa-package) nil)
      (setf (si:lisp-syntax-relative-names sqa-syntax)  nil)
      (do ((a '(si:pkg-add-relative-name    si:lisp-syntax-add-relative-name)    (cdr a))
	   (d '(si:pkg-delete-relative-name si:lisp-syntax-delete-relative-name) (cdr d))
	   (o (list pqa-package sqa-syntax)					 (cdr o)))
	  ((null a))
	(let ((adder   (car a))
	      (deleter (car d))
	      (object  (car o)))
	  (funcall adder object "PQA-CL-USER" "CL-USER")
	  (test object `(("PQA-CL-USER" . ,cl-user)))
	  (funcall adder object "PQA-CL-USER" cl-user)
	  (test object `(("PQA-CL-USER" . ,cl-user)))
	  (funcall adder object "PQA-ZL-USER" zl-user)
	  (test object `(("PQA-ZL-USER" . ,zl-user) ("PQA-CL-USER" . ,cl-user)))
	  (funcall deleter object "PQA-CL-USER" zl-user)
	  (test object `(("PQA-ZL-USER" . ,zl-user) ("PQA-CL-USER" . ,cl-user)))
	  (funcall deleter object "PQA-CL-USER" cl-user)
	  (test object `(("PQA-ZL-USER" . ,zl-user)))
	  (funcall deleter object "PQA-ZL-USER" nil)
	  (test object `(("PQA-ZL-USER" . ,zl-user)))
	  (funcall deleter object "PQA-ZL-USER")
	  (test object `()))))
    (if (not problems) :win `(:lose ,@(nreverse problems)))))

||#



;;; This used to live in SYS:IO;OPEN.LISP, in package FS, but I moved it to here
;;; and exported PACKAGE-NAME-FOR-SYNTAX from package SYSTEM.
;;; -kmp 5-Oct-89

(defun find-package-for-syntax (name &optional (syntax (current-lisp-syntax))
					       (create-p :error)
					       relative-to-package)
  (pkg-find-package name create-p relative-to-package syntax))



;;; This used to live in SYS:COMPILER;COMFILE.LISP, in package COMPILER,
;;; but I moved it to here and exported PACKAGE-NAME-FOR-SYNTAX from package SYSTEM.
;;; -kmp 5-Oct-89

(defun package-name-for-syntax (pkg &optional (syntax-name (current-lisp-syntax))
					      (error-p t)
					      relative-to-package)
  (declare lt:(side-effects reader))
  (cl:check-type pkg package)
  (macrolet ((check-package-name (pkg name)
	       `(eq ,pkg (pkg-find-package ,name :find relative-to-package syntax-name))))
    (or (when relative-to-package
	  ;; Hopefully the argument is already a package, but if not parse it syntax-relative.
	  (setq relative-to-package
		(pkg-find-package relative-to-package :error nil syntax-name))
	  (dolist (relative-pkg (pkg-self-and-use-list relative-to-package))
	    (let ((entry (rassq pkg (pkg-relative-names relative-pkg))))
	      (when (and entry (check-package-name pkg (car entry)))
		(return (car entry))))))
	(when syntax-name
	  (let ((syntax (find-lisp-syntax syntax-name)))
	    (or (let ((name (car (rassq pkg (lisp-syntax-relative-names syntax)))))
		  (if (check-package-name pkg name) name))
		(pkg-useable-name pkg nil nil syntax)
		(unless error-p (return-from package-name-for-syntax nil))
		(let ((global-name (zl:pkg-name pkg)))
		  (when global-name
		    ;; If no global name, just fall through to harder error below.
		    (cl:cerror "Try to use ~S as a name for ~S.~
		              ~%~'iWarning: This may cause you problems later on.~"
			       "There is no name for ~*~S in ~A syntax."
			       global-name pkg syntax-name))))))
	(zl:pkg-name pkg)
	(unless error-p (return-from package-name-for-syntax nil))
	(error "There is no name for ~S." pkg))))

(defun package-nicknames-for-syntax (pkg &optional (syntax (current-lisp-syntax))
					           (error-p t))
  (let ((possibilities (pkg-name-list pkg)))
    (dolist (entry (lisp-syntax-relative-names (find-lisp-syntax syntax)))
      (when (eq (cdr entry) pkg) (push (car entry) possibilities)))
    (let ((main-name (package-name-for-syntax pkg syntax error-p)))
      (mapcan #'(lambda (name)
		  (if (and (eq (sys:find-package-for-syntax name syntax :find) pkg)
			   (or (not main-name) (not (pkg-compare-names name main-name))))
		      (ncons name)))
	      possibilities))))



(defun import-genera-package (genera-package-name
			       &optional
			       (target-name nil target-name-p)
			       target-nicknames target-syntax-name)
  (check-arg target-name (and (or target-name (not target-name-p))
			      (or (symbolp target-name) (stringp target-name)))
	     "a package name")
  (check-arg target-nicknames (and (cl:listp target-nicknames)
				   (cl:every #'(lambda (x)
						 (and x (or (symbolp x) (stringp x))))
					     target-nicknames))
	     "a list of package nicknames")
  (let ((genera-package (pkg-find-package genera-package-name))
	(target-syntax (find-lisp-syntax (or target-syntax-name (current-lisp-syntax)))))
    (unless target-name-p
      (setq target-name      (pkg-name      genera-package)
	    target-nicknames (pkg-nicknames genera-package)))
    (let ((root (lisp-syntax-package-root target-syntax)))
      (unless root
	(error "The syntax ~A has no associated local package universe." target-syntax))
      (rename-package-for-syntax-locally genera-package
					 target-name
					 target-nicknames
					 root))))

(defun rename-package-for-syntax-locally (pkg name &optional nicknames
                                          (syntax (current-lisp-syntax)))
  (when (not syntax) (error "Don't try making local packages in the null syntax."))
  (setq syntax (find-lisp-syntax syntax))
  (setq pkg (find-package-for-syntax pkg syntax))
  (let ((old-global-name (pkg-name pkg))
	(root (lisp-syntax-package-root syntax))
	(prefix (lisp-syntax-package-root-prefix syntax)))
    (labels ((recurse (syntax)
	       (setq name (string name))
	       (setq nicknames (mapcar #'string nicknames))
	       (setq syntax (find-lisp-syntax syntax))
	       (let ((original-name (package-name-for-syntax pkg syntax nil))
		     (original-nicknames (package-nicknames-for-syntax pkg syntax nil)))
		 (flet ((remove-name (name)
			  (lisp-syntax-delete-relative-name syntax name)
			  (when (sys:find-package-for-syntax name syntax :find)
			    ;; An outer name shows through. Hide it.
			    (si:lisp-syntax-add-relative-name syntax name nil)))
			(add-name    (name) (lisp-syntax-add-relative-name syntax name pkg))
			(check-new-name (name)
			  (let ((entry (ass #'pkg-compare-names
					    name (lisp-syntax-relative-names syntax))))
			    (when (and entry (cdr entry) (neq (cdr entry) pkg))
			      (error "The ~A package name ~A is already in use."
				     syntax name)))))
		   ;; Verify first that the renaming will work.
		   (check-new-name name)
		   (mapc #'check-new-name nicknames)
		   ;; Now locally remove the old names for this package.
		   (dolist (original-nickname original-nicknames)
		     (remove-name original-nickname))
		   ;; Now add any new names.
		   (if original-name (remove-name original-name))
		   (mapc #'add-name nicknames)
		   ;; Add the real name last so it's pushed on the front of the relative names.
		   (add-name name)
		   (let ((name-symbol (lisp-syntax-name-symbol syntax)))
		     (dolist (syntax *known-lisp-syntaxes*)
		       (when (and (eq (lisp-syntax-inherits-from syntax) name-symbol)
				  (eq (lisp-syntax-package-root syntax) root))
			 (recurse syntax))))))))
      (recurse syntax))
    (when (string-equal old-global-name prefix 0 0 (string-length prefix))
      (rename-package pkg (string-append prefix name)))
    pkg))

(defun rename-package-for-syntax (pkg new-name &optional new-nicknames syntax)
  (let ((root (if syntax (lisp-syntax-package-root (find-lisp-syntax syntax)))))
    (if (not root)
	(cl:rename-package pkg new-name new-nicknames)
	(rename-package-for-syntax-locally pkg new-name new-nicknames syntax))))

(defun use-package-for-syntax (pkgs pkg &optional syntax)
  (package-package-operation pkgs pkg #'use-package-internal syntax))

(defun make-package-for-syntax-locally (name &rest options
					     &key nicknames (syntax (current-lisp-syntax))
					     &allow-other-keys)
  (setq syntax (find-lisp-syntax syntax))
  (when (sys:find-package-for-syntax name syntax :find)
    (error "A package named ~S already exists." name))
  (let* ((local-name (string-append (si:lisp-syntax-package-root-prefix syntax) name))
	 (package (si:with-rem-keywords (new-options options '(:nicknames))
		    (lexpr-funcall #'si:make-package-for-syntax
				   local-name :override-package-root t
				   new-options))))
    (rename-package-for-syntax-locally package name nicknames syntax)
    package))




(define-lisp-syntax :common-lisp
		    :pretty-name              "Common-Lisp"
		    :short-name               "CL"
		    :packages-must-use        '(("SCL") ("CL"))
		    :default-package-use-list '("SCL")
		    :readtable                *common-lisp-readtable*
		    :user-package             "CL-USER"
		    :reasonable-packages      '("CL" "SCL")
		    :package-name-function    'cl:package-name
		    :list-syntax-table        'zwei:*cl-list-syntax-table*
		    :minor-mode-name          'zwei:common-lisp-mode
		    :documentation            "Standard Common-Lisp syntax."
		    :relative-names           '(("USER" "CL-USER")
						("ZL" "GLOBAL")))

(define-lisp-syntax :zetalisp
		    :short-name               "ZL"
		    :packages-must-use        '(("GLOBAL"))
		    :default-package-use-list '("GLOBAL")
		    :readtable                standard-readtable
		    :user-package             "ZL-USER"
		    :reasonable-packages      '("GLOBAL")
		    :package-name-function    'zl:pkg-name
		    :list-syntax-table        'zwei:*list-syntax-table*
		    :documentation            "Standard Zetalisp syntax."
		    :package-colon-mode	      :internal
		    :make-package-function    'cl:make-package
		    :default-base             8.
		    :relative-names	      '(("USER" "ZL-USER")))

(cl:defparameter cli::*fcl-user-package* (cl:find-package "FUTURE-COMMON-LISP-USER"))

(sys:define-lisp-syntax :ansi-common-lisp
  :pretty-name		    "ANSI-Common-Lisp"
  :short-name		    "ANSI-CL"
  :inherits-from            :common-lisp
  :documentation            "ANSI Common Lisp syntax."
  :packages-must-use        '(("FUTURE-COMMON-LISP"))
  :default-package-use-list '("FUTURE-COMMON-LISP")
  :user-package             "FUTURE-COMMON-LISP-USER"
  :reasonable-packages      '("FUTURE-COMMON-LISP")
  :relative-names	      '(("CL"               "FUTURE-COMMON-LISP")
				("COMMON-LISP"      "FUTURE-COMMON-LISP")
				("CL-USER"          "FUTURE-COMMON-LISP-USER")
				("COMMON-LISP-USER" "FUTURE-COMMON-LISP-USER")
				("LISP"		    "COMMON-LISP")
				("USER"		    "COMMON-LISP-USER"))
  :readtable                si:*ansi-common-lisp-readtable*)



;; System facilities should look to this value instead of wiring in :COMMON-LISP
;; so that we can later transition gracefully to :ANSI-COMMON-LISP. -kmp 4-Oct-92

(defvar *default-lisp-syntax* :common-lisp)

 ;This is assigned to a more useful value later by the editor, if and when it is loaded. 
(defvar *editor-set-default-lisp-syntax-hook* nil)

(defun set-default-lisp-syntax (syntax &optional pkg)
  (let* ((real-syntax (si:find-lisp-syntax syntax))
	 (name-symbol (si:lisp-syntax-name-symbol real-syntax)))
    (setq *default-lisp-syntax* name-symbol)
    (if *editor-set-default-lisp-syntax-hook*
      (funcall *editor-set-default-lisp-syntax-hook* real-syntax pkg))
    name-symbol))

