;;; -*- Mode: LISP; Syntax: Common-lisp; Package: CLI; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; The generic console interface

(defgeneric console-initialize (console))
(defgeneric console-disable (console &key abort))
(defgeneric console-remove (console))
(defgeneric console-master-p (console))

(defgeneric console-screen-acceptable-p (console screen))
(defgeneric console-screen-create (console who-line-p &rest make-window-args))

(defgeneric console-create-mouse (console))
(defgeneric console-create-keyboard (console))
(defgeneric console-ensure-mouse-and-keyboard (console))

(defgeneric console-who-line-template (console))

(defgeneric console-video-address (console)
  (declare (values address
		   width height bits-per-pixel
		   top-margin-size bottom-margin-size left-margin-size right-margin-size)))

(defgeneric console-bow-mode (console))
(defgeneric console-real-brightness (console))
(defgeneric (setf console-real-brightness) (console new))
(defgeneric console-wait-for-vertical-sync (console))

(defgeneric console-hardware-char-available (console &optional kbd-in-ptr))
(defgeneric console-get-hardware-char (console))

(defgeneric console-send-command (console command &optional parameter delay))

(defgeneric console-audio-exists-p (console))
(defgeneric console-audio-active-p (console))
(defgeneric console-audio-start (console start-pma))
(defgeneric console-audio-stop (console))
(defgeneric console-beep (console))
(defgeneric console-real-volume (console))
(defgeneric (setf console-real-volume) (console new))

(defgeneric console-last-activity-time (console))
(defgeneric (setf console-last-activity-time) (console new))

(defgeneric console-kill-history (console))

(defgeneric console-activate-screen-saver (console))

(defgeneric console-function-keys-enabled (console)
  (declare (values (or boolean (list character)))))
(defgeneric console-function-key-enabled-p (console &optional ch)
  (declare (values enabled)))
(defgeneric console-select-keys-enabled (console)
  (declare (values (or boolean (list character)))))
(defgeneric console-select-key-enabled-p (console &optional ch)
  (declare (values enabled)))
(defgeneric console-system-menu-enabled (console)
  (declare (values enabled)))

;;; All consoles
(defvar *consoles* nil)

;;; Console object of the main console.
(defvar *main-console* nil)

;;; All those other than the main one.
(defvar *secondary-consoles* nil)

;;; The "current" console.
(defvar *console*)

;;; For compatibility.
(defvar *slb-main-console*)

(defun si:initialize-console ()
  (disable-consoles :abort t)
  (si:initialize-slb-console-wired)
  (find-console-device)
  (setf *slb-main-console* *main-console*)
  (setf *console* *main-console*)
  (when *main-console*
    (setf *consoles* (cons *main-console* *secondary-consoles*))
    (console-initialize *main-console*))
  nil)

(defun disable-consoles (&key abort)
  (loop while *secondary-consoles*
	do (console-disable (pop *secondary-consoles*) :abort abort))
  (when *main-console*
    (console-disable (shiftf *main-console* nil) :abort abort))
  (setf *console* nil)
  (setf *slb-main-console* nil)
  (setf *consoles* nil)
  nil)


;;; Compatibility stuff

(defun cvt-to-funny-brightness (brightness)
  (unless (<= 0 brightness 1)
    (error "Invalid brightness value."))
  (- 255 (round (* 254 brightness))))

(defun cvt-from-funny-brightness (funny-brightness)
  (min 1 (max 0 (/ (- 255 funny-brightness) 254))))

(defun cvt-to-funny-volume (volume)
  (unless (<= 0 volume 1)
    (error "Invalid volume value."))
  (- 63 (round (* 62 volume))))

(defun cvt-from-funny-volume (funny-volume)
  (min 1 (max 0 (/ (- 63 funny-volume) 62))))

(defun console-brightness (&optional (console *console*))
  (if (null console) 0 (console-real-brightness console)))

(defsetf console-brightness (&optional (console '*console*)) (new)
  `(if (null ,console) ,new (setf (console-real-brightness ,console) ,new)))

(defun si:set-console-brightness (new)
  (setf (console-brightness) new))

(defun console-volume (&optional (console *console*))
  (if (null console) 0 (console-real-volume console)))

(defsetf console-volume (&optional (console '*console*)) (new)
  `(if (null ,console) ,new (setf (console-real-volume ,console) ,new)))

(defun si:set-console-volume (new)
  (setf (console-volume) new))


(defflavor console
	((mouse nil)
	 (keyboard nil)
	 (screen nil)

	 (keyboard-process nil)
	 (selected-window nil)
	 (selected-io-buffer nil)
	 (system-io-buffer (tv:make-io-buffer 1000))
	 (previously-selected-windows (make-array 20 :fill-pointer 0))
	 (last-activity-time (sys:time))
	 (last-hardware-activity-time (sys:time))
	 (esc-function nil)
	 (selection-start-time nil)
	 (mouse-buttons-buffer-keyboard-index 0)
	 (input-lock nil))		;If T, don't process input
	()
  :abstract-flavor
  :readable-instance-variables
  (:writable-instance-variables mouse keyboard screen
				selected-io-buffer last-activity-time
				esc-function selection-start-time)
  (:locatable-instance-variables input-lock))


(defmethod (console-kill-history console :default) () nil)

(defmethod (console-function-keys-enabled console :default) ()
  firewall:*function-keys-enabled*)

(defmethod (console-function-key-enabled-p console :default) (&optional ch)
  (let ((keys (console-function-keys-enabled self)))
    (cond ((eq keys t) t)
	  ((eq keys nil) nil)
	  ((null ch) t)
	  (t (member ch keys :test #'char-equal)))))

(defmethod (console-select-keys-enabled console :default) ()
  firewall:*select-keys-enabled*)

(defmethod (console-select-key-enabled-p console :default) (&optional ch)
  (let ((keys (console-select-keys-enabled self)))
    (cond ((eq keys t) t)
	  ((eq keys nil) nil)
	  ((null ch) t)
	  (t (member ch keys :test #'char-equal)))))

(defmethod (console-system-menu-enabled console :default) ()
  firewall:*system-menu-enabled*)

(defmethod (console-master-p console :default) () nil)

(defmethod (color:console-wait-for-vertical-sync console :default) () t)

(defmethod (console-note-keyboard-process console :default) (ignore))


(defmethod (dw:console-select-program-after console :default) (program)
  (ignore program)
  nil)

(defmethod (dw:console-deexpose-program-after console :default) (program)
  (ignore program)
  nil)

(defmethod (dw:console-remote-program console :default) ()
  nil)

(defmethod (console-ensure-mouse-and-keyboard console) ()
  (when (null mouse)
    (setf mouse (console-create-mouse self)))
  (when (null keyboard)
    (setf keyboard (console-create-keyboard self)))
  (console-start-keyboard-process self))

(defresource keyboard-process ()
  :constructor (process:make-process "Keyboard" :top-level-whostate "Keyboard"
				     :priority (process:make-process-priority
						 :fg 30 :preemptive t)
				     :warm-boot-action nil :simple-p t
				     :flags '(:system-process t :no-kbd-arrest t)
				     :interrupt-handler t))

(defmethod (console-convert-to-software-char console) (hard-char &optional table)
  (keyboard-convert-to-software-char keyboard hard-char table))

(defmethod (console-key-state console) (key)
  ;; Bring hardware status up to date, but don't spend a lot of time thinking about auto-repeat
  (when (console-hardware-char-available self)
    (tv:console-process-input self))
  (keyboard-key-state keyboard key))

(defmethod (console-shifts console) ()
  (keyboard-shifts keyboard))

(defmethod ((setf console-selected-window) console) (new-selected-window)
  (without-interrupts
    (setf selected-window new-selected-window)
    (setf selected-io-buffer nil))
  (tv:who-line-run-state-update)
  new-selected-window)

(defmethod (console-start-keyboard-process console) ()
  (setq keyboard-process (allocate-resource 'keyboard-process))
  (setf (keyboard-repeat-timer keyboard)
	(process:create-timer-wakeup keyboard-process :name "Repeat Key"))
  (tv:io-buffer-clear system-io-buffer)
  (setq esc-function nil)
  (setq input-lock nil)
  (let ((args (list self)))
    (process::preset-simple-process
      keyboard-process
      #'keyboard-process-top-level args
      #'(lambda (console)
	  (or (and (or (console-hardware-char-available console)
		       (keyboard-time-to-repeat (console-keyboard console)))
		   (not (tv:io-buffer-full-p (console-system-io-buffer console)))
		   (not tv:cold-load-stream-selected)
		   (not (console-input-lock console)))
	      (not (null (console-esc-function console)))))
      args))
  (process:process-enable keyboard-process)
  (process:process-wakeup keyboard-process)
  (console-note-keyboard-process self keyboard-process))

(defmethod (console-initialize console :before) ()
  (when (null keyboard)
    (setf keyboard (console-create-keyboard self)))
  (keyboard-initialize keyboard))

(defmethod (console-disable console :before) (&key abort)
  (declare (ignore abort))
  (tv:clear-previously-selected-windows self)
  (console-stop-keyboard-process self))

(defmethod (console-stop-keyboard-process console) ()
  (when (keyboard-repeat-timer keyboard)
    (process:clear-timer (keyboard-repeat-timer keyboard))
    (setf (keyboard-repeat-timer keyboard) nil))
  (when keyboard-process
    (process-kill keyboard-process)
    (deallocate-resource 'keyboard-process keyboard-process)
    (setf keyboard-process nil)))

;;; Remove console from the various places that it's known about
(defmethod (console-remove console :default) ()
  (store-conditional (locf sys:*console*) self nil)
  (store-conditional (locf sys:*main-console*) self nil)
  (process:atomic-replacef sys:*consoles* (remove self sys:*consoles*))
  (process:atomic-replacef sys:*secondary-consoles* (remove self sys:*secondary-consoles*)))

(defmethod (keyboard-process-top-level console) ()
  (let* ((*debug-io* "Error in the keyboard process")	;so cold-load-stream will be used
	 (*console* self)
	 (tv:default-screen (console-screen self))
	 (*terminal-io* #'(lambda (operation &rest arguments)
			    (ignore arguments)
			    (case operation
			      (:which-operations '(:beep :operation-handled-p))
			      (:operation-handled-p (member (first arguments)
							    '(:beep :operation-handled-p)))
			      (:beep (console-beep *console*))
			      (otherwise
				(error "Using *TERMINAL-IO* in the keyboard process."))))))
    (when esc-function
      (funcall esc-function self)
      (process-wait "ESC Finish"
	#'(lambda (console)
	    (let ((time (console-selection-start-time console)))
	      (or (null time) (time-elapsed-p 600. time))))	;Wait at most 10 seconds
	self)
      (setq esc-function nil))
    (tv:console-process-input self)))

(defmethod (console-bow-mode console :default) () t)
(defmethod ((setf console-bow-mode) console :default) (new) new)
(defmethod (console-real-brightness console :default) () 0)
(defmethod ((setf console-real-brightness) console :default) (new) new)

(defun local-console-beep (console)
  (when tv:beep
    (let ((bow-mode (console-bow-mode console)))
      (unwind-protect
	  (progn (when (not (eq tv:beep :beep))
		   (setf (console-bow-mode console) (not bow-mode)))
		 (if (eq tv:beep :flash)
		     (sys:%beep 0 tv:beep-duration console)	;Delay same time without making any noise
		     (sys:%beep tv:beep-wavelength tv:beep-duration console)))
	(when (not (eq tv:beep :beep))
	  (setf (console-bow-mode console) bow-mode)))))
  nil)

;; Crock to make Univision color console work.
(defmethod (tv:console-readjust-screen console :default)
	   (screen &key buffer bits-per-pixel left right top bottom
		   left-margin-size right-margin-size top-margin-size bottom-margin-size
		   &allow-other-keys)
  (unless (and (not (tv:change-screen-shape
		      screen buffer (- right left) (- bottom top) bits-per-pixel))
	       (multiple-value-bind (le to ri bo)
		   (send screen :edges)
		 (and (= left le) (= right ri) (= top to) (= bottom bo)))
	       (multiple-value-bind (le to ri bo)
		   (send screen :margins)
		 (and (= left-margin-size le) (= right-margin-size ri)
		      (= top-margin-size to) (= bottom-margin-size bo))))
    (send screen :change-of-size-or-margins
	  :left left :right right :top top :bottom bottom
	  :left-margin-size left-margin-size :right-margin-size right-margin-size
	  :top-margin-size top-margin-size :bottom-margin-size bottom-margin-size))
  nil)



;;; This is the support for the Color Console Unit.
;;; This is just a CAD Buffer used instead of the B&W screen attached to the I/O board.
;;; Mouse, keyboard, audio, etc. all go through the non-CCU console.

(defflavor ccu-console-mixin
	(keyboard-console)			;console to use for input
	()
  (:required-flavors console)
  (:required-methods console-screen-acceptable-p console-screen-create
		     console-real-brightness (setf console-real-brightness)
		     console-bow-mode (setf console-bow-mode)
		     console-wait-for-vertical-sync))

(defmethod (console-who-line-template ccu-console-mixin) ()
  (tv:default-construct-who-line-template si:*b&w-screen*))

(defmethod (console-video-address ccu-console-mixin) ()
  (main-console-video-address))

(defmethod (console-initialize ccu-console-mixin) ()
  (console-initialize keyboard-console))		; Initialize the other console, too.

(defmethod (console-create-mouse ccu-console-mixin) ()
  (let ((mouse (console-create-mouse keyboard-console)))
    (setf (tv:mouse-console mouse) self)
    mouse))

(defmethod (console-disable ccu-console-mixin) (&key abort)
  (console-disable keyboard-console :abort abort)	;disable the other console
  nil)

;;; These just indirect through the other console

(defmethod (console-note-keyboard-process ccu-console-mixin) (process)
  (console-note-keyboard-process keyboard-console process))

(defmethod (console-hardware-char-available ccu-console-mixin) (&optional ptr)
  (console-hardware-char-available keyboard-console ptr))

(defmethod (console-get-hardware-char ccu-console-mixin) ()
  (console-get-hardware-char keyboard-console))

(defmethod (console-last-hardware-activity-time ccu-console-mixin) ()
  (console-last-hardware-activity-time keyboard-console))

;;

(defmethod (console-real-volume ccu-console-mixin) ()
  (console-real-volume keyboard-console))

(defmethod ((setf console-real-volume) ccu-console-mixin) (new)
  (setf (console-real-volume keyboard-console) new))

(defmethod (console-audio-exists-p ccu-console-mixin) ()
  (console-audio-exists-p keyboard-console))

(defmethod (console-audio-active-p ccu-console-mixin) ()
  (console-audio-active-p keyboard-console))

(defmethod (console-audio-start ccu-console-mixin) (start-pma)
  (console-audio-start keyboard-console start-pma))

(defmethod (console-audio-stop ccu-console-mixin) ()
  (console-audio-stop keyboard-console))

(defmethod (console-beep ccu-console-mixin) ()
  (local-console-beep self))

(defmethod (console-send-command ccu-console-mixin) (command &optional data delay)
  (console-send-command keyboard-console command data delay))

;; NBS only

(defmethod (console-serial-window-size ccu-console-mixin) ()
  (console-serial-window-size keyboard-console))

(defmethod ((setf console-serial-window-size) ccu-console-mixin) (value)
  (setf (console-serial-window-size keyboard-console) value))

(defmethod (console-adjust-serial-window-size ccu-console-mixin) (amount)
  (console-adjust-serial-window-size keyboard-console amount))

(defmethod (console-serial-modem-status ccu-console-mixin) ()
  (console-serial-modem-status keyboard-console))

(defmethod (console-serial-listen ccu-console-mixin) ()
  (console-serial-listen keyboard-console))

(defmethod (console-serial-read-byte ccu-console-mixin) ()
  (console-serial-read-byte keyboard-console))

;;;

;;; This gets called when color is loaded to change the main screen around.
(defun maybe-move-cad-buffer-console ()
  (when (or #+3600 (and (typep *main-console* 'shared-nbs-cad-buffer-ii-console)
			(not (symbol-value-in-instance *main-console* 'color-loaded-p))
			(not (null (flavor:find-flavor 'color:cad-buffer-ii-overlay-screen nil))))
	    #+3600 (and (typep *main-console* 'cad-buffer-i-console)
			(not (symbol-value-in-instance *main-console* 'color-loaded-p))
			(not (null (flavor:find-flavor 'color:cad-buffer-overlay-screen nil))))
	    #+imach (and (typep *main-console* 'framethrower-ccu-console)
			 (not (symbol-value-in-instance *main-console* 'color-loaded-p))
			 (not (null (flavor:find-flavor 'color:photon-fb-screen nil)))))
    (let ((old-screen tv:main-screen))
      (setf (symbol-value-in-instance *main-console* 'color-loaded-p) t)
      (tv:recompute-and-replace-screen old-screen)
      (send tv:main-screen :new-control)
      (send tv:main-screen :refresh)
      (send tv:main-screen :refresh-margins)
      (send tv:who-line-screen :refresh)
      (send tv:who-line-screen :refresh-margins)
      (setf (send tv:main-screen :get 'tv:initial-lisp-listener)
	    (send old-screen :get 'tv:initial-lisp-listener))
      (send old-screen :remprop 'tv:initial-lisp-listener)))
  nil)



;;; These variables exist for compatibility.  Their value cells are forwarded into the console

(defvar tv:kbd-process)
(defvar tv:selected-window)
(defvar tv:selected-io-buffer)

(defvar tv:previously-selected-windows)
(defvar tv:kbd-last-activity-time)
(defvar tv:kbd-io-buffer)
(defvar tv:kbd-esc-happened)
(defvar tv:kbd-esc-time)

(defparameter *main-console-compatibility-variables*
  '((tv:kbd-process keyboard-process)
    (tv:selected-window selected-window)
    (tv:selected-io-buffer selected-io-buffer)
    (tv:kbd-io-buffer system-io-buffer)
    (tv:previously-selected-windows previously-selected-windows)
    (tv:kbd-last-activity-time last-activity-time)
    (tv:kbd-esc-happened esc-function)
    (tv:kbd-esc-time selection-start-time)
    ))

(defflavor main-console () (console))

(defmethod (console-master-p main-console) () t)

(defun forward-compatibility-variables (instance variables)
  (loop for (special-var instance-var) in variables do
    (let ((instance-loc (locf (symbol-value-in-instance instance instance-var))))
      (when (location-boundp instance-loc)
	(setf (symbol-value special-var) (location-contents instance-loc)))
      (%p-store-tag-and-pointer instance-loc
				dtp-one-q-forward
				(locf (symbol-value special-var))))))

(defmethod (make-instance main-console) (&rest ignore)
  (forward-compatibility-variables self *main-console-compatibility-variables*))

;;;; Keyboards

;;; %type-... already defined in SYSDEF for SLB;
;;; they are compatible for OBS where they intersect.

;;; This is also %type-serial-in, so we rely on never seeing that at the keyboard level.
(defconstant %type-key-repeat 7)

(defconstant %%kbd-hardware-char-opcode (byte 3 12))
(defconstant %%kbd-hardware-char-key-shifts (byte 12 0))	;In %type-all-keys-up
(defconstant %%kbd-hardware-char-key-number (byte 8 0))	;In %type-key-up/down

(defconstant %%kbd-mapping-table-index-shift (byte 1 0))
(defconstant %%kbd-mapping-table-index-symbol (byte 1 1))

(defconstant %%kbd-mapping-special (byte 1 15))	;Not a regular character
(defconstant %%kbd-mapping-special-class (byte 3 12))
(defconstant %kbd-mapping-special-shift 0)
(defconstant %kbd-mapping-special-locking-shift 1)
(defconstant %kbd-mapping-special-locking-once-shift 2)
(defconstant %kbd-mapping-special-noop 3)
(defconstant %kbd-mapping-special-unassigned 4)
(defconstant %kbd-mapping-special-mouse-button 5)
(defconstant %%kbd-mapping-shift-index (byte 7 0))	;Which bit and which side
(defconstant %%kbd-mapping-bit-number (byte 5 0))	;Shift this bit
(defconstant %%kbd-mapping-right-p (byte 1 5))	;In right mask
(defconstant %%kbd-mapping-left-p (byte 1 6))	;In left mask (also there if neither)

(defconstant %%mouse-shifts-bits (byte 4 0))	;Those shared with char-bits
(defconstant %%mouse-shifts-shift (byte 1 4))	;Position in mouse-char-bits

(defconstant %%kbd-shifts-bits (byte 4 1))	;Those shared with char-bits.

(defvar *kbd-mapping-bit-names* (make-array 96))

(defprop define-kbd-shift-bit "Keyboard shift bit" si:definition-type-name)
(defmacro define-kbd-shift-bit (name number &key both-sides)
  `(compiler:local-declare ((function-parent ,name define-kbd-shift-bit))
     (defconstant ,(fintern "%KBD-SHIFTS-~A" name) ,number)
     (defconstant ,(fintern "%%KBD-SHIFTS-~A" name) (byte 1 ,number))
     (setf (aref *kbd-mapping-bit-names* ,number) ',name)
     . ,(when both-sides
	  `((setf (aref *kbd-mapping-bit-names* (dpb 1 %%kbd-mapping-left-p ,number))
		  ',(intern (format () "LEFT-~A" name) ""))
	    (setf (aref *kbd-mapping-bit-names* (dpb 1 %%kbd-mapping-right-p ,number))
		  ',(intern (format () "RIGHT-~A" name) ""))))))

(define-kbd-shift-bit :shift 0 :both-sides t)
(define-kbd-shift-bit :control 1 :both-sides t)
(define-kbd-shift-bit :meta 2 :both-sides t)
(define-kbd-shift-bit :super 3 :both-sides t)
(define-kbd-shift-bit :hyper 4 :both-sides t)
(define-kbd-shift-bit :symbol 5 :both-sides t)
(define-kbd-shift-bit :repeat 6)
(define-kbd-shift-bit :alt 7)			;nee Greek
;;; 8 obsolete
(define-kbd-shift-bit :caps-lock 9)
(define-kbd-shift-bit :mode-lock 10)
(define-kbd-shift-bit :scroll-lock 11)
(define-kbd-shift-bit :num-lock 12)

(define-kbd-shift-bit :local 30)		;Usually not seen.

(defparameter *kbd-mapping-mouse-button-names* '(:mouse-l :mouse-m :mouse-r :mouse-4))

(defgeneric map-key-to-software-char (shift-index char-index
				      &optional (table *keyboard-table*))
  (:function (if (arrayp table)
		 (aref table shift-index char-index)
		 (funcall (flavor:generic map-key-to-software-char)
			  table shift-index char-index)))
  (:method-arglist (shift-index char-index)))

(defgeneric keyboard-table-shift-index-limit (&optional (table *keyboard-table*))
  (:function (if (arrayp table)
		 (array-dimension table 0)
		 (funcall (flavor:generic keyboard-table-shift-index-limit) table)))
  (:method-arglist ()))

(defgeneric keyboard-table-key-code-limit (&optional (table *keyboard-table*))
  (:function (if (arrayp table)
		 (array-dimension table 1)
		 (funcall (flavor:generic keyboard-table-key-code-limit) table)))
  (:method-arglist ()))

(defun make-keyboard-table (definitions)
  (let* ((fix-p (loop for elem in definitions
		      always (if (consp elem)
				 (loop for elem in elem
				       always (integerp (standardize-keyboard-mapping elem t)))
				 (integerp (standardize-keyboard-mapping elem t)))))
	 (table (make-array (list (max 4 (loop for elem in definitions
					       when (consp elem)
						 maximize (length elem)))
				  (max 128 (length definitions)))
		  :element-type (if fix-p '(unsigned-byte 16) 't)
		  :initial-element (and fix-p
					(dpbs 1 %%kbd-mapping-special
					      %kbd-mapping-special-unassigned
					      %%kbd-mapping-special-class 0)))))
    (loop for code from 0
	  for entry in definitions
	  do
      (flet ((store (value shift code)
	       (when value
		 (setf (aref table shift code) (standardize-keyboard-mapping value fix-p)))))
	(if (atom entry)
	    (dotimes (shift 4)
	      (store entry shift code))
	    (loop for shift below 4
		  for value in entry
		  do (store value shift code)))))
    table))

(defun standardize-keyboard-mapping (value attempt-fix-p)
  (typecase value
    (character (if (and attempt-fix-p
			(< (char-code value) (dpb 1 %%kbd-mapping-special 0)))
		   (char-code value)
		 value))
    (null (and attempt-fix-p (dpbs 1 %%kbd-mapping-special
				   %kbd-mapping-special-unassigned
				   %%kbd-mapping-special-class 0)))
    (keyword
      (let ((class %kbd-mapping-special-unassigned)
	    (extra 0))
	(block found
	  (when (eq value :noop)
	    (setq class %kbd-mapping-special-noop)
	    (return-from found))
	  (let ((shift (position value *kbd-mapping-bit-names*)))
	    (when shift
	      (setq class %kbd-mapping-special-shift
		    extra shift)
	      (return-from found)))
	  (let ((mouse (position value *kbd-mapping-mouse-button-names*)))
	    (when mouse
	      (setq class %kbd-mapping-special-mouse-button
		    extra mouse)
	      (return-from found)))
	  (error "Unknown special key mapping: ~S" value))
	(dpbs 1 %%kbd-mapping-special class %%kbd-mapping-special-class extra)))
    (cons
      (destructuring-bind (shift-keyword &key locking) value
	(dpbs 1 %%kbd-mapping-special
	      (ecase locking
		((nil) %kbd-mapping-special-shift)
		((t) %kbd-mapping-special-locking-shift)
		((:once) %kbd-mapping-special-locking-once-shift))
	      %%kbd-mapping-special-class (position shift-keyword *kbd-mapping-bit-names*))))
    (otherwise value)))

;--- It might make sense to have a separate mixin for software repeat, since some
;keyboard do it in hardware or the lower levels of the driver.
(defflavor keyboard
	(
	 ;; Device specific
	 console
	 (layout-type nil)
	 keyboard-table
	 mode-lock-keyboard-table
	 (all-keys-up-shift-keys nil)
	 (mouse-button-shift-keys nil)

	 ;; Internal state
	 left-shifts right-shifts unlocking-shifts
	 key-states fast-fill-key-states
	 repeat-last-code repeat-last-time last-char-was-repeated-p repeat-timer

	 ;; Control panel type user options
	 (shift-lock-xors nil)
	 (mode-lock-controller :debugger)
	 (auto-repeat-enabled-p nil)
	 (repeat-key-enabled-p t)
	 (repetition-interval 2)
	 (auto-repeat-initial-delay 42)
	 auto-repeat-table)
	()
  :initable-instance-variables
  :writable-instance-variables
  (:constructor make-keyboard (&key console layout-type keyboard-table
				    all-keys-up-shift-keys mouse-button-shift-keys)))

(defmethod (keyboard-auto-repeat-p keyboard) (key)
  (let ((index (key-code-for-character keyboard-table key)))
    (and index (aref auto-repeat-table index))))

(defmethod ((setf keyboard-auto-repeat-p) keyboard) (key repeat-p)
  (let ((index (key-code-for-character keyboard-table key)))
    (and index (setf (aref auto-repeat-table index) repeat-p))))

(defun si:auto-repeat-p (key &optional (console *console*))
  (keyboard-auto-repeat-p (console-keyboard console) key))

(defun si:set-auto-repeat-p (key &optional (state t) (console *console*))
  (setf (keyboard-auto-repeat-p (console-keyboard console) key) state))

(defvar *keyboard-table*)
(defvar *mode-lock-keyboard-table*)
(defvar tv:*mode-lock-state*)
(defvar si:*kbd-auto-repeat-enabled-p*)
(defvar si:*kbd-repeat-key-enabled-p*)
(defvar si:*kbd-repetition-interval*)
(defvar si:*kbd-auto-repeat-initial-delay*)
(defvar si:*kbd-auto-repeat-table*)

(defparameter *main-keyboard-compatibility-variables*
  '((tv:*keyboard-table* keyboard-table)
    (tv:*mode-lock-keyboard-table* mode-lock-keyboard-table)
    (tv:*mode-lock-state* mode-lock-controller)
    (si:*kbd-auto-repeat-enabled-p* auto-repeat-enabled-p)
    (si:*kbd-repeat-key-enabled-p* repeat-key-enabled-p)
    (si:*kbd-repetition-interval* repetition-interval)
    (si:*kbd-auto-repeat-initial-delay* auto-repeat-initial-delay)
    (si:*kbd-auto-repeat-table* auto-repeat-table)

    ;; Below are declared by cold-load stream, who uses them before we are around.
    (si:kbd-left-shifts left-shifts)
    (si:kbd-right-shifts right-shifts)
    (si:kbd-key-states key-states)
    (si:kbd-fast-fill-key-states fast-fill-key-states)
    (si:shift-lock-xors shift-lock-xors)
    ))

(defmethod (make-instance keyboard) (&rest ignore)
  (when (console-master-p console)
    (forward-compatibility-variables self *main-keyboard-compatibility-variables*))
  (setq mode-lock-keyboard-table keyboard-table
	left-shifts 0
	right-shifts 0
	unlocking-shifts 0
	key-states (make-array 256 :element-type 'boolean)
	fast-fill-key-states (make-array 8 :element-type 'fixnum :displaced-to key-states)
	repeat-last-code nil
	repeat-last-time 0
	last-char-was-repeated-p nil
	repeat-timer nil
	auto-repeat-table (make-array 256 :element-type 'boolean :initial-element t))
  (dolist (key '(#\Function #\Select #\Network #\Suspend #\Resume #\Abort #\Help))
    (setf (keyboard-auto-repeat-p self key) nil)))

(defmethod (keyboard-initialize keyboard) ()
  (setq left-shifts 0
	right-shifts 0
	unlocking-shifts 0)
  (si:fill-array fast-fill-key-states nil 0))

(defun-in-flavor (mouse-kbd-button-transition keyboard) (button value)
  (without-interrupts
    (let* ((mouse (console-mouse console))
	   (i (tv:mouse-buttons-buffer-in-index mouse))
	   (b (tv:mouse-buttons-buffer mouse)))
      ;; Advance the mouse buttons buffer so there is a place to store the shifts
      ;; Assume no mouse button chording when we're doing this
      (setf (aref b i) (ldb (byte 31 0) (%microsecond-clock)))
      (setf (aref b (+ i 1)) (mouse-x mouse))
      (setf (aref b (+ i 2)) (mouse-y mouse))
      (setf (aref b (+ i 3)) (%logdpb (logior left-shifts right-shifts) (byte 16. 16.)
				      (ash value button)))
      (setf (tv:mouse-buttons-buffer-in-index mouse) (ldb (byte 5 0) (+ i 4)))
      (tv:mouse-wakeup mouse))))

(defmethod (keyboard-convert-to-software-char keyboard) (hard-char &optional kbd-table)
  (unless kbd-table
    (setq kbd-table (if (keyboard-use-mode-lock-table-p self)
			mode-lock-keyboard-table keyboard-table)))
  (let ((type (ldb %%kbd-hardware-char-opcode hard-char)))
    (selector type =
      (%type-all-keys-up
	(let ((mask (ldb %%kbd-hardware-char-key-shifts hard-char))
	      (old-left-shifts left-shifts)
	      (old-right-shifts right-shifts))
	  (if all-keys-up-shift-keys
	      ;; Take the mapping of the keys described by the device's all keys up.
	      ;; If they map to shifts, see whether this state is different.  If so,
	      ;; reset things.
	      (loop for key in all-keys-up-shift-keys
		    for mask-bit from 0
		    do
		(when key
		  (let ((mapping (map-key-to-software-char 0 key kbd-table)))
		    (when (and (ldb-test %%kbd-mapping-special mapping)
			       (= (ldb %%kbd-mapping-special-class mapping)
				  %kbd-mapping-special-shift))
		      (let ((on-p (ldb-test (byte 1 mask-bit) mask))
			    (shift-bit (ldb %%kbd-mapping-bit-number mapping))
			    (right-p (ldb-test %%kbd-mapping-right-p mapping)))
			(unless (eq (ldb-test (byte 1 shift-bit)
					      (if right-p right-shifts left-shifts))
				    on-p)
			  (setf (aref key-states key) on-p)
			  (if right-p 
			      (setf (ldb-test (byte 1 shift-bit) right-shifts) on-p)
			      (setf (ldb-test (byte 1 shift-bit) left-shifts) on-p))))))))
	    ;; Symbolics keyboard version.
	    (si:fill-array fast-fill-key-states nil 0)
	    (setq left-shifts (logand left-shifts mask)
		  right-shifts (logand right-shifts mask)
		  ;; This is for keys that are down that we thought were up, e.g. caps lock.
		  left-shifts (logior
				(logand (boole cl:boole-nor left-shifts right-shifts)
					mask)
				left-shifts))
	    #+ignore	;would be necessary if this feature were used on this keyboard.
			;we might want to optimize this to not wakeup the mouse when
			;the state of the buttons was not changing
	    (mouse-kbd-button-transition 0 0))
	  (when (or ( left-shifts old-left-shifts) ( right-shifts old-right-shifts))
	    (keyboard-note-change-of-shift-keys self))
	  nil))
      ((%type-key-up %type-key-down %type-key-repeat)
       (let* ((key-code (ldb %%kbd-hardware-char-key-number hard-char))
	      (shifts (logior left-shifts right-shifts))
	      (mapping (map-key-to-software-char
			 (dpbs (ldb %%kbd-shifts-shift shifts) %%kbd-mapping-table-index-shift
			       (ldb %%kbd-shifts-symbol shifts)
			       %%kbd-mapping-table-index-symbol 0)
			 key-code kbd-table)))
	 (flet ((reset-timer-for-next-repeat ()
		  (when (or (and repeat-key-enabled-p repetition-interval
				 (ldb-test %%kbd-shifts-repeat
					   (logior left-shifts right-shifts)))
			    (and auto-repeat-enabled-p auto-repeat-initial-delay))
		    (setq repeat-last-time (sys:time))
		    (when (and repeat-timer (not tv:cold-load-stream-selected))
		      (process:reset-timer-relative-timer-units
			repeat-timer (* repetition-interval 16666.))))))
	   (selector type =
	     (%type-key-up
	       (setf (aref key-states key-code) nil))
	     (%type-key-down
	       (setf (aref key-states key-code) t)
	       (when (= mapping (dpbs -1 %%kbd-mapping-special
				      %kbd-shifts-repeat %%kbd-mapping-bit-number
				      0))
		 ;; When the repeat key is pressed, we want to start repeating
		 ;; the last character only if its key is still held down.
  
		 ;; There seems to be a bug that causes kbd-get-hardware-char to
		 ;; return a type-2 code when you lift a shift key (including
		 ;; Repeat) in the sequence press-char press-shift lift-shift.
		 ;; The type-2 code causes the key-state array to be cleared out
		 ;; even though a key is down.  This means that the sequence
		 ;; press-char press-repeat lift-repeat press-repeat won't start
		 ;; repeating the second time.  -York 6/8/85
		 (when (and repeat-last-code (not (aref key-states repeat-last-code)))
		   (setq repeat-last-code nil)))
	       (unless (and (integerp mapping)
			    (ldb-test %%kbd-mapping-special mapping))
		 ;; Arrange to repeat this code if it maps to an actual character.
		 (setq repeat-last-code key-code)
		 (reset-timer-for-next-repeat))
	       ;; And clear locking shift keys.  Note that ones used to make char below have
	       ;; been snapshotted.
	       (when (not (zerop unlocking-shifts))
		 (setq left-shifts (logandc2 left-shifts unlocking-shifts)
		       right-shifts (logandc2 right-shifts unlocking-shifts))))
	     (%type-key-repeat
	       (reset-timer-for-next-repeat))))
	 (cond ((= type %type-key-up)
		;; Key up, just update shifts if that's what this mapping does.
		(when (and (integerp mapping)
			   (ldb-test %%kbd-mapping-special mapping))
		  (selector (ldb %%kbd-mapping-special-class mapping) =
		    (%kbd-mapping-special-shift
		      (let ((bit (byte 1 (ldb %%kbd-mapping-bit-number mapping))))
			(if (ldb-test %%kbd-mapping-right-p mapping)
			    (setf (ldb bit right-shifts) 0)
			    (setf (ldb bit left-shifts) 0)))
		      (keyboard-note-change-of-shift-keys self))
		    (%kbd-mapping-special-mouse-button
		      (mouse-kbd-button-transition (ldb %%kbd-mapping-bit-number mapping) 0))))
		nil)
	       ;; Note that we don't apply caps lock of bits to non-integer mappings.
	       ((not (integerp mapping)) mapping)
	       ((not (ldb-test %%kbd-mapping-special mapping))
		(let ((soft-char (code-char mapping))
		      (bits (ldb %%kbd-shifts-bits shifts)))
		  (cond ((not (zerop bits))
			 ;; Control character, swap cases, ignore caps lock
			 (make-char (char-flipcase soft-char) bits))
			((both-case-p soft-char)
			 ;; Not a control character, caps lock applies
			 (if (ldb-test %%kbd-shifts-caps-lock shifts)
			     (if shift-lock-xors
				 (char-flipcase soft-char)
				 (char-upcase soft-char))
			     soft-char))
			(t soft-char))))
	       (t
		(let ((class (ldb %%kbd-mapping-special-class mapping)))
		  (selector class =
		    (%kbd-mapping-special-shift
		     (let ((bit (byte 1 (ldb %%kbd-mapping-bit-number mapping))))
		       (if (ldb-test %%kbd-mapping-right-p mapping)
			   (setf (ldb bit right-shifts) 1)
			   (setf (ldb bit left-shifts) 1))
		       (when (= class %kbd-mapping-special-locking-once-shift)
			 (setf (ldb bit unlocking-shifts) 1)))
		     (keyboard-note-change-of-shift-keys self))
		    ((%kbd-mapping-special-locking-shift
		      %kbd-mapping-special-locking-once-shift)
		     (let ((mask (ash 1 (ldb %%kbd-mapping-bit-number mapping))))
		       (if (ldb-test %%kbd-mapping-right-p mapping)
			   (setq right-shifts (logxor right-shifts mask))
			   (setq left-shifts (logxor left-shifts mask)))
		       (when (= class %kbd-mapping-special-locking-once-shift)
			 (setq unlocking-shifts (logxor unlocking-shifts mask))))
		     (keyboard-note-change-of-shift-keys self))
		    (%kbd-mapping-special-unassigned
		      (console-beep console))
		    (%kbd-mapping-special-mouse-button
		      (mouse-kbd-button-transition (ldb %%kbd-mapping-bit-number mapping) 1))))
		nil)))))))

(defmethod (keyboard-use-mode-lock-table-p keyboard) ()
  (and (eq mode-lock-controller :keyboard)
       (ldb-test %%kbd-shifts-mode-lock (logior left-shifts right-shifts))))

(defun-in-flavor (compute-mouse-bits keyboard)
		 (&optional (shifts (logior left-shifts right-shifts)))
  (dpbs (ldb %%kbd-shifts-bits shifts) %%mouse-shifts-bits
	(ldb %%kbd-shifts-shift shifts) %%mouse-shifts-shift
	0))

;;; This is a method so that other flavors can add things to update LED's, wholine
;;; display, etc.
(defmethod (keyboard-note-change-of-shift-keys keyboard) ()
  (let ((sw (console-selected-window console)))
    (when sw
      (send-if-handles sw :change-of-shift-keys
		       (console-mouse console) (compute-mouse-bits)))))

;;; This deliberately ignores *MOUSE-INCREMENTING-KEYSTATES* and *MOUSE-MODIFYING-KEYSTATES*,
;;; which are really no longer relevant.
(defmethod (keyboard-convert-to-mouse-char keyboard) (button shifts)
  (make-mouse-char button (compute-mouse-bits shifts)))

(defmethod (keyboard-include-mouse-button-shift-keys keyboard) (bd)
  (loop for (key-button . keys) in mouse-button-shift-keys
	when (loop for key in keys always (aref key-states key))
	  return (setq bd (ash 1 key-button)))
  bd)

(defmethod (keyboard-shifts keyboard) ()
  (values (logior left-shifts right-shifts)
	  left-shifts right-shifts))

;--- Temporary definition until better keytop naming scheme in
(defun key-code-for-character (keyboard-table key)
  (dotimes (shift-index (keyboard-table-shift-index-limit keyboard-table))
    (dotimes (key-code (keyboard-table-key-code-limit keyboard-table))
      (when (keyboard-table-mapping-equal
	      (map-key-to-software-char shift-index key-code keyboard-table)
	      key)
	(return-from key-code-for-character
	  (values key-code shift-index))))))

;--- Temporary definition until better keytop naming scheme in
(defmethod (keyboard-key-state keyboard) (key)
  (etypecase key
    (integer
      (aref key-states key))
    (character
      (let ((index (key-code-for-character keyboard-table key)))
	(and index (aref key-states index))))
    (keyword
      (let ((index (position key *kbd-mapping-bit-names*)))
	(when index
	  (ldb-test (byte 1 (ldb %%kbd-mapping-bit-number index))
		    (cond ((ldb-test %%kbd-mapping-left-p index) left-shifts)
			  ((ldb-test %%kbd-mapping-right-p index) right-shifts)
			  (t (logior left-shifts right-shifts)))))))
    ;--- Something like a keysym
    ))

(defmethod (keyboard-time-to-repeat keyboard) ()
  (or
    ;; If the repeat key is enabled
    (and repeat-key-enabled-p
	 ;; Let's be safe and check this too.  NIL for the interval
	 ;; used to disable repeat key.
	 repetition-interval
	 ;; make sure repeat key is still held down
	 (ldb-test %%kbd-shifts-repeat (logior left-shifts right-shifts))
	 repeat-last-code
	 ;; has enough time elapsed since the last repetition?
	 (or (time-elapsed-p repetition-interval repeat-last-time)
	     (when repeat-timer
	       ;; If we aren't going to run now, make sure that we will before it's too late.
	       (let ((interval (* repetition-interval 16666)))
		 (unless (and (process:timer-pending-p repeat-timer)
			      (process:timer-expires-by-relative-timer-units repeat-timer interval))
		   (process:reset-timer-relative-timer-units repeat-timer interval))
		 nil))))
    ;; If auto-repeating is enabled
    (and auto-repeat-enabled-p
	 ;; Let's be safe and check this too.
	 auto-repeat-initial-delay
	 repeat-last-code
	 ;; Make sure that the last key typed is a key that we allow repeating
	 ;; on, and make sure that it's still down.
	 (aref auto-repeat-table repeat-last-code)
	 (aref key-states repeat-last-code)
	 (or (let ((time (sys:time)))
	       (and (or
		      ;; If the last char "typed" was generated by the repeat
		      ;; facility, don't wait the initial delay again.
		      last-char-was-repeated-p
		      ;; Otherwise, wait the initial delay before auto-repeating
		      (time-elapsed-p auto-repeat-initial-delay
				      repeat-last-time
				      time))
		    ;; Make sure that enough time has elapsed since the last repetition
		    (time-elapsed-p repetition-interval
				    repeat-last-time
				    time)))
	     (when repeat-timer
	       ;; If we aren't going to run now, make sure that we will before it's too late.
	       (let ((interval (* (if last-char-was-repeated-p
				      repetition-interval
				      auto-repeat-initial-delay)
				  16666)))
		 (unless (and (process:timer-pending-p repeat-timer)
			      (process:timer-expires-by-relative-timer-units repeat-timer interval))
		   (process:reset-timer-relative-timer-units repeat-timer interval))
		 nil))))))

(defmethod (keyboard-repeat-hardware-char keyboard) ()
  (setq last-char-was-repeated-p t)
  (dpb %type-key-repeat %%kbd-hardware-char-opcode repeat-last-code))

(compile-flavor-methods keyboard)

;;;; User remapping

(defmethod (console-note-keyboard-table-remapping console :default)
	   (value layout-type index &key shift symbol all-shifts)
  (declare (ignore value layout-type index shift symbol all-shifts))
  )

(defvar *keyboard-table-remappings* nil)

;--- Should be a generic function if tables can also be instances
(defun copy-keyboard-table (table &key (element-type (array-element-type table)))
  (let ((new (make-array (array-dimensions table) :element-type element-type)))
    (copy-array-contents table new)
    new))

;--- Should use keysym mapping scheme, including names for mouse buttons.
(defun set-keyboard-table-mapping (value table index &key (shift nil shift-p)
				   (symbol nil symbol-p)
				   all-shifts)
  (let ((value value)
	(table table))
    (unless (arrayp table)
      (setq table (find-settable-keyboard-table table)))
    (let ((fix-p (array-bits-per-element (array-type-field table))))
      (setq value (standardize-keyboard-mapping value fix-p))
      (when (and fix-p (not (integerp value)))
	(setq table (structure-forward table (copy-keyboard-table table :element-type 't)))))
    (let ((char-index index)
	  (shift-index 0))
      (unless (integerp char-index)
	(multiple-value-setq (char-index shift-index)
	  (key-code-for-character table char-index))
	(when (null char-index)
	  (error "No mapping currently in effect for ~C" char-index)))
      (if all-shifts
	  (dotimes (shift-index (keyboard-table-shift-index-limit table))
	    (setf (aref table shift-index char-index) value))
	(when shift-p
	  (setf (ldb %%kbd-mapping-table-index-shift shift-index) (if shift 1 0)))
	(when symbol-p
	  (setf (ldb %%kbd-mapping-table-index-symbol shift-index) (if symbol 1 0)))
	(setf (aref table shift-index char-index) value))))
  (unless (arrayp table)
    (let ((remapping
	    `(,value ,table ,index
	      ,@(and shift-p `(:shift ,shift))
	      ,@(and symbol-p `(:symbol ,symbol))
	      ,@(and all-shifts `(:all-shifts ,all-shifts)))))
      (pushnew remapping *keyboard-table-remappings* :test #'equal :key #'cdr :replace t)
      (dolist (console *consoles*)
	(apply #'console-note-keyboard-table-remapping console remapping))))
  value)

(defun keyboard-table-mapping-equal (mapping-1 mapping-2)
  (equal (standardize-keyboard-mapping mapping-1 t)
	 (standardize-keyboard-mapping mapping-2 t)))

;--- Temporary until new keysym mapping scheme installed
;--- Also, these might want to go in a hardware specific file.
(defparameter *symbolics-keyboard-mapping*
  '(:local					;0 local (function on old keyboards)
    :caps-lock					;1 caps lock
    :left-hyper					;2 left hyper
    :left-meta					;3 left meta
    :right-control				;4 right control
    :right-super				;5 right super
    #\Scroll					;6 scroll
    :mode-lock					;7 mode lock
    #\Select					;10 select
    :left-symbol				;11 left symbol
    :left-super					;12 left super
    :left-control				;13 left control
    #\Space					;14 space
    :right-meta					;15 right meta
    :right-hyper				;16 right hyper
    #\End					;17 end
    (#\z #\Z)					;20 z
    (#\c #\C)					;21 c
    (#\b #\B nil #\)				;22 b
    (#\m #\M)					;23 m
    (#\. #\> #\)				;24 .
    :right-shift				;25 right shift
    :repeat					;26 repeat
    #\Abort					;27 abort
    :left-shift					;30 left shift
    (#\x #\X)					;31 x
    (#\v #\V)					;32 v
    (#\n #\N)					;33 n
    (#\, #\< #\)				;34 ,
    (#\/ #\? #\‡)				;35 /
    :right-symbol				;36 right symbol
    (#\Help #\Help #\Symbol-help #\Symbol-help)	;37 help
    #\Rubout					;40 rubout
    (#\s #\S)					;41 s
    (#\f #\F)					;42 f
    (#\h #\H #\)				;43 h
    (#\k #\K #\)				;44 k
    (#\; #\: nil #\Œ)				;45 ;
    #\Return					;46 return
    #\Complete					;47 complete
    #\Network					;50 network
    (#\a #\A nil #\)				;51 a
    (#\d #\D nil #\)				;52 d
    (#\g #\G #\ #\‰)				;53 g
    (#\j #\J #\)				;54 j
    (#\l #\L #\ #\ˆ)				;55 l
    (#\' #\" #\ )				;56 '
    #\Line					;57 line
    #\Function					;60 function (local on old keyboards)
    (#\w #\W #\)				;61 w
    (#\r #\R #\)				;62 r
    (#\y #\Y #\)				;63 y
    (#\i #\I #\)				;64 i
    (#\p #\P #\ #\)				;65 p
    (#\) #\])					;66 )
    #\Page					;67 page
    #\Tab					;70 tab
    (#\q #\Q #\)				;71 q
    (#\e #\E #\ #\)				;72 e
    (#\t #\T #\)				;73 t
    (#\u #\U #\)				;74 u
    (#\o #\O #\)				;75 o
    (#\( #\[)					;76 (
    #\Backspace					;77 backspace (\ on old keyboards)
    (#\: #\: #\Œ #\Œ)				;100 :
    (#\2 #\@)					;101 2
    (#\4 #\$)					;102 4
    (#\6 #\^)					;103 6
    (#\8 #\* nil #\)				;104 8
    (#\0 #\))					;105 0
    (#\= #\+ #\ #\Š)				;106 =
    (#\\ #\{)					;107 \ (` on old keyboards)
    (#\1 #\!)					;110 1
    (#\3 #\#)					;111 3
    (#\5 #\%)					;112 5
    (#\7 #\&)					;113 7
    (#\9 #\()					;114 9
    (#\- #\_ #\)				;115 -
    (#\` #\~ #\)				;116 ~ (lowercase ~ on old keyboards)
    (#\| #\})					;117 (backspace on old keyboards)
    (#\Escape #\ #\)				;120 escape
    #\Refresh					;121 refresh
    #\Square					;122 square
    #\Circle					;123 circle
    #\Triangle					;124 triangle
    #\Clear-input				;125 clear input
    #\Suspend					;126 suspend
    #\Resume					;127 resume
    ))

;--- Temporary, should come from OBS/SLB shared flavor to allow embedded to get another kind.
;si:kbd-new-table  (make-keyboard-table *symbolics-keyboard-mapping*)
(defmethod (console-create-keyboard console) ()
  (make-keyboard :console self :keyboard-table si:kbd-new-table :layout-type :symbolics))

;--- To be upgraded to new keyboard layout altering interface
;;; This function can never be removed.  There will always be keyboards that have never
;;; been upgraded with the "new" keytops that "were installed by" April 1984.  Let this
;;; be a lesson to those of us who would require hardware upgrades.
(defun si:set-keyboard-layout
       (&optional (new-p (not (y-or-n-p "Local in top-left corner, tilde lower case? "))))
  (cond ((not new-p)
	 ;; Old layout
	 (dotimes (i 4)
	   (setf (aref si:kbd-new-table i #o60) #o140000)	;Local
	   (setf (aref si:kbd-new-table i #o0) (char-code #\Function)))
	 (setf (aref si:kbd-new-table 0 #o116) (char-code #\~))
	 (setf (aref si:kbd-new-table 1 #o116) (char-code #\{))
	 (setf (aref si:kbd-new-table 2 #o116) (char-code #\))
	 (setf (aref si:kbd-new-table 0 #o107) (char-code #\`))
	 (setf (aref si:kbd-new-table 1 #o107) (char-code #\}))
	 (dotimes (i 4)
	   (setf (aref si:kbd-new-table i #o117) (char-code #\Backspace)))
	 (setf (aref si:kbd-new-table 0 #o77) (char-code #\\))
	 (setf (aref si:kbd-new-table 1 #o77) (char-code #\|)))
	(t
	 ;; New layout
	 (dotimes (i 4)
	   (setf (aref si:kbd-new-table i #o0) #o140000)	;Local
	   (setf (aref si:kbd-new-table i #o60) (char-code #\Function)))
	 (setf (aref si:kbd-new-table 0 #o116) (char-code #\`))
	 (setf (aref si:kbd-new-table 1 #o116) (char-code #\~))
	 (setf (aref si:kbd-new-table 2 #o116) (char-code #\))
	 (setf (aref si:kbd-new-table 0 #o107) (char-code #\\))
	 (setf (aref si:kbd-new-table 1 #o107) (char-code #\{))
	 (setf (aref si:kbd-new-table 0 #o117) (char-code #\|))
	 (setf (aref si:kbd-new-table 1 #o117) (char-code #\}))
	 (dotimes (i 4)
	   (setf (aref si:kbd-new-table i #o77) (char-code #\Backspace)))))) 
