;;; -*- Package:SYSTEM-INTERNALS; Mode:LISP; Base:8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; L machine dependent functional object format interpretation
;;; This file is in the cold load.

(DEFVAR *STORE-BACK-EXPANDED-EXTRA-INFO* T)

;; (:INTERNAL parent-function index name) refers to the index'th unnamed
;; broken-off lambda in the parent function.
;; parent-function is normally a function-spec, but it may also be a compiled function.
;; Note that VALIDATE-FUNCTION-SPEC for :INTERNAL returns NIL if the
;; function-spec itself is malformed, however if the spec is well-formed
;; but the parent doesn't have internal functions, an error is signalled
;; giving a detailed explanation.
;; name comes from LABELS and is optional.


(DEFINE-FUNCTION-SPEC-HANDLER :INTERNAL (FUNCTION FUNCTION-SPEC &OPTIONAL ARG1 ARG2)
  (LET* ((PARENT (SECOND FUNCTION-SPEC))
	 (INDEX (THIRD FUNCTION-SPEC))
	 (DIRECT-COMPILED (TYPEP PARENT ':COMPILED-FUNCTION)))
    ;; Perform basic validation before accessing parent
    (AND ( 3 (LENGTH FUNCTION-SPEC) 4)
	 (FIXNUMP INDEX)
	 (NOT (MINUSP INDEX))
	 ;; Function spec basically valid
	 (SELECTQ FUNCTION
	   ;; Functions that don't need parent to be defined
	   (VALIDATE-FUNCTION-SPEC (OR DIRECT-COMPILED (VALIDATE-FUNCTION-SPEC PARENT)))
	   (FUNCTION-PARENT (VALUES PARENT 'DEFUN))
	   ;; Functions that must access the slot in the parent
	   ((FDEFINE FDEFINITION FDEFINEDP FDEFINITION-LOCATION)
	    (AND (OR (NEQ FUNCTION 'FDEFINEDP)	;FDEFINEDP is NIL if the parent is not defined
		     DIRECT-COMPILED
		     (FDEFINEDP PARENT))
		 (LET ((COMPILED-FUNCTION
			 (IF DIRECT-COMPILED PARENT
			     ;; The following complicated looking stuff not only allows
			     ;; internal functions of encapsulations, but avoids taking
			     ;; time exponential in the depth of nesting of :INTERNAL
			     ;; function specs.  It's amazing how slow it could get.
			     ;; FDEFINITION also takes care of (VALIDATE-FUNCTION-SPEC PARENT).
			     #+++ignore (FDEFINITION (UNENCAPSULATE-FUNCTION-SPEC PARENT))
			     #---ignore 
			     (LET ((COMPILED-CODE (FDEFINITION PARENT)))
			       (IF (AND (TYPEP COMPILED-CODE ':COMPILED-FUNCTION)
					(EQUAL (COMPILED-FUNCTION-NAME COMPILED-CODE) PARENT)
					(NOT (COMPILED-FUNCTION-ENCAPSULATED-P COMPILED-CODE)))
				   ; Don't bother unencapsulating, because we've got a
				   ; match.  This is the way we allow you to have internal
				   ; functions of encapsulations.
				   COMPILED-CODE
				   (FDEFINITION (UNENCAPSULATE-FUNCTION-SPEC PARENT))))))
		       (FUNCTION-DEFINED T)	;assume function is defined
		       TABLE OFFSET)
		   ;; Don't be fooled by macros, interpreted or compiled,
		   ;; nor by special form interpreters.
		   (WHEN (LISTP COMPILED-FUNCTION)
		     (SETQ COMPILED-FUNCTION (OR (SPECIAL-FORM-P COMPILED-FUNCTION)
						 (MACRO-FUNCTION COMPILED-FUNCTION)
						 COMPILED-FUNCTION)))
		   (WHEN (TYPEP COMPILED-FUNCTION :LEXICAL-CLOSURE)
		     (SETQ COMPILED-FUNCTION (LEXICAL-CLOSURE-FUNCTION COMPILED-FUNCTION)))
		   (UNLESS (TYPEP COMPILED-FUNCTION ':COMPILED-FUNCTION)
		     (FERROR
			 "The function spec ~S refers to ~S, which is not a compiled function"
		       FUNCTION-SPEC COMPILED-FUNCTION))
		   (UNLESS (SETQ TABLE (COMPILED-FUNCTION-INTERNAL-FUNCTION-OFFSETS
					 COMPILED-FUNCTION))
		     (IF (EQ FUNCTION 'FDEFINEDP)
			 (SETQ FUNCTION-DEFINED NIL)
		       (FERROR
			   "The function spec ~S refers to ~S, ~
		            which has no internal functions"
			 FUNCTION-SPEC COMPILED-FUNCTION)))
		   (UNLESS (OR (NULL FUNCTION-DEFINED)
			       (SETQ OFFSET (NTH INDEX TABLE)))
		     (IF (EQ FUNCTION 'FDEFINEDP)
			 (SETQ FUNCTION-DEFINED NIL)
		       (FERROR "The function spec ~S is out of range" FUNCTION-SPEC)))
		   #+3600
		   (PROGN
		     (UNLESS (NULL FUNCTION-DEFINED)
		       (SETQ OFFSET (- -1 OFFSET)))	;Make a pointer type offset
		     
		     ;; Function spec fully parsed, we can now earn our living
		     (SELECTQ FUNCTION
		       (FDEFINE
			(%P-STORE-CONTENTS-OFFSET ARG1 COMPILED-FUNCTION OFFSET))
		       (FDEFINITION
			(%P-CONTENTS-OFFSET COMPILED-FUNCTION OFFSET))
		       ((FDEFINEDP)
			FUNCTION-DEFINED)		;I guess it must be if we got this far
		       (FDEFINITION-LOCATION
			(%MAKE-POINTER-OFFSET DTP-LOCATIVE COMPILED-FUNCTION OFFSET))))
		   #+IMACH
		   (SELECTQ FUNCTION
		     (FDEFINE
		       ;;;--- This should use the linker substrate to replace
		       ;;;--- internal functions.  Somehow the linker has to know
		       ;;;--- about every such redefinition, too.
		       (ERROR "FDEFINING internal function is not allowed yet"))
		     (FDEFINITION
		       OFFSET)
		     ((FDEFINEDP)
		      FUNCTION-DEFINED)
		     (FDEFINITION-LOCATION
		      (FERROR "Internal functions have no fixed location on Ivory"))
		     ))))
	   (OTHERWISE
	    (AND (OR DIRECT-COMPILED (VALIDATE-FUNCTION-SPEC PARENT))
		 (FUNCTION-SPEC-DEFAULT-HANDLER FUNCTION FUNCTION-SPEC ARG1 ARG2)))))))

(DEFUN COMPILED-FUNCTION-ENCAPSULATED-P (COMPILED-FUNCTION)
  (DOLIST (THING (CDR (CCA-EXTRA-INFO (COMPILED-FUNCTION-CCA COMPILED-FUNCTION))))
    (WHEN (AND (LISTP THING)
	       (MEMQ (CAR THING) '(COMPILED-ENCAPSULATION ENCAPSULATED-DEFINITION)))
      (RETURN T))))

;; Get something that is not specially encoded.  Let's application still use this
;; data at runtime without unnecessarily uncompressing the rest of the debug-info.
(DEFUN DEBUGGING-INFO-USER-ENTRY (FUNCTION TYPE)
  (CL:TYPECASE FUNCTION
    (CL:COMPILED-FUNCTION
      (DOLIST (ENTRY (CDR (CCA-EXTRA-INFO (COMPILED-FUNCTION-CCA FUNCTION))))
	(WHEN (AND (LISTP ENTRY) (EQ (CAR ENTRY) TYPE))
	  (RETURN ENTRY))))
    (CLOS-INTERNALS:FUNCALLABLE-INSTANCE
      (COND ((LET ((CLASS (CLOS:FIND-CLASS 'CLOS:STANDARD-GENERIC-FUNCTION NIL)))
	       (OR (NULL CLASS)			;CLOS bootstrapping
		   (NOT (CLOS-INTERNALS:TYPEP-CLASS FUNCTION CLASS))
		   (AND (FBOUNDP 'CLOS-INTERNALS::GENERIC-FUNCTION-EXPLICITLY-DEFINED-P)
			(CLOS-INTERNALS::GENERIC-FUNCTION-EXPLICITLY-DEFINED-P FUNCTION))))
	     (ASSQ TYPE (DEBUGGING-INFO FUNCTION)))
	    ((AND (BOUNDP 'CLOS-INTERNALS::*DECL-TYPES-INHERITED-FROM-METHOD*)
		  (MEMBER TYPE CLOS-INTERNALS::*DECL-TYPES-INHERITED-FROM-METHOD*))
	     ;; Note:  ARGLIST, which is special-cased by DEBUGGING-INFO
	     ;; for CLOS generic functions, is compressed in functions,
	     ;; so we assume that DEBUGGING-INFO-USER-ENTRY won't be
	     ;; used to access it.
	     (LOOP FOR METHOD IN (CLOS:GENERIC-FUNCTION-METHODS FUNCTION)
		   FOR METHOD-FUNCTION = (CLOS:METHOD-FUNCTION METHOD)
		   DOING
	       (WHEN METHOD-FUNCTION
		 (LET ((ENTRY (DEBUGGING-INFO-USER-ENTRY METHOD-FUNCTION TYPE)))
		   (WHEN ENTRY (RETURN-FROM DEBUGGING-INFO-USER-ENTRY ENTRY))))))
	    (T
	     ;; Won't be inherited, and not in the method
	     NIL)))
    (OTHERWISE
      (ASSQ TYPE (DEBUGGING-INFO FUNCTION)))))

(DEFUN CCA-DEBUGGING-INFO-USER-ENTRY (CCA TYPE)
  (DOLIST (ENTRY (CDR (CCA-EXTRA-INFO CCA)))
    (WHEN (AND (LISTP ENTRY) (EQ (CAR ENTRY) TYPE))
      (RETURN ENTRY))))


;;; Is this where these declarations should go?
(DEFPROP COMPILER:ARGLIST-TYPES T SI:DEBUG-INFO)

(DEFPROP COMPILER:VALUE-TYPES T SI:DEBUG-INFO)

(DEFPROP COMPILER:ARGLIST-FINDER T SI:DEBUG-INFO)

;; ARGLIST returns the list of argument names and the list of
;; returned value names of the definition of a function spec.
;; The first value is the arglist: a list of the names
;; of the arguments, together with lambda list keywords.
;; The second value is the list of returned value names.
;; This list is present only if the definition of the function
;; supplies one, and it is just a comment.  Those names play no
;; actual role in execution.

;; The argument REAL-FLAG is T to inhibit the use of any declared
;; (comment only) arglist information.  Only the actual arglist of the function
;; is returned.  Normally the arglist specified for human comsumption
;; with an arglist declaration overrides the real one.

;; REAL-FLAG also inhibits following encapsulations.
;; So you get the arglist of the encapsulation rather than the
;; original definition.

;; T should be used by anything that requires a "legitimate" arglist
;; that reliably corresponds to what the function does with its args.

;; We accept both functions and function specs.

(DEFUN ARGLIST (FUNCTION &OPTIONAL REAL-FLAG ARGLIST-FINDER &AUX TEM)
  (DECLARE (VALUES ARGLIST VALUES TYPE ARGLIST-TYPES VALUE-TYPES))
  (DECLARE LT:(SIDE-EFFECTS READER))
  (UNLESS ARGLIST-FINDER
    (SETF ARGLIST-FINDER (SECOND (ASSOC 'COMPILER:ARGLIST-FINDER (DEBUGGING-INFO FUNCTION)))))
  (CL:ETYPECASE FUNCTION
    (SYMBOL
      (IF ARGLIST-FINDER
	  ;; If there's a finder function, it's the only one allowed to look
	  ;;--- Someday, make this work for non-symbols
	  (MULTIPLE-VALUE-BIND (ARGLIST VALUES TYPE ARGLIST-TYPES VALUE-TYPES FOUND-P)
	      (FUNCALL ARGLIST-FINDER FUNCTION)
	    (IF (OR FOUND-P ARGLIST)
		;; This is a likely a predication, just ignore REAL-FLAG
		(VALUES ARGLIST VALUES TYPE ARGLIST-TYPES VALUE-TYPES)
		;; This is undefined, either as a function or as a
		;; Joshua-style predication.
		;; this is too gross
		;; (FSYMEVAL NIL)
		(SIGNAL 'UNDEFINED-FUNCTION :FUNCTION-NAME FUNCTION)))
	  (MULTIPLE-VALUE-BIND (ARGLIST VALUES TYPE ARGLIST-TYPES VALUE-TYPES)
	      (ARGLIST (FSYMEVAL FUNCTION) REAL-FLAG)
	    (IF (AND (EQ TYPE 'SHARED-STRUCTURE-ACCESSOR)
		     (SETQ TEM (GET FUNCTION 'DEFSTRUCT-SLOT)))
		(VALUES (LIST (CAR TEM)) VALUES 'SUBST ARGLIST-TYPES VALUE-TYPES)
		(VALUES ARGLIST VALUES TYPE ARGLIST-TYPES VALUE-TYPES)))))
    ((CL:SATISFIES INTERPRETED-FUNCTION-P)
     (INTERPRETED-FUNCTION-ARGLIST (INTERPRETED-FUNCTION-LAMBDA-EXPRESSION FUNCTION)
				   REAL-FLAG))
    (CONS
      (SELECTQ (FIRST FUNCTION)
	((SPECIAL)
	 (MULTIPLE-VALUE-BIND (ARGLIST VALUES FLAG ARGLIST-TYPES VALUE-TYPES)
	     (ARGLIST (OR (THIRD FUNCTION) (SECOND FUNCTION)) REAL-FLAG)
	   (VALUES ARGLIST VALUES (OR FLAG
				      (COND ((NULL (SECOND FUNCTION)) 'SPECIAL)
					    ((NULL (THIRD FUNCTION)) 'MACRO)
					    (T 'SPECIAL-MACRO)))
		   ARGLIST-TYPES VALUE-TYPES)))
	((DIGESTED-LAMBDA)
	 (INTERPRETED-FUNCTION-ARGLIST FUNCTION REAL-FLAG))
	(OTHERWISE
	 (SETF FUNCTION (LAMBDA-MACRO-EXPAND FUNCTION NIL))
	 (IF (INTERPRETED-LAMBDA-P FUNCTION)
	     (INTERPRETED-FUNCTION-ARGLIST FUNCTION REAL-FLAG)
	     (ARGLIST (FDEFINITION FUNCTION) REAL-FLAG)))))		
    (CL:ARRAY
      (VALUES (LOOP FOR I FROM 0 BELOW (ARRAY-/#-DIMS FUNCTION)
		    COLLECT (FORMAT NIL "DIM-~D" (1+ I)))
	      NIL
	      'ARRAY))
    (SYS:LEXICAL-CLOSURE
      (LET ((FUN (LEXICAL-CLOSURE-FUNCTION FUNCTION)))
	(MULTIPLE-VALUE-BIND (ARGLIST VALUES TYPE ARGLIST-TYPES VALUE-TYPES)
	    (ARGLIST FUN REAL-FLAG)
	  (VALUES (IF (TYPEP FUN :COMPILED-FUNCTION)
		      (IF (OR (NOT (ASSQ 'REAL-ARGLIST (DEBUGGING-INFO FUN)))
			      REAL-FLAG)
			  ;; Don't include COMPILER:.LEXICAL-ENVIRONMENT-POINTER.
			  (CDR ARGLIST)
			  ARGLIST)
		      ARGLIST)
		  VALUES TYPE ARGLIST-TYPES VALUE-TYPES))))
    (SYS:DYNAMIC-CLOSURE
      (ARGLIST (CAR (%MAKE-POINTER DTP-LIST FUNCTION)) REAL-FLAG))
    ((CL:SATISFIES SYS:FUNCALLABLE-INSTANCE-P)
      (LET ((DEBUG-INFO (DEBUGGING-INFO FUNCTION)))
	(IF (AND (NOT REAL-FLAG)
		 (ASSQ 'ENCAPSULATED-DEFINITION DEBUG-INFO))
	    (ARGLIST
	      (CADR (ASSQ 'ENCAPSULATED-DEFINITION DEBUG-INFO))
	      REAL-FLAG ARGLIST-FINDER)
	    (VALUES (OR (CDR (ASSQ (IF REAL-FLAG 'REAL-ARGLIST 'ARGLIST) DEBUG-INFO))
			(CLOS-INTERNALS:ARGLIST-OBJECT FUNCTION))
		    (CDR (ASSQ 'VALUES DEBUG-INFO))
		    'CLOS:GENERIC-FUNCTION
		    (CDR (ASSQ 'COMPILER:ARGLIST-TYPES DEBUG-INFO))
		    (CDR (ASSQ 'COMPILER:VALUE-TYPES DEBUG-INFO))))))
    (CLI::INSTANCE
      '(MESSAGE &REST INSTANCE-ARGS-VARY))
    (SYS:COMPILED-FUNCTION
      (LET ((DEBUG-INFO (DEBUGGING-INFO FUNCTION)))
	(IF (AND (NOT REAL-FLAG)
		 (ASSQ 'ENCAPSULATED-DEFINITION DEBUG-INFO))
	    (ARGLIST (CADR (ASSQ 'ENCAPSULATED-DEFINITION DEBUG-INFO)) REAL-FLAG ARGLIST-FINDER)
	    (VALUES (CDR (IF REAL-FLAG
			     (OR (ASSQ 'REAL-ARGLIST DEBUG-INFO) (ASSQ 'ARGLIST DEBUG-INFO))
			     (ASSQ 'ARGLIST DEBUG-INFO)))
		    (CDR (OR (ASSQ 'VALUES DEBUG-INFO)
			     ;;+++ Someone should really get rid of this next major release.
			     (ASSQ 'RETURN-LIST DEBUG-INFO)))
		    (COND ((ASSQ 'SHARED-STRUCTURE-ACCESSOR DEBUG-INFO)
			   'SHARED-STRUCTURE-ACCESSOR)
			  ((LT:FUNCTION-INLINE-FORM-METHOD FUNCTION)
			   'SUBST))
		    (CDR (ASSQ 'COMPILER:ARGLIST-TYPES DEBUG-INFO))
		    (CDR (ASSQ 'COMPILER:VALUE-TYPES DEBUG-INFO))))))
    (SYS:GENERIC-FUNCTION
      (LET* ((DEBUG-INFO (EXPAND-GENERIC-FUNCTION-DEBUGGING-INFO FUNCTION))
	     (ARGLIST (AND (NOT REAL-FLAG) (ASSQ 'ARGLIST DEBUG-INFO)))
	     (VALUES (CDR (ASSQ 'VALUES DEBUG-INFO))))
	(SETQ ARGLIST (IF ARGLIST (CDR ARGLIST) (GENERIC-FUNCTION-ARGLIST FUNCTION)))
	(IF (FLAVOR::GENERIC-FUNCTION-MESSAGE-P FUNCTION)
	    (VALUES (CDR ARGLIST)		;Remove instance argument
		    VALUES
		    'MESSAGE
		    (CDR (ASSQ 'COMPILER:ARGLIST-TYPES DEBUG-INFO))
		    (CDR (ASSQ 'COMPILER:VALUE-TYPES DEBUG-INFO)))
	    (VALUES ARGLIST
		    VALUES
		    'GENERIC-FUNCTION
		    (CDR (ASSQ 'COMPILER:ARGLIST-TYPES DEBUG-INFO))
		    (CDR (ASSQ 'COMPILER:VALUE-TYPES DEBUG-INFO))))))))


#+IMACH
(DEFUN COMPILED-FUNCTION-ARGS-INFO (CCA)
  (LET ((ENTRY (%MEMORY-READ (%POINTER-PLUS CCA (DEFSTORAGE-SIZE COMPILED-FUNCTION)))))
    (WHEN ( (LDB %%Q-TYPE-WITHIN-TAG (%TAG ENTRY)) DTP-PACKED-INSTRUCTION-60)
      (SETQ ENTRY (%POINTER ENTRY))
      (LET ((MIN (- (LDB %%ENTRY-INSTRUCTION-MIN ENTRY) 2))
	    (MAX (- (LDB %%ENTRY-INSTRUCTION-MAX ENTRY) 2))
	    (OPCODE (LDB %%PACKED-INSTRUCTION-OPCODE ENTRY)))
	(WHEN (= OPCODE I-LISP-COMPILER:*ENTRY-REST-ACCEPTED-OPCODE*)
	  (RETURN-FROM COMPILED-FUNCTION-ARGS-INFO
	    (%LOGDPBS MAX %%ARG-DESC-MAX-ARGS
		      MIN %%ARG-DESC-MIN-ARGS
		      1 %%ARG-DESC-REST-ARG
		      0)))
	(WHEN (= OPCODE I-LISP-COMPILER:*ENTRY-REST-NOT-ACCEPTED-OPCODE*)
	  (RETURN-FROM COMPILED-FUNCTION-ARGS-INFO
	    (%LOGDPBS MAX %%ARG-DESC-MAX-ARGS
		      MIN %%ARG-DESC-MIN-ARGS
		      0)))))
    (%LOGDPBS 0 %%ARG-DESC-MAX-ARGS
	      0 %%ARG-DESC-MIN-ARGS
	      1 %%ARG-DESC-REST-ARG
	      0)))

(DEFUN %ARGS-INFO (FUNCTION)
  (TYPECASE FUNCTION
    (:SYMBOL
     (%ARGS-INFO (FSYMEVAL FUNCTION)))
    (:COMPILED-FUNCTION
     (COMPILED-FUNCTION-ARGS-INFO (COMPILED-FUNCTION-CCA FUNCTION)))
    (:LEXICAL-CLOSURE
      #+3600
     (LET* ((FCN (LEXICAL-CLOSURE-FUNCTION FUNCTION))
	    (INFO (ARGS-INFO FCN)))
       ;; Discount the extra environment argument iff compiled
       (WHEN (TYPEP FCN ':COMPILED-FUNCTION)
	 (SETF (LDB %%ARG-DESC-MIN-ARGS INFO) (MAX (1- (LDB %%ARG-DESC-MIN-ARGS INFO)) 0))
	 (SETF (LDB %%ARG-DESC-MAX-ARGS INFO) (MAX (1- (LDB %%ARG-DESC-MAX-ARGS INFO)) 0)))
       INFO)
     #+IMACH
     (LET ((FCN (LEXICAL-CLOSURE-FUNCTION FUNCTION)))
       (IF (TYPEP FCN ':COMPILED-FUNCTION)
	   (LET ((ENTRY (%P-POINTER FCN))
		 (SUBTRACT 3))			;ENVIRONMENT and normal +2 bias
	     (WHEN (AND (= (%LOGLDB %%ENTRY-INSTRUCTION-MIN ENTRY) 3)
			(= (%LOGLDB %%ENTRY-INSTRUCTION-MAX ENTRY) 3)
			;%%ENTRY-INSTRUCTION-REST-NOT-ACCEPTED
			(NOT (LDB-TEST (BYTE 1. 10.) ENTRY)))
	       ;; On Ivory, a call to a lexical closure whose function is a flavors
	       ;; function needs to shuffle the stack to get SELF-MAPPING-TABLE in
	       ;; FP|2 and SELF in FP|3.  This is accomplished with a helper
	       ;; function at the beginning of the CCA.  The helper function accepts
	       ;; one required argument (the environment) and a rest argument.  The
	       ;; helper function applies (by doing a direct call) the real code
	       ;; (which is in the same CCA) to SELF-MAPPING-TABLE (accessed from the
	       ;; environment), SELF (also accessed from the environment), the
	       ;; environment, and the rest argument.  %ARGS-INFO should return the
	       ;; information for the real code, not for the helper code.  Any entry
	       ;; instruction for compiled code associated with a lexical closure
	       ;; which accepts 1 required argument and a rest argument is suspect.
	       ;; If the first instruction after the entry vector is a direct call to
	       ;; code in the same CCA but not to the entry vector, we assume that we
	       ;; are dealing with one of these stack shuffling helper functions, and
	       ;; return the information for the real function instead.
	       (LET ((E+2 (%MEMORY-READ (%POINTER-PLUS FCN 2) :CYCLE-TYPE %MEMORY-SCAVENGE)))
		 (WHEN (AND (TYPE-MEMBER E+2 DTP-CALL-COMPILED-EVEN
					 DTP-CALL-COMPILED-EVEN-PREFETCH)
			    (< 1		;Not a linked recursive call
			       (%POINTER-DIFFERENCE E+2 FCN)
			       (- (CCA-TOTAL-SIZE (COMPILED-FUNCTION-CCA FCN))
				  (DEFSTORAGE-SIZE COMPILED-FUNCTION))))
		   (INCF SUBTRACT 2)		;SELF and SELF-MAPPING-TABLE
		   (SETQ ENTRY (%P-POINTER E+2)))))
	     (%LOGDPB (MAX (- (%LOGLDB %%ENTRY-INSTRUCTION-MAX ENTRY) SUBTRACT) 0)
		      %%ARG-DESC-MAX-ARGS
		      (%LOGDPB (MAX (- (%LOGLDB %%ENTRY-INSTRUCTION-MIN ENTRY) SUBTRACT) 0)
			       %%ARG-DESC-MIN-ARGS
			       (%LOGDPB (- 1 (%LOGLDB
					       %%ENTRY-INSTRUCTION-REST-NOT-ACCEPTED
					       ENTRY))
					%%ARG-DESC-REST-ARG
					0))))
	   (ARGS-INFO FCN))))
    (:FUNCALLABLE-INSTANCE
      (ARGS-INFO-FROM-LAMBDA-LIST
	(CLOS-INTERNALS:ARGLIST-OBJECT FUNCTION)))
    (:CLOSURE
     (%ARGS-INFO (CAR (%MAKE-POINTER DTP-LIST FUNCTION))))
    (:ARRAY
     (* (ARRAY-#-DIMS FUNCTION) (DPB 1 %%ARG-DESC-MAX-ARGS (DPB 1 %%ARG-DESC-MIN-ARGS 0))))
    (:INSTANCE
     (DPB -1 %%ARG-DESC-MAX-ARGS (DPB 1 %%ARG-DESC-MIN-ARGS 0)))
    (:GENERIC-FUNCTION
     (EXPAND-GENERIC-FUNCTION-DEBUGGING-INFO FUNCTION)
     (IF (FLAVOR::GENERIC-FUNCTION-EXPLICIT FUNCTION)
	 (ARGS-INFO-FROM-LAMBDA-LIST (GENERIC-FUNCTION-ARGLIST FUNCTION))
	 (DPB -1 %%ARG-DESC-MAX-ARGS (DPB 1 %%ARG-DESC-MIN-ARGS 0))))
    (OTHERWISE
     (DPB 1 %%ARG-DESC-INTERPRETED
	  (DPB -1 %%ARG-DESC-MAX-ARGS (DPB 0 %%ARG-DESC-MIN-ARGS 0))))))

(DEFUN ARGS-INFO (FCN)
  (DECLARE LT:(SIDE-EFFECTS READER))
  ;; First, convert FCN from a function-spec to a function
  (FLET ((ARGS-INFO-FROM-LAMBDA (LAMBDA)
	   (SELECTQ (FIRST LAMBDA)
	     ((DIGESTED-LAMBDA)
	      (FIFTH LAMBDA))
	     (OTHERWISE
	      (ARGS-INFO-FROM-LAMBDA-LIST
		(FIRST (INTERPRETED-LAMBDA-LAMBDA-LIST-AND-BODY
			 (LAMBDA-MACRO-EXPAND LAMBDA NIL))))))))
    (LOOP DO
      (COND ((SYMBOLP FCN)
	     (SETF FCN (FDEFINITION FCN)))
	    ((INTERPRETED-FUNCTION-P FCN)
	     (RETURN (ARGS-INFO-FROM-LAMBDA (INTERPRETED-FUNCTION-LAMBDA-EXPRESSION FCN))))
	    ((ATOM FCN)
	     (RETURN (%ARGS-INFO FCN)))
	    ((EQ (FIRST FCN) 'SPECIAL)
	     (RETURN (DPB 1 %%ARG-DESC-QUOTED (DPB 1 %%ARG-DESC-REST-ARG 0))))
	    ((INTERPRETED-LAMBDA-P (SETF FCN (LAMBDA-MACRO-EXPAND FCN)))
	     (RETURN (ARGS-INFO-FROM-LAMBDA FCN)))
	    (T (SETF FCN (FDEFINITION FCN)))))))

(DEFUN ARGS-INFO-FROM-LAMBDA-LIST (LL &AUX (FLAGS 0) MIN (N 0))
  (DO L LL (CDR L) (NULL L)
    (SELECTQ (CAR L)
      (&QUOTE (SETQ FLAGS (DPB 1 %%ARG-DESC-QUOTED FLAGS)))
      (&OPTIONAL (SETQ MIN N))
      (&AUX (RETURN NIL))
      ((&REST &KEY) (RETURN (SETQ FLAGS (DPB 1 %%ARG-DESC-REST-ARG FLAGS))))
      (OTHERWISE					;A VARIABLE
       (OR (MEMQ (CAR L) LAMBDA-LIST-KEYWORDS)
	   (SETQ N (1+ N))))))
  (OR MIN (SETQ MIN N))
  (DPB 1 %%ARG-DESC-INTERPRETED
       (DPB N %%ARG-DESC-MAX-ARGS
	    (DPB MIN %%ARG-DESC-MIN-ARGS FLAGS))))

(DEFUN FUNCTION-MAX-NUMBER-OF-ARGS (FUNCTION &AUX (ARGS-INF (ARGS-INFO FUNCTION)))
  (IF (LDB-TEST %%ARG-DESC-REST-ARG ARGS-INF)
      #+3600 #o400				;Random
      #+IMACH #o100				;Just as random
      (LDB %%ARG-DESC-MAX-ARGS ARGS-INF)))

;;; Takes a functional object, and returns a Lisp object which is its "name".
(DEFUN FUNCTION-NAME (FUNCTION)
  (CL:TYPECASE FUNCTION
    (COMPILED-FUNCTION (COMPILED-FUNCTION-NAME-FOR-DEBUGGING FUNCTION))
    ((CL:SATISFIES INTERPRETED-FUNCTION-P)
     (MULTIPLE-VALUE-BIND (LAMBDA CLOSURE NAME)
	 (INTERPRETED-FUNCTION-LAMBDA-EXPRESSION FUNCTION)
       (DECLARE (IGNORE CLOSURE))
       (OR NAME (SI:UNDIGEST LAMBDA))))
    (CL:CONS
      (SELECTQ (CAR FUNCTION)
	((SPECIAL)				;I'm not sure if this clause can be reached
	 (FUNCTION-NAME (OR (THIRD FUNCTION) (SECOND FUNCTION))))
	(OTHERWISE
	 FUNCTION)))
    (SYS:DYNAMIC-CLOSURE (FUNCTION-NAME (CAR (%MAKE-POINTER DTP-LIST FUNCTION))))
    (SYS:LEXICAL-CLOSURE
      (FUNCTION-NAME (LEXICAL-CLOSURE-FUNCTION FUNCTION)))
    (CLOS-INTERNALS:FUNCALLABLE-INSTANCE (CLOS-INTERNALS:FUNCTION-NAME-OBJECT FUNCTION))
    (SYS:GENERIC-FUNCTION (GENERIC-FUNCTION-NAME FUNCTION))
    (SYS:STACK-GROUP (SG-NAME FUNCTION))
    (OTHERWISE FUNCTION)))

(DEFUN COMPILED-FUNCTION-NAME-FOR-DEBUGGING (FUNCTION)
  (LET* ((EXTRA-INFO (CCA-EXTRA-INFO (COMPILED-FUNCTION-CCA FUNCTION)))
	 (NAME (CAR EXTRA-INFO)))
    (IF (AND (CL:CONSP NAME) (EQ (FIRST NAME) ':INTERNAL)
	     (CDDDR NAME) (NOT (SYMBOLP (FOURTH NAME))) (ATOM (FOURTH NAME)))
	(EXPAND-EXTRA-INFO-NAME EXTRA-INFO)
	NAME)))

#+IMACH
(DEFUN %READ-INSTRUCTION-WORD (FUNCTION OFFSET)
  (LET ((WORD (%MEMORY-READ (%POINTER-PLUS FUNCTION OFFSET)
			    :CYCLE-TYPE %MEMORY-SCAVENGE
			    :SET-CDR-NEXT T)))
    ;; If the word is a locative-like, then convert it to a locative
    (IF (TYPE-MEMBER WORD
		     DTP-EXTERNAL-VALUE-CELL-POINTER
		     DTP-CALL-COMPILED-EVEN DTP-CALL-COMPILED-EVEN-PREFETCH
		     DTP-CALL-COMPILED-ODD DTP-CALL-COMPILED-ODD-PREFETCH
		     DTP-CALL-INDIRECT DTP-CALL-INDIRECT-PREFETCH
		     DTP-CALL-GENERIC DTP-CALL-GENERIC-PREFETCH)
	(%MAKE-POINTER DTP-LOCATIVE WORD)
	WORD)))

;;; Replace all calls to OLD with NEW within the compiled function FUNCTION
;;; Used by RENAME-WITHIN encapsulation
#+3600
(DEFUN RENAME-WITHIN-COMPILED-FUNCTION-REPLACE-FUNCTION (FUNCTION OLD NEW)
  (CHECK-ARG-TYPE FUNCTION :COMPILED-FUNCTION)
  (SETQ OLD (FOLLOW-CELL-FORWARDING (FUNCTION-CELL-LOCATION OLD) NIL))
  (SETQ NEW (FOLLOW-CELL-FORWARDING (FUNCTION-CELL-LOCATION NEW) NIL))
  (LOOP FOR I FROM 0 BELOW (%P-LDB %%ENTRY-INSTRUCTION-TABLE-SIZE FUNCTION)
	AS OBJECT = (%P-CONTENTS-OFFSET FUNCTION (- -1 I))
	WHEN (EQ OBJECT OLD)
	DO (%P-STORE-CONTENTS-OFFSET NEW FUNCTION (- -1 I))))

#+IMACH
(DEFUN RENAME-WITHIN-COMPILED-FUNCTION-REPLACE-FUNCTION (FUNCTION OLD NEW)
  (CHECK-ARG-TYPE FUNCTION :COMPILED-FUNCTION)
  (SETQ OLD (FOLLOW-CELL-FORWARDING (FUNCTION-CELL-LOCATION OLD) NIL))
  (SETQ NEW (FOLLOW-CELL-FORWARDING (FUNCTION-CELL-LOCATION NEW) NIL))
  (LOOP WITH HEADER = (%P-LDB-OFFSET %%Q-POINTER FUNCTION
				     (- (DEFSTORAGE-SIZE COMPILED-FUNCTION)))
		      FOR I FROM 0 BELOW (- (LDB CCA-TOTAL-SIZE HEADER)
					    (LDB CCA-SUFFIX-SIZE HEADER)
					    (DEFSTORAGE-SIZE COMPILED-FUNCTION))
	DOING
    (LET* ((POINTER (%MAKE-POINTER-OFFSET DTP-LOCATIVE FUNCTION I))
	   (TYPE (%P-DATA-TYPE POINTER))
	   (OBJECT
	     (SELECT TYPE
	       ((DTP-CALL-COMPILED-EVEN DTP-CALL-COMPILED-ODD
		 DTP-CALL-COMPILED-EVEN-PREFETCH DTP-CALL-COMPILED-ODD-PREFETCH)
		;; We point at a pointer into the function.  We should be
		;; more clever here in the future, but for now I'm just
		;; going to do it the easy way.
		(%FIND-STRUCTURE-HEADER (%P-CONTENTS-AS-LOCATIVE POINTER)))
	       ((DTP-CALL-INDIRECT DTP-CALL-GENERIC
		 DTP-CALL-INDIRECT-PREFETCH DTP-CALL-GENERIC-PREFETCH)
		;; We point at a pointer to the function, so follow the
		;; two pointers and return what is there.
		(LOCATION-CONTENTS (%P-CONTENTS-AS-LOCATIVE POINTER)))
	       (OTHERWISE
		;; Otherwise we have a pointer to the function itself
		;; (for example, pushing something for a START-CALL). 
		;; Just return what is there.
		(LOCATION-CONTENTS POINTER))))
	   (LOCATION))
      (WHEN (EQ OBJECT OLD)
	(SELECT TYPE
	  ((DTP-CALL-COMPILED-EVEN DTP-CALL-COMPILED-EVEN-PREFETCH
	    DTP-CALL-COMPILED-ODD DTP-CALL-COMPILED-ODD-PREFETCH)
	   ;; We're going to need to make a location if we haven't
	   ;; already
	   (UNLESS LOCATION
	     (SETQ LOCATION (LIST NEW)))
	   ;; Change to an indirect (prefetch) call pointing at the cell
	   ;; we made
	   (%P-STORE-CONTENTS
	     POINTER
	     (SELECT TYPE
	       ((DTP-CALL-COMPILED-EVEN DTP-CALL-COMPILED-ODD)
		(%MAKE-POINTER DTP-CALL-INDIRECT LOCATION))
	       (OTHERWISE (%MAKE-POINTER
			    DTP-CALL-INDIRECT-PREFETCH LOCATION)))))
	  ((DTP-CALL-INDIRECT DTP-CALL-INDIRECT-PREFETCH)
	   ;; Replace the contents of the cell which is pointed to
	   (%P-STORE-CONTENTS (%P-CONTENTS-AS-LOCATIVE POINTER) NEW))
	  ((DTP-CALL-GENERIC DTP-CALL-GENERIC-PREFETCH)
	   (%P-STORE-DATA-TYPE POINTER
	    (if (= type DTP-CALL-GENERIC) DTP-CALL-INDIRECT DTP-CALL-INDIRECT-PREFETCH))
	   (%P-STORE-CONTENTS (%P-CONTENTS-AS-LOCATIVE POINTER) NEW))
	  (OTHERWISE
	   ;; Just a constant (as in START-CALL) so just change it to
	   ;; the new value.
	   (%P-STORE-CONTENTS POINTER NEW)))))))	


;;; --- Where should this go?  It is needed by map-over-compiled-function-callees.
(defun map-over-leaves-of-list (list funarg)
  (declare (sys:downward-funarg funarg))
  ;; --- Shouldn't be bounded like this!  This is rather quick and dirty
  ;; to avoid complete hair in circularity detection.
  (labels ((frob (list cars cdrs)
	     (loop repeat cdrs for l on list do
	       (cond ((null l) (return nil))
		     ((atom l) (return (funcall funarg l)))
		     (t (let ((car (car l)))
			  (cond ((null car))
				((listp car)
				 (when (plusp cars)
				   (frob car (1- cars) cdrs)))
				(t (funcall funarg car)))))))))
    (frob list 10. 580.))			;--- good numbers for now???
  ;; for effect, don't return gubbish
  nil)

(defun map-over-compiled-function-callees
       (compiled-function funarg &rest options
	&key external-references debugging-info instructions map-over-internal-functions-too)
  (declare (sys:downward-funarg funarg))
  "funarg gets called with three arguments: The caller, the callee, and
   how called.  The caller is typically the top level function here, but
   may be an internal function.  The callee is the object that is used.
   How called is a keyword such as :function, :variable, :constant,
   :macro, etc."
  ;; There are other various hooks that are here for optimizations of
  ;; who-calls.  Instructions can be T to map over microcode functions.
  ;; It can be a function which gets the bare instruction and the funarg
  ;; and figures out what to do.  who-calls supplies one that does a
  ;; very fast filter using the opcode.  external-references currently
  ;; only does what who-calls wants, but could be made to only do
  ;; constants, symbols, bignums, top-level lists, etc.
  (check-arg-type compiled-function :compiled-function)
  (let* ((caller compiled-function)
	 (cca (compiled-function-cca caller)))
    (when external-references
      (labels ((process-external-reference (object index)
		(typecase object
		 (:locative
		   (multiple-value-bind (symbol how)
		       (compiler:disassemble-decode-locative object cca index)
		     (selectq how
		       ((:function :variable)
			(funcall funarg caller symbol how)))))
		 (:symbol
		   (funcall funarg caller object ':constant))
		 (:instance
		   (when (operation-handled-p object 'dbg:map-over-instance-callees)
		     (lexpr-funcall #'dbg:map-over-instance-callees
				    object caller funarg options)))
		 (:compiled-function
		   (let ((name (compiled-function-name object)))
		     (if (and (listp name)
			      (eq (car name) ':internal)
			      (equal (cadr name) (compiled-function-name caller)))
			 (when map-over-internal-functions-too
			   (lexpr-funcall #'map-over-compiled-function-callees
					  object funarg options))
			 (funcall funarg caller name :function))))
		 (:list
		   (map-over-leaves-of-list
		     object (lambda (leaf)
			      (process-external-reference leaf nil))))
		 (:generic-function
		   (funcall funarg caller
			    (sys:generic-function-name object) :generic-function))
		 (resource
		   (funcall funarg caller (resource-name object) ':resource))
		 )))
	#+3600
	(dotimes (index (compiled-function-table-size cca))
	  (process-external-reference (cca-object cca index) index))
	#+IMACH
	(dotimes (index (- (cca-total-size cca)
			   (cca-suffix-size cca)
			   (defstorage-size compiled-function)))
	  (process-external-reference (%read-instruction-word compiled-function index) index))
	))
    (when instructions
      #+3600
      (let ((dispatch (cond ((eq instructions 't) :normal)
			    ((functionp instructions) :filter)
			    (t (ferror "Instructions argument, ~S, was not T or a function."
				       instructions)))))
	;; --- Think about what to do for the I machine here
	(loop for i upfrom 1 below (cca-n-instructions cca) do	;don't do entry instruction
	  (let ((inst (cca-instruction cca i)))
	    (selectq dispatch
	      (:filter
	       (funcall instructions cca inst i
			(lambda (lisp-function-name)
			  (declare (sys:downward-function))
			  (funcall funarg caller lisp-function-name
				   :microcoded-function))))
	      (:normal
	       (let ((lisp-function-name
		       (aref l-lisp-compiler:*instruction-function-name*
			     (l-lisp-compiler:get-universal-opcode (cca-instruction cca i)))))
		 (when lisp-function-name
		   (funcall funarg caller lisp-function-name :microcoded-function))))))))
      #+imach
      (let ((dispatch (cond ((eq instructions 't) :normal)
			    ((functionp instructions) :filter)
			    (t (ferror "Instructions argument, ~S, was not T or a function."
				       instructions))))
	    (i 2))
	(loop named instructions doing
	  (let* ((inst
		   (%memory-read
		     (%pointer-plus cca (+ (ldb (byte 31. 1.) i)
					   (defstorage-size compiled-function)))
		     :cycle-type %memory-scavenge :set-cdr-next nil))
		 (type (%data-type inst))
		 (increment
		   (select (ldb %%q-cdr-code-within-tag (%tag inst))
		     (sequencing-pc+1 1)
		     (sequencing-fence nil)
		     (sequencing-pc-1 -1)
		     (sequencing-pc-even+2-odd+3 (+ 2 (ldb (byte 1 0) i))))))
	    (cond ((null increment)
		   (return-from instructions))
		  (( type dtp-packed-instruction-60)
		   (let* ((inst-bits
			    (if (evenp i)
				(%set-tag inst dtp-fixnum)
				(dpb type %%odd-instruction-tag-component
				     (ldb %%q-odd-instruction-within-pointer
					  (%set-tag inst dtp-fixnum)))))
			  (opcode (ldb %%packed-instruction-opcode inst-bits)))
		     (selectq dispatch
		       (:filter
			(funcall instructions cca inst i
				 (lambda (lisp-function-name)
				   (declare (sys:downward-function))
				   (funcall funarg caller lisp-function-name
					    :microcoded-function))))
		       (:normal
			(let ((lisp-function-name
				(aref i-lisp-compiler:*instruction-name* opcode)))
			  (when lisp-function-name
			    (funcall funarg caller lisp-function-name
				     :microcoded-function))))))))
	    (incf i increment)))))
    (when debugging-info
      (let ((info (let ((*store-back-expanded-extra-info* nil))
		    (compiled-function-debugging-info caller))))
	#| Don't do :mapping-table-instructions since that will enter 
	   a call for each method.  That information is easier gotten
	   via other means |
	(dolist (mapping-table-info (cdr (assq ':mapping-table-instructions info)))
	  (funcall funarg caller (car mapping-table-info) ':flavor))
	||#	
	(dolist (instance-variable-info (cdr (assq ':instance-variable-instructions info)))
	  (funcall funarg caller (car instance-variable-info) ':instance-variable))
	;; Look for optimized CLOS:SLOT-VALUE
	(let ((family (or (caadr (assq 'clos-internals:mapping-table-family info))
			  (let ((method (function-name caller)))
			    (and (typep method :instance)	;speed bum & cold load hack
				 (cl:locally
				   (declare (cl:notinline cl:typep))
				   (cl:typep method 'clos:standard-method))
				 (clos-internals::method-mapping-table-family method))))))
	  (when family
	    (clos-internals::map-over-mapping-table-instructions caller family funarg)))
	(dolist (macro-name (cadr (assq ':macros-expanded info)))
	  (funcall funarg caller macro-name ':macro))
	(dolist (constant (cadr (assq ':constants-open-coded info)))
	  (funcall funarg caller (car constant) :defined-constant))))))



;;; Compiled code addressors, which are locatives to the header of a compiled function.

;;; Make a compiled code object, returning both the cca and the compiled-function
#+3600
(DEFUN MAKE-COMPILED-CODE (N-OBJECTS N-INSTRUCTIONS &OPTIONAL (AREA COMPILED-FUNCTION-AREA))
  (DECLARE (VALUES CCA FUNCTION))
  (LET* ((N-INSTW (CEILING N-INSTRUCTIONS 2))
	 (TOTAL-SIZE (+ (DEFSTORAGE-SIZE COMPILED-FUNCTION) N-OBJECTS N-INSTW)))
    (WHEN ( N-OBJECTS (DEFSYSBYTE-LIMIT-VALUE COMPILED-FUNCTION-TABLE-SIZE))
      (FERROR "More than maximum number of objects."))
    (WHEN ( TOTAL-SIZE (DEFSYSBYTE-LIMIT-VALUE COMPILED-FUNCTION-TOTAL-SIZE))
      (FERROR "More than maximum number of instructions."))
    (LET* ((CCA (%MAKE-STRUCTURE DTP-LOCATIVE DTP-HEADER-I %HEADER-TYPE-COMPILED-FUNCTION
			(DPB TOTAL-SIZE
			     (DEFSTORAGE-FIELD-BYTE COMPILED-FUNCTION-TOTAL-SIZE)
			     (DPB N-OBJECTS
				  (DEFSTORAGE-FIELD-BYTE COMPILED-FUNCTION-TABLE-SIZE)
				  0))
			AREA (+ (DEFSTORAGE-SIZE COMPILED-FUNCTION) N-OBJECTS N-INSTW)))
	   (FUNCTION (%MAKE-POINTER-OFFSET DTP-COMPILED-FUNCTION CCA
			(+ (DEFSTORAGE-SIZE COMPILED-FUNCTION) N-OBJECTS))))
      (%BLOCK-STORE-CDR-AND-CONTENTS (%MAKE-POINTER-OFFSET DTP-LOCATIVE CCA 1)
				     (+ (DEFSTORAGE-SIZE COMPILED-FUNCTION) N-OBJECTS -1)
				     CDR-NIL NIL 0)
      (%BLOCK-STORE-CDR-AND-CONTENTS FUNCTION N-INSTW CDR-NIL 0 0)
      (%P-STORE-CONTENTS-OFFSET 0 CCA 1)	;ARGS-INFO
      (%P-DPB N-OBJECTS %%ENTRY-INSTRUCTION-TABLE-SIZE FUNCTION)
      (VALUES CCA FUNCTION))))

#+IMACH
(DEFUN MAKE-COMPILED-CODE (TOTAL-SIZE SUFFIX-SIZE &OPTIONAL (AREA COMPILED-FUNCTION-AREA))
  (DECLARE (VALUES CCA FUNCTION))
  (WHEN ( SUFFIX-SIZE (DEFSYSBYTE-LIMIT-VALUE CCA-SUFFIX-SIZE))
    (FERROR "More than the maximum suffix size"))
  (WHEN ( TOTAL-SIZE (DEFSYSBYTE-LIMIT-VALUE CCA-TOTAL-SIZE))
    (FERROR "More than maximum number of instructions."))
  (LET* ((CCA (%MAKE-STRUCTURE DTP-LOCATIVE DTP-HEADER-I %HEADER-TYPE-COMPILED-FUNCTION
			       (%LOGDPBS TOTAL-SIZE CCA-TOTAL-SIZE
					 SUFFIX-SIZE CCA-SUFFIX-SIZE
					 0)
			       AREA TOTAL-SIZE))
	 (FUNCTION (%MAKE-POINTER-OFFSET DTP-COMPILED-FUNCTION CCA
					 (DEFSTORAGE-SIZE COMPILED-FUNCTION))))
    (%BLOCK-WRITE 1 FUNCTION)
    (%BLOCK-STORE-CDR-AND-CONTENTS
      FUNCTION (- TOTAL-SIZE (DEFSTORAGE-SIZE COMPILED-FUNCTION)) SEQUENCING-FENCE NIL 0)
    (VALUES CCA FUNCTION)))
    
#+3600(PROGN

(DEFUN CCA-COMPILED-CODE-OBJECT (CCA)
  (%MAKE-POINTER-OFFSET DTP-COMPILED-FUNCTION CCA
			(+ (DEFSTORAGE-SIZE COMPILED-FUNCTION)
			   (COMPILED-FUNCTION-TABLE-SIZE CCA))))

(DEFUN CCA-OBJECT (CCA N)
  (%P-CONTENTS-OFFSET CCA (+ (DEFSTORAGE-SIZE COMPILED-FUNCTION)
			     (- (COMPILED-FUNCTION-TABLE-SIZE CCA) N 1))))

(SCL:DEFLOCF CCA-OBJECT CCA-OBJECT-LOCATION)

;; This is for LOCF
(DEFUN CCA-OBJECT-LOCATION (CCA N)
  (%MAKE-POINTER-OFFSET DTP-LOCATIVE CCA
			(+ (DEFSTORAGE-SIZE COMPILED-FUNCTION)
			   (- (COMPILED-FUNCTION-TABLE-SIZE CCA) N 1))))

(DEFUN CCA-SET-OBJECT (CCA N VAL)
  (%P-STORE-CONTENTS-OFFSET VAL CCA (+ (DEFSTORAGE-SIZE COMPILED-FUNCTION)
				       (- (COMPILED-FUNCTION-TABLE-SIZE CCA) N 1))))
);End #+3600


#+IMACH
(DEFSUBST CCA-COMPILED-CODE-OBJECT (CCA)
  (%MAKE-POINTER-OFFSET DTP-COMPILED-FUNCTION CCA (DEFSTORAGE-SIZE COMPILED-FUNCTION)))

#+IMACH
(DEFUN CCA-OBJECT (CCA N)
  (%P-CONTENTS-OFFSET CCA (+ (DEFSTORAGE-SIZE COMPILED-FUNCTION) N)))

#+IMACH
(DEFUN PARSED-FUNCTION-INSTRUCTION (FUNCTION N)
  (let ((WORD (%MEMORY-READ (%POINTER-PLUS FUNCTION (FLOOR N 2))
			    :CYCLE-TYPE %MEMORY-SCAVENGE)))
    (VALUES (%DATA-TYPE WORD)
	    (IF (%POINTERP WORD)
		(%SET-TAG WORD DTP-LOCATIVE)
		WORD)
	    (EVENP N))))

#+3600
(DEFUN CCA-N-INSTRUCTIONS (CCA)
  (LET ((N (* (- (COMPILED-FUNCTION-TOTAL-SIZE CCA)
		 (DEFSTORAGE-SIZE COMPILED-FUNCTION)
		 (COMPILED-FUNCTION-TABLE-SIZE CCA))
	      2)))
    (IF (ZEROP (CCA-INSTRUCTION CCA (1- N)))
	(1- N)
	N)))

#+IMACH
(DEFUN CCA-N-INSTRUCTIONS (CCA)
  (* 2 (- (CCA-TOTAL-SIZE CCA)
	  (CCA-SUFFIX-SIZE CCA)
	  (DEFSTORAGE-SIZE COMPILED-FUNCTION))))
		   

(DEFUN CCA-INSTRUCTION (CCA N &OPTIONAL (HACK-BREAKPOINTS T))
  (COMPILED-FUNCTION-INSTRUCTION (CCA-COMPILED-CODE-OBJECT CCA) N HACK-BREAKPOINTS))

(DEFUN COMPILED-FUNCTION-INSTRUCTION (FUNCTION N &OPTIONAL (HACK-BREAKPOINTS T))
  (LET ((BREAK
	  (IF (AND HACK-BREAKPOINTS
		   (VARIABLE-BOUNDP #'DBG:BREAKPOINTS-IN-FUNCTION))
	      (CAR (DBG:BREAKPOINTS-IN-FUNCTION FUNCTION N))
	      NIL)))
    (IF BREAK
	(VALUES (DBG:BPT-INSTRUCTION BREAK) T)	;second value T if breakpoint here
	#+3600
	(LET ((PTR (%MAKE-POINTER-OFFSET DTP-LOCATIVE FUNCTION (%FIXNUM-FLOOR N 2))))
	  (IF (EVENP N)
	      (DPB (%P-LDB %%Q-LOW-INSTR-HIGH-BIT PTR) (BYTE 01 20)
		   (%P-LDB %%Q-LOW-INSTR PTR))
	      (DPB (%P-LDB %%Q-HIGH-INSTR-HIGH-BIT PTR) (BYTE 01 20)
		   (%P-LDB %%Q-HIGH-INSTR PTR))))
	#+IMACH
	(LET* ((WORD (%MEMORY-READ (%POINTER-PLUS FUNCTION (%FIXNUM-FLOOR N 2))
				   :CYCLE-TYPE %MEMORY-SCAVENGE :SET-CDR-NEXT T))
	       (TYPE (%DATA-TYPE WORD)))
	  (IF ( TYPE DTP-PACKED-INSTRUCTION-60)
	      ;; Packed instruction
	      (IF (EVENP N)
		  ;; All bits in the pointer field
		  (LDB %%Q-EVEN-INSTRUCTION (%SET-TAG WORD DTP-FIXNUM))
		  ;; Four bits in the type, fourteen in the pointer
		  (DPB TYPE %%ODD-INSTRUCTION-TAG-COMPONENT
		       (LDB %%Q-ODD-INSTRUCTION-WITHIN-POINTER
			    (%SET-TAG WORD DTP-FIXNUM))))
	      ;; Even words need to be aligned.
	      (IF (EVENP N)
		  WORD
		  (FERROR "Instruction ~a is a full word, odd half being accessed" n)))))))

(DEFUN CCA-SET-INSTRUCTION (CCA N INSTRUCTION)
  (COMPILED-FUNCTION-SET-INSTRUCTION (CCA-COMPILED-CODE-OBJECT CCA) N INSTRUCTION))

#+3600
(DEFUN COMPILED-FUNCTION-SET-INSTRUCTION (FUNCTION N INSTRUCTION)
  (LET ((PTR (%MAKE-POINTER-OFFSET DTP-LOCATIVE FUNCTION (// N 2))))
    (COND ((EVENP N)
	   (%P-DPB (LDB (BYTE 01 20) INSTRUCTION) %%Q-LOW-INSTR-HIGH-BIT PTR)
	   (%P-DPB INSTRUCTION %%Q-LOW-INSTR PTR))
	  (T
	   (%P-DPB (LDB (BYTE 01 20) INSTRUCTION) %%Q-HIGH-INSTR-HIGH-BIT PTR)
	   (%P-DPB INSTRUCTION %%Q-HIGH-INSTR PTR))))
  ())

#+IMACH
(DEFUN COMPILED-FUNCTION-SET-TO-PACKED-INSTRUCTION (FUNCTION N INSTRUCTION)
  (LET* ((PTR (%MAKE-POINTER-OFFSET DTP-LOCATIVE FUNCTION (// N 2)))
	 (NEW-INSTRUCTION (%MEMORY-READ PTR :CYCLE-TYPE %MEMORY-SCAVENGE :SET-CDR-NEXT NIL))
	 (TAG-FIELD 0))
    (IF (ODDP N)
	(FERROR "CAN'T STORE A FULL WORD INSTRUCTION IN AN ODD PC"))
    (SETF (LDB %%Q-CDR-CODE-WITHIN-TAG TAG-FIELD)
	  (LDB %%Q-CDR-CODE-WITHIN-TAG (%TAG NEW-INSTRUCTION)))
    (SETF (LDB %%Q-TYPE-WITHIN-TAG TAG-FIELD) DTP-PACKED-INSTRUCTION-60)
    (SETF NEW-INSTRUCTION (ILC:%SET-TAG NEW-INSTRUCTION DTP-FIXNUM))
    (SETF (LDB %%PACKED-INSTRUCTION-OPCODE NEW-INSTRUCTION)
	  (LDB %%PACKED-INSTRUCTION-OPCODE INSTRUCTION))
    (SETF NEW-INSTRUCTION (ILC:%SET-TAG NEW-INSTRUCTION TAG-FIELD))
    (%MEMORY-WRITE PTR NEW-INSTRUCTION)
    NEW-INSTRUCTION))

#+IMACH
(DEFUN COMPILED-FUNCTION-SET-INSTRUCTION (FUNCTION N INSTRUCTION &OPTIONAL FULL-P)
  (LET ((PTR (%MAKE-POINTER-OFFSET DTP-LOCATIVE FUNCTION (// N 2))))
    (IF FULL-P
	(IF (ODDP N)
	    (FERROR "Can't store a full word instruction in an odd PC")
	    (%P-STORE-CONTENTS PTR INSTRUCTION))
	(IF (EVENP N)
	    (%P-DPB INSTRUCTION %%Q-EVEN-INSTRUCTION PTR)
	    (%P-DPB INSTRUCTION %%Q-ODD-INSTRUCTION PTR))))
  INSTRUCTION)

;;; Given a DTP-COMPILED-FUNCTION, make a cca
#+3600
(DEFUN COMPILED-FUNCTION-CCA (FUNCTION)
  (%MAKE-POINTER-OFFSET DTP-LOCATIVE FUNCTION
			(- (+ (DEFSTORAGE-SIZE COMPILED-FUNCTION)
			      (LDB %%ENTRY-INSTRUCTION-TABLE-SIZE
				   (%P-LDB (BYTE 20 00) FUNCTION))))))

#+IMACH
(DEFSUBST COMPILED-FUNCTION-CCA (FUNCTION)
  (%MAKE-POINTER-OFFSET DTP-LOCATIVE FUNCTION (- (DEFSTORAGE-SIZE COMPILED-FUNCTION))))

#+IMACH
(DEFSUBST CCA-CURRENT-DEFINITION-P (CCA)
  (%P-LDB %%ENTRY-INSTRUCTION-CURRENT-DEFINITION-P
	  (%POINTER-PLUS CCA (DEFSTORAGE-SIZE COMPILED-FUNCTION))))

#+IMACH
(DEFSUBST CCA-LANGUAGE-INDEX (CCA)
  (%P-LDB %%ENTRY-INSTRUCTION-LANGUAGE-INDEX
	  (%POINTER-PLUS CCA (DEFSTORAGE-SIZE COMPILED-FUNCTION))))

#+3600
(DEFSUBST CCA-LANGUAGE-INDEX (CCA)
  (COMPILED-FUNCTION-LANGUAGE-INDEX CCA))

(DEFUN COMPILED-FUNCTION-NAME (FUNCTION)
  (CAR (CCA-EXTRA-INFO (COMPILED-FUNCTION-CCA FUNCTION))))

(DEFUN CCA-EXTRA-INFO-FOR-DEBUGGING (CCA)
  (LET ((EXTRA-INFO (CCA-EXTRA-INFO CCA)))
    (WHEN (AND (CDR EXTRA-INFO) (ATOM (SECOND EXTRA-INFO)))
      (SETQ EXTRA-INFO (EXPAND-EXTRA-INFO (%FIND-STRUCTURE-HEADER CCA) EXTRA-INFO))
      (CL:ECASE *STORE-BACK-EXPANDED-EXTRA-INFO*
	((NIL) )
	((T)
	 ;; Don't copy entries listed in *DEBUG-INFO-TYPES-NOT-TO-COPY*.
	 ;; As in SI:STANDARDIZE-EXTRA-INFO -- ACW 9/28/92 14:39:48
	 (LET ((UNCOPIED (LOOP FOR I FROM 1 FOR LIST ON (CDR EXTRA-INFO)
			       WHEN (MEMQ (CAAR LIST) *DEBUG-INFO-TYPES-NOT-TO-COPY*)
			       COLLECT (LIST (CAR LIST) I)
			       AND DO (SETF (CAR LIST) NIL))))
	   (SETQ EXTRA-INFO (COPY-INTO-AREA-IF-NOT-THERE EXTRA-INFO DEBUG-INFO-AREA))
	   (LOOP FOR (ENTRY INDEX) IN UNCOPIED DO
		 (SETF (NTH INDEX EXTRA-INFO) ENTRY)))
	 (SETF (CCA-EXTRA-INFO CCA) EXTRA-INFO))
	((:ERROR)
	 (UNLESS (PLUSP DBG:*DEBUGGER-LEVEL*)
	   ;; Not FSIGNAL, make sure it gets to the user.
	   (CL:BREAK "Trying to expand extra info for ~S" (FIRST EXTRA-INFO))))))
    EXTRA-INFO))

(DEFUN COMPILED-FUNCTION-DEBUGGING-INFO (FUNCTION)
  (CDR (CCA-EXTRA-INFO-FOR-DEBUGGING (SYS:COMPILED-FUNCTION-CCA FUNCTION))))

#+3600
(DEFUN PC-INSTRUCTION (PC)
  (SELECT (%DATA-TYPE PC)
    (DTP-EVEN-PC (DPB (%P-LDB %%Q-LOW-INSTR-HIGH-BIT PC) (BYTE 01 20)
		      (%P-LDB %%Q-LOW-INSTR PC)))
    (DTP-ODD-PC (DPB (%P-LDB %%Q-HIGH-INSTR-HIGH-BIT PC) (BYTE 01 20)
		     (%P-LDB %%Q-HIGH-INSTR PC)))))

#+IMACH
;; Returns NIL if the PC points to a full-word instruction.
(DEFUN PC-INSTRUCTION (PC)
  (DBG:PACKED-INSTRUCTION-FROM-PC PC))

;;; Given a PC that should be inside FUNCTION, return it as an address within FUNCTION, or
;;; NIL if it wasn't in range.
(DEFUN FUNCTION-RELATIVE-PC (PC FUNCTION)
  (LET ((ADDR (+ (* (%POINTER-DIFFERENCE PC FUNCTION) 2)
		 (SELECT (%DATA-TYPE PC)
		   (DTP-EVEN-PC 0)
		   (DTP-ODD-PC 1)))))
    (AND ( 0 ADDR (CCA-N-INSTRUCTIONS (COMPILED-FUNCTION-CCA FUNCTION)))
	 ADDR)))

(DEFUN %MAKE-PC (FUNCTION OFFSET)
  (CL:CHECK-TYPE FUNCTION CL:COMPILED-FUNCTION)
  (CL:CHECK-TYPE OFFSET (CL:INTEGER 0 *))
  (COMPILER:%ERROR-UNLESS
    ( OFFSET (CCA-N-INSTRUCTIONS (COMPILED-FUNCTION-CCA FUNCTION)))
    (ERROR "Offset is past end of function."))
  (LET ((WORD (FLOOR OFFSET 2)))
    (IF (ODDP OFFSET)
	(%MAKE-POINTER-OFFSET DTP-ODD-PC FUNCTION WORD)
        (%MAKE-POINTER-OFFSET DTP-EVEN-PC FUNCTION WORD))))

(DEFUN %PC-PLUS (PC OFFSET)
  (CL:CHECK-TYPE OFFSET CL:INTEGER)
  (CL:ECASE (%DATA-TYPE PC)
    (#.DTP-EVEN-PC
      (IF (EVENP OFFSET)
	  (%MAKE-POINTER-OFFSET DTP-EVEN-PC PC (ASH OFFSET -1))
	  (%MAKE-POINTER-OFFSET DTP-ODD-PC PC (ASH OFFSET -1))))
    (#.DTP-ODD-PC
      (IF (EVENP OFFSET)
	  (%MAKE-POINTER-OFFSET DTP-ODD-PC PC (ASH OFFSET -1))
	  (%MAKE-POINTER-OFFSET DTP-EVEN-PC PC (1+ (ASH OFFSET -1)))))))

(DEFUN DECODE-PC (PC)
  (DECLARE (VALUES FUNCTION OFFSET))
  (DECLARE (CL:INLINE CL:COMPILED-FUNCTION-P))
  ;; this should only happen on rev2b and beyond.
  #+imach
  (COMPILER:%ERROR-WHEN (AND (SI:%POINTER- SYS:%TRAP-VECTOR-BASE PC)
			     (SI:%POINTER-< PC (SYS:%POINTER-PLUS SYS:%TRAP-VECTOR-BASE
								  SYS:%TRAP-VECTOR-LENGTH)))
    ;; Can't do find-structure header on this!
    (RETURN-FROM DECODE-PC
      (VALUES (SI:%MAKE-POINTER SI:DTP-LOCATIVE PC) 0)))
  (MULTIPLE-VALUE-BIND (FUNCTION LEADER SIZE)
      (%FIND-STRUCTURE-EXTENT PC)
    (LET ((PC-BASE (CL:ETYPECASE FUNCTION
		     (CL:COMPILED-FUNCTION
		       (%POINTER-DIFFERENCE FUNCTION LEADER))
		     (CL:ARRAY
		       (ARRAY-DATA-OFFSET FUNCTION))))
	  (OFFSET (%POINTER-DIFFERENCE PC LEADER)))
      (COMPILER:%ERROR-WHEN (OR (< OFFSET PC-BASE) (>= OFFSET SIZE))
        (ERROR "PC is not inside a function."))
      (VALUES FUNCTION
	      (+ (* 2 (- OFFSET PC-BASE))
		 (SELECT (%DATA-TYPE PC)
		   (DTP-ODD-PC 1)
		   (DTP-EVEN-PC 0)
		   (OTHERWISE (ERROR "Bad data type."))))))))

(DEFUN DISASSEMBLE-DECODE-PC (PC)
  (DECLARE (VALUES FUNCTION OFFSET TYPE))
  (DECLARE (CL:INLINE CL:COMPILED-FUNCTION-P))
  ;; this should only happen on rev2b and beyond.
  #+imach
  (COMPILER:%ERROR-WHEN (AND (SI:%POINTER- SYS:%TRAP-VECTOR-BASE PC)
			     (SI:%POINTER-< PC (SYS:%POINTER-PLUS SYS:%TRAP-VECTOR-BASE
								  SYS:%TRAP-VECTOR-LENGTH)))
    ;; Can't do find-structure header on this!
    (COND ((EQL PC (SI:%MAKE-POINTER SI:DTP-EVEN-PC
				     (+ SYS:%TRAP-VECTOR-BASE
					SYS:%GENERIC-DISPATCH-TRAP-VECTOR)))
	   (RETURN-FROM DISASSEMBLE-DECODE-PC
	     (VALUES 'SYS:%GENERIC-DISPATCH-TRAP-VECTOR 0 :TRAP-VECTOR)))
	  ((EQL PC (SI:%MAKE-POINTER SI:DTP-EVEN-PC
				     (+ SYS:%TRAP-VECTOR-BASE
					SYS:%MESSAGE-DISPATCH-TRAP-VECTOR)))
	   ;; Can't do find-structure header on this, either!
	   (RETURN-FROM DISASSEMBLE-DECODE-PC
	     (VALUES 'SYS:%MESSAGE-DISPATCH-TRAP-VECTOR 0 :TRAP-VECTOR)))
	  (T
	   (RETURN-FROM DISASSEMBLE-DECODE-PC
	     (VALUES 'SYS:%TRAP-VECTOR-BASE
		     (+ (* 2 (SYS:%POINTER-DIFFERENCE PC SYS:%TRAP-VECTOR-BASE))
			(SELECT (%DATA-TYPE PC)
			  (DTP-ODD-PC 1)
			  (DTP-EVEN-PC 0)
			  (OTHERWISE (ERROR "Bad data type."))))
		     :TRAP-VECTOR)))))
  (MULTIPLE-VALUE-BIND (FUNCTION LEADER SIZE)
      (%FIND-STRUCTURE-EXTENT PC)
    (multiple-value-bind (PC-BASE type)
	(CL:ETYPECASE FUNCTION
	  (CL:COMPILED-FUNCTION
	    (values (%POINTER-DIFFERENCE FUNCTION LEADER) :function))
	  (CL:ARRAY
	    (values
	      (ARRAY-DATA-OFFSET FUNCTION) #+3600 :escape-function #+imach :return-0-kludge)))
      (let ((OFFSET (%POINTER-DIFFERENCE PC LEADER)))
	(COMPILER:%ERROR-WHEN (OR (< OFFSET PC-BASE) (>= OFFSET SIZE))
          (ERROR "PC is not inside a function."))
	(VALUES FUNCTION
		(+ (* 2 (- OFFSET PC-BASE))
		   (SELECT (%DATA-TYPE PC)
		     (DTP-ODD-PC 1)
		     (DTP-EVEN-PC 0)
		     (OTHERWISE (ERROR "Bad data type."))))
		TYPE)))))


;;; Source locators hackery.  Note that the source locator arrays are one per function
;;; and the read correspondences are one per top-level function.

(DEFUN CCA-SOURCE-LOCATOR-ARRAY (CCA)
  (CDR (CCA-DEBUGGING-INFO-USER-ENTRY CCA 'COMPILER:SOURCE-LOCATORS)))

(DEFUN FUNCTION-SOURCE-LOCATORS (FUNCTION)
  (CDR (DEBUGGING-INFO-USER-ENTRY FUNCTION 'COMPILER:SOURCE-LOCATORS)))

(DEFUN FUNCTION-READ-CORRESPONDENCES (FUNCTION)
  (LOOP DOING
    (LET ((ELEM (DEBUGGING-INFO-USER-ENTRY FUNCTION ':READ-CORRESPONDENCES)))
      (WHEN ELEM
	(RETURN (CADR ELEM))))
    (LET ((NAME (FUNCTION-NAME FUNCTION)))
      (UNLESS (AND (LISTP NAME) (EQ (FIRST NAME) :INTERNAL))
	(RETURN NIL))
      (WHEN (AND (TYPEP FUNCTION :COMPILED-FUNCTION)
		 (NEQ FUNCTION (VALID-FUNCTION-DEFINITION NAME)))
	;; We have our hands on an obsolete internal compiled code object.
	;; No way of getting to the parent compiled code object.
	(RETURN NIL))
      (SETQ FUNCTION (SECOND NAME)))))

(DEFUN CCA-INSTRUCTION-SOURCE-LOCATOR (CCA PC)
  (WHEN PC
    (LET ((SOURCE-LOCATORS (CCA-SOURCE-LOCATOR-ARRAY CCA)))
      (AND SOURCE-LOCATORS
	   (MACROLET ((PC (PC1 PC2)
			#+3600 `( ,PC1 ,PC2)
			#+IMACH `( ,PC1 ,PC2)
			;; Don't need this hair because if the PC does not appear in
			;; "this interval", then it will appear in an outer one
			#+IGNORE `(LET* ((CDR-CODE
					  (%P-CDR-CODE
					    (%MAKE-POINTER-OFFSET
					      DTP-LOCATIVE
					      CCA
					      (+ (DEFSTORAGE-SIZE COMPILED-FUNCTION)
						 (ASH ,PC1 -1)))))
					(INCREMENT
					  (SELECT CDR-CODE
					    (SEQUENCING-PC+1 1)
					    (SEQUENCING-FENCE 0)	;illegal, be forgiving
					    (SEQUENCING-PC-1 -1)
					    (SEQUENCING-PC-EVEN+2-ODD+3
					     (IF (EVENP ,PC1) 2 3)))))
				   (OR (= ,PC1 ,PC2)
				       ( (+ ,PC1 INCREMENT) ,PC2)))))
	     (LOOP FOR LOCATOR BEING THE ARRAY-ELEMENTS OF SOURCE-LOCATORS
		   AS START-PC = (COMPILER:SOURCE-LOCATOR-START-PC LOCATOR)
		   AS PC-INTERVAL = (COMPILER:SOURCE-LOCATOR-PC-INTERVAL LOCATOR)
		   AS FORM = (COMPILER:SOURCE-LOCATOR-FORM LOCATOR)
		   WHEN (AND (PC START-PC PC)
			     (PC PC (+ START-PC PC-INTERVAL)))
		     RETURN FORM))))))

(DEFUN CCA-INSTRUCTION-SOURCE-LOCATOR-BP (CCA PC)
  (LET ((LOC (CCA-INSTRUCTION-SOURCE-LOCATOR CCA PC)))
    (WHEN LOC
      (COMPILER:FIND-FORM-IN-CORRESPONDENCES
	(CAR LOC) 
	(FUNCTION-READ-CORRESPONDENCES (%FIND-STRUCTURE-HEADER CCA))
	LOC))))

;;--- This can't really work properly, since the locators are built using
;;--- a bp-interval.  We can make a reasonable guess though...
(DEFUN FUNCTION-BP-PC (BP FUNCTION)
  (MULTIPLE-VALUE-BIND (SECTION CORRESPONDENCES)
      (FUNCTION-CORRESPONDENCE-INFO FUNCTION)
    (IGNORE SECTION)
    (WHEN CORRESPONDENCES
      (LET* ((LOCATORS (FUNCTION-SOURCE-LOCATORS FUNCTION))
	     (FORM (LOOP NAMED FOUND-FORM
			 FOR (SUBFORM . CORRS) IN CORRESPONDENCES
			 ;; Ensures that the code below doesn't try to match on
			 ;; a symbol which might not be unique.
			 WHEN (CL:CONSP SUBFORM)
			   DO
			     (LOOP FOR (START END) IN CORRS
				   DO (IGNORE END)
				      (WHEN (OR (ZWEI:BP-< START BP)
						(ZWEI:BP-= START BP))
					(RETURN-FROM FOUND-FORM SUBFORM)))))
	     (PC (LOOP NAMED FOUND-PC
		       FOR LOCATOR BEING THE ARRAY-ELEMENTS OF LOCATORS
		       AS START-PC = (COMPILER:SOURCE-LOCATOR-START-PC LOCATOR)
		       AS SAVED-FORM = (COMPILER:SOURCE-LOCATOR-FORM LOCATOR)
		       ;;--- Someone needs to explain why and when SAVED-FORM can
		       ;;--- be usefully an atom rather than a list.  In particular,
		       ;;--- is there a bug where it is a single non-atomic form
		       ;;--- rather than a list of forms? --BIM
		       DO (WHEN (AND (CL:CONSP SAVED-FORM) 
				     (MEMQ FORM SAVED-FORM))
			    (RETURN-FROM FOUND-PC START-PC)))))
	PC))))

(DEFUN FUNCTION-CORRESPONDENCE-INFO (FUNCTION)
  (DECLARE (VALUES SECTION CORRESPONDENCES))
  (TYPECASE FUNCTION
    (:COMPILED-FUNCTION
      (LET ((FUNCTION-NAME (FUNCTION-NAME FUNCTION)))
	(MULTIPLE-VALUE-BIND (PARENT-FUNCTION PARENT-DEFINITION-TYPE)
	    (SYS:FUNCTION-PARENT FUNCTION-NAME)
	  ;; all compiled functions are of type 'defun
	  (LET ((DEFINITION-TYPE (IF PARENT-FUNCTION PARENT-DEFINITION-TYPE 'DEFUN)))
	    (LET* ((SECTION
		     (LOOP NAMED FIND-SECTION FOR PICKY IN '(T NIL)
			   DO
		       (LOOP FOR (TYPE SECTION) IN
				 (IF PARENT-FUNCTION
				     (FUNCTION-SPEC-GET PARENT-FUNCTION 'ZWEI:ZMACS-BUFFERS)
				     (FUNCTION-SPEC-GET FUNCTION-NAME 'ZWEI:ZMACS-BUFFERS))
			     WHEN (AND SECTION (OR (EQ TYPE DEFINITION-TYPE)
						   (NOT PICKY)))
			       DO (RETURN-FROM FIND-SECTION SECTION))))
		   (CORRESPONDENCES
		     (FUNCTION-READ-CORRESPONDENCES FUNCTION)))
	      (VALUES SECTION CORRESPONDENCES))))))
    (OTHERWISE
      (LET ((FUNCTION (VALID-FUNCTION-DEFINITION FUNCTION)))
	;; TYPEP of NIL is not :COMPILED-FUNCTION!
	(WHEN (TYPEP FUNCTION :COMPILED-FUNCTION)
	  (FUNCTION-CORRESPONDENCE-INFO FUNCTION))))))


#+3600
(DEFUN MAKE-ESCAPE-FUNCTION (NAME LENGTH)
  (LET ((ARRAY (MAKE-ARRAY LENGTH :TYPE 'SYS:ART-16B :LEADER-LENGTH 2
			   :AREA COMPILED-FUNCTION-AREA
			   :NAMED-STRUCTURE-SYMBOL 'ESCAPE-FUNCTION)))
    (SETF (ARRAY-LEADER ARRAY 0) NAME)
    (%MAKE-POINTER-OFFSET DTP-EVEN-PC ARRAY (SI:ARRAY-DATA-OFFSET ARRAY))))

(DEFSELECT-COLD ((:PROPERTY ESCAPE-FUNCTION NAMED-STRUCTURE-INVOKE))
  (:PRINT-SELF (OBJECT STREAM DEPTH ESCAPE)
   DEPTH ESCAPE
   (SI:PRINTING-RANDOM-OBJECT (OBJECT STREAM :TYPEP)
     (PRIN1 (ARRAY-LEADER OBJECT 0) STREAM))))
