;;; -*- Package:SYSTEM-INTERNALS; Mode:LISP; Base:8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; I machine dependent storage allocation and field extraction functions.
;;; This file is in the cold load.

;;; CAR and CDR must be local variables
(DEFMACRO CONS-INTERNAL (CAR CDR AREA DATA-TYPE)
  `(PROGN (%SET-CDR-CODE-NORMAL (LOCF ,CAR))
	  (%SET-CDR-CODE-NIL (LOCF ,CDR))
	  ,(IF (EQ DATA-TYPE 'DTP-LIST)
	       `(PROG1 (%ALLOCATE-LIST-BLOCK ,AREA 2)
		       (PREPARE-FOR-BLOCK-WRITE)
		       (%BLOCK-WRITE 1 ,CAR)
		       (%BLOCK-WRITE 1 ,CDR))
	       `(%MAKE-POINTER ,DATA-TYPE
			       (PROG1 (%ALLOCATE-LIST-BLOCK ,AREA 2)
				      (PREPARE-FOR-BLOCK-WRITE)
				      (%BLOCK-WRITE 1 ,CAR)
				      (%BLOCK-WRITE 1 ,CDR))))))

;;; CONSes
(DEFUN CONS (CAR CDR)
  (DECLARE (COMPILER:RETURN-TYPE CL:LIST)
	   LT:(SIDE-EFFECTS READER))
  (CONS-INTERNAL CAR CDR DEFAULT-CONS-AREA DTP-LIST))

(DEFUN CONS-IN-AREA (CAR CDR AREA)
  (DECLARE (COMPILER:RETURN-TYPE CL:LIST)
	   LT:(SIDE-EFFECTS READER))
  (CONS-INTERNAL CAR CDR (OR AREA DEFAULT-CONS-AREA) DTP-LIST))

(DEFUN XCONS (CDR CAR)
  (DECLARE (COMPILER:RETURN-TYPE CL:LIST)
	   LT:(SIDE-EFFECTS READER))
  (CONS-INTERNAL CAR CDR DEFAULT-CONS-AREA DTP-LIST))

(DEFUN XCONS-IN-AREA (CDR CAR AREA)
  (DECLARE (COMPILER:RETURN-TYPE CL:LIST)
	   LT:(SIDE-EFFECTS READER))
  (CONS-INTERNAL CAR CDR (OR AREA DEFAULT-CONS-AREA) DTP-LIST))

(DEFUN NCONS (X)
  (DECLARE (COMPILER:RETURN-TYPE CL:LIST)
	   LT:(SIDE-EFFECTS READER))
  (LET ((NIL-VAR NIL))
    (CONS-INTERNAL X NIL-VAR DEFAULT-CONS-AREA DTP-LIST)))

(DEFUN NCONS-IN-AREA (X AREA)
  (DECLARE (COMPILER:RETURN-TYPE CL:LIST)
	   LT:(SIDE-EFFECTS READER))
  (LET ((NIL-VAR NIL))
    (CONS-INTERNAL X NIL-VAR (OR AREA DEFAULT-CONS-AREA) DTP-LIST)))

;;; LISTs

;;; Use the open-coding macros for the block-writes (see GC stuff).
(DEFUN %MAKE-LIST (INITIAL-VALUE AREA LENGTH)
  (IF (ZEROP LENGTH)
      NIL
      (PROG1
	(%ALLOCATE-LIST-BLOCK (OR AREA DEFAULT-CONS-AREA) LENGTH)
	(PREPARE-FOR-BLOCK-WRITE)
	(UNROLL-BLOCK-FORMS ((1- LENGTH) 4) (%BLOCK-1-WRITE INITIAL-VALUE))
	(%SET-CDR-CODE-NIL (LOCF INITIAL-VALUE))
	(%BLOCK-WRITE 1 INITIAL-VALUE))))

;;; Roughly %MAKE-LIST but with the first two arguments removed.  This
;;; is to be called only from code generated by the compiler when making
;;; a lexical environment.
(DEFUN %MAKE-LEXICAL-ENVIRONMENT (LENGTH)
  (IF (ZEROP LENGTH)
      NIL
      (LET ((INITIAL-VALUE NIL))
	(PROG1
	  (%ALLOCATE-LIST-BLOCK DEFAULT-CONS-AREA LENGTH)
	  (PREPARE-FOR-BLOCK-WRITE)
	  (UNROLL-BLOCK-FORMS ((1- LENGTH) 4)
	    (%BLOCK-WRITE 1 INITIAL-VALUE))
	  (%SET-CDR-CODE-NIL (LOCF INITIAL-VALUE))
	  (%BLOCK-WRITE 1 INITIAL-VALUE)))))

;;; Fast versions of LIST.  The compiler knows about these

(DEFMACRO DEF-%LIST-N (N)
  (LET ((ARGS (LOOP FOR I FROM 0 BELOW N COLLECTING (INTERN (FORMAT NIL "ARG~D" I)))))
    `(DEFUN ,(INTERN (FORMAT NIL "%LIST-~D" N))
	    ,ARGS
       (%SET-CDR-CODE-NIL (LOCF ,(CAR (LAST ARGS))))
       (PROG1
	 (%ALLOCATE-LIST-BLOCK DEFAULT-CONS-AREA ,N)
	 (PREPARE-FOR-BLOCK-WRITE)
	 ,@(LOOP FOR ARG IN ARGS COLLECTING `(%BLOCK-WRITE 1 ,ARG))))))

(DEF-%LIST-N 1)
(DEF-%LIST-N 2)
(DEF-%LIST-N 3)
(DEF-%LIST-N 4)

;;; n > 0 and n = (length elements) since only the compiler arranges to call this
;(DEFUN %LIST-N (N &REST ELEMENTS)
;  (LET* ((POINTER (%ALLOCATE-LIST-BLOCK DEFAULT-CONS-AREA N)))
;    (UNROLL-BLOCK-FORMS ((1- N) 8)
;      (%BLOCK-WRITE 1 (POP ELEMENTS)))
;    (LET ((TEMP (CAR ELEMENTS)))
;      (%SET-CDR-CODE-NIL (LOCF TEMP))
;      (%BLOCK-WRITE 1 TEMP)
;      (%MAKE-POINTER DTP-LIST POINTER))))

;;; Only the compiler calls this, and it guarantees that n = (length elements).  We
;;; know that elements has all the cdr-codes set up correctly, so we just have to
;;; copy the list.
(DEFUN %LIST-N (N &REST ELEMENTS)
  ;; This WITH-SYSTEM-BLOCK-REGISTERS is actually legal, since we go into extra-stack
  ;; mode before we set BAR-2.
  (WITH-SYSTEM-BLOCK-REGISTERS (1 2)
    (UNLESS (AND (%POINTER-LESSP (%STACK-FRAME-POINTER) ELEMENTS)
		 (%POINTER-LESSP ELEMENTS (COMPILER:%STACK-LOCATION-INTERNAL 0)))
      (LET (A B C D E F G H I J K)
	(DECLARE (IGNORE A B C D E F G H I J K))))
    (PROG1
      (%ALLOCATE-LIST-BLOCK DEFAULT-CONS-AREA N)
      (SETF (%BLOCK-REGISTER 2) ELEMENTS)
      (PREPARE-FOR-BLOCK-WRITE)
      (UNROLL-BLOCK-FORMS (N 4)
	;; use scavenge reads in case there are invisible pointers on the stack, which
	;; would move the BAR
	(%BLOCK-WRITE 1 (%BLOCK-READ 2 :CYCLE-TYPE %MEMORY-SCAVENGE :SET-CDR-NEXT NIL))))))

;;; Fast versions of LIST-IN-AREA.  The compiler knows about these
(DEFMACRO DEF-%LIST-IN-AREA-N (N)
  (LET ((ARGS (LOOP FOR I FROM 0 BELOW N COLLECTING (INTERN (FORMAT NIL "ARG~D" I)))))
    `(DEFUN ,(INTERN (FORMAT NIL "%LIST-~D-IN-AREA" N))
	    (AREA . ,ARGS)
       (%SET-CDR-CODE-NIL (LOCF ,(CAR (LAST ARGS))))
       (PROG1
	 (%ALLOCATE-LIST-BLOCK (OR AREA DEFAULT-CONS-AREA) ,N)
	 (PREPARE-FOR-BLOCK-WRITE)
	 ,@(LOOP FOR ARG IN ARGS COLLECTING `(%BLOCK-WRITE 1 ,ARG))))))

(DEF-%LIST-IN-AREA-N 1)
(DEF-%LIST-IN-AREA-N 2)
(DEF-%LIST-IN-AREA-N 3)

;;; n > 0 and n = (length elements) since only the compiler arranges to call this
;(DEFUN %LIST-N-IN-AREA (N AREA &REST ELEMENTS)
;  (LET* ((POINTER (%ALLOCATE-LIST-BLOCK AREA N)))
;    (UNROLL-BLOCK-FORMS ((1- N) 8)
;      (%BLOCK-WRITE 1 (POP ELEMENTS)))
;    (LET ((TEMP (CAR ELEMENTS)))
;      (%SET-CDR-CODE-NIL (LOCF TEMP))
;      (%BLOCK-WRITE 1 TEMP)
;      (%MAKE-POINTER DTP-LIST POINTER))))

;;; Only the compiler calls this, and it guarantees that n = (length elements).  We
;;; know that elements has all the cdr-codes set up correctly, so we just have to
;;; copy the list.
(DEFUN %LIST-N-IN-AREA (N AREA &REST ELEMENTS)
  ;; This WITH-SYSTEM-BLOCK-REGISTERS is actually legal, since we go into extra-stack
  ;; mode before we set BAR-2.
  (WITH-SYSTEM-BLOCK-REGISTERS (1 2)
    (UNLESS (AND (%POINTER-LESSP (%STACK-FRAME-POINTER) ELEMENTS)
		 (%POINTER-LESSP ELEMENTS (COMPILER:%STACK-LOCATION-INTERNAL 0)))
      (LET (A B C D E F G H I J K)
	(DECLARE (IGNORE A B C D E F G H I J K))))
    (PROG1
      (%ALLOCATE-LIST-BLOCK (OR AREA DEFAULT-CONS-AREA) N)
      (SETF (%BLOCK-REGISTER 2) ELEMENTS)
      (PREPARE-FOR-BLOCK-WRITE)
      (UNROLL-BLOCK-FORMS (N 4)
	(%BLOCK-WRITE 1 (%BLOCK-READ 2 :SET-CDR-NEXT NIL))))))

;;; n is (length args), and therefore > 1, since only the compiler arranges to call this
(DEFUN %LIST*-N (N &REST ELEMENTS)
  (PROG1
    (%ALLOCATE-LIST-BLOCK DEFAULT-CONS-AREA N)
    (UNROLL-BLOCK-FORMS ((- N 2) 4)
      (%BLOCK-WRITE 1 (PROG1 (POP ELEMENTS) (PREPARE-FOR-BLOCK-WRITE))))
    (LET ((TEMP1 (POP ELEMENTS))
	  (TEMP2 (CAR ELEMENTS)))
      (%SET-CDR-CODE-NORMAL (LOCF TEMP1))
      (%SET-CDR-CODE-NIL (LOCF TEMP2))
      (PREPARE-FOR-BLOCK-WRITE)
      (%BLOCK-WRITE 1 TEMP1)
      (%BLOCK-WRITE 1 TEMP2))))

;;; n is (length args), and therefore > 1, since only the compiler arranges to call this
(DEFUN %LIST*-N-IN-AREA (N AREA &REST ELEMENTS)
  (PROG1
    (%ALLOCATE-LIST-BLOCK (OR AREA DEFAULT-CONS-AREA) N)
    (UNROLL-BLOCK-FORMS ((- N 2) 4)
      (%BLOCK-WRITE 1 (PROG1 (POP ELEMENTS) (PREPARE-FOR-BLOCK-WRITE))))
    (LET ((TEMP1 (POP ELEMENTS))
	  (TEMP2 (CAR ELEMENTS)))
      (%SET-CDR-CODE-NORMAL (LOCF TEMP1))
      (%SET-CDR-CODE-NIL (LOCF TEMP2))
      (PREPARE-FOR-BLOCK-WRITE)
      (%BLOCK-WRITE 1 TEMP1)
      (%BLOCK-WRITE 1 TEMP2))))

;;; Lexical Closures

(DEFUN MAKE-LEXICAL-CLOSURE (ENVIRONMENT FUNCTION)
  (CONS-INTERNAL ENVIRONMENT FUNCTION DEFAULT-CONS-AREA DTP-LEXICAL-CLOSURE))

(DEFUN CAPTURE-VARIABLE (VARIABLE POINTER)
  ;; This is a separate function only so that capturings can be found by Phase-4.
  (CONS-INTERNAL VARIABLE POINTER DEFAULT-CONS-AREA DTP-LIST))

(DEFUN COMPILER:SET-CLOSURE-ENVIRONMENT (CLOSURE ENVIRONMENT)
  (WHEN (TYPEP CLOSURE :LEXICAL-CLOSURE)
    (SETF (SYS:LEXICAL-CLOSURE-ENVIRONMENT CLOSURE) ENVIRONMENT)))


;;; Consers for number implemented as lists.  These do minimal (if any
;;; checking) and cons the requested number type from the components.

(DEFUN %MAKE-DOUBLE (HIGH LOW)
  (CONS-INTERNAL HIGH LOW DEFAULT-CONS-AREA DTP-DOUBLE-FLOAT))

(DEFUN %MAKE-COMPLEX (REAL IMAG)
  (CONS-INTERNAL REAL IMAG DEFAULT-CONS-AREA DTP-COMPLEX))

(DEFSUBST %MAKE-SMALL-RATIO (NUMERATOR DENOMINATOR)
  (%SET-TAG (%LOGDPB NUMERATOR %%SMALL-RATIO-NUMERATOR DENOMINATOR) DTP-SMALL-RATIO))

(DEFUN %MAKE-BIG-RATIO (NUMERATOR DENOMINATOR)
  (CONS-INTERNAL NUMERATOR DENOMINATOR DEFAULT-CONS-AREA DTP-BIG-RATIO))

(DEFSUBST SMALL-RATIO-NUMERATOR (RATIO)
  (ASH (%SET-TAG RATIO  DTP-FIXNUM) (- (BYTE-POSITION %%SMALL-RATIO-NUMERATOR))))

(DEFSUBST SMALL-RATIO-DENOMINATOR (RATIO)
  (LDB %%SMALL-RATIO-DENOMINATOR (%SET-TAG RATIO  DTP-FIXNUM)))

(DEFUN %MAKE-RATIONAL (NUMERATOR DENOMINATOR)
  (COND ((= DENOMINATOR 1) NUMERATOR)
	((AND (< DENOMINATOR 1_16.)
	      (< NUMERATOR 1_15.)
	      (NOT (< NUMERATOR -1_15.)))
	 (%MAKE-SMALL-RATIO NUMERATOR DENOMINATOR))
	(T (CONS-INTERNAL NUMERATOR DENOMINATOR DEFAULT-CONS-AREA DTP-BIG-RATIO))))

;;; Make a structure whose size can be determined entirely from its first header word
;;; When we return, BAR-1 will point to the first word after the header word

(DEFUN %MAKE-STRUCTURE (POINTER-DTP HEADER-DTP HEADER-TYPE REST-OF-HEADER AREA LENGTH)
  (LET ((POINTER (IF (EQ AREA :STACK)
		     (ALLOCATE-DATA-STACK LENGTH)
		     (%ALLOCATE-STRUCTURE-BLOCK (OR AREA DEFAULT-CONS-AREA) LENGTH))))
    ;; At this point, BAR-1 points to the address we just allocated
    (PREPARE-FOR-BLOCK-WRITE)
    (%BLOCK-WRITE 1
		  (%SET-TAG
		    REST-OF-HEADER
		    (%LOGDPB HEADER-TYPE SYS:%%Q-CDR-CODE-WITHIN-TAG
			     (%LOGDPB HEADER-DTP SYS:%%Q-TYPE-WITHIN-TAG 0))))
    (%MAKE-POINTER POINTER-DTP POINTER)))

;;;; Symbols
(DEFUN MAKE-SYMBOL (PRINT-NAME &OPTIONAL PERMANENT-P)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (CHECK-ARG-TYPE PRINT-NAME :STRING "A string")
  (AND PERMANENT-P (NOT (= (%AREA-NUMBER PRINT-NAME) PNAME-AREA))
       (SETQ PRINT-NAME (SUBSTRING PRINT-NAME 0 NIL PNAME-AREA)))
  (LET* ((SYMBOL (%MAKE-STRUCTURE DTP-SYMBOL DTP-HEADER-P %HEADER-TYPE-SYMBOL PRINT-NAME
				  (IF PERMANENT-P AREA-FOR-NEW-SYMBOLS DEFAULT-CONS-AREA)
				  (DEFSTORAGE-SIZE SYMBOL)))
	 (UNBOUND (%SET-TAG SYMBOL DTP-NULL)))
    (%BLOCK-WRITE 1 UNBOUND)			;Value cell
    (%BLOCK-WRITE 1 UNBOUND)			;Function cell
    (%BLOCK-WRITE 1 NIL)			;Property List
    (%BLOCK-WRITE 1 NIL)			;Package
    SYMBOL))

(DEFUN VALUE-CELL-LOCATION (SYMBOL)
  (CHECK-ARG SYMBOL SYMBOLP "symbol")
  (LOCF (SYMBOL-VALUE-CELL SYMBOL)))

(DEFUN FUNCTION-CELL-LOCATION (SYMBOL)
  (CHECK-ARG SYMBOL SYMBOLP "symbol")
  (LOCF (SYMBOL-FUNCTION-CELL SYMBOL)))

(DEFUN PACKAGE-CELL-LOCATION (SYMBOL)
  (CHECK-ARG SYMBOL SYMBOLP "symbol")
  (LOCF (SYMBOL-PACKAGE-CELL SYMBOL)))

(DEFUN PROPERTY-CELL-LOCATION (SYMBOL)
  (CHECK-ARG SYMBOL SYMBOLP "symbol")
  (LOCF (SYMBOL-PROPERTY-CELL SYMBOL)))

(DEFUN SYMEVAL (SYMBOL)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (CHECK-ARG SYMBOL SYMBOLP "symbol")
  (LOCATION-CONTENTS (LOCF (SYMBOL-VALUE-CELL SYMBOL))))

(DEFUN FSYMEVAL (SYMBOL)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (CHECK-ARG SYMBOL SYMBOLP "symbol")
  (LOCATION-CONTENTS (LOCF (SYMBOL-FUNCTION-CELL SYMBOL))))

(DEFUN BOUNDP (SYMBOL)
  (DECLARE LT:(SIDE-EFFECTS READER) (COMPILER:RETURN-TYPE SCL:BOOLEAN))
  (CHECK-ARG SYMBOL SYMBOLP "symbol")
  (NOT (TYPE-MEMBER (%MEMORY-READ (LOCF (SYMBOL-VALUE-CELL SYMBOL))
				  :CYCLE-TYPE %MEMORY-DATA-WRITE)
		    DTP-NULL)))

(DEFUN FBOUNDP (SYMBOL)
  (DECLARE LT:(SIDE-EFFECTS READER) (COMPILER:RETURN-TYPE SCL:BOOLEAN))
  (CHECK-ARG SYMBOL SYMBOLP "symbol")
  (NOT (TYPE-MEMBER (%MEMORY-READ (LOCF (SYMBOL-FUNCTION-CELL SYMBOL))
				  :CYCLE-TYPE %MEMORY-DATA-WRITE)
		    DTP-NULL)))

(DEFUN SET (SYMBOL VALUE)
  (CHECK-ARG SYMBOL SYMBOLP "symbol")
  (CL:SETF (LOCATION-CONTENTS (LOCF (SYMBOL-VALUE-CELL SYMBOL))) VALUE))

(DEFUN GET (SYM INDICATOR)
  (VALUES
    (SYS:RGETF
      INDICATOR
      (ARGUMENT-TYPECASE SYM
	(:SYMBOL (SYMBOL-PROPERTY-CELL SYM))
	(:LOCATIVE (LOCATION-CONTENTS SYM))
	(:LIST (CDR SYM))
	(OTHERWISE (RETURN-FROM GET NIL))))))

(DEFUN GET-PNAME (SYMBOL)
  (DECLARE LT:(SIDE-EFFECTS READER))
  (CHECK-ARG SYMBOL SYMBOLP "symbol")
  (%SET-TAG (%MEMORY-READ SYMBOL :CYCLE-TYPE %MEMORY-HEADER) DTP-STRING))

;;; Instances

(DEFUN %MAKE-INSTANCE (DESCRIPTOR AREA SIZE)
  (%MAKE-STRUCTURE DTP-INSTANCE DTP-HEADER-P
		   %HEADER-TYPE-INSTANCE DESCRIPTOR (OR AREA DEFAULT-CONS-AREA) SIZE))

;;; Array stuff

(ARRAY-USED-AS-FUNCTION ARRAY-TYPES)
(ARRAY-USED-AS-FUNCTION ARRAY-NULL-ELEMENT)
(ARRAY-USED-AS-FUNCTION ARRAY-NULL-WORD)


;;; ARRAY is the displaced array
;;; D-ARRAY is the array ARRAY is displaced to
;;; RANK is the rank.  Both arrays D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")must0 have the same rank.  This is the caller's
;;; responsibility.
(DEFUN %INHERIT-CONFORMAL-MULTIPLIERS (ARRAY D-ARRAY RANK)
  (WITH-BLOCK-REGISTERS (1)
    (SETF (%BLOCK-REGISTER 1) ARRAY)
    (LET* ((HEADER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER))
	   (LENGTH (%BLOCK-READ 1))
	   (INDEX-OFFSET (%BLOCK-READ 1 :PREFETCH NIL))
	   (ARRAY-ADDRESS (%POINTER-PLUS (%BLOCK-REGISTER 1) -3))
	   (HEADER-FIX (%POINTER HEADER))
	   (D-HEADER
	     (PROGN (SETF (%BLOCK-REGISTER 1) D-ARRAY)
		    (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER)))
	   (D-LENGTH (%BLOCK-READ 1 :PREFETCH NIL))
	   (SHIFT (- (LDB ARRAY-BYTE-PACKING HEADER-FIX)
		     (LDB ARRAY-BYTE-PACKING (%POINTER D-HEADER)))))
      (DECLARE (IGNORE LENGTH))
      (LOOP FOR OFFSET DOWNFROM (+ (* RANK 2) 2) DOWNTO 4 BY 2
	    FOR INDEX = (%MEMORY-READ (%POINTER-PLUS ARRAY OFFSET))
	    FOR MULTIPLIER = (LSH (%MEMORY-READ (%POINTER-PLUS D-ARRAY (+ OFFSET 1))) SHIFT)
	    DOING
	(%MEMORY-WRITE (%POINTER-PLUS ARRAY (+ OFFSET 1)) MULTIPLIER)
	    FINALLY
	      (SETF (%BLOCK-REGISTER 1) ARRAY-ADDRESS)
	      (PREPARE-FOR-BLOCK-WRITE)
	      (%BLOCK-WRITE
		1 (%SET-TAG (%LOGDPB 1 ARRAY-DISCONTIGUOUS-BIT HEADER-FIX)
			    (DPB %HEADER-TYPE-ARRAY %%Q-CDR-CODE-WITHIN-TAG DTP-HEADER-I)))
	      (%BLOCK-WRITE 1 (MIN (MAX (- (LSH D-LENGTH SHIFT) INDEX-OFFSET) 0)
				   (* INDEX MULTIPLIER)))
	      (RETURN NIL)))))

;; ARRAY is the new (or being adjusted array).
;; D-ARRAY is the target array.
;; RANK is the number of dimensions (= for both arrays, and  2).
(DEFUN %STORE-NONCONFORMAL-MULTIPLIERS (ARRAY RANK)
  (SETF (ARRAY-DISCONTIGUOUS-BIT ARRAY) 0)
  ;; The dimensions have already been stored.  Work backwards through the (dimension
  ;; multiplier) pairs, maintaining the cumulative multiplier and storing it into the
  ;; multiplier fields.
  (LOOP WITH CUMULATIVE = 1
	REPEAT RANK
	FOR OFFSET = (+ 4 (ROT (- RANK 1) 1)) THEN (- OFFSET 2)
	FOR DIMENSION = (%P-CONTENTS-OFFSET ARRAY OFFSET)
	DO (%P-STORE-CONTENTS-OFFSET CUMULATIVE ARRAY (+ OFFSET 1))
	   (SETQ CUMULATIVE (* CUMULATIVE DIMENSION))))

(DEFUN ARRAY-HAS-LEADER-P (ARRAY)
  (DECLARE LT:(SIDE-EFFECTS REDUCIBLE))
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-STRING DTP-ARRAY) "an array")
  (PLUSP (ARRAY-LEADER-LENGTH-FIELD ARRAY)))

(DEFUN ARRAY-LEADER-LENGTH (ARRAY)
  (DECLARE LT:(SIDE-EFFECTS REDUCIBLE))
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-STRING DTP-ARRAY) "an array")
  (LET ((LENGTH (ARRAY-LEADER-LENGTH-FIELD ARRAY)))
    (IF (ZEROP LENGTH)
	NIL
	LENGTH)))

(DEFUN ARRAY-DATA-OFFSET (ARRAY)
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (LET ((HEADER (%FIXNUM (%MEMORY-READ ARRAY :CYCLE-TYPE %MEMORY-HEADER))))
    (IF (NOT (LDB-TEST ARRAY-LONG-PREFIX-BIT HEADER))
	1
	(+ (ROT (LDB ARRAY-LONG-DIMENSIONS-FIELD HEADER) 1) (DEFSTORAGE-SIZE SYS:ARRAY)))))

(DEFUN ARRAY-PREFIX-LENGTH (ARRAY)
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (LET ((HEADER (%FIXNUM (%MEMORY-READ ARRAY :CYCLE-TYPE %MEMORY-HEADER))))
    (IF (NOT (LDB-TEST ARRAY-LONG-PREFIX-BIT HEADER))
	1
	(+ (ROT (LDB ARRAY-LONG-DIMENSIONS-FIELD HEADER) 1) (DEFSTORAGE-SIZE SYS:ARRAY)))))

(DEFWIREDFUN CL:ARRAY-TOTAL-SIZE (ARRAY)
  (DECLARE (UNSAFEGUARDED-REFERENCE DBG:CHECK-ARG-1 ARRAY))
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (WITH-BLOCK-REGISTERS (1)
    ;; Use block register 1 to read the header using the appropriate cycle type.
    ;; Afterward, we can address other words of the array header relative to it,
    ;; since it follows any forwarding pointers.
    (SETF (%BLOCK-REGISTER 1) ARRAY)
    (LET ((HEADER (%SET-TAG (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER) DTP-FIXNUM)))
      ;; If it's a short prefix array, return the length in the header.
      (IF (NOT (LDB-TEST ARRAY-LONG-PREFIX-BIT HEADER))
	  (LDB ARRAY-SHORT-LENGTH-FIELD HEADER)
	;; Otherwise return the long length, conveniently located in the next word.
	(%BLOCK-READ 1 :FIXNUM-ONLY T :PREFETCH NIL)))))

;;; The same as CL:LENGTH except it only takes arrays and allows multidimensional arrays.
(DEFUN ARRAY-ACTIVE-LENGTH (ARRAY)
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (WITH-BLOCK-REGISTERS (1)
    ;; Use block register 1 to read the header using the appropriate cycle type.
    ;; Afterward, we can address other words of the array header relative to it,
    ;; since it follows any forwarding pointers.
    (SETF (%BLOCK-REGISTER 1) ARRAY)
    (LET ((HEADER (%SET-TAG (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER) DTP-FIXNUM)))
      ;; First do a quick check for a short prefix array with leader-length 0,
      ;; returning the short array length field in the header in this common case.
      (COND ((NOT (LDB-TEST ARRAY-LEADER-LENGTH-AND-LONG-PREFIX-FIELD HEADER))
	     (LDB ARRAY-SHORT-LENGTH-FIELD HEADER))
	    ((NOT (LDB-TEST ARRAY-LONG-PREFIX-BIT HEADER))
	     ;; It's a short-prefix array with a leader.  If the first leader element
	     ;; is a fixnum, it's a fill-pointer, otherwise return the length.
	     (LET ((FILL-POINTER
		     ;; Block register has advanced to one past the header.
		     (%MEMORY-READ (%POINTER-PLUS (%BLOCK-REGISTER 1) -2))))
	       (IF (CL:TYPEP FILL-POINTER 'CL:FIXNUM)
		   FILL-POINTER
		 (LDB ARRAY-SHORT-LENGTH-FIELD HEADER))))
	    (T
	     ;; It's a long-prefix array.  If it has a fill-pointer, return that.
	     (WHEN (LDB-TEST ARRAY-LEADER-LENGTH-FIELD HEADER)
	       (LET ((FILL-POINTER
		       ;; Block register has advanced to one past the header.
		       (%MEMORY-READ (%POINTER-PLUS (%BLOCK-REGISTER 1) -2))))
		 (WHEN (CL:TYPEP FILL-POINTER 'CL:FIXNUM)
		   (RETURN-FROM ARRAY-ACTIVE-LENGTH FILL-POINTER))))
	     ;; Otherwise return the long length, conveniently located in the next word.
	     (%BLOCK-READ 1 :FIXNUM-ONLY T :PREFETCH NIL))))))

(DEFUN VECTOR-LENGTH (ARRAY)
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (WITH-BLOCK-REGISTERS (1)
    ;; Use block register 1 to read the header using the appropriate cycle type.
    ;; Afterward, we can address other words of the array header relative to it,
    ;; since it follows any forwarding pointers.
    (SETF (%BLOCK-REGISTER 1) ARRAY)
    (LET ((HEADER (%SET-TAG (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER) DTP-FIXNUM)))
      ;; First do a quick check for a short prefix array with leader-length 0,
      ;; returning the short array length field in the header in this common case.
      (COND ((NOT (LDB-TEST ARRAY-LEADER-LENGTH-AND-LONG-PREFIX-FIELD HEADER))
	     (LDB ARRAY-SHORT-LENGTH-FIELD HEADER))
	    ((NOT (LDB-TEST ARRAY-LONG-PREFIX-BIT HEADER))
	     ;; It's a short-prefix array with a leader.  If the first leader element
	     ;; is a fixnum, it's a fill-pointer, otherwise return the length.
	     (LET ((FILL-POINTER (%MEMORY-READ
				   ;; Block register has advanced to one past the header.
				   (%POINTER-PLUS (%BLOCK-REGISTER 1) -2))))
	       (IF (CL:TYPEP FILL-POINTER 'CL:FIXNUM)
		   FILL-POINTER
		   (LDB ARRAY-SHORT-LENGTH-FIELD HEADER))))
	    ;; Now we know it's a long-prefix array, possibly with a leader.  However,
	    ;; it must be one-dimensional, so check that here.
	    ((= (LDB ARRAY-LONG-DIMENSIONS-FIELD HEADER) 1)
	     ;; If it has a leader and the first element is a fill-pointer, return that.
	     (IF (LDB-TEST ARRAY-LEADER-LENGTH-FIELD HEADER)
		 (LET ((FILL-POINTER (%MEMORY-READ
				       ;; Block register has advanced to one past the header.
				       (%POINTER-PLUS (%BLOCK-REGISTER 1) -2))))
		   (IF (CL:TYPEP FILL-POINTER 'CL:FIXNUM)
		       FILL-POINTER
		       ;; Return the long length, conveniently located in the next word.
		       (%BLOCK-READ 1 :FIXNUM-ONLY T :PREFETCH NIL)))
		 (%BLOCK-READ 1 :FIXNUM-ONLY T :PREFETCH NIL)
		 ))
	    ;; Multidimensional arrays are no good
	    (T (VECTOR-LENGTH (DBG:CHECK-TYPE-1 'ARRAY ARRAY 'VECTOR "a vector")))))))

(DEFUN ARRAY-DIMENSION-N (N ARRAY)
  (DECLARE LT:(SIDE-EFFECTS REDUCIBLE))
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (WITH-BLOCK-REGISTERS (1)
    (SETF (%BLOCK-REGISTER 1) ARRAY)
    (LET ((HEADER (%POINTER (%BLOCK-READ 1
					 :CYCLE-TYPE %MEMORY-HEADER
					 :PREFETCH NIL
					 :NO-INCREMENT T))))
      (IF ( N 0)
	  (LET ((LLENGTH (LDB ARRAY-LEADER-LENGTH-FIELD HEADER)))
	    (IF (ZEROP LLENGTH) NIL LLENGTH))
	  (IF (LDB-TEST ARRAY-LONG-PREFIX-BIT HEADER)
	      (LET ((DIMS (LDB ARRAY-LONG-DIMENSIONS-FIELD HEADER)))
		(IF ( N DIMS)
		    (%MEMORY-READ 
		      (%POINTER-PLUS
			(%BLOCK-REGISTER 1)
			(+ -2 (SYS:DEFSTORAGE-SIZE ARRAY) (* N 2))))
		    NIL))
	      (IF (> N 1)
		  NIL
		  (LDB ARRAY-SHORT-LENGTH-FIELD HEADER)))))))

;;; Return the number of array elements spanned by a row of this 2-dimensional array.
;;; Normally this is just equal to the length of a row (i.e. the number of columns)
;;; but for conformally displaced arrays the length and the span are not equal.
;;; This function is primarily for users of %1D-AREF and the ARRAY-REGISTER-1D declaration.
;;;
;;; A row is the sequence of elements with the same value in the first subscript
;;; and varying values in the second subscript.
;;; In the old column-major order system, the TV displaced a column
;;; horizontally.  In the current row-major order system the TV displays
;;; a row horizontally and a column vertically.
(DEFUN ARRAY-ROW-SPAN (ARRAY)
  (DECLARE LT:(SIDE-EFFECTS REDUCIBLE))
  (WITH-BLOCK-REGISTERS (1)
    ;; Use block register 1 to read the header using the appropriate cycle type.
    ;; Afterward, we can address other words of the array header relative to it,
    ;; since it follows any forwarding pointers.
    (TAGBODY
      RETRY
	 (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY) "an array")
	 (SETF (%BLOCK-REGISTER 1) ARRAY)
	 (LET ((HEADER (%POINTER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER
					      :PREFETCH NIL :NO-INCREMENT T))))
	   (COMPILER:%ERROR-UNLESS (= (LOGAND HEADER
					      (%LOGDPBS 1 ARRAY-LONG-PREFIX-BIT
							-1 ARRAY-LONG-DIMENSIONS-FIELD
							0))
				      (%LOGDPBS 1 ARRAY-LONG-PREFIX-BIT
						2 ARRAY-LONG-DIMENSIONS-FIELD
						0))
	     (SIGNAL-PROCEED-CASE ((NEW-ARRAY)
				   'SYS:ARRAY-WRONG-NUMBER-OF-DIMENSIONS
				   :FUNCTION 'ARRAY-ROW-SPAN
				   :ARRAY ARRAY
				   :DIMENSIONS-EXPECTED 2
				   :DIMENSIONS-GIVEN
				   (IF (LDB-TEST ARRAY-LONG-PREFIX-BIT HEADER)
				       (LDB ARRAY-LONG-DIMENSIONS-FIELD HEADER)
				       1))
	       (:NEW-ARRAY
		 (SETQ ARRAY NEW-ARRAY)
		 (GO RETRY))))
	   (RETURN-FROM ARRAY-ROW-SPAN
	     (%MEMORY-READ
	       (%POINTER-PLUS (%BLOCK-REGISTER 1)
			      (+ (DEFSTORAGE-SIZE ARRAY) 2 -1)) :FIXNUM-ONLY T))))))

;;; Make an array large or smaller.  For multi-dimensional arrays,
;;; changes the (row-major: first, column-major: last) dimension (the
;;; one which varies slowest).  If array displaced, adjust request
;;; refers to the displaced header, not pointed-to data.  If the array
;;; is copied, the value returned is the new copy but the old copy is
;;; forwarded to point to the new.
;;;
;;; There are a bunch of pathological cases which one might expect to work
;;; with stack arrays which won't.  In these cases the array is forwarded
;;; into WORKING-STORAGE-AREA.
;;;    1.  Any extension which would cause the data stack to grow.
;;;    2.  Shrinking an array while it is not on the top of the data stack,
;;;        and subsequently growing it (even if it is then on the top).
(DEFUN ADJUST-ARRAY-SIZE (ARRAY NEW-INDEX-LENGTH
			  &AUX SHORT-P TYPE NEW-DATA-LENGTH REGION DATA-BASE
			       DATA-BASE-RELATIVE-TO-REGION NDIMS NEW-FORMAT
			       CURRENT-INDEX-LENGTH CURRENT-DATA-LENGTH NEW-ARRAY
			       STACK-ARRAY SG)
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (SCL:CHECK-TYPE NEW-INDEX-LENGTH (CL:INTEGER 0))
  (WITHOUT-INTERRUPTS-AND-STACK-OVERFLOWS (200.)
    (UPDATE-CONS-CACHE-REGION-FREE-POINTERS)
    (SETQ ARRAY (FOLLOW-STRUCTURE-FORWARDING ARRAY))
    (SETQ SHORT-P (ZEROP (ARRAY-LONG-PREFIX-BIT ARRAY))
	  TYPE (ARRAY-TYPE-FIELD ARRAY)
	  NDIMS (ARRAY-#-DIMS ARRAY))
    (SETQ CURRENT-INDEX-LENGTH (CL:ARRAY-TOTAL-SIZE ARRAY))
    (LET ((ELEMS-PER-Q (ARRAY-ELEMENTS-PER-Q TYPE)))
      (SETQ NEW-DATA-LENGTH     (CEILING NEW-INDEX-LENGTH ELEMS-PER-Q)
	    CURRENT-DATA-LENGTH (CEILING CURRENT-INDEX-LENGTH ELEMS-PER-Q)))
    (SETQ REGION (%REGION-NUMBER ARRAY)
	  DATA-BASE (+ (%POINTER ARRAY) (ARRAY-DATA-OFFSET ARRAY))
	  DATA-BASE-RELATIVE-TO-REGION (- DATA-BASE (REGION-ORIGIN REGION)))
    (SETQ NEW-FORMAT
	  (AND SHORT-P
	       ( NEW-INDEX-LENGTH (DEFSYSBYTE-LIMIT-VALUE ARRAY-SHORT-LENGTH-FIELD))))
    (COND ((SETQ STACK-ARRAY (LDB-TEST %%REGION-STACK (REGION-BITS (%REGION-NUMBER ARRAY))))
	   (SETQ SG %CURRENT-STACK-GROUP)))
    (COND ((ARRAY-DISPLACED-P ARRAY)
	   (AND (> NEW-INDEX-LENGTH CURRENT-INDEX-LENGTH)
		(FERROR "Can't make displaced array ~S bigger" ARRAY))
	   (%SET-ARRAY-LENGTH ARRAY SHORT-P NEW-INDEX-LENGTH)
	   ARRAY)
	  ((AND ( NEW-DATA-LENGTH CURRENT-DATA-LENGTH)	;No new storage needed
		(NOT NEW-FORMAT))
	   (COND ((= NEW-DATA-LENGTH CURRENT-DATA-LENGTH))	;No storage change
		 (STACK-ARRAY
		  ;; If this is the top object on the data stack, then shrink the
		  ;; data stack.  Otherwise leave the garbage off the end of the
		  ;; array without making a dummy array.  This is no problem since
		  ;; the data stack can never become oldspace.
		  (LET ((DATA-STACK-POINTER (SG-DATA-STACK-POINTER SG)))
		    (WHEN (EQ DATA-STACK-POINTER
			      (%MAKE-POINTER-OFFSET DTP-LOCATIVE DATA-BASE
						    (1- CURRENT-DATA-LENGTH)))
		      (ADJUST-DATA-STACK-POINTER SG DATA-STACK-POINTER
		        (%MAKE-POINTER-OFFSET DTP-LOCATIVE DATA-BASE (1- NEW-DATA-LENGTH))))))
		 ((= (+ DATA-BASE-RELATIVE-TO-REGION CURRENT-DATA-LENGTH)
		     (REGION-FREE-POINTER REGION))
		  ;; Last thing in region, decrement the free pointer
		  (GC-RESET-FREE-POINTER REGION
					 (+ DATA-BASE-RELATIVE-TO-REGION NEW-DATA-LENGTH)))
		 (T
		  ;; Fill in the hole with a dummy array
		  (%UNMAKE-STRUCTURE (+ DATA-BASE NEW-DATA-LENGTH)
				     (- CURRENT-DATA-LENGTH NEW-DATA-LENGTH))))
	   (%SET-ARRAY-LENGTH ARRAY SHORT-P NEW-INDEX-LENGTH)
	   (AND (= TYPE ART-Q-LIST) (PLUSP NEW-INDEX-LENGTH)
		(%P-STORE-CDR-CODE (+ DATA-BASE (1- NEW-INDEX-LENGTH)) CDR-NIL))
	   ;; Fixup the indirect-pointer for a long, now zero-length
	   ;; array
	   (WHEN (AND (NOT SHORT-P)
		      (ZEROP NEW-DATA-LENGTH))
	     (SETF (ARRAY-INDIRECT-POINTER ARRAY) (%SET-TAG ARRAY DTP-LOCATIVE)))
	   ARRAY)
	  ;; Need increased storage.  Either make fresh copy or extend existing copy.
	  ((OR NEW-FORMAT
	       (IF STACK-ARRAY
		   (OR ;; Not at top of data stack.
		       (NEQ (SG-DATA-STACK-POINTER SG)
			    (%MAKE-POINTER-OFFSET DTP-LOCATIVE DATA-BASE
						  (1- CURRENT-DATA-LENGTH)))
		       ;; Data stack isn't big enough.
		       (%POINTER-LESSP (SG-DATA-STACK-LIMIT SG)
				       (+ DATA-BASE (1- NEW-DATA-LENGTH))))
		   (OR ;; Not at end of region.
		       (< (+ DATA-BASE-RELATIVE-TO-REGION CURRENT-DATA-LENGTH)
			  (REGION-FREE-POINTER REGION))
		       ;; Region isn't big enough.
		       (> (+ DATA-BASE-RELATIVE-TO-REGION NEW-DATA-LENGTH)
			  (REGION-LENGTH REGION)))))
	   (SETQ NEW-ARRAY (MAKE-ARRAY (IF (= NDIMS 1) NEW-INDEX-LENGTH
					   #+row-major
					   (LET ((DIMS (ARRAY-DIMENSIONS ARRAY)))
					     (SETF (FIRST DIMS) (// NEW-INDEX-LENGTH
								    (APPLY #'* (CDR DIMS))))
					     DIMS)
					   #-row-major
					   (LET ((DIMS (ARRAY-DIMENSIONS ARRAY)))
					     (RPLACA (LAST DIMS) 1)
					     (RPLACA (LAST DIMS) (// NEW-INDEX-LENGTH
								     (LIST-PRODUCT DIMS)))
					     DIMS))
				       ':AREA (IF STACK-ARRAY WORKING-STORAGE-AREA
						  (%AREA-NUMBER ARRAY))
				       ':TYPE TYPE
				       ':LEADER-LENGTH (ARRAY-LEADER-LENGTH ARRAY)))
	   (COPY-ARRAY-CONTENTS-AND-LEADER ARRAY NEW-ARRAY)
	   (SETF (ARRAY-NAMED-STRUCTURE-BIT NEW-ARRAY) (ARRAY-NAMED-STRUCTURE-BIT ARRAY))
	   ;; this is probably never necessary
	   (UNLESS (OR SHORT-P (ZEROP (ARRAY-LONG-PREFIX-BIT NEW-ARRAY)))
	     #+row-major (SETF (ARRAY-DISCONTIGUOUS-BIT NEW-ARRAY)
			       (ARRAY-DISCONTIGUOUS-BIT ARRAY)))
	   (STRUCTURE-FORWARD ARRAY NEW-ARRAY
			      (ARRAY-PREFIX-LENGTH ARRAY) (ARRAY-PREFIX-LENGTH NEW-ARRAY))
	   NEW-ARRAY)
	  (T   ;Array is at end of data stack or region, just grow it
	   (IF (NOT STACK-ARRAY)
	       (GC-RESET-FREE-POINTER REGION (+ DATA-BASE-RELATIVE-TO-REGION NEW-DATA-LENGTH))
	       (ADJUST-DATA-STACK-POINTER SG (SG-DATA-STACK-POINTER SG)
		 (%MAKE-POINTER-OFFSET DTP-LOCATIVE DATA-BASE (1- NEW-DATA-LENGTH))))
	   (%SET-ARRAY-LENGTH ARRAY SHORT-P NEW-INDEX-LENGTH)
	   (%BLOCK-STORE-CDR-AND-CONTENTS (+ DATA-BASE CURRENT-DATA-LENGTH)
					  (- NEW-DATA-LENGTH CURRENT-DATA-LENGTH)
					  CDR-NEXT
					  (ARRAY-NULL-WORD TYPE)
					  0)
	   ;; Fixup the indirect-pointer for a long, previously
	   ;; zero-length array
	   (WHEN (AND (NOT SHORT-P)
		      (ZEROP CURRENT-DATA-LENGTH))
	     (SETF (ARRAY-INDIRECT-POINTER ARRAY)
		   (%SET-TAG DATA-BASE DTP-LOCATIVE)))
	   (COND ((= TYPE ART-Q-LIST)
		  (SETF (%P-CDR-CODE (+ DATA-BASE NEW-INDEX-LENGTH -1)) CDR-NIL)
		  (WHEN (PLUSP CURRENT-INDEX-LENGTH)
		    (SETF (%P-CDR-CODE (+ DATA-BASE CURRENT-INDEX-LENGTH -1)) CDR-NEXT))))
	   ARRAY))))

;;; Subprimitive for above
(DEFUN %SET-ARRAY-LENGTH (ARRAY SHORT-P NEW-LENGTH)
  (COND (SHORT-P (SETF (ARRAY-SHORT-LENGTH-FIELD ARRAY) NEW-LENGTH))
	(T (SETF (%P-CONTENTS-OFFSET ARRAY (DEFSTORAGE-SIZE ARRAY)) NEW-LENGTH)
	   (SETF (ARRAY-LONG-LENGTH-FIELD ARRAY)
		  (* NEW-LENGTH (%P-CONTENTS-OFFSET ARRAY (+ (DEFSTORAGE-SIZE ARRAY) 1))))))
  (ARRAY-REGISTER-EVENT))

;;; Dispose of an array, returning its storage to free if possible.
;;; If the array is displaced, the displaced-array header is disposed of,
;;; not the pointed-to data.
;;; You had better get rid of all pointers to this array before calling this,
;;; e.g. (RETURN-ARRAY (PROG1 FOO (SETQ FOO NIL)))
;;; Having those pointers lying around is okay (unlike the situation on the CADR),
;;; but trying to access the array through them, or even trying to print them out,
;;; gives unpredictable results.
;;; Returns T if storage really reclaimed, NIL if not.
(DEFUN RETURN-ARRAY (ARRAY &AUX REGION ARRAY-ORIGIN ARRAY-SIZE)
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  ;; Turn off garbage collection, allocation in this region
  (WITHOUT-INTERRUPTS-AND-STACK-OVERFLOWS (200.)
    (UPDATE-CONS-CACHE-REGION-FREE-POINTERS)
    (SETQ REGION (%REGION-NUMBER ARRAY))
    (MULTIPLE-VALUE (NIL ARRAY-ORIGIN ARRAY-SIZE) (%FIND-STRUCTURE-EXTENT ARRAY))
    (SETQ ARRAY-ORIGIN (%POINTER ARRAY-ORIGIN))
    (WHEN (= (%P-DATA-TYPE ARRAY) DTP-HEADER-FORWARD)
      ;; Get the array that is pointed-to and get rid of the pointer to it
      (SETQ ARRAY (%MAKE-POINTER DTP-ARRAY (%P-CONTENTS-AS-LOCATIVE ARRAY)))
      (%BLOCK-STORE-TAG-AND-POINTER ARRAY-ORIGIN ARRAY-SIZE
				    (%LOGDPB %HEADER-TYPE-ARRAY %%Q-CDR-CODE-WITHIN-TAG
					     DTP-HEADER-I)
				    (%LOGDPB
				      ART-Q
				      (DEFSTORAGE-FIELD-BYTE ARRAY-TYPE-FIELD)
				      (%LOGDPB
					0 (DEFSTORAGE-FIELD-BYTE ARRAY-SHORT-LENGTH-FIELD) 0))
				    0)
      ;; Having flushed the original, dispose of the copy
      (RETURN-ARRAY ARRAY))
    (COND ((= (+ ARRAY-ORIGIN ARRAY-SIZE)
	      (+ (REGION-ORIGIN REGION) (REGION-FREE-POINTER REGION)))
	   (GC-RESET-FREE-POINTER REGION (- ARRAY-ORIGIN (REGION-ORIGIN REGION)))
	   (ARRAY-REGISTER-EVENT)		;In case new array created at same address
	   T)
	  (T NIL))))

(DEFUN ARRAY-TYPE (ARRAY)
  (DECLARE LT:(SIDE-EFFECTS REDUCIBLE))
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (ARRAY-TYPES (ARRAY-TYPE-FIELD ARRAY)))

(DEFUN CL:ARRAY-RANK (ARRAY)
  (DECLARE LT:(SIDE-EFFECTS REDUCIBLE))
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (LET ((HEADER (%POINTER (%MEMORY-READ ARRAY :CYCLE-TYPE %MEMORY-HEADER))))
    (IF (NOT (LDB-TEST ARRAY-LONG-PREFIX-BIT HEADER))
	1
	(LDB ARRAY-LONG-DIMENSIONS-FIELD HEADER))))

;;; Same as L
(DEFUN ARRAY-DIMENSIONS (ARRAY)
  (DECLARE LT:(SIDE-EFFECTS REDUCIBLE))
  (LOOP FOR I FROM 0 BELOW (ARRAY-#-DIMS ARRAY)
	COLLECT (ARRAY-DIMENSION-N (1+ I) ARRAY)))

(DEFUN ARRAY-ELEMENT-SIZE (ARRAY)
  (DECLARE LT:(SIDE-EFFECTS REDUCIBLE))
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (LET ((TYPE (ARRAY-TYPE-FIELD ARRAY)))
    (IF (NOT (= (LDB %%ARRAY-TYPE-ELEMENT-TYPE TYPE) ARRAY-ELEMENT-TYPE-OBJECT))
	(%ARRAY-BITS-PER-ELEMENT TYPE)
	(1- (BYTE-SIZE %%Q-FIXNUM)))))

(DEFUN ARRAY-ELEMENT-BYTE-SIZE (ARRAY)
  (DECLARE LT:(SIDE-EFFECTS REDUCIBLE))
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (%ARRAY-BITS-PER-ELEMENT (ARRAY-TYPE-FIELD ARRAY)))

(DEFUN ARRAY-DISPLACED-P (ARRAY)
  (DECLARE LT:(SIDE-EFFECTS REDUCIBLE))
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (LET ((HEADER (%POINTER (%MEMORY-READ ARRAY :CYCLE-TYPE %MEMORY-HEADER))))
    (AND (LDB-TEST ARRAY-LONG-PREFIX-BIT HEADER)
	 (LDB-TEST ARRAY-DISPLACED-BIT HEADER))))

(DEFUN ARRAY-INDIRECT-P (ARRAY)
  (DECLARE LT:(SIDE-EFFECTS REDUCIBLE))
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (WITH-BLOCK-REGISTERS (1)
    (SETF (%BLOCK-REGISTER 1) ARRAY)
    (LET ((HEADER (%POINTER (%BLOCK-READ 1
					:CYCLE-TYPE %MEMORY-HEADER
					:NO-INCREMENT T
					:PREFETCH NIL))))
      (AND (= (LOGAND (%LOGDPBS 1 ARRAY-LONG-PREFIX-BIT
				1 ARRAY-DISPLACED-BIT
				0)
		      HEADER)
	      (%LOGDPBS 1 ARRAY-LONG-PREFIX-BIT
			1 ARRAY-DISPLACED-BIT
			0))
	   (ARRAYP (DONT-FOLLOW-FORWARDING (ARRAY-INDIRECT-POINTER (%BLOCK-REGISTER 1))))))))

;;; Same as L
(COMPILER:DEFINE-SYNONYM-FUNCTION ARRAY-INDEXED-P ARRAY-INDIRECT-P)

;;; Same as L
(DEFUN ARRAY-INDIRECT-TO (ARRAY)
  (DECLARE LT:(SIDE-EFFECTS REDUCIBLE))
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (WITH-BLOCK-REGISTERS (1)
    (SETF (%BLOCK-REGISTER 1) ARRAY)
    (LET ((HEADER (%POINTER (%BLOCK-READ 1
					:CYCLE-TYPE %MEMORY-HEADER
					:NO-INCREMENT T
					:PREFETCH NIL))))
      (AND (= (LOGAND (%LOGDPBS 1 ARRAY-LONG-PREFIX-BIT
				1 ARRAY-DISPLACED-BIT
				0)
		      HEADER)
	      (%LOGDPBS 1 ARRAY-LONG-PREFIX-BIT
			1 ARRAY-DISPLACED-BIT
			0))
	   (DONT-FOLLOW-FORWARDING (ARRAY-INDIRECT-POINTER (%BLOCK-REGISTER 1)))))))

(DEFUN ARRAY-INDEX-OFFSET (ARRAY)
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (WITH-BLOCK-REGISTERS (1)
    (SETF (%BLOCK-REGISTER 1) ARRAY)
    (LET ((HEADER (%POINTER (%BLOCK-READ 1
					:CYCLE-TYPE %MEMORY-HEADER
					:NO-INCREMENT T
					:PREFETCH NIL))))
      (AND (= (LOGAND (%LOGDPBS 1 ARRAY-LONG-PREFIX-BIT
				1 ARRAY-DISPLACED-BIT
				0)
		      HEADER)
	      (%LOGDPBS 1 ARRAY-LONG-PREFIX-BIT
			1 ARRAY-DISPLACED-BIT
			0))
	   (DONT-FOLLOW-FORWARDING (ARRAY-INDEX-OFFSET-FIELD (%BLOCK-REGISTER 1)))))))

;;; Change what an indirect array points at, or what its offset is.
;;; Multi-dimensional arrays assumed to be conformal if the ranks match,
;;; since the window system calls this.
;--- This function should be flushed and replaced by something that takes keywords,
;--- defaulting from the current state of the array.
(DEFUN CHANGE-INDIRECT-ARRAY (ARRAY TYPE DIMENSIONS DISPLACED-TO DISPLACED-INDEX-OFFSET)
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (WITH-BLOCK-REGISTERS (1)
    (SETF (%BLOCK-REGISTER 1) ARRAY)
    (LET* ((HEADER (%POINTER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER
					  :PREFETCH NIL
					  :NO-INCREMENT T)))
	   (HEADER-LOC (%BLOCK-REGISTER 1))
	   (RANK 0)
	   (NUMBER-OF-ELEMENTS 1)
	   (TYPE-NUMBER))
      (COMPILER:%ERROR-UNLESS (AND (LDB-TEST ARRAY-LONG-PREFIX-BIT HEADER)
				   (LDB-TEST ARRAY-DISPLACED-BIT HEADER))
        (CL:ERROR "~S is not a displaced array" ARRAY))
      (BLOCK CHECK-DIMENSIONS
	(WHEN (CL:TYPEP DIMENSIONS 'CL:FIXNUM)
	  (COMPILER:%ERROR-UNLESS (%UNSIGNED-LESSP DIMENSIONS CL:ARRAY-DIMENSION-LIMIT)
	    (CL:ERROR "The array length, ~s, was not a non-negative integer less than ~a"
		   DIMENSIONS CL:ARRAY-DIMENSION-LIMIT))
	  (SETQ RANK 1)
	  (SETQ NUMBER-OF-ELEMENTS DIMENSIONS)
	  (RETURN-FROM CHECK-DIMENSIONS))
	(COMPILER:%ERROR-UNLESS (CL:TYPEP DIMENSIONS 'LIST)
				(CL:ERROR "The dimensions argument ~s is illegal" DIMENSIONS))
	(DOLIST (DIMENSION DIMENSIONS)
	  (COMPILER:%ERROR-WHEN ( RANK (1- CL:ARRAY-RANK-LIMIT))
				(CL:ERROR "The array rank specified by ~s was not less than ~a"
				       DIMENSIONS CL:ARRAY-RANK-LIMIT))
	  (COMPILER:%ERROR-UNLESS (AND (CL:TYPEP DIMENSION 'CL:FIXNUM)
				       ( DIMENSION 0))
	    (CL:ERROR "The array dimension ~s in ~s was not a non-negative integer less than ~a"
		   DIMENSION DIMENSIONS CL:ARRAY-DIMENSION-LIMIT))
	  (INCF RANK)
	  (SETQ NUMBER-OF-ELEMENTS (* NUMBER-OF-ELEMENTS DIMENSION)))
	(COMPILER:%ERROR-UNLESS (< NUMBER-OF-ELEMENTS CL:ARRAY-TOTAL-SIZE-LIMIT)
	  (CL:ERROR "The specified total size, ~s, from the dimensions ~s, was not less than ~a"
		 NUMBER-OF-ELEMENTS DIMENSIONS CL:ARRAY-TOTAL-SIZE-LIMIT)))
      (COMPILER:%ERROR-UNLESS (CL:TYPECASE TYPE
				(CL:FIXNUM
				  (AND (%UNSIGNED-LESSP
					 TYPE
					 (DEFSYSBYTE-LIMIT-VALUE ARRAY-TYPE-FIELD))
				       (AREF *VALID-ARRAY-TYPE-CODES* TYPE)
				       (SETQ TYPE-NUMBER TYPE)))
				(NULL (SETQ TYPE-NUMBER ART-Q))
				(SYMBOL
				  (AND (CL:MEMBER TYPE *ARRAY-TYPE-CODES*)
				       (SETQ TYPE-NUMBER (CL:SYMBOL-VALUE TYPE))))
				(T NIL))
        (CL:ERROR "~s is not a valid array type" TYPE))
      (UNLESS (= (LDB ARRAY-LONG-DIMENSIONS-FIELD HEADER) RANK)
	(CL:ERROR "Illegal attempt to change the number of dimensions from ~D to ~D"
	       (LDB ARRAY-LONG-DIMENSIONS-FIELD HEADER) RANK))
      (LET ((DISPLACED-CONFORMALLY
	      (AND (ARRAYP DISPLACED-TO)
		   (> RANK 1)
		   (= RANK (CL:ARRAY-RANK
			     (SETQ DISPLACED-TO
				   (FOLLOW-STRUCTURE-FORWARDING
				     DISPLACED-TO))))))
	    (DISPLACED-INDEX-OFFSET (OR DISPLACED-INDEX-OFFSET 0)))
	(BLOCK CHECK-DISPLACED-TO
	  (WHEN (CL:TYPEP DISPLACED-TO
			  '(OR CL:FIXNUM CLI::LOCATIVE CLI::PHYSICAL-ADDRESS))
	    (COMPILER:%ERROR-UNLESS (= DISPLACED-INDEX-OFFSET 0)
	      (CL:ERROR "Only arrays displaced to arrays may have a displaced index offset"))
	    (RETURN-FROM CHECK-DISPLACED-TO))
	  (COMPILER:%ERROR-UNLESS (CL:TYPEP DISPLACED-TO 'CL:ARRAY)
	    (CL:ERROR
	      "An array can only be displaced to another array, an address, or a locative"))
	  (WHEN (= TYPE-NUMBER ART-Q-LIST)
	    (COMPILER:%ERROR-UNLESS (= (ARRAY-TYPE-FIELD DISPLACED-TO) ART-Q-LIST)
	      (CL:ERROR "ART-Q-LIST arrays can only be displaced to ART-Q-LIST arrays"))))
	(SETF (%BLOCK-REGISTER 1) HEADER-LOC)
	(PREPARE-FOR-BLOCK-WRITE)
	(%BLOCK-WRITE 1 (%SET-TAG (%LOGDPB TYPE-NUMBER ARRAY-TYPE-FIELD HEADER)
				  (DPB %HEADER-TYPE-ARRAY %%Q-CDR-CODE-WITHIN-TAG
				       DTP-HEADER-I)))
	(%BLOCK-WRITE 1 NUMBER-OF-ELEMENTS)
	(%BLOCK-WRITE 1 DISPLACED-INDEX-OFFSET)
	(%BLOCK-WRITE 1 DISPLACED-TO)
	(IF (CL:LISTP DIMENSIONS)
	    (LOOP FOR DIM IN DIMENSIONS
		  DOING
	      (%BLOCK-WRITE 1 DIM)
	      (%BLOCK-WRITE 1 1))
	    (%BLOCK-WRITE 1 DIMENSIONS))
	(WHEN (> RANK 1)
	  (IF DISPLACED-CONFORMALLY
	      (%INHERIT-CONFORMAL-MULTIPLIERS ARRAY DISPLACED-TO RANK)
	      (%STORE-NONCONFORMAL-MULTIPLIERS ARRAY RANK)))
	(ARRAY-REGISTER-EVENT)
	ARRAY))))

;;; If you change this, be sure to change array-column-major-index in the appropriate way!
(DEFUN ARRAY-ROW-MAJOR-INDEX (ARRAY &REST SUBSCRIPTS)
  (DECLARE LT:(SIDE-EFFECTS REDUCIBLE))
  (WITH-BLOCK-REGISTERS (1)
    (LOOP NAMED ARRAY-ROW-MAJOR-INDEX DOING
      (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
      (SETF (%BLOCK-REGISTER 1) ARRAY)
      (LET ((HEADER (%POINTER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER :NO-INCREMENT T
					   :PREFETCH NIL)))
	    (SUBSCRIPTS-LEFT SUBSCRIPTS))
	(IF (NOT (LDB-TEST ARRAY-LONG-PREFIX-BIT HEADER))
	    (LET ((SUBSCRIPT (POP SUBSCRIPTS-LEFT)))
	      (COMPILER:%ERROR-WHEN SUBSCRIPTS-LEFT
	        (SIGNAL-PROCEED-CASE ((NEW-ARRAY)
				      'ARRAY-WRONG-NUMBER-OF-DIMENSIONS
				      ':FUNCTION 'ARRAY-ROW-MAJOR-INDEX
				      ':ARRAY ARRAY
				      ':DIMENSIONS-EXPECTED (LENGTH SUBSCRIPTS)
				      ':DIMENSIONS-GIVEN 1)
		  (:NEW-ARRAY (SETQ ARRAY NEW-ARRAY))))
	      (COMPILER:%ERROR-UNLESS (%UNSIGNED-LESSP
					SUBSCRIPT
					(LDB ARRAY-SHORT-LENGTH-FIELD HEADER))
		(SIGNAL-PROCEED-CASE ((NEW-INDEX)
				      'SUBSCRIPT-OUT-OF-BOUNDS
				      ':FUNCTION 'ARRAY-ROW-MAJOR-INDEX
				      ':OBJECT ARRAY
				      ':SUBSCRIPT-USED SUBSCRIPTS
				      ':SUBSCRIPT-LIMIT (ARRAY-DIMENSIONS ARRAY))
		  (:NEW-SUBSCRIPT
		    (SETQ SUBSCRIPTS (LIST NEW-INDEX)))))
	      (RETURN-FROM ARRAY-ROW-MAJOR-INDEX SUBSCRIPT))
	    (LET ((OFFSET 0)
		  (RANK-LEFT (LDB ARRAY-LONG-DIMENSIONS-FIELD HEADER)))
	      (SETF (%BLOCK-REGISTER 1)
		    (%POINTER-PLUS (%BLOCK-REGISTER 1) (DEFSTORAGE-SIZE ARRAY)))
	      (LOOP NAMED COMPUTE-OFFSET DOING
		(WHEN (NULL SUBSCRIPTS-LEFT)
		  (COMPILER:%ERROR-UNLESS (= RANK-LEFT 0)
		    (SIGNAL-PROCEED-CASE ((NEW-ARRAY)
					  'ARRAY-WRONG-NUMBER-OF-DIMENSIONS
					  ':FUNCTION 'ARRAY-ROW-MAJOR-INDEX
					  ':ARRAY ARRAY
					  ':DIMENSIONS-EXPECTED (LENGTH SUBSCRIPTS)
					  :DIMENSIONS-GIVEN
					     (LDB ARRAY-LONG-DIMENSIONS-FIELD HEADER))
		      (:NEW-ARRAY
			(SETQ ARRAY NEW-ARRAY)
			(RETURN-FROM COMPUTE-OFFSET))))
		  (RETURN-FROM ARRAY-ROW-MAJOR-INDEX OFFSET))
		(COMPILER:%ERROR-WHEN (= RANK-LEFT 0)
		  (SIGNAL-PROCEED-CASE ((NEW-ARRAY)
					'ARRAY-WRONG-NUMBER-OF-DIMENSIONS
					':FUNCTION 'ARRAY-ROW-MAJOR-INDEX
					':ARRAY ARRAY
					':DIMENSIONS-EXPECTED (LENGTH SUBSCRIPTS)
					:DIMENSIONS-GIVEN
					   (LDB ARRAY-LONG-DIMENSIONS-FIELD HEADER))
		    (:NEW-ARRAY
		      (SETQ ARRAY NEW-ARRAY)
		      (RETURN-FROM COMPUTE-OFFSET))))
		(LET ((SUBSCRIPT (POP SUBSCRIPTS-LEFT))
		      (DIM (%BLOCK-READ 1))
		      (MULT (%BLOCK-READ 1)))
		  (DECF RANK-LEFT)
		  (COMPILER:%ERROR-UNLESS (%UNSIGNED-LESSP SUBSCRIPT DIM)
		    (LET ((CASE-AND-SUBSCRIPTS
			    (MULTIPLE-VALUE-LIST
			      (SIGNAL 'SUBSCRIPT-OUT-OF-BOUNDS
				      :FUNCTION 'ARRAY-ROW-MAJOR-INDEX
				      :OBJECT ARRAY
				      :SUBSCRIPT-USED SUBSCRIPTS
				      :SUBSCRIPT-LIMIT (ARRAY-DIMENSIONS ARRAY)
				      :PROCEED-TYPES '(:NEW-SUBSCRIPT)))))
		      (SETQ SUBSCRIPTS (CDR CASE-AND-SUBSCRIPTS))
		      (RETURN-FROM COMPUTE-OFFSET)))
		  (INCF OFFSET (* SUBSCRIPT MULT))))))))))

(DEFUN MAKE-ARRAY-INTERNAL
       (DIMENSIONS TYPE AREA
	LEADER-LIST LEADER-LENGTH FILL-POINTER
	DISPLACED-TO DISPLACED-INDEX-OFFSET
	NAMED-STRUCTURE-SYMBOL INITIAL-VALUE
	DISPLACED-CONFORMALLY ADJUSTABLE)
  (LET ((RANK 0)
	(NUMBER-OF-ELEMENTS 1)
	(TYPE-NUMBER TYPE)
	(LLENGTH (OR LEADER-LENGTH 0))
	(LLIST LEADER-LIST)
	(LEADER-LIST-LENGTH 0)
	(ARRAY-LEADER-0)
	(ARRAY-LEADER-1)
	(DISPLACED-INDEX-OFFSET (OR DISPLACED-INDEX-OFFSET 0)))
    (BLOCK CHECK-DIMENSIONS
      (WHEN (CL:TYPEP DIMENSIONS 'CL:FIXNUM)
	(COMPILER:%ERROR-UNLESS (%UNSIGNED-LESSP DIMENSIONS CL:ARRAY-DIMENSION-LIMIT)
	 (CL:ERROR "The array length, ~s, was not a non-negative integer less than ~a"
		DIMENSIONS CL:ARRAY-DIMENSION-LIMIT))
	(SETQ RANK 1)
	(SETQ NUMBER-OF-ELEMENTS DIMENSIONS)
	(RETURN-FROM CHECK-DIMENSIONS))
      (COMPILER:%ERROR-UNLESS (CL:TYPEP DIMENSIONS 'LIST)
        (CL:ERROR "The dimensions argument ~s is illegal" DIMENSIONS))
      (DOLIST (DIMENSION DIMENSIONS)
	(COMPILER:%ERROR-WHEN ( RANK (1- CL:ARRAY-RANK-LIMIT))
	  (CL:ERROR "The array rank specified by ~s was not less than ~a"
		 DIMENSIONS CL:ARRAY-RANK-LIMIT))
	(COMPILER:%ERROR-UNLESS (AND (CL:TYPEP DIMENSION 'CL:FIXNUM)
				     ( DIMENSION 0))
	  (CL:ERROR "The array dimension ~s in ~s was not a non-negative integer less than ~a"
		 DIMENSION DIMENSIONS CL:ARRAY-DIMENSION-LIMIT))
	(INCF RANK)
	(SETQ NUMBER-OF-ELEMENTS (* NUMBER-OF-ELEMENTS DIMENSION)))
      (COMPILER:%ERROR-UNLESS (< NUMBER-OF-ELEMENTS CL:ARRAY-TOTAL-SIZE-LIMIT)
        (CL:ERROR "The specified total size, ~s, from the dimensions ~s, was not less than ~a"
	       NUMBER-OF-ELEMENTS DIMENSIONS CL:ARRAY-TOTAL-SIZE-LIMIT)))
    (COMPILER:%ERROR-UNLESS (CL:TYPECASE TYPE
			      (CL:FIXNUM
				(AND (%UNSIGNED-LESSP
				       TYPE (DEFSYSBYTE-LIMIT-VALUE ARRAY-TYPE-FIELD))
				     (AREF *VALID-ARRAY-TYPE-CODES* TYPE)))
			      (NULL (SETQ TYPE-NUMBER ART-Q))
			      (SYMBOL
				(AND (CL:MEMBER TYPE *ARRAY-TYPE-CODES*)
				     (SETQ TYPE-NUMBER (CL:SYMBOL-VALUE TYPE))))
			      (T NIL))
      (CL:ERROR "~s is not a valid array type" TYPE))
    (COMPILER:%ERROR-WHEN (AND ( RANK 1)
			       (= TYPE-NUMBER ART-Q-LIST))
      (CL:ERROR "ART-Q-LIST arrays must have rank 1"))
    (BLOCK CHECK-DISPLACED-TO
      (WHEN (CL:TYPEP DISPLACED-TO '(OR NULL CL:FIXNUM CLI::LOCATIVE CLI::PHYSICAL-ADDRESS))
	(COMPILER:%ERROR-UNLESS (= DISPLACED-INDEX-OFFSET 0)
	  (CL:ERROR "Only arrays displaced to arrays may have a displaced index offset"))
	(COMPILER:%ERROR-WHEN DISPLACED-CONFORMALLY
	  (CL:ERROR "Only arrays displaced to arrays may be displaced conformally"))
	(RETURN-FROM CHECK-DISPLACED-TO))
      (COMPILER:%ERROR-UNLESS (CL:TYPEP DISPLACED-TO 'CL:ARRAY)
        (CL:ERROR "An array can only be displaced to another array, an address, or a locative"))
      (SETQ DISPLACED-TO (FOLLOW-STRUCTURE-FORWARDING DISPLACED-TO))
      (WHEN (= TYPE-NUMBER ART-Q-LIST)
	(COMPILER:%ERROR-UNLESS (= (ARRAY-TYPE-FIELD DISPLACED-TO) ART-Q-LIST)
	  (CL:ERROR "ART-Q-LIST arrays can only be displaced to ART-Q-LIST arrays")))
      (WHEN DISPLACED-CONFORMALLY
	(COMPILER:%ERROR-UNLESS (= RANK (CL:ARRAY-RANK DISPLACED-TO))
	  (CL:ERROR
	    "Conformal displacement to the array ~s is not meaningful because it has ~
             rank ~s, which is incompatible with the rank specified for this array, ~s. ~
             The ranks of the two arrays must be the same"
	    DISPLACED-TO (CL:ARRAY-RANK DISPLACED-TO) RANK))))
    (COMPILER:%ERROR-UNLESS (CL:TYPEP LEADER-LIST '(OR NULL LIST))
      (CL:ERROR "The leader list must be NIL or a list"))
    (WHEN LEADER-LENGTH
      (COMPILER:%ERROR-UNLESS (AND (CL:TYPEP LEADER-LENGTH 'CL:FIXNUM)
				   (%UNSIGNED-LESSP
				     (1- LEADER-LENGTH)
				     (1- (DEFSYSBYTE-LIMIT-VALUE ARRAY-LEADER-LENGTH-FIELD))))
        (CL:ERROR "The leader length ~s is not NIL or a positive integer less than ~a"
	       LEADER-LENGTH (DEFSYSBYTE-LIMIT-VALUE ARRAY-LEADER-LENGTH-FIELD))))
    ;; The most common case of a leader-list seems to be a one or two
    ;; element list.  Handle these cases specially.
    (WHEN LLIST
      (SETQ ARRAY-LEADER-0 (POP LLIST))
      (INCF LEADER-LIST-LENGTH)
      (WHEN LLIST
	(SETQ ARRAY-LEADER-1 (POP LLIST))
	(INCF LEADER-LIST-LENGTH)
	(WHEN LLIST
	  (INCF LEADER-LIST-LENGTH (LENGTH LLIST)))))
    (WHEN FILL-POINTER
      (COMPILER:%ERROR-UNLESS (= RANK 1)
        (CL:ERROR "Only arrays of rank 1 may have fill-pointers"))
      (SETQ LLENGTH (MAX LLENGTH 1))
      (SETQ ARRAY-LEADER-0
	    (BLOCK FILL-POINTER
	      (WHEN (CL:TYPEP FILL-POINTER 'CL:INTEGER)
		(RETURN-FROM FILL-POINTER FILL-POINTER))
	      (COMPILER:%ERROR-UNLESS (EQ FILL-POINTER T)
	        (CL:ERROR "The fill-pointer must be T, NIL, or a integer"))
	      NUMBER-OF-ELEMENTS)))
    (IF LEADER-LENGTH
	(PROGN
	  (COMPILER:%ERROR-UNLESS (AND (CL:TYPEP LEADER-LENGTH 'CL:FIXNUM)
				       (%UNSIGNED-LESSP
					 (1- LEADER-LENGTH)
					 (1- (DEFSYSBYTE-LIMIT-VALUE
					       ARRAY-LEADER-LENGTH-FIELD))))
	    (CL:ERROR "The leader length ~s is not NIL or a positive integer less than ~a"
		   LEADER-LENGTH (DEFSYSBYTE-LIMIT-VALUE ARRAY-LEADER-LENGTH-FIELD)))
	  (COMPILER:%ERROR-UNLESS ( LEADER-LENGTH LEADER-LIST-LENGTH)
	    (CL:ERROR "The leader length is too short for the leader list")))
	(SETQ LLENGTH (MAX LLENGTH LEADER-LIST-LENGTH)))
    (WHEN NAMED-STRUCTURE-SYMBOL
      (COMPILER:%ERROR-UNLESS (CL:TYPEP NAMED-STRUCTURE-SYMBOL 'SYMBOL)
        (CL:ERROR "The named structure symbol must be a symbol"))
      (WHEN (OR (NOT (ZEROP LLENGTH))
		( RANK 1)
		(NOT (EQL (%LOGLDB %%ARRAY-TYPE-ELEMENT-TYPE TYPE-NUMBER)
			  ARRAY-ELEMENT-TYPE-OBJECT))
		DISPLACED-TO
		(ZEROP NUMBER-OF-ELEMENTS))
	;; It has to go in the leader
	(SETQ ARRAY-LEADER-1 NAMED-STRUCTURE-SYMBOL)
	(SETQ LLENGTH (MAX LLENGTH 2))))
    (WITH-BLOCK-REGISTERS (1)
      (LET* ((INITIAL-WORD
	       (IF (NULL INITIAL-VALUE)
		   (ARRAY-NULL-WORD TYPE-NUMBER)
		   (BLOCK ARRAY-INITIAL-WORD
		     (LET ((VALUE
			     (SELECT (%LOGLDB %%ARRAY-TYPE-ELEMENT-TYPE TYPE-NUMBER)
			       (ARRAY-ELEMENT-TYPE-FIXNUM
				(COMPILER:%ERROR-UNLESS (CL:TYPEP INITIAL-VALUE 'CL:FIXNUM)
				  (CL:ERROR
				    "Initial value ~s for a fixnum array was not a fixnum"
				    INITIAL-VALUE))
				INITIAL-VALUE)
			       (ARRAY-ELEMENT-TYPE-CHARACTER
				(COMPILER:%ERROR-UNLESS (CL:TYPEP INITIAL-VALUE 'CHARACTER)
				  (CL:ERROR
				    "Initial value ~s for a string array is not a character"
				    INITIAL-VALUE))
				(IF (= TYPE-NUMBER SYS:ART-STRING)
				    (PROGN
				      (COMPILER:%ERROR-WHEN (CHAR-FAT-P INITIAL-VALUE)
				        (FERROR "Initial value ~s is not a thin character"
						INITIAL-VALUE))
				      (CHAR-SUBINDEX INITIAL-VALUE))
				    (%POINTER INITIAL-VALUE)))
			       (ARRAY-ELEMENT-TYPE-BOOLEAN
				(RETURN-FROM ARRAY-INITIAL-WORD
				  (IF INITIAL-VALUE -1 0)))
			       (OTHERWISE	;ARRAY-ELEMENT-TYPE-OBJECT	
				(RETURN-FROM ARRAY-INITIAL-WORD INITIAL-VALUE)))))
		       (TAGBODY (SELECT (%LOGLDB %%ARRAY-TYPE-BYTE-PACKING TYPE-NUMBER)
				  (0 (GO DONE))
				  (1 (GO L16))
				  (2 (GO L8))
				  (3 (GO L4))
				  (4 (GO L2)))
				(SETQ VALUE (%LOGDPB VALUE (BYTE 1. 1.) VALUE))
			     L2 (SETQ VALUE (%LOGDPB VALUE (BYTE 2. 2.) VALUE))
			     L4 (SETQ VALUE (%LOGDPB VALUE (BYTE 4. 4.) VALUE))
			     L8 (SETQ VALUE (%LOGDPB VALUE (BYTE 8. 8.) VALUE))
			     L16 (SETQ VALUE (%LOGDPB VALUE (BYTE 16. 16.) VALUE))
			     DONE)
		       VALUE))))
	      (WORD-LENGTH (IF DISPLACED-TO
			       0
			       (SI:ARRAY-ELEMENT-WORDS NUMBER-OF-ELEMENTS TYPE-NUMBER)))
	      (SIMPLEP (AND (NULL ADJUSTABLE)	;CLTL-1
			    (= RANK 1)
			    (NULL DISPLACED-TO)
			    (< NUMBER-OF-ELEMENTS
			       (DEFSYSBYTE-LIMIT-VALUE ARRAY-SHORT-LENGTH-FIELD))))
	      (LEADER-SIZE (IF (ZEROP LLENGTH) 0 (1+ LLENGTH)))
	      (ARRAY (%SET-TAG (%POINTER-PLUS (%ALLOCATE-STRUCTURE-BLOCK
						(OR AREA *DEFAULT-CONS-AREA*)
						(+ LEADER-SIZE
						   (IF SIMPLEP
						       1
						       (+ (* RANK 2)
							  (DEFSTORAGE-SIZE SYS:ARRAY)))
						   WORD-LENGTH))
					      LEADER-SIZE)
			       (IF (AND (= RANK 1)
					(= (LDB %%ARRAY-TYPE-ELEMENT-TYPE TYPE-NUMBER)
					   ARRAY-ELEMENT-TYPE-CHARACTER))
				   DTP-STRING
				   DTP-ARRAY))))
	(SI:PREPARE-FOR-BLOCK-WRITE)
	(UNLESS (ZEROP LLENGTH)
	  ;; Write the array leader.  If there is a LEADER-LIST which is longer than 2
	  ;; elements, don't initialize it until later.
	  (LET ((INITIAL-WORD NIL))
	    (%BLOCK-WRITE
	      1
	      (%SET-TAG ARRAY (DPB %HEADER-TYPE-LEADER %%Q-CDR-CODE-WITHIN-TAG DTP-HEADER-P)))
	    (WHEN (> LLENGTH 1)
	      (WHEN (> LLENGTH 2)
		(LET ((N (- LLENGTH 2)))
		  (WHEN (LDB-TEST (BYTE 1 0) N)
		    (%BLOCK-WRITE 1 INITIAL-WORD))
		  (WHEN (LDB-TEST (BYTE 1 1) N)
		    (%BLOCK-WRITE 1 INITIAL-WORD)
		    (%BLOCK-WRITE 1 INITIAL-WORD))
		  (WHEN (> N 3.)
		    (SETQ N (%FIXNUM-FLOOR N 4.))
		    (LOOP DOING
		      (%BLOCK-WRITE 1 INITIAL-WORD)
		      (%BLOCK-WRITE 1 INITIAL-WORD)
		      (%BLOCK-WRITE 1 INITIAL-WORD)
		      (%BLOCK-WRITE 1 INITIAL-WORD)
		      (DECF N 1)
		      (UNLESS (PLUSP N)
			(RETURN))))))
	      (%BLOCK-WRITE 1 ARRAY-LEADER-1))
	    (%BLOCK-WRITE 1 ARRAY-LEADER-0)))
	;; Now write the array header
	(%BLOCK-WRITE
	  1
	  (%SET-TAG
	    (%LOGDPBS TYPE-NUMBER ARRAY-TYPE-FIELD
		      LLENGTH ARRAY-LEADER-LENGTH-FIELD
		      (IF NAMED-STRUCTURE-SYMBOL 1 0) ARRAY-NAMED-STRUCTURE-BIT
		      (IF SIMPLEP
			  NUMBER-OF-ELEMENTS
			  (%LOGDPBS (IF DISPLACED-TO 1 0) ARRAY-DISPLACED-BIT
				    RANK ARRAY-LONG-DIMENSIONS-FIELD
				    1 ARRAY-LONG-PREFIX-BIT 0)))
	    (DPB %HEADER-TYPE-ARRAY %%Q-CDR-CODE-WITHIN-TAG DTP-HEADER-I)))
	(UNLESS SIMPLEP
	  (%BLOCK-WRITE 1 NUMBER-OF-ELEMENTS)
	  (%BLOCK-WRITE 1 DISPLACED-INDEX-OFFSET)
	  (%BLOCK-WRITE 1 (OR DISPLACED-TO
			      (%POINTER-PLUS
				(%SET-TAG ARRAY DTP-LOCATIVE)
				(IF (ZEROP NUMBER-OF-ELEMENTS)
				    0
				    (+ (* RANK 2) (DEFSTORAGE-SIZE SYS:ARRAY))))))
	  (COND ((= RANK 1)
		 (%BLOCK-WRITE 1 NUMBER-OF-ELEMENTS)
		 (%BLOCK-WRITE 1 1))
		(T
		 (LOOP FOR DIM IN DIMENSIONS DOING
		   (%BLOCK-WRITE 1 DIM)
		   (%BLOCK-WRITE 1 1)))))
	(WHEN (AND NAMED-STRUCTURE-SYMBOL (ZEROP LLENGTH))
	  (%BLOCK-WRITE 1 NAMED-STRUCTURE-SYMBOL)
	  (DECF WORD-LENGTH))
	(COND ((< (* WORD-LENGTH 2)
		  (%FIXNUM-MULTIPLY
		    (+ STORAGE:*COUNT-FLUSHABLE-PAGES* STORAGE:*COUNT-NORMAL-PAGES*)
		    SYS:PAGE-SIZE))
	       (LET ((WORD-LENGTH WORD-LENGTH))
		 (WHEN (LDB-TEST (BYTE 1 0) WORD-LENGTH)
		   (%BLOCK-WRITE 1 INITIAL-WORD))
		 (WHEN (LDB-TEST (BYTE 1 1) WORD-LENGTH)
		   (%BLOCK-WRITE 1 INITIAL-WORD)
		   (%BLOCK-WRITE 1 INITIAL-WORD))
		 (WHEN (LDB-TEST (BYTE 1 2) WORD-LENGTH)
		   (%BLOCK-WRITE 1 INITIAL-WORD)
		   (%BLOCK-WRITE 1 INITIAL-WORD)
		   (%BLOCK-WRITE 1 INITIAL-WORD)
		   (%BLOCK-WRITE 1 INITIAL-WORD))
		 (WHEN (> WORD-LENGTH 7.)
		   (SETF (%TRAP-MODE) (LDB %%CR.TRAP-MODE (%SAVED-CONTROL-REGISTER)))
		   (SETQ WORD-LENGTH (%FIXNUM-FLOOR WORD-LENGTH 8.))
		   (LOOP DOING
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (DECF WORD-LENGTH)
		     (UNLESS (PLUSP WORD-LENGTH) (RETURN))))))		     
	      (T
	       (LET* ((ADDRESS (%POINTER (%BLOCK-REGISTER 1)))
		      (LIMIT (%POINTER-PLUS ADDRESS WORD-LENGTH))
		      (WHACK-SIZE (* 40. SYS:PAGE-SIZE)))
		 (SI:SCANNING-THROUGH-MEMORY ZL:MAKE-ARRAY (ADDRESS LIMIT 40.)
		   (LOOP WHILE (%POINTER-LESSP ADDRESS LIMIT)
			 AS THIS-TIME = (MIN (%POINTER-DIFFERENCE LIMIT ADDRESS) WHACK-SIZE)
			 DO
		     (SI:CHECK-MEMORY-SCAN ZL:MAKE-ARRAY ADDRESS)
		     (%BLOCK-STORE-CDR-AND-CONTENTS ADDRESS THIS-TIME CDR-NEXT INITIAL-WORD 0)
		     (SETF ADDRESS (%POINTER-PLUS ADDRESS THIS-TIME)))))))
	
	(WHEN (AND (= TYPE-NUMBER ART-Q-LIST)
		   (NOT (= WORD-LENGTH 0))
		   (NOT DISPLACED-TO))
	  (SI:%SET-CDR-CODE-NIL (LOCF INITIAL-WORD))
	  (%MEMORY-WRITE (%POINTER-PLUS ARRAY
					(IF SIMPLEP
					    WORD-LENGTH
					    (+ (* RANK 2)
					       (1- (DEFSTORAGE-SIZE SYS:ARRAY))
					       WORD-LENGTH)))
			 INITIAL-WORD))
	(WHEN LLIST
	  (LOOP WHILE LLIST
		FOR I FROM 2
		DOING
	    (SETF (ARRAY-LEADER ARRAY I) (POP LLIST))))
	(WHEN (> RANK 1)
	  (IF DISPLACED-CONFORMALLY
	      (SI:%INHERIT-CONFORMAL-MULTIPLIERS ARRAY DISPLACED-TO RANK)
	      (SI:%STORE-NONCONFORMAL-MULTIPLIERS ARRAY RANK)))
	ARRAY))))

(DEFUN ARRAY-INITIAL-WORD (CONTROL-WORD
			   &OPTIONAL
			   (INITIAL-VALUE NIL INITIAL-VALUE-P))
  (IF (NULL INITIAL-VALUE-P)
      (ARRAY-NULL-WORD (ROT (LDB (BYTE 5. 27.) CONTROL-WORD) 1))
      (BLOCK ARRAY-INITIAL-WORD
	(LET* ((BYTE-PACKING (%LOGLDB ARRAY-REGISTER-BYTE-PACKING CONTROL-WORD))
	       (VALUE
		 (SELECT (%LOGLDB ARRAY-REGISTER-ELEMENT-TYPE CONTROL-WORD)
		   (ARRAY-ELEMENT-TYPE-FIXNUM
		    (COMPILER:%ERROR-UNLESS (CL:TYPEP INITIAL-VALUE 'CL:FIXNUM)
		      (ERROR
			"Initial value ~s for a fixnum array was not a fixnum"
			INITIAL-VALUE))
		    INITIAL-VALUE)
		   (ARRAY-ELEMENT-TYPE-CHARACTER
		    (COMPILER:%ERROR-UNLESS (CL:TYPEP INITIAL-VALUE 'CHARACTER)
		      (ERROR
			"Initial value ~s for a string array is not a character"
			INITIAL-VALUE))
		    (IF (= BYTE-PACKING 0)
			(%POINTER INITIAL-VALUE)
			(PROGN
			  (COMPILER:%ERROR-WHEN (CHAR-FAT-P INITIAL-VALUE)
			    (FERROR "Initial value ~s is not a thin character" INITIAL-VALUE))
			  (CHAR-SUBINDEX INITIAL-VALUE))))
		   (ARRAY-ELEMENT-TYPE-BOOLEAN
		    (RETURN-FROM ARRAY-INITIAL-WORD
		      (IF INITIAL-VALUE -1 0)))
		   (OTHERWISE			;ARRAY-ELEMENT-TYPE-OBJECT	
		    (RETURN-FROM ARRAY-INITIAL-WORD INITIAL-VALUE)))))
	  (TAGBODY (SELECT BYTE-PACKING
		     (0 (GO DONE))
		     (1 (GO L16))
		     (2 (GO L8))
		     (3 (GO L4))
		     (4 (GO L2)))
		   (SETQ VALUE (%LOGDPB VALUE (BYTE 1. 1.) VALUE))
		L2 (SETQ VALUE (%LOGDPB VALUE (BYTE 2. 2.) VALUE))
		L4 (SETQ VALUE (%LOGDPB VALUE (BYTE 4. 4.) VALUE))
		L8 (SETQ VALUE (%LOGDPB VALUE (BYTE 8. 8.) VALUE))
		L16 (SETQ VALUE (%LOGDPB VALUE (BYTE 16. 16.) VALUE))
		DONE)
	  VALUE))))

(DEFUN MAKE-ARRAY
       (DIMENSIONS &REST OPTIONS 
	;; &key
	&AUX
	(TYPE ART-Q) AREA
	LEADER-LIST LEADER-LENGTH FILL-POINTER
	DISPLACED-TO DISPLACED-INDEX-OFFSET
	NAMED-STRUCTURE-SYMBOL INITIAL-VALUE
	DISPLACED-CONFORMALLY ADJUSTABLE)
  (DECLARE (ARGLIST DIMENSIONS &KEY AREA TYPE DISPLACED-TO DISPLACED-INDEX-OFFSET
		    DISPLACED-CONFORMALLY ADJUSTABLE LEADER-LIST LEADER-LENGTH
		    NAMED-STRUCTURE-SYMBOL INITIAL-VALUE FILL-POINTER)
	   LT:(SIDE-EFFECTS READER))
  ;(APPLY #'CL-USER::LOG-MAKE-ARRAY-ENTRY DIMENSIONS OPTIONS)
  ;; Old format is no longer supported.  Only keyword format.  It is
  ;; believed that it is faster to scan a sparse keyword list by hand
  ;; than to do an n*m take-keyword-argument search.  While probably
  ;; true, this makes it not really a CL-compatible keyword list (grabs
  ;; last keyword value, not first).
  (COMPILER:%ERROR-WHEN (ODDP (LENGTH OPTIONS))
      (FERROR "Odd-length options list: ~S" OPTIONS))
  ;; Parse options
  (DO ((OPTIONS OPTIONS (CDDR OPTIONS)))
      ((NULL OPTIONS))
    (LET ((VALUE (SECOND OPTIONS)))
      (CL:CASE (FIRST OPTIONS)
	;; This is an attempt to optimize the search based on some metering
	(:LEADER-LENGTH (SETQ LEADER-LENGTH VALUE))
	(:TYPE (SETQ TYPE VALUE))
	(:AREA (SETQ AREA VALUE))
	(:NAMED-STRUCTURE-SYMBOL (SETQ NAMED-STRUCTURE-SYMBOL VALUE))
	(:FILL-POINTER (SETQ FILL-POINTER VALUE))
	(:LEADER-LIST (SETQ LEADER-LIST VALUE))
	(:DISPLACED-TO (SETQ DISPLACED-TO VALUE))
	(:DISPLACED-INDEX-OFFSET (SETQ DISPLACED-INDEX-OFFSET VALUE))
	(:INITIAL-VALUE (SETQ INITIAL-VALUE VALUE))
	(:DISPLACED-CONFORMALLY (SETQ DISPLACED-CONFORMALLY VALUE))
	(:ADJUSTABLE (SETQ ADJUSTABLE VALUE))
	(OTHERWISE
	  (ERROR "~S is not a known MAKE-ARRAY keyword." (FIRST OPTIONS))))))
  (MAKE-ARRAY-INTERNAL DIMENSIONS TYPE AREA LEADER-LIST LEADER-LENGTH FILL-POINTER
		       DISPLACED-TO DISPLACED-INDEX-OFFSET NAMED-STRUCTURE-SYMBOL
		       INITIAL-VALUE DISPLACED-CONFORMALLY ADJUSTABLE))

;;; Some dynamic metering has shown that the following are the common cases
;;; of make-array (not necessarily in order of use, because style will
;;; dictate usage).
;;;  (1)  Length only: TV:SCROLL-MAKE-ENTRY, when parsing scroll lists.  Zmail
;;;       uses this a lot.  Also, zwei:complete-string
;;;  (2)  leader-length: TV:SCROLL-PARSE-ITEM.
;;;  (3)  type: usually to create simple strings
;;;  (4)  type and area: substring
;;;  (5)  named-structure-symbol: simple uses of defstruct (e.g., compiler).
;;;  (6)  type, leader-length and area: zwei:create-line
;;;  (7)  type, leader-list and area: format and format:format-parse-clauses
;;;  (8)  type and leader-length: tv:quick-fixnum-string (from
;;;       display-file-transfer), buffered :LINE-IN.
;;;  (9)  type and fill-pointer: tv:scroll-make-entry, stream-copy-until-eof
;;;       (should be using a resource)
;;; 
;;; Considerations for writing optimizers:
;;; 
;;;  (a) Since area does not affect the format of an array, it is essentially
;;;      free.  Therefore, it is given as the last optional argument to all
;;;      optimizers.
;;;  
;;;  (b) Type alone has no interactions, and is easily implemented.  This
;;;      covers (3) and (4).
;;;  
;;;  (c) Named-structure-symbol is free if you don't have to worry about type
;;;      and possibility of a leader.  I.e., it is the first element of an
;;;      ART-Q.  [This is the case for many defstructs, but isn't always.]
;;;      This covers case (5).  It also covers case (1).  (1) could also be
;;;      covered by (b), but it is faster if done here.
;;;  
;;;  (d) leader-length, leader-list and fill-pointer all interact with each
;;;      other in some small way, so they should be grouped a bit.  Toss in
;;;      type and this covers (2), (6), (7), (8) and (9).
;;; 
;;; All optimizers should check all their arguments and call out to
;;; make-array (using FUNCALL to avoid circular optimization) if the
;;; optimizer failed.

;;; Not to be called by users; only compiler knows about this
(DEFUN SIMPLE-MAKE-ARRAY-NSS-AREA
       (DIMENSIONS &OPTIONAL NAMED-STRUCTURE-SYMBOL AREA)
  ;; If there is any exceptional condition, escape to MAKE-ARRAY
  (COMPILER:%ERROR-UNLESS (AND (CL:TYPEP DIMENSIONS 'CL:FIXNUM)
			       (%UNSIGNED-LESSP
				 DIMENSIONS
				 (DEFSYSBYTE-LIMIT-VALUE ARRAY-SHORT-LENGTH-FIELD))
			       ;; This would require a leader
			       (NOT (AND NAMED-STRUCTURE-SYMBOL
					 (ZEROP DIMENSIONS))))
     (RETURN-FROM SIMPLE-MAKE-ARRAY-NSS-AREA
       (MAKE-ARRAY-INTERNAL DIMENSIONS ART-Q AREA NIL NIL NIL NIL NIL NAMED-STRUCTURE-SYMBOL
			    NIL NIL NIL)))
  ;; Just a simple array
  (LET ((INITIAL-WORD NIL))
    (WITH-BLOCK-REGISTERS (1)
      (%SET-TAG
	(PROG1 (%ALLOCATE-STRUCTURE-BLOCK (OR AREA *DEFAULT-CONS-AREA*) (1+ DIMENSIONS))
	       (PREPARE-FOR-BLOCK-WRITE)
	       (%BLOCK-WRITE 1
			     (%SET-TAG (%LOGDPB DIMENSIONS ARRAY-SHORT-LENGTH-FIELD
						(IF NAMED-STRUCTURE-SYMBOL
						    (%LOGDPBS 1 ARRAY-NAMED-STRUCTURE-BIT
							      ART-Q ARRAY-TYPE-FIELD
							      0)
						    (%LOGDPBS ART-Q ARRAY-TYPE-FIELD 0)))
				       (DPB %HEADER-TYPE-ARRAY %%Q-CDR-CODE-WITHIN-TAG
					    DTP-HEADER-I)))
	       (UNLESS (ZEROP DIMENSIONS)
		 (%BLOCK-WRITE 1 NAMED-STRUCTURE-SYMBOL)
		 (LET ((WORD-LENGTH (1- DIMENSIONS)))	;One already pushed
		   (WHEN (LDB-TEST (BYTE 1 0) WORD-LENGTH)
		     (%BLOCK-WRITE 1 INITIAL-WORD))
		   (WHEN (LDB-TEST (BYTE 1 1) WORD-LENGTH)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD))
		   (WHEN (LDB-TEST (BYTE 1 2) WORD-LENGTH)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD))
		   (WHEN (> WORD-LENGTH 7.)
		     (SETF (%TRAP-MODE) (LDB %%CR.TRAP-MODE (%SAVED-CONTROL-REGISTER)))
		     (SETQ WORD-LENGTH (%FIXNUM-FLOOR WORD-LENGTH 8.))
		     (LOOP DOING
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (DECF WORD-LENGTH)
		       (UNLESS (PLUSP WORD-LENGTH) (RETURN)))))))
	DTP-ARRAY))))

;;; Not to be called by users; only compiler knows about this.
(DEFUN SIMPLE-MAKE-ARRAY-TYPE-AREA (DIMENSIONS TYPE &OPTIONAL AREA)
  (LET ((TYPE-NUMBER TYPE))
    (COMPILER:%ERROR-UNLESS (AND (CL:TYPECASE TYPE
				   (CL:FIXNUM
				     (AND
				       (%UNSIGNED-LESSP
					 TYPE (DEFSYSBYTE-LIMIT-VALUE ARRAY-TYPE-FIELD))
				       (AREF *VALID-ARRAY-TYPE-CODES* TYPE)))
				   (NULL (SETQ TYPE-NUMBER ART-Q))
				   (SYMBOL
				     (WHEN (CL:MEMBER TYPE VALID-ARRAY-TYPE-CODES)
				       (SETQ TYPE-NUMBER (CL:SYMBOL-VALUE TYPE))))
				   (OTHERWISE NIL))
				 (CL:TYPEP DIMENSIONS 'CL:FIXNUM)
				 (%UNSIGNED-LESSP
				   DIMENSIONS
				   (DEFSYSBYTE-LIMIT-VALUE ARRAY-SHORT-LENGTH-FIELD)))
       (RETURN-FROM SIMPLE-MAKE-ARRAY-TYPE-AREA
	 (MAKE-ARRAY-INTERNAL DIMENSIONS TYPE AREA NIL NIL NIL NIL NIL NIL NIL NIL NIL)))
    (LET ((INITIAL-WORD (AREF *ARRAY-NULL-WORD* TYPE-NUMBER))
	  (WORD-LENGTH (ARRAY-ELEMENT-WORDS DIMENSIONS TYPE-NUMBER)))
      (WITH-BLOCK-REGISTERS (1)
        (%SET-TAG
	  (PROG1 (%ALLOCATE-STRUCTURE-BLOCK (OR AREA *DEFAULT-CONS-AREA*) (1+ WORD-LENGTH))
		 (PREPARE-FOR-BLOCK-WRITE)
		 (%BLOCK-WRITE 1 (%SET-TAG (%LOGDPBS DIMENSIONS ARRAY-SHORT-LENGTH-FIELD
						     TYPE-NUMBER ARRAY-TYPE-FIELD
						     0)
					   (DPB %HEADER-TYPE-ARRAY %%Q-CDR-CODE-WITHIN-TAG
						DTP-HEADER-I)))
		 (SETF (%TRAP-MODE) (LDB %%CR.TRAP-MODE (%SAVED-CONTROL-REGISTER)))
		 (LET ((WORD-LENGTH WORD-LENGTH))
		   (WHEN (LDB-TEST (BYTE 1 0) WORD-LENGTH)
		     (%BLOCK-WRITE 1 INITIAL-WORD))
		   (WHEN (LDB-TEST (BYTE 1 1) WORD-LENGTH)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD))
		   (WHEN (LDB-TEST (BYTE 1 2) WORD-LENGTH)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD))
		   (WHEN (> WORD-LENGTH 7.)
		     (SETF (%TRAP-MODE) (LDB %%CR.TRAP-MODE (%SAVED-CONTROL-REGISTER)))
		     (SETQ WORD-LENGTH (%FIXNUM-FLOOR WORD-LENGTH 8.))
		     (LOOP DOING
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (DECF WORD-LENGTH)
		       (UNLESS (PLUSP WORD-LENGTH) (RETURN)))))
		 (WHEN (AND (= TYPE-NUMBER ART-Q-LIST)
			    (NOT (= DIMENSIONS 0)))
		   (%SET-CDR-CODE-NIL (LOCF INITIAL-WORD))
		   (%MEMORY-WRITE (%POINTER-PLUS (%BLOCK-REGISTER 1) -1) INITIAL-WORD)))
	  (IF (= (LDB %%ARRAY-TYPE-ELEMENT-TYPE TYPE-NUMBER)
		 ARRAY-ELEMENT-TYPE-CHARACTER)
	      DTP-STRING
	      DTP-ARRAY))))))

;;; Not to be called by users; only compiler knows about this.
(DEFUN SIMPLE-MAKE-ARRAY-TYPE-LL-FP-AREA
       (DIMENSIONS TYPE LEADER-LENGTH &OPTIONAL LEADER-LIST FILL-POINTER AREA)
  (LET ((TYPE-NUMBER TYPE)
	(LLENGTH (OR LEADER-LENGTH 0))
	(LLIST LEADER-LIST)
	(LEADER-LIST-LENGTH 0)
	(ARRAY-LEADER-0)
	(ARRAY-LEADER-1))
    (COMPILER:%ERROR-UNLESS (AND (CL:TYPECASE TYPE
				   (CL:FIXNUM
				     (%UNSIGNED-LESSP
				       TYPE
				       (DEFSYSBYTE-LIMIT-VALUE ARRAY-TYPE-FIELD)))
				   (NULL (SETQ TYPE-NUMBER ART-Q))
				   (SYMBOL
				     (WHEN (CL:MEMBER TYPE VALID-ARRAY-TYPE-CODES)
				       (SETQ TYPE-NUMBER (CL:SYMBOL-VALUE TYPE))))
				   (OTHERWISE NIL))
				 (CL:TYPEP DIMENSIONS 'CL:FIXNUM)
				 (%UNSIGNED-LESSP
				   DIMENSIONS
				   (DEFSYSBYTE-LIMIT-VALUE ARRAY-SHORT-LENGTH-FIELD))
				 (CL:TYPEP LLIST 'LIST)
				 (BLOCK LEADER-OPTIONS
				   ;; The most common case of a leader-list seems to
				   ;; be a one or two element list.  Handle these
				   ;; cases specially.
				   (WHEN LLIST
				     (SETQ ARRAY-LEADER-0 (POP LLIST))
				     (INCF LEADER-LIST-LENGTH)
				     (WHEN LLIST
				       (SETQ ARRAY-LEADER-1 (POP LLIST))
				       (INCF LEADER-LIST-LENGTH)
				       (WHEN LLIST
					 (INCF LEADER-LIST-LENGTH (LENGTH LLIST)))))
				   (WHEN FILL-POINTER
				     (SETQ LLENGTH (MAX LLENGTH 1))
				     (SETQ ARRAY-LEADER-0
					   (CL:TYPECASE FILL-POINTER
					     ((CL:MEMBER T) DIMENSIONS)
					     (CL:FIXNUM FILL-POINTER)
					     (OTHERWISE (RETURN-FROM LEADER-OPTIONS NIL)))))
				   (IF LEADER-LENGTH
				       (AND (CL:TYPEP LEADER-LENGTH 'CL:FIXNUM)
					    (%UNSIGNED-LESSP
					      (1- LEADER-LENGTH)
					      (1- (DEFSYSBYTE-LIMIT-VALUE
						    ARRAY-LEADER-LENGTH-FIELD)))
					    ( LEADER-LENGTH LEADER-LIST-LENGTH))
				       (SETQ LLENGTH (MAX LLENGTH LEADER-LIST-LENGTH)))))
       (RETURN-FROM SIMPLE-MAKE-ARRAY-TYPE-LL-FP-AREA
	 (MAKE-ARRAY-INTERNAL DIMENSIONS TYPE AREA LEADER-LIST LEADER-LENGTH FILL-POINTER
			      NIL NIL NIL NIL NIL NIL)))
    ;; There are two cases to worry about, arrays with leaders, and arrays without
    ;; leaders.
    (LET* ((WORD-LENGTH (ARRAY-ELEMENT-WORDS DIMENSIONS TYPE-NUMBER))
	   (INITIAL-WORD (AREF *ARRAY-NULL-WORD* TYPE-NUMBER))
	   (RESULT
	     (%SET-TAG
	       (WITH-BLOCK-REGISTERS (1)
		 (PROG1
		   (IF (ZEROP LLENGTH)
		       (PROG1 (%ALLOCATE-STRUCTURE-BLOCK
				(OR AREA *DEFAULT-CONS-AREA*)
				(+ WORD-LENGTH 1))
			      (PREPARE-FOR-BLOCK-WRITE))
		       (LET ((INITIAL-WORD NIL)
			     (HEADER-LOC (%POINTER-PLUS
					   (%ALLOCATE-STRUCTURE-BLOCK
					     (OR AREA *DEFAULT-CONS-AREA*)
					     (+ WORD-LENGTH LLENGTH 2))
					   (+ LLENGTH 1))))
			 (PREPARE-FOR-BLOCK-WRITE)
			 (%BLOCK-WRITE 1 (%SET-TAG HEADER-LOC (DPB %HEADER-TYPE-LEADER
								   %%Q-CDR-CODE-WITHIN-TAG
								   DTP-HEADER-P)))
			 (WHEN (> LLENGTH 1)
			   (WHEN (> LLENGTH 2)
			     (LET ((N (- LLENGTH 2)))
			       (WHEN (LDB-TEST (BYTE 1 0) N)
				 (%BLOCK-WRITE 1 INITIAL-WORD))
			       (WHEN (LDB-TEST (BYTE 1 1) N)
				 (%BLOCK-WRITE 1 INITIAL-WORD)
				 (%BLOCK-WRITE 1 INITIAL-WORD))
			       (WHEN (> N 3)
				 (SETQ N (%FIXNUM-FLOOR N 4.))
				 (LOOP DOING
				   (%BLOCK-WRITE 1 INITIAL-WORD)
				   (%BLOCK-WRITE 1 INITIAL-WORD)
				   (%BLOCK-WRITE 1 INITIAL-WORD)
				   (%BLOCK-WRITE 1 INITIAL-WORD)
				   (DECF N)
				   (UNLESS (PLUSP N) (RETURN))))))
			   (%BLOCK-WRITE 1 ARRAY-LEADER-1))
			 (%BLOCK-WRITE 1 ARRAY-LEADER-0)
			 HEADER-LOC))
		   (%BLOCK-WRITE 1 (%SET-TAG (%LOGDPBS LLENGTH ARRAY-LEADER-LENGTH-FIELD
						       DIMENSIONS ARRAY-SHORT-LENGTH-FIELD
						       TYPE-NUMBER ARRAY-TYPE-FIELD
						       0)
					     (DPB %HEADER-TYPE-ARRAY
						  %%Q-CDR-CODE-WITHIN-TAG
						  DTP-HEADER-I)))
		   (LET ((WORD-LENGTH WORD-LENGTH))
		     (WHEN (LDB-TEST (BYTE 1 0) WORD-LENGTH)
		       (%BLOCK-WRITE 1 INITIAL-WORD))
		     (WHEN (LDB-TEST (BYTE 1 1) WORD-LENGTH)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD))
		     (WHEN (LDB-TEST (BYTE 1 2) WORD-LENGTH)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD))
		     (WHEN (> WORD-LENGTH 7.)
		       (SETF (%TRAP-MODE) (LDB %%CR.TRAP-MODE (%SAVED-CONTROL-REGISTER)))
		       (SETQ WORD-LENGTH (%FIXNUM-FLOOR WORD-LENGTH 8.))
		       (LOOP DOING
			 (%BLOCK-WRITE 1 INITIAL-WORD)
			 (%BLOCK-WRITE 1 INITIAL-WORD)
			 (%BLOCK-WRITE 1 INITIAL-WORD)
			 (%BLOCK-WRITE 1 INITIAL-WORD)
			 (%BLOCK-WRITE 1 INITIAL-WORD)
			 (%BLOCK-WRITE 1 INITIAL-WORD)
			 (%BLOCK-WRITE 1 INITIAL-WORD)
			 (%BLOCK-WRITE 1 INITIAL-WORD)
			 (DECF WORD-LENGTH)
			 (UNLESS (PLUSP WORD-LENGTH)
			   (RETURN)))))))
	       (IF (= (LDB %%ARRAY-TYPE-ELEMENT-TYPE TYPE-NUMBER)
		      ARRAY-ELEMENT-TYPE-CHARACTER)
		   DTP-STRING
		   DTP-ARRAY))))
      (WHEN (AND (= TYPE-NUMBER ART-Q-LIST)
		 (NOT (= DIMENSIONS 0)))
	(LET ((END-OFFSET (IF FILL-POINTER (MIN ARRAY-LEADER-0 DIMENSIONS) DIMENSIONS)))
	  (WHEN (> END-OFFSET 0)
	    (%SET-CDR-CODE-NIL (LOCF INITIAL-WORD))
	    (SYS:%MEMORY-WRITE (%POINTER-PLUS RESULT END-OFFSET) INITIAL-WORD))))
      (WHEN LLIST
	;; In case this hasn't been done yet
	(SETF (%TRAP-MODE) (LDB %%CR.TRAP-MODE (%SAVED-CONTROL-REGISTER)))
	(LOOP WHILE LLIST
	      FOR I FROM 2
	      DOING
	  (SETF (ARRAY-LEADER RESULT I) (POP LLIST))))
      RESULT)))

(DEFUN MAKE-STRUCTURE-VECTOR-N (VECTOR-LENGTH &REST SLOT-VALUES)
  ;; Just a simple array
  (WITH-BLOCK-REGISTERS (1)
    (%SET-TAG
      (PROG1 (%ALLOCATE-STRUCTURE-BLOCK *DEFAULT-CONS-AREA* (1+ VECTOR-LENGTH))
	     (%BLOCK-WRITE 1
			   (%SET-TAG (%LOGDPB VECTOR-LENGTH ARRAY-SHORT-LENGTH-FIELD
					      (%LOGDPBS ART-Q ARRAY-TYPE-FIELD
							0))
				     (DPB %HEADER-TYPE-ARRAY %%Q-CDR-CODE-WITHIN-TAG
					  DTP-HEADER-I)))
	     (LOOP UNTIL (NULL SLOT-VALUES)
		   DO (%BLOCK-WRITE 1 (POP SLOT-VALUES))))
      DTP-ARRAY)))

(DEFUN MAKE-NAMED-STRUCTURE-VECTOR-N (VECTOR-LENGTH NAMED-STRUCTURE-SYMBOL &REST SLOT-VALUES)
  ;; Just a simple array
  (WITH-BLOCK-REGISTERS (1)
    (%SET-TAG
      (PROG1 (%ALLOCATE-STRUCTURE-BLOCK *DEFAULT-CONS-AREA* (1+ VECTOR-LENGTH))
	     (%BLOCK-WRITE 1
			   (%SET-TAG (%LOGDPB VECTOR-LENGTH ARRAY-SHORT-LENGTH-FIELD
					      (%LOGDPBS 1 ARRAY-NAMED-STRUCTURE-BIT
							ART-Q ARRAY-TYPE-FIELD
							0))
				     (DPB %HEADER-TYPE-ARRAY %%Q-CDR-CODE-WITHIN-TAG
					  DTP-HEADER-I)))
	     (%BLOCK-WRITE 1 NAMED-STRUCTURE-SYMBOL)
	     (LOOP UNTIL (NULL SLOT-VALUES)
		   DO (%BLOCK-WRITE 1 (POP SLOT-VALUES))))
      DTP-ARRAY)))

(EVAL-WHEN (COMPILE LOAD EVAL)
(CL:DEFPARAMETER *MAKE-STRUCTURE-OPTIMIZED-FUNCTION-MAX-SLOTS* 20.)
)

(DEFMACRO DEFINE-MAKE-STRUCTURE-OPTIMIZED-FUNCTIONS (MAX-SLOTS &ENVIRONMENT ENV)
  (FLET ((MAKE-STRUCTURE-OPTIMIZED-FUNCTION (N-SLOTS)
	   (LET ((VECTOR-LENGTH N-SLOTS)
		 (SLOTS (LOOP FOR I BELOW N-SLOTS
			      COLLECT (INTERN (FORMAT NIL "SLOT-~D" I) "SI"))))
	     `(DEFUN ,(INTERN (FORMAT NIL "MAKE-STRUCTURE-VECTOR-~D" VECTOR-LENGTH) "SI")
		     (,@SLOTS)
		(WITH-BLOCK-REGISTERS (1)
		  (%SET-TAG
		    (PROG1 (%ALLOCATE-STRUCTURE-BLOCK *DEFAULT-CONS-AREA* ,(1+ VECTOR-LENGTH))
			   (%BLOCK-WRITE 1
					 (%SET-TAG (%LOGDPB ,VECTOR-LENGTH
							    ARRAY-SHORT-LENGTH-FIELD
							    (%LOGDPBS ART-Q ARRAY-TYPE-FIELD
								      0))
						   (DPB %HEADER-TYPE-ARRAY
							%%Q-CDR-CODE-WITHIN-TAG
							DTP-HEADER-I)))
			   ,@(LOOP FOR SLOT IN SLOTS
				   COLLECT `(%BLOCK-WRITE 1 ,SLOT)))
		    DTP-ARRAY)))))
	 (MAKE-NAMED-STRUCTURE-OPTIMIZED-FUNCTION (N-SLOTS)
	   (LET ((VECTOR-LENGTH (1+ N-SLOTS))
		 (SLOTS (LOOP FOR I BELOW N-SLOTS
			      COLLECT (INTERN (FORMAT NIL "SLOT-~D" I) "SI"))))
	     `(DEFUN ,(INTERN (FORMAT NIL "MAKE-NAMED-STRUCTURE-VECTOR-~D" VECTOR-LENGTH) "SI")
		     (NAMED-STRUCTURE-SYMBOL ,@SLOTS)
		(WITH-BLOCK-REGISTERS (1)
		  (%SET-TAG
		    (PROG1 (%ALLOCATE-STRUCTURE-BLOCK *DEFAULT-CONS-AREA* ,(1+ VECTOR-LENGTH))
			   (%BLOCK-WRITE 1
					 (%SET-TAG (%LOGDPB ,VECTOR-LENGTH
							    ARRAY-SHORT-LENGTH-FIELD
							    (%LOGDPBS 1
								      ARRAY-NAMED-STRUCTURE-BIT
								      ART-Q ARRAY-TYPE-FIELD
								      0))
						   (DPB %HEADER-TYPE-ARRAY
							%%Q-CDR-CODE-WITHIN-TAG
							DTP-HEADER-I)))
			   (%BLOCK-WRITE 1 NAMED-STRUCTURE-SYMBOL)
			   ,@(LOOP FOR SLOT IN SLOTS
				   COLLECT `(%BLOCK-WRITE 1 ,SLOT)))
		    DTP-ARRAY))))))
    `(PROGN ,@(LOOP FOR N-SLOTS FROM 1 TO (EVAL MAX-SLOTS ENV)
		    COLLECT (MAKE-STRUCTURE-OPTIMIZED-FUNCTION N-SLOTS)
		    COLLECT (MAKE-NAMED-STRUCTURE-OPTIMIZED-FUNCTION N-SLOTS)))))

(DEFINE-MAKE-STRUCTURE-OPTIMIZED-FUNCTIONS *MAKE-STRUCTURE-OPTIMIZED-FUNCTION-MAX-SLOTS*)

  ;;
;;;;;;  Raster array abstractions
  ;;

;;; Same as L
(defun make-raster-array (width height &rest make-array-options)
  (stack-let ((dimensions (list #+ROW-MAJOR height width #-ROW-MAJOR height)))
    (cl:apply #'make-array dimensions make-array-options)))

;;; Same as L
(defun scl:make-raster-array (width height &rest make-array-options)
  (declare #.`(arglist width height ,@(cl:member '&key (arglist 'cl:make-array))))
  (stack-let ((dimensions (list #+ROW-MAJOR height width #-ROW-MAJOR height)))
    (cl:apply #'CL:make-array dimensions make-array-options)))


;;; Same as L
(defun raster-width-and-height-to-make-array-dimensions (width height)
  (list #+ROW-MAJOR height width #-ROW-MAJOR height))


;;; The data stack manipulations are machine independent

;;; The Data Stack

;This is the interface that most users of the facility will use
;This makes no attempt to preserve order of evaluation of the keyword args!
;Fixed in Common Lisp
(defmacro with-stack-array ((var length &rest keywords)
			    &body body)
  (declare (arglist (var length &key type element-type initial-element initial-contents
				     displaced-to displaced-index-offset
				     displaced-conformally leader-list leader-length
				     named-structure-symbol initial-value fill-pointer)
		    &body body))
  `(with-data-stack
     (let ((,var (make-stack-array ,length . ,keywords)))
       . ,body)))

;This makes no attempt to preserve order of evaluation of the keyword args!
;Fixed in Common Lisp
(DEFMACRO MAKE-STACK-ARRAY (DIMENSIONS &REST KEYWORDS
				       &KEY (TYPE 'ART-Q TYPE-P)
					    (ELEMENT-TYPE T ELEMENT-TYPE-P)
					    DISPLACED-TO DISPLACED-INDEX-OFFSET
					    DISPLACED-CONFORMALLY LEADER-LIST LEADER-LENGTH
					    NAMED-STRUCTURE-SYMBOL FILL-POINTER
					    (INITIAL-VALUE NIL INITIAL-VALUE-P)
					    (INITIAL-ELEMENT NIL INITIAL-ELEMENT-P)
					    (INITIAL-CONTENTS NIL INITIAL-CONTENTS-P)
					    ADJUSTABLE
				       &ENVIRONMENT ENV)
  (DECLARE (COMPILER:DO-NOT-RECORD-MACROEXPANSIONS))
  (WHEN (OR (IF DISPLACED-TO
		(OR INITIAL-VALUE-P INITIAL-ELEMENT-P INITIAL-CONTENTS-P)
		(OR DISPLACED-INDEX-OFFSET DISPLACED-CONFORMALLY))
	    (AND TYPE-P ELEMENT-TYPE-P)
	    (AND INITIAL-VALUE-P INITIAL-ELEMENT-P)
	    (AND INITIAL-VALUE-P INITIAL-CONTENTS-P)
	    (AND INITIAL-ELEMENT-P INITIAL-CONTENTS-P))
    (ERROR "Illegal combination of keywords"))
  (AND (LISTP TYPE)			;Enable compiler optimization of array
       (EQ (FIRST TYPE) 'QUOTE)		; type symbols into numbers
       (OR (CL:MEMBER (SECOND TYPE) *ARRAY-TYPE-CODES*)
	   (CL:MEMBER (SECOND TYPE) '(ART-STRING ART-FAT-STRING)))
       (SETQ TYPE (SECOND TYPE)))
  (AND (LISTP ELEMENT-TYPE)		;Translate CL array type to ZL array type
       (EQ (FIRST ELEMENT-TYPE) 'QUOTE)
       (SETQ TYPE (SYS:TYPE-ARRAY-ELEMENT-TYPE (SECOND ELEMENT-TYPE))
	     ELEMENT-TYPE-P NIL))
  (WHEN ELEMENT-TYPE-P
    (SETQ TYPE `(SYS:TYPE-ARRAY-ELEMENT-TYPE ,ELEMENT-TYPE)))
  (WHEN INITIAL-VALUE-P
    (SETQ INITIAL-ELEMENT INITIAL-VALUE
	  INITIAL-ELEMENT-P T))
  (COND (INITIAL-CONTENTS-P
	 (ONCE-ONLY (DIMENSIONS &ENVIRONMENT ENV)
	   `(CLI::INITIALIZE-ARRAY-CONTENTS
	      (MAKE-STACK-ARRAY ,DIMENSIONS ,@(REM-KEYWORDS KEYWORDS '(:INITIAL-CONTENTS)))
	      ,DIMENSIONS
	      ,INITIAL-CONTENTS)))
	((NOT DISPLACED-TO)
	 (IF (OR LEADER-LIST LEADER-LENGTH NAMED-STRUCTURE-SYMBOL INITIAL-ELEMENT-P
		 ELEMENT-TYPE-P FILL-POINTER ADJUSTABLE)
	     `(MAKE-GENERAL-STACK-ARRAY ,DIMENSIONS ,TYPE ,INITIAL-ELEMENT
					,LEADER-LIST ,LEADER-LENGTH ,FILL-POINTER
					,NAMED-STRUCTURE-SYMBOL ,ADJUSTABLE)
	     `(MAKE-SIMPLE-STACK-ARRAY ,DIMENSIONS ,TYPE)))
	((NOT DISPLACED-CONFORMALLY)
	 (IF (OR LEADER-LIST LEADER-LENGTH FILL-POINTER NAMED-STRUCTURE-SYMBOL)
	     `(MAKE-INDIRECT-LEADER-STACK-ARRAY ,DIMENSIONS ,TYPE
						,DISPLACED-TO ,DISPLACED-INDEX-OFFSET
						,LEADER-LIST ,LEADER-LENGTH ,FILL-POINTER
						,NAMED-STRUCTURE-SYMBOL)
	     `(MAKE-INDIRECT-STACK-ARRAY ,DIMENSIONS ,TYPE ,DISPLACED-TO
					 ,DISPLACED-INDEX-OFFSET ,ADJUSTABLE)))
	(T
	 `(MAKE-INDIRECT-MULTIDIMENSIONAL-STACK-ARRAY ,DIMENSIONS ,TYPE
			      ,DISPLACED-TO ,DISPLACED-INDEX-OFFSET ,DISPLACED-CONFORMALLY
			      ,LEADER-LIST ,LEADER-LENGTH ,FILL-POINTER
			      ,NAMED-STRUCTURE-SYMBOL))))

;;; Specialized forms of MAKE-ARRAY that allocate on the data stack
;;; Don't call these directly, go through the above macros!
(DEFUN MAKE-SIMPLE-STACK-ARRAY (DIMENSIONS TYPE)
  (LET ((TYPE-NUMBER TYPE))
    (COMPILER:%ERROR-UNLESS (AND (CL:TYPECASE TYPE
				   (CL:FIXNUM
				     (%UNSIGNED-LESSP
				       TYPE
				       (DEFSYSBYTE-LIMIT-VALUE ARRAY-TYPE-FIELD)))
				   (NULL (SETQ TYPE-NUMBER ART-Q))
				   (SYMBOL
				     (WHEN (CL:MEMBER TYPE VALID-ARRAY-TYPE-CODES)
				       (SETQ TYPE-NUMBER (CL:SYMBOL-VALUE TYPE))))
				   (OTHERWISE NIL))
				 (CL:TYPEP DIMENSIONS 'CL:FIXNUM)
				 (%UNSIGNED-LESSP
				   DIMENSIONS (DEFSYSBYTE-LIMIT-VALUE ARRAY-SHORT-LENGTH-FIELD)))
       (RETURN-FROM MAKE-SIMPLE-STACK-ARRAY
	 (MAKE-GENERAL-STACK-ARRAY DIMENSIONS TYPE NIL NIL NIL NIL NIL)))
    (LET ((INITIAL-WORD (AREF *ARRAY-NULL-WORD* TYPE-NUMBER))
	  (WORD-LENGTH (ARRAY-ELEMENT-WORDS DIMENSIONS TYPE-NUMBER))
	  ARRAY)
      (WITH-BLOCK-REGISTERS (1)
        (%SET-TAG
	  (PROG1 (SETQ ARRAY (ALLOCATE-DATA-STACK (1+ WORD-LENGTH)))
		 (PREPARE-FOR-BLOCK-WRITE)
		 (%BLOCK-WRITE 1 (%SET-TAG (%LOGDPBS DIMENSIONS ARRAY-SHORT-LENGTH-FIELD
						     TYPE-NUMBER ARRAY-TYPE-FIELD
						     0)
					   (DPB %HEADER-TYPE-ARRAY %%Q-CDR-CODE-WITHIN-TAG
						DTP-HEADER-I)))
		 (SETF (%TRAP-MODE) (LDB %%CR.TRAP-MODE (%SAVED-CONTROL-REGISTER)))
		 (LET ((WORD-LENGTH WORD-LENGTH))
		   (WHEN (LDB-TEST (BYTE 1 0) WORD-LENGTH)
		     (%BLOCK-WRITE 1 INITIAL-WORD))
		   (WHEN (LDB-TEST (BYTE 1 1) WORD-LENGTH)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD))
		   (WHEN (LDB-TEST (BYTE 1 2) WORD-LENGTH)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD))
		   (WHEN (> WORD-LENGTH 7.)
		     (SETF (%TRAP-MODE) (LDB %%CR.TRAP-MODE (%SAVED-CONTROL-REGISTER)))
		     (SETQ WORD-LENGTH (%FIXNUM-FLOOR WORD-LENGTH 8.))
		     (LOOP DOING
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (%BLOCK-WRITE 1 INITIAL-WORD)
		       (DECF WORD-LENGTH)
		       (UNLESS (PLUSP WORD-LENGTH)
			 (RETURN)))))
		 (WHEN (AND (= TYPE-NUMBER ART-Q-LIST)
			    (NOT (= DIMENSIONS 0)))
		   (%SET-CDR-CODE-NIL (LOCF INITIAL-WORD))
		   (%MEMORY-WRITE (%POINTER-PLUS (%BLOCK-REGISTER 1) -1) INITIAL-WORD))
		 #+VLM (HIDDEN-ARRAY-REGISTER-EVENT ARRAY))
	  (IF (= (LDB %%ARRAY-TYPE-ELEMENT-TYPE TYPE-NUMBER)
		 ARRAY-ELEMENT-TYPE-CHARACTER)
	      DTP-STRING
	      DTP-ARRAY))))))

;This is the general non-displaced case
(DEFUN MAKE-GENERAL-STACK-ARRAY (DIMENSIONS TYPE INITIAL-VALUE
				    LEADER-LIST LEADER-LENGTH FILL-POINTER
				    NAMED-STRUCTURE-SYMBOL &OPTIONAL ADJUSTABLE)
  (LET ((RANK 0)
	(NUMBER-OF-ELEMENTS 1)
	(TYPE-NUMBER TYPE)
	(LLENGTH (OR LEADER-LENGTH 0))
	(LLIST LEADER-LIST)
	(LEADER-LIST-LENGTH 0)
	(ARRAY-LEADER-0)
	(ARRAY-LEADER-1))
    (BLOCK CHECK-DIMENSIONS
      (WHEN (CL:TYPEP DIMENSIONS 'CL:FIXNUM)
	(COMPILER:%ERROR-UNLESS (%UNSIGNED-LESSP DIMENSIONS CL:ARRAY-DIMENSION-LIMIT)
	 (CL:ERROR "The array length, ~s, was not a non-negative integer less than ~a"
		DIMENSIONS CL:ARRAY-DIMENSION-LIMIT))
	(SETQ RANK 1)
	(SETQ NUMBER-OF-ELEMENTS DIMENSIONS)
	(RETURN-FROM CHECK-DIMENSIONS))
      (COMPILER:%ERROR-UNLESS (CL:TYPEP DIMENSIONS 'LIST)
        (CL:ERROR "The dimensions argument ~s is illegal" DIMENSIONS))
      (DOLIST (DIMENSION DIMENSIONS)
	(COMPILER:%ERROR-WHEN ( RANK (1- CL:ARRAY-RANK-LIMIT))
	  (CL:ERROR "The array rank specified by ~s was not less than ~a"
		 DIMENSIONS CL:ARRAY-RANK-LIMIT))
	(COMPILER:%ERROR-UNLESS (AND (CL:TYPEP DIMENSION 'CL:FIXNUM)
				     ( DIMENSION 0))
	  (CL:ERROR "The array dimension ~s in ~s was not a non-negative integer less than ~a"
		 DIMENSION DIMENSIONS CL:ARRAY-DIMENSION-LIMIT))
	(INCF RANK)
	(SETQ NUMBER-OF-ELEMENTS (* NUMBER-OF-ELEMENTS DIMENSION)))
      (COMPILER:%ERROR-UNLESS (< NUMBER-OF-ELEMENTS CL:ARRAY-TOTAL-SIZE-LIMIT)
        (CL:ERROR "The specified total size, ~s, from the dimensions ~s, was not less than ~a"
	       NUMBER-OF-ELEMENTS DIMENSIONS CL:ARRAY-TOTAL-SIZE-LIMIT)))
    (COMPILER:%ERROR-UNLESS (CL:TYPECASE TYPE
			      (CL:FIXNUM
				(AND
				  (%UNSIGNED-LESSP
				    TYPE (DEFSYSBYTE-LIMIT-VALUE ARRAY-TYPE-FIELD))
				  (AREF *VALID-ARRAY-TYPE-CODES* TYPE)))
			      (NULL (SETQ TYPE-NUMBER ART-Q))
			      (SYMBOL
				(AND (CL:MEMBER TYPE *ARRAY-TYPE-CODES*)
				     (SETQ TYPE-NUMBER (CL:SYMBOL-VALUE TYPE))))
			      (T NIL))
      (CL:ERROR "~s is not a valid array type" TYPE))
    (COMPILER:%ERROR-WHEN (AND ( RANK 1)
			       (= TYPE-NUMBER ART-Q-LIST))
      (CL:ERROR "ART-Q-LIST arrays must have rank 1"))
    (COMPILER:%ERROR-UNLESS (CL:TYPEP LEADER-LIST '(OR NULL LIST))
      (CL:ERROR "The leader list must be NIL or a list"))
    (WHEN LEADER-LENGTH
      (COMPILER:%ERROR-UNLESS (AND (CL:TYPEP LEADER-LENGTH 'CL:FIXNUM)
				   (%UNSIGNED-LESSP
				     (1- LEADER-LENGTH)
				     (1- (DEFSYSBYTE-LIMIT-VALUE
					   ARRAY-LEADER-LENGTH-FIELD))))
        (CL:ERROR "The leader length ~s is not NIL or a positive integer less than ~a"
	       LEADER-LENGTH (DEFSYSBYTE-LIMIT-VALUE ARRAY-LEADER-LENGTH-FIELD))))
    ;; The most common case of a leader-list seems to be a one or two
    ;; element list.  Handle these cases specially.
    (WHEN LLIST
      (SETQ ARRAY-LEADER-0 (POP LLIST))
      (INCF LEADER-LIST-LENGTH)
      (WHEN LLIST
	(SETQ ARRAY-LEADER-1 (POP LLIST))
	(INCF LEADER-LIST-LENGTH)
	(WHEN LLIST
	  (INCF LEADER-LIST-LENGTH (LENGTH LLIST)))))
    (WHEN FILL-POINTER
      (COMPILER:%ERROR-UNLESS (= RANK 1)
        (CL:ERROR "Only arrays of rank 1 may have fill-pointers"))
      (SETQ LLENGTH (MAX LLENGTH 1))
      (SETQ ARRAY-LEADER-0
	    (BLOCK FILL-POINTER
	      (WHEN (CL:TYPEP FILL-POINTER 'CL:INTEGER)
		(RETURN-FROM FILL-POINTER FILL-POINTER))
	      (COMPILER:%ERROR-UNLESS (EQ FILL-POINTER T)
	        (CL:ERROR "The fill-pointer must be T, NIL, or a integer"))
	      NUMBER-OF-ELEMENTS)))
    (IF LEADER-LENGTH
	(PROGN
	  (COMPILER:%ERROR-UNLESS (AND (CL:TYPEP LEADER-LENGTH 'CL:FIXNUM)
				       (%UNSIGNED-LESSP
					 (1- LEADER-LENGTH)
					 (1- (DEFSYSBYTE-LIMIT-VALUE
					       ARRAY-LEADER-LENGTH-FIELD))))
	    (CL:ERROR "The leader length ~s is not NIL or a positive integer less than ~a"
		   LEADER-LENGTH (DEFSYSBYTE-LIMIT-VALUE ARRAY-LEADER-LENGTH-FIELD)))
	  (COMPILER:%ERROR-UNLESS ( LEADER-LENGTH LEADER-LIST-LENGTH)
	    (CL:ERROR "The leader length is too short for the leader list")))
	(SETQ LLENGTH (MAX LLENGTH LEADER-LIST-LENGTH)))
    (WHEN NAMED-STRUCTURE-SYMBOL
      (COMPILER:%ERROR-UNLESS (CL:TYPEP NAMED-STRUCTURE-SYMBOL 'SYMBOL)
        (CL:ERROR "The named structure symbol must be a symbol"))
      (WHEN (OR (NOT (ZEROP LLENGTH))
		( RANK 1)
		(NOT (EQL (%LOGLDB %%ARRAY-TYPE-ELEMENT-TYPE TYPE-NUMBER)
			  ARRAY-ELEMENT-TYPE-OBJECT))
		(ZEROP NUMBER-OF-ELEMENTS))
	;; It has to go in the leader
	(SETQ ARRAY-LEADER-1 NAMED-STRUCTURE-SYMBOL)
	(SETQ LLENGTH (MAX LLENGTH 2))))
    (WITH-BLOCK-REGISTERS (1)
      (LET* ((INITIAL-WORD
	       (IF (NULL INITIAL-VALUE)
		   (ARRAY-NULL-WORD TYPE-NUMBER)
		   (BLOCK ARRAY-INITIAL-WORD
		     (LET ((VALUE
			     (SELECT (%LOGLDB %%ARRAY-TYPE-ELEMENT-TYPE TYPE-NUMBER)
			       (ARRAY-ELEMENT-TYPE-FIXNUM
				(COMPILER:%ERROR-UNLESS (CL:TYPEP INITIAL-VALUE 'CL:FIXNUM)
				  (CL:ERROR
				    "Initial value ~s for a fixnum array was not a fixnum"
				    INITIAL-VALUE))
				INITIAL-VALUE)
			       (ARRAY-ELEMENT-TYPE-CHARACTER
				(COMPILER:%ERROR-UNLESS (CL:TYPEP INITIAL-VALUE 'CHARACTER)
				  (CL:ERROR
				    "Initial value ~s for a string array is not a character"
				    INITIAL-VALUE))
				(IF (= TYPE-NUMBER SYS:ART-STRING)
				    (PROGN
				      (COMPILER:%ERROR-WHEN (CHAR-FAT-P INITIAL-VALUE)
				        (FERROR "Initial value ~s is not a thin character"
						INITIAL-VALUE))
				      (CHAR-SUBINDEX INITIAL-VALUE))
				    (%POINTER INITIAL-VALUE)))
			       (ARRAY-ELEMENT-TYPE-BOOLEAN
				(RETURN-FROM ARRAY-INITIAL-WORD
				  (IF INITIAL-VALUE -1 0)))
			       (OTHERWISE	;ARRAY-ELEMENT-TYPE-OBJECT	
				(RETURN-FROM ARRAY-INITIAL-WORD INITIAL-VALUE)))))
		       (TAGBODY (SELECT (%LOGLDB %%ARRAY-TYPE-BYTE-PACKING TYPE-NUMBER)
				  (0 (GO DONE))
				  (1 (GO L16))
				  (2 (GO L8))
				  (3 (GO L4))
				  (4 (GO L2)))
				(SETQ VALUE (%LOGDPB VALUE (BYTE 1. 1.) VALUE))
			     L2 (SETQ VALUE (%LOGDPB VALUE (BYTE 2. 2.) VALUE))
			     L4 (SETQ VALUE (%LOGDPB VALUE (BYTE 4. 4.) VALUE))
			     L8 (SETQ VALUE (%LOGDPB VALUE (BYTE 8. 8.) VALUE))
			     L16 (SETQ VALUE (%LOGDPB VALUE (BYTE 16. 16.) VALUE))
			     DONE)
		       VALUE))))
	      (WORD-LENGTH (ARRAY-ELEMENT-WORDS NUMBER-OF-ELEMENTS TYPE-NUMBER))
	      (SIMPLEP (AND (NULL ADJUSTABLE)
			    (= RANK 1)
			    (< NUMBER-OF-ELEMENTS
			       (DEFSYSBYTE-LIMIT-VALUE ARRAY-SHORT-LENGTH-FIELD))))
	      (LEADER-SIZE (IF (ZEROP LLENGTH) 0 (1+ LLENGTH)))
	      (ARRAY (%SET-TAG (%POINTER-PLUS (ALLOCATE-DATA-STACK
						(+ LEADER-SIZE
						   (IF SIMPLEP
						       1
						       (+ (* RANK 2)
							  (DEFSTORAGE-SIZE SYS:ARRAY)))
						   WORD-LENGTH))
					      LEADER-SIZE)
			       (IF (AND (= RANK 1)
					(= (LDB %%ARRAY-TYPE-ELEMENT-TYPE TYPE-NUMBER)
					   ARRAY-ELEMENT-TYPE-CHARACTER))
				   DTP-STRING
				   DTP-ARRAY))))
	(PREPARE-FOR-BLOCK-WRITE)
	(UNLESS (ZEROP LLENGTH)
	  ;; Write the array leader.  If there is a LEADER-LIST which is longer than 2
	  ;; elements, don't initialize it until later.
	  (LET ((INITIAL-WORD NIL))
	    (%BLOCK-WRITE
	      1
	      (%SET-TAG ARRAY (DPB %HEADER-TYPE-LEADER %%Q-CDR-CODE-WITHIN-TAG DTP-HEADER-P)))
	    (WHEN (> LLENGTH 1)
	      (WHEN (> LLENGTH 2)
		#-CLEVER-COMPILER
		(PROGN
		  (%PUSH (+ LLENGTH -2))
		  (WHEN (COMPILER:%INSTRUCTION LOGTEST-NO-POP (IM 1))
		    (%BLOCK-WRITE 1 INITIAL-WORD))
		  (WHEN (COMPILER:%INSTRUCTION LOGTEST-NO-POP (IM 2))
		    (%BLOCK-WRITE 1 INITIAL-WORD)
		    (%BLOCK-WRITE 1 INITIAL-WORD))
		  (%PUSH (%FIXNUM-FLOOR (%POP) 4.))
		  (WHEN (COMPILER:%INSTRUCTION PLUSP (SP 0))
		    (%BLOCK-WRITE 1 INITIAL-WORD)
		    (%BLOCK-WRITE 1 INITIAL-WORD)
		    (%BLOCK-WRITE 1 INITIAL-WORD)
		    (%BLOCK-WRITE 1 INITIAL-WORD)
		    (COMPILER:%INSTRUCTION LOOP-DECREMENT-TOS -4))
		  (%POP))
		#+CLEVER-COMPILER
		(LET ((N (- LLENGTH 2)))
		  (WHEN (LDB-TEST (BYTE 1 0) N)
		    (%BLOCK-WRITE 1 INITIAL-WORD))
		  (WHEN (LDB-TEST (BYTE 1 1) N)
		    (%BLOCK-WRITE 1 INITIAL-WORD)
		    (%BLOCK-WRITE 1 INITIAL-WORD))
		  (LOOP REPEAT (%FIXNUM-FLOOR N 4.) DOING
		    (%BLOCK-WRITE 1 INITIAL-WORD)
		    (%BLOCK-WRITE 1 INITIAL-WORD)
		    (%BLOCK-WRITE 1 INITIAL-WORD)
		    (%BLOCK-WRITE 1 INITIAL-WORD))))
	      (%BLOCK-WRITE 1 ARRAY-LEADER-1))
	    (%BLOCK-WRITE 1 ARRAY-LEADER-0)))
	;; Now write the array header
	(%BLOCK-WRITE
	  1
	  (%SET-TAG
	    (%LOGDPBS TYPE-NUMBER ARRAY-TYPE-FIELD
		      LLENGTH ARRAY-LEADER-LENGTH-FIELD
		      (IF NAMED-STRUCTURE-SYMBOL 1 0) ARRAY-NAMED-STRUCTURE-BIT
		      (IF SIMPLEP
			  NUMBER-OF-ELEMENTS
			  (%LOGDPBS RANK ARRAY-LONG-DIMENSIONS-FIELD
				    1 ARRAY-LONG-PREFIX-BIT 0)))
	    (DPB %HEADER-TYPE-ARRAY %%Q-CDR-CODE-WITHIN-TAG DTP-HEADER-I)))
	(UNLESS SIMPLEP
	  (%BLOCK-WRITE 1 NUMBER-OF-ELEMENTS)
	  (%BLOCK-WRITE 1 0)
	  (%BLOCK-WRITE 1 (%POINTER-PLUS
			    (%SET-TAG ARRAY DTP-LOCATIVE)
			    (IF (ZEROP NUMBER-OF-ELEMENTS)
				0
				(+ (* RANK 2) (DEFSTORAGE-SIZE SYS:ARRAY)))))
	  (COND ((= RANK 1)
		 (%BLOCK-WRITE 1 NUMBER-OF-ELEMENTS)
		 (%BLOCK-WRITE 1 1))
		(T
		 (LOOP FOR DIM IN DIMENSIONS DOING
		   (%BLOCK-WRITE 1 DIM)
		   (%BLOCK-WRITE 1 1)))))
	(WHEN (AND NAMED-STRUCTURE-SYMBOL (ZEROP LLENGTH))
	  (%BLOCK-WRITE 1 NAMED-STRUCTURE-SYMBOL)
	  (DECF WORD-LENGTH))
	(COND ((< (* WORD-LENGTH 2)
		  (%FIXNUM-MULTIPLY
		    (+ STORAGE:*COUNT-FLUSHABLE-PAGES* STORAGE:*COUNT-NORMAL-PAGES*)
		    SYS:PAGE-SIZE))
	       (LET ((WORD-LENGTH WORD-LENGTH))
		 (WHEN (LDB-TEST (BYTE 1 0) WORD-LENGTH)
		   (%BLOCK-WRITE 1 INITIAL-WORD))
		 (WHEN (LDB-TEST (BYTE 1 1) WORD-LENGTH)
		   (%BLOCK-WRITE 1 INITIAL-WORD)
		   (%BLOCK-WRITE 1 INITIAL-WORD))
		 (WHEN (LDB-TEST (BYTE 1 2) WORD-LENGTH)
		   (%BLOCK-WRITE 1 INITIAL-WORD)
		   (%BLOCK-WRITE 1 INITIAL-WORD)
		   (%BLOCK-WRITE 1 INITIAL-WORD)
		   (%BLOCK-WRITE 1 INITIAL-WORD))
		 (WHEN (> WORD-LENGTH 7.)
		   (SETF (%TRAP-MODE) (LDB %%CR.TRAP-MODE (%SAVED-CONTROL-REGISTER)))
		   (SETQ WORD-LENGTH (%FIXNUM-FLOOR WORD-LENGTH 8.))
		   (LOOP DOING
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (DECF WORD-LENGTH)
		     (UNLESS (PLUSP WORD-LENGTH)
		       (RETURN))))))
	      (T
	       (LET* ((ADDRESS (%POINTER (%BLOCK-REGISTER 1)))
		      (LIMIT (%POINTER-PLUS ADDRESS WORD-LENGTH))
		      (WHACK-SIZE (* 40. SYS:PAGE-SIZE)))
		 (SCANNING-THROUGH-MEMORY MAKE-ARRAY (ADDRESS LIMIT 40.)
		   (LOOP WHILE (%POINTER-LESSP ADDRESS LIMIT)
			 AS THIS-TIME = (MIN (%POINTER-DIFFERENCE LIMIT ADDRESS) WHACK-SIZE)
			 DO
		     (CHECK-MEMORY-SCAN MAKE-ARRAY ADDRESS)
		     (%BLOCK-STORE-CDR-AND-CONTENTS ADDRESS THIS-TIME CDR-NEXT INITIAL-WORD 0)
		     (SETF ADDRESS (%POINTER-PLUS ADDRESS THIS-TIME)))))))
	
	(WHEN (AND (= TYPE-NUMBER ART-Q-LIST)
		   (NOT (= WORD-LENGTH 0)))
	  (%SET-CDR-CODE-NIL (LOCF INITIAL-WORD))
	  (%MEMORY-WRITE (%POINTER-PLUS ARRAY
					(IF SIMPLEP
					    WORD-LENGTH
					    (+ (* RANK 2) (DEFSTORAGE-SIZE SYS:ARRAY) -1
					       WORD-LENGTH)))
			 INITIAL-WORD))
	#+VLM (HIDDEN-ARRAY-REGISTER-EVENT ARRAY)
	(WHEN LLIST
	  (LOOP WHILE LLIST
		FOR I FROM 2
		DOING
	    (SETF (ARRAY-LEADER ARRAY I) (POP LLIST))))
	(WHEN (> RANK 1)
	  (%STORE-NONCONFORMAL-MULTIPLIERS ARRAY RANK))
	ARRAY))))

(DEFUN MAKE-INDIRECT-STACK-ARRAY
       (DIMENSIONS TYPE DISPLACED-TO DISPLACED-INDEX-OFFSET &OPTIONAL ADJUSTABLE)
  (DECLARE (IGNORE ADJUSTABLE))
  (LET ((TYPE-NUMBER TYPE))
    (COMPILER:%ERROR-UNLESS (AND (CL:TYPECASE TYPE
				   (CL:FIXNUM
				     (AND (%UNSIGNED-LESSP
					    TYPE (DEFSYSBYTE-LIMIT-VALUE ARRAY-TYPE-FIELD))
					  (AREF *VALID-ARRAY-TYPE-CODES* TYPE)))
				   (NULL (SETQ TYPE-NUMBER ART-Q))
				   (SYMBOL
				     (WHEN (CL:MEMBER TYPE VALID-ARRAY-TYPE-CODES)
				       (SETQ TYPE-NUMBER (CL:SYMBOL-VALUE TYPE))))
				   (OTHERWISE NIL))
				 (CL:TYPECASE DISPLACED-TO
				   ((OR CL:FIXNUM CLI::LOCATIVE CLI::PHYSICAL-ADDRESS)
				    (NULL DISPLACED-INDEX-OFFSET))
				   (CL:ARRAY
				     (OR ( TYPE-NUMBER ART-Q-LIST)
					 (= (ARRAY-TYPE-FIELD DISPLACED-TO) ART-Q-LIST)))
				   (OTHERWISE NIL))
				 (CL:TYPEP DIMENSIONS 'CL:FIXNUM)
				 (%UNSIGNED-LESSP DIMENSIONS CL:ARRAY-TOTAL-SIZE-LIMIT))
       (RETURN-FROM MAKE-INDIRECT-STACK-ARRAY
	 (MAKE-INDIRECT-MULTIDIMENSIONAL-STACK-ARRAY
	   DIMENSIONS TYPE DISPLACED-TO DISPLACED-INDEX-OFFSET NIL NIL NIL NIL NIL)))
    (LET (ARRAY)
      (%SET-TAG
	(WITH-BLOCK-REGISTERS (1)
	  (PROG1 (SETQ ARRAY (ALLOCATE-DATA-STACK (+ (DEFSTORAGE-SIZE SYS:ARRAY) 2)))
		 (PREPARE-FOR-BLOCK-WRITE)
		 (%BLOCK-WRITE 1 (%SET-TAG
				   (%LOGDPBS TYPE-NUMBER ARRAY-TYPE-FIELD
					     1 ARRAY-LONG-DIMENSIONS-FIELD
					     1 ARRAY-DISPLACED-BIT
					     1 ARRAY-LONG-PREFIX-BIT
					     0)
				   (DPB %HEADER-TYPE-ARRAY %%Q-CDR-CODE-WITHIN-TAG
					DTP-HEADER-I)))
		 (%BLOCK-WRITE 1 DIMENSIONS)
		 (%BLOCK-WRITE 1 (OR DISPLACED-INDEX-OFFSET 0))
		 (%BLOCK-WRITE 1 DISPLACED-TO)
		 (%BLOCK-WRITE 1 DIMENSIONS)
		 (%BLOCK-WRITE 1 1)
		 #+VLM (HIDDEN-ARRAY-REGISTER-EVENT ARRAY)))
	(IF (= (LDB %%ARRAY-TYPE-ELEMENT-TYPE TYPE-NUMBER) ARRAY-ELEMENT-TYPE-CHARACTER)
	    DTP-STRING
	    DTP-ARRAY)))))

;Should there be a simpler version than this?
(DEFUN MAKE-INDIRECT-LEADER-STACK-ARRAY (DIMENSIONS TYPE DISPLACED-TO DISPLACED-INDEX-OFFSET
					    LEADER-LIST LEADER-LENGTH FILL-POINTER
					    NAMED-STRUCTURE-SYMBOL)
  (LET ((RANK 0)
	(NUMBER-OF-ELEMENTS 1)
	(TYPE-NUMBER TYPE)
	(LLENGTH (OR LEADER-LENGTH 0))
	(LLIST LEADER-LIST)
	(LEADER-LIST-LENGTH 0)
	(ARRAY-LEADER-0)
	(ARRAY-LEADER-1)
	(DISPLACED-INDEX-OFFSET (OR DISPLACED-INDEX-OFFSET 0)))
    (BLOCK CHECK-DIMENSIONS
      (WHEN (CL:TYPEP DIMENSIONS 'CL:FIXNUM)
	(COMPILER:%ERROR-UNLESS (%UNSIGNED-LESSP DIMENSIONS CL:ARRAY-DIMENSION-LIMIT)
	 (CL:ERROR "The array length, ~s, was not a non-negative integer less than ~a"
		DIMENSIONS CL:ARRAY-DIMENSION-LIMIT))
	(SETQ RANK 1)
	(SETQ NUMBER-OF-ELEMENTS DIMENSIONS)
	(RETURN-FROM CHECK-DIMENSIONS))
      (COMPILER:%ERROR-UNLESS (CL:TYPEP DIMENSIONS 'LIST)
        (CL:ERROR "The dimensions argument ~s is illegal" DIMENSIONS))
      (DOLIST (DIMENSION DIMENSIONS)
	(COMPILER:%ERROR-WHEN ( RANK (1- CL:ARRAY-RANK-LIMIT))
	  (CL:ERROR "The array rank specified by ~s was not less than ~a"
		 DIMENSIONS CL:ARRAY-RANK-LIMIT))
	(COMPILER:%ERROR-UNLESS (AND (CL:TYPEP DIMENSION 'CL:FIXNUM)
				     ( DIMENSION 0))
	  (CL:ERROR "The array dimension ~s in ~s was not a non-negative integer less than ~a"
		 DIMENSION DIMENSIONS CL:ARRAY-DIMENSION-LIMIT))
	(INCF RANK)
	(SETQ NUMBER-OF-ELEMENTS (* NUMBER-OF-ELEMENTS DIMENSION)))
      (COMPILER:%ERROR-UNLESS (< NUMBER-OF-ELEMENTS CL:ARRAY-TOTAL-SIZE-LIMIT)
        (CL:ERROR "The specified total size, ~s, from the dimensions ~s, was not less than ~a"
	       NUMBER-OF-ELEMENTS DIMENSIONS CL:ARRAY-TOTAL-SIZE-LIMIT)))
    (COMPILER:%ERROR-UNLESS (CL:TYPECASE TYPE
			      (CL:FIXNUM
				(AND (%UNSIGNED-LESSP
				       TYPE (DEFSYSBYTE-LIMIT-VALUE ARRAY-TYPE-FIELD))
				     (AREF *VALID-ARRAY-TYPE-CODES* TYPE)))
			      (NULL (SETQ TYPE-NUMBER ART-Q))
			      (SYMBOL
				(AND (CL:MEMBER TYPE *ARRAY-TYPE-CODES*)
				     (SETQ TYPE-NUMBER (CL:SYMBOL-VALUE TYPE))))
			      (T NIL))
      (CL:ERROR "~s is not a valid array type" TYPE))
    (COMPILER:%ERROR-WHEN (AND ( RANK 1)
			       (= TYPE-NUMBER ART-Q-LIST))
      (CL:ERROR "ART-Q-LIST arrays must have rank 1"))
    (BLOCK CHECK-DISPLACED-TO
      (WHEN (CL:TYPEP DISPLACED-TO '(OR NULL CL:FIXNUM CLI::LOCATIVE CLI::PHYSICAL-ADDRESS))
	(COMPILER:%ERROR-UNLESS (= DISPLACED-INDEX-OFFSET 0)
	  (CL:ERROR "Only arrays displaced to arrays may have a displaced index offset"))
	(RETURN-FROM CHECK-DISPLACED-TO))
      (COMPILER:%ERROR-UNLESS (CL:TYPEP DISPLACED-TO 'CL:ARRAY)
        (CL:ERROR "An array can only be displaced to another array, an address, or a locative"))
      (SETQ DISPLACED-TO (FOLLOW-STRUCTURE-FORWARDING DISPLACED-TO))
      (WHEN (= TYPE-NUMBER ART-Q-LIST)
	(COMPILER:%ERROR-UNLESS (= (ARRAY-TYPE-FIELD DISPLACED-TO) ART-Q-LIST)
	  (CL:ERROR "ART-Q-LIST arrays can only be displaced to ART-Q-LIST arrays"))))
    (COMPILER:%ERROR-UNLESS (CL:TYPEP LEADER-LIST '(OR NULL LIST))
      (CL:ERROR "The leader list must be NIL or a list"))
    (WHEN LEADER-LENGTH
      (COMPILER:%ERROR-UNLESS (AND (CL:TYPEP LEADER-LENGTH 'CL:FIXNUM)
				   (%UNSIGNED-LESSP
				     (1- LEADER-LENGTH)
				     (1- (DEFSYSBYTE-LIMIT-VALUE
					   ARRAY-LEADER-LENGTH-FIELD))))
        (CL:ERROR "The leader length ~s is not NIL or a positive integer less than ~a"
	       LEADER-LENGTH (DEFSYSBYTE-LIMIT-VALUE ARRAY-LEADER-LENGTH-FIELD))))
    ;; The most common case of a leader-list seems to be a one or two
    ;; element list.  Handle these cases specially.
    (WHEN LLIST
      (SETQ ARRAY-LEADER-0 (POP LLIST))
      (INCF LEADER-LIST-LENGTH)
      (WHEN LLIST
	(SETQ ARRAY-LEADER-1 (POP LLIST))
	(INCF LEADER-LIST-LENGTH)
	(WHEN LLIST
	  (INCF LEADER-LIST-LENGTH (LENGTH LLIST)))))
    (WHEN FILL-POINTER
      (COMPILER:%ERROR-UNLESS (= RANK 1)
        (CL:ERROR "Only arrays of rank 1 may have fill-pointers"))
      (SETQ LLENGTH (MAX LLENGTH 1))
      (SETQ ARRAY-LEADER-0
	    (BLOCK FILL-POINTER
	      (WHEN (CL:TYPEP FILL-POINTER 'CL:INTEGER)
		(RETURN-FROM FILL-POINTER FILL-POINTER))
	      (COMPILER:%ERROR-UNLESS (EQ FILL-POINTER T)
	        (CL:ERROR "The fill-pointer must be T, NIL, or a integer"))
	      NUMBER-OF-ELEMENTS)))
    (IF LEADER-LENGTH
	(PROGN
	  (COMPILER:%ERROR-UNLESS (AND (CL:TYPEP LEADER-LENGTH 'CL:FIXNUM)
				       (%UNSIGNED-LESSP
					 (1- LEADER-LENGTH)
					 (1- (DEFSYSBYTE-LIMIT-VALUE
					       ARRAY-LEADER-LENGTH-FIELD))))
	    (CL:ERROR "The leader length ~s is not NIL or a positive integer less than ~a"
		   LEADER-LENGTH (DEFSYSBYTE-LIMIT-VALUE ARRAY-LEADER-LENGTH-FIELD)))
	  (COMPILER:%ERROR-UNLESS ( LEADER-LENGTH LEADER-LIST-LENGTH)
	    (CL:ERROR "The leader length is too short for the leader list")))
	(SETQ LLENGTH (MAX LLENGTH LEADER-LIST-LENGTH)))
    (WHEN NAMED-STRUCTURE-SYMBOL
      (COMPILER:%ERROR-UNLESS (CL:TYPEP NAMED-STRUCTURE-SYMBOL 'SYMBOL)
        (CL:ERROR "The named structure symbol must be a symbol"))
      (IF (ZEROP LLENGTH)
	  (WHEN (OR ( RANK 1)
		    (NOT (EQL (%LOGLDB %%ARRAY-TYPE-ELEMENT-TYPE TYPE-NUMBER)
			      ARRAY-ELEMENT-TYPE-OBJECT))
		    DISPLACED-TO
		    (ZEROP NUMBER-OF-ELEMENTS))
	    ;; It has to go in the leader
	    (SETQ ARRAY-LEADER-1 NAMED-STRUCTURE-SYMBOL)
	    (SETQ LLENGTH 2))
	  (SETQ LLENGTH (MAX LLENGTH 2))))
    (WITH-BLOCK-REGISTERS (1)
      (LET* ((INITIAL-WORD (ARRAY-NULL-WORD TYPE-NUMBER))
	      (WORD-LENGTH (IF DISPLACED-TO
			       0
			       (ARRAY-ELEMENT-WORDS NUMBER-OF-ELEMENTS TYPE-NUMBER)))
	      (SIMPLEP (AND (= RANK 1)
			    (NULL DISPLACED-TO)
			    (< NUMBER-OF-ELEMENTS
			       (DEFSYSBYTE-LIMIT-VALUE ARRAY-SHORT-LENGTH-FIELD))))
	      (LEADER-SIZE (IF (ZEROP LLENGTH) 0 (1+ LLENGTH)))
	      (ARRAY (%SET-TAG (%POINTER-PLUS (ALLOCATE-DATA-STACK
						(+ LEADER-SIZE
						   (IF SIMPLEP
						       1
						       (+ (* RANK 2)
							  (DEFSTORAGE-SIZE SYS:ARRAY)))
						   WORD-LENGTH))
					      LEADER-SIZE)
			       (IF (AND (= RANK 1)
					(= (LDB %%ARRAY-TYPE-ELEMENT-TYPE TYPE-NUMBER)
					   ARRAY-ELEMENT-TYPE-CHARACTER))
				   DTP-STRING
				   DTP-ARRAY))))
	(PREPARE-FOR-BLOCK-WRITE)
	(UNLESS (ZEROP LLENGTH)
	  ;; Write the array leader.  If there is a LEADER-LIST which is longer than 2
	  ;; elements, don't initialize it until later.
	  (LET ((INITIAL-WORD NIL))
	    (%BLOCK-WRITE
	      1
	      (%SET-TAG ARRAY (DPB %HEADER-TYPE-LEADER %%Q-CDR-CODE-WITHIN-TAG DTP-HEADER-P)))
	    (WHEN (> LLENGTH 1)
	      (WHEN (> LLENGTH 2)
		(LET ((N (- LLENGTH 2)))
		  (WHEN (LDB-TEST (BYTE 1 0) N)
		    (%BLOCK-WRITE 1 INITIAL-WORD))
		  (WHEN (LDB-TEST (BYTE 1 1) N)
		    (%BLOCK-WRITE 1 INITIAL-WORD)
		    (%BLOCK-WRITE 1 INITIAL-WORD))
		  (WHEN (> N 3)
		    (SETQ N (%FIXNUM-FLOOR N 4.))
		    (LOOP DOING
		      (%BLOCK-WRITE 1 INITIAL-WORD)
		      (%BLOCK-WRITE 1 INITIAL-WORD)
		      (%BLOCK-WRITE 1 INITIAL-WORD)
		      (%BLOCK-WRITE 1 INITIAL-WORD)
		      (DECF N)
		      (UNLESS (PLUSP N)
			(RETURN))))))
	      (%BLOCK-WRITE 1 ARRAY-LEADER-1))
	    (%BLOCK-WRITE 1 ARRAY-LEADER-0)))
	;; Now write the array header
	(%BLOCK-WRITE
	  1
	  (%SET-TAG
	    (%LOGDPBS TYPE-NUMBER ARRAY-TYPE-FIELD
		      LLENGTH ARRAY-LEADER-LENGTH-FIELD
		      (IF NAMED-STRUCTURE-SYMBOL 1 0) ARRAY-NAMED-STRUCTURE-BIT
		      (IF SIMPLEP
			  NUMBER-OF-ELEMENTS
			  (%LOGDPBS (IF DISPLACED-TO 1 0) ARRAY-DISPLACED-BIT
				    RANK ARRAY-LONG-DIMENSIONS-FIELD
				    1 ARRAY-LONG-PREFIX-BIT 0)))
	    (DPB %HEADER-TYPE-ARRAY %%Q-CDR-CODE-WITHIN-TAG DTP-HEADER-I)))
	(UNLESS SIMPLEP
	  (%BLOCK-WRITE 1 NUMBER-OF-ELEMENTS)
	  (%BLOCK-WRITE 1 DISPLACED-INDEX-OFFSET)
	  (%BLOCK-WRITE 1 (OR DISPLACED-TO
			      (%POINTER-PLUS
				(%SET-TAG ARRAY DTP-LOCATIVE)
				(IF (ZEROP NUMBER-OF-ELEMENTS)
				    0
				    (+ (* RANK 2) (DEFSTORAGE-SIZE SYS:ARRAY))))))
	  (COND ((= RANK 1)
		 (%BLOCK-WRITE 1 NUMBER-OF-ELEMENTS)
		 (%BLOCK-WRITE 1 1))
		(T
		 (LOOP FOR DIM IN DIMENSIONS DOING
		   (%BLOCK-WRITE 1 DIM)
		   (%BLOCK-WRITE 1 1)))))
	(WHEN (AND NAMED-STRUCTURE-SYMBOL (ZEROP LLENGTH))
	  (%BLOCK-WRITE 1 NAMED-STRUCTURE-SYMBOL)
	  (DECF WORD-LENGTH))
	(COND ((< (* WORD-LENGTH 2)
		  (%FIXNUM-MULTIPLY
		    (+ STORAGE:*COUNT-FLUSHABLE-PAGES* STORAGE:*COUNT-NORMAL-PAGES*)
		    SYS:PAGE-SIZE))
	       (LET ((WORD-LENGTH WORD-LENGTH))
		 (WHEN (LDB-TEST (BYTE 1 0) WORD-LENGTH)
		   (%BLOCK-WRITE 1 INITIAL-WORD))
		 (WHEN (LDB-TEST (BYTE 1 1) WORD-LENGTH)
		   (%BLOCK-WRITE 1 INITIAL-WORD)
		   (%BLOCK-WRITE 1 INITIAL-WORD))
		 (WHEN (LDB-TEST (BYTE 1 2) WORD-LENGTH)
		   (%BLOCK-WRITE 1 INITIAL-WORD)
		   (%BLOCK-WRITE 1 INITIAL-WORD)
		   (%BLOCK-WRITE 1 INITIAL-WORD)
		   (%BLOCK-WRITE 1 INITIAL-WORD))
		 (WHEN (> WORD-LENGTH 7.)
		   (SETF (%TRAP-MODE) (LDB %%CR.TRAP-MODE (%SAVED-CONTROL-REGISTER)))
		   (SETQ WORD-LENGTH (%FIXNUM-FLOOR WORD-LENGTH 8.))
		   (LOOP DOING
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (DECF WORD-LENGTH)
		     (UNLESS (PLUSP WORD-LENGTH)
		       (RETURN))))))
	      (T
	       (LET* ((ADDRESS (%POINTER (%BLOCK-REGISTER 1)))
		      (LIMIT (%POINTER-PLUS ADDRESS WORD-LENGTH))
		      (WHACK-SIZE (* 40. SYS:PAGE-SIZE)))
		 (SCANNING-THROUGH-MEMORY MAKE-ARRAY (ADDRESS LIMIT 40.)
		   (LOOP WHILE (%POINTER-LESSP ADDRESS LIMIT)
			 AS THIS-TIME = (MIN (%POINTER-DIFFERENCE LIMIT ADDRESS) WHACK-SIZE)
			 DO
		     (CHECK-MEMORY-SCAN MAKE-ARRAY ADDRESS)
		     (%BLOCK-STORE-CDR-AND-CONTENTS ADDRESS THIS-TIME CDR-NEXT INITIAL-WORD 0)
		     (SETF ADDRESS (%POINTER-PLUS ADDRESS THIS-TIME)))))))
	
	(WHEN (AND (= TYPE-NUMBER ART-Q-LIST)
		   (NOT (= WORD-LENGTH 0))
		   (NOT DISPLACED-TO))
	  (%SET-CDR-CODE-NIL (LOCF INITIAL-WORD))
	  (%MEMORY-WRITE (%POINTER-PLUS ARRAY
					(IF SIMPLEP
					    WORD-LENGTH
					    (+ (* RANK 2)
					       (1- (DEFSTORAGE-SIZE SYS:ARRAY))
					       WORD-LENGTH)))
			 INITIAL-WORD))
	#+VLM (HIDDEN-ARRAY-REGISTER-EVENT ARRAY)
	(WHEN LLIST
	  (LOOP WHILE LLIST
		FOR I FROM 2
		DOING
	    (SETF (ARRAY-LEADER ARRAY I) (POP LLIST))))
	(WHEN (> RANK 1)
	  (%STORE-NONCONFORMAL-MULTIPLIERS ARRAY RANK))
	ARRAY))))

(DEFUN MAKE-INDIRECT-MULTIDIMENSIONAL-STACK-ARRAY (DIMENSIONS TYPE
						      DISPLACED-TO DISPLACED-INDEX-OFFSET
						      DISPLACED-CONFORMALLY
						      LEADER-LIST LEADER-LENGTH FILL-POINTER
						      NAMED-STRUCTURE-SYMBOL)
  (LET ((RANK 0)
	(NUMBER-OF-ELEMENTS 1)
	(TYPE-NUMBER TYPE)
	(LLENGTH (OR LEADER-LENGTH 0))
	(LLIST LEADER-LIST)
	(LEADER-LIST-LENGTH 0)
	(ARRAY-LEADER-0)
	(ARRAY-LEADER-1)
	(DISPLACED-INDEX-OFFSET (OR DISPLACED-INDEX-OFFSET 0)))
    (BLOCK CHECK-DIMENSIONS
      (WHEN (CL:TYPEP DIMENSIONS 'CL:FIXNUM)
	(COMPILER:%ERROR-UNLESS (%UNSIGNED-LESSP DIMENSIONS CL:ARRAY-DIMENSION-LIMIT)
	 (CL:ERROR "The array length, ~s, was not a non-negative integer less than ~a"
		DIMENSIONS CL:ARRAY-DIMENSION-LIMIT))
	(SETQ RANK 1)
	(SETQ NUMBER-OF-ELEMENTS DIMENSIONS)
	(RETURN-FROM CHECK-DIMENSIONS))
      (COMPILER:%ERROR-UNLESS (CL:TYPEP DIMENSIONS 'LIST)
        (CL:ERROR "The dimensions argument ~s is illegal" DIMENSIONS))
      (DOLIST (DIMENSION DIMENSIONS)
	(COMPILER:%ERROR-WHEN ( RANK (1- CL:ARRAY-RANK-LIMIT))
	  (CL:ERROR "The array rank specified by ~s was not less than ~a"
		 DIMENSIONS CL:ARRAY-RANK-LIMIT))
	(COMPILER:%ERROR-UNLESS (AND (CL:TYPEP DIMENSION 'CL:FIXNUM)
				     ( DIMENSION 0))
	  (CL:ERROR "The array dimension ~s in ~s was not a non-negative integer less than ~a"
		 DIMENSION DIMENSIONS CL:ARRAY-DIMENSION-LIMIT))
	(INCF RANK)
	(SETQ NUMBER-OF-ELEMENTS (* NUMBER-OF-ELEMENTS DIMENSION)))
      (COMPILER:%ERROR-UNLESS (< NUMBER-OF-ELEMENTS CL:ARRAY-TOTAL-SIZE-LIMIT)
        (CL:ERROR "The specified total size, ~s, from the dimensions ~s, was not less than ~a"
	       NUMBER-OF-ELEMENTS DIMENSIONS CL:ARRAY-TOTAL-SIZE-LIMIT)))
    (COMPILER:%ERROR-UNLESS (CL:TYPECASE TYPE
			      (CL:FIXNUM
				(AND (%UNSIGNED-LESSP
				       TYPE (DEFSYSBYTE-LIMIT-VALUE ARRAY-TYPE-FIELD))
				     (AREF *VALID-ARRAY-TYPE-CODES* TYPE)))
			      (NULL (SETQ TYPE-NUMBER ART-Q))
			      (SYMBOL
				(AND (CL:MEMBER TYPE *ARRAY-TYPE-CODES*)
				     (SETQ TYPE-NUMBER (CL:SYMBOL-VALUE TYPE))))
			      (T NIL))
      (CL:ERROR "~s is not a valid array type" TYPE))
    (COMPILER:%ERROR-WHEN (AND ( RANK 1)
			       (= TYPE-NUMBER ART-Q-LIST))
      (CL:ERROR "ART-Q-LIST arrays must have rank 1"))
    (BLOCK CHECK-DISPLACED-TO
      (WHEN (CL:TYPEP DISPLACED-TO '(OR NULL CL:FIXNUM CLI::LOCATIVE CLI::PHYSICAL-ADDRESS))
	(COMPILER:%ERROR-UNLESS (= DISPLACED-INDEX-OFFSET 0)
	  (CL:ERROR "Only arrays displaced to arrays may have a displaced index offset"))
	(COMPILER:%ERROR-WHEN DISPLACED-CONFORMALLY
	  (CL:ERROR "Only arrays displaced to arrays may be displaced conformally"))
	(RETURN-FROM CHECK-DISPLACED-TO))
      (COMPILER:%ERROR-UNLESS (CL:TYPEP DISPLACED-TO 'CL:ARRAY)
        (CL:ERROR "An array can only be displaced to another array, an address, or a locative"))
      (SETQ DISPLACED-TO (FOLLOW-STRUCTURE-FORWARDING DISPLACED-TO))
      (WHEN (= TYPE-NUMBER ART-Q-LIST)
	(COMPILER:%ERROR-UNLESS (= (ARRAY-TYPE-FIELD DISPLACED-TO) ART-Q-LIST)
	  (CL:ERROR "ART-Q-LIST arrays can only be displaced to ART-Q-LIST arrays")))
      (WHEN DISPLACED-CONFORMALLY
	(COMPILER:%ERROR-UNLESS (= RANK (CL:ARRAY-RANK DISPLACED-TO))
	  (CL:ERROR
	    "Conformal displacement to the array ~s is not meaningful because it has ~
             rank ~s, which is incompatible with the rank specified for this array, ~s. ~
             The ranks of the two arrays must be the same"
	    DISPLACED-TO (CL:ARRAY-RANK DISPLACED-TO) RANK))))
    (COMPILER:%ERROR-UNLESS (CL:TYPEP LEADER-LIST '(OR NULL LIST))
      (CL:ERROR "The leader list must be NIL or a list"))
    (WHEN LEADER-LENGTH
      (COMPILER:%ERROR-UNLESS (AND (CL:TYPEP LEADER-LENGTH 'CL:FIXNUM)
				   (%UNSIGNED-LESSP
				     (1- LEADER-LENGTH)
				     (1- (DEFSYSBYTE-LIMIT-VALUE
					   ARRAY-LEADER-LENGTH-FIELD))))
        (CL:ERROR "The leader length ~s is not NIL or a positive integer less than ~a"
	       LEADER-LENGTH (DEFSYSBYTE-LIMIT-VALUE ARRAY-LEADER-LENGTH-FIELD))))
    ;; The most common case of a leader-list seems to be a one or two
    ;; element list.  Handle these cases specially.
    (WHEN LLIST
      (SETQ ARRAY-LEADER-0 (POP LLIST))
      (INCF LEADER-LIST-LENGTH)
      (WHEN LLIST
	(SETQ ARRAY-LEADER-1 (POP LLIST))
	(INCF LEADER-LIST-LENGTH)
	(WHEN LLIST
	  (INCF LEADER-LIST-LENGTH (LENGTH LLIST)))))
    (WHEN FILL-POINTER
      (COMPILER:%ERROR-UNLESS (= RANK 1)
        (CL:ERROR "Only arrays of rank 1 may have fill-pointers"))
      (SETQ LLENGTH (MAX LLENGTH 1))
      (SETQ ARRAY-LEADER-0
	    (BLOCK FILL-POINTER
	      (WHEN (CL:TYPEP FILL-POINTER 'CL:INTEGER)
		(RETURN-FROM FILL-POINTER FILL-POINTER))
	      (COMPILER:%ERROR-UNLESS (EQ FILL-POINTER T)
	        (CL:ERROR "The fill-pointer must be T, NIL, or a integer"))
	      NUMBER-OF-ELEMENTS)))
    (IF LEADER-LENGTH
	(PROGN
	  (COMPILER:%ERROR-UNLESS (AND (CL:TYPEP LEADER-LENGTH 'CL:FIXNUM)
				       (%UNSIGNED-LESSP
					 (1- LEADER-LENGTH)
					 (1- (DEFSYSBYTE-LIMIT-VALUE
					       ARRAY-LEADER-LENGTH-FIELD))))
	    (CL:ERROR "The leader length ~s is not NIL or a positive integer less than ~a"
		   LEADER-LENGTH (DEFSYSBYTE-LIMIT-VALUE ARRAY-LEADER-LENGTH-FIELD)))
	  (COMPILER:%ERROR-UNLESS ( LEADER-LENGTH LEADER-LIST-LENGTH)
	    (CL:ERROR "The leader length is too short for the leader list")))
	(SETQ LLENGTH (MAX LLENGTH LEADER-LIST-LENGTH)))
    (WHEN NAMED-STRUCTURE-SYMBOL
      (COMPILER:%ERROR-UNLESS (CL:TYPEP NAMED-STRUCTURE-SYMBOL 'SYMBOL)
        (CL:ERROR "The named structure symbol must be a symbol"))
      (IF (ZEROP LLENGTH)
	  (WHEN (OR ( RANK 1)
		    (NOT (EQL (%LOGLDB %%ARRAY-TYPE-ELEMENT-TYPE TYPE-NUMBER)
			      ARRAY-ELEMENT-TYPE-OBJECT))
		    DISPLACED-TO
		    (ZEROP NUMBER-OF-ELEMENTS))
	    ;; It has to go in the leader
	    (SETQ ARRAY-LEADER-1 NAMED-STRUCTURE-SYMBOL)
	    (SETQ LLENGTH 2))
	  (SETQ LLENGTH (MAX LLENGTH 2))))
    (WITH-BLOCK-REGISTERS (1)
      (LET* ((INITIAL-WORD (ARRAY-NULL-WORD TYPE-NUMBER))
	      (WORD-LENGTH (IF DISPLACED-TO
			       0
			       (ARRAY-ELEMENT-WORDS NUMBER-OF-ELEMENTS TYPE-NUMBER)))
	      (SIMPLEP (AND (= RANK 1)
			    (NULL DISPLACED-TO)
			    (< NUMBER-OF-ELEMENTS
			       (DEFSYSBYTE-LIMIT-VALUE ARRAY-SHORT-LENGTH-FIELD))))
	      (LEADER-SIZE (IF (ZEROP LLENGTH) 0 (1+ LLENGTH)))
	      (ARRAY (%SET-TAG (%POINTER-PLUS (ALLOCATE-DATA-STACK
						(+ LEADER-SIZE
						   (IF SIMPLEP
						       1
						       (+ (* RANK 2)
							  (DEFSTORAGE-SIZE SYS:ARRAY)))
						   WORD-LENGTH))
					      LEADER-SIZE)
			       (IF (AND (= RANK 1)
					(= (LDB %%ARRAY-TYPE-ELEMENT-TYPE TYPE-NUMBER)
					   ARRAY-ELEMENT-TYPE-CHARACTER))
				   DTP-STRING
				   DTP-ARRAY))))
	(PREPARE-FOR-BLOCK-WRITE)
	(UNLESS (ZEROP LLENGTH)
	  ;; Write the array leader.  If there is a LEADER-LIST which is longer than 2
	  ;; elements, don't initialize it until later.
	  (LET ((INITIAL-WORD NIL))
	    (%BLOCK-WRITE
	      1
	      (%SET-TAG ARRAY (DPB %HEADER-TYPE-LEADER %%Q-CDR-CODE-WITHIN-TAG DTP-HEADER-P)))
	    (WHEN (> LLENGTH 1)
	      (WHEN (> LLENGTH 2)
		(LET ((N (- LLENGTH 2)))
		  (WHEN (LDB-TEST (BYTE 1 0) N)
		    (%BLOCK-WRITE 1 INITIAL-WORD))
		  (WHEN (LDB-TEST (BYTE 1 1) N)
		    (%BLOCK-WRITE 1 INITIAL-WORD)
		    (%BLOCK-WRITE 1 INITIAL-WORD))
		  (WHEN (> N 3)
		    (SETQ N (%FIXNUM-FLOOR N 4.))
		    (LOOP DOING
		      (%BLOCK-WRITE 1 INITIAL-WORD)
		      (%BLOCK-WRITE 1 INITIAL-WORD)
		      (%BLOCK-WRITE 1 INITIAL-WORD)
		      (%BLOCK-WRITE 1 INITIAL-WORD)
		      (DECF N)
		      (UNLESS (PLUSP N)
			(RETURN))))))
	      (%BLOCK-WRITE 1 ARRAY-LEADER-1))
	    (%BLOCK-WRITE 1 ARRAY-LEADER-0)))
	;; Now write the array header
	(%BLOCK-WRITE
	  1
	  (%SET-TAG
	    (%LOGDPBS TYPE-NUMBER ARRAY-TYPE-FIELD
		      LLENGTH ARRAY-LEADER-LENGTH-FIELD
		      (IF NAMED-STRUCTURE-SYMBOL 1 0) ARRAY-NAMED-STRUCTURE-BIT
		      (IF SIMPLEP
			  NUMBER-OF-ELEMENTS
			  (%LOGDPBS (IF DISPLACED-TO 1 0) ARRAY-DISPLACED-BIT
				    RANK ARRAY-LONG-DIMENSIONS-FIELD
				    1 ARRAY-LONG-PREFIX-BIT 0)))
	    (DPB %HEADER-TYPE-ARRAY %%Q-CDR-CODE-WITHIN-TAG DTP-HEADER-I)))
	(UNLESS SIMPLEP
	  (%BLOCK-WRITE 1 NUMBER-OF-ELEMENTS)
	  (%BLOCK-WRITE 1 DISPLACED-INDEX-OFFSET)
	  (%BLOCK-WRITE 1 (OR DISPLACED-TO
			      (%POINTER-PLUS
				(%SET-TAG ARRAY DTP-LOCATIVE)
				(IF (ZEROP NUMBER-OF-ELEMENTS)
				    0
				    (+ (* RANK 2) (DEFSTORAGE-SIZE SYS:ARRAY))))))
	  (COND ((= RANK 1)
		 (%BLOCK-WRITE 1 NUMBER-OF-ELEMENTS)
		 (%BLOCK-WRITE 1 1))
		(T
		 (LOOP FOR DIM IN DIMENSIONS DOING
		   (%BLOCK-WRITE 1 DIM)
		   (%BLOCK-WRITE 1 1)))))
	(WHEN (AND NAMED-STRUCTURE-SYMBOL (ZEROP LLENGTH))
	  (%BLOCK-WRITE 1 NAMED-STRUCTURE-SYMBOL)
	  (DECF WORD-LENGTH))
	(COND ((< (* WORD-LENGTH 2)
		  (%FIXNUM-MULTIPLY
		    (+ STORAGE:*COUNT-FLUSHABLE-PAGES* STORAGE:*COUNT-NORMAL-PAGES*)
		    SYS:PAGE-SIZE))
	       (LET ((WORD-LENGTH WORD-LENGTH))
		 (WHEN (LDB-TEST (BYTE 1 0) WORD-LENGTH)
		   (%BLOCK-WRITE 1 INITIAL-WORD))
		 (WHEN (LDB-TEST (BYTE 1 1) WORD-LENGTH)
		   (%BLOCK-WRITE 1 INITIAL-WORD)
		   (%BLOCK-WRITE 1 INITIAL-WORD))
		 (WHEN (LDB-TEST (BYTE 1 2) WORD-LENGTH)
		   (%BLOCK-WRITE 1 INITIAL-WORD)
		   (%BLOCK-WRITE 1 INITIAL-WORD)
		   (%BLOCK-WRITE 1 INITIAL-WORD)
		   (%BLOCK-WRITE 1 INITIAL-WORD))
		 (WHEN (> WORD-LENGTH 7.)
		   (SETF (%TRAP-MODE) (LDB %%CR.TRAP-MODE (%SAVED-CONTROL-REGISTER)))
		   (SETQ WORD-LENGTH (%FIXNUM-FLOOR WORD-LENGTH 8.))
		   (LOOP DOING
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (%BLOCK-WRITE 1 INITIAL-WORD)
		     (DECF WORD-LENGTH)
		     (UNLESS (PLUSP WORD-LENGTH)
		       (RETURN))))))
	      (T
	       (LET* ((ADDRESS (%POINTER (%BLOCK-REGISTER 1)))
		      (LIMIT (%POINTER-PLUS ADDRESS WORD-LENGTH))
		      (WHACK-SIZE (* 40. SYS:PAGE-SIZE)))
		 (SCANNING-THROUGH-MEMORY MAKE-ARRAY (ADDRESS LIMIT 40.)
		   (LOOP WHILE (%POINTER-LESSP ADDRESS LIMIT)
			 AS THIS-TIME = (MIN (%POINTER-DIFFERENCE LIMIT ADDRESS) WHACK-SIZE)
			 DO
		     (CHECK-MEMORY-SCAN MAKE-ARRAY ADDRESS)
		     (%BLOCK-STORE-CDR-AND-CONTENTS ADDRESS THIS-TIME CDR-NEXT INITIAL-WORD 0)
		     (SETF ADDRESS (%POINTER-PLUS ADDRESS THIS-TIME)))))))
	
	(WHEN (AND (= TYPE-NUMBER ART-Q-LIST)
		   (NOT (= WORD-LENGTH 0))
		   (NOT DISPLACED-TO))
	  (%SET-CDR-CODE-NIL (LOCF INITIAL-WORD))
	  (%MEMORY-WRITE (%POINTER-PLUS ARRAY
					(IF SIMPLEP
					    WORD-LENGTH
					    (+ (* RANK 2)
					       (1- (DEFSTORAGE-SIZE SYS:ARRAY))
					       WORD-LENGTH)))
			 INITIAL-WORD))
	#+VLM (HIDDEN-ARRAY-REGISTER-EVENT ARRAY)
	(WHEN LLIST
	  (LOOP WHILE LLIST
		FOR I FROM 2
		DOING
	    (SETF (ARRAY-LEADER ARRAY I) (POP LLIST))))
	(WHEN (> RANK 1)
	  (IF DISPLACED-CONFORMALLY
	      (%INHERIT-CONFORMAL-MULTIPLIERS ARRAY DISPLACED-TO RANK)
	      (%STORE-NONCONFORMAL-MULTIPLIERS ARRAY RANK)))
	ARRAY))))

;;; Same as L
(defmacro with-raster-stack-array
	  ((var width height &rest with-stack-array-args) &body body)
  (declare #.`(arglist (var width height
			    ,@(memq '&key (car (arglist 'sys:with-stack-array))))
		       &body body))
  (let ((dimensions (gensym)))
    `(stack-let ((,dimensions (list #+ROW-MAJOR ,height ,width #-ROW-MAJOR ,height)))
       (with-stack-array (,var ,dimensions . ,with-stack-array-args)
	 ,@body))))

;;; Same as L
(defmacro make-raster-stack-array (width height &rest make-stack-array-args)
  (declare #.`(arglist width height ,@(memq '&key (arglist 'sys:make-stack-array))))
  (let ((dimensions (gensym)))
    `(stack-let ((,dimensions (list #+ROW-MAJOR ,height ,width #-ROW-MAJOR ,height)))
       (make-stack-array ,dimensions . ,make-stack-array-args))))

(DEFUN %MAKE-INDIRECT-RASTER-ARRAY
       (WIDTH HEIGHT SPAN TYPE-NUMBER DISPLACED-TO DISPLACED-INDEX-OFFSET AREA)
  (%SET-TAG
    (WITH-BLOCK-REGISTERS (1)
      (PROG1 (%ALLOCATE-STRUCTURE-BLOCK (OR AREA *DEFAULT-CONS-AREA*)
					   (+ (DEFSTORAGE-SIZE SYS:ARRAY) 4))
	     #-VLM (CLI::%FPA-START FIXNUM-MULTIPLY HEIGHT SPAN)
	     (PREPARE-FOR-BLOCK-WRITE)
	     (%BLOCK-WRITE 1 (%SET-TAG
			       (%LOGDPBS TYPE-NUMBER ARRAY-TYPE-FIELD
					 1 ARRAY-DISCONTIGUOUS-BIT
					 2 ARRAY-LONG-DIMENSIONS-FIELD
					 1 ARRAY-DISPLACED-BIT
					 1 ARRAY-LONG-PREFIX-BIT
					 0)
			       (DPB %HEADER-TYPE-ARRAY %%Q-CDR-CODE-WITHIN-TAG
				    DTP-HEADER-I)))
	     (%BLOCK-WRITE 1 #-VLM (IF (CLI::FP-COPROCESSOR-ENABLED-P)
				       (%FIXNUM (CLI::%FPA-RESULT FIXNUM-MULTIPLY))
				       (* HEIGHT SPAN))
			     #+VLM (* HEIGHT SPAN))
	     (%BLOCK-WRITE 1 DISPLACED-INDEX-OFFSET)
	     (%BLOCK-WRITE 1 DISPLACED-TO)
	     (%BLOCK-WRITE 1 HEIGHT)
	     (%BLOCK-WRITE 1 SPAN)
	     (%BLOCK-WRITE 1 WIDTH)
	     (%BLOCK-WRITE 1 1)))
    DTP-ARRAY))

(DEFUN %MAKE-INDIRECT-RASTER-STACK-ARRAY
       (WIDTH HEIGHT SPAN TYPE-NUMBER DISPLACED-TO DISPLACED-INDEX-OFFSET)
  (%SET-TAG
    (WITH-BLOCK-REGISTERS (1)
      (PROG1 (ALLOCATE-DATA-STACK (+ (DEFSTORAGE-SIZE SYS:ARRAY) 4))
	     #-VLM (CLI::%FPA-START FIXNUM-MULTIPLY HEIGHT SPAN)
	     (PREPARE-FOR-BLOCK-WRITE)
	     (%BLOCK-WRITE 1 (%SET-TAG
			       (%LOGDPBS TYPE-NUMBER ARRAY-TYPE-FIELD
					 1 ARRAY-DISCONTIGUOUS-BIT
					 2 ARRAY-LONG-DIMENSIONS-FIELD
					 1 ARRAY-DISPLACED-BIT
					 1 ARRAY-LONG-PREFIX-BIT
					 0)
			       (DPB %HEADER-TYPE-ARRAY %%Q-CDR-CODE-WITHIN-TAG
				    DTP-HEADER-I)))
	     (%BLOCK-WRITE 1 #-VLM (IF (CLI::FP-COPROCESSOR-ENABLED-P)
				       (%FIXNUM (CLI::%FPA-RESULT FIXNUM-MULTIPLY))
				       (* HEIGHT SPAN))
			     #+VLM (* HEIGHT SPAN))
	     (%BLOCK-WRITE 1 DISPLACED-INDEX-OFFSET)
	     (%BLOCK-WRITE 1 DISPLACED-TO)
	     (%BLOCK-WRITE 1 HEIGHT)
	     (%BLOCK-WRITE 1 SPAN)
	     (%BLOCK-WRITE 1 WIDTH)
	     (%BLOCK-WRITE 1 1)))
    DTP-ARRAY))

(DEFUN %CHANGE-INDIRECT-RASTER-ARRAY
       (ARRAY WIDTH HEIGHT SPAN DISPLACED-TO DISPLACED-INDEX-OFFSET)
  (WITH-BLOCK-REGISTERS (1)
    (SETF (%BLOCK-REGISTER 1) ARRAY)
    #-VLM (CLI::%FPA-START FIXNUM-MULTIPLY HEIGHT SPAN)
    ;; Follow forwarding
    (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER)
    (PREPARE-FOR-BLOCK-WRITE)
    (%BLOCK-WRITE 1 #-VLM (IF (CLI::FP-COPROCESSOR-ENABLED-P)
			      (%FIXNUM (CLI::%FPA-RESULT FIXNUM-MULTIPLY))
			      (* HEIGHT SPAN))
		    #+VLM (* HEIGHT SPAN))
    (%BLOCK-WRITE 1 DISPLACED-INDEX-OFFSET)
    (%BLOCK-WRITE 1 DISPLACED-TO)
    (%BLOCK-WRITE 1 HEIGHT)
    (%BLOCK-WRITE 1 SPAN)
    (%BLOCK-WRITE 1 WIDTH))
  NIL)

;;; Same as L
(defun raster-index-offset (raster x y)
  (#+ROW-MAJOR array-row-major-index
   #-ROW-MAJOR array-column-major-index
   raster
   #+ROW-MAJOR y x #-ROW-MAJOR y))

;;; Array access
(DEFUN DISPLACED-ARRAY-REGISTER-VALUES (EVENT-COUNT HEADER LENGTH OFFSET INDIRECT)
  (DECLARE (WIRED-FUNCTION)
	   (VALUES CONTROL BASE-ADDRESS LENGTH)
	   (UNSAFEGUARDED-REFERENCE CL:ERROR))
  (WITH-BLOCK-REGISTERS (1)
    (LET ((TOTAL-OFFSET OFFSET)
	  (BYTE-PACKING (LDB ARRAY-BYTE-PACKING HEADER)))
      (SETF (%BLOCK-REGISTER 1) INDIRECT)
      (LET ((ADDRESS
	      (LOOP DOING
		(LET* ((HEADER
			 (%POINTER
			   (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER)))
		       (BYTE-PACKING-DIFFERENCE
			 (- BYTE-PACKING (%LOGLDB ARRAY-BYTE-PACKING HEADER))))
		  (UNLESS (LDB-TEST ARRAY-LONG-PREFIX-BIT HEADER)
		    (SETF LENGTH (MIN (+ LENGTH OFFSET)
				      (LSH (%LOGLDB ARRAY-SHORT-LENGTH-FIELD HEADER)
					   BYTE-PACKING-DIFFERENCE)))
		    ;; Found the array, since this one can't be indirected anywhere
		    (RETURN (%BLOCK-REGISTER 1)))
		  (LET* ((THIS-LENGTH (%BLOCK-READ 1 :SET-CDR-NEXT T))
			 (INDEX-OFFSET (%BLOCK-READ 1 :SET-CDR-NEXT T))
			 (NEXT (%BLOCK-READ 1 :SET-CDR-NEXT T :PREFETCH NIL))
			 (SHIFTED-LENGTH (LSH THIS-LENGTH BYTE-PACKING-DIFFERENCE)))
		    (SETF LENGTH
			  (IF (MINUSP SHIFTED-LENGTH)
			      (+ LENGTH OFFSET)
			      (MIN SHIFTED-LENGTH (+ LENGTH OFFSET))))
		    (WHEN (OR (CL:TYPEP NEXT 'CLI::LOCATIVE)
			      (CL:TYPEP NEXT 'CLI::PHYSICAL-ADDRESS))
		      (RETURN NEXT))
		    (COMPILER:%ERROR-UNLESS (TYPE-MEMBER NEXT DTP-ARRAY DTP-STRING)
		      (WHEN (CL:TYPEP NEXT 'CL:FIXNUM)
			(RETURN NEXT))
		      (CL:ERROR "Invalid indirect pointer found in array"))
		    (INCF TOTAL-OFFSET
			  (SETQ OFFSET (LSH INDEX-OFFSET BYTE-PACKING-DIFFERENCE)))
		    (SETF (%BLOCK-REGISTER 1) NEXT))))))
	(LET ((LENGTH (- LENGTH TOTAL-OFFSET)))
	  (SYS:%MULTIPLE-VALUE-CALL-N
	    VALUES
	    (%LOGDPBS (LOGAND (LOGNOT (LSH -1 BYTE-PACKING)) TOTAL-OFFSET)
		      ARRAY-REGISTER-BYTE-OFFSET
		      EVENT-COUNT
		      ARRAY-REGISTER-EVENT-COUNT
		      HEADER) 1
	    (IF (PLUSP LENGTH)
		(VALUES (%POINTER-PLUS ADDRESS (LSH TOTAL-OFFSET (- BYTE-PACKING)))
			LENGTH)
		(VALUES INDIRECT 0)) 2))))))

(DEFMACRO CHECK-ARRAY-INDICES (FUNCTION ARRAY INDICES LENGTHS)
  `(TAGBODY RETRY
	    (COMPILER:%ERROR-UNLESS
	      (AND ,@(LOOP FOR INDEX IN INDICES
			   FOR LENGTH IN LENGTHS
			   APPENDING
			   ;; By using %UNSIGNED-LESSP, we also ensure that the index
			   ;; is not negative.
			     `((%UNSIGNED-LESSP ,INDEX ,LENGTH))))
	      (CL:MULTIPLE-VALUE-SETQ ,INDICES
		(SIGNAL-PROCEED-CASE (,INDICES
				      'SYS:SUBSCRIPT-OUT-OF-BOUNDS
				      :OBJECT ,ARRAY
				      :FUNCTION ',FUNCTION
				      :SUBSCRIPT-USED (LIST ,@INDICES)
				      :SUBSCRIPT-LIMIT (LIST ,@LENGTHS))
		  (:NEW-SUBSCRIPT (VALUES ,@INDICES))))
	      (GO RETRY))))

(DEFMACRO WITH-LONG-ARRAY-REGISTER
	  (((ARRAY-VAR CONTROL-VAR BASE-ADDRESS-VAR LENGTH-VAR &REST LENGTHS-AND-MULTIPLIERS)
	    (ARRAY HEADER))
	   &BODY BODY)
  (LET* ((EVENT-COUNT (GENSYM))
	 (ALENGTH-VAR (GENSYM))
	 (OFFSET-VAR (GENSYM))
	 (INDIRECT-VAR (GENSYM))
	 (BLOCK-READS (LIST* ALENGTH-VAR OFFSET-VAR INDIRECT-VAR LENGTHS-AND-MULTIPLIERS)))
    `(LET ((,EVENT-COUNT (%READ-INTERNAL-REGISTER %REGISTER-EVENT-COUNT))
	   ,@(LOOP FOR VARS ON BLOCK-READS
		   COLLECTING
		     `(,(CAR VARS) (%BLOCK-READ 1
						:PREFETCH ,(NOT (NULL (CDR VARS)))
						:NO-INCREMENT ,(NULL (CDR VARS)))))
	   (,ARRAY-VAR ,ARRAY))
       (MULTIPLE-VALUE-BIND (,CONTROL-VAR ,BASE-ADDRESS-VAR ,LENGTH-VAR)
	   (BLOCK MAKE-THE-ARRAY-REGISTER
	     ;; Explicitly specify the types here because we want to check them in
	     ;; this order.
	     (BLOCK MAYBE-DISPLACED
	       (COMPILER:%ERROR-UNLESS (OR (CL:TYPEP ,INDIRECT-VAR 'CLI::LOCATIVE)
					   (CL:TYPEP ,INDIRECT-VAR 'CLI::PHYSICAL-ADDRESS))
		  (COMPILER:%ERROR-UNLESS (TYPE-MEMBER ,INDIRECT-VAR DTP-ARRAY DTP-STRING)
		    (WHEN (CL:TYPEP ,INDIRECT-VAR 'CL:FIXNUM)
		      (RETURN-FROM MAYBE-DISPLACED))
		    (FERROR "Array has illegal indirect pointer"))
		  (RETURN-FROM MAKE-THE-ARRAY-REGISTER
		    (DISPLACED-ARRAY-REGISTER-VALUES
		      ,EVENT-COUNT ,HEADER ,ALENGTH-VAR ,OFFSET-VAR ,INDIRECT-VAR))))
	     (VALUES (%LOGDPB (%READ-INTERNAL-REGISTER %REGISTER-EVENT-COUNT)
			      ARRAY-REGISTER-EVENT-COUNT-AND-BYTE-OFFSET
			      ,HEADER)
		     ,INDIRECT-VAR
		     ,ALENGTH-VAR))
	 ,@BLOCK-READS ,ARRAY-VAR ,CONTROL-VAR ,BASE-ADDRESS-VAR ,LENGTH-VAR
	 ,@BODY))))

(DEFUN %LEXPR-AREF (ARRAY INDICES &AUX NDIMS)
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (SETQ NDIMS (LENGTH INDICES))
  (COND ((= NDIMS 1)
	 (AREF ARRAY (CAR INDICES)))
	((= NDIMS 2)
	 (AREF ARRAY (CAR INDICES) (CADR INDICES)))
	(T
	 (SETQ ARRAY (FOLLOW-STRUCTURE-FORWARDING ARRAY))
	 (%1D-AREF ARRAY (CL:APPLY #'ARRAY-ROW-MAJOR-INDEX
				ARRAY INDICES)))))

(DEFUN %LEXPR-ASET (DATA ARRAY INDICES &AUX NDIMS)
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (SETQ NDIMS (LENGTH INDICES))
  (COND ((= NDIMS 1)
	 (SETF (AREF ARRAY (CAR INDICES)) DATA))
	((= NDIMS 2)
	 (SETF (AREF ARRAY (CAR INDICES) (CADR INDICES)) DATA))
	(T
	 (SETQ ARRAY (FOLLOW-STRUCTURE-FORWARDING ARRAY))
	 (%1D-ASET DATA ARRAY (CL:APPLY #'ARRAY-ROW-MAJOR-INDEX
				     ARRAY INDICES))
	 DATA)))

(DEFUN %LEXPR-ALOC (ARRAY INDICES &AUX NDIMS)
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (SETQ NDIMS (LENGTH INDICES))
  (COND ((= NDIMS 1)
	 (LOCF (AREF ARRAY (CAR INDICES))))
	((= NDIMS 2)
	 (LOCF (AREF ARRAY (CAR INDICES) (CADR INDICES))))
	(T
	 (SETQ ARRAY (FOLLOW-STRUCTURE-FORWARDING ARRAY))
	 (%1D-ALOC ARRAY (CL:APPLY #'ARRAY-ROW-MAJOR-INDEX
				   ARRAY INDICES)))))

;;; Presumably you don't normally call this function on an array that is already 1d,
;;; so a setup-force-1d-array is going to trap out, so we might as well save this
;;; step and expand in-line, at least for now.
(DEFUN %1D-AREF (ARRAY I0)
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (WITH-BLOCK-REGISTERS (1)
    (SETF (%BLOCK-REGISTER 1) ARRAY)
    (LET ((HEADER (%POINTER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER))))
      (UNLESS (LDB-TEST ARRAY-LONG-PREFIX-BIT HEADER)
	;; Easy case, let the microcode do it
	(RETURN-FROM %1D-AREF (AREF ARRAY I0)))
      (WITH-LONG-ARRAY-REGISTER ((ARRAY CONTROL ADDRESS LENGTH) (ARRAY HEADER))
	(FAST-AREF-1 I0 CONTROL)))))

(DEFUN %1D-ASET (VALUE ARRAY I0)
  (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
  (WITH-BLOCK-REGISTERS (1)
    (SETF (%BLOCK-REGISTER 1) ARRAY)
    (LET ((HEADER (%POINTER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER))))
      (UNLESS (LDB-TEST ARRAY-LONG-PREFIX-BIT HEADER)
	;; Easy case, let the microcode do it
	(RETURN-FROM %1D-ASET (ASET VALUE ARRAY I0)))
      ;; We have a long format array.
      (WITH-LONG-ARRAY-REGISTER ((ARRAY CONTROL ADDRESS LENGTH) (ARRAY HEADER))
	(FAST-ASET-1 VALUE I0 CONTROL)
	VALUE))))

(DEFUN %1D-ALOC (ARRAY I0)
  (TAGBODY RETRY
    (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
    (CL:CHECK-TYPE I0 CL:FIXNUM)
    (WITH-BLOCK-REGISTERS (1)
      (SETF (%BLOCK-REGISTER 1) ARRAY)
      (LET ((HEADER (%POINTER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER))))
	(UNLESS (LDB-TEST ARRAY-LONG-PREFIX-BIT HEADER)
	  ;; Easy case, let the microcode do it
	  (RETURN-FROM %1D-ALOC (LOCF (AREF ARRAY I0))))
	;; We have a long format array.
	(COMPILER:%ERROR-UNLESS (= (%LOGLDB ARRAY-ELEMENT-TYPE-FIELD HEADER)
				   ARRAY-ELEMENT-TYPE-OBJECT)
	  (SIGNAL-PROCEED-CASE ((NEW-ARRAY)
				'SYS:NUMBER-ARRAY-NOT-ALLOWED
				:ARRAY ARRAY
				:FUNCTION '%1D-ALOC)
	    (:NEW-ARRAY
	      (SETQ ARRAY NEW-ARRAY)
	      (GO RETRY))))
	(WITH-LONG-ARRAY-REGISTER ((ARRAY CONTROL ADDRESS LENGTH) (ARRAY HEADER))
	  (COMPILER:%ERROR-UNLESS (%UNSIGNED-LESSP I0 LENGTH)
	    (SIGNAL-PROCEED-CASE ((INDICES)
				  'SYS:SUBSCRIPT-OUT-OF-BOUNDS
				  :OBJECT ARRAY
				  :FUNCTION '%1D-ALOC
				  :SUBSCRIPT-USED (LIST I0)
				  :SUBSCRIPT-LIMIT (LIST LENGTH))
	      (:NEW-SUBSCRIPT
		(SETQ I0 INDICES)
		(GO RETRY))))
	  (RETURN-FROM %1D-ALOC (%POINTER-PLUS ADDRESS I0)))))))

(DEFUN %1D-ARRAY-ELEMENT-LOCATION (ARRAY I0)
  (WITH-BLOCK-REGISTERS (1)
    (SETF (%BLOCK-REGISTER 1) ARRAY)
    (LET ((HEADER (%POINTER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER))))
      (UNLESS (LDB-TEST ARRAY-LONG-PREFIX-BIT HEADER)
	(RETURN-FROM %1D-ARRAY-ELEMENT-LOCATION
	  (%MAKE-POINTER-OFFSET
	    DTP-LOCATIVE ARRAY (1+ (LSH I0 (- (%LOGLDB ARRAY-BYTE-PACKING HEADER)))))))
      (WITH-LONG-ARRAY-REGISTER ((ARRAY CONTROL ADDRESS LENGTH) (ARRAY HEADER))
	ADDRESS LENGTH ARRAY CONTROL		;Array register
	(SYS:%POINTER-PLUS ADDRESS (LSH (+ (%LOGLDB ARRAY-REGISTER-BYTE-OFFSET CONTROL) I0)
					(- (%LOGLDB ARRAY-BYTE-PACKING HEADER))))))))

(DEFUN AR-2 (ARRAY I0 I1)
  (TAGBODY
    RETRY
       (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY) "an array")
       (CL:CHECK-TYPE I0 CL:FIXNUM)
       (CL:CHECK-TYPE I1 CL:FIXNUM)
       (WITH-BLOCK-REGISTERS (1)
	 (SETF (%BLOCK-REGISTER 1) ARRAY)
	 (LET ((HEADER (%POINTER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER))))
	   (COMPILER:%ERROR-UNLESS (= (LOGAND (%LOGDPBS 1 ARRAY-LONG-PREFIX-BIT
							-1 ARRAY-LONG-DIMENSIONS-FIELD
							0)
					      HEADER)
				      (%LOGDPBS 1 ARRAY-LONG-PREFIX-BIT
						2 ARRAY-LONG-DIMENSIONS-FIELD
						0))
	     (SIGNAL-PROCEED-CASE ((NEW-ARRAY)
				   'ARRAY-WRONG-NUMBER-OF-DIMENSIONS
				   :FUNCTION 'AR-2
				   :ARRAY ARRAY
				   :DIMENSIONS-EXPECTED 2
				   :DIMENSIONS-GIVEN (CL:ARRAY-RANK ARRAY))
	       (:NEW-ARRAY
		 (SETQ ARRAY NEW-ARRAY)
		 (GO RETRY))))
	   (WITH-LONG-ARRAY-REGISTER ((ARRAY CONTROL ADDRESS LENGTH L0 M0 L1) (ARRAY HEADER))
	     (CHECK-ARRAY-INDICES AR-2 ARRAY (I0 I1) (L0 L1))
	     #-VLM (CLI::%FPA-START FIXNUM-MULTIPLY M0 I0)
	     (RETURN-FROM AR-2
	       (FAST-AREF-1
		 (+ #-VLM (IF (CLI::FP-COPROCESSOR-ENABLED-P)
			      (%FIXNUM (CLI::%FPA-RESULT FIXNUM-MULTIPLY))
			      (* M0 I0))
		    #+VLM (* M0 I0)
		    I1)
		 CONTROL)))))))

(DEFUN AS-2 (VALUE ARRAY I0 I1)
  (TAGBODY
    RETRY
       (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY) "an array")
       (CL:CHECK-TYPE I0 CL:FIXNUM)
       (CL:CHECK-TYPE I1 CL:FIXNUM)
       (WITH-BLOCK-REGISTERS (1)
	 (SETF (%BLOCK-REGISTER 1) ARRAY)
	 (LET ((HEADER (%POINTER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER))))
	   (COMPILER:%ERROR-UNLESS (= (LOGAND (%LOGDPBS 1 ARRAY-LONG-PREFIX-BIT
							-1 ARRAY-LONG-DIMENSIONS-FIELD
							0)
					      HEADER)
				      (%LOGDPBS 1 ARRAY-LONG-PREFIX-BIT
						2 ARRAY-LONG-DIMENSIONS-FIELD
						0))
	     (SIGNAL-PROCEED-CASE ((NEW-ARRAY)
				   'ARRAY-WRONG-NUMBER-OF-DIMENSIONS
				   :FUNCTION 'AS-2
				   :ARRAY ARRAY
				   :DIMENSIONS-EXPECTED 2
				   :DIMENSIONS-GIVEN (CL:ARRAY-RANK ARRAY))
	       (:NEW-ARRAY
		 (SETQ ARRAY NEW-ARRAY)
		 (GO RETRY))))
	   (WITH-LONG-ARRAY-REGISTER ((ARRAY CONTROL ADDRESS LENGTH L0 M0 L1) (ARRAY HEADER))
	     (CHECK-ARRAY-INDICES AS-2 ARRAY (I0 I1) (L0 L1))
	     #-VLM (CLI::%FPA-START FIXNUM-MULTIPLY M0 I0)
	     (FAST-ASET-1
	       VALUE
	       (+
		 #-VLM (IF (CLI::FP-COPROCESSOR-ENABLED-P)
			   (%FIXNUM (CLI::%FPA-RESULT FIXNUM-MULTIPLY))
			   (* M0 I0))
		 #+VLM (* M0 I0)
		 I1)
	       CONTROL)
	     (RETURN-FROM AS-2 VALUE))))))

(DEFUN AP-2 (ARRAY I0 I1)
  (TAGBODY
    RETRY
       (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY) "an array")
       (CL:CHECK-TYPE I0 CL:FIXNUM)
       (CL:CHECK-TYPE I1 CL:FIXNUM)
       (WITH-BLOCK-REGISTERS (1)
	 (SETF (%BLOCK-REGISTER 1) ARRAY)
	 (LET ((HEADER (%POINTER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER))))
	   (COMPILER:%ERROR-UNLESS (= (%LOGLDB ARRAY-ELEMENT-TYPE-FIELD HEADER)
				      ARRAY-ELEMENT-TYPE-OBJECT)
	     (SIGNAL-PROCEED-CASE ((NEW-ARRAY)
				   'SYS:NUMBER-ARRAY-NOT-ALLOWED
				   :ARRAY ARRAY
				   :FUNCTION 'AP-2)
	       (:NEW-ARRAY
		 (SETQ ARRAY NEW-ARRAY)
		 (GO RETRY))))
	   (COMPILER:%ERROR-UNLESS (= (LOGAND (%LOGDPBS 1 ARRAY-LONG-PREFIX-BIT
							-1 ARRAY-LONG-DIMENSIONS-FIELD
							0)
					      HEADER)
				      (%LOGDPBS 1 ARRAY-LONG-PREFIX-BIT
						2 ARRAY-LONG-DIMENSIONS-FIELD
						0))
	     (SIGNAL-PROCEED-CASE ((NEW-ARRAY)
				   'ARRAY-WRONG-NUMBER-OF-DIMENSIONS
				   :FUNCTION 'AP-2
				   :ARRAY ARRAY
				   :DIMENSIONS-EXPECTED 2
				   :DIMENSIONS-GIVEN (CL:ARRAY-RANK ARRAY))
	       (:NEW-ARRAY
		 (SETQ ARRAY NEW-ARRAY)
		 (GO RETRY))))
	   (WITH-LONG-ARRAY-REGISTER ((ARRAY CONTROL ADDRESS LENGTH L0 M0 L1) (ARRAY HEADER))
	     (CHECK-ARRAY-INDICES AP-2 ARRAY (I0 I1) (L0 L1))
	     #-VLM (CLI::%FPA-START FIXNUM-MULTIPLY M0 I0)
	     (LET ((INDEX (+ #-VLM (IF (CLI::FP-COPROCESSOR-ENABLED-P)
				       (%FIXNUM (CLI::%FPA-RESULT FIXNUM-MULTIPLY))
				       (* M0 I0))
			     #+VLM (* M0 I0)
			     I1)))
	       (COMPILER:%ERROR-UNLESS (%UNSIGNED-LESSP INDEX LENGTH)
		 (CL:MULTIPLE-VALUE-SETQ (I0 I1)
		   (SIGNAL-PROCEED-CASE ((I0 I1)
					 'SYS:SUBSCRIPT-OUT-OF-BOUNDS
					 :OBJECT ARRAY
					 :FUNCTION 'AP-2
					 :SUBSCRIPT-USED (LIST I0 I1)
					 :SUBSCRIPT-LIMIT (LIST L0 L1))
		     (:NEW-SUBSCRIPT (VALUES I0 I1))))
		 (GO RETRY))
	       (RETURN-FROM AP-2 (%POINTER-PLUS ADDRESS INDEX))))))))

(DEFUN DECODE-RASTER-ARRAY (RASTER)
  (DECLARE (VALUES WIDTH HEIGHT SPANNING-WIDTH))
  (TAGBODY
    RETRY
       (CHECK-ARG RASTER (TYPE-MEMBER RASTER DTP-ARRAY) "an array")
       (WITH-BLOCK-REGISTERS (1)
	 (SETF (%BLOCK-REGISTER 1) RASTER)
	 (LET ((HEADER (%POINTER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER :PREFETCH NIL
					      :NO-INCREMENT T))))
	   (COMPILER:%ERROR-UNLESS (AND (LDB-TEST ARRAY-LONG-PREFIX-BIT HEADER)
					(= (LDB ARRAY-LONG-DIMENSIONS-FIELD HEADER) 2))
	     (SIGNAL-PROCEED-CASE ((NEW-ARRAY)
				   'ARRAY-WRONG-NUMBER-OF-DIMENSIONS
				   :FUNCTION 'DECODE-RASTER-ARRAY
				   :ARRAY RASTER
				   :DIMENSIONS-EXPECTED 2
				   :DIMENSIONS-GIVEN (CL:ARRAY-RANK RASTER))
	       (:NEW-ARRAY
		 (SETQ RASTER NEW-ARRAY)
		 (GO RETRY))))
	   (SETF (%BLOCK-REGISTER 1)
		 (%POINTER-PLUS (%BLOCK-REGISTER 1) (SYS:DEFSTORAGE-SIZE ARRAY)))
	   (RETURN-FROM DECODE-RASTER-ARRAY
	     (LET ((L0 (%BLOCK-READ 1))
		   (M0 (%BLOCK-READ 1)))
	     (VALUES (%BLOCK-READ 1 :PREFETCH NIL :NO-INCREMENT T)
		     L0
		     M0)))))))

(DEFUN DECODE-RASTER-INDEX-OFFSET (RASTER)
  (DECLARE (VALUES X-OFFSET Y-OFFSET))
  (TAGBODY
    RETRY
       (CHECK-ARG RASTER (TYPE-MEMBER RASTER DTP-ARRAY) "an array")
       (WITH-BLOCK-REGISTERS (1)
	 (SETF (%BLOCK-REGISTER 1) RASTER)
	 (LET ((HEADER (%POINTER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER :PREFETCH NIL
					      :NO-INCREMENT T))))
	   (COMPILER:%ERROR-UNLESS (AND (LDB-TEST ARRAY-LONG-PREFIX-BIT HEADER)
					(= (LDB ARRAY-LONG-DIMENSIONS-FIELD HEADER) 2))
	     (SIGNAL-PROCEED-CASE ((NEW-ARRAY)
				   'ARRAY-WRONG-NUMBER-OF-DIMENSIONS
				   :FUNCTION 'DECODE-RASTER-INDEX-OFFSET
				   :ARRAY RASTER
				   :DIMENSIONS-EXPECTED 2
				   :DIMENSIONS-GIVEN (CL:ARRAY-RANK RASTER))
	       (:NEW-ARRAY
		 (SETQ RASTER NEW-ARRAY)
		 (GO RETRY))))
	   (COMPILER:%ERROR-UNLESS (= (LOGAND (%LOGDPBS 1 ARRAY-LONG-PREFIX-BIT
							1 ARRAY-DISPLACED-BIT
							0)
					      HEADER)
				      (%LOGDPBS 1 ARRAY-LONG-PREFIX-BIT
						1 ARRAY-DISPLACED-BIT
						0))
	     (RETURN-FROM DECODE-RASTER-INDEX-OFFSET
	       (VALUES 0 0)))
	   (LET ((INDEX-OFFSET (DONT-FOLLOW-FORWARDING (ARRAY-INDEX-OFFSET-FIELD
							 (%BLOCK-REGISTER 1))))
		 (SPANNING-WIDTH (%MEMORY-READ (%POINTER-PLUS (%BLOCK-REGISTER 1)
							 (1+ (SYS:DEFSTORAGE-SIZE ARRAY))))))
	     (RETURN-FROM DECODE-RASTER-INDEX-OFFSET
	       (IF (ZEROP SPANNING-WIDTH)		;this can happen
		   (VALUES INDEX-OFFSET 0)
		   (MULTIPLE-VALUE-BIND (Y-OFFSET X-OFFSET)
		       (FLOOR INDEX-OFFSET SPANNING-WIDTH)
		     (VALUES X-OFFSET Y-OFFSET)))))))))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER AREF-1 TRAP-MODE-EMULATOR (ARRAY I0)
  (DECLARE (WIRED-FUNCTION)
	   (UNSAFEGUARDED-REFERENCE
	     DBG:CHECK-ARG-1 ARRAY CL:ARRAY
	     ERROR :FUNCTION AREF-1
	     ARRAY-WRONG-NUMBER-OF-DIMENSIONS
	     :ARRAY :DIMENSIONS-EXPECTED :DIMENSIONS-GIVEN
	     CL:ARRAY-RANK :PROCEED-TYPES :NEW-ARRAY FERROR SIGNAL))
  (VALUES
  (BLOCK AREF-1
    (LET ((BAR-1 (%BLOCK-REGISTER 1)))
      (TAGBODY
	RETRY
	   (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
	   (SETF (%BLOCK-REGISTER 1) ARRAY)
	   (LET ((HEADER (%POINTER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER))))
	     (WITH-LONG-ARRAY-REGISTER ((ARRAY CONTROL ADDRESS LENGTH) (ARRAY HEADER))
	       (COMPILER:%ERROR-UNLESS (= (LDB ARRAY-LONG-DIMENSIONS-FIELD HEADER) 1)
		  (SIGNAL-PROCEED-CASE ((NEW-ARRAY)
					'ARRAY-WRONG-NUMBER-OF-DIMENSIONS
					:FUNCTION 'AREF-1
					:ARRAY ARRAY
					:DIMENSIONS-EXPECTED 1
					:DIMENSIONS-GIVEN (CL:ARRAY-RANK ARRAY))
		    (:NEW-ARRAY
		      (SETQ ARRAY NEW-ARRAY)
		      (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
		      (WHEN (= (ARRAY-LONG-PREFIX-BIT ARRAY) 1)
			(GO RETRY))
		      (SETF (%BLOCK-REGISTER 1) BAR-1)
		      (RETURN-FROM AREF-1 (AREF ARRAY I0)))))
	       (SETF (%BLOCK-REGISTER 1) BAR-1)
	       (RETURN-FROM AREF-1 (SYS:FAST-AREF-1 I0 CONTROL)))))))))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER ASET-1 TRAP-MODE-EMULATOR (VALUE ARRAY I0)
  (DECLARE (WIRED-FUNCTION)
	   (UNSAFEGUARDED-REFERENCE
	     DBG:CHECK-ARG-1 ARRAY CL:ARRAY
	     ERROR :FUNCTION ASET-1
	     ARRAY-WRONG-NUMBER-OF-DIMENSIONS
	     :ARRAY :DIMENSIONS-EXPECTED :DIMENSIONS-GIVEN
	     CL:ARRAY-RANK :PROCEED-TYPES :NEW-ARRAY FERROR SIGNAL))
  (SAVING-REGISTERS-FOR-EFFECT (%REGISTER-BAR-1)
    (TAGBODY
      RETRY
	 (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
	 (SETF (%BLOCK-REGISTER 1) ARRAY)
	 (LET ((HEADER (%POINTER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER))))
	   (WITH-LONG-ARRAY-REGISTER ((ARRAY CONTROL ADDRESS LENGTH) (ARRAY HEADER))
	     (COMPILER:%ERROR-UNLESS (= (LDB ARRAY-LONG-DIMENSIONS-FIELD HEADER) 1)
	       (SIGNAL-PROCEED-CASE ((NEW-ARRAY)
				     'ARRAY-WRONG-NUMBER-OF-DIMENSIONS
				     :FUNCTION 'ASET-1
				     :ARRAY ARRAY
				     :DIMENSIONS-EXPECTED 1
				     :DIMENSIONS-GIVEN (CL:ARRAY-RANK ARRAY))
		 (:NEW-ARRAY
		   (SETQ ARRAY NEW-ARRAY)
		   (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
		   (WHEN (= (ARRAY-LONG-PREFIX-BIT ARRAY) 1)
		     (GO RETRY))
		   (SETF (AREF ARRAY I0) VALUE)
		   (GO DONE))))
	     (SYS:FAST-ASET-1 VALUE I0 CONTROL)
	     (GO DONE)))
      DONE))
  (%RETURN-KLUDGE-0))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER ALOC-1 TRAP-MODE-EMULATOR (ARRAY I0)
  (DECLARE (WIRED-FUNCTION)
	   (UNSAFEGUARDED-REFERENCE
	     DBG:CHECK-ARG-1 DBG:CHECK-TYPE-1 ARRAY CL:ARRAY
	     I0 CL:FIXNUM
	     ERROR :FUNCTION ALOC-1
	     ARRAY-WRONG-NUMBER-OF-DIMENSIONS
	     :ARRAY :DIMENSIONS-EXPECTED :DIMENSIONS-GIVEN
	     CL:ARRAY-RANK :PROCEED-TYPES :NEW-ARRAY FERROR SIGNAL
	     NUMBER-ARRAY-NOT-ALLOWED SUBSCRIPT-OUT-OF-BOUNDS :OBJECT :SUBSCRIPT-USED
	     %LIST-1 :SUBSCRIPT-LIMIT :NEW-SUBSCRIPT NUMBER-ARRAY-NOT-ALLOWED))
  (VALUES
    (BLOCK ALOC-1
      (LET ((BAR-1 (%BLOCK-REGISTER 1)))
	(TAGBODY
	  RETRY
	     (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY) "an array")
	     (CL:CHECK-TYPE I0 CL:FIXNUM)
	     (SETF (%BLOCK-REGISTER 1) ARRAY)
	     (LET ((HEADER (%POINTER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER))))
	       (WITH-LONG-ARRAY-REGISTER ((ARRAY CONTROL ADDRESS LENGTH) (ARRAY HEADER))
		 (COMPILER:%ERROR-UNLESS (= (%LOGLDB ARRAY-ELEMENT-TYPE-FIELD HEADER)
					    ARRAY-ELEMENT-TYPE-OBJECT)
		   (SIGNAL-PROCEED-CASE ((NEW-ARRAY)
					 'SYS:NUMBER-ARRAY-NOT-ALLOWED
					 :ARRAY ARRAY
					 :FUNCTION 'ALOC-1)
		     (:NEW-ARRAY
		       (SETQ ARRAY NEW-ARRAY)
		       (WHEN (= (ARRAY-LONG-PREFIX-BIT ARRAY) 1)
			 (GO RETRY))
		       (SETF (%BLOCK-REGISTER 1) BAR-1)
		       (RETURN-FROM ALOC-1 (LOCF (AREF ARRAY I0))))))
		 (COMPILER:%ERROR-UNLESS (= (LDB ARRAY-LONG-DIMENSIONS-FIELD HEADER) 1)
		   (SIGNAL-PROCEED-CASE ((NEW-ARRAY)
					 'ARRAY-WRONG-NUMBER-OF-DIMENSIONS
					 :FUNCTION 'ALOC-1
					 :ARRAY ARRAY
					 :DIMENSIONS-EXPECTED 1
					 :DIMENSIONS-GIVEN (CL:ARRAY-RANK ARRAY))
		     (:NEW-ARRAY
		       (SETQ ARRAY NEW-ARRAY)
		       (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY) "an array")
		       (WHEN (= (ARRAY-LONG-PREFIX-BIT ARRAY) 1)
			 (GO RETRY))
		       (SETF (%BLOCK-REGISTER 1) BAR-1)
		       (RETURN-FROM ALOC-1 (LOCF (AREF ARRAY I0))))))
		 (CHECK-ARRAY-INDICES ALOC-1 ARRAY (I0) (LENGTH))
		 (SETF (%BLOCK-REGISTER 1) BAR-1)
		 (RETURN-FROM ALOC-1
		   (%POINTER-PLUS ADDRESS I0)))))))))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER SETUP-1D-ARRAY TRAP-MODE-EMULATOR (ARRAY)
  (DECLARE (WIRED-FUNCTION)
	   (UNSAFEGUARDED-REFERENCE DBG:CHECK-ARG-1 ARRAY CL:ARRAY
				    ERROR :FUNCTION SETUP-1D-ARRAY
				    ARRAY-WRONG-NUMBER-OF-DIMENSIONS
				    :ARRAY :DIMENSIONS-EXPECTED :DIMENSIONS-GIVEN
				    SIGNAL CL:ARRAY-RANK :PROCEED-TYPES :NEW-ARRAY FERROR))
  (LET ((BAR-1 (%BLOCK-REGISTER 1))
	(ALU (%READ-INTERNAL-REGISTER %REGISTER-ALU-AND-ROTATE-CONTROL)))
    (TAGBODY
      RETRY
	 (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
	 (SETF (%BLOCK-REGISTER 1) ARRAY)
	 (LET ((HEADER (%POINTER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER))))
	   (WITH-LONG-ARRAY-REGISTER ((ARRAY CONTROL ADDRESS LENGTH) (ARRAY HEADER))
	     (COMPILER:%ERROR-UNLESS (= (LDB ARRAY-LONG-DIMENSIONS-FIELD HEADER) 1)
	       (SIGNAL-PROCEED-CASE ((NEW-ARRAY)
				     'ARRAY-WRONG-NUMBER-OF-DIMENSIONS
				     :FUNCTION 'SETUP-1D-ARRAY
				     :ARRAY ARRAY
				     :DIMENSIONS-EXPECTED 1
				     :DIMENSIONS-GIVEN (CL:ARRAY-RANK ARRAY))
		 (:NEW-ARRAY
		   (SETQ ARRAY NEW-ARRAY)
		   (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
		   (WHEN (= (ARRAY-LONG-PREFIX-BIT ARRAY) 1)
		     (GO RETRY))
		   (MULTIPLE-VALUE-BIND (ARRAY CONTROL ADDRESS LENGTH)
		       (SETUP-1D-ARRAY ARRAY)
		     ARRAY CONTROL ADDRESS LENGTH
		     (SETF (%BLOCK-REGISTER 1) BAR-1)
		     (SETF (%READ-INTERNAL-REGISTER %REGISTER-ALU-AND-ROTATE-CONTROL) ALU)
		     (CLI::%RETURN-KLUDGE 4)))))
	     (SETF (%BLOCK-REGISTER 1) BAR-1)
	     (SETF (%READ-INTERNAL-REGISTER %REGISTER-ALU-AND-ROTATE-CONTROL) ALU)
	     (CLI::%RETURN-KLUDGE 4))))))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER SETUP-FORCE-1D-ARRAY TRAP-MODE-EMULATOR (ARRAY)
  (DECLARE (WIRED-FUNCTION)
	   (UNSAFEGUARDED-REFERENCE DBG:CHECK-ARG-1 ARRAY CL:ARRAY FERROR))  
  (LET ((BAR-1 (%BLOCK-REGISTER 1))
	(ALU (%READ-INTERNAL-REGISTER %REGISTER-ALU-AND-ROTATE-CONTROL)))
    (CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
    (SETF (%BLOCK-REGISTER 1) ARRAY)
    (LET ((HEADER (%POINTER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER))))
      (WITH-LONG-ARRAY-REGISTER ((ARRAY CONTROL ADDRESS LENGTH) (ARRAY HEADER))
	(SETF (%BLOCK-REGISTER 1) BAR-1)
	(SETF (%READ-INTERNAL-REGISTER %REGISTER-ALU-AND-ROTATE-CONTROL) ALU)
	(CLI::%RETURN-KLUDGE 4)))))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER ARRAY-LEADER TRAP-MODE-EMULATOR (ARRAY INDEX)
  (DECLARE (IGNORE INDEX))
  (DECLARE (UNSAFEGUARDED-REFERENCE ERROR))
  (ERROR "I don't know what to do with ~a" ARRAY))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER STORE-ARRAY-LEADER TRAP-MODE-EMULATOR
				      (VALUES ARRAY INDEX)
  (DECLARE (IGNORE VALUES INDEX))
  (DECLARE (UNSAFEGUARDED-REFERENCE ERROR))
  (ERROR "I don't know what to do with ~a" ARRAY))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER ALOC-LEADER TRAP-MODE-EMULATOR (ARRAY INDEX)
  (DECLARE (IGNORE INDEX))
  (DECLARE (UNSAFEGUARDED-REFERENCE ERROR))
  (ERROR "I don't know what to do with ~a" ARRAY))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER FAST-AREF-1 TRAP-MODE-EMULATOR
				      (I0 ARRAY-REG-LOC &PC PC)
  (DECLARE (IGNORE ARRAY-REG-LOC)
	   (SAFEGUARDED-FUNCTION DISABLE-REFERENCE-VALIDATION))
  (LET* ((OPERAND
	   (IF (TYPE-MEMBER PC DTP-EVEN-PC)
	       (%P-LDB (BYTE 10. 0.) PC)
	       (%P-LDB (BYTE 10. (BYTE-POSITION %%Q-ODD-INSTRUCTION)) PC)))
	 (ARRAY-LOC
	   (SELECT (LDB (BYTE 2. 8.) OPERAND)
	     (STACK-ADDRESSING-MODE-FRAME-POINTER
	       (%POINTER-PLUS
		 (%STACK-FRAME-POINTER)
		 (- (LDB (BYTE 8. 0.) OPERAND)
		    (LDB %%CR.CALLER-FRAME-SIZE
			 (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER))
		    1)))
	     (STACK-ADDRESSING-MODE-STACK-POINTER
	       (%POINTER-PLUS
		 (%STACK-FRAME-POINTER)
		 (- (LDB (BYTE 8. 0.) OPERAND)
		    256.)))
	     (STACK-ADDRESSING-MODE-LOCAL-POINTER
	       (%POINTER-PLUS
		 (%STACK-FRAME-POINTER)
		 (- (+ (LDB (BYTE 8. 0.) OPERAND)
		       (LDB %%CR.ARGUMENT-SIZE (%SAVED-CONTROL-REGISTER)))
		    (LDB %%CR.CALLER-FRAME-SIZE
			 (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER))
		    1)))
;	     (OTHERWISE (%POINTER-PLUS ARRAY-REG-LOC -1))
	     )))
    (SAVING-REGISTERS-FOR-VALUE (%REGISTER-BAR-1 %REGISTER-ALU-AND-ROTATE-CONTROL)
      (LET ((ARRAY (LOCATION-CONTENTS ARRAY-LOC)))
	(CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
	(SETF (%BLOCK-REGISTER 1) ARRAY)
	(LET ((HEADER (%POINTER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER))))
	  (WITH-LONG-ARRAY-REGISTER ((ARRAY CONTROL ADDRESS LENGTH) (ARRAY HEADER))
	    (SETF (%BLOCK-REGISTER 1) ARRAY-LOC)
	    (PREPARE-FOR-BLOCK-WRITE)
	    (%BLOCK-WRITE 1 ARRAY)
	    (%BLOCK-WRITE 1 CONTROL)
	    (%BLOCK-WRITE 1 ADDRESS)
	    (%BLOCK-WRITE 1 LENGTH)
	    (FAST-AREF-1 I0 CONTROL)))))))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER FAST-ASET-1 TRAP-MODE-EMULATOR
				      (VALUE I0 ARRAY-REG-LOC &PC PC)
  (DECLARE (IGNORE ARRAY-REG-LOC)
	   (SAFEGUARDED-FUNCTION DISABLE-REFERENCE-VALIDATION))
  (LET* ((OPERAND
	   (IF (TYPE-MEMBER PC DTP-EVEN-PC)
	       (%P-LDB (BYTE 10. 0.) PC)
	       (%P-LDB (BYTE 10. (BYTE-POSITION %%Q-ODD-INSTRUCTION)) PC)))
	 (ARRAY-LOC
	   (SELECT (LDB (BYTE 2. 8.) OPERAND)
	     (STACK-ADDRESSING-MODE-FRAME-POINTER
	      (%POINTER-PLUS
		(%STACK-FRAME-POINTER)
		(- (LDB (BYTE 8. 0.) OPERAND)
		   (LDB %%CR.CALLER-FRAME-SIZE
			(%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER))
		   1)))
	     (STACK-ADDRESSING-MODE-STACK-POINTER
	      (%POINTER-PLUS
		(%STACK-FRAME-POINTER)
		(- (LDB (BYTE 8. 0.) OPERAND)
		   255.)))
	     (STACK-ADDRESSING-MODE-LOCAL-POINTER
	      (%POINTER-PLUS
		(%STACK-FRAME-POINTER)
		(- (+ (LDB (BYTE 8. 0.) OPERAND)
		      (LDB %%CR.ARGUMENT-SIZE (%SAVED-CONTROL-REGISTER)))
		   (LDB %%CR.CALLER-FRAME-SIZE
			(%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER))
		   1)))
;	     (OTHERWISE (%POINTER-PLUS ARRAY-REG-LOC -1))
	     )))
    (SAVING-REGISTERS-FOR-EFFECT (%REGISTER-BAR-1 %REGISTER-ALU-AND-ROTATE-CONTROL)
      (LET ((ARRAY (LOCATION-CONTENTS ARRAY-LOC)))
	(CHECK-ARG ARRAY (TYPE-MEMBER ARRAY DTP-ARRAY DTP-STRING) "an array")
	(SETF (%BLOCK-REGISTER 1) ARRAY)
	(LET ((HEADER (%POINTER (%BLOCK-READ 1 :CYCLE-TYPE %MEMORY-HEADER))))
	  (WITH-LONG-ARRAY-REGISTER ((ARRAY CONTROL ADDRESS LENGTH) (ARRAY HEADER))
	    (SETF (%BLOCK-REGISTER 1) ARRAY-LOC)
	    (PREPARE-FOR-BLOCK-WRITE)
	    (%BLOCK-WRITE 1 ARRAY)
	    (%BLOCK-WRITE 1 CONTROL)
	    (%BLOCK-WRITE 1 ADDRESS)
	    (%BLOCK-WRITE 1 LENGTH)
	    (FAST-ASET-1 VALUE I0 CONTROL))))))
  (%RETURN-KLUDGE-0))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER CAR TRAP-MODE-EMULATOR (CONS)
  (DECLARE (UNSAFEGUARDED-REFERENCE ERROR))
  (ERROR "I don't know what to do with ~a" CONS))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER CDR TRAP-MODE-EMULATOR (CONS)
  (DECLARE (UNSAFEGUARDED-REFERENCE ERROR))
  (ERROR "I don't know what to do with ~a" CONS))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER RPLACA TRAP-MODE-EMULATOR (CONS X)
  (DECLARE (UNSAFEGUARDED-REFERENCE ERROR))
  (DECLARE (IGNORE X))
  (ERROR "I don't know what to do with ~a" CONS))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER RPLACD TRAP-MODE-EMULATOR (CONS X)
  (DECLARE (SAFEGUARDED-FUNCTION DISABLE-REFERENCE-VALIDATION))
  (BLOCK RPLACD-TRAP-HANDLER
    ;; Check for silly cases that don't require error checking and storage allocation
    ;;--- This has to be updated to do the hairy stuff that 3600 RPLACD-ESCAPE does
    ;;--- with NREVERSE and consecutive conses.
    (WHEN (NULL X)
      (WITHOUT-INTERRUPTS
	;; This check is to make sure it didn't change into a CDR-NORMAL or
	;; a DTP-HEADER-FORWARD while the microcode was trapping out
	(WHEN (= (%P-CDR-CODE CONS) CDR-NEXT)
	  (%P-STORE-CDR-CODE CONS CDR-NIL)
	  (RETURN-FROM RPLACD-TRAP-HANDLER (VALUES)))))
    (WHEN (EQ (CDR CONS) X)
      (RETURN-FROM RPLACD-TRAP-HANDLER (VALUES)))
    (LET ((REGION (%REGION-NUMBER CONS)) BITS)
      (WHEN (OR (NULL REGION)
		( (%LOGLDB %%REGION-REPRESENTATION-TYPE (SETQ BITS (REGION-BITS REGION)))
		   %REGION-REPRESENTATION-TYPE-LIST)
		(LDB-TEST %%REGION-STACK BITS))
	(ERROR "Attempt to RPLACD a list that is embedded in a ~:[structure~;stack~] and
therefore cannot be RPLACD'ed.  The list is ~S"
	       (LDB-TEST %%REGION-STACK BITS) CONS))
      (LET ((NEW-CONS (CONS-IN-AREA NIL X (REGION-AREA REGION))))
	(WITHOUT-INTERRUPTS
	  (SETF (CAR NEW-CONS) (CAR CONS))
;	  (WHEN (TYPE-MEMBER (CAR CONS) DTP-LOGIC-VARIABLE)
;	    ;; The CAR is an unbound logic variable, relocate it to the new place
;	    (%P-STORE-CDR-TYPE-AND-POINTER NEW-CONS CDR-NORMAL DTP-LOGIC-VARIABLE NEW-CONS))
	  (%P-STORE-CDR-TYPE-AND-POINTER CONS CDR-NIL DTP-HEADER-FORWARD NEW-CONS)
	  (VALUES)))))
  (%RETURN-KLUDGE-0))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER SET-TO-CAR TRAP-MODE-EMULATOR (CONS)
  (DECLARE (UNSAFEGUARDED-REFERENCE ERROR))
  (ERROR "I don't know what to do with ~a" CONS))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER SET-TO-CDR TRAP-MODE-EMULATOR (CONS)
  (DECLARE (UNSAFEGUARDED-REFERENCE ERROR))
  (ERROR "I don't know what to do with ~a" CONS))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER SET-TO-CDR-PUSH-CAR TRAP-MODE-EMULATOR (CONS)
  (DECLARE (UNSAFEGUARDED-REFERENCE ERROR))
  (ERROR "I don't know what to do with ~a" CONS))

;;; WITH-STACK-INSTANCE is to MAKE-INSTANCE as WITH-STACK-ARRAY is to MAKE-ARRAY
(DEFMACRO WITH-STACK-INSTANCE ((VAR FLAVOR . INIT-OPTIONS) &BODY BODY &AUX FLAVOR-STRUCTURE)
  (LET ((AREA-KEYWORD (COND ((AND (CL:CONSP FLAVOR)
				  (EQ (FIRST FLAVOR) 'QUOTE)
				  (CL:CONSP (CDR FLAVOR))
				  (SYMBOLP (SECOND FLAVOR))
				  (NULL (CDDR FLAVOR))
				  (SETQ FLAVOR-STRUCTURE
					(FLAVOR::FIND-FLAVOR (SECOND FLAVOR) NIL 'COMPILE))
				  (FLAVOR::FLAVOR-AREA-KEYWORD FLAVOR-STRUCTURE)))
			    (T ':AREA))))
    ;; Don't provide an area keyword in options!
    ;;--- Really no need to check for this, since it will never be seen
    (WHEN (CL:MEMBER AREA-KEYWORD INIT-OPTIONS)	;even if he says :AREA NIL
      (ERROR "You tried to specify an area for a stack-consed instance: ~S ~S"
	     AREA-KEYWORD (CL:GETF INIT-OPTIONS AREA-KEYWORD)))
    `(WITH-DATA-STACK				;clean up after ourselves
       ;; Make an instance on the data stack with the right options
       (LET ((,VAR (MAKE-INSTANCE ,FLAVOR ',AREA-KEYWORD :STACK ,@INIT-OPTIONS)))
	 ;; Execute the body with var bound to the instance
	 ,@BODY))))

;The argument must really be a structure, not a locative into the middle
;of something, and must not be in list space.  We store DTP-HEADER-FORWARD
;and DTP-ELEMENT-FORWARDs from the old instance to the new instance, and return the old.
(DEFUN STRUCTURE-FORWARD (OLD NEW &OPTIONAL (OLD-HEADER-SIZE 1) (NEW-HEADER-SIZE 1))
  (OR (= (%DATA-TYPE OLD) (%DATA-TYPE NEW))
      (FERROR "~S and ~S seem incompatible" OLD NEW))
  (OR (= (%LOGLDB %%REGION-REPRESENTATION-TYPE (REGION-BITS (%REGION-NUMBER OLD)))
       %REGION-REPRESENTATION-TYPE-STRUCTURE)
      (FERROR "~S is not in a structure region" OLD))
  (WHEN (EQ OLD (FOLLOW-STRUCTURE-FORWARDING NEW))
    (FERROR "Attempt to structure-forward ~S to itself" OLD))
  ;; Don't let anything move while in inconsistent state
  (WITHOUT-INTERRUPTS-AND-STACK-OVERFLOWS (200.)
    (MACROLET ((FORWARD-ELEMENTS
		 (OLD-START OLD-SIZE NEW-START NEW-SIZE RANDOM-PLACE)
		 ;; This has to be a macro because the compiler is too
		 ;; stupid to recognize an inline declaration
		 (ONCE-ONLY (OLD-START OLD-SIZE NEW-START NEW-SIZE)
		   `(LET ((SIZE (MIN ,OLD-SIZE ,NEW-SIZE)))
		      ;; Forward the old elements which have corresponding
		      ;; new elements to these new elements
		      (%BLOCK-STORE-TAG-AND-POINTER
			,OLD-START SIZE DTP-ELEMENT-FORWARD ,NEW-START 1)
		      ;; To maintain storage integrity, we have to forward any old
		      ;; elements which have no new elements to some random place
		      (WHEN (> ,OLD-SIZE SIZE)
			(%BLOCK-STORE-TAG-AND-POINTER
			  (%MAKE-POINTER-OFFSET DTP-LOCATIVE ,OLD-START SIZE)
			  (- ,OLD-SIZE SIZE)
			  DTP-ELEMENT-FORWARD
			  ,RANDOM-PLACE
			  0))))))
      (FLET ((FORWARD-HEADER-AND-ELEMENTS
		(OLD-HEADER OLD-HEADER-SIZE OLD-ELEMENT-SIZE
		 NEW-HEADER NEW-HEADER-SIZE NEW-ELEMENT-SIZE
		 RANDOM-PLACE)
	       ;; Forward the old header to the new header
	       (%P-STORE-TAG-AND-POINTER OLD-HEADER DTP-HEADER-FORWARD NEW-HEADER)
	       ;; Forward the old header elements
	       (FORWARD-ELEMENTS
		 (%MAKE-POINTER-OFFSET DTP-LOCATIVE OLD-HEADER 1)
		 (1- OLD-HEADER-SIZE)
		 (%MAKE-POINTER-OFFSET DTP-LOCATIVE NEW-HEADER 1)
		 (1- NEW-HEADER-SIZE)
		 RANDOM-PLACE)
	       ;; Forward the old elements to the new elements
	       (FORWARD-ELEMENTS
		 (%MAKE-POINTER-OFFSET DTP-LOCATIVE OLD-HEADER OLD-HEADER-SIZE)
		 OLD-ELEMENT-SIZE
		 (%MAKE-POINTER-OFFSET DTP-LOCATIVE NEW-HEADER NEW-HEADER-SIZE)
		 NEW-ELEMENT-SIZE
		 RANDOM-PLACE)))
	(MULTIPLE-VALUE-BIND (OLD-HEADER OLD-LEADER OLD-TOTAL-SIZE)
	    (%FIND-STRUCTURE-EXTENT OLD)
	  (MULTIPLE-VALUE-BIND (NEW-HEADER NEW-LEADER NEW-TOTAL-SIZE)
	      (%FIND-STRUCTURE-EXTENT NEW)
	    (LET ((OLD-LEADER-SIZE (%POINTER-DIFFERENCE OLD-HEADER OLD-LEADER))
		  (NEW-LEADER-SIZE (%POINTER-DIFFERENCE NEW-HEADER NEW-LEADER))
		  (RANDOM-PLACE
		    (%MAKE-POINTER-OFFSET DTP-LOCATIVE NEW-LEADER (1- NEW-TOTAL-SIZE))))
	      (COND ((ZEROP OLD-LEADER-SIZE))
		    ((ZEROP NEW-LEADER-SIZE)
		     ;; We have to forward the old leader someplace, so we'll just
		     ;; forward the leader header to the structure header, and the
		     ;; leader elements to the last structure element.
		     (FORWARD-HEADER-AND-ELEMENTS
		       OLD-LEADER 1 (1- OLD-LEADER-SIZE)
		       NEW-HEADER 1 0
		       RANDOM-PLACE))
		    (T (FORWARD-HEADER-AND-ELEMENTS
			 OLD-LEADER 1 (1- OLD-LEADER-SIZE)
			 NEW-LEADER 1 (1- NEW-LEADER-SIZE)
			 RANDOM-PLACE)))
	      (FORWARD-HEADER-AND-ELEMENTS
		OLD-HEADER
		OLD-HEADER-SIZE
		(- OLD-TOTAL-SIZE OLD-HEADER-SIZE OLD-LEADER-SIZE)
		NEW-HEADER
		NEW-HEADER-SIZE
		(- NEW-TOTAL-SIZE NEW-HEADER-SIZE NEW-LEADER-SIZE)
		RANDOM-PLACE))))))
    (ARRAY-REGISTER-EVENT))
  OLD)
