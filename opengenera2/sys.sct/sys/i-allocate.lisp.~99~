;;; -*- Package:SYSTEM-INTERNALS; Mode:LISP; Base:8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; I-machine specific storage allocation
;;; This file is in the cold load.

;;; On the I machine, there are two caches, one for lists and one for structures.
;;; The transporter does not make use of the cache.  Each cache is kept in three
;;; internal registers.

(DEFMACRO %LIST-CACHE-AREA ()
  `(%READ-INTERNAL-REGISTER %REGISTER-LIST-CACHE-AREA))
(DEFMACRO %LIST-CACHE-VIRTUAL-ADDRESS ()
  `(%POINTER (%READ-INTERNAL-REGISTER %REGISTER-LIST-CACHE-ADDRESS)))
;; This isn't legitimate CL.  Fix when the compiler won't compile it stupidly.
(CL:DEFSETF %LIST-CACHE-VIRTUAL-ADDRESS () (ADDRESS)
  `(SETF (%READ-INTERNAL-REGISTER %REGISTER-LIST-CACHE-ADDRESS)
	 (%MAKE-POINTER DTP-LIST ,ADDRESS)))
(DEFMACRO %LIST-CACHE-LENGTH ()
  `(%READ-INTERNAL-REGISTER %REGISTER-LIST-CACHE-LENGTH))
(DEFVAR-WIRED %LIST-CACHE-REGION)		;Used by STORAGE as well
(DEFMACRO %LIST-CACHE-REGION ()
  '%LIST-CACHE-REGION)

(DEFMACRO %STRUCTURE-CACHE-AREA ()
  `(%READ-INTERNAL-REGISTER %REGISTER-STRUCTURE-CACHE-AREA))
(DEFMACRO %STRUCTURE-CACHE-VIRTUAL-ADDRESS ()
  `(%POINTER (%READ-INTERNAL-REGISTER %REGISTER-STRUCTURE-CACHE-ADDRESS)))
;; This isn't legitimate CL.  Fix when the compiler won't compile it stupidly.
(CL:DEFSETF %STRUCTURE-CACHE-VIRTUAL-ADDRESS () (ADDRESS)
  `(SETF (%READ-INTERNAL-REGISTER %REGISTER-STRUCTURE-CACHE-ADDRESS)
	 (%MAKE-POINTER DTP-LOCATIVE ,ADDRESS)))
(DEFMACRO %STRUCTURE-CACHE-LENGTH ()
  `(%READ-INTERNAL-REGISTER %REGISTER-STRUCTURE-CACHE-LENGTH))
(DEFVAR-WIRED %STRUCTURE-CACHE-REGION)		;Used by STORAGE as well
(DEFMACRO %STRUCTURE-CACHE-REGION ()
  '%STRUCTURE-CACHE-REGION)

;; These are initialized by the cold load generator.
(DEFVAR-SAFEGUARDED *ZONE-LEVEL*)
(DEFVAR-WIRED *DEMILEVEL-LEVEL*)		;Referenced by GC-PAGE-OUT
(DEFVAR-SAFEGUARDED *EPHEMERAL-LEVEL-GROUP*)

(DEFMACRO %ZONE-OLDSPACE-REGISTER ()
  '(%READ-INTERNAL-REGISTER %REGISTER-ZONE-OLDSPACE-REGISTER))

(DEFMACRO %EPHEMERAL-OLDSPACE-REGISTER ()
  '(%READ-INTERNAL-REGISTER %REGISTER-EPHEMERAL-OLDSPACE-REGISTER))

(DEFSUBST ZONE-OLDSPACE-P (ZONE)
  (BIT-MEMBER ZONE (%ZONE-OLDSPACE-REGISTER)))

(DEFSUBST DEMILEVEL-OLDSPACE-P (DEMILEVEL)
  (BIT-MEMBER DEMILEVEL
	      (LOGXOR (- (LDB %%DEMILEVEL-EPHEMERAL-HALF DEMILEVEL) 1)
		      (%EPHEMERAL-OLDSPACE-REGISTER))))

(DEFSUBST OTHER-DEMILEVEL (DEMILEVEL)
  (LOGXOR DEMILEVEL (DPB 1 %%DEMILEVEL-EPHEMERAL-HALF 0)))

;; A demilevel is available if it is newspace or if it could be made newspace
;; without flipping something else.
(DEFSUBST DEMILEVEL-AVAILABLE-FOR-ALLOCATION (DEMILEVEL)
  (OR (NOT (DEMILEVEL-OLDSPACE-P DEMILEVEL))
      (NOT (LEVEL-VALID-P (DEMILEVEL-LEVEL (OTHER-DEMILEVEL DEMILEVEL))))))

;;--- This implements a stupid policy right now.
(DEFUN ASSIGN-EPHEMERAL-LEVEL-GROUPS ()
  (WITH-FAST-STORAGE-ACCESSORS (EPHEMERAL-LEVEL-GROUP)
    (LET ((TOP-LEVEL (CADR (CL:ASSOC 'WORKING-STORAGE-AREA *EPHEMERAL-AREAS*))))
      (DOTIMES (LEVEL %NUMBER-OF-EPHEMERAL-LEVELS)
	(SETF (EPHEMERAL-LEVEL-GROUP LEVEL)
	      (IF (EQ LEVEL TOP-LEVEL)
		  0
		  (1+ (MOD LEVEL 3))))))))

(DEFMACRO WITH-LIST-CACHE-DEFINITIONS (&BODY BODY)
  `(MACROLET ((%CACHE-REGION () `(%LIST-CACHE-REGION))
	      (%CACHE-AREA () `(%LIST-CACHE-AREA))
	      (%CACHE-ADDRESS () `(%LIST-CACHE-VIRTUAL-ADDRESS))
	      (%CACHE-LENGTH () `(%LIST-CACHE-LENGTH))
	      (REPRESENTATION-TYPE () '%REGION-REPRESENTATION-TYPE-LIST))
     (%MAKE-POINTER DTP-LIST (PROGN ,@BODY))))

(DEFMACRO WITH-STRUCTURE-CACHE-DEFINITIONS (&BODY BODY)
  `(MACROLET ((%CACHE-REGION () `(%STRUCTURE-CACHE-REGION))
	      (%CACHE-AREA () `(%STRUCTURE-CACHE-AREA))
	      (%CACHE-ADDRESS () `(%STRUCTURE-CACHE-VIRTUAL-ADDRESS))
	      (%CACHE-LENGTH () `(%STRUCTURE-CACHE-LENGTH))
	      (REPRESENTATION-TYPE () '%REGION-REPRESENTATION-TYPE-STRUCTURE))
     (%MAKE-POINTER DTP-LOCATIVE (PROGN ,@BODY))))

(DEFMACRO ALLOCATE-ESCAPE-BODY ()
  `(PROGN
     ;; This doesn't need to worry about overflow as long as the caller
     ;; was in emulator mode.
     ;; I'll blame Cyphers for forcing me into such a kludge...
     (MACROLET ((INSTRUCTION (&ENVIRONMENT ENV)
		  (CL:ECASE (MACROEXPAND '(REPRESENTATION-TYPE) ENV)
		    (%REGION-REPRESENTATION-TYPE-STRUCTURE
		      "%ALLOCATE-STRUCTURE-BLOCK")
		    (%REGION-REPRESENTATION-TYPE-LIST
		      "%ALLOCATE-LIST-BLOCK"))))
       (COMPILER:%ERROR-UNLESS (= (LDB %%CR.TRAP-MODE (%SAVED-CONTROL-REGISTER))
				  TRAP-MODE-EMULATOR)
	 (WIRED-FERROR :PROCEEDABLE-HALT "~A executed while not in emulator mode"
		       (INSTRUCTION)))
       (COMPILER:%ERROR-UNLESS (AND (FIXNUMP AREA)
				    (NOT (MINUSP AREA))
				    (< AREA (N-AREAS)))
	 (FERROR "The first argument to the ~A instruction, ~S, was not a valid area"
		 (INSTRUCTION) AREA))
       (COMPILER:%ERROR-UNLESS (PLUSP LENGTH)
	 (FERROR "The second argument to the ~A instruction, ~S, was not a positive fixnum"
		 (INSTRUCTION) LENGTH)))
     (WITHOUT-INTERRUPTS-AND-STACK-OVERFLOWS (700.)	;new upper limit, was 500 -- KR & ptw
       (PROG ((WORK-DONE NIL)
	      (CACHED-REGION NIL)
	      (REGION NIL)
	      (ORIGIN NIL)
	      (FREE-POINTER NIL)
	      (FIRST-ADDRESS-TO-CREATE NIL))
	RETRY
	  (SETQ CACHED-REGION (%CACHE-REGION))
	  (UPDATE-CONS-CACHE-REGION-FREE-POINTERS)
	  (COND ((AND (EQL AREA (%CACHE-AREA))
		      ( (+ (REGION-FREE-POINTER CACHED-REGION) LENGTH)
			 (REGION-LENGTH CACHED-REGION)))
		 ;; Allocating from the cached region
		 (SETQ REGION CACHED-REGION
		       ORIGIN (REGION-ORIGIN REGION)
		       ;; Update free-pointer from cache
		       FREE-POINTER (REGION-FREE-POINTER REGION)
		       FIRST-ADDRESS-TO-CREATE (+ (REGION-CREATED-PAGES REGION) ORIGIN)))
		(T (SETQ CACHED-REGION NIL	;that wasn't valid
			 REGION (ALLOCATE-OR-EXTEND-REGION AREA LENGTH
				  (%LOGDPBS (IF (ZEROP *INHIBIT-READ-ONLY-IN-PROGRESS*) 1 0)
					    %%REGION-READ-ONLY
					    -1 %%REGION-REPRESENTATION-TYPE
					    -1 %%REGION-LEVEL
					    -1 %%REGION-SPACE-TYPE
					    -1 %%REGION-NO-CONS 0)
				  (LET ((AREA-BITS (AREA-REGION-BITS AREA)))
				    (%LOGDPBS
				      (LDB %%REGION-LEVEL AREA-BITS) %%REGION-LEVEL
				      (LDB %%REGION-SPACE-TYPE AREA-BITS) %%REGION-SPACE-TYPE
				      (REPRESENTATION-TYPE) %%REGION-REPRESENTATION-TYPE
				      0 %%REGION-NO-CONS
				      0 %%REGION-READ-ONLY 0)))
			 ORIGIN (REGION-ORIGIN REGION)
			 FREE-POINTER (REGION-FREE-POINTER REGION)
			 FIRST-ADDRESS-TO-CREATE (+ (REGION-CREATED-PAGES REGION) ORIGIN))))
	  (LET ((NEW-END (ROUND-TO-CHUNK (+ ORIGIN FREE-POINTER LENGTH)))
		;; This is a post-trap, so we do our own allocation
		(NEW-FREE-POINTER (+ FREE-POINTER LENGTH)))
	    (SETQ WORK-DONE (- NEW-END FIRST-ADDRESS-TO-CREATE))
	    (WHEN (PLUSP WORK-DONE)
	      #-VLM
	      (WHEN (= (REPRESENTATION-TYPE) %REGION-REPRESENTATION-TYPE-STRUCTURE)
		(WHEN (= REGION 1)
		  (REGION-ONE-OVERFLOW LENGTH)
		  (GO RETRY)))
	      (CREATE-PAGES FIRST-ADDRESS-TO-CREATE WORK-DONE)
	      (SETF (REGION-CREATED-PAGES REGION) (- NEW-END ORIGIN)))
	    (SETF (REGION-FREE-POINTER REGION) NEW-FREE-POINTER)
	    ;; Maybe refill the cache
	    (WHEN (%CACHE-AREA)
	      (DECF *CONS-WORK-DONE* (%CACHE-LENGTH)))
	    (UNLESS (EQL REGION CACHED-REGION)
	      (SETF (%CACHE-REGION) REGION)
	      (SETF (%CACHE-AREA) AREA))
	    ;; Update the cache length if appropriate
	    (SETF (%CACHE-ADDRESS) (+ ORIGIN NEW-FREE-POINTER))
	    (SETF (%CACHE-LENGTH) (- NEW-END NEW-FREE-POINTER ORIGIN))
	    (INCF *CONS-WORK-DONE* (- NEW-END FREE-POINTER ORIGIN)))
	(WHEN (PLUSP WORK-DONE)
	  (NOTE-CONS-WORK-DONE WORK-DONE))
	;; Set the trap mode and that of the trapping frame to extra-stack
	(%SET-TRAP-MODE TRAP-MODE-EXTRA-STACK)
	(%P-DPB TRAP-MODE-EXTRA-STACK %%CR.TRAP-MODE (LOCF (%SAVED-CONTROL-REGISTER)))
	(LET ((POINTER (%POINTER-PLUS ORIGIN FREE-POINTER)))
	  (SETF (%BLOCK-REGISTER 1) POINTER)
	  (RETURN POINTER))))))

(DEFSUBST %CLEAR-CACHES () NIL)

(DEFUN UPDATE-CONS-CACHE-REGION-FREE-POINTERS ()
  (DECLARE (SAFEGUARDED-FUNCTION))
  (WITHOUT-INTERRUPTS
    (WHEN (%STRUCTURE-CACHE-AREA)
      (LET ((REGION (%STRUCTURE-CACHE-REGION)))
	(SETF (REGION-FREE-POINTER REGION)
	      (%POINTER-DIFFERENCE (%READ-INTERNAL-REGISTER %REGISTER-STRUCTURE-CACHE-ADDRESS)
				   (REGION-ORIGIN REGION)))))
    (WHEN (%LIST-CACHE-AREA)
      (LET ((REGION (%LIST-CACHE-REGION)))
	(SETF (REGION-FREE-POINTER REGION)
	      (%POINTER-DIFFERENCE (%READ-INTERNAL-REGISTER %REGISTER-LIST-CACHE-ADDRESS)
				   (REGION-ORIGIN REGION)))))))

(DEFUN CLEAR-CONS-CACHES ()
  (DECLARE (SAFEGUARDED-FUNCTION))
  (WITHOUT-INTERRUPTS
    (WHEN (%STRUCTURE-CACHE-AREA)
      (DECF *CONS-WORK-DONE* (%STRUCTURE-CACHE-LENGTH))
      (LET ((REGION (%STRUCTURE-CACHE-REGION)))
	(SETF (REGION-FREE-POINTER REGION)
	      (%POINTER-DIFFERENCE
		(%READ-INTERNAL-REGISTER %REGISTER-STRUCTURE-CACHE-ADDRESS)
		(REGION-ORIGIN REGION))))
      (SETF (%STRUCTURE-CACHE-AREA) NIL)
      (SETF (%STRUCTURE-CACHE-REGION) NIL))
    (WHEN (%LIST-CACHE-AREA)
      (DECF *CONS-WORK-DONE* (%LIST-CACHE-LENGTH))
      (LET ((REGION (%LIST-CACHE-REGION)))
	(SETF (REGION-FREE-POINTER REGION)
	      (%POINTER-DIFFERENCE
		(%READ-INTERNAL-REGISTER %REGISTER-LIST-CACHE-ADDRESS)
		(REGION-ORIGIN REGION))))
      (SETF (%LIST-CACHE-AREA) NIL)
      (SETF (%LIST-CACHE-REGION) NIL))))

#-VLM
(DEFUN REGION-ONE-OVERFLOW (LENGTH)
  (PROG* ((FREE (REGION-FREE-POINTER 1))
	  (ORIGIN (REGION-ORIGIN 1))
	  (FREE-ADDRESS (+ ORIGIN FREE)))
    ;; Fix up initialization of end of wired space.  These are exclusive upper bounds
    ;; and should lie on a page boundary.  They tend to get initialized to be equal
    ;; to the free-pointer of WIRED-CONTROL-TABLES.
    (SETQ %WIRED-VIRTUAL-ADDRESS-HIGH (LOGAND (+ %WIRED-VIRTUAL-ADDRESS-HIGH PAGE-SIZE -1)
					      (- PAGE-SIZE)))
    (SETQ %WIRED-PHYSICAL-ADDRESS-HIGH (LOGAND (+ %WIRED-PHYSICAL-ADDRESS-HIGH PAGE-SIZE -1)
					       (- PAGE-SIZE)))
    ;; Make sure no one has been consing
    (WHEN (> FREE-ADDRESS %WIRED-VIRTUAL-ADDRESS-HIGH)
      (FERROR "Objects have been allocated past the wired part of WIRED-CONTROL-TABLES."))
    ;; Make sure that the space is empty.
    (%BLOCK-STORE-TAG-AND-POINTER FREE-ADDRESS (- %WIRED-VIRTUAL-ADDRESS-HIGH FREE-ADDRESS)
				  DTP-NULL FREE-ADDRESS 1)
    ;; Tell the conser that the pages are already created
    (SETF (REGION-CREATED-PAGES 1) (%POINTER-DIFFERENCE %WIRED-VIRTUAL-ADDRESS-HIGH ORIGIN))
    (LET ((TARGET (ROUND-TO-CHUNK (+ FREE-ADDRESS LENGTH))))
      ;; Are we really out of space?
      (UNLESS (> TARGET %WIRED-VIRTUAL-ADDRESS-HIGH) (RETURN NIL))
      ;; Yep, we're out of space.
      (FERROR "Insufficient wired space to allocate block of ~D words.~@
	       In order to continue, a minimum of ~D more wired words are needed.~@
	       If none of the proceed options below are satisfactory, your only option~@
	       would be to start over by cold booting with sufficient wired space.~@
	       With ~D additional words for safety, you would do this by halting~@
	       the machine and doing~@
	       ~3@T~~A~:[~;~%Enable IDS~]~@
		     Set Wired Addresses ~\SI:ADDRESS\~@
		     Start~%~"
	      LENGTH
	      (- TARGET %WIRED-VIRTUAL-ADDRESS-HIGH) %ADDRESS-SPACE-CHUNK-SIZE
	      (FOOLPROOF-REBOOTING-COMMAND)
	      *SYSOUT-ENABLED-P*
	      (+ TARGET %ADDRESS-SPACE-CHUNK-SIZE)))))

(DEFWIREDFUN REAL-REGION-FREE-POINTER (REGION)
  ;; This must run without interrupts, and must be runnable on the aux stack.
  (COMPILER:%ERROR-WHEN (= (%TRAP-MODE) TRAP-MODE-EMULATOR)
    (%SET-TRAP-MODE TRAP-MODE-EXTRA-STACK))
  (COND ((AND (%STRUCTURE-CACHE-AREA) (EQL REGION (%STRUCTURE-CACHE-REGION)))
	 (%POINTER-DIFFERENCE
	   (%READ-INTERNAL-REGISTER %REGISTER-STRUCTURE-CACHE-ADDRESS) (REGION-ORIGIN REGION)))
	((AND (%LIST-CACHE-AREA) (EQL REGION (%LIST-CACHE-REGION)))
	 (%POINTER-DIFFERENCE
	   (%READ-INTERNAL-REGISTER %REGISTER-LIST-CACHE-ADDRESS) (REGION-ORIGIN REGION)))
	(T (REGION-FREE-POINTER REGION))))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER %ALLOCATE-LIST-BLOCK TRAP-MODE-EMULATOR
				      (AREA LENGTH)
  (DECLARE (SAFEGUARDED-FUNCTION DISABLE-REFERENCE-VALIDATION))
  (SAVING-REGISTERS-FOR-VALUE (%REGISTER-ALU-AND-ROTATE-CONTROL)
    (SAVING-ROTATE-LATCH
      (CLI::WITH-FLOATING-POINT-STATUS-SAVED-FOR-TRAP
	(PROGN
	  (CHECK-FOR-GC-WAITING-TO-FLIP)
	  (WHEN *INHIBIT-CONSING-FLAG*
	    ;; Try to get into the Debugger in the cold-load stream.  This tries
	    ;; to catch such things as accidental bignum consing in the transporter.
	    (LET ((*INHIBIT-CONSING-FLAG* NIL)
		  (CL:*DEBUG-IO* "Internal error"))
	      (ERROR "Internal error: %ALLOCATE- while *INHIBIT-CONSING-FLAG* is set.")))
	  (WITH-LIST-CACHE-DEFINITIONS (ALLOCATE-ESCAPE-BODY)))))))

(DEFINE-INSTRUCTION-EXCEPTION-HANDLER %ALLOCATE-STRUCTURE-BLOCK TRAP-MODE-EMULATOR
				      (AREA LENGTH)
  (DECLARE (SAFEGUARDED-FUNCTION DISABLE-REFERENCE-VALIDATION))
  (SAVING-REGISTERS-FOR-VALUE (%REGISTER-ALU-AND-ROTATE-CONTROL)
    (SAVING-ROTATE-LATCH
      (CLI::WITH-FLOATING-POINT-STATUS-SAVED-FOR-TRAP
	(PROGN
	  (CHECK-FOR-GC-WAITING-TO-FLIP)
	  (WHEN *INHIBIT-CONSING-FLAG*
	    ;; Try to get into the Debugger in the cold-load stream.  This tries
	    ;; to catch such things as accidental bignum consing in the transporter.
	    (LET ((*INHIBIT-CONSING-FLAG* NIL)
		  (CL:*DEBUG-IO* "Internal error"))
	      (ERROR "Internal error: %ALLOCATE- while *INHIBIT-CONSING-FLAG* is set.")))
	  (WITH-STRUCTURE-CACHE-DEFINITIONS (ALLOCATE-ESCAPE-BODY)))))))

;; I think this is faster than a bunch of comparisons.
(DEFUN %POINTER-TYPE-P (DATA-TYPE-NUMBER)
  (DECLARE (WIRED-FUNCTION))
  (AREF '#.(LET ((ARRAY (MAKE-ARRAY (LENGTH *DATA-TYPES*) :TYPE ART-BOOLEAN)))
	     (DOLIST (TYPE *POINTER-DATA-TYPES*)
	       (SETQ TYPE (SYMEVAL TYPE))
	       (SETF (AREF ARRAY TYPE) T))
	     ARRAY)
	DATA-TYPE-NUMBER))

;; Make the pointer-type-p array available for inner loops which want to make it an
;; array register.
(DEFVAR-SAFEGUARDED *POINTER-TYPE-P*)

;; The cold-load generator sucks.
(DEFUN INITIALIZE-POINTER-TYPE-P-ARRAY ()
  (SETQ *POINTER-TYPE-P* (%P-CONTENTS-OFFSET #'%POINTER-TYPE-P 1)))
(INITIALIZE-POINTER-TYPE-P-ARRAY)


;;; Allocation interface to address space map

(DEFUN %ADDRESS-SPACE-AVAILABLE-P (QUANTUM-ORIGIN &OPTIONAL (N-QUANTA 1))
  (DECLARE (SAFEGUARDED-FUNCTION))
  (LOOP FOR QUANTUM FROM QUANTUM-ORIGIN REPEAT N-QUANTA
	NEVER (%REGION-NUMBER (%LOGDPB QUANTUM %%VMA-QUANTUM-NUM 0))))

(DEFUN %SET-ADDRESS-SPACE-MAP (QUANTUM-ORIGIN QUANTUM-LENGTH REGION-OR-NIL)
  (DECLARE (SAFEGUARDED-FUNCTION))
  (%FUNCALL-IN-AUX-STACK #'STORAGE::%AUX-SET-ADDRESS-SPACE-MAP
			 QUANTUM-ORIGIN QUANTUM-LENGTH REGION-OR-NIL))

(DEFUN COPY-EXTENDED-NUMBER (OLD &OPTIONAL (AREA DEFAULT-CONS-AREA))
  (CHECK-ARG-TYPE OLD :EXTENDED-NUMBER)
  (COND ((TYPEP OLD :BIGNUM)
	 (SETQ OLD (FOLLOW-STRUCTURE-FORWARDING OLD))
	 (LET* ((SIZE (%STRUCTURE-TOTAL-SIZE OLD))
		(NEW (%MAKE-STRUCTURE DTP-BIGNUM DTP-HEADER-I
				      (%P-LDB %%HEADER-TYPE-FIELD OLD) (%P-POINTER OLD)
				      AREA SIZE)))
	   (%BLOCK-SCAVENGE-COPY
	     (%MAKE-POINTER-OFFSET DTP-LOCATIVE OLD 1)
	     (%MAKE-POINTER-OFFSET DTP-LOCATIVE NEW 1)
	     (1- SIZE))
	   NEW))
	(T (LET ((WORD0 (%MEMORY-READ OLD))
		 (WORD1 (%MEMORY-READ (%POINTER-PLUS OLD 1))))
	     (WHEN (TYPEP WORD0 :EXTENDED-NUMBER)
	       (SETQ WORD0 (COPY-EXTENDED-NUMBER WORD0 AREA)))
	     (WHEN (TYPEP WORD1 :EXTENDED-NUMBER)
	       (SETQ WORD0 (COPY-EXTENDED-NUMBER WORD1 AREA)))
	     (CONS-INTERNAL WORD0 WORD1 AREA (%DATA-TYPE OLD))))))

#| Notes:

Region shrinking:  Strategy not clear.  Should be different from 3600?

Install experimental address space map.  Use WHO-CALLS to get all
callers.

Maybe the storage arrays should live in a special block so we can use %BLOCK-READ
to get them.

ALLOCATE-OR-EXTEND-REGION area length level structure-p transport-p
  If level is safeguarded or wired, escape.  This handles stacks.
  From LEVEL, STRUCTURE-P, TRANSPORT-P, and *INHIBIT-READ-ONLY-IN-PROGRESS*,
    build a mask to test REGION-BITS with.  Make the low bits of %REGION-SPACE-NEW
    and %REGION-SPACE-STATIC be the same so this will work.
  (Maybe pass the mask and value in?  That might make transport faster.)
  Keep track of the first region which matches everthing but isn't long enough,
    and test to see if that region can be extended.  This should catch the common
    extend region case without going around the loop again.  This should extend into 
    the next zone/demilevel if it is free.
  Repeat the loop for all regions which match the mask.
  ---
  (Extending is now out of the question, so from here on things can be slow.)
  Do error checking to make sure such a region is legal.
  (Some error checking will have to come earlier before extending a region.)
  For each "zone/demilevel"-group, starting at the highest numbered one,
    Try to place a region in the "zone/demilevel"-group (need better name) according
      to the same algorithm as the 3600, except remember if an option is to overflow into
      the next (free) zone/demilevel.  But prefer starting a region on a boundary rather
      than overflowing.  (Regions should overlap only when they are larger than a 
      zone/demilevel.)
  If 3600 algorithm fails, or maybe in some other conditions, overflow & align
    if no good reason not to.
  If no "zone/demilevel"-group, then pick one via a simplified version of
    ALLOCATE-ZONE/DEMILEVEL, and stick the region at the beginning of that.

| ||#

;; This is THE region maker.  All other entrypoints prohibited.
;; Weird interface is mainly for speed.
;; Creates a region with REGION-BITS which match the specified masked bits.
;; Note that this code expects the following bits to be set in REGION-BITS-MASK:
;;   REPRESENTATION-TYPE
;;   LEVEL
;;   SPACE-TYPE (or some appropriate subset)
;;   NO-CONS (this should be set in the mask and clear in REGION-BITS)
;;   READ-ONLY (this should be (NOT *INHIBIT-READ-ONLY-IN-PROGRESS*) in the mask and
;;              clear in the bits)
(DEFUN ALLOCATE-OR-EXTEND-REGION (AREA LENGTH REGION-BITS-MASK REGION-BITS)
  (DECLARE (SAFEGUARDED-FUNCTION) ;Called by transport-trap
	   (UNSAFEGUARDED-REFERENCE ERROR))
  (UPDATE-CONS-CACHE-REGION-FREE-POINTERS)	;I'm not sure if this is really necessary.
  (WITH-FAST-STORAGE-ACCESSORS (AREA-REGION-LIST REGION-LIST-THREAD
				REGION-BITS REGION-FREE-POINTER REGION-LENGTH)
    (LET ((FIRST-MATCHING-REGION NIL))
      ;; Look for an existing region which matches our criteria and has enough room.
      ;; This loop is the common case, so it should really burn along.
      (DO-AREA-REGIONS (REGION AREA)
	(WHEN (= (LOGAND (REGION-BITS REGION) REGION-BITS-MASK) REGION-BITS)
	  (COND (( (+ (REGION-FREE-POINTER REGION) LENGTH)
		    (REGION-LENGTH REGION))
		 ;; Found a region which matched all the criteria, and had enough room.
		 (RETURN-FROM ALLOCATE-OR-EXTEND-REGION REGION))
		((NULL FIRST-MATCHING-REGION)
		 (SETQ FIRST-MATCHING-REGION REGION)))))
      ;; No regions have enough room.
      (LET ((LEVEL (LDB %%REGION-LEVEL REGION-BITS))
	    (AREA-REGION-BITS (AREA-REGION-BITS AREA)))

	;; Since now we're forced to allocate or extend, do error checking.
	(UNLESS (ZEROP (LOGAND (LOGNOT REGION-BITS-MASK) REGION-BITS))
	  (ERROR "Can't match region bits because unmasked bits are set."))
	;; Check level validity.
	(UNLESS (AND ( LEVEL 0) (< LEVEL %NUMBER-OF-LEVELS)
		     ( (LEVEL-TYPE LEVEL) %LEVEL-TYPE-UNALLOCATED))
	  (ERROR "Invalid level number in ALLOCATE-NEW-REGION"))
	;; Check for writability
	(UNLESS (= (LDB %%REGION-SPACE-TYPE REGION-BITS) %REGION-SPACE-COPY)
	  (WHEN (AND (LDB-TEST %%REGION-READ-ONLY AREA-REGION-BITS)
		     (NOT (PLUSP *INHIBIT-READ-ONLY-IN-PROGRESS*)))
	    (ERROR "Can't create new region in read-only area.")))
	;; Check for making an object in a stack area or vice versa
	(IF (NOT (LDB-TEST %%REGION-STACK REGION-BITS))
	    (WHEN (LDB-TEST %%REGION-STACK AREA-REGION-BITS)
	      (ERROR "Cannot create an object in ~S, an area for stacks." (AREA-NAME AREA)))
	  (WHEN (NOT (LDB-TEST %%REGION-STACK AREA-REGION-BITS))
	    (ERROR "Cannot create a stack in ~S, an area for objects." (AREA-NAME AREA)))
	  (WHEN ( LEVEL %SAFEGUARDED-LEVEL)
	    (ERROR "All stacks must be safeguarded")))
	;; Check for making an object in an area which couldn't possibly work.
	(WHEN (LDB-TEST %%REGION-NO-CONS AREA-REGION-BITS)
	  (ERROR "Attempt to create an object in ~S, where object creation is disabled."
		 (AREA-NAME AREA)))

	;; Escape to special-case code if this region is safeguarded or wired.
	(WHEN (OR (= LEVEL %SAFEGUARDED-LEVEL) (= LEVEL %WIRED-LEVEL))
	  (RETURN-FROM ALLOCATE-OR-EXTEND-REGION
	    (ALLOCATE-OR-EXTEND-MAGIC-REGION AREA LENGTH REGION-BITS-MASK REGION-BITS)))
	
	;; Otherwise try to extend a region.  We know the most recently made region
	;; which matches our specifications.  In the common case, all we'll have to
	;; do is extend it and return.
	(WHEN FIRST-MATCHING-REGION
	  (WITH-FAST-STORAGE-ACCESSORS (REGION-QUANTUM-ORIGIN)
	    (LOOP NAMED TRY-TO-EXTEND DO
	      (LET* ((QUANTUM-LENGTH (REGION-QUANTUM-LENGTH FIRST-MATCHING-REGION))
		     (NEXT-QUANTUM (+ (REGION-QUANTUM-ORIGIN FIRST-MATCHING-REGION)
				      QUANTUM-LENGTH))
		     (REQUIRED-QUANTA
		       (%FIXNUM-CEILING
			 (%32-BIT-PLUS (%32-BIT-DIFFERENCE
					 (%LOGDPB QUANTUM-LENGTH %%VMA-QUANTUM-NUM 0)
					 (REGION-FREE-POINTER FIRST-MATCHING-REGION))
				       LENGTH)
			 %ADDRESS-SPACE-QUANTUM-SIZE)))
		(WHEN (AND (LDB-TEST %%REGION-ADJUSTABLE-SIZE
				     (REGION-BITS FIRST-MATCHING-REGION))
			   (ADDRESS-SPACE-AVAILABLE-P NEXT-QUANTUM REQUIRED-QUANTA)
			   (ADDRESS-SPACE-LEGAL-FOR-LEVEL NEXT-QUANTUM REQUIRED-QUANTA LEVEL))
		  ;; The address space we want to extend into is not occupied by a region,
		  ;; and it is legal to put objects of our level there.  Go for it.
		  (EXTEND-REGION FIRST-MATCHING-REGION REQUIRED-QUANTA)
		  (RETURN-FROM ALLOCATE-OR-EXTEND-REGION FIRST-MATCHING-REGION)))
	      ;; The first region wasn't extendable.  Try for all matching regions.
	      (LOOP DO
		(SETQ FIRST-MATCHING-REGION (REGION-LIST-THREAD FIRST-MATCHING-REGION))
		(COND ((NOT (REGION-VALID-P FIRST-MATCHING-REGION))
		       (RETURN-FROM TRY-TO-EXTEND NIL))
		      ((= (LOGAND (REGION-BITS FIRST-MATCHING-REGION) REGION-BITS-MASK)
			  REGION-BITS)
		       (RETURN NIL)))))))

	;; No region is extendable.  Make a new one, placing it in memory according
	;; to a hairy algorithm.
	(MAKE-REGION-INTERNAL AREA LENGTH REGION-BITS-MASK REGION-BITS)))))

;; Here for all safeguarded and wired regions.
(DEFUN ALLOCATE-OR-EXTEND-MAGIC-REGION (AREA LENGTH REGION-BITS-MASK REGION-BITS)
  (DECLARE (SAFEGUARDED-FUNCTION)
	   (UNSAFEGUARDED-REFERENCE REGION-ALLOCATION-ERROR ERROR))
  (UNLESS (= (LDB %%REGION-LEVEL REGION-BITS) %SAFEGUARDED-LEVEL)
    (ERROR "Cannot allocate or extend wired regions"))
  ;; This is some sort of safeguarded region.  Try to extend it.
  (DO-AREA-REGIONS (REGION AREA)
    (WHEN (= (LOGAND (REGION-BITS REGION) REGION-BITS-MASK) REGION-BITS)
      (LET* ((QUANTUM-LENGTH (REGION-QUANTUM-LENGTH REGION))
	     (QUANTUM-ORIGIN (REGION-QUANTUM-ORIGIN REGION))
	     (NEXT-QUANTUM (+ QUANTUM-ORIGIN QUANTUM-LENGTH))
	     (REQUIRED-QUANTA
	       (%FIXNUM-CEILING (%32-BIT-PLUS (%32-BIT-DIFFERENCE
						(%LOGDPB QUANTUM-LENGTH %%VMA-QUANTUM-NUM 0)
						(REGION-FREE-POINTER REGION))
					      LENGTH)
				%ADDRESS-SPACE-QUANTUM-SIZE)))
	(WHEN (AND (LDB-TEST %%REGION-ADJUSTABLE-SIZE (REGION-BITS REGION))
		   ;; Never cross a subzone boundary.
		   (= (LDB %%QUANTUM-ZONE-AND-SUBZONE (+ NEXT-QUANTUM REQUIRED-QUANTA -1))
		      (LDB %%QUANTUM-ZONE-AND-SUBZONE QUANTUM-ORIGIN))
		   (ADDRESS-SPACE-AVAILABLE-P NEXT-QUANTUM REQUIRED-QUANTA))
	  ;; The address space we want to extend into is not occupied by a region,
	  ;; and it is legal to put objects of our level there.  Go for it.
	  (EXTEND-REGION REGION REQUIRED-QUANTA)
	  (RETURN-FROM ALLOCATE-OR-EXTEND-MAGIC-REGION REGION)))))
  ;; Unable to extend a region.  Try to allocate one.
  (LET ((QUANTUM (DPBS (SELECTOR (LDB %%REGION-SPACE-TYPE REGION-BITS) =
			 (%REGION-SPACE-CONTROL-STACK %SAFEGUARDED-SUBZONE-CONTROL-STACK)
			 (%REGION-SPACE-BINDING-STACK %SAFEGUARDED-SUBZONE-BINDING-STACK)
			 (%REGION-SPACE-STRUCTURE-STACK %SAFEGUARDED-SUBZONE-STRUCTURE-STACK)
			 (OTHERWISE %SAFEGUARDED-SUBZONE-MISC))
		       %%QUANTUM-SUBZONE-NUM
		       %SAFEGUARDED-ZONE %%QUANTUM-ZONE-NUM 0)))
    ;; Fill in the region bits.
    (SETQ REGION-BITS (LOGIOR (LOGAND REGION-BITS-MASK REGION-BITS)
			      (LOGAND (LOGNOT REGION-BITS-MASK) (AREA-REGION-BITS AREA))))
    ;; Don't have to worry about copyspace in the safeguarded zone.
    (WHEN (OR #|TRANSPORT-P|# (LDB-TEST %%REGION-STACK REGION-BITS))
      (SETQ REGION-BITS (DPB 1 %%REGION-SCAVENGE-ENABLE REGION-BITS)))
    (MULTIPLE-VALUE-BIND (REGION-ORIGIN REGION-LENGTH)
	(FIND-FREE-ADDRESS-SPACE QUANTUM %SUBZONE-SIZE-IN-QUANTA
				 (AREA-REGION-QUANTUM-SIZE AREA)
				 (%FIXNUM-CEILING LENGTH %ADDRESS-SPACE-QUANTUM-SIZE))
      (IF REGION-ORIGIN
	  (ALLOCATE-AND-INITIALIZE-REGION AREA REGION-ORIGIN REGION-LENGTH REGION-BITS)
	  (REGION-ALLOCATION-ERROR AREA LENGTH REGION-BITS-MASK REGION-BITS)))))

;; When we come here, we know that we can't extend a region.
;; The strategy is:
;;    Try to place it inside any existing zone or demilevel of the proper region.
;;    If that doesn't work, look for a new acceptable zone or demilevel, and stick
;;      it at the beginning of that.
;;    If there is no acceptable zone or demilevel, then go back through the existing
;;      zones and demilevels trying to make a region of the minimum size.
;;    If that doesn't work then go back through existing zones and demilevels, trying
;;      to steal space from other regions.
;;    If that doesn't work, and this is an ephemeral region, then throw to
;;      EPHEMERAL-REGION-ALLOCATION-ERROR, which will reset things up and try
;;      to allocate dynamic space.  When that succeeds, it will signal an error.
;;    Finally, die a burning, crashing death.
(DEFUN MAKE-REGION-INTERNAL (AREA LENGTH REGION-BITS-MASK REGION-BITS)
  (DECLARE (SAFEGUARDED-FUNCTION)
	   (UNSAFEGUARDED-REFERENCE REGION-ALLOCATION-ERROR ERROR REGION-TABLE-OVERFLOW))
  
  ;; First check for running out of regions
  (UNLESS (OR (REGION-VALID-P *FREE-REGION*)
	      (< *NUMBER-OF-ACTIVE-REGIONS* NUMBER-OF-REGIONS))
    (ERROR 'REGION-TABLE-OVERFLOW))
  
  (LET* ((LEVEL (LDB %%REGION-LEVEL REGION-BITS))
	 (TRANSPORT-P (= (LDB %%REGION-SPACE-TYPE REGION-BITS) %REGION-SPACE-COPY))
	 (REP (LDB %%REGION-REPRESENTATION-TYPE REGION-BITS))
	 (SIZE (COND ((AND (NOT TRANSPORT-P)
			   (= (LEVEL-TYPE LEVEL) %LEVEL-TYPE-EPHEMERAL))
		      (%FIXNUM-CEILING (AREF *EPHEMERAL-GC-FLIP-CAPACITY* LEVEL)
				       %ADDRESS-SPACE-QUANTUM-SIZE))
		     ((AND TRANSPORT-P (NOT *EPHEMERAL-GC-IN-PROGRESS*))
		      (LET ((OLD-SPACE-SIZE 0))
			(DO-AREA-REGIONS (REGION AREA)
			  (LET ((BITS (REGION-BITS REGION)))
			    (WHEN (AND (= (LDB %%REGION-SPACE-TYPE BITS) %REGION-SPACE-OLD)
				       (= (LDB %%REGION-REPRESENTATION-TYPE BITS) REP))
			      (SETQ OLD-SPACE-SIZE
				    (%32-BIT-PLUS OLD-SPACE-SIZE
						  (REGION-FREE-POINTER REGION))))))
			(%FIXNUM-CEILING OLD-SPACE-SIZE %ADDRESS-SPACE-QUANTUM-SIZE)))
		     (T (AREA-REGION-QUANTUM-SIZE AREA)))))
    ;; Fill in the region bits.
    (SETQ REGION-BITS (LOGIOR (LOGAND REGION-BITS-MASK REGION-BITS)
			      (LOGAND (LOGNOT REGION-BITS-MASK) (AREA-REGION-BITS AREA))))
    ;; Don't have to worry about stacks here; they're allocated magically in
    ;; ALLOCATE-OR-EXTEND-MAGIC-REGION.
    (WHEN (OR TRANSPORT-P #|(LDB-TEST %%REGION-STACK REGION-BITS)|#)
      (SETQ REGION-BITS (DPB 1 %%REGION-SCAVENGE-ENABLE REGION-BITS)))
    (MULTIPLE-VALUE-BIND (QUANTUM-ORIGIN QUANTUM-SIZE)
	(IF (= (LEVEL-TYPE LEVEL) %LEVEL-TYPE-EPHEMERAL)
	    (FIND-FREE-EPHEMERAL-SPACE LEVEL SIZE
				       (%FIXNUM-CEILING LENGTH %ADDRESS-SPACE-QUANTUM-SIZE))
	    (FIND-FREE-DYNAMIC-SPACE LEVEL SIZE
				     (%FIXNUM-CEILING LENGTH %ADDRESS-SPACE-QUANTUM-SIZE)))
      (IF QUANTUM-ORIGIN
	  (ALLOCATE-AND-INITIALIZE-REGION AREA QUANTUM-ORIGIN QUANTUM-SIZE REGION-BITS)
	  (REGION-ALLOCATION-ERROR AREA LENGTH REGION-BITS-MASK REGION-BITS)))))

(DEFVAR-SAFEGUARDED *ALLOCATE-IN-FALSE-OLDSPACE* T)

(DEFUN FIND-FREE-DYNAMIC-SPACE (LEVEL REQUESTED-QUANTA MIN-QUANTA)
  (DECLARE (SAFEGUARDED-FUNCTION))
  (SETQ REQUESTED-QUANTA (MAX REQUESTED-QUANTA MIN-QUANTA))
  (LET (A-ZONE-OF-THIS-LEVEL-EXISTS
	BEST-QUANTUM-SO-FAR
	(BEST-SIZE-SO-FAR 0)
	(FALSE-OLDSPACE-MASK (IF *ALLOCATE-IN-FALSE-OLDSPACE* *FALSE-OLDSPACE-MASK* 0)))
    ;; First try to allocate the region in an existing zone.
    ;; Check every group of newspace zones already allocated to this level.
    (LOOP WITH FIRST-ZONE = %FIRST-DYNAMIC-ZONE
	  WHILE ( FIRST-ZONE %LAST-DYNAMIC-ZONE)
	  WHEN (AND (= (ZONE-LEVEL FIRST-ZONE) LEVEL)
		    (OR (NOT (ZONE-OLDSPACE-P FIRST-ZONE))
			;; If false oldspace exists in this zone, then consider the
			;; zone for allocation.
			(BIT-MEMBER FIRST-ZONE FALSE-OLDSPACE-MASK)))
	    DO (SETQ A-ZONE-OF-THIS-LEVEL-EXISTS T)
	       (LOOP FOR LAST-ZONE FROM (1+ FIRST-ZONE)
		     UNTIL (OR (= LAST-ZONE (1+ %BOUNDARY-ZONE))
			       (> LAST-ZONE %LAST-DYNAMIC-ZONE)
			       ( (ZONE-LEVEL LAST-ZONE) LEVEL)
			       (AND (ZONE-OLDSPACE-P LAST-ZONE)
				    ;; If false oldspace exists in this zone,
				    ;; then consider it for allocation.
				    (NOT (BIT-MEMBER LAST-ZONE FALSE-OLDSPACE-MASK))))
		     FINALLY
		       (LET ((QUANTA (DPB (- LAST-ZONE FIRST-ZONE) %%QUANTUM-ZONE-NUM 0)))
			 (WHEN (= LAST-ZONE (1+ %BOUNDARY-ZONE))
			   (DECF QUANTA %OBLAST-SIZE-IN-QUANTA))
			 (MULTIPLE-VALUE-BIND (QUANTUM-ORIGIN QUANTUM-SIZE)
			     (FIND-FREE-ADDRESS-SPACE
			       (DPB FIRST-ZONE %%QUANTUM-ZONE-NUM 0)
			       QUANTA REQUESTED-QUANTA MIN-QUANTA)
			   (COND ((NULL QUANTUM-ORIGIN))
				 (( QUANTUM-SIZE REQUESTED-QUANTA)
				  (RETURN-FROM FIND-FREE-DYNAMIC-SPACE
				    (VALUES QUANTUM-ORIGIN QUANTUM-SIZE)))
				 (( QUANTUM-SIZE MIN-QUANTA)
				  (WHEN (> QUANTUM-SIZE BEST-SIZE-SO-FAR)
				    (SETQ BEST-QUANTUM-SO-FAR QUANTUM-ORIGIN
					  BEST-SIZE-SO-FAR QUANTUM-SIZE))))
			   (SETQ FIRST-ZONE LAST-ZONE))))
	  ELSE DO (INCF FIRST-ZONE))
    ;; No room in currently allocated zones.
    ;; Try to pick free zones adjacent to an existing zone.
    (WHEN A-ZONE-OF-THIS-LEVEL-EXISTS
      (LOOP WITH FIRST-ZONE = (1+ %FIRST-DYNAMIC-ZONE)
	    WHILE ( FIRST-ZONE %LAST-DYNAMIC-ZONE)
	    WHEN (AND ( FIRST-ZONE (1+ %BOUNDARY-ZONE))
		      (EQL (ZONE-LEVEL (1- FIRST-ZONE)) LEVEL)
		      (NOT (LEVEL-VALID-P (ZONE-LEVEL FIRST-ZONE))))
	      DO (LOOP FOR LAST-ZONE FROM (1+ FIRST-ZONE)
		       UNTIL (OR (= LAST-ZONE (1+ %BOUNDARY-ZONE))
				 (> LAST-ZONE %LAST-DYNAMIC-ZONE)
				 (LEVEL-VALID-P (ZONE-LEVEL LAST-ZONE)))
		       FINALLY
			 (LET ((QUANTA (DPB (- LAST-ZONE FIRST-ZONE) %%QUANTUM-ZONE-NUM 0)))
			   (WHEN (= LAST-ZONE (1+ %BOUNDARY-ZONE))
			     (DECF QUANTA %OBLAST-SIZE-IN-QUANTA))
			   (COND (( QUANTA REQUESTED-QUANTA)
				  (RETURN-FROM FIND-FREE-DYNAMIC-SPACE
				    (VALUES (DPB FIRST-ZONE %%QUANTUM-ZONE-NUM 0)
					    REQUESTED-QUANTA)))
				 (( QUANTA MIN-QUANTA)
				  (WHEN (> QUANTA BEST-SIZE-SO-FAR)
				    (SETQ BEST-QUANTUM-SO-FAR (DPB FIRST-ZONE
								   %%QUANTUM-ZONE-NUM 0)
					  BEST-SIZE-SO-FAR QUANTA))))
			   (SETQ FIRST-ZONE LAST-ZONE)))
	    ELSE DO (INCF FIRST-ZONE)))
    ;; No currently allocated zones, or no room by those zones.
    ;; So try any zones.  But try to group static zones in the high half of address space, and
    ;; dynamic zones in the low half.
    (MULTIPLE-VALUE-BIND (LOWER-BOUNDS UPPER-BOUNDS)
	(IF (= (LEVEL-TYPE LEVEL) %LEVEL-TYPE-STATIC)
	    (VALUES '#.(LIST (1+ %BOUNDARY-ZONE) %FIRST-DYNAMIC-ZONE)
		    '#.(LIST %LAST-DYNAMIC-ZONE  %BOUNDARY-ZONE))
	    (VALUES '#.(LIST %FIRST-DYNAMIC-ZONE (1+ %BOUNDARY-ZONE))
		    '#.(LIST %BOUNDARY-ZONE      %LAST-DYNAMIC-ZONE)))
      (LOOP FOR LOWER-BOUND IN LOWER-BOUNDS FOR UPPER-BOUND IN UPPER-BOUNDS DO
	(LOOP WITH FIRST-ZONE = LOWER-BOUND
	      WHILE ( FIRST-ZONE UPPER-BOUND)
	      WHEN (NOT (LEVEL-VALID-P (ZONE-LEVEL FIRST-ZONE)))
		DO (LOOP FOR LAST-ZONE FROM (1+ FIRST-ZONE)
			 UNTIL (OR (> LAST-ZONE UPPER-BOUND)
				   (LEVEL-VALID-P (ZONE-LEVEL LAST-ZONE)))
			 FINALLY
			   (LET ((QUANTA (DPB (- LAST-ZONE FIRST-ZONE) %%QUANTUM-ZONE-NUM 0)))
			     (WHEN (= LAST-ZONE (1+ %BOUNDARY-ZONE))
			       (DECF QUANTA %OBLAST-SIZE-IN-QUANTA))
			     (COND (( QUANTA REQUESTED-QUANTA)
				    (RETURN-FROM FIND-FREE-DYNAMIC-SPACE
				      (VALUES (DPB FIRST-ZONE %%QUANTUM-ZONE-NUM 0)
					      REQUESTED-QUANTA)))
				   (( QUANTA MIN-QUANTA)
				    (WHEN (> QUANTA BEST-SIZE-SO-FAR)
				      (SETQ BEST-QUANTUM-SO-FAR (DPB FIRST-ZONE
								     %%QUANTUM-ZONE-NUM 0)
					    BEST-SIZE-SO-FAR QUANTA))))
			     (SETQ FIRST-ZONE LAST-ZONE)))
	      ELSE DO (INCF FIRST-ZONE))))
      ;; Here no holes exist in which we can place our zone.
      ;; We could try to see if shortening the last region in a zone will help,
      ;; but for now I'm not going to bother.  Shouldn't be too common, anyway.
      (VALUES BEST-QUANTUM-SO-FAR BEST-SIZE-SO-FAR)))

;; This is much harder than allocating zones.  If we get here, we know that no
;; region can be extended.
;; Strategy:
;;   Try to place a region within an existing demilevel.
;;   Allocate a new demilevel adjacent to an existing one.
;;   Allocate a new demilevel anywhere in a group which already has the current level.
;;   If no demilevels for the current level, choose a group somehow.
;;   See if shrinking regions within existing demilevels would help.
;;   See if shrinking regions would allow us to overlap regions into new demilevels.
;; Constraints:
;;   For now, I'm going to enforce a restriction that no level can occupy more than one
;;   group and half.  This simplifies some things, and seems reasonable.
(DEFUN FIND-FREE-EPHEMERAL-SPACE (LEVEL REQUESTED-QUANTA MIN-QUANTA)
  (DECLARE (SAFEGUARDED-FUNCTION))
  (SETQ REQUESTED-QUANTA (MAX REQUESTED-QUANTA MIN-QUANTA))
  (LET* ((GROUP (EPHEMERAL-LEVEL-GROUP LEVEL))
	 (PREFERRED-HALF NIL)
	 (A-DEMILEVEL-OF-THIS-LEVEL-EXISTS NIL)
	 (BEST-QUANTUM-SO-FAR NIL)
	 (BEST-SIZE-SO-FAR 0))
    ;; First try to allocate the region in an existing demilevel.
    ;; At the same time, see if there's already a group allocated for this level.
    (LOOP FOR HALF FROM 0 TO 1 DO
      (LOOP WITH FIRST-DEMILEVEL = (DPBS HALF %%DEMILEVEL-EPHEMERAL-HALF
					 GROUP %%DEMILEVEL-EPHEMERAL-GROUP 0)
	    WHILE (= (LDB %%DEMILEVEL-EPHEMERAL-GROUP FIRST-DEMILEVEL) GROUP)
	    DO (IF (= (DEMILEVEL-LEVEL FIRST-DEMILEVEL) LEVEL)
		   (IF (DEMILEVEL-OLDSPACE-P FIRST-DEMILEVEL)
		       (PROGN (UNLESS PREFERRED-HALF (SETQ PREFERRED-HALF (- 1 HALF)))
			      (INCF FIRST-DEMILEVEL))
		     (UNLESS PREFERRED-HALF (SETQ PREFERRED-HALF HALF))
		     (SETQ A-DEMILEVEL-OF-THIS-LEVEL-EXISTS T)
		     (LOOP FOR LAST-DEMILEVEL FROM (1+ FIRST-DEMILEVEL)
			   UNTIL (OR ( (LDB %%DEMILEVEL-EPHEMERAL-GROUP LAST-DEMILEVEL) GROUP)
				     ( (DEMILEVEL-LEVEL LAST-DEMILEVEL) LEVEL)
				     (DEMILEVEL-OLDSPACE-P LAST-DEMILEVEL))
			   FINALLY
			     (MULTIPLE-VALUE-BIND (QUANTUM-ORIGIN QUANTUM-SIZE)
				 (FIND-FREE-ADDRESS-SPACE
				   (DPB FIRST-DEMILEVEL %%QUANTUM-DEMILEVEL-NUM 0)
				   (DPB (- LAST-DEMILEVEL FIRST-DEMILEVEL)
					%%QUANTUM-DEMILEVEL-NUM 0)
				   REQUESTED-QUANTA MIN-QUANTA)
			       (COND ((NULL QUANTUM-ORIGIN))
				     (( QUANTUM-SIZE REQUESTED-QUANTA)
				      (RETURN-FROM FIND-FREE-EPHEMERAL-SPACE
					(VALUES QUANTUM-ORIGIN QUANTUM-SIZE)))
				     (( QUANTUM-SIZE MIN-QUANTA)
				      (WHEN (> QUANTUM-SIZE BEST-SIZE-SO-FAR)
					(SETQ BEST-QUANTUM-SO-FAR QUANTUM-ORIGIN
					      BEST-SIZE-SO-FAR QUANTUM-SIZE))))
			       (SETQ FIRST-DEMILEVEL LAST-DEMILEVEL))))
		   (INCF FIRST-DEMILEVEL))))
    (UNLESS PREFERRED-HALF (SETQ PREFERRED-HALF 0))
    ;; Then try to allocate the region in a free demilevel adjacent to an existing one.
    (WHEN A-DEMILEVEL-OF-THIS-LEVEL-EXISTS
      (LOOP REPEAT 2 FOR HALF = PREFERRED-HALF THEN (- 1 PREFERRED-HALF) DO
	(LOOP WITH FIRST-DEMILEVEL = (DPBS HALF %%DEMILEVEL-EPHEMERAL-HALF
					   GROUP %%DEMILEVEL-EPHEMERAL-GROUP 1)
	      WHILE (= (LDB %%DEMILEVEL-EPHEMERAL-GROUP FIRST-DEMILEVEL) GROUP)
	      WHEN (AND (= (DEMILEVEL-LEVEL (1- FIRST-DEMILEVEL)) LEVEL)
			(NOT (LEVEL-VALID-P (DEMILEVEL-LEVEL FIRST-DEMILEVEL)))
			(DEMILEVEL-AVAILABLE-FOR-ALLOCATION FIRST-DEMILEVEL))
		DO (LOOP FOR LAST-DEMILEVEL FROM (1+ FIRST-DEMILEVEL)
			 UNTIL (OR ( (LDB %%DEMILEVEL-EPHEMERAL-GROUP LAST-DEMILEVEL) GROUP)
				   (LEVEL-VALID-P (DEMILEVEL-LEVEL LAST-DEMILEVEL))
				   (NOT (DEMILEVEL-AVAILABLE-FOR-ALLOCATION LAST-DEMILEVEL)))
			 FINALLY
			   (LET ((QUANTA (DPB (- LAST-DEMILEVEL FIRST-DEMILEVEL)
					      %%QUANTUM-DEMILEVEL-NUM 0)))
			     (COND (( QUANTA REQUESTED-QUANTA)
				    (RETURN-FROM FIND-FREE-EPHEMERAL-SPACE
				      (VALUES (DPB FIRST-DEMILEVEL %%QUANTUM-DEMILEVEL-NUM 0)
					      REQUESTED-QUANTA)))
				   (( QUANTA MIN-QUANTA)
				    (WHEN (> QUANTA BEST-SIZE-SO-FAR)
				      (SETQ BEST-QUANTUM-SO-FAR (DPB FIRST-DEMILEVEL
								     %%QUANTUM-DEMILEVEL-NUM 0)
					    BEST-SIZE-SO-FAR QUANTA))))
			     (SETQ FIRST-DEMILEVEL LAST-DEMILEVEL)))
	      ELSE DO (INCF FIRST-DEMILEVEL))))
    ;; Here there is no other new/copy space level for us to place ourselves by.
    ;; We try to allocate a demilevel as far away from other levels as possible.
    (LET ((ALLOCATION-ORDER #.(CL:MAKE-ARRAY (DPB 1 %%DEMILEVEL-EPHEMERAL-GROUP 0)
					     :ELEMENT-TYPE '(CL:UNSIGNED-BYTE 4)
					     :INITIAL-CONTENTS '(0 4 2 6 1 5 3 7))))
      (DECLARE (ARRAY-REGISTER ALLOCATION-ORDER))
      (LOOP REPEAT 2 FOR HALF = PREFERRED-HALF THEN (- 1 PREFERRED-HALF) DO
	(LOOP FOR I BELOW (DPB 1 %%DEMILEVEL-EPHEMERAL-GROUP 0)
	      AS OFFSET = (AREF ALLOCATION-ORDER I)
	      AS FIRST-DEMILEVEL = (DPBS HALF %%DEMILEVEL-EPHEMERAL-HALF
					 GROUP %%DEMILEVEL-EPHEMERAL-GROUP
					 OFFSET)
	      DO (LOOP FOR LAST-DEMILEVEL FROM FIRST-DEMILEVEL
		       UNTIL (OR ( (LDB %%DEMILEVEL-EPHEMERAL-GROUP LAST-DEMILEVEL) GROUP)
				 (LEVEL-VALID-P (DEMILEVEL-LEVEL LAST-DEMILEVEL))
				 (NOT (DEMILEVEL-AVAILABLE-FOR-ALLOCATION LAST-DEMILEVEL)))
		       FINALLY
			 (LET ((QUANTA (DPB (- LAST-DEMILEVEL FIRST-DEMILEVEL)
						      %%QUANTUM-DEMILEVEL-NUM 0)))
			   (COND (( QUANTA REQUESTED-QUANTA)
				  (RETURN-FROM FIND-FREE-EPHEMERAL-SPACE
				    (VALUES (DPB FIRST-DEMILEVEL %%QUANTUM-DEMILEVEL-NUM 0)
					    REQUESTED-QUANTA)))
				 (( QUANTA MIN-QUANTA)
				  (WHEN (> QUANTA BEST-SIZE-SO-FAR)
				    (SETQ BEST-QUANTUM-SO-FAR (DPB FIRST-DEMILEVEL
								   %%QUANTUM-DEMILEVEL-NUM 0)
					  BEST-SIZE-SO-FAR QUANTA)))))))))
    ;; Here there are no holes exist in which we can place our demilevel.
    ;; We could try to see if shortening the regions will help,
    ;; but for now I'm not going to bother.
    (VALUES BEST-QUANTUM-SO-FAR BEST-SIZE-SO-FAR)))

(DEFUN ALLOCATE-AND-INITIALIZE-REGION (AREA QUANTUM-ORIGIN QUANTUM-SIZE REGION-BITS)
  (DECLARE (SAFEGUARDED-FUNCTION))
  ;; Allocate the region number
  (LET ((REGION *FREE-REGION*))
    ;; If region free list was not empty, pop the first region off it
    ;; If region free list was empty, expand the active part of the tables
    ;; Overflow was already checked
    (IF (REGION-VALID-P REGION)
	(SETQ *FREE-REGION* (REGION-LIST-THREAD REGION))
      (SETQ REGION *NUMBER-OF-ACTIVE-REGIONS*)
      (SETQ *NUMBER-OF-ACTIVE-REGIONS* (1+ REGION)))
    ;; Put it into the address space map.
    (ENTER-REGION-IN-ADDRESS-SPACE-MAP REGION QUANTUM-ORIGIN QUANTUM-SIZE)
    (UPDATE-ZONE-AND-DEMILEVEL-TABLES QUANTUM-ORIGIN QUANTUM-SIZE
				      (LDB %%REGION-LEVEL REGION-BITS))
    (SET-NEWSPACE QUANTUM-ORIGIN QUANTUM-SIZE)
    ;; Finish filling in region tables
    (SETF (REGION-QUANTUM-ORIGIN REGION) QUANTUM-ORIGIN)
    (SETF (REGION-QUANTUM-LENGTH REGION) QUANTUM-SIZE)
    (SETF (REGION-FREE-POINTER REGION) 0)
    (SETF (REGION-FREE-POINTER-BEFORE-FLIP REGION) 0)
    (SETF (REGION-GC-POINTER REGION) 0)
    (SETF (REGION-BITS REGION) REGION-BITS)
    (SETF (REGION-CREATED-PAGES REGION) 0)
    (SETF (REGION-LIST-THREAD REGION) (AREA-REGION-LIST AREA))
    (SETF (AREA-REGION-LIST AREA) REGION)
    (SETF (REGION-AREA REGION) AREA)
    (INCF %REGION-CONS-ALARM)
    REGION))

;; We have already verified that extending is legal.
(DEFUN EXTEND-REGION (REGION N-QUANTA)
  (DECLARE (SAFEGUARDED-FUNCTION))
  (WITH-FAST-STORAGE-ACCESSORS (REGION-QUANTUM-ORIGIN REGION-QUANTUM-LENGTH)
    (LET* ((ORIGIN (REGION-QUANTUM-ORIGIN REGION))
	   (OLD-LENGTH (REGION-QUANTUM-LENGTH REGION))
	   (NEW-LENGTH (+ OLD-LENGTH N-QUANTA))
	   (EXTENSION-ORIGIN (+ ORIGIN OLD-LENGTH)))
      (ENTER-REGION-IN-ADDRESS-SPACE-MAP REGION EXTENSION-ORIGIN N-QUANTA)
      (UPDATE-ZONE-AND-DEMILEVEL-TABLES EXTENSION-ORIGIN N-QUANTA
					(LDB %%REGION-LEVEL (REGION-BITS REGION)))
      (SET-NEWSPACE EXTENSION-ORIGIN N-QUANTA)
      (SETF (REGION-QUANTUM-LENGTH REGION) NEW-LENGTH)
      REGION)))
	
(DEFUN SET-NEWSPACE (QUANTUM-ORIGIN QUANTUM-SIZE)
  (DECLARE (SAFEGUARDED-FUNCTION))
  (LET ((QUANTUM-LIMIT (+ QUANTUM-ORIGIN QUANTUM-SIZE -1)))
    (IF (ZEROP (LDB %%QUANTUM-ZONE-NUM QUANTUM-ORIGIN))
	(LOOP FOR DEMILEVEL FROM (LDB %%QUANTUM-DEMILEVEL-NUM QUANTUM-ORIGIN)
			    TO (LDB %%QUANTUM-DEMILEVEL-NUM QUANTUM-LIMIT)
	      DO (SETF (%EPHEMERAL-OLDSPACE-REGISTER)
		       (IF (LDB-TEST %%DEMILEVEL-EPHEMERAL-HALF DEMILEVEL)
			   (LOGAND (%EPHEMERAL-OLDSPACE-REGISTER) (ROT (LOGNOT 1) DEMILEVEL))
			   (LOGIOR (%EPHEMERAL-OLDSPACE-REGISTER) (ROT 1 DEMILEVEL)))))
	(LOOP WITH FALSE-OLDSPACE-MASK = *FALSE-OLDSPACE-MASK*
	      FOR ZONE FROM (LDB %%QUANTUM-ZONE-NUM QUANTUM-ORIGIN)
		       TO (LDB %%QUANTUM-ZONE-NUM QUANTUM-LIMIT)
	      ;; Do not turn off the oldspace bit if there is really oldspace here!
	      UNLESS (BIT-MEMBER ZONE FALSE-OLDSPACE-MASK)
		DO (SETF (%ZONE-OLDSPACE-REGISTER)
			 (LOGAND (%ZONE-OLDSPACE-REGISTER) (ROT (LOGNOT 1) ZONE)))))
    ;; We have to refill the oldspace map in case this is copyspace.
    ;; If that is the case, then it may contain oldspace pointers, and we wouldn't want
    ;; the scavenger to ignore references from it.
    (REINITIALIZE-OLDSPACE-MAP)))

(DEFUN UPDATE-ZONE-AND-DEMILEVEL-TABLES (ORIGIN SIZE LEVEL)
  (DECLARE (SAFEGUARDED-FUNCTION)
	   (UNSAFEGUARDED-REFERENCE ERROR))
  (IF (= (LDB %%QUANTUM-ZONE-NUM ORIGIN) %EPHEMERAL-ZONE)
      (LOOP FOR DEMILEVEL FROM (LDB %%QUANTUM-DEMILEVEL-NUM ORIGIN)
			  TO (LDB %%QUANTUM-DEMILEVEL-NUM (+ ORIGIN SIZE -1))
	    AS DEMILEVEL-LEVEL = (DEMILEVEL-LEVEL DEMILEVEL)
	    DO (COND ((LEVEL-VALID-P DEMILEVEL-LEVEL)
		      (UNLESS (= DEMILEVEL-LEVEL LEVEL)
			(ERROR "Demilevel table inconsistency")))
		     (T (SETF (DEMILEVEL-LEVEL DEMILEVEL) LEVEL))))
      (LOOP FOR ZONE FROM (LDB %%QUANTUM-ZONE-NUM ORIGIN)
		     TO (LDB %%QUANTUM-ZONE-NUM (+ ORIGIN SIZE -1))
	    AS ZONE-LEVEL = (ZONE-LEVEL ZONE)
	    DO (COND ((LEVEL-VALID-P ZONE-LEVEL)
		      (UNLESS (= ZONE-LEVEL LEVEL)
			(ERROR "Zone table inconsistency")))
		     (T (SETF (ZONE-LEVEL ZONE) LEVEL))))))

;; Arguments are in quanta, first two are multiples of oblastyi.
(DEFUN FIND-FREE-ADDRESS-SPACE (FIRST-QUANTUM N-QUANTA REQUESTED-QUANTA MIN-QUANTA)
  (DECLARE (SAFEGUARDED-FUNCTION))
  (SETQ REQUESTED-QUANTA (MAX REQUESTED-QUANTA MIN-QUANTA))
  (WHEN (< N-QUANTA MIN-QUANTA) ;don't try hairy algorithm if it's hopeless.
    (RETURN-FROM FIND-FREE-ADDRESS-SPACE NIL))
  (WHEN (< N-QUANTA REQUESTED-QUANTA)
    (SETQ REQUESTED-QUANTA N-QUANTA))
  (LET ((BEST-QUANTUM-SO-FAR NIL)
	(BEST-OBLAST NIL)
	(BEST-SIZE-SO-FAR 0))
    ;; Large regions go into their own oblast if possible.
    (WHEN ( REQUESTED-QUANTA %OBLAST-SIZE-IN-QUANTA)
      (LOOP WITH REQUESTED-OBLASTYI = (LDB %%QUANTUM-OBLAST-NUM
					   (+ REQUESTED-QUANTA %OBLAST-SIZE-IN-QUANTA -1))
	    WITH (FIRST-OBLAST HOPEFULLY-LAST-OBLAST)
	    FOR OBLAST FROM (LDB %%QUANTUM-OBLAST-NUM FIRST-QUANTUM)
	    REPEAT (LDB %%QUANTUM-OBLAST-NUM (+ N-QUANTA %OBLAST-SIZE-IN-QUANTA -1))
	    DO (IF (= (OBLAST-FREE-SIZE OBLAST) %OBLAST-SIZE-IN-QUANTA)
		   (COND ((NULL FIRST-OBLAST)
			  (SETQ FIRST-OBLAST OBLAST
				HOPEFULLY-LAST-OBLAST (+ OBLAST REQUESTED-OBLASTYI -1)))
			 (( OBLAST HOPEFULLY-LAST-OBLAST)
			  ;; Found all the space we need.
			  (RETURN-FROM FIND-FREE-ADDRESS-SPACE
			    (VALUES (DPB FIRST-OBLAST %%QUANTUM-OBLAST-NUM 0)
				    REQUESTED-QUANTA))))
		   (WHEN FIRST-OBLAST
		     (LET ((N-QUANTA (DPB (- OBLAST FIRST-OBLAST) %%QUANTUM-OBLAST-NUM 0)))
		       ;; We know that (< N-QUANTA REQUESTED-QUANTA)
		       ;;--- We could try to extend forward and backward into a
		       ;;--- holes at the end of the previous oblast and the beginning
		       ;;--- of the next oblast.
		       (WHEN (AND ( N-QUANTA MIN-QUANTA)
				  ( N-QUANTA BEST-SIZE-SO-FAR))
			 (SETQ BEST-QUANTUM-SO-FAR (DPB FIRST-OBLAST %%QUANTUM-OBLAST-NUM 0)
			       BEST-SIZE-SO-FAR N-QUANTA))
		       (SETQ FIRST-OBLAST NIL))))
	    FINALLY (WHEN FIRST-OBLAST
		      (LET ((N-QUANTA (DPB (- OBLAST FIRST-OBLAST) %%QUANTUM-OBLAST-NUM 0)))
			;;--- We could try to extend backwards into a
			;;--- hole at the end of the previous oblast here.
			(WHEN (AND ( N-QUANTA MIN-QUANTA)
				   ( N-QUANTA BEST-SIZE-SO-FAR))
			  (SETQ BEST-QUANTUM-SO-FAR (DPB FIRST-OBLAST %%QUANTUM-OBLAST-NUM 0)
				BEST-SIZE-SO-FAR N-QUANTA))))))
    ;; Small region.  First search for an oblast that contains adequate free space.
    (WHEN (< MIN-QUANTA %OBLAST-SIZE-IN-QUANTA)
      (LOOP FOR OBLAST FROM (LDB %%QUANTUM-OBLAST-NUM FIRST-QUANTUM)
	    REPEAT (LDB %%QUANTUM-OBLAST-NUM (+ N-QUANTA %OBLAST-SIZE-IN-QUANTA -1))
	    AS FREE = (OBLAST-FREE-SIZE OBLAST) DO
	(WHEN (> FREE BEST-SIZE-SO-FAR)
	  ;; This oblast contains the largest hole encountered so far
	  (WHEN ( FREE REQUESTED-QUANTA)
	    (RETURN-FROM FIND-FREE-ADDRESS-SPACE
	      (ADDRESS-SPACE-MAP-FIND-FREE-SPACE (DPB OBLAST %%QUANTUM-OBLAST-NUM 0)
						 %OBLAST-SIZE-IN-QUANTA REQUESTED-QUANTA)))
	  (SETQ BEST-OBLAST OBLAST
		BEST-SIZE-SO-FAR FREE)))
      (WHEN BEST-OBLAST
	(SETQ BEST-QUANTUM-SO-FAR
	      (ADDRESS-SPACE-MAP-FIND-FREE-SPACE (DPB BEST-OBLAST %%QUANTUM-OBLAST-NUM 0)
						 %OBLAST-SIZE-IN-QUANTA BEST-SIZE-SO-FAR))))
    (VALUES BEST-QUANTUM-SO-FAR BEST-SIZE-SO-FAR)))

(DEFUN ADDRESS-SPACE-LEGAL-FOR-LEVEL (FIRST-QUANTUM N-QUANTA LEVEL)
  (DECLARE (SAFEGUARDED-FUNCTION))
  (LET ((LAST-QUANTUM (+ FIRST-QUANTUM N-QUANTA -1)))
    (IF (= (LEVEL-TYPE LEVEL) %LEVEL-TYPE-EPHEMERAL)
	(AND (= %EPHEMERAL-ZONE (LDB %%QUANTUM-ZONE-NUM FIRST-QUANTUM))
	     (= %EPHEMERAL-ZONE (LDB %%QUANTUM-ZONE-NUM LAST-QUANTUM))
	     ;; Ensure we don't cross from the low half of the zone to the high half,
	     ;; or between two groups.
	     (= (LDB %%QUANTUM-EPHEMERAL-HALF-AND-GROUP FIRST-QUANTUM)
		(LDB %%QUANTUM-EPHEMERAL-HALF-AND-GROUP LAST-QUANTUM))
	     ;; Ensure that each demilevel is either already newspace of the proper level,
	     ;; or could be made newspace of the proper level.
	     (WITH-FAST-STORAGE-ACCESSORS (DEMILEVEL-LEVEL)
	       (LOOP FOR DEMILEVEL FROM (LDB %%QUANTUM-DEMILEVEL-NUM FIRST-QUANTUM)
				   TO (LDB %%QUANTUM-DEMILEVEL-NUM LAST-QUANTUM)
		     AS DEMILEVEL-LEVEL = (DEMILEVEL-LEVEL DEMILEVEL)
		     ALWAYS (COND ((= DEMILEVEL-LEVEL LEVEL)
				   (NOT (DEMILEVEL-OLDSPACE-P DEMILEVEL)))
				  ((NOT (LEVEL-VALID-P LEVEL))
				   (OR (NOT (DEMILEVEL-OLDSPACE-P DEMILEVEL))
				       (NOT (LEVEL-VALID-P
					      (DEMILEVEL-LEVEL
						(OTHER-DEMILEVEL DEMILEVEL))))))))))
	(AND ( %EPHEMERAL-ZONE (LDB %%QUANTUM-ZONE-NUM FIRST-QUANTUM))
	     (WITH-FAST-STORAGE-ACCESSORS (ZONE-LEVEL)
	       (LOOP FOR ZONE FROM (LDB %%QUANTUM-ZONE-NUM FIRST-QUANTUM)
			      TO (LDB %%QUANTUM-ZONE-NUM LAST-QUANTUM)
		     AS ZONE-LEVEL = (ZONE-LEVEL ZONE)
		     ALWAYS (OR (= ZONE-LEVEL LEVEL)
				(NOT (LEVEL-VALID-P ZONE-LEVEL)))))))))

(DEFUN ADDRESS-SPACE-MAP-FIND-FREE-SPACE (START-QUANTUM N-QUANTA SIZE)
  (DECLARE (SAFEGUARDED-FUNCTION))
  (LET ((LIMIT-QUANTUM (+ START-QUANTUM N-QUANTA)))
    (LOOP WITH BASE-QUANTUM WITH N-FOUND = 0
	  FOR QUANTUM FROM START-QUANTUM BELOW LIMIT-QUANTUM
	  DO (IF (%REGION-NUMBER (%LOGDPB QUANTUM %%VMA-QUANTUM-NUM 0))
		 (SETQ N-FOUND 0)
	       (WHEN (ZEROP N-FOUND) (SETQ BASE-QUANTUM QUANTUM))
	       (INCF N-FOUND)
	       (WHEN ( N-FOUND SIZE) (RETURN (VALUES BASE-QUANTUM N-FOUND))))
	  ;; Callers expect this to return non-NIL.
	  FINALLY (WIRED-FERROR :FATAL "No free space where expected in address space map"))))

(DEFUN ADDRESS-SPACE-AVAILABLE-P (START-QUANTUM N-QUANTA)
  (DECLARE (SAFEGUARDED-FUNCTION))
  (LET ((LIMIT-QUANTUM (+ START-QUANTUM N-QUANTA)))
    (LOOP FOR QUANTUM FROM START-QUANTUM BELOW LIMIT-QUANTUM
	  NEVER (%REGION-NUMBER (%LOGDPB QUANTUM %%VMA-QUANTUM-NUM 0)))))

(DEFUN ENTER-REGION-IN-ADDRESS-SPACE-MAP (REGION QUANTUM-ORIGIN QUANTUM-LENGTH)
  (DECLARE (SAFEGUARDED-FUNCTION))
  (%SET-ADDRESS-SPACE-MAP QUANTUM-ORIGIN QUANTUM-LENGTH REGION)
  (LET ((FIRST-OBLAST (LDB %%QUANTUM-OBLAST-NUM QUANTUM-ORIGIN))
	(LAST-OBLAST (LDB %%QUANTUM-OBLAST-NUM (+ QUANTUM-ORIGIN QUANTUM-LENGTH -1))))
    (LOOP FOR OBLAST FROM FIRST-OBLAST TO LAST-OBLAST DO
      ;; Only do hairy computation if we have to.
      (SETF (OBLAST-FREE-SIZE OBLAST)
	    (IF (OR (AND (= OBLAST FIRST-OBLAST)
			 ( (DPB OBLAST %%QUANTUM-OBLAST-NUM 0) QUANTUM-ORIGIN)
			 (< QUANTUM-LENGTH %OBLAST-SIZE-IN-QUANTA))
		    (= OBLAST LAST-OBLAST))
		(RECOMPUTE-OBLAST-FREE-SIZE OBLAST)
		0)))))

(DEFUN RECOMPUTE-OBLAST-FREE-SIZE (OBLAST)
  (DECLARE (SAFEGUARDED-FUNCTION))
  (LOOP WITH FREE = 0
	FOR QUANTUM FROM (DPB OBLAST %%QUANTUM-OBLAST-NUM 0)
	REPEAT %OBLAST-SIZE-IN-QUANTA
	IF (NULL (%REGION-NUMBER (%LOGDPB QUANTUM %%VMA-QUANTUM-NUM 0)))
	  DO (INCF FREE)
	ELSE MAXIMIZE (PROG1 FREE (SETQ FREE 0)) INTO MAX-FREE
	FINALLY (RETURN (MAX MAX-FREE FREE))))

(DEFUN MAYBE-FREE-ZONES-OR-DEMILEVELS (ORIGIN LENGTH)
  (DECLARE (SAFEGUARDED-FUNCTION))
  (IF (= (LDB %%QUANTUM-ZONE-NUM ORIGIN) %EPHEMERAL-ZONE)
      ;; This loop is weird because one demilevel = one oblast.
      (LOOP FOR DEMILEVEL FROM (LDB %%QUANTUM-DEMILEVEL-NUM ORIGIN)
			  TO (LDB %%QUANTUM-DEMILEVEL-NUM (+ ORIGIN LENGTH -1))
	    WHEN (= (OBLAST-FREE-SIZE DEMILEVEL) %OBLAST-SIZE-IN-QUANTA)
	      DO (SETF (DEMILEVEL-LEVEL DEMILEVEL) -1))
      (LOOP FOR ZONE FROM (LDB %%QUANTUM-ZONE-NUM ORIGIN)
		     TO (LDB %%QUANTUM-ZONE-NUM (+ ORIGIN LENGTH -1))
	    WHEN (LOOP FOR OBLAST FROM (DPB ZONE %%OBLAST-ZONE-NUM 0)
		       REPEAT %ZONE-SIZE-IN-OBLASTYI
		       ALWAYS (= (OBLAST-FREE-SIZE OBLAST) %OBLAST-SIZE-IN-QUANTA))
	      DO (SETF (ZONE-LEVEL ZONE) -1))))

(DEFUN REGION-ALLOCATION-ERROR (AREA LENGTH REGION-BITS-MASK REGION-BITS)
  (DECLARE (DBG:ERROR-REPORTER)
	   (IGNORE AREA REGION-BITS-MASK REGION-BITS))
  (ERROR "Not enough address space left to create a ~:D-word region" LENGTH))


;; Describers and Debuggers

(FORMAT:DEFFORMAT SI:DEMILEVEL (:ONE-ARG) (DEMILEVEL IGNORE)
  (FORMAT FORMAT:*FORMAT-OUTPUT* "~O (Group ~O ~[Low~;High~])"
	  DEMILEVEL
	  (LDB %%DEMILEVEL-EPHEMERAL-GROUP DEMILEVEL)
	  (LDB %%DEMILEVEL-EPHEMERAL-HALF DEMILEVEL)))

(DEFUN SHOW-ALLOCATIONS (&OPTIONAL (ALLOCATED-ONLY-P T) (STREAM STANDARD-OUTPUT))
  (LOOP WITH HEADER = NIL
	FOR DEMILEVEL BELOW %NUMBER-OF-DEMILEVELS
	AS LEVEL = (DEMILEVEL-LEVEL DEMILEVEL)
	WHEN (OR (NOT ALLOCATED-ONLY-P) (LEVEL-VALID-P LEVEL))
	  DO (UNLESS HEADER
	       (FORMAT STREAM "~%Demilevel Allocation:")
	       (SETQ HEADER T))
	     (FORMAT STREAM "~%  ~\SI:DEMILEVEL\ ~\SI:LEVEL\ ~:[newspace~;oldspace~]"
		     DEMILEVEL LEVEL (DEMILEVEL-OLDSPACE-P DEMILEVEL))
	FINALLY (UNLESS HEADER (FORMAT STREAM "~%No demilevels allocated.")))
  (FORMAT STREAM "~%Zone Allocation:")
  (LOOP WITH FALSE-OLDSPACE-MASK = *FALSE-OLDSPACE-MASK*
	FOR ZONE FROM (1+ %EPHEMERAL-ZONE) TO %WIRED-ZONE
	AS LEVEL = (ZONE-LEVEL ZONE)
	WHEN (OR (NOT ALLOCATED-ONLY-P) (LEVEL-VALID-P LEVEL))
	  DO (FORMAT STREAM "~%  ~2O ~\SI:LEVEL\ ~:[newspace~;oldspace~]"
		     ZONE LEVEL (ZONE-OLDSPACE-P ZONE))
	     (WHEN (BIT-MEMBER ZONE FALSE-OLDSPACE-MASK)
	       (FORMAT STREAM " (and newspace)"))))

(DEFUN SHOW-REGION-PLACEMENTS (&OPTIONAL (STREAM STANDARD-OUTPUT))
  (LET ((LAST-ZONE NIL)
	(LAST-DEMILEVEL NIL)
	(LAST-OBLAST NIL))
    (LOOP WITH (REGION-ORIGIN REGION-AT-ORIGIN)
	  FOR QUANTUM BELOW %NUMBER-OF-QUANTA
	  AS REGION = (%REGION-NUMBER (%LOGDPB QUANTUM %%VMA-QUANTUM-NUM 0))
	  WHEN (NEQ REGION REGION-AT-ORIGIN)
	    DO (WHEN REGION-AT-ORIGIN
		 (WHEN (NEQ (LDB %%QUANTUM-ZONE-NUM REGION-ORIGIN) LAST-ZONE)
		   (SETQ LAST-ZONE (LDB %%QUANTUM-ZONE-NUM REGION-ORIGIN))
		   (FORMAT STREAM "~%Zone ~O" LAST-ZONE))
		 (WHEN (AND (ZEROP LAST-ZONE)
			    (NEQ (LDB %%QUANTUM-DEMILEVEL-NUM REGION-ORIGIN)
				 LAST-DEMILEVEL))
		   (SETQ LAST-DEMILEVEL (LDB %%QUANTUM-DEMILEVEL-NUM REGION-ORIGIN))
		   (FORMAT STREAM "~%  Demilevel ~\SI:DEMILEVEL\" LAST-DEMILEVEL))
		 (WHEN (NEQ (LDB %%QUANTUM-OBLAST-NUM REGION-ORIGIN) LAST-OBLAST)
		   (SETQ LAST-OBLAST (LDB %%QUANTUM-OBLAST-NUM REGION-ORIGIN))
		   (FORMAT STREAM "~%    Oblast ~O" LAST-OBLAST))
		 (FORMAT STREAM "~%      Region ~O, Origin ~O, Length ~O, ~\SI:REGION-BITS\"
			 REGION-AT-ORIGIN REGION-ORIGIN (- QUANTUM REGION-ORIGIN)
			 (REGION-BITS REGION-AT-ORIGIN))
		 (UNLESS (AND (= (REGION-QUANTUM-ORIGIN REGION-AT-ORIGIN) REGION-ORIGIN)
			      (= (REGION-QUANTUM-LENGTH REGION-AT-ORIGIN)
				 (- QUANTUM REGION-ORIGIN)))
		   (FORMAT STREAM "~%      --- Region tables think Origin ~O, Length ~O"
			   (REGION-QUANTUM-ORIGIN REGION-AT-ORIGIN)
			   (REGION-QUANTUM-LENGTH REGION-AT-ORIGIN))))
	       (SETQ REGION-AT-ORIGIN REGION
		     REGION-ORIGIN QUANTUM))))

(DEFUN VERIFY-ZONE-CONSISTENCY ()
  (WITH-FAST-STORAGE-ACCESSORS (ZONE-LEVEL DEMILEVEL-LEVEL LEVEL-TYPE
				AREA-REGION-LIST REGION-LIST-THREAD
				REGION-BITS REGION-QUANTUM-ORIGIN REGION-QUANTUM-LENGTH)
    (MACROLET ((LEVEL-TYPE-NAME (LEVEL)
		 `(SUBSTRING (NTH ,LEVEL *LEVEL-TYPES*)
			     (STRING-LENGTH "%LEVEL-TYPE-")))
	       (ITERATOR (VAR-NAME STRING-NAME FROM TO LEVEL-FINDER)
		 `(LOOP FOR ,VAR-NAME FROM ,FROM TO ,TO
			AS LEVEL = (,LEVEL-FINDER ,VAR-NAME)
			DO (COND ((NOT (LEVEL-VALID-P LEVEL))
				  (FORMAT T ,(STRING-APPEND
					       "~%~A region ~O is in "
					       STRING-NAME
					       " ~O, which should not have any regions.")
					  (AREA-NAME AREA) REGION ,VAR-NAME))
				 ((NOT (EQL LEVEL REGION-LEVEL))
				  (FORMAT T ,(STRING-APPEND
					       "~%~A region ~O is level ~O (~A), but "
					       STRING-NAME
					       " ~O is level ~O (~A).")
					  (AREA-NAME AREA) REGION REGION-LEVEL
					  (LEVEL-TYPE-NAME REGION-LEVEL)
					  ,VAR-NAME LEVEL (LEVEL-TYPE-NAME LEVEL)))))))
      (LOOP FOR AREA BELOW (N-AREAS) DO
	(DO-AREA-REGIONS (REGION AREA)
	  (LET* ((REGION-LEVEL (LDB %%REGION-LEVEL (REGION-BITS REGION)))
		 (ORIGIN (REGION-QUANTUM-ORIGIN REGION))
		 (LENGTH (REGION-QUANTUM-LENGTH REGION))
		 (FIRST-ZONE (LDB %%QUANTUM-ZONE-NUM ORIGIN))
		 (LAST-ZONE  (LDB %%QUANTUM-ZONE-NUM (+ ORIGIN LENGTH -1))))
	    (IF (= (LEVEL-TYPE REGION-LEVEL) %LEVEL-TYPE-EPHEMERAL)
		(IF (AND (= %EPHEMERAL-ZONE FIRST-ZONE)
			 (= %EPHEMERAL-ZONE LAST-ZONE))
		    (ITERATOR DEMILEVEL "demilevel"
			      (LDB %%QUANTUM-DEMILEVEL-NUM ORIGIN)
			      (LDB %%QUANTUM-DEMILEVEL-NUM (+ ORIGIN LENGTH -1))
			      DEMILEVEL-LEVEL)
		    (FORMAT T "~%~A region ~O is ephemeral, ~
			       but is not in the ephemeral zone."
			    (AREA-NAME AREA) REGION))
		(IF (OR (= %EPHEMERAL-ZONE FIRST-ZONE)
			(= %EPHEMERAL-ZONE LAST-ZONE))
		    (FORMAT T "~%~A region ~O is not ephemeral, ~
			       but is in the ephemeral zone."
			    (AREA-NAME AREA) REGION)
		    (ITERATOR ZONE "zone" FIRST-ZONE LAST-ZONE ZONE-LEVEL)))))))))

(DEFUN VERIFY-ADDRESS-SPACE-MAP (&AUX FIX-OFS FIX-ASM)
  (WITH-FAST-STORAGE-ACCESSORS (OBLAST-FREE-SIZE
				REGION-BITS REGION-QUANTUM-ORIGIN REGION-QUANTUM-LENGTH)
    ;; Verify OBLAST-FREE-SIZE from ADDRESS-SPACE-MAP
    (LOOP FOR OBLAST BELOW %NUMBER-OF-OBLASTYI
	  AS OFS = (OBLAST-FREE-SIZE OBLAST)
	  AS ASM = (RECOMPUTE-OBLAST-FREE-SIZE OBLAST)
	  WHEN ( OFS ASM)
	    DO (SETQ FIX-OFS T)
	       (FORMAT T "~%Oblast ~O has OFS ~O but ASM shows ~O" OBLAST OFS ASM))
    ;; Verify ADDRESS-SPACE-MAP from region tables.
    ;; Build a new one and then compare.
    (WITH-STACK-ARRAY (NEW-ADDRESS-SPACE-MAP %NUMBER-OF-QUANTA :TYPE ART-16B :INITIAL-VALUE -1)
      (DECLARE (ARRAY-REGISTER NEW-ADDRESS-SPACE-MAP))
      (LOOP FOR REGION BELOW (N-REGIONS)
	    WHEN (NOT (ZEROP (REGION-BITS REGION)))
	      DO (LOOP FOR QUANTUM FROM (REGION-QUANTUM-ORIGIN REGION)
		       REPEAT (REGION-QUANTUM-LENGTH REGION)
		       AS CURRENT = (AREF NEW-ADDRESS-SPACE-MAP QUANTUM)
		       WHEN (REGION-VALID-P CURRENT)
			 DO (FORMAT T "~%Conflict at quantum ~O between regions ~O and ~O"
				    QUANTUM REGION CURRENT)
		       DO (SETF (AREF NEW-ADDRESS-SPACE-MAP QUANTUM) REGION)))
      (LOOP FOR QUANTUM BELOW %NUMBER-OF-QUANTA
	    AS CURRENT = (%REGION-NUMBER (%LOGDPB QUANTUM %%VMA-QUANTUM-NUM 0))
	    AS ACTUAL = (AREF NEW-ADDRESS-SPACE-MAP QUANTUM)
	    UNLESS (REGION-VALID-P ACTUAL)
	      DO (SETQ ACTUAL NIL)
	    WHEN (NOT (EQL ACTUAL CURRENT))
	      DO (SETQ FIX-ASM T)
		 (FORMAT T "Address space map at quantum ~O contains ~O instead of ~O"
			 QUANTUM CURRENT ACTUAL))
      (WHEN (AND FIX-ASM (YES-OR-NO-P "Fix ADDRESS-SPACE-MAP? "))
	(LOOP FOR QUANTUM BELOW %NUMBER-OF-QUANTA
	      AS ASM-ENTRY = (AREF NEW-ADDRESS-SPACE-MAP QUANTUM)
	      DO (%SET-ADDRESS-SPACE-MAP QUANTUM 1 (IF (REGION-VALID-P ASM-ENTRY) ASM-ENTRY))))
      (WHEN (AND FIX-OFS (YES-OR-NO-P "Fix OBLAST-FREE-SIZE?  "))
	(LOOP FOR OBLAST BELOW %NUMBER-OF-OBLASTYI
	      DO (SETF (OBLAST-FREE-SIZE OBLAST) (RECOMPUTE-OBLAST-FREE-SIZE OBLAST)))))))


#||

(defvar *test-allocation-level*)
(defvar *test-allocation-area*)

(defun verify-all ()
  (show-allocations) 
  (format t "~%Verifying ...")
  (verify-zone-consistency)
  (verify-address-space-map))

(defun simulate-cons (area length)
  (allocate-or-extend-region area length
			     (%logdpbs -1 %%region-read-only
				       -1 %%region-representation-type
				       -1 %%region-level
				       -1 %%region-space-type
				       -1 %%region-no-cons 0)
			     (let ((area-bits (area-region-bits area)))
			       (%logdpbs
				 (ldb %%region-level area-bits) %%region-level
				 (ldb %%region-space-type area-bits) %%region-space-type
				 %region-representation-type-list %%region-representation-type
				 0 %%region-no-cons
				 0 %%region-read-only 0))))

(defun test-allocation-code (&aux tem)
  (unless (variable-boundp *test-allocation-level*)
    (setq *test-allocation-level* (allocate-level %level-type-dynamic)))
  (unless (variable-boundp *test-allocation-area*)
    (setq *test-allocation-area* (make-area :name '*test-allocation-area*
					    :gc :dynamic
					    '%%region-level *test-allocation-level*)))
  (reset-area *test-allocation-area* t)
  (verify-all)

  ;; Allocate a region in two zones.
  (setf (area-region-quantum-size *test-allocation-area*) (* 2 %zone-size-in-quanta))
  (setq tem (ldb %%vma-zone-num (%pointer (cons-in-area nil nil *test-allocation-area*))))
  (verify-all)
  (reset-area *test-allocation-area* t)

  ;; Allocate a region in one zone, and extend it to the next.
  ;; Ensure that a zone is picked which can extend.
  (if (level-valid-p (zone-level tem))
      (error "Test needs to be smarter")
      (setf (zone-level tem) *test-allocation-level*))
  (setf (area-region-quantum-size *test-allocation-area*) (floor %zone-size-in-quanta 2))
  (cons-in-area nil nil *test-allocation-area*)
  (verify-all)
  (simulate-cons *test-allocation-area* %address-space-zone-size)
  (verify-all)

  ;; Test allocation in the boundary zone.
  (if (level-valid-p (zone-level %boundary-zone))
      (error "Test needs to be smarter"))
  (setf (zone-level %boundary-zone) *test-allocation-level*)
  (simulate-cons *test-allocation-area* %address-space-zone-size)
  (verify-all)
  (reset-area *test-allocation-area* t)

  ;; Test region extension in the boundary zone.
  (setf (zone-level %boundary-zone) *test-allocation-level*)
  (cons-in-area nil nil *test-allocation-area*)
  (verify-all)
  (simulate-cons *test-allocation-area* (- %address-space-zone-size
					   %address-space-oblast-size))
  (verify-all)

  ;; Clean up.
  (reset-area *test-allocation-area* t)
  nil)

||#
