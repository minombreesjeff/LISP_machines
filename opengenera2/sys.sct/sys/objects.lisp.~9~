;;; -*- Package:SYSTEM-INTERNALS; Mode:LISP; Base:8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; NOTE!!  If you change this, be sure to change %FIND-STRUCTURE-HEADER.
(defun %find-structure-extent (pointer)
  (declare (values header leader total-size))
  (let* ((inhibit-scheduling-flag t)		;to prevent flipping
	 (pointer (%pointer pointer))
	 (region (%region-number pointer))
	 region-origin region-free-pointer region-bits)
    (update-cons-cache-region-free-pointers)
    (cond ((or ;; Apparently garbage pointer, or to A-memory
	       (null region)
	       ;; Off the end of a region
	       ( (%pointer-difference pointer (setq region-origin (region-origin region)))
		  (setq region-free-pointer (region-free-pointer region)))
	       ;; To a communication region
       #+3600  (and (zerop region) (< pointer 2000))
       #+imach (and (= region sys:wired-control-tables)
		    (%pointer-lessp pointer 'nil))	;this is right
       #+imach (= region fep-area))
	   (values nil nil 0))
	  ((= (%logldb %%region-representation-type (setq region-bits (region-bits region)))
	      %region-representation-type-list)
	   (loop with region-base = (if (ldb-test %%region-stack region-bits)
					(decode-stack-address pointer)
					region-origin)
		 for prev = pointer then this
		 while (> prev region-base)
		 as this = (1- prev)
		 until (= (%p-ldb %%q-cdr-code this) cdr-nil)
		 finally
		   (return
		     (values
		       (%make-pointer dtp-list prev)
		       (%make-pointer dtp-locative prev)
		       ;; now go up looking for the end
		       ;; This assumes the last word of the region contains a CDR-NIL.
		       #+3600
		       (loop for p upfrom pointer
			     when (= (%p-ldb %%q-cdr-code p) cdr-nil)
			       return (1+ (%pointer-difference p prev)))
		       #+imach
		       (with-block-registers (1)
			 (setf (%block-register 1) pointer)
			 (set-alu-and-rotate-control :condition %alu-condition-result-cdr-low
						     :condition-sense %alu-condition-sense-true
						     :enable-condition-exception 0)
			 (%block-read-test-tagbody (found)
			   loop (%block-read-test 1 :cycle-type %memory-raw :set-cdr-next nil)
			        (%block-read-test 1 :cycle-type %memory-raw :set-cdr-next nil)
				(%block-read-test 1 :cycle-type %memory-raw :set-cdr-next nil)
				(%block-read-test 1 :cycle-type %memory-raw :set-cdr-next nil)
				(%block-read-test 1 :cycle-type %memory-raw :set-cdr-next nil)
				(%block-read-test 1 :cycle-type %memory-raw :set-cdr-next nil)
				(%block-read-test 1 :cycle-type %memory-raw :set-cdr-next nil)
				(%block-read-test 1 :cycle-type %memory-raw :set-cdr-next nil)
				(go loop)
			   found)
			 (1+ (%pointer-difference (%block-register 1) prev)))
		       ;; Old unoptimized code in case there's bugs above.
		       #+old
		       (setq pointer prev)
		       #+old
		       (loop for i from 1
			     for p = pointer then (%make-pointer-offset dtp-locative p 1)
			     when (= (%p-data-type p) dtp-header-forward)
			       return i		;was (1+ I) --Hornig
			     as cdrc = (%p-ldb %%q-cdr-code p) 
			     when ( cdrc cdr-next)
			       return (if (= cdrc cdr-nil) i (1+ i)))))))
	  (t (prog ((original-pointer pointer)
		    header-dtp forwarded
		    ;; real means "after following DTP-HEADER-FORWARD"
		    real-header-p real-dtp real-header-type
		    object size)
		   ;; find the header
		   (loop with region-base = #+3600  (if (zerop region) #o2000 region-origin)
					    #+imach region-origin
			 for p = pointer then (1- p)
			 do (compiler:%error-when (< p region-base)
			      (error "Searched past region-origin while searching for the header of ~\SI:ADDRESS\~%~v,v,vq"
				     original-pointer nil region-base original-pointer
				     #'transport-error-additional-info))
			 do (setq header-dtp (%p-ldb %%q-data-type p))
			 until (or (= header-dtp dtp-header-i) (= header-dtp dtp-header-p)
				   (= header-dtp dtp-header-forward))
			 finally (setq pointer p
				       real-header-p p
				       real-dtp header-dtp))
		   ;; follow possible header forwarding to get real DTP
		   (loop while (= real-dtp dtp-header-forward)
			 do (setq forwarded t
				  real-header-p (%p-contents-as-locative real-header-p)
				  real-dtp (%p-ldb %%q-data-type real-header-p)))
		   ;; Can now get real-header-type
		   (setq real-header-type (%p-ldb %%header-type-field real-header-p))
		   #+imach
		   (when (and (= real-dtp dtp-header-p)
			      (= real-header-type %header-type-leader))
		     ;; We found the array leader header, so go back and try again
		     ;; with the real array
		     (if (not forwarded)
			 (setq pointer (%pointer (%p-contents-as-locative pointer))
			       real-header-p pointer)
			 ;; Here we have a locative pointer to the header of an array
			 ;; which was since structure-forwarded.  We have to scan forward
			 ;; for the unforwarded header in order to return the proper
			 ;; result.  We can find the forwarded header easily enough.
			 (setq real-header-p (%p-contents-as-locative real-header-p)
			       pointer (%find-unforwarded-array-header pointer real-header-p
					 (+ region-origin region-free-pointer))))
		     (setq real-dtp (%p-data-type real-header-p)
			   real-header-type (%p-ldb %%header-type-field real-header-p)))
		   ;; compute object.  Try to compute size, GOing to
		   ;; HEADER-FORWARD-SIZE if FORWARDED.
		   (select real-dtp
		     (dtp-header-i
		      (select real-header-type
			#+3600
			(%header-type-array
			 (setq object (%make-pointer dtp-array pointer))
			 (if forwarded (go header-forward-size)
			   (let ((n-header-words 1) (leader-length 0) element-length)
			     (select (array-dispatch-field pointer)
			       (%array-dispatch-leader
				(setq leader-length (array-leader-length-field pointer)
				      element-length (array-short-length-field pointer)))
			       (%array-dispatch-short-indirect
				(setq n-header-words 2
				      element-length 0))
			       (%array-dispatch-short-2d
				(setq element-length (* (array-rows-field pointer)
							(array-columns-field pointer))))
			       ((%array-dispatch-long %array-dispatch-long-multidimensional)
				(setq n-header-words (array-long-prefix-length-field pointer)
				      leader-length (array-long-leader-length-field pointer)
				      element-length
				      (let ((long-length (array-long-length-field pointer)))
					(if (eq (array-indirect-pointer pointer)
						(%make-pointer-offset
						  dtp-locative pointer
						  (if (zerop long-length) 0
						      (+ n-header-words leader-length))))
					    long-length	;Normal
					    0))))	;Indirect or displaced
			       (otherwise
				(setq element-length (array-normal-length-field pointer))))
			     (setq size 
				   (+ n-header-words
				      leader-length
				      (let ((elements-per-q (array-elements-per-q
							      (array-type-field pointer))))
					;; please don't use ceiling here until it is in ucode
					(// (+ element-length elements-per-q -1)
					    elements-per-q)))))))
			#+imach
			(%header-type-array
			 (let ((header (%p-ldb %%q-pointer real-header-p)))
			   (setq object
				 (%make-pointer
				   (select (%logldb array-type-field header)
				     ((art-string art-fat-string) dtp-string)
				     (otherwise dtp-array))
				   pointer))
			   (when forwarded
			     ;; There might be a leader before us someplace
			     (loop with region-base = region-origin
				   with header-dtp
				   for p = (%pointer-plus pointer -1)
					 then (%pointer-plus p -1)
				   do
			       (when (%pointer-lessp p region-base)
				 (return))
			       (setq header-dtp (%p-ldb %%q-data-type p))
			       (if (= header-dtp dtp-header-forward)
				   (let ((forwarded-header
					   (%memory-read p :cycle-type %memory-header
							 :set-cdr-next nil)))
				     (when (and (= (%tag forwarded-header)
						   (dpb %header-type-leader
							%%q-cdr-code-within-tag
							dtp-header-p))
						(= (%pointer-difference forwarded-header
									real-header-p)
						   0))
				       ;; P points to the leader.
				       (loop for count from 1
						       below (- region-free-pointer
								(%pointer-difference
								  pointer region-origin))
					     as p1 = (%pointer-plus pointer count)
					     while (= (%p-ldb %%q-data-type p1)
						      dtp-element-forward)
					     finally (setq size
							   (+ (%pointer-difference pointer p)
							      count)))
				       (setq pointer p)
				       (go finished))
				     (return))
				   (when ( header-dtp dtp-element-forward)
				     (return))))
			     (go header-forward-size))
			   (setq size
				 (let ((leader-length (%logldb array-leader-length-field
							       header)))
				   (+ (cond ((zerop leader-length) 0)
					    (t (setq pointer (- pointer leader-length 1))
					       (+ 1 leader-length)))
				      (if (zerop (%logldb array-long-prefix-bit header))
					  (+ 1 (array-element-words
						 (%logldb array-short-length-field header)
						 (%logldb array-type-field header)))
					  (+ 4
					     (* 2 (%logldb array-long-dimensions-field
							   header))
					     (if (zerop (%logldb array-displaced-bit header))
						 (array-element-words
						   (array-long-length-field object)
						   (%logldb array-type-field header))
						 0))))))))
			#+3600
			(%header-type-number
			 (setq object (%make-pointer dtp-extended-number pointer))
			 (if forwarded (go header-forward-size)
			   (setq size
				 (select (%p-ldb %%header-subtype-field pointer)
				   (%header-type-bignum (1+ (%p-ldb %%bignum-length pointer)))
				   (%header-type-rational 3)
				   (%header-type-complex 3)
				   (%header-type-double 3)
				   (otherwise
				    (ferror
				      "Size of this extended number not known yet."))))))
			#+imach
			(%header-type-number
			 (let ((header (%p-ldb %%q-pointer pointer)))
			   (select (%logldb %%header-subtype-field header)
			     (%header-subtype-bignum
			      (setq object (%make-pointer dtp-bignum pointer))
			      (if forwarded
				  (go header-forward-size)
				  (setq size (1+ (%logldb %%bignum-length header)))))
			     (otherwise
			      (ferror "Size of this extended number not known yet.")))))
			(%header-type-compiled-function
			 (setq object (%make-pointer
					dtp-compiled-function
					(+ pointer
					   #+3600(compiled-function-table-size real-header-p)
					   (defstorage-size compiled-function))))
			 (if forwarded (go header-forward-size)
			   (setq size
				 #+3600(compiled-function-total-size pointer)
				 #+imach(cca-total-size pointer))))
			(otherwise (when forwarded (go header-forward-size)))))
		     (dtp-header-p
		      (select real-header-type
			(%header-type-symbol
			 (setq object (if (= pointer (%pointer nil))
					  nil
					(%make-pointer dtp-symbol pointer)))
			 (if forwarded (go header-forward-size)
			   (setq size (defstorage-size symbol))))
			(%header-type-instance
			 (setq object (%make-pointer dtp-instance pointer))
			 (if forwarded (go header-forward-size)
			   (setq size
				 #+3600 (%flavor-instance-size (%instance-flavor pointer))
				 #+imach (%memory-read
					   (%pointer-plus
					     (%memory-read pointer :cycle-type %memory-header)
					     -1) :fixnum-only t))))
			(otherwise (when forwarded (go header-forward-size)))))
		     (otherwise (when forwarded (go header-forward-size))))
		finished
		   (compiler:%error-unless
		       (%pointer-lessp original-pointer (+ pointer size))
		     (error "Found non-enclosing structure (~\SI:ADDRESS\-~\SI:ADDRESS\) starting from ~\SI:ADDRESS\~@
			     ~v,v,vQ"
			    pointer (+ pointer size) original-pointer
			    nil pointer original-pointer #'transport-error-additional-info))
		   (return (values object (%make-pointer dtp-locative pointer) size))
		header-forward-size
		   ;; don't modify POINTER in here!!
		   (loop for count from 1 below (- region-free-pointer
						   (%pointer-difference pointer region-origin))
			 as p = (%make-pointer-offset dtp-locative pointer count)
			 while (= (%p-ldb %%q-data-type p) dtp-element-forward)
			 finally (setq size count)
				 (go finished)))))))

;;; NOTE!!  If you change this, be sure to change 
(defun %find-structure-header (pointer)
  (let* ((inhibit-scheduling-flag t)		;to prevent flipping
	 (pointer (%pointer pointer))
	 (region (%region-number pointer))
	 region-origin #+imach region-free-pointer region-bits)
    (update-cons-cache-region-free-pointers)
    (cond ((or ;; Apparently garbage pointer, or to A-memory
	       (null region)
	       ;; Off the end of a region
	       ( (%pointer-difference pointer (setq region-origin (region-origin region)))
		  #+imach (setq region-free-pointer (region-free-pointer region))
		  #+3600 (region-free-pointer region))
	       ;; To a communication region
       #+3600  (and (zerop region) (< pointer 2000))
       #+imach (and (= region sys:wired-control-tables)
		    (%pointer-lessp pointer 'nil))	;this is right
       #+imach (= region fep-area))
	   nil)
	  ((= (%logldb %%region-representation-type (setq region-bits (region-bits region)))
	      %region-representation-type-list)
	   (loop with region-base = (if (ldb-test %%region-stack region-bits)
					(decode-stack-address pointer)
					region-origin)
		 for prev = pointer then this
		 while (> prev region-base)
		 as this = (1- prev)
		 until (= (%p-ldb %%q-cdr-code this) cdr-nil)
		 finally (return (%make-pointer dtp-list prev))))
	  (t
	   (loop with region-base = #+3600  (if (zerop region) #o2000 region-origin)
				    #+imach region-origin
		 for p = pointer then (1- p)
		 when (< p region-base)
		   return (error "Searched past region-origin while searching for the header of ~\SI:ADDRESS\~%~v,v,vq"
				 pointer nil region-base pointer
				 #'transport-error-additional-info)
		 as dtp = (%p-ldb %%q-data-type p)
		 when (or (= dtp dtp-header-i) (= dtp dtp-header-p)
			  (= dtp dtp-header-forward))
		 return (%make-pointer
			  (let (#+imach (forwarded nil) (header-p p))
			    (do () (( dtp dtp-header-forward))
			      #+imach (setq forwarded t)
			      (setq header-p (%p-contents-as-locative header-p)
				    dtp (%p-ldb %%q-data-type header-p)))
			    (let ((header-type (%p-ldb %%header-type-field header-p)))
			      #+imach
			      (when (and (= dtp dtp-header-p)
					 (= header-type %header-type-leader))
				(setq header-p (%pointer (%p-contents-as-locative header-p))
				      dtp (%p-data-type header-p)
				      header-type (%p-ldb %%header-type-field header-p)
				      p (if forwarded
					    (%find-unforwarded-array-header p header-p
					      (+ region-origin region-free-pointer))
					    header-p)))
			      (select dtp
				(dtp-header-i
				 (select header-type
				   (%header-type-array
				    #+3600 dtp-array
				    #+imach (select (array-type-field header-p)
					      ((art-string art-fat-string) dtp-string)
					      (otherwise dtp-array)))
				   (%header-type-number
				    #+3600 dtp-extended-number
				    #+imach (select (%p-ldb %%header-subtype-field header-p)
					      (%header-subtype-bignum dtp-bignum)
					      (otherwise dtp-spare-number)))
				   (%header-type-compiled-function
				    (setq p (%make-pointer-offset
					      dtp-locative p
					      (+ #+3600
						 (compiled-function-table-size header-p)
						 (defstorage-size compiled-function))))
				    dtp-compiled-function)))
				(dtp-header-p
				 (select header-type
				   (%header-type-symbol
				    (if (= p (%pointer nil)) dtp-nil dtp-symbol))
				   (%header-type-instance dtp-instance))))))
			  p))))))

(defun %find-structure-leader (pointer)
  (let ((obj (%find-structure-header pointer)))
    (select (%data-type obj)
      (dtp-compiled-function
       (%make-pointer-offset dtp-locative obj
			     (- (+ #+3600 (%logldb %%entry-instruction-table-size
						   (%p-ldb (byte 20 00) obj))
				   (defstorage-size compiled-function)))))
      #+imach
      ((dtp-array dtp-string)
       (let ((leader-length (array-leader-length-field obj)))
	 (if (zerop leader-length)
	     obj
	     (%make-pointer-offset dtp-locative obj (- (1+ leader-length))))))
      (otherwise obj))))

;;; This is actually faster than what it used to do, which was
;;; %find-structure-leader (which calls %find-structure-header) and then
;;; doing roughly the same dispatch that %find-structure-header does.
(defun %structure-total-size (pointer)
  (multiple-value-bind (nil nil size)
      (%find-structure-extent pointer)
    size))

#+imach
;; Find the unforward header of the array whose leader starts at POINTER.
;; The forwarded header is in REAL-HEADER-P, which is used for verification.
(defun %find-unforwarded-array-header (pointer real-header-p limit)
  (loop for p from (1+ pointer) below limit
	do (selector (%p-ldb %%q-data-type p) =
	     (dtp-element-forward)
	     (dtp-header-forward
	       (do ((p1 p p2)
		    (p2 (%memory-read p :cycle-type %memory-scavenge)
			(%memory-read p2 :cycle-type %memory-scavenge)))
		   (nil)
		 (cond ((and (type-member p2 dtp-header-i)
			     (zerop (%pointer-difference
				      p1 real-header-p)))
			(return-from %find-unforwarded-array-header p))
		       ((not (type-member p2 dtp-header-forward))
			(loop-finish)))))
	     (otherwise (loop-finish)))
	finally (error "Can't find old header for forwarded array")))

;;; Mapping over various things

  ;;
;;;;;;  Area mapping
  ;;

(defun area-predicate-all-areas (area) area T)

(defun area-predicate-areas-with-objects (area)
  (selector area =
    ((#+IMach fep-area page-table-area gc-table-area) nil)
    (otherwise t)))

(defun map-over-areas (area-predicate function &rest other-function-args)
  (declare (sys:downward-funarg function))
  "Function is applied to (area-number . other-function-args)
   Current values for AREA-PREDICATE (function gets area number as only argument):
	   #'SI:AREA-PREDICATE-ALL-AREAS
	   #'SI:AREA-PREDICATE-AREAS-WITH-OBJECTS (used if NIL is supplied)"
  (if (not area-predicate) (setq area-predicate #'area-predicate-areas-with-objects))
  (dotimes (area-number (n-areas))
    (when (funcall area-predicate area-number)
      (lexpr-funcall function area-number other-function-args))))

  ;;
;;;;;;  Region with area mapping
  ;;

;; This is careful to grab the REGION-LIST-THREAD before the body has a chance to splice it.
;; Removing this feature leads to very obscure bugs, I assure you.  -- DLA
(defmacro do-area-regions ((region-var area) &body body)
  `(do ((,region-var (area-region-list ,area)))
       ((not (region-valid-p ,region-var)))
     (setq ,region-var (prog1 (region-list-thread ,region-var) . ,body))))

(defun region-predicate-all-regions (region) region T)

(defun region-predicate-structure (region)
  (= (ldb %%region-representation-type (region-bits region))
     %region-representation-type-structure))

(defun region-predicate-list (region)
  (= (ldb %%region-representation-type (region-bits region))
     %region-representation-type-list))

(defun region-predicate-not-stack-list (region)
  (let ((bits (region-bits region)))
    (not (and (= (ldb %%region-representation-type bits) %region-representation-type-list)
	      (ldb-test %%region-stack bits)))))

(defun region-predicate-copyspace (region)
  (or (= (ldb %%region-space-type (region-bits region))
	 %region-space-copy)))

(defun map-over-regions-of-area (area region-predicate function &rest other-function-args)
  (declare (sys:downward-funarg REGION-PREDICATE function))
  "Function is applied to (region-number . other-function-args)
   Current values for REGION-PREDICATE (function gets region number as only argument):
	   #'SI:REGION-PREDICATE-ALL-REGIONS (used if NIL is supplied)
	   #'SI:REGION-PREDICATE-STRUCTURE
	   #'SI:REGION-PREDICATE-LIST"
  (do-area-regions (region area)
    (when (or (null region-predicate)
	      (funcall region-predicate region))
      (lexpr-funcall function region other-function-args))))

  ;;
;;;;;;  Composition (region mapping)
  ;;

(defun map-over-regions (area-predicate region-predicate function &rest other-function-args)
  (declare (sys:downward-funarg AREA-PREDICATE REGION-PREDICATE function))
  "Function is applied to (area-number region-number . other-function-args)"
  (map-over-areas
    area-predicate
    #'(lambda (area-number)
	(map-over-regions-of-area
	  area-number region-predicate
	  #'(lambda (region-number)
	      (lexpr-funcall function area-number region-number other-function-args))))
))

  ;;
;;;;;;  Paging assistance for memory scanning
  ;;

(eval-when (eval compile load)
(defun decode-scanning-through-memory-identifier (identifier-symbol)
  (declare (values scan-behind scan-limit scan-whack
		   scan-mark scan-ahead-start scan-ahead-limit))
  (values (intern (string-append "." (get-pname identifier-symbol) "-SCAN-BEHIND."))
	  (intern (string-append "." (get-pname identifier-symbol) "-SCAN-LIMIT."))
	  (intern (string-append "." (get-pname identifier-symbol) "-SCAN-WHACK."))
	  (intern (string-append "." (get-pname identifier-symbol) "-SCAN-MARK."))
	  (intern (string-append "." (get-pname identifier-symbol) "-SCAN-AHEAD-START."))
	  (intern (string-append "." (get-pname identifier-symbol) "-SCAN-AHEAD-LIMIT."))))
)

(eval-when (eval compile load)
(defvar *scanning-through-memory-valid-identifiers* nil)
)

;;; identifier symbol allows these to nest correctly.

(defmacro scanning-through-memory (identifier-symbol
				   (starting-address limit-address . pages-per-whack)
				   &body body)
  ;; fixed by Common Lisp
  (declare (arglist identifier-symbol
		    (starting-address limit-address &optional (pages-per-whack 16.))
		    &body body))
  (if pages-per-whack
      (setq pages-per-whack (car pages-per-whack))
    (setq pages-per-whack 16.))
  (multiple-value-bind (scan-behind scan-limit scan-whack
			scan-mark scan-ahead-start scan-ahead-limit)
      (decode-scanning-through-memory-identifier identifier-symbol)
    `(compiler-let ((*scanning-through-memory-valid-identifiers*
		      (cons ',identifier-symbol *scanning-through-memory-valid-identifiers*)))
       (let* ((,scan-behind ,starting-address)
	      (,scan-limit  ,limit-address)
	      (,scan-whack (%fixnum-multiply ,pages-per-whack page-size))
	      (,scan-mark ,scan-behind)
	      (,scan-ahead-start ,scan-behind)
	      (,scan-ahead-limit (min ,scan-limit (+ ,scan-behind ,scan-whack ,scan-whack))))
	 ,@body))))

(defmacro check-memory-scan (identifier-symbol current-address &environment env)
  (unless (memq identifier-symbol *scanning-through-memory-valid-identifiers*)
    (compiler:warn nil "Can't lexically find identifier-symbol ~S" identifier-symbol))
  (multiple-value-bind (scan-behind scan-limit scan-whack
			scan-mark scan-ahead-start scan-ahead-limit)
      (decode-scanning-through-memory-identifier identifier-symbol)
    (once-only (current-address &environment env)
      `(when ( ,current-address ,scan-mark)
	 ;; make scan-mark be the last page just traversed
	 (setq ,scan-mark (dpb 0 %%vma-word-offset ,current-address))
	 (page-out-words ,scan-behind (- ,scan-mark ,scan-behind) :write-modified :deferred)
	 (page-in-words ,scan-ahead-start (- ,scan-ahead-limit ,scan-ahead-start) :hang-p nil)
	 (setq ,scan-behind ,scan-mark
	       ,scan-mark (+ ,scan-mark ,scan-whack)
	       ,scan-ahead-start ,scan-ahead-limit
	       ,scan-ahead-limit (min ,scan-limit (+ ,scan-mark ,scan-whack ,scan-whack)))))))

;; This is a version of check-memory-scan which works in safeguarded code by open-coding
;; the storage interface.
(defmacro gc-check-memory-scan (identifier-symbol current-address &environment env)
  (unless (memq identifier-symbol
		#+cross-compilation l:si:*scanning-through-memory-valid-identifiers*
		#-cross-compilation *scanning-through-memory-valid-identifiers*)
    (compiler:warn nil "Can't lexically find identifier-symbol ~S" identifier-symbol))
  (multiple-value-bind (scan-behind scan-limit scan-whack
			scan-mark scan-ahead-start scan-ahead-limit)
      (#+cross-compilation l:si:decode-scanning-through-memory-identifier
       #-cross-compilation decode-scanning-through-memory-identifier
			   identifier-symbol)
    (once-only (current-address &environment env)
      `(when ( ,current-address ,scan-mark)
	 ;; make scan-mark be the last page just traversed
	 (setq ,scan-mark (dpb 0 %%vma-word-offset ,current-address))
	 (%funcall-in-aux-stack #'storage::flush-pages
				(extract-vpn ,scan-behind)
				(1+ (ldb %%vma-page-num
					 (+ (ldb %%vma-word-offset ,scan-behind)
					    (- ,scan-mark ,scan-behind)
					    -1)))
				nil t)
	 (%funcall-in-aux-stack #'storage::user-prefetch-pages
				,scan-ahead-start
				(1+ (ldb %%vma-page-num
					 (+ (ldb %%vma-word-offset ,scan-ahead-start)
					    (- ,scan-ahead-limit ,scan-ahead-start)
					    -1)))
				nil t)
	 (setq ,scan-behind ,scan-mark
	       ,scan-mark (+ ,scan-mark ,scan-whack)
	       ,scan-ahead-start ,scan-ahead-limit
	       ,scan-ahead-limit (min ,scan-limit (+ ,scan-mark ,scan-whack ,scan-whack)))))))

  ;;
;;;;;;  Object mapping
  ;;

(defun map-over-objects-in-region (region-number function &rest other-function-args)
  (declare (sys:downward-funarg function))
  "function gets applied to (address header leader size . other-function-args)"
  (flet ((do-memory (origin limit)
	   (scanning-through-memory objects (origin limit 32.)
	     (loop for address = #+3600 (max origin 2000)	;Skip AMEM
		                 #+IMACH (if (or (%pointer-lessp origin %trap-vector-base)
						 (not (%pointer-lessp origin 'nil)))
					     origin
					   (%pointer 'nil))
		       then (+ address size)
		   while (< address limit)
		   do (check-memory-scan objects address)
		   as size = (multiple-value-bind (header leader size)
				 (%find-structure-extent address)
			       (lexpr-funcall function address header leader size
					      other-function-args)
			       size)))))
    (update-cons-cache-region-free-pointers)
    (let* ((origin (region-origin region-number))
	   (limit (+ origin (region-free-pointer region-number)))
	   (region-bits (region-bits region-number)))
      (cond ((not (ldb-test %%region-stack region-bits))
	     (do-memory origin limit))
	    ((= (ldb %%region-representation-type region-bits)
		%region-representation-type-list)
	     ;; Control or binding stack, don't even look at it.
	     )
	    (t
	     ;; Data stack, look at the objects in it, but watch out for the
	     ;; unused word at the front.
	     (loop with (stack-origin stack-active-size stack-size)
		   for origin = origin then (+ stack-origin stack-size)
		   while (< origin limit) do
	       (multiple-value (stack-origin stack-active-size stack-size)
		 (decode-stack-address origin))
	       (do-memory (1+ stack-origin) (+ stack-origin stack-active-size -1))))))))

(defun map-over-objects-in-area (area-number region-predicate
				 function &rest other-function-args)
  (declare (sys:downward-funarg REGION-PREDICATE function))
  "function gets applied to (region-number address header leader size . other-function-args)"
  (map-over-regions-of-area
    area-number region-predicate
    #'(lambda (region-number)
	(map-over-objects-in-region
	  region-number
	  #'(lambda (address header leader size)
	      (lexpr-funcall function region-number
			     address header leader size
			     other-function-args))))))

(defun map-over-objects (area-predicate region-predicate
			 function &rest other-function-args)
  (declare (sys:downward-funarg area-predicate region-predicate function))
  "function gets applied to (area-number region-number address header leader size . other-function-args"
  (map-over-regions
    area-predicate region-predicate
    #'(lambda (area-number region-number)
	(map-over-objects-in-region
	  region-number
	  #'(lambda (address header leader size)
	      (lexpr-funcall function area-number region-number
			     address header leader size
			     other-function-args))))))

(defun map-compiled-functions (storage-categories region-predicate progress-note
			       function &rest args)
  (declare (sys:downward-funarg region-predicate function))
  "Function gets applied to (header[a compiled function] leader . args)
   STORAGE-CATEGORIES is either T, or a list of :WIRED, :SAFEGUARDED, and//or :UNSAFEGUARDED.
   Wired functions are scanned first, then safeguarded function, then unsafeguarded functions.
   Functions are scanned chronologically within their storage category."
  (when (eq storage-categories t)
    (setq storage-categories '(:wired :safeguarded :unsafeguarded)))
  (let ((regions nil)
	(total-size 0)
	(scanned-so-far 0))
    (flet ((collect (area)
	     (do-area-regions (region area)
	       (when (funcall (or region-predicate #'region-predicate-structure) region)
		 (push region regions)
		 (incf total-size (region-free-pointer region))))))
      (update-cons-cache-region-free-pointers)
      (when (memq :unsafeguarded storage-categories)
	(collect compiled-function-area))
      (when (memq :safeguarded storage-categories)
	(collect safeguarded-objects-area))
      (when (memq :wired storage-categories)
	(collect wired-control-tables))
      ;; Regions are now in the proper (reversed) order.
      (tv:noting-progress-if progress-note (progress-note)
	(dolist (region regions)
	  (let ((origin (region-origin region)))
	    (lexpr-funcall #'map-over-objects-in-region region
	      #'(lambda (address header leader size &rest args)
		  (declare (ignore size))
		  (when (typep header :compiled-function)
		    (when progress-note
		      (tv:note-progress (+ scanned-so-far (- address origin)) total-size))
		    (lexpr-funcall function header leader args)))
	      args)
	    (incf scanned-so-far (region-free-pointer region))))))))

;; Obsolete interfaces, left in because this file is distributed and people may
;; call them in private programs.

(compiler:make-obsolete map-over-compiled-functions "use MAP-COMPILED-FUNCTIONS")

(defun map-over-compiled-functions (unwired-p wired-p function &rest args)
  (declare (sys:downward-funarg function))
  (when (or unwired-p wired-p)
    (lexpr-funcall #'map-compiled-functions
		   (cond ((not wired-p) '(:safeguarded :unsafeguarded))
			 ((not unwired-p) '(:wired))
			 (t t))
		   (if (memq unwired-p '(t nil)) nil unwired-p)
		   nil function args)))

(compiler:make-obsolete map-over-compiled-functions-chronologically
			"use MAP-COMPILED-FUNCTIONS")

(defun map-over-compiled-functions-chronologically (unwired-p wired-p function &rest args)
  (declare (sys:downward-funarg function))
  (lexpr-funcall #'map-over-compiled-functions unwired-p wired-p function args))

;;; More modern object-mapping macros.

(defmacro do-objects (((object &key area region address leader size)
		       &key (oldspace-action :evacuate)	;or :IGNORE or :COLLECT
			    ((:area area-to-scan) nil)
			    ((:region region-to-scan) nil)
			    (area-predicate nil)
			    (region-predicate nil)
			    (object-predicate nil)
			    #+ignore (progress-note nil))	;---
		      &body body)
  `(do-objects-internal #'(lambda (,(or area 'ignore)
				   ,(or region 'ignore)
				   ,(or address 'ignore)
				   ,object
				   ,(or leader 'ignore)
				   ,(or size 'ignore))
			    . ,body)
			,oldspace-action ,area-to-scan ,region-to-scan
			,area-predicate ,region-predicate ,object-predicate))

(defmacro do-virtual-memory (((address tag pointer)
			      &key (oldspace-action :evacuate)	;:IGNORE, :COLLECT, :INCLUDE
				   ((:area area-to-scan) nil)
				   ((:region region-to-scan) nil)
				   (area-predicate nil)
				   (region-predicate nil)
				   (increment 1)
				   #+imach (cycle-type %memory-scavenge)
				   (loop-wrapper ''(progn . body)))
			     &body body)
  `(do-vm-internal #'(lambda (.origin. .limit.)
		       (declare (downward-function))
		       ,(subst `((scanning-through-memory do-vm-internal (.origin. .limit.)
				   (loop for ,address from .origin. below .limit. by ,increment
					 do (check-memory-scan do-vm-internal ,address)
					    (let* #+3600 ((,tag (%p-ldb %%q-tag ,address))
							  (,pointer (%p-ldb %%q-pointer
									    ,address)))
						  #+imach ((.word. (%memory-read
								     ,address
								     :cycle-type ,cycle-type
								     :set-cdr-next nil))
							   (,tag (%tag .word.))
							   (,pointer (%pointer .word.)))
						  . ,body))))
			       'body
			       (eval loop-wrapper)))	;Environment?
		   ,OLDSPACE-action
		   ,area-to-scan ,region-to-scan
		   ,area-predicate ,region-predicate))

;;--- This should map over the objects in creation order...
(defun do-objects-internal (continuation oldspace-action area region
			    area-predicate region-predicate object-predicate)
  (declare (downward-funarg continuation area-predicate region-predicate object-predicate))
  (check-arg oldspace-action (memq oldspace-action '(:evacuate :collect :ignore))
	     "a legal oldspace action")
  ;;--- Check args.
  ;; This ensures that a nongarbage object created before this call will really be found.
  (update-cons-cache-region-free-pointers)
  (macrolet ((with-appropriate-gc-action ((action area) &body body)
	       `(with-appropriate-gc-action-internal ,action ,area
		  #'(lambda () (declare (downward-function)) . ,body))))
    (labels ((consider-area (a)
	       (when (and (area-predicate-areas-with-objects a)
			  (or (null area-predicate)
			      (funcall area-predicate a)))
		 (with-appropriate-gc-action (oldspace-action a)
		   (with-fast-storage-accessors (area-region-list region-list-thread
						 region-bits)
		     (do-area-regions (r a)
		       (unless (and (eq oldspace-action :ignore)
				    (= (ldb %%region-space-type (region-bits r))
				       %region-space-old))
			 (consider-region a r)))))))
	     (consider-region (a r)
	       (when (or (null region-predicate)
			 (funcall region-predicate r))
		 (let* ((origin (region-origin r))
			(limit (%32-bit-plus (region-free-pointer r) origin)))
		   #+3600  (cond ((= r 0) (setq origin #o2000)))
		   #+imach (cond ((= r 0) (return-from consider-region nil))
				 ((= r 1) (setq origin (%pointer 'nil))))
		   (selector (ldb %%region-space-type (region-bits r)) =
		     ((%region-space-new %region-space-copy)
		      ;; Consider all objects in this region
		      (consider-range a r origin limit))
		     ((%region-space-stack)	;Yes, not (LDB-TEST %%REGION-STACK)!
		      ;; Consider all objects in data stacks in this region.
		      ;; This may not be the best idea, since data stacks can change size
		      ;; while we're looking at them.
		      (loop with (stack-base active-size total-size type)
			    for address = origin then (+ address total-size)
			    while (%pointer-lessp address limit)
			    do (multiple-value (stack-base active-size total-size nil nil type)
				 (decode-stack-address address))
			       (if (null type)
				   (setq total-size 1)
				 (unless (eql stack-base address)
				   (error "Unexpected stack format found in DO-OBJECTS"))
				 (when (eq type :data)
				   (consider-range a r
				     (%32-bit-plus stack-base 1)
				     (%32-bit-plus stack-base (1- active-size)))))))))))
	     (consider-range (area region origin limit)
	       (scanning-through-memory scan (origin limit)
		 (loop with (header leader size)
		       for address = origin then (%32-bit-plus address size)
		       while (%pointer-lessp address limit)
		       do (check-memory-scan scan address)
			  (multiple-value (header leader size)
			    (%find-structure-extent address))
			  (when (or (null object-predicate)
				    (funcall object-predicate header))
			    (funcall continuation area region address header leader size)))))
	     (with-appropriate-gc-action-internal (action area f)
	       (if (eq action :ignore)
		   (funcall f)
		   (inhibit-gc-flips
		     (unless %gc-flip-ready
		       (if (eq action :collect)
			   (%gc-scavenge)
			   (evacuate-oldspace-in-area area)))
		     (funcall f)))))
      (cond (area   (consider-area area))
	    (region (consider-region (region-area region) region))
	    (t      (dotimes (area (n-areas))
		      (consider-area area)))))))

(defun do-vm-internal (continuation
		       oldspace-action area region area-predicate region-predicate)
  (declare (downward-funarg continuation area-predicate region-predicate))
  (check-arg oldspace-action (memq oldspace-action '(:evacuate :collect :ignore :include))
	     "a legal oldspace action")
  ;;--- Check args.
  ;; This ensures that a nongarbage object created before this call will really be found.
  (update-cons-cache-region-free-pointers)
  (macrolet ((with-appropriate-gc-action ((action area) &body body)
	       `(with-appropriate-gc-action-internal ,action ,area
		  #'(lambda () (declare (downward-function)) . ,body))))
    (labels ((consider-area (a)
	       (when (and (area-predicate-areas-with-objects a)
			  (or (null area-predicate)
			      (funcall area-predicate a)))
		 (with-appropriate-gc-action (oldspace-action a)
		   (with-fast-storage-accessors (area-region-list region-list-thread
						 region-bits)
		     (do-area-regions (r a)
		       (unless (and (eq oldspace-action :ignore)
				    (= (ldb %%region-space-type (region-bits r))
				       %region-space-old))
			 (consider-region r)))))))
	     (consider-region (r)
	       (when (or (null region-predicate)
			 (funcall region-predicate r))
		 (let* ((origin (region-origin r))
			(limit (%32-bit-plus (region-free-pointer r) origin)))
		   ;; For this function, don't exclude communication areas.
		   ;; But do exclude the FEP, for now.
		   #+imach (cond ((= r 1) (setq origin (%pointer 'nil))))
		   (let ((space (ldb %%region-space-type (region-bits r))))
		     (cond ((or (= space %region-space-new)
				(= space %region-space-copy))
			    ;; Consider all objects in this region
			    (funcall continuation origin limit))
			   ((ldb-test %%space-type-stack space)
			    ;; Consider only the active stacks in this region
			    (loop with (stack-base active-size total-size)
				  for address = origin then (+ address total-size)
				  while (%pointer-lessp address limit)
				  do (multiple-value (stack-base active-size total-size)
				       (decode-stack-address address))
				     (if (null stack-base)
					 (setq total-size 1)
					 (funcall continuation
						  stack-base
						  (%32-bit-plus stack-base active-size)))))
			   ((= space %region-space-old)
			    ;; Consider this region only if explicitly instructed.
			    (when (eq oldspace-action :include)
			      (funcall continuation origin limit))))))))
	     (with-appropriate-gc-action-internal (action area f)
	       (if (or (eq action :ignore) (eq action :include))
		   (funcall f)
		   (inhibit-gc-flips
		     (unless %gc-flip-ready
		       (if (eq action :collect)
			   (%gc-scavenge)
			   (evacuate-oldspace-in-area area)))
		     (funcall f)))))
      (cond (area   (consider-area area))
	    (region (consider-region region))
	    (t      (dotimes (area (n-areas))
		      (consider-area area))
		    ;; Also consider A-memory on the 3600.  I guess it counts as virtual.
		    #+3600 (loop for (nil origin limit) in *magic-locations*
				 when (= (ldb %%vma-equals-amem (%pointer origin))
					 %vma-equals-amem)
				   do (funcall continuation
					       (%pointer origin) (%pointer limit)))
		    )))))

;;; GC support for object mapping

;; Go through an oldspace region and transport everything there into copyspace.
;; This could probably be written more efficiently for Ivory, but it's hard
;; to write it so it can run with preemption enabled.  So this will have to do for now.
(defun evacuate-oldspace-region (region) 
  (declare (safeguarded-function))
  ;; Search for something other than a GC-FORWARD.  When found, evacuate that pointer.
  (inhibit-oldspace-reclamation
    (let ((bits (region-bits region)))
      (when (= (ldb %%region-space-type bits) %region-space-old)
	(let* ((origin (region-origin region))
	       (limit (+ origin (region-free-pointer region))))
	  (scanning-through-memory evacuate-oldspace-region (origin limit)
	    ;; Redirect everything we transport back into the same level if appropriate.
	    ;; This gives garbage a chance to really be collected the next time around.
	    (unless (eq *ephemeral-migration-mode* :dynamic)
	      (let ((level (ldb %%region-level bits)))
		(when (ephemeral-level-p level)
		  (setf (region-gc-pointer region)
			(dpbs level %%gc-pointer-copyspace-level
			      #+imach -1 #+imach %%gc-pointer-copyspace-region 0)))))
	    (loop for pointer from origin below limit do
	      (gc-check-memory-scan evacuate-oldspace-region pointer)
	      (unless (= (%p-data-type pointer) dtp-gc-forward)
		;; This causes a hardware transport trap.
		(%p-contents-as-locative pointer)))))))))

(defun evacuate-oldspace-in-area (area)
  (with-fast-storage-accessors (area-region-list region-list-thread region-bits)
    (do-area-regions (region area)
      (when (= (ldb %%region-space-type (region-bits region)) %region-space-old)
	(evacuate-oldspace-region region)))))
