;;; -*- Package:SYSTEM-INTERNALS; Mode:LISP; Base:8 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>
;;; I machine dependent stack manipulation functions.
;;; This file is in the cold load.

;;; From SYSDF1
(DEFWIREDVAR %CURRENT-STACK-GROUP NIL)
(DEFWIREDVAR %CONTROL-STACK-LOW)
(DEFWIREDVAR %CURRENT-STACK-GROUP-STATUS-BITS)
(DEFWIREDVAR FLOAT-OPERATING-MODE *DEFAULT-FLOAT-OPERATING-MODE*)
(DEFWIREDVAR FLOAT-OPERATION-STATUS 0)

(DEFMACRO CATCH-BLOCK-P (CB)
  `(ZEROP (CATCH-BLOCK-UNWIND-PROTECT ,CB)))

(DEFMACRO SET-CALLERS-VALUE-DISPOSITION (FP DISPOSITION)
  `(%P-DPB ,DISPOSITION %%CR.VALUE-DISPOSITION
	   (LOCF (FRAME-CALLER-CONTROL-REGISTER ,FP))))

;;; ABORT-CALL-0, ABORT-CALL-1, ABORT-CALL-MULTIPLE

;;; Should be called in extra stack mode
;;; Copies its caller's frame header to the previous open frame OF.  N things have been
;;; pushed on the stack after the start-call for OF.
(DEFUN ABORT-CALL-HELPER (N)
  (LET* ((CALLER-FP
	   (%POINTER-PLUS (%STACK-FRAME-POINTER)
			  (- (LDB %%CR.CALLER-FRAME-SIZE
				  (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER)))))
	 (CALLER-SAVED-CONTROL (FRAME-CALLER-CONTROL-REGISTER CALLER-FP))
	 (OFFSET (+ (%LOGLDB %%CR.EXTRA-ARGUMENT CALLER-SAVED-CONTROL) N))
	 (OC+1 (%POINTER-PLUS CALLER-FP (1+ (- OFFSET)))))
    (%P-DPB (LDB %%CR.CLEANUP-AND-TRACE-BITS CALLER-SAVED-CONTROL)
	    %%CR.CLEANUP-AND-TRACE-BITS OC+1)
    (FLET ((CHANGE-CALLER-FP (OFFSET)
	     (%P-DPB (+ (LDB %%CR.CALLER-FRAME-SIZE (%SAVED-CONTROL-REGISTER)) OFFSET)
		     %%CR.CALLER-FRAME-SIZE
		     (LOCF (%SAVED-CONTROL-REGISTER)))))
      (STORAGE::NOTE-FRAME-POINTER-CHANGE
	%CURRENT-STACK-GROUP CALLER-FP (%POINTER-PLUS CALLER-FP (- OFFSET)))
      (CHANGE-CALLER-FP OFFSET)
      (%P-DPB (- (LDB %%CR.CALLER-FRAME-SIZE (%SAVED-CONTROL-REGISTER)) OFFSET)
	      %%CR.CALLER-FRAME-SIZE
	      (LOCF (%SAVED-CONTROL-REGISTER))))))

;;; ABORT-CALL-0
;;; Called for effect
;;; Aborts the following:
;;; Start-Call
;;; Push N-2 things on the stack
;;;
;;; Nothing is left on the stack
(DEFUN ABORT-CALL-0 (N)
  (%FUNCALL-IN-TRAP-MODE (%SET-MIN-TRAP-MODE TRAP-MODE-EXTRA-STACK) #'ABORT-CALL-HELPER N))

;;; Called for value
;;; Aborts the following:
;;; Start-Call
;;; Push N-3 things onto the stack
;;; Push value-to-return
;;;
;;; value-to-return is left on the stack
(DEFUN ABORT-CALL-1 (N)
  (%FUNCALL-IN-TRAP-MODE (%SET-MIN-TRAP-MODE TRAP-MODE-EXTRA-STACK) #'ABORT-CALL-HELPER N)
  (%POP)					;N
  (%POP)					;Saved control register
  (%POP)					;Saved continuation register
  (%POP))					;Value to return

;;; Called for multiple values
;;; Aborts the following:
;;; Start-call
;;; Push N-2 things onto the stack
;;; Push M-V-G
;;;
;;; Returns the M-V-G
(DEFUN ABORT-CALL-MULTIPLE (N)
  ;; Add in the MVG
  (%FUNCALL-IN-TRAP-MODE
    (%SET-MIN-TRAP-MODE TRAP-MODE-EXTRA-STACK) #'ABORT-CALL-HELPER
    (+ N (1+ (LOCATION-CONTENTS (%POINTER-PLUS (%STACK-FRAME-POINTER) -1)))))
  (%POP)					;N
  (%POP)					;Saved control register
  (%POP)					;Saved continuation register
  ;; The multiple value group is now on top of the stack, all ready to be
  ;; returned by us
  (%RETURN-MULTIPLE))

;;; Report an unwinding error.
;;; We can't use the error system because that might lead to an infinite loop.
(DEFUN UNWINDING-ERROR (FORMAT-STRING &REST FORMAT-ARGS)
  (DECLARE (DBG:ERROR-REPORTER))
  (CL:LOOP (CL:APPLY #'CL:BREAK FORMAT-STRING FORMAT-ARGS)))

(DEFUN THROW-ERROR (TAG VALUES)
  (DECLARE (DBG:ERROR-REPORTER))
  (SIGNAL-PROCEED-CASE ((NEW-TAG) 'THROW-TAG-NOT-SEEN :TAG TAG :VALUES VALUES)
    (:NEW-TAG (SETQ TAG NEW-TAG)))
  TAG)

(DEFUN THROW-TO-INVALID-CATCH-BLOCK ()
  (DECLARE (DBG:ERROR-REPORTER))
  (UNWINDING-ERROR "Attempt to THROW to a CATCH which has been already been thrown through."))

;;; Debugging function
;(DEFUN VERIFY-CATCH-BLOCK-LIST ()
;  (LOOP FOR LAST-CB FIRST -1 THEN CB
;	FOR CB FIRST (%READ-INTERNAL-REGISTER %REGISTER-CATCH-BLOCK-LIST)
;	       THEN (CATCH-BLOCK-PREVIOUS CB)
;	DOING
;    (COND ((NULL CB) (RETURN-FROM VERIFY-CATCH-BLOCK-LIST T))
;	  ((AND (%POINTER-LESSP CB LAST-CB)
;		(TYPE-MEMBER CB DTP-LOCATIVE)
;		(TYPE-MEMBER (CATCH-BLOCK-PC CB) DTP-EVEN-PC DTP-ODD-PC DTP-NIL)))
;	  (T (HALT)))))

(DEFWIREDFUN %THROW (TAG &REST VALUES)
  (DECLARE (DBG:ERROR-REPORTER))
  ;; Look carefully at (FLAVOR:METHOD :DECODE-FRAME-EXIT DBG:RETURN-FROM-TRACED-FRAME-TRAP)
  ;; when you change how this works, or if you change the calling contract.
  (FLET ((%THROW-INTERNAL (TAG VALUES)
	   (DECLARE (UNSAFEGUARDED-REFERENCE THROW-ERROR THROW-TO-INVALID-CATCH-BLOCK))
	   (LET* ((CATCH-BLOCK-LIST (%READ-INTERNAL-REGISTER %REGISTER-CATCH-BLOCK-LIST))
		  (DEST-BLOCK
		    (LOOP NAMED THROW-LOOP DOING
		      (LOOP FOR CB FIRST CATCH-BLOCK-LIST THEN (CATCH-BLOCK-PREVIOUS CB)
			    UNTIL (NULL CB)
			    DOING
			(WHEN (AND (CATCH-BLOCK-P CB)
				   (EQ (CATCH-BLOCK-TAG CB) TAG))
			  (IF (ZEROP (CATCH-BLOCK-INVALID CB))
			      (RETURN-FROM THROW-LOOP CB)
			      (THROW-TO-INVALID-CATCH-BLOCK))))
		      (THROW-ERROR TAG VALUES)))
		  (VALUE-DISPOSITION (CATCH-BLOCK-VALUE-DISPOSITION DEST-BLOCK))
		  (FP (%READ-INTERNAL-REGISTER %REGISTER-FP))
		  (CALLEES-FP)
		  (CALLEES-CALLEES-FP)
		  (CR (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER))
		  (CB CATCH-BLOCK-LIST)
		  (CBS-IN-LAST-FRAME 1)
		  ;; Just to be safe, we count the args ourselves in case somehow we
		  ;; were applied.
		  (NUMBER-OF-VALUES
		    (LET ((I 0))
		      (DOLIST (ELT VALUES)
			;; Have to use PROGN so it isn't confused with a tag.
			(PROGN ELT)
			(INCF I))
		      I)))
	     ;; Set our frame value disposition to be return, so that we
	     ;; return through that frame (not to be confused with not
	     ;; continuing from where our caller called us).  In the
	     ;; easy case of the catch being for destination return, we
	     ;; won't execute the helper function in %THROW, but in the
	     ;; messy case, we will.
	     (SETF (%LOGLDB %%CR.VALUE-DISPOSITION
			    (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER))
		   VALUE-DISPOSITION-RETURN)
	     ;; Go through the stack and the catch-blocks in parallel, making
	     ;; the catch blocks invalid and setting the value disposition on
	     ;; the intermediate frames to be return.
	     (LOOP NAMED THROW DOING
	       ;; Get to the frame for this catch block
	       (LOOP WHILE (%POINTER-LESSP CB FP) DOING
		 (WHEN CALLEES-CALLEES-FP
		   ;; All catch blocks up to this frame have now been invalidated, so it is
		   ;; safe to change the values disposition.
		   (SET-CALLERS-VALUE-DISPOSITION
		     CALLEES-CALLEES-FP VALUE-DISPOSITION-RETURN))
		 ;; Move to caller
		 (PSETQ CALLEES-CALLEES-FP CALLEES-FP
			CALLEES-FP FP
			FP (%MAKE-POINTER-OFFSET
			     DTP-LOCATIVE FP (- (LDB %%CR.CALLER-FRAME-SIZE CR)))
			CR (FRAME-CALLER-CONTROL-REGISTER FP))
		 (WHEN (%POINTER-LESSP FP DEST-BLOCK)
		   (RETURN-FROM THROW NIL)))
	       (WHEN (CATCH-BLOCK-P CB)
		 (SETF (CATCH-BLOCK-INVALID CB) 1))
	       (SETQ CB (CATCH-BLOCK-PREVIOUS CB)))
	     ;; Fix up the blocks in the frame we are throwing into while counting the
	     ;; number of catch blocks we will be throwing through
	     (LOOP UNTIL (EQ CB DEST-BLOCK) DOING
	       (WHEN (CATCH-BLOCK-P CB)
		 (SETF (CATCH-BLOCK-INVALID CB) 1))
	       (INCF CBS-IN-LAST-FRAME)
	       (SETQ CB (CATCH-BLOCK-PREVIOUS CB)))
	     ;; Fix the continuation register of the frame we are returning to
	     (SETF (FRAME-CALLER-CONTINUATION CALLEES-FP) (CATCH-BLOCK-CONTINUATION CB))
	     ;; Clear any exceptions which may be found in the FPA
	     (WHEN (CLI::FP-COPROCESSOR-ENABLED-P)
	       (LOOP DOING
		 (LET ((STATUS (%COPROCESSOR-READ
				 (+ CLI::%FPA-STATUS-REGISTER-BASE-ADDRESS 11.))))
		   (WHEN (AND (TYPE-MEMBER STATUS DTP-FIXNUM DTP-SINGLE-FLOAT)
			      (NOT (LDB-TEST
				     CLI::%%W3X64-DIVIDE-SQUARE-ROOT-IN-PROGRESS
				     (SETQ STATUS (%FIXNUM STATUS)))))
		     (SETF (CLI::%FPA-ADDER-MULTIPLIER-STATUS-REGISTER) 0)
		     (SETF (CLI::%FPA-STATUS-REGISTER 10.) 0)
		     (SETF (CLI::%FPA-FPEX-DIVIDE-STATUS-REGISTER) 0)
		     (RETURN)))))
	     ;; And finally do the returning
	     (WHEN (= VALUE-DISPOSITION VALUE-DISPOSITION-RETURN)
	       ;; Easy case -- the catch is returning.  This means that its frame must also
	       ;; have a value disposition of return, so we just have to make the callee
	       ;; have a value disposition of return and then do the return
	       (SET-CALLERS-VALUE-DISPOSITION CALLEES-CALLEES-FP VALUE-DISPOSITION-RETURN)
	       (DO ()
		   ((NULL VALUES))
		 (%PUSH (CAR VALUES))
		 (SETQ VALUES (CDR VALUES)))
	       (%PUSH NUMBER-OF-VALUES)
	       (%RETURN-MULTIPLE))
	     ;; Messy case -- throwing into a frame:  We return a multiple value group
	     ;; consisting of the values the catch wants in the form it wants them,
	     ;; the PC to continue at when all this is done, the number of
	     ;; catch blocks that need to be cleaned up in the last frame, and
	     ;; the number of bindings to be undone there (0 in this case).  We also arrange
	     ;; that the frames callee returns to our assistant, which happens to
	     ;; be where we would have returned to if we hadn't just molested the
	     ;; stack.
	     (SET-CALLERS-VALUE-DISPOSITION CALLEES-CALLEES-FP VALUE-DISPOSITION-MULTIPLE)
	     (SETF (FRAME-CALLER-CONTINUATION CALLEES-CALLEES-FP)
		   (%READ-INTERNAL-REGISTER %REGISTER-CONTINUATION))
	     (LET ((VALS VALUES))
	       ;; Push the values onto the stack according to the values disposition
	       (SELECT VALUE-DISPOSITION
		 (VALUE-DISPOSITION-EFFECT (SETQ NUMBER-OF-VALUES 0))
		 (VALUE-DISPOSITION-VALUE
		  (%PUSH (CAR VALUES))
		  (SETQ NUMBER-OF-VALUES 1))
		 (VALUE-DISPOSITION-MULTIPLE
		  (DO ()
		      ((NULL VALS))
		    (%PUSH (CAR VALS))
		    (SETQ VALS (CDR VALS)))
		  (%PUSH NUMBER-OF-VALUES)
		  (SETQ NUMBER-OF-VALUES (1+ NUMBER-OF-VALUES))))
	       (%PUSH (CATCH-BLOCK-PC DEST-BLOCK))
	       ;; This is the address of the target catch block's tag word.
	       (%PUSH (%POINTER-PLUS DEST-BLOCK -1))	;STACK-BLT-TO-ADDRESS
	       (%PUSH CALLEES-FP)		;STACK-BLT-FROM-ADDRESS
	       (%PUSH CBS-IN-LAST-FRAME)	;CATCH-BLOCKS-TO-CLOSE
	       (%PUSH (+ 4 NUMBER-OF-VALUES))	;Size of this multiple value group, which
						; includes the user's and these 5 extra
						; words
	       (%RETURN-MULTIPLE)))))
    ;; Really do the throw.  This will make the continuation
    ;; register be the helping function in %THROW-INTERNAL's frame
    ;; (a DCP trick).  It also gets around a fencepost problem
    ;; with throwing to your own frame.
    (%THROW-INTERNAL TAG VALUES)
    ;; %THROW-INTERNAL returns to here, but in another frame.
    (COMPILER:%PUSH-N 4)			;Tell the compiler there are at least
						;4 more things pushed onto the stack
						;than it thinks there are, so that it
						;doesn't think the stack depth goes
						;negative with all these pops
    
    (%POP)					;Pop the size of the multiple value group
						; just returned; it's no longer needed.
    ;; This is the helper function.  At this point the stack looks as follows:
    ;;      Values, if any
    ;;      PC-TO-RETURN-TO                   SP|-3
    ;;      STACK-BLT-TO-ADDRESS              SP|-2
    ;;      STACK-BLT-FROM-ADDRESS            SP|-1
    ;;      CATCH-BLOCKS-TO-CLOSE             SP|0
    ;; First, loop doing essentially CATCH-CLOSE-MULTIPLE for all of the catch blocks to
    ;; be closed.
    (WHEN (PLUSP (COMPILER:%INSTRUCTION PUSH (SP 0.)))
      (CATCH-CLOSE)
      (COMPILER:%INSTRUCTION LOOP-DECREMENT-TOS -1))
    (%POP)					;CATCH-BLOCKS-TO-CLOSE, don't need it any more
    ;; Now move the stuff at the top of the stack down a bit
    ;; Stack looks like:
    ;;      Values, if any
    ;;      PC-TO-RETURN-TO                   SP|-2
    ;;      STACK-BLT-TO-ADDRESS              SP|-1
    ;;      STACK-BLT-FROM-ADDRESS            SP|-0
    ;; Now change FROM to an address from an offset.
    ;; This next instruction will have the side-effect of popping the two arguments to
    ;; STACK-BLT (STACK-BLT-TO-ADDRESS and STACK-BLT-FROM-TOS-OFFSET).  So, when it's
    ;; finished, PC-TO-RETURN-TO will be at the top of the stack.
    (STACK-BLT (%POP))
    ;; TOS is PC-TO-RETURN-TO
    (%JUMP (%POP))))


(DEFUN MAP-OVER-STACK-FRAMES (STACK-GROUP FUNCTION)
  (DECLARE (SYS:DOWNWARD-FUNARG FUNCTION))
  (SYS:MAP-OVER-FRAMES-IN-STACK STACK-GROUP
				#'(LAMBDA (FP LCR PC)
				    (DECLARE (IGNORE PC))
				    (FUNCALL FUNCTION FP LCR))
				:NONE))

;;; Given an address in a stack group's data stack, locate the
;;; control stack frame that allocated it.  Returns NIL if not found.
;;; The technique is to search backwards through the binding stack, looking for a binding
;;; of sg-data-stack-pointer that, when restored, will pop ADDRESS off the data stack.
;;; The control-stack frame that owns this binding is the one that we are looking for.
(DEFUN CONTROL-STACK-FRAME-FOR-DATA-STACK-ADDRESS (SG ADDRESS)
  (LET ((BSP (IF (EQ SG %CURRENT-STACK-GROUP) %BINDING-STACK-POINTER
		       (SG-BINDING-STACK-POINTER SG)))
	(LOW (SG-BINDING-STACK-LOW SG))
	(CELL (LOCF (SG-DATA-STACK-POINTER SG)))
	(OFP NIL)
	(OCL NIL))
    (DBG:MAP-OVER-FRAMES-IN-STACK
      SG
      #'(LAMBDA (FP CONTROL-LOC PC)
	  (DECLARE (IGNORE PC))
	  (WHEN (LDB-TEST %%CR.CLEANUP-BINDINGS (LOCATION-CONTENTS CONTROL-LOC))
	    (LOOP WHILE (%POINTER-LESSP LOW BSP)	;This check should be redundant
		  AS OSP = BSP
		  DOING (WHEN (EQ (BINDING-STACK-CELL BSP) CELL)
			  (IF (%POINTER-LESSP (BINDING-STACK-CONTENTS BSP) ADDRESS)
			      (RETURN-FROM CONTROL-STACK-FRAME-FOR-DATA-STACK-ADDRESS
				(IF (EQ SG %CURRENT-STACK-GROUP)
				    (VALUES FP CONTROL-LOC)
				    (VALUES OFP OCL)))
			      (SETQ OFP FP OCL CONTROL-LOC)))  ;Frame owning next inner binding
			(SETQ BSP (%POINTER-PLUS BSP -2))
		  WHILE (NOT (ZEROP (BINDING-STACK-CHAIN-BIT OSP))))))
      :NONE)))

(DEFUN VALID-THROW-TAG-P (TAG
			  &OPTIONAL
			  (CATCH-BLOCK-LIST
			    (%READ-INTERNAL-REGISTER %REGISTER-CATCH-BLOCK-LIST)))
  (WHEN CATCH-BLOCK-LIST
    (LET ((TARGET-CATCH-BLOCK CATCH-BLOCK-LIST))
      (CL:LOOP
	 (WHEN (AND (CATCH-BLOCK-P TARGET-CATCH-BLOCK)
		    (EQ (CATCH-BLOCK-TAG TARGET-CATCH-BLOCK) TAG))
	   (RETURN (ZEROP (CATCH-BLOCK-INVALID TARGET-CATCH-BLOCK))))
	 (WHEN (NULL (SETF TARGET-CATCH-BLOCK (CATCH-BLOCK-PREVIOUS TARGET-CATCH-BLOCK)))
	   (RETURN NIL))))))

;;; Must be exactly two frames beween us and the frame being popped
;;; This needs to be called on the aux stack.
(DEFUN POP-GREAT-GRANDFATHERS-STACK (N)
  (DECLARE (SAFEGUARDED-FUNCTION))
  (LET* ((FATHERS-FP (%POINTER-PLUS (%STACK-FRAME-POINTER)
				    (- (LDB %%CR.CALLER-FRAME-SIZE
					    (%READ-INTERNAL-REGISTER
					      %REGISTER-CONTROL-REGISTER)))))
	 (GRANDFATHERS-FP
	   (%POINTER-PLUS FATHERS-FP
			  (- (LDB %%CR.CALLER-FRAME-SIZE (%SAVED-CONTROL-REGISTER)))))
	 (GRANDFATHERS-NEW-FP (%POINTER-PLUS GRANDFATHERS-FP (- N))))
    ;; Make sure we're not moving an FP past the wired boundary.
    (STORAGE::NOTE-FRAME-POINTER-CHANGE
      %CURRENT-STACK-GROUP GRANDFATHERS-FP GRANDFATHERS-NEW-FP)
    ;; Copy grandfather's FP back N locations, put NILs in the rest (POE)
    (LET ((READ-POINTER GRANDFATHERS-FP))
      (WITH-BLOCK-REGISTERS (1)
	(SETF (%BLOCK-REGISTER 1) GRANDFATHERS-NEW-FP)
	(%BLOCK-WRITE
	  1
	  (PROG1 (%MEMORY-READ READ-POINTER :CYCLE-TYPE %MEMORY-SCAVENGE :SET-CDR-NEXT NIL)
		 (PREPARE-FOR-BLOCK-WRITE)))
	(SETF READ-POINTER (%POINTER-PLUS READ-POINTER 1))
	(%BLOCK-WRITE
	  1
	  (PROG1 (%MEMORY-READ READ-POINTER :CYCLE-TYPE %MEMORY-SCAVENGE :SET-CDR-NEXT NIL)
		 (PREPARE-FOR-BLOCK-WRITE)))
	(LET ((NIL-VAR))
	  (LOOP REPEAT N DOING (%BLOCK-WRITE 1 NIL-VAR)))))
    (INCF (%P-LDB %%CR.CALLER-FRAME-SIZE
		  (LOCF (FRAME-CALLER-CONTROL-REGISTER (%STACK-FRAME-POINTER)))) N)
    (DECF (%P-LDB %%CR.CALLER-FRAME-SIZE
		  (LOCF (FRAME-CALLER-CONTROL-REGISTER FATHERS-FP))) N)))

;;; Must be exactly one frame between us and the frame being popped
(DEFUN POP-GRANDFATHERS-STACK (N)
  (DECLARE (SAFEGUARDED-FUNCTION))
  (%FUNCALL-IN-AUX-STACK #'POP-GREAT-GRANDFATHERS-STACK N))

;;; Similar stack unwinding primitives

;;; VERIFY-FRAME
;;;
;;;   FRAME is NIL or a frame pointer in the current stack.  We return the frame
;;;   pointer, after making sure that it is legitimate.
(DEFUN VERIFY-FRAME (FRAME)
  (LET* ((MY-FRAME-POINTER (%STACK-FRAME-POINTER))
	 (MY-STACK-BASE (DECODE-STACK-ADDRESS MY-FRAME-POINTER)))
    (UNLESS FRAME
      (SETQ FRAME (%MAKE-POINTER-OFFSET DTP-LOCATIVE MY-STACK-BASE 2)))
    (UNLESS (AND (%POINTER-LESSP MY-STACK-BASE FRAME)
		 (%POINTER-LESSP FRAME (%STACK-FRAME-POINTER)))
      (FERROR "FRAME is not in the current stack group"))
    ;; Make sure that the frame can be reached
    (LET ((CR (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER))
	  (FP MY-FRAME-POINTER))
      (LOOP WHILE (%POINTER-LESSP FRAME FP)
	    DOING
	(PSETQ CR (FRAME-CALLER-CONTROL-REGISTER FP)
	       FP (%MAKE-POINTER-OFFSET DTP-LOCATIVE FP (- (LDB %%CR.CALLER-FRAME-SIZE CR))))
	    FINALLY
	      (UNLESS (EQ FP FRAME)
		(FERROR "Attempt to return from a frame illegally"))))
    FRAME))

;;; Find the control register, starting PC and the extra argument for a
;;; function call.  This is supposed to do the same thing that
;;; START-CALL would.
(DEFUN START-CALL-VALUES (CONTROL-REGISTER FUNCTION)
  (DECLARE (WIRED-FUNCTION)
	   ;; Wired code doesn't use these paths
	   (UNSAFEGUARDED-REFERENCE DEBUGGING-INFO FSYMEVAL :LEXICAL-VARIABLE-INSTRUCTIONS)
	   (VALUES CONTROL-REGISTER PC EXTRA-ARG))
  (LET ((CONTROL-REGISTER (DPB 1 %%CR.CALL-STARTED CONTROL-REGISTER)))
    (LOOP DOING
      (CL:TYPECASE FUNCTION
	(COMPILED-FUNCTION
	  (RETURN-FROM START-CALL-VALUES
	    (VALUES (DPB 0 %%CR.EXTRA-ARGUMENT CONTROL-REGISTER)
		    (%MAKE-POINTER DTP-EVEN-PC FUNCTION)
		    NIL)))
	(SYMBOL
	  (SETQ FUNCTION (CL:SYMBOL-FUNCTION FUNCTION)))
	(LEXICAL-CLOSURE
	  (LET ((CLOSURE-FUNCTION (LEXICAL-CLOSURE-FUNCTION FUNCTION)))
	    (RETURN-FROM START-CALL-VALUES
	      (IF (CL:TYPEP CLOSURE-FUNCTION 'COMPILED-FUNCTION)
		  (VALUES
		    (DPB 1 %%CR.EXTRA-ARGUMENT CONTROL-REGISTER)
		    (%MAKE-POINTER DTP-EVEN-PC CLOSURE-FUNCTION)
		    (WHEN (ASSOC :LEXICAL-VARIABLE-INSTRUCTIONS
				 (DEBUGGING-INFO FUNCTION))
		      (LEXICAL-CLOSURE-ENVIRONMENT FUNCTION)))
		  (VALUES
		    (DPB 1 %%CR.EXTRA-ARGUMENT CONTROL-REGISTER)
		    (%MEMORY-READ (+ %TRAP-VECTOR-BASE
				     %INTERPRETER-FUNCTION-VECTOR
				     DTP-LEXICAL-CLOSURE)
				  :SET-CDR-NEXT T)
		    FUNCTION)))))
	(GENERIC-FUNCTION
	  (RETURN-FROM START-CALL-VALUES
	    (VALUES
	      (DPB 1 %%CR.EXTRA-ARGUMENT CONTROL-REGISTER)
	      (%MAKE-POINTER
		DTP-EVEN-PC
		(+ %TRAP-VECTOR-BASE
		   %GENERIC-DISPATCH-TRAP-VECTOR))
	      FUNCTION)))
	(SCL:INSTANCE
	  (RETURN-FROM START-CALL-VALUES
	    (VALUES
	      (DPB 1 %%CR.EXTRA-ARGUMENT CONTROL-REGISTER)
	      (%MAKE-POINTER
		DTP-EVEN-PC
		(+ %TRAP-VECTOR-BASE
		   %MESSAGE-DISPATCH-TRAP-VECTOR))
	      FUNCTION)))
	(OTHERWISE
	  (RETURN-FROM START-CALL-VALUES
	    (VALUES
	      (DPB 1 %%CR.EXTRA-ARGUMENT CONTROL-REGISTER)
	      (%MEMORY-READ (+ %TRAP-VECTOR-BASE
			       %INTERPRETER-FUNCTION-VECTOR
			       (%DATA-TYPE FUNCTION))
			    :SET-CDR-NEXT T)
	      FUNCTION)))))))

(DEFUN FINISH-CALL-VALUES (CONTROL-REGISTER SP FP VALUE-DISPOSITION APPLY N-ARGS+2)
  (DECLARE (WIRED-FUNCTION)
	   (VALUES CONTROL-REGISTER LP FP))
  (LET ((PUSHED-ARGS (+ (LDB %%CR.EXTRA-ARGUMENT CONTROL-REGISTER) N-ARGS+2)))
    (VALUES 
      (DPBS (- PUSHED-ARGS APPLY) %%CR.ARGUMENT-SIZE
	    APPLY %%CR.APPLY
	    0 %%CR.CALL-STARTED
	    VALUE-DISPOSITION %%CR.VALUE-DISPOSITION
	    (1+ (%POINTER-DIFFERENCE (%POINTER-PLUS SP (- PUSHED-ARGS)) FP))
	    %%CR.CALLER-FRAME-SIZE
	    CONTROL-REGISTER)
      (%POINTER-PLUS SP (- 1 APPLY))
      (%POINTER-PLUS SP (- 1 PUSHED-ARGS)))))

;;; Invalidate all catch blocks above frame.
(DEFUN INVALIDATE-INTERVENING-CATCH-BLOCKS (FRAME)
  (WITHOUT-INTERRUPTS
    (LOOP FOR CB FIRST (%READ-INTERNAL-REGISTER %REGISTER-CATCH-BLOCK-LIST)
		 THEN (CATCH-BLOCK-PREVIOUS CB)
	  WHILE (AND CB (%POINTER-LESSP FRAME CB))
	  DOING
      (WHEN (CATCH-BLOCK-P CB)
	(SETF (CATCH-BLOCK-INVALID CB) 1)))))

;;; VALUES is a list of values to be returned.
(DEFUN %RETURN-FROM-FRAME (FRAME VALUES)
  (SETQ FRAME (VERIFY-FRAME FRAME))
  ;; The frame is valid, so set the value disposition of the intervening frames to
  ;; RETURN, starting with our own frame
  (WITHOUT-INTERRUPTS
    (INVALIDATE-INTERVENING-CATCH-BLOCKS FRAME)
    (SETF (LDB %%CR.VALUE-DISPOSITION (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER))
	  VALUE-DISPOSITION-RETURN)
    (LOOP FOR OLD-FP FIRST (%READ-INTERNAL-REGISTER %REGISTER-FP) THEN FP
	  FOR OLD-CR FIRST (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER) THEN CR
	  FOR FP = (%POINTER-PLUS OLD-FP (- (LDB %%CR.CALLER-FRAME-SIZE OLD-CR)))
	  FOR CR = (FRAME-CALLER-CONTROL-REGISTER OLD-FP)
	  WHILE (%POINTER-LESSP FRAME FP)
	  DO (%P-DPB VALUE-DISPOSITION-RETURN %%CR.VALUE-DISPOSITION
		     (LOCF (FRAME-CALLER-CONTROL-REGISTER OLD-FP)))
	  FINALLY (WHEN (LDB-TEST %%CR.CALL-STARTED CR)
		    (SETF (FRAME-CALLER-CONTINUATION OLD-FP)
			  (FRAME-CALLER-CONTINUATION
			    (DBG:SPARTAN-FRAME-NEXT-OPEN-FRAME FP OLD-FP))))))
  ;; And finally return the values
  (VALUES-LIST VALUES))

;;; If args is T, do restart, else do apply.
(DEFUN %UNWIND-TO-FRAME-AND-RESTART-OR-APPLY (FRAME NEW-FUNCTION ARGS)
  (LABELS
    ((%UNWIND-TO-FRAME-AND-RESTART-OR-APPLY-INTERNAL (FRAME NEW-FUNCTION ARGS)
       (SETQ FRAME (VERIFY-FRAME FRAME))
       (INVALIDATE-INTERVENING-CATCH-BLOCKS FRAME)
       ;; Set the intervening value dispositions to be return,
       ;; including ourself.  Also, set the saved continuation
       ;; of the callee of FRAME so that the helper function (PC
       ;; is in our continuation now) takes over when we finish
       ;; the returns.
       (MULTIPLE-VALUE-BIND
	 (NEXT-FRAME NEXT-NEXT-FRAME OLD-FRAME-CONTROL FRAME-CONTINUATION)
	   (WITHOUT-INTERRUPTS
	     (SETF (LDB %%CR.VALUE-DISPOSITION
			(%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER))
		   VALUE-DISPOSITION-RETURN)
	     (LOOP FOR OLD-OLD-FP FIRST NIL THEN OLD-FP
		   FOR OLD-FP FIRST (%STACK-FRAME-POINTER) THEN FP
		   FOR OLD-CR FIRST (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER)
			      THEN CR
		   FOR FP = (%POINTER-PLUS OLD-FP (- (LDB %%CR.CALLER-FRAME-SIZE OLD-CR)))
		   FOR CR = (FRAME-CALLER-CONTROL-REGISTER OLD-FP)
		   DO (IF (%POINTER-LESSP FRAME FP)	;or check not eq?
			  ;; Return through this frame's caller
			  (%P-DPB VALUE-DISPOSITION-RETURN %%CR.VALUE-DISPOSITION
				  (LOCF (FRAME-CALLER-CONTROL-REGISTER OLD-FP)))
			  ;; old-fp is now frame's callee, so it has frame's
			  ;; continuation and control registers.
			  (RETURN
			    ;; Set continuation for frame (in its callee
			    ;; frame) so that it will cause the helper
			    ;; function to be invoked.
			    (MULTIPLE-VALUE-PROG1
			      (VALUES OLD-FP OLD-OLD-FP CR (FRAME-CALLER-CONTINUATION OLD-FP))
			      ;; Return multiple values from frame
			      (%P-DPB VALUE-DISPOSITION-MULTIPLE %%CR.VALUE-DISPOSITION
				      (LOCF (FRAME-CALLER-CONTROL-REGISTER OLD-FP)))
			      ;; And go to our helper when we return
			      (SETF (FRAME-CALLER-CONTINUATION OLD-FP)
				    (%READ-INTERNAL-REGISTER
				      %REGISTER-CONTINUATION)))))))
	 (DECLARE (IGNORE NEXT-NEXT-FRAME))	;Until code commented below goes back in.
	 (WHEN (LDB-TEST %%CR.CALL-STARTED OLD-FRAME-CONTROL)
	   (SETQ FRAME-CONTINUATION
		 (FRAME-CALLER-CONTINUATION
		   (DBG:SPARTAN-FRAME-NEXT-OPEN-FRAME FRAME NEXT-FRAME))))
	 (LET ((APPLY 0)
	       (N-ARGS)
	       (OLD-EXTRA-ARG-P NIL
;		 (WHEN (EQ ARGS T)     ;no need to compute o-e-a-p unless doing %restart-frame
;		   (LET ((OLD-FUNCTION
;			   (FUNCTION-NAME
;			     (DBG:SPARTAN-FRAME-FUNCTION NEXT-FRAME NEXT-NEXT-FRAME))))
;		     (COND ((EQUAL OLD-FUNCTION '(:PROPERTY DTP-LIST INTERPRETER-FUNCTION))
;			    T)
;			   ((AND (CL:CONSP OLD-FUNCTION) (EQ (CAR OLD-FUNCTION) :INTERNAL))
;			    (NOT (NULL (ASSOC :LEXICAL-VARIABLE-INSTRUCTIONS
;					      (DEBUGGING-INFO OLD-FUNCTION)))))
;			   ((CL:CONSP OLD-FUNCTION)
;			    T)
;			   (T NIL))))
		 )
	       (OLD-FRAME-END)
	       (INDEX)
	       (NEW-EXTRA-ARG)
	       (NEW-FRAME-CONTROL)
	       (NEW-FUNCTION-START-PC))
	   ;; Start the call to NEW-FUNCTION
	   ;; Don't set the cdr-codes to 3 here, that would be an illegal frame.
	   ;; Instead, we fix this up in the helper function below.
	   (%PUSH (%MEMORY-READ FRAME :SET-CDR-NEXT T))
	   (%PUSH (%MEMORY-READ (%POINTER-PLUS FRAME 1) :SET-CDR-NEXT T))
	   (MULTIPLE-VALUE (NEW-FRAME-CONTROL NEW-FUNCTION-START-PC NEW-EXTRA-ARG)
	     (START-CALL-VALUES OLD-FRAME-CONTROL NEW-FUNCTION))
	   (WHEN NEW-EXTRA-ARG
	     (%PUSH NEW-EXTRA-ARG))
	   ;; Copy the arguments
	   (IF (EQ ARGS T)
	       (PROGN				; %restart-frame - re-cycle the args in frame
		 ;;The apply bit tells us that after the spread args there is an apply arg
		 ;;which we also need to copy and tell the new function about.
		 (SETQ APPLY (LDB %%CR.APPLY OLD-FRAME-CONTROL)
		       N-ARGS (LDB %%CR.ARGUMENT-SIZE OLD-FRAME-CONTROL)
		       OLD-FRAME-END (+ N-ARGS APPLY)
		       INDEX (IF OLD-EXTRA-ARG-P 3 2))
		 (LOOP UNTIL (= INDEX OLD-FRAME-END)
		       DO (%PUSH (%MEMORY-READ (%POINTER-PLUS FRAME INDEX) :SET-CDR-NEXT T))
			  (INCF INDEX))
		 (WHEN OLD-EXTRA-ARG-P (DECF N-ARGS)))
	       (PROGN				; %unwind-to-frame-and-funcall
		 (SETQ N-ARGS (+ 2 (LENGTH ARGS)))
		 (LOOP UNTIL (NULL ARGS) DO (%PUSH (POP ARGS)))))
	   ;; Finish the "call"
	   (WHEN NEW-EXTRA-ARG (INCF N-ARGS))
	   (SETQ NEW-FRAME-CONTROL
		 (DPBS N-ARGS %%CR.ARGUMENT-SIZE
		       APPLY %%CR.APPLY
		       0 %%CR.CALL-STARTED
		       0 %%CR.CLEANUP-BITS
		       (LDB %%CR.VALUE-DISPOSITION OLD-FRAME-CONTROL) %%CR.VALUE-DISPOSITION
		       (LDB %%CR.CALLER-FRAME-SIZE OLD-FRAME-CONTROL) %%CR.CALLER-FRAME-SIZE
		       NEW-FRAME-CONTROL))
	   ;; PC
	   (%PUSH NEW-FUNCTION-START-PC)
	   ;; Control
	   (%PUSH NEW-FRAME-CONTROL)
	   ;; LP
	   (%PUSH (%POINTER-PLUS FRAME N-ARGS))
	   ;; FP
	   (%PUSH FRAME)
	   ;; Continuation
	   (%PUSH FRAME-CONTINUATION)
	   ;; Size of this multiple-value-group
	   (%PUSH (+ 5 N-ARGS APPLY))
	   (%RETURN-MULTIPLE)))))
    (%UNWIND-TO-FRAME-AND-RESTART-OR-APPLY-INTERNAL FRAME NEW-FUNCTION ARGS)
    ;; This is the helper function -- it does a finish-call by hand.  The stack cache
    ;; is already set up for this frame, since the new frame is in the multiple value group.
    ;; This needs to be in extra-stack mode to interlock with stack-wiring.
    (%SET-TRAP-MODE TRAP-MODE-EXTRA-STACK)
    (%POP)					;Size of M-V-G
    #-VLM
    (PROGN
      (%WRITE-INTERNAL-REGISTER (%POP) %REGISTER-CONTINUATION)
      (COMPILER:NO-OP)
      (%WRITE-INTERNAL-REGISTER (%POP) %REGISTER-FP)
      (COMPILER:NO-OP)
      (%WRITE-INTERNAL-REGISTER (%POP) %REGISTER-LP)
      (COMPILER:NO-OP)
      ;; Fix the cdr-codes now so that this is a legal frame.  This uses the new FP, above.
      (%P-DPB 3 %%Q-CDR-CODE (LOCF (%SAVED-CONTINUATION-REGISTER)))
      (%P-DPB 3 %%Q-CDR-CODE (LOCF (%SAVED-CONTROL-REGISTER)))
      ;; Copy the current trap-on-exit bit into the saved control register.
      ;; It may have changed since we snapshotted it, due to stack wiring.
      (%P-DPB (LDB %%CR.TRAP-ON-EXIT-BIT (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER))
	      %%CR.TRAP-ON-EXIT-BIT (LOCF (%SAVED-CONTROL-REGISTER)))
      ;; Now restore the control register, which includes the proper trap mode.
      (%WRITE-INTERNAL-REGISTER (%POP) %REGISTER-CONTROL-REGISTER)
      (COMPILER:NO-OP)
      (COMPILER:NO-OP))
    #+VLM
    (PROGN
      (%COPROCESSOR-WRITE 0 SYS:%COPROCESSOR-REGISTER-UNWIND-STACK-FOR-RESTART-OR-APPLY)
      (COMPILER:%PUSH-N -4))
    (%JUMP (%POP))))
  
;;; Unwind down to this frame and then start it up again.
(DEFUN %RESTART-FRAME (FRAME FUNCTION)
  (%UNWIND-TO-FRAME-AND-RESTART-OR-APPLY FRAME FUNCTION T))

;;; Unwind to FRAME (or all the way if FRAME is null) and then apply FUNCTION to ARGS
(DEFUN %UNWIND-TO-FRAME-AND-FUNCALL (FRAME FUNCTION &REST ARGS)
  (%UNWIND-TO-FRAME-AND-RESTART-OR-APPLY FRAME FUNCTION ARGS))

;Specially coded to minimize instructions and branches in the inner loop
(DEFUN VALIDATE-KEYWORDS-INTERNAL (VALID-KEYWORDS ARGLIST)
  (DECLARE (DBG:ERROR-REPORTER T))
  (UNLESS (ENDP ARGLIST)			;Allow end test to be at bottom of loop
    (LET ((L ARGLIST))
      (MACROLET ((STEP-L ()
		   `(PROGN
		      (COMPILER:%ERROR-WHEN (ENDP (SETF L (CDR L)))
			(LISP:CERROR "Assume NIL as the value of the ~S keyword argument"
				     "The value after the keyword ~S is missing."
				     (CAR (LAST ARGLIST)))
			(RETURN-FROM VALIDATE-KEYWORDS-INTERNAL NIL))
		      (WHEN (ENDP (SETF L (CDR L)))
			(RETURN-FROM VALIDATE-KEYWORDS-INTERNAL NIL)))))
	(LISP:LOOP
	     (COMPILER:%ERROR-UNLESS (NOT (NULL (LISP:MEMBER (CAR L) VALID-KEYWORDS)))
	       (COND ((EQ (CAR L) :ALLOW-OTHER-KEYS))
		     ((LISP:GETF ARGLIST :ALLOW-OTHER-KEYS)
		      (LISP:LOOP (STEP-L)))
		     (T
		      (LISP:CERROR "Ignore the keyword argument ~S"
				   "~S is not a valid keyword" (CAR L)))))
	     (STEP-L))))))

;Specially coded to minimize instructions and branches in the inner loop
(DEFUN VALIDATE-KEYWORDS-INTERNAL-ALLOW-OTHER-KEYS (ARGLIST)
  (DECLARE (DBG:ERROR-REPORTER T))
  (UNLESS (ENDP ARGLIST)			;Allow end test to be at bottom of loop
    (LET ((L ARGLIST))
      (CL:LOOP
	 (COMPILER:%ERROR-WHEN (ENDP (SETF L (CDR L)))
	   (CL:CERROR "Assume NIL as the value of the ~S keyword argument"
		      "The value after the keyword ~S is missing."
		      (CAR (LAST ARGLIST)))
	   (RETURN NIL))
	 (WHEN (ENDP (SETF L (CDR L)))
	   (RETURN NIL))))))

;Specially coded to minimize instructions and branches in the inner loop
(DEFUN KEYWORD-SUPPLIED-P-INTERNAL (KEYWORD ARGLIST)
  (MULTIPLE-VALUE-BIND (NIL FOUNDP)
      (RGETF KEYWORD ARGLIST)
    (CL:CONSP FOUNDP)))

;;; This variable is bound by the WITHOUT-ABORTS and WITH-ABORTS-ENABLED macros.
;;; THROW-INHIBIT-REASONS looks at every binding; it doesn't look at just the innermost
;;; binding as with an ordinary special variable.
;;; If the value is a symbol, it's a WITH-ABORTS-ENABLED identifier.
;;; If the value is a list, it represents an invocation of WITHOUT-ABORTS.
;;;   If the first list element is a symbol, it's an identifier to match WITH-ABORTS-ENABLED.
;;;   The next list element (the first if there is no identifier) is a format string.
;;;   The remaining list elements are arguments for that format string.
(DEFVAR-RESETTABLE *WITHOUT-ABORTS-REASON* NIL)

;;; The FORMAT string used by the message automatically generated
;;; by SI:THROW-INHIBIT-REASONS for an UNWIND-PROTECT cleanup form.
;;; This allows these messages to be recognized and suppressed when appropriate.
(DEFVAR *UNWIND-PROTECT-THROW-INHIBIT-REASON*
"The function ~S is executing a cleanup form.
Aborting before the cleanup is complete could leave the program in
an inconsistent state and cause it to operate incorrectly later.")

;;; Returns NIL if it is okay to throw to the specified tag, otherwise
;;; returns a list of lists (reason . format-args) why throwing is inhibited.
;;; The innermost reason is first on the list.
;;; If tag is NIL or no tag is specified, looks all the way down the stack.
;;; No error if tag not found, just looks all the way down the stack.
;;; If you don't specify SG, the current stack group is used.
;;; If you do specify SG, you must do a WITHOUT-INTERRUPTS.
(DEFUN THROW-INHIBIT-REASONS (&OPTIONAL TAG SG BOTTOM-FRAME)
  (WHEN (EQ SG %CURRENT-STACK-GROUP)
    (SETQ SG NIL))
  (WHEN SG
    (CHECK-ARG-TYPE SG :STACK-GROUP))
  (LET ((REASONS NIL)
	(TAG-CB NIL)
	(ABORTS-ENABLED NIL)
	(SAVED-REASON *WITHOUT-ABORTS-REASON*))
    (MULTIPLE-VALUE-BIND (FP CR CONTINUATION BSP BOTTOM)
	(IF SG
	    (VALUES (SG-FRAME-POINTER SG)
		    (SG-CONTROL-REGISTER SG)
		    (SG-CONTINUATION SG)
		    (SG-BINDING-STACK-POINTER SG)
		    (SG-CONTROL-STACK-LOW SG))
	    (VALUES (%READ-INTERNAL-REGISTER %REGISTER-FP)
		    (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER)
		    (%READ-INTERNAL-REGISTER %REGISTER-CONTINUATION)
		    (%READ-INTERNAL-REGISTER %REGISTER-BINDING-STACK-POINTER)
		    (SG-CONTROL-STACK-LOW %CURRENT-STACK-GROUP)))
      ;; Do sanity check here.....
      (UNLESS (AND (LOCATIVEP FP)
		   (OR (TYPE-MEMBER CONTINUATION DTP-EVEN-PC DTP-ODD-PC)
		       (AND (NULL CONTINUATION)
			    ( (%POINTER-DIFFERENCE FP BOTTOM) 4)))
		   (FIXNUMP CR)
		   (NOT (%POINTER-LESSP FP BOTTOM)))
	(SCL:CERROR "Return a reason signifying that this stack shouldn't be unwound"
		    "The stack-group ~S was in an invalid state"
		    (OR SG %CURRENT-STACK-GROUP))
	(RETURN-FROM THROW-INHIBIT-REASONS
	  (NCONS (LIST "The stack-group ~S was in an invalid state"
		       (OR SG %CURRENT-STACK-GROUP)))))
      
      ;; Traverse the stack as %THROW would, collecting without-aborts reasons on the way
      (LET ((CB (AND TAG
		     (LOOP FOR TEST-CB = (IF SG
					     (SG-CATCH-BLOCK-LIST SG)
					     (%READ-INTERNAL-REGISTER
					       %REGISTER-CATCH-BLOCK-LIST))
				       THEN (CATCH-BLOCK-PREVIOUS TEST-CB)
			   UNTIL (OR (NULL TEST-CB)
				     (AND TAG (EQ (CATCH-BLOCK-TAG TEST-CB) TAG)
					  (SETQ TAG-CB TEST-CB)
					  ;; don't return this tag in
					  ;; case there's another
					  ;; identically named tag later
					  ;; on, if we have a
					  ;; BOTTOM-FRAME
					  (OR (NULL BOTTOM-FRAME)
					      (NOT (%POINTER-LESSP BOTTOM-FRAME TEST-CB))))
				     ;; If there's a pointer, and we
				     ;; pass it, and we've already found
				     ;; the TAG.
				     (AND BOTTOM-FRAME
					  (NOT (%POINTER-LESSP BOTTOM-FRAME TEST-CB))
					  (NOT (NULL TAG-CB))
					  (SETQ TEST-CB TAG-CB)))
			   FINALLY (RETURN TEST-CB)))))
	(LOOP WHILE (LDB-TEST %%CR.CALLER-FRAME-SIZE CR)	;While frame-size > 0
	      ;; CB is NIL or the catch-block to which we are going to throw
	      WHILE (OR (NULL CB) (%POINTER-LESSP CB FP))
	      AS UNWIND-ENABLED = NIL
	      DOING
	  (IGNORE UNWIND-ENABLED)	;I don't know why we bother computing this --Moon
					;For the Rev3 chip -- Greenwald
	  ;; This frame is going away
	  (WHEN (NOT (ZEROP (LDB %%CR.CLEANUP-BINDINGS CR)))
	    (LOOP AS OBSP = BSP
		  DO
	      (WHEN (EQ (BINDING-STACK-CELL BSP)
			(VARIABLE-LOCATION *WITHOUT-ABORTS-REASON*))
		(LET ((REASON (IF SG (BINDING-STACK-CONTENTS BSP)
				  (CL:SHIFTF SAVED-REASON
					     (BINDING-STACK-CONTENTS BSP)))))
		  (COND ((ATOM REASON)
			 (IF (EQ REASON 'UNWIND-PROTECT)
			     (SETQ UNWIND-ENABLED T)
			     (PUSH REASON ABORTS-ENABLED)))
			((SYMBOLP (CAR REASON))
			 (IF (MEMQ (CAR REASON) ABORTS-ENABLED)
			     (SETQ ABORTS-ENABLED
				   (DELQ (CAR REASON) ABORTS-ENABLED 1))
			     (PUSH (CDR REASON) REASONS)))
			(T (PUSH REASON REASONS)))))
	      (SETQ BSP (%MAKE-POINTER-OFFSET DTP-LOCATIVE BSP -2))
		  UNTIL (ZEROP (BINDING-STACK-CHAIN-BIT OBSP))))
	  (LET ((OLD-FP FP)
		(FRAME-SIZE (LDB %%CR.CALLER-FRAME-SIZE CR)))
	    (SETQ FP (%POINTER-PLUS FP (- FRAME-SIZE))
		  CR (FRAME-CALLER-CONTROL-REGISTER OLD-FP)
		  CONTINUATION (FRAME-CALLER-CONTINUATION OLD-FP))
	    (UNLESS (AND (FIXNUMP CR)
			 (OR (TYPE-MEMBER CONTINUATION DTP-EVEN-PC DTP-ODD-PC)
			     (AND (NULL CONTINUATION)
				  ( (%POINTER-DIFFERENCE FP BOTTOM) 4)))
			 (NOT (%POINTER-LESSP FP BOTTOM))
			 ( FRAME-SIZE CONTROL-STACK-MAX-FRAME-SIZE))
	      (SCL:CERROR "Return a reason signifying that this stack shouldn't be unwound"
			  "The stack-group ~S was in an invalid state"
			  (OR SG %CURRENT-STACK-GROUP))
	      (RETURN-FROM THROW-INHIBIT-REASONS
		(NCONS (LIST "The stack-group ~S was in an invalid state"
			     (OR SG %CURRENT-STACK-GROUP))))))
	      FINALLY
		;; Now FP is the frame we are throwing to and BSP is
		;; the innermost binding in that frame and CB is the
		;; catch block in that frame.  Take care of any parts
		;; of that frame that are going away.  This duplicates
		;; the code above, tough cookies
		(LOOP WITH LIMIT = (IF CB
				       (CATCH-BLOCK-BINDING-STACK-POINTER CB)
				       (%POINTER-PLUS
					 (SG-BINDING-STACK-LOW (OR SG %CURRENT-STACK-GROUP))
					 1))
		      UNTIL (EQ BSP LIMIT) DO
		  (WHEN (EQ (BINDING-STACK-CELL BSP)
			    (VARIABLE-LOCATION *WITHOUT-ABORTS-REASON*))
		    (LET ((REASON (IF SG (BINDING-STACK-CONTENTS BSP)
				      (CL:SHIFTF SAVED-REASON
						 (BINDING-STACK-CONTENTS BSP)))))
		      (COND ((ATOM REASON)
			     (UNLESS (EQ REASON 'UNWIND-PROTECT)
			       (PUSH REASON ABORTS-ENABLED)))
			    ((SYMBOLP (CAR REASON))
			     (IF (MEMQ (CAR REASON) ABORTS-ENABLED)
				 (SETQ ABORTS-ENABLED (DELQ (CAR REASON) ABORTS-ENABLED 1))
				 (PUSH (CDR REASON) REASONS)))
			    (T (PUSH REASON REASONS)))))
		  (SETQ BSP (%MAKE-POINTER-OFFSET DTP-LOCATIVE BSP -2)))
		(RETURN-FROM THROW-INHIBIT-REASONS (NREVERSE REASONS)))))))

;; old version. Let's think about this again when %%cr.cleanup-in-progress works in a 
;; meaningful way.
#+IGNORE
(DEFUN THROW-INHIBIT-REASONS (&OPTIONAL TAG SG)
  (WHEN (EQ SG %CURRENT-STACK-GROUP)
    (SETQ SG NIL))
  (LET ((REASONS NIL)
	(ABORTS-ENABLED NIL)
	(SAVED-REASON *WITHOUT-ABORTS-REASON*))
    ;; Traverse the stack as %THROW would, collecting without-aborts reasons on the way
    (LOOP FOR CB = (IF SG (SG-CATCH-BLOCK-LIST SG)
		       (%READ-INTERNAL-REGISTER %REGISTER-CATCH-BLOCK-LIST))
		 THEN (CATCH-BLOCK-PREVIOUS CB) DO
      (WHEN (OR (NULL CB) (AND TAG (EQ (CATCH-BLOCK-TAG CB) TAG)))
	(MULTIPLE-VALUE-BIND (FP CR CONTINUATION BSP)
	    (IF SG
		(VALUES (SG-FRAME-POINTER SG)
			(SG-CONTROL-REGISTER SG)
			(SG-CONTINUATION SG)
			(SG-BINDING-STACK-POINTER SG))
		(VALUES (%READ-INTERNAL-REGISTER %REGISTER-FP)
			(%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER)
			(%READ-INTERNAL-REGISTER %REGISTER-CONTINUATION)
			(%READ-INTERNAL-REGISTER %REGISTER-BINDING-STACK-POINTER)))
	  (LOOP UNTIL (ZEROP (LDB %%CR.CALLER-FRAME-SIZE CR))
		;; CB is NIL or the catch-block to which we are going to throw
		WHILE (OR (NULL CB) (%POINTER-LESSP CB FP))
		DOING
	    ;; This frame is going away
	    (WHEN (NOT (ZEROP (LDB %%CR.CLEANUP-BINDINGS CR)))
	      (LOOP AS OBSP = BSP
		    DO
		(WHEN (EQ (BINDING-STACK-CELL BSP)
			  (VARIABLE-LOCATION *WITHOUT-ABORTS-REASON*))
		  (LET ((REASON (IF SG (BINDING-STACK-CONTENTS BSP)
				    (CL:SHIFTF SAVED-REASON
					       (BINDING-STACK-CONTENTS BSP)))))
		    (COND ((ATOM REASON) (PUSH REASON ABORTS-ENABLED))
			  ((SYMBOLP (CAR REASON))
			   (IF (MEMQ (CAR REASON) ABORTS-ENABLED)
			       (SETQ ABORTS-ENABLED
				     (DELQ (CAR REASON) ABORTS-ENABLED 1))
			       (PUSH (CDR REASON) REASONS)))
			  (T (PUSH REASON REASONS)))))
		(SETQ BSP (%MAKE-POINTER-OFFSET DTP-LOCATIVE BSP -2))
		    UNTIL (ZEROP (BINDING-STACK-CHAIN-BIT OBSP))))
	    (WHEN (NOT (ZEROP (LDB %%CR.CLEANUP-IN-PROGRESS CR)))
	      (LET ((FUNCTION-NAME (FUNCTION-NAME (%FIND-STRUCTURE-HEADER CONTINUATION))))
		(WHEN (EQ FUNCTION-NAME 'UNWIND-PROTECT)	;Interpreter
		  ;; We can't do what the L machine does here, so give up for now
		  (ERROR "You lose!"))
		(IF (MEMQ 'UNWIND-PROTECT ABORTS-ENABLED)
		    (SETQ ABORTS-ENABLED (DELQ 'UNWIND-PROTECT ABORTS-ENABLED 1))
		    (PUSH (LIST *UNWIND-PROTECT-THROW-INHIBIT-REASON* FUNCTION-NAME)
			  REASONS))))
	    (LET ((OLD-FP FP))
	      (SETQ FP (%POINTER-DIFFERENCE FP (LDB %%CR.CALLER-FRAME-SIZE CR))
		    CR (FRAME-CALLER-CONTROL-REGISTER OLD-FP)
		    CONTINUATION (FRAME-CALLER-CONTINUATION OLD-FP)))
		FINALLY
		  ;; Now FP is the frame we are throwing to and BSP is
		  ;; the innermost binding in that frame and CB is the
		  ;; catch block in that frame.  Take care of any parts
		  ;; of that frame that are going away.  This duplicates
		  ;; the code above, tough cookies
		  (LOOP WITH LIMIT = (IF CB
					 (CATCH-BLOCK-BINDING-STACK-POINTER CB)
					 (%POINTER-PLUS
					   (SG-BINDING-STACK-LOW (OR SG %CURRENT-STACK-GROUP))
					   1))
			UNTIL (EQ BSP LIMIT) DO
		    (WHEN (EQ (BINDING-STACK-CELL BSP)
			      (VARIABLE-LOCATION *WITHOUT-ABORTS-REASON*))
		      (LET ((REASON (IF SG (BINDING-STACK-CONTENTS BSP)
					(CL:SHIFTF SAVED-REASON
						   (BINDING-STACK-CONTENTS BSP)))))
			(COND ((ATOM REASON) (PUSH REASON ABORTS-ENABLED))
			      ((SYMBOLP (CAR REASON))
			       (IF (MEMQ (CAR REASON) ABORTS-ENABLED)
				   (SETQ ABORTS-ENABLED (DELQ (CAR REASON) ABORTS-ENABLED 1))
				   (PUSH (CDR REASON) REASONS)))
			      (T (PUSH REASON REASONS)))))
		    (SETQ BSP (%MAKE-POINTER-OFFSET DTP-LOCATIVE BSP -2)))
		  (RETURN-FROM THROW-INHIBIT-REASONS (NREVERSE REASONS))))))))

;;; Stack groups

;;--- Someday the word "pdl" should be expurgated from this
;; SGs must be in SAFEGUARDED-OBJECTS-AREA on the 3600 if the GC is to flip in that
;; process.  This is because of the A-memory variable %CURRENT-STACK-GROUP.
;; Consing them there is not so bad; there aren't very many of them.
;; On Ivory SGs must currently be in SAFEGUARDED-OBJECTS-AREA because stack-group
;; switching doesn't scavenge the stack-group object.  That could be changed, if it matters.
(DEFUN MAKE-STACK-GROUP (NAME &REST OPTIONS &KEY
                              (SG-AREA SAFEGUARDED-OBJECTS-AREA)
			      (REGULAR-PDL-AREA CONTROL-STACK-AREA)
			      (SPECIAL-PDL-AREA BINDING-STACK-AREA)
			      (REGULAR-PDL-SIZE 30000)	;3/8 a quantum
			      (SPECIAL-PDL-SIZE 4000)   ;Former process-run-function default
			      (ABSOLUTE-CONTROL-STACK-LIMIT NIL)
			      (ABSOLUTE-BINDING-STACK-LIMIT NIL)
			      (SAFE 1)
			      ALLOW-UNKNOWN-KEYWORDS &ALLOW-OTHER-KEYS
			      &AUX SG REGULAR-PDL SPECIAL-PDL)
  (UNLESS ALLOW-UNKNOWN-KEYWORDS
    (SI:VALIDATE-KEYWORDS-INTERNAL
      '(:SG-AREA :REGULAR-PDL-AREA :SPECIAL-PDL-AREA
		 :REGULAR-PDL-SIZE :SPECIAL-PDL-SIZE
		 :ABSOLUTE-CONTROL-STACK-LIMIT :ABSOLUTE-BINDING-STACK-LIMIT
		 :SAFE :ALLOW-UNKNOWN-KEYWORDS)
      OPTIONS))
  (WHEN (< REGULAR-PDL-SIZE (+ 2000 CONTROL-STACK-OVERFLOW-MARGIN))
    (FERROR "Regular PDL size ~S is too small; must be at least ~S"
	    REGULAR-PDL-SIZE (+ 2000 CONTROL-STACK-OVERFLOW-MARGIN)))
  (SETQ SG (MAKE-ARRAY (1- (DEFSTORAGE-SIZE STACK-GROUP))
		       :NAMED-STRUCTURE-SYMBOL 'STACK-GROUP
		       :AREA SG-AREA))
  (SETF (SG-STATUS-BITS SG) 0)
  (SETF (SG-UNINITIALIZED-BIT SG) 1)
  (SETF (SG-SAFE SG) SAFE)
  (SETF (SG-NAME SG) NAME)
  (SETQ SPECIAL-PDL
	(%MAKE-STACK SPECIAL-PDL-AREA SPECIAL-PDL-SIZE SG
		     %REGION-REPRESENTATION-TYPE-LIST %REGION-SPACE-BINDING-STACK))
  (SETQ REGULAR-PDL-SIZE (* (// (+ REGULAR-PDL-SIZE PAGE-SIZE -1) PAGE-SIZE) PAGE-SIZE))
  (SETQ REGULAR-PDL (%MAKE-STACK REGULAR-PDL-AREA REGULAR-PDL-SIZE
				 SG %REGION-REPRESENTATION-TYPE-LIST
				 %REGION-SPACE-CONTROL-STACK))
  (SETF (SG-STACK-POINTER SG) REGULAR-PDL)	;Must point somewhere within the stack
  (SETF (SG-CONTROL-STACK-LOW SG) REGULAR-PDL)
  (SETF (SG-CONTROL-STACK-LIMIT SG)
	(%MAKE-POINTER-OFFSET
	  DTP-LOCATIVE REGULAR-PDL
	  (- REGULAR-PDL-SIZE
	     CONTROL-STACK-OVERFLOW-MARGIN
	     CONTROL-STACK-MAX-FRAME-SIZE)))
  (SETF (SG-ABSOLUTE-CONTROL-STACK-LIMIT SG) ABSOLUTE-CONTROL-STACK-LIMIT)
  ;; Binding pairs always start on even addresses.  The bottom pair is not used, so
  ;; that the binding stack pointer points to always real storage.  The binding
  ;; stack pointer points to the top word of the pair.
  (SETF (SG-BINDING-STACK-POINTER SG) (%POINTER-PLUS SPECIAL-PDL 1))
  (SETF (SG-BINDING-STACK-LOW SG) SPECIAL-PDL)
  (SETF (SG-BINDING-STACK-LIMIT SG)
	(%MAKE-POINTER-OFFSET DTP-LOCATIVE SPECIAL-PDL (- SPECIAL-PDL-SIZE 1)))
  (SETF (SG-ABSOLUTE-BINDING-STACK-LIMIT SG) ABSOLUTE-BINDING-STACK-LIMIT)
  (SETF (SG-FLOAT-OPERATING-MODE SG) *DEFAULT-FLOAT-OPERATING-MODE*)
  (SETF (SG-FLOAT-OPERATION-STATUS SG) 0)
  (SETF (SG-STRUCTURE-STACK-POINTER-COUNT SG) 0)
  (%BLOCK-STORE-TAG-AND-POINTER (LOCF (SG-HARDWARE-STATUS-0 SG)) 16. DTP-NIL NIL 0)
  (SETF (SG-ERROR-TRAP-LEVEL SG) 0)
  (SETF (SG-WIRED-FRAME-DESCRIPTOR SG) 0)
  ;; Make the global values of the block registers reference memory which is
  ;; guaranteed not to exist.
  (LET ((BOGUS-POINTER (%MAKE-POINTER DTP-LOCATIVE
			 (%LOGDPBS %BOUNDARY-ZONE %%VMA-ZONE-NUM -1 %%VMA-OBLAST-NUM 0))))
    (SETF (SG-BAR-2 SG) BOGUS-POINTER)
    (SETF (SG-BAR-3 SG) BOGUS-POINTER)
    SG))

(DEFUN (STACK-GROUP NAMED-STRUCTURE-INVOKE) (OP &OPTIONAL SELF &REST ARGS)
  (COND ((EQ OP ':WHICH-OPERATIONS)
	 '(:DESCRIBE :PRINT-SELF))
	((EQ OP ':DESCRIBE)
	 (DESCRIBE-STACK-GROUP SELF))
	((EQ OP ':PRINT-SELF)
	 (SI:PRINTING-RANDOM-OBJECT (SELF (FIRST ARGS) :TYPEP)
	   (PRINC (SG-NAME SELF) (FIRST ARGS))))))

;;; Control Stack Manipulation (from another stack group)
;;;

;;; Right now, no one is making sure that two processes don't collide doing this kind
;;; of stuff.  Talk to Greenwald about locking requirements.
(DEFUN SG-%PUSH (STACK-GROUP VALUE &OPTIONAL (CDR-CODE CDR-NEXT))
  (DECLARE (WIRED-FUNCTION))
  (LET ((NEW-SP (%POINTER-PLUS (SG-STACK-POINTER STACK-GROUP) 1)))
    ;; The GC does not look at the part of the stack past SP, so we have to set SP
    ;; before writing VALUE, in case VALUE becomes old-space before we set SP.  So we
    ;; begin by writing a NIL just past SP, then moving SP, and then writing the
    ;; VALUE to the stack.
    (%P-STORE-CDR-AND-CONTENTS NEW-SP NIL CDR-NIL)
    (SETF (LOCATION-CONTENTS NEW-SP) NIL)
    (SETF (SG-STACK-POINTER STACK-GROUP) NEW-SP)
    (%P-STORE-CDR-AND-CONTENTS NEW-SP VALUE CDR-CODE)
    VALUE))

(DEFUN SG-%POP (STACK-GROUP)
  (DECLARE (WIRED-FUNCTION))
  (LET ((SP (SG-STACK-POINTER STACK-GROUP)))
    (PROG1 (LOCATION-CONTENTS SP)
	   (SETF (SG-STACK-POINTER STACK-GROUP) (%POINTER-PLUS SP -1)))))

(DEFUN SG-START-CALL (STACK-GROUP FUNCTION)
  (DECLARE (WIRED-FUNCTION))
  (LET ((CONTROL (SG-CONTROL-REGISTER STACK-GROUP)))
    (MULTIPLE-VALUE-BIND (CONTROL CONTINUATION EXTRA-ARG)
	(MULTIPLE-VALUE-PROG1
	  (START-CALL-VALUES CONTROL FUNCTION)
	  (SG-%PUSH STACK-GROUP (SG-CONTINUATION STACK-GROUP) 3)
	  (SG-%PUSH STACK-GROUP CONTROL 3))
      (WHEN EXTRA-ARG
	(SG-%PUSH STACK-GROUP EXTRA-ARG))
      (SETF (SG-CONTINUATION STACK-GROUP) CONTINUATION)
      (SETF (SG-CONTROL-REGISTER STACK-GROUP) CONTROL)
      NIL)))

(DEFUN SG-FINISH-CALL (STACK-GROUP VALUE-DISPOSITION APPLY N-ARGS)
  (DECLARE (WIRED-FUNCTION)
	   (SAFEGUARDED-REFERENCE STORAGE::UNWIRE-CONTROL-STACK-PAGES))
  (MULTIPLE-VALUE-BIND (CONTROL LP FP)
      (FINISH-CALL-VALUES
	(SG-CONTROL-REGISTER STACK-GROUP)
	(SG-STACK-POINTER STACK-GROUP)
	(SG-FRAME-POINTER STACK-GROUP)
	VALUE-DISPOSITION
	APPLY
	(+ N-ARGS 2))
    (DECLARE (IGNORE LP))
    ;; The following line causes stack wiring recalculation to be done for the new FP.
    (STORAGE::UNWIRE-CONTROL-STACK-PAGES STACK-GROUP)
    (SETF (SG-CONTROL-REGISTER STACK-GROUP) CONTROL)
    (SETF (SG-FRAME-POINTER STACK-GROUP) FP)
    (LET ((PC (SG-CONTINUATION STACK-GROUP)))
      (SETF (SG-CONTINUATION STACK-GROUP) (SG-NEXT-PC STACK-GROUP))
      (SETF (SG-NEXT-PC STACK-GROUP) PC)
      NIL)))

(DEFUN SG-CALL (STACK-GROUP VALUE-DISPOSITION APPLY FUNCTION &REST ARGS)
  (DECLARE (WIRED-FUNCTION))
  (SG-START-CALL STACK-GROUP FUNCTION)
  (LET ((N-ARGS 0))
    (DOLIST (ARG ARGS)
      (INCF N-ARGS)
      (SG-%PUSH STACK-GROUP ARG))
    (SG-FINISH-CALL STACK-GROUP VALUE-DISPOSITION APPLY N-ARGS)))

(DEFUN SG-INITIALIZE (STACK-GROUP)
  (DECLARE (WIRED-FUNCTION)
	   (VALUES FP)
	   (SAFEGUARDED-REFERENCE STORAGE::UNWIRE-CONTROL-STACK-PAGES))
  ;; Clean up the stack group
  (SETF (SG-PREVIOUS-STACK-GROUP STACK-GROUP) NIL)
  (SETF (SG-LOCK STACK-GROUP) NIL)
  (SETF (SG-DATA-STACK-POINTER STACK-GROUP) (SG-DATA-STACK-LOW STACK-GROUP))
  (LET ((OLD-STATUS (SG-STATUS-BITS STACK-GROUP)))
    (SETF (SG-STATUS-BITS STACK-GROUP)
	  (%LOGDPBS (LDB SG-SAFE OLD-STATUS) SG-SAFE
		    (LDB SG-UNINITIALIZED-BIT OLD-STATUS) SG-UNINITIALIZED-BIT
		    %SG-ARG-NONE SG-ARG-STATUS
		    0)))
  (SETF (SG-FLOAT-OPERATING-MODE STACK-GROUP) *DEFAULT-FLOAT-OPERATING-MODE*)
  (SETF (SG-FLOAT-OPERATION-STATUS STACK-GROUP) 0)
  (SETF (SG-ALU-ROTATE-AND-CONTROL STACK-GROUP) 0)
  (LET ((BOGUS-POINTER (%MAKE-POINTER DTP-LOCATIVE
			 (%LOGDPBS %BOUNDARY-ZONE %%VMA-ZONE-NUM -1 %%VMA-OBLAST-NUM 0))))
    (SETF (SG-BAR-1 STACK-GROUP) BOGUS-POINTER)
    (SETF (SG-BAR-2 STACK-GROUP) BOGUS-POINTER)
    (SETF (SG-BAR-3 STACK-GROUP) BOGUS-POINTER))
  ;; Make sure the FPA registers are reasonable
  (SETF (SG-FPA-0 STACK-GROUP) 0)
  (SETF (SG-FPA-1 STACK-GROUP)
	(%LOGDPBS
	  (LDB (BYTE 8. 24.)
	       (%LOGDPBS
		 (LDB %%FLOAT-TRAP-ENABLE-INEXACT-RESULT *DEFAULT-FLOAT-OPERATING-MODE*)
		 CLI::%%W3X64-INEXACT-RESULT-TRAP-ENABLE
		 (LDB %%FLOAT-TRAP-ENABLE-UNDERFLOW *DEFAULT-FLOAT-OPERATING-MODE*)
		 CLI::%%W3X64-UNDERFLOW-TRAP-ENABLE
		 (LDB %%FLOAT-TRAP-ENABLE-OVERFLOW *DEFAULT-FLOAT-OPERATING-MODE*)
		 CLI::%%W3X64-OVERFLOW-TRAP-ENABLE
		 1
		 CLI::%%W3X64-DENORMALIZED-INPUT-TRAP-ENABLE
		 (LDB %%FLOAT-TRAP-ENABLE-DIVISION-BY-ZERO
		      *DEFAULT-FLOAT-OPERATING-MODE*)
		 CLI::%%W3X64-DIVISION-BY-ZERO-TRAP-ENABLE
		 1
		 CLI::%%W3X64-INTEGER-OVERFLOW-TRAP-ENABLE
		 (LDB %%FLOAT-TRAP-ENABLE-INVALID-OPERATION
		      *DEFAULT-FLOAT-OPERATING-MODE*)
		 CLI::%%W3X64-INVALID-OPERATION-TRAP-ENABLE
		 0))
	  (BYTE 8 8)
	  (LDB (BYTE 8. 24.)
	       (%LOGDPBS (LDB %%FLOAT-ROUNDING-MODE *DEFAULT-FLOAT-OPERATING-MODE*)
			 CLI::%%W3X64-ROUNDING-MODE
			 1
			 CLI::%%W3X64-FPEX-STICKY 0))))
  (SETF (SG-FPA-2 STACK-GROUP) 0)
  (SETF (SG-FPA-3 STACK-GROUP) 0)
  (SETF (SG-FPA-4 STACK-GROUP) 0)
  (SETF (SG-CATCH-BLOCK-LIST STACK-GROUP) NIL)
  (SETF (SG-BINDING-STACK-POINTER STACK-GROUP)
	(%MAKE-POINTER-OFFSET DTP-LOCATIVE (SG-BINDING-STACK-LOW STACK-GROUP) 1))
  (SETF (SG-ROTATE-LATCH STACK-GROUP) 0)
  (%BLOCK-STORE-TAG-AND-POINTER (LOCF (SG-HARDWARE-STATUS-0 STACK-GROUP)) 16. DTP-NIL NIL 0)
  (SETF (SG-ERROR-TRAP-LEVEL STACK-GROUP) 0)
  (SETF (SG-WIRED-FRAME-DESCRIPTOR STACK-GROUP) 0)
  (LET* ((FP (SG-CONTROL-STACK-LOW STACK-GROUP))
	 (SP (%POINTER-PLUS FP 1)))
    ;; These values are bogus.
    (SETF (SG-CONTINUATION STACK-GROUP) NIL)
    (SETF (SG-NEXT-PC STACK-GROUP) NIL)
    (SETF (SG-CONTROL-REGISTER STACK-GROUP) (%LOGDPB 1 %%CR.TRAP-ON-EXIT-BIT 0))
    ;; Build the initial empty frame (in case the real frame returns somehow), with
    ;; bogus saved continuation and control registers.
    (%P-STORE-CDR-AND-CONTENTS FP NIL 3)
    (%P-STORE-CDR-AND-CONTENTS SP (%LOGDPB 1 %%CR.TRAP-ON-EXIT-BIT 0) 3)
    ;; The following lines cause stack wiring recalculation to be done for the new FP.
    (%SET-MIN-TRAP-MODE TRAP-MODE-EXTRA-STACK)
    (LET ((CURRENT-WIRED-LOW (SG-WIRED-CONTROL-STACK-LOW STACK-GROUP)))
      ;; What we really want to do here is ensure that bogus frame pointers don't
      ;; get recorded.  However, the common case will be that either the stack
      ;; is unwired, or it's wired starting at its beginning, and in both of those
      ;; cases no update to the stack-wiring information is necessary.
      ;;--- Meter if this is sufficient someday.
      (WHEN (AND CURRENT-WIRED-LOW
		 (NEQ (SG-CONTROL-STACK-LOW STACK-GROUP) CURRENT-WIRED-LOW))
	(STORAGE::UNWIRE-CONTROL-STACK-PAGES STACK-GROUP))
      (SETF (SG-FRAME-POINTER STACK-GROUP) FP)
      (SETF (SG-STACK-POINTER STACK-GROUP) SP)
      NIL)))

(DEFWIREDFUN STACK-GROUP-PRESETTER (FUNCTION &REST ARGS)
  (DECLARE (UNSAFEGUARDED-REFERENCE STACK-GROUP-EXHAUSTED))
  (MULTIPLE-VALUE-CALL #'STACK-GROUP-EXHAUSTED (APPLY FUNCTION ARGS)))

(DEFUN STACK-GROUP-PRESET (STACK-GROUP FUNCTION &REST ARGS)
  (DECLARE (WIRED-FUNCTION) ;Called by SYSTEM-STARTUP
	   (UNSAFEGUARDED-REFERENCE DBG:CHECK-ARG-1 STACK-GROUP))
  (CHECK-ARG-TYPE STACK-GROUP :STACK-GROUP)
  (SG-INITIALIZE STACK-GROUP)
  (CL:APPLY #'SG-CALL STACK-GROUP VALUE-DISPOSITION-EFFECT 0 #'STACK-GROUP-PRESETTER
	    FUNCTION ARGS)
  (SETF (SG-UNINITIALIZED-BIT STACK-GROUP) 0)
  (SETF (%LOGLDB %%CR.TRAP-ON-EXIT-BIT (SG-CONTROL-REGISTER STACK-GROUP)) 0))

;;; Places a call to FUNCTION with arguments ARGS on the stack group, which should
;;; not be the current stack group.  APPLY is 0 for a funcall, 1 for an APPLY.
;;; VALUE-DISPOSITION is a value-disposition number. 
(DEFUN PUT-CALL-ON-STACK-GROUP (STACK-GROUP VALUE-DISPOSITION APPLY FUNCTION &REST ARGS)
  (WHEN (EQ STACK-GROUP %CURRENT-STACK-GROUP)
    (FERROR "Attempt to place a call on the current stack group"))
  ;; The top of the stack group contains the saved control and continuation registers
  ;; for a call to %STACK-GROUP-SWITCH.  We need these values for START-CALL-VALUES.
  (CL:APPLY #'SG-CALL STACK-GROUP VALUE-DISPOSITION APPLY FUNCTION ARGS))

(DEFUN STACK-GROUP-RESUME (SG &REST VALUES)
  (DECLARE (DBG:ERROR-REPORTER))
  (CHECK-ARG-TYPE SG :STACK-GROUP)
  (%FUNCALL-IN-AUX-STACK #'%STACK-GROUP-SWITCH VALUES SG %SG-ARG-RESUME))

(DEFUN STACK-GROUP-RETURN (&REST VALUES)
  (LET ((CALLER (SG-PREVIOUS-STACK-GROUP %CURRENT-STACK-GROUP)))
    (IF (OR (NOT (TYPEP CALLER ':STACK-GROUP))
	    (AND (ZEROP (SG-SAFE %CURRENT-STACK-GROUP))
		 ( (SG-ARG-STATUS CALLER) %SG-ARG-CALL)))
	(FERROR NIL "Unsafe STACK-GROUP-RETURN"))
    (%FUNCALL-IN-AUX-STACK #'%STACK-GROUP-SWITCH VALUES CALLER %SG-ARG-RETURN)))

;; This gets called when the top function in a stack group returns
(DEFUN STACK-GROUP-EXHAUSTED (&REST VALUES)
  (LET ((CALLER (SG-PREVIOUS-STACK-GROUP %CURRENT-STACK-GROUP)))
    (IF (OR (NOT (TYPEP CALLER ':STACK-GROUP))
	    (AND (ZEROP (SG-SAFE %CURRENT-STACK-GROUP))
		 ( (SG-ARG-STATUS CALLER) %SG-ARG-CALL)))
	(FERROR NIL "Stack group exhausted and unsafe to STACK-GROUP-RETURN"))
    (%FUNCALL-IN-AUX-STACK #'%STACK-GROUP-SWITCH
			   VALUES CALLER (+ %SG-EXHAUSTED-BIT %SG-ARG-RETURN))))

;; Don't call this directly; it's an internal subroutine of CALL-FUNNY-FUNCTION
(DEFUN STACK-GROUP-CALL (SG &REST ARGS)
  (DECLARE (SAFEGUARDED-FUNCTION) ;Called by SI:STACK-OVERFLOW-TRAP-HANDLER
	   (UNSAFEGUARDED-REFERENCE FERROR))
  (OR (ZEROP (SG-SAFE %CURRENT-STACK-GROUP))
      (ZEROP (SG-SAFE SG))
      ( (SG-ARG-STATUS SG) %SG-ARG-CALL)
      (FERROR "Unsafe STACK-GROUP-CALL"))
  (SETF (SG-PREVIOUS-STACK-GROUP SG) %CURRENT-STACK-GROUP)
  (%FUNCALL-IN-AUX-STACK #'%STACK-GROUP-SWITCH ARGS SG %SG-ARG-CALL))

(DEFWIREDFUN %SET-CURRENT-STACK-GROUP-METER-ENABLE-FLAG (FLAG)
  (SI:%P-DPB (IF FLAG 1 0) %%CR.CALL-TRACE (CLI::%SAVED-CONTROL-REGISTER-ADDRESS))
  FLAG)

;; See if a function is currently active.  Used by TRACE :WHEREIN
(DEFUN FUNCTION-ACTIVE-P (FUNCTION)
  (SETQ FUNCTION (OR (VALID-FUNCTION-DEFINITION FUNCTION T) FUNCTION))
  (DBG:MAP-OVER-FRAMES-IN-STACK
    %CURRENT-STACK-GROUP
    #'(LAMBDA (FP IGNORE FRAME-FUNCTION)
	(WHEN (EQ FUNCTION FRAME-FUNCTION) (RETURN-FROM FUNCTION-ACTIVE-P FP)))))


;; System-wide stack group resource
(DEFRESOURCE STACK-GROUP (NAME)
  :CONSTRUCTOR (PROGN NAME (MAKE-STACK-GROUP 'SYSTEM-RESOURCE))
  :MATCHER (PROGN NAME OBJECT T)
  :INITIALIZER (SETF (SG-NAME OBJECT) NAME))


(DEFWIREDVAR *BUS-MODE* NIL)

;;; The Merlin VME bus interface hardware contains 4 pieces of per-process state: the
;;; direct access window, the direct access address modifier, the system controller
;;; release mode, and the system controller request level.  These values are contained
;;; within two byte fields in two separate registers.  Since many of the hardware
;;; registers are write-only, the current state of the hardware is always represented
;;; in (sg-hardware-status-0 %current-stack-group), and %stack-group-switch invokes this
;;; macro to update the hardware state after switching to the new stack group.
;;; We probably want to optimize this so that an additional state word is used more the
;;; hardware specific versions so there is less work at %stack-group-switch time.
(DEFMACRO UPDATE-MERLIN-VME-PROCESS-STATE (STATE)
  (ONCE-ONLY (STATE)
    `(PROGN
       (SETF *BUS-MODE* ,STATE)
       (SYSTEM-CASE
	 (MERLIN-I
	   (SETF (CLI::MERLIN-I-VME-DIRECT-AM-REGISTER) (LDB (BYTE 8. 4.) ,STATE))
	   (SETF (CLI::MERLIN-I-VME-SYSTEM-CONTROL-REGISTER) ,STATE))
	 (MERLIN-II
	   (SETF (CLI::MERLIN-II-VME-DIRECT-AM-REGISTER)
		 (%LOGDPB (CLI::AMOD-TO-VIC-FC-ASIZ
			    (LDB CLI::%%MERLIN-VME-OPTION-ADDRESS-MODIFIER ,STATE))
			  (BYTE 4 2)
			  (LDB CLI::%%MERLIN-VME-OPTION-WINDOW ,STATE)))
	   (SETF (CLI::VIC-ARBITER-REQUESTOR.BUS-REQUEST-LEVEL)
		 (LDB CLI::%%MERLIN-VME-OPTION-BUS-REQUEST-LEVEL ,STATE))
	   (SETF (CLI::VIC-RELEASE-CONTROL.RELEASE-MODE)
		 (LOGXOR (LDB CLI::%%MERLIN-VME-OPTION-ARBITRATION ,STATE) 1)))
	 (OTHERWISE NIL))
	    ,STATE)))


(DEFWIREDVAR %STACK-GROUP-LOCK NIL)

;;; Shamelessly bashes bars 2 and 3
(DEFWIREDFUN %SAVE-BINDINGS ()
  (LET ((POSITION (%POINTER-PLUS (%READ-INTERNAL-REGISTER %REGISTER-BINDING-STACK-POINTER) -1))
	(BINDING-STACK-LOW (SG-BINDING-STACK-LOW %CURRENT-STACK-GROUP)))
    (PREPARE-FOR-BLOCK-WRITE)
    (LOOP UNTIL (EQ BINDING-STACK-LOW POSITION) DOING
      (%WRITE-INTERNAL-REGISTER POSITION %REGISTER-BAR-2)
      (%WRITE-INTERNAL-REGISTER (%BLOCK-READ 2 :SET-CDR-NEXT T) %REGISTER-BAR-3)
      (%BLOCK-WRITE
	3
	(PROG1
	  (%BLOCK-READ 2 :CYCLE-TYPE %MEMORY-BIND-READ-NO-MONITOR
		       :NO-INCREMENT T :PREFETCH NIL :SET-CDR-NEXT NIL)
	  (%BLOCK-WRITE
	    2
	    (%MERGE-CDR-NO-POP
	      (%BLOCK-READ 3 :CYCLE-TYPE %MEMORY-BIND-READ-NO-MONITOR
			   :NO-INCREMENT T :PREFETCH NIL :SET-CDR-NEXT NIL)
	      (COMPILER:%STACK-LOCATION-INTERNAL 1)))))
      (SETQ POSITION (%POINTER-PLUS POSITION -2)))))

(DEFWIREDFUN %RESTORE-BINDINGS ()
  (LET ((LOW (%POINTER-PLUS (SG-BINDING-STACK-LOW %CURRENT-STACK-GROUP) 2)))
    (%WRITE-INTERNAL-REGISTER LOW %REGISTER-BAR-2)
    (PREPARE-FOR-BLOCK-WRITE)
    (LOOP REPEAT (LDB (BYTE 31. 1.)
		      (1+ (%POINTER-DIFFERENCE
			    (%READ-INTERNAL-REGISTER %REGISTER-BINDING-STACK-POINTER)
			    LOW)))
	  DOING
      (%WRITE-INTERNAL-REGISTER (%BLOCK-READ 2 :SET-CDR-NEXT T) %REGISTER-BAR-3)
      (%BLOCK-WRITE
	3
	(PROG1
	  (%BLOCK-READ 2 :CYCLE-TYPE %MEMORY-BIND-READ-NO-MONITOR
		       :NO-INCREMENT T :PREFETCH NIL :SET-CDR-NEXT NIL)
	  (%BLOCK-WRITE
	    2
	    (%MERGE-CDR-NO-POP
	      (%BLOCK-READ 3 :CYCLE-TYPE %MEMORY-BIND-READ-NO-MONITOR
			   :NO-INCREMENT T :PREFETCH NIL :SET-CDR-NEXT NIL)
	      (COMPILER:%STACK-LOCATION-INTERNAL 1))))))))

;(DEFUN VALIDATE-CATCH-BLOCK-LIST
;       (&OPTIONAL (FIRST-CB (%READ-INTERNAL-REGISTER %REGISTER-CATCH-BLOCK-LIST)))
;  (LOOP WITH CONTROL-LOW = (SG-CONTROL-STACK-LOW %CURRENT-STACK-GROUP)
;	FOR TOP FIRST (%STACK-FRAME-POINTER) THEN CB
;	FOR CB FIRST FIRST-CB THEN (CATCH-BLOCK-PREVIOUS CB)
;	DOING
;    (WHEN (NULL CB) (RETURN))
;    (UNLESS (AND (TYPEP CB :LOCATIVE)
;		 (%POINTER-LESSP CONTROL-LOW CB)
;		 (%POINTER-LESSP CB TOP))
;      (HALT)))
;  FIRST-CB)

(DEFWIREDFUN %STACK-GROUP-SWITCH (VALUES STACK-GROUP SG-STATUS-BITS)
  (DECLARE (SAFEGUARDED-REFERENCE STORAGE::NOTE-STACK-GROUP-SWITCH
				  SET-FLOAT-OPERATING-MODE
				  SET-FLOAT-OPERATION-STATUS)
	   (UNSAFEGUARDED-REFERENCE STORAGE::VERIFY-WIRING-FOR-STACK-GROUP-SWITCH
				    %ASSURE-PDL-ROOM))
  (COMPILER:%ERROR-UNLESS (= (%TRAP-MODE) TRAP-MODE-EXTRA-STACK)
    (WIRED-FERROR :PROCEEDABLE-HALT "Stack group switch while not in extra-stack mode"))
  (COMPILER:%ERROR-UNLESS (ZEROP (SG-NONRESUMABILITY STACK-GROUP))
    (WIRED-FERROR :PROCEEDABLE-HALT "~s is not resumable" STACK-GROUP))
  ;; This is not fatal; it simply means someone is munging the stack group
  (COMPILER:%ERROR-UNLESS (STORE-CONDITIONAL (LOCF (SG-LOCK STACK-GROUP)) NIL T)
    (WIRED-FERROR :PROCEEDABLE-HALT "Stack group's lock is held"))
  (COMPILER:%ERROR-UNLESS (STORE-CONDITIONAL (LOCF %STACK-GROUP-LOCK) NIL %CURRENT-STACK-GROUP)
    (WIRED-FERROR :PROCEEDABLE-HALT "Stack group lock is held"))
  (STORAGE::VERIFY-WIRING-FOR-STACK-GROUP-SWITCH (%STACK-FRAME-POINTER))
  (SETF (%LOGLDB SG-STACK-LOAD-STARTED %CURRENT-STACK-GROUP-STATUS-BITS) 1)
  ;; Get the rest of the internal registers
  ;; If we made clever use of PROG1 here, we could save the pop at the end of this if
  ;; we wanted to
  (LET* ((CURRENT-STACK-GROUP %CURRENT-STACK-GROUP)
	 (BAR-3 (%READ-INTERNAL-REGISTER %REGISTER-BAR-3))
	 (BAR-2 (%READ-INTERNAL-REGISTER %REGISTER-BAR-2))
	 (BAR-1 (%READ-INTERNAL-REGISTER %REGISTER-BAR-1))
	 (FLOAT-MODE FLOAT-OPERATING-MODE)
	 (FLOAT-STATUS FLOAT-OPERATION-STATUS)
	 (SHUFFLE
	   (SYSTEM-CASE
	     (MacIvory (READ-MACIVORY-HARDWARE-BIT-SHUFFLING-MODE))
	     (Merlin (SYS:%SET-TAG SYS:*BUS-MODE* SYS:DTP-SMALL-RATIO))
	     (OTHERWISE (SG-HARDWARE-STATUS-0 %CURRENT-STACK-GROUP)))))
    (WHEN CURRENT-STACK-GROUP
      (%SAVE-BINDINGS)
      (%WRITE-INTERNAL-REGISTER (LOCF (SG-STACK-POINTER CURRENT-STACK-GROUP)) %REGISTER-BAR-1)
      ;; Save the state (assume that if the stack limits, etc. had been
      ;; changed, the changer would have changed the stack group for us
      ;; as well.  This saves us the trouble of saving them on every
      ;; stack group switch even though they rarely change.  However, we
      ;; do need to restore them).
      (PREPARE-FOR-BLOCK-WRITE)
      (%BLOCK-WRITE 1 (%POINTER-PLUS (%STACK-FRAME-POINTER) -1))
      (%BLOCK-WRITE
	1
	(%POINTER-PLUS (%STACK-FRAME-POINTER)
		       (- (LDB %%CR.CALLER-FRAME-SIZE
			       (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER)))))
      (%BLOCK-WRITE 1 (%READ-INTERNAL-REGISTER %REGISTER-CONTINUATION))
      (%BLOCK-WRITE 1 (CLI::%SAVED-CONTINUATION-REGISTER))
      (%BLOCK-WRITE 1 (CLI::%SAVED-CONTROL-REGISTER))
      (%BLOCK-WRITE 1 (%LOGDPBS 0 SG-ACTIVE-BIT
				SG-STATUS-BITS (BYTE 5 0)
				%CURRENT-STACK-GROUP-STATUS-BITS))
      (%BLOCK-WRITE 1 (%READ-INTERNAL-REGISTER %REGISTER-CATCH-BLOCK-LIST))
      (COND ((CLI::FP-COPROCESSOR-ENABLED-P)
	     (LOOP DOING
	       ;; Wait for the FPA to finish what it is doing.
	       (LET ((SR11 (%COPROCESSOR-READ (+ CLI::%FPA-STATUS-REGISTER-BASE-ADDRESS 11.))))
		 (UNLESS (OR (NOT (TYPE-MEMBER SR11 DTP-FIXNUM DTP-SINGLE-FLOAT))
			     (LDB-TEST CLI::%%W3X64-DIVIDE-SQUARE-ROOT-IN-PROGRESS
				       (SETQ SR11 (%FIXNUM SR11))))
		   ;; DIVIDE/SQUARE-ROOT complete (if one were started).  Anything
		   ;; else will completed long before we got here
		   (%BLOCK-WRITE 1 SR11)
		   (%BLOCK-WRITE
		     1
		     (LOGIOR
		       (LDB (BYTE 8. 24.) (CLI::%FPA-STATUS-REGISTER 0))
		       (ROT (LDB (BYTE 8. 24.) (CLI::%FPA-STATUS-REGISTER 2)) 8.)
		       (ROT (LDB (BYTE 8. 24.) (CLI::%FPA-STATUS-REGISTER 3)) 16.)
		       (ROT (LDB (BYTE 8. 24.) (CLI::%FPA-STATUS-REGISTER 6.)) 24.)))
		   (%BLOCK-WRITE 1 (CLI::%FPA-R0-HIGH))
		   (%BLOCK-WRITE 1 (CLI::%FPA-R0-LOW))
		   ;; Also need to save R1-Low.
		   (%BLOCK-WRITE 1 (%COPROCESSOR-READ 1))
		   (RETURN)))))
	     (T
	      ;; Skip over FLOAT, SG-BINDING-STACK-LIMIT and SG-CONTROL-STACK-LOW
	      ;; Also need to skip R1-LOW
	      (SETF (%BLOCK-REGISTER 1) (%POINTER-PLUS (%BLOCK-REGISTER 1) 5))
	      ))
      (%BLOCK-WRITE 1 FLOAT-MODE)
      (%BLOCK-WRITE 1 FLOAT-STATUS)
      (%BLOCK-WRITE 1 (%READ-INTERNAL-REGISTER %REGISTER-ALU-AND-ROTATE-CONTROL))
      (%BLOCK-WRITE 1 (%ROTATE-LATCH))
      (%BLOCK-WRITE 1 BAR-1)
      (%BLOCK-WRITE 1 BAR-2)
      (%BLOCK-WRITE 1 BAR-3)
      (%BLOCK-WRITE 1 (%READ-INTERNAL-REGISTER %REGISTER-BINDING-STACK-POINTER))
      ;; Skip over SG-BINDING-STACK-LIMIT and SG-CONTROL-STACK-LOW
      (SETF (%BLOCK-REGISTER 1) (%POINTER-PLUS (%BLOCK-REGISTER 1) 2))
      ;; Save hardware-dependent state.
      (%BLOCK-WRITE 1 SHUFFLE)
      (SETF (SG-LOCK CURRENT-STACK-GROUP) NIL))
    ;; This has to be called after saving the above registers, since it trashes them.
    (STORAGE::NOTE-STACK-GROUP-SWITCH STACK-GROUP)
    (WHEN (= SG-STATUS-BITS %SG-ARG-CALL)
      (SETF (SG-PREVIOUS-STACK-GROUP STACK-GROUP) CURRENT-STACK-GROUP)))
  ;; Dump the stack cache below the %STACK-GROUP-SWITCH frame.  Do this after the
  ;; above function calls so that the microcode has a chance to do it for us.
  #-VLM
  (LET ((STACK-CACHE-LOWER-BOUND
	  (%READ-INTERNAL-REGISTER %REGISTER-STACK-CACHE-LOWER-BOUND)))
    (%WRITE-INTERNAL-REGISTER STACK-CACHE-LOWER-BOUND %REGISTER-BAR-2)
    (%WRITE-INTERNAL-REGISTER STACK-CACHE-LOWER-BOUND %REGISTER-BAR-3)
    (PREPARE-FOR-BLOCK-WRITE)
    (UNROLL-BLOCK-FORMS ((%POINTER-DIFFERENCE (%STACK-FRAME-POINTER)
					      STACK-CACHE-LOWER-BOUND)
			 8.)
      (%BLOCK-WRITE 2 (%BLOCK-READ 3 :CYCLE-TYPE %MEMORY-RAW :SET-CDR-NEXT NIL))))

  ;; Stick VALUES in the catch block list register
  (SETF (%READ-INTERNAL-REGISTER %REGISTER-CATCH-BLOCK-LIST) VALUES)
  ;; Change %CURRENT-STACK-GROUP now, while we still know what it is
  (SETQ %CURRENT-STACK-GROUP STACK-GROUP)
  ;; BAR-1 will be used to build the new stack frame
  (%WRITE-INTERNAL-REGISTER (LOCF (SG-WIRED-CONTROL-STACK-LIMIT STACK-GROUP)) %REGISTER-BAR-1)
  (LET* ((LIMIT (%BLOCK-READ 1))
	 (SP (%BLOCK-READ 1))
	 (FP (%BLOCK-READ 1 :PREFETCH NIL)))
    (%WRITE-INTERNAL-REGISTER (%BLOCK-READ 1 :PREFETCH NIL)
			      %REGISTER-CONTINUATION)

    ;; Set the frame size and trap mode.  It will not be safe to take a
    ;; trap after the overflow limit has been changed below.  Actually, we can still
    ;; take an interrupt for one more cycle, due to pipelining.  However, the next
    ;; cycle is spent pushing LIMIT, so this is okay.
    (%WRITE-INTERNAL-REGISTER
      (%LOGDPB (1+ (%POINTER-DIFFERENCE SP FP)) %%CR.CALLER-FRAME-SIZE
	       (%LOGDPB TRAP-MODE-IO %%CR.TRAP-MODE
			(%LOGDPB VALUE-DISPOSITION-RETURN %%CR.VALUE-DISPOSITION 0)))
      %REGISTER-CONTROL-REGISTER)

    (%WRITE-INTERNAL-REGISTER (%POINTER-PLUS LIMIT (- (+ CONTROL-STACK-MAX-FRAME-SIZE
							 CONTROL-STACK-OVERFLOW-MARGIN)))
			      %REGISTER-CONTROL-STACK-LIMIT)
    (%WRITE-INTERNAL-REGISTER LIMIT %REGISTER-CONTROL-STACK-EXTRA-LIMIT)

    #-VLM
    (PROGN
      ;; Choose a stack-cache-overflow-limit that will not cause an overflow with
      ;; either the old or the new stack pointer.  The stack cache overflow check
      ;; is (= D.SP<6:2> stack-cache-overflow-limit).
      (%WRITE-INTERNAL-REGISTER
	;; This gives a margin of at least 28 words from the old and new SPs.
	(%POINTER-PLUS
	  (IF (LDB-TEST (BYTE 1. 6.)
			(%POINTER-DIFFERENCE (COMPILER:%STACK-LOCATION-INTERNAL 0) SP))
	      SP
	      (COMPILER:%STACK-LOCATION-INTERNAL 0))
	  32.)
	%REGISTER-STACK-CACHE-OVERFLOW-LIMIT)
      (%WRITE-INTERNAL-REGISTER (%POINTER-PLUS SP 1) %REGISTER-FP)
      (COMPILER:NO-OP)
      (COMPILER::%INSTRUCTION SET-SP-TO-ADDRESS (FP 1))
      (COMPILER:%PUSH-N -4.)
      ;; Map the stack cache to the new frame
      (%WRITE-INTERNAL-REGISTER (%STACK-FRAME-POINTER) %REGISTER-STACK-CACHE-LOWER-BOUND)
      (%WRITE-INTERNAL-REGISTER
	(%POINTER-PLUS (%STACK-FRAME-POINTER) CONTROL-STACK-MAX-FRAME-SIZE)
	%REGISTER-STACK-CACHE-OVERFLOW-LIMIT))

    #+VLM
    (PROGN
      (COMPILER:NO-OP)
      (%COPROCESSOR-WRITE (%POINTER-PLUS SP 1) SYS:%COPROCESSOR-REGISTER-STACK-SWITCH)
      (COMPILER:%PUSH-N -4.))

    ;; It's now safe to take traps
    (SETF (%LOGLDB %%CR.TRAP-MODE (%READ-INTERNAL-REGISTER %REGISTER-CONTROL-REGISTER))
	  TRAP-MODE-EXTRA-STACK)
    (SET-ALU-AND-ROTATE-CONTROL
      :BYTE-R 0.
      :BYTE-S 0.
      :FUNCTION-CLASS %ALU-FUNCTION-CLASS-BYTE
      :FUNCTION-BITS #B0100)
    (COMPILER:%INSTRUCTION %BLOCK-1-READ 0)
    (COMPILER:%INSTRUCTION %BLOCK-1-READ 0)
    (COMPILER:%PUSH-N -2)
    (COMPILER::%INSTRUCTION POP (FP 1))
    (COMPILER::%INSTRUCTION POP (FP 0))
    (LET ((VALUES (%READ-INTERNAL-REGISTER %REGISTER-CATCH-BLOCK-LIST))
	  (STATUS-BITS (%BLOCK-READ 1)))
      (%WRITE-INTERNAL-REGISTER
	(PROG1
	  ;; Catch block list
	  (%BLOCK-READ 1)
	  (LET ((FPA0 (%BLOCK-READ 1))
		(FPA1 (%BLOCK-READ 1))
		(FPA2 (%BLOCK-READ 1))
		(FPA3 (%BLOCK-READ 1))
		(FPA4 (%BLOCK-READ 1))
		)
	    (DECLARE (FUTURE-COMMON-LISP:IGNORABLE FPA0 FPA1 FPA2 FPA3 FPA4))
	    (SETF
	      FLOAT-OPERATING-MODE
	      (PROG1
		;; FLOAT-OPERATING-MODE
		(%BLOCK-READ 1)
		(SETF
		  FLOAT-OPERATION-STATUS
		  (PROG1
		    ;; FLOAT-OPERATION-STATUS
		    (%BLOCK-READ 1)
		    (%WRITE-INTERNAL-REGISTER
		      (PROG1
			;; ALU rotate and control
			(%BLOCK-READ 1)
			;; The DP-OP is set up to load the rotate latch
			(%BLOCK-READ-SHIFT 1)
			(%WRITE-INTERNAL-REGISTER
			  (PROG1
			    ;; BAR-1
			    (%BLOCK-READ 1)
			    (%WRITE-INTERNAL-REGISTER
			      (PROG1
				;; BAR-2
				(%BLOCK-READ 1)
				(%WRITE-INTERNAL-REGISTER
				  (PROG1
				    ;; BAR-3
				    (%BLOCK-READ 1)
				    (%WRITE-INTERNAL-REGISTER
				      (PROG1
					;; Binding-stack-pointer
					(%BLOCK-READ 1)
					(%WRITE-INTERNAL-REGISTER
					  (PROG1
					    ;; Binding stack limit
					    (%BLOCK-READ 1)
					    (SETQ %CONTROL-STACK-LOW
						  (PROG1
						    (%BLOCK-READ 1 :PREFETCH NIL)
						    ;; Restore any hardware dependent state
						    (LET ((SHUFFLE
							    (%BLOCK-READ 1 :PREFETCH NIL)))
						      (DECLARE (FUTURE-COMMON-LISP:IGNORABLE
								 SHUFFLE))
						      (MACROLET
							((RESTORE-MACIVORY-SHUFFLE-MODE ()
							   `(SELECT SHUFFLE
							      (%FIXNUM-SHUFFLING-MODE
							       (WRITE-MACIVORY-REGISTER #O14 0)
							       )
							      (%BYTE-SHUFFLING-MODE
							       (WRITE-MACIVORY-REGISTER #O15 0)
							       )
							      (%NIBBLE-SHUFFLING-MODE
							       (WRITE-MACIVORY-REGISTER #O16 0)
							       )
							      (%BIT-SHUFFLING-MODE
							       (WRITE-MACIVORY-REGISTER #O17 0)
							       ))))
							;; Duplicate clauses for MacIvory will
							;; avoid double dispatches at runtime.
							(SYSTEM-CASE
							  (MacIvory-1&2
							    (RESTORE-MACIVORY-SHUFFLE-MODE))
							  (MacIvory-3
							    (RESTORE-MACIVORY-SHUFFLE-MODE))
							  (Merlin
							    (IF
							      (TYPE-MEMBER SHUFFLE
									   SYS:DTP-SMALL-RATIO)
							      (UPDATE-MERLIN-VME-PROCESS-STATE
								(%SET-TAG SHUFFLE
									  SYS:DTP-FIXNUM))
							      (UPDATE-MERLIN-VME-PROCESS-STATE
								CLI::%MERLIN-DEFAULT-BUS-STATE)
							      ))
							  (OTHERWISE NIL)))))))
					  %REGISTER-BINDING-STACK-LIMIT))
				      %REGISTER-BINDING-STACK-POINTER)
				    (%RESTORE-BINDINGS))
				  %REGISTER-BAR-3))
			      %REGISTER-BAR-2))
			  %REGISTER-BAR-1))
		      %REGISTER-ALU-AND-ROTATE-CONTROL)))))
	    (WHEN (CLI::FP-COPROCESSOR-ENABLED-P)
	      (SETF (CLI::%FPA-STATUS-REGISTER 0) (ROT (LDB (BYTE 8. 0.) FPA1) 24.))
	      (SETF (CLI::%FPA-STATUS-REGISTER 2) (ROT (LDB (BYTE 8. 8.) FPA1) 24.))
	      (SETF (CLI::%FPA-STATUS-REGISTER 3) (ROT (LDB (BYTE 8. 16.) FPA1) 24.))
	      (SETF (CLI::%FPA-STATUS-REGISTER 6.) FPA1)
	      (SETF (CLI::%FPA-STATUS-REGISTER 11.) FPA0)
	      (SETF (CLI::%FPA-R0-HIGH) FPA2)
	      (SETF (CLI::%FPA-R0-LOW) FPA3)
	      (%COPROCESSOR-WRITE FPA4 3)
	      )))
	  %REGISTER-CATCH-BLOCK-LIST)
      ;; Now we're done
      (SETQ %CURRENT-STACK-GROUP-STATUS-BITS
	    (%LOGDPBS 0 SG-STACK-LOAD-STARTED
		      1 SG-ACTIVE-BIT
		      STATUS-BITS))
      (SETF (SG-STATUS-BITS %CURRENT-STACK-GROUP) %CURRENT-STACK-GROUP-STATUS-BITS)
      (SETF %STACK-GROUP-LOCK NIL)
      (SELECT (LDB SG-ARG-STATUS STATUS-BITS)
	((%SG-ARG-NONE %SG-ARG-BREAK)
	 (RETURN-KLUDGE (VALUES)))
	((%SG-ARG-RESUME %SG-ARG-CALL %SG-ARG-RETURN)
	 (%VALUES-LIST VALUES))))))

(DEFUN SG-STRUCTURE-STACK-POINTER (STACK-GROUP)
  (IF ( (SG-STRUCTURE-STACK-POINTER-COUNT STACK-GROUP) 0)
      (SG-STRUCTURE-STACK-POINTER-HAVEN STACK-GROUP)
    (IF (EQ STACK-GROUP %CURRENT-STACK-GROUP)
	(%READ-INTERNAL-REGISTER %REGISTER-BAR-3)
      (SG-BAR-3 STACK-GROUP))))

;; Stack overflows.  This has to be in the cold load for SG-WIRED-OVERFLOW.

;; Called by microcode escape when control stack is nearly full.  Escape
;; to another stack group to do the work, with scheduling inhibited
;; until it has been completed.  Use STACK-GROUP-CALL rather than
;; FUNCALL to avoid the extra consumption of stack space required for
;; type-checking in CALL-FUNNY-FUNCTION.  After we have usable stacks,
;; signal a condition, which normally will enter the debugger.  This
;; does not get called for data-stack overflows, SI:GROW-DATA-STACK
;; handles that
(DEF-TRAP-HANDLER STACK-OVERFLOW-TRAP-HANDLER
		  (%STACK-OVERFLOW-TRAP-VECTOR TRAP-MODE-EXTRA-STACK)
		  (TRAP-VECTOR-INDEX FAULT-PC)
  (DECLARE (UNSAFEGUARDED-REFERENCE SIGNAL PDL-OVERFLOW :PDL-NAME
				    DBG:RELOCATE-EXIT-TRAP-FRAME-ACTIONS
				    DBG:RELOCATE-CALL-TRACE-HANDLERS
				    METERING:RELOCATE-METERING-STACK-POINTERS
				    DBG:CONTROL-STACK-GROWN)
	   (SAFEGUARDED-REFERENCE STORAGE::UNWIRE-CONTROL-STACK-PAGES)
	   (IGNORE TRAP-VECTOR-INDEX FAULT-PC)
	   (DBG:ERROR-REPORTER))
  (SAVING-REGISTERS-FOR-TRAP-FOR-EFFECT
    (LET* ((SG %CURRENT-STACK-GROUP)
	   (WIRED-LIMIT (SG-WIRED-CONTROL-STACK-LIMIT SG))
	   (LIMIT (%POINTER-PLUS (SG-CONTROL-STACK-LIMIT SG)
				 (+ CONTROL-STACK-MAX-FRAME-SIZE
				    CONTROL-STACK-OVERFLOW-MARGIN))))
      (IF (%POINTER-LESSP WIRED-LIMIT LIMIT)
	  ;; The common case.  We need to remain safeguarded in this path, since we
	  ;; may not have enought stack space left to take a transport trap.
	  ;; (Actually, I'm not sure; I'm just being safe.)
	  (STORAGE::SG-WIRED-OVERFLOW SG WIRED-LIMIT)
	  ;; A real stack overflow.  Grow the stack.
	  (LET ((OLD-PREEMPTION-ENABLED *PREEMPTION-ENABLED*))
	    (SETF *PREEMPTION-ENABLED* NIL)
	    (SI:STACK-GROUP-CALL DBG:STACK-GROWER :CONTROL DBG:PDL-GROW-RATIO)
	    (STORAGE::UNWIRE-CONTROL-STACK-PAGES DBG:STACK-GROWER)
	    (%SET-TRAP-MODE TRAP-MODE-EMULATOR)
	    (DBG:RELOCATE-EXIT-TRAP-FRAME-ACTIONS)
	    (DBG:RELOCATE-CALL-TRACE-HANDLERS)
	    (METERING:RELOCATE-METERING-STACK-POINTERS)
	    (WHEN OLD-PREEMPTION-ENABLED
	      (PROCESS::PREEMPTION-BEING-REENABLED))
	    (SIGNAL 'DBG:CONTROL-STACK-GROWN)
	    (LET* ((ABSOLUTE-LIMIT (SG-ABSOLUTE-CONTROL-STACK-LIMIT SG))
		   (NEW-SIZE (%POINTER-DIFFERENCE LIMIT (SG-CONTROL-STACK-LOW SG))))
	      (WHEN (OR (NULL ABSOLUTE-LIMIT)
			(> NEW-SIZE ABSOLUTE-LIMIT))
		;; Don't enter the Debugger if we haven't exceeded the absolute limit
		(SIGNAL 'PDL-OVERFLOW :PDL-NAME "control")))))))
  (VALUES))

;;;; Support for bit shuffling hardware

;;; Generate a form which converts an acceptable physical address into a new physical address
;;; which will invoke MacIvory's bit shuffling hardware.
(DEFMACRO MAKE-MACIVORY-HARDWARE-BIT-SHUFFLING-ADDRESS (ADDRESS &KEY DONT-VALIDATE-ADDRESS)
  `(SYSTEM-CASE
     (MacIvory-1&2
       ,@(UNLESS DONT-VALIDATE-ADDRESS
	   `((CL:CHECK-TYPE ,ADDRESS (DATA-TYPE DTP-PHYSICAL-ADDRESS))
	     (CL:ASSERT (= (LDB (BYTE 2 30.) (%POINTER ,ADDRESS)) 1) ()
			"The address supplied, ~S, is not a NuBus direct access address"
			,ADDRESS)))
       (%MAKE-PHYSICAL-ADDRESS (%LOGDPB 3 (BYTE 2 30.) (%POINTER ,ADDRESS))))
     (MacIvory-3
       ,@(UNLESS DONT-VALIDATE-ADDRESS
	   `((CL:CHECK-TYPE ,ADDRESS (DATA-TYPE DTP-PHYSICAL-ADDRESS))
	     (CL:ASSERT (OR (ZEROP (LDB (BYTE 3 29.) (%POINTER ,ADDRESS)))
			    (= (LDB (BYTE 2 30.) (%POINTER ,ADDRESS)) 1))
			()
			"The address supplied, ~S, is neither a 40-bit local memory address ~
		         nor a NuBus direct access address"
			,ADDRESS)))
       (IF (ZEROP (LDB (BYTE 3 29.) (%POINTER ,ADDRESS)))
	   (%MAKE-PHYSICAL-ADDRESS (%LOGDPB 1 (BYTE 1 29.) (%POINTER ,ADDRESS)))
	   (%MAKE-PHYSICAL-ADDRESS (%LOGDPB 3 (BYTE 2 30.) (%POINTER ,ADDRESS)))))
     (OTHERWISE NIL)))

;;; The hardware register is write-only, so we need this kludge to figure out what's in it
;;; We read a location that is known to contain the constant characters 'EMBD'
(DEFWIREDFUN READ-MACIVORY-HARDWARE-BIT-SHUFFLING-MODE ()
  (DECLARE (UNSAFEGUARDED-REFERENCE DBG:CHECK-TYPE-1 CLI::ASSERTION-FAILED
				    DATA-TYPE DTP-PHYSICAL-ADDRESS))
  (CL:CASE (%P-LDB (BYTE 6 24.)
		   (MAKE-MACIVORY-HARDWARE-BIT-SHUFFLING-ADDRESS *EMB-COMMUNICATION-AREA*
								 :DONT-VALIDATE-ADDRESS T))
    (#o04 (SYSTEM-CASE
	    (MacIvory-3 %FIXNUM-SHUFFLING-MODE)
	    (OTHERWISE NIL)))
    (#o05 %BYTE-SHUFFLING-MODE)
    (#o24 %NIBBLE-SHUFFLING-MODE)
    (#o42 %BIT-SHUFFLING-MODE)))

;;; Deliberately does not error if mode is not recognized -- stack groups
;;; might contain stale information after saving on one system and booting on another
(DEFWIREDFUN RESTORE-HARDWARE-BIT-SHUFFLING-MODE (MODE)
  (MACROLET ((DOIT ()
	       '(SELECT MODE
		  (%FIXNUM-SHUFFLING-MODE (WRITE-MACIVORY-REGISTER #O14 0))
		  (%BYTE-SHUFFLING-MODE (WRITE-MACIVORY-REGISTER #O15 0))
		  (%NIBBLE-SHUFFLING-MODE (WRITE-MACIVORY-REGISTER #O16 0))
		  (%BIT-SHUFFLING-MODE (WRITE-MACIVORY-REGISTER #O17 0)))))
    ;; Duplicate clauses will avoid double dispatches at runtime.
    (SYSTEM-CASE
      (MacIvory-1&2 (DOIT))
      (MacIvory-3 (DOIT))
      (OTHERWISE NIL))))

(DEFWIREDFUN SET-HARDWARE-BIT-SHUFFLING-MODE (ADDRESS MODE OLD-MODE-LOC)
  (DECLARE (UNSAFEGUARDED-REFERENCE DBG:CHECK-TYPE-1 CLI::ASSERTION-FAILED
				    ADDRESS DATA-TYPE DTP-PHYSICAL-ADDRESS))
  (MACROLET
    ((SET-MACIVORY-SHUFFLE-MODE ()
       '(LET ((SHUFFLED-ADDRESS (MAKE-MACIVORY-HARDWARE-BIT-SHUFFLING-ADDRESS ADDRESS)))
	  ;; Sense the current mode without touching the stack group, which may not be wired
	  (SETF (LOCATION-CONTENTS OLD-MODE-LOC) (READ-MACIVORY-HARDWARE-BIT-SHUFFLING-MODE))
	  ;; Select the new mode with a combination of high-order address bits and a register
	  (SELECT MODE
	    (%BYTE-SHUFFLING-MODE
	     (WRITE-MACIVORY-REGISTER #O15 0)
	     SHUFFLED-ADDRESS)
	    (%NIBBLE-SHUFFLING-MODE
	     (WRITE-MACIVORY-REGISTER #O16 0)
	     SHUFFLED-ADDRESS)
	    (%BIT-SHUFFLING-MODE
	     (WRITE-MACIVORY-REGISTER #O17 0)
	     SHUFFLED-ADDRESS)
	    (%FIXNUM-SHUFFLING-MODE
	     (SYSTEM-CASE
	       (MacIvory-1&2
		 ;; Access the NuBus directly without shuffling hardware.
		 ADDRESS)
	       (MacIvory-3
		 ;; Must use no-shuffle mode in case the original address was in local memory.
		 (WRITE-MACIVORY-REGISTER #O14 0)
		 SHUFFLED-ADDRESS)
	       (OTHERWISE NIL)))
	    (%SINGLE-FLOAT-SHUFFLING-MODE
	     (SYSTEM-CASE
	       (MacIvory-1&2
		 (%MAKE-PHYSICAL-ADDRESS (%LOGDPB 2 (BYTE 2 30.) (%POINTER ADDRESS))))
	       (MacIvory-3
		 (WIRED-FERROR NIL
		   "This hardware bit shuffling mode is not implemented by MacIvory model 3"))
	       (OTHERWISE NIL)))
	    (OTHERWISE
	     (WIRED-FERROR NIL
			   "This hardware bit shuffling mode is not implemented by MacIvory")))
	  )))
    ;; Duplicate clauses for MacIvory will avoid double dispatches at runtime.
    (SYSTEM-CASE
      (MacIvory-1&2
	(SET-MACIVORY-SHUFFLE-MODE))
      (MacIvory-3
	(SET-MACIVORY-SHUFFLE-MODE))
      (Merlin
	;; Make sure the caller-supplied address is connected to the right hardware
	(CL:CHECK-TYPE ADDRESS (DATA-TYPE DTP-PHYSICAL-ADDRESS))
	(CL:ASSERT (= (LDB (BYTE 4 28.) (%POINTER ADDRESS)) #b1000) ()
		   "The address supplied, ~S, is not a VMEBus direct access address" ADDRESS)
	;; Select the new mode
	(SELECT MODE
	  (%BYTE-SHUFFLING-MODE
	   (%MAKE-PHYSICAL-ADDRESS
	     (%LOGDPB CLI::%%VME-SHUFFLE-BYTES CLI::%%MERLIN-VME-OPTION-SHUFFLE
		      (%POINTER ADDRESS))))
	  (%NIBBLE-SHUFFLING-MODE
	   (%MAKE-PHYSICAL-ADDRESS
	     (%LOGDPB CLI::%%VME-SHUFFLE-NIBBLES CLI::%%MERLIN-VME-OPTION-SHUFFLE
		      (%POINTER ADDRESS))))
	  (%BIT-SHUFFLING-MODE
	   (%MAKE-PHYSICAL-ADDRESS
	     (%LOGDPB CLI::%%VME-SHUFFLE-BITS CLI::%%MERLIN-VME-OPTION-SHUFFLE
		      (%POINTER ADDRESS))))
	  (%FIXNUM-SHUFFLING-MODE
	   ADDRESS)
	  (%SINGLE-FLOAT-SHUFFLING-MODE
	   (SYSTEM-CASE
	     (MERLIN-I
	       (%MAKE-PHYSICAL-ADDRESS
		 (%LOGDPB CLI::%%VME-DATA-TYPE-FLONUM CLI::%%MERLIN-I-VME-OPTION-DATA-TYPE
			  (%POINTER ADDRESS))))
	     (MERLIN-II
	       (WIRED-FERROR NIL "Single Float shuffling is not implemented on this platform"))
	     (OTHERWISE NIL)))
	  (OTHERWISE
	   (WIRED-FERROR
	     NIL "This hardware bit shuffling mode is not implemented by XL400s/UX400s"))))
      ;; On other systems bit shuffling is a no-op because all the hardware in the
      ;; system uses compatible data formats
      (OTHERWISE ADDRESS))))

(DEFUN RESTORE-HARDWARE-BIT-SHUFFLING-ADDRESS (ADDRESS)
  (SYSTEM-CASE
    (MacIvory-1&2
      ;; Change it back to a Nubus direct access address
      (%MAKE-PHYSICAL-ADDRESS (%LOGDPB 1 (BYTE 2 30.) (%POINTER ADDRESS))))
    (MacIvory-3
      (IF (ZEROP (LDB (BYTE 2 30.) (%POINTER ADDRESS)))
	  ;; Change it back to a 40-bit local memory address
	  (%MAKE-PHYSICAL-ADDRESS (%LOGDPB 0 (BYTE 1 29.) (%POINTER ADDRESS)))
	  ;; Change it back to a Nubus direct access address
	  (%MAKE-PHYSICAL-ADDRESS (%LOGDPB 1 (BYTE 2 30.) (%POINTER ADDRESS)))))
    (Merlin-I
      ;; Change it back to a VMEbus direct access address
      (%MAKE-PHYSICAL-ADDRESS
	(%LOGDPBS CLI::%%VME-SHUFFLE-NONE CLI::%%MERLIN-VME-OPTION-SHUFFLE
		  CLI::%%VME-DATA-TYPE-FIXNUM CLI::%%MERLIN-I-VME-OPTION-DATA-TYPE
		  (%POINTER ADDRESS))))
    (Merlin-II
      ;; Change it back to a VMEbus direct access address
      (%MAKE-PHYSICAL-ADDRESS
	(%LOGDPBS CLI::%%VME-SHUFFLE-NONE CLI::%%MERLIN-VME-OPTION-SHUFFLE
		  (%POINTER ADDRESS))))
    (OTHERWISE ADDRESS)))
