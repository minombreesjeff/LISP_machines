;;; -*- Mode: LISP; Syntax: Zetalisp; Package: SI; Base: 10 -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; New AARRAY substrate.  April 1987 DLA.
;;;
;;; An AARRAY is an ART-Q-LIST array of conses.  The car of each cons is always a string.
;;; G-L-P of an AARRAY therefore will get you an ALIST keyed on strings.
;;; The leader of an AARRAY always contains two elements:
;;;    1.  The fill pointer.
;;;    2.  The sort state.
;;;
;;; The sort state describes which elements of the AARRAY are sorted.  If any elements
;;; are unsorted, then they are always at the end of the AARRAY.  In other words; the
;;; low portion of a partially-sorted AARRAY contains sorted elements, and the high
;;; portion of an AARRAY contains any unsorted elements.  The boundary of these two
;;; regions is called the "sort max", and is a subfield of the sort state.
;;;
;;; There are three kinds of insertion into AARRAYS.  Normal insertion of (KEY . VALUES)
;;; will add an element to the AARRAY, unless KEY is already there, in which case VALUES
;;; will be merged with the values in the existing key, using CL:UNION :TEST #'ZL:EQUAL.
;;;
;;; The second kind of insertion is called WHOLE-CDR insertion.  In this case, insertion
;;; of (KEY . VALUES) when KEY already exists will simply replace the values of the
;;; previous key.
;;;
;;; The third kind stores atomic items for those elements for which KEY can be deduced
;;; by calling STRING on it.
;;; 
;;; Which kind of insertion was used for the unsorted element is called the INSERTION-TYPE
;;; and is a subfield of the sort state.  It is only meaningful if the SORT-MAX is
;;; less than the fill pointer.
;;;
;;; The advertised routines which hack AARRAYs lock them, but the internal routines
;;; do not.  So if yuo use an internal function on an AARRAY, you better take the
;;; lock explicitly yourself.


;;; This variable controls how inserts into AARRAYs are handled.  If it
;;; is T, then the elments merely pushed onto the end of the AARRAY for
;;; later merging.  The theory is that this helps paging.

(DEFVAR-RESETTABLE *DEFER-AARRAY-SORTING* T)

;;; SORTING-MODIFIED-AARRAYS causes all AARRAYs on which deferred insertions
;;; were performed to be sorted upon exit from the special form.  This could be useful
;;; for some operations such as loading a system.

(DEFVAR-RESETTABLE *COLLECT-MODIFIED-AARRAYS-FOR-SORTING* NIL)
(DEFVAR-RESETTABLE *MODIFIED-AARRAYS-TO-BE-SORTED* NIL)

(DEFMACRO SORTING-MODIFIED-AARRAYS-IF (CONDITION &BODY BODY)
  (SELECTQ CONDITION
    ((NIL) `(PROGN . ,BODY))
    (OTHERWISE
     `(LET ((BIND-AND-SORT (AND ,CONDITION (NOT *COLLECT-MODIFIED-AARRAYS-FOR-SORTING*))))
	(LET-IF BIND-AND-SORT
		((*COLLECT-MODIFIED-AARRAYS-FOR-SORTING* T)
		 (*MODIFIED-AARRAYS-TO-BE-SORTED* NIL))
	  (MULTIPLE-VALUE-PROG1
	    (PROGN . ,BODY)
	    (WHEN BIND-AND-SORT
	      ;; Only the caller who initially bound *MODIFIED-AARRAYS-TO-BE-SORTED*
	      ;; should do any sorting
	      (LOOP FOR AARRAY IN *MODIFIED-AARRAYS-TO-BE-SORTED*
		    DO (SORT-AARRAY AARRAY)))))))))

(DEFMACRO SORTING-MODIFIED-AARRAYS (&BODY BODY)
  `(SORTING-MODIFIED-AARRAYS-IF T . ,BODY))

;;; The following is intended to be a user option.  Whenever you have a "load" form which
;;; has a SORTING-MODIFIED-AARRAYS around it, consider doing
;;; SORTING-MODIFIED-AARRAYS-IF *ENABLE-AARRAY-SORTING-AFTER-LOADS*.
;;; This allows users to customize their response times.

(DEFVAR *ENABLE-AARRAY-SORTING-AFTER-LOADS* T)

;;; AARRAY accessors.

(DEFSUBST AARRAY-SORT-STATE (AARRAY) (ARRAY-LEADER AARRAY 1))
(DEFSUBST AARRAY-LOCK (AARRAY) (ARRAY-LEADER AARRAY 2))

(DEFCONSTANT %%AARRAY-SORT-MAX (BYTE 31 0))
(DEFCONSTANT %%AARRAY-SORT-TYPE (BYTE 1 31))
(DEFCONSTANT %AARRAY-SORT-NORMAL 0)
(DEFCONSTANT %AARRAY-SORT-WHOLE-CDR 1)

(DEFSUBST SORT-STATE-MAX (STATE) (%LOGLDB %%AARRAY-SORT-MAX STATE))
(DEFSUBST SORT-STATE-TYPE (STATE) (%LOGLDB %%AARRAY-SORT-TYPE STATE))

(DEFSUBST AARRAY-SORT-MAX (AARRAY)
  (SORT-STATE-MAX (AARRAY-SORT-STATE AARRAY)))

(DEFSUBST AARRAY-SORT-TYPE (AARRAY)
  (SORT-STATE-TYPE (AARRAY-SORT-STATE AARRAY)))

(DEFSUBST AARRAY-ELEMENT-KEY (ELEMENT)
  (IF (LISTP ELEMENT) (CAR ELEMENT) (STRING ELEMENT)))

;;; AARRAY creation routines.

;; This is a real kludge, forced on me by compatibility.
(DEFVAR *AARRAY-NAME-ALIST* NIL)

(DEFUN OPTIMIZE-AARRAY-NAME-ALIST ()
  (LOOP FOR ENTRY IN *AARRAY-NAME-ALIST*
	AS OLD = (CAR ENTRY)
	AS NEW = (FOLLOW-STRUCTURE-FORWARDING OLD)
	WHEN (NEQ OLD NEW)
	  DO (SETF (CAR ENTRY) NEW)))

(ADD-INITIALIZATION "OPTIMIZE-AARRAY-NAME-ALIST" '(OPTIMIZE-AARRAY-NAME-ALIST) '(:BEFORE-COLD))
(ADD-INITIALIZATION "OPTIMIZE-AARRAY-NAME-ALIST" '(OPTIMIZE-AARRAY-NAME-ALIST) '(:FULL-GC))

(DEFUN MAKE-AARRAY (LENGTH &KEY NAME AREA)
  (LET ((AARRAY (MAKE-ARRAY LENGTH :TYPE ART-Q-LIST :LEADER-LENGTH 3 :AREA AREA)))
    (SETF (FILL-POINTER AARRAY) 0)
    (SETF (AARRAY-SORT-STATE AARRAY) 0)
    (SETF (AARRAY-LOCK AARRAY)
	  (PROCESS:MAKE-LOCK (IF NAME (STRING-APPEND NAME " Lock") "Completion Table Lock")
			     :RECURSIVE T))
    (WHEN NAME
      ;; Can't use CL:FIND, because it's not in the cold load.
      (LET ((OLD-ENTRY (CL:RASSOC NAME *AARRAY-NAME-ALIST* :TEST #'STRING= :KEY #'CAR)))
	(IF OLD-ENTRY
	    (SETF (CAR OLD-ENTRY) AARRAY)
	    (CL:PUSH (LIST AARRAY NAME) *AARRAY-NAME-ALIST* :LOCALIZE 2))))
    AARRAY))

(DEFMACRO WITH-STACK-AARRAY ((VARIABLE LENGTH) &BODY BODY)
  `(SYS:WITH-STACK-ARRAY (,VARIABLE ,LENGTH :TYPE ART-Q-LIST :LEADER-LENGTH 3)
     (SETF (FILL-POINTER ,VARIABLE) 0)
     (SETF (AARRAY-SORT-STATE ,VARIABLE) 0)
     ,@BODY))

;; This is like WITH-STACK-AARRAY, but if the stack aarray is too big it allocates
;; the aarray on the heap.  Internal routines use this to avoid overflowing the
;; data stack.
(DEFMACRO WITH-STACK-AARRAY-MAYBE ((VARIABLE LENGTH) &BODY BODY &ENVIRONMENT ENV)
  (ONCE-ONLY (LENGTH &ENVIRONMENT ENV)
    `(SYS:WITH-DATA-STACK
       (LET ((,VARIABLE (IF (> ,LENGTH ,1024)
			    (MAKE-AARRAY ,LENGTH)
			  (MAKE-STACK-ARRAY ,LENGTH :TYPE ART-Q-LIST :LEADER-LENGTH 3))))
	 (SETF (FILL-POINTER ,VARIABLE) 0)
	 (SETF (AARRAY-SORT-STATE ,VARIABLE) 0)
	 ,@BODY))))

(DEFMACRO WITH-AARRAY-LOCKED (AARRAY &BODY BODY)
  `(FLET ((BODY () ,@BODY))
     (LET ((STATE (AARRAY-SORT-STATE ,AARRAY)))
       (IF (OR (EQ STATE T) (NULL STATE)
	       ( (ARRAY-LEADER-LENGTH ,AARRAY) 3))
	   ;;--- Temporary compatibility kludge, remove for Rel 8
	   (BODY)
	   (PROCESS:WITH-LOCK ((AARRAY-LOCK ,AARRAY))
	     (BODY))))))

(DEFUN AARRAY-SORTED-P (AARRAY)
  (LET ((STATE (AARRAY-SORT-STATE AARRAY)))
    ;;--- Temporary compatibility kludge, remove for Rel 8
    (COND ((NULL STATE)
	   (SETF (AARRAY-SORT-STATE AARRAY)
		 (SETQ STATE 0)))
	  ((EQ STATE T)
	   (SETF (AARRAY-SORT-STATE AARRAY)
		 (SETQ STATE (FILL-POINTER AARRAY)))))
    ;;---
    (= (SORT-STATE-MAX STATE) (FILL-POINTER AARRAY))))

;; Like CHAR-LESSP but ignores BITS
(DEFSUBST FAST-CHAR-LESSP (CHAR1 CHAR2)
  (DECLARE LT:(SIDE-EFFECTS SIMPLE))
  (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR1))
      (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR2))
	  (LET ((CODE1 (CHAR-CODE CHAR1))
		(CODE2 (CHAR-CODE CHAR2)))
	    (WHEN (CODE-LOWER-CASE-P CODE1)
	      (SETQ CODE1 (LOGXOR CODE1 #O40)))
	    (WHEN (CODE-LOWER-CASE-P CODE2)
	      (SETQ CODE2 (LOGXOR CODE2 #O40)))
	    (< CODE1 CODE2))
	T)
    (IF (ZEROP (CHAR-CHAR-SET-INDEX CHAR2))
	NIL
      (MULTIPLE-VALUE-BIND (CHAR-SET-1 INDEX-1)
	  (CHAR-CHAR-SET-AND-INDEX CHAR1)
	(MULTIPLE-VALUE-BIND (CHAR-SET-2 INDEX-2)
	    (CHAR-CHAR-SET-AND-INDEX CHAR2)
	  (IF (EQ CHAR-SET-1 CHAR-SET-2)
	      (SEND CHAR-SET-1 :CHAR-LESSP INDEX-1 INDEX-2)
	    (< (CHAR-CHAR-SET-INDEX CHAR1) (CHAR-CHAR-SET-INDEX CHAR2))))))))

(DEFUN %FAST-STRING-COMPARE (STRING1 STRING2)
  (DECLARE LT:(SIDE-EFFECTS READER REDUCIBLE))
  (LET ((STRING1 STRING1)
	(STRING2 STRING2))
    (DECLARE (SYS:ARRAY-REGISTER STRING1 STRING2))
    (LET ((LENGTH1 (STRING-LENGTH STRING1))
	  (LENGTH2 (STRING-LENGTH STRING2)))
      (LOOP FOR INDEX UPFROM 0 BELOW (MIN LENGTH1 LENGTH2) DOING
	(LET ((CH1 (AREF STRING1 INDEX))
	      (CH2 (AREF STRING2 INDEX)))
	  (COND ((CHAR-EQUAL CH1 CH2))
		((FAST-CHAR-LESSP CH1 CH2) (RETURN -1))
		(T (RETURN 1))))
	    FINALLY (RETURN
		      (LET ((TEMP (- LENGTH1 LENGTH2)))
			(IF (PLUSP TEMP) 1 (IF (MINUSP TEMP) -1 TEMP))))))))

(DEFUN %FAST-STRING-LESSP (STRING1 STRING2)
  (MINUSP (%FAST-STRING-COMPARE STRING1 STRING2)))

;; This is mainly for debugging
(DEFUN AARRAY-REALLY-SORTED-P (AARRAY)
  (WITH-AARRAY-LOCKED AARRAY
    (PREPAGE-AARRAY AARRAY)
    (LOOP FOR I BELOW (1- (FILL-POINTER AARRAY))
	  UNLESS (MINUSP (%FAST-STRING-COMPARE
			   (AARRAY-ELEMENT-KEY (AREF AARRAY I))
			   (AARRAY-ELEMENT-KEY (AREF AARRAY (1+ I)))))
	    RETURN (PROGN (FORMAT T "~%~S (~D) is out of order" (AREF AARRAY I) I) NIL)
	  FINALLY (RETURN T))))

;; This is mainly for debugging
(DEFUN DESCRIBE-AARRAY (AARRAY)
  (LET ((FILL-POINTER (FILL-POINTER AARRAY))
	(STATE (AARRAY-SORT-STATE AARRAY)))
    ;;--- Temporary compatibility kludge, remove for Rel8 
    (COND ((NULL STATE)
	   (SETQ STATE 0)
	   (FORMAT T "~%Note:  ~S has not been updated to the new format." AARRAY))
	  ((EQ STATE T)
	   (SETQ STATE (FILL-POINTER AARRAY))
	   (FORMAT T "~%Note:  ~S has not been updated to the new format." AARRAY)))
    ;;---
    (LET ((MAX (SORT-STATE-MAX STATE))
	  (TYPE (SORT-STATE-TYPE STATE)))
      (FORMAT T "~%AARRAY ~S contains ~D out of a possible ~D element~:P."
	      AARRAY FILL-POINTER (ARRAY-LENGTH AARRAY))
      (COND ((ZEROP MAX)
	     (FORMAT T "~%It is unsorted."))
	    ((= MAX FILL-POINTER)
	     (FORMAT T "~%It is completely sorted."))
	    ((= MAX 1)
	     (FORMAT T "~%It is unsorted.  (The first element is /"sorted/".)"))
	    (T (FORMAT T "~%The first ~D element~:P are sorted." MAX)))
      (WHEN (PLUSP FILL-POINTER)
	(COND ((< MAX FILL-POINTER)
	       (FORMAT T "~%Unsorted elements were added in ~[normal~;whole-cdr~] mode." TYPE)
	       (FORMAT T "~%If it were sorted now, the algorithm used would be ~
		          ~:[normal merge sort~;binary lookup insertion merge~]."
		       (< (- FILL-POINTER MAX)
			  (// (* 2 MAX) (MAX 1 (- (HAULONG MAX) 3))))))
	      ((= MAX FILL-POINTER)
	       (FORMAT T "  Verifying ...")
	       (IF (AARRAY-REALLY-SORTED-P AARRAY)
		   (FORMAT T " It is really sorted.")
		   (FORMAT T "~%It is not really sorted.  (This indicates a bug.)")))))
      (LOOP AS FORWARD = AARRAY THEN (%MAKE-POINTER DTP-ARRAY (%P-POINTER FORWARD))
	    AS DATA-TYPE = (%P-DATA-TYPE FORWARD)
	    WHILE (= DATA-TYPE DTP-HEADER-FORWARD)
	    COUNT T INTO FORWARD-COUNT
	    FINALLY
	      (WHEN (PLUSP FORWARD-COUNT)
		(FORMAT T "~%Note:  ~S has been structure-forwarded ~A" AARRAY
		  (CL:CASE FORWARD-COUNT
		    (1 "once.")
		    (2 "twice.")
		    (3 "three times.")
		    (OTHERWISE (FORMAT NIL "~R times!!" FORWARD-COUNT))))))
      AARRAY)))

;;; AARRAY table functions.

;; This is the standard way to insert something into an aarray; it
;; associates STRING with DATUM.  The datum is replaces any previous
;; datum if inserted in WHOLE-CDR mode, otherwise it is merged to the
;; list of existing data.  No useful value is returned.
;; EXTENDER is the function which is used to extend the aarray if it is necessary.
;; See DEFAULT-AARRAY-EXTENDER as an example.
;; If SORT-BEFORE-EXTENDING is true, then the AARRAY is sorted (to eliminate
;; duplicates) before attempting to extend the aarray.
(DEFUN AARRAY-INSERT (AARRAY STRING DATUM
		      &OPTIONAL WHOLE-CDR EXTENDER (SORT-BEFORE-EXTENDING T))
  (WITH-AARRAY-LOCKED AARRAY
    ;; Do a fast insert if enabled and possible.
    (BLOCK FAST-AARRAY-INSERT
      (WHEN *DEFER-AARRAY-SORTING*
	(LET ((STATE (AARRAY-SORT-STATE AARRAY))
	      (FILL-POINTER (FILL-POINTER AARRAY))
	      (LENGTH (ARRAY-LENGTH AARRAY)))
	  ;;--- Temporary compatibility kludge, remove for Rel 8
	  (COND ((NULL STATE)
		 (SETF (AARRAY-SORT-STATE AARRAY)
		       (SETQ STATE 0)))
		((EQ STATE T)
		 (SETF (AARRAY-SORT-STATE AARRAY)
		       (SETQ STATE (FILL-POINTER AARRAY)))))
	  ;;---
	  (LET ((MAX (SORT-STATE-MAX STATE))
		(TYPE (SORT-STATE-TYPE STATE)))
	    (UNLESS (OR (= FILL-POINTER MAX)
			(SELECTQ WHOLE-CDR
			  ((ATOM NIL) (= TYPE %AARRAY-SORT-NORMAL))
			  (OTHERWISE (= TYPE %AARRAY-SORT-WHOLE-CDR))))
	      ;; By doing a sort here, we're already being slow, so we
	      ;; might as well do a slow insert.
	      (RETURN-FROM FAST-AARRAY-INSERT NIL))
	    (WHEN ( FILL-POINTER LENGTH)
	      ;; Oops, the aarray is too long.  It may be better to try to
	      ;; compress it by removing duplicates than to grow it.
	      (IF SORT-BEFORE-EXTENDING
		  (RETURN-FROM FAST-AARRAY-INSERT NIL)
		(SETQ AARRAY (FUNCALL (OR EXTENDER #'DEFAULT-AARRAY-EXTENDER) AARRAY))))
	    ;; Ah, we can do a fast insert.
	    (ARRAY-PUSH AARRAY (SELECTQ WHOLE-CDR
				 ((ATOM) DATUM)
				 ((NIL) (LIST STRING DATUM))
				 (OTHERWISE (CONS STRING DATUM))))
	    ;; If in delayed-sorting mode, remember this aarray to be sorted later.
	    (WHEN *COLLECT-MODIFIED-AARRAYS-FOR-SORTING*
	      (CL:PUSHNEW AARRAY *MODIFIED-AARRAYS-TO-BE-SORTED*))
	    ;; Update the sort state
	    (WHEN (= FILL-POINTER MAX)
	      (WHEN (ZEROP MAX)		;If we inserted the only element, we're still sorted!
		(INCF MAX))
	      (SETF (AARRAY-SORT-STATE AARRAY)
		    (%LOGDPB (SELECTQ WHOLE-CDR
			       ((ATOM NIL) %AARRAY-SORT-NORMAL)
			       (OTHERWISE %AARRAY-SORT-WHOLE-CDR)) 
			     %%AARRAY-SORT-TYPE MAX)))
	    (RETURN-FROM AARRAY-INSERT NIL)))))
    ;; Slow case.  Deferred aarray sorting is disabled by some Luddite, or the fast
    ;; case decided to be slow.
    (SORT-AARRAY AARRAY)
    (MULTIPLE-VALUE-BIND (ASSOC INDEX)
	(SORTED-AARRAY-LOOKUP STRING AARRAY)
      (COND ((NULL ASSOC)
	     (LET ((LENGTH (ARRAY-LENGTH AARRAY))
		   (FILL-POINTER (FILL-POINTER AARRAY)))
	       (UNLESS (> LENGTH FILL-POINTER)
		 (SETQ AARRAY (FUNCALL (OR EXTENDER #'DEFAULT-AARRAY-EXTENDER) AARRAY)))
	       (SHIFT-SUBARRAY-LATER AARRAY INDEX FILL-POINTER (1+ INDEX))
	       (SETF (AREF AARRAY INDEX)
		     (SELECTQ WHOLE-CDR
		       ((ATOM) DATUM)
		       ((NIL) (LIST STRING DATUM))
		       (OTHERWISE (CONS STRING DATUM))))
	       (UNLESS (ZEROP FILL-POINTER)
		 (%P-STORE-CDR-CODE (LOCF (AREF AARRAY (1- FILL-POINTER))) CDR-NEXT))
	       (%P-STORE-CDR-CODE (LOCF (AREF AARRAY FILL-POINTER)) CDR-NIL)
	       (LET ((FILL-POINTER (INCF (FILL-POINTER AARRAY))))
		 (SETF (AARRAY-SORT-STATE AARRAY) FILL-POINTER))))
	    ((EQ WHOLE-CDR 'ATOM)
	     (UNLESS (EQUAL DATUM ASSOC)
	       (IF (LISTP ASSOC)
		   (PUSH DATUM (CDR ASSOC))
		   (SETF (AREF AARRAY INDEX) (LIST STRING DATUM ASSOC)))))
	    (WHOLE-CDR
	     (SETF (CDR ASSOC) DATUM))
	    ((NOT (MEMBER DATUM (CDR ASSOC)))
	     (PUSH DATUM (CDR ASSOC))))))
  NIL)

(DEFUN DEFAULT-AARRAY-EXTENDER (AARRAY)
  (LET ((LENGTH (ARRAY-LENGTH AARRAY)))
    (ADJUST-ARRAY-SIZE AARRAY
		       (+ (1+ LENGTH)
			  (IF (< LENGTH SYS:PAGE-SIZE)
			      (MAX LENGTH (// SYS:PAGE-SIZE 2))
			      (// LENGTH 3))))))

;; This deletes the entry for STRING and DATUM from the AARRAY.
;;--- A version of this could be written which doesn't require sorting.
(DEFUN AARRAY-DELETE (AARRAY STRING DATUM &OPTIONAL WHOLE-CDR)
  (WITH-AARRAY-LOCKED AARRAY
    (SORT-AARRAY AARRAY)
    (MULTIPLE-VALUE-BIND (ASSOC INDEX)
	(SORTED-AARRAY-LOOKUP STRING AARRAY)
      (WHEN ASSOC
	(SELECTQ WHOLE-CDR
	  ((ATOM)
	   (IF (EQUAL DATUM ASSOC)
	       (AARRAY-DELETE-INTERNAL AARRAY INDEX)
	       (WHEN (LISTP ASSOC)
		 (WHEN (AND (MEMBER DATUM (CDR ASSOC))
			    (NULL (SETF (CDR ASSOC) (DELETE DATUM (CDR ASSOC)))))
		   ;; Could also convert one element entry to atomic here, but seems rare.
		   (AARRAY-DELETE-INTERNAL AARRAY INDEX)))))
	  ((NIL)
	   (WHEN (AND (MEMBER DATUM (CDR ASSOC))
		      (NULL (SETF (CDR ASSOC) (DELETE DATUM (CDR ASSOC)))))
	     (AARRAY-DELETE-INTERNAL AARRAY INDEX)))
	  (OTHERWISE
	   (WHEN (EQUAL DATUM (CDR ASSOC))
	     (AARRAY-DELETE-INTERNAL AARRAY INDEX)))))
      NIL)))

;; This is the same as above, but deletes all values for STRING.
;; It also allows you to specify a hairy matching function for the string.
(DEFUN AARRAY-DELETE-BY-NAME (AARRAY STRING &KEY (TEST #'STRING-EQUAL))
  (WITH-AARRAY-LOCKED AARRAY
    (SORT-AARRAY AARRAY)
    (IF (EQ TEST #'STRING-EQUAL)
	(MULTIPLE-VALUE-BIND (ASSOC INDEX)
	    (SORTED-AARRAY-LOOKUP STRING AARRAY)
	  (WHEN ASSOC
	    (AARRAY-DELETE-INTERNAL AARRAY INDEX)))
      (LOOP WITH I = 0 WHILE (< I (FILL-POINTER AARRAY)) DO
	(IF (FUNCALL TEST STRING (AARRAY-ELEMENT-KEY (AREF AARRAY I)))
	    (AARRAY-DELETE-INTERNAL AARRAY I)
	  (INCF I))))))

;; An internal function not for public consumption.
(DEFUN AARRAY-DELETE-INTERNAL (AARRAY INDEX)
  (LET ((LENGTH (FILL-POINTER AARRAY)))
    (COPY-ARRAY-PORTION AARRAY (1+ INDEX) LENGTH
			AARRAY INDEX (DECF LENGTH))
    (SETF (FILL-POINTER AARRAY) LENGTH)
    (SETF (AARRAY-SORT-STATE AARRAY) LENGTH)
    (SETF (AREF AARRAY LENGTH) NIL)		;help the GC
    (UNLESS (ZEROP LENGTH)
      (%P-STORE-CDR-CODE (LOCF (AREF AARRAY (1- LENGTH))) CDR-NIL))
    NIL))

;; Internal
(DEFUN SORT-AARRAY-PROGRESS-NOTE (AARRAY)
  (LET ((AARRAY (FOLLOW-STRUCTURE-FORWARDING AARRAY)))
    (LOOP FOR (CANDIDATE NAME) IN *AARRAY-NAME-ALIST*
	  WHEN (EQ (FOLLOW-STRUCTURE-FORWARDING CANDIDATE) AARRAY)
	    RETURN (FORMAT NIL "Sorting ~A" NAME)
	  FINALLY (RETURN "Sorting a completion aarray"))))

;; This function sorts an aarray if required.
;; To force a true sort of the AARRAY, first (SETF (AARRAY-SORT-MAX AARRAY) 0).
(DEFUN SORT-AARRAY (AARRAY)
  (WITH-AARRAY-LOCKED AARRAY
    (LET ((FILL-POINTER (FILL-POINTER AARRAY))
	  (STATE (AARRAY-SORT-STATE AARRAY)))
      ;;--- Temporary compatibility kludge, remove for Rel 8
      (COND ((NULL STATE)
	     (SETF (AARRAY-SORT-STATE AARRAY)
		   (SETQ STATE 0)))
	    ((EQ STATE T)
	     (SETF (AARRAY-SORT-STATE AARRAY)
		   (SETQ STATE (FILL-POINTER AARRAY)))))
      ;;---
      (LET ((MAX (SORT-STATE-MAX STATE))
	    (TYPE (SORT-STATE-TYPE STATE)))
	(WHEN (> MAX FILL-POINTER)
	  (FSIGNAL "Sort state larger than fill pointer in an AARRAY.")
	  (SETF (AARRAY-SORT-STATE AARRAY) FILL-POINTER)
	  (RETURN-FROM SORT-AARRAY NIL))
	(UNLESS (= MAX FILL-POINTER)
	  (TV:NOTING-PROGRESS ((SORT-AARRAY-PROGRESS-NOTE AARRAY))
	    ;; A sort is required
	    (SYS:WITHOUT-ABORTS (SORT-AARRAY "AARRAY ~S is being sorted." AARRAY)
	      (IF (< MAX (CEILING FILL-POINTER 4))
		  ;; Sort the whole array.
		  (PROGN
		    (PREPAGE-AARRAY AARRAY)
		    (TV:NOTE-PROGRESS 1 3)
		    ;; This has to be stable if we're deleting duplicates, so they come
		    ;; out in the right order.  If we're merging, order doesn't matter.
		    (FUNCALL (IF (= TYPE %AARRAY-SORT-NORMAL) #'CL:SORT #'CL:STABLE-SORT)
			     AARRAY #'%FAST-STRING-LESSP :KEY #'AARRAY-ELEMENT-KEY)
		    (TV:NOTE-PROGRESS 2 3)
		    ;; Merge or delete elements depending on the sort type
		    (MERGE-SINGLE-AARRAY AARRAY 0 (= TYPE %AARRAY-SORT-WHOLE-CDR)))
		;; Do it the hard way; it's probably more efficient.
		(PROGN
		  ;; Prepage the portion which we know we're going to touch.
		  ;; It's probably bad to prepage the rest and not touch it, so don't.
		  (PREPAGE-AARRAY AARRAY MAX)
		  (TV:NOTE-PROGRESS 1 3)
		  ;; Sort the unsorted part.
		  (FUNCALL (IF (= TYPE %AARRAY-SORT-NORMAL) #'CL:SORT #'CL:STABLE-SORT)
			   (%MAKE-POINTER DTP-LIST (ALOC AARRAY MAX))
			   #'%FAST-STRING-LESSP :KEY #'AARRAY-ELEMENT-KEY)
		  (TV:NOTE-PROGRESS 2 3)
		  ;; Merge the two halves.
		  (MERGE-SINGLE-AARRAY AARRAY MAX (= TYPE %AARRAY-SORT-WHOLE-CDR))))
	      ;; Set the state to sorted.  Get the real fill-pointer set by
	      ;; MERGE-SINGLE-AARRAY.
	      (SETF (AARRAY-SORT-STATE AARRAY)
		    (%LOGDPB TYPE %%AARRAY-SORT-TYPE (FILL-POINTER AARRAY))))))))))

;; This internal routine takes an AARRAY which has two separately sorted chunks
;; delimited by MERGE-INDEX and sorts the AARRAY by merging the halves.
;; Notice that this doesn't bother locking the aarray, since it is only called
;; by SORT-AARRAY, which does the locking itself.
(DEFUN MERGE-SINGLE-AARRAY (AARRAY MERGE-INDEX DELETE-DUPLICATES)
  (LET* ((FILL-POINTER (FILL-POINTER AARRAY))
	 (LENGTH2 (- FILL-POINTER MERGE-INDEX)))
    (WHEN (PLUSP LENGTH2)
      (IF (ZEROP MERGE-INDEX)
	  (MERGE-AARRAY-DUPLICATES AARRAY DELETE-DUPLICATES)
	  (WITH-STACK-AARRAY-MAYBE (AARRAY2 LENGTH2)
	    (COPY-ARRAY-PORTION AARRAY MERGE-INDEX FILL-POINTER
				AARRAY2 0 LENGTH2)
	    (SETF (FILL-POINTER AARRAY2) LENGTH2)
	    (SETF (FILL-POINTER AARRAY) MERGE-INDEX)
	    (MERGE-AARRAYS AARRAY AARRAY2 DELETE-DUPLICATES))))))

;; DESCRIPTION OF THE AARRAY MERGING ALGORITHM
;;
;; The simple merging algorithm when merging aarrays of length N and n,
;; does 2(N+n) string comparisons (actually, the 2 represents
;; %string-lessp then %string-equal).  For large N, this is expensive.
;; The binary search algorithm here takes only n(lg N) comparisons.  For
;; the case of merging, say, 10. elts into an aarray of length 4000.,
;; this would take (* 10.0 (lg 4000.0)) = 120. operations, instead of (*
;; 2 (+ 4000.  20.)) = 10040., reducing the number of string comparisons
;; by a factor of (// 10040.0 120.0) = 83.  For any N, this algorithm is
;; faster than the linear one if n < 2N / (lg N - 2).
;; 
;; 	   N	    faster if n<this
;; 	   16		  16
;; 	   64		  32
;; 	  256		  85
;; 	 1024		 256
;; 	 4096		 819

;; This semi-internal routine Merges AARRAY1 and AARRAY2 into AARRAY1.
;; It should not be necessary for clients to call this, but there's no reason they couldn't.
;; AARRAY1 is assumed to contain no duplicates.
;; AARRAY2 contains "additions", so it may contain duplicates.
;; AARRAY1 must be big enough or an error is signalled.
;; Notice that this doesn't bother locking the aarray, since it is only called
;; by MERGE-SINGLE-AARRAY (via SORT-AARRAY), which does the locking itself.
;;--- Please don't change this to randomly grow and structure-forward AARRAYs until
;;--- you consider all the callers.
(DEFUN MERGE-AARRAYS (AARRAY1 AARRAY2 DELETE-DUPLICATES)
  (LET* ((AARRAY1 AARRAY1)
	 (AARRAY2 AARRAY2)
	 (LENGTH1 (ARRAY-LENGTH AARRAY1))
	 (FILL-POINTER1 (FILL-POINTER AARRAY1))
	 (FILL-POINTER2 (FILL-POINTER AARRAY2))
	 (N-ELEMENTS (+ FILL-POINTER1 FILL-POINTER2)))
    (DECLARE (ARRAY-REGISTER AARRAY1 AARRAY2))
    (WHEN (> N-ELEMENTS LENGTH1)
      (FERROR "Attempt to merge into an aarray with insufficient room."))
    ;; Choose the most efficient algorithm based on number of string-compares.
    ;; Note:  Don't "fix" this to swap the arrays in the case where
    ;; FILL-POINTER1 > FILL-POINTER2.  We can't do that without first doing
    ;; MERGE-AARRAY-DUPLICATES on AARRAY2, at which point the benefits become unclear.
    (IF (< FILL-POINTER2 (// (* 2 FILL-POINTER1) (MAX 1 (- (HAULONG FILL-POINTER1) 3))))
	;; Binary Lookup Insertion Merge (BLIM, not to be confused with BIM).
	(WITH-STACK-ARRAY (STACK (* 2 FILL-POINTER2))
	  (DECLARE (ARRAY-REGISTER STACK))
	  (LET ((STACK-POINTER 0))
	    ;; Loop through the elements in AARRAY2, looking up the keys in AARRAY1.
	    ;; When found, merge appropriately.  Otherwise, push the element and the
	    ;; lookup index onto the stack.
	    (LOOP FOR I BELOW FILL-POINTER2
		  AS ELEM2 = (AREF AARRAY2 I) DO
	      (MULTIPLE-VALUE-BIND (ELEM1 INDEX)
		  (SORTED-AARRAY-LOOKUP (AARRAY-ELEMENT-KEY ELEM2) AARRAY1)
		(IF ELEM1
		    ;; Just adjust current item instead of adding
		    (IF DELETE-DUPLICATES
			(SETF (AREF AARRAY1 INDEX) ELEM2)
			(UNLESS (EQUAL ELEM1 ELEM2)
			  (LET ((CDR (CL:UNION (IF (ATOM ELEM1)
						   (LIST ELEM1)
						   (CDR ELEM1))
					       (IF (ATOM ELEM2)
						   (LIST ELEM2)
						   (CDR ELEM2))
					       :TEST #'ZL:EQUAL)))
			    (IF (ATOM ELEM1)
				(SETF (AREF AARRAY1 INDEX)
				      (CONS (AARRAY-ELEMENT-KEY ELEM2) CDR))
				(SETF (CDR ELEM1) CDR)))))
		    ;; Remember that this item needs to be added in
		    ;; Note that the list is collected in backwards order
		    (SETF (AREF STACK STACK-POINTER) ELEM2)
		    (INCF STACK-POINTER)
		    (SETF (AREF STACK STACK-POINTER) INDEX)
		    (INCF STACK-POINTER))))
	    ;; Now see if there are any elements left to add.
	    (WHEN (PLUSP STACK-POINTER)
	      ;; There are.  Handle duplicates in the new elements now.
	      (LOOP WITH I = 0
		    WHILE (< I (- STACK-POINTER 2))
		    AS ELEM1 = (AREF STACK I)
		    AS ELEM2 = (AREF STACK (+ I 2))
		    WHEN (%STRING-EQUAL (AARRAY-ELEMENT-KEY ELEM1) 0
					(AARRAY-ELEMENT-KEY ELEM2) 0 NIL)
		      DO (WHEN (NOT DELETE-DUPLICATES)
			   (UNLESS (EQUAL ELEM1 ELEM2)
			     (LET ((CDR (CL:UNION (IF (ATOM ELEM1)
						      (LIST ELEM1)
						      (CDR ELEM1))
						  (IF (ATOM ELEM2)
						      (LIST ELEM2)
						      (CDR ELEM2))
						  :TEST #'ZL:EQUAL)))
			       (IF (ATOM ELEM2)
				   (SETF (AREF STACK (+ I 2))
					 (CONS (AARRAY-ELEMENT-KEY ELEM2) CDR))
				   (SETF (CDR ELEM2) CDR)))))
			 (LOOP FOR J FROM I BELOW (- STACK-POINTER 2) DO
			   (SETF (AREF STACK J) (AREF STACK (+ J 2))))
			 (DECF STACK-POINTER 2)
		    ELSE DO (INCF I 2))
	      ;; Now insert them at their proper indices.
	      (LET ((NEW-FILL-POINTER1 (+ FILL-POINTER1 (ASH STACK-POINTER -1))))
		(SETF (FILL-POINTER AARRAY1) NEW-FILL-POINTER1)
		(SETF (%P-CDR-CODE (ALOC AARRAY1 (1- NEW-FILL-POINTER1))) CDR-NIL)
		(SETF (%P-CDR-CODE (ALOC AARRAY1 (1- FILL-POINTER1))) CDR-NEXT)
		(LOOP FOR SP DOWNFROM (1- STACK-POINTER) ABOVE 0 BY 2
		      FOR SHIFT DOWNFROM (ASH STACK-POINTER -1)
		      FOR BLOCK-BASE = (+ (AREF STACK SP) SHIFT)
		      AND BLOCK-LIMIT = NEW-FILL-POINTER1 THEN (1- BLOCK-BASE)
		      DO (LOOP FOR I DOWNFROM (1- BLOCK-LIMIT) TO BLOCK-BASE
			       DO (SETF (AREF AARRAY1 I) (AREF AARRAY1 (- I SHIFT))))
			 (SETF (AREF AARRAY1 (- BLOCK-BASE 1)) (AREF STACK (1- SP))))))))
	;; Normal merge.
	(PROGN
	  ;; Shift up the contents in AARRAY1.
	  (LOOP FOR I DOWNFROM (1- FILL-POINTER1) TO 0
		DO (SETF (AREF AARRAY1 (+ I FILL-POINTER2)) (AREF AARRAY1 I)))
	  (LOOP WITH I1 = FILL-POINTER2
		WITH I2 = 0
		WITH I3 = 0
		WITH ELEM1 = (AREF AARRAY1 I1)
		WITH ELEM2 = (AREF AARRAY2 I2)
		WITH KEY-ELEM1 = (AARRAY-ELEMENT-KEY ELEM1)
		WITH KEY-ELEM2 = (AARRAY-ELEMENT-KEY ELEM2)
		WITH (THIS-ELEM LAST-ELEM)
		DO (COND (( I2 FILL-POINTER2)	;Ran out of AARRAY2 elements
			  (WHEN ( I1 N-ELEMENTS)
			    (SETF (FILL-POINTER AARRAY1) I3)
			    (SETF (%P-CDR-CODE (ALOC AARRAY1 (1- I3))) CDR-NIL)
			    (RETURN NIL))
			  (SETQ THIS-ELEM ELEM1)
			  (UNLESS ( (INCF I1) N-ELEMENTS)
			    (SETQ ELEM1 (AREF AARRAY1 I1)
				  KEY-ELEM1 (AARRAY-ELEMENT-KEY ELEM1))))
			 ((OR ( I1 N-ELEMENTS)	;Ran out of AARRAY1 elements
			      (PLUSP (%FAST-STRING-COMPARE KEY-ELEM1 KEY-ELEM2)))
			  (SETQ THIS-ELEM ELEM2)	;Must do long loop for merging.
			  (UNLESS ( (INCF I2) FILL-POINTER2)
			    (SETQ ELEM2 (AREF AARRAY2 I2)
				  KEY-ELEM2 (AARRAY-ELEMENT-KEY ELEM2))))
			 (T
			  (SETQ THIS-ELEM ELEM1)
			  (UNLESS ( (INCF I1) N-ELEMENTS)
			    (SETQ ELEM1 (AREF AARRAY1 I1)
				  KEY-ELEM1 (AARRAY-ELEMENT-KEY ELEM1)))))
		   (COND ((OR (NULL LAST-ELEM)
			      (NOT (%STRING-EQUAL (AARRAY-ELEMENT-KEY LAST-ELEM) 0
						  (AARRAY-ELEMENT-KEY THIS-ELEM) 0 NIL)))
			  (SETF (AREF AARRAY1 I3) THIS-ELEM)
			  (INCF I3))
			 (DELETE-DUPLICATES
			  (SETF (AREF AARRAY1 (1- I3)) THIS-ELEM))
			 (T
			  (UNLESS (EQUAL LAST-ELEM THIS-ELEM)
			    (LET ((CDR (CL:UNION (IF (ATOM LAST-ELEM)
						     (LIST LAST-ELEM)
						     (CDR LAST-ELEM))
						 (IF (ATOM THIS-ELEM)
						     (LIST THIS-ELEM)
						     (CDR THIS-ELEM))
						 :TEST #'ZL:EQUAL)))
			      (IF (ATOM LAST-ELEM)
				  (SETF (AREF AARRAY1 (1- I3))
					(CONS (AARRAY-ELEMENT-KEY LAST-ELEM) CDR))
				  (SETF (CDR LAST-ELEM) CDR))))
			  (SETQ THIS-ELEM (AREF AARRAY1 (1- I3)))))
		   (SETQ LAST-ELEM THIS-ELEM))))))

;; This routine should be internal, because no legal sorted AARRAY created with
;; the AARRAY insertion and deletion routines should have any duplicates in it.
(DEFUN MERGE-AARRAY-DUPLICATES (AARRAY &OPTIONAL DELETE-P)
  (LET ((AARRAY AARRAY))
    (DECLARE (ARRAY-REGISTER AARRAY))
    ;;In the common case of no duplicates, this loop will actually spend
    ;;its time in STRING-EQUAL.  But why waste more time re-decoding the aarray?
    (LOOP WITH DUPLICATE-FOUND = ()
	  WITH N = (FILL-POINTER AARRAY)
	  FOR I FROM (1- N) DOWNTO 1
	  FOR ELTI = (AREF AARRAY I)
	  FOR ELTI-1 = (AREF AARRAY (1- I))
	  FOR KEY-ELTI = (AARRAY-ELEMENT-KEY ELTI)
	  FOR KEY-ELTI-1 = (AARRAY-ELEMENT-KEY ELTI-1)
	  WHEN (OR (EQ KEY-ELTI KEY-ELTI-1)	;It might be worth it.
		   (%STRING-EQUAL KEY-ELTI 0 KEY-ELTI-1 0 NIL))
	    DO (SETQ DUPLICATE-FOUND T)
	       (IF DELETE-P
		   (SETF (AREF AARRAY (1- I)) ELTI)
		   (UNLESS (EQUAL ELTI ELTI-1)
		     (LET ((CDR (CL:UNION (IF (ATOM ELTI-1) (LIST ELTI-1) (REST1 ELTI-1))
					  (IF (ATOM ELTI) (LIST ELTI) (REST1 ELTI))
					  :TEST #'ZL:EQUAL)))
		       (IF (ATOM ELTI-1)
			   (SETF (AREF AARRAY (1- I)) (CONS KEY-ELTI-1 CDR))
			   (SETF (REST1 ELTI-1) CDR)))))
	       (UNLESS ( I N)
		 (COPY-ARRAY-PORTION AARRAY (1+ I) N AARRAY I (1- N)))
	       (SETF (FILL-POINTER AARRAY) (SETQ N (1- N)))
	  FINALLY (WHEN DUPLICATE-FOUND
		    (SETF (%P-CDR-CODE (LOCF (AREF AARRAY (1- N)))) CDR-NIL))))
  AARRAY)


;;;Move some elements of an array to higher indices.
;;;This can't be done with COPY-ARRAY-PORTION, which does not handle overlaps correctly.
;;;This is a special purpose hack.  If COPY-ARRAY-PORTION is ever fixed to handle
;;;overlapping areas of the same array, then this code can be tossed.
(DEFUN SHIFT-SUBARRAY-LATER (ARRAY START END TO)
  (LET ((ARRAY ARRAY))
    (DECLARE (SYS:ARRAY-REGISTER ARRAY))
    (DO ((FROM (1- END) (1- FROM))
	 (TO (+ TO (- END START 1)) (1- TO)))
	((< FROM START))
      (SETF (AREF ARRAY TO) (AREF ARRAY FROM)))))

;;;This routine looks up a string in a sorted AARRAY.
;;;Is this string in the completion list?
;;;If true, returns the association pair
;;;Second value is where it was/would go before
(DEFUN SORTED-AARRAY-LOOKUP (STRING AARRAY &OPTIONAL FILL-POINTER)
  (DECLARE (VALUES PAIR IDX))
  (WITH-AARRAY-LOCKED AARRAY
    (LET ((AARRAY AARRAY))
      (DECLARE (ARRAY-REGISTER AARRAY))
      (WHEN (NULL FILL-POINTER)
	(SETQ FILL-POINTER (ARRAY-ACTIVE-LENGTH AARRAY)))
      (DO ((LO 0)
	   (HI FILL-POINTER)
	   IDX INC TEM)
	  (NIL)
	(AND (= HI LO) (RETURN (VALUES NIL HI)))
	(SETQ INC (LDB (BYTE 30 1) (- HI LO)))	; (FLOOR (- HI LO) 2)
	(SETQ IDX (+ LO INC))
	(COND ((ZEROP (SETQ TEM (%FAST-STRING-COMPARE
				  STRING
				  (AARRAY-ELEMENT-KEY (AREF AARRAY IDX)))))
	       (RETURN (VALUES (AREF AARRAY IDX) IDX)))
	      ((PLUSP TEM)
	       (IF (= (- HI LO) 1) (SETQ LO (1+ LO)) (SETQ LO IDX)))
	      (T
	       (IF (= (- HI LO) 1) (SETQ HI (1- HI)) (SETQ HI IDX))))))))

;; This is the general AARRAY lookup function.
;; Lookup something in a possibly unsorted AARRAY.
;; BOOLEAN-RESULT-P allows a little optimization in the unsorted lookup.
;; If it is true, the first element which is found is returned.
(DEFUN AARRAY-LOOKUP (STRING AARRAY &OPTIONAL BOOLEAN-RESULT-P (SORT :MAYBE))
  (WITH-AARRAY-LOCKED AARRAY
    (LET ((FILL-POINTER (FILL-POINTER AARRAY))
	  (STATE (AARRAY-SORT-STATE AARRAY)))
      ;;--- Temporary compatibility kludge, remove for Rel 8
      (COND ((EQ STATE T)
	     (SETF (AARRAY-SORT-STATE AARRAY) (SETQ STATE FILL-POINTER)))
	    ((NULL STATE)
	     (SETF (AARRAY-SORT-STATE AARRAY) (SETQ STATE 0))))
      ;;---
      (LET ((MAX (SORT-STATE-MAX STATE))
	    (TYPE (SORT-STATE-TYPE STATE)))
	(IF (OR (EQ SORT T)
		(AND (NOT (NULL SORT))
		     (AARRAY-LOOKUP-SORT-PREDICATE MAX FILL-POINTER)))
	    (PROGN (UNLESS (= MAX FILL-POINTER)	;cheap test.
		     (SORT-AARRAY AARRAY))
		   (VALUES (SORTED-AARRAY-LOOKUP STRING AARRAY)))
	  (LET ((PAIR (SORTED-AARRAY-LOOKUP STRING AARRAY MAX)))
	    (WHEN (AND PAIR BOOLEAN-RESULT-P)
	      (RETURN-FROM AARRAY-LOOKUP PAIR))
	    (LET ((AARRAY AARRAY))
	      (DECLARE (ARRAY-REGISTER AARRAY))
	      (LOOP FOR I FROM MAX BELOW FILL-POINTER
		    AS ELEM = (AREF AARRAY I)
		    DO (COND ((NOT (%STRING-EQUAL (AARRAY-ELEMENT-KEY ELEM) 0 STRING 0 NIL)))
			     (BOOLEAN-RESULT-P (RETURN-FROM AARRAY-LOOKUP ELEM))
			     ((OR (NULL PAIR) (EQ ELEM PAIR) ( TYPE %AARRAY-SORT-NORMAL))
			      (SETQ PAIR ELEM))
			     (T
			      (SETQ PAIR (CONS (AARRAY-ELEMENT-KEY PAIR)
					       (CL:UNION (IF (ATOM PAIR) (LIST PAIR)
							     (CDR PAIR))
							 (IF (ATOM ELEM) (LIST ELEM)
							     (CDR ELEM))
							 :TEST #'ZL:EQUAL)))))
		    FINALLY (RETURN PAIR)))))))))

;; This is the function which decides whether to sort an aarray passed to AARRAY-LOOKUP
;; before doing the lookup.  It tries to minimize string-compares.
;; Note that this doesn't consider the cost of page faults, so for large AARRAYs its
;; model may be insufficient.
(DEFUN AARRAY-LOOKUP-SORT-PREDICATE (MAX FILL-POINTER &OPTIONAL (NTIMES 1))
  ;; Catch some easy limiting cases without doing the math.
  (COND ((< NTIMES 2) NIL)
	((AND (> NTIMES 10) (< FILL-POINTER 1000)) T)
	(T (LET* ((LOG-MAX (HAULONG MAX))
		  ;; This is the cost of looking up n objects without sorting the aarray.
		  (UNSORTED-COST (* (+ LOG-MAX (- FILL-POINTER MAX)) NTIMES))
		  ;; This is the cost of sorting the aarray.  The MIN is because SORT-AARRAY
		  ;; chooses different sorting algorithms depending on the parameters.
		  (SORTING-COST (MIN (* 2 FILL-POINTER) (* (- FILL-POINTER MAX) LOG-MAX)))
		  ;; This estimates the lookup cost in the hypothetical sorted aarray.
		  ;; It is actually an upper bound, since duplicates may reduce the length
		  ;; of the aarray.
		  (SORTED-COST (* (HAULONG FILL-POINTER) NTIMES)))
	     ;; We now sort the aarray if it is the most efficient thing to do.
	     ( (+ SORTING-COST SORTED-COST) UNSORTED-COST)))))

;; This function declares that you are about to do the specified number of lookups
;; in the AARRAY.  It decides whether it is worth it or not to sort the aarray.
(DEFUN PREPARE-FOR-AARRAY-LOOKUPS (AARRAY N-LOOKUPS)
  (LET ((STATE (AARRAY-SORT-STATE AARRAY)))
    ;;--- Temporary compatibility kludge, remove for Rel 8
    (COND ((NULL STATE)
	   (SETF (AARRAY-SORT-STATE AARRAY)
		 (SETQ STATE 0)))
	  ((EQ STATE T)
	   (SETF (AARRAY-SORT-STATE AARRAY)
		 (SETQ STATE (FILL-POINTER AARRAY)))))
    ;;---
    (LET ((MAX (SORT-STATE-MAX STATE))
	  (FILL-POINTER (FILL-POINTER AARRAY)))
      (WHEN (AND (< MAX FILL-POINTER) ;cheap test
		 (AARRAY-LOOKUP-SORT-PREDICATE MAX FILL-POINTER N-LOOKUPS))
	(SORT-AARRAY AARRAY)))))

;;; Prepaging of AARRAYs.
;;; (This appears not to be as useful as I had hoped, mainly because of
;;; the overhead of gathering all the prepaging information.  But it's
;;; certainly better than no prepaging at all.)

;; This version does binary insertion into the page list, with a single-entry cache.
;; It's the fastest I have been able to come up with.  For an 18000 element aarray,
;; the nonpaging overhead is about 2.75 seconds, which is pretty good.
;; (I tried a version which used linear search and insertion using %BLOCK-SEARCH-EQ,
;; and it turned out to be much slower.)  (Inlining the INSERT function saves 
;; a negligible amount of time; it's not worth it.)
(DEFUN PREPAGE-AARRAY (AARRAY &OPTIONAL (START 0) (END NIL))
  (UNLESS END
    (SETQ END (FILL-POINTER AARRAY)))
  (LET ((AARRAY AARRAY)
	(LENGTH (- END START))
	(FILL-POINTER 0))
    (WHEN (> LENGTH 1000) (SETQ LENGTH 1000)) ;Don't abuse the data stack.
    (WITH-STACK-ARRAY (PAGES LENGTH)
      (DECLARE (ARRAY-REGISTER AARRAY))
      (FLET ((INSERT (PAGE PAGES FILL-POINTER)
	       (LET ((LOW 0)
		     (HIGH FILL-POINTER)
		     (PAGES PAGES))
		 (DECLARE (ARRAY-REGISTER PAGES))
		 (LOOP WHILE (> HIGH LOW)
		       AS PROBE = (LDB (BYTE 30 1) (+ HIGH LOW))	;FLOOR 2
		       AS ENTRY = (AREF PAGES PROBE)
		       WHEN (> ENTRY PAGE)
			 DO (SETQ HIGH PROBE)
		       ELSE WHEN (< ENTRY PAGE)
			      DO (SETQ LOW (1+ PROBE))
		       ELSE RETURN FILL-POINTER	; Already present in the table, just return.
		       FINALLY		; Not present in the table; needs to be inserted.
			 (LOOP FOR J DOWNFROM FILL-POINTER ABOVE HIGH
			       DO (SETF (AREF PAGES J) (AREF PAGES (1- J))))
			 (SETF (AREF PAGES HIGH) PAGE)
			 (RETURN (1+ FILL-POINTER))))))
	(PAGE-IN-ARRAY AARRAY START END NIL)
	(LOOP WITH LAST-PAGE = NIL
	      FOR I FROM START BELOW END
	      AS ELEM = (AREF AARRAY I)
	      WHEN (CL:CONSP ELEM)
		DO (LET ((PAGE (%LOGLDB %%VMA-PAGE-NUM (%POINTER ELEM))))
		     (UNLESS (EQL PAGE LAST-PAGE)
		       (SETQ LAST-PAGE PAGE)
		       (WHEN ( FILL-POINTER LENGTH)
			 (SETQ LENGTH (+ LENGTH 250)
			       PAGES (ADJUST-ARRAY-SIZE PAGES LENGTH)))
		       (SETQ FILL-POINTER (INSERT PAGE PAGES FILL-POINTER)))))
	(PAGE-IN-PAGES PAGES FILL-POINTER NIL T)
	(SETQ FILL-POINTER 0)
	(LOOP WITH LAST-PAGE = NIL
	      FOR I FROM START BELOW END
	      AS ELEM = (AREF AARRAY I)
	      WHEN ELEM
		DO (LET ((STRING (AARRAY-ELEMENT-KEY ELEM)))
		     (WHEN (ARRAYP STRING)
		       (LET ((PAGE (%LOGLDB %%VMA-PAGE-NUM (%POINTER STRING))))
			 (UNLESS (EQL PAGE LAST-PAGE)
			   (SETQ LAST-PAGE PAGE)
			   (WHEN ( FILL-POINTER LENGTH)
			     (SETQ LENGTH (+ LENGTH 250)
				   PAGES (ADJUST-ARRAY-SIZE PAGES LENGTH)))
			   (SETQ FILL-POINTER (INSERT PAGE PAGES FILL-POINTER)))))))
	(PAGE-IN-PAGES PAGES FILL-POINTER NIL T)))))

;; Internal function to PREPAGE-AARRAY.
;; (This could be in the paging system.)
(DEFUN PAGE-IN-PAGES (ARRAY LENGTH LOAD-MAP-ONLY-P NORMALIZE-P)
  (LET ((ARRAY ARRAY))
    (DECLARE (ARRAY-REGISTER ARRAY))
    ;; Prefetch the pages in blocks
    (LOOP WITH (START-PAGE END-PAGE)
	  FOR I BELOW LENGTH
	  AS PAGE = (AREF ARRAY I)
	  WHEN (EQL PAGE END-PAGE)
	    DO (INCF END-PAGE)
	  ELSE
	    DO (WHEN START-PAGE
		 (%FUNCALL-IN-AUX-STACK #'USER-PREFETCH-PAGES
		   (%LOGDPB START-PAGE %%VMA-PAGE-NUM 0)
		   (- END-PAGE START-PAGE) LOAD-MAP-ONLY-P NORMALIZE-P))
	       (SETQ START-PAGE PAGE END-PAGE (1+ PAGE))
	  FINALLY
	    (WHEN START-PAGE
	      (%FUNCALL-IN-AUX-STACK #'USER-PREFETCH-PAGES
		(%LOGDPB START-PAGE %%VMA-PAGE-NUM 0)
		(- END-PAGE START-PAGE) LOAD-MAP-ONLY-P NORMALIZE-P)))))

;; This shares strings as directed by the STRING-HASH-TABLE
;; It shares and copies lists referenced by the AARRAY (that is, function specs),
;; but it doesn't share the CDRs, so deletion still works.
;;--- This probably should be thought out a little more, and 
(DEFUN OPTIMIZE-AARRAY (AARRAY &OPTIONAL AREA HASH-TABLE)
  (DECLARE (VALUES AARRAY HASH-TABLE))
  (UNLESS HASH-TABLE
    (SETQ HASH-TABLE
	  (CL:MAKE-HASH-TABLE :SIZE (FILL-POINTER AARRAY)
			      :TEST #'CL:EQUAL
			      :NUMBER-OF-VALUES 0
			      :LOCKING NIL)))
  (LET ((AARRAY AARRAY))
    (DECLARE (ARRAY-REGISTER AARRAY))
    ;; Prepage the aarray.
    (PREPAGE-AARRAY AARRAY)
    ;; Sort the aarray.
    (SORT-AARRAY AARRAY)
    ;; Get rid of pointers beyond the end of the aarray.
    (LOOP FOR I FROM (FILL-POINTER AARRAY) BELOW (ARRAY-LENGTH AARRAY)
	  DO (SETF (AREF AARRAY I) NIL))
    ;; Now copy and share the lists and strings.
    (LABELS ((COMPACT (OBJECT)
	       (CL:TYPECASE OBJECT
		 (CL:(OR STRING CONS)
		  (MULTIPLE-VALUE-BIND (NIL FOUNDP SHARED-OBJECT)
		      (CL:GETHASH OBJECT HASH-TABLE)
		    (IF FOUNDP SHARED-OBJECT
			(SETF (CL:GETHASH OBJECT HASH-TABLE) OBJECT)
		      (WHEN (LISTP OBJECT)
			(LOOP FOR L = OBJECT THEN (CDR L) UNTIL (ATOM L)
			      AS X = (CAR L)
			      AS Y = (COMPACT X)
			      DO (UNLESS (EQ X Y)
				   (SETF (CAR L) Y))))
		      OBJECT)))
		 ((CL:SYMBOL)
		  ;; Don't copy, but enter any pnames we find.
		  (WHEN (SYMBOL-PACKAGE OBJECT)
		    (LET ((PNAME (GET-PNAME OBJECT)))
		      (MULTIPLE-VALUE-BIND (NIL FOUNDP)
			  (CL:GETHASH PNAME HASH-TABLE)
			(UNLESS FOUNDP
			  (SETF (CL:GETHASH PNAME HASH-TABLE) T)))))
		  OBJECT)
		 (OTHERWISE OBJECT))))
      (DOTIMES (I (FILL-POINTER AARRAY))
	(LET ((ELEM (AREF AARRAY I)))
	  (UNLESS (ATOM ELEM)
	    (SETF (AREF AARRAY I) (SETQ ELEM (COPYLIST ELEM AREA)))
	    ;; Share any lists and strings in the CDR
	    (IF (ATOM (CDR ELEM))
		(LET ((COMPACT (COMPACT (CDR ELEM))))
		  (WHEN (NEQ (CDR ELEM) COMPACT)
		    (SETF (CDR ELEM) COMPACT)))
		(DO ((SUBLIST (CDR ELEM) (CDR SUBLIST)))
		    ((ATOM (CDR SUBLIST))
		     (LET ((COMPACT (COMPACT (CAR SUBLIST))))
		       (WHEN (NEQ (CAR SUBLIST) COMPACT)
			 (SETF (CAR SUBLIST) COMPACT)))
		     (LET ((COMPACT (COMPACT (CDR SUBLIST))))
		       (WHEN (NEQ (CDR SUBLIST) COMPACT)
			 (SETF (CDR SUBLIST) COMPACT))))
		  (LET ((COMPACT (COMPACT (CAR SUBLIST))))
		    (WHEN (NEQ (CAR SUBLIST) COMPACT)
		      (SETF (CAR SUBLIST) COMPACT)))))
	    ;; Try to share string in the CAR
	    (MULTIPLE-VALUE-BIND (NIL FOUNDP SHARED-STRING)
		(CL:GETHASH (CAR ELEM) HASH-TABLE)
	      (IF FOUNDP
		  (WHEN (NEQ (CAR ELEM) SHARED-STRING)
		    (SETF (CAR ELEM) SHARED-STRING))
		  (SETF (CL:GETHASH (CAR ELEM) HASH-TABLE) T))))))
      (VALUES (FOLLOW-STRUCTURE-FORWARDING AARRAY)
	      HASH-TABLE))))


#||
;;; AARRAY insertion/deletion testing.

;;; Run this test with each half of MERGE-AARRAYS forced!
(DEFUN TEST-AARRAYS ()
  (LET ((A (MAKE-AARRAY 10))
	(PASSED T))

    (AARRAY-INSERT A "FOO" 'FOO)
    (AARRAY-INSERT A "BAR" 'BAR)
    (AARRAY-INSERT A "BAZ" 'BAZ)
    (AARRAY-INSERT A "BAR" 'BARFUCIOUS)
    (PRINT (G-L-P A))
    (SORT-AARRAY A)
    (UNLESS (AND (= (FILL-POINTER A) 3)
		 (= (AARRAY-SORT-MAX A) 3)
		 (EQUAL (AREF A 0) '("BAR" BARFUCIOUS BAR))
		 (EQUAL (AREF A 1) '("BAZ" BAZ))
		 (EQUAL (AREF A 2) '("FOO" FOO)))
      (SETQ PASSED NIL)
      (FORMAT T "~&Failed test 1:  ~S" (G-L-P A)))

    (AARRAY-INSERT A "BAR" '(BARN) T)
    (SORT-AARRAY A)
    (UNLESS (AND (= (FILL-POINTER A) 3)
		 (= (AARRAY-SORT-MAX A) 3)
		 (EQUAL (AREF A 0) '("BAR" BARN)))
      (SETQ PASSED NIL)
      (FORMAT T "~&Failed test 2:  ~S" (G-L-P A)))

    (SETF (AARRAY-SORT-MAX A) 0)
    (SETF (AARRAY-SORT-TYPE A) %AARRAY-SORT-NORMAL)
    (AARRAY-INSERT A "BAR" 'BAR)
    (SORT-AARRAY A)
    (UNLESS (AND (= (FILL-POINTER A) 3)
		 (= (AARRAY-SORT-MAX A) 3)
		 (EQUAL (AREF A 0) '("BAR" BAR BARN)))
      (SETQ PASSED NIL)
      (FORMAT T "~&Failed test 3:  ~S" (G-L-P A)))

    (SETF (AARRAY-SORT-MAX A) 0)
    (SETF (AARRAY-SORT-TYPE A) %AARRAY-SORT-WHOLE-CDR)
    (AARRAY-INSERT A "BAR" '(BARF) T)
    (SORT-AARRAY A)
    (UNLESS (AND (= (FILL-POINTER A) 3)
		 (= (AARRAY-SORT-MAX A) 3)
		 (EQUAL (AREF A 0) '("BAR" BARF)))
      (SETQ PASSED NIL)
      (FORMAT T "~&Failed test 4:  ~S" (G-L-P A)))

    (WHEN PASSED
      (FORMAT T "~&Passed."))
    (VALUES)))


||#

;; Spaces are obvious.  Dashes for chunkwise completion of symbol names.  Right
;; parenthesis for completion of method names.
(DEFVAR ZWEI:*COMPLETING-DELIMS* '(#\SP #/) #/-))

;;;Complete a given STRING from an ALIST of strings.  CHAR-POS is position in string to be
;;;relocated with new things inserted.  TRUNC says don't complete more than one chunk at end.
;;;Returns new STRING, matching subset of ALIST, COMPLETED-P if some completion was done,
;;;new CHAR-POS, and MAGIC-POS location of first point of ambiguity.  COMPLETED-P is 'NOSPACE
;;;if proper delimiter is already at end of string.
;;;For efficiency, if ALIST is an ART-Q-LIST array, it is assumed to be alphabetically
;;;sorted.  DONT-NEED-LIST says we really don't want all the possibilities, just not NIL.
(DEFUN ZWEI:COMPLETE-STRING (STRING ALIST DELIMS
			&OPTIONAL DONT-NEED-LIST CHAR-POS TRUNC IGNORE-RIGHT-SPACE
			&AUX NCHUNKS CHUNKS CHUNK-DELIMS FILLS CHAMB TEMS RETS
			     RCHUNKS TEM LEN COMPLETED-P CHAR-CHUNK CHAR-OFFSET MAGIC-POS
			     TAIL)
  (DECLARE (VALUES NEW-STRING SUBSET-OF-ALIST COMPLETED-P NEW-CHAR-POS LOCATION-OF-AMBIGUITY))
  #---IGNORE					;"heuristic" speedup --SWM
  (WHEN (AND (ARRAYP ALIST)			;must be a true aarray for this to win
	     (NULL (STRING-SEARCH-NOT-SET DELIMS STRING)))
    ;; If the string is composed entirely of chunk delimiters, then see if it is
    ;; in the aarray as is.  If so, we're done.  The possibly nasty side-effect of
    ;; this is that type † to a such string will not show all of the possibilities.
    ;; But them, do you really want to see them all?
    (LET ((POSSIBLE (SI:AARRAY-LOOKUP STRING ALIST)))
      (WHEN POSSIBLE
	(RETURN-FROM ZWEI:COMPLETE-STRING
	  (VALUES (FIRST POSSIBLE) (LIST POSSIBLE) T NIL NIL)))))
  ;; Both COMPLETE-STRING and COMPLETE-CHUNK-COMPARE depend on using the data-stack.
  ;; Fortunately, these don't really cons up too much (matching 240 items out of
  ;; 26,000 possibilities against a 4 chunk input conses about 2500 words on the
  ;; data-stack, which shouldn't cause it overflow).  This has the side-effect of
  ;; making this about 25% faster, too.
  (SYS:WITH-DATA-STACK
    (FLET ((STACK-SUBSTRING (STRING START END)
	     (WHEN (NULL END) (SETQ END (STRING-LENGTH STRING)))
	     (LET* ((LENGTH (- END START))
		    (NEW-STRING (SYS:MAKE-STACK-ARRAY LENGTH
						      :FILL-POINTER LENGTH
						      :TYPE (ARRAY-TYPE STRING)))
		    (STRING STRING))
	       (DECLARE (SYS:ARRAY-REGISTER STRING NEW-STRING))
	       (LOOP FOR I BELOW LENGTH
		     DOING (SETF (AREF NEW-STRING I) (AREF STRING (+ I START))))
	       NEW-STRING)))
      (SETQ CHUNKS (SYS:MAKE-STACK-ARRAY 20. :FILL-POINTER 0)
	    CHUNK-DELIMS (SYS:MAKE-STACK-ARRAY 20. :FILL-POINTER 0))
      (SETQ LEN (IF IGNORE-RIGHT-SPACE
		    (1+ (OR (STRING-REVERSE-SEARCH-NOT-CHAR #\SP STRING) -1))
		  (STRING-LENGTH STRING)))
      (DO ((I 0 (1+ I))
	   (J 0))
	  ((> I LEN))
	(COND ((COND ((= I LEN)
		      (SETQ TEM -1))		;Last character delimits a chunk
		     (T
		      (MEM #'CHAR-EQUAL (SETQ TEM (AREF STRING I)) DELIMS)))
	       (AND CHAR-POS (> CHAR-POS J)	;Keep track of relative position
		    (SETQ CHAR-CHUNK (ARRAY-LEADER CHUNKS 0)
			  CHAR-OFFSET (- CHAR-POS J)))
	       (ARRAY-PUSH-EXTEND CHUNKS (STACK-SUBSTRING STRING J I))
	       (ARRAY-PUSH-EXTEND CHUNK-DELIMS TEM)
	       (SETQ J I))))
      (SETQ NCHUNKS (ARRAY-ACTIVE-LENGTH CHUNKS)
	    FILLS (SYS:MAKE-STACK-ARRAY NCHUNKS)
	    TEMS (SYS:MAKE-STACK-ARRAY NCHUNKS)
	    RCHUNKS (SYS:MAKE-STACK-ARRAY NCHUNKS)
	    CHAMB (SYS:MAKE-STACK-ARRAY NCHUNKS :TYPE 'ART-1B))
      (AND (ARRAYP ALIST)
	   (MULTIPLE-VALUE (ALIST TAIL)
	     (ZWEI:COMPLETE-STRING-BOUNDS ALIST DELIMS NCHUNKS CHUNKS CHUNK-DELIMS)))
      (DO ((L ALIST (CDR L))
	   (ALL-AMBIG))
	  ((EQ L TAIL))
	(COND ((NLISTP L))			;Indirect through multiple alists
	      ((NULL (ZWEI:COMPLETE-CHUNK-COMPARE (SI:AARRAY-ELEMENT-KEY (CAR L))
					     DELIMS NCHUNKS CHUNKS CHUNK-DELIMS
					     TEMS (AND (NULL RETS) RCHUNKS)))
	       (OR RETS (SETQ CHUNKS RCHUNKS))	;First winner determines case of result
	       (PUSH (CAR L) RETS)		;add to list of partial matches
	       (SETQ ALL-AMBIG DONT-NEED-LIST)
	       (DO ((I 0 (1+ I))
		    (FILL))
		   (( I NCHUNKS))
		 (SETQ TEM (AREF TEMS I)
		       FILL (AREF FILLS I))
		 (COND ((NULL FILL)		;First one to complete a chunk
			(ASET TEM FILLS I)	;save for later ones
			(AND (PLUSP (STRING-LENGTH TEM))
			     (SETQ ALL-AMBIG NIL)))	;This chunk not ambiguous yet
		       (T
			(SETQ LEN (STRING-LENGTH FILL))
			(DO ((J 0 (1+ J))
			     (LEN1 (STRING-LENGTH TEM)))
			    (( J LEN)
			     (OR (ZEROP LEN)
				 (AND (= I (1- NCHUNKS))
				      (= LEN 1)
				      (MEM #'CHAR-EQUAL (AREF FILL 0) DELIMS))
				 (SETQ ALL-AMBIG NIL)))
			  (COND ((OR ( J LEN1)
				     (NOT (CHAR-EQUAL (AREF FILL J) (AREF TEM J))))
				 ;;Not the same completion, shorten final version
				 (ASET (STACK-SUBSTRING FILL 0 J) FILLS I)
				 (ASET 1 CHAMB I)	;Remember this was ambiguous
				 (OR (ZEROP J) (SETQ ALL-AMBIG NIL))
				 (RETURN NIL)))))))
	       ;;If not going to complete and dont need actual list, finish up now.
	       (AND ALL-AMBIG (NULL (AREF FILLS (1- NCHUNKS))) (RETURN NIL)))))
      (COND ((AND TRUNC (SETQ TEMS (AREF FILLS (1- NCHUNKS))))
	     (SETQ LEN (STRING-LENGTH TEMS))
	     (AND (ZEROP (AREF CHAMB (1- NCHUNKS)))	;If last chunk wasnt ambigous,
		  (SETQ TRUNC 'NOSPACE))	;shouldnt have delimiter there
	     (DO I 0 (1+ I) ( I LEN)
		 (COND ((MEM #'CHAR-EQUAL (AREF TEMS I) DELIMS)
			(ASET (STACK-SUBSTRING TEMS 0 (1+ I)) FILLS (1- NCHUNKS))
			(SETQ TRUNC 'NOSPACE)	;Already gave a delimiter
			(RETURN NIL))))))
      (SETQ TEMS "")
      (DO I 0 (1+ I) ( I NCHUNKS)
	  (AND CHAR-POS CHAR-CHUNK (= I CHAR-CHUNK)	;In case inside chunk not completed,
	       (SETQ CHAR-POS (+ (STRING-LENGTH TEMS) CHAR-OFFSET)))	;relocate
	  (SETQ TEMS (STRING-APPEND TEMS (AREF CHUNKS I)))
	  (COND ((AND (SETQ TEM (AREF FILLS I)) (> (STRING-LENGTH TEM) 0))
		 (SETQ TEMS (STRING-APPEND TEMS TEM)
		       COMPLETED-P T)
		 (AND CHAR-POS CHAR-CHUNK (= I CHAR-CHUNK)	;If inside completed chunk,
		      (SETQ CHAR-POS (STRING-LENGTH TEMS)))))	;move to end of it
	  (OR MAGIC-POS (ZEROP (AREF CHAMB I))	;Remember end of leftmost ambigous chunk
	      (SETQ MAGIC-POS (STRING-LENGTH TEMS))))
      (AND COMPLETED-P (EQ TRUNC 'NOSPACE)
	   (SETQ COMPLETED-P 'NOSPACE))
      (VALUES TEMS (NREVERSE RETS) COMPLETED-P CHAR-POS MAGIC-POS))))

;;;Compare a STR with the given chunks and return NIL if it is a possible completion,
;;;else LESS or GREATER according as it is less or greater than the CHUNKS.
;;;T is returned for the indeterminate case, for the sake of the binary search in the
;;;array case.  The actual completer only checks NULL.
;;--- Must be called inside SYS:WITH-DATA-STACK
(DEFUN ZWEI:COMPLETE-CHUNK-COMPARE (STR DELIMS NCHUNKS CHUNKS CHUNK-DELIMS &OPTIONAL TEMS RCHUNKS
			       &AUX LEN2)
  (FLET ((STACK-SUBSTRING (STRING START END)
	   (WHEN (NULL END) (SETQ END (STRING-LENGTH STRING)))
	   (LET* ((LENGTH (- END START))
		  (NEW-STRING (SYS:MAKE-STACK-ARRAY LENGTH
						    :FILL-POINTER LENGTH
						    :TYPE (ARRAY-TYPE STRING)))
		  (STRING STRING))
	     (DECLARE (SYS:ARRAY-REGISTER STRING NEW-STRING))
	     (LOOP FOR I BELOW LENGTH
		   DOING (SETF (AREF NEW-STRING I) (AREF STRING (+ I START))))
	     NEW-STRING)))
    (SETQ LEN2 (STRING-LENGTH STR))
    (DO ((I 0 (1+ I))
	 (J 0)
	 (K)
	 (LEN1)
	 (CHUNK)
	 (DELIM))
	(( I NCHUNKS) NIL)		;Aligns with each chunk, a winner
      (SETQ CHUNK (AREF CHUNKS I)
	    LEN1 (STRING-LENGTH CHUNK))
      (SETQ K (DO ((J1 0 (1+ J1))
		   (K1 J (1+ K1))
		   (CH1)
		   (CH2))
		  (( J1 LEN1) K1)
		(AND ( K1 LEN2) (RETURN 'LESS))
		(SETQ CH1 (AREF CHUNK J1)
		      CH2 (AREF STR K1))
		(COND ((CHAR-EQUAL CH1 CH2))
		      ((CHAR-LESSP CH1 CH2) (RETURN 'GREATER))
		      (T (RETURN 'LESS)))))
      (OR (NUMBERP K)
	  ;; If comparison of first chunk yields an ordering, return it.
	  ;; If later chunks don't match, just return T.
	  (RETURN (IF (ZEROP I) K T)))
      (AND RCHUNKS (ASET (STACK-SUBSTRING STR J K) RCHUNKS I))
      (COND ((AND (NUMBERP (SETQ DELIM (AREF CHUNK-DELIMS I)))	;yecch! array of chars and -1s
		  (MINUSP DELIM))
	     (SETQ J NIL))			;For the last chunk, use rest of string
	    ((AND (SETQ J (STRING-SEARCH-SET DELIMS STR K LEN2))
		  (CHAR-EQUAL DELIM (AREF STR J))))
	    (T (RETURN T)))			;Compare fails if can't find chunk when expected.
      (AND TEMS (ASET (STACK-SUBSTRING STR K J) TEMS I)))))

;;;Given an ART-Q-LIST array and the chunks to match, compute the subset of that array
;;;that could possibly be a completion of the string, and return an NTHCDR of the G-L-P
;;;and the appropriate tail to stop with.
;;--- Must be called inside SYS:WITH-DATA-STACK
(DEFUN ZWEI:COMPLETE-STRING-BOUNDS (AARRAY DELIMS NCHUNKS CHUNKS CHUNK-DELIMS &AUX LO HI HIHI ALEN)
  (SI:SORT-AARRAY AARRAY)
  (LET ((AARRAY AARRAY))
    (DECLARE (SYS:ARRAY-REGISTER AARRAY))
    (SETQ LO 0 HI 0
	  ALEN (ARRAY-ACTIVE-LENGTH AARRAY)
	  HIHI ALEN)
    (IF (ZEROP ALEN)
	(VALUES NIL NIL)
      (DO ((HILO HIHI)
	   (IDX)
	   (VAL T))
	  (NIL)
	(AND (ZEROP (SETQ IDX (// (- HILO LO) 2)))	;binary search
	     (RETURN NIL))
	(SETQ IDX (+ LO IDX))
	(SETQ VAL (ZWEI:COMPLETE-CHUNK-COMPARE (SI:AARRAY-ELEMENT-KEY (AREF AARRAY IDX)) DELIMS
					  NCHUNKS CHUNKS CHUNK-DELIMS))
	(COND ((EQ VAL 'LESS)
	       (SETQ LO IDX)
	       (SETQ HI IDX))
	      (T
	       (SETQ HILO IDX)
	       (COND ((NEQ VAL 'GREATER)
		      (SETQ HI IDX))
		     (T (SETQ HIHI IDX))))))
      (DO ((IDX)
	   (VAL))
	  (NIL)
	(AND (ZEROP (SETQ IDX (// (- HIHI HI) 2)))
	     (RETURN NIL))
	(SETQ IDX (+ HI IDX))
	(SETQ VAL (ZWEI:COMPLETE-CHUNK-COMPARE (SI:AARRAY-ELEMENT-KEY (AREF AARRAY IDX)) DELIMS
					  NCHUNKS CHUNKS CHUNK-DELIMS))
	(COND ((NEQ VAL 'GREATER)
	       (SETQ HI IDX))
	      (T (SETQ HIHI IDX))))
      ;; (SETQ AARRAY (G-L-P AARRAY))
      ;; (VALUES (NTHCDR LO AARRAY) (NTHCDR (1+ HI) AARRAY))
      ;; This is better because it doesn't page in the whole aarray to get the
      ;; sublist pointer.
      (VALUES (%MAKE-POINTER DTP-LIST (LOCF (AREF AARRAY LO)))
	      (IF (< (1+ HI) ALEN)
		  (%MAKE-POINTER DTP-LIST (LOCF (AREF AARRAY (1+ HI))))
		;; %MAKE-POINTER loses when it goes past the end of the array
		NIL)))))
