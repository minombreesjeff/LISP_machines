;; -*- Mode: LISP; Syntax: Common-Lisp; Package: COMMAND-PROCESSOR; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; validation, see also DEFS.

(defun validate-prompt-option (prompt)
  (or (null prompt)
      (stringp prompt)
      (functionp prompt)
      (and (listp prompt)
	   (or (stringp (car prompt))
	       (functionp (car prompt))))))

(defun validate-modes ()
  (validate-mode *dispatch-mode* *validate-dispatch-mode* *dispatch-modes*)
  (validate-mode *blank-line-mode* *validate-blank-line-mode* *blank-line-modes*)
  (unless (validate-prompt-option *prompt*)
    (reset-mode *prompt* *validate-prompt*)))

;; These three functions are called by the Lisp/Command loop.  These entrypoints should not be
;; called by other programs.

(defun command-loop-read-function ()
  (validate-modes)
  (read-command-or-form *standard-input*
			:dispatch-mode *dispatch-mode*
			:blank-line-mode *blank-line-mode*
			:prompt *prompt*))

;; *prompt* and *blank-line-mode* are not passed on to read-command-or-form since they
;; must be looked at before the input editor is invoked.

;;--- This should use a presentation type for read-or-character stuff
(defun command-loop-break-read-function ()
  (macrolet ((kludge-help (&body body)
	       `(si:with-input-editing-options
		    (((:complete-help :override)
		      (lambda (s)
			(declare (sys:downward-function))
			(dw::display-help s ""))))
		  (dw:with-accept-help
		      ((:top-level-help "You are being asked to enter a command or form.")
		       (:subhelp #'(lambda (s string)
				     (declare (sys:downward-function))
				     (let ((p-t
					     (dw::presentation-input-context-presentation-type
					       dw:*presentation-input-context*)))
				       (dw:with-type-decoded (type-name) p-t
					 (when (eq type-name 'si:input-editor)
					   ;; Magic knowledge of the type hierarchy here...
					   ;; Only doing this help when in si:input-editor
					   ;; context prevents getting the help twice after
					   ;; a ":" has been typed...
					   (maybe-show-command-name-subhelp
					     s string
					     :input-context-doesnt-matter t)))))))
		    ,@body))))
  (validate-modes)
  (si:with-input-editing-options
      ((:prompt *prompt*)
       (:rescan #'(lambda (char stream)
		    (declare (sys:downward-function))
		    (or (eql char #\Return)
			(si:read-or-character-activation-p char stream
							   si:*break-special-characters*)))
		*standard-input*))
    (dw:with-presentation-input-editor-context (*standard-input*
						 `((command-or-form
						     :command-table ,*command-table*
						     :dispatch-mode ,*dispatch-mode*)))
					       (blip start-loc)
	 (kludge-help
	   (si:read-or-character
	     si:*break-special-characters*
	     *standard-input*
	     #'(lambda (stream)
		 (read-command-or-form stream :dispatch-mode *dispatch-mode*))))
       (t (values (echo-and-return-command-or-form-blip blip start-loc)))))))

(defun echo-and-return-command-or-form-blip
       (blip &optional start-loc (input-type 'command-or-form))
  (flet ((echo-blip ()
	   (cond (start-loc
		  (dw:echo-presentation-blip *standard-input* blip start-loc input-type)
		  ;; And make the current input editor stand for that if nothing else.
		  (send *standard-input* :set-input-buffer-presentation
			(dw:presentation-blip-object blip)
			(dw:presentation-blip-presentation-type blip)))
		 (t
		  (fresh-line)
		  (present (dw:presentation-blip-object blip)
			   (dw:presentation-blip-presentation-type blip)
			   :for-context-type input-type)))))
    (dw:presentation-blip-ecase blip
      (cp:command
	(echo-blip)
	(fresh-line)
	(values (destructuring-bind (command . arguments) (dw:presentation-blip-object blip)
		  (turn-command-into-form command arguments))
		:command))
      ;; This was D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB")sys:expression0, but I think that was only to make up for other bugs.  --RWK
      (sys:form
	(echo-blip)
	(values (dw:presentation-blip-object blip) :form)))))

(defun command-loop-eval-function (form &optional environment)
  (dw::with-presentation-more-break-input-context
     ('command-or-form) (blip)
       (eval form environment)
     (t (throw 'si:command-loop-new-form
	  (echo-and-return-command-or-form-blip blip)))))

(defun command-loop-print-function (values)
  (dw::with-presentation-more-break-input-context
     ('command-or-form) (blip)
       (progn
	 (fresh-line)
	 (dolist (value values)
	   (funcall (or prin1 #'prin1) value)
	   (fresh-line)))
     (t (throw 'si:command-loop-new-form
	  (echo-and-return-command-or-form-blip blip)))))

(defun cp-on (&optional (dispatch-mode *dispatch-mode*)
	                (prompt-string nil prompt-supplied))
  (check-dispatch-mode-arg dispatch-mode)
  (unless prompt-supplied
    (setq prompt-string (cdr (assoc dispatch-mode *prompt-alist*))))
  (setq si:*command-loop-read-function* 'command-loop-read-function)
  (setq si:*command-loop-break-read-function* 'command-loop-break-read-function)
  (setq si:*command-loop-eval-function* 'command-loop-eval-function)
  (setq si:*command-loop-break-eval-function* 'command-loop-eval-function)
  (setq si:*command-loop-print-function* 'command-loop-print-function)
  (setq si:*command-loop-break-print-function* 'command-loop-print-function)
  (setq *dispatch-mode* dispatch-mode)
  (setq *prompt* prompt-string)
  (when prompt-supplied
    (rplacd (assoc dispatch-mode *prompt-alist*) prompt-string))
  t)

(defun (cp-on :undo-function) (ignore)
  ;; CP:CP-ON doesn't just enable the CP--it changes all kinds of state in a non-binary way.
  ;; The way to undo it is not to call CP:CP-OFF, but rather to remember the settings of all
  ;; the state variables. -kmp 28-Sep-89
  `(progn ,@(mapcar #'(lambda (var) `(setq ,var ',(symbol-value var)))
		    '(si:*command-loop-read-function*
		       si:*command-loop-break-read-function*
		       si:*command-loop-eval-function*
		       si:*command-loop-break-eval-function*
		       si:*command-loop-print-function*
		       si:*command-loop-break-print-function*
		       *dispatch-mode*
		       *prompt*))
	  (setq *prompt-alist* ',(copy-alist *prompt-alist*))))

(defun cp-off ()
  (setq si:*command-loop-read-function* 'si:read-form)
  (setq si:*command-loop-break-read-function* 'si:command-loop-break-read-function)
  (setq si:*command-loop-eval-function* 'eval)
  (setq si:*command-loop-break-eval-function* 'eval)
  (setq si:*command-loop-print-function* 'si:command-loop-print-function)
  (setq si:*command-loop-break-print-function* 'si:command-loop-print-function)
  t)


;;; The follow are conversion and compatability tools for turning old
;;; DEFINE-CP-COMMAND forms into new-syntax ones.

;;; old-style arg-spec looks like:
;;; (file (:pathname :pathname-default (fs:parse-pathname "Y:>doughty>foo.bar"))
;;;       :allow-multiple t
;;;       :prompt "Foo"
;;;       :default (fs:parse-pathname "wally"))

(defparameter *old-style-cp-argument-types* nil)

(defmacro define-cp-arg-type-converter (type &body body)
  `(progn (pushnew ',type *old-style-cp-argument-types*)
	  (defun (,type converter-function) (type)
	    (ignore type)
	    ,@body)))

;;; Simple ones
(define-cp-arg-type-converter :boolean 'boolean)
(define-cp-arg-type-converter :string 'string)
(define-cp-arg-type-converter :date 'time:universal-time)

;;; Really need to hack this up, as we've got to accept :All, Local, and None.
;;; I don't want to have to define NEW presentation types just for old-cp support.
(define-cp-arg-type-converter :host
  '((token-or-type (:all ("None" . nil)) net:host)))

;;; A little more complicated
(define-cp-arg-type-converter :enumeration
  (destructuring-bind (ignore &rest enumeration-set)
		      type
    `((member ,@enumeration-set))))

(define-cp-arg-type-converter :number
  (cond ((eq type :number) 'number)
	(t
	 (destructuring-bind (ignore &rest number-options)
			     type
	   `((number) ,@number-options)))))

(define-cp-arg-type-converter :integer
  (cond ((eq type :integer) 'integer)
	(t (block convert-integer
	     (destructuring-bind (ignore &rest integer-options &key base from to)
				 type
	       (when (null integer-options) (return-from convert-integer 'integer))
	       (unless (or from to)
		 (return-from convert-integer `((integer) ,@(when base `(:base ,base)))))
	       (unless from
		 (setq from most-negative-fixnum))
	       (when to (setq to (ncons to)))
	       `((integer ,from ,@to) ,@(when base `(:base ,base))))))))

(define-cp-arg-type-converter :printer
  (cond ((eq type :printer) 'sys:printer)
	(t
	 ;; I can NOT believe that :ALL-ALLOWED is allowed to not have
	 ;; a value.  Damn!
	 (destructuring-bind (ignore &rest options)
			     type
	   (let ((all-allowed (member :all-allowed options)))
	   (cond ((and all-allowed
		       (if (cdr all-allowed)
			   (car (cdr all-allowed))
			   t))
		  `((token-or-type (:All) sys:printer)))
		 (t 'sys:printer)))))))

;;; We can't easily hack known-only without an extension to the SYS:FONT presentation-type.
;;; "BFD..."
(define-cp-arg-type-converter :font
  (cond ((eq type :font) 'sys:font)
	(t
	 (block convert-font
	   (let ((return-type 'sys:font))
	     (let* ((font-options (cdr type))
		    (known-only (member :known-only font-options))
		    (or-default (member :or-default font-options))
		    (lop (member :loaded-only font-options))
		    (loaded-only (when lop
				   (cadr lop))))
	       (ignore known-only)
	       (when (null font-options) (return-from convert-font return-type))
	       (when lop
		 (setq return-type `((sys:font :loaded-only ,loaded-only))))
	       (cond (or-default
		      `((token-or-type (:default-font)
				       ,return-type)))
		     (t return-type))))))))

(define-cp-arg-type-converter :package
  (cond ((eq type :package) 'package)
	(t
	 (destructuring-bind (ignore &rest options)
			     type
	   (let ((all-allowed (member :all-allowed options)))
	     (cond ((and all-allowed
			 (if (cdr all-allowed)
			     (car (cdr all-allowed))
			     t))
		    `((token-or-type (:All) package)))
		   (t 'package)))))))

;;; YECCH!
(define-cp-arg-type-converter :make-system-version
  (destructuring-bind (ignore &rest type-specific-information)
		      type
    (let ((numbers-allowed (null (member :no-number type-specific-information))))
      (setq type-specific-information
	    (delete :no-number type-specific-information))
      `((or ((member ,@type-specific-information))
	    ,@(if numbers-allowed '(((integer 0))) nil)
	    string)))))

;;; Obviously, need to add :patchable-only to the SYSTEM presentation-type.
(define-cp-arg-type-converter :system
  (cond ((eq type :system) '((scl:type-or-string sct:system)))
	(t
	 (destructuring-bind (ignore &rest stuff)
	    type
	   (cond ((member :loaded-only stuff)
		  `((token-or-type (:All) sct:system)))
		 (t 'sct:system))))))

;;; We can't completely hack :pathname-default here.  Hmm.
(define-cp-arg-type-converter :fep-pathname
  (cond ((eq type :fep-pathname)
	 'fs:fep-pathname)
	(t
	 (let ((special-tokens nil)
	       (return-type nil)
	       (default-version nil)
	       (raw nil))
	   (destructuring-bind (ignore &rest keywords)
			       type
	     (when (member :raw keywords) (setq raw t)
	       (setq keywords (delete :raw keywords)))
	     (when (member :or-none keywords) (push :none special-tokens))
	     (when (member :or-no keywords) (push :no special-tokens))
	     (when (member :or-query keywords) (push :query special-tokens))
	     (when (member :default-version keywords)
	       (setq default-version (cadr (member :default-version keywords))))
	     (setq return-type
		   (cond ((or default-version raw)
			  `((fs:fep-pathname) ,@(when default-version `(:default-version ,default-version))
			    ,@(when raw `(:dont-merge-default t))))
			 (t 'fs:fep-pathname)))
	     (cond (special-tokens
		    `((token-or-type (,@special-tokens) ,return-type)))
		   (t return-type)))))))

;;; We can't completely hack :pathname-default here.  Hmm.
(define-cp-arg-type-converter :pathname
  (cond ((eq type :pathname) 'fs:pathname)
	(t
	 (let ((special-tokens nil)
	       (return-type nil)
	       (default-version nil)
	       (raw nil))
	   (destructuring-bind (ignore &rest keywords)
			       type
	     (when (member :raw keywords) (setq raw t)
	       (setq keywords (delete :raw keywords)))
	     (when (member :or-none keywords) (push :none special-tokens))
	     (when (member :or-no keywords) (push :no special-tokens))
	     (when (member :or-query keywords) (push :query special-tokens))
	     (when (member :default-version keywords)
	       (setq default-version (cadr (member :default-version keywords))))
	     (setq return-type
		   (cond ((or default-version raw)
			  `((fs:pathname)
			    ,@(when default-version `(:default-version ,default-version))
			    ,@(when raw `(:dont-merge-default t))))
			 (t 'fs:pathname)))
	     (cond (special-tokens
		    `((token-or-type (,@special-tokens) ,return-type)))
		   (t return-type)))))))

(defun convert-old-style-cp-arg-type (type)
  (let* ((real-type (if (listp type) (car type) type))
	 (converter-function (get real-type 'converter-function)))
    (if converter-function
	(funcall converter-function type)
	type)))

(defun convert-old-style-cp-argument-spec (spec &optional (warn t))
  (multiple-value-bind (new-spec type new-type default-p prompt-p others)
      (convert-old-style-cp-argument-spec-internal spec)
    (when warn
      (cond ((keywordp new-type)
	     (compiler:warn '(:obsolete t)
			    "(For command argument ~S)  The argument type ~S is unrecognized.
Find a suitable presentation type to use instead."
			    (car new-spec) type))
	    ((neq new-type type)
	     (compiler:warn '(:obsolete t)
			    "(For command argument ~S)  The syntax for specifying cp command args has changed.
~S should be rewritten as ~S."
			    (car new-spec) type new-type)))
      (when default-p
	(compiler:warn '(:bad-style t)
		       "(For command argument ~S)  :DEFAULT NIL now supplies a default value of NIL.
To suppress the default, use :PROVIDE-DEFAULT NIL." (car new-spec)))
      (when others
	(compiler:warn '(:obsolete t)
		       "(For command argument ~S)  The keyword~P ~A ~:[is~;are~] obsolete and will be ignored.
Your code will probably continue to work but you should convert it by
following the recommendations in the Release Notes." (car new-spec)
		       (length others)
		       (cond (( (length others) 2)
			      (with-output-to-string (*standard-output*)
				(format-textual-list others #'prin1 :finally " and ")))
			     (t (format nil "~S" (car others))))
		       (> (length others) 1)))
      
      (when prompt-p
	(compiler:warn '(:obsolete t)
		       "(Also for arg ~S)  A prompt containing a reference to =DEFAULT= was
specified: ~S.  ~%Since ACCEPT prints the default in the prompt, the prompt has been removed."
		       (car new-spec) prompt-p)))
    new-spec))

(defun convert-old-style-cp-argument-spec-internal (spec)
  (destructuring-bind (variable type &rest options)
		      spec
    (let ((new-type (convert-old-style-cp-arg-type type))
	  (provide-default t)
	  (default nil)
	  (default-p nil)
	  (prompt-p)
	  (others nil)
	  (provide-provide-default-clause nil))
      (when (getf options :allow-multiple)
	(setq new-type `((sequence ,new-type)))
	(setq options (si:rem-keywords options '(:allow-multiple))))
      (when (member :default options)
	(setq default (getf options :default))
	;; warn about uses of :DEFAULT as a flag that prohibited defaulting
	(when (null default)
	  (setq default-p t)			; print warning
	  ;; prohibit defaulting in call to accept
	  (setq provide-provide-default-clause t)
	  (setq provide-default nil)))
      (when (member :use-type-default options)
	;; For now, we'll just assume that :use-type-default is never specified
	;; with any other :DEFAULT-like keywords.  This was prohibited by the
	;; old command definer.
	(setq options (si:rem-keywords options '(:use-type-default)))
	(push ':use-type-default others)
	(setq provide-provide-default-clause nil))
      (when (member :set-type-default options)
	;; For now, we'll just assume that :set-type-default is never specified
	;; with any other :DEFAULT-like keywords.  This was prohibited by the
	;; old command definer.
	(setq options (si:rem-keywords options '(:set-type-default)))
	(push ':set-type-default others))

      ;; Horribly heuristicating kludge.
      (let ((prompt (getf options :prompt))
	    (found-=default= nil))
	(when (and (listp prompt)			;i.e., the prompt is a function to call
		   (progn
		     (lt:mapforms #'(lambda (form &rest ignored)
				      (when (and (symbolp form)
						 (string-equal (symbol-name form) "=default="))
					(setq found-=default= t))) prompt)
		     found-=default=))
	  ;; Assume that the ONLY reason ANYONE would use =default= is if she were
	  ;; trying to simulate what ACCEPT does now.  Just punt and remove the prompt
	  ;; altogether, but warn user.
	  (setq prompt-p prompt)
	  ;; Try to hack the common case nicely
	  (cond ((stringp (caddr prompt))
		 (let (([-index (string-search " [" (caddr prompt))))
		   (if [-index
		       (setf (getf options :prompt)
			     (substring (caddr prompt) 0 [-index))
		       (setq options (si:rem-keywords options '(:prompt))))))
		(t (setq options (si:rem-keywords options '(:prompt)))))))

      ;;       This quote  is the SWM quote
      (values `(,variable ',new-type
		,@options
		,@(when provide-provide-default-clause
		    `(:provide-default ,provide-default)))
	      type
	      `',new-type
	      default-p
	      prompt-p
	      others))))

(defun old-style-cp-argument-spec-p (spec)
  ;; Don't blow out on malformed DEFINE-CP-COMMANDs
  (when (and (listp spec) ( (length spec) 2))
    (destructuring-bind (ignore type &rest options)
			spec
      (ignore options)
      (old-style-cp-argument-type-p type))))

(defun old-style-cp-argument-type-p (type)
  (let ((real-type (if (listp type) (car type) type)))
    (cond ((not (null (member real-type *old-style-cp-argument-types*)))
	   t)
	  ((keywordp real-type)
	   (compiler:warn '(:fatal t) "~S is invalid as a presentation-type and is unrecognized as an old-style
cp argument type." real-type)))))


;;; New command processor implementation, based on presentation-type
;;; technology.

;;; Slow but effective
(defmacro collect-into (thing place)
  `(setf ,place (nconc ,place (ncons ,thing))))

;;; Command definition macros.

(zl:defvar-standard *parsing-mode* :parse)	;:parse, :parse-for-effect, :unparse, :unparse-acceptably, or :skip
(defvar *pending-parsed-arguments* nil)		;When in :unparse or :skip mode
(defvar *last-command-values* nil
  "List of values returned by the execution of the last CP command")
(zl:defvar-standard *inhibit-echo* nil)		;NIL, T, or :RESCAN
						;:RESCAN means we've already tried
						;inhibiting echoing and failed
(zl:defvar-standard *read-initial-delimiter* t)

;;; Teach the editor how to find the function spec.  This is the same code that
;;; is used for defselect.
(defun (:property define-command zwei:definition-function-spec-finder) (bp)
  (and (setq bp (zwei:forward-over zwei:*whitespace-chars* bp))
       (if (char-equal (zwei:bp-char bp) #\open-parenthesis)
	   (zwei:forward-list bp 1 nil -1 t)
	   bp)))

(defprop define-command undefine-command zwei:kill-definition)
(defun undefine-command (command-name)
  ;; The command name is the function.
  (delete-command-symbol-from-all-command-tables command-name)
  (remhash command-name *command-descriptors*)
  (fundefine command-name))

(defprop define-command "Command" si:definition-type-name)

;;; More or less compatible with existing define-cp-command, but with
;;; presentation types.
;;; This doesn't need record-source-file-name, because define-command-and-parser records
;;; as definition type define-command.
(defmacro define-command (name-and-options arguments &body body)
  (declare (zwei:indentation 1 3 2 2))
  (let ((compiler:default-warning-function (decode-cp-name-and-options name-and-options))
	(compiler:default-warning-definition-type 'define-command))
    (multiple-value-bind (arglist parser extra-forms)
	(expand-cp-arguments name-and-options arguments)
      `(progn
	 (define-command-and-parser ,name-and-options ,arglist
	   ,parser
	   . ,body)
	 . ,extra-forms))))

;; --- Rel 6 compatibility.
(deff zl:define-cp-command 'define-command)
(defprop zl:define-cp-command define-command zwei:definition-function-spec-type)

(zwei:defindentation (zl:define-cp-command 1 3 2 2))

(defun check-for-invalid-cp-options (arg-name arg-type options key-p)
  ;; --- I guess that this needs a real code-walk looking for constant values
  (destructuring-bind (&key default-type &allow-other-keys)
			options
      (dw:check-presentation-type-argument arg-type)
      (when default-type
	(dw:check-presentation-type-argument default-type)))
  ;; didn't include the following keywords allowed by accept:
  ;; :stream :activation-chars :additional-activation-chars :blip-chars
  ;; :additional-blip-chars :inherit-context :present-default :history
  ;; :prompts-in-line :initially-display-possibilities :input-sensitizer
  ;; :handler-type :query-identifier
  (let* ((valid-options
	       '(:documentation :prompt :prompt-mode :default
				:name :when
				:default-type :provide-default :display-default
				:confirm))
	 (options-only-valid-for-keyword-args '(:mentioned-default))
	 (invalid-options 
	   (loop for (key) on options by #'cddr
		 unless (or (member key valid-options)
			    (and key-p
				 (member key options-only-valid-for-keyword-args)))
		   collect key)))
    (when invalid-options
      (compiler:warn '(:fatal t)
		     "(For command argument ~S)  The option~P ~A ~:[are~;is~] unrecognized.
Valid options are ~A."
		     arg-name
		     (length invalid-options)
		     (with-output-to-string (s)
		       (format-textual-list invalid-options #'prin1
					    :stream s
					    :conjunction "and"))
		     (= (length invalid-options) 1)
		     (with-output-to-string (s)
		       (format-textual-list valid-options #'prin1
					    :stream s :conjunction "and"))))))

;;; extra-forms would be keyboard or mouse accelerator assignments, etc.
(defun decode-cp-name-and-options (name-and-options)
  (declare (values (command-name options extra-forms)))
  (if (atom name-and-options)
      name-and-options
      (values (first name-and-options)
	      (rest name-and-options))))

(defvar *valid-command-options* '(:name :command-table
				  :explicit-arglist
				  :explicit-parser-body-p
				  :provide-output-destination-keyword
				  :values))

(defun warn-about-unknown-command-options (options)
  (let ((ct (getf options :comtab)))
    (when ct
      (warn "The option ~S has been replaced by ~S." :comtab :command-table)
      (remf options :comtab)
      (setf (getf options :command-table) ct)))
  (loop for (option nil) on options by #'cddr
	unless (member option *valid-command-options*)
	  do (compiler:warn '(:fatal t)
			    "The option ~S is unrecognized.
Valid command options are ~A." option
			    (with-output-to-string (s)
			      (format-textual-list *valid-command-options* #'prin1
						   :stream s :conjunction "and"))))
  options)

;;; a quadruple of indicator, default-value, keyword-clause, and arglist-spec
;;; if you change this, you should also change *VALID-COMMAND-OPTIONS*
(defvar *extra-cp-keyword-info*
	'(
	  (:provide-output-destination-keyword
	    t
	    (.output-destination.
	      'destination :name "Output-Destination"
	      :documentation "Redirects typeout done by this command to the specified streams")
	    ((:output-destination .output-destination.))
	    (.more-processing.
	      '((dw:alist-member :alist (("Default" :value :default)
					 ("Yes" :value t)
					 ("No" :value nil))))
	      :name "More-Processing"
	      :default :default
	      :documentation "Whether to pause at end of page on interactive streams")
	    ((:more-processing .more-processing.) :default)
	    )
	  ))

(defun convert-cp-keyword-to-keyword-clause (keyword)
  (let ((info (assoc keyword *extra-cp-keyword-info*)))
    (unless info (error "~S invalid keyword in a command specifier." keyword))
    (loop for (keyword-clause arglist-spec) on (cddr info) by 'cddr
	  do (ignore arglist-spec)
	  collect keyword-clause)))

(defun convert-cp-keyword-to-arglist-spec (keyword)
  (let ((info (assoc keyword *extra-cp-keyword-info*)))
    (unless info (error "~S invalid keyword in a command specifier." keyword))
    (loop for (keyword-clause arglist-spec) on (cddr info) by 'cddr
	  do (ignore keyword-clause)
	  collect arglist-spec)))

(defun extra-cp-keywords (options)
  (loop for (possible-keyword-indicator default-value nil) in *extra-cp-keyword-info*
	when (if (member possible-keyword-indicator options)
		 (cadr (member possible-keyword-indicator options))
		 default-value)
	  collect possible-keyword-indicator))

(defun add-cp-options-to-arglist (arglist options)
  (let ((extra-cp-keywords (extra-cp-keywords options)))
    (when extra-cp-keywords
      (when (not (member '&key arglist))
	(setq arglist (append arglist '(&key))))
      (setq arglist (append arglist
			    (loop for extra-keyword in extra-cp-keywords
				  appending (convert-cp-keyword-to-arglist-spec
					       extra-keyword)))))
    (values arglist extra-cp-keywords)))

;;; name-and-options only for error reporting
;;; extra-forms would be mouse assignments based on arguments.
(defun expand-cp-arguments (name-and-options arguments)
  (declare (values (arglist parser extra-forms)))
  (let ((arg-name-list nil)
	(arglist nil)
	(optional-clauses nil)
	(keyword-clauses nil)
	(optional-template nil)
	(collecting-template t)
	)
    (let ((key-p nil))
      (loop for (arg-form . nil) on arguments doing
	(if (atom arg-form)
	    ;; &key is the only lambda-list-keyword allowed
	    (cond ((eq arg-form '&key)
		   (setq key-p t)
		   (collect-into '&key arglist))
		  (t
		   (let ((command-name (decode-cp-name-and-options name-and-options)))
		     (if (member arg-form lambda-list-keywords)
			 (compiler:warn '(:fatal t)
					"~S is illegal in command argument list for ~S."
					arg-form command-name)
			 (compiler:warn '(:fatal t)
					"~S unrecognized command argument form for ~S."
					arg-form command-name)))))
	    ;; --- compatibility kludge
	    (when (old-style-cp-argument-spec-p arg-form)
	      (let* ((command-name (decode-cp-name-and-options name-and-options))
		     (compiler:default-warning-function command-name))
		(setq arg-form (convert-old-style-cp-argument-spec arg-form t))))
	    ;;decode one arg
	    (destructuring-bind (arg-name presentation-type
					  &key default name WHEN
					  &rest options &allow-other-keys)
				arg-form
	      (let* ((command-name (decode-cp-name-and-options name-and-options))
		     (compiler:default-warning-function command-name))
		(check-for-invalid-cp-options arg-name presentation-type options key-p))
	      ;; collect its chunk of the lambda list for the command function
	      (cond ((not key-p)
		     ;; Collect arg-variable and default value into arglist
		     (collect-into `(,arg-name ,default) arglist)
		     (collect-into arg-name arg-name-list)
		     ;; Optimize the common case where all the arguments are of constant
		     ;; presentation type, with constant accept options.
		     (when collecting-template
		       (if (or when (not (every #'compiler:constant-form-p (rest arg-form))))
			   (setq collecting-template nil)
			   (collect-into (cons (first arg-form)
					       (map 'list #'compiler:constant-evaluator
						    (rest arg-form)))	;type+options
					 optional-template)))
		     ;; collect a LET clause that binds the arg name to the result of
		     ;; parsing for the given type
		     (collect-into (if when
				       `(when ,when
					  (assign-argument-value
					    ,arg-name
					    (read-command-argument 
					      ,presentation-type
					      :query-identifier ',arg-name
					      . ,(si:rem-keywords options '(:when)))))
				       `(assign-argument-value
					  ,arg-name
					  (read-command-argument ,presentation-type
								 :query-identifier
								 ',arg-name
								 . ,options)))
				   optional-clauses))
		    (t
		     ;; If someone used :name for a keyword arg, then
		     ;; convert into CL format for specifying a keyword to use
		     (cond (name
			    (collect-into `((,(intern (string-upcase name) 'keyword)
					     ,arg-name)
					    ,default)
					  arglist))
			   (t (collect-into `(,arg-name ,default) arglist)))
		     (collect-into `(,arg-name ,presentation-type . ,options)
				   keyword-clauses)))))))
    (when (and arglist (neq (first arglist) '&key))
      (push '&optional arglist))
    (values (si:eliminate-duplicates arglist #'(lambda (x y) (or (eq x y)
								 (and (listp x) (listp y)
								      (eq (car x) (car y))))))
	    `(progn
	       ,@(if collecting-template
		     (and optional-template
			  `((assign-template-argument-values
			      ,(map 'list #'car optional-template)
			      ,optional-template)))
		     optional-clauses)
	       (read-keyword-arguments . ,keyword-clauses))
	    )))

(define-presentation-type 1unread-cp-argument0 ((&optional arg-name))
   :parser ((stream)
	    (ignore stream)
	    (error "Attempting to use the argument ~S before it has been read.
In this case, this probably means that somewhere in your command definition
you used ~:*~S when you meant '~:*~S." arg-name)))

(defun unread-argument-p (thing)
  (and (listp thing)
       (eq (first thing) 'unread-cp-argument)))

;;; Use this interface if you need more complicated parsing, such as
;;; type depending on earlier arguments or conditional parsing.
(defmacro define-command-and-parser (name-and-options arglist parser &body body)
  (declare (zwei:indentation . 2))		; for gprint formatting
  (multiple-value-bind (command-name options extra-forms)
      (decode-cp-name-and-options name-and-options)
    (let ((compiler:default-warning-function command-name)
	  (compiler:default-warning-definition-type 'define-command))
      (setq options (warn-about-unknown-command-options options)))
    (let* ((values (getf options :values))
	   extra-cp-keywords
	   provide-output-destination-keyword
	   (explicit-arglist (getf options :explicit-arglist))
	   (explicit-parser-body-p (getf options :explicit-parser-body-p)))
      (let ((name (getf options :name)))
	(when name
	  (unless (stringp name)
	    (compiler:warn
	      '(:fatal t)
	      "~S is invalid as a :NAME option.  The :NAME option must be a string."
	      name))))
      ;; Eliminate options that define-command-internal won't want
      (setq options (si:rem-keywords options '(:explicit-arglist :explicit-parser-body-p)))
      (multiple-value-setq (arglist extra-cp-keywords)
	(add-cp-options-to-arglist arglist options))
      (setq provide-output-destination-keyword
	    (when (member :provide-output-destination-keyword extra-cp-keywords)
	      t))
	`(progn
	   (define-command-load-time ',command-name . ,(zwei:some-plist options
									'(:name
									  :command-table)))
	   (defun ,command-name ,(if explicit-arglist explicit-arglist arglist)
	     (declare (sys:function-parent ,command-name define-command))
	     (setq *last-command-values*
		   (multiple-value-list
		     (block ,command-name
		       . ,(if provide-output-destination-keyword
			      `((with-standard-output-and-more-processing-bound
				  .output-destination.
				  .more-processing.
				  ,@body))
			      body))))
	     ,@(if (null values) '((values)) '((values-list *last-command-values*))))
	   (defun (command-parser-function ,command-name) (argument-parser)
	     (declare (sys:function-parent ,command-name define-command))
	     ,(if explicit-parser-body-p
		  parser
		  (write-parser-body parser arglist extra-cp-keywords)))
	   . ,extra-forms))))

(defun write-parser-body (parser arglist &optional extra-cp-keywords)
  (multiple-value-bind (let-clauses variables required-variables)
      (loop for element in arglist
	    with optional-flag = nil
	    with let-clauses
	    with required-variables
	    until (member element '(&key &rest))
	    when (eq element '&optional)
	      do
		(setq optional-flag t)
	    unless (eq element '&optional)
	      do
		(cond ((listp element)
		       (collect-into `(,(first element)
				       '(unread-cp-argument ,(first element)))
				     let-clauses))
		      (t (collect-into `(,element
					 '(unread-cp-argument ,element))
				       let-clauses)
			 ;; Only have to create checking clauses later for
			 ;; required arguments.
			 (unless optional-flag
			   (collect-into element required-variables))))
	    unless (eq element '&optional)
	      collect
		(cond ((listp element)
		       (first element))
		      (t element)) into variables
	    finally (return (values let-clauses variables required-variables)))
    `(let* (,@let-clauses)
       (let ((.keyword-arguments. 
	       (call-with-standard-read-command-argument
		 (lambda (read-command-argument-function keyword-parser-function
			  template-parser-function)
		   (ignore read-command-argument-function keyword-parser-function
			   template-parser-function)
		   (macrolet ((read-command-argument (&rest args)
				`(funcall read-command-argument-function . ,args))
			      (assign-argument-value (arg-name value)
				`(setq ,arg-name ,value))
			      (assign-template-argument-values (arg-names template)
				`(multiple-value-setq ,arg-names
				   (funcall template-parser-function ',template)))
			      (read-keyword-arguments (&body clauses)
				`(parse-keyword-arguments
				   (keyword-parser-function ,',extra-cp-keywords)
				   ,@clauses)))
		     (catch 'done-parsing
		       ,parser)
		     ,@(loop for variable in required-variables
			     collecting
			       `(when (unread-argument-p ,variable)
				  (error "The parser for this command never read the command argument ~A." ',variable)))))
		 argument-parser)))
	 (list* ,@variables .keyword-arguments.)))))

(defun call-with-standard-read-command-argument (function argument-parser)
  (declare (sys:downward-funarg function)
	   (values keyword-arguments))
  (let ((keyword-arguments nil))
    (labels ((read-command-argument (presentation-type &rest options)
	       ;; Need to clear the input context so that, say,
	       ;; pathnames are sensitive as pathnames rather
	       ;; than as :Show File <pathname>
	       ;; NOTE: only clear the context when actually reading arguments
	       ;; from the keyboard.  Don't clear it when unparsing a command
	       ;; to get a doc string, etc., 'cause it will screw up sensitivity.
	       (when (eq *parsing-mode* :parse)
		 (dw:clear-presentation-input-context))
	       ;; Try to catch the simple cases
	       (when (unread-argument-p (getf options :default))
		 (error
		   "The parser for this command tried to read ~:[an argument~;the argument ~:*~A~] 
  whose default depends upon ~A, an argument that has not yet been read."
		   (getf options :query-identifier)
		   (second (getf options :default))))
	       (apply argument-parser
		      presentation-type
		      options))
	     (keyword-parser (presentation-type &rest args)
	       (let ((thing (apply #'read-command-argument presentation-type args)))
		 (collect-into thing keyword-arguments)
		 thing))
	     (template-parser (template)
	       (values-list
		 (loop for (arg-name presentation-type . options) in template
		       collect (apply #'read-command-argument presentation-type
				      :query-identifier arg-name
				      options)))))
      (funcall function #'read-command-argument #'keyword-parser #'template-parser))
    keyword-arguments))


;;; Command structure

(defvar *command-descriptors* (make-hash-table))

(defsubst command-name-command-descriptor-internal (command-name)
  (gethash command-name *command-descriptors*))

(defun map-over-command-descriptors (function)
  (declare (sys:downward-funarg function))
  (maphash (lambda (ignore descriptor) (funcall function descriptor))
	   *command-descriptors*))

(define-presentation-type defined-command-name ()
   :description "a defined command name"
   :parser ((stream &key initially-display-possibilities type)
	    (dw:completing-from-suggestions (stream :type type
						    :partial-completers '(#\Space)
						    :initially-display-possibilities
						    initially-display-possibilities)
	      (map-over-command-descriptors
		(lambda (x) (dw:suggest (command-pretty-name x))))))
   :printer ((object stream &key acceptably)
	     (when acceptably (prin1 object stream) (princ object stream))))

(defun command-name-command-descriptor (command-name &key (if-does-not-exist :error))
  (or (command-name-command-descriptor-internal command-name)
      (ecase if-does-not-exist
	((nil) nil)
	((:error) (error "There is no command processor command named ~S." command-name)))))

(defstruct (command-descriptor :named-array
		    (:print-function (lambda (command stream ignore)
					 (si:printing-random-object
					   (command stream :typep)
					   (write (command-pretty-name command)
						  :stream stream))))
		    (:conc-name "COMMAND-"))
  name
  pretty-name
  parser-function
  (command-table nil))				;Atom or list

(defun generate-command-pretty-name (command-symbol)
  (string-capitalize-words
    (cond ((string-equal command-symbol "COM-" :end1 4)
	   (substring command-symbol 4))
	  (t command-symbol))))

;;; For compatibility with old .BIN files.

(sys:define-derived-function-type command-parser command-parser)

(defun define-command-internal (command-name
				&key name command-table comtab
				&allow-other-keys)
  (when (and comtab command-table)
    (error ":COMMAND-TABLE and :COMTAB were both specified.  ~
:COMTAB is obsolete.  Use :COMMAND-TABLE"))
  (when comtab
    (setq command-table comtab))

  (define-command-load-time command-name :name name :command-table command-table
			    :record-source-file-name nil)
  (let ((def (fdefinition `(command-parser ,command-name))))
    ;; I think this might be necessary to make who-calls happy.
    (when (typep def 'compiled-function)
      (let ((name (first (sys:cca-extra-info (sys:compiled-function-cca def)))))
	;; Since we are destructively modifying the function name, it may become
	;; a duplicate in the definitions database.  So, remove it, the fdefine will
	;; put in what we want.
	(let ((entry (assoc 'defun si:fdefine-file-definitions)))
	  (when entry (setf (cdr entry) (delete name (cdr entry)))))
	(setf (first name) 'command-parser-function)))
    (fdefine `(command-parser-function ,command-name) def))
  (remprop command-name 'command-parser))

;;; End compatibility

(sys:define-function-spec-handler command-parser-function
				  (operation function-spec &optional arg1 arg2)
  (case operation
    (sys:validate-function-spec
      (case (length function-spec)
	((2) (symbolp (second function-spec)))))
    (definition-has-location-p t)
    ((fdefinition fdefinedp sys:fdefinition-location)
     (let* ((command (command-name-command-descriptor (second function-spec)
						      :if-does-not-exist nil))
	    (location (and command (locf (command-parser-function command)))))
       (ecase operation
	 (fdefinition
	   (and location (location-contents location)))
	 (fdefinedp
	   (and location (not (null (location-contents location)))))
	 (sys:fdefinition-location
	   location))))
    ((fdefine fundefine)
     (let* ((command (command-name-command-descriptor (second function-spec)))
	    (location (locf (command-parser-function command))))
       (ecase operation
	 (fdefine
	   (setf (location-contents location) arg1))
	 (fundefine
	   (setf (location-contents location) nil)))))
    (otherwise
      (si:function-spec-default-handler operation function-spec arg1 arg2))))

(defun define-command-load-time (command-name &key name command-table
						   (record-source-file-name t))
  (when record-source-file-name
    (record-source-file-name command-name 'define-command))
  (unless name
    (setq name (generate-command-pretty-name command-name)))
  (let ((command (command-name-command-descriptor-internal command-name)))
    (if command
	;; Don't clobber which command tables it's in.
	(setf (command-pretty-name command) name
	      (command-parser-function command) nil)
      (setq command (make-command-descriptor :name command-name :pretty-name name))
      (setf (command-name-command-descriptor-internal command-name) command))
    (when command-table
      (flet ((install (command-table)
	       (command-table-install-command (find-command-table command-table)
					      command-name)))
	(if (listp command-table)
	    (mapcar #'install command-table)
	    (install command-table))))))


;;; Destination-hacking code
(define-presentation-type destination ((&key (direction :output)))
   :parser
     ((stream &key original-type)
      (let ((ptype (case direction
		     (:output
		       `((sequence
			   ((cased-subtype
			      ("File" fs:pathname
			       :prompt "file"
			       :documentation "The pathname of a file.  If the file exists, it will be appended to.")
			      ("Buffer" ((zwei:buffer) :create-p t)
			       :when (and (get 'zwei:buffer 'sys:flavor)
					  (not zwei:*zmacs-needs-initialization*))
			       :default nil
			       :documentation "An editor buffer.  If the buffer exists, it will be appended to.")
			      ("Kill ring" ((member :kill-ring))
			       :documentation "The top of the kill ring.")
			      ("Window" tv:sheet
			       :default nil)
			      ("Stream" named-stream
			       :documentation "A symbol naming a stream (e.g. CL:*STANDARD-OUTPUT*).")
			      ("Printer" sys:printer
			       :when (variable-boundp #'hardcopy:make-hardcopy-stream)
			       :default hardcopy:*default-text-printer*)
			      ("None" ((member :none))
			       :documentation "Discard the output"))
			    :keyword-description "a destination"))))
		     (:input
		       `((sequence
			   ((cased-subtype
			      ("File" (and fs:pathname
					   (satisfies (lambda (pathname)
							(and (not (send pathname :wild-p))
							     (zl:probef pathname)))))
			       :prompt "file"
			       :documentation "The pathname of a file.  The file must exist.")
			      ("Buffer" zwei:buffer
			       :when (and (get 'zwei:buffer 'sys:flavor)
					  (not zwei:*zmacs-needs-initialization*))
			       :documentation "An editor buffer.  The buffer must exist.")
			      ("Window" tv:sheet)
			      ("Stream" named-stream
			       :documentation "A symbol naming a stream (e.g. CL:*STANDARD-INPUT*)."))
			    :keyword-description "a source")))))))
	(values (accept ptype :stream stream)
		original-type)))
   :describer ((stream)
	       (case direction
		 (:output (write-string "a destination" stream))
		 (:input (write-string "a source" stream))))
   :printer ((things stream)
	     (formatting-textual-list (stream)
	       (loop for destination in things
		     doing
		 (formatting-textual-list-element (stream)
		   (write-string
		     (typecase destination
		       (pathname "File")
		       (zwei:buffer "Buffer")
		       (tv:sheet "Window")
		       (hci::printer "Printer")
		       (stream "Stream")
		       ((member :kill-ring) "Kill ring")
		       ((member :none) "None"))
		     stream)
		   (unless (keywordp destination)
		     (write-char #\Space stream)
		     (present destination (type-of destination) :stream stream)))))))

(defun cased-subtype-toplevel-help (stream description)
  (cond (description
	 (format stream
		 "~@(~A~) is composed of two fields separated by a space.  " description))
	(t (format stream
		   "You are being asked to enter two fields separated by a space.  "))))

(defun cased-subtype-first-field-help (stream description)
  (format stream
	  "You are currently entering the first field~@[ of ~A~].  
This is a qualifying name that will be used to determine what kind of object you will be
prompted for in the second field.  The table below shows the possible qualifying names
and the type of object you will be prompted for after typing each qualifying name."
	  description))

(defun cased-subtype-second-field-help (stream cs-desc type)
  (format stream
	  "You are currently entering the second field~@[ of ~A~].
You are being asked to enter " cs-desc)
  (dw:describe-presentation-type type stream)
  (write-char #\. stream))

;;; A pattern for a cased-subtype looks like:
;;; (name type &rest accept-keyword-args &key documentation)
;;; Documentation defaults to (describe-presentation-type type)
;;; Each of the accept-keyword-args will be evaluated before passed off to ACCEPT,
;;; allowing you to do specify things like :default *default-text-printer*.
(define-presentation-type cased-subtype ((&rest patterns) &key keyword-description)
   :parser ((stream)
	    (dw:with-accept-help ((:subhelp
				    (lambda (stream ignored)
				      (cased-subtype-toplevel-help
					stream keyword-description))))
	      (let* ((menu-choose (loop for (keyword type . stuff) in patterns
					as documentation =
					   (or
					     (getf stuff :documentation)
					     (format nil "~@(~A.~)"
						     (with-output-to-string (s)
						       (dw:describe-presentation-type
							 type
							 s))))
					unless (let ((when (getf stuff :when)))
						 (and when (not (eval when))))
					collect
					  `(,keyword
					    :value ,keyword
					    :documentation ,documentation)))
		     (choice (dw:with-accept-help
				 ((:subhelp (lambda (stream ignored)
					      (cased-subtype-first-field-help
						stream keyword-description))))
			       (accept `((dw:menu-choose :alist ,menu-choose)
					 ,@(if keyword-description
					       `(:description
						  ,keyword-description)
					       ()))
				       :stream stream
				       :additional-blip-chars '(#\space)
				       :prompt nil)))
		   (choice-pattern (assoc choice patterns)))
	      (destructuring-bind (ignored type &rest additional-accept-keyword-args)
		 choice-pattern
		(if (and (consp type)
			 (consp (car type)) (eql (caar type) 'member)
			 (null (cddar type)))
		    (cadar type)
		  (setq additional-accept-keyword-args
			(si:rem-keywords additional-accept-keyword-args '(:documentation
									  :when)))
		  (let ((delim (dw:read-char-for-accept stream)))
		    (unless (dw:compare-char-for-accept delim #\space)
		      (dw:unread-char-for-accept delim stream)
		      (cp-error t "You must supply ~A"
				(with-output-to-string (*standard-output*)
				  (dw:describe-presentation-type type))))
		    (unless type
		      (error "Invalid pattern supplied for cased-subtype"))
		    (dw::with-accept-help ((:subhelp (lambda (stream ignored)
						       (cased-subtype-second-field-help
							 stream keyword-description
							 type))))
		      (let ((form-to-eval
			      `(accept ',type :stream ',stream ;:prompt nil
				       ,@additional-accept-keyword-args)))
			;; I hate having to call EVAL inside a program.
			(eval form-to-eval))))))))))

;		    (apply #'accept type :stream stream :prompt nil)
	    
(defun named-stream-p (symbol)
  (and (boundp symbol)
       (streamp (eval symbol))))

;;; Well, for the time being.
;;; We recognize that this is a crock

(define-presentation-type named-stream ()
   :parser ((stream)
	    (let ((symbol
		    (accept '((and sys:symbol
				   ((satisfies named-stream-p)))
			      :description "a symbol naming a stream")
			    :prompt nil :stream stream)))
	      ;; Just in case
	      (si:follow-syn-stream
		(symbol-value symbol))))

   :description "a symbol naming a stream")

(defflavor simple-hardcopy-stream (stream) ()
  :no-vanilla-flavor
  :initable-instance-variables
  (:constructor make-simple-hardcopy-stream (stream)))

(defmethod (:unclaimed-message simple-hardcopy-stream) (op &rest args)
  (condition-bind ((hardcopy:hardcopy-outside-of-bounding-box
		     #'hardcopy:simple-formatter-exception-interceptor))
    (lexpr-send stream op args)))

(defmethod (:operation-handled-p simple-hardcopy-stream) (op)
  (send stream :operation-handled-p op))

(defmethod (:which-operations simple-hardcopy-stream) ()
  (send stream :which-operations))

(defmethod (:send-if-handles simple-hardcopy-stream) (op &rest args)
  (condition-bind ((hardcopy:hardcopy-outside-of-bounding-box
		     #'hardcopy:simple-formatter-exception-interceptor))
    (lexpr-send stream :send-if-handles op args)))

(defmethod (:describe simple-hardcopy-stream) ()
  (describe stream))

(defmethod (sys:print-self simple-hardcopy-stream) (str print-depth slashify-p)
  (sys:print-self stream str print-depth slashify-p))

(defmethod (get-handler-for simple-hardcopy-stream) (operation)
  (get-handler-for stream operation))

(compile-flavor-methods simple-hardcopy-stream)

(defun open-destination-stream (destination &key (direction :output))
  (ecase direction
    (:output
      (etypecase destination
	(si:stream destination)
	(function destination)
	(fs:pathname
	  (open destination :direction :output
		:if-exists :append :if-does-not-exist :create))
	(zwei:buffer
	  (zwei:open-interval-stream
	    (zwei:interval-last-bp destination)
	    (zwei:interval-last-bp destination)
	    t))
	(hci:hardcopy-device-mixin
	  (make-simple-hardcopy-stream (hardcopy:make-hardcopy-stream destination)))
	((member :kill-ring)
	 (zwei:open-kill-ring-stream))
	((member :none)
	 'sys:null-stream)))
    (:input
      (etypecase destination
	(si:stream destination)
	(function destination)
	(fs:pathname
	  (open destination :direction :input))
	(zwei:buffer
	  (zwei:open-interval-stream
	    (zwei:interval-first-bp destination)
	    (zwei:interval-last-bp destination)))))))

;;; Destinations will be a list of destinations.
;;; Probably need better error checking and reporting here.
(defmacro with-standard-output-bound (destinations &body body)
  `(with-standard-output-bound-internal
     ,destinations
     (lambda ()
       ,@body)))

(defun with-standard-output-bound-internal (destinations continuation)
  (if destinations
      (let ((.streams.
	      (loop for destination in (remove-duplicates destinations)
		    collecting
		      (open-destination-stream destination)))
	    (.stream-abort-flag. ':abort))
	(with-open-stream (*standard-output*
			    (if (null (rest .streams.))
				(first .streams.)
				(apply #'make-broadcast-stream .streams.)))
	  (unwind-protect (multiple-value-prog1 (funcall continuation)
			    (setq .stream-abort-flag. nil))
	    (loop for stream in .streams. do
	      (si:close-open-stream stream .stream-abort-flag.)))))
      (funcall continuation)))

(defmacro with-standard-output-and-more-processing-bound (destinations more-processing
							  &body body)
  `(with-more-processing-bound ,more-processing
			       (lambda () (with-standard-output-bound ,destinations ,@body))))

(defun with-more-processing-bound (more-processing continuation)
  (declare (sys:downward-funarg continuation))
  (let ((tv:more-processing-global-enable
	  (ecase more-processing
	    ((:default) tv:more-processing-global-enable)
	    ((t) t)
	    ((nil) nil))))
    (funcall continuation)))


;;; Command and argument readers.

(defgeneric arg-terminated-p (&optional (stream *standard-input*)
					(chars *arg-terminators*))
  (:method-arglist (chars))
  (:function (if (and (instancep stream)
		      (operation-handled-p stream 'arg-terminated-p))
		 (funcall (flavor:generic arg-terminated-p) stream chars)
		 (default-arg-terminated-p stream chars))))

;; This function looks at the delimiter that terminated the last arg and
;; returns T if it is a valid arg terminator.
(defun default-arg-terminated-p (stream chars)
  (case *parsing-mode*
    ((:parse :parse-for-effect)
     (let ((char (dw:peek-char-for-accept stream)))
       (not (null (member char chars :test #'dw:compare-char-for-accept)))))
    (otherwise t)))

(defun command-table-inherits-from (table1 table2)
  "Returns true if table1 inherits commands from table2, otherwise NIL."
  (block found
    (map-over-command-table-inheritance 
      table1
      (lambda (supertable1)
	(when (eq supertable1 table2) (return-from found t))))
    nil))

(define-presentation-type command-name ((&key (command-table *command-table* command-table-p))
					&key (complete-activates nil))
   :description "a command name"

   :key-function ((function type-name)
		  (if (not command-table-p)
		      (funcall function type-name)
		    (stack-let ((key `(,type-name ,(find-command-table command-table))))
		      (funcall function key))))
   :with-cache-key ((function type-name)
		    (if (not command-table-p)
			(funcall function type-name)
		      (stack-let ((key `(,type-name ,(find-command-table command-table))))
			(funcall function key))))
   :with-full-cache-key
     ((function &key type do-not-cache)
      (dw:with-type-decoded (type-name) type
	(if (and (not command-table-p) (not complete-activates))
	    (funcall function type-name do-not-cache)
	  (if command-table-p
	      (stack-let* ((table (or (find-command-table command-table
							  :if-does-not-exist nil)
				      (progn (setq do-not-cache t)
					     command-table)))
			   (data-key `(,type-name ,table)))
		(if (not complete-activates)
		    (funcall function data-key do-not-cache)
		  (stack-let ((key `(,data-key t)))
		    (funcall function key do-not-cache))))))))

   :typep ((name)
	   (or (not command-table-p)
	       (if (stringp name)
		   (command-table-lookup-command command-table name)
		 (command-in-command-table-p (if (atom name) name (car name))
					     command-table nil))))

   :presentation-subtypep
     ((type1 type2)
      (dw:with-presentation-type-arguments (command-name type1)
	(let ((table1 (find-command-table command-table)))
	  (dw:with-presentation-type-arguments (command-name type2)
	    (let ((table2 (find-command-table command-table)))
	      (values (command-table-inherits-from table2 table1) t))))))

   :parser ((stream &key initially-display-possibilities type)
	    (setq command-table (find-command-table command-table))
	    (let ((delimiters (command-table-command-table-delims command-table)))
	      (dw::with-command-token-completion-caches (string-cache completion-bounds-table)
		(values
		  (dw:complete-input stream
				     #'(lambda (string action)
					 (declare (sys:downward-function))
					 (command-table-complete
					   string-cache completion-bounds-table delimiters
					   string command-table action))
				     :partial-completers *command-name-partial-completers*
				     :allow-any-input nil
				     :type type
				     :complete-activates complete-activates
				     :initially-display-possibilities
				      initially-display-possibilities)))))
   :printer ((command-name stream)
	     (multiple-value-bind (found name)
		 (command-in-command-table-p command-name command-table)
	       (unless found
		 (setq name (command-pretty-name
			      (command-name-command-descriptor command-name))))
	       (write-string name stream))))

(define-presentation-type command ((&key (command-table *command-table* command-table-p))
				   &key (wait-for-activation t))
   :history nil
   :description "a command"

   :key-function ((function type-name)
		  (if (not command-table-p)
		      (funcall function type-name)
		    (stack-let ((key `(,type-name ,(find-command-table command-table))))
		      (funcall function key))))
   :with-cache-key ((function type-name)
		    (if (not command-table-p)
			(funcall function type-name)
		      (stack-let ((key `(,type-name ,(find-command-table command-table))))
			(funcall function key))))
   :with-full-cache-key
     ((function &key type do-not-cache)
      (dw:with-type-decoded (type-name) type
	(if (not command-table-p)
	    (if wait-for-activation
		(funcall function type-name do-not-cache)
		(stack-let ((key `(,type-name nil)))
		  (funcall function key do-not-cache)))
	    (stack-let* ((table (or (find-command-table command-table
							:if-does-not-exist nil)
				    (progn (setq do-not-cache t)
					   command-table)))
			 (data-key `(,type-name ,table)))
	      (if wait-for-activation
		  (funcall function data-key do-not-cache)
		  (stack-let ((key `(,data-key nil)))
		    (funcall function key do-not-cache)))))))

   :typep ((command)
	   (or (not command-table-p)
	       (and command
		    (command-in-command-table-p (if (atom command) command (car command))
						command-table nil))))

   :presentation-subtypep
     ((type1 type2)
      (dw:with-presentation-type-arguments (command type1)
	(let ((table1 (find-command-table command-table)))
	  (dw:with-presentation-type-arguments (command type2)
	    (let ((table2 (find-command-table command-table)))
	      (values (command-table-inherits-from table2 table1) t))))))

   :parser ((stream)
	    (setq command-table (find-command-table command-table))
	    (let ((command-name (let ((type `((command-name :command-table ,command-table)
					      :complete-activates t)))
				  (block blip-name
				    (let ((char (dw:with-presentation-input-context
						   (type :stream stream)
						   (blip)
						     (dw::with-accept-blip-chars
						       (*command-name-terminators*)
						       (dw:peek-char-for-accept stream t))
						   (t (dw:echo-presentation-blip
							stream blip)
						      (return-from blip-name
							(dw:presentation-blip-object blip))
						      ))))
				      (when (member char *command-dispatchers*
						    :test #'dw:compare-char-for-accept)
					(dw:read-char-for-accept stream)))
				    (accept type
					    :prompt nil
					    :additional-blip-chars *command-name-terminators*
					    :additional-activation-chars *command-previewers*
					    :stream stream))))
		  (arguments nil))
	      (let ((char (dw:peek-char-for-accept stream)))
		(when (member char *command-name-completers*
			      :test #'dw:compare-char-for-accept)
		  (dw:read-char-for-accept stream)
		  (let ((loc (send stream :read-location)))
		    (dw::presentation-replace-input stream loc
						    (first *command-name-terminators*)
						    :dont-quote t)
		    (send stream :set-location loc)))
		(cond ((member char *command-previewers*
			       :test #'dw:compare-char-for-accept)
		       (dw::presentation-replace-input stream
						       (send stream :read-location)
						       (first *command-name-terminators*)
						       :dont-quote t)
		       (setq arguments (preview-arguments stream command-name)))
		      ((not NIL
			    #||
			    ;;+++ Does this test screw up :confirm?
			    (or (member char *command-terminators*
					:test #'dw:compare-char-for-accept)
				(member char *line-terminators*
					:test #'dw:compare-char-for-accept))
			    ||#)
		       ;; Read the arguments for that command
		       (setq arguments
			     (accept `((command-arguments :command-name ,command-name)
				       :wait-for-activation ,wait-for-activation)
				     :prompt nil
				     :additional-blip-chars *arg-terminators*
				     :stream stream)))))
	      (values (cons command-name arguments)
		      `((command :command-table ,command-table)))))

   :printer ((command stream &key acceptably for-context-type)
	     (ignore wait-for-activation)
	     
	     (when (and (eq acceptably :very)
			(eq (dw:presentation-type-name for-context-type) 'command-or-form)
			(dw:with-presentation-type-arguments (command-or-form for-context-type)
			  (eq dispatch-mode :form-preferred)))
	       (write-char (first *command-dispatchers*) stream))
	     
	     (destructuring-bind (command-name . arguments) command
	       (present command-name `((command-name :command-table ,command-table))
			:stream stream :acceptably acceptably)
	       (when arguments
		 (write-char (first *command-name-terminators*) stream)
		 (present arguments `((command-arguments :command-name ,command-name)
				      :wait-for-activation nil)
			  :stream stream :acceptably acceptably)))))

(define-presentation-translator reexecute-command-hacking-arguments
   (command command
    :gesture :select-and-edit
    :tester ((command)
	     (command-in-command-table-p (first command) *command-table* nil))
    :do-not-compose t
    :documentation "Re-execute command after modifying arguments")
   (command &key presentation)
  (let* ((name (first command))
	 (pretty-name (multiple-value-bind (nil pretty-name)
			  (command-in-command-table-p name *command-table*)
			pretty-name))
	 (new-arguments (choose-command-arguments
			  name
			  :prompt (format nil "Modify arguments for ~A" pretty-name)
			  :initial-arguments (cdr command)
			  :start 0
			  :stream *query-io*))
	 (new-command `(,name ,@new-arguments)))
    (values new-command (dw:presentation-type presentation))))

(define-presentation-type command-arguments ((&key command-name
						   (initial-arguments nil))
					     &key (wait-for-activation t)
					     (read-initial-delimiter t))
   :parser ((stream &key type)
	    (dw:with-accept-help ((:top-level-help
				    #'(lambda (stream ignore cmd-name)
					(declare (sys:downward-function))
					(format stream
						"No additional arguments are allowed for the ~
					     ~@\\presentation\\ command.~
					     ~%Use Return or End to activate this command."
						cmd-name 'command-name))
				    command-name))
	      (let ((start-loc (send stream :read-location))
		    (delimiter (if read-initial-delimiter (dw:peek-char-for-accept stream)))
		    (arguments
		      (let-if initial-arguments
			      ((*parsing-mode* :skip)
			       (*pending-parsed-arguments* initial-arguments))
			(let-if (not read-initial-delimiter)
				((*read-initial-delimiter* nil))
			  (let ((dw::*object-to-sequence-of-object-activate-p* t))
			    (dw::with-accept-activation-chars (*command-previewers*)
			      (parse-command-arguments command-name stream)))))))
		(when wait-for-activation
		  ;; always leave final delimiter for caller
		  ;; but only exit when that delimiter ends commands
		  (loop for char = (dw:read-char-for-accept stream)
			for first-time = t then nil
			when (member char *command-previewers*
				     :test #'dw:compare-char-for-accept)
			  do (setq arguments (preview-arguments stream command-name
								arguments
								start-loc type delimiter))
			     (return)
			until (or (null char)
				  (member char *command-terminators*
					  :test #'dw:compare-char-for-accept)
				  (member char *line-terminators*
					  :test #'dw:compare-char-for-accept)
				  ;; I admit, this is a kludge.  See echo-presentation-blip.
				  (and (consp char)
				       (eq (first char) :activation)
				       (consp (second char))
				       (dw:presentation-blip-p (second char))))
			finally nil		; (dw:unread-char-for-accept char stream)
			  ;; allow for the delimiter that terminated the last arg
			unless first-time
			  do (zl:parse-ferror "No additional arguments are allowed.")))
		arguments)))
   
   :printer ((arguments stream &key acceptably)
	     (ignore wait-for-activation read-initial-delimiter)
	     ;; Dynamic binding of *parsing-mode* to :unparse causes the
	     ;; parser to run in reverse, calling present instead of accept.
	     (let ((*parsing-mode* (if acceptably :unparse-acceptably :unparse))
		   (*pending-parsed-arguments* (remove-if #'unread-argument-p
							  (append initial-arguments
								  arguments))))
	       (parse-command-arguments command-name stream))))

;;; Make command-names sensitive at top-level.
(define-presentation-translator command-name-to-command
   (command-name command)
   (command-name)
  (values
    `(,command-name) 'command :activate nil :dont-quote t :suffix " "))


;;; Also try to make ellipses do the "right thing" in command-or-form context.
;;; This code is yanked almost verbatim from completion.lisp.
(define-presentation-action expand-command-name-ellipsis
   (dw::ellipsis command
    :tester ((ignore &key presentation)
	     (dw:with-presentation-type-arguments (dw::ellipsis
						    (dw:presentation-type presentation))
	       (dw:presentation-subtypep dw::object-type 'command-name)))
    :documentation "Expand ellipsis")
   (ellipsis &key presentation window)
  (dw::expand-ellipsis ellipsis :presentation presentation :window window))

;;; Also copy code that expands a command-name ellipsis.  Does NOT activate
;;; the resulting command-name, though.
(define-presentation-translator command-name-ellipsis-menu
   (dw::ellipsis command
    :tester ((ignore &key presentation)
	     (dw:with-presentation-type-arguments
	         (dw::ellipsis (dw:presentation-type presentation))
	       (dw:presentation-subtypep dw::object-type 'command-name)))
    :documentation "Menu of expansions"
    :gesture :menu
    :do-not-compose t
    :context-independent nil)
   (ignore &key presentation)
  (let ((p-t (dw:presentation-type presentation))
	(string (dw:presentation-object presentation)))
    (dw:with-presentation-type-arguments (dw::ellipsis p-t)
      ;; This does not require the same kludge that ELLIPSIS-MENU does 
      ;; because we cannot possibly have an AARRAY-COMPLETION in the act.
      (let ((expansion
	      (dw:menu-choose
		dw::expansions
		:prompt (format nil "Completions of \"~A\""
			  (substring string 0
				     (string-search "..." string))))))
	(when expansion
	  (values (ncons expansion) 'command
		  :activate nil))))))

(defun preview-arguments (stream command-name
			  &optional (initial-arguments nil)
				    (start-loc (send stream :read-location))
				    (type `((command-arguments :command-name ,command-name))) delimiter)
  (when (net:remote-terminal-p stream)
    ;; AVV will try to ask the questions one per line, which isn't any better.
    (sys:parse-error "Preview mode does not work from a remote terminal.
Just input the arguments from the command line."))
  (let ((arguments (let ((help-stream (si:input-editor-flag :help-stream)))
		     (when (and help-stream
				(or (eq (si:follow-syn-stream help-stream)
					(si:follow-syn-stream stream))
				    (not (send-if-handles help-stream :typeout-window-p))))
		       (setq help-stream nil))
		     (si:with-ie-typein (stream nil :erase t)
		       (let ((dw::*accept-active* nil))
			 (choose-command-arguments
			   command-name
			   :prompt-mode :own-window
			   :initial-arguments initial-arguments
			   :start 0
			   :stream stream
			   :typeout-stream help-stream)))))
	(string ))
    (setq string (present-to-string arguments type :acceptably t))
    (when (listp delimiter) (setq delimiter (second delimiter)))
    (when delimiter (setq string (string-append delimiter string)))
    (send stream :replace-input-since start-loc string)
    arguments))

;;; Always leaves the last delimiter for the caller to process.
(defun parse-command-arguments (command-name *standard-input*)
  (unwind-protect
      (labels ((parser (presentation-type &rest args)
		 (apply #'normal-arg-parser presentation-type args)))
	(let ((read-loc
		;; Don't blow out when presenting something as a command.
		(when (member *parsing-mode* '(:parse :parse-for-effect))
		  (send-if-handles *standard-input* :read-location)))
	      (values))
	  (prog ()
	     a (setq values 
		     (multiple-value-list
		       (catch 'rescan-to-real-stream
			 (condition-bind-if (send *standard-input* :interactive)
			   (((zl:sys:parse-ferror dw::input-not-of-required-type)
			     ;; If we get an expected error we want to force rescanning.
			    #'(lambda (error)
				(ignore error)
				(when (and *inhibit-echo*
					   (neq *inhibit-echo* :rescan))
				  (throw 'rescan-to-real-stream 'rescan-to-real-stream)))))
			   ;;+++ Compatibility code for two-arg version of command parser
			   ;;removed, since 7.0 was shipped after it was already in the
			   ;;new format.
			   ;; Call the parser that was built at command definition time.
			   (catch 'done-parsing
			     (funcall (fdefinition `(command-parser-function ,command-name))
				      #'parser))))))
		;; I'm not great at designing flow of control.  Anyway,
		;; if 'rescan-to-real-stream was returned (i.e., someone
		;; did (throw 'r-t-r-s 'r-t-r-s), we want to back up
		;; and try again with output going to the console
		(cond ((eq (car values) 'rescan-to-real-stream)
		       (send *standard-input* :set-location read-loc)
		       ;; This magic setting means that we've already tried
		       ;; inhibiting echoing and failed
		       (setq *inhibit-echo* :rescan)
		       (go a))
		      (t (return (values-list values)))))))
    ;; Unwind-protect cleanup form, just in case.
    (setq *inhibit-echo* nil)))

;;; Use this stream when you want ACCEPT to not print out anything
;;; but still take input from the original stream.
(defun inhibit-echo-stream (original-stream operation &rest args)
  (case operation
    ;; Ignore output messages
    ((:tyo :string-out :noise-string-out) nil)
    (:interactive nil)				;fool ACCEPT and COMPLETE-INPUT
    (otherwise (lexpr-send original-stream operation args))))

(defflavor internal-cp-condition () (condition))

(defmethod (dbg:report internal-cp-condition) (stream)
  (format stream "This command processor argument requires confirmation."))

;;; The arg-parser should ensure that this function doesn't get keys it doesn't want
(defun normal-arg-parser (presentation-type &rest keyword-args
			  &key (default nil default-provided) (provide-default t)
			  (mentioned-default nil md-p)
			  (class :normal) documentation
			  confirm query-identifier
			  &allow-other-keys)
  (setq keyword-args (si:rem-keywords keyword-args '(:remaining-args
						     :mentioned-default
						     :documentation :class
						     :expecting-initial-delimiter)))
  (let ((additional-blip-chars
	  (ecase class
	    ((:normal :keyword-value :automatically-generated-keyword-value)
	     *arg-terminators*)
	    (:keyword-name *keyword-key-terminators*)))
	(stream *standard-input*)
	(confirm-warn-p nil)
	(read-initial-delimiter *read-initial-delimiter*))
    (ecase *parsing-mode*
      ((:parse :parse-for-effect)
       (dw:with-accept-help
	   (
	    ((:top-level-help :override)
	     ;; This is :OVERRIDE because it seems that information
	     ;; about this specific argument is more interesting than 
	     ;; "You are being asked to enter a command or form."
	     (lambda (stream ignored)
	       (declare (sys:downward-function))
	       (format stream
		       "~:[You are being asked to enter ~;~:*~A~%Type of input expected:  ~]"
		       documentation)
	       (dw:describe-presentation-type presentation-type stream)
	       (unless documentation (write-char #\. stream)))))
	(let ((expected (if (eq class :keyword-value)
			    *keyword-key-terminators*
			    *arg-terminators*)))
	  (when read-initial-delimiter
	    (if (arg-terminated-p *standard-input* expected)
		;; If the delimiter that terminated the last field was a valid arg terminator,
		;; just read over it.
		(dw:read-char-for-accept *standard-input*)
		(progn
		  (when confirm
		    (when (and *inhibit-echo*
			       (neq *inhibit-echo* :rescan))
		      ;; When we've got echoing inhibited but we haven't yet forced
		      ;; a rescan, force a rescan.
		      (throw 'rescan-to-real-stream 'rescan-to-real-stream))
		    ;; Otherwise, we are either rescanning or we typed an unexpected
		    ;; character while reading an argument that requires confirmation.
		    ;; In any event, there's not reason to try inhibiting echoing in 
		    ;; this case.
		    
		    ;; And, we do want to issue the confirm warning message.
		    (setq confirm-warn-p t)
		    ;; And we want to get the offending character out of the stream
		    (dw:read-char-for-accept *standard-input*))
		  ;; First, try reading rest of arguments without echoing anything.
		  (when (and (neq *inhibit-echo* :rescan)
			     (not confirm-warn-p))
		    ;; If we're running this code, we got an unexpected character,
		    ;; we're not rescanning, and the current argument does not
		    ;; require confirmation.  Try inhibiting echoing for a while.
		    (setq *inhibit-echo* t)
		    (setq stream
			  #'(lambda (op &rest args)
			      (apply #'inhibit-echo-stream *standard-input* op args))))
		  (let ((location (send stream :read-location)))
		    (unless (eql location 0)
		      (dw::presentation-replace-input stream location
						      (first expected) :dont-quote t)))))))
	(unless read-initial-delimiter
	  (setq *read-initial-delimiter* t))
	(when (and (eq class :keyword-value) provide-default)
	  (setq default (if md-p mentioned-default default))
	  (when (or md-p default-provided)
	    (setf (getf keyword-args :default) default)))
	(loop 	      
	   do
	  (condition-case ()
	       (return
		 (multiple-value-prog1
		   (apply #'accept presentation-type :stream STREAM
			  :additional-blip-chars additional-blip-chars
			  ;; :PROMPT-AFTER needs to be added to ACCEPT-2
			  ;; Should either be NIL or a function to be run.
			  ;; We signal this bogus internal condition cause
			  ;; other layers trap the cp error if we try to cause
			  ;; the lower-level call to accept to signal that...
			  :prompt-after (when confirm-warn-p
					  #'(lambda ()
					      (signal 'internal-cp-condition)))
			  keyword-args)
		   ;; If no terminator, supply one.  This ought to mean that the input
		   ;; came from the mouse.  It could also mean that the parser has a bug,
		   ;; though.
		   (when (and (null (dw:peek-char-for-accept stream))
			      (send stream :interactive))
		     (let ((loc (send stream :read-location)))
		       (send stream :replace-input-since loc
			     (first (if (eq class :keyword-value)
					*keyword-key-terminators*
					*arg-terminators*)))
		       (send stream :set-location loc)))))
		(internal-cp-condition
		  (beep tv:beep stream)
		  (cp-error
		    nil
		    (format nil
			    "Confirm or supply a value for ~:@[this~;the ~:(~A~)~] argument."
			    query-identifier))))))
       )
      ((:unparse :unparse-acceptably)
       (when (null *pending-parsed-arguments*)
	 (throw 'done-parsing nil))
       ;; Can't have "noise strings" in input buffers
       ;; a value of :ACCEPTABLY is a crock we use to get dynamic scope on unparsing
       ;; so that we don't put the noise strings in the input buffer.
       (multiple-value-prog1
	 (apply #'accept presentation-type :stream STREAM
		:present-default t		;"present" the default
		:provide-default t		;give the default to accept
		:display-default nil		;but don't actually display it
		:prompts-in-line t
		:default (pop *pending-parsed-arguments*)
		:prompt (if (eql *parsing-mode* :unparse-acceptably)
			    nil
			    (getf keyword-args :prompt))
		keyword-args)
	   (when *pending-parsed-arguments*
	     (write-char (first additional-blip-chars) stream))))
      
      (:skip
	(multiple-value-prog1
	  (values (pop *pending-parsed-arguments*)
		  presentation-type)
	  (when (null *pending-parsed-arguments*)
	    (setq *parsing-mode* :parse)))))))

;;; Keyword argument parsing

;;; +++ Before source freeze this was:
;(define-presentation-type keyword-argument ((&rest keywords))
;   :old-arglist (() &rest keywords)
;   :parser ((stream &key initially-display-possibilities type)
;	    (flet ((turn-hyphens-into-spaces (string)
;		     (substitute #\space #\- string)))
;	      (multiple-value-bind (thing nil nil)
;		  (dw:completing-from-suggestions
;		      (stream :force-complete t
;			      :partial-completers
;			      *keyword-key-partial-completers*
;			      :initially-display-possibilities
;			      initially-display-possibilities
;			      :type type
;			      :compress-choices :never)
;		    (loop for keyword in keywords
;			  do
;		      (dw::suggest (turn-hyphens-into-spaces
;				     (if (listp keyword)
;					 (format nil ":~A" (second keyword))
;					 (format nil ":~:(~A~)" keyword)))
;				   (intern (symbol-name
;					     (if (listp keyword)
;						 (first keyword)
;						 keyword))
;					   'keyword))))
;	      thing)))
;   :printer ((keyword stream)
;	     keywords
;	     (let ((*package* nil))
;	       (format stream "~:(~S~)" keyword))))

;;; If keyword is a string, accept it literally and return
;;; (intern (string-upcase string) 'keyword)
(define-presentation-type keyword-argument ((&rest keywords))
   :parser ((stream &key initially-display-possibilities type)
	    (flet ((turn-hyphens-into-spaces (string)
		     (substitute #\space #\- string)))
	      (sys:with-data-stack
		(let* ((n-keywords (length keywords))
		       (keyword-names (sys:make-stack-array n-keywords :fill-pointer 0))
		       (keys (sys:make-stack-array n-keywords :fill-pointer 0))
		       (doc-clauses (sys:make-stack-array n-keywords :fill-pointer 0)))
		  (loop for (keyword . options) in keywords
			as keyword-name = (turn-hyphens-into-spaces
					    (if (listp keyword)
						(format nil ":~A" (second keyword))
					      (format nil ":~:(~A~)" keyword)))
			as key = (intern (symbol-name (if (listp keyword)
							  (first keyword)
							keyword))
					 'keyword)
			as documentation = (or (getf options :documentation)
					       "No documentation supplied.")
			doing
		    (vector-push keyword-name keyword-names)
		    (vector-push key keys)
		    (vector-push `(,key ,documentation) doc-clauses))
		  (multiple-value-bind (thing nil nil)
		      (dw:completing-from-suggestions
			(stream :force-complete t
				:partial-completers
			          *keyword-key-partial-completers*
				:documenter
				  #'(lambda (keyword stream)
				      (format stream
					  (second (find keyword doc-clauses :key #'car))))
				:initially-display-possibilities
			          initially-display-possibilities
				:type type
				:compress-choices :never)
			(loop for keyword-name being the array-elements of keyword-names
			      for key being the array-elements of keys
			      doing
			  (dw:suggest keyword-name key)))
		    thing)))))

   :printer ((keyword stream)
	     (write-string
	       (substitute #\space #\- 
			   (or (loop for (entry . nil) in keywords doing
				 (when (eq entry keyword)
				   (return (format nil ":~:(~A~)" entry)))
				 (when (and (consp entry)
					    (eq (first entry) keyword))
				   (return (format nil ":~A" (second entry)))))
			       (format nil ":~:(~A~)" keyword)))
	       stream)))

;;; Parse keyword arguments takes a list of clauses looking like:
;;; ((direction 'fs:pathname :default "W:>doughty>foo.bar")
;;;  (...))
;;;
;;; Body looks like CASE on a bunch of keywords.  Read a keyword name
;;; and then dispatch for the specific parsing required for the value of
;;; that keyword.  Value is plist of keyword value pairs.
(defmacro parse-keyword-arguments ((arg-parser &optional extra-cp-keywords) &body clauses
				   &aux extra-clauses)
  (declare (compiler:do-not-record-macroexpansions))
  (when extra-cp-keywords
    (setq extra-clauses
	  (loop for keyword in extra-cp-keywords
		appending (convert-cp-keyword-to-keyword-clause keyword)))
    (setq clauses (append clauses extra-clauses)))
  (multiple-value-bind (keywords new-clauses variables defaults when-clauses template-p)
      (loop for clause in clauses
	    with template-p = t
	    as automatically-generated-p = (member clause extra-clauses)
	    ;; key-spec will either be a symbol or a list of form (keyword symbol)
	    as (key-spec presentation-type . options) = clause
	    as variable = (if (listp key-spec) (cadr key-spec) key-spec)
	    ;; Probably a symbol, sometimes a string
	    as keyword-name = (or (getf options :name)
				  (if (listp key-spec)
				      (car key-spec)
				      variable))
	    as keyword = (intern (string-upcase keyword-name) 'keyword)
	    as default = (or (getf options :default-value)	;--- temporary compatibility
			     (getf options :default))
	    as documentation = (getf options :documentation)
	    as when-p = (member :when options)	;in case we have command-writing macros
	    as when = (getf options :when)
	    as keyword-name-spec = (if (stringp keyword-name) `(,keyword ,keyword-name)
			keyword)
	    collect ``(,',keyword-name-spec :documentation ,,documentation) into keyword-names
	    collect default into defaults
	    collect variable into variables
	    collect `(,keyword (setq ,variable
				     (funcall ,arg-parser ,presentation-type
					      :class
					      ,(if automatically-generated-p
						   :automatically-generated-keyword-value
						   :keyword-value)
					      :query-identifier ',variable
					      . ,(si:rem-keywords options '(:name :when)))))
	      into new-clauses
	    when when-p
	      collect `(,keyword-name-spec ,when) into when-clauses
	    when (and template-p
		      (or (and (not when-p)
			       (every #'compiler:constant-form-p (rest clause)))
			  (setq template-p nil)))
	      collect (map 'list #'compiler:constant-evaluator
			   `(,keyword ,presentation-type
			     :class ,(if automatically-generated-p
					 :automatically-generated-keyword-value
					 :keyword-value)
			     . ,(si:rem-keywords options '(:name :when))))
		into template
	    finally (return (values keyword-names (if template-p template new-clauses)
				    variables defaults when-clauses template-p)))
    (if template-p
	`(parse-template-keyword-arguments-internal ,arg-parser ,keywords 
	   (lambda (.keyword.)
	     (parse-template-keyword-argument .keyword. ,arg-parser ',new-clauses)))
	`(parse-keyword-arguments-internal ,arg-parser ,keywords
					   ,variables ,defaults ,when-clauses
	   (lambda (.keyword.)
	     (ecase .keyword.
	       . ,new-clauses))))))

;;; When this returns, it leaves the last delimiter.
(defmacro parse-keyword-arguments-internal (arg-parser
					    keywords variables defaults
					    when-clauses
					    dispatch-function)
  (let ((default-clauses (loop for variable in variables
			       and default in defaults
			       collecting `(,variable ,default))))
    `(let* ,default-clauses
       (ignore ,@variables)
       (let ((keywords-to-go ,(compiler:optimize-constant-lists ``(,,@keywords))))
	 ,@(when when-clauses
	     (loop for (keyword-name predicate) in when-clauses
		   collecting
		     `(unless ,predicate
			(setq keywords-to-go
			      (remove ',keyword-name keywords-to-go :key #'car)))))
	 (parse-keyword-arguments-internal-run-time-0 ,arg-parser
						      keywords-to-go
						      ,dispatch-function)))))

;;; Simpler version for template case.  Do not need all the variables that name the
;;; keyword arguments, because they cannot be used, since all defaults, etc. are constant
;;; forms.  Keywords are collected for the actual parser by side-effect in the funarg.
(defmacro parse-template-keyword-arguments-internal (arg-parser keywords dispatch-function)
  `(let ((keywords-to-go ,(compiler:optimize-constant-lists ``(,,@keywords))))
     (parse-keyword-arguments-internal-run-time-0 ,arg-parser
						  keywords-to-go
						  ,dispatch-function)))

(defun parse-template-keyword-argument (keyword arg-parser template)
  ;; Note that we use the keyword for the identifier, whereas the inline code uses the
  ;; variable name.  Presumably this doesn't matter, since either one will be unique.
  (let ((elem (assoc keyword template)))
    (when (null elem)
      (error "The keyword ~S was returned by the parser but isn't in the keyword template."
	     keyword))
    (destructuring-bind (ignore presentation-type . options) elem
      (apply arg-parser presentation-type :query-identifier keyword options))))

(defun parse-keyword-arguments-internal-run-time-0
       (arg-parser keywords-to-go dispatch-function)
  ;; Minor interaction style tweak.  Simply here to prevent (keywords) from being
  ;; printed when you hit <return> at the end of all your positional arguments.
  (unless (arg-terminated-p)
    (throw 'done-parsing nil))
  ;; Ok, got a :, now go and really read keywords
  (loop while keywords-to-go
	for first-time = t then nil
	do (multiple-value-bind (keyword new-keywords-to-go)
	       (parse-keyword-arguments-internal-run-time arg-parser keywords-to-go
							  first-time)
	     (when (null keyword)
	       (return nil))
	     (setq keywords-to-go new-keywords-to-go)
	     (funcall dispatch-function keyword))
	   ;; only read the next keyword if there are any more keywords and
	   ;; the delimiter was like #\space
	   (when (null keywords-to-go)
	     (return t))))

(defun parse-keyword-arguments-internal-run-time (arg-parser keywords-to-go first-p)
  (condition-bind ((dw::input-not-of-required-type
		     #'(lambda (e)
			 (when (and (dw:presentation-subtypep (send e :type)
							      'keyword-argument)
				    (string-equal (send e :string) ""))
			   (return-from parse-keyword-arguments-internal-run-time nil)))))
    (let ((keyword (funcall arg-parser `((keyword-argument ,@keywords-to-go))
			    :class :keyword-name
			    :provide-default nil
			    :prompt (when first-p "keywords")
			    :prompts-in-line t)))
      (values keyword
	      (remove keyword keywords-to-go :test #'(lambda (x y)
						       (or (eq x y)
							   (and (listp y)
								(eq (first y) x))))
		      :key #'car)))))

(defun noise-string-out (string &optional (stream *standard-input*))
  (send stream :noise-string-out string))

;;; Kludges to get command-name help in various places
(defun control-character-etc-help (stream &optional string-so-far)
  (ignore string-so-far)
  (format stream "Control characters are interpreted as commands to edit input.~@
                  Press Control- for a list of input editor commands.~%")
  (send stream :input-editor-help))

(defun generic-help-present-p ()
  (multiple-value-bind (present name)
      (cp::command-in-command-table-p 'si:com-generic-help)
    ;; Test both that the command is present and that the command
    ;; is not shadowed by some other command with the same name,
    ;; so we don't embarrass ourselves by presenting unhelpful help!
    ;; -kmp 5-Dec-90
    (and present
	 (eq (cp::command-table-lookup-command *command-table* name)
	     'si:com-generic-help)
	 name)))

(defvar *help-key-help-command-default-arguments* '(:all))

(defun maybe-show-command-name-subhelp (stream string-so-far &key input-context-doesnt-matter)
  (let ((input-context-pres-type (dw::presentation-input-context-presentation-type
				   dw:*presentation-input-context*)))
    (dw:with-type-decoded (type-name) input-context-pres-type
       (let ((flag nil))
	 (when (and (or input-context-doesnt-matter
			(member type-name '(command command-or-form command-name)))
		    (string-equal
		      (string-trim
			'(#\sp #\tab #\return #\line)
			string-so-far)
		      ""))
	   (cond ((generic-help-present-p)
		   (apply #'si:com-generic-help *help-key-help-command-default-arguments*)
		   (setq flag t))
		 (t
		   (show-command-name-help stream :brief))))
	 (when (or input-context-doesnt-matter
		   (member type-name '(command-or-form command)))
	   (unless flag
	     (format stream "~%")
	     (control-character-etc-help stream)))))))

(defun show-command-name-help (stream &optional
			       (type :brief)
			       (detailed-command :default)
			       command-table)
  (when (eq detailed-command :default)
    (setq detailed-command '(si:com-generic-help :commands (:format :detailed))))
  (format stream "~&")
  (dw::show-help-for-presentation-type
    `((command-name :command-table ,(or command-table cp:*command-table*)))
    stream
    ""
    (ecase type
      (:brief
	(if (and detailed-command
		 (cp::command-in-command-table-p (car detailed-command) cp:*command-table*))
	    `(:then-return
	       :if-compressed
	       ,(dw:with-output-to-presentation-recording-string (stream)
		  ;;This string cannot be cached (e.g., in a variable) because it
		  ;;must be allowed to vary according to the input context
		  ;;so that it will print ":Help ..." or "Help ..." as appropriate.
		  ;; -kmp 26-Apr-90
		  (format stream "Use the ~\\CP:COMMAND\\ command to see ~
			          a full list of command names."
			  detailed-command)))
	    :then-return))
      (:detailed :then-return-no-compress-choices)))
  (format stream "~&"))


(defun show-command-help (&key (format :full) (stream *standard-output*)
			  (detailed-command :default)
			  (command-table cp:*command-table*))
  (let ((*standard-output* (or stream *standard-output*)))
    (ecase format
      ((:brief)
       (show-help-for-command-table command-table stream))
      ((:full)
       (show-command-name-help stream :brief detailed-command command-table))
      ((:detailed)
       (show-command-name-help stream :detailed detailed-command command-table)))))

(defun show-help-for-command-table (table stream)
  (let ((supertables '()))
    (map-over-command-table-inheritance
      table
      (lambda (supertable)
	(unless (or (eq supertable table)
		    (and (not (command-table-inherit-from supertable))
			 (not (command-table-command-alist supertable))))
	  (pushnew supertable supertables))))
    (setq supertables (sort supertables #'string-lessp :key #'command-table-name))
    (cond ((null supertables)
	   (expand-command-table table :window stream))
	  (t
	   (show-command-tables-inheriting-from table supertables stream)))))

(define-presentation-action show-help-for-command-table
   (command-table-ellipsis
     t
     :gesture :describe
     :tester expand-command-table-ellipsis-p
     :documentation "Describe command table")
   (table &key window)
  (show-help-for-command-table table window))

(defun show-command-tables-inheriting-from (table supertables stream)
  (si:with-ie-typeout-if-appropriate (stream)
    (let ((n (length (command-table-command-alist table))))
      (format stream "~&The ~@\\PRESENTATION\\ command table ~
		    ~:[~5@*~;has ~@\\PRESENTATION\\ of its own~%and ~]~
	            inherits ~:2@*~:[~;additional ~]commands ~
		    from ~5@*~\\this-these\\ command table~:P:~%"
	      table 'command-table-ellipsis
	      (plusp n)
	      table '((command-table-ellipsis) :locally t)
	      (length supertables)))
    (format-item-list supertables :stream stream
		      :printer #'(lambda (table stream)
				   (present table 'command-table-ellipsis
					    :stream stream)))
    (when (and supertables (not (dw::mouse-sensitive-stream-p stream)))
      (format t "~&Type \"~:[~AShow Command Table <name>~;~
			     ~A~0@*~A (with) Commands :Command Table <name>~]\" ~
		   to expand a command table.~%"
	      (generic-help-present-p)
	      (if (eq cp:*dispatch-mode* :form-preferred) ":" "")))))


;;; Hooks into the existing CP mechanism
(defun read-command (&optional (stream *standard-input*)
		     &key
		     (command-table *command-table*)
		     (blank-line-mode *default-blank-line-mode*)
		     (prompt *default-prompt*))
  (unless stream
    (setq stream *standard-input*))
  (check-blank-line-mode-arg blank-line-mode)
  (check-prompt-arg prompt)
  (multiple-value-bind (data type)
	  ;; Use this kludge here because ACCEPT won't actually call our parser
	  ;; until after whitespace has been read...
	  (dw:with-accept-help ((:subhelp #'maybe-show-command-name-subhelp))
	    (accept `((command :command-table ,command-table))
		    :prompt prompt :prompt-mode :raw
		    :stream stream :provide-default nil
		    :top-level t :top-level-blank-line-mode blank-line-mode))
    (when type
      (cond ((eq type (first (si:input-editor-option :full-rubout)))
	     (values data type))
	    ((null data)
	     (error "ACCEPT of CP:COMMAND failed to return a command.  Please report this."))
	    (t
	     (destructuring-bind (command . arguments) data
	       (fresh-line stream)
	       (values command arguments)))))))

;;; Read-command (accept 'command) returns a command name and arguments.
;;; This function turns that into an evaluable form.
(defun read-command-returning-form (command-table stream prompt)
  (multiple-value-bind (thing type)
      (dw:with-accept-help ((:subhelp #'maybe-show-command-name-subhelp))
	(accept `((command :command-table ,command-table)) :prompt prompt :prompt-mode :raw
		:stream stream :provide-default nil :top-level t))
    (fresh-line stream)
    (let ((full-rubout-option (first (si:input-editor-option :full-rubout))))
      (values (if (and full-rubout-option
		       (eq type full-rubout-option))
		  nil
		  (convert-command-to-form thing))
	      type))))

;;;--- Obvious disagreement here.
;;; Should only be one function, although which calling sequence?
(defun convert-command-to-form (command)
  (destructuring-bind (cmd . arguments) command
    (turn-command-into-form cmd arguments)))

(defun turn-command-into-form (command arguments)
  (cons command (loop for argument in arguments
		      collect `',argument)))

(defun read-command-or-form (&optional (stream *standard-input*)
			     &key
			     (command-table   *command-table*)
			     (dispatch-mode   *default-dispatch-mode*)
			     (blank-line-mode *default-blank-line-mode*)
			     (prompt	      *default-prompt*)
			     (exception-chars nil)
			     (expression-reader  nil)
			     (expression-printer nil)
			     (environment     si:*read-form-environment* environment-p))
  (ignore exception-chars)
  (unless stream
    (setq stream *standard-input*))
  (check-dispatch-mode-arg dispatch-mode)
  (check-blank-line-mode-arg blank-line-mode)
  (check-prompt-arg prompt)
  (case dispatch-mode
    (:command-only
      (read-command-returning-form command-table stream prompt))
    (:form-only
      ;; should be ((sys:form) :environment environment)
      (dw:with-accept-help ((:subhelp #'control-character-etc-help))
	(let ((ptype `((sys:form) :expression-reader ,expression-reader
				  :expression-printer ,expression-printer
				  ,@(and environment-p
					 `((:environment ,environment))))))
	  (accept ptype
		  :provide-default nil :prompt prompt :prompt-mode :raw :stream stream
		  :top-level t :top-level-blank-line-mode blank-line-mode))))
    (otherwise					; :form-perferred or :command-preferred
      (multiple-value-bind (thing type)
	  ;; Use this kludge here because ACCEPT won't actually call our parser
	  ;; until after whitespace has been read...
	  (dw:with-accept-help ((:subhelp #'maybe-show-command-name-subhelp))
	    (let ((ptype `((command-or-form :command-table ,command-table
					    :dispatch-mode ,dispatch-mode)
			   :environment ,environment
			   :expression-reader ,expression-reader
			   :expression-printer ,expression-printer)))
	      (accept ptype
		      :provide-default nil :prompt prompt :prompt-mode :raw :stream stream
		      :top-level t :top-level-blank-line-mode blank-line-mode)))
	(cond ((null type)
	       (values thing type))
	      ((dw:presentation-subtypep type 'command)
	       (send stream :fresh-line)
	       (values (convert-command-to-form thing) type))
	      (t (values thing type)))))))

(defun try-to-interpret-error-as-symbol (e)
  (declare (values symbol found-p string))
  ;; This is only used in a condition-bind handler, that's why
  ;; it has side-effects and returns NIL.
  ;; if there are any spaces in the string, forget it immediately
  (let* ((string (send e :string))
	 (string-length (string-length string)))
    (when (or (null string) (zerop string-length))
      (return-from try-to-interpret-error-as-symbol (values nil nil nil)))
    (let ((index (1- string-length)))
      (when  (eql (aref string index) #\Space)
	(setq string (nsubstring string 0 index)))
      (when (string-search #\sp string)
	(return-from try-to-interpret-error-as-symbol (values nil nil nil)))
      (let ((type (send e :type)))
	(dw:with-type-decoded (type-name data-args pres-args) type
	  (when (eql type-name 'command-name)
	    ;; the thing typed isn't a command name, see if it is a
	    ;; bound symbol or symbol macro.
	    ;; We are relying on the fact that only
	    ;; alphabetic characters can start this string
	    ;; (otherwise we're already in the form case
	    ;; in some other code in this file)
	    ;; Thus there's no way read-from-string
	    ;; can get any errors.
	    (let ((symbol (read-from-string string)))
	      (when (and (symbolp symbol) (boundp symbol))
		(return-from try-to-interpret-error-as-symbol (values symbol t string))))
	    ;; --- do package-dwim at this point??
	    ;; At this point, the input was not a symbol with a value.
	    ;; Augment the type with a description for error reporting.
	    ;; (only do this when we know the type is command-name)
	    ;; Is this too cutesy?
	    (setq pres-args (copy-list pres-args))	;Don't clobber random lists!  --RWK
	    (setf (getf pres-args :description)
		  "a command name or a symbol with a value")
	    (let ((new-type `((,type-name ,@data-args) ,@pres-args)))
	      ;; If we haven't returned yet, continue signalling the original
	      ;; input-not-of-required-type error.
	      (sys:set-in-instance e 'type new-type))
	    ;; now decline to handle the error after
	    ;; performing that gross surgery on the error object...
	    (values nil nil nil)))))))

(define-presentation-type command-or-form
      ((&key (command-table *command-table* command-table-supplied-p)
	     (dispatch-mode *dispatch-mode*))
       &key (environment si:*read-form-environment*)
	    (expression-reader  nil)
	    (expression-printer nil))
   :history nil
   :abbreviation-for
     (let ((command-type (if command-table-supplied-p
			     `(command :command-table ,command-table)
			   'command))
	   (form-type `((sys:form) :environment ,environment
				   :expression-reader ,expression-reader
				   :expression-printer ,expression-printer)))
       (case dispatch-mode
	 (:command-preferred `(or ,command-type ,form-type))
	 (:form-preferred    `(or ,form-type ,command-type))
	 (:command-only	     command-type)
	 (:form-only	     form-type)))
   :parser ((stream)
	    (let ((char 
		    ;; Need this kludge because we want #\Help to show us
		    ;; command names even though we're in command-or-form context.
		    (dw:with-accept-help ((:subhelp #'maybe-show-command-name-subhelp))
		      (dw:peek-char-for-accept stream t))))
	      (cond ((member char *command-dispatchers*
			     :test #'dw:compare-char-for-accept)
		     ;; Need to clear-presentation-input-context so that
		     ;; the recursive call to accept doesn't inherit both command and form
		     ;; context
		     (dw:clear-presentation-input-context)
		     (dw:read-char-for-accept stream)
		     (accept `((command :command-table ,command-table)) :prompt nil
			     :stream stream
			     :provide-default nil))
		    ((member char *form-dispatchers* :test #'dw:compare-char-for-accept)
		     (dw:clear-presentation-input-context)
		     (dw:read-char-for-accept stream)
		     (dw:with-accept-help ((:subhelp #'control-character-etc-help))
		       (let ((ptype `((sys:form) :environment ,environment
						 :expression-reader ,expression-reader
						 :expression-printer ,expression-printer)))
			 (accept ptype
				 :provide-default nil :prompt nil :stream stream))))
		    (t (cond ((and (eq dispatch-mode :command-preferred)
				   (characterp char) (si:alpha-char-p char))
			      (dw:clear-presentation-input-context)
			      (block read-command-or-symbol
				(labels ((maybe-interpret-as-symbol (e)
					   (multiple-value-bind (symbol found-p string)
					       (try-to-interpret-error-as-symbol e)
					     (when found-p
					       ;; get the damn delimiter out of the stream
					       ;; we've changed the rules in mid-"stream".
					       (dw:read-char-for-accept stream)
					       (let ((ptype `((sys:form)
							      :environment ,environment
							      :expression-reader
							        ,expression-reader
							      :expression-printer
							        ,expression-printer)))
						 (dw::push-for-presentation-type
						   (dw::find-accept-history ptype)
						   symbol ptype string)
						 (return-from read-command-or-symbol
						   (values symbol ptype)))))))
				  (let ((command-type
					  `((command :command-table ,command-table))))
				    (condition-bind ((dw::input-not-of-required-type
						       #'maybe-interpret-as-symbol))
				      (accept command-type :prompt nil
					      :stream stream :provide-default nil))))))
			     ;; dispatch mode is :form-preferred or a non-alpha char was typed
			     (t (dw:clear-presentation-input-context)
				(dw:with-accept-help ((:subhelp #'control-character-etc-help))
				  (let ((ptype `((sys:form) :environment ,environment
						 :expression-reader ,expression-reader
						 :expression-printer ,expression-printer)))
				    (accept ptype
					    :provide-default nil :prompt nil
					    :stream stream))))))))))

;;; Provide this separate function, rather than just using ACCEPT because it can default the
;;; prompt and interact with the history better.
(defun read-command-arguments (command-name &key initial-arguments
						 (command-table *command-table*)
						 (stream *standard-input*)
						 (prompt nil prompt-p)
						 (full-command-into-history nil))
  (let ((prefix nil))
    (flet ((get-prefix ()
	     (or prefix
		 (setq prefix (present-to-string
				(cons command-name initial-arguments)
				`((command :command-table ,command-table)))))))
      (when (null prompt-p)
	(setq prompt (get-prefix)))
      (with-input-editing-options-if full-command-into-history ((:no-input-save t))
	(multiple-value-prog1
	  (accept `((command-arguments :command-name ,command-name
				       :initial-arguments ,initial-arguments)
		    :read-initial-delimiter nil)
		  :prompt prompt
		  :stream stream)
	  (fresh-line stream)
	  (when full-command-into-history
	    (let ((history (send-if-handles stream :input-history))
		  (argument-input (send-if-handles stream :last-input)))
	      (when (and history argument-input)
		(send history :push
		      (string-append (get-prefix) #\space argument-input))))))))))

(defun unparse-command (command-name arguments &optional (command-table *command-table*)
							 (already-quoted nil)
							 (arguments-only nil)
							 (show-default nil)
							 (acceptably t))

  ;--- Does anyone supply this trash?
  (ignore already-quoted arguments-only show-default)
  (present-to-string
    `(,command-name . ,arguments)
    `((command :command-table ,command-table))
    :acceptably acceptably))

;;; Assume for top-level command description.
;;; With a colon, doesn't allow sensitive inferiors.
;;; --- This is an interim solution to the :Start GC :Immediately problem
(format:defformat command (:one-arg) (command ignore)
  (present command 'command :stream format:*format-output*
	   :acceptably :very
	   :for-context-type 'command-or-form
	   :allow-sensitive-inferiors (not format:colon-flag)))

#||
;;;  Tests and examples
;;;  Not really a very thorough test suite, just random hacks.

(define-command (com-york :command-table "User" :values t :provide-output-destination-keyword nil)
		((file 'fs:pathname :default (fs:parse-pathname "Wally"))
		 (child '((member :user :host)) :default :host :confirm t))
  (values file child))

(define-command (com-foo-bar :command-table "User" :values t)
		((yes 'boolean :default nil)
		 (object `((net:object :class :user)) :confirm t
			 )
		 &key
		 (locally 'boolean :default t))
  yes)

(define-command (com-eno-test :command-table "User" :values t)
		    ((class '((member :user :host :any)) :default :any)
		     (object `((net:object :class ,class)) :when (neq class :any) :confirm t)
		     &key
		     (locally 'boolean :default t :when (neq class :any)))
  (format t "~&Class: ~A, Object: ~A, Locally: ~A" class object locally)
  (values class object locally))

Expands into ==>

(progn
  (define-command-and-parser (com-another-frob-namespace-object :command-table "User"
								:values t)
		    (&optional (class :any) (object nil) &key (locally t))
         (progn (assign-argument-value class
                 (read-command-argument '((member :user :host :any)) :query-identifier 'class
                  :default :any))
                (when (neq class :any)
                  (assign-argument-value object
                   (read-command-argument `((net:object :class ,class)) :query-identifier
                    'object :confirm t)))
                (read-keyword-arguments
                 (locally 'boolean :default t
			  :when (neq class :any))))
         (values class object locally)))

Note the presence of :query-identifier in the above.  That is ONLY for ACCEPT's
benefit, and for the purposes of letting the command processor give you
more informative error messages.  You could write the command such as the one below
without :query-identifier and not suffer.


(define-command-and-parser (com-frob-namespace-object :command-table "User" :values t)
		  (class &optional object &key (locally t))
  (progn
    (assign-argument-value
      class
      (read-command-argument '((member :user :host :any)) :default :any))
    (unless (eq class :any)
      (assign-argument-value
	object
	(read-command-argument `((net:object :class ,class))
			       :documentation "Something interesting")))
    (read-keyword-arguments
      (locally 'boolean :default t :documentation "Edit a local copy of this object?")))
  (values class object locally))

(define-command (simple :command-table "user" :values t)
		    ((path 'pathname)
		     (file `fs:pathname :prompt "foo file")
		     &key
		     (thing '((member :wally :beaver)) :mentioned-default :wally))
  path
  (let ((foo (accept 'fs:pathname)))
    (format t "~&Foo was ~S" foo))
  ;; Does output for purposes of testing :Output-Destination
  (format t "This is a test ~S" path)
  (values path file thing))

(define-command (still-another-test :command-table "User")
		(&key (two-word '((member :wally :beaver)) :default :wally))
  two-word)

(define-command (complex-test :command-table "user" :values t)
		((files '((sequence fs:pathname))
			:prompt "foo file")
		 (thing '((member :wally :beaver))
			:default :wally)
		 (another-file 'fs:pathname
			       :provide-default nil
			       :prompt "second file")
		 &key
		 (direction 'pathname)
		 (format '((member :new :old))
			 :default :old
			 :mentioned-default :new))
  (values files thing another-file direction format))

;;; --- This doesn't work as a way to start a  multi-arg command
(define-presentation-to-command-translator (fs:pathname)
					   (path)
  `(complex-test (,path)))

(define-command (no-arguments :command-table "Test")
		    ()
  (print "Nothing"))

;;; old-style command
(define-command (the-test :command-table "Test" :values t)
		    ((file :pathname
			   :allow-multiple t
			   :confirm t
			   :use-type-default t
			   :prompt (format nil "Foo ~S" (fs:merge-pathnames =default=)))
		     (foo (:enumeration :a :b))
		     &key
		     (direction (:enumeration :forward :backward)
				:default :forward
				:mentioned-default :backward))
  (values file foo direction))

;;; Expanding this:

(define-command (com-delete-file :command-table "Test")
		   ((files (sequence pathname)
			  :prompt "file to delete" ;(format nil "file [default ~A]" (first =default=))	;
;			  :confirm t
;			  :documentation "File to mark for deletion")
			  )
		    &key
		    (expunge (member :yes :no :ask)
			     :default :no
			     :mentioned-default :yes
;			     :documentation "Whether to expunge the files, also"
			     )
		    (keep integer
			  :default 0
;			  :documentation "How many versions to keep")
			  )
		    (query (member :yes :no :ask)
			   :mentioned-default :yes
			   :default :no
;			   :documentation "Whether to ask before deleting each file"))
			   ))
  expunge keep query ;You get the idea anyway
  (dolist (directory files)
    (dolist (file (directory directory))
      (delete-file file))))

;;; produces this:

(DEFINE-COMMAND-AND-PARSER COM-DELETE-FILE
		      ;; This is the argument list of the actual COM-DELETE-FILE function,
		      ;; so that arguments not supplied in the command parsing are defaulted
		      ;; at execution time.
		      (&OPTIONAL (FILES NIL)
		       &KEY (EXPUNGE :NO) (KEEP 0) (QUERY :NO))
		      ((ARG-PARSER)
		       (LET* ((FILES (FUNCALL ARG-PARSER '(SEQUENCE PATHNAME)
					      :PROMPT (FORMAT NIL "file [default ~A]"
							      (FIRST =DEFAULT=))
					      :CONFIRM T
					      :DOCUMENTATION "File to mark for deletion")))
			 (LIST* FILES
			   (PARSE-KEYWORD-ARGUMENTS (ARG-PARSER)
			     (:EXPUNGE
			      (FUNCALL ARG-PARSER '(MEMBER :YES :NO :ASK)
				       :DEFAULT :NO
				       :MENTIONED-DEFAULT :YES
				       :DOCUMENTATION "Whether to expunge the files, also"))
			     (:KEEP
			      (FUNCALL ARG-PARSER 'INTEGER
				       :DEFAULT 0
				       :DOCUMENTATION "How many versions to keep"))
			     (:QUERY
			      (FUNCALL ARG-PARSER '(MEMBER :YES :NO :ASK)
				       :MENTIONED-DEFAULT :YES
				       :DEFAULT :NO
				       :DOCUMENTATION "Whether to ask ..."))))))
  EXPUNGE KEEP QUERY
  (DOLIST (DIRECTORY FILES)
    (DOLIST (FILE (DIRECTORY DIRECTORY))
      (DELETE-FILE FILE))))

;;; Something that needs the full parser power
(define-command-and-parser (com-rename-buffer :command-table 'global)
		      (buffer new-name)
		      ((arg-reader arg-collector)
		       (let ((buffer (funcall arg-reader 'zwei:buffer :default zwei:*interval*)))
			 (list buffer
			       (if (zwei:file-buffer-p buffer)
				   (funcall arg-reader 'pathname
					    :prompt (format () "new filename for ~A" buffer)
					    :default (send buffer :pathname))
				   (funcall arg-reader 'string
					    :prompt (format () "new name for ~A" buffer)
					    :default (send buffer :name))))))
  (if (zwei:file-buffer-p buffer)
      (send buffer :set-pathname new-name)
      (send buffer :set-name new-name))
  )

;;; Or in the alternate scheme where arguments are accumulated
;;; automatically and you are allowed to put in additional arguments
;;; that didn't come from parsing:
(define-command-and-parser com-rename-buffer
		      (buffer file-p new-name)
		      ((reader outputter)
		       (let* ((buffer (funcall reader 'buffer :default *interval*))
			      (file-p (file-buffer-p buffer)))
			 (funcall outputter file-p)
			 (if file-p
			     (funcall reader 'pathname
				      :prompt (format () "new filename for ~A" buffer)
				      :default (send buffer :pathname))
			     (funcall reader 'string
				      :prompt (format () "new name for ~A" buffer)
				      :default (send buffer :name)))))
  (if file-p
      (send buffer :set-pathname new-name)
      (send buffer :set-name new-name))
  )

||#

;;; Accept-values-based command argument reading

(defun choose-command-arguments (command-name &rest args
					      &key (initial-arguments nil)
						   (start (length initial-arguments))
						   (end nil)
						   (command-table *command-table*)
						   (stream *standard-input*)
						   (typeout-stream nil)
						   (help-stream typeout-stream)
						   (prompt nil) (prompt-mode :normal)
						   (own-window nil)
						   (near-mode '(:mouse))
						   (full-rubout nil)
						   (erase-input-editor nil)
						   (mode :accept-values)
						   (initially-select-query-identifier nil))

  ;; Documentation
  (ignore end stream prompt prompt-mode own-window near-mode
	  initially-select-query-identifier)

  (ecase mode
    (:none
     (default-positional-arguments command-name :initial-arguments initial-arguments
						:command-table command-table))
    ((:accept-values :menu)
     (cond ((and typeout-stream (not own-window))
	    (let ((sys:rubout-handler nil)
		  (sys:*input-editor-options* nil)
		  (dw::*accept-active* nil))
	      (send typeout-stream :expose-for-typeout)
	      (tv:window-call-relative (typeout-stream :make-complete)
		(apply #'accept-values-command-arguments command-name
		       :stream typeout-stream :allow-other-keys t args))))
	   ((and sys:rubout-handler (not own-window))
	    (let ((dw::*accept-active* nil))
	      (si:with-ie-typeout-if-appropriate (stream :insert :blank-line :none)
		(si:with-ie-typein (stream nil :erase erase-input-editor)
		  (with-input-editing-options-if help-stream ((:help-stream help-stream))
		    (apply #'accept-values-command-arguments command-name
			   :allow-other-keys t args))))))
	   (t
	    (apply #'accept-values-command-arguments command-name
		   :allow-other-keys t args))))
    #||
    (:menu
     (apply #'menu-choose-command-arguments command-name :allow-other-keys t args))
    ||#
    (:keyboard
     (let* ((fixed-arguments (subseq initial-arguments 0 start))
	    (initial-input (when (> (length initial-arguments) (length fixed-arguments))
			     ;; There are some initial arguments that are editable
			     (substring (unparse-command command-name initial-arguments
							 :command-table command-table
							 :arguments-only t)
					0
					(string-length
					  (unparse-command command-name
							   fixed-arguments
							   :command-table command-table
							   :arguments-only t))))))
       (flet ((read-them (stream)
		(multiple-value-bind (start-x start-y)
		    (send stream :read-cursorpos)
		  (with-input-editing-options-if initial-input
						    ((:initial-input initial-input))
		    (multiple-value-bind (arguments type)
			(with-input-editing-options-if full-rubout
						       ((:limited-full-rubout
							  :full-rubout))
			  (apply #'read-command-arguments command-name
				 :stream stream :initial-arguments fixed-arguments
				 :full-command-into-history t
				 :allow-other-keys t args))
		      (when (eq type :full-rubout)
			(multiple-value-bind (end-x end-y)
			    (send stream :read-cursorpos)
			  (send stream :clear-between-cursorposes start-x start-y end-x end-y)
			  (send stream :set-cursorpos start-x start-y))
			(return-from read-them :full-rubout))
		      arguments)))))
	 (if sys:rubout-handler
	     (let ((dw::*accept-active* nil))
	       (si:with-ie-typein (stream nil :erase erase-input-editor)
		 (with-input-editing-options-if
		     help-stream ((:help-stream help-stream))
		   (read-them stream))))
	     (read-them stream)))))))

(defun accept-values-command-arguments (command-name &rest args
					&key (initial-arguments nil)
					     (start (length initial-arguments))
					     (end nil)
					     (command-table *command-table*)
					     (stream *standard-input*)
					     (own-window nil)
					     (near-mode '(:mouse))
					     (prompt nil prompt-p)
					     (prompt-mode :normal)
					     (initially-select-query-identifier nil))
  (declare (ignore args))
  (let ((*standard-input* stream)
	(fixed-arguments (subseq initial-arguments 0 start)))
    (when (null prompt-p)
      (setq prompt (present-to-string (cons command-name fixed-arguments)
				      `((command :command-table ,command-table)))))
    (when prompt
      (unless (or own-window (eq prompt-mode :own-window))
	(si:display-prompt-option stream prompt)
	(format stream ":~%")))
    (dw:accepting-values (*standard-input* :own-window own-window
					   :label prompt :near-mode near-mode
					   :initially-select-query-identifier
					     initially-select-query-identifier)
      (accept-values-command-arguments-1 command-name
					 :initial-arguments initial-arguments
					 :start start :end end))))

(defun accept-values-command-arguments-1 (command-name &key (initial-arguments nil)
							    (start (length initial-arguments))
							    (end nil))
  (let* ((null-keyword-marker '#,(gensym))
	 (arguments-to-go (coerce initial-arguments 'list))
	 (arguments nil)
	 (keyword-name nil))
    (labels ((pop-arguments-to-go ()
	       (let* ((value (pop arguments-to-go))
		      (next (car arguments-to-go)))
		 ;; An unread argument usually means that there was a
		 ;; 1:when0 which was not satisfied.  We have to skip it
		 ;; here so that it doesn't screw up the works.
		 (when (unread-argument-p next)
		   (pop arguments-to-go))
		 value))
	     (emitter (argument)
	       (collect-into argument arguments)
	       (when (and end
			  ( (length arguments) end))
		 (throw 'done-parsing nil))
	       argument)
	     (parser (presentation-type &rest args
					&key class &allow-other-keys)
	       (cond ((and arguments-to-go
			   (< (length arguments) start))
		      (values (pop-arguments-to-go) presentation-type))
		     ((eq class :keyword-name)
		      (dw:with-presentation-type-arguments
			(keyword-argument presentation-type)
			(values
			  (let ((key
				  (loop while arguments-to-go do
				    (let ((new-value
					    (find (pop-arguments-to-go) keywords
						  :key #'(lambda (item)
							   (let ((keyword (car item)))
							     (if (consp keyword)
								 (first keyword)
								 keyword))))))
				      (if new-value 
					  (return (car new-value))
					  ;; arg isn't valid - pop the value too
					  ;; This is not optimal.
					  ;; We can't tell the difference between a bogus
					  ;; arg and a currently invalid arg
					  ;; (due to a :when).
					  ;; Really bogus args in the initial-arguments
					  ;; don't error but are ignored.
					  (pop-arguments-to-go)))
					finally
					  (return (first (first keywords))))))
			    (setq keyword-name (if (consp key) (second key)
						   (string-capitalize key)))
			    (if (consp key) (first key) key))
			  presentation-type)))
		     (t
		      (si:with-rem-keywords (accept-args args
							 '(:remaining-args :mentioned-default
							   :documentation :class))
			(with-stack-list* (args-with-keyword-name
					    :prompt keyword-name accept-args)
			  (with-stack-list* (args-with-ensure-object
					      :ensure-object t accept-args)
			    (cond ((member class
					   '(:keyword-value
					     :automatically-generated-keyword-value))
				   (setq accept-args args-with-keyword-name))
				  ((eq (dw:presentation-type-name presentation-type)
				       'boolean)
				   nil)
				  ;; This must be a positional non-boolean
				  (t (setq accept-args args-with-ensure-object)))
			    (let ((default (first arguments-to-go)))
			      (with-stack-list* (args-with-default
						  :default default
						  :provide-default t
						  accept-args)
				(cond (arguments-to-go
				       (pop-arguments-to-go)
				       (setq accept-args args-with-default))
				      (t (setq default (getf accept-args :default))))
				(with-stack-list* (args-with-explicit-default
						    :default nil accept-args)
				  ;; If this is a keyword argument, and the call did not
				  ;; supply a :default, do not let accept try to get it
				  ;; from the history.  This makes it look more consistent
				  ;; with how unsupplied keywords behave.
				  (when (and (eq class :keyword-value)
					     (eq (getf accept-args :default
						       null-keyword-marker)
						 null-keyword-marker))
				    (setq accept-args args-with-explicit-default))
				  (multiple-value-bind (value type unchanged-p)
				      (apply #'accept presentation-type
					     :stream *standard-input*
					     accept-args)
				    (if (and unchanged-p (null default)
					     (member class
						     '(:keyword-value
						       :automatically-generated-keyword-value
						       )))
					null-keyword-marker
					(values value type)))))))) ))))
	     (parser-emitter (&rest args)
	       (emitter (apply #'parser args))))
      (let ((args (funcall (fdefinition `(command-parser-function ,command-name))
			   #'parser-emitter)))
	(if (not (member null-keyword-marker args))
	    args
	    (let ((new-list nil))
	      (dolist (arg args)
		(if (eq arg null-keyword-marker)
		    (pop new-list)
		    (push arg new-list)))
	      (nreverse new-list)))))))

(defflavor null-cp-input-stream () (si:input-stream))

(defmethod (:tyi null-cp-input-stream) () nil)
(defmethod (:listen null-cp-input-stream) () t)
(defmethod (:untyi null-cp-input-stream) (ignore) )

(defmethod (arg-terminated-p null-cp-input-stream) (ignore) t)

(compile-flavor-methods null-cp-input-stream)

(defresource null-cp-input-stream ()
  :constructor (make-instance 'null-cp-input-stream))

;;; This is used by define-program-framework for the default click right
;;; behaviour on a command menu item.
;;; If the command only gets one argument, read it from a menu or the
;;; keyboard depending on whether it has a special choose mode.
(defun select-best-choose-arguments-mode (command-name &key (initial-arguments nil)
							    (start (length initial-arguments))
							    (end nil)
							    (command-table *command-table*)
							    (stream *standard-input*)
							    (for-select-gesture nil)
							    )
  (declare (values mode own-window-p))
  (ignore command-table)			;Who knows, might need it.
  (let* ((arguments-to-go (coerce initial-arguments 'list))
	 (arguments nil)
	 (number-of-real-arguments 0)
	 (arg-without-default nil)
	 (first-real-presentation-type nil))
    (labels ((emitter (argument)
	       (collect-into argument arguments)
	       (when (and end
			  ( (length arguments) end))
		 (throw 'done-parsing nil))
	       argument)
	     (parser (presentation-type &rest args
					&key class
					     (confirm nil)
					     (default nil def-p)
					     (mentioned-default nil md-p)
					     (provide-default 'dw::unless-default-is-nil)
					&allow-other-keys)
	       (declare (ignore args))
	       (cond ((and arguments-to-go
			   (< (length arguments) start))
		      (values (pop arguments-to-go) presentation-type))
		     ((eq class :keyword-name)
		      (when for-select-gesture	;Don't worry about these, only required.
			(throw 'done-parsing nil))
		      (dw:with-presentation-type-arguments
			  (keyword-argument presentation-type)
			(values (let ((key
					(if arguments-to-go
					    (let ((tem (pop arguments-to-go)))
					      (or (loop for (keyword . nil) in keywords
							do
						    (when (eq (if (consp keyword)
								  (first keyword)
								  keyword)
							      tem)
						      (return keyword)))
						  tem))
					    (first (first keywords)))))
				  (if (consp key) (first key) key))
				presentation-type)))
		     ((and (eq class :keyword-value)
			   (eq presentation-type 'destination))
		      (setq arguments (nbutlast arguments))
		      (throw 'foo nil))
		     (t
		      (flet ((get-default ()
			       (cond (md-p mentioned-default)
				     (def-p default)
				     (t (dw:presentation-type-default presentation-type)))))
			(when for-select-gesture
			  (unless (and (not confirm)
				       (or arguments-to-go
					   (case provide-default
					     ((nil) nil)
					     ((dw::unless-default-is-nil)
					      (or (not (null (get-default)))
						  (dw::presentation-type-null-default-provide-default
						    presentation-type)))
					     (otherwise t))))
			    (setq arg-without-default t)
			    (throw 'too-many t)))
			(incf number-of-real-arguments)
			(when (> number-of-real-arguments 1)
			  (throw 'too-many t))
			(setq first-real-presentation-type presentation-type)
			(values
			  (if arguments-to-go (pop arguments-to-go) (get-default))
			  presentation-type)))))
	     (parser-emitter (&rest args)
	       (catch 'foo
		 (emitter (apply #'parser args)))))
      (catch 'too-many
	(using-resource (*standard-input* null-cp-input-stream)
	  (let ((*parsing-mode* :parse-for-effect))
	    (funcall (fdefinition `(command-parser-function ,command-name))
		     #'parser-emitter)))))
    (let ((background-p (eq (si:follow-syn-stream stream) 'tv:background-stream)))
      (cond (arg-without-default
	     (values :keyboard background-p))
	    (for-select-gesture
	     :none)
	    ((zerop number-of-real-arguments)
	     ;; Should we require confirmation?
	     :none)
	    ((or (> number-of-real-arguments 1) (null first-real-presentation-type))
	     ;; Too many, use multiple accept, in its own window if
	     ;; there isn't anything better.
	     (values :accept-values background-p))
	    (t
	     ;; Just one, see whether it has a nice chooser
	     (dw::with-type-method ((type function display-type)
				    first-real-presentation-type
				    #'dw::presentation-type-displayer-for-menu)
	       (ignore function type)
	       (if (eql display-type 'printer)
		   (values :keyboard background-p)
		 (values :menu background-p))))))))

(defun default-positional-arguments (command-name &key (initial-arguments nil)
						       (command-table *command-table*)
						       )
  (ignore command-table)			;Who knows, might need it.
  (let ((arguments-to-go (coerce initial-arguments 'list)))
    (labels ((parser (presentation-type &rest args
					&key class
					     (default nil def-p)
					     (mentioned-default nil md-p)
					&allow-other-keys)
	       (declare (ignore args))
	       (cond (arguments-to-go
		      (values (pop arguments-to-go) presentation-type))
		     ((eq class :keyword-name)
		      (throw 'done-parsing nil))
		     (t
		      (values
			(cond (md-p mentioned-default)
			      (def-p default)
			      (t (dw:presentation-type-default presentation-type)))
			presentation-type)))))
      (using-resource (*standard-input* null-cp-input-stream)
	(let ((*parsing-mode* :parse-for-effect))
	  (funcall (fdefinition `(command-parser-function ,command-name)) #'parser))))))

;;;; execute-command and friends

(defun execute-command-internal (command)
  (let ((*last-command-values* *last-command-values*))
    (fresh-line)
    (apply (first command) (rest command))
    *last-command-values*))

(defun execute-command (command-name &rest command-arguments)
  (execute-command-internal (apply #'build-command command-name command-arguments)))

(defun build-command (command-name &rest command-arguments)
  (etypecase command-name
    (symbol (command-name-command-descriptor command-name))
    ;; Well, here's some heuristication.  We'd really like to simply error
    ;; here if the string isn't found, but there are some circumstances where
    ;; the string can be decoded relative to the current command table and
    ;; everything will work right.
    ;; Positive side-effect:  A translator on pathnames to "Show File" will work,
    ;; although there will be no documentation if you move the mouse over this
    ;; item in the click-right menu.
    ;; Negative side-effects:  A translator to "Sned Message" will properly not
    ;; blowout, but you will never be able to figure out why it didn't work.
    (string
      (let ((real-command-name (command-table-lookup-command *command-table* command-name)))
	(unless real-command-name
	  (when (or dw::*inside-handler-test-phase*
		    dw::*inside-handler-documentation-phase*)
	    (return-from build-command nil))
	  (error "There is no command called \"~A\"." command-name))
	(setq command-name real-command-name))))
  (when dw::*inside-handler-test-phase*
    (return-from build-command (ncons command-name)))	;this is enough
						;for the rest of the test-phase to do
						;its work
  (let* ((arguments-to-go command-arguments))
    (flet ((parser (presentation-type &rest args
				      &key class
					   (default nil def-p)
					   (mentioned-default nil md-p)
				      &allow-other-keys)
	     (flet ((default-value ()
		      (cond (md-p mentioned-default)
			    (def-p default)
			    (t (dw:presentation-type-default presentation-type)))))
	       (if (null arguments-to-go)
		   (if (eq class :keyword-name)
		       (throw 'done-parsing nil)
		       ;; Must supply all positional arguments, since
		       ;; function cp writes does not really take optional
		       ;; arguments.
		       (values (default-value) presentation-type))
		   (let ((argument-value (pop arguments-to-go)))
		     (if (eq class :keyword-name)
			 (dw:with-presentation-type-arguments
			   (keyword-argument presentation-type)
			   (assert (member argument-value keywords
					   :key #'(lambda (x)
						    (if (consp (first x))
							(first (first x))
							(first x))))
				   (argument-value)
				   "~S is not a valid keyword." argument-value))
			 (let* ((sequence-p (eq (dw:presentation-type-name presentation-type)
						'sequence))
				(sequence-type (and sequence-p
						    (dw:with-presentation-type-arguments
						      (sequence presentation-type)
						      dw::element-type)))
				(string-p (eq (dw:presentation-type-name
						(if sequence-p sequence-type
						    presentation-type))
					      'string)))
			   (typecase argument-value
			     (string
			       (if string-p
				   (when sequence-p
				     (setq argument-value (list argument-value)))
				   (setq argument-value (apply #'accept-from-string
							       presentation-type
							       argument-value
							       :default (default-value)
							       :allow-other-keys t
							       args))))
			     (cons
			       (when sequence-p
				 (unless string-p
				   (when (member-if #'stringp argument-value)
				     (setq argument-value
					   (loop for value in argument-value
						 collect (if (stringp value)
							     (accept-from-string
							       sequence-type value)
							     value)))))))
			     (atom
			       (when sequence-p
				 (setq argument-value (list argument-value)))))))
		     (values argument-value presentation-type))))))
      (using-resource (*standard-input* null-cp-input-stream)
	(let ((*parsing-mode* :parse-for-effect))
	  (cons command-name
		(funcall (fdefinition `(command-parser-function ,command-name))
			 #'parser)))))))
