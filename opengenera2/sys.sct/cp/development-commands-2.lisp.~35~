;;; -*- Syntax: Zetalisp; Mode: LISP; Package: SYSTEM-INTERNALS; Base: 8; Lowercase: T -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Clean commands

;;; We define the act of "cleaning" as expunge all directories that are
;;; encompassed by the source spec, deleting old versions, etc.  I.e.,
;;; even if no files are deleted, expunging may be appropriate.

;;; Same as Clean Directory, but with a different default and prompt for its file argument.
(cp:define-command (com-clean-file :command-table "File")
    ((files '((cl:sequence ((fs:pathname) :default-version :wild)))	;hmmm
	    ;; how do we make the :WILD type survive across merges?
	    :default `(,(send (si:pathname-history-first-pathname)
			      :new-version :wild))
	    :prompt "file"
	    :confirm t
	    :documentation "The pathname(s) of file(s) to delete extra versions of")
     &key
     (keep-versions 'number
		    :default zwei:*file-versions-kept*
		    :documentation "The number of newest copies of each file to leave undeleted.")
     ;; Spec says YES, NO, ASK.  What does ASK mean?
     ;; I'm making this a BOOLEAN
     (query-each 'boolean
		 :default t
		 :documentation "Ask before deleting the extra versions of each file.")
     ;; Not sure what options should be here...
     ;; Spec says "QUERY-EACH", but what does that mean?
     ;; I'm saying that ASK means ASK before expunging each
     ;; dir.
     (expunge '((cl:member :yes :no :ask))
	      :default :ask
	      :documentation "Expunge the directory after deletion."))
   (loop for file in files do
     (zwei:reap-directory file keep-versions standard-output standard-output
			  :query-each query-each :expunge expunge)))

;;; Same as Clean File, but with a different default and prompt for its file argument.
(cp:define-command (com-clean-directory :command-table "Directory")
    ((files '((cl:sequence ((fs:pathname) :default-version :wild)))	;hmmm
	    ;; how do we make the :WILD type survive across merges?
	    :default `(,(send (si:pathname-history-first-pathname)
			      :new-pathname
			      :name    :wild
			      :type    :wild
			      :version :wild))
	    :prompt "files"
	    :confirm t
	    :documentation "The pathname(s) of file(s) to delete extra versions of")
     &key
     (keep-versions 'number
		    :default zwei:*file-versions-kept*
		    :documentation "The number of newest copies of each file to leave undeleted.")
     ;; Spec says YES, NO, ASK.  What does ASK mean?
     ;; I'm making this a BOOLEAN
     (query-each 'boolean
		 :default t
		 :documentation "Ask before deleting the extra versions of each file.")
     ;; Not sure what options should be here...
     ;; Spec says "QUERY-EACH", but what does that mean?
     ;; I'm saying that ASK means ASK before expunging each
     ;; dir.
     (expunge '((cl:member :yes :no :ask))
	      :default :ask
	      :documentation "Expunge the directory after deletion."))
   (loop for file in files do
     (zwei:reap-directory file keep-versions standard-output standard-output
			  :query-each query-each :expunge expunge)))

;;; Compare commands

(cp:define-command (com-show-differences :command-table "File")
    ((file-1 'fs:pathname :confirm t :prompt "between file"
      :documentation "First file to be compared")
     (file-2 'fs:pathname :confirm t :prompt "and file"
      :display-default nil
      :documentation "Second file to be compared")
     &key
     ((:ignore to-ignore) '((scl:subset :indentation :case-and-style))
      :default nil :prompt nil
      :documentation "Aspects to ignore when searching for file differences:
	Indentation	whitespace at beginnings of lines
	Case-and-Style	alphabetic case and character style"))
   (if (equal file-1 file-2)
       (progn (beep)
	      (format t "  The two files given, ~A and ~A, are the same." file-1 file-2))
     ;; In spite of :confirm t, file-2 can be nil when using noun-verb order
     ;; So read the argument here
     (unless file-2
       (setq file-2 (accept 'fs:pathname :default (send file-1 :new-version :newest)
			    :confirm t :prompt "compare to file")))
     (labels ((compare (file &optional deleted)
		(condition-case (error)
		     (condition-case-if (not deleted) ()
			  (srccom:source-compare file (send file-1 :translate-wild-pathname
							    (fs:merge-pathnames file-2 file-1)
							    file)
						 standard-output t
						 :ignore-case-and-style
					         (memq :case-and-style to-ignore)
						 :ignore-whitespace
					         (memq :indentation to-ignore)
						 :deleted deleted)
			(fs:file-not-found (compare file t)))
		   (fs:file-operation-failure (format t "~&Error: ~~A~" error)))))
       (if (send file-1 :wild-p)
	   (condition-case (err-or-files)
		(cdr (fs:directory-list file-1 ':sorted))
	      (fs:file-operation-failure (format t "~&Error: ~~A~" err-or-files))
	      (:no-error
		(loop for (file) in err-or-files do
		  (compare file))))
	 (compare file-1)))))

(scl:define-presentation-to-command-translator com-show-differences
   (fs:pathname
     ;; This tester is so :Compare File
     ;; doesn't show up in the click-right menu
     ;; for directories
     :tester ((pathname &key presentation)
	      (and (neq (dw:presentation-type presentation) 'fs:directory-pathname)
		   (not (zl:get (send pathname :canonical-type) :binary-file-byte-size))
		   (fs:pathname-sequentially-accessible-p pathname)))
     :gesture nil)
   (pathname)
  `(com-show-differences ,pathname))

;;; Very simple-minded directory comparer.  Can fix it up later.
;;; Should share common subroutine with Show Directory.
(defun simple-compare-directories (dir1 dir2 &key ignore-versions)
  (flet ((pathname-equal (thing-one thing-two)
	   (and (car thing-two)
		(or (null (car thing-one))
		    (and (cl:equalp (send (car thing-one) :name)
				    (send (car thing-two) :name))
			 (cl:equalp (send (car thing-one) :type)
				    (send (car thing-two) :type))
			 (or ignore-versions
			     (cl:equalp (send (car thing-one) :version)
					(send (car thing-two) :version))))))))
    (macrolet ((format-directory (files directory order)
		 `(dw:with-resortable-output
		    ((,directory ,order)
		     (:name (lambda (x y)
			      (fs:pathname-lessp (car x) (car y))))
		     (:type (lambda (entry1 entry2)
			      (let* ((path1 (car entry1))
				     (path2 (car entry2))
				     (type1 (send path1 :type))
				     (type2 (send path2 :type)))
				(if (string-equal type1 type2)
				    (fs:pathname-lessp path1 path2)
				  (string-lessp type1 type2)))))
		     (:smallest-first
		       (lambda (x y)
			 (< (or (cl:getf (cdr x) :length-in-blocks) 1000000)
			    (or (cl:getf (cdr y) :length-in-blocks) 1000000))))
		     (:largest-first (lambda (x y)
				       (> (or (cl:getf (cdr x) :length-in-blocks) 1000000)
					  (or (cl:getf (cdr y) :length-in-blocks) 1000000))))
		     (:oldest-first (lambda (x y)
				      (< (or (get x :creation-date)
					     (get x :file-creation-date)
					     1_40)
					 (or (get y :creation-date)
					     (get y :file-creation-date)
					     1_40))))
		     (:newest-first (lambda (x y)
				      (> (or (get x :creation-date)
					     (get x :file-creation-date)
					     1_40)
					 (or (get y :creation-date)
					     (get y :file-creation-date)
					     1_40)))))
		    ()
		    (zwei:list-directory-internal ,files ,directory
						  #'present-directory-element))))
      ;; Turn them into real pathnames
      (setq dir1 (fs:parse-pathname dir1)
	    dir2 (fs:parse-pathname dir2))
      (let* ((dirlist1 (cdr (fs:directory-list dir1)))
	     (dirlist2 (cdr (fs:directory-list dir2)))
	     (list1not2 (cl:set-difference dirlist1 dirlist2 :test #'pathname-equal))
	     (list2not1 (cl:set-difference dirlist2 dirlist1 :test #'pathname-equal))
	     (order1 :name)
	     (order2 :name)
	     val1 val2)
	;; First pass, simply sort directory-lists alphabetically.
	;; Worry about performance later.
	;; Don't use val1 and val2 right now.
	(setq list1not2 (cl:sort list1not2 #'fs:pathname-lessp :key #'car)
	      list2not1 (cl:sort list2not1 #'fs:pathname-lessp :key #'car))
	(setq val1 (cl:map 'list #'car list1not2)
	      val2 (cl:map 'list #'car list2not1))
	(format t "~&Comparison of ~A with ~A:~2&" dir1 dir2)
	(cond ((or list1not2 list2not1)
	       ;; if there are any differences:
	       (when (null dirlist1)
		 (format t "~&No files match ~A.~%" dir1)
		 (terpri))
	       (when list1not2
		 (format t "~&Files in ~A but not in ~A:~%" dir1 dir2)
		 (format-directory `(,dir1) list1not2 order1)
		 (terpri))
	       (when (null dirlist2)
		 (format t "~&No files match ~A.~%" dir2))
	       (when list2not1
		 (format t "~&Files in ~A but not in ~A:~%" dir2 dir1)
		 (format-directory `(,dir2) list2not1 order2)))
	      ((null dirlist1)
	       (when (null dirlist1)
		 (format t "~&No files match ~A.~%" dir1))
	       (when (and (null dirlist2) (neq dir1 dir2))
		 (format t "~&No files match ~A.~%" dir2)))
	      (t (format t "~&No differences encountered.~%")))
	(values val1 val2)))))

(cp:define-command (com-compare-directories :command-table "Directory")
    ((from-pathname '((fs:pathname) :default-version :wild)
		    :default (send (pathname-history-first-pathname)
				   :new-pathname
				   :name ':wild
				   :type ':wild
				   :version ':wild)
		    :prompt "first directory")
     (to-pathname '((fs:pathname) :default-version :wild)
		  :default from-pathname
		  :prompt "second directory"
		  :confirm t)
     &key
     (ignore-versions 'boolean
		      :default nil
		      :mentioned-default t))
   (simple-compare-directories from-pathname to-pathname
			       :ignore-versions ignore-versions))

;;; Compile commands

(defvar *file-compilers* '(:use-canonical-type))
(defvar *file-compiler-info-list* nil)

(defmacro associate-compiler-info (compiler-name function-name function-package-name)
  `(progn
     (cl:pushnew ,compiler-name *file-compilers*)
     (let ((new-element (list ,compiler-name ,function-name ,function-package-name)))
       (setq *file-compiler-info-list*
	     (cons new-element (cl:delete ,compiler-name *file-compiler-info-list*
					  :key #'car))))))

(associate-compiler-info :fortran "COMPILE-FORTRAN-FILE" "F77")
(associate-compiler-info :prolog "COMPILE-PROLOG-FILE" "COMPILER")
(associate-compiler-info :pascal "COMPILE-PASCAL-FILE" "Pascal")
(associate-compiler-info :lisp "COMPILE-FILE" "COMPILER")
(associate-compiler-info :c "COMPILE-C-FILE" "C-SYS")

(cp:define-command (com-compile-file :command-table "System Maintenance")
    ((file '((cl:sequence fs:pathname))
	   :default (let ((file (dw:presentation-type-default 'cl:pathname)))
		      (when file
			(unless (member (send file :canonical-type)D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD NIL) "CPTFONTCB") 0*file-compilers*)
			  (setq file (send file :new-pathname :canonical-type :lisp)))
			(list file)))
	   :confirm t
	   :prompt "file"
	   :documentation "What file to compile")
     &key
     (binary-file '((token-or-type (("Default" . nil)) fs:pathname))
		  :default nil
		  :documentation "File in which to put the result")
     (compiler `((cl:member1 0,@*file-compilers*))
	       :default :use-canonical-type
	       :documentation "Which compiler to use")
     (load '((cl:member :yes :no :ask))
	   :mentioned-default :yes
	   :default :no
	   :documentation "Whether to load each compiled file")
     (query '((cl:member :yes :no :ask))
	    :mentioned-default :yes
	    :default :no
	    :documentation "Whether to ask before compiling each file")
     (silently 'boolean
	       :default t
	       :documentation "Whether to print a line as each file is compiled")
     (compiler-context 'scl:boolean
		       :documentation "Inherit existing compiler environment"
		       :when (eq compiler :lisp)
		       :default t))
   (labels ((barf (compiler-type)
	      (format nil "I don't know how to compile ~A files yet." compiler-type))
	    (invoke-compiler-internal (name pkg file binary-file)
	      (let ((.package. (pkg-find-package pkg :find)))
		(cond (.package.
		       (let ((function (intern-soft (scl:string-thin name) .package.)))
			 (cond ((and function (fdefinedp function))
				(let ((result-bin
					(if binary-file
					    (funcall function file binary-file)
					  (funcall function file))))
				  (values nil result-bin)))	;return NIL for the err value
			       (t (barf compiler)))))
		      (t (barf compiler)))))
	    (invoke-compiler (file binary-file compiler silently)
	      (let* ((compiler (if (eq compiler :use-canonical-type)
				   (send file :canonical-type)
				   compiler))
		     (compiler-options
		       (cl:find compiler1 0*file-compiler-info-list* :key #'car)))
		(if (null compiler-options)
		    (format nil "Unknown file type: ~A" compiler)
		    (scl:destructuring-bind (ignore compiler-function function-package)
		       compiler-options
		      (unless silently
			(format t "Compiling file ~A~@[ into file ~A~]." file binary-file))
		      (invoke-compiler-internal
			compiler-function function-package file binary-file)))))
	    (invoke-compiler-and-load (file compiler load silently wild-pathname)
	      (let ((binary-file
		      (when binary-file
			(send wild-pathname :translate-wild-pathname
			      (fs:merge-pathnames
				binary-file (fs:default-pathname
					      file nil *default-binary-file-type* :newest))
			      file))))
		(multiple-value-bind (err result-bin)
		    (invoke-compiler file binary-file compiler silently)
		  (if err
		      (format t "~&Error: ~A" err)
		    (let ((load-file
			    (or (when (typep result-bin 'fs:pathname) result-bin)
				binary-file
				(send file :new-pathname :type nil :version nil))))
		      (if (or (eq load :yes)
				(and (eq load :ask)
				     (cl:y-or-n-p " Load ~A? " load-file)))
			  (load load-file)
			(format t "~& ~A compiled." file))))))))
     (si:inhibit-lengthy-background-updates
       (compiler:compiler-context-bind (:condition (and #+++ignore (eq compiler :lisp)
							compiler-context)
					:inherit-existing-environment t)
	 (loop for file in file doing
	   (let ((pathname (fs:merge-pathnames file)))
	     (if (send pathname :wild-p)
		 (let ((files (condition-case (err)
				   (cdr (fs:directory-link-opaque-dirlist
					  pathname :sorted))	;need slow..
				 (fs:file-operation-failure
				   (format t "~&Error: ~~A~" err)))))
		   (cond (files
			  (when (eq query :ask)
			    (setq query (if (fquery nil "Ask whether to compile each file? ")
					    :yes :no)))
			  (loop for plist in files
				as (file) = plist
				doing
			    (cond ((get plist ':directory))
				  ((or (eq query :no)
				       (fquery nil "Compile file ~A? " file))
				   (invoke-compiler-and-load
				     file compiler load silently pathname)))
				finally (return t)))
			 (t
			  (format t "~&~A matches no files.  None compiled." pathname))))
		 (when (or (eq query :no)
			   (fquery nil "Compile file ~A? " pathname))
		   (invoke-compiler-and-load pathname compiler load silently pathname)))))))))

;;;--- this demonstrates a CP bug when you try to use No File.
(cp:define-command (com-save-compiler-warnings :command-table "Debugging")
		   ((pathname 'cl:pathname
			      :default (fs:default-pathname nil nil ':cwarns)
			      :confirm t
			      :prompt "pathname"
			      :documentation "file to save compiler warnings in")
		    ;; --- it would be some work to scan the warnings and
		    ;; --- see what files were represented.
		    (files 'scl:((token-or-type
				  (:All
				    ("No File" . nil))
				  ((sequence
				     pathname))))
			   :prompt "save warnings for files"
			   :default :all))
  (with-open-file (out pathname :direction :output)
    (print-compiler-warnings (if (eq files :all) nil files) out)))

(cp:define-command (com-show-compiler-warnings :command-table "Debugging")
    (
     ;; --- it would be some work to scan the warnings and
     ;; --- see what files were represented.
     (files 'scl:(token-or-type (:all ("No File" . nil))
		   (sequence ((pathname) :default-type nil :default-version nil)))
	    :prompt "show warnings for files"
	    :default :all))
  (print-compiler-warnings (if (eq files :all) nil files) standard-output))

;;; Edit commands

(defun definition-type-name-p (symbol)
  (get symbol 'definition-type-name))

(defun definition-types-for-function-spec (function-spec)
  (if (and (listp function-spec)
	   (memq (car function-spec) flavor::*accessor-method-types*))
      '(("Function" . defun)
	("Flavor" . defflavor)
	("Any" . any))
    (let ((source-file-spec (function-spec-get function-spec :source-file-name)))
      (append
	(cond ((null source-file-spec) ())
	      ((atom source-file-spec) '(("Function" . defun)))
	      (t (loop for (type . nil) in source-file-spec
		       collect (cons (or (get type 'definition-type-name) type)
				     type))))
	'(("Any" . any))))))

(define-presentation-type definition-type-name ((&optional function-spec))
   :parser ((stream &key original-type initially-display-possibilities)
	    (values (accept `(scl:alist-member					      
			       :alist ,(definition-types-for-function-spec function-spec))
			    :stream stream
			    :original-type original-type
			    :prompt nil
			    :initially-display-possibilities
			      initially-display-possibilities)))
   :printer ((type stream)
	     (let ((name (get type 'definition-type-name)))
	       (if (or (null name)
		       (eq type 'any))
		   (format stream "~:(~A~)" type)
		 (princ name stream))))
   :describer ((stream &key plural-count)
	       (when (numberp plural-count)
		 (setq plural-count (> plural-count 1)))
	       (format stream
		   "~:[a ~;~]symbol~:*~:[~;s~] that name~:*~:[s~;~] a type of definition of ~S"
		 plural-count function-spec)))

(cp:define-command (com-edit-definition :command-table "Debugging"
					:provide-output-destination-keyword nil)
    ((name 'function-spec
	   :display-default nil :confirm t :prompt "name"
	   :documentation "Name of something (such as a function) whose definition to edit")
     (type `((definition-type-name ,name))
	   :default 'any :confirm nil :prompt "type"
	   :documentation "Type of definition to edit"))
  ;; Check for flavor accessor pseudo function specs
  (when (and (eq type 'defun)
	     (listp name)
	     (memq (car name) flavor::*accessor-method-types*))
    (format t "~&The accessor for ~S is defined by the flavor ~S"
      (flavor::accessor-instance-variable name)
      (flavor:method-flavor name))
    (setq name (flavor:method-flavor name)
	  type 'defflavor))
  ;; If the source file of the definition is not known, let Zmacs do the complaining
  (if (eq type 'any)
      (ed `(zwei:edit-definition ,name ()))
    (ed `(zwei:edit-definition ,name (,type)))))

(define-presentation-to-command-translator edit-instance-variable-accessor
   (flavor:instance-variable-accessor
    :gesture :edit-function)
   (iv-accessor)
  `(com-edit-definition ,iv-accessor defun))

;; Put it on :select also, so it will be mouse-sensitive without holding down Meta
(define-presentation-to-command-translator edit-instance-variable-accessor-2
   (flavor:instance-variable-accessor
    :gesture :select)
   (iv-accessor)
  `(com-edit-definition ,iv-accessor defun))

(define-presentation-to-command-translator edit-definition
   (expression
    :gesture :edit-function)
   (expression)
  (multiple-value-bind (function-spec definition-type)
      (zwei:expression-to-function-spec expression nil t nil nil t)
    (when function-spec
      (if definition-type
	  `(com-edit-definition ,function-spec ,definition-type)
	`(com-edit-definition ,function-spec)))))

(cp:define-command (com-edit-directory :provide-output-destination-keyword nil
				       :command-table "Directory")
    ((directory '((fs:pathname) :default-version :wild)
		:default (send (pathname-history-first-pathname)
			       ':new-pathname
			       ':name ':wild ':type ':wild ':version ':wild)
		:documentation "Directory to be edited")
     &key
     ;; this needs to be defined, designed and implemented
;		    (property ((:enumeration :some-stuff))
;			      :default nil
;			      :allow-multiple t
;			      :documentation "File properties to display")
     ;; this needs to be designed and implemented
;		    (order ((:enumeration :alphabetical :chronological))
;			   :allow-multiple t
;			   :default '(:alphabetical :chronological)
;			   :documentation "Keys, major  minor, on which to sort the display")
     (version '((cl:member :all :newest :number))  
	      :default :all
	      :documentation "Versions of the files to be shown"))
   (setq version
	 (selectq version
	   (:all ':wild)
	   (:newest ':newest)
	   (:number (prompt-and-read
		      :number
		      (format nil "Version number for ~A to include in the editable set: "
			      directory)))))
   (let ((default-pathname (fs:default-pathname))
	 (pathname))
     (setq default-pathname (send default-pathname ':new-pathname
				  ':name ':wild ':type ':wild ':version ':wild))
     (setq pathname (fs:merge-pathnames directory default-pathname version))
     ;; we're not actually doing anything with :property and :order yet,
     ;;  but the interface is there...
     (ed (list 'zwei:directory pathname :property nil :order nil))))

;; The definition of SI:COM-EDIT-FILE has been scattered to the wind.
;; For more information, do m-. of SI:DEFINE-FILE-EDITOR and SI:*ALL-FILE-EDITORS*.

;; The definition of SI:COM-EDIT-FILE has been scattered to the wind.
;; For more information, do m-. of SI:DEFINE-FILE-EDITOR and SI:*ALL-FILE-EDITORS*.

(scl:define-presentation-to-command-translator com-edit-file
   (fs:pathname
     :gesture :edit-function
     :tester ((pathname &key presentation)
	      ;; It's OK to edit directories
	      (or (eq (dw:presentation-type presentation) 'fs:directory-pathname)
		  (and (fs:pathname-sequentially-accessible-p pathname)
		       ;; edit file will edit a file if it is acceptable
		       ;; to some editor
		       (stack-let ((pathnames `(,pathname)))
			 (loop for editor in *all-file-editors*
			     thereis (null (verify-editor editor pathnames))))))))
   (pathname &key presentation)
  (if (and (eq (dw:presentation-type presentation) 'fs:directory-pathname)
	   (operation-handled-p pathname :pathname-as-directory))
      `(com-edit-directory ,(send (send pathname :pathname-as-directory)
				  :new-pathname :name :wild :type :wild :version :wild))
      `(com-edit-file (,pathname))))

(cp:define-command (com-show-editor-buffer :command-table "Editing")
    ((buffer 'zwei:buffer
	     :prompt "named"
	     :documentation "Buffer to show."))
   (format t "~&----- Buffer ~S -----~%" (send buffer :name))
   (let ((stream (zwei:interval-stream buffer)))
     (cl:loop
	(multiple-value-bind (line eof-p)
			     (send stream :line-in)
	  (when eof-p (return))
	  (format t "~&~A~%" line)))))


;;; Command for documentation-strings

(cp:define-command (com-show-definition-documentation :command-table "Documentation")
    ((name 'function-spec
	   :display-default nil :confirm t :prompt "name"
	   :documentation "Show the documentation string in the definition of this function, variable, flavor, etc.")
     (type `((definition-type-name ,name))
	   :default (multiple-value-bind (nil type)
			(get-definition-and-sage-documentation name 'any)
		      (or type 'any))
	   :confirm nil :prompt "type"
	   :documentation "Type of definition to show the documentation of"))
   (multiple-value-bind (name type string sage)
       (get-definition-and-sage-documentation name type)
     (format t "~&~@[~A ~]~S~:[ has no explicit documentation string in its definition.~;~
		: ~:*~A~]"
	     (definition-type-name type) name string)
     (when sage
       (format t "~&For detailed documentation, use the (2 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")Document0 2Examiner0 or execute")
       (when (cdr sage) (format t " one of"))
       (dolist (record-group sage)
	 (format t "~&~2@T")
	 (present `(sage::com-show-documentation ,record-group) 'cp:command
		  :acceptably :very :for-context-type 'cp:command-or-form
		  :allow-sensitive-inferiors nil)))))

(define-presentation-to-command-translator show-definition-documentation
		(expression :gesture nil)	;too slow for any gesture other than menu
		(expression)
  (multiple-value-bind (name type)
      (zwei:expression-to-function-spec expression nil t nil)
    (unless (or name type)
      (if (and expression (symbolp expression))
	  (setq name expression)
	  (return-from show-definition-documentation nil)))
    (multiple-value-bind (name type string sage)
	(get-definition-and-sage-documentation name type)
      (when (or string sage)
	`(com-show-definition-documentation ,name ,type)))))

;; Name returned can be different if generic function inherits from method or vice versa
;; If type is nil or any, it defaults
;; Sage documentation types aren't the same space as definition-types, so we
;; have to be content with finding any and all Sage documentation for the specified name
(defun get-definition-and-sage-documentation (name type &optional recursive)
  (declare (values name type string sage))
  (when (or (null type) (eq type 'any))
    (setq type (cond ((fdefinedp name) 'defun)
		     ((not (symbolp name)) nil)
		     ((get name 'special) 'defvar)
		     ((get name 'flavor::flavor) 'defflavor)
		     ((get name 'si:defstruct-description) 'defstruct))))
  (when (and name type)
    (let ((string (documentation name type))
	  (sage (and (variable-boundp #'sage:find-record-group-for-topic-and-type)
		     (sage:find-record-group-for-topic-and-type name nil))))
      (unless (or string sage (neq type 'defun) recursive)
	(cond ((and (listp name)
		    (memq (first name) 'flavor:(method wrapper whopper ncwhopper)))
	       (multiple-value-bind (nil nil new-string new-sage)
		   (get-definition-and-sage-documentation (flavor:method-generic name) type t)
		 (when (or new-string new-sage)
		   (setq string new-string sage new-sage name (flavor:method-generic name)))))
	      ((and (cl:typep name 'generic-function-name)
		    (flavor:find-generic-function name nil))
	       (loop for method in (flavor:generic-function-methods name) do
		 (when (memq (flavor:method-type method) flavor:*fdefinable-method-types*)
		   (multiple-value-bind (nil nil new-string new-sage)
		       (get-definition-and-sage-documentation method type t)
		     (when (or new-string new-sage)
		       (return
			 (setq string new-string sage new-sage name method)))))))))
      (values name type string sage))))

;;; Find commands

;; Define a presentation-type so that we get our own history
(define-presentation-type several-strings ()
   :expander `((cl:sequence string))
   :printer ((strings stream)
	     (scl:format-textual-list strings #'prin1 :stream stream :finally ", "))
   :description "string(s) to search for"
   :history t)

(defvar *all-symbol-types*
	'(:variable :function :class :flavor :resource :unbound :presentation-type :all-types))

(scl:define-presentation-type symbol-type ()
   :abbreviation-for `((scl:subset ,@*all-symbol-types*)
		       :description "a symbol type")
   :description "one or more symbol types"
   :choose-displayer
     ((stream object query-identifier &key original-type)
      (dw::accept-values-choose-from-sequence
	stream *all-symbol-types*
	object query-identifier
	:type original-type
	:multiple-choices t
	:id-test #'eql 			;; we could probably just use the default here.
	:printer #'(lambda (o s)
		     (format s "~:(~A~)" o))
	:select-action #'(lambda (new list)
			   (if (eq new :all-types)
			       '(:all-types)
			     (if (cl:member new list)
				 (let ((new-list (cl:remove new list)))
				   (if (null new-list)
				       '(:all-types)
				     new-list))
			       (cl:remove :all-types (cl:adjoin new list)))))))
   )

(cp:define-command (com-find-symbol :command-table "Debugging")
		   ((name-fragments 'several-strings
				    :prompt "substring(s)"
				    :documentation "Substrings of the symbol to find")
		    &key
		    (packages '((scl:token-or-type (:All)
						   ((cl:sequence cl:package))))
			      :prompt "to search"
			      :default `(,package)
			      :documentation "Packages in which to search")
		    (search-inherited-symbols 'boolean
					      :default t
					      :documentation
					      "Whether to search imported symbols")
		    (search-packages-used-by 'boolean
					     :default nil
					     :mentioned-default t
					     :documentation
					     "Whether to search packages used by these packages")
		    (search-packages-using 'boolean
					   :default nil
					   :mentioned-default t
					   :documentation
					   "Whether to search packages that use these packages")
		    (symbol-type 'symbol-type
				 :name "Type"
				 :default '(:all-types)
				 :documentation "Kinds of symbols to search for")
		    (verbose 'boolean
			     :default nil
			     :mentioned-default t
			     :documentation "Whether to show names of packages in which no symbols were found."))
  (let ((all (or (eq packages :all)		; the old way
		 (and (= (length packages) 1)
		      (eq (first packages) :all)))))
    ;; -- get around bug in SCL:SUBSET
    (when (eq symbol-type nil)
      (setq symbol-type '(:all-types)))
    ;; Display the intent
    (send standard-output :fresh-line)
    (cl:write-string "Searching ")
    (if all
	(cl:write-string "all packages")
	(format-textual-list packages #'princ :conjunction "and"))
    (format t " for ~:[~A~;all~*~] symbols with names containing "
	    (memq :all-types symbol-type)
	    (with-output-to-string (s)
	      (format-textual-list symbol-type #'(lambda (thing stream)
						   (format stream "~(~A~)" thing))
				   :conjunction "and" :stream s)))
;	    (string-downcase symbol-type))
    (formatting-textual-list (t :conjunction "and")
      (loop for fragment in name-fragments do
	(formatting-textual-list-element (t)
	  (cl:write-string (string-upcase fragment)))))
    
    (when all (setq packages si:*all-packages*))
    (let ((progress-denominator 0)
	  (progress-numerator 0)
	  this-package package-name-printed)
      (tv:noting-progress ("Searching for symbols")
	(labels ((find-appropriate-symbols (symbol)
		   (when (loop with symbol-name = (get-pname symbol)
			       for fragment in name-fragments
			       always (string-search fragment symbol-name))
		     (unless (or verbose package-name-printed)
		       (format t "~&In package ~A" this-package)
		       (setq package-name-printed t))
		     (display-symbol-and-definitions symbol symbol-type)))
		 (search-one-package (a-package)
		   (tv:note-progress (incf progress-numerator) progress-denominator)
		   (setq package-name-printed nil
			 this-package a-package)
		   (when verbose (format t "~&In package ~A" a-package))
		   (mapatoms #'find-appropriate-symbols a-package
			     ;; Don't search inherited symbols if we are going to search
			     ;; the used-by packages later anyway
			     (and search-inherited-symbols (not search-packages-used-by))))
		 (map-over-packages (function)
		   (loop for top-level-package in packages do
		     (funcall function top-level-package)
		     (when search-packages-using
		       (dolist (usee (package-used-by-list top-level-package))
			 (unless (eql usee top-level-package)
			   (funcall function usee))))
		     (when search-packages-used-by
		       (dolist (user (pkg-self-and-use-list top-level-package))
			 (unless (eql user top-level-package)
			   (funcall function user)))))))
	  (map-over-packages
	    ;; Just count packages, not symbols.  The PKG-NUMBER-OF-SYMBOLS information
	    ;; doesn't count inherited symbols, so this is not going to return a valid
	    ;; denominator if you try to compute per-symbol info unless you do a lot more
	    ;; work. -kmp 4-Oct-92
	    (lambda (pkg)
	      (declare (ignore pkg))
	      (incf progress-denominator #|(pkg-number-of-symbols pkg)|#)))
	  (map-over-packages #'search-one-package)))
      (format t "~& ... Done"))))

(defun display-symbol-and-definitions (symbol symbol-type)
  ;; this is at the top since the LETted state vars have to be
  ;; bound inside the body to avoid side-effect lossage
  ;; Use the filling stream after it works and is fast enough
  ;(filling-output (t :fill-on-spaces t :after-line-break "    ")
    (formatting-textual-list (t)
      (let ((printed-symbol nil)
	    (printed-delimiter nil))
	;; We only want to print the symbol name if at least one of the
	;; WHEN clauses below is true, and we only want to print the
	;; post-symbol delimiter when we know that there is at least one
	;; definition type following.
	(labels ((print-definition-type (symbol type-name)
		   (unless printed-symbol
		     ;; Binding the package to NIL forces the package to be printed.
		     ;; This is better than explicitly printing the package, because
		     ;; this way you get the "short" version.
		     (let ((package nil))
		       (format t "~&  ")
		       (present symbol (cond ((fboundp symbol) 'sys:function-spec)
					     ((boundp symbol) 'sys:form)
					     (t 'sys:expression))))
		     (setq printed-symbol t))
		   (when type-name
		     (unless printed-delimiter
		       (cl:write-string " - ")
		       (setq printed-delimiter t))
		     (formatting-textual-list-element ()
		       (cl:write-string type-name))))
		 (searching-for-appropriate-type (type-name)
		   (or (memq ':all-types symbol-type)
		       (memq type-name symbol-type))))
	  
	  ;; The following WHEN clauses check for the various ways that the
	  ;; symbol may be defined.
	  (when (searching-for-appropriate-type :unbound)
	    ;; No value or definition, but symbol does exist
	    (print-definition-type symbol nil))
	  (when (searching-for-appropriate-type :function)
	    (when (fboundp symbol)
	      (print-definition-type
		symbol
		(condition-case (error)
		     (with-output-to-string (stream)
		       (format stream "Function ")
		       (lt:print-lambda-list (arglist symbol) stream :brief t :error-p nil))
		   (error (format nil "Garbage function (~~A~)" error))))))
	  (when (searching-for-appropriate-type :variable)
	    (when (boundp symbol)
	      (print-definition-type symbol "Bound")))
	  (when (searching-for-appropriate-type :class)
	    (when (and (not (null symbol))
		       (clos:find-class symbol nil))
	      (print-definition-type symbol "Class")))
	  (when (searching-for-appropriate-type :flavor)
	    (when (and (not (null symbol))
		       (flavor:find-flavor symbol nil))
	      (print-definition-type symbol "Flavor")))
	  (when (searching-for-appropriate-type :resource)
	    (when (get symbol 'defresource)
	      (print-definition-type symbol "Resource")))
	  (when (searching-for-appropriate-type :presentation-type)
	    ;; would use dw:presentation-type-p but that shows all flavors, etc.
	    (when (memq symbol dw::*all-presentation-types*)
	      (print-definition-type symbol "Presentation-Type")))))))

(cp:define-command (com-find-string :command-table "File")
		   ((strings 'several-strings)
		    &key
		    (files '((cl:sequence fs:pathname))
			   :documentation "Files in which to search")
		    (systems 'scl:((sequence
				     ((type-or-string ((or sct:subsystem sct:system))))))
			     :documentation "Systems in which to search")
		    (patches 'scl:boolean
			     :default t
			     :documentation "Whether to include patch files")
		    ;;--- This should be more sophisticated
		    (branch 'sct:system-branch
			    :default nil
			    :documentation "A system branch")
		    (include-components 'scl:boolean
					:default nil
					:mentioned-default t
					:documentation "Whether to include component systems of any specified systems")
		    (stop-if-found 'scl:boolean
				   :default nil
				   :mentioned-default t
				   :documentation "Stop searching the file after an occurrence is found")
		    #+++ignore
		    (nlines 'cl:integer
			    :default 1
			    :documentation "Number of lines to show"))
  (block find-string
    (unless (or files systems)
      (format error-output "~&You must specify either :FILES or :SYSTEM")
      (return-from find-string nil))
    (let ((inputs (append files systems))
	  #---ignore (nlines 1))
      (find-string-internal strings inputs
			    :patches patches
			    :nlines nlines
			    :include-components include-components
			    :system-branch branch
			    :stop-if-found stop-if-found))))

(defun find-string-internal (strings inputs
			     &key patches nlines stop-if-found
				  include-components system-branch
			     &aux (failures 0))
  nlines	;--- someday make this work
  (labels
    ((funny-pathname-lessp (f1 f2 &aux tem)
       ;; Predicate to sort pathnames in ascending alphabetical order, except
       ;; that the version numbers are sorted in descending order, so that
       ;; .NEWEST gets frobbed first.  Notice that the pathname can either be
       ;; a pathname or a list whose CAR is a pathname; we do this to avoid
       ;; consing extra lists below
       (multiple-value-bind
	 (f1-host f1-dev f1-dir f1-name f1-type f1-ver)
	   (send (if (listp f1) (car f1) f1) :all-components)
	 (multiple-value-bind
	   (f2-host f2-dev f2-dir f2-name f2-type f2-ver)
	     (send (if (listp f2) (car f2) f2) :all-components)
	   (and (zerop (setq tem (fs:pathname-component-compare f1-host f2-host)))
		(zerop (setq tem (fs:pathname-component-compare f1-dev f2-dev)))
		(zerop (setq tem (fs:pathname-component-compare f1-dir f2-dir)))
		(zerop (setq tem (fs:pathname-component-compare f1-name f2-name)))
		(zerop (setq tem (fs:pathname-component-compare f1-type f2-type)))
		(setq tem (fs:pathname-component-compare f2-ver f1-ver)))
	   (minusp tem))))
     (sorted-directory (input)
       ;; Return a sorted directory list from either a system or a pathname
       (sort (cl:etypecase input
	       (sct:basic-system
		 (let ((system-branch (or system-branch
					  (sct:system-branch-loaded input)
					  (sct:system-default-system-branch input))))
		   (sct:get-all-system-input-files
		     (sct:reload-system-declaration-if-necessary
		       input :newest system-branch)
		     :version :newest
		     :system-branch system-branch
		     :include-components include-components)))
	       (string
		 (sct:load-system-declaration-if-necessary input :newest)
		 (setq input (sct:find-system-named input))
		 (let ((system-branch (or system-branch
					  ;; We know there isn't a loaded branch here
					  (sct:system-default-system-branch input))))
		   (sct:get-all-system-input-files
		     (sct:reload-system-declaration-if-necessary
		       input :newest system-branch)
		     :version :newest
		     :system-branch system-branch
		     :include-components include-components)))
	       (fs:pathname
		 (cdr (fs:directory-list input :fast))))
	     #'funny-pathname-lessp))
     (make-strings-and-tables (strings)
       ;; Generate the Boyer-Moore tables from a list of strings
       (loop for string in strings
	     as skip = (zwei:generate-boyer-skip-table string)
	     as occur = (zwei:generate-boyer-reoccurrence-table string)
	     collect `(,string ,skip ,occur))))
    (si:with-stack-array (buffer 1000. :type 'art-fat-string :fill-pointer 0)
      (loop with strings-and-tables = (make-strings-and-tables strings)
	    for input in inputs
	    as all-files = (if (and (typep input 'fs:pathname)
				    (not (send input :wild-p)))
			       (list (list input))	;yuck
			     (sorted-directory input))
	    doing
	(loop with bogus-file-types = (sct:destination-file-types-for-distribution)
	      with match-count = 0
	      with file-count = 0
	      for spoke = nil
	      for file-frob in all-files
	      ;; Conses less than COLLECT'ing above
	      as file = (if (typep input 'fs:pathname) (car file-frob) file-frob)
	      as skip-reason =
		 (cond ((and (null patches)
			     (%string-equal (send file :name) 0 "patch-" 0 6))
			"a patch file")
		       ;; Don't skip .SAB files.  They are handled specially below.
		       ((eql (send file :canonical-type) :sage-binary) nil)
		       ((get (send file :canonical-type) :binary-file-byte-size)
			"a binary file")
		       ((mem #'string-equal
			     (send file :canonical-type) bogus-file-types)
			"an SCT product file")
		       (t nil))
	      doing
	  (if skip-reason
	      (progn 
		(incf failures)
		(format error-output
			"~&Skipping file ~A because it is ~A" file skip-reason))
	    (catch 'next-file
	      (catch-error-restart ((error) "Skip searching ~A" file)
		(error-restart ((error) "Retry searching ~A" file)
		  (if (eql (send file :canonical-type) :sage-binary)
		      ;; Searching a .SAB file
		      (multiple-value-bind (çmatch-count çfile-count çfailures)
			  (sage::find-wt-strings strings file :stop-if-found stop-if-found)
			(incf match-count çmatch-count)
			(incf file-count çfile-count)
			(incf failures çfailures))
		    (condition-case (error)
			 (with-open-file (stream file :preserve-dates t)
			   (loop with line = 0
				 doing
			     (multiple-value-bind (nchars eof more-p)
				 (send stream :string-line-in nil buffer)
			       (when (and eof (zerop nchars))
				 (return nil))
			       (when (loop for (pattern skip occur)
					       in strings-and-tables
					   thereis (zwei:boyer-search-internal
						     pattern buffer skip occur
						     0 (string-length buffer)))
				 (when (not spoke)
				   (if stop-if-found
				       (format t "~&")
				       (format t "~&~%"))
				   (scl:present file)
				   (setq spoke t)
				   (incf file-count))
				 (when stop-if-found
				   (incf match-count)
				   (throw 'next-file t))
				 (incf match-count)
				 (format t "~&Line #~D:~12T~A" line buffer))
			       (when (not more-p) (incf line)))))
		       (fs:file-not-found
			 (incf failures)
			 (format error-output
				 "~&~%Skipping file ~A because it could not be found" file))
		       (fs:invalid-operation-for-directory
			 ;; I don't think that anyone thinks of the .directory files as "files"
			 #+ignore #+ignore
			 (incf failures)
			 (format error-output
				 "~&~%Skipping file ~A because it is a directory" file))
		       (fs:qinvalid-byte-size
			 (incf failures)
			 (format error-output
				 "~&~%Skipping file ~A.~%  ~a"
				 file (send error :error-description)))))))))
	      finally
		(if (zerop match-count)
		    (format t "~%No lines matched ")
		    (if stop-if-found
			(format t "~2%The string was found in ~D file~:P "
				file-count)
			(format t "~2%~D line~:P matched in ~D file~:P "
				match-count file-count)))
		(format t "(~D file~:P searched"
			(- (length all-files) failures))
		(if (zerop failures)
		    (format t ")")
		    (format t ", ~D file~:P skipped)"
			    failures)))))))

(cp:define-command (com-set-base :command-table "Evaluation Context"
				 :provide-output-destination-keyword nil)
    ((new-base 'cl:integer			;should there be a range check on new-base?
	       :prompt "number base"
	       :default 10.))
   (flet ((set-standard-values (var new-value)
	    (cl:setf (standard-value var :global-p t :setq-p t) new-value
		     (standard-value var :setq-p t) new-value)))
     (set-standard-values 'ibase new-base)
     (set-standard-values 'base new-base))
   (format t "~& Input and output bases set to ~D." new-base))

(cp:define-command (com-set-input-base :command-table "Evaluation Context"
				       :provide-output-destination-keyword nil)
    ((new-base 'cl:integer			;should there be a range check on new-base?
	       :prompt "number base"
	       :default 10.))
   (when (neq base new-base)
     (format t "~& Caution: The input base is being set to ~D, but the output base is ~D"
	     new-base base))
   (cl:setf (standard-value 'ibase :global-p t :setq-p t) new-base
	    (standard-value 'ibase :setq-p t) new-base))

(cp:define-command (com-set-output-base :command-table "Evaluation Context"
					:provide-output-destination-keyword nil)
    ((new-base 'cl:integer			;should there be a range check on new-base?
	       :prompt "number base"
	       :default 10.))
   (when (neq ibase new-base)
     (format t "~& Caution: The output base is being set to ~D, but the input base is ~D."
	     new-base ibase))  
   (cl:setf (standard-value 'base :global-p t :setq-p t) new-base
	    (standard-value 'base :setq-p t) new-base))

(cp:define-command (com-set-package :command-table "Evaluation Context"
				    :provide-output-destination-keyword nil)
    ((new-package '(cl:package)
		  :default (pkg-find-package "COMMON-LISP-USER")
		  :documentation "name of package to change to"
		  :prompt "a package"))
  (block try-to-set-package
    (condition-case (.error.)
	 (cl:setf (standard-value 'package :global-p t :setq-p t) new-package
		  (standard-value 'package :setq-p t) new-package)
       (error (format error-output "~&Error -- ")
	      (send .error. :report error-output)
	      (format error-output "~&Package not changed.")
	      (return-from try-to-set-package (values))))
    (format t "~& Package set to ~A" package)))

(cp:define-command (com-show-expanded-lisp-code :command-table "Debugging")
    ((form '((scl:token-or-type (nil) ((form) :edit-trivial-errors-p nil)))
	   :display-default nil
	   :provide-default t
	   :default nil)
     &key
     (repeat 'scl:boolean
	     :default nil
	     :mentioned-default t
	     :documentation "Keep expanding until nothing more can be expanded")
     (as-if-compiler 'scl:boolean
		     :default nil
		     :mentioned-default t
		     :documentation "Do the expansion exactly as the compiler would")
     (expand '((scl:subset
		 :macros :inline-functions :style-checkers
		 :optimizers :constants))
	     :default '(:inline-functions :macros)
	     :documentation "Specify what sort of things should be expanded")
     (constant-folding 'scl:boolean
		       :default nil
		       :mentioned-default t
		       :documentation "Optimize certain functions with constant arguments")
     (whole-form 'scl:boolean
		 :default nil
		 :mentioned-default t
		 :documentation "Expand all levels of the form"))
  (with-stack-list (options :compile as-if-compiler
			    :repeat repeat :all-levels whole-form
			    :do-style-checking (memq :style-checkers expand)
			    :do-macro-expansion (memq :macros expand)
			    :do-named-constants (memq :constants expand)
			    :do-inline-forms (memq :inline-functions expand)
			    :do-optimizers (memq :optimizers expand)
			    :do-constant-folding constant-folding)
    ;; Non-standard keyword argument handling by compiler
    (when (not as-if-compiler)
      (setq options (cddr options)))
    (if (null form)
	(lexpr-funcall #'si:mexp-1 nil options)
	(cl:pprint
	  (lexpr-funcall #'si:mexp-expand-form form nil options)))))

;(define-cp-command com-set-lisp-context
;		   ((mode (:enumeration :common-lisp :zetalisp)
;			  :default (select readtable
;				     (*common-lisp-readtable* :common-lisp)
;				     (standard-readtable :zetalisp)
;				     (otherwise :present-unknown-syntax))
;			  :documentation
;			  "Lisp syntax and package context to be used by default"))
;  (unless (eq mode (select readtable
;		     (*common-lisp-readtable* :common-lisp)
;		     (standard-readtable :zetalisp)
;		     (otherwise :present-unknown-syntax)))
;    (selectq mode
;      (:common-lisp
;       (setq-standard-value readtable *common-lisp-readtable*)
;       (when (cond ((eq package pkg-user-package))
;		   ((null (cl:intersection (package-use-list package)
;					   (loop for p in '("CL" "SCL")
;						 collect (pkg-find-package p))
;					   :test #'eq))
;		    (format
;		      error-output
;		     "~& Package ~A is not a Common Lisp package.  USER will be used instead."
;		      package)
;		    t))
;	 (setq-standard-value package (pkg-find-package "USER" :ERROR "CL"))))
;      (:zetalisp
;       (setq-standard-value readtable standard-readtable)
;       (when (cond ((eq package (pkg-find-package "USER" :ERROR "CL")))
;		   ((not (memq pkg-global-package (package-use-list package)))
;		    (format
;		      error-output
;		      "~& Package ~A is not a Zetalisp package.  USER will be used instead."
;		      package)
;		    t))
;	 (setq-standard-value package (pkg-find-package "USER" :ERROR "GLOBAL"))))))
;  (show-lisp-context-internal))
;
;(defun show-lisp-context-internal ()
;  (format t
;	  "~& ~A syntax is now enabled.~@
;              ~1TPackage is ~A; Input base is ~D; Output base is ~D.~%"
;	  (select readtable
;	    (*common-lisp-readtable* "Common Lisp")
;	    (standard-readtable "Zetalisp")
;	    (otherwise "An unknown"))
;	  package ibase base))

;;;
;;; Make lisp-syntax commands extensible.  These now allow for implementors
;;; to define their own lisp-syntaxes.  Consider Set Lisp Context Interlisp
;;; or Set Lisp Context Joshua.  Each lisp-syntax has a readtable that
;;; distinguishes the others, and so can be used to figure out what the current 
;;; syntax is.  Each context has a function associated with it that gets called
;;; when we enter that context.  Typically that sets readtables, base, package, 
;;; etc.
;;;
;;; ---Various Problems -- We have no notion of readtable inheritance.
;;; --- What if the readtable is already a readtable on the correct readtable?
;;; --- Since package USE is not transitive, I can define FOO to USE SCL,
;;; --- and then USE FOO, and this code will think that package is innappropriate.
;;; --- We need to use the common lisp type system to classify packages, by adding
;;; --- a TYPE slot to the package defstruct.
;;; --- The packages-must-use feature of lisp syntaxes is a temporary crock.

;;; ---Not yet converted.

(defun show-lisp-context-internal ()
  "Print out some stuff describing the current state."
  (format t
	  "~& ~A syntax is now enabled.~@
              ~1TPackage is ~A; Input base is ~D; Output base is ~D.~%"
	  (let ((current (current-lisp-syntax)))
	    (if (typep current 'si:lisp-syntax)
	        (lisp-syntax-external-name current)
		"An unknown"))
	  package ibase base)) 

(cp:define-command (com-show-lisp-context :command-table "Evaluation Context")
    ()
   (show-lisp-context-internal))

(cp:define-command (com-set-lisp-context :command-table "Evaluation Context"
					 :provide-output-destination-keyword nil)
    ((mode 'lisp-syntax
	   :default (current-lisp-syntax)
	   :documentation
	   "Readtable, package, and so on to be used by default"))
   (si:turn-on-lisp-syntax mode))

