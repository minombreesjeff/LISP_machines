;;; -*- Syntax: Zetalisp; Mode: LISP; Package: SYSTEM-INTERNALS; Base: 8; Lowercase: T -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; Command Processor commands that deal in a fundamental way with
;;; files, such as Copy File, are included in this source, along with
;;; supporting routines.

;;; Copy commands

(cp:define-command (com-copy-file :command-table "File")
    ((files '((cl:sequence fs:pathname))
		:confirm t
		:documentation "File(s) to be copied")
     (to-file #-ignore '((fs:pathname) :dont-merge-default t)
	      ;; This new UI behavior is still a matter of controversy.
	      #+ignore '((fs:pathname) :default-name :wild :default-type :wild :default-version :wild)
	      :default #-ignore (fs:default-pathname
				  (if (listp files) (first files) files) nil nil ':wild)
		       #+ignore (if (listp files) (first files) files)
	      :confirm t
	      :prompt "to"
	      :documentation "Destination directory or file")
     &key
     (byte-size '((cl:integer 1))
		:prompt "bits"
		:provide-default nil
		:documentation "Byte size in which to do copy operation")
     (copy-properties '((cl:sequence
			  ((cl:member :author :creation-date)
			   :description "file property")))
		      :default '(:author :creation-date)
		      :documentation "Properties of the file to be duplicated")
     (create-directories '((scl:alist-member
			     :alist (("Yes" :value :yes
				      :documentation "Automatically create it")
				     ("Error" :value :error
				      :documentation "Signal an error")
				     ("Query" :value :query
				      :documentation "Ask what to do then"))))
			 :default :query
			 :documentation
			 "What to do if a destination directory does not exist")
     (mode '((scl:alist-member
	       :alist (("Binary" :value :binary
			:documentation "Binary bytes of a size given by Byte Size")
		       ("Character" :value :character
			:documentation "Text characters")
		       ("Macintosh" :value :macintosh
			:documentation "Both Macintosh file forks")
		       ("Raw character" :value :raw-character
			:documentation "Text (:element-type 'cl:string-char)")
		       ("Default" :value :default
			:documentation "Determined automatically per file")))
	     :description "a copy mode")
	   ;; This is a bit too long, so stick with the description above.
	 ; :prompt "Binary, Character, Macintosh, or Default"
	   :default :default
	   :documentation "Mode in which to perform the copy")
     (query '((cl:member :yes :no :ask))
	    :mentioned-default :yes
	    :default :no
	    :documentation "Whether to ask before copying each file")
     (if-exists
      '((scl:alist-member
	  :alist (("New Version" :value :new-version
		   :documentation "Create the next version-- default if target is .newest")
		  ("Overwrite" :value :overwrite
		   :documentation "Destructively modify target")
		  ("Supersede" :value :supersede
		   :documentation "Replace the target-- default if target is not .newest")
		  ("Nothing" :value nil
		   :documentation "Do nothing if the target already exists"))))
      :default :none				;kludge to get if-exists-p
      :provide-default nil
      :mentioned-default :nothing
      :documentation "What to do if asked to copy to an existing file"))
   (let ((element-type (cl:ecase mode
			 (:binary
			   `(cl:unsigned-byte ,(or byte-size '*)))
			 (:character
			   (unless (null byte-size)
			     (cl:cerror "Ignore byte size"
					"Specification of byte size is incompatible with character mode."))
			   'cl:character)
			 (:raw-character 'cl:string-char)
			 (:macintosh
			   '(cl:unsigned-byte 8))
			 (:default
			   (cond ((null byte-size)
				  :default)
				 (t
				  `(cl:unsigned-byte ,byte-size))))))
	 (copy-author (not (null (memq ':author copy-properties))))
	 (copy-creation-date (not (null (memq ':creation-date copy-properties))))
	 (create-directories (cl:ecase create-directories
			       (:yes t)
			       (:error nil)
			       (:query :query)))
	 (need-macintosh-warning nil))
     (when (eq query ':ask)
       (setq query (if (fquery nil "Ask before copying each file? ") :yes :no)))
     (unless (listp files) (setq files (list files)))	;Compatibility kludge
     (flet ((do-copy (from-file to-file &optional plist)
	      (when (or (eq query :no)
			(let ((answer
				(unless (eq query :dont-no)
				(fquery '(:choices 
					   (((t "Yes")  #\Y #\T #\space)
					    ((nil "no") #\N #\rubout)
					    ((:dont-yes "Yes and continue answering yes") #\P)
					    ((:dont-no "No and continue answering no") #\S)))
					"Copy file ~A to ~A? " from-file to-file))))
			  (prog1 (or (eql answer t)
				     (eql answer :dont-yes))
				 (when (eql answer :dont-no)
				   (setq query :dont-no))
				 (when (eql answer :dont-yes)
				   (setq query :no)))))
		(let ((this-mode mode)
		      (report-stream (when (eq query :no) standard-output)))
		  (when (eq this-mode :default)
		    ;; In default, use Mac mode between two Mac's or from a Mac to another
		    ;; host when the Mac file has something in the resource fork.
		    (flet ((mac-p (pathname)
			     ;; Either local or via NFILE.
			     (typep (send pathname :host) 'mac-fs:emb-file-host)))
		      (when (and (mac-p from-file)
				 (or (mac-p to-file)
				     (let ((reslen (get (or plist
							    (ignore-errors
							      (fs:file-properties from-file)))
							:resource-fork-length)))
				       (when (and reslen (plusp reslen))
					 (setq need-macintosh-warning t)
					 t))))
			(setq this-mode :macintosh))))
		  (condition-case (err)
		       (if (eq this-mode :macintosh)
			   (mtb::copy-mac-image from-file to-file
						:create-directories create-directories
						:report-stream report-stream)
			   (cl:apply #'copyf from-file to-file
				     :element-type element-type
				     :copy-author copy-author
				     :copy-creation-date copy-creation-date
				     :create-directories create-directories
				     :report-stream report-stream
				     (if (not (eq if-exists :none))
					 `(:if-exists ,if-exists)
					 nil)
				     ))
		     (fs:file-operation-failure
		       (format error-output "~& Could not copy ~A:~%  ~~A~"
			       from-file err)))))))
       (dolist (from-file files)
	 (if (send from-file ':wild-p)
	     (let ((files (condition-case (err)
			       (cdr (fs:directory-link-opaque-dirlist
				      from-file ':sorted))	;need slow..
			     (fs:file-operation-failure
			       (format error-output "~&Error: ~~A~" err)))))
	       (if files
		   (loop with merged-to = (fs:merge-pathnames
					    to-file
					    (fs:default-pathname from-file nil nil ':wild)
					    ':wild)
			 for plist in files
			 for (file) = plist
			 for truename = (or (get plist ':truename) file)
			 if (get plist ':directory) do nil
			 else if (get plist ':link-to) do nil	;This involves hair
						;and design
			 else
			   do (do-copy truename (send from-file ':translate-wild-pathname
						      merged-to file)
				       plist)
			 finally (return t))
		   (format error-output "~&~A matches no files.  None copied." from-file)))
	     (do-copy from-file to-file))))
     (when need-macintosh-warning
       (format t "~&Note:  Files copied to non-Macintosh hosts in Macintosh mode will need
to be copied to another Macintosh with an explicit :Mode Macintosh.
:Mode Default cannot recognize these files."))))

;;; Create commands

(defun pathname-history-first-pathname ()
  (let* ((history (dw::find-accept-history 'fs:pathname))
	 (history-item
	   (when history (car (send history :element 0))))
	 (item (if history-item history-item
		   (fs:default-pathname))))
    item))

(cp:define-command (com-create-directory :command-table "Directory"
					 :provide-output-destination-keyword nil)
    ((directory 'fs:pathname
		:confirm t
		:default (send
			   (pathname-history-first-pathname)
			   :new-pathname
			   :name :wild :type :wild :version :wild))
     &key
     #+What-does-this-mean
     (enable (:enumeration :yes :no :ask)
	     :default :no
	     :mentioned-default :yes
	     :documentation "What does this do?"))
   (fs:force-user-to-login)
   (condition-case (.error.)
	(send directory ':create-directory)
      (fs:file-operation-failure
	(format t "~&Can't create directory: ~~A~" .error.))
      (:no-error
	(format t "~&Directory ~A created."
		(send directory ':new-pathname ':name nil ':type nil ':version nil)))))

(cp:define-command (com-create-link :command-table "File"
				    :provide-output-destination-keyword nil)
    ((destination 'fs:pathname
		  :confirm t
		  :prompt "pathname of link"
		  :documentation
		  "New pathname to link to another pathname")
     (source 'fs:pathname
	     :default (and destination (fs:merge-pathnames destination))
	     :confirm t
	     :prompt "target of link"
	     :documentation "Pathname to link to")
     &key
     (type '((cl:member :read-only :read-write :create-through :all
			:use-default))
	   :default :use-default
	   :documentation "Kind of link to create")
     (create-directories '((cl:member :yes :error :query))
			 :default :query
			 :documentation
			 "What to do if a destination directory does not exist"))
   (let ((source-list (and source
			   (if (send source :wild-p)
			       (cl:mapcar #'first
					  (cdr (fs:directory-link-opaque-dirlist
						 source :no-extra-info :sorted)))
			       (list source)))))
     (if source-list
	 (loop for one-source in source-list do
	   (let* ((first (send source :translate-wild-pathname destination one-source))
		  (second (fs:merge-pathnames one-source first))
		  (link-type (selectq type	; do we need more?
			       (:read-only '(:read))
			       (:read-write '(:read :write))
			       (:create-through '(:read :write :create))
			       (:all '(:read :write :create :rename :delete))
			       (:use-default nil)))
		  (physical-first (send first :translated-pathname))
		  (physical-second (send second :translated-pathname)))
	     ;; don't know how to do link types yet.
	     (condition-case (.error.)
		  (fs:with-copyf-create-directories (create-directories)
		    (send physical-first ':create-link physical-second))
		(fs:file-operation-failure
		  (format t "~& Error: Cannot create link: ~%~8@T~~A~" .error.))
		(:no-error
		  (when link-type
		    (condition-case (.error.)
			 (fs:change-file-properties
			   physical-first t ':link-transparencies link-type)
		       (fs:file-operation-failure
			 (format
			   t
			   "~& Error: Cannot set link transparencies: ~%~8@T~~A~" .error.))))
		  (format t "~& ~A linked to ~A"  first second)))))
	 (format t "~& Error: No existing pathname given."))))

;;; Delete commands

(cp:define-command (com-delete-file :command-table "File")
    ((file '((cl:sequence fs:pathname))
	   :prompt "file"
	   :confirm t
	   :documentation "File to mark for deletion")
     &key
     (expunge '((cl:member :yes :no :ask))
	      :default :no
	      :mentioned-default :yes
	      :documentation "Whether to expunge the files, also")
;		    (keep 'cl:integer
;			  :default 0
;			  :documentation "How many versions to keep (not delete)")
     (query '((cl:member :yes :no :ask))
	    :mentioned-default :yes
	    :default :no
	    :documentation "Whether to ask before deleting each file"))
   (when (eq query ':ask)
     (setq query (y-or-n-p "Ask before deleting each file? "))
     (setq query (if query :yes :no)))
   (let ((files-to-delete)
	 (keep 0))				;temporarily
     (loop for file in file
	   do
       (if (minusp keep)
	   (format t "~& Error: :Keep must not be negative")
	   ;; :keep not implemented yet.
	   ;; so far deals only with files.
	   (cond ((send file ':wild-p)
		  (condition-case (err-or-files)
		       (cdr (fs:directory-list file ':fast ':sorted))
		     (fs:file-operation-failure (format t "Error: ~A" err-or-files))
		     (:no-error
		       (if (null err-or-files)
			   (format t "Error: ~A matches no files." file)
			   (when (eq query :yes)
			     (format t "~&~%Deleting the following ~D file~:P:~%"
				     (length err-or-files))
			     (loop for (file) in err-or-files
				   do (format t "  ~A~%" file)
				   finally (terpri)))
			   (loop for (file) in err-or-files
				 do (when (or (eq query :no)
					      (y-or-n-p (format nil "~&Delete ~A? " file)))
				      (condition-case (err)
					   (deletef file)
					 (fs:file-operation-failure
					   (format t "~&Cannot delete ~A:~%  ~~A~" file err))
					 (:no-error
					   (setq files-to-delete t)
					   (when (eq query :no)
					     (format t "~&~A deleted." file))))))))))
		 (t
		  (let* ((no-such-file nil)
			 (truename (or (fs:link-opaque-truename file nil)
				       (progn (setq no-such-file t)
					      file))))
		    (when (or no-such-file
			      (eq query :no)
			      (y-or-n-p (format nil "Delete ~A? " truename)))
		      (condition-case (err)
			   (deletef truename)
			 (fs:file-operation-failure
			   (format t "~&Cannot delete ~A:~%  ~~A~" truename err))
			 (:no-error
			   (setq files-to-delete t)
			   (format t "~&~A deleted." truename)))))))))
     (when (and files-to-delete
		(or (eq expunge :yes)
		    (and (eq expunge :ask)
			 (fquery nil "~&~% Expunge the files just deleted? "))))
       (loop with expunged-directories
	     for file in file
	     as directory = (send file :new-pathname :name :wild :type :wild :version :wild)
	     unless (cl:member directory expunged-directories)
	       do
		 (push directory expunged-directories)
		 (zwei:cp-expunge-directory-internal file :no)))))

;;; Expunge commands

;Common subroutine for all expunge commands
;Returns the number of blocks freed
zwei:
(defun cp-expunge-directory-internal (directory query-each)
  (setq directory (send directory :new-pathname :name :wild :type :wild :version :wild))
  (if (send directory ':directory-wild-p)
      (loop for (subdir) in (condition-case (.error.)
				(fs:all-directories directory ':sorted)
			      (fs:file-error
				(ferror "Can't list directories of ~A: ~~A~"
					directory .error.)))
	    when (or (eq query-each :no)
		     (y-or-n-p (format nil "Expunge directory ~A? " subdir)))
	      sum (cp-expunge-directory-internal subdir query-each) into total
	    finally
	      (when (plusp total)
		(format t "~&~A: ~D total block~:P freed." directory total))
	      (return total))
    (condition-case (result)
	(fs:expunge-directory directory)
      (fs:file-operation-failure
	(format t "~&Cannot expunge ~A because " directory)
	(send result (if (send result ':operation-handled-p ':report-without-pathname)
			 ':report-without-pathname ':report)
	      standard-output)
	0)
      (:no-error
       (format t "~&~A: ~D block~:P freed.~%" directory result)
       result))))

(defun expunge-delay (spec &key (delay-seconds 300.))
  (let* ((where (cl:etypecase spec
		  (net:host (format nil "on ~A" spec))
		  (cl:pathname (format nil "in ~A" spec))
		  (scl:sequence (format nil "in ~@\presentation\"
					spec '(scl:sequence cl:pathname)))))
	 (who (if (and (neq *user* *not-logged-in-user*)	
		       (neq (send *user* :type) :daemon))
		  *user*
		  (accept 'cl:string :prompt "Who are you really?")))
	 (message
	   (format nil "All deleted files ~A will be expunged in ~\time-interval\. --~A"
		   where delay-seconds who)))
    (sys:unwind-protect-case ()
	(progn (dis:with-never-more (tv:selected-window)
		 (net:notify-lispms-at-site net:*local-site* message :report nil))
	       (scl:sleep delay-seconds
			  :sleep-reason
			  (format nil "Expunge at ~A"
				  (let ((date-and-time
					  (format nil "~\time\"
						  (+ (cl:get-universal-time) delay-seconds))))
				    (substring date-and-time
					       (1+ (string-search #\space date-and-time)))))))
      (:abort (net:notify-lispms-at-site
		net:*local-site*
		(format nil "Scheduled expunge of deleted files ~A has been canceled. --~A"
			where who)
		:report nil)))))

(defvar *expunge-notification-default* :no
  "Controls the default for the :Notify keyword to the Expunge Directory command.")

(defvar *expunge-notification-delay-default* 300.
  "Controls the default for the :Notification Delay keyword to the Expunge Directory command.")

(defun query-expunge-delay (pathnames
			    &key (notify *expunge-notification-default*)
			         (notification-delay *expunge-notification-delay-default*))
  (let ((wilds (loop for dir in pathnames
		     when (let* ((component (send dir :directory))
				 (token (if (atom component) component (car component))))
			    ;; Is dir component :wild or :wild-inferiors,
			    ;; or is that its top-level node?
			    (member token '(:wild :wild-inferiors)))
		       collect dir)))
    (cond ((not wilds) t)
	  ((eq notify :no) t)
	  (t ;Notify is :YES or :QUERY
	   (when (eq notify :query)
	     (unless (cl:yes-or-no-p "Do you want to notify other users at site ~A ~
			   	      that you are about to expunge ~@\presentation\, ~
			 	    ~%and then wait ~\time-interval\ before proceeding? "
				     net:*local-site*
				     wilds '(cl:sequence pathname)
				     notification-delay)
	       (cond ((cl:yes-or-no-p "Do you want to continue without notifying anyone? ")
		      (format t "~&OK, no notification will be done.~%")
		      (return-from query-expunge-delay t))
		     (t
		      (format t "~&No files will be expunged.~%")
		      (return-from query-expunge-delay nil)))))
	   (expunge-delay wilds :delay-seconds notification-delay)
	   t))))

(cp:define-command (com-expunge-directory :command-table "Directory"
				       ;; This command potentially does lots of output!
				       ;; -kmp 29-Sep-92
				       ;; :provide-output-destination-keyword nil
					  )
    ((directory '((cl:sequence ((cl:pathname)
				:default-name :wild
				:default-type :wild
				:default-version :wild)))
		:confirm t
		:prompt "file"
		:documentation "Directory in which to expunge deleted files")
     &key
     (notify '(cl:member :yes :no :query)
	     :default *expunge-notification-default*
	     :mentioned-default :yes
	     :documentation
       "Whether to notify other users before expunging toplevel directories using wildcards.")
     (delay-after-notification 'time:time-interval
			       :default *expunge-notification-delay-default*
			       :documentation
       "The amount of time to wait when a notification is sent before doing the deed.")
     (query '((cl:member :yes :no))
	    :mentioned-default :yes
	    :default :no
	    :documentation
	    "Whether to ask before expunging each directory"))
   (setq directory
	 (mapcar #'(lambda (pathname)
		     (send pathname :new-pathname :name :wild :type :wild :version :wild))
		 directory))
   (when (si:query-expunge-delay directory
				 :notify notify
				 :notification-delay delay-after-notification)
     (loop for dir in directory do
       ;; We needed to do this earlier. See above.
       ;; (setq dir (send dir :new-pathname :name :wild :type :wild :version :wild))
       (zwei:cp-expunge-directory-internal dir query))))

(cp:define-command (com-delete-directory :command-table "Directory"
					 :provide-output-destination-keyword nil)
    ((directory '((cl:sequence ((cl:pathname)
				:default-name nil
				:default-type nil
				:default-version nil)))
		:confirm t
		:prompt "file"
		:documentation "Directory to delete the contents of and expunge recursively")
     &key
     (confirm '((alist-member :alist (("Yes" . t)
				      ("No" . nil)
				      ("Each" . :each))))
	      :default :each
	      :documentation "Whether to ask before deleting each subdirectory"))
   (dolist (pathname directory)
     (unless (and (member (send pathname :name)    '(nil :unspecific))
		  (member (send pathname :type)    '(nil :unspecific))
		  (member (send pathname :version) '(nil :unspecific)))
       (format t "~&Your request to Delete Directory will not be performed~
		  ~%because ~A is not the unambiguous name of a directory.~
		  ~%Please specify ~A or ~A for clarity.~%"
	       pathname
	       (send (send pathname :new-pathname :type nil :version nil)
		     :pathname-as-directory)
	       (send pathname :new-pathname :name nil :type nil :version nil))
       (return-from com-delete-directory)))
   (dolist (dir directory)
     (condition-case (err)
	  (fs:delete-directory dir :confirm confirm)
	(fs:file-operation-failure
	  (format error-output "~&Cannot delete ~A: ~~A~" dir err)))))

;;; Load commands

(cp:define-command (com-load-file :command-table "System Maintenance")
    ((file-spec '((cl:sequence ((fs:pathname) :default-type nil :default-version nil)))
		:confirm t
		:default `(,(send (pathname-history-first-pathname)
				  :new-pathname :type nil :version nil))
		:prompt "file"
		:documentation "name of file to load")
     &key
     (compile '((cl:member :never :new-source :always))
	      :default ':never
	      :mentioned-default ':new-source
	      :documentation "Whether to compile source before loading")
     #||
     (loader '((cl:member :lisp :sage :use-canonical-type))
	     :default ':use-canonical-type
	     :documentation "Not implemented yet")
     ||#
     (pkg 'scl:package
	  :name "Package"
	  :default nil
	  :documentation "Package into which to load")
     (query '((cl:member :yes :no :ask))
	    :mentioned-default :yes
	    :default :no
	    :documentation "Whether to ask before loading each file")
     (silently 'boolean
	       :mentioned-default t
	       :documentation
	       "Whether to print a line as each file is loaded"))
   (unless (eq compile :never)
     (let ((new-files (translate-load-files-for-compile file-spec compile)))
       (when new-files
	 (com-compile-file new-files :load :no :query query :silently silently))))
   #||
   (when (neq loader :use-canonical-type)
     (ferror "The :loader option is not yet implemented."))
   ||#
   ;; nothing done yet about compiling or using different loaders
   (when (eq query ':ask)
     (setq query (if (yes-or-no-p "Ask before loading each file? ") :yes :no)))
   (si:inhibit-lengthy-background-updates
     (loop for file in file-spec doing
       (if (send file ':wild-p)
	   (let ((files (condition-case (err)
			     (cdr (fs:directory-list file ':sorted))	;need slow..
			   (fs:file-operation-failure (format t "~&Error: ~~A~" err)))))
	     (when files
	       (setq files
		     (eliminate-duplicates
		       (loop with wild-type = (send file :type-wild-p)
			     and notype = (eq (send file :type) nil)
			     for plist in files
			     for (one-file) = plist
			     unless (or (get plist :directory)
					(and wild-type
					     (let ((type (send one-file :canonical-type)))
					       (not (or (null type)
							(eq type *default-binary-file-type*)
							(eq type :lisp))))))
			       collect (if notype
					   (send one-file :new-pathname
						 :type nil :version :newest)
					   one-file))
		       #'equal)))
	     (if files
		 (loop for one-file in files
		       do (when (or (eq query :no)
				    (y-or-n-p (format nil "Load ~A? " one-file)))
			    (load one-file pkg nil nil silently)))
		 (format t "~& ~A matches no files; none loaded." file)))
	   (when (or (eq query :no)
		     (y-or-n-p (format nil "Load ~A? " file)))
	     (load file pkg nil nil silently)))))
   (format t "~& ... Done."))

;;; Given the file you want to load, figure out the files you want to compile to get them.
;;;+++ I guess this should really look in the bin file to see what language it was from.
(defun translate-load-files-for-compile (files &optional (mode :new-source))
  (loop for dest-file in files
	do (setq dest-file (send dest-file :new-version :newest))
	as bin-file = (send dest-file :new-canonical-type *default-binary-file-type*)
	as source-file = (multiple-value-bind (source-file source-date)
			     (dolist (type *file-compilers*)
			       (let ((path (condition-case ()
						(send dest-file :new-canonical-type type)
					      (fs:invalid-pathname-component nil))))
				 (when path
				   (condition-case (date)
					(cl:file-write-date path)
				      (fs:file-lookup-error nil)
				      (:no-error (return (values path date)))))))
			   (when (and source-file source-date
				      (or (eq mode :always)
					  (let ((bin-creation-date
						  (condition-case ()
						       (cl:file-write-date bin-file)
						     (fs:file-lookup-error nil))))
					    (or (null bin-creation-date)
						(> source-date bin-creation-date)))))
			     source-file))
	when source-file collect source-file))

;;; Rename commands

(cp:define-command (com-rename-file :command-table "File")
    ((from-file 'fs:pathname
		:confirm t
		:prompt "existing name"
		:documentation "File to be renamed")
     (to-file #-ignore '((fs:pathname) :dont-merge-default t)
	      #+ignore '((fs:pathname) :default-name :wild :default-type :wild :default-version :wild)
	      :default #-ignore (fs:default-pathname from-file nil nil :wild)
		       #+ignore from-file
	      :confirm t
	      :prompt "new name"
	      :documentation "New name for file")
     &key
     (query '((cl:member :yes :no :ask))
	    :mentioned-default :yes
	    :default :no
	    :documentation "Whether to ask before renaming each file")
     (create-directories '((scl:alist-member
			     ;; {T NIL :QUERY} is the right set for
			     ;; fs:with-copyf-create-directories
			     :alist (("Yes" t) ("Error" nil) ("Query" :query))))
			 :default :query
			 :documentation
			 "What to do if a destination directory does not exist"))
   (when (eq query ':ask)
     (setq query (if (y-or-n-p "Ask before renaming each file? ") :yes :no)))
   (flet ((rename-internal (from to)
	    (condition-case (err)
		 (multiple-value-bind (nil old new)
		     (fs:with-copyf-create-directories (create-directories)
		       (renamef from to))
		   (format t "~&Renamed ~A to ~A." old new))
	       (fs:file-operation-failure
		 (format error-output "~&Cannot rename ~A to ~A:~%  ~~A~" from to err)))))
     (if (send from-file ':wild-p)
	 (condition-case (err-or-files)
	      ;;Sort the list so that .newest remains .newest 
	      (cdr (fs:directory-link-opaque-dirlist from-file ':fast ':sorted))
	    (fs:file-operation-failure (format error-output "~&Error: ~~A~" err-or-files))
	    (:no-error
	      (or err-or-files
		  (format error-output "~&Error: ~A matches no files." from-file))
	      (loop with merged-to = (fs:merge-pathnames to-file from-file :wild)
		    for (file . plist) in err-or-files
		    as translation = (send from-file ':translate-wild-pathname
					   merged-to file)
		    as truename = (or (get (locf plist) ':truename) file)
		    when (or (eq query :no)
			     (y-or-n-p (format nil "Rename file ~A to ~A? "
					       truename translation)))
		      do (rename-internal truename translation))))
	 (when (or (eq query :no)		; these look funny, may need more work
		   (y-or-n-p (format nil "Rename file ~A to ~A? " from-file to-file)))
	   (rename-internal from-file to-file)))))

;;; Show commands

(cp:define-command (com-show-disk-usage :command-table "Directory") 
    ((pathnames '((scl:sequence ((scl:pathname) :default-version :wild)))
		:default
		(ncons
		  (send (si:pathname-history-first-pathname) :new-pathname
			:name :wild
			:type :wild
			:version :wild))
		:prompt "files"
		:documentation "Pathname whose disk usage to show."))
   "Shows disk usage as in Show Directory, but without listing individual files."
   (flet ((compute-info (data)
	    (let ((total-blocks 0) (deleted-blocks 0) (n-files 0) (n-deleted-files 0))
	      (dolist (datum data)
		(incf n-files)
		(let ((b (getf (cdr datum) :length-in-blocks)))
		  (when b
		    (incf total-blocks b)
		    (when (getf (cdr datum) :deleted)
		      (incf n-deleted-files)
		      (incf deleted-blocks b)))))
	      (list total-blocks n-files
		    (if (> n-deleted-files 0) n-deleted-files) deleted-blocks)))
	  (show-info (info format-string &rest format-args)
	    (let ((total-blocks    (nth 0 info))
		  (n-files         (nth 1 info))
		  (n-deleted-files (nth 2 info))
		  (deleted-blocks  (nth 3 info)))
	      (format t "~&~? ~:D block~:P in ~:D file~:P~
			   ~@[ (including ~*~:D deleted block~:P in ~2:*~D file~:P)~]."
		      format-string format-args
		      total-blocks n-files n-deleted-files deleted-blocks))))
     (let ((data (mapcar #'(lambda (path) (fs:directory-list path :deleted)) pathnames)))
       (let ((host-data (do ((p pathnames (cdr p))
			     (d data (cdr d))
			     (info '()))
			    ((null d) info)
			  (setf (getf info (cl:pathname-host (car p)))
				(list (getf (cdaar d) :disk-space-description))))))
	 (do ((p pathnames (cdr p))
	      (d data (cdr d)))
	     ((null d)
	      (do ((h (reverse host-data) (cddr h))) ((null h))
		(let ((host (cadr h))
		      (disk (caar h))
		      (data (cdar h)))
		  (format t "~&~A: ~A~%" (send host :short-name) disk)
		  (dolist (datum (reverse data))
		    (dw:with-output-as-presentation (:stream standard-output
						     :type 'cp:command
						     :object `(si:com-show-directory
								(,(car datum)))
						     :single-box t)
		      (show-info (cdr datum)
				 " ~A uses" (car datum))))))
	      (when (> (length pathnames) 1)
		(dw:with-output-as-presentation (:stream standard-output
						 :type 'cp:command
						 :object `(si:com-show-directory
							    ,pathnames)
						 :single-box t)
		  (show-info ;; Just in case any of the wildcard specs had an overlap,
		             ;; make sure to remove duplicates.
		             (compute-info
			       (cl:remove-duplicates (cl:apply #'append (mapcar #'cdr data))
						     :key #'car))
			     "Grand total of"))))
	   (push (cons (car p) (compute-info (cdar d)))
		 (cdr (getf host-data (cl:pathname-host (car p))))))))))

(defun excludable-pathname-p (pathname)
  ;; This is a heuristic function intended to help avoid a problem of calling
  ;; :pathname-match on a truename and having it gratuitously fail, which will
  ;; happen, e.g., if you do (send #P"*.*.newest" :pathname-match (truename newest))
  ;; because the truename will have resolved the :NEWEST into an actual version.
  ;; For the same kind of reason, logical pathnames don't fare well either.
  (and (not (typep pathname 'fs:logical-pathname))
       (let ((version (cl:pathname-version pathname)))
	 (or (cl:integerp version)
	     (member version '(nil :unspecific :wild))))))

(cp:define-command (com-show-directory :command-table "Directory")
    ((pathnames '(cl:sequence ((fs:pathname) :default-version :newest))
		:default
		(ncons
		  (send (pathname-history-first-pathname)
			:new-pathname :name :wild :type :wild :version
			:newest))
		:prompt "files"
		:confirm t
		:documentation "pathname whose directory to show")
     &key
     (excluding `((cl:sequence ((and ((cl:pathname)
                                      :default-name :wild
				      :default-type :wild
				      :default-version :wild)
				     ((cl:satisfies excludable-pathname-p)))
				:description "an excludable pathname"))
		  :element-default ,(cl:make-pathname :name :wild :type :wild :version :wild))
		:default '()
		:prompt "files"
		:documentation "Pathnames not to show")
     (size 'cl:integer
	   :prompt "pages"
	   :default 0
	   :documentation "Show files same or larger than this, in blocks")
     (since '(or null ((time:universal-time) :past-p t))
	    :default nil
	    :default-type 'null
	    :documentation "Show files created on or after this date")
     (before '(or null ((time:universal-time) :past-p t))
	     :default nil
	     :default-type 'null
	     :documentation "Show files created before this date")
     (author '(null-or-type string)
	     :default nil
	     :default-type 'null
	     :documentation "Show files written by this user")
     (order '(cl:member :smallest-first :largest-first :oldest-first
			:newest-first :name :type)
	    :default :name
	    :documentation "Show the files in this order")
     (partition-id '(or (scl:member :invisible :any) (cl:integer 1))
		   :default (if zwei:*directory-single-file-show-partition* :any :invisible)
		   :prompt "Invisible or Any or an integer"
		   :documentation "Whether to show partitions where files reside
  D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :ITALIC NIL) "CPTFONTI")Invisible0    Show files in all partitions and don't display their partition numbers
  1Any0          Show files in all partitions and display their partition numbers
  <1integer>0    Select only files in this partition number")
     )
   (let ((zwei:*directory-single-file-show-partition* (neq partition-id :invisible)))
     (multiple-value-bind (headers files)
	 (loop for pathname in pathnames
	       as listing = (fs:directory-list pathname :deleted)
	       collect (first listing) into headers
	       append (rest1 listing) into files
	       finally (return (values (eliminate-duplicates headers #'equal)
				       files)))
       ;; Eliminate duplicates due to overlapping pathname specs
       ;; (but only when there are multiple pathname specs to begin with).
       (when (cdr pathnames) (setq files (cl:delete-duplicates files :key #'first)))
       (setq files (del-if-not
		     (lambda (file)
		       (let ((file-size (get file :length-in-blocks))
			     (file-date (or (get file :creation-date)
					    (get file :file-creation-date)))
			     (file-author (get file :author))
			     (file-partition-id (get file :partition-id))
			     )
			 (and (or (null size)
				  (null file-size)
				  ( file-size size))
			      (or (null since)
				  (null file-date)
				  ( file-date since))
			      (or (null before)
				  (null file-date)
				  (< file-date before))
			      (or (null author)
				  (null file-author)
				  (string-equal author file-author))
			      (or (null excluding)
				  (not
				    (cl:some
				      (lambda (exclusion)
					(cl:some
					  (lambda (pathname)
					    (send (fs:merge-pathnames exclusion pathname)
						  :pathname-match (car file)))
					  pathnames))
				      excluding)))
			      (or (memq partition-id '(:invisible :any))
				  (null file-partition-id)
				  (= partition-id file-partition-id)))))
		     files))
       (cl:fresh-line)
       (terpri)
       (dw:with-resortable-output ((files order)
				   (:name (lambda (x y)
					    (fs:pathname-lessp (car x) (car y))))
				   (:type (lambda (entry1 entry2)
					    (let* ((path1 (car entry1))
						   (path2 (car entry2))
						   (type1 (send path1 :type))
						   (type2 (send path2 :type)))
					      (if (string-equal type1 type2)
						  (fs:pathname-lessp path1 path2)
						(string-lessp type1 type2)))))
				   (:smallest-first
				     (lambda (x y)
				       (let* ((x-blocks (get x :length-in-blocks))
					      (y-blocks (get y :length-in-blocks))
					      (blocks-p (and x-blocks y-blocks)))
					 (or (and blocks-p (< x-blocks y-blocks))
					     (and (or (not blocks-p) (= x-blocks y-blocks))
						  (< (* (or (get x :byte-size) 8)
							;; put directories and randoms first
							(or (get x :length-in-bytes) 0))
						     (* (or (get y :byte-size) 8)
							(or (get y :length-in-bytes) 0))))))))
				   (:largest-first
				     (lambda (x y)
				       (let* ((x-blocks (get x :length-in-blocks))
					      (y-blocks (get y :length-in-blocks))
					      (blocks-p (and x-blocks y-blocks)))
					 (or (and blocks-p (> x-blocks y-blocks))
					     (and (or (not blocks-p) (= x-blocks y-blocks))
						  (> (* (or (get x :byte-size) 8)
							(or (get x :length-in-bytes) 0))
						     (* (or (get y :byte-size) 8)
							(or (get y :length-in-bytes) 0))))))))
				   (:oldest-first (lambda (x y)
						    (< (or (get x :creation-date)
							   (get x :file-creation-date)
							   1_40)
						       (or (get y :creation-date)
							   (get y :file-creation-date)
							   1_40))))
				   (:newest-first (lambda (x y)
						    (> (or (get x :creation-date)
							   (get x :file-creation-date)
							   1_40)
						       (or (get y :creation-date)
							   (get y :file-creation-date)
							   1_40))))
				   (:partition-up (lambda (x y)
						    (< (or (get x :partition-id)
							   0)
						       (or (get y :partition-id)
							   0))))
				   (:partition-down (lambda (x y)
						      (> (or (get x :partition-id)
							     0)
							 (or (get y :partition-id)
							     0)))))
				  ()
	 (let ((file-count 0))
	   (multiple-value-bind (total-blocks deleted-blocks)
	       (zwei:list-directory-internal
		 pathnames (append headers '(nil) files)
		 (lambda (line file)
		   (present-directory-element line file)
		   (unless (or (atom file)			;NIL or :SWITCH
			       (null (car file)))		;the directory info line
		     (incf file-count))))
	     (format t "~%~:D block~:P in ~D files" total-blocks file-count)
	     (when (plusp deleted-blocks)
	       (format t ", including ~D deleted block~:P" deleted-blocks))
	     (loop repeat 2 do (send standard-output :tyo #\return))))))))

(define-presentation-to-command-translator com-show-directory
   (fs:directory-pathname
     :tester ((file) (operation-handled-p file :pathname-as-directory)))
   (file)
  `(com-show-directory (,(send (send file :pathname-as-directory)
			       :new-pathname :name :wild :type :wild :version :newest))))

;; line is a formatted-up string for a line of the directory listing
;; car of directory-element is a pathname, cdr is a property list
;; This function encapsulates the knowledge of what presentation-type to use
(defun present-directory-element (line directory-element &optional (stream standard-output))
  (if (or (atom directory-element)		;NIL or :SWITCH
	  (null (car directory-element)))	;the directory info line
      (cl:write-line line stream)
      (let ((pathname (car directory-element)))
	;; presentation-type of the directory line encodes information about the
	;; pathname, such as whether it is a FEP file and whether it is a directory
	;; (in any file system).  These are all subtypes of PATHNAME, which is the
	;; from-presentation-type of most of the applicable presentation translators.
	;; Using this more specific presentation type allows more specific contexts,
	;; such as FS:FEP-PATHNAME, to work.
	(dw:with-output-as-presentation (:object pathname
					 :type (if (and
						     ;; This says it holds stuff
						     (get directory-element :directory)
						     ;; This says we have enough syntactic
						     ;; knowledge about it to be able to care.
						     ;; -kmp 17-Aug-90
						     (operation-handled-p
						       pathname
						       :pathname-as-directory))
						   'fs:directory-pathname
						   (cl:type-of pathname))
					 :stream stream)
	  (cl:write-string line stream))
	(terpri stream))))

(defvar zwei:*directory-single-file-lister* 'zwei:default-list-one-file
  "Function normally called to display each file")

(defvar zwei:*directory-single-file-show-partition* t
  "Whether to make the file lister display the partition number for LMFS files")

;;; Note that *DIRECTORY-SINGLE-FILE-LISTER* is expected to output lines.
;;; If STREAM is NIL, just return the string which would be :LINE-OUT'd.
(defun zwei:default-list-one-file (file &optional (stream standard-output)
				   (sensitive-output-p
				     (and (cl:streamp stream)
					  (typep (follow-syn-stream stream)
						 'dw:dynamic-window)))
				   (show-partition zwei:*directory-single-file-show-partition*)
			      &aux pathname line dir-p)
  (setq line (make-array 400 ':type 'art-fat-string
			     ':leader-length (and (or (null stream)
						      (and (flavor:find-flavor
							     'zwei:interval-stream nil)
							   (typep stream
								  'zwei:interval-stream)))
						  zwei:line-leader-size)
			     ':fill-pointer 2))
  (si:fill-array line nil #\sp)
  (cond ((null (setq pathname (car file)))
	 (cond ((get file ':disk-space-description)
		(string-nconc line (get file ':disk-space-description)))
	       ((get file ':physical-volume-free-blocks)
		(do ((free (get file ':physical-volume-free-blocks) (cdr free))
		     (flag t nil))
		    ((null free))
		  (string-nconc line (if flag "Free: #" ", #") (caar free) #/=)
		  (setf (fill-pointer line)
			(number-into-array line (cdar free) 10. (fill-pointer line)))))))
	(t (if (get file ':deleted) (aset #/D line 0))
	   (when (get file ':open-for-writing)
	     (aset #/W line 1)
	     (setf (fill-pointer line) 3))
	   (string-nconc line (or (get file ':physical-volume) ""))
	   (setf (fill-pointer line) (1+ (max 5 (fill-pointer line))))
	   (setq dir-p (get file ':directory))
	   (string-nconc line (funcall pathname ':string-for-dired))
	   (setf (fill-pointer line) (max 20. (1+ (fill-pointer line))))
	   (let ((link-to (get file ':link-to)))
	     (cond (link-to
		    (string-nconc line "=> " link-to)
		    (setf (fill-pointer line) (max 40. (1+ (fill-pointer line)))))
		   (t
		    (if (get file ':offline)	;Tops-20
			(string-nconc line "[OFFLINE]")
			(let ((length (get file ':length-in-blocks)))
			  (if length
			      (setf (fill-pointer line)
				    (1+ (number-into-array line length 10.
							   (fill-pointer line) 4)))
			      (incf (fill-pointer line) 5))))
		    (if dir-p
			(string-nconc line "  DIRECTORY")
			(let ((length (get file ':length-in-bytes)))
			  (when length
			    (setf (fill-pointer line)
				  (number-into-array line length 10. (fill-pointer line) 6))
			    (array-push line #/()
			    (setf (fill-pointer line)
				  (number-into-array line (get file ':byte-size) 10.
						     (fill-pointer line)))
			    (array-push line #/)))))
		    (setf (fill-pointer line)
			  (max 39. (1+ (fill-pointer line))))
		    (array-push line (if (get file ':not-backed-up) #/! #\sp)))))
	   (array-push line (if (get file ':dont-delete) #/@ #\sp))
	   (array-push line (if (get file ':dont-supersede) #/# #\sp))
	   (array-push line (if (get file ':dont-reap) #/$ #\sp))
	   (let ((partition-id (get file :partition-id)))
	     (when (and show-partition partition-id (numberp partition-id))
	       (array-push line #\  )
	       (array-push line #\# )
	       (loop for digit being array-elements of
			 (format nil "~D" partition-id)
		     do (array-push line digit))
	       (array-push line #\  )))
	   (let ((creation-date (or (get file ':creation-date)
				    (get file ':file-creation-date))))
	     (if creation-date
		 (zwei:time-into-array line creation-date)
		 (incf (fill-pointer line) 17.)))
	   (let* ((date-last-expunged (get file ':date-last-expunged))
		  (reference-date (or date-last-expunged (get file ':reference-date))))
	     (if (null reference-date)
		 (let ((comment (get file ':comment)))
		   (if (null comment)
		       (incf (fill-pointer line) 11.)
		       (string-nconc line " [" comment "]")))
		 (string-nconc line (if date-last-expunged " X=" " ("))
		 (zwei:time-into-array line reference-date nil)
		 (or date-last-expunged (array-push line #/close))))
	   (let ((directory (send pathname ':raw-directory)))
	     (when (and (listp directory)
			(null (cdr directory)))
	       (setq directory (car directory)))
	     (let ((author (get file ':author)))
	       (when (and author (not (equal directory author)))
		 (setf (fill-pointer line)
		       (max (1+ (fill-pointer line)) 74.))
		 (string-nconc line author)))
	     (let ((reader (get file ':reader)))
	       (when (and reader (not (equal reader directory)))
		 (setf (fill-pointer line)
		       (max (1+ (fill-pointer line)) 84.))
		 (string-nconc line reader))))))
  (adjust-array-size line (fill-pointer line))
  (unless (null stream)
    (if (or (null pathname) (null sensitive-output-p))
	(send stream ':line-out line)
      (dw:with-output-as-presentation (:stream stream :type 'fs:pathname :object pathname)
	(send stream :line-out line))))
  line)

;; Helping kludges for DEFAULT-LIST-ONE-FILE
(defsubst zwei:2-digit-into-array (array number)
  (array-push array (digit-char (// number 10.)))
  (array-push array (or (digit-char (\ number 10.))
			#/0)))

(defun zwei:time-into-array (array time &optional (include-time t))
  (multiple-value-bind (seconds minutes hours day month year)
      (time:decode-universal-time time)
    (setf year (mod year 100.))
    (cl:ecase time:*date-printing-format*
      ((:mm//dd//yy :mm//dd//yyyy)
       (zwei:2-digit-into-array array month)
       (array-push array #//)
       (zwei:2-digit-into-array array day)
       (array-push array #//)
       (zwei:2-digit-into-array array year))
      ((:dd-mmm-yy :dd-mmm-yyyy)
       (zwei:2-digit-into-array array day)
       (array-push array #/-)
       (loop for ch being the array-elements of (first (nth (1- month) time:*months*))
	     do (array-push array ch))
       (array-push array #/-)
       (zwei:2-digit-into-array array year))
      (:iso
       (zwei:2-digit-into-array array 19.)
       (zwei:2-digit-into-array array year)
       (array-push array #/-)
       (zwei:2-digit-into-array array month)
       (array-push array #/-)
       (zwei:2-digit-into-array array day)))
    (when include-time
      (array-push array #\sp)
      (zwei:2-digit-into-array array hours)
      (array-push array #/:)
      (zwei:2-digit-into-array array minutes)
      (array-push array #/:)
      (zwei:2-digit-into-array array seconds))))

(defvar *dir-listing-buffer* (make-array 100. :type 'art-string :fill-pointer 0))

(defun zwei:list-directory-internal (pathnames directory printer)
  ;; For compatibility with pre-dw callers.
  (when (and pathnames (not (listp pathnames)))
    (setq pathnames (ncons pathnames)))
  (funcall printer (if (null (cdr pathnames))
		       (string (first pathnames))
		       (with-output-to-string (stream)
			 (scl:format-textual-list pathnames #'princ :stream stream)))
	   nil)
  (let ((last-directory (send (first pathnames) ':raw-directory))
	(last-device (send (first pathnames) ':raw-device))
	(last-host (send (first pathnames) :host))
	(deleted-space-consumed 0)
	(total-space-consumed 0))
    (tv:dolist-noting-progress (file directory "Processing pathnames in directory")
      (let ((pathname (car file)))
	(when (and pathname			;list starts with dummy entry(s)
		   (not (and (equal (send pathname :host) last-host)
			     (equal (send pathname ':raw-directory) last-directory)
			     (equal (send pathname ':raw-device) last-device))))
	  (setq last-directory (send pathname ':raw-directory)
		last-device (send pathname ':raw-device)
		last-host (send pathname :host))
	  (funcall
	    printer (format nil "~A:~A" (send (send pathname :host) :name-as-file-computer)
			    (send pathname :string-for-directory)) :switch))	;need flag
	(when pathname
	  (let ((length (get file ':length-in-blocks)))
	    (when length			;accumulate size info
	      (incf total-space-consumed length)
	      (when (get file ':deleted) (incf deleted-space-consumed length))))))
      (setf (fill-pointer *dir-listing-buffer*) 0)
      (with-output-to-string (stream *dir-listing-buffer*)
	(funcall zwei:*directory-single-file-lister* file stream))
      (decf (fill-pointer *dir-listing-buffer*))
      (funcall printer *dir-listing-buffer* file))
    (values total-space-consumed deleted-space-consumed)))


(cp:define-command (com-show-file :command-table "File")
    ((file '((cl:sequence fs:pathname))
	   :confirm t
	   :prompt "file"
	   :documentation "File to display"))
  (flet ((print-truename-and-maybe-name (pathname)
	   (let ((name (send pathname :string-for-printing))
		 (truename (send pathname :truename)))
	     (when truename			;will be nil if file doesn't exist
	       (let* ((truename-string (send truename :string-for-printing))
		      (pos (string-search name truename-string))
		      (name-is-substring (and pos (zerop pos))))
		 (format t "~&~% ***  ")
		 (if name-is-substring
		     (dw:with-output-as-presentation (:object truename
						      :type 'fs:pathname)
		       (format t "~A" truename-string))
		   (dw:with-output-as-presentation (:object pathname
						    :type 'fs:pathname)
		     (format t "~A" name)))
		 (format t "  ***")
		 (unless name-is-substring
		   (format t "~% ***  (")
		   (dw:with-output-as-presentation (:object truename
						    :type 'fs:pathname)
		     (format t "~A" truename-string))
		   (format t ")  ***"))
		 (format t "~2%"))))))
    (loop for file in file do
      (cond ((send file ':wild-p)
	     (condition-case (err-or-files)
		 (cdr (fs:directory-list file ':sorted))
	       (fs:file-operation-failure (format t "Error: ~~A~" err-or-files))
	       (:no-error
		 (setq err-or-files
		       (loop for (file . nil) in err-or-files
			     collect file))
		 (if (null err-or-files)
		     (format t "Error: ~A matches no files." file)
		     (loop for file in err-or-files
			   do (condition-case (err)
				  (progn
				    (print-truename-and-maybe-name file)
				    (viewf file))
				(fs:file-operation-failure
				  (format t "~&Cannot access ~A: ~~A~" file err)))
			      (fresh-terpri))))))
	    (t
	     (condition-case (err)
		 (progn
		   (print-truename-and-maybe-name file)
		   (viewf file))
	       (fs:file-operation-failure
		 (format t "~&Cannot access ~A: ~~A~" file err))))))))

;;; undelete commands

(cp:define-command (com-undelete-file :command-table "File")
    ((file '((cl:sequence fs:pathname))
	   :prompt "file"
	   :confirm t
	   :documentation "File to unmark re deletion")
     &key
     (query '((cl:member :yes :no :ask))
	    :mentioned-default :yes
	    :default :no
	    :documentation "Whether to ask before undeleting each file"))
   (when (eq query ':ask)
     (setq query (y-or-n-p "Ask before undeleting each file? "))
     (setq query (if query :yes :no)))
   (loop for file in file do
     (cond ((send file ':wild-p)
	    (condition-case (err-or-files)
		 (cdr (fs:directory-list file ':sorted ':deleted))
	       (fs:file-operation-failure (format t "Error: ~~A~" err-or-files))
	       (:no-error
		 (setq err-or-files
		       (loop for file in err-or-files
			     when (get (locf (cdr file)) ':deleted)
			       collect file))
		 (if (null err-or-files)
		     (format t "Error: ~A matches no deleted files." file)
		     (when (eq query :yes)
		       (format t "~&~%Undeleting the following ~D file~:P:~%"
			       (length err-or-files))
		       (loop for (file) in err-or-files
			     do (format t "  ~A~%" file)
			     finally (terpri)))
		     (loop for (file) in err-or-files
			   do (when (or (eq query :no)
					(y-or-n-p (format nil "~&Undelete ~A? " file)))
				(condition-case (err)
				     (undeletef file)
				   (fs:file-operation-failure
				     (format t "~&Cannot undelete ~A: ~~A~" file err))
				   (:no-error (when (eq query :no)
						(format t "~&~A undeleted." file))))))))))
	   (t
	    (let* ((no-such-file nil)
		   (truename (or (fs:link-opaque-truename file nil)
				 (progn (setq no-such-file t)
					file))))
	      (when (or no-such-file
			(eq query :no)
			(y-or-n-p (format nil "Undelete ~A? " truename)))
		(condition-case (err)
		     (undeletef truename)
		   (fs:file-operation-failure
		     (format t "~&Cannot undelete ~A: ~~A~" truename err))
		   (:no-error (format t "~&~A undeleted." truename)))))))))

;;; Edit commands

;This sets up the Simple editor, and a facility for extending it later with other
;editors such as Zmacs, FED, Concordia, ...

(defprop define-file-editor "File editor" si:definition-type-name)

(defflavor file-editor (function
			pretty-name
			(file-filter nil)
			(file-filter-description "suitable file")
			(context-filter nil)
			(context-filter-description nil)
			(permit-multiple nil)
			(source-filter nil)
			)
	   ()
  :initable-instance-variables
  :writable-instance-variables)

(defmethod (print-self file-editor) (stream ignore slashify-p)
  (if slashify-p
      (printing-random-object (self stream :typep) (princ pretty-name stream))
      (princ pretty-name stream)))

(compile-flavor-methods file-editor)

(defmethod (verify-editor file-editor) (files)
  (or (if (and (cdr files) (not permit-multiple))
	  "Cannot edit multiple files at once.")
      (if context-filter
	  (unless (funcall context-filter)
	    (format nil "~:[Does not work in this context.~;Only works ~:*~A.~]"
		    context-filter-description)))
      (if file-filter
	  (let ((failures (mapcan #'(lambda (file)
				      (unless (funcall file-filter file)
					(ncons file)))
				  files)))
	    (when failures
	      (let ((n (length failures)))
		(format nil "File name~P ~:*~\IS-ARE\ not the name~:P of ~A~:[.~;~:*:~{~
			   ~%  ~A~}~]"
			n
			(if (> n 1)
			    (string-pluralize file-filter-description)
			    (scl:string-a-or-an file-filter-description))
			(if (not (= n (length files))) failures))))))))

(defvar *all-file-editors* '())

(defun install-file-editor (file-editor &key after)
  (let* ((pretty-name (file-editor-pretty-name file-editor))
	 (existing-position (cl:member pretty-name *all-file-editors*
				       :key #'file-editor-pretty-name
				       :test #'string-equal))
	 (after-position (if after (cl:member after *all-file-editors*
					      :key #'file-editor-pretty-name
					      :test #'string-equal))))
    (cond ((and after-position
		existing-position
		(not (tailp existing-position after-position)))
	   (setq *all-file-editors* (delete (car existing-position) *all-file-editors*))
	   (push file-editor (cdr after-position)))
	  (existing-position
	   (setf (car existing-position) file-editor))
	  (after-position
	   (push file-editor (cdr after-position)))
	  (t
	   (push file-editor *all-file-editors*)))
    file-editor))

(defmacro define-file-editor (name
			      &rest options
			      &key pretty-name after
			      &allow-other-keys)
  (declare (zwei:indentation . 1))
  (cl:check-type name symbol "the name of an editor function")
  (cl:check-type pretty-name string "a literal string")
  (setq options (cl:copy-list options))
  (cl:remf options :after)
  `(sys:multiple-definition ,name define-file-editor
     (install-file-editor (make-instance 'file-editor :function ',name ,@options)
			  :after ,after)
     ',name))

(defun edit-file-default (editor files &optional verbose)
  (declare (values editor))
  (if (not files)
      (values nil "No file was specified.")
      (let ((problems '()))
	(dolist (editor (if (or (not editor) (eq editor :default))
			    *all-file-editors*
			    (list editor)))
	  (let ((problem (verify-editor editor files)))
	    (if problem
		(push (list editor problem) problems)
		(return-from edit-file-default editor))))
	(setq problems (nreverse problems))
	(when verbose
	  (let ((first-problem-string (cadr (car problems))))
	    (if (cl:every
		  #'(lambda (problem) (string-equal (cadr problem) first-problem-string))
		  (cdr problems))
		(format t "~&~A~%" first-problem-string)
		(format t "~&Unable to edit file~P.~:{~% ~A editor: ~~A~~}~%"
			(length files) problems))))
	nil)))


(defmethod (file-file-source file-editor) (files)
  (if source-filter
      (mapcar #'(lambda (file) (funcall source-filter file)) files)
      files))

(cp:define-command (com-edit-file :provide-output-destination-keyword nil
				  :command-table "File")
    ((files '((cl:sequence fs:pathname))
	    :prompt "file"
	    :documentation "Files to edit")
     &key
     (editor `((scl:token-or-type (:default)
				  ((cl:member ,@*all-file-editors*)
				   :description "an editor type")))
	     :prompt "to use"
	     :default :default
	     :display-default nil
	     :documentation "Which editing facility to use."))
   (when (setq editor (edit-file-default editor files t))
     (funcall (file-editor-function editor) (file-file-source editor files))))



(defun simple-edit-file (filename)
  "Edits the given file using the input editor."
  (flet ((fail (format-string &rest format-args)
	   (format t "~&Simple Editor: ~~?~~%"
		   format-string format-args)
	   (return-from simple-edit-file (values))))
    (when (listp filename)
      (cl:case (length filename)
	((0) (fail "No files specified."))
	((1) (setq filename (first filename)))
	(otherwise (fail "Too many files specified."))))
    (multiple-value-bind (text name size)
	(string-file filename :size-threshold #.(* 60. 80.)) ;A 60x80 screenful fully packed
      (unless text
	(fail "The file ~A is too big (~D bytes) to edit this way.~
	     ~%Use Create File to overwrite it with new data." name size))
      (simple-create-file filename :initial-text text))))

(defun string-file (file &key size-threshold)
  "Given the name of a file, returns its contents as a string and its truename."
  (declare (values string truename))
  (let ((truename (fs:merge-pathname-defaults file)))
    (let ((string (condition-case ()
		      (with-output-to-string (out)
			(with-open-file (in file :direction :input)
			  (setq truename (send in :truename))
			  (let ((size (cl:file-length in)))
			    (when (and size-threshold (> size size-threshold))
			      (return-from string-file (values nil truename size))))
			  (stream-copy-until-eof in out)))
		    (fs:file-not-found ""))))
      (values string truename))))

(cp:define-command (com-create-file :command-table "File"
				    :provide-output-destination-keyword nil)
    ((file 'cl:pathname
	   :prompt "file"
	   :documentation "File to create."))
   "Creates a file with the given name."
   (simple-create-file file :initial-text nil :if-exists :warn))

(defun simple-create-file (filename &key initial-text if-exists)
  "Creates a file with the given name."
  (when (eq if-exists :warn)
    (let ((probed (cl:probe-file filename)))
      (if probed (format t "~&Warning: The file ~A already exists." probed))))
  (let ((text (with-input-editing-options ((:initial-input (or initial-text ""))
					   (:no-input-save t))
		(prompt-and-read :delimited-string
				 "~:[Creating~;Editing~] ~A (~ writes, ~ aborts):~%"
				 initial-text filename #\end #\abort))))
    (with-open-file (out filename :direction :output)
      (cl:write-string text out)
      (close out)
      (format t "~&Written: ~A~%" (cl:truename out)))))

(defvar *binary-file-types-with-no-text-source* '(:sage-binary :kbin))

(defun text-file-p (file)
  (let ((path (cl:pathname file)))
    (and (fs:pathname-sequentially-accessible-p path)
	 ;; We allow binary files on the assumption that their source can be
	 ;; found, but we can't allow .sab files, which are only editable by
	 ;; Concordia
	 (not (cl:member (send path :canonical-type)
			 *binary-file-types-with-no-text-source*)))))

(defun text-or-source (file)
  (let ((pathname (cl:pathname file)))
    (if (get (send pathname :canonical-type) :binary-file-byte-size)
	(or ;; prefer loaded version
	  (send (send pathname :generic-pathname) :get :qfasl-source-file-unique-id)
	  (let ((attributes (fs:pathname-attribute-list pathname)))
	    ;; If the source file was a logical pathname, use it;
	    ;; otherwise resort to the physical path
	    (condition-case (file)
		 (cl:pathname (getf attributes :qfasl-source-file-unique-id))
	       (error (getf attributes :binary-source-file-original-truename))
	       (:no-error file)))
	  ;; --- edit wild type and hope? :lisp for now
	  (send pathname :new-pathname :type :lisp :version :newest))
	file)))

(si:define-file-editor simple-edit-file
  :pretty-name "Simple"
  :file-filter 'text-file-p
  :file-filter-description "text file"
  :source-filter 'text-or-source)
