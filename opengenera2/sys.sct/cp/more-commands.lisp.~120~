;;; -*- Mode: LISP; Syntax: Common-lisp; Package: CP; Base: 10; Lowercase: Yes -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; :Clear Output History

(define-command (com-clear-output-history :command-table "Window"
					  :provide-output-destination-keyword nil)
    ((window 'dw:dynamic-window
	     ;; *terminal-io* is per-process, much better than tv:selected-window
	     ;; in the face of activity system activity.
	     :default (and (typep *terminal-io* 'dw:dynamic-window)
			   *terminal-io*))
     &key
     (keep-marked-text 'boolean :default t
		       :documentation "Don't remove anything that's underlined.")
     (keep-screenfuls 'integer :default 0 :mentioned-default 5
		      :prompt "number of screenfuls"
		      :documentation "Don't remove anything within the last few screenfuls.")
     (keep-all-text 'boolean :default nil :mentioned-default t
		    :documentation "Remove presentations and graphics, but not characters."))
   (let ((tv:*asynchronous-window-operation* (neq sys:current-process (send window :process))))
     (send window :compress-output-history :marked-text (and keep-marked-text :keep)
					   :keep-screenfuls keep-screenfuls
					   :keep-all-text keep-all-text)))

(define-command (com-copy-output-history :command-table "Window"
					 :provide-output-destination-keyword nil)
    ((destinations 'destination :default nil)
     (source 'dw:dynamic-window :default (when (typep *terminal-io* 'dw:dynamic-window)
					   *terminal-io*)
				:prompt "from window"))
   (with-standard-output-bound destinations
     (dw::output-output-history-as-text source)))

(define-command (com-show-output-history :command-table "Window")
    ((window 'dw:dynamic-window :default (when (typep *terminal-io* 'dw:dynamic-window)
					   *terminal-io*)
	     :prompt "from window"))
   (dw::output-output-history-as-text window))

;;; :Show Users

(define-presentation-type user-at-host-or-site (() &key (print-host t))
   :parser ((stream)
	    (ignore print-host)
	    (let ((string (dw:read-standard-token stream)))
	      (si:with-parse-ferror ((sys:unknown-host-name net:object-not-found))
		(let ((atsign (string-search-char #\@ string)))
		  (if (null atsign)
		      `(:user ,(net:find-object-named :user string))
		      (nconc
			(unless (zerop atsign)
			  `(:user ,(string-thin (substring string 0 atsign)
						:remove-bits t :error-if :fat)))
			(let* ((host-or-site (substring string (1+ atsign)))
			       (site (and (not (string-search-char #\. host-or-site))
					  (condition-case ()
					       (net:find-object-named :site host-or-site)
					     (net:object-not-found
					       nil)))))
			  (if site
			      `(:site ,site)
			      `(:host ,(net:parse-host host-or-site))))))))))

   :printer ((spec stream)
	     (let ((user (getf spec :user)))
	       (when user
		 (princ user stream)))
	     (let ((host-or-site (zl:getl (locf spec) '(:host :site))))
	       (when (and host-or-site print-host)
		 (send stream :tyo #\@)
		 (princ (cadr host-or-site) stream))))

   :description "User, user@site, user@host, @site, or @host")

(define-command (si:com-show-users :name "Show Users" :command-table "Utilities")
    ((specs '((sequence user-at-host-or-site))
	    :prompt "users"
	    :documentation "User(s) to show.  This can be either a user name by itself or a
user-name (potentially null) followed by an @ followed by either the
name of a site or a host, as in JoeUser@My-Site."
	    :default `((:site ,net:*local-site*)))
     &key
     (format '((member :brief :normal :detailed))
	     :default :brief
	     :mentioned-default :normal
	     :documentation "Formatting of resulting display.")
     (search 'boolean
	     :when (some #'(lambda (spec) (and (getf spec :user)
					       (not (getf spec :host))
					       (not (getf spec :site))))
			 specs)
	     :prompt (format nil "all hosts at site ~A" net:*local-site*)
	     :default (neq format ':detailed)
	     :mentioned-default t
	     :documentation
	     (let* ((users (loop for spec in specs
				 when (and (getf spec :user)
					   (not (getf spec :host))
					   (not (getf spec :site)))
				   collect spec))
		    (n-users (length users)))
	       (with-output-to-string (str)
		 (format str "Whether to search all hosts at site ~A for user~P "
			 net:*local-site* n-users)
		 (format-textual-list users
				      #'(lambda (spec stream)
					  (present spec 'user-at-host-or-site :stream stream))
				      :conjunction "and" :stream str)
		 (format str "~%since neither a host nor a site was specified ~
				for ~:[each of these~;this~] user~P."
			 (= n-users 1) n-users))))
     (order '((member :host :user :idle))
	    :default :user
	    :mentioned-default :idle
	    :documentation "Sorting method for lisp machine list."))
  (let ((lispms-to-show nil)
	(other-hosts-to-show nil)
	(users-to-find nil))
    (dolist (spec specs)
      (if (getf spec :user)
	  (if (or (getf spec :host)
		  (and (not search) (not (getf spec :site))))
	      (push spec other-hosts-to-show)
	      (push spec users-to-find))
	  (let ((site (getf spec :site)))
	    (if site
		(setq lispms-to-show (append (if (eq site '*)
						 (neti:get-all-lispms)
						 (neti:get-lispms-at-site site))
					     lispms-to-show))
		(let ((host (getf spec :host)))
		  (if (and host (eq (send host :system-type) :lispm)
			   ;; Kludge to have server encaching finger accessible too.
			   (not (= (length specs) 1)))
		      (push host lispms-to-show)
		      (push spec other-hosts-to-show)))))))
    (when lispms-to-show
      (show-users-on-lispms lispms-to-show :format format :order order))
    (dolist (spec other-hosts-to-show)
      (show-user-on-host (or (getf spec :host) fs:user-login-machine)
			 :user (getf spec :user)
			 :format format
			 :original-spec spec))
    (when users-to-find
      (find-and-show-users users-to-find format order))))

(defun show-user-on-host (host &key user format original-spec)
  (fresh-line)
  (condition-case (error)
      (condition-bind ((net:host-does-not-support-service
			 #'neti:host-does-not-support-protocol-specify-path-handler))
	(net:invoke-service-on-host :show-users host :user user :whois (eq format :detailed)))
    (net:network-error
      (format t "~&An error occurred while showing \"")
      (if original-spec
	  (present original-spec 'user-at-host-or-site)
	  (princ host))
      (format t "\":~%~A~%" error))))

(defun show-users-on-lispms (hosts &key (format :brief) (order :user)
					(stream *standard-output*) (wait-message t)
					(show-active t) (show-inactive t))
  (let ((*standard-output* stream)
	(active nil)
	(free nil)
	(dead nil)
	(rejects nil))
    (funcall (if wait-message #'scan-lispms-with-wait-message #'neti:*scan-lispms)
	     hosts 
	     (lambda (host data)
	       (zl:destructuring-bind (id location idle-time . ignore) data
		 (if (equal id "")
		     (push (list host idle-time location) free)
		     (push (cons host data) active))))
	     (lambda (host ignore)
	       (push host dead))
	     (lambda (host error)
	       (push (list host error) rejects)))

    (when show-active
      (when active
	(show-users-on-active-lispms active format order)))

    (when show-inactive
      (when free
	(macrolet ((elem-host (elem) `(first ,elem))
		   (elem-idle (elem) `(or (second ,elem) ""))
		   (elem-location (elem) `(or (third ,elem) "")))
	  (let ((sort :host))
	    (dw:with-resortable-output ((free sort)
					(:host (lambda (elem-1 elem-2)
						 (string-lessp (elem-host elem-1)
							       (elem-host elem-2))))
					(:idle (lambda (elem-1 elem-2)
						 (idle-time-lessp (elem-idle elem-1)
								  (elem-idle elem-2))))
					(:location (lambda (elem-1 elem-2)
						     (string-lessp (elem-location elem-1)
								   (elem-location elem-2)))))
				       ()
	      (with-character-face (:italic)
		(format t "~2&Free Lisp machines:"))
	      (indenting-output (t '(5 :character))
		(terpri)
		(formatting-table (t :multiple-columns t
				     :output-multiple-columns-row-wise t)
		  (loop for elem in free doing
		    (formatting-row ()
		      (formatting-cell ()
			(present (elem-host elem)))
		      (formatting-cell (t :align :right)
			(write-string (elem-idle elem)))
		      (formatting-cell ()
			(abbreviating-output (t :width 30.)
			  (write-string (elem-location elem))))))))))))

      (when dead
	(setq dead (sort dead #'string-lessp))
	(with-character-face (:italic)
	  (format t "~2&Lisp machines not responding: "))
	(format-textual-list dead (lambda (host stream)
				    (present host 'net:host :stream stream))
			     :conjunction "and" :after-line-break "     "))

      (when rejects
	(setq rejects (sort rejects #'string-lessp :key #'car))
	(with-character-face (:italic)
	  (format t "~2&Other errors: ~%"))
	(loop for (host error) in rejects
	      do (dw:with-output-as-presentation (:object host :type 'net:host)
		   (format t "~&~A: ~~A~~%" host error)))))

    (values active free dead rejects)))

;;; Idle times are expressed as strings, not numbers.
(defun idle-time-lessp (x y)
  (let ((len-1 (string-length x))
	(len-2 (string-length y)))
    (or (< len-1 len-2)
	(and (= len-1 len-2)
	     (string-lessp x y)))))

(defun show-users-on-active-lispms (active format order)
  (macrolet ((elem-host (elem) `(first ,elem))
	     (elem-user (elem) `(second ,elem))
	     (elem-location (elem) `(or (third ,elem) ""))
	     (elem-idle (elem) `(or (fourth ,elem) "")))
    (dw:with-resortable-output ((active order)
				(:user (lambda (elem-1 elem-2)
					 (string-lessp (elem-user elem-1)
						       (elem-user elem-2))))
				(:host (lambda (elem-1 elem-2)
					 (string-lessp (elem-host elem-1)
						       (elem-host elem-2))))
				(:idle (lambda (elem-1 elem-2)
					 (idle-time-lessp (elem-idle elem-1)
							  (elem-idle elem-2)))))
			       ((format "Format" ((member :brief :normal :detailed))))
      (ecase format
	(:brief
	 (formatting-table (t :multiple-columns t
			      :output-multiple-columns-row-wise t)
	   (formatting-column-headings (t :underline-p t)
	     (with-character-face (:italic)
	       (format-cell "User" #'write-string)
	       (format-cell "Host" #'write-string)
	       (format-cell "Idle" #'write-string :align-x :right)))
	   (dolist (elem active)
	     (formatting-row ()
	       (let ((user (elem-user elem))
		     (host (elem-host elem)))
		 (formatting-cell ()
		   (present `(:user ,user :host ,host)
			    '((user-at-host-or-site) :print-host nil)))
		 (formatting-cell ()
		   (present host)))
	       (format-cell (elem-idle elem) #'write-string :align-x :right)))))
	((:normal :detailed)
	 (show-users-on-active-lispms-00 active format))))))

;;; This is a separate function only because the compiler screws up
;;; if you put it all together.  That's why the indentation's still funny, too.
(defun show-users-on-active-lispms-00 (active format)
  (macrolet ((elem-host (elem) `(first ,elem))
	     (elem-user (elem) `(second ,elem))
	     (elem-location (elem) `(or (third ,elem) ""))
	     (elem-idle (elem) `(or (fourth ,elem) "")))
	 (flet ((common-headings ()
		  (formatting-column-headings (t :underline-p t)
		    (with-character-face (:italic)
		      (formatting-cell () "User")
		      (formatting-cell () )
		      (formatting-cell () "Name")
		      (formatting-cell () "Host")
		      (formatting-cell (t :align :right) "Idle")
		      (when (eq format :normal)
			(formatting-cell () "Location")))))
		(common-per-host (elem)
		  (destructuring-bind (host user location idle-time personal-name group
				       . ignore) elem
		    location
		    (formatting-cell ()
		      (present `(:user ,user :host ,host)
				   `((user-at-host-or-site) :print-host nil)))
		    (formatting-cell ()
		      (write-string group))
		    (formatting-cell ()
		      (write-string personal-name))
		    (formatting-cell ()
		      (present host 'net:host))
		    (formatting-cell (t :align :right)
		      (write-string idle-time)))))
	   (case format
	     (:normal
	      ;--- abbreviating-output and table formatting don't get along right now.
	      (progn ;abbreviating-output (t :width t)
		(formatting-table ()
		  (common-headings)
		  (dolist (elem active)
		    (formatting-row ()
		      (common-per-host elem)
		      (formatting-cell ()
			(write-string (elem-location elem))))))))
	     (:detailed
	      (formatting-table ()
		(common-headings)
		(dolist (elem active)
		  (formatting-row ()
		    (common-per-host elem))
		  (formatting-row (t :single-column t)
		    (formatting-cell ()
		      (filling-output (t :after-line-break "       -"
					 :after-line-break-initially-too t)
			(write-string (elem-location elem))))))))))))

(defun find-and-show-users (specs format order)
  (let ((finds nil))
    (let ((user-list (loop for spec in specs
			   collect (let ((user (getf spec :user)))
				     (if (stringp user)
					 user
					 (send user :lispm-name)))))
	  (hosts (loop for site in (delete-duplicates
				     (loop for spec in specs
					   as site = (getf spec :site)
					   when (null site)
					     collect net:*local-site*
					   else collect site))
		       append (neti:get-lispms-at-site site))))
      ;; Do quick scan looking for any matching users (possibly at wrong site, etc.)
      (scan-lispms-with-wait-message hosts
				     (lambda (host data)
				       (when (member (first data) user-list
						     :test #'string-equal)
					 (push (cons host data) finds)))))

    (let ((real-finds nil)
	  (specs-found nil))
      (dolist (find finds)
	(dolist (spec specs)
	  (when (equal (second find) (let ((user (getf spec :user)))
				       (if (stringp user)
					   user
					   (send user :lispm-name))))
	    (when (let ((site (getf spec :site)))
		    (or (null site)
			(eq site (send (first find) :site))))
	      (push find real-finds)
	      (push spec specs-found)))))
      (when real-finds
	(show-users-on-active-lispms real-finds format order))
      (let ((not-found (remove-if (lambda (spec) (member spec specs-found)) specs)))
	(when not-found
	  (setq not-found (sort not-found (lambda (x y)
					    (string-lessp
					      (getf x :user)
					      (getf y :user)))))
	  (with-character-face (:italic)
	    (format t "~2&User~P not found logged in:~%" (length not-found)))
	  (dolist (spec not-found)
	    (let ((user (getf spec :user)))
	      (when (stringp user)
		(show-user-on-host (let ((site (getf spec :site)))
				     (when (null site)
				       (setq site net:*local-site*))
				     (first (send (send site :local-namespace)
						  :primary-name-server)))
				   :user user :format format :original-spec spec))))
	  (formatting-table ()
	    (dolist (spec not-found)
	      (let ((user (getf spec :user)))
		(unless (stringp user)
		  (formatting-row ()
		    (formatting-cell ()
		      (dw:with-output-as-presentation
			(:object spec :type 'user-at-host-or-site)
			(write-string (send user :lispm-name))))
		    (formatting-cell ()
		      (let ((aff (send user :affiliation)))
			(when aff
			  (write-string aff))))
		    (formatting-cell ()
		      (write-string (send user :personal-name))))
		  (when (eq format :detailed)
		    (neti:print-whois-internal *standard-output* user t)))))))))))

(defun scan-lispms-with-wait-message (hosts &rest args)
  (let ((length (length hosts)))
    (when (> length 10)
      (format *error-output* "~%Polling ~D host~:P, please wait..." length))
    (apply #'neti:*scan-lispms hosts args)
    (send *error-output* :set-cursorpos 0 nil)
    (send *error-output* :clear-rest-of-line)))

(define-presentation-to-command-translator com-x-show-users (user-at-host-or-site) (user)
  `(si:com-show-users (,user) :format :detailed))

(define-presentation-to-command-translator show-users-host (net:host) (host)
  `(si:com-show-users ((:host ,host)) :format :normal))

(define-presentation-translator user-at-host-or-site-to-host
				(user-at-host-or-site net:host) (user)
  (getf user :host))

;;; Hopefully this won't be too slow.
;;; --- It is too slow.  What should we do?  Punt?  Assume that the value in
;;; user is valid if it isn't ""?
(define-presentation-translator user-at-host-or-site-to-net-object-of-class-user
   (user-at-host-or-site net::user
			 :tester ((user)
				  (let ((user (getf user :user)))
				    (when user
				      (cond ((typep user 'net:user)
					     t)
					    ((net:find-object-named :user user nil)
					     t))))))
   (user)
  (let ((user (getf user :user)))
    (cond ((typep user 'net:user) user)
	  (t (net:find-object-named :user user)))))

(define-presentation-translator host-to-user-at-host-or-site
				(net:host user-at-host-or-site) (host)
  `(:host ,host))

;;; For use with more or less compatible function keys.
(defun pop-up-run-command (command-name arg &optional arg-function)
  (unless arg-function
    (setq arg-function #'(lambda (arg)
			   (and arg (read-command-arguments command-name)))))
  (using-resource (window dw:dynamic-window (sys:console-screen sys:*console*)
		    :margin-components dw::*ragged-borders-label-and-scroll-bars-margin-components*
		    :blinker-p t)
    (multiple-value-bind (left top right bottom) (send (sys:console-screen sys:*console*)
						       :inside-edges)
      (send window :set-edges left top right bottom)) 
    (send window :set-label `(:string ,(present-to-string command-name 'cp:command-name)
			      :character-style (:swiss :bold :normal)))
    (tv:window-call (window :deactivate)
      ;; Remove blips that will confuse the input editor's noise strings.
      (loop as char = (send window :any-tyi-no-hang)
	    while char
	    when (not (consp char))
	      return (send window :untyi char))
      ;; Allow input to this window now that it's selected.
      (tv:console-end-selection-input-hold)
      (let ((*terminal-io* window)
	    (*standard-output* sys:syn-terminal-io)
	    (*standard-input* sys:syn-terminal-io)
	    (*query-io* sys:syn-terminal-io))
	(multiple-value-bind (start-x start-y)
	    (send *standard-output* :read-cursorpos)
	  (let ((command (cons command-name (funcall arg-function arg))))
	    (loop
	      (send *standard-output* :set-cursorpos start-x start-y)
	      (send *standard-output* :clear-rest-of-window)
	      (fresh-line)
	      (present command 'cp:command)
	      (format t ":~%")
	      (apply (first command) (rest command))
	      (fresh-line)
	      (multiple-value-setq (start-x start-y)
		(send *standard-output* :read-cursorpos))
	      (dw:with-presentation-input-context
		   ;; Allow clicking on a host for another show users, detailed.
		 (`((cp:command :command-table ,cp:*command-table*)))
		 (blip)
		   ;; Use accept so that commands like s-R and m-Scroll are available.
		   (return
		     (accept 'character :provide-default nil
					:prompt "Type a space to refresh the screen"))
		 (cp:command
		   (setq command (dw:presentation-blip-object blip)))))))))))

(defvar *finger-arg-alist*)

(defun set-site-finger-arg-alist ()
  (setq *finger-arg-alist*
	(copy-list
	  (let ((entry (si:get-site-option ':terminal-f-argument)))
	    (if (null entry)
		'((nil . :login) (0 . :read) (1 . :local-lisp-machines))
		(loop for (arg type hosts) in entry
		      collect (cons
				(selector arg string-equal
				  ("NONE" 'nil)
				  ("*" 't)
				  (otherwise (parse-integer arg)))
				(if (eq type ':host)
				    hosts
				    type))))))))

(add-initialization "SITE:*FINGER-ARG-ALIST*" '(set-site-finger-arg-alist) '(:site))

(defvar tv:*function-f-format* :standard)

(defun convert-function-f-argument (arg)
  (when (typep arg '(or null integer))
    (setq arg (or (cdr (assoc arg *finger-arg-alist*))
		  (cdr (assoc 't *finger-arg-alist*))
		  :login)))
  (list
    (case arg
      ((:login :associated)
       `((:host ,fs:user-login-machine)))
      ((:local-lisp-machines :lisp-machines)
       `((:site ,net:*local-site*)))
      ((:all-lisp-machines)
       `((:site *)))
      ((:read)
       (return-from convert-function-f-argument
	 (read-command-arguments 'si:com-show-users)))
      (otherwise
	(loop for host in arg collect `(:host ,host))))
    :format (case tv:*function-f-format*
	      (:standard :normal)
	      (otherwise tv:*function-f-format*))))

(defun finger-arg-prompt ()
  (with-output-to-string (stream)
    (present 'si:com-show-users 'cp:command-name :stream stream)
    (format stream ": ")
    (format-textual-list *finger-arg-alist*
      #'(lambda (entry stream)
	  (let ((arg (first entry)))
	    (if arg (format stream "~D: " arg) (format stream " no arg: ")))
	  (let ((arg (rest entry)))
	    (case arg
	      (:read (write-string "prompt" stream))
	      (otherwise
		(present (first (convert-function-f-argument arg))
			 '((sequence user-at-host-or-site))
			 :stream stream)))))
      :stream stream :separator "; "
      :filled t :after-line-break "  ")))

(defun pop-up-show-users (arg)
  (pop-up-run-command 'si:com-show-users arg #'convert-function-f-argument))

(tv:add-function-key #\F 'pop-up-show-users '(finger-arg-prompt)
		     :typeahead :process "Function-F")

;;; Pre CP "command" compatibility
(defun net:finger-local-lispms
       (&optional (stream *standard-output*) (print-free t) (return-free nil))
  (neti:finger-lispms (net:get-local-lispms) stream
		      :print-free print-free
		      :return-free return-free))

(defun net:finger-all-lispms
       (&optional (stream *standard-output*) (print-free t) (return-free nil))
  (neti:finger-lispms (net:get-all-lispms) stream
		      :print-free print-free
		      :return-free return-free))

(defun neti:finger-lispms-at-site
       (a-site-name &optional (stream *standard-output*) (print-free t) (return-free nil))
  (neti:finger-lispms (neti:get-lispms-at-site a-site-name) stream
		      :print-free print-free
		      :return-free return-free))

(defun neti:finger-lispms (hosts &optional (stream *standard-output*)
			         &key (print-free t) (return-free nil) (single-line t))
  (let ((show-active t)
	(show-inactive print-free)
	(wait-message t))
    (when (eq stream #'sys:null-stream)
      (setq show-active nil
	    show-inactive nil
	    wait-message nil))
    (multiple-value-bind (ignore free)
	(show-users-on-lispms hosts :format (if single-line :normal :detailed)
			      :show-inactive show-inactive :show-active show-active
			      :wait-message wait-message :stream stream)
      (and return-free (map 'list #'first free)))))

(defun neti:finger-lispm-briefly (hosts &optional (stream *standard-output*))
  (show-users-on-lispms hosts :stream stream))

(define-command (si:com-show-hosts :command-table "Networks")
    ((hosts '((token-or-type (:all) ((sequence net:host))))
	    :default :all
	    :display-default nil
	    :prompt "hosts"
	    :documentation "Hosts about which to display status information"))
   (if (eq hosts :all)
       (net:hostat)
       (apply #'net:hostat hosts)))

(defun pop-up-show-hosts (arg)
  (pop-up-run-command 'si:com-show-hosts arg))

(tv:add-function-key #\H 'pop-up-show-hosts
		     "Show Hosts:  with an argument, prompt for hosts."
		     :typeahead :process "Function-H")

(define-presentation-type fs:capability ()
   :history t
   :expander 'string)

(define-command (com-enable-capabilities :command-table "Networks"
					 :provide-output-destination-keyword nil)
    ((host 'net:host
	   :default (send si:*user* :home-host)
	   :prompt "on host"
	   :documentation "Host to enable capabilities on")
     (capabilities '((sequence fs:capability))
       :prompt "capabilities"
       :default (send host :default-enable-capabilities)
       :documentation "Capabilities to enable on host"))
   (loop for (cap . on) in (apply #'fs:enable-capabilities host capabilities)
	 do (format t "~&~A capability on ~A is ~:[disabled~;enabled~].~%"
		    cap host on)))

(define-command (com-disable-capabilities :command-table "Networks"
					  :provide-output-destination-keyword nil)
    ((host 'net:host
	   :default (send si:*user* :home-host)
	   :prompt "on host"
	   :documentation "Host to disable capabilities on")
     (capabilities '((cl:sequence fs:capability))
       :prompt "capabilities"
       :default (send host :default-enable-capabilities)
       :documentation "Capabilities to disable on host"))
   (loop for (cap . on) in (apply #'fs:disable-capabilities host capabilities)
	 do (format t "~&~A capability on ~A is ~:[disabled~;enabled~].~%"
		    cap host on)))


;;; ECC Commands

#+(and IMach (not VLM))
(progn

(defvar *ecc-scrubber-ppn* 0)
(defvar *ecc-verify-ptr* -1)        ;; the number of ecc errors logged
(defvar *ecc-timer*)                 ;; the ecc timer
(defparameter *ecc-timer-interval* 10)        ;; the ecc timer interval in seconds
(defvar *scrub-memory-for-ecc-errors* t)	;whether to scrub in addition to logging

(defvar *ecc-matrix*
	      '(#b1001111010000010101101000110100100110100
		#b0100111001100001010110011000010000111001
		#b0110101100101000111000011001011011000001
		#b0001101110010100010101100010000111000110
		#b1011000110010011010010001001100000101011
		#b0101100001000011100101100100011000010101
		#b1110010001101100000100100110001010001110
		#b0101001000011100011010010001100101000101))

(defun make-ecc-xref-table ()
  (let ((table (make-array 40 :initial-element 0))
	(number)
	(shift-var 0))
    (loop for element in *ecc-matrix* do
      (loop for bitpos from 0 to 39 do
	(setf number (aref table bitpos))
	(setf number (logior number (ash (ldb (byte 1 bitpos) element) shift-var)))
	(setf (aref table bitpos) number))
      (incf shift-var))
    table))

(defvar *ecc-xref-table* (make-ecc-xref-table))

;; The verification routine for the ecc process handler
;; The process executes when this routine is t
(defun ecc-verify ()
  (or (not (eql *ecc-verify-ptr* storage::*ecc-log-ptr*))
      ;; pending-p covers the warm-boot case of the timer being
      ;; "neutralized"
      (not (process:timer-pending-p *ecc-timer*))))

;; The code executing within the ecc server process
;; It wakes up when either - every quantum of time (*ecc-timer-interval*)
;;                   or    - when pht-remove has discovered and logged a new ecc error.
(defun ecc-process-handler ()
  (if *scrub-memory-for-ecc-errors*
      (loop repeat 100				;--- tunable?
	    do #+debug
	       (tv:note-progress *ecc-pages-scrubbed*
				 storage::*count-usable-pages*
				 *ecc-scrubber-progress-note*)
	       (storage::scan-page-for-ecc-errors *ecc-scrubber-ppn*)
	       #+debug
	       (progn
		 (incf *ecc-pages-scrubbed*)
		 (when (> *ecc-pages-scrubbed* storage::*count-usable-pages*)
		   (setq *ecc-pages-scrubbed* 0)))
	       (setq *ecc-scrubber-ppn* (storage::next-ppn *ecc-scrubber-ppn*)))
      ;; else just look for and report
      (si:%funcall-in-aux-stack #'storage::check-for-memory-ecc-error))
  ;; report any errors you found
  (loop with limit = storage::*ecc-log-ptr*
	with wrap = storage::*ecc-log-size*
	with ptr = *ecc-verify-ptr*
	with notify = storage::*ecc-notification-on*
	until (= ptr limit)
	finally (setf *ecc-verify-ptr* ptr)
	do
    (incf ptr 2)
    (when (> ptr wrap)
      (setq ptr 1))
    (cond ((or (and (= ptr 1) (< storage::*ecc-log-counter* wrap)) ;first time
	       (= (ldb sys:%%ecc-log-access-mask (aref storage::*ecc-error-log* (1- ptr)))
		  storage::ecc-error-stuck))		;stuck
	   ;; --- say something different if it's stuck?
	   (tv:notify nil "Warning: An error correction has occurred in physical memory.
For further information use the ~\\cp:command\\"
		      '(cp::com-show-memory-error-corrections :detailed t)))
	  (notify
	   (tv:notify nil
		      "Warning: A error correction has occurred at physical memory address ~\\si:address\\"

		      (aref storage::*ecc-error-log* ptr)))))
  (process:reset-timer-relative *ecc-timer* *ecc-timer-interval*))

(defun initialize-ecc-process ()
  ;; Create ECC process which will watch ECC registers for ECCs and notify user (if requested)
  (setf *ecc-verify-ptr* -1
	*ecc-scrubber-ppn* 0)
  (when storage::*ecc-process*
    (process:kill (shiftf storage::*ecc-process* nil)))
  (setf storage::*ecc-process*
	(process:make-process "Memory ECC Handler"
			      :simple-p t :system-process t
			      :top-level-whostate "Memory ECC Handler"
			      :verify-function 'ecc-verify
			      :run-reasons nil
			      :initial-function 'ecc-process-handler
			      :interrupt-handler t))
  (setf *ecc-timer*
	(process:create-timer-wakeup storage::*ecc-process* :name "Memory ECC Handler"))
  (process:enable storage::*ecc-process*)
  (process:reset-timer-relative *ecc-timer* 0))

(add-initialization "Start Memory ECC Process" '(initialize-ecc-process) '(:once))

(defun restart-ecc-process ()
  (setf *ecc-verify-ptr* -1
	*ecc-scrubber-ppn* 0))

(add-initialization "Restart Memory ECC Process"
		    '(restart-ecc-process)
		    '(:cold))

(define-command (com-show-memory-error-corrections :command-table "Session")
    (&key
      (detailed 'scl:boolean
		:default nil
		:mentioned-default t
		:documentation "List the logged error correction codes")
      (newest   '(integer 0 *)
                :default 20
		:mentioned-default 20
                :documentation "The number of items to be output"))
   (print-memory-ecc :verbose detailed :specified-no-of-elements newest))

(defun print-memory-ecc (&key verbose (stream *standard-output*) specified-no-of-elements)
  (cond ((> storage::*ecc-log-counter* 1)
	 (format stream "~&There have been ~d memory error corrections."
		 storage::*ecc-log-counter*))
	((= storage::*ecc-log-counter* 0)
	 (format stream "~&There have not been any memory error corrections."))
	((= storage::*ecc-log-counter* 1)
	 (format stream "~&There has been 1 memory error correction.")))
  (when (and verbose (> storage::*ecc-log-counter* 0) (> specified-no-of-elements 0))
    (let ((no-of-entries (if (< storage::*ecc-log-counter* storage::*ecc-log-size*)
			     (values storage::*ecc-log-counter*);; Wrap around??
			     (/ storage::*ecc-log-size* 2))) ;; Print entire circular log
	  )
      (when (< specified-no-of-elements no-of-entries)
	(setf no-of-entries specified-no-of-elements))
      (cond ((> no-of-entries 1)
	     (format stream "~%The newest ~d error corrections are listed." no-of-entries)
	     (format stream "~%The most recent memory error correction is listed first."))
	    ((= no-of-entries 1)
	     (format stream "~%The newest memory error correction is listed.")))
      (format stream "~2%")
      (formatting-table (stream :inter-column-spacing 3)
	(formatting-column-headings (stream)
	  (with-character-face (:italic stream)
	    (formatting-cell (stream)
	      (with-underlining (stream) (princ "Memory Address" stream)))
	    (formatting-cell (stream)
	      (with-underlining (stream) (princ "Check Bit" stream)))
	    (formatting-cell (stream)
	      (with-underlining (stream ) (princ "ECC Syndrome" stream)))
	    (formatting-cell (stream)
	      (with-underlining (stream ) (princ "Disposition" stream)))))
	(let ((log-offset (- storage::*ecc-log-ptr* 1)))
	  (dotimes (ignore no-of-entries)
	    (let* ((ecc-syndrome
		     (ldb sys:%%ecc-log-syndrome (aref storage::*ecc-error-log* log-offset)))
		   (ecc-access
		     (ldb sys:%%ecc-log-access-mask (aref storage::*ecc-error-log* log-offset)))
		   (bit-position (position ecc-syndrome *ecc-xref-table*)))
	      ;; Since we are printing from most-recent to least
	      ;; recent, these "unlogged" errors are actually newer
	      ;; than the error we did record (not really in the case
	      ;; of an uncorrectable error that superceded a
	      ;; correctable one, but we don't sweat that)
	      (when (ldb-test sys:%%ecc-log-error-lost
			      (aref storage::*ecc-error-log* log-offset))
		(formatting-row (stream)
		  (formatting-cell (stream :align-x ':right)
		    (princ "..." stream))
		  (formatting-cell (stream :align-x ':center)
		    (princ "..." stream))
		  (formatting-cell (stream :align-x ':center)
		    (princ "..." stream))
		  (formatting-cell (stream)
		    (princ "Soft (corrected) error(s), unlogged" stream))))
	      (with-character-style ((if (or (null bit-position)	;uncorrectable
					     (eql ecc-access storage::ecc-error-stuck))
					 '(nil :bold nil)
					 nil) stream)
		(formatting-row (stream)
		  (formatting-cell (stream :align-x ':right)
		    (si:print-address (aref storage::*ecc-error-log* (+ log-offset 1)) stream))
		  (formatting-cell (stream :align-x ':center)
		    ;; huh? a multi-bit error should halt
		    (princ (or bit-position "Multiple") stream))
		  (formatting-cell (stream :align-x ':center)
		    (princ ecc-syndrome stream))
		  (formatting-cell (stream)
		    (if bit-position
			(princ "Soft (corrected) error, " stream)
			(princ "Uncorrectable error, " stream))
		    (princ
		      (select ecc-access
			(storage::ecc-error-repaired "repaired by scrubber")
			(storage::ecc-error-stuck "stuck (D,#TD1PsT[Begin using 006 escapes](1 0 (NIL 0) (NIL :BOLD-ITALIC NIL) "CPTFONTBI")call field service0)")
			(storage::ecc-error-ignored "ignored (corrected data written to disk)")
			(storage::ecc-error-virtual "virtual access")
			(storage::ecc-error-physical "physical access")
			(storage::ecc-error-unknown "unknown access")
			(t "Bad log entry"))
		      stream)
		    ))
		)
	      )
	    (when (< (setf log-offset (- log-offset 2)) 0)
	      (setf log-offset (- storage::*ecc-log-size* 2)))))))
    (format stream "~2%")))

(define-command (com-enable-memory-error-correction-notifications
		     :command-table "Session"
		     :provide-output-destination-keyword nil)
    (&key)
   (set-ecc-notify :notification t))

(define-command (com-disable-memory-error-correction-notifications
		     :command-table "Session"
		     :provide-output-destination-keyword nil)
    (&key)
   (set-ecc-notify :notification nil))

(defun set-ecc-notify (&key notification)
  (cond ((and notification storage::*ecc-notification-on*)
	 (format t "~&Ecc notification is already on"))
	((and (not notification) (not storage::*ecc-notification-on*))
	 (format t "~&Ecc notification is already off"))
	((not notification)
	 (setf storage::*ecc-notification-on* nil))
	(notification
	 (setf storage::*ecc-notification-on* t))))

#|Debug|

(defun make-ecc-xref-table ()
  (let ((table (make-array 48 :initial-element 0))
	(number)
	(shift-var 0))
    (loop for element in *ecc-matrix* do
      (loop for bitpos from 0 to 39 do
	(setf number (aref table bitpos))
	(setf number (logior number (ash (ldb (byte 1 bitpos) element) shift-var)))
	(setf (aref table bitpos) number))
      (incf shift-var))
    (loop for bitpos from 40 to 47 do
      (setf (aref table bitpos) (lsh 1 (- bitpos 40))))
    table))

(defvar *ecc-xref-table* (make-ecc-xref-table))

(defmacro build-byte-ecc-table ()
  (labels ((parity-sum (word)
	     (logand (cl:logcount word) 1))
	   (check-bits (word)
	     (loop for row in *ecc-matrix*
		   for i from 0
		   sum (ash (parity-sum (logand row word)) i))))
    (let ((byte-ecc-table (make-array #o2400 :element-type '(unsigned-byte 8))))
      (loop for byte-number from 0 to 4
	    as byte-starting-position = (* byte-number #o10)
	    as increment = (ash 1 byte-starting-position)
	    do
	(loop for byte from 0 below #o400
	      for shifted-byte from 0 by increment
	      do
	  (setf (aref byte-ecc-table (dpb byte-number (byte #o3 #o10) byte))
		(check-bits shifted-byte))))
      byte-ecc-table)))

(defun compute-ecc (tag data)
  (let ((table (build-byte-ecc-table)))
    (declare (sys:array-register table))
    (logxor #o377
	    (aref table (dpb 0 (byte 3 #o10) (ldb (byte #o10 0) data)))
	    (aref table (dpb 1 (byte 3 #o10) (ldb (byte #o10 #o10) data)))
	    (aref table (dpb 2 (byte 3 #o10) (ldb (byte #o10 #o20) data)))
	    (aref table (dpb 3 (byte 3 #o10) (ldb (byte #o10 #o30) data)))
	    (aref table (dpb 4 (byte 3 #o10) (ldb (byte #o10 0) tag))))))

(sys:defwiredfun write-bad-ecc-internal (mem-ctl test-mode address ecc tag pointer)
  (unwind-protect
      (progn
	;; Don't let an interrupt happen in check mode
	(sys:%set-trap-mode sys:trap-mode-io)
	;; don't let stack dump in check mode
	(si:%ensure-n-pushes-without-stack-cache-spill 7)
	;; Can't let pre-fetches occur during check mode
	;; no-op's fill cache
	(compiler::no-op) (compiler::no-op) (compiler::no-op)
	(compiler::no-op) (compiler::no-op) (compiler::no-op)
	;; flush write buffer before setting control
	(compiler::for-effect
	  (sys:%memory-read #'write-bad-ecc-internal :cycle-type sys:%memory-raw))
	(let ((data (sys:%set-tag pointer tag)))
	  (setf sys:(%read-internal-register %register-memory-control)
		test-mode)
	  (sys:%write-internal-register ecc sys:%register-ecc-log)
	  (sys:%memory-write address data)
	  ;; flush write buffer before setting control
	  (compiler::for-effect
	    (sys:%memory-read #'write-bad-ecc-internal :cycle-type sys:%memory-raw))
	  (setf sys:(%read-internal-register %register-memory-control)
		mem-ctl))
	;; let errro percolate to log
	(compiler::no-op) (compiler::no-op)
	;; clear any bogus error from log
	(sys:%read-internal-register sys:%register-ecc-log))
    ;; be safe
    (setf sys:(%read-internal-register %register-memory-control)
	  mem-ctl)))

(defun write-bad-ecc (address tag pointer error-bit)
  (let* ((pointer-limit (byte-size sys:%%q-pointer))
	 (tag-limit (+ (byte-size sys:%%q-tag) pointer-limit))
	 (mem-ctl (sys:%logdpbs 0 sys:%%MEMORY-CONTROL-CHECK-BIT-TEST-MODE-ENABLE
				1 sys:%%MEMORY-CONTROL-ECC-ENABLE
				sys:(%read-internal-register %register-memory-control)))
	 (test-mode (sys:%logdpbs 1 sys:%%MEMORY-CONTROL-CHECK-BIT-TEST-MODE-ENABLE
				  0 sys:%%MEMORY-CONTROL-ECC-ENABLE
				  mem-ctl)))
    ;; Don't write fault
    (sys:%memory-write address (sys:%set-tag pointer tag))
    (unwind-protect
	(let ((ecc (if (< error-bit tag-limit)
		       (compute-ecc tag pointer)
		       (logxor
			 (compute-ecc tag pointer)
			 (lsh 1 (- error-bit tag-limit)))))
	      (tag (if (< error-bit pointer-limit)
		       tag
		       (logxor tag (lsh 1 (-  error-bit pointer-limit)))))
	      (pointer (if (< error-bit pointer-limit)
			   (logxor pointer (lsh 1 error-bit))
			   pointer)))
	  ;; Don't page fault
	  (storage::wire-words address 1)
	  (write-bad-ecc-internal mem-ctl test-mode address ecc tag pointer))
      (storage::unwire-words address 1))))

|gubeD|#
)



;;; Boot commands

;;; This is not in Utility-Commands because it was debugged for a CL-based package
;;; and Utility-Commands is in SI. I'm just not up to changing it over to Zetalisp
;;; just so it can be with its pals like Halt Machine.
;;; This is run in a separate process to avoid problems with shutting down our own console.
(defun perform-halt (fep-command-string)
  ;; Really disable the services
  (sys:disable-services :all nil t)
  ;; Shutdown all the X-consoles
  (loop for console in sys:*consoles*
	when (typep console 'x-screen::x-console)
	  do
	    (x-screen:x-console-shutdown console :abort t))
  (sys:halt fep-command-string))

(defun halt-machine-internal (&key logout (query :confirm-only)
			      (delay 0) (reason "for halting")
			      fep-command-string (description "halt") simulate
			      final-message)
  (let ((verb (if logout
		  (format nil "logout and ~A" description)
		  description))
	(si:*confirm-logout-p* query))
    (unless (si:confirm-logout :verb verb
			       :simulate simulate)
      (return-from halt-machine-internal)))
  (let* ((n-servers (if net:*active-servers* (length net:*active-servers*)))
	 (message
	   (format nil "~@[~'iWarning! ~There ~0@*~\\is-are\\ ~:*~D active ~
			server~:P~3@*~:[~;, ~'iand~ you have not~
		        ~%~9Tallowed ~3@*~A time for ~A to shut down~].~%~]~
			~5@*~@[~'iWarning! ~There ~\\is-are\\ ~:*~D ~
			open file~:P.~%~]~
			~6@*~:[~1@*~@(~A~)ing~;Logging out and ~1@*~Aing~] ~
			~2@*~:[immediately~;in ~2@*~\\time-interval\\~]~
			~6@*~:[ ~'iwithout~ logging out~;~].~
			~%Do you really want to do this? "
		   n-servers			; Arg 0
		   description			; Arg 1
		   (if (not (zerop delay)) delay)	;Arg 2
		   (cond ((zerop delay) "any") ((< delay 300) "much") (t nil))	;Arg 3
		   (if (eql n-servers 1) "it" "them")	;Arg 4
		   (let ((n (length (fs:all-open-files))))	;Arg 5
		     ;; Warn only if we're not already warning about something else.
		     (if (and (not n-servers) (> n 0)) n))
		   logout			;Arg 6
		   )))
    (when (and simulate query)
      (format t "~&The following query would appear:~
		      ~%  ~~A~~
		      ~%Only if you responded \"Yes\" would execution proceed ~
			beyond this point."
	      message))
    (when (or simulate (null query) (cl:yes-or-no-p "~A" message))
      (unless (server-shutdown :delay delay
			       :n-servers n-servers
			       :simulate simulate
			       :reason reason)
	(return-from halt-machine-internal))
      (cond (logout 
	     (if simulate
		 (format t "~&You would then be logged out.~%")
		 (let ((si:*confirm-logout-p* nil))
		   (cp:execute-command "Logout"))))
	    (t
	     (if simulate
		 (format t "~&Essential system shutdown operations would then be done.~%")
		 ;; The following is a subjectively chosen subset of
		 ;; LOGOUT-INITIALIZATION-LIST.  It's not really very modular, but does
		 ;; something useful.  Some day we should make a separate initialization
		 ;; list for ESSENTIAL-LOGOUT or BEFORE-NON-DISK-SAVING-COLD or some
		 ;; such.  There seems to be nothing which corresponds to that right now.
		 ;; -kmp 1-Oct-89
		 ;; -------
		 ;; 1. Logout all open connections.
		 (fs:file-login nil)
		 ;; 2. Shut down LMFS if appropriate.
		 (if (fboundp 'lmfs:shut) (funcall 'lmfs:shut))
		 ;; 3. Close and write back any Statice unique-ids.
		 (let ((uid-package (find-package "UID")))
		   (when uid-package
		     (let ((uid-shutdown (find-symbol "SHUTDOWN" uid-package)))
		       (when (and uid-shutdown
				  (fboundp uid-shutdown))
			 (funcall uid-shutdown))))))))
      (when final-message
	(if simulate
	    (format t "~&The following message would appear:~
		      ~%  ~~?~"
		    final-message nil)
	    (format t final-message)))
      (if simulate
	  (format t "~&Your machine would then halt~:[.~;~:*, and the FEP would execute:~
			    ~%  FEP Command: ~A~]"
		  fep-command-string)
	  (process-run-function "Halt Machine" #'perform-halt fep-command-string)
	  ))))

(defun server-shutdown (&key
			(delay 0)
			(n-servers (length net:*active-servers*))
			(simulate nil)
			(use-file-server-shutdown t)
			(reason nil))
  (declare (values success))
  (unless n-servers (setq n-servers 0))
  (setq use-file-server-shutdown
	(and use-file-server-shutdown (fboundp 'fs:file-server-shutdown)))
  (when simulate
    (cond ((= delay 0)
	   (when (> n-servers 0)
	     (format t "~&The ~D server~:P would be terminated without warning.~%"
		     n-servers)))
	  ((and use-file-server-shutdown (> n-servers 0))
	   (format t "~&Since there ~\\is-are\\ ~:*~D active server~:P, ~
		        and since you allowed a delay of ~\\time-interval\\,~
		      ~%the server~0@*~P would be notified about the shutdown ~
		        ~2@*~:[~;(with your stated reason) ~]while you waited."
		   n-servers delay reason))
	  (t
	   ;; Probably we should notify the other hosts in the interval while we wait,
	   ;; but I didn't have time to prototype that part, so decided to at least
	   ;; make the Simulate feature be honest about the fact that lossage will
	   ;; occur at the end of the delay period... -kmp 1-Oct-89
	   (format t "~&A delay of ~\\time-interval\\ would occur~:[~;, after which the ~
		        server connection~P~
		      ~%would be terminated without warning~].~%"
		   delay (> n-servers 0) n-servers)))
    (return-from server-shutdown t))
  (when (= delay 0) (return-from server-shutdown t))
  (cond (use-file-server-shutdown
	 ;; This can only be entered if shutdown stuff is present...
	 (funcall 'fs:file-server-shutdown (or reason "No reason given.") (/ delay 60))
	 (unwind-protect-case ()
	     (process-wait "Server Shutdown"
	       #'(lambda () (not (funcall 'fs:file-server-shutdown-state))))
	   (:abort
	     (funcall 'fs:file-server-cancel-shutdown)))
	 (when (multiple-value-bind (ignore time)
		   (funcall 'fs:file-server-shutdown-state)
		 ;; Actually, cancelling shutdown doesn't reset the time to 0,
		 ;; but I think that's a bug and I'm hoping it will get fixed,
		 ;; so I'll assume it might happen. -kmp 30-Sep-89
		 (or (zerop time) (< (get-universal-time) time)))
	   (format t "~&Not going to continue because someone seems to have cancelled ~
			shutdown from another process.~%")
	   (return-from server-shutdown nil)))
	(t
	 (scl:sleep delay :sleep-reason "Server Shutdown")))
  t) 

#-VLM
(progn

(defun find-fep-files-matching (&key host name type version)
  (let ((result '()))
    (dotimes (unit (world-tools:number-of-disk-units net:*local-host*))
      (let ((matches (condition-case ()
			  (let ((root-pathname
				  (make-pathname :host (format nil "~A|FEP~D"
							       (or host net:*local-host*)
							       unit)
						 :directory :root)))
			    (progn (open (send root-pathname :new-pathname
					       :name "ROOT-DIRECTORY"
					       :type "DIR")
					 :direction :probe)
				   (directory (send root-pathname :new-pathname
						    :name (or name :wild)
						    :type (or type :wild)
						    :version (or version :wild)))))
			((fs:unknown-pathname-host fs:no-file-system sys:disk-not-mounted-error
						   fs:qfile-system-bug)
			 nil))))
	(setq result (nconc result (copy-list* matches)))))
    result))

(defun parse-local-fep-namestring (string &optional defaults (error-p t))
  (flet ((fail () (error "~S is not a local FEP host." string)))
    (or (ignore-errors
	  (let ((host-pos (string-search-char #\: string)))
	    (let ((host (if host-pos (substring string 0 host-pos) "FEP"))
		  (name (if host-pos (substring string (1+ host-pos)) string)))
	      (unless (and (string-equal "FEP" host :end2 3)
			   (multiple-value-bind (ignore pos)
			       (parse-integer host :start 3 :junk-allowed t)
			     (= pos (string-length host))))
		(fail))
	      (let ((full-namestring (namestring (parse-namestring name host defaults))))
		(if host-pos
		    full-namestring
		    (setq host-pos (string-search-char #\: full-namestring))
		    (substring full-namestring (if host-pos (1+ host-pos) 0)))))))
	(when error-p (fail)))))

(defvar *boot-machine-logout-default* t
  "If NIL, the Boot Machine command will not try to run Logout before booting,
but will still do a few essential pre-boot actions to make the shutdown a clean one.
This is the sort of thing some people might set in their init if they didn't like
to wait around for Zwei, Zmail, etc. to check to see if buffers need to be saved.")

(cp:define-command (com-boot-machine :command-table "Session"
				     :provide-output-destination-keyword nil)
    ((name '((token-or-type (:default) string))
	   :default :default
	   :display-default nil
	   :prompt "boot file name"
	   :documentation "File to boot from.")
     &key
     (delay '((null-or-type time:time-interval))
	    :prompt "time"
	    :default (if net:*active-servers* 300. nil)		;5 mins if servers exist.
	    :documentation "How long to delay booting.")
     (logout 'boolean
	     :default *boot-machine-logout-default*
	     :mentioned-default t
	     :documentation "Log out before booting.")
     (reason '((null-or-type string))
	     :prompt "for booting"
	     :default NIL)
     (simulate 'boolean
	       :default nil
	       :mentioned-default t
	       :documentation
	       "Whether to just show the effect of this command without actually doing it."))
   "Boots the machine."
   (if (not delay) (setq delay 0))
   (if (or (string-equal name "") (eq name :default)) (setq name nil))
   (let ((boot-file nil))
     (fs:with-automatic-login-to-sys-host
       (cond ((and name (string-search-set ":>." name))
	      (setq boot-file (parse-local-fep-namestring name ".boot.newest" nil))
	      (unless (probe-file boot-file)
		(setq boot-file nil)))
	     (t
	      (let ((boot-files
		      (when name
			(mapcar #'(lambda (p) (namestring (send p :new-version nil)))
				(find-fep-files-matching :name name
							 :type "boot"
							 :version :newest)))))
		(setq boot-file
		      (if (< (length boot-files) 2)
			  (car boot-files)
			  (dw:menu-choose
			    (mapcar #'(lambda (file)
					(cons (format nil "Boot ~A" file) file)) boot-files)
			    :prompt (if simulate
					"You would be asked to please clarify your selection:"
					"Please clarify your selection:")))))))
       (when (and name (not boot-file))
	 (format t "~&~:[~;You would be told:~% ~]No such boot file name: ~A~%" simulate name)
	 (return-from com-boot-machine))
       (let ((fep-command-string (format nil ":Boot~@[ ~A~]~%" boot-file)))
	 (halt-machine-internal :logout logout
				:delay delay
				:reason reason
				:fep-command-string fep-command-string
				:description "reboot"
				:simulate simulate)))))


)
