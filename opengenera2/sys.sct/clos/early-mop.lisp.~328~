;;; -*- Mode: LISP; Syntax: ANSI-Common-Lisp; Base: 10; Package: CLOS-INTERNALS -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(IN-PACKAGE :CLOS-INTERNALS)

(DEFPARAMETER *BOOTSTRAP-CLASS-SLOTS* NIL)

(DEFMACRO DEF-BOOTSTRAP-CLASS ((NAME &KEY INCLUDE) &BODY SLOTS)
  `(MULTIPLE-VALUE-BIND (I REST)
       (IF ',INCLUDE
	   (LET ((OTHER (GETF *BOOTSTRAP-CLASS-SLOTS* ',INCLUDE)))
	     (VALUES (FIRST OTHER)
		     (SECOND OTHER)))
	   (VALUES (PROGN #+(OR Genera Minima) 1
			  #+CLOE-Runtime 0)
		   NIL))
     (SETF (GETF *BOOTSTRAP-CLASS-SLOTS* ',NAME)
	   (LET ((ALIST (MAPCAR #'(LAMBDA (SLOT)
				    (IF (SYMBOLP SLOT)
					`(,SLOT
					  ,(INTERN (STRING SLOT) (FIND-PACKAGE 'KEYWORD))
					  ,(PROG1 I
						  (INCF I)))
					`(,(FIRST SLOT)
					  ,(SECOND SLOT)
					  ,(PROG1 I
						  (INCF I)))))
				',(COPY-LIST SLOTS))))
	     (LIST I (APPEND REST ALIST) NIL)))))

(DEFUN INITIALIZE-BOOTSTRAP-INSTANCE-INFORMATION ()
  (LET ((LIST *BOOTSTRAP-CLASS-SLOTS*))
    (LOOP
      (WHEN (NULL LIST) (RETURN))
      (LET* ((NAME (POP LIST))
	     (INFO (POP LIST))
	     (INFORMATION (MAKE-CLASS-INSTANCE-INFORMATION)))
	(SETF (%INSTANCE-INFORMATION-SIZE INFORMATION) (FIRST INFO))
	(SETF (%CLASS-INSTANCE-INFORMATION-CLASS-NAME INFORMATION) NAME)
	(SETF (THIRD INFO) INFORMATION)))))

(DEFUN BOOTSTRAP-CLASS-INFO (CLASS-NAME)
  (GETF *BOOTSTRAP-CLASS-SLOTS* CLASS-NAME))

(DEFUN BOOTSTRAP-CLASS-SIZE (CLASS-NAME)
  (FIRST (BOOTSTRAP-CLASS-INFO CLASS-NAME)))

(DEFUN BOOTSTRAP-CLASS-INFORMATION (CLASS-NAME)
  (THIRD (BOOTSTRAP-CLASS-INFO CLASS-NAME)))

(DEFUN BOOTSTRAP-CLASS-SLOT-DESCRIPTIONS (CLASS-NAME)
  (SECOND (BOOTSTRAP-CLASS-INFO CLASS-NAME)))

(DEFUN BOOTSTRAP-CLASS-SLOT-DESCRIPTION (CLASS-NAME SLOT)
  (ASSOC SLOT (BOOTSTRAP-CLASS-SLOT-DESCRIPTIONS CLASS-NAME)))

(DEFMACRO BOOTSTRAP-SLOT-VALUE (INSTANCE CLASS SLOT)
  `(%INSTANCE-REF
     ,INSTANCE
     (THIRD (BOOTSTRAP-CLASS-SLOT-DESCRIPTION ,CLASS ,SLOT))))

(DEFUN BOOTSTRAP-INITIALIZE-INSTANCE (INSTANCE CLASS)
  (MACROLET ((LOCATOR (&REST IGNORE) 'LOCATION))
    (LOOP FOR (SLOT-NAME NIL LOCATION) IN (BOOTSTRAP-CLASS-SLOT-DESCRIPTIONS CLASS) DOING
      (MAKUNBOUND-SLOT CLASS INSTANCE SLOT-NAME %INSTANCE-REF LOCATOR))))

(DEFMACRO BOOTSTRAP-FSLOT-VALUE (INSTANCE SLOT)
  `(%FUNCALLABLE-INSTANCE-REF
     ,INSTANCE
     (THIRD (BOOTSTRAP-CLASS-SLOT-DESCRIPTION 'STANDARD-GENERIC-FUNCTION ,SLOT))))

(DEFUN BOOTSTRAP-INITIALIZE-FUNCALLABLE-INSTANCE (INSTANCE CLASS)
  (MACROLET ((LOCATOR (&REST IGNORE) 'LOCATION))
    (LOOP FOR (SLOT-NAME NIL LOCATION) IN (BOOTSTRAP-CLASS-SLOT-DESCRIPTIONS CLASS) DOING
      (MAKUNBOUND-SLOT CLASS INSTANCE SLOT-NAME %FUNCALLABLE-INSTANCE-REF LOCATOR))))

(DEF-BOOTSTRAP-CLASS (STANDARD-GENERIC-FUNCTION)
  #+(OR Genera Minima)
  FUNCALLABLE-INSTANCE
  NAME
  LAMBDA-LIST
  DEBUGGING-INFO
  METHOD-COMBINATION
  FLAGS
  METHODS
  #+Genera
  SELECTOR
  TABLE
  PRECEDENCE-ORDER
  INITIAL-METHODS
  METHOD-CLASS
  MAPPING-TABLE-FAMILIES
  #+GENERA #:FILL)

(DEF-BOOTSTRAP-CLASS (STANDARD-METHOD)
  CELL
  GENERIC-FUNCTION
  LAMBDA-LIST
  #+Genera
  FUNCTION-PARENT
  SPECIALIZERS
  QUALIFIERS
  DOCUMENTATION
  NO-NEXT-METHOD-INFORMATION
  MAPPING-TABLE-FAMILY
  #+Genera
  MAPPING-TABLE-ARGUMENTS
  MAPPED-ARGUMENTS-BITMAP)

(DEF-BOOTSTRAP-CLASS (STANDARD-ACCESSOR-METHOD :INCLUDE STANDARD-METHOD)
  SLOT-NAME)

(DEF-BOOTSTRAP-CLASS (STANDARD-READER-METHOD :INCLUDE STANDARD-ACCESSOR-METHOD)
  )

(DEF-BOOTSTRAP-CLASS (STANDARD-WRITER-METHOD :INCLUDE STANDARD-ACCESSOR-METHOD)
  )

#+(OR Genera Minima)
(DEF-BOOTSTRAP-CLASS (STANDARD-LOCATOR-METHOD :INCLUDE STANDARD-ACCESSOR-METHOD)
  )

(DEF-BOOTSTRAP-CLASS (SLOT-DEFINITION)
  NAME
  INITFORM
  INITFUNCTION
  INITFORM-INLINABLE
  TYPE
  ALLOCATION
  INITARGS
  DOCUMENTATION)

(DEF-BOOTSTRAP-CLASS (DIRECT-SLOT-DEFINITION :INCLUDE SLOT-DEFINITION)
  READERS
  WRITERS
  #+(OR Genera Minima)
  LOCATORS
  METHODS)

(DEF-BOOTSTRAP-CLASS (STANDARD-DIRECT-SLOT-DEFINITION :INCLUDE DIRECT-SLOT-DEFINITION))

(DEF-BOOTSTRAP-CLASS (EFFECTIVE-SLOT-DEFINITION :INCLUDE SLOT-DEFINITION)
  LOCATION)

(DEF-BOOTSTRAP-CLASS (STANDARD-EFFECTIVE-SLOT-DEFINITION :INCLUDE EFFECTIVE-SLOT-DEFINITION))

(DEF-BOOTSTRAP-CLASS (CLOS-CLASS)
  CONSTRUCTORS
  INSTANCE-INFORMATION
  NAME
  DIRECT-SUPERCLASSES
  DIRECT-SUBCLASSES
  PROTOTYPE
  DOCUMENTATION)

(DEF-BOOTSTRAP-CLASS (FORWARD-REFERENCED-CLASS :INCLUDE CLOS-CLASS)
  )

(DEF-BOOTSTRAP-CLASS (BUILT-IN-CLASS :INCLUDE CLOS-CLASS)
  )

(DEF-BOOTSTRAP-CLASS (METHOD-ONLY-CLASS :INCLUDE CLOS-CLASS)
  )

(DEF-BOOTSTRAP-CLASS (STRUCTURE-CLASS :INCLUDE CLOS-CLASS)
  STANDARD-CONSTRUCTOR
  #+(OR Genera Minima)
  FUNCTIONS
  PRINT-FUNCTION
  )

(DEF-BOOTSTRAP-CLASS (STANDARD-CLASS :INCLUDE CLOS-CLASS)
  MAPPING-TABLES
  DIRECT-DEFAULT-INITARGS
  DEFAULT-INITARGS
  BITS
  DIRECT-SLOTS
  SHARED-SLOTS
  MAKE-INSTANCE-KEYWORDS
  KEYWORD-CONSTRUCTOR)

(DEF-BOOTSTRAP-CLASS (FUNCALLABLE-STANDARD-CLASS :INCLUDE STANDARD-CLASS)
  )

(DEF-BOOTSTRAP-CLASS (METHOD-COMBINATION-DEFINITION)
  NAME
  DOCUMENTATION)

(DEF-BOOTSTRAP-CLASS (SHORT-FORM-METHOD-COMBINATION-DEFINITION
		       :INCLUDE METHOD-COMBINATION-DEFINITION)
  OPERATOR
  IDENTITY-WITH-ONE-ARGUMENT)

(DEF-BOOTSTRAP-CLASS (LONG-FORM-METHOD-COMBINATION-DEFINITION
		       :INCLUDE METHOD-COMBINATION-DEFINITION)
  METHOD-GROUPS
  FUNCTION
  ARGUMENTS-LAMBDA-LIST)

(DEF-BOOTSTRAP-CLASS (STANDARD-METHOD-COMBINATION)
  TYPE
  OPTIONS)

(DEF-BOOTSTRAP-CLASS (MISCELLANEOUS-FUNCTION)
  CELL
  PLIST
  LAMBDA-EXPRESSION
  NAME)

(DEFMACRO DEFUN-BOOTSTRAP-GENERIC (FUNCTION-NAME LAMBDA-LIST &BODY BODY)
  `(DEFUN ,FUNCTION-NAME (.EXTRA-ARG. ,@LAMBDA-LIST)
     (DECLARE (IGNORE .EXTRA-ARG.))
     #+Genera
     (DECLARE (SYS:FUNCTION-PARENT ,FUNCTION-NAME DEFUN-BOOTSTRAP-GENERIC))
     ,@BODY))

(DEFMACRO BOOTSTRAP-GENERIC-LAMBDA (LAMBDA-LIST &BODY BODY &ENVIRONMENT ENVIRONMENT)
  (MULTIPLE-VALUE-BIND (REAL-BODY DECLARATIONS DOCUMENTATION)
      (PARSE-TOPLEVEL-BODY BODY ENVIRONMENT LAMBDA-LIST)
    `(FUNCTION (LAMBDA (.EXTRA-ARGUMENT. ,@LAMBDA-LIST)
		 ,@(WHEN DOCUMENTATION `(,DOCUMENTATION))
		 ,@(WHEN DECLARATIONS `((DECLARE ,@DECLARATIONS)))
		 .EXTRA-ARGUMENT.
		 ,@REAL-BODY))))

(DEFMACRO DEFUN-BOOTSTRAP-METHOD
	  (FUNCTION-NAME LAMBDA-LIST &BODY BODY &ENVIRONMENT ENVIRONMENT)
  (MULTIPLE-VALUE-BIND (EXPANSION OTHER-STUFF)
      (MAKE-STANDARD-METHOD-LAMBDA `(LAMBDA ,LAMBDA-LIST ,@BODY) ENVIRONMENT)
    (UNLESS (GETF OTHER-STUFF 'NO-NEXT-METHOD-INFORMATION)
      (WARN "~s needs next method information" FUNCTION-NAME))
    `(DEFUN ,FUNCTION-NAME ,(SECOND EXPANSION) ,@(CDDR EXPANSION))))

(DEFMACRO BOOTSTRAP-METHOD-LAMBDA (LAMBDA-LIST &BODY BODY &ENVIRONMENT ENVIRONMENT)
  (MULTIPLE-VALUE-BIND (EXPANSION OTHER-STUFF)
      (MAKE-STANDARD-METHOD-LAMBDA `(LAMBDA ,LAMBDA-LIST ,@BODY) ENVIRONMENT)
    (UNLESS (GETF OTHER-STUFF 'NO-NEXT-METHOD-INFORMATION)
      (WARN "~s needs next method information" BODY))
    `(FUNCTION ,EXPANSION)))

(DEFVAR *BOOTSTRAP-CLASSES* NIL)		;A list of all the class objects
(DEFVAR *BOOTSTRAP-GENERICS* NIL)		;A list of all the generic functions

(DEFUN BOOTSTRAP-MAKE-GENERIC-FUNCTION (&OPTIONAL ENVIRONMENT)
  (LET ((INSTANCE (%ALLOCATE-FUNCALLABLE-INSTANCE
		    (BOOTSTRAP-CLASS-INFORMATION 'STANDARD-GENERIC-FUNCTION)
		    #+(OR CLOE-Runtime Genera) 
		    (IF (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
			(PROGN #+Genera SYS:*DEFAULT-CONS-AREA*
			       #+CLOE-Runtime SYS::AKIND$K-DEFAULT)
			*CLOS-STATIC-AREA*))))
    (BOOTSTRAP-INITIALIZE-FUNCALLABLE-INSTANCE INSTANCE 'STANDARD-GENERIC-FUNCTION)
    (SETF (BOOTSTRAP-FSLOT-VALUE INSTANCE 'TABLE) NIL)
    #+(OR Genera Minima)
    (SETF (BOOTSTRAP-FSLOT-VALUE INSTANCE 'FUNCALLABLE-INSTANCE) INSTANCE)
    (PUSH INSTANCE *BOOTSTRAP-GENERICS*)
    (UNLESS (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
      (NOTICE-GENERIC-FUNCTION INSTANCE)
      )
    INSTANCE))

(DEFUN BOOTSTRAP-INITIALIZE-GENERIC-FUNCTION
       (INSTANCE FUNCTION-NAME
	&KEY
	ARGUMENT-PRECEDENCE-ORDER
	(LAMBDA-LIST NIL LAMBDA-LIST-P)
	(METHOD-COMBINATION '(STANDARD))
	((INITIAL-METHODS INITIAL-METHODS))
	(METHOD-CLASS (OR (FIND-CLASS 'STANDARD-METHOD NIL)
			  'STANDARD-METHOD))
	#+Genera
	((SELECTOR SELECTOR))
	&ALLOW-OTHER-KEYS)
  #+Genera
  (LET ((SYMBOL (IF (SYMBOLP FUNCTION-NAME) FUNCTION-NAME (SECOND FUNCTION-NAME))))
    (SI:AARRAY-INSERT *ALL-GENERIC-FUNCTION-NAMES-AARRAY*
		      (SYMBOL-NAME SYMBOL) SYMBOL 'ATOM))
  (LET ((ORDER (CHECK-ARGUMENT-PRECEDENCE-ORDER
		 #'CLOS-ERROR ARGUMENT-PRECEDENCE-ORDER LAMBDA-LIST)))
    (SETF (BOOTSTRAP-FSLOT-VALUE INSTANCE 'NAME) FUNCTION-NAME)
    (SETF (BOOTSTRAP-FSLOT-VALUE INSTANCE 'LAMBDA-LIST) LAMBDA-LIST)
    (SETF (BOOTSTRAP-FSLOT-VALUE INSTANCE 'DEBUGGING-INFO) NIL)
    (SETF (BOOTSTRAP-FSLOT-VALUE INSTANCE 'METHOD-COMBINATION)
	  (IF (AND *METHOD-COMBINATION-DEFINITIONS*
		   (CONSP METHOD-COMBINATION))		  
	      (FIND-METHOD-COMBINATION
		INSTANCE (CAR METHOD-COMBINATION) (CDR METHOD-COMBINATION))
	      ;; This needs to be fixed up
	      METHOD-COMBINATION))
    (SETF (BOOTSTRAP-FSLOT-VALUE INSTANCE 'FLAGS)
	  (DPB 1 (BYTE 1 11.)
	       (DPB (IF LAMBDA-LIST-P 1 0) %%GENERIC-FUNCTION-EXPLICITLY-DEFINED-P
		    (DPB 1 %%GENERIC-FUNCTION-INITIALIZED-P 0))))
    (SETF (BOOTSTRAP-FSLOT-VALUE INSTANCE 'METHODS) NIL)
    #+Genera
    (WHEN SELECTOR
      (SETF (GET SELECTOR 'SELECTOR-GENERIC-FUNCTION) INSTANCE)
      (PUSHNEW INSTANCE *ALL-GENERIC-FUNCTIONS-WITH-SELECTORS*))
    #+Genera
    (SETF (BOOTSTRAP-FSLOT-VALUE INSTANCE 'SELECTOR) SELECTOR)
    (SETF (BOOTSTRAP-FSLOT-VALUE INSTANCE 'PRECEDENCE-ORDER) ORDER)
    (SETF (BOOTSTRAP-FSLOT-VALUE INSTANCE 'INITIAL-METHODS) INITIAL-METHODS)
    (SETF (BOOTSTRAP-FSLOT-VALUE INSTANCE 'METHOD-CLASS) METHOD-CLASS)
    (SETF (BOOTSTRAP-FSLOT-VALUE INSTANCE 'MAPPING-TABLE-FAMILIES) NIL)
    INSTANCE))

(DEFUN-BOOTSTRAP-GENERIC BOOTSTRAP-LAMBDA-LIST-CONGRUENT-P
			 (GENERIC LAMBDA-LIST
				  &OPTIONAL
				  (GENERIC-LAMBDA-LIST
				    (BOOTSTRAP-FSLOT-VALUE GENERIC 'LAMBDA-LIST)))
  (CLOS-LAMBDA-LISTS-CONGRUENT-P
    GENERIC-LAMBDA-LIST
    LAMBDA-LIST))

(DEFUN-BOOTSTRAP-GENERIC BOOTSTRAP-ENSURE-GENERIC-FUNCTION-USING-CLASS
			 (GENERIC FUNCTION-NAME
				  &REST KEYS
				  &KEY
				  ENVIRONMENT
				  (LAMBDA-LIST NIL LAMBDA-LIST-P)
				  &ALLOW-OTHER-KEYS)
  (DECLARE (DYNAMIC-EXTENT KEYS))
  LAMBDA-LIST
  (COND (GENERIC
	 #+Genera
	 (UNLESS
	   (OR (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
	       (NOT LAMBDA-LIST-P))
	   ;; If LAMBDA-LIST-P is provided, this form came from a
	   ;; DEFGENERIC, so record a source file name.  Otherwise, the
	   ;; generic function is being defined by something like DEFMETHOD,
	   ;; and no source file should be recorded.
	   (SI:RECORD-SOURCE-FILE-NAME FUNCTION-NAME))
	 (WHEN LAMBDA-LIST-P
	   (APPLY #'BOOTSTRAP-INITIALIZE-GENERIC-FUNCTION
		  GENERIC
		  FUNCTION-NAME
		  KEYS))
	 GENERIC)
	(T (LET ((GENERIC
		   (APPLY #'BOOTSTRAP-INITIALIZE-GENERIC-FUNCTION
			  (BOOTSTRAP-MAKE-GENERIC-FUNCTION ENVIRONMENT)
			  FUNCTION-NAME
			  KEYS)))
	     (SETF (FDEFINITION-IN-ENVIRONMENT FUNCTION-NAME ENVIRONMENT) GENERIC)
	     GENERIC))))

(DEFUN-BOOTSTRAP-GENERIC BOOTSTRAP-ENSURE-CLASS-USING-CLASS
			 (CLASS NAME
				&KEY
				(METACLASS 'STANDARD-CLASS)
				SLOTS
				DIRECT-SUPERCLASSES
				DEFAULT-INITARGS
				DOCUMENTATION
				ENVIRONMENT
				&ALLOW-OTHER-KEYS)
  (WITH-PENDING-DW-UPDATES
    (WHEN (PROGN
	    #-Genera T
	    #+Genera
	    (OR (NULL NAME)
		(COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
		(OR (EQ METACLASS 'FORWARD-REFERENCED-CLASS)
		    (EQ METACLASS (FIND-CLASS 'FORWARD-REFERENCED-CLASS NIL)))
		(AND (SYS:RECORD-DEFINITION-SOURCE-FILE
		       NAME 'DEFCLASS :START-TYPE-DEFINITION NIL)
		     (SYS:RECORD-DEFINITION-SOURCE-FILE
		       NAME 'CLI::DEFTYPE :START-TYPE-DEFINITION NIL))))
      (LET* ((INFORMATION
	       (OR (BOOTSTRAP-CLASS-INFORMATION NAME)
		   (MAKE-CLASS-INSTANCE-INFORMATION)))
	     (METACLASS-INFORMATION
	       (BOOTSTRAP-CLASS-INFORMATION METACLASS))
	     (INSTANCE NIL))
	(COND (CLASS
	       (SETQ INSTANCE CLASS)
	       (LET ((OLD-METACLASS-INFORMATION (%INSTANCE-INFORMATION CLASS)))
		 (UNLESS (EQ OLD-METACLASS-INFORMATION METACLASS-INFORMATION)
		   (LET ((NEW-INSTANCE (%ALLOCATE-INSTANCE METACLASS-INFORMATION))
			 (OLD-METACLASS (%CLASS-INSTANCE-INFORMATION-CLASS-NAME
					  OLD-METACLASS-INFORMATION)))
		     (UNLESS (EQ OLD-METACLASS 'FORWARD-REFERENCED-CLASS)
		       (ERROR "Bootstrapping can't handle this case"))
		     (BOOTSTRAP-INITIALIZE-INSTANCE NEW-INSTANCE METACLASS)
		     (LET ((OLD-SUPERCLASSES
			     (BOOTSTRAP-SLOT-VALUE
			       CLASS OLD-METACLASS 'DIRECT-SUPERCLASSES)))
		       ;;The following has a presumption of metaclass of the class, obviously.
		       ;;The non-genera version moreso than the genera one, but both do.
		       #+Genera
		       (SYS:STRUCTURE-FORWARD CLASS NEW-INSTANCE)
		       #+Minima
		       (IVORY:%MEMORY-WRITE CLASS (IVORY:%SET-TAG NEW-INSTANCE (IVORY:DATA-TYPE 'IVORY::HEADER-FORWARD)))
		       #-(OR Genera Minima)
		       (INSTANCE-FORWARD CLASS NEW-INSTANCE)		       
		       (SETF (BOOTSTRAP-SLOT-VALUE CLASS METACLASS 'DIRECT-SUPERCLASSES)
			     OLD-SUPERCLASSES))))))
	      (T
	       (SETQ INSTANCE (%ALLOCATE-INSTANCE METACLASS-INFORMATION))
	       (BOOTSTRAP-INITIALIZE-INSTANCE INSTANCE METACLASS)))
	;; The class definitions are ordered so that each class definition follows those
	;; classes upon which it depends.
	(SETF (BOOTSTRAP-SLOT-VALUE INSTANCE METACLASS 'DIRECT-SUBCLASSES) NIL)
	(SETF (BOOTSTRAP-SLOT-VALUE INSTANCE METACLASS 'DIRECT-SUPERCLASSES)
	      (MAPCAR #'(LAMBDA (SUPERCLASS-NAME)
			  (LET ((SUPERCLASS (FIND-CLASS-OR-FORWARD-REFERENCE
					      SUPERCLASS-NAME ENVIRONMENT NIL)))
			    (UNLESS (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
			      (PUSHNEW INSTANCE
				       (BOOTSTRAP-SLOT-VALUE
					 SUPERCLASS  'CLOS-CLASS 'DIRECT-SUBCLASSES)))
			    SUPERCLASS))
		      DIRECT-SUPERCLASSES))
	(SETF (BOOTSTRAP-SLOT-VALUE INSTANCE METACLASS 'DOCUMENTATION) DOCUMENTATION)
	(SETF (BOOTSTRAP-SLOT-VALUE INSTANCE METACLASS 'NAME) NAME)
	(SETF (BOOTSTRAP-SLOT-VALUE INSTANCE METACLASS 'INSTANCE-INFORMATION) INFORMATION)
	(SETF (BOOTSTRAP-SLOT-VALUE INSTANCE METACLASS 'CONSTRUCTORS) NIL)
	(UNLESS (MEMBER METACLASS '(BUILT-IN-CLASS STRUCTURE-CLASS FORWARD-REFERENCED-CLASS
						   METHOD-ONLY-CLASS))
	  (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE METACLASS 'SHARED-SLOTS) NIL)
	  (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE METACLASS 'MAKE-INSTANCE-KEYWORDS) NIL)
	  (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE METACLASS 'BITS)
		(DPB 1 %%STANDARD-CLASS-INITIALIZED-P 0))
	  (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE METACLASS 'MAPPING-TABLES) NIL)
	  (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE METACLASS 'DIRECT-SLOTS)
		(MAPCAR #'(LAMBDA (SLOT-DESCRIPTOR)
			    (LET* ((SLOT (APPLY #'BOOTSTRAP-MAKE-DIRECT-SLOT SLOT-DESCRIPTOR))
				   (SLOT-NAME (BOOTSTRAP-SLOT-VALUE
						SLOT 'SLOT-DEFINITION 'NAME))
				   (METHODS NIL))
			      (UNLESS (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
				(MAPC #'(LAMBDA (FUNCTION-NAME)
					  (LET* ((LAMBDA-LIST `(,NAME))
						 (GENERIC (ENSURE-GENERIC-FUNCTION
							    FUNCTION-NAME
							    :ENVIRONMENT ENVIRONMENT))
						 (METHOD
						   (BOOTSTRAP-MAKE-ACCESSOR-METHOD
						     'STANDARD-READER-METHOD
						     :LAMBDA-LIST LAMBDA-LIST
						     :GENERIC-FUNCTION GENERIC
						     :SPECIALIZERS `(,INSTANCE)
						     :SLOT-NAME SLOT-NAME)))
					    (PUSH METHOD METHODS)
					    (BOOTSTRAP-ADD-METHOD GENERIC METHOD)))
				      (GETF SLOT-DESCRIPTOR :READERS))
				#+(OR Genera Minima)
				(MAPC #'(LAMBDA (FUNCTION-NAME)
					  (LET* ((LAMBDA-LIST `(,NAME))
						 (GENERIC (ENSURE-GENERIC-FUNCTION
							    FUNCTION-NAME
							    :ENVIRONMENT ENVIRONMENT))
						 (METHOD
						   (BOOTSTRAP-MAKE-ACCESSOR-METHOD
						     'STANDARD-LOCATOR-METHOD
						     :LAMBDA-LIST LAMBDA-LIST
						     :GENERIC-FUNCTION GENERIC
						     :SPECIALIZERS `(,INSTANCE)
						     :SLOT-NAME SLOT-NAME)))
					    (PUSH METHOD METHODS)
					    (BOOTSTRAP-ADD-METHOD GENERIC METHOD)))
				      (GETF SLOT-DESCRIPTOR :LOCATORS))
				(MAPC #'(LAMBDA (FUNCTION-NAME)
					  (LET* ((LAMBDA-LIST `(NEW-VALUE ,NAME))
						 (GENERIC (ENSURE-GENERIC-FUNCTION
							    FUNCTION-NAME
							    :ENVIRONMENT ENVIRONMENT))
						 (METHOD
						   (BOOTSTRAP-MAKE-ACCESSOR-METHOD
						     'STANDARD-WRITER-METHOD
						     :LAMBDA-LIST LAMBDA-LIST
						     :GENERIC-FUNCTION GENERIC
						     :SPECIALIZERS `(,(FIND-CLASS T) ,INSTANCE)
						     :SLOT-NAME SLOT-NAME)))
					    (PUSH METHOD METHODS)
					    (BOOTSTRAP-ADD-METHOD GENERIC METHOD)))
				      (GETF SLOT-DESCRIPTOR :WRITERS))
				(SETF (BOOTSTRAP-SLOT-VALUE
					SLOT 'DIRECT-SLOT-DEFINITION 'METHODS)
				      METHODS))
			      SLOT))
			SLOTS))
	  (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE METACLASS 'DIRECT-DEFAULT-INITARGS)
		DEFAULT-INITARGS))
	(SETF (%CLASS-INSTANCE-INFORMATION-CLASS-NAME INFORMATION) NAME)
	(SETF (%CLASS-INSTANCE-INFORMATION-CLASS INFORMATION) INSTANCE)
	(SETF (FIND-CLASS NAME NIL ENVIRONMENT) INSTANCE)
	(UNLESS (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
	  (PUSHNEW INSTANCE *BOOTSTRAP-CLASSES*))
	INSTANCE))))

(DEFUN BOOTSTRAP-MAKE-DIRECT-SLOT (&KEY
				   NAME
				   INITFORM
				   INITFUNCTION
				   ((INITFORM-INLINABLE INITFORM-INLINABLE) NIL)
				   (TYPE T)
				   (ALLOCATION :INSTANCE)
				   DOCUMENTATION
				   INITARGS
				   READERS
				   WRITERS
				   #+(OR Genera Minima) LOCATORS)
  (LET* ((CLASS 'STANDARD-DIRECT-SLOT-DEFINITION)
	 (INSTANCE (%ALLOCATE-INSTANCE (BOOTSTRAP-CLASS-INFORMATION CLASS))))
    (BOOTSTRAP-INITIALIZE-INSTANCE INSTANCE CLASS)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'NAME) NAME)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'INITFORM) INITFORM)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'INITFUNCTION) INITFUNCTION)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'INITFORM-INLINABLE) INITFORM-INLINABLE)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'TYPE) TYPE)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'ALLOCATION) ALLOCATION)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'INITARGS) INITARGS)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'DOCUMENTATION) DOCUMENTATION)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'READERS) READERS)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'WRITERS) WRITERS)
    #+(OR Genera Minima)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'LOCATORS) LOCATORS)
    INSTANCE))

(DEFUN BOOTSTRAP-MAKE-EFFECTIVE-SLOT (&KEY
				      NAME
				      INITFORM
				      INITFUNCTION
				      ((INITFORM-INLINABLE INITFORM-INLINABLE) NIL)
				      (TYPE T)
				      (ALLOCATION :INSTANCE)
				      DOCUMENTATION
				      INITARGS
				      LOCATION)
  (LET* ((CLASS 'STANDARD-EFFECTIVE-SLOT-DEFINITION)
	 (INSTANCE (%ALLOCATE-INSTANCE (BOOTSTRAP-CLASS-INFORMATION CLASS))))
    (BOOTSTRAP-INITIALIZE-INSTANCE INSTANCE CLASS)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'NAME) NAME)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'INITFORM) INITFORM)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'INITFUNCTION) INITFUNCTION)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'INITFORM-INLINABLE) INITFORM-INLINABLE)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'TYPE) TYPE)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'ALLOCATION) ALLOCATION)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'INITARGS) INITARGS)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'DOCUMENTATION) DOCUMENTATION)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'LOCATION) LOCATION)
    INSTANCE))

(DEFUN BOOTSTRAP-MAKE-METHOD
       (CLASS
	&KEY
	GENERIC-FUNCTION
	LAMBDA-LIST
	SPECIALIZERS
	FUNCTION
	QUALIFIERS
	DOCUMENTATION
	((NO-NEXT-METHOD-INFORMATION NO-NEXT-METHOD-INFORMATION))
	((METHOD-MAPPING-TABLE-FAMILY METHOD-MAPPING-TABLE-FAMILY))
	((METHOD-MAPPED-ARGUMENTS-BITMAP METHOD-MAPPED-ARGUMENTS-BITMAP) 0)
	#+Genera
	((METHOD-MAPPING-TABLE-ARGUMENTS METHOD-MAPPING-TABLE-ARGUMENTS)
	 NIL))
  (LET* ((INFORMATION (BOOTSTRAP-CLASS-INFORMATION CLASS))
	 (INSTANCE (%ALLOCATE-INSTANCE INFORMATION)))
    (BOOTSTRAP-INITIALIZE-INSTANCE INSTANCE CLASS)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'GENERIC-FUNCTION) GENERIC-FUNCTION)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'LAMBDA-LIST) LAMBDA-LIST)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'SPECIALIZERS) SPECIALIZERS)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'QUALIFIERS) QUALIFIERS)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'DOCUMENTATION) DOCUMENTATION)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'NO-NEXT-METHOD-INFORMATION)
	  NO-NEXT-METHOD-INFORMATION)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'MAPPING-TABLE-FAMILY)
	  METHOD-MAPPING-TABLE-FAMILY)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'MAPPED-ARGUMENTS-BITMAP)
	  METHOD-MAPPED-ARGUMENTS-BITMAP)
    #+Genera
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'MAPPING-TABLE-ARGUMENTS)
	  METHOD-MAPPING-TABLE-ARGUMENTS)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE 'STANDARD-METHOD 'CELL) FUNCTION)
    (WHEN FUNCTION
      ;; This gets rather revolting
      ;; We compile the method function with the "METHOD" name so that it will be
      ;; meaningful to the observer.  We we go to make the method, we save the
      ;; function name in a slot of the method and bash the original function name.
      ;; All the internal function specs share structure with the top level function
      ;; spec, so this takes care of everything at once.
      #+Genera
      (LET ((REAL-FUNCTION (FUNCTION-REAL-FUNCTION FUNCTION)))
	(TYPECASE REAL-FUNCTION
	  (SYS:COMPILED-FUNCTION
	    ;; Get some information out of the debugging information
	    (LET* ((CCA (SYS:COMPILED-FUNCTION-CCA REAL-FUNCTION))
		   (DEBUG-INFO (SYS:CCA-EXTRA-INFO CCA))
		   (NAME (POP DEBUG-INFO)))
	      (COND ((INSTANCEP NAME)
		     ;; This function is shared by several methods.
		     (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE 'STANDARD-METHOD 'FUNCTION-PARENT)
			   (BOOTSTRAP-SLOT-VALUE NAME 'STANDARD-METHOD 'FUNCTION-PARENT))
		     (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE 'STANDARD-METHOD 'MAPPING-TABLE-FAMILY)
			   (BOOTSTRAP-SLOT-VALUE NAME 'STANDARD-METHOD 'MAPPING-TABLE-FAMILY))
		     (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE 'STANDARD-METHOD 'MAPPING-TABLE-ARGUMENTS)
			   (BOOTSTRAP-SLOT-VALUE NAME 'STANDARD-METHOD 'MAPPING-TABLE-ARGUMENTS))
		     (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE 'STANDARD-METHOD 'MAPPED-ARGUMENTS-BITMAP)
			   (BOOTSTRAP-SLOT-VALUE NAME 'STANDARD-METHOD 'MAPPED-ARGUMENTS-BITMAP)))
		    (T
		     (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE 'STANDARD-METHOD 'FUNCTION-PARENT)
			   (AND (SYS:VALIDATE-FUNCTION-SPEC NAME) (COPY-TREE NAME)))
		     (DOLIST (ENTRY DEBUG-INFO)
		       (WHEN (CONSP ENTRY)
			 (CASE (FIRST ENTRY)
			   (MAPPING-TABLE-FAMILY
			     (LET ((INFO (SECOND ENTRY)))
			       (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE 'STANDARD-METHOD 'MAPPING-TABLE-FAMILY) (CAR INFO))
			       (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE 'STANDARD-METHOD 'MAPPING-TABLE-ARGUMENTS) (CDR INFO))))
			   (MAPPED-ARGUMENTS
			     (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE 'STANDARD-METHOD 'MAPPED-ARGUMENTS-BITMAP) (SECOND ENTRY))))))
		     (SETF (SYS:FUNCTION-NAME REAL-FUNCTION) INSTANCE)))))
	  (FUNCTION
	    (LET ((NAME (SYS:FUNCTION-NAME REAL-FUNCTION)))
	      (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE 'STANDARD-METHOD 'FUNCTION-PARENT)
		    (AND (SYS:VALIDATE-FUNCTION-SPEC NAME) (COPY-TREE NAME)))))))
      #+Minima
      (LET ((REAL-FUNCTION (FUNCTION-REAL-FUNCTION FUNCTION)))
	(WHEN (TYPEP REAL-FUNCTION 'IVORY::COMPILED-CODE)
	  ;; Get some information out of the debugging information
	  (LET* ((EXTRA-INFO (IVORY::COMPILED-FUNCTION-EXTRA-INFO REAL-FUNCTION))
		 (NAME (CAR EXTRA-INFO)))
	    (COND ((INSTANCEP NAME)
		   ;; This function is shared by several methods.
		   (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE 'STANDARD-METHOD 'MAPPING-TABLE-FAMILY)
			 (BOOTSTRAP-SLOT-VALUE NAME 'STANDARD-METHOD 'MAPPING-TABLE-FAMILY))
		   (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE 'STANDARD-METHOD 'MAPPED-ARGUMENTS-BITMAP)
			 (BOOTSTRAP-SLOT-VALUE NAME 'STANDARD-METHOD 'MAPPED-ARGUMENTS-BITMAP)))
		  (T
		   (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE 'STANDARD-METHOD 'MAPPING-TABLE-FAMILY)
			 (GETF (CDR EXTRA-INFO) 'MAPPING-TABLE-FAMILY))
		   (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE 'STANDARD-METHOD 'MAPPED-ARGUMENTS-BITMAP)
			 (GETF (CDR EXTRA-INFO) 'MAPPED-ARGUMENTS-BITMAP 0))
		   (SETF (CAR EXTRA-INFO) INSTANCE))))))
      #+CLOE-Runtime
      (SETF (SYS:FUNCTION-NAME FUNCTION) INSTANCE))
    INSTANCE))

(DEFUN BOOTSTRAP-MAKE-ACCESSOR-METHOD (CLASS &REST KEYS &KEY SLOT-NAME &ALLOW-OTHER-KEYS)
  (DECLARE (DYNAMIC-EXTENT KEYS))
  (LET ((INSTANCE (APPLY #'BOOTSTRAP-MAKE-METHOD CLASS (REMOVE-KEYWORDS KEYS :SLOT-NAME))))
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'SLOT-NAME) SLOT-NAME)
    INSTANCE))

(DEFUN BOOTSTRAP-ADD-METHOD (GENERIC-FUNCTION METHOD)
  (SETF (BOOTSTRAP-SLOT-VALUE METHOD 'STANDARD-METHOD 'GENERIC-FUNCTION) GENERIC-FUNCTION)
  (PUSH METHOD (BOOTSTRAP-FSLOT-VALUE GENERIC-FUNCTION 'METHODS))
  (WHEN (AND (NULL (BOOTSTRAP-FSLOT-VALUE GENERIC-FUNCTION 'LAMBDA-LIST))
	     (NULL (LDB-TEST %%GENERIC-FUNCTION-EXPLICITLY-DEFINED-P
			     (BOOTSTRAP-FSLOT-VALUE GENERIC-FUNCTION 'FLAGS))))
    (WARN "Missing DEFGENERIC for ~s"
	  (BOOTSTRAP-FSLOT-VALUE GENERIC-FUNCTION 'NAME))
    (LET ((LAMBDA-LIST (COMPUTE-GENERIC-FUNCTION-LAMBDA-LIST
			 (BOOTSTRAP-SLOT-VALUE METHOD 'STANDARD-METHOD 'LAMBDA-LIST))))
      (SETF (BOOTSTRAP-FSLOT-VALUE GENERIC-FUNCTION 'LAMBDA-LIST) LAMBDA-LIST)
      (SETF (BOOTSTRAP-FSLOT-VALUE GENERIC-FUNCTION 'PRECEDENCE-ORDER)
	    (CHECK-ARGUMENT-PRECEDENCE-ORDER #'CLOS-ERROR NIL LAMBDA-LIST))))
  (DOLIST (SPECIALIZER (BOOTSTRAP-SLOT-VALUE METHOD 'STANDARD-METHOD 'SPECIALIZERS))
    (WHEN (CONSP SPECIALIZER)
      (LET* ((OBJECT (SECOND SPECIALIZER))
	     (PAIR (ASSOC OBJECT *EQL-SPECIALIZER-METHODS*)))
	(IF PAIR
	    (PUSHNEW METHOD (CDR PAIR))
	    (PUSH (LIST OBJECT METHOD) *EQL-SPECIALIZER-METHODS*)))))
  (LET ((FUNCTION (BOOTSTRAP-SLOT-VALUE METHOD 'STANDARD-METHOD 'CELL)))
    (WHEN FUNCTION
      (LET ((FAMILY (BOOTSTRAP-SLOT-VALUE METHOD 'STANDARD-METHOD 'MAPPING-TABLE-FAMILY)))
	(WHEN FAMILY
	  #+Genera
	  (LET ((OLD-FAMILIES
		  (BOOTSTRAP-FSLOT-VALUE GENERIC-FUNCTION 'MAPPING-TABLE-FAMILIES)))
	    (MULTIPLE-VALUE-BIND (NEW-FAMILY NEW-FAMILIES)
		(FIND-APPROPRIATE-MAPPING-TABLE OLD-FAMILIES FAMILY)
	      (UNLESS (EQ OLD-FAMILIES NEW-FAMILIES)
		(SETF (BOOTSTRAP-FSLOT-VALUE GENERIC-FUNCTION 'MAPPING-TABLE-FAMILIES)
		      NEW-FAMILIES))
	      (WHEN (NOT (EQ FAMILY NEW-FAMILY))
		(UPDATE-MAPPING-TABLE-INSTRUCTIONS FUNCTION NEW-FAMILY FAMILY)
		(SETF (BOOTSTRAP-SLOT-VALUE METHOD 'STANDARD-METHOD 'MAPPING-TABLE-FAMILY)
		      (SETF FAMILY NEW-FAMILY)))))
	  #-Genera
	  (PUSH FAMILY (BOOTSTRAP-FSLOT-VALUE GENERIC-FUNCTION 'MAPPING-TABLE-FAMILIES))
	  (ENTER-MAPPING-TABLE-FAMILY FAMILY))))))

(DEFUN BOOTSTRAP-MAKE-METHOD-COMBINATION-DEFINITION
       (CLASS &KEY NAME OPERATOR IDENTITY-WITH-ONE-ARGUMENT DOCUMENTATION
	((METHOD-GROUPS METHOD-GROUPS) NIL)  FUNCTION ARGUMENTS-LAMBDA-LIST)
  (LET ((INSTANCE (%ALLOCATE-INSTANCE (CLASS-INSTANCE-INFORMATION (FIND-CLASS CLASS)))))
    (BOOTSTRAP-INITIALIZE-INSTANCE INSTANCE CLASS)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'NAME) NAME)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'DOCUMENTATION) DOCUMENTATION)
    (ECASE CLASS
      (SHORT-FORM-METHOD-COMBINATION-DEFINITION
	(SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'OPERATOR) OPERATOR)
	(SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'IDENTITY-WITH-ONE-ARGUMENT)
	      IDENTITY-WITH-ONE-ARGUMENT))
      (LONG-FORM-METHOD-COMBINATION-DEFINITION
	(SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'METHOD-GROUPS) METHOD-GROUPS)
	(SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'FUNCTION) FUNCTION)
	(SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'ARGUMENTS-LAMBDA-LIST)
	      ARGUMENTS-LAMBDA-LIST)))
    INSTANCE))

(DEFUN BOOTSTRAP-MAKE-METHOD-COMBINATION (CLASS &KEY TYPE OPTIONS)
  (LET ((INSTANCE (%ALLOCATE-INSTANCE (CLASS-INSTANCE-INFORMATION (FIND-CLASS CLASS)))))
    (BOOTSTRAP-INITIALIZE-INSTANCE INSTANCE CLASS)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'TYPE) TYPE)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE CLASS 'OPTIONS) OPTIONS)
    INSTANCE))

(DEFUN BOOTSTRAP-MAKE-MISCELLANEOUS-FUNCTION (CLASS &KEY LAMBDA-EXPRESSION NAME)
  (LET ((INSTANCE (%ALLOCATE-INSTANCE (BOOTSTRAP-CLASS-INFORMATION CLASS))))
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE 'MISCELLANEOUS-FUNCTION 'PLIST) NIL)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE 'MISCELLANEOUS-FUNCTION 'NAME) NAME)
    (SETF (BOOTSTRAP-SLOT-VALUE INSTANCE 'MISCELLANEOUS-FUNCTION 'LAMBDA-EXPRESSION)
	  LAMBDA-EXPRESSION)
    INSTANCE))

(DEFVAR *SPECIALLY-MAPPED-GENERICS* NIL)

(DEFUN BOOTSTRAP-ADD-MAPPING (GENERIC-FUNCTION CLASS FUNCTION EXTRA-ARGUMENT)
  (PUSHNEW GENERIC-FUNCTION *SPECIALLY-MAPPED-GENERICS*)
  (LET ((DISPATCHES `(,(MAKE-CLASS-DISPATCH :POSITION 0 :CLASS CLASS)
		      ,(MAKE-FINISH-DISPATCH :HANDLER FUNCTION
					     :EXTRA-ARGUMENT EXTRA-ARGUMENT))))
    (MODIFY-DISPATCHES
      GENERIC-FUNCTION
      #'(LAMBDA (OLD-DISPATCH)
	  OLD-DISPATCH
	  (POP DISPATCHES)))))

;;; Bootstrapping
;;;
;;; The generic functions get defined first since they are the simplest.  Then bring
;;; up the classes.
(DEFVAR *OVERRIDDEN-GENERICS* NIL)		;A list of all generic functions
						;whose handlers have been overridden.

(DEFUN OVERRIDE-GENERIC (GENERIC DEFINITION)
  (PUSH GENERIC *OVERRIDDEN-GENERICS*)
  (SETF (%FUNCALLABLE-INSTANCE-FUNCTION GENERIC) DEFINITION))

(DEFUN REVERT-GENERIC (GENERIC)
  (SETF (%FUNCALLABLE-INSTANCE-FUNCTION GENERIC) #'HANDLE-START-DISPATCH-MISS)
  (SETQ *OVERRIDDEN-GENERICS* (DELETE GENERIC *OVERRIDDEN-GENERICS*)))

;;; Prepare for compiling/loading generics
(DEFUN INITIALIZE-CLOS-1 ()
  (SETQ *CLOS-INITIALIZED-P* NIL)
  (MAP-OVER-GENERIC-FUNCTIONS
    #'(LAMBDA (GENERIC-FUNCTION)
	(LET ((NAME (BOOTSTRAP-FSLOT-VALUE GENERIC-FUNCTION 'NAME)))
	  (WHEN (AND (NOT (EQ NAME 'GENERIC-FUNCTION-NAME))
		     (FBOUNDP NAME)
		     (EQ (FDEFINITION NAME) GENERIC-FUNCTION))
	    (FMAKUNBOUND NAME)))))
  (FMAKUNBOUND 'GENERIC-FUNCTION-NAME)
  (FILL *ALL-GENERIC-FUNCTIONS* NIL)
  (SETF *ALL-GENERIC-FUNCTIONS-LENGTH* 0)
  #+Genera
  (SETF *ALL-GENERIC-FUNCTIONS-WITH-SELECTORS* NIL)
  #+Genera
  (PROGN
    (SETF (FILL-POINTER *ALL-GENERIC-FUNCTION-NAMES-AARRAY*) 0)
    (SETF (SI:AARRAY-SORT-STATE *ALL-GENERIC-FUNCTION-NAMES-AARRAY*) 0))
  (REMOVE-ALL-CLASSES)
  (SETQ *BOOTSTRAP-CLASSES* NIL)
  (SETQ *BOOTSTRAP-GENERICS* NIL)
  (SETQ *METHOD-COMBINATION-DEFINITIONS* NIL)
  (SETQ *OVERRIDDEN-GENERICS* NIL)
  (SETQ *SPECIALLY-MAPPED-GENERICS* NIL)
  (SETQ *EQL-SPECIALIZER-METHODS* NIL)
  (CLOS-CLRHASH *MISCELLANEOUS-FUNCTION-TABLE*)
  (MAKUNBOUND '*INLINE-METHOD-GENERATORS*)
  #+Genera (REMPROP 'MAKE-INSTANCE 'COMPILER:OPTIMIZERS)
  (INITIALIZE-BOOTSTRAP-INSTANCE-INFORMATION)
  ;(INITIALIZE-CLASS-DISPATCH-STARTERS)
  (FLET ((BOOTSTRAP-GENERIC (NAME DEFINITION)
	   (LET (#+Genera
		 ;; Don't get warnings about redefinition here or when the real
		 ;; definition comes.
		 (SYS:FDEFINE-FILE-PATHNAME (SI:GET-SOURCE-FILE-NAME NAME 'DEFUN)))
	     (SETF (FDEFINITION-IN-ENVIRONMENT NAME NIL)
		   (BOOTSTRAP-INITIALIZE-GENERIC-FUNCTION
		     (BOOTSTRAP-MAKE-GENERIC-FUNCTION) NAME))
	     (OVERRIDE-GENERIC (FDEFINITION-IN-ENVIRONMENT NAME NIL)
			       DEFINITION))))
    (BOOTSTRAP-GENERIC 'ENSURE-GENERIC-FUNCTION-USING-CLASS
		       #'BOOTSTRAP-ENSURE-GENERIC-FUNCTION-USING-CLASS)
    (BOOTSTRAP-GENERIC 'FUNCTION-NAME-OBJECT
		       (BOOTSTRAP-GENERIC-LAMBDA (GENERIC-FUNCTION)
			 (BOOTSTRAP-FSLOT-VALUE GENERIC-FUNCTION 'NAME)))
    (BOOTSTRAP-GENERIC 'ARGLIST-OBJECT
		       (BOOTSTRAP-GENERIC-LAMBDA (GENERIC-FUNCTION)
			 (BOOTSTRAP-FSLOT-VALUE GENERIC-FUNCTION 'LAMBDA-LIST)))
    (BOOTSTRAP-GENERIC 'ENSURE-CLASS-USING-CLASS
		       #'BOOTSTRAP-ENSURE-CLASS-USING-CLASS)
    (BOOTSTRAP-GENERIC 'FIND-METHOD-COMBINATION
		       (BOOTSTRAP-GENERIC-LAMBDA (GENERIC-FUNCTION TYPE OPTIONS)
			 (DECLARE (IGNORE GENERIC-FUNCTION))
			 (CONS TYPE OPTIONS)))
    (BOOTSTRAP-GENERIC 'GENERIC-FUNCTION-NAME
		       (BOOTSTRAP-GENERIC-LAMBDA (GENERIC-FUNCTION)
			 (BOOTSTRAP-FSLOT-VALUE GENERIC-FUNCTION 'NAME)))
    (BOOTSTRAP-GENERIC 'CLASS-PROTOTYPE
		       (BOOTSTRAP-GENERIC-LAMBDA (CLASS)
			 CLASS))
    ))

;;; Prepare for compiling/loading class definitions, after generics have been loaded.
(DEFUN INITIALIZE-CLOS-2 ()
  (OVERRIDE-GENERIC #'LAMBDA-LIST-CONGRUENT-P #'BOOTSTRAP-LAMBDA-LIST-CONGRUENT-P)
  ;; Override so (SETF FIND-CLASS) can work
  (OVERRIDE-GENERIC
    #'CLASS-NAME
    (BOOTSTRAP-GENERIC-LAMBDA (CLASS)
      CLASS
      NIL))
  (SETQ *ALLOCATE-INSTANCE* (FDEFINITION-IN-ENVIRONMENT 'ALLOCATE-INSTANCE NIL))
  (SETQ *MAKE-INSTANCE* (FDEFINITION-IN-ENVIRONMENT 'MAKE-INSTANCE NIL))
  (SETQ *SHARED-INITIALIZE* (FDEFINITION-IN-ENVIRONMENT 'SHARED-INITIALIZE NIL))
  (SETQ *INITIALIZE-INSTANCE* (FDEFINITION-IN-ENVIRONMENT 'INITIALIZE-INSTANCE NIL))
  (SETQ *REINITIALIZE-INSTANCE* (FDEFINITION-IN-ENVIRONMENT 'REINITIALIZE-INSTANCE NIL))
  (SETQ *SLOT-VALUE-USING-CLASS* (FDEFINITION-IN-ENVIRONMENT 'SLOT-VALUE-USING-CLASS NIL))
  (SETQ *UPDATE-INSTANCE-FOR-REDEFINED-CLASS*
	(FDEFINITION-IN-ENVIRONMENT 'UPDATE-INSTANCE-FOR-REDEFINED-CLASS NIL))
  (SETQ *UPDATE-INSTANCE-FOR-DIFFERENT-CLASS*
	(FDEFINITION-IN-ENVIRONMENT 'UPDATE-INSTANCE-FOR-DIFFERENT-CLASS NIL))
  (SETQ *NO-APPLICABLE-METHOD* (FDEFINITION-IN-ENVIRONMENT 'NO-APPLICABLE-METHOD NIL))
  )

(DEFUN INITIALIZE-CLOS-3 ()
  (DECLARE (NOTINLINE CLASS-NAME))
  (SETQ *METHOD-COMBINATION-DEFINITIONS* NIL)
  (REVERT-GENERIC #'CLASS-NAME)
  (OVERRIDE-GENERIC #'GENERIC-FUNCTION-LAMBDA-LIST
		    (BOOTSTRAP-GENERIC-LAMBDA (GENERIC-FUNCTION)
		      (BOOTSTRAP-FSLOT-VALUE GENERIC-FUNCTION 'LAMBDA-LIST)))
  (OVERRIDE-GENERIC #'DISPATCHING-FUNCALLABLE-INSTANCE-FROM-SELECTOR
		    (BOOTSTRAP-GENERIC-LAMBDA (SELECTOR)
		      (FUNCALLABLE-INSTANCE-FROM-GENERIC-SELECTOR SELECTOR)))
  (OVERRIDE-GENERIC #'DISPATCHING-FUNCALLABLE-INSTANCE-TABLE
		    (BOOTSTRAP-GENERIC-LAMBDA (GENERIC-FUNCTION)
		      (BOOTSTRAP-FSLOT-VALUE GENERIC-FUNCTION 'TABLE)))
  (OVERRIDE-GENERIC #'(SETF DISPATCHING-FUNCALLABLE-INSTANCE-TABLE)
		    (BOOTSTRAP-GENERIC-LAMBDA (NEW-VALUE GENERIC-FUNCTION)
		      (SETF (BOOTSTRAP-FSLOT-VALUE GENERIC-FUNCTION 'TABLE)
			    NEW-VALUE)))
  (OVERRIDE-GENERIC #'(SETF PROPERTY-LIST-OBJECT)
		    (BOOTSTRAP-GENERIC-LAMBDA (NEW-VALUE METHOD)
		      (SETF (BOOTSTRAP-SLOT-VALUE METHOD 'STANDARD-METHOD 'PROPERTY-LIST)
			    NEW-VALUE)))
  (OVERRIDE-GENERIC #'CLASS-INSTANCE-INFORMATION
		    (BOOTSTRAP-GENERIC-LAMBDA (CLASS)
		      (BOOTSTRAP-SLOT-VALUE CLASS 'STANDARD-CLASS 'INSTANCE-INFORMATION)))
  #+(OR CLOE-Runtime Minima)
  (OVERRIDE-GENERIC #'(SETF DOCUMENTATION)
		    (BOOTSTRAP-GENERIC-LAMBDA (NEW-VALUE THING &OPTIONAL TYPE)
		      (DECLARE (IGNORE NEW-VALUE THING TYPE))))
  (MAPC #'(LAMBDA (GENERIC)
	    (LET ((METHOD-CLASS (BOOTSTRAP-FSLOT-VALUE GENERIC 'METHOD-CLASS)))
	      (WHEN (SYMBOLP METHOD-CLASS)
		(SETF (BOOTSTRAP-FSLOT-VALUE GENERIC 'METHOD-CLASS)
		      (FIND-CLASS (OR METHOD-CLASS 'STANDARD-METHOD))))))
	*BOOTSTRAP-GENERICS*)
  (LET ((CLASS 'STANDARD-DIRECT-SLOT-DEFINITION))
    (DOLIST (READER '((NAME SLOT-DEFINITION-NAME)
		      (INITFORM SLOT-DEFINITION-INITFORM)
		      (INITFUNCTION SLOT-DEFINITION-INITFUNCTION)
		      (INITFORM-INLINABLE SLOT-DEFINITION-INITFORM-INLINABLE)
		      (TYPE SLOT-DEFINITION-TYPE)
		      (ALLOCATION SLOT-DEFINITION-ALLOCATION)
		      (INITARGS SLOT-DEFINITION-INITARGS)
		      (DOCUMENTATION DOCUMENTATION-OBJECT)
		      (READERS SLOT-DEFINITION-READERS)))
      (BOOTSTRAP-ADD-MAPPING
	(FDEFINITION (SECOND READER))
	(FIND-CLASS CLASS)
	#'STANDARD-CLASS-LOCAL-SLOT-READER
	(THIRD (BOOTSTRAP-CLASS-SLOT-DESCRIPTION CLASS (FIRST READER))))))
  (LET ((CLASS 'STANDARD-EFFECTIVE-SLOT-DEFINITION))
    (DOLIST (READER '((NAME SLOT-DEFINITION-NAME)
		      (LOCATION SLOT-DEFINITION-LOCATION)))
      (BOOTSTRAP-ADD-MAPPING
	(FDEFINITION (SECOND READER))
	(FIND-CLASS CLASS)
	#'STANDARD-CLASS-LOCAL-SLOT-READER
	(THIRD (BOOTSTRAP-CLASS-SLOT-DESCRIPTION CLASS (FIRST READER))))))
  (DOLIST (CLASS '(STANDARD-CLASS FUNCALLABLE-STANDARD-CLASS STRUCTURE-CLASS BUILT-IN-CLASS
				  METHOD-ONLY-CLASS FORWARD-REFERENCED-CLASS))
    (DOLIST (READER '((NAME CLASS-NAME)
		      (DIRECT-SUPERCLASSES CLASS-DIRECT-SUPERCLASSES)
		      (DIRECT-SUBCLASSES CLASS-DIRECT-SUBCLASSES)
		      (PROTOTYPE CLASS-PROTOTYPE)
		      (INSTANCE-INFORMATION CLASS-INSTANCE-INFORMATION)))
      (BOOTSTRAP-ADD-MAPPING
	(FDEFINITION (SECOND READER))
	(FIND-CLASS CLASS)
	#'STANDARD-CLASS-LOCAL-SLOT-READER
	(THIRD (BOOTSTRAP-CLASS-SLOT-DESCRIPTION CLASS (FIRST READER))))))
  (DOLIST (CLASS '(STANDARD-CLASS FUNCALLABLE-STANDARD-CLASS))
    (BOOTSTRAP-ADD-MAPPING
      #'CLASS-DIRECT-SLOTS
      (FIND-CLASS CLASS)
      #'STANDARD-CLASS-LOCAL-SLOT-READER
      (THIRD (BOOTSTRAP-CLASS-SLOT-DESCRIPTION CLASS 'DIRECT-SLOTS))))
  (DOLIST (CLASS '(BUILT-IN-CLASS METHOD-ONLY-CLASS))
    (BOOTSTRAP-ADD-MAPPING
      #'CLASS-DIRECT-SLOTS
      (FIND-CLASS CLASS)
      #'CONSTANT-NIL
      NIL))
  (DOLIST (CLASS *BOOTSTRAP-CLASSES*)
    (WHEN (EQ (FIND-CLASS (CLASS-NAME CLASS)) CLASS)
      ;; Skip compile-time classes, since they don't have slots recorded.
      (LET ((INFORMATION (CLASS-INSTANCE-INFORMATION CLASS))
	    (CPL (COMPUTE-CLOS-CLASS-PRECEDENCE-LIST CLASS))
	    (METACLASS (CLASS-NAME (CLASS-OF CLASS))))
	(SETF (%CLASS-INSTANCE-INFORMATION-PRECEDENCE-LIST INFORMATION) CPL)
	(ECASE METACLASS
	  ;; No slots for built-in-class
	  ((BUILT-IN-CLASS STRUCTURE-CLASS METHOD-ONLY-CLASS))
	  ((STANDARD-CLASS FUNCALLABLE-STANDARD-CLASS)
	   (LET ((NAMES NIL)
		 (EFFECTIVE-SLOTS NIL)
		 (I (PROGN #+(OR Genera Minima) 1
			   #+CLOE-Runtime 0)))
	     (DECLARE (FIXNUM I))
	     (DOLIST (CLASS (REVERSE CPL))
	       (DOLIST (SLOT (CLASS-DIRECT-SLOTS CLASS))
		 (PUSHNEW (SLOT-DEFINITION-NAME SLOT) NAMES)))
	     (DOLIST (NAME (REVERSE NAMES))
	       (LET ((DIRECT-SLOTS
		       (MAPCAR #'(LAMBDA (CLASS)
				   (FIND NAME (CLASS-DIRECT-SLOTS CLASS)
					 :KEY #'SLOT-DEFINITION-NAME))
			       CPL))
		     (ALLOCATION NIL)
		     (INITFORM NIL)
		     (INITFUNCTION NIL)
		     (INITFORM-INLINABLE NIL)
		     (TYPES NIL)
		     (INITARGS NIL)
		     (DOCUMENTATION NIL)
		     (LOCATION NIL))
		 (MAPC #'(LAMBDA (SLOT)
			   (WHEN SLOT
			     (SETQ ALLOCATION (SLOT-DEFINITION-ALLOCATION SLOT))
			     (SETQ LOCATION
				   (IF (EQ ALLOCATION ':CLASS)
				       (SLOT-DEFINITION-LOCATION SLOT)
				       NIL))
			     (LET ((TEMP (SLOT-DEFINITION-INITFUNCTION SLOT)))
			       (WHEN TEMP
				 (SETQ INITFUNCTION TEMP
				       INITFORM (SLOT-DEFINITION-INITFORM SLOT)
				       INITFORM-INLINABLE
				       (SLOT-DEFINITION-INITFORM-INLINABLE SLOT))))
			     (LET ((TEMP (SLOT-DEFINITION-TYPE SLOT)))
			       (UNLESS (EQ TEMP T) 
				 (PUSHNEW TEMP TYPES :TEST #'EQUAL)))
			     (MAPC #'(LAMBDA (INITARG)
				       (PUSH INITARG INITARGS))
				   (SLOT-DEFINITION-INITARGS SLOT))
			     (LET ((TEMP (DOCUMENTATION-OBJECT SLOT)))
			       (WHEN TEMP (SETQ DOCUMENTATION TEMP)))))
		       (REVERSE DIRECT-SLOTS))
		 (SETQ ALLOCATION (OR ALLOCATION :INSTANCE))
		 (WHEN (EQ ALLOCATION :INSTANCE)
		   (SETQ LOCATION (SHIFTF I (1+ I)))
		   (WHEN (BOOTSTRAP-CLASS-INFO (CLASS-NAME CLASS))
		     (LET ((BOOTSTRAP-LOCATION
			     (THIRD (BOOTSTRAP-CLASS-SLOT-DESCRIPTION
				      (CLASS-NAME CLASS)
				      NAME))))
		       (UNLESS (EQL LOCATION BOOTSTRAP-LOCATION)
			 (CERROR "Continue to find additional lossage"
				 "Lose:  For class ~s, bootstrap slot location for ~s is wrong"
				 (CLASS-NAME CLASS)
				 NAME)))))
		 (PUSH (BOOTSTRAP-MAKE-EFFECTIVE-SLOT
			 :NAME NAME
			 :ALLOCATION ALLOCATION
			 :INITFORM INITFORM
			 :INITFUNCTION INITFUNCTION
			 'INITFORM-INLINABLE INITFORM-INLINABLE
			 :TYPE (COND ((NULL TYPES) T)
				     ((NULL (REST TYPES)) (FIRST TYPES))
				     (T `(AND ,@(NREVERSE TYPES))))
			 :INITARGS (REVERSE INITARGS)
			 :DOCUMENTATION DOCUMENTATION
			 :LOCATION LOCATION)
		       EFFECTIVE-SLOTS)))
	     (SETF (LDB %%STANDARD-CLASS-FINALIZED-P
			(BOOTSTRAP-SLOT-VALUE CLASS 'STANDARD-CLASS 'BITS))
		   -1)

	     #+Genera
	     (WHEN (EQ METACLASS 'FUNCALLABLE-STANDARD-CLASS)
	       ;; Make sure generic functions are of odd length
	       (SETQ I (LOGIOR I 1)))

	     (LET ((OLD-SIZE (%INSTANCE-INFORMATION-SIZE INFORMATION)))
	       (WHEN (AND (/= OLD-SIZE 3)
			  (/= OLD-SIZE I))
		 (ERROR "You're going to lose ~s" (CLASS-NAME CLASS))))
	     (SETF (%INSTANCE-INFORMATION-SIZE INFORMATION) I)
	     (SET-CLASS-INSTANCE-INFORMATION-EFFECTIVE-SLOTS CLASS INFORMATION EFFECTIVE-SLOTS)
	     (ECASE METACLASS
	       (STANDARD-CLASS
		 (SETF (BOOTSTRAP-SLOT-VALUE CLASS METACLASS 'PROTOTYPE)
		       (%ALLOCATE-INSTANCE INFORMATION)))
	       (FUNCALLABLE-STANDARD-CLASS
		 (SETF (BOOTSTRAP-SLOT-VALUE CLASS METACLASS 'PROTOTYPE)
		       (%ALLOCATE-FUNCALLABLE-INSTANCE INFORMATION))))))))))
  ;; Initialize the built-in classes
  (FLET ((INITIALIZE-BUILTIN-CLASS (NAME PROTOTYPE &REST DATA-TYPES)
	   (DECLARE (DYNAMIC-EXTENT DATA-TYPES))
	   #-(OR Genera Minima) (DECLARE (IGNORE DATA-TYPES))
	   (LET* ((CLASS (FIND-CLASS NAME))
		  (INFORMATION (CLASS-INSTANCE-INFORMATION CLASS)))
	     (SETF (BOOTSTRAP-SLOT-VALUE CLASS 'CLOS-CLASS 'PROTOTYPE) PROTOTYPE)
	     #+(OR Genera Minima)
	     (DOLIST (TYPE DATA-TYPES)
	       (SETF (%CLASS-INFORMATION-FOR-TYPE TYPE) INFORMATION))
	     CLASS)))
    (LET* ((T-CLASS (FIND-CLASS T))
	   (T-INFORMATION (CLASS-INSTANCE-INFORMATION T-CLASS)))
      ;;Fill initial tables with T information.
      #+Genera
      (DOTIMES (TYPE (SYS:DEFSYSBYTE-LIMIT-VALUE SYS:%%Q-DATA-TYPE))
	(SETF (%CLASS-INFORMATION-FOR-TYPE TYPE) T-INFORMATION))
      #+Minima
      (DOTIMES (TYPE #X40)
	(SETF (%CLASS-INFORMATION-FOR-TYPE TYPE) T-INFORMATION))
      #+CLOE-Runtime
      (FILL (THE SIMPLE-VECTOR *OBJECT-TYPE-INSTANCE-INFORMATION*) T-INFORMATION)
      #-(OR Genera CLOE-Runtime Minima)
      (NYI)
      (SETF (BOOTSTRAP-SLOT-VALUE T-CLASS 'CLOS-CLASS 'PROTOTYPE)
	    (%ALLOCATE-INSTANCE T-INFORMATION)))
    #+Genera
    (PROGN
      (INITIALIZE-BUILTIN-CLASS 'FUNCTION #'CONS)
      (INITIALIZE-BUILTIN-CLASS 'SYS:COMPILED-FUNCTION #'CONS SYS:DTP-COMPILED-FUNCTION)
      (INITIALIZE-BUILTIN-CLASS 'SYS:DYNAMIC-CLOSURE
				(LET ((*A* #'(LAMBDA ()
					       (DECLARE (SPECIAL *A*))
					       *A*)))
				  (DECLARE (SPECIAL *A*))
				  (ZL:CLOSURE '(*A*) *A*))
				#+IMACH SYS:DTP-DYNAMIC-CLOSURE
				#+|3600| SYS:DTP-CLOSURE)
      (INITIALIZE-BUILTIN-CLASS 'ARRAY (MAKE-ARRAY NIL) SYS:DTP-ARRAY)
      (INITIALIZE-BUILTIN-CLASS 'CHARACTER #\C SYS:DTP-CHARACTER)
      (INITIALIZE-BUILTIN-CLASS 'NUMBER 6)
      (INITIALIZE-BUILTIN-CLASS 'SEQUENCE '(1 2 3))
      (INITIALIZE-BUILTIN-CLASS 'SYMBOL 'SYMBOL SYS:DTP-SYMBOL)
      (INITIALIZE-BUILTIN-CLASS 'VECTOR (VECTOR 1 2 3))
      (INITIALIZE-BUILTIN-CLASS 'STRING "String" #+IMACH SYS:DTP-STRING)
      (INITIALIZE-BUILTIN-CLASS 'BIT-VECTOR #*1001)
      (INITIALIZE-BUILTIN-CLASS 'READTABLE *READTABLE*)
      (INITIALIZE-BUILTIN-CLASS 'PACKAGE *PACKAGE*)
      (INITIALIZE-BUILTIN-CLASS 'COMPLEX #C(0 1) #+IMACH SYS:DTP-COMPLEX)
      (INITIALIZE-BUILTIN-CLASS 'FLOAT 1.3)
      (INITIALIZE-BUILTIN-CLASS 'SINGLE-FLOAT 1.3
				#+IMACH SYS:DTP-SINGLE-FLOAT #+|3600| SYS:DTP-FLOAT)
      (INITIALIZE-BUILTIN-CLASS 'DOUBLE-FLOAT 1.3D0 #+IMACH SYS:DTP-DOUBLE-FLOAT)
      (INITIALIZE-BUILTIN-CLASS 'RATIONAL 3/4)
      (INITIALIZE-BUILTIN-CLASS 'INTEGER 5)
      (INITIALIZE-BUILTIN-CLASS 'FIXNUM 4 #+IMACH SYS:DTP-FIXNUM #+|3600| SYS:DTP-FIX)
      (INITIALIZE-BUILTIN-CLASS 'BIGNUM (ASH 1 32) #+IMACH SYS:DTP-BIGNUM)
      (INITIALIZE-BUILTIN-CLASS 'RATIO 5/7)
      #+IMACH
      (INITIALIZE-BUILTIN-CLASS 'SYS:BIG-RATIO 1/1000000 SYS:DTP-BIG-RATIO)
      #+IMACH
      (INITIALIZE-BUILTIN-CLASS 'SYS:SMALL-RATIO 1/2 SYS:DTP-SMALL-RATIO)
      (INITIALIZE-BUILTIN-CLASS 'LIST '(1 2 3 4))
      (INITIALIZE-BUILTIN-CLASS 'NULL NIL SYS:DTP-NIL)
      (INITIALIZE-BUILTIN-CLASS 'CONS '(CAR . CDR) SYS:DTP-LIST)
      (INITIALIZE-BUILTIN-CLASS 'SYS:LEXICAL-CLOSURE
				(LABELS ((LEXICAL-CLOSURE-PROTOTYPE ()
					   #'LEXICAL-CLOSURE-PROTOTYPE))
				  #'LEXICAL-CLOSURE-PROTOTYPE))
      (INITIALIZE-BUILTIN-CLASS 'LOCATIVE (SYS:VALUE-CELL-LOCATION 'LOCATIVE)
				SYS:DTP-LOCATIVE)
      (INITIALIZE-BUILTIN-CLASS 'GENERIC-FUNCTION-SELECTOR
				(%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT
				  #'DISPATCHING-FUNCALLABLE-INSTANCE-FROM-SELECTOR)
				SYS:DTP-GENERIC-FUNCTION))
    #+Minima
    (PROGN
      (INITIALIZE-BUILTIN-CLASS 'FUNCTION #'CONS)
      (INITIALIZE-BUILTIN-CLASS 'ARRAY (MAKE-ARRAY NIL) (IVORY:DATA-TYPE 'IVORY::ARRAY))
      (INITIALIZE-BUILTIN-CLASS 'CHARACTER #\C (IVORY:DATA-TYPE 'IVORY::CHARACTER))
      (INITIALIZE-BUILTIN-CLASS 'NUMBER 6)
      (INITIALIZE-BUILTIN-CLASS 'SEQUENCE '(1 2 3))
      (INITIALIZE-BUILTIN-CLASS 'SYMBOL 'SYMBOL (IVORY:DATA-TYPE 'IVORY::SYMBOL))
      (INITIALIZE-BUILTIN-CLASS 'VECTOR (VECTOR 1 2 3))
      (INITIALIZE-BUILTIN-CLASS 'STRING "String" (IVORY:DATA-TYPE 'IVORY::STRING))
      (INITIALIZE-BUILTIN-CLASS 'BIT-VECTOR #*1001)
      (INITIALIZE-BUILTIN-CLASS 'COMPLEX #C(0 1) (IVORY:DATA-TYPE 'IVORY::COMPLEX))
      (INITIALIZE-BUILTIN-CLASS 'FLOAT 1.3)
      (INITIALIZE-BUILTIN-CLASS 'SINGLE-FLOAT 1.3 (IVORY:DATA-TYPE 'IVORY::SINGLE-FLOAT))
      (INITIALIZE-BUILTIN-CLASS 'DOUBLE-FLOAT 1.3D0 (IVORY:DATA-TYPE 'IVORY::DOUBLE-FLOAT))
      (INITIALIZE-BUILTIN-CLASS 'RATIONAL 3/4)
      (INITIALIZE-BUILTIN-CLASS 'INTEGER 5)
      (INITIALIZE-BUILTIN-CLASS 'FIXNUM 4 (IVORY:DATA-TYPE 'IVORY::FIXNUM))
      (INITIALIZE-BUILTIN-CLASS 'BIGNUM (ASH 1 32) (IVORY:DATA-TYPE 'IVORY::DOUBLE-FIXNUM) (IVORY:DATA-TYPE 'IVORY::BIGNUM))
      (INITIALIZE-BUILTIN-CLASS 'RATIO 5/7 (IVORY:DATA-TYPE 'IVORY::SMALL-RATIO) (IVORY:DATA-TYPE 'IVORY::BIG-RATIO))
      (INITIALIZE-BUILTIN-CLASS 'LIST '(1 2 3 4))
      (INITIALIZE-BUILTIN-CLASS 'NULL NIL (IVORY:DATA-TYPE 'IVORY::NIL))
      (INITIALIZE-BUILTIN-CLASS 'CONS '(CAR . CDR) (IVORY:DATA-TYPE 'IVORY::CONS))
      (INITIALIZE-BUILTIN-CLASS 'IVORY::LEXICAL-CLOSURE
				(LABELS ((LEXICAL-CLOSURE-PROTOTYPE ()
					   #'LEXICAL-CLOSURE-PROTOTYPE))
				  #'LEXICAL-CLOSURE-PROTOTYPE))
      (INITIALIZE-BUILTIN-CLASS 'LOCATIVE (LOCF *METHOD-COMBINATION-DEFINITIONS*)
				(IVORY:DATA-TYPE 'IVORY::LOCATIVE))
      (INITIALIZE-BUILTIN-CLASS 'GENERIC-FUNCTION-SELECTOR
				(%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT
				  #'DISPATCHING-FUNCALLABLE-INSTANCE-FROM-SELECTOR)
				(IVORY:DATA-TYPE 'IVORY::GENERIC-FUNCTION))
      (INITIALIZE-BUILTIN-CLASS 'IVORY::COMPILED-CODE #'CONS
				(IVORY:DATA-TYPE 'IVORY::COMPILED-FUNCTION))
      (INITIALIZE-BUILTIN-CLASS 'IVORY::PC (HANDLER-PC #'HANDLE-INTERPRETED-HANDLER)
				(IVORY:DATA-TYPE 'IVORY::EVEN-PC) (IVORY:DATA-TYPE 'IVORY::ODD-PC))
      (INITIALIZE-BUILTIN-CLASS 'IVORY::PHYSICAL-ADDRESS (IVORY:%MAKE-PHYSICAL-ADDRESS 0)
				(IVORY:DATA-TYPE 'IVORY::PHYSICAL-ADDRESS))
      )
    #-(OR Genera Minima)
    (LET ((TYPICAL-CLOSURE (LET ((X 3)) #'(LAMBDA () (INCF X)))))
      (INITIALIZE-BUILTIN-CLASS 'ARRAY (MAKE-ARRAY NIL))
      (INITIALIZE-BUILTIN-CLASS 'BIGNUM (1+ MOST-POSITIVE-FIXNUM))
      (INITIALIZE-BUILTIN-CLASS 'BIT-VECTOR #*1001)
      (INITIALIZE-BUILTIN-CLASS 'CHARACTER #\C)
      (INITIALIZE-BUILTIN-CLASS 'COMPLEX #C(0 1))
      (INITIALIZE-BUILTIN-CLASS 'CONS '(CAR . CDR))
      #-CLOE-Runtime (INITIALIZE-BUILTIN-CLASS 'DOUBLE-FLOAT 259.259D0)
      (INITIALIZE-BUILTIN-CLASS 'FIXNUM 4)
      (INITIALIZE-BUILTIN-CLASS 'FLOAT 1.3)
      (INITIALIZE-BUILTIN-CLASS 'FUNCTION #'CONS)
      #+CLOE-Runtime (INITIALIZE-BUILTIN-CLASS 'SYS::IMMOBJ #\A)
      (INITIALIZE-BUILTIN-CLASS 'INTEGER 5)
      #+CLOE-Runtime (INITIALIZE-BUILTIN-CLASS 'SYS::LEXICAL-CLOSURE TYPICAL-CLOSURE)
      (INITIALIZE-BUILTIN-CLASS 'LIST '(1 2 3 4))
      #-CLOE-Runtime (INITIALIZE-BUILTIN-CLASS 'LONG-FLOAT 10.5L0)
      (INITIALIZE-BUILTIN-CLASS 'NULL NIL)
      (INITIALIZE-BUILTIN-CLASS 'NUMBER 6)
      (INITIALIZE-BUILTIN-CLASS 'RATIO 5/7)
      (INITIALIZE-BUILTIN-CLASS 'RATIONAL 3/4)
      (INITIALIZE-BUILTIN-CLASS 'REAL 25/9)
      (INITIALIZE-BUILTIN-CLASS 'SEQUENCE '(1 2 3))
      #-CLOE-Runtime (INITIALIZE-BUILTIN-CLASS 'SHORT-FLOAT 1.3S0)
      (INITIALIZE-BUILTIN-CLASS 'SINGLE-FLOAT 69.0F0)
      (INITIALIZE-BUILTIN-CLASS 'SYS::SIMPLE-FUNCTION #'CAR)
      (INITIALIZE-BUILTIN-CLASS 'STRING "String")
      (INITIALIZE-BUILTIN-CLASS 'SYMBOL 'SYMBOL)
      #+CLOE-Runtime (INITIALIZE-BUILTIN-CLASS 'SYS::TRAMPOLINE TYPICAL-CLOSURE)
      (INITIALIZE-BUILTIN-CLASS 'VECTOR (VECTOR 1 2 3))))
  ;; Now initialize dispatching for the built-in classes
  #+IMACH
  (PROGN
    (LET ((DISPATCH-TABLE
	    (MAKE-DISPATCH-TABLE
	      1 NIL NIL
	      (HANDLER-PC-NO-ENTRY #'HANDLE-DTP-ARRAY-DISPATCH))))
      (SETF (%CLASS-INFORMATION-FOR-TYPE SYS:DTP-ARRAY)
	    (MAKE-INSTANCE-INFORMATION-INTERNAL
	      DISPATCH-TABLE
	      (DISPATCH-TABLE-MASK DISPATCH-TABLE)
	      (DISPATCH-TABLE-ADDRESS DISPATCH-TABLE)))
      (SETF *BIT-VECTOR-INSTANCE* (%ALLOCATE-INSTANCE
				    (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'BIT-VECTOR))))
      (SETF *VECTOR-INSTANCE* (%ALLOCATE-INSTANCE
				(CLASS-INSTANCE-INFORMATION (FIND-CLASS 'VECTOR))))
      (SETF *ARRAY-INSTANCE* (%ALLOCATE-INSTANCE
			       (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'ARRAY))))
      (SETF *PACKAGE-INSTANCE* (%ALLOCATE-INSTANCE
				 (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'PACKAGE))))
      (SETF *READTABLE-INSTANCE* (%ALLOCATE-INSTANCE
				   (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'READTABLE)))))
    (LET ((DISPATCH-TABLE
	    (MAKE-DISPATCH-TABLE
	      1 NIL NIL
	      (HANDLER-PC-NO-ENTRY #'HANDLE-DTP-LEXICAL-CLOSURE-DISPATCH))))
      ;; Don't use the prototype of class T here because that is an object which is a
      ;; valid last argument to a generic function, and that would confuse certain
      ;; types of misses.
      (SETQ *LEXICAL-CLOSURE-INSTANCE*
	    (%ALLOCATE-INSTANCE
	      (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'SYS:LEXICAL-CLOSURE))))
      (SETF (%CLASS-INFORMATION-FOR-TYPE SYS:DTP-LEXICAL-CLOSURE)
	    (MAKE-INSTANCE-INFORMATION-INTERNAL
	      DISPATCH-TABLE
	      (DISPATCH-TABLE-MASK DISPATCH-TABLE)
	      (DISPATCH-TABLE-ADDRESS DISPATCH-TABLE)))))
  #+Minima
  (PROGN
    (LET ((DISPATCH-TABLE
	    (MAKE-DISPATCH-TABLE
	      1 NIL NIL
	      (HANDLER-PC-NO-ENTRY #'HANDLE-DTP-ARRAY-DISPATCH))))
      (SETF (%CLASS-INFORMATION-FOR-TYPE (IVORY:DATA-TYPE 'IVORY::ARRAY))
	    (MAKE-INSTANCE-INFORMATION-INTERNAL
	      DISPATCH-TABLE
	      (DISPATCH-TABLE-MASK DISPATCH-TABLE)
	      (DISPATCH-TABLE-ADDRESS DISPATCH-TABLE)))
      (SETF *BIT-VECTOR-INSTANCE* (%ALLOCATE-INSTANCE
				    (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'BIT-VECTOR))))
      (SETF *VECTOR-INSTANCE* (%ALLOCATE-INSTANCE
				(CLASS-INSTANCE-INFORMATION (FIND-CLASS 'VECTOR))))
      (SETF *ARRAY-INSTANCE* (%ALLOCATE-INSTANCE
			       (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'ARRAY)))))
    (LET ((DISPATCH-TABLE
	    (MAKE-DISPATCH-TABLE
	      1 NIL NIL
	      (HANDLER-PC-NO-ENTRY #'HANDLE-DTP-LEXICAL-CLOSURE-DISPATCH))))
      ;; Don't use the prototype of class T here because that is an object which is a
      ;; valid last argument to a generic function, and that would confuse certain
      ;; types of misses.
      (SETQ *LEXICAL-CLOSURE-INSTANCE*
	    (%ALLOCATE-INSTANCE
	      (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'IVORY::LEXICAL-CLOSURE))))
      (SETF (%CLASS-INFORMATION-FOR-TYPE (IVORY:DATA-TYPE 'IVORY::EXTRA-ARG-FUNCTION))
	    (MAKE-INSTANCE-INFORMATION-INTERNAL
	      DISPATCH-TABLE
	      (DISPATCH-TABLE-MASK DISPATCH-TABLE)
	      (DISPATCH-TABLE-ADDRESS DISPATCH-TABLE)))))
  #+|3600|
  (PROGN
    (SETF (AREF *EXTENDED-NUMBER-INFORMATION* SYS:%HEADER-TYPE-BIGNUM)
	  (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'BIGNUM)))
    (SETF (AREF *EXTENDED-NUMBER-INFORMATION* SYS:%HEADER-TYPE-RATIONAL)
	  (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'RATIO)))
    (SETF (AREF *EXTENDED-NUMBER-INFORMATION* SYS:%HEADER-TYPE-COMPLEX)
	  (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'COMPLEX)))
    (SETF (AREF *EXTENDED-NUMBER-INFORMATION* SYS:%HEADER-TYPE-DOUBLE)
	  (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'DOUBLE-FLOAT)))
    (SETF *STRING-INFORMATION*
	  (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'STRING)))
    (SETF *BIT-VECTOR-INFORMATION*
	  (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'BIT-VECTOR)))
    (SETF *VECTOR-INFORMATION*
	  (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'VECTOR)))
    (SETF *ARRAY-INFORMATION*
	  (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'ARRAY)))
    (SETF *PACKAGE-INFORMATION*
	  (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'PACKAGE)))
    (SETF *READTABLE-INFORMATION*
	  (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'READTABLE)))
    (SETF *LEXICAL-CLOSURE-INFORMATION*
	  (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'SYS:LEXICAL-CLOSURE)))
    (LET* ((DISPATCH-TABLE
	     (MAKE-DISPATCH-TABLE
	       1 NIL NIL
	       #'DISPATCH-INTERNAL-1))
	   (INFORMATION (MAKE-INSTANCE-INFORMATION-INTERNAL
			  DISPATCH-TABLE
			  (DISPATCH-TABLE-MASK DISPATCH-TABLE)
			  (DISPATCH-TABLE-ADDRESS DISPATCH-TABLE))))
      (SETF (%CLASS-INFORMATION-FOR-TYPE SYS:DTP-LEXICAL-CLOSURE) INFORMATION)
      (SETF (%CLASS-INFORMATION-FOR-TYPE SYS:DTP-EXTENDED-NUMBER) INFORMATION)
      (SETF (%CLASS-INFORMATION-FOR-TYPE SYS:DTP-ARRAY) INFORMATION)))
  #+CLOE-Runtime
  (PROGN
    (DOLIST (X '((SYS::LO$K-CONS CONS) 
		 (SYS::LO$K-CHARACTER CHARACTER)
		 (SYS::LO$K-SYMBOL SYMBOL)
		 (SYS::LO$K-SHORT-FLOAT SINGLE-FLOAT)
		 (SYS::LO$K-FIXNUM FIXNUM)
		 (SYS::LO$K-ARRAY ARRAY)
		 (SYS::LO$K-FUNCTION SYS::SIMPLE-FUNCTION)
		 (SYS::LO$K-STRING STRING)
		 (SYS::LO$K-STRUCTURE T)
		 (SYS::LO$K-TRAMPOLINE SYS::TRAMPOLINE)
		 (SYS::LO$K-MARKER SYS::IMMOBJ)))
      (SETF (SVREF *OBJECT-TYPE-INSTANCE-INFORMATION* (SYMBOL-VALUE (FIRST X)))
	    (CLASS-INSTANCE-INFORMATION (FIND-CLASS (SECOND X)))))
    (FILL (THE SIMPLE-VECTOR *XNUM-TYPE-INSTANCE-INFORMATION*) (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'NUMBER)))
    (DOLIST (X '((SYS::LN$K-SHORT-FLOAT SINGLE-FLOAT)
		 (SYS::LN$K-RATIO RATIO)
		 (SYS::LN$K-FIXNUM FIXNUM)
		 (SYS::LN$K-BIGNUM BIGNUM)
		 (SYS::LN$K-COMPLEX COMPLEX)))
      (SETF (SVREF *XNUM-TYPE-INSTANCE-INFORMATION* (SYMBOL-VALUE (FIRST X)))
	    (CLASS-INSTANCE-INFORMATION (FIND-CLASS (SECOND X)))))
    (FILL (THE SIMPLE-VECTOR *VECTOR-AETYPE-INSTANCE-INFORMATION*) (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'VECTOR)))
    (DOLIST (X '((SYS::AETYPE$K-BIT BIT-VECTOR)
		 (SYS::AETYPE$K-SCHAR STRING)))
      (SETF (SVREF *VECTOR-AETYPE-INSTANCE-INFORMATION* (- (SYMBOL-VALUE (FIRST X)) SYS::AETYPE$K-OFFSET))
	    (CLASS-INSTANCE-INFORMATION (FIND-CLASS (SECOND X)))))
    (SETF *T-CLASS-INSTANCE-INFORMATION* (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'T))
	  *LEXICAL-CLOSURE-INSTANCE-INFORMATION* (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'SYS::LEXICAL-CLOSURE))
	  *NULL-INSTANCE-INFORMATION* (CLASS-INSTANCE-INFORMATION (FIND-CLASS 'NULL)))
    )
  #-(OR Genera CLOE-Runtime Minima) (NYI)

  ;; All the effective slot definitions are now computed.  For the important classes,
  ;; ensure that all their readers are set up.
  (DOLIST (CLASS-NAME '(STANDARD-METHOD STANDARD-READER-METHOD STANDARD-WRITER-METHOD
					#+(OR Genera Minima) STANDARD-LOCATOR-METHOD
					SHORT-FORM-METHOD-COMBINATION-DEFINITION
					LONG-FORM-METHOD-COMBINATION-DEFINITION
					STANDARD-METHOD-COMBINATION
					STANDARD-DIRECT-SLOT-DEFINITION
					STANDARD-EFFECTIVE-SLOT-DEFINITION
					STANDARD-CLASS FUNCALLABLE-STANDARD-CLASS
					STRUCTURE-CLASS
					STANDARD-METHOD-COMBINATION))
    (LET* ((CLASS (FIND-CLASS CLASS-NAME))
	   (CPL (%CLASS-INSTANCE-INFORMATION-PRECEDENCE-LIST
		  (CLASS-INSTANCE-INFORMATION CLASS)))
	   (ESDS (%CLASS-INSTANCE-INFORMATION-EFFECTIVE-SLOTS
		   (CLASS-INSTANCE-INFORMATION CLASS))))
      (DOLIST (S-CLASS CPL)
	(DOLIST (SLOT (CLASS-DIRECT-SLOTS S-CLASS))
	  (LET ((ESD (FIND (SLOT-DEFINITION-NAME SLOT) ESDS :KEY #'SLOT-DEFINITION-NAME)))
	    (WHEN ESD
	      (DOLIST (READER (SLOT-DEFINITION-READERS SLOT))
		(BOOTSTRAP-ADD-MAPPING
		  (FDEFINITION READER)
		  CLASS
		  #'STANDARD-CLASS-LOCAL-SLOT-READER
		  (SLOT-DEFINITION-LOCATION ESD)))))))))
  (LET* ((CLASS (FIND-CLASS 'STANDARD-GENERIC-FUNCTION))
	 (INFORMATION (CLASS-INSTANCE-INFORMATION CLASS))
	 (CPL (%CLASS-INSTANCE-INFORMATION-PRECEDENCE-LIST INFORMATION))
	 (ESDS (%CLASS-INSTANCE-INFORMATION-EFFECTIVE-SLOTS INFORMATION))
	 (HANDLER #'FUNCALLABLE-STANDARD-CLASS-SLOT-READER))
    (DOLIST (S-CLASS CPL)
      (DOLIST (SLOT (CLASS-DIRECT-SLOTS S-CLASS))
	(LET ((ESD (FIND (SLOT-DEFINITION-NAME SLOT) ESDS :KEY #'SLOT-DEFINITION-NAME)))
	  (WHEN ESD
	    (DOLIST (READER (SLOT-DEFINITION-READERS SLOT))
	      (BOOTSTRAP-ADD-MAPPING
		(FDEFINITION READER)
		CLASS
		HANDLER
		(SLOT-DEFINITION-LOCATION ESD))))))))
  (BOOTSTRAP-ADD-MAPPING
    #'MAKE-INSTANCE
    (FIND-CLASS 'SYMBOL)
    (BOOTSTRAP-METHOD-LAMBDA (CLASS &REST KEYS)
      (DECLARE (DYNAMIC-EXTENT KEYS))
      (APPLY #'MAKE-INSTANCE (FIND-CLASS CLASS) KEYS))
    NIL)
  (BOOTSTRAP-ADD-MAPPING
    #'MAKE-INSTANCE
    (FIND-CLASS 'STANDARD-CLASS)
    (BOOTSTRAP-METHOD-LAMBDA (CLASS &REST KEYS)
      (DECLARE (DYNAMIC-EXTENT KEYS))
      (LET ((CLASS-NAME (CLASS-NAME CLASS)))
	(ECASE CLASS-NAME
	  ((STANDARD-METHOD)
	   (APPLY #'BOOTSTRAP-MAKE-METHOD 'STANDARD-METHOD KEYS))
	  ((SHORT-FORM-METHOD-COMBINATION-DEFINITION
	    LONG-FORM-METHOD-COMBINATION-DEFINITION)
	   (APPLY #'BOOTSTRAP-MAKE-METHOD-COMBINATION-DEFINITION CLASS-NAME KEYS))
	  ((STANDARD-METHOD-COMBINATION)
	   (APPLY #'BOOTSTRAP-MAKE-METHOD-COMBINATION CLASS-NAME KEYS))
	  ((MISCELLANEOUS-FUNCTION)
	   (APPLY #'BOOTSTRAP-MAKE-MISCELLANEOUS-FUNCTION CLASS-NAME KEYS))
	  )))
    NIL)
  (BOOTSTRAP-ADD-MAPPING
    #'MAKE-INSTANCE
    (FIND-CLASS 'FUNCALLABLE-STANDARD-CLASS)
    (BOOTSTRAP-METHOD-LAMBDA (CLASS &REST KEYS
				    &KEY
				    ((FUNCTION-SPECIFIER FUNCTION-SPECIFIER))
				    ENVIRONMENT
				    &ALLOW-OTHER-KEYS)
      (DECLARE (DYNAMIC-EXTENT KEYS))
      (ECASE (CLASS-NAME CLASS)
	((STANDARD-GENERIC-FUNCTION)
	 (LET ((GENERIC (BOOTSTRAP-MAKE-GENERIC-FUNCTION ENVIRONMENT)))
	   (APPLY #'BOOTSTRAP-INITIALIZE-GENERIC-FUNCTION
		  GENERIC FUNCTION-SPECIFIER KEYS)
	   GENERIC))))
    NIL)
  (DOLIST (CLASS '(BUILT-IN-CLASS STANDARD-CLASS FUNCALLABLE-STANDARD-CLASS STRUCTURE-CLASS))
    (BOOTSTRAP-ADD-MAPPING
      #'CLASS-PRECEDENCE-LIST
      (FIND-CLASS CLASS)
      (BOOTSTRAP-METHOD-LAMBDA (CLASS)
	(%CLASS-INSTANCE-INFORMATION-PRECEDENCE-LIST (CLASS-INSTANCE-INFORMATION CLASS)))
      NIL))
  #+Genera
  (BOOTSTRAP-ADD-MAPPING
    #'FUNCTION-SPEC-OBJECT
    (FIND-CLASS 'STANDARD-METHOD)
    (BOOTSTRAP-METHOD-LAMBDA (METHOD)
      (BOOTSTRAP-SLOT-VALUE METHOD 'STANDARD-METHOD 'FUNCTION-PARENT))
    NIL)
  #+Genera
  (BOOTSTRAP-ADD-MAPPING
    #'FUNCTION-SPEC-OBJECT
    (FIND-CLASS 'STANDARD-READER-METHOD)
    (BOOTSTRAP-METHOD-LAMBDA (METHOD)
      (DECLARE (IGNORE METHOD)))
    NIL)
  #+Genera
  (BOOTSTRAP-ADD-MAPPING
    #'FUNCTION-SPEC-OBJECT
    (FIND-CLASS 'STANDARD-WRITER-METHOD)
    (BOOTSTRAP-METHOD-LAMBDA (METHOD)
      (DECLARE (IGNORE METHOD)))
    NIL)
  (BOOTSTRAP-ADD-MAPPING
    #'DISPATCHING-FUNCALLABLE-INSTANCE-FROM-SELECTOR
    (FIND-CLASS #+(OR Genera Minima) 'GENERIC-FUNCTION-SELECTOR
		#-(OR Genera Minima) 'STANDARD-GENERIC-FUNCTION)
    (BOOTSTRAP-METHOD-LAMBDA (SELECTOR)
      (FUNCALLABLE-INSTANCE-FROM-GENERIC-SELECTOR SELECTOR))
    NIL)
  #+Genera
  (BOOTSTRAP-ADD-MAPPING
    #'SEND-IF-HANDLES
    (FIND-CLASS 'STANDARD-METHOD)
    (BOOTSTRAP-METHOD-LAMBDA (METHOD MESSAGE &REST ARGUMENTS)
      (DECLARE (DYNAMIC-EXTENT ARGUMENTS))
      (WHEN (MEMBER MESSAGE '(:FUNCTION-SPEC-TYPE))
	(APPLY METHOD MESSAGE ARGUMENTS)))
    NIL)
  #+Genera
  (BOOTSTRAP-ADD-MAPPING
    #'FUNCTION-SPEC-TYPE
    (FIND-CLASS 'STANDARD-METHOD)
    (BOOTSTRAP-METHOD-LAMBDA (METHOD)
      (DECLARE (IGNORE METHOD))
      'INSTANCE-FUNCTION-NAME)
    NIL)
  #+CLOE-Runtime
  (BOOTSTRAP-ADD-MAPPING
    #'FUNCTION-SPEC-TYPE
    (FIND-CLASS 'STANDARD-METHOD)
    (BOOTSTRAP-METHOD-LAMBDA (METHOD)
      (DECLARE (IGNORE METHOD))
      #'INSTANCE-FUNCTION-NAME-HANDLER)
    NIL)
  #+Minima
  (BOOTSTRAP-ADD-MAPPING
    #'(LOCF FUNCTION-NAME-DEFINITION)
    (FIND-CLASS 'STANDARD-METHOD)
    (BOOTSTRAP-METHOD-LAMBDA (METHOD)
      (LOCF (BOOTSTRAP-SLOT-VALUE METHOD 'STANDARD-METHOD 'CELL)))
    NIL)
  #+Genera
  (OVERRIDE-GENERIC
    (GET 'INSTANCE-FUNCTION-NAME 'SI:FUNCTION-SPEC-HANDLER)
    (BOOTSTRAP-GENERIC-LAMBDA (FUNCTION FUNCTION-NAME &OPTIONAL ARG1 ARG2)
      (CASE FUNCTION
	(SI:FDEFINE
	  (SETF (BOOTSTRAP-SLOT-VALUE FUNCTION-NAME 'STANDARD-METHOD 'CELL) ARG1))
	(SI:COMPILER-FDEFINE NIL)
	(SI:FDEFINEDP NIL)
	(SI:COMPILER-FDEFINEDP NIL)
	(SI:FDEFINITION
	  (BOOTSTRAP-SLOT-VALUE FUNCTION-NAME 'STANDARD-METHOD 'CELL))
	(SI:FDEFINITION-LOCATION
	  (LOCF (BOOTSTRAP-SLOT-VALUE FUNCTION-NAME 'STANDARD-METHOD 'CELL)))
	(SI:DEFINITION-HAS-LOCATION-P T)
	(SI:FORWARD-FUNCTION-CELL-INTO-COMPILED-FUNCTION-P T)
	(SI:LOCATION-IS-FDEFINITION-LOCATION-P
	  (EQ ARG1 (LOCF (BOOTSTRAP-SLOT-VALUE
			       FUNCTION-NAME 'STANDARD-METHOD 'CELL))))
	(SI:FUNDEFINE (ERROR "Not handled"))
	(SI:FUNCTION-PARENT (ERROR "Not handled"))
	(SI:GET
	  (SI:FUNCTION-SPEC-GET
	    (BOOTSTRAP-SLOT-VALUE FUNCTION-NAME 'STANDARD-METHOD 'FUNCTION-PARENT) ARG1))
	(SI:PUTPROP
	  (SI:FUNCTION-SPEC-PUTPROP
	    (BOOTSTRAP-SLOT-VALUE FUNCTION-NAME 'STANDARD-METHOD 'FUNCTION-PARENT)
	    ARG1
	    ARG2))
	(SI:PLIST (ERROR "Not handled"))
	(SI:REMPROP (ERROR "Not handled"))
	(OTHERWISE
	  (SI:FUNCTION-SPEC-DEFAULT-HANDLER FUNCTION FUNCTION-NAME ARG1 ARG2)))))
  #+CLOE-Runtime
  (OVERRIDE-GENERIC
    #'INSTANCE-FUNCTION-NAME-HANDLER
    (BOOTSTRAP-GENERIC-LAMBDA (OP FUNCTION-NAME &OPTIONAL ARG1 ARG2)
      (ECASE OP
	(:DEFINITION
	  (BOOTSTRAP-SLOT-VALUE FUNCTION-NAME 'STANDARD-METHOD 'CELL))
	(:BOUNDP NIL)
	;(:MAKUNBOUND (FUNCTION-NAME-MAKUNBOUND FUNCTION-NAME))
	(:DEFINE
	  (SETF (BOOTSTRAP-SLOT-VALUE FUNCTION-NAME 'STANDARD-METHOD 'CELL) ARG1))
	;(:GET (FUNCTION-NAME-GET FUNCTION-NAME ARG1))
	;(:PUT (SETF (FUNCTION-NAME-GET FUNCTION-NAME ARG1) ARG2))
	(:FUNCTION-FORM `(FUNCTION-NAME-DEFINITION ',FUNCTION-NAME)))))
  ;; With some remodularization of the discrimination code, this could be an
  ;; add-mapping kind of thing.
  (OVERRIDE-GENERIC
    #'MAKE-METHOD-LAMBDA
    (BOOTSTRAP-GENERIC-LAMBDA (GENERIC METHOD LAMBDA &OPTIONAL ENVIRONMENT)
      GENERIC METHOD
      (MAKE-STANDARD-METHOD-LAMBDA LAMBDA ENVIRONMENT)))
  (OVERRIDE-GENERIC
    #'ADD-METHOD
    (BOOTSTRAP-GENERIC-LAMBDA (GENERIC METHOD)
      (BOOTSTRAP-ADD-METHOD GENERIC METHOD)))
  (OVERRIDE-GENERIC
    #'GENERIC-FUNCTION-EXPLICITLY-DEFINED-P
    (BOOTSTRAP-GENERIC-LAMBDA (GENERIC)
      (DECLARE (IGNORE GENERIC))
      T))
  )


(DEFUN BOOTSTRAP-METHOD-COMBINER (GENERIC-FUNCTION METHODS ARGUMENT-FUNCTION)
  (DECLARE (IGNORE GENERIC-FUNCTION ARGUMENT-FUNCTION))
;  (UNLESS (EQL (LENGTH METHODS) 1)
;    #+Genera
;    (PRINT (SYS:GENERIC-FUNCTION-NAME
;	     (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT GENERIC-FUNCTION)))
;    (ERROR "Wrong number of methods Bozo!"))
  (LET ((METHOD (FIRST METHODS)))
    (VALUES (METHOD-FUNCTION METHOD)
	    NIL)))

(DEFUN INITIALIZE-CLOS-4 ()
  (DECLARE (NOTINLINE MAKE-INSTANCE))
  (DOLIST (GENERIC *BOOTSTRAP-GENERICS*)
    (LET ((COMBINATION (BOOTSTRAP-FSLOT-VALUE GENERIC 'METHOD-COMBINATION)))
      (WHEN (CONSP COMBINATION)
	(SETF (BOOTSTRAP-FSLOT-VALUE GENERIC 'METHOD-COMBINATION)
	      (MAKE-INSTANCE 'STANDARD-METHOD-COMBINATION
			     :TYPE (FIND-METHOD-COMBINATION-DEFINITION (CAR COMBINATION))
			     :OPTIONS (CDR COMBINATION))))))
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'COMPUTE-EFFECTIVE-METHOD
    (MAPCAR #'FIND-CLASS '(STANDARD-GENERIC-FUNCTION
			    STANDARD-METHOD-COMBINATION
			    T))
    #'BOOTSTRAP-METHOD-COMBINER)
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'COMPUTE-EFFECTIVE-METHOD-1
    (MAPCAR #'FIND-CLASS '(STANDARD-GENERIC-FUNCTION
			   T
			   T))
    #'BOOTSTRAP-METHOD-COMBINER)
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'GENERIC-FUNCTION-CALL-FORM
    (LIST (FIND-CLASS 'STANDARD-GENERIC-FUNCTION)
	  (FIND-CLASS T)
	  (FIND-CLASS T)
	  (FIND-CLASS T))
    #'BOOTSTRAP-METHOD-COMBINER)
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'GENERIC-FUNCTION-MAKE-LAMBDA
    (LIST (FIND-CLASS 'STANDARD-GENERIC-FUNCTION)
	  (FIND-CLASS T)
	  (FIND-CLASS T)
	  (FIND-CLASS T))
    #'BOOTSTRAP-METHOD-COMBINER)
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'METHOD-COMBINATION-ARGUMENTS-LAMBDA-LIST
    (LIST (FIND-CLASS 'STANDARD-METHOD-COMBINATION))
    #'BOOTSTRAP-METHOD-COMBINER)
  (LOOP FOR METHOD IN '(STANDARD-METHOD
			 STANDARD-READER-METHOD
			 STANDARD-WRITER-METHOD
			 #+(OR Genera Minima) STANDARD-LOCATOR-METHOD
			 CONS)
	DOING
    (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
      #'METHOD-FUNCTION-NAME-AND-EXTRA-ARGUMENT
      (LIST (FIND-CLASS 'STANDARD-GENERIC-FUNCTION)
	    (FIND-CLASS METHOD)
	    (FIND-CLASS T)
	    (FIND-CLASS T))
      #'BOOTSTRAP-METHOD-COMBINER))
  (LOOP FOR CLASS IN '(STANDARD-CLASS FUNCALLABLE-STANDARD-CLASS)
	DOING
    (LOOP FOR METHOD IN '(STANDARD-READER-METHOD
			  STANDARD-WRITER-METHOD
			  #+(OR Genera Minima) STANDARD-LOCATOR-METHOD)
	  DOING
      (LOOP FOR LOCATION IN '(FIXNUM #+(OR Genera Minima) LOCATIVE #-(OR Genera Minima) CONS)
	    DOING
	(GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
	  #'SLOT-ACCESSOR-NAME-AND-EXTRA-ARGUMENT-USING-CLASS
	  (LIST (FIND-CLASS 'STANDARD-GENERIC-FUNCTION)
		(FIND-CLASS METHOD)
		(FIND-CLASS CLASS)
		(FIND-CLASS LOCATION))
	  #'BOOTSTRAP-METHOD-COMBINER))))
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'METHOD-MAPPING-TABLE
    (MAPCAR #'FIND-CLASS '(STANDARD-METHOD T))
    #'BOOTSTRAP-METHOD-COMBINER)
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'CLASS-SLOTS
    (LIST (FIND-CLASS 'STANDARD-CLASS))
    #'BOOTSTRAP-METHOD-COMBINER)
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'CLASS-SLOTS
    (LIST (FIND-CLASS 'FUNCALLABLE-STANDARD-CLASS))
    #'BOOTSTRAP-METHOD-COMBINER)
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'METHOD-COMBINATION-DEFINITION-NAME
    (LIST (FIND-CLASS 'STANDARD-METHOD-COMBINATION))
    #'BOOTSTRAP-METHOD-COMBINER)
  #+CLOE-Runtime
  (DOLIST (OP '(:DEFINITION :BOUNDP :MAKUNBOUND :DEFINE :GET))
    (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
      #'INSTANCE-FUNCTION-NAME-HANDLER
      (LIST `(EQL ,OP) (FIND-CLASS 'STANDARD-METHOD))
      #'BOOTSTRAP-METHOD-COMBINER))
  #+Genera
  (PROGN
    (DOLIST (OP '(SI:FDEFINE SI:COMPILER-FDEFINE SI:FDEFINEDP SI:COMPILER-FDEFINEDP
			     SI:FDEFINITION SI:FDEFINITION-LOCATION
			     SI:DEFINITION-HAS-LOCATION-P SI:FUNDEFINE SI:FUNCTION-PARENT
			     SI:LOCATION-IS-FDEFINITION-LOCATION-P
			     SI:FORWARD-FUNCTION-CELL-INTO-COMPILED-FUNCTION-P
			     SI:GET SI:PUTPROP SI:PLIST SI:REMPROP))
      (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
	(GET 'INSTANCE-FUNCTION-NAME 'SI:FUNCTION-SPEC-HANDLER)
	(LIST `(EQL ,OP) (FIND-CLASS 'STANDARD-METHOD))
	#'BOOTSTRAP-METHOD-COMBINER))
    (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
      (GET 'INSTANCE-FUNCTION-NAME 'SI:FUNCTION-SPEC-HANDLER)
      (LIST (FIND-CLASS 'SYMBOL) (FIND-CLASS 'STANDARD-METHOD))
      #'BOOTSTRAP-METHOD-COMBINER))
  (BOOTSTRAP-ADD-MAPPING
    #'FUNCTION-NAME-DEFINITION
    (FIND-CLASS 'STANDARD-METHOD)
    (BOOTSTRAP-METHOD-LAMBDA (METHOD)
      (METHOD-FUNCTION METHOD))
    NIL)
  (REVERT-GENERIC #'MAKE-METHOD-LAMBDA)
  (REVERT-GENERIC #'ADD-METHOD)
  (REVERT-GENERIC #'GENERIC-FUNCTION-EXPLICITLY-DEFINED-P)
  (REVERT-GENERIC #'LAMBDA-LIST-CONGRUENT-P)
  (REVERT-GENERIC #'ENSURE-GENERIC-FUNCTION-USING-CLASS)
  (REVERT-GENERIC #'ENSURE-CLASS-USING-CLASS)
  (REVERT-GENERIC #'FIND-METHOD-COMBINATION)
  (REVERT-GENERIC #'GENERIC-FUNCTION-NAME)
  (REVERT-GENERIC #'CLASS-PROTOTYPE)
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'GENERIC-FUNCTION-EXPLICITLY-DEFINED-P
    (MAPCAR #'FIND-CLASS '(STANDARD-GENERIC-FUNCTION))
    #'STANDARD-METHOD-COMBINER)
  #+Genera
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'OPERATION-HANDLED-P
    (MAPCAR #'FIND-CLASS '(STANDARD-METHOD T))
    #'STANDARD-METHOD-COMBINER)
  #+Genera
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'DISPATCHING-FUNCALLABLE-INSTANCE-FROM-SELECTOR
    (MAPCAR #'FIND-CLASS '(SYMBOL))
    #'STANDARD-METHOD-COMBINER)
  #+(OR Genera Minima)
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'DISPATCHING-FUNCALLABLE-INSTANCE-FROM-SELECTOR
    (MAPCAR #'FIND-CLASS '(GENERIC-FUNCTION-SELECTOR))
    #'STANDARD-METHOD-COMBINER)
  #-(OR Genera Minima)
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'DISPATCHING-FUNCALLABLE-INSTANCE-FROM-SELECTOR
    (MAPCAR #'FIND-CLASS '(STANDARD-GENERIC-FUNCTION))
    #'STANDARD-METHOD-COMBINER)
  #+Genera
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'SEND-IF-HANDLES
    (MAPCAR #'FIND-CLASS '(STANDARD-METHOD T))
    #'STANDARD-METHOD-COMBINER)
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'FUNCTION-NAME-DEFINITION
    (MAPCAR #'FIND-CLASS '(STANDARD-METHOD))
    #'STANDARD-METHOD-COMBINER)
  #+(OR Genera CLOE-Runtime)
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'FUNCTION-SPEC-TYPE
    (MAPCAR #'FIND-CLASS '(STANDARD-METHOD))
    #'STANDARD-METHOD-COMBINER)
  #+Genera
  (PROGN
    (DOLIST (OP '(SI:FDEFINE SI:COMPILER-FDEFINE SI:FDEFINEDP SI:COMPILER-FDEFINEDP
			     SI:FDEFINITION SI:FDEFINITION-LOCATION
			     SI:DEFINITION-HAS-LOCATION-P SI:FUNDEFINE SI:FUNCTION-PARENT
			     SI:LOCATION-IS-FDEFINITION-LOCATION-P
			     SI:FORWARD-FUNCTION-CELL-INTO-COMPILED-FUNCTION-P
			     SI:GET SI:PUTPROP SI:PLIST SI:REMPROP))
      (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
	(GET 'INSTANCE-FUNCTION-NAME 'SI:FUNCTION-SPEC-HANDLER)
	(LIST `(EQL ,OP) (FIND-CLASS 'STANDARD-METHOD))
	#'STANDARD-METHOD-COMBINER))
    (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
      (GET 'INSTANCE-FUNCTION-NAME 'SI:FUNCTION-SPEC-HANDLER)
      (LIST (FIND-CLASS 'SYMBOL) (FIND-CLASS 'STANDARD-METHOD))
      #'STANDARD-METHOD-COMBINER))
  #+CLOE-Runtime
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'INSTANCE-FUNCTION-NAME-HANDLER
    (MAPCAR #'FIND-CLASS '(SYMBOL STANDARD-METHOD))
    #'STANDARD-METHOD-COMBINER)
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'(SETF DISPATCHING-FUNCALLABLE-INSTANCE-TABLE)
    (MAPCAR #'FIND-CLASS '(T STANDARD-GENERIC-FUNCTION))
    #'STANDARD-METHOD-COMBINER)
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'(SETF PROPERTY-LIST-OBJECT)
    (MAPCAR #'FIND-CLASS '(T STANDARD-METHOD))
    #'STANDARD-METHOD-COMBINER)
  )

(DEFUN INITIALIZE-CLOS-5 ()
  (LET ((STANDARD-CLASS (FIND-CLASS 'STANDARD-CLASS)))
    (DOLIST (CLASS *BOOTSTRAP-CLASSES*)
      (WHEN (AND (EQ CLASS (FIND-CLASS (CLASS-NAME CLASS)))
		 (MEMBER STANDARD-CLASS (CLASS-PRECEDENCE-LIST (CLASS-OF CLASS))))
	(SETF (SLOT-VALUE CLASS 'DEFAULT-INITARGS) (COMPUTE-DEFAULT-INITARGS CLASS))
	(SETF (SLOT-VALUE CLASS 'PROTOTYPE) (COMPUTE-PROTOTYPE CLASS))
	(SETF (LDB %%STANDARD-CLASS-FINALIZED-P (SLOT-VALUE CLASS 'BITS)) -1)))))

(DEFUN INITIALIZE-CLOS-6 ()
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'INITIALIZE-INSTANCE
    (LIST (FIND-CLASS 'MISCELLANEOUS-FUNCTION))
    #'STANDARD-METHOD-COMBINER)
  (GENERIC-FUNCTION-ENSURE-SPECIALIZERS-MAPPED
    #'INITIALIZE-INSTANCE
    (LIST (FIND-CLASS 'POSITIONAL-CONSTRUCTOR))
    #'STANDARD-METHOD-COMBINER))

(DEFUN INITIALIZE-CLOS-7 ()
  (DOLIST (GENERIC *SPECIALLY-MAPPED-GENERICS*)
    (UPDATE-DISPATCHES GENERIC #'STANDARD-METHOD-COMBINER T))
  (DOLIST (GENERIC *OVERRIDDEN-GENERICS*)
    (UPDATE-DISPATCHES GENERIC #'STANDARD-METHOD-COMBINER T))
  (DOLIST (CLASS *BOOTSTRAP-CLASSES*)
    (WHEN (EQ CLASS (FIND-CLASS (CLASS-NAME CLASS)))
      (NOTICE-CLASS-NAME-CHANGE CLASS)
      (WHEN (TYPEP-CLASS CLASS (FIND-CLASS 'STANDARD-CLASS))
	(FINALIZE-INHERITANCE CLASS))))
  (SETQ *BOOTSTRAP-CLASSES* NIL)
  (SETQ *BOOTSTRAP-GENERICS* NIL)
  (SETQ *OVERRIDDEN-GENERICS* NIL)
  (SETQ *SPECIALLY-MAPPED-GENERICS* NIL)
  (SETQ *CLOS-INITIALIZED-P* T))

(INITIALIZE-CLOS-1)

;(DEFUN REINITIALIZE-CLOS ()
;  (INITIALIZE-CLOS-1)
;  (LOAD "sys:clos;generics")
;  (LOAD "sys:clos;metaclasses")
;  (LOAD "sys:clos;method-combination")
;  (LOAD "sys:clos;basic-methods")
;  (LOAD "sys:clos;methods")
;  (LOAD "sys:clos;slots")
;  (LOAD "sys:clos;basic-class")
;  (LOAD "sys:clos;class")
;)


