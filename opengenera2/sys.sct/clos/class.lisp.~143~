;;; -*- Mode: LISP; Syntax: ANSI-Common-Lisp; Base: 10; Package: CLOS-INTERNALS -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(IN-PACKAGE :CLOS-INTERNALS)

(DEFMETHOD ENSURE-CLASS-USING-CLASS
	   ((CLASS NULL) NAME &REST KEYS
	    &KEY
	    (METACLASS NIL METACLASS-P)
	    ENVIRONMENT
	    (DIRECT-SUPERCLASSES NIL DIRECT-SUPERCLASSES-P)
	    &ALLOW-OTHER-KEYS)
  (DECLARE (DYNAMIC-EXTENT KEYS))
  (LET ((METACLASS
	  (COND ((NULL METACLASS-P)
		 (SETQ METACLASS (FIND-CLASS 'STANDARD-CLASS)))
		((TYPEP METACLASS 'SYMBOL)
		 (FIND-CLASS METACLASS))
		(T METACLASS))))
    (WITH-CLOS-LOCK
      (LET ((DIRECT-SUPERCLASSES
	      (MAPCAR #'(LAMBDA (CLASS)
			  (IF (TYPEP CLASS 'SYMBOL)
			      (FIND-CLASS-OR-FORWARD-REFERENCE CLASS ENVIRONMENT NIL)
			      CLASS))
		      DIRECT-SUPERCLASSES)))
	(WITH-CLASS-UPDATES
	  (LET* ((NEW-KEYS (REMOVE-KEYWORDS KEYS :METACLASS :DIRECT-SUPERCLASSES))
		 (CLASS
		   (IF DIRECT-SUPERCLASSES-P
		       (APPLY #'MAKE-INSTANCE
			      METACLASS
			      :DIRECT-SUPERCLASSES DIRECT-SUPERCLASSES
			      'NAME NAME
			      NEW-KEYS)
		       (APPLY #'MAKE-INSTANCE
			      METACLASS
			      'NAME NAME
			      NEW-KEYS))))
	    (SETF (FIND-CLASS NAME NIL ENVIRONMENT) CLASS)
	    #+Genera
	    (UNLESS (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
	      (NOTE-CLASS-INITIALIZATION-FUNCTIONS CLASS)
	      (NOTE-CLASS-CHANGE-FOR-DW CLASS))
	    CLASS))))))

(DEFMETHOD ENSURE-CLASS-USING-CLASS
	   ((CLASS CLASS) NAME &REST KEYS
	    &KEY
	    (METACLASS NIL METACLASS-P)
	    ENVIRONMENT
	    (DIRECT-SUPERCLASSES NIL DIRECT-SUPERCLASSES-P)
	    &ALLOW-OTHER-KEYS)
  (DECLARE (DYNAMIC-EXTENT KEYS))
  (LET ((METACLASS
	  (COND ((NULL METACLASS-P)
		 (SETQ METACLASS (FIND-CLASS 'STANDARD-CLASS)))
		((TYPEP METACLASS 'SYMBOL)
		 (FIND-CLASS METACLASS))
		(T METACLASS))))
    (WITH-CLOS-LOCK
      (LET ((DIRECT-SUPERCLASSES
	      (MAPCAR #'(LAMBDA (CLASS)
			  (IF (TYPEP CLASS 'SYMBOL)
			      (FIND-CLASS-OR-FORWARD-REFERENCE CLASS ENVIRONMENT NIL)
			      CLASS))
		      DIRECT-SUPERCLASSES)))
	(WHEN (NOT (EQ METACLASS (CLASS-OF CLASS)))
	  ;; Make sure the subclasses aren't going to get upset about this
	  (LET ((OBJECTING-SUBCLASSES
		  (LOOP WITH PROTOTYPE = (CLASS-PROTOTYPE METACLASS)
			FOR CLASS IN (CLASS-DIRECT-SUBCLASSES CLASS)
			UNLESS (VALIDATE-SUPERCLASS CLASS PROTOTYPE)
			  COLLECT CLASS)))
	    (WHEN OBJECTING-SUBCLASSES
	      (ERROR
		"The class ~a can not be defined with metaclass ~a because this~@
               would make it an invalid superclass for the~@
               direct subclass~:[~;es~]~?."
		CLASS
		METACLASS
		(CDR OBJECTING-SUBCLASSES)
		*AND-~A-FORMAT-STRING*
		OBJECTING-SUBCLASSES))
	    (CHANGE-CLASS CLASS METACLASS)))
	(WITH-CLASS-UPDATES
	  (LET ((NEW-KEYS (REMOVE-KEYWORDS KEYS :METACLASS :DIRECT-SUPERCLASSES)))
	    (IF DIRECT-SUPERCLASSES-P
		(APPLY #'REINITIALIZE-INSTANCE
		       CLASS
		       :DIRECT-SUPERCLASSES DIRECT-SUPERCLASSES
		       'NAME NAME
		       NEW-KEYS)
		(APPLY #'REINITIALIZE-INSTANCE
		       CLASS
		       'NAME NAME
		       NEW-KEYS))))
	#+Genera
	(UNLESS (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
	  (NOTE-CLASS-INITIALIZATION-FUNCTIONS CLASS)
	  (NOTE-CLASS-CHANGE-FOR-DW CLASS))
	CLASS))))

#+Genera
(DEFMETHOD ENSURE-CLASS-USING-CLASS :AROUND (CLASS NAME
					     &KEY ENVIRONMENT METACLASS &ALLOW-OTHER-KEYS)
  (DECLARE (IGNORE CLASS))
  (WITH-PENDING-DW-UPDATES
    (WHEN (OR (NULL NAME)
	      (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
	      (IF (SYMBOLP METACLASS)
		  (EQ METACLASS 'FORWARD-REFERENCED-CLASS)
		  (EQ METACLASS (FIND-CLASS 'FORWARD-REFERENCED-CLASS)))
	      (AND (SYS:RECORD-DEFINITION-SOURCE-FILE
		     NAME 'DEFCLASS :START-TYPE-DEFINITION NIL)
		   (SYS:RECORD-DEFINITION-SOURCE-FILE
		     NAME 'CLI::DEFTYPE :START-TYPE-DEFINITION NIL)))
      (CALL-NEXT-METHOD))))

(DEFMETHOD UPDATE-INSTANCE-FOR-REDEFINED-CLASS
	   ((INSTANCE STANDARD-OBJECT)
	    ADDED-SLOTS
	    DISCARDED-SLOTS
	    PROPERTY-LIST
	    &REST INITARGS)
  (DECLARE (DYNAMIC-EXTENT INITARGS))
  ;; Check the keywords
  (BLOCK CHECK-KEYWORDS
    (LET ((KEYWORDS NIL))
      (DOLIST (METHOD (COMPUTE-APPLICABLE-METHODS
			*UPDATE-INSTANCE-FOR-REDEFINED-CLASS*
			(LIST INSTANCE ADDED-SLOTS DISCARDED-SLOTS PROPERTY-LIST)))
	(MULTIPLE-VALUE-BIND (KEYS ALLOW-OTHER-KEYS-P)
	    (FUNCTION-KEYWORDS METHOD)
	  (WHEN ALLOW-OTHER-KEYS-P
	    (RETURN-FROM CHECK-KEYWORDS))
	  (DOLIST (KEYWORD KEYS)
	    (PUSHNEW KEYWORD KEYWORDS))))
      (DOLIST (METHOD (COMPUTE-APPLICABLE-METHODS
			*SHARED-INITIALIZE*
			(LIST INSTANCE ADDED-SLOTS)))
	(MULTIPLE-VALUE-BIND (KEYS ALLOW-OTHER-KEYS-P)
	    (FUNCTION-KEYWORDS METHOD)
	  (WHEN ALLOW-OTHER-KEYS-P
	    (RETURN-FROM CHECK-KEYWORDS))
	  (DOLIST (KEYWORD KEYS)
	    (PUSHNEW KEYWORD KEYWORDS))))
      (DOLIST (SLOT (CLASS-SLOTS (CLASS-OF INSTANCE)))
	(DOLIST (KEYWORD (SLOT-DEFINITION-INITARGS SLOT))
	  (PUSHNEW KEYWORD KEYWORDS)))
      (VALIDATE-KEYWORDS-INTERNAL KEYWORDS INITARGS)))
  (APPLY #'SHARED-INITIALIZE INSTANCE ADDED-SLOTS
	 'INITIALIZATION-TYPE 'REDEFINED-CLASS
	 INITARGS))

(DEFMETHOD MAKE-INSTANCES-OBSOLETE ((CLASS SYMBOL))
  (MAKE-INSTANCES-OBSOLETE (FIND-CLASS CLASS)))

(DEFMETHOD MAKE-INSTANCES-OBSOLETE ((CLASS STANDARD-CLASS))
  (WITH-CLOS-LOCK
    (LET* ((OLD-INFORMATION (CLASS-INSTANCE-INFORMATION CLASS))
	   (NEW-INFORMATION (COPY-CLASS-INSTANCE-INFORMATION OLD-INFORMATION)))
      (SETF (SLOT-VALUE CLASS 'INSTANCE-INFORMATION) NEW-INFORMATION)
      (SETF (%INSTANCE-INFORMATION-DISPATCH-TABLE OLD-INFORMATION)
	    (COPY-DISPATCH-TABLE (%INSTANCE-INFORMATION-DISPATCH-TABLE OLD-INFORMATION)))
      (UNLESS (EQ CLASS *FINALIZING-CLASS*)
	;; FINALIZE-INHERITANCE has called us, so don't bother computing a prototype
	;; and ensuring instances get updated until FINALIZE-INHERITANCE has
	;; finished.
	(SETF (SLOT-VALUE CLASS 'PROTOTYPE) (COMPUTE-PROTOTYPE CLASS))
	(ENSURE-EXISTING-INSTANCES-WILL-GET-UPDATED CLASS OLD-INFORMATION))
      CLASS)))

(DEFMETHOD CLASS-OBSOLETE-DISPATCH-TABLE ((CLASS STANDARD-CLASS))
  *STANDARD-CLASS-UPDATE-DISPATCH-TABLE*)

(DEFMETHOD CLASS-OBSOLETE-DISPATCH-TABLE ((CLASS FUNCALLABLE-STANDARD-CLASS))
  *FUNCALLABLE-STANDARD-CLASS-UPDATE-DISPATCH-TABLE*)

(DEFMETHOD UPDATE-INSTANCE-USING-CLASS ((CLASS STANDARD-CLASS) INSTANCE &REST INITARGS
					&KEY &ALLOW-OTHER-KEYS)
  (DECLARE (DYNAMIC-EXTENT INITARGS))
  (APPLY #'UPDATE-STANDARD-CLASS-INSTANCE INSTANCE INITARGS))

(DEFMETHOD UPDATE-INSTANCE-USING-CLASS ((CLASS FUNCALLABLE-STANDARD-CLASS) INSTANCE
					&REST INITARGS
					&KEY &ALLOW-OTHER-KEYS)
  (DECLARE (DYNAMIC-EXTENT INITARGS))
  (APPLY #'UPDATE-FUNCALLABLE-STANDARD-CLASS-INSTANCE INSTANCE INITARGS))

(DEFMETHOD UPDATE-INSTANCE-USING-CLASS ((CLASS STRUCTURE-CLASS) INSTANCE &REST INITARGS
					&KEY &ALLOW-OTHER-KEYS)
  (DECLARE (IGNORE INSTANCE INITARGS))
  NIL)

#+Genera
(DEFMETHOD UPDATE-INSTANCE-USING-CLASS ((CLASS FLAVOR-CLASS) INSTANCE
					&REST INITARGS
					&KEY &ALLOW-OTHER-KEYS)
  (DECLARE (IGNORE INITARGS))
  (FLAVOR:TRANSFORM-INSTANCE INSTANCE (FLAVOR:FIND-FLAVOR (CLASS-NAME CLASS))))

(DEFMETHOD CHANGE-CLASS ((INSTANCE T) (NEW-CLASS SYMBOL))
  (CHANGE-CLASS INSTANCE (FIND-CLASS NEW-CLASS)))

(DEFMETHOD CHANGE-CLASS :BEFORE ((INSTANCE STANDARD-OBJECT) (NEW-CLASS CLASS))
  (LET ((OLD-CLASS (CLASS-OF INSTANCE)))
    (UNLESS (VALIDATE-METACLASS-CHANGE OLD-CLASS NEW-CLASS)
      (ERROR "Changing the class of an object of class ~s to class ~s is not allowed"
	     OLD-CLASS NEW-CLASS))))

(DEFMETHOD CHANGE-CLASS :BEFORE ((CLASS CLASS) (NEW-METACLASS STANDARD-CLASS))
  (UNLESS (VALIDATE-METACLASS-CHANGE CLASS (CLASS-PROTOTYPE NEW-METACLASS))
    (ERROR "Changing the class of an object of class ~A to class ~A is not allowed."
	   (CLASS-OF CLASS) NEW-METACLASS)))

(DEFMETHOD CHANGE-CLASS ((INSTANCE STANDARD-OBJECT) (NEW-CLASS STANDARD-CLASS))
  (UNLESS (CLASS-FINALIZED-P NEW-CLASS) (FINALIZE-INHERITANCE NEW-CLASS))
  (LET* ((OLD-CLASS (CLASS-OF INSTANCE))
	 (COPY-INSTANCE (COPY-INSTANCE-USING-CLASS OLD-CLASS INSTANCE)))
    (CHANGE-CLASS-INTERNAL
      INSTANCE (CLASS-SLOTS OLD-CLASS)
      (ALLOCATE-INSTANCE NEW-CLASS) (CLASS-SLOTS NEW-CLASS))
    (RECOMBINE-METHODS OLD-CLASS T NIL)
    (CHANGE-EQL-DISPATCHES INSTANCE)
    (UPDATE-INSTANCE-FOR-DIFFERENT-CLASS COPY-INSTANCE INSTANCE)
    INSTANCE))

(DEFMETHOD CHANGE-CLASS ((INSTANCE FUNCALLABLE-INSTANCE)
			 (NEW-CLASS FUNCALLABLE-STANDARD-CLASS))
  (UNLESS (CLASS-FINALIZED-P NEW-CLASS) (FINALIZE-INHERITANCE NEW-CLASS))
  (LET* ((OLD-CLASS (CLASS-OF INSTANCE))
	 (COPY-INSTANCE (COPY-INSTANCE-USING-CLASS OLD-CLASS INSTANCE)))
    (CHANGE-CLASS-INTERNAL
      (%DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT
	(%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT INSTANCE))
      (CLASS-SLOTS OLD-CLASS)
      (%DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT
	(%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT (ALLOCATE-INSTANCE NEW-CLASS)))
      (CLASS-SLOTS NEW-CLASS))
    (RECOMBINE-METHODS OLD-CLASS T NIL)
    (CHANGE-EQL-DISPATCHES INSTANCE)
    (UPDATE-INSTANCE-FOR-DIFFERENT-CLASS COPY-INSTANCE INSTANCE)
    INSTANCE))

(DEFMETHOD UPDATE-INSTANCE-FOR-DIFFERENT-CLASS ((PREVIOUS STANDARD-OBJECT)
						(CURRENT STANDARD-OBJECT)
						&REST INITARGS)
  (DECLARE (DYNAMIC-EXTENT INITARGS))
  (WHEN INITARGS
    (BLOCK CHECK-KEYWORDS
      (LET ((KEYWORDS NIL))
	(DOLIST (METHOD (COMPUTE-APPLICABLE-METHODS
			  *UPDATE-INSTANCE-FOR-DIFFERENT-CLASS*
			  (LIST PREVIOUS CURRENT)))
	  (MULTIPLE-VALUE-BIND (KEYS ALLOW-OTHER-KEYS-P)
	      (FUNCTION-KEYWORDS METHOD)
	    (WHEN ALLOW-OTHER-KEYS-P
	      (RETURN-FROM CHECK-KEYWORDS))
	    (DOLIST (KEYWORD KEYS)
	      (PUSHNEW KEYWORD KEYWORDS))))
	(DOLIST (METHOD (COMPUTE-APPLICABLE-METHODS
			  *SHARED-INITIALIZE*
			  (LIST CURRENT NIL)))
	  (MULTIPLE-VALUE-BIND (KEYS ALLOW-OTHER-KEYS-P)
	      (FUNCTION-KEYWORDS METHOD)
	    (WHEN ALLOW-OTHER-KEYS-P
	      (RETURN-FROM CHECK-KEYWORDS))
	    (DOLIST (KEYWORD KEYS)
	      (PUSHNEW KEYWORD KEYWORDS))))
	(DOLIST (SLOT (CLASS-SLOTS (CLASS-OF CURRENT)))
	  (DOLIST (KEYWORD (SLOT-DEFINITION-INITARGS SLOT))
	    (PUSHNEW KEYWORD KEYWORDS)))
	;; Ideally we would store this information someplace, but we can't do that until
	;; we know when it becomes invalid
	(VALIDATE-KEYWORDS-INTERNAL KEYWORDS INITARGS))))
  ;; Determine the list of new slots
  (LET ((NEW-SLOTS NIL))
    (LOOP WITH OLD-SLOTS = (CLASS-SLOTS (CLASS-OF PREVIOUS))
	  FOR NEW-SLOT IN (CLASS-SLOTS (CLASS-OF CURRENT))
	  FOR NAME = (SLOT-DEFINITION-NAME NEW-SLOT)
	  DOING
      (WHEN (OR (EQ (SLOT-DEFINITION-ALLOCATION NEW-SLOT) ':INSTANCE)
		(NULL (FIND NAME OLD-SLOTS :KEY #'SLOT-DEFINITION-NAME)))
	(PUSH NAME NEW-SLOTS)))
    (APPLY #'SHARED-INITIALIZE CURRENT NEW-SLOTS
	   'INITIALIZATION-TYPE 'DIFFERENT-CLASS
	   INITARGS)))

(DEFMETHOD VALIDATE-METACLASS-CHANGE ((CLASS CLASS)
				      (PROTOTYPE-OF-NEW-CLASS CLASS))
  NIL)

(DEFMETHOD VALIDATE-METACLASS-CHANGE ((CLASS FORWARD-REFERENCED-CLASS)
				      (PROTOTYPE-OF-NEW-CLASS CLASS))
  T)

(DEFMETHOD VALIDATE-METACLASS-CHANGE ((CLASS STANDARD-CLASS)
				      (PROTOTYPE-OF-NEW-CLASS STANDARD-CLASS))
  T)

(DEFMETHOD VALIDATE-METACLASS-CHANGE ((CLASS STRUCTURE-CLASS)
				      (PROTOTYPE-OF-NEW-CLASS STRUCTURE-CLASS))
  T)

;;; The only valid metaclass changes are FORWARD-REFERENCED-CLASS to FLAVOR-CLASS
;;; and FLAVOR-CLASS to FLAVOR-CLASS
#+Genera
(DEFMETHOD VALIDATE-METACLASS-CHANGE ((CLASS FLAVOR-CLASS)
				      (PROTOTYPE-OF-NEW-CLASS FLAVOR-CLASS))
  T)

#+Genera
(DEFMETHOD VALIDATE-METACLASS-CHANGE ((CLASS FLAVOR-CLASS)
				      (PROTOTYPE-OF-NEW-CLASS FORWARD-REFERENCED-CLASS))
  T)

(DEFMETHOD MAKE-INSTANCE ((CLASS STANDARD-CLASS) &REST INITARGS)
  (DECLARE (DYNAMIC-EXTENT INITARGS))
  (APPLY (CONSTRUCTOR-FDEFINITION (SLOT-VALUE CLASS 'KEYWORD-CONSTRUCTOR)) INITARGS))

(DEFMETHOD MAKE-INSTANCE ((CLASS SYMBOL) &REST INITARGS)
  (DECLARE (DYNAMIC-EXTENT INITARGS))
  (APPLY #'MAKE-INSTANCE (FIND-CLASS CLASS) INITARGS))

;;; This seems like a better idea than signalling NO-APPLICABLE-METHOD
#+Genera
(DEFMETHOD MAKE-INSTANCE ((CLASS FLAVOR-CLASS) &REST INITARGS)
  (DECLARE (DYNAMIC-EXTENT INITARGS))
  (APPLY #'FLAVOR:MAKE-INSTANCE (SLOT-VALUE CLASS 'NAME) INITARGS))

#+Genera
(DEFMACRO WITH-STACK-INSTANCE ((VAR CLASS &REST MAKE-INSTANCE-KEYWORDS) &BODY BODY
			       &ENVIRONMENT ENVIRONMENT)
  (LOOP FOR (MAKE-INSTANCE-KEYWORD VALUE) ON MAKE-INSTANCE-KEYWORDS BY #'CDDR
	AS KEYWORD = (AND (CONSTANTP MAKE-INSTANCE-KEYWORD ENVIRONMENT)
			  (LT:EVALUATE-CONSTANT MAKE-INSTANCE-KEYWORD ENVIRONMENT))
	WHEN (EQL KEYWORD 'CLOS-INTERNALS:STORAGE-AREA)
	  DO (ERROR "You tried to specify an area for a stack-allocated instance: ~S ~S"
		    MAKE-INSTANCE-KEYWORD VALUE))
  `(SYS:WITH-DATA-STACK
     (LET ((,VAR (MAKE-INSTANCE ,CLASS 'CLOS-INTERNALS:STORAGE-AREA ':STACK
				,@MAKE-INSTANCE-KEYWORDS)))
       ,@BODY)))

(DEFMETHOD MAKE-LOAD-FORM-SAVING-SLOTS ((OBJECT STANDARD-OBJECT) &OPTIONAL (SAVE-SLOTS NIL SAVE-SLOTS-P))
  (LET ((CLASS (CLASS-OF OBJECT)))
    ;;; Argument defaulting:
    (UNLESS SAVE-SLOTS-P
      (DOLIST (SLOT (CLASS-SLOTS CLASS))
	(WHEN (EQ (SLOT-DEFINITION-ALLOCATION SLOT) :INSTANCE)
	  (PUSH (SLOT-DEFINITION-NAME SLOT) SAVE-SLOTS))))
    (VALUES
      `(ALLOCATE-INSTANCE ',CLASS)
      `(PROGN ,@(MAPCAR #'(LAMBDA (SLOT-NAME)
			    (AND (SLOT-BOUNDP OBJECT SLOT-NAME)
				 `(SETF (SLOT-VALUE ',OBJECT ',SLOT-NAME)
					',(SLOT-VALUE OBJECT SLOT-NAME))))
			SAVE-SLOTS)
	      (INITIALIZE-INSTANCE ',OBJECT)))))

(INITIALIZE-CLOS-7)



;;; For compatibility with files compiled in Genera 8.0.
#+Genera
(DEFUN (:PROPERTY CONSTRUCTOR SYS:FUNCTION-SPEC-HANDLER) (FUNCTION FUNCTION-SPEC &REST ARGS)
  (CASE FUNCTION
    (SYS:VALIDATE-FUNCTION-SPEC
      (= 2 (LIST-LENGTH FUNCTION-SPEC)))
    (OTHERWISE
      (IF (= 2 (LIST-LENGTH FUNCTION-SPEC))
	  (APPLY (GET 'INSTANCE-FUNCTION-NAME 'SI:FUNCTION-SPEC-HANDLER)
		 FUNCTION (SECOND FUNCTION-SPEC) ARGS)
	  (ERROR "Invalid function spec ~S." FUNCTION-SPEC)))))

;;; For DW::PRESENTATION-TYPE-NAME
#+Genera
(DEFUN CLASSP (X)
  (TYPEP X 'CLASS))

#+Genera
(DEFUN ENSURE-FLAVOR-CLASS (CLASS-NAME)
  (LET* ((CLASS-HOLDER (LOAD-CLASS-HOLDER CLASS-NAME))
	 (CLASS (AND (CLASS-HOLDER-BOUNDP CLASS-HOLDER)
		     (CLASS-HOLDER-CLASS CLASS-HOLDER)))
	 (METACLASS (FIND-CLASS 'FLAVOR-CLASS)))
    (COND ((NULL CLASS)
	   (SETF (CLASS-HOLDER-CLASS CLASS-HOLDER)
		 (MAKE-INSTANCE 'FLAVOR-CLASS :NAME CLASS-NAME)))
	  ((EQ (CLASS-OF CLASS) METACLASS)
	   (REINITIALIZE-INSTANCE CLASS :NAME CLASS-NAME)
	   CLASS)
	  (T
	   (CHANGE-CLASS CLASS METACLASS)
	   (REINITIALIZE-INSTANCE CLASS :NAME CLASS-NAME)
	   CLASS))))

#+Genera
(DEFUN REMOVE-FLAVOR-CLASS (CLASS-NAME)
  (LET* ((CLASS-HOLDER (LOAD-CLASS-HOLDER CLASS-NAME :CREATEP NIL))
	 (CLASS (AND CLASS-HOLDER
		     (CLASS-HOLDER-BOUNDP CLASS-HOLDER)
		     (CLASS-HOLDER-CLASS CLASS-HOLDER))))
    (WHEN (TYPEP CLASS 'FLAVOR-CLASS)
      (CHANGE-CLASS CLASS (FIND-CLASS 'FORWARD-REFERENCED-CLASS)))
    CLASS))

#+Genera
(SI:DEFINE-GC-OPTIMIZATION TRANSFORM-OBSOLETE-CLOS-INSTANCES SI:SYMBOLICS-SYSTEM-RELEASE
  (:DOCUMENTATION
    "Run UPDATE-INSTANCE-FOR-REDEFINED-CLASS on all obsolete instances")
  (:BEFORE-FLIP (IGNORE)
    (DECLARE (IGNORE IGNORE))
    (SI:INHIBIT-GC-FLIPS			;interlock with GC
      (SI:GC-RECLAIM-OLDSPACE)			;needed if not called from full GC
      (SI:WITH-PROGRESS-REPORT ("finding and updating obsolete instances")
	(TV:NOTING-PROGRESS ("Finding and updating obsolete instances")
	  (LET ((TOTAL-WORDS 0)
		(SEEN-WORDS 0)
		(SEEN-INSTANCES 0)
		(TRANSFORMED-INSTANCES 0))
	    (SI:MAP-OVER-REGIONS
	      #'SI:AREA-PREDICATE-AREAS-WITH-OBJECTS
	      #'SI:REGION-PREDICATE-STRUCTURE
	      #'(LAMBDA (AREA REGION)
		  (DECLARE (IGNORE AREA))
		  (INCF TOTAL-WORDS (SI:REGION-FREE-POINTER REGION))))
	    (SI:MAP-OVER-REGIONS
	      #'SI:AREA-PREDICATE-AREAS-WITH-OBJECTS
	      #'SI:REGION-PREDICATE-STRUCTURE
	      #'(LAMBDA (AREA REGION)
		  (DECLARE (IGNORE AREA))
		  (SI:MAP-OVER-OBJECTS-IN-REGION
		    REGION
		    #'(LAMBDA (ADDRESS HEADER LEADER SIZE)
			(DECLARE (IGNORE ADDRESS LEADER SIZE))
			(WHEN (OR (AND (SYS:INSTANCEP HEADER)
				       (NOT (SYS:FLAVOR-INSTANCE-P HEADER))
				       (NOT (SYS:EQL-DISPATCH-INSTANCE-P HEADER))
				       #+IMACH
				       (NOT (FAKE-INSTANCE-P HEADER)))
				  (SYS:FUNCALLABLE-INSTANCE-P HEADER))
			  (INCF SEEN-INSTANCES)
			  (WHEN (INSTANCE-INFORMATION-OBSOLETE-P
				  (%INSTANCE-INFORMATION-INLINE HEADER))
			    (UPDATE-INSTANCE-USING-CLASS (CLASS-OF HEADER) HEADER)
			    (INCF TRANSFORMED-INSTANCES)))))
		  (INCF SEEN-WORDS (SI:REGION-FREE-POINTER REGION))
		  (TV:NOTE-PROGRESS SEEN-WORDS TOTAL-WORDS)))
	    (SI:GC-OPTIMIZATION-REPORT "~&Transformed ~D obsolete instance~:P out of ~D."
				       TRANSFORMED-INSTANCES SEEN-INSTANCES)))))))

#+Genera
(SI:DEFINE-GC-OPTIMIZATION SHRINK-MAPPING-TABLES :LAYERED-IDS-RELEASE
  (:ORDER :LATE)
  (:DOCUMENTATION "Shrink all CLOS mapping tables")
  (:BEFORE-FLIP (INCREMENTAL-P)
   (DECLARE (IGNORE INCREMENTAL-P))
   (MAP-OVER-GENERIC-FUNCTIONS
     #'(LAMBDA (GENERIC-FUNCTION)
	 (DOLIST (FAMILY (GENERIC-FUNCTION-MAPPING-TABLE-FAMILIES GENERIC-FUNCTION))
	   (UNLESS (MAPPING-TABLE-FAMILY-DO-NOT-GROW FAMILY)
	     (FREEZE-MAPPING-TABLE-FAMILY FAMILY)))))))
