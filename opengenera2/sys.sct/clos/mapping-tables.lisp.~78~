;;; -*- Mode: LISP; Syntax: ANSI-Common-Lisp; Base: 10; Package: CLOS-INTERNALS -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This file must be part of the System system

(IN-PACKAGE :CLOS-INTERNALS)

;;; Mapping Tables
;;;
;;; Mapping tables are segmented if there are too many entries to be addressed.  When
;;; this is done, SEGMENTS is a cdr-coded list of the segments.  By convention,
;;; segment 0 is used as the mapping table.  Normally, mapping tables only have one
;;; segment.  Each segment's first elements are described by the following structure.
;;; The remaining elements can be
;;;
;;; A fixnum 
;;;   
;;;   An offset into the instance slot vector, i.e. the
;;;   slot-definition-location of a slot.
;;;
;;; A locative
;;;
;;;   The location of the cell for a shared slot, again the slot-definition-location
;;;   of the slot.
;;;
;;; A function
;;;
;;;   A function which gets called with the operation (SLOT-VALUE, (SETF SLOT-VALUE),
;;;   or (LOCF SLOT-VALUE), the offset in the mapping table segment, the mapping
;;;   table segment, the instance, and any additional appropriate arguments
;;;   (currently, in the (SETF SLOT-VALUE), this will be the value to be set).  This
;;;   is the general escape mechanism.
;;;
;;; The symbol :UPDATE
;;;
;;;   One of the classes associated with the mapping table has had
;;;   MAKE-INSTANCES-OBSOLETE called on it.  The mapping table and the instances
;;;   in the frame should be updated.
;;;
(#+(OR Genera Cloe-Runtime) LISP:DEFSTRUCT
 #-(OR Genera Cloe-Runtime) DEFSTRUCT
 (MAPPING-TABLE
   (:CONSTRUCTOR NIL)
   (:COPIER NIL)
   (:PREDICATE NIL)
   :NAMED
   #+Minima
   (:TYPE VECTOR)
   #-Minima
   (:PRINT-FUNCTION
     (LAMBDA (OBJECT STREAM IGNORE)
       (PRINT-UNREADABLE-OBJECT (OBJECT STREAM :IDENTITY T)
	 (FORMAT STREAM "Map for classes ~{~s~^, ~}"
		 (MAPCAR #'CLASS-NAME-FOR-TYPE-OF
			 (MAPPING-TABLE-CLASSES OBJECT))))))
   #+Genera
   (:SIZE-SYMBOL *MAPPING-TABLE-OVERHEAD*)
   #+Genera
   (:ALTERANT NIL)
   )
 FAMILY-AND-CLASSES
 SEGMENTS)

(DEFMACRO %MAPPING-TABLE-REF (MT IDX)
  #+(OR Genera Minima) `(AREF ,MT ,IDX)
  #+Cloe-Runtime `(SYS::STRUCTURE-REF ,MT ,IDX)
  #-(OR Genera Minima Cloe-Runtime) (ERROR "wtf"))

#-Genera
(DEFPARAMETER *MAPPING-TABLE-OVERHEAD*
	      #+Cloe-Runtime 3
	      #+Minima 3
	      #-(OR Cloe-Runtime Minima) (ERROR "I don't know!"))

(DECLAIM (INLINE MAPPING-TABLE-FAMILY MAPPING-TABLE-CLASSES))

(DEFUN MAPPING-TABLE-FAMILY (SEGMENT)
  (CAR (MAPPING-TABLE-FAMILY-AND-CLASSES SEGMENT)))

(DEFUN MAPPING-TABLE-CLASSES (SEGMENT)
  (CDR (MAPPING-TABLE-FAMILY-AND-CLASSES SEGMENT)))

;;; These could be page-aligned
(DEFPARAMETER *MAPPING-TABLE-SIZE* 255.)

(DEFPARAMETER *MAPPING-TABLE-SEGMENT-SIZE* (- *MAPPING-TABLE-SIZE* *MAPPING-TABLE-OVERHEAD*))

(DEFUN MAPPING-TABLE-FAMILY-INDEX-SEGMENT-NUMBER-AND-OFFSET (INDEX)
  #+Genera (DECLARE (VALUES SEGMENT-NUMBER OFFSET))
  (MULTIPLE-VALUE-BIND (SEGMENT-NUMBER OFFSET) (FLOOR INDEX *MAPPING-TABLE-SEGMENT-SIZE*)
    (VALUES SEGMENT-NUMBER (+ *MAPPING-TABLE-OVERHEAD* OFFSET))))

(DEFUN SEGMENT-NUMBER-AND-OFFSET-MAPPING-TABLE-FAMILY-INDEX (SEGMENT-NUMBER OFFSET)
  (+ (* SEGMENT-NUMBER *MAPPING-TABLE-SEGMENT-SIZE*)
     OFFSET
     (- *MAPPING-TABLE-OVERHEAD*)))

(DEFUN SEGMENT-AND-OFFSET-MAPPING-TABLE-FAMILY-INDEX (SEGMENT OFFSET)
  (LET ((I 0))
    (DOLIST (MAPPING-TABLE-SEGMENT (MAPPING-TABLE-SEGMENTS SEGMENT))
      (WHEN (EQ SEGMENT MAPPING-TABLE-SEGMENT)
	(RETURN-FROM SEGMENT-AND-OFFSET-MAPPING-TABLE-FAMILY-INDEX
	  (+ (* I *MAPPING-TABLE-SEGMENT-SIZE*)
	     OFFSET
	     (- *MAPPING-TABLE-OVERHEAD*))))
      (INCF I))
    (ERROR "Mapping tables broken")))

(DEFUN APPEND-MAPPING-TABLE-SEGMENT (MAPPING-TABLE MAPPING-TABLE-FAMILY)
  (LET* ((NEW-SEGMENT (MAKE-MAPPING-TABLE-SEGMENT MAPPING-TABLE-FAMILY))
	 (OLD-SEGMENTS (MAPPING-TABLE-SEGMENTS MAPPING-TABLE))
	 (NEW-SEGMENTS (MAKE-LIST (1+ (LENGTH OLD-SEGMENTS))))
	 (NEW-PLACE NEW-SEGMENTS))
    (SETF (MAPPING-TABLE-FAMILY-AND-CLASSES NEW-SEGMENT)
	  (MAPPING-TABLE-FAMILY-AND-CLASSES MAPPING-TABLE))  
    (LOOP WHILE OLD-SEGMENTS DOING
      (LET ((OLD-SEGMENT (POP OLD-SEGMENTS)))
	(SETF (MAPPING-TABLE-SEGMENTS OLD-SEGMENT) NEW-SEGMENTS)
	(SETF (FIRST NEW-PLACE) OLD-SEGMENT)
	(POP NEW-PLACE)))
    (SETF (FIRST NEW-PLACE) NEW-SEGMENT)
    (SETF (MAPPING-TABLE-SEGMENTS NEW-SEGMENT) NEW-SEGMENTS)))

;;; The type of mapping table entry (see below):
(DEFCONSTANT %%MAP-BITS-TYPE (BYTE 3 0))

(DEFCONSTANT %MAP-TYPE-NULL 0)			;Entry not used
(DEFCONSTANT %MAP-TYPE-SLOT 1)			;Entry for a slot
(DEFCONSTANT %MAP-TYPE-READER 2)		;Entry for a reader
(DEFCONSTANT %MAP-TYPE-WRITER 3)		;Entry for a writer
(DEFCONSTANT %MAP-TYPE-LOCATOR 4)		;Entry for a locator
(DEFCONSTANT %MAP-TYPE-GENERIC-FUNCTION 5)	;Entry for a generic function call.

;;; Each mapping table family can map any number of classes.  Within the mapping
;;; table family, each class is identified by an index, which corresponds to the
;;; position of a variable in the WITH-MAPPED-SLOT-ACCESS form.
(DEFCONSTANT %%MAP-BITS-CLASS (BYTE 5 3))

(#+(OR Genera Cloe-Runtime) LISP:DEFSTRUCT
 #-(OR Genera Cloe-Runtime) DEFSTRUCT
  (MAPPING-TABLE-FAMILY
	     (:COPIER NIL)
	     (:PREDICATE NIL)
	     (:PRINT-FUNCTION
	       (LAMBDA (OBJECT STREAM IGNORE)
		 (PRINT-UNREADABLE-OBJECT (OBJECT STREAM :TYPE T :IDENTITY T)))))
  (MAPPING-TABLES NIL :TYPE LIST)
  (BITS 0 :TYPE FIXNUM)
  (MAP-BITS (MAKE-ARRAY *MAPPING-TABLE-SEGMENT-SIZE*
			:ELEMENT-TYPE '(UNSIGNED-BYTE 8.)
			:INITIAL-ELEMENT %MAP-TYPE-NULL)
	    :TYPE (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)))
  (MAP-DATA (MAKE-ARRAY *MAPPING-TABLE-SEGMENT-SIZE*)
	    :TYPE SIMPLE-VECTOR))

(DEFCONSTANT %%MAPPING-TABLE-FAMILY-BITS-SIZE (BYTE 24. 0.))
(DEFCONSTANT %%MAPPING-TABLE-FAMILY-BITS-DO-NOT-GROW (BYTE 1. 24.))

(DECLAIM (INLINE MAPPING-TABLE-FAMILY-SIZE))
(DEFUN MAPPING-TABLE-FAMILY-SIZE (MAPPING-TABLE-FAMILY)
  (LDB %%MAPPING-TABLE-FAMILY-BITS-SIZE (MAPPING-TABLE-FAMILY-BITS MAPPING-TABLE-FAMILY)))

(DECLAIM (INLINE (SETF MAPPING-TABLE-FAMILY-SIZE)))
(DEFUN (SETF MAPPING-TABLE-FAMILY-SIZE) (VALUE MAPPING-TABLE-FAMILY)
  (SETF (LDB %%MAPPING-TABLE-FAMILY-BITS-SIZE (MAPPING-TABLE-FAMILY-BITS MAPPING-TABLE-FAMILY))
	VALUE))

(DECLAIM (INLINE MAPPING-TABLE-FAMILY-DO-NOT-GROW))
(DEFUN MAPPING-TABLE-FAMILY-DO-NOT-GROW (MAPPING-TABLE-FAMILY)
  (LDB-TEST %%MAPPING-TABLE-FAMILY-BITS-DO-NOT-GROW
	    (MAPPING-TABLE-FAMILY-BITS MAPPING-TABLE-FAMILY)))

(DECLAIM (INLINE (SETF MAPPING-TABLE-FAMILY-DO-NOT-GROW)))
(DEFUN (SETF MAPPING-TABLE-FAMILY-DO-NOT-GROW) (VALUE MAPPING-TABLE-FAMILY)
  (SETF (LDB %%MAPPING-TABLE-FAMILY-BITS-DO-NOT-GROW
	     (MAPPING-TABLE-FAMILY-BITS MAPPING-TABLE-FAMILY))
	(IF VALUE -1 0)))

(DEFUN FREEZE-MAPPING-TABLE-FAMILY (FAMILY)
  (LET ((SIZE (MAPPING-TABLE-FAMILY-SIZE FAMILY)))
    ;; Prevent the family from growing somehow.
    (SETF (MAPPING-TABLE-FAMILY-DO-NOT-GROW FAMILY) T)
    #+Genera
    (DOLIST (MAPPING-TABLE (MAPPING-TABLE-FAMILY-MAPPING-TABLES FAMILY))
      (ADJUST-ARRAY MAPPING-TABLE (+ SIZE *MAPPING-TABLE-OVERHEAD*)))
    (SETF (MAPPING-TABLE-FAMILY-MAP-BITS FAMILY)
	  (REPLACE (MAKE-ARRAY SIZE
			       :ELEMENT-TYPE '(UNSIGNED-BYTE 8.)
			       :INITIAL-ELEMENT %MAP-TYPE-NULL)
		   (MAPPING-TABLE-FAMILY-MAP-BITS FAMILY)
		   :END1 SIZE
		   :END2 SIZE))
    (SETF (MAPPING-TABLE-FAMILY-MAP-DATA FAMILY)
	  (REPLACE (MAKE-ARRAY SIZE)
		   (MAPPING-TABLE-FAMILY-MAP-DATA FAMILY)
		   :END1 SIZE
		   :END2 SIZE))))

(DEFUN MAKE-MAPPING-TABLE-SEGMENT (MAPPING-TABLE-FAMILY)
  #+Genera
  (LISP:MAKE-ARRAY (IF (MAPPING-TABLE-FAMILY-DO-NOT-GROW MAPPING-TABLE-FAMILY)
		       (+ (MAPPING-TABLE-FAMILY-SIZE MAPPING-TABLE-FAMILY)
			  *MAPPING-TABLE-OVERHEAD*)
		       *MAPPING-TABLE-SIZE*)
		   :NAMED-STRUCTURE-SYMBOL 'MAPPING-TABLE)
  #+Minima
  (LET ((MT (MAKE-ARRAY (IF (MAPPING-TABLE-FAMILY-DO-NOT-GROW MAPPING-TABLE-FAMILY)
			    (+ (MAPPING-TABLE-FAMILY-SIZE MAPPING-TABLE-FAMILY)
			       *MAPPING-TABLE-OVERHEAD*)
			    *MAPPING-TABLE-SIZE*))))
    (SETF (SVREF MT 0) 'MAPPING-TABLE)
    MT)
  #+Cloe-Runtime
  (LET ((MT (SYSTEM::MAKE-TRIVIAL-STRUCTURE
	      (+ (MAPPING-TABLE-FAMILY-SIZE MAPPING-TABLE-FAMILY)
		 *MAPPING-TABLE-OVERHEAD*))))
    (SETF (SYSTEM::STRUCTURE-REF MT 0) 'MAPPING-TABLE)
    MT)
  #-(or Genera Minima Cloe-Runtime)
  (ERROR "Can't make mapping table segments yet"))

(DEFUN ALLOCATE-MAPPING-TABLE-FAMILY-INDEX (FAMILY)
  (WITH-NO-OTHER-PROCESSES
    (WHEN (MAPPING-TABLE-FAMILY-DO-NOT-GROW FAMILY)
      (ERROR "Attempt to grow a mapping table family which has been marked as not growable."))
    (LET ((SIZE (MAPPING-TABLE-FAMILY-SIZE FAMILY)))
      (SETF (MAPPING-TABLE-FAMILY-SIZE FAMILY) (1+ SIZE))
      ;; See if we need a new segment
      (LET* ((BITS (MAPPING-TABLE-FAMILY-MAP-BITS FAMILY))
	     (LENGTH (LENGTH BITS)))
	(WHEN (>= SIZE LENGTH)
	  ;; Have to grow
	  (SETQ LENGTH (* *MAPPING-TABLE-SEGMENT-SIZE*
			  (CEILING (1+ LENGTH) *MAPPING-TABLE-SEGMENT-SIZE*)))
	  (LET ((NEW-BITS (MAKE-ARRAY LENGTH
				      :ELEMENT-TYPE '(UNSIGNED-BYTE 16.)
				      :INITIAL-ELEMENT %MAP-TYPE-NULL))
		(NEW-DATA (MAKE-ARRAY LENGTH)))
	    (REPLACE NEW-BITS BITS)
	    (REPLACE NEW-DATA (MAPPING-TABLE-FAMILY-MAP-DATA FAMILY))
	    (SETF (MAPPING-TABLE-FAMILY-MAP-BITS FAMILY) NEW-BITS)
	    (SETF (MAPPING-TABLE-FAMILY-MAP-DATA FAMILY) NEW-DATA))
	  (MAPC #'(LAMBDA (MAPPING-TABLE)
		    (APPEND-MAPPING-TABLE-SEGMENT MAPPING-TABLE FAMILY))
		(MAPPING-TABLE-FAMILY-MAPPING-TABLES FAMILY))))
      SIZE)))

(DEFUN GET-MAPPING-TABLE-FAMILY-SEGMENT-NUMBER-AND-OFFSET
       (FAMILY CLASS-INDEX TYPE THING &OPTIONAL (INSERT-P T))
  #+Genera (DECLARE (VALUES SEGMENT-NUMBER OFFSET))
  (WITH-NO-OTHER-PROCESSES
    (LET ((BITS (DPB CLASS-INDEX %%MAP-BITS-CLASS
		     (DPB (ECASE TYPE
			    (:SLOT %MAP-TYPE-SLOT)
			    (:READER %MAP-TYPE-READER)
			    (:WRITER %MAP-TYPE-WRITER)
			    #+(OR Genera Minima)
			    (:LOCATOR %MAP-TYPE-LOCATOR)
			    (:GENERIC-FUNCTION %MAP-TYPE-GENERIC-FUNCTION))
			  %%MAP-BITS-TYPE 0)))
	  (MAP-BITS (MAPPING-TABLE-FAMILY-MAP-BITS FAMILY))
	  (MAP-DATA (MAPPING-TABLE-FAMILY-MAP-DATA FAMILY))
	  (SIZE (MAPPING-TABLE-FAMILY-SIZE FAMILY)))
      (DECLARE (TYPE (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)) MAP-BITS)
	       (TYPE SIMPLE-VECTOR MAP-DATA))
      (LOOP FOR I FROM 0 BELOW SIZE DOING
	(WHEN (AND (EQL (AREF MAP-BITS I) BITS)
		   (EQ (AREF MAP-DATA I) THING))
	  (RETURN-FROM GET-MAPPING-TABLE-FAMILY-SEGMENT-NUMBER-AND-OFFSET
	    (MAPPING-TABLE-FAMILY-INDEX-SEGMENT-NUMBER-AND-OFFSET I))))
      (UNLESS INSERT-P
	(RETURN-FROM GET-MAPPING-TABLE-FAMILY-SEGMENT-NUMBER-AND-OFFSET NIL))
      (CASE TYPE
	((:READER :WRITER #+(OR Genera Minima) :LOCATOR)
	 (ADD-FUNCTION-MAPPING-TABLE-FAMILY THING FAMILY)))
      (LET ((INDEX (ALLOCATE-MAPPING-TABLE-FAMILY-INDEX FAMILY)))
	;; MAP-BITS and MAP-DATA can be changed by
	;; ALLOCATE-MAPPING-TABLE-FAMILY-INDEX, so recache them.
	(SETQ MAP-BITS (MAPPING-TABLE-FAMILY-MAP-BITS FAMILY))
	(SETQ MAP-DATA (MAPPING-TABLE-FAMILY-MAP-DATA FAMILY))
	(SETF (AREF MAP-BITS INDEX) BITS)
	(SETF (AREF MAP-DATA INDEX) THING)
	;; Add this slot to the existing mapping tables
	(MULTIPLE-VALUE-BIND (SEGMENT-NUMBER OFFSET)
	    (MAPPING-TABLE-FAMILY-INDEX-SEGMENT-NUMBER-AND-OFFSET INDEX)
	  (DOLIST (MAPPING-TABLE (MAPPING-TABLE-FAMILY-MAPPING-TABLES FAMILY))
	    (LET ((SEGMENT (NTH SEGMENT-NUMBER (MAPPING-TABLE-SEGMENTS MAPPING-TABLE))))
	      (SETF (%MAPPING-TABLE-REF SEGMENT OFFSET)
		    (COMPUTE-MAPPING-TABLE-ENTRY
		      MAP-BITS MAP-DATA INDEX (MAPPING-TABLE-CLASSES MAPPING-TABLE)))))
	  (VALUES SEGMENT-NUMBER OFFSET))))))

;;; In the interpreter, this is nothing more than a progn.
;;; Accesses to the variables VARIABLES will be mapped (if they can be).  .SELF. and
;;; .SELF-MAPPING-TABLE. should already be set up.
;;;
;;; The position of a variable in the variables list determines the class index which
;;; will be associated with the mapping table family for that variable.  If the
;;; variables are (A B C D E), then variable A will be index 0, B 1, etc.
(DEFMACRO WITH-MAPPED-SLOT-ACCESS ((VARIABLES MAPPING-TABLE) &BODY BODY)
  `(PROGN
     ,MAPPING-TABLE
     ,@VARIABLES
     ,@BODY))

#+Genera
(SCL:DEFPROP MAPPING-TABLE-FAMILY T SI:DEBUG-INFO)

;;; Make sure that any references to accessors are noted.
(DEFUN ENTER-MAPPING-TABLE-FAMILY (FAMILY)
  (LET ((MAP-BITS (MAPPING-TABLE-FAMILY-MAP-BITS FAMILY))
	(MAP-DATA (MAPPING-TABLE-FAMILY-MAP-DATA FAMILY)))
    (DECLARE (TYPE (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)) MAP-BITS)
	     (TYPE SIMPLE-VECTOR MAP-DATA))
    (LOOP FOR INDEX FROM 0 BELOW (MAPPING-TABLE-FAMILY-SIZE FAMILY)
	  FOR TYPE = (LDB %%MAP-BITS-TYPE (AREF MAP-BITS INDEX))
	  DO
      (WHEN (OR (= TYPE %MAP-TYPE-READER)
		(= TYPE %MAP-TYPE-WRITER)
		#+(OR Genera Minima) (= TYPE %MAP-TYPE-LOCATOR))
	(ADD-FUNCTION-MAPPING-TABLE-FAMILY (AREF MAP-DATA INDEX) FAMILY)))))

;;; FAMILIES should be a list of possible mapping table families, and FUNCTION-FAMILY
;;; should be the family for a particular function we are going to add.
#+Genera
(DEFUN FIND-APPROPRIATE-MAPPING-TABLE (FAMILIES FUNCTION-FAMILY)
  #+Genera (DECLARE (VALUES FAMILY NEW-FAMILIES))
  (WHEN (>= (MAPPING-TABLE-FAMILY-SIZE FUNCTION-FAMILY)
	    *MAPPING-TABLE-SEGMENT-SIZE*)
    ;; Multi-segment families are too hairy to change around, so just leave it go
    (RETURN-FROM FIND-APPROPRIATE-MAPPING-TABLE
      (VALUES FUNCTION-FAMILY FAMILIES)))
  (LET ((FUNCTION-SIZE (MAPPING-TABLE-FAMILY-SIZE FUNCTION-FAMILY))
	(FUNCTION-MAP-BITS (MAPPING-TABLE-FAMILY-MAP-BITS FUNCTION-FAMILY))
	(FUNCTION-MAP-DATA (MAPPING-TABLE-FAMILY-MAP-DATA FUNCTION-FAMILY))
	(SMALLEST-COUNT NIL)
	(SMALLEST-FAMILY NIL))
    (DECLARE (TYPE (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)) FUNCTION-MAP-BITS)
	     (TYPE SIMPLE-VECTOR FUNCTION-MAP-DATA))
    ;; The families must stay one segment long.  Choose the family that would grow
    ;; the least without becoming more than one segment long.
    (DOLIST (FAMILY FAMILIES)
      (LET ((FAMILY-MAP-BITS (MAPPING-TABLE-FAMILY-MAP-BITS FAMILY))
	    (FAMILY-MAP-DATA (MAPPING-TABLE-FAMILY-MAP-DATA FAMILY)))
	(DECLARE (TYPE (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)) FAMILY-MAP-BITS)
		 (TYPE SIMPLE-VECTOR FAMILY-MAP-DATA))
	(LET ((FAMILY-SIZE (MAPPING-TABLE-FAMILY-SIZE FAMILY))
	      (DO-NOT-GROW-P (MAPPING-TABLE-FAMILY-DO-NOT-GROW FAMILY))
	      (COUNT 0))
	  (BLOCK DO-FAMILY
	    (DOTIMES (FUNCTION-INDEX FUNCTION-SIZE)
	      (LET ((FUNCTION-BITS (AREF FUNCTION-MAP-BITS FUNCTION-INDEX))
		    (FUNCTION-DATA (AREF FUNCTION-MAP-DATA FUNCTION-INDEX)))
		(BLOCK SEARCH
		  (DOTIMES (FAMILY-INDEX FAMILY-SIZE)
		    (WHEN (AND (= (AREF FAMILY-MAP-BITS FAMILY-INDEX) FUNCTION-BITS)
			       (EQ (AREF FAMILY-MAP-DATA FAMILY-INDEX) FUNCTION-DATA))
		      (RETURN-FROM SEARCH)))
		  (WHEN DO-NOT-GROW-P
		    (RETURN-FROM DO-FAMILY))
		  (INCF COUNT))))
	    (WHEN (AND (<= (+ COUNT FAMILY-SIZE) *MAPPING-TABLE-SEGMENT-SIZE*)
		       (OR (NULL SMALLEST-COUNT)
			   (< COUNT SMALLEST-COUNT)))
	      (SETQ SMALLEST-COUNT COUNT
		    SMALLEST-FAMILY FAMILY))))))
    (WHEN SMALLEST-COUNT
      (RETURN-FROM FIND-APPROPRIATE-MAPPING-TABLE
	(VALUES SMALLEST-FAMILY FAMILIES))))
  ;; None of the families were suitable, so just use the function's family.
  ;; ALLOCATE-MAPPING-TABLE-FAMILY-INDEX will grow the family if needed.
  (VALUES FUNCTION-FAMILY (CONS FUNCTION-FAMILY FAMILIES)))

#+IMACH
(DEFMACRO ALTER-MAPPED-INSTRUCTIONS ((OFFSET FUNCTION) &BODY BODY)
  (LET ((WORD (GENSYM))
	(TAG (GENSYM))
	(DATA (GENSYM))
	(OPCODE (GENSYM))
	(INSTRUCTION (GENSYM))
	(CHANGEDP (GENSYM)))
    `(MACROLET
       ((DO-INSTRUCTION (INSTRUCTION)
	  `(LET ((,',OPCODE (LDB SYS:%%PACKED-INSTRUCTION-OPCODE ,INSTRUCTION)))
	     (IF (OR (= ,',OPCODE I-LISP-COMPILER:*PUSH-INSTANCE-VARIABLE-OPCODE*)
		     (= ,',OPCODE I-LISP-COMPILER:*POP-INSTANCE-VARIABLE-OPCODE*)
		     (= ,',OPCODE I-LISP-COMPILER:*MOVEM-INSTANCE-VARIABLE-OPCODE*)
		     (= ,',OPCODE I-LISP-COMPILER:*PUSH-ADDRESS-INSTANCE-VARIABLE-OPCODE*))
		 (LET ((,',OFFSET (LDB SYS:%%PACKED-INSTRUCTION-8-BIT-OPERAND ,INSTRUCTION)))
		   (DPB (PROGN ,',@BODY) SYS:%%PACKED-INSTRUCTION-8-BIT-OPERAND ,INSTRUCTION))
		 ,INSTRUCTION))))
       (SYS:WITH-BLOCK-REGISTERS (2)
	 (SETF (SYS:%BLOCK-REGISTER 2) ,FUNCTION)
	 (LOOP REPEAT (LET ((CCA (SYS:COMPILED-FUNCTION-CCA ,FUNCTION)))
			(- (SYS:CCA-TOTAL-SIZE CCA)
			   (SYS:CCA-SUFFIX-SIZE CCA)
			   (SYS:DEFSTORAGE-SIZE SYS:COMPILED-FUNCTION)))
	       DOING
	   (LET* ((,CHANGEDP NIL)
		  (,WORD (SYS:%BLOCK-READ 2 :CYCLE-TYPE SYS:%MEMORY-SCAVENGE
					  :SET-CDR-NEXT NIL))
		  (,TAG (SYS:%TAG ,WORD)))
	     (WHEN (>= (LDB SYS:%%Q-TYPE-WITHIN-TAG ,TAG) SYS:DTP-PACKED-INSTRUCTION-60)
	       ;; It is a packed instruction.  Check the opcodes of the odd and even halves
	       (LET ((,DATA (SYS:%POINTER ,WORD)))
		 (LET* ((,INSTRUCTION (LDB SYS:%%Q-EVEN-INSTRUCTION ,DATA))
			(NEW-POINTER (DO-INSTRUCTION ,INSTRUCTION)))
		   (UNLESS (= ,INSTRUCTION NEW-POINTER)
		     (SETF (LDB SYS:%%Q-EVEN-INSTRUCTION ,DATA) NEW-POINTER)
		     (SETF ,CHANGEDP T)))
		 (LET* ((,INSTRUCTION
			 (DPB (LDB SYS:%%Q-ODD-INSTRUCTION-WITHIN-TAG ,TAG)
			      SYS:%%ODD-INSTRUCTION-TAG-COMPONENT
			      (LDB SYS:%%Q-ODD-INSTRUCTION-WITHIN-POINTER ,DATA)))
			(NEW-POINTER (DO-INSTRUCTION ,INSTRUCTION)))
		   (UNLESS (= ,INSTRUCTION NEW-POINTER)
		     (SETF (LDB SYS:%%Q-ODD-INSTRUCTION-WITHIN-TAG ,TAG)
			   (LDB SYS:%%ODD-INSTRUCTION-TAG-COMPONENT NEW-POINTER))
		     (SETF (LDB SYS:%%Q-ODD-INSTRUCTION-WITHIN-POINTER ,DATA)
			   (LDB SYS:%%ODD-INSTRUCTION-DATA-COMPONENT NEW-POINTER))
		     (SETF ,CHANGEDP T)))
		 (WHEN ,CHANGEDP
		   (SYS:%MEMORY-WRITE
		     (SYS:%POINTER-PLUS (SYS:%BLOCK-REGISTER 2) -1)
		     (SYS:%SET-TAG ,DATA ,TAG))))))))
       (SYS:%CLEAR-INSTRUCTION-CACHE)
       NIL)))

#+|3600|
(DEFMACRO ALTER-MAPPED-INSTRUCTIONS ((OFFSET FUNCTION) &BODY BODY)
  (LET ((PC (GENSYM))
	(INSTRUCTION (GENSYM))
	(OPCODE (GENSYM))
	(CCA (GENSYM))
	(NEW-OFFSET (GENSYM)))
    `(LET ((,CCA (SYS:COMPILED-FUNCTION-CCA ,FUNCTION)))
       (DOTIMES (,PC (SYS:CCA-N-INSTRUCTIONS ,CCA))
	 (LET* ((,INSTRUCTION (SYS:CCA-INSTRUCTION ,CCA ,PC))
		(,OPCODE (L-LISP-COMPILER:GET-UNIVERSAL-OPCODE ,INSTRUCTION)))
	   (WHEN (OR (= ,OPCODE L-LISP-COMPILER:*PUSH-INSTANCE-VARIABLE-OPCODE*)
		     (= ,OPCODE L-LISP-COMPILER:*POP-INSTANCE-VARIABLE-OPCODE*)
		     (= ,OPCODE L-LISP-COMPILER:*MOVEM-INSTANCE-VARIABLE-OPCODE*)
		     (= ,OPCODE L-LISP-COMPILER:*PUSH-ADDRESS-INSTANCE-VARIABLE-OPCODE*))
	     (LET* ((,OFFSET (LDB (BYTE 8. 8.) ,INSTRUCTION))
		    (,NEW-OFFSET (PROGN ,@BODY)))
	       (UNLESS (= ,OFFSET ,NEW-OFFSET)
		 (SETF (SYS:CCA-INSTRUCTION ,CCA ,PC)
		       (DPB ,NEW-OFFSET (BYTE 8. 8.) ,INSTRUCTION)))))))
       (SYS:%CLEAR-INSTRUCTION-CACHE)
       NIL)))

#+Genera
;;; Changes from one mapping table family to another
(DEFUN UPDATE-MAPPING-TABLE-INSTRUCTIONS (EXTERNAL-FUNCTION NEW-FAMILY OLD-FAMILY)
  (WITH-NO-OTHER-PROCESSES
    (LABELS ((DO-FUNCTION (FUNCTION)
	       (LET* ((CCA (SYS:COMPILED-FUNCTION-CCA FUNCTION))
		      (OLD-DEBUG-INFO (SYS:CCA-EXTRA-INFO CCA))
		      (DEBUG-INFO OLD-DEBUG-INFO))
		 (DOLIST (ENTRY (CDR DEBUG-INFO))
		   (WHEN (CONSP ENTRY)
		     (CASE (FIRST ENTRY)
		       ((MAPPING-TABLE-FAMILY MAPPED-ARGUMENTS)
			 (SETF DEBUG-INFO (REMOVE ENTRY DEBUG-INFO))))))
		 (UNLESS (EQ DEBUG-INFO OLD-DEBUG-INFO)
		   (SETF (SYS:CCA-EXTRA-INFO CCA)
			 (SI:STANDARDIZE-EXTRA-INFO FUNCTION DEBUG-INFO))))
	       (UNLESS (EQ OLD-FAMILY NEW-FAMILY)
		 (LET ((MAX-SIZE (+ (MAPPING-TABLE-FAMILY-SIZE NEW-FAMILY)
				    (MAPPING-TABLE-FAMILY-SIZE OLD-FAMILY))))
		   (SYS:WITH-STACK-ARRAY (TRANSLATIONS MAX-SIZE :INITIAL-ELEMENT NIL)
		     (DECLARE (SYS:ARRAY-REGISTER TRANSLATIONS))
		     (LET* ((OLD-BITS (MAPPING-TABLE-FAMILY-MAP-BITS OLD-FAMILY))
			    (OLD-DATA (MAPPING-TABLE-FAMILY-MAP-DATA OLD-FAMILY))
			    (NEW-BITS (MAPPING-TABLE-FAMILY-MAP-BITS NEW-FAMILY))
			    (NEW-DATA (MAPPING-TABLE-FAMILY-MAP-DATA NEW-FAMILY))
			    (NEW-ORIGINAL-SIZE (MAPPING-TABLE-FAMILY-SIZE NEW-FAMILY)))
		       (DECLARE (TYPE (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)) OLD-BITS NEW-BITS)
				(TYPE SIMPLE-VECTOR OLD-DATA NEW-DATA))
		       (LOOP FOR I FROM 0 BELOW (MAPPING-TABLE-FAMILY-SIZE OLD-FAMILY) DOING
			 (LET ((BITS (AREF OLD-BITS I))
			       (DATA (AREF OLD-DATA I)))
			   (LOOP FOR J FROM 0 BELOW NEW-ORIGINAL-SIZE DOING
			     (WHEN (AND (= (AREF NEW-BITS J) BITS)
					(EQ (AREF NEW-DATA J) DATA))
			       (SETF (AREF TRANSLATIONS I) J)))))
		       (ALTER-MAPPED-INSTRUCTIONS (OFFSET FUNCTION)
			 (LET ((INDEX (SEGMENT-NUMBER-AND-OFFSET-MAPPING-TABLE-FAMILY-INDEX
					0 OFFSET)))
			   (MULTIPLE-VALUE-BIND (SEGMENT-NUMBER OFFSET)
			       (MAPPING-TABLE-FAMILY-INDEX-SEGMENT-NUMBER-AND-OFFSET
				 (OR (AREF TRANSLATIONS INDEX)
				     ;; Insert a new entry into the table
				     (LET* ((NEW-INDEX (ALLOCATE-MAPPING-TABLE-FAMILY-INDEX
							 NEW-FAMILY))
					    (BITS (MAPPING-TABLE-FAMILY-MAP-BITS NEW-FAMILY))
					    (DATA (MAPPING-TABLE-FAMILY-MAP-DATA NEW-FAMILY))
					    (FAMILY-BITS (AREF OLD-BITS INDEX))
					    (FAMILY-DATA (AREF OLD-DATA INDEX)))
				       (UNLESS (EQ BITS NEW-BITS) (SETQ NEW-BITS BITS))
				       (UNLESS (EQ DATA NEW-DATA) (SETQ NEW-DATA DATA))
				       (SETF (AREF TRANSLATIONS INDEX) NEW-INDEX)
				       (SETF (AREF NEW-BITS NEW-INDEX) FAMILY-BITS)
				       (SETF (AREF NEW-DATA NEW-INDEX) FAMILY-DATA)
				       NEW-INDEX)))
			     (UNLESS (EQL SEGMENT-NUMBER 0)
			       (ERROR "Can not change the segment number"))
			     OFFSET)))
		       ;; Update the existing mapping tables
		       (LOOP FOR MAPPING-TABLE IN (MAPPING-TABLE-FAMILY-MAPPING-TABLES
						    NEW-FAMILY)
			     DOING
			 (LOOP FOR INDEX FROM NEW-ORIGINAL-SIZE
					 BELOW (MAPPING-TABLE-FAMILY-SIZE NEW-FAMILY)
			       DOING
			   (MULTIPLE-VALUE-BIND (SEGMENT-NUMBER OFFSET)
			       (MAPPING-TABLE-FAMILY-INDEX-SEGMENT-NUMBER-AND-OFFSET INDEX)
			     (LET ((SEGMENT (NTH SEGMENT-NUMBER
						 (MAPPING-TABLE-SEGMENTS MAPPING-TABLE))))
			       (SETF (%MAPPING-TABLE-REF SEGMENT OFFSET)
				     (COMPUTE-MAPPING-TABLE-ENTRY
				       NEW-BITS NEW-DATA INDEX
				       (MAPPING-TABLE-CLASSES MAPPING-TABLE)))))))))))
	       #+IMACH
	       (MAPC #'DO-FUNCTION (SI:COMPILED-FUNCTION-INTERNAL-FUNCTION-OFFSETS FUNCTION))
	       #+|3600|
	       (MAPC #'(LAMBDA (OFFSET)
			 (DO-FUNCTION (SYS:%P-CONTENTS-OFFSET FUNCTION (- -1 OFFSET))))
		     (SI:COMPILED-FUNCTION-INTERNAL-FUNCTION-OFFSETS FUNCTION))
	       #-Genera
	       (ERROR "Can't do this yet")
	       NIL))
      (DO-FUNCTION EXTERNAL-FUNCTION))))

#+Genera
(DEFUN MAP-OVER-MAPPING-TABLE-INSTRUCTIONS (CALLER FAMILY FUNARG)
  (LET ((MAP-BITS (MAPPING-TABLE-FAMILY-MAP-BITS FAMILY))
	(MAP-DATA (MAPPING-TABLE-FAMILY-MAP-DATA FAMILY)))
    (DECLARE (TYPE (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)) MAP-BITS)
	     (TYPE SIMPLE-VECTOR MAP-DATA))
    (SCL:STACK-LET ((ALREADY-SEEN (MAKE-ARRAY (MAPPING-TABLE-FAMILY-SIZE FAMILY)
					      :ELEMENT-TYPE 'SCL:BOOLEAN
					      :INITIAL-ELEMENT NIL)))
      (DECLARE (SYS:ARRAY-REGISTER ALREADY-SEEN))
      (ALTER-MAPPED-INSTRUCTIONS (OFFSET CALLER)
	(LET ((INDEX (SEGMENT-NUMBER-AND-OFFSET-MAPPING-TABLE-FAMILY-INDEX 0 OFFSET)))
	  (UNLESS (AREF ALREADY-SEEN INDEX)
	    (SETF (AREF ALREADY-SEEN INDEX) T)
	    (LET ((BITS (AREF MAP-BITS INDEX)))
	      (SCL:SELECT (LDB %%MAP-BITS-TYPE BITS)
		((%MAP-TYPE-SLOT)
		 ;;              caller callee                how
		 (FUNCALL FUNARG CALLER (AREF MAP-DATA INDEX) ':INSTANCE-VARIABLE))
		((%MAP-TYPE-READER %MAP-TYPE-WRITER %MAP-TYPE-LOCATOR)
		 (LET ((DATA (AREF MAP-DATA INDEX)))
		   (FUNCALL FUNARG CALLER DATA
			    (IF (FUNCTIONP DATA) :GENERIC-FUNCTION :FUNCTION))))
		))))
	;; Don't modify anything...
	OFFSET))))

;;; This is called by method combination and the like
(DEFUN GET-MAPPING-TABLE-FOR-CLASSES (FAMILY &REST CLASSES)
  (WITH-NO-OTHER-PROCESSES
    (OR (BLOCK SEARCH
	  (LOOP FOR MAPPING-TABLE IN (MAPPING-TABLE-FAMILY-MAPPING-TABLES FAMILY)
		FOR KEY = (MAPPING-TABLE-CLASSES MAPPING-TABLE)
		DOING
	    (LET ((CLASSES CLASSES))
	      (LOOP DOING
		(WHEN (AND (NULL CLASSES) (NULL KEY))
		  (RETURN-FROM SEARCH MAPPING-TABLE))
		(UNLESS (AND CLASSES KEY (EQ (POP CLASSES) (POP KEY)))
		  (RETURN NIL))))))
	(PROGN
	  (LET* ((MAPPING-TABLE NIL)
		 (FAMILY-AND-CLASSES (MAKE-LIST (1+ (LENGTH CLASSES))))
		 (MAP-BITS (MAPPING-TABLE-FAMILY-MAP-BITS FAMILY))
		 (MAP-DATA (MAPPING-TABLE-FAMILY-MAP-DATA FAMILY))
		 (SIZE (MAPPING-TABLE-FAMILY-SIZE FAMILY))
		 (N-SEGMENTS (CEILING SIZE *MAPPING-TABLE-SEGMENT-SIZE*))
		 (SEGMENTS (MAKE-LIST N-SEGMENTS)))
	    (DECLARE (TYPE (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)) MAP-BITS)
		     (TYPE SIMPLE-VECTOR MAP-DATA))
	    (SETF (FIRST FAMILY-AND-CLASSES) FAMILY)
	    (MAPL #'(LAMBDA (OLD-PLACE NEW-PLACE)
		      (SETF (CAR NEW-PLACE) (CAR OLD-PLACE)))
		  CLASSES
		  (CDR FAMILY-AND-CLASSES))
	    (SETF CLASSES (CDR FAMILY-AND-CLASSES))
	    (LOOP FOR PLACE ON SEGMENTS DOING
	      (LET ((SEGMENT (MAKE-MAPPING-TABLE-SEGMENT FAMILY)))
		(SETF (MAPPING-TABLE-FAMILY-AND-CLASSES SEGMENT) FAMILY-AND-CLASSES)
		(SETF (MAPPING-TABLE-SEGMENTS SEGMENT) SEGMENTS)
		(SETF (FIRST PLACE) SEGMENT)))
	    (SETF MAPPING-TABLE (FIRST SEGMENTS))
	    (ASSERT (NOT (NULL MAPPING-TABLE)))
	    (LOOP FOR INDEX FROM 0 BELOW SIZE DOING
	      (MULTIPLE-VALUE-BIND (SEGMENT-NUMBER OFFSET)
		  (MAPPING-TABLE-FAMILY-INDEX-SEGMENT-NUMBER-AND-OFFSET INDEX)
		(LET ((SEGMENT (NTH SEGMENT-NUMBER SEGMENTS)))
		  (SETF (%MAPPING-TABLE-REF SEGMENT OFFSET)
			(COMPUTE-MAPPING-TABLE-ENTRY MAP-BITS MAP-DATA INDEX CLASSES)))))
	    (PUSH MAPPING-TABLE (MAPPING-TABLE-FAMILY-MAPPING-TABLES FAMILY))
	    (DOLIST (CLASS CLASSES)
	      (ADD-MAPPING-TABLE CLASS MAPPING-TABLE))
	    MAPPING-TABLE)))))

(DEFUN COMPUTE-MAPPING-TABLE-ENTRY (MAP-BITS MAP-DATA INDEX CLASSES)
  (LET* ((BITS (AREF MAP-BITS INDEX))
	 (TYPE (LDB %%MAP-BITS-TYPE BITS))
	 (CLASS (NTH (LDB %%MAP-BITS-CLASS BITS) CLASSES))
	 (DATA (AREF MAP-DATA INDEX)))
    (COND ((EQL TYPE %MAP-TYPE-NULL)
	   NIL)
	  ((EQL TYPE %MAP-TYPE-SLOT)
	   (IF (OR (NULL CLASS) (EQ CLASS (FIND-CLASS T)))
	       #'MAPPING-TABLE-CALL-SLOT-VALUE
	       (LET ((SLOT (FIND DATA (CLASS-SLOTS CLASS) :KEY #'SLOT-DEFINITION-NAME)))
		 (IF SLOT
		     (SLOT-DEFINITION-LOCATION SLOT)
		     #'MAPPING-TABLE-CALL-SLOT-MISSING))))
	  ((EQL TYPE %MAP-TYPE-READER)
	   (WHEN (AND (NOT (FUNCTIONP DATA))
		      (FBOUNDP DATA))
	     (SETF DATA (FDEFINITION DATA)))
	   (WHEN (GENERIC-FUNCTION-P DATA)
	     (MULTIPLE-VALUE-BIND (FUNCTION EXTRA-ARG)
		 (STANDARD-METHOD-COMBINER DATA (GENERIC-FUNCTION-METHODS DATA)
					   #'(LAMBDA (TYPE I)
					       (DECLARE (IGNORE I))
					       (ECASE TYPE
						 (CLASS CLASS)
						 (EQL (VALUES NIL NIL))))
					   T)
	       (WHEN (OR (EQ FUNCTION #'STANDARD-CLASS-LOCAL-SLOT-READER)
			 (EQ FUNCTION #'STANDARD-CLASS-SHARED-SLOT-READER))
		 (RETURN-FROM COMPUTE-MAPPING-TABLE-ENTRY
		   EXTRA-ARG))))
	   #'MAPPING-TABLE-CALL-READER)
	  ((EQL TYPE %MAP-TYPE-WRITER)
	   (WHEN (AND (NOT (FUNCTIONP DATA))
		      (FBOUNDP DATA))
	     (SETF DATA (FDEFINITION DATA)))
	   (WHEN (GENERIC-FUNCTION-P DATA)
	     (MULTIPLE-VALUE-BIND (FUNCTION EXTRA-ARG)
		 (STANDARD-METHOD-COMBINER DATA (GENERIC-FUNCTION-METHODS DATA)
					   #'(LAMBDA (TYPE I)
					       (ECASE TYPE
						 (CLASS (IF (= I 0) (FIND-CLASS T) CLASS))
						 (EQL (VALUES NIL NIL))))
					   T)
	       (WHEN (OR (EQ FUNCTION #'STANDARD-CLASS-LOCAL-SLOT-WRITER)
			 (EQ FUNCTION #'STANDARD-CLASS-SHARED-SLOT-WRITER))
		 (RETURN-FROM COMPUTE-MAPPING-TABLE-ENTRY
		   EXTRA-ARG))))
	   #'MAPPING-TABLE-CALL-WRITER)
	  #+(OR Genera Minima)
	  ((EQL TYPE %MAP-TYPE-LOCATOR)
	   (WHEN (AND (NOT (FUNCTIONP DATA))
		      (FBOUNDP DATA))
	     (SETF DATA (FDEFINITION DATA)))
	   (WHEN (GENERIC-FUNCTION-P DATA)
	     (MULTIPLE-VALUE-BIND (FUNCTION EXTRA-ARG)
		 (STANDARD-METHOD-COMBINER DATA (GENERIC-FUNCTION-METHODS DATA)
					   #'(LAMBDA (TYPE I)
					       (DECLARE (IGNORE I))
					       (ECASE TYPE
						 (CLASS CLASS)
						 (EQL (VALUES NIL NIL))))
					   T)
	       (WHEN (OR (EQ FUNCTION #'STANDARD-CLASS-LOCAL-SLOT-LOCATOR)
			 (EQ FUNCTION #'STANDARD-CLASS-SHARED-SLOT-LOCATOR))
		 (RETURN-FROM COMPUTE-MAPPING-TABLE-ENTRY
		   EXTRA-ARG))))
	   #'MAPPING-TABLE-CALL-LOCATOR)
	  ((EQL TYPE %MAP-TYPE-GENERIC-FUNCTION)
	   NIL))))

(DEFUN MAPPING-TABLE-CALL-SLOT-MISSING (OPERATION OFFSET SEGMENT INSTANCE &REST OTHER)
  #+(OR Genera Cloe-Runtime) (DECLARE (DBG:ERROR-REPORTER))
  #+Minima
  (WHEN (AND (INSTANCEP INSTANCE)
	     (MEMBER (FIND-CLASS 'FUNCALLABLE-INSTANCE)
		     (%CLASS-INSTANCE-INFORMATION-PRECEDENCE-LIST
		       (%INSTANCE-INSTANCE-INFORMATION INSTANCE))))
    (SETF INSTANCE (%FUNCALLABLE-INSTANCE-FROM-DISPATCH-INSTANCE INSTANCE)))
  (APPLY
    #'SLOT-MISSING
    (CLASS-OF INSTANCE)
    INSTANCE
    (AREF (MAPPING-TABLE-FAMILY-MAP-DATA (MAPPING-TABLE-FAMILY SEGMENT))
	  (SEGMENT-AND-OFFSET-MAPPING-TABLE-FAMILY-INDEX SEGMENT OFFSET))
    OPERATION
    OTHER))

(DEFUN MAPPING-TABLE-CALL-SLOT-VALUE (OPERATION OFFSET SEGMENT INSTANCE &OPTIONAL NEW-VALUE)
  #+(OR Genera Cloe-Runtime) (DECLARE (DBG:ERROR-REPORTER))
  #+Minima
  (WHEN (AND (INSTANCEP INSTANCE)
	     (MEMBER (FIND-CLASS 'FUNCALLABLE-INSTANCE)
		     (%CLASS-INSTANCE-INFORMATION-PRECEDENCE-LIST
		       (%INSTANCE-INSTANCE-INFORMATION INSTANCE))))
    (SETF INSTANCE (%FUNCALLABLE-INSTANCE-FROM-DISPATCH-INSTANCE INSTANCE)))
  (LET ((SLOT-NAME (AREF (MAPPING-TABLE-FAMILY-MAP-DATA (MAPPING-TABLE-FAMILY SEGMENT))
			 (SEGMENT-AND-OFFSET-MAPPING-TABLE-FAMILY-INDEX SEGMENT OFFSET))))
    (COND ((EQ OPERATION 'SLOT-VALUE)
	   (SLOT-VALUE INSTANCE SLOT-NAME))
	  ((EQUAL (FIRST OPERATION) 'SETF)
	   (SETF (SLOT-VALUE INSTANCE SLOT-NAME) NEW-VALUE))
	  #+Genera
	  ((EQUAL (FIRST OPERATION) 'LOCF)
	   (LOCF (SLOT-VALUE INSTANCE SLOT-NAME)))
	  (T
	   (ERROR "Mapping tables broken")))))

(DEFUN MAPPING-TABLE-CALL-READER (OPERATION OFFSET SEGMENT INSTANCE)
  (DECLARE (IGNORE OPERATION)
	   #+(OR Genera Cloe-Runtime) (DBG:ERROR-REPORTER))
  #+Minima
  (WHEN (AND (INSTANCEP INSTANCE)
	     (MEMBER (FIND-CLASS 'FUNCALLABLE-INSTANCE)
		     (%CLASS-INSTANCE-INFORMATION-PRECEDENCE-LIST
		       (%INSTANCE-INSTANCE-INFORMATION INSTANCE))))
    (SETF INSTANCE (%FUNCALLABLE-INSTANCE-FROM-DISPATCH-INSTANCE INSTANCE)))
  (LET ((FCN (AREF (MAPPING-TABLE-FAMILY-MAP-DATA (MAPPING-TABLE-FAMILY SEGMENT))
		   (SEGMENT-AND-OFFSET-MAPPING-TABLE-FAMILY-INDEX SEGMENT OFFSET))))
    (FUNCALL (IF (FUNCTIONP FCN) FCN (FDEFINITION FCN)) INSTANCE)))

(DEFUN MAPPING-TABLE-CALL-WRITER (OPERATION OFFSET SEGMENT INSTANCE NEW-VALUE)
  (DECLARE (IGNORE OPERATION)
	   #+(OR Genera Cloe-Runtime) (DBG:ERROR-REPORTER))
  #+Minima
  (WHEN (AND (INSTANCEP INSTANCE)
	     (MEMBER (FIND-CLASS 'FUNCALLABLE-INSTANCE)
		     (%CLASS-INSTANCE-INFORMATION-PRECEDENCE-LIST
		       (%INSTANCE-INSTANCE-INFORMATION INSTANCE))))
    (SETF INSTANCE (%FUNCALLABLE-INSTANCE-FROM-DISPATCH-INSTANCE INSTANCE)))
  (LET ((FCN (AREF (MAPPING-TABLE-FAMILY-MAP-DATA (MAPPING-TABLE-FAMILY SEGMENT))
		   (SEGMENT-AND-OFFSET-MAPPING-TABLE-FAMILY-INDEX SEGMENT OFFSET))))
    (FUNCALL (IF (FUNCTIONP FCN) FCN (FDEFINITION FCN)) NEW-VALUE INSTANCE)))

#+(OR Genera Minima)
(DEFUN MAPPING-TABLE-CALL-LOCATOR (OPERATION OFFSET SEGMENT INSTANCE)
  (DECLARE (IGNORE OPERATION)
	   #+(OR Genera Cloe-Runtime) (DBG:ERROR-REPORTER))
  #+Minima
  (WHEN (AND (INSTANCEP INSTANCE)
	     (MEMBER (FIND-CLASS 'FUNCALLABLE-INSTANCE)
		     (%CLASS-INSTANCE-INFORMATION-PRECEDENCE-LIST
		       (%INSTANCE-INSTANCE-INFORMATION INSTANCE))))
    (SETF INSTANCE (%FUNCALLABLE-INSTANCE-FROM-DISPATCH-INSTANCE INSTANCE)))
  (LET ((FCN (AREF (MAPPING-TABLE-FAMILY-MAP-DATA (MAPPING-TABLE-FAMILY SEGMENT))
		   (SEGMENT-AND-OFFSET-MAPPING-TABLE-FAMILY-INDEX SEGMENT OFFSET))))
    (FUNCALL (IF (FUNCTIONP FCN) FCN (FDEFINITION FCN)) INSTANCE)))

(DEFUN INVALIDATE-MAPPING-TABLE (MAPPING-TABLE)
  (DOLIST (SEGMENT (MAPPING-TABLE-SEGMENTS MAPPING-TABLE))
    #+(OR Genera Minima)
    (FILL SEGMENT ':UPDATE :START *MAPPING-TABLE-OVERHEAD*)
    #-(OR Genera Minima)
    (LOOP FOR I FROM *MAPPING-TABLE-OVERHEAD*
		BELOW (+ *MAPPING-TABLE-OVERHEAD*
			 (MAPPING-TABLE-FAMILY-SIZE (MAPPING-TABLE-FAMILY MAPPING-TABLE)))
	  DOING
      (SETF (%MAPPING-TABLE-REF MAPPING-TABLE I) :UPDATE))
    (LET ((FAMILY (MAPPING-TABLE-FAMILY MAPPING-TABLE)))
      (WITH-NO-OTHER-PROCESSES
	(SETF (MAPPING-TABLE-FAMILY-MAPPING-TABLES FAMILY)
	      (DELETE MAPPING-TABLE (MAPPING-TABLE-FAMILY-MAPPING-TABLES FAMILY)))))))

;;; Adjust a mapping table for things which don't require instance updates.
(DEFUN UPDATE-MAPPING-TABLE (MAPPING-TABLE)
  (LET* ((FAMILY (MAPPING-TABLE-FAMILY MAPPING-TABLE))
	 (CLASSES (MAPPING-TABLE-CLASSES MAPPING-TABLE))
	 (MAP-DATA (MAPPING-TABLE-FAMILY-MAP-DATA FAMILY))
	 (MAP-BITS (MAPPING-TABLE-FAMILY-MAP-BITS FAMILY))
	 (SEGMENTS (MAPPING-TABLE-SEGMENTS MAPPING-TABLE)))
    (DECLARE (TYPE (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)) MAP-BITS)
	     (TYPE SIMPLE-VECTOR MAP-DATA))
    (LOOP FOR INDEX FROM 0 BELOW (MAPPING-TABLE-FAMILY-SIZE FAMILY)
	  FOR BITS = (AREF MAP-BITS INDEX)
	  FOR TYPE = (LDB %%MAP-BITS-TYPE BITS)
	  DOING
      (WHEN (OR (= TYPE %MAP-TYPE-SLOT)
		(= TYPE %MAP-TYPE-READER)
		(= TYPE %MAP-TYPE-WRITER)
		(= TYPE %MAP-TYPE-LOCATOR))
	;; Recompute this one
	(MULTIPLE-VALUE-BIND (SEGMENT-NUMBER OFFSET)
	    (MAPPING-TABLE-FAMILY-INDEX-SEGMENT-NUMBER-AND-OFFSET INDEX)
	  (LET ((SEGMENT (NTH SEGMENT-NUMBER SEGMENTS)))
	    (LET ((VALUE (%MAPPING-TABLE-REF SEGMENT OFFSET)))
	      (WHEN (PROGN
		      #+Genera
		      (OR (TYPEP VALUE 'LOCATIVE)
			  (TYPEP VALUE 'SYS:COMPILED-FUNCTION))
		      #+Minima
		      (OR (TYPEP VALUE 'LOCATIVE)
			  (TYPEP VALUE 'IVORY::COMPILED-CODE))
		      #-(OR Genera Minima)
		      (OR (TYPEP VALUE 'CONS)
			  (TYPEP VALUE 'COMPILED-FUNCTION)))
		;; Recompute this one
		(LET ((NEW-VALUE
			(COMPUTE-MAPPING-TABLE-ENTRY MAP-BITS MAP-DATA INDEX CLASSES)))
		  (UNLESS (TYPEP NEW-VALUE 'FIXNUM)
		    (SETF (%MAPPING-TABLE-REF SEGMENT OFFSET) NEW-VALUE)))))))))))

(DEFUN UPDATE-MAPPING-TABLE-FAMILY-FOR-GENERIC-FUNCTION (FAMILY GENERIC-FUNCTION)
  (LET ((MAP-DATA (MAPPING-TABLE-FAMILY-MAP-DATA FAMILY))
	(MAP-BITS (MAPPING-TABLE-FAMILY-MAP-BITS FAMILY)))
    (DECLARE (TYPE (SIMPLE-ARRAY (UNSIGNED-BYTE 8) (*)) MAP-BITS)
	     (TYPE SIMPLE-VECTOR MAP-DATA))
    (LOOP FOR INDEX FROM 0 BELOW (MAPPING-TABLE-FAMILY-SIZE FAMILY)
	  FOR BITS = (AREF MAP-BITS INDEX)
	  FOR TYPE = (LDB %%MAP-BITS-TYPE BITS)
	  FOR DATA = (AREF MAP-DATA INDEX)
	  DO
      (WHEN (AND (OR (= TYPE %MAP-TYPE-READER)
		     (= TYPE %MAP-TYPE-WRITER)
		     (= TYPE %MAP-TYPE-LOCATOR))
		 (COND ((FUNCTIONP DATA)
			(EQ GENERIC-FUNCTION DATA))
		       ((FUNCTIONP GENERIC-FUNCTION)
			(AND (FBOUNDP DATA)
			     (EQ GENERIC-FUNCTION (FDEFINITION DATA))))
		       (T
			(EQUAL DATA GENERIC-FUNCTION))))
	;; Recompute this one
	(MULTIPLE-VALUE-BIND (SEGMENT-NUMBER OFFSET)
	    (MAPPING-TABLE-FAMILY-INDEX-SEGMENT-NUMBER-AND-OFFSET INDEX)
	  (DOLIST (MAPPING-TABLE (MAPPING-TABLE-FAMILY-MAPPING-TABLES FAMILY))
	    (SETF (%MAPPING-TABLE-REF (NTH SEGMENT-NUMBER (MAPPING-TABLE-SEGMENTS MAPPING-TABLE)) OFFSET)
		  (COMPUTE-MAPPING-TABLE-ENTRY MAP-BITS MAP-DATA INDEX
					       (MAPPING-TABLE-CLASSES MAPPING-TABLE)))))))))



(DEFUN CLOS-ERROR (FORMAT-CONTROL &REST FORMAT-ARGUMENTS)
  (APPLY #'ERROR FORMAT-CONTROL FORMAT-ARGUMENTS))

(DEFUN CLOS-MAKE-HASH-TABLE (&REST KEYS &KEY (TEST #'EQL))
  (DECLARE (IGNORE #+(OR Genera Cloe-Runtime) TEST))
  #+(OR Genera Cloe-Runtime)
  (APPLY #'MAKE-HASH-TABLE KEYS)
  #-(OR Genera Cloe-Runtime)
  (IF (FBOUNDP 'MAKE-HASH-TABLE)
      (APPLY #'MAKE-HASH-TABLE KEYS)
      (CONS TEST NIL)))

(DEFUN CLOS-GETHASH (KEY TABLE &OPTIONAL DEFAULT)
  #+(OR Genera Cloe-Runtime)
  (GETHASH KEY TABLE DEFAULT)
  #-(OR Genera Cloe-Runtime)
  (IF (CONSP TABLE)
      (LET ((ENTRY (ASSOC KEY (CDR TABLE) :TEST (CAR TABLE))))
	(IF ENTRY (CDR ENTRY) DEFAULT))
      (GETHASH KEY TABLE DEFAULT)))

(DEFUN (SETF CLOS-GETHASH) (VALUE KEY TABLE &OPTIONAL DEFAULT)
  #+(OR Genera Cloe-Runtime)
  (SETF (GETHASH KEY TABLE DEFAULT) VALUE)
  #-(OR Genera Cloe-Runtime)
  (IF (CONSP TABLE)
      (LET ((ENTRY (ASSOC KEY (CDR TABLE) :TEST (CAR TABLE))))
	(IF ENTRY
	    (SETF (CDR ENTRY) VALUE)
	    (PUSH (CONS KEY VALUE) (CDR TABLE)))
	VALUE)
      (SETF (GETHASH KEY TABLE DEFAULT) VALUE)))

(DEFUN CLOS-REMHASH (KEY TABLE)
  #+(OR Genera Cloe-Runtime)
  (REMHASH KEY TABLE)
  #-(OR Genera Cloe-Runtime)
  (IF (CONSP TABLE)
      (LET ((ENTRY (ASSOC KEY (CDR TABLE) :TEST (CAR TABLE))))
	(WHEN ENTRY
	  (SETF (CDR TABLE) (DELETE ENTRY (CDR TABLE)))
	  T))
      (REMHASH KEY TABLE)))

(DEFUN CLOS-CLRHASH (TABLE)
  #+(OR Genera Cloe-Runtime)
  (CLRHASH TABLE)
  #-(OR Genera Cloe-Runtime)
  (IF (CONSP TABLE)
      (PROGN (SETF (CDR TABLE) NIL)
	     TABLE)
      (CLRHASH TABLE)))



(DEFVAR *FUNCTION-MAPPING-TABLE-FAMILIES* (CLOS-MAKE-HASH-TABLE :TEST #'EQUAL))

(DEFUN ADD-FUNCTION-MAPPING-TABLE-FAMILY (FUNCTION FAMILY)
  (PUSHNEW FAMILY (CLOS-GETHASH FUNCTION *FUNCTION-MAPPING-TABLE-FAMILIES*))
  (WHEN (AND (NOT (FUNCTIONP FUNCTION))
	     (FBOUNDP FUNCTION))
    (LET ((FUNCTION (FDEFINITION FUNCTION)))
      (WHEN (GENERIC-FUNCTION-P FUNCTION)
	(PUSHNEW FAMILY (CLOS-GETHASH FUNCTION *FUNCTION-MAPPING-TABLE-FAMILIES*)))))
  NIL)

(DEFUN FUNCTION-MAPPING-TABLE-FAMILIES (FUNCTION)
  (VALUES (CLOS-GETHASH FUNCTION *FUNCTION-MAPPING-TABLE-FAMILIES*)))
