;;; -*- Mode: LISP; Syntax: ANSI-Common-Lisp; Base: 10; Package: CLOS-INTERNALS -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(IN-PACKAGE :CLOS-INTERNALS)

(DEFMETHOD DOCUMENTATION ((OBJECT T) &OPTIONAL (DOC-TYPE NIL DOC-P))
  (DECLARE (IGNORE DOC-TYPE))
  (WHEN DOC-P
    (ERROR "DOC-TYPE argument may not be supplied"))
  (DOCUMENTATION-OBJECT OBJECT))

(DEFMETHOD (SETF DOCUMENTATION) (NEW-VALUE (OBJECT T) &OPTIONAL (DOC-TYPE NIL DOC-P))
  (DECLARE (IGNORE DOC-TYPE))
  (WHEN DOC-P
    (ERROR "DOC-TYPE argument may not be supplied"))
  (SETF (DOCUMENTATION-OBJECT OBJECT) NEW-VALUE))

(DEFMETHOD DOCUMENTATION ((SYMBOL SYMBOL) &OPTIONAL DOC-TYPE)
  (ECASE DOC-TYPE
    ((METHOD-COMBINATION)
     (DOCUMENTATION-OBJECT (FIND-METHOD-COMBINATION-DEFINITION SYMBOL)))
    #+Genera
    ((COMPILER-MACRO)
     (LISP:DOCUMENTATION `(COMPILER:COMPILER-MACRO ,SYMBOL) 'LISP:FUNCTION))
    #+Genera
    ((FUNCTION VARIABLE STRUCTURE TYPE SETF)
     (LISP:DOCUMENTATION SYMBOL (CASE DOC-TYPE
				  ((FUNCTION) 'LISP:FUNCTION)
				  ((VARIABLE) 'LISP:VARIABLE)
				  ((STRUCTURE) 'LISP:STRUCTURE)
				  ((TYPE) 'LISP:TYPE)
				  ((SETF) 'LISP:SETF))))
    #+CLOE-Runtime
    ((FUNCTION VARIABLE TYPE SETF)
     (GETF (SYSTEM::SYS%GET SYMBOL 'DOCUMENTATION) DOC-TYPE))
    #+CLOE-Runtime
    ((STRUCTURE)
     (LET ((DSINFO (SYSTEM::SYS%GET SYMBOL 'SYSTEM::DEFSTRUCT-INFORMATION)))
       (AND DSINFO (GETF (SYSTEM::DSINFO-PLIST DSINFO) 'DOCUMENTATION))))
    #+Minima
    ((FUNCTION VARIABLE STRUCTURE TYPE SETF COMPILER-MACRO)
     (GETF (GET SYMBOL 'DOCUMENTATION) DOC-TYPE))))

(DEFMETHOD DOCUMENTATION ((LIST LIST) &OPTIONAL DOC-TYPE)
  (ECASE DOC-TYPE
    #+Genera
    ((FUNCTION)
     (LISP:DOCUMENTATION LIST 'LISP:FUNCTION))
    #+Genera
    ((COMPILER-MACRO)
     (LISP:DOCUMENTATION `(COMPILER:COMPILER-MACRO ,LIST) 'LISP:FUNCTION))
    #+CLOE-Runtime
    ((FUNCTION)
     (SYSTEM::FUNCTION-NAME-GET LIST 'DOCUMENTATION))
    #+Minima
    ((FUNCTION COMPILER-MACRO)
     (GETF (GETF (MINIMA-INTERNALS::FUNCTION-NAME-PLIST LIST) 'DOCUMENTATION) DOC-TYPE))))

(DEFMETHOD (SETF DOCUMENTATION) (NEW-VALUE (SYMBOL SYMBOL) &OPTIONAL DOC-TYPE)
  (CHECK-TYPE NEW-VALUE (OR STRING NULL))
  (ECASE DOC-TYPE
    ((METHOD-COMBINATION)
     (SETF (DOCUMENTATION-OBJECT (FIND-METHOD-COMBINATION-DEFINITION SYMBOL)) NEW-VALUE))
    #+Genera
    ((COMPILER-MACRO)
     (SETF (LISP:DOCUMENTATION `(COMPILER:COMPILER-MACRO ,SYMBOL) 'LISP:FUNCTION) NEW-VALUE))
    #+Genera
    ((FUNCTION VARIABLE STRUCTURE TYPE SETF)
     (SETF (LISP:DOCUMENTATION SYMBOL (CASE DOC-TYPE
					((FUNCTION) 'LISP:FUNCTION)
					((VARIABLE) 'LISP:VARIABLE)
					((STRUCTURE) 'LISP:STRUCTURE)
					((TYPE) 'LISP:TYPE)
					((SETF) 'LISP:SETF)))
	   NEW-VALUE))
    #+CLOE-Runtime
    ((FUNCTION VARIABLE TYPE SETF)
     (IF NEW-VALUE 
	 (SETF (GETF (SYSTEM::SYS%GET SYMBOL 'DOCUMENTATION) DOC-TYPE) NEW-VALUE)
	 (REMF (SYSTEM::SYS%GET SYMBOL 'DOCUMENTATION) DOC-TYPE))
     NEW-VALUE)
    #+CLOE-Runtime
    ((STRUCTURE)
     (LET ((DSINFO (SYSTEM::SYS%GET SYMBOL 'SYSTEM::DEFSTRUCT-INFORMATION)))
       (IF DSINFO
	   (IF NEW-VALUE
	       (SETF (GETF (SYSTEM::DSINFO-PLIST DSINFO) 'DOCUMENTATION) NEW-VALUE)
	       (REMF (SYSTEM::DSINFO-PLIST DSINFO) 'DOCUMENTATION))))
     NEW-VALUE)
    #+Minima
    ((FUNCTION VARIABLE STRUCTURE TYPE SETF COMPILER-MACRO)
     (IF NEW-VALUE
	 (SETF (GETF (GET SYMBOL 'DOCUMENTATION) DOC-TYPE) NEW-VALUE)
	 (PROGN
	   (REMF (GET SYMBOL 'DOCUMENTATION) DOC-TYPE)
	   (WHEN (NULL (GET SYMBOL 'DOCUMENTATION))
	     (REMPROP SYMBOL 'DOCUMENTATION))))
     NEW-VALUE)))

(DEFMETHOD (SETF DOCUMENTATION) (NEW-VALUE (LIST LIST) &OPTIONAL DOC-TYPE)
  (CHECK-TYPE NEW-VALUE (OR STRING NULL))
  (ECASE DOC-TYPE
    #+Genera
    ((COMPILER-MACRO)
     (SETF (LISP:DOCUMENTATION `(COMPILER:COMPILER-MACRO ,LIST) 'LISP:FUNCTION) NEW-VALUE))
    #+Genera
    ((FUNCTION)
     (SETF (LISP:DOCUMENTATION LIST 'LISP:FUNCTION) NEW-VALUE))
    #+CLOE-Runtime
    ((FUNCTION)
     (SETF (SYSTEM::FUNCTION-NAME-GET LIST 'DOCUMENTATION) NEW-VALUE))
    #+Minima
    ((FUNCTION COMPILER-MACRO)
     (IF NEW-VALUE
	 (SETF (GETF (GETF (MINIMA-INTERNALS::FUNCTION-NAME-PLIST LIST) 'DOCUMENTATION)
		     DOC-TYPE)
	       NEW-VALUE)
	 (PROGN
	   (REMF (GETF (MINIMA-INTERNALS::FUNCTION-NAME-PLIST LIST) 'DOCUMENTATION) DOC-TYPE)
	   (WHEN (NULL (GETF (MINIMA-INTERNALS::FUNCTION-NAME-PLIST LIST) 'DOCUMENTATION))
	     (REMF (MINIMA-INTERNALS::FUNCTION-NAME-PLIST LIST) 'DOCUMENTATION))))
     NEW-VALUE)))

;;;

#+Genera
(DEFMETHOD DOCUMENTATION-OBJECT ((FUNCTION FUNCTION))
  (LISP:DOCUMENTATION FUNCTION 'LISP:FUNCTION))

#+Genera
(DEFMETHOD (SETF DOCUMENTATION-OBJECT) (NEW-VALUE (FUNCTION FUNCTION))
  (SETF (LISP:DOCUMENTATION FUNCTION 'LISP:FUNCTION) NEW-VALUE))

#+Genera
(DEFMETHOD DOCUMENTATION-OBJECT ((PACKAGE PACKAGE))
  (VALUES (GETHASH (PACKAGE-NAME PACKAGE) FCLI::*PACKAGE-DOCUMENTATION*)))

#+Genera
(DEFMETHOD (SETF DOCUMENTATION-OBJECT) (NEW-VALUE (PACKAGE PACKAGE))
  (IF NEW-VALUE
      (SETF (GETHASH (PACKAGE-NAME PACKAGE) FCLI::*PACKAGE-DOCUMENTATION*) NEW-VALUE)
      (REMHASH (PACKAGE-NAME PACKAGE) FCLI::*PACKAGE-DOCUMENTATION*))
  NEW-VALUE)

#-Genera
(DEFMETHOD DOCUMENTATION-OBJECT ((GENERIC STANDARD-GENERIC-FUNCTION))
  (SECOND (ASSOC ':DOCUMENTATION (SLOT-VALUE GENERIC 'DEBUGGING-INFO))))

#-Genera
(DEFMETHOD (SETF DOCUMENTATION-OBJECT) (NEW-VALUE (GENERIC STANDARD-GENERIC-FUNCTION))
  (LET ((OLD (ASSOC ':DOCUMENTATION (SLOT-VALUE GENERIC 'DEBUGGING-INFO))))
    (IF OLD
	(SETF (SECOND OLD) NEW-VALUE)
	(PUSH (LIST ':DOCUMENTATION NEW-VALUE)
	      (SLOT-VALUE GENERIC 'DEBUGGING-INFO))))
  NEW-VALUE)

(DEFGENERIC DEBUGGING-INFORMATION-FUNCTION (FUNCTION))

#+Genera
(DEFVAR *DECL-TYPES-INHERITED-FROM-METHOD*
	'(VALUES SYS:DOWNWARD-FUNARG))

(DEFMETHOD DEBUGGING-INFORMATION-FUNCTION ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION))
  (IF (GENERIC-FUNCTION-EXPLICITLY-DEFINED-P GENERIC-FUNCTION)
      (SLOT-VALUE GENERIC-FUNCTION 'DEBUGGING-INFO)
      (PROGN
	#+Genera
	(LET ((RESULT NIL))
	  (LOOP FOR METHOD IN (GENERIC-FUNCTION-METHODS GENERIC-FUNCTION)
		FOR FUNCTION = (METHOD-FUNCTION METHOD)
		UNTIL RESULT
		DOING
	    (WHEN FUNCTION
	      (LET ((DEBUG-INFO (SI:DEBUGGING-INFO FUNCTION)))
		(DOLIST (DECL-SPEC DEBUG-INFO)
		  (LET ((DECL-TYPE (FIRST DECL-SPEC)))
		    (IF (OR (MEMBER DECL-TYPE *DECL-TYPES-INHERITED-FROM-METHOD*)
			    ;; In order to make things complicated, if just an
			    ;; SCL:ARGLIST decl-spec appears, it is derived from
			    ;; the lambda list, which is not the right thing to
			    ;; inherit from the method.  However, if there is a
			    ;; SYS:REAL-ARGLIST decl-spec, then the SCL:ARGLIST comes
			    ;; from an SCL:ARGLIST declaration, and should be used.
			    (AND (EQ DECL-TYPE 'SCL:ARGLIST)
				 (ASSOC 'SYS:REAL-ARGLIST DEBUG-INFO)))
			(PUSH DECL-SPEC RESULT)))))))
	  RESULT)
	#-Genera
	NIL)))

(DEFMETHOD DEBUGGING-INFORMATION-FUNCTION ((GENERIC-FUNCTION FUNCALLABLE-INSTANCE))
  NIL)

(DEFMETHOD REMOVE-METHOD ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
			  (METHOD STANDARD-METHOD))
  (WITH-CLOS-LOCK
    (WHEN (MEMBER METHOD (GENERIC-FUNCTION-METHODS GENERIC-FUNCTION))
      (SETF (SLOT-VALUE METHOD 'GENERIC-FUNCTION) NIL)
      (SETF (SLOT-VALUE GENERIC-FUNCTION 'METHODS)
	    (REMOVE METHOD (GENERIC-FUNCTION-METHODS GENERIC-FUNCTION)))
      (SETF (SLOT-VALUE GENERIC-FUNCTION 'INITIAL-METHODS)
	    (REMOVE METHOD (GENERIC-FUNCTION-INITIAL-METHODS GENERIC-FUNCTION)))
      (DOLIST (SPECIALIZER (METHOD-SPECIALIZERS METHOD))
	(REMOVE-DIRECT-METHOD SPECIALIZER METHOD))
      (NOTE-GENERIC-FUNCTION-METHOD-CHANGE GENERIC-FUNCTION METHOD :REMOVE)
      (UNLESS *INHIBIT-DISPATCH-CACHE-UPDATING*
	;; This class is being redefined.  Save the cache changes until the class
	;; gets finalized again (this reduces work, and makes metaclass redefinition
	;; possible).
	(WHEN (OR (EQ GENERIC-FUNCTION *SHARED-INITIALIZE*)
		  (EQ GENERIC-FUNCTION *INITIALIZE-INSTANCE*))
	  (UPDATE-CLASS-INITIALIZATION-INFORMATION METHOD))
	(WHEN (OR (EQ GENERIC-FUNCTION *MAKE-INSTANCE*)
		  (EQ GENERIC-FUNCTION *ALLOCATE-INSTANCE*))
	  (UPDATE-METACLASS-INITIALIZATION-INFORMATION METHOD))
	(UPDATE-DISPATCHES GENERIC-FUNCTION #'STANDARD-METHOD-COMBINER))))
  GENERIC-FUNCTION)

(DEFMETHOD FIND-METHOD ((GENERIC-FUNCTION STANDARD-GENERIC-FUNCTION)
			METHOD-QUALIFIERS
			SPECIALIZERS
			&OPTIONAL
			(ERRORP T))
  (UNLESS (EVERY #'VALID-SPECIALIZER-P SPECIALIZERS)
    (ERROR "~s is not a valid specializer"
	   (FIND-IF-NOT #'VALID-SPECIALIZER-P SPECIALIZERS)))
  (UNLESS (= (LENGTH SPECIALIZERS)
	     (LENGTH (DISPATCHING-FUNCALLABLE-INSTANCE-PRECEDENCE-ORDER GENERIC-FUNCTION)))
    (ERROR "~s requires ~s argument specializer~p"
	   GENERIC-FUNCTION
	   (LENGTH (DISPATCHING-FUNCALLABLE-INSTANCE-PRECEDENCE-ORDER GENERIC-FUNCTION))
	   (LENGTH (DISPATCHING-FUNCALLABLE-INSTANCE-PRECEDENCE-ORDER GENERIC-FUNCTION))))
  (DOLIST (METHOD (GENERIC-FUNCTION-METHODS GENERIC-FUNCTION))
    (WHEN (AND (EQUIVALENT-SPECIALIZER-LISTS-P (METHOD-SPECIALIZERS METHOD) SPECIALIZERS)
	       (EQUIVALENT-QUALIFIERS-P (METHOD-QUALIFIERS METHOD) METHOD-QUALIFIERS))
      (RETURN-FROM FIND-METHOD METHOD)))
  (WHEN ERRORP
    (ERROR "No matching method")))

(DEFMETHOD GENERIC-FUNCTION-ARGUMENT-PRECEDENCE-ORDER ((GENERIC-FUNCTION GENERIC-FUNCTION))
  (LET ((LAMBDA-LIST (GENERIC-FUNCTION-LAMBDA-LIST GENERIC-FUNCTION)))
    (MAPCAR #'(LAMBDA (N) (NTH N LAMBDA-LIST))
	    (DISPATCHING-FUNCALLABLE-INSTANCE-PRECEDENCE-ORDER GENERIC-FUNCTION))))

(DEFMETHOD SHARED-INITIALIZE :AFTER
	   ((METHOD STANDARD-METHOD)
	    (SLOT-NAMES T)
	    &KEY
	    (LAMBDA-LIST NIL LAMBDA-LIST-P)
	    QUALIFIERS
	    (SPECIALIZERS NIL SPECIALIZERSP)
	    FUNCTION
	    ((NO-NEXT-METHOD-INFORMATION NO-NEXT-METHOD-INFORMATION) NIL)
	    DOCUMENTATION
	    #-(OR Genera Minima)
	    ((METHOD-MAPPING-TABLE-FAMILY METHOD-MAPPING-TABLE-FAMILY)
	     NIL METHOD-MAPPING-TABLE-FAMILY-P)
	    ((INITIALIZATION-TYPE INITIALIZATION-TYPE) NIL))
  (WHEN INITIALIZATION-TYPE
    (RETURN-FROM SHARED-INITIALIZE NIL))
  (WHEN (AND DOCUMENTATION (NOT (STRINGP DOCUMENTATION)))
    (ERROR ":DOCUMENTATION must be a string"))
  (WHEN (NOT LAMBDA-LIST-P)
    (ERROR ":LAMBDA-LIST must be supplied"))
  (UNLESS SPECIALIZERSP
    (ERROR ":SPECIALIZERS must be specified"))
  (SETF (SLOT-VALUE METHOD 'LAMBDA-LIST) LAMBDA-LIST)
  (SETF (SLOT-VALUE METHOD 'QUALIFIERS) QUALIFIERS)
  (SETF (SLOT-VALUE METHOD 'SPECIALIZERS) SPECIALIZERS)
  #+Genera
  (LET ((REAL-FUNCTION (FUNCTION-REAL-FUNCTION FUNCTION)))
    (TYPECASE REAL-FUNCTION
      (SYS:COMPILED-FUNCTION
	;; Get some information out of the debugging information
	(LET ((NAME (CAR (SYS:CCA-EXTRA-INFO (SYS:COMPILED-FUNCTION-CCA REAL-FUNCTION)))))
	  (TYPECASE NAME
	    (METHOD
	      ;; This function is shared by several methods.
	      (SETF (SLOT-VALUE METHOD 'FUNCTION-PARENT)
		    (SLOT-VALUE NAME 'FUNCTION-PARENT)))
	    (OTHERWISE
	      (SETF (SLOT-VALUE METHOD 'FUNCTION-PARENT)
		    (AND (SYS:VALIDATE-FUNCTION-SPEC NAME) NAME))))))
      (FUNCTION
	(LET ((NAME (SYS:FUNCTION-NAME REAL-FUNCTION)))
	  (SETF (SLOT-VALUE METHOD 'FUNCTION-PARENT)
		(AND (SYS:VALIDATE-FUNCTION-SPEC NAME) NAME))))))
  #-(OR Genera Minima)
  (WHEN METHOD-MAPPING-TABLE-FAMILY-P
    (SETF (SLOT-VALUE METHOD 'MAPPING-TABLE-FAMILY) METHOD-MAPPING-TABLE-FAMILY))
  (WHEN DOCUMENTATION
    (SETF (DOCUMENTATION METHOD) DOCUMENTATION))
  (SETF (SLOT-VALUE METHOD 'NO-NEXT-METHOD-INFORMATION) NO-NEXT-METHOD-INFORMATION)
  (WHEN FUNCTION
    (SETF (FDEFINITION-IN-ENVIRONMENT METHOD NIL) FUNCTION)))


(DEFMETHOD SHARED-INITIALIZE :AFTER
	   ((METHOD STANDARD-ACCESSOR-METHOD)
	    (SLOTS T)
	    &KEY
	    SLOT-NAME
	    ((INITIALIZATION-TYPE INITIALIZATION-TYPE) NIL))
  (WHEN INITIALIZATION-TYPE
    (RETURN-FROM SHARED-INITIALIZE NIL))
  (SETF (SLOT-VALUE METHOD 'SLOT-NAME) SLOT-NAME))



(DEFMETHOD REINITIALIZE-INSTANCE
	   ((METHOD METHOD) &REST REST)
  (DECLARE (IGNORE REST))
  (ERROR "Methods may not be redefined"))

(DEFMETHOD REINITIALIZE-INSTANCE
	   ((METHOD-COMBINATION METHOD-COMBINATION) &REST REST)
  (DECLARE (IGNORE REST))
  (ERROR "Method combinations may not be redefined"))
