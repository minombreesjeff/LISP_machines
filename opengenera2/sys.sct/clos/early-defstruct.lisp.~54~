;;; -*- Mode: LISP; Syntax: ANSI-Common-Lisp; Base: 10; Package: CLOS-INTERNALS -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

;;; This file has all the code you need to load structure definitions into the world.

(IN-PACKAGE :CLOS-INTERNALS)

;;; First, some world-size reduction stuff for Genera.

#+(OR Genera Cloe-Runtime Minima)
(MACROLET ((DEFINE-DEFSTRUCT-STANDARD-ACCESSORS (TYPE-NAME ACCESS-MACRO N)
	     (FLET ((FINTERN (&REST ARGS)
		      (INTERN (APPLY #'FORMAT NIL ARGS) *PACKAGE*)))
	       (LET ((VAR-NAME (FINTERN "*DEFSTRUCT-~A-ACCESSORS*" TYPE-NAME)))
		 `(PROGN
		    ,@(LOOP FOR I BELOW N
			    COLLECT (LET ((READ (FINTERN "DEFSTRUCT-~A-READ-~D" TYPE-NAME I))
					  (WRITE (FINTERN "DEFSTRUCT-~A-WRITE-~D" TYPE-NAME I))
					  #+(OR Genera Minima)
					  (LOCATE (FINTERN "DEFSTRUCT-~A-LOCATE-~D" TYPE-NAME I)))
				      `(PROGN
					 (DECLAIM (FTYPE (FUNCTION (,TYPE-NAME) T) ,READ) (INLINE ,READ))
					 (DEFUN ,READ (STRUCTURE)
					   (,ACCESS-MACRO STRUCTURE ,I))
					 (DECLAIM (FTYPE (FUNCTION (T ,TYPE-NAME) T) ,WRITE)
						  (INLINE ,WRITE))
					 (DEFUN ,WRITE (VALUE STRUCTURE)
					   (SETF (,ACCESS-MACRO STRUCTURE ,I) VALUE))
					 #+(OR Genera Minima)
					 (DECLAIM (FTYPE (FUNCTION (,TYPE-NAME) LOCATIVE) ,LOCATE)
						  (INLINE ,LOCATE))
					 #+(OR Genera Minima)
					 (DEFUN ,LOCATE (STRUCTURE)
					   (LOCF (,ACCESS-MACRO STRUCTURE ,I))))))
		    (DEFPARAMETER ,VAR-NAME
				  (VECTOR
				    ,@(LOOP FOR I BELOW N
					    COLLECT
					      ``(,#',(FINTERN "DEFSTRUCT-~A-READ-~D" TYPE-NAME I)
						 ,#',(FINTERN "DEFSTRUCT-~A-WRITE-~D" TYPE-NAME I)
						 #+(OR Genera Minima)
						 ,#',(FINTERN "DEFSTRUCT-~A-LOCATE-~D" TYPE-NAME I)))))
		    (DEFUN ,(FINTERN "MAKE-DEFSTRUCT-~A-READER" TYPE-NAME) (OFFSET)
		      (IF (< OFFSET ,N)
			  (FIRST (AREF ,VAR-NAME OFFSET))
			  (PROGN
			    #+Genera
			    (SYS:MAKE-LEXICAL-CLOSURE OFFSET #'(LAMBDA (OFFSET STRUCTURE)
								 (,ACCESS-MACRO STRUCTURE OFFSET)))
			    #-Genera
			    #'(LAMBDA (STRUCTURE) (,ACCESS-MACRO STRUCTURE OFFSET)))))
		    (DEFUN ,(FINTERN "MAKE-DEFSTRUCT-~A-WRITER" TYPE-NAME) (OFFSET)
		      (IF (< OFFSET ,N)
			  (SECOND (AREF ,VAR-NAME OFFSET))
			  (PROGN
			    #+Genera
			    (SYS:MAKE-LEXICAL-CLOSURE
			      OFFSET #'(LAMBDA (OFFSET VALUE STRUCTURE)
					 (SETF (,ACCESS-MACRO STRUCTURE OFFSET) VALUE)))
			    #-Genera
			    #'(LAMBDA (VALUE STRUCTURE)
				(SETF (,ACCESS-MACRO STRUCTURE OFFSET) VALUE)))))
		    #+(OR Genera Minima)
		    (DEFUN ,(FINTERN "MAKE-DEFSTRUCT-~A-LOCATOR" TYPE-NAME) (OFFSET)
		      (IF (< OFFSET ,N)
			  (THIRD (AREF ,VAR-NAME OFFSET))
			  #+Genera
			  (SYS:MAKE-LEXICAL-CLOSURE OFFSET #'(LAMBDA (OFFSET STRUCTURE)
							       (SYS:LOCF (,ACCESS-MACRO STRUCTURE OFFSET))))
			  #-Genera
			  #'(LAMBDA (STRUCTURE) (LOCF (,ACCESS-MACRO STRUCTURE OFFSET)))))
		    )))))

  (DEFINE-DEFSTRUCT-STANDARD-ACCESSORS STRUCTURE-OBJECT %STRUCTURE-REF 16)

  (DEFINE-DEFSTRUCT-STANDARD-ACCESSORS LIST DEFSTRUCT-LIST-REF 8)

  (DEFINE-DEFSTRUCT-STANDARD-ACCESSORS VECTOR AREF 16)
  )

;;;

#+(OR Genera Cloe-Runtime Minima)
(DEFUN DEF-DEFSTRUCT-ACCESSOR-1 (FSPEC TYPE REF-MACRO LOCATION)
  #+Cloe-Runtime (COND ((SYMBOLP FSPEC)
			(SETF (SYS::FUNCTION-NAME-GET FSPEC 'COMPILER::REDUCER)
			      '(CLOS-DEFSTRUCT-FETCH-REDUCER))
			(SETF (SYS::FUNCTION-NAME-GET FSPEC 'ACCESS-INFO)
			      `(,LOCATION . ,REF-MACRO)))
		       (T
			(SETF (SYS::FUNCTION-NAME-GET (SECOND FSPEC) 'SETF)
			      `(CLOS-STRUCTURE-SLOT-STORE (,LOCATION . ,REF-MACRO)))))
  #-Cloe-Runtime (SETF (COMPILER-MACRO-FUNCTION FSPEC)
		       (MAKE-ACCESSOR-COMPILER-MACRO FSPEC REF-MACRO LOCATION))
  (SETF (FDEFINITION FSPEC)
	(IF (SYMBOLP FSPEC)
	    (ECASE TYPE
	      (STRUCTURE-OBJECT (MAKE-DEFSTRUCT-STRUCTURE-OBJECT-READER LOCATION))
	      (LIST (MAKE-DEFSTRUCT-LIST-READER LOCATION))
	      (VECTOR (MAKE-DEFSTRUCT-VECTOR-READER LOCATION)))
	    (ECASE (CAR FSPEC)
	      ((SETF)
	       (ECASE TYPE
		 (STRUCTURE-OBJECT (MAKE-DEFSTRUCT-STRUCTURE-OBJECT-WRITER LOCATION))
		 (LIST (MAKE-DEFSTRUCT-LIST-WRITER LOCATION))
		 (VECTOR (MAKE-DEFSTRUCT-VECTOR-WRITER LOCATION))))
	      #+(OR Genera Minima)
	      ((LOCF)
	       (ECASE TYPE
		 (STRUCTURE-OBJECT (MAKE-DEFSTRUCT-STRUCTURE-OBJECT-LOCATOR LOCATION))
		 (LIST (MAKE-DEFSTRUCT-LIST-LOCATOR LOCATION))
		 (VECTOR (MAKE-DEFSTRUCT-VECTOR-LOCATOR LOCATION)))))))
  FSPEC)

#+(OR Genera Minima)
(DEFUN MAKE-ACCESSOR-COMPILER-MACRO (FSPEC REF-MACRO LOCATION)
  (IF (SYMBOLP FSPEC)
      #'(LAMBDA (FORM ENV)
	  (DECLARE (IGNORE ENV))
	  (IF (= (LENGTH FORM) 2)
	      `(,REF-MACRO ,(SECOND FORM) ,LOCATION)
	      FORM))
      (ECASE (CAR FSPEC)
	((SETF)
	 #'(LAMBDA (FORM ENV)
	     (DECLARE (IGNORE ENV))
	     (IF (= (LENGTH FORM) 4)
		 `(SETF (,REF-MACRO ,(FOURTH FORM) ,LOCATION) ,(THIRD FORM))
		 FORM)))
	#+(OR GENERA MINIMA)
	((LOCF)
	 #'(LAMBDA (FORM ENV)
	     (DECLARE (IGNORE ENV))
	     (IF (= (LENGTH FORM) 3)
		 `(LOCF (,REF-MACRO ,(THIRD FORM) ,LOCATION))
		 FORM))))))



(DEFVAR *FORWARD-REFERENCED-STRUCTURE-CLASSES* NIL)

(DEFUN ENSURE-DEFSTRUCT (NAME &REST ARGS)
  (LET ((ENTRY (ASSOC NAME *FORWARD-REFERENCED-STRUCTURE-CLASSES*)))
    (COND ((FBOUNDP 'ENSURE-DEFSTRUCT-1)
	   (PROG1 (LET ((OLD-INSTANCE-INFORMATION (AND ENTRY (SECOND ENTRY))))
		    (IF OLD-INSTANCE-INFORMATION
			(APPLY #'ENSURE-DEFSTRUCT-1 NAME (POP ARGS) (POP ARGS) (POP ARGS)
			       'INSTANCE-INFORMATION OLD-INSTANCE-INFORMATION
			       ARGS)
			(APPLY #'ENSURE-DEFSTRUCT-1 NAME ARGS)))
		  (WHEN ENTRY
		    (SETF *FORWARD-REFERENCED-STRUCTURE-CLASSES*
			  (DELETE ENTRY *FORWARD-REFERENCED-STRUCTURE-CLASSES*)))))
	  (T
	   #+(OR Genera Minima) (SETF ARGS (COPY-LIST ARGS))
	   (IF ENTRY
	       (SETF (CDDR ENTRY) ARGS)
	       (PUSH (LIST* NAME NIL ARGS) *FORWARD-REFERENCED-STRUCTURE-CLASSES*))
	   NAME))))

(DEFUN ENSURE-DEFSTRUCT-COMPILE (NAME TYPE INCLUDED-STRUCTURE ENVIRONMENT &REST ARGS)
  (COND ((FBOUNDP 'ENSURE-DEFSTRUCT-1)
	 (APPLY #'ENSURE-DEFSTRUCT-1 NAME TYPE INCLUDED-STRUCTURE ENVIRONMENT ARGS))
	(T
	 #+(OR Genera Minima) (SETF ARGS (COPY-LIST ARGS))
	 (SETF ARGS (LIST* TYPE INCLUDED-STRUCTURE ENVIRONMENT ARGS))
	 (SETF (FILE-DECLARATION NAME 'EARLY-DEFSTRUCT) ARGS))))

(DEFUN LOOKUP-STRUCTURE-INFORMATION (NAME ENVIRONMENT)
  (WHEN (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
    (LET ((ENTRY (IF (FBOUNDP 'LOOKUP-STRUCTURE-INFORMATION-1)
		     (LOOKUP-STRUCTURE-INFORMATION-1 NAME :ENVIRONMENT ENVIRONMENT :ERROR NIL)
		     (FILE-DECLARATION NAME 'EARLY-DEFSTRUCT))))
      (WHEN ENTRY
	(RETURN-FROM LOOKUP-STRUCTURE-INFORMATION
	  ENTRY))))
  (LET ((ENTRY (ASSOC NAME *FORWARD-REFERENCED-STRUCTURE-CLASSES*)))
    (WHEN ENTRY
      (RETURN-FROM LOOKUP-STRUCTURE-INFORMATION
	(NTHCDR 2 ENTRY))))
  (IF (FBOUNDP 'LOOKUP-STRUCTURE-INFORMATION-1)
      (LOOKUP-STRUCTURE-INFORMATION-1 NAME)
      (ERROR "Structure ~S not defined." NAME)))

(DEFUN LOOKUP-STRUCTURE-INSTANCE-INFORMATION (NAME SIZE &OPTIONAL #+Minima STORAGE-CATEGORY)
  (DECLARE (NOTINLINE TYPEP))			;want to be able to load this
  #+Minima
  (WHEN SIZE
    (INCF SIZE))
  (WHEN (FBOUNDP 'FIND-CLASS)
    (LET ((CLASS (FIND-CLASS NAME NIL)))
      (WHEN CLASS
	(ETYPECASE CLASS
	  (STRUCTURE-CLASS
	    (LET ((INFORMATION (CLASS-INSTANCE-INFORMATION CLASS)))
	      (WHEN (OR (NULL SIZE) (= SIZE (%CLASS-INSTANCE-INFORMATION-SIZE INFORMATION)))
		(RETURN-FROM LOOKUP-STRUCTURE-INSTANCE-INFORMATION INFORMATION))))
	  (FORWARD-REFERENCED-CLASS)))))
  (LET ((ENTRY (ASSOC NAME *FORWARD-REFERENCED-STRUCTURE-CLASSES*)))
    (WHEN (NULL ENTRY)
      (SETF ENTRY (LIST* NAME NIL NIL))
      (PUSH ENTRY *FORWARD-REFERENCED-STRUCTURE-CLASSES*))
    (LET ((INFORMATION (SECOND ENTRY)))
      (WHEN (OR (NULL INFORMATION)
		(AND SIZE
		     (LET ((OLD-SIZE (%CLASS-INSTANCE-INFORMATION-SIZE INFORMATION)))
		       (IF OLD-SIZE
			   (NOT (= SIZE OLD-SIZE))
			   (PROGN
			     (SETF (%CLASS-INSTANCE-INFORMATION-SIZE INFORMATION) SIZE)
			     NIL)))))
	(SETF (SECOND ENTRY)
	      (SETF INFORMATION (EARLY-MAKE-CLASS-INSTANCE-INFORMATION
				  NAME SIZE #+Minima STORAGE-CATEGORY))))
      INFORMATION)))

;;; This is separate because it depends on the previous function to be loaded.
(DEFUN EARLY-MAKE-CLASS-INSTANCE-INFORMATION (NAME SIZE #+Minima STORAGE-CATEGORY)
  (LET ((INFORMATION (MAKE-CLASS-INSTANCE-INFORMATION-INTERNAL
		       NIL NIL NIL		       
		       #+Minima 'STORAGE-AREA
		       #+Minima
		       (ECASE STORAGE-CATEGORY
			 ((NIL) T)
			 (:WIRED MINIMA-INTERNALS::+WIRED-AREA+)
			 (:SAFEGUARDED MINIMA-INTERNALS::+SAFEGUARDED-AREA+)))))
    (SETF (%CLASS-INSTANCE-INFORMATION-CLASS INFORMATION) NAME)
    (SETF (%CLASS-INSTANCE-INFORMATION-CLASS-NAME INFORMATION) NAME)
    (SETF (%CLASS-INSTANCE-INFORMATION-SIZE INFORMATION) SIZE)
    INFORMATION))

#+|3600|
(DEFUN ALLOCATE-STRUCTURE-OBJECT (INSTANCE-INFORMATION
				  &OPTIONAL
				  (STORAGE-AREA SYS:*DEFAULT-CONS-AREA*))
  (LET* ((SIZE (%INSTANCE-INFORMATION-SIZE INSTANCE-INFORMATION))
	 (INSTANCE (SI:%MAKE-STRUCTURE SYS:DTP-INSTANCE SYS:DTP-HEADER-P
				       SYS:%HEADER-TYPE-INSTANCE
				       INSTANCE-INFORMATION STORAGE-AREA SIZE)))
    (SYS:%BLOCK-STORE-TAG-AND-POINTER
      (SYS:%POINTER-PLUS INSTANCE 1)
      (1- SIZE)
      SYS:DTP-NULL
      INSTANCE
      0)
    INSTANCE))

(DEFUN EARLY-STRUCTURE-SUBTYPEP (THIS-CLASS-NAME CLASS-NAME)
  (LOOP
    (WHEN (EQ THIS-CLASS-NAME CLASS-NAME)
      (RETURN T))
    (SETF THIS-CLASS-NAME
	  (LET ((ENTRY (ASSOC THIS-CLASS-NAME *FORWARD-REFERENCED-STRUCTURE-CLASSES*)))
	    (IF ENTRY
		(NTH 3 ENTRY)
		(LET ((DESCRIPTOR (LOOKUP-DEFSTRUCT-DESCRIPTOR THIS-CLASS-NAME :ERROR NIL)))
		  (AND DESCRIPTOR
		       (CLASS-NAME (FIRST (CLASS-DIRECT-SUPERCLASSES DESCRIPTOR))))))))
    (WHEN (NULL THIS-CLASS-NAME)
      (RETURN NIL))))

;;; This doesn't work right while DEFSTRUCT is being loaded.
(DEFUN STRUCTURE-SUBTYPEP (THIS-CLASS-NAME CLASS-NAME)
  (IF *FORWARD-REFERENCED-STRUCTURE-CLASSES*
      (EARLY-STRUCTURE-SUBTYPEP THIS-CLASS-NAME CLASS-NAME)
      (DO ((DESCRIPTOR (LOOKUP-DEFSTRUCT-DESCRIPTOR THIS-CLASS-NAME :ERROR NIL)
		       (FIRST (CLASS-DIRECT-SUPERCLASSES DESCRIPTOR))))
	  ((NULL DESCRIPTOR) NIL)
	(WHEN (EQ (CLASS-NAME DESCRIPTOR) CLASS-NAME)
	  (RETURN T)))))

(DEFUN STRUCTURE-CLASS-TYPEP (OBJECT CLASS-NAME)
  (LET ((INSTANCE-INFORMATION (%INSTANCE-INSTANCE-INFORMATION OBJECT)))
    (AND (CLASS-INSTANCE-INFORMATION-P INSTANCE-INFORMATION)
	 (LET ((PRECEDENCE-LIST
		 (%CLASS-INSTANCE-INFORMATION-PRECEDENCE-LIST INSTANCE-INFORMATION)))
	   (IF (NULL PRECEDENCE-LIST)
	       (EARLY-STRUCTURE-SUBTYPEP
		 (%CLASS-INSTANCE-INFORMATION-CLASS-NAME INSTANCE-INFORMATION)
		 CLASS-NAME)
	       (MEMBER CLASS-NAME PRECEDENCE-LIST :KEY #'CLASS-NAME))))))

;;; Old compiled code calls this.
(DEFUN STRUCTURE-CLASS-SUBTYPEP (INSTANCE-INFORMATION CLASS-NAME)
  (AND (CLASS-INSTANCE-INFORMATION-P INSTANCE-INFORMATION)
       (LET ((PRECEDENCE-LIST
	       (%CLASS-INSTANCE-INFORMATION-PRECEDENCE-LIST INSTANCE-INFORMATION)))
	 (IF (NULL PRECEDENCE-LIST)
	     (EARLY-STRUCTURE-SUBTYPEP
	       (%CLASS-INSTANCE-INFORMATION-CLASS-NAME INSTANCE-INFORMATION)
	       CLASS-NAME)
	     (MEMBER CLASS-NAME PRECEDENCE-LIST :KEY #'CLASS-NAME)))))

#+Imach
(SYS:DEFINE-DERIVED-FUNCTION-TYPE STRUCTURE-CONSTRUCTOR STRUCTURE-CONSTRUCTOR)

(DEFUN STRUCTURE-SLOT-INITFUNCTION (DEFSTRUCT-NAME SLOT-NAME &KEY (ERROR T))
  (LET ((ENTRY (ASSOC DEFSTRUCT-NAME *FORWARD-REFERENCED-STRUCTURE-CLASSES*)))
    (WHEN ENTRY
      (LET ((SLOT (ASSOC SLOT-NAME (GETF (NTHCDR 5 ENTRY) :SLOTS))))
	(WHEN SLOT
	  (RETURN-FROM STRUCTURE-SLOT-INITFUNCTION
	    (GETF (CDR SLOT) :INITFUNCTION))))))
  (WHEN (FBOUNDP 'LOOKUP-DEFSTRUCT-DESCRIPTOR)
    (LET ((DEFSTRUCT (LOOKUP-DEFSTRUCT-DESCRIPTOR DEFSTRUCT-NAME :ERROR ERROR)))
      (WHEN DEFSTRUCT
	(LET ((SLOT (FIND SLOT-NAME (CLASS-SLOTS DEFSTRUCT) :KEY #'SLOT-DEFINITION-NAME)))
	  (WHEN SLOT
	    (RETURN-FROM STRUCTURE-SLOT-INITFUNCTION
	      (SLOT-DEFINITION-INITFUNCTION SLOT)))))))
  (AND ERROR (ERROR "Slot ~S is not defined in structure ~S." SLOT-NAME DEFSTRUCT-NAME)))

(DEFUN STRUCTURE-PRINT-FUNCTION (DEFSTRUCT-NAME &KEY (ERROR T))
  (LET ((ENTRY (ASSOC DEFSTRUCT-NAME *FORWARD-REFERENCED-STRUCTURE-CLASSES*)))
    (WHEN ENTRY
      (RETURN-FROM STRUCTURE-PRINT-FUNCTION
	(GETF (NTHCDR 5 ENTRY) 'PRINT-FUNCTION))))
  (WHEN (FBOUNDP 'LOOKUP-DEFSTRUCT-DESCRIPTOR)
    (LET ((DEFSTRUCT (LOOKUP-DEFSTRUCT-DESCRIPTOR DEFSTRUCT-NAME :ERROR ERROR)))
      (WHEN DEFSTRUCT
	(RETURN-FROM STRUCTURE-PRINT-FUNCTION
	  (SLOT-VALUE DEFSTRUCT 'PRINT-FUNCTION)))))
  (AND ERROR (ERROR "Structure ~S is not defined." DEFSTRUCT-NAME)))
