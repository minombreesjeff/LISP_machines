;;; -*- Mode: LISP; Syntax: ANSI-Common-Lisp; Base: 10; Package: CLOS-INTERNALS -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(IN-PACKAGE :CLOS-INTERNALS)

;;; A list of constructors that haven't been compiled yet after they
;;; were either defined or decached during load-system or load-patches
(DEFVAR *CONSTRUCTORS-TO-BE-COMPILED* NIL)

(DEFMETHOD INITIALIZE-INSTANCE :AFTER ((CONSTRUCTOR POSITIONAL-CONSTRUCTOR) &KEY)
  (SETF (SLOT-VALUE CONSTRUCTOR 'TRAPPING-FUNCTION)
	#+Genera (SYS:MAKE-LEXICAL-CLOSURE CONSTRUCTOR #'TRAP-MAKE-INSTANCE)
	#-Genera #'(LAMBDA (&REST ARGS)
		     (DECLARE (DYNAMIC-EXTENT ARGS))
		     (APPLY #'TRAP-MAKE-INSTANCE CONSTRUCTOR ARGS)))
  (NOTE-CONSTRUCTOR-CHANGED CONSTRUCTOR))

;;; Save space by not saving these.
#+Genera
(DEFMETHOD (SETF FUNCTION-NAME-GET)
	   (VALUE (CONSTRUCTOR POSITIONAL-CONSTRUCTOR) (INDICATOR (EQL ':SOURCE-FILE-NAME)))
  VALUE)

(DEFMETHOD CONSTRUCTOR-FDEFINITION ((CONSTRUCTOR POSITIONAL-CONSTRUCTOR))
  (FUNCTION-NAME-DEFINITION CONSTRUCTOR))

(DEFMETHOD (SETF CONSTRUCTOR-FDEFINITION) (FUNCTION (CONSTRUCTOR POSITIONAL-CONSTRUCTOR))
  #+Genera (LET ((SYS:FDEFINE-FILE-PATHNAME NIL)
		 (SI:PATCH-SOURCE-FILE-PATHNAME NIL))
	     (SYS:LETF (((SLOT-VALUE CONSTRUCTOR 'PLIST) NIL))	;No :PREVIOUS-DEFINITION
	       (SYS:FDEFINE CONSTRUCTOR FUNCTION T T)))
  #-Genera (SETF (FUNCTION-NAME-DEFINITION CONSTRUCTOR) FUNCTION)
  FUNCTION)

;;; Regenerate the constructor the next time it is called
(DEFMETHOD NOTE-CONSTRUCTOR-CHANGED ((CONSTRUCTOR POSITIONAL-CONSTRUCTOR))
  (WITH-CLOS-LOCK
    (WHEN #+Genera (PLUSP SI:*INHIBIT-LENGTHY-BACKGROUND-UPDATES*)	;i.e. in LOAD-SYSTEM
	  #-Genera T
      (PUSHNEW CONSTRUCTOR *CONSTRUCTORS-TO-BE-COMPILED*))
    (WITH-SLOTS (TRAPPING-FUNCTION) CONSTRUCTOR
      (SETF (CONSTRUCTOR-FDEFINITION CONSTRUCTOR) TRAPPING-FUNCTION))))

(DEFUN TRAP-MAKE-INSTANCE (CONSTRUCTOR &REST ARGS)
  (DECLARE (DYNAMIC-EXTENT ARGS))
  (APPLY (ENSURE-CONSTRUCTOR-FUNCTION CONSTRUCTOR) ARGS))

(DEFUN COMPUTE-DEFAULT-CONSTRUCTOR (CONSTRUCTOR)
  (LET* ((CLASS (CONSTRUCTOR-CLASS CONSTRUCTOR))
	 (INITARGS (CONSTRUCTOR-INITARGS CONSTRUCTOR))
	 (TEMPS (LOOP REPEAT (LENGTH INITARGS) COLLECT (GENSYM)))
	 (KEYS (MAPCAN #'(LAMBDA (KEY TEMP) `(',KEY ,TEMP))
		       INITARGS TEMPS))
	 (REST (AND (CONSTRUCTOR-KEYS-P CONSTRUCTOR) (GENSYM))))
    (CLOS-COMPILE NIL
		  `(LAMBDA (,@TEMPS ,@(AND REST `(&REST ,REST)))
		     (DECLARE (NOTINLINE MAKE-INSTANCE))
		     #+Genera (DECLARE (SYS:FUNCTION-NAME ,CONSTRUCTOR))
		     ,@(WHEN REST
			 `((DECLARE (DYNAMIC-EXTENT ,REST))))
		     (,(IF REST 'APPLY 'FUNCALL)
		      ,(IF (SLOT-VALUE CONSTRUCTOR 'INTERNAL-P)
			   '#'SLOW-MAKE-INSTANCE
			   '#'MAKE-INSTANCE)
		      ',CLASS ,@KEYS ,@(AND REST `(,REST)))))))

(DEFMETHOD ENSURE-CONSTRUCTOR-FUNCTION ((CONSTRUCTOR POSITIONAL-CONSTRUCTOR))
  (WITH-SLOTS (CLASS INITARGS DEFAULT-FUNCTION TRAPPING-FUNCTION) CONSTRUCTOR
    (WITH-CLOS-LOCK
      (SETQ *CONSTRUCTORS-TO-BE-COMPILED* (DELETE CONSTRUCTOR *CONSTRUCTORS-TO-BE-COMPILED*))
      (WHEN (EQ (CONSTRUCTOR-FDEFINITION CONSTRUCTOR) TRAPPING-FUNCTION)
	(SETF (CONSTRUCTOR-FDEFINITION CONSTRUCTOR)
	      (COND #-Minima ((COMPUTE-CONSTRUCTOR-FUNCTION CONSTRUCTOR))
		    ((SLOT-BOUNDP CONSTRUCTOR 'DEFAULT-FUNCTION) DEFAULT-FUNCTION)
		    (T (SETF DEFAULT-FUNCTION (COMPUTE-DEFAULT-CONSTRUCTOR CONSTRUCTOR))))))
      (CONSTRUCTOR-FDEFINITION CONSTRUCTOR))))

(DEFMETHOD PRINT-OBJECT ((CONSTRUCTOR POSITIONAL-CONSTRUCTOR) STREAM)
  (COND ((AND *PRINT-READABLY* *READ-EVAL*)
	 (FORMAT STREAM "#.~S" (MAKE-LOAD-FORM CONSTRUCTOR)))
	(T
	 (PRINT-UNREADABLE-OBJECT (CONSTRUCTOR STREAM)
	   (WITH-SLOTS (CLASS) CONSTRUCTOR
	     (FORMAT STREAM "CLOS Constructor ~S ~:S~:[~; &KEY~]"
		     CLASS
		     (CONSTRUCTOR-INITARGS CONSTRUCTOR)
		     (CONSTRUCTOR-KEYS-P CONSTRUCTOR)))))))

(DEFMETHOD MAKE-LOAD-FORM ((CONSTRUCTOR POSITIONAL-CONSTRUCTOR))
  (WITH-SLOTS (CLASS INITARGS KEYS-P) CONSTRUCTOR
    `(FIND-POSITIONAL-CONSTRUCTOR ',CLASS ',INITARGS ,@(AND KEYS-P `(',KEYS-P)))))

(DEFMETHOD FIND-POSITIONAL-CONSTRUCTOR ((CLASS SYMBOL) INITARGS &OPTIONAL KEYS-P)
  (LET ((HOLDER (LOAD-CLASS-HOLDER CLASS)))
    (OR (FIND-IF #'(LAMBDA (CONSTRUCTOR)
		     (AND (EQUAL (CONSTRUCTOR-INITARGS CONSTRUCTOR) INITARGS)
			  (EQ (NULL (CONSTRUCTOR-KEYS-P CONSTRUCTOR)) (NULL KEYS-P))
			  (NOT (CONSTRUCTOR-INTERNAL-P CONSTRUCTOR))))
		 (CLASS-HOLDER-CONSTRUCTORS HOLDER))
	(LET ((CONSTRUCTOR (SLOW-MAKE-INSTANCE 'POSITIONAL-CONSTRUCTOR :CLASS CLASS
					       :INITARGS INITARGS :KEYS-P KEYS-P)))
	  (PUSH CONSTRUCTOR (CLASS-HOLDER-CONSTRUCTORS HOLDER))
	  (WHEN (CLASS-HOLDER-BOUNDP HOLDER)
	    (PUSH CONSTRUCTOR (CLASS-CONSTRUCTORS (CLASS-HOLDER-CLASS HOLDER))))
	  CONSTRUCTOR))))

(DEFMETHOD FIND-POSITIONAL-CONSTRUCTOR ((CLASS CLASS) INITARGS &OPTIONAL KEYS-P)
  (OR (FIND-IF #'(LAMBDA (CONSTRUCTOR)
		   (AND (EQ (CONSTRUCTOR-CLASS CONSTRUCTOR) CLASS)
			(EQUAL (CONSTRUCTOR-INITARGS CONSTRUCTOR) INITARGS)
			(EQ (NULL (CONSTRUCTOR-KEYS-P CONSTRUCTOR)) (NULL KEYS-P))
			(NOT (CONSTRUCTOR-INTERNAL-P CONSTRUCTOR))))
	       (CLASS-CONSTRUCTORS CLASS))
      (LET ((CONSTRUCTOR (SLOW-MAKE-INSTANCE 'POSITIONAL-CONSTRUCTOR
					     :CLASS CLASS :INITARGS INITARGS :KEYS-P KEYS-P)))
	(PUSH CONSTRUCTOR (CLASS-CONSTRUCTORS CLASS))
	CONSTRUCTOR)))

(DEFMETHOD SLOT-UNBOUND
	   (METACLASS (CLASS STANDARD-CLASS) (SLOT-NAME (EQL 'KEYWORD-CONSTRUCTOR)))
  (DECLARE (IGNORE METACLASS))
  (SETF (SLOT-VALUE CLASS 'KEYWORD-CONSTRUCTOR)
	(LET ((CONSTRUCTOR (SLOW-MAKE-INSTANCE 'POSITIONAL-CONSTRUCTOR
					       :CLASS CLASS :INITARGS NIL :KEYS-P T
					       :INTERNAL-P T)))
	  (PUSH CONSTRUCTOR (CLASS-CONSTRUCTORS CLASS))
	  CONSTRUCTOR)))

(DEFUN ENSURE-ALL-CONSTRUCTOR-FUNCTIONS ()
  (MAP-OVER-CLASS-AND-ITS-SUBCLASSES
    (FIND-CLASS T)
    #'(LAMBDA (CLASS)
	(WHEN (AND (SLOT-EXISTS-P CLASS 'CONSTRUCTORS)
		   (CLASS-FINALIZED-P CLASS))
	  (MAP NIL #'ENSURE-CONSTRUCTOR-FUNCTION (CLASS-CONSTRUCTORS CLASS))))))

(DEFUN ENSURE-CONSTRUCTORS-COMPILED ()
  (MAP NIL #'ENSURE-CONSTRUCTOR-FUNCTION *CONSTRUCTORS-TO-BE-COMPILED*))

#+Genera
(SI:DEFINE-POSTPONED-LENGTHY-BACKGROUND-UPDATE (ENSURE-CONSTRUCTORS-COMPILED))

#+Genera
(SYS:ADD-INITIALIZATION "Compile CLOS constructors." '(ENSURE-ALL-CONSTRUCTOR-FUNCTIONS)
			'(:BEFORE-COLD))

#+Genera
(SI:DEFINE-GC-OPTIMIZATION COMPILE-CLOS-CONSTRUCTORS :LAYERED-IDS-RELEASE
  (:DOCUMENTATION "Ensures that CLOS positional constructors are compiled.")
  (:ORDER :FIRST (:BEFORE SI:CACHE-FUNCTION-CURRENCY))
  (:BEFORE-FLIP (IGNORE)
   (DECLARE (IGNORE IGNORE))
   (ENSURE-ALL-CONSTRUCTOR-FUNCTIONS)))

#+Cloe-Runtime
(PUSHNEW 'ENSURE-ALL-CONSTRUCTOR-FUNCTIONS SYS:*BEFORE-SAVE-PROGRAM-HOOKS*)

#+Genera
(DEFMETHOD CLASS-MAKE-INSTANCE-KEYWORDS ((CLASS FLAVOR-CLASS))
  (FLAVOR:FLAVOR-ALLOWED-INIT-KEYWORDS
    (FLAVOR:FLAVOR-NAME (CLASS-INSTANCE-INFORMATION CLASS))))

;;; Let the metaclass decide how to make positional constructor functions
(DEFUN COMPUTE-CONSTRUCTOR-FUNCTION (CONSTRUCTOR)
  (COMPUTE-CONSTRUCTOR-FUNCTION-USING-CLASS (CONSTRUCTOR-CLASS CONSTRUCTOR) CONSTRUCTOR))
  
(DEFMETHOD COMPUTE-CONSTRUCTOR-FUNCTION-USING-CLASS ((CLASS SYMBOL) CONSTRUCTOR)
  (LET ((CLASS (FIND-CLASS CLASS NIL)))
    (AND CLASS
	 (COMPUTE-CONSTRUCTOR-FUNCTION-USING-CLASS CLASS CONSTRUCTOR))))

;;; Default is not to do any optimization
(DEFMETHOD COMPUTE-CONSTRUCTOR-FUNCTION-USING-CLASS ((CLASS CLASS) CONSTRUCTOR)
  (DECLARE (IGNORE CONSTRUCTOR))
  NIL)

;;; For standard-class, optimize if the class is fully defined and
;;; only valid initialization arguments are being supplied.
(DEFMETHOD COMPUTE-CONSTRUCTOR-FUNCTION-USING-CLASS
	   ((CLASS STANDARD-CLASS) (CONSTRUCTOR POSITIONAL-CONSTRUCTOR))
  ;; Make sure the class is fully defined and finalized
  (UNLESS (CLASS-FINALIZED-P CLASS)
    (LABELS ((VERIFY (CLASS)
	       (AND (CLASS-INITIALIZED-P CLASS)
		    (EVERY #'VERIFY (CLASS-DIRECT-SUPERCLASSES CLASS)))))
      (UNLESS (VERIFY CLASS)
	(RETURN-FROM COMPUTE-CONSTRUCTOR-FUNCTION-USING-CLASS NIL)))
    (FINALIZE-INHERITANCE CLASS))
  (WITH-SLOTS (INITARGS KEYS-P INTERNAL-P) CONSTRUCTOR
    ;; Make sure only valid initargs are being supplied
    (WHEN (OR (LDB-TEST %%STANDARD-CLASS-MAKE-INSTANCE-ALLOW-OTHER-KEYS-P (CLASS-BITS CLASS))
	      (NULL (SET-DIFFERENCE INITARGS (CLASS-MAKE-INSTANCE-KEYWORDS CLASS))))
      (MULTIPLE-VALUE-BIND (LAMBDA-LIST FORM DECLARATIONS)
	  (GENERATE-POSITIONAL-CONSTRUCTOR-BODY CLASS INITARGS KEYS-P INTERNAL-P)
	(WHEN FORM
	  (IGNORE-ERRORS
	    (CLOS-COMPILE NIL 
			  `(LAMBDA ,LAMBDA-LIST
			     #+Genera (DECLARE (SYS:FUNCTION-NAME ,CONSTRUCTOR))
			     (DECLARE ,@DECLARATIONS)
			     ,FORM))))))))

;;; The constructors that STANDARD-CLASS knows how to make do not work for
;;; FUNCALLABLE-STANDARD-CLASS.  Just punt the optimization.
(DEFMETHOD COMPUTE-CONSTRUCTOR-FUNCTION-USING-CLASS ((CLASS FUNCALLABLE-STANDARD-CLASS)
						     CONSTRUCTOR)
  (DECLARE (IGNORE CONSTRUCTOR))
  NIL)

(DEFUN GENERATE-POSITIONAL-CONSTRUCTOR-BODY (CLASS INITARG-KEYS REST-P INTERNAL-P)
  #+Genera (DECLARE (VALUES LAMBDA-LIST FORM))
  (LET ((LAMBDA-LIST NIL)
	(DECLARATIONS NIL)
	(CHECKS NIL)
	(BINDINGS NIL)
	(INITARGS-ALIST NIL)
	(DEFAULT-INITARGS (CLASS-DEFAULT-INITARGS CLASS))
	(VALID-KEYS (CLASS-MAKE-INSTANCE-KEYWORDS CLASS))
	(ALLOW-OTHER-KEYS-P (LDB-TEST %%STANDARD-CLASS-MAKE-INSTANCE-ALLOW-OTHER-KEYS-P
				      (CLASS-BITS CLASS)))
	(NUMBER-OF-PARAMETERS #+|3600| 3 #-|3600| 2))	;class, plus one or two extra-args
    (MULTIPLE-VALUE-BIND (FAST-P INLINE-P) (CLASS-CONSTRUCTOR-FAST-P CLASS)
      (WHEN REST-P
	;; Check for the case where a single slot is filled by more than one initialization
	;; argument, and therefore it makes a difference in what order the user supplied the
	;; initialization arguments.  In that case we cannot make a keyword constructor as
	;; it would reorder the initialization arguments according to its lambda-list's order.
	(DOLIST (SLOT (CLASS-SLOTS CLASS))
	  (WHEN (< 1 (LENGTH (SET-DIFFERENCE (SLOT-DEFINITION-INITARGS SLOT) INITARG-KEYS)))
	    (RETURN-FROM GENERATE-POSITIONAL-CONSTRUCTOR-BODY NIL)))
	;; This case is too hard for now.
	(WHEN ALLOW-OTHER-KEYS-P
	  (RETURN-FROM GENERATE-POSITIONAL-CONSTRUCTOR-BODY NIL)))
      ;; Check for invalid default-initargs, if there are any we'll give up on a constructor
      ;; and let the default MAKE-INSTANCE method report the error
      (UNLESS ALLOW-OTHER-KEYS-P
	(LOOP FOR (KEY) IN DEFAULT-INITARGS
	      DO (UNLESS (MEMBER KEY VALID-KEYS)
		   (RETURN-FROM GENERATE-POSITIONAL-CONSTRUCTOR-BODY NIL))))
      ;; Handle the positional arguments.
      (LOOP FOR KEY IN INITARG-KEYS
	    FOR VAR = (MAKE-SYMBOL (STRING KEY))
	    DO
	(PUSH `(,KEY ,VAR T) INITARGS-ALIST)
	(PUSH VAR LAMBDA-LIST)
	(INCF NUMBER-OF-PARAMETERS))
      (COND (REST-P
	     (LET ((INLINABLES NIL)
		   (KEYS NIL)
		   (REST '#:INITARGS))
	       (SETQ REST-P REST)
	       (PUSH `(DYNAMIC-EXTENT ,REST) DECLARATIONS)
	       ;; For each initialization argument that comes from the rest argument (rather
	       ;; than from any positional arguments preceding the rest argument), create an
	       ;; entry on INITARGS-ALIST and arrange for the value to come either from the
	       ;; rest argument or from the default value.
	       (LOOP FOR KEY IN (SET-DIFFERENCE VALID-KEYS INITARG-KEYS)
		     AS (FORM FUNCTION INLINABLE) = (CDR (ASSOC KEY DEFAULT-INITARGS))
		     AS FILL-SLOT = NIL
		     WITH (VAR SUPPLIED-P DEFAULT)
		     DO (UNLESS FUNCTION	;Unless there is a DEFAULT-INITARGS entry
			  (WHEN (AND INLINE-P
				     (LOOP FOR SLOT IN (CLASS-SLOTS CLASS) WITH COUNT = 0
					   DO (WHEN (MEMBER KEY (SLOT-DEFINITION-INITARGS SLOT))
						(INCF COUNT)
						(SETQ FILL-SLOT SLOT))
					   FINALLY (RETURN (= COUNT 1)))
				     FAST-P
				     (SLOT-DEFINITION-INITFUNCTION FILL-SLOT)
				     (EQ (SLOT-DEFINITION-ALLOCATION FILL-SLOT) :INSTANCE)
				     (NOT (CLASS-INITIALIZATION-METHODS-USE-INITARG CLASS KEY)))
			    ;; If this initarg is going nowhere but to fill one slot, we can
			    ;; use the slot's initform as the initarg's default
			    (SETQ FORM (SLOT-DEFINITION-INITFORM FILL-SLOT)
				  FUNCTION (SLOT-DEFINITION-INITFUNCTION FILL-SLOT)
				  INLINABLE (SLOT-DEFINITION-INITFORM-INLINABLE FILL-SLOT))))
			(SETQ VAR (MAKE-SYMBOL (STRING KEY))
			      SUPPLIED-P (AND (NOT FUNCTION)
					      (MAKE-SYMBOL (CONCATENATE 'STRING (STRING KEY)
									"-SUPPLIED-P")))
			      DEFAULT (AND FUNCTION
					   (IF INLINABLE
					       FORM
					       ;; We can't funcall the function closure
					       ;; by function-spec, but if we were compiling
					       ;; to a file we could not use the closure as
					       ;; a constant either.  LOAD-TIME-VALUE?
					       `(FUNCALL ',FUNCTION))))
			;; The lambda-list only gets a keyword parameter if it will actually
			;; be used, which occurs if it's used to fill any slots or if it has
			;; a default value and is received by any methods.  We won't check for
			;; having a default value and not being received by any methods nor
			;; used to fill any slots, which shouldn't be able to happen.
			(WHEN (OR FILL-SLOT (NOT SUPPLIED-P))
			  (INCF NUMBER-OF-PARAMETERS (IF SUPPLIED-P 2 1))
			  (PUSH `((,KEY ,VAR) ,DEFAULT
				  ;; The lambda-list only gets a supplied-p parameter if it will
				  ;; actually be used, which occurs when this initialization
				  ;; argument is undefaulted and fills one or more slots.
				  ,@(AND SUPPLIED-P FILL-SLOT (LIST SUPPLIED-P)))
				KEYS)
			  (PUSH (OR INLINABLE (IF FUNCTION 'WRITER 'CONSTANT)) INLINABLES))
			(PUSH `(,KEY ,VAR ,(OR SUPPLIED-P 'T)) INITARGS-ALIST))
	       (COND #-Minima
		     ((>= NUMBER-OF-PARAMETERS LAMBDA-PARAMETERS-LIMIT)
		      ;; Too many parameters, fall back to doing it a slower way
		      ;; On Ivory, this depends on GETF, RGETF, and SI:KEYWORD-SUPPLIED-P-INTERNAL
		      ;; not bashing BAR-1
		      (LET (#+|3600| (CONSTANTS '#:CONSTANTS)
			    #+|3600| (CONSTANT-VALUES NIL))
			;; Replace the keyword and supplied-p parameter variables
			;; in INITARGS-ALIST with forms that produce equivalent values
			(LOOP FOR ((KEY VAR) DEFAULT SUPPLIED-P) IN KEYS
			      AND INLINABLE IN INLINABLES
			      WITH INDEX = -1
			      AS ITEM = (ASSOC KEY INITARGS-ALIST) DO
			  (PROGN #+|3600| (PUSH KEY CONSTANT-VALUES)
				 #+|3600| (SETQ KEY `(AREF ,CONSTANTS ,(INCF INDEX)))
				 #-|3600| (SETQ KEY `(QUOTE ,KEY))
				 #-|3600| INDEX)
			  #+|3600| (WHEN (EQ INLINABLE 'CONSTANT)
				     (UNLESS (OR (NULL DEFAULT)
						 (TYPEP DEFAULT '(INTEGER -256 255)))
				       (SETQ DEFAULT (EVAL DEFAULT))
				       (LET ((I (POSITION DEFAULT CONSTANT-VALUES)))
					 (COND ((NULL I)
						(PUSH DEFAULT CONSTANT-VALUES)
						(SETQ DEFAULT `(AREF ,CONSTANTS ,(INCF INDEX))))
					       (T
						(SETQ DEFAULT `(AREF ,CONSTANTS ,(- INDEX I))))))))
			  (COND (SUPPLIED-P
				 (ASSERT (EQ INLINABLE 'CONSTANT))
				 (ASSERT (EQ DEFAULT 'NIL))
				 (SETF (SECOND ITEM)
				       #-(OR IMach Minima) `(GETF ,REST ,KEY)
				       #+IMach `(SYS:RGETF ,KEY ,REST)
				       #+Minima `(IVORY:RGETF ,KEY ,REST))
				 (SETF (THIRD ITEM)
				       #+Genera `(SI:KEYWORD-SUPPLIED-P-INTERNAL ,KEY ,REST)
				       #-Genera `(LOOP FOR KEY IN ,REST BY #'CDDR
						       THEREIS (EQ KEY ,KEY))))
				((EQ INLINABLE 'CONSTANT)
				 ;; This is the simplest case, we don't need a variable, we don't
				 ;; have to maintain supplied-p, and we can evaluate DEFAULT
				 ;; whenever we like, even in the middle of the block-write
				 (SETF (SECOND ITEM)
				       #-(OR IMach Minima) `(GETF ,REST ,KEY ,DEFAULT)
				       #+IMach (IF DEFAULT
						   `(GETF ,REST ,KEY ,DEFAULT)
						   `(SYS:RGETF ,KEY ,REST))
				       #+Minima (IF DEFAULT
						    `(GETF ,REST ,KEY ,DEFAULT)
						    `(IVORY:RGETF ,KEY ,REST))))
				(T
				 ;; DEFAULT has to be evaluated ahead of time so it doesn't get
				 ;; evaluated while a block-register is in use, storage is not
				 ;; yet initialized, etc.  So we still need a variable here.
				 (PUSH `(,VAR
					 ,(IF (MEMBER INLINABLE '(SIMPLE READER))
					      ;; It's okay to evaluate DEFAULT even when the
					      ;; initarg is actually supplied
					      `(GETF ,REST ,KEY ,DEFAULT)
					      ;; We must only evaluate DEFAULT if no initarg
					      #+IMach (LET ((VALUE '#:VALUE)
							    (SUPPLIED-P '#:SUPPLIED-P))
							`(MULTIPLE-VALUE-BIND (,VALUE ,SUPPLIED-P)
							     (SYS:RGETF ,KEY ,REST)
							   (IF ,SUPPLIED-P ,VALUE ,DEFAULT)))
					      #+Minima (LET ((VALUE '#:VALUE)
							     (SUPPLIED-P '#:SUPPLIED-P))
							 `(MULTIPLE-VALUE-BIND (,VALUE ,SUPPLIED-P)
							      (IVORY:RGETF ,KEY ,REST)
							    (IF ,SUPPLIED-P ,VALUE ,DEFAULT)))
					      #+|3600| `(IF (SI:KEYWORD-SUPPLIED-P-INTERNAL ,KEY
											    ,REST)
							    (GETF ,REST ,KEY)
							    ,DEFAULT)
					      #-(OR Genera MINIMA)
					      (LET ((KEY-ARG '#:KEY)
						    (VAL-ARG '#:VAL))
						`(LOOP FOR (,KEY-ARG ,VAL-ARG) ON ,REST
								     BY #'CDDR
						       DO (WHEN (EQ ,KEY-ARG ,KEY)
							    (RETURN ,VAL-ARG))
						       FINALLY (RETURN ,DEFAULT)))))
				       BINDINGS))))
			(SETF LAMBDA-LIST `(
			;; The 3600 can suffer constant-table overflow, so we have to make
			;; our own array of constants.  This assumes we don't have so many
			;; constants (around 500) that we overflow the constant-table with
			;; the subscripts to be given to AREF.
			#+|3600| (,CONSTANTS ',(APPLY #'VECTOR (NREVERSE CONSTANT-VALUES)))
			#+|3600| &AUX
			,REST &REST ,@LAMBDA-LIST))))
		     (T
		      (SETF LAMBDA-LIST `(&ALLOW-OTHER-KEYS ,@KEYS &KEY
							    ,REST &REST
							    ,@LAMBDA-LIST))))
	       (PUSH (IF ALLOW-OTHER-KEYS-P
			 REST			;avoid unused variable warning
			 `(VALIDATE-KEYWORDS-INTERNAL ',VALID-KEYS ,REST))
		     CHECKS)))
	    (T
	     (LOOP FOR (KEY FORM FUNCTION INLINABLE) IN DEFAULT-INITARGS DO
	       (UNLESS (MEMBER KEY INITARG-KEYS)
		 (PUSH (LIST KEY
			     (CASE INLINABLE
			       ((CONSTANT) FORM)
			       ;; Move the evaluation to the front of the function
			       ;; by binding a temporary variable (this is
			       ;; perhaps only needed if FAST-P)
			       ((SIMPLE READER WRITER SPECIAL)
				(LET ((TEMP (MAKE-SYMBOL (STRING KEY))))
				  (PUSH (LIST TEMP FORM) BINDINGS)
				  TEMP))
			       (OTHERWISE
				 (LET ((TEMP (MAKE-SYMBOL (STRING KEY)))
				       ;; We can't funcall the function closure
				       ;; by function-spec, but if we were compiling
				       ;; to a file we could not use the closure as
				       ;; a constant either.  LOAD-TIME-VALUE?
				       (FORM `(FUNCALL ',FUNCTION)))
				   (PUSH (LIST TEMP FORM) BINDINGS)
				   TEMP)))
			     T)
		       INITARGS-ALIST)))))
      (LET ((BODY (GENERATE-CONSTRUCTOR-BODY CLASS BINDINGS (NREVERSE INITARGS-ALIST)
					     FAST-P REST-P INTERNAL-P)))
	(WHEN CHECKS
	  (SETF BODY `(PROGN ,@CHECKS ,BODY)))
	(VALUES (NREVERSE LAMBDA-LIST) BODY DECLARATIONS)))))

(DEFUN GENERATE-CONSTRUCTOR-BODY
       (CLASS BINDINGS INITARGS-ALIST FAST-P REST-P INTERNAL-P)
  #+Genera (DECLARE (VALUES FORM))
  ;; Make sure that this class uses the slot implementation expected by our inline code
  (DOLIST (METHOD (COMPUTE-APPLICABLE-METHODS *SLOT-VALUE-USING-CLASS*
					      (LIST CLASS (CLASS-PROTOTYPE CLASS) NIL)))
    (UNLESS (MEMBER (FIRST (METHOD-QUALIFIERS METHOD)) '(:BEFORE :AFTER))
      (UNLESS (AND (NULL (METHOD-QUALIFIERS METHOD))
		   (EQ (FIRST (METHOD-SPECIALIZERS METHOD)) (FIND-CLASS 'STANDARD-CLASS)))
	(RETURN-FROM GENERATE-CONSTRUCTOR-BODY NIL))))
  ;; Convert the effective method form into inline code and then optimize it
  (MULTIPLE-VALUE-BIND (FORM MORE-BINDINGS)
      (IF INTERNAL-P
	  (GENERATE-INLINE-METHOD
	    *MAKE-INSTANCE*
	    (FIND-METHOD *MAKE-INSTANCE* NIL (LIST (FIND-CLASS 'STANDARD-CLASS)))
	    CLASS (LIST CLASS) INITARGS-ALIST NIL FAST-P NIL REST-P)
	  (GENERATE-INLINE-EFFECTIVE-METHOD
	    *MAKE-INSTANCE* CLASS (LIST CLASS) INITARGS-ALIST FAST-P REST-P))
    (WHEN (AND (CONSP FORM)
	       (MEMBER (FIRST FORM) '(LET PROG1))
	       (CONSP (CAR (LAST FORM)))
	       (EQ (FIRST (CAR (LAST FORM))) 'PROGN))
      (SETQ FORM (APPEND (BUTLAST FORM) (REST (CAR (LAST FORM))))))
    ;; Setting the TRAP-MODE right before returning is unnecessary, since return restores it
    #+IMach (WHEN (AND (CONSP FORM)
		       (EQUAL (CAR (LAST FORM))
			      '(SETF (SYS:%TRAP-MODE)
				     (LDB SYS:%%CR.TRAP-MODE (SYS:%SAVED-CONTROL-REGISTER)))))
	      (SETQ FORM (BUTLAST FORM)))
    (IF (OR BINDINGS MORE-BINDINGS)
	`(LET (,@BINDINGS ,@MORE-BINDINGS)
	   ,FORM)
	FORM)))

(DEFUN CLASS-CONSTRUCTOR-FAST-P (CLASS)
  #+Genera (DECLARE (VALUES FAST-P INLINE-P))
  (FLET ((APPLICABLE-METHODS (GENERIC-FUNCTION &REST ARGUMENTS)
	   (DECLARE (DYNAMIC-EXTENT ARGUMENTS))
	   (COMPUTE-APPLICABLE-METHODS GENERIC-FUNCTION ARGUMENTS))
	 (VERIFY (GENERIC-FUNCTION ALLOWED-QUALIFIERS METHODS)
	   (LOOP FOR METHOD IN METHODS
		 AS QUALIFIERS = (METHOD-QUALIFIERS METHOD)
		 ALWAYS (IF QUALIFIERS
			    (MEMBER (FIRST QUALIFIERS) ALLOWED-QUALIFIERS)
			    (EQ (FIRST (METHOD-SPECIALIZERS METHOD))
				(FIND-CLASS (IF (EQ GENERIC-FUNCTION *ALLOCATE-INSTANCE*)
						'STANDARD-CLASS 'STANDARD-OBJECT)))))))
    (LET* ((INSTANCE (CLASS-PROTOTYPE CLASS))
	   (ALLOCATE-METHODS (APPLICABLE-METHODS *ALLOCATE-INSTANCE* CLASS))
	   (INITIALIZE-METHODS (APPLICABLE-METHODS *INITIALIZE-INSTANCE* INSTANCE))
	   (SHARED-METHODS (APPLICABLE-METHODS *SHARED-INITIALIZE* INSTANCE T)))
      (VALUES
	;; True if the standard method for ALLOCATE-INSTANCE is
	;; immediately followed by the standard method for
	;; SHARED-INITIALIZE
	(AND (VERIFY *ALLOCATE-INSTANCE* '(:BEFORE) ALLOCATE-METHODS)
	     (VERIFY *INITIALIZE-INSTANCE* '(:AFTER) INITIALIZE-METHODS)
	     (VERIFY *SHARED-INITIALIZE* '(:AFTER) SHARED-METHODS))
	;; True if the shared-initialize will be inlined
	(AND (VERIFY *INITIALIZE-INSTANCE* '(:BEFORE :AFTER) INITIALIZE-METHODS)
	     (VERIFY *SHARED-INITIALIZE* '(:BEFORE :AFTER) SHARED-METHODS))))))

;;; The keyword arguments that must be passed to this method, either for
;;; its own use or for it to pass along via CALL-NEXT-METHOD.
;;; SUPPLY-ALL-KEYWORDS is true if all arguments must be visible as an &REST parameter.
(DEFUN METHOD-REQUIRED-KEYWORDS (METHOD NEXT-METHODS)
  #+Genera (DECLARE (VALUES KEYWORDS SUPPLY-ALL-KEYWORDS))
  (IF (CONSP METHOD)
      ;; Must be a MAKE-METHOD form
      (LET ((KEYWORDS NIL)
	    (SUPPLY-ALL-KEYWORDS NIL))
	#+Genera
	(LT:MAPFORMS #'(LAMBDA (FORM KIND USAGE STATE)
			 (DECLARE (IGNORE USAGE STATE))
			 (WHEN (AND (LISTP KIND)
				    (CONSP FORM)
				    (EQ (FIRST FORM) 'CALL-METHOD))
			   (MULTIPLE-VALUE-BIND (KEYS ALL)
			       (METHOD-REQUIRED-KEYWORDS (SECOND FORM) (THIRD FORM))
			     (SETQ KEYWORDS (UNION KEYWORDS KEYS)
				   SUPPLY-ALL-KEYWORDS (OR SUPPLY-ALL-KEYWORDS ALL))))
			 NIL)
		     METHOD)
	#+CLOE-Runtime
	(LABELS ((COPYFORMS-FUNCTION (FORM CONTEXT)
		   (IF (AND (EQ CONTEXT :FUNCTION-CALL)
			    (CONSP FORM)
			    (EQ (FIRST FORM) 'CALL-METHOD))
		       (MULTIPLE-VALUE-BIND (KEYS ALL)
			   (METHOD-REQUIRED-KEYWORDS (SECOND FORM) (THIRD FORM))
			 (SETQ KEYWORDS (UNION KEYWORDS KEYS)
			       SUPPLY-ALL-KEYWORDS (OR SUPPLY-ALL-KEYWORDS ALL))
			 FORM)
		       (MAP-FORMS-RECURSE #'COPYFORMS-FUNCTION FORM CONTEXT))))
	  (MAP-FORMS-TOPLEVEL #'COPYFORMS-FUNCTION METHOD))
	#-(OR Genera CLOE-Runtime)
	(NYI)
	(VALUES KEYWORDS SUPPLY-ALL-KEYWORDS))
      ;; Must be a METHOD object
      (MULTIPLE-VALUE-BIND (N-REQUIRED-ARGUMENTS N-OPTIONAL-ARGUMENTS SUPPLY-ALL-KEYWORDS
			    KEYWORDSP KEYWORDS)
	  (LAMBDA-LIST-COMPONENTS (METHOD-LAMBDA-LIST METHOD))
	(DECLARE (IGNORE N-REQUIRED-ARGUMENTS N-OPTIONAL-ARGUMENTS KEYWORDSP))
	(IF (AND NEXT-METHODS
		 (NOT (METHOD-NO-NEXT-METHOD-INFORMATION METHOD)))
	    ;; If CALL-NEXT-METHOD is used, the next-method may need to see all keywords
	    (MULTIPLE-VALUE-BIND (KEYS ALL)
		(METHOD-REQUIRED-KEYWORDS (FIRST NEXT-METHODS) (REST NEXT-METHODS))
	      (VALUES (UNION KEYWORDS KEYS) (OR SUPPLY-ALL-KEYWORDS ALL)))
	    (VALUES KEYWORDS SUPPLY-ALL-KEYWORDS)))))

(DEFUN CLASS-INITIALIZATION-METHODS-USE-INITARG (CLASS KEY)
  (FLET ((CHECK (GENERIC-FUNCTION &REST ARGUMENTS)
	   (DECLARE (DYNAMIC-EXTENT ARGUMENTS))
	   (DOLIST (METHOD (COMPUTE-APPLICABLE-METHODS GENERIC-FUNCTION ARGUMENTS))
	     (UNLESS (OR (AND (OR (EQ GENERIC-FUNCTION *INITIALIZE-INSTANCE*)
				  (EQ GENERIC-FUNCTION *SHARED-INITIALIZE*))
			      (NULL (METHOD-QUALIFIERS METHOD))
			      (EQ (FIRST (METHOD-SPECIALIZERS METHOD))
				  (FIND-CLASS 'STANDARD-OBJECT)))
			 (AND (OR (EQ GENERIC-FUNCTION *MAKE-INSTANCE*)
				  (EQ GENERIC-FUNCTION *ALLOCATE-INSTANCE*))
			      (NULL (METHOD-QUALIFIERS METHOD))
			      (EQ (FIRST (METHOD-SPECIALIZERS METHOD))
				  (FIND-CLASS 'STANDARD-CLASS))))
	       (MULTIPLE-VALUE-BIND (KEYWORDS SUPPLY-ALL-KEYWORDS)
		   (METHOD-REQUIRED-KEYWORDS METHOD NIL)
		 (WHEN (OR SUPPLY-ALL-KEYWORDS (MEMBER KEY KEYWORDS))
		   (RETURN T)))))))
    (LET ((INSTANCE (CLASS-PROTOTYPE CLASS)))
      (OR (CHECK *MAKE-INSTANCE* CLASS)
	  (CHECK *ALLOCATE-INSTANCE* CLASS)
	  (CHECK *INITIALIZE-INSTANCE* INSTANCE)
	  (CHECK *SHARED-INITIALIZE* INSTANCE T)))))

;; Generate inline code for a call to a generic function
;; Not 100% general, but works for initialization methods
;;   GENERIC-FUNCTION - the generic function being called
;;   ARG1 - form evaluated at run time to give the actual first argument
;;   ARGS - list of argument forms for the generic function, always self-evaluating objects,
;;          includes only the arguments preceding the initargs
;;   INITARGS-ALIST - ((initarg-name value-form supplied-p-form) ...)
;;          The forms are always safe to evaluate at "random" times (variables or constants).
;;   FAST-P - true if the only thing that happens between the system method for
;;            ALLOCATE-INSTANCE and the system method for SHARED-INITIALIZE is
;;            the system method for INITIALIZE-INSTANCE.
;;   REST-P - name of variable containing the list of keyword arguments originally
;;	      supplied to MAKE-INSTANCE, or NIL if there is no list (i.e. this is a
;;	      positional constructor).
(DEFUN GENERATE-INLINE-EFFECTIVE-METHOD (GENERIC-FUNCTION ARG1 ARGS INITARGS-ALIST
					 FAST-P REST-P)
  #+Genera (DECLARE (VALUES FORM BINDINGS))
  (LET ((EFFECTIVE-METHOD-FORM
	  (COMPUTE-EFFECTIVE-METHOD GENERIC-FUNCTION
				    (GENERIC-FUNCTION-METHOD-COMBINATION GENERIC-FUNCTION)
				    (COMPUTE-APPLICABLE-METHODS GENERIC-FUNCTION ARGS)))
	(BINDINGS NIL)
	(PRIMARY-CALLED NIL))
    (LABELS ((GENERATE (FORM)
	       (SETF FORM (MACROEXPAND FORM))
	       (IF (ATOM FORM) FORM
		   (CASE (CAR FORM)
		     ((PROGN PROG1 MULTIPLE-VALUE-PROG1)
		      (CONS (CAR FORM) (MAPCAR #'GENERATE (CDR FORM))))
		     ((CALL-METHOD)
		      (DESTRUCTURING-BIND (METHOD . MAYBE-NEXT-METHODS) (CDR FORM)
			(MULTIPLE-VALUE-BIND (FORM BINDS)
			    (GENERATE-INLINE-METHOD GENERIC-FUNCTION METHOD ARG1 ARGS
						    INITARGS-ALIST MAYBE-NEXT-METHODS
						    FAST-P PRIMARY-CALLED REST-P)
			  (WHEN (NULL (METHOD-QUALIFIERS METHOD))
			    (SETQ PRIMARY-CALLED T))
			  (SETQ BINDINGS (NCONC BINDINGS BINDS))
			  FORM)))
		     ((QUOTE) FORM)
		     (OTHERWISE
		       (VERIFY-FAST-P GENERIC-FUNCTION PRIMARY-CALLED FAST-P FORM)
		       FORM)))))
      (VALUES (GENERATE EFFECTIVE-METHOD-FORM) BINDINGS))))

;;; Complain if FAST-P is true and something other than calling a system method occurs between
;;; the system method for ALLOCATE-INSTANCE and the system method for SHARED-INITIALIZE
(DEFUN VERIFY-FAST-P (GENERIC-FUNCTION PRIMARY-CALLED FAST-P FORM)
  (WHEN (AND FAST-P
	     (COND ((EQ GENERIC-FUNCTION *MAKE-INSTANCE*) NIL)
		   ((EQ GENERIC-FUNCTION *ALLOCATE-INSTANCE*) PRIMARY-CALLED)	     ;after
		   ((EQ GENERIC-FUNCTION *SHARED-INITIALIZE*) (NOT PRIMARY-CALLED))  ;before
		   ((EQ GENERIC-FUNCTION *INITIALIZE-INSTANCE*) (NOT PRIMARY-CALLED));before
		   (T T)))
    (ERROR "INTERNAL ERROR: FAST-P true but ~S occurred unexpectedly" FORM)))

;; Methods for which we have a special code generator
;; Alist of ((GENERIC SPECIALIZERS QUALIFIERS GENERATOR)...)
;; This can't just be keyed by method metaobject because redefining a method
;; conses a new metaobject, unlike redefining a class or a generic function
(DEFVAR *INLINE-METHOD-GENERATORS*
	`((,#'MAKE-INSTANCE       (,(FIND-CLASS 'STANDARD-CLASS))                   ()
	   GENERATE-INLINE-MAKE-INSTANCE)
	  (,#'ALLOCATE-INSTANCE   (,(FIND-CLASS 'STANDARD-CLASS))                   ()
	   GENERATE-INLINE-ALLOCATE-INSTANCE)
	  (,#'INITIALIZE-INSTANCE (,(FIND-CLASS 'STANDARD-OBJECT))                  ()
	   GENERATE-INLINE-INITIALIZE-INSTANCE)
	  (,#'SHARED-INITIALIZE   (,(FIND-CLASS 'STANDARD-OBJECT) ,(FIND-CLASS 'T)) ()
	   GENERATE-INLINE-SHARED-INITIALIZE)))

(DEFUN GENERATE-INLINE-METHOD (GENERIC-FUNCTION METHOD ARG1 ARGS INITARGS-ALIST 
			       MAYBE-NEXT-METHODS FAST-P PRIMARY-CALLED REST-P)
  #+Genera (DECLARE (VALUES FORM BINDINGS))
  ;; See if this is one of the methods for which we have a special code generator
  (LOOP FOR (GENERIC SPECIALIZERS QUALIFIERS GENERATOR) IN *INLINE-METHOD-GENERATORS* DO
    (WHEN (AND (EQ GENERIC GENERIC-FUNCTION)
	       (EQUIVALENT-SPECIALIZER-LISTS-P SPECIALIZERS (METHOD-SPECIALIZERS METHOD))
	       (EQUIVALENT-QUALIFIERS-P QUALIFIERS (METHOD-QUALIFIERS METHOD)))
      (RETURN-FROM GENERATE-INLINE-METHOD
	(FUNCALL GENERATOR ARG1 ARGS INITARGS-ALIST (CAR MAYBE-NEXT-METHODS) FAST-P REST-P))))
  ;; No special code generator, we must actually call the method
  ;; We optimize by passing it only the particular keyword arguments it is looking for
  (VERIFY-FAST-P GENERIC-FUNCTION PRIMARY-CALLED FAST-P
		 `(CALL-METHOD ,METHOD ,@MAYBE-NEXT-METHODS))
  (MULTIPLE-VALUE-BIND (KEYWORDS SUPPLY-ALL-KEYWORDS)
      (METHOD-REQUIRED-KEYWORDS METHOD (CAR MAYBE-NEXT-METHODS))
    (MULTIPLE-VALUE-BIND (METHOD-FUNCTION-NAME EXTRA-ARGUMENT)
	(GENERATE-COMBINED-METHOD
	  GENERIC-FUNCTION
	  #'(LAMBDA (TYPE POSITION)
	      ;; Return values corresponding to what will be true in the general case.
	      (LET ((ARG (NTH POSITION ARGS)))
		(ECASE TYPE
		  (CLASS
		    (IF (EQL POSITION 0)
			(CLASS-OF ARG)
			(FIND-CLASS T)))
		  (EQL
		    ;; Only return T if this argument will always be EQL-specialized.
		    (IF (EQ GENERIC-FUNCTION *MAKE-INSTANCE*)
			(VALUES T ARG)
			(VALUES NIL NIL))))))
	  `(CALL-METHOD ,METHOD ,@MAYBE-NEXT-METHODS)
	  NIL NIL
	  :USE-EXTRA-ARGUMENT NIL)
      ;; We handle keywords where supplied-p is not T (i.e. there is no default for
      ;; the initialization argument) by getting the keyword from the &rest parameter
      ;; rather than passing it explicitly.
      (LET ((USE-REST-ARGUMENT (LOOP FOR (KEY NIL SUPPLIED-P) IN INITARGS-ALIST DO
				 (WHEN (OR SUPPLY-ALL-KEYWORDS (MEMBER KEY KEYWORDS))
				   (UNLESS (EQ SUPPLIED-P 'T)
				     ;; A consistency check to make sure we never need
				     ;; a run-time test of a supplied-p
				     (UNLESS REST-P
				       (ERROR "INTERNAL ERROR: Key ~S has supplied-p ~S, ~
					       should be T." KEY SUPPLIED-P))
				     (RETURN T)))))
	    (OTHER-INITARGS (LOOP FOR (KEY VALUE SUPPLIED-P) IN INITARGS-ALIST
				  WHEN (OR SUPPLY-ALL-KEYWORDS (MEMBER KEY KEYWORDS))
				    WHEN (EQ SUPPLIED-P 'T)
				      COLLECT `',KEY
				      AND COLLECT VALUE)))
	#+Genera
	(WHEN (> (+ (LENGTH ARGS) (LENGTH OTHER-INITARGS))
		 (FLOOR SYS:CONTROL-STACK-MAX-FRAME-SIZE 2))
	  ;; Try to avoid overflowing the stack frame, by using the data stack
	  ;; The exact limit is SYS:CONTROL-STACK-MAX-FRAME-SIZE minus the number of
	  ;; parameters and local bindings (not known in this function) minus an
	  ;; architecture-dependent constant.  The value used here should work.
	  (LET* ((TEMP '#:OTHER-INITARGS)
		 (FORM (APPLY #'GENERIC-FUNCTION-CALL-FORM
			      GENERIC-FUNCTION
			      'APPLY
			      `(SCL:FUNCTION ,METHOD-FUNCTION-NAME)
			      `',EXTRA-ARGUMENT
			      ARG1
			      `(,@(CDR ARGS)
				(SYS:G-L-P ,TEMP)))))
	    (RETURN-FROM GENERATE-INLINE-METHOD
	      `(SYS:WITH-STACK-ARRAY (,TEMP ,(LENGTH OTHER-INITARGS) :TYPE SYS:ART-Q-LIST)
		 ,@(LOOP FOR ITEM IN OTHER-INITARGS AND INDEX FROM 0
			 COLLECT `(SETF (AREF ,TEMP ,INDEX) ,ITEM))
		 ,FORM))))
	(APPLY #'GENERIC-FUNCTION-CALL-FORM
	       GENERIC-FUNCTION
	       (IF USE-REST-ARGUMENT 'APPLY 'FUNCALL)
	       #+Genera `(SCL:FUNCTION ,METHOD-FUNCTION-NAME)
	       #-Genera `(FUNCTION ,METHOD-FUNCTION-NAME)
	       `',EXTRA-ARGUMENT
	       ARG1
	       `(,@(CDR ARGS)
		 ,@OTHER-INITARGS
		 ,@(AND USE-REST-ARGUMENT `(,REST-P))))))))

(DEFUN CALL-METHOD-FUNCTION (GENERIC-FUNCTION METHOD-FUNCTION EXTRA-ARGUMENT
			     FUNCALL-OR-APPLY ARGUMENT-FORMS)
  #-|3600| (DECLARE (IGNORE GENERIC-FUNCTION))
  ;; In Genera we would like to call #',(SYS:FUNCTION-NAME METHOD-FUNCTION) rather
  ;; than calling ',METHOD-FUNCTION, so that we could use a direct call instruction
  ;; (linked on the Ivory) rather than a start-call sp|pop instruction.  However,
  ;; it doesn't work, and in fact generates a run-time call to FDEFINITION.
  ;; The problem seems to be that methods don't have function cells.
  ;; At least for now, we will just live with the start-call sp|pop instruction.
  #+|3600|
  `(,FUNCALL-OR-APPLY ',METHOD-FUNCTION
    ,(FIRST ARGUMENT-FORMS) ',EXTRA-ARGUMENT ',GENERIC-FUNCTION
    ,@(REST ARGUMENT-FORMS))
  #-|3600|
  `(,FUNCALL-OR-APPLY ',METHOD-FUNCTION ',EXTRA-ARGUMENT ,(FIRST ARGUMENT-FORMS)
    ,@(REST ARGUMENT-FORMS)))

;; This is based on (METHOD MAKE-INSTANCE (STANDARD-CLASS))
(DEFUN GENERATE-INLINE-MAKE-INSTANCE (ARG1 ARGS INITARGS-ALIST NEXT-METHODS FAST-P REST-P)
  #+Genera (DECLARE (VALUES FORM BINDINGS))
  (DECLARE (IGNORE NEXT-METHODS))		;never does CALL-NEXT-METHOD
  ;; Doesn't need to call CLASS-FINALIZED-P, FINALIZE-INHERITANCE, DEFAULT-INITARGS,
  ;; or VALIDATE-KEYWORDS-INTERNAL since that part is handled before we ever get here
  ;; Inline the calls to ALLOCATE-INSTANCE and INITIALIZE-INSTANCE
  (MULTIPLE-VALUE-BIND (ALLOCATE-INSTANCE BINDINGS)
      (GENERATE-INLINE-EFFECTIVE-METHOD *ALLOCATE-INSTANCE* ARG1 ARGS
					INITARGS-ALIST FAST-P REST-P)
    (LET ((INSTANCE '#:INSTANCE))		;local variable to hold the instance
      (MULTIPLE-VALUE-BIND (INITIALIZE-INSTANCE MORE-BINDINGS)
	  (GENERATE-INLINE-EFFECTIVE-METHOD *INITIALIZE-INSTANCE* INSTANCE
					    (LIST (CLASS-PROTOTYPE (FIRST ARGS)))
					    INITARGS-ALIST FAST-P REST-P)
	(VALUES (IF (PROGN
		      #-Genera T
		      #+Genera (BLOCK NIL
				 ;; Optimize out the variable binding if it's not used
				 (LT:MAPFORMS #'(LAMBDA (SUBFORM KIND USAGE STATE)
						  (DECLARE (IGNORE USAGE))
						  (WHEN (AND (EQ KIND 'LT:SYMEVAL)
							     (EQ SUBFORM INSTANCE)
							     (NOT (MEMBER SUBFORM LT:*MAPFORMS-BOUND-VARIABLES*)))
						    (RETURN T))
						  STATE)
					      INITIALIZE-INSTANCE :BOUND-VARIABLES NIL)
				 NIL))
		    `(LET ((,INSTANCE ,ALLOCATE-INSTANCE))
		       ,INITIALIZE-INSTANCE
		       ,INSTANCE)
		    `(PROG1 ,ALLOCATE-INSTANCE ,INITIALIZE-INSTANCE))
		(APPEND BINDINGS MORE-BINDINGS))))))

;; This is based on (METHOD ALLOCATE-INSTANCE (STANDARD-CLASS))
;; We're not going to worry about optimizing the FUNCALLABLE-STANDARD-CLASS case
;; If FAST-P and Ivory, this leaves BAR-1 pointing at the first slot
;; In all other cases the pointer for initializing the slots has to be set up later
(DEFUN GENERATE-INLINE-ALLOCATE-INSTANCE (ARG1 ARGS INITARGS-ALIST NEXT-METHODS FAST-P REST-P)
  #+Genera (DECLARE (VALUES FORM BINDINGS))
  (DECLARE (IGNORE NEXT-METHODS))		;never does CALL-NEXT-METHOD
  (DECLARE (IGNORE ARG1))			;doesn't look at class argument
  (DECLARE (IGNORE REST-P))			;never calls any user methods
  (LET* ((CLASS (FIRST ARGS))
	 (INSTANCE-INFORMATION (CLASS-INSTANCE-INFORMATION CLASS))
	 (SIZE (%INSTANCE-INFORMATION-SIZE INSTANCE-INFORMATION))
	 (AREA (SECOND (ASSOC 'STORAGE-AREA INITARGS-ALIST))))
    (COND (FAST-P
	   ;; Fast case allocates the storage inline and doesn't need to initialize it
	   ;; We are essentially inlining the first half of %ALLOCATE-INSTANCE-COPY here
	   #+IMACH `(PROG1
		      (SYS:%SET-TAG
			;was (SYS:%ALLOCATE-STRUCTURE-BLOCK ,AREA ,SIZE) -kmp 25-Jul-92
			,(ONCE-ONLY (AREA)
			   `(IF (EQ ,AREA :STACK)
				(SI:ALLOCATE-DATA-STACK ,SIZE)
				(SYS:%ALLOCATE-STRUCTURE-BLOCK ,AREA ,SIZE)))
			SYS:DTP-INSTANCE)
		      (SYS:%BLOCK-WRITE 1 (SYS:%SET-TAG
					    ',(SYS:%MAKE-POINTER-OFFSET SYS:DTP-LOCATIVE
									INSTANCE-INFORMATION
									3)
					    (SYS:%LOGDPBS SYS:%HEADER-TYPE-INSTANCE
							  SYS:%%Q-CDR-CODE-WITHIN-TAG
							  SYS:DTP-HEADER-P
							  SYS:%%Q-TYPE-WITHIN-TAG
							  0))))
	   #+Minima `(PROG1
		      (IVORY:%SET-TAG (IF (EQ ,AREA T)
					  (IVORY:%ALLOCATE-PRIMARY-BLOCK T ,SIZE)
					  (IVORY:%ALLOCATE-SECONDARY-BLOCK ,AREA ,SIZE))
				      (IVORY:DATA-TYPE 'IVORY::INSTANCE))
		      (IVORY:%BLOCK-WRITE 1 (IVORY::MAKE-HEADER-P IVORY:INSTANCE (IVORY:%POINTER-PLUS INSTANCE-INFORMATION 2))))
	   #+|3600| `(SI:%MAKE-STRUCTURE SYS:DTP-INSTANCE SYS:DTP-HEADER-P
				       SYS:%HEADER-TYPE-INSTANCE
				       ',INSTANCE-INFORMATION ,AREA ,SIZE)
	   #+CLOE-Runtime `(LET ((.INSTANCE. (%INSTANCE-UNBOUND-INIT
				       (SYS::MAKEINSTANCE
					 SYS::SPACE$K-STRUCTURE ,AREA ,SIZE))))
		     (SETF (%INSTANCE-INSTANCE-INFORMATION .INSTANCE.) ',INSTANCE-INFORMATION)
		     .INSTANCE.)
	   #-(OR Genera CLOE-Runtime Minima) `(%ALLOCATE-INSTANCE-INTERNAL
					',INSTANCE-INFORMATION
					(MAKE-ARRAY ,SIZE :INITIAL-ELEMENT *UNBOUND-INSTANCE-SLOT*)))
	  (T
	   ;; Slow case has to call a function to allocate the storage so that
	   ;; on Ivory the trap mode gets lowered right away before user code runs
	   (LET ((PROTOTYPE (CLASS-PROTOTYPE CLASS)))
	     `(PROG1 (%ALLOCATE-INSTANCE-COPY ',PROTOTYPE
					      #+(OR Genera CLOE-Runtime Minima) ,AREA)
		     ;; If the class was redefined while this code was executing,
		     ;; and the prototype got updated, the wired-in slot offsets
		     ;; will be wrong and we will smash something.  If the prototype
		     ;; did not get updated, we should be okay.
		     (#+Genera COMPILER:%ERROR-UNLESS
		      #-Genera UNLESS
		      (EQ (%INSTANCE-INSTANCE-INFORMATION ',PROTOTYPE)
			  ',INSTANCE-INFORMATION)
		      (ERROR "Class redefined at critical time while making an instance"))
		     ))))))

;; This is based on (METHOD INITIALIZE-INSTANCE (STANDARD-OBJECT))
(DEFUN GENERATE-INLINE-INITIALIZE-INSTANCE (ARG1 ARGS INITARGS-ALIST NEXT-METHODS
					    FAST-P REST-P)
  #+Genera (DECLARE (VALUES FORM BINDINGS))
  (DECLARE (IGNORE NEXT-METHODS))	;never does CALL-NEXT-METHOD
  (GENERATE-INLINE-EFFECTIVE-METHOD *SHARED-INITIALIZE* ARG1 `(,(FIRST ARGS) T ,@(REST ARGS))
				    INITARGS-ALIST FAST-P REST-P))

;; This is based on (METHOD SHARED-INITIALIZE (STANDARD-OBJECT T))
;; If FAST-P, no SLOT-BOUNDP checks are required because all the default-initargs 
;; and initforms get stored into the instance before any user code runs
(DEFUN GENERATE-INLINE-SHARED-INITIALIZE (ARG1 ARGS INITARGS-ALIST NEXT-METHODS FAST-P REST-P)
  #+Genera (DECLARE (VALUES FORM BINDINGS))
  (DECLARE (IGNORE NEXT-METHODS))		;never does CALL-NEXT-METHOD
  (DECLARE (IGNORE REST-P))			;never calls a user method
  (ASSERT (EQ (SECOND ARGS) T))			;SLOT-NAMES argument must be T
  (LET ((SLOT-VALUES NIL)			;alist from slot to value form
	(BINDINGS NIL)				;temporary variable bindings
	(SLOTS (CLASS-SLOTS (CLASS-OF (FIRST ARGS))))
	(CLASS-SLOTS NIL)
	(INSTANCE-INFORMATION (%INSTANCE-INFORMATION (FIRST ARGS)))
	(FIRST-SLOT NIL)
	(LAST-SLOT NIL)
	#+|3600| (POINTER '#:POINTER))		;temporary variable for 3600 block-write
    ;; Build up the slot initializations alist from the initialization arguments alist
    ;; Note that the value forms don't have side-effects, so multiple evaluation is fine
    ;; This assumes that INITARGS-ALIST is in the order that the initargs were actually
    ;; supplied, in the case where there are multiple initargs for a single slot
    (LOOP FOR (INITARG VALUE SUPPLIED-P) IN INITARGS-ALIST DO
      (LOOP FOR SLOT IN SLOTS DO
	(WHEN (MEMBER INITARG (SLOT-DEFINITION-INITARGS SLOT))
	  (LET ((ELEM (ASSOC SLOT SLOT-VALUES)))
	    (COND ((NULL ELEM)
		   (PUSH (LIST SLOT VALUE SUPPLIED-P) SLOT-VALUES))
		  ;; More than one initarg can fill this slot and we don't know which one
		  ;; it's going to be.  This will generate slightly inefficient code if
		  ;; there are more than two initargs for this slot...don't worry about it.
		  ((NOT (EQ (THIRD ELEM) 'T))
		   (SETF (SECOND ELEM) `(IF ,(THIRD ELEM) ,(SECOND ELEM) ,VALUE)
			 (THIRD ELEM) (IF (EQ SUPPLIED-P 'T) SUPPLIED-P
					  `(OR ,(THIRD ELEM) ,SUPPLIED-P)))))))))
    ;; Separate out the shared slots, and sort SLOTS by location
    (DOLIST (SLOT SLOTS)
      (UNLESS (EQ (SLOT-DEFINITION-ALLOCATION SLOT) ':INSTANCE)
	(SETQ SLOTS (REMOVE SLOT SLOTS))
	(PUSH SLOT CLASS-SLOTS)))
    (SETQ SLOTS (SORT (COPY-LIST SLOTS) #'< :KEY #'SLOT-DEFINITION-LOCATION))
    (LOOP FOR SLOT IN SLOTS
	  FOR POSITION FROM (PROGN #+(OR Genera Minima) 1
				   #+CLOE-Runtime 0
				   #-(OR Genera CLOE-Runtime Minima) (ERROR "Not implemented"))
	  DO
      (UNLESS (EQL (SLOT-DEFINITION-LOCATION SLOT) POSITION)
	(ERROR "INTERNAL ERROR: Slot ~S is at position ~S where ~S was expected"
	       (SLOT-DEFINITION-NAME SLOT) (SLOT-DEFINITION-LOCATION SLOT) POSITION)))
    (LET ((FILL-SLOTS
	    (COND (FAST-P
		   ;; This is the fast case, no boundp checks required
		   ;; Slots that are not initialized from the initargs are either initialized
		   ;; from the initform or unbound
		   (LOOP FOR SLOT IN SLOTS
			 AS NAME = (SLOT-DEFINITION-NAME SLOT)
			 AS INITFUNCTION = (SLOT-DEFINITION-INITFUNCTION SLOT)
			 AS INLINABLE = (SLOT-DEFINITION-INITFORM-INLINABLE SLOT)
			 AS (INITARG SUPPLIED-P) = (CDR (ASSOC SLOT SLOT-VALUES)) DO
		     (UNLESS (EQ SUPPLIED-P 'T)
		       ;; Compute the value that will be used if there is no initarg
		       (LET ((VALUE (COND ((NOT INITFUNCTION)
					   #+Genera `(SYS:%MAKE-POINTER SYS:DTP-NULL ',NAME)
					   #+Minima `(IVORY:%SET-TAG ',NAME (IVORY:DATA-TYPE 'IVORY::NULL))
					   #-(OR Genera Minima) '*UNBOUND-INSTANCE-SLOT*)
					  ((EQ INLINABLE 'CONSTANT)
					   ;; It's safe to inline the evaluation directly
					   ;; On Ivory, we can't inline even SIMPLE initforms
					   ;; because we are in trap mode at this point
					   ;; For non-Genera, we'll be conservative and not
					   ;; inline any complex forms, in case they would
					   ;; interfere with magic pointer-registers
					   ;; The 3600 might be able to inline SIMPLE,
					   ;; READER, and perhaps WRITER but I don't want
					   ;; to have to think it through and test it
					   (SLOT-DEFINITION-INITFORM SLOT))
					  #-Minima
					  (INLINABLE
					   ;; It's safe to inline the evaluation earlier in
					   ;; the function and bind it to a temporary variable
					   (LET ((TEMP (MAKE-SYMBOL (STRING NAME)))
						 (FORM (SLOT-DEFINITION-INITFORM SLOT)))
					     (WHEN SUPPLIED-P
					       (UNLESS (MEMBER INLINABLE '(SIMPLE READER))
						 (SETQ FORM `(UNLESS ,SUPPLIED-P ,FORM))))
					     (PUSH (LIST TEMP FORM) BINDINGS)
					     TEMP))
					  (T
					   ;; Cannot inline the evaluation of the initform
					   ;; Instead we must call the initfunction
					   (LET ((TEMP (MAKE-SYMBOL (STRING NAME)))
						 ;; We can't funcall the initfunction closure
						 ;; by function-spec, but if we were compiling
						 ;; to a file we could not use the closure as
						 ;; a constant either.  LOAD-TIME-VALUE?
						 (FORM `(FUNCALL ',INITFUNCTION)))
					     (WHEN SUPPLIED-P
					       (SETQ FORM `(UNLESS ,SUPPLIED-P ,FORM)))
					     (PUSH (LIST TEMP FORM) BINDINGS)
					     TEMP)))))
			 ;; Add run-time test if needed for whether to use initarg
			 (WHEN SUPPLIED-P
			   (SETQ VALUE (GENERATE-SUPPLIED-P-TEST SUPPLIED-P INITARG VALUE)))
			 (PUSH (LIST SLOT VALUE) SLOT-VALUES))))
		   (COND ((NULL SLOTS)
			  `(PROGN
			     ;; Ivory memory is consistent now, unlock the "lock"
			     ;; set by allocation
			     #+IMACH
			     (SETF (SYS:%TRAP-MODE)
				   (LDB SYS:%%CR.TRAP-MODE (SYS:%SAVED-CONTROL-REGISTER)))
			     #+Minima 
			     (IVORY::%SET-TRAP-MODE
			       (MINIMA-INTERNALS::FIXNUM-FIELD-VALUE
				 IVORY:CONTROL-REGISTER IVORY:TRAP-MODE
				 (IVORY::%SAVED-CONTROL-REGISTER)))
			     ))
			 (T
			  ;; Set up the pointer register if it's not already set up
			  ;; CLOE-Runtime should use a hardware address register for this
			  ;; #-Symbolics will have to do something less efficient
			  #+|3600| (PUSH `(,POINTER NIL) BINDINGS)
			  ;; Generate machine-dependent code to block-write into the slots
			  `(PROGN
			     #+CLOE-Runtime
			     (%INSTANCE-BLOCK-INIT
			       ,ARG1 0 ,@(LOOP FOR SLOT IN SLOTS COLLECT (SECOND (ASSOC SLOT SLOT-VALUES))))
			     #+|3600|
			     (SETQ ,POINTER (SYS:%MAKE-POINTER SYS:DTP-LOCATIVE ,ARG1))
			     #-CLOE-Runtime
			     ,@(LET (#-(OR Genera Minima) (I 0))
				 (LOOP FOR SLOT IN SLOTS
				       AS VALUE = (SECOND (ASSOC SLOT SLOT-VALUES))
				       COLLECT
					 #+IMACH  `(SYS:%BLOCK-WRITE 1 ,VALUE)
					 #+Minima `(IVORY:%BLOCK-WRITE 1 ,VALUE)
					 #+|3600|   `(SYS:%P-STORE-CONTENTS-INCREMENT-POINTER
						       ,VALUE ,POINTER)
					 #-(OR Genera MINIMA) `(SETF (%INSTANCE-REF ,ARG1
										    ,(PROG1 I
											    (INCF I)))
								     ,VALUE)))
			     ;; Ivory memory is consistent now, unlock the "lock"
			     ;; set by allocation
			     #+IMACH
			     (SETF (SYS:%TRAP-MODE)
				   (LDB SYS:%%CR.TRAP-MODE (SYS:%SAVED-CONTROL-REGISTER)))
			     #+Minima
			     (IVORY::%SET-TRAP-MODE
			       (MINIMA-INTERNALS::FIXNUM-FIELD-VALUE
				 IVORY:CONTROL-REGISTER IVORY:TRAP-MODE
				 (IVORY::%SAVED-CONTROL-REGISTER)))
			     ))))
		  (T
		   ;; This is the slow case, boundp checks are required
		   `(PROGN
		      ;; If the class was redefined and the newly-created instance got
		      ;; updated while executing user methods, the slot offsets used
		      ;; below will be out of date and we could clobber something.
		      (#+Genera COMPILER:%ERROR-UNLESS
		       #-Genera UNLESS
		       (EQ (%INSTANCE-INSTANCE-INFORMATION ,ARG1) ',INSTANCE-INFORMATION)
		       (ERROR "Class redefined at critical time while making an instance"))
		      ;; Generate machine-dependent code to block-write initargs into
		      ;; the slots, for the initargs that are always supplied.
		      ;; Since this is the slow case, the slots have already been initialized
		      ;; to unbound and we can avoid some redundant writes.  At least for
		      ;; now we won't check for the sparse-writes case, we'll just peel
		      ;; off redundant writes from the state and the end.
		      ,@(PROGN
			  (LOOP FOR SLOT IN SLOTS
				FOR OFFSET FROM (PROGN #+(OR Genera Minima) 1
						       #+CLOE-Runtime 0
						       #-(OR Genera CLOE-Runtime Minima) (NYI))
				DO
			    (COND ((EQ (THIRD (ASSOC SLOT SLOT-VALUES)) 'T)
				   (UNLESS FIRST-SLOT (SETQ FIRST-SLOT OFFSET))
				   (SETQ LAST-SLOT OFFSET))
				  (FIRST-SLOT (RETURN))))
			  (WHEN FIRST-SLOT
			    ;; There is something to do, set up the pointer register
			    ;; then fill in the slots from FIRST-SLOT through LAST-SLOT
			    #+|3600| (PUSH `(,POINTER NIL) BINDINGS)			    
			    `(#+IMach (SETF (SYS:%BLOCK-REGISTER 1)
					    (SYS:%POINTER-PLUS ,ARG1 ,FIRST-SLOT))
			      #+Minima (SETF (IVORY:BLOCK-REGISTER 1)
					     (IVORY:%POINTER-PLUS ,ARG1 ,FIRST-SLOT))
			      #+|3600|  (SETQ ,POINTER
					      (SYS:%MAKE-POINTER-OFFSET SYS:DTP-LOCATIVE
									,ARG1 ,(1- FIRST-SLOT)))
			      #+CLOE-Runtime  (%INSTANCE-BLOCK-INIT
					,ARG1 ,FIRST-SLOT
					,@(LOOP FOR SLOT IN (NTHCDR FIRST-SLOT SLOTS)
						REPEAT (- (1+ LAST-SLOT) FIRST-SLOT)
						COLLECT (SECOND (ASSOC SLOT SLOT-VALUES))))
			      #-CLOE-Runtime
			      ,@(LET (#-(OR Genera Minima) (I FIRST-SLOT))
				  (LOOP FOR SLOT IN (NTHCDR (- FIRST-SLOT
							       (PROGN #+(OR Genera Minima) 1
								      #-(OR Genera Minima) 0))
							    SLOTS)
					REPEAT (- (1+ LAST-SLOT) FIRST-SLOT)
					AS VALUE = (SECOND (ASSOC SLOT SLOT-VALUES))
					COLLECT
					  #+IMACH  `(SYS:%BLOCK-WRITE 1 ,VALUE)
					  #+Minima `(IVORY:%BLOCK-WRITE 1 ,VALUE)
					  #+|3600|   `(SYS:%P-STORE-CONTENTS-INCREMENT-POINTER
							,VALUE ,POINTER)
					  #-(OR Genera Minima) `(SETF (%INSTANCE-REF
									,ARG1 ,(PROG1 I (INCF I)))
								      ,VALUE))))))
		      ;; Generate machine-dependent code to do the initforms
		      ;; and to do the initargs for any that were not done above
		      ;; It would be nice to be able to use %STORE-INSTANCE-VARIABLE-ORDERED
		      ;; in Genera, but that would require setting up SELF.  Since this is
		      ;; the slow case anyway, we won't bother being quite that optimal.
		      ,@(LOOP FOR SLOT IN SLOTS 
			      FOR OFFSET FROM (PROGN #+(OR Genera Minima) 1
						     #+CLOE-Runtime 0
						     #-(OR Genera CLOE-Runtime Minima) (NYI))
			      AS (INITARG SUPPLIED-P) = (CDR (ASSOC SLOT SLOT-VALUES))
			      AS INITFUNCTION = (SLOT-DEFINITION-INITFUNCTION SLOT)
			      AS INITFORM = (SLOT-DEFINITION-INITFORM SLOT)
			      AS INLINABLE = (SLOT-DEFINITION-INITFORM-INLINABLE SLOT)
			      UNLESS (AND FIRST-SLOT (<= FIRST-SLOT OFFSET LAST-SLOT))
				WHEN (OR SUPPLIED-P INITFUNCTION)
				  COLLECT
				    (PROGN
				      #+(OR Genera Minima)
				      (CASE SUPPLIED-P
					((T)
					 `(SETF (%INSTANCE-REF ,ARG1 ,OFFSET) ,INITARG))
					((NIL)
					 `(LET ((LOCATION (LOCF (%INSTANCE-REF ,ARG1 ,OFFSET))))
					    (UNLESS (LOCATION-BOUNDP LOCATION)
					      (SETF (LOCATION-CONTENTS LOCATION)
						    ,(IF INLINABLE
							 INITFORM
							 ;; We can't funcall the initfunction
							 ;; closure by function-spec, but if
							 ;; we were compiling to a file we
							 ;; could not use the closure as a
							 ;; constant either.
							 ;; LOAD-TIME-VALUE?
							 `(FUNCALL ',INITFUNCTION))))))
					(OTHERWISE
					  `(LET ((LOCATION (LOCF (%INSTANCE-REF ,ARG1 ,OFFSET))))
					     (COND (,SUPPLIED-P
						    (SETF (LOCATION-CONTENTS LOCATION)
							  ,INITARG))
						   ,@(WHEN INITFUNCTION
						       `(((NOT (LOCATION-BOUNDP LOCATION))
							  (SETF (LOCATION-CONTENTS LOCATION)
								,(IF INLINABLE
								     INITFORM
								     ;; We can't funcall the
								     ;; initfunction closure
								     ;; by function-spec, but
								     ;; if we were compiling
								     ;; to a file we could not
								     ;; use the closure as a
								     ;; constant either.
								     ;; LOAD-TIME-VALUE?
								     `(FUNCALL ',INITFUNCTION))))))))))
				      #-(OR Genera Minima)
				      ;;This is the same as the genera one except for rewrites wrt locatives
				      ;; and minor things like that.
				      (CASE SUPPLIED-P
					((T)
					 `(SETF (%INSTANCE-REF ,ARG1 ,OFFSET) ,INITARG))
					((NIL)
					 `(UNLESS (%INSTANCE-SLOT-BOUNDP ,ARG1 ,OFFSET)
					    (SETF (%INSTANCE-REF ,ARG1 ,OFFSET)
						  ,(IF INLINABLE
						       INITFORM
						       `(FUNCALL ',INITFUNCTION)))))
					(OTHERWISE
					  `(COND (,SUPPLIED-P
						  (SETF (%INSTANCE-REF ,ARG1 ,OFFSET) ,INITARG))
						 ,@(WHEN INITFUNCTION
						     `(((NOT (%INSTANCE-SLOT-BOUNDP ,ARG1 ,OFFSET))
							(SETF (%INSTANCE-REF ,ARG1 ,OFFSET)
							      ,(IF INLINABLE
								   INITFORM
								   `(FUNCALL ',INITFUNCTION))))))))))))))))
      (VALUES 
	;; Generate code to fill the class slots
	;; This can use SLOT-DEFINITION-LOCATION as a constant because if a new
	;; vector of class slots is created, the old slots get forwarded to the new ones
	;; I don't know if the #-Genera code works...compiler must maintain constant identity
	(APPEND FILL-SLOTS
		(LOOP FOR SLOT IN CLASS-SLOTS
		      AS (INITARG SUPPLIED-P) = (CDR (ASSOC SLOT SLOT-VALUES))
		      AS INITFUNCTION = (SLOT-DEFINITION-INITFUNCTION SLOT)
		      AS INITFORM = (SLOT-DEFINITION-INITFORM SLOT)
		      AS INLINABLE = (SLOT-DEFINITION-INITFORM-INLINABLE SLOT)
		      AS LOCATION = (SLOT-DEFINITION-LOCATION SLOT)
		      AS PLACE = `(#+(OR Genera Minima) LOCATION-CONTENTS
				   #-(OR Genera Minima) CAR
				   ',LOCATION)
		      AS INITARG-FORM = `(SETF ,PLACE ,INITARG)
		      AS INITFORM-FORM = (WHEN INITFUNCTION
					   `(UNLESS
					      #+(OR Genera Minima) (LOCATION-BOUNDP ',LOCATION)
					      #-(OR Genera Minima) (EQ ,PLACE *UNBOUND-INSTANCE-SLOT*)
					      (SETF ,PLACE
						    ,(IF INLINABLE
							 INITFORM
							 ;; We can't funcall the initfunction
							 ;; closure by function-spec, but if
							 ;; we were compiling to a file we
							 ;; could not use the closure as a
							 ;; constant either.
							 ;; LOAD-TIME-VALUE?
							 `(FUNCALL ',INITFUNCTION)))))
		      COLLECT (CASE SUPPLIED-P
				((T) INITARG-FORM)
				((NIL) INITFORM-FORM)
				(OTHERWISE (GENERATE-SUPPLIED-P-TEST SUPPLIED-P
								     INITARG-FORM
								     INITFORM-FORM)))))
	;; The order doesn't really matter, but it's more tasteful to bind things
	;; in the same order that they are used, if only for human readability
	(NREVERSE BINDINGS)))))

(DEFUN GENERATE-SUPPLIED-P-TEST (SUPPLIED-P IF-SUPPLIED DEFAULT)
  #+IMach (WHEN (AND (CONSP SUPPLIED-P)
		     (EQ (CAR SUPPLIED-P) 'SI:KEYWORD-SUPPLIED-P-INTERNAL)
		     (CONSP IF-SUPPLIED)
		     (EQ (CAR IF-SUPPLIED) 'SYS:RGETF)
		     (EQUAL (CDR SUPPLIED-P) (CDR IF-SUPPLIED)))
	    (RETURN-FROM GENERATE-SUPPLIED-P-TEST
	      ;; Optimize to avoid calling RGETF twice
	      ;; The compiler could be improved to generate 3 instructions for this
	      ;; instead of the present 6 instructions, by being smarter about popping
	      (LET ((VALUE '#:VALUE)
		    (SUPPLIED-P '#:SUPPLIED-P))
		`(MULTIPLE-VALUE-BIND (,VALUE ,SUPPLIED-P)
		     ,IF-SUPPLIED
		   (IF ,SUPPLIED-P ,VALUE ,DEFAULT)))))
  `(IF ,SUPPLIED-P ,IF-SUPPLIED ,DEFAULT))

(INITIALIZE-CLOS-6)
