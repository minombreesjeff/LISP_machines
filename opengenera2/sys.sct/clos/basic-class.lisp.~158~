;;; -*- Mode: LISP; Syntax: ANSI-Common-Lisp; Base: 10; Package: CLOS-INTERNALS -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(IN-PACKAGE :CLOS-INTERNALS)

;;; "Accessors" for built-in and structure classes
(DEFMETHOD CLASS-DEFAULT-INITARGS ((CLASS BUILT-IN-CLASS))
  NIL)

(DEFMETHOD CLASS-DEFAULT-INITARGS ((CLASS STRUCTURE-CLASS))
  NIL)

;;; It's too hard to parse Flavors' composed initializations back into this,
;;; so let's just do it the dumb way
#+Genera
(DEFMETHOD CLASS-DEFAULT-INITARGS ((CLASS FLAVOR-CLASS))
  (LET ((DEFAULT-INITARGS NIL))
    (FLAVOR::MAP-ALL-FLAVOR-COMPONENTS
      (SLOT-VALUE CLASS 'NAME)
      #'(LAMBDA
	  (COMPONENT)
	  (LET ((FLAVOR (FLAVOR:FIND-FLAVOR COMPONENT NIL)))
	    (WHEN FLAVOR
	      (LOOP FOR (KEY VAL) ON (FLAVOR::FLAVOR-DEFAULT-INIT-PLIST FLAVOR) BY #'CDDR DO
		(UNLESS (LOOP FOR K IN DEFAULT-INITARGS BY #'CDDR
			      THEREIS (EQ K KEY))
		  (SETQ DEFAULT-INITARGS (NCONC DEFAULT-INITARGS (LIST* KEY VAL NIL)))))))))
    DEFAULT-INITARGS))

(DEFMETHOD CLASS-DIRECT-DEFAULT-INITARGS ((CLASS BUILT-IN-CLASS))
  NIL)

(DEFMETHOD CLASS-DIRECT-DEFAULT-INITARGS ((CLASS STRUCTURE-CLASS))
  NIL)

(DEFMETHOD CLASS-DIRECT-DEFAULT-INITARGS ((CLASS METHOD-ONLY-CLASS)) NIL)

#+Genera
(DEFMETHOD CLASS-DIRECT-DEFAULT-INITARGS ((CLASS FLAVOR-CLASS))
  (LOOP FOR (KEY FORM) ON (FLAVOR::FLAVOR-DEFAULT-INIT-PLIST
			    (CLASS-INSTANCE-INFORMATION CLASS)) BY #'CDDR
	COLLECT (LIST KEY FORM (MAKE-EVAL-CLOSURE FORM))))

(DEFMETHOD CLASS-DIRECT-SLOTS ((CLASS BUILT-IN-CLASS))
  NIL)

(DEFMETHOD CLASS-DIRECT-SLOTS ((CLASS METHOD-ONLY-CLASS)) NIL)

#+Genera
(DEFMETHOD CLASS-DIRECT-SLOTS ((CLASS FLAVOR-CLASS))
  (DECLARE (NOTINLINE MAKE-INSTANCE))
  (LET* ((FLAVOR (CLASS-INSTANCE-INFORMATION CLASS))
	 (INITS (FLAVOR::FLAVOR-LOCAL-INSTANCE-VARIABLE-INITIALIZATIONS FLAVOR))
	 (INITABLE (FLAVOR::FLAVOR-LOCAL-INITABLE-INSTANCE-VARIABLES FLAVOR))
	 (READABLE (FLAVOR::FLAVOR-LOCAL-READABLE-INSTANCE-VARIABLES FLAVOR))
	 (WRITABLE (FLAVOR::FLAVOR-LOCAL-WRITABLE-INSTANCE-VARIABLES FLAVOR))
	 (LOCATABLE (FLAVOR::FLAVOR-LOCAL-LOCATABLE-INSTANCE-VARIABLES FLAVOR)))
    (LOOP FOR NAME IN (FLAVOR::FLAVOR-LOCAL-INSTANCE-VARIABLES FLAVOR)
	  AS INIT = (ASSOC NAME INITS)
	  COLLECT (MAKE-INSTANCE 'STANDARD-DIRECT-SLOT-DEFINITION
				 :ALLOCATION ':INSTANCE
				 :INITARGS (LOOP FOR (KEY VAR) IN INITABLE
						 WHEN (EQ VAR NAME) COLLECT KEY)
				 :INITFORM (SECOND INIT)
				 :INITFUNCTION (AND INIT
						    (MAKE-EVAL-CLOSURE (SECOND INIT)))
				 :LOCATORS (LOOP FOR (GEN VAR) IN LOCATABLE
						 WHEN (EQ VAR NAME) COLLECT GEN)
				 :NAME NAME
				 :READERS (LOOP FOR (GEN VAR) IN READABLE
						 WHEN (EQ VAR NAME) COLLECT GEN)
				 :TYPE 'T
				 :WRITERS (LOOP FOR (GEN VAR) IN WRITABLE
						 WHEN (EQ VAR NAME) COLLECT GEN)))))

(DEFMETHOD (SETF CLASS-NAME) :AFTER (NEW-NAME (CLASS CLASS))
  (WHEN (CLASS-FINALIZED-P CLASS)
    (SETF (%CLASS-INSTANCE-INFORMATION-CLASS-NAME (CLASS-INSTANCE-INFORMATION CLASS))
	  NEW-NAME))	
  (NOTICE-CLASS-NAME-CHANGE CLASS))

#+Genera
(DEFMETHOD (SETF CLASS-NAME) :AROUND (NEW-NAME (CLASS STANDARD-CLASS))
  (WITH-PENDING-DW-UPDATES
    (LET ((OLD-NAME (AND (SLOT-BOUNDP CLASS 'NAME) (SLOT-VALUE CLASS 'NAME))))
      ;; When renaming a class, tell DW about the changes to the old and new names
      (WHEN (AND (NOT (EQ OLD-NAME NEW-NAME))
		 (NOT (NULL OLD-NAME))
		 (SYMBOLP OLD-NAME))
	(NOTE-CHANGE-FOR-DW OLD-NAME)))
    (CALL-NEXT-METHOD)))

(DEFMETHOD CLASS-PRECEDENCE-LIST ((CLASS CLASS))
  (IF (CLASS-FINALIZED-P CLASS)
      (%CLASS-INSTANCE-INFORMATION-PRECEDENCE-LIST
	(CLASS-INSTANCE-INFORMATION CLASS))
      (COMPUTE-CLASS-PRECEDENCE-LIST CLASS)))

#+Genera
(DEFMETHOD CLASS-PRECEDENCE-LIST ((CLASS FLAVOR-CLASS))
  (LET ((FLAVOR (CLASS-INSTANCE-INFORMATION CLASS)))
    (IF (FLAVOR::FLAVOR-COMPONENTS-COMPOSED FLAVOR)
	(NCONC (MAPCAR #'FIND-CLASS (FLAVOR:FLAVOR-ALL-COMPONENTS FLAVOR))
	       (LIST (FIND-CLASS 'T)))
	(COMPUTE-CLASS-PRECEDENCE-LIST CLASS))))

(DEFMETHOD CLASS-INITIALIZED-P ((CLASS STANDARD-CLASS))
  (LDB-TEST %%STANDARD-CLASS-INITIALIZED-P (CLASS-BITS CLASS)))

(DEFMETHOD CLASS-INITIALIZED-P ((CLASS BUILT-IN-CLASS))
  T)

(DEFMETHOD CLASS-INITIALIZED-P ((CLASS FORWARD-REFERENCED-CLASS))
  NIL)

(DEFMETHOD CLASS-INITIALIZED-P ((CLASS METHOD-ONLY-CLASS))
  (NOT (NULL (CLASS-DIRECT-SUPERCLASSES CLASS))))

#+Genera
(DEFMETHOD CLASS-INITIALIZED-P ((CLASS FLAVOR-CLASS))
  T)

(DEFMETHOD EFFECTIVE-SLOT-DEFINITION-CLASS ((CLASS STANDARD-CLASS))
  (FIND-CLASS 'STANDARD-EFFECTIVE-SLOT-DEFINITION))

(DEFMETHOD DIRECT-SLOT-DEFINITION-CLASS ((CLASS STANDARD-CLASS)
					 (SLOT-SPECIFICATION T))
  (FIND-CLASS
    (IF (EQ (GETF SLOT-SPECIFICATION ':ALLOCATION) :CLASS)
	'STANDARD-DIRECT-CLASS-SLOT-DEFINITION
	'STANDARD-DIRECT-SLOT-DEFINITION)))

(DEFMETHOD ADD-DIRECT-SUBCLASS ((SUPERCLASS CLASS)(SUBCLASS CLASS))
  (PUSHNEW SUBCLASS (SLOT-VALUE SUPERCLASS 'DIRECT-SUBCLASSES)))

(DEFMETHOD REMOVE-DIRECT-SUBCLASS ((SUPERCLASS CLASS)(SUBCLASS CLASS))
  (SETF (SLOT-VALUE SUPERCLASS 'DIRECT-SUBCLASSES)
	(DELETE SUBCLASS (CLASS-DIRECT-SUBCLASSES SUPERCLASS))))

(DEFMETHOD VALIDATE-SUPERCLASS ((CLASS CLASS) (SUPERCLASS CLASS))
  (EQ (CLASS-OF CLASS) (CLASS-OF SUPERCLASS)))

(DEFMETHOD VALIDATE-SUPERCLASS ((CLASS CLASS) (SUPERCLASS (EQL (FIND-CLASS T))))
  T)

(DEFMETHOD VALIDATE-SUPERCLASS ((CLASS FUNCALLABLE-STANDARD-CLASS)
				(SUPERCLASS (EQL (FIND-CLASS 'FUNCTION))))
  T)

(DEFMETHOD VALIDATE-SUPERCLASS ((CLASS FUNCALLABLE-STANDARD-CLASS)
				(SUPERCLASS STANDARD-CLASS))
  (OR (AND (EQ (CLASS-OF CLASS) (FIND-CLASS 'FUNCALLABLE-STANDARD-CLASS))
	   (EQ (CLASS-OF SUPERCLASS) (FIND-CLASS 'STANDARD-CLASS))
	   (NULL (CLASS-SLOTS SUPERCLASS)))
      (CALL-NEXT-METHOD)))

(DEFMETHOD VALIDATE-SUPERCLASS ((CLASS STRUCTURE-CLASS)
				(SUPERCLASS STANDARD-CLASS))
  (OR (AND (EQ (CLASS-OF CLASS) (FIND-CLASS 'STRUCTURE-CLASS))
	   (EQ (CLASS-OF SUPERCLASS) (FIND-CLASS 'STANDARD-CLASS))
	   (NULL (CLASS-SLOTS SUPERCLASS)))
      (CALL-NEXT-METHOD)))

(DEFMETHOD VALIDATE-SUPERCLASS ((CLASS CLASS)
				(SUPERCLASS METHOD-ONLY-CLASS))
  T)

(DEFMETHOD VALIDATE-SUPERCLASS ((CLASS CLASS)
				(SUPERCLASS FORWARD-REFERENCED-CLASS))
  ;; Will be verified when the forward-referenced-class is really defined
  T)

(DEFMETHOD COMPUTE-PROTOTYPE ((CLASS STANDARD-CLASS))
  (LET ((INSTANCE (%ALLOCATE-INSTANCE (CLASS-INSTANCE-INFORMATION CLASS))))
    (DOLIST (SLOT (CLASS-SLOTS CLASS))
      (WHEN (EQ (SLOT-DEFINITION-ALLOCATION SLOT) ':INSTANCE)
	(LET ((SLOT-NAME (SLOT-DEFINITION-NAME SLOT)))
	  (MAKUNBOUND-SLOT
	    CLASS INSTANCE SLOT-NAME %INSTANCE-REF STANDARD-CLASS-SLOT-LOCATION))))
    INSTANCE))

(DEFMETHOD COMPUTE-PROTOTYPE ((CLASS FUNCALLABLE-STANDARD-CLASS))
  (LET ((INSTANCE (%ALLOCATE-FUNCALLABLE-INSTANCE (CLASS-INSTANCE-INFORMATION CLASS))))
    (DOLIST (SLOT (CLASS-SLOTS CLASS))
      (LET ((SLOT-NAME (SLOT-DEFINITION-NAME SLOT)))
	(MAKUNBOUND-SLOT CLASS INSTANCE SLOT-NAME %FUNCALLABLE-INSTANCE-REF
			 FUNCALLABLE-STANDARD-CLASS-SLOT-LOCATION)))
    INSTANCE))

#+Genera
(DEFMETHOD NOTE-CLASS-CHANGE-FOR-DW ((CLASS CLASS))
  NIL)

#+Genera
(DEFMETHOD NOTE-CLASS-CHANGE-FOR-DW ((CLASS STANDARD-CLASS))
  (LET ((NAME (CLASS-NAME CLASS)))
    (WHEN *INSIDE-WITH-PENDING-DW-UPDATES*
      (NOTE-CHANGE-FOR-DW NAME)
      (DW:MAYBE-CHECK-TYPE-REDEFINITION NAME 'DEFCLASS :7.2-TYPE T))))

#+Genera
(DEFMETHOD NOTE-CLASS-INITIALIZATION-FUNCTIONS ((CLASS CLASS))
  NIL)

#+Genera
(DEFMETHOD NOTE-CLASS-INITIALIZATION-FUNCTIONS ((CLASS STANDARD-CLASS))
  (LET ((NAME (CLASS-NAME CLASS)))
    (DOLIST (SLOT (CLASS-DIRECT-SLOTS CLASS))
      (WHEN (SLOT-DEFINITION-INITFUNCTION SLOT)
	(CASE (SLOT-DEFINITION-INITFORM-INLINABLE SLOT)
	  ((CONSTANT SPECIAL))
	  (OTHERWISE
	    (LET ((FSPEC `(STANDARD-CLASS-SLOT-INITFUNCTION ,NAME ,(SLOT-DEFINITION-NAME SLOT))))
	      (SI:RECORD-SOURCE-FILE-NAME FSPEC 'DEFUN T)
	      (SI:WHEN-IN-INCREMENTAL-WHO-CALLS-MODE
		(SI:WHO-CALLS-FDEFINE-HOOK FSPEC)))))))
    (DOLIST (ENTRY (CLASS-DIRECT-DEFAULT-INITARGS CLASS))
      (CASE (FOURTH ENTRY)
	((CONSTANT SPECIAL))
	(OTHERWISE
	  (LET ((FSPEC `(STANDARD-CLASS-DEFAULT-INITARG-FUNCTION ,NAME ,(FIRST ENTRY))))
	    (SI:RECORD-SOURCE-FILE-NAME FSPEC 'DEFUN T)
	    (SI:WHEN-IN-INCREMENTAL-WHO-CALLS-MODE
	      (SI:WHO-CALLS-FDEFINE-HOOK FSPEC))))))))

(DEFMETHOD ENSURE-EXISTING-INSTANCES-WILL-GET-UPDATED ((CLASS STANDARD-CLASS)
						       (OLD-INFORMATION T))
  (SETF (%INSTANCE-INFORMATION-DISPATCH-TABLE OLD-INFORMATION)
	(CLASS-OBSOLETE-DISPATCH-TABLE CLASS))
  (SETF (%CLASS-INSTANCE-INFORMATION-N-SLOTS OLD-INFORMATION) 0)
  (SETF (%CLASS-INSTANCE-INFORMATION-OBSOLETE-P OLD-INFORMATION) T))

(DEFMETHOD ENSURE-EXISTING-INSTANCES-WILL-GET-UPDATED
	   ((CLASS (EQL (FIND-CLASS 'STANDARD-CLASS)))
	    (OLD-INFORMATION T))
  (LABELS ((UPDATE-CLASS (THIS-CLASS)
	     (LET ((METACLASS (CLASS-OF THIS-CLASS)))
	       (WHEN (EQ METACLASS CLASS)
		 (UPDATE-INSTANCE-USING-CLASS METACLASS THIS-CLASS))
	       (MAP NIL #'UPDATE-CLASS (CLASS-DIRECT-SUBCLASSES THIS-CLASS)))))
    (UPDATE-CLASS (FIND-CLASS 'T))
    (CALL-NEXT-METHOD)))

(DEFMETHOD ENSURE-EXISTING-INSTANCES-WILL-GET-UPDATED
	   ((CLASS (EQL (FIND-CLASS 'FUNCALLABLE-STANDARD-CLASS)))
	    (OLD-INFORMATION T))
  (LABELS ((UPDATE-CLASS (THIS-CLASS)
	     (LET ((METACLASS (CLASS-OF THIS-CLASS)))
	       (WHEN (EQ METACLASS CLASS)
		 (UPDATE-INSTANCE-USING-CLASS METACLASS THIS-CLASS))
	       (MAP NIL #'UPDATE-CLASS (CLASS-DIRECT-SUBCLASSES THIS-CLASS)))))
    (UPDATE-CLASS (FIND-CLASS 'T))
    (CALL-NEXT-METHOD)))

(DEFMETHOD ENSURE-EXISTING-INSTANCES-WILL-GET-UPDATED
	   ((CLASS (EQL (FIND-CLASS 'BUILT-IN-CLASS)))
	    (OLD-INFORMATION T))
  (LABELS ((UPDATE-CLASS (THIS-CLASS)
	     (LET ((METACLASS (CLASS-OF THIS-CLASS)))
	       (WHEN (EQ METACLASS CLASS)
		 (UPDATE-INSTANCE-USING-CLASS METACLASS THIS-CLASS))
	       (MAP NIL #'UPDATE-CLASS (CLASS-DIRECT-SUBCLASSES THIS-CLASS)))))
    (UPDATE-CLASS (FIND-CLASS 'T))
    (CALL-NEXT-METHOD)))

(DEFMETHOD ENSURE-EXISTING-INSTANCES-WILL-GET-UPDATED
	   ((CLASS (EQL (FIND-CLASS 'STANDARD-GENERIC-FUNCTION)))
	    (OLD-INFORMATION T))
  (MAP-OVER-GENERIC-FUNCTIONS
    #'(LAMBDA (GENERIC-FUNCTION)
	(UPDATE-INSTANCE-USING-CLASS CLASS GENERIC-FUNCTION)))
  (CALL-NEXT-METHOD))

(DEFMETHOD ENSURE-EXISTING-INSTANCES-WILL-GET-UPDATED
	   ((CLASS (EQL (FIND-CLASS 'STANDARD-EFFECTIVE-SLOT-DEFINITION)))
	    (OLD-INFORMATION T))
  (LABELS ((UPDATE-CLASS (THIS-CLASS)
	     (WHEN (CLASS-FINALIZED-P THIS-CLASS)
	       (DOLIST (SLOT (CLASS-SLOTS THIS-CLASS))
		 (LET ((METACLASS (CLASS-OF SLOT)))
		   (WHEN (EQ METACLASS CLASS)
		     (UPDATE-INSTANCE-USING-CLASS METACLASS SLOT)))))
	     (MAP NIL #'UPDATE-CLASS (CLASS-DIRECT-SUBCLASSES THIS-CLASS))))
    (UPDATE-CLASS (FIND-CLASS 'T))
    (CALL-NEXT-METHOD)))

(DEFMETHOD ENSURE-EXISTING-INSTANCES-WILL-GET-UPDATED
	   ((CLASS (EQL (FIND-CLASS 'STANDARD-DIRECT-SLOT-DEFINITION)))
	    (OLD-INFORMATION T))
  (LABELS ((UPDATE-CLASS (THIS-CLASS)
	     (WHEN (CLASS-INITIALIZED-P THIS-CLASS)
	       (DOLIST (SLOT (CLASS-DIRECT-SLOTS THIS-CLASS))
		 (LET ((METACLASS (CLASS-OF SLOT)))
		   (WHEN (EQ METACLASS CLASS)
		     (UPDATE-INSTANCE-USING-CLASS METACLASS SLOT)))))
	     (MAP NIL #'UPDATE-CLASS (CLASS-DIRECT-SUBCLASSES THIS-CLASS))))
    (UPDATE-CLASS (FIND-CLASS 'T))
    (CALL-NEXT-METHOD)))

(DEFMETHOD ENSURE-EXISTING-INSTANCES-WILL-GET-UPDATED
	   ((CLASS (EQL (FIND-CLASS 'STANDARD-DIRECT-CLASS-SLOT-DEFINITION)))
	    (OLD-INFORMATION T))
  (LABELS ((UPDATE-CLASS (THIS-CLASS)
	     (WHEN (CLASS-INITIALIZED-P THIS-CLASS)
	       (DOLIST (SLOT (CLASS-DIRECT-SLOTS THIS-CLASS))
		 (LET ((METACLASS (CLASS-OF SLOT)))
		   (WHEN (EQ METACLASS CLASS)
		     (UPDATE-INSTANCE-USING-CLASS METACLASS SLOT)))))
	     (MAP NIL #'UPDATE-CLASS (CLASS-DIRECT-SUBCLASSES THIS-CLASS))))
    (UPDATE-CLASS (FIND-CLASS 'T))
    (CALL-NEXT-METHOD)))

#+Genera
(DEFMETHOD ENSURE-EXISTING-INSTANCES-WILL-GET-UPDATED
	   ((CLASS FLAVOR-CLASS)
	    (OLD-INFORMATION T))
  NIL)

(DEFUN UPDATE-GENERIC-FUNCTION-METHODS (CLASS)
  (MAP-OVER-GENERIC-FUNCTIONS
    #'(LAMBDA (GENERIC-FUNCTION)
	(DOLIST (METHOD (GENERIC-FUNCTION-METHODS GENERIC-FUNCTION))
	  (WHEN (EQ (CLASS-OF METHOD) CLASS)
	    (UPDATE-INSTANCE-USING-CLASS CLASS METHOD))))))

(DEFMETHOD ENSURE-EXISTING-INSTANCES-WILL-GET-UPDATED
	   ((CLASS (EQL (FIND-CLASS 'STANDARD-METHOD)))
	    (OLD-INFORMATION T))
  (UPDATE-GENERIC-FUNCTION-METHODS CLASS)
  (CALL-NEXT-METHOD))

(DEFMETHOD ENSURE-EXISTING-INSTANCES-WILL-GET-UPDATED
	   ((CLASS (EQL (FIND-CLASS 'STANDARD-READER-METHOD)))
	    (OLD-INFORMATION T))
  (UPDATE-GENERIC-FUNCTION-METHODS CLASS)
  (CALL-NEXT-METHOD))

(DEFMETHOD ENSURE-EXISTING-INSTANCES-WILL-GET-UPDATED
	   ((CLASS (EQL (FIND-CLASS 'STANDARD-WRITER-METHOD)))
	    (OLD-INFORMATION T))
  (UPDATE-GENERIC-FUNCTION-METHODS CLASS)
  (CALL-NEXT-METHOD))

#+(OR Genera Minima)
(DEFMETHOD ENSURE-EXISTING-INSTANCES-WILL-GET-UPDATED
	   ((CLASS (EQL (FIND-CLASS 'STANDARD-LOCATOR-METHOD)))
	    (OLD-INFORMATION T))
  (UPDATE-GENERIC-FUNCTION-METHODS CLASS)
  (CALL-NEXT-METHOD))

(DEFMETHOD FINALIZE-INHERITANCE ((CLASS STANDARD-CLASS))
  (WITH-CLOS-LOCK
    (WITH-PENDING-DW-UPDATES
      (LET* ((*FINALIZING-CLASS* CLASS)
	     (UPDATEP NIL)
	     (OLD-FINALIZED-P (CLASS-FINALIZED-P CLASS))
	     (OLD-INFORMATION (AND OLD-FINALIZED-P (CLASS-INSTANCE-INFORMATION CLASS)))
	     (INFORMATION OLD-INFORMATION)
	     (PRECEDENCE-LIST (COMPUTE-CLASS-PRECEDENCE-LIST CLASS)))
	(LET ((UNINITIALIZED-CLASSES (LOOP FOR CLASS IN (CDR PRECEDENCE-LIST)
					   UNLESS (CLASS-INITIALIZED-P CLASS) COLLECT CLASS)))
	  (WHEN UNINITIALIZED-CLASSES
	    (WITHOUT-CLOS-LOCK
	      (ERROR
		"The class ~a can not be finalized because the superclass~:[~;es~]~?~@
               ~1@*~:[has~;have~] not been defined."
		CLASS
		(CDR UNINITIALIZED-CLASSES)
		*AND-~A-FORMAT-STRING*
		UNINITIALIZED-CLASSES))))
	(WITHOUT-ABORTS ("The class ~a is being finalized.~@
                          Aborting now could leave the class in an inconsistent state."
			 CLASS)
	  #+Genera
	  (PROGN
	    (WHEN OLD-FINALIZED-P
	      ;; Tell DW that the old superclasses may have changed subtypes
	      (DOLIST (CLASS (%CLASS-INSTANCE-INFORMATION-PRECEDENCE-LIST OLD-INFORMATION))
		(WHEN (CLASS-INITIALIZED-P CLASS)
		  (NOTE-CLASS-CHANGE-FOR-DW CLASS))))
	    ;; Tell DW that the new superclasses may have changed subtypes
	    (DOLIST (CLASS PRECEDENCE-LIST)
	      (WHEN (CLASS-INITIALIZED-P CLASS)
		(NOTE-CLASS-CHANGE-FOR-DW CLASS))))
	  (UNLESS OLD-FINALIZED-P
	    (SETF INFORMATION (MAKE-CLASS-INSTANCE-INFORMATION))
	    (SETF (%CLASS-INSTANCE-INFORMATION-CLASS-NAME INFORMATION) (CLASS-NAME CLASS))
	    (SETF (%CLASS-INSTANCE-INFORMATION-CLASS INFORMATION) CLASS)
	    (SETF (SLOT-VALUE CLASS 'INSTANCE-INFORMATION) INFORMATION))
	  (UNLESS (AND OLD-FINALIZED-P
		       (EQUAL (%CLASS-INSTANCE-INFORMATION-PRECEDENCE-LIST
				OLD-INFORMATION)
			      PRECEDENCE-LIST))
	    (SETF (%CLASS-INSTANCE-INFORMATION-PRECEDENCE-LIST INFORMATION)
		  PRECEDENCE-LIST))
	  (LET ((SLOTS (COMPUTE-SLOTS CLASS))
		(OLD-SLOTS
		  (AND OLD-FINALIZED-P
		       (%CLASS-INSTANCE-INFORMATION-EFFECTIVE-SLOTS OLD-INFORMATION))))
	    ;; If the slots haven't changed, then we can continue to use the same
	    ;; instance information.
	    (UNLESS (OR (NOT OLD-FINALIZED-P)
			(BLOCK CHECK-SLOTS
			  (DOLIST (SLOT SLOTS)
			    (LET ((OLD-SLOT (FIND (SLOT-DEFINITION-NAME SLOT)
						  OLD-SLOTS
						  :KEY #'SLOT-DEFINITION-NAME)))
			      (UNLESS (AND OLD-SLOT
					   (EQL (SLOT-DEFINITION-LOCATION OLD-SLOT)
						(SLOT-DEFINITION-LOCATION SLOT)))
				(RETURN-FROM CHECK-SLOTS NIL))))
			  (DOLIST (SLOT OLD-SLOTS)
			    (LET ((NEW-SLOT (FIND (SLOT-DEFINITION-NAME SLOT) SLOTS
						  :KEY #'SLOT-DEFINITION-NAME)))
			      (UNLESS (AND NEW-SLOT
					   (EQL (SLOT-DEFINITION-LOCATION SLOT)
						(SLOT-DEFINITION-LOCATION NEW-SLOT)))
				(RETURN-FROM CHECK-SLOTS NIL))))
			  T))
	      (SETQ UPDATEP T)
	      (WHEN OLD-FINALIZED-P
		(MAKE-INSTANCES-OBSOLETE CLASS)
		(SETQ INFORMATION (CLASS-INSTANCE-INFORMATION CLASS))))
	    (SET-CLASS-INSTANCE-INFORMATION-EFFECTIVE-SLOTS CLASS INFORMATION SLOTS)
	    (LET ((SIZE (COMPUTE-SLOT-VECTOR-SIZE CLASS SLOTS)))
	      (WHEN (AND (NOT UPDATEP)
			 OLD-FINALIZED-P
			 (NOT (= (%CLASS-INSTANCE-INFORMATION-SIZE OLD-INFORMATION)
				 SIZE)))
		(MAKE-INSTANCES-OBSOLETE CLASS)
		(SETQ INFORMATION (CLASS-INSTANCE-INFORMATION CLASS))
		(SETQ UPDATEP T))
	      (SETF (%CLASS-INSTANCE-INFORMATION-SIZE INFORMATION) SIZE)))
	  (SETF (SLOT-VALUE CLASS 'DEFAULT-INITARGS) (COMPUTE-DEFAULT-INITARGS CLASS))
	  (WHEN (OR (NOT OLD-FINALIZED-P)
		    UPDATEP)
	    (SETF (SLOT-VALUE CLASS 'PROTOTYPE) (COMPUTE-PROTOTYPE CLASS)))
	  (SETF (LDB %%STANDARD-CLASS-FINALIZED-P (SLOT-VALUE CLASS 'BITS)) -1)
	  (ENSURE-CLASS-INITIALIZATION-INFORMATION CLASS)
	  (RECOMBINE-METHODS CLASS UPDATEP OLD-INFORMATION))))))

(DEFMETHOD COMPUTE-SLOT-VECTOR-SIZE ((CLASS STANDARD-CLASS) SLOTS)
  (LET ((MAX-LOCATION (1- (PROGN #+(OR Genera Minima) 1
				 #+CLOE-Runtime 0))))
    (LOOP FOR SLOT IN SLOTS
	  DOING
      (WHEN (EQ (SLOT-DEFINITION-ALLOCATION SLOT) ':INSTANCE)
	(SETF MAX-LOCATION (MAX MAX-LOCATION (SLOT-DEFINITION-LOCATION SLOT)))))
    (1+ MAX-LOCATION)))

#+Genera
(DEFMETHOD COMPUTE-SLOT-VECTOR-SIZE :AROUND ((CLASS FUNCALLABLE-STANDARD-CLASS) SLOTS)
  (DECLARE (IGNORE SLOTS))
  ;; Reorder memory insists that the selectors have odd size
  (LOGIOR (CALL-NEXT-METHOD) 1))

(DEFMETHOD RECOMBINE-METHODS ((CLASS MAPPED-CLASS-MIXIN) UPDATEP OLD-INFORMATION)
  (WITH-CLOS-LOCK 
    (LET ((OLD-MAPPING-TABLES NIL))
      (WHEN UPDATEP
	(SETF OLD-MAPPING-TABLES (CLASS-MAPPING-TABLES CLASS))
	(DOLIST (MAPPING-TABLE OLD-MAPPING-TABLES)
	  (LET ((FAMILY (MAPPING-TABLE-FAMILY MAPPING-TABLE)))
	    (SETF (MAPPING-TABLE-FAMILY-MAPPING-TABLES FAMILY)
		  (DELETE MAPPING-TABLE (MAPPING-TABLE-FAMILY-MAPPING-TABLES FAMILY)))))
	(SETF (CLASS-MAPPING-TABLES CLASS) NIL))
      (RECOMBINE-METHODS-SPECIALIZED-ON-CLASS CLASS #'STANDARD-METHOD-COMBINER)
      (WHEN UPDATEP
	(WHEN OLD-INFORMATION
	  (ENSURE-EXISTING-INSTANCES-WILL-GET-UPDATED CLASS OLD-INFORMATION))
	(MAPC #'INVALIDATE-MAPPING-TABLE OLD-MAPPING-TABLES)))))

(DEFMETHOD ENSURE-CLASS-INITIALIZATION-INFORMATION ((CLASS CLASS))
  )

(DEFMETHOD COMPUTE-DEFAULT-INITARGS ((CLASS STANDARD-CLASS))
  (LET ((RESULT NIL)
	(LENGTH 0))
    (DOLIST (CLASS (CLASS-PRECEDENCE-LIST CLASS))
      (LET ((INITARGS (CLASS-DIRECT-DEFAULT-INITARGS CLASS)))
	(PUSH INITARGS RESULT)
	(INCF LENGTH (LENGTH INITARGS))))
    (LET* ((LIST (MAKE-LIST LENGTH))
	   (PLACE LIST))
      (MAPC #'(LAMBDA (INITARGS)
		(MAPC #'(LAMBDA (INITARG)
			  (SETF (CAR PLACE) INITARG)
			  (SETF PLACE (CDR PLACE)))
		      INITARGS))
	    (NREVERSE RESULT))
      LIST)))

(DEFMETHOD CLASS-DEFAULT-DIRECT-SUPERCLASSES ((CLASS BUILT-IN-CLASS) &KEY ENVIRONMENT)
  (DECLARE (IGNORE ENVIRONMENT))
  NIL)

(DEFMETHOD CLASS-DEFAULT-DIRECT-SUPERCLASSES ((CLASS STANDARD-CLASS) &KEY ENVIRONMENT)
  (DECLARE (IGNORE ENVIRONMENT))
  '(STANDARD-OBJECT))

(DEFMETHOD CLASS-DEFAULT-DIRECT-SUPERCLASSES ((CLASS FUNCALLABLE-STANDARD-CLASS) &KEY ENVIRONMENT)
  (DECLARE (IGNORE ENVIRONMENT))
  '(FUNCALLABLE-INSTANCE))

(DEFMETHOD CLASS-DEFAULT-DIRECT-SUPERCLASSES ((CLASS STRUCTURE-CLASS) &KEY ENVIRONMENT)
  (DECLARE (IGNORE ENVIRONMENT))
  '(STRUCTURE-OBJECT))

(DEFMETHOD CLASS-DEFAULT-DIRECT-SUPERCLASSES ((CLASS METHOD-ONLY-CLASS) &KEY ENVIRONMENT)
  (DECLARE (IGNORE ENVIRONMENT))
  '(T))

(DEFMETHOD CHECK-CLASS-OPTIONS PROGN
	   ((CLASS CLOS-CLASS)
	    (SLOT-NAMES T)
	    &KEY
	    (DIRECT-SUPERCLASSES NIL DIRECT-SUPERCLASSES-P)
	    ((INITIALIZATION-TYPE INITIALIZATION-TYPE) NIL))
  (WHEN (NULL INITIALIZATION-TYPE)
    (WHEN DIRECT-SUPERCLASSES-P
      (LET ((INVALID-SUPERCLASSES
	      ;; Verify that all of the superclasses are valid
	      (REMOVE-IF #'(LAMBDA (SUPER) (VALIDATE-SUPERCLASS CLASS SUPER))
			 DIRECT-SUPERCLASSES))
	    (SUBCLASSES-CHECKED NIL)
	    (INSTANTIATED-SUBCLASSES NIL)
	    (SUPERCLASSES-CHECKED NIL)
	    (UNINITIALIZED-SUPERCLASSES NIL))
	(LABELS ((CHECK-SUBCLASSES (CLASS)
		   (WHEN (MEMBER CLASS SUBCLASSES-CHECKED)
		     (RETURN-FROM CHECK-SUBCLASSES NIL))
		   (PUSH CLASS SUBCLASSES-CHECKED)
		   (WHEN (CLASS-FINALIZED-P CLASS)
		     (PUSH CLASS INSTANTIATED-SUBCLASSES))
		   (DOLIST (CLASS (CLASS-DIRECT-SUBCLASSES CLASS))
		     (CHECK-SUBCLASSES CLASS)))
		 (CHECK-SUPERCLASSES (CLASS)
		   (WHEN (MEMBER CLASS SUPERCLASSES-CHECKED)
		     (RETURN-FROM CHECK-SUPERCLASSES NIL))
		   (PUSH CLASS SUPERCLASSES-CHECKED)
		   (UNLESS (CLASS-INITIALIZED-P CLASS)
		     (PUSH CLASS UNINITIALIZED-SUPERCLASSES))
		   (DOLIST (CLASS (CLASS-DIRECT-SUPERCLASSES CLASS))
		     (CHECK-SUPERCLASSES CLASS))))
	  (CHECK-SUBCLASSES CLASS)
	  (WHEN INSTANTIATED-SUBCLASSES
	    (DOLIST (CLASS DIRECT-SUPERCLASSES)
	      (CHECK-SUPERCLASSES CLASS))))
	(WHEN (OR UNINITIALIZED-SUPERCLASSES INVALID-SUPERCLASSES)
	  (WITHOUT-CLOS-LOCK
	    (ERROR
	      "~:[~;The class~:[~;es~]~?~1@*~@
               ~:[is an~;are~] invalid superclass~1@*~:[~;es~] for the class ~4@*~a.~]~
               ~5@*~:[~;~0@*~:[T~;~%Also, t~]~6@*he class ~a can not be redefined with the~@
               direct superclass~:[~;es~]~?~@
               because this would cause the undefined class~:[~;es~]~?~@
               to be ~:[a ~;~]~:*superclass~:[~;es~] of the instantiated class~:[~;es~]~?.~]"
	      INVALID-SUPERCLASSES
	      (CDR INVALID-SUPERCLASSES)
	      *AND-~A-FORMAT-STRING*
	      INVALID-SUPERCLASSES
	      CLASS
	      UNINITIALIZED-SUPERCLASSES
	      CLASS
	      (CDR DIRECT-SUPERCLASSES)
	      *AND-~A-FORMAT-STRING*
	      DIRECT-SUPERCLASSES
	      (CDR UNINITIALIZED-SUPERCLASSES)
	      *AND-~A-FORMAT-STRING*
	      UNINITIALIZED-SUPERCLASSES
	      (CDR UNINITIALIZED-SUPERCLASSES)
	      (CDR INSTANTIATED-SUBCLASSES)
	      *AND-~A-FORMAT-STRING*
	      INSTANTIATED-SUBCLASSES)))))))

(DEFVAR *INVALIDATE-CLIM-HANDLER-CACHES* NIL)

(DEFMETHOD SHARED-INITIALIZE :AFTER
	   ((CLASS CLOS-CLASS)
	    (SLOT-NAMES T)
	    &REST KEYS
	    &KEY
	    ((NAME NAME) NIL NAME-P)
	    ENVIRONMENT
	    (DIRECT-SUPERCLASSES NIL DIRECT-SUPERCLASSES-P)
	    (DOCUMENTATION NIL DOCUMENTATION-P)
	    ((INITIALIZATION-TYPE INITIALIZATION-TYPE) NIL))
  (DECLARE (IGNORE ENVIRONMENT))
  (DECLARE (DYNAMIC-EXTENT KEYS))
  (UNLESS (EQ INITIALIZATION-TYPE 'REDEFINED-CLASS)
    (WHEN DOCUMENTATION
      (CHECK-TYPE DOCUMENTATION STRING))
    (LET ((INITIALIZED (CLASS-INITIALIZED-P CLASS)))
      ;; Set the class name before checking the options so that the error message
      ;; will be more meaninful.
      (SETF (CLASS-NAME CLASS)
	    (IF NAME-P
		NAME
		(IF INITIALIZED
		    (CLASS-NAME CLASS)
		    NIL)))
      (WITH-CLASS-UPDATES-ENABLE-ABORTS
	(APPLY #'CHECK-CLASS-OPTIONS CLASS SLOT-NAMES KEYS))
      (SETF (DOCUMENTATION-OBJECT CLASS)
	    (IF DOCUMENTATION-P
		DOCUMENTATION
		(IF INITIALIZED
		    (DOCUMENTATION-OBJECT CLASS)
		    NIL)))
      (WHEN (OR DIRECT-SUPERCLASSES-P (NULL INITIALIZED))
	(LET ((OLD-DIRECT-SUPERCLASSES (AND INITIALIZED (CLASS-DIRECT-SUPERCLASSES CLASS))))
	  (DOLIST (OLD-SUPERCLASS OLD-DIRECT-SUPERCLASSES)
	    (UNLESS (MEMBER OLD-SUPERCLASS DIRECT-SUPERCLASSES)
	      (REMOVE-DIRECT-SUBCLASS OLD-SUPERCLASS CLASS)))
	  (DOLIST (SUPERCLASS DIRECT-SUPERCLASSES)
	    (UNLESS (MEMBER SUPERCLASS OLD-DIRECT-SUPERCLASSES)
	      (ADD-DIRECT-SUBCLASS SUPERCLASS CLASS)))
	  (SETF (SLOT-VALUE CLASS 'DIRECT-SUPERCLASSES) DIRECT-SUPERCLASSES)
	  (UNLESS (EQUAL OLD-DIRECT-SUPERCLASSES DIRECT-SUPERCLASSES)
	    (WHEN *INVALIDATE-CLIM-HANDLER-CACHES*
	      (FUNCALL *INVALIDATE-CLIM-HANDLER-CACHES* CLASS))))))))

;;; If DEFCLASS asked us how to parse, then we wouldn't need this.
(DEFMETHOD CHECK-CLASS-OPTIONS PROGN
	   ((CLASS METHOD-ONLY-CLASS)
	    (SLOT-NAMES T)
	    &KEY
	    SLOTS
	    DEFAULT-INITARGS)
  (UNLESS (AND (NULL SLOTS)
	       (NULL DEFAULT-INITARGS))
    (WITHOUT-CLOS-LOCK
      (ERROR "Method only classes cannot have slots or initargs."))))

#+Genera
(LISP:DEFSTRUCT (CLASS-SLOTS-VECTOR :NAMED-ARRAY
				    (:PRINT-FUNCTION
				      (LAMBDA (OBJECT STREAM IGNORE)
					(PRINT-UNREADABLE-OBJECT (CLASS-SLOTS-VECTOR
								   STREAM
								   :IDENTITY T)
					  (FORMAT STREAM "Class slots vector for ~s"
						  (CLASS-SLOTS-VECTOR-CLASS OBJECT)))))
				    (:COPIER NIL)
				    (:PREDICATE NIL)
				    (:CONSTRUCTOR NIL)
				    (:SIZE-SYMBOL *CLASS-SLOTS-VECTOR-OVERHEAD*))
				    
  CLASS)

#+Genera
(DEFUN MAKE-CLASS-SLOTS-VECTOR (CLASS SLOTS-NEEDED)
  (LET ((NEW-CELLS (SCL:MAKE-ARRAY (+ SLOTS-NEEDED *CLASS-SLOTS-VECTOR-OVERHEAD*)
				   :NAMED-STRUCTURE-SYMBOL 'CLASS-SLOTS-VECTOR)))
    (SETF (CLASS-SLOTS-VECTOR-CLASS NEW-CELLS) CLASS)
    (VALUES NEW-CELLS *CLASS-SLOTS-VECTOR-OVERHEAD*)))

#+Minima
(DEFSTRUCT (CLASS-SLOTS-VECTOR (:TYPE VECTOR) :NAMED
			       (:COPIER NIL) (:PREDICATE NIL) (:CONSTRUCTOR NIL))
  CLASS)

#+Minima
(DEFUN MAKE-CLASS-SLOTS-VECTOR (CLASS SLOTS-NEEDED)
  (LET ((NEW-CELLS (MAKE-ARRAY (+ SLOTS-NEEDED 2))))
    (SETF (SVREF NEW-CELLS 0) 'CLASS-SLOTS-VECTOR)
    (SETF (CLASS-SLOTS-VECTOR-CLASS NEW-CELLS) CLASS)
    (VALUES NEW-CELLS 2)))

(DEFMETHOD SHARED-INITIALIZE :AFTER
	   ((CLASS STANDARD-CLASS)
	    (SLOT-NAMES T)
	    &KEY
	    (ENVIRONMENT NIL)
	    (SLOTS NIL SLOTS-P)
	    (DEFAULT-INITARGS NIL DEFAULT-INITARGS-P))
  (UNLESS (SLOT-BOUNDP CLASS 'BITS)
    ;; Obsolete class prototypes can have BITS unbound, which will cause problems
    ;; when optimizing the world tries to update the instance.
    (RETURN-FROM SHARED-INITIALIZE NIL))
  (LET ((INITIALIZED (CLASS-INITIALIZED-P CLASS)))
    (WHEN (OR DEFAULT-INITARGS-P (AND (NOT INITIALIZED) SLOTS-P))
      (SETF (SLOT-VALUE CLASS 'DIRECT-DEFAULT-INITARGS) DEFAULT-INITARGS))
    (LET ((OLD-DIRECT-SLOTS (AND INITIALIZED (SLOT-VALUE CLASS 'DIRECT-SLOTS)))
	  (NEED-TO-UPDATE-MAPPING-TABLES NIL))
      (WHEN SLOTS-P
	(LET ((NEW-DIRECT-SLOTS
		(MAPCAR #'(LAMBDA (SLOT)
			    (APPLY #'MAKE-INSTANCE
				   (DIRECT-SLOT-DEFINITION-CLASS CLASS SLOT)
				   SLOT))
			SLOTS)))
	  (UNLESS (COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
	    #+(OR Genera Minima)
	    (LET ((OLD-CELLS (CLASS-SHARED-SLOTS CLASS))
		  (SLOTS-NEEDED (COUNT :CLASS NEW-DIRECT-SLOTS
				       :KEY #'SLOT-DEFINITION-ALLOCATION)))
	      (COND ((AND (= SLOTS-NEEDED 0) OLD-CELLS)
		     ;; We've got to leave the cells around, in case some of the slots
		     ;; have become instance slots (update instance will need to get the
		     ;; old value).  Unhook the array so that we can enventually reclaim
		     ;; the storage.
		     (SETQ NEED-TO-UPDATE-MAPPING-TABLES T)
		     (SETF (SLOT-VALUE CLASS 'SHARED-SLOTS) NIL))
		    ((AND (> SLOTS-NEEDED 0)
			  OLD-CELLS
			  (= SLOTS-NEEDED (- (LENGTH OLD-CELLS) 1))
			  (EVERY #'(LAMBDA (NEW-SLOT)
				     (OR (NOT (EQ (SLOT-DEFINITION-ALLOCATION NEW-SLOT)
						  ':CLASS))
					 (LET ((OLD-SLOT
						 (FIND (SLOT-DEFINITION-NAME NEW-SLOT)
						       OLD-DIRECT-SLOTS
						       :KEY #'SLOT-DEFINITION-NAME)))
					   (AND OLD-SLOT
						(EQ (SLOT-DEFINITION-ALLOCATION OLD-SLOT)
						    ':CLASS)))))
				 NEW-DIRECT-SLOTS))
		     ;; Just copy the locations into the new slot definition.
		     (DOLIST (NEW-SLOT NEW-DIRECT-SLOTS)
		       (LET ((OLD-SLOT (FIND (SLOT-DEFINITION-NAME NEW-SLOT) OLD-DIRECT-SLOTS
					     :KEY #'SLOT-DEFINITION-NAME)))
			 (SETF (SLOT-VALUE NEW-SLOT 'LOCATION)
			       (SLOT-DEFINITION-LOCATION OLD-SLOT))))
		     (SETQ NEED-TO-UPDATE-MAPPING-TABLES T))
		    ((> SLOTS-NEEDED 0)
		     (MULTIPLE-VALUE-BIND (NEW-CELLS INDEX)
			 (MAKE-CLASS-SLOTS-VECTOR CLASS SLOTS-NEEDED)
		       (DOLIST (OLD-SLOT OLD-DIRECT-SLOTS)
			 (WHEN (EQ (SLOT-DEFINITION-ALLOCATION OLD-SLOT) ':CLASS)
			   (LET* ((NAME (SLOT-DEFINITION-NAME OLD-SLOT))
				  (OLD-LOCATION (SLOT-DEFINITION-LOCATION OLD-SLOT))
				  (NEW-SLOT (FIND NAME NEW-DIRECT-SLOTS
						  :KEY #'SLOT-DEFINITION-NAME)))
			     (WHEN (AND NEW-SLOT
					(EQ (SLOT-DEFINITION-ALLOCATION NEW-SLOT) ':CLASS))
			       ;; Forward the old cell to the new cell.  Just leave the
			       ;; other cells as they are, because they hold the initial
			       ;; values for some of the new slots.
			       (LET ((NEW-LOCATION (LOCF (AREF NEW-CELLS INDEX))))
				 (INCF INDEX)
				 #+Genera
				 (PROGN
				   (SI:%P-COPY-Q OLD-LOCATION NEW-LOCATION)
				   (SYS:%P-STORE-TAG-AND-POINTER
				     OLD-LOCATION SYS:DTP-ONE-Q-FORWARD NEW-LOCATION))
				 #+Minima
				 (PROGN
				   (IVORY:%P-STORE-CONTENTS
				     NEW-LOCATION
				     (IVORY:%MEMORY-READ
				       OLD-LOCATION
				       :CYCLE-TYPE 'IVORY::SCAVENGE
				       :SET-CDR-NEXT NIL))
				   (IVORY:%P-STORE-CONTENTS
				     OLD-LOCATION
				     (IVORY:%SET-TAG NEW-LOCATION
						     (IVORY:DATA-TYPE 'IVORY::ONE-Q-FORWARD))))
				 #-(OR Genera Minima) (NYI)
				 (SETF (SLOT-VALUE NEW-SLOT 'LOCATION) NEW-LOCATION))))))
		       (DOLIST (NEW-SLOT NEW-DIRECT-SLOTS)
			 (WHEN (EQ (SLOT-DEFINITION-ALLOCATION NEW-SLOT) ':CLASS)
			   (UNLESS (SLOT-DEFINITION-LOCATION NEW-SLOT)
			     (LET ((LOCATION (LOCF (AREF NEW-CELLS INDEX)))
				   (INITFUNCTION (SLOT-DEFINITION-INITFUNCTION NEW-SLOT)))
			       (INCF INDEX)
			       #+(OR Genera Minima)
			       (IF INITFUNCTION
				   (SETF (LOCATION-CONTENTS LOCATION)
					 (FUNCALL INITFUNCTION))
				   (LOCATION-MAKUNBOUND
				     LOCATION (SLOT-DEFINITION-NAME NEW-SLOT)))
			       #-(OR Genera Minima)
			       (SETF (CAR LOCATION)
				     (IF INITFUNCTION
					 (FUNCALL INITFUNCTION)
					 *UNBOUND-INSTANCE-SLOT*))
			       (SETF (SLOT-VALUE NEW-SLOT 'LOCATION) LOCATION)))))
		       (SETF NEED-TO-UPDATE-MAPPING-TABLES T)
		       (SETF (SLOT-VALUE CLASS 'SHARED-SLOTS) NEW-CELLS)))))
	    #-(OR Genera Minima)
	    (LET ((SLOTS-NEEDED (COUNT :CLASS NEW-DIRECT-SLOTS
				       :KEY #'SLOT-DEFINITION-ALLOCATION)))
	      (DOLIST (OLD-SLOT OLD-DIRECT-SLOTS)
		(WHEN (EQ (SLOT-DEFINITION-ALLOCATION OLD-SLOT) ':CLASS)
		  (LET* ((NAME (SLOT-DEFINITION-NAME OLD-SLOT))
			 (OLD-LOCATION (SLOT-DEFINITION-LOCATION OLD-SLOT))
			 (NEW-SLOT (FIND NAME NEW-DIRECT-SLOTS :KEY #'SLOT-DEFINITION-NAME)))
		    (COND ((AND NEW-SLOT (EQ (SLOT-DEFINITION-ALLOCATION NEW-SLOT) ':CLASS))
			   (SETF (SLOT-VALUE NEW-SLOT 'LOCATION) NEW-LOCATION))
			  (T (SETQ NEED-TO-UPDATE-MAPPING-TABLES T))))))
	      (DOLIST (NEW-SLOT NEW-DIRECT-SLOTS)
		(WHEN (EQ (SLOT-DEFINITION-ALLOCATION NEW-SLOT) ':CLASS)
		  (UNLESS (SLOT-DEFINITION-LOCATION NEW-SLOT)
		    (SETF (SLOT-VALUE NEW-SLOT 'LOCATION)
			  (LET ((INITFUNCTION (SLOT-DEFINITION-INITFUNCTION NEW-SLOT)))
			    ;;@@@@ This cons gets included as a quoted constant in automatically
			    ;; generated constructor functions.  Consequently, it might get copied
			    ;; thus losing the sharing...  So we cons it in a static space in CLOE.
			    ;; Your implementation may differ...
			    #+CLOE-Runtime
			    (SYSTEM::CONS-IN-AREA
			      (IF INITFUNCTION
				  (FUNCALL INITFUNCTION)
				  *UNBOUND-INSTANCE-SLOT*)
			      NIL
			      SYSTEM::AKIND$K-STATIC)
			    #-CLOE-Runtime
			    (CONS (IF INITFUNCTION
				      (FUNCALL INITFUNCTION)
				      *UNBOUND-INSTANCE-SLOT*)
				  CLASS)))
		    (SETQ NEED-TO-UPDATE-MAPPING-TABLES T))))))
	  (SETF (SLOT-VALUE CLASS 'DIRECT-SLOTS) NEW-DIRECT-SLOTS)))
      (WITH-CLOS-LOCK
	(WHEN SLOTS-P
	  (COMPUTE-SLOT-METHODS CLASS ENVIRONMENT)
	  (DOLIST (SLOT OLD-DIRECT-SLOTS)
	    (DOLIST (METHOD (SLOT-DEFINITION-METHODS SLOT))
	      (LET ((GENERIC-FUNCTION (METHOD-GENERIC-FUNCTION METHOD)))
		(WHEN GENERIC-FUNCTION
		  ;; Avoid the debugger if someone removed this method without telling
		  ;; us.
		  (LET ((*INHIBIT-DISPATCH-CACHE-UPDATING* T))
		    ;; These will get updated when the class is finalized.
		    (REMOVE-METHOD GENERIC-FUNCTION METHOD))
		  (SETF NEED-TO-UPDATE-MAPPING-TABLES T)))))
	  (DOLIST (SLOT (SLOT-VALUE CLASS 'DIRECT-SLOTS))
	    (WHEN (SLOT-DEFINITION-METHODS SLOT)
	      (SETF NEED-TO-UPDATE-MAPPING-TABLES T)))
	  (WHEN NEED-TO-UPDATE-MAPPING-TABLES
	    (MAPC #'UPDATE-MAPPING-TABLE (CLASS-MAPPING-TABLES CLASS))))
	(WHEN (OR INITIALIZED SLOTS-P)
	  (WITH-PENDING-DW-UPDATES
	    (LET ((CLASSES-FINALIZED NIL))
	      (LABELS ((FINALIZE-CLASS (CLASS)
			 (WHEN (MEMBER CLASS CLASSES-FINALIZED)
			   (RETURN-FROM FINALIZE-CLASS NIL))
			 (PUSH CLASS CLASSES-FINALIZED)
			 (DOLIST (CLASS (CLASS-DIRECT-SUBCLASSES CLASS))
			   (FINALIZE-CLASS CLASS))
			 (WHEN (CLASS-FINALIZED-P CLASS)
			   (FINALIZE-INHERITANCE CLASS))))
		(FINALIZE-CLASS CLASS)))))))
    (WHEN SLOTS-P
      (SETF (LDB %%STANDARD-CLASS-INITIALIZED-P (SLOT-VALUE CLASS 'BITS)) -1))))

(DEFMETHOD COMPUTE-CLASS-PRECEDENCE-LIST ((CLASS CLASS))
  (COMPUTE-CLOS-CLASS-PRECEDENCE-LIST CLASS))

;;; FLAVOR:GET-ALL-FLAVOR-COMPONENTS is not always accurate, but if Flavors
;;; doesn't bother to do this accurately, why should we?
#+Genera
(DEFMETHOD COMPUTE-CLASS-PRECEDENCE-LIST ((CLASS FLAVOR-CLASS))
  (NCONC (MAPCAR #'FIND-CLASS (FLAVOR:GET-ALL-FLAVOR-COMPONENTS (CLASS-NAME CLASS)))
	 (LIST (FIND-CLASS 'T))))


(DEFMETHOD DEFAULT-INITARGS ((CLASS STANDARD-CLASS) INITARGS)
  ;; Want to follow INITARGS by those default initargs which are not already
  ;; mentioned in INITARGS.  Want to keep the order the same.
  (LET ((RESULT NIL)
	(KEYS NIL)
	(UNIQUE (LIST NIL)))
    (MAPC #'(LAMBDA (DEFUALT-INITARG)
	      (LET ((KEY (POP DEFUALT-INITARG)))
		(WHEN (AND (NOT (MEMBER KEY KEYS))
			   (EQ (GETF INITARGS KEY UNIQUE) UNIQUE))
		  (LET ((VALUE (FUNCALL (SECOND DEFUALT-INITARG))))
		    (PUSH KEY RESULT)
		    (PUSH VALUE RESULT)
		    (PUSH KEY KEYS)))))
	  (CLASS-DEFAULT-INITARGS CLASS))
    (APPEND INITARGS (NREVERSE RESULT))))

(DEFMETHOD ALLOCATE-INSTANCE ((CLASS STANDARD-CLASS)
			      &KEY
			      #+(OR Genera Minima CLOE-Runtime)
			      ((STORAGE-AREA AREA)
			       (PROGN #+Genera SYS:*DEFAULT-CONS-AREA*
				      #+Minima T
				      #+CLOE-Runtime SYS::AKIND$K-DEFAULT)))
  (%ALLOCATE-INSTANCE-COPY (CLASS-PROTOTYPE CLASS) #+(OR Genera Minima CLOE-Runtime) AREA))

(DEFMETHOD ALLOCATE-SLOT-VECTOR ((CLASS STANDARD-CLASS) #+Genera AREA)
  (%ALLOCATE-INSTANCE-COPY (CLASS-PROTOTYPE CLASS) #+Genera AREA))

(DEFMETHOD ALLOCATE-INSTANCE ((CLASS FUNCALLABLE-STANDARD-CLASS)
			      &KEY
			      #+(OR Genera CLOE-Runtime Minima)
			      ((STORAGE-AREA AREA)
			       (PROGN #+Genera SYS:*DEFAULT-CONS-AREA*
				      #+Minima T
				      #+CLOE-Runtime SYS::AKIND$K-DEFAULT)))
  (%ALLOCATE-FUNCALLABLE-INSTANCE-COPY (CLASS-PROTOTYPE CLASS) #+(OR Genera Minima CLOE-Runtime) AREA))

(DEFMETHOD COPY-INSTANCE-USING-CLASS ((CLASS STANDARD-CLASS) INSTANCE)
  (%ALLOCATE-INSTANCE-COPY INSTANCE))

(DEFMETHOD COPY-INSTANCE-USING-CLASS ((CLASS FUNCALLABLE-STANDARD-CLASS) INSTANCE)
  (%ALLOCATE-FUNCALLABLE-INSTANCE-COPY INSTANCE))

#+Genera
(DEFMETHOD ALLOCATE-SLOT-VECTOR ((CLASS FUNCALLABLE-STANDARD-CLASS) #+Genera AREA)
  (LET ((OLD-SLOTS (%DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT
		     (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT (CLASS-PROTOTYPE CLASS)))))
    (%ALLOCATE-INSTANCE-COPY OLD-SLOTS #+Genera AREA)))

(DEFMETHOD INITIALIZE-INSTANCE ((INSTANCE STANDARD-OBJECT) &REST INITARGS)
  (DECLARE (DYNAMIC-EXTENT INITARGS))
  (APPLY #'SHARED-INITIALIZE INSTANCE T INITARGS))

(DEFUN SLOW-MAKE-INSTANCE (CLASS &REST INITARGS)
  (DECLARE (DYNAMIC-EXTENT INITARGS))
  (WHEN (SYMBOLP CLASS)
    (SETF CLASS (FIND-CLASS CLASS)))
  (UNLESS (CLASS-FINALIZED-P CLASS)
    (FINALIZE-INHERITANCE CLASS))
  (LET ((INITARGS (DEFAULT-INITARGS CLASS INITARGS)))
    (WHEN (AND INITARGS
	       (NOT (LDB-TEST %%STANDARD-CLASS-MAKE-INSTANCE-ALLOW-OTHER-KEYS-P
			      (CLASS-BITS CLASS))))
      (VALIDATE-KEYWORDS-INTERNAL (CLASS-MAKE-INSTANCE-KEYWORDS CLASS) INITARGS))
    (LET ((INSTANCE (APPLY #'ALLOCATE-INSTANCE CLASS INITARGS)))
      (APPLY #'INITIALIZE-INSTANCE INSTANCE INITARGS)
      INSTANCE)))

(INITIALIZE-CLOS-5)
