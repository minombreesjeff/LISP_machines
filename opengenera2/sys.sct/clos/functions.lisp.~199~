;;; -*- Mode: LISP; Syntax: ANSI-Common-Lisp; Base: 10; Package: CLOS-INTERNALS -*-
;;;>
;;;> *****************************************************************************************
;;;> ** (c) Copyright 1998-1982 Symbolics, Inc.  All rights reserved.
;;;> ** Portions of font library Copyright (c) 1984 Bitstream, Inc.  All Rights Reserved.
;;;>
;;;>    The software, data, and information contained herein are proprietary to,
;;;> and comprise valuable trade secrets of, Symbolics, Inc., which intends 
;;;> to keep such software, data, and information confidential and to preserve them
;;;> as trade secrets.  They are given in confidence by Symbolics pursuant 
;;;> to a written license agreement, and may be used, copied, transmitted, and stored
;;;> only in accordance with the terms of such license.
;;;> 
;;;> Symbolics, Symbolics 3600, Symbolics 3675, Symbolics 3630, Symbolics 3640,
;;;> Symbolics 3645, Symbolics 3650, Symbolics 3653, Symbolics 3620, Symbolics 3610,
;;;> Zetalisp, Open Genera, Virtual Lisp Machine, VLM, Wheels, Dynamic Windows,
;;;> SmartStore, Semanticue, Frame-Up, Firewall, Document Examiner,
;;;> Delivery Document Examiner, "Your Next Step in Computing", Ivory, MacIvory,
;;;> MacIvory model 1, MacIvory model 2, MacIvory model 3, XL400, XL1200, XL1201,
;;;> Symbolics UX400S, Symbolics UX1200S, NXP1000, Symbolics C, Symbolics Pascal,
;;;> Symbolics Prolog, Symbolics Fortran, CLOE, CLOE Application Generator,
;;;> CLOE Developer, CLOE Runtime, Common Lisp Developer, Symbolics Concordia,
;;;> Joshua, Statice, and Minima are trademarks of Symbolics, Inc.
;;;> 
;;;> Symbolics 3670, Symbolics Common Lisp, Symbolics-Lisp, and Genera are registered
;;;> trademarks of Symbolics, Inc.
;;;>
;;;> GOVERNMENT PURPOSE RIGHTS LEGEND
;;;> 
;;;>      Contract No.: various
;;;>      Contractor Name: Symbolics, Inc.
;;;>      Contractor Address: c/o Ropes & Gray
;;;> 			 One International Place
;;;> 			 Boston, Massachusetts 02110-2624
;;;>      Expiration Date: 2/27/2018
;;;>      
;;;> The Government's rights to use, modify, reproduce, release, perform, display or
;;;> disclose this software are restricted by paragraph (b)(2) of the "Rights in
;;;> Noncommercial Computer Software and Noncommercial Computer Software Documentation"
;;;> contained in the above identified contracts.  No restrictions apply after the
;;;> expiration date shown above.  Any reproduction of the software or portions thereof
;;;> marked with this legend must also reproduce the markings.  Questions regarding
;;;> the Government's rights may be referred to the AS&T Contracts Office of the
;;;> National Reconnaissance Office, Chantilly, Virginia 20151-1715.
;;;> 
;;;>      Symbolics, Inc.
;;;>      c/o Ropes & Gray
;;;>      One International Place
;;;>      Boston, Massachusetts 02110-2624
;;;>      781-937-7655
;;;>
;;;> *****************************************************************************************
;;;>

(IN-PACKAGE :CLOS-INTERNALS)

#+Minima
(DEFUN COMPILE-FILE-ENVIRONMENT-P (ENVIRONMENT)
  (DECLARE (IGNORE ENVIRONMENT))
  NIL)

(DEFUN FIND-CLASS (CLASS-NAME &OPTIONAL (ERRORP T) ENVIRONMENT)
  (OR (FIND-CLASS-INTERNAL CLASS-NAME ENVIRONMENT NIL)
      (AND ERRORP
	   (ERROR "The class ~s is undefined" CLASS-NAME))))

(DEFUN (SETF FIND-CLASS) (CLASS CLASS-NAME &OPTIONAL ERRORP ENVIRONMENT)
  (DECLARE (IGNORE ERRORP))
  (SETF (FIND-CLASS-INTERNAL CLASS-NAME ENVIRONMENT NIL) CLASS))

(DEFUN FIND-CLASS-OR-FORWARD-REFERENCE (CLASS-NAME ENVIRONMENT INHERITP)
  (OR (FIND-CLASS-INTERNAL CLASS-NAME ENVIRONMENT INHERITP)
      (ENSURE-CLASS-USING-CLASS
	NIL CLASS-NAME
	:METACLASS 'FORWARD-REFERENCED-CLASS
	:ENVIRONMENT ENVIRONMENT
	:DIRECT-SUPERCLASSES NIL)))

;;; Genera version is in LISPFN.
#-Genera
(DEFUN GENERIC-FUNCTION-P (THING)
  #+Genera (SYS:FUNCALLABLE-INSTANCE-P THING)
  #-Genera (FUNCALLABLE-INSTANCE-P THING))

(DEFUN REDEFINING-FUNCTION-AS-GENERIC-ERROR (FUNCTION-NAME ENVIRONMENT)
  (LET* ((OLD-DEFINITION (FDEFINITION-IN-ENVIRONMENT FUNCTION-NAME ENVIRONMENT NIL))
	 (TYPE (COND #+Genera((SYS:GENERIC-FUNCTION-P OLD-DEFINITION)
			      "Flavors generic function")
		     (T "function"))))
    (COND ((COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
	   (WARN
	     "~s was previously defined as a ~a, but is now being used as a generic ~
            function.  The previous definition will be shadowed as a CLOS generic function in ~
            the compilation environment."
	     FUNCTION-NAME TYPE))
	  (T
	   (WHEN *CLOS-INITIALIZED-P*
	     (CERROR
	       "Remove the previous definition."
	       "~s was previously defined as a ~a, but is now being used as a CLOS generic ~
                function."
	       FUNCTION-NAME TYPE))
	   (FMAKUNBOUND FUNCTION-NAME)))))

(DEFUN LAMBDA-LISTS-NOT-CONGRUENT-ERROR
       (FUNCTION-NAME GENERIC-LAMBDA-LIST LAMBDA-LIST ENVIRONMENT)
  #+(OR Genera CLOE-Runtime) (DECLARE (DBG:ERROR-REPORTER))
  (COND ((COMPILE-FILE-ENVIRONMENT-P ENVIRONMENT)
	 (WARN
	   "~s was previously defined as a generic function with the lambda list ~s, which is ~
            not congruent with the lambda list ~s.  The previous definition will be shadowed ~
            as a generic function with the lambda list ~s in the compilation environment."
	   FUNCTION-NAME
	   GENERIC-LAMBDA-LIST
	   LAMBDA-LIST
	   (COMPUTE-GENERIC-FUNCTION-LAMBDA-LIST LAMBDA-LIST)))
	(T
	 (CERROR
	   "Remove the previous generic function definition."
	   "~s was previously defined as a generic function with the lambda list ~s, which is ~
            not congruent with the lambda list ~s."
	   FUNCTION-NAME
	   GENERIC-LAMBDA-LIST
	   LAMBDA-LIST)
	 (FMAKUNBOUND FUNCTION-NAME))))

;;; Call this when you want to make or redefine a generic function.
(DEFUN ENSURE-GENERIC-FUNCTION
       (FUNCTION-NAME
	&REST KEYS
	&KEY
	ENVIRONMENT
	&ALLOW-OTHER-KEYS)
  (DECLARE (DYNAMIC-EXTENT KEYS))
  (WHEN (FBOUNDP-IN-ENVIRONMENT FUNCTION-NAME ENVIRONMENT)
    (LET ((DEFINITION (FDEFINITION-IN-ENVIRONMENT FUNCTION-NAME ENVIRONMENT NIL)))
      (WHEN (GENERIC-FUNCTION-P DEFINITION)
	(RETURN-FROM ENSURE-GENERIC-FUNCTION
	  (APPLY #'ENSURE-GENERIC-FUNCTION-USING-CLASS DEFINITION FUNCTION-NAME KEYS)))
      (REDEFINING-FUNCTION-AS-GENERIC-ERROR FUNCTION-NAME ENVIRONMENT)))
  (APPLY #'ENSURE-GENERIC-FUNCTION-USING-CLASS NIL FUNCTION-NAME KEYS))

(DEFUN ENSURE-CLASS (NAME &REST KEYS &KEY ENVIRONMENT &ALLOW-OTHER-KEYS)
  (DECLARE (DYNAMIC-EXTENT KEYS))
  (APPLY #'ENSURE-CLASS-USING-CLASS (FIND-CLASS NAME NIL ENVIRONMENT) NAME KEYS))

(DEFUN DEFGENERIC-INTERNAL (FUNCTION-NAME LAMBDA-LIST &REST REST &KEY
			    (GENERIC-FUNCTION-CLASS 'STANDARD-GENERIC-FUNCTION)
			    (METHOD-CLASS 'STANDARD-METHOD)
			    (METHOD-COMBINATION '(STANDARD))
			    &ALLOW-OTHER-KEYS)
  (DECLARE (DYNAMIC-EXTENT REST))
  (APPLY #'ENSURE-GENERIC-FUNCTION FUNCTION-NAME :LAMBDA-LIST LAMBDA-LIST
	 :GENERIC-FUNCTION-CLASS GENERIC-FUNCTION-CLASS
	 :METHOD-CLASS METHOD-CLASS
	 :METHOD-COMBINATION METHOD-COMBINATION
	 REST))

(DEFUN DEFMETHOD-INTERNAL
       (FUNCTION-NAME LAMBDA-LIST SPECIALIZERS QUALIFIERS FUNCTION DOCUMENTATION
	OTHER-STUFF)
  (LET* ((GENERIC-FUNCTION (ENSURE-GENERIC-FUNCTION FUNCTION-NAME))
	 (METHOD (APPLY
		   #'MAKE-INSTANCE
		   (GENERIC-FUNCTION-METHOD-CLASS GENERIC-FUNCTION)
		   :SPECIALIZERS SPECIALIZERS
		   :QUALIFIERS QUALIFIERS
		   :LAMBDA-LIST LAMBDA-LIST
		   :FUNCTION FUNCTION
		   :DOCUMENTATION DOCUMENTATION
		   OTHER-STUFF)))
    (ADD-METHOD GENERIC-FUNCTION METHOD)
    METHOD))

(DEFVAR *METHOD-COMBINATION-DEFINITIONS* NIL)

(DEFUN FIND-METHOD-COMBINATION-DEFINITION (NAME &OPTIONAL (ERRORP T))
  (OR (FIND NAME *METHOD-COMBINATION-DEFINITIONS*
	    :KEY #'METHOD-COMBINATION-DEFINITION-NAME)
      (IF ERRORP
	  (ERROR "~s is not the name of a defined method combination" NAME)
	  NIL)))

(DEFUN DEFINE-METHOD-COMBINATION-INTERNAL (CLASS &REST KEYS &KEY NAME &ALLOW-OTHER-KEYS)
  (DECLARE (DYNAMIC-EXTENT KEYS))
  (WHEN (PROGN
	  #+Genera
	  (SYS:RECORD-DEFINITION-SOURCE-FILE NAME 'DEFINE-METHOD-COMBINATION
					     :START-TYPE-DEFINITION NIL)
	  #-Genera
	  T)
    (LET* ((NEW (APPLY #'MAKE-INSTANCE CLASS KEYS))
	   (OLD (FIND-METHOD-COMBINATION-DEFINITION
		  (METHOD-COMBINATION-DEFINITION-NAME NEW)
		  NIL)))
      (SETQ *METHOD-COMBINATION-DEFINITIONS*
	    (CONS NEW
		  (IF OLD
		      (DELETE OLD *METHOD-COMBINATION-DEFINITIONS*)
		      *METHOD-COMBINATION-DEFINITIONS*)))
      (WHEN OLD (NOTE-METHOD-COMBINATION-CHANGE OLD NEW))
      NEW)))

(DEFUN NOTE-METHOD-COMBINATION-CHANGE (OLD-METHOD-COMBINATION NEW-METHOD-COMBINATION)
  (MAP-OVER-GENERIC-FUNCTIONS
    #'(LAMBDA (GENERIC-FUNCTION)
	(LET ((METHOD-COMBINATION (GENERIC-FUNCTION-METHOD-COMBINATION GENERIC-FUNCTION)))
	  (WHEN (EQ (METHOD-COMBINATION-TYPE METHOD-COMBINATION) OLD-METHOD-COMBINATION)
	    ;; This one changed
	    (SETF (SLOT-VALUE METHOD-COMBINATION 'TYPE) NEW-METHOD-COMBINATION)
	    (UPDATE-DISPATCHES GENERIC-FUNCTION #'STANDARD-METHOD-COMBINER T))))))

(DEFUN COMPUTE-CLOS-CLASS-PRECEDENCE-LIST (CLASS)
  (LET* ((CLASS-ENTRY (LIST* CLASS 0 NIL))
	 (ENTRY-LIST (LIST CLASS-ENTRY))
	 (CANDIDATES (LIST NIL (LIST CLASS-ENTRY)))
	 (RESULT NIL))
    (MACROLET ((ENTRY-SUPERCLASSES (ENTRY) `(CDDR ,ENTRY))
	       (ENTRY-COUNT (ENTRY) `(SECOND ,ENTRY))
	       (ENTRY-CLASS (ENTRY) `(FIRST ,ENTRY)))
      (LABELS ((SETUP-ENTRY-LIST (CLASS)
		 (LET ((ENTRY (ASSOC CLASS ENTRY-LIST)))
		   (COND (ENTRY (INCF (ENTRY-COUNT ENTRY)))
			 (T
			  (PUSH (SETQ ENTRY (LIST* CLASS 1 NIL)) ENTRY-LIST)
			  (SETF (ENTRY-SUPERCLASSES ENTRY)
				(MAPCAR #'SETUP-ENTRY-LIST
					(CLASS-DIRECT-SUPERCLASSES CLASS)))))
		   ENTRY)))
	(SETF (ENTRY-SUPERCLASSES CLASS-ENTRY)
	      (MAPCAR #'SETUP-ENTRY-LIST (CLASS-DIRECT-SUPERCLASSES CLASS)))
	(LOOP
	  (UNLESS (CDR CANDIDATES) (RETURN))
	  (BLOCK DO-CANDIDATE
	    (LET ((LAST-PLACE CANDIDATES)
		  (PLACE (CDR CANDIDATES)))
	      (LOOP
		(WHEN (NULL PLACE)
		  (ERROR "Class precedence list can not be computed"))
		(LET ((CANDIDATE (CAAR PLACE)))
		  (WHEN (AND CANDIDATE (= (ENTRY-COUNT CANDIDATE) 0))
		    (PUSH (ENTRY-CLASS CANDIDATE) RESULT)
		    (LET ((CANDIDATE-CDR (CDAR PLACE)))
		      (IF (NULL CANDIDATE-CDR)
			  (SETF (CDR LAST-PLACE) (CDR PLACE)
				PLACE LAST-PLACE)
			  (PROGN (SETF (CAR PLACE) CANDIDATE-CDR)
				 (DECF (ENTRY-COUNT (CAR CANDIDATE-CDR))))))
		    (LET ((SUPERS (ENTRY-SUPERCLASSES CANDIDATE)))
		      (WHEN SUPERS
			(DECF (ENTRY-COUNT (CAR SUPERS)))
			(PUSH SUPERS (CDR CANDIDATES))))
		    (LET ((LAST-REMAINING-PLACE PLACE)
			  (REMAINING-PLACE (CDR PLACE)))
		      (LOOP
			(WHEN (NULL REMAINING-PLACE) (RETURN))
			(LET ((REMAINING-CANDIDATES (CAR REMAINING-PLACE)))
			  (WHEN (EQ (CAR REMAINING-CANDIDATES) CANDIDATE)
			    (LET ((REST (CDR REMAINING-CANDIDATES)))
			      (IF REST
				  (PROGN (SETF (CAR REMAINING-PLACE) REST)
					 (DECF (ENTRY-COUNT (CAR REST))))
				  (SETF (CDR LAST-REMAINING-PLACE) (CDR REMAINING-PLACE)
					REMAINING-PLACE LAST-REMAINING-PLACE))))
			  (SETQ LAST-REMAINING-PLACE REMAINING-PLACE)
			  (SETQ REMAINING-PLACE (CDR REMAINING-PLACE)))))
		    (RETURN-FROM DO-CANDIDATE))
		  (SETQ LAST-PLACE PLACE)
		  (SETQ PLACE (CDR PLACE)))))))
	(NREVERSE RESULT)))))

(DEFMACRO SLOT-THING ((OBJECT SLOT-NAME LOCATION) FAST-FORM SLOW-FORM)
  `(BLOCK SLOT-THING
     #+Genera
     (WHEN (INSTANCEP ,OBJECT)
       (LET ((INFORMATION (%INSTANCE-INSTANCE-INFORMATION ,OBJECT)))
	 (DECLARE (SYS:ARRAY-REGISTER INFORMATION))
	 (WHEN (CLASS-INSTANCE-INFORMATION-P INFORMATION)
	   (LET ((N-SLOTS (%CLASS-INSTANCE-INFORMATION-N-SLOTS INFORMATION)))
	     (WHEN (PLUSP N-SLOTS)
	       (LET* ((TABLE-LOC
			(LOCF
			  (AREF (%CLASS-INSTANCE-INFORMATION-SLOT-NAME-TABLE INFORMATION) 0)))
		      (PTR (SYS:%BLOCK-SEARCH-EQ ,SLOT-NAME TABLE-LOC N-SLOTS)))
		 (WHEN PTR
		   (RETURN-FROM SLOT-THING
		     (LET ((,LOCATION (LOCATION-CONTENTS (SYS:%POINTER-PLUS PTR N-SLOTS))))
		       ,FAST-FORM)))))))))
     #+Minima
     (WHEN (INSTANCEP ,OBJECT)
       (LET ((INFORMATION (%INSTANCE-INSTANCE-INFORMATION ,OBJECT)))
	 (WHEN (CLASS-INSTANCE-INFORMATION-P INFORMATION)
	   (LET ((N-SLOTS (%CLASS-INSTANCE-INFORMATION-N-SLOTS INFORMATION)))
	     (WHEN (PLUSP N-SLOTS)
	       (LET* ((TABLE-LOC
			(LOCF
			  (AREF (%CLASS-INSTANCE-INFORMATION-SLOT-NAME-TABLE INFORMATION) 0)))
		      (PTR (MINIMA-INTERNALS::%BLOCK-SEARCH-EQ ,SLOT-NAME TABLE-LOC N-SLOTS)))
		 (WHEN PTR
		   (RETURN-FROM SLOT-THING
		     (LET ((,LOCATION (LOCATION-CONTENTS (IVORY:%POINTER-PLUS PTR N-SLOTS))))
		       ,FAST-FORM)))))))))
     #-(OR Genera Minima)
     ,@(AND FAST-FORM
	    `((WHEN (INSTANCEP OBJECT)
		(LET ((INFORMATION (%INSTANCE-INSTANCE-INFORMATION ,OBJECT)))
		  (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (SPACE 0)))
		  (WHEN (CLASS-INSTANCE-INFORMATION-P INFORMATION)
		    (LET ((N-SLOTS (%CLASS-INSTANCE-INFORMATION-N-SLOTS INFORMATION)))
		      (DECLARE (FIXNUM N-SLOTS))
		      (WHEN (> N-SLOTS 0)
			(LET ((TABLE (%CLASS-INSTANCE-INFORMATION-SLOT-NAME-TABLE INFORMATION)))
			  (DECLARE (SIMPLE-VECTOR TABLE))
			  (LET ((POSITION (POSITION (THE SYMBOL ,SLOT-NAME) TABLE :END N-SLOTS)))
			    (WHEN POSITION
			      (LOCALLY (DECLARE (FIXNUM POSITION))
				(RETURN-FROM SLOT-THING
				  (LET ((,LOCATION (SVREF TABLE (THE FIXNUM (+ N-SLOTS POSITION)))))
				    ,FAST-FORM)))))))))))))
     ,SLOW-FORM))

(DEFUN SLOT-VALUE (OBJECT SLOT-NAME)
  (SLOT-THING (OBJECT SLOT-NAME LOCATION)
	      (PROGN
		#-|3600| (%INSTANCE-REF OBJECT LOCATION)
		;; %INSTANCE-REF does not compile into an instruction on 3600 when the
		;; second argument is not a constant
		#+|3600| (LOCATION-CONTENTS (SYS:%P-STRUCTURE-OFFSET OBJECT LOCATION)))
	      (SLOT-VALUE-USING-CLASS (CLASS-OF OBJECT) OBJECT SLOT-NAME)))

(DEFUN (SETF SLOT-VALUE) (NEW-VALUE OBJECT SLOT-NAME)
  #+CLOE-Runtime					;Exists primarily for #'(SETF SLOT-VALUE).
  (SET-SLOT-VALUE OBJECT SLOT-NAME NEW-VALUE)
  #-CLOE-Runtime
  (SLOT-THING (OBJECT SLOT-NAME LOCATION)
	      (PROGN
		#-|3600| (SETF (%INSTANCE-REF OBJECT LOCATION) NEW-VALUE)
		;; %INSTANCE-SET does not compile into an instruction on 3600 when the
		;; third argument is not a constant
		#+|3600| (SETF (LOCATION-CONTENTS (SYS:%P-STRUCTURE-OFFSET OBJECT LOCATION))
			     NEW-VALUE))
	      (SETF (SLOT-VALUE-USING-CLASS (CLASS-OF OBJECT) OBJECT SLOT-NAME) NEW-VALUE)))

#+CLOE-Runtime
(DEFUN SET-SLOT-VALUE (OBJECT SLOT-NAME NEW-VALUE)
  (SLOT-THING (OBJECT SLOT-NAME LOCATION)
	      (SETF (%INSTANCE-REF OBJECT LOCATION) NEW-VALUE)
	      (SETF (SLOT-VALUE-USING-CLASS (CLASS-OF OBJECT) OBJECT SLOT-NAME) NEW-VALUE)))

#+CLOE-Runtime
(DEFSETF SLOT-VALUE SET-SLOT-VALUE)

#+(OR Genera Minima)
(DEFUN (LOCF SLOT-VALUE) (OBJECT SLOT-NAME)
  (SLOT-THING (OBJECT SLOT-NAME LOCATION)
	      (PROGN
		#-|3600| (LOCF (%INSTANCE-REF OBJECT LOCATION))
		;; %INSTANCE-LOC does not compile into an instruction on 3600 when the
		;; second argument is not a constant
		#+|3600| (SYS:%P-STRUCTURE-OFFSET OBJECT LOCATION))
	      (LOCF (SLOT-VALUE-USING-CLASS (CLASS-OF OBJECT) OBJECT SLOT-NAME))))

(DEFUN SLOT-BOUNDP (OBJECT SLOT-NAME)
  (SLOT-THING (OBJECT SLOT-NAME LOCATION)
	      (PROGN
		#+(OR IMACH Minima) (LOCATION-BOUNDP (LOCF (%INSTANCE-REF OBJECT LOCATION)))
		;; %INSTANCE-LOC does not compile into an instruction on 3600 when the
		;; second argument is not a constant
		#+|3600| (LOCATION-BOUNDP (SYS:%P-STRUCTURE-OFFSET OBJECT LOCATION))
		#-(OR IMACH |3600| Minima) (%INSTANCE-SLOT-BOUNDP OBJECT LOCATION))
	      (SLOT-BOUNDP-USING-CLASS (CLASS-OF OBJECT) OBJECT SLOT-NAME)))

(DEFUN SLOT-MAKUNBOUND (OBJECT SLOT-NAME)
  (SLOT-THING (OBJECT SLOT-NAME LOCATION)
	      (PROGN
		#+(OR IMACH Minima) (LOCATION-MAKUNBOUND (LOCF (%INSTANCE-REF OBJECT LOCATION))
							 SLOT-NAME)
		;; %INSTANCE-LOC does not compile into an instruction on 3600 when the
		;; second argument is not a constant
		#+|3600| (LOCATION-MAKUNBOUND (SYS:%P-STRUCTURE-OFFSET OBJECT LOCATION)
						SLOT-NAME)
		#-(OR IMACH |3600| MINIMA) (PROGN (SETF (%INSTANCE-REF OBJECT LOCATION)
							*UNBOUND-INSTANCE-SLOT*)
						  NIL))
	      (SLOT-MAKUNBOUND-USING-CLASS (CLASS-OF OBJECT) OBJECT SLOT-NAME)))

(DEFUN SLOT-EXISTS-P (OBJECT SLOT-NAME)
  (SLOT-THING (OBJECT SLOT-NAME LOCATION)
	      (PROGN LOCATION T)
	      (SLOT-EXISTS-P-USING-CLASS (CLASS-OF OBJECT) OBJECT SLOT-NAME)))

;;; Slot accessing method functions

#+(OR IMACH CLOE-Runtime Minima)
(DEFUN CONSTANT-NIL (EXTRA-ARGUMENT INSTANCE)
  (DECLARE (IGNORE EXTRA-ARGUMENT INSTANCE))
  NIL)

#+|3600|
(DEFUN CONSTANT-NIL (INSTANCE EXTRA-ARGUMENT .GENERIC.)
  (DECLARE (IGNORE EXTRA-ARGUMENT INSTANCE .GENERIC.))
  NIL)

#+(OR IMACH CLOE-Runtime Minima)
(DEFUN CONSTANT-VALUE (EXTRA-ARGUMENT INSTANCE)
  (DECLARE (IGNORE INSTANCE))
  EXTRA-ARGUMENT)

#+|3600|
(DEFUN CONSTANT-VALUE (INSTANCE EXTRA-ARGUMENT .GENERIC.)
  (DECLARE (IGNORE INSTANCE .GENERIC.))
  EXTRA-ARGUMENT)

#+IMACH
(SCL:DEFF STANDARD-CLASS-LOCAL-SLOT-READER #'FLAVOR:READ-INSTANCE-VARIABLE)

#+(OR CLOE-Runtime Minima)
(DEFUN STANDARD-CLASS-LOCAL-SLOT-READER (EXTRA-ARGUMENT INSTANCE)
  (%INSTANCE-REF INSTANCE EXTRA-ARGUMENT))

#+|3600|
(DEFUN STANDARD-CLASS-LOCAL-SLOT-READER (INSTANCE EXTRA-ARGUMENT .GENERIC.)
  (DECLARE (IGNORE .GENERIC.))
  ;(%INSTANCE-REF INSTANCE EXTRA-ARGUMENT) does not compile into an instruction on 3600
  (LOCATION-CONTENTS (SYS:%P-STRUCTURE-OFFSET INSTANCE EXTRA-ARGUMENT)))

#+(OR CLOE-Runtime Minima)
(DEFUN STANDARD-CLASS-LOCAL-SLOT-WRITER (EXTRA-ARGUMENT NEW-VALUE INSTANCE)
  (SETF (%INSTANCE-REF INSTANCE EXTRA-ARGUMENT) NEW-VALUE))

#+|3600|
(DEFUN STANDARD-CLASS-LOCAL-SLOT-WRITER (NEW-VALUE EXTRA-ARGUMENT .GENERIC. INSTANCE)
  (DECLARE (IGNORE .GENERIC.))
  ;(SETF (%INSTANCE-REF INSTANCE EXTRA-ARGUMENT) NEW-VALUE) is slow on the 3600
  (SETF (LOCATION-CONTENTS (SYS:%P-STRUCTURE-OFFSET INSTANCE EXTRA-ARGUMENT)) NEW-VALUE))

#+IMACH
(SCL:DEFF STANDARD-CLASS-LOCAL-SLOT-LOCATOR #'FLAVOR:LOCATE-INSTANCE-VARIABLE)

#+Minima
(DEFUN STANDARD-CLASS-LOCAL-SLOT-LOCATOR (EXTRA-ARGUMENT INSTANCE)
  (LOCF (%INSTANCE-REF INSTANCE EXTRA-ARGUMENT)))

#+|3600|
(DEFUN STANDARD-CLASS-LOCAL-SLOT-LOCATOR (INSTANCE EXTRA-ARGUMENT .GENERIC.)
  (DECLARE (IGNORE .GENERIC.))
  ;(LOCF (%INSTANCE-REF INSTANCE EXTRA-ARGUMENT))) is slow on the 3600
  (SYS:%P-STRUCTURE-OFFSET INSTANCE EXTRA-ARGUMENT))

#+(OR IMACH Minima)
(DEFUN STANDARD-CLASS-SHARED-SLOT-READER (EXTRA-ARGUMENT INSTANCE)
  (DECLARE (IGNORE INSTANCE))
  (LOCATION-CONTENTS EXTRA-ARGUMENT))

#+|3600|
(DEFUN STANDARD-CLASS-SHARED-SLOT-READER (INSTANCE EXTRA-ARGUMENT .GENERIC.)
  (DECLARE (IGNORE INSTANCE .GENERIC.))
  (LOCATION-CONTENTS EXTRA-ARGUMENT))

#+CLOE-Runtime
(DEFUN STANDARD-CLASS-SHARED-SLOT-READER (EXTRA-ARGUMENT INSTANCE)
  (DECLARE (IGNORE INSTANCE))
  (CAR EXTRA-ARGUMENT))

#+(OR IMACH Minima)
(DEFUN STANDARD-CLASS-SHARED-SLOT-WRITER (EXTRA-ARGUMENT NEW-VALUE INSTANCE)
  (DECLARE (IGNORE INSTANCE))
  (SETF (LOCATION-CONTENTS EXTRA-ARGUMENT) NEW-VALUE))

#+|3600|
(DEFUN STANDARD-CLASS-SHARED-SLOT-WRITER (NEW-VALUE EXTRA-ARGUMENT .GENERIC. INSTANCE)
  (DECLARE (IGNORE INSTANCE .GENERIC.))
  (SETF (LOCATION-CONTENTS EXTRA-ARGUMENT) NEW-VALUE))

#+CLOE-Runtime
(DEFUN STANDARD-CLASS-SHARED-SLOT-WRITER (EXTRA-ARGUMENT NEW-VALUE INSTANCE)
  (DECLARE (IGNORE INSTANCE))
  (SETF (CAR EXTRA-ARGUMENT) NEW-VALUE))

#+(OR IMACH Minima)
(DEFUN STANDARD-CLASS-SHARED-SLOT-LOCATOR (EXTRA-ARGUMENT INSTANCE)
  (DECLARE (IGNORE INSTANCE))
  EXTRA-ARGUMENT)

#+|3600|
(DEFUN STANDARD-CLASS-SHARED-SLOT-LOCATOR (INSTANCE EXTRA-ARGUMENT .GENERIC.)
  (DECLARE (IGNORE INSTANCE .GENERIC.))
  EXTRA-ARGUMENT)

#+(OR IMACH CLOE-Runtime Minima)
(DEFUN FUNCALLABLE-STANDARD-CLASS-SLOT-READER (EXTRA-ARGUMENT INSTANCE)
  (%FUNCALLABLE-INSTANCE-REF INSTANCE EXTRA-ARGUMENT))

#+|3600|
(DEFUN FUNCALLABLE-STANDARD-CLASS-SLOT-READER (INSTANCE EXTRA-ARGUMENT .GENERIC.)
  (DECLARE (IGNORE .GENERIC.))
  (%FUNCALLABLE-INSTANCE-REF INSTANCE EXTRA-ARGUMENT))

#+(OR IMACH CLOE-Runtime Minima)
(DEFUN FUNCALLABLE-STANDARD-CLASS-SLOT-WRITER (EXTRA-ARGUMENT NEW-VALUE INSTANCE)
  (SETF (%FUNCALLABLE-INSTANCE-REF INSTANCE EXTRA-ARGUMENT) NEW-VALUE))

#+|3600|
(DEFUN FUNCALLABLE-STANDARD-CLASS-SLOT-WRITER (NEW-VALUE EXTRA-ARGUMENT .GENERIC. INSTANCE)
  (DECLARE (IGNORE .GENERIC.))
  (SETF (%FUNCALLABLE-INSTANCE-REF INSTANCE EXTRA-ARGUMENT) NEW-VALUE))

#+(OR IMACH Minima)
(DEFUN FUNCALLABLE-STANDARD-CLASS-SLOT-LOCATOR (EXTRA-ARGUMENT INSTANCE)
  (LOCF (%FUNCALLABLE-INSTANCE-REF INSTANCE EXTRA-ARGUMENT)))

#+|3600|
(DEFUN FUNCALLABLE-STANDARD-CLASS-SLOT-LOCATOR (INSTANCE EXTRA-ARGUMENT .GENERIC.)
  (DECLARE (IGNORE .GENERIC.))
  (LOCF (%FUNCALLABLE-INSTANCE-REF INSTANCE EXTRA-ARGUMENT)))

;;; Shared slots are the same as for STANDARD-CLASS.

#-|3600|
(DEFUN CALL-NEXT-METHOD-INVALID (METHOD &REST ARGUMENTS)
  #+(OR Genera CLOE-Runtime) (DECLARE (DBG:ERROR-REPORTER))
  (DECLARE (IGNORE METHOD ARGUMENTS))
  (ERROR "CALL-NEXT-METHOD is invalid"))

#+|3600|
(DEFUN CALL-NEXT-METHOD-INVALID (ARGUMENT-0 METHOD MORE-ARGUMENTS)
  #+Genera (DECLARE (DBG:ERROR-REPORTER))
  (DECLARE (IGNORE ARGUMENT-0 METHOD MORE-ARGUMENTS))
  (ERROR "CALL-NEXT-METHOD is invalid"))

#-|3600|
(DEFUN CALL-NEXT-METHOD-NO-NEXT-METHOD (METHOD &REST ARGUMENTS)
  (DECLARE (DYNAMIC-EXTENT ARGUMENTS))
  #+(or Genera CLOE-Runtime) (DECLARE (DBG:ERROR-REPORTER))
  (APPLY #'NO-NEXT-METHOD (METHOD-GENERIC-FUNCTION METHOD) METHOD ARGUMENTS))

#+|3600|
(DEFUN CALL-NEXT-METHOD-NO-NEXT-METHOD (ARGUMENT-0 METHOD MORE-ARGUMENTS)
  #+(or Genera CLOE-Runtime) (DECLARE (DBG:ERROR-REPORTER))
  (APPLY #'NO-NEXT-METHOD (METHOD-GENERIC-FUNCTION METHOD) METHOD ARGUMENT-0 MORE-ARGUMENTS))

(DEFUN INVALID-METHOD-ERROR (METHOD FORMAT-STRING &REST ARGS)
  (DECLARE (DYNAMIC-EXTENT ARGS))
  (DECLARE (IGNORE METHOD))
  #+(or Genera CLOE-Runtime) (DECLARE (DBG:ERROR-REPORTER))
  (SIGNALLING-METHOD-COMBINATION-ERROR ()
    (APPLY #'ERROR FORMAT-STRING ARGS)))

(DEFUN QUALIFIERS-MATCH-P (METHOD-QUALFIERS PATTERN)
  (LOOP
    (WHEN (OR (AND (NULL PATTERN)
		   (NULL METHOD-QUALFIERS))
	      (EQ PATTERN '*))
      (RETURN-FROM QUALIFIERS-MATCH-P T))
    (LET ((METHOD-ELT (POP METHOD-QUALFIERS))
	  (PATTERN-ELT (POP PATTERN)))
      (UNLESS (OR (EQ PATTERN-ELT '*)
		  (EQL PATTERN-ELT METHOD-ELT))
	(RETURN-FROM QUALIFIERS-MATCH-P NIL)))))

(DEFUN SUB-SPECIALIZER-P (SPECIALIZER1 SPECIALIZER2)
  (IF (TYPEP SPECIALIZER1 'LIST)
      (IF (TYPEP SPECIALIZER2 'LIST)
	  (EQL (SECOND SPECIALIZER1) (SECOND SPECIALIZER2))
	  (MEMBER (CLASS-OF (SECOND SPECIALIZER1))
		  (CLASS-PRECEDENCE-LIST SPECIALIZER2)))
      (AND (NOT (TYPEP SPECIALIZER2 'LIST))
	   (MEMBER SPECIALIZER1 (CLASS-PRECEDENCE-LIST SPECIALIZER2)))))

#+Genera
(DEFUN SPECIALIZER-NAME-TO-SPECIALIZER (SN)
  ;; class-name ==> class
  ;; (eql 'foo) ==> (eql foo)
  ;; (eql constant) ==> (eql constant)
  ;; ==> NIL if it can't cope
  (MULTIPLE-VALUE-BIND (EQL? THING)
      (EQL-METHOD-SPECIALIZER-P SN)
    (IF EQL?
	(IF (CONSTANTP THING)
	    (VALUES (SCL:IGNORE-ERRORS `(EQL ,(EVAL THING))))
	    NIL)
	(IF (SYMBOLP SN)
	    (FIND-CLASS SN NIL)
	    NIL))))

(DEFUN NO-METHOD-QUALIFIERS-MATCH-ERROR (PATTERNS)
  #+(OR Genera CLOE-Runtime) (DECLARE (DBG:ERROR-REPORTER))
  (SIGNALLING-METHOD-COMBINATION-ERROR ()
    (METHOD-COMBINATION-ERROR
      "No methods matched the patterns:~?."
      *AND-~S-FORMAT-STRING*
      PATTERNS)))

(DEFUN METHOD-COMBINATION-ERROR (FORMAT-STRING &REST ARGUMENTS)
  (DECLARE (DYNAMIC-EXTENT ARGUMENTS))
  #+(OR Genera CLOE-Runtime) (DECLARE (DBG:ERROR-REPORTER))
  (SIGNALLING-METHOD-COMBINATION-ERROR ()
    (APPLY #'ERROR "Method combination: ~@?" FORMAT-STRING ARGUMENTS)))


(DEFUN CLASS-OF (OBJECT)
  (LET ((INFORMATION (%INSTANCE-INFORMATION-INLINE OBJECT)))
    (COND ((CLASS-INSTANCE-INFORMATION-P INFORMATION)
	   (%CLASS-INSTANCE-INFORMATION-CLASS INFORMATION))
	  #+Genera
	  ((EQ 'FLAVOR:FLAVOR (AREF INFORMATION 0))
	   (VALUES (FIND-CLASS-INTERNAL (FLAVOR:FLAVOR-NAME INFORMATION) NIL NIL)))
	  (T (FIND-CLASS T)))))

;;; Set in METACLASSES.
(DEFVAR *T-CLASS* NIL)

(DEFUN TYPEP-CLASS (OBJECT CLASS)
  (TAGBODY
    RETRY
       (LET ((INFORMATION (%INSTANCE-INFORMATION-INLINE OBJECT)))
	 #+Genera (DECLARE (SYS:ARRAY-REGISTER INFORMATION))
	 (RETURN-FROM TYPEP-CLASS
	   (AND
	     (MEMBER 
	       (COND #+Genera
		     ((EQ (AREF INFORMATION 0) 'FLAVOR:FLAVOR)
		      (COMPILER:%ERROR-WHEN (EQ (FLAVOR:FLAVOR-HANDLER-TABLE INFORMATION)
						FLAVOR::*INSTANCE-TRANSFORMING-HANDLER-TABLE*)
			(FLAVOR:TRANSFORM-INSTANCE
			  OBJECT
			  (FLAVOR:FIND-FLAVOR (FLAVOR:FLAVOR-NAME INFORMATION)))
			(GO RETRY))
		      ;; Check for classes which don't appear in the Flavor's list.
		      (WHEN (EQ CLASS *T-CLASS*)
			(RETURN-FROM TYPEP-CLASS T))
		      (CLASS-NAME CLASS))
		     (T
		      (#+Genera COMPILER:%ERROR-WHEN
		       #-Genera WHEN
			(%CLASS-INSTANCE-INFORMATION-OBSOLETE-P INFORMATION)
			(UPDATE-INSTANCE-USING-CLASS (CLASS-OF OBJECT) OBJECT)
			(GO RETRY))
		      CLASS))
	       (%CLASS-INSTANCE-INFORMATION-PRECEDENCE-LIST INFORMATION))
	     T)))))

(DEFUN STANDARD-CALL-NO-APPLICABLE-METHOD (GENERIC-FUNCTION &REST ARGUMENTS)
  (DECLARE (DYNAMIC-EXTENT ARGUMENTS))
  #+(or Genera CLOE-Runtime) (DECLARE (DBG:ERROR-REPORTER))
  (IF (EQ GENERIC-FUNCTION *NO-APPLICABLE-METHOD*)
      (ERROR "No applicable method for NO-APPLICABLE-METHOD.")
      (APPLY #'NO-APPLICABLE-METHOD GENERIC-FUNCTION ARGUMENTS)))

#+|3600|
(DEFUN STANDARD-3600-CALL-NO-APPLICABLE-METHOD
       (ARGUMENT-0 GENERIC-FUNCTION .GENERIC. &REST MORE-ARGUMENTS)
  (DECLARE (DYNAMIC-EXTENT MORE-ARGUMENTS))
  #+(or Genera CLOE-Runtime) (DECLARE (DBG:ERROR-REPORTER))
  (DECLARE (IGNORE .GENERIC.))
  (IF (EQ GENERIC-FUNCTION *NO-APPLICABLE-METHOD*)
      (ERROR "No applicable method for NO-APPLICABLE-METHOD.")
      (APPLY #'NO-APPLICABLE-METHOD GENERIC-FUNCTION ARGUMENT-0 MORE-ARGUMENTS)))

;;; Compute a compiled combined method from an effective method form.  A function name
;;; and an extra argument are returned.  This wraps the form in any bindings specified
;;; by the :ARGUMENTS option to DEFINE-METHOD-COMBINATION, converts any CALL-METHOD
;;; subforms of the form into actual calls using GENERIC-FUNCTION-CALL-FORM, adds
;;; checking for valid keywords if the generic function takes keyword arguments,
;;; and computes the appropriate extra-argument.
;;;
;;; GENERIC-FUNCTION is the associated generic function.
;;;
;;; ARGUMENT-FUNCTION is a function of two arguments, a type and an argument number
;;; (N) which must be greater than or equal to 0 and less then the number
;;; of required arguments for the generic function.  The type is one of:
;;;
;;;    CLASS -- Return the most specific class for the Nth argument.  The class T is
;;;    returned if the argument is not specialized.
;;;
;;;    EQL -- If a value EQL to the Nth argument is known, returns T and something EQL
;;;    to the Nth argument.  Otherwise returns NIL and NIL.
;;;
;;;    SPECIALIZER -- Returns a specializer for the Nth argument, i.e. either a class
;;;    object or a list of the form (EQL value).
;;;
;;; FORM is an effective method.
;;;
;;; CHECK-KEYWORDS-P tells whether or not keywords should be checked.
;;;
;;; KEYWORDS is the list of allowable keywords, or T is any keywords are allowable.
;;;
;;; REQUIRED-ARGUMENT-THRESHOLD is the value where rest arguments are used instead of
;;; explicitly enumerating the arguments.
;;;
;;; USE-EXTRA-ARGUMENT controls whether the extra argument should be passed to the
;;; combined method (in which case the compiled code will be shared) or should be
;;; inlined (in which case each combined method gets its own code).
;;;
;;; INTERNAL is T when the FORM is internal to a combined method, as would be the
;;; case for the code generated from a MAKE-METHOD form.
;;;
;;; This assumes that each "section" (required, optional, rest, or keyword) of the
;;; method-combination lambda-list (from the :ARGUMENTS option to DEFINE-METHOD-COMBINATION)
;;; is matched up independently with the corresponding section of the generic function
;;; argument list.  In particular, if (:ARGUMENTS a b c) meets DEFGENERIC (x y &optional z),
;;; the value of c will be NIL, not the value of Z.
(DEFUN GENERATE-COMBINED-METHOD
       (GENERIC-FUNCTION ARGUMENT-FUNCTION FORM CHECK-KEYWORDS-P KEYWORDS
	&REST MY-KEYS
	&KEY
	(REQUIRED-ARGUMENT-THRESHOLD 5)
	(USE-EXTRA-ARGUMENT T)
	(INTERNAL NIL))
  #+Genera (DECLARE (VALUES FUNCTION-NAME EXTRA-ARGUMENT))
  (DECLARE (DYNAMIC-EXTENT MY-KEYS))
  (DECLARE (NOTINLINE MAKE-INSTANCE))
  (MULTIPLE-VALUE-BIND (GENERIC-N-REQUIRED-ARGUMENTS GENERIC-N-OPTIONAL-ARGUMENTS
			GENERIC-REST-P GENERIC-KEYWORDS-P GENERIC-KEYWORDS
			GENERIC-ALLOW-OTHER-KEYS-P)
      (LAMBDA-LIST-COMPONENTS (GENERIC-FUNCTION-LAMBDA-LIST GENERIC-FUNCTION))
    (DECLARE (IGNORE GENERIC-KEYWORDS GENERIC-ALLOW-OTHER-KEYS-P))
    (LET* ((METHOD-COMBINATION-LAMBDA-LIST
	     (METHOD-COMBINATION-ARGUMENTS-LAMBDA-LIST
	       (GENERIC-FUNCTION-METHOD-COMBINATION GENERIC-FUNCTION)))
	   (SYMBOL-GENERATOR (MAKE-SYMBOL-GENERATOR "AN-ARG-"))
	   (BINDINGS NIL)
	   (GENERIC-N-REQUIRED-ARGUMENTS-REMAINING GENERIC-N-REQUIRED-ARGUMENTS)
	   (GENERIC-N-OPTIONAL-ARGUMENTS-REMAINING GENERIC-N-OPTIONAL-ARGUMENTS)
	   (EXTRA-ARGUMENT (FUNCALL SYMBOL-GENERATOR))
	   (EXTRA-ARGUMENT-VALUES NIL)
	   (CALL-METHOD-EXPANSION NIL)
	   (CALL-METHOD-FUNCTION NIL)
	   (CALL-METHOD-EXTRA-ARGUMENT NIL)
	   (SPECIALIZERS
	     (LOOP FOR I FROM 0 BELOW GENERIC-N-REQUIRED-ARGUMENTS
		   COLLECT
		     (MULTIPLE-VALUE-BIND (EQLP VALUE)
			 (FUNCALL ARGUMENT-FUNCTION 'EQL I)
		       (IF EQLP
			   `(EQL ,VALUE)
			   (FUNCALL ARGUMENT-FUNCTION 'CLASS I))))))
      (MULTIPLE-VALUE-BIND (METHOD-COMBINATION-N-REQUIRED-ARGUMENTS
			    METHOD-COMBINATION-N-OPTIONAL-ARGUMENTS
			    METHOD-COMBINATION-REST-P METHOD-COMBINATION-KEYWORDS-P
			    METHOD-COMBINATION-KEYWORDS
			    METHOD-COMBINATION-ALLOW-OTHER-KEYS-P
			    METHOD-COMBINATION-WHOLE-P
			    METHOD-COMBINATION-WHOLE)
	  (LAMBDA-LIST-COMPONENTS METHOD-COMBINATION-LAMBDA-LIST)
	(DECLARE (IGNORE METHOD-COMBINATION-KEYWORDS-P
			 METHOD-COMBINATION-ALLOW-OTHER-KEYS-P))

	;; Compute the lambda-list of the combined-method
	(MULTIPLE-VALUE-BIND (REQUIRED-ARGUMENTS REST-ARGUMENT REST-POSITION
			      REST-TEMP REST-TEMP-POSITION)
	    (LET* ((GENERIC-SIMPLE-P
		     ;; No rest argument needed
		     (AND (ZEROP GENERIC-N-OPTIONAL-ARGUMENTS)
			  (NOT GENERIC-REST-P)
			  (NOT GENERIC-KEYWORDS-P)))
		   (METHOD-COMBINATION-SIMPLE-P
		     ;; No rest argument needed
		     (AND (ZEROP METHOD-COMBINATION-N-OPTIONAL-ARGUMENTS)
			  (NOT METHOD-COMBINATION-REST-P)
			  ;; We don't care if the method combination lambda list has an
			  ;; &KEY in it with no mentioned keywords, since we aren't
			  ;; going to check anyways.  All we care about is if we
			  ;; actually need to look at the keywords.
			  (NOT METHOD-COMBINATION-KEYWORDS)))
		   (N-REQUIRED-ARGUMENTS
		     ;; This is the number of required arguments which will actually
		     ;; appear in the lambda list.
		     (IF (AND GENERIC-SIMPLE-P
			      (<= GENERIC-N-REQUIRED-ARGUMENTS REQUIRED-ARGUMENT-THRESHOLD))
			 ;; Not very many required arguments and no rest arguments,
			 ;; just takes them all.
			 GENERIC-N-REQUIRED-ARGUMENTS
			 ;; Only take as many required arguments as are needed for the
			 ;; method combination arguments.
			 (PROGN
			   #-|3600|
			   (MIN GENERIC-N-REQUIRED-ARGUMENTS
				METHOD-COMBINATION-N-REQUIRED-ARGUMENTS)
			   #+|3600|
			   (IF (= GENERIC-N-REQUIRED-ARGUMENTS 0)
			       0
			       ;; Need at least one required argument, to serve as
			       ;; the "SELF" argument during dispatching.
			       (MAX 1 (MIN GENERIC-N-REQUIRED-ARGUMENTS
					   METHOD-COMBINATION-N-REQUIRED-ARGUMENTS))))))
		   (REST-P (OR (NOT GENERIC-SIMPLE-P)
			       (NOT (= N-REQUIRED-ARGUMENTS GENERIC-N-REQUIRED-ARGUMENTS)))))
	      (VALUES
		(LOOP WITH LIST = (MAKE-LIST N-REQUIRED-ARGUMENTS)
		      FOR PLACE ON LIST
		      DOING
		  (SETF (CAR PLACE) (FUNCALL SYMBOL-GENERATOR))
		      FINALLY
			(RETURN LIST))
		(WHEN REST-P
		  (FUNCALL SYMBOL-GENERATOR))
		(- (+ GENERIC-N-REQUIRED-ARGUMENTS GENERIC-N-OPTIONAL-ARGUMENTS)
		   N-REQUIRED-ARGUMENTS)
		(UNLESS (OR GENERIC-SIMPLE-P METHOD-COMBINATION-SIMPLE-P)
		  (FUNCALL SYMBOL-GENERATOR))
		(- GENERIC-N-REQUIRED-ARGUMENTS N-REQUIRED-ARGUMENTS)))

	  ;; Do a whole pile of processing for DEFINE-METHOD-COMBINATION :ARGUMENTS
	  ;; Match the method combination's required arguments to the generic
	  ;; function's required arguments.  When there is no corresponding argument
	  ;; in the generic function, use NIL.
	  (WHEN METHOD-COMBINATION-WHOLE-P
	    (SETQ METHOD-COMBINATION-LAMBDA-LIST
		  (CDDR METHOD-COMBINATION-LAMBDA-LIST)))
	  (LOOP FOR I BELOW METHOD-COMBINATION-N-REQUIRED-ARGUMENTS
		FOR VARIABLE = (POP METHOD-COMBINATION-LAMBDA-LIST)
		DOING
	    (PUSH `(,VARIABLE
		    ,(COND ((PLUSP GENERIC-N-REQUIRED-ARGUMENTS-REMAINING)
			    ;; Generic and method combination arguments still match.
			    ;; Just use the generic function's argument.
			    (DECF GENERIC-N-REQUIRED-ARGUMENTS-REMAINING)
			    (NTH I REQUIRED-ARGUMENTS))
			   (T
			    ;; No generic function argument to correspond with the
			    ;; method combination argument, so default the method
			    ;; combination argument to NIL.
			    'NIL)))
		  BINDINGS))
	  ;; REST-TEMP will be used to compute the method combination optionals,
	  ;; rest, and keyword arguments.  Position past any remaining required
	  ;; arguments.
	  (WHEN REST-TEMP
	    (PUSH `(,REST-TEMP (NTHCDR ,REST-TEMP-POSITION ,REST-ARGUMENT))
		  BINDINGS))
	  (WHEN METHOD-COMBINATION-WHOLE-P
	    (PUSH `(,METHOD-COMBINATION-WHOLE
		    (LIST* ,@REQUIRED-ARGUMENTS ,REST-ARGUMENT)) BINDINGS))
	  (WHEN (EQ (CAR METHOD-COMBINATION-LAMBDA-LIST) '&OPTIONAL)
	    ;; Get rid of &OPTIONAL
	    (POP METHOD-COMBINATION-LAMBDA-LIST)
	    (LOOP REPEAT METHOD-COMBINATION-N-OPTIONAL-ARGUMENTS
		  FOR SPEC = (POP METHOD-COMBINATION-LAMBDA-LIST)
		  DOING
	      (IF (SYMBOLP SPEC)
		  (PUSH `(,SPEC
			  ,(IF (ZEROP GENERIC-N-OPTIONAL-ARGUMENTS-REMAINING)
			       ;; Nothing matches, use NIL
			       'NIL
			       ;; Check the arguments passed
			       `(POP ,REST-TEMP)))
			BINDINGS)
		  (LET ((VARIABLE (FIRST SPEC))
			(DEFAULT (SECOND SPEC))
			(SUPPLIED-P (THIRD SPEC)))
		    (COND ((ZEROP GENERIC-N-OPTIONAL-ARGUMENTS-REMAINING)
			   ;; Ran out of optional arguments to the generic function,
			   ;; so default the variable.
			   (PUSH `(,VARIABLE ,DEFAULT) BINDINGS)
			   (WHEN SUPPLIED-P
			     (PUSH `(,SUPPLIED-P NIL) BINDINGS)))
			  (SUPPLIED-P
			   (PUSH `((,VARIABLE ,SUPPLIED-P) (IF ,REST-TEMP
							       (VALUES (POP ,REST-TEMP) T)
							       (VALUES ,DEFAULT NIL)))
				 BINDINGS))
			  (T
			   (PUSH `(,VARIABLE (IF ,REST-TEMP
						 (POP ,REST-TEMP)
						 ,DEFAULT))
				 BINDINGS)))))
	      (UNLESS (ZEROP GENERIC-N-OPTIONAL-ARGUMENTS-REMAINING)
		(DECF GENERIC-N-OPTIONAL-ARGUMENTS-REMAINING))))
	  ;; Match the rest argument
	  (WHEN METHOD-COMBINATION-REST-P
	    ;; Get rid of &REST
	    (POP METHOD-COMBINATION-LAMBDA-LIST)
	    (PUSH `(,(POP METHOD-COMBINATION-LAMBDA-LIST)
		    ;; Skip over any optional arguments which were in the generic function
		    ;; lambda list but not matched by the method combination lambda list.
		    (SETQ ,REST-TEMP
			  (NTHCDR ,GENERIC-N-OPTIONAL-ARGUMENTS-REMAINING ,REST-TEMP)))
		  BINDINGS)
	    (SETQ GENERIC-N-OPTIONAL-ARGUMENTS-REMAINING 0))
	  ;; Match any keywords
	  (WHEN METHOD-COMBINATION-KEYWORDS
	    ;; Get rid of &KEY
	    (POP METHOD-COMBINATION-LAMBDA-LIST)
	    (LOOP WHILE METHOD-COMBINATION-LAMBDA-LIST
		  FOR SPEC = (POP METHOD-COMBINATION-LAMBDA-LIST)
		  DOING
	      (WHEN (OR (EQ SPEC '&ALLOW-OTHER-KEYS)
			(EQ SPEC '&AUX))
		(RETURN))
	      (MULTIPLE-VALUE-BIND (KEYWORD VARIABLE DEFAULT SUPPLIED-P)
		  (IF (SYMBOLP SPEC)
		      (VALUES (INTERN (SYMBOL-NAME SPEC) :KEYWORD)
			      SPEC
			      NIL
			      NIL)
		      (LET ((FIRST (FIRST SPEC)))
			(IF (SYMBOLP FIRST)
			    (VALUES (INTERN (SYMBOL-NAME FIRST) :KEYWORD)
				    FIRST
				    (SECOND SPEC)
				    (THIRD SPEC))
			    (VALUES (FIRST FIRST)
				    (SECOND FIRST)
				    (SECOND SPEC)
				    (THIRD SPEC)))))
		(COND ((AND REST-TEMP (OR GENERIC-REST-P GENERIC-KEYWORDS-P))
		       ;; Generic function has a rest argument or keys, so there may be
		       ;; something for the method combination argument.
		       (LET ((VAL-TEMP (FUNCALL SYMBOL-GENERATOR))
			     (SUPPLIED-TEMP (FUNCALL SYMBOL-GENERATOR)))
			 (PUSH `(,(IF SUPPLIED-P
				      `(,VARIABLE ,SUPPLIED-P)
				      VARIABLE)
				 #+IMACH
				 (MULTIPLE-VALUE-BIND (,VAL-TEMP ,SUPPLIED-TEMP)
				     (SYS:RGETF
				       ',KEYWORD
				       ,(IF (ZEROP GENERIC-N-OPTIONAL-ARGUMENTS-REMAINING)
					    REST-TEMP
					    ;; Skip over optional arguments in the
					    ;; generic function if they haven't been
					    ;; skipped over yet.
					    `(SETQ ,REST-TEMP
						   (NTHCDR
						     ,GENERIC-N-OPTIONAL-ARGUMENTS-REMAINING
						     ,REST-TEMP))))
				   (IF ,SUPPLIED-TEMP
				       ,(IF SUPPLIED-P
					    `(VALUES ,VAL-TEMP ,SUPPLIED-TEMP)
					    VAL-TEMP)
				       ,(IF SUPPLIED-P
					    `(VALUES ,DEFAULT NIL)
					    DEFAULT)))
				 #+Minima
				 (MULTIPLE-VALUE-BIND (,VAL-TEMP ,SUPPLIED-TEMP)
				     (IVORY:RGETF
				       ',KEYWORD
				       ,(IF (ZEROP GENERIC-N-OPTIONAL-ARGUMENTS-REMAINING)
					    REST-TEMP
					    ;; Skip over optional arguments in the
					    ;; generic function if they haven't been
					    ;; skipped over yet.
					    `(SETQ ,REST-TEMP
						   (NTHCDR
						     ,GENERIC-N-OPTIONAL-ARGUMENTS-REMAINING
						     ,REST-TEMP))))
				   (IF ,SUPPLIED-TEMP
				       ,(IF SUPPLIED-P
					    `(VALUES ,VAL-TEMP ,SUPPLIED-TEMP)
					    VAL-TEMP)
				       ,(IF SUPPLIED-P
					    `(VALUES ,DEFAULT NIL)
					    DEFAULT)))
				 #-(OR IMACH Minima)
				 (LET ((,VAL-TEMP
					(GETF
					  ;; Skip over optional arguments in the
					  ;; generic function if they haven't been
					  ;; skipped over yet.
					  ,(IF (ZEROP GENERIC-N-OPTIONAL-ARGUMENTS-REMAINING)
					       REST-TEMP
					       `(SETQ ,REST-TEMP
						      (NTHCDR
							,GENERIC-N-OPTIONAL-ARGUMENTS-REMAINING
							,REST-TEMP)))
					  ',KEYWORD
					  ',SUPPLIED-TEMP)))
				   ,(IF SUPPLIED-P
				       `(IF (EQ ,VAL-TEMP ',SUPPLIED-TEMP)
					    (VALUES ,DEFAULT NIL)
					    (VALUES ,VAL-TEMP T))
				       `(IF (EQ ,VAL-TEMP ',SUPPLIED-TEMP)
					    ,DEFAULT
					    ,VAL-TEMP))))
			       BINDINGS)))
		      (T
		       (PUSH `(,VARIABLE ,DEFAULT) BINDINGS)
		       (WHEN SUPPLIED-P
			 (PUSH `(,SUPPLIED-P NIL) BINDINGS)))))))
	  ;; Finally, the aux variables, which have nothing at all to do with the
	  ;; generic function lambda list.
	  (WHEN (EQ (FIRST METHOD-COMBINATION-LAMBDA-LIST) '&AUX)
	    (POP METHOD-COMBINATION-LAMBDA-LIST))
	  (LOOP WHILE METHOD-COMBINATION-LAMBDA-LIST
		FOR SPEC = (POP METHOD-COMBINATION-LAMBDA-LIST)
		DOING
	    (IF (SYMBOLP SPEC)
		(PUSH `(,SPEC NIL) BINDINGS)
		(PUSH `(,(FIRST SPEC) ,(SECOND SPEC)) BINDINGS)))

	  ;; For each CALL-METHOD in FORM, compute the extra argument and method function for
	  ;; that method.  These will eventually end up in the extra argument vector.
	  (MACROLET ((CONVERT-FORMS (FORM FORM-VAR CONDITION &BODY BODY)
		       #+Genera
		       `(LT:COPYFORMS
			  #'(LAMBDA (,FORM-VAR KIND USAGE)
			      (DECLARE (IGNORE USAGE))
			      (COND ((AND (CONSP ,FORM-VAR)
					  (LISTP KIND)
					  ,CONDITION)
				     (VALUES
				       (PROGN ,@BODY)
				       T))
				    (T ,FORM-VAR)))
			  ,FORM)
		       #+CLOE-Runtime
		       `(LABELS ((COPYFORMS-FUNCTION (,FORM-VAR CONTEXT)
				   (COND ((AND (EQ CONTEXT :FUNCTION-CALL)
					       (CONSP ,FORM-VAR)
					       ,CONDITION)
					  ,@BODY)
					 (T
					  (MAP-FORMS-RECURSE
					    #'COPYFORMS-FUNCTION ,FORM-VAR CONTEXT)))))
			  (MAP-FORMS-TOPLEVEL #'COPYFORMS-FUNCTION ,FORM))
		       #+Minima
		       `(LABELS ((WALK (,FORM-VAR)
				   (IF (CONSP ,FORM-VAR)
				       (IF ,CONDITION
					   (PROGN ,@BODY)
					   `(,(FIRST FORM) ,@(MAPCAR #'WALK (REST FORM))))
				       ,FORM-VAR)))
			  (WALK ,FORM))
		       #-(OR Genera CLOE-Runtime Minima)
		       `(NYI)))
	    (LABELS ((EXTRA-ARGUMENT-VALUE (OBJECT)
		       `(SVREF ,EXTRA-ARGUMENT
			       ,(OR (POSITION OBJECT EXTRA-ARGUMENT-VALUES)
				    (PROG1 (LENGTH EXTRA-ARGUMENT-VALUES)
					   (SETQ EXTRA-ARGUMENT-VALUES
						 (NCONC EXTRA-ARGUMENT-VALUES
							(LIST OBJECT)))))))
		     (CONVERT-CALL-METHOD (METHOD MORE-METHODS CALL-NEXT-METHOD-VALID-P)
		       ;; Return the method function to be called and the extra
		       ;; argument for that method function.
		       (APPLY
			 #'METHOD-FUNCTION-NAME-AND-EXTRA-ARGUMENT
			 GENERIC-FUNCTION
			 METHOD
			 #'(LAMBDA ()
			     ;; If METHOD calls CALL-NEXT-METHOD ...
			     (IF CALL-NEXT-METHOD-VALID-P
				 ;; and CALL-NEXT-METHOD is valid, ...
				 (IF MORE-METHODS
				     ;; if there are additional methods, make it
				     ;; call the first of them with the remaining
				     ;; ones as available next methods.
				     (CONVERT-CALL-METHOD (FIRST MORE-METHODS)
							  (REST MORE-METHODS)
							  T)
				     ;; otherwise make it call to
				     ;; CALL-NEXT-METHOD-NO-NEXT-METHOD with the
				     ;; method as the extra argument.
				     (VALUES 'CALL-NEXT-METHOD-NO-NEXT-METHOD METHOD))
				 ;; otherwise make it call
				 ;; CALL-NEXT-METHOD-INVALID passing it METHOD as
				 ;; the extra argument.
				 (VALUES 'CALL-NEXT-METHOD-INVALID METHOD)))
			 ARGUMENT-FUNCTION
			 :INTERNAL T
			 MY-KEYS)))

	      ;; Translate CALL-METHOD and MAKE-METHOD into genuine Lisp
	      (LET ((FORM
		      (CONVERT-FORMS
			FORM FORM (EQ (FIRST FORM) 'CALL-METHOD)
			(MULTIPLE-VALUE-BIND (MORE-METHODS CALL-NEXT-METHOD-VALID-P
					      ARGUMENT-SUBSTITUTIONS)
			    (IF (CDDDR FORM)	;extended CALL-METHOD syntax
				(VALUES (GETF (CDDR FORM) ':NEXT-METHODS)
					(LOOP FOR KEY IN (CDDR FORM) BY #'CDDR
					      THEREIS (EQ KEY ':NEXT-METHODS))
					(GETF (CDDR FORM) ':ARGUMENTS))
				(VALUES (THIRD FORM) (CDDR FORM) NIL))
			  (MULTIPLE-VALUE-BIND (FUNCTION-NAME EXTRA-ARGUMENT)
			      (CONVERT-CALL-METHOD (SECOND FORM) MORE-METHODS
						   CALL-NEXT-METHOD-VALID-P)
			    (SETQ CALL-METHOD-FUNCTION FUNCTION-NAME
				  CALL-METHOD-EXTRA-ARGUMENT EXTRA-ARGUMENT
				  CALL-METHOD-EXPANSION
				    (EXPAND-CALL-METHOD-FUNCTION
				      GENERIC-FUNCTION
				      (IF REST-ARGUMENT 'APPLY 'FUNCALL)
				      (IF USE-EXTRA-ARGUMENT
					  (EXTRA-ARGUMENT-VALUE (FDEFINITION FUNCTION-NAME))
					  #+Genera `(SCL:FUNCTION ,FUNCTION-NAME)
					  #-Genera `(FUNCTION ,FUNCTION-NAME))
				      (IF USE-EXTRA-ARGUMENT
					  (EXTRA-ARGUMENT-VALUE EXTRA-ARGUMENT)
					  `',EXTRA-ARGUMENT)
				      (APPEND REQUIRED-ARGUMENTS (IF REST-ARGUMENT
								     `(,REST-ARGUMENT)
								     NIL))
				      ARGUMENT-SUBSTITUTIONS)))))))

		;; Get rid of any simple useless junk which may be in the form
		(LOOP DOING
		  (COND ((AND (CONSP FORM)
			      (OR (EQ (CAR FORM) 'MULTIPLE-VALUE-PROG1)
				  (EQ (CAR FORM) 'PROGN))
			      (NULL (CDDR FORM)))
			 (SETQ FORM (CADR FORM)))
			(T (RETURN))))
		;; Wrap that form in bindings for DEFINE-METHOD-COMBINATION :ARGUMENTS
		(LOOP FOR (BINDING VALUE) IN BINDINGS DOING
		  (SETQ FORM
			(IF (SYMBOLP BINDING)
			    `(LET ((,BINDING ,VALUE))
			       #+(or Genera CLOE-Runtime) (DECLARE (COMPILER:VARIABLE-INLINABLE ,BINDING))
			       ,BINDING		;suppress compiler warning
			       ,FORM)
			    `(MULTIPLE-VALUE-BIND ,BINDING ,VALUE
			       #+(or Genera CLOE-Runtime) (DECLARE (COMPILER:VARIABLE-INLINABLE ,@BINDING))
			       ,@BINDING	;suppress compiler warning
			       ,FORM))))
		;; Now take care of checking for keywords, if that has to be done
		(SETQ FORM
		      (COND ((OR (NULL CHECK-KEYWORDS-P)
				 ;; Methods will call
				 ;; VALIDATE-KEYWORDS-INTERNAL-ALLOW-OTHER-KEYS.
				 (EQ KEYWORDS T))
			     FORM)
			    (T
			     `(PROGN (VALIDATE-KEYWORDS-INTERNAL
				       ,(IF USE-EXTRA-ARGUMENT
					    (EXTRA-ARGUMENT-VALUE KEYWORDS)
					    `',KEYWORDS)
				       (NTHCDR ,REST-POSITION ,REST-ARGUMENT))
				     ,FORM))))
		;; Optimize the common case
		(WHEN (EQ FORM CALL-METHOD-EXPANSION)
		  ;; We don't need a combined method since all form does is call one method
		  ;; with no argument substitutions and no code wrapped around it
		  (RETURN-FROM GENERATE-COMBINED-METHOD
		    (VALUES CALL-METHOD-FUNCTION CALL-METHOD-EXTRA-ARGUMENT)))
		;; Create an appropriate extra argument
		(WHEN (AND USE-EXTRA-ARGUMENT EXTRA-ARGUMENT-VALUES)
		  (SETQ EXTRA-ARGUMENT-VALUES
			(MAKE-ARRAY (LENGTH EXTRA-ARGUMENT-VALUES)
				    :INITIAL-CONTENTS EXTRA-ARGUMENT-VALUES)))
		#+Genera
		(WHEN (AND USE-EXTRA-ARGUMENT EXTRA-ARGUMENT-VALUES)
		  (SETQ FORM `(LET ((,EXTRA-ARGUMENT ,EXTRA-ARGUMENT))
				(DECLARE (SYS:ARRAY-REGISTER ,EXTRA-ARGUMENT))
				,FORM)))
		(LET ((LAMBDA
			(GENERIC-FUNCTION-MAKE-LAMBDA
			  GENERIC-FUNCTION
			  EXTRA-ARGUMENT
			  `(,@REQUIRED-ARGUMENTS
			    ,@(WHEN REST-ARGUMENT `(&REST ,REST-ARGUMENT)))
			  `(,@(UNLESS (AND USE-EXTRA-ARGUMENT EXTRA-ARGUMENT-VALUES)
				`((DECLARE (IGNORE ,EXTRA-ARGUMENT))))
			    ,@(WHEN REST-ARGUMENT
				`((DECLARE (DYNAMIC-EXTENT ,REST-ARGUMENT))))
			    ,FORM))))
		  (IF USE-EXTRA-ARGUMENT
		      (VALUES (MISCELLANEOUS-FUNCTION-FOR-LAMBDA
				(METHOD-COMBINATION-DEFINITION-NAME
				 (GENERIC-FUNCTION-METHOD-COMBINATION GENERIC-FUNCTION))
				LAMBDA)
			      EXTRA-ARGUMENT-VALUES)
		      (LET ((FUNCTION-NAME (MAKE-INSTANCE 'COMBINED-METHOD
							  :GENERIC-FUNCTION GENERIC-FUNCTION
							  :SPECIALIZERS SPECIALIZERS
							  :INTERNAL INTERNAL)))
			(CLOS-COMPILE FUNCTION-NAME LAMBDA)
			(VALUES FUNCTION-NAME
				NIL))))))))))))

(DEFUN EXPAND-CALL-METHOD-FUNCTION (GENERIC-FUNCTION APPLY FUNCTION-FORM EXTRA-ARGUMENT-FORM
				    ARGUMENTS ARGUMENT-SUBSTITUTIONS)
  (LET ((LAST (- (LENGTH ARGUMENTS) (IF (EQ APPLY 'APPLY) 1 0)))
	(LAST-ARGUMENT (CAR (LAST ARGUMENTS))))
    (LOOP FOR (INDEX SUBSTITUTE) ON ARGUMENT-SUBSTITUTIONS BY #'CDDR DO
      (IF (EQ APPLY 'APPLY)
	  ;; Pull-apply-arguments.  Can't use POP since the same arguments might get
	  ;; used for multiple method calls, and we don't have a way to change our
	  ;; caller's idea of the number of required-arguments.
	  (WHEN (>= INDEX LAST)
	    (SETQ ARGUMENTS `(,@(BUTLAST ARGUMENTS)
			      ,@(LOOP FOR I FROM 0 BELOW (- (1+ INDEX) LAST)
				      COLLECT `(NTH ,I ,LAST-ARGUMENT))
			      (NTHCDR ,(- (1+ INDEX) LAST) ,LAST-ARGUMENT))))
	  (ASSERT (< INDEX LAST)))
      (SETQ ARGUMENTS (APPEND (SUBSEQ ARGUMENTS 0 INDEX)
			      (LIST SUBSTITUTE)
			      (SUBSEQ ARGUMENTS (1+ INDEX)))))
    (APPLY #'GENERIC-FUNCTION-CALL-FORM GENERIC-FUNCTION APPLY
					FUNCTION-FORM EXTRA-ARGUMENT-FORM
					ARGUMENTS)))

;;; Compute keyword information appropriate for the applicable methods of a generic
;;; function.  CHECK-KEYWORDS-P indicates whether or not keywords should be checked.
;;; KEYWORDS is a list of allowable keywords, or T if all keywords are allowable.
(DEFUN KEYWORD-INFORMATION (GENERIC-FUNCTION METHODS)
  #+Genera (DECLARE (VALUES CHECK-KEYWORDS-P KEYWORDS))
  (MULTIPLE-VALUE-BIND (REQUIRED OPTIONAL REST KEYSP KEYWORDS ALLOW-OTHER-KEYS)
      (LAMBDA-LIST-COMPONENTS (GENERIC-FUNCTION-LAMBDA-LIST GENERIC-FUNCTION))
    (DECLARE (IGNORE REQUIRED OPTIONAL))
    (WHEN ALLOW-OTHER-KEYS
      ;; Just check that the rest argument has even length
      (RETURN-FROM KEYWORD-INFORMATION
	(VALUES T T)))
    (WHEN (AND (NULL KEYSP)
	       (NULL REST))
      ;; Nothing to check
      (RETURN-FROM KEYWORD-INFORMATION
	(VALUES NIL NIL)))
    (LET ((NO-KEYS-BUT-REST (AND (NULL KEYSP) REST)))
      ;; Even though the generic function may have a rest argument but not specify
      ;; keyword arguments, if any of the methods have keyword arguments, then we
      ;; must make sure the rest argument has even length.
      (DOLIST (METHOD METHODS)
	(MULTIPLE-VALUE-BIND (REQUIRED OPTIONAL REST METHOD-KEYSP KEYS ALLOW)
	    (LAMBDA-LIST-COMPONENTS (METHOD-LAMBDA-LIST METHOD))
	  (DECLARE (IGNORE REQUIRED OPTIONAL REST))
	  (WHEN (OR ALLOW (AND METHOD-KEYSP NO-KEYS-BUT-REST))
	    ;; There are keywords, but, either through &ALLOW-OTHER-KEYS or a rest
	    ;; argument, other keywords are allowed.
	    (RETURN-FROM KEYWORD-INFORMATION
	      (VALUES T T)))
	  (WHEN METHOD-KEYSP
	    (SETQ KEYSP T))
	  (MAPC #'(LAMBDA (KEY) (PUSHNEW KEY KEYWORDS)) KEYS)))
      (VALUES KEYSP KEYWORDS))))

;;; Updating instances
#+IMACH
(DEF-ASSEMBLED HANDLE-STANDARD-CLASS-UPDATE
  ;; The following would be needed if there were objects of standard class which
  ;; shared data types, but there are none.
;  (TAG SYS:DTP-CALL-INDIRECT (LOCF #'FAKE-INSTANCE-P))
;  (PACKED PUSH (FP 3))
;  (PACKED FINISH-CALL-N (EVAL (DPB SYS:VALUE-DISPOSITION-VALUE
;				   SYS:%%PACKED-INSTRUCTION-VALUE-DISPOSITION
;				   2)))
;  (PACKED BRANCH-FALSE (EVAL (- UPDATE HERE)))
;  (PACKED POP (FP 3))
;  UPDATE
  (TAG #.SYS:DTP-CALL-INDIRECT #.(LOCF #'UPDATE-STANDARD-CLASS-INSTANCE))
  (PACKED PUSH (FP 3))
  (PACKED FINISH-CALL-N #.(DPB SYS:VALUE-DISPOSITION-EFFECT
			       SYS:%%PACKED-INSTRUCTION-VALUE-DISPOSITION
			       2))
  (PACKED SYS:%GENERIC-DISPATCH 0)
  (SUFFIX (HANDLE-STANDARD-CLASS-UPDATE
	    (SYS:FUNCTION-PARENT HANDLE-STANDARD-CLASS-UPDATE DEF-ASSEMBLED))))

#+Minima
(DEFUN HANDLE-STANDARD-CLASS-UPDATE (SELECTOR ARG0 #|&REST MORE-ARGUMENTS|#)
  (DECLARE (IGNORE SELECTOR))
  (UPDATE-STANDARD-CLASS-INSTANCE ARG0)
  (IVORY:%GENERIC-DISPATCH))

#+|3600|
(DEFUN HANDLE-STANDARD-CLASS-UPDATE (ARG0 EXTRA-ARGUMENT SELECTOR &REST MORE-ARGUMENTS)
  (DECLARE (DYNAMIC-EXTENT MORE-ARGUMENTS))
  EXTRA-ARGUMENT
  (UPDATE-STANDARD-CLASS-INSTANCE ARG0)
  (APPLY (DISPATCHING-FUNCALLABLE-INSTANCE-FROM-SELECTOR SELECTOR) ARG0 MORE-ARGUMENTS))

(DEFVAR *STANDARD-CLASS-UPDATE-DISPATCH-TABLE*
	(MAKE-DISPATCH-TABLE 1 NIL NIL
			     #+Minima (HANDLER-PC-NO-ENTRY #'HANDLE-STANDARD-CLASS-UPDATE)
			     #-Minima #'HANDLE-STANDARD-CLASS-UPDATE))

#+IMACH
(DEF-ASSEMBLED HANDLE-FUNCALLABLE-STANDARD-CLASS-UPDATE
  ;; The following should always be true for a funcallable instance, since they
  ;; share the data type DTP-LEXICAL-CLOSURE.
;  (TAG SYS:DTP-CALL-INDIRECT (LOCF #'FAKE-INSTANCE-P))
;  (PACKED PUSH (FP 3))
;  (PACKED FINISH-CALL-N (EVAL (DPB SYS:VALUE-DISPOSITION-VALUE
;				   SYS:%%PACKED-INSTRUCTION-VALUE-DISPOSITION
;				   2)))
;  (PACKED BRANCH-FALSE (EVAL (- UPDATE HERE)))
  (PACKED MOVEM (SP 0))
  (PACKED POP (FP 3))
;  UPDATE
  (TAG #.SYS:DTP-CALL-INDIRECT #.(LOCF #'UPDATE-FUNCALLABLE-STANDARD-CLASS-INSTANCE))
  (PACKED PUSH (FP 3))
  (PACKED FINISH-CALL-N #.(DPB SYS:VALUE-DISPOSITION-EFFECT
			       SYS:%%PACKED-INSTRUCTION-VALUE-DISPOSITION
			       2))
  (PACKED SYS:%GENERIC-DISPATCH 0)
  (SUFFIX (HANDLE-FUNCALLABLE-STANDARD-CLASS-UPDATE
	    (SYS:FUNCTION-PARENT HANDLE-FUNCALLABLE-STANDARD-CLASS-UPDATE DEF-ASSEMBLED))))

;;; Can't really get here yet
#+|3600|
(DEFUN HANDLE-FUNCALLABLE-STANDARD-CLASS-UPDATE
       (ARG0 EXTRA-ARGUMENT SELECTOR &REST MORE-ARGUMENTS)
  (DECLARE (DYNAMIC-EXTENT MORE-ARGUMENTS))
  EXTRA-ARGUMENT
  (UPDATE-FUNCALLABLE-STANDARD-CLASS-INSTANCE ARG0)
  (APPLY (DISPATCHING-FUNCALLABLE-INSTANCE-FROM-SELECTOR SELECTOR) ARG0 MORE-ARGUMENTS))

;;; Can't really get here yet
#+Minima
(DEFUN HANDLE-FUNCALLABLE-STANDARD-CLASS-UPDATE (SELECTOR ARG0 #|&REST MORE-ARGUMENTS|#)
  (DECLARE (IGNORE SELECTOR))
  (ZL:::COMPILER:%INSTRUCTION ZL:::COMPILER:MOVEM (ZL:::COMPILER:SP 0))
  (SETF ARG0 (ZL:::COMPILER:%POP))
  (UPDATE-FUNCALLABLE-STANDARD-CLASS-INSTANCE ARG0)
  (IVORY:%GENERIC-DISPATCH))

(DEFVAR *FUNCALLABLE-STANDARD-CLASS-UPDATE-DISPATCH-TABLE*
	(MAKE-DISPATCH-TABLE 1 NIL NIL
			     #+Minima (HANDLER-PC-NO-ENTRY #'HANDLE-FUNCALLABLE-STANDARD-CLASS-UPDATE)
			     #-Minima #'HANDLE-FUNCALLABLE-STANDARD-CLASS-UPDATE))

(DEFUN UPDATE-STANDARD-CLASS-INSTANCE (INSTANCE &REST INITARGS &KEY &ALLOW-OTHER-KEYS)
  (DECLARE (DYNAMIC-EXTENT INITARGS))
  (APPLY #'UPDATE-INSTANCE-FOR-REDEFINED-CLASS-INTERNAL
	 INSTANCE (%INSTANCE-INSTANCE-INFORMATION INSTANCE) INSTANCE INITARGS))

(DEFUN UPDATE-FUNCALLABLE-STANDARD-CLASS-INSTANCE
       (FUNCALLABLE-INSTANCE &REST INITARGS &KEY &ALLOW-OTHER-KEYS)
  (DECLARE (DYNAMIC-EXTENT INITARGS))
  (APPLY #'UPDATE-INSTANCE-FOR-REDEFINED-CLASS-INTERNAL
	 FUNCALLABLE-INSTANCE
	 (%FUNCALLABLE-INSTANCE-INSTANCE-INFORMATION FUNCALLABLE-INSTANCE)
	 (%DISPATCH-INSTANCE-FROM-EXTRA-ARGUMENT
	   (%FUNCALLABLE-INSTANCE-EXTRA-ARGUMENT FUNCALLABLE-INSTANCE))
	 INITARGS))

#+Genera
(DEFUN ELEMENT-FORWARD (OLD-LOCATION NEW-LOCATION)
  (SYS:%P-STORE-TAG-AND-POINTER OLD-LOCATION SYS:DTP-ELEMENT-FORWARD NEW-LOCATION)
  NIL)

#+Minima
(DEFUN ELEMENT-FORWARD (OLD-LOCATION NEW-LOCATION)
  (LET ((NEW (IVORY:%SET-TAG NEW-LOCATION (IVORY:DATA-TYPE 'IVORY::ELEMENT-FORWARD))))
    (IVORY:%P-STORE-CONTENTS OLD-LOCATION NEW))
  NIL)

(DEFUN UPDATE-INSTANCE-FOR-REDEFINED-CLASS-INTERNAL
       (INSTANCE OLD-INFORMATION UNFORWARDED-OLD-SLOT-VECTOR &REST INITARGS)
  (DECLARE (DYNAMIC-EXTENT INITARGS))
  ;;In point of fact, unforwarded-old-slot-vector is just an instance
  ;;(but maybe forwarded  to a newer one).  "slots" is really an
  ;;instance in Genera.  It doesn't need to be  outside genera, except
  ;;that we still need to pass an equivalent instance pointer around  to
  ;;other functions (user update-instance methods or somesuch?).
  ;;Effectively, there  needs to be a different one of these methods for
  ;;each kind of "instance" implementation  (metaclass), e.g. instance,
  ;;funcallable-instance, structure.
  (LET ((DISCARDED-SLOTS NIL)
	(ADDED-SLOTS NIL)
	(PROPERTY-LIST NIL))
    (WITH-CLOS-LOCK
      (LET* ((CLASS (%CLASS-INSTANCE-INFORMATION-CLASS OLD-INFORMATION))
	     (NEW-INFORMATION (CLASS-INSTANCE-INFORMATION CLASS))
	     (OLD-SLOT-VECTOR
	       #+Genera (SYS:FOLLOW-STRUCTURE-FORWARDING UNFORWARDED-OLD-SLOT-VECTOR)
	       #+Minima (IVORY:%MEMORY-READ-ADDRESS UNFORWARDED-OLD-SLOT-VECTOR :CYCLE-TYPE 'IVORY::STRUCTURE-OFFSET :SET-CDR-NEXT T)
	       #-(OR Genera Minima) UNFORWARDED-OLD-SLOT-VECTOR))
	(WHEN (EQ OLD-INFORMATION NEW-INFORMATION)
	  ;; Someone already updated this instance
	  (RETURN-FROM UPDATE-INSTANCE-FOR-REDEFINED-CLASS-INTERNAL))
	(LET ((OLD-SLOT-DEFINITIONS
		(%CLASS-INSTANCE-INFORMATION-EFFECTIVE-SLOTS OLD-INFORMATION))
	      (NEW-SLOT-DEFINITIONS
		(%CLASS-INSTANCE-INFORMATION-EFFECTIVE-SLOTS NEW-INFORMATION))
	      (NEW-SLOT-VECTOR
		(ALLOCATE-SLOT-VECTOR CLASS #+Genera (SYS:%AREA-NUMBER OLD-SLOT-VECTOR))))
	  (INHIBIT-GC-FLIPS			; Don't let GC see partially forwarded
	    ;; Move the contents of the old slots into the new slots where appropriate,
	    ;; discard any old slots which aren't being retained.
	    (LOOP FOR OLD-SLOT IN OLD-SLOT-DEFINITIONS
		  FOR NAME = (SLOT-DEFINITION-NAME OLD-SLOT)
		  FOR OLD-LOCATION = (SLOT-DEFINITION-LOCATION OLD-SLOT)
		  FOR NEW-SLOT = (FIND NAME NEW-SLOT-DEFINITIONS :KEY #'SLOT-DEFINITION-NAME)
		  FOR NEW-LOCATION = (AND NEW-SLOT (SLOT-DEFINITION-LOCATION NEW-SLOT))
		  DOING
	      (MACROLET ((OLD-LOCATOR (&REST IGNORE) `(SLOT-DEFINITION-LOCATION OLD-SLOT))
			 (NEW-LOCATOR (&REST IGNORE) `(SLOT-DEFINITION-LOCATION NEW-SLOT)))
		(WHEN (OR (NULL NEW-SLOT)		;Deleted
			  (AND (TYPEP OLD-LOCATION 'INTEGER)	;Local
			       (NOT (TYPEP NEW-LOCATION 'INTEGER))))	;Not local
		  ;; Discard the slot, and put it in the property list if it is bound
		  (PUSH NAME DISCARDED-SLOTS)
		  (WHEN (BOUNDP-SLOT CLASS OLD-SLOT-VECTOR NAME %INSTANCE-REF OLD-LOCATOR)
		    (PUSH (READ-SLOT CLASS OLD-SLOT-VECTOR NAME %INSTANCE-REF OLD-LOCATOR)
			  PROPERTY-LIST)
		    (PUSH NAME PROPERTY-LIST)))
		(WHEN (TYPEP NEW-LOCATION 'INTEGER)
		  ;; Copy the old value
		  (WHEN (BOUNDP-SLOT CLASS OLD-SLOT-VECTOR NAME %INSTANCE-REF OLD-LOCATOR)
		    (LET ((VALUE (READ-SLOT CLASS OLD-SLOT-VECTOR NAME %INSTANCE-REF OLD-LOCATOR)))
		      (WRITE-SLOT VALUE CLASS NEW-SLOT-VECTOR NAME %INSTANCE-REF NEW-LOCATOR))))
		#+(or Genera Minima)
		(WHEN (TYPEP OLD-LOCATION 'INTEGER)
		  ;; Have to forward each slot someplace or the GC will get upset
		  (ELEMENT-FORWARD (LOCATE-SLOT CLASS OLD-SLOT-VECTOR NAME %INSTANCE-REF OLD-LOCATOR)
				   (IF (TYPEP NEW-LOCATION 'INTEGER)
				       (LOCATE-SLOT CLASS NEW-SLOT-VECTOR NAME %INSTANCE-REF NEW-LOCATOR)
				       (LIST NIL))))
		)))
	  (LOOP FOR NEW-SLOT IN NEW-SLOT-DEFINITIONS
		DOING
	    (WHEN (TYPEP (SLOT-DEFINITION-LOCATION NEW-SLOT) 'FIXNUM)
	      (LET ((NAME (SLOT-DEFINITION-NAME NEW-SLOT)))
		(UNLESS (FIND NAME OLD-SLOT-DEFINITIONS :KEY #'SLOT-DEFINITION-NAME)
		  (PUSH NAME ADDED-SLOTS)))))
	  #+Genera
	  (PROGN
	    (SYS:%P-STORE-TAG-AND-POINTER UNFORWARDED-OLD-SLOT-VECTOR
					  SYS:DTP-HEADER-FORWARD NEW-SLOT-VECTOR)
	    (SYS:%P-STORE-TAG-AND-POINTER OLD-SLOT-VECTOR
					  SYS:DTP-HEADER-FORWARD NEW-SLOT-VECTOR))
	  #+Minima
	  (PROGN
	    (IVORY:%MEMORY-WRITE
	      UNFORWARDED-OLD-SLOT-VECTOR
	      (IVORY:%SET-TAG NEW-SLOT-VECTOR (IVORY:DATA-TYPE 'IVORY::HEADER-FORWARD)))
	    (IVORY:%MEMORY-WRITE
	      OLD-SLOT-VECTOR
	      (IVORY:%SET-TAG NEW-SLOT-VECTOR (IVORY:DATA-TYPE 'IVORY::HEADER-FORWARD))))
	  #-(OR Genera Minima)
	  (INSTANCE-FORWARD INSTANCE NEW-SLOT-VECTOR))))
    ;; Compute the new slot names
    (APPLY #'UPDATE-INSTANCE-FOR-REDEFINED-CLASS
	   INSTANCE ADDED-SLOTS DISCARDED-SLOTS PROPERTY-LIST INITARGS)))

(DEFUN CHANGE-CLASS-INTERNAL (OLD-SLOT-VECTOR OLD-SLOTS NEW-SLOT-VECTOR NEW-SLOTS)
  #+Genera (SETQ OLD-SLOT-VECTOR (SYS:FOLLOW-STRUCTURE-FORWARDING OLD-SLOT-VECTOR))
  #+Minima (SETF OLD-SLOT-VECTOR
		 (IVORY:%MEMORY-READ-ADDRESS OLD-SLOT-VECTOR :CYCLE-TYPE 'IVORY::STRUCTURE-OFFSET :SET-CDR-NEXT T))
  (INHIBIT-GC-FLIPS				;Don't let GC see partially forwarded
    ;; Initialize the new local slots according to the old slots
    (LOOP FOR OLD-SLOT IN OLD-SLOTS
	  FOR NAME = (SLOT-DEFINITION-NAME OLD-SLOT)
	  FOR OLD-LOCATION = (SLOT-DEFINITION-LOCATION OLD-SLOT)
	  FOR NEW-SLOT = (FIND NAME NEW-SLOTS :KEY #'SLOT-DEFINITION-NAME)
	  FOR NEW-LOCATION = (AND NEW-SLOT (SLOT-DEFINITION-LOCATION NEW-SLOT))
	  DOING
      (COND (NEW-SLOT
	     ;; Copy the old value to the new value if the new slot is local
	     (WHEN (EQ (SLOT-DEFINITION-ALLOCATION NEW-SLOT) ':INSTANCE)
	       #+Genera
	       (SI:%P-COPY-Q
		 (ETYPECASE OLD-LOCATION
		   (FIXNUM (LOCF (%INSTANCE-REF OLD-SLOT-VECTOR OLD-LOCATION)))
		   (LOCATIVE OLD-LOCATION))
		 (LOCF (%INSTANCE-REF NEW-SLOT-VECTOR NEW-LOCATION)))
	       #+Minima
	       (IVORY:%P-STORE-CONTENTS		;preserve cdr-codes for Minima GC
		 (LOCF (%INSTANCE-REF NEW-SLOT-VECTOR NEW-LOCATION))
		 (IVORY:%MEMORY-READ (ETYPECASE OLD-LOCATION
				       (FIXNUM (LOCF (%INSTANCE-REF OLD-SLOT-VECTOR OLD-LOCATION)))
				       (LOCATIVE OLD-LOCATION))
				     :CYCLE-TYPE 'IVORY::SCAVENGE
				     :SET-CDR-NEXT NIL))
	       #+CLOE-Runtime
	       (SETF (%INSTANCE-REF NEW-SLOT-VECTOR NEW-LOCATION)
		     (ETYPECASE OLD-LOCATION
		       (FIXNUM (SYSTEM::%Q
				 (SYSTEM::%Q OLD-SLOT-VECTOR SYSTEM::INSTANCE$K-PTYPE SYSTEM::INSTANCE$P-DATA-ADDRESS)
				 SYSTEM::INSTANCE$K-PTYPE SYSTEM::INSTANCE$K-OVERHEAD
				 OLD-LOCATION))
		       (CONS (CAR OLD-LOCATION))))
	       #-(OR Genera CLOE-Runtime Minima) (NYI))
	     #+(or Genera Minima)
	     (WHEN (EQ (SLOT-DEFINITION-ALLOCATION OLD-SLOT) ':INSTANCE)
	       ;; Forward to the new slot
	       (ELEMENT-FORWARD (LOCF (%INSTANCE-REF OLD-SLOT-VECTOR OLD-LOCATION))
				(ETYPECASE NEW-LOCATION
				  (FIXNUM (LOCF (%INSTANCE-REF NEW-SLOT-VECTOR NEW-LOCATION)))
				  (LOCATIVE NEW-LOCATION)))))
	    (T
	     #+(or Genera Minima)
	     (WHEN (EQ (SLOT-DEFINITION-ALLOCATION OLD-SLOT) ':INSTANCE)
	       ;; Have to forward this slot to a black hole
	       (ELEMENT-FORWARD (LOCF (%INSTANCE-REF OLD-SLOT-VECTOR OLD-LOCATION))
				(LIST NIL))))))
    ;; Now replace the old slot vector with the new one
    #+Genera
    (SYS:%P-STORE-TAG-AND-POINTER
      OLD-SLOT-VECTOR
      SYS:DTP-HEADER-FORWARD
      NEW-SLOT-VECTOR)
    #+Minima
    (IVORY:%MEMORY-WRITE
      OLD-SLOT-VECTOR (IVORY:%SET-TAG NEW-SLOT-VECTOR (IVORY:DATA-TYPE 'IVORY::HEADER-FORWARD))))
  #-(OR Genera Minima)
  (INSTANCE-FORWARD OLD-SLOT-VECTOR NEW-SLOT-VECTOR)
  OLD-SLOT-VECTOR)

;;; METHODS should include at least the applicable methods.
(DEFUN SORT-APPLICABLE-METHODS (GENERIC-FUNCTION METHODS ARGUMENT-FUNCTION)
  (DECLARE (DYNAMIC-EXTENT ARGUMENT-FUNCTION))
  ;; Compute the precedence list for each required argument
  (LET* ((POSITIONS
	   (DISPATCHING-FUNCALLABLE-INSTANCE-PRECEDENCE-ORDER GENERIC-FUNCTION))
	 (CLASS-PRECEDENCE-LISTS
	   (MAPCAR
	     #'(LAMBDA (POSITION)
		 (CLASS-PRECEDENCE-LIST (FUNCALL ARGUMENT-FUNCTION 'CLASS POSITION)))
	     POSITIONS))
	 (WEIGHTS
	   (REVERSE
	     (LOOP WITH PRODUCT = 1
		   FOR CLASS-PRECEDENCE-LIST IN (REVERSE CLASS-PRECEDENCE-LISTS)
		   COLLECT PRODUCT
		   DO (SETF PRODUCT (* PRODUCT (1+ (LENGTH CLASS-PRECEDENCE-LIST)))))))
	 (SORT-KEYS-AND-METHODS NIL))
    (DOLIST (METHOD METHODS)
      (BLOCK DO-METHOD
	(LET ((INDEX 0))
	  (MAPC
	    #'(LAMBDA (WEIGHT CLASS-PREDENCE-LIST ARGUMENT-POSITION)
		(LET ((SPECIALIZER (NTH ARGUMENT-POSITION (METHOD-SPECIALIZERS METHOD))))
		  (IF (TYPEP SPECIALIZER 'LIST)
		      (MULTIPLE-VALUE-BIND (EQLP SPEC)
			  (FUNCALL ARGUMENT-FUNCTION 'EQL ARGUMENT-POSITION)
			(UNLESS (AND EQLP (EQL (SECOND SPECIALIZER) SPEC))
			  (RETURN-FROM DO-METHOD)))
		      (LET ((POSITION (POSITION SPECIALIZER CLASS-PREDENCE-LIST)))
			(UNLESS POSITION
			  (RETURN-FROM DO-METHOD))
			(INCF INDEX (* (1+ POSITION) WEIGHT))))))
	    WEIGHTS
	    CLASS-PRECEDENCE-LISTS
	    POSITIONS)
	  (PUSH (CONS INDEX METHOD) SORT-KEYS-AND-METHODS))))
    (MAPCAR #'CDR (SORT SORT-KEYS-AND-METHODS #'< :KEY #'CAR))))

(DEFUN GET-MAPPING-TABLE (FAMILY &REST INSTANCES)
  (DECLARE (DYNAMIC-EXTENT INSTANCES))
  ;; There ought to be an optimal way to do this, but this will do until things are
  ;; working smoothly.
  (WITH-NO-OTHER-PROCESSES
    (APPLY #'GET-MAPPING-TABLE-FOR-CLASSES
	   FAMILY
	   (MAPCAR #'(LAMBDA (INSTANCE)
		       (LET ((CLASS (CLASS-OF INSTANCE)))
			 (WHEN (INSTANCE-INFORMATION-OBSOLETE-P
				 (%INSTANCE-INFORMATION INSTANCE))
			   ;; Have to update the instance before doing anything else
			   (UPDATE-INSTANCE-USING-CLASS CLASS INSTANCE))
			 CLASS))
		   INSTANCES))))

(DEFUN EQL-METHOD-SPECIALIZER-P (SPEC)
  (AND (LISTP SPEC)
       (EQ (CAR SPEC) 'EQL)
       (CONSP (CDR SPEC))
       (NULL (CDDR SPEC))
       (VALUES T (SECOND SPEC))))

(DEFUN EQUIVALENT-SPECIALIZERS-P (SPEC1 SPEC2)
  (OR (EQ SPEC1 SPEC2)
      (MULTIPLE-VALUE-BIND (EQL1? OBJECT1)
	  (EQL-METHOD-SPECIALIZER-P SPEC1)
	(MULTIPLE-VALUE-BIND (EQL2? OBJECT2)
	    (EQL-METHOD-SPECIALIZER-P SPEC2)
	  (AND EQL1?
	       EQL2?
	       (EQL OBJECT1 OBJECT2))))))

(DEFUN EQUIVALENT-SPECIALIZER-LISTS-P (SPEC1 SPEC2)
  (AND (= (LENGTH SPEC1) (LENGTH SPEC2))
       (EVERY #'EQUIVALENT-SPECIALIZERS-P SPEC1 SPEC2)))

(DEFUN EQUIVALENT-QUALIFIERS-P (QUAL1 QUAL2)
  (LET ((QUAL1-PLACE QUAL1)
	(QUAL2-PLACE QUAL2))
    (LOOP DOING
      (IF (AND QUAL1-PLACE
	       QUAL2-PLACE)
	  (UNLESS (EQL (POP QUAL1-PLACE) (POP QUAL2-PLACE))
	    (RETURN-FROM EQUIVALENT-QUALIFIERS-P NIL))
	  (RETURN-FROM EQUIVALENT-QUALIFIERS-P (EQ QUAL1-PLACE QUAL2-PLACE))))))

;;; All miscellaneous functions are kept in an EQUAL hash table.  The name (generally
;;; the name of a method combination) and the lambda expressions must match for the
;;; compiled code to be used.  Otherwise, a new function is compiled and added to the
;;; table.
(DEFPARAMETER *MISCELLANEOUS-FUNCTION-TABLE* (CLOS-MAKE-HASH-TABLE :TEST #'EQUAL))

(DEFUN MISCELLANEOUS-FUNCTION-FOR-LAMBDA (NAME LAMBDA-EXPRESSION)
  (DECLARE (NOTINLINE MAKE-INSTANCE))
  (LET ((KEY (CONS NAME LAMBDA-EXPRESSION)))
    (WITH-CLOS-LOCK
      (OR (CLOS-GETHASH KEY *MISCELLANEOUS-FUNCTION-TABLE*)
	  (LET ((MISCELLANEOUS-FUNCTION
		  (MAKE-INSTANCE 'MISCELLANEOUS-FUNCTION
				 :LAMBDA-EXPRESSION LAMBDA-EXPRESSION
				 :NAME NAME)))
	    (LET (#+Genera (SYS:FDEFINE-FILE-PATHNAME NIL)
		  #+Genera (SI:PATCH-SOURCE-FILE-PATHNAME NIL))
	      (CLOS-COMPILE MISCELLANEOUS-FUNCTION LAMBDA-EXPRESSION))
	    (SETF (CLOS-GETHASH KEY *MISCELLANEOUS-FUNCTION-TABLE*) MISCELLANEOUS-FUNCTION)
	    MISCELLANEOUS-FUNCTION)))))

;;; Minima doesn't have a real compiler.
#-Minima
(DEFUN CLOS-COMPILE (SPEC LAMBDA)
  (COMPILE SPEC LAMBDA))

(DEFUN STATIC-COPY-TREE (TREE)
  #+Genera
  (SCL:COPY-TREE TREE SYS:PERMANENT-STORAGE-AREA)
  #+CLOE-Runtime
  (IF (CONSP TREE)
      (SYS::CONS-IN-AREA (STATIC-COPY-TREE (CAR TREE))
			 (STATIC-COPY-TREE (CDR TREE))
			 SYS::AKIND$K-STATIC)
      TREE)
  #-(OR Genera CLOE-Runtime)
  TREE)

#+(OR Genera Minima)
(DEFUN CLOS-INSTANCE-EQUALP (X Y)
  (LET ((XINFO (%INSTANCE-INSTANCE-INFORMATION X))
	(YINFO (%INSTANCE-INSTANCE-INFORMATION Y)))
    (AND (CLASS-INSTANCE-INFORMATION-P XINFO)
	 (CLASS-INSTANCE-INFORMATION-P YINFO)
	 (EQ (%CLASS-INSTANCE-INFORMATION-CLASS XINFO)
	     (%CLASS-INSTANCE-INFORMATION-CLASS YINFO))
	 (MEMBER (FIND-CLASS 'STRUCTURE-OBJECT)
		 (%CLASS-INSTANCE-INFORMATION-PRECEDENCE-LIST XINFO))
	 (LET ((SIZE (%INSTANCE-INFORMATION-SIZE XINFO)))
	   (AND (EQL SIZE (%INSTANCE-INFORMATION-SIZE YINFO))
		(DOTIMES (I (1- SIZE) T)
		  (LET ((XLOC (LOCF (%STRUCTURE-REF X I)))
			(YLOC (LOCF (%STRUCTURE-REF Y I))))
		    (IF (LOCATION-BOUNDP XLOC)
			(UNLESS (AND (LOCATION-BOUNDP YLOC)
				     (EQUALP (LOCATION-CONTENTS XLOC)
					     (LOCATION-CONTENTS YLOC)))
			  (RETURN NIL))
			(UNLESS (NOT (LOCATION-BOUNDP YLOC))
			  (RETURN NIL))))))))))
